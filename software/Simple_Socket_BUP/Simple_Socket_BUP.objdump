
Simple_Socket_BUP.elf:     file format elf32-littlenios2
Simple_Socket_BUP.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x08200200

Program Header:
    LOAD off    0x00001000 vaddr 0x04a80000 paddr 0x04a80000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x
    LOAD off    0x00001060 vaddr 0x08200060 paddr 0x08200060 align 2**12
         filesz 0x00053fdc memsz 0x0005ea8c flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  04a80000  04a80000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   000001a0  08200060  08200060  00001060  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0004bd30  08200200  08200200  00001200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00006020  0824bf30  0824bf30  0004cf30  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000020ec  08251f50  08251f50  00052f50  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0000aab0  0825403c  0825403c  0005503c  2**2
                  ALLOC, SMALL_DATA
  6 .ext_flash    00000000  04a80020  04a80020  0005503c  2**0
                  CONTENTS
  7 .descriptor_memory 00000000  08000000  08000000  0005503c  2**0
                  CONTENTS
  8 .onchip_ram   00000000  0825eaec  0825eaec  0005503c  2**0
                  CONTENTS
  9 .comment      00000023  00000000  00000000  0005503c  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00001d18  00000000  00000000  00055060  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   00067021  00000000  00000000  00056d78  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00015607  00000000  00000000  000bdd99  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0001daa2  00000000  00000000  000d33a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00008908  00000000  00000000  000f0e44  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    0000bace  00000000  00000000  000f974c  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0001ef9a  00000000  00000000  0010521a  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_alt_sim_info 00000050  00000000  00000000  001241b4  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00001e98  00000000  00000000  00124208  2**3
                  CONTENTS, READONLY, DEBUGGING
 19 .thread_model 00000006  00000000  00000000  00130892  2**0
                  CONTENTS, READONLY
 20 .cpu          00000003  00000000  00000000  00130898  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  0013089b  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  0013089c  2**0
                  CONTENTS, READONLY
 23 .sysid_hash   00000004  00000000  00000000  0013089d  2**0
                  CONTENTS, READONLY
 24 .sysid_base   00000004  00000000  00000000  001308a1  2**0
                  CONTENTS, READONLY
 25 .sysid_time   00000004  00000000  00000000  001308a5  2**0
                  CONTENTS, READONLY
 26 .stderr_dev   0000000b  00000000  00000000  001308a9  2**0
                  CONTENTS, READONLY
 27 .stdin_dev    0000000b  00000000  00000000  001308b4  2**0
                  CONTENTS, READONLY
 28 .stdout_dev   0000000b  00000000  00000000  001308bf  2**0
                  CONTENTS, READONLY
 29 .sopc_system_name 0000001a  00000000  00000000  001308ca  2**0
                  CONTENTS, READONLY
 30 .quartus_project_dir 00000023  00000000  00000000  001308e4  2**0
                  CONTENTS, READONLY
 31 .jdi          00007005  00000000  00000000  00130907  2**0
                  CONTENTS, READONLY
 32 .sopcinfo     000bd54f  00000000  00000000  0013790c  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
04a80000 l    d  .entry	00000000 .entry
08200060 l    d  .exceptions	00000000 .exceptions
08200200 l    d  .text	00000000 .text
0824bf30 l    d  .rodata	00000000 .rodata
08251f50 l    d  .rwdata	00000000 .rwdata
0825403c l    d  .bss	00000000 .bss
04a80020 l    d  .ext_flash	00000000 .ext_flash
08000000 l    d  .descriptor_memory	00000000 .descriptor_memory
0825eaec l    d  .onchip_ram	00000000 .onchip_ram
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simple_Socket_BUP_bsp//obj/HAL/src/crt0.o
08200244 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
082000d4 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_error_handler.c
00000000 l    df *ABS*	00000000 iniche_init.c
00000000 l    df *ABS*	00000000 led.c
00000000 l    df *ABS*	00000000 network_utilities.c
00000000 l    df *ABS*	00000000 simple_socket_server.c
08254048 l     O .bss	00000004 SSSCommand.4950
08254258 l     O .bss	000005f0 conn.4980
00000000 l    df *ABS*	00000000 tse_my_system.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 ctype_.c
0824d2e3 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 getc.c
00000000 l    df *ABS*	00000000 impure.c
08252088 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 perror.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 rget.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 strchr.c
00000000 l    df *ABS*	00000000 strerror.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strstr.c
08204054 l     F .text	00000104 critical_factorization
08204158 l     F .text	000003b0 two_way_long_needle
00000000 l    df *ABS*	00000000 vfprintf.c
0824dbb2 l     O .rodata	00000010 zeroes.4389
0824dbc2 l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 u_strerr.c
00000000 l    df *ABS*	00000000 vfprintf.c
0824dbd2 l     O .rodata	00000010 zeroes.4404
08208cac l     F .text	000000bc __sbprintf
0824dbe2 l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 dtoa.c
08209014 l     F .text	00000200 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
0820ab44 l     F .text	00000008 __fp_unlock
0820ab58 l     F .text	0000019c __sinit.part.1
0820acf4 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fputs.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 locale.c
082524cc l     O .rwdata	00000020 lc_ctype_charset
082524ac l     O .rwdata	00000020 lc_message_charset
082524ec l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 mprec.c
0824dc10 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 refill.c
0820dc14 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 vfprintf.c
0824dd44 l     O .rodata	00000010 blanks.4332
0824dd34 l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 vfprintf.c
0820f4f0 l     F .text	000000fc __sprint_r.part.0
0824dd64 l     O .rodata	00000010 blanks.4348
0824dd54 l     O .rodata	00000010 zeroes.4349
08210a7c l     F .text	000000bc __sbprintf
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_fstat.c
082144e8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
082145d4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_lseek.c
082146b4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
08253f08 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_env_lock.c
08253f0c l     O .rwdata	00000004 lockid
08254080 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
08253f10 l     O .rwdata	00000004 lockid
08254088 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
0821622c l     F .text	00000048 OS_InitMisc
08216274 l     F .text	0000006c OS_InitRdyList
082163e0 l     F .text	000000e4 OS_InitTCBList
0821614c l     F .text	000000e0 OS_InitEventList
082162e0 l     F .text	00000080 OS_InitTaskIdle
08216360 l     F .text	00000080 OS_InitTaskStat
08216650 l     F .text	00000074 OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
08218378 l     F .text	000000f4 OS_FlagTaskRdy
08218138 l     F .text	00000160 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
0821c428 l     F .text	00000034 alt_dev_reg
0825292c l     O .rwdata	0000106c jtag_uart_0
08253998 l     O .rwdata	00000124 lcd
08253abc l     O .rwdata	00000030 sgdma_rx
08253aec l     O .rwdata	00000030 sgdma_tx
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0821c978 l     F .text	000002a4 altera_avalon_jtag_uart_irq
0821cc1c l     F .text	00000104 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207.c
08253f8c l     O .rwdata	00000004 colstart
0821d3f8 l     F .text	000000b8 lcd_write_command
0821d4b0 l     F .text	000000d8 lcd_write_data
0821d588 l     F .text	000000d0 lcd_clear_screen
0821d658 l     F .text	000001ec lcd_repaint_screen
0821d844 l     F .text	000000cc lcd_scroll_up
0821d910 l     F .text	000002ac lcd_handle_escape
0821e0cc l     F .text	000000ac alt_lcd_16207_timeout
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
0821e358 l     F .text	0000003c alt_get_errno
0821ef88 l     F .text	000000bc alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
0821f0ec l     F .text	00000078 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_tse.c
082540e2 l     O .bss	00000001 tse_system_count.4813
082540e3 l     O .bss	00000001 is_init.4895
00000000 l    df *ABS*	00000000 ins_tse_mac.c
00000000 l    df *ABS*	00000000 alt_iniche_close.c
00000000 l    df *ABS*	00000000 alt_iniche_dev.c
00000000 l    df *ABS*	00000000 alt_iniche_read.c
00000000 l    df *ABS*	00000000 alt_iniche_write.c
00000000 l    df *ABS*	00000000 ipnet.c
00000000 l    df *ABS*	00000000 ipstart.c
08254870 l     O .bss	0000003c closers
082540f8 l     O .bss	00000004 nclosers
00000000 l    df *ABS*	00000000 igmp_cmn.c
00000000 l    df *ABS*	00000000 bsdsock.c
00000000 l    df *ABS*	00000000 cksum.c
08253fa8 l     O .rwdata	00000004 cksum_select
00000000 l    df *ABS*	00000000 in_utils.c
082548ac l     O .bss	00000018 tistring
00000000 l    df *ABS*	00000000 netmain.c
00000000 l    df *ABS*	00000000 tk_crnos.c
00000000 l    df *ABS*	00000000 dhcpclnt.c
0822ba50 l     F .text	000000ac dh_getlong
00000000 l    df *ABS*	00000000 dhcputil.c
00000000 l    df *ABS*	00000000 pktalloc.c
00000000 l    df *ABS*	00000000 q.c
00000000 l    df *ABS*	00000000 udp_open.c
00000000 l    df *ABS*	00000000 asm_cksum.o
0822d5ec l       .text	00000000 done
0822d47c l       .text	00000000 asm1
0822d5a8 l       .text	00000000 loop0
0822d4a4 l       .text	00000000 loop
0822d5c4 l       .text	00000000 fold
00000000 l    df *ABS*	00000000 brdutils.c
08254164 l     O .bss	00000004 kbd_init.4233
08254160 l     O .bss	00000004 cpu_statusreg
00000000 l    df *ABS*	00000000 osportco.c
00000000 l    df *ABS*	00000000 targnios.c
00000000 l    df *ABS*	00000000 nptcp.c
08254198 l     O .bss	00000004 in_tcptick
00000000 l    df *ABS*	00000000 rawsock.c
00000000 l    df *ABS*	00000000 sockcall.c
0823196c l     F .text	0000008c sockargs
08230c90 l     F .text	000001dc t_getname
00000000 l    df *ABS*	00000000 socket.c
00000000 l    df *ABS*	00000000 socket2.c
00000000 l    df *ABS*	00000000 soselect.c
00000000 l    df *ABS*	00000000 tcp_in.c
00000000 l    df *ABS*	00000000 tcp_out.c
08239460 l     F .text	000000c8 bld_options
00000000 l    df *ABS*	00000000 tcp_subr.c
00000000 l    df *ABS*	00000000 tcp_timr.c
00000000 l    df *ABS*	00000000 tcp_usr.c
00000000 l    df *ABS*	00000000 tcpport.c
00000000 l    df *ABS*	00000000 udpsock.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
0823bc5c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dev.c
0823bde0 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0823be0c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0823c2dc l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
0823c41c l     F .text	0000003c alt_get_errno
0823c458 l     F .text	000000c4 alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
0823c670 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_remap_cached.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_uncached_free.c
00000000 l    df *ABS*	00000000 alt_uncached_malloc.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
0823cbb8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000040 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 allports.c
082541d0 l     O .bss	00000004 inside_pktdemux
00000000 l    df *ABS*	00000000 timeouts.c
0823d4f4 l     F .text	0000018c check_interval_timers
082541dc l     O .bss	00000004 numtimers
00000000 l    df *ABS*	00000000 tk_misc.c
00000000 l    df *ABS*	00000000 alt_iniche_fcntl.c
00000000 l    df *ABS*	00000000 et_arp.c
082541e0 l     O .bss	00000004 arp_timer
082541e8 l     O .bss	00000004 cachetime
00000000 l    df *ABS*	00000000 iface.c
00000000 l    df *ABS*	00000000 ip.c
08254024 l     O .rwdata	00000004 uid
00000000 l    df *ABS*	00000000 ip_reasm.c
00000000 l    df *ABS*	00000000 ipdemux.c
00000000 l    df *ABS*	00000000 ipmc.c
00000000 l    df *ABS*	00000000 ipport.c
00000000 l    df *ABS*	00000000 ipraw.c
00000000 l    df *ABS*	00000000 iproute.c
00000000 l    df *ABS*	00000000 udp.c
08254228 l     O .bss	00000002 usocket
00000000 l    df *ABS*	00000000 igmp.c
00000000 l    df *ABS*	00000000 igmp2.c
00000000 l    df *ABS*	00000000 ipopt.c
00000000 l    df *ABS*	00000000 u_mctest.c
0825402c l     O .rwdata	00000004 iCounter.4951
00000000 l    df *ABS*	00000000 dhcsetup.c
00000000 l    df *ABS*	00000000 memdev.c
00000000 l    df *ABS*	00000000 parseip.c
082548c4 l     O .bss	0000001e nearBuf.4578
00000000 l    df *ABS*	00000000 tcpcksum.c
00000000 l    df *ABS*	00000000 in_pcb.c
00000000 l    df *ABS*	00000000 vfsfiles.c
00000000 l    df *ABS*	00000000 vfsport.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_fcntl.c
0824a17c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 icmp.c
08253ecc l     O .rwdata	00000018 dsts
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vprintf.c
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 vfprintfr_1.c
00000000 l    df *ABS*	00000000 alt_exit.c
082035a8 g     F .text	00000018 putchar
0825e5e8 g     O .bss	00000014 soq
0820d538 g     F .text	00000074 _mprec_log10
08220458 g     F .text	000000d8 alt_tse_get_mac_info
08253f5e g     O .rwdata	00000002 OSTaskNameSize
0820d624 g     F .text	0000008c __any_on
08211018 g     F .text	00000054 _isatty_r
0824dc1c g     O .rodata	00000028 __mprec_tinytens
0823f284 g     F .text	00000724 ip_write_internal
082147c4 g     F .text	000000bc alt_main
0824b714 g     F .text	00000090 strcpy
0822cd98 g     F .text	000000ac pk_free
082035c0 g     F .text	000000c0 _puts_r
0825e794 g     O .bss	00000100 alt_irq
08253d6c g     O .rwdata	00000009 rtp_priority
0821106c g     F .text	00000060 _lseek_r
0824b320 g     F .text	00000314 icmp_timex
0822e694 g     F .text	00000044 m_freem
08249b2c g     F .text	00000048 vgetc
0822d74c g     F .text	00000020 clock_c
082541b0 g     O .bss	00000004 tcp_optionbuf
0823eda4 g     F .text	00000070 if_getbynum
08218b98 g     F .text	000000cc OS_MemInit
08254150 g     O .bss	00000004 dsc_rlyerrs
08254140 g     O .bss	00000004 dsc_releases
082297fc g     F .text	0000006c TK_OSTaskQuery
0822d45c g       .text	00000000 asm_cksum
08224068 g     F .text	000000f0 marvell_cfg_rgmii
0821c3c8 g     F .text	00000060 OSTimeSet
08249a34 g     F .text	000000f8 vgetc_locked
0822df84 g     F .text	00000020 post_task_setup
082428e4 g     F .text	00000358 ipr_stats
0823ac88 g     F .text	00000118 tcp_attach
08253fb8 g     O .rwdata	00000004 reqlist_len
0822fa54 g     F .text	00000078 tcp_tick
08228a50 g     F .text	0000007c print_ipad
08229704 g     F .text	000000f8 tcp_wakeup
08212f58 g     F .text	00000088 .hidden __eqdf2
08254040 g     O .bss	00000004 last_flash_sector_offset
082540fc g     O .bss	00000004 igmp_timers_are_running
08200d98 g     F .text	000000e4 led_bit_toggle
08237e94 g     F .text	0000012c tcp_pulloutofband
08221654 g     F .text	00000210 alt_tse_phy_print_profile
08214ea0 g     F .text	00000610 OSEventPendMulti
0825eaec g       *ABS*	00000000 __alt_heap_start
0823cf3c g     F .text	00000024 OSTaskCreateHook
0822c5d4 g     F .text	00000068 dhc_ifacedone
08223e08 g     F .text	00000098 marvell_phy_cfg
08242c8c g     F .text	00000380 ip_rcv
082497d8 g     F .text	0000014c vfseek
08234040 g     F .text	00000108 soqremque
08244860 g     F .text	000007a8 udpdemux
08225790 g     F .text	00000104 tse_mac_close
082033fc g     F .text	0000003c printf
082541fc g     O .bss	00000004 rt_mib
08253f36 g     O .rwdata	00000002 OSMboxEn
0822c4f4 g     F .text	00000058 dhc_state_init
0824bc30 g     F .text	0000001c vsprintf
0821e4b8 g     F .text	00000110 alt_avalon_sgdma_do_sync_transfer
08215508 g     F .text	0000004c OSIntEnter
0821112c g     F .text	0000009c _wcrtomb_r
0820dfa4 g     F .text	0000005c __sseek
0820ae94 g     F .text	00000010 __sinit
08243af8 g     F .text	0000010c in_delmulti
08208d68 g     F .text	00000140 __swbuf_r
08254214 g     O .bss	00000004 so_evtmap_create
08253f46 g     O .rwdata	00000002 OSQEn
08247e94 g     F .text	00000088 in_pcballoc
08253fd4 g     O .rwdata	00000002 socket_defaults
0820bab0 g     F .text	0000007c _setlocale_r
0823dc80 g     F .text	00000454 send_arp
0820acfc g     F .text	00000068 __sfmoreglue
082488f0 g     F .text	00000338 vfopen_locked
0825404c g     O .bss	00000004 SSSLEDCommandQ
08214b74 g     F .text	000000cc __malloc_unlock
0823cfa4 g     F .text	00000020 OSTaskStatHook
0823d414 g     F .text	00000054 prep_modules
08228050 g     F .text	0000013c bsd_i_sockoptlen
08254090 g     O .bss	00000001 OSLockNesting
08253fb0 g     O .rwdata	00000004 xids
08203fa0 g     F .text	0000001c strerror
0822069c g     F .text	00000a88 getPHYSpeed
08248e34 g     F .text	00000044 vfclose
0825e688 g     O .bss	0000002c tcb
08253f84 g     O .rwdata	00000002 OSDataSize
0823c80c g     F .text	00000034 alt_remap_cached
08254091 g     O .bss	00000001 OSRunning
0823eaec g     F .text	000002b8 grat_arp
08201118 g     F .text	0000005c get_ip_addr
0824791c g     F .text	00000094 inet_pton
0823eee8 g     F .text	00000090 reg_type
0825e18c g     O .bss	000000f0 dhc_states
08226ecc g     F .text	00000174 igmp_fasttimo
08248fe0 g     F .text	0000005c vunlink_flag_open_files
0822c2bc g     F .text	00000080 dhc_halt
0821ebd0 g     F .text	000003b8 alt_avalon_sgdma_construct_descriptor_burst
08254134 g     O .bss	00000004 dsc_acks
0825e6b4 g     O .bss	000000e0 tcpstat
082421dc g     F .text	0000034c ip_reasm_copy_queued_fragments_into_reassy_buffer
0822ebe0 g     F .text	0000009c dtom
08239360 g     F .text	00000100 tcp_setpersist
0823102c g     F .text	0000018c t_getsockopt
082030b4 g     F .text	0000015c memmove
08254144 g     O .bss	00000004 dsc_naks
0822f030 g     F .text	000005b0 ip_output
0823cff0 g     F .text	00000020 OSInitHookBegin
0824b634 g     F .text	00000054 icmp_du
08253fac g     O .rwdata	00000004 num_net_tasks
08254238 g     O .bss	00000004 vfiles
08253f7c g     O .rwdata	00000002 OSTmrSize
082470ac g     F .text	00000114 dhc_main_ipset
0820ae7c g     F .text	00000018 _cleanup
082413b0 g     F .text	000002b8 ip_reasm_process_first_fragment
0820c6b4 g     F .text	000000a8 _Balloc
08201614 g     F .text	00000198 get_board_mac_addr
08254094 g     O .bss	00000004 OSIdleCtr
08254050 g     O .bss	00000004 SSSLEDLightshowSem
08223068 g     F .text	000001c4 alt_tse_phy_set_adv_1000
08253f98 g     O .rwdata	00000001 max_mac_system
08246008 g     F .text	000005c8 ip_setmoptions
0821f70c g     F .text	000009fc alt_tse_system_add_sys
08212fe0 g     F .text	000000dc .hidden __gtdf2
08247438 g     F .text	0000002c md_fseek
0823cdbc g       .text	00000000 OSStartTsk
08216998 g     F .text	000002d4 OS_TCBInit
08241668 g     F .text	00000088 ip_reassm
0822c33c g     F .text	000001b8 dhc_reclaim
0825ea74 g     O .bss	00000010 udp_mib
04a80000 g     F .entry	00000000 __reset
082317d0 g     F .text	000000d8 t_shutdown
082027d0 g     F .text	000001f0 sss_handle_receive
08231298 g     F .text	00000140 t_recvfrom
08253f82 g     O .rwdata	00000002 OSTmrWheelTblSize
08246794 g     F .text	000006b4 u_mctest_run
0821e720 g     F .text	00000078 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
08243c68 g     F .text	00000080 prep_ifaces
08254118 g     O .bss	00000001 to_netmain
0822ca48 g     F .text	000000c4 pk_alloc
08253f22 g     O .rwdata	00000002 OSEventSize
08200a10 g     F .text	00000298 alt_SSSErrorHandler
08254098 g     O .bss	00000001 OSPrioHighRdy
08210fbc g     F .text	0000005c _fstat_r
08251f68 g     O .rwdata	00000120 tse_mac_device
082294a4 g     F .text	00000048 tk_nettick
0823cf60 g     F .text	00000024 OSTaskDelHook
08254070 g     O .bss	00000004 errno
08203708 g     F .text	00000014 __srget
08235244 g     F .text	000000c4 in_pcbnotify
0820df20 g     F .text	00000008 __seofread
0823cd9c g       .text	00000000 OSStartHighRdy
0825e27c g     O .bss	00000014 lilfreeq
08200248 g     F .text	00000564 alt_uCOSIIErrorHandler
08243d10 g     F .text	0000002c evtmap_setup
0821ae64 g     F .text	000001e4 OSTaskCreateExt
0825411c g     O .bss	00000004 tcp_sleep_timeout
08234a08 g     F .text	000001b8 sbdrop
08254210 g     O .bss	00000004 net_system_exit
0825ea84 g     O .bss	00000068 icmp_mib
0820e2b4 g     F .text	0000123c ___svfiprintf_internal_r
08239df0 g     F .text	00000074 tcp_getseq
082440f4 g     F .text	000000b8 ip_raw_alloc
08223950 g     F .text	000004b8 alt_tse_phy_set_common_speed
08217c80 g     F .text	00000060 OSFlagPendGetFlagsRdy
08253f62 g     O .rwdata	00000002 OSTaskStatStkSize
0825dc60 g     O .bss	00000010 pmac_groups
0822ab64 g     F .text	00000a84 dhc_request
082328c0 g     F .text	0000074c soreceive
08216dfc g     F .text	00000308 OSFlagAccept
082191d0 g     F .text	000000b8 OSQFlush
08218c64 g     F .text	00000140 OSQAccept
08254078 g     O .bss	00000004 alt_argv
0825bee4 g       *ABS*	00000000 _gp
08242c3c g     F .text	00000050 ip_reasm_send_icmp_timex
0823ca80 g     F .text	00000138 usleep
08248e78 g     F .text	00000048 vfflush
0825e590 g     O .bss	00000040 resid_semaphore
0822890c g     F .text	00000144 hexdump
08241278 g     F .text	000000a0 ip_reasm_incr_mem_useage
08227530 g     F .text	00000080 igmp_leavegroup
0821acb8 g     F .text	000001ac OSTaskCreate
0821a7c8 g     F .text	000004f0 OSTaskChangePrio
0825408c g     O .bss	00000004 alt_heapsem
08239c3c g     F .text	000000f0 tcp_close
08216c6c g     F .text	00000190 OSDebugInit
0821b048 g     F .text	00000344 OSTaskDel
08249f4c g     F .text	0000005c vferror
0823ca28 g     F .text	00000058 alt_uncached_malloc
0821f210 g     F .text	00000060 tse_mac_initTransInfo2
08245444 g     F .text	000000bc udp_alloc
08253bd4 g     O .rwdata	00000180 alt_fd_list
0825a95c g     O .bss	00000370 OSFlagTbl
0825419c g     O .bss	00000008 mbstat
08202e74 g     F .text	00000070 _getc_r
08202ee4 g     F .text	00000088 getc
082035a0 g     F .text	00000008 _putchar_r
08215f2c g     F .text	000000b8 OS_EventTaskRemove
08245c50 g     F .text	00000144 igmpv2_chk_set_timer
082294ec g     F .text	00000030 TK_OSTimeDly
0823bfac g     F .text	00000090 alt_find_dev
08202f6c g     F .text	00000148 memcpy
0821f484 g     F .text	00000054 tse_mac_setMIImode
0825414c g     O .bss	00000004 dsc_rebind
0823d8a0 g     F .text	0000007c task_stats
0823043c g     F .text	00000050 DOMAIN_CHECK
0822f5e0 g     F .text	00000038 in_broadcast
08253f4c g     O .rwdata	00000002 OSRdyTblSize
08221124 g     F .text	00000048 alt_tse_phy_rd_mdio_addr
08254234 g     O .bss	00000004 vfsystems
08245394 g     F .text	000000b0 udp_socket
082540ec g     O .bss	00000004 MaxMtu
08234f20 g     F .text	00000140 sock_selscan
0820ab4c g     F .text	0000000c _cleanup_r
08214244 g     F .text	000000dc .hidden __floatsidf
08241050 g     F .text	000000c4 ip_reasm_match_frag_with_ire
082341a0 g     F .text	00000058 socantrcvmore
0821f270 g     F .text	000000e4 tse_mac_sTxWrite
08201e48 g     F .text	00000988 sss_exec_command
082033b8 g     F .text	00000014 perror
0823c3a0 g     F .text	0000007c alt_io_redirect
082130bc g     F .text	000000f4 .hidden __ltdf2
08254178 g     O .bss	00000004 netq_intmask
082478d0 g     F .text	0000004c hextoa
0824bf30 g       *ABS*	00000000 __DTOR_END__
082315cc g     F .text	00000204 t_send
0823bc98 g     F .text	000000d0 alt_close
082541a4 g     O .bss	00000002 select_wait
08203680 g     F .text	00000014 puts
0822902c g     F .text	00000044 std_out
0825dc80 g     O .bss	00000030 tse_iniche_dev_driver_data
08249b74 g     F .text	00000124 vfslookup_locked
08232180 g     F .text	00000098 soaccept
08214c40 g     F .text	00000120 OSEventNameGet
08253f30 g     O .rwdata	00000002 OSFlagMax
08203944 g     F .text	0000065c _strerror_r
0825e5fc g     O .bss	0000003c tcpmib
082319f8 g     F .text	00000098 t_errno
08243d3c g     F .text	000000d8 ip_raw_open
0820de04 g     F .text	00000074 __fpclassifyd
0822b948 g     F .text	00000108 dhc_decline
0820d494 g     F .text	000000a4 __ratio
08215554 g     F .text	000000f8 OSIntExit
08254028 g     O .rwdata	00000004 ipRoutes
08248f90 g     F .text	00000050 vfeof
08210a60 g     F .text	0000001c __vfiprintf_internal
0823a0d4 g     F .text	00000060 tcp_canceltimers
0822a3d0 g     F .text	000001e4 dhc_buildheader
08253f6a g     O .rwdata	00000002 OSTCBSize
0821e818 g     F .text	0000008c alt_avalon_sgdma_construct_mem_to_stream_desc_burst
08254099 g     O .bss	00000001 OSPrioCur
0821ce78 g     F .text	000002bc altera_avalon_jtag_uart_read
0824b6ec g     F .text	00000014 malloc
08254230 g     O .bss	00000004 inpcb_cachemiss
082033cc g     F .text	00000030 _printf_r
08247a90 g     F .text	000000c4 inet46_addr
0825422c g     O .bss	00000004 inpcb_cachehits
08202c6c g     F .text	00000064 .hidden __udivsi3
08253b94 g     O .rwdata	0000000b tcp_outflags
0825dcb0 g     O .bss	00000130 tse
08214610 g     F .text	000000a4 isatty
08220108 g     F .text	00000168 alt_tse_sys_enable_mdio_sharing
08253f50 g     O .rwdata	00000002 OSStkWidth
0824dc6c g     O .rodata	000000c8 __mprec_tens
08248768 g     F .text	00000070 vf_alloc_and_link_vop
08253f44 g     O .rwdata	00000002 OSPtrSize
08254200 g     O .bss	00000004 ipr_curr_mem
08226b84 g     F .text	00000070 exit_hook
08254100 g     O .bss	00000004 igmp_cticks
082203d8 g     F .text	00000080 alt_tse_get_mac_info_index
0825418c g     O .bss	00000004 mheap_sem_ptr
0823821c g     F .text	00000048 ip4_tcpmss
0820bb2c g     F .text	0000000c __locale_charset
08253f24 g     O .rwdata	00000002 OSEventTblSize
0825e9f8 g     O .bss	00000014 netlist
0823300c g     F .text	00000098 soshutdown
0823cd10 g       .text	00000000 OSCtxSw
0823d3a0 g     F .text	00000050 packet_check
0822b5e8 g     F .text	0000027c dhc_setip
0825e638 g     O .bss	00000014 mbufq
08232130 g     F .text	00000050 soabort
0825406c g     O .bss	00000004 __malloc_top_pad
0825409c g     O .bss	00000004 OSTCBList
0822d088 g     F .text	00000100 qdel
0823d1fc g     F .text	00000164 station_state
08244238 g     F .text	00000154 rt_lookup
082541bc g     O .bss	00000004 alt_fd_list_lock
08253ef0 g     O .rwdata	00000004 __mb_cur_max
082275b0 g     F .text	00000318 igmp_validate
0820bb5c g     F .text	0000000c _localeconv_r
082268e0 g     F .text	000002a4 ip_startup
08230748 g     F .text	00000254 t_accept
08233c38 g     F .text	00000098 soisdisconnecting
0820cac0 g     F .text	0000003c __i2b
0820b46c g     F .text	000004bc __sfvwrite_r
0821e950 g     F .text	0000005c alt_avalon_sgdma_stop
08226320 g     F .text	000003a4 pktdemux
0825accc g     O .bss	00000c30 OSMemTbl
082540a0 g     O .bss	00000001 OSTickStepState
082211c4 g     F .text	00000128 alt_tse_phy_wr_mdio_reg
0822d624 g     F .text	00000094 kbhit
08230e6c g     F .text	000001c0 t_setsockopt
0820de78 g     F .text	00000054 _sbrk_r
08253d54 g     O .rwdata	00000018 icmpdu_types
08221864 g     F .text	000006a4 alt_tse_mac_group_init
0824903c g     F .text	00000200 vunlink
08224560 g     F .text	00000a60 tse_mac_init
08253f48 g     O .rwdata	00000002 OSQMax
0822876c g     F .text	000000a4 ccksum
082487d8 g     F .text	000000c8 vf_alloc_buffer
08254224 g     O .bss	00000004 cachedRoute
08253fbc g     O .rwdata	00000004 lilbufs
0825b8fc g     O .bss	00000800 OSTaskStatStk
08247464 g     F .text	00000024 md_ftell
08228810 g     F .text	00000054 cksum
082187d4 g     F .text	000000f0 OSMemNameGet
08231d64 g     F .text	00000110 sofree
082540f4 g     O .bss	00000004 ifNumber
08253f28 g     O .rwdata	00000002 OSFlagEn
082110cc g     F .text	00000060 _read_r
08253f6e g     O .rwdata	00000002 OSTimeTickHookEn
0823bd68 g     F .text	00000078 alt_dcache_flush
08219680 g     F .text	00000168 OSQPost
0821846c g     F .text	000000a4 OS_FlagUnlink
08253ffc g     O .rwdata	00000004 alt_max_fd
08216518 g     F .text	00000068 OS_MemCopy
08253fc4 g     O .rwdata	00000004 bigbufs
0823ada0 g     F .text	000000cc tcp_disconnect
08216580 g     F .text	000000d0 OS_Sched
08210cb0 g     F .text	000000f0 _fclose_r
082186e4 g     F .text	000000f0 OSMemGet
0821b674 g     F .text	000001b4 OSTaskNameSet
0820ab14 g     F .text	00000030 fflush
08254068 g     O .bss	00000004 __malloc_max_sbrked_mem
082540a4 g     O .bss	00000004 OSCtxSwCtr
0825e104 g     O .bss	00000064 igmpstats
0823cfc4 g     F .text	0000002c OSTimeTickHook
0822aa80 g     F .text	000000e4 dhc_rx_offer
0822818c g     F .text	0000010c bsd_getsockopt
08253f32 g     O .rwdata	00000002 OSFlagNameSize
0825ea5c g     O .bss	00000018 ire_stats
08200ef0 g     F .text	000001d4 LEDManagementTask
0823afd8 g     F .text	000001a0 udp_soinput
0822cfd8 g     F .text	000000b0 putq
08215fe4 g     F .text	00000100 OS_EventTaskRemoveMulti
08254114 g     O .bss	00000004 iniche_net_ready
08211dc4 g     F .text	000008ac .hidden __adddf3
08215ddc g     F .text	00000150 OS_EventTaskWaitMulti
08249f04 g     F .text	00000048 isvfile
082331a0 g     F .text	00000430 sosetopt
0822934c g     F .text	000000e0 netmain
08238264 g     F .text	000000f8 tcp_mss
0820d23c g     F .text	0000010c __b2d
08247574 g     F .text	000002fc parse_ipad
08248748 g     F .text	00000020 get_vfopen_error
08253f4a g     O .rwdata	00000002 OSQSize
0821188c g     F .text	00000538 .hidden __umoddi3
082146f0 g     F .text	000000d4 lseek
0823d468 g     F .text	0000008c inet_timer
0821a130 g     F .text	0000020c OSSemPend
082213b8 g     F .text	0000029c alt_tse_phy_add_profile_default
08222ad0 g     F .text	00000598 alt_tse_phy_get_cap
08201abc g     F .text	000002c4 sss_send_menu
08253ee8 g     O .rwdata	00000004 _global_impure_ptr
08228cec g     F .text	00000154 print_eth
08248c28 g     F .text	00000050 vfopen
0823c6ac g     F .text	000000fc alt_read
0820d6b0 g     F .text	00000564 _realloc_r
082007ac g     F .text	00000264 alt_NetworkErrorHandler
08253f34 g     O .rwdata	00000002 OSLowestPrio
0825eaec g       *ABS*	00000000 __bss_end
0823c1ec g     F .text	000000f0 alt_iic_isr_register
0821e394 g     F .text	00000124 alt_avalon_sgdma_do_async_transfer
0822e58c g     F .text	00000108 m_free
0823d050 g     F .text	00000024 OSTCBInitHook
08225750 g     F .text	00000040 tse_mac_stats
0822cb0c g     F .text	0000028c pk_validate
08253f7a g     O .rwdata	00000002 OSTmrCfgTicksPerSec
0823c8dc g     F .text	00000108 alt_tick
082484c8 g     F .text	00000254 in_pcblookup
0822c6ec g     F .text	000000c0 find_opt
08211314 g     F .text	00000578 .hidden __udivdi3
0822e404 g     F .text	00000188 m_getnbuf
0822ce64 g     F .text	000000bc dump_buf_estats
08210f18 g     F .text	00000024 _fputwc_r
08222970 g     F .text	00000160 alt_tse_phy_check_link
082541f8 g     O .bss	00000004 arpRepsOut
08253f1c g     O .rwdata	00000002 OSEventEn
0824dc44 g     O .rodata	00000028 __mprec_bigtens
0820c8a4 g     F .text	00000104 __s2b
08253f76 g     O .rwdata	00000002 OSTmrCfgNameSize
08214320 g     F .text	000000a8 .hidden __floatunsidf
0823d074 g     F .text	000000f4 netmain_init
08223f84 g     F .text	000000e4 marvell_cfg_sgmii
082227b4 g     F .text	000001bc alt_tse_phy_restart_an
0820cf7c g     F .text	00000060 __mcmp
08254130 g     O .bss	00000004 dsc_requests
08239684 g     F .text	00000400 tcp_respond
0823b3b4 g     F .text	000002d4 udp4_sockbind
0825417c g     O .bss	00000004 old_mode
082272dc g     F .text	00000254 igmp_joingroup
0822f70c g     F .text	00000348 so_icmpdu
0820aeb4 g     F .text	00000018 __fp_lock_all
08254244 g     O .bss	00000004 vfs_dir_stale
0823c1a0 g     F .text	0000004c alt_ic_irq_enabled
0825dc70 g     O .bss	00000010 pphy_profiles
08242528 g     F .text	000000d8 ip_reasm_process_timer_tick
08249fa8 g     F .text	00000058 vclearerr
0822868c g     F .text	000000e0 bsd_setsockopt
0822eb8c g     F .text	00000054 mbuf_len
08218298 g     F .text	000000e0 OS_FlagInit
0823c840 g     F .text	0000009c alt_alarm_stop
08249ce0 g     F .text	000001cc strippath
08253fb4 g     O .rwdata	00000004 reqlist
08229590 g     F .text	00000174 tcp_sleep
0824bb98 g     F .text	0000001c strtol
08229c20 g     F .text	000007b0 dhc_upcall
0823ae6c g     F .text	000000d0 tcp_usrclosed
08000000 g       *ABS*	00000000 __alt_mem_descriptor_memory
08254168 g     O .bss	00000004 cticks_factor
08253f58 g     O .rwdata	00000002 OSTaskIdleStkSize
08247f74 g     F .text	00000210 in_pcbbind
082541c0 g     O .bss	00000004 alt_irq_active
08219d68 g     F .text	000000b0 OSSemAccept
082189d8 g     F .text	000000d8 OSMemPut
08218510 g     F .text	000001d4 OSMemCreate
082540a8 g     O .bss	00000004 OSIdleCtrMax
0820012c g     F .exceptions	000000d4 alt_irq_handler
08253bac g     O .rwdata	00000028 alt_dev_null
08253fd6 g     O .rwdata	00000001 tcprexmtthresh
08253f6c g     O .rwdata	00000002 OSTicksPerSec
0823ef78 g     F .text	00000094 if_killsocks
0823f9a8 g     F .text	00000220 ip_write
0824300c g     F .text	000005cc ip_rcv_phase2
08230c4c g     F .text	00000044 t_getsockname
0823099c g     F .text	0000026c t_connect
08253fd0 g     O .rwdata	00000004 TCPTV_MSL
0825e290 g     O .bss	00000010 memestats
0822269c g     F .text	00000118 alt_tse_phy_init
0822d6b8 g     F .text	0000005c getch
08253e4c g     O .rwdata	00000080 vfs_root_path
08230c08 g     F .text	00000044 t_getpeername
0821e9ac g     F .text	00000064 alt_avalon_sgdma_check_descriptor_status
08241318 g     F .text	00000098 ip_reasm_decr_mem_useage
0823432c g     F .text	00000088 soreserve
0823cd10 g       .text	00000000 OSIntCtxSw
0822e1c8 g     F .text	00000034 npalloc
0820c9a8 g     F .text	00000068 __hi0bits
08254220 g     O .bss	00000004 ipraw_eps
0822c7ac g     F .text	0000029c pk_init
08247264 g     F .text	0000015c md_fread
08224fc0 g     F .text	000002f8 tse_mac_raw_send
082141c4 g     F .text	00000080 .hidden __fixdfsi
0825e894 g     O .bss	00000064 intimers
08234404 g     F .text	0000004c sbrelease
08235388 g     F .text	000000f0 ifd_clr
08234cc0 g     F .text	00000090 sbdroprecord
08228e40 g     F .text	0000007c uslash
0823cbf4 g     F .text	000000f8 alt_write
082541f4 g     O .bss	00000004 arpRepsIn
08229aa0 g     F .text	00000088 dhc_get_srv_ipaddr
0823d680 g     F .text	00000160 in_timerset
082540ac g     O .bss	00000004 OSTCBFreeList
0821a33c g     F .text	0000016c OSSemPendAbort
0823835c g     F .text	00001004 tcp_output
082541cc g     O .bss	00000004 activehost
08253ff4 g     O .rwdata	00000008 alt_dev_list
08229148 g     F .text	00000204 parse_args
08254180 g     O .bss	00000004 global_TCPwakeup_setIndx
0820aee4 g     F .text	00000044 _fputc_r
08225a94 g     F .text	00000068 write
0821eaf0 g     F .text	00000080 alt_avalon_sgdma_enable_desc_poll
0822e1fc g     F .text	00000040 npfree
08203438 g     F .text	000000a0 _putc_r
0823e33c g     F .text	000002c0 arpReply
08228890 g     F .text	0000007c nextarg
08253f70 g     O .rwdata	00000002 OSVersionNbr
08241c54 g     F .text	00000530 ip_reasm_process_subsequent_fragments
08254034 g     O .rwdata	00000004 pton_error
08254124 g     O .bss	00000004 dsc_errors
082548e4 g     O .bss	00002000 SSSInitialTaskStk
0825dde0 g     O .bss	00000014 rcvdq
08235308 g     F .text	00000080 tcp_notify
08214524 g     F .text	000000b0 fstat
08202d50 g     F .text	00000024 fprintf
08232218 g     F .text	000000b8 soconnect
082441f0 g     F .text	00000048 ip_raw_maxalloc
082130bc g     F .text	000000f4 .hidden __ledf2
08224158 g     F .text	00000078 DP83848C_link_status_read
0822a5b4 g     F .text	000004cc dhc_discover
082018d8 g     F .text	000000a4 SSSCreateOSDataStructs
08248444 g     F .text	00000084 in_setpeeraddr
08253f18 g     O .rwdata	00000004 OSEndiannessTest
0822d714 g     F .text	00000038 clock_init
08248ec0 g     F .text	000000d0 vfgets
0823da04 g     F .text	00000180 et_send
0820ccf4 g     F .text	00000140 __pow5mult
0820f604 g     F .text	0000145c ___vfiprintf_internal_r
08254060 g     O .bss	00000004 __nlocale_changed
08202cd0 g     F .text	00000058 .hidden __umodsi3
08247870 g     F .text	00000060 inet_addr
082411e4 g     F .text	00000094 ip_reasm_check_mem_useage
082330a4 g     F .text	000000fc sorflush
0824bbb4 g     F .text	0000001c vprintf
0825e3a4 g     O .bss	000000fc global_tcb_ext
08240014 g     F .text	00000420 ip_fragment_lc
0825ddf4 g     O .bss	00000300 netstatic
0823050c g     F .text	00000164 t_bind
0821e798 g     F .text	00000080 alt_avalon_sgdma_construct_mem_to_stream_desc
08253f2a g     O .rwdata	00000002 OSFlagGrpSize
0822d384 g     F .text	000000d8 udp_close
0821e8a4 g     F .text	00000054 alt_avalon_sgdma_register_callback
0822dd3c g     F .text	000001fc alt_iniche_init
0825eaec g       *ABS*	00000000 end
0822d930 g     F .text	00000088 UNLOCK_NET_RESOURCE
08224308 g     F .text	00000258 prep_tse_mac
082311b8 g     F .text	000000e0 t_recv
0821dbbc g     F .text	00000510 altera_avalon_lcd_16207_write
0824923c g     F .text	0000018c vfread
0822623c g     F .text	000000e4 netclose
082029c0 g     F .text	000001b4 SSSSimpleSocketServerTask
0824b6a8 g     F .text	0000000c _atoi_r
0821f528 g     F .text	000001e4 alt_tse_phy_add_profile
08253fe0 g     O .rwdata	00000004 tcp_keepintvl
0821c830 g     F .text	00000148 altera_avalon_jtag_uart_init
082167e8 g     F .text	000000e4 OS_TaskStat
08254128 g     O .bss	00000004 dsc_discovers
08253f88 g     O .rwdata	00000004 tse_mac_name
08253b4c g     O .rwdata	00000018 tcp_protosw
0824bf30 g       *ABS*	00000000 __CTOR_LIST__
08254240 g     O .bss	00000004 vfopen_error
08380000 g       *ABS*	00000000 __alt_stack_pointer
082541b4 g     O .bss	00000004 tcp_maxidle
08254154 g     O .bss	00000004 firstudp
0821eb70 g     F .text	00000060 alt_avalon_sgdma_disable_desc_poll
0821f164 g     F .text	0000007c alt_avalon_timer_sc_init
082143c8 g     F .text	00000064 .hidden __clzsi2
0821d134 g     F .text	000002c4 altera_avalon_jtag_uart_write
0821e5c8 g     F .text	00000074 alt_avalon_sgdma_construct_mem_to_mem_desc
0820aea4 g     F .text	00000004 __sfp_lock_acquire
0820c554 g     F .text	000000e4 memchr
082164c4 g     F .text	00000054 OS_MemClr
08206a98 g     F .text	000021f8 ___vfprintf_internal_r
0823cde0 g     F .text	0000015c OSTaskStkInit
0820371c g     F .text	00000058 _sprintf_r
0821e6c0 g     F .text	00000060 alt_avalon_sgdma_construct_stream_to_mem_desc
0820b15c g     F .text	00000310 _free_r
08245d94 g     F .text	00000140 igmpv2_chk4_rtr_alert_opt
0820bb38 g     F .text	00000010 __locale_mb_cur_max
082318a8 g     F .text	000000c4 t_socketclose
082568e4 g     O .bss	00002000 LED7SegLightshowTaskStk
08215b34 g     F .text	00000198 OS_EventTaskRdy
0824bd64 g     F .text	00000180 __call_exitprocs
08203694 g     F .text	00000074 __srget_r
082252b8 g     F .text	000000ac tse_sgdmaRx_isr
082540b0 g     O .bss	00000001 OSCPUUsage
0825e0f4 g     O .bss	00000010 nets
0822d86c g     F .text	000000c4 LOCK_NET_RESOURCE
0822b864 g     F .text	000000e4 dhc_resetip
0825405c g     O .bss	00000004 __mlocale_changed
08225510 g     F .text	00000240 tse_mac_rcv
0823048c g     F .text	00000080 t_socket
08253ef4 g     O .rwdata	00000004 __malloc_sbrk_base
08200200 g     F .text	00000048 _start
0823d9bc g     F .text	00000048 etainit
082541c4 g     O .bss	00000004 _alt_tick_rate
0823d3f0 g     F .text	00000024 mcastlist
08219288 g     F .text	0000028c OSQPend
08204508 g     F .text	000003b0 strstr
0825e2a0 g     O .bss	000000f0 pktlog
08245930 g     F .text	00000134 igmpv2_process_report
082354f0 g     F .text	00000078 ifd_isset
0824474c g     F .text	00000114 del_route
0821ea10 g     F .text	00000054 alt_avalon_sgdma_open
08206a90 g     F .text	00000008 _user_strerror
0821bf34 g     F .text	00000104 OSTimeDly
082010c4 g     F .text	00000054 get_mac_addr
08231c94 g     F .text	000000d0 solisten
0820ce34 g     F .text	00000148 __lshift
082541c8 g     O .bss	00000004 _alt_nticks
082212ec g     F .text	000000cc alt_tse_phy_rd_mdio_reg
08225a24 g     F .text	00000070 read
0821c494 g     F .text	00000238 alt_sys_init
08239d2c g     F .text	0000004c tcp_quench
0820e0e4 g     F .text	000001d0 __ssprint_r
08228ebc g     F .text	00000170 ns_printf
0823ee14 g     F .text	000000d4 isbcast
0822d9b8 g     F .text	0000024c TK_NEWTASK
0824bc4c g     F .text	00000118 __register_exitproc
082540b1 g     O .bss	00000001 OSTaskCtr
08241114 g     F .text	000000d0 ip_reasm_determine_type_of_frag
082540e0 g     O .bss	00000001 phy_profile_count
0824b7a4 g     F .text	000000d0 strncmp
08220364 g     F .text	00000074 alt_tse_get_mac_group_index
0821c038 g     F .text	00000160 OSTimeDlyHMSM
08243e14 g     F .text	000000bc ip_raw_close
0820cafc g     F .text	000001f8 __multiply
08253d9c g     O .rwdata	000000b0 mdlist
0821cd20 g     F .text	00000068 altera_avalon_jtag_uart_close
08226dec g     F .text	000000e0 igmp_input
0823ff4c g     F .text	000000c8 ip_raw_write
082493c8 g     F .text	000003b0 vfwrite_locked
0824b874 g     F .text	000000ec strncpy
0825412c g     O .bss	00000004 dsc_offers
08254848 g     O .bss	00000028 __malloc_current_mallinfo
08253f1e g     O .rwdata	00000002 OSEventMax
08247b54 g     F .text	0000006c inet_setport
0820d348 g     F .text	0000014c __d2b
0821a4a8 g     F .text	00000110 OSSemPost
08237d0c g     F .text	00000188 tcp_dooptions
08254054 g     O .bss	00000004 SSSLEDEventFlag
08233b34 g     F .text	00000104 soisconnected
082156d8 g     F .text	000000dc OSSchedUnlock
08243ce8 g     F .text	00000028 netexit
08201174 g     F .text	000001bc get_serial_number
08254110 g     O .bss	00000004 nettick_wakes
0822116c g     F .text	00000058 alt_tse_phy_wr_mdio_addr
082541a8 g     O .bss	00000001 tcpprintfs
0823d7e0 g     F .text	0000009c in_timerkill
0824580c g     F .text	00000124 igmpv2_input
0825413c g     O .bss	00000004 dsc_declines
0821c6cc g     F .text	00000060 altera_avalon_jtag_uart_read_fd
08228864 g     F .text	0000002c do_trap
0824a3e0 g     F .text	000000dc alt_get_fd
08228298 g     F .text	000000f4 bsd_ioctl
082540b4 g     O .bss	00000004 OSMemFreeList
08215824 g     F .text	000000b0 OSStatInit
0822ee60 g     F .text	000001d0 tcp_rcv
08228ca4 g     F .text	00000048 panic
08254248 g     O .bss	00000004 vfs_open_files
0824a024 g     F .text	00000158 alt_busy_sleep
08226754 g     F .text	0000018c ip2mac
08218074 g     F .text	000000c4 OSFlagQuery
08235060 g     F .text	000001e4 sock_select
08246e48 g     F .text	00000264 dhc_setup
08239528 g     F .text	00000054 tcp_init
08254184 g     O .bss	00000004 cticks
08254119 g     O .bss	00000001 to_nettick
08253f54 g     O .rwdata	00000002 OSTaskCreateExtEn
08210b98 g     F .text	00000054 _close_r
08225afc g     F .text	000005e8 Netinit
0822dfa4 g     F .text	00000038 prep_armintcp
082439ac g     F .text	0000014c in_addmulti
0823957c g     F .text	00000108 tcp_template
08223628 g     F .text	00000328 alt_tse_phy_get_common_speed
0822ec7c g     F .text	00000070 remque
0824bbd0 g     F .text	00000010 _vprintf_r
082355cc g     F .text	00000410 tcp_reass
08247cf4 g     F .text	000001a0 tcp_cksum
0823b688 g     F .text	00000380 udp4_socksend
08248c78 g     F .text	000001bc vfclose_locked
08235478 g     F .text	00000078 ifd_set
0820c638 g     F .text	0000007c memcmp
08215b14 g     F .text	00000020 OS_Dummy
0821c78c g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0822c63c g     F .text	000000b0 dhc_set_state
082540f0 g     O .bss	00000004 NDEBUG
0825eaec g       *ABS*	00000000 __alt_stack_base
08254044 g     O .bss	00000004 last_flash_sector
0821c7dc g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
082343b4 g     F .text	00000050 sbreserve
082540e1 g     O .bss	00000001 mac_group_count
08243ed0 g     F .text	00000224 ip_raw_input
08202d74 g     F .text	000000cc _fwrite_r
08253fc0 g     O .rwdata	00000004 lilbufsiz
08235568 g     F .text	00000064 ifd_get
082342a0 g     F .text	0000008c sbwakeup
08208ec0 g     F .text	00000154 __swsetup_r
082241d0 g     F .text	00000138 altera_eth_tse_init
0825c0fc g     O .bss	000001e0 OSQTbl
08237fc0 g     F .text	0000025c tcp_xmit_timer
08225364 g     F .text	000001ac tse_sgdma_read_init
08212670 g     F .text	000008e8 .hidden __divdf3
0820ad64 g     F .text	00000118 __sfp
082014d8 g     F .text	0000013c generate_mac_addr
0823f0f4 g     F .text	00000190 ip_bldhead
0820d5ac g     F .text	00000078 __copybits
08234450 g     F .text	000000a0 sbappend
08252524 g     O .rwdata	00000408 __malloc_av_
0820aeb0 g     F .text	00000004 __sinit_lock_release
082540b8 g     O .bss	00000004 OSTCBHighRdy
082131b0 g     F .text	00000718 .hidden __muldf3
0823fbc8 g     F .text	00000384 ip_write2
0820decc g     F .text	00000054 __sread
08254020 g     O .rwdata	00000004 arp_ageout
082540bc g     O .bss	00000004 OSQFreeList
08221f08 g     F .text	00000424 alt_tse_mac_get_phy
0823f00c g     F .text	000000e8 ip_init
0824a2d8 g     F .text	00000108 alt_find_file
082441ac g     F .text	00000044 ip_raw_free
0823e240 g     F .text	000000fc make_arp_entry
0823be48 g     F .text	000000a4 alt_dev_llist_insert
08214a54 g     F .text	00000120 __malloc_lock
08202d28 g     F .text	00000028 _fprintf_r
08214880 g     F .text	000000b0 sbrk
0823af7c g     F .text	0000005c udp_lookup
082048b8 g     F .text	000021d8 ___svfprintf_internal_r
0821e8f8 g     F .text	00000058 alt_avalon_sgdma_start
08214d60 g     F .text	00000140 OSEventNameSet
0820aab8 g     F .text	0000005c _fflush_r
08220610 g     F .text	0000008c alt_tse_mac_set_duplex
08210bec g     F .text	000000c4 _calloc_r
0822e0e8 g     F .text	000000e0 npfree_base
082540c0 g     O .bss	00000001 OSRdyGrp
08247218 g     F .text	00000028 md_fopen
08253b64 g     O .rwdata	00000018 udp_protosw
08253f00 g     O .rwdata	00000008 alt_flash_dev_list
082483c0 g     F .text	00000084 in_setsockaddr
0825403c g       *ABS*	00000000 __bss_start
08200e7c g     F .text	00000074 LED7SegLightshowTask
082344f0 g     F .text	000000d8 sbappendrecord
0825ea0c g     O .bss	00000050 ip_mib
08203210 g     F .text	00000128 memset
082322d0 g     F .text	00000098 sodisconnect
08200d18 g     F .text	00000080 main
0825407c g     O .bss	00000004 alt_envp
08254064 g     O .bss	00000004 __malloc_max_total_mem
08201a4c g     F .text	00000070 sss_reset_connection
0822e9cc g     F .text	000001c0 m_adj
0821c72c g     F .text	00000060 altera_avalon_jtag_uart_write_fd
08208ea8 g     F .text	00000018 __swbuf
08247488 g     F .text	000000c8 md_fgetc
0824de88 g     O .rodata	00000100 OSUnMapTbl
08240a9c g     F .text	000002a8 ip_dump
08229898 g     F .text	00000208 tk_stats
08253f9c g     O .rwdata	00000008 alt_iniche_dev_list
082588e4 g     O .bss	00000078 SSSLEDCommandQTbl
0821e178 g     F .text	00000180 altera_avalon_lcd_16207_init
08253f90 g     O .rwdata	00000008 alt_sgdma_list
08253f4e g     O .rwdata	00000002 OSSemEn
0825416c g     O .bss	00000004 OS_TPS
0822fcf0 g     F .text	0000074c rawip_usrreq
08217ce0 g     F .text	00000394 OSFlagPost
0820e000 g     F .text	00000008 __sclose
08247a34 g     F .text	0000005c print46_addr
08380000 g       *ABS*	00000000 __alt_heap_limit
08210da0 g     F .text	00000014 fclose
08215ccc g     F .text	00000110 OS_EventTaskWait
0824b960 g     F .text	00000238 _strtol_r
08228acc g     F .text	000001d8 print_uptime
082168cc g     F .text	000000cc OS_TaskStatStkChk
0821b38c g     F .text	00000150 OSTaskDelReq
08209214 g     F .text	00001688 _dtoa_r
0820bd48 g     F .text	0000080c _malloc_r
08247550 g     F .text	00000024 md_unlink
0821f3fc g     F .text	00000088 tse_mac_SwReset
08211288 g     F .text	00000030 __ascii_wctomb
08247f1c g     F .text	00000058 in_pcbdetach
08254000 g     O .rwdata	00000004 alt_errno
08254030 g     O .rwdata	00000004 mdlist_size
082157b4 g     F .text	00000070 OSStart
08246760 g     F .text	00000034 u_mctest_init
082149f4 g     F .text	00000060 __env_unlock
0820b928 g     F .text	000000c4 _fwalk
0821b828 g     F .text	000001d4 OSTaskResume
08218ab0 g     F .text	000000e8 OSMemQuery
08247bc0 g     F .text	00000134 convert_ip
0823e0d4 g     F .text	0000016c find_oldest_arp
08253f60 g     O .rwdata	00000002 OSTaskStatEn
082541ec g     O .bss	00000004 arpReqsIn
082488a0 g     F .text	00000050 vf_free_buffer
0824a1b8 g     F .text	00000120 alt_fcntl
08253f3a g     O .rwdata	00000002 OSMemMax
082197e8 g     F .text	00000170 OSQPostFront
0822d5f0 g     F .text	00000034 dtrap
08253fcc g     O .rwdata	00000004 kb_last
082034d8 g     F .text	000000c8 putc
08202b74 g     F .text	00000084 .hidden __divsi3
082202b0 g     F .text	00000048 alt_tse_mac_set_common_speed
082540c1 g     O .bss	00000003 OSRdyTbl
08253f14 g     O .rwdata	00000002 OSDebugEn
0822dfdc g     F .text	0000010c npalloc_base
08226bf4 g     F .text	000000d0 ip_exit
0820b038 g     F .text	00000124 _malloc_trim_r
0824bf30 g       *ABS*	00000000 __CTOR_END__
08253f2c g     O .rwdata	00000002 OSFlagNodeSize
08254120 g     O .bss	00000004 dhc_conn
0822d76c g     F .text	0000005c cticks_hook
08253f74 g     O .rwdata	00000002 OSTmrCfgMax
0823d360 g     F .text	00000040 sysuptime
0820e008 g     F .text	000000dc strcmp
08201330 g     F .text	000001a8 generate_and_store_mac_addr
08242600 g     F .text	000001b4 ip_reasm_delete_ire
08218da4 g     F .text	000001ac OSQCreate
0822d7c8 g     F .text	00000060 irq_Mask
0821b4dc g     F .text	00000198 OSTaskNameGet
082541d4 g     O .bss	00000004 nextppp
0825415c g     O .bss	00000004 irq_level
082260e4 g     F .text	00000158 fixup_subnet_mask
08219958 g     F .text	0000020c OSQPostOpt
082158d4 g     F .text	00000220 OSTimeTick
08240f1c g     F .text	00000134 ip_copypkt
0822c54c g     F .text	00000088 dhc_alldone
08253f5c g     O .rwdata	00000002 OSTaskMax
0824bf30 g       *ABS*	00000000 __DTOR_LIST__
08219e18 g     F .text	000000d8 OSSemCreate
08254104 g     O .bss	00000004 igmp_all_hosts_group
08253f80 g     O .rwdata	00000002 OSTmrWheelSize
082341f8 g     F .text	0000003c sbselqueue
0825410c g     O .bss	00000004 netmain_wakes
0823e5fc g     F .text	00000264 arprcv
0822951c g     F .text	00000074 TK_OSTaskResume
082278c8 g     F .text	0000041c igmp_print_stats
08212f58 g     F .text	00000088 .hidden __nedf2
0822e2b0 g     F .text	00000090 pffindtype
08253f56 g     O .rwdata	00000002 OSTaskDelEn
08253fe4 g     O .rwdata	00000004 tcp_sendspace
08249924 g     F .text	00000110 vftell
0825e168 g     O .bss	00000012 eth_prt_buf
0821a5b8 g     F .text	00000110 OSSemQuery
08218f50 g     F .text	00000280 OSQDel
08219514 g     F .text	0000016c OSQPendAbort
0821c45c g     F .text	00000038 alt_irq_init
08220270 g     F .text	00000040 alt_tse_mac_get_common_speed
0825e5d0 g     O .bss	00000018 app_semaphore
0823c7a8 g     F .text	00000064 alt_release_fd
0822dcc0 g     F .text	0000007c post_app_sem
08226d48 g     F .text	000000a4 igmp_init
08203774 g     F .text	0000006c sprintf
0824dd74 g     O .rodata	00000100 .hidden __clz_tab
08254148 g     O .bss	00000004 dsc_renew
082473c0 g     F .text	00000078 md_fwrite
08254058 g     O .bss	00000004 _PathLocale
08254170 g     O .bss	00000004 tcp_sleep_count
0822ecec g     F .text	0000007c insque
0824b688 g     F .text	00000014 atexit
0825423c g     O .bss	00000004 vfsfiles
08210b38 g     F .text	00000060 _write_r
0824bbe0 g     F .text	00000050 _vsprintf_r
08245008 g     F .text	00000298 udp_send
0821564c g     F .text	0000008c OSSchedLock
08227040 g     F .text	0000029c igmp_send
0820bb68 g     F .text	00000018 setlocale
08217104 g     F .text	00000108 OSFlagCreate
0825895c g     O .bss	00002000 LEDManagementTaskStk
0822d828 g     F .text	00000044 irq_Unmask
08230670 g     F .text	000000d8 t_listen
08253eec g     O .rwdata	00000004 _impure_ptr
08251f50 g     O .rwdata	00000018 ssstask
08254074 g     O .bss	00000004 alt_argc
0823a5b4 g     F .text	000006d4 tcp_usrreq
0823b178 g     F .text	0000023c udp_usrreq
0822e23c g     F .text	00000034 ncpalloc
0820a89c g     F .text	0000021c __sflush_r
0823bf4c g     F .text	00000060 _do_dtors
0820bb54 g     F .text	00000008 __locale_cjk_lang
08253f26 g     O .rwdata	00000002 OSEventMultiEn
08254018 g     O .rwdata	00000004 pingdelay
0823dc0c g     F .text	00000074 arp_send_pending
0825db80 g     O .bss	000000e0 tse_mac_if
08245568 g     F .text	000002a4 igmpv1_input
0820dc30 g     F .text	000001d4 __srefill_r
0822df38 g     F .text	0000004c pre_task_setup
08254190 g     O .bss	00000004 rcvdq_sem_ptr
08227f2c g     F .text	00000124 bsd_getsockname
082427b4 g     F .text	00000130 ip_reasm_mark_compact_rfq
082017ac g     F .text	0000012c FindLastFlashSectorOffset
0821720c g     F .text	00000248 OSFlagDel
082540c4 g     O .bss	00000004 OSEventFreeList
08229bd8 g     F .text	00000048 dhc_set_callback
08200060 g       .exceptions	00000000 alt_irq_entry
082541e4 g     O .bss	00000004 arpcache
0824b020 g     F .text	00000300 icmp_destun
08243c04 g     F .text	00000064 lookup_mcast
08249c98 g     F .text	00000048 vfslookup
082435d8 g     F .text	000003d4 ip_demux
0820d1d8 g     F .text	00000064 __ulp
08254174 g     O .bss	00000004 tcp_wakeup_count
082176c8 g     F .text	000005b8 OSFlagPend
08253f72 g     O .rwdata	00000002 OSTmrEn
0820aecc g     F .text	00000018 __fp_unlock_all
0822dc04 g     F .text	000000bc wait_app_sem
0821e2f8 g     F .text	00000060 altera_avalon_lcd_16207_write_fd
0820af28 g     F .text	0000005c fputc
08253fa4 g     O .rwdata	00000004 ipmcfail_str
08254188 g     O .bss	00000004 memtrapsize
0822e6d8 g     F .text	000002f4 m_copy
08253fec g     O .rwdata	00000008 alt_fs_list
0825e64c g     O .bss	00000014 mfreeq
082166c4 g     F .text	00000074 OS_StrCopy
08231c38 g     F .text	0000005c sobind
082471c0 g     F .text	00000058 init_memdev
0825403c g     O .bss	00000001 to_ssstask
0822ed68 g     F .text	000000f8 nptcp_init
08253f3c g     O .rwdata	00000002 OSMemNameSize
0825e4a0 g     O .bss	000000f0 global_TCPwakeup_set
0823d010 g     F .text	00000020 OSInitHookEnd
08233cd0 g     F .text	000000c4 soisdisconnected
0823db84 g     F .text	00000088 arp_free_pending
08253f68 g     O .rwdata	00000002 OSTCBPrioTblMax
0820bb80 g     F .text	0000000c localeconv
08231e74 g     F .text	000002bc soclose
0825e390 g     O .bss	00000014 bigfreeq
08253f64 g     O .rwdata	00000002 OSTaskStatStkChkEn
08254014 g     O .rwdata	00000004 prompt
08253fdc g     O .rwdata	00000004 tcp_keepidle
08223480 g     F .text	000001a8 alt_tse_phy_set_adv_10
0822fb28 g     F .text	000001c8 rawip_soinput
0823c03c g     F .text	00000050 alt_ic_isr_register
08249778 g     F .text	00000060 vfwrite
08253f38 g     O .rwdata	00000002 OSMemEn
08233f94 g     F .text	000000ac soqinsque
08254218 g     O .bss	00000004 so_evtmap_delete
08202e40 g     F .text	00000034 fwrite
08253f42 g     O .rwdata	00000002 OSMutexEn
08254204 g     O .bss	00000004 h_ireq
0825403c g       *ABS*	00000000 _edata
08240434 g     F .text	000005c4 ip_fragment
082258dc g     F .text	00000148 iniche_devices_init
0825e660 g     O .bss	00000028 tcp_saveti
08229070 g     F .text	000000d8 con_page
0825eaec g       *ABS*	00000000 _end
082335d0 g     F .text	000004a8 sogetopt
0821442c g     F .text	00000068 alt_flash_open_dev
082540c8 g     O .bss	00000001 OSIntNesting
0822232c g     F .text	00000248 alt_tse_mac_associate_phy
08253b1c g     O .rwdata	00000030 nettasks
0822ce44 g     F .text	00000020 pk_get_max_intrsafe_buf_len
08210db4 g     F .text	00000164 __fputwc
08240d44 g     F .text	000001d8 iproute
0822f618 g     F .text	000000f4 np_stripoptions
0825421c g     O .bss	00000001 so_evtmap
0821cd88 g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
0820af84 g     F .text	0000009c _fputs_r
0821c198 g     F .text	000001d4 OSTimeDlyResume
0820197c g     F .text	000000d0 SSSCreateTasks
0824438c g     F .text	000003c0 add_route
0821757c g     F .text	0000014c OSFlagNameSet
082266c4 g     F .text	00000090 c_older
08234984 g     F .text	00000084 sbflush
08247240 g     F .text	00000024 md_fclose
08229868 g     F .text	00000030 tk_yield
08201d80 g     F .text	000000c8 sss_handle_accept
0821b9fc g     F .text	000001c0 OSTaskStkChk
0823c114 g     F .text	0000008c alt_ic_irq_disable
08232368 g     F .text	00000558 sosend
08253f3e g     O .rwdata	00000002 OSMemSize
082409f8 g     F .text	000000a4 ip_mymach
0821ea64 g     F .text	0000008c alt_avalon_sgdma_construct_descriptor
0820df28 g     F .text	0000007c __swrite
08254158 g     O .bss	00000004 cticks_initialized
0825401c g     O .rwdata	00000004 deflength
082313d8 g     F .text	000001f4 t_sendto
08253ef8 g     O .rwdata	00000004 __malloc_trim_threshold
08203338 g     F .text	00000080 _perror_r
0823ccec g     F .text	00000024 altera_nios2_qsys_irq_init
0820bb48 g     F .text	0000000c __locale_msgcharset
082540cc g     O .bss	00000004 OSTCBCur
08231a90 g     F .text	000001a8 socreate
0824b6b4 g     F .text	00000038 exit
0825e8f8 g     O .bss	00000100 arp_table
08254254 g     O .bss	00000004 icmpdu_hook
08253f40 g     O .rwdata	00000002 OSMemTblSize
0820b9ec g     F .text	000000c4 _fwalk_reent
0823d87c g     F .text	00000024 create_apptasks
08253fd8 g     O .rwdata	00000004 tcp_ttl
0820cfdc g     F .text	000001fc __mdiff
08214494 g     F .text	00000054 alt_flash_close_dev
0822e270 g     F .text	00000040 ncpfree
08202bf8 g     F .text	00000074 .hidden __modsi3
082540e8 g     O .bss	00000004 MaxLnh
08253ee4 g     O .rwdata	00000004 __ctype_ptr__
0821f4d8 g     F .text	00000050 tse_mac_setGMIImode
082479b0 g     F .text	00000084 inet_ntop
08245500 g     F .text	00000024 udp_maxalloc
08223ea0 g     F .text	000000e4 marvell_cfg_gmii
08380000 g       *ABS*	00000000 __alt_data_end
08200060 g     F .exceptions	00000000 alt_exception
0820aea8 g     F .text	00000004 __sfp_lock_release
082154b0 g     F .text	00000058 OSInit
08222574 g     F .text	00000128 alt_tse_phy_cfg_pcs
0821bda0 g     F .text	00000124 OSTaskQuery
0823d168 g     F .text	00000094 icmp_port_du
082541b8 g     O .bss	00000004 tcp_iss
08219cc0 g     F .text	000000a8 OS_QInit
0824b69c g     F .text	0000000c atoi
08253fc8 g     O .rwdata	00000004 bigbufsiz
08216738 g     F .text	00000054 OS_StrLen
08239d78 g     F .text	00000078 tcp_putseq
082188c4 g     F .text	00000114 OSMemNameSet
0824d1e2 g     O .rodata	00000101 _ctype_
08200000 g       *ABS*	00000000 __alt_mem_onchip_ram
082345c8 g     F .text	000001dc sbappendaddr
00000000 g       *ABS*	00000000 __alt_mem_ext_flash
0825424c g     O .bss	00000004 vfs_total_rw_space
082465d0 g     F .text	00000108 ip_getmoptions
08253f5a g     O .rwdata	00000002 OSTaskProfileEn
082452a0 g     F .text	000000f4 udpswap
082540d0 g     O .bss	00000004 OSTime
08254194 g     O .bss	00000004 nextslow
08239e64 g     F .text	00000270 tcp_slowtimo
08239a84 g     F .text	0000010c tcp_newtcpcb
0823e860 g     F .text	00000180 send_via_arp
08229b28 g     F .text	000000b0 dhc_init
08242184 g     F .text	00000058 ip_reasm_find_ire
0825c2dc g     O .bss	00000800 OSTaskIdleStk
0824befc g     F .text	00000034 _exit
08249eac g     F .text	00000058 isvfile_locked
08228508 g     F .text	00000184 bsd_select
0823bb30 g     F .text	0000012c alt_alarm_start
08217454 g     F .text	00000128 OSFlagNameGet
08245524 g     F .text	00000044 udp_free
0822cf20 g     F .text	000000b8 getq
0824a000 g     F .text	00000024 prep_vfs
0821c36c g     F .text	0000005c OSTimeGet
08254010 g     O .rwdata	00000004 name
08234bc0 g     F .text	00000100 sbdropend
0820bb8c g     F .text	000001bc __smakebuf_r
0823e9e0 g     F .text	0000010c cb_arpent_tmo
08203fbc g     F .text	00000098 strlen
08245ed4 g     F .text	00000134 IPADDR_TO_NETP
0822838c g     F .text	00000034 bsd_inet_ntoa
0823cf84 g     F .text	00000020 OSTaskSwHook
0823c51c g     F .text	00000154 open
0822d188 g     F .text	000001fc udp_open
0825cadc g     O .bss	00000b40 OSEventTbl
08234148 g     F .text	00000058 socantsendmore
08254250 g     O .bss	00000004 vfs_total_dyna_files
08212fe0 g     F .text	000000dc .hidden __gedf2
0823c9e4 g     F .text	00000044 alt_uncached_free
0825d61c g     O .bss	00000510 OSTCBTbl
082541f0 g     O .bss	00000004 arpReqsOut
0821a6c8 g     F .text	00000100 OSSemSet
08254038 g     O .rwdata	00000004 http_root_path
0822bafc g     F .text	00000270 dhc_extract_opts
082416f0 g     F .text	00000564 ip_reasm_compute_overlap
08253efc g     O .rwdata	00000004 __wctomb
0820f5ec g     F .text	00000018 __sprint_r
0821f354 g     F .text	000000a8 tse_mac_aRxRead
082037e0 g     F .text	00000164 strchr
0825e17a g     O .bss	00000012 ipreturn
0825420c g     O .bss	00000004 port_prep
08253b9f g     O .rwdata	0000000d tcp_backoff
08233ac4 g     F .text	00000070 soisconnecting
08200ca8 g     F .text	00000070 SSSInitialTask
0820b020 g     F .text	00000018 fputs
08254004 g     O .rwdata	00000004 alt_priority_mask
08245a64 g     F .text	000001ec igmpv2_process_query
08234d50 g     F .text	000001d0 t_select
08219ef0 g     F .text	00000240 OSSemDel
0823ba08 g     F .text	00000128 udp4_sockaddr
082540d4 g     O .bss	00000004 OSFlagFreeList
08248184 g     F .text	000001e0 in_pcbconnect
082541ac g     O .bss	00000004 dropline
08254208 g     O .bss	00000004 ire_cticks
0823c08c g     F .text	00000088 alt_ic_irq_enable
08253f20 g     O .rwdata	00000002 OSEventNameSize
08208c90 g     F .text	0000001c __vfprintf_internal
0822942c g     F .text	00000078 tk_netmain
08248364 g     F .text	0000005c in_pcbdisconnect
082540d8 g     O .bss	00000001 OSStatRdy
0825db2c g     O .bss	00000054 OSTCBPrioTbl
082112b8 g     F .text	0000005c _wctomb_r
08214930 g     F .text	000000c4 __env_lock
08253f66 g     O .rwdata	00000002 OSTaskSwHookEn
08253d78 g     O .rwdata	00000024 mdio
08220530 g     F .text	000000e0 alt_tse_mac_set_speed
0821e63c g     F .text	00000084 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
08227ce4 g     F .text	00000124 bsd_accept
08253fe8 g     O .rwdata	00000004 tcp_recvspace
082138c8 g     F .text	000008fc .hidden __subdf3
0824bee4 g     F .text	00000018 _vfprintf_r
0823af3c g     F .text	00000040 tcpinit
08254108 g     O .bss	00000004 igmp_all_rtrs_group
0822facc g     F .text	0000005c rawip_lookup
0823d91c g     F .text	000000a0 fcntl
0820ca10 g     F .text	000000b0 __lo0bits
082347a4 g     F .text	000001e0 sbcompress
08254008 g     O .rwdata	00000008 alt_alarm_list
08239b90 g     F .text	000000ac tcp_drop
08253f2e g     O .rwdata	00000002 OSFlagWidth
0823beec g     F .text	00000060 _do_ctors
0822322c g     F .text	00000254 alt_tse_phy_set_adv_100
0823a134 g     F .text	00000480 tcp_timers
08226cc4 g     F .text	00000084 if_netnumber
082466d8 g     F .text	00000088 ip_freemoptions
08233a78 g     F .text	0000004c sohasoutofband
082111c8 g     F .text	000000c0 wcrtomb
082359dc g     F .text	00002330 tcp_input
08227e08 g     F .text	00000124 bsd_getpeername
082283c0 g     F .text	00000148 bsd_recvfrom
08225894 g     F .text	00000048 close
08254138 g     O .bss	00000004 dsc_bpreplys
08254084 g     O .bss	00000004 alt_envsem
082540dc g     O .bss	00000004 OSIdleCtrRun
08215af4 g     F .text	00000020 OSVersion
08253f78 g     O .rwdata	00000002 OSTmrCfgWheelSize
0821bec4 g     F .text	00000070 OS_TaskStkClr
0824871c g     F .text	0000002c set_vfopen_error
08253f52 g     O .rwdata	00000002 OSTaskCreateEn
082202f8 g     F .text	0000006c alt_tse_get_system_index
08253b7c g     O .rwdata	00000018 rawip_protosw
08234234 g     F .text	0000006c sbwait
082160e4 g     F .text	00000068 OS_EventWaitListInit
0822bd6c g     F .text	00000550 dhc_second
0821f044 g     F .text	000000a8 alt_avalon_sgdma_init
082541d8 g     O .bss	00000004 port_1s_callout
08210f3c g     F .text	00000080 fputwc
0823d030 g     F .text	00000020 OSTaskIdleHook
0824b700 g     F .text	00000014 free
0820aeac g     F .text	00000004 __sinit_lock_acquire
082540e4 g     O .bss	00000001 number_of_tse_mac
0820c784 g     F .text	00000120 __multadd
0821bbbc g     F .text	000001e4 OSTaskSuspend
0820c75c g     F .text	00000028 _Bfree
0821f1e0 g     F .text	00000030 no_printf
08233d94 g     F .text	00000200 sonewconn
0824a4bc g     F .text	00000b64 icmprcv
0822e340 g     F .text	000000c4 pffindproto
0821678c g     F .text	0000005c OS_TaskIdle
08253f7e g     O .rwdata	00000002 OSTmrTblSize
08219b64 g     F .text	0000015c OSQQuery



Disassembly of section .exceptions:

08200060 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
 8200060:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
 8200064:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
 8200068:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 820006c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 8200070:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 8200074:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 8200078:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 820007c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 8200080:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
 8200084:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
 8200088:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 820008c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 8200090:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 8200094:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 8200098:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 820009c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 82000a0:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 82000a4:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 82000a8:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 82000ac:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 82000b0:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 82000b4:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 82000b8:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 82000bc:	10000326 	beq	r2,zero,82000cc <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 82000c0:	20000226 	beq	r4,zero,82000cc <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 82000c4:	820012c0 	call	820012c <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 82000c8:	00000306 	br	82000d8 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
 82000cc:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
 82000d0:	e8bfff17 	ldw	r2,-4(ea)

082000d4 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
 82000d4:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 82000d8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 82000dc:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 82000e0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 82000e4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 82000e8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 82000ec:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 82000f0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 82000f4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 82000f8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 82000fc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 8200100:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
 8200104:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 8200108:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 820010c:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 8200110:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 8200114:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 8200118:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 820011c:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 8200120:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
 8200124:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 8200128:	ef80083a 	eret

0820012c <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 820012c:	defff904 	addi	sp,sp,-28
 8200130:	dfc00615 	stw	ra,24(sp)
 8200134:	df000515 	stw	fp,20(sp)
 8200138:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 820013c:	82155080 	call	8215508 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 8200140:	0005313a 	rdctl	r2,ipending
 8200144:	e0bffe15 	stw	r2,-8(fp)

  return active;
 8200148:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 820014c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
 8200150:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 8200154:	00800044 	movi	r2,1
 8200158:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 820015c:	e0fffb17 	ldw	r3,-20(fp)
 8200160:	e0bffc17 	ldw	r2,-16(fp)
 8200164:	1884703a 	and	r2,r3,r2
 8200168:	10001426 	beq	r2,zero,82001bc <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 820016c:	008209b4 	movhi	r2,2086
 8200170:	10b9e504 	addi	r2,r2,-6252
 8200174:	e0fffd17 	ldw	r3,-12(fp)
 8200178:	180690fa 	slli	r3,r3,3
 820017c:	10c5883a 	add	r2,r2,r3
 8200180:	10c00017 	ldw	r3,0(r2)
 8200184:	008209b4 	movhi	r2,2086
 8200188:	10b9e504 	addi	r2,r2,-6252
 820018c:	e13ffd17 	ldw	r4,-12(fp)
 8200190:	200890fa 	slli	r4,r4,3
 8200194:	1105883a 	add	r2,r2,r4
 8200198:	10800104 	addi	r2,r2,4
 820019c:	10800017 	ldw	r2,0(r2)
 82001a0:	1009883a 	mov	r4,r2
 82001a4:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
 82001a8:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 82001ac:	0005313a 	rdctl	r2,ipending
 82001b0:	e0bfff15 	stw	r2,-4(fp)

  return active;
 82001b4:	e0bfff17 	ldw	r2,-4(fp)
 82001b8:	00000706 	br	82001d8 <alt_irq_handler+0xac>
      }
      mask <<= 1;
 82001bc:	e0bffc17 	ldw	r2,-16(fp)
 82001c0:	1085883a 	add	r2,r2,r2
 82001c4:	e0bffc15 	stw	r2,-16(fp)
      i++;
 82001c8:	e0bffd17 	ldw	r2,-12(fp)
 82001cc:	10800044 	addi	r2,r2,1
 82001d0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 82001d4:	003fe106 	br	820015c <alt_irq_handler+0x30>

    active = alt_irq_pending ();
 82001d8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
 82001dc:	e0bffb17 	ldw	r2,-20(fp)
 82001e0:	103fdb1e 	bne	r2,zero,8200150 <alt_irq_handler+0x24>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 82001e4:	82155540 	call	8215554 <OSIntExit>
}
 82001e8:	0001883a 	nop
 82001ec:	e037883a 	mov	sp,fp
 82001f0:	dfc00117 	ldw	ra,4(sp)
 82001f4:	df000017 	ldw	fp,0(sp)
 82001f8:	dec00204 	addi	sp,sp,8
 82001fc:	f800283a 	ret

Disassembly of section .text:

08200200 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 8200200:	00a00014 	movui	r2,32768
#endif

0:
    initd 0(r2)
 8200204:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 8200208:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
 820020c:	00bffd16 	blt	zero,r2,8200204 <_start+0x4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 8200210:	06c20e34 	movhi	sp,2104
    ori sp, sp, %lo(__alt_stack_pointer)
 8200214:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 8200218:	06820974 	movhi	gp,2085
    ori gp, gp, %lo(_gp)
 820021c:	d6afb914 	ori	gp,gp,48868
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 8200220:	00820974 	movhi	r2,2085
    ori r2, r2, %lo(__bss_start)
 8200224:	10900f14 	ori	r2,r2,16444

    movhi r3, %hi(__bss_end)
 8200228:	00c20974 	movhi	r3,2085
    ori r3, r3, %lo(__bss_end)
 820022c:	18fabb14 	ori	r3,r3,60140

    beq r2, r3, 1f
 8200230:	10c00326 	beq	r2,r3,8200240 <_start+0x40>

0:
    stw zero, (r2)
 8200234:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 8200238:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 820023c:	10fffd36 	bltu	r2,r3,8200234 <_start+0x34>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 8200240:	82147c40 	call	82147c4 <alt_main>

08200244 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 8200244:	003fff06 	br	8200244 <alt_after_alt_main>

08200248 <alt_uCOSIIErrorHandler>:
#include <errno.h>
#include "includes.h"
#include "alt_error_handler.h"
 
void alt_uCOSIIErrorHandler(INT8U error_code, void *expanded_diagnosis_ptr)
{
 8200248:	defffb04 	addi	sp,sp,-20
 820024c:	dfc00415 	stw	ra,16(sp)
 8200250:	df000315 	stw	fp,12(sp)
 8200254:	df000304 	addi	fp,sp,12
 8200258:	2005883a 	mov	r2,r4
 820025c:	e17fff15 	stw	r5,-4(fp)
 8200260:	e0bffe05 	stb	r2,-8(fp)
   FAULT_LEVEL fault_level;
   
   if(error_code == OS_NO_ERR)
 8200264:	e0bffe03 	ldbu	r2,-8(fp)
 8200268:	10014a26 	beq	r2,zero,8200794 <alt_uCOSIIErrorHandler+0x54c>
   {
      return;
   }
   
   fault_level = SYSTEM;  
 820026c:	00800084 	movi	r2,2
 8200270:	e0bffd15 	stw	r2,-12(fp)
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */
 8200274:	821564c0 	call	821564c <OSSchedLock>
      
   switch (error_code)
 8200278:	e0bffe03 	ldbu	r2,-8(fp)
 820027c:	10c00a20 	cmpeqi	r3,r2,40
 8200280:	1800261e 	bne	r3,zero,820031c <alt_uCOSIIErrorHandler+0xd4>
 8200284:	10c00a48 	cmpgei	r3,r2,41
 8200288:	1800121e 	bne	r3,zero,82002d4 <alt_uCOSIIErrorHandler+0x8c>
 820028c:	10c00120 	cmpeqi	r3,r2,4
 8200290:	1800601e 	bne	r3,zero,8200414 <alt_uCOSIIErrorHandler+0x1cc>
 8200294:	10c00148 	cmpgei	r3,r2,5
 8200298:	1800071e 	bne	r3,zero,82002b8 <alt_uCOSIIErrorHandler+0x70>
 820029c:	10c000a0 	cmpeqi	r3,r2,2
 82002a0:	18007a1e 	bne	r3,zero,820048c <alt_uCOSIIErrorHandler+0x244>
 82002a4:	10c000c8 	cmpgei	r3,r2,3
 82002a8:	1800631e 	bne	r3,zero,8200438 <alt_uCOSIIErrorHandler+0x1f0>
 82002ac:	10800060 	cmpeqi	r2,r2,1
 82002b0:	10004d1e 	bne	r2,zero,82003e8 <alt_uCOSIIErrorHandler+0x1a0>
 82002b4:	0000bc06 	br	82005a8 <alt_uCOSIIErrorHandler+0x360>
 82002b8:	10c00520 	cmpeqi	r3,r2,20
 82002bc:	1800401e 	bne	r3,zero,82003c0 <alt_uCOSIIErrorHandler+0x178>
 82002c0:	10c007a0 	cmpeqi	r3,r2,30
 82002c4:	1800961e 	bne	r3,zero,8200520 <alt_uCOSIIErrorHandler+0x2d8>
 82002c8:	108002a0 	cmpeqi	r2,r2,10
 82002cc:	1000651e 	bne	r2,zero,8200464 <alt_uCOSIIErrorHandler+0x21c>
 82002d0:	0000b506 	br	82005a8 <alt_uCOSIIErrorHandler+0x360>
 82002d4:	10c01020 	cmpeqi	r3,r2,64
 82002d8:	1800881e 	bne	r3,zero,82004fc <alt_uCOSIIErrorHandler+0x2b4>
 82002dc:	10c01048 	cmpgei	r3,r2,65
 82002e0:	1800071e 	bne	r3,zero,8200300 <alt_uCOSIIErrorHandler+0xb8>
 82002e4:	10c00f60 	cmpeqi	r3,r2,61
 82002e8:	18007a1e 	bne	r3,zero,82004d4 <alt_uCOSIIErrorHandler+0x28c>
 82002ec:	10c00fa0 	cmpeqi	r3,r2,62
 82002f0:	18006f1e 	bne	r3,zero,82004b0 <alt_uCOSIIErrorHandler+0x268>
 82002f4:	10800aa0 	cmpeqi	r2,r2,42
 82002f8:	1000111e 	bne	r2,zero,8200340 <alt_uCOSIIErrorHandler+0xf8>
 82002fc:	0000aa06 	br	82005a8 <alt_uCOSIIErrorHandler+0x360>
 8200300:	10c01920 	cmpeqi	r3,r2,100
 8200304:	1800901e 	bne	r3,zero,8200548 <alt_uCOSIIErrorHandler+0x300>
 8200308:	10c03fe0 	cmpeqi	r3,r2,255
 820030c:	1800991e 	bne	r3,zero,8200574 <alt_uCOSIIErrorHandler+0x32c>
 8200310:	108010a0 	cmpeqi	r2,r2,66
 8200314:	10001a1e 	bne	r2,zero,8200380 <alt_uCOSIIErrorHandler+0x138>
 8200318:	0000a306 	br	82005a8 <alt_uCOSIIErrorHandler+0x360>
   {  
      case OS_PRIO_EXIST:
         fprintf(stderr, "Attempted to assign task priority aready in use.\n");
 820031c:	d0a00217 	ldw	r2,-32760(gp)
 8200320:	10800317 	ldw	r2,12(r2)
 8200324:	100f883a 	mov	r7,r2
 8200328:	01800c44 	movi	r6,49
 820032c:	01400044 	movi	r5,1
 8200330:	01020974 	movhi	r4,2085
 8200334:	212fcc04 	addi	r4,r4,-16592
 8200338:	8202e400 	call	8202e40 <fwrite>
         break;
 820033c:	0000b106 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_PRIO_INVALID:
         fprintf(stderr, "Specified task priority higher than allowed max.\n");
 8200340:	d0a00217 	ldw	r2,-32760(gp)
 8200344:	10800317 	ldw	r2,12(r2)
 8200348:	100f883a 	mov	r7,r2
 820034c:	01800c44 	movi	r6,49
 8200350:	01400044 	movi	r5,1
 8200354:	01020974 	movhi	r4,2085
 8200358:	212fd904 	addi	r4,r4,-16540
 820035c:	8202e400 	call	8202e40 <fwrite>
         fprintf(stderr, "Task can't be assigned a priority higher than %d\n",
 8200360:	d0a00217 	ldw	r2,-32760(gp)
 8200364:	10800317 	ldw	r2,12(r2)
 8200368:	01800504 	movi	r6,20
 820036c:	01420974 	movhi	r5,2085
 8200370:	296fe604 	addi	r5,r5,-16488
 8200374:	1009883a 	mov	r4,r2
 8200378:	8202d500 	call	8202d50 <fprintf>
            OS_LOWEST_PRIO);
         break;
 820037c:	0000a106 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_NO_MORE_TCB:
         fprintf(stderr, "Task Control Blocks have been exhausted\n");
 8200380:	d0a00217 	ldw	r2,-32760(gp)
 8200384:	10800317 	ldw	r2,12(r2)
 8200388:	100f883a 	mov	r7,r2
 820038c:	01800a04 	movi	r6,40
 8200390:	01400044 	movi	r5,1
 8200394:	01020974 	movhi	r4,2085
 8200398:	212ff304 	addi	r4,r4,-16436
 820039c:	8202e400 	call	8202e40 <fwrite>
         fprintf(stderr, "Current max number of tasks is %d\n",OS_MAX_TASKS);
 82003a0:	d0a00217 	ldw	r2,-32760(gp)
 82003a4:	10800317 	ldw	r2,12(r2)
 82003a8:	01800284 	movi	r6,10
 82003ac:	01420974 	movhi	r5,2085
 82003b0:	296ffe04 	addi	r5,r5,-16392
 82003b4:	1009883a 	mov	r4,r2
 82003b8:	8202d500 	call	8202d50 <fprintf>
         break;
 82003bc:	00009106 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_MBOX_FULL:
         fault_level = NONE;
 82003c0:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Attempted Post to Mailbox already holding message\n");
 82003c4:	d0a00217 	ldw	r2,-32760(gp)
 82003c8:	10800317 	ldw	r2,12(r2)
 82003cc:	100f883a 	mov	r7,r2
 82003d0:	01800c84 	movi	r6,50
 82003d4:	01400044 	movi	r5,1
 82003d8:	01020974 	movhi	r4,2085
 82003dc:	21300704 	addi	r4,r4,-16356
 82003e0:	8202e400 	call	8202e40 <fwrite>
         break;
 82003e4:	00008706 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_EVENT_TYPE:
         fault_level = TASK;
 82003e8:	00800044 	movi	r2,1
 82003ec:	e0bffd15 	stw	r2,-12(fp)
         fprintf(stderr, 
 82003f0:	d0a00217 	ldw	r2,-32760(gp)
 82003f4:	10800317 	ldw	r2,12(r2)
 82003f8:	100f883a 	mov	r7,r2
 82003fc:	01801244 	movi	r6,73
 8200400:	01400044 	movi	r5,1
 8200404:	01020974 	movhi	r4,2085
 8200408:	21301404 	addi	r4,r4,-16304
 820040c:	8202e400 	call	8202e40 <fwrite>
"Attempted to access a resource with no match for the required data type.\n");
         break;
 8200410:	00007c06 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_PEVENT_NULL:
         fprintf(stderr, "Attempting to access a resource pointing to NULL\n");
 8200414:	d0a00217 	ldw	r2,-32760(gp)
 8200418:	10800317 	ldw	r2,12(r2)
 820041c:	100f883a 	mov	r7,r2
 8200420:	01800c44 	movi	r6,49
 8200424:	01400044 	movi	r5,1
 8200428:	01020974 	movhi	r4,2085
 820042c:	21302704 	addi	r4,r4,-16228
 8200430:	8202e400 	call	8202e40 <fwrite>
         break;
 8200434:	00007306 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_POST_NULL_PTR:
         fault_level = TASK;
 8200438:	00800044 	movi	r2,1
 820043c:	e0bffd15 	stw	r2,-12(fp)
         fprintf(stderr, "Attempted to Post a NULL to a resource. \n");
 8200440:	d0a00217 	ldw	r2,-32760(gp)
 8200444:	10800317 	ldw	r2,12(r2)
 8200448:	100f883a 	mov	r7,r2
 820044c:	01800a44 	movi	r6,41
 8200450:	01400044 	movi	r5,1
 8200454:	01020974 	movhi	r4,2085
 8200458:	21303404 	addi	r4,r4,-16176
 820045c:	8202e400 	call	8202e40 <fwrite>
         break;
 8200460:	00006806 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_TIMEOUT:
         fault_level = NONE;
 8200464:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Resource not received in specified time\n");
 8200468:	d0a00217 	ldw	r2,-32760(gp)
 820046c:	10800317 	ldw	r2,12(r2)
 8200470:	100f883a 	mov	r7,r2
 8200474:	01800a04 	movi	r6,40
 8200478:	01400044 	movi	r5,1
 820047c:	01020974 	movhi	r4,2085
 8200480:	21303f04 	addi	r4,r4,-16132
 8200484:	8202e400 	call	8202e40 <fwrite>
         break;
 8200488:	00005e06 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_PEND_ISR:
         fprintf(stderr, "Attempting to pend for a resource in an ISR\n");
 820048c:	d0a00217 	ldw	r2,-32760(gp)
 8200490:	10800317 	ldw	r2,12(r2)
 8200494:	100f883a 	mov	r7,r2
 8200498:	01800b04 	movi	r6,44
 820049c:	01400044 	movi	r5,1
 82004a0:	01020974 	movhi	r4,2085
 82004a4:	21304a04 	addi	r4,r4,-16088
 82004a8:	8202e400 	call	8202e40 <fwrite>
         break;
 82004ac:	00005506 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_TASK_DEL_IDLE:
         fprintf(stderr, "Attempted to delete the IDLE task\n");
 82004b0:	d0a00217 	ldw	r2,-32760(gp)
 82004b4:	10800317 	ldw	r2,12(r2)
 82004b8:	100f883a 	mov	r7,r2
 82004bc:	01800884 	movi	r6,34
 82004c0:	01400044 	movi	r5,1
 82004c4:	01020974 	movhi	r4,2085
 82004c8:	21305604 	addi	r4,r4,-16040
 82004cc:	8202e400 	call	8202e40 <fwrite>
         break;
 82004d0:	00004c06 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_TASK_DEL_ERR:
         fault_level = NONE;
 82004d4:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Attempted to delete a task that does not exist\n");
 82004d8:	d0a00217 	ldw	r2,-32760(gp)
 82004dc:	10800317 	ldw	r2,12(r2)
 82004e0:	100f883a 	mov	r7,r2
 82004e4:	01800bc4 	movi	r6,47
 82004e8:	01400044 	movi	r5,1
 82004ec:	01020974 	movhi	r4,2085
 82004f0:	21305f04 	addi	r4,r4,-16004
 82004f4:	8202e400 	call	8202e40 <fwrite>
         break;
 82004f8:	00004206 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_TASK_DEL_ISR:
         fprintf(stderr, "Attempted to delete a task from an ISR\n");
 82004fc:	d0a00217 	ldw	r2,-32760(gp)
 8200500:	10800317 	ldw	r2,12(r2)
 8200504:	100f883a 	mov	r7,r2
 8200508:	018009c4 	movi	r6,39
 820050c:	01400044 	movi	r5,1
 8200510:	01020974 	movhi	r4,2085
 8200514:	21306b04 	addi	r4,r4,-15956
 8200518:	8202e400 	call	8202e40 <fwrite>
         break;
 820051c:	00003906 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_Q_FULL:
         fault_level = NONE;
 8200520:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Attempted to post to a full message queue\n");
 8200524:	d0a00217 	ldw	r2,-32760(gp)
 8200528:	10800317 	ldw	r2,12(r2)
 820052c:	100f883a 	mov	r7,r2
 8200530:	01800a84 	movi	r6,42
 8200534:	01400044 	movi	r5,1
 8200538:	01020974 	movhi	r4,2085
 820053c:	21307504 	addi	r4,r4,-15916
 8200540:	8202e400 	call	8202e40 <fwrite>
         break;
 8200544:	00002f06 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_NOT_MUTEX_OWNER:
         fault_level = TASK;
 8200548:	00800044 	movi	r2,1
 820054c:	e0bffd15 	stw	r2,-12(fp)
         fprintf(stderr, "Attempted to post a mutex not owned by the task\n");
 8200550:	d0a00217 	ldw	r2,-32760(gp)
 8200554:	10800317 	ldw	r2,12(r2)
 8200558:	100f883a 	mov	r7,r2
 820055c:	01800c04 	movi	r6,48
 8200560:	01400044 	movi	r5,1
 8200564:	01020974 	movhi	r4,2085
 8200568:	21308004 	addi	r4,r4,-15872
 820056c:	8202e400 	call	8202e40 <fwrite>
         break;
 8200570:	00002406 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case EXPANDED_DIAGNOSIS_CODE:      
         fault_level = SYSTEM;
 8200574:	00800084 	movi	r2,2
 8200578:	e0bffd15 	stw	r2,-12(fp)
         printf(
 820057c:	01020974 	movhi	r4,2085
 8200580:	21308d04 	addi	r4,r4,-15820
 8200584:	82033fc0 	call	82033fc <printf>
"\n[MicroC/OS-II]: See STDERR for expanded diagnosis translation.");    
         fprintf(stderr, "\n[MicroC/OS-II]: Expanded Diagnosis: %s.", 
 8200588:	d0a00217 	ldw	r2,-32760(gp)
 820058c:	10800317 	ldw	r2,12(r2)
 8200590:	e1bfff17 	ldw	r6,-4(fp)
 8200594:	01420974 	movhi	r5,2085
 8200598:	29709d04 	addi	r5,r5,-15756
 820059c:	1009883a 	mov	r4,r2
 82005a0:	8202d500 	call	8202d50 <fprintf>
                 (char *)expanded_diagnosis_ptr);
         break;           
 82005a4:	00001706 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      default:
         printf("\n[MicroC/OS-II]: (Not a MicroC/OS-II error) See STDERR.\n");    
 82005a8:	01020974 	movhi	r4,2085
 82005ac:	2130a804 	addi	r4,r4,-15712
 82005b0:	82036800 	call	8203680 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]:");
 82005b4:	d0a00217 	ldw	r2,-32760(gp)
 82005b8:	10800317 	ldw	r2,12(r2)
 82005bc:	100f883a 	mov	r7,r2
 82005c0:	01800404 	movi	r6,16
 82005c4:	01400044 	movi	r5,1
 82005c8:	01020974 	movhi	r4,2085
 82005cc:	2130b604 	addi	r4,r4,-15656
 82005d0:	8202e400 	call	8202e40 <fwrite>
         fprintf(stderr, "\nError_code %d.\n", error_code);
 82005d4:	d0a00217 	ldw	r2,-32760(gp)
 82005d8:	10800317 	ldw	r2,12(r2)
 82005dc:	e0fffe03 	ldbu	r3,-8(fp)
 82005e0:	180d883a 	mov	r6,r3
 82005e4:	01420974 	movhi	r5,2085
 82005e8:	2970bb04 	addi	r5,r5,-15636
 82005ec:	1009883a 	mov	r4,r2
 82005f0:	8202d500 	call	8202d50 <fprintf>
         perror("\n[MicroC/OS-II]: (Not a MicroC/OS-II error), ERRNO: ");
 82005f4:	01020974 	movhi	r4,2085
 82005f8:	2130c004 	addi	r4,r4,-15616
 82005fc:	82033b80 	call	82033b8 <perror>
         break;
 8200600:	0001883a 	nop

   }

   /* Process the error based on the fault level, 
    * reenable scheduler if appropriate. */  
   switch (fault_level) {
 8200604:	e0bffd17 	ldw	r2,-12(fp)
 8200608:	10c00060 	cmpeqi	r3,r2,1
 820060c:	1800041e 	bne	r3,zero,8200620 <alt_uCOSIIErrorHandler+0x3d8>
 8200610:	00803a2e 	bgeu	zero,r2,82006fc <alt_uCOSIIErrorHandler+0x4b4>
 8200614:	108000a0 	cmpeqi	r2,r2,2
 8200618:	10001c1e 	bne	r2,zero,820068c <alt_uCOSIIErrorHandler+0x444>
 820061c:	00005106 	br	8200764 <alt_uCOSIIErrorHandler+0x51c>
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is TASK).");
 8200620:	01020974 	movhi	r4,2085
 8200624:	2130ce04 	addi	r4,r4,-15560
 8200628:	82033fc0 	call	82033fc <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is TASK");
 820062c:	d0a00217 	ldw	r2,-32760(gp)
 8200630:	10800317 	ldw	r2,12(r2)
 8200634:	100f883a 	mov	r7,r2
 8200638:	01800904 	movi	r6,36
 820063c:	01400044 	movi	r5,1
 8200640:	01020974 	movhi	r4,2085
 8200644:	2130db04 	addi	r4,r4,-15508
 8200648:	8202e400 	call	8202e40 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Task is being deleted.\n");
 820064c:	d0a00217 	ldw	r2,-32760(gp)
 8200650:	10800317 	ldw	r2,12(r2)
 8200654:	100f883a 	mov	r7,r2
 8200658:	01800a04 	movi	r6,40
 820065c:	01400044 	movi	r5,1
 8200660:	01020974 	movhi	r4,2085
 8200664:	2130e504 	addi	r4,r4,-15468
 8200668:	8202e400 	call	8202e40 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 820066c:	82156d80 	call	82156d8 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 8200670:	01003fc4 	movi	r4,255
 8200674:	821b0480 	call	821b048 <OSTaskDel>
         /* Reinvoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 8200678:	e0bffe03 	ldbu	r2,-8(fp)
 820067c:	000b883a 	mov	r5,zero
 8200680:	1009883a 	mov	r4,r2
 8200684:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
         break;
 8200688:	00004106 	br	8200790 <alt_uCOSIIErrorHandler+0x548>
      case SYSTEM:
         /* Total System Failure, Restart Required */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 820068c:	01020974 	movhi	r4,2085
 8200690:	2130f004 	addi	r4,r4,-15424
 8200694:	82033fc0 	call	82033fc <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is SYSTEM");
 8200698:	d0a00217 	ldw	r2,-32760(gp)
 820069c:	10800317 	ldw	r2,12(r2)
 82006a0:	100f883a 	mov	r7,r2
 82006a4:	01800984 	movi	r6,38
 82006a8:	01400044 	movi	r5,1
 82006ac:	01020974 	movhi	r4,2085
 82006b0:	2130fe04 	addi	r4,r4,-15368
 82006b4:	8202e400 	call	8202e40 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: FATAL Error, Restart required.");
 82006b8:	d0a00217 	ldw	r2,-32760(gp)
 82006bc:	10800317 	ldw	r2,12(r2)
 82006c0:	100f883a 	mov	r7,r2
 82006c4:	01800bc4 	movi	r6,47
 82006c8:	01400044 	movi	r5,1
 82006cc:	01020974 	movhi	r4,2085
 82006d0:	21310804 	addi	r4,r4,-15328
 82006d4:	8202e400 	call	8202e40 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Locking scheduler - endless loop.\n");
 82006d8:	d0a00217 	ldw	r2,-32760(gp)
 82006dc:	10800317 	ldw	r2,12(r2)
 82006e0:	100f883a 	mov	r7,r2
 82006e4:	01800cc4 	movi	r6,51
 82006e8:	01400044 	movi	r5,1
 82006ec:	01020974 	movhi	r4,2085
 82006f0:	21311404 	addi	r4,r4,-15280
 82006f4:	8202e400 	call	8202e40 <fwrite>
         while(1); /* Since scheduler is locked,loop halts all task activity.*/
 82006f8:	003fff06 	br	82006f8 <alt_uCOSIIErrorHandler+0x4b0>
         break;
      case NONE:
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is NONE");
 82006fc:	d0a00217 	ldw	r2,-32760(gp)
 8200700:	10800317 	ldw	r2,12(r2)
 8200704:	100f883a 	mov	r7,r2
 8200708:	01800904 	movi	r6,36
 820070c:	01400044 	movi	r5,1
 8200710:	01020974 	movhi	r4,2085
 8200714:	21312104 	addi	r4,r4,-15228
 8200718:	8202e400 	call	8202e40 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Informational error only, control"); 
 820071c:	d0a00217 	ldw	r2,-32760(gp)
 8200720:	10800317 	ldw	r2,12(r2)
 8200724:	100f883a 	mov	r7,r2
 8200728:	01800c84 	movi	r6,50
 820072c:	01400044 	movi	r5,1
 8200730:	01020974 	movhi	r4,2085
 8200734:	21312b04 	addi	r4,r4,-15188
 8200738:	8202e400 	call	8202e40 <fwrite>
         fprintf(stderr, 
 820073c:	d0a00217 	ldw	r2,-32760(gp)
 8200740:	10800317 	ldw	r2,12(r2)
 8200744:	100f883a 	mov	r7,r2
 8200748:	01800f84 	movi	r6,62
 820074c:	01400044 	movi	r5,1
 8200750:	01020974 	movhi	r4,2085
 8200754:	21313804 	addi	r4,r4,-15136
 8200758:	8202e400 	call	8202e40 <fwrite>
            "returned to task to complete processing at application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */
 820075c:	82156d80 	call	82156d8 <OSSchedUnlock>
         return;   
 8200760:	00000d06 	br	8200798 <alt_uCOSIIErrorHandler+0x550>
         break;      
      default:
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is Unknown).\n");
 8200764:	01020974 	movhi	r4,2085
 8200768:	21314804 	addi	r4,r4,-15072
 820076c:	82036800 	call	8203680 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is unknown!?!\n");
 8200770:	d0a00217 	ldw	r2,-32760(gp)
 8200774:	10800317 	ldw	r2,12(r2)
 8200778:	100f883a 	mov	r7,r2
 820077c:	01800ac4 	movi	r6,43
 8200780:	01400044 	movi	r5,1
 8200784:	01020974 	movhi	r4,2085
 8200788:	21315604 	addi	r4,r4,-15016
 820078c:	8202e400 	call	8202e40 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 8200790:	003fff06 	br	8200790 <alt_uCOSIIErrorHandler+0x548>
{
   FAULT_LEVEL fault_level;
   
   if(error_code == OS_NO_ERR)
   {
      return;
 8200794:	0001883a 	nop
      default:
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is Unknown).\n");
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is unknown!?!\n");
   }
   while(1); /* Correct Program Flow never gets here. */
}
 8200798:	e037883a 	mov	sp,fp
 820079c:	dfc00117 	ldw	ra,4(sp)
 82007a0:	df000017 	ldw	fp,0(sp)
 82007a4:	dec00204 	addi	sp,sp,8
 82007a8:	f800283a 	ret

082007ac <alt_NetworkErrorHandler>:

void alt_NetworkErrorHandler(INT8U error_code, void *expanded_diagnosis_ptr)
{
 82007ac:	defffb04 	addi	sp,sp,-20
 82007b0:	dfc00415 	stw	ra,16(sp)
 82007b4:	df000315 	stw	fp,12(sp)
 82007b8:	df000304 	addi	fp,sp,12
 82007bc:	2005883a 	mov	r2,r4
 82007c0:	e17fff15 	stw	r5,-4(fp)
 82007c4:	e0bffe05 	stb	r2,-8(fp)
   FAULT_LEVEL fault_level;

   if(error_code == OS_NO_ERR)
 82007c8:	e0bffe03 	ldbu	r2,-8(fp)
 82007cc:	10008a26 	beq	r2,zero,82009f8 <alt_NetworkErrorHandler+0x24c>
   {
      return;
   }

   fault_level = SYSTEM;   
 82007d0:	00800084 	movi	r2,2
 82007d4:	e0bffd15 	stw	r2,-12(fp)
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */  
 82007d8:	821564c0 	call	821564c <OSSchedLock>

   if (error_code == EXPANDED_DIAGNOSIS_CODE) 
 82007dc:	e0bffe03 	ldbu	r2,-8(fp)
 82007e0:	10803fd8 	cmpnei	r2,r2,255
 82007e4:	1000101e 	bne	r2,zero,8200828 <alt_NetworkErrorHandler+0x7c>
   {
      fault_level = SYSTEM;
 82007e8:	00800084 	movi	r2,2
 82007ec:	e0bffd15 	stw	r2,-12(fp)
      printf("\n[Network]: See STDERR for expanded diagnosis translation.");    
 82007f0:	01020974 	movhi	r4,2085
 82007f4:	21316104 	addi	r4,r4,-14972
 82007f8:	82033fc0 	call	82033fc <printf>
      fprintf(stderr, "\n[Network]: %s", (char *)expanded_diagnosis_ptr);
 82007fc:	d0a00217 	ldw	r2,-32760(gp)
 8200800:	10800317 	ldw	r2,12(r2)
 8200804:	e1bfff17 	ldw	r6,-4(fp)
 8200808:	01420974 	movhi	r5,2085
 820080c:	29717004 	addi	r5,r5,-14912
 8200810:	1009883a 	mov	r4,r2
 8200814:	8202d500 	call	8202d50 <fprintf>
      /* Check errno also in case it has been set. */
      perror("\n[Network]:  ERRNO: ");
 8200818:	01020974 	movhi	r4,2085
 820081c:	21317404 	addi	r4,r4,-14896
 8200820:	82033b80 	call	82033b8 <perror>
 8200824:	00001006 	br	8200868 <alt_NetworkErrorHandler+0xbc>
   }
   else 
   {
      fault_level = TASK;
 8200828:	00800044 	movi	r2,1
 820082c:	e0bffd15 	stw	r2,-12(fp)
      printf("\n[Network]: See STDERR.\n");    
 8200830:	01020974 	movhi	r4,2085
 8200834:	21317a04 	addi	r4,r4,-14872
 8200838:	82036800 	call	8203680 <puts>
      fprintf(stderr, "\n[Network]: Error_code %d!\n", error_code);        
 820083c:	d0a00217 	ldw	r2,-32760(gp)
 8200840:	10800317 	ldw	r2,12(r2)
 8200844:	e0fffe03 	ldbu	r3,-8(fp)
 8200848:	180d883a 	mov	r6,r3
 820084c:	01420974 	movhi	r5,2085
 8200850:	29718004 	addi	r5,r5,-14848
 8200854:	1009883a 	mov	r4,r2
 8200858:	8202d500 	call	8202d50 <fprintf>
      perror("\n[Network]:  ERRNO: ");
 820085c:	01020974 	movhi	r4,2085
 8200860:	21317404 	addi	r4,r4,-14896
 8200864:	82033b80 	call	82033b8 <perror>
   }

   /* Process error based on fault level, reenable scheduler if appropriate. */     
   switch (fault_level) 
 8200868:	e0bffd17 	ldw	r2,-12(fp)
 820086c:	10c00060 	cmpeqi	r3,r2,1
 8200870:	1800041e 	bne	r3,zero,8200884 <alt_NetworkErrorHandler+0xd8>
 8200874:	00803a2e 	bgeu	zero,r2,8200960 <alt_NetworkErrorHandler+0x1b4>
 8200878:	108000a0 	cmpeqi	r2,r2,2
 820087c:	10001c1e 	bne	r2,zero,82008f0 <alt_NetworkErrorHandler+0x144>
 8200880:	00005106 	br	82009c8 <alt_NetworkErrorHandler+0x21c>
   {
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[Network]: See STDERR (FAULT_LEVEL is TASK).");
 8200884:	01020974 	movhi	r4,2085
 8200888:	21318704 	addi	r4,r4,-14820
 820088c:	82033fc0 	call	82033fc <printf>
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is TASK");
 8200890:	d0a00217 	ldw	r2,-32760(gp)
 8200894:	10800317 	ldw	r2,12(r2)
 8200898:	100f883a 	mov	r7,r2
 820089c:	018007c4 	movi	r6,31
 82008a0:	01400044 	movi	r5,1
 82008a4:	01020974 	movhi	r4,2085
 82008a8:	21319304 	addi	r4,r4,-14772
 82008ac:	8202e400 	call	8202e40 <fwrite>
         fprintf(stderr, "\n[Network]: Task is being deleted.\n");
 82008b0:	d0a00217 	ldw	r2,-32760(gp)
 82008b4:	10800317 	ldw	r2,12(r2)
 82008b8:	100f883a 	mov	r7,r2
 82008bc:	018008c4 	movi	r6,35
 82008c0:	01400044 	movi	r5,1
 82008c4:	01020974 	movhi	r4,2085
 82008c8:	21319b04 	addi	r4,r4,-14740
 82008cc:	8202e400 	call	8202e40 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 82008d0:	82156d80 	call	82156d8 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 82008d4:	01003fc4 	movi	r4,255
 82008d8:	821b0480 	call	821b048 <OSTaskDel>
         /* Reinvoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 82008dc:	e0bffe03 	ldbu	r2,-8(fp)
 82008e0:	000b883a 	mov	r5,zero
 82008e4:	1009883a 	mov	r4,r2
 82008e8:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
         break;
 82008ec:	00004106 	br	82009f4 <alt_NetworkErrorHandler+0x248>
      case SYSTEM:
         /* Total System Failure, Restart Required */
         printf("\n[Network]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 82008f0:	01020974 	movhi	r4,2085
 82008f4:	2131a404 	addi	r4,r4,-14704
 82008f8:	82033fc0 	call	82033fc <printf>
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is SYSTEM.");
 82008fc:	d0a00217 	ldw	r2,-32760(gp)
 8200900:	10800317 	ldw	r2,12(r2)
 8200904:	100f883a 	mov	r7,r2
 8200908:	01800884 	movi	r6,34
 820090c:	01400044 	movi	r5,1
 8200910:	01020974 	movhi	r4,2085
 8200914:	2131b004 	addi	r4,r4,-14656
 8200918:	8202e400 	call	8202e40 <fwrite>
         fprintf(stderr, "\n[Network]: FATAL Error, Restart required.");
 820091c:	d0a00217 	ldw	r2,-32760(gp)
 8200920:	10800317 	ldw	r2,12(r2)
 8200924:	100f883a 	mov	r7,r2
 8200928:	01800a84 	movi	r6,42
 820092c:	01400044 	movi	r5,1
 8200930:	01020974 	movhi	r4,2085
 8200934:	2131b904 	addi	r4,r4,-14620
 8200938:	8202e400 	call	8202e40 <fwrite>
         fprintf(stderr, "\n[Network]: Locking scheduler - endless loop.\n");
 820093c:	d0a00217 	ldw	r2,-32760(gp)
 8200940:	10800317 	ldw	r2,12(r2)
 8200944:	100f883a 	mov	r7,r2
 8200948:	01800b84 	movi	r6,46
 820094c:	01400044 	movi	r5,1
 8200950:	01020974 	movhi	r4,2085
 8200954:	2131c404 	addi	r4,r4,-14576
 8200958:	8202e400 	call	8202e40 <fwrite>
         while(1); /* Since scheduler is locked, loop halts all task activity.*/
 820095c:	003fff06 	br	820095c <alt_NetworkErrorHandler+0x1b0>
         break;
      case NONE:
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is NONE.");
 8200960:	d0a00217 	ldw	r2,-32760(gp)
 8200964:	10800317 	ldw	r2,12(r2)
 8200968:	100f883a 	mov	r7,r2
 820096c:	01800804 	movi	r6,32
 8200970:	01400044 	movi	r5,1
 8200974:	01020974 	movhi	r4,2085
 8200978:	2131d004 	addi	r4,r4,-14528
 820097c:	8202e400 	call	8202e40 <fwrite>
         fprintf(stderr, "\n[Network]: Informational "
 8200980:	d0a00217 	ldw	r2,-32760(gp)
 8200984:	10800317 	ldw	r2,12(r2)
 8200988:	100f883a 	mov	r7,r2
 820098c:	01800d84 	movi	r6,54
 8200990:	01400044 	movi	r5,1
 8200994:	01020974 	movhi	r4,2085
 8200998:	2131d904 	addi	r4,r4,-14492
 820099c:	8202e400 	call	8202e40 <fwrite>
                         "error only, control returned");
         fprintf(stderr, 
 82009a0:	d0a00217 	ldw	r2,-32760(gp)
 82009a4:	10800317 	ldw	r2,12(r2)
 82009a8:	100f883a 	mov	r7,r2
 82009ac:	01800e44 	movi	r6,57
 82009b0:	01400044 	movi	r5,1
 82009b4:	01020974 	movhi	r4,2085
 82009b8:	2131e704 	addi	r4,r4,-14436
 82009bc:	8202e400 	call	8202e40 <fwrite>
            "to task to complete processing at the application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */ 
 82009c0:	82156d80 	call	82156d8 <OSSchedUnlock>
         return;
 82009c4:	00000d06 	br	82009fc <alt_NetworkErrorHandler+0x250>
         break;         
      default:
         printf("\n[Network]: See STDERR (FAULT_LEVEL is unknown).\n");    
 82009c8:	01020974 	movhi	r4,2085
 82009cc:	2131f604 	addi	r4,r4,-14376
 82009d0:	82036800 	call	8203680 <puts>
         fprintf(stderr, "\n[Network] FAULT_LEVEL is unknown !?!\n");
 82009d4:	d0a00217 	ldw	r2,-32760(gp)
 82009d8:	10800317 	ldw	r2,12(r2)
 82009dc:	100f883a 	mov	r7,r2
 82009e0:	01800984 	movi	r6,38
 82009e4:	01400044 	movi	r5,1
 82009e8:	01020974 	movhi	r4,2085
 82009ec:	21320304 	addi	r4,r4,-14324
 82009f0:	8202e400 	call	8202e40 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 82009f4:	003fff06 	br	82009f4 <alt_NetworkErrorHandler+0x248>
{
   FAULT_LEVEL fault_level;

   if(error_code == OS_NO_ERR)
   {
      return;
 82009f8:	0001883a 	nop
      default:
         printf("\n[Network]: See STDERR (FAULT_LEVEL is unknown).\n");    
         fprintf(stderr, "\n[Network] FAULT_LEVEL is unknown !?!\n");
   }
   while(1); /* Correct Program Flow never gets here. */
}
 82009fc:	e037883a 	mov	sp,fp
 8200a00:	dfc00117 	ldw	ra,4(sp)
 8200a04:	df000017 	ldw	fp,0(sp)
 8200a08:	dec00204 	addi	sp,sp,8
 8200a0c:	f800283a 	ret

08200a10 <alt_SSSErrorHandler>:
   
   
void alt_SSSErrorHandler(INT8U error_code, 
                         void *expanded_diagnosis_ptr)
{
 8200a10:	defffb04 	addi	sp,sp,-20
 8200a14:	dfc00415 	stw	ra,16(sp)
 8200a18:	df000315 	stw	fp,12(sp)
 8200a1c:	df000304 	addi	fp,sp,12
 8200a20:	2005883a 	mov	r2,r4
 8200a24:	e17fff15 	stw	r5,-4(fp)
 8200a28:	e0bffe05 	stb	r2,-8(fp)
   FAULT_LEVEL fault_level;
   
   if   (error_code == OS_NO_ERR)
 8200a2c:	e0bffe03 	ldbu	r2,-8(fp)
 8200a30:	10009726 	beq	r2,zero,8200c90 <alt_SSSErrorHandler+0x280>
   {
      return;
   }

   fault_level = (error_code == OS_NO_ERR) ? NONE : SYSTEM;
 8200a34:	e0bffe03 	ldbu	r2,-8(fp)
 8200a38:	1000021e 	bne	r2,zero,8200a44 <alt_SSSErrorHandler+0x34>
 8200a3c:	0005883a 	mov	r2,zero
 8200a40:	00000106 	br	8200a48 <alt_SSSErrorHandler+0x38>
 8200a44:	00800084 	movi	r2,2
 8200a48:	e0bffd15 	stw	r2,-12(fp)
   
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */
 8200a4c:	821564c0 	call	821564c <OSSchedLock>
   switch (error_code)
 8200a50:	e0bffe03 	ldbu	r2,-8(fp)
 8200a54:	10c007a0 	cmpeqi	r3,r2,30
 8200a58:	18000f1e 	bne	r3,zero,8200a98 <alt_SSSErrorHandler+0x88>
 8200a5c:	10803fe0 	cmpeqi	r2,r2,255
 8200a60:	10001726 	beq	r2,zero,8200ac0 <alt_SSSErrorHandler+0xb0>
   {
      case EXPANDED_DIAGNOSIS_CODE:      
         fault_level = SYSTEM;
 8200a64:	00800084 	movi	r2,2
 8200a68:	e0bffd15 	stw	r2,-12(fp)
         printf("\n[SSS]: See STDERR for expanded diagnosis translation.");    
 8200a6c:	01020974 	movhi	r4,2085
 8200a70:	21320d04 	addi	r4,r4,-14284
 8200a74:	82033fc0 	call	82033fc <printf>
         fprintf(stderr, "\n[SSS]: %s", (char *)expanded_diagnosis_ptr);
 8200a78:	d0a00217 	ldw	r2,-32760(gp)
 8200a7c:	10800317 	ldw	r2,12(r2)
 8200a80:	e1bfff17 	ldw	r6,-4(fp)
 8200a84:	01420974 	movhi	r5,2085
 8200a88:	29721b04 	addi	r5,r5,-14228
 8200a8c:	1009883a 	mov	r4,r2
 8200a90:	8202d500 	call	8202d50 <fprintf>
         break;
 8200a94:	00001a06 	br	8200b00 <alt_SSSErrorHandler+0xf0>
         
      case OS_Q_FULL:
         fault_level = NONE;
 8200a98:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr,"\n[SSS]: Attempted to post to a full message queue.");
 8200a9c:	d0a00217 	ldw	r2,-32760(gp)
 8200aa0:	10800317 	ldw	r2,12(r2)
 8200aa4:	100f883a 	mov	r7,r2
 8200aa8:	01800c84 	movi	r6,50
 8200aac:	01400044 	movi	r5,1
 8200ab0:	01020974 	movhi	r4,2085
 8200ab4:	21321e04 	addi	r4,r4,-14216
 8200ab8:	8202e400 	call	8202e40 <fwrite>
         break;
 8200abc:	00001006 	br	8200b00 <alt_SSSErrorHandler+0xf0>
      
      default:
         fault_level = SYSTEM;
 8200ac0:	00800084 	movi	r2,2
 8200ac4:	e0bffd15 	stw	r2,-12(fp)
         printf("\n[SSS]: See STDERR.\n");    
 8200ac8:	01020974 	movhi	r4,2085
 8200acc:	21322b04 	addi	r4,r4,-14164
 8200ad0:	82036800 	call	8203680 <puts>
         fprintf(stderr, "\n[SSS]: Error_code %d!", error_code);        
 8200ad4:	d0a00217 	ldw	r2,-32760(gp)
 8200ad8:	10800317 	ldw	r2,12(r2)
 8200adc:	e0fffe03 	ldbu	r3,-8(fp)
 8200ae0:	180d883a 	mov	r6,r3
 8200ae4:	01420974 	movhi	r5,2085
 8200ae8:	29723004 	addi	r5,r5,-14144
 8200aec:	1009883a 	mov	r4,r2
 8200af0:	8202d500 	call	8202d50 <fprintf>
         perror("\n[SSS]:  ERRNO: ");
 8200af4:	01020974 	movhi	r4,2085
 8200af8:	21323604 	addi	r4,r4,-14120
 8200afc:	82033b80 	call	82033b8 <perror>
   }

   /* Process the error based on the fault level, 
    * reenable scheduler if appropriate. */     
   switch (fault_level) 
 8200b00:	e0bffd17 	ldw	r2,-12(fp)
 8200b04:	10c00060 	cmpeqi	r3,r2,1
 8200b08:	1800041e 	bne	r3,zero,8200b1c <alt_SSSErrorHandler+0x10c>
 8200b0c:	00803a2e 	bgeu	zero,r2,8200bf8 <alt_SSSErrorHandler+0x1e8>
 8200b10:	108000a0 	cmpeqi	r2,r2,2
 8200b14:	10001c1e 	bne	r2,zero,8200b88 <alt_SSSErrorHandler+0x178>
 8200b18:	00005106 	br	8200c60 <alt_SSSErrorHandler+0x250>
   {
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is TASK).");
 8200b1c:	01020974 	movhi	r4,2085
 8200b20:	21323b04 	addi	r4,r4,-14100
 8200b24:	82033fc0 	call	82033fc <printf>
         fprintf(stderr, "\n[SSS]: FAULT_LEVEL is TASK");
 8200b28:	d0a00217 	ldw	r2,-32760(gp)
 8200b2c:	10800317 	ldw	r2,12(r2)
 8200b30:	100f883a 	mov	r7,r2
 8200b34:	018006c4 	movi	r6,27
 8200b38:	01400044 	movi	r5,1
 8200b3c:	01020974 	movhi	r4,2085
 8200b40:	21324604 	addi	r4,r4,-14056
 8200b44:	8202e400 	call	8202e40 <fwrite>
         fprintf(stderr, "\n[SSS]: Task is being deleted.\n");
 8200b48:	d0a00217 	ldw	r2,-32760(gp)
 8200b4c:	10800317 	ldw	r2,12(r2)
 8200b50:	100f883a 	mov	r7,r2
 8200b54:	018007c4 	movi	r6,31
 8200b58:	01400044 	movi	r5,1
 8200b5c:	01020974 	movhi	r4,2085
 8200b60:	21324d04 	addi	r4,r4,-14028
 8200b64:	8202e400 	call	8202e40 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 8200b68:	82156d80 	call	82156d8 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 8200b6c:	01003fc4 	movi	r4,255
 8200b70:	821b0480 	call	821b048 <OSTaskDel>
         /* Invoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 8200b74:	e0bffe03 	ldbu	r2,-8(fp)
 8200b78:	000b883a 	mov	r5,zero
 8200b7c:	1009883a 	mov	r4,r2
 8200b80:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
         break;
 8200b84:	00004106 	br	8200c8c <alt_SSSErrorHandler+0x27c>
      case SYSTEM:
          /* Total System Failure, Restart Required */
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 8200b88:	01020974 	movhi	r4,2085
 8200b8c:	21325504 	addi	r4,r4,-13996
 8200b90:	82033fc0 	call	82033fc <printf>
         fprintf(stderr, "\n[SSS]: FAULT_LEVEL is SYSTEM.");
 8200b94:	d0a00217 	ldw	r2,-32760(gp)
 8200b98:	10800317 	ldw	r2,12(r2)
 8200b9c:	100f883a 	mov	r7,r2
 8200ba0:	01800784 	movi	r6,30
 8200ba4:	01400044 	movi	r5,1
 8200ba8:	01020974 	movhi	r4,2085
 8200bac:	21326004 	addi	r4,r4,-13952
 8200bb0:	8202e400 	call	8202e40 <fwrite>
         fprintf(stderr, "\n[SSS]: FATAL Error, Restart required.");
 8200bb4:	d0a00217 	ldw	r2,-32760(gp)
 8200bb8:	10800317 	ldw	r2,12(r2)
 8200bbc:	100f883a 	mov	r7,r2
 8200bc0:	01800984 	movi	r6,38
 8200bc4:	01400044 	movi	r5,1
 8200bc8:	01020974 	movhi	r4,2085
 8200bcc:	21326804 	addi	r4,r4,-13920
 8200bd0:	8202e400 	call	8202e40 <fwrite>
         fprintf(stderr, "\n[SSS]: Locking scheduler - endless loop.\n");
 8200bd4:	d0a00217 	ldw	r2,-32760(gp)
 8200bd8:	10800317 	ldw	r2,12(r2)
 8200bdc:	100f883a 	mov	r7,r2
 8200be0:	01800a84 	movi	r6,42
 8200be4:	01400044 	movi	r5,1
 8200be8:	01020974 	movhi	r4,2085
 8200bec:	21327204 	addi	r4,r4,-13880
 8200bf0:	8202e400 	call	8202e40 <fwrite>
         while(1); /* Since scheduler is locked, loop halts all task activity.*/
 8200bf4:	003fff06 	br	8200bf4 <alt_SSSErrorHandler+0x1e4>
         break;
      case NONE:
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is NONE.");
 8200bf8:	d0a00217 	ldw	r2,-32760(gp)
 8200bfc:	10800317 	ldw	r2,12(r2)
 8200c00:	100f883a 	mov	r7,r2
 8200c04:	018006c4 	movi	r6,27
 8200c08:	01400044 	movi	r5,1
 8200c0c:	01020974 	movhi	r4,2085
 8200c10:	21327d04 	addi	r4,r4,-13836
 8200c14:	8202e400 	call	8202e40 <fwrite>
         fprintf(stderr, 
 8200c18:	d0a00217 	ldw	r2,-32760(gp)
 8200c1c:	10800317 	ldw	r2,12(r2)
 8200c20:	100f883a 	mov	r7,r2
 8200c24:	01800f44 	movi	r6,61
 8200c28:	01400044 	movi	r5,1
 8200c2c:	01020974 	movhi	r4,2085
 8200c30:	21328404 	addi	r4,r4,-13808
 8200c34:	8202e400 	call	8202e40 <fwrite>
            "\n[SSS] Informational error only, control returned to task to ");
         fprintf(stderr,
 8200c38:	d0a00217 	ldw	r2,-32760(gp)
 8200c3c:	10800317 	ldw	r2,12(r2)
 8200c40:	100f883a 	mov	r7,r2
 8200c44:	01800b84 	movi	r6,46
 8200c48:	01400044 	movi	r5,1
 8200c4c:	01020974 	movhi	r4,2085
 8200c50:	21329404 	addi	r4,r4,-13744
 8200c54:	8202e400 	call	8202e40 <fwrite>
            "complete processing at the application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */ 
 8200c58:	82156d80 	call	82156d8 <OSSchedUnlock>
         return;         
 8200c5c:	00000d06 	br	8200c94 <alt_SSSErrorHandler+0x284>
         break;
      default:
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is Unknown).\n");
 8200c60:	01020974 	movhi	r4,2085
 8200c64:	2132a004 	addi	r4,r4,-13696
 8200c68:	82036800 	call	8203680 <puts>
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is unknown!?!\n");
 8200c6c:	d0a00217 	ldw	r2,-32760(gp)
 8200c70:	10800317 	ldw	r2,12(r2)
 8200c74:	100f883a 	mov	r7,r2
 8200c78:	01800844 	movi	r6,33
 8200c7c:	01400044 	movi	r5,1
 8200c80:	01020974 	movhi	r4,2085
 8200c84:	2132ac04 	addi	r4,r4,-13648
 8200c88:	8202e400 	call	8202e40 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 8200c8c:	003fff06 	br	8200c8c <alt_SSSErrorHandler+0x27c>
{
   FAULT_LEVEL fault_level;
   
   if   (error_code == OS_NO_ERR)
   {
      return;
 8200c90:	0001883a 	nop
      default:
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is Unknown).\n");
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is unknown!?!\n");
   }
   while(1); /* Correct Program Flow never gets here. */
}
 8200c94:	e037883a 	mov	sp,fp
 8200c98:	dfc00117 	ldw	ra,4(sp)
 8200c9c:	df000017 	ldw	fp,0(sp)
 8200ca0:	dec00204 	addi	sp,sp,8
 8200ca4:	f800283a 	ret

08200ca8 <SSSInitialTask>:
/* SSSInitialTask will initialize the NicheStack
 * TCP/IP Stack and then initialize the rest of the Simple Socket Server example 
 * RTOS structures and tasks. 
 */
void SSSInitialTask(void *task_data)
{
 8200ca8:	defffc04 	addi	sp,sp,-16
 8200cac:	dfc00315 	stw	ra,12(sp)
 8200cb0:	df000215 	stw	fp,8(sp)
 8200cb4:	df000204 	addi	fp,sp,8
 8200cb8:	e13fff15 	stw	r4,-4(fp)
   * NicheStack is initialized from a task, so that RTOS will have started, and 
   * I/O drivers are available.  Two tasks are created:
   *    "Inet main"  task with priority 2
   *    "clock tick" task with priority 3
   */   
  alt_iniche_init();
 8200cbc:	822dd3c0 	call	822dd3c <alt_iniche_init>
  netmain(); 
 8200cc0:	822934c0 	call	822934c <netmain>

  /* Wait for the network stack to be ready before proceeding. 
   * iniche_net_ready indicates that TCP/IP stack is ready, and IP address is obtained.
   */
  while (!iniche_net_ready)
 8200cc4:	00000206 	br	8200cd0 <SSSInitialTask+0x28>
    TK_SLEEP(1);
 8200cc8:	01000084 	movi	r4,2
 8200ccc:	821bf340 	call	821bf34 <OSTimeDly>
  netmain(); 

  /* Wait for the network stack to be ready before proceeding. 
   * iniche_net_ready indicates that TCP/IP stack is ready, and IP address is obtained.
   */
  while (!iniche_net_ready)
 8200cd0:	d0a08c17 	ldw	r2,-32208(gp)
 8200cd4:	103ffc26 	beq	r2,zero,8200cc8 <SSSInitialTask+0x20>

  /* Now that the stack is running, perform the application initialization steps */
  
  /* Application Specific Task Launching Code Block Begin */

  printf("\nSimple Socket Server starting up\n");
 8200cd8:	01020974 	movhi	r4,2085
 8200cdc:	2132bb04 	addi	r4,r4,-13588
 8200ce0:	82036800 	call	8203680 <puts>

  /* Create the main simple socket server task. */
  TK_NEWTASK(&ssstask);
 8200ce4:	01020974 	movhi	r4,2085
 8200ce8:	2107d404 	addi	r4,r4,8016
 8200cec:	822d9b80 	call	822d9b8 <TK_NEWTASK>
  
  /*create os data structures */
  SSSCreateOSDataStructs(); 
 8200cf0:	82018d80 	call	82018d8 <SSSCreateOSDataStructs>

  /* create the other tasks */
  SSSCreateTasks();
 8200cf4:	820197c0 	call	820197c <SSSCreateTasks>

  /* Application Specific Task Launching Code Block End */
  
  /*This task is deleted because there is no need for it to run again */
  error_code = OSTaskDel(OS_PRIO_SELF);
 8200cf8:	01003fc4 	movi	r4,255
 8200cfc:	821b0480 	call	821b048 <OSTaskDel>
 8200d00:	e0bffe05 	stb	r2,-8(fp)
  alt_uCOSIIErrorHandler(error_code, 0);
 8200d04:	e0bffe03 	ldbu	r2,-8(fp)
 8200d08:	000b883a 	mov	r5,zero
 8200d0c:	1009883a 	mov	r4,r2
 8200d10:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  
  while (1); /* Correct Program Flow should never get here */
 8200d14:	003fff06 	br	8200d14 <SSSInitialTask+0x6c>

08200d18 <main>:

/* Main creates a single task, SSSInitialTask, and starts task scheduler.
 */

int main (int argc, char* argv[], char* envp[])
{
 8200d18:	defff504 	addi	sp,sp,-44
 8200d1c:	dfc00a15 	stw	ra,40(sp)
 8200d20:	df000915 	stw	fp,36(sp)
 8200d24:	df000904 	addi	fp,sp,36
 8200d28:	e13ffd15 	stw	r4,-12(fp)
 8200d2c:	e17ffe15 	stw	r5,-8(fp)
 8200d30:	e1bfff15 	stw	r6,-4(fp)
  
  INT8U error_code;

  /* Clear the RTOS timer */
  OSTimeSet(0);
 8200d34:	0009883a 	mov	r4,zero
 8200d38:	821c3c80 	call	821c3c8 <OSTimeSet>

  /* SSSInitialTask will initialize the NicheStack
   * TCP/IP Stack and then initialize the rest of the Simple Socket Server example 
   * RTOS structures and tasks. 
   */  
  error_code = OSTaskCreateExt(SSSInitialTask,
 8200d3c:	d8000415 	stw	zero,16(sp)
 8200d40:	d8000315 	stw	zero,12(sp)
 8200d44:	00820004 	movi	r2,2048
 8200d48:	d8800215 	stw	r2,8(sp)
 8200d4c:	00820974 	movhi	r2,2085
 8200d50:	10923904 	addi	r2,r2,18660
 8200d54:	d8800115 	stw	r2,4(sp)
 8200d58:	00800144 	movi	r2,5
 8200d5c:	d8800015 	stw	r2,0(sp)
 8200d60:	01c00144 	movi	r7,5
 8200d64:	01820974 	movhi	r6,2085
 8200d68:	319a3904 	addi	r6,r6,26852
 8200d6c:	000b883a 	mov	r5,zero
 8200d70:	01020834 	movhi	r4,2080
 8200d74:	21032a04 	addi	r4,r4,3240
 8200d78:	821ae640 	call	821ae64 <OSTaskCreateExt>
 8200d7c:	e0bffc05 	stb	r2,-16(fp)
                             SSS_INITIAL_TASK_PRIORITY,
                             SSSInitialTaskStk,
                             TASK_STACKSIZE,
                             NULL,
                             0);
  alt_uCOSIIErrorHandler(error_code, 0);
 8200d80:	e0bffc03 	ldbu	r2,-16(fp)
 8200d84:	000b883a 	mov	r5,zero
 8200d88:	1009883a 	mov	r4,r2
 8200d8c:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>

  /*
   * As with all MicroC/OS-II designs, once the initial thread(s) and 
   * associated RTOS resources are declared, we start the RTOS. That's it!
   */
  OSStart();
 8200d90:	82157b40 	call	82157b4 <OSStart>

  
  while(1); /* Correct Program Flow never gets here. */
 8200d94:	003fff06 	br	8200d94 <main+0x7c>

08200d98 <led_bit_toggle>:
 * Development Board which controls 8 LEDs, D0 - D7.
 * 
 */
 
void led_bit_toggle(OS_FLAGS bit)
{
 8200d98:	defffc04 	addi	sp,sp,-16
 8200d9c:	dfc00315 	stw	ra,12(sp)
 8200da0:	df000215 	stw	fp,8(sp)
 8200da4:	df000204 	addi	fp,sp,8
 8200da8:	2005883a 	mov	r2,r4
 8200dac:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS  led_8_val;
    INT8U error_code;
    
    led_8_val = OSFlagQuery(SSSLEDEventFlag, &error_code);
 8200db0:	d0a05c17 	ldw	r2,-32400(gp)
 8200db4:	e0fffe84 	addi	r3,fp,-6
 8200db8:	180b883a 	mov	r5,r3
 8200dbc:	1009883a 	mov	r4,r2
 8200dc0:	82180740 	call	8218074 <OSFlagQuery>
 8200dc4:	e0bffe0d 	sth	r2,-8(fp)
    alt_uCOSIIErrorHandler(error_code, 0);
 8200dc8:	e0bffe83 	ldbu	r2,-6(fp)
 8200dcc:	10803fcc 	andi	r2,r2,255
 8200dd0:	000b883a 	mov	r5,zero
 8200dd4:	1009883a 	mov	r4,r2
 8200dd8:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
    if (bit & led_8_val)
 8200ddc:	e0ffff0b 	ldhu	r3,-4(fp)
 8200de0:	e0bffe0b 	ldhu	r2,-8(fp)
 8200de4:	1884703a 	and	r2,r3,r2
 8200de8:	10bfffcc 	andi	r2,r2,65535
 8200dec:	10000f26 	beq	r2,zero,8200e2c <led_bit_toggle+0x94>
    {
       led_8_val = OSFlagPost(SSSLEDEventFlag, bit, OS_FLAG_CLR, &error_code);
 8200df0:	d0a05c17 	ldw	r2,-32400(gp)
 8200df4:	e0ffff0b 	ldhu	r3,-4(fp)
 8200df8:	e13ffe84 	addi	r4,fp,-6
 8200dfc:	200f883a 	mov	r7,r4
 8200e00:	000d883a 	mov	r6,zero
 8200e04:	180b883a 	mov	r5,r3
 8200e08:	1009883a 	mov	r4,r2
 8200e0c:	8217ce00 	call	8217ce0 <OSFlagPost>
 8200e10:	e0bffe0d 	sth	r2,-8(fp)
       alt_uCOSIIErrorHandler(error_code, 0);
 8200e14:	e0bffe83 	ldbu	r2,-6(fp)
 8200e18:	10803fcc 	andi	r2,r2,255
 8200e1c:	000b883a 	mov	r5,zero
 8200e20:	1009883a 	mov	r4,r2
 8200e24:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
    #ifdef LED_PIO_BASE
       IOWR_ALTERA_AVALON_PIO_DATA(LED_PIO_BASE, led_8_val);
       printf("Value for LED_PIO_BASE set to %d.\n", (INT8U)led_8_val);
    #endif
      
    return;
 8200e28:	00000f06 	br	8200e68 <led_bit_toggle+0xd0>
       led_8_val = OSFlagPost(SSSLEDEventFlag, bit, OS_FLAG_CLR, &error_code);
       alt_uCOSIIErrorHandler(error_code, 0);
    }
    else
    {
       led_8_val = OSFlagPost(SSSLEDEventFlag, bit, OS_FLAG_SET, &error_code);
 8200e2c:	d0a05c17 	ldw	r2,-32400(gp)
 8200e30:	e0ffff0b 	ldhu	r3,-4(fp)
 8200e34:	e13ffe84 	addi	r4,fp,-6
 8200e38:	200f883a 	mov	r7,r4
 8200e3c:	01800044 	movi	r6,1
 8200e40:	180b883a 	mov	r5,r3
 8200e44:	1009883a 	mov	r4,r2
 8200e48:	8217ce00 	call	8217ce0 <OSFlagPost>
 8200e4c:	e0bffe0d 	sth	r2,-8(fp)
       alt_uCOSIIErrorHandler(error_code, 0);
 8200e50:	e0bffe83 	ldbu	r2,-6(fp)
 8200e54:	10803fcc 	andi	r2,r2,255
 8200e58:	000b883a 	mov	r5,zero
 8200e5c:	1009883a 	mov	r4,r2
 8200e60:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
    #ifdef LED_PIO_BASE
       IOWR_ALTERA_AVALON_PIO_DATA(LED_PIO_BASE, led_8_val);
       printf("Value for LED_PIO_BASE set to %d.\n", (INT8U)led_8_val);
    #endif
      
    return;
 8200e64:	0001883a 	nop
}
 8200e68:	e037883a 	mov	sp,fp
 8200e6c:	dfc00117 	ldw	ra,4(sp)
 8200e70:	df000017 	ldw	fp,0(sp)
 8200e74:	dec00204 	addi	sp,sp,8
 8200e78:	f800283a 	ret

08200e7c <LED7SegLightshowTask>:
 * SSSLEDLightshowSem semaphore controlled in LEDManagementTask.
 * 
 */ 
 
void LED7SegLightshowTask()
{
 8200e7c:	defffd04 	addi	sp,sp,-12
 8200e80:	dfc00215 	stw	ra,8(sp)
 8200e84:	df000115 	stw	fp,4(sp)
 8200e88:	df000104 	addi	fp,sp,4
   {
    
      /* Wait 50 milliseconds between pattern updates, to make the pattern slow
       * enough for the human eye, and more impotantly, to give up control so
       * MicroC/OS-II can schedule other lower priority tasks. */ 
      OSTimeDlyHMSM(0,0,0,50);
 8200e8c:	01c00c84 	movi	r7,50
 8200e90:	000d883a 	mov	r6,zero
 8200e94:	000b883a 	mov	r5,zero
 8200e98:	0009883a 	mov	r4,zero
 8200e9c:	821c0380 	call	821c038 <OSTimeDlyHMSM>
      
      /* Check that we still have the SSSLEDLightshowSem semaphore. If we don't,
       * then wait until the LEDManagement task gives it back to us. */
      OSSemPend(SSSLEDLightshowSem, 0, &error_code);
 8200ea0:	d0a05b17 	ldw	r2,-32404(gp)
 8200ea4:	e1bfff04 	addi	r6,fp,-4
 8200ea8:	000b883a 	mov	r5,zero
 8200eac:	1009883a 	mov	r4,r2
 8200eb0:	821a1300 	call	821a130 <OSSemPend>
      alt_uCOSIIErrorHandler(error_code, 0);
 8200eb4:	e0bfff03 	ldbu	r2,-4(fp)
 8200eb8:	10803fcc 	andi	r2,r2,255
 8200ebc:	000b883a 	mov	r5,zero
 8200ec0:	1009883a 	mov	r4,r2
 8200ec4:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
      #if SEVEN_SEG_PIO_BASE
         led_7_seg_val = rand();
         IOWR_ALTERA_AVALON_PIO_DATA(SEVEN_SEG_PIO_BASE, led_7_seg_val);
      #endif
      
      error_code = OSSemPost(SSSLEDLightshowSem);
 8200ec8:	d0a05b17 	ldw	r2,-32404(gp)
 8200ecc:	1009883a 	mov	r4,r2
 8200ed0:	821a4a80 	call	821a4a8 <OSSemPost>
 8200ed4:	e0bfff05 	stb	r2,-4(fp)
      alt_uCOSIIErrorHandler(error_code, 0);
 8200ed8:	e0bfff03 	ldbu	r2,-4(fp)
 8200edc:	10803fcc 	andi	r2,r2,255
 8200ee0:	000b883a 	mov	r5,zero
 8200ee4:	1009883a 	mov	r4,r2
 8200ee8:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
      
   }
 8200eec:	003fe706 	br	8200e8c <LED7SegLightshowTask+0x10>

08200ef0 <LEDManagementTask>:
 * The task will read the SSSLedCommandQ for an 
 * in-coming message command from the SSSSimpleSocketServerTask. 
 */
 
void LEDManagementTask()
{
 8200ef0:	defffb04 	addi	sp,sp,-20
 8200ef4:	dfc00415 	stw	ra,16(sp)
 8200ef8:	df000315 	stw	fp,12(sp)
 8200efc:	df000304 	addi	fp,sp,12
  
  INT32U led_command; 
  BOOLEAN SSSLEDLightshowActive;
  INT8U error_code;
  
  SSSLEDLightshowActive = OS_TRUE;
 8200f00:	00800044 	movi	r2,1
 8200f04:	e0bffd05 	stb	r2,-12(fp)
  
  while(1)
  {
    led_command = (INT32U)OSQPend(SSSLEDCommandQ, 0, &error_code);
 8200f08:	d0a05a17 	ldw	r2,-32408(gp)
 8200f0c:	e0ffff04 	addi	r3,fp,-4
 8200f10:	180d883a 	mov	r6,r3
 8200f14:	000b883a 	mov	r5,zero
 8200f18:	1009883a 	mov	r4,r2
 8200f1c:	82192880 	call	8219288 <OSQPend>
 8200f20:	e0bffe15 	stw	r2,-8(fp)
   
    alt_uCOSIIErrorHandler(error_code, 0);
 8200f24:	e0bfff03 	ldbu	r2,-4(fp)
 8200f28:	10803fcc 	andi	r2,r2,255
 8200f2c:	000b883a 	mov	r5,zero
 8200f30:	1009883a 	mov	r4,r2
 8200f34:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
        
    switch (led_command) {
 8200f38:	e0bffe17 	ldw	r2,-8(fp)
 8200f3c:	10bff404 	addi	r2,r2,-48
 8200f40:	10c00928 	cmpgeui	r3,r2,36
 8200f44:	18005d1e 	bne	r3,zero,82010bc <LEDManagementTask+0x1cc>
 8200f48:	100690ba 	slli	r3,r2,2
 8200f4c:	00820834 	movhi	r2,2080
 8200f50:	1083d804 	addi	r2,r2,3936
 8200f54:	1885883a 	add	r2,r3,r2
 8200f58:	10800017 	ldw	r2,0(r2)
 8200f5c:	1000683a 	jmp	r2
 8200f60:	08200ff0 	cmpltui	zero,at,32831
 8200f64:	08200ffc 	xorhi	zero,at,32831
 8200f68:	08201008 	cmpgei	zero,at,-32704
 8200f6c:	08201014 	ori	zero,at,32832
 8200f70:	08201020 	cmpeqi	zero,at,-32704
 8200f74:	0820102c 	andhi	zero,at,32832
 8200f78:	08201038 	rdprs	zero,at,-32704
 8200f7c:	08201044 	addi	zero,at,-32703
 8200f80:	082010bc 	xorhi	zero,at,32834
 8200f84:	082010bc 	xorhi	zero,at,32834
 8200f88:	082010bc 	xorhi	zero,at,32834
 8200f8c:	082010bc 	xorhi	zero,at,32834
 8200f90:	082010bc 	xorhi	zero,at,32834
 8200f94:	082010bc 	xorhi	zero,at,32834
 8200f98:	082010bc 	xorhi	zero,at,32834
 8200f9c:	082010bc 	xorhi	zero,at,32834
 8200fa0:	082010bc 	xorhi	zero,at,32834
 8200fa4:	082010bc 	xorhi	zero,at,32834
 8200fa8:	082010bc 	xorhi	zero,at,32834
 8200fac:	082010bc 	xorhi	zero,at,32834
 8200fb0:	082010bc 	xorhi	zero,at,32834
 8200fb4:	082010bc 	xorhi	zero,at,32834
 8200fb8:	082010bc 	xorhi	zero,at,32834
 8200fbc:	082010bc 	xorhi	zero,at,32834
 8200fc0:	082010bc 	xorhi	zero,at,32834
 8200fc4:	082010bc 	xorhi	zero,at,32834
 8200fc8:	082010bc 	xorhi	zero,at,32834
 8200fcc:	082010bc 	xorhi	zero,at,32834
 8200fd0:	082010bc 	xorhi	zero,at,32834
 8200fd4:	082010bc 	xorhi	zero,at,32834
 8200fd8:	082010bc 	xorhi	zero,at,32834
 8200fdc:	082010bc 	xorhi	zero,at,32834
 8200fe0:	082010bc 	xorhi	zero,at,32834
 8200fe4:	082010bc 	xorhi	zero,at,32834
 8200fe8:	082010bc 	xorhi	zero,at,32834
 8200fec:	08201050 	cmplti	zero,at,-32703
      case CMD_LEDS_BIT_0_TOGGLE:
         led_bit_toggle(BIT_0);
 8200ff0:	01000044 	movi	r4,1
 8200ff4:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8200ff8:	00003106 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_1_TOGGLE:
         led_bit_toggle(BIT_1);
 8200ffc:	01000084 	movi	r4,2
 8201000:	8200d980 	call	8200d98 <led_bit_toggle>
         break;   
 8201004:	00002e06 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_2_TOGGLE:
         led_bit_toggle(BIT_2);
 8201008:	01000104 	movi	r4,4
 820100c:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8201010:	00002b06 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_3_TOGGLE:
         led_bit_toggle(BIT_3);
 8201014:	01000204 	movi	r4,8
 8201018:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 820101c:	00002806 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_4_TOGGLE:
         led_bit_toggle(BIT_4);
 8201020:	01000404 	movi	r4,16
 8201024:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8201028:	00002506 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_5_TOGGLE:
         led_bit_toggle(BIT_5);
 820102c:	01000804 	movi	r4,32
 8201030:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8201034:	00002206 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_6_TOGGLE:
         led_bit_toggle(BIT_6);
 8201038:	01001004 	movi	r4,64
 820103c:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8201040:	00001f06 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_7_TOGGLE:
         led_bit_toggle(BIT_7);
 8201044:	01002004 	movi	r4,128
 8201048:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 820104c:	00001c06 	br	82010c0 <LEDManagementTask+0x1d0>
         /* The SSSLEDLightshowSem semaphore is checked by LED7SegLightshowTask 
          * each time it updates 7 segment LED displays, U8 and U9.  Grab the 
          * semaphore (pend) away from the lightshow task to toggle the lightshow off, 
          * and give up the semaphore (post) to turn the lightshow back on.  
          */
         if (SSSLEDLightshowActive == OS_FALSE)
 8201050:	e0bffd03 	ldbu	r2,-12(fp)
 8201054:	10000c1e 	bne	r2,zero,8201088 <LEDManagementTask+0x198>
         {
             error_code = OSSemPost(SSSLEDLightshowSem);
 8201058:	d0a05b17 	ldw	r2,-32404(gp)
 820105c:	1009883a 	mov	r4,r2
 8201060:	821a4a80 	call	821a4a8 <OSSemPost>
 8201064:	e0bfff05 	stb	r2,-4(fp)
             alt_uCOSIIErrorHandler(error_code, 0);
 8201068:	e0bfff03 	ldbu	r2,-4(fp)
 820106c:	10803fcc 	andi	r2,r2,255
 8201070:	000b883a 	mov	r5,zero
 8201074:	1009883a 	mov	r4,r2
 8201078:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
             SSSLEDLightshowActive = OS_TRUE;
 820107c:	00800044 	movi	r2,1
 8201080:	e0bffd05 	stb	r2,-12(fp)
         {
             OSSemPend(SSSLEDLightshowSem, 0, &error_code);
             alt_uCOSIIErrorHandler(error_code, 0); 
             SSSLEDLightshowActive = OS_FALSE;
         }     
         break;
 8201084:	00000e06 	br	82010c0 <LEDManagementTask+0x1d0>
             alt_uCOSIIErrorHandler(error_code, 0);
             SSSLEDLightshowActive = OS_TRUE;
         }
         else
         {
             OSSemPend(SSSLEDLightshowSem, 0, &error_code);
 8201088:	d0a05b17 	ldw	r2,-32404(gp)
 820108c:	e0ffff04 	addi	r3,fp,-4
 8201090:	180d883a 	mov	r6,r3
 8201094:	000b883a 	mov	r5,zero
 8201098:	1009883a 	mov	r4,r2
 820109c:	821a1300 	call	821a130 <OSSemPend>
             alt_uCOSIIErrorHandler(error_code, 0); 
 82010a0:	e0bfff03 	ldbu	r2,-4(fp)
 82010a4:	10803fcc 	andi	r2,r2,255
 82010a8:	000b883a 	mov	r5,zero
 82010ac:	1009883a 	mov	r4,r2
 82010b0:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
             SSSLEDLightshowActive = OS_FALSE;
 82010b4:	e03ffd05 	stb	zero,-12(fp)
         }     
         break;
 82010b8:	00000106 	br	82010c0 <LEDManagementTask+0x1d0>
      default:     
        /* Discard unknown LED commands. */
        break;
 82010bc:	0001883a 	nop
    } /* switch led_command */
  } /* while(1) */
 82010c0:	003f9106 	br	8200f08 <LEDManagementTask+0x18>

082010c4 <get_mac_addr>:
* Read the MAC address in a board specific way. Prompt user to enter serial 
* number to generate MAC address if failed to read from flash.
*
*/
int get_mac_addr(NET net, unsigned char mac_addr[6])
{
 82010c4:	defffb04 	addi	sp,sp,-20
 82010c8:	dfc00415 	stw	ra,16(sp)
 82010cc:	df000315 	stw	fp,12(sp)
 82010d0:	df000304 	addi	fp,sp,12
 82010d4:	e13ffe15 	stw	r4,-8(fp)
 82010d8:	e17fff15 	stw	r5,-4(fp)
    error_t error = 0;
 82010dc:	e03ffd15 	stw	zero,-12(fp)
    
    error = get_board_mac_addr(mac_addr);
 82010e0:	e13fff17 	ldw	r4,-4(fp)
 82010e4:	82016140 	call	8201614 <get_board_mac_addr>
 82010e8:	e0bffd15 	stw	r2,-12(fp)
    
    if(error)
 82010ec:	e0bffd17 	ldw	r2,-12(fp)
 82010f0:	10000326 	beq	r2,zero,8201100 <get_mac_addr+0x3c>
    {
        /* Failed read MAC address from flash, prompt user to enter serial 
           number to generate MAC address. */
        error = generate_mac_addr(mac_addr);
 82010f4:	e13fff17 	ldw	r4,-4(fp)
 82010f8:	82014d80 	call	82014d8 <generate_mac_addr>
 82010fc:	e0bffd15 	stw	r2,-12(fp)
    }
    return error;
 8201100:	e0bffd17 	ldw	r2,-12(fp)
}
 8201104:	e037883a 	mov	sp,fp
 8201108:	dfc00117 	ldw	ra,4(sp)
 820110c:	df000017 	ldw	fp,0(sp)
 8201110:	dec00204 	addi	sp,sp,8
 8201114:	f800283a 	ret

08201118 <get_ip_addr>:
int get_ip_addr(alt_iniche_dev *p_dev,
                ip_addr* ipaddr,
                ip_addr* netmask,
                ip_addr* gw,
                int* use_dhcp)
{
 8201118:	defffb04 	addi	sp,sp,-20
 820111c:	df000415 	stw	fp,16(sp)
 8201120:	df000404 	addi	fp,sp,16
 8201124:	e13ffc15 	stw	r4,-16(fp)
 8201128:	e17ffd15 	stw	r5,-12(fp)
 820112c:	e1bffe15 	stw	r6,-8(fp)
 8201130:	e1ffff15 	stw	r7,-4(fp)

    IP4_ADDR(*ipaddr, IPADDR0, IPADDR1, IPADDR2, IPADDR3);
 8201134:	e0bffd17 	ldw	r2,-12(fp)
 8201138:	10000015 	stw	zero,0(r2)
    IP4_ADDR(*gw, GWADDR0, GWADDR1, GWADDR2, GWADDR3);
 820113c:	e0bfff17 	ldw	r2,-4(fp)
 8201140:	10000015 	stw	zero,0(r2)
    IP4_ADDR(*netmask, MSKADDR0, MSKADDR1, MSKADDR2, MSKADDR3);
 8201144:	e0fffe17 	ldw	r3,-8(fp)
 8201148:	00804034 	movhi	r2,256
 820114c:	10bfffc4 	addi	r2,r2,-1
 8201150:	18800015 	stw	r2,0(r3)

#ifdef DHCP_CLIENT
    *use_dhcp = 1;
 8201154:	e0800117 	ldw	r2,4(fp)
 8201158:	00c00044 	movi	r3,1
 820115c:	10c00015 	stw	r3,0(r2)
        ip4_addr4(*ipaddr));
#endif /* not DHCP_CLIENT */


    /* Non-standard API: return 1 for success */
    return 1;
 8201160:	00800044 	movi	r2,1
}
 8201164:	e037883a 	mov	sp,fp
 8201168:	df000017 	ldw	fp,0(sp)
 820116c:	dec00104 	addi	sp,sp,4
 8201170:	f800283a 	ret

08201174 <get_serial_number>:
*
* Prompt user to enter 9-digit serial number. 
*
*/
alt_u32 get_serial_number (void)
{
 8201174:	defff904 	addi	sp,sp,-28
 8201178:	dfc00615 	stw	ra,24(sp)
 820117c:	df000515 	stw	fp,20(sp)
 8201180:	df000504 	addi	fp,sp,20
    alt_u32 ser_num = 0;
 8201184:	e03ffb15 	stw	zero,-20(fp)
    char serial_number[9];
    int i = 0;
 8201188:	e03ffc15 	stw	zero,-16(fp)
    
    while(!ser_num)
 820118c:	00006006 	br	8201310 <get_serial_number+0x19c>
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
 8201190:	01020974 	movhi	r4,2085
 8201194:	2132c404 	addi	r4,r4,-13552
 8201198:	82036800 	call	8203680 <puts>
        printf("label under your Nios dev. board. The first 3 digits of the \n");
 820119c:	01020974 	movhi	r4,2085
 82011a0:	2132d404 	addi	r4,r4,-13488
 82011a4:	82036800 	call	8203680 <puts>
        printf("label are ASJ and the serial number follows this.\n -->");
 82011a8:	01020974 	movhi	r4,2085
 82011ac:	2132e404 	addi	r4,r4,-13424
 82011b0:	82033fc0 	call	82033fc <printf>
        
        for(i=0; i<9; i++)
 82011b4:	e03ffc15 	stw	zero,-16(fp)
 82011b8:	00002606 	br	8201254 <get_serial_number+0xe0>
        {
            serial_number[i] = getchar();
 82011bc:	d0a00217 	ldw	r2,-32760(gp)
 82011c0:	10800117 	ldw	r2,4(r2)
 82011c4:	1009883a 	mov	r4,r2
 82011c8:	8202ee40 	call	8202ee4 <getc>
 82011cc:	1009883a 	mov	r4,r2
 82011d0:	e0fffd04 	addi	r3,fp,-12
 82011d4:	e0bffc17 	ldw	r2,-16(fp)
 82011d8:	1885883a 	add	r2,r3,r2
 82011dc:	11000005 	stb	r4,0(r2)
            putchar(serial_number[i]);
 82011e0:	e0fffd04 	addi	r3,fp,-12
 82011e4:	e0bffc17 	ldw	r2,-16(fp)
 82011e8:	1885883a 	add	r2,r3,r2
 82011ec:	10800003 	ldbu	r2,0(r2)
 82011f0:	10c03fcc 	andi	r3,r2,255
 82011f4:	18c0201c 	xori	r3,r3,128
 82011f8:	18ffe004 	addi	r3,r3,-128
 82011fc:	d0a00217 	ldw	r2,-32760(gp)
 8201200:	10800217 	ldw	r2,8(r2)
 8201204:	100b883a 	mov	r5,r2
 8201208:	1809883a 	mov	r4,r3
 820120c:	82034d80 	call	82034d8 <putc>
            
            /* Handle backspaces.  How civilized. */
            if ((serial_number[i] == 0x08) && (i >= 0)) 
 8201210:	e0fffd04 	addi	r3,fp,-12
 8201214:	e0bffc17 	ldw	r2,-16(fp)
 8201218:	1885883a 	add	r2,r3,r2
 820121c:	10800003 	ldbu	r2,0(r2)
 8201220:	10803fcc 	andi	r2,r2,255
 8201224:	1080201c 	xori	r2,r2,128
 8201228:	10bfe004 	addi	r2,r2,-128
 820122c:	10800218 	cmpnei	r2,r2,8
 8201230:	1000051e 	bne	r2,zero,8201248 <get_serial_number+0xd4>
 8201234:	e0bffc17 	ldw	r2,-16(fp)
 8201238:	10000316 	blt	r2,zero,8201248 <get_serial_number+0xd4>
            {
                i--;
 820123c:	e0bffc17 	ldw	r2,-16(fp)
 8201240:	10bfffc4 	addi	r2,r2,-1
 8201244:	e0bffc15 	stw	r2,-16(fp)
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
        printf("label under your Nios dev. board. The first 3 digits of the \n");
        printf("label are ASJ and the serial number follows this.\n -->");
        
        for(i=0; i<9; i++)
 8201248:	e0bffc17 	ldw	r2,-16(fp)
 820124c:	10800044 	addi	r2,r2,1
 8201250:	e0bffc15 	stw	r2,-16(fp)
 8201254:	e0bffc17 	ldw	r2,-16(fp)
 8201258:	10800250 	cmplti	r2,r2,9
 820125c:	103fd71e 	bne	r2,zero,82011bc <get_serial_number+0x48>
            if ((serial_number[i] == 0x08) && (i >= 0)) 
            {
                i--;
            }
        }
        printf("\n");
 8201260:	01000284 	movi	r4,10
 8201264:	82035a80 	call	82035a8 <putchar>
                
        for(i=0; i<9; i++)
 8201268:	e03ffc15 	stw	zero,-16(fp)
 820126c:	00002506 	br	8201304 <get_serial_number+0x190>
        {
            if (isdigit(serial_number[i]))
 8201270:	d0e00017 	ldw	r3,-32768(gp)
 8201274:	e13ffd04 	addi	r4,fp,-12
 8201278:	e0bffc17 	ldw	r2,-16(fp)
 820127c:	2085883a 	add	r2,r4,r2
 8201280:	10800003 	ldbu	r2,0(r2)
 8201284:	10803fcc 	andi	r2,r2,255
 8201288:	1080201c 	xori	r2,r2,128
 820128c:	10bfe004 	addi	r2,r2,-128
 8201290:	10800044 	addi	r2,r2,1
 8201294:	1885883a 	add	r2,r3,r2
 8201298:	10800003 	ldbu	r2,0(r2)
 820129c:	10803fcc 	andi	r2,r2,255
 82012a0:	1080010c 	andi	r2,r2,4
 82012a4:	10000f26 	beq	r2,zero,82012e4 <get_serial_number+0x170>
            {
                ser_num *= 10;
 82012a8:	e0bffb17 	ldw	r2,-20(fp)
 82012ac:	108002a4 	muli	r2,r2,10
 82012b0:	e0bffb15 	stw	r2,-20(fp)
                ser_num += serial_number[i] - '0';
 82012b4:	e0fffd04 	addi	r3,fp,-12
 82012b8:	e0bffc17 	ldw	r2,-16(fp)
 82012bc:	1885883a 	add	r2,r3,r2
 82012c0:	10800003 	ldbu	r2,0(r2)
 82012c4:	10c03fcc 	andi	r3,r2,255
 82012c8:	18c0201c 	xori	r3,r3,128
 82012cc:	18ffe004 	addi	r3,r3,-128
 82012d0:	e0bffb17 	ldw	r2,-20(fp)
 82012d4:	1885883a 	add	r2,r3,r2
 82012d8:	10bff404 	addi	r2,r2,-48
 82012dc:	e0bffb15 	stw	r2,-20(fp)
 82012e0:	00000506 	br	82012f8 <get_serial_number+0x184>
            }
            else
            {
                ser_num = 0;
 82012e4:	e03ffb15 	stw	zero,-20(fp)
                printf("Serial number only contains decimal digits and is non-zero\n");
 82012e8:	01020974 	movhi	r4,2085
 82012ec:	2132f204 	addi	r4,r4,-13368
 82012f0:	82036800 	call	8203680 <puts>
                break;
 82012f4:	00000606 	br	8201310 <get_serial_number+0x19c>
                i--;
            }
        }
        printf("\n");
                
        for(i=0; i<9; i++)
 82012f8:	e0bffc17 	ldw	r2,-16(fp)
 82012fc:	10800044 	addi	r2,r2,1
 8201300:	e0bffc15 	stw	r2,-16(fp)
 8201304:	e0bffc17 	ldw	r2,-16(fp)
 8201308:	10800250 	cmplti	r2,r2,9
 820130c:	103fd81e 	bne	r2,zero,8201270 <get_serial_number+0xfc>
{
    alt_u32 ser_num = 0;
    char serial_number[9];
    int i = 0;
    
    while(!ser_num)
 8201310:	e0bffb17 	ldw	r2,-20(fp)
 8201314:	103f9e26 	beq	r2,zero,8201190 <get_serial_number+0x1c>
                break;
            }
        }
    }
    
    return ser_num;
 8201318:	e0bffb17 	ldw	r2,-20(fp)
}
 820131c:	e037883a 	mov	sp,fp
 8201320:	dfc00117 	ldw	ra,4(sp)
 8201324:	df000017 	ldw	fp,0(sp)
 8201328:	dec00204 	addi	sp,sp,8
 820132c:	f800283a 	ret

08201330 <generate_and_store_mac_addr>:
 * sections. These fail-safe static settings are compatible with previous
 * Nios Ethernet designs, and allow the "factory-safe" design to behave 
 * as expected if the last flash sector is erased.
 */
error_t generate_and_store_mac_addr()
{
 8201330:	deffef04 	addi	sp,sp,-68
 8201334:	dfc01015 	stw	ra,64(sp)
 8201338:	df000f15 	stw	fp,60(sp)
 820133c:	df000f04 	addi	fp,sp,60
    error_t error = -1;
 8201340:	00bfffc4 	movi	r2,-1
 8201344:	e0bff115 	stw	r2,-60(fp)
    alt_u32 ser_num = 0;
 8201348:	e03ff215 	stw	zero,-56(fp)
    char flash_content[32];
    alt_flash_fd* flash_handle;
    
    printf("Can't read the MAC address from your board (this probably means\n");
 820134c:	01020974 	movhi	r4,2085
 8201350:	21330104 	addi	r4,r4,-13308
 8201354:	82036800 	call	8203680 <puts>
    printf("that your flash was erased). We will assign you a MAC address and\n");
 8201358:	01020974 	movhi	r4,2085
 820135c:	21331104 	addi	r4,r4,-13244
 8201360:	82036800 	call	8203680 <puts>
    printf("static network settings\n\n");
 8201364:	01020974 	movhi	r4,2085
 8201368:	21332204 	addi	r4,r4,-13176
 820136c:	82036800 	call	8203680 <puts>
    
    ser_num = 123456789;//get_serial_number();
 8201370:	0081d734 	movhi	r2,1884
 8201374:	10b34544 	addi	r2,r2,-13035
 8201378:	e0bff215 	stw	r2,-56(fp)
  
    if (ser_num)
 820137c:	e0bff217 	ldw	r2,-56(fp)
 8201380:	10004f26 	beq	r2,zero,82014c0 <generate_and_store_mac_addr+0x190>
    {
        /* This says the image is safe */
        flash_content[0] = 0xfe;
 8201384:	00bfff84 	movi	r2,-2
 8201388:	e0bff805 	stb	r2,-32(fp)
        flash_content[1] = 0x5a;
 820138c:	00801684 	movi	r2,90
 8201390:	e0bff845 	stb	r2,-31(fp)
        flash_content[2] = 0x0;
 8201394:	e03ff885 	stb	zero,-30(fp)
        flash_content[3] = 0x0;
 8201398:	e03ff8c5 	stb	zero,-29(fp)
        
        /* This is the Altera Vendor ID */
        flash_content[4] = 0x0;
 820139c:	e03ff905 	stb	zero,-28(fp)
        flash_content[5] = 0x7;
 82013a0:	008001c4 	movi	r2,7
 82013a4:	e0bff945 	stb	r2,-27(fp)
        flash_content[6] = 0xed;
 82013a8:	00bffb44 	movi	r2,-19
 82013ac:	e0bff985 	stb	r2,-26(fp)
        
        /* Reserverd Board identifier for erase boards */
        flash_content[7] = 0xFF;
 82013b0:	00bfffc4 	movi	r2,-1
 82013b4:	e0bff9c5 	stb	r2,-25(fp)
        flash_content[8] = (ser_num & 0xff00) >> 8;
 82013b8:	e0bff217 	ldw	r2,-56(fp)
 82013bc:	10bfc00c 	andi	r2,r2,65280
 82013c0:	1004d23a 	srli	r2,r2,8
 82013c4:	e0bffa05 	stb	r2,-24(fp)
        flash_content[9] = ser_num & 0xff;
 82013c8:	e0bff217 	ldw	r2,-56(fp)
 82013cc:	e0bffa45 	stb	r2,-23(fp)
        
        /* Then comes a 16-bit "flags" field */
        flash_content[10] = 0xFF;
 82013d0:	00bfffc4 	movi	r2,-1
 82013d4:	e0bffa85 	stb	r2,-22(fp)
        flash_content[11] = 0xFF;
 82013d8:	00bfffc4 	movi	r2,-1
 82013dc:	e0bffac5 	stb	r2,-21(fp)
        
        /* Then comes the static IP address */
        flash_content[12] = IPADDR0;
 82013e0:	e03ffb05 	stb	zero,-20(fp)
        flash_content[13] = IPADDR1;
 82013e4:	e03ffb45 	stb	zero,-19(fp)
        flash_content[14] = IPADDR2;
 82013e8:	e03ffb85 	stb	zero,-18(fp)
        flash_content[15] = IPADDR3;
 82013ec:	e03ffbc5 	stb	zero,-17(fp)
        
        /* Then comes the static nameserver address */
        flash_content[16] = 0xFF;
 82013f0:	00bfffc4 	movi	r2,-1
 82013f4:	e0bffc05 	stb	r2,-16(fp)
        flash_content[17] = 0xFF;
 82013f8:	00bfffc4 	movi	r2,-1
 82013fc:	e0bffc45 	stb	r2,-15(fp)
        flash_content[18] = 0xFF;
 8201400:	00bfffc4 	movi	r2,-1
 8201404:	e0bffc85 	stb	r2,-14(fp)
        flash_content[19] = 0xFF;
 8201408:	00bfffc4 	movi	r2,-1
 820140c:	e0bffcc5 	stb	r2,-13(fp)
        
        /* Then comes the static subnet mask */
        flash_content[20] = MSKADDR0;
 8201410:	00bfffc4 	movi	r2,-1
 8201414:	e0bffd05 	stb	r2,-12(fp)
        flash_content[21] = MSKADDR1;
 8201418:	00bfffc4 	movi	r2,-1
 820141c:	e0bffd45 	stb	r2,-11(fp)
        flash_content[22] = MSKADDR2;
 8201420:	00bfffc4 	movi	r2,-1
 8201424:	e0bffd85 	stb	r2,-10(fp)
        flash_content[23] = MSKADDR3;
 8201428:	e03ffdc5 	stb	zero,-9(fp)
        
        /* Then comes the static gateway address */
        flash_content[24] = GWADDR0;
 820142c:	e03ffe05 	stb	zero,-8(fp)
        flash_content[25] = GWADDR1;
 8201430:	e03ffe45 	stb	zero,-7(fp)
        flash_content[26] = GWADDR2;
 8201434:	e03ffe85 	stb	zero,-6(fp)
        flash_content[27] = GWADDR3;
 8201438:	e03ffec5 	stb	zero,-5(fp)
        
        /* And finally whether to use DHCP - set all bits to be safe */
        flash_content[28] = 0xFF;
 820143c:	00bfffc4 	movi	r2,-1
 8201440:	e0bfff05 	stb	r2,-4(fp)
        flash_content[29] = 0xFF;
 8201444:	00bfffc4 	movi	r2,-1
 8201448:	e0bfff45 	stb	r2,-3(fp)
        flash_content[30] = 0xFF;
 820144c:	00bfffc4 	movi	r2,-1
 8201450:	e0bfff85 	stb	r2,-2(fp)
        flash_content[31] = 0xFF;
 8201454:	00bfffc4 	movi	r2,-1
 8201458:	e0bfffc5 	stb	r2,-1(fp)
        
        /* Write the MAC address to flash */
        flash_handle = alt_flash_open_dev(EXT_FLASH_NAME);
 820145c:	01020974 	movhi	r4,2085
 8201460:	21332904 	addi	r4,r4,-13148
 8201464:	821442c0 	call	821442c <alt_flash_open_dev>
 8201468:	e0bff315 	stw	r2,-52(fp)
        if (flash_handle)
 820146c:	e0bff317 	ldw	r2,-52(fp)
 8201470:	10001326 	beq	r2,zero,82014c0 <generate_and_store_mac_addr+0x190>
        {
            alt_write_flash(flash_handle,
 8201474:	d0a05717 	ldw	r2,-32420(gp)
 8201478:	1007883a 	mov	r3,r2
 820147c:	e0bff317 	ldw	r2,-52(fp)
 8201480:	e0bff415 	stw	r2,-48(fp)
 8201484:	e0fff515 	stw	r3,-44(fp)
 8201488:	e0bff804 	addi	r2,fp,-32
 820148c:	e0bff615 	stw	r2,-40(fp)
 8201490:	00800804 	movi	r2,32
 8201494:	e0bff715 	stw	r2,-36(fp)
                                                           alt_flash_fd* fd, 
                                                           int offset, 
                                                           const void* src_addr, 
                                                           int length )
{
  return fd->write( fd, offset, src_addr, length );
 8201498:	e0bff417 	ldw	r2,-48(fp)
 820149c:	10800517 	ldw	r2,20(r2)
 82014a0:	e1fff717 	ldw	r7,-36(fp)
 82014a4:	e1bff617 	ldw	r6,-40(fp)
 82014a8:	e17ff517 	ldw	r5,-44(fp)
 82014ac:	e13ff417 	ldw	r4,-48(fp)
 82014b0:	103ee83a 	callr	r2
                            last_flash_sector_offset,
                            flash_content,
                            32);
            alt_flash_close_dev(flash_handle);
 82014b4:	e13ff317 	ldw	r4,-52(fp)
 82014b8:	82144940 	call	8214494 <alt_flash_close_dev>
            error = 0;
 82014bc:	e03ff115 	stw	zero,-60(fp)
        }
    }

    return error;    
 82014c0:	e0bff117 	ldw	r2,-60(fp)
}
 82014c4:	e037883a 	mov	sp,fp
 82014c8:	dfc00117 	ldw	ra,4(sp)
 82014cc:	df000017 	ldw	fp,0(sp)
 82014d0:	dec00204 	addi	sp,sp,8
 82014d4:	f800283a 	ret

082014d8 <generate_mac_addr>:
 * Development Board serial number is 040800017, the corresponding ethernet 
 * number generated will be 00:07:ED:FF:8F:11.
 * 
 */
error_t generate_mac_addr(unsigned char mac_addr[6])
{
 82014d8:	defff804 	addi	sp,sp,-32
 82014dc:	dfc00715 	stw	ra,28(sp)
 82014e0:	df000615 	stw	fp,24(sp)
 82014e4:	df000604 	addi	fp,sp,24
 82014e8:	e13fff15 	stw	r4,-4(fp)
    error_t error = -1;
 82014ec:	00bfffc4 	movi	r2,-1
 82014f0:	e0bffd15 	stw	r2,-12(fp)
    alt_u32 ser_num = 0;
 82014f4:	e03ffe15 	stw	zero,-8(fp)
    
    printf("\nCan't read the MAC address from your board. We will assign you\n");
 82014f8:	01020974 	movhi	r4,2085
 82014fc:	21332d04 	addi	r4,r4,-13132
 8201500:	82036800 	call	8203680 <puts>
    printf("a MAC address.\n\n");
 8201504:	01020974 	movhi	r4,2085
 8201508:	21333d04 	addi	r4,r4,-13068
 820150c:	82036800 	call	8203680 <puts>
    
    ser_num = 123456789;//get_serial_number();
 8201510:	0081d734 	movhi	r2,1884
 8201514:	10b34544 	addi	r2,r2,-13035
 8201518:	e0bffe15 	stw	r2,-8(fp)
  
    if (ser_num)
 820151c:	e0bffe17 	ldw	r2,-8(fp)
 8201520:	10003626 	beq	r2,zero,82015fc <generate_mac_addr+0x124>
    {
        /* This is the Altera Vendor ID */
        mac_addr[0] = 0x0;
 8201524:	e0bfff17 	ldw	r2,-4(fp)
 8201528:	10000005 	stb	zero,0(r2)
        mac_addr[1] = 0x7;
 820152c:	e0bfff17 	ldw	r2,-4(fp)
 8201530:	10800044 	addi	r2,r2,1
 8201534:	00c001c4 	movi	r3,7
 8201538:	10c00005 	stb	r3,0(r2)
        mac_addr[2] = 0xed;
 820153c:	e0bfff17 	ldw	r2,-4(fp)
 8201540:	10800084 	addi	r2,r2,2
 8201544:	00fffb44 	movi	r3,-19
 8201548:	10c00005 	stb	r3,0(r2)
        
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
 820154c:	e0bfff17 	ldw	r2,-4(fp)
 8201550:	108000c4 	addi	r2,r2,3
 8201554:	00ffffc4 	movi	r3,-1
 8201558:	10c00005 	stb	r3,0(r2)
        mac_addr[4] = (ser_num & 0xff00) >> 8;
 820155c:	e0bfff17 	ldw	r2,-4(fp)
 8201560:	10800104 	addi	r2,r2,4
 8201564:	e0fffe17 	ldw	r3,-8(fp)
 8201568:	18ffc00c 	andi	r3,r3,65280
 820156c:	1806d23a 	srli	r3,r3,8
 8201570:	10c00005 	stb	r3,0(r2)
        mac_addr[5] = ser_num & 0xff;
 8201574:	e0bfff17 	ldw	r2,-4(fp)
 8201578:	10800144 	addi	r2,r2,5
 820157c:	e0fffe17 	ldw	r3,-8(fp)
 8201580:	10c00005 	stb	r3,0(r2)
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
            mac_addr[0],
 8201584:	e0bfff17 	ldw	r2,-4(fp)
 8201588:	10800003 	ldbu	r2,0(r2)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 820158c:	11403fcc 	andi	r5,r2,255
            mac_addr[0],
            mac_addr[1],
 8201590:	e0bfff17 	ldw	r2,-4(fp)
 8201594:	10800044 	addi	r2,r2,1
 8201598:	10800003 	ldbu	r2,0(r2)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 820159c:	11803fcc 	andi	r6,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
 82015a0:	e0bfff17 	ldw	r2,-4(fp)
 82015a4:	10800084 	addi	r2,r2,2
 82015a8:	10800003 	ldbu	r2,0(r2)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 82015ac:	11c03fcc 	andi	r7,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
 82015b0:	e0bfff17 	ldw	r2,-4(fp)
 82015b4:	108000c4 	addi	r2,r2,3
 82015b8:	10800003 	ldbu	r2,0(r2)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 82015bc:	10803fcc 	andi	r2,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
 82015c0:	e0ffff17 	ldw	r3,-4(fp)
 82015c4:	18c00104 	addi	r3,r3,4
 82015c8:	18c00003 	ldbu	r3,0(r3)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 82015cc:	18c03fcc 	andi	r3,r3,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
 82015d0:	e13fff17 	ldw	r4,-4(fp)
 82015d4:	21000144 	addi	r4,r4,5
 82015d8:	21000003 	ldbu	r4,0(r4)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 82015dc:	21003fcc 	andi	r4,r4,255
 82015e0:	d9000215 	stw	r4,8(sp)
 82015e4:	d8c00115 	stw	r3,4(sp)
 82015e8:	d8800015 	stw	r2,0(sp)
 82015ec:	01020974 	movhi	r4,2085
 82015f0:	21334104 	addi	r4,r4,-13052
 82015f4:	82033fc0 	call	82033fc <printf>
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
        
        error = 0;
 82015f8:	e03ffd15 	stw	zero,-12(fp)
    }
  
    return error;    
 82015fc:	e0bffd17 	ldw	r2,-12(fp)
}
 8201600:	e037883a 	mov	sp,fp
 8201604:	dfc00117 	ldw	ra,4(sp)
 8201608:	df000017 	ldw	fp,0(sp)
 820160c:	dec00204 	addi	sp,sp,8
 8201610:	f800283a 	ret

08201614 <get_board_mac_addr>:
*
* Read the MAC address in a board specific way
*
*/
error_t get_board_mac_addr(unsigned char mac_addr[6])
{
 8201614:	defff804 	addi	sp,sp,-32
 8201618:	dfc00715 	stw	ra,28(sp)
 820161c:	df000615 	stw	fp,24(sp)
 8201620:	df000604 	addi	fp,sp,24
 8201624:	e13fff15 	stw	r4,-4(fp)
    error_t error = 0;
 8201628:	e03ffd15 	stw	zero,-12(fp)
    alt_u32 signature;
    
    /* Get the flash sector with the MAC address. */
    error = FindLastFlashSectorOffset(&last_flash_sector_offset);
 820162c:	d1205704 	addi	r4,gp,-32420
 8201630:	82017ac0 	call	82017ac <FindLastFlashSectorOffset>
 8201634:	e0bffd15 	stw	r2,-12(fp)
    if (!error)
 8201638:	e0bffd17 	ldw	r2,-12(fp)
 820163c:	1000021e 	bne	r2,zero,8201648 <get_board_mac_addr+0x34>
        last_flash_sector = EXT_FLASH_BASE + last_flash_sector_offset;
 8201640:	d0a05717 	ldw	r2,-32420(gp)
 8201644:	d0a05815 	stw	r2,-32416(gp)
     * valid network settings are present, indicated by a signature of 0x00005afe at 
     * the first address of the last flash sector.  This hex value is chosen as the 
     * signature since it looks like the english word "SAFE", meaning that it is 
     * safe to use these network address values.  
    */
    if (!error)
 8201648:	e0bffd17 	ldw	r2,-12(fp)
 820164c:	1000081e 	bne	r2,zero,8201670 <get_board_mac_addr+0x5c>
    {
        signature = IORD_32DIRECT(last_flash_sector, 0);
 8201650:	d0a05817 	ldw	r2,-32416(gp)
 8201654:	10800037 	ldwio	r2,0(r2)
 8201658:	e0bffe15 	stw	r2,-8(fp)
        if (signature != 0x00005afe)
 820165c:	e0bffe17 	ldw	r2,-8(fp)
 8201660:	1096bfa0 	cmpeqi	r2,r2,23294
 8201664:	1000021e 	bne	r2,zero,8201670 <get_board_mac_addr+0x5c>
        {
          error = generate_and_store_mac_addr();
 8201668:	82013300 	call	8201330 <generate_and_store_mac_addr>
 820166c:	e0bffd15 	stw	r2,-12(fp)
        }
    }
  
    if (!error)
 8201670:	e0bffd17 	ldw	r2,-12(fp)
 8201674:	1000471e 	bne	r2,zero,8201794 <get_board_mac_addr+0x180>
    {
        mac_addr[0] = IORD_8DIRECT(last_flash_sector, 4);
 8201678:	d0a05817 	ldw	r2,-32416(gp)
 820167c:	10800104 	addi	r2,r2,4
 8201680:	10800023 	ldbuio	r2,0(r2)
 8201684:	10803fcc 	andi	r2,r2,255
 8201688:	1007883a 	mov	r3,r2
 820168c:	e0bfff17 	ldw	r2,-4(fp)
 8201690:	10c00005 	stb	r3,0(r2)
        mac_addr[1] = IORD_8DIRECT(last_flash_sector, 5);
 8201694:	e0bfff17 	ldw	r2,-4(fp)
 8201698:	10800044 	addi	r2,r2,1
 820169c:	d0e05817 	ldw	r3,-32416(gp)
 82016a0:	18c00144 	addi	r3,r3,5
 82016a4:	18c00023 	ldbuio	r3,0(r3)
 82016a8:	18c03fcc 	andi	r3,r3,255
 82016ac:	10c00005 	stb	r3,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
 82016b0:	e0bfff17 	ldw	r2,-4(fp)
 82016b4:	10800084 	addi	r2,r2,2
 82016b8:	d0e05817 	ldw	r3,-32416(gp)
 82016bc:	18c00184 	addi	r3,r3,6
 82016c0:	18c00023 	ldbuio	r3,0(r3)
 82016c4:	18c03fcc 	andi	r3,r3,255
 82016c8:	10c00005 	stb	r3,0(r2)
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
 82016cc:	e0bfff17 	ldw	r2,-4(fp)
 82016d0:	108000c4 	addi	r2,r2,3
 82016d4:	d0e05817 	ldw	r3,-32416(gp)
 82016d8:	18c001c4 	addi	r3,r3,7
 82016dc:	18c00023 	ldbuio	r3,0(r3)
 82016e0:	18c03fcc 	andi	r3,r3,255
 82016e4:	10c00005 	stb	r3,0(r2)
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
 82016e8:	e0bfff17 	ldw	r2,-4(fp)
 82016ec:	10800104 	addi	r2,r2,4
 82016f0:	d0e05817 	ldw	r3,-32416(gp)
 82016f4:	18c00204 	addi	r3,r3,8
 82016f8:	18c00023 	ldbuio	r3,0(r3)
 82016fc:	18c03fcc 	andi	r3,r3,255
 8201700:	10c00005 	stb	r3,0(r2)
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
 8201704:	e0bfff17 	ldw	r2,-4(fp)
 8201708:	10800144 	addi	r2,r2,5
 820170c:	d0e05817 	ldw	r3,-32416(gp)
 8201710:	18c00244 	addi	r3,r3,9
 8201714:	18c00023 	ldbuio	r3,0(r3)
 8201718:	18c03fcc 	andi	r3,r3,255
 820171c:	10c00005 	stb	r3,0(r2)
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
            mac_addr[0],
 8201720:	e0bfff17 	ldw	r2,-4(fp)
 8201724:	10800003 	ldbu	r2,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201728:	11403fcc 	andi	r5,r2,255
            mac_addr[0],
            mac_addr[1],
 820172c:	e0bfff17 	ldw	r2,-4(fp)
 8201730:	10800044 	addi	r2,r2,1
 8201734:	10800003 	ldbu	r2,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201738:	11803fcc 	andi	r6,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
 820173c:	e0bfff17 	ldw	r2,-4(fp)
 8201740:	10800084 	addi	r2,r2,2
 8201744:	10800003 	ldbu	r2,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201748:	11c03fcc 	andi	r7,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
 820174c:	e0bfff17 	ldw	r2,-4(fp)
 8201750:	108000c4 	addi	r2,r2,3
 8201754:	10800003 	ldbu	r2,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201758:	10803fcc 	andi	r2,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
 820175c:	e0ffff17 	ldw	r3,-4(fp)
 8201760:	18c00104 	addi	r3,r3,4
 8201764:	18c00003 	ldbu	r3,0(r3)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201768:	18c03fcc 	andi	r3,r3,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
 820176c:	e13fff17 	ldw	r4,-4(fp)
 8201770:	21000144 	addi	r4,r4,5
 8201774:	21000003 	ldbu	r4,0(r4)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201778:	21003fcc 	andi	r4,r4,255
 820177c:	d9000215 	stw	r4,8(sp)
 8201780:	d8c00115 	stw	r3,4(sp)
 8201784:	d8800015 	stw	r2,0(sp)
 8201788:	01020974 	movhi	r4,2085
 820178c:	21334104 	addi	r4,r4,-13052
 8201790:	82033fc0 	call	82033fc <printf>
            mac_addr[4],
            mac_addr[5]);
    
    }
    
    return error;
 8201794:	e0bffd17 	ldw	r2,-12(fp)
}
 8201798:	e037883a 	mov	sp,fp
 820179c:	dfc00117 	ldw	ra,4(sp)
 82017a0:	df000017 	ldw	fp,0(sp)
 82017a4:	dec00204 	addi	sp,sp,8
 82017a8:	f800283a 	ret

082017ac <FindLastFlashSectorOffset>:
 * in pLastFlashSectorOffset.
 */

int FindLastFlashSectorOffset(
    alt_u32                     *pLastFlashSectorOffset)
{
 82017ac:	defff304 	addi	sp,sp,-52
 82017b0:	dfc00c15 	stw	ra,48(sp)
 82017b4:	df000b15 	stw	fp,44(sp)
 82017b8:	df000b04 	addi	fp,sp,44
 82017bc:	e13fff15 	stw	r4,-4(fp)
    flash_region                *regions;
    int                         numRegions;
    flash_region                *pLastRegion;
    int                         lastFlashSectorOffset;
    int                         n;
    int                         error = 0;
 82017c0:	e03ff815 	stw	zero,-32(fp)

    /* Open the flash device. */
    fd = alt_flash_open_dev(EXT_FLASH_NAME);
 82017c4:	01020974 	movhi	r4,2085
 82017c8:	21332904 	addi	r4,r4,-13148
 82017cc:	821442c0 	call	821442c <alt_flash_open_dev>
 82017d0:	e0bff915 	stw	r2,-28(fp)
    if (fd <= 0)
 82017d4:	e0bff917 	ldw	r2,-28(fp)
 82017d8:	1000021e 	bne	r2,zero,82017e4 <FindLastFlashSectorOffset+0x38>
        error = -1;
 82017dc:	00bfffc4 	movi	r2,-1
 82017e0:	e0bff815 	stw	r2,-32(fp)

    /* Get the flash info. */
    if (!error)
 82017e4:	e0bff817 	ldw	r2,-32(fp)
 82017e8:	10000d1e 	bne	r2,zero,8201820 <FindLastFlashSectorOffset+0x74>
 82017ec:	e0bff917 	ldw	r2,-28(fp)
 82017f0:	e0bffa15 	stw	r2,-24(fp)
 82017f4:	e0bffd04 	addi	r2,fp,-12
 82017f8:	e0bffb15 	stw	r2,-20(fp)
 82017fc:	e0bffe04 	addi	r2,fp,-8
 8201800:	e0bffc15 	stw	r2,-16(fp)
 */
static __inline__ int __attribute__ ((always_inline)) alt_get_flash_info( 
                                      alt_flash_fd* fd, flash_region** info, 
                                      int* number_of_regions)
{
  return fd->get_info( fd, info, number_of_regions);
 8201804:	e0bffa17 	ldw	r2,-24(fp)
 8201808:	10800717 	ldw	r2,28(r2)
 820180c:	e1bffc17 	ldw	r6,-16(fp)
 8201810:	e17ffb17 	ldw	r5,-20(fp)
 8201814:	e13ffa17 	ldw	r4,-24(fp)
 8201818:	103ee83a 	callr	r2
        error = alt_get_flash_info(fd, &regions, &numRegions);
 820181c:	e0bff815 	stw	r2,-32(fp)

    /* Find the last flash sector. */
    if (!error)
 8201820:	e0bff817 	ldw	r2,-32(fp)
 8201824:	1000211e 	bne	r2,zero,82018ac <FindLastFlashSectorOffset+0x100>
    {
        pLastRegion = &(regions[0]);
 8201828:	e0bffd17 	ldw	r2,-12(fp)
 820182c:	e0bff515 	stw	r2,-44(fp)
        for (n = 1; n < numRegions; n++)
 8201830:	00800044 	movi	r2,1
 8201834:	e0bff715 	stw	r2,-36(fp)
 8201838:	00001006 	br	820187c <FindLastFlashSectorOffset+0xd0>
        {
            if (regions[n].offset > pLastRegion->offset)
 820183c:	e0fffd17 	ldw	r3,-12(fp)
 8201840:	e0bff717 	ldw	r2,-36(fp)
 8201844:	1004913a 	slli	r2,r2,4
 8201848:	1885883a 	add	r2,r3,r2
 820184c:	10800017 	ldw	r2,0(r2)
 8201850:	e0fff517 	ldw	r3,-44(fp)
 8201854:	18c00017 	ldw	r3,0(r3)
 8201858:	1880050e 	bge	r3,r2,8201870 <FindLastFlashSectorOffset+0xc4>
                pLastRegion = &(regions[n]);
 820185c:	e0fffd17 	ldw	r3,-12(fp)
 8201860:	e0bff717 	ldw	r2,-36(fp)
 8201864:	1004913a 	slli	r2,r2,4
 8201868:	1885883a 	add	r2,r3,r2
 820186c:	e0bff515 	stw	r2,-44(fp)

    /* Find the last flash sector. */
    if (!error)
    {
        pLastRegion = &(regions[0]);
        for (n = 1; n < numRegions; n++)
 8201870:	e0bff717 	ldw	r2,-36(fp)
 8201874:	10800044 	addi	r2,r2,1
 8201878:	e0bff715 	stw	r2,-36(fp)
 820187c:	e0bffe17 	ldw	r2,-8(fp)
 8201880:	e0fff717 	ldw	r3,-36(fp)
 8201884:	18bfed16 	blt	r3,r2,820183c <FindLastFlashSectorOffset+0x90>
        {
            if (regions[n].offset > pLastRegion->offset)
                pLastRegion = &(regions[n]);
        }
        lastFlashSectorOffset =   pLastRegion->offset
 8201888:	e0bff517 	ldw	r2,-44(fp)
 820188c:	10c00017 	ldw	r3,0(r2)
                                + pLastRegion->region_size
 8201890:	e0bff517 	ldw	r2,-44(fp)
 8201894:	10800117 	ldw	r2,4(r2)
 8201898:	1887883a 	add	r3,r3,r2
                                - pLastRegion->block_size;
 820189c:	e0bff517 	ldw	r2,-44(fp)
 82018a0:	10800317 	ldw	r2,12(r2)
        for (n = 1; n < numRegions; n++)
        {
            if (regions[n].offset > pLastRegion->offset)
                pLastRegion = &(regions[n]);
        }
        lastFlashSectorOffset =   pLastRegion->offset
 82018a4:	1885c83a 	sub	r2,r3,r2
 82018a8:	e0bff615 	stw	r2,-40(fp)
                                + pLastRegion->region_size
                                - pLastRegion->block_size;
    }

    /* Return results. */
    if (!error)
 82018ac:	e0bff817 	ldw	r2,-32(fp)
 82018b0:	1000031e 	bne	r2,zero,82018c0 <FindLastFlashSectorOffset+0x114>
        *pLastFlashSectorOffset = lastFlashSectorOffset;
 82018b4:	e0fff617 	ldw	r3,-40(fp)
 82018b8:	e0bfff17 	ldw	r2,-4(fp)
 82018bc:	10c00015 	stw	r3,0(r2)

    return (error);
 82018c0:	e0bff817 	ldw	r2,-32(fp)
}
 82018c4:	e037883a 	mov	sp,fp
 82018c8:	dfc00117 	ldw	ra,4(sp)
 82018cc:	df000017 	ldw	fp,0(sp)
 82018d0:	dec00204 	addi	sp,sp,8
 82018d4:	f800283a 	ret

082018d8 <SSSCreateOSDataStructs>:
/*
 * Create our MicroC/OS-II resources. All of the resources beginning with 
 * "SSS" are declared in this file, and created in this function.
 */
void SSSCreateOSDataStructs(void)
{
 82018d8:	defffd04 	addi	sp,sp,-12
 82018dc:	dfc00215 	stw	ra,8(sp)
 82018e0:	df000115 	stw	fp,4(sp)
 82018e4:	df000104 	addi	fp,sp,4
  /*
  * Create the resource for our MicroC/OS-II Queue for sending commands 
  * received on the TCP/IP socket from the SSSSimpleSocketServerTask()
  * to the LEDManagementTask().
  */
  SSSLEDCommandQ = OSQCreate(&SSSLEDCommandQTbl[0], SSS_LED_COMMAND_Q_SIZE);
 82018e8:	01400784 	movi	r5,30
 82018ec:	010209b4 	movhi	r4,2086
 82018f0:	21223904 	addi	r4,r4,-30492
 82018f4:	8218da40 	call	8218da4 <OSQCreate>
 82018f8:	d0a05a15 	stw	r2,-32408(gp)
  if (!SSSLEDCommandQ)
 82018fc:	d0a05a17 	ldw	r2,-32408(gp)
 8201900:	1000041e 	bne	r2,zero,8201914 <SSSCreateOSDataStructs+0x3c>
  {
     alt_uCOSIIErrorHandler(EXPANDED_DIAGNOSIS_CODE, 
 8201904:	01420974 	movhi	r5,2085
 8201908:	29735004 	addi	r5,r5,-12992
 820190c:	01003fc4 	movi	r4,255
 8201910:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  * toggle the lightshow off, and gives up the semaphore to turn the lightshow
  * back on.  The LEDTask does this in response to the CMD_LEDS_LIGHTSHOW
  * command sent from the SSSSimpleSocketServerTask when the user sends the 
  * toggle lightshow command over the TCPIP socket.
  */
  SSSLEDLightshowSem = OSSemCreate(1);
 8201914:	01000044 	movi	r4,1
 8201918:	8219e180 	call	8219e18 <OSSemCreate>
 820191c:	d0a05b15 	stw	r2,-32404(gp)
  if (!SSSLEDLightshowSem)
 8201920:	d0a05b17 	ldw	r2,-32404(gp)
 8201924:	1000041e 	bne	r2,zero,8201938 <SSSCreateOSDataStructs+0x60>
  {
     alt_uCOSIIErrorHandler(EXPANDED_DIAGNOSIS_CODE, 
 8201928:	01420974 	movhi	r5,2085
 820192c:	29735904 	addi	r5,r5,-12956
 8201930:	01003fc4 	movi	r4,255
 8201934:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  
 /*
  * Create our MicroC/OS-II LED Event Flag.  Each flag corresponds to one of
  * the LEDs on the Nios Development board, D0 - D7. 
  */   
  SSSLEDEventFlag = OSFlagCreate(0, &error_code);
 8201938:	e17fff04 	addi	r5,fp,-4
 820193c:	0009883a 	mov	r4,zero
 8201940:	82171040 	call	8217104 <OSFlagCreate>
 8201944:	d0a05c15 	stw	r2,-32400(gp)
  if (!SSSLEDEventFlag)
 8201948:	d0a05c17 	ldw	r2,-32400(gp)
 820194c:	1000051e 	bne	r2,zero,8201964 <SSSCreateOSDataStructs+0x8c>
  {
     alt_uCOSIIErrorHandler(error_code, 0);
 8201950:	e0bfff03 	ldbu	r2,-4(fp)
 8201954:	10803fcc 	andi	r2,r2,255
 8201958:	000b883a 	mov	r5,zero
 820195c:	1009883a 	mov	r4,r2
 8201960:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  }
}
 8201964:	0001883a 	nop
 8201968:	e037883a 	mov	sp,fp
 820196c:	dfc00117 	ldw	ra,4(sp)
 8201970:	df000017 	ldw	fp,0(sp)
 8201974:	dec00204 	addi	sp,sp,8
 8201978:	f800283a 	ret

0820197c <SSSCreateTasks>:
/* This function creates tasks used in this example which do not use sockets.
 * Tasks which use Interniche sockets must be created with TK_NEWTASK.
 */
 
void SSSCreateTasks(void)
{
 820197c:	defff804 	addi	sp,sp,-32
 8201980:	dfc00715 	stw	ra,28(sp)
 8201984:	df000615 	stw	fp,24(sp)
 8201988:	df000604 	addi	fp,sp,24
   INT8U error_code;
  
   error_code = OSTaskCreateExt(LED7SegLightshowTask,
 820198c:	d8000415 	stw	zero,16(sp)
 8201990:	d8000315 	stw	zero,12(sp)
 8201994:	00820004 	movi	r2,2048
 8201998:	d8800215 	stw	r2,8(sp)
 820199c:	00820974 	movhi	r2,2085
 82019a0:	109a3904 	addi	r2,r2,26852
 82019a4:	d8800115 	stw	r2,4(sp)
 82019a8:	00800484 	movi	r2,18
 82019ac:	d8800015 	stw	r2,0(sp)
 82019b0:	01c00484 	movi	r7,18
 82019b4:	018209b4 	movhi	r6,2086
 82019b8:	31a23804 	addi	r6,r6,-30496
 82019bc:	000b883a 	mov	r5,zero
 82019c0:	01020834 	movhi	r4,2080
 82019c4:	21039f04 	addi	r4,r4,3708
 82019c8:	821ae640 	call	821ae64 <OSTaskCreateExt>
 82019cc:	e0bfff05 	stb	r2,-4(fp)
                             LED7SegLightshowTaskStk,
                             TASK_STACKSIZE,
                             NULL,
                             0);
   
   alt_uCOSIIErrorHandler(error_code, 0);
 82019d0:	e0bfff03 	ldbu	r2,-4(fp)
 82019d4:	000b883a 	mov	r5,zero
 82019d8:	1009883a 	mov	r4,r2
 82019dc:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  
   error_code = OSTaskCreateExt(LEDManagementTask,
 82019e0:	d8000415 	stw	zero,16(sp)
 82019e4:	d8000315 	stw	zero,12(sp)
 82019e8:	00820004 	movi	r2,2048
 82019ec:	d8800215 	stw	r2,8(sp)
 82019f0:	008209b4 	movhi	r2,2086
 82019f4:	10a25704 	addi	r2,r2,-30372
 82019f8:	d8800115 	stw	r2,4(sp)
 82019fc:	008001c4 	movi	r2,7
 8201a00:	d8800015 	stw	r2,0(sp)
 8201a04:	01c001c4 	movi	r7,7
 8201a08:	018209b4 	movhi	r6,2086
 8201a0c:	31aa5604 	addi	r6,r6,-22184
 8201a10:	000b883a 	mov	r5,zero
 8201a14:	01020834 	movhi	r4,2080
 8201a18:	2103bc04 	addi	r4,r4,3824
 8201a1c:	821ae640 	call	821ae64 <OSTaskCreateExt>
 8201a20:	e0bfff05 	stb	r2,-4(fp)
                              LEDManagementTaskStk,
                              TASK_STACKSIZE,
                              NULL,
                              0);

   alt_uCOSIIErrorHandler(error_code, 0);
 8201a24:	e0bfff03 	ldbu	r2,-4(fp)
 8201a28:	000b883a 	mov	r5,zero
 8201a2c:	1009883a 	mov	r4,r2
 8201a30:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>

}
 8201a34:	0001883a 	nop
 8201a38:	e037883a 	mov	sp,fp
 8201a3c:	dfc00117 	ldw	ra,4(sp)
 8201a40:	df000017 	ldw	fp,0(sp)
 8201a44:	dec00204 	addi	sp,sp,8
 8201a48:	f800283a 	ret

08201a4c <sss_reset_connection>:
 * to a reliable initial state. Note that we set our socket (FD) number to
 * -1 to easily determine whether the connection is in a "reset, ready to go" 
 * state.
 */
void sss_reset_connection(SSSConn* conn)
{
 8201a4c:	defffd04 	addi	sp,sp,-12
 8201a50:	dfc00215 	stw	ra,8(sp)
 8201a54:	df000115 	stw	fp,4(sp)
 8201a58:	df000104 	addi	fp,sp,4
 8201a5c:	e13fff15 	stw	r4,-4(fp)
  memset(conn, 0, sizeof(SSSConn));
 8201a60:	01817c04 	movi	r6,1520
 8201a64:	000b883a 	mov	r5,zero
 8201a68:	e13fff17 	ldw	r4,-4(fp)
 8201a6c:	82032100 	call	8203210 <memset>

  conn->fd = -1;
 8201a70:	e0bfff17 	ldw	r2,-4(fp)
 8201a74:	00ffffc4 	movi	r3,-1
 8201a78:	10c00115 	stw	r3,4(r2)
  conn->state = READY;
 8201a7c:	e0bfff17 	ldw	r2,-4(fp)
 8201a80:	10000015 	stw	zero,0(r2)
  conn->rx_wr_pos = conn->rx_buffer;
 8201a84:	e0bfff17 	ldw	r2,-4(fp)
 8201a88:	10c00304 	addi	r3,r2,12
 8201a8c:	e0bfff17 	ldw	r2,-4(fp)
 8201a90:	10c17b15 	stw	r3,1516(r2)
  conn->rx_rd_pos = conn->rx_buffer;
 8201a94:	e0bfff17 	ldw	r2,-4(fp)
 8201a98:	10c00304 	addi	r3,r2,12
 8201a9c:	e0bfff17 	ldw	r2,-4(fp)
 8201aa0:	10c17a15 	stw	r3,1512(r2)
  return;
 8201aa4:	0001883a 	nop
}
 8201aa8:	e037883a 	mov	sp,fp
 8201aac:	dfc00117 	ldw	ra,4(sp)
 8201ab0:	df000017 	ldw	fp,0(sp)
 8201ab4:	dec00204 	addi	sp,sp,8
 8201ab8:	f800283a 	ret

08201abc <sss_send_menu>:
 * sss_send_menu()
 * 
 * This routine will transmit the menu out to the telent client.
 */
void sss_send_menu(SSSConn* conn)
{
 8201abc:	defe8504 	addi	sp,sp,-1516
 8201ac0:	dfc17a15 	stw	ra,1512(sp)
 8201ac4:	df017915 	stw	fp,1508(sp)
 8201ac8:	df017904 	addi	fp,sp,1508
 8201acc:	e13fff15 	stw	r4,-4(fp)
  char  tx_buf[SSS_TX_BUF_SIZE];
  char *tx_wr_pos = tx_buf;
 8201ad0:	e0be8804 	addi	r2,fp,-1504
 8201ad4:	e0be8715 	stw	r2,-1508(fp)

  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 8201ad8:	e0fe8717 	ldw	r3,-1508(fp)
 8201adc:	00820974 	movhi	r2,2085
 8201ae0:	10b36304 	addi	r2,r2,-12916
 8201ae4:	1009883a 	mov	r4,r2
 8201ae8:	00800904 	movi	r2,36
 8201aec:	100d883a 	mov	r6,r2
 8201af0:	200b883a 	mov	r5,r4
 8201af4:	1809883a 	mov	r4,r3
 8201af8:	8202f6c0 	call	8202f6c <memcpy>
 8201afc:	008008c4 	movi	r2,35
 8201b00:	1007883a 	mov	r3,r2
 8201b04:	e0be8717 	ldw	r2,-1508(fp)
 8201b08:	10c5883a 	add	r2,r2,r3
 8201b0c:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"ADC Socket Server Menu\n\r");
 8201b10:	e0fe8717 	ldw	r3,-1508(fp)
 8201b14:	00820974 	movhi	r2,2085
 8201b18:	10b36c04 	addi	r2,r2,-12880
 8201b1c:	1009883a 	mov	r4,r2
 8201b20:	00800644 	movi	r2,25
 8201b24:	100d883a 	mov	r6,r2
 8201b28:	200b883a 	mov	r5,r4
 8201b2c:	1809883a 	mov	r4,r3
 8201b30:	8202f6c0 	call	8202f6c <memcpy>
 8201b34:	00800604 	movi	r2,24
 8201b38:	1007883a 	mov	r3,r2
 8201b3c:	e0be8717 	ldw	r2,-1508(fp)
 8201b40:	10c5883a 	add	r2,r2,r3
 8201b44:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 8201b48:	e0fe8717 	ldw	r3,-1508(fp)
 8201b4c:	00820974 	movhi	r2,2085
 8201b50:	10b36304 	addi	r2,r2,-12916
 8201b54:	1009883a 	mov	r4,r2
 8201b58:	00800904 	movi	r2,36
 8201b5c:	100d883a 	mov	r6,r2
 8201b60:	200b883a 	mov	r5,r4
 8201b64:	1809883a 	mov	r4,r3
 8201b68:	8202f6c0 	call	8202f6c <memcpy>
 8201b6c:	008008c4 	movi	r2,35
 8201b70:	1007883a 	mov	r3,r2
 8201b74:	e0be8717 	ldw	r2,-1508(fp)
 8201b78:	10c5883a 	add	r2,r2,r3
 8201b7c:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"ACQUIRE      - output most recent trigger\n\r");
 8201b80:	e0fe8717 	ldw	r3,-1508(fp)
 8201b84:	00820974 	movhi	r2,2085
 8201b88:	10b37304 	addi	r2,r2,-12852
 8201b8c:	1009883a 	mov	r4,r2
 8201b90:	00800b04 	movi	r2,44
 8201b94:	100d883a 	mov	r6,r2
 8201b98:	200b883a 	mov	r5,r4
 8201b9c:	1809883a 	mov	r4,r3
 8201ba0:	8202f6c0 	call	8202f6c <memcpy>
 8201ba4:	00800ac4 	movi	r2,43
 8201ba8:	1007883a 	mov	r3,r2
 8201bac:	e0be8717 	ldw	r2,-1508(fp)
 8201bb0:	10c5883a 	add	r2,r2,r3
 8201bb4:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"TRIG:SLOPE:  - Set trigger slope: POS or NEG\n\r");
 8201bb8:	e0fe8717 	ldw	r3,-1508(fp)
 8201bbc:	00820974 	movhi	r2,2085
 8201bc0:	10b37e04 	addi	r2,r2,-12808
 8201bc4:	1009883a 	mov	r4,r2
 8201bc8:	00800bc4 	movi	r2,47
 8201bcc:	100d883a 	mov	r6,r2
 8201bd0:	200b883a 	mov	r5,r4
 8201bd4:	1809883a 	mov	r4,r3
 8201bd8:	8202f6c0 	call	8202f6c <memcpy>
 8201bdc:	00800b84 	movi	r2,46
 8201be0:	1007883a 	mov	r3,r2
 8201be4:	e0be8717 	ldw	r2,-1508(fp)
 8201be8:	10c5883a 	add	r2,r2,r3
 8201bec:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"TRIG:SOURCE: - Set trigger source: SELF or EXT\n\r");
 8201bf0:	e0fe8717 	ldw	r3,-1508(fp)
 8201bf4:	00820974 	movhi	r2,2085
 8201bf8:	10b38a04 	addi	r2,r2,-12760
 8201bfc:	1009883a 	mov	r4,r2
 8201c00:	00800c44 	movi	r2,49
 8201c04:	100d883a 	mov	r6,r2
 8201c08:	200b883a 	mov	r5,r4
 8201c0c:	1809883a 	mov	r4,r3
 8201c10:	8202f6c0 	call	8202f6c <memcpy>
 8201c14:	00800c04 	movi	r2,48
 8201c18:	1007883a 	mov	r3,r2
 8201c1c:	e0be8717 	ldw	r2,-1508(fp)
 8201c20:	10c5883a 	add	r2,r2,r3
 8201c24:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"DELAY:       - Set delay: ON or OFF\n\r");
 8201c28:	e0fe8717 	ldw	r3,-1508(fp)
 8201c2c:	00820974 	movhi	r2,2085
 8201c30:	10b39704 	addi	r2,r2,-12708
 8201c34:	1009883a 	mov	r4,r2
 8201c38:	00800984 	movi	r2,38
 8201c3c:	100d883a 	mov	r6,r2
 8201c40:	200b883a 	mov	r5,r4
 8201c44:	1809883a 	mov	r4,r3
 8201c48:	8202f6c0 	call	8202f6c <memcpy>
 8201c4c:	00800944 	movi	r2,37
 8201c50:	1007883a 	mov	r3,r2
 8201c54:	e0be8717 	ldw	r2,-1508(fp)
 8201c58:	10c5883a 	add	r2,r2,r3
 8201c5c:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"MENU         - display this menu \n\r");
 8201c60:	e0fe8717 	ldw	r3,-1508(fp)
 8201c64:	00820974 	movhi	r2,2085
 8201c68:	10b3a104 	addi	r2,r2,-12668
 8201c6c:	1009883a 	mov	r4,r2
 8201c70:	00800904 	movi	r2,36
 8201c74:	100d883a 	mov	r6,r2
 8201c78:	200b883a 	mov	r5,r4
 8201c7c:	1809883a 	mov	r4,r3
 8201c80:	8202f6c0 	call	8202f6c <memcpy>
 8201c84:	008008c4 	movi	r2,35
 8201c88:	1007883a 	mov	r3,r2
 8201c8c:	e0be8717 	ldw	r2,-1508(fp)
 8201c90:	10c5883a 	add	r2,r2,r3
 8201c94:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"QUIT         - quit \n\r");
 8201c98:	e0fe8717 	ldw	r3,-1508(fp)
 8201c9c:	00820974 	movhi	r2,2085
 8201ca0:	10b3aa04 	addi	r2,r2,-12632
 8201ca4:	1009883a 	mov	r4,r2
 8201ca8:	008005c4 	movi	r2,23
 8201cac:	100d883a 	mov	r6,r2
 8201cb0:	200b883a 	mov	r5,r4
 8201cb4:	1809883a 	mov	r4,r3
 8201cb8:	8202f6c0 	call	8202f6c <memcpy>
 8201cbc:	00800584 	movi	r2,22
 8201cc0:	1007883a 	mov	r3,r2
 8201cc4:	e0be8717 	ldw	r2,-1508(fp)
 8201cc8:	10c5883a 	add	r2,r2,r3
 8201ccc:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 8201cd0:	e0fe8717 	ldw	r3,-1508(fp)
 8201cd4:	00820974 	movhi	r2,2085
 8201cd8:	10b36304 	addi	r2,r2,-12916
 8201cdc:	1009883a 	mov	r4,r2
 8201ce0:	00800904 	movi	r2,36
 8201ce4:	100d883a 	mov	r6,r2
 8201ce8:	200b883a 	mov	r5,r4
 8201cec:	1809883a 	mov	r4,r3
 8201cf0:	8202f6c0 	call	8202f6c <memcpy>
 8201cf4:	008008c4 	movi	r2,35
 8201cf8:	1007883a 	mov	r3,r2
 8201cfc:	e0be8717 	ldw	r2,-1508(fp)
 8201d00:	10c5883a 	add	r2,r2,r3
 8201d04:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"Enter your choice & press return:\n\r");
 8201d08:	e0fe8717 	ldw	r3,-1508(fp)
 8201d0c:	00820974 	movhi	r2,2085
 8201d10:	10b3b004 	addi	r2,r2,-12608
 8201d14:	1009883a 	mov	r4,r2
 8201d18:	00800904 	movi	r2,36
 8201d1c:	100d883a 	mov	r6,r2
 8201d20:	200b883a 	mov	r5,r4
 8201d24:	1809883a 	mov	r4,r3
 8201d28:	8202f6c0 	call	8202f6c <memcpy>
 8201d2c:	008008c4 	movi	r2,35
 8201d30:	1007883a 	mov	r3,r2
 8201d34:	e0be8717 	ldw	r2,-1508(fp)
 8201d38:	10c5883a 	add	r2,r2,r3
 8201d3c:	e0be8715 	stw	r2,-1508(fp)

  send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);
 8201d40:	e0bfff17 	ldw	r2,-4(fp)
 8201d44:	11000117 	ldw	r4,4(r2)
 8201d48:	e0fe8717 	ldw	r3,-1508(fp)
 8201d4c:	e0be8804 	addi	r2,fp,-1504
 8201d50:	1887c83a 	sub	r3,r3,r2
 8201d54:	e0be8804 	addi	r2,fp,-1504
 8201d58:	000f883a 	mov	r7,zero
 8201d5c:	180d883a 	mov	r6,r3
 8201d60:	100b883a 	mov	r5,r2
 8201d64:	82315cc0 	call	82315cc <t_send>
  
  return;
 8201d68:	0001883a 	nop
}
 8201d6c:	e037883a 	mov	sp,fp
 8201d70:	dfc00117 	ldw	ra,4(sp)
 8201d74:	df000017 	ldw	fp,0(sp)
 8201d78:	dec00204 	addi	sp,sp,8
 8201d7c:	f800283a 	ret

08201d80 <sss_handle_accept>:
 * reject the incoming request by immediately closing the new socket.
 * 
 * We'll also print out the client's IP address.
 */
void sss_handle_accept(int listen_socket, SSSConn* conn)
{
 8201d80:	defff604 	addi	sp,sp,-40
 8201d84:	dfc00915 	stw	ra,36(sp)
 8201d88:	df000815 	stw	fp,32(sp)
 8201d8c:	df000804 	addi	fp,sp,32
 8201d90:	e13ffe15 	stw	r4,-8(fp)
 8201d94:	e17fff15 	stw	r5,-4(fp)
  int                 socket, len;
  struct sockaddr_in  incoming_addr;

  len = sizeof(incoming_addr);
 8201d98:	00800404 	movi	r2,16
 8201d9c:	e0bff915 	stw	r2,-28(fp)

  if ((conn)->fd == -1)
 8201da0:	e0bfff17 	ldw	r2,-4(fp)
 8201da4:	10800117 	ldw	r2,4(r2)
 8201da8:	10bfffd8 	cmpnei	r2,r2,-1
 8201dac:	10001a1e 	bne	r2,zero,8201e18 <sss_handle_accept+0x98>
  {
     if((socket=accept(listen_socket,(struct sockaddr*)&incoming_addr,&len))<0)
 8201db0:	e0fff904 	addi	r3,fp,-28
 8201db4:	e0bffa04 	addi	r2,fp,-24
 8201db8:	180d883a 	mov	r6,r3
 8201dbc:	100b883a 	mov	r5,r2
 8201dc0:	e13ffe17 	ldw	r4,-8(fp)
 8201dc4:	8227ce40 	call	8227ce4 <bsd_accept>
 8201dc8:	e0bff815 	stw	r2,-32(fp)
 8201dcc:	e0bff817 	ldw	r2,-32(fp)
 8201dd0:	1000050e 	bge	r2,zero,8201de8 <sss_handle_accept+0x68>
     {
         alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,
 8201dd4:	01420974 	movhi	r5,2085
 8201dd8:	2973b904 	addi	r5,r5,-12572
 8201ddc:	01003fc4 	movi	r4,255
 8201de0:	82007ac0 	call	82007ac <alt_NetworkErrorHandler>
  {
    printf("[sss_handle_accept] rejected connection request from %s\n",
           inet_ntoa(incoming_addr.sin_addr));
  }

  return;
 8201de4:	00001306 	br	8201e34 <sss_handle_accept+0xb4>
         alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,
                                 "[sss_handle_accept] accept failed");
     }
     else
     {
        (conn)->fd = socket;
 8201de8:	e0bfff17 	ldw	r2,-4(fp)
 8201dec:	e0fff817 	ldw	r3,-32(fp)
 8201df0:	10c00115 	stw	r3,4(r2)
        sss_send_menu(conn);
 8201df4:	e13fff17 	ldw	r4,-4(fp)
 8201df8:	8201abc0 	call	8201abc <sss_send_menu>
        printf("[sss_handle_accept] accepted connection request from %s\n",
 8201dfc:	e13ffb17 	ldw	r4,-20(fp)
 8201e00:	822838c0 	call	822838c <bsd_inet_ntoa>
 8201e04:	100b883a 	mov	r5,r2
 8201e08:	01020974 	movhi	r4,2085
 8201e0c:	2133c204 	addi	r4,r4,-12536
 8201e10:	82033fc0 	call	82033fc <printf>
  {
    printf("[sss_handle_accept] rejected connection request from %s\n",
           inet_ntoa(incoming_addr.sin_addr));
  }

  return;
 8201e14:	00000706 	br	8201e34 <sss_handle_accept+0xb4>
               inet_ntoa(incoming_addr.sin_addr));
     }
  }
  else
  {
    printf("[sss_handle_accept] rejected connection request from %s\n",
 8201e18:	e13ffb17 	ldw	r4,-20(fp)
 8201e1c:	822838c0 	call	822838c <bsd_inet_ntoa>
 8201e20:	100b883a 	mov	r5,r2
 8201e24:	01020974 	movhi	r4,2085
 8201e28:	2133d104 	addi	r4,r4,-12476
 8201e2c:	82033fc0 	call	82033fc <printf>
           inet_ntoa(incoming_addr.sin_addr));
  }

  return;
 8201e30:	0001883a 	nop
}
 8201e34:	e037883a 	mov	sp,fp
 8201e38:	dfc00117 	ldw	ra,4(sp)
 8201e3c:	df000017 	ldw	fp,0(sp)
 8201e40:	dec00204 	addi	sp,sp,8
 8201e44:	f800283a 	ret

08201e48 <sss_exec_command>:
 * If the user wishes to quit, we set the "close" member of our SSSConn
 * struct, which will be looked at back in sss_handle_receive() when it 
 * comes time to see whether to close the connection or not.
 */
void sss_exec_command(SSSConn* conn)
{
 8201e48:	defb9104 	addi	sp,sp,-4540
 8201e4c:	dfc46e15 	stw	ra,4536(sp)
 8201e50:	df046d15 	stw	fp,4532(sp)
 8201e54:	df046d04 	addi	fp,sp,4532
 8201e58:	e13fff15 	stw	r4,-4(fp)
   int bytes_to_process = conn->rx_wr_pos - conn->rx_rd_pos;
 8201e5c:	e0bfff17 	ldw	r2,-4(fp)
 8201e60:	10817b17 	ldw	r2,1516(r2)
 8201e64:	1007883a 	mov	r3,r2
 8201e68:	e0bfff17 	ldw	r2,-4(fp)
 8201e6c:	10817a17 	ldw	r2,1512(r2)
 8201e70:	1885c83a 	sub	r2,r3,r2
 8201e74:	e0bb9315 	stw	r2,-4532(fp)

   char  tx_buf[SSS_TX_BUF_SIZE];
   char *tx_wr_pos = tx_buf;
 8201e78:	e0bb9a04 	addi	r2,fp,-4504
 8201e7c:	e0bb9415 	stw	r2,-4528(fp)

   char text_buf[SSS_TX_BUF_SIZE];
   char *text = text_buf;
 8201e80:	e0bd1104 	addi	r2,fp,-3004
 8201e84:	e0bb9515 	stw	r2,-4524(fp)
    * SSSSimpleSocketServerTask, since the LEDManagementTask does not 
    * have access to the stack of the SSSSimpleSocketServerTask.
    */
   static INT32U SSSCommand;
   
   SSSCommand = CMD_LEDS_BIT_0_TOGGLE;
 8201e88:	00800c04 	movi	r2,48
 8201e8c:	d0a05915 	stw	r2,-32412(gp)

   while(bytes_to_process--) {
 8201e90:	00002206 	br	8201f1c <sss_exec_command+0xd4>
      SSSCommand = tolower(*(conn->rx_rd_pos++));
 8201e94:	e0bfff17 	ldw	r2,-4(fp)
 8201e98:	10817a17 	ldw	r2,1512(r2)
 8201e9c:	11000044 	addi	r4,r2,1
 8201ea0:	e0ffff17 	ldw	r3,-4(fp)
 8201ea4:	19017a15 	stw	r4,1512(r3)
 8201ea8:	10800003 	ldbu	r2,0(r2)
 8201eac:	e0bb9885 	stb	r2,-4510(fp)
 8201eb0:	d0e00017 	ldw	r3,-32768(gp)
 8201eb4:	e0bb9883 	ldbu	r2,-4510(fp)
 8201eb8:	10800044 	addi	r2,r2,1
 8201ebc:	1885883a 	add	r2,r3,r2
 8201ec0:	10800003 	ldbu	r2,0(r2)
 8201ec4:	10803fcc 	andi	r2,r2,255
 8201ec8:	108000cc 	andi	r2,r2,3
 8201ecc:	10800058 	cmpnei	r2,r2,1
 8201ed0:	1000031e 	bne	r2,zero,8201ee0 <sss_exec_command+0x98>
 8201ed4:	e0bb9883 	ldbu	r2,-4510(fp)
 8201ed8:	10800804 	addi	r2,r2,32
 8201edc:	00000106 	br	8201ee4 <sss_exec_command+0x9c>
 8201ee0:	e0bb9883 	ldbu	r2,-4510(fp)
 8201ee4:	d0a05915 	stw	r2,-32412(gp)
	  text += sprintf(text,"%c",(char)SSSCommand);
 8201ee8:	d0a05917 	ldw	r2,-32412(gp)
 8201eec:	10803fcc 	andi	r2,r2,255
 8201ef0:	1080201c 	xori	r2,r2,128
 8201ef4:	10bfe004 	addi	r2,r2,-128
 8201ef8:	100d883a 	mov	r6,r2
 8201efc:	01420974 	movhi	r5,2085
 8201f00:	2973e004 	addi	r5,r5,-12416
 8201f04:	e13b9517 	ldw	r4,-4524(fp)
 8201f08:	82037740 	call	8203774 <sprintf>
 8201f0c:	1007883a 	mov	r3,r2
 8201f10:	e0bb9517 	ldw	r2,-4524(fp)
 8201f14:	10c5883a 	add	r2,r2,r3
 8201f18:	e0bb9515 	stw	r2,-4524(fp)
    */
   static INT32U SSSCommand;
   
   SSSCommand = CMD_LEDS_BIT_0_TOGGLE;

   while(bytes_to_process--) {
 8201f1c:	e0bb9317 	ldw	r2,-4532(fp)
 8201f20:	10ffffc4 	addi	r3,r2,-1
 8201f24:	e0fb9315 	stw	r3,-4532(fp)
 8201f28:	103fda1e 	bne	r2,zero,8201e94 <sss_exec_command+0x4c>
      SSSCommand = tolower(*(conn->rx_rd_pos++));
	  text += sprintf(text,"%c",(char)SSSCommand);
   }

   alt_u8 startValue = IORD_ALTERA_AVALON_PIO_DATA(ADC_CONTROL_BASE);
 8201f2c:	00824034 	movhi	r2,2304
 8201f30:	10801004 	addi	r2,r2,64
 8201f34:	10800037 	ldwio	r2,0(r2)
 8201f38:	e0bb98c5 	stb	r2,-4509(fp)

   alt_u8 endValue = startValue;
 8201f3c:	e0bb98c3 	ldbu	r2,-4509(fp)
 8201f40:	e0bb9605 	stb	r2,-4520(fp)

   if(strstr(text_buf, "acquire") != NULL){
 8201f44:	e0bd1104 	addi	r2,fp,-3004
 8201f48:	01420974 	movhi	r5,2085
 8201f4c:	2973e104 	addi	r5,r5,-12412
 8201f50:	1009883a 	mov	r4,r2
 8201f54:	82045080 	call	8204508 <strstr>
 8201f58:	10006b26 	beq	r2,zero,8202108 <sss_exec_command+0x2c0>
	   endValue ^= (-1 ^ endValue) & (1 << 0);
 8201f5c:	e0bb9603 	ldbu	r2,-4520(fp)
 8201f60:	1080004c 	andi	r2,r2,1
 8201f64:	1005003a 	cmpeq	r2,r2,zero
 8201f68:	1007883a 	mov	r3,r2
 8201f6c:	e0bb9603 	ldbu	r2,-4520(fp)
 8201f70:	1884f03a 	xor	r2,r3,r2
 8201f74:	e0bb9605 	stb	r2,-4520(fp)


	   IOWR_ALTERA_AVALON_PIO_DATA(ADC_CONTROL_BASE, endValue);
 8201f78:	e0fb9603 	ldbu	r3,-4520(fp)
 8201f7c:	00824034 	movhi	r2,2304
 8201f80:	10801004 	addi	r2,r2,64
 8201f84:	10c00035 	stwio	r3,0(r2)


	   char  tx_buf_data[SSS_TX_BUF_SIZE];
	   char *tx_wr_pos_data = tx_buf_data;
 8201f88:	e0be8804 	addi	r2,fp,-1504
 8201f8c:	e0bb9715 	stw	r2,-4516(fp)

	   //loop over the waveform
	   for(alt_u16 i=1; i<=1000; i++){
 8201f90:	00800044 	movi	r2,1
 8201f94:	e0bb980d 	sth	r2,-4512(fp)
 8201f98:	00002c06 	br	820204c <sss_exec_command+0x204>

		   //request the ith sample of the waveform
		   IOWR_ALTERA_AVALON_PIO_DATA(SAMPLENUM_BASE, i);
 8201f9c:	e0fb980b 	ldhu	r3,-4512(fp)
 8201fa0:	00824034 	movhi	r2,2304
 8201fa4:	10801804 	addi	r2,r2,96
 8201fa8:	10c00035 	stwio	r3,0(r2)

		   //usleep(10);

		   alt_u16 sample = IORD_ALTERA_AVALON_PIO_DATA(WAVESAMPLE_BASE);
 8201fac:	00824034 	movhi	r2,2304
 8201fb0:	10801404 	addi	r2,r2,80
 8201fb4:	10800037 	ldwio	r2,0(r2)
 8201fb8:	e0bb990d 	sth	r2,-4508(fp)

		   //printf("%d\t", i);
		   //printf("%d\n", sample);

		   tx_wr_pos_data += sprintf(tx_wr_pos_data, "%d\n", sample);
 8201fbc:	e0bb990b 	ldhu	r2,-4508(fp)
 8201fc0:	100d883a 	mov	r6,r2
 8201fc4:	01420974 	movhi	r5,2085
 8201fc8:	2973e304 	addi	r5,r5,-12404
 8201fcc:	e13b9717 	ldw	r4,-4516(fp)
 8201fd0:	82037740 	call	8203774 <sprintf>
 8201fd4:	1007883a 	mov	r3,r2
 8201fd8:	e0bb9717 	ldw	r2,-4516(fp)
 8201fdc:	10c5883a 	add	r2,r2,r3
 8201fe0:	e0bb9715 	stw	r2,-4516(fp)

		   //send data every 100 samples.
		   if(i%100==0){
 8201fe4:	e0bb980b 	ldhu	r2,-4512(fp)
 8201fe8:	01401904 	movi	r5,100
 8201fec:	1009883a 	mov	r4,r2
 8201ff0:	8202cd00 	call	8202cd0 <__umodsi3>
 8201ff4:	10bfffcc 	andi	r2,r2,65535
 8201ff8:	1000111e 	bne	r2,zero,8202040 <sss_exec_command+0x1f8>
			   send(conn->fd, tx_buf_data, tx_wr_pos_data - tx_buf_data, 0);
 8201ffc:	e0bfff17 	ldw	r2,-4(fp)
 8202000:	11000117 	ldw	r4,4(r2)
 8202004:	e0fb9717 	ldw	r3,-4516(fp)
 8202008:	e0be8804 	addi	r2,fp,-1504
 820200c:	1887c83a 	sub	r3,r3,r2
 8202010:	e0be8804 	addi	r2,fp,-1504
 8202014:	000f883a 	mov	r7,zero
 8202018:	180d883a 	mov	r6,r3
 820201c:	100b883a 	mov	r5,r2
 8202020:	82315cc0 	call	82315cc <t_send>

			   memset(tx_buf_data, 0, sizeof tx_buf_data);
 8202024:	e0be8804 	addi	r2,fp,-1504
 8202028:	01817704 	movi	r6,1500
 820202c:	000b883a 	mov	r5,zero
 8202030:	1009883a 	mov	r4,r2
 8202034:	82032100 	call	8203210 <memset>
			   tx_wr_pos_data = tx_buf_data;
 8202038:	e0be8804 	addi	r2,fp,-1504
 820203c:	e0bb9715 	stw	r2,-4516(fp)

	   char  tx_buf_data[SSS_TX_BUF_SIZE];
	   char *tx_wr_pos_data = tx_buf_data;

	   //loop over the waveform
	   for(alt_u16 i=1; i<=1000; i++){
 8202040:	e0bb980b 	ldhu	r2,-4512(fp)
 8202044:	10800044 	addi	r2,r2,1
 8202048:	e0bb980d 	sth	r2,-4512(fp)
 820204c:	e0bb980b 	ldhu	r2,-4512(fp)
 8202050:	1080fa70 	cmpltui	r2,r2,1001
 8202054:	103fd11e 	bne	r2,zero,8201f9c <sss_exec_command+0x154>
			   tx_wr_pos_data = tx_buf_data;

		   }

	   }
	   IOWR_ALTERA_AVALON_PIO_DATA(SAMPLENUM_BASE, 1001);
 8202058:	00c0fa44 	movi	r3,1001
 820205c:	00824034 	movhi	r2,2304
 8202060:	10801804 	addi	r2,r2,96
 8202064:	10c00035 	stwio	r3,0(r2)
	   //usleep(10);
	   alt_u16 waveNum = IORD_ALTERA_AVALON_PIO_DATA(WAVESAMPLE_BASE);
 8202068:	00824034 	movhi	r2,2304
 820206c:	10801404 	addi	r2,r2,80
 8202070:	10800037 	ldwio	r2,0(r2)
 8202074:	e0bb998d 	sth	r2,-4506(fp)
	   //printf("%d\n", waveNum);


	   IOWR_ALTERA_AVALON_PIO_DATA(SAMPLENUM_BASE, 0);
 8202078:	0007883a 	mov	r3,zero
 820207c:	00824034 	movhi	r2,2304
 8202080:	10801804 	addi	r2,r2,96
 8202084:	10c00035 	stwio	r3,0(r2)

	   memset(tx_buf_data, 0, sizeof tx_buf_data);
 8202088:	e0be8804 	addi	r2,fp,-1504
 820208c:	01817704 	movi	r6,1500
 8202090:	000b883a 	mov	r5,zero
 8202094:	1009883a 	mov	r4,r2
 8202098:	82032100 	call	8203210 <memset>
	   tx_wr_pos_data = tx_buf_data;
 820209c:	e0be8804 	addi	r2,fp,-1504
 82020a0:	e0bb9715 	stw	r2,-4516(fp)

	   tx_wr_pos_data += sprintf(tx_wr_pos_data, "%d\ncomplete\n",waveNum);
 82020a4:	e0bb998b 	ldhu	r2,-4506(fp)
 82020a8:	100d883a 	mov	r6,r2
 82020ac:	01420974 	movhi	r5,2085
 82020b0:	2973e404 	addi	r5,r5,-12400
 82020b4:	e13b9717 	ldw	r4,-4516(fp)
 82020b8:	82037740 	call	8203774 <sprintf>
 82020bc:	1007883a 	mov	r3,r2
 82020c0:	e0bb9717 	ldw	r2,-4516(fp)
 82020c4:	10c5883a 	add	r2,r2,r3
 82020c8:	e0bb9715 	stw	r2,-4516(fp)

	   send(conn->fd, tx_buf_data, tx_wr_pos_data - tx_buf_data, 0);
 82020cc:	e0bfff17 	ldw	r2,-4(fp)
 82020d0:	11000117 	ldw	r4,4(r2)
 82020d4:	e0fb9717 	ldw	r3,-4516(fp)
 82020d8:	e0be8804 	addi	r2,fp,-1504
 82020dc:	1887c83a 	sub	r3,r3,r2
 82020e0:	e0be8804 	addi	r2,fp,-1504
 82020e4:	000f883a 	mov	r7,zero
 82020e8:	180d883a 	mov	r6,r3
 82020ec:	100b883a 	mov	r5,r2
 82020f0:	82315cc0 	call	82315cc <t_send>

	   //reset the control pio

	   endValue ^= (-0 ^ endValue) & (1 << 0);
 82020f4:	e0fb9603 	ldbu	r3,-4520(fp)
 82020f8:	00bfff84 	movi	r2,-2
 82020fc:	1884703a 	and	r2,r3,r2
 8202100:	e0bb9605 	stb	r2,-4520(fp)
 8202104:	00019e06 	br	8202780 <sss_exec_command+0x938>
   } else if( strstr(text_buf, "delay")) {
 8202108:	e0bd1104 	addi	r2,fp,-3004
 820210c:	01420974 	movhi	r5,2085
 8202110:	2973e804 	addi	r5,r5,-12384
 8202114:	1009883a 	mov	r4,r2
 8202118:	82045080 	call	8204508 <strstr>
 820211c:	10003526 	beq	r2,zero,82021f4 <sss_exec_command+0x3ac>
	   if ( strstr(text_buf, ":on")){
 8202120:	e0bd1104 	addi	r2,fp,-3004
 8202124:	01420974 	movhi	r5,2085
 8202128:	2973ea04 	addi	r5,r5,-12376
 820212c:	1009883a 	mov	r4,r2
 8202130:	82045080 	call	8204508 <strstr>
 8202134:	10001626 	beq	r2,zero,8202190 <sss_exec_command+0x348>
		   tx_wr_pos += sprintf(tx_wr_pos, "Enabling delay\n");
 8202138:	e0fb9417 	ldw	r3,-4528(fp)
 820213c:	00820974 	movhi	r2,2085
 8202140:	10b3eb04 	addi	r2,r2,-12372
 8202144:	1009883a 	mov	r4,r2
 8202148:	00800404 	movi	r2,16
 820214c:	100d883a 	mov	r6,r2
 8202150:	200b883a 	mov	r5,r4
 8202154:	1809883a 	mov	r4,r3
 8202158:	8202f6c0 	call	8202f6c <memcpy>
 820215c:	008003c4 	movi	r2,15
 8202160:	1007883a 	mov	r3,r2
 8202164:	e0bb9417 	ldw	r2,-4528(fp)
 8202168:	10c5883a 	add	r2,r2,r3
 820216c:	e0bb9415 	stw	r2,-4528(fp)
		   endValue ^= (-1 ^ endValue) & (1 << 3);
 8202170:	e0bb9603 	ldbu	r2,-4520(fp)
 8202174:	0084303a 	nor	r2,zero,r2
 8202178:	1080020c 	andi	r2,r2,8
 820217c:	1007883a 	mov	r3,r2
 8202180:	e0bb9603 	ldbu	r2,-4520(fp)
 8202184:	1884f03a 	xor	r2,r3,r2
 8202188:	e0bb9605 	stb	r2,-4520(fp)
 820218c:	00017c06 	br	8202780 <sss_exec_command+0x938>

	   } else if ( strstr(text_buf, ":off")){
 8202190:	e0bd1104 	addi	r2,fp,-3004
 8202194:	01420974 	movhi	r5,2085
 8202198:	2973ef04 	addi	r5,r5,-12356
 820219c:	1009883a 	mov	r4,r2
 82021a0:	82045080 	call	8204508 <strstr>
 82021a4:	10017626 	beq	r2,zero,8202780 <sss_exec_command+0x938>
		   tx_wr_pos += sprintf(tx_wr_pos, "Disabling delay\n");
 82021a8:	e0fb9417 	ldw	r3,-4528(fp)
 82021ac:	00820974 	movhi	r2,2085
 82021b0:	10b3f104 	addi	r2,r2,-12348
 82021b4:	1009883a 	mov	r4,r2
 82021b8:	00800444 	movi	r2,17
 82021bc:	100d883a 	mov	r6,r2
 82021c0:	200b883a 	mov	r5,r4
 82021c4:	1809883a 	mov	r4,r3
 82021c8:	8202f6c0 	call	8202f6c <memcpy>
 82021cc:	00800404 	movi	r2,16
 82021d0:	1007883a 	mov	r3,r2
 82021d4:	e0bb9417 	ldw	r2,-4528(fp)
 82021d8:	10c5883a 	add	r2,r2,r3
 82021dc:	e0bb9415 	stw	r2,-4528(fp)
		   endValue ^= (-0 ^ endValue) & (1 << 3);
 82021e0:	e0fb9603 	ldbu	r3,-4520(fp)
 82021e4:	00bffdc4 	movi	r2,-9
 82021e8:	1884703a 	and	r2,r3,r2
 82021ec:	e0bb9605 	stb	r2,-4520(fp)
 82021f0:	00016306 	br	8202780 <sss_exec_command+0x938>
	   }
   } else if( strstr(text_buf, "trig")) {
 82021f4:	e0bd1104 	addi	r2,fp,-3004
 82021f8:	01420974 	movhi	r5,2085
 82021fc:	2973f604 	addi	r5,r5,-12328
 8202200:	1009883a 	mov	r4,r2
 8202204:	82045080 	call	8204508 <strstr>
 8202208:	10008926 	beq	r2,zero,8202430 <sss_exec_command+0x5e8>
	   if( strstr(text_buf, ":source")) {
 820220c:	e0bd1104 	addi	r2,fp,-3004
 8202210:	01420974 	movhi	r5,2085
 8202214:	2973f804 	addi	r5,r5,-12320
 8202218:	1009883a 	mov	r4,r2
 820221c:	82045080 	call	8204508 <strstr>
 8202220:	10004826 	beq	r2,zero,8202344 <sss_exec_command+0x4fc>
	   	   if ( strstr(text_buf, ":self")){
 8202224:	e0bd1104 	addi	r2,fp,-3004
 8202228:	01420974 	movhi	r5,2085
 820222c:	2973fa04 	addi	r5,r5,-12312
 8202230:	1009883a 	mov	r4,r2
 8202234:	82045080 	call	8204508 <strstr>
 8202238:	10002926 	beq	r2,zero,82022e0 <sss_exec_command+0x498>
			   tx_wr_pos += sprintf(tx_wr_pos, "Self trigger\n");
 820223c:	e0bb9417 	ldw	r2,-4528(fp)
 8202240:	00c014c4 	movi	r3,83
 8202244:	10c00005 	stb	r3,0(r2)
 8202248:	00c01944 	movi	r3,101
 820224c:	10c00045 	stb	r3,1(r2)
 8202250:	00c01b04 	movi	r3,108
 8202254:	10c00085 	stb	r3,2(r2)
 8202258:	00c01984 	movi	r3,102
 820225c:	10c000c5 	stb	r3,3(r2)
 8202260:	00c00804 	movi	r3,32
 8202264:	10c00105 	stb	r3,4(r2)
 8202268:	00c01d04 	movi	r3,116
 820226c:	10c00145 	stb	r3,5(r2)
 8202270:	00c01c84 	movi	r3,114
 8202274:	10c00185 	stb	r3,6(r2)
 8202278:	00c01a44 	movi	r3,105
 820227c:	10c001c5 	stb	r3,7(r2)
 8202280:	00c019c4 	movi	r3,103
 8202284:	10c00205 	stb	r3,8(r2)
 8202288:	00c019c4 	movi	r3,103
 820228c:	10c00245 	stb	r3,9(r2)
 8202290:	00c01944 	movi	r3,101
 8202294:	10c00285 	stb	r3,10(r2)
 8202298:	00c01c84 	movi	r3,114
 820229c:	10c002c5 	stb	r3,11(r2)
 82022a0:	00c00284 	movi	r3,10
 82022a4:	10c00305 	stb	r3,12(r2)
 82022a8:	10000345 	stb	zero,13(r2)
 82022ac:	00800344 	movi	r2,13
 82022b0:	1007883a 	mov	r3,r2
 82022b4:	e0bb9417 	ldw	r2,-4528(fp)
 82022b8:	10c5883a 	add	r2,r2,r3
 82022bc:	e0bb9415 	stw	r2,-4528(fp)
	   		   endValue ^= (-1 ^ endValue) & (1 << 1);
 82022c0:	e0bb9603 	ldbu	r2,-4520(fp)
 82022c4:	0084303a 	nor	r2,zero,r2
 82022c8:	1080008c 	andi	r2,r2,2
 82022cc:	1007883a 	mov	r3,r2
 82022d0:	e0bb9603 	ldbu	r2,-4520(fp)
 82022d4:	1884f03a 	xor	r2,r3,r2
 82022d8:	e0bb9605 	stb	r2,-4520(fp)
 82022dc:	00012806 	br	8202780 <sss_exec_command+0x938>

	   	   } else if ( strstr(text_buf, ":ext")){
 82022e0:	e0bd1104 	addi	r2,fp,-3004
 82022e4:	01420974 	movhi	r5,2085
 82022e8:	2973fc04 	addi	r5,r5,-12304
 82022ec:	1009883a 	mov	r4,r2
 82022f0:	82045080 	call	8204508 <strstr>
 82022f4:	10012226 	beq	r2,zero,8202780 <sss_exec_command+0x938>
			   tx_wr_pos += sprintf(tx_wr_pos, "External trigger\n");
 82022f8:	e0fb9417 	ldw	r3,-4528(fp)
 82022fc:	00820974 	movhi	r2,2085
 8202300:	10b3fe04 	addi	r2,r2,-12296
 8202304:	1009883a 	mov	r4,r2
 8202308:	00800484 	movi	r2,18
 820230c:	100d883a 	mov	r6,r2
 8202310:	200b883a 	mov	r5,r4
 8202314:	1809883a 	mov	r4,r3
 8202318:	8202f6c0 	call	8202f6c <memcpy>
 820231c:	00800444 	movi	r2,17
 8202320:	1007883a 	mov	r3,r2
 8202324:	e0bb9417 	ldw	r2,-4528(fp)
 8202328:	10c5883a 	add	r2,r2,r3
 820232c:	e0bb9415 	stw	r2,-4528(fp)
	   		   endValue ^= (-0 ^ endValue) & (1 << 1);
 8202330:	e0fb9603 	ldbu	r3,-4520(fp)
 8202334:	00bfff44 	movi	r2,-3
 8202338:	1884703a 	and	r2,r3,r2
 820233c:	e0bb9605 	stb	r2,-4520(fp)
 8202340:	00010f06 	br	8202780 <sss_exec_command+0x938>
	   	   }
	   } else if( strstr(text_buf, ":slope")) {
 8202344:	e0bd1104 	addi	r2,fp,-3004
 8202348:	01420974 	movhi	r5,2085
 820234c:	29740304 	addi	r5,r5,-12276
 8202350:	1009883a 	mov	r4,r2
 8202354:	82045080 	call	8204508 <strstr>
 8202358:	10010926 	beq	r2,zero,8202780 <sss_exec_command+0x938>
		   if ( strstr(text_buf, ":pos")){
 820235c:	e0bd1104 	addi	r2,fp,-3004
 8202360:	01420974 	movhi	r5,2085
 8202364:	29740504 	addi	r5,r5,-12268
 8202368:	1009883a 	mov	r4,r2
 820236c:	82045080 	call	8204508 <strstr>
 8202370:	10001626 	beq	r2,zero,82023cc <sss_exec_command+0x584>
			   tx_wr_pos += sprintf(tx_wr_pos, "Positive trigger\n");
 8202374:	e0fb9417 	ldw	r3,-4528(fp)
 8202378:	00820974 	movhi	r2,2085
 820237c:	10b40704 	addi	r2,r2,-12260
 8202380:	1009883a 	mov	r4,r2
 8202384:	00800484 	movi	r2,18
 8202388:	100d883a 	mov	r6,r2
 820238c:	200b883a 	mov	r5,r4
 8202390:	1809883a 	mov	r4,r3
 8202394:	8202f6c0 	call	8202f6c <memcpy>
 8202398:	00800444 	movi	r2,17
 820239c:	1007883a 	mov	r3,r2
 82023a0:	e0bb9417 	ldw	r2,-4528(fp)
 82023a4:	10c5883a 	add	r2,r2,r3
 82023a8:	e0bb9415 	stw	r2,-4528(fp)
			   endValue ^= (-1 ^ endValue) & (1 << 2);
 82023ac:	e0bb9603 	ldbu	r2,-4520(fp)
 82023b0:	0084303a 	nor	r2,zero,r2
 82023b4:	1080010c 	andi	r2,r2,4
 82023b8:	1007883a 	mov	r3,r2
 82023bc:	e0bb9603 	ldbu	r2,-4520(fp)
 82023c0:	1884f03a 	xor	r2,r3,r2
 82023c4:	e0bb9605 	stb	r2,-4520(fp)
 82023c8:	0000ed06 	br	8202780 <sss_exec_command+0x938>

		   } else if ( strstr(text_buf, ":neg")){
 82023cc:	e0bd1104 	addi	r2,fp,-3004
 82023d0:	01420974 	movhi	r5,2085
 82023d4:	29740c04 	addi	r5,r5,-12240
 82023d8:	1009883a 	mov	r4,r2
 82023dc:	82045080 	call	8204508 <strstr>
 82023e0:	1000e726 	beq	r2,zero,8202780 <sss_exec_command+0x938>
			   tx_wr_pos += sprintf(tx_wr_pos, "negative trigger\n");
 82023e4:	e0fb9417 	ldw	r3,-4528(fp)
 82023e8:	00820974 	movhi	r2,2085
 82023ec:	10b40e04 	addi	r2,r2,-12232
 82023f0:	1009883a 	mov	r4,r2
 82023f4:	00800484 	movi	r2,18
 82023f8:	100d883a 	mov	r6,r2
 82023fc:	200b883a 	mov	r5,r4
 8202400:	1809883a 	mov	r4,r3
 8202404:	8202f6c0 	call	8202f6c <memcpy>
 8202408:	00800444 	movi	r2,17
 820240c:	1007883a 	mov	r3,r2
 8202410:	e0bb9417 	ldw	r2,-4528(fp)
 8202414:	10c5883a 	add	r2,r2,r3
 8202418:	e0bb9415 	stw	r2,-4528(fp)
			   endValue ^= (-0 ^ endValue) & (1 << 2);
 820241c:	e0fb9603 	ldbu	r3,-4520(fp)
 8202420:	00bffec4 	movi	r2,-5
 8202424:	1884703a 	and	r2,r3,r2
 8202428:	e0bb9605 	stb	r2,-4520(fp)
 820242c:	0000d406 	br	8202780 <sss_exec_command+0x938>
		   }
	   }
   } else if ( strstr(text_buf, "quit") != NULL){
 8202430:	e0bd1104 	addi	r2,fp,-3004
 8202434:	01420974 	movhi	r5,2085
 8202438:	29741304 	addi	r5,r5,-12212
 820243c:	1009883a 	mov	r4,r2
 8202440:	82045080 	call	8204508 <strstr>
 8202444:	10001226 	beq	r2,zero,8202490 <sss_exec_command+0x648>
	   tx_wr_pos += sprintf(tx_wr_pos,"Terminating connection.\n\n\r");
 8202448:	e0fb9417 	ldw	r3,-4528(fp)
 820244c:	00820974 	movhi	r2,2085
 8202450:	10b41504 	addi	r2,r2,-12204
 8202454:	1009883a 	mov	r4,r2
 8202458:	008006c4 	movi	r2,27
 820245c:	100d883a 	mov	r6,r2
 8202460:	200b883a 	mov	r5,r4
 8202464:	1809883a 	mov	r4,r3
 8202468:	8202f6c0 	call	8202f6c <memcpy>
 820246c:	00800684 	movi	r2,26
 8202470:	1007883a 	mov	r3,r2
 8202474:	e0bb9417 	ldw	r2,-4528(fp)
 8202478:	10c5883a 	add	r2,r2,r3
 820247c:	e0bb9415 	stw	r2,-4528(fp)
	   conn->close = 1;
 8202480:	e0bfff17 	ldw	r2,-4(fp)
 8202484:	00c00044 	movi	r3,1
 8202488:	10c00215 	stw	r3,8(r2)
 820248c:	0000bc06 	br	8202780 <sss_exec_command+0x938>
   } else if ( strstr(text_buf, "*rst") != NULL){
 8202490:	e0bd1104 	addi	r2,fp,-3004
 8202494:	01420974 	movhi	r5,2085
 8202498:	29741c04 	addi	r5,r5,-12176
 820249c:	1009883a 	mov	r4,r2
 82024a0:	82045080 	call	8204508 <strstr>
 82024a4:	10001d26 	beq	r2,zero,820251c <sss_exec_command+0x6d4>
	   tx_wr_pos += sprintf(tx_wr_pos, "Resetting\n");
 82024a8:	e0bb9417 	ldw	r2,-4528(fp)
 82024ac:	00c01484 	movi	r3,82
 82024b0:	10c00005 	stb	r3,0(r2)
 82024b4:	00c01944 	movi	r3,101
 82024b8:	10c00045 	stb	r3,1(r2)
 82024bc:	00c01cc4 	movi	r3,115
 82024c0:	10c00085 	stb	r3,2(r2)
 82024c4:	00c01944 	movi	r3,101
 82024c8:	10c000c5 	stb	r3,3(r2)
 82024cc:	00c01d04 	movi	r3,116
 82024d0:	10c00105 	stb	r3,4(r2)
 82024d4:	00c01d04 	movi	r3,116
 82024d8:	10c00145 	stb	r3,5(r2)
 82024dc:	00c01a44 	movi	r3,105
 82024e0:	10c00185 	stb	r3,6(r2)
 82024e4:	00c01b84 	movi	r3,110
 82024e8:	10c001c5 	stb	r3,7(r2)
 82024ec:	00c019c4 	movi	r3,103
 82024f0:	10c00205 	stb	r3,8(r2)
 82024f4:	00c00284 	movi	r3,10
 82024f8:	10c00245 	stb	r3,9(r2)
 82024fc:	10000285 	stb	zero,10(r2)
 8202500:	00800284 	movi	r2,10
 8202504:	1007883a 	mov	r3,r2
 8202508:	e0bb9417 	ldw	r2,-4528(fp)
 820250c:	10c5883a 	add	r2,r2,r3
 8202510:	e0bb9415 	stw	r2,-4528(fp)
	   endValue=0;
 8202514:	e03b9605 	stb	zero,-4520(fp)
 8202518:	00009906 	br	8202780 <sss_exec_command+0x938>

   } else if ( strstr(text_buf, "status") != NULL){
 820251c:	e0bd1104 	addi	r2,fp,-3004
 8202520:	01420974 	movhi	r5,2085
 8202524:	29741e04 	addi	r5,r5,-12168
 8202528:	1009883a 	mov	r4,r2
 820252c:	82045080 	call	8204508 <strstr>
 8202530:	10008b26 	beq	r2,zero,8202760 <sss_exec_command+0x918>
	   if((startValue >> 1) & 1){
 8202534:	e0bb98c3 	ldbu	r2,-4509(fp)
 8202538:	1004d07a 	srli	r2,r2,1
 820253c:	10803fcc 	andi	r2,r2,255
 8202540:	1080004c 	andi	r2,r2,1
 8202544:	10002226 	beq	r2,zero,82025d0 <sss_exec_command+0x788>
		   tx_wr_pos += sprintf(tx_wr_pos, "Self Trigger\n");
 8202548:	e0bb9417 	ldw	r2,-4528(fp)
 820254c:	00c014c4 	movi	r3,83
 8202550:	10c00005 	stb	r3,0(r2)
 8202554:	00c01944 	movi	r3,101
 8202558:	10c00045 	stb	r3,1(r2)
 820255c:	00c01b04 	movi	r3,108
 8202560:	10c00085 	stb	r3,2(r2)
 8202564:	00c01984 	movi	r3,102
 8202568:	10c000c5 	stb	r3,3(r2)
 820256c:	00c00804 	movi	r3,32
 8202570:	10c00105 	stb	r3,4(r2)
 8202574:	00c01504 	movi	r3,84
 8202578:	10c00145 	stb	r3,5(r2)
 820257c:	00c01c84 	movi	r3,114
 8202580:	10c00185 	stb	r3,6(r2)
 8202584:	00c01a44 	movi	r3,105
 8202588:	10c001c5 	stb	r3,7(r2)
 820258c:	00c019c4 	movi	r3,103
 8202590:	10c00205 	stb	r3,8(r2)
 8202594:	00c019c4 	movi	r3,103
 8202598:	10c00245 	stb	r3,9(r2)
 820259c:	00c01944 	movi	r3,101
 82025a0:	10c00285 	stb	r3,10(r2)
 82025a4:	00c01c84 	movi	r3,114
 82025a8:	10c002c5 	stb	r3,11(r2)
 82025ac:	00c00284 	movi	r3,10
 82025b0:	10c00305 	stb	r3,12(r2)
 82025b4:	10000345 	stb	zero,13(r2)
 82025b8:	00800344 	movi	r2,13
 82025bc:	1007883a 	mov	r3,r2
 82025c0:	e0bb9417 	ldw	r2,-4528(fp)
 82025c4:	10c5883a 	add	r2,r2,r3
 82025c8:	e0bb9415 	stw	r2,-4528(fp)
 82025cc:	00000e06 	br	8202608 <sss_exec_command+0x7c0>
	   } else {
		   tx_wr_pos += sprintf(tx_wr_pos, "External Trigger\n");
 82025d0:	e0fb9417 	ldw	r3,-4528(fp)
 82025d4:	00820974 	movhi	r2,2085
 82025d8:	10b42004 	addi	r2,r2,-12160
 82025dc:	1009883a 	mov	r4,r2
 82025e0:	00800484 	movi	r2,18
 82025e4:	100d883a 	mov	r6,r2
 82025e8:	200b883a 	mov	r5,r4
 82025ec:	1809883a 	mov	r4,r3
 82025f0:	8202f6c0 	call	8202f6c <memcpy>
 82025f4:	00800444 	movi	r2,17
 82025f8:	1007883a 	mov	r3,r2
 82025fc:	e0bb9417 	ldw	r2,-4528(fp)
 8202600:	10c5883a 	add	r2,r2,r3
 8202604:	e0bb9415 	stw	r2,-4528(fp)
	   }

	   if((startValue >> 2) & 1){
 8202608:	e0bb98c3 	ldbu	r2,-4509(fp)
 820260c:	1004d0ba 	srli	r2,r2,2
 8202610:	10803fcc 	andi	r2,r2,255
 8202614:	1080004c 	andi	r2,r2,1
 8202618:	10000f26 	beq	r2,zero,8202658 <sss_exec_command+0x810>
		   tx_wr_pos += sprintf(tx_wr_pos, "Positive Trigger\n");
 820261c:	e0fb9417 	ldw	r3,-4528(fp)
 8202620:	00820974 	movhi	r2,2085
 8202624:	10b42504 	addi	r2,r2,-12140
 8202628:	1009883a 	mov	r4,r2
 820262c:	00800484 	movi	r2,18
 8202630:	100d883a 	mov	r6,r2
 8202634:	200b883a 	mov	r5,r4
 8202638:	1809883a 	mov	r4,r3
 820263c:	8202f6c0 	call	8202f6c <memcpy>
 8202640:	00800444 	movi	r2,17
 8202644:	1007883a 	mov	r3,r2
 8202648:	e0bb9417 	ldw	r2,-4528(fp)
 820264c:	10c5883a 	add	r2,r2,r3
 8202650:	e0bb9415 	stw	r2,-4528(fp)
 8202654:	00000e06 	br	8202690 <sss_exec_command+0x848>
	   } else {
		   tx_wr_pos += sprintf(tx_wr_pos, "Negative Trigger\n");
 8202658:	e0fb9417 	ldw	r3,-4528(fp)
 820265c:	00820974 	movhi	r2,2085
 8202660:	10b42a04 	addi	r2,r2,-12120
 8202664:	1009883a 	mov	r4,r2
 8202668:	00800484 	movi	r2,18
 820266c:	100d883a 	mov	r6,r2
 8202670:	200b883a 	mov	r5,r4
 8202674:	1809883a 	mov	r4,r3
 8202678:	8202f6c0 	call	8202f6c <memcpy>
 820267c:	00800444 	movi	r2,17
 8202680:	1007883a 	mov	r3,r2
 8202684:	e0bb9417 	ldw	r2,-4528(fp)
 8202688:	10c5883a 	add	r2,r2,r3
 820268c:	e0bb9415 	stw	r2,-4528(fp)
	   }

	   if((startValue >> 3) & 1){
 8202690:	e0bb98c3 	ldbu	r2,-4509(fp)
 8202694:	1004d0fa 	srli	r2,r2,3
 8202698:	10803fcc 	andi	r2,r2,255
 820269c:	1080004c 	andi	r2,r2,1
 82026a0:	10000f26 	beq	r2,zero,82026e0 <sss_exec_command+0x898>
		   tx_wr_pos += sprintf(tx_wr_pos, "Delay enabled\n");
 82026a4:	e0fb9417 	ldw	r3,-4528(fp)
 82026a8:	00820974 	movhi	r2,2085
 82026ac:	10b42f04 	addi	r2,r2,-12100
 82026b0:	1009883a 	mov	r4,r2
 82026b4:	008003c4 	movi	r2,15
 82026b8:	100d883a 	mov	r6,r2
 82026bc:	200b883a 	mov	r5,r4
 82026c0:	1809883a 	mov	r4,r3
 82026c4:	8202f6c0 	call	8202f6c <memcpy>
 82026c8:	00800384 	movi	r2,14
 82026cc:	1007883a 	mov	r3,r2
 82026d0:	e0bb9417 	ldw	r2,-4528(fp)
 82026d4:	10c5883a 	add	r2,r2,r3
 82026d8:	e0bb9415 	stw	r2,-4528(fp)
 82026dc:	00000e06 	br	8202718 <sss_exec_command+0x8d0>
	   } else {
		   tx_wr_pos += sprintf(tx_wr_pos, "Delay disabled\n");
 82026e0:	e0fb9417 	ldw	r3,-4528(fp)
 82026e4:	00820974 	movhi	r2,2085
 82026e8:	10b43304 	addi	r2,r2,-12084
 82026ec:	1009883a 	mov	r4,r2
 82026f0:	00800404 	movi	r2,16
 82026f4:	100d883a 	mov	r6,r2
 82026f8:	200b883a 	mov	r5,r4
 82026fc:	1809883a 	mov	r4,r3
 8202700:	8202f6c0 	call	8202f6c <memcpy>
 8202704:	008003c4 	movi	r2,15
 8202708:	1007883a 	mov	r3,r2
 820270c:	e0bb9417 	ldw	r2,-4528(fp)
 8202710:	10c5883a 	add	r2,r2,r3
 8202714:	e0bb9415 	stw	r2,-4528(fp)
	   }

	   tx_wr_pos += sprintf(tx_wr_pos, "done\n");
 8202718:	e0bb9417 	ldw	r2,-4528(fp)
 820271c:	00c01904 	movi	r3,100
 8202720:	10c00005 	stb	r3,0(r2)
 8202724:	00c01bc4 	movi	r3,111
 8202728:	10c00045 	stb	r3,1(r2)
 820272c:	00c01b84 	movi	r3,110
 8202730:	10c00085 	stb	r3,2(r2)
 8202734:	00c01944 	movi	r3,101
 8202738:	10c000c5 	stb	r3,3(r2)
 820273c:	00c00284 	movi	r3,10
 8202740:	10c00105 	stb	r3,4(r2)
 8202744:	10000145 	stb	zero,5(r2)
 8202748:	00800144 	movi	r2,5
 820274c:	1007883a 	mov	r3,r2
 8202750:	e0bb9417 	ldw	r2,-4528(fp)
 8202754:	10c5883a 	add	r2,r2,r3
 8202758:	e0bb9415 	stw	r2,-4528(fp)
 820275c:	00000806 	br	8202780 <sss_exec_command+0x938>
   } else if ( strstr(text_buf, "menu") != NULL){
 8202760:	e0bd1104 	addi	r2,fp,-3004
 8202764:	01420974 	movhi	r5,2085
 8202768:	29743704 	addi	r5,r5,-12068
 820276c:	1009883a 	mov	r4,r2
 8202770:	82045080 	call	8204508 <strstr>
 8202774:	10000226 	beq	r2,zero,8202780 <sss_exec_command+0x938>
	   sss_send_menu(conn);
 8202778:	e13fff17 	ldw	r4,-4(fp)
 820277c:	8201abc0 	call	8201abc <sss_send_menu>

   }



  IOWR_ALTERA_AVALON_PIO_DATA(ADC_CONTROL_BASE, endValue);
 8202780:	e0fb9603 	ldbu	r3,-4520(fp)
 8202784:	00824034 	movhi	r2,2304
 8202788:	10801004 	addi	r2,r2,64
 820278c:	10c00035 	stwio	r3,0(r2)


  send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);  
 8202790:	e0bfff17 	ldw	r2,-4(fp)
 8202794:	11000117 	ldw	r4,4(r2)
 8202798:	e0fb9417 	ldw	r3,-4528(fp)
 820279c:	e0bb9a04 	addi	r2,fp,-4504
 82027a0:	1887c83a 	sub	r3,r3,r2
 82027a4:	e0bb9a04 	addi	r2,fp,-4504
 82027a8:	000f883a 	mov	r7,zero
 82027ac:	180d883a 	mov	r6,r3
 82027b0:	100b883a 	mov	r5,r2
 82027b4:	82315cc0 	call	82315cc <t_send>
  
  return;
 82027b8:	0001883a 	nop
}
 82027bc:	e037883a 	mov	sp,fp
 82027c0:	dfc00117 	ldw	ra,4(sp)
 82027c4:	df000017 	ldw	fp,0(sp)
 82027c8:	dec00204 	addi	sp,sp,8
 82027cc:	f800283a 	ret

082027d0 <sss_handle_receive>:
 * sss_exec_command() routine. Aside from these, we must move incoming
 * (un-processed) data to buffer start as appropriate and keep track of 
 * associated pointers.
 */
void sss_handle_receive(SSSConn* conn)
{
 82027d0:	defffa04 	addi	sp,sp,-24
 82027d4:	dfc00515 	stw	ra,20(sp)
 82027d8:	df000415 	stw	fp,16(sp)
 82027dc:	df000404 	addi	fp,sp,16
 82027e0:	e13fff15 	stw	r4,-4(fp)
  int data_used = 0, rx_code = 0;
 82027e4:	e03ffc15 	stw	zero,-16(fp)
 82027e8:	e03ffd15 	stw	zero,-12(fp)
  char *lf_addr; 
  
  conn->rx_rd_pos = conn->rx_buffer;
 82027ec:	e0bfff17 	ldw	r2,-4(fp)
 82027f0:	10c00304 	addi	r3,r2,12
 82027f4:	e0bfff17 	ldw	r2,-4(fp)
 82027f8:	10c17a15 	stw	r3,1512(r2)
  conn->rx_wr_pos = conn->rx_buffer;
 82027fc:	e0bfff17 	ldw	r2,-4(fp)
 8202800:	10c00304 	addi	r3,r2,12
 8202804:	e0bfff17 	ldw	r2,-4(fp)
 8202808:	10c17b15 	stw	r3,1516(r2)
  
  printf("[sss_handle_receive] processing RX data\n");
 820280c:	01020974 	movhi	r4,2085
 8202810:	21343904 	addi	r4,r4,-12060
 8202814:	82036800 	call	8203680 <puts>
  
  while(conn->state != CLOSE)
 8202818:	00005606 	br	8202974 <sss_handle_receive+0x1a4>
  {
    /* Find the Carriage return which marks the end of the header */
    lf_addr = strchr((const char*)conn->rx_buffer, '\n');
 820281c:	e0bfff17 	ldw	r2,-4(fp)
 8202820:	10800304 	addi	r2,r2,12
 8202824:	01400284 	movi	r5,10
 8202828:	1009883a 	mov	r4,r2
 820282c:	82037e00 	call	82037e0 <strchr>
 8202830:	e0bffe15 	stw	r2,-8(fp)
      
    if(lf_addr)
 8202834:	e0bffe17 	ldw	r2,-8(fp)
 8202838:	10000326 	beq	r2,zero,8202848 <sss_handle_receive+0x78>
    {
      /* go off and do whatever the user wanted us to do */
      sss_exec_command(conn);
 820283c:	e13fff17 	ldw	r4,-4(fp)
 8202840:	8201e480 	call	8201e48 <sss_exec_command>
 8202844:	00001c06 	br	82028b8 <sss_handle_receive+0xe8>
    }
    /* No newline received? Then ask the socket for data */
    else
    {
      rx_code = recv(conn->fd, (char*)conn->rx_wr_pos, 
 8202848:	e0bfff17 	ldw	r2,-4(fp)
 820284c:	11000117 	ldw	r4,4(r2)
 8202850:	e0bfff17 	ldw	r2,-4(fp)
 8202854:	11417b17 	ldw	r5,1516(r2)
 8202858:	e0bfff17 	ldw	r2,-4(fp)
 820285c:	10817b17 	ldw	r2,1516(r2)
 8202860:	1007883a 	mov	r3,r2
 8202864:	e0bfff17 	ldw	r2,-4(fp)
 8202868:	10800304 	addi	r2,r2,12
 820286c:	1885c83a 	sub	r2,r3,r2
 8202870:	00c176c4 	movi	r3,1499
 8202874:	1885c83a 	sub	r2,r3,r2
 8202878:	000f883a 	mov	r7,zero
 820287c:	100d883a 	mov	r6,r2
 8202880:	82311b80 	call	82311b8 <t_recv>
 8202884:	e0bffd15 	stw	r2,-12(fp)
        SSS_RX_BUF_SIZE - (conn->rx_wr_pos - conn->rx_buffer) -1, 0);
          
     if(rx_code > 0)
 8202888:	e0bffd17 	ldw	r2,-12(fp)
 820288c:	00800a0e 	bge	zero,r2,82028b8 <sss_handle_receive+0xe8>
      {
        conn->rx_wr_pos += rx_code;
 8202890:	e0bfff17 	ldw	r2,-4(fp)
 8202894:	10c17b17 	ldw	r3,1516(r2)
 8202898:	e0bffd17 	ldw	r2,-12(fp)
 820289c:	1887883a 	add	r3,r3,r2
 82028a0:	e0bfff17 	ldw	r2,-4(fp)
 82028a4:	10c17b15 	stw	r3,1516(r2)
        
        /* Zero terminate so we can use string functions */
        *(conn->rx_wr_pos+1) = 0;
 82028a8:	e0bfff17 	ldw	r2,-4(fp)
 82028ac:	10817b17 	ldw	r2,1516(r2)
 82028b0:	10800044 	addi	r2,r2,1
 82028b4:	10000005 	stb	zero,0(r2)

    /* 
     * When the quit command is received, update our connection state so that
     * we can exit the while() loop and close the connection
     */
    conn->state = conn->close ? CLOSE : READY;
 82028b8:	e0bfff17 	ldw	r2,-4(fp)
 82028bc:	10800217 	ldw	r2,8(r2)
 82028c0:	10000226 	beq	r2,zero,82028cc <sss_handle_receive+0xfc>
 82028c4:	00800084 	movi	r2,2
 82028c8:	00000106 	br	82028d0 <sss_handle_receive+0x100>
 82028cc:	0005883a 	mov	r2,zero
 82028d0:	e0ffff17 	ldw	r3,-4(fp)
 82028d4:	18800015 	stw	r2,0(r3)

    /* Manage buffer */
    data_used = conn->rx_rd_pos - conn->rx_buffer;
 82028d8:	e0bfff17 	ldw	r2,-4(fp)
 82028dc:	10817a17 	ldw	r2,1512(r2)
 82028e0:	1007883a 	mov	r3,r2
 82028e4:	e0bfff17 	ldw	r2,-4(fp)
 82028e8:	10800304 	addi	r2,r2,12
 82028ec:	1885c83a 	sub	r2,r3,r2
 82028f0:	e0bffc15 	stw	r2,-16(fp)
    memmove(conn->rx_buffer, conn->rx_rd_pos, 
 82028f4:	e0bfff17 	ldw	r2,-4(fp)
 82028f8:	10c00304 	addi	r3,r2,12
 82028fc:	e0bfff17 	ldw	r2,-4(fp)
 8202900:	11017a17 	ldw	r4,1512(r2)
       conn->rx_wr_pos - conn->rx_rd_pos);
 8202904:	e0bfff17 	ldw	r2,-4(fp)
 8202908:	10817b17 	ldw	r2,1516(r2)
 820290c:	100b883a 	mov	r5,r2
 8202910:	e0bfff17 	ldw	r2,-4(fp)
 8202914:	10817a17 	ldw	r2,1512(r2)
 8202918:	2885c83a 	sub	r2,r5,r2
     */
    conn->state = conn->close ? CLOSE : READY;

    /* Manage buffer */
    data_used = conn->rx_rd_pos - conn->rx_buffer;
    memmove(conn->rx_buffer, conn->rx_rd_pos, 
 820291c:	100d883a 	mov	r6,r2
 8202920:	200b883a 	mov	r5,r4
 8202924:	1809883a 	mov	r4,r3
 8202928:	82030b40 	call	82030b4 <memmove>
       conn->rx_wr_pos - conn->rx_rd_pos);
    conn->rx_rd_pos = conn->rx_buffer;
 820292c:	e0bfff17 	ldw	r2,-4(fp)
 8202930:	10c00304 	addi	r3,r2,12
 8202934:	e0bfff17 	ldw	r2,-4(fp)
 8202938:	10c17a15 	stw	r3,1512(r2)
    conn->rx_wr_pos -= data_used;
 820293c:	e0bfff17 	ldw	r2,-4(fp)
 8202940:	10c17b17 	ldw	r3,1516(r2)
 8202944:	e0bffc17 	ldw	r2,-16(fp)
 8202948:	0085c83a 	sub	r2,zero,r2
 820294c:	1887883a 	add	r3,r3,r2
 8202950:	e0bfff17 	ldw	r2,-4(fp)
 8202954:	10c17b15 	stw	r3,1516(r2)
    memset(conn->rx_wr_pos, 0, data_used);
 8202958:	e0bfff17 	ldw	r2,-4(fp)
 820295c:	10817b17 	ldw	r2,1516(r2)
 8202960:	e0fffc17 	ldw	r3,-16(fp)
 8202964:	180d883a 	mov	r6,r3
 8202968:	000b883a 	mov	r5,zero
 820296c:	1009883a 	mov	r4,r2
 8202970:	82032100 	call	8203210 <memset>
  conn->rx_rd_pos = conn->rx_buffer;
  conn->rx_wr_pos = conn->rx_buffer;
  
  printf("[sss_handle_receive] processing RX data\n");
  
  while(conn->state != CLOSE)
 8202974:	e0bfff17 	ldw	r2,-4(fp)
 8202978:	10800017 	ldw	r2,0(r2)
 820297c:	10800098 	cmpnei	r2,r2,2
 8202980:	103fa61e 	bne	r2,zero,820281c <sss_handle_receive+0x4c>
    conn->rx_rd_pos = conn->rx_buffer;
    conn->rx_wr_pos -= data_used;
    memset(conn->rx_wr_pos, 0, data_used);
  }

  printf("[sss_handle_receive] closing connection\n");
 8202984:	01020974 	movhi	r4,2085
 8202988:	21344304 	addi	r4,r4,-12020
 820298c:	82036800 	call	8203680 <puts>
  close(conn->fd);
 8202990:	e0bfff17 	ldw	r2,-4(fp)
 8202994:	10800117 	ldw	r2,4(r2)
 8202998:	1009883a 	mov	r4,r2
 820299c:	82258940 	call	8225894 <close>
  sss_reset_connection(conn);
 82029a0:	e13fff17 	ldw	r4,-4(fp)
 82029a4:	8201a4c0 	call	8201a4c <sss_reset_connection>
  
  return;
 82029a8:	0001883a 	nop
}
 82029ac:	e037883a 	mov	sp,fp
 82029b0:	dfc00117 	ldw	ra,4(sp)
 82029b4:	df000017 	ldw	fp,0(sp)
 82029b8:	dec00204 	addi	sp,sp,8
 82029bc:	f800283a 	ret

082029c0 <SSSSimpleSocketServerTask>:
 * (if a connection is active), the sss data socket. When data arrives, 
 * the approrpriate routine is called to either accept/reject a connection 
 * request, or process incoming data.
 */
void SSSSimpleSocketServerTask()
{
 82029c0:	deffb604 	addi	sp,sp,-296
 82029c4:	dfc04915 	stw	ra,292(sp)
 82029c8:	df004815 	stw	fp,288(sp)
 82029cc:	df004804 	addi	fp,sp,288
   * protocol and address families respectively. However, there is usually only
   * 1 address per protocol family. Thus PF_INET and AF_INET can be interchanged.
   * In the case of NicheStack, only the use of AF_INET is supported.
   * PF_INET is not supported in NicheStack.
   */ 
  if ((fd_listen = socket(AF_INET, SOCK_STREAM, 0)) < 0)
 82029d0:	000d883a 	mov	r6,zero
 82029d4:	01400044 	movi	r5,1
 82029d8:	01000084 	movi	r4,2
 82029dc:	823048c0 	call	823048c <t_socket>
 82029e0:	e0bfba15 	stw	r2,-280(fp)
 82029e4:	e0bfba17 	ldw	r2,-280(fp)
 82029e8:	1000040e 	bge	r2,zero,82029fc <SSSSimpleSocketServerTask+0x3c>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Socket creation failed");
 82029ec:	01420974 	movhi	r5,2085
 82029f0:	29744d04 	addi	r5,r5,-11980
 82029f4:	01003fc4 	movi	r4,255
 82029f8:	82007ac0 	call	82007ac <alt_NetworkErrorHandler>
   * port and incoming address. In this case we're binding to SSS_PORT and to
   * INADDR_ANY address (allowing anyone to connect to us. Bind may fail for 
   * various reasons, but the most common is that some other socket is bound to
   * the port we're requesting. 
   */ 
  addr.sin_family = AF_INET;
 82029fc:	00800084 	movi	r2,2
 8202a00:	e0bfbb0d 	sth	r2,-276(fp)
  addr.sin_port = htons(SSS_PORT);
 8202a04:	00878004 	movi	r2,7680
 8202a08:	e0bfbb8d 	sth	r2,-274(fp)
  addr.sin_addr.s_addr = INADDR_ANY;
 8202a0c:	e03fbc15 	stw	zero,-272(fp)
  
  if ((bind(fd_listen,(struct sockaddr *)&addr,sizeof(addr))) < 0)
 8202a10:	e0bfbb04 	addi	r2,fp,-276
 8202a14:	01800404 	movi	r6,16
 8202a18:	100b883a 	mov	r5,r2
 8202a1c:	e13fba17 	ldw	r4,-280(fp)
 8202a20:	823050c0 	call	823050c <t_bind>
 8202a24:	1000040e 	bge	r2,zero,8202a38 <SSSSimpleSocketServerTask+0x78>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Bind failed");
 8202a28:	01420974 	movhi	r5,2085
 8202a2c:	29745604 	addi	r5,r5,-11944
 8202a30:	01003fc4 	movi	r4,255
 8202a34:	82007ac0 	call	82007ac <alt_NetworkErrorHandler>
   * Sockets primer, continued...
   * The listen socket is a socket which is waiting for incoming connections.
   * This call to listen will block (i.e. not return) until someone tries to 
   * connect to this port.
   */ 
  if ((listen(fd_listen,1)) < 0)
 8202a38:	01400044 	movi	r5,1
 8202a3c:	e13fba17 	ldw	r4,-280(fp)
 8202a40:	82306700 	call	8230670 <t_listen>
 8202a44:	1000040e 	bge	r2,zero,8202a58 <SSSSimpleSocketServerTask+0x98>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Listen failed");
 8202a48:	01420974 	movhi	r5,2085
 8202a4c:	29745c04 	addi	r5,r5,-11920
 8202a50:	01003fc4 	movi	r4,255
 8202a54:	82007ac0 	call	82007ac <alt_NetworkErrorHandler>
  }

  /* At this point we have successfully created a socket which is listening
   * on SSS_PORT for connection requests from any remote address.
   */
  sss_reset_connection(&conn);
 8202a58:	01020974 	movhi	r4,2085
 8202a5c:	21109604 	addi	r4,r4,16984
 8202a60:	8201a4c0 	call	8201a4c <sss_reset_connection>
  printf("[sss_task] Simple Socket Server listening on port %d\n", SSS_PORT);
 8202a64:	01400784 	movi	r5,30
 8202a68:	01020974 	movhi	r4,2085
 8202a6c:	21346304 	addi	r4,r4,-11892
 8202a70:	82033fc0 	call	82033fc <printf>
     * 
     *   FD_ZERO  - Zero's out the sockets we're interested in
     *   FD_SET   - Adds a socket to those we're interested in
     *   FD_ISSET - Tests whether the chosen socket is set 
     */
    FD_ZERO(&readfds);
 8202a74:	e03fbf15 	stw	zero,-260(fp)
    FD_SET(fd_listen, &readfds);
 8202a78:	e0bfbf04 	addi	r2,fp,-260
 8202a7c:	100b883a 	mov	r5,r2
 8202a80:	e13fba17 	ldw	r4,-280(fp)
 8202a84:	82354780 	call	8235478 <ifd_set>
    max_socket = fd_listen+1;
 8202a88:	e0bfba17 	ldw	r2,-280(fp)
 8202a8c:	10800044 	addi	r2,r2,1
 8202a90:	e0bfb915 	stw	r2,-284(fp)

    if (conn.fd != -1)
 8202a94:	00820974 	movhi	r2,2085
 8202a98:	10909604 	addi	r2,r2,16984
 8202a9c:	10800117 	ldw	r2,4(r2)
 8202aa0:	10bfffe0 	cmpeqi	r2,r2,-1
 8202aa4:	1000111e 	bne	r2,zero,8202aec <SSSSimpleSocketServerTask+0x12c>
    {
      FD_SET(conn.fd, &readfds);
 8202aa8:	00820974 	movhi	r2,2085
 8202aac:	10909604 	addi	r2,r2,16984
 8202ab0:	10800117 	ldw	r2,4(r2)
 8202ab4:	e0ffbf04 	addi	r3,fp,-260
 8202ab8:	180b883a 	mov	r5,r3
 8202abc:	1009883a 	mov	r4,r2
 8202ac0:	82354780 	call	8235478 <ifd_set>
      if (max_socket <= conn.fd)
 8202ac4:	00820974 	movhi	r2,2085
 8202ac8:	10909604 	addi	r2,r2,16984
 8202acc:	10c00117 	ldw	r3,4(r2)
 8202ad0:	e0bfb917 	ldw	r2,-284(fp)
 8202ad4:	18800516 	blt	r3,r2,8202aec <SSSSimpleSocketServerTask+0x12c>
      {
        max_socket = conn.fd+1;
 8202ad8:	00820974 	movhi	r2,2085
 8202adc:	10909604 	addi	r2,r2,16984
 8202ae0:	10800117 	ldw	r2,4(r2)
 8202ae4:	10800044 	addi	r2,r2,1
 8202ae8:	e0bfb915 	stw	r2,-284(fp)
      }
    }

    select(max_socket, &readfds, NULL, NULL, NULL);
 8202aec:	e0bfbf04 	addi	r2,fp,-260
 8202af0:	d8000015 	stw	zero,0(sp)
 8202af4:	000f883a 	mov	r7,zero
 8202af8:	000d883a 	mov	r6,zero
 8202afc:	100b883a 	mov	r5,r2
 8202b00:	e13fb917 	ldw	r4,-284(fp)
 8202b04:	82285080 	call	8228508 <bsd_select>
     * is "set" in readfs, then we have an incoming connection request. We'll
     * call a routine to explicitly accept or deny the incoming connection 
     * request (in this example, we accept a single connection and reject any
     * others that come in while the connection is open).
     */
    if (FD_ISSET(fd_listen, &readfds))
 8202b08:	e0bfbf04 	addi	r2,fp,-260
 8202b0c:	100b883a 	mov	r5,r2
 8202b10:	e13fba17 	ldw	r4,-280(fp)
 8202b14:	82354f00 	call	82354f0 <ifd_isset>
 8202b18:	10000526 	beq	r2,zero,8202b30 <SSSSimpleSocketServerTask+0x170>
    {
      sss_handle_accept(fd_listen, &conn);
 8202b1c:	01420974 	movhi	r5,2085
 8202b20:	29509604 	addi	r5,r5,16984
 8202b24:	e13fba17 	ldw	r4,-280(fp)
 8202b28:	8201d800 	call	8201d80 <sss_handle_accept>
 8202b2c:	003fd106 	br	8202a74 <SSSSimpleSocketServerTask+0xb4>
     * incoming data for our sss server, and we call our receiver routine
     * to process it.
     */
    else
    {
      if ((conn.fd != -1) && FD_ISSET(conn.fd, &readfds))
 8202b30:	00820974 	movhi	r2,2085
 8202b34:	10909604 	addi	r2,r2,16984
 8202b38:	10800117 	ldw	r2,4(r2)
 8202b3c:	10bfffe0 	cmpeqi	r2,r2,-1
 8202b40:	103fcc1e 	bne	r2,zero,8202a74 <SSSSimpleSocketServerTask+0xb4>
 8202b44:	00820974 	movhi	r2,2085
 8202b48:	10909604 	addi	r2,r2,16984
 8202b4c:	10800117 	ldw	r2,4(r2)
 8202b50:	e0ffbf04 	addi	r3,fp,-260
 8202b54:	180b883a 	mov	r5,r3
 8202b58:	1009883a 	mov	r4,r2
 8202b5c:	82354f00 	call	82354f0 <ifd_isset>
 8202b60:	103fc426 	beq	r2,zero,8202a74 <SSSSimpleSocketServerTask+0xb4>
      {
        sss_handle_receive(&conn);
 8202b64:	01020974 	movhi	r4,2085
 8202b68:	21109604 	addi	r4,r4,16984
 8202b6c:	82027d00 	call	82027d0 <sss_handle_receive>
      }
    }
  } /* while(1) */
 8202b70:	003fc006 	br	8202a74 <SSSSimpleSocketServerTask+0xb4>

08202b74 <__divsi3>:
 8202b74:	20001b16 	blt	r4,zero,8202be4 <__divsi3+0x70>
 8202b78:	000f883a 	mov	r7,zero
 8202b7c:	28001616 	blt	r5,zero,8202bd8 <__divsi3+0x64>
 8202b80:	200d883a 	mov	r6,r4
 8202b84:	29001a2e 	bgeu	r5,r4,8202bf0 <__divsi3+0x7c>
 8202b88:	00800804 	movi	r2,32
 8202b8c:	00c00044 	movi	r3,1
 8202b90:	00000106 	br	8202b98 <__divsi3+0x24>
 8202b94:	10000d26 	beq	r2,zero,8202bcc <__divsi3+0x58>
 8202b98:	294b883a 	add	r5,r5,r5
 8202b9c:	10bfffc4 	addi	r2,r2,-1
 8202ba0:	18c7883a 	add	r3,r3,r3
 8202ba4:	293ffb36 	bltu	r5,r4,8202b94 <__divsi3+0x20>
 8202ba8:	0005883a 	mov	r2,zero
 8202bac:	18000726 	beq	r3,zero,8202bcc <__divsi3+0x58>
 8202bb0:	0005883a 	mov	r2,zero
 8202bb4:	31400236 	bltu	r6,r5,8202bc0 <__divsi3+0x4c>
 8202bb8:	314dc83a 	sub	r6,r6,r5
 8202bbc:	10c4b03a 	or	r2,r2,r3
 8202bc0:	1806d07a 	srli	r3,r3,1
 8202bc4:	280ad07a 	srli	r5,r5,1
 8202bc8:	183ffa1e 	bne	r3,zero,8202bb4 <__divsi3+0x40>
 8202bcc:	38000126 	beq	r7,zero,8202bd4 <__divsi3+0x60>
 8202bd0:	0085c83a 	sub	r2,zero,r2
 8202bd4:	f800283a 	ret
 8202bd8:	014bc83a 	sub	r5,zero,r5
 8202bdc:	39c0005c 	xori	r7,r7,1
 8202be0:	003fe706 	br	8202b80 <__divsi3+0xc>
 8202be4:	0109c83a 	sub	r4,zero,r4
 8202be8:	01c00044 	movi	r7,1
 8202bec:	003fe306 	br	8202b7c <__divsi3+0x8>
 8202bf0:	00c00044 	movi	r3,1
 8202bf4:	003fee06 	br	8202bb0 <__divsi3+0x3c>

08202bf8 <__modsi3>:
 8202bf8:	20001716 	blt	r4,zero,8202c58 <__modsi3+0x60>
 8202bfc:	000f883a 	mov	r7,zero
 8202c00:	2005883a 	mov	r2,r4
 8202c04:	28001216 	blt	r5,zero,8202c50 <__modsi3+0x58>
 8202c08:	2900162e 	bgeu	r5,r4,8202c64 <__modsi3+0x6c>
 8202c0c:	01800804 	movi	r6,32
 8202c10:	00c00044 	movi	r3,1
 8202c14:	00000106 	br	8202c1c <__modsi3+0x24>
 8202c18:	30000a26 	beq	r6,zero,8202c44 <__modsi3+0x4c>
 8202c1c:	294b883a 	add	r5,r5,r5
 8202c20:	31bfffc4 	addi	r6,r6,-1
 8202c24:	18c7883a 	add	r3,r3,r3
 8202c28:	293ffb36 	bltu	r5,r4,8202c18 <__modsi3+0x20>
 8202c2c:	18000526 	beq	r3,zero,8202c44 <__modsi3+0x4c>
 8202c30:	1806d07a 	srli	r3,r3,1
 8202c34:	11400136 	bltu	r2,r5,8202c3c <__modsi3+0x44>
 8202c38:	1145c83a 	sub	r2,r2,r5
 8202c3c:	280ad07a 	srli	r5,r5,1
 8202c40:	183ffb1e 	bne	r3,zero,8202c30 <__modsi3+0x38>
 8202c44:	38000126 	beq	r7,zero,8202c4c <__modsi3+0x54>
 8202c48:	0085c83a 	sub	r2,zero,r2
 8202c4c:	f800283a 	ret
 8202c50:	014bc83a 	sub	r5,zero,r5
 8202c54:	003fec06 	br	8202c08 <__modsi3+0x10>
 8202c58:	0109c83a 	sub	r4,zero,r4
 8202c5c:	01c00044 	movi	r7,1
 8202c60:	003fe706 	br	8202c00 <__modsi3+0x8>
 8202c64:	00c00044 	movi	r3,1
 8202c68:	003ff106 	br	8202c30 <__modsi3+0x38>

08202c6c <__udivsi3>:
 8202c6c:	200d883a 	mov	r6,r4
 8202c70:	2900152e 	bgeu	r5,r4,8202cc8 <__udivsi3+0x5c>
 8202c74:	28001416 	blt	r5,zero,8202cc8 <__udivsi3+0x5c>
 8202c78:	00800804 	movi	r2,32
 8202c7c:	00c00044 	movi	r3,1
 8202c80:	00000206 	br	8202c8c <__udivsi3+0x20>
 8202c84:	10000e26 	beq	r2,zero,8202cc0 <__udivsi3+0x54>
 8202c88:	28000516 	blt	r5,zero,8202ca0 <__udivsi3+0x34>
 8202c8c:	294b883a 	add	r5,r5,r5
 8202c90:	10bfffc4 	addi	r2,r2,-1
 8202c94:	18c7883a 	add	r3,r3,r3
 8202c98:	293ffa36 	bltu	r5,r4,8202c84 <__udivsi3+0x18>
 8202c9c:	18000826 	beq	r3,zero,8202cc0 <__udivsi3+0x54>
 8202ca0:	0005883a 	mov	r2,zero
 8202ca4:	31400236 	bltu	r6,r5,8202cb0 <__udivsi3+0x44>
 8202ca8:	314dc83a 	sub	r6,r6,r5
 8202cac:	10c4b03a 	or	r2,r2,r3
 8202cb0:	1806d07a 	srli	r3,r3,1
 8202cb4:	280ad07a 	srli	r5,r5,1
 8202cb8:	183ffa1e 	bne	r3,zero,8202ca4 <__udivsi3+0x38>
 8202cbc:	f800283a 	ret
 8202cc0:	0005883a 	mov	r2,zero
 8202cc4:	f800283a 	ret
 8202cc8:	00c00044 	movi	r3,1
 8202ccc:	003ff406 	br	8202ca0 <__udivsi3+0x34>

08202cd0 <__umodsi3>:
 8202cd0:	2005883a 	mov	r2,r4
 8202cd4:	2900122e 	bgeu	r5,r4,8202d20 <__umodsi3+0x50>
 8202cd8:	28001116 	blt	r5,zero,8202d20 <__umodsi3+0x50>
 8202cdc:	01800804 	movi	r6,32
 8202ce0:	00c00044 	movi	r3,1
 8202ce4:	00000206 	br	8202cf0 <__umodsi3+0x20>
 8202ce8:	30000c26 	beq	r6,zero,8202d1c <__umodsi3+0x4c>
 8202cec:	28000516 	blt	r5,zero,8202d04 <__umodsi3+0x34>
 8202cf0:	294b883a 	add	r5,r5,r5
 8202cf4:	31bfffc4 	addi	r6,r6,-1
 8202cf8:	18c7883a 	add	r3,r3,r3
 8202cfc:	293ffa36 	bltu	r5,r4,8202ce8 <__umodsi3+0x18>
 8202d00:	18000626 	beq	r3,zero,8202d1c <__umodsi3+0x4c>
 8202d04:	1806d07a 	srli	r3,r3,1
 8202d08:	11400136 	bltu	r2,r5,8202d10 <__umodsi3+0x40>
 8202d0c:	1145c83a 	sub	r2,r2,r5
 8202d10:	280ad07a 	srli	r5,r5,1
 8202d14:	183ffb1e 	bne	r3,zero,8202d04 <__umodsi3+0x34>
 8202d18:	f800283a 	ret
 8202d1c:	f800283a 	ret
 8202d20:	00c00044 	movi	r3,1
 8202d24:	003ff706 	br	8202d04 <__umodsi3+0x34>

08202d28 <_fprintf_r>:
 8202d28:	defffe04 	addi	sp,sp,-8
 8202d2c:	2809883a 	mov	r4,r5
 8202d30:	300b883a 	mov	r5,r6
 8202d34:	dfc00015 	stw	ra,0(sp)
 8202d38:	d9c00115 	stw	r7,4(sp)
 8202d3c:	d9800104 	addi	r6,sp,4
 8202d40:	8208c900 	call	8208c90 <__vfprintf_internal>
 8202d44:	dfc00017 	ldw	ra,0(sp)
 8202d48:	dec00204 	addi	sp,sp,8
 8202d4c:	f800283a 	ret

08202d50 <fprintf>:
 8202d50:	defffd04 	addi	sp,sp,-12
 8202d54:	dfc00015 	stw	ra,0(sp)
 8202d58:	d9800115 	stw	r6,4(sp)
 8202d5c:	d9c00215 	stw	r7,8(sp)
 8202d60:	d9800104 	addi	r6,sp,4
 8202d64:	8208c900 	call	8208c90 <__vfprintf_internal>
 8202d68:	dfc00017 	ldw	ra,0(sp)
 8202d6c:	dec00304 	addi	sp,sp,12
 8202d70:	f800283a 	ret

08202d74 <_fwrite_r>:
 8202d74:	defff504 	addi	sp,sp,-44
 8202d78:	dc800815 	stw	r18,32(sp)
 8202d7c:	39a5383a 	mul	r18,r7,r6
 8202d80:	d8800304 	addi	r2,sp,12
 8202d84:	d8800015 	stw	r2,0(sp)
 8202d88:	00800044 	movi	r2,1
 8202d8c:	dcc00915 	stw	r19,36(sp)
 8202d90:	dc400715 	stw	r17,28(sp)
 8202d94:	dc000615 	stw	r16,24(sp)
 8202d98:	d9400315 	stw	r5,12(sp)
 8202d9c:	dfc00a15 	stw	ra,40(sp)
 8202da0:	dc800415 	stw	r18,16(sp)
 8202da4:	dc800215 	stw	r18,8(sp)
 8202da8:	d8800115 	stw	r2,4(sp)
 8202dac:	3027883a 	mov	r19,r6
 8202db0:	3821883a 	mov	r16,r7
 8202db4:	2023883a 	mov	r17,r4
 8202db8:	d9400b17 	ldw	r5,44(sp)
 8202dbc:	20000226 	beq	r4,zero,8202dc8 <_fwrite_r+0x54>
 8202dc0:	20800e17 	ldw	r2,56(r4)
 8202dc4:	10001a26 	beq	r2,zero,8202e30 <_fwrite_r+0xbc>
 8202dc8:	2880030b 	ldhu	r2,12(r5)
 8202dcc:	10c8000c 	andi	r3,r2,8192
 8202dd0:	1800061e 	bne	r3,zero,8202dec <_fwrite_r+0x78>
 8202dd4:	29001917 	ldw	r4,100(r5)
 8202dd8:	00f7ffc4 	movi	r3,-8193
 8202ddc:	10880014 	ori	r2,r2,8192
 8202de0:	20c6703a 	and	r3,r4,r3
 8202de4:	2880030d 	sth	r2,12(r5)
 8202de8:	28c01915 	stw	r3,100(r5)
 8202dec:	d80d883a 	mov	r6,sp
 8202df0:	8809883a 	mov	r4,r17
 8202df4:	820b46c0 	call	820b46c <__sfvwrite_r>
 8202df8:	10000b26 	beq	r2,zero,8202e28 <_fwrite_r+0xb4>
 8202dfc:	d9000217 	ldw	r4,8(sp)
 8202e00:	980b883a 	mov	r5,r19
 8202e04:	9109c83a 	sub	r4,r18,r4
 8202e08:	8202c6c0 	call	8202c6c <__udivsi3>
 8202e0c:	dfc00a17 	ldw	ra,40(sp)
 8202e10:	dcc00917 	ldw	r19,36(sp)
 8202e14:	dc800817 	ldw	r18,32(sp)
 8202e18:	dc400717 	ldw	r17,28(sp)
 8202e1c:	dc000617 	ldw	r16,24(sp)
 8202e20:	dec00b04 	addi	sp,sp,44
 8202e24:	f800283a 	ret
 8202e28:	8005883a 	mov	r2,r16
 8202e2c:	003ff706 	br	8202e0c <_fwrite_r+0x98>
 8202e30:	d9400515 	stw	r5,20(sp)
 8202e34:	820ae940 	call	820ae94 <__sinit>
 8202e38:	d9400517 	ldw	r5,20(sp)
 8202e3c:	003fe206 	br	8202dc8 <_fwrite_r+0x54>

08202e40 <fwrite>:
 8202e40:	defffe04 	addi	sp,sp,-8
 8202e44:	00820974 	movhi	r2,2085
 8202e48:	d9c00015 	stw	r7,0(sp)
 8202e4c:	108fbb04 	addi	r2,r2,16108
 8202e50:	300f883a 	mov	r7,r6
 8202e54:	280d883a 	mov	r6,r5
 8202e58:	200b883a 	mov	r5,r4
 8202e5c:	11000017 	ldw	r4,0(r2)
 8202e60:	dfc00115 	stw	ra,4(sp)
 8202e64:	8202d740 	call	8202d74 <_fwrite_r>
 8202e68:	dfc00117 	ldw	ra,4(sp)
 8202e6c:	dec00204 	addi	sp,sp,8
 8202e70:	f800283a 	ret

08202e74 <_getc_r>:
 8202e74:	defffd04 	addi	sp,sp,-12
 8202e78:	dc000115 	stw	r16,4(sp)
 8202e7c:	dfc00215 	stw	ra,8(sp)
 8202e80:	2021883a 	mov	r16,r4
 8202e84:	20000226 	beq	r4,zero,8202e90 <_getc_r+0x1c>
 8202e88:	20800e17 	ldw	r2,56(r4)
 8202e8c:	10000c26 	beq	r2,zero,8202ec0 <_getc_r+0x4c>
 8202e90:	28800117 	ldw	r2,4(r5)
 8202e94:	10bfffc4 	addi	r2,r2,-1
 8202e98:	28800115 	stw	r2,4(r5)
 8202e9c:	10000c16 	blt	r2,zero,8202ed0 <_getc_r+0x5c>
 8202ea0:	28800017 	ldw	r2,0(r5)
 8202ea4:	10c00044 	addi	r3,r2,1
 8202ea8:	28c00015 	stw	r3,0(r5)
 8202eac:	10800003 	ldbu	r2,0(r2)
 8202eb0:	dfc00217 	ldw	ra,8(sp)
 8202eb4:	dc000117 	ldw	r16,4(sp)
 8202eb8:	dec00304 	addi	sp,sp,12
 8202ebc:	f800283a 	ret
 8202ec0:	d9400015 	stw	r5,0(sp)
 8202ec4:	820ae940 	call	820ae94 <__sinit>
 8202ec8:	d9400017 	ldw	r5,0(sp)
 8202ecc:	003ff006 	br	8202e90 <_getc_r+0x1c>
 8202ed0:	8009883a 	mov	r4,r16
 8202ed4:	dfc00217 	ldw	ra,8(sp)
 8202ed8:	dc000117 	ldw	r16,4(sp)
 8202edc:	dec00304 	addi	sp,sp,12
 8202ee0:	82036941 	jmpi	8203694 <__srget_r>

08202ee4 <getc>:
 8202ee4:	00820974 	movhi	r2,2085
 8202ee8:	defffd04 	addi	sp,sp,-12
 8202eec:	108fbb04 	addi	r2,r2,16108
 8202ef0:	dc400115 	stw	r17,4(sp)
 8202ef4:	14400017 	ldw	r17,0(r2)
 8202ef8:	dc000015 	stw	r16,0(sp)
 8202efc:	dfc00215 	stw	ra,8(sp)
 8202f00:	2021883a 	mov	r16,r4
 8202f04:	88000226 	beq	r17,zero,8202f10 <getc+0x2c>
 8202f08:	88800e17 	ldw	r2,56(r17)
 8202f0c:	10000d26 	beq	r2,zero,8202f44 <getc+0x60>
 8202f10:	80800117 	ldw	r2,4(r16)
 8202f14:	10bfffc4 	addi	r2,r2,-1
 8202f18:	80800115 	stw	r2,4(r16)
 8202f1c:	10000c16 	blt	r2,zero,8202f50 <getc+0x6c>
 8202f20:	80800017 	ldw	r2,0(r16)
 8202f24:	10c00044 	addi	r3,r2,1
 8202f28:	80c00015 	stw	r3,0(r16)
 8202f2c:	10800003 	ldbu	r2,0(r2)
 8202f30:	dfc00217 	ldw	ra,8(sp)
 8202f34:	dc400117 	ldw	r17,4(sp)
 8202f38:	dc000017 	ldw	r16,0(sp)
 8202f3c:	dec00304 	addi	sp,sp,12
 8202f40:	f800283a 	ret
 8202f44:	8809883a 	mov	r4,r17
 8202f48:	820ae940 	call	820ae94 <__sinit>
 8202f4c:	003ff006 	br	8202f10 <getc+0x2c>
 8202f50:	800b883a 	mov	r5,r16
 8202f54:	8809883a 	mov	r4,r17
 8202f58:	dfc00217 	ldw	ra,8(sp)
 8202f5c:	dc400117 	ldw	r17,4(sp)
 8202f60:	dc000017 	ldw	r16,0(sp)
 8202f64:	dec00304 	addi	sp,sp,12
 8202f68:	82036941 	jmpi	8203694 <__srget_r>

08202f6c <memcpy>:
 8202f6c:	defffd04 	addi	sp,sp,-12
 8202f70:	dfc00215 	stw	ra,8(sp)
 8202f74:	dc400115 	stw	r17,4(sp)
 8202f78:	dc000015 	stw	r16,0(sp)
 8202f7c:	00c003c4 	movi	r3,15
 8202f80:	2005883a 	mov	r2,r4
 8202f84:	1980452e 	bgeu	r3,r6,820309c <memcpy+0x130>
 8202f88:	2906b03a 	or	r3,r5,r4
 8202f8c:	18c000cc 	andi	r3,r3,3
 8202f90:	1800441e 	bne	r3,zero,82030a4 <memcpy+0x138>
 8202f94:	347ffc04 	addi	r17,r6,-16
 8202f98:	8822d13a 	srli	r17,r17,4
 8202f9c:	28c00104 	addi	r3,r5,4
 8202fa0:	23400104 	addi	r13,r4,4
 8202fa4:	8820913a 	slli	r16,r17,4
 8202fa8:	2b000204 	addi	r12,r5,8
 8202fac:	22c00204 	addi	r11,r4,8
 8202fb0:	84000504 	addi	r16,r16,20
 8202fb4:	2a800304 	addi	r10,r5,12
 8202fb8:	22400304 	addi	r9,r4,12
 8202fbc:	2c21883a 	add	r16,r5,r16
 8202fc0:	2811883a 	mov	r8,r5
 8202fc4:	200f883a 	mov	r7,r4
 8202fc8:	41000017 	ldw	r4,0(r8)
 8202fcc:	1fc00017 	ldw	ra,0(r3)
 8202fd0:	63c00017 	ldw	r15,0(r12)
 8202fd4:	39000015 	stw	r4,0(r7)
 8202fd8:	53800017 	ldw	r14,0(r10)
 8202fdc:	6fc00015 	stw	ra,0(r13)
 8202fe0:	5bc00015 	stw	r15,0(r11)
 8202fe4:	4b800015 	stw	r14,0(r9)
 8202fe8:	18c00404 	addi	r3,r3,16
 8202fec:	39c00404 	addi	r7,r7,16
 8202ff0:	42000404 	addi	r8,r8,16
 8202ff4:	6b400404 	addi	r13,r13,16
 8202ff8:	63000404 	addi	r12,r12,16
 8202ffc:	5ac00404 	addi	r11,r11,16
 8203000:	52800404 	addi	r10,r10,16
 8203004:	4a400404 	addi	r9,r9,16
 8203008:	1c3fef1e 	bne	r3,r16,8202fc8 <memcpy+0x5c>
 820300c:	89c00044 	addi	r7,r17,1
 8203010:	380e913a 	slli	r7,r7,4
 8203014:	310003cc 	andi	r4,r6,15
 8203018:	02c000c4 	movi	r11,3
 820301c:	11c7883a 	add	r3,r2,r7
 8203020:	29cb883a 	add	r5,r5,r7
 8203024:	5900212e 	bgeu	r11,r4,82030ac <memcpy+0x140>
 8203028:	1813883a 	mov	r9,r3
 820302c:	2811883a 	mov	r8,r5
 8203030:	200f883a 	mov	r7,r4
 8203034:	42800017 	ldw	r10,0(r8)
 8203038:	4a400104 	addi	r9,r9,4
 820303c:	39ffff04 	addi	r7,r7,-4
 8203040:	4abfff15 	stw	r10,-4(r9)
 8203044:	42000104 	addi	r8,r8,4
 8203048:	59fffa36 	bltu	r11,r7,8203034 <memcpy+0xc8>
 820304c:	213fff04 	addi	r4,r4,-4
 8203050:	2008d0ba 	srli	r4,r4,2
 8203054:	318000cc 	andi	r6,r6,3
 8203058:	21000044 	addi	r4,r4,1
 820305c:	2109883a 	add	r4,r4,r4
 8203060:	2109883a 	add	r4,r4,r4
 8203064:	1907883a 	add	r3,r3,r4
 8203068:	290b883a 	add	r5,r5,r4
 820306c:	30000626 	beq	r6,zero,8203088 <memcpy+0x11c>
 8203070:	198d883a 	add	r6,r3,r6
 8203074:	29c00003 	ldbu	r7,0(r5)
 8203078:	18c00044 	addi	r3,r3,1
 820307c:	29400044 	addi	r5,r5,1
 8203080:	19ffffc5 	stb	r7,-1(r3)
 8203084:	19bffb1e 	bne	r3,r6,8203074 <memcpy+0x108>
 8203088:	dfc00217 	ldw	ra,8(sp)
 820308c:	dc400117 	ldw	r17,4(sp)
 8203090:	dc000017 	ldw	r16,0(sp)
 8203094:	dec00304 	addi	sp,sp,12
 8203098:	f800283a 	ret
 820309c:	2007883a 	mov	r3,r4
 82030a0:	003ff206 	br	820306c <memcpy+0x100>
 82030a4:	2007883a 	mov	r3,r4
 82030a8:	003ff106 	br	8203070 <memcpy+0x104>
 82030ac:	200d883a 	mov	r6,r4
 82030b0:	003fee06 	br	820306c <memcpy+0x100>

082030b4 <memmove>:
 82030b4:	2005883a 	mov	r2,r4
 82030b8:	29000b2e 	bgeu	r5,r4,82030e8 <memmove+0x34>
 82030bc:	298f883a 	add	r7,r5,r6
 82030c0:	21c0092e 	bgeu	r4,r7,82030e8 <memmove+0x34>
 82030c4:	2187883a 	add	r3,r4,r6
 82030c8:	198bc83a 	sub	r5,r3,r6
 82030cc:	30004826 	beq	r6,zero,82031f0 <memmove+0x13c>
 82030d0:	39ffffc4 	addi	r7,r7,-1
 82030d4:	39000003 	ldbu	r4,0(r7)
 82030d8:	18ffffc4 	addi	r3,r3,-1
 82030dc:	19000005 	stb	r4,0(r3)
 82030e0:	28fffb1e 	bne	r5,r3,82030d0 <memmove+0x1c>
 82030e4:	f800283a 	ret
 82030e8:	00c003c4 	movi	r3,15
 82030ec:	1980412e 	bgeu	r3,r6,82031f4 <memmove+0x140>
 82030f0:	2886b03a 	or	r3,r5,r2
 82030f4:	18c000cc 	andi	r3,r3,3
 82030f8:	1800401e 	bne	r3,zero,82031fc <memmove+0x148>
 82030fc:	33fffc04 	addi	r15,r6,-16
 8203100:	781ed13a 	srli	r15,r15,4
 8203104:	28c00104 	addi	r3,r5,4
 8203108:	13400104 	addi	r13,r2,4
 820310c:	781c913a 	slli	r14,r15,4
 8203110:	2b000204 	addi	r12,r5,8
 8203114:	12c00204 	addi	r11,r2,8
 8203118:	73800504 	addi	r14,r14,20
 820311c:	2a800304 	addi	r10,r5,12
 8203120:	12400304 	addi	r9,r2,12
 8203124:	2b9d883a 	add	r14,r5,r14
 8203128:	2811883a 	mov	r8,r5
 820312c:	100f883a 	mov	r7,r2
 8203130:	41000017 	ldw	r4,0(r8)
 8203134:	39c00404 	addi	r7,r7,16
 8203138:	18c00404 	addi	r3,r3,16
 820313c:	393ffc15 	stw	r4,-16(r7)
 8203140:	193ffc17 	ldw	r4,-16(r3)
 8203144:	6b400404 	addi	r13,r13,16
 8203148:	5ac00404 	addi	r11,r11,16
 820314c:	693ffc15 	stw	r4,-16(r13)
 8203150:	61000017 	ldw	r4,0(r12)
 8203154:	4a400404 	addi	r9,r9,16
 8203158:	42000404 	addi	r8,r8,16
 820315c:	593ffc15 	stw	r4,-16(r11)
 8203160:	51000017 	ldw	r4,0(r10)
 8203164:	63000404 	addi	r12,r12,16
 8203168:	52800404 	addi	r10,r10,16
 820316c:	493ffc15 	stw	r4,-16(r9)
 8203170:	1bbfef1e 	bne	r3,r14,8203130 <memmove+0x7c>
 8203174:	79000044 	addi	r4,r15,1
 8203178:	2008913a 	slli	r4,r4,4
 820317c:	328003cc 	andi	r10,r6,15
 8203180:	02c000c4 	movi	r11,3
 8203184:	1107883a 	add	r3,r2,r4
 8203188:	290b883a 	add	r5,r5,r4
 820318c:	5a801e2e 	bgeu	r11,r10,8203208 <memmove+0x154>
 8203190:	1813883a 	mov	r9,r3
 8203194:	2811883a 	mov	r8,r5
 8203198:	500f883a 	mov	r7,r10
 820319c:	41000017 	ldw	r4,0(r8)
 82031a0:	4a400104 	addi	r9,r9,4
 82031a4:	39ffff04 	addi	r7,r7,-4
 82031a8:	493fff15 	stw	r4,-4(r9)
 82031ac:	42000104 	addi	r8,r8,4
 82031b0:	59fffa36 	bltu	r11,r7,820319c <memmove+0xe8>
 82031b4:	513fff04 	addi	r4,r10,-4
 82031b8:	2008d0ba 	srli	r4,r4,2
 82031bc:	318000cc 	andi	r6,r6,3
 82031c0:	21000044 	addi	r4,r4,1
 82031c4:	2109883a 	add	r4,r4,r4
 82031c8:	2109883a 	add	r4,r4,r4
 82031cc:	1907883a 	add	r3,r3,r4
 82031d0:	290b883a 	add	r5,r5,r4
 82031d4:	30000b26 	beq	r6,zero,8203204 <memmove+0x150>
 82031d8:	198d883a 	add	r6,r3,r6
 82031dc:	29c00003 	ldbu	r7,0(r5)
 82031e0:	18c00044 	addi	r3,r3,1
 82031e4:	29400044 	addi	r5,r5,1
 82031e8:	19ffffc5 	stb	r7,-1(r3)
 82031ec:	19bffb1e 	bne	r3,r6,82031dc <memmove+0x128>
 82031f0:	f800283a 	ret
 82031f4:	1007883a 	mov	r3,r2
 82031f8:	003ff606 	br	82031d4 <memmove+0x120>
 82031fc:	1007883a 	mov	r3,r2
 8203200:	003ff506 	br	82031d8 <memmove+0x124>
 8203204:	f800283a 	ret
 8203208:	500d883a 	mov	r6,r10
 820320c:	003ff106 	br	82031d4 <memmove+0x120>

08203210 <memset>:
 8203210:	20c000cc 	andi	r3,r4,3
 8203214:	2005883a 	mov	r2,r4
 8203218:	18004426 	beq	r3,zero,820332c <memset+0x11c>
 820321c:	31ffffc4 	addi	r7,r6,-1
 8203220:	30004026 	beq	r6,zero,8203324 <memset+0x114>
 8203224:	2813883a 	mov	r9,r5
 8203228:	200d883a 	mov	r6,r4
 820322c:	2007883a 	mov	r3,r4
 8203230:	00000406 	br	8203244 <memset+0x34>
 8203234:	3a3fffc4 	addi	r8,r7,-1
 8203238:	31800044 	addi	r6,r6,1
 820323c:	38003926 	beq	r7,zero,8203324 <memset+0x114>
 8203240:	400f883a 	mov	r7,r8
 8203244:	18c00044 	addi	r3,r3,1
 8203248:	32400005 	stb	r9,0(r6)
 820324c:	1a0000cc 	andi	r8,r3,3
 8203250:	403ff81e 	bne	r8,zero,8203234 <memset+0x24>
 8203254:	010000c4 	movi	r4,3
 8203258:	21c02d2e 	bgeu	r4,r7,8203310 <memset+0x100>
 820325c:	29003fcc 	andi	r4,r5,255
 8203260:	200c923a 	slli	r6,r4,8
 8203264:	3108b03a 	or	r4,r6,r4
 8203268:	200c943a 	slli	r6,r4,16
 820326c:	218cb03a 	or	r6,r4,r6
 8203270:	010003c4 	movi	r4,15
 8203274:	21c0182e 	bgeu	r4,r7,82032d8 <memset+0xc8>
 8203278:	3b3ffc04 	addi	r12,r7,-16
 820327c:	6018d13a 	srli	r12,r12,4
 8203280:	1a000104 	addi	r8,r3,4
 8203284:	1ac00204 	addi	r11,r3,8
 8203288:	6008913a 	slli	r4,r12,4
 820328c:	1a800304 	addi	r10,r3,12
 8203290:	1813883a 	mov	r9,r3
 8203294:	21000504 	addi	r4,r4,20
 8203298:	1909883a 	add	r4,r3,r4
 820329c:	49800015 	stw	r6,0(r9)
 82032a0:	41800015 	stw	r6,0(r8)
 82032a4:	59800015 	stw	r6,0(r11)
 82032a8:	51800015 	stw	r6,0(r10)
 82032ac:	42000404 	addi	r8,r8,16
 82032b0:	4a400404 	addi	r9,r9,16
 82032b4:	5ac00404 	addi	r11,r11,16
 82032b8:	52800404 	addi	r10,r10,16
 82032bc:	413ff71e 	bne	r8,r4,820329c <memset+0x8c>
 82032c0:	63000044 	addi	r12,r12,1
 82032c4:	6018913a 	slli	r12,r12,4
 82032c8:	39c003cc 	andi	r7,r7,15
 82032cc:	010000c4 	movi	r4,3
 82032d0:	1b07883a 	add	r3,r3,r12
 82032d4:	21c00e2e 	bgeu	r4,r7,8203310 <memset+0x100>
 82032d8:	1813883a 	mov	r9,r3
 82032dc:	3811883a 	mov	r8,r7
 82032e0:	010000c4 	movi	r4,3
 82032e4:	49800015 	stw	r6,0(r9)
 82032e8:	423fff04 	addi	r8,r8,-4
 82032ec:	4a400104 	addi	r9,r9,4
 82032f0:	223ffc36 	bltu	r4,r8,82032e4 <memset+0xd4>
 82032f4:	393fff04 	addi	r4,r7,-4
 82032f8:	2008d0ba 	srli	r4,r4,2
 82032fc:	39c000cc 	andi	r7,r7,3
 8203300:	21000044 	addi	r4,r4,1
 8203304:	2109883a 	add	r4,r4,r4
 8203308:	2109883a 	add	r4,r4,r4
 820330c:	1907883a 	add	r3,r3,r4
 8203310:	38000526 	beq	r7,zero,8203328 <memset+0x118>
 8203314:	19cf883a 	add	r7,r3,r7
 8203318:	19400005 	stb	r5,0(r3)
 820331c:	18c00044 	addi	r3,r3,1
 8203320:	38fffd1e 	bne	r7,r3,8203318 <memset+0x108>
 8203324:	f800283a 	ret
 8203328:	f800283a 	ret
 820332c:	2007883a 	mov	r3,r4
 8203330:	300f883a 	mov	r7,r6
 8203334:	003fc706 	br	8203254 <memset+0x44>

08203338 <_perror_r>:
 8203338:	defffd04 	addi	sp,sp,-12
 820333c:	dc000115 	stw	r16,4(sp)
 8203340:	dfc00215 	stw	ra,8(sp)
 8203344:	2021883a 	mov	r16,r4
 8203348:	28000326 	beq	r5,zero,8203358 <_perror_r+0x20>
 820334c:	28c00007 	ldb	r3,0(r5)
 8203350:	2805883a 	mov	r2,r5
 8203354:	1800101e 	bne	r3,zero,8203398 <_perror_r+0x60>
 8203358:	81400017 	ldw	r5,0(r16)
 820335c:	d80f883a 	mov	r7,sp
 8203360:	01800044 	movi	r6,1
 8203364:	8009883a 	mov	r4,r16
 8203368:	82039440 	call	8203944 <_strerror_r>
 820336c:	10000326 	beq	r2,zero,820337c <_perror_r+0x44>
 8203370:	81400317 	ldw	r5,12(r16)
 8203374:	1009883a 	mov	r4,r2
 8203378:	820b0200 	call	820b020 <fputs>
 820337c:	81400317 	ldw	r5,12(r16)
 8203380:	01000284 	movi	r4,10
 8203384:	820af280 	call	820af28 <fputc>
 8203388:	dfc00217 	ldw	ra,8(sp)
 820338c:	dc000117 	ldw	r16,4(sp)
 8203390:	dec00304 	addi	sp,sp,12
 8203394:	f800283a 	ret
 8203398:	21400317 	ldw	r5,12(r4)
 820339c:	1009883a 	mov	r4,r2
 82033a0:	820b0200 	call	820b020 <fputs>
 82033a4:	81400317 	ldw	r5,12(r16)
 82033a8:	01020974 	movhi	r4,2085
 82033ac:	21351a04 	addi	r4,r4,-11160
 82033b0:	820b0200 	call	820b020 <fputs>
 82033b4:	003fe806 	br	8203358 <_perror_r+0x20>

082033b8 <perror>:
 82033b8:	00820974 	movhi	r2,2085
 82033bc:	108fbb04 	addi	r2,r2,16108
 82033c0:	200b883a 	mov	r5,r4
 82033c4:	11000017 	ldw	r4,0(r2)
 82033c8:	82033381 	jmpi	8203338 <_perror_r>

082033cc <_printf_r>:
 82033cc:	defffd04 	addi	sp,sp,-12
 82033d0:	2805883a 	mov	r2,r5
 82033d4:	dfc00015 	stw	ra,0(sp)
 82033d8:	d9800115 	stw	r6,4(sp)
 82033dc:	d9c00215 	stw	r7,8(sp)
 82033e0:	21400217 	ldw	r5,8(r4)
 82033e4:	d9c00104 	addi	r7,sp,4
 82033e8:	100d883a 	mov	r6,r2
 82033ec:	8206a980 	call	8206a98 <___vfprintf_internal_r>
 82033f0:	dfc00017 	ldw	ra,0(sp)
 82033f4:	dec00304 	addi	sp,sp,12
 82033f8:	f800283a 	ret

082033fc <printf>:
 82033fc:	defffc04 	addi	sp,sp,-16
 8203400:	dfc00015 	stw	ra,0(sp)
 8203404:	d9400115 	stw	r5,4(sp)
 8203408:	d9800215 	stw	r6,8(sp)
 820340c:	d9c00315 	stw	r7,12(sp)
 8203410:	00820974 	movhi	r2,2085
 8203414:	108fbb04 	addi	r2,r2,16108
 8203418:	10800017 	ldw	r2,0(r2)
 820341c:	200b883a 	mov	r5,r4
 8203420:	d9800104 	addi	r6,sp,4
 8203424:	11000217 	ldw	r4,8(r2)
 8203428:	8208c900 	call	8208c90 <__vfprintf_internal>
 820342c:	dfc00017 	ldw	ra,0(sp)
 8203430:	dec00404 	addi	sp,sp,16
 8203434:	f800283a 	ret

08203438 <_putc_r>:
 8203438:	defffc04 	addi	sp,sp,-16
 820343c:	dc000215 	stw	r16,8(sp)
 8203440:	dfc00315 	stw	ra,12(sp)
 8203444:	2021883a 	mov	r16,r4
 8203448:	20000226 	beq	r4,zero,8203454 <_putc_r+0x1c>
 820344c:	20800e17 	ldw	r2,56(r4)
 8203450:	10001b26 	beq	r2,zero,82034c0 <_putc_r+0x88>
 8203454:	30800217 	ldw	r2,8(r6)
 8203458:	10bfffc4 	addi	r2,r2,-1
 820345c:	30800215 	stw	r2,8(r6)
 8203460:	10000a16 	blt	r2,zero,820348c <_putc_r+0x54>
 8203464:	30800017 	ldw	r2,0(r6)
 8203468:	11400005 	stb	r5,0(r2)
 820346c:	30800017 	ldw	r2,0(r6)
 8203470:	10c00044 	addi	r3,r2,1
 8203474:	30c00015 	stw	r3,0(r6)
 8203478:	10800003 	ldbu	r2,0(r2)
 820347c:	dfc00317 	ldw	ra,12(sp)
 8203480:	dc000217 	ldw	r16,8(sp)
 8203484:	dec00404 	addi	sp,sp,16
 8203488:	f800283a 	ret
 820348c:	30c00617 	ldw	r3,24(r6)
 8203490:	10c00616 	blt	r2,r3,82034ac <_putc_r+0x74>
 8203494:	30800017 	ldw	r2,0(r6)
 8203498:	00c00284 	movi	r3,10
 820349c:	11400005 	stb	r5,0(r2)
 82034a0:	30800017 	ldw	r2,0(r6)
 82034a4:	11400003 	ldbu	r5,0(r2)
 82034a8:	28fff11e 	bne	r5,r3,8203470 <_putc_r+0x38>
 82034ac:	8009883a 	mov	r4,r16
 82034b0:	dfc00317 	ldw	ra,12(sp)
 82034b4:	dc000217 	ldw	r16,8(sp)
 82034b8:	dec00404 	addi	sp,sp,16
 82034bc:	8208d681 	jmpi	8208d68 <__swbuf_r>
 82034c0:	d9400015 	stw	r5,0(sp)
 82034c4:	d9800115 	stw	r6,4(sp)
 82034c8:	820ae940 	call	820ae94 <__sinit>
 82034cc:	d9800117 	ldw	r6,4(sp)
 82034d0:	d9400017 	ldw	r5,0(sp)
 82034d4:	003fdf06 	br	8203454 <_putc_r+0x1c>

082034d8 <putc>:
 82034d8:	00820974 	movhi	r2,2085
 82034dc:	defffc04 	addi	sp,sp,-16
 82034e0:	108fbb04 	addi	r2,r2,16108
 82034e4:	dc000115 	stw	r16,4(sp)
 82034e8:	14000017 	ldw	r16,0(r2)
 82034ec:	dc400215 	stw	r17,8(sp)
 82034f0:	dfc00315 	stw	ra,12(sp)
 82034f4:	2023883a 	mov	r17,r4
 82034f8:	80000226 	beq	r16,zero,8203504 <putc+0x2c>
 82034fc:	80800e17 	ldw	r2,56(r16)
 8203500:	10001a26 	beq	r2,zero,820356c <putc+0x94>
 8203504:	28800217 	ldw	r2,8(r5)
 8203508:	10bfffc4 	addi	r2,r2,-1
 820350c:	28800215 	stw	r2,8(r5)
 8203510:	10000b16 	blt	r2,zero,8203540 <putc+0x68>
 8203514:	28800017 	ldw	r2,0(r5)
 8203518:	14400005 	stb	r17,0(r2)
 820351c:	28800017 	ldw	r2,0(r5)
 8203520:	10c00044 	addi	r3,r2,1
 8203524:	28c00015 	stw	r3,0(r5)
 8203528:	10800003 	ldbu	r2,0(r2)
 820352c:	dfc00317 	ldw	ra,12(sp)
 8203530:	dc400217 	ldw	r17,8(sp)
 8203534:	dc000117 	ldw	r16,4(sp)
 8203538:	dec00404 	addi	sp,sp,16
 820353c:	f800283a 	ret
 8203540:	28c00617 	ldw	r3,24(r5)
 8203544:	10c00e16 	blt	r2,r3,8203580 <putc+0xa8>
 8203548:	28800017 	ldw	r2,0(r5)
 820354c:	01000284 	movi	r4,10
 8203550:	14400005 	stb	r17,0(r2)
 8203554:	28800017 	ldw	r2,0(r5)
 8203558:	10c00003 	ldbu	r3,0(r2)
 820355c:	193ff01e 	bne	r3,r4,8203520 <putc+0x48>
 8203560:	280d883a 	mov	r6,r5
 8203564:	180b883a 	mov	r5,r3
 8203568:	00000706 	br	8203588 <putc+0xb0>
 820356c:	8009883a 	mov	r4,r16
 8203570:	d9400015 	stw	r5,0(sp)
 8203574:	820ae940 	call	820ae94 <__sinit>
 8203578:	d9400017 	ldw	r5,0(sp)
 820357c:	003fe106 	br	8203504 <putc+0x2c>
 8203580:	280d883a 	mov	r6,r5
 8203584:	880b883a 	mov	r5,r17
 8203588:	8009883a 	mov	r4,r16
 820358c:	dfc00317 	ldw	ra,12(sp)
 8203590:	dc400217 	ldw	r17,8(sp)
 8203594:	dc000117 	ldw	r16,4(sp)
 8203598:	dec00404 	addi	sp,sp,16
 820359c:	8208d681 	jmpi	8208d68 <__swbuf_r>

082035a0 <_putchar_r>:
 82035a0:	21800217 	ldw	r6,8(r4)
 82035a4:	82034381 	jmpi	8203438 <_putc_r>

082035a8 <putchar>:
 82035a8:	00820974 	movhi	r2,2085
 82035ac:	108fbb04 	addi	r2,r2,16108
 82035b0:	200b883a 	mov	r5,r4
 82035b4:	11000017 	ldw	r4,0(r2)
 82035b8:	21800217 	ldw	r6,8(r4)
 82035bc:	82034381 	jmpi	8203438 <_putc_r>

082035c0 <_puts_r>:
 82035c0:	defff604 	addi	sp,sp,-40
 82035c4:	dc000715 	stw	r16,28(sp)
 82035c8:	2021883a 	mov	r16,r4
 82035cc:	2809883a 	mov	r4,r5
 82035d0:	dc400815 	stw	r17,32(sp)
 82035d4:	dfc00915 	stw	ra,36(sp)
 82035d8:	2823883a 	mov	r17,r5
 82035dc:	8203fbc0 	call	8203fbc <strlen>
 82035e0:	10c00044 	addi	r3,r2,1
 82035e4:	d8800115 	stw	r2,4(sp)
 82035e8:	00820974 	movhi	r2,2085
 82035ec:	10b51b04 	addi	r2,r2,-11156
 82035f0:	d8800215 	stw	r2,8(sp)
 82035f4:	00800044 	movi	r2,1
 82035f8:	d8800315 	stw	r2,12(sp)
 82035fc:	00800084 	movi	r2,2
 8203600:	dc400015 	stw	r17,0(sp)
 8203604:	d8c00615 	stw	r3,24(sp)
 8203608:	dec00415 	stw	sp,16(sp)
 820360c:	d8800515 	stw	r2,20(sp)
 8203610:	80000226 	beq	r16,zero,820361c <_puts_r+0x5c>
 8203614:	80800e17 	ldw	r2,56(r16)
 8203618:	10001426 	beq	r2,zero,820366c <_puts_r+0xac>
 820361c:	81400217 	ldw	r5,8(r16)
 8203620:	2880030b 	ldhu	r2,12(r5)
 8203624:	10c8000c 	andi	r3,r2,8192
 8203628:	1800061e 	bne	r3,zero,8203644 <_puts_r+0x84>
 820362c:	29001917 	ldw	r4,100(r5)
 8203630:	00f7ffc4 	movi	r3,-8193
 8203634:	10880014 	ori	r2,r2,8192
 8203638:	20c6703a 	and	r3,r4,r3
 820363c:	2880030d 	sth	r2,12(r5)
 8203640:	28c01915 	stw	r3,100(r5)
 8203644:	d9800404 	addi	r6,sp,16
 8203648:	8009883a 	mov	r4,r16
 820364c:	820b46c0 	call	820b46c <__sfvwrite_r>
 8203650:	1000091e 	bne	r2,zero,8203678 <_puts_r+0xb8>
 8203654:	00800284 	movi	r2,10
 8203658:	dfc00917 	ldw	ra,36(sp)
 820365c:	dc400817 	ldw	r17,32(sp)
 8203660:	dc000717 	ldw	r16,28(sp)
 8203664:	dec00a04 	addi	sp,sp,40
 8203668:	f800283a 	ret
 820366c:	8009883a 	mov	r4,r16
 8203670:	820ae940 	call	820ae94 <__sinit>
 8203674:	003fe906 	br	820361c <_puts_r+0x5c>
 8203678:	00bfffc4 	movi	r2,-1
 820367c:	003ff606 	br	8203658 <_puts_r+0x98>

08203680 <puts>:
 8203680:	00820974 	movhi	r2,2085
 8203684:	108fbb04 	addi	r2,r2,16108
 8203688:	200b883a 	mov	r5,r4
 820368c:	11000017 	ldw	r4,0(r2)
 8203690:	82035c01 	jmpi	82035c0 <_puts_r>

08203694 <__srget_r>:
 8203694:	defffd04 	addi	sp,sp,-12
 8203698:	dc400115 	stw	r17,4(sp)
 820369c:	dc000015 	stw	r16,0(sp)
 82036a0:	dfc00215 	stw	ra,8(sp)
 82036a4:	2023883a 	mov	r17,r4
 82036a8:	2821883a 	mov	r16,r5
 82036ac:	20000226 	beq	r4,zero,82036b8 <__srget_r+0x24>
 82036b0:	20800e17 	ldw	r2,56(r4)
 82036b4:	10001026 	beq	r2,zero,82036f8 <__srget_r+0x64>
 82036b8:	800b883a 	mov	r5,r16
 82036bc:	8809883a 	mov	r4,r17
 82036c0:	820dc300 	call	820dc30 <__srefill_r>
 82036c4:	10000e1e 	bne	r2,zero,8203700 <__srget_r+0x6c>
 82036c8:	80c00017 	ldw	r3,0(r16)
 82036cc:	80800117 	ldw	r2,4(r16)
 82036d0:	19000044 	addi	r4,r3,1
 82036d4:	10bfffc4 	addi	r2,r2,-1
 82036d8:	80800115 	stw	r2,4(r16)
 82036dc:	81000015 	stw	r4,0(r16)
 82036e0:	18800003 	ldbu	r2,0(r3)
 82036e4:	dfc00217 	ldw	ra,8(sp)
 82036e8:	dc400117 	ldw	r17,4(sp)
 82036ec:	dc000017 	ldw	r16,0(sp)
 82036f0:	dec00304 	addi	sp,sp,12
 82036f4:	f800283a 	ret
 82036f8:	820ae940 	call	820ae94 <__sinit>
 82036fc:	003fee06 	br	82036b8 <__srget_r+0x24>
 8203700:	00bfffc4 	movi	r2,-1
 8203704:	003ff706 	br	82036e4 <__srget_r+0x50>

08203708 <__srget>:
 8203708:	00820974 	movhi	r2,2085
 820370c:	108fbb04 	addi	r2,r2,16108
 8203710:	200b883a 	mov	r5,r4
 8203714:	11000017 	ldw	r4,0(r2)
 8203718:	82036941 	jmpi	8203694 <__srget_r>

0820371c <_sprintf_r>:
 820371c:	deffe404 	addi	sp,sp,-112
 8203720:	2807883a 	mov	r3,r5
 8203724:	dfc01a15 	stw	ra,104(sp)
 8203728:	d9c01b15 	stw	r7,108(sp)
 820372c:	00a00034 	movhi	r2,32768
 8203730:	10bfffc4 	addi	r2,r2,-1
 8203734:	02008204 	movi	r8,520
 8203738:	d8800215 	stw	r2,8(sp)
 820373c:	d8800515 	stw	r2,20(sp)
 8203740:	d9c01b04 	addi	r7,sp,108
 8203744:	d80b883a 	mov	r5,sp
 8203748:	00bfffc4 	movi	r2,-1
 820374c:	d8c00015 	stw	r3,0(sp)
 8203750:	d8c00415 	stw	r3,16(sp)
 8203754:	da00030d 	sth	r8,12(sp)
 8203758:	d880038d 	sth	r2,14(sp)
 820375c:	82048b80 	call	82048b8 <___svfprintf_internal_r>
 8203760:	d8c00017 	ldw	r3,0(sp)
 8203764:	18000005 	stb	zero,0(r3)
 8203768:	dfc01a17 	ldw	ra,104(sp)
 820376c:	dec01c04 	addi	sp,sp,112
 8203770:	f800283a 	ret

08203774 <sprintf>:
 8203774:	deffe304 	addi	sp,sp,-116
 8203778:	2007883a 	mov	r3,r4
 820377c:	dfc01a15 	stw	ra,104(sp)
 8203780:	d9801b15 	stw	r6,108(sp)
 8203784:	d9c01c15 	stw	r7,112(sp)
 8203788:	01020974 	movhi	r4,2085
 820378c:	210fbb04 	addi	r4,r4,16108
 8203790:	21000017 	ldw	r4,0(r4)
 8203794:	00a00034 	movhi	r2,32768
 8203798:	10bfffc4 	addi	r2,r2,-1
 820379c:	280d883a 	mov	r6,r5
 82037a0:	02008204 	movi	r8,520
 82037a4:	d8800215 	stw	r2,8(sp)
 82037a8:	d8800515 	stw	r2,20(sp)
 82037ac:	d9c01b04 	addi	r7,sp,108
 82037b0:	d80b883a 	mov	r5,sp
 82037b4:	00bfffc4 	movi	r2,-1
 82037b8:	d8c00015 	stw	r3,0(sp)
 82037bc:	d8c00415 	stw	r3,16(sp)
 82037c0:	da00030d 	sth	r8,12(sp)
 82037c4:	d880038d 	sth	r2,14(sp)
 82037c8:	82048b80 	call	82048b8 <___svfprintf_internal_r>
 82037cc:	d8c00017 	ldw	r3,0(sp)
 82037d0:	18000005 	stb	zero,0(r3)
 82037d4:	dfc01a17 	ldw	ra,104(sp)
 82037d8:	dec01d04 	addi	sp,sp,116
 82037dc:	f800283a 	ret

082037e0 <strchr>:
 82037e0:	2ac03fcc 	andi	r11,r5,255
 82037e4:	2813883a 	mov	r9,r5
 82037e8:	208000cc 	andi	r2,r4,3
 82037ec:	58003726 	beq	r11,zero,82038cc <strchr+0xec>
 82037f0:	10000b26 	beq	r2,zero,8203820 <strchr+0x40>
 82037f4:	20800003 	ldbu	r2,0(r4)
 82037f8:	10003226 	beq	r2,zero,82038c4 <strchr+0xe4>
 82037fc:	28c03fcc 	andi	r3,r5,255
 8203800:	5880041e 	bne	r11,r2,8203814 <strchr+0x34>
 8203804:	00004d06 	br	820393c <strchr+0x15c>
 8203808:	20800003 	ldbu	r2,0(r4)
 820380c:	10002d26 	beq	r2,zero,82038c4 <strchr+0xe4>
 8203810:	18804a26 	beq	r3,r2,820393c <strchr+0x15c>
 8203814:	21000044 	addi	r4,r4,1
 8203818:	208000cc 	andi	r2,r4,3
 820381c:	103ffa1e 	bne	r2,zero,8203808 <strchr+0x28>
 8203820:	29403fcc 	andi	r5,r5,255
 8203824:	2814923a 	slli	r10,r5,8
 8203828:	20800017 	ldw	r2,0(r4)
 820382c:	01bfbff4 	movhi	r6,65279
 8203830:	2a8ab03a 	or	r5,r5,r10
 8203834:	2814943a 	slli	r10,r5,16
 8203838:	31bfbfc4 	addi	r6,r6,-257
 820383c:	119b883a 	add	r13,r2,r6
 8203840:	5154b03a 	or	r10,r10,r5
 8203844:	008e303a 	nor	r7,zero,r2
 8203848:	5084f03a 	xor	r2,r10,r2
 820384c:	1191883a 	add	r8,r2,r6
 8203850:	0086303a 	nor	r3,zero,r2
 8203854:	03202074 	movhi	r12,32897
 8203858:	69ca703a 	and	r5,r13,r7
 820385c:	40c4703a 	and	r2,r8,r3
 8203860:	63202004 	addi	r12,r12,-32640
 8203864:	2884b03a 	or	r2,r5,r2
 8203868:	1304703a 	and	r2,r2,r12
 820386c:	10000c1e 	bne	r2,zero,82038a0 <strchr+0xc0>
 8203870:	21000104 	addi	r4,r4,4
 8203874:	20c00017 	ldw	r3,0(r4)
 8203878:	50c4f03a 	xor	r2,r10,r3
 820387c:	1991883a 	add	r8,r3,r6
 8203880:	00ca303a 	nor	r5,zero,r3
 8203884:	118f883a 	add	r7,r2,r6
 8203888:	0086303a 	nor	r3,zero,r2
 820388c:	414a703a 	and	r5,r8,r5
 8203890:	38c4703a 	and	r2,r7,r3
 8203894:	2884b03a 	or	r2,r5,r2
 8203898:	1304703a 	and	r2,r2,r12
 820389c:	103ff426 	beq	r2,zero,8203870 <strchr+0x90>
 82038a0:	20800003 	ldbu	r2,0(r4)
 82038a4:	10000726 	beq	r2,zero,82038c4 <strchr+0xe4>
 82038a8:	58802426 	beq	r11,r2,820393c <strchr+0x15c>
 82038ac:	48c03fcc 	andi	r3,r9,255
 82038b0:	00000106 	br	82038b8 <strchr+0xd8>
 82038b4:	18802126 	beq	r3,r2,820393c <strchr+0x15c>
 82038b8:	21000044 	addi	r4,r4,1
 82038bc:	20800003 	ldbu	r2,0(r4)
 82038c0:	103ffc1e 	bne	r2,zero,82038b4 <strchr+0xd4>
 82038c4:	0005883a 	mov	r2,zero
 82038c8:	f800283a 	ret
 82038cc:	10000526 	beq	r2,zero,82038e4 <strchr+0x104>
 82038d0:	20800003 	ldbu	r2,0(r4)
 82038d4:	10001926 	beq	r2,zero,820393c <strchr+0x15c>
 82038d8:	21000044 	addi	r4,r4,1
 82038dc:	208000cc 	andi	r2,r4,3
 82038e0:	103ffb1e 	bne	r2,zero,82038d0 <strchr+0xf0>
 82038e4:	20800017 	ldw	r2,0(r4)
 82038e8:	01bfbff4 	movhi	r6,65279
 82038ec:	31bfbfc4 	addi	r6,r6,-257
 82038f0:	0086303a 	nor	r3,zero,r2
 82038f4:	01602074 	movhi	r5,32897
 82038f8:	1185883a 	add	r2,r2,r6
 82038fc:	29602004 	addi	r5,r5,-32640
 8203900:	10c4703a 	and	r2,r2,r3
 8203904:	1144703a 	and	r2,r2,r5
 8203908:	1000071e 	bne	r2,zero,8203928 <strchr+0x148>
 820390c:	21000104 	addi	r4,r4,4
 8203910:	20800017 	ldw	r2,0(r4)
 8203914:	1187883a 	add	r3,r2,r6
 8203918:	0084303a 	nor	r2,zero,r2
 820391c:	1884703a 	and	r2,r3,r2
 8203920:	1144703a 	and	r2,r2,r5
 8203924:	103ff926 	beq	r2,zero,820390c <strchr+0x12c>
 8203928:	20800003 	ldbu	r2,0(r4)
 820392c:	10000326 	beq	r2,zero,820393c <strchr+0x15c>
 8203930:	21000044 	addi	r4,r4,1
 8203934:	20800003 	ldbu	r2,0(r4)
 8203938:	103ffd1e 	bne	r2,zero,8203930 <strchr+0x150>
 820393c:	2005883a 	mov	r2,r4
 8203940:	f800283a 	ret

08203944 <_strerror_r>:
 8203944:	deffff04 	addi	sp,sp,-4
 8203948:	2807883a 	mov	r3,r5
 820394c:	dfc00015 	stw	ra,0(sp)
 8203950:	00802384 	movi	r2,142
 8203954:	300b883a 	mov	r5,r6
 8203958:	10c18736 	bltu	r2,r3,8203f78 <_strerror_r+0x634>
 820395c:	181090ba 	slli	r8,r3,2
 8203960:	00820834 	movhi	r2,2080
 8203964:	108e5d04 	addi	r2,r2,14708
 8203968:	4085883a 	add	r2,r8,r2
 820396c:	10800017 	ldw	r2,0(r2)
 8203970:	1000683a 	jmp	r2
 8203974:	08203bb0 	cmpltui	zero,at,33006
 8203978:	08203f6c 	andhi	zero,at,33021
 820397c:	08203f60 	cmpeqi	zero,at,-32515
 8203980:	08203f54 	ori	zero,at,33021
 8203984:	08203f48 	cmpgei	zero,at,-32515
 8203988:	08203f3c 	xorhi	zero,at,33020
 820398c:	08203f30 	cmpltui	zero,at,33020
 8203990:	08203f24 	muli	zero,at,-32516
 8203994:	08203f18 	cmpnei	zero,at,-32516
 8203998:	08203f0c 	andi	zero,at,33020
 820399c:	08203f00 	call	8203f0 <OSCtxSw_SWITCH_PC+0x8203b0>
 82039a0:	08203ef4 	orhi	zero,at,33019
 82039a4:	08203ee8 	cmpgeui	zero,at,33019
 82039a8:	08203edc 	xori	zero,at,33019
 82039ac:	08203ed0 	cmplti	zero,at,-32517
 82039b0:	08203f78 	rdprs	zero,at,-32515
 82039b4:	08203ec4 	addi	zero,at,-32517
 82039b8:	08203eb8 	rdprs	zero,at,-32518
 82039bc:	08203eac 	andhi	zero,at,33018
 82039c0:	08203ea0 	cmpeqi	zero,at,-32518
 82039c4:	08203e94 	ori	zero,at,33018
 82039c8:	08203e88 	cmpgei	zero,at,-32518
 82039cc:	08203e7c 	xorhi	zero,at,33017
 82039d0:	08203e70 	cmpltui	zero,at,33017
 82039d4:	08203e64 	muli	zero,at,-32519
 82039d8:	08203e58 	cmpnei	zero,at,-32519
 82039dc:	08203e4c 	andi	zero,at,33017
 82039e0:	08203e40 	call	8203e4 <OSCtxSw_SWITCH_PC+0x8203a4>
 82039e4:	08203e34 	orhi	zero,at,33016
 82039e8:	08203e28 	cmpgeui	zero,at,33016
 82039ec:	08203e1c 	xori	zero,at,33016
 82039f0:	08203e10 	cmplti	zero,at,-32520
 82039f4:	08203e04 	addi	zero,at,-32520
 82039f8:	08203df8 	rdprs	zero,at,-32521
 82039fc:	08203dec 	andhi	zero,at,33015
 8203a00:	08203de0 	cmpeqi	zero,at,-32521
 8203a04:	08203dd4 	ori	zero,at,33015
 8203a08:	08203f78 	rdprs	zero,at,-32515
 8203a0c:	08203f78 	rdprs	zero,at,-32515
 8203a10:	08203f78 	rdprs	zero,at,-32515
 8203a14:	08203f78 	rdprs	zero,at,-32515
 8203a18:	08203f78 	rdprs	zero,at,-32515
 8203a1c:	08203f78 	rdprs	zero,at,-32515
 8203a20:	08203f78 	rdprs	zero,at,-32515
 8203a24:	08203f78 	rdprs	zero,at,-32515
 8203a28:	08203dc8 	cmpgei	zero,at,-32521
 8203a2c:	08203dbc 	xorhi	zero,at,33014
 8203a30:	08203f78 	rdprs	zero,at,-32515
 8203a34:	08203f78 	rdprs	zero,at,-32515
 8203a38:	08203f78 	rdprs	zero,at,-32515
 8203a3c:	08203f78 	rdprs	zero,at,-32515
 8203a40:	08203f78 	rdprs	zero,at,-32515
 8203a44:	08203f78 	rdprs	zero,at,-32515
 8203a48:	08203f78 	rdprs	zero,at,-32515
 8203a4c:	08203f78 	rdprs	zero,at,-32515
 8203a50:	08203f78 	rdprs	zero,at,-32515
 8203a54:	08203f78 	rdprs	zero,at,-32515
 8203a58:	08203f78 	rdprs	zero,at,-32515
 8203a5c:	08203f78 	rdprs	zero,at,-32515
 8203a60:	08203f78 	rdprs	zero,at,-32515
 8203a64:	08203db0 	cmpltui	zero,at,33014
 8203a68:	08203da4 	muli	zero,at,-32522
 8203a6c:	08203d98 	cmpnei	zero,at,-32522
 8203a70:	08203d8c 	andi	zero,at,33014
 8203a74:	08203f78 	rdprs	zero,at,-32515
 8203a78:	08203f78 	rdprs	zero,at,-32515
 8203a7c:	08203f78 	rdprs	zero,at,-32515
 8203a80:	08203d80 	call	8203d8 <OSCtxSw_SWITCH_PC+0x820398>
 8203a84:	08203f78 	rdprs	zero,at,-32515
 8203a88:	08203f78 	rdprs	zero,at,-32515
 8203a8c:	08203f78 	rdprs	zero,at,-32515
 8203a90:	08203d74 	orhi	zero,at,33013
 8203a94:	08203f78 	rdprs	zero,at,-32515
 8203a98:	08203f78 	rdprs	zero,at,-32515
 8203a9c:	08203d68 	cmpgeui	zero,at,33013
 8203aa0:	08203f78 	rdprs	zero,at,-32515
 8203aa4:	08203f78 	rdprs	zero,at,-32515
 8203aa8:	08203d5c 	xori	zero,at,33013
 8203aac:	08203f78 	rdprs	zero,at,-32515
 8203ab0:	08203f78 	rdprs	zero,at,-32515
 8203ab4:	08203f78 	rdprs	zero,at,-32515
 8203ab8:	08203f78 	rdprs	zero,at,-32515
 8203abc:	08203f78 	rdprs	zero,at,-32515
 8203ac0:	08203f78 	rdprs	zero,at,-32515
 8203ac4:	08203f78 	rdprs	zero,at,-32515
 8203ac8:	08203f78 	rdprs	zero,at,-32515
 8203acc:	08203f78 	rdprs	zero,at,-32515
 8203ad0:	08203f78 	rdprs	zero,at,-32515
 8203ad4:	08203d50 	cmplti	zero,at,-32523
 8203ad8:	08203f78 	rdprs	zero,at,-32515
 8203adc:	08203d44 	addi	zero,at,-32523
 8203ae0:	08203d38 	rdprs	zero,at,-32524
 8203ae4:	08203d2c 	andhi	zero,at,33012
 8203ae8:	08203f78 	rdprs	zero,at,-32515
 8203aec:	08203f78 	rdprs	zero,at,-32515
 8203af0:	08203d20 	cmpeqi	zero,at,-32524
 8203af4:	08203f78 	rdprs	zero,at,-32515
 8203af8:	08203f78 	rdprs	zero,at,-32515
 8203afc:	08203f78 	rdprs	zero,at,-32515
 8203b00:	08203f78 	rdprs	zero,at,-32515
 8203b04:	08203f78 	rdprs	zero,at,-32515
 8203b08:	08203f78 	rdprs	zero,at,-32515
 8203b0c:	08203f78 	rdprs	zero,at,-32515
 8203b10:	08203f78 	rdprs	zero,at,-32515
 8203b14:	08203d14 	ori	zero,at,33012
 8203b18:	08203d08 	cmpgei	zero,at,-32524
 8203b1c:	08203cfc 	xorhi	zero,at,33011
 8203b20:	08203cf0 	cmpltui	zero,at,33011
 8203b24:	08203ce4 	muli	zero,at,-32525
 8203b28:	08203cd8 	cmpnei	zero,at,-32525
 8203b2c:	08203f78 	rdprs	zero,at,-32515
 8203b30:	08203ccc 	andi	zero,at,33011
 8203b34:	08203cc0 	call	8203cc <OSCtxSw_SWITCH_PC+0x82038c>
 8203b38:	08203cb4 	orhi	zero,at,33010
 8203b3c:	08203ca8 	cmpgeui	zero,at,33010
 8203b40:	08203c9c 	xori	zero,at,33010
 8203b44:	08203c90 	cmplti	zero,at,-32526
 8203b48:	08203c84 	addi	zero,at,-32526
 8203b4c:	08203c78 	rdprs	zero,at,-32527
 8203b50:	08203c6c 	andhi	zero,at,33009
 8203b54:	08203c60 	cmpeqi	zero,at,-32527
 8203b58:	08203c54 	ori	zero,at,33009
 8203b5c:	08203c48 	cmpgei	zero,at,-32527
 8203b60:	08203c3c 	xorhi	zero,at,33008
 8203b64:	08203f78 	rdprs	zero,at,-32515
 8203b68:	08203c30 	cmpltui	zero,at,33008
 8203b6c:	08203c24 	muli	zero,at,-32528
 8203b70:	08203c18 	cmpnei	zero,at,-32528
 8203b74:	08203c0c 	andi	zero,at,33008
 8203b78:	08203f78 	rdprs	zero,at,-32515
 8203b7c:	08203f78 	rdprs	zero,at,-32515
 8203b80:	08203f78 	rdprs	zero,at,-32515
 8203b84:	08203f78 	rdprs	zero,at,-32515
 8203b88:	08203f78 	rdprs	zero,at,-32515
 8203b8c:	08203c00 	call	8203c0 <OSCtxSw_SWITCH_PC+0x820380>
 8203b90:	08203f78 	rdprs	zero,at,-32515
 8203b94:	08203f78 	rdprs	zero,at,-32515
 8203b98:	08203f78 	rdprs	zero,at,-32515
 8203b9c:	08203bf4 	orhi	zero,at,33007
 8203ba0:	08203be8 	cmpgeui	zero,at,33007
 8203ba4:	08203bdc 	xori	zero,at,33007
 8203ba8:	08203bd0 	cmplti	zero,at,-32529
 8203bac:	08203bc4 	addi	zero,at,-32529
 8203bb0:	00820974 	movhi	r2,2085
 8203bb4:	10b51c04 	addi	r2,r2,-11152
 8203bb8:	dfc00017 	ldw	ra,0(sp)
 8203bbc:	dec00104 	addi	sp,sp,4
 8203bc0:	f800283a 	ret
 8203bc4:	00820974 	movhi	r2,2085
 8203bc8:	10b6b904 	addi	r2,r2,-9500
 8203bcc:	003ffa06 	br	8203bb8 <_strerror_r+0x274>
 8203bd0:	00820974 	movhi	r2,2085
 8203bd4:	10b6b304 	addi	r2,r2,-9524
 8203bd8:	003ff706 	br	8203bb8 <_strerror_r+0x274>
 8203bdc:	00820974 	movhi	r2,2085
 8203be0:	10b6ae04 	addi	r2,r2,-9544
 8203be4:	003ff406 	br	8203bb8 <_strerror_r+0x274>
 8203be8:	00820974 	movhi	r2,2085
 8203bec:	10b6c704 	addi	r2,r2,-9444
 8203bf0:	003ff106 	br	8203bb8 <_strerror_r+0x274>
 8203bf4:	00820974 	movhi	r2,2085
 8203bf8:	10b60504 	addi	r2,r2,-10220
 8203bfc:	003fee06 	br	8203bb8 <_strerror_r+0x274>
 8203c00:	00820974 	movhi	r2,2085
 8203c04:	10b5d304 	addi	r2,r2,-10420
 8203c08:	003feb06 	br	8203bb8 <_strerror_r+0x274>
 8203c0c:	00820974 	movhi	r2,2085
 8203c10:	10b6a104 	addi	r2,r2,-9596
 8203c14:	003fe806 	br	8203bb8 <_strerror_r+0x274>
 8203c18:	00820974 	movhi	r2,2085
 8203c1c:	10b6a704 	addi	r2,r2,-9572
 8203c20:	003fe506 	br	8203bb8 <_strerror_r+0x274>
 8203c24:	00820974 	movhi	r2,2085
 8203c28:	10b5a204 	addi	r2,r2,-10616
 8203c2c:	003fe206 	br	8203bb8 <_strerror_r+0x274>
 8203c30:	00820974 	movhi	r2,2085
 8203c34:	10b69204 	addi	r2,r2,-9656
 8203c38:	003fdf06 	br	8203bb8 <_strerror_r+0x274>
 8203c3c:	00820974 	movhi	r2,2085
 8203c40:	10b62f04 	addi	r2,r2,-10052
 8203c44:	003fdc06 	br	8203bb8 <_strerror_r+0x274>
 8203c48:	00820974 	movhi	r2,2085
 8203c4c:	10b6d104 	addi	r2,r2,-9404
 8203c50:	003fd906 	br	8203bb8 <_strerror_r+0x274>
 8203c54:	00820974 	movhi	r2,2085
 8203c58:	10b55404 	addi	r2,r2,-10928
 8203c5c:	003fd606 	br	8203bb8 <_strerror_r+0x274>
 8203c60:	00820974 	movhi	r2,2085
 8203c64:	10b54604 	addi	r2,r2,-10984
 8203c68:	003fd306 	br	8203bb8 <_strerror_r+0x274>
 8203c6c:	00820974 	movhi	r2,2085
 8203c70:	10b58804 	addi	r2,r2,-10720
 8203c74:	003fd006 	br	8203bb8 <_strerror_r+0x274>
 8203c78:	00820974 	movhi	r2,2085
 8203c7c:	10b5c804 	addi	r2,r2,-10464
 8203c80:	003fcd06 	br	8203bb8 <_strerror_r+0x274>
 8203c84:	00820974 	movhi	r2,2085
 8203c88:	10b58404 	addi	r2,r2,-10736
 8203c8c:	003fca06 	br	8203bb8 <_strerror_r+0x274>
 8203c90:	00820974 	movhi	r2,2085
 8203c94:	10b6d604 	addi	r2,r2,-9384
 8203c98:	003fc706 	br	8203bb8 <_strerror_r+0x274>
 8203c9c:	00820974 	movhi	r2,2085
 8203ca0:	10b59904 	addi	r2,r2,-10652
 8203ca4:	003fc406 	br	8203bb8 <_strerror_r+0x274>
 8203ca8:	00820974 	movhi	r2,2085
 8203cac:	10b60e04 	addi	r2,r2,-10184
 8203cb0:	003fc106 	br	8203bb8 <_strerror_r+0x274>
 8203cb4:	00820974 	movhi	r2,2085
 8203cb8:	10b69804 	addi	r2,r2,-9632
 8203cbc:	003fbe06 	br	8203bb8 <_strerror_r+0x274>
 8203cc0:	00820974 	movhi	r2,2085
 8203cc4:	10b68c04 	addi	r2,r2,-9680
 8203cc8:	003fbb06 	br	8203bb8 <_strerror_r+0x274>
 8203ccc:	00820974 	movhi	r2,2085
 8203cd0:	10b68004 	addi	r2,r2,-9728
 8203cd4:	003fb806 	br	8203bb8 <_strerror_r+0x274>
 8203cd8:	00820974 	movhi	r2,2085
 8203cdc:	10b67a04 	addi	r2,r2,-9752
 8203ce0:	003fb506 	br	8203bb8 <_strerror_r+0x274>
 8203ce4:	00820974 	movhi	r2,2085
 8203ce8:	10b67204 	addi	r2,r2,-9784
 8203cec:	003fb206 	br	8203bb8 <_strerror_r+0x274>
 8203cf0:	00820974 	movhi	r2,2085
 8203cf4:	10b66a04 	addi	r2,r2,-9816
 8203cf8:	003faf06 	br	8203bb8 <_strerror_r+0x274>
 8203cfc:	00820974 	movhi	r2,2085
 8203d00:	10b65e04 	addi	r2,r2,-9864
 8203d04:	003fac06 	br	8203bb8 <_strerror_r+0x274>
 8203d08:	00820974 	movhi	r2,2085
 8203d0c:	10b65504 	addi	r2,r2,-9900
 8203d10:	003fa906 	br	8203bb8 <_strerror_r+0x274>
 8203d14:	00820974 	movhi	r2,2085
 8203d18:	10b68504 	addi	r2,r2,-9708
 8203d1c:	003fa606 	br	8203bb8 <_strerror_r+0x274>
 8203d20:	00820974 	movhi	r2,2085
 8203d24:	10b6be04 	addi	r2,r2,-9480
 8203d28:	003fa306 	br	8203bb8 <_strerror_r+0x274>
 8203d2c:	00820974 	movhi	r2,2085
 8203d30:	10b64f04 	addi	r2,r2,-9924
 8203d34:	003fa006 	br	8203bb8 <_strerror_r+0x274>
 8203d38:	00820974 	movhi	r2,2085
 8203d3c:	10b64804 	addi	r2,r2,-9952
 8203d40:	003f9d06 	br	8203bb8 <_strerror_r+0x274>
 8203d44:	00820974 	movhi	r2,2085
 8203d48:	10b64304 	addi	r2,r2,-9972
 8203d4c:	003f9a06 	br	8203bb8 <_strerror_r+0x274>
 8203d50:	00820974 	movhi	r2,2085
 8203d54:	10b63c04 	addi	r2,r2,-10000
 8203d58:	003f9706 	br	8203bb8 <_strerror_r+0x274>
 8203d5c:	00820974 	movhi	r2,2085
 8203d60:	10b63904 	addi	r2,r2,-10012
 8203d64:	003f9406 	br	8203bb8 <_strerror_r+0x274>
 8203d68:	00820974 	movhi	r2,2085
 8203d6c:	10b63404 	addi	r2,r2,-10032
 8203d70:	003f9106 	br	8203bb8 <_strerror_r+0x274>
 8203d74:	00820974 	movhi	r2,2085
 8203d78:	10b62b04 	addi	r2,r2,-10068
 8203d7c:	003f8e06 	br	8203bb8 <_strerror_r+0x274>
 8203d80:	00820974 	movhi	r2,2085
 8203d84:	10b62504 	addi	r2,r2,-10092
 8203d88:	003f8b06 	br	8203bb8 <_strerror_r+0x274>
 8203d8c:	00820974 	movhi	r2,2085
 8203d90:	10b62004 	addi	r2,r2,-10112
 8203d94:	003f8806 	br	8203bb8 <_strerror_r+0x274>
 8203d98:	00820974 	movhi	r2,2085
 8203d9c:	10b61a04 	addi	r2,r2,-10136
 8203da0:	003f8506 	br	8203bb8 <_strerror_r+0x274>
 8203da4:	00820974 	movhi	r2,2085
 8203da8:	10b65c04 	addi	r2,r2,-9872
 8203dac:	003f8206 	br	8203bb8 <_strerror_r+0x274>
 8203db0:	00820974 	movhi	r2,2085
 8203db4:	10b61604 	addi	r2,r2,-10152
 8203db8:	003f7f06 	br	8203bb8 <_strerror_r+0x274>
 8203dbc:	00820974 	movhi	r2,2085
 8203dc0:	10b61404 	addi	r2,r2,-10160
 8203dc4:	003f7c06 	br	8203bb8 <_strerror_r+0x274>
 8203dc8:	00820974 	movhi	r2,2085
 8203dcc:	10b60b04 	addi	r2,r2,-10196
 8203dd0:	003f7906 	br	8203bb8 <_strerror_r+0x274>
 8203dd4:	00820974 	movhi	r2,2085
 8203dd8:	10b60004 	addi	r2,r2,-10240
 8203ddc:	003f7606 	br	8203bb8 <_strerror_r+0x274>
 8203de0:	00820974 	movhi	r2,2085
 8203de4:	10b5f904 	addi	r2,r2,-10268
 8203de8:	003f7306 	br	8203bb8 <_strerror_r+0x274>
 8203dec:	00820974 	movhi	r2,2085
 8203df0:	10b5f404 	addi	r2,r2,-10288
 8203df4:	003f7006 	br	8203bb8 <_strerror_r+0x274>
 8203df8:	00820974 	movhi	r2,2085
 8203dfc:	10b5e804 	addi	r2,r2,-10336
 8203e00:	003f6d06 	br	8203bb8 <_strerror_r+0x274>
 8203e04:	00820974 	movhi	r2,2085
 8203e08:	10b5e504 	addi	r2,r2,-10348
 8203e0c:	003f6a06 	br	8203bb8 <_strerror_r+0x274>
 8203e10:	00820974 	movhi	r2,2085
 8203e14:	10b5e104 	addi	r2,r2,-10364
 8203e18:	003f6706 	br	8203bb8 <_strerror_r+0x274>
 8203e1c:	00820974 	movhi	r2,2085
 8203e20:	10b5db04 	addi	r2,r2,-10388
 8203e24:	003f6406 	br	8203bb8 <_strerror_r+0x274>
 8203e28:	00820974 	movhi	r2,2085
 8203e2c:	10b5d704 	addi	r2,r2,-10404
 8203e30:	003f6106 	br	8203bb8 <_strerror_r+0x274>
 8203e34:	00820974 	movhi	r2,2085
 8203e38:	10b5cd04 	addi	r2,r2,-10444
 8203e3c:	003f5e06 	br	8203bb8 <_strerror_r+0x274>
 8203e40:	00820974 	movhi	r2,2085
 8203e44:	10b5c404 	addi	r2,r2,-10480
 8203e48:	003f5b06 	br	8203bb8 <_strerror_r+0x274>
 8203e4c:	00820974 	movhi	r2,2085
 8203e50:	10b5c004 	addi	r2,r2,-10496
 8203e54:	003f5806 	br	8203bb8 <_strerror_r+0x274>
 8203e58:	00820974 	movhi	r2,2085
 8203e5c:	10b5ba04 	addi	r2,r2,-10520
 8203e60:	003f5506 	br	8203bb8 <_strerror_r+0x274>
 8203e64:	00820974 	movhi	r2,2085
 8203e68:	10b5b204 	addi	r2,r2,-10552
 8203e6c:	003f5206 	br	8203bb8 <_strerror_r+0x274>
 8203e70:	00820974 	movhi	r2,2085
 8203e74:	10b5aa04 	addi	r2,r2,-10584
 8203e78:	003f4f06 	br	8203bb8 <_strerror_r+0x274>
 8203e7c:	00820974 	movhi	r2,2085
 8203e80:	10b59404 	addi	r2,r2,-10672
 8203e84:	003f4c06 	br	8203bb8 <_strerror_r+0x274>
 8203e88:	00820974 	movhi	r2,2085
 8203e8c:	10b59004 	addi	r2,r2,-10688
 8203e90:	003f4906 	br	8203bb8 <_strerror_r+0x274>
 8203e94:	00820974 	movhi	r2,2085
 8203e98:	10b58004 	addi	r2,r2,-10752
 8203e9c:	003f4606 	br	8203bb8 <_strerror_r+0x274>
 8203ea0:	00820974 	movhi	r2,2085
 8203ea4:	10b57c04 	addi	r2,r2,-10768
 8203ea8:	003f4306 	br	8203bb8 <_strerror_r+0x274>
 8203eac:	00820974 	movhi	r2,2085
 8203eb0:	10b57704 	addi	r2,r2,-10788
 8203eb4:	003f4006 	br	8203bb8 <_strerror_r+0x274>
 8203eb8:	00820974 	movhi	r2,2085
 8203ebc:	10b57404 	addi	r2,r2,-10800
 8203ec0:	003f3d06 	br	8203bb8 <_strerror_r+0x274>
 8203ec4:	00820974 	movhi	r2,2085
 8203ec8:	10b56e04 	addi	r2,r2,-10824
 8203ecc:	003f3a06 	br	8203bb8 <_strerror_r+0x274>
 8203ed0:	00820974 	movhi	r2,2085
 8203ed4:	10b56b04 	addi	r2,r2,-10836
 8203ed8:	003f3706 	br	8203bb8 <_strerror_r+0x274>
 8203edc:	00820974 	movhi	r2,2085
 8203ee0:	10b56604 	addi	r2,r2,-10856
 8203ee4:	003f3406 	br	8203bb8 <_strerror_r+0x274>
 8203ee8:	00820974 	movhi	r2,2085
 8203eec:	10b56104 	addi	r2,r2,-10876
 8203ef0:	003f3106 	br	8203bb8 <_strerror_r+0x274>
 8203ef4:	00820974 	movhi	r2,2085
 8203ef8:	10b55c04 	addi	r2,r2,-10896
 8203efc:	003f2e06 	br	8203bb8 <_strerror_r+0x274>
 8203f00:	00820974 	movhi	r2,2085
 8203f04:	10b55104 	addi	r2,r2,-10940
 8203f08:	003f2b06 	br	8203bb8 <_strerror_r+0x274>
 8203f0c:	00820974 	movhi	r2,2085
 8203f10:	10b54d04 	addi	r2,r2,-10956
 8203f14:	003f2806 	br	8203bb8 <_strerror_r+0x274>
 8203f18:	00820974 	movhi	r2,2085
 8203f1c:	10b54104 	addi	r2,r2,-11004
 8203f20:	003f2506 	br	8203bb8 <_strerror_r+0x274>
 8203f24:	00820974 	movhi	r2,2085
 8203f28:	10b53c04 	addi	r2,r2,-11024
 8203f2c:	003f2206 	br	8203bb8 <_strerror_r+0x274>
 8203f30:	00820974 	movhi	r2,2085
 8203f34:	10b53504 	addi	r2,r2,-11052
 8203f38:	003f1f06 	br	8203bb8 <_strerror_r+0x274>
 8203f3c:	00820974 	movhi	r2,2085
 8203f40:	10b53204 	addi	r2,r2,-11064
 8203f44:	003f1c06 	br	8203bb8 <_strerror_r+0x274>
 8203f48:	00820974 	movhi	r2,2085
 8203f4c:	10b52c04 	addi	r2,r2,-11088
 8203f50:	003f1906 	br	8203bb8 <_strerror_r+0x274>
 8203f54:	00820974 	movhi	r2,2085
 8203f58:	10b52804 	addi	r2,r2,-11104
 8203f5c:	003f1606 	br	8203bb8 <_strerror_r+0x274>
 8203f60:	00820974 	movhi	r2,2085
 8203f64:	10b52104 	addi	r2,r2,-11132
 8203f68:	003f1306 	br	8203bb8 <_strerror_r+0x274>
 8203f6c:	00820974 	movhi	r2,2085
 8203f70:	10b51e04 	addi	r2,r2,-11144
 8203f74:	003f1006 	br	8203bb8 <_strerror_r+0x274>
 8203f78:	38000726 	beq	r7,zero,8203f98 <_strerror_r+0x654>
 8203f7c:	380d883a 	mov	r6,r7
 8203f80:	1809883a 	mov	r4,r3
 8203f84:	8206a900 	call	8206a90 <_user_strerror>
 8203f88:	103f0b1e 	bne	r2,zero,8203bb8 <_strerror_r+0x274>
 8203f8c:	00820974 	movhi	r2,2085
 8203f90:	10b6e404 	addi	r2,r2,-9328
 8203f94:	003f0806 	br	8203bb8 <_strerror_r+0x274>
 8203f98:	200f883a 	mov	r7,r4
 8203f9c:	003ff706 	br	8203f7c <_strerror_r+0x638>

08203fa0 <strerror>:
 8203fa0:	00820974 	movhi	r2,2085
 8203fa4:	108fbb04 	addi	r2,r2,16108
 8203fa8:	200b883a 	mov	r5,r4
 8203fac:	11000017 	ldw	r4,0(r2)
 8203fb0:	000f883a 	mov	r7,zero
 8203fb4:	000d883a 	mov	r6,zero
 8203fb8:	82039441 	jmpi	8203944 <_strerror_r>

08203fbc <strlen>:
 8203fbc:	208000cc 	andi	r2,r4,3
 8203fc0:	10002026 	beq	r2,zero,8204044 <strlen+0x88>
 8203fc4:	20800007 	ldb	r2,0(r4)
 8203fc8:	10002026 	beq	r2,zero,820404c <strlen+0x90>
 8203fcc:	2005883a 	mov	r2,r4
 8203fd0:	00000206 	br	8203fdc <strlen+0x20>
 8203fd4:	10c00007 	ldb	r3,0(r2)
 8203fd8:	18001826 	beq	r3,zero,820403c <strlen+0x80>
 8203fdc:	10800044 	addi	r2,r2,1
 8203fe0:	10c000cc 	andi	r3,r2,3
 8203fe4:	183ffb1e 	bne	r3,zero,8203fd4 <strlen+0x18>
 8203fe8:	10c00017 	ldw	r3,0(r2)
 8203fec:	01ffbff4 	movhi	r7,65279
 8203ff0:	39ffbfc4 	addi	r7,r7,-257
 8203ff4:	00ca303a 	nor	r5,zero,r3
 8203ff8:	01a02074 	movhi	r6,32897
 8203ffc:	19c7883a 	add	r3,r3,r7
 8204000:	31a02004 	addi	r6,r6,-32640
 8204004:	1946703a 	and	r3,r3,r5
 8204008:	1986703a 	and	r3,r3,r6
 820400c:	1800091e 	bne	r3,zero,8204034 <strlen+0x78>
 8204010:	10800104 	addi	r2,r2,4
 8204014:	10c00017 	ldw	r3,0(r2)
 8204018:	19cb883a 	add	r5,r3,r7
 820401c:	00c6303a 	nor	r3,zero,r3
 8204020:	28c6703a 	and	r3,r5,r3
 8204024:	1986703a 	and	r3,r3,r6
 8204028:	183ff926 	beq	r3,zero,8204010 <strlen+0x54>
 820402c:	00000106 	br	8204034 <strlen+0x78>
 8204030:	10800044 	addi	r2,r2,1
 8204034:	10c00007 	ldb	r3,0(r2)
 8204038:	183ffd1e 	bne	r3,zero,8204030 <strlen+0x74>
 820403c:	1105c83a 	sub	r2,r2,r4
 8204040:	f800283a 	ret
 8204044:	2005883a 	mov	r2,r4
 8204048:	003fe706 	br	8203fe8 <strlen+0x2c>
 820404c:	0005883a 	mov	r2,zero
 8204050:	f800283a 	ret

08204054 <critical_factorization>:
 8204054:	02c00044 	movi	r11,1
 8204058:	5811883a 	mov	r8,r11
 820405c:	0013883a 	mov	r9,zero
 8204060:	00bfffc4 	movi	r2,-1
 8204064:	2087883a 	add	r3,r4,r2
 8204068:	1a0f883a 	add	r7,r3,r8
 820406c:	4a07883a 	add	r3,r9,r8
 8204070:	20d5883a 	add	r10,r4,r3
 8204074:	1940102e 	bgeu	r3,r5,82040b8 <critical_factorization+0x64>
 8204078:	52800003 	ldbu	r10,0(r10)
 820407c:	39c00003 	ldbu	r7,0(r7)
 8204080:	51c0042e 	bgeu	r10,r7,8204094 <critical_factorization+0x40>
 8204084:	1897c83a 	sub	r11,r3,r2
 8204088:	1813883a 	mov	r9,r3
 820408c:	02000044 	movi	r8,1
 8204090:	003ff406 	br	8204064 <critical_factorization+0x10>
 8204094:	51c00526 	beq	r10,r7,82040ac <critical_factorization+0x58>
 8204098:	02c00044 	movi	r11,1
 820409c:	4805883a 	mov	r2,r9
 82040a0:	5811883a 	mov	r8,r11
 82040a4:	4ad3883a 	add	r9,r9,r11
 82040a8:	003fee06 	br	8204064 <critical_factorization+0x10>
 82040ac:	42c02226 	beq	r8,r11,8204138 <critical_factorization+0xe4>
 82040b0:	42000044 	addi	r8,r8,1
 82040b4:	003feb06 	br	8204064 <critical_factorization+0x10>
 82040b8:	03000044 	movi	r12,1
 82040bc:	32c00015 	stw	r11,0(r6)
 82040c0:	6011883a 	mov	r8,r12
 82040c4:	0013883a 	mov	r9,zero
 82040c8:	02ffffc4 	movi	r11,-1
 82040cc:	22c7883a 	add	r3,r4,r11
 82040d0:	1a0f883a 	add	r7,r3,r8
 82040d4:	4a07883a 	add	r3,r9,r8
 82040d8:	20d5883a 	add	r10,r4,r3
 82040dc:	1940102e 	bgeu	r3,r5,8204120 <critical_factorization+0xcc>
 82040e0:	52800003 	ldbu	r10,0(r10)
 82040e4:	39c00003 	ldbu	r7,0(r7)
 82040e8:	3a80042e 	bgeu	r7,r10,82040fc <critical_factorization+0xa8>
 82040ec:	1ad9c83a 	sub	r12,r3,r11
 82040f0:	1813883a 	mov	r9,r3
 82040f4:	02000044 	movi	r8,1
 82040f8:	003ff406 	br	82040cc <critical_factorization+0x78>
 82040fc:	51c00526 	beq	r10,r7,8204114 <critical_factorization+0xc0>
 8204100:	03000044 	movi	r12,1
 8204104:	4817883a 	mov	r11,r9
 8204108:	6011883a 	mov	r8,r12
 820410c:	4b13883a 	add	r9,r9,r12
 8204110:	003fee06 	br	82040cc <critical_factorization+0x78>
 8204114:	43000c26 	beq	r8,r12,8204148 <critical_factorization+0xf4>
 8204118:	42000044 	addi	r8,r8,1
 820411c:	003feb06 	br	82040cc <critical_factorization+0x78>
 8204120:	5ac00044 	addi	r11,r11,1
 8204124:	10800044 	addi	r2,r2,1
 8204128:	58800236 	bltu	r11,r2,8204134 <critical_factorization+0xe0>
 820412c:	33000015 	stw	r12,0(r6)
 8204130:	5805883a 	mov	r2,r11
 8204134:	f800283a 	ret
 8204138:	4017883a 	mov	r11,r8
 820413c:	1813883a 	mov	r9,r3
 8204140:	02000044 	movi	r8,1
 8204144:	003fc706 	br	8204064 <critical_factorization+0x10>
 8204148:	4019883a 	mov	r12,r8
 820414c:	1813883a 	mov	r9,r3
 8204150:	02000044 	movi	r8,1
 8204154:	003fdd06 	br	82040cc <critical_factorization+0x78>

08204158 <two_way_long_needle>:
 8204158:	defef104 	addi	sp,sp,-1084
 820415c:	dc810715 	stw	r18,1052(sp)
 8204160:	dc410615 	stw	r17,1048(sp)
 8204164:	dc810004 	addi	r18,sp,1024
 8204168:	3023883a 	mov	r17,r6
 820416c:	2807883a 	mov	r3,r5
 8204170:	ddc10c15 	stw	r23,1072(sp)
 8204174:	900d883a 	mov	r6,r18
 8204178:	202f883a 	mov	r23,r4
 820417c:	380b883a 	mov	r5,r7
 8204180:	8809883a 	mov	r4,r17
 8204184:	dd810b15 	stw	r22,1068(sp)
 8204188:	dc010515 	stw	r16,1044(sp)
 820418c:	d8c10415 	stw	r3,1040(sp)
 8204190:	dfc10e15 	stw	ra,1080(sp)
 8204194:	df010d15 	stw	fp,1076(sp)
 8204198:	dd410a15 	stw	r21,1064(sp)
 820419c:	dd010915 	stw	r20,1060(sp)
 82041a0:	dcc10815 	stw	r19,1056(sp)
 82041a4:	382d883a 	mov	r22,r7
 82041a8:	82040540 	call	8204054 <critical_factorization>
 82041ac:	d8c10417 	ldw	r3,1040(sp)
 82041b0:	1021883a 	mov	r16,r2
 82041b4:	d805883a 	mov	r2,sp
 82041b8:	15800015 	stw	r22,0(r2)
 82041bc:	10800104 	addi	r2,r2,4
 82041c0:	90bffd1e 	bne	r18,r2,82041b8 <two_way_long_needle+0x60>
 82041c4:	b0000b26 	beq	r22,zero,82041f4 <two_way_long_needle+0x9c>
 82041c8:	b17fffc4 	addi	r5,r22,-1
 82041cc:	8809883a 	mov	r4,r17
 82041d0:	8d8d883a 	add	r6,r17,r22
 82041d4:	20800003 	ldbu	r2,0(r4)
 82041d8:	21000044 	addi	r4,r4,1
 82041dc:	1085883a 	add	r2,r2,r2
 82041e0:	1085883a 	add	r2,r2,r2
 82041e4:	d885883a 	add	r2,sp,r2
 82041e8:	11400015 	stw	r5,0(r2)
 82041ec:	297fffc4 	addi	r5,r5,-1
 82041f0:	21bff81e 	bne	r4,r6,82041d4 <two_way_long_needle+0x7c>
 82041f4:	d9410017 	ldw	r5,1024(sp)
 82041f8:	800d883a 	mov	r6,r16
 82041fc:	8809883a 	mov	r4,r17
 8204200:	894b883a 	add	r5,r17,r5
 8204204:	d8c10415 	stw	r3,1040(sp)
 8204208:	820c6380 	call	820c638 <memcmp>
 820420c:	d8c10417 	ldw	r3,1040(sp)
 8204210:	10006a1e 	bne	r2,zero,82043bc <two_way_long_needle+0x264>
 8204214:	84bfffc4 	addi	r18,r16,-1
 8204218:	8c85883a 	add	r2,r17,r18
 820421c:	d8810215 	stw	r2,1032(sp)
 8204220:	00800044 	movi	r2,1
 8204224:	813fff84 	addi	r4,r16,-2
 8204228:	1405c83a 	sub	r2,r2,r16
 820422c:	0029883a 	mov	r20,zero
 8204230:	0039883a 	mov	fp,zero
 8204234:	b57fffc4 	addi	r21,r22,-1
 8204238:	d9010115 	stw	r4,1028(sp)
 820423c:	d8810315 	stw	r2,1036(sp)
 8204240:	00000706 	br	8204260 <two_way_long_needle+0x108>
 8204244:	a0000326 	beq	r20,zero,8204254 <two_way_long_needle+0xfc>
 8204248:	d8c10017 	ldw	r3,1024(sp)
 820424c:	10c0012e 	bgeu	r2,r3,8204254 <two_way_long_needle+0xfc>
 8204250:	b0c5c83a 	sub	r2,r22,r3
 8204254:	e0b9883a 	add	fp,fp,r2
 8204258:	0029883a 	mov	r20,zero
 820425c:	9807883a 	mov	r3,r19
 8204260:	e5a7883a 	add	r19,fp,r22
 8204264:	98cdc83a 	sub	r6,r19,r3
 8204268:	000b883a 	mov	r5,zero
 820426c:	b8c9883a 	add	r4,r23,r3
 8204270:	820c5540 	call	820c554 <memchr>
 8204274:	1000441e 	bne	r2,zero,8204388 <two_way_long_needle+0x230>
 8204278:	98004326 	beq	r19,zero,8204388 <two_way_long_needle+0x230>
 820427c:	bcc5883a 	add	r2,r23,r19
 8204280:	10bfffc3 	ldbu	r2,-1(r2)
 8204284:	1085883a 	add	r2,r2,r2
 8204288:	1085883a 	add	r2,r2,r2
 820428c:	d885883a 	add	r2,sp,r2
 8204290:	10800017 	ldw	r2,0(r2)
 8204294:	103feb1e 	bne	r2,zero,8204244 <two_way_long_needle+0xec>
 8204298:	a015883a 	mov	r10,r20
 820429c:	a400012e 	bgeu	r20,r16,82042a4 <two_way_long_needle+0x14c>
 82042a0:	8015883a 	mov	r10,r16
 82042a4:	5540152e 	bgeu	r10,r21,82042fc <two_way_long_needle+0x1a4>
 82042a8:	bf05883a 	add	r2,r23,fp
 82042ac:	8a87883a 	add	r3,r17,r10
 82042b0:	1285883a 	add	r2,r2,r10
 82042b4:	18c00003 	ldbu	r3,0(r3)
 82042b8:	10800003 	ldbu	r2,0(r2)
 82042bc:	18802d1e 	bne	r3,r2,8204374 <two_way_long_needle+0x21c>
 82042c0:	e1400044 	addi	r5,fp,1
 82042c4:	50800044 	addi	r2,r10,1
 82042c8:	2a8b883a 	add	r5,r5,r10
 82042cc:	888d883a 	add	r6,r17,r2
 82042d0:	b94b883a 	add	r5,r23,r5
 82042d4:	00000706 	br	82042f4 <two_way_long_needle+0x19c>
 82042d8:	31000003 	ldbu	r4,0(r6)
 82042dc:	28c00003 	ldbu	r3,0(r5)
 82042e0:	31800044 	addi	r6,r6,1
 82042e4:	21003fcc 	andi	r4,r4,255
 82042e8:	29400044 	addi	r5,r5,1
 82042ec:	20c0211e 	bne	r4,r3,8204374 <two_way_long_needle+0x21c>
 82042f0:	10800044 	addi	r2,r2,1
 82042f4:	1015883a 	mov	r10,r2
 82042f8:	157ff736 	bltu	r2,r21,82042d8 <two_way_long_needle+0x180>
 82042fc:	900d883a 	mov	r6,r18
 8204300:	a4007d2e 	bgeu	r20,r16,82044f8 <two_way_long_needle+0x3a0>
 8204304:	d9410217 	ldw	r5,1032(sp)
 8204308:	bf05883a 	add	r2,r23,fp
 820430c:	1485883a 	add	r2,r2,r18
 8204310:	28c00003 	ldbu	r3,0(r5)
 8204314:	10800003 	ldbu	r2,0(r2)
 8204318:	1880771e 	bne	r3,r2,82044f8 <two_way_long_needle+0x3a0>
 820431c:	d8c10117 	ldw	r3,1028(sp)
 8204320:	a2ffffc4 	addi	r11,r20,-1
 8204324:	8ad7883a 	add	r11,r17,r11
 8204328:	e0cb883a 	add	r5,fp,r3
 820432c:	88c5883a 	add	r2,r17,r3
 8204330:	b94b883a 	add	r5,r23,r5
 8204334:	00000706 	br	8204354 <two_way_long_needle+0x1fc>
 8204338:	11000003 	ldbu	r4,0(r2)
 820433c:	28c00003 	ldbu	r3,0(r5)
 8204340:	10bfffc4 	addi	r2,r2,-1
 8204344:	21003fcc 	andi	r4,r4,255
 8204348:	297fffc4 	addi	r5,r5,-1
 820434c:	20c0031e 	bne	r4,r3,820435c <two_way_long_needle+0x204>
 8204350:	500d883a 	mov	r6,r10
 8204354:	32bfffc4 	addi	r10,r6,-1
 8204358:	58bff71e 	bne	r11,r2,8204338 <two_way_long_needle+0x1e0>
 820435c:	a2400044 	addi	r9,r20,1
 8204360:	32406736 	bltu	r6,r9,8204500 <two_way_long_needle+0x3a8>
 8204364:	da410017 	ldw	r9,1024(sp)
 8204368:	e279883a 	add	fp,fp,r9
 820436c:	b269c83a 	sub	r20,r22,r9
 8204370:	003fba06 	br	820425c <two_way_long_needle+0x104>
 8204374:	d8c10317 	ldw	r3,1036(sp)
 8204378:	0029883a 	mov	r20,zero
 820437c:	1f39883a 	add	fp,r3,fp
 8204380:	e2b9883a 	add	fp,fp,r10
 8204384:	003fb506 	br	820425c <two_way_long_needle+0x104>
 8204388:	0005883a 	mov	r2,zero
 820438c:	dfc10e17 	ldw	ra,1080(sp)
 8204390:	df010d17 	ldw	fp,1076(sp)
 8204394:	ddc10c17 	ldw	r23,1072(sp)
 8204398:	dd810b17 	ldw	r22,1068(sp)
 820439c:	dd410a17 	ldw	r21,1064(sp)
 82043a0:	dd010917 	ldw	r20,1060(sp)
 82043a4:	dcc10817 	ldw	r19,1056(sp)
 82043a8:	dc810717 	ldw	r18,1052(sp)
 82043ac:	dc410617 	ldw	r17,1048(sp)
 82043b0:	dc010517 	ldw	r16,1044(sp)
 82043b4:	dec10f04 	addi	sp,sp,1084
 82043b8:	f800283a 	ret
 82043bc:	b405c83a 	sub	r2,r22,r16
 82043c0:	14004b36 	bltu	r2,r16,82044f0 <two_way_long_needle+0x398>
 82043c4:	10800044 	addi	r2,r2,1
 82043c8:	84bfffc4 	addi	r18,r16,-1
 82043cc:	d8810015 	stw	r2,1024(sp)
 82043d0:	00800044 	movi	r2,1
 82043d4:	8c89883a 	add	r4,r17,r18
 82043d8:	817fff84 	addi	r5,r16,-2
 82043dc:	1405c83a 	sub	r2,r2,r16
 82043e0:	0029883a 	mov	r20,zero
 82043e4:	b73fffc4 	addi	fp,r22,-1
 82043e8:	d9010215 	stw	r4,1032(sp)
 82043ec:	d9410115 	stw	r5,1028(sp)
 82043f0:	8d7fffc4 	addi	r21,r17,-1
 82043f4:	d8810315 	stw	r2,1036(sp)
 82043f8:	a5a7883a 	add	r19,r20,r22
 82043fc:	98cdc83a 	sub	r6,r19,r3
 8204400:	000b883a 	mov	r5,zero
 8204404:	b8c9883a 	add	r4,r23,r3
 8204408:	820c5540 	call	820c554 <memchr>
 820440c:	103fde1e 	bne	r2,zero,8204388 <two_way_long_needle+0x230>
 8204410:	983fdd26 	beq	r19,zero,8204388 <two_way_long_needle+0x230>
 8204414:	bcc5883a 	add	r2,r23,r19
 8204418:	10bfffc3 	ldbu	r2,-1(r2)
 820441c:	1085883a 	add	r2,r2,r2
 8204420:	1085883a 	add	r2,r2,r2
 8204424:	d885883a 	add	r2,sp,r2
 8204428:	10800017 	ldw	r2,0(r2)
 820442c:	1000291e 	bne	r2,zero,82044d4 <two_way_long_needle+0x37c>
 8204430:	bd05883a 	add	r2,r23,r20
 8204434:	8700142e 	bgeu	r16,fp,8204488 <two_way_long_needle+0x330>
 8204438:	8c07883a 	add	r3,r17,r16
 820443c:	140b883a 	add	r5,r2,r16
 8204440:	19000003 	ldbu	r4,0(r3)
 8204444:	28c00003 	ldbu	r3,0(r5)
 8204448:	800d883a 	mov	r6,r16
 820444c:	20c0241e 	bne	r4,r3,82044e0 <two_way_long_needle+0x388>
 8204450:	81400044 	addi	r5,r16,1
 8204454:	a155883a 	add	r10,r20,r5
 8204458:	ba95883a 	add	r10,r23,r10
 820445c:	894b883a 	add	r5,r17,r5
 8204460:	800d883a 	mov	r6,r16
 8204464:	00000606 	br	8204480 <two_way_long_needle+0x328>
 8204468:	29000003 	ldbu	r4,0(r5)
 820446c:	50c00003 	ldbu	r3,0(r10)
 8204470:	29400044 	addi	r5,r5,1
 8204474:	21003fcc 	andi	r4,r4,255
 8204478:	52800044 	addi	r10,r10,1
 820447c:	20c0181e 	bne	r4,r3,82044e0 <two_way_long_needle+0x388>
 8204480:	31800044 	addi	r6,r6,1
 8204484:	373ff836 	bltu	r6,fp,8204468 <two_way_long_needle+0x310>
 8204488:	00ffffc4 	movi	r3,-1
 820448c:	90ffbf26 	beq	r18,r3,820438c <two_way_long_needle+0x234>
 8204490:	d9410217 	ldw	r5,1032(sp)
 8204494:	1487883a 	add	r3,r2,r18
 8204498:	18c00003 	ldbu	r3,0(r3)
 820449c:	29000003 	ldbu	r4,0(r5)
 82044a0:	20c00b1e 	bne	r4,r3,82044d0 <two_way_long_needle+0x378>
 82044a4:	d8c10117 	ldw	r3,1028(sp)
 82044a8:	a0cd883a 	add	r6,r20,r3
 82044ac:	b98d883a 	add	r6,r23,r6
 82044b0:	88c7883a 	add	r3,r17,r3
 82044b4:	1d7fb526 	beq	r3,r21,820438c <two_way_long_needle+0x234>
 82044b8:	19400003 	ldbu	r5,0(r3)
 82044bc:	31000003 	ldbu	r4,0(r6)
 82044c0:	18ffffc4 	addi	r3,r3,-1
 82044c4:	29403fcc 	andi	r5,r5,255
 82044c8:	31bfffc4 	addi	r6,r6,-1
 82044cc:	293ff926 	beq	r5,r4,82044b4 <two_way_long_needle+0x35c>
 82044d0:	d8810017 	ldw	r2,1024(sp)
 82044d4:	a0a9883a 	add	r20,r20,r2
 82044d8:	9807883a 	mov	r3,r19
 82044dc:	003fc606 	br	82043f8 <two_way_long_needle+0x2a0>
 82044e0:	d8c10317 	ldw	r3,1036(sp)
 82044e4:	1d11883a 	add	r8,r3,r20
 82044e8:	41a9883a 	add	r20,r8,r6
 82044ec:	003ffa06 	br	82044d8 <two_way_long_needle+0x380>
 82044f0:	8005883a 	mov	r2,r16
 82044f4:	003fb306 	br	82043c4 <two_way_long_needle+0x26c>
 82044f8:	800d883a 	mov	r6,r16
 82044fc:	003f9706 	br	820435c <two_way_long_needle+0x204>
 8204500:	bf05883a 	add	r2,r23,fp
 8204504:	003fa106 	br	820438c <two_way_long_needle+0x234>

08204508 <strstr>:
 8204508:	21800007 	ldb	r6,0(r4)
 820450c:	30009226 	beq	r6,zero,8204758 <strstr+0x250>
 8204510:	28c00007 	ldb	r3,0(r5)
 8204514:	18000f26 	beq	r3,zero,8204554 <strstr+0x4c>
 8204518:	280f883a 	mov	r7,r5
 820451c:	2011883a 	mov	r8,r4
 8204520:	02400044 	movi	r9,1
 8204524:	00000206 	br	8204530 <strstr+0x28>
 8204528:	38c00007 	ldb	r3,0(r7)
 820452c:	18000826 	beq	r3,zero,8204550 <strstr+0x48>
 8204530:	42000044 	addi	r8,r8,1
 8204534:	1987003a 	cmpeq	r3,r3,r6
 8204538:	41800007 	ldb	r6,0(r8)
 820453c:	39c00044 	addi	r7,r7,1
 8204540:	48d2703a 	and	r9,r9,r3
 8204544:	303ff81e 	bne	r6,zero,8204528 <strstr+0x20>
 8204548:	38800007 	ldb	r2,0(r7)
 820454c:	1000841e 	bne	r2,zero,8204760 <strstr+0x258>
 8204550:	48000226 	beq	r9,zero,820455c <strstr+0x54>
 8204554:	2005883a 	mov	r2,r4
 8204558:	f800283a 	ret
 820455c:	defff104 	addi	sp,sp,-60
 8204560:	ddc00c15 	stw	r23,48(sp)
 8204564:	dd800b15 	stw	r22,44(sp)
 8204568:	dd400a15 	stw	r21,40(sp)
 820456c:	dc000515 	stw	r16,20(sp)
 8204570:	dfc00e15 	stw	ra,56(sp)
 8204574:	df000d15 	stw	fp,52(sp)
 8204578:	dd000915 	stw	r20,36(sp)
 820457c:	dcc00815 	stw	r19,32(sp)
 8204580:	dc800715 	stw	r18,28(sp)
 8204584:	dc400615 	stw	r17,24(sp)
 8204588:	282d883a 	mov	r22,r5
 820458c:	29400007 	ldb	r5,0(r5)
 8204590:	202b883a 	mov	r21,r4
 8204594:	21000044 	addi	r4,r4,1
 8204598:	3da1c83a 	sub	r16,r7,r22
 820459c:	82037e00 	call	82037e0 <strchr>
 82045a0:	102f883a 	mov	r23,r2
 82045a4:	10007526 	beq	r2,zero,820477c <strstr+0x274>
 82045a8:	00c00044 	movi	r3,1
 82045ac:	80c00a26 	beq	r16,r3,82045d8 <strstr+0xd0>
 82045b0:	ac09883a 	add	r4,r21,r16
 82045b4:	20800136 	bltu	r4,r2,82045bc <strstr+0xb4>
 82045b8:	2087c83a 	sub	r3,r4,r2
 82045bc:	008007c4 	movi	r2,31
 82045c0:	1400112e 	bgeu	r2,r16,8204608 <strstr+0x100>
 82045c4:	800f883a 	mov	r7,r16
 82045c8:	b00d883a 	mov	r6,r22
 82045cc:	180b883a 	mov	r5,r3
 82045d0:	b809883a 	mov	r4,r23
 82045d4:	82041580 	call	8204158 <two_way_long_needle>
 82045d8:	dfc00e17 	ldw	ra,56(sp)
 82045dc:	df000d17 	ldw	fp,52(sp)
 82045e0:	ddc00c17 	ldw	r23,48(sp)
 82045e4:	dd800b17 	ldw	r22,44(sp)
 82045e8:	dd400a17 	ldw	r21,40(sp)
 82045ec:	dd000917 	ldw	r20,36(sp)
 82045f0:	dcc00817 	ldw	r19,32(sp)
 82045f4:	dc800717 	ldw	r18,28(sp)
 82045f8:	dc400617 	ldw	r17,24(sp)
 82045fc:	dc000517 	ldw	r16,20(sp)
 8204600:	dec00f04 	addi	sp,sp,60
 8204604:	f800283a 	ret
 8204608:	d80d883a 	mov	r6,sp
 820460c:	800b883a 	mov	r5,r16
 8204610:	b009883a 	mov	r4,r22
 8204614:	d8c00415 	stw	r3,16(sp)
 8204618:	82040540 	call	8204054 <critical_factorization>
 820461c:	d9400017 	ldw	r5,0(sp)
 8204620:	100d883a 	mov	r6,r2
 8204624:	b009883a 	mov	r4,r22
 8204628:	b14b883a 	add	r5,r22,r5
 820462c:	1039883a 	mov	fp,r2
 8204630:	820c6380 	call	820c638 <memcmp>
 8204634:	d8c00417 	ldw	r3,16(sp)
 8204638:	1000521e 	bne	r2,zero,8204784 <strstr+0x27c>
 820463c:	e47fffc4 	addi	r17,fp,-1
 8204640:	04c00044 	movi	r19,1
 8204644:	b445883a 	add	r2,r22,r17
 8204648:	9f27c83a 	sub	r19,r19,fp
 820464c:	0029883a 	mov	r20,zero
 8204650:	002b883a 	mov	r21,zero
 8204654:	d8800215 	stw	r2,8(sp)
 8204658:	e4bfff84 	addi	r18,fp,-2
 820465c:	dcc00115 	stw	r19,4(sp)
 8204660:	8567883a 	add	r19,r16,r21
 8204664:	98cdc83a 	sub	r6,r19,r3
 8204668:	000b883a 	mov	r5,zero
 820466c:	b8c9883a 	add	r4,r23,r3
 8204670:	820c5540 	call	820c554 <memchr>
 8204674:	1000411e 	bne	r2,zero,820477c <strstr+0x274>
 8204678:	98004026 	beq	r19,zero,820477c <strstr+0x274>
 820467c:	e00b883a 	mov	r5,fp
 8204680:	e500012e 	bgeu	fp,r20,8204688 <strstr+0x180>
 8204684:	a00b883a 	mov	r5,r20
 8204688:	2c00152e 	bgeu	r5,r16,82046e0 <strstr+0x1d8>
 820468c:	b947883a 	add	r3,r23,r5
 8204690:	1d47883a 	add	r3,r3,r21
 8204694:	b145883a 	add	r2,r22,r5
 8204698:	18c00003 	ldbu	r3,0(r3)
 820469c:	10800003 	ldbu	r2,0(r2)
 82046a0:	1880311e 	bne	r3,r2,8204768 <strstr+0x260>
 82046a4:	a8800044 	addi	r2,r21,1
 82046a8:	28c00044 	addi	r3,r5,1
 82046ac:	1145883a 	add	r2,r2,r5
 82046b0:	b0c9883a 	add	r4,r22,r3
 82046b4:	b885883a 	add	r2,r23,r2
 82046b8:	00000706 	br	82046d8 <strstr+0x1d0>
 82046bc:	21c00003 	ldbu	r7,0(r4)
 82046c0:	11800003 	ldbu	r6,0(r2)
 82046c4:	21000044 	addi	r4,r4,1
 82046c8:	39c03fcc 	andi	r7,r7,255
 82046cc:	10800044 	addi	r2,r2,1
 82046d0:	3980251e 	bne	r7,r6,8204768 <strstr+0x260>
 82046d4:	18c00044 	addi	r3,r3,1
 82046d8:	180b883a 	mov	r5,r3
 82046dc:	1c3ff736 	bltu	r3,r16,82046bc <strstr+0x1b4>
 82046e0:	880d883a 	mov	r6,r17
 82046e4:	a700702e 	bgeu	r20,fp,82048a8 <strstr+0x3a0>
 82046e8:	d9000217 	ldw	r4,8(sp)
 82046ec:	bd45883a 	add	r2,r23,r21
 82046f0:	1445883a 	add	r2,r2,r17
 82046f4:	20c00003 	ldbu	r3,0(r4)
 82046f8:	10800003 	ldbu	r2,0(r2)
 82046fc:	18806a1e 	bne	r3,r2,82048a8 <strstr+0x3a0>
 8204700:	954b883a 	add	r5,r18,r21
 8204704:	a2bfffc4 	addi	r10,r20,-1
 8204708:	b485883a 	add	r2,r22,r18
 820470c:	b94b883a 	add	r5,r23,r5
 8204710:	b295883a 	add	r10,r22,r10
 8204714:	00000706 	br	8204734 <strstr+0x22c>
 8204718:	11000003 	ldbu	r4,0(r2)
 820471c:	28c00003 	ldbu	r3,0(r5)
 8204720:	10bfffc4 	addi	r2,r2,-1
 8204724:	21003fcc 	andi	r4,r4,255
 8204728:	297fffc4 	addi	r5,r5,-1
 820472c:	20c0031e 	bne	r4,r3,820473c <strstr+0x234>
 8204730:	380d883a 	mov	r6,r7
 8204734:	31ffffc4 	addi	r7,r6,-1
 8204738:	12bff71e 	bne	r2,r10,8204718 <strstr+0x210>
 820473c:	a2000044 	addi	r8,r20,1
 8204740:	32005b36 	bltu	r6,r8,82048b0 <strstr+0x3a8>
 8204744:	da000017 	ldw	r8,0(sp)
 8204748:	aa2b883a 	add	r21,r21,r8
 820474c:	8229c83a 	sub	r20,r16,r8
 8204750:	9807883a 	mov	r3,r19
 8204754:	003fc206 	br	8204660 <strstr+0x158>
 8204758:	28800007 	ldb	r2,0(r5)
 820475c:	103f7d26 	beq	r2,zero,8204554 <strstr+0x4c>
 8204760:	0005883a 	mov	r2,zero
 8204764:	f800283a 	ret
 8204768:	d8c00117 	ldw	r3,4(sp)
 820476c:	0029883a 	mov	r20,zero
 8204770:	1d6b883a 	add	r21,r3,r21
 8204774:	a96b883a 	add	r21,r21,r5
 8204778:	003ff506 	br	8204750 <strstr+0x248>
 820477c:	0005883a 	mov	r2,zero
 8204780:	003f9506 	br	82045d8 <strstr+0xd0>
 8204784:	8705c83a 	sub	r2,r16,fp
 8204788:	1700012e 	bgeu	r2,fp,8204790 <strstr+0x288>
 820478c:	e005883a 	mov	r2,fp
 8204790:	10800044 	addi	r2,r2,1
 8204794:	e4bfffc4 	addi	r18,fp,-1
 8204798:	05000044 	movi	r20,1
 820479c:	a729c83a 	sub	r20,r20,fp
 82047a0:	d8800015 	stw	r2,0(sp)
 82047a4:	b48b883a 	add	r5,r22,r18
 82047a8:	e0bfff84 	addi	r2,fp,-2
 82047ac:	dd000215 	stw	r20,8(sp)
 82047b0:	002b883a 	mov	r21,zero
 82047b4:	e4400044 	addi	r17,fp,1
 82047b8:	d9400315 	stw	r5,12(sp)
 82047bc:	d8800115 	stw	r2,4(sp)
 82047c0:	b53fffc4 	addi	r20,r22,-1
 82047c4:	8567883a 	add	r19,r16,r21
 82047c8:	98cdc83a 	sub	r6,r19,r3
 82047cc:	000b883a 	mov	r5,zero
 82047d0:	b8c9883a 	add	r4,r23,r3
 82047d4:	820c5540 	call	820c554 <memchr>
 82047d8:	103fe81e 	bne	r2,zero,820477c <strstr+0x274>
 82047dc:	983fe726 	beq	r19,zero,820477c <strstr+0x274>
 82047e0:	e400132e 	bgeu	fp,r16,8204830 <strstr+0x328>
 82047e4:	bf07883a 	add	r3,r23,fp
 82047e8:	1d47883a 	add	r3,r3,r21
 82047ec:	b705883a 	add	r2,r22,fp
 82047f0:	18c00003 	ldbu	r3,0(r3)
 82047f4:	10800003 	ldbu	r2,0(r2)
 82047f8:	1880241e 	bne	r3,r2,820488c <strstr+0x384>
 82047fc:	ac45883a 	add	r2,r21,r17
 8204800:	b44b883a 	add	r5,r22,r17
 8204804:	b885883a 	add	r2,r23,r2
 8204808:	e009883a 	mov	r4,fp
 820480c:	00000606 	br	8204828 <strstr+0x320>
 8204810:	29800003 	ldbu	r6,0(r5)
 8204814:	10c00003 	ldbu	r3,0(r2)
 8204818:	29400044 	addi	r5,r5,1
 820481c:	31803fcc 	andi	r6,r6,255
 8204820:	10800044 	addi	r2,r2,1
 8204824:	30c01a1e 	bne	r6,r3,8204890 <strstr+0x388>
 8204828:	21000044 	addi	r4,r4,1
 820482c:	243ff836 	bltu	r4,r16,8204810 <strstr+0x308>
 8204830:	00bfffc4 	movi	r2,-1
 8204834:	bd49883a 	add	r4,r23,r21
 8204838:	90801926 	beq	r18,r2,82048a0 <strstr+0x398>
 820483c:	d9400317 	ldw	r5,12(sp)
 8204840:	2485883a 	add	r2,r4,r18
 8204844:	10800003 	ldbu	r2,0(r2)
 8204848:	28c00003 	ldbu	r3,0(r5)
 820484c:	18800b1e 	bne	r3,r2,820487c <strstr+0x374>
 8204850:	d8c00117 	ldw	r3,4(sp)
 8204854:	a8c5883a 	add	r2,r21,r3
 8204858:	b885883a 	add	r2,r23,r2
 820485c:	b0c7883a 	add	r3,r22,r3
 8204860:	1d000f26 	beq	r3,r20,82048a0 <strstr+0x398>
 8204864:	19800003 	ldbu	r6,0(r3)
 8204868:	11400003 	ldbu	r5,0(r2)
 820486c:	18ffffc4 	addi	r3,r3,-1
 8204870:	31803fcc 	andi	r6,r6,255
 8204874:	10bfffc4 	addi	r2,r2,-1
 8204878:	317ff926 	beq	r6,r5,8204860 <strstr+0x358>
 820487c:	d8800017 	ldw	r2,0(sp)
 8204880:	a8ab883a 	add	r21,r21,r2
 8204884:	9807883a 	mov	r3,r19
 8204888:	003fce06 	br	82047c4 <strstr+0x2bc>
 820488c:	e009883a 	mov	r4,fp
 8204890:	d8c00217 	ldw	r3,8(sp)
 8204894:	1d4f883a 	add	r7,r3,r21
 8204898:	392b883a 	add	r21,r7,r4
 820489c:	003ff906 	br	8204884 <strstr+0x37c>
 82048a0:	2005883a 	mov	r2,r4
 82048a4:	003f4c06 	br	82045d8 <strstr+0xd0>
 82048a8:	e00d883a 	mov	r6,fp
 82048ac:	003fa306 	br	820473c <strstr+0x234>
 82048b0:	bd45883a 	add	r2,r23,r21
 82048b4:	003f4806 	br	82045d8 <strstr+0xd0>

082048b8 <___svfprintf_internal_r>:
 82048b8:	deffb704 	addi	sp,sp,-292
 82048bc:	dfc04815 	stw	ra,288(sp)
 82048c0:	ddc04615 	stw	r23,280(sp)
 82048c4:	d9402c15 	stw	r5,176(sp)
 82048c8:	d9003915 	stw	r4,228(sp)
 82048cc:	302f883a 	mov	r23,r6
 82048d0:	d9c02d15 	stw	r7,180(sp)
 82048d4:	df004715 	stw	fp,284(sp)
 82048d8:	dd804515 	stw	r22,276(sp)
 82048dc:	dd404415 	stw	r21,272(sp)
 82048e0:	dd004315 	stw	r20,268(sp)
 82048e4:	dcc04215 	stw	r19,264(sp)
 82048e8:	dc804115 	stw	r18,260(sp)
 82048ec:	dc404015 	stw	r17,256(sp)
 82048f0:	dc003f15 	stw	r16,252(sp)
 82048f4:	820bb5c0 	call	820bb5c <_localeconv_r>
 82048f8:	10800017 	ldw	r2,0(r2)
 82048fc:	1009883a 	mov	r4,r2
 8204900:	d8803415 	stw	r2,208(sp)
 8204904:	8203fbc0 	call	8203fbc <strlen>
 8204908:	d8c02c17 	ldw	r3,176(sp)
 820490c:	d8803815 	stw	r2,224(sp)
 8204910:	1880030b 	ldhu	r2,12(r3)
 8204914:	1080200c 	andi	r2,r2,128
 8204918:	10000226 	beq	r2,zero,8204924 <___svfprintf_internal_r+0x6c>
 820491c:	18800417 	ldw	r2,16(r3)
 8204920:	10067f26 	beq	r2,zero,8206320 <___svfprintf_internal_r+0x1a68>
 8204924:	dcc03917 	ldw	r19,228(sp)
 8204928:	d8c00404 	addi	r3,sp,16
 820492c:	05420974 	movhi	r21,2085
 8204930:	d9001e04 	addi	r4,sp,120
 8204934:	ad76ec84 	addi	r21,r21,-9294
 8204938:	d8c01e15 	stw	r3,120(sp)
 820493c:	d8002015 	stw	zero,128(sp)
 8204940:	d8001f15 	stw	zero,124(sp)
 8204944:	d8003315 	stw	zero,204(sp)
 8204948:	d8003615 	stw	zero,216(sp)
 820494c:	d8003715 	stw	zero,220(sp)
 8204950:	1811883a 	mov	r8,r3
 8204954:	d8003a15 	stw	zero,232(sp)
 8204958:	d8003b15 	stw	zero,236(sp)
 820495c:	d8002f15 	stw	zero,188(sp)
 8204960:	d9002815 	stw	r4,160(sp)
 8204964:	b8800007 	ldb	r2,0(r23)
 8204968:	10026726 	beq	r2,zero,8205308 <___svfprintf_internal_r+0xa50>
 820496c:	00c00944 	movi	r3,37
 8204970:	b821883a 	mov	r16,r23
 8204974:	10c0021e 	bne	r2,r3,8204980 <___svfprintf_internal_r+0xc8>
 8204978:	00001406 	br	82049cc <___svfprintf_internal_r+0x114>
 820497c:	10c00326 	beq	r2,r3,820498c <___svfprintf_internal_r+0xd4>
 8204980:	84000044 	addi	r16,r16,1
 8204984:	80800007 	ldb	r2,0(r16)
 8204988:	103ffc1e 	bne	r2,zero,820497c <___svfprintf_internal_r+0xc4>
 820498c:	85e3c83a 	sub	r17,r16,r23
 8204990:	88000e26 	beq	r17,zero,82049cc <___svfprintf_internal_r+0x114>
 8204994:	d8c02017 	ldw	r3,128(sp)
 8204998:	d8801f17 	ldw	r2,124(sp)
 820499c:	45c00015 	stw	r23,0(r8)
 82049a0:	1c47883a 	add	r3,r3,r17
 82049a4:	10800044 	addi	r2,r2,1
 82049a8:	d8c02015 	stw	r3,128(sp)
 82049ac:	44400115 	stw	r17,4(r8)
 82049b0:	d8801f15 	stw	r2,124(sp)
 82049b4:	00c001c4 	movi	r3,7
 82049b8:	18809716 	blt	r3,r2,8204c18 <___svfprintf_internal_r+0x360>
 82049bc:	42000204 	addi	r8,r8,8
 82049c0:	d9402f17 	ldw	r5,188(sp)
 82049c4:	2c4b883a 	add	r5,r5,r17
 82049c8:	d9402f15 	stw	r5,188(sp)
 82049cc:	80800007 	ldb	r2,0(r16)
 82049d0:	10009826 	beq	r2,zero,8204c34 <___svfprintf_internal_r+0x37c>
 82049d4:	84400047 	ldb	r17,1(r16)
 82049d8:	00bfffc4 	movi	r2,-1
 82049dc:	85c00044 	addi	r23,r16,1
 82049e0:	d8002785 	stb	zero,158(sp)
 82049e4:	0007883a 	mov	r3,zero
 82049e8:	000f883a 	mov	r7,zero
 82049ec:	d8802915 	stw	r2,164(sp)
 82049f0:	d8003115 	stw	zero,196(sp)
 82049f4:	0025883a 	mov	r18,zero
 82049f8:	01401604 	movi	r5,88
 82049fc:	01800244 	movi	r6,9
 8204a00:	02800a84 	movi	r10,42
 8204a04:	02401b04 	movi	r9,108
 8204a08:	bdc00044 	addi	r23,r23,1
 8204a0c:	88bff804 	addi	r2,r17,-32
 8204a10:	2882f036 	bltu	r5,r2,82055d4 <___svfprintf_internal_r+0xd1c>
 8204a14:	100490ba 	slli	r2,r2,2
 8204a18:	01020834 	movhi	r4,2080
 8204a1c:	21128b04 	addi	r4,r4,18988
 8204a20:	1105883a 	add	r2,r2,r4
 8204a24:	10800017 	ldw	r2,0(r2)
 8204a28:	1000683a 	jmp	r2
 8204a2c:	0820553c 	xorhi	zero,at,33108
 8204a30:	082055d4 	ori	zero,at,33111
 8204a34:	082055d4 	ori	zero,at,33111
 8204a38:	08205530 	cmpltui	zero,at,33108
 8204a3c:	082055d4 	ori	zero,at,33111
 8204a40:	082055d4 	ori	zero,at,33111
 8204a44:	082055d4 	ori	zero,at,33111
 8204a48:	082055d4 	ori	zero,at,33111
 8204a4c:	082055d4 	ori	zero,at,33111
 8204a50:	082055d4 	ori	zero,at,33111
 8204a54:	08204c90 	cmplti	zero,at,-32462
 8204a58:	0820546c 	andhi	zero,at,33105
 8204a5c:	082055d4 	ori	zero,at,33111
 8204a60:	08204ba0 	cmpeqi	zero,at,-32466
 8204a64:	08204cb8 	rdprs	zero,at,-32462
 8204a68:	082055d4 	ori	zero,at,33111
 8204a6c:	08204d2c 	andhi	zero,at,33076
 8204a70:	08204cf8 	rdprs	zero,at,-32461
 8204a74:	08204cf8 	rdprs	zero,at,-32461
 8204a78:	08204cf8 	rdprs	zero,at,-32461
 8204a7c:	08204cf8 	rdprs	zero,at,-32461
 8204a80:	08204cf8 	rdprs	zero,at,-32461
 8204a84:	08204cf8 	rdprs	zero,at,-32461
 8204a88:	08204cf8 	rdprs	zero,at,-32461
 8204a8c:	08204cf8 	rdprs	zero,at,-32461
 8204a90:	08204cf8 	rdprs	zero,at,-32461
 8204a94:	082055d4 	ori	zero,at,33111
 8204a98:	082055d4 	ori	zero,at,33111
 8204a9c:	082055d4 	ori	zero,at,33111
 8204aa0:	082055d4 	ori	zero,at,33111
 8204aa4:	082055d4 	ori	zero,at,33111
 8204aa8:	082055d4 	ori	zero,at,33111
 8204aac:	082055d4 	ori	zero,at,33111
 8204ab0:	082055d4 	ori	zero,at,33111
 8204ab4:	082055d4 	ori	zero,at,33111
 8204ab8:	082055d4 	ori	zero,at,33111
 8204abc:	08204de4 	muli	zero,at,-32457
 8204ac0:	08204d38 	rdprs	zero,at,-32460
 8204ac4:	082055d4 	ori	zero,at,33111
 8204ac8:	08204d38 	rdprs	zero,at,-32460
 8204acc:	082055d4 	ori	zero,at,33111
 8204ad0:	082055d4 	ori	zero,at,33111
 8204ad4:	082055d4 	ori	zero,at,33111
 8204ad8:	082055d4 	ori	zero,at,33111
 8204adc:	08204dd8 	cmpnei	zero,at,-32457
 8204ae0:	082055d4 	ori	zero,at,33111
 8204ae4:	082055d4 	ori	zero,at,33111
 8204ae8:	08204ea0 	cmpeqi	zero,at,-32454
 8204aec:	082055d4 	ori	zero,at,33111
 8204af0:	082055d4 	ori	zero,at,33111
 8204af4:	082055d4 	ori	zero,at,33111
 8204af8:	082055d4 	ori	zero,at,33111
 8204afc:	082055d4 	ori	zero,at,33111
 8204b00:	08205310 	cmplti	zero,at,-32436
 8204b04:	082055d4 	ori	zero,at,33111
 8204b08:	082055d4 	ori	zero,at,33111
 8204b0c:	08205370 	cmpltui	zero,at,33101
 8204b10:	082055d4 	ori	zero,at,33111
 8204b14:	082055d4 	ori	zero,at,33111
 8204b18:	082055d4 	ori	zero,at,33111
 8204b1c:	082055d4 	ori	zero,at,33111
 8204b20:	082055d4 	ori	zero,at,33111
 8204b24:	082055d4 	ori	zero,at,33111
 8204b28:	082055d4 	ori	zero,at,33111
 8204b2c:	082055d4 	ori	zero,at,33111
 8204b30:	082055d4 	ori	zero,at,33111
 8204b34:	082055d4 	ori	zero,at,33111
 8204b38:	08205420 	cmpeqi	zero,at,-32432
 8204b3c:	0820555c 	xori	zero,at,33109
 8204b40:	08204d38 	rdprs	zero,at,-32460
 8204b44:	08204d38 	rdprs	zero,at,-32460
 8204b48:	08204d38 	rdprs	zero,at,-32460
 8204b4c:	082055b0 	cmpltui	zero,at,33110
 8204b50:	0820555c 	xori	zero,at,33109
 8204b54:	082055d4 	ori	zero,at,33111
 8204b58:	082055d4 	ori	zero,at,33111
 8204b5c:	0820556c 	andhi	zero,at,33109
 8204b60:	082055d4 	ori	zero,at,33111
 8204b64:	0820557c 	xorhi	zero,at,33109
 8204b68:	0820545c 	xori	zero,at,33105
 8204b6c:	08204bac 	andhi	zero,at,33070
 8204b70:	0820547c 	xorhi	zero,at,33105
 8204b74:	082055d4 	ori	zero,at,33111
 8204b78:	08205488 	cmpgei	zero,at,-32430
 8204b7c:	082055d4 	ori	zero,at,33111
 8204b80:	082054e4 	muli	zero,at,-32429
 8204b84:	082055d4 	ori	zero,at,33111
 8204b88:	082055d4 	ori	zero,at,33111
 8204b8c:	082054f4 	orhi	zero,at,33107
 8204b90:	d9003117 	ldw	r4,196(sp)
 8204b94:	d8802d15 	stw	r2,180(sp)
 8204b98:	0109c83a 	sub	r4,zero,r4
 8204b9c:	d9003115 	stw	r4,196(sp)
 8204ba0:	94800114 	ori	r18,r18,4
 8204ba4:	bc400007 	ldb	r17,0(r23)
 8204ba8:	003f9706 	br	8204a08 <___svfprintf_internal_r+0x150>
 8204bac:	00800c04 	movi	r2,48
 8204bb0:	d9002d17 	ldw	r4,180(sp)
 8204bb4:	d9402917 	ldw	r5,164(sp)
 8204bb8:	d8802705 	stb	r2,156(sp)
 8204bbc:	00801e04 	movi	r2,120
 8204bc0:	d8802745 	stb	r2,157(sp)
 8204bc4:	d8002785 	stb	zero,158(sp)
 8204bc8:	20c00104 	addi	r3,r4,4
 8204bcc:	25000017 	ldw	r20,0(r4)
 8204bd0:	002d883a 	mov	r22,zero
 8204bd4:	90800094 	ori	r2,r18,2
 8204bd8:	28028616 	blt	r5,zero,82055f4 <___svfprintf_internal_r+0xd3c>
 8204bdc:	00bfdfc4 	movi	r2,-129
 8204be0:	90a4703a 	and	r18,r18,r2
 8204be4:	d8c02d15 	stw	r3,180(sp)
 8204be8:	94800094 	ori	r18,r18,2
 8204bec:	a002731e 	bne	r20,zero,82055bc <___svfprintf_internal_r+0xd04>
 8204bf0:	00820974 	movhi	r2,2085
 8204bf4:	10b6e504 	addi	r2,r2,-9324
 8204bf8:	d8803a15 	stw	r2,232(sp)
 8204bfc:	04401e04 	movi	r17,120
 8204c00:	d8c02917 	ldw	r3,164(sp)
 8204c04:	0039883a 	mov	fp,zero
 8204c08:	1801d526 	beq	r3,zero,8205360 <___svfprintf_internal_r+0xaa8>
 8204c0c:	0029883a 	mov	r20,zero
 8204c10:	002d883a 	mov	r22,zero
 8204c14:	0001f106 	br	82053dc <___svfprintf_internal_r+0xb24>
 8204c18:	d9402c17 	ldw	r5,176(sp)
 8204c1c:	d9801e04 	addi	r6,sp,120
 8204c20:	9809883a 	mov	r4,r19
 8204c24:	820e0e40 	call	820e0e4 <__ssprint_r>
 8204c28:	1000081e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 8204c2c:	da000404 	addi	r8,sp,16
 8204c30:	003f6306 	br	82049c0 <___svfprintf_internal_r+0x108>
 8204c34:	d8802017 	ldw	r2,128(sp)
 8204c38:	10000426 	beq	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 8204c3c:	d9402c17 	ldw	r5,176(sp)
 8204c40:	d9003917 	ldw	r4,228(sp)
 8204c44:	d9801e04 	addi	r6,sp,120
 8204c48:	820e0e40 	call	820e0e4 <__ssprint_r>
 8204c4c:	d8802c17 	ldw	r2,176(sp)
 8204c50:	10c0030b 	ldhu	r3,12(r2)
 8204c54:	d8802f17 	ldw	r2,188(sp)
 8204c58:	18c0100c 	andi	r3,r3,64
 8204c5c:	1805f51e 	bne	r3,zero,8206434 <___svfprintf_internal_r+0x1b7c>
 8204c60:	dfc04817 	ldw	ra,288(sp)
 8204c64:	df004717 	ldw	fp,284(sp)
 8204c68:	ddc04617 	ldw	r23,280(sp)
 8204c6c:	dd804517 	ldw	r22,276(sp)
 8204c70:	dd404417 	ldw	r21,272(sp)
 8204c74:	dd004317 	ldw	r20,268(sp)
 8204c78:	dcc04217 	ldw	r19,264(sp)
 8204c7c:	dc804117 	ldw	r18,260(sp)
 8204c80:	dc404017 	ldw	r17,256(sp)
 8204c84:	dc003f17 	ldw	r16,252(sp)
 8204c88:	dec04904 	addi	sp,sp,292
 8204c8c:	f800283a 	ret
 8204c90:	d8802d17 	ldw	r2,180(sp)
 8204c94:	d9002d17 	ldw	r4,180(sp)
 8204c98:	10800017 	ldw	r2,0(r2)
 8204c9c:	d8803115 	stw	r2,196(sp)
 8204ca0:	20800104 	addi	r2,r4,4
 8204ca4:	d9003117 	ldw	r4,196(sp)
 8204ca8:	203fb916 	blt	r4,zero,8204b90 <___svfprintf_internal_r+0x2d8>
 8204cac:	d8802d15 	stw	r2,180(sp)
 8204cb0:	bc400007 	ldb	r17,0(r23)
 8204cb4:	003f5406 	br	8204a08 <___svfprintf_internal_r+0x150>
 8204cb8:	bc400007 	ldb	r17,0(r23)
 8204cbc:	bac00044 	addi	r11,r23,1
 8204cc0:	8a873926 	beq	r17,r10,82069a8 <___svfprintf_internal_r+0x20f0>
 8204cc4:	88bff404 	addi	r2,r17,-48
 8204cc8:	0009883a 	mov	r4,zero
 8204ccc:	30868836 	bltu	r6,r2,82066f0 <___svfprintf_internal_r+0x1e38>
 8204cd0:	5c400007 	ldb	r17,0(r11)
 8204cd4:	210002a4 	muli	r4,r4,10
 8204cd8:	5dc00044 	addi	r23,r11,1
 8204cdc:	b817883a 	mov	r11,r23
 8204ce0:	2089883a 	add	r4,r4,r2
 8204ce4:	88bff404 	addi	r2,r17,-48
 8204ce8:	30bff92e 	bgeu	r6,r2,8204cd0 <___svfprintf_internal_r+0x418>
 8204cec:	2005d716 	blt	r4,zero,820644c <___svfprintf_internal_r+0x1b94>
 8204cf0:	d9002915 	stw	r4,164(sp)
 8204cf4:	003f4506 	br	8204a0c <___svfprintf_internal_r+0x154>
 8204cf8:	b809883a 	mov	r4,r23
 8204cfc:	d8003115 	stw	zero,196(sp)
 8204d00:	88bff404 	addi	r2,r17,-48
 8204d04:	0017883a 	mov	r11,zero
 8204d08:	24400007 	ldb	r17,0(r4)
 8204d0c:	5ac002a4 	muli	r11,r11,10
 8204d10:	bdc00044 	addi	r23,r23,1
 8204d14:	b809883a 	mov	r4,r23
 8204d18:	12d7883a 	add	r11,r2,r11
 8204d1c:	88bff404 	addi	r2,r17,-48
 8204d20:	30bff92e 	bgeu	r6,r2,8204d08 <___svfprintf_internal_r+0x450>
 8204d24:	dac03115 	stw	r11,196(sp)
 8204d28:	003f3806 	br	8204a0c <___svfprintf_internal_r+0x154>
 8204d2c:	94802014 	ori	r18,r18,128
 8204d30:	bc400007 	ldb	r17,0(r23)
 8204d34:	003f3406 	br	8204a08 <___svfprintf_internal_r+0x150>
 8204d38:	18c03fcc 	andi	r3,r3,255
 8204d3c:	1807471e 	bne	r3,zero,8206a5c <___svfprintf_internal_r+0x21a4>
 8204d40:	9080020c 	andi	r2,r18,8
 8204d44:	10047d26 	beq	r2,zero,8205f3c <___svfprintf_internal_r+0x1684>
 8204d48:	d8c02d17 	ldw	r3,180(sp)
 8204d4c:	d9002d17 	ldw	r4,180(sp)
 8204d50:	d9402d17 	ldw	r5,180(sp)
 8204d54:	18c00017 	ldw	r3,0(r3)
 8204d58:	21000117 	ldw	r4,4(r4)
 8204d5c:	29400204 	addi	r5,r5,8
 8204d60:	d8c03615 	stw	r3,216(sp)
 8204d64:	d9003715 	stw	r4,220(sp)
 8204d68:	d9402d15 	stw	r5,180(sp)
 8204d6c:	d9003617 	ldw	r4,216(sp)
 8204d70:	d9403717 	ldw	r5,220(sp)
 8204d74:	da003e15 	stw	r8,248(sp)
 8204d78:	04000044 	movi	r16,1
 8204d7c:	820de040 	call	820de04 <__fpclassifyd>
 8204d80:	da003e17 	ldw	r8,248(sp)
 8204d84:	14044b1e 	bne	r2,r16,8205eb4 <___svfprintf_internal_r+0x15fc>
 8204d88:	d9003617 	ldw	r4,216(sp)
 8204d8c:	d9403717 	ldw	r5,220(sp)
 8204d90:	000d883a 	mov	r6,zero
 8204d94:	000f883a 	mov	r7,zero
 8204d98:	82130bc0 	call	82130bc <__ledf2>
 8204d9c:	da003e17 	ldw	r8,248(sp)
 8204da0:	1005f316 	blt	r2,zero,8206570 <___svfprintf_internal_r+0x1cb8>
 8204da4:	df002783 	ldbu	fp,158(sp)
 8204da8:	008011c4 	movi	r2,71
 8204dac:	1445590e 	bge	r2,r17,8206314 <___svfprintf_internal_r+0x1a5c>
 8204db0:	04020974 	movhi	r16,2085
 8204db4:	8436dd04 	addi	r16,r16,-9356
 8204db8:	00c000c4 	movi	r3,3
 8204dbc:	00bfdfc4 	movi	r2,-129
 8204dc0:	d8c02a15 	stw	r3,168(sp)
 8204dc4:	90a4703a 	and	r18,r18,r2
 8204dc8:	d8c02e15 	stw	r3,184(sp)
 8204dcc:	d8002915 	stw	zero,164(sp)
 8204dd0:	d8003215 	stw	zero,200(sp)
 8204dd4:	00006606 	br	8204f70 <___svfprintf_internal_r+0x6b8>
 8204dd8:	94800214 	ori	r18,r18,8
 8204ddc:	bc400007 	ldb	r17,0(r23)
 8204de0:	003f0906 	br	8204a08 <___svfprintf_internal_r+0x150>
 8204de4:	18c03fcc 	andi	r3,r3,255
 8204de8:	1807181e 	bne	r3,zero,8206a4c <___svfprintf_internal_r+0x2194>
 8204dec:	94800414 	ori	r18,r18,16
 8204df0:	9080080c 	andi	r2,r18,32
 8204df4:	10039626 	beq	r2,zero,8205c50 <___svfprintf_internal_r+0x1398>
 8204df8:	d9402d17 	ldw	r5,180(sp)
 8204dfc:	28800117 	ldw	r2,4(r5)
 8204e00:	2d000017 	ldw	r20,0(r5)
 8204e04:	29400204 	addi	r5,r5,8
 8204e08:	d9402d15 	stw	r5,180(sp)
 8204e0c:	102d883a 	mov	r22,r2
 8204e10:	10039816 	blt	r2,zero,8205c74 <___svfprintf_internal_r+0x13bc>
 8204e14:	d9402917 	ldw	r5,164(sp)
 8204e18:	df002783 	ldbu	fp,158(sp)
 8204e1c:	2803ab16 	blt	r5,zero,8205ccc <___svfprintf_internal_r+0x1414>
 8204e20:	00ffdfc4 	movi	r3,-129
 8204e24:	a584b03a 	or	r2,r20,r22
 8204e28:	90e4703a 	and	r18,r18,r3
 8204e2c:	10014a26 	beq	r2,zero,8205358 <___svfprintf_internal_r+0xaa0>
 8204e30:	b0034b26 	beq	r22,zero,8205b60 <___svfprintf_internal_r+0x12a8>
 8204e34:	dc402a15 	stw	r17,168(sp)
 8204e38:	dc001e04 	addi	r16,sp,120
 8204e3c:	b023883a 	mov	r17,r22
 8204e40:	402d883a 	mov	r22,r8
 8204e44:	a009883a 	mov	r4,r20
 8204e48:	880b883a 	mov	r5,r17
 8204e4c:	01800284 	movi	r6,10
 8204e50:	000f883a 	mov	r7,zero
 8204e54:	821188c0 	call	821188c <__umoddi3>
 8204e58:	10800c04 	addi	r2,r2,48
 8204e5c:	843fffc4 	addi	r16,r16,-1
 8204e60:	a009883a 	mov	r4,r20
 8204e64:	880b883a 	mov	r5,r17
 8204e68:	80800005 	stb	r2,0(r16)
 8204e6c:	01800284 	movi	r6,10
 8204e70:	000f883a 	mov	r7,zero
 8204e74:	82113140 	call	8211314 <__udivdi3>
 8204e78:	1029883a 	mov	r20,r2
 8204e7c:	10c4b03a 	or	r2,r2,r3
 8204e80:	1823883a 	mov	r17,r3
 8204e84:	103fef1e 	bne	r2,zero,8204e44 <___svfprintf_internal_r+0x58c>
 8204e88:	d8c02817 	ldw	r3,160(sp)
 8204e8c:	dc402a17 	ldw	r17,168(sp)
 8204e90:	b011883a 	mov	r8,r22
 8204e94:	1c07c83a 	sub	r3,r3,r16
 8204e98:	d8c02e15 	stw	r3,184(sp)
 8204e9c:	00002e06 	br	8204f58 <___svfprintf_internal_r+0x6a0>
 8204ea0:	18c03fcc 	andi	r3,r3,255
 8204ea4:	1806e71e 	bne	r3,zero,8206a44 <___svfprintf_internal_r+0x218c>
 8204ea8:	94800414 	ori	r18,r18,16
 8204eac:	9080080c 	andi	r2,r18,32
 8204eb0:	1002d426 	beq	r2,zero,8205a04 <___svfprintf_internal_r+0x114c>
 8204eb4:	d9402d17 	ldw	r5,180(sp)
 8204eb8:	d8c02917 	ldw	r3,164(sp)
 8204ebc:	d8002785 	stb	zero,158(sp)
 8204ec0:	28800204 	addi	r2,r5,8
 8204ec4:	2d000017 	ldw	r20,0(r5)
 8204ec8:	2d800117 	ldw	r22,4(r5)
 8204ecc:	18041516 	blt	r3,zero,8205f24 <___svfprintf_internal_r+0x166c>
 8204ed0:	013fdfc4 	movi	r4,-129
 8204ed4:	a586b03a 	or	r3,r20,r22
 8204ed8:	d8802d15 	stw	r2,180(sp)
 8204edc:	9124703a 	and	r18,r18,r4
 8204ee0:	1802d51e 	bne	r3,zero,8205a38 <___svfprintf_internal_r+0x1180>
 8204ee4:	d9402917 	ldw	r5,164(sp)
 8204ee8:	0039883a 	mov	fp,zero
 8204eec:	2806be26 	beq	r5,zero,82069e8 <___svfprintf_internal_r+0x2130>
 8204ef0:	0029883a 	mov	r20,zero
 8204ef4:	002d883a 	mov	r22,zero
 8204ef8:	dc001e04 	addi	r16,sp,120
 8204efc:	a006d0fa 	srli	r3,r20,3
 8204f00:	b008977a 	slli	r4,r22,29
 8204f04:	b02cd0fa 	srli	r22,r22,3
 8204f08:	a50001cc 	andi	r20,r20,7
 8204f0c:	a0800c04 	addi	r2,r20,48
 8204f10:	843fffc4 	addi	r16,r16,-1
 8204f14:	20e8b03a 	or	r20,r4,r3
 8204f18:	80800005 	stb	r2,0(r16)
 8204f1c:	a586b03a 	or	r3,r20,r22
 8204f20:	183ff61e 	bne	r3,zero,8204efc <___svfprintf_internal_r+0x644>
 8204f24:	90c0004c 	andi	r3,r18,1
 8204f28:	18013926 	beq	r3,zero,8205410 <___svfprintf_internal_r+0xb58>
 8204f2c:	10803fcc 	andi	r2,r2,255
 8204f30:	1080201c 	xori	r2,r2,128
 8204f34:	10bfe004 	addi	r2,r2,-128
 8204f38:	00c00c04 	movi	r3,48
 8204f3c:	10c13426 	beq	r2,r3,8205410 <___svfprintf_internal_r+0xb58>
 8204f40:	80ffffc5 	stb	r3,-1(r16)
 8204f44:	d8c02817 	ldw	r3,160(sp)
 8204f48:	80bfffc4 	addi	r2,r16,-1
 8204f4c:	1021883a 	mov	r16,r2
 8204f50:	1887c83a 	sub	r3,r3,r2
 8204f54:	d8c02e15 	stw	r3,184(sp)
 8204f58:	d8802e17 	ldw	r2,184(sp)
 8204f5c:	d9002917 	ldw	r4,164(sp)
 8204f60:	1100010e 	bge	r2,r4,8204f68 <___svfprintf_internal_r+0x6b0>
 8204f64:	2005883a 	mov	r2,r4
 8204f68:	d8802a15 	stw	r2,168(sp)
 8204f6c:	d8003215 	stw	zero,200(sp)
 8204f70:	e7003fcc 	andi	fp,fp,255
 8204f74:	e700201c 	xori	fp,fp,128
 8204f78:	e73fe004 	addi	fp,fp,-128
 8204f7c:	e0000326 	beq	fp,zero,8204f8c <___svfprintf_internal_r+0x6d4>
 8204f80:	d8c02a17 	ldw	r3,168(sp)
 8204f84:	18c00044 	addi	r3,r3,1
 8204f88:	d8c02a15 	stw	r3,168(sp)
 8204f8c:	90c0008c 	andi	r3,r18,2
 8204f90:	d8c02b15 	stw	r3,172(sp)
 8204f94:	18000326 	beq	r3,zero,8204fa4 <___svfprintf_internal_r+0x6ec>
 8204f98:	d8c02a17 	ldw	r3,168(sp)
 8204f9c:	18c00084 	addi	r3,r3,2
 8204fa0:	d8c02a15 	stw	r3,168(sp)
 8204fa4:	90c0210c 	andi	r3,r18,132
 8204fa8:	d8c03015 	stw	r3,192(sp)
 8204fac:	1801a11e 	bne	r3,zero,8205634 <___svfprintf_internal_r+0xd7c>
 8204fb0:	d9003117 	ldw	r4,196(sp)
 8204fb4:	d8c02a17 	ldw	r3,168(sp)
 8204fb8:	20e9c83a 	sub	r20,r4,r3
 8204fbc:	05019d0e 	bge	zero,r20,8205634 <___svfprintf_internal_r+0xd7c>
 8204fc0:	02400404 	movi	r9,16
 8204fc4:	d8c02017 	ldw	r3,128(sp)
 8204fc8:	d8801f17 	ldw	r2,124(sp)
 8204fcc:	4d051b0e 	bge	r9,r20,820643c <___svfprintf_internal_r+0x1b84>
 8204fd0:	01420974 	movhi	r5,2085
 8204fd4:	2976f084 	addi	r5,r5,-9278
 8204fd8:	dc403c15 	stw	r17,240(sp)
 8204fdc:	d9403515 	stw	r5,212(sp)
 8204fe0:	a023883a 	mov	r17,r20
 8204fe4:	482d883a 	mov	r22,r9
 8204fe8:	9029883a 	mov	r20,r18
 8204fec:	070001c4 	movi	fp,7
 8204ff0:	8025883a 	mov	r18,r16
 8204ff4:	dc002c17 	ldw	r16,176(sp)
 8204ff8:	00000306 	br	8205008 <___svfprintf_internal_r+0x750>
 8204ffc:	8c7ffc04 	addi	r17,r17,-16
 8205000:	42000204 	addi	r8,r8,8
 8205004:	b440130e 	bge	r22,r17,8205054 <___svfprintf_internal_r+0x79c>
 8205008:	01020974 	movhi	r4,2085
 820500c:	18c00404 	addi	r3,r3,16
 8205010:	10800044 	addi	r2,r2,1
 8205014:	2136f084 	addi	r4,r4,-9278
 8205018:	41000015 	stw	r4,0(r8)
 820501c:	45800115 	stw	r22,4(r8)
 8205020:	d8c02015 	stw	r3,128(sp)
 8205024:	d8801f15 	stw	r2,124(sp)
 8205028:	e0bff40e 	bge	fp,r2,8204ffc <___svfprintf_internal_r+0x744>
 820502c:	d9801e04 	addi	r6,sp,120
 8205030:	800b883a 	mov	r5,r16
 8205034:	9809883a 	mov	r4,r19
 8205038:	820e0e40 	call	820e0e4 <__ssprint_r>
 820503c:	103f031e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 8205040:	8c7ffc04 	addi	r17,r17,-16
 8205044:	d8c02017 	ldw	r3,128(sp)
 8205048:	d8801f17 	ldw	r2,124(sp)
 820504c:	da000404 	addi	r8,sp,16
 8205050:	b47fed16 	blt	r22,r17,8205008 <___svfprintf_internal_r+0x750>
 8205054:	9021883a 	mov	r16,r18
 8205058:	a025883a 	mov	r18,r20
 820505c:	8829883a 	mov	r20,r17
 8205060:	dc403c17 	ldw	r17,240(sp)
 8205064:	d9403517 	ldw	r5,212(sp)
 8205068:	a0c7883a 	add	r3,r20,r3
 820506c:	10800044 	addi	r2,r2,1
 8205070:	41400015 	stw	r5,0(r8)
 8205074:	45000115 	stw	r20,4(r8)
 8205078:	d8c02015 	stw	r3,128(sp)
 820507c:	d8801f15 	stw	r2,124(sp)
 8205080:	010001c4 	movi	r4,7
 8205084:	20829f16 	blt	r4,r2,8205b04 <___svfprintf_internal_r+0x124c>
 8205088:	df002787 	ldb	fp,158(sp)
 820508c:	42000204 	addi	r8,r8,8
 8205090:	e0000c26 	beq	fp,zero,82050c4 <___svfprintf_internal_r+0x80c>
 8205094:	d8801f17 	ldw	r2,124(sp)
 8205098:	d9002784 	addi	r4,sp,158
 820509c:	18c00044 	addi	r3,r3,1
 82050a0:	10800044 	addi	r2,r2,1
 82050a4:	41000015 	stw	r4,0(r8)
 82050a8:	01000044 	movi	r4,1
 82050ac:	41000115 	stw	r4,4(r8)
 82050b0:	d8c02015 	stw	r3,128(sp)
 82050b4:	d8801f15 	stw	r2,124(sp)
 82050b8:	010001c4 	movi	r4,7
 82050bc:	20823816 	blt	r4,r2,82059a0 <___svfprintf_internal_r+0x10e8>
 82050c0:	42000204 	addi	r8,r8,8
 82050c4:	d8802b17 	ldw	r2,172(sp)
 82050c8:	10000c26 	beq	r2,zero,82050fc <___svfprintf_internal_r+0x844>
 82050cc:	d8801f17 	ldw	r2,124(sp)
 82050d0:	d9002704 	addi	r4,sp,156
 82050d4:	18c00084 	addi	r3,r3,2
 82050d8:	10800044 	addi	r2,r2,1
 82050dc:	41000015 	stw	r4,0(r8)
 82050e0:	01000084 	movi	r4,2
 82050e4:	41000115 	stw	r4,4(r8)
 82050e8:	d8c02015 	stw	r3,128(sp)
 82050ec:	d8801f15 	stw	r2,124(sp)
 82050f0:	010001c4 	movi	r4,7
 82050f4:	20823216 	blt	r4,r2,82059c0 <___svfprintf_internal_r+0x1108>
 82050f8:	42000204 	addi	r8,r8,8
 82050fc:	d9003017 	ldw	r4,192(sp)
 8205100:	00802004 	movi	r2,128
 8205104:	20819726 	beq	r4,r2,8205764 <___svfprintf_internal_r+0xeac>
 8205108:	d9402917 	ldw	r5,164(sp)
 820510c:	d8802e17 	ldw	r2,184(sp)
 8205110:	28adc83a 	sub	r22,r5,r2
 8205114:	05802f0e 	bge	zero,r22,82051d4 <___svfprintf_internal_r+0x91c>
 8205118:	07000404 	movi	fp,16
 820511c:	d8801f17 	ldw	r2,124(sp)
 8205120:	e583c00e 	bge	fp,r22,8206024 <___svfprintf_internal_r+0x176c>
 8205124:	01420974 	movhi	r5,2085
 8205128:	2976ec84 	addi	r5,r5,-9294
 820512c:	dc402915 	stw	r17,164(sp)
 8205130:	d9402b15 	stw	r5,172(sp)
 8205134:	b023883a 	mov	r17,r22
 8205138:	050001c4 	movi	r20,7
 820513c:	902d883a 	mov	r22,r18
 8205140:	8025883a 	mov	r18,r16
 8205144:	dc002c17 	ldw	r16,176(sp)
 8205148:	00000306 	br	8205158 <___svfprintf_internal_r+0x8a0>
 820514c:	8c7ffc04 	addi	r17,r17,-16
 8205150:	42000204 	addi	r8,r8,8
 8205154:	e440110e 	bge	fp,r17,820519c <___svfprintf_internal_r+0x8e4>
 8205158:	18c00404 	addi	r3,r3,16
 820515c:	10800044 	addi	r2,r2,1
 8205160:	45400015 	stw	r21,0(r8)
 8205164:	47000115 	stw	fp,4(r8)
 8205168:	d8c02015 	stw	r3,128(sp)
 820516c:	d8801f15 	stw	r2,124(sp)
 8205170:	a0bff60e 	bge	r20,r2,820514c <___svfprintf_internal_r+0x894>
 8205174:	d9801e04 	addi	r6,sp,120
 8205178:	800b883a 	mov	r5,r16
 820517c:	9809883a 	mov	r4,r19
 8205180:	820e0e40 	call	820e0e4 <__ssprint_r>
 8205184:	103eb11e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 8205188:	8c7ffc04 	addi	r17,r17,-16
 820518c:	d8c02017 	ldw	r3,128(sp)
 8205190:	d8801f17 	ldw	r2,124(sp)
 8205194:	da000404 	addi	r8,sp,16
 8205198:	e47fef16 	blt	fp,r17,8205158 <___svfprintf_internal_r+0x8a0>
 820519c:	9021883a 	mov	r16,r18
 82051a0:	b025883a 	mov	r18,r22
 82051a4:	882d883a 	mov	r22,r17
 82051a8:	dc402917 	ldw	r17,164(sp)
 82051ac:	d9002b17 	ldw	r4,172(sp)
 82051b0:	1d87883a 	add	r3,r3,r22
 82051b4:	10800044 	addi	r2,r2,1
 82051b8:	41000015 	stw	r4,0(r8)
 82051bc:	45800115 	stw	r22,4(r8)
 82051c0:	d8c02015 	stw	r3,128(sp)
 82051c4:	d8801f15 	stw	r2,124(sp)
 82051c8:	010001c4 	movi	r4,7
 82051cc:	2081ec16 	blt	r4,r2,8205980 <___svfprintf_internal_r+0x10c8>
 82051d0:	42000204 	addi	r8,r8,8
 82051d4:	9080400c 	andi	r2,r18,256
 82051d8:	1001181e 	bne	r2,zero,820563c <___svfprintf_internal_r+0xd84>
 82051dc:	d9402e17 	ldw	r5,184(sp)
 82051e0:	d8801f17 	ldw	r2,124(sp)
 82051e4:	44000015 	stw	r16,0(r8)
 82051e8:	1947883a 	add	r3,r3,r5
 82051ec:	10800044 	addi	r2,r2,1
 82051f0:	41400115 	stw	r5,4(r8)
 82051f4:	d8c02015 	stw	r3,128(sp)
 82051f8:	d8801f15 	stw	r2,124(sp)
 82051fc:	010001c4 	movi	r4,7
 8205200:	2081d116 	blt	r4,r2,8205948 <___svfprintf_internal_r+0x1090>
 8205204:	42000204 	addi	r8,r8,8
 8205208:	9480010c 	andi	r18,r18,4
 820520c:	90003226 	beq	r18,zero,82052d8 <___svfprintf_internal_r+0xa20>
 8205210:	d9403117 	ldw	r5,196(sp)
 8205214:	d8802a17 	ldw	r2,168(sp)
 8205218:	28a1c83a 	sub	r16,r5,r2
 820521c:	04002e0e 	bge	zero,r16,82052d8 <___svfprintf_internal_r+0xa20>
 8205220:	04400404 	movi	r17,16
 8205224:	d8801f17 	ldw	r2,124(sp)
 8205228:	8c04b90e 	bge	r17,r16,8206510 <___svfprintf_internal_r+0x1c58>
 820522c:	01420974 	movhi	r5,2085
 8205230:	2976f084 	addi	r5,r5,-9278
 8205234:	d9403515 	stw	r5,212(sp)
 8205238:	048001c4 	movi	r18,7
 820523c:	dd002c17 	ldw	r20,176(sp)
 8205240:	00000306 	br	8205250 <___svfprintf_internal_r+0x998>
 8205244:	843ffc04 	addi	r16,r16,-16
 8205248:	42000204 	addi	r8,r8,8
 820524c:	8c00130e 	bge	r17,r16,820529c <___svfprintf_internal_r+0x9e4>
 8205250:	01020974 	movhi	r4,2085
 8205254:	18c00404 	addi	r3,r3,16
 8205258:	10800044 	addi	r2,r2,1
 820525c:	2136f084 	addi	r4,r4,-9278
 8205260:	41000015 	stw	r4,0(r8)
 8205264:	44400115 	stw	r17,4(r8)
 8205268:	d8c02015 	stw	r3,128(sp)
 820526c:	d8801f15 	stw	r2,124(sp)
 8205270:	90bff40e 	bge	r18,r2,8205244 <___svfprintf_internal_r+0x98c>
 8205274:	d9801e04 	addi	r6,sp,120
 8205278:	a00b883a 	mov	r5,r20
 820527c:	9809883a 	mov	r4,r19
 8205280:	820e0e40 	call	820e0e4 <__ssprint_r>
 8205284:	103e711e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 8205288:	843ffc04 	addi	r16,r16,-16
 820528c:	d8c02017 	ldw	r3,128(sp)
 8205290:	d8801f17 	ldw	r2,124(sp)
 8205294:	da000404 	addi	r8,sp,16
 8205298:	8c3fed16 	blt	r17,r16,8205250 <___svfprintf_internal_r+0x998>
 820529c:	d9403517 	ldw	r5,212(sp)
 82052a0:	1c07883a 	add	r3,r3,r16
 82052a4:	10800044 	addi	r2,r2,1
 82052a8:	41400015 	stw	r5,0(r8)
 82052ac:	44000115 	stw	r16,4(r8)
 82052b0:	d8c02015 	stw	r3,128(sp)
 82052b4:	d8801f15 	stw	r2,124(sp)
 82052b8:	010001c4 	movi	r4,7
 82052bc:	2080060e 	bge	r4,r2,82052d8 <___svfprintf_internal_r+0xa20>
 82052c0:	d9402c17 	ldw	r5,176(sp)
 82052c4:	d9801e04 	addi	r6,sp,120
 82052c8:	9809883a 	mov	r4,r19
 82052cc:	820e0e40 	call	820e0e4 <__ssprint_r>
 82052d0:	103e5e1e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 82052d4:	d8c02017 	ldw	r3,128(sp)
 82052d8:	d8803117 	ldw	r2,196(sp)
 82052dc:	d9002a17 	ldw	r4,168(sp)
 82052e0:	1100010e 	bge	r2,r4,82052e8 <___svfprintf_internal_r+0xa30>
 82052e4:	2005883a 	mov	r2,r4
 82052e8:	d9402f17 	ldw	r5,188(sp)
 82052ec:	288b883a 	add	r5,r5,r2
 82052f0:	d9402f15 	stw	r5,188(sp)
 82052f4:	18019c1e 	bne	r3,zero,8205968 <___svfprintf_internal_r+0x10b0>
 82052f8:	b8800007 	ldb	r2,0(r23)
 82052fc:	d8001f15 	stw	zero,124(sp)
 8205300:	da000404 	addi	r8,sp,16
 8205304:	103d991e 	bne	r2,zero,820496c <___svfprintf_internal_r+0xb4>
 8205308:	b821883a 	mov	r16,r23
 820530c:	003daf06 	br	82049cc <___svfprintf_internal_r+0x114>
 8205310:	18c03fcc 	andi	r3,r3,255
 8205314:	1805c71e 	bne	r3,zero,8206a34 <___svfprintf_internal_r+0x217c>
 8205318:	94800414 	ori	r18,r18,16
 820531c:	9080080c 	andi	r2,r18,32
 8205320:	10020126 	beq	r2,zero,8205b28 <___svfprintf_internal_r+0x1270>
 8205324:	d8802d17 	ldw	r2,180(sp)
 8205328:	d9002917 	ldw	r4,164(sp)
 820532c:	d8002785 	stb	zero,158(sp)
 8205330:	10c00204 	addi	r3,r2,8
 8205334:	15000017 	ldw	r20,0(r2)
 8205338:	15800117 	ldw	r22,4(r2)
 820533c:	20038e16 	blt	r4,zero,8206178 <___svfprintf_internal_r+0x18c0>
 8205340:	013fdfc4 	movi	r4,-129
 8205344:	a584b03a 	or	r2,r20,r22
 8205348:	d8c02d15 	stw	r3,180(sp)
 820534c:	9124703a 	and	r18,r18,r4
 8205350:	0039883a 	mov	fp,zero
 8205354:	103eb61e 	bne	r2,zero,8204e30 <___svfprintf_internal_r+0x578>
 8205358:	d8802917 	ldw	r2,164(sp)
 820535c:	1002c81e 	bne	r2,zero,8205e80 <___svfprintf_internal_r+0x15c8>
 8205360:	d8002915 	stw	zero,164(sp)
 8205364:	d8002e15 	stw	zero,184(sp)
 8205368:	dc001e04 	addi	r16,sp,120
 820536c:	003efa06 	br	8204f58 <___svfprintf_internal_r+0x6a0>
 8205370:	18c03fcc 	andi	r3,r3,255
 8205374:	1805ad1e 	bne	r3,zero,8206a2c <___svfprintf_internal_r+0x2174>
 8205378:	01420974 	movhi	r5,2085
 820537c:	2976e004 	addi	r5,r5,-9344
 8205380:	d9403a15 	stw	r5,232(sp)
 8205384:	9080080c 	andi	r2,r18,32
 8205388:	10006126 	beq	r2,zero,8205510 <___svfprintf_internal_r+0xc58>
 820538c:	d8802d17 	ldw	r2,180(sp)
 8205390:	15000017 	ldw	r20,0(r2)
 8205394:	15800117 	ldw	r22,4(r2)
 8205398:	10800204 	addi	r2,r2,8
 820539c:	d8802d15 	stw	r2,180(sp)
 82053a0:	9080004c 	andi	r2,r18,1
 82053a4:	10018e26 	beq	r2,zero,82059e0 <___svfprintf_internal_r+0x1128>
 82053a8:	a584b03a 	or	r2,r20,r22
 82053ac:	10030926 	beq	r2,zero,8205fd4 <___svfprintf_internal_r+0x171c>
 82053b0:	d8c02917 	ldw	r3,164(sp)
 82053b4:	00800c04 	movi	r2,48
 82053b8:	d8802705 	stb	r2,156(sp)
 82053bc:	dc402745 	stb	r17,157(sp)
 82053c0:	d8002785 	stb	zero,158(sp)
 82053c4:	90800094 	ori	r2,r18,2
 82053c8:	18048716 	blt	r3,zero,82065e8 <___svfprintf_internal_r+0x1d30>
 82053cc:	00bfdfc4 	movi	r2,-129
 82053d0:	90a4703a 	and	r18,r18,r2
 82053d4:	94800094 	ori	r18,r18,2
 82053d8:	0039883a 	mov	fp,zero
 82053dc:	d9003a17 	ldw	r4,232(sp)
 82053e0:	dc001e04 	addi	r16,sp,120
 82053e4:	a08003cc 	andi	r2,r20,15
 82053e8:	b006973a 	slli	r3,r22,28
 82053ec:	2085883a 	add	r2,r4,r2
 82053f0:	a028d13a 	srli	r20,r20,4
 82053f4:	10800003 	ldbu	r2,0(r2)
 82053f8:	b02cd13a 	srli	r22,r22,4
 82053fc:	843fffc4 	addi	r16,r16,-1
 8205400:	1d28b03a 	or	r20,r3,r20
 8205404:	80800005 	stb	r2,0(r16)
 8205408:	a584b03a 	or	r2,r20,r22
 820540c:	103ff51e 	bne	r2,zero,82053e4 <___svfprintf_internal_r+0xb2c>
 8205410:	d8c02817 	ldw	r3,160(sp)
 8205414:	1c07c83a 	sub	r3,r3,r16
 8205418:	d8c02e15 	stw	r3,184(sp)
 820541c:	003ece06 	br	8204f58 <___svfprintf_internal_r+0x6a0>
 8205420:	d8c02d17 	ldw	r3,180(sp)
 8205424:	d9002d17 	ldw	r4,180(sp)
 8205428:	d8002785 	stb	zero,158(sp)
 820542c:	18800017 	ldw	r2,0(r3)
 8205430:	21000104 	addi	r4,r4,4
 8205434:	00c00044 	movi	r3,1
 8205438:	d8c02a15 	stw	r3,168(sp)
 820543c:	d8801405 	stb	r2,80(sp)
 8205440:	d9002d15 	stw	r4,180(sp)
 8205444:	d8c02e15 	stw	r3,184(sp)
 8205448:	d8002915 	stw	zero,164(sp)
 820544c:	d8003215 	stw	zero,200(sp)
 8205450:	dc001404 	addi	r16,sp,80
 8205454:	0039883a 	mov	fp,zero
 8205458:	003ecc06 	br	8204f8c <___svfprintf_internal_r+0x6d4>
 820545c:	18c03fcc 	andi	r3,r3,255
 8205460:	183e9226 	beq	r3,zero,8204eac <___svfprintf_internal_r+0x5f4>
 8205464:	d9c02785 	stb	r7,158(sp)
 8205468:	003e9006 	br	8204eac <___svfprintf_internal_r+0x5f4>
 820546c:	00c00044 	movi	r3,1
 8205470:	01c00ac4 	movi	r7,43
 8205474:	bc400007 	ldb	r17,0(r23)
 8205478:	003d6306 	br	8204a08 <___svfprintf_internal_r+0x150>
 820547c:	94800814 	ori	r18,r18,32
 8205480:	bc400007 	ldb	r17,0(r23)
 8205484:	003d6006 	br	8204a08 <___svfprintf_internal_r+0x150>
 8205488:	d8c02d17 	ldw	r3,180(sp)
 820548c:	d8002785 	stb	zero,158(sp)
 8205490:	1c000017 	ldw	r16,0(r3)
 8205494:	1d000104 	addi	r20,r3,4
 8205498:	80040f26 	beq	r16,zero,82064d8 <___svfprintf_internal_r+0x1c20>
 820549c:	d9002917 	ldw	r4,164(sp)
 82054a0:	2003dc16 	blt	r4,zero,8206414 <___svfprintf_internal_r+0x1b5c>
 82054a4:	200d883a 	mov	r6,r4
 82054a8:	000b883a 	mov	r5,zero
 82054ac:	8009883a 	mov	r4,r16
 82054b0:	da003e15 	stw	r8,248(sp)
 82054b4:	820c5540 	call	820c554 <memchr>
 82054b8:	da003e17 	ldw	r8,248(sp)
 82054bc:	10045826 	beq	r2,zero,8206620 <___svfprintf_internal_r+0x1d68>
 82054c0:	1405c83a 	sub	r2,r2,r16
 82054c4:	d8802e15 	stw	r2,184(sp)
 82054c8:	1003d816 	blt	r2,zero,820642c <___svfprintf_internal_r+0x1b74>
 82054cc:	df002783 	ldbu	fp,158(sp)
 82054d0:	d8802a15 	stw	r2,168(sp)
 82054d4:	dd002d15 	stw	r20,180(sp)
 82054d8:	d8002915 	stw	zero,164(sp)
 82054dc:	d8003215 	stw	zero,200(sp)
 82054e0:	003ea306 	br	8204f70 <___svfprintf_internal_r+0x6b8>
 82054e4:	18c03fcc 	andi	r3,r3,255
 82054e8:	183f8c26 	beq	r3,zero,820531c <___svfprintf_internal_r+0xa64>
 82054ec:	d9c02785 	stb	r7,158(sp)
 82054f0:	003f8a06 	br	820531c <___svfprintf_internal_r+0xa64>
 82054f4:	18c03fcc 	andi	r3,r3,255
 82054f8:	1805631e 	bne	r3,zero,8206a88 <___svfprintf_internal_r+0x21d0>
 82054fc:	01420974 	movhi	r5,2085
 8205500:	2976e504 	addi	r5,r5,-9324
 8205504:	d9403a15 	stw	r5,232(sp)
 8205508:	9080080c 	andi	r2,r18,32
 820550c:	103f9f1e 	bne	r2,zero,820538c <___svfprintf_internal_r+0xad4>
 8205510:	9080040c 	andi	r2,r18,16
 8205514:	10029c26 	beq	r2,zero,8205f88 <___svfprintf_internal_r+0x16d0>
 8205518:	d8c02d17 	ldw	r3,180(sp)
 820551c:	002d883a 	mov	r22,zero
 8205520:	1d000017 	ldw	r20,0(r3)
 8205524:	18c00104 	addi	r3,r3,4
 8205528:	d8c02d15 	stw	r3,180(sp)
 820552c:	003f9c06 	br	82053a0 <___svfprintf_internal_r+0xae8>
 8205530:	94800054 	ori	r18,r18,1
 8205534:	bc400007 	ldb	r17,0(r23)
 8205538:	003d3306 	br	8204a08 <___svfprintf_internal_r+0x150>
 820553c:	38803fcc 	andi	r2,r7,255
 8205540:	1080201c 	xori	r2,r2,128
 8205544:	10bfe004 	addi	r2,r2,-128
 8205548:	1002971e 	bne	r2,zero,8205fa8 <___svfprintf_internal_r+0x16f0>
 820554c:	00c00044 	movi	r3,1
 8205550:	01c00804 	movi	r7,32
 8205554:	bc400007 	ldb	r17,0(r23)
 8205558:	003d2b06 	br	8204a08 <___svfprintf_internal_r+0x150>
 820555c:	18c03fcc 	andi	r3,r3,255
 8205560:	183e2326 	beq	r3,zero,8204df0 <___svfprintf_internal_r+0x538>
 8205564:	d9c02785 	stb	r7,158(sp)
 8205568:	003e2106 	br	8204df0 <___svfprintf_internal_r+0x538>
 820556c:	bc400007 	ldb	r17,0(r23)
 8205570:	8a430426 	beq	r17,r9,8206184 <___svfprintf_internal_r+0x18cc>
 8205574:	94800414 	ori	r18,r18,16
 8205578:	003d2306 	br	8204a08 <___svfprintf_internal_r+0x150>
 820557c:	18c03fcc 	andi	r3,r3,255
 8205580:	18053f1e 	bne	r3,zero,8206a80 <___svfprintf_internal_r+0x21c8>
 8205584:	9080080c 	andi	r2,r18,32
 8205588:	10028926 	beq	r2,zero,8205fb0 <___svfprintf_internal_r+0x16f8>
 820558c:	d9402d17 	ldw	r5,180(sp)
 8205590:	d9002f17 	ldw	r4,188(sp)
 8205594:	28800017 	ldw	r2,0(r5)
 8205598:	2007d7fa 	srai	r3,r4,31
 820559c:	29400104 	addi	r5,r5,4
 82055a0:	d9402d15 	stw	r5,180(sp)
 82055a4:	11000015 	stw	r4,0(r2)
 82055a8:	10c00115 	stw	r3,4(r2)
 82055ac:	003ced06 	br	8204964 <___svfprintf_internal_r+0xac>
 82055b0:	94801014 	ori	r18,r18,64
 82055b4:	bc400007 	ldb	r17,0(r23)
 82055b8:	003d1306 	br	8204a08 <___svfprintf_internal_r+0x150>
 82055bc:	01020974 	movhi	r4,2085
 82055c0:	2136e504 	addi	r4,r4,-9324
 82055c4:	0039883a 	mov	fp,zero
 82055c8:	d9003a15 	stw	r4,232(sp)
 82055cc:	04401e04 	movi	r17,120
 82055d0:	003f8206 	br	82053dc <___svfprintf_internal_r+0xb24>
 82055d4:	18c03fcc 	andi	r3,r3,255
 82055d8:	1805221e 	bne	r3,zero,8206a64 <___svfprintf_internal_r+0x21ac>
 82055dc:	883d9526 	beq	r17,zero,8204c34 <___svfprintf_internal_r+0x37c>
 82055e0:	00c00044 	movi	r3,1
 82055e4:	d8c02a15 	stw	r3,168(sp)
 82055e8:	dc401405 	stb	r17,80(sp)
 82055ec:	d8002785 	stb	zero,158(sp)
 82055f0:	003f9406 	br	8205444 <___svfprintf_internal_r+0xb8c>
 82055f4:	01020974 	movhi	r4,2085
 82055f8:	2136e504 	addi	r4,r4,-9324
 82055fc:	d9003a15 	stw	r4,232(sp)
 8205600:	d8c02d15 	stw	r3,180(sp)
 8205604:	1025883a 	mov	r18,r2
 8205608:	04401e04 	movi	r17,120
 820560c:	a584b03a 	or	r2,r20,r22
 8205610:	1000fa1e 	bne	r2,zero,82059fc <___svfprintf_internal_r+0x1144>
 8205614:	0039883a 	mov	fp,zero
 8205618:	00800084 	movi	r2,2
 820561c:	10803fcc 	andi	r2,r2,255
 8205620:	00c00044 	movi	r3,1
 8205624:	10c21626 	beq	r2,r3,8205e80 <___svfprintf_internal_r+0x15c8>
 8205628:	00c00084 	movi	r3,2
 820562c:	10fe301e 	bne	r2,r3,8204ef0 <___svfprintf_internal_r+0x638>
 8205630:	003d7606 	br	8204c0c <___svfprintf_internal_r+0x354>
 8205634:	d8c02017 	ldw	r3,128(sp)
 8205638:	003e9506 	br	8205090 <___svfprintf_internal_r+0x7d8>
 820563c:	00801944 	movi	r2,101
 8205640:	14407c0e 	bge	r2,r17,8205834 <___svfprintf_internal_r+0xf7c>
 8205644:	d9003617 	ldw	r4,216(sp)
 8205648:	d9403717 	ldw	r5,220(sp)
 820564c:	000d883a 	mov	r6,zero
 8205650:	000f883a 	mov	r7,zero
 8205654:	d8c03d15 	stw	r3,244(sp)
 8205658:	da003e15 	stw	r8,248(sp)
 820565c:	8212f580 	call	8212f58 <__eqdf2>
 8205660:	d8c03d17 	ldw	r3,244(sp)
 8205664:	da003e17 	ldw	r8,248(sp)
 8205668:	1000f51e 	bne	r2,zero,8205a40 <___svfprintf_internal_r+0x1188>
 820566c:	d8801f17 	ldw	r2,124(sp)
 8205670:	01020974 	movhi	r4,2085
 8205674:	2136ec04 	addi	r4,r4,-9296
 8205678:	18c00044 	addi	r3,r3,1
 820567c:	10800044 	addi	r2,r2,1
 8205680:	41000015 	stw	r4,0(r8)
 8205684:	01000044 	movi	r4,1
 8205688:	41000115 	stw	r4,4(r8)
 820568c:	d8c02015 	stw	r3,128(sp)
 8205690:	d8801f15 	stw	r2,124(sp)
 8205694:	010001c4 	movi	r4,7
 8205698:	20826616 	blt	r4,r2,8206034 <___svfprintf_internal_r+0x177c>
 820569c:	42000204 	addi	r8,r8,8
 82056a0:	d8802617 	ldw	r2,152(sp)
 82056a4:	d9403317 	ldw	r5,204(sp)
 82056a8:	11400216 	blt	r2,r5,82056b4 <___svfprintf_internal_r+0xdfc>
 82056ac:	9080004c 	andi	r2,r18,1
 82056b0:	103ed526 	beq	r2,zero,8205208 <___svfprintf_internal_r+0x950>
 82056b4:	d8803817 	ldw	r2,224(sp)
 82056b8:	d9003417 	ldw	r4,208(sp)
 82056bc:	d9403817 	ldw	r5,224(sp)
 82056c0:	1887883a 	add	r3,r3,r2
 82056c4:	d8801f17 	ldw	r2,124(sp)
 82056c8:	41000015 	stw	r4,0(r8)
 82056cc:	41400115 	stw	r5,4(r8)
 82056d0:	10800044 	addi	r2,r2,1
 82056d4:	d8c02015 	stw	r3,128(sp)
 82056d8:	d8801f15 	stw	r2,124(sp)
 82056dc:	010001c4 	movi	r4,7
 82056e0:	2082af16 	blt	r4,r2,82061a0 <___svfprintf_internal_r+0x18e8>
 82056e4:	42000204 	addi	r8,r8,8
 82056e8:	d8803317 	ldw	r2,204(sp)
 82056ec:	143fffc4 	addi	r16,r2,-1
 82056f0:	043ec50e 	bge	zero,r16,8205208 <___svfprintf_internal_r+0x950>
 82056f4:	04400404 	movi	r17,16
 82056f8:	d8801f17 	ldw	r2,124(sp)
 82056fc:	8c00860e 	bge	r17,r16,8205918 <___svfprintf_internal_r+0x1060>
 8205700:	01420974 	movhi	r5,2085
 8205704:	2976ec84 	addi	r5,r5,-9294
 8205708:	d9402b15 	stw	r5,172(sp)
 820570c:	058001c4 	movi	r22,7
 8205710:	dd002c17 	ldw	r20,176(sp)
 8205714:	00000306 	br	8205724 <___svfprintf_internal_r+0xe6c>
 8205718:	42000204 	addi	r8,r8,8
 820571c:	843ffc04 	addi	r16,r16,-16
 8205720:	8c00800e 	bge	r17,r16,8205924 <___svfprintf_internal_r+0x106c>
 8205724:	18c00404 	addi	r3,r3,16
 8205728:	10800044 	addi	r2,r2,1
 820572c:	45400015 	stw	r21,0(r8)
 8205730:	44400115 	stw	r17,4(r8)
 8205734:	d8c02015 	stw	r3,128(sp)
 8205738:	d8801f15 	stw	r2,124(sp)
 820573c:	b0bff60e 	bge	r22,r2,8205718 <___svfprintf_internal_r+0xe60>
 8205740:	d9801e04 	addi	r6,sp,120
 8205744:	a00b883a 	mov	r5,r20
 8205748:	9809883a 	mov	r4,r19
 820574c:	820e0e40 	call	820e0e4 <__ssprint_r>
 8205750:	103d3e1e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 8205754:	d8c02017 	ldw	r3,128(sp)
 8205758:	d8801f17 	ldw	r2,124(sp)
 820575c:	da000404 	addi	r8,sp,16
 8205760:	003fee06 	br	820571c <___svfprintf_internal_r+0xe64>
 8205764:	d9403117 	ldw	r5,196(sp)
 8205768:	d8802a17 	ldw	r2,168(sp)
 820576c:	28adc83a 	sub	r22,r5,r2
 8205770:	05be650e 	bge	zero,r22,8205108 <___svfprintf_internal_r+0x850>
 8205774:	07000404 	movi	fp,16
 8205778:	d8801f17 	ldw	r2,124(sp)
 820577c:	e583a20e 	bge	fp,r22,8206608 <___svfprintf_internal_r+0x1d50>
 8205780:	01420974 	movhi	r5,2085
 8205784:	2976ec84 	addi	r5,r5,-9294
 8205788:	dc403015 	stw	r17,192(sp)
 820578c:	d9402b15 	stw	r5,172(sp)
 8205790:	b023883a 	mov	r17,r22
 8205794:	050001c4 	movi	r20,7
 8205798:	902d883a 	mov	r22,r18
 820579c:	8025883a 	mov	r18,r16
 82057a0:	dc002c17 	ldw	r16,176(sp)
 82057a4:	00000306 	br	82057b4 <___svfprintf_internal_r+0xefc>
 82057a8:	8c7ffc04 	addi	r17,r17,-16
 82057ac:	42000204 	addi	r8,r8,8
 82057b0:	e440110e 	bge	fp,r17,82057f8 <___svfprintf_internal_r+0xf40>
 82057b4:	18c00404 	addi	r3,r3,16
 82057b8:	10800044 	addi	r2,r2,1
 82057bc:	45400015 	stw	r21,0(r8)
 82057c0:	47000115 	stw	fp,4(r8)
 82057c4:	d8c02015 	stw	r3,128(sp)
 82057c8:	d8801f15 	stw	r2,124(sp)
 82057cc:	a0bff60e 	bge	r20,r2,82057a8 <___svfprintf_internal_r+0xef0>
 82057d0:	d9801e04 	addi	r6,sp,120
 82057d4:	800b883a 	mov	r5,r16
 82057d8:	9809883a 	mov	r4,r19
 82057dc:	820e0e40 	call	820e0e4 <__ssprint_r>
 82057e0:	103d1a1e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 82057e4:	8c7ffc04 	addi	r17,r17,-16
 82057e8:	d8c02017 	ldw	r3,128(sp)
 82057ec:	d8801f17 	ldw	r2,124(sp)
 82057f0:	da000404 	addi	r8,sp,16
 82057f4:	e47fef16 	blt	fp,r17,82057b4 <___svfprintf_internal_r+0xefc>
 82057f8:	9021883a 	mov	r16,r18
 82057fc:	b025883a 	mov	r18,r22
 8205800:	882d883a 	mov	r22,r17
 8205804:	dc403017 	ldw	r17,192(sp)
 8205808:	d9002b17 	ldw	r4,172(sp)
 820580c:	1d87883a 	add	r3,r3,r22
 8205810:	10800044 	addi	r2,r2,1
 8205814:	41000015 	stw	r4,0(r8)
 8205818:	45800115 	stw	r22,4(r8)
 820581c:	d8c02015 	stw	r3,128(sp)
 8205820:	d8801f15 	stw	r2,124(sp)
 8205824:	010001c4 	movi	r4,7
 8205828:	20819a16 	blt	r4,r2,8205e94 <___svfprintf_internal_r+0x15dc>
 820582c:	42000204 	addi	r8,r8,8
 8205830:	003e3506 	br	8205108 <___svfprintf_internal_r+0x850>
 8205834:	d9403317 	ldw	r5,204(sp)
 8205838:	00800044 	movi	r2,1
 820583c:	18c00044 	addi	r3,r3,1
 8205840:	1141710e 	bge	r2,r5,8205e08 <___svfprintf_internal_r+0x1550>
 8205844:	dc401f17 	ldw	r17,124(sp)
 8205848:	00800044 	movi	r2,1
 820584c:	40800115 	stw	r2,4(r8)
 8205850:	8c400044 	addi	r17,r17,1
 8205854:	44000015 	stw	r16,0(r8)
 8205858:	d8c02015 	stw	r3,128(sp)
 820585c:	dc401f15 	stw	r17,124(sp)
 8205860:	008001c4 	movi	r2,7
 8205864:	14417416 	blt	r2,r17,8205e38 <___svfprintf_internal_r+0x1580>
 8205868:	42000204 	addi	r8,r8,8
 820586c:	d8803817 	ldw	r2,224(sp)
 8205870:	d9003417 	ldw	r4,208(sp)
 8205874:	8c400044 	addi	r17,r17,1
 8205878:	10c7883a 	add	r3,r2,r3
 820587c:	40800115 	stw	r2,4(r8)
 8205880:	41000015 	stw	r4,0(r8)
 8205884:	d8c02015 	stw	r3,128(sp)
 8205888:	dc401f15 	stw	r17,124(sp)
 820588c:	008001c4 	movi	r2,7
 8205890:	14417216 	blt	r2,r17,8205e5c <___svfprintf_internal_r+0x15a4>
 8205894:	45800204 	addi	r22,r8,8
 8205898:	d9003617 	ldw	r4,216(sp)
 820589c:	d9403717 	ldw	r5,220(sp)
 82058a0:	000d883a 	mov	r6,zero
 82058a4:	000f883a 	mov	r7,zero
 82058a8:	d8c03d15 	stw	r3,244(sp)
 82058ac:	8212f580 	call	8212f58 <__eqdf2>
 82058b0:	d8c03d17 	ldw	r3,244(sp)
 82058b4:	1000b326 	beq	r2,zero,8205b84 <___svfprintf_internal_r+0x12cc>
 82058b8:	d9403317 	ldw	r5,204(sp)
 82058bc:	84000044 	addi	r16,r16,1
 82058c0:	8c400044 	addi	r17,r17,1
 82058c4:	28bfffc4 	addi	r2,r5,-1
 82058c8:	1887883a 	add	r3,r3,r2
 82058cc:	b0800115 	stw	r2,4(r22)
 82058d0:	b4000015 	stw	r16,0(r22)
 82058d4:	d8c02015 	stw	r3,128(sp)
 82058d8:	dc401f15 	stw	r17,124(sp)
 82058dc:	008001c4 	movi	r2,7
 82058e0:	1440d216 	blt	r2,r17,8205c2c <___svfprintf_internal_r+0x1374>
 82058e4:	b5800204 	addi	r22,r22,8
 82058e8:	d9003b17 	ldw	r4,236(sp)
 82058ec:	df0022c4 	addi	fp,sp,139
 82058f0:	8c400044 	addi	r17,r17,1
 82058f4:	20c7883a 	add	r3,r4,r3
 82058f8:	b7000015 	stw	fp,0(r22)
 82058fc:	b1000115 	stw	r4,4(r22)
 8205900:	d8c02015 	stw	r3,128(sp)
 8205904:	dc401f15 	stw	r17,124(sp)
 8205908:	008001c4 	movi	r2,7
 820590c:	14400e16 	blt	r2,r17,8205948 <___svfprintf_internal_r+0x1090>
 8205910:	b2000204 	addi	r8,r22,8
 8205914:	003e3c06 	br	8205208 <___svfprintf_internal_r+0x950>
 8205918:	01020974 	movhi	r4,2085
 820591c:	2136ec84 	addi	r4,r4,-9294
 8205920:	d9002b15 	stw	r4,172(sp)
 8205924:	d9002b17 	ldw	r4,172(sp)
 8205928:	1c07883a 	add	r3,r3,r16
 820592c:	44000115 	stw	r16,4(r8)
 8205930:	41000015 	stw	r4,0(r8)
 8205934:	10800044 	addi	r2,r2,1
 8205938:	d8c02015 	stw	r3,128(sp)
 820593c:	d8801f15 	stw	r2,124(sp)
 8205940:	010001c4 	movi	r4,7
 8205944:	20be2f0e 	bge	r4,r2,8205204 <___svfprintf_internal_r+0x94c>
 8205948:	d9402c17 	ldw	r5,176(sp)
 820594c:	d9801e04 	addi	r6,sp,120
 8205950:	9809883a 	mov	r4,r19
 8205954:	820e0e40 	call	820e0e4 <__ssprint_r>
 8205958:	103cbc1e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 820595c:	d8c02017 	ldw	r3,128(sp)
 8205960:	da000404 	addi	r8,sp,16
 8205964:	003e2806 	br	8205208 <___svfprintf_internal_r+0x950>
 8205968:	d9402c17 	ldw	r5,176(sp)
 820596c:	d9801e04 	addi	r6,sp,120
 8205970:	9809883a 	mov	r4,r19
 8205974:	820e0e40 	call	820e0e4 <__ssprint_r>
 8205978:	103e5f26 	beq	r2,zero,82052f8 <___svfprintf_internal_r+0xa40>
 820597c:	003cb306 	br	8204c4c <___svfprintf_internal_r+0x394>
 8205980:	d9402c17 	ldw	r5,176(sp)
 8205984:	d9801e04 	addi	r6,sp,120
 8205988:	9809883a 	mov	r4,r19
 820598c:	820e0e40 	call	820e0e4 <__ssprint_r>
 8205990:	103cae1e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 8205994:	d8c02017 	ldw	r3,128(sp)
 8205998:	da000404 	addi	r8,sp,16
 820599c:	003e0d06 	br	82051d4 <___svfprintf_internal_r+0x91c>
 82059a0:	d9402c17 	ldw	r5,176(sp)
 82059a4:	d9801e04 	addi	r6,sp,120
 82059a8:	9809883a 	mov	r4,r19
 82059ac:	820e0e40 	call	820e0e4 <__ssprint_r>
 82059b0:	103ca61e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 82059b4:	d8c02017 	ldw	r3,128(sp)
 82059b8:	da000404 	addi	r8,sp,16
 82059bc:	003dc106 	br	82050c4 <___svfprintf_internal_r+0x80c>
 82059c0:	d9402c17 	ldw	r5,176(sp)
 82059c4:	d9801e04 	addi	r6,sp,120
 82059c8:	9809883a 	mov	r4,r19
 82059cc:	820e0e40 	call	820e0e4 <__ssprint_r>
 82059d0:	103c9e1e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 82059d4:	d8c02017 	ldw	r3,128(sp)
 82059d8:	da000404 	addi	r8,sp,16
 82059dc:	003dc706 	br	82050fc <___svfprintf_internal_r+0x844>
 82059e0:	d8802917 	ldw	r2,164(sp)
 82059e4:	d8002785 	stb	zero,158(sp)
 82059e8:	103f0816 	blt	r2,zero,820560c <___svfprintf_internal_r+0xd54>
 82059ec:	00ffdfc4 	movi	r3,-129
 82059f0:	a584b03a 	or	r2,r20,r22
 82059f4:	90e4703a 	and	r18,r18,r3
 82059f8:	103c8126 	beq	r2,zero,8204c00 <___svfprintf_internal_r+0x348>
 82059fc:	0039883a 	mov	fp,zero
 8205a00:	003e7606 	br	82053dc <___svfprintf_internal_r+0xb24>
 8205a04:	9080040c 	andi	r2,r18,16
 8205a08:	10013d26 	beq	r2,zero,8205f00 <___svfprintf_internal_r+0x1648>
 8205a0c:	d9002d17 	ldw	r4,180(sp)
 8205a10:	d9402917 	ldw	r5,164(sp)
 8205a14:	d8002785 	stb	zero,158(sp)
 8205a18:	20800104 	addi	r2,r4,4
 8205a1c:	25000017 	ldw	r20,0(r4)
 8205a20:	002d883a 	mov	r22,zero
 8205a24:	28013f16 	blt	r5,zero,8205f24 <___svfprintf_internal_r+0x166c>
 8205a28:	00ffdfc4 	movi	r3,-129
 8205a2c:	d8802d15 	stw	r2,180(sp)
 8205a30:	90e4703a 	and	r18,r18,r3
 8205a34:	a03d2b26 	beq	r20,zero,8204ee4 <___svfprintf_internal_r+0x62c>
 8205a38:	0039883a 	mov	fp,zero
 8205a3c:	003d2e06 	br	8204ef8 <___svfprintf_internal_r+0x640>
 8205a40:	dc402617 	ldw	r17,152(sp)
 8205a44:	0441830e 	bge	zero,r17,8206054 <___svfprintf_internal_r+0x179c>
 8205a48:	dc403217 	ldw	r17,200(sp)
 8205a4c:	d8803317 	ldw	r2,204(sp)
 8205a50:	1440010e 	bge	r2,r17,8205a58 <___svfprintf_internal_r+0x11a0>
 8205a54:	1023883a 	mov	r17,r2
 8205a58:	04400a0e 	bge	zero,r17,8205a84 <___svfprintf_internal_r+0x11cc>
 8205a5c:	d8801f17 	ldw	r2,124(sp)
 8205a60:	1c47883a 	add	r3,r3,r17
 8205a64:	44000015 	stw	r16,0(r8)
 8205a68:	10800044 	addi	r2,r2,1
 8205a6c:	44400115 	stw	r17,4(r8)
 8205a70:	d8c02015 	stw	r3,128(sp)
 8205a74:	d8801f15 	stw	r2,124(sp)
 8205a78:	010001c4 	movi	r4,7
 8205a7c:	20827516 	blt	r4,r2,8206454 <___svfprintf_internal_r+0x1b9c>
 8205a80:	42000204 	addi	r8,r8,8
 8205a84:	88027b16 	blt	r17,zero,8206474 <___svfprintf_internal_r+0x1bbc>
 8205a88:	d9003217 	ldw	r4,200(sp)
 8205a8c:	2463c83a 	sub	r17,r4,r17
 8205a90:	0440990e 	bge	zero,r17,8205cf8 <___svfprintf_internal_r+0x1440>
 8205a94:	05800404 	movi	r22,16
 8205a98:	d8801f17 	ldw	r2,124(sp)
 8205a9c:	b441530e 	bge	r22,r17,8205fec <___svfprintf_internal_r+0x1734>
 8205aa0:	01020974 	movhi	r4,2085
 8205aa4:	2136ec84 	addi	r4,r4,-9294
 8205aa8:	d9002b15 	stw	r4,172(sp)
 8205aac:	070001c4 	movi	fp,7
 8205ab0:	dd002c17 	ldw	r20,176(sp)
 8205ab4:	00000306 	br	8205ac4 <___svfprintf_internal_r+0x120c>
 8205ab8:	42000204 	addi	r8,r8,8
 8205abc:	8c7ffc04 	addi	r17,r17,-16
 8205ac0:	b4414d0e 	bge	r22,r17,8205ff8 <___svfprintf_internal_r+0x1740>
 8205ac4:	18c00404 	addi	r3,r3,16
 8205ac8:	10800044 	addi	r2,r2,1
 8205acc:	45400015 	stw	r21,0(r8)
 8205ad0:	45800115 	stw	r22,4(r8)
 8205ad4:	d8c02015 	stw	r3,128(sp)
 8205ad8:	d8801f15 	stw	r2,124(sp)
 8205adc:	e0bff60e 	bge	fp,r2,8205ab8 <___svfprintf_internal_r+0x1200>
 8205ae0:	d9801e04 	addi	r6,sp,120
 8205ae4:	a00b883a 	mov	r5,r20
 8205ae8:	9809883a 	mov	r4,r19
 8205aec:	820e0e40 	call	820e0e4 <__ssprint_r>
 8205af0:	103c561e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 8205af4:	d8c02017 	ldw	r3,128(sp)
 8205af8:	d8801f17 	ldw	r2,124(sp)
 8205afc:	da000404 	addi	r8,sp,16
 8205b00:	003fee06 	br	8205abc <___svfprintf_internal_r+0x1204>
 8205b04:	d9402c17 	ldw	r5,176(sp)
 8205b08:	d9801e04 	addi	r6,sp,120
 8205b0c:	9809883a 	mov	r4,r19
 8205b10:	820e0e40 	call	820e0e4 <__ssprint_r>
 8205b14:	103c4d1e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 8205b18:	d8c02017 	ldw	r3,128(sp)
 8205b1c:	df002787 	ldb	fp,158(sp)
 8205b20:	da000404 	addi	r8,sp,16
 8205b24:	003d5a06 	br	8205090 <___svfprintf_internal_r+0x7d8>
 8205b28:	9080040c 	andi	r2,r18,16
 8205b2c:	10005c26 	beq	r2,zero,8205ca0 <___svfprintf_internal_r+0x13e8>
 8205b30:	d9402d17 	ldw	r5,180(sp)
 8205b34:	d8c02917 	ldw	r3,164(sp)
 8205b38:	d8002785 	stb	zero,158(sp)
 8205b3c:	28800104 	addi	r2,r5,4
 8205b40:	2d000017 	ldw	r20,0(r5)
 8205b44:	002d883a 	mov	r22,zero
 8205b48:	18005e16 	blt	r3,zero,8205cc4 <___svfprintf_internal_r+0x140c>
 8205b4c:	00ffdfc4 	movi	r3,-129
 8205b50:	d8802d15 	stw	r2,180(sp)
 8205b54:	90e4703a 	and	r18,r18,r3
 8205b58:	0039883a 	mov	fp,zero
 8205b5c:	a03dfe26 	beq	r20,zero,8205358 <___svfprintf_internal_r+0xaa0>
 8205b60:	00800244 	movi	r2,9
 8205b64:	153cb336 	bltu	r2,r20,8204e34 <___svfprintf_internal_r+0x57c>
 8205b68:	a5000c04 	addi	r20,r20,48
 8205b6c:	dc001dc4 	addi	r16,sp,119
 8205b70:	dd001dc5 	stb	r20,119(sp)
 8205b74:	d8c02817 	ldw	r3,160(sp)
 8205b78:	1c07c83a 	sub	r3,r3,r16
 8205b7c:	d8c02e15 	stw	r3,184(sp)
 8205b80:	003cf506 	br	8204f58 <___svfprintf_internal_r+0x6a0>
 8205b84:	d8803317 	ldw	r2,204(sp)
 8205b88:	143fffc4 	addi	r16,r2,-1
 8205b8c:	043f560e 	bge	zero,r16,82058e8 <___svfprintf_internal_r+0x1030>
 8205b90:	07000404 	movi	fp,16
 8205b94:	e403530e 	bge	fp,r16,82068e4 <___svfprintf_internal_r+0x202c>
 8205b98:	01420974 	movhi	r5,2085
 8205b9c:	2976ec84 	addi	r5,r5,-9294
 8205ba0:	d9402b15 	stw	r5,172(sp)
 8205ba4:	01c001c4 	movi	r7,7
 8205ba8:	dd002c17 	ldw	r20,176(sp)
 8205bac:	00000306 	br	8205bbc <___svfprintf_internal_r+0x1304>
 8205bb0:	843ffc04 	addi	r16,r16,-16
 8205bb4:	b5800204 	addi	r22,r22,8
 8205bb8:	e400130e 	bge	fp,r16,8205c08 <___svfprintf_internal_r+0x1350>
 8205bbc:	18c00404 	addi	r3,r3,16
 8205bc0:	8c400044 	addi	r17,r17,1
 8205bc4:	b5400015 	stw	r21,0(r22)
 8205bc8:	b7000115 	stw	fp,4(r22)
 8205bcc:	d8c02015 	stw	r3,128(sp)
 8205bd0:	dc401f15 	stw	r17,124(sp)
 8205bd4:	3c7ff60e 	bge	r7,r17,8205bb0 <___svfprintf_internal_r+0x12f8>
 8205bd8:	d9801e04 	addi	r6,sp,120
 8205bdc:	a00b883a 	mov	r5,r20
 8205be0:	9809883a 	mov	r4,r19
 8205be4:	d9c03d15 	stw	r7,244(sp)
 8205be8:	820e0e40 	call	820e0e4 <__ssprint_r>
 8205bec:	d9c03d17 	ldw	r7,244(sp)
 8205bf0:	103c161e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 8205bf4:	843ffc04 	addi	r16,r16,-16
 8205bf8:	d8c02017 	ldw	r3,128(sp)
 8205bfc:	dc401f17 	ldw	r17,124(sp)
 8205c00:	dd800404 	addi	r22,sp,16
 8205c04:	e43fed16 	blt	fp,r16,8205bbc <___svfprintf_internal_r+0x1304>
 8205c08:	d8802b17 	ldw	r2,172(sp)
 8205c0c:	1c07883a 	add	r3,r3,r16
 8205c10:	8c400044 	addi	r17,r17,1
 8205c14:	b0800015 	stw	r2,0(r22)
 8205c18:	b4000115 	stw	r16,4(r22)
 8205c1c:	d8c02015 	stw	r3,128(sp)
 8205c20:	dc401f15 	stw	r17,124(sp)
 8205c24:	008001c4 	movi	r2,7
 8205c28:	147f2e0e 	bge	r2,r17,82058e4 <___svfprintf_internal_r+0x102c>
 8205c2c:	d9402c17 	ldw	r5,176(sp)
 8205c30:	d9801e04 	addi	r6,sp,120
 8205c34:	9809883a 	mov	r4,r19
 8205c38:	820e0e40 	call	820e0e4 <__ssprint_r>
 8205c3c:	103c031e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 8205c40:	d8c02017 	ldw	r3,128(sp)
 8205c44:	dc401f17 	ldw	r17,124(sp)
 8205c48:	dd800404 	addi	r22,sp,16
 8205c4c:	003f2606 	br	82058e8 <___svfprintf_internal_r+0x1030>
 8205c50:	9080040c 	andi	r2,r18,16
 8205c54:	1000c326 	beq	r2,zero,8205f64 <___svfprintf_internal_r+0x16ac>
 8205c58:	d8802d17 	ldw	r2,180(sp)
 8205c5c:	15000017 	ldw	r20,0(r2)
 8205c60:	10800104 	addi	r2,r2,4
 8205c64:	d8802d15 	stw	r2,180(sp)
 8205c68:	a02dd7fa 	srai	r22,r20,31
 8205c6c:	b005883a 	mov	r2,r22
 8205c70:	103c680e 	bge	r2,zero,8204e14 <___svfprintf_internal_r+0x55c>
 8205c74:	0529c83a 	sub	r20,zero,r20
 8205c78:	a004c03a 	cmpne	r2,r20,zero
 8205c7c:	05adc83a 	sub	r22,zero,r22
 8205c80:	b0adc83a 	sub	r22,r22,r2
 8205c84:	d8802917 	ldw	r2,164(sp)
 8205c88:	07000b44 	movi	fp,45
 8205c8c:	df002785 	stb	fp,158(sp)
 8205c90:	10022e16 	blt	r2,zero,820654c <___svfprintf_internal_r+0x1c94>
 8205c94:	00bfdfc4 	movi	r2,-129
 8205c98:	90a4703a 	and	r18,r18,r2
 8205c9c:	003c6406 	br	8204e30 <___svfprintf_internal_r+0x578>
 8205ca0:	9080100c 	andi	r2,r18,64
 8205ca4:	d8002785 	stb	zero,158(sp)
 8205ca8:	10012526 	beq	r2,zero,8206140 <___svfprintf_internal_r+0x1888>
 8205cac:	d9002d17 	ldw	r4,180(sp)
 8205cb0:	d9402917 	ldw	r5,164(sp)
 8205cb4:	002d883a 	mov	r22,zero
 8205cb8:	20800104 	addi	r2,r4,4
 8205cbc:	2500000b 	ldhu	r20,0(r4)
 8205cc0:	283fa20e 	bge	r5,zero,8205b4c <___svfprintf_internal_r+0x1294>
 8205cc4:	d8802d15 	stw	r2,180(sp)
 8205cc8:	0039883a 	mov	fp,zero
 8205ccc:	a584b03a 	or	r2,r20,r22
 8205cd0:	103c571e 	bne	r2,zero,8204e30 <___svfprintf_internal_r+0x578>
 8205cd4:	00800044 	movi	r2,1
 8205cd8:	003e5006 	br	820561c <___svfprintf_internal_r+0xd64>
 8205cdc:	d9402c17 	ldw	r5,176(sp)
 8205ce0:	d9801e04 	addi	r6,sp,120
 8205ce4:	9809883a 	mov	r4,r19
 8205ce8:	820e0e40 	call	820e0e4 <__ssprint_r>
 8205cec:	103bd71e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 8205cf0:	d8c02017 	ldw	r3,128(sp)
 8205cf4:	da000404 	addi	r8,sp,16
 8205cf8:	d9003217 	ldw	r4,200(sp)
 8205cfc:	d8802617 	ldw	r2,152(sp)
 8205d00:	d9403317 	ldw	r5,204(sp)
 8205d04:	8123883a 	add	r17,r16,r4
 8205d08:	11400216 	blt	r2,r5,8205d14 <___svfprintf_internal_r+0x145c>
 8205d0c:	9100004c 	andi	r4,r18,1
 8205d10:	20000d26 	beq	r4,zero,8205d48 <___svfprintf_internal_r+0x1490>
 8205d14:	d9003817 	ldw	r4,224(sp)
 8205d18:	d9403417 	ldw	r5,208(sp)
 8205d1c:	1907883a 	add	r3,r3,r4
 8205d20:	d9001f17 	ldw	r4,124(sp)
 8205d24:	41400015 	stw	r5,0(r8)
 8205d28:	d9403817 	ldw	r5,224(sp)
 8205d2c:	21000044 	addi	r4,r4,1
 8205d30:	d8c02015 	stw	r3,128(sp)
 8205d34:	41400115 	stw	r5,4(r8)
 8205d38:	d9001f15 	stw	r4,124(sp)
 8205d3c:	014001c4 	movi	r5,7
 8205d40:	2901dc16 	blt	r5,r4,82064b4 <___svfprintf_internal_r+0x1bfc>
 8205d44:	42000204 	addi	r8,r8,8
 8205d48:	d9003317 	ldw	r4,204(sp)
 8205d4c:	8121883a 	add	r16,r16,r4
 8205d50:	2085c83a 	sub	r2,r4,r2
 8205d54:	8461c83a 	sub	r16,r16,r17
 8205d58:	1400010e 	bge	r2,r16,8205d60 <___svfprintf_internal_r+0x14a8>
 8205d5c:	1021883a 	mov	r16,r2
 8205d60:	04000a0e 	bge	zero,r16,8205d8c <___svfprintf_internal_r+0x14d4>
 8205d64:	d9001f17 	ldw	r4,124(sp)
 8205d68:	1c07883a 	add	r3,r3,r16
 8205d6c:	44400015 	stw	r17,0(r8)
 8205d70:	21000044 	addi	r4,r4,1
 8205d74:	44000115 	stw	r16,4(r8)
 8205d78:	d8c02015 	stw	r3,128(sp)
 8205d7c:	d9001f15 	stw	r4,124(sp)
 8205d80:	014001c4 	movi	r5,7
 8205d84:	2901e616 	blt	r5,r4,8206520 <___svfprintf_internal_r+0x1c68>
 8205d88:	42000204 	addi	r8,r8,8
 8205d8c:	8001f616 	blt	r16,zero,8206568 <___svfprintf_internal_r+0x1cb0>
 8205d90:	1421c83a 	sub	r16,r2,r16
 8205d94:	043d1c0e 	bge	zero,r16,8205208 <___svfprintf_internal_r+0x950>
 8205d98:	04400404 	movi	r17,16
 8205d9c:	d8801f17 	ldw	r2,124(sp)
 8205da0:	8c3edd0e 	bge	r17,r16,8205918 <___svfprintf_internal_r+0x1060>
 8205da4:	01420974 	movhi	r5,2085
 8205da8:	2976ec84 	addi	r5,r5,-9294
 8205dac:	d9402b15 	stw	r5,172(sp)
 8205db0:	058001c4 	movi	r22,7
 8205db4:	dd002c17 	ldw	r20,176(sp)
 8205db8:	00000306 	br	8205dc8 <___svfprintf_internal_r+0x1510>
 8205dbc:	42000204 	addi	r8,r8,8
 8205dc0:	843ffc04 	addi	r16,r16,-16
 8205dc4:	8c3ed70e 	bge	r17,r16,8205924 <___svfprintf_internal_r+0x106c>
 8205dc8:	18c00404 	addi	r3,r3,16
 8205dcc:	10800044 	addi	r2,r2,1
 8205dd0:	45400015 	stw	r21,0(r8)
 8205dd4:	44400115 	stw	r17,4(r8)
 8205dd8:	d8c02015 	stw	r3,128(sp)
 8205ddc:	d8801f15 	stw	r2,124(sp)
 8205de0:	b0bff60e 	bge	r22,r2,8205dbc <___svfprintf_internal_r+0x1504>
 8205de4:	d9801e04 	addi	r6,sp,120
 8205de8:	a00b883a 	mov	r5,r20
 8205dec:	9809883a 	mov	r4,r19
 8205df0:	820e0e40 	call	820e0e4 <__ssprint_r>
 8205df4:	103b951e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 8205df8:	d8c02017 	ldw	r3,128(sp)
 8205dfc:	d8801f17 	ldw	r2,124(sp)
 8205e00:	da000404 	addi	r8,sp,16
 8205e04:	003fee06 	br	8205dc0 <___svfprintf_internal_r+0x1508>
 8205e08:	9088703a 	and	r4,r18,r2
 8205e0c:	203e8d1e 	bne	r4,zero,8205844 <___svfprintf_internal_r+0xf8c>
 8205e10:	dc401f17 	ldw	r17,124(sp)
 8205e14:	40800115 	stw	r2,4(r8)
 8205e18:	44000015 	stw	r16,0(r8)
 8205e1c:	8c400044 	addi	r17,r17,1
 8205e20:	d8c02015 	stw	r3,128(sp)
 8205e24:	dc401f15 	stw	r17,124(sp)
 8205e28:	008001c4 	movi	r2,7
 8205e2c:	147f7f16 	blt	r2,r17,8205c2c <___svfprintf_internal_r+0x1374>
 8205e30:	45800204 	addi	r22,r8,8
 8205e34:	003eac06 	br	82058e8 <___svfprintf_internal_r+0x1030>
 8205e38:	d9402c17 	ldw	r5,176(sp)
 8205e3c:	d9801e04 	addi	r6,sp,120
 8205e40:	9809883a 	mov	r4,r19
 8205e44:	820e0e40 	call	820e0e4 <__ssprint_r>
 8205e48:	103b801e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 8205e4c:	d8c02017 	ldw	r3,128(sp)
 8205e50:	dc401f17 	ldw	r17,124(sp)
 8205e54:	da000404 	addi	r8,sp,16
 8205e58:	003e8406 	br	820586c <___svfprintf_internal_r+0xfb4>
 8205e5c:	d9402c17 	ldw	r5,176(sp)
 8205e60:	d9801e04 	addi	r6,sp,120
 8205e64:	9809883a 	mov	r4,r19
 8205e68:	820e0e40 	call	820e0e4 <__ssprint_r>
 8205e6c:	103b771e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 8205e70:	d8c02017 	ldw	r3,128(sp)
 8205e74:	dc401f17 	ldw	r17,124(sp)
 8205e78:	dd800404 	addi	r22,sp,16
 8205e7c:	003e8606 	br	8205898 <___svfprintf_internal_r+0xfe0>
 8205e80:	0029883a 	mov	r20,zero
 8205e84:	a5000c04 	addi	r20,r20,48
 8205e88:	dc001dc4 	addi	r16,sp,119
 8205e8c:	dd001dc5 	stb	r20,119(sp)
 8205e90:	003f3806 	br	8205b74 <___svfprintf_internal_r+0x12bc>
 8205e94:	d9402c17 	ldw	r5,176(sp)
 8205e98:	d9801e04 	addi	r6,sp,120
 8205e9c:	9809883a 	mov	r4,r19
 8205ea0:	820e0e40 	call	820e0e4 <__ssprint_r>
 8205ea4:	103b691e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 8205ea8:	d8c02017 	ldw	r3,128(sp)
 8205eac:	da000404 	addi	r8,sp,16
 8205eb0:	003c9506 	br	8205108 <___svfprintf_internal_r+0x850>
 8205eb4:	d9003617 	ldw	r4,216(sp)
 8205eb8:	d9403717 	ldw	r5,220(sp)
 8205ebc:	da003e15 	stw	r8,248(sp)
 8205ec0:	820de040 	call	820de04 <__fpclassifyd>
 8205ec4:	da003e17 	ldw	r8,248(sp)
 8205ec8:	1000bd1e 	bne	r2,zero,82061c0 <___svfprintf_internal_r+0x1908>
 8205ecc:	008011c4 	movi	r2,71
 8205ed0:	14411e0e 	bge	r2,r17,820634c <___svfprintf_internal_r+0x1a94>
 8205ed4:	04020974 	movhi	r16,2085
 8205ed8:	8436df04 	addi	r16,r16,-9348
 8205edc:	00c000c4 	movi	r3,3
 8205ee0:	00bfdfc4 	movi	r2,-129
 8205ee4:	d8c02a15 	stw	r3,168(sp)
 8205ee8:	90a4703a 	and	r18,r18,r2
 8205eec:	df002783 	ldbu	fp,158(sp)
 8205ef0:	d8c02e15 	stw	r3,184(sp)
 8205ef4:	d8002915 	stw	zero,164(sp)
 8205ef8:	d8003215 	stw	zero,200(sp)
 8205efc:	003c1c06 	br	8204f70 <___svfprintf_internal_r+0x6b8>
 8205f00:	9080100c 	andi	r2,r18,64
 8205f04:	d8002785 	stb	zero,158(sp)
 8205f08:	10009426 	beq	r2,zero,820615c <___svfprintf_internal_r+0x18a4>
 8205f0c:	d8c02d17 	ldw	r3,180(sp)
 8205f10:	d9002917 	ldw	r4,164(sp)
 8205f14:	002d883a 	mov	r22,zero
 8205f18:	18800104 	addi	r2,r3,4
 8205f1c:	1d00000b 	ldhu	r20,0(r3)
 8205f20:	203ec10e 	bge	r4,zero,8205a28 <___svfprintf_internal_r+0x1170>
 8205f24:	a586b03a 	or	r3,r20,r22
 8205f28:	d8802d15 	stw	r2,180(sp)
 8205f2c:	183ec21e 	bne	r3,zero,8205a38 <___svfprintf_internal_r+0x1180>
 8205f30:	0039883a 	mov	fp,zero
 8205f34:	0005883a 	mov	r2,zero
 8205f38:	003db806 	br	820561c <___svfprintf_internal_r+0xd64>
 8205f3c:	d8802d17 	ldw	r2,180(sp)
 8205f40:	d8c02d17 	ldw	r3,180(sp)
 8205f44:	d9002d17 	ldw	r4,180(sp)
 8205f48:	10800017 	ldw	r2,0(r2)
 8205f4c:	18c00117 	ldw	r3,4(r3)
 8205f50:	21000204 	addi	r4,r4,8
 8205f54:	d8803615 	stw	r2,216(sp)
 8205f58:	d8c03715 	stw	r3,220(sp)
 8205f5c:	d9002d15 	stw	r4,180(sp)
 8205f60:	003b8206 	br	8204d6c <___svfprintf_internal_r+0x4b4>
 8205f64:	9080100c 	andi	r2,r18,64
 8205f68:	10010726 	beq	r2,zero,8206388 <___svfprintf_internal_r+0x1ad0>
 8205f6c:	d8c02d17 	ldw	r3,180(sp)
 8205f70:	1d00000f 	ldh	r20,0(r3)
 8205f74:	18c00104 	addi	r3,r3,4
 8205f78:	d8c02d15 	stw	r3,180(sp)
 8205f7c:	a02dd7fa 	srai	r22,r20,31
 8205f80:	b005883a 	mov	r2,r22
 8205f84:	003ba206 	br	8204e10 <___svfprintf_internal_r+0x558>
 8205f88:	9080100c 	andi	r2,r18,64
 8205f8c:	10010526 	beq	r2,zero,82063a4 <___svfprintf_internal_r+0x1aec>
 8205f90:	d9002d17 	ldw	r4,180(sp)
 8205f94:	002d883a 	mov	r22,zero
 8205f98:	2500000b 	ldhu	r20,0(r4)
 8205f9c:	21000104 	addi	r4,r4,4
 8205fa0:	d9002d15 	stw	r4,180(sp)
 8205fa4:	003cfe06 	br	82053a0 <___svfprintf_internal_r+0xae8>
 8205fa8:	bc400007 	ldb	r17,0(r23)
 8205fac:	003a9606 	br	8204a08 <___svfprintf_internal_r+0x150>
 8205fb0:	9080040c 	andi	r2,r18,16
 8205fb4:	10010126 	beq	r2,zero,82063bc <___svfprintf_internal_r+0x1b04>
 8205fb8:	d9402d17 	ldw	r5,180(sp)
 8205fbc:	d8c02f17 	ldw	r3,188(sp)
 8205fc0:	28800017 	ldw	r2,0(r5)
 8205fc4:	29400104 	addi	r5,r5,4
 8205fc8:	d9402d15 	stw	r5,180(sp)
 8205fcc:	10c00015 	stw	r3,0(r2)
 8205fd0:	003a6406 	br	8204964 <___svfprintf_internal_r+0xac>
 8205fd4:	d9002917 	ldw	r4,164(sp)
 8205fd8:	d8002785 	stb	zero,158(sp)
 8205fdc:	203d8d16 	blt	r4,zero,8205614 <___svfprintf_internal_r+0xd5c>
 8205fe0:	00bfdfc4 	movi	r2,-129
 8205fe4:	90a4703a 	and	r18,r18,r2
 8205fe8:	003b0506 	br	8204c00 <___svfprintf_internal_r+0x348>
 8205fec:	01420974 	movhi	r5,2085
 8205ff0:	2976ec84 	addi	r5,r5,-9294
 8205ff4:	d9402b15 	stw	r5,172(sp)
 8205ff8:	d9402b17 	ldw	r5,172(sp)
 8205ffc:	1c47883a 	add	r3,r3,r17
 8206000:	10800044 	addi	r2,r2,1
 8206004:	41400015 	stw	r5,0(r8)
 8206008:	44400115 	stw	r17,4(r8)
 820600c:	d8c02015 	stw	r3,128(sp)
 8206010:	d8801f15 	stw	r2,124(sp)
 8206014:	010001c4 	movi	r4,7
 8206018:	20bf3016 	blt	r4,r2,8205cdc <___svfprintf_internal_r+0x1424>
 820601c:	42000204 	addi	r8,r8,8
 8206020:	003f3506 	br	8205cf8 <___svfprintf_internal_r+0x1440>
 8206024:	01020974 	movhi	r4,2085
 8206028:	2136ec84 	addi	r4,r4,-9294
 820602c:	d9002b15 	stw	r4,172(sp)
 8206030:	003c5e06 	br	82051ac <___svfprintf_internal_r+0x8f4>
 8206034:	d9402c17 	ldw	r5,176(sp)
 8206038:	d9801e04 	addi	r6,sp,120
 820603c:	9809883a 	mov	r4,r19
 8206040:	820e0e40 	call	820e0e4 <__ssprint_r>
 8206044:	103b011e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 8206048:	d8c02017 	ldw	r3,128(sp)
 820604c:	da000404 	addi	r8,sp,16
 8206050:	003d9306 	br	82056a0 <___svfprintf_internal_r+0xde8>
 8206054:	d8801f17 	ldw	r2,124(sp)
 8206058:	01420974 	movhi	r5,2085
 820605c:	01000044 	movi	r4,1
 8206060:	18c00044 	addi	r3,r3,1
 8206064:	10800044 	addi	r2,r2,1
 8206068:	2976ec04 	addi	r5,r5,-9296
 820606c:	41000115 	stw	r4,4(r8)
 8206070:	41400015 	stw	r5,0(r8)
 8206074:	d8c02015 	stw	r3,128(sp)
 8206078:	d8801f15 	stw	r2,124(sp)
 820607c:	010001c4 	movi	r4,7
 8206080:	2080b516 	blt	r4,r2,8206358 <___svfprintf_internal_r+0x1aa0>
 8206084:	42000204 	addi	r8,r8,8
 8206088:	8800041e 	bne	r17,zero,820609c <___svfprintf_internal_r+0x17e4>
 820608c:	d8803317 	ldw	r2,204(sp)
 8206090:	1000021e 	bne	r2,zero,820609c <___svfprintf_internal_r+0x17e4>
 8206094:	9080004c 	andi	r2,r18,1
 8206098:	103c5b26 	beq	r2,zero,8205208 <___svfprintf_internal_r+0x950>
 820609c:	d9003817 	ldw	r4,224(sp)
 82060a0:	d8801f17 	ldw	r2,124(sp)
 82060a4:	d9403417 	ldw	r5,208(sp)
 82060a8:	20c7883a 	add	r3,r4,r3
 82060ac:	10800044 	addi	r2,r2,1
 82060b0:	41000115 	stw	r4,4(r8)
 82060b4:	41400015 	stw	r5,0(r8)
 82060b8:	d8c02015 	stw	r3,128(sp)
 82060bc:	d8801f15 	stw	r2,124(sp)
 82060c0:	010001c4 	movi	r4,7
 82060c4:	20818016 	blt	r4,r2,82066c8 <___svfprintf_internal_r+0x1e10>
 82060c8:	42000204 	addi	r8,r8,8
 82060cc:	0463c83a 	sub	r17,zero,r17
 82060d0:	0440cb0e 	bge	zero,r17,8206400 <___svfprintf_internal_r+0x1b48>
 82060d4:	05800404 	movi	r22,16
 82060d8:	b440e80e 	bge	r22,r17,820647c <___svfprintf_internal_r+0x1bc4>
 82060dc:	01420974 	movhi	r5,2085
 82060e0:	2976ec84 	addi	r5,r5,-9294
 82060e4:	d9402b15 	stw	r5,172(sp)
 82060e8:	070001c4 	movi	fp,7
 82060ec:	dd002c17 	ldw	r20,176(sp)
 82060f0:	00000306 	br	8206100 <___svfprintf_internal_r+0x1848>
 82060f4:	42000204 	addi	r8,r8,8
 82060f8:	8c7ffc04 	addi	r17,r17,-16
 82060fc:	b440e20e 	bge	r22,r17,8206488 <___svfprintf_internal_r+0x1bd0>
 8206100:	18c00404 	addi	r3,r3,16
 8206104:	10800044 	addi	r2,r2,1
 8206108:	45400015 	stw	r21,0(r8)
 820610c:	45800115 	stw	r22,4(r8)
 8206110:	d8c02015 	stw	r3,128(sp)
 8206114:	d8801f15 	stw	r2,124(sp)
 8206118:	e0bff60e 	bge	fp,r2,82060f4 <___svfprintf_internal_r+0x183c>
 820611c:	d9801e04 	addi	r6,sp,120
 8206120:	a00b883a 	mov	r5,r20
 8206124:	9809883a 	mov	r4,r19
 8206128:	820e0e40 	call	820e0e4 <__ssprint_r>
 820612c:	103ac71e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 8206130:	d8c02017 	ldw	r3,128(sp)
 8206134:	d8801f17 	ldw	r2,124(sp)
 8206138:	da000404 	addi	r8,sp,16
 820613c:	003fee06 	br	82060f8 <___svfprintf_internal_r+0x1840>
 8206140:	d8c02d17 	ldw	r3,180(sp)
 8206144:	d9002917 	ldw	r4,164(sp)
 8206148:	002d883a 	mov	r22,zero
 820614c:	18800104 	addi	r2,r3,4
 8206150:	1d000017 	ldw	r20,0(r3)
 8206154:	203e7d0e 	bge	r4,zero,8205b4c <___svfprintf_internal_r+0x1294>
 8206158:	003eda06 	br	8205cc4 <___svfprintf_internal_r+0x140c>
 820615c:	d9402d17 	ldw	r5,180(sp)
 8206160:	d8c02917 	ldw	r3,164(sp)
 8206164:	002d883a 	mov	r22,zero
 8206168:	28800104 	addi	r2,r5,4
 820616c:	2d000017 	ldw	r20,0(r5)
 8206170:	183e2d0e 	bge	r3,zero,8205a28 <___svfprintf_internal_r+0x1170>
 8206174:	003f6b06 	br	8205f24 <___svfprintf_internal_r+0x166c>
 8206178:	d8c02d15 	stw	r3,180(sp)
 820617c:	0039883a 	mov	fp,zero
 8206180:	003ed206 	br	8205ccc <___svfprintf_internal_r+0x1414>
 8206184:	bc400043 	ldbu	r17,1(r23)
 8206188:	94800814 	ori	r18,r18,32
 820618c:	bdc00044 	addi	r23,r23,1
 8206190:	8c403fcc 	andi	r17,r17,255
 8206194:	8c40201c 	xori	r17,r17,128
 8206198:	8c7fe004 	addi	r17,r17,-128
 820619c:	003a1a06 	br	8204a08 <___svfprintf_internal_r+0x150>
 82061a0:	d9402c17 	ldw	r5,176(sp)
 82061a4:	d9801e04 	addi	r6,sp,120
 82061a8:	9809883a 	mov	r4,r19
 82061ac:	820e0e40 	call	820e0e4 <__ssprint_r>
 82061b0:	103aa61e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 82061b4:	d8c02017 	ldw	r3,128(sp)
 82061b8:	da000404 	addi	r8,sp,16
 82061bc:	003d4a06 	br	82056e8 <___svfprintf_internal_r+0xe30>
 82061c0:	d9002917 	ldw	r4,164(sp)
 82061c4:	05bff7c4 	movi	r22,-33
 82061c8:	00bfffc4 	movi	r2,-1
 82061cc:	8dac703a 	and	r22,r17,r22
 82061d0:	20806a26 	beq	r4,r2,820637c <___svfprintf_internal_r+0x1ac4>
 82061d4:	008011c4 	movi	r2,71
 82061d8:	b0813726 	beq	r22,r2,82066b8 <___svfprintf_internal_r+0x1e00>
 82061dc:	d9003717 	ldw	r4,220(sp)
 82061e0:	90c04014 	ori	r3,r18,256
 82061e4:	d8c02b15 	stw	r3,172(sp)
 82061e8:	20015d16 	blt	r4,zero,8206760 <___svfprintf_internal_r+0x1ea8>
 82061ec:	dd003717 	ldw	r20,220(sp)
 82061f0:	d8002a05 	stb	zero,168(sp)
 82061f4:	00801984 	movi	r2,102
 82061f8:	88814026 	beq	r17,r2,82066fc <___svfprintf_internal_r+0x1e44>
 82061fc:	00801184 	movi	r2,70
 8206200:	88817126 	beq	r17,r2,82067c8 <___svfprintf_internal_r+0x1f10>
 8206204:	00801144 	movi	r2,69
 8206208:	b0816226 	beq	r22,r2,8206794 <___svfprintf_internal_r+0x1edc>
 820620c:	d8c02917 	ldw	r3,164(sp)
 8206210:	d8802104 	addi	r2,sp,132
 8206214:	d8800315 	stw	r2,12(sp)
 8206218:	d9403617 	ldw	r5,216(sp)
 820621c:	d8802504 	addi	r2,sp,148
 8206220:	d8800215 	stw	r2,8(sp)
 8206224:	d8802604 	addi	r2,sp,152
 8206228:	d8c00015 	stw	r3,0(sp)
 820622c:	d8800115 	stw	r2,4(sp)
 8206230:	01c00084 	movi	r7,2
 8206234:	a00d883a 	mov	r6,r20
 8206238:	9809883a 	mov	r4,r19
 820623c:	d8c03d15 	stw	r3,244(sp)
 8206240:	da003e15 	stw	r8,248(sp)
 8206244:	82092140 	call	8209214 <_dtoa_r>
 8206248:	1021883a 	mov	r16,r2
 820624c:	008019c4 	movi	r2,103
 8206250:	d8c03d17 	ldw	r3,244(sp)
 8206254:	da003e17 	ldw	r8,248(sp)
 8206258:	8880e726 	beq	r17,r2,82065f8 <___svfprintf_internal_r+0x1d40>
 820625c:	008011c4 	movi	r2,71
 8206260:	8880d426 	beq	r17,r2,82065b4 <___svfprintf_internal_r+0x1cfc>
 8206264:	80f9883a 	add	fp,r16,r3
 8206268:	d9003617 	ldw	r4,216(sp)
 820626c:	000d883a 	mov	r6,zero
 8206270:	000f883a 	mov	r7,zero
 8206274:	a00b883a 	mov	r5,r20
 8206278:	da003e15 	stw	r8,248(sp)
 820627c:	8212f580 	call	8212f58 <__eqdf2>
 8206280:	da003e17 	ldw	r8,248(sp)
 8206284:	1000e426 	beq	r2,zero,8206618 <___svfprintf_internal_r+0x1d60>
 8206288:	d8802117 	ldw	r2,132(sp)
 820628c:	1700062e 	bgeu	r2,fp,82062a8 <___svfprintf_internal_r+0x19f0>
 8206290:	01000c04 	movi	r4,48
 8206294:	10c00044 	addi	r3,r2,1
 8206298:	d8c02115 	stw	r3,132(sp)
 820629c:	11000005 	stb	r4,0(r2)
 82062a0:	d8802117 	ldw	r2,132(sp)
 82062a4:	173ffb36 	bltu	r2,fp,8206294 <___svfprintf_internal_r+0x19dc>
 82062a8:	1405c83a 	sub	r2,r2,r16
 82062ac:	d8803315 	stw	r2,204(sp)
 82062b0:	008011c4 	movi	r2,71
 82062b4:	b080c526 	beq	r22,r2,82065cc <___svfprintf_internal_r+0x1d14>
 82062b8:	00801944 	movi	r2,101
 82062bc:	1441d90e 	bge	r2,r17,8206a24 <___svfprintf_internal_r+0x216c>
 82062c0:	d8c02617 	ldw	r3,152(sp)
 82062c4:	00801984 	movi	r2,102
 82062c8:	d8c03215 	stw	r3,200(sp)
 82062cc:	88813426 	beq	r17,r2,82067a0 <___svfprintf_internal_r+0x1ee8>
 82062d0:	d8c03217 	ldw	r3,200(sp)
 82062d4:	d9003317 	ldw	r4,204(sp)
 82062d8:	19012516 	blt	r3,r4,8206770 <___svfprintf_internal_r+0x1eb8>
 82062dc:	9480004c 	andi	r18,r18,1
 82062e0:	9001841e 	bne	r18,zero,82068f4 <___svfprintf_internal_r+0x203c>
 82062e4:	1805883a 	mov	r2,r3
 82062e8:	1801cc16 	blt	r3,zero,8206a1c <___svfprintf_internal_r+0x2164>
 82062ec:	d8c03217 	ldw	r3,200(sp)
 82062f0:	044019c4 	movi	r17,103
 82062f4:	d8c02e15 	stw	r3,184(sp)
 82062f8:	df002a07 	ldb	fp,168(sp)
 82062fc:	e000a61e 	bne	fp,zero,8206598 <___svfprintf_internal_r+0x1ce0>
 8206300:	df002783 	ldbu	fp,158(sp)
 8206304:	d8802a15 	stw	r2,168(sp)
 8206308:	dc802b17 	ldw	r18,172(sp)
 820630c:	d8002915 	stw	zero,164(sp)
 8206310:	003b1706 	br	8204f70 <___svfprintf_internal_r+0x6b8>
 8206314:	04020974 	movhi	r16,2085
 8206318:	8436dc04 	addi	r16,r16,-9360
 820631c:	003aa606 	br	8204db8 <___svfprintf_internal_r+0x500>
 8206320:	d9003917 	ldw	r4,228(sp)
 8206324:	04001004 	movi	r16,64
 8206328:	800b883a 	mov	r5,r16
 820632c:	820bd480 	call	820bd48 <_malloc_r>
 8206330:	d9002c17 	ldw	r4,176(sp)
 8206334:	20800015 	stw	r2,0(r4)
 8206338:	20800415 	stw	r2,16(r4)
 820633c:	1001cb26 	beq	r2,zero,8206a6c <___svfprintf_internal_r+0x21b4>
 8206340:	d8802c17 	ldw	r2,176(sp)
 8206344:	14000515 	stw	r16,20(r2)
 8206348:	00397606 	br	8204924 <___svfprintf_internal_r+0x6c>
 820634c:	04020974 	movhi	r16,2085
 8206350:	8436de04 	addi	r16,r16,-9352
 8206354:	003ee106 	br	8205edc <___svfprintf_internal_r+0x1624>
 8206358:	d9402c17 	ldw	r5,176(sp)
 820635c:	d9801e04 	addi	r6,sp,120
 8206360:	9809883a 	mov	r4,r19
 8206364:	820e0e40 	call	820e0e4 <__ssprint_r>
 8206368:	103a381e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 820636c:	dc402617 	ldw	r17,152(sp)
 8206370:	d8c02017 	ldw	r3,128(sp)
 8206374:	da000404 	addi	r8,sp,16
 8206378:	003f4306 	br	8206088 <___svfprintf_internal_r+0x17d0>
 820637c:	01400184 	movi	r5,6
 8206380:	d9402915 	stw	r5,164(sp)
 8206384:	003f9506 	br	82061dc <___svfprintf_internal_r+0x1924>
 8206388:	d9002d17 	ldw	r4,180(sp)
 820638c:	25000017 	ldw	r20,0(r4)
 8206390:	21000104 	addi	r4,r4,4
 8206394:	d9002d15 	stw	r4,180(sp)
 8206398:	a02dd7fa 	srai	r22,r20,31
 820639c:	b005883a 	mov	r2,r22
 82063a0:	003a9b06 	br	8204e10 <___svfprintf_internal_r+0x558>
 82063a4:	d9402d17 	ldw	r5,180(sp)
 82063a8:	002d883a 	mov	r22,zero
 82063ac:	2d000017 	ldw	r20,0(r5)
 82063b0:	29400104 	addi	r5,r5,4
 82063b4:	d9402d15 	stw	r5,180(sp)
 82063b8:	003bf906 	br	82053a0 <___svfprintf_internal_r+0xae8>
 82063bc:	9480100c 	andi	r18,r18,64
 82063c0:	90006e26 	beq	r18,zero,820657c <___svfprintf_internal_r+0x1cc4>
 82063c4:	d9002d17 	ldw	r4,180(sp)
 82063c8:	d9402f17 	ldw	r5,188(sp)
 82063cc:	20800017 	ldw	r2,0(r4)
 82063d0:	21000104 	addi	r4,r4,4
 82063d4:	d9002d15 	stw	r4,180(sp)
 82063d8:	1140000d 	sth	r5,0(r2)
 82063dc:	00396106 	br	8204964 <___svfprintf_internal_r+0xac>
 82063e0:	d9402c17 	ldw	r5,176(sp)
 82063e4:	d9801e04 	addi	r6,sp,120
 82063e8:	9809883a 	mov	r4,r19
 82063ec:	820e0e40 	call	820e0e4 <__ssprint_r>
 82063f0:	103a161e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 82063f4:	d8c02017 	ldw	r3,128(sp)
 82063f8:	d8801f17 	ldw	r2,124(sp)
 82063fc:	da000404 	addi	r8,sp,16
 8206400:	d9403317 	ldw	r5,204(sp)
 8206404:	10800044 	addi	r2,r2,1
 8206408:	44000015 	stw	r16,0(r8)
 820640c:	28c7883a 	add	r3,r5,r3
 8206410:	003b7706 	br	82051f0 <___svfprintf_internal_r+0x938>
 8206414:	8009883a 	mov	r4,r16
 8206418:	da003e15 	stw	r8,248(sp)
 820641c:	8203fbc0 	call	8203fbc <strlen>
 8206420:	d8802e15 	stw	r2,184(sp)
 8206424:	da003e17 	ldw	r8,248(sp)
 8206428:	103c280e 	bge	r2,zero,82054cc <___svfprintf_internal_r+0xc14>
 820642c:	0005883a 	mov	r2,zero
 8206430:	003c2606 	br	82054cc <___svfprintf_internal_r+0xc14>
 8206434:	00bfffc4 	movi	r2,-1
 8206438:	003a0906 	br	8204c60 <___svfprintf_internal_r+0x3a8>
 820643c:	01020974 	movhi	r4,2085
 8206440:	2136f084 	addi	r4,r4,-9278
 8206444:	d9003515 	stw	r4,212(sp)
 8206448:	003b0606 	br	8205064 <___svfprintf_internal_r+0x7ac>
 820644c:	013fffc4 	movi	r4,-1
 8206450:	003a2706 	br	8204cf0 <___svfprintf_internal_r+0x438>
 8206454:	d9402c17 	ldw	r5,176(sp)
 8206458:	d9801e04 	addi	r6,sp,120
 820645c:	9809883a 	mov	r4,r19
 8206460:	820e0e40 	call	820e0e4 <__ssprint_r>
 8206464:	1039f91e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 8206468:	d8c02017 	ldw	r3,128(sp)
 820646c:	da000404 	addi	r8,sp,16
 8206470:	003d8406 	br	8205a84 <___svfprintf_internal_r+0x11cc>
 8206474:	0023883a 	mov	r17,zero
 8206478:	003d8306 	br	8205a88 <___svfprintf_internal_r+0x11d0>
 820647c:	01020974 	movhi	r4,2085
 8206480:	2136ec84 	addi	r4,r4,-9294
 8206484:	d9002b15 	stw	r4,172(sp)
 8206488:	d9002b17 	ldw	r4,172(sp)
 820648c:	1c47883a 	add	r3,r3,r17
 8206490:	10800044 	addi	r2,r2,1
 8206494:	41000015 	stw	r4,0(r8)
 8206498:	44400115 	stw	r17,4(r8)
 820649c:	d8c02015 	stw	r3,128(sp)
 82064a0:	d8801f15 	stw	r2,124(sp)
 82064a4:	010001c4 	movi	r4,7
 82064a8:	20bfcd16 	blt	r4,r2,82063e0 <___svfprintf_internal_r+0x1b28>
 82064ac:	42000204 	addi	r8,r8,8
 82064b0:	003fd306 	br	8206400 <___svfprintf_internal_r+0x1b48>
 82064b4:	d9402c17 	ldw	r5,176(sp)
 82064b8:	d9801e04 	addi	r6,sp,120
 82064bc:	9809883a 	mov	r4,r19
 82064c0:	820e0e40 	call	820e0e4 <__ssprint_r>
 82064c4:	1039e11e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 82064c8:	d8802617 	ldw	r2,152(sp)
 82064cc:	d8c02017 	ldw	r3,128(sp)
 82064d0:	da000404 	addi	r8,sp,16
 82064d4:	003e1c06 	br	8205d48 <___svfprintf_internal_r+0x1490>
 82064d8:	d8802917 	ldw	r2,164(sp)
 82064dc:	00c00184 	movi	r3,6
 82064e0:	1880012e 	bgeu	r3,r2,82064e8 <___svfprintf_internal_r+0x1c30>
 82064e4:	1805883a 	mov	r2,r3
 82064e8:	d8802e15 	stw	r2,184(sp)
 82064ec:	1000f316 	blt	r2,zero,82068bc <___svfprintf_internal_r+0x2004>
 82064f0:	04020974 	movhi	r16,2085
 82064f4:	d8802a15 	stw	r2,168(sp)
 82064f8:	dd002d15 	stw	r20,180(sp)
 82064fc:	d8002915 	stw	zero,164(sp)
 8206500:	d8003215 	stw	zero,200(sp)
 8206504:	8436ea04 	addi	r16,r16,-9304
 8206508:	0039883a 	mov	fp,zero
 820650c:	003a9f06 	br	8204f8c <___svfprintf_internal_r+0x6d4>
 8206510:	01020974 	movhi	r4,2085
 8206514:	2136f084 	addi	r4,r4,-9278
 8206518:	d9003515 	stw	r4,212(sp)
 820651c:	003b5f06 	br	820529c <___svfprintf_internal_r+0x9e4>
 8206520:	d9402c17 	ldw	r5,176(sp)
 8206524:	d9801e04 	addi	r6,sp,120
 8206528:	9809883a 	mov	r4,r19
 820652c:	820e0e40 	call	820e0e4 <__ssprint_r>
 8206530:	1039c61e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 8206534:	d8802617 	ldw	r2,152(sp)
 8206538:	d9403317 	ldw	r5,204(sp)
 820653c:	d8c02017 	ldw	r3,128(sp)
 8206540:	da000404 	addi	r8,sp,16
 8206544:	2885c83a 	sub	r2,r5,r2
 8206548:	003e1006 	br	8205d8c <___svfprintf_internal_r+0x14d4>
 820654c:	00800044 	movi	r2,1
 8206550:	10803fcc 	andi	r2,r2,255
 8206554:	00c00044 	movi	r3,1
 8206558:	10fa3526 	beq	r2,r3,8204e30 <___svfprintf_internal_r+0x578>
 820655c:	00c00084 	movi	r3,2
 8206560:	10fb9e26 	beq	r2,r3,82053dc <___svfprintf_internal_r+0xb24>
 8206564:	003a6406 	br	8204ef8 <___svfprintf_internal_r+0x640>
 8206568:	0021883a 	mov	r16,zero
 820656c:	003e0806 	br	8205d90 <___svfprintf_internal_r+0x14d8>
 8206570:	07000b44 	movi	fp,45
 8206574:	df002785 	stb	fp,158(sp)
 8206578:	003a0b06 	br	8204da8 <___svfprintf_internal_r+0x4f0>
 820657c:	d8c02d17 	ldw	r3,180(sp)
 8206580:	d9002f17 	ldw	r4,188(sp)
 8206584:	18800017 	ldw	r2,0(r3)
 8206588:	18c00104 	addi	r3,r3,4
 820658c:	d8c02d15 	stw	r3,180(sp)
 8206590:	11000015 	stw	r4,0(r2)
 8206594:	0038f306 	br	8204964 <___svfprintf_internal_r+0xac>
 8206598:	00c00b44 	movi	r3,45
 820659c:	d8c02785 	stb	r3,158(sp)
 82065a0:	d8802a15 	stw	r2,168(sp)
 82065a4:	dc802b17 	ldw	r18,172(sp)
 82065a8:	d8002915 	stw	zero,164(sp)
 82065ac:	07000b44 	movi	fp,45
 82065b0:	003a7306 	br	8204f80 <___svfprintf_internal_r+0x6c8>
 82065b4:	9080004c 	andi	r2,r18,1
 82065b8:	1000941e 	bne	r2,zero,820680c <___svfprintf_internal_r+0x1f54>
 82065bc:	d8802117 	ldw	r2,132(sp)
 82065c0:	1405c83a 	sub	r2,r2,r16
 82065c4:	d8803315 	stw	r2,204(sp)
 82065c8:	b441161e 	bne	r22,r17,8206a24 <___svfprintf_internal_r+0x216c>
 82065cc:	dd802617 	ldw	r22,152(sp)
 82065d0:	00bfff44 	movi	r2,-3
 82065d4:	b0801a16 	blt	r22,r2,8206640 <___svfprintf_internal_r+0x1d88>
 82065d8:	d9402917 	ldw	r5,164(sp)
 82065dc:	2d801816 	blt	r5,r22,8206640 <___svfprintf_internal_r+0x1d88>
 82065e0:	dd803215 	stw	r22,200(sp)
 82065e4:	003f3a06 	br	82062d0 <___svfprintf_internal_r+0x1a18>
 82065e8:	1025883a 	mov	r18,r2
 82065ec:	0039883a 	mov	fp,zero
 82065f0:	00800084 	movi	r2,2
 82065f4:	003fd606 	br	8206550 <___svfprintf_internal_r+0x1c98>
 82065f8:	9080004c 	andi	r2,r18,1
 82065fc:	103f191e 	bne	r2,zero,8206264 <___svfprintf_internal_r+0x19ac>
 8206600:	d8802117 	ldw	r2,132(sp)
 8206604:	003f2806 	br	82062a8 <___svfprintf_internal_r+0x19f0>
 8206608:	01020974 	movhi	r4,2085
 820660c:	2136ec84 	addi	r4,r4,-9294
 8206610:	d9002b15 	stw	r4,172(sp)
 8206614:	003c7c06 	br	8205808 <___svfprintf_internal_r+0xf50>
 8206618:	e005883a 	mov	r2,fp
 820661c:	003f2206 	br	82062a8 <___svfprintf_internal_r+0x19f0>
 8206620:	d9402917 	ldw	r5,164(sp)
 8206624:	df002783 	ldbu	fp,158(sp)
 8206628:	dd002d15 	stw	r20,180(sp)
 820662c:	d9402a15 	stw	r5,168(sp)
 8206630:	d9402e15 	stw	r5,184(sp)
 8206634:	d8002915 	stw	zero,164(sp)
 8206638:	d8003215 	stw	zero,200(sp)
 820663c:	003a4c06 	br	8204f70 <___svfprintf_internal_r+0x6b8>
 8206640:	8c7fff84 	addi	r17,r17,-2
 8206644:	b5bfffc4 	addi	r22,r22,-1
 8206648:	dd802615 	stw	r22,152(sp)
 820664c:	dc4022c5 	stb	r17,139(sp)
 8206650:	b000c316 	blt	r22,zero,8206960 <___svfprintf_internal_r+0x20a8>
 8206654:	00800ac4 	movi	r2,43
 8206658:	d8802305 	stb	r2,140(sp)
 820665c:	00800244 	movi	r2,9
 8206660:	15806e16 	blt	r2,r22,820681c <___svfprintf_internal_r+0x1f64>
 8206664:	00800c04 	movi	r2,48
 8206668:	b5800c04 	addi	r22,r22,48
 820666c:	d8802345 	stb	r2,141(sp)
 8206670:	dd802385 	stb	r22,142(sp)
 8206674:	d88023c4 	addi	r2,sp,143
 8206678:	df0022c4 	addi	fp,sp,139
 820667c:	d8c03317 	ldw	r3,204(sp)
 8206680:	1739c83a 	sub	fp,r2,fp
 8206684:	d9003317 	ldw	r4,204(sp)
 8206688:	e0c7883a 	add	r3,fp,r3
 820668c:	df003b15 	stw	fp,236(sp)
 8206690:	d8c02e15 	stw	r3,184(sp)
 8206694:	00800044 	movi	r2,1
 8206698:	1100b70e 	bge	r2,r4,8206978 <___svfprintf_internal_r+0x20c0>
 820669c:	d8c02e17 	ldw	r3,184(sp)
 82066a0:	18c00044 	addi	r3,r3,1
 82066a4:	d8c02e15 	stw	r3,184(sp)
 82066a8:	1805883a 	mov	r2,r3
 82066ac:	1800b016 	blt	r3,zero,8206970 <___svfprintf_internal_r+0x20b8>
 82066b0:	d8003215 	stw	zero,200(sp)
 82066b4:	003f1006 	br	82062f8 <___svfprintf_internal_r+0x1a40>
 82066b8:	d8802917 	ldw	r2,164(sp)
 82066bc:	103ec71e 	bne	r2,zero,82061dc <___svfprintf_internal_r+0x1924>
 82066c0:	dc002915 	stw	r16,164(sp)
 82066c4:	003ec506 	br	82061dc <___svfprintf_internal_r+0x1924>
 82066c8:	d9402c17 	ldw	r5,176(sp)
 82066cc:	d9801e04 	addi	r6,sp,120
 82066d0:	9809883a 	mov	r4,r19
 82066d4:	820e0e40 	call	820e0e4 <__ssprint_r>
 82066d8:	10395c1e 	bne	r2,zero,8204c4c <___svfprintf_internal_r+0x394>
 82066dc:	dc402617 	ldw	r17,152(sp)
 82066e0:	d8c02017 	ldw	r3,128(sp)
 82066e4:	d8801f17 	ldw	r2,124(sp)
 82066e8:	da000404 	addi	r8,sp,16
 82066ec:	003e7706 	br	82060cc <___svfprintf_internal_r+0x1814>
 82066f0:	582f883a 	mov	r23,r11
 82066f4:	d8002915 	stw	zero,164(sp)
 82066f8:	0038c406 	br	8204a0c <___svfprintf_internal_r+0x154>
 82066fc:	d8c02917 	ldw	r3,164(sp)
 8206700:	d8802104 	addi	r2,sp,132
 8206704:	d8800315 	stw	r2,12(sp)
 8206708:	d9403617 	ldw	r5,216(sp)
 820670c:	d8802504 	addi	r2,sp,148
 8206710:	d8800215 	stw	r2,8(sp)
 8206714:	d8802604 	addi	r2,sp,152
 8206718:	d8c00015 	stw	r3,0(sp)
 820671c:	9809883a 	mov	r4,r19
 8206720:	d8800115 	stw	r2,4(sp)
 8206724:	01c000c4 	movi	r7,3
 8206728:	a00d883a 	mov	r6,r20
 820672c:	da003e15 	stw	r8,248(sp)
 8206730:	82092140 	call	8209214 <_dtoa_r>
 8206734:	d9002917 	ldw	r4,164(sp)
 8206738:	da003e17 	ldw	r8,248(sp)
 820673c:	1021883a 	mov	r16,r2
 8206740:	1139883a 	add	fp,r2,r4
 8206744:	2007883a 	mov	r3,r4
 8206748:	81000007 	ldb	r4,0(r16)
 820674c:	00800c04 	movi	r2,48
 8206750:	20806f26 	beq	r4,r2,8206910 <___svfprintf_internal_r+0x2058>
 8206754:	d8c02617 	ldw	r3,152(sp)
 8206758:	e0f9883a 	add	fp,fp,r3
 820675c:	003ec206 	br	8206268 <___svfprintf_internal_r+0x19b0>
 8206760:	00c00b44 	movi	r3,45
 8206764:	2520003c 	xorhi	r20,r4,32768
 8206768:	d8c02a05 	stb	r3,168(sp)
 820676c:	003ea106 	br	82061f4 <___svfprintf_internal_r+0x193c>
 8206770:	d8c03217 	ldw	r3,200(sp)
 8206774:	00c0890e 	bge	zero,r3,820699c <___svfprintf_internal_r+0x20e4>
 8206778:	00800044 	movi	r2,1
 820677c:	d9003317 	ldw	r4,204(sp)
 8206780:	1105883a 	add	r2,r2,r4
 8206784:	d8802e15 	stw	r2,184(sp)
 8206788:	10005f16 	blt	r2,zero,8206908 <___svfprintf_internal_r+0x2050>
 820678c:	044019c4 	movi	r17,103
 8206790:	003ed906 	br	82062f8 <___svfprintf_internal_r+0x1a40>
 8206794:	d9002917 	ldw	r4,164(sp)
 8206798:	20c00044 	addi	r3,r4,1
 820679c:	003e9c06 	br	8206210 <___svfprintf_internal_r+0x1958>
 82067a0:	d9002917 	ldw	r4,164(sp)
 82067a4:	00c0680e 	bge	zero,r3,8206948 <___svfprintf_internal_r+0x2090>
 82067a8:	2000461e 	bne	r4,zero,82068c4 <___svfprintf_internal_r+0x200c>
 82067ac:	9480004c 	andi	r18,r18,1
 82067b0:	9000441e 	bne	r18,zero,82068c4 <___svfprintf_internal_r+0x200c>
 82067b4:	1805883a 	mov	r2,r3
 82067b8:	1800a016 	blt	r3,zero,8206a3c <___svfprintf_internal_r+0x2184>
 82067bc:	d8c03217 	ldw	r3,200(sp)
 82067c0:	d8c02e15 	stw	r3,184(sp)
 82067c4:	003ecc06 	br	82062f8 <___svfprintf_internal_r+0x1a40>
 82067c8:	d9402917 	ldw	r5,164(sp)
 82067cc:	d8802104 	addi	r2,sp,132
 82067d0:	d8800315 	stw	r2,12(sp)
 82067d4:	d9400015 	stw	r5,0(sp)
 82067d8:	d8802504 	addi	r2,sp,148
 82067dc:	d9403617 	ldw	r5,216(sp)
 82067e0:	d8800215 	stw	r2,8(sp)
 82067e4:	d8802604 	addi	r2,sp,152
 82067e8:	d8800115 	stw	r2,4(sp)
 82067ec:	01c000c4 	movi	r7,3
 82067f0:	a00d883a 	mov	r6,r20
 82067f4:	9809883a 	mov	r4,r19
 82067f8:	da003e15 	stw	r8,248(sp)
 82067fc:	82092140 	call	8209214 <_dtoa_r>
 8206800:	d8c02917 	ldw	r3,164(sp)
 8206804:	da003e17 	ldw	r8,248(sp)
 8206808:	1021883a 	mov	r16,r2
 820680c:	00801184 	movi	r2,70
 8206810:	80f9883a 	add	fp,r16,r3
 8206814:	88bfcc26 	beq	r17,r2,8206748 <___svfprintf_internal_r+0x1e90>
 8206818:	003e9306 	br	8206268 <___svfprintf_internal_r+0x19b0>
 820681c:	df0022c4 	addi	fp,sp,139
 8206820:	dc002915 	stw	r16,164(sp)
 8206824:	9829883a 	mov	r20,r19
 8206828:	e021883a 	mov	r16,fp
 820682c:	4027883a 	mov	r19,r8
 8206830:	b009883a 	mov	r4,r22
 8206834:	01400284 	movi	r5,10
 8206838:	8202bf80 	call	8202bf8 <__modsi3>
 820683c:	10800c04 	addi	r2,r2,48
 8206840:	843fffc4 	addi	r16,r16,-1
 8206844:	b009883a 	mov	r4,r22
 8206848:	01400284 	movi	r5,10
 820684c:	80800005 	stb	r2,0(r16)
 8206850:	8202b740 	call	8202b74 <__divsi3>
 8206854:	102d883a 	mov	r22,r2
 8206858:	00800244 	movi	r2,9
 820685c:	15bff416 	blt	r2,r22,8206830 <___svfprintf_internal_r+0x1f78>
 8206860:	9811883a 	mov	r8,r19
 8206864:	b0800c04 	addi	r2,r22,48
 8206868:	a027883a 	mov	r19,r20
 820686c:	8029883a 	mov	r20,r16
 8206870:	a17fffc4 	addi	r5,r20,-1
 8206874:	a0bfffc5 	stb	r2,-1(r20)
 8206878:	dc002917 	ldw	r16,164(sp)
 820687c:	2f00752e 	bgeu	r5,fp,8206a54 <___svfprintf_internal_r+0x219c>
 8206880:	d9c02384 	addi	r7,sp,142
 8206884:	3d0fc83a 	sub	r7,r7,r20
 8206888:	d9002344 	addi	r4,sp,141
 820688c:	e1cf883a 	add	r7,fp,r7
 8206890:	00000106 	br	8206898 <___svfprintf_internal_r+0x1fe0>
 8206894:	28800003 	ldbu	r2,0(r5)
 8206898:	20800005 	stb	r2,0(r4)
 820689c:	21000044 	addi	r4,r4,1
 82068a0:	29400044 	addi	r5,r5,1
 82068a4:	21fffb1e 	bne	r4,r7,8206894 <___svfprintf_internal_r+0x1fdc>
 82068a8:	d8802304 	addi	r2,sp,140
 82068ac:	1505c83a 	sub	r2,r2,r20
 82068b0:	d8c02344 	addi	r3,sp,141
 82068b4:	1885883a 	add	r2,r3,r2
 82068b8:	003f7006 	br	820667c <___svfprintf_internal_r+0x1dc4>
 82068bc:	0005883a 	mov	r2,zero
 82068c0:	003f0b06 	br	82064f0 <___svfprintf_internal_r+0x1c38>
 82068c4:	d9002917 	ldw	r4,164(sp)
 82068c8:	d8c03217 	ldw	r3,200(sp)
 82068cc:	20800044 	addi	r2,r4,1
 82068d0:	1885883a 	add	r2,r3,r2
 82068d4:	d8802e15 	stw	r2,184(sp)
 82068d8:	103e870e 	bge	r2,zero,82062f8 <___svfprintf_internal_r+0x1a40>
 82068dc:	0005883a 	mov	r2,zero
 82068e0:	003e8506 	br	82062f8 <___svfprintf_internal_r+0x1a40>
 82068e4:	01020974 	movhi	r4,2085
 82068e8:	2136ec84 	addi	r4,r4,-9294
 82068ec:	d9002b15 	stw	r4,172(sp)
 82068f0:	003cc506 	br	8205c08 <___svfprintf_internal_r+0x1350>
 82068f4:	d8c03217 	ldw	r3,200(sp)
 82068f8:	18c00044 	addi	r3,r3,1
 82068fc:	d8c02e15 	stw	r3,184(sp)
 8206900:	1805883a 	mov	r2,r3
 8206904:	183fa10e 	bge	r3,zero,820678c <___svfprintf_internal_r+0x1ed4>
 8206908:	0005883a 	mov	r2,zero
 820690c:	003f9f06 	br	820678c <___svfprintf_internal_r+0x1ed4>
 8206910:	d9003617 	ldw	r4,216(sp)
 8206914:	000d883a 	mov	r6,zero
 8206918:	000f883a 	mov	r7,zero
 820691c:	a00b883a 	mov	r5,r20
 8206920:	d8c03d15 	stw	r3,244(sp)
 8206924:	da003e15 	stw	r8,248(sp)
 8206928:	8212f580 	call	8212f58 <__eqdf2>
 820692c:	d8c03d17 	ldw	r3,244(sp)
 8206930:	da003e17 	ldw	r8,248(sp)
 8206934:	103f8726 	beq	r2,zero,8206754 <___svfprintf_internal_r+0x1e9c>
 8206938:	00800044 	movi	r2,1
 820693c:	10c7c83a 	sub	r3,r2,r3
 8206940:	d8c02615 	stw	r3,152(sp)
 8206944:	003f8406 	br	8206758 <___svfprintf_internal_r+0x1ea0>
 8206948:	20000e1e 	bne	r4,zero,8206984 <___svfprintf_internal_r+0x20cc>
 820694c:	9480004c 	andi	r18,r18,1
 8206950:	90000c1e 	bne	r18,zero,8206984 <___svfprintf_internal_r+0x20cc>
 8206954:	00800044 	movi	r2,1
 8206958:	d8802e15 	stw	r2,184(sp)
 820695c:	003e6606 	br	82062f8 <___svfprintf_internal_r+0x1a40>
 8206960:	00800b44 	movi	r2,45
 8206964:	05adc83a 	sub	r22,zero,r22
 8206968:	d8802305 	stb	r2,140(sp)
 820696c:	003f3b06 	br	820665c <___svfprintf_internal_r+0x1da4>
 8206970:	0005883a 	mov	r2,zero
 8206974:	003f4e06 	br	82066b0 <___svfprintf_internal_r+0x1df8>
 8206978:	90a4703a 	and	r18,r18,r2
 820697c:	903f4a26 	beq	r18,zero,82066a8 <___svfprintf_internal_r+0x1df0>
 8206980:	003f4606 	br	820669c <___svfprintf_internal_r+0x1de4>
 8206984:	d8c02917 	ldw	r3,164(sp)
 8206988:	18c00084 	addi	r3,r3,2
 820698c:	d8c02e15 	stw	r3,184(sp)
 8206990:	1805883a 	mov	r2,r3
 8206994:	183e580e 	bge	r3,zero,82062f8 <___svfprintf_internal_r+0x1a40>
 8206998:	003fd006 	br	82068dc <___svfprintf_internal_r+0x2024>
 820699c:	00800084 	movi	r2,2
 82069a0:	10c5c83a 	sub	r2,r2,r3
 82069a4:	003f7506 	br	820677c <___svfprintf_internal_r+0x1ec4>
 82069a8:	d8802d17 	ldw	r2,180(sp)
 82069ac:	d9002d17 	ldw	r4,180(sp)
 82069b0:	bc400043 	ldbu	r17,1(r23)
 82069b4:	10800017 	ldw	r2,0(r2)
 82069b8:	582f883a 	mov	r23,r11
 82069bc:	d8802915 	stw	r2,164(sp)
 82069c0:	20800104 	addi	r2,r4,4
 82069c4:	d9002917 	ldw	r4,164(sp)
 82069c8:	d8802d15 	stw	r2,180(sp)
 82069cc:	203df00e 	bge	r4,zero,8206190 <___svfprintf_internal_r+0x18d8>
 82069d0:	8c403fcc 	andi	r17,r17,255
 82069d4:	00bfffc4 	movi	r2,-1
 82069d8:	8c40201c 	xori	r17,r17,128
 82069dc:	d8802915 	stw	r2,164(sp)
 82069e0:	8c7fe004 	addi	r17,r17,-128
 82069e4:	00380806 	br	8204a08 <___svfprintf_internal_r+0x150>
 82069e8:	9080004c 	andi	r2,r18,1
 82069ec:	0039883a 	mov	fp,zero
 82069f0:	10000726 	beq	r2,zero,8206a10 <___svfprintf_internal_r+0x2158>
 82069f4:	d8c02817 	ldw	r3,160(sp)
 82069f8:	dc001dc4 	addi	r16,sp,119
 82069fc:	00800c04 	movi	r2,48
 8206a00:	1c07c83a 	sub	r3,r3,r16
 8206a04:	d8801dc5 	stb	r2,119(sp)
 8206a08:	d8c02e15 	stw	r3,184(sp)
 8206a0c:	00395206 	br	8204f58 <___svfprintf_internal_r+0x6a0>
 8206a10:	d8002e15 	stw	zero,184(sp)
 8206a14:	dc001e04 	addi	r16,sp,120
 8206a18:	00394f06 	br	8204f58 <___svfprintf_internal_r+0x6a0>
 8206a1c:	0005883a 	mov	r2,zero
 8206a20:	003e3206 	br	82062ec <___svfprintf_internal_r+0x1a34>
 8206a24:	dd802617 	ldw	r22,152(sp)
 8206a28:	003f0606 	br	8206644 <___svfprintf_internal_r+0x1d8c>
 8206a2c:	d9c02785 	stb	r7,158(sp)
 8206a30:	003a5106 	br	8205378 <___svfprintf_internal_r+0xac0>
 8206a34:	d9c02785 	stb	r7,158(sp)
 8206a38:	003a3706 	br	8205318 <___svfprintf_internal_r+0xa60>
 8206a3c:	0005883a 	mov	r2,zero
 8206a40:	003f5e06 	br	82067bc <___svfprintf_internal_r+0x1f04>
 8206a44:	d9c02785 	stb	r7,158(sp)
 8206a48:	00391706 	br	8204ea8 <___svfprintf_internal_r+0x5f0>
 8206a4c:	d9c02785 	stb	r7,158(sp)
 8206a50:	0038e606 	br	8204dec <___svfprintf_internal_r+0x534>
 8206a54:	d8802344 	addi	r2,sp,141
 8206a58:	003f0806 	br	820667c <___svfprintf_internal_r+0x1dc4>
 8206a5c:	d9c02785 	stb	r7,158(sp)
 8206a60:	0038b706 	br	8204d40 <___svfprintf_internal_r+0x488>
 8206a64:	d9c02785 	stb	r7,158(sp)
 8206a68:	003adc06 	br	82055dc <___svfprintf_internal_r+0xd24>
 8206a6c:	d9403917 	ldw	r5,228(sp)
 8206a70:	00800304 	movi	r2,12
 8206a74:	28800015 	stw	r2,0(r5)
 8206a78:	00bfffc4 	movi	r2,-1
 8206a7c:	00387806 	br	8204c60 <___svfprintf_internal_r+0x3a8>
 8206a80:	d9c02785 	stb	r7,158(sp)
 8206a84:	003abf06 	br	8205584 <___svfprintf_internal_r+0xccc>
 8206a88:	d9c02785 	stb	r7,158(sp)
 8206a8c:	003a9b06 	br	82054fc <___svfprintf_internal_r+0xc44>

08206a90 <_user_strerror>:
 8206a90:	0005883a 	mov	r2,zero
 8206a94:	f800283a 	ret

08206a98 <___vfprintf_internal_r>:
 8206a98:	deffb804 	addi	sp,sp,-288
 8206a9c:	dfc04715 	stw	ra,284(sp)
 8206aa0:	ddc04515 	stw	r23,276(sp)
 8206aa4:	dd404315 	stw	r21,268(sp)
 8206aa8:	d9002c15 	stw	r4,176(sp)
 8206aac:	282f883a 	mov	r23,r5
 8206ab0:	302b883a 	mov	r21,r6
 8206ab4:	d9c02d15 	stw	r7,180(sp)
 8206ab8:	df004615 	stw	fp,280(sp)
 8206abc:	dd804415 	stw	r22,272(sp)
 8206ac0:	dd004215 	stw	r20,264(sp)
 8206ac4:	dcc04115 	stw	r19,260(sp)
 8206ac8:	dc804015 	stw	r18,256(sp)
 8206acc:	dc403f15 	stw	r17,252(sp)
 8206ad0:	dc003e15 	stw	r16,248(sp)
 8206ad4:	820bb5c0 	call	820bb5c <_localeconv_r>
 8206ad8:	10800017 	ldw	r2,0(r2)
 8206adc:	1009883a 	mov	r4,r2
 8206ae0:	d8803415 	stw	r2,208(sp)
 8206ae4:	8203fbc0 	call	8203fbc <strlen>
 8206ae8:	d8803715 	stw	r2,220(sp)
 8206aec:	d8802c17 	ldw	r2,176(sp)
 8206af0:	10000226 	beq	r2,zero,8206afc <___vfprintf_internal_r+0x64>
 8206af4:	10800e17 	ldw	r2,56(r2)
 8206af8:	1000f926 	beq	r2,zero,8206ee0 <___vfprintf_internal_r+0x448>
 8206afc:	b880030b 	ldhu	r2,12(r23)
 8206b00:	10c8000c 	andi	r3,r2,8192
 8206b04:	1800061e 	bne	r3,zero,8206b20 <___vfprintf_internal_r+0x88>
 8206b08:	b9001917 	ldw	r4,100(r23)
 8206b0c:	00f7ffc4 	movi	r3,-8193
 8206b10:	10880014 	ori	r2,r2,8192
 8206b14:	20c6703a 	and	r3,r4,r3
 8206b18:	b880030d 	sth	r2,12(r23)
 8206b1c:	b8c01915 	stw	r3,100(r23)
 8206b20:	10c0020c 	andi	r3,r2,8
 8206b24:	1800c126 	beq	r3,zero,8206e2c <___vfprintf_internal_r+0x394>
 8206b28:	b8c00417 	ldw	r3,16(r23)
 8206b2c:	1800bf26 	beq	r3,zero,8206e2c <___vfprintf_internal_r+0x394>
 8206b30:	1080068c 	andi	r2,r2,26
 8206b34:	00c00284 	movi	r3,10
 8206b38:	10c0c426 	beq	r2,r3,8206e4c <___vfprintf_internal_r+0x3b4>
 8206b3c:	d8c00404 	addi	r3,sp,16
 8206b40:	05020974 	movhi	r20,2085
 8206b44:	d9001e04 	addi	r4,sp,120
 8206b48:	a536f484 	addi	r20,r20,-9262
 8206b4c:	d8c01e15 	stw	r3,120(sp)
 8206b50:	d8002015 	stw	zero,128(sp)
 8206b54:	d8001f15 	stw	zero,124(sp)
 8206b58:	d8003315 	stw	zero,204(sp)
 8206b5c:	d8003615 	stw	zero,216(sp)
 8206b60:	d8003815 	stw	zero,224(sp)
 8206b64:	1811883a 	mov	r8,r3
 8206b68:	d8003915 	stw	zero,228(sp)
 8206b6c:	d8003a15 	stw	zero,232(sp)
 8206b70:	d8002f15 	stw	zero,188(sp)
 8206b74:	d9002815 	stw	r4,160(sp)
 8206b78:	a8800007 	ldb	r2,0(r21)
 8206b7c:	10027b26 	beq	r2,zero,820756c <___vfprintf_internal_r+0xad4>
 8206b80:	00c00944 	movi	r3,37
 8206b84:	a821883a 	mov	r16,r21
 8206b88:	10c0021e 	bne	r2,r3,8206b94 <___vfprintf_internal_r+0xfc>
 8206b8c:	00001406 	br	8206be0 <___vfprintf_internal_r+0x148>
 8206b90:	10c00326 	beq	r2,r3,8206ba0 <___vfprintf_internal_r+0x108>
 8206b94:	84000044 	addi	r16,r16,1
 8206b98:	80800007 	ldb	r2,0(r16)
 8206b9c:	103ffc1e 	bne	r2,zero,8206b90 <___vfprintf_internal_r+0xf8>
 8206ba0:	8563c83a 	sub	r17,r16,r21
 8206ba4:	88000e26 	beq	r17,zero,8206be0 <___vfprintf_internal_r+0x148>
 8206ba8:	d8c02017 	ldw	r3,128(sp)
 8206bac:	d8801f17 	ldw	r2,124(sp)
 8206bb0:	45400015 	stw	r21,0(r8)
 8206bb4:	1c47883a 	add	r3,r3,r17
 8206bb8:	10800044 	addi	r2,r2,1
 8206bbc:	d8c02015 	stw	r3,128(sp)
 8206bc0:	44400115 	stw	r17,4(r8)
 8206bc4:	d8801f15 	stw	r2,124(sp)
 8206bc8:	00c001c4 	movi	r3,7
 8206bcc:	1880a716 	blt	r3,r2,8206e6c <___vfprintf_internal_r+0x3d4>
 8206bd0:	42000204 	addi	r8,r8,8
 8206bd4:	d9402f17 	ldw	r5,188(sp)
 8206bd8:	2c4b883a 	add	r5,r5,r17
 8206bdc:	d9402f15 	stw	r5,188(sp)
 8206be0:	80800007 	ldb	r2,0(r16)
 8206be4:	1000a826 	beq	r2,zero,8206e88 <___vfprintf_internal_r+0x3f0>
 8206be8:	84400047 	ldb	r17,1(r16)
 8206bec:	00bfffc4 	movi	r2,-1
 8206bf0:	85400044 	addi	r21,r16,1
 8206bf4:	d8002785 	stb	zero,158(sp)
 8206bf8:	0007883a 	mov	r3,zero
 8206bfc:	000f883a 	mov	r7,zero
 8206c00:	d8802915 	stw	r2,164(sp)
 8206c04:	d8003115 	stw	zero,196(sp)
 8206c08:	0025883a 	mov	r18,zero
 8206c0c:	01401604 	movi	r5,88
 8206c10:	01800244 	movi	r6,9
 8206c14:	02800a84 	movi	r10,42
 8206c18:	02401b04 	movi	r9,108
 8206c1c:	ad400044 	addi	r21,r21,1
 8206c20:	88bff804 	addi	r2,r17,-32
 8206c24:	28830436 	bltu	r5,r2,8207838 <___vfprintf_internal_r+0xda0>
 8206c28:	100490ba 	slli	r2,r2,2
 8206c2c:	01020834 	movhi	r4,2080
 8206c30:	211b1004 	addi	r4,r4,27712
 8206c34:	1105883a 	add	r2,r2,r4
 8206c38:	10800017 	ldw	r2,0(r2)
 8206c3c:	1000683a 	jmp	r2
 8206c40:	08207758 	cmpnei	zero,at,-32291
 8206c44:	08207838 	rdprs	zero,at,-32288
 8206c48:	08207838 	rdprs	zero,at,-32288
 8206c4c:	08207778 	rdprs	zero,at,-32291
 8206c50:	08207838 	rdprs	zero,at,-32288
 8206c54:	08207838 	rdprs	zero,at,-32288
 8206c58:	08207838 	rdprs	zero,at,-32288
 8206c5c:	08207838 	rdprs	zero,at,-32288
 8206c60:	08207838 	rdprs	zero,at,-32288
 8206c64:	08207838 	rdprs	zero,at,-32288
 8206c68:	08206eec 	andhi	zero,at,33211
 8206c6c:	08207694 	ori	zero,at,33242
 8206c70:	08207838 	rdprs	zero,at,-32288
 8206c74:	08206db4 	orhi	zero,at,33206
 8206c78:	08206f14 	ori	zero,at,33212
 8206c7c:	08207838 	rdprs	zero,at,-32288
 8206c80:	08206f54 	ori	zero,at,33213
 8206c84:	08206f60 	cmpeqi	zero,at,-32323
 8206c88:	08206f60 	cmpeqi	zero,at,-32323
 8206c8c:	08206f60 	cmpeqi	zero,at,-32323
 8206c90:	08206f60 	cmpeqi	zero,at,-32323
 8206c94:	08206f60 	cmpeqi	zero,at,-32323
 8206c98:	08206f60 	cmpeqi	zero,at,-32323
 8206c9c:	08206f60 	cmpeqi	zero,at,-32323
 8206ca0:	08206f60 	cmpeqi	zero,at,-32323
 8206ca4:	08206f60 	cmpeqi	zero,at,-32323
 8206ca8:	08207838 	rdprs	zero,at,-32288
 8206cac:	08207838 	rdprs	zero,at,-32288
 8206cb0:	08207838 	rdprs	zero,at,-32288
 8206cb4:	08207838 	rdprs	zero,at,-32288
 8206cb8:	08207838 	rdprs	zero,at,-32288
 8206cbc:	08207838 	rdprs	zero,at,-32288
 8206cc0:	08207838 	rdprs	zero,at,-32288
 8206cc4:	08207838 	rdprs	zero,at,-32288
 8206cc8:	08207838 	rdprs	zero,at,-32288
 8206ccc:	08207838 	rdprs	zero,at,-32288
 8206cd0:	08206f94 	ori	zero,at,33214
 8206cd4:	08207050 	cmplti	zero,at,-32319
 8206cd8:	08207838 	rdprs	zero,at,-32288
 8206cdc:	08207050 	cmplti	zero,at,-32319
 8206ce0:	08207838 	rdprs	zero,at,-32288
 8206ce4:	08207838 	rdprs	zero,at,-32288
 8206ce8:	08207838 	rdprs	zero,at,-32288
 8206cec:	08207838 	rdprs	zero,at,-32288
 8206cf0:	082070f0 	cmpltui	zero,at,33219
 8206cf4:	08207838 	rdprs	zero,at,-32288
 8206cf8:	08207838 	rdprs	zero,at,-32288
 8206cfc:	082070fc 	xorhi	zero,at,33219
 8206d00:	08207838 	rdprs	zero,at,-32288
 8206d04:	08207838 	rdprs	zero,at,-32288
 8206d08:	08207838 	rdprs	zero,at,-32288
 8206d0c:	08207838 	rdprs	zero,at,-32288
 8206d10:	08207838 	rdprs	zero,at,-32288
 8206d14:	08207574 	orhi	zero,at,33237
 8206d18:	08207838 	rdprs	zero,at,-32288
 8206d1c:	08207838 	rdprs	zero,at,-32288
 8206d20:	082075d4 	ori	zero,at,33239
 8206d24:	08207838 	rdprs	zero,at,-32288
 8206d28:	08207838 	rdprs	zero,at,-32288
 8206d2c:	08207838 	rdprs	zero,at,-32288
 8206d30:	08207838 	rdprs	zero,at,-32288
 8206d34:	08207838 	rdprs	zero,at,-32288
 8206d38:	08207838 	rdprs	zero,at,-32288
 8206d3c:	08207838 	rdprs	zero,at,-32288
 8206d40:	08207838 	rdprs	zero,at,-32288
 8206d44:	08207838 	rdprs	zero,at,-32288
 8206d48:	08207838 	rdprs	zero,at,-32288
 8206d4c:	082077e4 	muli	zero,at,-32289
 8206d50:	08207784 	addi	zero,at,-32290
 8206d54:	08207050 	cmplti	zero,at,-32319
 8206d58:	08207050 	cmplti	zero,at,-32319
 8206d5c:	08207050 	cmplti	zero,at,-32319
 8206d60:	08207794 	ori	zero,at,33246
 8206d64:	08207784 	addi	zero,at,-32290
 8206d68:	08207838 	rdprs	zero,at,-32288
 8206d6c:	08207838 	rdprs	zero,at,-32288
 8206d70:	082077a0 	cmpeqi	zero,at,-32290
 8206d74:	08207838 	rdprs	zero,at,-32288
 8206d78:	082077b0 	cmpltui	zero,at,33246
 8206d7c:	08207684 	addi	zero,at,-32294
 8206d80:	08206dc0 	call	8206dc <OSCtxSw_SWITCH_PC+0x82069c>
 8206d84:	082076a4 	muli	zero,at,-32294
 8206d88:	08207838 	rdprs	zero,at,-32288
 8206d8c:	082076b0 	cmpltui	zero,at,33242
 8206d90:	08207838 	rdprs	zero,at,-32288
 8206d94:	0820770c 	andi	zero,at,33244
 8206d98:	08207838 	rdprs	zero,at,-32288
 8206d9c:	08207838 	rdprs	zero,at,-32288
 8206da0:	0820771c 	xori	zero,at,33244
 8206da4:	d9003117 	ldw	r4,196(sp)
 8206da8:	d8802d15 	stw	r2,180(sp)
 8206dac:	0109c83a 	sub	r4,zero,r4
 8206db0:	d9003115 	stw	r4,196(sp)
 8206db4:	94800114 	ori	r18,r18,4
 8206db8:	ac400007 	ldb	r17,0(r21)
 8206dbc:	003f9706 	br	8206c1c <___vfprintf_internal_r+0x184>
 8206dc0:	00800c04 	movi	r2,48
 8206dc4:	d9002d17 	ldw	r4,180(sp)
 8206dc8:	d9402917 	ldw	r5,164(sp)
 8206dcc:	d8802705 	stb	r2,156(sp)
 8206dd0:	00801e04 	movi	r2,120
 8206dd4:	d8802745 	stb	r2,157(sp)
 8206dd8:	d8002785 	stb	zero,158(sp)
 8206ddc:	20c00104 	addi	r3,r4,4
 8206de0:	24c00017 	ldw	r19,0(r4)
 8206de4:	002d883a 	mov	r22,zero
 8206de8:	90800094 	ori	r2,r18,2
 8206dec:	28029a16 	blt	r5,zero,8207858 <___vfprintf_internal_r+0xdc0>
 8206df0:	00bfdfc4 	movi	r2,-129
 8206df4:	90a4703a 	and	r18,r18,r2
 8206df8:	d8c02d15 	stw	r3,180(sp)
 8206dfc:	94800094 	ori	r18,r18,2
 8206e00:	9802871e 	bne	r19,zero,8207820 <___vfprintf_internal_r+0xd88>
 8206e04:	00820974 	movhi	r2,2085
 8206e08:	10b6e504 	addi	r2,r2,-9324
 8206e0c:	d8803915 	stw	r2,228(sp)
 8206e10:	04401e04 	movi	r17,120
 8206e14:	d8802917 	ldw	r2,164(sp)
 8206e18:	0039883a 	mov	fp,zero
 8206e1c:	1001e926 	beq	r2,zero,82075c4 <___vfprintf_internal_r+0xb2c>
 8206e20:	0027883a 	mov	r19,zero
 8206e24:	002d883a 	mov	r22,zero
 8206e28:	00020506 	br	8207640 <___vfprintf_internal_r+0xba8>
 8206e2c:	d9002c17 	ldw	r4,176(sp)
 8206e30:	b80b883a 	mov	r5,r23
 8206e34:	8208ec00 	call	8208ec0 <__swsetup_r>
 8206e38:	1005ac1e 	bne	r2,zero,82084ec <___vfprintf_internal_r+0x1a54>
 8206e3c:	b880030b 	ldhu	r2,12(r23)
 8206e40:	00c00284 	movi	r3,10
 8206e44:	1080068c 	andi	r2,r2,26
 8206e48:	10ff3c1e 	bne	r2,r3,8206b3c <___vfprintf_internal_r+0xa4>
 8206e4c:	b880038f 	ldh	r2,14(r23)
 8206e50:	103f3a16 	blt	r2,zero,8206b3c <___vfprintf_internal_r+0xa4>
 8206e54:	d9c02d17 	ldw	r7,180(sp)
 8206e58:	d9002c17 	ldw	r4,176(sp)
 8206e5c:	a80d883a 	mov	r6,r21
 8206e60:	b80b883a 	mov	r5,r23
 8206e64:	8208cac0 	call	8208cac <__sbprintf>
 8206e68:	00001106 	br	8206eb0 <___vfprintf_internal_r+0x418>
 8206e6c:	d9002c17 	ldw	r4,176(sp)
 8206e70:	d9801e04 	addi	r6,sp,120
 8206e74:	b80b883a 	mov	r5,r23
 8206e78:	820f5ec0 	call	820f5ec <__sprint_r>
 8206e7c:	1000081e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 8206e80:	da000404 	addi	r8,sp,16
 8206e84:	003f5306 	br	8206bd4 <___vfprintf_internal_r+0x13c>
 8206e88:	d8802017 	ldw	r2,128(sp)
 8206e8c:	10000426 	beq	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 8206e90:	d9002c17 	ldw	r4,176(sp)
 8206e94:	d9801e04 	addi	r6,sp,120
 8206e98:	b80b883a 	mov	r5,r23
 8206e9c:	820f5ec0 	call	820f5ec <__sprint_r>
 8206ea0:	b880030b 	ldhu	r2,12(r23)
 8206ea4:	1080100c 	andi	r2,r2,64
 8206ea8:	1005901e 	bne	r2,zero,82084ec <___vfprintf_internal_r+0x1a54>
 8206eac:	d8802f17 	ldw	r2,188(sp)
 8206eb0:	dfc04717 	ldw	ra,284(sp)
 8206eb4:	df004617 	ldw	fp,280(sp)
 8206eb8:	ddc04517 	ldw	r23,276(sp)
 8206ebc:	dd804417 	ldw	r22,272(sp)
 8206ec0:	dd404317 	ldw	r21,268(sp)
 8206ec4:	dd004217 	ldw	r20,264(sp)
 8206ec8:	dcc04117 	ldw	r19,260(sp)
 8206ecc:	dc804017 	ldw	r18,256(sp)
 8206ed0:	dc403f17 	ldw	r17,252(sp)
 8206ed4:	dc003e17 	ldw	r16,248(sp)
 8206ed8:	dec04804 	addi	sp,sp,288
 8206edc:	f800283a 	ret
 8206ee0:	d9002c17 	ldw	r4,176(sp)
 8206ee4:	820ae940 	call	820ae94 <__sinit>
 8206ee8:	003f0406 	br	8206afc <___vfprintf_internal_r+0x64>
 8206eec:	d8802d17 	ldw	r2,180(sp)
 8206ef0:	d9002d17 	ldw	r4,180(sp)
 8206ef4:	10800017 	ldw	r2,0(r2)
 8206ef8:	d8803115 	stw	r2,196(sp)
 8206efc:	20800104 	addi	r2,r4,4
 8206f00:	d9003117 	ldw	r4,196(sp)
 8206f04:	203fa716 	blt	r4,zero,8206da4 <___vfprintf_internal_r+0x30c>
 8206f08:	d8802d15 	stw	r2,180(sp)
 8206f0c:	ac400007 	ldb	r17,0(r21)
 8206f10:	003f4206 	br	8206c1c <___vfprintf_internal_r+0x184>
 8206f14:	ac400007 	ldb	r17,0(r21)
 8206f18:	aac00044 	addi	r11,r21,1
 8206f1c:	8a872826 	beq	r17,r10,8208bc0 <___vfprintf_internal_r+0x2128>
 8206f20:	88bff404 	addi	r2,r17,-48
 8206f24:	0009883a 	mov	r4,zero
 8206f28:	30867d36 	bltu	r6,r2,8208920 <___vfprintf_internal_r+0x1e88>
 8206f2c:	5c400007 	ldb	r17,0(r11)
 8206f30:	210002a4 	muli	r4,r4,10
 8206f34:	5d400044 	addi	r21,r11,1
 8206f38:	a817883a 	mov	r11,r21
 8206f3c:	2089883a 	add	r4,r4,r2
 8206f40:	88bff404 	addi	r2,r17,-48
 8206f44:	30bff92e 	bgeu	r6,r2,8206f2c <___vfprintf_internal_r+0x494>
 8206f48:	2005c916 	blt	r4,zero,8208670 <___vfprintf_internal_r+0x1bd8>
 8206f4c:	d9002915 	stw	r4,164(sp)
 8206f50:	003f3306 	br	8206c20 <___vfprintf_internal_r+0x188>
 8206f54:	94802014 	ori	r18,r18,128
 8206f58:	ac400007 	ldb	r17,0(r21)
 8206f5c:	003f2f06 	br	8206c1c <___vfprintf_internal_r+0x184>
 8206f60:	a809883a 	mov	r4,r21
 8206f64:	d8003115 	stw	zero,196(sp)
 8206f68:	88bff404 	addi	r2,r17,-48
 8206f6c:	0017883a 	mov	r11,zero
 8206f70:	24400007 	ldb	r17,0(r4)
 8206f74:	5ac002a4 	muli	r11,r11,10
 8206f78:	ad400044 	addi	r21,r21,1
 8206f7c:	a809883a 	mov	r4,r21
 8206f80:	12d7883a 	add	r11,r2,r11
 8206f84:	88bff404 	addi	r2,r17,-48
 8206f88:	30bff92e 	bgeu	r6,r2,8206f70 <___vfprintf_internal_r+0x4d8>
 8206f8c:	dac03115 	stw	r11,196(sp)
 8206f90:	003f2306 	br	8206c20 <___vfprintf_internal_r+0x188>
 8206f94:	18c03fcc 	andi	r3,r3,255
 8206f98:	18072b1e 	bne	r3,zero,8208c48 <___vfprintf_internal_r+0x21b0>
 8206f9c:	94800414 	ori	r18,r18,16
 8206fa0:	9080080c 	andi	r2,r18,32
 8206fa4:	10037b26 	beq	r2,zero,8207d94 <___vfprintf_internal_r+0x12fc>
 8206fa8:	d9402d17 	ldw	r5,180(sp)
 8206fac:	28800117 	ldw	r2,4(r5)
 8206fb0:	2cc00017 	ldw	r19,0(r5)
 8206fb4:	29400204 	addi	r5,r5,8
 8206fb8:	d9402d15 	stw	r5,180(sp)
 8206fbc:	102d883a 	mov	r22,r2
 8206fc0:	10044b16 	blt	r2,zero,82080f0 <___vfprintf_internal_r+0x1658>
 8206fc4:	d9402917 	ldw	r5,164(sp)
 8206fc8:	df002783 	ldbu	fp,158(sp)
 8206fcc:	2803bc16 	blt	r5,zero,8207ec0 <___vfprintf_internal_r+0x1428>
 8206fd0:	00ffdfc4 	movi	r3,-129
 8206fd4:	9d84b03a 	or	r2,r19,r22
 8206fd8:	90e4703a 	and	r18,r18,r3
 8206fdc:	10017726 	beq	r2,zero,82075bc <___vfprintf_internal_r+0xb24>
 8206fe0:	b0038326 	beq	r22,zero,8207df0 <___vfprintf_internal_r+0x1358>
 8206fe4:	dc402a15 	stw	r17,168(sp)
 8206fe8:	dc001e04 	addi	r16,sp,120
 8206fec:	b023883a 	mov	r17,r22
 8206ff0:	402d883a 	mov	r22,r8
 8206ff4:	9809883a 	mov	r4,r19
 8206ff8:	880b883a 	mov	r5,r17
 8206ffc:	01800284 	movi	r6,10
 8207000:	000f883a 	mov	r7,zero
 8207004:	821188c0 	call	821188c <__umoddi3>
 8207008:	10800c04 	addi	r2,r2,48
 820700c:	843fffc4 	addi	r16,r16,-1
 8207010:	9809883a 	mov	r4,r19
 8207014:	880b883a 	mov	r5,r17
 8207018:	80800005 	stb	r2,0(r16)
 820701c:	01800284 	movi	r6,10
 8207020:	000f883a 	mov	r7,zero
 8207024:	82113140 	call	8211314 <__udivdi3>
 8207028:	1027883a 	mov	r19,r2
 820702c:	10c4b03a 	or	r2,r2,r3
 8207030:	1823883a 	mov	r17,r3
 8207034:	103fef1e 	bne	r2,zero,8206ff4 <___vfprintf_internal_r+0x55c>
 8207038:	d8c02817 	ldw	r3,160(sp)
 820703c:	dc402a17 	ldw	r17,168(sp)
 8207040:	b011883a 	mov	r8,r22
 8207044:	1c07c83a 	sub	r3,r3,r16
 8207048:	d8c02e15 	stw	r3,184(sp)
 820704c:	00005906 	br	82071b4 <___vfprintf_internal_r+0x71c>
 8207050:	18c03fcc 	andi	r3,r3,255
 8207054:	1806fa1e 	bne	r3,zero,8208c40 <___vfprintf_internal_r+0x21a8>
 8207058:	9080020c 	andi	r2,r18,8
 820705c:	10048a26 	beq	r2,zero,8208288 <___vfprintf_internal_r+0x17f0>
 8207060:	d8c02d17 	ldw	r3,180(sp)
 8207064:	d9002d17 	ldw	r4,180(sp)
 8207068:	d9402d17 	ldw	r5,180(sp)
 820706c:	18c00017 	ldw	r3,0(r3)
 8207070:	21000117 	ldw	r4,4(r4)
 8207074:	29400204 	addi	r5,r5,8
 8207078:	d8c03615 	stw	r3,216(sp)
 820707c:	d9003815 	stw	r4,224(sp)
 8207080:	d9402d15 	stw	r5,180(sp)
 8207084:	d9003617 	ldw	r4,216(sp)
 8207088:	d9403817 	ldw	r5,224(sp)
 820708c:	da003d15 	stw	r8,244(sp)
 8207090:	04000044 	movi	r16,1
 8207094:	820de040 	call	820de04 <__fpclassifyd>
 8207098:	da003d17 	ldw	r8,244(sp)
 820709c:	14041f1e 	bne	r2,r16,820811c <___vfprintf_internal_r+0x1684>
 82070a0:	d9003617 	ldw	r4,216(sp)
 82070a4:	d9403817 	ldw	r5,224(sp)
 82070a8:	000d883a 	mov	r6,zero
 82070ac:	000f883a 	mov	r7,zero
 82070b0:	82130bc0 	call	82130bc <__ledf2>
 82070b4:	da003d17 	ldw	r8,244(sp)
 82070b8:	1005be16 	blt	r2,zero,82087b4 <___vfprintf_internal_r+0x1d1c>
 82070bc:	df002783 	ldbu	fp,158(sp)
 82070c0:	008011c4 	movi	r2,71
 82070c4:	1445330e 	bge	r2,r17,8208594 <___vfprintf_internal_r+0x1afc>
 82070c8:	04020974 	movhi	r16,2085
 82070cc:	8436dd04 	addi	r16,r16,-9356
 82070d0:	00c000c4 	movi	r3,3
 82070d4:	00bfdfc4 	movi	r2,-129
 82070d8:	d8c02a15 	stw	r3,168(sp)
 82070dc:	90a4703a 	and	r18,r18,r2
 82070e0:	d8c02e15 	stw	r3,184(sp)
 82070e4:	d8002915 	stw	zero,164(sp)
 82070e8:	d8003215 	stw	zero,200(sp)
 82070ec:	00003706 	br	82071cc <___vfprintf_internal_r+0x734>
 82070f0:	94800214 	ori	r18,r18,8
 82070f4:	ac400007 	ldb	r17,0(r21)
 82070f8:	003ec806 	br	8206c1c <___vfprintf_internal_r+0x184>
 82070fc:	18c03fcc 	andi	r3,r3,255
 8207100:	1806db1e 	bne	r3,zero,8208c70 <___vfprintf_internal_r+0x21d8>
 8207104:	94800414 	ori	r18,r18,16
 8207108:	9080080c 	andi	r2,r18,32
 820710c:	1002d826 	beq	r2,zero,8207c70 <___vfprintf_internal_r+0x11d8>
 8207110:	d9402d17 	ldw	r5,180(sp)
 8207114:	d8c02917 	ldw	r3,164(sp)
 8207118:	d8002785 	stb	zero,158(sp)
 820711c:	28800204 	addi	r2,r5,8
 8207120:	2cc00017 	ldw	r19,0(r5)
 8207124:	2d800117 	ldw	r22,4(r5)
 8207128:	18048f16 	blt	r3,zero,8208368 <___vfprintf_internal_r+0x18d0>
 820712c:	013fdfc4 	movi	r4,-129
 8207130:	9d86b03a 	or	r3,r19,r22
 8207134:	d8802d15 	stw	r2,180(sp)
 8207138:	9124703a 	and	r18,r18,r4
 820713c:	1802d91e 	bne	r3,zero,8207ca4 <___vfprintf_internal_r+0x120c>
 8207140:	d8c02917 	ldw	r3,164(sp)
 8207144:	0039883a 	mov	fp,zero
 8207148:	1805c326 	beq	r3,zero,8208858 <___vfprintf_internal_r+0x1dc0>
 820714c:	0027883a 	mov	r19,zero
 8207150:	002d883a 	mov	r22,zero
 8207154:	dc001e04 	addi	r16,sp,120
 8207158:	9806d0fa 	srli	r3,r19,3
 820715c:	b008977a 	slli	r4,r22,29
 8207160:	b02cd0fa 	srli	r22,r22,3
 8207164:	9cc001cc 	andi	r19,r19,7
 8207168:	98800c04 	addi	r2,r19,48
 820716c:	843fffc4 	addi	r16,r16,-1
 8207170:	20e6b03a 	or	r19,r4,r3
 8207174:	80800005 	stb	r2,0(r16)
 8207178:	9d86b03a 	or	r3,r19,r22
 820717c:	183ff61e 	bne	r3,zero,8207158 <___vfprintf_internal_r+0x6c0>
 8207180:	90c0004c 	andi	r3,r18,1
 8207184:	18013b26 	beq	r3,zero,8207674 <___vfprintf_internal_r+0xbdc>
 8207188:	10803fcc 	andi	r2,r2,255
 820718c:	1080201c 	xori	r2,r2,128
 8207190:	10bfe004 	addi	r2,r2,-128
 8207194:	00c00c04 	movi	r3,48
 8207198:	10c13626 	beq	r2,r3,8207674 <___vfprintf_internal_r+0xbdc>
 820719c:	80ffffc5 	stb	r3,-1(r16)
 82071a0:	d8c02817 	ldw	r3,160(sp)
 82071a4:	80bfffc4 	addi	r2,r16,-1
 82071a8:	1021883a 	mov	r16,r2
 82071ac:	1887c83a 	sub	r3,r3,r2
 82071b0:	d8c02e15 	stw	r3,184(sp)
 82071b4:	d8802e17 	ldw	r2,184(sp)
 82071b8:	d9002917 	ldw	r4,164(sp)
 82071bc:	1100010e 	bge	r2,r4,82071c4 <___vfprintf_internal_r+0x72c>
 82071c0:	2005883a 	mov	r2,r4
 82071c4:	d8802a15 	stw	r2,168(sp)
 82071c8:	d8003215 	stw	zero,200(sp)
 82071cc:	e7003fcc 	andi	fp,fp,255
 82071d0:	e700201c 	xori	fp,fp,128
 82071d4:	e73fe004 	addi	fp,fp,-128
 82071d8:	e0000326 	beq	fp,zero,82071e8 <___vfprintf_internal_r+0x750>
 82071dc:	d8c02a17 	ldw	r3,168(sp)
 82071e0:	18c00044 	addi	r3,r3,1
 82071e4:	d8c02a15 	stw	r3,168(sp)
 82071e8:	90c0008c 	andi	r3,r18,2
 82071ec:	d8c02b15 	stw	r3,172(sp)
 82071f0:	18000326 	beq	r3,zero,8207200 <___vfprintf_internal_r+0x768>
 82071f4:	d8c02a17 	ldw	r3,168(sp)
 82071f8:	18c00084 	addi	r3,r3,2
 82071fc:	d8c02a15 	stw	r3,168(sp)
 8207200:	90c0210c 	andi	r3,r18,132
 8207204:	d8c03015 	stw	r3,192(sp)
 8207208:	1801a31e 	bne	r3,zero,8207898 <___vfprintf_internal_r+0xe00>
 820720c:	d9003117 	ldw	r4,196(sp)
 8207210:	d8c02a17 	ldw	r3,168(sp)
 8207214:	20e7c83a 	sub	r19,r4,r3
 8207218:	04c19f0e 	bge	zero,r19,8207898 <___vfprintf_internal_r+0xe00>
 820721c:	02400404 	movi	r9,16
 8207220:	d8c02017 	ldw	r3,128(sp)
 8207224:	d8801f17 	ldw	r2,124(sp)
 8207228:	4cc50d0e 	bge	r9,r19,8208660 <___vfprintf_internal_r+0x1bc8>
 820722c:	01420974 	movhi	r5,2085
 8207230:	2976f884 	addi	r5,r5,-9246
 8207234:	dc403b15 	stw	r17,236(sp)
 8207238:	d9403515 	stw	r5,212(sp)
 820723c:	9823883a 	mov	r17,r19
 8207240:	482d883a 	mov	r22,r9
 8207244:	9027883a 	mov	r19,r18
 8207248:	070001c4 	movi	fp,7
 820724c:	8025883a 	mov	r18,r16
 8207250:	dc002c17 	ldw	r16,176(sp)
 8207254:	00000306 	br	8207264 <___vfprintf_internal_r+0x7cc>
 8207258:	8c7ffc04 	addi	r17,r17,-16
 820725c:	42000204 	addi	r8,r8,8
 8207260:	b440130e 	bge	r22,r17,82072b0 <___vfprintf_internal_r+0x818>
 8207264:	01020974 	movhi	r4,2085
 8207268:	18c00404 	addi	r3,r3,16
 820726c:	10800044 	addi	r2,r2,1
 8207270:	2136f884 	addi	r4,r4,-9246
 8207274:	41000015 	stw	r4,0(r8)
 8207278:	45800115 	stw	r22,4(r8)
 820727c:	d8c02015 	stw	r3,128(sp)
 8207280:	d8801f15 	stw	r2,124(sp)
 8207284:	e0bff40e 	bge	fp,r2,8207258 <___vfprintf_internal_r+0x7c0>
 8207288:	d9801e04 	addi	r6,sp,120
 820728c:	b80b883a 	mov	r5,r23
 8207290:	8009883a 	mov	r4,r16
 8207294:	820f5ec0 	call	820f5ec <__sprint_r>
 8207298:	103f011e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 820729c:	8c7ffc04 	addi	r17,r17,-16
 82072a0:	d8c02017 	ldw	r3,128(sp)
 82072a4:	d8801f17 	ldw	r2,124(sp)
 82072a8:	da000404 	addi	r8,sp,16
 82072ac:	b47fed16 	blt	r22,r17,8207264 <___vfprintf_internal_r+0x7cc>
 82072b0:	9021883a 	mov	r16,r18
 82072b4:	9825883a 	mov	r18,r19
 82072b8:	8827883a 	mov	r19,r17
 82072bc:	dc403b17 	ldw	r17,236(sp)
 82072c0:	d9403517 	ldw	r5,212(sp)
 82072c4:	98c7883a 	add	r3,r19,r3
 82072c8:	10800044 	addi	r2,r2,1
 82072cc:	41400015 	stw	r5,0(r8)
 82072d0:	44c00115 	stw	r19,4(r8)
 82072d4:	d8c02015 	stw	r3,128(sp)
 82072d8:	d8801f15 	stw	r2,124(sp)
 82072dc:	010001c4 	movi	r4,7
 82072e0:	2082a316 	blt	r4,r2,8207d70 <___vfprintf_internal_r+0x12d8>
 82072e4:	df002787 	ldb	fp,158(sp)
 82072e8:	42000204 	addi	r8,r8,8
 82072ec:	e0000c26 	beq	fp,zero,8207320 <___vfprintf_internal_r+0x888>
 82072f0:	d8801f17 	ldw	r2,124(sp)
 82072f4:	d9002784 	addi	r4,sp,158
 82072f8:	18c00044 	addi	r3,r3,1
 82072fc:	10800044 	addi	r2,r2,1
 8207300:	41000015 	stw	r4,0(r8)
 8207304:	01000044 	movi	r4,1
 8207308:	41000115 	stw	r4,4(r8)
 820730c:	d8c02015 	stw	r3,128(sp)
 8207310:	d8801f15 	stw	r2,124(sp)
 8207314:	010001c4 	movi	r4,7
 8207318:	20823c16 	blt	r4,r2,8207c0c <___vfprintf_internal_r+0x1174>
 820731c:	42000204 	addi	r8,r8,8
 8207320:	d8802b17 	ldw	r2,172(sp)
 8207324:	10000c26 	beq	r2,zero,8207358 <___vfprintf_internal_r+0x8c0>
 8207328:	d8801f17 	ldw	r2,124(sp)
 820732c:	d9002704 	addi	r4,sp,156
 8207330:	18c00084 	addi	r3,r3,2
 8207334:	10800044 	addi	r2,r2,1
 8207338:	41000015 	stw	r4,0(r8)
 820733c:	01000084 	movi	r4,2
 8207340:	41000115 	stw	r4,4(r8)
 8207344:	d8c02015 	stw	r3,128(sp)
 8207348:	d8801f15 	stw	r2,124(sp)
 820734c:	010001c4 	movi	r4,7
 8207350:	20823616 	blt	r4,r2,8207c2c <___vfprintf_internal_r+0x1194>
 8207354:	42000204 	addi	r8,r8,8
 8207358:	d9003017 	ldw	r4,192(sp)
 820735c:	00802004 	movi	r2,128
 8207360:	20819926 	beq	r4,r2,82079c8 <___vfprintf_internal_r+0xf30>
 8207364:	d9402917 	ldw	r5,164(sp)
 8207368:	d8802e17 	ldw	r2,184(sp)
 820736c:	28adc83a 	sub	r22,r5,r2
 8207370:	0580310e 	bge	zero,r22,8207438 <___vfprintf_internal_r+0x9a0>
 8207374:	07000404 	movi	fp,16
 8207378:	d8801f17 	ldw	r2,124(sp)
 820737c:	e584140e 	bge	fp,r22,82083d0 <___vfprintf_internal_r+0x1938>
 8207380:	01420974 	movhi	r5,2085
 8207384:	2976f484 	addi	r5,r5,-9262
 8207388:	dc402915 	stw	r17,164(sp)
 820738c:	d9402b15 	stw	r5,172(sp)
 8207390:	b023883a 	mov	r17,r22
 8207394:	04c001c4 	movi	r19,7
 8207398:	a82d883a 	mov	r22,r21
 820739c:	902b883a 	mov	r21,r18
 82073a0:	8025883a 	mov	r18,r16
 82073a4:	dc002c17 	ldw	r16,176(sp)
 82073a8:	00000306 	br	82073b8 <___vfprintf_internal_r+0x920>
 82073ac:	8c7ffc04 	addi	r17,r17,-16
 82073b0:	42000204 	addi	r8,r8,8
 82073b4:	e440110e 	bge	fp,r17,82073fc <___vfprintf_internal_r+0x964>
 82073b8:	18c00404 	addi	r3,r3,16
 82073bc:	10800044 	addi	r2,r2,1
 82073c0:	45000015 	stw	r20,0(r8)
 82073c4:	47000115 	stw	fp,4(r8)
 82073c8:	d8c02015 	stw	r3,128(sp)
 82073cc:	d8801f15 	stw	r2,124(sp)
 82073d0:	98bff60e 	bge	r19,r2,82073ac <___vfprintf_internal_r+0x914>
 82073d4:	d9801e04 	addi	r6,sp,120
 82073d8:	b80b883a 	mov	r5,r23
 82073dc:	8009883a 	mov	r4,r16
 82073e0:	820f5ec0 	call	820f5ec <__sprint_r>
 82073e4:	103eae1e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 82073e8:	8c7ffc04 	addi	r17,r17,-16
 82073ec:	d8c02017 	ldw	r3,128(sp)
 82073f0:	d8801f17 	ldw	r2,124(sp)
 82073f4:	da000404 	addi	r8,sp,16
 82073f8:	e47fef16 	blt	fp,r17,82073b8 <___vfprintf_internal_r+0x920>
 82073fc:	9021883a 	mov	r16,r18
 8207400:	a825883a 	mov	r18,r21
 8207404:	b02b883a 	mov	r21,r22
 8207408:	882d883a 	mov	r22,r17
 820740c:	dc402917 	ldw	r17,164(sp)
 8207410:	d9002b17 	ldw	r4,172(sp)
 8207414:	1d87883a 	add	r3,r3,r22
 8207418:	10800044 	addi	r2,r2,1
 820741c:	41000015 	stw	r4,0(r8)
 8207420:	45800115 	stw	r22,4(r8)
 8207424:	d8c02015 	stw	r3,128(sp)
 8207428:	d8801f15 	stw	r2,124(sp)
 820742c:	010001c4 	movi	r4,7
 8207430:	2081ee16 	blt	r4,r2,8207bec <___vfprintf_internal_r+0x1154>
 8207434:	42000204 	addi	r8,r8,8
 8207438:	9080400c 	andi	r2,r18,256
 820743c:	1001181e 	bne	r2,zero,82078a0 <___vfprintf_internal_r+0xe08>
 8207440:	d9402e17 	ldw	r5,184(sp)
 8207444:	d8801f17 	ldw	r2,124(sp)
 8207448:	44000015 	stw	r16,0(r8)
 820744c:	1947883a 	add	r3,r3,r5
 8207450:	10800044 	addi	r2,r2,1
 8207454:	41400115 	stw	r5,4(r8)
 8207458:	d8c02015 	stw	r3,128(sp)
 820745c:	d8801f15 	stw	r2,124(sp)
 8207460:	010001c4 	movi	r4,7
 8207464:	2081d316 	blt	r4,r2,8207bb4 <___vfprintf_internal_r+0x111c>
 8207468:	42000204 	addi	r8,r8,8
 820746c:	9480010c 	andi	r18,r18,4
 8207470:	90003226 	beq	r18,zero,820753c <___vfprintf_internal_r+0xaa4>
 8207474:	d9403117 	ldw	r5,196(sp)
 8207478:	d8802a17 	ldw	r2,168(sp)
 820747c:	28a1c83a 	sub	r16,r5,r2
 8207480:	04002e0e 	bge	zero,r16,820753c <___vfprintf_internal_r+0xaa4>
 8207484:	04400404 	movi	r17,16
 8207488:	d8801f17 	ldw	r2,124(sp)
 820748c:	8c04a20e 	bge	r17,r16,8208718 <___vfprintf_internal_r+0x1c80>
 8207490:	01420974 	movhi	r5,2085
 8207494:	2976f884 	addi	r5,r5,-9246
 8207498:	d9403515 	stw	r5,212(sp)
 820749c:	048001c4 	movi	r18,7
 82074a0:	dcc02c17 	ldw	r19,176(sp)
 82074a4:	00000306 	br	82074b4 <___vfprintf_internal_r+0xa1c>
 82074a8:	843ffc04 	addi	r16,r16,-16
 82074ac:	42000204 	addi	r8,r8,8
 82074b0:	8c00130e 	bge	r17,r16,8207500 <___vfprintf_internal_r+0xa68>
 82074b4:	01020974 	movhi	r4,2085
 82074b8:	18c00404 	addi	r3,r3,16
 82074bc:	10800044 	addi	r2,r2,1
 82074c0:	2136f884 	addi	r4,r4,-9246
 82074c4:	41000015 	stw	r4,0(r8)
 82074c8:	44400115 	stw	r17,4(r8)
 82074cc:	d8c02015 	stw	r3,128(sp)
 82074d0:	d8801f15 	stw	r2,124(sp)
 82074d4:	90bff40e 	bge	r18,r2,82074a8 <___vfprintf_internal_r+0xa10>
 82074d8:	d9801e04 	addi	r6,sp,120
 82074dc:	b80b883a 	mov	r5,r23
 82074e0:	9809883a 	mov	r4,r19
 82074e4:	820f5ec0 	call	820f5ec <__sprint_r>
 82074e8:	103e6d1e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 82074ec:	843ffc04 	addi	r16,r16,-16
 82074f0:	d8c02017 	ldw	r3,128(sp)
 82074f4:	d8801f17 	ldw	r2,124(sp)
 82074f8:	da000404 	addi	r8,sp,16
 82074fc:	8c3fed16 	blt	r17,r16,82074b4 <___vfprintf_internal_r+0xa1c>
 8207500:	d9403517 	ldw	r5,212(sp)
 8207504:	1c07883a 	add	r3,r3,r16
 8207508:	10800044 	addi	r2,r2,1
 820750c:	41400015 	stw	r5,0(r8)
 8207510:	44000115 	stw	r16,4(r8)
 8207514:	d8c02015 	stw	r3,128(sp)
 8207518:	d8801f15 	stw	r2,124(sp)
 820751c:	010001c4 	movi	r4,7
 8207520:	2080060e 	bge	r4,r2,820753c <___vfprintf_internal_r+0xaa4>
 8207524:	d9002c17 	ldw	r4,176(sp)
 8207528:	d9801e04 	addi	r6,sp,120
 820752c:	b80b883a 	mov	r5,r23
 8207530:	820f5ec0 	call	820f5ec <__sprint_r>
 8207534:	103e5a1e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 8207538:	d8c02017 	ldw	r3,128(sp)
 820753c:	d8803117 	ldw	r2,196(sp)
 8207540:	d9002a17 	ldw	r4,168(sp)
 8207544:	1100010e 	bge	r2,r4,820754c <___vfprintf_internal_r+0xab4>
 8207548:	2005883a 	mov	r2,r4
 820754c:	d9402f17 	ldw	r5,188(sp)
 8207550:	288b883a 	add	r5,r5,r2
 8207554:	d9402f15 	stw	r5,188(sp)
 8207558:	18019e1e 	bne	r3,zero,8207bd4 <___vfprintf_internal_r+0x113c>
 820755c:	a8800007 	ldb	r2,0(r21)
 8207560:	d8001f15 	stw	zero,124(sp)
 8207564:	da000404 	addi	r8,sp,16
 8207568:	103d851e 	bne	r2,zero,8206b80 <___vfprintf_internal_r+0xe8>
 820756c:	a821883a 	mov	r16,r21
 8207570:	003d9b06 	br	8206be0 <___vfprintf_internal_r+0x148>
 8207574:	18c03fcc 	andi	r3,r3,255
 8207578:	1805c11e 	bne	r3,zero,8208c80 <___vfprintf_internal_r+0x21e8>
 820757c:	94800414 	ori	r18,r18,16
 8207580:	9080080c 	andi	r2,r18,32
 8207584:	10020c26 	beq	r2,zero,8207db8 <___vfprintf_internal_r+0x1320>
 8207588:	d8802d17 	ldw	r2,180(sp)
 820758c:	d9002917 	ldw	r4,164(sp)
 8207590:	d8002785 	stb	zero,158(sp)
 8207594:	10c00204 	addi	r3,r2,8
 8207598:	14c00017 	ldw	r19,0(r2)
 820759c:	15800117 	ldw	r22,4(r2)
 82075a0:	20040f16 	blt	r4,zero,82085e0 <___vfprintf_internal_r+0x1b48>
 82075a4:	013fdfc4 	movi	r4,-129
 82075a8:	9d84b03a 	or	r2,r19,r22
 82075ac:	d8c02d15 	stw	r3,180(sp)
 82075b0:	9124703a 	and	r18,r18,r4
 82075b4:	0039883a 	mov	fp,zero
 82075b8:	103e891e 	bne	r2,zero,8206fe0 <___vfprintf_internal_r+0x548>
 82075bc:	d9002917 	ldw	r4,164(sp)
 82075c0:	2002c11e 	bne	r4,zero,82080c8 <___vfprintf_internal_r+0x1630>
 82075c4:	d8002915 	stw	zero,164(sp)
 82075c8:	d8002e15 	stw	zero,184(sp)
 82075cc:	dc001e04 	addi	r16,sp,120
 82075d0:	003ef806 	br	82071b4 <___vfprintf_internal_r+0x71c>
 82075d4:	18c03fcc 	andi	r3,r3,255
 82075d8:	18059d1e 	bne	r3,zero,8208c50 <___vfprintf_internal_r+0x21b8>
 82075dc:	01420974 	movhi	r5,2085
 82075e0:	2976e004 	addi	r5,r5,-9344
 82075e4:	d9403915 	stw	r5,228(sp)
 82075e8:	9080080c 	andi	r2,r18,32
 82075ec:	10005226 	beq	r2,zero,8207738 <___vfprintf_internal_r+0xca0>
 82075f0:	d8802d17 	ldw	r2,180(sp)
 82075f4:	14c00017 	ldw	r19,0(r2)
 82075f8:	15800117 	ldw	r22,4(r2)
 82075fc:	10800204 	addi	r2,r2,8
 8207600:	d8802d15 	stw	r2,180(sp)
 8207604:	9080004c 	andi	r2,r18,1
 8207608:	10019026 	beq	r2,zero,8207c4c <___vfprintf_internal_r+0x11b4>
 820760c:	9d84b03a 	or	r2,r19,r22
 8207610:	10036926 	beq	r2,zero,82083b8 <___vfprintf_internal_r+0x1920>
 8207614:	d8c02917 	ldw	r3,164(sp)
 8207618:	00800c04 	movi	r2,48
 820761c:	d8802705 	stb	r2,156(sp)
 8207620:	dc402745 	stb	r17,157(sp)
 8207624:	d8002785 	stb	zero,158(sp)
 8207628:	90800094 	ori	r2,r18,2
 820762c:	18045d16 	blt	r3,zero,82087a4 <___vfprintf_internal_r+0x1d0c>
 8207630:	00bfdfc4 	movi	r2,-129
 8207634:	90a4703a 	and	r18,r18,r2
 8207638:	94800094 	ori	r18,r18,2
 820763c:	0039883a 	mov	fp,zero
 8207640:	d9003917 	ldw	r4,228(sp)
 8207644:	dc001e04 	addi	r16,sp,120
 8207648:	988003cc 	andi	r2,r19,15
 820764c:	b006973a 	slli	r3,r22,28
 8207650:	2085883a 	add	r2,r4,r2
 8207654:	9826d13a 	srli	r19,r19,4
 8207658:	10800003 	ldbu	r2,0(r2)
 820765c:	b02cd13a 	srli	r22,r22,4
 8207660:	843fffc4 	addi	r16,r16,-1
 8207664:	1ce6b03a 	or	r19,r3,r19
 8207668:	80800005 	stb	r2,0(r16)
 820766c:	9d84b03a 	or	r2,r19,r22
 8207670:	103ff51e 	bne	r2,zero,8207648 <___vfprintf_internal_r+0xbb0>
 8207674:	d8c02817 	ldw	r3,160(sp)
 8207678:	1c07c83a 	sub	r3,r3,r16
 820767c:	d8c02e15 	stw	r3,184(sp)
 8207680:	003ecc06 	br	82071b4 <___vfprintf_internal_r+0x71c>
 8207684:	18c03fcc 	andi	r3,r3,255
 8207688:	183e9f26 	beq	r3,zero,8207108 <___vfprintf_internal_r+0x670>
 820768c:	d9c02785 	stb	r7,158(sp)
 8207690:	003e9d06 	br	8207108 <___vfprintf_internal_r+0x670>
 8207694:	00c00044 	movi	r3,1
 8207698:	01c00ac4 	movi	r7,43
 820769c:	ac400007 	ldb	r17,0(r21)
 82076a0:	003d5e06 	br	8206c1c <___vfprintf_internal_r+0x184>
 82076a4:	94800814 	ori	r18,r18,32
 82076a8:	ac400007 	ldb	r17,0(r21)
 82076ac:	003d5b06 	br	8206c1c <___vfprintf_internal_r+0x184>
 82076b0:	d8c02d17 	ldw	r3,180(sp)
 82076b4:	d8002785 	stb	zero,158(sp)
 82076b8:	1c000017 	ldw	r16,0(r3)
 82076bc:	1cc00104 	addi	r19,r3,4
 82076c0:	80041926 	beq	r16,zero,8208728 <___vfprintf_internal_r+0x1c90>
 82076c4:	d9002917 	ldw	r4,164(sp)
 82076c8:	2003d016 	blt	r4,zero,820860c <___vfprintf_internal_r+0x1b74>
 82076cc:	200d883a 	mov	r6,r4
 82076d0:	000b883a 	mov	r5,zero
 82076d4:	8009883a 	mov	r4,r16
 82076d8:	da003d15 	stw	r8,244(sp)
 82076dc:	820c5540 	call	820c554 <memchr>
 82076e0:	da003d17 	ldw	r8,244(sp)
 82076e4:	10045426 	beq	r2,zero,8208838 <___vfprintf_internal_r+0x1da0>
 82076e8:	1405c83a 	sub	r2,r2,r16
 82076ec:	d8802e15 	stw	r2,184(sp)
 82076f0:	1003cc16 	blt	r2,zero,8208624 <___vfprintf_internal_r+0x1b8c>
 82076f4:	df002783 	ldbu	fp,158(sp)
 82076f8:	d8802a15 	stw	r2,168(sp)
 82076fc:	dcc02d15 	stw	r19,180(sp)
 8207700:	d8002915 	stw	zero,164(sp)
 8207704:	d8003215 	stw	zero,200(sp)
 8207708:	003eb006 	br	82071cc <___vfprintf_internal_r+0x734>
 820770c:	18c03fcc 	andi	r3,r3,255
 8207710:	183f9b26 	beq	r3,zero,8207580 <___vfprintf_internal_r+0xae8>
 8207714:	d9c02785 	stb	r7,158(sp)
 8207718:	003f9906 	br	8207580 <___vfprintf_internal_r+0xae8>
 820771c:	18c03fcc 	andi	r3,r3,255
 8207720:	1805551e 	bne	r3,zero,8208c78 <___vfprintf_internal_r+0x21e0>
 8207724:	01420974 	movhi	r5,2085
 8207728:	2976e504 	addi	r5,r5,-9324
 820772c:	d9403915 	stw	r5,228(sp)
 8207730:	9080080c 	andi	r2,r18,32
 8207734:	103fae1e 	bne	r2,zero,82075f0 <___vfprintf_internal_r+0xb58>
 8207738:	9080040c 	andi	r2,r18,16
 820773c:	1002de26 	beq	r2,zero,82082b8 <___vfprintf_internal_r+0x1820>
 8207740:	d8c02d17 	ldw	r3,180(sp)
 8207744:	002d883a 	mov	r22,zero
 8207748:	1cc00017 	ldw	r19,0(r3)
 820774c:	18c00104 	addi	r3,r3,4
 8207750:	d8c02d15 	stw	r3,180(sp)
 8207754:	003fab06 	br	8207604 <___vfprintf_internal_r+0xb6c>
 8207758:	38803fcc 	andi	r2,r7,255
 820775c:	1080201c 	xori	r2,r2,128
 8207760:	10bfe004 	addi	r2,r2,-128
 8207764:	1002d21e 	bne	r2,zero,82082b0 <___vfprintf_internal_r+0x1818>
 8207768:	00c00044 	movi	r3,1
 820776c:	01c00804 	movi	r7,32
 8207770:	ac400007 	ldb	r17,0(r21)
 8207774:	003d2906 	br	8206c1c <___vfprintf_internal_r+0x184>
 8207778:	94800054 	ori	r18,r18,1
 820777c:	ac400007 	ldb	r17,0(r21)
 8207780:	003d2606 	br	8206c1c <___vfprintf_internal_r+0x184>
 8207784:	18c03fcc 	andi	r3,r3,255
 8207788:	183e0526 	beq	r3,zero,8206fa0 <___vfprintf_internal_r+0x508>
 820778c:	d9c02785 	stb	r7,158(sp)
 8207790:	003e0306 	br	8206fa0 <___vfprintf_internal_r+0x508>
 8207794:	94801014 	ori	r18,r18,64
 8207798:	ac400007 	ldb	r17,0(r21)
 820779c:	003d1f06 	br	8206c1c <___vfprintf_internal_r+0x184>
 82077a0:	ac400007 	ldb	r17,0(r21)
 82077a4:	8a438726 	beq	r17,r9,82085c4 <___vfprintf_internal_r+0x1b2c>
 82077a8:	94800414 	ori	r18,r18,16
 82077ac:	003d1b06 	br	8206c1c <___vfprintf_internal_r+0x184>
 82077b0:	18c03fcc 	andi	r3,r3,255
 82077b4:	1805341e 	bne	r3,zero,8208c88 <___vfprintf_internal_r+0x21f0>
 82077b8:	9080080c 	andi	r2,r18,32
 82077bc:	1002cd26 	beq	r2,zero,82082f4 <___vfprintf_internal_r+0x185c>
 82077c0:	d9402d17 	ldw	r5,180(sp)
 82077c4:	d9002f17 	ldw	r4,188(sp)
 82077c8:	28800017 	ldw	r2,0(r5)
 82077cc:	2007d7fa 	srai	r3,r4,31
 82077d0:	29400104 	addi	r5,r5,4
 82077d4:	d9402d15 	stw	r5,180(sp)
 82077d8:	11000015 	stw	r4,0(r2)
 82077dc:	10c00115 	stw	r3,4(r2)
 82077e0:	003ce506 	br	8206b78 <___vfprintf_internal_r+0xe0>
 82077e4:	d8c02d17 	ldw	r3,180(sp)
 82077e8:	d9002d17 	ldw	r4,180(sp)
 82077ec:	d8002785 	stb	zero,158(sp)
 82077f0:	18800017 	ldw	r2,0(r3)
 82077f4:	21000104 	addi	r4,r4,4
 82077f8:	00c00044 	movi	r3,1
 82077fc:	d8c02a15 	stw	r3,168(sp)
 8207800:	d8801405 	stb	r2,80(sp)
 8207804:	d9002d15 	stw	r4,180(sp)
 8207808:	d8c02e15 	stw	r3,184(sp)
 820780c:	d8002915 	stw	zero,164(sp)
 8207810:	d8003215 	stw	zero,200(sp)
 8207814:	dc001404 	addi	r16,sp,80
 8207818:	0039883a 	mov	fp,zero
 820781c:	003e7206 	br	82071e8 <___vfprintf_internal_r+0x750>
 8207820:	01020974 	movhi	r4,2085
 8207824:	2136e504 	addi	r4,r4,-9324
 8207828:	0039883a 	mov	fp,zero
 820782c:	d9003915 	stw	r4,228(sp)
 8207830:	04401e04 	movi	r17,120
 8207834:	003f8206 	br	8207640 <___vfprintf_internal_r+0xba8>
 8207838:	18c03fcc 	andi	r3,r3,255
 820783c:	1805061e 	bne	r3,zero,8208c58 <___vfprintf_internal_r+0x21c0>
 8207840:	883d9126 	beq	r17,zero,8206e88 <___vfprintf_internal_r+0x3f0>
 8207844:	00c00044 	movi	r3,1
 8207848:	d8c02a15 	stw	r3,168(sp)
 820784c:	dc401405 	stb	r17,80(sp)
 8207850:	d8002785 	stb	zero,158(sp)
 8207854:	003fec06 	br	8207808 <___vfprintf_internal_r+0xd70>
 8207858:	01420974 	movhi	r5,2085
 820785c:	2976e504 	addi	r5,r5,-9324
 8207860:	d9403915 	stw	r5,228(sp)
 8207864:	d8c02d15 	stw	r3,180(sp)
 8207868:	1025883a 	mov	r18,r2
 820786c:	04401e04 	movi	r17,120
 8207870:	9d84b03a 	or	r2,r19,r22
 8207874:	1000fc1e 	bne	r2,zero,8207c68 <___vfprintf_internal_r+0x11d0>
 8207878:	0039883a 	mov	fp,zero
 820787c:	00800084 	movi	r2,2
 8207880:	10803fcc 	andi	r2,r2,255
 8207884:	00c00044 	movi	r3,1
 8207888:	10c20f26 	beq	r2,r3,82080c8 <___vfprintf_internal_r+0x1630>
 820788c:	00c00084 	movi	r3,2
 8207890:	10fd6326 	beq	r2,r3,8206e20 <___vfprintf_internal_r+0x388>
 8207894:	003e2d06 	br	820714c <___vfprintf_internal_r+0x6b4>
 8207898:	d8c02017 	ldw	r3,128(sp)
 820789c:	003e9306 	br	82072ec <___vfprintf_internal_r+0x854>
 82078a0:	00801944 	movi	r2,101
 82078a4:	14407e0e 	bge	r2,r17,8207aa0 <___vfprintf_internal_r+0x1008>
 82078a8:	d9003617 	ldw	r4,216(sp)
 82078ac:	d9403817 	ldw	r5,224(sp)
 82078b0:	000d883a 	mov	r6,zero
 82078b4:	000f883a 	mov	r7,zero
 82078b8:	d8c03c15 	stw	r3,240(sp)
 82078bc:	da003d15 	stw	r8,244(sp)
 82078c0:	8212f580 	call	8212f58 <__eqdf2>
 82078c4:	d8c03c17 	ldw	r3,240(sp)
 82078c8:	da003d17 	ldw	r8,244(sp)
 82078cc:	1000f71e 	bne	r2,zero,8207cac <___vfprintf_internal_r+0x1214>
 82078d0:	d8801f17 	ldw	r2,124(sp)
 82078d4:	01020974 	movhi	r4,2085
 82078d8:	2136ec04 	addi	r4,r4,-9296
 82078dc:	18c00044 	addi	r3,r3,1
 82078e0:	10800044 	addi	r2,r2,1
 82078e4:	41000015 	stw	r4,0(r8)
 82078e8:	01000044 	movi	r4,1
 82078ec:	41000115 	stw	r4,4(r8)
 82078f0:	d8c02015 	stw	r3,128(sp)
 82078f4:	d8801f15 	stw	r2,124(sp)
 82078f8:	010001c4 	movi	r4,7
 82078fc:	2082b816 	blt	r4,r2,82083e0 <___vfprintf_internal_r+0x1948>
 8207900:	42000204 	addi	r8,r8,8
 8207904:	d8802617 	ldw	r2,152(sp)
 8207908:	d9403317 	ldw	r5,204(sp)
 820790c:	11400216 	blt	r2,r5,8207918 <___vfprintf_internal_r+0xe80>
 8207910:	9080004c 	andi	r2,r18,1
 8207914:	103ed526 	beq	r2,zero,820746c <___vfprintf_internal_r+0x9d4>
 8207918:	d8803717 	ldw	r2,220(sp)
 820791c:	d9003417 	ldw	r4,208(sp)
 8207920:	d9403717 	ldw	r5,220(sp)
 8207924:	1887883a 	add	r3,r3,r2
 8207928:	d8801f17 	ldw	r2,124(sp)
 820792c:	41000015 	stw	r4,0(r8)
 8207930:	41400115 	stw	r5,4(r8)
 8207934:	10800044 	addi	r2,r2,1
 8207938:	d8c02015 	stw	r3,128(sp)
 820793c:	d8801f15 	stw	r2,124(sp)
 8207940:	010001c4 	movi	r4,7
 8207944:	20832916 	blt	r4,r2,82085ec <___vfprintf_internal_r+0x1b54>
 8207948:	42000204 	addi	r8,r8,8
 820794c:	d8803317 	ldw	r2,204(sp)
 8207950:	143fffc4 	addi	r16,r2,-1
 8207954:	043ec50e 	bge	zero,r16,820746c <___vfprintf_internal_r+0x9d4>
 8207958:	04400404 	movi	r17,16
 820795c:	d8801f17 	ldw	r2,124(sp)
 8207960:	8c00880e 	bge	r17,r16,8207b84 <___vfprintf_internal_r+0x10ec>
 8207964:	01420974 	movhi	r5,2085
 8207968:	2976f484 	addi	r5,r5,-9262
 820796c:	d9402b15 	stw	r5,172(sp)
 8207970:	058001c4 	movi	r22,7
 8207974:	dcc02c17 	ldw	r19,176(sp)
 8207978:	00000306 	br	8207988 <___vfprintf_internal_r+0xef0>
 820797c:	42000204 	addi	r8,r8,8
 8207980:	843ffc04 	addi	r16,r16,-16
 8207984:	8c00820e 	bge	r17,r16,8207b90 <___vfprintf_internal_r+0x10f8>
 8207988:	18c00404 	addi	r3,r3,16
 820798c:	10800044 	addi	r2,r2,1
 8207990:	45000015 	stw	r20,0(r8)
 8207994:	44400115 	stw	r17,4(r8)
 8207998:	d8c02015 	stw	r3,128(sp)
 820799c:	d8801f15 	stw	r2,124(sp)
 82079a0:	b0bff60e 	bge	r22,r2,820797c <___vfprintf_internal_r+0xee4>
 82079a4:	d9801e04 	addi	r6,sp,120
 82079a8:	b80b883a 	mov	r5,r23
 82079ac:	9809883a 	mov	r4,r19
 82079b0:	820f5ec0 	call	820f5ec <__sprint_r>
 82079b4:	103d3a1e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 82079b8:	d8c02017 	ldw	r3,128(sp)
 82079bc:	d8801f17 	ldw	r2,124(sp)
 82079c0:	da000404 	addi	r8,sp,16
 82079c4:	003fee06 	br	8207980 <___vfprintf_internal_r+0xee8>
 82079c8:	d9403117 	ldw	r5,196(sp)
 82079cc:	d8802a17 	ldw	r2,168(sp)
 82079d0:	28adc83a 	sub	r22,r5,r2
 82079d4:	05be630e 	bge	zero,r22,8207364 <___vfprintf_internal_r+0x8cc>
 82079d8:	07000404 	movi	fp,16
 82079dc:	d8801f17 	ldw	r2,124(sp)
 82079e0:	e5838f0e 	bge	fp,r22,8208820 <___vfprintf_internal_r+0x1d88>
 82079e4:	01420974 	movhi	r5,2085
 82079e8:	2976f484 	addi	r5,r5,-9262
 82079ec:	dc403015 	stw	r17,192(sp)
 82079f0:	d9402b15 	stw	r5,172(sp)
 82079f4:	b023883a 	mov	r17,r22
 82079f8:	04c001c4 	movi	r19,7
 82079fc:	a82d883a 	mov	r22,r21
 8207a00:	902b883a 	mov	r21,r18
 8207a04:	8025883a 	mov	r18,r16
 8207a08:	dc002c17 	ldw	r16,176(sp)
 8207a0c:	00000306 	br	8207a1c <___vfprintf_internal_r+0xf84>
 8207a10:	8c7ffc04 	addi	r17,r17,-16
 8207a14:	42000204 	addi	r8,r8,8
 8207a18:	e440110e 	bge	fp,r17,8207a60 <___vfprintf_internal_r+0xfc8>
 8207a1c:	18c00404 	addi	r3,r3,16
 8207a20:	10800044 	addi	r2,r2,1
 8207a24:	45000015 	stw	r20,0(r8)
 8207a28:	47000115 	stw	fp,4(r8)
 8207a2c:	d8c02015 	stw	r3,128(sp)
 8207a30:	d8801f15 	stw	r2,124(sp)
 8207a34:	98bff60e 	bge	r19,r2,8207a10 <___vfprintf_internal_r+0xf78>
 8207a38:	d9801e04 	addi	r6,sp,120
 8207a3c:	b80b883a 	mov	r5,r23
 8207a40:	8009883a 	mov	r4,r16
 8207a44:	820f5ec0 	call	820f5ec <__sprint_r>
 8207a48:	103d151e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 8207a4c:	8c7ffc04 	addi	r17,r17,-16
 8207a50:	d8c02017 	ldw	r3,128(sp)
 8207a54:	d8801f17 	ldw	r2,124(sp)
 8207a58:	da000404 	addi	r8,sp,16
 8207a5c:	e47fef16 	blt	fp,r17,8207a1c <___vfprintf_internal_r+0xf84>
 8207a60:	9021883a 	mov	r16,r18
 8207a64:	a825883a 	mov	r18,r21
 8207a68:	b02b883a 	mov	r21,r22
 8207a6c:	882d883a 	mov	r22,r17
 8207a70:	dc403017 	ldw	r17,192(sp)
 8207a74:	d9002b17 	ldw	r4,172(sp)
 8207a78:	1d87883a 	add	r3,r3,r22
 8207a7c:	10800044 	addi	r2,r2,1
 8207a80:	41000015 	stw	r4,0(r8)
 8207a84:	45800115 	stw	r22,4(r8)
 8207a88:	d8c02015 	stw	r3,128(sp)
 8207a8c:	d8801f15 	stw	r2,124(sp)
 8207a90:	010001c4 	movi	r4,7
 8207a94:	20818e16 	blt	r4,r2,82080d0 <___vfprintf_internal_r+0x1638>
 8207a98:	42000204 	addi	r8,r8,8
 8207a9c:	003e3106 	br	8207364 <___vfprintf_internal_r+0x8cc>
 8207aa0:	d9403317 	ldw	r5,204(sp)
 8207aa4:	00800044 	movi	r2,1
 8207aa8:	18c00044 	addi	r3,r3,1
 8207aac:	1141530e 	bge	r2,r5,8207ffc <___vfprintf_internal_r+0x1564>
 8207ab0:	dc401f17 	ldw	r17,124(sp)
 8207ab4:	00800044 	movi	r2,1
 8207ab8:	40800115 	stw	r2,4(r8)
 8207abc:	8c400044 	addi	r17,r17,1
 8207ac0:	44000015 	stw	r16,0(r8)
 8207ac4:	d8c02015 	stw	r3,128(sp)
 8207ac8:	dc401f15 	stw	r17,124(sp)
 8207acc:	008001c4 	movi	r2,7
 8207ad0:	14416b16 	blt	r2,r17,8208080 <___vfprintf_internal_r+0x15e8>
 8207ad4:	42000204 	addi	r8,r8,8
 8207ad8:	d8803717 	ldw	r2,220(sp)
 8207adc:	d9003417 	ldw	r4,208(sp)
 8207ae0:	8c400044 	addi	r17,r17,1
 8207ae4:	10c7883a 	add	r3,r2,r3
 8207ae8:	40800115 	stw	r2,4(r8)
 8207aec:	41000015 	stw	r4,0(r8)
 8207af0:	d8c02015 	stw	r3,128(sp)
 8207af4:	dc401f15 	stw	r17,124(sp)
 8207af8:	008001c4 	movi	r2,7
 8207afc:	14416916 	blt	r2,r17,82080a4 <___vfprintf_internal_r+0x160c>
 8207b00:	45800204 	addi	r22,r8,8
 8207b04:	d9003617 	ldw	r4,216(sp)
 8207b08:	d9403817 	ldw	r5,224(sp)
 8207b0c:	000d883a 	mov	r6,zero
 8207b10:	000f883a 	mov	r7,zero
 8207b14:	d8c03c15 	stw	r3,240(sp)
 8207b18:	8212f580 	call	8212f58 <__eqdf2>
 8207b1c:	d8c03c17 	ldw	r3,240(sp)
 8207b20:	1000bc26 	beq	r2,zero,8207e14 <___vfprintf_internal_r+0x137c>
 8207b24:	d9403317 	ldw	r5,204(sp)
 8207b28:	84000044 	addi	r16,r16,1
 8207b2c:	8c400044 	addi	r17,r17,1
 8207b30:	28bfffc4 	addi	r2,r5,-1
 8207b34:	1887883a 	add	r3,r3,r2
 8207b38:	b0800115 	stw	r2,4(r22)
 8207b3c:	b4000015 	stw	r16,0(r22)
 8207b40:	d8c02015 	stw	r3,128(sp)
 8207b44:	dc401f15 	stw	r17,124(sp)
 8207b48:	008001c4 	movi	r2,7
 8207b4c:	14414316 	blt	r2,r17,820805c <___vfprintf_internal_r+0x15c4>
 8207b50:	b5800204 	addi	r22,r22,8
 8207b54:	d9003a17 	ldw	r4,232(sp)
 8207b58:	df0022c4 	addi	fp,sp,139
 8207b5c:	8c400044 	addi	r17,r17,1
 8207b60:	20c7883a 	add	r3,r4,r3
 8207b64:	b7000015 	stw	fp,0(r22)
 8207b68:	b1000115 	stw	r4,4(r22)
 8207b6c:	d8c02015 	stw	r3,128(sp)
 8207b70:	dc401f15 	stw	r17,124(sp)
 8207b74:	008001c4 	movi	r2,7
 8207b78:	14400e16 	blt	r2,r17,8207bb4 <___vfprintf_internal_r+0x111c>
 8207b7c:	b2000204 	addi	r8,r22,8
 8207b80:	003e3a06 	br	820746c <___vfprintf_internal_r+0x9d4>
 8207b84:	01020974 	movhi	r4,2085
 8207b88:	2136f484 	addi	r4,r4,-9262
 8207b8c:	d9002b15 	stw	r4,172(sp)
 8207b90:	d9002b17 	ldw	r4,172(sp)
 8207b94:	1c07883a 	add	r3,r3,r16
 8207b98:	44000115 	stw	r16,4(r8)
 8207b9c:	41000015 	stw	r4,0(r8)
 8207ba0:	10800044 	addi	r2,r2,1
 8207ba4:	d8c02015 	stw	r3,128(sp)
 8207ba8:	d8801f15 	stw	r2,124(sp)
 8207bac:	010001c4 	movi	r4,7
 8207bb0:	20be2d0e 	bge	r4,r2,8207468 <___vfprintf_internal_r+0x9d0>
 8207bb4:	d9002c17 	ldw	r4,176(sp)
 8207bb8:	d9801e04 	addi	r6,sp,120
 8207bbc:	b80b883a 	mov	r5,r23
 8207bc0:	820f5ec0 	call	820f5ec <__sprint_r>
 8207bc4:	103cb61e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 8207bc8:	d8c02017 	ldw	r3,128(sp)
 8207bcc:	da000404 	addi	r8,sp,16
 8207bd0:	003e2606 	br	820746c <___vfprintf_internal_r+0x9d4>
 8207bd4:	d9002c17 	ldw	r4,176(sp)
 8207bd8:	d9801e04 	addi	r6,sp,120
 8207bdc:	b80b883a 	mov	r5,r23
 8207be0:	820f5ec0 	call	820f5ec <__sprint_r>
 8207be4:	103e5d26 	beq	r2,zero,820755c <___vfprintf_internal_r+0xac4>
 8207be8:	003cad06 	br	8206ea0 <___vfprintf_internal_r+0x408>
 8207bec:	d9002c17 	ldw	r4,176(sp)
 8207bf0:	d9801e04 	addi	r6,sp,120
 8207bf4:	b80b883a 	mov	r5,r23
 8207bf8:	820f5ec0 	call	820f5ec <__sprint_r>
 8207bfc:	103ca81e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 8207c00:	d8c02017 	ldw	r3,128(sp)
 8207c04:	da000404 	addi	r8,sp,16
 8207c08:	003e0b06 	br	8207438 <___vfprintf_internal_r+0x9a0>
 8207c0c:	d9002c17 	ldw	r4,176(sp)
 8207c10:	d9801e04 	addi	r6,sp,120
 8207c14:	b80b883a 	mov	r5,r23
 8207c18:	820f5ec0 	call	820f5ec <__sprint_r>
 8207c1c:	103ca01e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 8207c20:	d8c02017 	ldw	r3,128(sp)
 8207c24:	da000404 	addi	r8,sp,16
 8207c28:	003dbd06 	br	8207320 <___vfprintf_internal_r+0x888>
 8207c2c:	d9002c17 	ldw	r4,176(sp)
 8207c30:	d9801e04 	addi	r6,sp,120
 8207c34:	b80b883a 	mov	r5,r23
 8207c38:	820f5ec0 	call	820f5ec <__sprint_r>
 8207c3c:	103c981e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 8207c40:	d8c02017 	ldw	r3,128(sp)
 8207c44:	da000404 	addi	r8,sp,16
 8207c48:	003dc306 	br	8207358 <___vfprintf_internal_r+0x8c0>
 8207c4c:	d8802917 	ldw	r2,164(sp)
 8207c50:	d8002785 	stb	zero,158(sp)
 8207c54:	103f0616 	blt	r2,zero,8207870 <___vfprintf_internal_r+0xdd8>
 8207c58:	00ffdfc4 	movi	r3,-129
 8207c5c:	9d84b03a 	or	r2,r19,r22
 8207c60:	90e4703a 	and	r18,r18,r3
 8207c64:	103c6b26 	beq	r2,zero,8206e14 <___vfprintf_internal_r+0x37c>
 8207c68:	0039883a 	mov	fp,zero
 8207c6c:	003e7406 	br	8207640 <___vfprintf_internal_r+0xba8>
 8207c70:	9080040c 	andi	r2,r18,16
 8207c74:	1001b326 	beq	r2,zero,8208344 <___vfprintf_internal_r+0x18ac>
 8207c78:	d9002d17 	ldw	r4,180(sp)
 8207c7c:	d9402917 	ldw	r5,164(sp)
 8207c80:	d8002785 	stb	zero,158(sp)
 8207c84:	20800104 	addi	r2,r4,4
 8207c88:	24c00017 	ldw	r19,0(r4)
 8207c8c:	002d883a 	mov	r22,zero
 8207c90:	2801b516 	blt	r5,zero,8208368 <___vfprintf_internal_r+0x18d0>
 8207c94:	00ffdfc4 	movi	r3,-129
 8207c98:	d8802d15 	stw	r2,180(sp)
 8207c9c:	90e4703a 	and	r18,r18,r3
 8207ca0:	983d2726 	beq	r19,zero,8207140 <___vfprintf_internal_r+0x6a8>
 8207ca4:	0039883a 	mov	fp,zero
 8207ca8:	003d2a06 	br	8207154 <___vfprintf_internal_r+0x6bc>
 8207cac:	dc402617 	ldw	r17,152(sp)
 8207cb0:	0441d30e 	bge	zero,r17,8208400 <___vfprintf_internal_r+0x1968>
 8207cb4:	dc403217 	ldw	r17,200(sp)
 8207cb8:	d8803317 	ldw	r2,204(sp)
 8207cbc:	1440010e 	bge	r2,r17,8207cc4 <___vfprintf_internal_r+0x122c>
 8207cc0:	1023883a 	mov	r17,r2
 8207cc4:	04400a0e 	bge	zero,r17,8207cf0 <___vfprintf_internal_r+0x1258>
 8207cc8:	d8801f17 	ldw	r2,124(sp)
 8207ccc:	1c47883a 	add	r3,r3,r17
 8207cd0:	44000015 	stw	r16,0(r8)
 8207cd4:	10800044 	addi	r2,r2,1
 8207cd8:	44400115 	stw	r17,4(r8)
 8207cdc:	d8c02015 	stw	r3,128(sp)
 8207ce0:	d8801f15 	stw	r2,124(sp)
 8207ce4:	010001c4 	movi	r4,7
 8207ce8:	20826516 	blt	r4,r2,8208680 <___vfprintf_internal_r+0x1be8>
 8207cec:	42000204 	addi	r8,r8,8
 8207cf0:	88026116 	blt	r17,zero,8208678 <___vfprintf_internal_r+0x1be0>
 8207cf4:	d9003217 	ldw	r4,200(sp)
 8207cf8:	2463c83a 	sub	r17,r4,r17
 8207cfc:	04407b0e 	bge	zero,r17,8207eec <___vfprintf_internal_r+0x1454>
 8207d00:	05800404 	movi	r22,16
 8207d04:	d8801f17 	ldw	r2,124(sp)
 8207d08:	b4419d0e 	bge	r22,r17,8208380 <___vfprintf_internal_r+0x18e8>
 8207d0c:	01020974 	movhi	r4,2085
 8207d10:	2136f484 	addi	r4,r4,-9262
 8207d14:	d9002b15 	stw	r4,172(sp)
 8207d18:	070001c4 	movi	fp,7
 8207d1c:	dcc02c17 	ldw	r19,176(sp)
 8207d20:	00000306 	br	8207d30 <___vfprintf_internal_r+0x1298>
 8207d24:	42000204 	addi	r8,r8,8
 8207d28:	8c7ffc04 	addi	r17,r17,-16
 8207d2c:	b441970e 	bge	r22,r17,820838c <___vfprintf_internal_r+0x18f4>
 8207d30:	18c00404 	addi	r3,r3,16
 8207d34:	10800044 	addi	r2,r2,1
 8207d38:	45000015 	stw	r20,0(r8)
 8207d3c:	45800115 	stw	r22,4(r8)
 8207d40:	d8c02015 	stw	r3,128(sp)
 8207d44:	d8801f15 	stw	r2,124(sp)
 8207d48:	e0bff60e 	bge	fp,r2,8207d24 <___vfprintf_internal_r+0x128c>
 8207d4c:	d9801e04 	addi	r6,sp,120
 8207d50:	b80b883a 	mov	r5,r23
 8207d54:	9809883a 	mov	r4,r19
 8207d58:	820f5ec0 	call	820f5ec <__sprint_r>
 8207d5c:	103c501e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 8207d60:	d8c02017 	ldw	r3,128(sp)
 8207d64:	d8801f17 	ldw	r2,124(sp)
 8207d68:	da000404 	addi	r8,sp,16
 8207d6c:	003fee06 	br	8207d28 <___vfprintf_internal_r+0x1290>
 8207d70:	d9002c17 	ldw	r4,176(sp)
 8207d74:	d9801e04 	addi	r6,sp,120
 8207d78:	b80b883a 	mov	r5,r23
 8207d7c:	820f5ec0 	call	820f5ec <__sprint_r>
 8207d80:	103c471e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 8207d84:	d8c02017 	ldw	r3,128(sp)
 8207d88:	df002787 	ldb	fp,158(sp)
 8207d8c:	da000404 	addi	r8,sp,16
 8207d90:	003d5606 	br	82072ec <___vfprintf_internal_r+0x854>
 8207d94:	9080040c 	andi	r2,r18,16
 8207d98:	10016126 	beq	r2,zero,8208320 <___vfprintf_internal_r+0x1888>
 8207d9c:	d8802d17 	ldw	r2,180(sp)
 8207da0:	14c00017 	ldw	r19,0(r2)
 8207da4:	10800104 	addi	r2,r2,4
 8207da8:	d8802d15 	stw	r2,180(sp)
 8207dac:	982dd7fa 	srai	r22,r19,31
 8207db0:	b005883a 	mov	r2,r22
 8207db4:	003c8206 	br	8206fc0 <___vfprintf_internal_r+0x528>
 8207db8:	9080040c 	andi	r2,r18,16
 8207dbc:	10003526 	beq	r2,zero,8207e94 <___vfprintf_internal_r+0x13fc>
 8207dc0:	d9402d17 	ldw	r5,180(sp)
 8207dc4:	d8c02917 	ldw	r3,164(sp)
 8207dc8:	d8002785 	stb	zero,158(sp)
 8207dcc:	28800104 	addi	r2,r5,4
 8207dd0:	2cc00017 	ldw	r19,0(r5)
 8207dd4:	002d883a 	mov	r22,zero
 8207dd8:	18003716 	blt	r3,zero,8207eb8 <___vfprintf_internal_r+0x1420>
 8207ddc:	00ffdfc4 	movi	r3,-129
 8207de0:	d8802d15 	stw	r2,180(sp)
 8207de4:	90e4703a 	and	r18,r18,r3
 8207de8:	0039883a 	mov	fp,zero
 8207dec:	983df326 	beq	r19,zero,82075bc <___vfprintf_internal_r+0xb24>
 8207df0:	00800244 	movi	r2,9
 8207df4:	14fc7b36 	bltu	r2,r19,8206fe4 <___vfprintf_internal_r+0x54c>
 8207df8:	d8c02817 	ldw	r3,160(sp)
 8207dfc:	dc001dc4 	addi	r16,sp,119
 8207e00:	9cc00c04 	addi	r19,r19,48
 8207e04:	1c07c83a 	sub	r3,r3,r16
 8207e08:	dcc01dc5 	stb	r19,119(sp)
 8207e0c:	d8c02e15 	stw	r3,184(sp)
 8207e10:	003ce806 	br	82071b4 <___vfprintf_internal_r+0x71c>
 8207e14:	d8803317 	ldw	r2,204(sp)
 8207e18:	143fffc4 	addi	r16,r2,-1
 8207e1c:	043f4d0e 	bge	zero,r16,8207b54 <___vfprintf_internal_r+0x10bc>
 8207e20:	07000404 	movi	fp,16
 8207e24:	e400810e 	bge	fp,r16,820802c <___vfprintf_internal_r+0x1594>
 8207e28:	01420974 	movhi	r5,2085
 8207e2c:	2976f484 	addi	r5,r5,-9262
 8207e30:	d9402b15 	stw	r5,172(sp)
 8207e34:	01c001c4 	movi	r7,7
 8207e38:	dcc02c17 	ldw	r19,176(sp)
 8207e3c:	00000306 	br	8207e4c <___vfprintf_internal_r+0x13b4>
 8207e40:	b5800204 	addi	r22,r22,8
 8207e44:	843ffc04 	addi	r16,r16,-16
 8207e48:	e4007b0e 	bge	fp,r16,8208038 <___vfprintf_internal_r+0x15a0>
 8207e4c:	18c00404 	addi	r3,r3,16
 8207e50:	8c400044 	addi	r17,r17,1
 8207e54:	b5000015 	stw	r20,0(r22)
 8207e58:	b7000115 	stw	fp,4(r22)
 8207e5c:	d8c02015 	stw	r3,128(sp)
 8207e60:	dc401f15 	stw	r17,124(sp)
 8207e64:	3c7ff60e 	bge	r7,r17,8207e40 <___vfprintf_internal_r+0x13a8>
 8207e68:	d9801e04 	addi	r6,sp,120
 8207e6c:	b80b883a 	mov	r5,r23
 8207e70:	9809883a 	mov	r4,r19
 8207e74:	d9c03c15 	stw	r7,240(sp)
 8207e78:	820f5ec0 	call	820f5ec <__sprint_r>
 8207e7c:	d9c03c17 	ldw	r7,240(sp)
 8207e80:	103c071e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 8207e84:	d8c02017 	ldw	r3,128(sp)
 8207e88:	dc401f17 	ldw	r17,124(sp)
 8207e8c:	dd800404 	addi	r22,sp,16
 8207e90:	003fec06 	br	8207e44 <___vfprintf_internal_r+0x13ac>
 8207e94:	9080100c 	andi	r2,r18,64
 8207e98:	d8002785 	stb	zero,158(sp)
 8207e9c:	10010e26 	beq	r2,zero,82082d8 <___vfprintf_internal_r+0x1840>
 8207ea0:	d9002d17 	ldw	r4,180(sp)
 8207ea4:	d9402917 	ldw	r5,164(sp)
 8207ea8:	002d883a 	mov	r22,zero
 8207eac:	20800104 	addi	r2,r4,4
 8207eb0:	24c0000b 	ldhu	r19,0(r4)
 8207eb4:	283fc90e 	bge	r5,zero,8207ddc <___vfprintf_internal_r+0x1344>
 8207eb8:	d8802d15 	stw	r2,180(sp)
 8207ebc:	0039883a 	mov	fp,zero
 8207ec0:	9d84b03a 	or	r2,r19,r22
 8207ec4:	103c461e 	bne	r2,zero,8206fe0 <___vfprintf_internal_r+0x548>
 8207ec8:	00800044 	movi	r2,1
 8207ecc:	003e6c06 	br	8207880 <___vfprintf_internal_r+0xde8>
 8207ed0:	d9002c17 	ldw	r4,176(sp)
 8207ed4:	d9801e04 	addi	r6,sp,120
 8207ed8:	b80b883a 	mov	r5,r23
 8207edc:	820f5ec0 	call	820f5ec <__sprint_r>
 8207ee0:	103bef1e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 8207ee4:	d8c02017 	ldw	r3,128(sp)
 8207ee8:	da000404 	addi	r8,sp,16
 8207eec:	d9003217 	ldw	r4,200(sp)
 8207ef0:	d8802617 	ldw	r2,152(sp)
 8207ef4:	d9403317 	ldw	r5,204(sp)
 8207ef8:	8123883a 	add	r17,r16,r4
 8207efc:	11400216 	blt	r2,r5,8207f08 <___vfprintf_internal_r+0x1470>
 8207f00:	9100004c 	andi	r4,r18,1
 8207f04:	20000d26 	beq	r4,zero,8207f3c <___vfprintf_internal_r+0x14a4>
 8207f08:	d9003717 	ldw	r4,220(sp)
 8207f0c:	d9403417 	ldw	r5,208(sp)
 8207f10:	1907883a 	add	r3,r3,r4
 8207f14:	d9001f17 	ldw	r4,124(sp)
 8207f18:	41400015 	stw	r5,0(r8)
 8207f1c:	d9403717 	ldw	r5,220(sp)
 8207f20:	21000044 	addi	r4,r4,1
 8207f24:	d8c02015 	stw	r3,128(sp)
 8207f28:	41400115 	stw	r5,4(r8)
 8207f2c:	d9001f15 	stw	r4,124(sp)
 8207f30:	014001c4 	movi	r5,7
 8207f34:	2901e816 	blt	r5,r4,82086d8 <___vfprintf_internal_r+0x1c40>
 8207f38:	42000204 	addi	r8,r8,8
 8207f3c:	d9003317 	ldw	r4,204(sp)
 8207f40:	8121883a 	add	r16,r16,r4
 8207f44:	2085c83a 	sub	r2,r4,r2
 8207f48:	8461c83a 	sub	r16,r16,r17
 8207f4c:	1400010e 	bge	r2,r16,8207f54 <___vfprintf_internal_r+0x14bc>
 8207f50:	1021883a 	mov	r16,r2
 8207f54:	04000a0e 	bge	zero,r16,8207f80 <___vfprintf_internal_r+0x14e8>
 8207f58:	d9001f17 	ldw	r4,124(sp)
 8207f5c:	1c07883a 	add	r3,r3,r16
 8207f60:	44400015 	stw	r17,0(r8)
 8207f64:	21000044 	addi	r4,r4,1
 8207f68:	44000115 	stw	r16,4(r8)
 8207f6c:	d8c02015 	stw	r3,128(sp)
 8207f70:	d9001f15 	stw	r4,124(sp)
 8207f74:	014001c4 	movi	r5,7
 8207f78:	2901fb16 	blt	r5,r4,8208768 <___vfprintf_internal_r+0x1cd0>
 8207f7c:	42000204 	addi	r8,r8,8
 8207f80:	8001f716 	blt	r16,zero,8208760 <___vfprintf_internal_r+0x1cc8>
 8207f84:	1421c83a 	sub	r16,r2,r16
 8207f88:	043d380e 	bge	zero,r16,820746c <___vfprintf_internal_r+0x9d4>
 8207f8c:	04400404 	movi	r17,16
 8207f90:	d8801f17 	ldw	r2,124(sp)
 8207f94:	8c3efb0e 	bge	r17,r16,8207b84 <___vfprintf_internal_r+0x10ec>
 8207f98:	01420974 	movhi	r5,2085
 8207f9c:	2976f484 	addi	r5,r5,-9262
 8207fa0:	d9402b15 	stw	r5,172(sp)
 8207fa4:	058001c4 	movi	r22,7
 8207fa8:	dcc02c17 	ldw	r19,176(sp)
 8207fac:	00000306 	br	8207fbc <___vfprintf_internal_r+0x1524>
 8207fb0:	42000204 	addi	r8,r8,8
 8207fb4:	843ffc04 	addi	r16,r16,-16
 8207fb8:	8c3ef50e 	bge	r17,r16,8207b90 <___vfprintf_internal_r+0x10f8>
 8207fbc:	18c00404 	addi	r3,r3,16
 8207fc0:	10800044 	addi	r2,r2,1
 8207fc4:	45000015 	stw	r20,0(r8)
 8207fc8:	44400115 	stw	r17,4(r8)
 8207fcc:	d8c02015 	stw	r3,128(sp)
 8207fd0:	d8801f15 	stw	r2,124(sp)
 8207fd4:	b0bff60e 	bge	r22,r2,8207fb0 <___vfprintf_internal_r+0x1518>
 8207fd8:	d9801e04 	addi	r6,sp,120
 8207fdc:	b80b883a 	mov	r5,r23
 8207fe0:	9809883a 	mov	r4,r19
 8207fe4:	820f5ec0 	call	820f5ec <__sprint_r>
 8207fe8:	103bad1e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 8207fec:	d8c02017 	ldw	r3,128(sp)
 8207ff0:	d8801f17 	ldw	r2,124(sp)
 8207ff4:	da000404 	addi	r8,sp,16
 8207ff8:	003fee06 	br	8207fb4 <___vfprintf_internal_r+0x151c>
 8207ffc:	9088703a 	and	r4,r18,r2
 8208000:	203eab1e 	bne	r4,zero,8207ab0 <___vfprintf_internal_r+0x1018>
 8208004:	dc401f17 	ldw	r17,124(sp)
 8208008:	40800115 	stw	r2,4(r8)
 820800c:	44000015 	stw	r16,0(r8)
 8208010:	8c400044 	addi	r17,r17,1
 8208014:	d8c02015 	stw	r3,128(sp)
 8208018:	dc401f15 	stw	r17,124(sp)
 820801c:	008001c4 	movi	r2,7
 8208020:	14400e16 	blt	r2,r17,820805c <___vfprintf_internal_r+0x15c4>
 8208024:	45800204 	addi	r22,r8,8
 8208028:	003eca06 	br	8207b54 <___vfprintf_internal_r+0x10bc>
 820802c:	01020974 	movhi	r4,2085
 8208030:	2136f484 	addi	r4,r4,-9262
 8208034:	d9002b15 	stw	r4,172(sp)
 8208038:	d8802b17 	ldw	r2,172(sp)
 820803c:	1c07883a 	add	r3,r3,r16
 8208040:	8c400044 	addi	r17,r17,1
 8208044:	b0800015 	stw	r2,0(r22)
 8208048:	b4000115 	stw	r16,4(r22)
 820804c:	d8c02015 	stw	r3,128(sp)
 8208050:	dc401f15 	stw	r17,124(sp)
 8208054:	008001c4 	movi	r2,7
 8208058:	147ebd0e 	bge	r2,r17,8207b50 <___vfprintf_internal_r+0x10b8>
 820805c:	d9002c17 	ldw	r4,176(sp)
 8208060:	d9801e04 	addi	r6,sp,120
 8208064:	b80b883a 	mov	r5,r23
 8208068:	820f5ec0 	call	820f5ec <__sprint_r>
 820806c:	103b8c1e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 8208070:	d8c02017 	ldw	r3,128(sp)
 8208074:	dc401f17 	ldw	r17,124(sp)
 8208078:	dd800404 	addi	r22,sp,16
 820807c:	003eb506 	br	8207b54 <___vfprintf_internal_r+0x10bc>
 8208080:	d9002c17 	ldw	r4,176(sp)
 8208084:	d9801e04 	addi	r6,sp,120
 8208088:	b80b883a 	mov	r5,r23
 820808c:	820f5ec0 	call	820f5ec <__sprint_r>
 8208090:	103b831e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 8208094:	d8c02017 	ldw	r3,128(sp)
 8208098:	dc401f17 	ldw	r17,124(sp)
 820809c:	da000404 	addi	r8,sp,16
 82080a0:	003e8d06 	br	8207ad8 <___vfprintf_internal_r+0x1040>
 82080a4:	d9002c17 	ldw	r4,176(sp)
 82080a8:	d9801e04 	addi	r6,sp,120
 82080ac:	b80b883a 	mov	r5,r23
 82080b0:	820f5ec0 	call	820f5ec <__sprint_r>
 82080b4:	103b7a1e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 82080b8:	d8c02017 	ldw	r3,128(sp)
 82080bc:	dc401f17 	ldw	r17,124(sp)
 82080c0:	dd800404 	addi	r22,sp,16
 82080c4:	003e8f06 	br	8207b04 <___vfprintf_internal_r+0x106c>
 82080c8:	0027883a 	mov	r19,zero
 82080cc:	003f4a06 	br	8207df8 <___vfprintf_internal_r+0x1360>
 82080d0:	d9002c17 	ldw	r4,176(sp)
 82080d4:	d9801e04 	addi	r6,sp,120
 82080d8:	b80b883a 	mov	r5,r23
 82080dc:	820f5ec0 	call	820f5ec <__sprint_r>
 82080e0:	103b6f1e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 82080e4:	d8c02017 	ldw	r3,128(sp)
 82080e8:	da000404 	addi	r8,sp,16
 82080ec:	003c9d06 	br	8207364 <___vfprintf_internal_r+0x8cc>
 82080f0:	04e7c83a 	sub	r19,zero,r19
 82080f4:	9804c03a 	cmpne	r2,r19,zero
 82080f8:	05adc83a 	sub	r22,zero,r22
 82080fc:	b0adc83a 	sub	r22,r22,r2
 8208100:	d8802917 	ldw	r2,164(sp)
 8208104:	07000b44 	movi	fp,45
 8208108:	df002785 	stb	fp,158(sp)
 820810c:	10017b16 	blt	r2,zero,82086fc <___vfprintf_internal_r+0x1c64>
 8208110:	00bfdfc4 	movi	r2,-129
 8208114:	90a4703a 	and	r18,r18,r2
 8208118:	003bb106 	br	8206fe0 <___vfprintf_internal_r+0x548>
 820811c:	d9003617 	ldw	r4,216(sp)
 8208120:	d9403817 	ldw	r5,224(sp)
 8208124:	da003d15 	stw	r8,244(sp)
 8208128:	820de040 	call	820de04 <__fpclassifyd>
 820812c:	da003d17 	ldw	r8,244(sp)
 8208130:	1000f026 	beq	r2,zero,82084f4 <___vfprintf_internal_r+0x1a5c>
 8208134:	d9002917 	ldw	r4,164(sp)
 8208138:	05bff7c4 	movi	r22,-33
 820813c:	00bfffc4 	movi	r2,-1
 8208140:	8dac703a 	and	r22,r17,r22
 8208144:	20820026 	beq	r4,r2,8208948 <___vfprintf_internal_r+0x1eb0>
 8208148:	008011c4 	movi	r2,71
 820814c:	b081f726 	beq	r22,r2,820892c <___vfprintf_internal_r+0x1e94>
 8208150:	d9003817 	ldw	r4,224(sp)
 8208154:	90c04014 	ori	r3,r18,256
 8208158:	d8c02b15 	stw	r3,172(sp)
 820815c:	20021516 	blt	r4,zero,82089b4 <___vfprintf_internal_r+0x1f1c>
 8208160:	dcc03817 	ldw	r19,224(sp)
 8208164:	d8002a05 	stb	zero,168(sp)
 8208168:	00801984 	movi	r2,102
 820816c:	8881f926 	beq	r17,r2,8208954 <___vfprintf_internal_r+0x1ebc>
 8208170:	00801184 	movi	r2,70
 8208174:	88821c26 	beq	r17,r2,82089e8 <___vfprintf_internal_r+0x1f50>
 8208178:	00801144 	movi	r2,69
 820817c:	b081ef26 	beq	r22,r2,820893c <___vfprintf_internal_r+0x1ea4>
 8208180:	d8c02917 	ldw	r3,164(sp)
 8208184:	d8802104 	addi	r2,sp,132
 8208188:	d8800315 	stw	r2,12(sp)
 820818c:	d9403617 	ldw	r5,216(sp)
 8208190:	d8802504 	addi	r2,sp,148
 8208194:	d9002c17 	ldw	r4,176(sp)
 8208198:	d8800215 	stw	r2,8(sp)
 820819c:	d8802604 	addi	r2,sp,152
 82081a0:	d8c00015 	stw	r3,0(sp)
 82081a4:	d8800115 	stw	r2,4(sp)
 82081a8:	01c00084 	movi	r7,2
 82081ac:	980d883a 	mov	r6,r19
 82081b0:	d8c03c15 	stw	r3,240(sp)
 82081b4:	da003d15 	stw	r8,244(sp)
 82081b8:	82092140 	call	8209214 <_dtoa_r>
 82081bc:	1021883a 	mov	r16,r2
 82081c0:	008019c4 	movi	r2,103
 82081c4:	d8c03c17 	ldw	r3,240(sp)
 82081c8:	da003d17 	ldw	r8,244(sp)
 82081cc:	88817126 	beq	r17,r2,8208794 <___vfprintf_internal_r+0x1cfc>
 82081d0:	008011c4 	movi	r2,71
 82081d4:	88829226 	beq	r17,r2,8208c20 <___vfprintf_internal_r+0x2188>
 82081d8:	80f9883a 	add	fp,r16,r3
 82081dc:	d9003617 	ldw	r4,216(sp)
 82081e0:	000d883a 	mov	r6,zero
 82081e4:	000f883a 	mov	r7,zero
 82081e8:	980b883a 	mov	r5,r19
 82081ec:	da003d15 	stw	r8,244(sp)
 82081f0:	8212f580 	call	8212f58 <__eqdf2>
 82081f4:	da003d17 	ldw	r8,244(sp)
 82081f8:	10018d26 	beq	r2,zero,8208830 <___vfprintf_internal_r+0x1d98>
 82081fc:	d8802117 	ldw	r2,132(sp)
 8208200:	1700062e 	bgeu	r2,fp,820821c <___vfprintf_internal_r+0x1784>
 8208204:	01000c04 	movi	r4,48
 8208208:	10c00044 	addi	r3,r2,1
 820820c:	d8c02115 	stw	r3,132(sp)
 8208210:	11000005 	stb	r4,0(r2)
 8208214:	d8802117 	ldw	r2,132(sp)
 8208218:	173ffb36 	bltu	r2,fp,8208208 <___vfprintf_internal_r+0x1770>
 820821c:	1405c83a 	sub	r2,r2,r16
 8208220:	d8803315 	stw	r2,204(sp)
 8208224:	008011c4 	movi	r2,71
 8208228:	b0817626 	beq	r22,r2,8208804 <___vfprintf_internal_r+0x1d6c>
 820822c:	00801944 	movi	r2,101
 8208230:	1442810e 	bge	r2,r17,8208c38 <___vfprintf_internal_r+0x21a0>
 8208234:	d8c02617 	ldw	r3,152(sp)
 8208238:	00801984 	movi	r2,102
 820823c:	d8c03215 	stw	r3,200(sp)
 8208240:	8881fe26 	beq	r17,r2,8208a3c <___vfprintf_internal_r+0x1fa4>
 8208244:	d8c03217 	ldw	r3,200(sp)
 8208248:	d9003317 	ldw	r4,204(sp)
 820824c:	1901dd16 	blt	r3,r4,82089c4 <___vfprintf_internal_r+0x1f2c>
 8208250:	9480004c 	andi	r18,r18,1
 8208254:	90022b1e 	bne	r18,zero,8208b04 <___vfprintf_internal_r+0x206c>
 8208258:	1805883a 	mov	r2,r3
 820825c:	18028016 	blt	r3,zero,8208c60 <___vfprintf_internal_r+0x21c8>
 8208260:	d8c03217 	ldw	r3,200(sp)
 8208264:	044019c4 	movi	r17,103
 8208268:	d8c02e15 	stw	r3,184(sp)
 820826c:	df002a07 	ldb	fp,168(sp)
 8208270:	e001531e 	bne	fp,zero,82087c0 <___vfprintf_internal_r+0x1d28>
 8208274:	df002783 	ldbu	fp,158(sp)
 8208278:	d8802a15 	stw	r2,168(sp)
 820827c:	dc802b17 	ldw	r18,172(sp)
 8208280:	d8002915 	stw	zero,164(sp)
 8208284:	003bd106 	br	82071cc <___vfprintf_internal_r+0x734>
 8208288:	d8802d17 	ldw	r2,180(sp)
 820828c:	d8c02d17 	ldw	r3,180(sp)
 8208290:	d9002d17 	ldw	r4,180(sp)
 8208294:	10800017 	ldw	r2,0(r2)
 8208298:	18c00117 	ldw	r3,4(r3)
 820829c:	21000204 	addi	r4,r4,8
 82082a0:	d8803615 	stw	r2,216(sp)
 82082a4:	d8c03815 	stw	r3,224(sp)
 82082a8:	d9002d15 	stw	r4,180(sp)
 82082ac:	003b7506 	br	8207084 <___vfprintf_internal_r+0x5ec>
 82082b0:	ac400007 	ldb	r17,0(r21)
 82082b4:	003a5906 	br	8206c1c <___vfprintf_internal_r+0x184>
 82082b8:	9080100c 	andi	r2,r18,64
 82082bc:	1000a826 	beq	r2,zero,8208560 <___vfprintf_internal_r+0x1ac8>
 82082c0:	d9002d17 	ldw	r4,180(sp)
 82082c4:	002d883a 	mov	r22,zero
 82082c8:	24c0000b 	ldhu	r19,0(r4)
 82082cc:	21000104 	addi	r4,r4,4
 82082d0:	d9002d15 	stw	r4,180(sp)
 82082d4:	003ccb06 	br	8207604 <___vfprintf_internal_r+0xb6c>
 82082d8:	d8c02d17 	ldw	r3,180(sp)
 82082dc:	d9002917 	ldw	r4,164(sp)
 82082e0:	002d883a 	mov	r22,zero
 82082e4:	18800104 	addi	r2,r3,4
 82082e8:	1cc00017 	ldw	r19,0(r3)
 82082ec:	203ebb0e 	bge	r4,zero,8207ddc <___vfprintf_internal_r+0x1344>
 82082f0:	003ef106 	br	8207eb8 <___vfprintf_internal_r+0x1420>
 82082f4:	9080040c 	andi	r2,r18,16
 82082f8:	1000921e 	bne	r2,zero,8208544 <___vfprintf_internal_r+0x1aac>
 82082fc:	9480100c 	andi	r18,r18,64
 8208300:	90013926 	beq	r18,zero,82087e8 <___vfprintf_internal_r+0x1d50>
 8208304:	d9002d17 	ldw	r4,180(sp)
 8208308:	d9402f17 	ldw	r5,188(sp)
 820830c:	20800017 	ldw	r2,0(r4)
 8208310:	21000104 	addi	r4,r4,4
 8208314:	d9002d15 	stw	r4,180(sp)
 8208318:	1140000d 	sth	r5,0(r2)
 820831c:	003a1606 	br	8206b78 <___vfprintf_internal_r+0xe0>
 8208320:	9080100c 	andi	r2,r18,64
 8208324:	10008026 	beq	r2,zero,8208528 <___vfprintf_internal_r+0x1a90>
 8208328:	d8c02d17 	ldw	r3,180(sp)
 820832c:	1cc0000f 	ldh	r19,0(r3)
 8208330:	18c00104 	addi	r3,r3,4
 8208334:	d8c02d15 	stw	r3,180(sp)
 8208338:	982dd7fa 	srai	r22,r19,31
 820833c:	b005883a 	mov	r2,r22
 8208340:	003b1f06 	br	8206fc0 <___vfprintf_internal_r+0x528>
 8208344:	9080100c 	andi	r2,r18,64
 8208348:	d8002785 	stb	zero,158(sp)
 820834c:	10008a1e 	bne	r2,zero,8208578 <___vfprintf_internal_r+0x1ae0>
 8208350:	d9402d17 	ldw	r5,180(sp)
 8208354:	d8c02917 	ldw	r3,164(sp)
 8208358:	002d883a 	mov	r22,zero
 820835c:	28800104 	addi	r2,r5,4
 8208360:	2cc00017 	ldw	r19,0(r5)
 8208364:	183e4b0e 	bge	r3,zero,8207c94 <___vfprintf_internal_r+0x11fc>
 8208368:	9d86b03a 	or	r3,r19,r22
 820836c:	d8802d15 	stw	r2,180(sp)
 8208370:	183e4c1e 	bne	r3,zero,8207ca4 <___vfprintf_internal_r+0x120c>
 8208374:	0039883a 	mov	fp,zero
 8208378:	0005883a 	mov	r2,zero
 820837c:	003d4006 	br	8207880 <___vfprintf_internal_r+0xde8>
 8208380:	01420974 	movhi	r5,2085
 8208384:	2976f484 	addi	r5,r5,-9262
 8208388:	d9402b15 	stw	r5,172(sp)
 820838c:	d9402b17 	ldw	r5,172(sp)
 8208390:	1c47883a 	add	r3,r3,r17
 8208394:	10800044 	addi	r2,r2,1
 8208398:	41400015 	stw	r5,0(r8)
 820839c:	44400115 	stw	r17,4(r8)
 82083a0:	d8c02015 	stw	r3,128(sp)
 82083a4:	d8801f15 	stw	r2,124(sp)
 82083a8:	010001c4 	movi	r4,7
 82083ac:	20bec816 	blt	r4,r2,8207ed0 <___vfprintf_internal_r+0x1438>
 82083b0:	42000204 	addi	r8,r8,8
 82083b4:	003ecd06 	br	8207eec <___vfprintf_internal_r+0x1454>
 82083b8:	d9002917 	ldw	r4,164(sp)
 82083bc:	d8002785 	stb	zero,158(sp)
 82083c0:	203d2d16 	blt	r4,zero,8207878 <___vfprintf_internal_r+0xde0>
 82083c4:	00bfdfc4 	movi	r2,-129
 82083c8:	90a4703a 	and	r18,r18,r2
 82083cc:	003a9106 	br	8206e14 <___vfprintf_internal_r+0x37c>
 82083d0:	01020974 	movhi	r4,2085
 82083d4:	2136f484 	addi	r4,r4,-9262
 82083d8:	d9002b15 	stw	r4,172(sp)
 82083dc:	003c0c06 	br	8207410 <___vfprintf_internal_r+0x978>
 82083e0:	d9002c17 	ldw	r4,176(sp)
 82083e4:	d9801e04 	addi	r6,sp,120
 82083e8:	b80b883a 	mov	r5,r23
 82083ec:	820f5ec0 	call	820f5ec <__sprint_r>
 82083f0:	103aab1e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 82083f4:	d8c02017 	ldw	r3,128(sp)
 82083f8:	da000404 	addi	r8,sp,16
 82083fc:	003d4106 	br	8207904 <___vfprintf_internal_r+0xe6c>
 8208400:	d8801f17 	ldw	r2,124(sp)
 8208404:	01420974 	movhi	r5,2085
 8208408:	01000044 	movi	r4,1
 820840c:	18c00044 	addi	r3,r3,1
 8208410:	10800044 	addi	r2,r2,1
 8208414:	2976ec04 	addi	r5,r5,-9296
 8208418:	41000115 	stw	r4,4(r8)
 820841c:	41400015 	stw	r5,0(r8)
 8208420:	d8c02015 	stw	r3,128(sp)
 8208424:	d8801f15 	stw	r2,124(sp)
 8208428:	010001c4 	movi	r4,7
 820842c:	20805c16 	blt	r4,r2,82085a0 <___vfprintf_internal_r+0x1b08>
 8208430:	42000204 	addi	r8,r8,8
 8208434:	8800041e 	bne	r17,zero,8208448 <___vfprintf_internal_r+0x19b0>
 8208438:	d8803317 	ldw	r2,204(sp)
 820843c:	1000021e 	bne	r2,zero,8208448 <___vfprintf_internal_r+0x19b0>
 8208440:	9080004c 	andi	r2,r18,1
 8208444:	103c0926 	beq	r2,zero,820746c <___vfprintf_internal_r+0x9d4>
 8208448:	d9003717 	ldw	r4,220(sp)
 820844c:	d8801f17 	ldw	r2,124(sp)
 8208450:	d9403417 	ldw	r5,208(sp)
 8208454:	20c7883a 	add	r3,r4,r3
 8208458:	10800044 	addi	r2,r2,1
 820845c:	41000115 	stw	r4,4(r8)
 8208460:	41400015 	stw	r5,0(r8)
 8208464:	d8c02015 	stw	r3,128(sp)
 8208468:	d8801f15 	stw	r2,124(sp)
 820846c:	010001c4 	movi	r4,7
 8208470:	20812116 	blt	r4,r2,82088f8 <___vfprintf_internal_r+0x1e60>
 8208474:	42000204 	addi	r8,r8,8
 8208478:	0463c83a 	sub	r17,zero,r17
 820847c:	0440730e 	bge	zero,r17,820864c <___vfprintf_internal_r+0x1bb4>
 8208480:	05800404 	movi	r22,16
 8208484:	b440860e 	bge	r22,r17,82086a0 <___vfprintf_internal_r+0x1c08>
 8208488:	01420974 	movhi	r5,2085
 820848c:	2976f484 	addi	r5,r5,-9262
 8208490:	d9402b15 	stw	r5,172(sp)
 8208494:	070001c4 	movi	fp,7
 8208498:	dcc02c17 	ldw	r19,176(sp)
 820849c:	00000306 	br	82084ac <___vfprintf_internal_r+0x1a14>
 82084a0:	42000204 	addi	r8,r8,8
 82084a4:	8c7ffc04 	addi	r17,r17,-16
 82084a8:	b440800e 	bge	r22,r17,82086ac <___vfprintf_internal_r+0x1c14>
 82084ac:	18c00404 	addi	r3,r3,16
 82084b0:	10800044 	addi	r2,r2,1
 82084b4:	45000015 	stw	r20,0(r8)
 82084b8:	45800115 	stw	r22,4(r8)
 82084bc:	d8c02015 	stw	r3,128(sp)
 82084c0:	d8801f15 	stw	r2,124(sp)
 82084c4:	e0bff60e 	bge	fp,r2,82084a0 <___vfprintf_internal_r+0x1a08>
 82084c8:	d9801e04 	addi	r6,sp,120
 82084cc:	b80b883a 	mov	r5,r23
 82084d0:	9809883a 	mov	r4,r19
 82084d4:	820f5ec0 	call	820f5ec <__sprint_r>
 82084d8:	103a711e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 82084dc:	d8c02017 	ldw	r3,128(sp)
 82084e0:	d8801f17 	ldw	r2,124(sp)
 82084e4:	da000404 	addi	r8,sp,16
 82084e8:	003fee06 	br	82084a4 <___vfprintf_internal_r+0x1a0c>
 82084ec:	00bfffc4 	movi	r2,-1
 82084f0:	003a6f06 	br	8206eb0 <___vfprintf_internal_r+0x418>
 82084f4:	008011c4 	movi	r2,71
 82084f8:	1440b816 	blt	r2,r17,82087dc <___vfprintf_internal_r+0x1d44>
 82084fc:	04020974 	movhi	r16,2085
 8208500:	8436de04 	addi	r16,r16,-9352
 8208504:	00c000c4 	movi	r3,3
 8208508:	00bfdfc4 	movi	r2,-129
 820850c:	d8c02a15 	stw	r3,168(sp)
 8208510:	90a4703a 	and	r18,r18,r2
 8208514:	df002783 	ldbu	fp,158(sp)
 8208518:	d8c02e15 	stw	r3,184(sp)
 820851c:	d8002915 	stw	zero,164(sp)
 8208520:	d8003215 	stw	zero,200(sp)
 8208524:	003b2906 	br	82071cc <___vfprintf_internal_r+0x734>
 8208528:	d9002d17 	ldw	r4,180(sp)
 820852c:	24c00017 	ldw	r19,0(r4)
 8208530:	21000104 	addi	r4,r4,4
 8208534:	d9002d15 	stw	r4,180(sp)
 8208538:	982dd7fa 	srai	r22,r19,31
 820853c:	b005883a 	mov	r2,r22
 8208540:	003a9f06 	br	8206fc0 <___vfprintf_internal_r+0x528>
 8208544:	d9402d17 	ldw	r5,180(sp)
 8208548:	d8c02f17 	ldw	r3,188(sp)
 820854c:	28800017 	ldw	r2,0(r5)
 8208550:	29400104 	addi	r5,r5,4
 8208554:	d9402d15 	stw	r5,180(sp)
 8208558:	10c00015 	stw	r3,0(r2)
 820855c:	00398606 	br	8206b78 <___vfprintf_internal_r+0xe0>
 8208560:	d9402d17 	ldw	r5,180(sp)
 8208564:	002d883a 	mov	r22,zero
 8208568:	2cc00017 	ldw	r19,0(r5)
 820856c:	29400104 	addi	r5,r5,4
 8208570:	d9402d15 	stw	r5,180(sp)
 8208574:	003c2306 	br	8207604 <___vfprintf_internal_r+0xb6c>
 8208578:	d8c02d17 	ldw	r3,180(sp)
 820857c:	d9002917 	ldw	r4,164(sp)
 8208580:	002d883a 	mov	r22,zero
 8208584:	18800104 	addi	r2,r3,4
 8208588:	1cc0000b 	ldhu	r19,0(r3)
 820858c:	203dc10e 	bge	r4,zero,8207c94 <___vfprintf_internal_r+0x11fc>
 8208590:	003f7506 	br	8208368 <___vfprintf_internal_r+0x18d0>
 8208594:	04020974 	movhi	r16,2085
 8208598:	8436dc04 	addi	r16,r16,-9360
 820859c:	003acc06 	br	82070d0 <___vfprintf_internal_r+0x638>
 82085a0:	d9002c17 	ldw	r4,176(sp)
 82085a4:	d9801e04 	addi	r6,sp,120
 82085a8:	b80b883a 	mov	r5,r23
 82085ac:	820f5ec0 	call	820f5ec <__sprint_r>
 82085b0:	103a3b1e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 82085b4:	dc402617 	ldw	r17,152(sp)
 82085b8:	d8c02017 	ldw	r3,128(sp)
 82085bc:	da000404 	addi	r8,sp,16
 82085c0:	003f9c06 	br	8208434 <___vfprintf_internal_r+0x199c>
 82085c4:	ac400043 	ldbu	r17,1(r21)
 82085c8:	94800814 	ori	r18,r18,32
 82085cc:	ad400044 	addi	r21,r21,1
 82085d0:	8c403fcc 	andi	r17,r17,255
 82085d4:	8c40201c 	xori	r17,r17,128
 82085d8:	8c7fe004 	addi	r17,r17,-128
 82085dc:	00398f06 	br	8206c1c <___vfprintf_internal_r+0x184>
 82085e0:	d8c02d15 	stw	r3,180(sp)
 82085e4:	0039883a 	mov	fp,zero
 82085e8:	003e3506 	br	8207ec0 <___vfprintf_internal_r+0x1428>
 82085ec:	d9002c17 	ldw	r4,176(sp)
 82085f0:	d9801e04 	addi	r6,sp,120
 82085f4:	b80b883a 	mov	r5,r23
 82085f8:	820f5ec0 	call	820f5ec <__sprint_r>
 82085fc:	103a281e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 8208600:	d8c02017 	ldw	r3,128(sp)
 8208604:	da000404 	addi	r8,sp,16
 8208608:	003cd006 	br	820794c <___vfprintf_internal_r+0xeb4>
 820860c:	8009883a 	mov	r4,r16
 8208610:	da003d15 	stw	r8,244(sp)
 8208614:	8203fbc0 	call	8203fbc <strlen>
 8208618:	d8802e15 	stw	r2,184(sp)
 820861c:	da003d17 	ldw	r8,244(sp)
 8208620:	103c340e 	bge	r2,zero,82076f4 <___vfprintf_internal_r+0xc5c>
 8208624:	0005883a 	mov	r2,zero
 8208628:	003c3206 	br	82076f4 <___vfprintf_internal_r+0xc5c>
 820862c:	d9002c17 	ldw	r4,176(sp)
 8208630:	d9801e04 	addi	r6,sp,120
 8208634:	b80b883a 	mov	r5,r23
 8208638:	820f5ec0 	call	820f5ec <__sprint_r>
 820863c:	103a181e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 8208640:	d8c02017 	ldw	r3,128(sp)
 8208644:	d8801f17 	ldw	r2,124(sp)
 8208648:	da000404 	addi	r8,sp,16
 820864c:	d9403317 	ldw	r5,204(sp)
 8208650:	10800044 	addi	r2,r2,1
 8208654:	44000015 	stw	r16,0(r8)
 8208658:	28c7883a 	add	r3,r5,r3
 820865c:	003b7d06 	br	8207454 <___vfprintf_internal_r+0x9bc>
 8208660:	01020974 	movhi	r4,2085
 8208664:	2136f884 	addi	r4,r4,-9246
 8208668:	d9003515 	stw	r4,212(sp)
 820866c:	003b1406 	br	82072c0 <___vfprintf_internal_r+0x828>
 8208670:	013fffc4 	movi	r4,-1
 8208674:	003a3506 	br	8206f4c <___vfprintf_internal_r+0x4b4>
 8208678:	0023883a 	mov	r17,zero
 820867c:	003d9d06 	br	8207cf4 <___vfprintf_internal_r+0x125c>
 8208680:	d9002c17 	ldw	r4,176(sp)
 8208684:	d9801e04 	addi	r6,sp,120
 8208688:	b80b883a 	mov	r5,r23
 820868c:	820f5ec0 	call	820f5ec <__sprint_r>
 8208690:	103a031e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 8208694:	d8c02017 	ldw	r3,128(sp)
 8208698:	da000404 	addi	r8,sp,16
 820869c:	003d9406 	br	8207cf0 <___vfprintf_internal_r+0x1258>
 82086a0:	01020974 	movhi	r4,2085
 82086a4:	2136f484 	addi	r4,r4,-9262
 82086a8:	d9002b15 	stw	r4,172(sp)
 82086ac:	d9002b17 	ldw	r4,172(sp)
 82086b0:	1c47883a 	add	r3,r3,r17
 82086b4:	10800044 	addi	r2,r2,1
 82086b8:	41000015 	stw	r4,0(r8)
 82086bc:	44400115 	stw	r17,4(r8)
 82086c0:	d8c02015 	stw	r3,128(sp)
 82086c4:	d8801f15 	stw	r2,124(sp)
 82086c8:	010001c4 	movi	r4,7
 82086cc:	20bfd716 	blt	r4,r2,820862c <___vfprintf_internal_r+0x1b94>
 82086d0:	42000204 	addi	r8,r8,8
 82086d4:	003fdd06 	br	820864c <___vfprintf_internal_r+0x1bb4>
 82086d8:	d9002c17 	ldw	r4,176(sp)
 82086dc:	d9801e04 	addi	r6,sp,120
 82086e0:	b80b883a 	mov	r5,r23
 82086e4:	820f5ec0 	call	820f5ec <__sprint_r>
 82086e8:	1039ed1e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 82086ec:	d8802617 	ldw	r2,152(sp)
 82086f0:	d8c02017 	ldw	r3,128(sp)
 82086f4:	da000404 	addi	r8,sp,16
 82086f8:	003e1006 	br	8207f3c <___vfprintf_internal_r+0x14a4>
 82086fc:	00800044 	movi	r2,1
 8208700:	10803fcc 	andi	r2,r2,255
 8208704:	00c00044 	movi	r3,1
 8208708:	10fa3526 	beq	r2,r3,8206fe0 <___vfprintf_internal_r+0x548>
 820870c:	00c00084 	movi	r3,2
 8208710:	10fbcb26 	beq	r2,r3,8207640 <___vfprintf_internal_r+0xba8>
 8208714:	003a8f06 	br	8207154 <___vfprintf_internal_r+0x6bc>
 8208718:	01020974 	movhi	r4,2085
 820871c:	2136f884 	addi	r4,r4,-9246
 8208720:	d9003515 	stw	r4,212(sp)
 8208724:	003b7606 	br	8207500 <___vfprintf_internal_r+0xa68>
 8208728:	d8802917 	ldw	r2,164(sp)
 820872c:	00c00184 	movi	r3,6
 8208730:	1880012e 	bgeu	r3,r2,8208738 <___vfprintf_internal_r+0x1ca0>
 8208734:	1805883a 	mov	r2,r3
 8208738:	d8802e15 	stw	r2,184(sp)
 820873c:	1000ef16 	blt	r2,zero,8208afc <___vfprintf_internal_r+0x2064>
 8208740:	04020974 	movhi	r16,2085
 8208744:	d8802a15 	stw	r2,168(sp)
 8208748:	dcc02d15 	stw	r19,180(sp)
 820874c:	d8002915 	stw	zero,164(sp)
 8208750:	d8003215 	stw	zero,200(sp)
 8208754:	8436ea04 	addi	r16,r16,-9304
 8208758:	0039883a 	mov	fp,zero
 820875c:	003aa206 	br	82071e8 <___vfprintf_internal_r+0x750>
 8208760:	0021883a 	mov	r16,zero
 8208764:	003e0706 	br	8207f84 <___vfprintf_internal_r+0x14ec>
 8208768:	d9002c17 	ldw	r4,176(sp)
 820876c:	d9801e04 	addi	r6,sp,120
 8208770:	b80b883a 	mov	r5,r23
 8208774:	820f5ec0 	call	820f5ec <__sprint_r>
 8208778:	1039c91e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 820877c:	d8802617 	ldw	r2,152(sp)
 8208780:	d9403317 	ldw	r5,204(sp)
 8208784:	d8c02017 	ldw	r3,128(sp)
 8208788:	da000404 	addi	r8,sp,16
 820878c:	2885c83a 	sub	r2,r5,r2
 8208790:	003dfb06 	br	8207f80 <___vfprintf_internal_r+0x14e8>
 8208794:	9080004c 	andi	r2,r18,1
 8208798:	103e8f1e 	bne	r2,zero,82081d8 <___vfprintf_internal_r+0x1740>
 820879c:	d8802117 	ldw	r2,132(sp)
 82087a0:	003e9e06 	br	820821c <___vfprintf_internal_r+0x1784>
 82087a4:	1025883a 	mov	r18,r2
 82087a8:	0039883a 	mov	fp,zero
 82087ac:	00800084 	movi	r2,2
 82087b0:	003fd306 	br	8208700 <___vfprintf_internal_r+0x1c68>
 82087b4:	07000b44 	movi	fp,45
 82087b8:	df002785 	stb	fp,158(sp)
 82087bc:	003a4006 	br	82070c0 <___vfprintf_internal_r+0x628>
 82087c0:	00c00b44 	movi	r3,45
 82087c4:	d8c02785 	stb	r3,158(sp)
 82087c8:	d8802a15 	stw	r2,168(sp)
 82087cc:	dc802b17 	ldw	r18,172(sp)
 82087d0:	d8002915 	stw	zero,164(sp)
 82087d4:	07000b44 	movi	fp,45
 82087d8:	003a8006 	br	82071dc <___vfprintf_internal_r+0x744>
 82087dc:	04020974 	movhi	r16,2085
 82087e0:	8436df04 	addi	r16,r16,-9348
 82087e4:	003f4706 	br	8208504 <___vfprintf_internal_r+0x1a6c>
 82087e8:	d8c02d17 	ldw	r3,180(sp)
 82087ec:	d9002f17 	ldw	r4,188(sp)
 82087f0:	18800017 	ldw	r2,0(r3)
 82087f4:	18c00104 	addi	r3,r3,4
 82087f8:	d8c02d15 	stw	r3,180(sp)
 82087fc:	11000015 	stw	r4,0(r2)
 8208800:	0038dd06 	br	8206b78 <___vfprintf_internal_r+0xe0>
 8208804:	dd802617 	ldw	r22,152(sp)
 8208808:	00bfff44 	movi	r2,-3
 820880c:	b0801c16 	blt	r22,r2,8208880 <___vfprintf_internal_r+0x1de8>
 8208810:	d9402917 	ldw	r5,164(sp)
 8208814:	2d801a16 	blt	r5,r22,8208880 <___vfprintf_internal_r+0x1de8>
 8208818:	dd803215 	stw	r22,200(sp)
 820881c:	003e8906 	br	8208244 <___vfprintf_internal_r+0x17ac>
 8208820:	01020974 	movhi	r4,2085
 8208824:	2136f484 	addi	r4,r4,-9262
 8208828:	d9002b15 	stw	r4,172(sp)
 820882c:	003c9106 	br	8207a74 <___vfprintf_internal_r+0xfdc>
 8208830:	e005883a 	mov	r2,fp
 8208834:	003e7906 	br	820821c <___vfprintf_internal_r+0x1784>
 8208838:	d9402917 	ldw	r5,164(sp)
 820883c:	df002783 	ldbu	fp,158(sp)
 8208840:	dcc02d15 	stw	r19,180(sp)
 8208844:	d9402a15 	stw	r5,168(sp)
 8208848:	d9402e15 	stw	r5,184(sp)
 820884c:	d8002915 	stw	zero,164(sp)
 8208850:	d8003215 	stw	zero,200(sp)
 8208854:	003a5d06 	br	82071cc <___vfprintf_internal_r+0x734>
 8208858:	9080004c 	andi	r2,r18,1
 820885c:	0039883a 	mov	fp,zero
 8208860:	10000426 	beq	r2,zero,8208874 <___vfprintf_internal_r+0x1ddc>
 8208864:	00800c04 	movi	r2,48
 8208868:	dc001dc4 	addi	r16,sp,119
 820886c:	d8801dc5 	stb	r2,119(sp)
 8208870:	003b8006 	br	8207674 <___vfprintf_internal_r+0xbdc>
 8208874:	d8002e15 	stw	zero,184(sp)
 8208878:	dc001e04 	addi	r16,sp,120
 820887c:	003a4d06 	br	82071b4 <___vfprintf_internal_r+0x71c>
 8208880:	8c7fff84 	addi	r17,r17,-2
 8208884:	b5bfffc4 	addi	r22,r22,-1
 8208888:	dd802615 	stw	r22,152(sp)
 820888c:	dc4022c5 	stb	r17,139(sp)
 8208890:	b000bf16 	blt	r22,zero,8208b90 <___vfprintf_internal_r+0x20f8>
 8208894:	00800ac4 	movi	r2,43
 8208898:	d8802305 	stb	r2,140(sp)
 820889c:	00800244 	movi	r2,9
 82088a0:	15807016 	blt	r2,r22,8208a64 <___vfprintf_internal_r+0x1fcc>
 82088a4:	00800c04 	movi	r2,48
 82088a8:	b5800c04 	addi	r22,r22,48
 82088ac:	d8802345 	stb	r2,141(sp)
 82088b0:	dd802385 	stb	r22,142(sp)
 82088b4:	d88023c4 	addi	r2,sp,143
 82088b8:	df0022c4 	addi	fp,sp,139
 82088bc:	d8c03317 	ldw	r3,204(sp)
 82088c0:	1739c83a 	sub	fp,r2,fp
 82088c4:	d9003317 	ldw	r4,204(sp)
 82088c8:	e0c7883a 	add	r3,fp,r3
 82088cc:	df003a15 	stw	fp,232(sp)
 82088d0:	d8c02e15 	stw	r3,184(sp)
 82088d4:	00800044 	movi	r2,1
 82088d8:	1100b30e 	bge	r2,r4,8208ba8 <___vfprintf_internal_r+0x2110>
 82088dc:	d8c02e17 	ldw	r3,184(sp)
 82088e0:	18c00044 	addi	r3,r3,1
 82088e4:	d8c02e15 	stw	r3,184(sp)
 82088e8:	1805883a 	mov	r2,r3
 82088ec:	1800ac16 	blt	r3,zero,8208ba0 <___vfprintf_internal_r+0x2108>
 82088f0:	d8003215 	stw	zero,200(sp)
 82088f4:	003e5d06 	br	820826c <___vfprintf_internal_r+0x17d4>
 82088f8:	d9002c17 	ldw	r4,176(sp)
 82088fc:	d9801e04 	addi	r6,sp,120
 8208900:	b80b883a 	mov	r5,r23
 8208904:	820f5ec0 	call	820f5ec <__sprint_r>
 8208908:	1039651e 	bne	r2,zero,8206ea0 <___vfprintf_internal_r+0x408>
 820890c:	dc402617 	ldw	r17,152(sp)
 8208910:	d8c02017 	ldw	r3,128(sp)
 8208914:	d8801f17 	ldw	r2,124(sp)
 8208918:	da000404 	addi	r8,sp,16
 820891c:	003ed606 	br	8208478 <___vfprintf_internal_r+0x19e0>
 8208920:	582b883a 	mov	r21,r11
 8208924:	d8002915 	stw	zero,164(sp)
 8208928:	0038bd06 	br	8206c20 <___vfprintf_internal_r+0x188>
 820892c:	d8802917 	ldw	r2,164(sp)
 8208930:	103e071e 	bne	r2,zero,8208150 <___vfprintf_internal_r+0x16b8>
 8208934:	dc002915 	stw	r16,164(sp)
 8208938:	003e0506 	br	8208150 <___vfprintf_internal_r+0x16b8>
 820893c:	d9002917 	ldw	r4,164(sp)
 8208940:	20c00044 	addi	r3,r4,1
 8208944:	003e0f06 	br	8208184 <___vfprintf_internal_r+0x16ec>
 8208948:	01400184 	movi	r5,6
 820894c:	d9402915 	stw	r5,164(sp)
 8208950:	003dff06 	br	8208150 <___vfprintf_internal_r+0x16b8>
 8208954:	d8802104 	addi	r2,sp,132
 8208958:	d8800315 	stw	r2,12(sp)
 820895c:	d8802504 	addi	r2,sp,148
 8208960:	d8800215 	stw	r2,8(sp)
 8208964:	d8802604 	addi	r2,sp,152
 8208968:	d8800115 	stw	r2,4(sp)
 820896c:	d8802917 	ldw	r2,164(sp)
 8208970:	d9403617 	ldw	r5,216(sp)
 8208974:	d9002c17 	ldw	r4,176(sp)
 8208978:	d8800015 	stw	r2,0(sp)
 820897c:	01c000c4 	movi	r7,3
 8208980:	980d883a 	mov	r6,r19
 8208984:	da003d15 	stw	r8,244(sp)
 8208988:	82092140 	call	8209214 <_dtoa_r>
 820898c:	d8c02917 	ldw	r3,164(sp)
 8208990:	da003d17 	ldw	r8,244(sp)
 8208994:	1021883a 	mov	r16,r2
 8208998:	10f9883a 	add	fp,r2,r3
 820899c:	81000007 	ldb	r4,0(r16)
 82089a0:	00800c04 	movi	r2,48
 82089a4:	20805e26 	beq	r4,r2,8208b20 <___vfprintf_internal_r+0x2088>
 82089a8:	d8c02617 	ldw	r3,152(sp)
 82089ac:	e0f9883a 	add	fp,fp,r3
 82089b0:	003e0a06 	br	82081dc <___vfprintf_internal_r+0x1744>
 82089b4:	00c00b44 	movi	r3,45
 82089b8:	24e0003c 	xorhi	r19,r4,32768
 82089bc:	d8c02a05 	stb	r3,168(sp)
 82089c0:	003de906 	br	8208168 <___vfprintf_internal_r+0x16d0>
 82089c4:	d8c03217 	ldw	r3,200(sp)
 82089c8:	00c07a0e 	bge	zero,r3,8208bb4 <___vfprintf_internal_r+0x211c>
 82089cc:	00800044 	movi	r2,1
 82089d0:	d9003317 	ldw	r4,204(sp)
 82089d4:	1105883a 	add	r2,r2,r4
 82089d8:	d8802e15 	stw	r2,184(sp)
 82089dc:	10004e16 	blt	r2,zero,8208b18 <___vfprintf_internal_r+0x2080>
 82089e0:	044019c4 	movi	r17,103
 82089e4:	003e2106 	br	820826c <___vfprintf_internal_r+0x17d4>
 82089e8:	d9002917 	ldw	r4,164(sp)
 82089ec:	d8802104 	addi	r2,sp,132
 82089f0:	d8800315 	stw	r2,12(sp)
 82089f4:	d9000015 	stw	r4,0(sp)
 82089f8:	d8802504 	addi	r2,sp,148
 82089fc:	d9403617 	ldw	r5,216(sp)
 8208a00:	d9002c17 	ldw	r4,176(sp)
 8208a04:	d8800215 	stw	r2,8(sp)
 8208a08:	d8802604 	addi	r2,sp,152
 8208a0c:	d8800115 	stw	r2,4(sp)
 8208a10:	01c000c4 	movi	r7,3
 8208a14:	980d883a 	mov	r6,r19
 8208a18:	da003d15 	stw	r8,244(sp)
 8208a1c:	82092140 	call	8209214 <_dtoa_r>
 8208a20:	d8c02917 	ldw	r3,164(sp)
 8208a24:	da003d17 	ldw	r8,244(sp)
 8208a28:	1021883a 	mov	r16,r2
 8208a2c:	00801184 	movi	r2,70
 8208a30:	80f9883a 	add	fp,r16,r3
 8208a34:	88bfd926 	beq	r17,r2,820899c <___vfprintf_internal_r+0x1f04>
 8208a38:	003de806 	br	82081dc <___vfprintf_internal_r+0x1744>
 8208a3c:	d9002917 	ldw	r4,164(sp)
 8208a40:	00c04d0e 	bge	zero,r3,8208b78 <___vfprintf_internal_r+0x20e0>
 8208a44:	2000441e 	bne	r4,zero,8208b58 <___vfprintf_internal_r+0x20c0>
 8208a48:	9480004c 	andi	r18,r18,1
 8208a4c:	9000421e 	bne	r18,zero,8208b58 <___vfprintf_internal_r+0x20c0>
 8208a50:	1805883a 	mov	r2,r3
 8208a54:	18007016 	blt	r3,zero,8208c18 <___vfprintf_internal_r+0x2180>
 8208a58:	d8c03217 	ldw	r3,200(sp)
 8208a5c:	d8c02e15 	stw	r3,184(sp)
 8208a60:	003e0206 	br	820826c <___vfprintf_internal_r+0x17d4>
 8208a64:	df0022c4 	addi	fp,sp,139
 8208a68:	dc002915 	stw	r16,164(sp)
 8208a6c:	4027883a 	mov	r19,r8
 8208a70:	e021883a 	mov	r16,fp
 8208a74:	b009883a 	mov	r4,r22
 8208a78:	01400284 	movi	r5,10
 8208a7c:	8202bf80 	call	8202bf8 <__modsi3>
 8208a80:	10800c04 	addi	r2,r2,48
 8208a84:	843fffc4 	addi	r16,r16,-1
 8208a88:	b009883a 	mov	r4,r22
 8208a8c:	01400284 	movi	r5,10
 8208a90:	80800005 	stb	r2,0(r16)
 8208a94:	8202b740 	call	8202b74 <__divsi3>
 8208a98:	102d883a 	mov	r22,r2
 8208a9c:	00800244 	movi	r2,9
 8208aa0:	15bff416 	blt	r2,r22,8208a74 <___vfprintf_internal_r+0x1fdc>
 8208aa4:	9811883a 	mov	r8,r19
 8208aa8:	b0800c04 	addi	r2,r22,48
 8208aac:	8027883a 	mov	r19,r16
 8208ab0:	997fffc4 	addi	r5,r19,-1
 8208ab4:	98bfffc5 	stb	r2,-1(r19)
 8208ab8:	dc002917 	ldw	r16,164(sp)
 8208abc:	2f006a2e 	bgeu	r5,fp,8208c68 <___vfprintf_internal_r+0x21d0>
 8208ac0:	d9c02384 	addi	r7,sp,142
 8208ac4:	3ccfc83a 	sub	r7,r7,r19
 8208ac8:	d9002344 	addi	r4,sp,141
 8208acc:	e1cf883a 	add	r7,fp,r7
 8208ad0:	00000106 	br	8208ad8 <___vfprintf_internal_r+0x2040>
 8208ad4:	28800003 	ldbu	r2,0(r5)
 8208ad8:	20800005 	stb	r2,0(r4)
 8208adc:	21000044 	addi	r4,r4,1
 8208ae0:	29400044 	addi	r5,r5,1
 8208ae4:	393ffb1e 	bne	r7,r4,8208ad4 <___vfprintf_internal_r+0x203c>
 8208ae8:	d8802304 	addi	r2,sp,140
 8208aec:	14c5c83a 	sub	r2,r2,r19
 8208af0:	d8c02344 	addi	r3,sp,141
 8208af4:	1885883a 	add	r2,r3,r2
 8208af8:	003f7006 	br	82088bc <___vfprintf_internal_r+0x1e24>
 8208afc:	0005883a 	mov	r2,zero
 8208b00:	003f0f06 	br	8208740 <___vfprintf_internal_r+0x1ca8>
 8208b04:	d8c03217 	ldw	r3,200(sp)
 8208b08:	18c00044 	addi	r3,r3,1
 8208b0c:	d8c02e15 	stw	r3,184(sp)
 8208b10:	1805883a 	mov	r2,r3
 8208b14:	183fb20e 	bge	r3,zero,82089e0 <___vfprintf_internal_r+0x1f48>
 8208b18:	0005883a 	mov	r2,zero
 8208b1c:	003fb006 	br	82089e0 <___vfprintf_internal_r+0x1f48>
 8208b20:	d9003617 	ldw	r4,216(sp)
 8208b24:	000d883a 	mov	r6,zero
 8208b28:	000f883a 	mov	r7,zero
 8208b2c:	980b883a 	mov	r5,r19
 8208b30:	d8c03c15 	stw	r3,240(sp)
 8208b34:	da003d15 	stw	r8,244(sp)
 8208b38:	8212f580 	call	8212f58 <__eqdf2>
 8208b3c:	d8c03c17 	ldw	r3,240(sp)
 8208b40:	da003d17 	ldw	r8,244(sp)
 8208b44:	103f9826 	beq	r2,zero,82089a8 <___vfprintf_internal_r+0x1f10>
 8208b48:	00800044 	movi	r2,1
 8208b4c:	10c7c83a 	sub	r3,r2,r3
 8208b50:	d8c02615 	stw	r3,152(sp)
 8208b54:	003f9506 	br	82089ac <___vfprintf_internal_r+0x1f14>
 8208b58:	d9002917 	ldw	r4,164(sp)
 8208b5c:	d8c03217 	ldw	r3,200(sp)
 8208b60:	20800044 	addi	r2,r4,1
 8208b64:	1885883a 	add	r2,r3,r2
 8208b68:	d8802e15 	stw	r2,184(sp)
 8208b6c:	103dbf0e 	bge	r2,zero,820826c <___vfprintf_internal_r+0x17d4>
 8208b70:	0005883a 	mov	r2,zero
 8208b74:	003dbd06 	br	820826c <___vfprintf_internal_r+0x17d4>
 8208b78:	2000211e 	bne	r4,zero,8208c00 <___vfprintf_internal_r+0x2168>
 8208b7c:	9480004c 	andi	r18,r18,1
 8208b80:	90001f1e 	bne	r18,zero,8208c00 <___vfprintf_internal_r+0x2168>
 8208b84:	00800044 	movi	r2,1
 8208b88:	d8802e15 	stw	r2,184(sp)
 8208b8c:	003db706 	br	820826c <___vfprintf_internal_r+0x17d4>
 8208b90:	00800b44 	movi	r2,45
 8208b94:	05adc83a 	sub	r22,zero,r22
 8208b98:	d8802305 	stb	r2,140(sp)
 8208b9c:	003f3f06 	br	820889c <___vfprintf_internal_r+0x1e04>
 8208ba0:	0005883a 	mov	r2,zero
 8208ba4:	003f5206 	br	82088f0 <___vfprintf_internal_r+0x1e58>
 8208ba8:	90a4703a 	and	r18,r18,r2
 8208bac:	903f4e26 	beq	r18,zero,82088e8 <___vfprintf_internal_r+0x1e50>
 8208bb0:	003f4a06 	br	82088dc <___vfprintf_internal_r+0x1e44>
 8208bb4:	00800084 	movi	r2,2
 8208bb8:	10c5c83a 	sub	r2,r2,r3
 8208bbc:	003f8406 	br	82089d0 <___vfprintf_internal_r+0x1f38>
 8208bc0:	d8802d17 	ldw	r2,180(sp)
 8208bc4:	d9002d17 	ldw	r4,180(sp)
 8208bc8:	ac400043 	ldbu	r17,1(r21)
 8208bcc:	10800017 	ldw	r2,0(r2)
 8208bd0:	582b883a 	mov	r21,r11
 8208bd4:	d8802915 	stw	r2,164(sp)
 8208bd8:	20800104 	addi	r2,r4,4
 8208bdc:	d9002917 	ldw	r4,164(sp)
 8208be0:	d8802d15 	stw	r2,180(sp)
 8208be4:	203e7a0e 	bge	r4,zero,82085d0 <___vfprintf_internal_r+0x1b38>
 8208be8:	8c403fcc 	andi	r17,r17,255
 8208bec:	00bfffc4 	movi	r2,-1
 8208bf0:	8c40201c 	xori	r17,r17,128
 8208bf4:	d8802915 	stw	r2,164(sp)
 8208bf8:	8c7fe004 	addi	r17,r17,-128
 8208bfc:	00380706 	br	8206c1c <___vfprintf_internal_r+0x184>
 8208c00:	d8c02917 	ldw	r3,164(sp)
 8208c04:	18c00084 	addi	r3,r3,2
 8208c08:	d8c02e15 	stw	r3,184(sp)
 8208c0c:	1805883a 	mov	r2,r3
 8208c10:	183d960e 	bge	r3,zero,820826c <___vfprintf_internal_r+0x17d4>
 8208c14:	003fd606 	br	8208b70 <___vfprintf_internal_r+0x20d8>
 8208c18:	0005883a 	mov	r2,zero
 8208c1c:	003f8e06 	br	8208a58 <___vfprintf_internal_r+0x1fc0>
 8208c20:	9080004c 	andi	r2,r18,1
 8208c24:	103f811e 	bne	r2,zero,8208a2c <___vfprintf_internal_r+0x1f94>
 8208c28:	d8802117 	ldw	r2,132(sp)
 8208c2c:	1405c83a 	sub	r2,r2,r16
 8208c30:	d8803315 	stw	r2,204(sp)
 8208c34:	b47ef326 	beq	r22,r17,8208804 <___vfprintf_internal_r+0x1d6c>
 8208c38:	dd802617 	ldw	r22,152(sp)
 8208c3c:	003f1106 	br	8208884 <___vfprintf_internal_r+0x1dec>
 8208c40:	d9c02785 	stb	r7,158(sp)
 8208c44:	00390406 	br	8207058 <___vfprintf_internal_r+0x5c0>
 8208c48:	d9c02785 	stb	r7,158(sp)
 8208c4c:	0038d306 	br	8206f9c <___vfprintf_internal_r+0x504>
 8208c50:	d9c02785 	stb	r7,158(sp)
 8208c54:	003a6106 	br	82075dc <___vfprintf_internal_r+0xb44>
 8208c58:	d9c02785 	stb	r7,158(sp)
 8208c5c:	003af806 	br	8207840 <___vfprintf_internal_r+0xda8>
 8208c60:	0005883a 	mov	r2,zero
 8208c64:	003d7e06 	br	8208260 <___vfprintf_internal_r+0x17c8>
 8208c68:	d8802344 	addi	r2,sp,141
 8208c6c:	003f1306 	br	82088bc <___vfprintf_internal_r+0x1e24>
 8208c70:	d9c02785 	stb	r7,158(sp)
 8208c74:	00392306 	br	8207104 <___vfprintf_internal_r+0x66c>
 8208c78:	d9c02785 	stb	r7,158(sp)
 8208c7c:	003aa906 	br	8207724 <___vfprintf_internal_r+0xc8c>
 8208c80:	d9c02785 	stb	r7,158(sp)
 8208c84:	003a3d06 	br	820757c <___vfprintf_internal_r+0xae4>
 8208c88:	d9c02785 	stb	r7,158(sp)
 8208c8c:	003aca06 	br	82077b8 <___vfprintf_internal_r+0xd20>

08208c90 <__vfprintf_internal>:
 8208c90:	00820974 	movhi	r2,2085
 8208c94:	108fbb04 	addi	r2,r2,16108
 8208c98:	300f883a 	mov	r7,r6
 8208c9c:	280d883a 	mov	r6,r5
 8208ca0:	200b883a 	mov	r5,r4
 8208ca4:	11000017 	ldw	r4,0(r2)
 8208ca8:	8206a981 	jmpi	8206a98 <___vfprintf_internal_r>

08208cac <__sbprintf>:
 8208cac:	2880030b 	ldhu	r2,12(r5)
 8208cb0:	2ac01917 	ldw	r11,100(r5)
 8208cb4:	2a80038b 	ldhu	r10,14(r5)
 8208cb8:	2a400717 	ldw	r9,28(r5)
 8208cbc:	2a000917 	ldw	r8,36(r5)
 8208cc0:	defee204 	addi	sp,sp,-1144
 8208cc4:	00c10004 	movi	r3,1024
 8208cc8:	dc011a15 	stw	r16,1128(sp)
 8208ccc:	10bfff4c 	andi	r2,r2,65533
 8208cd0:	2821883a 	mov	r16,r5
 8208cd4:	d8cb883a 	add	r5,sp,r3
 8208cd8:	dc811c15 	stw	r18,1136(sp)
 8208cdc:	dc411b15 	stw	r17,1132(sp)
 8208ce0:	dfc11d15 	stw	ra,1140(sp)
 8208ce4:	2025883a 	mov	r18,r4
 8208ce8:	d881030d 	sth	r2,1036(sp)
 8208cec:	dac11915 	stw	r11,1124(sp)
 8208cf0:	da81038d 	sth	r10,1038(sp)
 8208cf4:	da410715 	stw	r9,1052(sp)
 8208cf8:	da010915 	stw	r8,1060(sp)
 8208cfc:	dec10015 	stw	sp,1024(sp)
 8208d00:	dec10415 	stw	sp,1040(sp)
 8208d04:	d8c10215 	stw	r3,1032(sp)
 8208d08:	d8c10515 	stw	r3,1044(sp)
 8208d0c:	d8010615 	stw	zero,1048(sp)
 8208d10:	8206a980 	call	8206a98 <___vfprintf_internal_r>
 8208d14:	1023883a 	mov	r17,r2
 8208d18:	10000416 	blt	r2,zero,8208d2c <__sbprintf+0x80>
 8208d1c:	d9410004 	addi	r5,sp,1024
 8208d20:	9009883a 	mov	r4,r18
 8208d24:	820aab80 	call	820aab8 <_fflush_r>
 8208d28:	10000d1e 	bne	r2,zero,8208d60 <__sbprintf+0xb4>
 8208d2c:	d881030b 	ldhu	r2,1036(sp)
 8208d30:	1080100c 	andi	r2,r2,64
 8208d34:	10000326 	beq	r2,zero,8208d44 <__sbprintf+0x98>
 8208d38:	8080030b 	ldhu	r2,12(r16)
 8208d3c:	10801014 	ori	r2,r2,64
 8208d40:	8080030d 	sth	r2,12(r16)
 8208d44:	8805883a 	mov	r2,r17
 8208d48:	dfc11d17 	ldw	ra,1140(sp)
 8208d4c:	dc811c17 	ldw	r18,1136(sp)
 8208d50:	dc411b17 	ldw	r17,1132(sp)
 8208d54:	dc011a17 	ldw	r16,1128(sp)
 8208d58:	dec11e04 	addi	sp,sp,1144
 8208d5c:	f800283a 	ret
 8208d60:	047fffc4 	movi	r17,-1
 8208d64:	003ff106 	br	8208d2c <__sbprintf+0x80>

08208d68 <__swbuf_r>:
 8208d68:	defffb04 	addi	sp,sp,-20
 8208d6c:	dcc00315 	stw	r19,12(sp)
 8208d70:	dc800215 	stw	r18,8(sp)
 8208d74:	dc000015 	stw	r16,0(sp)
 8208d78:	dfc00415 	stw	ra,16(sp)
 8208d7c:	dc400115 	stw	r17,4(sp)
 8208d80:	2025883a 	mov	r18,r4
 8208d84:	2827883a 	mov	r19,r5
 8208d88:	3021883a 	mov	r16,r6
 8208d8c:	20000226 	beq	r4,zero,8208d98 <__swbuf_r+0x30>
 8208d90:	20800e17 	ldw	r2,56(r4)
 8208d94:	10004226 	beq	r2,zero,8208ea0 <__swbuf_r+0x138>
 8208d98:	80800617 	ldw	r2,24(r16)
 8208d9c:	8100030b 	ldhu	r4,12(r16)
 8208da0:	80800215 	stw	r2,8(r16)
 8208da4:	2080020c 	andi	r2,r4,8
 8208da8:	10003626 	beq	r2,zero,8208e84 <__swbuf_r+0x11c>
 8208dac:	80c00417 	ldw	r3,16(r16)
 8208db0:	18003426 	beq	r3,zero,8208e84 <__swbuf_r+0x11c>
 8208db4:	2088000c 	andi	r2,r4,8192
 8208db8:	9c403fcc 	andi	r17,r19,255
 8208dbc:	10001a26 	beq	r2,zero,8208e28 <__swbuf_r+0xc0>
 8208dc0:	80800017 	ldw	r2,0(r16)
 8208dc4:	81000517 	ldw	r4,20(r16)
 8208dc8:	10c7c83a 	sub	r3,r2,r3
 8208dcc:	1900200e 	bge	r3,r4,8208e50 <__swbuf_r+0xe8>
 8208dd0:	18c00044 	addi	r3,r3,1
 8208dd4:	81000217 	ldw	r4,8(r16)
 8208dd8:	11400044 	addi	r5,r2,1
 8208ddc:	81400015 	stw	r5,0(r16)
 8208de0:	213fffc4 	addi	r4,r4,-1
 8208de4:	81000215 	stw	r4,8(r16)
 8208de8:	14c00005 	stb	r19,0(r2)
 8208dec:	80800517 	ldw	r2,20(r16)
 8208df0:	10c01e26 	beq	r2,r3,8208e6c <__swbuf_r+0x104>
 8208df4:	8080030b 	ldhu	r2,12(r16)
 8208df8:	1080004c 	andi	r2,r2,1
 8208dfc:	10000226 	beq	r2,zero,8208e08 <__swbuf_r+0xa0>
 8208e00:	00800284 	movi	r2,10
 8208e04:	88801926 	beq	r17,r2,8208e6c <__swbuf_r+0x104>
 8208e08:	8805883a 	mov	r2,r17
 8208e0c:	dfc00417 	ldw	ra,16(sp)
 8208e10:	dcc00317 	ldw	r19,12(sp)
 8208e14:	dc800217 	ldw	r18,8(sp)
 8208e18:	dc400117 	ldw	r17,4(sp)
 8208e1c:	dc000017 	ldw	r16,0(sp)
 8208e20:	dec00504 	addi	sp,sp,20
 8208e24:	f800283a 	ret
 8208e28:	81401917 	ldw	r5,100(r16)
 8208e2c:	00b7ffc4 	movi	r2,-8193
 8208e30:	21080014 	ori	r4,r4,8192
 8208e34:	2884703a 	and	r2,r5,r2
 8208e38:	80801915 	stw	r2,100(r16)
 8208e3c:	80800017 	ldw	r2,0(r16)
 8208e40:	8100030d 	sth	r4,12(r16)
 8208e44:	81000517 	ldw	r4,20(r16)
 8208e48:	10c7c83a 	sub	r3,r2,r3
 8208e4c:	193fe016 	blt	r3,r4,8208dd0 <__swbuf_r+0x68>
 8208e50:	800b883a 	mov	r5,r16
 8208e54:	9009883a 	mov	r4,r18
 8208e58:	820aab80 	call	820aab8 <_fflush_r>
 8208e5c:	1000071e 	bne	r2,zero,8208e7c <__swbuf_r+0x114>
 8208e60:	80800017 	ldw	r2,0(r16)
 8208e64:	00c00044 	movi	r3,1
 8208e68:	003fda06 	br	8208dd4 <__swbuf_r+0x6c>
 8208e6c:	800b883a 	mov	r5,r16
 8208e70:	9009883a 	mov	r4,r18
 8208e74:	820aab80 	call	820aab8 <_fflush_r>
 8208e78:	103fe326 	beq	r2,zero,8208e08 <__swbuf_r+0xa0>
 8208e7c:	00bfffc4 	movi	r2,-1
 8208e80:	003fe206 	br	8208e0c <__swbuf_r+0xa4>
 8208e84:	800b883a 	mov	r5,r16
 8208e88:	9009883a 	mov	r4,r18
 8208e8c:	8208ec00 	call	8208ec0 <__swsetup_r>
 8208e90:	103ffa1e 	bne	r2,zero,8208e7c <__swbuf_r+0x114>
 8208e94:	8100030b 	ldhu	r4,12(r16)
 8208e98:	80c00417 	ldw	r3,16(r16)
 8208e9c:	003fc506 	br	8208db4 <__swbuf_r+0x4c>
 8208ea0:	820ae940 	call	820ae94 <__sinit>
 8208ea4:	003fbc06 	br	8208d98 <__swbuf_r+0x30>

08208ea8 <__swbuf>:
 8208ea8:	00820974 	movhi	r2,2085
 8208eac:	108fbb04 	addi	r2,r2,16108
 8208eb0:	280d883a 	mov	r6,r5
 8208eb4:	200b883a 	mov	r5,r4
 8208eb8:	11000017 	ldw	r4,0(r2)
 8208ebc:	8208d681 	jmpi	8208d68 <__swbuf_r>

08208ec0 <__swsetup_r>:
 8208ec0:	00820974 	movhi	r2,2085
 8208ec4:	defffd04 	addi	sp,sp,-12
 8208ec8:	108fbb04 	addi	r2,r2,16108
 8208ecc:	dc400115 	stw	r17,4(sp)
 8208ed0:	2023883a 	mov	r17,r4
 8208ed4:	11000017 	ldw	r4,0(r2)
 8208ed8:	dc000015 	stw	r16,0(sp)
 8208edc:	dfc00215 	stw	ra,8(sp)
 8208ee0:	2821883a 	mov	r16,r5
 8208ee4:	20000226 	beq	r4,zero,8208ef0 <__swsetup_r+0x30>
 8208ee8:	20800e17 	ldw	r2,56(r4)
 8208eec:	10003126 	beq	r2,zero,8208fb4 <__swsetup_r+0xf4>
 8208ef0:	8080030b 	ldhu	r2,12(r16)
 8208ef4:	10c0020c 	andi	r3,r2,8
 8208ef8:	1009883a 	mov	r4,r2
 8208efc:	18000f26 	beq	r3,zero,8208f3c <__swsetup_r+0x7c>
 8208f00:	80c00417 	ldw	r3,16(r16)
 8208f04:	18001526 	beq	r3,zero,8208f5c <__swsetup_r+0x9c>
 8208f08:	1100004c 	andi	r4,r2,1
 8208f0c:	20001c1e 	bne	r4,zero,8208f80 <__swsetup_r+0xc0>
 8208f10:	1080008c 	andi	r2,r2,2
 8208f14:	1000291e 	bne	r2,zero,8208fbc <__swsetup_r+0xfc>
 8208f18:	80800517 	ldw	r2,20(r16)
 8208f1c:	80800215 	stw	r2,8(r16)
 8208f20:	18001c26 	beq	r3,zero,8208f94 <__swsetup_r+0xd4>
 8208f24:	0005883a 	mov	r2,zero
 8208f28:	dfc00217 	ldw	ra,8(sp)
 8208f2c:	dc400117 	ldw	r17,4(sp)
 8208f30:	dc000017 	ldw	r16,0(sp)
 8208f34:	dec00304 	addi	sp,sp,12
 8208f38:	f800283a 	ret
 8208f3c:	2080040c 	andi	r2,r4,16
 8208f40:	10002e26 	beq	r2,zero,8208ffc <__swsetup_r+0x13c>
 8208f44:	2080010c 	andi	r2,r4,4
 8208f48:	10001e1e 	bne	r2,zero,8208fc4 <__swsetup_r+0x104>
 8208f4c:	80c00417 	ldw	r3,16(r16)
 8208f50:	20800214 	ori	r2,r4,8
 8208f54:	8080030d 	sth	r2,12(r16)
 8208f58:	183feb1e 	bne	r3,zero,8208f08 <__swsetup_r+0x48>
 8208f5c:	1100a00c 	andi	r4,r2,640
 8208f60:	01408004 	movi	r5,512
 8208f64:	217fe826 	beq	r4,r5,8208f08 <__swsetup_r+0x48>
 8208f68:	800b883a 	mov	r5,r16
 8208f6c:	8809883a 	mov	r4,r17
 8208f70:	820bb8c0 	call	820bb8c <__smakebuf_r>
 8208f74:	8080030b 	ldhu	r2,12(r16)
 8208f78:	80c00417 	ldw	r3,16(r16)
 8208f7c:	003fe206 	br	8208f08 <__swsetup_r+0x48>
 8208f80:	80800517 	ldw	r2,20(r16)
 8208f84:	80000215 	stw	zero,8(r16)
 8208f88:	0085c83a 	sub	r2,zero,r2
 8208f8c:	80800615 	stw	r2,24(r16)
 8208f90:	183fe41e 	bne	r3,zero,8208f24 <__swsetup_r+0x64>
 8208f94:	80c0030b 	ldhu	r3,12(r16)
 8208f98:	0005883a 	mov	r2,zero
 8208f9c:	1900200c 	andi	r4,r3,128
 8208fa0:	203fe126 	beq	r4,zero,8208f28 <__swsetup_r+0x68>
 8208fa4:	18c01014 	ori	r3,r3,64
 8208fa8:	80c0030d 	sth	r3,12(r16)
 8208fac:	00bfffc4 	movi	r2,-1
 8208fb0:	003fdd06 	br	8208f28 <__swsetup_r+0x68>
 8208fb4:	820ae940 	call	820ae94 <__sinit>
 8208fb8:	003fcd06 	br	8208ef0 <__swsetup_r+0x30>
 8208fbc:	0005883a 	mov	r2,zero
 8208fc0:	003fd606 	br	8208f1c <__swsetup_r+0x5c>
 8208fc4:	81400c17 	ldw	r5,48(r16)
 8208fc8:	28000626 	beq	r5,zero,8208fe4 <__swsetup_r+0x124>
 8208fcc:	80801004 	addi	r2,r16,64
 8208fd0:	28800326 	beq	r5,r2,8208fe0 <__swsetup_r+0x120>
 8208fd4:	8809883a 	mov	r4,r17
 8208fd8:	820b15c0 	call	820b15c <_free_r>
 8208fdc:	8100030b 	ldhu	r4,12(r16)
 8208fe0:	80000c15 	stw	zero,48(r16)
 8208fe4:	80c00417 	ldw	r3,16(r16)
 8208fe8:	00bff6c4 	movi	r2,-37
 8208fec:	1108703a 	and	r4,r2,r4
 8208ff0:	80000115 	stw	zero,4(r16)
 8208ff4:	80c00015 	stw	r3,0(r16)
 8208ff8:	003fd506 	br	8208f50 <__swsetup_r+0x90>
 8208ffc:	00800244 	movi	r2,9
 8209000:	88800015 	stw	r2,0(r17)
 8209004:	20801014 	ori	r2,r4,64
 8209008:	8080030d 	sth	r2,12(r16)
 820900c:	00bfffc4 	movi	r2,-1
 8209010:	003fc506 	br	8208f28 <__swsetup_r+0x68>

08209014 <quorem>:
 8209014:	defff704 	addi	sp,sp,-36
 8209018:	dc800215 	stw	r18,8(sp)
 820901c:	20800417 	ldw	r2,16(r4)
 8209020:	2c800417 	ldw	r18,16(r5)
 8209024:	dfc00815 	stw	ra,32(sp)
 8209028:	ddc00715 	stw	r23,28(sp)
 820902c:	dd800615 	stw	r22,24(sp)
 8209030:	dd400515 	stw	r21,20(sp)
 8209034:	dd000415 	stw	r20,16(sp)
 8209038:	dcc00315 	stw	r19,12(sp)
 820903c:	dc400115 	stw	r17,4(sp)
 8209040:	dc000015 	stw	r16,0(sp)
 8209044:	14807116 	blt	r2,r18,820920c <quorem+0x1f8>
 8209048:	94bfffc4 	addi	r18,r18,-1
 820904c:	94ad883a 	add	r22,r18,r18
 8209050:	b5ad883a 	add	r22,r22,r22
 8209054:	2c400504 	addi	r17,r5,20
 8209058:	8da9883a 	add	r20,r17,r22
 820905c:	25400504 	addi	r21,r4,20
 8209060:	282f883a 	mov	r23,r5
 8209064:	adad883a 	add	r22,r21,r22
 8209068:	a1400017 	ldw	r5,0(r20)
 820906c:	2021883a 	mov	r16,r4
 8209070:	b1000017 	ldw	r4,0(r22)
 8209074:	29400044 	addi	r5,r5,1
 8209078:	8202c6c0 	call	8202c6c <__udivsi3>
 820907c:	1027883a 	mov	r19,r2
 8209080:	10002c26 	beq	r2,zero,8209134 <quorem+0x120>
 8209084:	a813883a 	mov	r9,r21
 8209088:	880b883a 	mov	r5,r17
 820908c:	0009883a 	mov	r4,zero
 8209090:	000d883a 	mov	r6,zero
 8209094:	2a000017 	ldw	r8,0(r5)
 8209098:	49c00017 	ldw	r7,0(r9)
 820909c:	29400104 	addi	r5,r5,4
 82090a0:	40bfffcc 	andi	r2,r8,65535
 82090a4:	14c5383a 	mul	r2,r2,r19
 82090a8:	4010d43a 	srli	r8,r8,16
 82090ac:	38ffffcc 	andi	r3,r7,65535
 82090b0:	1105883a 	add	r2,r2,r4
 82090b4:	1008d43a 	srli	r4,r2,16
 82090b8:	44d1383a 	mul	r8,r8,r19
 82090bc:	198d883a 	add	r6,r3,r6
 82090c0:	10ffffcc 	andi	r3,r2,65535
 82090c4:	30c7c83a 	sub	r3,r6,r3
 82090c8:	380ed43a 	srli	r7,r7,16
 82090cc:	4105883a 	add	r2,r8,r4
 82090d0:	180dd43a 	srai	r6,r3,16
 82090d4:	113fffcc 	andi	r4,r2,65535
 82090d8:	390fc83a 	sub	r7,r7,r4
 82090dc:	398d883a 	add	r6,r7,r6
 82090e0:	300e943a 	slli	r7,r6,16
 82090e4:	18ffffcc 	andi	r3,r3,65535
 82090e8:	1008d43a 	srli	r4,r2,16
 82090ec:	38ceb03a 	or	r7,r7,r3
 82090f0:	49c00015 	stw	r7,0(r9)
 82090f4:	300dd43a 	srai	r6,r6,16
 82090f8:	4a400104 	addi	r9,r9,4
 82090fc:	a17fe52e 	bgeu	r20,r5,8209094 <quorem+0x80>
 8209100:	b0800017 	ldw	r2,0(r22)
 8209104:	10000b1e 	bne	r2,zero,8209134 <quorem+0x120>
 8209108:	b0bfff04 	addi	r2,r22,-4
 820910c:	a880082e 	bgeu	r21,r2,8209130 <quorem+0x11c>
 8209110:	b0ffff17 	ldw	r3,-4(r22)
 8209114:	18000326 	beq	r3,zero,8209124 <quorem+0x110>
 8209118:	00000506 	br	8209130 <quorem+0x11c>
 820911c:	10c00017 	ldw	r3,0(r2)
 8209120:	1800031e 	bne	r3,zero,8209130 <quorem+0x11c>
 8209124:	10bfff04 	addi	r2,r2,-4
 8209128:	94bfffc4 	addi	r18,r18,-1
 820912c:	a8bffb36 	bltu	r21,r2,820911c <quorem+0x108>
 8209130:	84800415 	stw	r18,16(r16)
 8209134:	b80b883a 	mov	r5,r23
 8209138:	8009883a 	mov	r4,r16
 820913c:	820cf7c0 	call	820cf7c <__mcmp>
 8209140:	10002616 	blt	r2,zero,82091dc <quorem+0x1c8>
 8209144:	9cc00044 	addi	r19,r19,1
 8209148:	a805883a 	mov	r2,r21
 820914c:	000b883a 	mov	r5,zero
 8209150:	11000017 	ldw	r4,0(r2)
 8209154:	89800017 	ldw	r6,0(r17)
 8209158:	10800104 	addi	r2,r2,4
 820915c:	20ffffcc 	andi	r3,r4,65535
 8209160:	194b883a 	add	r5,r3,r5
 8209164:	30ffffcc 	andi	r3,r6,65535
 8209168:	28c7c83a 	sub	r3,r5,r3
 820916c:	300cd43a 	srli	r6,r6,16
 8209170:	2008d43a 	srli	r4,r4,16
 8209174:	180bd43a 	srai	r5,r3,16
 8209178:	18ffffcc 	andi	r3,r3,65535
 820917c:	2189c83a 	sub	r4,r4,r6
 8209180:	2149883a 	add	r4,r4,r5
 8209184:	200c943a 	slli	r6,r4,16
 8209188:	8c400104 	addi	r17,r17,4
 820918c:	200bd43a 	srai	r5,r4,16
 8209190:	30c6b03a 	or	r3,r6,r3
 8209194:	10ffff15 	stw	r3,-4(r2)
 8209198:	a47fed2e 	bgeu	r20,r17,8209150 <quorem+0x13c>
 820919c:	9485883a 	add	r2,r18,r18
 82091a0:	1085883a 	add	r2,r2,r2
 82091a4:	a887883a 	add	r3,r21,r2
 82091a8:	18800017 	ldw	r2,0(r3)
 82091ac:	10000b1e 	bne	r2,zero,82091dc <quorem+0x1c8>
 82091b0:	18bfff04 	addi	r2,r3,-4
 82091b4:	a880082e 	bgeu	r21,r2,82091d8 <quorem+0x1c4>
 82091b8:	18ffff17 	ldw	r3,-4(r3)
 82091bc:	18000326 	beq	r3,zero,82091cc <quorem+0x1b8>
 82091c0:	00000506 	br	82091d8 <quorem+0x1c4>
 82091c4:	10c00017 	ldw	r3,0(r2)
 82091c8:	1800031e 	bne	r3,zero,82091d8 <quorem+0x1c4>
 82091cc:	10bfff04 	addi	r2,r2,-4
 82091d0:	94bfffc4 	addi	r18,r18,-1
 82091d4:	a8bffb36 	bltu	r21,r2,82091c4 <quorem+0x1b0>
 82091d8:	84800415 	stw	r18,16(r16)
 82091dc:	9805883a 	mov	r2,r19
 82091e0:	dfc00817 	ldw	ra,32(sp)
 82091e4:	ddc00717 	ldw	r23,28(sp)
 82091e8:	dd800617 	ldw	r22,24(sp)
 82091ec:	dd400517 	ldw	r21,20(sp)
 82091f0:	dd000417 	ldw	r20,16(sp)
 82091f4:	dcc00317 	ldw	r19,12(sp)
 82091f8:	dc800217 	ldw	r18,8(sp)
 82091fc:	dc400117 	ldw	r17,4(sp)
 8209200:	dc000017 	ldw	r16,0(sp)
 8209204:	dec00904 	addi	sp,sp,36
 8209208:	f800283a 	ret
 820920c:	0005883a 	mov	r2,zero
 8209210:	003ff306 	br	82091e0 <quorem+0x1cc>

08209214 <_dtoa_r>:
 8209214:	20801017 	ldw	r2,64(r4)
 8209218:	deffde04 	addi	sp,sp,-136
 820921c:	df002015 	stw	fp,128(sp)
 8209220:	dcc01b15 	stw	r19,108(sp)
 8209224:	dc801a15 	stw	r18,104(sp)
 8209228:	dc401915 	stw	r17,100(sp)
 820922c:	dc001815 	stw	r16,96(sp)
 8209230:	dfc02115 	stw	ra,132(sp)
 8209234:	ddc01f15 	stw	r23,124(sp)
 8209238:	dd801e15 	stw	r22,120(sp)
 820923c:	dd401d15 	stw	r21,116(sp)
 8209240:	dd001c15 	stw	r20,112(sp)
 8209244:	d9c00315 	stw	r7,12(sp)
 8209248:	2039883a 	mov	fp,r4
 820924c:	3023883a 	mov	r17,r6
 8209250:	2825883a 	mov	r18,r5
 8209254:	dc002417 	ldw	r16,144(sp)
 8209258:	3027883a 	mov	r19,r6
 820925c:	10000826 	beq	r2,zero,8209280 <_dtoa_r+0x6c>
 8209260:	21801117 	ldw	r6,68(r4)
 8209264:	00c00044 	movi	r3,1
 8209268:	100b883a 	mov	r5,r2
 820926c:	1986983a 	sll	r3,r3,r6
 8209270:	11800115 	stw	r6,4(r2)
 8209274:	10c00215 	stw	r3,8(r2)
 8209278:	820c75c0 	call	820c75c <_Bfree>
 820927c:	e0001015 	stw	zero,64(fp)
 8209280:	88002e16 	blt	r17,zero,820933c <_dtoa_r+0x128>
 8209284:	80000015 	stw	zero,0(r16)
 8209288:	889ffc2c 	andhi	r2,r17,32752
 820928c:	00dffc34 	movhi	r3,32752
 8209290:	10c01c26 	beq	r2,r3,8209304 <_dtoa_r+0xf0>
 8209294:	000d883a 	mov	r6,zero
 8209298:	000f883a 	mov	r7,zero
 820929c:	9009883a 	mov	r4,r18
 82092a0:	980b883a 	mov	r5,r19
 82092a4:	8212f580 	call	8212f58 <__eqdf2>
 82092a8:	10002b1e 	bne	r2,zero,8209358 <_dtoa_r+0x144>
 82092ac:	d9c02317 	ldw	r7,140(sp)
 82092b0:	00800044 	movi	r2,1
 82092b4:	38800015 	stw	r2,0(r7)
 82092b8:	d8802517 	ldw	r2,148(sp)
 82092bc:	10019e26 	beq	r2,zero,8209938 <_dtoa_r+0x724>
 82092c0:	d8c02517 	ldw	r3,148(sp)
 82092c4:	00820974 	movhi	r2,2085
 82092c8:	10b6ec44 	addi	r2,r2,-9295
 82092cc:	18800015 	stw	r2,0(r3)
 82092d0:	10bfffc4 	addi	r2,r2,-1
 82092d4:	dfc02117 	ldw	ra,132(sp)
 82092d8:	df002017 	ldw	fp,128(sp)
 82092dc:	ddc01f17 	ldw	r23,124(sp)
 82092e0:	dd801e17 	ldw	r22,120(sp)
 82092e4:	dd401d17 	ldw	r21,116(sp)
 82092e8:	dd001c17 	ldw	r20,112(sp)
 82092ec:	dcc01b17 	ldw	r19,108(sp)
 82092f0:	dc801a17 	ldw	r18,104(sp)
 82092f4:	dc401917 	ldw	r17,100(sp)
 82092f8:	dc001817 	ldw	r16,96(sp)
 82092fc:	dec02204 	addi	sp,sp,136
 8209300:	f800283a 	ret
 8209304:	d8c02317 	ldw	r3,140(sp)
 8209308:	0089c3c4 	movi	r2,9999
 820930c:	18800015 	stw	r2,0(r3)
 8209310:	90017726 	beq	r18,zero,82098f0 <_dtoa_r+0x6dc>
 8209314:	00820974 	movhi	r2,2085
 8209318:	10b70004 	addi	r2,r2,-9216
 820931c:	d9002517 	ldw	r4,148(sp)
 8209320:	203fec26 	beq	r4,zero,82092d4 <_dtoa_r+0xc0>
 8209324:	10c000c7 	ldb	r3,3(r2)
 8209328:	1801781e 	bne	r3,zero,820990c <_dtoa_r+0x6f8>
 820932c:	10c000c4 	addi	r3,r2,3
 8209330:	d9802517 	ldw	r6,148(sp)
 8209334:	30c00015 	stw	r3,0(r6)
 8209338:	003fe606 	br	82092d4 <_dtoa_r+0xc0>
 820933c:	04e00034 	movhi	r19,32768
 8209340:	9cffffc4 	addi	r19,r19,-1
 8209344:	00800044 	movi	r2,1
 8209348:	8ce6703a 	and	r19,r17,r19
 820934c:	80800015 	stw	r2,0(r16)
 8209350:	9823883a 	mov	r17,r19
 8209354:	003fcc06 	br	8209288 <_dtoa_r+0x74>
 8209358:	d8800204 	addi	r2,sp,8
 820935c:	d8800015 	stw	r2,0(sp)
 8209360:	d9c00104 	addi	r7,sp,4
 8209364:	900b883a 	mov	r5,r18
 8209368:	980d883a 	mov	r6,r19
 820936c:	e009883a 	mov	r4,fp
 8209370:	8820d53a 	srli	r16,r17,20
 8209374:	820d3480 	call	820d348 <__d2b>
 8209378:	d8800915 	stw	r2,36(sp)
 820937c:	8001651e 	bne	r16,zero,8209914 <_dtoa_r+0x700>
 8209380:	dd800217 	ldw	r22,8(sp)
 8209384:	dc000117 	ldw	r16,4(sp)
 8209388:	00800804 	movi	r2,32
 820938c:	b421883a 	add	r16,r22,r16
 8209390:	80c10c84 	addi	r3,r16,1074
 8209394:	10c2d10e 	bge	r2,r3,8209edc <_dtoa_r+0xcc8>
 8209398:	00801004 	movi	r2,64
 820939c:	81010484 	addi	r4,r16,1042
 82093a0:	10c7c83a 	sub	r3,r2,r3
 82093a4:	9108d83a 	srl	r4,r18,r4
 82093a8:	88e2983a 	sll	r17,r17,r3
 82093ac:	2448b03a 	or	r4,r4,r17
 82093b0:	82143200 	call	8214320 <__floatunsidf>
 82093b4:	017f8434 	movhi	r5,65040
 82093b8:	01800044 	movi	r6,1
 82093bc:	1009883a 	mov	r4,r2
 82093c0:	194b883a 	add	r5,r3,r5
 82093c4:	843fffc4 	addi	r16,r16,-1
 82093c8:	d9801115 	stw	r6,68(sp)
 82093cc:	000d883a 	mov	r6,zero
 82093d0:	01cffe34 	movhi	r7,16376
 82093d4:	82138c80 	call	82138c8 <__subdf3>
 82093d8:	0198dbf4 	movhi	r6,25455
 82093dc:	01cff4f4 	movhi	r7,16339
 82093e0:	3190d844 	addi	r6,r6,17249
 82093e4:	39e1e9c4 	addi	r7,r7,-30809
 82093e8:	1009883a 	mov	r4,r2
 82093ec:	180b883a 	mov	r5,r3
 82093f0:	82131b00 	call	82131b0 <__muldf3>
 82093f4:	01a2d874 	movhi	r6,35681
 82093f8:	01cff1f4 	movhi	r7,16327
 82093fc:	31b22cc4 	addi	r6,r6,-14157
 8209400:	39e28a04 	addi	r7,r7,-30168
 8209404:	180b883a 	mov	r5,r3
 8209408:	1009883a 	mov	r4,r2
 820940c:	8211dc40 	call	8211dc4 <__adddf3>
 8209410:	8009883a 	mov	r4,r16
 8209414:	1029883a 	mov	r20,r2
 8209418:	1823883a 	mov	r17,r3
 820941c:	82142440 	call	8214244 <__floatsidf>
 8209420:	019427f4 	movhi	r6,20639
 8209424:	01cff4f4 	movhi	r7,16339
 8209428:	319e7ec4 	addi	r6,r6,31227
 820942c:	39d104c4 	addi	r7,r7,17427
 8209430:	1009883a 	mov	r4,r2
 8209434:	180b883a 	mov	r5,r3
 8209438:	82131b00 	call	82131b0 <__muldf3>
 820943c:	100d883a 	mov	r6,r2
 8209440:	180f883a 	mov	r7,r3
 8209444:	a009883a 	mov	r4,r20
 8209448:	880b883a 	mov	r5,r17
 820944c:	8211dc40 	call	8211dc4 <__adddf3>
 8209450:	1009883a 	mov	r4,r2
 8209454:	180b883a 	mov	r5,r3
 8209458:	1029883a 	mov	r20,r2
 820945c:	1823883a 	mov	r17,r3
 8209460:	82141c40 	call	82141c4 <__fixdfsi>
 8209464:	000d883a 	mov	r6,zero
 8209468:	000f883a 	mov	r7,zero
 820946c:	a009883a 	mov	r4,r20
 8209470:	880b883a 	mov	r5,r17
 8209474:	d8800515 	stw	r2,20(sp)
 8209478:	82130bc0 	call	82130bc <__ledf2>
 820947c:	10028716 	blt	r2,zero,8209e9c <_dtoa_r+0xc88>
 8209480:	d8c00517 	ldw	r3,20(sp)
 8209484:	00800584 	movi	r2,22
 8209488:	10c27536 	bltu	r2,r3,8209e60 <_dtoa_r+0xc4c>
 820948c:	180490fa 	slli	r2,r3,3
 8209490:	00c20974 	movhi	r3,2085
 8209494:	18f71b04 	addi	r3,r3,-9108
 8209498:	1885883a 	add	r2,r3,r2
 820949c:	11000017 	ldw	r4,0(r2)
 82094a0:	11400117 	ldw	r5,4(r2)
 82094a4:	900d883a 	mov	r6,r18
 82094a8:	980f883a 	mov	r7,r19
 82094ac:	8212fe00 	call	8212fe0 <__gedf2>
 82094b0:	00828d0e 	bge	zero,r2,8209ee8 <_dtoa_r+0xcd4>
 82094b4:	d9000517 	ldw	r4,20(sp)
 82094b8:	d8000e15 	stw	zero,56(sp)
 82094bc:	213fffc4 	addi	r4,r4,-1
 82094c0:	d9000515 	stw	r4,20(sp)
 82094c4:	b42dc83a 	sub	r22,r22,r16
 82094c8:	b5bfffc4 	addi	r22,r22,-1
 82094cc:	b0026f16 	blt	r22,zero,8209e8c <_dtoa_r+0xc78>
 82094d0:	d8000815 	stw	zero,32(sp)
 82094d4:	d9c00517 	ldw	r7,20(sp)
 82094d8:	38026416 	blt	r7,zero,8209e6c <_dtoa_r+0xc58>
 82094dc:	b1ed883a 	add	r22,r22,r7
 82094e0:	d9c00d15 	stw	r7,52(sp)
 82094e4:	d8000a15 	stw	zero,40(sp)
 82094e8:	d9800317 	ldw	r6,12(sp)
 82094ec:	00800244 	movi	r2,9
 82094f0:	11811436 	bltu	r2,r6,8209944 <_dtoa_r+0x730>
 82094f4:	00800144 	movi	r2,5
 82094f8:	1184e10e 	bge	r2,r6,820a880 <_dtoa_r+0x166c>
 82094fc:	31bfff04 	addi	r6,r6,-4
 8209500:	d9800315 	stw	r6,12(sp)
 8209504:	0023883a 	mov	r17,zero
 8209508:	d9800317 	ldw	r6,12(sp)
 820950c:	008000c4 	movi	r2,3
 8209510:	30836726 	beq	r6,r2,820a2b0 <_dtoa_r+0x109c>
 8209514:	1183410e 	bge	r2,r6,820a21c <_dtoa_r+0x1008>
 8209518:	d9c00317 	ldw	r7,12(sp)
 820951c:	00800104 	movi	r2,4
 8209520:	38827c26 	beq	r7,r2,8209f14 <_dtoa_r+0xd00>
 8209524:	00800144 	movi	r2,5
 8209528:	3884c41e 	bne	r7,r2,820a83c <_dtoa_r+0x1628>
 820952c:	00800044 	movi	r2,1
 8209530:	d8800b15 	stw	r2,44(sp)
 8209534:	d8c00517 	ldw	r3,20(sp)
 8209538:	d9002217 	ldw	r4,136(sp)
 820953c:	1907883a 	add	r3,r3,r4
 8209540:	19800044 	addi	r6,r3,1
 8209544:	d8c00c15 	stw	r3,48(sp)
 8209548:	d9800615 	stw	r6,24(sp)
 820954c:	0183a40e 	bge	zero,r6,820a3e0 <_dtoa_r+0x11cc>
 8209550:	d9800617 	ldw	r6,24(sp)
 8209554:	3021883a 	mov	r16,r6
 8209558:	e0001115 	stw	zero,68(fp)
 820955c:	008005c4 	movi	r2,23
 8209560:	1184c92e 	bgeu	r2,r6,820a888 <_dtoa_r+0x1674>
 8209564:	00c00044 	movi	r3,1
 8209568:	00800104 	movi	r2,4
 820956c:	1085883a 	add	r2,r2,r2
 8209570:	11000504 	addi	r4,r2,20
 8209574:	180b883a 	mov	r5,r3
 8209578:	18c00044 	addi	r3,r3,1
 820957c:	313ffb2e 	bgeu	r6,r4,820956c <_dtoa_r+0x358>
 8209580:	e1401115 	stw	r5,68(fp)
 8209584:	e009883a 	mov	r4,fp
 8209588:	820c6b40 	call	820c6b4 <_Balloc>
 820958c:	d8800715 	stw	r2,28(sp)
 8209590:	e0801015 	stw	r2,64(fp)
 8209594:	00800384 	movi	r2,14
 8209598:	1400f736 	bltu	r2,r16,8209978 <_dtoa_r+0x764>
 820959c:	8800f626 	beq	r17,zero,8209978 <_dtoa_r+0x764>
 82095a0:	d9c00517 	ldw	r7,20(sp)
 82095a4:	01c39a0e 	bge	zero,r7,820a410 <_dtoa_r+0x11fc>
 82095a8:	388003cc 	andi	r2,r7,15
 82095ac:	100490fa 	slli	r2,r2,3
 82095b0:	382bd13a 	srai	r21,r7,4
 82095b4:	00c20974 	movhi	r3,2085
 82095b8:	18f71b04 	addi	r3,r3,-9108
 82095bc:	1885883a 	add	r2,r3,r2
 82095c0:	a8c0040c 	andi	r3,r21,16
 82095c4:	12400017 	ldw	r9,0(r2)
 82095c8:	12000117 	ldw	r8,4(r2)
 82095cc:	18037926 	beq	r3,zero,820a3b4 <_dtoa_r+0x11a0>
 82095d0:	00820974 	movhi	r2,2085
 82095d4:	10b71104 	addi	r2,r2,-9148
 82095d8:	11800817 	ldw	r6,32(r2)
 82095dc:	11c00917 	ldw	r7,36(r2)
 82095e0:	9009883a 	mov	r4,r18
 82095e4:	980b883a 	mov	r5,r19
 82095e8:	da001715 	stw	r8,92(sp)
 82095ec:	da401615 	stw	r9,88(sp)
 82095f0:	82126700 	call	8212670 <__divdf3>
 82095f4:	da001717 	ldw	r8,92(sp)
 82095f8:	da401617 	ldw	r9,88(sp)
 82095fc:	ad4003cc 	andi	r21,r21,15
 8209600:	040000c4 	movi	r16,3
 8209604:	1023883a 	mov	r17,r2
 8209608:	1829883a 	mov	r20,r3
 820960c:	a8001126 	beq	r21,zero,8209654 <_dtoa_r+0x440>
 8209610:	05c20974 	movhi	r23,2085
 8209614:	bdf71104 	addi	r23,r23,-9148
 8209618:	4805883a 	mov	r2,r9
 820961c:	4007883a 	mov	r3,r8
 8209620:	a980004c 	andi	r6,r21,1
 8209624:	1009883a 	mov	r4,r2
 8209628:	a82bd07a 	srai	r21,r21,1
 820962c:	180b883a 	mov	r5,r3
 8209630:	30000426 	beq	r6,zero,8209644 <_dtoa_r+0x430>
 8209634:	b9800017 	ldw	r6,0(r23)
 8209638:	b9c00117 	ldw	r7,4(r23)
 820963c:	84000044 	addi	r16,r16,1
 8209640:	82131b00 	call	82131b0 <__muldf3>
 8209644:	bdc00204 	addi	r23,r23,8
 8209648:	a83ff51e 	bne	r21,zero,8209620 <_dtoa_r+0x40c>
 820964c:	1013883a 	mov	r9,r2
 8209650:	1811883a 	mov	r8,r3
 8209654:	480d883a 	mov	r6,r9
 8209658:	400f883a 	mov	r7,r8
 820965c:	8809883a 	mov	r4,r17
 8209660:	a00b883a 	mov	r5,r20
 8209664:	82126700 	call	8212670 <__divdf3>
 8209668:	d8800f15 	stw	r2,60(sp)
 820966c:	d8c01015 	stw	r3,64(sp)
 8209670:	d8c00e17 	ldw	r3,56(sp)
 8209674:	18000626 	beq	r3,zero,8209690 <_dtoa_r+0x47c>
 8209678:	d9000f17 	ldw	r4,60(sp)
 820967c:	d9401017 	ldw	r5,64(sp)
 8209680:	000d883a 	mov	r6,zero
 8209684:	01cffc34 	movhi	r7,16368
 8209688:	82130bc0 	call	82130bc <__ledf2>
 820968c:	10040b16 	blt	r2,zero,820a6bc <_dtoa_r+0x14a8>
 8209690:	8009883a 	mov	r4,r16
 8209694:	82142440 	call	8214244 <__floatsidf>
 8209698:	d9800f17 	ldw	r6,60(sp)
 820969c:	d9c01017 	ldw	r7,64(sp)
 82096a0:	1009883a 	mov	r4,r2
 82096a4:	180b883a 	mov	r5,r3
 82096a8:	82131b00 	call	82131b0 <__muldf3>
 82096ac:	000d883a 	mov	r6,zero
 82096b0:	01d00734 	movhi	r7,16412
 82096b4:	1009883a 	mov	r4,r2
 82096b8:	180b883a 	mov	r5,r3
 82096bc:	8211dc40 	call	8211dc4 <__adddf3>
 82096c0:	1021883a 	mov	r16,r2
 82096c4:	d8800617 	ldw	r2,24(sp)
 82096c8:	047f3034 	movhi	r17,64704
 82096cc:	1c63883a 	add	r17,r3,r17
 82096d0:	10031826 	beq	r2,zero,820a334 <_dtoa_r+0x1120>
 82096d4:	d8c00517 	ldw	r3,20(sp)
 82096d8:	db000617 	ldw	r12,24(sp)
 82096dc:	d8c01315 	stw	r3,76(sp)
 82096e0:	d9000b17 	ldw	r4,44(sp)
 82096e4:	20038f26 	beq	r4,zero,820a524 <_dtoa_r+0x1310>
 82096e8:	60bfffc4 	addi	r2,r12,-1
 82096ec:	100490fa 	slli	r2,r2,3
 82096f0:	00c20974 	movhi	r3,2085
 82096f4:	18f71b04 	addi	r3,r3,-9108
 82096f8:	1885883a 	add	r2,r3,r2
 82096fc:	11800017 	ldw	r6,0(r2)
 8209700:	11c00117 	ldw	r7,4(r2)
 8209704:	d8800717 	ldw	r2,28(sp)
 8209708:	0009883a 	mov	r4,zero
 820970c:	014ff834 	movhi	r5,16352
 8209710:	db001615 	stw	r12,88(sp)
 8209714:	15c00044 	addi	r23,r2,1
 8209718:	82126700 	call	8212670 <__divdf3>
 820971c:	800d883a 	mov	r6,r16
 8209720:	880f883a 	mov	r7,r17
 8209724:	1009883a 	mov	r4,r2
 8209728:	180b883a 	mov	r5,r3
 820972c:	82138c80 	call	82138c8 <__subdf3>
 8209730:	d9401017 	ldw	r5,64(sp)
 8209734:	d9000f17 	ldw	r4,60(sp)
 8209738:	102b883a 	mov	r21,r2
 820973c:	d8c01215 	stw	r3,72(sp)
 8209740:	82141c40 	call	82141c4 <__fixdfsi>
 8209744:	1009883a 	mov	r4,r2
 8209748:	1029883a 	mov	r20,r2
 820974c:	82142440 	call	8214244 <__floatsidf>
 8209750:	d9000f17 	ldw	r4,60(sp)
 8209754:	d9401017 	ldw	r5,64(sp)
 8209758:	100d883a 	mov	r6,r2
 820975c:	180f883a 	mov	r7,r3
 8209760:	82138c80 	call	82138c8 <__subdf3>
 8209764:	1823883a 	mov	r17,r3
 8209768:	d8c00717 	ldw	r3,28(sp)
 820976c:	d9401217 	ldw	r5,72(sp)
 8209770:	a2000c04 	addi	r8,r20,48
 8209774:	1021883a 	mov	r16,r2
 8209778:	1a000005 	stb	r8,0(r3)
 820977c:	800d883a 	mov	r6,r16
 8209780:	880f883a 	mov	r7,r17
 8209784:	a809883a 	mov	r4,r21
 8209788:	4029883a 	mov	r20,r8
 820978c:	8212fe00 	call	8212fe0 <__gedf2>
 8209790:	00841d16 	blt	zero,r2,820a808 <_dtoa_r+0x15f4>
 8209794:	800d883a 	mov	r6,r16
 8209798:	880f883a 	mov	r7,r17
 820979c:	0009883a 	mov	r4,zero
 82097a0:	014ffc34 	movhi	r5,16368
 82097a4:	82138c80 	call	82138c8 <__subdf3>
 82097a8:	d9401217 	ldw	r5,72(sp)
 82097ac:	100d883a 	mov	r6,r2
 82097b0:	180f883a 	mov	r7,r3
 82097b4:	a809883a 	mov	r4,r21
 82097b8:	8212fe00 	call	8212fe0 <__gedf2>
 82097bc:	db001617 	ldw	r12,88(sp)
 82097c0:	00840e16 	blt	zero,r2,820a7fc <_dtoa_r+0x15e8>
 82097c4:	00800044 	movi	r2,1
 82097c8:	13006b0e 	bge	r2,r12,8209978 <_dtoa_r+0x764>
 82097cc:	d9000717 	ldw	r4,28(sp)
 82097d0:	dd800f15 	stw	r22,60(sp)
 82097d4:	dcc01015 	stw	r19,64(sp)
 82097d8:	2319883a 	add	r12,r4,r12
 82097dc:	dcc01217 	ldw	r19,72(sp)
 82097e0:	602d883a 	mov	r22,r12
 82097e4:	dc801215 	stw	r18,72(sp)
 82097e8:	b825883a 	mov	r18,r23
 82097ec:	00000906 	br	8209814 <_dtoa_r+0x600>
 82097f0:	82138c80 	call	82138c8 <__subdf3>
 82097f4:	a80d883a 	mov	r6,r21
 82097f8:	980f883a 	mov	r7,r19
 82097fc:	1009883a 	mov	r4,r2
 8209800:	180b883a 	mov	r5,r3
 8209804:	82130bc0 	call	82130bc <__ledf2>
 8209808:	1003e816 	blt	r2,zero,820a7ac <_dtoa_r+0x1598>
 820980c:	b825883a 	mov	r18,r23
 8209810:	bd83e926 	beq	r23,r22,820a7b8 <_dtoa_r+0x15a4>
 8209814:	a809883a 	mov	r4,r21
 8209818:	980b883a 	mov	r5,r19
 820981c:	000d883a 	mov	r6,zero
 8209820:	01d00934 	movhi	r7,16420
 8209824:	82131b00 	call	82131b0 <__muldf3>
 8209828:	000d883a 	mov	r6,zero
 820982c:	01d00934 	movhi	r7,16420
 8209830:	8009883a 	mov	r4,r16
 8209834:	880b883a 	mov	r5,r17
 8209838:	102b883a 	mov	r21,r2
 820983c:	1827883a 	mov	r19,r3
 8209840:	82131b00 	call	82131b0 <__muldf3>
 8209844:	180b883a 	mov	r5,r3
 8209848:	1009883a 	mov	r4,r2
 820984c:	1821883a 	mov	r16,r3
 8209850:	1023883a 	mov	r17,r2
 8209854:	82141c40 	call	82141c4 <__fixdfsi>
 8209858:	1009883a 	mov	r4,r2
 820985c:	1029883a 	mov	r20,r2
 8209860:	82142440 	call	8214244 <__floatsidf>
 8209864:	8809883a 	mov	r4,r17
 8209868:	800b883a 	mov	r5,r16
 820986c:	100d883a 	mov	r6,r2
 8209870:	180f883a 	mov	r7,r3
 8209874:	82138c80 	call	82138c8 <__subdf3>
 8209878:	a5000c04 	addi	r20,r20,48
 820987c:	a80d883a 	mov	r6,r21
 8209880:	980f883a 	mov	r7,r19
 8209884:	1009883a 	mov	r4,r2
 8209888:	180b883a 	mov	r5,r3
 820988c:	95000005 	stb	r20,0(r18)
 8209890:	1021883a 	mov	r16,r2
 8209894:	1823883a 	mov	r17,r3
 8209898:	82130bc0 	call	82130bc <__ledf2>
 820989c:	bdc00044 	addi	r23,r23,1
 82098a0:	800d883a 	mov	r6,r16
 82098a4:	880f883a 	mov	r7,r17
 82098a8:	0009883a 	mov	r4,zero
 82098ac:	014ffc34 	movhi	r5,16368
 82098b0:	103fcf0e 	bge	r2,zero,82097f0 <_dtoa_r+0x5dc>
 82098b4:	d8c01317 	ldw	r3,76(sp)
 82098b8:	d8c00515 	stw	r3,20(sp)
 82098bc:	d9400917 	ldw	r5,36(sp)
 82098c0:	e009883a 	mov	r4,fp
 82098c4:	820c75c0 	call	820c75c <_Bfree>
 82098c8:	d9000517 	ldw	r4,20(sp)
 82098cc:	d9802317 	ldw	r6,140(sp)
 82098d0:	d9c02517 	ldw	r7,148(sp)
 82098d4:	b8000005 	stb	zero,0(r23)
 82098d8:	20800044 	addi	r2,r4,1
 82098dc:	30800015 	stw	r2,0(r6)
 82098e0:	3802aa26 	beq	r7,zero,820a38c <_dtoa_r+0x1178>
 82098e4:	3dc00015 	stw	r23,0(r7)
 82098e8:	d8800717 	ldw	r2,28(sp)
 82098ec:	003e7906 	br	82092d4 <_dtoa_r+0xc0>
 82098f0:	00800434 	movhi	r2,16
 82098f4:	10bfffc4 	addi	r2,r2,-1
 82098f8:	88a2703a 	and	r17,r17,r2
 82098fc:	883e851e 	bne	r17,zero,8209314 <_dtoa_r+0x100>
 8209900:	00820974 	movhi	r2,2085
 8209904:	10b6fd04 	addi	r2,r2,-9228
 8209908:	003e8406 	br	820931c <_dtoa_r+0x108>
 820990c:	10c00204 	addi	r3,r2,8
 8209910:	003e8706 	br	8209330 <_dtoa_r+0x11c>
 8209914:	01400434 	movhi	r5,16
 8209918:	297fffc4 	addi	r5,r5,-1
 820991c:	994a703a 	and	r5,r19,r5
 8209920:	9009883a 	mov	r4,r18
 8209924:	843f0044 	addi	r16,r16,-1023
 8209928:	294ffc34 	orhi	r5,r5,16368
 820992c:	dd800217 	ldw	r22,8(sp)
 8209930:	d8001115 	stw	zero,68(sp)
 8209934:	003ea506 	br	82093cc <_dtoa_r+0x1b8>
 8209938:	00820974 	movhi	r2,2085
 820993c:	10b6ec04 	addi	r2,r2,-9296
 8209940:	003e6406 	br	82092d4 <_dtoa_r+0xc0>
 8209944:	e0001115 	stw	zero,68(fp)
 8209948:	000b883a 	mov	r5,zero
 820994c:	e009883a 	mov	r4,fp
 8209950:	820c6b40 	call	820c6b4 <_Balloc>
 8209954:	01bfffc4 	movi	r6,-1
 8209958:	01c00044 	movi	r7,1
 820995c:	d8800715 	stw	r2,28(sp)
 8209960:	d9800c15 	stw	r6,48(sp)
 8209964:	e0801015 	stw	r2,64(fp)
 8209968:	d8000315 	stw	zero,12(sp)
 820996c:	d9c00b15 	stw	r7,44(sp)
 8209970:	d9800615 	stw	r6,24(sp)
 8209974:	d8002215 	stw	zero,136(sp)
 8209978:	d8800117 	ldw	r2,4(sp)
 820997c:	10008916 	blt	r2,zero,8209ba4 <_dtoa_r+0x990>
 8209980:	d9000517 	ldw	r4,20(sp)
 8209984:	00c00384 	movi	r3,14
 8209988:	19008616 	blt	r3,r4,8209ba4 <_dtoa_r+0x990>
 820998c:	200490fa 	slli	r2,r4,3
 8209990:	00c20974 	movhi	r3,2085
 8209994:	d9802217 	ldw	r6,136(sp)
 8209998:	18f71b04 	addi	r3,r3,-9108
 820999c:	1885883a 	add	r2,r3,r2
 82099a0:	14000017 	ldw	r16,0(r2)
 82099a4:	14400117 	ldw	r17,4(r2)
 82099a8:	30016316 	blt	r6,zero,8209f38 <_dtoa_r+0xd24>
 82099ac:	800d883a 	mov	r6,r16
 82099b0:	880f883a 	mov	r7,r17
 82099b4:	9009883a 	mov	r4,r18
 82099b8:	980b883a 	mov	r5,r19
 82099bc:	82126700 	call	8212670 <__divdf3>
 82099c0:	180b883a 	mov	r5,r3
 82099c4:	1009883a 	mov	r4,r2
 82099c8:	82141c40 	call	82141c4 <__fixdfsi>
 82099cc:	1009883a 	mov	r4,r2
 82099d0:	102b883a 	mov	r21,r2
 82099d4:	82142440 	call	8214244 <__floatsidf>
 82099d8:	800d883a 	mov	r6,r16
 82099dc:	880f883a 	mov	r7,r17
 82099e0:	1009883a 	mov	r4,r2
 82099e4:	180b883a 	mov	r5,r3
 82099e8:	82131b00 	call	82131b0 <__muldf3>
 82099ec:	100d883a 	mov	r6,r2
 82099f0:	180f883a 	mov	r7,r3
 82099f4:	9009883a 	mov	r4,r18
 82099f8:	980b883a 	mov	r5,r19
 82099fc:	82138c80 	call	82138c8 <__subdf3>
 8209a00:	d9c00717 	ldw	r7,28(sp)
 8209a04:	1009883a 	mov	r4,r2
 8209a08:	a8800c04 	addi	r2,r21,48
 8209a0c:	38800005 	stb	r2,0(r7)
 8209a10:	3dc00044 	addi	r23,r7,1
 8209a14:	d9c00617 	ldw	r7,24(sp)
 8209a18:	01800044 	movi	r6,1
 8209a1c:	180b883a 	mov	r5,r3
 8209a20:	2005883a 	mov	r2,r4
 8209a24:	39803826 	beq	r7,r6,8209b08 <_dtoa_r+0x8f4>
 8209a28:	000d883a 	mov	r6,zero
 8209a2c:	01d00934 	movhi	r7,16420
 8209a30:	82131b00 	call	82131b0 <__muldf3>
 8209a34:	000d883a 	mov	r6,zero
 8209a38:	000f883a 	mov	r7,zero
 8209a3c:	1009883a 	mov	r4,r2
 8209a40:	180b883a 	mov	r5,r3
 8209a44:	1025883a 	mov	r18,r2
 8209a48:	1827883a 	mov	r19,r3
 8209a4c:	8212f580 	call	8212f58 <__eqdf2>
 8209a50:	103f9a26 	beq	r2,zero,82098bc <_dtoa_r+0x6a8>
 8209a54:	d9c00617 	ldw	r7,24(sp)
 8209a58:	d8c00717 	ldw	r3,28(sp)
 8209a5c:	b829883a 	mov	r20,r23
 8209a60:	38bfffc4 	addi	r2,r7,-1
 8209a64:	18ad883a 	add	r22,r3,r2
 8209a68:	00000a06 	br	8209a94 <_dtoa_r+0x880>
 8209a6c:	82131b00 	call	82131b0 <__muldf3>
 8209a70:	000d883a 	mov	r6,zero
 8209a74:	000f883a 	mov	r7,zero
 8209a78:	1009883a 	mov	r4,r2
 8209a7c:	180b883a 	mov	r5,r3
 8209a80:	1025883a 	mov	r18,r2
 8209a84:	1827883a 	mov	r19,r3
 8209a88:	b829883a 	mov	r20,r23
 8209a8c:	8212f580 	call	8212f58 <__eqdf2>
 8209a90:	103f8a26 	beq	r2,zero,82098bc <_dtoa_r+0x6a8>
 8209a94:	800d883a 	mov	r6,r16
 8209a98:	880f883a 	mov	r7,r17
 8209a9c:	9009883a 	mov	r4,r18
 8209aa0:	980b883a 	mov	r5,r19
 8209aa4:	82126700 	call	8212670 <__divdf3>
 8209aa8:	180b883a 	mov	r5,r3
 8209aac:	1009883a 	mov	r4,r2
 8209ab0:	82141c40 	call	82141c4 <__fixdfsi>
 8209ab4:	1009883a 	mov	r4,r2
 8209ab8:	102b883a 	mov	r21,r2
 8209abc:	82142440 	call	8214244 <__floatsidf>
 8209ac0:	800d883a 	mov	r6,r16
 8209ac4:	880f883a 	mov	r7,r17
 8209ac8:	1009883a 	mov	r4,r2
 8209acc:	180b883a 	mov	r5,r3
 8209ad0:	82131b00 	call	82131b0 <__muldf3>
 8209ad4:	100d883a 	mov	r6,r2
 8209ad8:	180f883a 	mov	r7,r3
 8209adc:	9009883a 	mov	r4,r18
 8209ae0:	980b883a 	mov	r5,r19
 8209ae4:	82138c80 	call	82138c8 <__subdf3>
 8209ae8:	aa000c04 	addi	r8,r21,48
 8209aec:	a2000005 	stb	r8,0(r20)
 8209af0:	000d883a 	mov	r6,zero
 8209af4:	01d00934 	movhi	r7,16420
 8209af8:	1009883a 	mov	r4,r2
 8209afc:	180b883a 	mov	r5,r3
 8209b00:	a5c00044 	addi	r23,r20,1
 8209b04:	b53fd91e 	bne	r22,r20,8209a6c <_dtoa_r+0x858>
 8209b08:	100d883a 	mov	r6,r2
 8209b0c:	180f883a 	mov	r7,r3
 8209b10:	1009883a 	mov	r4,r2
 8209b14:	180b883a 	mov	r5,r3
 8209b18:	8211dc40 	call	8211dc4 <__adddf3>
 8209b1c:	100d883a 	mov	r6,r2
 8209b20:	180f883a 	mov	r7,r3
 8209b24:	8009883a 	mov	r4,r16
 8209b28:	880b883a 	mov	r5,r17
 8209b2c:	1027883a 	mov	r19,r2
 8209b30:	1825883a 	mov	r18,r3
 8209b34:	82130bc0 	call	82130bc <__ledf2>
 8209b38:	10000816 	blt	r2,zero,8209b5c <_dtoa_r+0x948>
 8209b3c:	980d883a 	mov	r6,r19
 8209b40:	900f883a 	mov	r7,r18
 8209b44:	8009883a 	mov	r4,r16
 8209b48:	880b883a 	mov	r5,r17
 8209b4c:	8212f580 	call	8212f58 <__eqdf2>
 8209b50:	103f5a1e 	bne	r2,zero,82098bc <_dtoa_r+0x6a8>
 8209b54:	ad40004c 	andi	r21,r21,1
 8209b58:	a83f5826 	beq	r21,zero,82098bc <_dtoa_r+0x6a8>
 8209b5c:	bd3fffc3 	ldbu	r20,-1(r23)
 8209b60:	b8bfffc4 	addi	r2,r23,-1
 8209b64:	1007883a 	mov	r3,r2
 8209b68:	01400e44 	movi	r5,57
 8209b6c:	d9800717 	ldw	r6,28(sp)
 8209b70:	00000506 	br	8209b88 <_dtoa_r+0x974>
 8209b74:	18ffffc4 	addi	r3,r3,-1
 8209b78:	11824726 	beq	r2,r6,820a498 <_dtoa_r+0x1284>
 8209b7c:	1d000003 	ldbu	r20,0(r3)
 8209b80:	102f883a 	mov	r23,r2
 8209b84:	10bfffc4 	addi	r2,r2,-1
 8209b88:	a1003fcc 	andi	r4,r20,255
 8209b8c:	2100201c 	xori	r4,r4,128
 8209b90:	213fe004 	addi	r4,r4,-128
 8209b94:	217ff726 	beq	r4,r5,8209b74 <_dtoa_r+0x960>
 8209b98:	a2000044 	addi	r8,r20,1
 8209b9c:	12000005 	stb	r8,0(r2)
 8209ba0:	003f4606 	br	82098bc <_dtoa_r+0x6a8>
 8209ba4:	d9000b17 	ldw	r4,44(sp)
 8209ba8:	2000c826 	beq	r4,zero,8209ecc <_dtoa_r+0xcb8>
 8209bac:	d9800317 	ldw	r6,12(sp)
 8209bb0:	00c00044 	movi	r3,1
 8209bb4:	1980f90e 	bge	r3,r6,8209f9c <_dtoa_r+0xd88>
 8209bb8:	d8800617 	ldw	r2,24(sp)
 8209bbc:	d8c00a17 	ldw	r3,40(sp)
 8209bc0:	157fffc4 	addi	r21,r2,-1
 8209bc4:	1d41f316 	blt	r3,r21,820a394 <_dtoa_r+0x1180>
 8209bc8:	1d6bc83a 	sub	r21,r3,r21
 8209bcc:	d9c00617 	ldw	r7,24(sp)
 8209bd0:	3802aa16 	blt	r7,zero,820a67c <_dtoa_r+0x1468>
 8209bd4:	dd000817 	ldw	r20,32(sp)
 8209bd8:	d8800617 	ldw	r2,24(sp)
 8209bdc:	d8c00817 	ldw	r3,32(sp)
 8209be0:	01400044 	movi	r5,1
 8209be4:	e009883a 	mov	r4,fp
 8209be8:	1887883a 	add	r3,r3,r2
 8209bec:	d8c00815 	stw	r3,32(sp)
 8209bf0:	b0ad883a 	add	r22,r22,r2
 8209bf4:	820cac00 	call	820cac0 <__i2b>
 8209bf8:	1023883a 	mov	r17,r2
 8209bfc:	a0000826 	beq	r20,zero,8209c20 <_dtoa_r+0xa0c>
 8209c00:	0580070e 	bge	zero,r22,8209c20 <_dtoa_r+0xa0c>
 8209c04:	a005883a 	mov	r2,r20
 8209c08:	b500b916 	blt	r22,r20,8209ef0 <_dtoa_r+0xcdc>
 8209c0c:	d9000817 	ldw	r4,32(sp)
 8209c10:	a0a9c83a 	sub	r20,r20,r2
 8209c14:	b0adc83a 	sub	r22,r22,r2
 8209c18:	2089c83a 	sub	r4,r4,r2
 8209c1c:	d9000815 	stw	r4,32(sp)
 8209c20:	d9800a17 	ldw	r6,40(sp)
 8209c24:	0181810e 	bge	zero,r6,820a22c <_dtoa_r+0x1018>
 8209c28:	d9c00b17 	ldw	r7,44(sp)
 8209c2c:	3800b326 	beq	r7,zero,8209efc <_dtoa_r+0xce8>
 8209c30:	a800b226 	beq	r21,zero,8209efc <_dtoa_r+0xce8>
 8209c34:	880b883a 	mov	r5,r17
 8209c38:	a80d883a 	mov	r6,r21
 8209c3c:	e009883a 	mov	r4,fp
 8209c40:	820ccf40 	call	820ccf4 <__pow5mult>
 8209c44:	d9800917 	ldw	r6,36(sp)
 8209c48:	100b883a 	mov	r5,r2
 8209c4c:	e009883a 	mov	r4,fp
 8209c50:	1023883a 	mov	r17,r2
 8209c54:	820cafc0 	call	820cafc <__multiply>
 8209c58:	1021883a 	mov	r16,r2
 8209c5c:	d8800a17 	ldw	r2,40(sp)
 8209c60:	d9400917 	ldw	r5,36(sp)
 8209c64:	e009883a 	mov	r4,fp
 8209c68:	1545c83a 	sub	r2,r2,r21
 8209c6c:	d8800a15 	stw	r2,40(sp)
 8209c70:	820c75c0 	call	820c75c <_Bfree>
 8209c74:	d8c00a17 	ldw	r3,40(sp)
 8209c78:	18009f1e 	bne	r3,zero,8209ef8 <_dtoa_r+0xce4>
 8209c7c:	05c00044 	movi	r23,1
 8209c80:	e009883a 	mov	r4,fp
 8209c84:	b80b883a 	mov	r5,r23
 8209c88:	820cac00 	call	820cac0 <__i2b>
 8209c8c:	d9000d17 	ldw	r4,52(sp)
 8209c90:	102b883a 	mov	r21,r2
 8209c94:	2000ce26 	beq	r4,zero,8209fd0 <_dtoa_r+0xdbc>
 8209c98:	200d883a 	mov	r6,r4
 8209c9c:	100b883a 	mov	r5,r2
 8209ca0:	e009883a 	mov	r4,fp
 8209ca4:	820ccf40 	call	820ccf4 <__pow5mult>
 8209ca8:	d9800317 	ldw	r6,12(sp)
 8209cac:	102b883a 	mov	r21,r2
 8209cb0:	b981810e 	bge	r23,r6,820a2b8 <_dtoa_r+0x10a4>
 8209cb4:	0027883a 	mov	r19,zero
 8209cb8:	a8800417 	ldw	r2,16(r21)
 8209cbc:	05c00804 	movi	r23,32
 8209cc0:	10800104 	addi	r2,r2,4
 8209cc4:	1085883a 	add	r2,r2,r2
 8209cc8:	1085883a 	add	r2,r2,r2
 8209ccc:	a885883a 	add	r2,r21,r2
 8209cd0:	11000017 	ldw	r4,0(r2)
 8209cd4:	820c9a80 	call	820c9a8 <__hi0bits>
 8209cd8:	b885c83a 	sub	r2,r23,r2
 8209cdc:	1585883a 	add	r2,r2,r22
 8209ce0:	108007cc 	andi	r2,r2,31
 8209ce4:	1000b326 	beq	r2,zero,8209fb4 <_dtoa_r+0xda0>
 8209ce8:	00c00804 	movi	r3,32
 8209cec:	1887c83a 	sub	r3,r3,r2
 8209cf0:	01000104 	movi	r4,4
 8209cf4:	20c2cd0e 	bge	r4,r3,820a82c <_dtoa_r+0x1618>
 8209cf8:	00c00704 	movi	r3,28
 8209cfc:	1885c83a 	sub	r2,r3,r2
 8209d00:	d8c00817 	ldw	r3,32(sp)
 8209d04:	a0a9883a 	add	r20,r20,r2
 8209d08:	b0ad883a 	add	r22,r22,r2
 8209d0c:	1887883a 	add	r3,r3,r2
 8209d10:	d8c00815 	stw	r3,32(sp)
 8209d14:	d9800817 	ldw	r6,32(sp)
 8209d18:	0180040e 	bge	zero,r6,8209d2c <_dtoa_r+0xb18>
 8209d1c:	800b883a 	mov	r5,r16
 8209d20:	e009883a 	mov	r4,fp
 8209d24:	820ce340 	call	820ce34 <__lshift>
 8209d28:	1021883a 	mov	r16,r2
 8209d2c:	0580050e 	bge	zero,r22,8209d44 <_dtoa_r+0xb30>
 8209d30:	a80b883a 	mov	r5,r21
 8209d34:	b00d883a 	mov	r6,r22
 8209d38:	e009883a 	mov	r4,fp
 8209d3c:	820ce340 	call	820ce34 <__lshift>
 8209d40:	102b883a 	mov	r21,r2
 8209d44:	d9c00e17 	ldw	r7,56(sp)
 8209d48:	3801211e 	bne	r7,zero,820a1d0 <_dtoa_r+0xfbc>
 8209d4c:	d9800617 	ldw	r6,24(sp)
 8209d50:	0181380e 	bge	zero,r6,820a234 <_dtoa_r+0x1020>
 8209d54:	d8c00b17 	ldw	r3,44(sp)
 8209d58:	1800ab1e 	bne	r3,zero,820a008 <_dtoa_r+0xdf4>
 8209d5c:	dc800717 	ldw	r18,28(sp)
 8209d60:	dcc00617 	ldw	r19,24(sp)
 8209d64:	9029883a 	mov	r20,r18
 8209d68:	00000206 	br	8209d74 <_dtoa_r+0xb60>
 8209d6c:	820c7840 	call	820c784 <__multadd>
 8209d70:	1021883a 	mov	r16,r2
 8209d74:	a80b883a 	mov	r5,r21
 8209d78:	8009883a 	mov	r4,r16
 8209d7c:	82090140 	call	8209014 <quorem>
 8209d80:	10800c04 	addi	r2,r2,48
 8209d84:	90800005 	stb	r2,0(r18)
 8209d88:	94800044 	addi	r18,r18,1
 8209d8c:	9507c83a 	sub	r3,r18,r20
 8209d90:	000f883a 	mov	r7,zero
 8209d94:	01800284 	movi	r6,10
 8209d98:	800b883a 	mov	r5,r16
 8209d9c:	e009883a 	mov	r4,fp
 8209da0:	1cfff216 	blt	r3,r19,8209d6c <_dtoa_r+0xb58>
 8209da4:	1011883a 	mov	r8,r2
 8209da8:	d8800617 	ldw	r2,24(sp)
 8209dac:	0082370e 	bge	zero,r2,820a68c <_dtoa_r+0x1478>
 8209db0:	d9000717 	ldw	r4,28(sp)
 8209db4:	0025883a 	mov	r18,zero
 8209db8:	20af883a 	add	r23,r4,r2
 8209dbc:	01800044 	movi	r6,1
 8209dc0:	800b883a 	mov	r5,r16
 8209dc4:	e009883a 	mov	r4,fp
 8209dc8:	da001715 	stw	r8,92(sp)
 8209dcc:	820ce340 	call	820ce34 <__lshift>
 8209dd0:	a80b883a 	mov	r5,r21
 8209dd4:	1009883a 	mov	r4,r2
 8209dd8:	d8800915 	stw	r2,36(sp)
 8209ddc:	820cf7c0 	call	820cf7c <__mcmp>
 8209de0:	da001717 	ldw	r8,92(sp)
 8209de4:	0081800e 	bge	zero,r2,820a3e8 <_dtoa_r+0x11d4>
 8209de8:	b93fffc3 	ldbu	r4,-1(r23)
 8209dec:	b8bfffc4 	addi	r2,r23,-1
 8209df0:	1007883a 	mov	r3,r2
 8209df4:	01800e44 	movi	r6,57
 8209df8:	d9c00717 	ldw	r7,28(sp)
 8209dfc:	00000506 	br	8209e14 <_dtoa_r+0xc00>
 8209e00:	18ffffc4 	addi	r3,r3,-1
 8209e04:	11c12326 	beq	r2,r7,820a294 <_dtoa_r+0x1080>
 8209e08:	19000003 	ldbu	r4,0(r3)
 8209e0c:	102f883a 	mov	r23,r2
 8209e10:	10bfffc4 	addi	r2,r2,-1
 8209e14:	21403fcc 	andi	r5,r4,255
 8209e18:	2940201c 	xori	r5,r5,128
 8209e1c:	297fe004 	addi	r5,r5,-128
 8209e20:	29bff726 	beq	r5,r6,8209e00 <_dtoa_r+0xbec>
 8209e24:	21000044 	addi	r4,r4,1
 8209e28:	11000005 	stb	r4,0(r2)
 8209e2c:	a80b883a 	mov	r5,r21
 8209e30:	e009883a 	mov	r4,fp
 8209e34:	820c75c0 	call	820c75c <_Bfree>
 8209e38:	883ea026 	beq	r17,zero,82098bc <_dtoa_r+0x6a8>
 8209e3c:	90000426 	beq	r18,zero,8209e50 <_dtoa_r+0xc3c>
 8209e40:	94400326 	beq	r18,r17,8209e50 <_dtoa_r+0xc3c>
 8209e44:	900b883a 	mov	r5,r18
 8209e48:	e009883a 	mov	r4,fp
 8209e4c:	820c75c0 	call	820c75c <_Bfree>
 8209e50:	880b883a 	mov	r5,r17
 8209e54:	e009883a 	mov	r4,fp
 8209e58:	820c75c0 	call	820c75c <_Bfree>
 8209e5c:	003e9706 	br	82098bc <_dtoa_r+0x6a8>
 8209e60:	01800044 	movi	r6,1
 8209e64:	d9800e15 	stw	r6,56(sp)
 8209e68:	003d9606 	br	82094c4 <_dtoa_r+0x2b0>
 8209e6c:	d8800817 	ldw	r2,32(sp)
 8209e70:	d8c00517 	ldw	r3,20(sp)
 8209e74:	d8000d15 	stw	zero,52(sp)
 8209e78:	10c5c83a 	sub	r2,r2,r3
 8209e7c:	00c9c83a 	sub	r4,zero,r3
 8209e80:	d8800815 	stw	r2,32(sp)
 8209e84:	d9000a15 	stw	r4,40(sp)
 8209e88:	003d9706 	br	82094e8 <_dtoa_r+0x2d4>
 8209e8c:	05adc83a 	sub	r22,zero,r22
 8209e90:	dd800815 	stw	r22,32(sp)
 8209e94:	002d883a 	mov	r22,zero
 8209e98:	003d8e06 	br	82094d4 <_dtoa_r+0x2c0>
 8209e9c:	d9000517 	ldw	r4,20(sp)
 8209ea0:	82142440 	call	8214244 <__floatsidf>
 8209ea4:	100d883a 	mov	r6,r2
 8209ea8:	180f883a 	mov	r7,r3
 8209eac:	a009883a 	mov	r4,r20
 8209eb0:	880b883a 	mov	r5,r17
 8209eb4:	8212f580 	call	8212f58 <__eqdf2>
 8209eb8:	103d7126 	beq	r2,zero,8209480 <_dtoa_r+0x26c>
 8209ebc:	d9c00517 	ldw	r7,20(sp)
 8209ec0:	39ffffc4 	addi	r7,r7,-1
 8209ec4:	d9c00515 	stw	r7,20(sp)
 8209ec8:	003d6d06 	br	8209480 <_dtoa_r+0x26c>
 8209ecc:	dd400a17 	ldw	r21,40(sp)
 8209ed0:	dd000817 	ldw	r20,32(sp)
 8209ed4:	0023883a 	mov	r17,zero
 8209ed8:	003f4806 	br	8209bfc <_dtoa_r+0x9e8>
 8209edc:	10e3c83a 	sub	r17,r2,r3
 8209ee0:	9448983a 	sll	r4,r18,r17
 8209ee4:	003d3206 	br	82093b0 <_dtoa_r+0x19c>
 8209ee8:	d8000e15 	stw	zero,56(sp)
 8209eec:	003d7506 	br	82094c4 <_dtoa_r+0x2b0>
 8209ef0:	b005883a 	mov	r2,r22
 8209ef4:	003f4506 	br	8209c0c <_dtoa_r+0x9f8>
 8209ef8:	dc000915 	stw	r16,36(sp)
 8209efc:	d9800a17 	ldw	r6,40(sp)
 8209f00:	d9400917 	ldw	r5,36(sp)
 8209f04:	e009883a 	mov	r4,fp
 8209f08:	820ccf40 	call	820ccf4 <__pow5mult>
 8209f0c:	1021883a 	mov	r16,r2
 8209f10:	003f5a06 	br	8209c7c <_dtoa_r+0xa68>
 8209f14:	01c00044 	movi	r7,1
 8209f18:	d9c00b15 	stw	r7,44(sp)
 8209f1c:	d8802217 	ldw	r2,136(sp)
 8209f20:	0081280e 	bge	zero,r2,820a3c4 <_dtoa_r+0x11b0>
 8209f24:	100d883a 	mov	r6,r2
 8209f28:	1021883a 	mov	r16,r2
 8209f2c:	d8800c15 	stw	r2,48(sp)
 8209f30:	d8800615 	stw	r2,24(sp)
 8209f34:	003d8806 	br	8209558 <_dtoa_r+0x344>
 8209f38:	d8800617 	ldw	r2,24(sp)
 8209f3c:	00be9b16 	blt	zero,r2,82099ac <_dtoa_r+0x798>
 8209f40:	10010f1e 	bne	r2,zero,820a380 <_dtoa_r+0x116c>
 8209f44:	880b883a 	mov	r5,r17
 8209f48:	000d883a 	mov	r6,zero
 8209f4c:	01d00534 	movhi	r7,16404
 8209f50:	8009883a 	mov	r4,r16
 8209f54:	82131b00 	call	82131b0 <__muldf3>
 8209f58:	900d883a 	mov	r6,r18
 8209f5c:	980f883a 	mov	r7,r19
 8209f60:	1009883a 	mov	r4,r2
 8209f64:	180b883a 	mov	r5,r3
 8209f68:	8212fe00 	call	8212fe0 <__gedf2>
 8209f6c:	002b883a 	mov	r21,zero
 8209f70:	0023883a 	mov	r17,zero
 8209f74:	1000bf16 	blt	r2,zero,820a274 <_dtoa_r+0x1060>
 8209f78:	d9802217 	ldw	r6,136(sp)
 8209f7c:	ddc00717 	ldw	r23,28(sp)
 8209f80:	018c303a 	nor	r6,zero,r6
 8209f84:	d9800515 	stw	r6,20(sp)
 8209f88:	a80b883a 	mov	r5,r21
 8209f8c:	e009883a 	mov	r4,fp
 8209f90:	820c75c0 	call	820c75c <_Bfree>
 8209f94:	883e4926 	beq	r17,zero,82098bc <_dtoa_r+0x6a8>
 8209f98:	003fad06 	br	8209e50 <_dtoa_r+0xc3c>
 8209f9c:	d9c01117 	ldw	r7,68(sp)
 8209fa0:	3801bc26 	beq	r7,zero,820a694 <_dtoa_r+0x1480>
 8209fa4:	10810cc4 	addi	r2,r2,1075
 8209fa8:	dd400a17 	ldw	r21,40(sp)
 8209fac:	dd000817 	ldw	r20,32(sp)
 8209fb0:	003f0a06 	br	8209bdc <_dtoa_r+0x9c8>
 8209fb4:	00800704 	movi	r2,28
 8209fb8:	d9000817 	ldw	r4,32(sp)
 8209fbc:	a0a9883a 	add	r20,r20,r2
 8209fc0:	b0ad883a 	add	r22,r22,r2
 8209fc4:	2089883a 	add	r4,r4,r2
 8209fc8:	d9000815 	stw	r4,32(sp)
 8209fcc:	003f5106 	br	8209d14 <_dtoa_r+0xb00>
 8209fd0:	d8c00317 	ldw	r3,12(sp)
 8209fd4:	b8c1fc0e 	bge	r23,r3,820a7c8 <_dtoa_r+0x15b4>
 8209fd8:	0027883a 	mov	r19,zero
 8209fdc:	b805883a 	mov	r2,r23
 8209fe0:	003f3e06 	br	8209cdc <_dtoa_r+0xac8>
 8209fe4:	880b883a 	mov	r5,r17
 8209fe8:	e009883a 	mov	r4,fp
 8209fec:	000f883a 	mov	r7,zero
 8209ff0:	01800284 	movi	r6,10
 8209ff4:	820c7840 	call	820c784 <__multadd>
 8209ff8:	d9000c17 	ldw	r4,48(sp)
 8209ffc:	1023883a 	mov	r17,r2
 820a000:	0102040e 	bge	zero,r4,820a814 <_dtoa_r+0x1600>
 820a004:	d9000615 	stw	r4,24(sp)
 820a008:	0500050e 	bge	zero,r20,820a020 <_dtoa_r+0xe0c>
 820a00c:	880b883a 	mov	r5,r17
 820a010:	a00d883a 	mov	r6,r20
 820a014:	e009883a 	mov	r4,fp
 820a018:	820ce340 	call	820ce34 <__lshift>
 820a01c:	1023883a 	mov	r17,r2
 820a020:	9801241e 	bne	r19,zero,820a4b4 <_dtoa_r+0x12a0>
 820a024:	8829883a 	mov	r20,r17
 820a028:	d9000617 	ldw	r4,24(sp)
 820a02c:	dcc00717 	ldw	r19,28(sp)
 820a030:	9480004c 	andi	r18,r18,1
 820a034:	20bfffc4 	addi	r2,r4,-1
 820a038:	9885883a 	add	r2,r19,r2
 820a03c:	d8800415 	stw	r2,16(sp)
 820a040:	dc800615 	stw	r18,24(sp)
 820a044:	a80b883a 	mov	r5,r21
 820a048:	8009883a 	mov	r4,r16
 820a04c:	82090140 	call	8209014 <quorem>
 820a050:	880b883a 	mov	r5,r17
 820a054:	8009883a 	mov	r4,r16
 820a058:	102f883a 	mov	r23,r2
 820a05c:	820cf7c0 	call	820cf7c <__mcmp>
 820a060:	a80b883a 	mov	r5,r21
 820a064:	a00d883a 	mov	r6,r20
 820a068:	e009883a 	mov	r4,fp
 820a06c:	102d883a 	mov	r22,r2
 820a070:	820cfdc0 	call	820cfdc <__mdiff>
 820a074:	1007883a 	mov	r3,r2
 820a078:	10800317 	ldw	r2,12(r2)
 820a07c:	bc800c04 	addi	r18,r23,48
 820a080:	180b883a 	mov	r5,r3
 820a084:	10004e1e 	bne	r2,zero,820a1c0 <_dtoa_r+0xfac>
 820a088:	8009883a 	mov	r4,r16
 820a08c:	d8c01615 	stw	r3,88(sp)
 820a090:	820cf7c0 	call	820cf7c <__mcmp>
 820a094:	d8c01617 	ldw	r3,88(sp)
 820a098:	e009883a 	mov	r4,fp
 820a09c:	d8801615 	stw	r2,88(sp)
 820a0a0:	180b883a 	mov	r5,r3
 820a0a4:	820c75c0 	call	820c75c <_Bfree>
 820a0a8:	d8801617 	ldw	r2,88(sp)
 820a0ac:	1000041e 	bne	r2,zero,820a0c0 <_dtoa_r+0xeac>
 820a0b0:	d9800317 	ldw	r6,12(sp)
 820a0b4:	3000021e 	bne	r6,zero,820a0c0 <_dtoa_r+0xeac>
 820a0b8:	d8c00617 	ldw	r3,24(sp)
 820a0bc:	18003726 	beq	r3,zero,820a19c <_dtoa_r+0xf88>
 820a0c0:	b0002016 	blt	r22,zero,820a144 <_dtoa_r+0xf30>
 820a0c4:	b000041e 	bne	r22,zero,820a0d8 <_dtoa_r+0xec4>
 820a0c8:	d9000317 	ldw	r4,12(sp)
 820a0cc:	2000021e 	bne	r4,zero,820a0d8 <_dtoa_r+0xec4>
 820a0d0:	d8c00617 	ldw	r3,24(sp)
 820a0d4:	18001b26 	beq	r3,zero,820a144 <_dtoa_r+0xf30>
 820a0d8:	00810716 	blt	zero,r2,820a4f8 <_dtoa_r+0x12e4>
 820a0dc:	d8c00417 	ldw	r3,16(sp)
 820a0e0:	9d800044 	addi	r22,r19,1
 820a0e4:	9c800005 	stb	r18,0(r19)
 820a0e8:	b02f883a 	mov	r23,r22
 820a0ec:	98c10626 	beq	r19,r3,820a508 <_dtoa_r+0x12f4>
 820a0f0:	800b883a 	mov	r5,r16
 820a0f4:	000f883a 	mov	r7,zero
 820a0f8:	01800284 	movi	r6,10
 820a0fc:	e009883a 	mov	r4,fp
 820a100:	820c7840 	call	820c784 <__multadd>
 820a104:	1021883a 	mov	r16,r2
 820a108:	000f883a 	mov	r7,zero
 820a10c:	01800284 	movi	r6,10
 820a110:	880b883a 	mov	r5,r17
 820a114:	e009883a 	mov	r4,fp
 820a118:	8d002526 	beq	r17,r20,820a1b0 <_dtoa_r+0xf9c>
 820a11c:	820c7840 	call	820c784 <__multadd>
 820a120:	a00b883a 	mov	r5,r20
 820a124:	000f883a 	mov	r7,zero
 820a128:	01800284 	movi	r6,10
 820a12c:	e009883a 	mov	r4,fp
 820a130:	1023883a 	mov	r17,r2
 820a134:	820c7840 	call	820c784 <__multadd>
 820a138:	1029883a 	mov	r20,r2
 820a13c:	b027883a 	mov	r19,r22
 820a140:	003fc006 	br	820a044 <_dtoa_r+0xe30>
 820a144:	9011883a 	mov	r8,r18
 820a148:	00800e0e 	bge	zero,r2,820a184 <_dtoa_r+0xf70>
 820a14c:	800b883a 	mov	r5,r16
 820a150:	01800044 	movi	r6,1
 820a154:	e009883a 	mov	r4,fp
 820a158:	da001715 	stw	r8,92(sp)
 820a15c:	820ce340 	call	820ce34 <__lshift>
 820a160:	a80b883a 	mov	r5,r21
 820a164:	1009883a 	mov	r4,r2
 820a168:	1021883a 	mov	r16,r2
 820a16c:	820cf7c0 	call	820cf7c <__mcmp>
 820a170:	da001717 	ldw	r8,92(sp)
 820a174:	0081960e 	bge	zero,r2,820a7d0 <_dtoa_r+0x15bc>
 820a178:	00800e44 	movi	r2,57
 820a17c:	40817026 	beq	r8,r2,820a740 <_dtoa_r+0x152c>
 820a180:	ba000c44 	addi	r8,r23,49
 820a184:	8825883a 	mov	r18,r17
 820a188:	9dc00044 	addi	r23,r19,1
 820a18c:	9a000005 	stb	r8,0(r19)
 820a190:	a023883a 	mov	r17,r20
 820a194:	dc000915 	stw	r16,36(sp)
 820a198:	003f2406 	br	8209e2c <_dtoa_r+0xc18>
 820a19c:	00800e44 	movi	r2,57
 820a1a0:	9011883a 	mov	r8,r18
 820a1a4:	90816626 	beq	r18,r2,820a740 <_dtoa_r+0x152c>
 820a1a8:	05bff516 	blt	zero,r22,820a180 <_dtoa_r+0xf6c>
 820a1ac:	003ff506 	br	820a184 <_dtoa_r+0xf70>
 820a1b0:	820c7840 	call	820c784 <__multadd>
 820a1b4:	1023883a 	mov	r17,r2
 820a1b8:	1029883a 	mov	r20,r2
 820a1bc:	003fdf06 	br	820a13c <_dtoa_r+0xf28>
 820a1c0:	e009883a 	mov	r4,fp
 820a1c4:	820c75c0 	call	820c75c <_Bfree>
 820a1c8:	00800044 	movi	r2,1
 820a1cc:	003fbc06 	br	820a0c0 <_dtoa_r+0xeac>
 820a1d0:	a80b883a 	mov	r5,r21
 820a1d4:	8009883a 	mov	r4,r16
 820a1d8:	820cf7c0 	call	820cf7c <__mcmp>
 820a1dc:	103edb0e 	bge	r2,zero,8209d4c <_dtoa_r+0xb38>
 820a1e0:	800b883a 	mov	r5,r16
 820a1e4:	000f883a 	mov	r7,zero
 820a1e8:	01800284 	movi	r6,10
 820a1ec:	e009883a 	mov	r4,fp
 820a1f0:	820c7840 	call	820c784 <__multadd>
 820a1f4:	1021883a 	mov	r16,r2
 820a1f8:	d8800517 	ldw	r2,20(sp)
 820a1fc:	d8c00b17 	ldw	r3,44(sp)
 820a200:	10bfffc4 	addi	r2,r2,-1
 820a204:	d8800515 	stw	r2,20(sp)
 820a208:	183f761e 	bne	r3,zero,8209fe4 <_dtoa_r+0xdd0>
 820a20c:	d9000c17 	ldw	r4,48(sp)
 820a210:	0101730e 	bge	zero,r4,820a7e0 <_dtoa_r+0x15cc>
 820a214:	d9000615 	stw	r4,24(sp)
 820a218:	003ed006 	br	8209d5c <_dtoa_r+0xb48>
 820a21c:	00800084 	movi	r2,2
 820a220:	3081861e 	bne	r6,r2,820a83c <_dtoa_r+0x1628>
 820a224:	d8000b15 	stw	zero,44(sp)
 820a228:	003f3c06 	br	8209f1c <_dtoa_r+0xd08>
 820a22c:	dc000917 	ldw	r16,36(sp)
 820a230:	003e9206 	br	8209c7c <_dtoa_r+0xa68>
 820a234:	d9c00317 	ldw	r7,12(sp)
 820a238:	00800084 	movi	r2,2
 820a23c:	11fec50e 	bge	r2,r7,8209d54 <_dtoa_r+0xb40>
 820a240:	d9000617 	ldw	r4,24(sp)
 820a244:	20013c1e 	bne	r4,zero,820a738 <_dtoa_r+0x1524>
 820a248:	a80b883a 	mov	r5,r21
 820a24c:	000f883a 	mov	r7,zero
 820a250:	01800144 	movi	r6,5
 820a254:	e009883a 	mov	r4,fp
 820a258:	820c7840 	call	820c784 <__multadd>
 820a25c:	100b883a 	mov	r5,r2
 820a260:	8009883a 	mov	r4,r16
 820a264:	102b883a 	mov	r21,r2
 820a268:	820cf7c0 	call	820cf7c <__mcmp>
 820a26c:	dc000915 	stw	r16,36(sp)
 820a270:	00bf410e 	bge	zero,r2,8209f78 <_dtoa_r+0xd64>
 820a274:	d9c00717 	ldw	r7,28(sp)
 820a278:	00800c44 	movi	r2,49
 820a27c:	38800005 	stb	r2,0(r7)
 820a280:	d8800517 	ldw	r2,20(sp)
 820a284:	3dc00044 	addi	r23,r7,1
 820a288:	10800044 	addi	r2,r2,1
 820a28c:	d8800515 	stw	r2,20(sp)
 820a290:	003f3d06 	br	8209f88 <_dtoa_r+0xd74>
 820a294:	d9800517 	ldw	r6,20(sp)
 820a298:	d9c00717 	ldw	r7,28(sp)
 820a29c:	00800c44 	movi	r2,49
 820a2a0:	31800044 	addi	r6,r6,1
 820a2a4:	d9800515 	stw	r6,20(sp)
 820a2a8:	38800005 	stb	r2,0(r7)
 820a2ac:	003edf06 	br	8209e2c <_dtoa_r+0xc18>
 820a2b0:	d8000b15 	stw	zero,44(sp)
 820a2b4:	003c9f06 	br	8209534 <_dtoa_r+0x320>
 820a2b8:	903e7e1e 	bne	r18,zero,8209cb4 <_dtoa_r+0xaa0>
 820a2bc:	00800434 	movhi	r2,16
 820a2c0:	10bfffc4 	addi	r2,r2,-1
 820a2c4:	9884703a 	and	r2,r19,r2
 820a2c8:	1000ea1e 	bne	r2,zero,820a674 <_dtoa_r+0x1460>
 820a2cc:	9cdffc2c 	andhi	r19,r19,32752
 820a2d0:	9800e826 	beq	r19,zero,820a674 <_dtoa_r+0x1460>
 820a2d4:	d9c00817 	ldw	r7,32(sp)
 820a2d8:	b5800044 	addi	r22,r22,1
 820a2dc:	04c00044 	movi	r19,1
 820a2e0:	39c00044 	addi	r7,r7,1
 820a2e4:	d9c00815 	stw	r7,32(sp)
 820a2e8:	d8800d17 	ldw	r2,52(sp)
 820a2ec:	103e721e 	bne	r2,zero,8209cb8 <_dtoa_r+0xaa4>
 820a2f0:	00800044 	movi	r2,1
 820a2f4:	003e7906 	br	8209cdc <_dtoa_r+0xac8>
 820a2f8:	8009883a 	mov	r4,r16
 820a2fc:	82142440 	call	8214244 <__floatsidf>
 820a300:	d9800f17 	ldw	r6,60(sp)
 820a304:	d9c01017 	ldw	r7,64(sp)
 820a308:	1009883a 	mov	r4,r2
 820a30c:	180b883a 	mov	r5,r3
 820a310:	82131b00 	call	82131b0 <__muldf3>
 820a314:	000d883a 	mov	r6,zero
 820a318:	01d00734 	movhi	r7,16412
 820a31c:	1009883a 	mov	r4,r2
 820a320:	180b883a 	mov	r5,r3
 820a324:	8211dc40 	call	8211dc4 <__adddf3>
 820a328:	047f3034 	movhi	r17,64704
 820a32c:	1021883a 	mov	r16,r2
 820a330:	1c63883a 	add	r17,r3,r17
 820a334:	d9000f17 	ldw	r4,60(sp)
 820a338:	d9401017 	ldw	r5,64(sp)
 820a33c:	000d883a 	mov	r6,zero
 820a340:	01d00534 	movhi	r7,16404
 820a344:	82138c80 	call	82138c8 <__subdf3>
 820a348:	800d883a 	mov	r6,r16
 820a34c:	880f883a 	mov	r7,r17
 820a350:	1009883a 	mov	r4,r2
 820a354:	180b883a 	mov	r5,r3
 820a358:	102b883a 	mov	r21,r2
 820a35c:	1829883a 	mov	r20,r3
 820a360:	8212fe00 	call	8212fe0 <__gedf2>
 820a364:	00806c16 	blt	zero,r2,820a518 <_dtoa_r+0x1304>
 820a368:	89e0003c 	xorhi	r7,r17,32768
 820a36c:	800d883a 	mov	r6,r16
 820a370:	a809883a 	mov	r4,r21
 820a374:	a00b883a 	mov	r5,r20
 820a378:	82130bc0 	call	82130bc <__ledf2>
 820a37c:	103d7e0e 	bge	r2,zero,8209978 <_dtoa_r+0x764>
 820a380:	002b883a 	mov	r21,zero
 820a384:	0023883a 	mov	r17,zero
 820a388:	003efb06 	br	8209f78 <_dtoa_r+0xd64>
 820a38c:	d8800717 	ldw	r2,28(sp)
 820a390:	003bd006 	br	82092d4 <_dtoa_r+0xc0>
 820a394:	d9000a17 	ldw	r4,40(sp)
 820a398:	d9800d17 	ldw	r6,52(sp)
 820a39c:	dd400a15 	stw	r21,40(sp)
 820a3a0:	a905c83a 	sub	r2,r21,r4
 820a3a4:	308d883a 	add	r6,r6,r2
 820a3a8:	d9800d15 	stw	r6,52(sp)
 820a3ac:	002b883a 	mov	r21,zero
 820a3b0:	003e0606 	br	8209bcc <_dtoa_r+0x9b8>
 820a3b4:	9023883a 	mov	r17,r18
 820a3b8:	9829883a 	mov	r20,r19
 820a3bc:	04000084 	movi	r16,2
 820a3c0:	003c9206 	br	820960c <_dtoa_r+0x3f8>
 820a3c4:	04000044 	movi	r16,1
 820a3c8:	dc000c15 	stw	r16,48(sp)
 820a3cc:	dc000615 	stw	r16,24(sp)
 820a3d0:	dc002215 	stw	r16,136(sp)
 820a3d4:	e0001115 	stw	zero,68(fp)
 820a3d8:	000b883a 	mov	r5,zero
 820a3dc:	003c6906 	br	8209584 <_dtoa_r+0x370>
 820a3e0:	3021883a 	mov	r16,r6
 820a3e4:	003ffb06 	br	820a3d4 <_dtoa_r+0x11c0>
 820a3e8:	1000021e 	bne	r2,zero,820a3f4 <_dtoa_r+0x11e0>
 820a3ec:	4200004c 	andi	r8,r8,1
 820a3f0:	403e7d1e 	bne	r8,zero,8209de8 <_dtoa_r+0xbd4>
 820a3f4:	01000c04 	movi	r4,48
 820a3f8:	00000106 	br	820a400 <_dtoa_r+0x11ec>
 820a3fc:	102f883a 	mov	r23,r2
 820a400:	b8bfffc4 	addi	r2,r23,-1
 820a404:	10c00007 	ldb	r3,0(r2)
 820a408:	193ffc26 	beq	r3,r4,820a3fc <_dtoa_r+0x11e8>
 820a40c:	003e8706 	br	8209e2c <_dtoa_r+0xc18>
 820a410:	d8800517 	ldw	r2,20(sp)
 820a414:	00a3c83a 	sub	r17,zero,r2
 820a418:	8800a426 	beq	r17,zero,820a6ac <_dtoa_r+0x1498>
 820a41c:	888003cc 	andi	r2,r17,15
 820a420:	100490fa 	slli	r2,r2,3
 820a424:	00c20974 	movhi	r3,2085
 820a428:	18f71b04 	addi	r3,r3,-9108
 820a42c:	1885883a 	add	r2,r3,r2
 820a430:	11800017 	ldw	r6,0(r2)
 820a434:	11c00117 	ldw	r7,4(r2)
 820a438:	9009883a 	mov	r4,r18
 820a43c:	980b883a 	mov	r5,r19
 820a440:	8823d13a 	srai	r17,r17,4
 820a444:	82131b00 	call	82131b0 <__muldf3>
 820a448:	d8800f15 	stw	r2,60(sp)
 820a44c:	d8c01015 	stw	r3,64(sp)
 820a450:	8800e826 	beq	r17,zero,820a7f4 <_dtoa_r+0x15e0>
 820a454:	05020974 	movhi	r20,2085
 820a458:	a5371104 	addi	r20,r20,-9148
 820a45c:	04000084 	movi	r16,2
 820a460:	8980004c 	andi	r6,r17,1
 820a464:	1009883a 	mov	r4,r2
 820a468:	8823d07a 	srai	r17,r17,1
 820a46c:	180b883a 	mov	r5,r3
 820a470:	30000426 	beq	r6,zero,820a484 <_dtoa_r+0x1270>
 820a474:	a1800017 	ldw	r6,0(r20)
 820a478:	a1c00117 	ldw	r7,4(r20)
 820a47c:	84000044 	addi	r16,r16,1
 820a480:	82131b00 	call	82131b0 <__muldf3>
 820a484:	a5000204 	addi	r20,r20,8
 820a488:	883ff51e 	bne	r17,zero,820a460 <_dtoa_r+0x124c>
 820a48c:	d8800f15 	stw	r2,60(sp)
 820a490:	d8c01015 	stw	r3,64(sp)
 820a494:	003c7606 	br	8209670 <_dtoa_r+0x45c>
 820a498:	00c00c04 	movi	r3,48
 820a49c:	10c00005 	stb	r3,0(r2)
 820a4a0:	d8c00517 	ldw	r3,20(sp)
 820a4a4:	bd3fffc3 	ldbu	r20,-1(r23)
 820a4a8:	18c00044 	addi	r3,r3,1
 820a4ac:	d8c00515 	stw	r3,20(sp)
 820a4b0:	003db906 	br	8209b98 <_dtoa_r+0x984>
 820a4b4:	89400117 	ldw	r5,4(r17)
 820a4b8:	e009883a 	mov	r4,fp
 820a4bc:	820c6b40 	call	820c6b4 <_Balloc>
 820a4c0:	89800417 	ldw	r6,16(r17)
 820a4c4:	89400304 	addi	r5,r17,12
 820a4c8:	11000304 	addi	r4,r2,12
 820a4cc:	31800084 	addi	r6,r6,2
 820a4d0:	318d883a 	add	r6,r6,r6
 820a4d4:	318d883a 	add	r6,r6,r6
 820a4d8:	1027883a 	mov	r19,r2
 820a4dc:	8202f6c0 	call	8202f6c <memcpy>
 820a4e0:	01800044 	movi	r6,1
 820a4e4:	980b883a 	mov	r5,r19
 820a4e8:	e009883a 	mov	r4,fp
 820a4ec:	820ce340 	call	820ce34 <__lshift>
 820a4f0:	1029883a 	mov	r20,r2
 820a4f4:	003ecc06 	br	820a028 <_dtoa_r+0xe14>
 820a4f8:	00800e44 	movi	r2,57
 820a4fc:	90809026 	beq	r18,r2,820a740 <_dtoa_r+0x152c>
 820a500:	92000044 	addi	r8,r18,1
 820a504:	003f1f06 	br	820a184 <_dtoa_r+0xf70>
 820a508:	9011883a 	mov	r8,r18
 820a50c:	8825883a 	mov	r18,r17
 820a510:	a023883a 	mov	r17,r20
 820a514:	003e2906 	br	8209dbc <_dtoa_r+0xba8>
 820a518:	002b883a 	mov	r21,zero
 820a51c:	0023883a 	mov	r17,zero
 820a520:	003f5406 	br	820a274 <_dtoa_r+0x1060>
 820a524:	61bfffc4 	addi	r6,r12,-1
 820a528:	300490fa 	slli	r2,r6,3
 820a52c:	00c20974 	movhi	r3,2085
 820a530:	18f71b04 	addi	r3,r3,-9108
 820a534:	1885883a 	add	r2,r3,r2
 820a538:	11000017 	ldw	r4,0(r2)
 820a53c:	11400117 	ldw	r5,4(r2)
 820a540:	d8800717 	ldw	r2,28(sp)
 820a544:	880f883a 	mov	r7,r17
 820a548:	d9801215 	stw	r6,72(sp)
 820a54c:	800d883a 	mov	r6,r16
 820a550:	db001615 	stw	r12,88(sp)
 820a554:	15c00044 	addi	r23,r2,1
 820a558:	82131b00 	call	82131b0 <__muldf3>
 820a55c:	d9401017 	ldw	r5,64(sp)
 820a560:	d9000f17 	ldw	r4,60(sp)
 820a564:	d8c01515 	stw	r3,84(sp)
 820a568:	d8801415 	stw	r2,80(sp)
 820a56c:	82141c40 	call	82141c4 <__fixdfsi>
 820a570:	1009883a 	mov	r4,r2
 820a574:	1021883a 	mov	r16,r2
 820a578:	82142440 	call	8214244 <__floatsidf>
 820a57c:	d9000f17 	ldw	r4,60(sp)
 820a580:	d9401017 	ldw	r5,64(sp)
 820a584:	100d883a 	mov	r6,r2
 820a588:	180f883a 	mov	r7,r3
 820a58c:	82138c80 	call	82138c8 <__subdf3>
 820a590:	1829883a 	mov	r20,r3
 820a594:	d8c00717 	ldw	r3,28(sp)
 820a598:	84000c04 	addi	r16,r16,48
 820a59c:	1023883a 	mov	r17,r2
 820a5a0:	1c000005 	stb	r16,0(r3)
 820a5a4:	db001617 	ldw	r12,88(sp)
 820a5a8:	00800044 	movi	r2,1
 820a5ac:	60802226 	beq	r12,r2,820a638 <_dtoa_r+0x1424>
 820a5b0:	d9c00717 	ldw	r7,28(sp)
 820a5b4:	8805883a 	mov	r2,r17
 820a5b8:	b82b883a 	mov	r21,r23
 820a5bc:	3b19883a 	add	r12,r7,r12
 820a5c0:	6023883a 	mov	r17,r12
 820a5c4:	a007883a 	mov	r3,r20
 820a5c8:	dc800f15 	stw	r18,60(sp)
 820a5cc:	000d883a 	mov	r6,zero
 820a5d0:	01d00934 	movhi	r7,16420
 820a5d4:	1009883a 	mov	r4,r2
 820a5d8:	180b883a 	mov	r5,r3
 820a5dc:	82131b00 	call	82131b0 <__muldf3>
 820a5e0:	180b883a 	mov	r5,r3
 820a5e4:	1009883a 	mov	r4,r2
 820a5e8:	1829883a 	mov	r20,r3
 820a5ec:	1025883a 	mov	r18,r2
 820a5f0:	82141c40 	call	82141c4 <__fixdfsi>
 820a5f4:	1009883a 	mov	r4,r2
 820a5f8:	1021883a 	mov	r16,r2
 820a5fc:	82142440 	call	8214244 <__floatsidf>
 820a600:	100d883a 	mov	r6,r2
 820a604:	180f883a 	mov	r7,r3
 820a608:	9009883a 	mov	r4,r18
 820a60c:	a00b883a 	mov	r5,r20
 820a610:	84000c04 	addi	r16,r16,48
 820a614:	82138c80 	call	82138c8 <__subdf3>
 820a618:	ad400044 	addi	r21,r21,1
 820a61c:	ac3fffc5 	stb	r16,-1(r21)
 820a620:	ac7fea1e 	bne	r21,r17,820a5cc <_dtoa_r+0x13b8>
 820a624:	1023883a 	mov	r17,r2
 820a628:	d8801217 	ldw	r2,72(sp)
 820a62c:	dc800f17 	ldw	r18,60(sp)
 820a630:	1829883a 	mov	r20,r3
 820a634:	b8af883a 	add	r23,r23,r2
 820a638:	d9001417 	ldw	r4,80(sp)
 820a63c:	d9401517 	ldw	r5,84(sp)
 820a640:	000d883a 	mov	r6,zero
 820a644:	01cff834 	movhi	r7,16352
 820a648:	8211dc40 	call	8211dc4 <__adddf3>
 820a64c:	880d883a 	mov	r6,r17
 820a650:	a00f883a 	mov	r7,r20
 820a654:	1009883a 	mov	r4,r2
 820a658:	180b883a 	mov	r5,r3
 820a65c:	82130bc0 	call	82130bc <__ledf2>
 820a660:	10003e0e 	bge	r2,zero,820a75c <_dtoa_r+0x1548>
 820a664:	d9001317 	ldw	r4,76(sp)
 820a668:	bd3fffc3 	ldbu	r20,-1(r23)
 820a66c:	d9000515 	stw	r4,20(sp)
 820a670:	003d3b06 	br	8209b60 <_dtoa_r+0x94c>
 820a674:	0027883a 	mov	r19,zero
 820a678:	003f1b06 	br	820a2e8 <_dtoa_r+0x10d4>
 820a67c:	d8800817 	ldw	r2,32(sp)
 820a680:	11e9c83a 	sub	r20,r2,r7
 820a684:	0005883a 	mov	r2,zero
 820a688:	003d5406 	br	8209bdc <_dtoa_r+0x9c8>
 820a68c:	00800044 	movi	r2,1
 820a690:	003dc706 	br	8209db0 <_dtoa_r+0xb9c>
 820a694:	d8c00217 	ldw	r3,8(sp)
 820a698:	00800d84 	movi	r2,54
 820a69c:	dd400a17 	ldw	r21,40(sp)
 820a6a0:	10c5c83a 	sub	r2,r2,r3
 820a6a4:	dd000817 	ldw	r20,32(sp)
 820a6a8:	003d4c06 	br	8209bdc <_dtoa_r+0x9c8>
 820a6ac:	dc800f15 	stw	r18,60(sp)
 820a6b0:	dcc01015 	stw	r19,64(sp)
 820a6b4:	04000084 	movi	r16,2
 820a6b8:	003bed06 	br	8209670 <_dtoa_r+0x45c>
 820a6bc:	d9000617 	ldw	r4,24(sp)
 820a6c0:	203f0d26 	beq	r4,zero,820a2f8 <_dtoa_r+0x10e4>
 820a6c4:	d9800c17 	ldw	r6,48(sp)
 820a6c8:	01bcab0e 	bge	zero,r6,8209978 <_dtoa_r+0x764>
 820a6cc:	d9401017 	ldw	r5,64(sp)
 820a6d0:	d9000f17 	ldw	r4,60(sp)
 820a6d4:	000d883a 	mov	r6,zero
 820a6d8:	01d00934 	movhi	r7,16420
 820a6dc:	82131b00 	call	82131b0 <__muldf3>
 820a6e0:	81000044 	addi	r4,r16,1
 820a6e4:	d8800f15 	stw	r2,60(sp)
 820a6e8:	d8c01015 	stw	r3,64(sp)
 820a6ec:	82142440 	call	8214244 <__floatsidf>
 820a6f0:	d9800f17 	ldw	r6,60(sp)
 820a6f4:	d9c01017 	ldw	r7,64(sp)
 820a6f8:	1009883a 	mov	r4,r2
 820a6fc:	180b883a 	mov	r5,r3
 820a700:	82131b00 	call	82131b0 <__muldf3>
 820a704:	01d00734 	movhi	r7,16412
 820a708:	000d883a 	mov	r6,zero
 820a70c:	1009883a 	mov	r4,r2
 820a710:	180b883a 	mov	r5,r3
 820a714:	8211dc40 	call	8211dc4 <__adddf3>
 820a718:	d9c00517 	ldw	r7,20(sp)
 820a71c:	047f3034 	movhi	r17,64704
 820a720:	1021883a 	mov	r16,r2
 820a724:	39ffffc4 	addi	r7,r7,-1
 820a728:	d9c01315 	stw	r7,76(sp)
 820a72c:	1c63883a 	add	r17,r3,r17
 820a730:	db000c17 	ldw	r12,48(sp)
 820a734:	003bea06 	br	82096e0 <_dtoa_r+0x4cc>
 820a738:	dc000915 	stw	r16,36(sp)
 820a73c:	003e0e06 	br	8209f78 <_dtoa_r+0xd64>
 820a740:	01000e44 	movi	r4,57
 820a744:	8825883a 	mov	r18,r17
 820a748:	9dc00044 	addi	r23,r19,1
 820a74c:	99000005 	stb	r4,0(r19)
 820a750:	a023883a 	mov	r17,r20
 820a754:	dc000915 	stw	r16,36(sp)
 820a758:	003da406 	br	8209dec <_dtoa_r+0xbd8>
 820a75c:	d9801417 	ldw	r6,80(sp)
 820a760:	d9c01517 	ldw	r7,84(sp)
 820a764:	0009883a 	mov	r4,zero
 820a768:	014ff834 	movhi	r5,16352
 820a76c:	82138c80 	call	82138c8 <__subdf3>
 820a770:	880d883a 	mov	r6,r17
 820a774:	a00f883a 	mov	r7,r20
 820a778:	1009883a 	mov	r4,r2
 820a77c:	180b883a 	mov	r5,r3
 820a780:	8212fe00 	call	8212fe0 <__gedf2>
 820a784:	00bc7c0e 	bge	zero,r2,8209978 <_dtoa_r+0x764>
 820a788:	01000c04 	movi	r4,48
 820a78c:	00000106 	br	820a794 <_dtoa_r+0x1580>
 820a790:	102f883a 	mov	r23,r2
 820a794:	b8bfffc4 	addi	r2,r23,-1
 820a798:	10c00007 	ldb	r3,0(r2)
 820a79c:	193ffc26 	beq	r3,r4,820a790 <_dtoa_r+0x157c>
 820a7a0:	d9801317 	ldw	r6,76(sp)
 820a7a4:	d9800515 	stw	r6,20(sp)
 820a7a8:	003c4406 	br	82098bc <_dtoa_r+0x6a8>
 820a7ac:	d9801317 	ldw	r6,76(sp)
 820a7b0:	d9800515 	stw	r6,20(sp)
 820a7b4:	003cea06 	br	8209b60 <_dtoa_r+0x94c>
 820a7b8:	dd800f17 	ldw	r22,60(sp)
 820a7bc:	dcc01017 	ldw	r19,64(sp)
 820a7c0:	dc801217 	ldw	r18,72(sp)
 820a7c4:	003c6c06 	br	8209978 <_dtoa_r+0x764>
 820a7c8:	903e031e 	bne	r18,zero,8209fd8 <_dtoa_r+0xdc4>
 820a7cc:	003ebb06 	br	820a2bc <_dtoa_r+0x10a8>
 820a7d0:	103e6c1e 	bne	r2,zero,820a184 <_dtoa_r+0xf70>
 820a7d4:	4080004c 	andi	r2,r8,1
 820a7d8:	103e6a26 	beq	r2,zero,820a184 <_dtoa_r+0xf70>
 820a7dc:	003e6606 	br	820a178 <_dtoa_r+0xf64>
 820a7e0:	d8c00317 	ldw	r3,12(sp)
 820a7e4:	00800084 	movi	r2,2
 820a7e8:	10c02916 	blt	r2,r3,820a890 <_dtoa_r+0x167c>
 820a7ec:	d9000c17 	ldw	r4,48(sp)
 820a7f0:	003e8806 	br	820a214 <_dtoa_r+0x1000>
 820a7f4:	04000084 	movi	r16,2
 820a7f8:	003b9d06 	br	8209670 <_dtoa_r+0x45c>
 820a7fc:	d9001317 	ldw	r4,76(sp)
 820a800:	d9000515 	stw	r4,20(sp)
 820a804:	003cd606 	br	8209b60 <_dtoa_r+0x94c>
 820a808:	d8801317 	ldw	r2,76(sp)
 820a80c:	d8800515 	stw	r2,20(sp)
 820a810:	003c2a06 	br	82098bc <_dtoa_r+0x6a8>
 820a814:	d9800317 	ldw	r6,12(sp)
 820a818:	00800084 	movi	r2,2
 820a81c:	11801516 	blt	r2,r6,820a874 <_dtoa_r+0x1660>
 820a820:	d9c00c17 	ldw	r7,48(sp)
 820a824:	d9c00615 	stw	r7,24(sp)
 820a828:	003df706 	br	820a008 <_dtoa_r+0xdf4>
 820a82c:	193d3926 	beq	r3,r4,8209d14 <_dtoa_r+0xb00>
 820a830:	00c00f04 	movi	r3,60
 820a834:	1885c83a 	sub	r2,r3,r2
 820a838:	003ddf06 	br	8209fb8 <_dtoa_r+0xda4>
 820a83c:	e009883a 	mov	r4,fp
 820a840:	e0001115 	stw	zero,68(fp)
 820a844:	000b883a 	mov	r5,zero
 820a848:	820c6b40 	call	820c6b4 <_Balloc>
 820a84c:	d8800715 	stw	r2,28(sp)
 820a850:	d8c00717 	ldw	r3,28(sp)
 820a854:	00bfffc4 	movi	r2,-1
 820a858:	01000044 	movi	r4,1
 820a85c:	d8800c15 	stw	r2,48(sp)
 820a860:	e0c01015 	stw	r3,64(fp)
 820a864:	d9000b15 	stw	r4,44(sp)
 820a868:	d8800615 	stw	r2,24(sp)
 820a86c:	d8002215 	stw	zero,136(sp)
 820a870:	003c4106 	br	8209978 <_dtoa_r+0x764>
 820a874:	d8c00c17 	ldw	r3,48(sp)
 820a878:	d8c00615 	stw	r3,24(sp)
 820a87c:	003e7006 	br	820a240 <_dtoa_r+0x102c>
 820a880:	04400044 	movi	r17,1
 820a884:	003b2006 	br	8209508 <_dtoa_r+0x2f4>
 820a888:	000b883a 	mov	r5,zero
 820a88c:	003b3d06 	br	8209584 <_dtoa_r+0x370>
 820a890:	d8800c17 	ldw	r2,48(sp)
 820a894:	d8800615 	stw	r2,24(sp)
 820a898:	003e6906 	br	820a240 <_dtoa_r+0x102c>

0820a89c <__sflush_r>:
 820a89c:	2880030b 	ldhu	r2,12(r5)
 820a8a0:	defffb04 	addi	sp,sp,-20
 820a8a4:	dcc00315 	stw	r19,12(sp)
 820a8a8:	dc400115 	stw	r17,4(sp)
 820a8ac:	dfc00415 	stw	ra,16(sp)
 820a8b0:	dc800215 	stw	r18,8(sp)
 820a8b4:	dc000015 	stw	r16,0(sp)
 820a8b8:	10c0020c 	andi	r3,r2,8
 820a8bc:	2823883a 	mov	r17,r5
 820a8c0:	2027883a 	mov	r19,r4
 820a8c4:	1800311e 	bne	r3,zero,820a98c <__sflush_r+0xf0>
 820a8c8:	28c00117 	ldw	r3,4(r5)
 820a8cc:	10820014 	ori	r2,r2,2048
 820a8d0:	2880030d 	sth	r2,12(r5)
 820a8d4:	00c04b0e 	bge	zero,r3,820aa04 <__sflush_r+0x168>
 820a8d8:	8a000a17 	ldw	r8,40(r17)
 820a8dc:	40002326 	beq	r8,zero,820a96c <__sflush_r+0xd0>
 820a8e0:	9c000017 	ldw	r16,0(r19)
 820a8e4:	10c4000c 	andi	r3,r2,4096
 820a8e8:	98000015 	stw	zero,0(r19)
 820a8ec:	18004826 	beq	r3,zero,820aa10 <__sflush_r+0x174>
 820a8f0:	89801417 	ldw	r6,80(r17)
 820a8f4:	10c0010c 	andi	r3,r2,4
 820a8f8:	18000626 	beq	r3,zero,820a914 <__sflush_r+0x78>
 820a8fc:	88c00117 	ldw	r3,4(r17)
 820a900:	88800c17 	ldw	r2,48(r17)
 820a904:	30cdc83a 	sub	r6,r6,r3
 820a908:	10000226 	beq	r2,zero,820a914 <__sflush_r+0x78>
 820a90c:	88800f17 	ldw	r2,60(r17)
 820a910:	308dc83a 	sub	r6,r6,r2
 820a914:	89400717 	ldw	r5,28(r17)
 820a918:	000f883a 	mov	r7,zero
 820a91c:	9809883a 	mov	r4,r19
 820a920:	403ee83a 	callr	r8
 820a924:	00ffffc4 	movi	r3,-1
 820a928:	10c04426 	beq	r2,r3,820aa3c <__sflush_r+0x1a0>
 820a92c:	88c0030b 	ldhu	r3,12(r17)
 820a930:	89000417 	ldw	r4,16(r17)
 820a934:	88000115 	stw	zero,4(r17)
 820a938:	197dffcc 	andi	r5,r3,63487
 820a93c:	8940030d 	sth	r5,12(r17)
 820a940:	89000015 	stw	r4,0(r17)
 820a944:	18c4000c 	andi	r3,r3,4096
 820a948:	18002c1e 	bne	r3,zero,820a9fc <__sflush_r+0x160>
 820a94c:	89400c17 	ldw	r5,48(r17)
 820a950:	9c000015 	stw	r16,0(r19)
 820a954:	28000526 	beq	r5,zero,820a96c <__sflush_r+0xd0>
 820a958:	88801004 	addi	r2,r17,64
 820a95c:	28800226 	beq	r5,r2,820a968 <__sflush_r+0xcc>
 820a960:	9809883a 	mov	r4,r19
 820a964:	820b15c0 	call	820b15c <_free_r>
 820a968:	88000c15 	stw	zero,48(r17)
 820a96c:	0005883a 	mov	r2,zero
 820a970:	dfc00417 	ldw	ra,16(sp)
 820a974:	dcc00317 	ldw	r19,12(sp)
 820a978:	dc800217 	ldw	r18,8(sp)
 820a97c:	dc400117 	ldw	r17,4(sp)
 820a980:	dc000017 	ldw	r16,0(sp)
 820a984:	dec00504 	addi	sp,sp,20
 820a988:	f800283a 	ret
 820a98c:	2c800417 	ldw	r18,16(r5)
 820a990:	903ff626 	beq	r18,zero,820a96c <__sflush_r+0xd0>
 820a994:	2c000017 	ldw	r16,0(r5)
 820a998:	108000cc 	andi	r2,r2,3
 820a99c:	2c800015 	stw	r18,0(r5)
 820a9a0:	84a1c83a 	sub	r16,r16,r18
 820a9a4:	1000131e 	bne	r2,zero,820a9f4 <__sflush_r+0x158>
 820a9a8:	28800517 	ldw	r2,20(r5)
 820a9ac:	88800215 	stw	r2,8(r17)
 820a9b0:	04000316 	blt	zero,r16,820a9c0 <__sflush_r+0x124>
 820a9b4:	003fed06 	br	820a96c <__sflush_r+0xd0>
 820a9b8:	90a5883a 	add	r18,r18,r2
 820a9bc:	043feb0e 	bge	zero,r16,820a96c <__sflush_r+0xd0>
 820a9c0:	88800917 	ldw	r2,36(r17)
 820a9c4:	89400717 	ldw	r5,28(r17)
 820a9c8:	800f883a 	mov	r7,r16
 820a9cc:	900d883a 	mov	r6,r18
 820a9d0:	9809883a 	mov	r4,r19
 820a9d4:	103ee83a 	callr	r2
 820a9d8:	80a1c83a 	sub	r16,r16,r2
 820a9dc:	00bff616 	blt	zero,r2,820a9b8 <__sflush_r+0x11c>
 820a9e0:	88c0030b 	ldhu	r3,12(r17)
 820a9e4:	00bfffc4 	movi	r2,-1
 820a9e8:	18c01014 	ori	r3,r3,64
 820a9ec:	88c0030d 	sth	r3,12(r17)
 820a9f0:	003fdf06 	br	820a970 <__sflush_r+0xd4>
 820a9f4:	0005883a 	mov	r2,zero
 820a9f8:	003fec06 	br	820a9ac <__sflush_r+0x110>
 820a9fc:	88801415 	stw	r2,80(r17)
 820aa00:	003fd206 	br	820a94c <__sflush_r+0xb0>
 820aa04:	28c00f17 	ldw	r3,60(r5)
 820aa08:	00ffb316 	blt	zero,r3,820a8d8 <__sflush_r+0x3c>
 820aa0c:	003fd706 	br	820a96c <__sflush_r+0xd0>
 820aa10:	89400717 	ldw	r5,28(r17)
 820aa14:	000d883a 	mov	r6,zero
 820aa18:	01c00044 	movi	r7,1
 820aa1c:	9809883a 	mov	r4,r19
 820aa20:	403ee83a 	callr	r8
 820aa24:	100d883a 	mov	r6,r2
 820aa28:	00bfffc4 	movi	r2,-1
 820aa2c:	30801426 	beq	r6,r2,820aa80 <__sflush_r+0x1e4>
 820aa30:	8880030b 	ldhu	r2,12(r17)
 820aa34:	8a000a17 	ldw	r8,40(r17)
 820aa38:	003fae06 	br	820a8f4 <__sflush_r+0x58>
 820aa3c:	98c00017 	ldw	r3,0(r19)
 820aa40:	183fba26 	beq	r3,zero,820a92c <__sflush_r+0x90>
 820aa44:	01000744 	movi	r4,29
 820aa48:	19000626 	beq	r3,r4,820aa64 <__sflush_r+0x1c8>
 820aa4c:	01000584 	movi	r4,22
 820aa50:	19000426 	beq	r3,r4,820aa64 <__sflush_r+0x1c8>
 820aa54:	88c0030b 	ldhu	r3,12(r17)
 820aa58:	18c01014 	ori	r3,r3,64
 820aa5c:	88c0030d 	sth	r3,12(r17)
 820aa60:	003fc306 	br	820a970 <__sflush_r+0xd4>
 820aa64:	8880030b 	ldhu	r2,12(r17)
 820aa68:	88c00417 	ldw	r3,16(r17)
 820aa6c:	88000115 	stw	zero,4(r17)
 820aa70:	10bdffcc 	andi	r2,r2,63487
 820aa74:	8880030d 	sth	r2,12(r17)
 820aa78:	88c00015 	stw	r3,0(r17)
 820aa7c:	003fb306 	br	820a94c <__sflush_r+0xb0>
 820aa80:	98800017 	ldw	r2,0(r19)
 820aa84:	103fea26 	beq	r2,zero,820aa30 <__sflush_r+0x194>
 820aa88:	00c00744 	movi	r3,29
 820aa8c:	10c00226 	beq	r2,r3,820aa98 <__sflush_r+0x1fc>
 820aa90:	00c00584 	movi	r3,22
 820aa94:	10c0031e 	bne	r2,r3,820aaa4 <__sflush_r+0x208>
 820aa98:	9c000015 	stw	r16,0(r19)
 820aa9c:	0005883a 	mov	r2,zero
 820aaa0:	003fb306 	br	820a970 <__sflush_r+0xd4>
 820aaa4:	88c0030b 	ldhu	r3,12(r17)
 820aaa8:	3005883a 	mov	r2,r6
 820aaac:	18c01014 	ori	r3,r3,64
 820aab0:	88c0030d 	sth	r3,12(r17)
 820aab4:	003fae06 	br	820a970 <__sflush_r+0xd4>

0820aab8 <_fflush_r>:
 820aab8:	defffd04 	addi	sp,sp,-12
 820aabc:	dc000115 	stw	r16,4(sp)
 820aac0:	dfc00215 	stw	ra,8(sp)
 820aac4:	2021883a 	mov	r16,r4
 820aac8:	20000226 	beq	r4,zero,820aad4 <_fflush_r+0x1c>
 820aacc:	20800e17 	ldw	r2,56(r4)
 820aad0:	10000c26 	beq	r2,zero,820ab04 <_fflush_r+0x4c>
 820aad4:	2880030f 	ldh	r2,12(r5)
 820aad8:	1000051e 	bne	r2,zero,820aaf0 <_fflush_r+0x38>
 820aadc:	0005883a 	mov	r2,zero
 820aae0:	dfc00217 	ldw	ra,8(sp)
 820aae4:	dc000117 	ldw	r16,4(sp)
 820aae8:	dec00304 	addi	sp,sp,12
 820aaec:	f800283a 	ret
 820aaf0:	8009883a 	mov	r4,r16
 820aaf4:	dfc00217 	ldw	ra,8(sp)
 820aaf8:	dc000117 	ldw	r16,4(sp)
 820aafc:	dec00304 	addi	sp,sp,12
 820ab00:	820a89c1 	jmpi	820a89c <__sflush_r>
 820ab04:	d9400015 	stw	r5,0(sp)
 820ab08:	820ae940 	call	820ae94 <__sinit>
 820ab0c:	d9400017 	ldw	r5,0(sp)
 820ab10:	003ff006 	br	820aad4 <_fflush_r+0x1c>

0820ab14 <fflush>:
 820ab14:	20000526 	beq	r4,zero,820ab2c <fflush+0x18>
 820ab18:	00820974 	movhi	r2,2085
 820ab1c:	108fbb04 	addi	r2,r2,16108
 820ab20:	200b883a 	mov	r5,r4
 820ab24:	11000017 	ldw	r4,0(r2)
 820ab28:	820aab81 	jmpi	820aab8 <_fflush_r>
 820ab2c:	00820974 	movhi	r2,2085
 820ab30:	108fba04 	addi	r2,r2,16104
 820ab34:	11000017 	ldw	r4,0(r2)
 820ab38:	01420874 	movhi	r5,2081
 820ab3c:	296aae04 	addi	r5,r5,-21832
 820ab40:	820b9ec1 	jmpi	820b9ec <_fwalk_reent>

0820ab44 <__fp_unlock>:
 820ab44:	0005883a 	mov	r2,zero
 820ab48:	f800283a 	ret

0820ab4c <_cleanup_r>:
 820ab4c:	01420874 	movhi	r5,2081
 820ab50:	29432c04 	addi	r5,r5,3248
 820ab54:	820b9ec1 	jmpi	820b9ec <_fwalk_reent>

0820ab58 <__sinit.part.1>:
 820ab58:	defff704 	addi	sp,sp,-36
 820ab5c:	00c20874 	movhi	r3,2081
 820ab60:	dfc00815 	stw	ra,32(sp)
 820ab64:	ddc00715 	stw	r23,28(sp)
 820ab68:	dd800615 	stw	r22,24(sp)
 820ab6c:	dd400515 	stw	r21,20(sp)
 820ab70:	dd000415 	stw	r20,16(sp)
 820ab74:	dcc00315 	stw	r19,12(sp)
 820ab78:	dc800215 	stw	r18,8(sp)
 820ab7c:	dc400115 	stw	r17,4(sp)
 820ab80:	dc000015 	stw	r16,0(sp)
 820ab84:	18ead304 	addi	r3,r3,-21684
 820ab88:	24000117 	ldw	r16,4(r4)
 820ab8c:	20c00f15 	stw	r3,60(r4)
 820ab90:	2080bb04 	addi	r2,r4,748
 820ab94:	00c000c4 	movi	r3,3
 820ab98:	20c0b915 	stw	r3,740(r4)
 820ab9c:	2080ba15 	stw	r2,744(r4)
 820aba0:	2000b815 	stw	zero,736(r4)
 820aba4:	05c00204 	movi	r23,8
 820aba8:	00800104 	movi	r2,4
 820abac:	2025883a 	mov	r18,r4
 820abb0:	b80d883a 	mov	r6,r23
 820abb4:	81001704 	addi	r4,r16,92
 820abb8:	000b883a 	mov	r5,zero
 820abbc:	80000015 	stw	zero,0(r16)
 820abc0:	80000115 	stw	zero,4(r16)
 820abc4:	80000215 	stw	zero,8(r16)
 820abc8:	8080030d 	sth	r2,12(r16)
 820abcc:	80001915 	stw	zero,100(r16)
 820abd0:	8000038d 	sth	zero,14(r16)
 820abd4:	80000415 	stw	zero,16(r16)
 820abd8:	80000515 	stw	zero,20(r16)
 820abdc:	80000615 	stw	zero,24(r16)
 820abe0:	82032100 	call	8203210 <memset>
 820abe4:	05820874 	movhi	r22,2081
 820abe8:	94400217 	ldw	r17,8(r18)
 820abec:	05420874 	movhi	r21,2081
 820abf0:	05020874 	movhi	r20,2081
 820abf4:	04c20874 	movhi	r19,2081
 820abf8:	b5b7b304 	addi	r22,r22,-8500
 820abfc:	ad77ca04 	addi	r21,r21,-8408
 820ac00:	a537e904 	addi	r20,r20,-8284
 820ac04:	9cf80004 	addi	r19,r19,-8192
 820ac08:	85800815 	stw	r22,32(r16)
 820ac0c:	85400915 	stw	r21,36(r16)
 820ac10:	85000a15 	stw	r20,40(r16)
 820ac14:	84c00b15 	stw	r19,44(r16)
 820ac18:	84000715 	stw	r16,28(r16)
 820ac1c:	00800284 	movi	r2,10
 820ac20:	8880030d 	sth	r2,12(r17)
 820ac24:	00800044 	movi	r2,1
 820ac28:	b80d883a 	mov	r6,r23
 820ac2c:	89001704 	addi	r4,r17,92
 820ac30:	000b883a 	mov	r5,zero
 820ac34:	88000015 	stw	zero,0(r17)
 820ac38:	88000115 	stw	zero,4(r17)
 820ac3c:	88000215 	stw	zero,8(r17)
 820ac40:	88001915 	stw	zero,100(r17)
 820ac44:	8880038d 	sth	r2,14(r17)
 820ac48:	88000415 	stw	zero,16(r17)
 820ac4c:	88000515 	stw	zero,20(r17)
 820ac50:	88000615 	stw	zero,24(r17)
 820ac54:	82032100 	call	8203210 <memset>
 820ac58:	94000317 	ldw	r16,12(r18)
 820ac5c:	00800484 	movi	r2,18
 820ac60:	8c400715 	stw	r17,28(r17)
 820ac64:	8d800815 	stw	r22,32(r17)
 820ac68:	8d400915 	stw	r21,36(r17)
 820ac6c:	8d000a15 	stw	r20,40(r17)
 820ac70:	8cc00b15 	stw	r19,44(r17)
 820ac74:	8080030d 	sth	r2,12(r16)
 820ac78:	00800084 	movi	r2,2
 820ac7c:	80000015 	stw	zero,0(r16)
 820ac80:	80000115 	stw	zero,4(r16)
 820ac84:	80000215 	stw	zero,8(r16)
 820ac88:	80001915 	stw	zero,100(r16)
 820ac8c:	8080038d 	sth	r2,14(r16)
 820ac90:	80000415 	stw	zero,16(r16)
 820ac94:	80000515 	stw	zero,20(r16)
 820ac98:	80000615 	stw	zero,24(r16)
 820ac9c:	b80d883a 	mov	r6,r23
 820aca0:	000b883a 	mov	r5,zero
 820aca4:	81001704 	addi	r4,r16,92
 820aca8:	82032100 	call	8203210 <memset>
 820acac:	00800044 	movi	r2,1
 820acb0:	84000715 	stw	r16,28(r16)
 820acb4:	85800815 	stw	r22,32(r16)
 820acb8:	85400915 	stw	r21,36(r16)
 820acbc:	85000a15 	stw	r20,40(r16)
 820acc0:	84c00b15 	stw	r19,44(r16)
 820acc4:	90800e15 	stw	r2,56(r18)
 820acc8:	dfc00817 	ldw	ra,32(sp)
 820accc:	ddc00717 	ldw	r23,28(sp)
 820acd0:	dd800617 	ldw	r22,24(sp)
 820acd4:	dd400517 	ldw	r21,20(sp)
 820acd8:	dd000417 	ldw	r20,16(sp)
 820acdc:	dcc00317 	ldw	r19,12(sp)
 820ace0:	dc800217 	ldw	r18,8(sp)
 820ace4:	dc400117 	ldw	r17,4(sp)
 820ace8:	dc000017 	ldw	r16,0(sp)
 820acec:	dec00904 	addi	sp,sp,36
 820acf0:	f800283a 	ret

0820acf4 <__fp_lock>:
 820acf4:	0005883a 	mov	r2,zero
 820acf8:	f800283a 	ret

0820acfc <__sfmoreglue>:
 820acfc:	defffc04 	addi	sp,sp,-16
 820ad00:	dc400115 	stw	r17,4(sp)
 820ad04:	2c7fffc4 	addi	r17,r5,-1
 820ad08:	8c401a24 	muli	r17,r17,104
 820ad0c:	dc800215 	stw	r18,8(sp)
 820ad10:	2825883a 	mov	r18,r5
 820ad14:	89401d04 	addi	r5,r17,116
 820ad18:	dc000015 	stw	r16,0(sp)
 820ad1c:	dfc00315 	stw	ra,12(sp)
 820ad20:	820bd480 	call	820bd48 <_malloc_r>
 820ad24:	1021883a 	mov	r16,r2
 820ad28:	10000726 	beq	r2,zero,820ad48 <__sfmoreglue+0x4c>
 820ad2c:	11000304 	addi	r4,r2,12
 820ad30:	10000015 	stw	zero,0(r2)
 820ad34:	14800115 	stw	r18,4(r2)
 820ad38:	11000215 	stw	r4,8(r2)
 820ad3c:	89801a04 	addi	r6,r17,104
 820ad40:	000b883a 	mov	r5,zero
 820ad44:	82032100 	call	8203210 <memset>
 820ad48:	8005883a 	mov	r2,r16
 820ad4c:	dfc00317 	ldw	ra,12(sp)
 820ad50:	dc800217 	ldw	r18,8(sp)
 820ad54:	dc400117 	ldw	r17,4(sp)
 820ad58:	dc000017 	ldw	r16,0(sp)
 820ad5c:	dec00404 	addi	sp,sp,16
 820ad60:	f800283a 	ret

0820ad64 <__sfp>:
 820ad64:	defffb04 	addi	sp,sp,-20
 820ad68:	dc000015 	stw	r16,0(sp)
 820ad6c:	04020974 	movhi	r16,2085
 820ad70:	840fba04 	addi	r16,r16,16104
 820ad74:	dcc00315 	stw	r19,12(sp)
 820ad78:	2027883a 	mov	r19,r4
 820ad7c:	81000017 	ldw	r4,0(r16)
 820ad80:	dfc00415 	stw	ra,16(sp)
 820ad84:	dc800215 	stw	r18,8(sp)
 820ad88:	20800e17 	ldw	r2,56(r4)
 820ad8c:	dc400115 	stw	r17,4(sp)
 820ad90:	1000021e 	bne	r2,zero,820ad9c <__sfp+0x38>
 820ad94:	820ab580 	call	820ab58 <__sinit.part.1>
 820ad98:	81000017 	ldw	r4,0(r16)
 820ad9c:	2480b804 	addi	r18,r4,736
 820ada0:	047fffc4 	movi	r17,-1
 820ada4:	91000117 	ldw	r4,4(r18)
 820ada8:	94000217 	ldw	r16,8(r18)
 820adac:	213fffc4 	addi	r4,r4,-1
 820adb0:	20000a16 	blt	r4,zero,820addc <__sfp+0x78>
 820adb4:	8080030f 	ldh	r2,12(r16)
 820adb8:	10000c26 	beq	r2,zero,820adec <__sfp+0x88>
 820adbc:	80c01d04 	addi	r3,r16,116
 820adc0:	00000206 	br	820adcc <__sfp+0x68>
 820adc4:	18bfe60f 	ldh	r2,-104(r3)
 820adc8:	10000826 	beq	r2,zero,820adec <__sfp+0x88>
 820adcc:	213fffc4 	addi	r4,r4,-1
 820add0:	1c3ffd04 	addi	r16,r3,-12
 820add4:	18c01a04 	addi	r3,r3,104
 820add8:	247ffa1e 	bne	r4,r17,820adc4 <__sfp+0x60>
 820addc:	90800017 	ldw	r2,0(r18)
 820ade0:	10001d26 	beq	r2,zero,820ae58 <__sfp+0xf4>
 820ade4:	1025883a 	mov	r18,r2
 820ade8:	003fee06 	br	820ada4 <__sfp+0x40>
 820adec:	00bfffc4 	movi	r2,-1
 820adf0:	8080038d 	sth	r2,14(r16)
 820adf4:	00800044 	movi	r2,1
 820adf8:	8080030d 	sth	r2,12(r16)
 820adfc:	80001915 	stw	zero,100(r16)
 820ae00:	80000015 	stw	zero,0(r16)
 820ae04:	80000215 	stw	zero,8(r16)
 820ae08:	80000115 	stw	zero,4(r16)
 820ae0c:	80000415 	stw	zero,16(r16)
 820ae10:	80000515 	stw	zero,20(r16)
 820ae14:	80000615 	stw	zero,24(r16)
 820ae18:	01800204 	movi	r6,8
 820ae1c:	000b883a 	mov	r5,zero
 820ae20:	81001704 	addi	r4,r16,92
 820ae24:	82032100 	call	8203210 <memset>
 820ae28:	8005883a 	mov	r2,r16
 820ae2c:	80000c15 	stw	zero,48(r16)
 820ae30:	80000d15 	stw	zero,52(r16)
 820ae34:	80001115 	stw	zero,68(r16)
 820ae38:	80001215 	stw	zero,72(r16)
 820ae3c:	dfc00417 	ldw	ra,16(sp)
 820ae40:	dcc00317 	ldw	r19,12(sp)
 820ae44:	dc800217 	ldw	r18,8(sp)
 820ae48:	dc400117 	ldw	r17,4(sp)
 820ae4c:	dc000017 	ldw	r16,0(sp)
 820ae50:	dec00504 	addi	sp,sp,20
 820ae54:	f800283a 	ret
 820ae58:	01400104 	movi	r5,4
 820ae5c:	9809883a 	mov	r4,r19
 820ae60:	820acfc0 	call	820acfc <__sfmoreglue>
 820ae64:	90800015 	stw	r2,0(r18)
 820ae68:	103fde1e 	bne	r2,zero,820ade4 <__sfp+0x80>
 820ae6c:	00800304 	movi	r2,12
 820ae70:	98800015 	stw	r2,0(r19)
 820ae74:	0005883a 	mov	r2,zero
 820ae78:	003ff006 	br	820ae3c <__sfp+0xd8>

0820ae7c <_cleanup>:
 820ae7c:	00820974 	movhi	r2,2085
 820ae80:	108fba04 	addi	r2,r2,16104
 820ae84:	11000017 	ldw	r4,0(r2)
 820ae88:	01420874 	movhi	r5,2081
 820ae8c:	29432c04 	addi	r5,r5,3248
 820ae90:	820b9ec1 	jmpi	820b9ec <_fwalk_reent>

0820ae94 <__sinit>:
 820ae94:	20800e17 	ldw	r2,56(r4)
 820ae98:	10000126 	beq	r2,zero,820aea0 <__sinit+0xc>
 820ae9c:	f800283a 	ret
 820aea0:	820ab581 	jmpi	820ab58 <__sinit.part.1>

0820aea4 <__sfp_lock_acquire>:
 820aea4:	f800283a 	ret

0820aea8 <__sfp_lock_release>:
 820aea8:	f800283a 	ret

0820aeac <__sinit_lock_acquire>:
 820aeac:	f800283a 	ret

0820aeb0 <__sinit_lock_release>:
 820aeb0:	f800283a 	ret

0820aeb4 <__fp_lock_all>:
 820aeb4:	00820974 	movhi	r2,2085
 820aeb8:	108fbb04 	addi	r2,r2,16108
 820aebc:	11000017 	ldw	r4,0(r2)
 820aec0:	01420874 	movhi	r5,2081
 820aec4:	296b3d04 	addi	r5,r5,-21260
 820aec8:	820b9281 	jmpi	820b928 <_fwalk>

0820aecc <__fp_unlock_all>:
 820aecc:	00820974 	movhi	r2,2085
 820aed0:	108fbb04 	addi	r2,r2,16108
 820aed4:	11000017 	ldw	r4,0(r2)
 820aed8:	01420874 	movhi	r5,2081
 820aedc:	296ad104 	addi	r5,r5,-21692
 820aee0:	820b9281 	jmpi	820b928 <_fwalk>

0820aee4 <_fputc_r>:
 820aee4:	defffc04 	addi	sp,sp,-16
 820aee8:	dc000215 	stw	r16,8(sp)
 820aeec:	dfc00315 	stw	ra,12(sp)
 820aef0:	2021883a 	mov	r16,r4
 820aef4:	20000726 	beq	r4,zero,820af14 <_fputc_r+0x30>
 820aef8:	20800e17 	ldw	r2,56(r4)
 820aefc:	1000051e 	bne	r2,zero,820af14 <_fputc_r+0x30>
 820af00:	d9400015 	stw	r5,0(sp)
 820af04:	d9800115 	stw	r6,4(sp)
 820af08:	820ae940 	call	820ae94 <__sinit>
 820af0c:	d9800117 	ldw	r6,4(sp)
 820af10:	d9400017 	ldw	r5,0(sp)
 820af14:	8009883a 	mov	r4,r16
 820af18:	dfc00317 	ldw	ra,12(sp)
 820af1c:	dc000217 	ldw	r16,8(sp)
 820af20:	dec00404 	addi	sp,sp,16
 820af24:	82034381 	jmpi	8203438 <_putc_r>

0820af28 <fputc>:
 820af28:	00820974 	movhi	r2,2085
 820af2c:	defffc04 	addi	sp,sp,-16
 820af30:	108fbb04 	addi	r2,r2,16108
 820af34:	dc000115 	stw	r16,4(sp)
 820af38:	14000017 	ldw	r16,0(r2)
 820af3c:	dc400215 	stw	r17,8(sp)
 820af40:	dfc00315 	stw	ra,12(sp)
 820af44:	2023883a 	mov	r17,r4
 820af48:	80000626 	beq	r16,zero,820af64 <fputc+0x3c>
 820af4c:	80800e17 	ldw	r2,56(r16)
 820af50:	1000041e 	bne	r2,zero,820af64 <fputc+0x3c>
 820af54:	8009883a 	mov	r4,r16
 820af58:	d9400015 	stw	r5,0(sp)
 820af5c:	820ae940 	call	820ae94 <__sinit>
 820af60:	d9400017 	ldw	r5,0(sp)
 820af64:	280d883a 	mov	r6,r5
 820af68:	8009883a 	mov	r4,r16
 820af6c:	880b883a 	mov	r5,r17
 820af70:	dfc00317 	ldw	ra,12(sp)
 820af74:	dc400217 	ldw	r17,8(sp)
 820af78:	dc000117 	ldw	r16,4(sp)
 820af7c:	dec00404 	addi	sp,sp,16
 820af80:	82034381 	jmpi	8203438 <_putc_r>

0820af84 <_fputs_r>:
 820af84:	defff804 	addi	sp,sp,-32
 820af88:	dc400615 	stw	r17,24(sp)
 820af8c:	2023883a 	mov	r17,r4
 820af90:	2809883a 	mov	r4,r5
 820af94:	dc000515 	stw	r16,20(sp)
 820af98:	dfc00715 	stw	ra,28(sp)
 820af9c:	3021883a 	mov	r16,r6
 820afa0:	d9400315 	stw	r5,12(sp)
 820afa4:	8203fbc0 	call	8203fbc <strlen>
 820afa8:	d8800215 	stw	r2,8(sp)
 820afac:	d8800415 	stw	r2,16(sp)
 820afb0:	d8800304 	addi	r2,sp,12
 820afb4:	d8800015 	stw	r2,0(sp)
 820afb8:	00800044 	movi	r2,1
 820afbc:	d8800115 	stw	r2,4(sp)
 820afc0:	88000226 	beq	r17,zero,820afcc <_fputs_r+0x48>
 820afc4:	88800e17 	ldw	r2,56(r17)
 820afc8:	10001226 	beq	r2,zero,820b014 <_fputs_r+0x90>
 820afcc:	8080030b 	ldhu	r2,12(r16)
 820afd0:	10c8000c 	andi	r3,r2,8192
 820afd4:	1800061e 	bne	r3,zero,820aff0 <_fputs_r+0x6c>
 820afd8:	81001917 	ldw	r4,100(r16)
 820afdc:	00f7ffc4 	movi	r3,-8193
 820afe0:	10880014 	ori	r2,r2,8192
 820afe4:	20c6703a 	and	r3,r4,r3
 820afe8:	8080030d 	sth	r2,12(r16)
 820afec:	80c01915 	stw	r3,100(r16)
 820aff0:	d80d883a 	mov	r6,sp
 820aff4:	800b883a 	mov	r5,r16
 820aff8:	8809883a 	mov	r4,r17
 820affc:	820b46c0 	call	820b46c <__sfvwrite_r>
 820b000:	dfc00717 	ldw	ra,28(sp)
 820b004:	dc400617 	ldw	r17,24(sp)
 820b008:	dc000517 	ldw	r16,20(sp)
 820b00c:	dec00804 	addi	sp,sp,32
 820b010:	f800283a 	ret
 820b014:	8809883a 	mov	r4,r17
 820b018:	820ae940 	call	820ae94 <__sinit>
 820b01c:	003feb06 	br	820afcc <_fputs_r+0x48>

0820b020 <fputs>:
 820b020:	00820974 	movhi	r2,2085
 820b024:	108fbb04 	addi	r2,r2,16108
 820b028:	280d883a 	mov	r6,r5
 820b02c:	200b883a 	mov	r5,r4
 820b030:	11000017 	ldw	r4,0(r2)
 820b034:	820af841 	jmpi	820af84 <_fputs_r>

0820b038 <_malloc_trim_r>:
 820b038:	defffb04 	addi	sp,sp,-20
 820b03c:	dcc00315 	stw	r19,12(sp)
 820b040:	04c20974 	movhi	r19,2085
 820b044:	dc800215 	stw	r18,8(sp)
 820b048:	dc400115 	stw	r17,4(sp)
 820b04c:	dc000015 	stw	r16,0(sp)
 820b050:	dfc00415 	stw	ra,16(sp)
 820b054:	2821883a 	mov	r16,r5
 820b058:	9cc94904 	addi	r19,r19,9508
 820b05c:	2025883a 	mov	r18,r4
 820b060:	8214a540 	call	8214a54 <__malloc_lock>
 820b064:	98800217 	ldw	r2,8(r19)
 820b068:	14400117 	ldw	r17,4(r2)
 820b06c:	00bfff04 	movi	r2,-4
 820b070:	88a2703a 	and	r17,r17,r2
 820b074:	8c21c83a 	sub	r16,r17,r16
 820b078:	8403fbc4 	addi	r16,r16,4079
 820b07c:	8020d33a 	srli	r16,r16,12
 820b080:	0083ffc4 	movi	r2,4095
 820b084:	843fffc4 	addi	r16,r16,-1
 820b088:	8020933a 	slli	r16,r16,12
 820b08c:	1400060e 	bge	r2,r16,820b0a8 <_malloc_trim_r+0x70>
 820b090:	000b883a 	mov	r5,zero
 820b094:	9009883a 	mov	r4,r18
 820b098:	820de780 	call	820de78 <_sbrk_r>
 820b09c:	98c00217 	ldw	r3,8(r19)
 820b0a0:	1c47883a 	add	r3,r3,r17
 820b0a4:	10c00a26 	beq	r2,r3,820b0d0 <_malloc_trim_r+0x98>
 820b0a8:	9009883a 	mov	r4,r18
 820b0ac:	8214b740 	call	8214b74 <__malloc_unlock>
 820b0b0:	0005883a 	mov	r2,zero
 820b0b4:	dfc00417 	ldw	ra,16(sp)
 820b0b8:	dcc00317 	ldw	r19,12(sp)
 820b0bc:	dc800217 	ldw	r18,8(sp)
 820b0c0:	dc400117 	ldw	r17,4(sp)
 820b0c4:	dc000017 	ldw	r16,0(sp)
 820b0c8:	dec00504 	addi	sp,sp,20
 820b0cc:	f800283a 	ret
 820b0d0:	040bc83a 	sub	r5,zero,r16
 820b0d4:	9009883a 	mov	r4,r18
 820b0d8:	820de780 	call	820de78 <_sbrk_r>
 820b0dc:	00ffffc4 	movi	r3,-1
 820b0e0:	10c00d26 	beq	r2,r3,820b118 <_malloc_trim_r+0xe0>
 820b0e4:	00c20974 	movhi	r3,2085
 820b0e8:	18d21204 	addi	r3,r3,18504
 820b0ec:	18800017 	ldw	r2,0(r3)
 820b0f0:	99000217 	ldw	r4,8(r19)
 820b0f4:	8c23c83a 	sub	r17,r17,r16
 820b0f8:	8c400054 	ori	r17,r17,1
 820b0fc:	1421c83a 	sub	r16,r2,r16
 820b100:	24400115 	stw	r17,4(r4)
 820b104:	9009883a 	mov	r4,r18
 820b108:	1c000015 	stw	r16,0(r3)
 820b10c:	8214b740 	call	8214b74 <__malloc_unlock>
 820b110:	00800044 	movi	r2,1
 820b114:	003fe706 	br	820b0b4 <_malloc_trim_r+0x7c>
 820b118:	000b883a 	mov	r5,zero
 820b11c:	9009883a 	mov	r4,r18
 820b120:	820de780 	call	820de78 <_sbrk_r>
 820b124:	99000217 	ldw	r4,8(r19)
 820b128:	014003c4 	movi	r5,15
 820b12c:	1107c83a 	sub	r3,r2,r4
 820b130:	28ffdd0e 	bge	r5,r3,820b0a8 <_malloc_trim_r+0x70>
 820b134:	01420974 	movhi	r5,2085
 820b138:	294fbd04 	addi	r5,r5,16116
 820b13c:	29400017 	ldw	r5,0(r5)
 820b140:	18c00054 	ori	r3,r3,1
 820b144:	20c00115 	stw	r3,4(r4)
 820b148:	00c20974 	movhi	r3,2085
 820b14c:	1145c83a 	sub	r2,r2,r5
 820b150:	18d21204 	addi	r3,r3,18504
 820b154:	18800015 	stw	r2,0(r3)
 820b158:	003fd306 	br	820b0a8 <_malloc_trim_r+0x70>

0820b15c <_free_r>:
 820b15c:	28004126 	beq	r5,zero,820b264 <_free_r+0x108>
 820b160:	defffd04 	addi	sp,sp,-12
 820b164:	dc400115 	stw	r17,4(sp)
 820b168:	dc000015 	stw	r16,0(sp)
 820b16c:	2023883a 	mov	r17,r4
 820b170:	2821883a 	mov	r16,r5
 820b174:	dfc00215 	stw	ra,8(sp)
 820b178:	8214a540 	call	8214a54 <__malloc_lock>
 820b17c:	81ffff17 	ldw	r7,-4(r16)
 820b180:	00bfff84 	movi	r2,-2
 820b184:	01020974 	movhi	r4,2085
 820b188:	81bffe04 	addi	r6,r16,-8
 820b18c:	3884703a 	and	r2,r7,r2
 820b190:	21094904 	addi	r4,r4,9508
 820b194:	308b883a 	add	r5,r6,r2
 820b198:	2a400117 	ldw	r9,4(r5)
 820b19c:	22000217 	ldw	r8,8(r4)
 820b1a0:	00ffff04 	movi	r3,-4
 820b1a4:	48c6703a 	and	r3,r9,r3
 820b1a8:	2a005726 	beq	r5,r8,820b308 <_free_r+0x1ac>
 820b1ac:	28c00115 	stw	r3,4(r5)
 820b1b0:	39c0004c 	andi	r7,r7,1
 820b1b4:	3800091e 	bne	r7,zero,820b1dc <_free_r+0x80>
 820b1b8:	823ffe17 	ldw	r8,-8(r16)
 820b1bc:	22400204 	addi	r9,r4,8
 820b1c0:	320dc83a 	sub	r6,r6,r8
 820b1c4:	31c00217 	ldw	r7,8(r6)
 820b1c8:	1205883a 	add	r2,r2,r8
 820b1cc:	3a406526 	beq	r7,r9,820b364 <_free_r+0x208>
 820b1d0:	32000317 	ldw	r8,12(r6)
 820b1d4:	3a000315 	stw	r8,12(r7)
 820b1d8:	41c00215 	stw	r7,8(r8)
 820b1dc:	28cf883a 	add	r7,r5,r3
 820b1e0:	39c00117 	ldw	r7,4(r7)
 820b1e4:	39c0004c 	andi	r7,r7,1
 820b1e8:	38003a26 	beq	r7,zero,820b2d4 <_free_r+0x178>
 820b1ec:	10c00054 	ori	r3,r2,1
 820b1f0:	30c00115 	stw	r3,4(r6)
 820b1f4:	3087883a 	add	r3,r6,r2
 820b1f8:	18800015 	stw	r2,0(r3)
 820b1fc:	00c07fc4 	movi	r3,511
 820b200:	18801936 	bltu	r3,r2,820b268 <_free_r+0x10c>
 820b204:	1004d0fa 	srli	r2,r2,3
 820b208:	01c00044 	movi	r7,1
 820b20c:	21400117 	ldw	r5,4(r4)
 820b210:	10c00044 	addi	r3,r2,1
 820b214:	18c7883a 	add	r3,r3,r3
 820b218:	1005d0ba 	srai	r2,r2,2
 820b21c:	18c7883a 	add	r3,r3,r3
 820b220:	18c7883a 	add	r3,r3,r3
 820b224:	1907883a 	add	r3,r3,r4
 820b228:	3884983a 	sll	r2,r7,r2
 820b22c:	19c00017 	ldw	r7,0(r3)
 820b230:	1a3ffe04 	addi	r8,r3,-8
 820b234:	1144b03a 	or	r2,r2,r5
 820b238:	32000315 	stw	r8,12(r6)
 820b23c:	31c00215 	stw	r7,8(r6)
 820b240:	20800115 	stw	r2,4(r4)
 820b244:	19800015 	stw	r6,0(r3)
 820b248:	39800315 	stw	r6,12(r7)
 820b24c:	8809883a 	mov	r4,r17
 820b250:	dfc00217 	ldw	ra,8(sp)
 820b254:	dc400117 	ldw	r17,4(sp)
 820b258:	dc000017 	ldw	r16,0(sp)
 820b25c:	dec00304 	addi	sp,sp,12
 820b260:	8214b741 	jmpi	8214b74 <__malloc_unlock>
 820b264:	f800283a 	ret
 820b268:	100ad27a 	srli	r5,r2,9
 820b26c:	00c00104 	movi	r3,4
 820b270:	19404a36 	bltu	r3,r5,820b39c <_free_r+0x240>
 820b274:	100ad1ba 	srli	r5,r2,6
 820b278:	28c00e44 	addi	r3,r5,57
 820b27c:	18c7883a 	add	r3,r3,r3
 820b280:	29400e04 	addi	r5,r5,56
 820b284:	18c7883a 	add	r3,r3,r3
 820b288:	18c7883a 	add	r3,r3,r3
 820b28c:	1909883a 	add	r4,r3,r4
 820b290:	20c00017 	ldw	r3,0(r4)
 820b294:	01c20974 	movhi	r7,2085
 820b298:	213ffe04 	addi	r4,r4,-8
 820b29c:	39c94904 	addi	r7,r7,9508
 820b2a0:	20c04426 	beq	r4,r3,820b3b4 <_free_r+0x258>
 820b2a4:	01ffff04 	movi	r7,-4
 820b2a8:	19400117 	ldw	r5,4(r3)
 820b2ac:	29ca703a 	and	r5,r5,r7
 820b2b0:	1140022e 	bgeu	r2,r5,820b2bc <_free_r+0x160>
 820b2b4:	18c00217 	ldw	r3,8(r3)
 820b2b8:	20fffb1e 	bne	r4,r3,820b2a8 <_free_r+0x14c>
 820b2bc:	19000317 	ldw	r4,12(r3)
 820b2c0:	31000315 	stw	r4,12(r6)
 820b2c4:	30c00215 	stw	r3,8(r6)
 820b2c8:	21800215 	stw	r6,8(r4)
 820b2cc:	19800315 	stw	r6,12(r3)
 820b2d0:	003fde06 	br	820b24c <_free_r+0xf0>
 820b2d4:	29c00217 	ldw	r7,8(r5)
 820b2d8:	10c5883a 	add	r2,r2,r3
 820b2dc:	00c20974 	movhi	r3,2085
 820b2e0:	18c94b04 	addi	r3,r3,9516
 820b2e4:	38c03b26 	beq	r7,r3,820b3d4 <_free_r+0x278>
 820b2e8:	2a000317 	ldw	r8,12(r5)
 820b2ec:	11400054 	ori	r5,r2,1
 820b2f0:	3087883a 	add	r3,r6,r2
 820b2f4:	3a000315 	stw	r8,12(r7)
 820b2f8:	41c00215 	stw	r7,8(r8)
 820b2fc:	31400115 	stw	r5,4(r6)
 820b300:	18800015 	stw	r2,0(r3)
 820b304:	003fbd06 	br	820b1fc <_free_r+0xa0>
 820b308:	39c0004c 	andi	r7,r7,1
 820b30c:	10c5883a 	add	r2,r2,r3
 820b310:	3800071e 	bne	r7,zero,820b330 <_free_r+0x1d4>
 820b314:	81fffe17 	ldw	r7,-8(r16)
 820b318:	31cdc83a 	sub	r6,r6,r7
 820b31c:	30c00317 	ldw	r3,12(r6)
 820b320:	31400217 	ldw	r5,8(r6)
 820b324:	11c5883a 	add	r2,r2,r7
 820b328:	28c00315 	stw	r3,12(r5)
 820b32c:	19400215 	stw	r5,8(r3)
 820b330:	10c00054 	ori	r3,r2,1
 820b334:	30c00115 	stw	r3,4(r6)
 820b338:	00c20974 	movhi	r3,2085
 820b33c:	18cfbe04 	addi	r3,r3,16120
 820b340:	18c00017 	ldw	r3,0(r3)
 820b344:	21800215 	stw	r6,8(r4)
 820b348:	10ffc036 	bltu	r2,r3,820b24c <_free_r+0xf0>
 820b34c:	00820974 	movhi	r2,2085
 820b350:	10901b04 	addi	r2,r2,16492
 820b354:	11400017 	ldw	r5,0(r2)
 820b358:	8809883a 	mov	r4,r17
 820b35c:	820b0380 	call	820b038 <_malloc_trim_r>
 820b360:	003fba06 	br	820b24c <_free_r+0xf0>
 820b364:	28c9883a 	add	r4,r5,r3
 820b368:	21000117 	ldw	r4,4(r4)
 820b36c:	2100004c 	andi	r4,r4,1
 820b370:	2000391e 	bne	r4,zero,820b458 <_free_r+0x2fc>
 820b374:	29c00217 	ldw	r7,8(r5)
 820b378:	29000317 	ldw	r4,12(r5)
 820b37c:	1885883a 	add	r2,r3,r2
 820b380:	10c00054 	ori	r3,r2,1
 820b384:	39000315 	stw	r4,12(r7)
 820b388:	21c00215 	stw	r7,8(r4)
 820b38c:	30c00115 	stw	r3,4(r6)
 820b390:	308d883a 	add	r6,r6,r2
 820b394:	30800015 	stw	r2,0(r6)
 820b398:	003fac06 	br	820b24c <_free_r+0xf0>
 820b39c:	00c00504 	movi	r3,20
 820b3a0:	19401536 	bltu	r3,r5,820b3f8 <_free_r+0x29c>
 820b3a4:	28c01704 	addi	r3,r5,92
 820b3a8:	18c7883a 	add	r3,r3,r3
 820b3ac:	294016c4 	addi	r5,r5,91
 820b3b0:	003fb406 	br	820b284 <_free_r+0x128>
 820b3b4:	280bd0ba 	srai	r5,r5,2
 820b3b8:	00c00044 	movi	r3,1
 820b3bc:	38800117 	ldw	r2,4(r7)
 820b3c0:	194a983a 	sll	r5,r3,r5
 820b3c4:	2007883a 	mov	r3,r4
 820b3c8:	2884b03a 	or	r2,r5,r2
 820b3cc:	38800115 	stw	r2,4(r7)
 820b3d0:	003fbb06 	br	820b2c0 <_free_r+0x164>
 820b3d4:	21800515 	stw	r6,20(r4)
 820b3d8:	21800415 	stw	r6,16(r4)
 820b3dc:	10c00054 	ori	r3,r2,1
 820b3e0:	31c00315 	stw	r7,12(r6)
 820b3e4:	31c00215 	stw	r7,8(r6)
 820b3e8:	30c00115 	stw	r3,4(r6)
 820b3ec:	308d883a 	add	r6,r6,r2
 820b3f0:	30800015 	stw	r2,0(r6)
 820b3f4:	003f9506 	br	820b24c <_free_r+0xf0>
 820b3f8:	00c01504 	movi	r3,84
 820b3fc:	19400536 	bltu	r3,r5,820b414 <_free_r+0x2b8>
 820b400:	100ad33a 	srli	r5,r2,12
 820b404:	28c01bc4 	addi	r3,r5,111
 820b408:	18c7883a 	add	r3,r3,r3
 820b40c:	29401b84 	addi	r5,r5,110
 820b410:	003f9c06 	br	820b284 <_free_r+0x128>
 820b414:	00c05504 	movi	r3,340
 820b418:	19400536 	bltu	r3,r5,820b430 <_free_r+0x2d4>
 820b41c:	100ad3fa 	srli	r5,r2,15
 820b420:	28c01e04 	addi	r3,r5,120
 820b424:	18c7883a 	add	r3,r3,r3
 820b428:	29401dc4 	addi	r5,r5,119
 820b42c:	003f9506 	br	820b284 <_free_r+0x128>
 820b430:	00c15504 	movi	r3,1364
 820b434:	19400536 	bltu	r3,r5,820b44c <_free_r+0x2f0>
 820b438:	100ad4ba 	srli	r5,r2,18
 820b43c:	28c01f44 	addi	r3,r5,125
 820b440:	18c7883a 	add	r3,r3,r3
 820b444:	29401f04 	addi	r5,r5,124
 820b448:	003f8e06 	br	820b284 <_free_r+0x128>
 820b44c:	00c03f84 	movi	r3,254
 820b450:	01401f84 	movi	r5,126
 820b454:	003f8b06 	br	820b284 <_free_r+0x128>
 820b458:	10c00054 	ori	r3,r2,1
 820b45c:	30c00115 	stw	r3,4(r6)
 820b460:	308d883a 	add	r6,r6,r2
 820b464:	30800015 	stw	r2,0(r6)
 820b468:	003f7806 	br	820b24c <_free_r+0xf0>

0820b46c <__sfvwrite_r>:
 820b46c:	30800217 	ldw	r2,8(r6)
 820b470:	10006726 	beq	r2,zero,820b610 <__sfvwrite_r+0x1a4>
 820b474:	28c0030b 	ldhu	r3,12(r5)
 820b478:	defff404 	addi	sp,sp,-48
 820b47c:	dd400715 	stw	r21,28(sp)
 820b480:	dd000615 	stw	r20,24(sp)
 820b484:	dc000215 	stw	r16,8(sp)
 820b488:	dfc00b15 	stw	ra,44(sp)
 820b48c:	df000a15 	stw	fp,40(sp)
 820b490:	ddc00915 	stw	r23,36(sp)
 820b494:	dd800815 	stw	r22,32(sp)
 820b498:	dcc00515 	stw	r19,20(sp)
 820b49c:	dc800415 	stw	r18,16(sp)
 820b4a0:	dc400315 	stw	r17,12(sp)
 820b4a4:	1880020c 	andi	r2,r3,8
 820b4a8:	2821883a 	mov	r16,r5
 820b4ac:	202b883a 	mov	r21,r4
 820b4b0:	3029883a 	mov	r20,r6
 820b4b4:	10002726 	beq	r2,zero,820b554 <__sfvwrite_r+0xe8>
 820b4b8:	28800417 	ldw	r2,16(r5)
 820b4bc:	10002526 	beq	r2,zero,820b554 <__sfvwrite_r+0xe8>
 820b4c0:	1880008c 	andi	r2,r3,2
 820b4c4:	a4400017 	ldw	r17,0(r20)
 820b4c8:	10002a26 	beq	r2,zero,820b574 <__sfvwrite_r+0x108>
 820b4cc:	05a00034 	movhi	r22,32768
 820b4d0:	0027883a 	mov	r19,zero
 820b4d4:	0025883a 	mov	r18,zero
 820b4d8:	b5bf0004 	addi	r22,r22,-1024
 820b4dc:	980d883a 	mov	r6,r19
 820b4e0:	a809883a 	mov	r4,r21
 820b4e4:	90004626 	beq	r18,zero,820b600 <__sfvwrite_r+0x194>
 820b4e8:	900f883a 	mov	r7,r18
 820b4ec:	b480022e 	bgeu	r22,r18,820b4f8 <__sfvwrite_r+0x8c>
 820b4f0:	01e00034 	movhi	r7,32768
 820b4f4:	39ff0004 	addi	r7,r7,-1024
 820b4f8:	80800917 	ldw	r2,36(r16)
 820b4fc:	81400717 	ldw	r5,28(r16)
 820b500:	103ee83a 	callr	r2
 820b504:	0080570e 	bge	zero,r2,820b664 <__sfvwrite_r+0x1f8>
 820b508:	a0c00217 	ldw	r3,8(r20)
 820b50c:	98a7883a 	add	r19,r19,r2
 820b510:	90a5c83a 	sub	r18,r18,r2
 820b514:	1885c83a 	sub	r2,r3,r2
 820b518:	a0800215 	stw	r2,8(r20)
 820b51c:	103fef1e 	bne	r2,zero,820b4dc <__sfvwrite_r+0x70>
 820b520:	0005883a 	mov	r2,zero
 820b524:	dfc00b17 	ldw	ra,44(sp)
 820b528:	df000a17 	ldw	fp,40(sp)
 820b52c:	ddc00917 	ldw	r23,36(sp)
 820b530:	dd800817 	ldw	r22,32(sp)
 820b534:	dd400717 	ldw	r21,28(sp)
 820b538:	dd000617 	ldw	r20,24(sp)
 820b53c:	dcc00517 	ldw	r19,20(sp)
 820b540:	dc800417 	ldw	r18,16(sp)
 820b544:	dc400317 	ldw	r17,12(sp)
 820b548:	dc000217 	ldw	r16,8(sp)
 820b54c:	dec00c04 	addi	sp,sp,48
 820b550:	f800283a 	ret
 820b554:	800b883a 	mov	r5,r16
 820b558:	a809883a 	mov	r4,r21
 820b55c:	8208ec00 	call	8208ec0 <__swsetup_r>
 820b560:	1000eb1e 	bne	r2,zero,820b910 <__sfvwrite_r+0x4a4>
 820b564:	80c0030b 	ldhu	r3,12(r16)
 820b568:	a4400017 	ldw	r17,0(r20)
 820b56c:	1880008c 	andi	r2,r3,2
 820b570:	103fd61e 	bne	r2,zero,820b4cc <__sfvwrite_r+0x60>
 820b574:	1880004c 	andi	r2,r3,1
 820b578:	10003f1e 	bne	r2,zero,820b678 <__sfvwrite_r+0x20c>
 820b57c:	0039883a 	mov	fp,zero
 820b580:	0025883a 	mov	r18,zero
 820b584:	90001a26 	beq	r18,zero,820b5f0 <__sfvwrite_r+0x184>
 820b588:	1880800c 	andi	r2,r3,512
 820b58c:	84c00217 	ldw	r19,8(r16)
 820b590:	10002126 	beq	r2,zero,820b618 <__sfvwrite_r+0x1ac>
 820b594:	982f883a 	mov	r23,r19
 820b598:	94c09336 	bltu	r18,r19,820b7e8 <__sfvwrite_r+0x37c>
 820b59c:	1881200c 	andi	r2,r3,1152
 820b5a0:	10009e1e 	bne	r2,zero,820b81c <__sfvwrite_r+0x3b0>
 820b5a4:	81000017 	ldw	r4,0(r16)
 820b5a8:	b80d883a 	mov	r6,r23
 820b5ac:	e00b883a 	mov	r5,fp
 820b5b0:	82030b40 	call	82030b4 <memmove>
 820b5b4:	80c00217 	ldw	r3,8(r16)
 820b5b8:	81000017 	ldw	r4,0(r16)
 820b5bc:	9005883a 	mov	r2,r18
 820b5c0:	1ce7c83a 	sub	r19,r3,r19
 820b5c4:	25cf883a 	add	r7,r4,r23
 820b5c8:	84c00215 	stw	r19,8(r16)
 820b5cc:	81c00015 	stw	r7,0(r16)
 820b5d0:	a0c00217 	ldw	r3,8(r20)
 820b5d4:	e0b9883a 	add	fp,fp,r2
 820b5d8:	90a5c83a 	sub	r18,r18,r2
 820b5dc:	18a7c83a 	sub	r19,r3,r2
 820b5e0:	a4c00215 	stw	r19,8(r20)
 820b5e4:	983fce26 	beq	r19,zero,820b520 <__sfvwrite_r+0xb4>
 820b5e8:	80c0030b 	ldhu	r3,12(r16)
 820b5ec:	903fe61e 	bne	r18,zero,820b588 <__sfvwrite_r+0x11c>
 820b5f0:	8f000017 	ldw	fp,0(r17)
 820b5f4:	8c800117 	ldw	r18,4(r17)
 820b5f8:	8c400204 	addi	r17,r17,8
 820b5fc:	003fe106 	br	820b584 <__sfvwrite_r+0x118>
 820b600:	8cc00017 	ldw	r19,0(r17)
 820b604:	8c800117 	ldw	r18,4(r17)
 820b608:	8c400204 	addi	r17,r17,8
 820b60c:	003fb306 	br	820b4dc <__sfvwrite_r+0x70>
 820b610:	0005883a 	mov	r2,zero
 820b614:	f800283a 	ret
 820b618:	81000017 	ldw	r4,0(r16)
 820b61c:	80800417 	ldw	r2,16(r16)
 820b620:	11005736 	bltu	r2,r4,820b780 <__sfvwrite_r+0x314>
 820b624:	85c00517 	ldw	r23,20(r16)
 820b628:	95c05536 	bltu	r18,r23,820b780 <__sfvwrite_r+0x314>
 820b62c:	00a00034 	movhi	r2,32768
 820b630:	10bfffc4 	addi	r2,r2,-1
 820b634:	9009883a 	mov	r4,r18
 820b638:	1480012e 	bgeu	r2,r18,820b640 <__sfvwrite_r+0x1d4>
 820b63c:	1009883a 	mov	r4,r2
 820b640:	b80b883a 	mov	r5,r23
 820b644:	8202b740 	call	8202b74 <__divsi3>
 820b648:	15cf383a 	mul	r7,r2,r23
 820b64c:	81400717 	ldw	r5,28(r16)
 820b650:	80800917 	ldw	r2,36(r16)
 820b654:	e00d883a 	mov	r6,fp
 820b658:	a809883a 	mov	r4,r21
 820b65c:	103ee83a 	callr	r2
 820b660:	00bfdb16 	blt	zero,r2,820b5d0 <__sfvwrite_r+0x164>
 820b664:	8080030b 	ldhu	r2,12(r16)
 820b668:	10801014 	ori	r2,r2,64
 820b66c:	8080030d 	sth	r2,12(r16)
 820b670:	00bfffc4 	movi	r2,-1
 820b674:	003fab06 	br	820b524 <__sfvwrite_r+0xb8>
 820b678:	0027883a 	mov	r19,zero
 820b67c:	0011883a 	mov	r8,zero
 820b680:	0039883a 	mov	fp,zero
 820b684:	0025883a 	mov	r18,zero
 820b688:	90001f26 	beq	r18,zero,820b708 <__sfvwrite_r+0x29c>
 820b68c:	40005a26 	beq	r8,zero,820b7f8 <__sfvwrite_r+0x38c>
 820b690:	982d883a 	mov	r22,r19
 820b694:	94c0012e 	bgeu	r18,r19,820b69c <__sfvwrite_r+0x230>
 820b698:	902d883a 	mov	r22,r18
 820b69c:	81000017 	ldw	r4,0(r16)
 820b6a0:	80800417 	ldw	r2,16(r16)
 820b6a4:	b02f883a 	mov	r23,r22
 820b6a8:	81c00517 	ldw	r7,20(r16)
 820b6ac:	1100032e 	bgeu	r2,r4,820b6bc <__sfvwrite_r+0x250>
 820b6b0:	80c00217 	ldw	r3,8(r16)
 820b6b4:	38c7883a 	add	r3,r7,r3
 820b6b8:	1d801816 	blt	r3,r22,820b71c <__sfvwrite_r+0x2b0>
 820b6bc:	b1c03e16 	blt	r22,r7,820b7b8 <__sfvwrite_r+0x34c>
 820b6c0:	80800917 	ldw	r2,36(r16)
 820b6c4:	81400717 	ldw	r5,28(r16)
 820b6c8:	e00d883a 	mov	r6,fp
 820b6cc:	da000115 	stw	r8,4(sp)
 820b6d0:	a809883a 	mov	r4,r21
 820b6d4:	103ee83a 	callr	r2
 820b6d8:	102f883a 	mov	r23,r2
 820b6dc:	da000117 	ldw	r8,4(sp)
 820b6e0:	00bfe00e 	bge	zero,r2,820b664 <__sfvwrite_r+0x1f8>
 820b6e4:	9de7c83a 	sub	r19,r19,r23
 820b6e8:	98001f26 	beq	r19,zero,820b768 <__sfvwrite_r+0x2fc>
 820b6ec:	a0800217 	ldw	r2,8(r20)
 820b6f0:	e5f9883a 	add	fp,fp,r23
 820b6f4:	95e5c83a 	sub	r18,r18,r23
 820b6f8:	15efc83a 	sub	r23,r2,r23
 820b6fc:	a5c00215 	stw	r23,8(r20)
 820b700:	b83f8726 	beq	r23,zero,820b520 <__sfvwrite_r+0xb4>
 820b704:	903fe11e 	bne	r18,zero,820b68c <__sfvwrite_r+0x220>
 820b708:	8f000017 	ldw	fp,0(r17)
 820b70c:	8c800117 	ldw	r18,4(r17)
 820b710:	0011883a 	mov	r8,zero
 820b714:	8c400204 	addi	r17,r17,8
 820b718:	003fdb06 	br	820b688 <__sfvwrite_r+0x21c>
 820b71c:	180d883a 	mov	r6,r3
 820b720:	e00b883a 	mov	r5,fp
 820b724:	da000115 	stw	r8,4(sp)
 820b728:	d8c00015 	stw	r3,0(sp)
 820b72c:	82030b40 	call	82030b4 <memmove>
 820b730:	d8c00017 	ldw	r3,0(sp)
 820b734:	80800017 	ldw	r2,0(r16)
 820b738:	800b883a 	mov	r5,r16
 820b73c:	a809883a 	mov	r4,r21
 820b740:	10c5883a 	add	r2,r2,r3
 820b744:	80800015 	stw	r2,0(r16)
 820b748:	d8c00015 	stw	r3,0(sp)
 820b74c:	820aab80 	call	820aab8 <_fflush_r>
 820b750:	d8c00017 	ldw	r3,0(sp)
 820b754:	da000117 	ldw	r8,4(sp)
 820b758:	103fc21e 	bne	r2,zero,820b664 <__sfvwrite_r+0x1f8>
 820b75c:	182f883a 	mov	r23,r3
 820b760:	9de7c83a 	sub	r19,r19,r23
 820b764:	983fe11e 	bne	r19,zero,820b6ec <__sfvwrite_r+0x280>
 820b768:	800b883a 	mov	r5,r16
 820b76c:	a809883a 	mov	r4,r21
 820b770:	820aab80 	call	820aab8 <_fflush_r>
 820b774:	103fbb1e 	bne	r2,zero,820b664 <__sfvwrite_r+0x1f8>
 820b778:	0011883a 	mov	r8,zero
 820b77c:	003fdb06 	br	820b6ec <__sfvwrite_r+0x280>
 820b780:	94c0012e 	bgeu	r18,r19,820b788 <__sfvwrite_r+0x31c>
 820b784:	9027883a 	mov	r19,r18
 820b788:	980d883a 	mov	r6,r19
 820b78c:	e00b883a 	mov	r5,fp
 820b790:	82030b40 	call	82030b4 <memmove>
 820b794:	80800217 	ldw	r2,8(r16)
 820b798:	80c00017 	ldw	r3,0(r16)
 820b79c:	14c5c83a 	sub	r2,r2,r19
 820b7a0:	1cc7883a 	add	r3,r3,r19
 820b7a4:	80800215 	stw	r2,8(r16)
 820b7a8:	80c00015 	stw	r3,0(r16)
 820b7ac:	10004326 	beq	r2,zero,820b8bc <__sfvwrite_r+0x450>
 820b7b0:	9805883a 	mov	r2,r19
 820b7b4:	003f8606 	br	820b5d0 <__sfvwrite_r+0x164>
 820b7b8:	b00d883a 	mov	r6,r22
 820b7bc:	e00b883a 	mov	r5,fp
 820b7c0:	da000115 	stw	r8,4(sp)
 820b7c4:	82030b40 	call	82030b4 <memmove>
 820b7c8:	80800217 	ldw	r2,8(r16)
 820b7cc:	80c00017 	ldw	r3,0(r16)
 820b7d0:	da000117 	ldw	r8,4(sp)
 820b7d4:	1585c83a 	sub	r2,r2,r22
 820b7d8:	1dad883a 	add	r22,r3,r22
 820b7dc:	80800215 	stw	r2,8(r16)
 820b7e0:	85800015 	stw	r22,0(r16)
 820b7e4:	003fbf06 	br	820b6e4 <__sfvwrite_r+0x278>
 820b7e8:	81000017 	ldw	r4,0(r16)
 820b7ec:	9027883a 	mov	r19,r18
 820b7f0:	902f883a 	mov	r23,r18
 820b7f4:	003f6c06 	br	820b5a8 <__sfvwrite_r+0x13c>
 820b7f8:	900d883a 	mov	r6,r18
 820b7fc:	01400284 	movi	r5,10
 820b800:	e009883a 	mov	r4,fp
 820b804:	820c5540 	call	820c554 <memchr>
 820b808:	10003e26 	beq	r2,zero,820b904 <__sfvwrite_r+0x498>
 820b80c:	10800044 	addi	r2,r2,1
 820b810:	1727c83a 	sub	r19,r2,fp
 820b814:	02000044 	movi	r8,1
 820b818:	003f9d06 	br	820b690 <__sfvwrite_r+0x224>
 820b81c:	80800517 	ldw	r2,20(r16)
 820b820:	81400417 	ldw	r5,16(r16)
 820b824:	81c00017 	ldw	r7,0(r16)
 820b828:	10a7883a 	add	r19,r2,r2
 820b82c:	9885883a 	add	r2,r19,r2
 820b830:	1026d7fa 	srli	r19,r2,31
 820b834:	396dc83a 	sub	r22,r7,r5
 820b838:	b1000044 	addi	r4,r22,1
 820b83c:	9885883a 	add	r2,r19,r2
 820b840:	1027d07a 	srai	r19,r2,1
 820b844:	2485883a 	add	r2,r4,r18
 820b848:	980d883a 	mov	r6,r19
 820b84c:	9880022e 	bgeu	r19,r2,820b858 <__sfvwrite_r+0x3ec>
 820b850:	1027883a 	mov	r19,r2
 820b854:	100d883a 	mov	r6,r2
 820b858:	18c1000c 	andi	r3,r3,1024
 820b85c:	18001c26 	beq	r3,zero,820b8d0 <__sfvwrite_r+0x464>
 820b860:	300b883a 	mov	r5,r6
 820b864:	a809883a 	mov	r4,r21
 820b868:	820bd480 	call	820bd48 <_malloc_r>
 820b86c:	102f883a 	mov	r23,r2
 820b870:	10002926 	beq	r2,zero,820b918 <__sfvwrite_r+0x4ac>
 820b874:	81400417 	ldw	r5,16(r16)
 820b878:	b00d883a 	mov	r6,r22
 820b87c:	1009883a 	mov	r4,r2
 820b880:	8202f6c0 	call	8202f6c <memcpy>
 820b884:	8080030b 	ldhu	r2,12(r16)
 820b888:	00fedfc4 	movi	r3,-1153
 820b88c:	10c4703a 	and	r2,r2,r3
 820b890:	10802014 	ori	r2,r2,128
 820b894:	8080030d 	sth	r2,12(r16)
 820b898:	bd89883a 	add	r4,r23,r22
 820b89c:	9d8fc83a 	sub	r7,r19,r22
 820b8a0:	85c00415 	stw	r23,16(r16)
 820b8a4:	84c00515 	stw	r19,20(r16)
 820b8a8:	81000015 	stw	r4,0(r16)
 820b8ac:	9027883a 	mov	r19,r18
 820b8b0:	81c00215 	stw	r7,8(r16)
 820b8b4:	902f883a 	mov	r23,r18
 820b8b8:	003f3b06 	br	820b5a8 <__sfvwrite_r+0x13c>
 820b8bc:	800b883a 	mov	r5,r16
 820b8c0:	a809883a 	mov	r4,r21
 820b8c4:	820aab80 	call	820aab8 <_fflush_r>
 820b8c8:	103fb926 	beq	r2,zero,820b7b0 <__sfvwrite_r+0x344>
 820b8cc:	003f6506 	br	820b664 <__sfvwrite_r+0x1f8>
 820b8d0:	a809883a 	mov	r4,r21
 820b8d4:	820d6b00 	call	820d6b0 <_realloc_r>
 820b8d8:	102f883a 	mov	r23,r2
 820b8dc:	103fee1e 	bne	r2,zero,820b898 <__sfvwrite_r+0x42c>
 820b8e0:	81400417 	ldw	r5,16(r16)
 820b8e4:	a809883a 	mov	r4,r21
 820b8e8:	820b15c0 	call	820b15c <_free_r>
 820b8ec:	8080030b 	ldhu	r2,12(r16)
 820b8f0:	00ffdfc4 	movi	r3,-129
 820b8f4:	1884703a 	and	r2,r3,r2
 820b8f8:	00c00304 	movi	r3,12
 820b8fc:	a8c00015 	stw	r3,0(r21)
 820b900:	003f5906 	br	820b668 <__sfvwrite_r+0x1fc>
 820b904:	94c00044 	addi	r19,r18,1
 820b908:	02000044 	movi	r8,1
 820b90c:	003f6006 	br	820b690 <__sfvwrite_r+0x224>
 820b910:	00bfffc4 	movi	r2,-1
 820b914:	003f0306 	br	820b524 <__sfvwrite_r+0xb8>
 820b918:	00800304 	movi	r2,12
 820b91c:	a8800015 	stw	r2,0(r21)
 820b920:	8080030b 	ldhu	r2,12(r16)
 820b924:	003f5006 	br	820b668 <__sfvwrite_r+0x1fc>

0820b928 <_fwalk>:
 820b928:	defff704 	addi	sp,sp,-36
 820b92c:	dd000415 	stw	r20,16(sp)
 820b930:	dfc00815 	stw	ra,32(sp)
 820b934:	ddc00715 	stw	r23,28(sp)
 820b938:	dd800615 	stw	r22,24(sp)
 820b93c:	dd400515 	stw	r21,20(sp)
 820b940:	dcc00315 	stw	r19,12(sp)
 820b944:	dc800215 	stw	r18,8(sp)
 820b948:	dc400115 	stw	r17,4(sp)
 820b94c:	dc000015 	stw	r16,0(sp)
 820b950:	2500b804 	addi	r20,r4,736
 820b954:	a0002326 	beq	r20,zero,820b9e4 <_fwalk+0xbc>
 820b958:	282b883a 	mov	r21,r5
 820b95c:	002f883a 	mov	r23,zero
 820b960:	05800044 	movi	r22,1
 820b964:	04ffffc4 	movi	r19,-1
 820b968:	a4400117 	ldw	r17,4(r20)
 820b96c:	a4800217 	ldw	r18,8(r20)
 820b970:	8c7fffc4 	addi	r17,r17,-1
 820b974:	88000d16 	blt	r17,zero,820b9ac <_fwalk+0x84>
 820b978:	94000304 	addi	r16,r18,12
 820b97c:	94800384 	addi	r18,r18,14
 820b980:	8080000b 	ldhu	r2,0(r16)
 820b984:	8c7fffc4 	addi	r17,r17,-1
 820b988:	813ffd04 	addi	r4,r16,-12
 820b98c:	b080042e 	bgeu	r22,r2,820b9a0 <_fwalk+0x78>
 820b990:	9080000f 	ldh	r2,0(r18)
 820b994:	14c00226 	beq	r2,r19,820b9a0 <_fwalk+0x78>
 820b998:	a83ee83a 	callr	r21
 820b99c:	b8aeb03a 	or	r23,r23,r2
 820b9a0:	84001a04 	addi	r16,r16,104
 820b9a4:	94801a04 	addi	r18,r18,104
 820b9a8:	8cfff51e 	bne	r17,r19,820b980 <_fwalk+0x58>
 820b9ac:	a5000017 	ldw	r20,0(r20)
 820b9b0:	a03fed1e 	bne	r20,zero,820b968 <_fwalk+0x40>
 820b9b4:	b805883a 	mov	r2,r23
 820b9b8:	dfc00817 	ldw	ra,32(sp)
 820b9bc:	ddc00717 	ldw	r23,28(sp)
 820b9c0:	dd800617 	ldw	r22,24(sp)
 820b9c4:	dd400517 	ldw	r21,20(sp)
 820b9c8:	dd000417 	ldw	r20,16(sp)
 820b9cc:	dcc00317 	ldw	r19,12(sp)
 820b9d0:	dc800217 	ldw	r18,8(sp)
 820b9d4:	dc400117 	ldw	r17,4(sp)
 820b9d8:	dc000017 	ldw	r16,0(sp)
 820b9dc:	dec00904 	addi	sp,sp,36
 820b9e0:	f800283a 	ret
 820b9e4:	002f883a 	mov	r23,zero
 820b9e8:	003ff206 	br	820b9b4 <_fwalk+0x8c>

0820b9ec <_fwalk_reent>:
 820b9ec:	defff704 	addi	sp,sp,-36
 820b9f0:	dd000415 	stw	r20,16(sp)
 820b9f4:	dfc00815 	stw	ra,32(sp)
 820b9f8:	ddc00715 	stw	r23,28(sp)
 820b9fc:	dd800615 	stw	r22,24(sp)
 820ba00:	dd400515 	stw	r21,20(sp)
 820ba04:	dcc00315 	stw	r19,12(sp)
 820ba08:	dc800215 	stw	r18,8(sp)
 820ba0c:	dc400115 	stw	r17,4(sp)
 820ba10:	dc000015 	stw	r16,0(sp)
 820ba14:	2500b804 	addi	r20,r4,736
 820ba18:	a0002326 	beq	r20,zero,820baa8 <_fwalk_reent+0xbc>
 820ba1c:	282b883a 	mov	r21,r5
 820ba20:	2027883a 	mov	r19,r4
 820ba24:	002f883a 	mov	r23,zero
 820ba28:	05800044 	movi	r22,1
 820ba2c:	04bfffc4 	movi	r18,-1
 820ba30:	a4400117 	ldw	r17,4(r20)
 820ba34:	a4000217 	ldw	r16,8(r20)
 820ba38:	8c7fffc4 	addi	r17,r17,-1
 820ba3c:	88000c16 	blt	r17,zero,820ba70 <_fwalk_reent+0x84>
 820ba40:	84000304 	addi	r16,r16,12
 820ba44:	8080000b 	ldhu	r2,0(r16)
 820ba48:	8c7fffc4 	addi	r17,r17,-1
 820ba4c:	817ffd04 	addi	r5,r16,-12
 820ba50:	b080052e 	bgeu	r22,r2,820ba68 <_fwalk_reent+0x7c>
 820ba54:	8080008f 	ldh	r2,2(r16)
 820ba58:	9809883a 	mov	r4,r19
 820ba5c:	14800226 	beq	r2,r18,820ba68 <_fwalk_reent+0x7c>
 820ba60:	a83ee83a 	callr	r21
 820ba64:	b8aeb03a 	or	r23,r23,r2
 820ba68:	84001a04 	addi	r16,r16,104
 820ba6c:	8cbff51e 	bne	r17,r18,820ba44 <_fwalk_reent+0x58>
 820ba70:	a5000017 	ldw	r20,0(r20)
 820ba74:	a03fee1e 	bne	r20,zero,820ba30 <_fwalk_reent+0x44>
 820ba78:	b805883a 	mov	r2,r23
 820ba7c:	dfc00817 	ldw	ra,32(sp)
 820ba80:	ddc00717 	ldw	r23,28(sp)
 820ba84:	dd800617 	ldw	r22,24(sp)
 820ba88:	dd400517 	ldw	r21,20(sp)
 820ba8c:	dd000417 	ldw	r20,16(sp)
 820ba90:	dcc00317 	ldw	r19,12(sp)
 820ba94:	dc800217 	ldw	r18,8(sp)
 820ba98:	dc400117 	ldw	r17,4(sp)
 820ba9c:	dc000017 	ldw	r16,0(sp)
 820baa0:	dec00904 	addi	sp,sp,36
 820baa4:	f800283a 	ret
 820baa8:	002f883a 	mov	r23,zero
 820baac:	003ff206 	br	820ba78 <_fwalk_reent+0x8c>

0820bab0 <_setlocale_r>:
 820bab0:	30001b26 	beq	r6,zero,820bb20 <_setlocale_r+0x70>
 820bab4:	01420974 	movhi	r5,2085
 820bab8:	defffe04 	addi	sp,sp,-8
 820babc:	29770104 	addi	r5,r5,-9212
 820bac0:	3009883a 	mov	r4,r6
 820bac4:	dc000015 	stw	r16,0(sp)
 820bac8:	dfc00115 	stw	ra,4(sp)
 820bacc:	3021883a 	mov	r16,r6
 820bad0:	820e0080 	call	820e008 <strcmp>
 820bad4:	1000061e 	bne	r2,zero,820baf0 <_setlocale_r+0x40>
 820bad8:	00820974 	movhi	r2,2085
 820badc:	10b51904 	addi	r2,r2,-11164
 820bae0:	dfc00117 	ldw	ra,4(sp)
 820bae4:	dc000017 	ldw	r16,0(sp)
 820bae8:	dec00204 	addi	sp,sp,8
 820baec:	f800283a 	ret
 820baf0:	01420974 	movhi	r5,2085
 820baf4:	29751904 	addi	r5,r5,-11164
 820baf8:	8009883a 	mov	r4,r16
 820bafc:	820e0080 	call	820e008 <strcmp>
 820bb00:	103ff526 	beq	r2,zero,820bad8 <_setlocale_r+0x28>
 820bb04:	01420974 	movhi	r5,2085
 820bb08:	2976e404 	addi	r5,r5,-9328
 820bb0c:	8009883a 	mov	r4,r16
 820bb10:	820e0080 	call	820e008 <strcmp>
 820bb14:	103ff026 	beq	r2,zero,820bad8 <_setlocale_r+0x28>
 820bb18:	0005883a 	mov	r2,zero
 820bb1c:	003ff006 	br	820bae0 <_setlocale_r+0x30>
 820bb20:	00820974 	movhi	r2,2085
 820bb24:	10b51904 	addi	r2,r2,-11164
 820bb28:	f800283a 	ret

0820bb2c <__locale_charset>:
 820bb2c:	00820974 	movhi	r2,2085
 820bb30:	10893304 	addi	r2,r2,9420
 820bb34:	f800283a 	ret

0820bb38 <__locale_mb_cur_max>:
 820bb38:	00820974 	movhi	r2,2085
 820bb3c:	108fbc04 	addi	r2,r2,16112
 820bb40:	10800017 	ldw	r2,0(r2)
 820bb44:	f800283a 	ret

0820bb48 <__locale_msgcharset>:
 820bb48:	00820974 	movhi	r2,2085
 820bb4c:	10892b04 	addi	r2,r2,9388
 820bb50:	f800283a 	ret

0820bb54 <__locale_cjk_lang>:
 820bb54:	0005883a 	mov	r2,zero
 820bb58:	f800283a 	ret

0820bb5c <_localeconv_r>:
 820bb5c:	00820974 	movhi	r2,2085
 820bb60:	10893b04 	addi	r2,r2,9452
 820bb64:	f800283a 	ret

0820bb68 <setlocale>:
 820bb68:	00820974 	movhi	r2,2085
 820bb6c:	108fbb04 	addi	r2,r2,16108
 820bb70:	280d883a 	mov	r6,r5
 820bb74:	200b883a 	mov	r5,r4
 820bb78:	11000017 	ldw	r4,0(r2)
 820bb7c:	820bab01 	jmpi	820bab0 <_setlocale_r>

0820bb80 <localeconv>:
 820bb80:	00820974 	movhi	r2,2085
 820bb84:	10893b04 	addi	r2,r2,9452
 820bb88:	f800283a 	ret

0820bb8c <__smakebuf_r>:
 820bb8c:	2880030b 	ldhu	r2,12(r5)
 820bb90:	10c0008c 	andi	r3,r2,2
 820bb94:	1800411e 	bne	r3,zero,820bc9c <__smakebuf_r+0x110>
 820bb98:	deffec04 	addi	sp,sp,-80
 820bb9c:	dc000f15 	stw	r16,60(sp)
 820bba0:	2821883a 	mov	r16,r5
 820bba4:	2940038f 	ldh	r5,14(r5)
 820bba8:	dc401015 	stw	r17,64(sp)
 820bbac:	dfc01315 	stw	ra,76(sp)
 820bbb0:	dcc01215 	stw	r19,72(sp)
 820bbb4:	dc801115 	stw	r18,68(sp)
 820bbb8:	2023883a 	mov	r17,r4
 820bbbc:	28001c16 	blt	r5,zero,820bc30 <__smakebuf_r+0xa4>
 820bbc0:	d80d883a 	mov	r6,sp
 820bbc4:	8210fbc0 	call	8210fbc <_fstat_r>
 820bbc8:	10001816 	blt	r2,zero,820bc2c <__smakebuf_r+0xa0>
 820bbcc:	d8800117 	ldw	r2,4(sp)
 820bbd0:	00e00014 	movui	r3,32768
 820bbd4:	10bc000c 	andi	r2,r2,61440
 820bbd8:	14c80020 	cmpeqi	r19,r2,8192
 820bbdc:	10c03726 	beq	r2,r3,820bcbc <__smakebuf_r+0x130>
 820bbe0:	80c0030b 	ldhu	r3,12(r16)
 820bbe4:	18c20014 	ori	r3,r3,2048
 820bbe8:	80c0030d 	sth	r3,12(r16)
 820bbec:	00c80004 	movi	r3,8192
 820bbf0:	10c0521e 	bne	r2,r3,820bd3c <__smakebuf_r+0x1b0>
 820bbf4:	8140038f 	ldh	r5,14(r16)
 820bbf8:	8809883a 	mov	r4,r17
 820bbfc:	82110180 	call	8211018 <_isatty_r>
 820bc00:	10004c26 	beq	r2,zero,820bd34 <__smakebuf_r+0x1a8>
 820bc04:	8080030b 	ldhu	r2,12(r16)
 820bc08:	80c010c4 	addi	r3,r16,67
 820bc0c:	80c00015 	stw	r3,0(r16)
 820bc10:	10800054 	ori	r2,r2,1
 820bc14:	8080030d 	sth	r2,12(r16)
 820bc18:	00800044 	movi	r2,1
 820bc1c:	80c00415 	stw	r3,16(r16)
 820bc20:	80800515 	stw	r2,20(r16)
 820bc24:	04810004 	movi	r18,1024
 820bc28:	00000706 	br	820bc48 <__smakebuf_r+0xbc>
 820bc2c:	8080030b 	ldhu	r2,12(r16)
 820bc30:	10c0200c 	andi	r3,r2,128
 820bc34:	18001f1e 	bne	r3,zero,820bcb4 <__smakebuf_r+0x128>
 820bc38:	04810004 	movi	r18,1024
 820bc3c:	10820014 	ori	r2,r2,2048
 820bc40:	8080030d 	sth	r2,12(r16)
 820bc44:	0027883a 	mov	r19,zero
 820bc48:	900b883a 	mov	r5,r18
 820bc4c:	8809883a 	mov	r4,r17
 820bc50:	820bd480 	call	820bd48 <_malloc_r>
 820bc54:	10002c26 	beq	r2,zero,820bd08 <__smakebuf_r+0x17c>
 820bc58:	80c0030b 	ldhu	r3,12(r16)
 820bc5c:	01020874 	movhi	r4,2081
 820bc60:	212ad304 	addi	r4,r4,-21684
 820bc64:	89000f15 	stw	r4,60(r17)
 820bc68:	18c02014 	ori	r3,r3,128
 820bc6c:	80c0030d 	sth	r3,12(r16)
 820bc70:	80800015 	stw	r2,0(r16)
 820bc74:	80800415 	stw	r2,16(r16)
 820bc78:	84800515 	stw	r18,20(r16)
 820bc7c:	98001a1e 	bne	r19,zero,820bce8 <__smakebuf_r+0x15c>
 820bc80:	dfc01317 	ldw	ra,76(sp)
 820bc84:	dcc01217 	ldw	r19,72(sp)
 820bc88:	dc801117 	ldw	r18,68(sp)
 820bc8c:	dc401017 	ldw	r17,64(sp)
 820bc90:	dc000f17 	ldw	r16,60(sp)
 820bc94:	dec01404 	addi	sp,sp,80
 820bc98:	f800283a 	ret
 820bc9c:	288010c4 	addi	r2,r5,67
 820bca0:	28800015 	stw	r2,0(r5)
 820bca4:	28800415 	stw	r2,16(r5)
 820bca8:	00800044 	movi	r2,1
 820bcac:	28800515 	stw	r2,20(r5)
 820bcb0:	f800283a 	ret
 820bcb4:	04801004 	movi	r18,64
 820bcb8:	003fe006 	br	820bc3c <__smakebuf_r+0xb0>
 820bcbc:	81000a17 	ldw	r4,40(r16)
 820bcc0:	00c20874 	movhi	r3,2081
 820bcc4:	18f7e904 	addi	r3,r3,-8284
 820bcc8:	20ffc51e 	bne	r4,r3,820bbe0 <__smakebuf_r+0x54>
 820bccc:	8080030b 	ldhu	r2,12(r16)
 820bcd0:	04810004 	movi	r18,1024
 820bcd4:	84801315 	stw	r18,76(r16)
 820bcd8:	1484b03a 	or	r2,r2,r18
 820bcdc:	8080030d 	sth	r2,12(r16)
 820bce0:	0027883a 	mov	r19,zero
 820bce4:	003fd806 	br	820bc48 <__smakebuf_r+0xbc>
 820bce8:	8140038f 	ldh	r5,14(r16)
 820bcec:	8809883a 	mov	r4,r17
 820bcf0:	82110180 	call	8211018 <_isatty_r>
 820bcf4:	103fe226 	beq	r2,zero,820bc80 <__smakebuf_r+0xf4>
 820bcf8:	8080030b 	ldhu	r2,12(r16)
 820bcfc:	10800054 	ori	r2,r2,1
 820bd00:	8080030d 	sth	r2,12(r16)
 820bd04:	003fde06 	br	820bc80 <__smakebuf_r+0xf4>
 820bd08:	8080030b 	ldhu	r2,12(r16)
 820bd0c:	10c0800c 	andi	r3,r2,512
 820bd10:	183fdb1e 	bne	r3,zero,820bc80 <__smakebuf_r+0xf4>
 820bd14:	10800094 	ori	r2,r2,2
 820bd18:	80c010c4 	addi	r3,r16,67
 820bd1c:	8080030d 	sth	r2,12(r16)
 820bd20:	00800044 	movi	r2,1
 820bd24:	80c00015 	stw	r3,0(r16)
 820bd28:	80c00415 	stw	r3,16(r16)
 820bd2c:	80800515 	stw	r2,20(r16)
 820bd30:	003fd306 	br	820bc80 <__smakebuf_r+0xf4>
 820bd34:	04810004 	movi	r18,1024
 820bd38:	003fc306 	br	820bc48 <__smakebuf_r+0xbc>
 820bd3c:	0027883a 	mov	r19,zero
 820bd40:	04810004 	movi	r18,1024
 820bd44:	003fc006 	br	820bc48 <__smakebuf_r+0xbc>

0820bd48 <_malloc_r>:
 820bd48:	defff504 	addi	sp,sp,-44
 820bd4c:	dc800315 	stw	r18,12(sp)
 820bd50:	dfc00a15 	stw	ra,40(sp)
 820bd54:	df000915 	stw	fp,36(sp)
 820bd58:	ddc00815 	stw	r23,32(sp)
 820bd5c:	dd800715 	stw	r22,28(sp)
 820bd60:	dd400615 	stw	r21,24(sp)
 820bd64:	dd000515 	stw	r20,20(sp)
 820bd68:	dcc00415 	stw	r19,16(sp)
 820bd6c:	dc400215 	stw	r17,8(sp)
 820bd70:	dc000115 	stw	r16,4(sp)
 820bd74:	288002c4 	addi	r2,r5,11
 820bd78:	00c00584 	movi	r3,22
 820bd7c:	2025883a 	mov	r18,r4
 820bd80:	18807f2e 	bgeu	r3,r2,820bf80 <_malloc_r+0x238>
 820bd84:	047ffe04 	movi	r17,-8
 820bd88:	1462703a 	and	r17,r2,r17
 820bd8c:	8800a316 	blt	r17,zero,820c01c <_malloc_r+0x2d4>
 820bd90:	8940a236 	bltu	r17,r5,820c01c <_malloc_r+0x2d4>
 820bd94:	8214a540 	call	8214a54 <__malloc_lock>
 820bd98:	00807dc4 	movi	r2,503
 820bd9c:	1441e92e 	bgeu	r2,r17,820c544 <_malloc_r+0x7fc>
 820bda0:	8804d27a 	srli	r2,r17,9
 820bda4:	1000a126 	beq	r2,zero,820c02c <_malloc_r+0x2e4>
 820bda8:	00c00104 	movi	r3,4
 820bdac:	18811e36 	bltu	r3,r2,820c228 <_malloc_r+0x4e0>
 820bdb0:	8804d1ba 	srli	r2,r17,6
 820bdb4:	12000e44 	addi	r8,r2,57
 820bdb8:	11c00e04 	addi	r7,r2,56
 820bdbc:	4209883a 	add	r4,r8,r8
 820bdc0:	04c20974 	movhi	r19,2085
 820bdc4:	2109883a 	add	r4,r4,r4
 820bdc8:	9cc94904 	addi	r19,r19,9508
 820bdcc:	2109883a 	add	r4,r4,r4
 820bdd0:	9909883a 	add	r4,r19,r4
 820bdd4:	24000117 	ldw	r16,4(r4)
 820bdd8:	213ffe04 	addi	r4,r4,-8
 820bddc:	24009726 	beq	r4,r16,820c03c <_malloc_r+0x2f4>
 820bde0:	80800117 	ldw	r2,4(r16)
 820bde4:	01bfff04 	movi	r6,-4
 820bde8:	014003c4 	movi	r5,15
 820bdec:	1184703a 	and	r2,r2,r6
 820bdf0:	1447c83a 	sub	r3,r2,r17
 820bdf4:	28c00716 	blt	r5,r3,820be14 <_malloc_r+0xcc>
 820bdf8:	1800920e 	bge	r3,zero,820c044 <_malloc_r+0x2fc>
 820bdfc:	84000317 	ldw	r16,12(r16)
 820be00:	24008e26 	beq	r4,r16,820c03c <_malloc_r+0x2f4>
 820be04:	80800117 	ldw	r2,4(r16)
 820be08:	1184703a 	and	r2,r2,r6
 820be0c:	1447c83a 	sub	r3,r2,r17
 820be10:	28fff90e 	bge	r5,r3,820bdf8 <_malloc_r+0xb0>
 820be14:	3809883a 	mov	r4,r7
 820be18:	01820974 	movhi	r6,2085
 820be1c:	9c000417 	ldw	r16,16(r19)
 820be20:	31894904 	addi	r6,r6,9508
 820be24:	32000204 	addi	r8,r6,8
 820be28:	82013426 	beq	r16,r8,820c2fc <_malloc_r+0x5b4>
 820be2c:	80c00117 	ldw	r3,4(r16)
 820be30:	00bfff04 	movi	r2,-4
 820be34:	188e703a 	and	r7,r3,r2
 820be38:	3c45c83a 	sub	r2,r7,r17
 820be3c:	00c003c4 	movi	r3,15
 820be40:	18811f16 	blt	r3,r2,820c2c0 <_malloc_r+0x578>
 820be44:	32000515 	stw	r8,20(r6)
 820be48:	32000415 	stw	r8,16(r6)
 820be4c:	10007f0e 	bge	r2,zero,820c04c <_malloc_r+0x304>
 820be50:	00807fc4 	movi	r2,511
 820be54:	11c0fd36 	bltu	r2,r7,820c24c <_malloc_r+0x504>
 820be58:	3806d0fa 	srli	r3,r7,3
 820be5c:	01c00044 	movi	r7,1
 820be60:	30800117 	ldw	r2,4(r6)
 820be64:	19400044 	addi	r5,r3,1
 820be68:	294b883a 	add	r5,r5,r5
 820be6c:	1807d0ba 	srai	r3,r3,2
 820be70:	294b883a 	add	r5,r5,r5
 820be74:	294b883a 	add	r5,r5,r5
 820be78:	298b883a 	add	r5,r5,r6
 820be7c:	38c6983a 	sll	r3,r7,r3
 820be80:	29c00017 	ldw	r7,0(r5)
 820be84:	2a7ffe04 	addi	r9,r5,-8
 820be88:	1886b03a 	or	r3,r3,r2
 820be8c:	82400315 	stw	r9,12(r16)
 820be90:	81c00215 	stw	r7,8(r16)
 820be94:	30c00115 	stw	r3,4(r6)
 820be98:	2c000015 	stw	r16,0(r5)
 820be9c:	3c000315 	stw	r16,12(r7)
 820bea0:	2005d0ba 	srai	r2,r4,2
 820bea4:	01400044 	movi	r5,1
 820bea8:	288a983a 	sll	r5,r5,r2
 820beac:	19406f36 	bltu	r3,r5,820c06c <_malloc_r+0x324>
 820beb0:	28c4703a 	and	r2,r5,r3
 820beb4:	10000a1e 	bne	r2,zero,820bee0 <_malloc_r+0x198>
 820beb8:	00bfff04 	movi	r2,-4
 820bebc:	294b883a 	add	r5,r5,r5
 820bec0:	2088703a 	and	r4,r4,r2
 820bec4:	28c4703a 	and	r2,r5,r3
 820bec8:	21000104 	addi	r4,r4,4
 820becc:	1000041e 	bne	r2,zero,820bee0 <_malloc_r+0x198>
 820bed0:	294b883a 	add	r5,r5,r5
 820bed4:	28c4703a 	and	r2,r5,r3
 820bed8:	21000104 	addi	r4,r4,4
 820bedc:	103ffc26 	beq	r2,zero,820bed0 <_malloc_r+0x188>
 820bee0:	02bfff04 	movi	r10,-4
 820bee4:	024003c4 	movi	r9,15
 820bee8:	21800044 	addi	r6,r4,1
 820beec:	318d883a 	add	r6,r6,r6
 820bef0:	318d883a 	add	r6,r6,r6
 820bef4:	318d883a 	add	r6,r6,r6
 820bef8:	998d883a 	add	r6,r19,r6
 820befc:	333ffe04 	addi	r12,r6,-8
 820bf00:	2017883a 	mov	r11,r4
 820bf04:	31800104 	addi	r6,r6,4
 820bf08:	34000017 	ldw	r16,0(r6)
 820bf0c:	31fffd04 	addi	r7,r6,-12
 820bf10:	81c0041e 	bne	r16,r7,820bf24 <_malloc_r+0x1dc>
 820bf14:	0000fb06 	br	820c304 <_malloc_r+0x5bc>
 820bf18:	1801030e 	bge	r3,zero,820c328 <_malloc_r+0x5e0>
 820bf1c:	84000317 	ldw	r16,12(r16)
 820bf20:	81c0f826 	beq	r16,r7,820c304 <_malloc_r+0x5bc>
 820bf24:	80800117 	ldw	r2,4(r16)
 820bf28:	1284703a 	and	r2,r2,r10
 820bf2c:	1447c83a 	sub	r3,r2,r17
 820bf30:	48fff90e 	bge	r9,r3,820bf18 <_malloc_r+0x1d0>
 820bf34:	80800317 	ldw	r2,12(r16)
 820bf38:	81000217 	ldw	r4,8(r16)
 820bf3c:	89400054 	ori	r5,r17,1
 820bf40:	81400115 	stw	r5,4(r16)
 820bf44:	20800315 	stw	r2,12(r4)
 820bf48:	11000215 	stw	r4,8(r2)
 820bf4c:	8463883a 	add	r17,r16,r17
 820bf50:	9c400515 	stw	r17,20(r19)
 820bf54:	9c400415 	stw	r17,16(r19)
 820bf58:	18800054 	ori	r2,r3,1
 820bf5c:	88800115 	stw	r2,4(r17)
 820bf60:	8a000315 	stw	r8,12(r17)
 820bf64:	8a000215 	stw	r8,8(r17)
 820bf68:	88e3883a 	add	r17,r17,r3
 820bf6c:	88c00015 	stw	r3,0(r17)
 820bf70:	9009883a 	mov	r4,r18
 820bf74:	8214b740 	call	8214b74 <__malloc_unlock>
 820bf78:	80800204 	addi	r2,r16,8
 820bf7c:	00001b06 	br	820bfec <_malloc_r+0x2a4>
 820bf80:	04400404 	movi	r17,16
 820bf84:	89402536 	bltu	r17,r5,820c01c <_malloc_r+0x2d4>
 820bf88:	8214a540 	call	8214a54 <__malloc_lock>
 820bf8c:	00800184 	movi	r2,6
 820bf90:	01000084 	movi	r4,2
 820bf94:	04c20974 	movhi	r19,2085
 820bf98:	1085883a 	add	r2,r2,r2
 820bf9c:	9cc94904 	addi	r19,r19,9508
 820bfa0:	1085883a 	add	r2,r2,r2
 820bfa4:	9885883a 	add	r2,r19,r2
 820bfa8:	14000117 	ldw	r16,4(r2)
 820bfac:	10fffe04 	addi	r3,r2,-8
 820bfb0:	80c0d926 	beq	r16,r3,820c318 <_malloc_r+0x5d0>
 820bfb4:	80c00117 	ldw	r3,4(r16)
 820bfb8:	81000317 	ldw	r4,12(r16)
 820bfbc:	00bfff04 	movi	r2,-4
 820bfc0:	1884703a 	and	r2,r3,r2
 820bfc4:	81400217 	ldw	r5,8(r16)
 820bfc8:	8085883a 	add	r2,r16,r2
 820bfcc:	10c00117 	ldw	r3,4(r2)
 820bfd0:	29000315 	stw	r4,12(r5)
 820bfd4:	21400215 	stw	r5,8(r4)
 820bfd8:	18c00054 	ori	r3,r3,1
 820bfdc:	10c00115 	stw	r3,4(r2)
 820bfe0:	9009883a 	mov	r4,r18
 820bfe4:	8214b740 	call	8214b74 <__malloc_unlock>
 820bfe8:	80800204 	addi	r2,r16,8
 820bfec:	dfc00a17 	ldw	ra,40(sp)
 820bff0:	df000917 	ldw	fp,36(sp)
 820bff4:	ddc00817 	ldw	r23,32(sp)
 820bff8:	dd800717 	ldw	r22,28(sp)
 820bffc:	dd400617 	ldw	r21,24(sp)
 820c000:	dd000517 	ldw	r20,20(sp)
 820c004:	dcc00417 	ldw	r19,16(sp)
 820c008:	dc800317 	ldw	r18,12(sp)
 820c00c:	dc400217 	ldw	r17,8(sp)
 820c010:	dc000117 	ldw	r16,4(sp)
 820c014:	dec00b04 	addi	sp,sp,44
 820c018:	f800283a 	ret
 820c01c:	00800304 	movi	r2,12
 820c020:	90800015 	stw	r2,0(r18)
 820c024:	0005883a 	mov	r2,zero
 820c028:	003ff006 	br	820bfec <_malloc_r+0x2a4>
 820c02c:	01002004 	movi	r4,128
 820c030:	02001004 	movi	r8,64
 820c034:	01c00fc4 	movi	r7,63
 820c038:	003f6106 	br	820bdc0 <_malloc_r+0x78>
 820c03c:	4009883a 	mov	r4,r8
 820c040:	003f7506 	br	820be18 <_malloc_r+0xd0>
 820c044:	81000317 	ldw	r4,12(r16)
 820c048:	003fde06 	br	820bfc4 <_malloc_r+0x27c>
 820c04c:	81c5883a 	add	r2,r16,r7
 820c050:	11400117 	ldw	r5,4(r2)
 820c054:	9009883a 	mov	r4,r18
 820c058:	29400054 	ori	r5,r5,1
 820c05c:	11400115 	stw	r5,4(r2)
 820c060:	8214b740 	call	8214b74 <__malloc_unlock>
 820c064:	80800204 	addi	r2,r16,8
 820c068:	003fe006 	br	820bfec <_malloc_r+0x2a4>
 820c06c:	9c000217 	ldw	r16,8(r19)
 820c070:	00bfff04 	movi	r2,-4
 820c074:	85800117 	ldw	r22,4(r16)
 820c078:	b0ac703a 	and	r22,r22,r2
 820c07c:	b4400336 	bltu	r22,r17,820c08c <_malloc_r+0x344>
 820c080:	b445c83a 	sub	r2,r22,r17
 820c084:	00c003c4 	movi	r3,15
 820c088:	18805d16 	blt	r3,r2,820c200 <_malloc_r+0x4b8>
 820c08c:	05c20974 	movhi	r23,2085
 820c090:	00820974 	movhi	r2,2085
 820c094:	10901b04 	addi	r2,r2,16492
 820c098:	bdcfbd04 	addi	r23,r23,16116
 820c09c:	15400017 	ldw	r21,0(r2)
 820c0a0:	b8c00017 	ldw	r3,0(r23)
 820c0a4:	00bfffc4 	movi	r2,-1
 820c0a8:	858d883a 	add	r6,r16,r22
 820c0ac:	8d6b883a 	add	r21,r17,r21
 820c0b0:	1880ea26 	beq	r3,r2,820c45c <_malloc_r+0x714>
 820c0b4:	ad4403c4 	addi	r21,r21,4111
 820c0b8:	00bc0004 	movi	r2,-4096
 820c0bc:	a8aa703a 	and	r21,r21,r2
 820c0c0:	a80b883a 	mov	r5,r21
 820c0c4:	9009883a 	mov	r4,r18
 820c0c8:	d9800015 	stw	r6,0(sp)
 820c0cc:	820de780 	call	820de78 <_sbrk_r>
 820c0d0:	1029883a 	mov	r20,r2
 820c0d4:	00bfffc4 	movi	r2,-1
 820c0d8:	d9800017 	ldw	r6,0(sp)
 820c0dc:	a080e826 	beq	r20,r2,820c480 <_malloc_r+0x738>
 820c0e0:	a180a636 	bltu	r20,r6,820c37c <_malloc_r+0x634>
 820c0e4:	07020974 	movhi	fp,2085
 820c0e8:	e7121204 	addi	fp,fp,18504
 820c0ec:	e0800017 	ldw	r2,0(fp)
 820c0f0:	a887883a 	add	r3,r21,r2
 820c0f4:	e0c00015 	stw	r3,0(fp)
 820c0f8:	3500e626 	beq	r6,r20,820c494 <_malloc_r+0x74c>
 820c0fc:	b9000017 	ldw	r4,0(r23)
 820c100:	00bfffc4 	movi	r2,-1
 820c104:	2080ee26 	beq	r4,r2,820c4c0 <_malloc_r+0x778>
 820c108:	a185c83a 	sub	r2,r20,r6
 820c10c:	10c5883a 	add	r2,r2,r3
 820c110:	e0800015 	stw	r2,0(fp)
 820c114:	a0c001cc 	andi	r3,r20,7
 820c118:	1800bc26 	beq	r3,zero,820c40c <_malloc_r+0x6c4>
 820c11c:	a0e9c83a 	sub	r20,r20,r3
 820c120:	00840204 	movi	r2,4104
 820c124:	a5000204 	addi	r20,r20,8
 820c128:	10c7c83a 	sub	r3,r2,r3
 820c12c:	a545883a 	add	r2,r20,r21
 820c130:	1083ffcc 	andi	r2,r2,4095
 820c134:	18abc83a 	sub	r21,r3,r2
 820c138:	a80b883a 	mov	r5,r21
 820c13c:	9009883a 	mov	r4,r18
 820c140:	820de780 	call	820de78 <_sbrk_r>
 820c144:	00ffffc4 	movi	r3,-1
 820c148:	10c0e126 	beq	r2,r3,820c4d0 <_malloc_r+0x788>
 820c14c:	1505c83a 	sub	r2,r2,r20
 820c150:	1545883a 	add	r2,r2,r21
 820c154:	10800054 	ori	r2,r2,1
 820c158:	e0c00017 	ldw	r3,0(fp)
 820c15c:	9d000215 	stw	r20,8(r19)
 820c160:	a0800115 	stw	r2,4(r20)
 820c164:	a8c7883a 	add	r3,r21,r3
 820c168:	e0c00015 	stw	r3,0(fp)
 820c16c:	84c00e26 	beq	r16,r19,820c1a8 <_malloc_r+0x460>
 820c170:	018003c4 	movi	r6,15
 820c174:	3580a72e 	bgeu	r6,r22,820c414 <_malloc_r+0x6cc>
 820c178:	81400117 	ldw	r5,4(r16)
 820c17c:	013ffe04 	movi	r4,-8
 820c180:	b0bffd04 	addi	r2,r22,-12
 820c184:	1104703a 	and	r2,r2,r4
 820c188:	2900004c 	andi	r4,r5,1
 820c18c:	2088b03a 	or	r4,r4,r2
 820c190:	81000115 	stw	r4,4(r16)
 820c194:	01400144 	movi	r5,5
 820c198:	8089883a 	add	r4,r16,r2
 820c19c:	21400115 	stw	r5,4(r4)
 820c1a0:	21400215 	stw	r5,8(r4)
 820c1a4:	3080cd36 	bltu	r6,r2,820c4dc <_malloc_r+0x794>
 820c1a8:	00820974 	movhi	r2,2085
 820c1ac:	10901a04 	addi	r2,r2,16488
 820c1b0:	11000017 	ldw	r4,0(r2)
 820c1b4:	20c0012e 	bgeu	r4,r3,820c1bc <_malloc_r+0x474>
 820c1b8:	10c00015 	stw	r3,0(r2)
 820c1bc:	00820974 	movhi	r2,2085
 820c1c0:	10901904 	addi	r2,r2,16484
 820c1c4:	11000017 	ldw	r4,0(r2)
 820c1c8:	9c000217 	ldw	r16,8(r19)
 820c1cc:	20c0012e 	bgeu	r4,r3,820c1d4 <_malloc_r+0x48c>
 820c1d0:	10c00015 	stw	r3,0(r2)
 820c1d4:	80c00117 	ldw	r3,4(r16)
 820c1d8:	00bfff04 	movi	r2,-4
 820c1dc:	1886703a 	and	r3,r3,r2
 820c1e0:	1c45c83a 	sub	r2,r3,r17
 820c1e4:	1c400236 	bltu	r3,r17,820c1f0 <_malloc_r+0x4a8>
 820c1e8:	00c003c4 	movi	r3,15
 820c1ec:	18800416 	blt	r3,r2,820c200 <_malloc_r+0x4b8>
 820c1f0:	9009883a 	mov	r4,r18
 820c1f4:	8214b740 	call	8214b74 <__malloc_unlock>
 820c1f8:	0005883a 	mov	r2,zero
 820c1fc:	003f7b06 	br	820bfec <_malloc_r+0x2a4>
 820c200:	88c00054 	ori	r3,r17,1
 820c204:	80c00115 	stw	r3,4(r16)
 820c208:	8463883a 	add	r17,r16,r17
 820c20c:	10800054 	ori	r2,r2,1
 820c210:	9c400215 	stw	r17,8(r19)
 820c214:	88800115 	stw	r2,4(r17)
 820c218:	9009883a 	mov	r4,r18
 820c21c:	8214b740 	call	8214b74 <__malloc_unlock>
 820c220:	80800204 	addi	r2,r16,8
 820c224:	003f7106 	br	820bfec <_malloc_r+0x2a4>
 820c228:	00c00504 	movi	r3,20
 820c22c:	18804a2e 	bgeu	r3,r2,820c358 <_malloc_r+0x610>
 820c230:	00c01504 	movi	r3,84
 820c234:	18806e36 	bltu	r3,r2,820c3f0 <_malloc_r+0x6a8>
 820c238:	8804d33a 	srli	r2,r17,12
 820c23c:	12001bc4 	addi	r8,r2,111
 820c240:	11c01b84 	addi	r7,r2,110
 820c244:	4209883a 	add	r4,r8,r8
 820c248:	003edd06 	br	820bdc0 <_malloc_r+0x78>
 820c24c:	3804d27a 	srli	r2,r7,9
 820c250:	00c00104 	movi	r3,4
 820c254:	1880442e 	bgeu	r3,r2,820c368 <_malloc_r+0x620>
 820c258:	00c00504 	movi	r3,20
 820c25c:	18808136 	bltu	r3,r2,820c464 <_malloc_r+0x71c>
 820c260:	11401704 	addi	r5,r2,92
 820c264:	10c016c4 	addi	r3,r2,91
 820c268:	294b883a 	add	r5,r5,r5
 820c26c:	294b883a 	add	r5,r5,r5
 820c270:	294b883a 	add	r5,r5,r5
 820c274:	994b883a 	add	r5,r19,r5
 820c278:	28800017 	ldw	r2,0(r5)
 820c27c:	01820974 	movhi	r6,2085
 820c280:	297ffe04 	addi	r5,r5,-8
 820c284:	31894904 	addi	r6,r6,9508
 820c288:	28806526 	beq	r5,r2,820c420 <_malloc_r+0x6d8>
 820c28c:	01bfff04 	movi	r6,-4
 820c290:	10c00117 	ldw	r3,4(r2)
 820c294:	1986703a 	and	r3,r3,r6
 820c298:	38c0022e 	bgeu	r7,r3,820c2a4 <_malloc_r+0x55c>
 820c29c:	10800217 	ldw	r2,8(r2)
 820c2a0:	28bffb1e 	bne	r5,r2,820c290 <_malloc_r+0x548>
 820c2a4:	11400317 	ldw	r5,12(r2)
 820c2a8:	98c00117 	ldw	r3,4(r19)
 820c2ac:	81400315 	stw	r5,12(r16)
 820c2b0:	80800215 	stw	r2,8(r16)
 820c2b4:	2c000215 	stw	r16,8(r5)
 820c2b8:	14000315 	stw	r16,12(r2)
 820c2bc:	003ef806 	br	820bea0 <_malloc_r+0x158>
 820c2c0:	88c00054 	ori	r3,r17,1
 820c2c4:	80c00115 	stw	r3,4(r16)
 820c2c8:	8463883a 	add	r17,r16,r17
 820c2cc:	34400515 	stw	r17,20(r6)
 820c2d0:	34400415 	stw	r17,16(r6)
 820c2d4:	10c00054 	ori	r3,r2,1
 820c2d8:	8a000315 	stw	r8,12(r17)
 820c2dc:	8a000215 	stw	r8,8(r17)
 820c2e0:	88c00115 	stw	r3,4(r17)
 820c2e4:	88a3883a 	add	r17,r17,r2
 820c2e8:	88800015 	stw	r2,0(r17)
 820c2ec:	9009883a 	mov	r4,r18
 820c2f0:	8214b740 	call	8214b74 <__malloc_unlock>
 820c2f4:	80800204 	addi	r2,r16,8
 820c2f8:	003f3c06 	br	820bfec <_malloc_r+0x2a4>
 820c2fc:	30c00117 	ldw	r3,4(r6)
 820c300:	003ee706 	br	820bea0 <_malloc_r+0x158>
 820c304:	5ac00044 	addi	r11,r11,1
 820c308:	588000cc 	andi	r2,r11,3
 820c30c:	31800204 	addi	r6,r6,8
 820c310:	103efd1e 	bne	r2,zero,820bf08 <_malloc_r+0x1c0>
 820c314:	00002406 	br	820c3a8 <_malloc_r+0x660>
 820c318:	14000317 	ldw	r16,12(r2)
 820c31c:	143f251e 	bne	r2,r16,820bfb4 <_malloc_r+0x26c>
 820c320:	21000084 	addi	r4,r4,2
 820c324:	003ebc06 	br	820be18 <_malloc_r+0xd0>
 820c328:	8085883a 	add	r2,r16,r2
 820c32c:	10c00117 	ldw	r3,4(r2)
 820c330:	81000317 	ldw	r4,12(r16)
 820c334:	81400217 	ldw	r5,8(r16)
 820c338:	18c00054 	ori	r3,r3,1
 820c33c:	10c00115 	stw	r3,4(r2)
 820c340:	29000315 	stw	r4,12(r5)
 820c344:	21400215 	stw	r5,8(r4)
 820c348:	9009883a 	mov	r4,r18
 820c34c:	8214b740 	call	8214b74 <__malloc_unlock>
 820c350:	80800204 	addi	r2,r16,8
 820c354:	003f2506 	br	820bfec <_malloc_r+0x2a4>
 820c358:	12001704 	addi	r8,r2,92
 820c35c:	11c016c4 	addi	r7,r2,91
 820c360:	4209883a 	add	r4,r8,r8
 820c364:	003e9606 	br	820bdc0 <_malloc_r+0x78>
 820c368:	3804d1ba 	srli	r2,r7,6
 820c36c:	11400e44 	addi	r5,r2,57
 820c370:	10c00e04 	addi	r3,r2,56
 820c374:	294b883a 	add	r5,r5,r5
 820c378:	003fbc06 	br	820c26c <_malloc_r+0x524>
 820c37c:	84ff5926 	beq	r16,r19,820c0e4 <_malloc_r+0x39c>
 820c380:	00820974 	movhi	r2,2085
 820c384:	10894904 	addi	r2,r2,9508
 820c388:	14000217 	ldw	r16,8(r2)
 820c38c:	00bfff04 	movi	r2,-4
 820c390:	80c00117 	ldw	r3,4(r16)
 820c394:	1886703a 	and	r3,r3,r2
 820c398:	003f9106 	br	820c1e0 <_malloc_r+0x498>
 820c39c:	60800217 	ldw	r2,8(r12)
 820c3a0:	213fffc4 	addi	r4,r4,-1
 820c3a4:	1300651e 	bne	r2,r12,820c53c <_malloc_r+0x7f4>
 820c3a8:	208000cc 	andi	r2,r4,3
 820c3ac:	633ffe04 	addi	r12,r12,-8
 820c3b0:	103ffa1e 	bne	r2,zero,820c39c <_malloc_r+0x654>
 820c3b4:	98800117 	ldw	r2,4(r19)
 820c3b8:	0146303a 	nor	r3,zero,r5
 820c3bc:	1884703a 	and	r2,r3,r2
 820c3c0:	98800115 	stw	r2,4(r19)
 820c3c4:	294b883a 	add	r5,r5,r5
 820c3c8:	117f2836 	bltu	r2,r5,820c06c <_malloc_r+0x324>
 820c3cc:	283f2726 	beq	r5,zero,820c06c <_malloc_r+0x324>
 820c3d0:	2886703a 	and	r3,r5,r2
 820c3d4:	5809883a 	mov	r4,r11
 820c3d8:	183ec31e 	bne	r3,zero,820bee8 <_malloc_r+0x1a0>
 820c3dc:	294b883a 	add	r5,r5,r5
 820c3e0:	2886703a 	and	r3,r5,r2
 820c3e4:	21000104 	addi	r4,r4,4
 820c3e8:	183ffc26 	beq	r3,zero,820c3dc <_malloc_r+0x694>
 820c3ec:	003ebe06 	br	820bee8 <_malloc_r+0x1a0>
 820c3f0:	00c05504 	movi	r3,340
 820c3f4:	18801236 	bltu	r3,r2,820c440 <_malloc_r+0x6f8>
 820c3f8:	8804d3fa 	srli	r2,r17,15
 820c3fc:	12001e04 	addi	r8,r2,120
 820c400:	11c01dc4 	addi	r7,r2,119
 820c404:	4209883a 	add	r4,r8,r8
 820c408:	003e6d06 	br	820bdc0 <_malloc_r+0x78>
 820c40c:	00c40004 	movi	r3,4096
 820c410:	003f4606 	br	820c12c <_malloc_r+0x3e4>
 820c414:	00800044 	movi	r2,1
 820c418:	a0800115 	stw	r2,4(r20)
 820c41c:	003f7406 	br	820c1f0 <_malloc_r+0x4a8>
 820c420:	1805d0ba 	srai	r2,r3,2
 820c424:	01c00044 	movi	r7,1
 820c428:	30c00117 	ldw	r3,4(r6)
 820c42c:	388e983a 	sll	r7,r7,r2
 820c430:	2805883a 	mov	r2,r5
 820c434:	38c6b03a 	or	r3,r7,r3
 820c438:	30c00115 	stw	r3,4(r6)
 820c43c:	003f9b06 	br	820c2ac <_malloc_r+0x564>
 820c440:	00c15504 	movi	r3,1364
 820c444:	18801a36 	bltu	r3,r2,820c4b0 <_malloc_r+0x768>
 820c448:	8804d4ba 	srli	r2,r17,18
 820c44c:	12001f44 	addi	r8,r2,125
 820c450:	11c01f04 	addi	r7,r2,124
 820c454:	4209883a 	add	r4,r8,r8
 820c458:	003e5906 	br	820bdc0 <_malloc_r+0x78>
 820c45c:	ad400404 	addi	r21,r21,16
 820c460:	003f1706 	br	820c0c0 <_malloc_r+0x378>
 820c464:	00c01504 	movi	r3,84
 820c468:	18802336 	bltu	r3,r2,820c4f8 <_malloc_r+0x7b0>
 820c46c:	3804d33a 	srli	r2,r7,12
 820c470:	11401bc4 	addi	r5,r2,111
 820c474:	10c01b84 	addi	r3,r2,110
 820c478:	294b883a 	add	r5,r5,r5
 820c47c:	003f7b06 	br	820c26c <_malloc_r+0x524>
 820c480:	9c000217 	ldw	r16,8(r19)
 820c484:	00bfff04 	movi	r2,-4
 820c488:	80c00117 	ldw	r3,4(r16)
 820c48c:	1886703a 	and	r3,r3,r2
 820c490:	003f5306 	br	820c1e0 <_malloc_r+0x498>
 820c494:	3083ffcc 	andi	r2,r6,4095
 820c498:	103f181e 	bne	r2,zero,820c0fc <_malloc_r+0x3b4>
 820c49c:	99000217 	ldw	r4,8(r19)
 820c4a0:	b545883a 	add	r2,r22,r21
 820c4a4:	10800054 	ori	r2,r2,1
 820c4a8:	20800115 	stw	r2,4(r4)
 820c4ac:	003f3e06 	br	820c1a8 <_malloc_r+0x460>
 820c4b0:	01003f84 	movi	r4,254
 820c4b4:	02001fc4 	movi	r8,127
 820c4b8:	01c01f84 	movi	r7,126
 820c4bc:	003e4006 	br	820bdc0 <_malloc_r+0x78>
 820c4c0:	00820974 	movhi	r2,2085
 820c4c4:	108fbd04 	addi	r2,r2,16116
 820c4c8:	15000015 	stw	r20,0(r2)
 820c4cc:	003f1106 	br	820c114 <_malloc_r+0x3cc>
 820c4d0:	00800044 	movi	r2,1
 820c4d4:	002b883a 	mov	r21,zero
 820c4d8:	003f1f06 	br	820c158 <_malloc_r+0x410>
 820c4dc:	81400204 	addi	r5,r16,8
 820c4e0:	9009883a 	mov	r4,r18
 820c4e4:	820b15c0 	call	820b15c <_free_r>
 820c4e8:	00820974 	movhi	r2,2085
 820c4ec:	10921204 	addi	r2,r2,18504
 820c4f0:	10c00017 	ldw	r3,0(r2)
 820c4f4:	003f2c06 	br	820c1a8 <_malloc_r+0x460>
 820c4f8:	00c05504 	movi	r3,340
 820c4fc:	18800536 	bltu	r3,r2,820c514 <_malloc_r+0x7cc>
 820c500:	3804d3fa 	srli	r2,r7,15
 820c504:	11401e04 	addi	r5,r2,120
 820c508:	10c01dc4 	addi	r3,r2,119
 820c50c:	294b883a 	add	r5,r5,r5
 820c510:	003f5606 	br	820c26c <_malloc_r+0x524>
 820c514:	00c15504 	movi	r3,1364
 820c518:	18800536 	bltu	r3,r2,820c530 <_malloc_r+0x7e8>
 820c51c:	3804d4ba 	srli	r2,r7,18
 820c520:	11401f44 	addi	r5,r2,125
 820c524:	10c01f04 	addi	r3,r2,124
 820c528:	294b883a 	add	r5,r5,r5
 820c52c:	003f4f06 	br	820c26c <_malloc_r+0x524>
 820c530:	01403f84 	movi	r5,254
 820c534:	00c01f84 	movi	r3,126
 820c538:	003f4c06 	br	820c26c <_malloc_r+0x524>
 820c53c:	98800117 	ldw	r2,4(r19)
 820c540:	003fa006 	br	820c3c4 <_malloc_r+0x67c>
 820c544:	8808d0fa 	srli	r4,r17,3
 820c548:	20800044 	addi	r2,r4,1
 820c54c:	1085883a 	add	r2,r2,r2
 820c550:	003e9006 	br	820bf94 <_malloc_r+0x24c>

0820c554 <memchr>:
 820c554:	208000cc 	andi	r2,r4,3
 820c558:	280f883a 	mov	r7,r5
 820c55c:	10003426 	beq	r2,zero,820c630 <memchr+0xdc>
 820c560:	30bfffc4 	addi	r2,r6,-1
 820c564:	30001a26 	beq	r6,zero,820c5d0 <memchr+0x7c>
 820c568:	20c00003 	ldbu	r3,0(r4)
 820c56c:	29803fcc 	andi	r6,r5,255
 820c570:	30c0051e 	bne	r6,r3,820c588 <memchr+0x34>
 820c574:	00001806 	br	820c5d8 <memchr+0x84>
 820c578:	10001526 	beq	r2,zero,820c5d0 <memchr+0x7c>
 820c57c:	20c00003 	ldbu	r3,0(r4)
 820c580:	10bfffc4 	addi	r2,r2,-1
 820c584:	30c01426 	beq	r6,r3,820c5d8 <memchr+0x84>
 820c588:	21000044 	addi	r4,r4,1
 820c58c:	20c000cc 	andi	r3,r4,3
 820c590:	183ff91e 	bne	r3,zero,820c578 <memchr+0x24>
 820c594:	020000c4 	movi	r8,3
 820c598:	40801136 	bltu	r8,r2,820c5e0 <memchr+0x8c>
 820c59c:	10000c26 	beq	r2,zero,820c5d0 <memchr+0x7c>
 820c5a0:	20c00003 	ldbu	r3,0(r4)
 820c5a4:	29403fcc 	andi	r5,r5,255
 820c5a8:	28c00b26 	beq	r5,r3,820c5d8 <memchr+0x84>
 820c5ac:	20c00044 	addi	r3,r4,1
 820c5b0:	39803fcc 	andi	r6,r7,255
 820c5b4:	2089883a 	add	r4,r4,r2
 820c5b8:	00000306 	br	820c5c8 <memchr+0x74>
 820c5bc:	18c00044 	addi	r3,r3,1
 820c5c0:	197fffc3 	ldbu	r5,-1(r3)
 820c5c4:	31400526 	beq	r6,r5,820c5dc <memchr+0x88>
 820c5c8:	1805883a 	mov	r2,r3
 820c5cc:	20fffb1e 	bne	r4,r3,820c5bc <memchr+0x68>
 820c5d0:	0005883a 	mov	r2,zero
 820c5d4:	f800283a 	ret
 820c5d8:	2005883a 	mov	r2,r4
 820c5dc:	f800283a 	ret
 820c5e0:	28c03fcc 	andi	r3,r5,255
 820c5e4:	1812923a 	slli	r9,r3,8
 820c5e8:	02ffbff4 	movhi	r11,65279
 820c5ec:	02a02074 	movhi	r10,32897
 820c5f0:	48d2b03a 	or	r9,r9,r3
 820c5f4:	4806943a 	slli	r3,r9,16
 820c5f8:	5affbfc4 	addi	r11,r11,-257
 820c5fc:	52a02004 	addi	r10,r10,-32640
 820c600:	48d2b03a 	or	r9,r9,r3
 820c604:	20c00017 	ldw	r3,0(r4)
 820c608:	48c6f03a 	xor	r3,r9,r3
 820c60c:	1acd883a 	add	r6,r3,r11
 820c610:	00c6303a 	nor	r3,zero,r3
 820c614:	30c6703a 	and	r3,r6,r3
 820c618:	1a86703a 	and	r3,r3,r10
 820c61c:	183fe01e 	bne	r3,zero,820c5a0 <memchr+0x4c>
 820c620:	10bfff04 	addi	r2,r2,-4
 820c624:	21000104 	addi	r4,r4,4
 820c628:	40bff636 	bltu	r8,r2,820c604 <memchr+0xb0>
 820c62c:	003fdb06 	br	820c59c <memchr+0x48>
 820c630:	3005883a 	mov	r2,r6
 820c634:	003fd706 	br	820c594 <memchr+0x40>

0820c638 <memcmp>:
 820c638:	01c000c4 	movi	r7,3
 820c63c:	3980192e 	bgeu	r7,r6,820c6a4 <memcmp+0x6c>
 820c640:	2144b03a 	or	r2,r4,r5
 820c644:	11c4703a 	and	r2,r2,r7
 820c648:	10000f26 	beq	r2,zero,820c688 <memcmp+0x50>
 820c64c:	20800003 	ldbu	r2,0(r4)
 820c650:	28c00003 	ldbu	r3,0(r5)
 820c654:	10c0151e 	bne	r2,r3,820c6ac <memcmp+0x74>
 820c658:	31bfff84 	addi	r6,r6,-2
 820c65c:	01ffffc4 	movi	r7,-1
 820c660:	00000406 	br	820c674 <memcmp+0x3c>
 820c664:	20800003 	ldbu	r2,0(r4)
 820c668:	28c00003 	ldbu	r3,0(r5)
 820c66c:	31bfffc4 	addi	r6,r6,-1
 820c670:	10c00e1e 	bne	r2,r3,820c6ac <memcmp+0x74>
 820c674:	21000044 	addi	r4,r4,1
 820c678:	29400044 	addi	r5,r5,1
 820c67c:	31fff91e 	bne	r6,r7,820c664 <memcmp+0x2c>
 820c680:	0005883a 	mov	r2,zero
 820c684:	f800283a 	ret
 820c688:	20c00017 	ldw	r3,0(r4)
 820c68c:	28800017 	ldw	r2,0(r5)
 820c690:	18bfee1e 	bne	r3,r2,820c64c <memcmp+0x14>
 820c694:	31bfff04 	addi	r6,r6,-4
 820c698:	21000104 	addi	r4,r4,4
 820c69c:	29400104 	addi	r5,r5,4
 820c6a0:	39bff936 	bltu	r7,r6,820c688 <memcmp+0x50>
 820c6a4:	303fe91e 	bne	r6,zero,820c64c <memcmp+0x14>
 820c6a8:	003ff506 	br	820c680 <memcmp+0x48>
 820c6ac:	10c5c83a 	sub	r2,r2,r3
 820c6b0:	f800283a 	ret

0820c6b4 <_Balloc>:
 820c6b4:	20801317 	ldw	r2,76(r4)
 820c6b8:	defffc04 	addi	sp,sp,-16
 820c6bc:	dc400115 	stw	r17,4(sp)
 820c6c0:	dc000015 	stw	r16,0(sp)
 820c6c4:	dfc00315 	stw	ra,12(sp)
 820c6c8:	dc800215 	stw	r18,8(sp)
 820c6cc:	2023883a 	mov	r17,r4
 820c6d0:	2821883a 	mov	r16,r5
 820c6d4:	10000f26 	beq	r2,zero,820c714 <_Balloc+0x60>
 820c6d8:	8407883a 	add	r3,r16,r16
 820c6dc:	18c7883a 	add	r3,r3,r3
 820c6e0:	10c7883a 	add	r3,r2,r3
 820c6e4:	18800017 	ldw	r2,0(r3)
 820c6e8:	10001126 	beq	r2,zero,820c730 <_Balloc+0x7c>
 820c6ec:	11000017 	ldw	r4,0(r2)
 820c6f0:	19000015 	stw	r4,0(r3)
 820c6f4:	10000415 	stw	zero,16(r2)
 820c6f8:	10000315 	stw	zero,12(r2)
 820c6fc:	dfc00317 	ldw	ra,12(sp)
 820c700:	dc800217 	ldw	r18,8(sp)
 820c704:	dc400117 	ldw	r17,4(sp)
 820c708:	dc000017 	ldw	r16,0(sp)
 820c70c:	dec00404 	addi	sp,sp,16
 820c710:	f800283a 	ret
 820c714:	01800844 	movi	r6,33
 820c718:	01400104 	movi	r5,4
 820c71c:	8210bec0 	call	8210bec <_calloc_r>
 820c720:	88801315 	stw	r2,76(r17)
 820c724:	103fec1e 	bne	r2,zero,820c6d8 <_Balloc+0x24>
 820c728:	0005883a 	mov	r2,zero
 820c72c:	003ff306 	br	820c6fc <_Balloc+0x48>
 820c730:	01400044 	movi	r5,1
 820c734:	2c24983a 	sll	r18,r5,r16
 820c738:	8809883a 	mov	r4,r17
 820c73c:	91800144 	addi	r6,r18,5
 820c740:	318d883a 	add	r6,r6,r6
 820c744:	318d883a 	add	r6,r6,r6
 820c748:	8210bec0 	call	8210bec <_calloc_r>
 820c74c:	103ff626 	beq	r2,zero,820c728 <_Balloc+0x74>
 820c750:	14000115 	stw	r16,4(r2)
 820c754:	14800215 	stw	r18,8(r2)
 820c758:	003fe606 	br	820c6f4 <_Balloc+0x40>

0820c75c <_Bfree>:
 820c75c:	28000826 	beq	r5,zero,820c780 <_Bfree+0x24>
 820c760:	28c00117 	ldw	r3,4(r5)
 820c764:	20801317 	ldw	r2,76(r4)
 820c768:	18c7883a 	add	r3,r3,r3
 820c76c:	18c7883a 	add	r3,r3,r3
 820c770:	10c5883a 	add	r2,r2,r3
 820c774:	10c00017 	ldw	r3,0(r2)
 820c778:	28c00015 	stw	r3,0(r5)
 820c77c:	11400015 	stw	r5,0(r2)
 820c780:	f800283a 	ret

0820c784 <__multadd>:
 820c784:	defffa04 	addi	sp,sp,-24
 820c788:	dc800315 	stw	r18,12(sp)
 820c78c:	dc400215 	stw	r17,8(sp)
 820c790:	dc000115 	stw	r16,4(sp)
 820c794:	2823883a 	mov	r17,r5
 820c798:	2c000417 	ldw	r16,16(r5)
 820c79c:	dfc00515 	stw	ra,20(sp)
 820c7a0:	dcc00415 	stw	r19,16(sp)
 820c7a4:	2025883a 	mov	r18,r4
 820c7a8:	29400504 	addi	r5,r5,20
 820c7ac:	0011883a 	mov	r8,zero
 820c7b0:	28c00017 	ldw	r3,0(r5)
 820c7b4:	29400104 	addi	r5,r5,4
 820c7b8:	42000044 	addi	r8,r8,1
 820c7bc:	18bfffcc 	andi	r2,r3,65535
 820c7c0:	1185383a 	mul	r2,r2,r6
 820c7c4:	1806d43a 	srli	r3,r3,16
 820c7c8:	11cf883a 	add	r7,r2,r7
 820c7cc:	3808d43a 	srli	r4,r7,16
 820c7d0:	1987383a 	mul	r3,r3,r6
 820c7d4:	38bfffcc 	andi	r2,r7,65535
 820c7d8:	1907883a 	add	r3,r3,r4
 820c7dc:	1808943a 	slli	r4,r3,16
 820c7e0:	180ed43a 	srli	r7,r3,16
 820c7e4:	2085883a 	add	r2,r4,r2
 820c7e8:	28bfff15 	stw	r2,-4(r5)
 820c7ec:	443ff016 	blt	r8,r16,820c7b0 <__multadd+0x2c>
 820c7f0:	38000926 	beq	r7,zero,820c818 <__multadd+0x94>
 820c7f4:	88800217 	ldw	r2,8(r17)
 820c7f8:	80800f0e 	bge	r16,r2,820c838 <__multadd+0xb4>
 820c7fc:	80800144 	addi	r2,r16,5
 820c800:	1085883a 	add	r2,r2,r2
 820c804:	1085883a 	add	r2,r2,r2
 820c808:	8885883a 	add	r2,r17,r2
 820c80c:	11c00015 	stw	r7,0(r2)
 820c810:	84000044 	addi	r16,r16,1
 820c814:	8c000415 	stw	r16,16(r17)
 820c818:	8805883a 	mov	r2,r17
 820c81c:	dfc00517 	ldw	ra,20(sp)
 820c820:	dcc00417 	ldw	r19,16(sp)
 820c824:	dc800317 	ldw	r18,12(sp)
 820c828:	dc400217 	ldw	r17,8(sp)
 820c82c:	dc000117 	ldw	r16,4(sp)
 820c830:	dec00604 	addi	sp,sp,24
 820c834:	f800283a 	ret
 820c838:	89400117 	ldw	r5,4(r17)
 820c83c:	9009883a 	mov	r4,r18
 820c840:	d9c00015 	stw	r7,0(sp)
 820c844:	29400044 	addi	r5,r5,1
 820c848:	820c6b40 	call	820c6b4 <_Balloc>
 820c84c:	89800417 	ldw	r6,16(r17)
 820c850:	89400304 	addi	r5,r17,12
 820c854:	11000304 	addi	r4,r2,12
 820c858:	31800084 	addi	r6,r6,2
 820c85c:	318d883a 	add	r6,r6,r6
 820c860:	318d883a 	add	r6,r6,r6
 820c864:	1027883a 	mov	r19,r2
 820c868:	8202f6c0 	call	8202f6c <memcpy>
 820c86c:	d9c00017 	ldw	r7,0(sp)
 820c870:	88000a26 	beq	r17,zero,820c89c <__multadd+0x118>
 820c874:	88c00117 	ldw	r3,4(r17)
 820c878:	90801317 	ldw	r2,76(r18)
 820c87c:	18c7883a 	add	r3,r3,r3
 820c880:	18c7883a 	add	r3,r3,r3
 820c884:	10c5883a 	add	r2,r2,r3
 820c888:	10c00017 	ldw	r3,0(r2)
 820c88c:	88c00015 	stw	r3,0(r17)
 820c890:	14400015 	stw	r17,0(r2)
 820c894:	9823883a 	mov	r17,r19
 820c898:	003fd806 	br	820c7fc <__multadd+0x78>
 820c89c:	9823883a 	mov	r17,r19
 820c8a0:	003fd606 	br	820c7fc <__multadd+0x78>

0820c8a4 <__s2b>:
 820c8a4:	defff904 	addi	sp,sp,-28
 820c8a8:	dc400115 	stw	r17,4(sp)
 820c8ac:	dc000015 	stw	r16,0(sp)
 820c8b0:	2023883a 	mov	r17,r4
 820c8b4:	2821883a 	mov	r16,r5
 820c8b8:	39000204 	addi	r4,r7,8
 820c8bc:	01400244 	movi	r5,9
 820c8c0:	dcc00315 	stw	r19,12(sp)
 820c8c4:	dc800215 	stw	r18,8(sp)
 820c8c8:	dfc00615 	stw	ra,24(sp)
 820c8cc:	dd400515 	stw	r21,20(sp)
 820c8d0:	dd000415 	stw	r20,16(sp)
 820c8d4:	3825883a 	mov	r18,r7
 820c8d8:	3027883a 	mov	r19,r6
 820c8dc:	8202b740 	call	8202b74 <__divsi3>
 820c8e0:	00c00044 	movi	r3,1
 820c8e4:	000b883a 	mov	r5,zero
 820c8e8:	1880030e 	bge	r3,r2,820c8f8 <__s2b+0x54>
 820c8ec:	18c7883a 	add	r3,r3,r3
 820c8f0:	29400044 	addi	r5,r5,1
 820c8f4:	18bffd16 	blt	r3,r2,820c8ec <__s2b+0x48>
 820c8f8:	8809883a 	mov	r4,r17
 820c8fc:	820c6b40 	call	820c6b4 <_Balloc>
 820c900:	d8c00717 	ldw	r3,28(sp)
 820c904:	10c00515 	stw	r3,20(r2)
 820c908:	00c00044 	movi	r3,1
 820c90c:	10c00415 	stw	r3,16(r2)
 820c910:	00c00244 	movi	r3,9
 820c914:	1cc0210e 	bge	r3,r19,820c99c <__s2b+0xf8>
 820c918:	80eb883a 	add	r21,r16,r3
 820c91c:	a829883a 	mov	r20,r21
 820c920:	84e1883a 	add	r16,r16,r19
 820c924:	a1c00007 	ldb	r7,0(r20)
 820c928:	01800284 	movi	r6,10
 820c92c:	a5000044 	addi	r20,r20,1
 820c930:	100b883a 	mov	r5,r2
 820c934:	39fff404 	addi	r7,r7,-48
 820c938:	8809883a 	mov	r4,r17
 820c93c:	820c7840 	call	820c784 <__multadd>
 820c940:	a43ff81e 	bne	r20,r16,820c924 <__s2b+0x80>
 820c944:	ace1883a 	add	r16,r21,r19
 820c948:	843ffe04 	addi	r16,r16,-8
 820c94c:	9c800a0e 	bge	r19,r18,820c978 <__s2b+0xd4>
 820c950:	94e5c83a 	sub	r18,r18,r19
 820c954:	84a5883a 	add	r18,r16,r18
 820c958:	81c00007 	ldb	r7,0(r16)
 820c95c:	01800284 	movi	r6,10
 820c960:	84000044 	addi	r16,r16,1
 820c964:	100b883a 	mov	r5,r2
 820c968:	39fff404 	addi	r7,r7,-48
 820c96c:	8809883a 	mov	r4,r17
 820c970:	820c7840 	call	820c784 <__multadd>
 820c974:	84bff81e 	bne	r16,r18,820c958 <__s2b+0xb4>
 820c978:	dfc00617 	ldw	ra,24(sp)
 820c97c:	dd400517 	ldw	r21,20(sp)
 820c980:	dd000417 	ldw	r20,16(sp)
 820c984:	dcc00317 	ldw	r19,12(sp)
 820c988:	dc800217 	ldw	r18,8(sp)
 820c98c:	dc400117 	ldw	r17,4(sp)
 820c990:	dc000017 	ldw	r16,0(sp)
 820c994:	dec00704 	addi	sp,sp,28
 820c998:	f800283a 	ret
 820c99c:	84000284 	addi	r16,r16,10
 820c9a0:	1827883a 	mov	r19,r3
 820c9a4:	003fe906 	br	820c94c <__s2b+0xa8>

0820c9a8 <__hi0bits>:
 820c9a8:	20bfffec 	andhi	r2,r4,65535
 820c9ac:	1000141e 	bne	r2,zero,820ca00 <__hi0bits+0x58>
 820c9b0:	2008943a 	slli	r4,r4,16
 820c9b4:	00800404 	movi	r2,16
 820c9b8:	20ffc02c 	andhi	r3,r4,65280
 820c9bc:	1800021e 	bne	r3,zero,820c9c8 <__hi0bits+0x20>
 820c9c0:	2008923a 	slli	r4,r4,8
 820c9c4:	10800204 	addi	r2,r2,8
 820c9c8:	20fc002c 	andhi	r3,r4,61440
 820c9cc:	1800021e 	bne	r3,zero,820c9d8 <__hi0bits+0x30>
 820c9d0:	2008913a 	slli	r4,r4,4
 820c9d4:	10800104 	addi	r2,r2,4
 820c9d8:	20f0002c 	andhi	r3,r4,49152
 820c9dc:	1800031e 	bne	r3,zero,820c9ec <__hi0bits+0x44>
 820c9e0:	2109883a 	add	r4,r4,r4
 820c9e4:	10800084 	addi	r2,r2,2
 820c9e8:	2109883a 	add	r4,r4,r4
 820c9ec:	20000316 	blt	r4,zero,820c9fc <__hi0bits+0x54>
 820c9f0:	2110002c 	andhi	r4,r4,16384
 820c9f4:	2000041e 	bne	r4,zero,820ca08 <__hi0bits+0x60>
 820c9f8:	00800804 	movi	r2,32
 820c9fc:	f800283a 	ret
 820ca00:	0005883a 	mov	r2,zero
 820ca04:	003fec06 	br	820c9b8 <__hi0bits+0x10>
 820ca08:	10800044 	addi	r2,r2,1
 820ca0c:	f800283a 	ret

0820ca10 <__lo0bits>:
 820ca10:	20c00017 	ldw	r3,0(r4)
 820ca14:	188001cc 	andi	r2,r3,7
 820ca18:	10000826 	beq	r2,zero,820ca3c <__lo0bits+0x2c>
 820ca1c:	1880004c 	andi	r2,r3,1
 820ca20:	1000211e 	bne	r2,zero,820caa8 <__lo0bits+0x98>
 820ca24:	1880008c 	andi	r2,r3,2
 820ca28:	1000211e 	bne	r2,zero,820cab0 <__lo0bits+0xa0>
 820ca2c:	1806d0ba 	srli	r3,r3,2
 820ca30:	00800084 	movi	r2,2
 820ca34:	20c00015 	stw	r3,0(r4)
 820ca38:	f800283a 	ret
 820ca3c:	18bfffcc 	andi	r2,r3,65535
 820ca40:	10001326 	beq	r2,zero,820ca90 <__lo0bits+0x80>
 820ca44:	0005883a 	mov	r2,zero
 820ca48:	19403fcc 	andi	r5,r3,255
 820ca4c:	2800021e 	bne	r5,zero,820ca58 <__lo0bits+0x48>
 820ca50:	1806d23a 	srli	r3,r3,8
 820ca54:	10800204 	addi	r2,r2,8
 820ca58:	194003cc 	andi	r5,r3,15
 820ca5c:	2800021e 	bne	r5,zero,820ca68 <__lo0bits+0x58>
 820ca60:	1806d13a 	srli	r3,r3,4
 820ca64:	10800104 	addi	r2,r2,4
 820ca68:	194000cc 	andi	r5,r3,3
 820ca6c:	2800021e 	bne	r5,zero,820ca78 <__lo0bits+0x68>
 820ca70:	1806d0ba 	srli	r3,r3,2
 820ca74:	10800084 	addi	r2,r2,2
 820ca78:	1940004c 	andi	r5,r3,1
 820ca7c:	2800081e 	bne	r5,zero,820caa0 <__lo0bits+0x90>
 820ca80:	1806d07a 	srli	r3,r3,1
 820ca84:	1800051e 	bne	r3,zero,820ca9c <__lo0bits+0x8c>
 820ca88:	00800804 	movi	r2,32
 820ca8c:	f800283a 	ret
 820ca90:	1806d43a 	srli	r3,r3,16
 820ca94:	00800404 	movi	r2,16
 820ca98:	003feb06 	br	820ca48 <__lo0bits+0x38>
 820ca9c:	10800044 	addi	r2,r2,1
 820caa0:	20c00015 	stw	r3,0(r4)
 820caa4:	f800283a 	ret
 820caa8:	0005883a 	mov	r2,zero
 820caac:	f800283a 	ret
 820cab0:	1806d07a 	srli	r3,r3,1
 820cab4:	00800044 	movi	r2,1
 820cab8:	20c00015 	stw	r3,0(r4)
 820cabc:	f800283a 	ret

0820cac0 <__i2b>:
 820cac0:	defffd04 	addi	sp,sp,-12
 820cac4:	dc000015 	stw	r16,0(sp)
 820cac8:	04000044 	movi	r16,1
 820cacc:	dc400115 	stw	r17,4(sp)
 820cad0:	2823883a 	mov	r17,r5
 820cad4:	800b883a 	mov	r5,r16
 820cad8:	dfc00215 	stw	ra,8(sp)
 820cadc:	820c6b40 	call	820c6b4 <_Balloc>
 820cae0:	14400515 	stw	r17,20(r2)
 820cae4:	14000415 	stw	r16,16(r2)
 820cae8:	dfc00217 	ldw	ra,8(sp)
 820caec:	dc400117 	ldw	r17,4(sp)
 820caf0:	dc000017 	ldw	r16,0(sp)
 820caf4:	dec00304 	addi	sp,sp,12
 820caf8:	f800283a 	ret

0820cafc <__multiply>:
 820cafc:	defffa04 	addi	sp,sp,-24
 820cb00:	dcc00315 	stw	r19,12(sp)
 820cb04:	dc800215 	stw	r18,8(sp)
 820cb08:	34c00417 	ldw	r19,16(r6)
 820cb0c:	2c800417 	ldw	r18,16(r5)
 820cb10:	dd000415 	stw	r20,16(sp)
 820cb14:	dc400115 	stw	r17,4(sp)
 820cb18:	dfc00515 	stw	ra,20(sp)
 820cb1c:	dc000015 	stw	r16,0(sp)
 820cb20:	2829883a 	mov	r20,r5
 820cb24:	3023883a 	mov	r17,r6
 820cb28:	94c0050e 	bge	r18,r19,820cb40 <__multiply+0x44>
 820cb2c:	9007883a 	mov	r3,r18
 820cb30:	3029883a 	mov	r20,r6
 820cb34:	9825883a 	mov	r18,r19
 820cb38:	2823883a 	mov	r17,r5
 820cb3c:	1827883a 	mov	r19,r3
 820cb40:	a0800217 	ldw	r2,8(r20)
 820cb44:	94e1883a 	add	r16,r18,r19
 820cb48:	a1400117 	ldw	r5,4(r20)
 820cb4c:	1400010e 	bge	r2,r16,820cb54 <__multiply+0x58>
 820cb50:	29400044 	addi	r5,r5,1
 820cb54:	820c6b40 	call	820c6b4 <_Balloc>
 820cb58:	8415883a 	add	r10,r16,r16
 820cb5c:	12c00504 	addi	r11,r2,20
 820cb60:	5295883a 	add	r10,r10,r10
 820cb64:	5a95883a 	add	r10,r11,r10
 820cb68:	5807883a 	mov	r3,r11
 820cb6c:	5a80032e 	bgeu	r11,r10,820cb7c <__multiply+0x80>
 820cb70:	18000015 	stw	zero,0(r3)
 820cb74:	18c00104 	addi	r3,r3,4
 820cb78:	1abffd36 	bltu	r3,r10,820cb70 <__multiply+0x74>
 820cb7c:	9ce7883a 	add	r19,r19,r19
 820cb80:	94a5883a 	add	r18,r18,r18
 820cb84:	89800504 	addi	r6,r17,20
 820cb88:	9ce7883a 	add	r19,r19,r19
 820cb8c:	a3400504 	addi	r13,r20,20
 820cb90:	94a5883a 	add	r18,r18,r18
 820cb94:	34d9883a 	add	r12,r6,r19
 820cb98:	6c93883a 	add	r9,r13,r18
 820cb9c:	3300422e 	bgeu	r6,r12,820cca8 <__multiply+0x1ac>
 820cba0:	37c00017 	ldw	ra,0(r6)
 820cba4:	fbffffcc 	andi	r15,ra,65535
 820cba8:	78001b26 	beq	r15,zero,820cc18 <__multiply+0x11c>
 820cbac:	5811883a 	mov	r8,r11
 820cbb0:	681d883a 	mov	r14,r13
 820cbb4:	000f883a 	mov	r7,zero
 820cbb8:	71000017 	ldw	r4,0(r14)
 820cbbc:	40c00017 	ldw	r3,0(r8)
 820cbc0:	73800104 	addi	r14,r14,4
 820cbc4:	217fffcc 	andi	r5,r4,65535
 820cbc8:	2bcb383a 	mul	r5,r5,r15
 820cbcc:	2008d43a 	srli	r4,r4,16
 820cbd0:	1c7fffcc 	andi	r17,r3,65535
 820cbd4:	2c4b883a 	add	r5,r5,r17
 820cbd8:	29cb883a 	add	r5,r5,r7
 820cbdc:	23c9383a 	mul	r4,r4,r15
 820cbe0:	1806d43a 	srli	r3,r3,16
 820cbe4:	280ed43a 	srli	r7,r5,16
 820cbe8:	297fffcc 	andi	r5,r5,65535
 820cbec:	20c7883a 	add	r3,r4,r3
 820cbf0:	19c7883a 	add	r3,r3,r7
 820cbf4:	1808943a 	slli	r4,r3,16
 820cbf8:	4023883a 	mov	r17,r8
 820cbfc:	180ed43a 	srli	r7,r3,16
 820cc00:	214ab03a 	or	r5,r4,r5
 820cc04:	41400015 	stw	r5,0(r8)
 820cc08:	42000104 	addi	r8,r8,4
 820cc0c:	727fea36 	bltu	r14,r9,820cbb8 <__multiply+0xbc>
 820cc10:	89c00115 	stw	r7,4(r17)
 820cc14:	37c00017 	ldw	ra,0(r6)
 820cc18:	f83ed43a 	srli	ra,ra,16
 820cc1c:	f8001f26 	beq	ra,zero,820cc9c <__multiply+0x1a0>
 820cc20:	58c00017 	ldw	r3,0(r11)
 820cc24:	681d883a 	mov	r14,r13
 820cc28:	581f883a 	mov	r15,r11
 820cc2c:	1811883a 	mov	r8,r3
 820cc30:	5825883a 	mov	r18,r11
 820cc34:	000f883a 	mov	r7,zero
 820cc38:	00000106 	br	820cc40 <__multiply+0x144>
 820cc3c:	8825883a 	mov	r18,r17
 820cc40:	7140000b 	ldhu	r5,0(r14)
 820cc44:	4010d43a 	srli	r8,r8,16
 820cc48:	193fffcc 	andi	r4,r3,65535
 820cc4c:	2fcb383a 	mul	r5,r5,ra
 820cc50:	7bc00104 	addi	r15,r15,4
 820cc54:	73800104 	addi	r14,r14,4
 820cc58:	2a0b883a 	add	r5,r5,r8
 820cc5c:	29cb883a 	add	r5,r5,r7
 820cc60:	2806943a 	slli	r3,r5,16
 820cc64:	94400104 	addi	r17,r18,4
 820cc68:	280ad43a 	srli	r5,r5,16
 820cc6c:	1908b03a 	or	r4,r3,r4
 820cc70:	793fff15 	stw	r4,-4(r15)
 820cc74:	70ffff17 	ldw	r3,-4(r14)
 820cc78:	8a000017 	ldw	r8,0(r17)
 820cc7c:	1806d43a 	srli	r3,r3,16
 820cc80:	413fffcc 	andi	r4,r8,65535
 820cc84:	1fc7383a 	mul	r3,r3,ra
 820cc88:	1907883a 	add	r3,r3,r4
 820cc8c:	1947883a 	add	r3,r3,r5
 820cc90:	180ed43a 	srli	r7,r3,16
 820cc94:	727fe936 	bltu	r14,r9,820cc3c <__multiply+0x140>
 820cc98:	90c00115 	stw	r3,4(r18)
 820cc9c:	31800104 	addi	r6,r6,4
 820cca0:	5ac00104 	addi	r11,r11,4
 820cca4:	333fbe36 	bltu	r6,r12,820cba0 <__multiply+0xa4>
 820cca8:	0400090e 	bge	zero,r16,820ccd0 <__multiply+0x1d4>
 820ccac:	50ffff17 	ldw	r3,-4(r10)
 820ccb0:	52bfff04 	addi	r10,r10,-4
 820ccb4:	18000326 	beq	r3,zero,820ccc4 <__multiply+0x1c8>
 820ccb8:	00000506 	br	820ccd0 <__multiply+0x1d4>
 820ccbc:	50c00017 	ldw	r3,0(r10)
 820ccc0:	1800031e 	bne	r3,zero,820ccd0 <__multiply+0x1d4>
 820ccc4:	843fffc4 	addi	r16,r16,-1
 820ccc8:	52bfff04 	addi	r10,r10,-4
 820cccc:	803ffb1e 	bne	r16,zero,820ccbc <__multiply+0x1c0>
 820ccd0:	14000415 	stw	r16,16(r2)
 820ccd4:	dfc00517 	ldw	ra,20(sp)
 820ccd8:	dd000417 	ldw	r20,16(sp)
 820ccdc:	dcc00317 	ldw	r19,12(sp)
 820cce0:	dc800217 	ldw	r18,8(sp)
 820cce4:	dc400117 	ldw	r17,4(sp)
 820cce8:	dc000017 	ldw	r16,0(sp)
 820ccec:	dec00604 	addi	sp,sp,24
 820ccf0:	f800283a 	ret

0820ccf4 <__pow5mult>:
 820ccf4:	defffa04 	addi	sp,sp,-24
 820ccf8:	dcc00315 	stw	r19,12(sp)
 820ccfc:	dc000015 	stw	r16,0(sp)
 820cd00:	dfc00515 	stw	ra,20(sp)
 820cd04:	dd000415 	stw	r20,16(sp)
 820cd08:	dc800215 	stw	r18,8(sp)
 820cd0c:	dc400115 	stw	r17,4(sp)
 820cd10:	308000cc 	andi	r2,r6,3
 820cd14:	3021883a 	mov	r16,r6
 820cd18:	2027883a 	mov	r19,r4
 820cd1c:	10002f1e 	bne	r2,zero,820cddc <__pow5mult+0xe8>
 820cd20:	2825883a 	mov	r18,r5
 820cd24:	8021d0ba 	srai	r16,r16,2
 820cd28:	80001a26 	beq	r16,zero,820cd94 <__pow5mult+0xa0>
 820cd2c:	9c401217 	ldw	r17,72(r19)
 820cd30:	8800061e 	bne	r17,zero,820cd4c <__pow5mult+0x58>
 820cd34:	00003406 	br	820ce08 <__pow5mult+0x114>
 820cd38:	8021d07a 	srai	r16,r16,1
 820cd3c:	80001526 	beq	r16,zero,820cd94 <__pow5mult+0xa0>
 820cd40:	88800017 	ldw	r2,0(r17)
 820cd44:	10001c26 	beq	r2,zero,820cdb8 <__pow5mult+0xc4>
 820cd48:	1023883a 	mov	r17,r2
 820cd4c:	8080004c 	andi	r2,r16,1
 820cd50:	103ff926 	beq	r2,zero,820cd38 <__pow5mult+0x44>
 820cd54:	880d883a 	mov	r6,r17
 820cd58:	900b883a 	mov	r5,r18
 820cd5c:	9809883a 	mov	r4,r19
 820cd60:	820cafc0 	call	820cafc <__multiply>
 820cd64:	90001b26 	beq	r18,zero,820cdd4 <__pow5mult+0xe0>
 820cd68:	91000117 	ldw	r4,4(r18)
 820cd6c:	98c01317 	ldw	r3,76(r19)
 820cd70:	8021d07a 	srai	r16,r16,1
 820cd74:	2109883a 	add	r4,r4,r4
 820cd78:	2109883a 	add	r4,r4,r4
 820cd7c:	1907883a 	add	r3,r3,r4
 820cd80:	19000017 	ldw	r4,0(r3)
 820cd84:	91000015 	stw	r4,0(r18)
 820cd88:	1c800015 	stw	r18,0(r3)
 820cd8c:	1025883a 	mov	r18,r2
 820cd90:	803feb1e 	bne	r16,zero,820cd40 <__pow5mult+0x4c>
 820cd94:	9005883a 	mov	r2,r18
 820cd98:	dfc00517 	ldw	ra,20(sp)
 820cd9c:	dd000417 	ldw	r20,16(sp)
 820cda0:	dcc00317 	ldw	r19,12(sp)
 820cda4:	dc800217 	ldw	r18,8(sp)
 820cda8:	dc400117 	ldw	r17,4(sp)
 820cdac:	dc000017 	ldw	r16,0(sp)
 820cdb0:	dec00604 	addi	sp,sp,24
 820cdb4:	f800283a 	ret
 820cdb8:	880d883a 	mov	r6,r17
 820cdbc:	880b883a 	mov	r5,r17
 820cdc0:	9809883a 	mov	r4,r19
 820cdc4:	820cafc0 	call	820cafc <__multiply>
 820cdc8:	88800015 	stw	r2,0(r17)
 820cdcc:	10000015 	stw	zero,0(r2)
 820cdd0:	003fdd06 	br	820cd48 <__pow5mult+0x54>
 820cdd4:	1025883a 	mov	r18,r2
 820cdd8:	003fd706 	br	820cd38 <__pow5mult+0x44>
 820cddc:	10bfffc4 	addi	r2,r2,-1
 820cde0:	1085883a 	add	r2,r2,r2
 820cde4:	00c20974 	movhi	r3,2085
 820cde8:	18f70404 	addi	r3,r3,-9200
 820cdec:	1085883a 	add	r2,r2,r2
 820cdf0:	1885883a 	add	r2,r3,r2
 820cdf4:	11800017 	ldw	r6,0(r2)
 820cdf8:	000f883a 	mov	r7,zero
 820cdfc:	820c7840 	call	820c784 <__multadd>
 820ce00:	1025883a 	mov	r18,r2
 820ce04:	003fc706 	br	820cd24 <__pow5mult+0x30>
 820ce08:	05000044 	movi	r20,1
 820ce0c:	a00b883a 	mov	r5,r20
 820ce10:	9809883a 	mov	r4,r19
 820ce14:	820c6b40 	call	820c6b4 <_Balloc>
 820ce18:	1023883a 	mov	r17,r2
 820ce1c:	00809c44 	movi	r2,625
 820ce20:	88800515 	stw	r2,20(r17)
 820ce24:	8d000415 	stw	r20,16(r17)
 820ce28:	9c401215 	stw	r17,72(r19)
 820ce2c:	88000015 	stw	zero,0(r17)
 820ce30:	003fc606 	br	820cd4c <__pow5mult+0x58>

0820ce34 <__lshift>:
 820ce34:	defff904 	addi	sp,sp,-28
 820ce38:	dd400515 	stw	r21,20(sp)
 820ce3c:	dcc00315 	stw	r19,12(sp)
 820ce40:	302bd17a 	srai	r21,r6,5
 820ce44:	2cc00417 	ldw	r19,16(r5)
 820ce48:	28800217 	ldw	r2,8(r5)
 820ce4c:	dd000415 	stw	r20,16(sp)
 820ce50:	ace7883a 	add	r19,r21,r19
 820ce54:	dc800215 	stw	r18,8(sp)
 820ce58:	dc400115 	stw	r17,4(sp)
 820ce5c:	dc000015 	stw	r16,0(sp)
 820ce60:	dfc00615 	stw	ra,24(sp)
 820ce64:	9c000044 	addi	r16,r19,1
 820ce68:	2823883a 	mov	r17,r5
 820ce6c:	3029883a 	mov	r20,r6
 820ce70:	2025883a 	mov	r18,r4
 820ce74:	29400117 	ldw	r5,4(r5)
 820ce78:	1400030e 	bge	r2,r16,820ce88 <__lshift+0x54>
 820ce7c:	1085883a 	add	r2,r2,r2
 820ce80:	29400044 	addi	r5,r5,1
 820ce84:	143ffd16 	blt	r2,r16,820ce7c <__lshift+0x48>
 820ce88:	9009883a 	mov	r4,r18
 820ce8c:	820c6b40 	call	820c6b4 <_Balloc>
 820ce90:	10c00504 	addi	r3,r2,20
 820ce94:	0540070e 	bge	zero,r21,820ceb4 <__lshift+0x80>
 820ce98:	ad6b883a 	add	r21,r21,r21
 820ce9c:	ad6b883a 	add	r21,r21,r21
 820cea0:	1809883a 	mov	r4,r3
 820cea4:	1d47883a 	add	r3,r3,r21
 820cea8:	20000015 	stw	zero,0(r4)
 820ceac:	21000104 	addi	r4,r4,4
 820ceb0:	193ffd1e 	bne	r3,r4,820cea8 <__lshift+0x74>
 820ceb4:	8a000417 	ldw	r8,16(r17)
 820ceb8:	89000504 	addi	r4,r17,20
 820cebc:	a18007cc 	andi	r6,r20,31
 820cec0:	4211883a 	add	r8,r8,r8
 820cec4:	4211883a 	add	r8,r8,r8
 820cec8:	2211883a 	add	r8,r4,r8
 820cecc:	30002326 	beq	r6,zero,820cf5c <__lshift+0x128>
 820ced0:	02400804 	movi	r9,32
 820ced4:	4993c83a 	sub	r9,r9,r6
 820ced8:	000b883a 	mov	r5,zero
 820cedc:	21c00017 	ldw	r7,0(r4)
 820cee0:	1815883a 	mov	r10,r3
 820cee4:	18c00104 	addi	r3,r3,4
 820cee8:	398e983a 	sll	r7,r7,r6
 820ceec:	21000104 	addi	r4,r4,4
 820cef0:	394ab03a 	or	r5,r7,r5
 820cef4:	197fff15 	stw	r5,-4(r3)
 820cef8:	217fff17 	ldw	r5,-4(r4)
 820cefc:	2a4ad83a 	srl	r5,r5,r9
 820cf00:	223ff636 	bltu	r4,r8,820cedc <__lshift+0xa8>
 820cf04:	51400115 	stw	r5,4(r10)
 820cf08:	28001a1e 	bne	r5,zero,820cf74 <__lshift+0x140>
 820cf0c:	843fffc4 	addi	r16,r16,-1
 820cf10:	14000415 	stw	r16,16(r2)
 820cf14:	88000826 	beq	r17,zero,820cf38 <__lshift+0x104>
 820cf18:	89000117 	ldw	r4,4(r17)
 820cf1c:	90c01317 	ldw	r3,76(r18)
 820cf20:	2109883a 	add	r4,r4,r4
 820cf24:	2109883a 	add	r4,r4,r4
 820cf28:	1907883a 	add	r3,r3,r4
 820cf2c:	19000017 	ldw	r4,0(r3)
 820cf30:	89000015 	stw	r4,0(r17)
 820cf34:	1c400015 	stw	r17,0(r3)
 820cf38:	dfc00617 	ldw	ra,24(sp)
 820cf3c:	dd400517 	ldw	r21,20(sp)
 820cf40:	dd000417 	ldw	r20,16(sp)
 820cf44:	dcc00317 	ldw	r19,12(sp)
 820cf48:	dc800217 	ldw	r18,8(sp)
 820cf4c:	dc400117 	ldw	r17,4(sp)
 820cf50:	dc000017 	ldw	r16,0(sp)
 820cf54:	dec00704 	addi	sp,sp,28
 820cf58:	f800283a 	ret
 820cf5c:	21400017 	ldw	r5,0(r4)
 820cf60:	18c00104 	addi	r3,r3,4
 820cf64:	21000104 	addi	r4,r4,4
 820cf68:	197fff15 	stw	r5,-4(r3)
 820cf6c:	223ffb36 	bltu	r4,r8,820cf5c <__lshift+0x128>
 820cf70:	003fe606 	br	820cf0c <__lshift+0xd8>
 820cf74:	9c000084 	addi	r16,r19,2
 820cf78:	003fe406 	br	820cf0c <__lshift+0xd8>

0820cf7c <__mcmp>:
 820cf7c:	20800417 	ldw	r2,16(r4)
 820cf80:	28c00417 	ldw	r3,16(r5)
 820cf84:	10c5c83a 	sub	r2,r2,r3
 820cf88:	1000111e 	bne	r2,zero,820cfd0 <__mcmp+0x54>
 820cf8c:	18c7883a 	add	r3,r3,r3
 820cf90:	18c7883a 	add	r3,r3,r3
 820cf94:	21000504 	addi	r4,r4,20
 820cf98:	29400504 	addi	r5,r5,20
 820cf9c:	20c5883a 	add	r2,r4,r3
 820cfa0:	28cb883a 	add	r5,r5,r3
 820cfa4:	00000106 	br	820cfac <__mcmp+0x30>
 820cfa8:	20800a2e 	bgeu	r4,r2,820cfd4 <__mcmp+0x58>
 820cfac:	10bfff04 	addi	r2,r2,-4
 820cfb0:	297fff04 	addi	r5,r5,-4
 820cfb4:	11800017 	ldw	r6,0(r2)
 820cfb8:	28c00017 	ldw	r3,0(r5)
 820cfbc:	30fffa26 	beq	r6,r3,820cfa8 <__mcmp+0x2c>
 820cfc0:	30c00236 	bltu	r6,r3,820cfcc <__mcmp+0x50>
 820cfc4:	00800044 	movi	r2,1
 820cfc8:	f800283a 	ret
 820cfcc:	00bfffc4 	movi	r2,-1
 820cfd0:	f800283a 	ret
 820cfd4:	0005883a 	mov	r2,zero
 820cfd8:	f800283a 	ret

0820cfdc <__mdiff>:
 820cfdc:	28c00417 	ldw	r3,16(r5)
 820cfe0:	30800417 	ldw	r2,16(r6)
 820cfe4:	defffa04 	addi	sp,sp,-24
 820cfe8:	dcc00315 	stw	r19,12(sp)
 820cfec:	dc800215 	stw	r18,8(sp)
 820cff0:	dfc00515 	stw	ra,20(sp)
 820cff4:	dd000415 	stw	r20,16(sp)
 820cff8:	dc400115 	stw	r17,4(sp)
 820cffc:	dc000015 	stw	r16,0(sp)
 820d000:	1887c83a 	sub	r3,r3,r2
 820d004:	2825883a 	mov	r18,r5
 820d008:	3027883a 	mov	r19,r6
 820d00c:	1800141e 	bne	r3,zero,820d060 <__mdiff+0x84>
 820d010:	1085883a 	add	r2,r2,r2
 820d014:	1085883a 	add	r2,r2,r2
 820d018:	2a000504 	addi	r8,r5,20
 820d01c:	34000504 	addi	r16,r6,20
 820d020:	4087883a 	add	r3,r8,r2
 820d024:	8085883a 	add	r2,r16,r2
 820d028:	00000106 	br	820d030 <__mdiff+0x54>
 820d02c:	40c0592e 	bgeu	r8,r3,820d194 <__mdiff+0x1b8>
 820d030:	18ffff04 	addi	r3,r3,-4
 820d034:	10bfff04 	addi	r2,r2,-4
 820d038:	19c00017 	ldw	r7,0(r3)
 820d03c:	11400017 	ldw	r5,0(r2)
 820d040:	397ffa26 	beq	r7,r5,820d02c <__mdiff+0x50>
 820d044:	3940592e 	bgeu	r7,r5,820d1ac <__mdiff+0x1d0>
 820d048:	9005883a 	mov	r2,r18
 820d04c:	4023883a 	mov	r17,r8
 820d050:	9825883a 	mov	r18,r19
 820d054:	05000044 	movi	r20,1
 820d058:	1027883a 	mov	r19,r2
 820d05c:	00000406 	br	820d070 <__mdiff+0x94>
 820d060:	18005616 	blt	r3,zero,820d1bc <__mdiff+0x1e0>
 820d064:	34400504 	addi	r17,r6,20
 820d068:	2c000504 	addi	r16,r5,20
 820d06c:	0029883a 	mov	r20,zero
 820d070:	91400117 	ldw	r5,4(r18)
 820d074:	820c6b40 	call	820c6b4 <_Balloc>
 820d078:	92400417 	ldw	r9,16(r18)
 820d07c:	9b000417 	ldw	r12,16(r19)
 820d080:	12c00504 	addi	r11,r2,20
 820d084:	4a51883a 	add	r8,r9,r9
 820d088:	6319883a 	add	r12,r12,r12
 820d08c:	4211883a 	add	r8,r8,r8
 820d090:	6319883a 	add	r12,r12,r12
 820d094:	15000315 	stw	r20,12(r2)
 820d098:	8211883a 	add	r8,r16,r8
 820d09c:	8b19883a 	add	r12,r17,r12
 820d0a0:	0007883a 	mov	r3,zero
 820d0a4:	81400017 	ldw	r5,0(r16)
 820d0a8:	89c00017 	ldw	r7,0(r17)
 820d0ac:	59800104 	addi	r6,r11,4
 820d0b0:	293fffcc 	andi	r4,r5,65535
 820d0b4:	20c7883a 	add	r3,r4,r3
 820d0b8:	393fffcc 	andi	r4,r7,65535
 820d0bc:	1909c83a 	sub	r4,r3,r4
 820d0c0:	280ad43a 	srli	r5,r5,16
 820d0c4:	380ed43a 	srli	r7,r7,16
 820d0c8:	2007d43a 	srai	r3,r4,16
 820d0cc:	213fffcc 	andi	r4,r4,65535
 820d0d0:	29cbc83a 	sub	r5,r5,r7
 820d0d4:	28c7883a 	add	r3,r5,r3
 820d0d8:	180a943a 	slli	r5,r3,16
 820d0dc:	8c400104 	addi	r17,r17,4
 820d0e0:	84000104 	addi	r16,r16,4
 820d0e4:	2908b03a 	or	r4,r5,r4
 820d0e8:	59000015 	stw	r4,0(r11)
 820d0ec:	1807d43a 	srai	r3,r3,16
 820d0f0:	3015883a 	mov	r10,r6
 820d0f4:	3017883a 	mov	r11,r6
 820d0f8:	8b3fea36 	bltu	r17,r12,820d0a4 <__mdiff+0xc8>
 820d0fc:	8200162e 	bgeu	r16,r8,820d158 <__mdiff+0x17c>
 820d100:	8017883a 	mov	r11,r16
 820d104:	59400017 	ldw	r5,0(r11)
 820d108:	31800104 	addi	r6,r6,4
 820d10c:	5ac00104 	addi	r11,r11,4
 820d110:	293fffcc 	andi	r4,r5,65535
 820d114:	20c7883a 	add	r3,r4,r3
 820d118:	280ed43a 	srli	r7,r5,16
 820d11c:	180bd43a 	srai	r5,r3,16
 820d120:	193fffcc 	andi	r4,r3,65535
 820d124:	3947883a 	add	r3,r7,r5
 820d128:	180a943a 	slli	r5,r3,16
 820d12c:	1807d43a 	srai	r3,r3,16
 820d130:	2908b03a 	or	r4,r5,r4
 820d134:	313fff15 	stw	r4,-4(r6)
 820d138:	5a3ff236 	bltu	r11,r8,820d104 <__mdiff+0x128>
 820d13c:	0406303a 	nor	r3,zero,r16
 820d140:	1a07883a 	add	r3,r3,r8
 820d144:	1806d0ba 	srli	r3,r3,2
 820d148:	18c00044 	addi	r3,r3,1
 820d14c:	18c7883a 	add	r3,r3,r3
 820d150:	18c7883a 	add	r3,r3,r3
 820d154:	50d5883a 	add	r10,r10,r3
 820d158:	50ffff04 	addi	r3,r10,-4
 820d15c:	2000041e 	bne	r4,zero,820d170 <__mdiff+0x194>
 820d160:	18ffff04 	addi	r3,r3,-4
 820d164:	19000017 	ldw	r4,0(r3)
 820d168:	4a7fffc4 	addi	r9,r9,-1
 820d16c:	203ffc26 	beq	r4,zero,820d160 <__mdiff+0x184>
 820d170:	12400415 	stw	r9,16(r2)
 820d174:	dfc00517 	ldw	ra,20(sp)
 820d178:	dd000417 	ldw	r20,16(sp)
 820d17c:	dcc00317 	ldw	r19,12(sp)
 820d180:	dc800217 	ldw	r18,8(sp)
 820d184:	dc400117 	ldw	r17,4(sp)
 820d188:	dc000017 	ldw	r16,0(sp)
 820d18c:	dec00604 	addi	sp,sp,24
 820d190:	f800283a 	ret
 820d194:	000b883a 	mov	r5,zero
 820d198:	820c6b40 	call	820c6b4 <_Balloc>
 820d19c:	00c00044 	movi	r3,1
 820d1a0:	10c00415 	stw	r3,16(r2)
 820d1a4:	10000515 	stw	zero,20(r2)
 820d1a8:	003ff206 	br	820d174 <__mdiff+0x198>
 820d1ac:	8023883a 	mov	r17,r16
 820d1b0:	0029883a 	mov	r20,zero
 820d1b4:	4021883a 	mov	r16,r8
 820d1b8:	003fad06 	br	820d070 <__mdiff+0x94>
 820d1bc:	9005883a 	mov	r2,r18
 820d1c0:	94400504 	addi	r17,r18,20
 820d1c4:	9c000504 	addi	r16,r19,20
 820d1c8:	9825883a 	mov	r18,r19
 820d1cc:	05000044 	movi	r20,1
 820d1d0:	1027883a 	mov	r19,r2
 820d1d4:	003fa606 	br	820d070 <__mdiff+0x94>

0820d1d8 <__ulp>:
 820d1d8:	295ffc2c 	andhi	r5,r5,32752
 820d1dc:	00bf3034 	movhi	r2,64704
 820d1e0:	2887883a 	add	r3,r5,r2
 820d1e4:	00c0020e 	bge	zero,r3,820d1f0 <__ulp+0x18>
 820d1e8:	0005883a 	mov	r2,zero
 820d1ec:	f800283a 	ret
 820d1f0:	00c7c83a 	sub	r3,zero,r3
 820d1f4:	1807d53a 	srai	r3,r3,20
 820d1f8:	008004c4 	movi	r2,19
 820d1fc:	10c00b0e 	bge	r2,r3,820d22c <__ulp+0x54>
 820d200:	18bffb04 	addi	r2,r3,-20
 820d204:	01000784 	movi	r4,30
 820d208:	0007883a 	mov	r3,zero
 820d20c:	20800516 	blt	r4,r2,820d224 <__ulp+0x4c>
 820d210:	010007c4 	movi	r4,31
 820d214:	2089c83a 	sub	r4,r4,r2
 820d218:	00800044 	movi	r2,1
 820d21c:	1104983a 	sll	r2,r2,r4
 820d220:	f800283a 	ret
 820d224:	00800044 	movi	r2,1
 820d228:	f800283a 	ret
 820d22c:	01400234 	movhi	r5,8
 820d230:	28c7d83a 	sra	r3,r5,r3
 820d234:	0005883a 	mov	r2,zero
 820d238:	f800283a 	ret

0820d23c <__b2d>:
 820d23c:	defffa04 	addi	sp,sp,-24
 820d240:	dc000015 	stw	r16,0(sp)
 820d244:	24000417 	ldw	r16,16(r4)
 820d248:	dc400115 	stw	r17,4(sp)
 820d24c:	24400504 	addi	r17,r4,20
 820d250:	8421883a 	add	r16,r16,r16
 820d254:	8421883a 	add	r16,r16,r16
 820d258:	8c21883a 	add	r16,r17,r16
 820d25c:	dc800215 	stw	r18,8(sp)
 820d260:	84bfff17 	ldw	r18,-4(r16)
 820d264:	dd000415 	stw	r20,16(sp)
 820d268:	dcc00315 	stw	r19,12(sp)
 820d26c:	9009883a 	mov	r4,r18
 820d270:	2829883a 	mov	r20,r5
 820d274:	dfc00515 	stw	ra,20(sp)
 820d278:	820c9a80 	call	820c9a8 <__hi0bits>
 820d27c:	00c00804 	movi	r3,32
 820d280:	1889c83a 	sub	r4,r3,r2
 820d284:	a1000015 	stw	r4,0(r20)
 820d288:	01000284 	movi	r4,10
 820d28c:	84ffff04 	addi	r19,r16,-4
 820d290:	20801216 	blt	r4,r2,820d2dc <__b2d+0xa0>
 820d294:	018002c4 	movi	r6,11
 820d298:	308dc83a 	sub	r6,r6,r2
 820d29c:	9186d83a 	srl	r3,r18,r6
 820d2a0:	18cffc34 	orhi	r3,r3,16368
 820d2a4:	8cc0212e 	bgeu	r17,r19,820d32c <__b2d+0xf0>
 820d2a8:	813ffe17 	ldw	r4,-8(r16)
 820d2ac:	218cd83a 	srl	r6,r4,r6
 820d2b0:	10800544 	addi	r2,r2,21
 820d2b4:	9084983a 	sll	r2,r18,r2
 820d2b8:	1184b03a 	or	r2,r2,r6
 820d2bc:	dfc00517 	ldw	ra,20(sp)
 820d2c0:	dd000417 	ldw	r20,16(sp)
 820d2c4:	dcc00317 	ldw	r19,12(sp)
 820d2c8:	dc800217 	ldw	r18,8(sp)
 820d2cc:	dc400117 	ldw	r17,4(sp)
 820d2d0:	dc000017 	ldw	r16,0(sp)
 820d2d4:	dec00604 	addi	sp,sp,24
 820d2d8:	f800283a 	ret
 820d2dc:	8cc00f2e 	bgeu	r17,r19,820d31c <__b2d+0xe0>
 820d2e0:	117ffd44 	addi	r5,r2,-11
 820d2e4:	80bffe17 	ldw	r2,-8(r16)
 820d2e8:	28000e26 	beq	r5,zero,820d324 <__b2d+0xe8>
 820d2ec:	1949c83a 	sub	r4,r3,r5
 820d2f0:	9164983a 	sll	r18,r18,r5
 820d2f4:	1106d83a 	srl	r3,r2,r4
 820d2f8:	81bffe04 	addi	r6,r16,-8
 820d2fc:	948ffc34 	orhi	r18,r18,16368
 820d300:	90c6b03a 	or	r3,r18,r3
 820d304:	89800e2e 	bgeu	r17,r6,820d340 <__b2d+0x104>
 820d308:	81bffd17 	ldw	r6,-12(r16)
 820d30c:	1144983a 	sll	r2,r2,r5
 820d310:	310ad83a 	srl	r5,r6,r4
 820d314:	2884b03a 	or	r2,r5,r2
 820d318:	003fe806 	br	820d2bc <__b2d+0x80>
 820d31c:	10bffd44 	addi	r2,r2,-11
 820d320:	1000041e 	bne	r2,zero,820d334 <__b2d+0xf8>
 820d324:	90cffc34 	orhi	r3,r18,16368
 820d328:	003fe406 	br	820d2bc <__b2d+0x80>
 820d32c:	000d883a 	mov	r6,zero
 820d330:	003fdf06 	br	820d2b0 <__b2d+0x74>
 820d334:	90a4983a 	sll	r18,r18,r2
 820d338:	0005883a 	mov	r2,zero
 820d33c:	003ff906 	br	820d324 <__b2d+0xe8>
 820d340:	1144983a 	sll	r2,r2,r5
 820d344:	003fdd06 	br	820d2bc <__b2d+0x80>

0820d348 <__d2b>:
 820d348:	defff804 	addi	sp,sp,-32
 820d34c:	dc000215 	stw	r16,8(sp)
 820d350:	3021883a 	mov	r16,r6
 820d354:	dc400315 	stw	r17,12(sp)
 820d358:	8022907a 	slli	r17,r16,1
 820d35c:	dd000615 	stw	r20,24(sp)
 820d360:	2829883a 	mov	r20,r5
 820d364:	01400044 	movi	r5,1
 820d368:	dcc00515 	stw	r19,20(sp)
 820d36c:	dc800415 	stw	r18,16(sp)
 820d370:	dfc00715 	stw	ra,28(sp)
 820d374:	3825883a 	mov	r18,r7
 820d378:	8822d57a 	srli	r17,r17,21
 820d37c:	820c6b40 	call	820c6b4 <_Balloc>
 820d380:	1027883a 	mov	r19,r2
 820d384:	00800434 	movhi	r2,16
 820d388:	10bfffc4 	addi	r2,r2,-1
 820d38c:	808c703a 	and	r6,r16,r2
 820d390:	88000126 	beq	r17,zero,820d398 <__d2b+0x50>
 820d394:	31800434 	orhi	r6,r6,16
 820d398:	d9800015 	stw	r6,0(sp)
 820d39c:	a0002426 	beq	r20,zero,820d430 <__d2b+0xe8>
 820d3a0:	d9000104 	addi	r4,sp,4
 820d3a4:	dd000115 	stw	r20,4(sp)
 820d3a8:	820ca100 	call	820ca10 <__lo0bits>
 820d3ac:	d8c00017 	ldw	r3,0(sp)
 820d3b0:	10002f1e 	bne	r2,zero,820d470 <__d2b+0x128>
 820d3b4:	d9000117 	ldw	r4,4(sp)
 820d3b8:	99000515 	stw	r4,20(r19)
 820d3bc:	1821003a 	cmpeq	r16,r3,zero
 820d3c0:	01000084 	movi	r4,2
 820d3c4:	2421c83a 	sub	r16,r4,r16
 820d3c8:	98c00615 	stw	r3,24(r19)
 820d3cc:	9c000415 	stw	r16,16(r19)
 820d3d0:	88001f1e 	bne	r17,zero,820d450 <__d2b+0x108>
 820d3d4:	10bef384 	addi	r2,r2,-1074
 820d3d8:	90800015 	stw	r2,0(r18)
 820d3dc:	00900034 	movhi	r2,16384
 820d3e0:	10bfffc4 	addi	r2,r2,-1
 820d3e4:	8085883a 	add	r2,r16,r2
 820d3e8:	1085883a 	add	r2,r2,r2
 820d3ec:	1085883a 	add	r2,r2,r2
 820d3f0:	9885883a 	add	r2,r19,r2
 820d3f4:	11000517 	ldw	r4,20(r2)
 820d3f8:	8020917a 	slli	r16,r16,5
 820d3fc:	820c9a80 	call	820c9a8 <__hi0bits>
 820d400:	d8c00817 	ldw	r3,32(sp)
 820d404:	8085c83a 	sub	r2,r16,r2
 820d408:	18800015 	stw	r2,0(r3)
 820d40c:	9805883a 	mov	r2,r19
 820d410:	dfc00717 	ldw	ra,28(sp)
 820d414:	dd000617 	ldw	r20,24(sp)
 820d418:	dcc00517 	ldw	r19,20(sp)
 820d41c:	dc800417 	ldw	r18,16(sp)
 820d420:	dc400317 	ldw	r17,12(sp)
 820d424:	dc000217 	ldw	r16,8(sp)
 820d428:	dec00804 	addi	sp,sp,32
 820d42c:	f800283a 	ret
 820d430:	d809883a 	mov	r4,sp
 820d434:	820ca100 	call	820ca10 <__lo0bits>
 820d438:	d8c00017 	ldw	r3,0(sp)
 820d43c:	04000044 	movi	r16,1
 820d440:	9c000415 	stw	r16,16(r19)
 820d444:	98c00515 	stw	r3,20(r19)
 820d448:	10800804 	addi	r2,r2,32
 820d44c:	883fe126 	beq	r17,zero,820d3d4 <__d2b+0x8c>
 820d450:	00c00d44 	movi	r3,53
 820d454:	8c7ef344 	addi	r17,r17,-1075
 820d458:	88a3883a 	add	r17,r17,r2
 820d45c:	1885c83a 	sub	r2,r3,r2
 820d460:	d8c00817 	ldw	r3,32(sp)
 820d464:	94400015 	stw	r17,0(r18)
 820d468:	18800015 	stw	r2,0(r3)
 820d46c:	003fe706 	br	820d40c <__d2b+0xc4>
 820d470:	01000804 	movi	r4,32
 820d474:	2089c83a 	sub	r4,r4,r2
 820d478:	1908983a 	sll	r4,r3,r4
 820d47c:	d9400117 	ldw	r5,4(sp)
 820d480:	1886d83a 	srl	r3,r3,r2
 820d484:	2148b03a 	or	r4,r4,r5
 820d488:	99000515 	stw	r4,20(r19)
 820d48c:	d8c00015 	stw	r3,0(sp)
 820d490:	003fca06 	br	820d3bc <__d2b+0x74>

0820d494 <__ratio>:
 820d494:	defff904 	addi	sp,sp,-28
 820d498:	dc400315 	stw	r17,12(sp)
 820d49c:	2823883a 	mov	r17,r5
 820d4a0:	d9400104 	addi	r5,sp,4
 820d4a4:	dfc00615 	stw	ra,24(sp)
 820d4a8:	dcc00515 	stw	r19,20(sp)
 820d4ac:	dc800415 	stw	r18,16(sp)
 820d4b0:	2027883a 	mov	r19,r4
 820d4b4:	dc000215 	stw	r16,8(sp)
 820d4b8:	820d23c0 	call	820d23c <__b2d>
 820d4bc:	d80b883a 	mov	r5,sp
 820d4c0:	8809883a 	mov	r4,r17
 820d4c4:	1025883a 	mov	r18,r2
 820d4c8:	1821883a 	mov	r16,r3
 820d4cc:	820d23c0 	call	820d23c <__b2d>
 820d4d0:	8a000417 	ldw	r8,16(r17)
 820d4d4:	99000417 	ldw	r4,16(r19)
 820d4d8:	d9400117 	ldw	r5,4(sp)
 820d4dc:	2209c83a 	sub	r4,r4,r8
 820d4e0:	2010917a 	slli	r8,r4,5
 820d4e4:	d9000017 	ldw	r4,0(sp)
 820d4e8:	2909c83a 	sub	r4,r5,r4
 820d4ec:	4109883a 	add	r4,r8,r4
 820d4f0:	01000e0e 	bge	zero,r4,820d52c <__ratio+0x98>
 820d4f4:	2008953a 	slli	r4,r4,20
 820d4f8:	2421883a 	add	r16,r4,r16
 820d4fc:	100d883a 	mov	r6,r2
 820d500:	180f883a 	mov	r7,r3
 820d504:	9009883a 	mov	r4,r18
 820d508:	800b883a 	mov	r5,r16
 820d50c:	82126700 	call	8212670 <__divdf3>
 820d510:	dfc00617 	ldw	ra,24(sp)
 820d514:	dcc00517 	ldw	r19,20(sp)
 820d518:	dc800417 	ldw	r18,16(sp)
 820d51c:	dc400317 	ldw	r17,12(sp)
 820d520:	dc000217 	ldw	r16,8(sp)
 820d524:	dec00704 	addi	sp,sp,28
 820d528:	f800283a 	ret
 820d52c:	2008953a 	slli	r4,r4,20
 820d530:	1907c83a 	sub	r3,r3,r4
 820d534:	003ff106 	br	820d4fc <__ratio+0x68>

0820d538 <_mprec_log10>:
 820d538:	defffe04 	addi	sp,sp,-8
 820d53c:	dc000015 	stw	r16,0(sp)
 820d540:	dfc00115 	stw	ra,4(sp)
 820d544:	008005c4 	movi	r2,23
 820d548:	2021883a 	mov	r16,r4
 820d54c:	11000d0e 	bge	r2,r4,820d584 <_mprec_log10+0x4c>
 820d550:	0005883a 	mov	r2,zero
 820d554:	00cffc34 	movhi	r3,16368
 820d558:	843fffc4 	addi	r16,r16,-1
 820d55c:	000d883a 	mov	r6,zero
 820d560:	01d00934 	movhi	r7,16420
 820d564:	1009883a 	mov	r4,r2
 820d568:	180b883a 	mov	r5,r3
 820d56c:	82131b00 	call	82131b0 <__muldf3>
 820d570:	803ff91e 	bne	r16,zero,820d558 <_mprec_log10+0x20>
 820d574:	dfc00117 	ldw	ra,4(sp)
 820d578:	dc000017 	ldw	r16,0(sp)
 820d57c:	dec00204 	addi	sp,sp,8
 820d580:	f800283a 	ret
 820d584:	202090fa 	slli	r16,r4,3
 820d588:	00820974 	movhi	r2,2085
 820d58c:	10b71b04 	addi	r2,r2,-9108
 820d590:	1421883a 	add	r16,r2,r16
 820d594:	80800017 	ldw	r2,0(r16)
 820d598:	80c00117 	ldw	r3,4(r16)
 820d59c:	dfc00117 	ldw	ra,4(sp)
 820d5a0:	dc000017 	ldw	r16,0(sp)
 820d5a4:	dec00204 	addi	sp,sp,8
 820d5a8:	f800283a 	ret

0820d5ac <__copybits>:
 820d5ac:	297fffc4 	addi	r5,r5,-1
 820d5b0:	280fd17a 	srai	r7,r5,5
 820d5b4:	30c00417 	ldw	r3,16(r6)
 820d5b8:	30800504 	addi	r2,r6,20
 820d5bc:	39c00044 	addi	r7,r7,1
 820d5c0:	18c7883a 	add	r3,r3,r3
 820d5c4:	39cf883a 	add	r7,r7,r7
 820d5c8:	18c7883a 	add	r3,r3,r3
 820d5cc:	39cf883a 	add	r7,r7,r7
 820d5d0:	10c7883a 	add	r3,r2,r3
 820d5d4:	21cf883a 	add	r7,r4,r7
 820d5d8:	10c00d2e 	bgeu	r2,r3,820d610 <__copybits+0x64>
 820d5dc:	200b883a 	mov	r5,r4
 820d5e0:	12000017 	ldw	r8,0(r2)
 820d5e4:	29400104 	addi	r5,r5,4
 820d5e8:	10800104 	addi	r2,r2,4
 820d5ec:	2a3fff15 	stw	r8,-4(r5)
 820d5f0:	10fffb36 	bltu	r2,r3,820d5e0 <__copybits+0x34>
 820d5f4:	1985c83a 	sub	r2,r3,r6
 820d5f8:	10bffac4 	addi	r2,r2,-21
 820d5fc:	1004d0ba 	srli	r2,r2,2
 820d600:	10800044 	addi	r2,r2,1
 820d604:	1085883a 	add	r2,r2,r2
 820d608:	1085883a 	add	r2,r2,r2
 820d60c:	2089883a 	add	r4,r4,r2
 820d610:	21c0032e 	bgeu	r4,r7,820d620 <__copybits+0x74>
 820d614:	20000015 	stw	zero,0(r4)
 820d618:	21000104 	addi	r4,r4,4
 820d61c:	21fffd36 	bltu	r4,r7,820d614 <__copybits+0x68>
 820d620:	f800283a 	ret

0820d624 <__any_on>:
 820d624:	20c00417 	ldw	r3,16(r4)
 820d628:	2805d17a 	srai	r2,r5,5
 820d62c:	21000504 	addi	r4,r4,20
 820d630:	18800d0e 	bge	r3,r2,820d668 <__any_on+0x44>
 820d634:	18c7883a 	add	r3,r3,r3
 820d638:	18c7883a 	add	r3,r3,r3
 820d63c:	20c7883a 	add	r3,r4,r3
 820d640:	20c0192e 	bgeu	r4,r3,820d6a8 <__any_on+0x84>
 820d644:	18bfff17 	ldw	r2,-4(r3)
 820d648:	18ffff04 	addi	r3,r3,-4
 820d64c:	1000041e 	bne	r2,zero,820d660 <__any_on+0x3c>
 820d650:	20c0142e 	bgeu	r4,r3,820d6a4 <__any_on+0x80>
 820d654:	18ffff04 	addi	r3,r3,-4
 820d658:	19400017 	ldw	r5,0(r3)
 820d65c:	283ffc26 	beq	r5,zero,820d650 <__any_on+0x2c>
 820d660:	00800044 	movi	r2,1
 820d664:	f800283a 	ret
 820d668:	10c00a0e 	bge	r2,r3,820d694 <__any_on+0x70>
 820d66c:	1085883a 	add	r2,r2,r2
 820d670:	1085883a 	add	r2,r2,r2
 820d674:	294007cc 	andi	r5,r5,31
 820d678:	2087883a 	add	r3,r4,r2
 820d67c:	283ff026 	beq	r5,zero,820d640 <__any_on+0x1c>
 820d680:	19800017 	ldw	r6,0(r3)
 820d684:	3144d83a 	srl	r2,r6,r5
 820d688:	114a983a 	sll	r5,r2,r5
 820d68c:	317ff41e 	bne	r6,r5,820d660 <__any_on+0x3c>
 820d690:	003feb06 	br	820d640 <__any_on+0x1c>
 820d694:	1085883a 	add	r2,r2,r2
 820d698:	1085883a 	add	r2,r2,r2
 820d69c:	2087883a 	add	r3,r4,r2
 820d6a0:	003fe706 	br	820d640 <__any_on+0x1c>
 820d6a4:	f800283a 	ret
 820d6a8:	0005883a 	mov	r2,zero
 820d6ac:	f800283a 	ret

0820d6b0 <_realloc_r>:
 820d6b0:	defff604 	addi	sp,sp,-40
 820d6b4:	dc800215 	stw	r18,8(sp)
 820d6b8:	dfc00915 	stw	ra,36(sp)
 820d6bc:	df000815 	stw	fp,32(sp)
 820d6c0:	ddc00715 	stw	r23,28(sp)
 820d6c4:	dd800615 	stw	r22,24(sp)
 820d6c8:	dd400515 	stw	r21,20(sp)
 820d6cc:	dd000415 	stw	r20,16(sp)
 820d6d0:	dcc00315 	stw	r19,12(sp)
 820d6d4:	dc400115 	stw	r17,4(sp)
 820d6d8:	dc000015 	stw	r16,0(sp)
 820d6dc:	3025883a 	mov	r18,r6
 820d6e0:	2800b726 	beq	r5,zero,820d9c0 <_realloc_r+0x310>
 820d6e4:	282b883a 	mov	r21,r5
 820d6e8:	2029883a 	mov	r20,r4
 820d6ec:	8214a540 	call	8214a54 <__malloc_lock>
 820d6f0:	a8bfff17 	ldw	r2,-4(r21)
 820d6f4:	043fff04 	movi	r16,-4
 820d6f8:	90c002c4 	addi	r3,r18,11
 820d6fc:	01000584 	movi	r4,22
 820d700:	acfffe04 	addi	r19,r21,-8
 820d704:	1420703a 	and	r16,r2,r16
 820d708:	20c0332e 	bgeu	r4,r3,820d7d8 <_realloc_r+0x128>
 820d70c:	047ffe04 	movi	r17,-8
 820d710:	1c62703a 	and	r17,r3,r17
 820d714:	8807883a 	mov	r3,r17
 820d718:	88005816 	blt	r17,zero,820d87c <_realloc_r+0x1cc>
 820d71c:	8c805736 	bltu	r17,r18,820d87c <_realloc_r+0x1cc>
 820d720:	80c0300e 	bge	r16,r3,820d7e4 <_realloc_r+0x134>
 820d724:	07020974 	movhi	fp,2085
 820d728:	e7094904 	addi	fp,fp,9508
 820d72c:	e1c00217 	ldw	r7,8(fp)
 820d730:	9c09883a 	add	r4,r19,r16
 820d734:	22000117 	ldw	r8,4(r4)
 820d738:	21c06326 	beq	r4,r7,820d8c8 <_realloc_r+0x218>
 820d73c:	017fff84 	movi	r5,-2
 820d740:	414a703a 	and	r5,r8,r5
 820d744:	214b883a 	add	r5,r4,r5
 820d748:	29800117 	ldw	r6,4(r5)
 820d74c:	3180004c 	andi	r6,r6,1
 820d750:	30003f26 	beq	r6,zero,820d850 <_realloc_r+0x1a0>
 820d754:	1080004c 	andi	r2,r2,1
 820d758:	10008326 	beq	r2,zero,820d968 <_realloc_r+0x2b8>
 820d75c:	900b883a 	mov	r5,r18
 820d760:	a009883a 	mov	r4,r20
 820d764:	820bd480 	call	820bd48 <_malloc_r>
 820d768:	1025883a 	mov	r18,r2
 820d76c:	10011e26 	beq	r2,zero,820dbe8 <_realloc_r+0x538>
 820d770:	a93fff17 	ldw	r4,-4(r21)
 820d774:	10fffe04 	addi	r3,r2,-8
 820d778:	00bfff84 	movi	r2,-2
 820d77c:	2084703a 	and	r2,r4,r2
 820d780:	9885883a 	add	r2,r19,r2
 820d784:	1880ee26 	beq	r3,r2,820db40 <_realloc_r+0x490>
 820d788:	81bfff04 	addi	r6,r16,-4
 820d78c:	00800904 	movi	r2,36
 820d790:	1180b836 	bltu	r2,r6,820da74 <_realloc_r+0x3c4>
 820d794:	00c004c4 	movi	r3,19
 820d798:	19809636 	bltu	r3,r6,820d9f4 <_realloc_r+0x344>
 820d79c:	9005883a 	mov	r2,r18
 820d7a0:	a807883a 	mov	r3,r21
 820d7a4:	19000017 	ldw	r4,0(r3)
 820d7a8:	11000015 	stw	r4,0(r2)
 820d7ac:	19000117 	ldw	r4,4(r3)
 820d7b0:	11000115 	stw	r4,4(r2)
 820d7b4:	18c00217 	ldw	r3,8(r3)
 820d7b8:	10c00215 	stw	r3,8(r2)
 820d7bc:	a80b883a 	mov	r5,r21
 820d7c0:	a009883a 	mov	r4,r20
 820d7c4:	820b15c0 	call	820b15c <_free_r>
 820d7c8:	a009883a 	mov	r4,r20
 820d7cc:	8214b740 	call	8214b74 <__malloc_unlock>
 820d7d0:	9005883a 	mov	r2,r18
 820d7d4:	00001206 	br	820d820 <_realloc_r+0x170>
 820d7d8:	00c00404 	movi	r3,16
 820d7dc:	1823883a 	mov	r17,r3
 820d7e0:	003fce06 	br	820d71c <_realloc_r+0x6c>
 820d7e4:	a825883a 	mov	r18,r21
 820d7e8:	8445c83a 	sub	r2,r16,r17
 820d7ec:	00c003c4 	movi	r3,15
 820d7f0:	18802636 	bltu	r3,r2,820d88c <_realloc_r+0x1dc>
 820d7f4:	99800117 	ldw	r6,4(r19)
 820d7f8:	9c07883a 	add	r3,r19,r16
 820d7fc:	3180004c 	andi	r6,r6,1
 820d800:	3420b03a 	or	r16,r6,r16
 820d804:	9c000115 	stw	r16,4(r19)
 820d808:	18800117 	ldw	r2,4(r3)
 820d80c:	10800054 	ori	r2,r2,1
 820d810:	18800115 	stw	r2,4(r3)
 820d814:	a009883a 	mov	r4,r20
 820d818:	8214b740 	call	8214b74 <__malloc_unlock>
 820d81c:	9005883a 	mov	r2,r18
 820d820:	dfc00917 	ldw	ra,36(sp)
 820d824:	df000817 	ldw	fp,32(sp)
 820d828:	ddc00717 	ldw	r23,28(sp)
 820d82c:	dd800617 	ldw	r22,24(sp)
 820d830:	dd400517 	ldw	r21,20(sp)
 820d834:	dd000417 	ldw	r20,16(sp)
 820d838:	dcc00317 	ldw	r19,12(sp)
 820d83c:	dc800217 	ldw	r18,8(sp)
 820d840:	dc400117 	ldw	r17,4(sp)
 820d844:	dc000017 	ldw	r16,0(sp)
 820d848:	dec00a04 	addi	sp,sp,40
 820d84c:	f800283a 	ret
 820d850:	017fff04 	movi	r5,-4
 820d854:	414a703a 	and	r5,r8,r5
 820d858:	814d883a 	add	r6,r16,r5
 820d85c:	30c01f16 	blt	r6,r3,820d8dc <_realloc_r+0x22c>
 820d860:	20800317 	ldw	r2,12(r4)
 820d864:	20c00217 	ldw	r3,8(r4)
 820d868:	a825883a 	mov	r18,r21
 820d86c:	3021883a 	mov	r16,r6
 820d870:	18800315 	stw	r2,12(r3)
 820d874:	10c00215 	stw	r3,8(r2)
 820d878:	003fdb06 	br	820d7e8 <_realloc_r+0x138>
 820d87c:	00800304 	movi	r2,12
 820d880:	a0800015 	stw	r2,0(r20)
 820d884:	0005883a 	mov	r2,zero
 820d888:	003fe506 	br	820d820 <_realloc_r+0x170>
 820d88c:	98c00117 	ldw	r3,4(r19)
 820d890:	9c4b883a 	add	r5,r19,r17
 820d894:	11000054 	ori	r4,r2,1
 820d898:	18c0004c 	andi	r3,r3,1
 820d89c:	1c62b03a 	or	r17,r3,r17
 820d8a0:	9c400115 	stw	r17,4(r19)
 820d8a4:	29000115 	stw	r4,4(r5)
 820d8a8:	2885883a 	add	r2,r5,r2
 820d8ac:	10c00117 	ldw	r3,4(r2)
 820d8b0:	29400204 	addi	r5,r5,8
 820d8b4:	a009883a 	mov	r4,r20
 820d8b8:	18c00054 	ori	r3,r3,1
 820d8bc:	10c00115 	stw	r3,4(r2)
 820d8c0:	820b15c0 	call	820b15c <_free_r>
 820d8c4:	003fd306 	br	820d814 <_realloc_r+0x164>
 820d8c8:	017fff04 	movi	r5,-4
 820d8cc:	414a703a 	and	r5,r8,r5
 820d8d0:	89800404 	addi	r6,r17,16
 820d8d4:	8151883a 	add	r8,r16,r5
 820d8d8:	4180590e 	bge	r8,r6,820da40 <_realloc_r+0x390>
 820d8dc:	1080004c 	andi	r2,r2,1
 820d8e0:	103f9e1e 	bne	r2,zero,820d75c <_realloc_r+0xac>
 820d8e4:	adbffe17 	ldw	r22,-8(r21)
 820d8e8:	00bfff04 	movi	r2,-4
 820d8ec:	9dadc83a 	sub	r22,r19,r22
 820d8f0:	b1800117 	ldw	r6,4(r22)
 820d8f4:	3084703a 	and	r2,r6,r2
 820d8f8:	20002026 	beq	r4,zero,820d97c <_realloc_r+0x2cc>
 820d8fc:	80af883a 	add	r23,r16,r2
 820d900:	b96f883a 	add	r23,r23,r5
 820d904:	21c05f26 	beq	r4,r7,820da84 <_realloc_r+0x3d4>
 820d908:	b8c01c16 	blt	r23,r3,820d97c <_realloc_r+0x2cc>
 820d90c:	20800317 	ldw	r2,12(r4)
 820d910:	20c00217 	ldw	r3,8(r4)
 820d914:	81bfff04 	addi	r6,r16,-4
 820d918:	01000904 	movi	r4,36
 820d91c:	18800315 	stw	r2,12(r3)
 820d920:	10c00215 	stw	r3,8(r2)
 820d924:	b0c00217 	ldw	r3,8(r22)
 820d928:	b0800317 	ldw	r2,12(r22)
 820d92c:	b4800204 	addi	r18,r22,8
 820d930:	18800315 	stw	r2,12(r3)
 820d934:	10c00215 	stw	r3,8(r2)
 820d938:	21801b36 	bltu	r4,r6,820d9a8 <_realloc_r+0x2f8>
 820d93c:	008004c4 	movi	r2,19
 820d940:	1180352e 	bgeu	r2,r6,820da18 <_realloc_r+0x368>
 820d944:	a8800017 	ldw	r2,0(r21)
 820d948:	b0800215 	stw	r2,8(r22)
 820d94c:	a8800117 	ldw	r2,4(r21)
 820d950:	b0800315 	stw	r2,12(r22)
 820d954:	008006c4 	movi	r2,27
 820d958:	11807f36 	bltu	r2,r6,820db58 <_realloc_r+0x4a8>
 820d95c:	b0800404 	addi	r2,r22,16
 820d960:	ad400204 	addi	r21,r21,8
 820d964:	00002d06 	br	820da1c <_realloc_r+0x36c>
 820d968:	adbffe17 	ldw	r22,-8(r21)
 820d96c:	00bfff04 	movi	r2,-4
 820d970:	9dadc83a 	sub	r22,r19,r22
 820d974:	b1000117 	ldw	r4,4(r22)
 820d978:	2084703a 	and	r2,r4,r2
 820d97c:	b03f7726 	beq	r22,zero,820d75c <_realloc_r+0xac>
 820d980:	80af883a 	add	r23,r16,r2
 820d984:	b8ff7516 	blt	r23,r3,820d75c <_realloc_r+0xac>
 820d988:	b0800317 	ldw	r2,12(r22)
 820d98c:	b0c00217 	ldw	r3,8(r22)
 820d990:	81bfff04 	addi	r6,r16,-4
 820d994:	01000904 	movi	r4,36
 820d998:	18800315 	stw	r2,12(r3)
 820d99c:	10c00215 	stw	r3,8(r2)
 820d9a0:	b4800204 	addi	r18,r22,8
 820d9a4:	21bfe52e 	bgeu	r4,r6,820d93c <_realloc_r+0x28c>
 820d9a8:	a80b883a 	mov	r5,r21
 820d9ac:	9009883a 	mov	r4,r18
 820d9b0:	82030b40 	call	82030b4 <memmove>
 820d9b4:	b821883a 	mov	r16,r23
 820d9b8:	b027883a 	mov	r19,r22
 820d9bc:	003f8a06 	br	820d7e8 <_realloc_r+0x138>
 820d9c0:	300b883a 	mov	r5,r6
 820d9c4:	dfc00917 	ldw	ra,36(sp)
 820d9c8:	df000817 	ldw	fp,32(sp)
 820d9cc:	ddc00717 	ldw	r23,28(sp)
 820d9d0:	dd800617 	ldw	r22,24(sp)
 820d9d4:	dd400517 	ldw	r21,20(sp)
 820d9d8:	dd000417 	ldw	r20,16(sp)
 820d9dc:	dcc00317 	ldw	r19,12(sp)
 820d9e0:	dc800217 	ldw	r18,8(sp)
 820d9e4:	dc400117 	ldw	r17,4(sp)
 820d9e8:	dc000017 	ldw	r16,0(sp)
 820d9ec:	dec00a04 	addi	sp,sp,40
 820d9f0:	820bd481 	jmpi	820bd48 <_malloc_r>
 820d9f4:	a8c00017 	ldw	r3,0(r21)
 820d9f8:	90c00015 	stw	r3,0(r18)
 820d9fc:	a8c00117 	ldw	r3,4(r21)
 820da00:	90c00115 	stw	r3,4(r18)
 820da04:	00c006c4 	movi	r3,27
 820da08:	19804536 	bltu	r3,r6,820db20 <_realloc_r+0x470>
 820da0c:	90800204 	addi	r2,r18,8
 820da10:	a8c00204 	addi	r3,r21,8
 820da14:	003f6306 	br	820d7a4 <_realloc_r+0xf4>
 820da18:	9005883a 	mov	r2,r18
 820da1c:	a8c00017 	ldw	r3,0(r21)
 820da20:	b821883a 	mov	r16,r23
 820da24:	b027883a 	mov	r19,r22
 820da28:	10c00015 	stw	r3,0(r2)
 820da2c:	a8c00117 	ldw	r3,4(r21)
 820da30:	10c00115 	stw	r3,4(r2)
 820da34:	a8c00217 	ldw	r3,8(r21)
 820da38:	10c00215 	stw	r3,8(r2)
 820da3c:	003f6a06 	br	820d7e8 <_realloc_r+0x138>
 820da40:	9c67883a 	add	r19,r19,r17
 820da44:	4445c83a 	sub	r2,r8,r17
 820da48:	e4c00215 	stw	r19,8(fp)
 820da4c:	10800054 	ori	r2,r2,1
 820da50:	98800115 	stw	r2,4(r19)
 820da54:	a8bfff17 	ldw	r2,-4(r21)
 820da58:	a009883a 	mov	r4,r20
 820da5c:	1080004c 	andi	r2,r2,1
 820da60:	1462b03a 	or	r17,r2,r17
 820da64:	ac7fff15 	stw	r17,-4(r21)
 820da68:	8214b740 	call	8214b74 <__malloc_unlock>
 820da6c:	a805883a 	mov	r2,r21
 820da70:	003f6b06 	br	820d820 <_realloc_r+0x170>
 820da74:	a80b883a 	mov	r5,r21
 820da78:	9009883a 	mov	r4,r18
 820da7c:	82030b40 	call	82030b4 <memmove>
 820da80:	003f4e06 	br	820d7bc <_realloc_r+0x10c>
 820da84:	89000404 	addi	r4,r17,16
 820da88:	b93fbc16 	blt	r23,r4,820d97c <_realloc_r+0x2cc>
 820da8c:	b0800317 	ldw	r2,12(r22)
 820da90:	b0c00217 	ldw	r3,8(r22)
 820da94:	81bfff04 	addi	r6,r16,-4
 820da98:	01000904 	movi	r4,36
 820da9c:	18800315 	stw	r2,12(r3)
 820daa0:	10c00215 	stw	r3,8(r2)
 820daa4:	b4800204 	addi	r18,r22,8
 820daa8:	21804336 	bltu	r4,r6,820dbb8 <_realloc_r+0x508>
 820daac:	008004c4 	movi	r2,19
 820dab0:	11803f2e 	bgeu	r2,r6,820dbb0 <_realloc_r+0x500>
 820dab4:	a8800017 	ldw	r2,0(r21)
 820dab8:	b0800215 	stw	r2,8(r22)
 820dabc:	a8800117 	ldw	r2,4(r21)
 820dac0:	b0800315 	stw	r2,12(r22)
 820dac4:	008006c4 	movi	r2,27
 820dac8:	11803f36 	bltu	r2,r6,820dbc8 <_realloc_r+0x518>
 820dacc:	b0800404 	addi	r2,r22,16
 820dad0:	ad400204 	addi	r21,r21,8
 820dad4:	a8c00017 	ldw	r3,0(r21)
 820dad8:	10c00015 	stw	r3,0(r2)
 820dadc:	a8c00117 	ldw	r3,4(r21)
 820dae0:	10c00115 	stw	r3,4(r2)
 820dae4:	a8c00217 	ldw	r3,8(r21)
 820dae8:	10c00215 	stw	r3,8(r2)
 820daec:	b447883a 	add	r3,r22,r17
 820daf0:	bc45c83a 	sub	r2,r23,r17
 820daf4:	e0c00215 	stw	r3,8(fp)
 820daf8:	10800054 	ori	r2,r2,1
 820dafc:	18800115 	stw	r2,4(r3)
 820db00:	b0800117 	ldw	r2,4(r22)
 820db04:	a009883a 	mov	r4,r20
 820db08:	1080004c 	andi	r2,r2,1
 820db0c:	1462b03a 	or	r17,r2,r17
 820db10:	b4400115 	stw	r17,4(r22)
 820db14:	8214b740 	call	8214b74 <__malloc_unlock>
 820db18:	9005883a 	mov	r2,r18
 820db1c:	003f4006 	br	820d820 <_realloc_r+0x170>
 820db20:	a8c00217 	ldw	r3,8(r21)
 820db24:	90c00215 	stw	r3,8(r18)
 820db28:	a8c00317 	ldw	r3,12(r21)
 820db2c:	90c00315 	stw	r3,12(r18)
 820db30:	30801126 	beq	r6,r2,820db78 <_realloc_r+0x4c8>
 820db34:	90800404 	addi	r2,r18,16
 820db38:	a8c00404 	addi	r3,r21,16
 820db3c:	003f1906 	br	820d7a4 <_realloc_r+0xf4>
 820db40:	90ffff17 	ldw	r3,-4(r18)
 820db44:	00bfff04 	movi	r2,-4
 820db48:	a825883a 	mov	r18,r21
 820db4c:	1884703a 	and	r2,r3,r2
 820db50:	80a1883a 	add	r16,r16,r2
 820db54:	003f2406 	br	820d7e8 <_realloc_r+0x138>
 820db58:	a8800217 	ldw	r2,8(r21)
 820db5c:	b0800415 	stw	r2,16(r22)
 820db60:	a8800317 	ldw	r2,12(r21)
 820db64:	b0800515 	stw	r2,20(r22)
 820db68:	31000a26 	beq	r6,r4,820db94 <_realloc_r+0x4e4>
 820db6c:	b0800604 	addi	r2,r22,24
 820db70:	ad400404 	addi	r21,r21,16
 820db74:	003fa906 	br	820da1c <_realloc_r+0x36c>
 820db78:	a9000417 	ldw	r4,16(r21)
 820db7c:	90800604 	addi	r2,r18,24
 820db80:	a8c00604 	addi	r3,r21,24
 820db84:	91000415 	stw	r4,16(r18)
 820db88:	a9000517 	ldw	r4,20(r21)
 820db8c:	91000515 	stw	r4,20(r18)
 820db90:	003f0406 	br	820d7a4 <_realloc_r+0xf4>
 820db94:	a8c00417 	ldw	r3,16(r21)
 820db98:	ad400604 	addi	r21,r21,24
 820db9c:	b0800804 	addi	r2,r22,32
 820dba0:	b0c00615 	stw	r3,24(r22)
 820dba4:	a8ffff17 	ldw	r3,-4(r21)
 820dba8:	b0c00715 	stw	r3,28(r22)
 820dbac:	003f9b06 	br	820da1c <_realloc_r+0x36c>
 820dbb0:	9005883a 	mov	r2,r18
 820dbb4:	003fc706 	br	820dad4 <_realloc_r+0x424>
 820dbb8:	a80b883a 	mov	r5,r21
 820dbbc:	9009883a 	mov	r4,r18
 820dbc0:	82030b40 	call	82030b4 <memmove>
 820dbc4:	003fc906 	br	820daec <_realloc_r+0x43c>
 820dbc8:	a8800217 	ldw	r2,8(r21)
 820dbcc:	b0800415 	stw	r2,16(r22)
 820dbd0:	a8800317 	ldw	r2,12(r21)
 820dbd4:	b0800515 	stw	r2,20(r22)
 820dbd8:	31000726 	beq	r6,r4,820dbf8 <_realloc_r+0x548>
 820dbdc:	b0800604 	addi	r2,r22,24
 820dbe0:	ad400404 	addi	r21,r21,16
 820dbe4:	003fbb06 	br	820dad4 <_realloc_r+0x424>
 820dbe8:	a009883a 	mov	r4,r20
 820dbec:	8214b740 	call	8214b74 <__malloc_unlock>
 820dbf0:	0005883a 	mov	r2,zero
 820dbf4:	003f0a06 	br	820d820 <_realloc_r+0x170>
 820dbf8:	a8c00417 	ldw	r3,16(r21)
 820dbfc:	ad400604 	addi	r21,r21,24
 820dc00:	b0800804 	addi	r2,r22,32
 820dc04:	b0c00615 	stw	r3,24(r22)
 820dc08:	a8ffff17 	ldw	r3,-4(r21)
 820dc0c:	b0c00715 	stw	r3,28(r22)
 820dc10:	003fb006 	br	820dad4 <_realloc_r+0x424>

0820dc14 <lflush>:
 820dc14:	2080030b 	ldhu	r2,12(r4)
 820dc18:	00c00244 	movi	r3,9
 820dc1c:	1080024c 	andi	r2,r2,9
 820dc20:	10c00226 	beq	r2,r3,820dc2c <lflush+0x18>
 820dc24:	0005883a 	mov	r2,zero
 820dc28:	f800283a 	ret
 820dc2c:	820ab141 	jmpi	820ab14 <fflush>

0820dc30 <__srefill_r>:
 820dc30:	defffc04 	addi	sp,sp,-16
 820dc34:	dc400115 	stw	r17,4(sp)
 820dc38:	dc000015 	stw	r16,0(sp)
 820dc3c:	dfc00315 	stw	ra,12(sp)
 820dc40:	dc800215 	stw	r18,8(sp)
 820dc44:	2023883a 	mov	r17,r4
 820dc48:	2821883a 	mov	r16,r5
 820dc4c:	20000226 	beq	r4,zero,820dc58 <__srefill_r+0x28>
 820dc50:	20800e17 	ldw	r2,56(r4)
 820dc54:	10003c26 	beq	r2,zero,820dd48 <__srefill_r+0x118>
 820dc58:	80c0030b 	ldhu	r3,12(r16)
 820dc5c:	1908000c 	andi	r4,r3,8192
 820dc60:	1805883a 	mov	r2,r3
 820dc64:	2000071e 	bne	r4,zero,820dc84 <__srefill_r+0x54>
 820dc68:	81001917 	ldw	r4,100(r16)
 820dc6c:	18880014 	ori	r2,r3,8192
 820dc70:	00f7ffc4 	movi	r3,-8193
 820dc74:	20c8703a 	and	r4,r4,r3
 820dc78:	8080030d 	sth	r2,12(r16)
 820dc7c:	1007883a 	mov	r3,r2
 820dc80:	81001915 	stw	r4,100(r16)
 820dc84:	80000115 	stw	zero,4(r16)
 820dc88:	1100080c 	andi	r4,r2,32
 820dc8c:	2000571e 	bne	r4,zero,820ddec <__srefill_r+0x1bc>
 820dc90:	1100010c 	andi	r4,r2,4
 820dc94:	20001f26 	beq	r4,zero,820dd14 <__srefill_r+0xe4>
 820dc98:	81400c17 	ldw	r5,48(r16)
 820dc9c:	28000826 	beq	r5,zero,820dcc0 <__srefill_r+0x90>
 820dca0:	80801004 	addi	r2,r16,64
 820dca4:	28800226 	beq	r5,r2,820dcb0 <__srefill_r+0x80>
 820dca8:	8809883a 	mov	r4,r17
 820dcac:	820b15c0 	call	820b15c <_free_r>
 820dcb0:	80800f17 	ldw	r2,60(r16)
 820dcb4:	80000c15 	stw	zero,48(r16)
 820dcb8:	80800115 	stw	r2,4(r16)
 820dcbc:	1000391e 	bne	r2,zero,820dda4 <__srefill_r+0x174>
 820dcc0:	80800417 	ldw	r2,16(r16)
 820dcc4:	10004b26 	beq	r2,zero,820ddf4 <__srefill_r+0x1c4>
 820dcc8:	8480030b 	ldhu	r18,12(r16)
 820dccc:	908000cc 	andi	r2,r18,3
 820dcd0:	10001f1e 	bne	r2,zero,820dd50 <__srefill_r+0x120>
 820dcd4:	81800417 	ldw	r6,16(r16)
 820dcd8:	80800817 	ldw	r2,32(r16)
 820dcdc:	81c00517 	ldw	r7,20(r16)
 820dce0:	81400717 	ldw	r5,28(r16)
 820dce4:	81800015 	stw	r6,0(r16)
 820dce8:	8809883a 	mov	r4,r17
 820dcec:	103ee83a 	callr	r2
 820dcf0:	80800115 	stw	r2,4(r16)
 820dcf4:	00800e0e 	bge	zero,r2,820dd30 <__srefill_r+0x100>
 820dcf8:	0005883a 	mov	r2,zero
 820dcfc:	dfc00317 	ldw	ra,12(sp)
 820dd00:	dc800217 	ldw	r18,8(sp)
 820dd04:	dc400117 	ldw	r17,4(sp)
 820dd08:	dc000017 	ldw	r16,0(sp)
 820dd0c:	dec00404 	addi	sp,sp,16
 820dd10:	f800283a 	ret
 820dd14:	1100040c 	andi	r4,r2,16
 820dd18:	20003026 	beq	r4,zero,820dddc <__srefill_r+0x1ac>
 820dd1c:	1080020c 	andi	r2,r2,8
 820dd20:	1000241e 	bne	r2,zero,820ddb4 <__srefill_r+0x184>
 820dd24:	18c00114 	ori	r3,r3,4
 820dd28:	80c0030d 	sth	r3,12(r16)
 820dd2c:	003fe406 	br	820dcc0 <__srefill_r+0x90>
 820dd30:	80c0030b 	ldhu	r3,12(r16)
 820dd34:	1000161e 	bne	r2,zero,820dd90 <__srefill_r+0x160>
 820dd38:	18c00814 	ori	r3,r3,32
 820dd3c:	00bfffc4 	movi	r2,-1
 820dd40:	80c0030d 	sth	r3,12(r16)
 820dd44:	003fed06 	br	820dcfc <__srefill_r+0xcc>
 820dd48:	820ae940 	call	820ae94 <__sinit>
 820dd4c:	003fc206 	br	820dc58 <__srefill_r+0x28>
 820dd50:	00820974 	movhi	r2,2085
 820dd54:	108fba04 	addi	r2,r2,16104
 820dd58:	11000017 	ldw	r4,0(r2)
 820dd5c:	01420874 	movhi	r5,2081
 820dd60:	00800044 	movi	r2,1
 820dd64:	29770504 	addi	r5,r5,-9196
 820dd68:	8080030d 	sth	r2,12(r16)
 820dd6c:	820b9280 	call	820b928 <_fwalk>
 820dd70:	00800244 	movi	r2,9
 820dd74:	8480030d 	sth	r18,12(r16)
 820dd78:	9480024c 	andi	r18,r18,9
 820dd7c:	90bfd51e 	bne	r18,r2,820dcd4 <__srefill_r+0xa4>
 820dd80:	800b883a 	mov	r5,r16
 820dd84:	8809883a 	mov	r4,r17
 820dd88:	820a89c0 	call	820a89c <__sflush_r>
 820dd8c:	003fd106 	br	820dcd4 <__srefill_r+0xa4>
 820dd90:	18c01014 	ori	r3,r3,64
 820dd94:	80000115 	stw	zero,4(r16)
 820dd98:	00bfffc4 	movi	r2,-1
 820dd9c:	80c0030d 	sth	r3,12(r16)
 820dda0:	003fd606 	br	820dcfc <__srefill_r+0xcc>
 820dda4:	80c00e17 	ldw	r3,56(r16)
 820dda8:	0005883a 	mov	r2,zero
 820ddac:	80c00015 	stw	r3,0(r16)
 820ddb0:	003fd206 	br	820dcfc <__srefill_r+0xcc>
 820ddb4:	800b883a 	mov	r5,r16
 820ddb8:	8809883a 	mov	r4,r17
 820ddbc:	820aab80 	call	820aab8 <_fflush_r>
 820ddc0:	10000a1e 	bne	r2,zero,820ddec <__srefill_r+0x1bc>
 820ddc4:	8080030b 	ldhu	r2,12(r16)
 820ddc8:	00fffdc4 	movi	r3,-9
 820ddcc:	80000215 	stw	zero,8(r16)
 820ddd0:	1886703a 	and	r3,r3,r2
 820ddd4:	80000615 	stw	zero,24(r16)
 820ddd8:	003fd206 	br	820dd24 <__srefill_r+0xf4>
 820dddc:	00800244 	movi	r2,9
 820dde0:	88800015 	stw	r2,0(r17)
 820dde4:	18c01014 	ori	r3,r3,64
 820dde8:	80c0030d 	sth	r3,12(r16)
 820ddec:	00bfffc4 	movi	r2,-1
 820ddf0:	003fc206 	br	820dcfc <__srefill_r+0xcc>
 820ddf4:	800b883a 	mov	r5,r16
 820ddf8:	8809883a 	mov	r4,r17
 820ddfc:	820bb8c0 	call	820bb8c <__smakebuf_r>
 820de00:	003fb106 	br	820dcc8 <__srefill_r+0x98>

0820de04 <__fpclassifyd>:
 820de04:	00a00034 	movhi	r2,32768
 820de08:	10bfffc4 	addi	r2,r2,-1
 820de0c:	2884703a 	and	r2,r5,r2
 820de10:	10000726 	beq	r2,zero,820de30 <__fpclassifyd+0x2c>
 820de14:	00fffc34 	movhi	r3,65520
 820de18:	019ff834 	movhi	r6,32736
 820de1c:	28c7883a 	add	r3,r5,r3
 820de20:	31bfffc4 	addi	r6,r6,-1
 820de24:	30c00536 	bltu	r6,r3,820de3c <__fpclassifyd+0x38>
 820de28:	00800104 	movi	r2,4
 820de2c:	f800283a 	ret
 820de30:	2000021e 	bne	r4,zero,820de3c <__fpclassifyd+0x38>
 820de34:	00800084 	movi	r2,2
 820de38:	f800283a 	ret
 820de3c:	00dffc34 	movhi	r3,32752
 820de40:	019ff834 	movhi	r6,32736
 820de44:	28cb883a 	add	r5,r5,r3
 820de48:	31bfffc4 	addi	r6,r6,-1
 820de4c:	317ff62e 	bgeu	r6,r5,820de28 <__fpclassifyd+0x24>
 820de50:	01400434 	movhi	r5,16
 820de54:	297fffc4 	addi	r5,r5,-1
 820de58:	28800236 	bltu	r5,r2,820de64 <__fpclassifyd+0x60>
 820de5c:	008000c4 	movi	r2,3
 820de60:	f800283a 	ret
 820de64:	10c00226 	beq	r2,r3,820de70 <__fpclassifyd+0x6c>
 820de68:	0005883a 	mov	r2,zero
 820de6c:	f800283a 	ret
 820de70:	2005003a 	cmpeq	r2,r4,zero
 820de74:	f800283a 	ret

0820de78 <_sbrk_r>:
 820de78:	defffd04 	addi	sp,sp,-12
 820de7c:	dc000015 	stw	r16,0(sp)
 820de80:	04020974 	movhi	r16,2085
 820de84:	dc400115 	stw	r17,4(sp)
 820de88:	84101c04 	addi	r16,r16,16496
 820de8c:	2023883a 	mov	r17,r4
 820de90:	2809883a 	mov	r4,r5
 820de94:	dfc00215 	stw	ra,8(sp)
 820de98:	80000015 	stw	zero,0(r16)
 820de9c:	82148800 	call	8214880 <sbrk>
 820dea0:	00ffffc4 	movi	r3,-1
 820dea4:	10c00526 	beq	r2,r3,820debc <_sbrk_r+0x44>
 820dea8:	dfc00217 	ldw	ra,8(sp)
 820deac:	dc400117 	ldw	r17,4(sp)
 820deb0:	dc000017 	ldw	r16,0(sp)
 820deb4:	dec00304 	addi	sp,sp,12
 820deb8:	f800283a 	ret
 820debc:	80c00017 	ldw	r3,0(r16)
 820dec0:	183ff926 	beq	r3,zero,820dea8 <_sbrk_r+0x30>
 820dec4:	88c00015 	stw	r3,0(r17)
 820dec8:	003ff706 	br	820dea8 <_sbrk_r+0x30>

0820decc <__sread>:
 820decc:	defffe04 	addi	sp,sp,-8
 820ded0:	dc000015 	stw	r16,0(sp)
 820ded4:	2821883a 	mov	r16,r5
 820ded8:	2940038f 	ldh	r5,14(r5)
 820dedc:	dfc00115 	stw	ra,4(sp)
 820dee0:	82110cc0 	call	82110cc <_read_r>
 820dee4:	10000716 	blt	r2,zero,820df04 <__sread+0x38>
 820dee8:	80c01417 	ldw	r3,80(r16)
 820deec:	1887883a 	add	r3,r3,r2
 820def0:	80c01415 	stw	r3,80(r16)
 820def4:	dfc00117 	ldw	ra,4(sp)
 820def8:	dc000017 	ldw	r16,0(sp)
 820defc:	dec00204 	addi	sp,sp,8
 820df00:	f800283a 	ret
 820df04:	80c0030b 	ldhu	r3,12(r16)
 820df08:	18fbffcc 	andi	r3,r3,61439
 820df0c:	80c0030d 	sth	r3,12(r16)
 820df10:	dfc00117 	ldw	ra,4(sp)
 820df14:	dc000017 	ldw	r16,0(sp)
 820df18:	dec00204 	addi	sp,sp,8
 820df1c:	f800283a 	ret

0820df20 <__seofread>:
 820df20:	0005883a 	mov	r2,zero
 820df24:	f800283a 	ret

0820df28 <__swrite>:
 820df28:	2880030b 	ldhu	r2,12(r5)
 820df2c:	defffb04 	addi	sp,sp,-20
 820df30:	dcc00315 	stw	r19,12(sp)
 820df34:	dc800215 	stw	r18,8(sp)
 820df38:	dc400115 	stw	r17,4(sp)
 820df3c:	dc000015 	stw	r16,0(sp)
 820df40:	dfc00415 	stw	ra,16(sp)
 820df44:	10c0400c 	andi	r3,r2,256
 820df48:	2821883a 	mov	r16,r5
 820df4c:	2023883a 	mov	r17,r4
 820df50:	3025883a 	mov	r18,r6
 820df54:	3827883a 	mov	r19,r7
 820df58:	18000526 	beq	r3,zero,820df70 <__swrite+0x48>
 820df5c:	2940038f 	ldh	r5,14(r5)
 820df60:	01c00084 	movi	r7,2
 820df64:	000d883a 	mov	r6,zero
 820df68:	821106c0 	call	821106c <_lseek_r>
 820df6c:	8080030b 	ldhu	r2,12(r16)
 820df70:	8140038f 	ldh	r5,14(r16)
 820df74:	10bbffcc 	andi	r2,r2,61439
 820df78:	980f883a 	mov	r7,r19
 820df7c:	900d883a 	mov	r6,r18
 820df80:	8809883a 	mov	r4,r17
 820df84:	8080030d 	sth	r2,12(r16)
 820df88:	dfc00417 	ldw	ra,16(sp)
 820df8c:	dcc00317 	ldw	r19,12(sp)
 820df90:	dc800217 	ldw	r18,8(sp)
 820df94:	dc400117 	ldw	r17,4(sp)
 820df98:	dc000017 	ldw	r16,0(sp)
 820df9c:	dec00504 	addi	sp,sp,20
 820dfa0:	8210b381 	jmpi	8210b38 <_write_r>

0820dfa4 <__sseek>:
 820dfa4:	defffe04 	addi	sp,sp,-8
 820dfa8:	dc000015 	stw	r16,0(sp)
 820dfac:	2821883a 	mov	r16,r5
 820dfb0:	2940038f 	ldh	r5,14(r5)
 820dfb4:	dfc00115 	stw	ra,4(sp)
 820dfb8:	821106c0 	call	821106c <_lseek_r>
 820dfbc:	00ffffc4 	movi	r3,-1
 820dfc0:	10c00826 	beq	r2,r3,820dfe4 <__sseek+0x40>
 820dfc4:	80c0030b 	ldhu	r3,12(r16)
 820dfc8:	80801415 	stw	r2,80(r16)
 820dfcc:	18c40014 	ori	r3,r3,4096
 820dfd0:	80c0030d 	sth	r3,12(r16)
 820dfd4:	dfc00117 	ldw	ra,4(sp)
 820dfd8:	dc000017 	ldw	r16,0(sp)
 820dfdc:	dec00204 	addi	sp,sp,8
 820dfe0:	f800283a 	ret
 820dfe4:	80c0030b 	ldhu	r3,12(r16)
 820dfe8:	18fbffcc 	andi	r3,r3,61439
 820dfec:	80c0030d 	sth	r3,12(r16)
 820dff0:	dfc00117 	ldw	ra,4(sp)
 820dff4:	dc000017 	ldw	r16,0(sp)
 820dff8:	dec00204 	addi	sp,sp,8
 820dffc:	f800283a 	ret

0820e000 <__sclose>:
 820e000:	2940038f 	ldh	r5,14(r5)
 820e004:	8210b981 	jmpi	8210b98 <_close_r>

0820e008 <strcmp>:
 820e008:	2144b03a 	or	r2,r4,r5
 820e00c:	108000cc 	andi	r2,r2,3
 820e010:	1000171e 	bne	r2,zero,820e070 <strcmp+0x68>
 820e014:	20800017 	ldw	r2,0(r4)
 820e018:	28c00017 	ldw	r3,0(r5)
 820e01c:	10c0141e 	bne	r2,r3,820e070 <strcmp+0x68>
 820e020:	027fbff4 	movhi	r9,65279
 820e024:	4a7fbfc4 	addi	r9,r9,-257
 820e028:	0086303a 	nor	r3,zero,r2
 820e02c:	02202074 	movhi	r8,32897
 820e030:	1245883a 	add	r2,r2,r9
 820e034:	42202004 	addi	r8,r8,-32640
 820e038:	10c4703a 	and	r2,r2,r3
 820e03c:	1204703a 	and	r2,r2,r8
 820e040:	10000226 	beq	r2,zero,820e04c <strcmp+0x44>
 820e044:	00002306 	br	820e0d4 <strcmp+0xcc>
 820e048:	1000221e 	bne	r2,zero,820e0d4 <strcmp+0xcc>
 820e04c:	21000104 	addi	r4,r4,4
 820e050:	20c00017 	ldw	r3,0(r4)
 820e054:	29400104 	addi	r5,r5,4
 820e058:	29800017 	ldw	r6,0(r5)
 820e05c:	1a4f883a 	add	r7,r3,r9
 820e060:	00c4303a 	nor	r2,zero,r3
 820e064:	3884703a 	and	r2,r7,r2
 820e068:	1204703a 	and	r2,r2,r8
 820e06c:	19bff626 	beq	r3,r6,820e048 <strcmp+0x40>
 820e070:	20800003 	ldbu	r2,0(r4)
 820e074:	10c03fcc 	andi	r3,r2,255
 820e078:	18c0201c 	xori	r3,r3,128
 820e07c:	18ffe004 	addi	r3,r3,-128
 820e080:	18000c26 	beq	r3,zero,820e0b4 <strcmp+0xac>
 820e084:	29800007 	ldb	r6,0(r5)
 820e088:	19800326 	beq	r3,r6,820e098 <strcmp+0x90>
 820e08c:	00001306 	br	820e0dc <strcmp+0xd4>
 820e090:	29800007 	ldb	r6,0(r5)
 820e094:	11800b1e 	bne	r2,r6,820e0c4 <strcmp+0xbc>
 820e098:	21000044 	addi	r4,r4,1
 820e09c:	20c00003 	ldbu	r3,0(r4)
 820e0a0:	29400044 	addi	r5,r5,1
 820e0a4:	18803fcc 	andi	r2,r3,255
 820e0a8:	1080201c 	xori	r2,r2,128
 820e0ac:	10bfe004 	addi	r2,r2,-128
 820e0b0:	103ff71e 	bne	r2,zero,820e090 <strcmp+0x88>
 820e0b4:	0007883a 	mov	r3,zero
 820e0b8:	28800003 	ldbu	r2,0(r5)
 820e0bc:	1885c83a 	sub	r2,r3,r2
 820e0c0:	f800283a 	ret
 820e0c4:	28800003 	ldbu	r2,0(r5)
 820e0c8:	18c03fcc 	andi	r3,r3,255
 820e0cc:	1885c83a 	sub	r2,r3,r2
 820e0d0:	f800283a 	ret
 820e0d4:	0005883a 	mov	r2,zero
 820e0d8:	f800283a 	ret
 820e0dc:	10c03fcc 	andi	r3,r2,255
 820e0e0:	003ff506 	br	820e0b8 <strcmp+0xb0>

0820e0e4 <__ssprint_r>:
 820e0e4:	30800217 	ldw	r2,8(r6)
 820e0e8:	defff604 	addi	sp,sp,-40
 820e0ec:	dc800215 	stw	r18,8(sp)
 820e0f0:	dfc00915 	stw	ra,36(sp)
 820e0f4:	df000815 	stw	fp,32(sp)
 820e0f8:	ddc00715 	stw	r23,28(sp)
 820e0fc:	dd800615 	stw	r22,24(sp)
 820e100:	dd400515 	stw	r21,20(sp)
 820e104:	dd000415 	stw	r20,16(sp)
 820e108:	dcc00315 	stw	r19,12(sp)
 820e10c:	dc400115 	stw	r17,4(sp)
 820e110:	dc000015 	stw	r16,0(sp)
 820e114:	3025883a 	mov	r18,r6
 820e118:	10005826 	beq	r2,zero,820e27c <__ssprint_r+0x198>
 820e11c:	2027883a 	mov	r19,r4
 820e120:	35c00017 	ldw	r23,0(r6)
 820e124:	29000017 	ldw	r4,0(r5)
 820e128:	28800217 	ldw	r2,8(r5)
 820e12c:	2823883a 	mov	r17,r5
 820e130:	0039883a 	mov	fp,zero
 820e134:	0021883a 	mov	r16,zero
 820e138:	80003926 	beq	r16,zero,820e220 <__ssprint_r+0x13c>
 820e13c:	102b883a 	mov	r21,r2
 820e140:	102d883a 	mov	r22,r2
 820e144:	80803a36 	bltu	r16,r2,820e230 <__ssprint_r+0x14c>
 820e148:	88c0030b 	ldhu	r3,12(r17)
 820e14c:	1881200c 	andi	r2,r3,1152
 820e150:	10002626 	beq	r2,zero,820e1ec <__ssprint_r+0x108>
 820e154:	88800517 	ldw	r2,20(r17)
 820e158:	89400417 	ldw	r5,16(r17)
 820e15c:	81800044 	addi	r6,r16,1
 820e160:	108f883a 	add	r7,r2,r2
 820e164:	3885883a 	add	r2,r7,r2
 820e168:	100ed7fa 	srli	r7,r2,31
 820e16c:	216dc83a 	sub	r22,r4,r5
 820e170:	3589883a 	add	r4,r6,r22
 820e174:	3885883a 	add	r2,r7,r2
 820e178:	102bd07a 	srai	r21,r2,1
 820e17c:	a80d883a 	mov	r6,r21
 820e180:	a900022e 	bgeu	r21,r4,820e18c <__ssprint_r+0xa8>
 820e184:	202b883a 	mov	r21,r4
 820e188:	200d883a 	mov	r6,r4
 820e18c:	18c1000c 	andi	r3,r3,1024
 820e190:	18002a26 	beq	r3,zero,820e23c <__ssprint_r+0x158>
 820e194:	300b883a 	mov	r5,r6
 820e198:	9809883a 	mov	r4,r19
 820e19c:	820bd480 	call	820bd48 <_malloc_r>
 820e1a0:	1029883a 	mov	r20,r2
 820e1a4:	10002c26 	beq	r2,zero,820e258 <__ssprint_r+0x174>
 820e1a8:	89400417 	ldw	r5,16(r17)
 820e1ac:	b00d883a 	mov	r6,r22
 820e1b0:	1009883a 	mov	r4,r2
 820e1b4:	8202f6c0 	call	8202f6c <memcpy>
 820e1b8:	8880030b 	ldhu	r2,12(r17)
 820e1bc:	00fedfc4 	movi	r3,-1153
 820e1c0:	10c4703a 	and	r2,r2,r3
 820e1c4:	10802014 	ori	r2,r2,128
 820e1c8:	8880030d 	sth	r2,12(r17)
 820e1cc:	a589883a 	add	r4,r20,r22
 820e1d0:	adadc83a 	sub	r22,r21,r22
 820e1d4:	8d400515 	stw	r21,20(r17)
 820e1d8:	8d800215 	stw	r22,8(r17)
 820e1dc:	8d000415 	stw	r20,16(r17)
 820e1e0:	89000015 	stw	r4,0(r17)
 820e1e4:	802b883a 	mov	r21,r16
 820e1e8:	802d883a 	mov	r22,r16
 820e1ec:	b00d883a 	mov	r6,r22
 820e1f0:	e00b883a 	mov	r5,fp
 820e1f4:	82030b40 	call	82030b4 <memmove>
 820e1f8:	88800217 	ldw	r2,8(r17)
 820e1fc:	89000017 	ldw	r4,0(r17)
 820e200:	90c00217 	ldw	r3,8(r18)
 820e204:	1545c83a 	sub	r2,r2,r21
 820e208:	2589883a 	add	r4,r4,r22
 820e20c:	88800215 	stw	r2,8(r17)
 820e210:	89000015 	stw	r4,0(r17)
 820e214:	1c21c83a 	sub	r16,r3,r16
 820e218:	94000215 	stw	r16,8(r18)
 820e21c:	80001726 	beq	r16,zero,820e27c <__ssprint_r+0x198>
 820e220:	bf000017 	ldw	fp,0(r23)
 820e224:	bc000117 	ldw	r16,4(r23)
 820e228:	bdc00204 	addi	r23,r23,8
 820e22c:	003fc206 	br	820e138 <__ssprint_r+0x54>
 820e230:	802b883a 	mov	r21,r16
 820e234:	802d883a 	mov	r22,r16
 820e238:	003fec06 	br	820e1ec <__ssprint_r+0x108>
 820e23c:	9809883a 	mov	r4,r19
 820e240:	820d6b00 	call	820d6b0 <_realloc_r>
 820e244:	1029883a 	mov	r20,r2
 820e248:	103fe01e 	bne	r2,zero,820e1cc <__ssprint_r+0xe8>
 820e24c:	89400417 	ldw	r5,16(r17)
 820e250:	9809883a 	mov	r4,r19
 820e254:	820b15c0 	call	820b15c <_free_r>
 820e258:	88c0030b 	ldhu	r3,12(r17)
 820e25c:	00800304 	movi	r2,12
 820e260:	98800015 	stw	r2,0(r19)
 820e264:	18c01014 	ori	r3,r3,64
 820e268:	88c0030d 	sth	r3,12(r17)
 820e26c:	00bfffc4 	movi	r2,-1
 820e270:	90000215 	stw	zero,8(r18)
 820e274:	90000115 	stw	zero,4(r18)
 820e278:	00000206 	br	820e284 <__ssprint_r+0x1a0>
 820e27c:	90000115 	stw	zero,4(r18)
 820e280:	0005883a 	mov	r2,zero
 820e284:	dfc00917 	ldw	ra,36(sp)
 820e288:	df000817 	ldw	fp,32(sp)
 820e28c:	ddc00717 	ldw	r23,28(sp)
 820e290:	dd800617 	ldw	r22,24(sp)
 820e294:	dd400517 	ldw	r21,20(sp)
 820e298:	dd000417 	ldw	r20,16(sp)
 820e29c:	dcc00317 	ldw	r19,12(sp)
 820e2a0:	dc800217 	ldw	r18,8(sp)
 820e2a4:	dc400117 	ldw	r17,4(sp)
 820e2a8:	dc000017 	ldw	r16,0(sp)
 820e2ac:	dec00a04 	addi	sp,sp,40
 820e2b0:	f800283a 	ret

0820e2b4 <___svfiprintf_internal_r>:
 820e2b4:	2880030b 	ldhu	r2,12(r5)
 820e2b8:	deffc804 	addi	sp,sp,-224
 820e2bc:	dcc03115 	stw	r19,196(sp)
 820e2c0:	dfc03715 	stw	ra,220(sp)
 820e2c4:	df003615 	stw	fp,216(sp)
 820e2c8:	ddc03515 	stw	r23,212(sp)
 820e2cc:	dd803415 	stw	r22,208(sp)
 820e2d0:	dd403315 	stw	r21,204(sp)
 820e2d4:	dd003215 	stw	r20,200(sp)
 820e2d8:	dc803015 	stw	r18,192(sp)
 820e2dc:	dc402f15 	stw	r17,188(sp)
 820e2e0:	dc002e15 	stw	r16,184(sp)
 820e2e4:	d9402715 	stw	r5,156(sp)
 820e2e8:	d9002a15 	stw	r4,168(sp)
 820e2ec:	1080200c 	andi	r2,r2,128
 820e2f0:	d9c02315 	stw	r7,140(sp)
 820e2f4:	3027883a 	mov	r19,r6
 820e2f8:	10000226 	beq	r2,zero,820e304 <___svfiprintf_internal_r+0x50>
 820e2fc:	28800417 	ldw	r2,16(r5)
 820e300:	10041d26 	beq	r2,zero,820f378 <___svfiprintf_internal_r+0x10c4>
 820e304:	dac01a04 	addi	r11,sp,104
 820e308:	dac01e15 	stw	r11,120(sp)
 820e30c:	d8801e17 	ldw	r2,120(sp)
 820e310:	dac019c4 	addi	r11,sp,103
 820e314:	dd402a17 	ldw	r21,168(sp)
 820e318:	ddc02717 	ldw	r23,156(sp)
 820e31c:	05820974 	movhi	r22,2085
 820e320:	05020974 	movhi	r20,2085
 820e324:	dac01f15 	stw	r11,124(sp)
 820e328:	12d7c83a 	sub	r11,r2,r11
 820e32c:	b5b75104 	addi	r22,r22,-8892
 820e330:	a5374d04 	addi	r20,r20,-8908
 820e334:	dec01a15 	stw	sp,104(sp)
 820e338:	d8001c15 	stw	zero,112(sp)
 820e33c:	d8001b15 	stw	zero,108(sp)
 820e340:	d811883a 	mov	r8,sp
 820e344:	d8002915 	stw	zero,164(sp)
 820e348:	d8002515 	stw	zero,148(sp)
 820e34c:	dac02b15 	stw	r11,172(sp)
 820e350:	98800007 	ldb	r2,0(r19)
 820e354:	1002dd26 	beq	r2,zero,820eecc <___svfiprintf_internal_r+0xc18>
 820e358:	00c00944 	movi	r3,37
 820e35c:	9823883a 	mov	r17,r19
 820e360:	10c0021e 	bne	r2,r3,820e36c <___svfiprintf_internal_r+0xb8>
 820e364:	00001406 	br	820e3b8 <___svfiprintf_internal_r+0x104>
 820e368:	10c00326 	beq	r2,r3,820e378 <___svfiprintf_internal_r+0xc4>
 820e36c:	8c400044 	addi	r17,r17,1
 820e370:	88800007 	ldb	r2,0(r17)
 820e374:	103ffc1e 	bne	r2,zero,820e368 <___svfiprintf_internal_r+0xb4>
 820e378:	8ce1c83a 	sub	r16,r17,r19
 820e37c:	80000e26 	beq	r16,zero,820e3b8 <___svfiprintf_internal_r+0x104>
 820e380:	d8c01c17 	ldw	r3,112(sp)
 820e384:	d8801b17 	ldw	r2,108(sp)
 820e388:	44c00015 	stw	r19,0(r8)
 820e38c:	1c07883a 	add	r3,r3,r16
 820e390:	10800044 	addi	r2,r2,1
 820e394:	d8c01c15 	stw	r3,112(sp)
 820e398:	44000115 	stw	r16,4(r8)
 820e39c:	d8801b15 	stw	r2,108(sp)
 820e3a0:	00c001c4 	movi	r3,7
 820e3a4:	18831e16 	blt	r3,r2,820f020 <___svfiprintf_internal_r+0xd6c>
 820e3a8:	42000204 	addi	r8,r8,8
 820e3ac:	dac02517 	ldw	r11,148(sp)
 820e3b0:	5c17883a 	add	r11,r11,r16
 820e3b4:	dac02515 	stw	r11,148(sp)
 820e3b8:	88800007 	ldb	r2,0(r17)
 820e3bc:	1002c526 	beq	r2,zero,820eed4 <___svfiprintf_internal_r+0xc20>
 820e3c0:	88c00047 	ldb	r3,1(r17)
 820e3c4:	8cc00044 	addi	r19,r17,1
 820e3c8:	d8001d85 	stb	zero,118(sp)
 820e3cc:	0009883a 	mov	r4,zero
 820e3d0:	000f883a 	mov	r7,zero
 820e3d4:	043fffc4 	movi	r16,-1
 820e3d8:	d8002415 	stw	zero,144(sp)
 820e3dc:	0025883a 	mov	r18,zero
 820e3e0:	01401604 	movi	r5,88
 820e3e4:	01800244 	movi	r6,9
 820e3e8:	02800a84 	movi	r10,42
 820e3ec:	02401b04 	movi	r9,108
 820e3f0:	9cc00044 	addi	r19,r19,1
 820e3f4:	18bff804 	addi	r2,r3,-32
 820e3f8:	2881dd36 	bltu	r5,r2,820eb70 <___svfiprintf_internal_r+0x8bc>
 820e3fc:	100490ba 	slli	r2,r2,2
 820e400:	02c20874 	movhi	r11,2081
 820e404:	5af90504 	addi	r11,r11,-7148
 820e408:	12c5883a 	add	r2,r2,r11
 820e40c:	10800017 	ldw	r2,0(r2)
 820e410:	1000683a 	jmp	r2
 820e414:	0820e610 	cmplti	zero,at,-31848
 820e418:	0820eb70 	cmpltui	zero,at,33709
 820e41c:	0820eb70 	cmpltui	zero,at,33709
 820e420:	0820e604 	addi	zero,at,-31848
 820e424:	0820eb70 	cmpltui	zero,at,33709
 820e428:	0820eb70 	cmpltui	zero,at,33709
 820e42c:	0820eb70 	cmpltui	zero,at,33709
 820e430:	0820eb70 	cmpltui	zero,at,33709
 820e434:	0820eb70 	cmpltui	zero,at,33709
 820e438:	0820eb70 	cmpltui	zero,at,33709
 820e43c:	0820e578 	rdprs	zero,at,-31851
 820e440:	0820e754 	ori	zero,at,33693
 820e444:	0820eb70 	cmpltui	zero,at,33709
 820e448:	0820e5a4 	muli	zero,at,-31850
 820e44c:	0820eba4 	muli	zero,at,-31826
 820e450:	0820eb70 	cmpltui	zero,at,33709
 820e454:	0820eb98 	cmpnei	zero,at,-31826
 820e458:	0820eb38 	rdprs	zero,at,-31828
 820e45c:	0820eb38 	rdprs	zero,at,-31828
 820e460:	0820eb38 	rdprs	zero,at,-31828
 820e464:	0820eb38 	rdprs	zero,at,-31828
 820e468:	0820eb38 	rdprs	zero,at,-31828
 820e46c:	0820eb38 	rdprs	zero,at,-31828
 820e470:	0820eb38 	rdprs	zero,at,-31828
 820e474:	0820eb38 	rdprs	zero,at,-31828
 820e478:	0820eb38 	rdprs	zero,at,-31828
 820e47c:	0820eb70 	cmpltui	zero,at,33709
 820e480:	0820eb70 	cmpltui	zero,at,33709
 820e484:	0820eb70 	cmpltui	zero,at,33709
 820e488:	0820eb70 	cmpltui	zero,at,33709
 820e48c:	0820eb70 	cmpltui	zero,at,33709
 820e490:	0820eb70 	cmpltui	zero,at,33709
 820e494:	0820eb70 	cmpltui	zero,at,33709
 820e498:	0820eb70 	cmpltui	zero,at,33709
 820e49c:	0820eb70 	cmpltui	zero,at,33709
 820e4a0:	0820eb70 	cmpltui	zero,at,33709
 820e4a4:	0820ead4 	ori	zero,at,33707
 820e4a8:	0820eb70 	cmpltui	zero,at,33709
 820e4ac:	0820eb70 	cmpltui	zero,at,33709
 820e4b0:	0820eb70 	cmpltui	zero,at,33709
 820e4b4:	0820eb70 	cmpltui	zero,at,33709
 820e4b8:	0820eb70 	cmpltui	zero,at,33709
 820e4bc:	0820eb70 	cmpltui	zero,at,33709
 820e4c0:	0820eb70 	cmpltui	zero,at,33709
 820e4c4:	0820eb70 	cmpltui	zero,at,33709
 820e4c8:	0820eb70 	cmpltui	zero,at,33709
 820e4cc:	0820eb70 	cmpltui	zero,at,33709
 820e4d0:	0820ec4c 	andi	zero,at,33713
 820e4d4:	0820eb70 	cmpltui	zero,at,33709
 820e4d8:	0820eb70 	cmpltui	zero,at,33709
 820e4dc:	0820eb70 	cmpltui	zero,at,33709
 820e4e0:	0820eb70 	cmpltui	zero,at,33709
 820e4e4:	0820eb70 	cmpltui	zero,at,33709
 820e4e8:	0820ebe4 	muli	zero,at,-31825
 820e4ec:	0820eb70 	cmpltui	zero,at,33709
 820e4f0:	0820eb70 	cmpltui	zero,at,33709
 820e4f4:	0820e918 	cmpnei	zero,at,-31836
 820e4f8:	0820eb70 	cmpltui	zero,at,33709
 820e4fc:	0820eb70 	cmpltui	zero,at,33709
 820e500:	0820eb70 	cmpltui	zero,at,33709
 820e504:	0820eb70 	cmpltui	zero,at,33709
 820e508:	0820eb70 	cmpltui	zero,at,33709
 820e50c:	0820eb70 	cmpltui	zero,at,33709
 820e510:	0820eb70 	cmpltui	zero,at,33709
 820e514:	0820eb70 	cmpltui	zero,at,33709
 820e518:	0820eb70 	cmpltui	zero,at,33709
 820e51c:	0820eb70 	cmpltui	zero,at,33709
 820e520:	0820e808 	cmpgei	zero,at,-31840
 820e524:	0820e9b4 	orhi	zero,at,33702
 820e528:	0820eb70 	cmpltui	zero,at,33709
 820e52c:	0820eb70 	cmpltui	zero,at,33709
 820e530:	0820eb70 	cmpltui	zero,at,33709
 820e534:	0820e9a8 	cmpgeui	zero,at,33702
 820e538:	0820e9b4 	orhi	zero,at,33702
 820e53c:	0820eb70 	cmpltui	zero,at,33709
 820e540:	0820eb70 	cmpltui	zero,at,33709
 820e544:	0820e998 	cmpnei	zero,at,-31834
 820e548:	0820eb70 	cmpltui	zero,at,33709
 820e54c:	0820e95c 	xori	zero,at,33701
 820e550:	0820e764 	muli	zero,at,-31843
 820e554:	0820e5b0 	cmpltui	zero,at,33686
 820e558:	0820eac8 	cmpgei	zero,at,-31829
 820e55c:	0820eb70 	cmpltui	zero,at,33709
 820e560:	0820ea7c 	xorhi	zero,at,33705
 820e564:	0820eb70 	cmpltui	zero,at,33709
 820e568:	0820e6d4 	ori	zero,at,33691
 820e56c:	0820eb70 	cmpltui	zero,at,33709
 820e570:	0820eb70 	cmpltui	zero,at,33709
 820e574:	0820e630 	cmpltui	zero,at,33688
 820e578:	dac02317 	ldw	r11,140(sp)
 820e57c:	5ac00017 	ldw	r11,0(r11)
 820e580:	dac02415 	stw	r11,144(sp)
 820e584:	dac02317 	ldw	r11,140(sp)
 820e588:	58800104 	addi	r2,r11,4
 820e58c:	dac02417 	ldw	r11,144(sp)
 820e590:	5802e90e 	bge	r11,zero,820f138 <___svfiprintf_internal_r+0xe84>
 820e594:	dac02417 	ldw	r11,144(sp)
 820e598:	d8802315 	stw	r2,140(sp)
 820e59c:	02d7c83a 	sub	r11,zero,r11
 820e5a0:	dac02415 	stw	r11,144(sp)
 820e5a4:	94800114 	ori	r18,r18,4
 820e5a8:	98c00007 	ldb	r3,0(r19)
 820e5ac:	003f9006 	br	820e3f0 <___svfiprintf_internal_r+0x13c>
 820e5b0:	00800c04 	movi	r2,48
 820e5b4:	dac02317 	ldw	r11,140(sp)
 820e5b8:	d8801d05 	stb	r2,116(sp)
 820e5bc:	00801e04 	movi	r2,120
 820e5c0:	d8801d45 	stb	r2,117(sp)
 820e5c4:	d8001d85 	stb	zero,118(sp)
 820e5c8:	58c00104 	addi	r3,r11,4
 820e5cc:	5f000017 	ldw	fp,0(r11)
 820e5d0:	0013883a 	mov	r9,zero
 820e5d4:	90800094 	ori	r2,r18,2
 820e5d8:	80032b16 	blt	r16,zero,820f288 <___svfiprintf_internal_r+0xfd4>
 820e5dc:	00bfdfc4 	movi	r2,-129
 820e5e0:	90a4703a 	and	r18,r18,r2
 820e5e4:	d8c02315 	stw	r3,140(sp)
 820e5e8:	94800094 	ori	r18,r18,2
 820e5ec:	e002dc26 	beq	fp,zero,820f160 <___svfiprintf_internal_r+0xeac>
 820e5f0:	01020974 	movhi	r4,2085
 820e5f4:	2136e504 	addi	r4,r4,-9324
 820e5f8:	0015883a 	mov	r10,zero
 820e5fc:	d9002915 	stw	r4,164(sp)
 820e600:	00002306 	br	820e690 <___svfiprintf_internal_r+0x3dc>
 820e604:	94800054 	ori	r18,r18,1
 820e608:	98c00007 	ldb	r3,0(r19)
 820e60c:	003f7806 	br	820e3f0 <___svfiprintf_internal_r+0x13c>
 820e610:	38803fcc 	andi	r2,r7,255
 820e614:	1080201c 	xori	r2,r2,128
 820e618:	10bfe004 	addi	r2,r2,-128
 820e61c:	1002f31e 	bne	r2,zero,820f1ec <___svfiprintf_internal_r+0xf38>
 820e620:	01000044 	movi	r4,1
 820e624:	01c00804 	movi	r7,32
 820e628:	98c00007 	ldb	r3,0(r19)
 820e62c:	003f7006 	br	820e3f0 <___svfiprintf_internal_r+0x13c>
 820e630:	21003fcc 	andi	r4,r4,255
 820e634:	2003aa1e 	bne	r4,zero,820f4e0 <___svfiprintf_internal_r+0x122c>
 820e638:	00820974 	movhi	r2,2085
 820e63c:	10b6e504 	addi	r2,r2,-9324
 820e640:	d8802915 	stw	r2,164(sp)
 820e644:	9080080c 	andi	r2,r18,32
 820e648:	1000ba26 	beq	r2,zero,820e934 <___svfiprintf_internal_r+0x680>
 820e64c:	dac02317 	ldw	r11,140(sp)
 820e650:	5f000017 	ldw	fp,0(r11)
 820e654:	5a400117 	ldw	r9,4(r11)
 820e658:	5ac00204 	addi	r11,r11,8
 820e65c:	dac02315 	stw	r11,140(sp)
 820e660:	9080004c 	andi	r2,r18,1
 820e664:	10029026 	beq	r2,zero,820f0a8 <___svfiprintf_internal_r+0xdf4>
 820e668:	e244b03a 	or	r2,fp,r9
 820e66c:	1002d41e 	bne	r2,zero,820f1c0 <___svfiprintf_internal_r+0xf0c>
 820e670:	d8001d85 	stb	zero,118(sp)
 820e674:	80030b16 	blt	r16,zero,820f2a4 <___svfiprintf_internal_r+0xff0>
 820e678:	00bfdfc4 	movi	r2,-129
 820e67c:	90a4703a 	and	r18,r18,r2
 820e680:	0015883a 	mov	r10,zero
 820e684:	80002426 	beq	r16,zero,820e718 <___svfiprintf_internal_r+0x464>
 820e688:	0039883a 	mov	fp,zero
 820e68c:	0013883a 	mov	r9,zero
 820e690:	d9002917 	ldw	r4,164(sp)
 820e694:	dc401a04 	addi	r17,sp,104
 820e698:	e08003cc 	andi	r2,fp,15
 820e69c:	4806973a 	slli	r3,r9,28
 820e6a0:	2085883a 	add	r2,r4,r2
 820e6a4:	e038d13a 	srli	fp,fp,4
 820e6a8:	10800003 	ldbu	r2,0(r2)
 820e6ac:	4812d13a 	srli	r9,r9,4
 820e6b0:	8c7fffc4 	addi	r17,r17,-1
 820e6b4:	1f38b03a 	or	fp,r3,fp
 820e6b8:	88800005 	stb	r2,0(r17)
 820e6bc:	e244b03a 	or	r2,fp,r9
 820e6c0:	103ff51e 	bne	r2,zero,820e698 <___svfiprintf_internal_r+0x3e4>
 820e6c4:	dac01e17 	ldw	r11,120(sp)
 820e6c8:	5c57c83a 	sub	r11,r11,r17
 820e6cc:	dac02115 	stw	r11,132(sp)
 820e6d0:	00001406 	br	820e724 <___svfiprintf_internal_r+0x470>
 820e6d4:	21003fcc 	andi	r4,r4,255
 820e6d8:	2003741e 	bne	r4,zero,820f4ac <___svfiprintf_internal_r+0x11f8>
 820e6dc:	9080080c 	andi	r2,r18,32
 820e6e0:	10014526 	beq	r2,zero,820ebf8 <___svfiprintf_internal_r+0x944>
 820e6e4:	dac02317 	ldw	r11,140(sp)
 820e6e8:	d8001d85 	stb	zero,118(sp)
 820e6ec:	58c00204 	addi	r3,r11,8
 820e6f0:	5f000017 	ldw	fp,0(r11)
 820e6f4:	5a400117 	ldw	r9,4(r11)
 820e6f8:	8002d916 	blt	r16,zero,820f260 <___svfiprintf_internal_r+0xfac>
 820e6fc:	013fdfc4 	movi	r4,-129
 820e700:	e244b03a 	or	r2,fp,r9
 820e704:	d8c02315 	stw	r3,140(sp)
 820e708:	9124703a 	and	r18,r18,r4
 820e70c:	0015883a 	mov	r10,zero
 820e710:	1000b91e 	bne	r2,zero,820e9f8 <___svfiprintf_internal_r+0x744>
 820e714:	8002e61e 	bne	r16,zero,820f2b0 <___svfiprintf_internal_r+0xffc>
 820e718:	0021883a 	mov	r16,zero
 820e71c:	d8002115 	stw	zero,132(sp)
 820e720:	dc401a04 	addi	r17,sp,104
 820e724:	d8c02117 	ldw	r3,132(sp)
 820e728:	dc002015 	stw	r16,128(sp)
 820e72c:	80c0010e 	bge	r16,r3,820e734 <___svfiprintf_internal_r+0x480>
 820e730:	d8c02015 	stw	r3,128(sp)
 820e734:	52803fcc 	andi	r10,r10,255
 820e738:	5280201c 	xori	r10,r10,128
 820e73c:	52bfe004 	addi	r10,r10,-128
 820e740:	50003c26 	beq	r10,zero,820e834 <___svfiprintf_internal_r+0x580>
 820e744:	dac02017 	ldw	r11,128(sp)
 820e748:	5ac00044 	addi	r11,r11,1
 820e74c:	dac02015 	stw	r11,128(sp)
 820e750:	00003806 	br	820e834 <___svfiprintf_internal_r+0x580>
 820e754:	01000044 	movi	r4,1
 820e758:	01c00ac4 	movi	r7,43
 820e75c:	98c00007 	ldb	r3,0(r19)
 820e760:	003f2306 	br	820e3f0 <___svfiprintf_internal_r+0x13c>
 820e764:	21003fcc 	andi	r4,r4,255
 820e768:	2003481e 	bne	r4,zero,820f48c <___svfiprintf_internal_r+0x11d8>
 820e76c:	9080080c 	andi	r2,r18,32
 820e770:	10013b26 	beq	r2,zero,820ec60 <___svfiprintf_internal_r+0x9ac>
 820e774:	dac02317 	ldw	r11,140(sp)
 820e778:	d8001d85 	stb	zero,118(sp)
 820e77c:	58800204 	addi	r2,r11,8
 820e780:	5f000017 	ldw	fp,0(r11)
 820e784:	5a400117 	ldw	r9,4(r11)
 820e788:	8002a816 	blt	r16,zero,820f22c <___svfiprintf_internal_r+0xf78>
 820e78c:	013fdfc4 	movi	r4,-129
 820e790:	e246b03a 	or	r3,fp,r9
 820e794:	d8802315 	stw	r2,140(sp)
 820e798:	9124703a 	and	r18,r18,r4
 820e79c:	18013c26 	beq	r3,zero,820ec90 <___svfiprintf_internal_r+0x9dc>
 820e7a0:	0015883a 	mov	r10,zero
 820e7a4:	dc401a04 	addi	r17,sp,104
 820e7a8:	e006d0fa 	srli	r3,fp,3
 820e7ac:	4808977a 	slli	r4,r9,29
 820e7b0:	4812d0fa 	srli	r9,r9,3
 820e7b4:	e70001cc 	andi	fp,fp,7
 820e7b8:	e0800c04 	addi	r2,fp,48
 820e7bc:	8c7fffc4 	addi	r17,r17,-1
 820e7c0:	20f8b03a 	or	fp,r4,r3
 820e7c4:	88800005 	stb	r2,0(r17)
 820e7c8:	e246b03a 	or	r3,fp,r9
 820e7cc:	183ff61e 	bne	r3,zero,820e7a8 <___svfiprintf_internal_r+0x4f4>
 820e7d0:	90c0004c 	andi	r3,r18,1
 820e7d4:	1800a526 	beq	r3,zero,820ea6c <___svfiprintf_internal_r+0x7b8>
 820e7d8:	10803fcc 	andi	r2,r2,255
 820e7dc:	1080201c 	xori	r2,r2,128
 820e7e0:	10bfe004 	addi	r2,r2,-128
 820e7e4:	00c00c04 	movi	r3,48
 820e7e8:	10ffb626 	beq	r2,r3,820e6c4 <___svfiprintf_internal_r+0x410>
 820e7ec:	88ffffc5 	stb	r3,-1(r17)
 820e7f0:	d8c01e17 	ldw	r3,120(sp)
 820e7f4:	88bfffc4 	addi	r2,r17,-1
 820e7f8:	1023883a 	mov	r17,r2
 820e7fc:	1887c83a 	sub	r3,r3,r2
 820e800:	d8c02115 	stw	r3,132(sp)
 820e804:	003fc706 	br	820e724 <___svfiprintf_internal_r+0x470>
 820e808:	dac02317 	ldw	r11,140(sp)
 820e80c:	00c00044 	movi	r3,1
 820e810:	d8c02015 	stw	r3,128(sp)
 820e814:	58800017 	ldw	r2,0(r11)
 820e818:	5ac00104 	addi	r11,r11,4
 820e81c:	d8001d85 	stb	zero,118(sp)
 820e820:	d8801005 	stb	r2,64(sp)
 820e824:	dac02315 	stw	r11,140(sp)
 820e828:	d8c02115 	stw	r3,132(sp)
 820e82c:	dc401004 	addi	r17,sp,64
 820e830:	0021883a 	mov	r16,zero
 820e834:	90c0008c 	andi	r3,r18,2
 820e838:	d8c02215 	stw	r3,136(sp)
 820e83c:	18000326 	beq	r3,zero,820e84c <___svfiprintf_internal_r+0x598>
 820e840:	dac02017 	ldw	r11,128(sp)
 820e844:	5ac00084 	addi	r11,r11,2
 820e848:	dac02015 	stw	r11,128(sp)
 820e84c:	90c0210c 	andi	r3,r18,132
 820e850:	d8c02615 	stw	r3,152(sp)
 820e854:	1801131e 	bne	r3,zero,820eca4 <___svfiprintf_internal_r+0x9f0>
 820e858:	dac02417 	ldw	r11,144(sp)
 820e85c:	d8c02017 	ldw	r3,128(sp)
 820e860:	58f9c83a 	sub	fp,r11,r3
 820e864:	07010f0e 	bge	zero,fp,820eca4 <___svfiprintf_internal_r+0x9f0>
 820e868:	02400404 	movi	r9,16
 820e86c:	d8c01c17 	ldw	r3,112(sp)
 820e870:	d8801b17 	ldw	r2,108(sp)
 820e874:	4f02d60e 	bge	r9,fp,820f3d0 <___svfiprintf_internal_r+0x111c>
 820e878:	01420974 	movhi	r5,2085
 820e87c:	29775104 	addi	r5,r5,-8892
 820e880:	d9402815 	stw	r5,160(sp)
 820e884:	028001c4 	movi	r10,7
 820e888:	00000306 	br	820e898 <___svfiprintf_internal_r+0x5e4>
 820e88c:	e73ffc04 	addi	fp,fp,-16
 820e890:	42000204 	addi	r8,r8,8
 820e894:	4f00150e 	bge	r9,fp,820e8ec <___svfiprintf_internal_r+0x638>
 820e898:	18c00404 	addi	r3,r3,16
 820e89c:	10800044 	addi	r2,r2,1
 820e8a0:	45800015 	stw	r22,0(r8)
 820e8a4:	42400115 	stw	r9,4(r8)
 820e8a8:	d8c01c15 	stw	r3,112(sp)
 820e8ac:	d8801b15 	stw	r2,108(sp)
 820e8b0:	50bff60e 	bge	r10,r2,820e88c <___svfiprintf_internal_r+0x5d8>
 820e8b4:	d9801a04 	addi	r6,sp,104
 820e8b8:	b80b883a 	mov	r5,r23
 820e8bc:	a809883a 	mov	r4,r21
 820e8c0:	da402c15 	stw	r9,176(sp)
 820e8c4:	da802d15 	stw	r10,180(sp)
 820e8c8:	820e0e40 	call	820e0e4 <__ssprint_r>
 820e8cc:	da402c17 	ldw	r9,176(sp)
 820e8d0:	da802d17 	ldw	r10,180(sp)
 820e8d4:	1001851e 	bne	r2,zero,820eeec <___svfiprintf_internal_r+0xc38>
 820e8d8:	e73ffc04 	addi	fp,fp,-16
 820e8dc:	d8c01c17 	ldw	r3,112(sp)
 820e8e0:	d8801b17 	ldw	r2,108(sp)
 820e8e4:	d811883a 	mov	r8,sp
 820e8e8:	4f3feb16 	blt	r9,fp,820e898 <___svfiprintf_internal_r+0x5e4>
 820e8ec:	dac02817 	ldw	r11,160(sp)
 820e8f0:	e0c7883a 	add	r3,fp,r3
 820e8f4:	10800044 	addi	r2,r2,1
 820e8f8:	42c00015 	stw	r11,0(r8)
 820e8fc:	47000115 	stw	fp,4(r8)
 820e900:	d8c01c15 	stw	r3,112(sp)
 820e904:	d8801b15 	stw	r2,108(sp)
 820e908:	010001c4 	movi	r4,7
 820e90c:	2081ee16 	blt	r4,r2,820f0c8 <___svfiprintf_internal_r+0xe14>
 820e910:	42000204 	addi	r8,r8,8
 820e914:	0000e506 	br	820ecac <___svfiprintf_internal_r+0x9f8>
 820e918:	21003fcc 	andi	r4,r4,255
 820e91c:	2002dd1e 	bne	r4,zero,820f494 <___svfiprintf_internal_r+0x11e0>
 820e920:	00820974 	movhi	r2,2085
 820e924:	10b6e004 	addi	r2,r2,-9344
 820e928:	d8802915 	stw	r2,164(sp)
 820e92c:	9080080c 	andi	r2,r18,32
 820e930:	103f461e 	bne	r2,zero,820e64c <___svfiprintf_internal_r+0x398>
 820e934:	9080040c 	andi	r2,r18,16
 820e938:	10022e1e 	bne	r2,zero,820f1f4 <___svfiprintf_internal_r+0xf40>
 820e93c:	9080100c 	andi	r2,r18,64
 820e940:	dac02317 	ldw	r11,140(sp)
 820e944:	10027326 	beq	r2,zero,820f314 <___svfiprintf_internal_r+0x1060>
 820e948:	5f00000b 	ldhu	fp,0(r11)
 820e94c:	5ac00104 	addi	r11,r11,4
 820e950:	0013883a 	mov	r9,zero
 820e954:	dac02315 	stw	r11,140(sp)
 820e958:	003f4106 	br	820e660 <___svfiprintf_internal_r+0x3ac>
 820e95c:	21003fcc 	andi	r4,r4,255
 820e960:	2002e11e 	bne	r4,zero,820f4e8 <___svfiprintf_internal_r+0x1234>
 820e964:	9080080c 	andi	r2,r18,32
 820e968:	1002011e 	bne	r2,zero,820f170 <___svfiprintf_internal_r+0xebc>
 820e96c:	9080040c 	andi	r2,r18,16
 820e970:	10023e1e 	bne	r2,zero,820f26c <___svfiprintf_internal_r+0xfb8>
 820e974:	9480100c 	andi	r18,r18,64
 820e978:	90023c26 	beq	r18,zero,820f26c <___svfiprintf_internal_r+0xfb8>
 820e97c:	dac02317 	ldw	r11,140(sp)
 820e980:	58800017 	ldw	r2,0(r11)
 820e984:	5ac00104 	addi	r11,r11,4
 820e988:	dac02315 	stw	r11,140(sp)
 820e98c:	dac02517 	ldw	r11,148(sp)
 820e990:	12c0000d 	sth	r11,0(r2)
 820e994:	003e6e06 	br	820e350 <___svfiprintf_internal_r+0x9c>
 820e998:	98c00007 	ldb	r3,0(r19)
 820e99c:	1a422926 	beq	r3,r9,820f244 <___svfiprintf_internal_r+0xf90>
 820e9a0:	94800414 	ori	r18,r18,16
 820e9a4:	003e9206 	br	820e3f0 <___svfiprintf_internal_r+0x13c>
 820e9a8:	94801014 	ori	r18,r18,64
 820e9ac:	98c00007 	ldb	r3,0(r19)
 820e9b0:	003e8f06 	br	820e3f0 <___svfiprintf_internal_r+0x13c>
 820e9b4:	21003fcc 	andi	r4,r4,255
 820e9b8:	2002c71e 	bne	r4,zero,820f4d8 <___svfiprintf_internal_r+0x1224>
 820e9bc:	9080080c 	andi	r2,r18,32
 820e9c0:	10004926 	beq	r2,zero,820eae8 <___svfiprintf_internal_r+0x834>
 820e9c4:	dac02317 	ldw	r11,140(sp)
 820e9c8:	58800117 	ldw	r2,4(r11)
 820e9cc:	5f000017 	ldw	fp,0(r11)
 820e9d0:	5ac00204 	addi	r11,r11,8
 820e9d4:	dac02315 	stw	r11,140(sp)
 820e9d8:	1013883a 	mov	r9,r2
 820e9dc:	10004b16 	blt	r2,zero,820eb0c <___svfiprintf_internal_r+0x858>
 820e9e0:	da801d83 	ldbu	r10,118(sp)
 820e9e4:	8001cb16 	blt	r16,zero,820f114 <___svfiprintf_internal_r+0xe60>
 820e9e8:	00ffdfc4 	movi	r3,-129
 820e9ec:	e244b03a 	or	r2,fp,r9
 820e9f0:	90e4703a 	and	r18,r18,r3
 820e9f4:	103f4726 	beq	r2,zero,820e714 <___svfiprintf_internal_r+0x460>
 820e9f8:	48008c26 	beq	r9,zero,820ec2c <___svfiprintf_internal_r+0x978>
 820e9fc:	dc802015 	stw	r18,128(sp)
 820ea00:	dc002115 	stw	r16,132(sp)
 820ea04:	dc401a04 	addi	r17,sp,104
 820ea08:	e021883a 	mov	r16,fp
 820ea0c:	da002215 	stw	r8,136(sp)
 820ea10:	5039883a 	mov	fp,r10
 820ea14:	4825883a 	mov	r18,r9
 820ea18:	8009883a 	mov	r4,r16
 820ea1c:	900b883a 	mov	r5,r18
 820ea20:	01800284 	movi	r6,10
 820ea24:	000f883a 	mov	r7,zero
 820ea28:	821188c0 	call	821188c <__umoddi3>
 820ea2c:	10800c04 	addi	r2,r2,48
 820ea30:	8c7fffc4 	addi	r17,r17,-1
 820ea34:	8009883a 	mov	r4,r16
 820ea38:	900b883a 	mov	r5,r18
 820ea3c:	88800005 	stb	r2,0(r17)
 820ea40:	01800284 	movi	r6,10
 820ea44:	000f883a 	mov	r7,zero
 820ea48:	82113140 	call	8211314 <__udivdi3>
 820ea4c:	1021883a 	mov	r16,r2
 820ea50:	10c4b03a 	or	r2,r2,r3
 820ea54:	1825883a 	mov	r18,r3
 820ea58:	103fef1e 	bne	r2,zero,820ea18 <___svfiprintf_internal_r+0x764>
 820ea5c:	dc802017 	ldw	r18,128(sp)
 820ea60:	dc002117 	ldw	r16,132(sp)
 820ea64:	da002217 	ldw	r8,136(sp)
 820ea68:	e015883a 	mov	r10,fp
 820ea6c:	d8c01e17 	ldw	r3,120(sp)
 820ea70:	1c47c83a 	sub	r3,r3,r17
 820ea74:	d8c02115 	stw	r3,132(sp)
 820ea78:	003f2a06 	br	820e724 <___svfiprintf_internal_r+0x470>
 820ea7c:	dac02317 	ldw	r11,140(sp)
 820ea80:	d8001d85 	stb	zero,118(sp)
 820ea84:	5c400017 	ldw	r17,0(r11)
 820ea88:	5f000104 	addi	fp,r11,4
 820ea8c:	88022f26 	beq	r17,zero,820f34c <___svfiprintf_internal_r+0x1098>
 820ea90:	80022516 	blt	r16,zero,820f328 <___svfiprintf_internal_r+0x1074>
 820ea94:	800d883a 	mov	r6,r16
 820ea98:	000b883a 	mov	r5,zero
 820ea9c:	8809883a 	mov	r4,r17
 820eaa0:	da002c15 	stw	r8,176(sp)
 820eaa4:	820c5540 	call	820c554 <memchr>
 820eaa8:	da002c17 	ldw	r8,176(sp)
 820eaac:	10026426 	beq	r2,zero,820f440 <___svfiprintf_internal_r+0x118c>
 820eab0:	1445c83a 	sub	r2,r2,r17
 820eab4:	d8802115 	stw	r2,132(sp)
 820eab8:	da801d83 	ldbu	r10,118(sp)
 820eabc:	df002315 	stw	fp,140(sp)
 820eac0:	0021883a 	mov	r16,zero
 820eac4:	003f1706 	br	820e724 <___svfiprintf_internal_r+0x470>
 820eac8:	94800814 	ori	r18,r18,32
 820eacc:	98c00007 	ldb	r3,0(r19)
 820ead0:	003e4706 	br	820e3f0 <___svfiprintf_internal_r+0x13c>
 820ead4:	21003fcc 	andi	r4,r4,255
 820ead8:	2002701e 	bne	r4,zero,820f49c <___svfiprintf_internal_r+0x11e8>
 820eadc:	94800414 	ori	r18,r18,16
 820eae0:	9080080c 	andi	r2,r18,32
 820eae4:	103fb71e 	bne	r2,zero,820e9c4 <___svfiprintf_internal_r+0x710>
 820eae8:	9080040c 	andi	r2,r18,16
 820eaec:	1001ab26 	beq	r2,zero,820f19c <___svfiprintf_internal_r+0xee8>
 820eaf0:	dac02317 	ldw	r11,140(sp)
 820eaf4:	5f000017 	ldw	fp,0(r11)
 820eaf8:	5ac00104 	addi	r11,r11,4
 820eafc:	dac02315 	stw	r11,140(sp)
 820eb00:	e013d7fa 	srai	r9,fp,31
 820eb04:	4805883a 	mov	r2,r9
 820eb08:	103fb50e 	bge	r2,zero,820e9e0 <___svfiprintf_internal_r+0x72c>
 820eb0c:	0739c83a 	sub	fp,zero,fp
 820eb10:	02800b44 	movi	r10,45
 820eb14:	e004c03a 	cmpne	r2,fp,zero
 820eb18:	0253c83a 	sub	r9,zero,r9
 820eb1c:	da801d85 	stb	r10,118(sp)
 820eb20:	4893c83a 	sub	r9,r9,r2
 820eb24:	80023016 	blt	r16,zero,820f3e8 <___svfiprintf_internal_r+0x1134>
 820eb28:	00bfdfc4 	movi	r2,-129
 820eb2c:	90a4703a 	and	r18,r18,r2
 820eb30:	483fb21e 	bne	r9,zero,820e9fc <___svfiprintf_internal_r+0x748>
 820eb34:	00003d06 	br	820ec2c <___svfiprintf_internal_r+0x978>
 820eb38:	9817883a 	mov	r11,r19
 820eb3c:	d8002415 	stw	zero,144(sp)
 820eb40:	18bff404 	addi	r2,r3,-48
 820eb44:	0019883a 	mov	r12,zero
 820eb48:	58c00007 	ldb	r3,0(r11)
 820eb4c:	630002a4 	muli	r12,r12,10
 820eb50:	9cc00044 	addi	r19,r19,1
 820eb54:	9817883a 	mov	r11,r19
 820eb58:	1319883a 	add	r12,r2,r12
 820eb5c:	18bff404 	addi	r2,r3,-48
 820eb60:	30bff92e 	bgeu	r6,r2,820eb48 <___svfiprintf_internal_r+0x894>
 820eb64:	db002415 	stw	r12,144(sp)
 820eb68:	18bff804 	addi	r2,r3,-32
 820eb6c:	28be232e 	bgeu	r5,r2,820e3fc <___svfiprintf_internal_r+0x148>
 820eb70:	21003fcc 	andi	r4,r4,255
 820eb74:	20024b1e 	bne	r4,zero,820f4a4 <___svfiprintf_internal_r+0x11f0>
 820eb78:	1800d626 	beq	r3,zero,820eed4 <___svfiprintf_internal_r+0xc20>
 820eb7c:	02c00044 	movi	r11,1
 820eb80:	dac02015 	stw	r11,128(sp)
 820eb84:	d8c01005 	stb	r3,64(sp)
 820eb88:	d8001d85 	stb	zero,118(sp)
 820eb8c:	dac02115 	stw	r11,132(sp)
 820eb90:	dc401004 	addi	r17,sp,64
 820eb94:	003f2606 	br	820e830 <___svfiprintf_internal_r+0x57c>
 820eb98:	94802014 	ori	r18,r18,128
 820eb9c:	98c00007 	ldb	r3,0(r19)
 820eba0:	003e1306 	br	820e3f0 <___svfiprintf_internal_r+0x13c>
 820eba4:	98c00007 	ldb	r3,0(r19)
 820eba8:	9ac00044 	addi	r11,r19,1
 820ebac:	1a822b26 	beq	r3,r10,820f45c <___svfiprintf_internal_r+0x11a8>
 820ebb0:	18bff404 	addi	r2,r3,-48
 820ebb4:	0021883a 	mov	r16,zero
 820ebb8:	30821e36 	bltu	r6,r2,820f434 <___svfiprintf_internal_r+0x1180>
 820ebbc:	58c00007 	ldb	r3,0(r11)
 820ebc0:	840002a4 	muli	r16,r16,10
 820ebc4:	5cc00044 	addi	r19,r11,1
 820ebc8:	9817883a 	mov	r11,r19
 820ebcc:	80a1883a 	add	r16,r16,r2
 820ebd0:	18bff404 	addi	r2,r3,-48
 820ebd4:	30bff92e 	bgeu	r6,r2,820ebbc <___svfiprintf_internal_r+0x908>
 820ebd8:	803e060e 	bge	r16,zero,820e3f4 <___svfiprintf_internal_r+0x140>
 820ebdc:	043fffc4 	movi	r16,-1
 820ebe0:	003e0406 	br	820e3f4 <___svfiprintf_internal_r+0x140>
 820ebe4:	21003fcc 	andi	r4,r4,255
 820ebe8:	2002371e 	bne	r4,zero,820f4c8 <___svfiprintf_internal_r+0x1214>
 820ebec:	94800414 	ori	r18,r18,16
 820ebf0:	9080080c 	andi	r2,r18,32
 820ebf4:	103ebb1e 	bne	r2,zero,820e6e4 <___svfiprintf_internal_r+0x430>
 820ebf8:	9080040c 	andi	r2,r18,16
 820ebfc:	10013b26 	beq	r2,zero,820f0ec <___svfiprintf_internal_r+0xe38>
 820ec00:	dac02317 	ldw	r11,140(sp)
 820ec04:	d8001d85 	stb	zero,118(sp)
 820ec08:	0013883a 	mov	r9,zero
 820ec0c:	58800104 	addi	r2,r11,4
 820ec10:	5f000017 	ldw	fp,0(r11)
 820ec14:	80013d16 	blt	r16,zero,820f10c <___svfiprintf_internal_r+0xe58>
 820ec18:	00ffdfc4 	movi	r3,-129
 820ec1c:	d8802315 	stw	r2,140(sp)
 820ec20:	90e4703a 	and	r18,r18,r3
 820ec24:	0015883a 	mov	r10,zero
 820ec28:	e03eba26 	beq	fp,zero,820e714 <___svfiprintf_internal_r+0x460>
 820ec2c:	00800244 	movi	r2,9
 820ec30:	173f7236 	bltu	r2,fp,820e9fc <___svfiprintf_internal_r+0x748>
 820ec34:	dac02b17 	ldw	r11,172(sp)
 820ec38:	e7000c04 	addi	fp,fp,48
 820ec3c:	df0019c5 	stb	fp,103(sp)
 820ec40:	dac02115 	stw	r11,132(sp)
 820ec44:	dc4019c4 	addi	r17,sp,103
 820ec48:	003eb606 	br	820e724 <___svfiprintf_internal_r+0x470>
 820ec4c:	21003fcc 	andi	r4,r4,255
 820ec50:	20021f1e 	bne	r4,zero,820f4d0 <___svfiprintf_internal_r+0x121c>
 820ec54:	94800414 	ori	r18,r18,16
 820ec58:	9080080c 	andi	r2,r18,32
 820ec5c:	103ec51e 	bne	r2,zero,820e774 <___svfiprintf_internal_r+0x4c0>
 820ec60:	9080040c 	andi	r2,r18,16
 820ec64:	10016926 	beq	r2,zero,820f20c <___svfiprintf_internal_r+0xf58>
 820ec68:	dac02317 	ldw	r11,140(sp)
 820ec6c:	d8001d85 	stb	zero,118(sp)
 820ec70:	0013883a 	mov	r9,zero
 820ec74:	58800104 	addi	r2,r11,4
 820ec78:	5f000017 	ldw	fp,0(r11)
 820ec7c:	80016b16 	blt	r16,zero,820f22c <___svfiprintf_internal_r+0xf78>
 820ec80:	00ffdfc4 	movi	r3,-129
 820ec84:	d8802315 	stw	r2,140(sp)
 820ec88:	90e4703a 	and	r18,r18,r3
 820ec8c:	e03ec41e 	bne	fp,zero,820e7a0 <___svfiprintf_internal_r+0x4ec>
 820ec90:	0015883a 	mov	r10,zero
 820ec94:	8001c226 	beq	r16,zero,820f3a0 <___svfiprintf_internal_r+0x10ec>
 820ec98:	0039883a 	mov	fp,zero
 820ec9c:	0013883a 	mov	r9,zero
 820eca0:	003ec006 	br	820e7a4 <___svfiprintf_internal_r+0x4f0>
 820eca4:	d8c01c17 	ldw	r3,112(sp)
 820eca8:	d8801b17 	ldw	r2,108(sp)
 820ecac:	d9001d87 	ldb	r4,118(sp)
 820ecb0:	20000b26 	beq	r4,zero,820ece0 <___svfiprintf_internal_r+0xa2c>
 820ecb4:	d9001d84 	addi	r4,sp,118
 820ecb8:	18c00044 	addi	r3,r3,1
 820ecbc:	10800044 	addi	r2,r2,1
 820ecc0:	41000015 	stw	r4,0(r8)
 820ecc4:	01000044 	movi	r4,1
 820ecc8:	41000115 	stw	r4,4(r8)
 820eccc:	d8c01c15 	stw	r3,112(sp)
 820ecd0:	d8801b15 	stw	r2,108(sp)
 820ecd4:	010001c4 	movi	r4,7
 820ecd8:	2080e116 	blt	r4,r2,820f060 <___svfiprintf_internal_r+0xdac>
 820ecdc:	42000204 	addi	r8,r8,8
 820ece0:	dac02217 	ldw	r11,136(sp)
 820ece4:	58000b26 	beq	r11,zero,820ed14 <___svfiprintf_internal_r+0xa60>
 820ece8:	d9001d04 	addi	r4,sp,116
 820ecec:	18c00084 	addi	r3,r3,2
 820ecf0:	10800044 	addi	r2,r2,1
 820ecf4:	41000015 	stw	r4,0(r8)
 820ecf8:	01000084 	movi	r4,2
 820ecfc:	41000115 	stw	r4,4(r8)
 820ed00:	d8c01c15 	stw	r3,112(sp)
 820ed04:	d8801b15 	stw	r2,108(sp)
 820ed08:	010001c4 	movi	r4,7
 820ed0c:	2080dd16 	blt	r4,r2,820f084 <___svfiprintf_internal_r+0xdd0>
 820ed10:	42000204 	addi	r8,r8,8
 820ed14:	dac02617 	ldw	r11,152(sp)
 820ed18:	01002004 	movi	r4,128
 820ed1c:	59008426 	beq	r11,r4,820ef30 <___svfiprintf_internal_r+0xc7c>
 820ed20:	dac02117 	ldw	r11,132(sp)
 820ed24:	82e1c83a 	sub	r16,r16,r11
 820ed28:	0400270e 	bge	zero,r16,820edc8 <___svfiprintf_internal_r+0xb14>
 820ed2c:	01c00404 	movi	r7,16
 820ed30:	3c016a0e 	bge	r7,r16,820f2dc <___svfiprintf_internal_r+0x1028>
 820ed34:	01420974 	movhi	r5,2085
 820ed38:	29774d04 	addi	r5,r5,-8908
 820ed3c:	d9402215 	stw	r5,136(sp)
 820ed40:	070001c4 	movi	fp,7
 820ed44:	00000306 	br	820ed54 <___svfiprintf_internal_r+0xaa0>
 820ed48:	843ffc04 	addi	r16,r16,-16
 820ed4c:	42000204 	addi	r8,r8,8
 820ed50:	3c00130e 	bge	r7,r16,820eda0 <___svfiprintf_internal_r+0xaec>
 820ed54:	18c00404 	addi	r3,r3,16
 820ed58:	10800044 	addi	r2,r2,1
 820ed5c:	45000015 	stw	r20,0(r8)
 820ed60:	41c00115 	stw	r7,4(r8)
 820ed64:	d8c01c15 	stw	r3,112(sp)
 820ed68:	d8801b15 	stw	r2,108(sp)
 820ed6c:	e0bff60e 	bge	fp,r2,820ed48 <___svfiprintf_internal_r+0xa94>
 820ed70:	d9801a04 	addi	r6,sp,104
 820ed74:	b80b883a 	mov	r5,r23
 820ed78:	a809883a 	mov	r4,r21
 820ed7c:	d9c02c15 	stw	r7,176(sp)
 820ed80:	820e0e40 	call	820e0e4 <__ssprint_r>
 820ed84:	d9c02c17 	ldw	r7,176(sp)
 820ed88:	1000581e 	bne	r2,zero,820eeec <___svfiprintf_internal_r+0xc38>
 820ed8c:	843ffc04 	addi	r16,r16,-16
 820ed90:	d8c01c17 	ldw	r3,112(sp)
 820ed94:	d8801b17 	ldw	r2,108(sp)
 820ed98:	d811883a 	mov	r8,sp
 820ed9c:	3c3fed16 	blt	r7,r16,820ed54 <___svfiprintf_internal_r+0xaa0>
 820eda0:	dac02217 	ldw	r11,136(sp)
 820eda4:	1c07883a 	add	r3,r3,r16
 820eda8:	10800044 	addi	r2,r2,1
 820edac:	42c00015 	stw	r11,0(r8)
 820edb0:	44000115 	stw	r16,4(r8)
 820edb4:	d8c01c15 	stw	r3,112(sp)
 820edb8:	d8801b15 	stw	r2,108(sp)
 820edbc:	010001c4 	movi	r4,7
 820edc0:	20809e16 	blt	r4,r2,820f03c <___svfiprintf_internal_r+0xd88>
 820edc4:	42000204 	addi	r8,r8,8
 820edc8:	dac02117 	ldw	r11,132(sp)
 820edcc:	10800044 	addi	r2,r2,1
 820edd0:	44400015 	stw	r17,0(r8)
 820edd4:	58c7883a 	add	r3,r11,r3
 820edd8:	42c00115 	stw	r11,4(r8)
 820eddc:	d8c01c15 	stw	r3,112(sp)
 820ede0:	d8801b15 	stw	r2,108(sp)
 820ede4:	010001c4 	movi	r4,7
 820ede8:	20807f16 	blt	r4,r2,820efe8 <___svfiprintf_internal_r+0xd34>
 820edec:	42000204 	addi	r8,r8,8
 820edf0:	9480010c 	andi	r18,r18,4
 820edf4:	90002926 	beq	r18,zero,820ee9c <___svfiprintf_internal_r+0xbe8>
 820edf8:	dac02417 	ldw	r11,144(sp)
 820edfc:	d8802017 	ldw	r2,128(sp)
 820ee00:	58a1c83a 	sub	r16,r11,r2
 820ee04:	0400250e 	bge	zero,r16,820ee9c <___svfiprintf_internal_r+0xbe8>
 820ee08:	04400404 	movi	r17,16
 820ee0c:	d8801b17 	ldw	r2,108(sp)
 820ee10:	8c017c0e 	bge	r17,r16,820f404 <___svfiprintf_internal_r+0x1150>
 820ee14:	01420974 	movhi	r5,2085
 820ee18:	29775104 	addi	r5,r5,-8892
 820ee1c:	d9402815 	stw	r5,160(sp)
 820ee20:	048001c4 	movi	r18,7
 820ee24:	00000306 	br	820ee34 <___svfiprintf_internal_r+0xb80>
 820ee28:	843ffc04 	addi	r16,r16,-16
 820ee2c:	42000204 	addi	r8,r8,8
 820ee30:	8c00110e 	bge	r17,r16,820ee78 <___svfiprintf_internal_r+0xbc4>
 820ee34:	18c00404 	addi	r3,r3,16
 820ee38:	10800044 	addi	r2,r2,1
 820ee3c:	45800015 	stw	r22,0(r8)
 820ee40:	44400115 	stw	r17,4(r8)
 820ee44:	d8c01c15 	stw	r3,112(sp)
 820ee48:	d8801b15 	stw	r2,108(sp)
 820ee4c:	90bff60e 	bge	r18,r2,820ee28 <___svfiprintf_internal_r+0xb74>
 820ee50:	d9801a04 	addi	r6,sp,104
 820ee54:	b80b883a 	mov	r5,r23
 820ee58:	a809883a 	mov	r4,r21
 820ee5c:	820e0e40 	call	820e0e4 <__ssprint_r>
 820ee60:	1000221e 	bne	r2,zero,820eeec <___svfiprintf_internal_r+0xc38>
 820ee64:	843ffc04 	addi	r16,r16,-16
 820ee68:	d8c01c17 	ldw	r3,112(sp)
 820ee6c:	d8801b17 	ldw	r2,108(sp)
 820ee70:	d811883a 	mov	r8,sp
 820ee74:	8c3fef16 	blt	r17,r16,820ee34 <___svfiprintf_internal_r+0xb80>
 820ee78:	dac02817 	ldw	r11,160(sp)
 820ee7c:	1c07883a 	add	r3,r3,r16
 820ee80:	10800044 	addi	r2,r2,1
 820ee84:	42c00015 	stw	r11,0(r8)
 820ee88:	44000115 	stw	r16,4(r8)
 820ee8c:	d8c01c15 	stw	r3,112(sp)
 820ee90:	d8801b15 	stw	r2,108(sp)
 820ee94:	010001c4 	movi	r4,7
 820ee98:	2080aa16 	blt	r4,r2,820f144 <___svfiprintf_internal_r+0xe90>
 820ee9c:	d8802417 	ldw	r2,144(sp)
 820eea0:	dac02017 	ldw	r11,128(sp)
 820eea4:	12c0010e 	bge	r2,r11,820eeac <___svfiprintf_internal_r+0xbf8>
 820eea8:	5805883a 	mov	r2,r11
 820eeac:	dac02517 	ldw	r11,148(sp)
 820eeb0:	5897883a 	add	r11,r11,r2
 820eeb4:	dac02515 	stw	r11,148(sp)
 820eeb8:	1800531e 	bne	r3,zero,820f008 <___svfiprintf_internal_r+0xd54>
 820eebc:	98800007 	ldb	r2,0(r19)
 820eec0:	d8001b15 	stw	zero,108(sp)
 820eec4:	d811883a 	mov	r8,sp
 820eec8:	103d231e 	bne	r2,zero,820e358 <___svfiprintf_internal_r+0xa4>
 820eecc:	9823883a 	mov	r17,r19
 820eed0:	003d3906 	br	820e3b8 <___svfiprintf_internal_r+0x104>
 820eed4:	d8801c17 	ldw	r2,112(sp)
 820eed8:	10000426 	beq	r2,zero,820eeec <___svfiprintf_internal_r+0xc38>
 820eedc:	d9402717 	ldw	r5,156(sp)
 820eee0:	d9002a17 	ldw	r4,168(sp)
 820eee4:	d9801a04 	addi	r6,sp,104
 820eee8:	820e0e40 	call	820e0e4 <__ssprint_r>
 820eeec:	dac02717 	ldw	r11,156(sp)
 820eef0:	d8802517 	ldw	r2,148(sp)
 820eef4:	58c0030b 	ldhu	r3,12(r11)
 820eef8:	18c0100c 	andi	r3,r3,64
 820eefc:	1801381e 	bne	r3,zero,820f3e0 <___svfiprintf_internal_r+0x112c>
 820ef00:	dfc03717 	ldw	ra,220(sp)
 820ef04:	df003617 	ldw	fp,216(sp)
 820ef08:	ddc03517 	ldw	r23,212(sp)
 820ef0c:	dd803417 	ldw	r22,208(sp)
 820ef10:	dd403317 	ldw	r21,204(sp)
 820ef14:	dd003217 	ldw	r20,200(sp)
 820ef18:	dcc03117 	ldw	r19,196(sp)
 820ef1c:	dc803017 	ldw	r18,192(sp)
 820ef20:	dc402f17 	ldw	r17,188(sp)
 820ef24:	dc002e17 	ldw	r16,184(sp)
 820ef28:	dec03804 	addi	sp,sp,224
 820ef2c:	f800283a 	ret
 820ef30:	dac02417 	ldw	r11,144(sp)
 820ef34:	d9002017 	ldw	r4,128(sp)
 820ef38:	5939c83a 	sub	fp,r11,r4
 820ef3c:	073f780e 	bge	zero,fp,820ed20 <___svfiprintf_internal_r+0xa6c>
 820ef40:	02400404 	movi	r9,16
 820ef44:	4f01370e 	bge	r9,fp,820f424 <___svfiprintf_internal_r+0x1170>
 820ef48:	02c20974 	movhi	r11,2085
 820ef4c:	5af74d04 	addi	r11,r11,-8908
 820ef50:	dac02215 	stw	r11,136(sp)
 820ef54:	028001c4 	movi	r10,7
 820ef58:	00000306 	br	820ef68 <___svfiprintf_internal_r+0xcb4>
 820ef5c:	e73ffc04 	addi	fp,fp,-16
 820ef60:	42000204 	addi	r8,r8,8
 820ef64:	4f00150e 	bge	r9,fp,820efbc <___svfiprintf_internal_r+0xd08>
 820ef68:	18c00404 	addi	r3,r3,16
 820ef6c:	10800044 	addi	r2,r2,1
 820ef70:	45000015 	stw	r20,0(r8)
 820ef74:	42400115 	stw	r9,4(r8)
 820ef78:	d8c01c15 	stw	r3,112(sp)
 820ef7c:	d8801b15 	stw	r2,108(sp)
 820ef80:	50bff60e 	bge	r10,r2,820ef5c <___svfiprintf_internal_r+0xca8>
 820ef84:	d9801a04 	addi	r6,sp,104
 820ef88:	b80b883a 	mov	r5,r23
 820ef8c:	a809883a 	mov	r4,r21
 820ef90:	da402c15 	stw	r9,176(sp)
 820ef94:	da802d15 	stw	r10,180(sp)
 820ef98:	820e0e40 	call	820e0e4 <__ssprint_r>
 820ef9c:	da402c17 	ldw	r9,176(sp)
 820efa0:	da802d17 	ldw	r10,180(sp)
 820efa4:	103fd11e 	bne	r2,zero,820eeec <___svfiprintf_internal_r+0xc38>
 820efa8:	e73ffc04 	addi	fp,fp,-16
 820efac:	d8c01c17 	ldw	r3,112(sp)
 820efb0:	d8801b17 	ldw	r2,108(sp)
 820efb4:	d811883a 	mov	r8,sp
 820efb8:	4f3feb16 	blt	r9,fp,820ef68 <___svfiprintf_internal_r+0xcb4>
 820efbc:	dac02217 	ldw	r11,136(sp)
 820efc0:	1f07883a 	add	r3,r3,fp
 820efc4:	10800044 	addi	r2,r2,1
 820efc8:	42c00015 	stw	r11,0(r8)
 820efcc:	47000115 	stw	fp,4(r8)
 820efd0:	d8c01c15 	stw	r3,112(sp)
 820efd4:	d8801b15 	stw	r2,108(sp)
 820efd8:	010001c4 	movi	r4,7
 820efdc:	2080b616 	blt	r4,r2,820f2b8 <___svfiprintf_internal_r+0x1004>
 820efe0:	42000204 	addi	r8,r8,8
 820efe4:	003f4e06 	br	820ed20 <___svfiprintf_internal_r+0xa6c>
 820efe8:	d9801a04 	addi	r6,sp,104
 820efec:	b80b883a 	mov	r5,r23
 820eff0:	a809883a 	mov	r4,r21
 820eff4:	820e0e40 	call	820e0e4 <__ssprint_r>
 820eff8:	103fbc1e 	bne	r2,zero,820eeec <___svfiprintf_internal_r+0xc38>
 820effc:	d8c01c17 	ldw	r3,112(sp)
 820f000:	d811883a 	mov	r8,sp
 820f004:	003f7a06 	br	820edf0 <___svfiprintf_internal_r+0xb3c>
 820f008:	d9801a04 	addi	r6,sp,104
 820f00c:	b80b883a 	mov	r5,r23
 820f010:	a809883a 	mov	r4,r21
 820f014:	820e0e40 	call	820e0e4 <__ssprint_r>
 820f018:	103fa826 	beq	r2,zero,820eebc <___svfiprintf_internal_r+0xc08>
 820f01c:	003fb306 	br	820eeec <___svfiprintf_internal_r+0xc38>
 820f020:	d9801a04 	addi	r6,sp,104
 820f024:	b80b883a 	mov	r5,r23
 820f028:	a809883a 	mov	r4,r21
 820f02c:	820e0e40 	call	820e0e4 <__ssprint_r>
 820f030:	103fae1e 	bne	r2,zero,820eeec <___svfiprintf_internal_r+0xc38>
 820f034:	d811883a 	mov	r8,sp
 820f038:	003cdc06 	br	820e3ac <___svfiprintf_internal_r+0xf8>
 820f03c:	d9801a04 	addi	r6,sp,104
 820f040:	b80b883a 	mov	r5,r23
 820f044:	a809883a 	mov	r4,r21
 820f048:	820e0e40 	call	820e0e4 <__ssprint_r>
 820f04c:	103fa71e 	bne	r2,zero,820eeec <___svfiprintf_internal_r+0xc38>
 820f050:	d8c01c17 	ldw	r3,112(sp)
 820f054:	d8801b17 	ldw	r2,108(sp)
 820f058:	d811883a 	mov	r8,sp
 820f05c:	003f5a06 	br	820edc8 <___svfiprintf_internal_r+0xb14>
 820f060:	d9801a04 	addi	r6,sp,104
 820f064:	b80b883a 	mov	r5,r23
 820f068:	a809883a 	mov	r4,r21
 820f06c:	820e0e40 	call	820e0e4 <__ssprint_r>
 820f070:	103f9e1e 	bne	r2,zero,820eeec <___svfiprintf_internal_r+0xc38>
 820f074:	d8c01c17 	ldw	r3,112(sp)
 820f078:	d8801b17 	ldw	r2,108(sp)
 820f07c:	d811883a 	mov	r8,sp
 820f080:	003f1706 	br	820ece0 <___svfiprintf_internal_r+0xa2c>
 820f084:	d9801a04 	addi	r6,sp,104
 820f088:	b80b883a 	mov	r5,r23
 820f08c:	a809883a 	mov	r4,r21
 820f090:	820e0e40 	call	820e0e4 <__ssprint_r>
 820f094:	103f951e 	bne	r2,zero,820eeec <___svfiprintf_internal_r+0xc38>
 820f098:	d8c01c17 	ldw	r3,112(sp)
 820f09c:	d8801b17 	ldw	r2,108(sp)
 820f0a0:	d811883a 	mov	r8,sp
 820f0a4:	003f1b06 	br	820ed14 <___svfiprintf_internal_r+0xa60>
 820f0a8:	d8001d85 	stb	zero,118(sp)
 820f0ac:	80007b16 	blt	r16,zero,820f29c <___svfiprintf_internal_r+0xfe8>
 820f0b0:	00ffdfc4 	movi	r3,-129
 820f0b4:	e244b03a 	or	r2,fp,r9
 820f0b8:	90e4703a 	and	r18,r18,r3
 820f0bc:	103d7026 	beq	r2,zero,820e680 <___svfiprintf_internal_r+0x3cc>
 820f0c0:	0015883a 	mov	r10,zero
 820f0c4:	003d7206 	br	820e690 <___svfiprintf_internal_r+0x3dc>
 820f0c8:	d9801a04 	addi	r6,sp,104
 820f0cc:	b80b883a 	mov	r5,r23
 820f0d0:	a809883a 	mov	r4,r21
 820f0d4:	820e0e40 	call	820e0e4 <__ssprint_r>
 820f0d8:	103f841e 	bne	r2,zero,820eeec <___svfiprintf_internal_r+0xc38>
 820f0dc:	d8c01c17 	ldw	r3,112(sp)
 820f0e0:	d8801b17 	ldw	r2,108(sp)
 820f0e4:	d811883a 	mov	r8,sp
 820f0e8:	003ef006 	br	820ecac <___svfiprintf_internal_r+0x9f8>
 820f0ec:	9080100c 	andi	r2,r18,64
 820f0f0:	d8001d85 	stb	zero,118(sp)
 820f0f4:	dac02317 	ldw	r11,140(sp)
 820f0f8:	10008126 	beq	r2,zero,820f300 <___svfiprintf_internal_r+0x104c>
 820f0fc:	58800104 	addi	r2,r11,4
 820f100:	5f00000b 	ldhu	fp,0(r11)
 820f104:	0013883a 	mov	r9,zero
 820f108:	803ec30e 	bge	r16,zero,820ec18 <___svfiprintf_internal_r+0x964>
 820f10c:	d8802315 	stw	r2,140(sp)
 820f110:	0015883a 	mov	r10,zero
 820f114:	e244b03a 	or	r2,fp,r9
 820f118:	103e371e 	bne	r2,zero,820e9f8 <___svfiprintf_internal_r+0x744>
 820f11c:	00800044 	movi	r2,1
 820f120:	10803fcc 	andi	r2,r2,255
 820f124:	00c00044 	movi	r3,1
 820f128:	10c06126 	beq	r2,r3,820f2b0 <___svfiprintf_internal_r+0xffc>
 820f12c:	00c00084 	movi	r3,2
 820f130:	10fd5526 	beq	r2,r3,820e688 <___svfiprintf_internal_r+0x3d4>
 820f134:	003ed806 	br	820ec98 <___svfiprintf_internal_r+0x9e4>
 820f138:	d8802315 	stw	r2,140(sp)
 820f13c:	98c00007 	ldb	r3,0(r19)
 820f140:	003cab06 	br	820e3f0 <___svfiprintf_internal_r+0x13c>
 820f144:	d9801a04 	addi	r6,sp,104
 820f148:	b80b883a 	mov	r5,r23
 820f14c:	a809883a 	mov	r4,r21
 820f150:	820e0e40 	call	820e0e4 <__ssprint_r>
 820f154:	103f651e 	bne	r2,zero,820eeec <___svfiprintf_internal_r+0xc38>
 820f158:	d8c01c17 	ldw	r3,112(sp)
 820f15c:	003f4f06 	br	820ee9c <___svfiprintf_internal_r+0xbe8>
 820f160:	00820974 	movhi	r2,2085
 820f164:	10b6e504 	addi	r2,r2,-9324
 820f168:	d8802915 	stw	r2,164(sp)
 820f16c:	003d4406 	br	820e680 <___svfiprintf_internal_r+0x3cc>
 820f170:	dac02317 	ldw	r11,140(sp)
 820f174:	58800017 	ldw	r2,0(r11)
 820f178:	dac02517 	ldw	r11,148(sp)
 820f17c:	5807d7fa 	srai	r3,r11,31
 820f180:	dac02317 	ldw	r11,140(sp)
 820f184:	10c00115 	stw	r3,4(r2)
 820f188:	5ac00104 	addi	r11,r11,4
 820f18c:	dac02315 	stw	r11,140(sp)
 820f190:	dac02517 	ldw	r11,148(sp)
 820f194:	12c00015 	stw	r11,0(r2)
 820f198:	003c6d06 	br	820e350 <___svfiprintf_internal_r+0x9c>
 820f19c:	9080100c 	andi	r2,r18,64
 820f1a0:	dac02317 	ldw	r11,140(sp)
 820f1a4:	103e5326 	beq	r2,zero,820eaf4 <___svfiprintf_internal_r+0x840>
 820f1a8:	5f00000f 	ldh	fp,0(r11)
 820f1ac:	5ac00104 	addi	r11,r11,4
 820f1b0:	dac02315 	stw	r11,140(sp)
 820f1b4:	e013d7fa 	srai	r9,fp,31
 820f1b8:	4805883a 	mov	r2,r9
 820f1bc:	003e0706 	br	820e9dc <___svfiprintf_internal_r+0x728>
 820f1c0:	00800c04 	movi	r2,48
 820f1c4:	d8801d05 	stb	r2,116(sp)
 820f1c8:	d8c01d45 	stb	r3,117(sp)
 820f1cc:	d8001d85 	stb	zero,118(sp)
 820f1d0:	90800094 	ori	r2,r18,2
 820f1d4:	80008f16 	blt	r16,zero,820f414 <___svfiprintf_internal_r+0x1160>
 820f1d8:	00bfdfc4 	movi	r2,-129
 820f1dc:	90a4703a 	and	r18,r18,r2
 820f1e0:	94800094 	ori	r18,r18,2
 820f1e4:	0015883a 	mov	r10,zero
 820f1e8:	003d2906 	br	820e690 <___svfiprintf_internal_r+0x3dc>
 820f1ec:	98c00007 	ldb	r3,0(r19)
 820f1f0:	003c7f06 	br	820e3f0 <___svfiprintf_internal_r+0x13c>
 820f1f4:	dac02317 	ldw	r11,140(sp)
 820f1f8:	0013883a 	mov	r9,zero
 820f1fc:	5f000017 	ldw	fp,0(r11)
 820f200:	5ac00104 	addi	r11,r11,4
 820f204:	dac02315 	stw	r11,140(sp)
 820f208:	003d1506 	br	820e660 <___svfiprintf_internal_r+0x3ac>
 820f20c:	9080100c 	andi	r2,r18,64
 820f210:	d8001d85 	stb	zero,118(sp)
 820f214:	dac02317 	ldw	r11,140(sp)
 820f218:	10003426 	beq	r2,zero,820f2ec <___svfiprintf_internal_r+0x1038>
 820f21c:	58800104 	addi	r2,r11,4
 820f220:	5f00000b 	ldhu	fp,0(r11)
 820f224:	0013883a 	mov	r9,zero
 820f228:	803e950e 	bge	r16,zero,820ec80 <___svfiprintf_internal_r+0x9cc>
 820f22c:	e246b03a 	or	r3,fp,r9
 820f230:	d8802315 	stw	r2,140(sp)
 820f234:	183d5a1e 	bne	r3,zero,820e7a0 <___svfiprintf_internal_r+0x4ec>
 820f238:	0015883a 	mov	r10,zero
 820f23c:	0005883a 	mov	r2,zero
 820f240:	003fb706 	br	820f120 <___svfiprintf_internal_r+0xe6c>
 820f244:	98c00043 	ldbu	r3,1(r19)
 820f248:	94800814 	ori	r18,r18,32
 820f24c:	9cc00044 	addi	r19,r19,1
 820f250:	18c03fcc 	andi	r3,r3,255
 820f254:	18c0201c 	xori	r3,r3,128
 820f258:	18ffe004 	addi	r3,r3,-128
 820f25c:	003c6406 	br	820e3f0 <___svfiprintf_internal_r+0x13c>
 820f260:	d8c02315 	stw	r3,140(sp)
 820f264:	0015883a 	mov	r10,zero
 820f268:	003faa06 	br	820f114 <___svfiprintf_internal_r+0xe60>
 820f26c:	dac02317 	ldw	r11,140(sp)
 820f270:	58800017 	ldw	r2,0(r11)
 820f274:	5ac00104 	addi	r11,r11,4
 820f278:	dac02315 	stw	r11,140(sp)
 820f27c:	dac02517 	ldw	r11,148(sp)
 820f280:	12c00015 	stw	r11,0(r2)
 820f284:	003c3206 	br	820e350 <___svfiprintf_internal_r+0x9c>
 820f288:	01020974 	movhi	r4,2085
 820f28c:	2136e504 	addi	r4,r4,-9324
 820f290:	d9002915 	stw	r4,164(sp)
 820f294:	d8c02315 	stw	r3,140(sp)
 820f298:	1025883a 	mov	r18,r2
 820f29c:	e244b03a 	or	r2,fp,r9
 820f2a0:	103f871e 	bne	r2,zero,820f0c0 <___svfiprintf_internal_r+0xe0c>
 820f2a4:	0015883a 	mov	r10,zero
 820f2a8:	00800084 	movi	r2,2
 820f2ac:	003f9c06 	br	820f120 <___svfiprintf_internal_r+0xe6c>
 820f2b0:	0039883a 	mov	fp,zero
 820f2b4:	003e5f06 	br	820ec34 <___svfiprintf_internal_r+0x980>
 820f2b8:	d9801a04 	addi	r6,sp,104
 820f2bc:	b80b883a 	mov	r5,r23
 820f2c0:	a809883a 	mov	r4,r21
 820f2c4:	820e0e40 	call	820e0e4 <__ssprint_r>
 820f2c8:	103f081e 	bne	r2,zero,820eeec <___svfiprintf_internal_r+0xc38>
 820f2cc:	d8c01c17 	ldw	r3,112(sp)
 820f2d0:	d8801b17 	ldw	r2,108(sp)
 820f2d4:	d811883a 	mov	r8,sp
 820f2d8:	003e9106 	br	820ed20 <___svfiprintf_internal_r+0xa6c>
 820f2dc:	01020974 	movhi	r4,2085
 820f2e0:	21374d04 	addi	r4,r4,-8908
 820f2e4:	d9002215 	stw	r4,136(sp)
 820f2e8:	003ead06 	br	820eda0 <___svfiprintf_internal_r+0xaec>
 820f2ec:	58800104 	addi	r2,r11,4
 820f2f0:	5f000017 	ldw	fp,0(r11)
 820f2f4:	0013883a 	mov	r9,zero
 820f2f8:	803e610e 	bge	r16,zero,820ec80 <___svfiprintf_internal_r+0x9cc>
 820f2fc:	003fcb06 	br	820f22c <___svfiprintf_internal_r+0xf78>
 820f300:	58800104 	addi	r2,r11,4
 820f304:	5f000017 	ldw	fp,0(r11)
 820f308:	0013883a 	mov	r9,zero
 820f30c:	803e420e 	bge	r16,zero,820ec18 <___svfiprintf_internal_r+0x964>
 820f310:	003f7e06 	br	820f10c <___svfiprintf_internal_r+0xe58>
 820f314:	5f000017 	ldw	fp,0(r11)
 820f318:	5ac00104 	addi	r11,r11,4
 820f31c:	0013883a 	mov	r9,zero
 820f320:	dac02315 	stw	r11,140(sp)
 820f324:	003cce06 	br	820e660 <___svfiprintf_internal_r+0x3ac>
 820f328:	8809883a 	mov	r4,r17
 820f32c:	da002c15 	stw	r8,176(sp)
 820f330:	8203fbc0 	call	8203fbc <strlen>
 820f334:	d8802115 	stw	r2,132(sp)
 820f338:	da801d83 	ldbu	r10,118(sp)
 820f33c:	df002315 	stw	fp,140(sp)
 820f340:	0021883a 	mov	r16,zero
 820f344:	da002c17 	ldw	r8,176(sp)
 820f348:	003cf606 	br	820e724 <___svfiprintf_internal_r+0x470>
 820f34c:	00800184 	movi	r2,6
 820f350:	1400012e 	bgeu	r2,r16,820f358 <___svfiprintf_internal_r+0x10a4>
 820f354:	1021883a 	mov	r16,r2
 820f358:	dc002115 	stw	r16,132(sp)
 820f35c:	8005883a 	mov	r2,r16
 820f360:	80003c16 	blt	r16,zero,820f454 <___svfiprintf_internal_r+0x11a0>
 820f364:	04420974 	movhi	r17,2085
 820f368:	d8802015 	stw	r2,128(sp)
 820f36c:	df002315 	stw	fp,140(sp)
 820f370:	8c76ea04 	addi	r17,r17,-9304
 820f374:	003d2e06 	br	820e830 <___svfiprintf_internal_r+0x57c>
 820f378:	04001004 	movi	r16,64
 820f37c:	800b883a 	mov	r5,r16
 820f380:	820bd480 	call	820bd48 <_malloc_r>
 820f384:	dac02717 	ldw	r11,156(sp)
 820f388:	58800015 	stw	r2,0(r11)
 820f38c:	58800415 	stw	r2,16(r11)
 820f390:	10004826 	beq	r2,zero,820f4b4 <___svfiprintf_internal_r+0x1200>
 820f394:	dac02717 	ldw	r11,156(sp)
 820f398:	5c000515 	stw	r16,20(r11)
 820f39c:	003bd906 	br	820e304 <___svfiprintf_internal_r+0x50>
 820f3a0:	9080004c 	andi	r2,r18,1
 820f3a4:	0015883a 	mov	r10,zero
 820f3a8:	10000626 	beq	r2,zero,820f3c4 <___svfiprintf_internal_r+0x1110>
 820f3ac:	dac02b17 	ldw	r11,172(sp)
 820f3b0:	00800c04 	movi	r2,48
 820f3b4:	d88019c5 	stb	r2,103(sp)
 820f3b8:	dac02115 	stw	r11,132(sp)
 820f3bc:	dc4019c4 	addi	r17,sp,103
 820f3c0:	003cd806 	br	820e724 <___svfiprintf_internal_r+0x470>
 820f3c4:	d8002115 	stw	zero,132(sp)
 820f3c8:	dc401a04 	addi	r17,sp,104
 820f3cc:	003cd506 	br	820e724 <___svfiprintf_internal_r+0x470>
 820f3d0:	01020974 	movhi	r4,2085
 820f3d4:	21375104 	addi	r4,r4,-8892
 820f3d8:	d9002815 	stw	r4,160(sp)
 820f3dc:	003d4306 	br	820e8ec <___svfiprintf_internal_r+0x638>
 820f3e0:	00bfffc4 	movi	r2,-1
 820f3e4:	003ec606 	br	820ef00 <___svfiprintf_internal_r+0xc4c>
 820f3e8:	00800044 	movi	r2,1
 820f3ec:	10803fcc 	andi	r2,r2,255
 820f3f0:	00c00044 	movi	r3,1
 820f3f4:	10fd8026 	beq	r2,r3,820e9f8 <___svfiprintf_internal_r+0x744>
 820f3f8:	00c00084 	movi	r3,2
 820f3fc:	10fca426 	beq	r2,r3,820e690 <___svfiprintf_internal_r+0x3dc>
 820f400:	003ce806 	br	820e7a4 <___svfiprintf_internal_r+0x4f0>
 820f404:	01020974 	movhi	r4,2085
 820f408:	21375104 	addi	r4,r4,-8892
 820f40c:	d9002815 	stw	r4,160(sp)
 820f410:	003e9906 	br	820ee78 <___svfiprintf_internal_r+0xbc4>
 820f414:	1025883a 	mov	r18,r2
 820f418:	0015883a 	mov	r10,zero
 820f41c:	00800084 	movi	r2,2
 820f420:	003ff206 	br	820f3ec <___svfiprintf_internal_r+0x1138>
 820f424:	01420974 	movhi	r5,2085
 820f428:	29774d04 	addi	r5,r5,-8908
 820f42c:	d9402215 	stw	r5,136(sp)
 820f430:	003ee206 	br	820efbc <___svfiprintf_internal_r+0xd08>
 820f434:	5827883a 	mov	r19,r11
 820f438:	0021883a 	mov	r16,zero
 820f43c:	003bed06 	br	820e3f4 <___svfiprintf_internal_r+0x140>
 820f440:	dc002115 	stw	r16,132(sp)
 820f444:	da801d83 	ldbu	r10,118(sp)
 820f448:	df002315 	stw	fp,140(sp)
 820f44c:	0021883a 	mov	r16,zero
 820f450:	003cb406 	br	820e724 <___svfiprintf_internal_r+0x470>
 820f454:	0005883a 	mov	r2,zero
 820f458:	003fc206 	br	820f364 <___svfiprintf_internal_r+0x10b0>
 820f45c:	d8802317 	ldw	r2,140(sp)
 820f460:	98c00043 	ldbu	r3,1(r19)
 820f464:	5827883a 	mov	r19,r11
 820f468:	14000017 	ldw	r16,0(r2)
 820f46c:	10800104 	addi	r2,r2,4
 820f470:	d8802315 	stw	r2,140(sp)
 820f474:	803f760e 	bge	r16,zero,820f250 <___svfiprintf_internal_r+0xf9c>
 820f478:	18c03fcc 	andi	r3,r3,255
 820f47c:	18c0201c 	xori	r3,r3,128
 820f480:	043fffc4 	movi	r16,-1
 820f484:	18ffe004 	addi	r3,r3,-128
 820f488:	003bd906 	br	820e3f0 <___svfiprintf_internal_r+0x13c>
 820f48c:	d9c01d85 	stb	r7,118(sp)
 820f490:	003cb606 	br	820e76c <___svfiprintf_internal_r+0x4b8>
 820f494:	d9c01d85 	stb	r7,118(sp)
 820f498:	003d2106 	br	820e920 <___svfiprintf_internal_r+0x66c>
 820f49c:	d9c01d85 	stb	r7,118(sp)
 820f4a0:	003d8e06 	br	820eadc <___svfiprintf_internal_r+0x828>
 820f4a4:	d9c01d85 	stb	r7,118(sp)
 820f4a8:	003db306 	br	820eb78 <___svfiprintf_internal_r+0x8c4>
 820f4ac:	d9c01d85 	stb	r7,118(sp)
 820f4b0:	003c8a06 	br	820e6dc <___svfiprintf_internal_r+0x428>
 820f4b4:	dac02a17 	ldw	r11,168(sp)
 820f4b8:	00800304 	movi	r2,12
 820f4bc:	58800015 	stw	r2,0(r11)
 820f4c0:	00bfffc4 	movi	r2,-1
 820f4c4:	003e8e06 	br	820ef00 <___svfiprintf_internal_r+0xc4c>
 820f4c8:	d9c01d85 	stb	r7,118(sp)
 820f4cc:	003dc706 	br	820ebec <___svfiprintf_internal_r+0x938>
 820f4d0:	d9c01d85 	stb	r7,118(sp)
 820f4d4:	003ddf06 	br	820ec54 <___svfiprintf_internal_r+0x9a0>
 820f4d8:	d9c01d85 	stb	r7,118(sp)
 820f4dc:	003d3706 	br	820e9bc <___svfiprintf_internal_r+0x708>
 820f4e0:	d9c01d85 	stb	r7,118(sp)
 820f4e4:	003c5406 	br	820e638 <___svfiprintf_internal_r+0x384>
 820f4e8:	d9c01d85 	stb	r7,118(sp)
 820f4ec:	003d1d06 	br	820e964 <___svfiprintf_internal_r+0x6b0>

0820f4f0 <__sprint_r.part.0>:
 820f4f0:	28801917 	ldw	r2,100(r5)
 820f4f4:	defff604 	addi	sp,sp,-40
 820f4f8:	dd400515 	stw	r21,20(sp)
 820f4fc:	dfc00915 	stw	ra,36(sp)
 820f500:	df000815 	stw	fp,32(sp)
 820f504:	ddc00715 	stw	r23,28(sp)
 820f508:	dd800615 	stw	r22,24(sp)
 820f50c:	dd000415 	stw	r20,16(sp)
 820f510:	dcc00315 	stw	r19,12(sp)
 820f514:	dc800215 	stw	r18,8(sp)
 820f518:	dc400115 	stw	r17,4(sp)
 820f51c:	dc000015 	stw	r16,0(sp)
 820f520:	1088000c 	andi	r2,r2,8192
 820f524:	302b883a 	mov	r21,r6
 820f528:	10002e26 	beq	r2,zero,820f5e4 <__sprint_r.part.0+0xf4>
 820f52c:	30800217 	ldw	r2,8(r6)
 820f530:	35800017 	ldw	r22,0(r6)
 820f534:	10002926 	beq	r2,zero,820f5dc <__sprint_r.part.0+0xec>
 820f538:	2827883a 	mov	r19,r5
 820f53c:	2029883a 	mov	r20,r4
 820f540:	b5c00104 	addi	r23,r22,4
 820f544:	04bfffc4 	movi	r18,-1
 820f548:	bc400017 	ldw	r17,0(r23)
 820f54c:	b4000017 	ldw	r16,0(r22)
 820f550:	0039883a 	mov	fp,zero
 820f554:	8822d0ba 	srli	r17,r17,2
 820f558:	8800031e 	bne	r17,zero,820f568 <__sprint_r.part.0+0x78>
 820f55c:	00001806 	br	820f5c0 <__sprint_r.part.0+0xd0>
 820f560:	84000104 	addi	r16,r16,4
 820f564:	8f001526 	beq	r17,fp,820f5bc <__sprint_r.part.0+0xcc>
 820f568:	81400017 	ldw	r5,0(r16)
 820f56c:	980d883a 	mov	r6,r19
 820f570:	a009883a 	mov	r4,r20
 820f574:	8210f180 	call	8210f18 <_fputwc_r>
 820f578:	e7000044 	addi	fp,fp,1
 820f57c:	14bff81e 	bne	r2,r18,820f560 <__sprint_r.part.0+0x70>
 820f580:	9005883a 	mov	r2,r18
 820f584:	a8000215 	stw	zero,8(r21)
 820f588:	a8000115 	stw	zero,4(r21)
 820f58c:	dfc00917 	ldw	ra,36(sp)
 820f590:	df000817 	ldw	fp,32(sp)
 820f594:	ddc00717 	ldw	r23,28(sp)
 820f598:	dd800617 	ldw	r22,24(sp)
 820f59c:	dd400517 	ldw	r21,20(sp)
 820f5a0:	dd000417 	ldw	r20,16(sp)
 820f5a4:	dcc00317 	ldw	r19,12(sp)
 820f5a8:	dc800217 	ldw	r18,8(sp)
 820f5ac:	dc400117 	ldw	r17,4(sp)
 820f5b0:	dc000017 	ldw	r16,0(sp)
 820f5b4:	dec00a04 	addi	sp,sp,40
 820f5b8:	f800283a 	ret
 820f5bc:	a8800217 	ldw	r2,8(r21)
 820f5c0:	8c63883a 	add	r17,r17,r17
 820f5c4:	8c63883a 	add	r17,r17,r17
 820f5c8:	1445c83a 	sub	r2,r2,r17
 820f5cc:	a8800215 	stw	r2,8(r21)
 820f5d0:	b5800204 	addi	r22,r22,8
 820f5d4:	bdc00204 	addi	r23,r23,8
 820f5d8:	103fdb1e 	bne	r2,zero,820f548 <__sprint_r.part.0+0x58>
 820f5dc:	0005883a 	mov	r2,zero
 820f5e0:	003fe806 	br	820f584 <__sprint_r.part.0+0x94>
 820f5e4:	820b46c0 	call	820b46c <__sfvwrite_r>
 820f5e8:	003fe606 	br	820f584 <__sprint_r.part.0+0x94>

0820f5ec <__sprint_r>:
 820f5ec:	30c00217 	ldw	r3,8(r6)
 820f5f0:	18000126 	beq	r3,zero,820f5f8 <__sprint_r+0xc>
 820f5f4:	820f4f01 	jmpi	820f4f0 <__sprint_r.part.0>
 820f5f8:	30000115 	stw	zero,4(r6)
 820f5fc:	0005883a 	mov	r2,zero
 820f600:	f800283a 	ret

0820f604 <___vfiprintf_internal_r>:
 820f604:	deffc904 	addi	sp,sp,-220
 820f608:	df003515 	stw	fp,212(sp)
 820f60c:	dd003115 	stw	r20,196(sp)
 820f610:	dfc03615 	stw	ra,216(sp)
 820f614:	ddc03415 	stw	r23,208(sp)
 820f618:	dd803315 	stw	r22,204(sp)
 820f61c:	dd403215 	stw	r21,200(sp)
 820f620:	dcc03015 	stw	r19,192(sp)
 820f624:	dc802f15 	stw	r18,188(sp)
 820f628:	dc402e15 	stw	r17,184(sp)
 820f62c:	dc002d15 	stw	r16,180(sp)
 820f630:	d9002015 	stw	r4,128(sp)
 820f634:	d9c02215 	stw	r7,136(sp)
 820f638:	2829883a 	mov	r20,r5
 820f63c:	3039883a 	mov	fp,r6
 820f640:	20000226 	beq	r4,zero,820f64c <___vfiprintf_internal_r+0x48>
 820f644:	20800e17 	ldw	r2,56(r4)
 820f648:	1000cf26 	beq	r2,zero,820f988 <___vfiprintf_internal_r+0x384>
 820f64c:	a080030b 	ldhu	r2,12(r20)
 820f650:	10c8000c 	andi	r3,r2,8192
 820f654:	1800061e 	bne	r3,zero,820f670 <___vfiprintf_internal_r+0x6c>
 820f658:	a1001917 	ldw	r4,100(r20)
 820f65c:	00f7ffc4 	movi	r3,-8193
 820f660:	10880014 	ori	r2,r2,8192
 820f664:	20c6703a 	and	r3,r4,r3
 820f668:	a080030d 	sth	r2,12(r20)
 820f66c:	a0c01915 	stw	r3,100(r20)
 820f670:	10c0020c 	andi	r3,r2,8
 820f674:	1800a926 	beq	r3,zero,820f91c <___vfiprintf_internal_r+0x318>
 820f678:	a0c00417 	ldw	r3,16(r20)
 820f67c:	1800a726 	beq	r3,zero,820f91c <___vfiprintf_internal_r+0x318>
 820f680:	1080068c 	andi	r2,r2,26
 820f684:	00c00284 	movi	r3,10
 820f688:	10c0ac26 	beq	r2,r3,820f93c <___vfiprintf_internal_r+0x338>
 820f68c:	da801a04 	addi	r10,sp,104
 820f690:	da801e15 	stw	r10,120(sp)
 820f694:	d8801e17 	ldw	r2,120(sp)
 820f698:	da8019c4 	addi	r10,sp,103
 820f69c:	05820974 	movhi	r22,2085
 820f6a0:	05c20974 	movhi	r23,2085
 820f6a4:	da801f15 	stw	r10,124(sp)
 820f6a8:	1295c83a 	sub	r10,r2,r10
 820f6ac:	b5b75904 	addi	r22,r22,-8860
 820f6b0:	bdf75504 	addi	r23,r23,-8876
 820f6b4:	dec01a15 	stw	sp,104(sp)
 820f6b8:	d8001c15 	stw	zero,112(sp)
 820f6bc:	d8001b15 	stw	zero,108(sp)
 820f6c0:	d8002615 	stw	zero,152(sp)
 820f6c4:	d8002315 	stw	zero,140(sp)
 820f6c8:	da802715 	stw	r10,156(sp)
 820f6cc:	d811883a 	mov	r8,sp
 820f6d0:	dd002115 	stw	r20,132(sp)
 820f6d4:	e021883a 	mov	r16,fp
 820f6d8:	80800007 	ldb	r2,0(r16)
 820f6dc:	1003ea26 	beq	r2,zero,8210688 <___vfiprintf_internal_r+0x1084>
 820f6e0:	00c00944 	movi	r3,37
 820f6e4:	8025883a 	mov	r18,r16
 820f6e8:	10c0021e 	bne	r2,r3,820f6f4 <___vfiprintf_internal_r+0xf0>
 820f6ec:	00001606 	br	820f748 <___vfiprintf_internal_r+0x144>
 820f6f0:	10c00326 	beq	r2,r3,820f700 <___vfiprintf_internal_r+0xfc>
 820f6f4:	94800044 	addi	r18,r18,1
 820f6f8:	90800007 	ldb	r2,0(r18)
 820f6fc:	103ffc1e 	bne	r2,zero,820f6f0 <___vfiprintf_internal_r+0xec>
 820f700:	9423c83a 	sub	r17,r18,r16
 820f704:	88001026 	beq	r17,zero,820f748 <___vfiprintf_internal_r+0x144>
 820f708:	d8c01c17 	ldw	r3,112(sp)
 820f70c:	d8801b17 	ldw	r2,108(sp)
 820f710:	44000015 	stw	r16,0(r8)
 820f714:	88c7883a 	add	r3,r17,r3
 820f718:	10800044 	addi	r2,r2,1
 820f71c:	44400115 	stw	r17,4(r8)
 820f720:	d8c01c15 	stw	r3,112(sp)
 820f724:	d8801b15 	stw	r2,108(sp)
 820f728:	010001c4 	movi	r4,7
 820f72c:	2080760e 	bge	r4,r2,820f908 <___vfiprintf_internal_r+0x304>
 820f730:	1803821e 	bne	r3,zero,821053c <___vfiprintf_internal_r+0xf38>
 820f734:	da802317 	ldw	r10,140(sp)
 820f738:	d8001b15 	stw	zero,108(sp)
 820f73c:	d811883a 	mov	r8,sp
 820f740:	5455883a 	add	r10,r10,r17
 820f744:	da802315 	stw	r10,140(sp)
 820f748:	90800007 	ldb	r2,0(r18)
 820f74c:	10044626 	beq	r2,zero,8210868 <___vfiprintf_internal_r+0x1264>
 820f750:	90c00047 	ldb	r3,1(r18)
 820f754:	94000044 	addi	r16,r18,1
 820f758:	d8001d85 	stb	zero,118(sp)
 820f75c:	0009883a 	mov	r4,zero
 820f760:	000f883a 	mov	r7,zero
 820f764:	027fffc4 	movi	r9,-1
 820f768:	0023883a 	mov	r17,zero
 820f76c:	0029883a 	mov	r20,zero
 820f770:	01401604 	movi	r5,88
 820f774:	01800244 	movi	r6,9
 820f778:	03400a84 	movi	r13,42
 820f77c:	03001b04 	movi	r12,108
 820f780:	84000044 	addi	r16,r16,1
 820f784:	18bff804 	addi	r2,r3,-32
 820f788:	28827336 	bltu	r5,r2,8210158 <___vfiprintf_internal_r+0xb54>
 820f78c:	100490ba 	slli	r2,r2,2
 820f790:	02820874 	movhi	r10,2081
 820f794:	52bde904 	addi	r10,r10,-2140
 820f798:	1285883a 	add	r2,r2,r10
 820f79c:	10800017 	ldw	r2,0(r2)
 820f7a0:	1000683a 	jmp	r2
 820f7a4:	0820fe8c 	andi	zero,at,33786
 820f7a8:	08210158 	cmpnei	zero,at,-31739
 820f7ac:	08210158 	cmpnei	zero,at,-31739
 820f7b0:	0820feac 	andhi	zero,at,33786
 820f7b4:	08210158 	cmpnei	zero,at,-31739
 820f7b8:	08210158 	cmpnei	zero,at,-31739
 820f7bc:	08210158 	cmpnei	zero,at,-31739
 820f7c0:	08210158 	cmpnei	zero,at,-31739
 820f7c4:	08210158 	cmpnei	zero,at,-31739
 820f7c8:	08210158 	cmpnei	zero,at,-31739
 820f7cc:	08210094 	ori	zero,at,33794
 820f7d0:	082100b0 	cmpltui	zero,at,33794
 820f7d4:	08210158 	cmpnei	zero,at,-31739
 820f7d8:	0820f998 	cmpnei	zero,at,-31770
 820f7dc:	082100c0 	call	82100c <OSCtxSw_SWITCH_PC+0x820fcc>
 820f7e0:	08210158 	cmpnei	zero,at,-31739
 820f7e4:	0820feb8 	rdprs	zero,at,-31750
 820f7e8:	0820fec4 	addi	zero,at,-31749
 820f7ec:	0820fec4 	addi	zero,at,-31749
 820f7f0:	0820fec4 	addi	zero,at,-31749
 820f7f4:	0820fec4 	addi	zero,at,-31749
 820f7f8:	0820fec4 	addi	zero,at,-31749
 820f7fc:	0820fec4 	addi	zero,at,-31749
 820f800:	0820fec4 	addi	zero,at,-31749
 820f804:	0820fec4 	addi	zero,at,-31749
 820f808:	0820fec4 	addi	zero,at,-31749
 820f80c:	08210158 	cmpnei	zero,at,-31739
 820f810:	08210158 	cmpnei	zero,at,-31739
 820f814:	08210158 	cmpnei	zero,at,-31739
 820f818:	08210158 	cmpnei	zero,at,-31739
 820f81c:	08210158 	cmpnei	zero,at,-31739
 820f820:	08210158 	cmpnei	zero,at,-31739
 820f824:	08210158 	cmpnei	zero,at,-31739
 820f828:	08210158 	cmpnei	zero,at,-31739
 820f82c:	08210158 	cmpnei	zero,at,-31739
 820f830:	08210158 	cmpnei	zero,at,-31739
 820f834:	0820fef0 	cmpltui	zero,at,33787
 820f838:	08210158 	cmpnei	zero,at,-31739
 820f83c:	08210158 	cmpnei	zero,at,-31739
 820f840:	08210158 	cmpnei	zero,at,-31739
 820f844:	08210158 	cmpnei	zero,at,-31739
 820f848:	08210158 	cmpnei	zero,at,-31739
 820f84c:	08210158 	cmpnei	zero,at,-31739
 820f850:	08210158 	cmpnei	zero,at,-31739
 820f854:	08210158 	cmpnei	zero,at,-31739
 820f858:	08210158 	cmpnei	zero,at,-31739
 820f85c:	08210158 	cmpnei	zero,at,-31739
 820f860:	0820ff28 	cmpgeui	zero,at,33788
 820f864:	08210158 	cmpnei	zero,at,-31739
 820f868:	08210158 	cmpnei	zero,at,-31739
 820f86c:	08210158 	cmpnei	zero,at,-31739
 820f870:	08210158 	cmpnei	zero,at,-31739
 820f874:	08210158 	cmpnei	zero,at,-31739
 820f878:	0820ff80 	call	820ff8 <OSCtxSw_SWITCH_PC+0x820fb8>
 820f87c:	08210158 	cmpnei	zero,at,-31739
 820f880:	08210158 	cmpnei	zero,at,-31739
 820f884:	0820fff0 	cmpltui	zero,at,33791
 820f888:	08210158 	cmpnei	zero,at,-31739
 820f88c:	08210158 	cmpnei	zero,at,-31739
 820f890:	08210158 	cmpnei	zero,at,-31739
 820f894:	08210158 	cmpnei	zero,at,-31739
 820f898:	08210158 	cmpnei	zero,at,-31739
 820f89c:	08210158 	cmpnei	zero,at,-31739
 820f8a0:	08210158 	cmpnei	zero,at,-31739
 820f8a4:	08210158 	cmpnei	zero,at,-31739
 820f8a8:	08210158 	cmpnei	zero,at,-31739
 820f8ac:	08210158 	cmpnei	zero,at,-31739
 820f8b0:	0820fd9c 	xori	zero,at,33782
 820f8b4:	0820fdc8 	cmpgei	zero,at,-31753
 820f8b8:	08210158 	cmpnei	zero,at,-31739
 820f8bc:	08210158 	cmpnei	zero,at,-31739
 820f8c0:	08210158 	cmpnei	zero,at,-31739
 820f8c4:	08210100 	call	821010 <OSCtxSw_SWITCH_PC+0x820fd0>
 820f8c8:	0820fdc8 	cmpgei	zero,at,-31753
 820f8cc:	08210158 	cmpnei	zero,at,-31739
 820f8d0:	08210158 	cmpnei	zero,at,-31739
 820f8d4:	0820fc5c 	xori	zero,at,33777
 820f8d8:	08210158 	cmpnei	zero,at,-31739
 820f8dc:	0820fc6c 	andhi	zero,at,33777
 820f8e0:	0820fca8 	cmpgeui	zero,at,33778
 820f8e4:	0820f9a4 	muli	zero,at,-31770
 820f8e8:	0820fc50 	cmplti	zero,at,-31759
 820f8ec:	08210158 	cmpnei	zero,at,-31739
 820f8f0:	0821002c 	andhi	zero,at,33792
 820f8f4:	08210158 	cmpnei	zero,at,-31739
 820f8f8:	08210084 	addi	zero,at,-31742
 820f8fc:	08210158 	cmpnei	zero,at,-31739
 820f900:	08210158 	cmpnei	zero,at,-31739
 820f904:	0820fd48 	cmpgei	zero,at,-31755
 820f908:	42000204 	addi	r8,r8,8
 820f90c:	da802317 	ldw	r10,140(sp)
 820f910:	5455883a 	add	r10,r10,r17
 820f914:	da802315 	stw	r10,140(sp)
 820f918:	003f8b06 	br	820f748 <___vfiprintf_internal_r+0x144>
 820f91c:	d9002017 	ldw	r4,128(sp)
 820f920:	a00b883a 	mov	r5,r20
 820f924:	8208ec00 	call	8208ec0 <__swsetup_r>
 820f928:	1003b11e 	bne	r2,zero,82107f0 <___vfiprintf_internal_r+0x11ec>
 820f92c:	a080030b 	ldhu	r2,12(r20)
 820f930:	00c00284 	movi	r3,10
 820f934:	1080068c 	andi	r2,r2,26
 820f938:	10ff541e 	bne	r2,r3,820f68c <___vfiprintf_internal_r+0x88>
 820f93c:	a080038f 	ldh	r2,14(r20)
 820f940:	103f5216 	blt	r2,zero,820f68c <___vfiprintf_internal_r+0x88>
 820f944:	d9c02217 	ldw	r7,136(sp)
 820f948:	d9002017 	ldw	r4,128(sp)
 820f94c:	e00d883a 	mov	r6,fp
 820f950:	a00b883a 	mov	r5,r20
 820f954:	8210a7c0 	call	8210a7c <__sbprintf>
 820f958:	dfc03617 	ldw	ra,216(sp)
 820f95c:	df003517 	ldw	fp,212(sp)
 820f960:	ddc03417 	ldw	r23,208(sp)
 820f964:	dd803317 	ldw	r22,204(sp)
 820f968:	dd403217 	ldw	r21,200(sp)
 820f96c:	dd003117 	ldw	r20,196(sp)
 820f970:	dcc03017 	ldw	r19,192(sp)
 820f974:	dc802f17 	ldw	r18,188(sp)
 820f978:	dc402e17 	ldw	r17,184(sp)
 820f97c:	dc002d17 	ldw	r16,180(sp)
 820f980:	dec03704 	addi	sp,sp,220
 820f984:	f800283a 	ret
 820f988:	820ae940 	call	820ae94 <__sinit>
 820f98c:	003f2f06 	br	820f64c <___vfiprintf_internal_r+0x48>
 820f990:	0463c83a 	sub	r17,zero,r17
 820f994:	d8802215 	stw	r2,136(sp)
 820f998:	a5000114 	ori	r20,r20,4
 820f99c:	80c00007 	ldb	r3,0(r16)
 820f9a0:	003f7706 	br	820f780 <___vfiprintf_internal_r+0x17c>
 820f9a4:	00800c04 	movi	r2,48
 820f9a8:	da802217 	ldw	r10,136(sp)
 820f9ac:	d8801d05 	stb	r2,116(sp)
 820f9b0:	00801e04 	movi	r2,120
 820f9b4:	d8801d45 	stb	r2,117(sp)
 820f9b8:	d8001d85 	stb	zero,118(sp)
 820f9bc:	50c00104 	addi	r3,r10,4
 820f9c0:	54800017 	ldw	r18,0(r10)
 820f9c4:	0027883a 	mov	r19,zero
 820f9c8:	a0800094 	ori	r2,r20,2
 820f9cc:	48030b16 	blt	r9,zero,82105fc <___vfiprintf_internal_r+0xff8>
 820f9d0:	00bfdfc4 	movi	r2,-129
 820f9d4:	a096703a 	and	r11,r20,r2
 820f9d8:	d8c02215 	stw	r3,136(sp)
 820f9dc:	5d000094 	ori	r20,r11,2
 820f9e0:	90032b1e 	bne	r18,zero,8210690 <___vfiprintf_internal_r+0x108c>
 820f9e4:	00820974 	movhi	r2,2085
 820f9e8:	10b6e504 	addi	r2,r2,-9324
 820f9ec:	d8802615 	stw	r2,152(sp)
 820f9f0:	0039883a 	mov	fp,zero
 820f9f4:	48017b1e 	bne	r9,zero,820ffe4 <___vfiprintf_internal_r+0x9e0>
 820f9f8:	0013883a 	mov	r9,zero
 820f9fc:	0027883a 	mov	r19,zero
 820fa00:	dd401a04 	addi	r21,sp,104
 820fa04:	4825883a 	mov	r18,r9
 820fa08:	4cc0010e 	bge	r9,r19,820fa10 <___vfiprintf_internal_r+0x40c>
 820fa0c:	9825883a 	mov	r18,r19
 820fa10:	e7003fcc 	andi	fp,fp,255
 820fa14:	e700201c 	xori	fp,fp,128
 820fa18:	e73fe004 	addi	fp,fp,-128
 820fa1c:	e0000126 	beq	fp,zero,820fa24 <___vfiprintf_internal_r+0x420>
 820fa20:	94800044 	addi	r18,r18,1
 820fa24:	a380008c 	andi	r14,r20,2
 820fa28:	70000126 	beq	r14,zero,820fa30 <___vfiprintf_internal_r+0x42c>
 820fa2c:	94800084 	addi	r18,r18,2
 820fa30:	a700210c 	andi	fp,r20,132
 820fa34:	e001df1e 	bne	fp,zero,82101b4 <___vfiprintf_internal_r+0xbb0>
 820fa38:	8c87c83a 	sub	r3,r17,r18
 820fa3c:	00c1dd0e 	bge	zero,r3,82101b4 <___vfiprintf_internal_r+0xbb0>
 820fa40:	01c00404 	movi	r7,16
 820fa44:	d8801c17 	ldw	r2,112(sp)
 820fa48:	38c3ad0e 	bge	r7,r3,8210900 <___vfiprintf_internal_r+0x12fc>
 820fa4c:	02820974 	movhi	r10,2085
 820fa50:	52b75904 	addi	r10,r10,-8860
 820fa54:	dc002915 	stw	r16,164(sp)
 820fa58:	d9801b17 	ldw	r6,108(sp)
 820fa5c:	da802415 	stw	r10,144(sp)
 820fa60:	03c001c4 	movi	r15,7
 820fa64:	da402515 	stw	r9,148(sp)
 820fa68:	db802815 	stw	r14,160(sp)
 820fa6c:	1821883a 	mov	r16,r3
 820fa70:	00000506 	br	820fa88 <___vfiprintf_internal_r+0x484>
 820fa74:	31400084 	addi	r5,r6,2
 820fa78:	42000204 	addi	r8,r8,8
 820fa7c:	200d883a 	mov	r6,r4
 820fa80:	843ffc04 	addi	r16,r16,-16
 820fa84:	3c000d0e 	bge	r7,r16,820fabc <___vfiprintf_internal_r+0x4b8>
 820fa88:	10800404 	addi	r2,r2,16
 820fa8c:	31000044 	addi	r4,r6,1
 820fa90:	45800015 	stw	r22,0(r8)
 820fa94:	41c00115 	stw	r7,4(r8)
 820fa98:	d8801c15 	stw	r2,112(sp)
 820fa9c:	d9001b15 	stw	r4,108(sp)
 820faa0:	793ff40e 	bge	r15,r4,820fa74 <___vfiprintf_internal_r+0x470>
 820faa4:	1001b51e 	bne	r2,zero,821017c <___vfiprintf_internal_r+0xb78>
 820faa8:	843ffc04 	addi	r16,r16,-16
 820faac:	000d883a 	mov	r6,zero
 820fab0:	01400044 	movi	r5,1
 820fab4:	d811883a 	mov	r8,sp
 820fab8:	3c3ff316 	blt	r7,r16,820fa88 <___vfiprintf_internal_r+0x484>
 820fabc:	8007883a 	mov	r3,r16
 820fac0:	da402517 	ldw	r9,148(sp)
 820fac4:	db802817 	ldw	r14,160(sp)
 820fac8:	dc002917 	ldw	r16,164(sp)
 820facc:	da802417 	ldw	r10,144(sp)
 820fad0:	1885883a 	add	r2,r3,r2
 820fad4:	40c00115 	stw	r3,4(r8)
 820fad8:	42800015 	stw	r10,0(r8)
 820fadc:	d8801c15 	stw	r2,112(sp)
 820fae0:	d9401b15 	stw	r5,108(sp)
 820fae4:	00c001c4 	movi	r3,7
 820fae8:	19426016 	blt	r3,r5,821046c <___vfiprintf_internal_r+0xe68>
 820faec:	d8c01d87 	ldb	r3,118(sp)
 820faf0:	42000204 	addi	r8,r8,8
 820faf4:	29000044 	addi	r4,r5,1
 820faf8:	1801b31e 	bne	r3,zero,82101c8 <___vfiprintf_internal_r+0xbc4>
 820fafc:	7001c026 	beq	r14,zero,8210200 <___vfiprintf_internal_r+0xbfc>
 820fb00:	d8c01d04 	addi	r3,sp,116
 820fb04:	10800084 	addi	r2,r2,2
 820fb08:	40c00015 	stw	r3,0(r8)
 820fb0c:	00c00084 	movi	r3,2
 820fb10:	40c00115 	stw	r3,4(r8)
 820fb14:	d8801c15 	stw	r2,112(sp)
 820fb18:	d9001b15 	stw	r4,108(sp)
 820fb1c:	00c001c4 	movi	r3,7
 820fb20:	1902650e 	bge	r3,r4,82104b8 <___vfiprintf_internal_r+0xeb4>
 820fb24:	10029a1e 	bne	r2,zero,8210590 <___vfiprintf_internal_r+0xf8c>
 820fb28:	00c02004 	movi	r3,128
 820fb2c:	01000044 	movi	r4,1
 820fb30:	000b883a 	mov	r5,zero
 820fb34:	d811883a 	mov	r8,sp
 820fb38:	e0c1b31e 	bne	fp,r3,8210208 <___vfiprintf_internal_r+0xc04>
 820fb3c:	8cb9c83a 	sub	fp,r17,r18
 820fb40:	0701b10e 	bge	zero,fp,8210208 <___vfiprintf_internal_r+0xc04>
 820fb44:	01c00404 	movi	r7,16
 820fb48:	3f03890e 	bge	r7,fp,8210970 <___vfiprintf_internal_r+0x136c>
 820fb4c:	00c20974 	movhi	r3,2085
 820fb50:	18f75504 	addi	r3,r3,-8876
 820fb54:	d8c02415 	stw	r3,144(sp)
 820fb58:	8007883a 	mov	r3,r16
 820fb5c:	034001c4 	movi	r13,7
 820fb60:	e021883a 	mov	r16,fp
 820fb64:	da402515 	stw	r9,148(sp)
 820fb68:	1839883a 	mov	fp,r3
 820fb6c:	00000506 	br	820fb84 <___vfiprintf_internal_r+0x580>
 820fb70:	29800084 	addi	r6,r5,2
 820fb74:	42000204 	addi	r8,r8,8
 820fb78:	180b883a 	mov	r5,r3
 820fb7c:	843ffc04 	addi	r16,r16,-16
 820fb80:	3c000d0e 	bge	r7,r16,820fbb8 <___vfiprintf_internal_r+0x5b4>
 820fb84:	10800404 	addi	r2,r2,16
 820fb88:	28c00044 	addi	r3,r5,1
 820fb8c:	45c00015 	stw	r23,0(r8)
 820fb90:	41c00115 	stw	r7,4(r8)
 820fb94:	d8801c15 	stw	r2,112(sp)
 820fb98:	d8c01b15 	stw	r3,108(sp)
 820fb9c:	68fff40e 	bge	r13,r3,820fb70 <___vfiprintf_internal_r+0x56c>
 820fba0:	1002241e 	bne	r2,zero,8210434 <___vfiprintf_internal_r+0xe30>
 820fba4:	843ffc04 	addi	r16,r16,-16
 820fba8:	01800044 	movi	r6,1
 820fbac:	000b883a 	mov	r5,zero
 820fbb0:	d811883a 	mov	r8,sp
 820fbb4:	3c3ff316 	blt	r7,r16,820fb84 <___vfiprintf_internal_r+0x580>
 820fbb8:	da402517 	ldw	r9,148(sp)
 820fbbc:	e007883a 	mov	r3,fp
 820fbc0:	8039883a 	mov	fp,r16
 820fbc4:	1821883a 	mov	r16,r3
 820fbc8:	d8c02417 	ldw	r3,144(sp)
 820fbcc:	1705883a 	add	r2,r2,fp
 820fbd0:	47000115 	stw	fp,4(r8)
 820fbd4:	40c00015 	stw	r3,0(r8)
 820fbd8:	d8801c15 	stw	r2,112(sp)
 820fbdc:	d9801b15 	stw	r6,108(sp)
 820fbe0:	00c001c4 	movi	r3,7
 820fbe4:	19827616 	blt	r3,r6,82105c0 <___vfiprintf_internal_r+0xfbc>
 820fbe8:	4cf9c83a 	sub	fp,r9,r19
 820fbec:	42000204 	addi	r8,r8,8
 820fbf0:	31000044 	addi	r4,r6,1
 820fbf4:	300b883a 	mov	r5,r6
 820fbf8:	07018516 	blt	zero,fp,8210210 <___vfiprintf_internal_r+0xc0c>
 820fbfc:	9885883a 	add	r2,r19,r2
 820fc00:	45400015 	stw	r21,0(r8)
 820fc04:	44c00115 	stw	r19,4(r8)
 820fc08:	d8801c15 	stw	r2,112(sp)
 820fc0c:	d9001b15 	stw	r4,108(sp)
 820fc10:	00c001c4 	movi	r3,7
 820fc14:	1901dd0e 	bge	r3,r4,821038c <___vfiprintf_internal_r+0xd88>
 820fc18:	1002401e 	bne	r2,zero,821051c <___vfiprintf_internal_r+0xf18>
 820fc1c:	d8001b15 	stw	zero,108(sp)
 820fc20:	a2c0010c 	andi	r11,r20,4
 820fc24:	58000226 	beq	r11,zero,820fc30 <___vfiprintf_internal_r+0x62c>
 820fc28:	8ca7c83a 	sub	r19,r17,r18
 820fc2c:	04c2f216 	blt	zero,r19,82107f8 <___vfiprintf_internal_r+0x11f4>
 820fc30:	8c80010e 	bge	r17,r18,820fc38 <___vfiprintf_internal_r+0x634>
 820fc34:	9023883a 	mov	r17,r18
 820fc38:	da802317 	ldw	r10,140(sp)
 820fc3c:	5455883a 	add	r10,r10,r17
 820fc40:	da802315 	stw	r10,140(sp)
 820fc44:	d8001b15 	stw	zero,108(sp)
 820fc48:	d811883a 	mov	r8,sp
 820fc4c:	003ea206 	br	820f6d8 <___vfiprintf_internal_r+0xd4>
 820fc50:	a5000814 	ori	r20,r20,32
 820fc54:	80c00007 	ldb	r3,0(r16)
 820fc58:	003ec906 	br	820f780 <___vfiprintf_internal_r+0x17c>
 820fc5c:	80c00007 	ldb	r3,0(r16)
 820fc60:	1b030926 	beq	r3,r12,8210888 <___vfiprintf_internal_r+0x1284>
 820fc64:	a5000414 	ori	r20,r20,16
 820fc68:	003ec506 	br	820f780 <___vfiprintf_internal_r+0x17c>
 820fc6c:	21003fcc 	andi	r4,r4,255
 820fc70:	20035e1e 	bne	r4,zero,82109ec <___vfiprintf_internal_r+0x13e8>
 820fc74:	a080080c 	andi	r2,r20,32
 820fc78:	1002a526 	beq	r2,zero,8210710 <___vfiprintf_internal_r+0x110c>
 820fc7c:	da802217 	ldw	r10,136(sp)
 820fc80:	50800017 	ldw	r2,0(r10)
 820fc84:	da802317 	ldw	r10,140(sp)
 820fc88:	5007d7fa 	srai	r3,r10,31
 820fc8c:	da802217 	ldw	r10,136(sp)
 820fc90:	10c00115 	stw	r3,4(r2)
 820fc94:	52800104 	addi	r10,r10,4
 820fc98:	da802215 	stw	r10,136(sp)
 820fc9c:	da802317 	ldw	r10,140(sp)
 820fca0:	12800015 	stw	r10,0(r2)
 820fca4:	003e8c06 	br	820f6d8 <___vfiprintf_internal_r+0xd4>
 820fca8:	21003fcc 	andi	r4,r4,255
 820fcac:	2003511e 	bne	r4,zero,82109f4 <___vfiprintf_internal_r+0x13f0>
 820fcb0:	a080080c 	andi	r2,r20,32
 820fcb4:	1000a126 	beq	r2,zero,820ff3c <___vfiprintf_internal_r+0x938>
 820fcb8:	da802217 	ldw	r10,136(sp)
 820fcbc:	d8001d85 	stb	zero,118(sp)
 820fcc0:	50800204 	addi	r2,r10,8
 820fcc4:	54800017 	ldw	r18,0(r10)
 820fcc8:	54c00117 	ldw	r19,4(r10)
 820fccc:	4802b416 	blt	r9,zero,82107a0 <___vfiprintf_internal_r+0x119c>
 820fcd0:	013fdfc4 	movi	r4,-129
 820fcd4:	94c6b03a 	or	r3,r18,r19
 820fcd8:	d8802215 	stw	r2,136(sp)
 820fcdc:	a128703a 	and	r20,r20,r4
 820fce0:	1800a226 	beq	r3,zero,820ff6c <___vfiprintf_internal_r+0x968>
 820fce4:	0039883a 	mov	fp,zero
 820fce8:	dd401a04 	addi	r21,sp,104
 820fcec:	9006d0fa 	srli	r3,r18,3
 820fcf0:	9808977a 	slli	r4,r19,29
 820fcf4:	9826d0fa 	srli	r19,r19,3
 820fcf8:	948001cc 	andi	r18,r18,7
 820fcfc:	90800c04 	addi	r2,r18,48
 820fd00:	ad7fffc4 	addi	r21,r21,-1
 820fd04:	20e4b03a 	or	r18,r4,r3
 820fd08:	a8800005 	stb	r2,0(r21)
 820fd0c:	94c6b03a 	or	r3,r18,r19
 820fd10:	183ff61e 	bne	r3,zero,820fcec <___vfiprintf_internal_r+0x6e8>
 820fd14:	a0c0004c 	andi	r3,r20,1
 820fd18:	18005926 	beq	r3,zero,820fe80 <___vfiprintf_internal_r+0x87c>
 820fd1c:	10803fcc 	andi	r2,r2,255
 820fd20:	1080201c 	xori	r2,r2,128
 820fd24:	10bfe004 	addi	r2,r2,-128
 820fd28:	00c00c04 	movi	r3,48
 820fd2c:	10c05426 	beq	r2,r3,820fe80 <___vfiprintf_internal_r+0x87c>
 820fd30:	da801e17 	ldw	r10,120(sp)
 820fd34:	a8bfffc4 	addi	r2,r21,-1
 820fd38:	a8ffffc5 	stb	r3,-1(r21)
 820fd3c:	50a7c83a 	sub	r19,r10,r2
 820fd40:	102b883a 	mov	r21,r2
 820fd44:	003f2f06 	br	820fa04 <___vfiprintf_internal_r+0x400>
 820fd48:	21003fcc 	andi	r4,r4,255
 820fd4c:	2003421e 	bne	r4,zero,8210a58 <___vfiprintf_internal_r+0x1454>
 820fd50:	00820974 	movhi	r2,2085
 820fd54:	10b6e504 	addi	r2,r2,-9324
 820fd58:	d8802615 	stw	r2,152(sp)
 820fd5c:	a080080c 	andi	r2,r20,32
 820fd60:	1000aa26 	beq	r2,zero,821000c <___vfiprintf_internal_r+0xa08>
 820fd64:	da802217 	ldw	r10,136(sp)
 820fd68:	54800017 	ldw	r18,0(r10)
 820fd6c:	54c00117 	ldw	r19,4(r10)
 820fd70:	52800204 	addi	r10,r10,8
 820fd74:	da802215 	stw	r10,136(sp)
 820fd78:	a080004c 	andi	r2,r20,1
 820fd7c:	1001d226 	beq	r2,zero,82104c8 <___vfiprintf_internal_r+0xec4>
 820fd80:	94c4b03a 	or	r2,r18,r19
 820fd84:	1002351e 	bne	r2,zero,821065c <___vfiprintf_internal_r+0x1058>
 820fd88:	d8001d85 	stb	zero,118(sp)
 820fd8c:	48022216 	blt	r9,zero,8210618 <___vfiprintf_internal_r+0x1014>
 820fd90:	00bfdfc4 	movi	r2,-129
 820fd94:	a0a8703a 	and	r20,r20,r2
 820fd98:	003f1506 	br	820f9f0 <___vfiprintf_internal_r+0x3ec>
 820fd9c:	da802217 	ldw	r10,136(sp)
 820fda0:	04800044 	movi	r18,1
 820fda4:	d8001d85 	stb	zero,118(sp)
 820fda8:	50800017 	ldw	r2,0(r10)
 820fdac:	52800104 	addi	r10,r10,4
 820fdb0:	da802215 	stw	r10,136(sp)
 820fdb4:	d8801005 	stb	r2,64(sp)
 820fdb8:	9027883a 	mov	r19,r18
 820fdbc:	dd401004 	addi	r21,sp,64
 820fdc0:	0013883a 	mov	r9,zero
 820fdc4:	003f1706 	br	820fa24 <___vfiprintf_internal_r+0x420>
 820fdc8:	21003fcc 	andi	r4,r4,255
 820fdcc:	2003201e 	bne	r4,zero,8210a50 <___vfiprintf_internal_r+0x144c>
 820fdd0:	a080080c 	andi	r2,r20,32
 820fdd4:	10004b26 	beq	r2,zero,820ff04 <___vfiprintf_internal_r+0x900>
 820fdd8:	da802217 	ldw	r10,136(sp)
 820fddc:	50800117 	ldw	r2,4(r10)
 820fde0:	54800017 	ldw	r18,0(r10)
 820fde4:	52800204 	addi	r10,r10,8
 820fde8:	da802215 	stw	r10,136(sp)
 820fdec:	1027883a 	mov	r19,r2
 820fdf0:	10022c16 	blt	r2,zero,82106a4 <___vfiprintf_internal_r+0x10a0>
 820fdf4:	df001d83 	ldbu	fp,118(sp)
 820fdf8:	48007216 	blt	r9,zero,820ffc4 <___vfiprintf_internal_r+0x9c0>
 820fdfc:	00ffdfc4 	movi	r3,-129
 820fe00:	94c4b03a 	or	r2,r18,r19
 820fe04:	a0e8703a 	and	r20,r20,r3
 820fe08:	1000cc26 	beq	r2,zero,821013c <___vfiprintf_internal_r+0xb38>
 820fe0c:	98021026 	beq	r19,zero,8210650 <___vfiprintf_internal_r+0x104c>
 820fe10:	dc402415 	stw	r17,144(sp)
 820fe14:	dc002515 	stw	r16,148(sp)
 820fe18:	9823883a 	mov	r17,r19
 820fe1c:	9021883a 	mov	r16,r18
 820fe20:	dd401a04 	addi	r21,sp,104
 820fe24:	4825883a 	mov	r18,r9
 820fe28:	4027883a 	mov	r19,r8
 820fe2c:	8009883a 	mov	r4,r16
 820fe30:	880b883a 	mov	r5,r17
 820fe34:	01800284 	movi	r6,10
 820fe38:	000f883a 	mov	r7,zero
 820fe3c:	821188c0 	call	821188c <__umoddi3>
 820fe40:	10800c04 	addi	r2,r2,48
 820fe44:	ad7fffc4 	addi	r21,r21,-1
 820fe48:	8009883a 	mov	r4,r16
 820fe4c:	880b883a 	mov	r5,r17
 820fe50:	a8800005 	stb	r2,0(r21)
 820fe54:	01800284 	movi	r6,10
 820fe58:	000f883a 	mov	r7,zero
 820fe5c:	82113140 	call	8211314 <__udivdi3>
 820fe60:	1021883a 	mov	r16,r2
 820fe64:	10c4b03a 	or	r2,r2,r3
 820fe68:	1823883a 	mov	r17,r3
 820fe6c:	103fef1e 	bne	r2,zero,820fe2c <___vfiprintf_internal_r+0x828>
 820fe70:	dc402417 	ldw	r17,144(sp)
 820fe74:	dc002517 	ldw	r16,148(sp)
 820fe78:	9013883a 	mov	r9,r18
 820fe7c:	9811883a 	mov	r8,r19
 820fe80:	da801e17 	ldw	r10,120(sp)
 820fe84:	5567c83a 	sub	r19,r10,r21
 820fe88:	003ede06 	br	820fa04 <___vfiprintf_internal_r+0x400>
 820fe8c:	38803fcc 	andi	r2,r7,255
 820fe90:	1080201c 	xori	r2,r2,128
 820fe94:	10bfe004 	addi	r2,r2,-128
 820fe98:	1002371e 	bne	r2,zero,8210778 <___vfiprintf_internal_r+0x1174>
 820fe9c:	01000044 	movi	r4,1
 820fea0:	01c00804 	movi	r7,32
 820fea4:	80c00007 	ldb	r3,0(r16)
 820fea8:	003e3506 	br	820f780 <___vfiprintf_internal_r+0x17c>
 820feac:	a5000054 	ori	r20,r20,1
 820feb0:	80c00007 	ldb	r3,0(r16)
 820feb4:	003e3206 	br	820f780 <___vfiprintf_internal_r+0x17c>
 820feb8:	a5002014 	ori	r20,r20,128
 820febc:	80c00007 	ldb	r3,0(r16)
 820fec0:	003e2f06 	br	820f780 <___vfiprintf_internal_r+0x17c>
 820fec4:	8015883a 	mov	r10,r16
 820fec8:	0023883a 	mov	r17,zero
 820fecc:	18bff404 	addi	r2,r3,-48
 820fed0:	50c00007 	ldb	r3,0(r10)
 820fed4:	8c4002a4 	muli	r17,r17,10
 820fed8:	84000044 	addi	r16,r16,1
 820fedc:	8015883a 	mov	r10,r16
 820fee0:	1463883a 	add	r17,r2,r17
 820fee4:	18bff404 	addi	r2,r3,-48
 820fee8:	30bff92e 	bgeu	r6,r2,820fed0 <___vfiprintf_internal_r+0x8cc>
 820feec:	003e2506 	br	820f784 <___vfiprintf_internal_r+0x180>
 820fef0:	21003fcc 	andi	r4,r4,255
 820fef4:	2002d41e 	bne	r4,zero,8210a48 <___vfiprintf_internal_r+0x1444>
 820fef8:	a5000414 	ori	r20,r20,16
 820fefc:	a080080c 	andi	r2,r20,32
 820ff00:	103fb51e 	bne	r2,zero,820fdd8 <___vfiprintf_internal_r+0x7d4>
 820ff04:	a080040c 	andi	r2,r20,16
 820ff08:	1001f826 	beq	r2,zero,82106ec <___vfiprintf_internal_r+0x10e8>
 820ff0c:	da802217 	ldw	r10,136(sp)
 820ff10:	54800017 	ldw	r18,0(r10)
 820ff14:	52800104 	addi	r10,r10,4
 820ff18:	da802215 	stw	r10,136(sp)
 820ff1c:	9027d7fa 	srai	r19,r18,31
 820ff20:	9805883a 	mov	r2,r19
 820ff24:	003fb206 	br	820fdf0 <___vfiprintf_internal_r+0x7ec>
 820ff28:	21003fcc 	andi	r4,r4,255
 820ff2c:	2002c41e 	bne	r4,zero,8210a40 <___vfiprintf_internal_r+0x143c>
 820ff30:	a5000414 	ori	r20,r20,16
 820ff34:	a080080c 	andi	r2,r20,32
 820ff38:	103f5f1e 	bne	r2,zero,820fcb8 <___vfiprintf_internal_r+0x6b4>
 820ff3c:	a080040c 	andi	r2,r20,16
 820ff40:	10020f26 	beq	r2,zero,8210780 <___vfiprintf_internal_r+0x117c>
 820ff44:	da802217 	ldw	r10,136(sp)
 820ff48:	d8001d85 	stb	zero,118(sp)
 820ff4c:	0027883a 	mov	r19,zero
 820ff50:	50800104 	addi	r2,r10,4
 820ff54:	54800017 	ldw	r18,0(r10)
 820ff58:	48021116 	blt	r9,zero,82107a0 <___vfiprintf_internal_r+0x119c>
 820ff5c:	00ffdfc4 	movi	r3,-129
 820ff60:	d8802215 	stw	r2,136(sp)
 820ff64:	a0e8703a 	and	r20,r20,r3
 820ff68:	903f5e1e 	bne	r18,zero,820fce4 <___vfiprintf_internal_r+0x6e0>
 820ff6c:	0039883a 	mov	fp,zero
 820ff70:	4802a626 	beq	r9,zero,8210a0c <___vfiprintf_internal_r+0x1408>
 820ff74:	0025883a 	mov	r18,zero
 820ff78:	0027883a 	mov	r19,zero
 820ff7c:	003f5a06 	br	820fce8 <___vfiprintf_internal_r+0x6e4>
 820ff80:	21003fcc 	andi	r4,r4,255
 820ff84:	20029f1e 	bne	r4,zero,8210a04 <___vfiprintf_internal_r+0x1400>
 820ff88:	a5000414 	ori	r20,r20,16
 820ff8c:	a080080c 	andi	r2,r20,32
 820ff90:	10005e1e 	bne	r2,zero,821010c <___vfiprintf_internal_r+0xb08>
 820ff94:	a080040c 	andi	r2,r20,16
 820ff98:	1001a21e 	bne	r2,zero,8210624 <___vfiprintf_internal_r+0x1020>
 820ff9c:	a080100c 	andi	r2,r20,64
 820ffa0:	d8001d85 	stb	zero,118(sp)
 820ffa4:	da802217 	ldw	r10,136(sp)
 820ffa8:	1002231e 	bne	r2,zero,8210838 <___vfiprintf_internal_r+0x1234>
 820ffac:	50800104 	addi	r2,r10,4
 820ffb0:	54800017 	ldw	r18,0(r10)
 820ffb4:	0027883a 	mov	r19,zero
 820ffb8:	4801a00e 	bge	r9,zero,821063c <___vfiprintf_internal_r+0x1038>
 820ffbc:	d8802215 	stw	r2,136(sp)
 820ffc0:	0039883a 	mov	fp,zero
 820ffc4:	94c4b03a 	or	r2,r18,r19
 820ffc8:	103f901e 	bne	r2,zero,820fe0c <___vfiprintf_internal_r+0x808>
 820ffcc:	00800044 	movi	r2,1
 820ffd0:	10803fcc 	andi	r2,r2,255
 820ffd4:	00c00044 	movi	r3,1
 820ffd8:	10c05926 	beq	r2,r3,8210140 <___vfiprintf_internal_r+0xb3c>
 820ffdc:	00c00084 	movi	r3,2
 820ffe0:	10ffe41e 	bne	r2,r3,820ff74 <___vfiprintf_internal_r+0x970>
 820ffe4:	0025883a 	mov	r18,zero
 820ffe8:	0027883a 	mov	r19,zero
 820ffec:	00013d06 	br	82104e4 <___vfiprintf_internal_r+0xee0>
 820fff0:	21003fcc 	andi	r4,r4,255
 820fff4:	2002811e 	bne	r4,zero,82109fc <___vfiprintf_internal_r+0x13f8>
 820fff8:	00820974 	movhi	r2,2085
 820fffc:	10b6e004 	addi	r2,r2,-9344
 8210000:	d8802615 	stw	r2,152(sp)
 8210004:	a080080c 	andi	r2,r20,32
 8210008:	103f561e 	bne	r2,zero,820fd64 <___vfiprintf_internal_r+0x760>
 821000c:	a080040c 	andi	r2,r20,16
 8210010:	1001d126 	beq	r2,zero,8210758 <___vfiprintf_internal_r+0x1154>
 8210014:	da802217 	ldw	r10,136(sp)
 8210018:	0027883a 	mov	r19,zero
 821001c:	54800017 	ldw	r18,0(r10)
 8210020:	52800104 	addi	r10,r10,4
 8210024:	da802215 	stw	r10,136(sp)
 8210028:	003f5306 	br	820fd78 <___vfiprintf_internal_r+0x774>
 821002c:	da802217 	ldw	r10,136(sp)
 8210030:	d8001d85 	stb	zero,118(sp)
 8210034:	55400017 	ldw	r21,0(r10)
 8210038:	50c00104 	addi	r3,r10,4
 821003c:	a8024226 	beq	r21,zero,8210948 <___vfiprintf_internal_r+0x1344>
 8210040:	48021816 	blt	r9,zero,82108a4 <___vfiprintf_internal_r+0x12a0>
 8210044:	480d883a 	mov	r6,r9
 8210048:	000b883a 	mov	r5,zero
 821004c:	a809883a 	mov	r4,r21
 8210050:	d8c02a15 	stw	r3,168(sp)
 8210054:	da002b15 	stw	r8,172(sp)
 8210058:	da402c15 	stw	r9,176(sp)
 821005c:	820c5540 	call	820c554 <memchr>
 8210060:	d8c02a17 	ldw	r3,168(sp)
 8210064:	da002b17 	ldw	r8,172(sp)
 8210068:	da402c17 	ldw	r9,176(sp)
 821006c:	10024826 	beq	r2,zero,8210990 <___vfiprintf_internal_r+0x138c>
 8210070:	1567c83a 	sub	r19,r2,r21
 8210074:	df001d83 	ldbu	fp,118(sp)
 8210078:	d8c02215 	stw	r3,136(sp)
 821007c:	0013883a 	mov	r9,zero
 8210080:	003e6006 	br	820fa04 <___vfiprintf_internal_r+0x400>
 8210084:	21003fcc 	andi	r4,r4,255
 8210088:	203fc026 	beq	r4,zero,820ff8c <___vfiprintf_internal_r+0x988>
 821008c:	d9c01d85 	stb	r7,118(sp)
 8210090:	003fbe06 	br	820ff8c <___vfiprintf_internal_r+0x988>
 8210094:	da802217 	ldw	r10,136(sp)
 8210098:	54400017 	ldw	r17,0(r10)
 821009c:	50800104 	addi	r2,r10,4
 82100a0:	883e3b16 	blt	r17,zero,820f990 <___vfiprintf_internal_r+0x38c>
 82100a4:	d8802215 	stw	r2,136(sp)
 82100a8:	80c00007 	ldb	r3,0(r16)
 82100ac:	003db406 	br	820f780 <___vfiprintf_internal_r+0x17c>
 82100b0:	01000044 	movi	r4,1
 82100b4:	01c00ac4 	movi	r7,43
 82100b8:	80c00007 	ldb	r3,0(r16)
 82100bc:	003db006 	br	820f780 <___vfiprintf_internal_r+0x17c>
 82100c0:	80c00007 	ldb	r3,0(r16)
 82100c4:	82800044 	addi	r10,r16,1
 82100c8:	1b423c26 	beq	r3,r13,82109bc <___vfiprintf_internal_r+0x13b8>
 82100cc:	18bff404 	addi	r2,r3,-48
 82100d0:	0013883a 	mov	r9,zero
 82100d4:	30822b36 	bltu	r6,r2,8210984 <___vfiprintf_internal_r+0x1380>
 82100d8:	50c00007 	ldb	r3,0(r10)
 82100dc:	4a4002a4 	muli	r9,r9,10
 82100e0:	54000044 	addi	r16,r10,1
 82100e4:	8015883a 	mov	r10,r16
 82100e8:	4893883a 	add	r9,r9,r2
 82100ec:	18bff404 	addi	r2,r3,-48
 82100f0:	30bff92e 	bgeu	r6,r2,82100d8 <___vfiprintf_internal_r+0xad4>
 82100f4:	483da30e 	bge	r9,zero,820f784 <___vfiprintf_internal_r+0x180>
 82100f8:	027fffc4 	movi	r9,-1
 82100fc:	003da106 	br	820f784 <___vfiprintf_internal_r+0x180>
 8210100:	a5001014 	ori	r20,r20,64
 8210104:	80c00007 	ldb	r3,0(r16)
 8210108:	003d9d06 	br	820f780 <___vfiprintf_internal_r+0x17c>
 821010c:	da802217 	ldw	r10,136(sp)
 8210110:	d8001d85 	stb	zero,118(sp)
 8210114:	50c00204 	addi	r3,r10,8
 8210118:	54800017 	ldw	r18,0(r10)
 821011c:	54c00117 	ldw	r19,4(r10)
 8210120:	4801ca16 	blt	r9,zero,821084c <___vfiprintf_internal_r+0x1248>
 8210124:	013fdfc4 	movi	r4,-129
 8210128:	94c4b03a 	or	r2,r18,r19
 821012c:	d8c02215 	stw	r3,136(sp)
 8210130:	a128703a 	and	r20,r20,r4
 8210134:	0039883a 	mov	fp,zero
 8210138:	103f341e 	bne	r2,zero,820fe0c <___vfiprintf_internal_r+0x808>
 821013c:	483e2e26 	beq	r9,zero,820f9f8 <___vfiprintf_internal_r+0x3f4>
 8210140:	0025883a 	mov	r18,zero
 8210144:	94800c04 	addi	r18,r18,48
 8210148:	dc8019c5 	stb	r18,103(sp)
 821014c:	dcc02717 	ldw	r19,156(sp)
 8210150:	dd4019c4 	addi	r21,sp,103
 8210154:	003e2b06 	br	820fa04 <___vfiprintf_internal_r+0x400>
 8210158:	21003fcc 	andi	r4,r4,255
 821015c:	2002361e 	bne	r4,zero,8210a38 <___vfiprintf_internal_r+0x1434>
 8210160:	1801c126 	beq	r3,zero,8210868 <___vfiprintf_internal_r+0x1264>
 8210164:	04800044 	movi	r18,1
 8210168:	d8c01005 	stb	r3,64(sp)
 821016c:	d8001d85 	stb	zero,118(sp)
 8210170:	9027883a 	mov	r19,r18
 8210174:	dd401004 	addi	r21,sp,64
 8210178:	003f1106 	br	820fdc0 <___vfiprintf_internal_r+0x7bc>
 821017c:	d9402117 	ldw	r5,132(sp)
 8210180:	d9002017 	ldw	r4,128(sp)
 8210184:	d9801a04 	addi	r6,sp,104
 8210188:	d9c02b15 	stw	r7,172(sp)
 821018c:	dbc02a15 	stw	r15,168(sp)
 8210190:	820f4f00 	call	820f4f0 <__sprint_r.part.0>
 8210194:	d9c02b17 	ldw	r7,172(sp)
 8210198:	dbc02a17 	ldw	r15,168(sp)
 821019c:	10006d1e 	bne	r2,zero,8210354 <___vfiprintf_internal_r+0xd50>
 82101a0:	d9801b17 	ldw	r6,108(sp)
 82101a4:	d8801c17 	ldw	r2,112(sp)
 82101a8:	d811883a 	mov	r8,sp
 82101ac:	31400044 	addi	r5,r6,1
 82101b0:	003e3306 	br	820fa80 <___vfiprintf_internal_r+0x47c>
 82101b4:	d9401b17 	ldw	r5,108(sp)
 82101b8:	d8801c17 	ldw	r2,112(sp)
 82101bc:	29000044 	addi	r4,r5,1
 82101c0:	d8c01d87 	ldb	r3,118(sp)
 82101c4:	183e4d26 	beq	r3,zero,820fafc <___vfiprintf_internal_r+0x4f8>
 82101c8:	00c00044 	movi	r3,1
 82101cc:	d9401d84 	addi	r5,sp,118
 82101d0:	10c5883a 	add	r2,r2,r3
 82101d4:	41400015 	stw	r5,0(r8)
 82101d8:	40c00115 	stw	r3,4(r8)
 82101dc:	d8801c15 	stw	r2,112(sp)
 82101e0:	d9001b15 	stw	r4,108(sp)
 82101e4:	014001c4 	movi	r5,7
 82101e8:	2900a90e 	bge	r5,r4,8210490 <___vfiprintf_internal_r+0xe8c>
 82101ec:	1000da1e 	bne	r2,zero,8210558 <___vfiprintf_internal_r+0xf54>
 82101f0:	7000ab1e 	bne	r14,zero,82104a0 <___vfiprintf_internal_r+0xe9c>
 82101f4:	000b883a 	mov	r5,zero
 82101f8:	1809883a 	mov	r4,r3
 82101fc:	d811883a 	mov	r8,sp
 8210200:	00c02004 	movi	r3,128
 8210204:	e0fe4d26 	beq	fp,r3,820fb3c <___vfiprintf_internal_r+0x538>
 8210208:	4cf9c83a 	sub	fp,r9,r19
 821020c:	073e7b0e 	bge	zero,fp,820fbfc <___vfiprintf_internal_r+0x5f8>
 8210210:	01c00404 	movi	r7,16
 8210214:	3f01900e 	bge	r7,fp,8210858 <___vfiprintf_internal_r+0x1254>
 8210218:	00c20974 	movhi	r3,2085
 821021c:	18f75504 	addi	r3,r3,-8876
 8210220:	d8c02415 	stw	r3,144(sp)
 8210224:	034001c4 	movi	r13,7
 8210228:	00000506 	br	8210240 <___vfiprintf_internal_r+0xc3c>
 821022c:	29000084 	addi	r4,r5,2
 8210230:	42000204 	addi	r8,r8,8
 8210234:	180b883a 	mov	r5,r3
 8210238:	e73ffc04 	addi	fp,fp,-16
 821023c:	3f000d0e 	bge	r7,fp,8210274 <___vfiprintf_internal_r+0xc70>
 8210240:	10800404 	addi	r2,r2,16
 8210244:	28c00044 	addi	r3,r5,1
 8210248:	45c00015 	stw	r23,0(r8)
 821024c:	41c00115 	stw	r7,4(r8)
 8210250:	d8801c15 	stw	r2,112(sp)
 8210254:	d8c01b15 	stw	r3,108(sp)
 8210258:	68fff40e 	bge	r13,r3,821022c <___vfiprintf_internal_r+0xc28>
 821025c:	1000101e 	bne	r2,zero,82102a0 <___vfiprintf_internal_r+0xc9c>
 8210260:	e73ffc04 	addi	fp,fp,-16
 8210264:	01000044 	movi	r4,1
 8210268:	000b883a 	mov	r5,zero
 821026c:	d811883a 	mov	r8,sp
 8210270:	3f3ff316 	blt	r7,fp,8210240 <___vfiprintf_internal_r+0xc3c>
 8210274:	da802417 	ldw	r10,144(sp)
 8210278:	1705883a 	add	r2,r2,fp
 821027c:	47000115 	stw	fp,4(r8)
 8210280:	42800015 	stw	r10,0(r8)
 8210284:	d8801c15 	stw	r2,112(sp)
 8210288:	d9001b15 	stw	r4,108(sp)
 821028c:	00c001c4 	movi	r3,7
 8210290:	19003616 	blt	r3,r4,821036c <___vfiprintf_internal_r+0xd68>
 8210294:	42000204 	addi	r8,r8,8
 8210298:	21000044 	addi	r4,r4,1
 821029c:	003e5706 	br	820fbfc <___vfiprintf_internal_r+0x5f8>
 82102a0:	d9402117 	ldw	r5,132(sp)
 82102a4:	d9002017 	ldw	r4,128(sp)
 82102a8:	d9801a04 	addi	r6,sp,104
 82102ac:	d9c02b15 	stw	r7,172(sp)
 82102b0:	db402a15 	stw	r13,168(sp)
 82102b4:	820f4f00 	call	820f4f0 <__sprint_r.part.0>
 82102b8:	d9c02b17 	ldw	r7,172(sp)
 82102bc:	db402a17 	ldw	r13,168(sp)
 82102c0:	1000241e 	bne	r2,zero,8210354 <___vfiprintf_internal_r+0xd50>
 82102c4:	d9401b17 	ldw	r5,108(sp)
 82102c8:	d8801c17 	ldw	r2,112(sp)
 82102cc:	d811883a 	mov	r8,sp
 82102d0:	29000044 	addi	r4,r5,1
 82102d4:	003fd806 	br	8210238 <___vfiprintf_internal_r+0xc34>
 82102d8:	d9401b17 	ldw	r5,108(sp)
 82102dc:	00c20974 	movhi	r3,2085
 82102e0:	18f75904 	addi	r3,r3,-8860
 82102e4:	d8c02415 	stw	r3,144(sp)
 82102e8:	29400044 	addi	r5,r5,1
 82102ec:	d8c02417 	ldw	r3,144(sp)
 82102f0:	14c5883a 	add	r2,r2,r19
 82102f4:	44c00115 	stw	r19,4(r8)
 82102f8:	40c00015 	stw	r3,0(r8)
 82102fc:	d8801c15 	stw	r2,112(sp)
 8210300:	d9401b15 	stw	r5,108(sp)
 8210304:	00c001c4 	movi	r3,7
 8210308:	1940070e 	bge	r3,r5,8210328 <___vfiprintf_internal_r+0xd24>
 821030c:	103e4826 	beq	r2,zero,820fc30 <___vfiprintf_internal_r+0x62c>
 8210310:	d9402117 	ldw	r5,132(sp)
 8210314:	d9002017 	ldw	r4,128(sp)
 8210318:	d9801a04 	addi	r6,sp,104
 821031c:	820f4f00 	call	820f4f0 <__sprint_r.part.0>
 8210320:	10000c1e 	bne	r2,zero,8210354 <___vfiprintf_internal_r+0xd50>
 8210324:	d8801c17 	ldw	r2,112(sp)
 8210328:	8c80010e 	bge	r17,r18,8210330 <___vfiprintf_internal_r+0xd2c>
 821032c:	9023883a 	mov	r17,r18
 8210330:	da802317 	ldw	r10,140(sp)
 8210334:	5455883a 	add	r10,r10,r17
 8210338:	da802315 	stw	r10,140(sp)
 821033c:	103e4126 	beq	r2,zero,820fc44 <___vfiprintf_internal_r+0x640>
 8210340:	d9402117 	ldw	r5,132(sp)
 8210344:	d9002017 	ldw	r4,128(sp)
 8210348:	d9801a04 	addi	r6,sp,104
 821034c:	820f4f00 	call	820f4f0 <__sprint_r.part.0>
 8210350:	103e3c26 	beq	r2,zero,820fc44 <___vfiprintf_internal_r+0x640>
 8210354:	dd002117 	ldw	r20,132(sp)
 8210358:	a080030b 	ldhu	r2,12(r20)
 821035c:	1080100c 	andi	r2,r2,64
 8210360:	1001231e 	bne	r2,zero,82107f0 <___vfiprintf_internal_r+0x11ec>
 8210364:	d8802317 	ldw	r2,140(sp)
 8210368:	003d7b06 	br	820f958 <___vfiprintf_internal_r+0x354>
 821036c:	1000991e 	bne	r2,zero,82105d4 <___vfiprintf_internal_r+0xfd0>
 8210370:	00c00044 	movi	r3,1
 8210374:	9805883a 	mov	r2,r19
 8210378:	dd400015 	stw	r21,0(sp)
 821037c:	dcc00115 	stw	r19,4(sp)
 8210380:	dcc01c15 	stw	r19,112(sp)
 8210384:	d8c01b15 	stw	r3,108(sp)
 8210388:	d811883a 	mov	r8,sp
 821038c:	42000204 	addi	r8,r8,8
 8210390:	a2c0010c 	andi	r11,r20,4
 8210394:	583fe426 	beq	r11,zero,8210328 <___vfiprintf_internal_r+0xd24>
 8210398:	8ca7c83a 	sub	r19,r17,r18
 821039c:	04ffe20e 	bge	zero,r19,8210328 <___vfiprintf_internal_r+0xd24>
 82103a0:	01c00404 	movi	r7,16
 82103a4:	3cffcc0e 	bge	r7,r19,82102d8 <___vfiprintf_internal_r+0xcd4>
 82103a8:	02820974 	movhi	r10,2085
 82103ac:	52b75904 	addi	r10,r10,-8860
 82103b0:	d9001b17 	ldw	r4,108(sp)
 82103b4:	da802415 	stw	r10,144(sp)
 82103b8:	382b883a 	mov	r21,r7
 82103bc:	050001c4 	movi	r20,7
 82103c0:	df002017 	ldw	fp,128(sp)
 82103c4:	00000506 	br	82103dc <___vfiprintf_internal_r+0xdd8>
 82103c8:	21400084 	addi	r5,r4,2
 82103cc:	42000204 	addi	r8,r8,8
 82103d0:	1809883a 	mov	r4,r3
 82103d4:	9cfffc04 	addi	r19,r19,-16
 82103d8:	acffc40e 	bge	r21,r19,82102ec <___vfiprintf_internal_r+0xce8>
 82103dc:	10800404 	addi	r2,r2,16
 82103e0:	20c00044 	addi	r3,r4,1
 82103e4:	45800015 	stw	r22,0(r8)
 82103e8:	45400115 	stw	r21,4(r8)
 82103ec:	d8801c15 	stw	r2,112(sp)
 82103f0:	d8c01b15 	stw	r3,108(sp)
 82103f4:	a0fff40e 	bge	r20,r3,82103c8 <___vfiprintf_internal_r+0xdc4>
 82103f8:	1000041e 	bne	r2,zero,821040c <___vfiprintf_internal_r+0xe08>
 82103fc:	01400044 	movi	r5,1
 8210400:	0009883a 	mov	r4,zero
 8210404:	d811883a 	mov	r8,sp
 8210408:	003ff206 	br	82103d4 <___vfiprintf_internal_r+0xdd0>
 821040c:	d9402117 	ldw	r5,132(sp)
 8210410:	d9801a04 	addi	r6,sp,104
 8210414:	e009883a 	mov	r4,fp
 8210418:	820f4f00 	call	820f4f0 <__sprint_r.part.0>
 821041c:	103fcd1e 	bne	r2,zero,8210354 <___vfiprintf_internal_r+0xd50>
 8210420:	d9001b17 	ldw	r4,108(sp)
 8210424:	d8801c17 	ldw	r2,112(sp)
 8210428:	d811883a 	mov	r8,sp
 821042c:	21400044 	addi	r5,r4,1
 8210430:	003fe806 	br	82103d4 <___vfiprintf_internal_r+0xdd0>
 8210434:	d9402117 	ldw	r5,132(sp)
 8210438:	d9002017 	ldw	r4,128(sp)
 821043c:	d9801a04 	addi	r6,sp,104
 8210440:	d9c02b15 	stw	r7,172(sp)
 8210444:	db402a15 	stw	r13,168(sp)
 8210448:	820f4f00 	call	820f4f0 <__sprint_r.part.0>
 821044c:	d9c02b17 	ldw	r7,172(sp)
 8210450:	db402a17 	ldw	r13,168(sp)
 8210454:	103fbf1e 	bne	r2,zero,8210354 <___vfiprintf_internal_r+0xd50>
 8210458:	d9401b17 	ldw	r5,108(sp)
 821045c:	d8801c17 	ldw	r2,112(sp)
 8210460:	d811883a 	mov	r8,sp
 8210464:	29800044 	addi	r6,r5,1
 8210468:	003dc406 	br	820fb7c <___vfiprintf_internal_r+0x578>
 821046c:	1000d21e 	bne	r2,zero,82107b8 <___vfiprintf_internal_r+0x11b4>
 8210470:	d8c01d87 	ldb	r3,118(sp)
 8210474:	18009526 	beq	r3,zero,82106cc <___vfiprintf_internal_r+0x10c8>
 8210478:	00800044 	movi	r2,1
 821047c:	d8c01d84 	addi	r3,sp,118
 8210480:	1009883a 	mov	r4,r2
 8210484:	d8c00015 	stw	r3,0(sp)
 8210488:	d8800115 	stw	r2,4(sp)
 821048c:	d811883a 	mov	r8,sp
 8210490:	200b883a 	mov	r5,r4
 8210494:	42000204 	addi	r8,r8,8
 8210498:	21000044 	addi	r4,r4,1
 821049c:	003d9706 	br	820fafc <___vfiprintf_internal_r+0x4f8>
 82104a0:	d9001d04 	addi	r4,sp,116
 82104a4:	00800084 	movi	r2,2
 82104a8:	d9000015 	stw	r4,0(sp)
 82104ac:	d8800115 	stw	r2,4(sp)
 82104b0:	1809883a 	mov	r4,r3
 82104b4:	d811883a 	mov	r8,sp
 82104b8:	200b883a 	mov	r5,r4
 82104bc:	42000204 	addi	r8,r8,8
 82104c0:	21000044 	addi	r4,r4,1
 82104c4:	003f4e06 	br	8210200 <___vfiprintf_internal_r+0xbfc>
 82104c8:	d8001d85 	stb	zero,118(sp)
 82104cc:	48005016 	blt	r9,zero,8210610 <___vfiprintf_internal_r+0x100c>
 82104d0:	00ffdfc4 	movi	r3,-129
 82104d4:	94c4b03a 	or	r2,r18,r19
 82104d8:	a0e8703a 	and	r20,r20,r3
 82104dc:	103d4426 	beq	r2,zero,820f9f0 <___vfiprintf_internal_r+0x3ec>
 82104e0:	0039883a 	mov	fp,zero
 82104e4:	d9002617 	ldw	r4,152(sp)
 82104e8:	dd401a04 	addi	r21,sp,104
 82104ec:	908003cc 	andi	r2,r18,15
 82104f0:	9806973a 	slli	r3,r19,28
 82104f4:	2085883a 	add	r2,r4,r2
 82104f8:	9024d13a 	srli	r18,r18,4
 82104fc:	10800003 	ldbu	r2,0(r2)
 8210500:	9826d13a 	srli	r19,r19,4
 8210504:	ad7fffc4 	addi	r21,r21,-1
 8210508:	1ca4b03a 	or	r18,r3,r18
 821050c:	a8800005 	stb	r2,0(r21)
 8210510:	94c4b03a 	or	r2,r18,r19
 8210514:	103ff51e 	bne	r2,zero,82104ec <___vfiprintf_internal_r+0xee8>
 8210518:	003e5906 	br	820fe80 <___vfiprintf_internal_r+0x87c>
 821051c:	d9402117 	ldw	r5,132(sp)
 8210520:	d9002017 	ldw	r4,128(sp)
 8210524:	d9801a04 	addi	r6,sp,104
 8210528:	820f4f00 	call	820f4f0 <__sprint_r.part.0>
 821052c:	103f891e 	bne	r2,zero,8210354 <___vfiprintf_internal_r+0xd50>
 8210530:	d8801c17 	ldw	r2,112(sp)
 8210534:	d811883a 	mov	r8,sp
 8210538:	003f9506 	br	8210390 <___vfiprintf_internal_r+0xd8c>
 821053c:	d9402117 	ldw	r5,132(sp)
 8210540:	d9002017 	ldw	r4,128(sp)
 8210544:	d9801a04 	addi	r6,sp,104
 8210548:	820f4f00 	call	820f4f0 <__sprint_r.part.0>
 821054c:	103f811e 	bne	r2,zero,8210354 <___vfiprintf_internal_r+0xd50>
 8210550:	d811883a 	mov	r8,sp
 8210554:	003ced06 	br	820f90c <___vfiprintf_internal_r+0x308>
 8210558:	d9402117 	ldw	r5,132(sp)
 821055c:	d9002017 	ldw	r4,128(sp)
 8210560:	d9801a04 	addi	r6,sp,104
 8210564:	da402c15 	stw	r9,176(sp)
 8210568:	db802a15 	stw	r14,168(sp)
 821056c:	820f4f00 	call	820f4f0 <__sprint_r.part.0>
 8210570:	da402c17 	ldw	r9,176(sp)
 8210574:	db802a17 	ldw	r14,168(sp)
 8210578:	103f761e 	bne	r2,zero,8210354 <___vfiprintf_internal_r+0xd50>
 821057c:	d9401b17 	ldw	r5,108(sp)
 8210580:	d8801c17 	ldw	r2,112(sp)
 8210584:	d811883a 	mov	r8,sp
 8210588:	29000044 	addi	r4,r5,1
 821058c:	003d5b06 	br	820fafc <___vfiprintf_internal_r+0x4f8>
 8210590:	d9402117 	ldw	r5,132(sp)
 8210594:	d9002017 	ldw	r4,128(sp)
 8210598:	d9801a04 	addi	r6,sp,104
 821059c:	da402c15 	stw	r9,176(sp)
 82105a0:	820f4f00 	call	820f4f0 <__sprint_r.part.0>
 82105a4:	da402c17 	ldw	r9,176(sp)
 82105a8:	103f6a1e 	bne	r2,zero,8210354 <___vfiprintf_internal_r+0xd50>
 82105ac:	d9401b17 	ldw	r5,108(sp)
 82105b0:	d8801c17 	ldw	r2,112(sp)
 82105b4:	d811883a 	mov	r8,sp
 82105b8:	29000044 	addi	r4,r5,1
 82105bc:	003f1006 	br	8210200 <___vfiprintf_internal_r+0xbfc>
 82105c0:	1000c31e 	bne	r2,zero,82108d0 <___vfiprintf_internal_r+0x12cc>
 82105c4:	01000044 	movi	r4,1
 82105c8:	000b883a 	mov	r5,zero
 82105cc:	d811883a 	mov	r8,sp
 82105d0:	003f0d06 	br	8210208 <___vfiprintf_internal_r+0xc04>
 82105d4:	d9402117 	ldw	r5,132(sp)
 82105d8:	d9002017 	ldw	r4,128(sp)
 82105dc:	d9801a04 	addi	r6,sp,104
 82105e0:	820f4f00 	call	820f4f0 <__sprint_r.part.0>
 82105e4:	103f5b1e 	bne	r2,zero,8210354 <___vfiprintf_internal_r+0xd50>
 82105e8:	d9001b17 	ldw	r4,108(sp)
 82105ec:	d8801c17 	ldw	r2,112(sp)
 82105f0:	d811883a 	mov	r8,sp
 82105f4:	21000044 	addi	r4,r4,1
 82105f8:	003d8006 	br	820fbfc <___vfiprintf_internal_r+0x5f8>
 82105fc:	01020974 	movhi	r4,2085
 8210600:	2136e504 	addi	r4,r4,-9324
 8210604:	d9002615 	stw	r4,152(sp)
 8210608:	d8c02215 	stw	r3,136(sp)
 821060c:	1029883a 	mov	r20,r2
 8210610:	94c4b03a 	or	r2,r18,r19
 8210614:	103fb21e 	bne	r2,zero,82104e0 <___vfiprintf_internal_r+0xedc>
 8210618:	0039883a 	mov	fp,zero
 821061c:	00800084 	movi	r2,2
 8210620:	003e6b06 	br	820ffd0 <___vfiprintf_internal_r+0x9cc>
 8210624:	da802217 	ldw	r10,136(sp)
 8210628:	d8001d85 	stb	zero,118(sp)
 821062c:	0027883a 	mov	r19,zero
 8210630:	50800104 	addi	r2,r10,4
 8210634:	54800017 	ldw	r18,0(r10)
 8210638:	483e6016 	blt	r9,zero,820ffbc <___vfiprintf_internal_r+0x9b8>
 821063c:	00ffdfc4 	movi	r3,-129
 8210640:	d8802215 	stw	r2,136(sp)
 8210644:	a0e8703a 	and	r20,r20,r3
 8210648:	0039883a 	mov	fp,zero
 821064c:	903ebb26 	beq	r18,zero,821013c <___vfiprintf_internal_r+0xb38>
 8210650:	00800244 	movi	r2,9
 8210654:	14bdee36 	bltu	r2,r18,820fe10 <___vfiprintf_internal_r+0x80c>
 8210658:	003eba06 	br	8210144 <___vfiprintf_internal_r+0xb40>
 821065c:	00800c04 	movi	r2,48
 8210660:	d8c01d45 	stb	r3,117(sp)
 8210664:	d8801d05 	stb	r2,116(sp)
 8210668:	d8001d85 	stb	zero,118(sp)
 821066c:	a0c00094 	ori	r3,r20,2
 8210670:	4800a916 	blt	r9,zero,8210918 <___vfiprintf_internal_r+0x1314>
 8210674:	00bfdfc4 	movi	r2,-129
 8210678:	a096703a 	and	r11,r20,r2
 821067c:	5d000094 	ori	r20,r11,2
 8210680:	0039883a 	mov	fp,zero
 8210684:	003f9706 	br	82104e4 <___vfiprintf_internal_r+0xee0>
 8210688:	8025883a 	mov	r18,r16
 821068c:	003c2e06 	br	820f748 <___vfiprintf_internal_r+0x144>
 8210690:	00820974 	movhi	r2,2085
 8210694:	10b6e504 	addi	r2,r2,-9324
 8210698:	0039883a 	mov	fp,zero
 821069c:	d8802615 	stw	r2,152(sp)
 82106a0:	003f9006 	br	82104e4 <___vfiprintf_internal_r+0xee0>
 82106a4:	04a5c83a 	sub	r18,zero,r18
 82106a8:	07000b44 	movi	fp,45
 82106ac:	9004c03a 	cmpne	r2,r18,zero
 82106b0:	04e7c83a 	sub	r19,zero,r19
 82106b4:	df001d85 	stb	fp,118(sp)
 82106b8:	98a7c83a 	sub	r19,r19,r2
 82106bc:	48009f16 	blt	r9,zero,821093c <___vfiprintf_internal_r+0x1338>
 82106c0:	00bfdfc4 	movi	r2,-129
 82106c4:	a0a8703a 	and	r20,r20,r2
 82106c8:	003dd006 	br	820fe0c <___vfiprintf_internal_r+0x808>
 82106cc:	70004c26 	beq	r14,zero,8210800 <___vfiprintf_internal_r+0x11fc>
 82106d0:	00800084 	movi	r2,2
 82106d4:	d8c01d04 	addi	r3,sp,116
 82106d8:	d8c00015 	stw	r3,0(sp)
 82106dc:	d8800115 	stw	r2,4(sp)
 82106e0:	01000044 	movi	r4,1
 82106e4:	d811883a 	mov	r8,sp
 82106e8:	003f7306 	br	82104b8 <___vfiprintf_internal_r+0xeb4>
 82106ec:	a080100c 	andi	r2,r20,64
 82106f0:	da802217 	ldw	r10,136(sp)
 82106f4:	103e0626 	beq	r2,zero,820ff10 <___vfiprintf_internal_r+0x90c>
 82106f8:	5480000f 	ldh	r18,0(r10)
 82106fc:	52800104 	addi	r10,r10,4
 8210700:	da802215 	stw	r10,136(sp)
 8210704:	9027d7fa 	srai	r19,r18,31
 8210708:	9805883a 	mov	r2,r19
 821070c:	003db806 	br	820fdf0 <___vfiprintf_internal_r+0x7ec>
 8210710:	a080040c 	andi	r2,r20,16
 8210714:	1000091e 	bne	r2,zero,821073c <___vfiprintf_internal_r+0x1138>
 8210718:	a2c0100c 	andi	r11,r20,64
 821071c:	58000726 	beq	r11,zero,821073c <___vfiprintf_internal_r+0x1138>
 8210720:	da802217 	ldw	r10,136(sp)
 8210724:	50800017 	ldw	r2,0(r10)
 8210728:	52800104 	addi	r10,r10,4
 821072c:	da802215 	stw	r10,136(sp)
 8210730:	da802317 	ldw	r10,140(sp)
 8210734:	1280000d 	sth	r10,0(r2)
 8210738:	003be706 	br	820f6d8 <___vfiprintf_internal_r+0xd4>
 821073c:	da802217 	ldw	r10,136(sp)
 8210740:	50800017 	ldw	r2,0(r10)
 8210744:	52800104 	addi	r10,r10,4
 8210748:	da802215 	stw	r10,136(sp)
 821074c:	da802317 	ldw	r10,140(sp)
 8210750:	12800015 	stw	r10,0(r2)
 8210754:	003be006 	br	820f6d8 <___vfiprintf_internal_r+0xd4>
 8210758:	a080100c 	andi	r2,r20,64
 821075c:	da802217 	ldw	r10,136(sp)
 8210760:	10003026 	beq	r2,zero,8210824 <___vfiprintf_internal_r+0x1220>
 8210764:	5480000b 	ldhu	r18,0(r10)
 8210768:	52800104 	addi	r10,r10,4
 821076c:	0027883a 	mov	r19,zero
 8210770:	da802215 	stw	r10,136(sp)
 8210774:	003d8006 	br	820fd78 <___vfiprintf_internal_r+0x774>
 8210778:	80c00007 	ldb	r3,0(r16)
 821077c:	003c0006 	br	820f780 <___vfiprintf_internal_r+0x17c>
 8210780:	a080100c 	andi	r2,r20,64
 8210784:	d8001d85 	stb	zero,118(sp)
 8210788:	da802217 	ldw	r10,136(sp)
 821078c:	1000201e 	bne	r2,zero,8210810 <___vfiprintf_internal_r+0x120c>
 8210790:	50800104 	addi	r2,r10,4
 8210794:	54800017 	ldw	r18,0(r10)
 8210798:	0027883a 	mov	r19,zero
 821079c:	483def0e 	bge	r9,zero,820ff5c <___vfiprintf_internal_r+0x958>
 82107a0:	94c6b03a 	or	r3,r18,r19
 82107a4:	d8802215 	stw	r2,136(sp)
 82107a8:	183d4e1e 	bne	r3,zero,820fce4 <___vfiprintf_internal_r+0x6e0>
 82107ac:	0039883a 	mov	fp,zero
 82107b0:	0005883a 	mov	r2,zero
 82107b4:	003e0606 	br	820ffd0 <___vfiprintf_internal_r+0x9cc>
 82107b8:	d9402117 	ldw	r5,132(sp)
 82107bc:	d9002017 	ldw	r4,128(sp)
 82107c0:	d9801a04 	addi	r6,sp,104
 82107c4:	da402c15 	stw	r9,176(sp)
 82107c8:	db802a15 	stw	r14,168(sp)
 82107cc:	820f4f00 	call	820f4f0 <__sprint_r.part.0>
 82107d0:	da402c17 	ldw	r9,176(sp)
 82107d4:	db802a17 	ldw	r14,168(sp)
 82107d8:	103ede1e 	bne	r2,zero,8210354 <___vfiprintf_internal_r+0xd50>
 82107dc:	d9401b17 	ldw	r5,108(sp)
 82107e0:	d8801c17 	ldw	r2,112(sp)
 82107e4:	d811883a 	mov	r8,sp
 82107e8:	29000044 	addi	r4,r5,1
 82107ec:	003e7406 	br	82101c0 <___vfiprintf_internal_r+0xbbc>
 82107f0:	00bfffc4 	movi	r2,-1
 82107f4:	003c5806 	br	820f958 <___vfiprintf_internal_r+0x354>
 82107f8:	d811883a 	mov	r8,sp
 82107fc:	003ee806 	br	82103a0 <___vfiprintf_internal_r+0xd9c>
 8210800:	000b883a 	mov	r5,zero
 8210804:	01000044 	movi	r4,1
 8210808:	d811883a 	mov	r8,sp
 821080c:	003e7c06 	br	8210200 <___vfiprintf_internal_r+0xbfc>
 8210810:	50800104 	addi	r2,r10,4
 8210814:	5480000b 	ldhu	r18,0(r10)
 8210818:	0027883a 	mov	r19,zero
 821081c:	483dcf0e 	bge	r9,zero,820ff5c <___vfiprintf_internal_r+0x958>
 8210820:	003fdf06 	br	82107a0 <___vfiprintf_internal_r+0x119c>
 8210824:	54800017 	ldw	r18,0(r10)
 8210828:	52800104 	addi	r10,r10,4
 821082c:	0027883a 	mov	r19,zero
 8210830:	da802215 	stw	r10,136(sp)
 8210834:	003d5006 	br	820fd78 <___vfiprintf_internal_r+0x774>
 8210838:	50800104 	addi	r2,r10,4
 821083c:	5480000b 	ldhu	r18,0(r10)
 8210840:	0027883a 	mov	r19,zero
 8210844:	483f7d0e 	bge	r9,zero,821063c <___vfiprintf_internal_r+0x1038>
 8210848:	003ddc06 	br	820ffbc <___vfiprintf_internal_r+0x9b8>
 821084c:	d8c02215 	stw	r3,136(sp)
 8210850:	0039883a 	mov	fp,zero
 8210854:	003ddb06 	br	820ffc4 <___vfiprintf_internal_r+0x9c0>
 8210858:	02820974 	movhi	r10,2085
 821085c:	52b75504 	addi	r10,r10,-8876
 8210860:	da802415 	stw	r10,144(sp)
 8210864:	003e8306 	br	8210274 <___vfiprintf_internal_r+0xc70>
 8210868:	d8801c17 	ldw	r2,112(sp)
 821086c:	dd002117 	ldw	r20,132(sp)
 8210870:	103eb926 	beq	r2,zero,8210358 <___vfiprintf_internal_r+0xd54>
 8210874:	d9002017 	ldw	r4,128(sp)
 8210878:	d9801a04 	addi	r6,sp,104
 821087c:	a00b883a 	mov	r5,r20
 8210880:	820f4f00 	call	820f4f0 <__sprint_r.part.0>
 8210884:	003eb406 	br	8210358 <___vfiprintf_internal_r+0xd54>
 8210888:	80c00043 	ldbu	r3,1(r16)
 821088c:	a5000814 	ori	r20,r20,32
 8210890:	84000044 	addi	r16,r16,1
 8210894:	18c03fcc 	andi	r3,r3,255
 8210898:	18c0201c 	xori	r3,r3,128
 821089c:	18ffe004 	addi	r3,r3,-128
 82108a0:	003bb706 	br	820f780 <___vfiprintf_internal_r+0x17c>
 82108a4:	a809883a 	mov	r4,r21
 82108a8:	d8c02a15 	stw	r3,168(sp)
 82108ac:	da002b15 	stw	r8,172(sp)
 82108b0:	8203fbc0 	call	8203fbc <strlen>
 82108b4:	d8c02a17 	ldw	r3,168(sp)
 82108b8:	1027883a 	mov	r19,r2
 82108bc:	df001d83 	ldbu	fp,118(sp)
 82108c0:	d8c02215 	stw	r3,136(sp)
 82108c4:	0013883a 	mov	r9,zero
 82108c8:	da002b17 	ldw	r8,172(sp)
 82108cc:	003c4d06 	br	820fa04 <___vfiprintf_internal_r+0x400>
 82108d0:	d9402117 	ldw	r5,132(sp)
 82108d4:	d9002017 	ldw	r4,128(sp)
 82108d8:	d9801a04 	addi	r6,sp,104
 82108dc:	da402c15 	stw	r9,176(sp)
 82108e0:	820f4f00 	call	820f4f0 <__sprint_r.part.0>
 82108e4:	da402c17 	ldw	r9,176(sp)
 82108e8:	103e9a1e 	bne	r2,zero,8210354 <___vfiprintf_internal_r+0xd50>
 82108ec:	d9401b17 	ldw	r5,108(sp)
 82108f0:	d8801c17 	ldw	r2,112(sp)
 82108f4:	d811883a 	mov	r8,sp
 82108f8:	29000044 	addi	r4,r5,1
 82108fc:	003e4206 	br	8210208 <___vfiprintf_internal_r+0xc04>
 8210900:	d9401b17 	ldw	r5,108(sp)
 8210904:	01020974 	movhi	r4,2085
 8210908:	21375904 	addi	r4,r4,-8860
 821090c:	d9002415 	stw	r4,144(sp)
 8210910:	29400044 	addi	r5,r5,1
 8210914:	003c6d06 	br	820facc <___vfiprintf_internal_r+0x4c8>
 8210918:	0039883a 	mov	fp,zero
 821091c:	00800084 	movi	r2,2
 8210920:	10803fcc 	andi	r2,r2,255
 8210924:	01000044 	movi	r4,1
 8210928:	11001e26 	beq	r2,r4,82109a4 <___vfiprintf_internal_r+0x13a0>
 821092c:	01000084 	movi	r4,2
 8210930:	11001e1e 	bne	r2,r4,82109ac <___vfiprintf_internal_r+0x13a8>
 8210934:	1829883a 	mov	r20,r3
 8210938:	003eea06 	br	82104e4 <___vfiprintf_internal_r+0xee0>
 821093c:	a007883a 	mov	r3,r20
 8210940:	00800044 	movi	r2,1
 8210944:	003ff606 	br	8210920 <___vfiprintf_internal_r+0x131c>
 8210948:	00800184 	movi	r2,6
 821094c:	1240012e 	bgeu	r2,r9,8210954 <___vfiprintf_internal_r+0x1350>
 8210950:	1013883a 	mov	r9,r2
 8210954:	4827883a 	mov	r19,r9
 8210958:	4825883a 	mov	r18,r9
 821095c:	48001516 	blt	r9,zero,82109b4 <___vfiprintf_internal_r+0x13b0>
 8210960:	05420974 	movhi	r21,2085
 8210964:	d8c02215 	stw	r3,136(sp)
 8210968:	ad76ea04 	addi	r21,r21,-9304
 821096c:	003d1406 	br	820fdc0 <___vfiprintf_internal_r+0x7bc>
 8210970:	02820974 	movhi	r10,2085
 8210974:	52b75504 	addi	r10,r10,-8876
 8210978:	da802415 	stw	r10,144(sp)
 821097c:	200d883a 	mov	r6,r4
 8210980:	003c9106 	br	820fbc8 <___vfiprintf_internal_r+0x5c4>
 8210984:	5021883a 	mov	r16,r10
 8210988:	0013883a 	mov	r9,zero
 821098c:	003b7d06 	br	820f784 <___vfiprintf_internal_r+0x180>
 8210990:	4827883a 	mov	r19,r9
 8210994:	df001d83 	ldbu	fp,118(sp)
 8210998:	d8c02215 	stw	r3,136(sp)
 821099c:	0013883a 	mov	r9,zero
 82109a0:	003c1806 	br	820fa04 <___vfiprintf_internal_r+0x400>
 82109a4:	1829883a 	mov	r20,r3
 82109a8:	003d1806 	br	820fe0c <___vfiprintf_internal_r+0x808>
 82109ac:	1829883a 	mov	r20,r3
 82109b0:	003ccd06 	br	820fce8 <___vfiprintf_internal_r+0x6e4>
 82109b4:	0025883a 	mov	r18,zero
 82109b8:	003fe906 	br	8210960 <___vfiprintf_internal_r+0x135c>
 82109bc:	d8802217 	ldw	r2,136(sp)
 82109c0:	80c00043 	ldbu	r3,1(r16)
 82109c4:	5021883a 	mov	r16,r10
 82109c8:	12400017 	ldw	r9,0(r2)
 82109cc:	10800104 	addi	r2,r2,4
 82109d0:	d8802215 	stw	r2,136(sp)
 82109d4:	483faf0e 	bge	r9,zero,8210894 <___vfiprintf_internal_r+0x1290>
 82109d8:	18c03fcc 	andi	r3,r3,255
 82109dc:	18c0201c 	xori	r3,r3,128
 82109e0:	027fffc4 	movi	r9,-1
 82109e4:	18ffe004 	addi	r3,r3,-128
 82109e8:	003b6506 	br	820f780 <___vfiprintf_internal_r+0x17c>
 82109ec:	d9c01d85 	stb	r7,118(sp)
 82109f0:	003ca006 	br	820fc74 <___vfiprintf_internal_r+0x670>
 82109f4:	d9c01d85 	stb	r7,118(sp)
 82109f8:	003cad06 	br	820fcb0 <___vfiprintf_internal_r+0x6ac>
 82109fc:	d9c01d85 	stb	r7,118(sp)
 8210a00:	003d7d06 	br	820fff8 <___vfiprintf_internal_r+0x9f4>
 8210a04:	d9c01d85 	stb	r7,118(sp)
 8210a08:	003d5f06 	br	820ff88 <___vfiprintf_internal_r+0x984>
 8210a0c:	a080004c 	andi	r2,r20,1
 8210a10:	0039883a 	mov	fp,zero
 8210a14:	10000526 	beq	r2,zero,8210a2c <___vfiprintf_internal_r+0x1428>
 8210a18:	00800c04 	movi	r2,48
 8210a1c:	d88019c5 	stb	r2,103(sp)
 8210a20:	dcc02717 	ldw	r19,156(sp)
 8210a24:	dd4019c4 	addi	r21,sp,103
 8210a28:	003bf606 	br	820fa04 <___vfiprintf_internal_r+0x400>
 8210a2c:	0027883a 	mov	r19,zero
 8210a30:	dd401a04 	addi	r21,sp,104
 8210a34:	003bf306 	br	820fa04 <___vfiprintf_internal_r+0x400>
 8210a38:	d9c01d85 	stb	r7,118(sp)
 8210a3c:	003dc806 	br	8210160 <___vfiprintf_internal_r+0xb5c>
 8210a40:	d9c01d85 	stb	r7,118(sp)
 8210a44:	003d3a06 	br	820ff30 <___vfiprintf_internal_r+0x92c>
 8210a48:	d9c01d85 	stb	r7,118(sp)
 8210a4c:	003d2a06 	br	820fef8 <___vfiprintf_internal_r+0x8f4>
 8210a50:	d9c01d85 	stb	r7,118(sp)
 8210a54:	003cde06 	br	820fdd0 <___vfiprintf_internal_r+0x7cc>
 8210a58:	d9c01d85 	stb	r7,118(sp)
 8210a5c:	003cbc06 	br	820fd50 <___vfiprintf_internal_r+0x74c>

08210a60 <__vfiprintf_internal>:
 8210a60:	00820974 	movhi	r2,2085
 8210a64:	108fbb04 	addi	r2,r2,16108
 8210a68:	300f883a 	mov	r7,r6
 8210a6c:	280d883a 	mov	r6,r5
 8210a70:	200b883a 	mov	r5,r4
 8210a74:	11000017 	ldw	r4,0(r2)
 8210a78:	820f6041 	jmpi	820f604 <___vfiprintf_internal_r>

08210a7c <__sbprintf>:
 8210a7c:	2880030b 	ldhu	r2,12(r5)
 8210a80:	2ac01917 	ldw	r11,100(r5)
 8210a84:	2a80038b 	ldhu	r10,14(r5)
 8210a88:	2a400717 	ldw	r9,28(r5)
 8210a8c:	2a000917 	ldw	r8,36(r5)
 8210a90:	defee204 	addi	sp,sp,-1144
 8210a94:	00c10004 	movi	r3,1024
 8210a98:	dc011a15 	stw	r16,1128(sp)
 8210a9c:	10bfff4c 	andi	r2,r2,65533
 8210aa0:	2821883a 	mov	r16,r5
 8210aa4:	d8cb883a 	add	r5,sp,r3
 8210aa8:	dc811c15 	stw	r18,1136(sp)
 8210aac:	dc411b15 	stw	r17,1132(sp)
 8210ab0:	dfc11d15 	stw	ra,1140(sp)
 8210ab4:	2025883a 	mov	r18,r4
 8210ab8:	d881030d 	sth	r2,1036(sp)
 8210abc:	dac11915 	stw	r11,1124(sp)
 8210ac0:	da81038d 	sth	r10,1038(sp)
 8210ac4:	da410715 	stw	r9,1052(sp)
 8210ac8:	da010915 	stw	r8,1060(sp)
 8210acc:	dec10015 	stw	sp,1024(sp)
 8210ad0:	dec10415 	stw	sp,1040(sp)
 8210ad4:	d8c10215 	stw	r3,1032(sp)
 8210ad8:	d8c10515 	stw	r3,1044(sp)
 8210adc:	d8010615 	stw	zero,1048(sp)
 8210ae0:	820f6040 	call	820f604 <___vfiprintf_internal_r>
 8210ae4:	1023883a 	mov	r17,r2
 8210ae8:	10000416 	blt	r2,zero,8210afc <__sbprintf+0x80>
 8210aec:	d9410004 	addi	r5,sp,1024
 8210af0:	9009883a 	mov	r4,r18
 8210af4:	820aab80 	call	820aab8 <_fflush_r>
 8210af8:	10000d1e 	bne	r2,zero,8210b30 <__sbprintf+0xb4>
 8210afc:	d881030b 	ldhu	r2,1036(sp)
 8210b00:	1080100c 	andi	r2,r2,64
 8210b04:	10000326 	beq	r2,zero,8210b14 <__sbprintf+0x98>
 8210b08:	8080030b 	ldhu	r2,12(r16)
 8210b0c:	10801014 	ori	r2,r2,64
 8210b10:	8080030d 	sth	r2,12(r16)
 8210b14:	8805883a 	mov	r2,r17
 8210b18:	dfc11d17 	ldw	ra,1140(sp)
 8210b1c:	dc811c17 	ldw	r18,1136(sp)
 8210b20:	dc411b17 	ldw	r17,1132(sp)
 8210b24:	dc011a17 	ldw	r16,1128(sp)
 8210b28:	dec11e04 	addi	sp,sp,1144
 8210b2c:	f800283a 	ret
 8210b30:	047fffc4 	movi	r17,-1
 8210b34:	003ff106 	br	8210afc <__sbprintf+0x80>

08210b38 <_write_r>:
 8210b38:	defffd04 	addi	sp,sp,-12
 8210b3c:	2805883a 	mov	r2,r5
 8210b40:	dc000015 	stw	r16,0(sp)
 8210b44:	04020974 	movhi	r16,2085
 8210b48:	dc400115 	stw	r17,4(sp)
 8210b4c:	300b883a 	mov	r5,r6
 8210b50:	84101c04 	addi	r16,r16,16496
 8210b54:	2023883a 	mov	r17,r4
 8210b58:	380d883a 	mov	r6,r7
 8210b5c:	1009883a 	mov	r4,r2
 8210b60:	dfc00215 	stw	ra,8(sp)
 8210b64:	80000015 	stw	zero,0(r16)
 8210b68:	8225a940 	call	8225a94 <write>
 8210b6c:	00ffffc4 	movi	r3,-1
 8210b70:	10c00526 	beq	r2,r3,8210b88 <_write_r+0x50>
 8210b74:	dfc00217 	ldw	ra,8(sp)
 8210b78:	dc400117 	ldw	r17,4(sp)
 8210b7c:	dc000017 	ldw	r16,0(sp)
 8210b80:	dec00304 	addi	sp,sp,12
 8210b84:	f800283a 	ret
 8210b88:	80c00017 	ldw	r3,0(r16)
 8210b8c:	183ff926 	beq	r3,zero,8210b74 <_write_r+0x3c>
 8210b90:	88c00015 	stw	r3,0(r17)
 8210b94:	003ff706 	br	8210b74 <_write_r+0x3c>

08210b98 <_close_r>:
 8210b98:	defffd04 	addi	sp,sp,-12
 8210b9c:	dc000015 	stw	r16,0(sp)
 8210ba0:	04020974 	movhi	r16,2085
 8210ba4:	dc400115 	stw	r17,4(sp)
 8210ba8:	84101c04 	addi	r16,r16,16496
 8210bac:	2023883a 	mov	r17,r4
 8210bb0:	2809883a 	mov	r4,r5
 8210bb4:	dfc00215 	stw	ra,8(sp)
 8210bb8:	80000015 	stw	zero,0(r16)
 8210bbc:	82258940 	call	8225894 <close>
 8210bc0:	00ffffc4 	movi	r3,-1
 8210bc4:	10c00526 	beq	r2,r3,8210bdc <_close_r+0x44>
 8210bc8:	dfc00217 	ldw	ra,8(sp)
 8210bcc:	dc400117 	ldw	r17,4(sp)
 8210bd0:	dc000017 	ldw	r16,0(sp)
 8210bd4:	dec00304 	addi	sp,sp,12
 8210bd8:	f800283a 	ret
 8210bdc:	80c00017 	ldw	r3,0(r16)
 8210be0:	183ff926 	beq	r3,zero,8210bc8 <_close_r+0x30>
 8210be4:	88c00015 	stw	r3,0(r17)
 8210be8:	003ff706 	br	8210bc8 <_close_r+0x30>

08210bec <_calloc_r>:
 8210bec:	298b383a 	mul	r5,r5,r6
 8210bf0:	defffe04 	addi	sp,sp,-8
 8210bf4:	dfc00115 	stw	ra,4(sp)
 8210bf8:	dc000015 	stw	r16,0(sp)
 8210bfc:	820bd480 	call	820bd48 <_malloc_r>
 8210c00:	10002926 	beq	r2,zero,8210ca8 <_calloc_r+0xbc>
 8210c04:	11bfff17 	ldw	r6,-4(r2)
 8210c08:	1021883a 	mov	r16,r2
 8210c0c:	00bfff04 	movi	r2,-4
 8210c10:	308c703a 	and	r6,r6,r2
 8210c14:	00c00904 	movi	r3,36
 8210c18:	308d883a 	add	r6,r6,r2
 8210c1c:	19801636 	bltu	r3,r6,8210c78 <_calloc_r+0x8c>
 8210c20:	008004c4 	movi	r2,19
 8210c24:	11800b2e 	bgeu	r2,r6,8210c54 <_calloc_r+0x68>
 8210c28:	80000015 	stw	zero,0(r16)
 8210c2c:	80000115 	stw	zero,4(r16)
 8210c30:	008006c4 	movi	r2,27
 8210c34:	11801a2e 	bgeu	r2,r6,8210ca0 <_calloc_r+0xb4>
 8210c38:	80000215 	stw	zero,8(r16)
 8210c3c:	80000315 	stw	zero,12(r16)
 8210c40:	30c0151e 	bne	r6,r3,8210c98 <_calloc_r+0xac>
 8210c44:	80000415 	stw	zero,16(r16)
 8210c48:	80800604 	addi	r2,r16,24
 8210c4c:	80000515 	stw	zero,20(r16)
 8210c50:	00000106 	br	8210c58 <_calloc_r+0x6c>
 8210c54:	8005883a 	mov	r2,r16
 8210c58:	10000015 	stw	zero,0(r2)
 8210c5c:	10000115 	stw	zero,4(r2)
 8210c60:	10000215 	stw	zero,8(r2)
 8210c64:	8005883a 	mov	r2,r16
 8210c68:	dfc00117 	ldw	ra,4(sp)
 8210c6c:	dc000017 	ldw	r16,0(sp)
 8210c70:	dec00204 	addi	sp,sp,8
 8210c74:	f800283a 	ret
 8210c78:	000b883a 	mov	r5,zero
 8210c7c:	8009883a 	mov	r4,r16
 8210c80:	82032100 	call	8203210 <memset>
 8210c84:	8005883a 	mov	r2,r16
 8210c88:	dfc00117 	ldw	ra,4(sp)
 8210c8c:	dc000017 	ldw	r16,0(sp)
 8210c90:	dec00204 	addi	sp,sp,8
 8210c94:	f800283a 	ret
 8210c98:	80800404 	addi	r2,r16,16
 8210c9c:	003fee06 	br	8210c58 <_calloc_r+0x6c>
 8210ca0:	80800204 	addi	r2,r16,8
 8210ca4:	003fec06 	br	8210c58 <_calloc_r+0x6c>
 8210ca8:	0005883a 	mov	r2,zero
 8210cac:	003fee06 	br	8210c68 <_calloc_r+0x7c>

08210cb0 <_fclose_r>:
 8210cb0:	28003926 	beq	r5,zero,8210d98 <_fclose_r+0xe8>
 8210cb4:	defffc04 	addi	sp,sp,-16
 8210cb8:	dc400115 	stw	r17,4(sp)
 8210cbc:	dc000015 	stw	r16,0(sp)
 8210cc0:	dfc00315 	stw	ra,12(sp)
 8210cc4:	dc800215 	stw	r18,8(sp)
 8210cc8:	2023883a 	mov	r17,r4
 8210ccc:	2821883a 	mov	r16,r5
 8210cd0:	20000226 	beq	r4,zero,8210cdc <_fclose_r+0x2c>
 8210cd4:	20800e17 	ldw	r2,56(r4)
 8210cd8:	10002726 	beq	r2,zero,8210d78 <_fclose_r+0xc8>
 8210cdc:	8080030f 	ldh	r2,12(r16)
 8210ce0:	1000071e 	bne	r2,zero,8210d00 <_fclose_r+0x50>
 8210ce4:	0005883a 	mov	r2,zero
 8210ce8:	dfc00317 	ldw	ra,12(sp)
 8210cec:	dc800217 	ldw	r18,8(sp)
 8210cf0:	dc400117 	ldw	r17,4(sp)
 8210cf4:	dc000017 	ldw	r16,0(sp)
 8210cf8:	dec00404 	addi	sp,sp,16
 8210cfc:	f800283a 	ret
 8210d00:	800b883a 	mov	r5,r16
 8210d04:	8809883a 	mov	r4,r17
 8210d08:	820a89c0 	call	820a89c <__sflush_r>
 8210d0c:	1025883a 	mov	r18,r2
 8210d10:	80800b17 	ldw	r2,44(r16)
 8210d14:	10000426 	beq	r2,zero,8210d28 <_fclose_r+0x78>
 8210d18:	81400717 	ldw	r5,28(r16)
 8210d1c:	8809883a 	mov	r4,r17
 8210d20:	103ee83a 	callr	r2
 8210d24:	10001616 	blt	r2,zero,8210d80 <_fclose_r+0xd0>
 8210d28:	8080030b 	ldhu	r2,12(r16)
 8210d2c:	1080200c 	andi	r2,r2,128
 8210d30:	1000151e 	bne	r2,zero,8210d88 <_fclose_r+0xd8>
 8210d34:	81400c17 	ldw	r5,48(r16)
 8210d38:	28000526 	beq	r5,zero,8210d50 <_fclose_r+0xa0>
 8210d3c:	80801004 	addi	r2,r16,64
 8210d40:	28800226 	beq	r5,r2,8210d4c <_fclose_r+0x9c>
 8210d44:	8809883a 	mov	r4,r17
 8210d48:	820b15c0 	call	820b15c <_free_r>
 8210d4c:	80000c15 	stw	zero,48(r16)
 8210d50:	81401117 	ldw	r5,68(r16)
 8210d54:	28000326 	beq	r5,zero,8210d64 <_fclose_r+0xb4>
 8210d58:	8809883a 	mov	r4,r17
 8210d5c:	820b15c0 	call	820b15c <_free_r>
 8210d60:	80001115 	stw	zero,68(r16)
 8210d64:	820aea40 	call	820aea4 <__sfp_lock_acquire>
 8210d68:	8000030d 	sth	zero,12(r16)
 8210d6c:	820aea80 	call	820aea8 <__sfp_lock_release>
 8210d70:	9005883a 	mov	r2,r18
 8210d74:	003fdc06 	br	8210ce8 <_fclose_r+0x38>
 8210d78:	820ae940 	call	820ae94 <__sinit>
 8210d7c:	003fd706 	br	8210cdc <_fclose_r+0x2c>
 8210d80:	04bfffc4 	movi	r18,-1
 8210d84:	003fe806 	br	8210d28 <_fclose_r+0x78>
 8210d88:	81400417 	ldw	r5,16(r16)
 8210d8c:	8809883a 	mov	r4,r17
 8210d90:	820b15c0 	call	820b15c <_free_r>
 8210d94:	003fe706 	br	8210d34 <_fclose_r+0x84>
 8210d98:	0005883a 	mov	r2,zero
 8210d9c:	f800283a 	ret

08210da0 <fclose>:
 8210da0:	00820974 	movhi	r2,2085
 8210da4:	108fbb04 	addi	r2,r2,16108
 8210da8:	200b883a 	mov	r5,r4
 8210dac:	11000017 	ldw	r4,0(r2)
 8210db0:	8210cb01 	jmpi	8210cb0 <_fclose_r>

08210db4 <__fputwc>:
 8210db4:	defff804 	addi	sp,sp,-32
 8210db8:	dcc00415 	stw	r19,16(sp)
 8210dbc:	dc800315 	stw	r18,12(sp)
 8210dc0:	dc000115 	stw	r16,4(sp)
 8210dc4:	dfc00715 	stw	ra,28(sp)
 8210dc8:	dd400615 	stw	r21,24(sp)
 8210dcc:	dd000515 	stw	r20,20(sp)
 8210dd0:	dc400215 	stw	r17,8(sp)
 8210dd4:	2027883a 	mov	r19,r4
 8210dd8:	2825883a 	mov	r18,r5
 8210ddc:	3021883a 	mov	r16,r6
 8210de0:	820bb380 	call	820bb38 <__locale_mb_cur_max>
 8210de4:	00c00044 	movi	r3,1
 8210de8:	10c03e26 	beq	r2,r3,8210ee4 <__fputwc+0x130>
 8210dec:	81c01704 	addi	r7,r16,92
 8210df0:	900d883a 	mov	r6,r18
 8210df4:	d80b883a 	mov	r5,sp
 8210df8:	9809883a 	mov	r4,r19
 8210dfc:	821112c0 	call	821112c <_wcrtomb_r>
 8210e00:	1029883a 	mov	r20,r2
 8210e04:	00bfffc4 	movi	r2,-1
 8210e08:	a0802026 	beq	r20,r2,8210e8c <__fputwc+0xd8>
 8210e0c:	d9400003 	ldbu	r5,0(sp)
 8210e10:	a0001c26 	beq	r20,zero,8210e84 <__fputwc+0xd0>
 8210e14:	0023883a 	mov	r17,zero
 8210e18:	05400284 	movi	r21,10
 8210e1c:	00000906 	br	8210e44 <__fputwc+0x90>
 8210e20:	80800017 	ldw	r2,0(r16)
 8210e24:	11400005 	stb	r5,0(r2)
 8210e28:	80c00017 	ldw	r3,0(r16)
 8210e2c:	18c00044 	addi	r3,r3,1
 8210e30:	80c00015 	stw	r3,0(r16)
 8210e34:	8c400044 	addi	r17,r17,1
 8210e38:	dc45883a 	add	r2,sp,r17
 8210e3c:	8d00112e 	bgeu	r17,r20,8210e84 <__fputwc+0xd0>
 8210e40:	11400003 	ldbu	r5,0(r2)
 8210e44:	80c00217 	ldw	r3,8(r16)
 8210e48:	18ffffc4 	addi	r3,r3,-1
 8210e4c:	80c00215 	stw	r3,8(r16)
 8210e50:	183ff30e 	bge	r3,zero,8210e20 <__fputwc+0x6c>
 8210e54:	80800617 	ldw	r2,24(r16)
 8210e58:	18801916 	blt	r3,r2,8210ec0 <__fputwc+0x10c>
 8210e5c:	80800017 	ldw	r2,0(r16)
 8210e60:	11400005 	stb	r5,0(r2)
 8210e64:	80800017 	ldw	r2,0(r16)
 8210e68:	10c00003 	ldbu	r3,0(r2)
 8210e6c:	10800044 	addi	r2,r2,1
 8210e70:	1d402326 	beq	r3,r21,8210f00 <__fputwc+0x14c>
 8210e74:	80800015 	stw	r2,0(r16)
 8210e78:	8c400044 	addi	r17,r17,1
 8210e7c:	dc45883a 	add	r2,sp,r17
 8210e80:	8d3fef36 	bltu	r17,r20,8210e40 <__fputwc+0x8c>
 8210e84:	9005883a 	mov	r2,r18
 8210e88:	00000406 	br	8210e9c <__fputwc+0xe8>
 8210e8c:	80c0030b 	ldhu	r3,12(r16)
 8210e90:	a005883a 	mov	r2,r20
 8210e94:	18c01014 	ori	r3,r3,64
 8210e98:	80c0030d 	sth	r3,12(r16)
 8210e9c:	dfc00717 	ldw	ra,28(sp)
 8210ea0:	dd400617 	ldw	r21,24(sp)
 8210ea4:	dd000517 	ldw	r20,20(sp)
 8210ea8:	dcc00417 	ldw	r19,16(sp)
 8210eac:	dc800317 	ldw	r18,12(sp)
 8210eb0:	dc400217 	ldw	r17,8(sp)
 8210eb4:	dc000117 	ldw	r16,4(sp)
 8210eb8:	dec00804 	addi	sp,sp,32
 8210ebc:	f800283a 	ret
 8210ec0:	800d883a 	mov	r6,r16
 8210ec4:	29403fcc 	andi	r5,r5,255
 8210ec8:	9809883a 	mov	r4,r19
 8210ecc:	8208d680 	call	8208d68 <__swbuf_r>
 8210ed0:	10bfffe0 	cmpeqi	r2,r2,-1
 8210ed4:	10803fcc 	andi	r2,r2,255
 8210ed8:	103fd626 	beq	r2,zero,8210e34 <__fputwc+0x80>
 8210edc:	00bfffc4 	movi	r2,-1
 8210ee0:	003fee06 	br	8210e9c <__fputwc+0xe8>
 8210ee4:	90ffffc4 	addi	r3,r18,-1
 8210ee8:	01003f84 	movi	r4,254
 8210eec:	20ffbf36 	bltu	r4,r3,8210dec <__fputwc+0x38>
 8210ef0:	900b883a 	mov	r5,r18
 8210ef4:	dc800005 	stb	r18,0(sp)
 8210ef8:	1029883a 	mov	r20,r2
 8210efc:	003fc506 	br	8210e14 <__fputwc+0x60>
 8210f00:	800d883a 	mov	r6,r16
 8210f04:	a80b883a 	mov	r5,r21
 8210f08:	9809883a 	mov	r4,r19
 8210f0c:	8208d680 	call	8208d68 <__swbuf_r>
 8210f10:	10bfffe0 	cmpeqi	r2,r2,-1
 8210f14:	003fef06 	br	8210ed4 <__fputwc+0x120>

08210f18 <_fputwc_r>:
 8210f18:	3080030b 	ldhu	r2,12(r6)
 8210f1c:	10c8000c 	andi	r3,r2,8192
 8210f20:	1800051e 	bne	r3,zero,8210f38 <_fputwc_r+0x20>
 8210f24:	30c01917 	ldw	r3,100(r6)
 8210f28:	10880014 	ori	r2,r2,8192
 8210f2c:	3080030d 	sth	r2,12(r6)
 8210f30:	18880014 	ori	r2,r3,8192
 8210f34:	30801915 	stw	r2,100(r6)
 8210f38:	8210db41 	jmpi	8210db4 <__fputwc>

08210f3c <fputwc>:
 8210f3c:	00820974 	movhi	r2,2085
 8210f40:	defffc04 	addi	sp,sp,-16
 8210f44:	108fbb04 	addi	r2,r2,16108
 8210f48:	dc000115 	stw	r16,4(sp)
 8210f4c:	14000017 	ldw	r16,0(r2)
 8210f50:	dc400215 	stw	r17,8(sp)
 8210f54:	dfc00315 	stw	ra,12(sp)
 8210f58:	2023883a 	mov	r17,r4
 8210f5c:	80000226 	beq	r16,zero,8210f68 <fputwc+0x2c>
 8210f60:	80800e17 	ldw	r2,56(r16)
 8210f64:	10001026 	beq	r2,zero,8210fa8 <fputwc+0x6c>
 8210f68:	2880030b 	ldhu	r2,12(r5)
 8210f6c:	10c8000c 	andi	r3,r2,8192
 8210f70:	1800051e 	bne	r3,zero,8210f88 <fputwc+0x4c>
 8210f74:	28c01917 	ldw	r3,100(r5)
 8210f78:	10880014 	ori	r2,r2,8192
 8210f7c:	2880030d 	sth	r2,12(r5)
 8210f80:	18880014 	ori	r2,r3,8192
 8210f84:	28801915 	stw	r2,100(r5)
 8210f88:	280d883a 	mov	r6,r5
 8210f8c:	8009883a 	mov	r4,r16
 8210f90:	880b883a 	mov	r5,r17
 8210f94:	dfc00317 	ldw	ra,12(sp)
 8210f98:	dc400217 	ldw	r17,8(sp)
 8210f9c:	dc000117 	ldw	r16,4(sp)
 8210fa0:	dec00404 	addi	sp,sp,16
 8210fa4:	8210db41 	jmpi	8210db4 <__fputwc>
 8210fa8:	8009883a 	mov	r4,r16
 8210fac:	d9400015 	stw	r5,0(sp)
 8210fb0:	820ae940 	call	820ae94 <__sinit>
 8210fb4:	d9400017 	ldw	r5,0(sp)
 8210fb8:	003feb06 	br	8210f68 <fputwc+0x2c>

08210fbc <_fstat_r>:
 8210fbc:	defffd04 	addi	sp,sp,-12
 8210fc0:	2805883a 	mov	r2,r5
 8210fc4:	dc000015 	stw	r16,0(sp)
 8210fc8:	04020974 	movhi	r16,2085
 8210fcc:	dc400115 	stw	r17,4(sp)
 8210fd0:	84101c04 	addi	r16,r16,16496
 8210fd4:	2023883a 	mov	r17,r4
 8210fd8:	300b883a 	mov	r5,r6
 8210fdc:	1009883a 	mov	r4,r2
 8210fe0:	dfc00215 	stw	ra,8(sp)
 8210fe4:	80000015 	stw	zero,0(r16)
 8210fe8:	82145240 	call	8214524 <fstat>
 8210fec:	00ffffc4 	movi	r3,-1
 8210ff0:	10c00526 	beq	r2,r3,8211008 <_fstat_r+0x4c>
 8210ff4:	dfc00217 	ldw	ra,8(sp)
 8210ff8:	dc400117 	ldw	r17,4(sp)
 8210ffc:	dc000017 	ldw	r16,0(sp)
 8211000:	dec00304 	addi	sp,sp,12
 8211004:	f800283a 	ret
 8211008:	80c00017 	ldw	r3,0(r16)
 821100c:	183ff926 	beq	r3,zero,8210ff4 <_fstat_r+0x38>
 8211010:	88c00015 	stw	r3,0(r17)
 8211014:	003ff706 	br	8210ff4 <_fstat_r+0x38>

08211018 <_isatty_r>:
 8211018:	defffd04 	addi	sp,sp,-12
 821101c:	dc000015 	stw	r16,0(sp)
 8211020:	04020974 	movhi	r16,2085
 8211024:	dc400115 	stw	r17,4(sp)
 8211028:	84101c04 	addi	r16,r16,16496
 821102c:	2023883a 	mov	r17,r4
 8211030:	2809883a 	mov	r4,r5
 8211034:	dfc00215 	stw	ra,8(sp)
 8211038:	80000015 	stw	zero,0(r16)
 821103c:	82146100 	call	8214610 <isatty>
 8211040:	00ffffc4 	movi	r3,-1
 8211044:	10c00526 	beq	r2,r3,821105c <_isatty_r+0x44>
 8211048:	dfc00217 	ldw	ra,8(sp)
 821104c:	dc400117 	ldw	r17,4(sp)
 8211050:	dc000017 	ldw	r16,0(sp)
 8211054:	dec00304 	addi	sp,sp,12
 8211058:	f800283a 	ret
 821105c:	80c00017 	ldw	r3,0(r16)
 8211060:	183ff926 	beq	r3,zero,8211048 <_isatty_r+0x30>
 8211064:	88c00015 	stw	r3,0(r17)
 8211068:	003ff706 	br	8211048 <_isatty_r+0x30>

0821106c <_lseek_r>:
 821106c:	defffd04 	addi	sp,sp,-12
 8211070:	2805883a 	mov	r2,r5
 8211074:	dc000015 	stw	r16,0(sp)
 8211078:	04020974 	movhi	r16,2085
 821107c:	dc400115 	stw	r17,4(sp)
 8211080:	300b883a 	mov	r5,r6
 8211084:	84101c04 	addi	r16,r16,16496
 8211088:	2023883a 	mov	r17,r4
 821108c:	380d883a 	mov	r6,r7
 8211090:	1009883a 	mov	r4,r2
 8211094:	dfc00215 	stw	ra,8(sp)
 8211098:	80000015 	stw	zero,0(r16)
 821109c:	82146f00 	call	82146f0 <lseek>
 82110a0:	00ffffc4 	movi	r3,-1
 82110a4:	10c00526 	beq	r2,r3,82110bc <_lseek_r+0x50>
 82110a8:	dfc00217 	ldw	ra,8(sp)
 82110ac:	dc400117 	ldw	r17,4(sp)
 82110b0:	dc000017 	ldw	r16,0(sp)
 82110b4:	dec00304 	addi	sp,sp,12
 82110b8:	f800283a 	ret
 82110bc:	80c00017 	ldw	r3,0(r16)
 82110c0:	183ff926 	beq	r3,zero,82110a8 <_lseek_r+0x3c>
 82110c4:	88c00015 	stw	r3,0(r17)
 82110c8:	003ff706 	br	82110a8 <_lseek_r+0x3c>

082110cc <_read_r>:
 82110cc:	defffd04 	addi	sp,sp,-12
 82110d0:	2805883a 	mov	r2,r5
 82110d4:	dc000015 	stw	r16,0(sp)
 82110d8:	04020974 	movhi	r16,2085
 82110dc:	dc400115 	stw	r17,4(sp)
 82110e0:	300b883a 	mov	r5,r6
 82110e4:	84101c04 	addi	r16,r16,16496
 82110e8:	2023883a 	mov	r17,r4
 82110ec:	380d883a 	mov	r6,r7
 82110f0:	1009883a 	mov	r4,r2
 82110f4:	dfc00215 	stw	ra,8(sp)
 82110f8:	80000015 	stw	zero,0(r16)
 82110fc:	8225a240 	call	8225a24 <read>
 8211100:	00ffffc4 	movi	r3,-1
 8211104:	10c00526 	beq	r2,r3,821111c <_read_r+0x50>
 8211108:	dfc00217 	ldw	ra,8(sp)
 821110c:	dc400117 	ldw	r17,4(sp)
 8211110:	dc000017 	ldw	r16,0(sp)
 8211114:	dec00304 	addi	sp,sp,12
 8211118:	f800283a 	ret
 821111c:	80c00017 	ldw	r3,0(r16)
 8211120:	183ff926 	beq	r3,zero,8211108 <_read_r+0x3c>
 8211124:	88c00015 	stw	r3,0(r17)
 8211128:	003ff706 	br	8211108 <_read_r+0x3c>

0821112c <_wcrtomb_r>:
 821112c:	defff604 	addi	sp,sp,-40
 8211130:	00820974 	movhi	r2,2085
 8211134:	dc800815 	stw	r18,32(sp)
 8211138:	dc400715 	stw	r17,28(sp)
 821113c:	dc000615 	stw	r16,24(sp)
 8211140:	108fbf04 	addi	r2,r2,16124
 8211144:	dfc00915 	stw	ra,36(sp)
 8211148:	2021883a 	mov	r16,r4
 821114c:	3823883a 	mov	r17,r7
 8211150:	14800017 	ldw	r18,0(r2)
 8211154:	28001426 	beq	r5,zero,82111a8 <_wcrtomb_r+0x7c>
 8211158:	d9400415 	stw	r5,16(sp)
 821115c:	d9800515 	stw	r6,20(sp)
 8211160:	820bb2c0 	call	820bb2c <__locale_charset>
 8211164:	d9800517 	ldw	r6,20(sp)
 8211168:	d9400417 	ldw	r5,16(sp)
 821116c:	100f883a 	mov	r7,r2
 8211170:	dc400015 	stw	r17,0(sp)
 8211174:	8009883a 	mov	r4,r16
 8211178:	903ee83a 	callr	r18
 821117c:	00ffffc4 	movi	r3,-1
 8211180:	10c0031e 	bne	r2,r3,8211190 <_wcrtomb_r+0x64>
 8211184:	88000015 	stw	zero,0(r17)
 8211188:	00c02284 	movi	r3,138
 821118c:	80c00015 	stw	r3,0(r16)
 8211190:	dfc00917 	ldw	ra,36(sp)
 8211194:	dc800817 	ldw	r18,32(sp)
 8211198:	dc400717 	ldw	r17,28(sp)
 821119c:	dc000617 	ldw	r16,24(sp)
 82111a0:	dec00a04 	addi	sp,sp,40
 82111a4:	f800283a 	ret
 82111a8:	820bb2c0 	call	820bb2c <__locale_charset>
 82111ac:	100f883a 	mov	r7,r2
 82111b0:	dc400015 	stw	r17,0(sp)
 82111b4:	000d883a 	mov	r6,zero
 82111b8:	d9400104 	addi	r5,sp,4
 82111bc:	8009883a 	mov	r4,r16
 82111c0:	903ee83a 	callr	r18
 82111c4:	003fed06 	br	821117c <_wcrtomb_r+0x50>

082111c8 <wcrtomb>:
 82111c8:	defff604 	addi	sp,sp,-40
 82111cc:	00820974 	movhi	r2,2085
 82111d0:	dc800615 	stw	r18,24(sp)
 82111d4:	dc400515 	stw	r17,20(sp)
 82111d8:	108fbb04 	addi	r2,r2,16108
 82111dc:	dfc00915 	stw	ra,36(sp)
 82111e0:	dd000815 	stw	r20,32(sp)
 82111e4:	dcc00715 	stw	r19,28(sp)
 82111e8:	dc000415 	stw	r16,16(sp)
 82111ec:	3025883a 	mov	r18,r6
 82111f0:	14400017 	ldw	r17,0(r2)
 82111f4:	20001926 	beq	r4,zero,821125c <wcrtomb+0x94>
 82111f8:	00820974 	movhi	r2,2085
 82111fc:	108fbf04 	addi	r2,r2,16124
 8211200:	15000017 	ldw	r20,0(r2)
 8211204:	2021883a 	mov	r16,r4
 8211208:	2827883a 	mov	r19,r5
 821120c:	820bb2c0 	call	820bb2c <__locale_charset>
 8211210:	100f883a 	mov	r7,r2
 8211214:	dc800015 	stw	r18,0(sp)
 8211218:	980d883a 	mov	r6,r19
 821121c:	800b883a 	mov	r5,r16
 8211220:	8809883a 	mov	r4,r17
 8211224:	a03ee83a 	callr	r20
 8211228:	00ffffc4 	movi	r3,-1
 821122c:	10c0031e 	bne	r2,r3,821123c <wcrtomb+0x74>
 8211230:	90000015 	stw	zero,0(r18)
 8211234:	00c02284 	movi	r3,138
 8211238:	88c00015 	stw	r3,0(r17)
 821123c:	dfc00917 	ldw	ra,36(sp)
 8211240:	dd000817 	ldw	r20,32(sp)
 8211244:	dcc00717 	ldw	r19,28(sp)
 8211248:	dc800617 	ldw	r18,24(sp)
 821124c:	dc400517 	ldw	r17,20(sp)
 8211250:	dc000417 	ldw	r16,16(sp)
 8211254:	dec00a04 	addi	sp,sp,40
 8211258:	f800283a 	ret
 821125c:	00820974 	movhi	r2,2085
 8211260:	108fbf04 	addi	r2,r2,16124
 8211264:	14000017 	ldw	r16,0(r2)
 8211268:	820bb2c0 	call	820bb2c <__locale_charset>
 821126c:	100f883a 	mov	r7,r2
 8211270:	dc800015 	stw	r18,0(sp)
 8211274:	000d883a 	mov	r6,zero
 8211278:	d9400104 	addi	r5,sp,4
 821127c:	8809883a 	mov	r4,r17
 8211280:	803ee83a 	callr	r16
 8211284:	003fe806 	br	8211228 <wcrtomb+0x60>

08211288 <__ascii_wctomb>:
 8211288:	28000526 	beq	r5,zero,82112a0 <__ascii_wctomb+0x18>
 821128c:	00803fc4 	movi	r2,255
 8211290:	11800536 	bltu	r2,r6,82112a8 <__ascii_wctomb+0x20>
 8211294:	29800005 	stb	r6,0(r5)
 8211298:	00800044 	movi	r2,1
 821129c:	f800283a 	ret
 82112a0:	0005883a 	mov	r2,zero
 82112a4:	f800283a 	ret
 82112a8:	00802284 	movi	r2,138
 82112ac:	20800015 	stw	r2,0(r4)
 82112b0:	00bfffc4 	movi	r2,-1
 82112b4:	f800283a 	ret

082112b8 <_wctomb_r>:
 82112b8:	00820974 	movhi	r2,2085
 82112bc:	defff904 	addi	sp,sp,-28
 82112c0:	108fbf04 	addi	r2,r2,16124
 82112c4:	dfc00615 	stw	ra,24(sp)
 82112c8:	dc400515 	stw	r17,20(sp)
 82112cc:	dc000415 	stw	r16,16(sp)
 82112d0:	3823883a 	mov	r17,r7
 82112d4:	14000017 	ldw	r16,0(r2)
 82112d8:	d9000115 	stw	r4,4(sp)
 82112dc:	d9400215 	stw	r5,8(sp)
 82112e0:	d9800315 	stw	r6,12(sp)
 82112e4:	820bb2c0 	call	820bb2c <__locale_charset>
 82112e8:	d9800317 	ldw	r6,12(sp)
 82112ec:	d9400217 	ldw	r5,8(sp)
 82112f0:	d9000117 	ldw	r4,4(sp)
 82112f4:	100f883a 	mov	r7,r2
 82112f8:	dc400015 	stw	r17,0(sp)
 82112fc:	803ee83a 	callr	r16
 8211300:	dfc00617 	ldw	ra,24(sp)
 8211304:	dc400517 	ldw	r17,20(sp)
 8211308:	dc000417 	ldw	r16,16(sp)
 821130c:	dec00704 	addi	sp,sp,28
 8211310:	f800283a 	ret

08211314 <__udivdi3>:
 8211314:	defff504 	addi	sp,sp,-44
 8211318:	dcc00415 	stw	r19,16(sp)
 821131c:	dc000115 	stw	r16,4(sp)
 8211320:	dfc00a15 	stw	ra,40(sp)
 8211324:	df000915 	stw	fp,36(sp)
 8211328:	ddc00815 	stw	r23,32(sp)
 821132c:	dd800715 	stw	r22,28(sp)
 8211330:	dd400615 	stw	r21,24(sp)
 8211334:	dd000515 	stw	r20,20(sp)
 8211338:	dc800315 	stw	r18,12(sp)
 821133c:	dc400215 	stw	r17,8(sp)
 8211340:	2027883a 	mov	r19,r4
 8211344:	2821883a 	mov	r16,r5
 8211348:	3800411e 	bne	r7,zero,8211450 <__udivdi3+0x13c>
 821134c:	3023883a 	mov	r17,r6
 8211350:	2025883a 	mov	r18,r4
 8211354:	2980522e 	bgeu	r5,r6,82114a0 <__udivdi3+0x18c>
 8211358:	00bfffd4 	movui	r2,65535
 821135c:	282d883a 	mov	r22,r5
 8211360:	1180a836 	bltu	r2,r6,8211604 <__udivdi3+0x2f0>
 8211364:	00803fc4 	movi	r2,255
 8211368:	1185803a 	cmpltu	r2,r2,r6
 821136c:	100490fa 	slli	r2,r2,3
 8211370:	3086d83a 	srl	r3,r6,r2
 8211374:	01020974 	movhi	r4,2085
 8211378:	21375d04 	addi	r4,r4,-8844
 821137c:	20c7883a 	add	r3,r4,r3
 8211380:	18c00003 	ldbu	r3,0(r3)
 8211384:	1885883a 	add	r2,r3,r2
 8211388:	00c00804 	movi	r3,32
 821138c:	1887c83a 	sub	r3,r3,r2
 8211390:	18000526 	beq	r3,zero,82113a8 <__udivdi3+0x94>
 8211394:	80e0983a 	sll	r16,r16,r3
 8211398:	9884d83a 	srl	r2,r19,r2
 821139c:	30e2983a 	sll	r17,r6,r3
 82113a0:	98e4983a 	sll	r18,r19,r3
 82113a4:	142cb03a 	or	r22,r2,r16
 82113a8:	882ad43a 	srli	r21,r17,16
 82113ac:	b009883a 	mov	r4,r22
 82113b0:	8d3fffcc 	andi	r20,r17,65535
 82113b4:	a80b883a 	mov	r5,r21
 82113b8:	8202cd00 	call	8202cd0 <__umodsi3>
 82113bc:	b009883a 	mov	r4,r22
 82113c0:	a80b883a 	mov	r5,r21
 82113c4:	1027883a 	mov	r19,r2
 82113c8:	8202c6c0 	call	8202c6c <__udivsi3>
 82113cc:	102d883a 	mov	r22,r2
 82113d0:	9826943a 	slli	r19,r19,16
 82113d4:	9004d43a 	srli	r2,r18,16
 82113d8:	a5a1383a 	mul	r16,r20,r22
 82113dc:	14c4b03a 	or	r2,r2,r19
 82113e0:	1400052e 	bgeu	r2,r16,82113f8 <__udivdi3+0xe4>
 82113e4:	1445883a 	add	r2,r2,r17
 82113e8:	b0ffffc4 	addi	r3,r22,-1
 82113ec:	14400136 	bltu	r2,r17,82113f4 <__udivdi3+0xe0>
 82113f0:	14012336 	bltu	r2,r16,8211880 <__udivdi3+0x56c>
 82113f4:	182d883a 	mov	r22,r3
 82113f8:	1421c83a 	sub	r16,r2,r16
 82113fc:	a80b883a 	mov	r5,r21
 8211400:	8009883a 	mov	r4,r16
 8211404:	8202cd00 	call	8202cd0 <__umodsi3>
 8211408:	1027883a 	mov	r19,r2
 821140c:	a80b883a 	mov	r5,r21
 8211410:	8009883a 	mov	r4,r16
 8211414:	8202c6c0 	call	8202c6c <__udivsi3>
 8211418:	9826943a 	slli	r19,r19,16
 821141c:	a0a9383a 	mul	r20,r20,r2
 8211420:	94bfffcc 	andi	r18,r18,65535
 8211424:	94e4b03a 	or	r18,r18,r19
 8211428:	9500052e 	bgeu	r18,r20,8211440 <__udivdi3+0x12c>
 821142c:	8ca5883a 	add	r18,r17,r18
 8211430:	10ffffc4 	addi	r3,r2,-1
 8211434:	9440f136 	bltu	r18,r17,82117fc <__udivdi3+0x4e8>
 8211438:	9500f02e 	bgeu	r18,r20,82117fc <__udivdi3+0x4e8>
 821143c:	10bfff84 	addi	r2,r2,-2
 8211440:	b00c943a 	slli	r6,r22,16
 8211444:	0007883a 	mov	r3,zero
 8211448:	3084b03a 	or	r2,r6,r2
 821144c:	00005906 	br	82115b4 <__udivdi3+0x2a0>
 8211450:	29c05636 	bltu	r5,r7,82115ac <__udivdi3+0x298>
 8211454:	00bfffd4 	movui	r2,65535
 8211458:	11c0622e 	bgeu	r2,r7,82115e4 <__udivdi3+0x2d0>
 821145c:	00804034 	movhi	r2,256
 8211460:	10bfffc4 	addi	r2,r2,-1
 8211464:	11c0ee36 	bltu	r2,r7,8211820 <__udivdi3+0x50c>
 8211468:	00800404 	movi	r2,16
 821146c:	3886d83a 	srl	r3,r7,r2
 8211470:	01020974 	movhi	r4,2085
 8211474:	21375d04 	addi	r4,r4,-8844
 8211478:	20c7883a 	add	r3,r4,r3
 821147c:	18c00003 	ldbu	r3,0(r3)
 8211480:	05400804 	movi	r21,32
 8211484:	1885883a 	add	r2,r3,r2
 8211488:	a8abc83a 	sub	r21,r21,r2
 821148c:	a800621e 	bne	r21,zero,8211618 <__udivdi3+0x304>
 8211490:	3c00e936 	bltu	r7,r16,8211838 <__udivdi3+0x524>
 8211494:	9985403a 	cmpgeu	r2,r19,r6
 8211498:	0007883a 	mov	r3,zero
 821149c:	00004506 	br	82115b4 <__udivdi3+0x2a0>
 82114a0:	3000041e 	bne	r6,zero,82114b4 <__udivdi3+0x1a0>
 82114a4:	000b883a 	mov	r5,zero
 82114a8:	01000044 	movi	r4,1
 82114ac:	8202c6c0 	call	8202c6c <__udivsi3>
 82114b0:	1023883a 	mov	r17,r2
 82114b4:	00bfffd4 	movui	r2,65535
 82114b8:	14404e2e 	bgeu	r2,r17,82115f4 <__udivdi3+0x2e0>
 82114bc:	00804034 	movhi	r2,256
 82114c0:	10bfffc4 	addi	r2,r2,-1
 82114c4:	1440d836 	bltu	r2,r17,8211828 <__udivdi3+0x514>
 82114c8:	00800404 	movi	r2,16
 82114cc:	8886d83a 	srl	r3,r17,r2
 82114d0:	01020974 	movhi	r4,2085
 82114d4:	21375d04 	addi	r4,r4,-8844
 82114d8:	20c7883a 	add	r3,r4,r3
 82114dc:	18c00003 	ldbu	r3,0(r3)
 82114e0:	1885883a 	add	r2,r3,r2
 82114e4:	00c00804 	movi	r3,32
 82114e8:	1887c83a 	sub	r3,r3,r2
 82114ec:	18008f1e 	bne	r3,zero,821172c <__udivdi3+0x418>
 82114f0:	882ad43a 	srli	r21,r17,16
 82114f4:	8461c83a 	sub	r16,r16,r17
 82114f8:	8d3fffcc 	andi	r20,r17,65535
 82114fc:	00c00044 	movi	r3,1
 8211500:	8009883a 	mov	r4,r16
 8211504:	a80b883a 	mov	r5,r21
 8211508:	d8c00015 	stw	r3,0(sp)
 821150c:	8202cd00 	call	8202cd0 <__umodsi3>
 8211510:	8009883a 	mov	r4,r16
 8211514:	a80b883a 	mov	r5,r21
 8211518:	1027883a 	mov	r19,r2
 821151c:	8202c6c0 	call	8202c6c <__udivsi3>
 8211520:	9826943a 	slli	r19,r19,16
 8211524:	9008d43a 	srli	r4,r18,16
 8211528:	1521383a 	mul	r16,r2,r20
 821152c:	102d883a 	mov	r22,r2
 8211530:	24c8b03a 	or	r4,r4,r19
 8211534:	d8c00017 	ldw	r3,0(sp)
 8211538:	2400052e 	bgeu	r4,r16,8211550 <__udivdi3+0x23c>
 821153c:	2449883a 	add	r4,r4,r17
 8211540:	b0bfffc4 	addi	r2,r22,-1
 8211544:	24400136 	bltu	r4,r17,821154c <__udivdi3+0x238>
 8211548:	2400ca36 	bltu	r4,r16,8211874 <__udivdi3+0x560>
 821154c:	102d883a 	mov	r22,r2
 8211550:	2421c83a 	sub	r16,r4,r16
 8211554:	a80b883a 	mov	r5,r21
 8211558:	8009883a 	mov	r4,r16
 821155c:	d8c00015 	stw	r3,0(sp)
 8211560:	8202cd00 	call	8202cd0 <__umodsi3>
 8211564:	1027883a 	mov	r19,r2
 8211568:	a80b883a 	mov	r5,r21
 821156c:	8009883a 	mov	r4,r16
 8211570:	8202c6c0 	call	8202c6c <__udivsi3>
 8211574:	9826943a 	slli	r19,r19,16
 8211578:	1529383a 	mul	r20,r2,r20
 821157c:	94bfffcc 	andi	r18,r18,65535
 8211580:	94e4b03a 	or	r18,r18,r19
 8211584:	d8c00017 	ldw	r3,0(sp)
 8211588:	9500052e 	bgeu	r18,r20,82115a0 <__udivdi3+0x28c>
 821158c:	8ca5883a 	add	r18,r17,r18
 8211590:	113fffc4 	addi	r4,r2,-1
 8211594:	94409736 	bltu	r18,r17,82117f4 <__udivdi3+0x4e0>
 8211598:	9500962e 	bgeu	r18,r20,82117f4 <__udivdi3+0x4e0>
 821159c:	10bfff84 	addi	r2,r2,-2
 82115a0:	b00c943a 	slli	r6,r22,16
 82115a4:	3084b03a 	or	r2,r6,r2
 82115a8:	00000206 	br	82115b4 <__udivdi3+0x2a0>
 82115ac:	0007883a 	mov	r3,zero
 82115b0:	0005883a 	mov	r2,zero
 82115b4:	dfc00a17 	ldw	ra,40(sp)
 82115b8:	df000917 	ldw	fp,36(sp)
 82115bc:	ddc00817 	ldw	r23,32(sp)
 82115c0:	dd800717 	ldw	r22,28(sp)
 82115c4:	dd400617 	ldw	r21,24(sp)
 82115c8:	dd000517 	ldw	r20,20(sp)
 82115cc:	dcc00417 	ldw	r19,16(sp)
 82115d0:	dc800317 	ldw	r18,12(sp)
 82115d4:	dc400217 	ldw	r17,8(sp)
 82115d8:	dc000117 	ldw	r16,4(sp)
 82115dc:	dec00b04 	addi	sp,sp,44
 82115e0:	f800283a 	ret
 82115e4:	00803fc4 	movi	r2,255
 82115e8:	11c5803a 	cmpltu	r2,r2,r7
 82115ec:	100490fa 	slli	r2,r2,3
 82115f0:	003f9e06 	br	821146c <__udivdi3+0x158>
 82115f4:	00803fc4 	movi	r2,255
 82115f8:	1445803a 	cmpltu	r2,r2,r17
 82115fc:	100490fa 	slli	r2,r2,3
 8211600:	003fb206 	br	82114cc <__udivdi3+0x1b8>
 8211604:	00804034 	movhi	r2,256
 8211608:	10bfffc4 	addi	r2,r2,-1
 821160c:	11808836 	bltu	r2,r6,8211830 <__udivdi3+0x51c>
 8211610:	00800404 	movi	r2,16
 8211614:	003f5606 	br	8211370 <__udivdi3+0x5c>
 8211618:	30aed83a 	srl	r23,r6,r2
 821161c:	3d4e983a 	sll	r7,r7,r21
 8211620:	80acd83a 	srl	r22,r16,r2
 8211624:	9884d83a 	srl	r2,r19,r2
 8211628:	3deeb03a 	or	r23,r7,r23
 821162c:	b824d43a 	srli	r18,r23,16
 8211630:	8560983a 	sll	r16,r16,r21
 8211634:	b009883a 	mov	r4,r22
 8211638:	900b883a 	mov	r5,r18
 821163c:	3568983a 	sll	r20,r6,r21
 8211640:	1420b03a 	or	r16,r2,r16
 8211644:	8202cd00 	call	8202cd0 <__umodsi3>
 8211648:	b009883a 	mov	r4,r22
 821164c:	900b883a 	mov	r5,r18
 8211650:	1023883a 	mov	r17,r2
 8211654:	8202c6c0 	call	8202c6c <__udivsi3>
 8211658:	8808943a 	slli	r4,r17,16
 821165c:	bf3fffcc 	andi	fp,r23,65535
 8211660:	8006d43a 	srli	r3,r16,16
 8211664:	e0a3383a 	mul	r17,fp,r2
 8211668:	100d883a 	mov	r6,r2
 821166c:	1906b03a 	or	r3,r3,r4
 8211670:	1c40042e 	bgeu	r3,r17,8211684 <__udivdi3+0x370>
 8211674:	1dc7883a 	add	r3,r3,r23
 8211678:	10bfffc4 	addi	r2,r2,-1
 821167c:	1dc0752e 	bgeu	r3,r23,8211854 <__udivdi3+0x540>
 8211680:	100d883a 	mov	r6,r2
 8211684:	1c63c83a 	sub	r17,r3,r17
 8211688:	900b883a 	mov	r5,r18
 821168c:	8809883a 	mov	r4,r17
 8211690:	d9800015 	stw	r6,0(sp)
 8211694:	8202cd00 	call	8202cd0 <__umodsi3>
 8211698:	102d883a 	mov	r22,r2
 821169c:	8809883a 	mov	r4,r17
 82116a0:	900b883a 	mov	r5,r18
 82116a4:	8202c6c0 	call	8202c6c <__udivsi3>
 82116a8:	b02c943a 	slli	r22,r22,16
 82116ac:	e089383a 	mul	r4,fp,r2
 82116b0:	843fffcc 	andi	r16,r16,65535
 82116b4:	85a0b03a 	or	r16,r16,r22
 82116b8:	d9800017 	ldw	r6,0(sp)
 82116bc:	8100042e 	bgeu	r16,r4,82116d0 <__udivdi3+0x3bc>
 82116c0:	85e1883a 	add	r16,r16,r23
 82116c4:	10ffffc4 	addi	r3,r2,-1
 82116c8:	85c05e2e 	bgeu	r16,r23,8211844 <__udivdi3+0x530>
 82116cc:	1805883a 	mov	r2,r3
 82116d0:	300c943a 	slli	r6,r6,16
 82116d4:	a17fffcc 	andi	r5,r20,65535
 82116d8:	a028d43a 	srli	r20,r20,16
 82116dc:	3084b03a 	or	r2,r6,r2
 82116e0:	10ffffcc 	andi	r3,r2,65535
 82116e4:	100cd43a 	srli	r6,r2,16
 82116e8:	194f383a 	mul	r7,r3,r5
 82116ec:	1d07383a 	mul	r3,r3,r20
 82116f0:	314b383a 	mul	r5,r6,r5
 82116f4:	3810d43a 	srli	r8,r7,16
 82116f8:	8121c83a 	sub	r16,r16,r4
 82116fc:	1947883a 	add	r3,r3,r5
 8211700:	40c7883a 	add	r3,r8,r3
 8211704:	350d383a 	mul	r6,r6,r20
 8211708:	1940022e 	bgeu	r3,r5,8211714 <__udivdi3+0x400>
 821170c:	01000074 	movhi	r4,1
 8211710:	310d883a 	add	r6,r6,r4
 8211714:	1828d43a 	srli	r20,r3,16
 8211718:	a18d883a 	add	r6,r20,r6
 821171c:	81803e36 	bltu	r16,r6,8211818 <__udivdi3+0x504>
 8211720:	81803826 	beq	r16,r6,8211804 <__udivdi3+0x4f0>
 8211724:	0007883a 	mov	r3,zero
 8211728:	003fa206 	br	82115b4 <__udivdi3+0x2a0>
 821172c:	88e2983a 	sll	r17,r17,r3
 8211730:	80a8d83a 	srl	r20,r16,r2
 8211734:	80e0983a 	sll	r16,r16,r3
 8211738:	882ad43a 	srli	r21,r17,16
 821173c:	9884d83a 	srl	r2,r19,r2
 8211740:	a009883a 	mov	r4,r20
 8211744:	a80b883a 	mov	r5,r21
 8211748:	142eb03a 	or	r23,r2,r16
 821174c:	98e4983a 	sll	r18,r19,r3
 8211750:	8202cd00 	call	8202cd0 <__umodsi3>
 8211754:	a009883a 	mov	r4,r20
 8211758:	a80b883a 	mov	r5,r21
 821175c:	1021883a 	mov	r16,r2
 8211760:	8202c6c0 	call	8202c6c <__udivsi3>
 8211764:	1039883a 	mov	fp,r2
 8211768:	8d3fffcc 	andi	r20,r17,65535
 821176c:	8020943a 	slli	r16,r16,16
 8211770:	b804d43a 	srli	r2,r23,16
 8211774:	a72d383a 	mul	r22,r20,fp
 8211778:	1404b03a 	or	r2,r2,r16
 821177c:	1580062e 	bgeu	r2,r22,8211798 <__udivdi3+0x484>
 8211780:	1445883a 	add	r2,r2,r17
 8211784:	e0ffffc4 	addi	r3,fp,-1
 8211788:	14403836 	bltu	r2,r17,821186c <__udivdi3+0x558>
 821178c:	1580372e 	bgeu	r2,r22,821186c <__udivdi3+0x558>
 8211790:	e73fff84 	addi	fp,fp,-2
 8211794:	1445883a 	add	r2,r2,r17
 8211798:	15adc83a 	sub	r22,r2,r22
 821179c:	a80b883a 	mov	r5,r21
 82117a0:	b009883a 	mov	r4,r22
 82117a4:	8202cd00 	call	8202cd0 <__umodsi3>
 82117a8:	1027883a 	mov	r19,r2
 82117ac:	b009883a 	mov	r4,r22
 82117b0:	a80b883a 	mov	r5,r21
 82117b4:	8202c6c0 	call	8202c6c <__udivsi3>
 82117b8:	9826943a 	slli	r19,r19,16
 82117bc:	a0a1383a 	mul	r16,r20,r2
 82117c0:	b93fffcc 	andi	r4,r23,65535
 82117c4:	24c8b03a 	or	r4,r4,r19
 82117c8:	2400062e 	bgeu	r4,r16,82117e4 <__udivdi3+0x4d0>
 82117cc:	2449883a 	add	r4,r4,r17
 82117d0:	10ffffc4 	addi	r3,r2,-1
 82117d4:	24402336 	bltu	r4,r17,8211864 <__udivdi3+0x550>
 82117d8:	2400222e 	bgeu	r4,r16,8211864 <__udivdi3+0x550>
 82117dc:	10bfff84 	addi	r2,r2,-2
 82117e0:	2449883a 	add	r4,r4,r17
 82117e4:	e038943a 	slli	fp,fp,16
 82117e8:	2421c83a 	sub	r16,r4,r16
 82117ec:	e086b03a 	or	r3,fp,r2
 82117f0:	003f4306 	br	8211500 <__udivdi3+0x1ec>
 82117f4:	2005883a 	mov	r2,r4
 82117f8:	003f6906 	br	82115a0 <__udivdi3+0x28c>
 82117fc:	1805883a 	mov	r2,r3
 8211800:	003f0f06 	br	8211440 <__udivdi3+0x12c>
 8211804:	1806943a 	slli	r3,r3,16
 8211808:	9d66983a 	sll	r19,r19,r21
 821180c:	39ffffcc 	andi	r7,r7,65535
 8211810:	19c7883a 	add	r3,r3,r7
 8211814:	98ffc32e 	bgeu	r19,r3,8211724 <__udivdi3+0x410>
 8211818:	10bfffc4 	addi	r2,r2,-1
 821181c:	003fc106 	br	8211724 <__udivdi3+0x410>
 8211820:	00800604 	movi	r2,24
 8211824:	003f1106 	br	821146c <__udivdi3+0x158>
 8211828:	00800604 	movi	r2,24
 821182c:	003f2706 	br	82114cc <__udivdi3+0x1b8>
 8211830:	00800604 	movi	r2,24
 8211834:	003ece06 	br	8211370 <__udivdi3+0x5c>
 8211838:	0007883a 	mov	r3,zero
 821183c:	00800044 	movi	r2,1
 8211840:	003f5c06 	br	82115b4 <__udivdi3+0x2a0>
 8211844:	813fa12e 	bgeu	r16,r4,82116cc <__udivdi3+0x3b8>
 8211848:	10bfff84 	addi	r2,r2,-2
 821184c:	85e1883a 	add	r16,r16,r23
 8211850:	003f9f06 	br	82116d0 <__udivdi3+0x3bc>
 8211854:	1c7f8a2e 	bgeu	r3,r17,8211680 <__udivdi3+0x36c>
 8211858:	31bfff84 	addi	r6,r6,-2
 821185c:	1dc7883a 	add	r3,r3,r23
 8211860:	003f8806 	br	8211684 <__udivdi3+0x370>
 8211864:	1805883a 	mov	r2,r3
 8211868:	003fde06 	br	82117e4 <__udivdi3+0x4d0>
 821186c:	1839883a 	mov	fp,r3
 8211870:	003fc906 	br	8211798 <__udivdi3+0x484>
 8211874:	b5bfff84 	addi	r22,r22,-2
 8211878:	2449883a 	add	r4,r4,r17
 821187c:	003f3406 	br	8211550 <__udivdi3+0x23c>
 8211880:	b5bfff84 	addi	r22,r22,-2
 8211884:	1445883a 	add	r2,r2,r17
 8211888:	003edb06 	br	82113f8 <__udivdi3+0xe4>

0821188c <__umoddi3>:
 821188c:	defff404 	addi	sp,sp,-48
 8211890:	df000a15 	stw	fp,40(sp)
 8211894:	dc400315 	stw	r17,12(sp)
 8211898:	dc000215 	stw	r16,8(sp)
 821189c:	dfc00b15 	stw	ra,44(sp)
 82118a0:	ddc00915 	stw	r23,36(sp)
 82118a4:	dd800815 	stw	r22,32(sp)
 82118a8:	dd400715 	stw	r21,28(sp)
 82118ac:	dd000615 	stw	r20,24(sp)
 82118b0:	dcc00515 	stw	r19,20(sp)
 82118b4:	dc800415 	stw	r18,16(sp)
 82118b8:	2021883a 	mov	r16,r4
 82118bc:	2823883a 	mov	r17,r5
 82118c0:	2839883a 	mov	fp,r5
 82118c4:	38003c1e 	bne	r7,zero,82119b8 <__umoddi3+0x12c>
 82118c8:	3027883a 	mov	r19,r6
 82118cc:	2029883a 	mov	r20,r4
 82118d0:	2980512e 	bgeu	r5,r6,8211a18 <__umoddi3+0x18c>
 82118d4:	00bfffd4 	movui	r2,65535
 82118d8:	11809a36 	bltu	r2,r6,8211b44 <__umoddi3+0x2b8>
 82118dc:	01003fc4 	movi	r4,255
 82118e0:	2189803a 	cmpltu	r4,r4,r6
 82118e4:	200890fa 	slli	r4,r4,3
 82118e8:	3104d83a 	srl	r2,r6,r4
 82118ec:	00c20974 	movhi	r3,2085
 82118f0:	18f75d04 	addi	r3,r3,-8844
 82118f4:	1885883a 	add	r2,r3,r2
 82118f8:	10c00003 	ldbu	r3,0(r2)
 82118fc:	00800804 	movi	r2,32
 8211900:	1909883a 	add	r4,r3,r4
 8211904:	1125c83a 	sub	r18,r2,r4
 8211908:	90000526 	beq	r18,zero,8211920 <__umoddi3+0x94>
 821190c:	8ca2983a 	sll	r17,r17,r18
 8211910:	8108d83a 	srl	r4,r16,r4
 8211914:	34a6983a 	sll	r19,r6,r18
 8211918:	84a8983a 	sll	r20,r16,r18
 821191c:	2478b03a 	or	fp,r4,r17
 8211920:	982ed43a 	srli	r23,r19,16
 8211924:	e009883a 	mov	r4,fp
 8211928:	9dbfffcc 	andi	r22,r19,65535
 821192c:	b80b883a 	mov	r5,r23
 8211930:	8202cd00 	call	8202cd0 <__umodsi3>
 8211934:	e009883a 	mov	r4,fp
 8211938:	b80b883a 	mov	r5,r23
 821193c:	102b883a 	mov	r21,r2
 8211940:	8202c6c0 	call	8202c6c <__udivsi3>
 8211944:	a806943a 	slli	r3,r21,16
 8211948:	a008d43a 	srli	r4,r20,16
 821194c:	b085383a 	mul	r2,r22,r2
 8211950:	20c8b03a 	or	r4,r4,r3
 8211954:	2080032e 	bgeu	r4,r2,8211964 <__umoddi3+0xd8>
 8211958:	24c9883a 	add	r4,r4,r19
 821195c:	24c00136 	bltu	r4,r19,8211964 <__umoddi3+0xd8>
 8211960:	20811036 	bltu	r4,r2,8211da4 <__umoddi3+0x518>
 8211964:	20abc83a 	sub	r21,r4,r2
 8211968:	b80b883a 	mov	r5,r23
 821196c:	a809883a 	mov	r4,r21
 8211970:	8202cd00 	call	8202cd0 <__umodsi3>
 8211974:	1023883a 	mov	r17,r2
 8211978:	b80b883a 	mov	r5,r23
 821197c:	a809883a 	mov	r4,r21
 8211980:	8202c6c0 	call	8202c6c <__udivsi3>
 8211984:	8822943a 	slli	r17,r17,16
 8211988:	b085383a 	mul	r2,r22,r2
 821198c:	a0ffffcc 	andi	r3,r20,65535
 8211990:	1c46b03a 	or	r3,r3,r17
 8211994:	1880042e 	bgeu	r3,r2,82119a8 <__umoddi3+0x11c>
 8211998:	1cc7883a 	add	r3,r3,r19
 821199c:	1cc00236 	bltu	r3,r19,82119a8 <__umoddi3+0x11c>
 82119a0:	1880012e 	bgeu	r3,r2,82119a8 <__umoddi3+0x11c>
 82119a4:	1cc7883a 	add	r3,r3,r19
 82119a8:	1885c83a 	sub	r2,r3,r2
 82119ac:	1484d83a 	srl	r2,r2,r18
 82119b0:	0007883a 	mov	r3,zero
 82119b4:	00004f06 	br	8211af4 <__umoddi3+0x268>
 82119b8:	29c04c36 	bltu	r5,r7,8211aec <__umoddi3+0x260>
 82119bc:	00bfffd4 	movui	r2,65535
 82119c0:	11c0582e 	bgeu	r2,r7,8211b24 <__umoddi3+0x298>
 82119c4:	00804034 	movhi	r2,256
 82119c8:	10bfffc4 	addi	r2,r2,-1
 82119cc:	11c0e736 	bltu	r2,r7,8211d6c <__umoddi3+0x4e0>
 82119d0:	01000404 	movi	r4,16
 82119d4:	3904d83a 	srl	r2,r7,r4
 82119d8:	00c20974 	movhi	r3,2085
 82119dc:	18f75d04 	addi	r3,r3,-8844
 82119e0:	1885883a 	add	r2,r3,r2
 82119e4:	14c00003 	ldbu	r19,0(r2)
 82119e8:	00c00804 	movi	r3,32
 82119ec:	9927883a 	add	r19,r19,r4
 82119f0:	1ce9c83a 	sub	r20,r3,r19
 82119f4:	a000581e 	bne	r20,zero,8211b58 <__umoddi3+0x2cc>
 82119f8:	3c400136 	bltu	r7,r17,8211a00 <__umoddi3+0x174>
 82119fc:	8180eb36 	bltu	r16,r6,8211dac <__umoddi3+0x520>
 8211a00:	8185c83a 	sub	r2,r16,r6
 8211a04:	89e3c83a 	sub	r17,r17,r7
 8211a08:	8089803a 	cmpltu	r4,r16,r2
 8211a0c:	8939c83a 	sub	fp,r17,r4
 8211a10:	e007883a 	mov	r3,fp
 8211a14:	00003706 	br	8211af4 <__umoddi3+0x268>
 8211a18:	3000041e 	bne	r6,zero,8211a2c <__umoddi3+0x1a0>
 8211a1c:	000b883a 	mov	r5,zero
 8211a20:	01000044 	movi	r4,1
 8211a24:	8202c6c0 	call	8202c6c <__udivsi3>
 8211a28:	1027883a 	mov	r19,r2
 8211a2c:	00bfffd4 	movui	r2,65535
 8211a30:	14c0402e 	bgeu	r2,r19,8211b34 <__umoddi3+0x2a8>
 8211a34:	00804034 	movhi	r2,256
 8211a38:	10bfffc4 	addi	r2,r2,-1
 8211a3c:	14c0cd36 	bltu	r2,r19,8211d74 <__umoddi3+0x4e8>
 8211a40:	00800404 	movi	r2,16
 8211a44:	9886d83a 	srl	r3,r19,r2
 8211a48:	01020974 	movhi	r4,2085
 8211a4c:	21375d04 	addi	r4,r4,-8844
 8211a50:	20c7883a 	add	r3,r4,r3
 8211a54:	18c00003 	ldbu	r3,0(r3)
 8211a58:	1887883a 	add	r3,r3,r2
 8211a5c:	00800804 	movi	r2,32
 8211a60:	10e5c83a 	sub	r18,r2,r3
 8211a64:	9000901e 	bne	r18,zero,8211ca8 <__umoddi3+0x41c>
 8211a68:	982cd43a 	srli	r22,r19,16
 8211a6c:	8ce3c83a 	sub	r17,r17,r19
 8211a70:	9d7fffcc 	andi	r21,r19,65535
 8211a74:	b00b883a 	mov	r5,r22
 8211a78:	8809883a 	mov	r4,r17
 8211a7c:	8202cd00 	call	8202cd0 <__umodsi3>
 8211a80:	8809883a 	mov	r4,r17
 8211a84:	b00b883a 	mov	r5,r22
 8211a88:	1021883a 	mov	r16,r2
 8211a8c:	8202c6c0 	call	8202c6c <__udivsi3>
 8211a90:	8006943a 	slli	r3,r16,16
 8211a94:	a008d43a 	srli	r4,r20,16
 8211a98:	1545383a 	mul	r2,r2,r21
 8211a9c:	20c8b03a 	or	r4,r4,r3
 8211aa0:	2080042e 	bgeu	r4,r2,8211ab4 <__umoddi3+0x228>
 8211aa4:	24c9883a 	add	r4,r4,r19
 8211aa8:	24c00236 	bltu	r4,r19,8211ab4 <__umoddi3+0x228>
 8211aac:	2080012e 	bgeu	r4,r2,8211ab4 <__umoddi3+0x228>
 8211ab0:	24c9883a 	add	r4,r4,r19
 8211ab4:	20a1c83a 	sub	r16,r4,r2
 8211ab8:	b00b883a 	mov	r5,r22
 8211abc:	8009883a 	mov	r4,r16
 8211ac0:	8202cd00 	call	8202cd0 <__umodsi3>
 8211ac4:	1023883a 	mov	r17,r2
 8211ac8:	b00b883a 	mov	r5,r22
 8211acc:	8009883a 	mov	r4,r16
 8211ad0:	8202c6c0 	call	8202c6c <__udivsi3>
 8211ad4:	8822943a 	slli	r17,r17,16
 8211ad8:	1545383a 	mul	r2,r2,r21
 8211adc:	a53fffcc 	andi	r20,r20,65535
 8211ae0:	a446b03a 	or	r3,r20,r17
 8211ae4:	18bfb02e 	bgeu	r3,r2,82119a8 <__umoddi3+0x11c>
 8211ae8:	003fab06 	br	8211998 <__umoddi3+0x10c>
 8211aec:	2005883a 	mov	r2,r4
 8211af0:	2807883a 	mov	r3,r5
 8211af4:	dfc00b17 	ldw	ra,44(sp)
 8211af8:	df000a17 	ldw	fp,40(sp)
 8211afc:	ddc00917 	ldw	r23,36(sp)
 8211b00:	dd800817 	ldw	r22,32(sp)
 8211b04:	dd400717 	ldw	r21,28(sp)
 8211b08:	dd000617 	ldw	r20,24(sp)
 8211b0c:	dcc00517 	ldw	r19,20(sp)
 8211b10:	dc800417 	ldw	r18,16(sp)
 8211b14:	dc400317 	ldw	r17,12(sp)
 8211b18:	dc000217 	ldw	r16,8(sp)
 8211b1c:	dec00c04 	addi	sp,sp,48
 8211b20:	f800283a 	ret
 8211b24:	04c03fc4 	movi	r19,255
 8211b28:	99c9803a 	cmpltu	r4,r19,r7
 8211b2c:	200890fa 	slli	r4,r4,3
 8211b30:	003fa806 	br	82119d4 <__umoddi3+0x148>
 8211b34:	00803fc4 	movi	r2,255
 8211b38:	14c5803a 	cmpltu	r2,r2,r19
 8211b3c:	100490fa 	slli	r2,r2,3
 8211b40:	003fc006 	br	8211a44 <__umoddi3+0x1b8>
 8211b44:	00804034 	movhi	r2,256
 8211b48:	10bfffc4 	addi	r2,r2,-1
 8211b4c:	11808b36 	bltu	r2,r6,8211d7c <__umoddi3+0x4f0>
 8211b50:	01000404 	movi	r4,16
 8211b54:	003f6406 	br	82118e8 <__umoddi3+0x5c>
 8211b58:	34c4d83a 	srl	r2,r6,r19
 8211b5c:	3d0e983a 	sll	r7,r7,r20
 8211b60:	8cf8d83a 	srl	fp,r17,r19
 8211b64:	8d10983a 	sll	r8,r17,r20
 8211b68:	38aab03a 	or	r21,r7,r2
 8211b6c:	a82cd43a 	srli	r22,r21,16
 8211b70:	84e2d83a 	srl	r17,r16,r19
 8211b74:	e009883a 	mov	r4,fp
 8211b78:	b00b883a 	mov	r5,r22
 8211b7c:	8a22b03a 	or	r17,r17,r8
 8211b80:	3524983a 	sll	r18,r6,r20
 8211b84:	8202cd00 	call	8202cd0 <__umodsi3>
 8211b88:	e009883a 	mov	r4,fp
 8211b8c:	b00b883a 	mov	r5,r22
 8211b90:	102f883a 	mov	r23,r2
 8211b94:	8202c6c0 	call	8202c6c <__udivsi3>
 8211b98:	100d883a 	mov	r6,r2
 8211b9c:	b808943a 	slli	r4,r23,16
 8211ba0:	aa3fffcc 	andi	r8,r21,65535
 8211ba4:	8804d43a 	srli	r2,r17,16
 8211ba8:	41af383a 	mul	r23,r8,r6
 8211bac:	8520983a 	sll	r16,r16,r20
 8211bb0:	1104b03a 	or	r2,r2,r4
 8211bb4:	15c0042e 	bgeu	r2,r23,8211bc8 <__umoddi3+0x33c>
 8211bb8:	1545883a 	add	r2,r2,r21
 8211bbc:	30ffffc4 	addi	r3,r6,-1
 8211bc0:	1540742e 	bgeu	r2,r21,8211d94 <__umoddi3+0x508>
 8211bc4:	180d883a 	mov	r6,r3
 8211bc8:	15efc83a 	sub	r23,r2,r23
 8211bcc:	b00b883a 	mov	r5,r22
 8211bd0:	b809883a 	mov	r4,r23
 8211bd4:	d9800115 	stw	r6,4(sp)
 8211bd8:	da000015 	stw	r8,0(sp)
 8211bdc:	8202cd00 	call	8202cd0 <__umodsi3>
 8211be0:	b00b883a 	mov	r5,r22
 8211be4:	b809883a 	mov	r4,r23
 8211be8:	1039883a 	mov	fp,r2
 8211bec:	8202c6c0 	call	8202c6c <__udivsi3>
 8211bf0:	da000017 	ldw	r8,0(sp)
 8211bf4:	e038943a 	slli	fp,fp,16
 8211bf8:	100b883a 	mov	r5,r2
 8211bfc:	4089383a 	mul	r4,r8,r2
 8211c00:	8a3fffcc 	andi	r8,r17,65535
 8211c04:	4710b03a 	or	r8,r8,fp
 8211c08:	d9800117 	ldw	r6,4(sp)
 8211c0c:	4100042e 	bgeu	r8,r4,8211c20 <__umoddi3+0x394>
 8211c10:	4551883a 	add	r8,r8,r21
 8211c14:	10bfffc4 	addi	r2,r2,-1
 8211c18:	45405a2e 	bgeu	r8,r21,8211d84 <__umoddi3+0x4f8>
 8211c1c:	100b883a 	mov	r5,r2
 8211c20:	300c943a 	slli	r6,r6,16
 8211c24:	91ffffcc 	andi	r7,r18,65535
 8211c28:	9004d43a 	srli	r2,r18,16
 8211c2c:	314cb03a 	or	r6,r6,r5
 8211c30:	317fffcc 	andi	r5,r6,65535
 8211c34:	300cd43a 	srli	r6,r6,16
 8211c38:	29d3383a 	mul	r9,r5,r7
 8211c3c:	288b383a 	mul	r5,r5,r2
 8211c40:	31cf383a 	mul	r7,r6,r7
 8211c44:	4806d43a 	srli	r3,r9,16
 8211c48:	4111c83a 	sub	r8,r8,r4
 8211c4c:	29cb883a 	add	r5,r5,r7
 8211c50:	194b883a 	add	r5,r3,r5
 8211c54:	3085383a 	mul	r2,r6,r2
 8211c58:	29c0022e 	bgeu	r5,r7,8211c64 <__umoddi3+0x3d8>
 8211c5c:	00c00074 	movhi	r3,1
 8211c60:	10c5883a 	add	r2,r2,r3
 8211c64:	2808d43a 	srli	r4,r5,16
 8211c68:	280a943a 	slli	r5,r5,16
 8211c6c:	4a7fffcc 	andi	r9,r9,65535
 8211c70:	2085883a 	add	r2,r4,r2
 8211c74:	2a4b883a 	add	r5,r5,r9
 8211c78:	40803636 	bltu	r8,r2,8211d54 <__umoddi3+0x4c8>
 8211c7c:	40804d26 	beq	r8,r2,8211db4 <__umoddi3+0x528>
 8211c80:	4089c83a 	sub	r4,r8,r2
 8211c84:	280f883a 	mov	r7,r5
 8211c88:	81cfc83a 	sub	r7,r16,r7
 8211c8c:	81c7803a 	cmpltu	r3,r16,r7
 8211c90:	20c7c83a 	sub	r3,r4,r3
 8211c94:	1cc4983a 	sll	r2,r3,r19
 8211c98:	3d0ed83a 	srl	r7,r7,r20
 8211c9c:	1d06d83a 	srl	r3,r3,r20
 8211ca0:	11c4b03a 	or	r2,r2,r7
 8211ca4:	003f9306 	br	8211af4 <__umoddi3+0x268>
 8211ca8:	9ca6983a 	sll	r19,r19,r18
 8211cac:	88e8d83a 	srl	r20,r17,r3
 8211cb0:	80c4d83a 	srl	r2,r16,r3
 8211cb4:	982cd43a 	srli	r22,r19,16
 8211cb8:	8ca2983a 	sll	r17,r17,r18
 8211cbc:	a009883a 	mov	r4,r20
 8211cc0:	b00b883a 	mov	r5,r22
 8211cc4:	1478b03a 	or	fp,r2,r17
 8211cc8:	8202cd00 	call	8202cd0 <__umodsi3>
 8211ccc:	a009883a 	mov	r4,r20
 8211cd0:	b00b883a 	mov	r5,r22
 8211cd4:	1023883a 	mov	r17,r2
 8211cd8:	8202c6c0 	call	8202c6c <__udivsi3>
 8211cdc:	9d7fffcc 	andi	r21,r19,65535
 8211ce0:	880a943a 	slli	r5,r17,16
 8211ce4:	e008d43a 	srli	r4,fp,16
 8211ce8:	a885383a 	mul	r2,r21,r2
 8211cec:	84a8983a 	sll	r20,r16,r18
 8211cf0:	2148b03a 	or	r4,r4,r5
 8211cf4:	2080042e 	bgeu	r4,r2,8211d08 <__umoddi3+0x47c>
 8211cf8:	24c9883a 	add	r4,r4,r19
 8211cfc:	24c00236 	bltu	r4,r19,8211d08 <__umoddi3+0x47c>
 8211d00:	2080012e 	bgeu	r4,r2,8211d08 <__umoddi3+0x47c>
 8211d04:	24c9883a 	add	r4,r4,r19
 8211d08:	20a3c83a 	sub	r17,r4,r2
 8211d0c:	b00b883a 	mov	r5,r22
 8211d10:	8809883a 	mov	r4,r17
 8211d14:	8202cd00 	call	8202cd0 <__umodsi3>
 8211d18:	102f883a 	mov	r23,r2
 8211d1c:	8809883a 	mov	r4,r17
 8211d20:	b00b883a 	mov	r5,r22
 8211d24:	8202c6c0 	call	8202c6c <__udivsi3>
 8211d28:	b82e943a 	slli	r23,r23,16
 8211d2c:	a885383a 	mul	r2,r21,r2
 8211d30:	e13fffcc 	andi	r4,fp,65535
 8211d34:	25c8b03a 	or	r4,r4,r23
 8211d38:	2080042e 	bgeu	r4,r2,8211d4c <__umoddi3+0x4c0>
 8211d3c:	24c9883a 	add	r4,r4,r19
 8211d40:	24c00236 	bltu	r4,r19,8211d4c <__umoddi3+0x4c0>
 8211d44:	2080012e 	bgeu	r4,r2,8211d4c <__umoddi3+0x4c0>
 8211d48:	24c9883a 	add	r4,r4,r19
 8211d4c:	20a3c83a 	sub	r17,r4,r2
 8211d50:	003f4806 	br	8211a74 <__umoddi3+0x1e8>
 8211d54:	2c8fc83a 	sub	r7,r5,r18
 8211d58:	1545c83a 	sub	r2,r2,r21
 8211d5c:	29cb803a 	cmpltu	r5,r5,r7
 8211d60:	1145c83a 	sub	r2,r2,r5
 8211d64:	4089c83a 	sub	r4,r8,r2
 8211d68:	003fc706 	br	8211c88 <__umoddi3+0x3fc>
 8211d6c:	01000604 	movi	r4,24
 8211d70:	003f1806 	br	82119d4 <__umoddi3+0x148>
 8211d74:	00800604 	movi	r2,24
 8211d78:	003f3206 	br	8211a44 <__umoddi3+0x1b8>
 8211d7c:	01000604 	movi	r4,24
 8211d80:	003ed906 	br	82118e8 <__umoddi3+0x5c>
 8211d84:	413fa52e 	bgeu	r8,r4,8211c1c <__umoddi3+0x390>
 8211d88:	297fff84 	addi	r5,r5,-2
 8211d8c:	4551883a 	add	r8,r8,r21
 8211d90:	003fa306 	br	8211c20 <__umoddi3+0x394>
 8211d94:	15ff8b2e 	bgeu	r2,r23,8211bc4 <__umoddi3+0x338>
 8211d98:	31bfff84 	addi	r6,r6,-2
 8211d9c:	1545883a 	add	r2,r2,r21
 8211da0:	003f8906 	br	8211bc8 <__umoddi3+0x33c>
 8211da4:	24c9883a 	add	r4,r4,r19
 8211da8:	003eee06 	br	8211964 <__umoddi3+0xd8>
 8211dac:	8005883a 	mov	r2,r16
 8211db0:	003f1706 	br	8211a10 <__umoddi3+0x184>
 8211db4:	817fe736 	bltu	r16,r5,8211d54 <__umoddi3+0x4c8>
 8211db8:	280f883a 	mov	r7,r5
 8211dbc:	0009883a 	mov	r4,zero
 8211dc0:	003fb106 	br	8211c88 <__umoddi3+0x3fc>

08211dc4 <__adddf3>:
 8211dc4:	02c00434 	movhi	r11,16
 8211dc8:	5affffc4 	addi	r11,r11,-1
 8211dcc:	2806d7fa 	srli	r3,r5,31
 8211dd0:	2ad4703a 	and	r10,r5,r11
 8211dd4:	3ad2703a 	and	r9,r7,r11
 8211dd8:	3804d53a 	srli	r2,r7,20
 8211ddc:	3018d77a 	srli	r12,r6,29
 8211de0:	280ad53a 	srli	r5,r5,20
 8211de4:	501490fa 	slli	r10,r10,3
 8211de8:	2010d77a 	srli	r8,r4,29
 8211dec:	481290fa 	slli	r9,r9,3
 8211df0:	380ed7fa 	srli	r7,r7,31
 8211df4:	defffb04 	addi	sp,sp,-20
 8211df8:	dc800215 	stw	r18,8(sp)
 8211dfc:	dc400115 	stw	r17,4(sp)
 8211e00:	dc000015 	stw	r16,0(sp)
 8211e04:	dfc00415 	stw	ra,16(sp)
 8211e08:	dcc00315 	stw	r19,12(sp)
 8211e0c:	1c803fcc 	andi	r18,r3,255
 8211e10:	2c01ffcc 	andi	r16,r5,2047
 8211e14:	5210b03a 	or	r8,r10,r8
 8211e18:	202290fa 	slli	r17,r4,3
 8211e1c:	1081ffcc 	andi	r2,r2,2047
 8211e20:	4b12b03a 	or	r9,r9,r12
 8211e24:	300c90fa 	slli	r6,r6,3
 8211e28:	91c07526 	beq	r18,r7,8212000 <__adddf3+0x23c>
 8211e2c:	8087c83a 	sub	r3,r16,r2
 8211e30:	00c0ab0e 	bge	zero,r3,82120e0 <__adddf3+0x31c>
 8211e34:	10002a1e 	bne	r2,zero,8211ee0 <__adddf3+0x11c>
 8211e38:	4984b03a 	or	r2,r9,r6
 8211e3c:	1000961e 	bne	r2,zero,8212098 <__adddf3+0x2d4>
 8211e40:	888001cc 	andi	r2,r17,7
 8211e44:	10000726 	beq	r2,zero,8211e64 <__adddf3+0xa0>
 8211e48:	888003cc 	andi	r2,r17,15
 8211e4c:	00c00104 	movi	r3,4
 8211e50:	10c00426 	beq	r2,r3,8211e64 <__adddf3+0xa0>
 8211e54:	88c7883a 	add	r3,r17,r3
 8211e58:	1c63803a 	cmpltu	r17,r3,r17
 8211e5c:	4451883a 	add	r8,r8,r17
 8211e60:	1823883a 	mov	r17,r3
 8211e64:	4080202c 	andhi	r2,r8,128
 8211e68:	10005926 	beq	r2,zero,8211fd0 <__adddf3+0x20c>
 8211e6c:	84000044 	addi	r16,r16,1
 8211e70:	0081ffc4 	movi	r2,2047
 8211e74:	8080ba26 	beq	r16,r2,8212160 <__adddf3+0x39c>
 8211e78:	00bfe034 	movhi	r2,65408
 8211e7c:	10bfffc4 	addi	r2,r2,-1
 8211e80:	4090703a 	and	r8,r8,r2
 8211e84:	4004977a 	slli	r2,r8,29
 8211e88:	4010927a 	slli	r8,r8,9
 8211e8c:	8822d0fa 	srli	r17,r17,3
 8211e90:	8401ffcc 	andi	r16,r16,2047
 8211e94:	4010d33a 	srli	r8,r8,12
 8211e98:	9007883a 	mov	r3,r18
 8211e9c:	1444b03a 	or	r2,r2,r17
 8211ea0:	8401ffcc 	andi	r16,r16,2047
 8211ea4:	8020953a 	slli	r16,r16,20
 8211ea8:	18c03fcc 	andi	r3,r3,255
 8211eac:	01000434 	movhi	r4,16
 8211eb0:	213fffc4 	addi	r4,r4,-1
 8211eb4:	180697fa 	slli	r3,r3,31
 8211eb8:	4110703a 	and	r8,r8,r4
 8211ebc:	4410b03a 	or	r8,r8,r16
 8211ec0:	40c6b03a 	or	r3,r8,r3
 8211ec4:	dfc00417 	ldw	ra,16(sp)
 8211ec8:	dcc00317 	ldw	r19,12(sp)
 8211ecc:	dc800217 	ldw	r18,8(sp)
 8211ed0:	dc400117 	ldw	r17,4(sp)
 8211ed4:	dc000017 	ldw	r16,0(sp)
 8211ed8:	dec00504 	addi	sp,sp,20
 8211edc:	f800283a 	ret
 8211ee0:	0081ffc4 	movi	r2,2047
 8211ee4:	80bfd626 	beq	r16,r2,8211e40 <__adddf3+0x7c>
 8211ee8:	4a402034 	orhi	r9,r9,128
 8211eec:	00800e04 	movi	r2,56
 8211ef0:	10c09f16 	blt	r2,r3,8212170 <__adddf3+0x3ac>
 8211ef4:	008007c4 	movi	r2,31
 8211ef8:	10c0c216 	blt	r2,r3,8212204 <__adddf3+0x440>
 8211efc:	00800804 	movi	r2,32
 8211f00:	10c5c83a 	sub	r2,r2,r3
 8211f04:	488a983a 	sll	r5,r9,r2
 8211f08:	30c8d83a 	srl	r4,r6,r3
 8211f0c:	3084983a 	sll	r2,r6,r2
 8211f10:	48c6d83a 	srl	r3,r9,r3
 8211f14:	290cb03a 	or	r6,r5,r4
 8211f18:	1004c03a 	cmpne	r2,r2,zero
 8211f1c:	308cb03a 	or	r6,r6,r2
 8211f20:	898dc83a 	sub	r6,r17,r6
 8211f24:	89a3803a 	cmpltu	r17,r17,r6
 8211f28:	40d1c83a 	sub	r8,r8,r3
 8211f2c:	4451c83a 	sub	r8,r8,r17
 8211f30:	3023883a 	mov	r17,r6
 8211f34:	4080202c 	andhi	r2,r8,128
 8211f38:	10002326 	beq	r2,zero,8211fc8 <__adddf3+0x204>
 8211f3c:	04c02034 	movhi	r19,128
 8211f40:	9cffffc4 	addi	r19,r19,-1
 8211f44:	44e6703a 	and	r19,r8,r19
 8211f48:	98007626 	beq	r19,zero,8212124 <__adddf3+0x360>
 8211f4c:	9809883a 	mov	r4,r19
 8211f50:	82143c80 	call	82143c8 <__clzsi2>
 8211f54:	10fffe04 	addi	r3,r2,-8
 8211f58:	010007c4 	movi	r4,31
 8211f5c:	20c07716 	blt	r4,r3,821213c <__adddf3+0x378>
 8211f60:	00800804 	movi	r2,32
 8211f64:	10c5c83a 	sub	r2,r2,r3
 8211f68:	8884d83a 	srl	r2,r17,r2
 8211f6c:	98d0983a 	sll	r8,r19,r3
 8211f70:	88e2983a 	sll	r17,r17,r3
 8211f74:	1204b03a 	or	r2,r2,r8
 8211f78:	1c007416 	blt	r3,r16,821214c <__adddf3+0x388>
 8211f7c:	1c21c83a 	sub	r16,r3,r16
 8211f80:	82000044 	addi	r8,r16,1
 8211f84:	00c007c4 	movi	r3,31
 8211f88:	1a009116 	blt	r3,r8,82121d0 <__adddf3+0x40c>
 8211f8c:	00c00804 	movi	r3,32
 8211f90:	1a07c83a 	sub	r3,r3,r8
 8211f94:	8a08d83a 	srl	r4,r17,r8
 8211f98:	88e2983a 	sll	r17,r17,r3
 8211f9c:	10c6983a 	sll	r3,r2,r3
 8211fa0:	1210d83a 	srl	r8,r2,r8
 8211fa4:	8804c03a 	cmpne	r2,r17,zero
 8211fa8:	1906b03a 	or	r3,r3,r4
 8211fac:	18a2b03a 	or	r17,r3,r2
 8211fb0:	0021883a 	mov	r16,zero
 8211fb4:	003fa206 	br	8211e40 <__adddf3+0x7c>
 8211fb8:	1890b03a 	or	r8,r3,r2
 8211fbc:	40017d26 	beq	r8,zero,82125b4 <__adddf3+0x7f0>
 8211fc0:	1011883a 	mov	r8,r2
 8211fc4:	1823883a 	mov	r17,r3
 8211fc8:	888001cc 	andi	r2,r17,7
 8211fcc:	103f9e1e 	bne	r2,zero,8211e48 <__adddf3+0x84>
 8211fd0:	4004977a 	slli	r2,r8,29
 8211fd4:	8822d0fa 	srli	r17,r17,3
 8211fd8:	4010d0fa 	srli	r8,r8,3
 8211fdc:	9007883a 	mov	r3,r18
 8211fe0:	1444b03a 	or	r2,r2,r17
 8211fe4:	0101ffc4 	movi	r4,2047
 8211fe8:	81002426 	beq	r16,r4,821207c <__adddf3+0x2b8>
 8211fec:	8120703a 	and	r16,r16,r4
 8211ff0:	01000434 	movhi	r4,16
 8211ff4:	213fffc4 	addi	r4,r4,-1
 8211ff8:	4110703a 	and	r8,r8,r4
 8211ffc:	003fa806 	br	8211ea0 <__adddf3+0xdc>
 8212000:	8089c83a 	sub	r4,r16,r2
 8212004:	01005e0e 	bge	zero,r4,8212180 <__adddf3+0x3bc>
 8212008:	10002b26 	beq	r2,zero,82120b8 <__adddf3+0x2f4>
 821200c:	0081ffc4 	movi	r2,2047
 8212010:	80bf8b26 	beq	r16,r2,8211e40 <__adddf3+0x7c>
 8212014:	4a402034 	orhi	r9,r9,128
 8212018:	00800e04 	movi	r2,56
 821201c:	1100a40e 	bge	r2,r4,82122b0 <__adddf3+0x4ec>
 8212020:	498cb03a 	or	r6,r9,r6
 8212024:	300ac03a 	cmpne	r5,r6,zero
 8212028:	0013883a 	mov	r9,zero
 821202c:	2c4b883a 	add	r5,r5,r17
 8212030:	2c63803a 	cmpltu	r17,r5,r17
 8212034:	4a11883a 	add	r8,r9,r8
 8212038:	8a11883a 	add	r8,r17,r8
 821203c:	2823883a 	mov	r17,r5
 8212040:	4080202c 	andhi	r2,r8,128
 8212044:	103fe026 	beq	r2,zero,8211fc8 <__adddf3+0x204>
 8212048:	84000044 	addi	r16,r16,1
 821204c:	0081ffc4 	movi	r2,2047
 8212050:	8080d226 	beq	r16,r2,821239c <__adddf3+0x5d8>
 8212054:	00bfe034 	movhi	r2,65408
 8212058:	10bfffc4 	addi	r2,r2,-1
 821205c:	4090703a 	and	r8,r8,r2
 8212060:	880ad07a 	srli	r5,r17,1
 8212064:	400897fa 	slli	r4,r8,31
 8212068:	88c0004c 	andi	r3,r17,1
 821206c:	28e2b03a 	or	r17,r5,r3
 8212070:	4010d07a 	srli	r8,r8,1
 8212074:	2462b03a 	or	r17,r4,r17
 8212078:	003f7106 	br	8211e40 <__adddf3+0x7c>
 821207c:	4088b03a 	or	r4,r8,r2
 8212080:	20014526 	beq	r4,zero,8212598 <__adddf3+0x7d4>
 8212084:	01000434 	movhi	r4,16
 8212088:	42000234 	orhi	r8,r8,8
 821208c:	213fffc4 	addi	r4,r4,-1
 8212090:	4110703a 	and	r8,r8,r4
 8212094:	003f8206 	br	8211ea0 <__adddf3+0xdc>
 8212098:	18ffffc4 	addi	r3,r3,-1
 821209c:	1800491e 	bne	r3,zero,82121c4 <__adddf3+0x400>
 82120a0:	898bc83a 	sub	r5,r17,r6
 82120a4:	8963803a 	cmpltu	r17,r17,r5
 82120a8:	4251c83a 	sub	r8,r8,r9
 82120ac:	4451c83a 	sub	r8,r8,r17
 82120b0:	2823883a 	mov	r17,r5
 82120b4:	003f9f06 	br	8211f34 <__adddf3+0x170>
 82120b8:	4984b03a 	or	r2,r9,r6
 82120bc:	103f6026 	beq	r2,zero,8211e40 <__adddf3+0x7c>
 82120c0:	213fffc4 	addi	r4,r4,-1
 82120c4:	2000931e 	bne	r4,zero,8212314 <__adddf3+0x550>
 82120c8:	898d883a 	add	r6,r17,r6
 82120cc:	3463803a 	cmpltu	r17,r6,r17
 82120d0:	4251883a 	add	r8,r8,r9
 82120d4:	8a11883a 	add	r8,r17,r8
 82120d8:	3023883a 	mov	r17,r6
 82120dc:	003fd806 	br	8212040 <__adddf3+0x27c>
 82120e0:	1800541e 	bne	r3,zero,8212234 <__adddf3+0x470>
 82120e4:	80800044 	addi	r2,r16,1
 82120e8:	1081ffcc 	andi	r2,r2,2047
 82120ec:	00c00044 	movi	r3,1
 82120f0:	1880a00e 	bge	r3,r2,8212374 <__adddf3+0x5b0>
 82120f4:	8989c83a 	sub	r4,r17,r6
 82120f8:	8905803a 	cmpltu	r2,r17,r4
 82120fc:	4267c83a 	sub	r19,r8,r9
 8212100:	98a7c83a 	sub	r19,r19,r2
 8212104:	9880202c 	andhi	r2,r19,128
 8212108:	10006326 	beq	r2,zero,8212298 <__adddf3+0x4d4>
 821210c:	3463c83a 	sub	r17,r6,r17
 8212110:	4a07c83a 	sub	r3,r9,r8
 8212114:	344d803a 	cmpltu	r6,r6,r17
 8212118:	19a7c83a 	sub	r19,r3,r6
 821211c:	3825883a 	mov	r18,r7
 8212120:	983f8a1e 	bne	r19,zero,8211f4c <__adddf3+0x188>
 8212124:	8809883a 	mov	r4,r17
 8212128:	82143c80 	call	82143c8 <__clzsi2>
 821212c:	10800804 	addi	r2,r2,32
 8212130:	10fffe04 	addi	r3,r2,-8
 8212134:	010007c4 	movi	r4,31
 8212138:	20ff890e 	bge	r4,r3,8211f60 <__adddf3+0x19c>
 821213c:	10bff604 	addi	r2,r2,-40
 8212140:	8884983a 	sll	r2,r17,r2
 8212144:	0023883a 	mov	r17,zero
 8212148:	1c3f8c0e 	bge	r3,r16,8211f7c <__adddf3+0x1b8>
 821214c:	023fe034 	movhi	r8,65408
 8212150:	423fffc4 	addi	r8,r8,-1
 8212154:	80e1c83a 	sub	r16,r16,r3
 8212158:	1210703a 	and	r8,r2,r8
 821215c:	003f3806 	br	8211e40 <__adddf3+0x7c>
 8212160:	9007883a 	mov	r3,r18
 8212164:	0011883a 	mov	r8,zero
 8212168:	0005883a 	mov	r2,zero
 821216c:	003f4c06 	br	8211ea0 <__adddf3+0xdc>
 8212170:	498cb03a 	or	r6,r9,r6
 8212174:	300cc03a 	cmpne	r6,r6,zero
 8212178:	0007883a 	mov	r3,zero
 821217c:	003f6806 	br	8211f20 <__adddf3+0x15c>
 8212180:	20009c1e 	bne	r4,zero,82123f4 <__adddf3+0x630>
 8212184:	80800044 	addi	r2,r16,1
 8212188:	1141ffcc 	andi	r5,r2,2047
 821218c:	01000044 	movi	r4,1
 8212190:	2140670e 	bge	r4,r5,8212330 <__adddf3+0x56c>
 8212194:	0101ffc4 	movi	r4,2047
 8212198:	11007f26 	beq	r2,r4,8212398 <__adddf3+0x5d4>
 821219c:	898d883a 	add	r6,r17,r6
 82121a0:	4247883a 	add	r3,r8,r9
 82121a4:	3451803a 	cmpltu	r8,r6,r17
 82121a8:	40d1883a 	add	r8,r8,r3
 82121ac:	402297fa 	slli	r17,r8,31
 82121b0:	300cd07a 	srli	r6,r6,1
 82121b4:	4010d07a 	srli	r8,r8,1
 82121b8:	1021883a 	mov	r16,r2
 82121bc:	89a2b03a 	or	r17,r17,r6
 82121c0:	003f1f06 	br	8211e40 <__adddf3+0x7c>
 82121c4:	0081ffc4 	movi	r2,2047
 82121c8:	80bf481e 	bne	r16,r2,8211eec <__adddf3+0x128>
 82121cc:	003f1c06 	br	8211e40 <__adddf3+0x7c>
 82121d0:	843ff844 	addi	r16,r16,-31
 82121d4:	01000804 	movi	r4,32
 82121d8:	1406d83a 	srl	r3,r2,r16
 82121dc:	41005026 	beq	r8,r4,8212320 <__adddf3+0x55c>
 82121e0:	01001004 	movi	r4,64
 82121e4:	2211c83a 	sub	r8,r4,r8
 82121e8:	1204983a 	sll	r2,r2,r8
 82121ec:	88a2b03a 	or	r17,r17,r2
 82121f0:	8822c03a 	cmpne	r17,r17,zero
 82121f4:	1c62b03a 	or	r17,r3,r17
 82121f8:	0011883a 	mov	r8,zero
 82121fc:	0021883a 	mov	r16,zero
 8212200:	003f7106 	br	8211fc8 <__adddf3+0x204>
 8212204:	193ff804 	addi	r4,r3,-32
 8212208:	00800804 	movi	r2,32
 821220c:	4908d83a 	srl	r4,r9,r4
 8212210:	18804526 	beq	r3,r2,8212328 <__adddf3+0x564>
 8212214:	00801004 	movi	r2,64
 8212218:	10c5c83a 	sub	r2,r2,r3
 821221c:	4886983a 	sll	r3,r9,r2
 8212220:	198cb03a 	or	r6,r3,r6
 8212224:	300cc03a 	cmpne	r6,r6,zero
 8212228:	218cb03a 	or	r6,r4,r6
 821222c:	0007883a 	mov	r3,zero
 8212230:	003f3b06 	br	8211f20 <__adddf3+0x15c>
 8212234:	80002a26 	beq	r16,zero,82122e0 <__adddf3+0x51c>
 8212238:	0101ffc4 	movi	r4,2047
 821223c:	11006826 	beq	r2,r4,82123e0 <__adddf3+0x61c>
 8212240:	00c7c83a 	sub	r3,zero,r3
 8212244:	42002034 	orhi	r8,r8,128
 8212248:	01000e04 	movi	r4,56
 821224c:	20c07c16 	blt	r4,r3,8212440 <__adddf3+0x67c>
 8212250:	010007c4 	movi	r4,31
 8212254:	20c0da16 	blt	r4,r3,82125c0 <__adddf3+0x7fc>
 8212258:	01000804 	movi	r4,32
 821225c:	20c9c83a 	sub	r4,r4,r3
 8212260:	4114983a 	sll	r10,r8,r4
 8212264:	88cad83a 	srl	r5,r17,r3
 8212268:	8908983a 	sll	r4,r17,r4
 821226c:	40c6d83a 	srl	r3,r8,r3
 8212270:	5162b03a 	or	r17,r10,r5
 8212274:	2008c03a 	cmpne	r4,r4,zero
 8212278:	8922b03a 	or	r17,r17,r4
 821227c:	3463c83a 	sub	r17,r6,r17
 8212280:	48c7c83a 	sub	r3,r9,r3
 8212284:	344d803a 	cmpltu	r6,r6,r17
 8212288:	1991c83a 	sub	r8,r3,r6
 821228c:	1021883a 	mov	r16,r2
 8212290:	3825883a 	mov	r18,r7
 8212294:	003f2706 	br	8211f34 <__adddf3+0x170>
 8212298:	24d0b03a 	or	r8,r4,r19
 821229c:	40001b1e 	bne	r8,zero,821230c <__adddf3+0x548>
 82122a0:	0005883a 	mov	r2,zero
 82122a4:	0007883a 	mov	r3,zero
 82122a8:	0021883a 	mov	r16,zero
 82122ac:	003f4d06 	br	8211fe4 <__adddf3+0x220>
 82122b0:	008007c4 	movi	r2,31
 82122b4:	11003c16 	blt	r2,r4,82123a8 <__adddf3+0x5e4>
 82122b8:	00800804 	movi	r2,32
 82122bc:	1105c83a 	sub	r2,r2,r4
 82122c0:	488e983a 	sll	r7,r9,r2
 82122c4:	310ad83a 	srl	r5,r6,r4
 82122c8:	3084983a 	sll	r2,r6,r2
 82122cc:	4912d83a 	srl	r9,r9,r4
 82122d0:	394ab03a 	or	r5,r7,r5
 82122d4:	1004c03a 	cmpne	r2,r2,zero
 82122d8:	288ab03a 	or	r5,r5,r2
 82122dc:	003f5306 	br	821202c <__adddf3+0x268>
 82122e0:	4448b03a 	or	r4,r8,r17
 82122e4:	20003e26 	beq	r4,zero,82123e0 <__adddf3+0x61c>
 82122e8:	00c6303a 	nor	r3,zero,r3
 82122ec:	18003a1e 	bne	r3,zero,82123d8 <__adddf3+0x614>
 82122f0:	3463c83a 	sub	r17,r6,r17
 82122f4:	4a07c83a 	sub	r3,r9,r8
 82122f8:	344d803a 	cmpltu	r6,r6,r17
 82122fc:	1991c83a 	sub	r8,r3,r6
 8212300:	1021883a 	mov	r16,r2
 8212304:	3825883a 	mov	r18,r7
 8212308:	003f0a06 	br	8211f34 <__adddf3+0x170>
 821230c:	2023883a 	mov	r17,r4
 8212310:	003f0d06 	br	8211f48 <__adddf3+0x184>
 8212314:	0081ffc4 	movi	r2,2047
 8212318:	80bf3f1e 	bne	r16,r2,8212018 <__adddf3+0x254>
 821231c:	003ec806 	br	8211e40 <__adddf3+0x7c>
 8212320:	0005883a 	mov	r2,zero
 8212324:	003fb106 	br	82121ec <__adddf3+0x428>
 8212328:	0007883a 	mov	r3,zero
 821232c:	003fbc06 	br	8212220 <__adddf3+0x45c>
 8212330:	4444b03a 	or	r2,r8,r17
 8212334:	8000871e 	bne	r16,zero,8212554 <__adddf3+0x790>
 8212338:	1000ba26 	beq	r2,zero,8212624 <__adddf3+0x860>
 821233c:	4984b03a 	or	r2,r9,r6
 8212340:	103ebf26 	beq	r2,zero,8211e40 <__adddf3+0x7c>
 8212344:	8985883a 	add	r2,r17,r6
 8212348:	4247883a 	add	r3,r8,r9
 821234c:	1451803a 	cmpltu	r8,r2,r17
 8212350:	40d1883a 	add	r8,r8,r3
 8212354:	40c0202c 	andhi	r3,r8,128
 8212358:	1023883a 	mov	r17,r2
 821235c:	183f1a26 	beq	r3,zero,8211fc8 <__adddf3+0x204>
 8212360:	00bfe034 	movhi	r2,65408
 8212364:	10bfffc4 	addi	r2,r2,-1
 8212368:	2021883a 	mov	r16,r4
 821236c:	4090703a 	and	r8,r8,r2
 8212370:	003eb306 	br	8211e40 <__adddf3+0x7c>
 8212374:	4444b03a 	or	r2,r8,r17
 8212378:	8000291e 	bne	r16,zero,8212420 <__adddf3+0x65c>
 821237c:	10004b1e 	bne	r2,zero,82124ac <__adddf3+0x6e8>
 8212380:	4990b03a 	or	r8,r9,r6
 8212384:	40008b26 	beq	r8,zero,82125b4 <__adddf3+0x7f0>
 8212388:	4811883a 	mov	r8,r9
 821238c:	3023883a 	mov	r17,r6
 8212390:	3825883a 	mov	r18,r7
 8212394:	003eaa06 	br	8211e40 <__adddf3+0x7c>
 8212398:	1021883a 	mov	r16,r2
 821239c:	0011883a 	mov	r8,zero
 82123a0:	0005883a 	mov	r2,zero
 82123a4:	003f0f06 	br	8211fe4 <__adddf3+0x220>
 82123a8:	217ff804 	addi	r5,r4,-32
 82123ac:	00800804 	movi	r2,32
 82123b0:	494ad83a 	srl	r5,r9,r5
 82123b4:	20807d26 	beq	r4,r2,82125ac <__adddf3+0x7e8>
 82123b8:	00801004 	movi	r2,64
 82123bc:	1109c83a 	sub	r4,r2,r4
 82123c0:	4912983a 	sll	r9,r9,r4
 82123c4:	498cb03a 	or	r6,r9,r6
 82123c8:	300cc03a 	cmpne	r6,r6,zero
 82123cc:	298ab03a 	or	r5,r5,r6
 82123d0:	0013883a 	mov	r9,zero
 82123d4:	003f1506 	br	821202c <__adddf3+0x268>
 82123d8:	0101ffc4 	movi	r4,2047
 82123dc:	113f9a1e 	bne	r2,r4,8212248 <__adddf3+0x484>
 82123e0:	4811883a 	mov	r8,r9
 82123e4:	3023883a 	mov	r17,r6
 82123e8:	1021883a 	mov	r16,r2
 82123ec:	3825883a 	mov	r18,r7
 82123f0:	003e9306 	br	8211e40 <__adddf3+0x7c>
 82123f4:	8000161e 	bne	r16,zero,8212450 <__adddf3+0x68c>
 82123f8:	444ab03a 	or	r5,r8,r17
 82123fc:	28005126 	beq	r5,zero,8212544 <__adddf3+0x780>
 8212400:	0108303a 	nor	r4,zero,r4
 8212404:	20004d1e 	bne	r4,zero,821253c <__adddf3+0x778>
 8212408:	89a3883a 	add	r17,r17,r6
 821240c:	4253883a 	add	r9,r8,r9
 8212410:	898d803a 	cmpltu	r6,r17,r6
 8212414:	3251883a 	add	r8,r6,r9
 8212418:	1021883a 	mov	r16,r2
 821241c:	003f0806 	br	8212040 <__adddf3+0x27c>
 8212420:	1000301e 	bne	r2,zero,82124e4 <__adddf3+0x720>
 8212424:	4984b03a 	or	r2,r9,r6
 8212428:	10007126 	beq	r2,zero,82125f0 <__adddf3+0x82c>
 821242c:	4811883a 	mov	r8,r9
 8212430:	3023883a 	mov	r17,r6
 8212434:	3825883a 	mov	r18,r7
 8212438:	0401ffc4 	movi	r16,2047
 821243c:	003e8006 	br	8211e40 <__adddf3+0x7c>
 8212440:	4462b03a 	or	r17,r8,r17
 8212444:	8822c03a 	cmpne	r17,r17,zero
 8212448:	0007883a 	mov	r3,zero
 821244c:	003f8b06 	br	821227c <__adddf3+0x4b8>
 8212450:	0141ffc4 	movi	r5,2047
 8212454:	11403b26 	beq	r2,r5,8212544 <__adddf3+0x780>
 8212458:	0109c83a 	sub	r4,zero,r4
 821245c:	42002034 	orhi	r8,r8,128
 8212460:	01400e04 	movi	r5,56
 8212464:	29006716 	blt	r5,r4,8212604 <__adddf3+0x840>
 8212468:	014007c4 	movi	r5,31
 821246c:	29007016 	blt	r5,r4,8212630 <__adddf3+0x86c>
 8212470:	01400804 	movi	r5,32
 8212474:	290bc83a 	sub	r5,r5,r4
 8212478:	4154983a 	sll	r10,r8,r5
 821247c:	890ed83a 	srl	r7,r17,r4
 8212480:	894a983a 	sll	r5,r17,r5
 8212484:	4108d83a 	srl	r4,r8,r4
 8212488:	51e2b03a 	or	r17,r10,r7
 821248c:	280ac03a 	cmpne	r5,r5,zero
 8212490:	8962b03a 	or	r17,r17,r5
 8212494:	89a3883a 	add	r17,r17,r6
 8212498:	2253883a 	add	r9,r4,r9
 821249c:	898d803a 	cmpltu	r6,r17,r6
 82124a0:	3251883a 	add	r8,r6,r9
 82124a4:	1021883a 	mov	r16,r2
 82124a8:	003ee506 	br	8212040 <__adddf3+0x27c>
 82124ac:	4984b03a 	or	r2,r9,r6
 82124b0:	103e6326 	beq	r2,zero,8211e40 <__adddf3+0x7c>
 82124b4:	8987c83a 	sub	r3,r17,r6
 82124b8:	88c9803a 	cmpltu	r4,r17,r3
 82124bc:	4245c83a 	sub	r2,r8,r9
 82124c0:	1105c83a 	sub	r2,r2,r4
 82124c4:	1100202c 	andhi	r4,r2,128
 82124c8:	203ebb26 	beq	r4,zero,8211fb8 <__adddf3+0x1f4>
 82124cc:	3463c83a 	sub	r17,r6,r17
 82124d0:	4a07c83a 	sub	r3,r9,r8
 82124d4:	344d803a 	cmpltu	r6,r6,r17
 82124d8:	1991c83a 	sub	r8,r3,r6
 82124dc:	3825883a 	mov	r18,r7
 82124e0:	003e5706 	br	8211e40 <__adddf3+0x7c>
 82124e4:	4984b03a 	or	r2,r9,r6
 82124e8:	10002e26 	beq	r2,zero,82125a4 <__adddf3+0x7e0>
 82124ec:	4004d0fa 	srli	r2,r8,3
 82124f0:	8822d0fa 	srli	r17,r17,3
 82124f4:	4010977a 	slli	r8,r8,29
 82124f8:	10c0022c 	andhi	r3,r2,8
 82124fc:	4462b03a 	or	r17,r8,r17
 8212500:	18000826 	beq	r3,zero,8212524 <__adddf3+0x760>
 8212504:	4808d0fa 	srli	r4,r9,3
 8212508:	20c0022c 	andhi	r3,r4,8
 821250c:	1800051e 	bne	r3,zero,8212524 <__adddf3+0x760>
 8212510:	300cd0fa 	srli	r6,r6,3
 8212514:	4806977a 	slli	r3,r9,29
 8212518:	2005883a 	mov	r2,r4
 821251c:	3825883a 	mov	r18,r7
 8212520:	19a2b03a 	or	r17,r3,r6
 8212524:	8810d77a 	srli	r8,r17,29
 8212528:	100490fa 	slli	r2,r2,3
 821252c:	882290fa 	slli	r17,r17,3
 8212530:	0401ffc4 	movi	r16,2047
 8212534:	4090b03a 	or	r8,r8,r2
 8212538:	003e4106 	br	8211e40 <__adddf3+0x7c>
 821253c:	0141ffc4 	movi	r5,2047
 8212540:	117fc71e 	bne	r2,r5,8212460 <__adddf3+0x69c>
 8212544:	4811883a 	mov	r8,r9
 8212548:	3023883a 	mov	r17,r6
 821254c:	1021883a 	mov	r16,r2
 8212550:	003e3b06 	br	8211e40 <__adddf3+0x7c>
 8212554:	10002f26 	beq	r2,zero,8212614 <__adddf3+0x850>
 8212558:	4984b03a 	or	r2,r9,r6
 821255c:	10001126 	beq	r2,zero,82125a4 <__adddf3+0x7e0>
 8212560:	4004d0fa 	srli	r2,r8,3
 8212564:	8822d0fa 	srli	r17,r17,3
 8212568:	4010977a 	slli	r8,r8,29
 821256c:	10c0022c 	andhi	r3,r2,8
 8212570:	4462b03a 	or	r17,r8,r17
 8212574:	183feb26 	beq	r3,zero,8212524 <__adddf3+0x760>
 8212578:	4808d0fa 	srli	r4,r9,3
 821257c:	20c0022c 	andhi	r3,r4,8
 8212580:	183fe81e 	bne	r3,zero,8212524 <__adddf3+0x760>
 8212584:	300cd0fa 	srli	r6,r6,3
 8212588:	4806977a 	slli	r3,r9,29
 821258c:	2005883a 	mov	r2,r4
 8212590:	19a2b03a 	or	r17,r3,r6
 8212594:	003fe306 	br	8212524 <__adddf3+0x760>
 8212598:	0011883a 	mov	r8,zero
 821259c:	0005883a 	mov	r2,zero
 82125a0:	003e3f06 	br	8211ea0 <__adddf3+0xdc>
 82125a4:	0401ffc4 	movi	r16,2047
 82125a8:	003e2506 	br	8211e40 <__adddf3+0x7c>
 82125ac:	0013883a 	mov	r9,zero
 82125b0:	003f8406 	br	82123c4 <__adddf3+0x600>
 82125b4:	0005883a 	mov	r2,zero
 82125b8:	0007883a 	mov	r3,zero
 82125bc:	003e8906 	br	8211fe4 <__adddf3+0x220>
 82125c0:	197ff804 	addi	r5,r3,-32
 82125c4:	01000804 	movi	r4,32
 82125c8:	414ad83a 	srl	r5,r8,r5
 82125cc:	19002426 	beq	r3,r4,8212660 <__adddf3+0x89c>
 82125d0:	01001004 	movi	r4,64
 82125d4:	20c7c83a 	sub	r3,r4,r3
 82125d8:	40c6983a 	sll	r3,r8,r3
 82125dc:	1c46b03a 	or	r3,r3,r17
 82125e0:	1806c03a 	cmpne	r3,r3,zero
 82125e4:	28e2b03a 	or	r17,r5,r3
 82125e8:	0007883a 	mov	r3,zero
 82125ec:	003f2306 	br	821227c <__adddf3+0x4b8>
 82125f0:	0007883a 	mov	r3,zero
 82125f4:	5811883a 	mov	r8,r11
 82125f8:	00bfffc4 	movi	r2,-1
 82125fc:	0401ffc4 	movi	r16,2047
 8212600:	003e7806 	br	8211fe4 <__adddf3+0x220>
 8212604:	4462b03a 	or	r17,r8,r17
 8212608:	8822c03a 	cmpne	r17,r17,zero
 821260c:	0009883a 	mov	r4,zero
 8212610:	003fa006 	br	8212494 <__adddf3+0x6d0>
 8212614:	4811883a 	mov	r8,r9
 8212618:	3023883a 	mov	r17,r6
 821261c:	0401ffc4 	movi	r16,2047
 8212620:	003e0706 	br	8211e40 <__adddf3+0x7c>
 8212624:	4811883a 	mov	r8,r9
 8212628:	3023883a 	mov	r17,r6
 821262c:	003e0406 	br	8211e40 <__adddf3+0x7c>
 8212630:	21fff804 	addi	r7,r4,-32
 8212634:	01400804 	movi	r5,32
 8212638:	41ced83a 	srl	r7,r8,r7
 821263c:	21400a26 	beq	r4,r5,8212668 <__adddf3+0x8a4>
 8212640:	01401004 	movi	r5,64
 8212644:	2909c83a 	sub	r4,r5,r4
 8212648:	4108983a 	sll	r4,r8,r4
 821264c:	2448b03a 	or	r4,r4,r17
 8212650:	2008c03a 	cmpne	r4,r4,zero
 8212654:	3922b03a 	or	r17,r7,r4
 8212658:	0009883a 	mov	r4,zero
 821265c:	003f8d06 	br	8212494 <__adddf3+0x6d0>
 8212660:	0007883a 	mov	r3,zero
 8212664:	003fdd06 	br	82125dc <__adddf3+0x818>
 8212668:	0009883a 	mov	r4,zero
 821266c:	003ff706 	br	821264c <__adddf3+0x888>

08212670 <__divdf3>:
 8212670:	defff204 	addi	sp,sp,-56
 8212674:	dd400915 	stw	r21,36(sp)
 8212678:	282ad53a 	srli	r21,r5,20
 821267c:	dd000815 	stw	r20,32(sp)
 8212680:	2828d7fa 	srli	r20,r5,31
 8212684:	dc000415 	stw	r16,16(sp)
 8212688:	04000434 	movhi	r16,16
 821268c:	df000c15 	stw	fp,48(sp)
 8212690:	843fffc4 	addi	r16,r16,-1
 8212694:	dfc00d15 	stw	ra,52(sp)
 8212698:	ddc00b15 	stw	r23,44(sp)
 821269c:	dd800a15 	stw	r22,40(sp)
 82126a0:	dcc00715 	stw	r19,28(sp)
 82126a4:	dc800615 	stw	r18,24(sp)
 82126a8:	dc400515 	stw	r17,20(sp)
 82126ac:	ad41ffcc 	andi	r21,r21,2047
 82126b0:	2c20703a 	and	r16,r5,r16
 82126b4:	a7003fcc 	andi	fp,r20,255
 82126b8:	a8006126 	beq	r21,zero,8212840 <__divdf3+0x1d0>
 82126bc:	0081ffc4 	movi	r2,2047
 82126c0:	2025883a 	mov	r18,r4
 82126c4:	a8803726 	beq	r21,r2,82127a4 <__divdf3+0x134>
 82126c8:	80800434 	orhi	r2,r16,16
 82126cc:	100490fa 	slli	r2,r2,3
 82126d0:	2020d77a 	srli	r16,r4,29
 82126d4:	202490fa 	slli	r18,r4,3
 82126d8:	ad7f0044 	addi	r21,r21,-1023
 82126dc:	80a0b03a 	or	r16,r16,r2
 82126e0:	0027883a 	mov	r19,zero
 82126e4:	0013883a 	mov	r9,zero
 82126e8:	3804d53a 	srli	r2,r7,20
 82126ec:	382cd7fa 	srli	r22,r7,31
 82126f0:	04400434 	movhi	r17,16
 82126f4:	8c7fffc4 	addi	r17,r17,-1
 82126f8:	1081ffcc 	andi	r2,r2,2047
 82126fc:	3011883a 	mov	r8,r6
 8212700:	3c62703a 	and	r17,r7,r17
 8212704:	b5c03fcc 	andi	r23,r22,255
 8212708:	10006c26 	beq	r2,zero,82128bc <__divdf3+0x24c>
 821270c:	00c1ffc4 	movi	r3,2047
 8212710:	10c06426 	beq	r2,r3,82128a4 <__divdf3+0x234>
 8212714:	88c00434 	orhi	r3,r17,16
 8212718:	180690fa 	slli	r3,r3,3
 821271c:	3022d77a 	srli	r17,r6,29
 8212720:	301090fa 	slli	r8,r6,3
 8212724:	10bf0044 	addi	r2,r2,-1023
 8212728:	88e2b03a 	or	r17,r17,r3
 821272c:	000f883a 	mov	r7,zero
 8212730:	a58cf03a 	xor	r6,r20,r22
 8212734:	3cc8b03a 	or	r4,r7,r19
 8212738:	a8abc83a 	sub	r21,r21,r2
 821273c:	008003c4 	movi	r2,15
 8212740:	3007883a 	mov	r3,r6
 8212744:	34c03fcc 	andi	r19,r6,255
 8212748:	11009036 	bltu	r2,r4,821298c <__divdf3+0x31c>
 821274c:	200890ba 	slli	r4,r4,2
 8212750:	00820874 	movhi	r2,2081
 8212754:	1089d904 	addi	r2,r2,10084
 8212758:	2089883a 	add	r4,r4,r2
 821275c:	20800017 	ldw	r2,0(r4)
 8212760:	1000683a 	jmp	r2
 8212764:	0821298c 	andi	zero,at,33958
 8212768:	082127dc 	xori	zero,at,33951
 821276c:	0821297c 	xorhi	zero,at,33957
 8212770:	082127d0 	cmplti	zero,at,-31585
 8212774:	0821297c 	xorhi	zero,at,33957
 8212778:	08212950 	cmplti	zero,at,-31579
 821277c:	0821297c 	xorhi	zero,at,33957
 8212780:	082127d0 	cmplti	zero,at,-31585
 8212784:	082127dc 	xori	zero,at,33951
 8212788:	082127dc 	xori	zero,at,33951
 821278c:	08212950 	cmplti	zero,at,-31579
 8212790:	082127d0 	cmplti	zero,at,-31585
 8212794:	082127c0 	call	82127c <OSCtxSw_SWITCH_PC+0x82123c>
 8212798:	082127c0 	call	82127c <OSCtxSw_SWITCH_PC+0x82123c>
 821279c:	082127c0 	call	82127c <OSCtxSw_SWITCH_PC+0x82123c>
 82127a0:	08212c70 	cmpltui	zero,at,33969
 82127a4:	2404b03a 	or	r2,r4,r16
 82127a8:	1000661e 	bne	r2,zero,8212944 <__divdf3+0x2d4>
 82127ac:	04c00204 	movi	r19,8
 82127b0:	0021883a 	mov	r16,zero
 82127b4:	0025883a 	mov	r18,zero
 82127b8:	02400084 	movi	r9,2
 82127bc:	003fca06 	br	82126e8 <__divdf3+0x78>
 82127c0:	8023883a 	mov	r17,r16
 82127c4:	9011883a 	mov	r8,r18
 82127c8:	e02f883a 	mov	r23,fp
 82127cc:	480f883a 	mov	r7,r9
 82127d0:	00800084 	movi	r2,2
 82127d4:	3881311e 	bne	r7,r2,8212c9c <__divdf3+0x62c>
 82127d8:	b827883a 	mov	r19,r23
 82127dc:	98c0004c 	andi	r3,r19,1
 82127e0:	0081ffc4 	movi	r2,2047
 82127e4:	000b883a 	mov	r5,zero
 82127e8:	0025883a 	mov	r18,zero
 82127ec:	1004953a 	slli	r2,r2,20
 82127f0:	18c03fcc 	andi	r3,r3,255
 82127f4:	04400434 	movhi	r17,16
 82127f8:	8c7fffc4 	addi	r17,r17,-1
 82127fc:	180697fa 	slli	r3,r3,31
 8212800:	2c4a703a 	and	r5,r5,r17
 8212804:	288ab03a 	or	r5,r5,r2
 8212808:	28c6b03a 	or	r3,r5,r3
 821280c:	9005883a 	mov	r2,r18
 8212810:	dfc00d17 	ldw	ra,52(sp)
 8212814:	df000c17 	ldw	fp,48(sp)
 8212818:	ddc00b17 	ldw	r23,44(sp)
 821281c:	dd800a17 	ldw	r22,40(sp)
 8212820:	dd400917 	ldw	r21,36(sp)
 8212824:	dd000817 	ldw	r20,32(sp)
 8212828:	dcc00717 	ldw	r19,28(sp)
 821282c:	dc800617 	ldw	r18,24(sp)
 8212830:	dc400517 	ldw	r17,20(sp)
 8212834:	dc000417 	ldw	r16,16(sp)
 8212838:	dec00e04 	addi	sp,sp,56
 821283c:	f800283a 	ret
 8212840:	2404b03a 	or	r2,r4,r16
 8212844:	2027883a 	mov	r19,r4
 8212848:	10003926 	beq	r2,zero,8212930 <__divdf3+0x2c0>
 821284c:	80012e26 	beq	r16,zero,8212d08 <__divdf3+0x698>
 8212850:	8009883a 	mov	r4,r16
 8212854:	d9800315 	stw	r6,12(sp)
 8212858:	d9c00215 	stw	r7,8(sp)
 821285c:	82143c80 	call	82143c8 <__clzsi2>
 8212860:	d9800317 	ldw	r6,12(sp)
 8212864:	d9c00217 	ldw	r7,8(sp)
 8212868:	113ffd44 	addi	r4,r2,-11
 821286c:	00c00704 	movi	r3,28
 8212870:	19012116 	blt	r3,r4,8212cf8 <__divdf3+0x688>
 8212874:	00c00744 	movi	r3,29
 8212878:	147ffe04 	addi	r17,r2,-8
 821287c:	1907c83a 	sub	r3,r3,r4
 8212880:	8460983a 	sll	r16,r16,r17
 8212884:	98c6d83a 	srl	r3,r19,r3
 8212888:	9c64983a 	sll	r18,r19,r17
 821288c:	1c20b03a 	or	r16,r3,r16
 8212890:	1080fcc4 	addi	r2,r2,1011
 8212894:	00abc83a 	sub	r21,zero,r2
 8212898:	0027883a 	mov	r19,zero
 821289c:	0013883a 	mov	r9,zero
 82128a0:	003f9106 	br	82126e8 <__divdf3+0x78>
 82128a4:	3446b03a 	or	r3,r6,r17
 82128a8:	18001f1e 	bne	r3,zero,8212928 <__divdf3+0x2b8>
 82128ac:	0023883a 	mov	r17,zero
 82128b0:	0011883a 	mov	r8,zero
 82128b4:	01c00084 	movi	r7,2
 82128b8:	003f9d06 	br	8212730 <__divdf3+0xc0>
 82128bc:	3446b03a 	or	r3,r6,r17
 82128c0:	18001526 	beq	r3,zero,8212918 <__divdf3+0x2a8>
 82128c4:	88011b26 	beq	r17,zero,8212d34 <__divdf3+0x6c4>
 82128c8:	8809883a 	mov	r4,r17
 82128cc:	d9800315 	stw	r6,12(sp)
 82128d0:	da400115 	stw	r9,4(sp)
 82128d4:	82143c80 	call	82143c8 <__clzsi2>
 82128d8:	d9800317 	ldw	r6,12(sp)
 82128dc:	da400117 	ldw	r9,4(sp)
 82128e0:	113ffd44 	addi	r4,r2,-11
 82128e4:	00c00704 	movi	r3,28
 82128e8:	19010e16 	blt	r3,r4,8212d24 <__divdf3+0x6b4>
 82128ec:	00c00744 	movi	r3,29
 82128f0:	123ffe04 	addi	r8,r2,-8
 82128f4:	1907c83a 	sub	r3,r3,r4
 82128f8:	8a22983a 	sll	r17,r17,r8
 82128fc:	30c6d83a 	srl	r3,r6,r3
 8212900:	3210983a 	sll	r8,r6,r8
 8212904:	1c62b03a 	or	r17,r3,r17
 8212908:	1080fcc4 	addi	r2,r2,1011
 821290c:	0085c83a 	sub	r2,zero,r2
 8212910:	000f883a 	mov	r7,zero
 8212914:	003f8606 	br	8212730 <__divdf3+0xc0>
 8212918:	0023883a 	mov	r17,zero
 821291c:	0011883a 	mov	r8,zero
 8212920:	01c00044 	movi	r7,1
 8212924:	003f8206 	br	8212730 <__divdf3+0xc0>
 8212928:	01c000c4 	movi	r7,3
 821292c:	003f8006 	br	8212730 <__divdf3+0xc0>
 8212930:	04c00104 	movi	r19,4
 8212934:	0021883a 	mov	r16,zero
 8212938:	0025883a 	mov	r18,zero
 821293c:	02400044 	movi	r9,1
 8212940:	003f6906 	br	82126e8 <__divdf3+0x78>
 8212944:	04c00304 	movi	r19,12
 8212948:	024000c4 	movi	r9,3
 821294c:	003f6606 	br	82126e8 <__divdf3+0x78>
 8212950:	01400434 	movhi	r5,16
 8212954:	0007883a 	mov	r3,zero
 8212958:	297fffc4 	addi	r5,r5,-1
 821295c:	04bfffc4 	movi	r18,-1
 8212960:	0081ffc4 	movi	r2,2047
 8212964:	003fa106 	br	82127ec <__divdf3+0x17c>
 8212968:	00c00044 	movi	r3,1
 821296c:	1887c83a 	sub	r3,r3,r2
 8212970:	01000e04 	movi	r4,56
 8212974:	20c1210e 	bge	r4,r3,8212dfc <__divdf3+0x78c>
 8212978:	98c0004c 	andi	r3,r19,1
 821297c:	0005883a 	mov	r2,zero
 8212980:	000b883a 	mov	r5,zero
 8212984:	0025883a 	mov	r18,zero
 8212988:	003f9806 	br	82127ec <__divdf3+0x17c>
 821298c:	8c00fd36 	bltu	r17,r16,8212d84 <__divdf3+0x714>
 8212990:	8440fb26 	beq	r16,r17,8212d80 <__divdf3+0x710>
 8212994:	8007883a 	mov	r3,r16
 8212998:	ad7fffc4 	addi	r21,r21,-1
 821299c:	0021883a 	mov	r16,zero
 82129a0:	4004d63a 	srli	r2,r8,24
 82129a4:	8822923a 	slli	r17,r17,8
 82129a8:	1809883a 	mov	r4,r3
 82129ac:	402c923a 	slli	r22,r8,8
 82129b0:	88b8b03a 	or	fp,r17,r2
 82129b4:	e028d43a 	srli	r20,fp,16
 82129b8:	d8c00015 	stw	r3,0(sp)
 82129bc:	e5ffffcc 	andi	r23,fp,65535
 82129c0:	a00b883a 	mov	r5,r20
 82129c4:	8202c6c0 	call	8202c6c <__udivsi3>
 82129c8:	d8c00017 	ldw	r3,0(sp)
 82129cc:	a00b883a 	mov	r5,r20
 82129d0:	d8800315 	stw	r2,12(sp)
 82129d4:	1809883a 	mov	r4,r3
 82129d8:	8202cd00 	call	8202cd0 <__umodsi3>
 82129dc:	d9800317 	ldw	r6,12(sp)
 82129e0:	1006943a 	slli	r3,r2,16
 82129e4:	9004d43a 	srli	r2,r18,16
 82129e8:	b9a3383a 	mul	r17,r23,r6
 82129ec:	10c4b03a 	or	r2,r2,r3
 82129f0:	1440062e 	bgeu	r2,r17,8212a0c <__divdf3+0x39c>
 82129f4:	1705883a 	add	r2,r2,fp
 82129f8:	30ffffc4 	addi	r3,r6,-1
 82129fc:	1700ee36 	bltu	r2,fp,8212db8 <__divdf3+0x748>
 8212a00:	1440ed2e 	bgeu	r2,r17,8212db8 <__divdf3+0x748>
 8212a04:	31bfff84 	addi	r6,r6,-2
 8212a08:	1705883a 	add	r2,r2,fp
 8212a0c:	1463c83a 	sub	r17,r2,r17
 8212a10:	a00b883a 	mov	r5,r20
 8212a14:	8809883a 	mov	r4,r17
 8212a18:	d9800315 	stw	r6,12(sp)
 8212a1c:	8202c6c0 	call	8202c6c <__udivsi3>
 8212a20:	a00b883a 	mov	r5,r20
 8212a24:	8809883a 	mov	r4,r17
 8212a28:	d8800215 	stw	r2,8(sp)
 8212a2c:	8202cd00 	call	8202cd0 <__umodsi3>
 8212a30:	d9c00217 	ldw	r7,8(sp)
 8212a34:	1004943a 	slli	r2,r2,16
 8212a38:	94bfffcc 	andi	r18,r18,65535
 8212a3c:	b9d1383a 	mul	r8,r23,r7
 8212a40:	90a4b03a 	or	r18,r18,r2
 8212a44:	d9800317 	ldw	r6,12(sp)
 8212a48:	9200062e 	bgeu	r18,r8,8212a64 <__divdf3+0x3f4>
 8212a4c:	9725883a 	add	r18,r18,fp
 8212a50:	38bfffc4 	addi	r2,r7,-1
 8212a54:	9700d636 	bltu	r18,fp,8212db0 <__divdf3+0x740>
 8212a58:	9200d52e 	bgeu	r18,r8,8212db0 <__divdf3+0x740>
 8212a5c:	39ffff84 	addi	r7,r7,-2
 8212a60:	9725883a 	add	r18,r18,fp
 8212a64:	3004943a 	slli	r2,r6,16
 8212a68:	b012d43a 	srli	r9,r22,16
 8212a6c:	b1bfffcc 	andi	r6,r22,65535
 8212a70:	11e2b03a 	or	r17,r2,r7
 8212a74:	8806d43a 	srli	r3,r17,16
 8212a78:	893fffcc 	andi	r4,r17,65535
 8212a7c:	218b383a 	mul	r5,r4,r6
 8212a80:	30c5383a 	mul	r2,r6,r3
 8212a84:	2249383a 	mul	r4,r4,r9
 8212a88:	280ed43a 	srli	r7,r5,16
 8212a8c:	9225c83a 	sub	r18,r18,r8
 8212a90:	2089883a 	add	r4,r4,r2
 8212a94:	3909883a 	add	r4,r7,r4
 8212a98:	1a47383a 	mul	r3,r3,r9
 8212a9c:	2080022e 	bgeu	r4,r2,8212aa8 <__divdf3+0x438>
 8212aa0:	00800074 	movhi	r2,1
 8212aa4:	1887883a 	add	r3,r3,r2
 8212aa8:	2004d43a 	srli	r2,r4,16
 8212aac:	2008943a 	slli	r4,r4,16
 8212ab0:	297fffcc 	andi	r5,r5,65535
 8212ab4:	10c7883a 	add	r3,r2,r3
 8212ab8:	2149883a 	add	r4,r4,r5
 8212abc:	90c0a536 	bltu	r18,r3,8212d54 <__divdf3+0x6e4>
 8212ac0:	90c0bf26 	beq	r18,r3,8212dc0 <__divdf3+0x750>
 8212ac4:	90c7c83a 	sub	r3,r18,r3
 8212ac8:	810fc83a 	sub	r7,r16,r4
 8212acc:	81e5803a 	cmpltu	r18,r16,r7
 8212ad0:	1ca5c83a 	sub	r18,r3,r18
 8212ad4:	e480c126 	beq	fp,r18,8212ddc <__divdf3+0x76c>
 8212ad8:	a00b883a 	mov	r5,r20
 8212adc:	9009883a 	mov	r4,r18
 8212ae0:	d9800315 	stw	r6,12(sp)
 8212ae4:	d9c00215 	stw	r7,8(sp)
 8212ae8:	da400115 	stw	r9,4(sp)
 8212aec:	8202c6c0 	call	8202c6c <__udivsi3>
 8212af0:	a00b883a 	mov	r5,r20
 8212af4:	9009883a 	mov	r4,r18
 8212af8:	d8800015 	stw	r2,0(sp)
 8212afc:	8202cd00 	call	8202cd0 <__umodsi3>
 8212b00:	d9c00217 	ldw	r7,8(sp)
 8212b04:	da000017 	ldw	r8,0(sp)
 8212b08:	1006943a 	slli	r3,r2,16
 8212b0c:	3804d43a 	srli	r2,r7,16
 8212b10:	ba21383a 	mul	r16,r23,r8
 8212b14:	d9800317 	ldw	r6,12(sp)
 8212b18:	10c4b03a 	or	r2,r2,r3
 8212b1c:	da400117 	ldw	r9,4(sp)
 8212b20:	1400062e 	bgeu	r2,r16,8212b3c <__divdf3+0x4cc>
 8212b24:	1705883a 	add	r2,r2,fp
 8212b28:	40ffffc4 	addi	r3,r8,-1
 8212b2c:	1700ad36 	bltu	r2,fp,8212de4 <__divdf3+0x774>
 8212b30:	1400ac2e 	bgeu	r2,r16,8212de4 <__divdf3+0x774>
 8212b34:	423fff84 	addi	r8,r8,-2
 8212b38:	1705883a 	add	r2,r2,fp
 8212b3c:	1421c83a 	sub	r16,r2,r16
 8212b40:	a00b883a 	mov	r5,r20
 8212b44:	8009883a 	mov	r4,r16
 8212b48:	d9800315 	stw	r6,12(sp)
 8212b4c:	d9c00215 	stw	r7,8(sp)
 8212b50:	da000015 	stw	r8,0(sp)
 8212b54:	da400115 	stw	r9,4(sp)
 8212b58:	8202c6c0 	call	8202c6c <__udivsi3>
 8212b5c:	8009883a 	mov	r4,r16
 8212b60:	a00b883a 	mov	r5,r20
 8212b64:	1025883a 	mov	r18,r2
 8212b68:	8202cd00 	call	8202cd0 <__umodsi3>
 8212b6c:	d9c00217 	ldw	r7,8(sp)
 8212b70:	1004943a 	slli	r2,r2,16
 8212b74:	bcaf383a 	mul	r23,r23,r18
 8212b78:	393fffcc 	andi	r4,r7,65535
 8212b7c:	2088b03a 	or	r4,r4,r2
 8212b80:	d9800317 	ldw	r6,12(sp)
 8212b84:	da000017 	ldw	r8,0(sp)
 8212b88:	da400117 	ldw	r9,4(sp)
 8212b8c:	25c0062e 	bgeu	r4,r23,8212ba8 <__divdf3+0x538>
 8212b90:	2709883a 	add	r4,r4,fp
 8212b94:	90bfffc4 	addi	r2,r18,-1
 8212b98:	27009436 	bltu	r4,fp,8212dec <__divdf3+0x77c>
 8212b9c:	25c0932e 	bgeu	r4,r23,8212dec <__divdf3+0x77c>
 8212ba0:	94bfff84 	addi	r18,r18,-2
 8212ba4:	2709883a 	add	r4,r4,fp
 8212ba8:	4004943a 	slli	r2,r8,16
 8212bac:	25efc83a 	sub	r23,r4,r23
 8212bb0:	1490b03a 	or	r8,r2,r18
 8212bb4:	4008d43a 	srli	r4,r8,16
 8212bb8:	40ffffcc 	andi	r3,r8,65535
 8212bbc:	30c5383a 	mul	r2,r6,r3
 8212bc0:	1a47383a 	mul	r3,r3,r9
 8212bc4:	310d383a 	mul	r6,r6,r4
 8212bc8:	100ad43a 	srli	r5,r2,16
 8212bcc:	4913383a 	mul	r9,r9,r4
 8212bd0:	1987883a 	add	r3,r3,r6
 8212bd4:	28c7883a 	add	r3,r5,r3
 8212bd8:	1980022e 	bgeu	r3,r6,8212be4 <__divdf3+0x574>
 8212bdc:	01000074 	movhi	r4,1
 8212be0:	4913883a 	add	r9,r9,r4
 8212be4:	1808d43a 	srli	r4,r3,16
 8212be8:	1806943a 	slli	r3,r3,16
 8212bec:	10bfffcc 	andi	r2,r2,65535
 8212bf0:	2253883a 	add	r9,r4,r9
 8212bf4:	1887883a 	add	r3,r3,r2
 8212bf8:	ba403836 	bltu	r23,r9,8212cdc <__divdf3+0x66c>
 8212bfc:	ba403626 	beq	r23,r9,8212cd8 <__divdf3+0x668>
 8212c00:	42000054 	ori	r8,r8,1
 8212c04:	a880ffc4 	addi	r2,r21,1023
 8212c08:	00bf570e 	bge	zero,r2,8212968 <__divdf3+0x2f8>
 8212c0c:	40c001cc 	andi	r3,r8,7
 8212c10:	18000726 	beq	r3,zero,8212c30 <__divdf3+0x5c0>
 8212c14:	40c003cc 	andi	r3,r8,15
 8212c18:	01000104 	movi	r4,4
 8212c1c:	19000426 	beq	r3,r4,8212c30 <__divdf3+0x5c0>
 8212c20:	4107883a 	add	r3,r8,r4
 8212c24:	1a11803a 	cmpltu	r8,r3,r8
 8212c28:	8a23883a 	add	r17,r17,r8
 8212c2c:	1811883a 	mov	r8,r3
 8212c30:	88c0402c 	andhi	r3,r17,256
 8212c34:	18000426 	beq	r3,zero,8212c48 <__divdf3+0x5d8>
 8212c38:	00ffc034 	movhi	r3,65280
 8212c3c:	18ffffc4 	addi	r3,r3,-1
 8212c40:	a8810004 	addi	r2,r21,1024
 8212c44:	88e2703a 	and	r17,r17,r3
 8212c48:	00c1ff84 	movi	r3,2046
 8212c4c:	18bee316 	blt	r3,r2,82127dc <__divdf3+0x16c>
 8212c50:	8824977a 	slli	r18,r17,29
 8212c54:	4010d0fa 	srli	r8,r8,3
 8212c58:	8822927a 	slli	r17,r17,9
 8212c5c:	1081ffcc 	andi	r2,r2,2047
 8212c60:	9224b03a 	or	r18,r18,r8
 8212c64:	880ad33a 	srli	r5,r17,12
 8212c68:	98c0004c 	andi	r3,r19,1
 8212c6c:	003edf06 	br	82127ec <__divdf3+0x17c>
 8212c70:	8080022c 	andhi	r2,r16,8
 8212c74:	10001226 	beq	r2,zero,8212cc0 <__divdf3+0x650>
 8212c78:	8880022c 	andhi	r2,r17,8
 8212c7c:	1000101e 	bne	r2,zero,8212cc0 <__divdf3+0x650>
 8212c80:	00800434 	movhi	r2,16
 8212c84:	89400234 	orhi	r5,r17,8
 8212c88:	10bfffc4 	addi	r2,r2,-1
 8212c8c:	b007883a 	mov	r3,r22
 8212c90:	288a703a 	and	r5,r5,r2
 8212c94:	4025883a 	mov	r18,r8
 8212c98:	003f3106 	br	8212960 <__divdf3+0x2f0>
 8212c9c:	008000c4 	movi	r2,3
 8212ca0:	3880a626 	beq	r7,r2,8212f3c <__divdf3+0x8cc>
 8212ca4:	00800044 	movi	r2,1
 8212ca8:	3880521e 	bne	r7,r2,8212df4 <__divdf3+0x784>
 8212cac:	b807883a 	mov	r3,r23
 8212cb0:	0005883a 	mov	r2,zero
 8212cb4:	000b883a 	mov	r5,zero
 8212cb8:	0025883a 	mov	r18,zero
 8212cbc:	003ecb06 	br	82127ec <__divdf3+0x17c>
 8212cc0:	00800434 	movhi	r2,16
 8212cc4:	81400234 	orhi	r5,r16,8
 8212cc8:	10bfffc4 	addi	r2,r2,-1
 8212ccc:	a007883a 	mov	r3,r20
 8212cd0:	288a703a 	and	r5,r5,r2
 8212cd4:	003f2206 	br	8212960 <__divdf3+0x2f0>
 8212cd8:	183fca26 	beq	r3,zero,8212c04 <__divdf3+0x594>
 8212cdc:	e5ef883a 	add	r23,fp,r23
 8212ce0:	40bfffc4 	addi	r2,r8,-1
 8212ce4:	bf00392e 	bgeu	r23,fp,8212dcc <__divdf3+0x75c>
 8212ce8:	1011883a 	mov	r8,r2
 8212cec:	ba7fc41e 	bne	r23,r9,8212c00 <__divdf3+0x590>
 8212cf0:	b0ffc31e 	bne	r22,r3,8212c00 <__divdf3+0x590>
 8212cf4:	003fc306 	br	8212c04 <__divdf3+0x594>
 8212cf8:	143ff604 	addi	r16,r2,-40
 8212cfc:	9c20983a 	sll	r16,r19,r16
 8212d00:	0025883a 	mov	r18,zero
 8212d04:	003ee206 	br	8212890 <__divdf3+0x220>
 8212d08:	d9800315 	stw	r6,12(sp)
 8212d0c:	d9c00215 	stw	r7,8(sp)
 8212d10:	82143c80 	call	82143c8 <__clzsi2>
 8212d14:	10800804 	addi	r2,r2,32
 8212d18:	d9c00217 	ldw	r7,8(sp)
 8212d1c:	d9800317 	ldw	r6,12(sp)
 8212d20:	003ed106 	br	8212868 <__divdf3+0x1f8>
 8212d24:	147ff604 	addi	r17,r2,-40
 8212d28:	3462983a 	sll	r17,r6,r17
 8212d2c:	0011883a 	mov	r8,zero
 8212d30:	003ef506 	br	8212908 <__divdf3+0x298>
 8212d34:	3009883a 	mov	r4,r6
 8212d38:	d9800315 	stw	r6,12(sp)
 8212d3c:	da400115 	stw	r9,4(sp)
 8212d40:	82143c80 	call	82143c8 <__clzsi2>
 8212d44:	10800804 	addi	r2,r2,32
 8212d48:	da400117 	ldw	r9,4(sp)
 8212d4c:	d9800317 	ldw	r6,12(sp)
 8212d50:	003ee306 	br	82128e0 <__divdf3+0x270>
 8212d54:	85a1883a 	add	r16,r16,r22
 8212d58:	8585803a 	cmpltu	r2,r16,r22
 8212d5c:	1705883a 	add	r2,r2,fp
 8212d60:	14a5883a 	add	r18,r2,r18
 8212d64:	88bfffc4 	addi	r2,r17,-1
 8212d68:	e4800c2e 	bgeu	fp,r18,8212d9c <__divdf3+0x72c>
 8212d6c:	90c03e36 	bltu	r18,r3,8212e68 <__divdf3+0x7f8>
 8212d70:	1c806926 	beq	r3,r18,8212f18 <__divdf3+0x8a8>
 8212d74:	90c7c83a 	sub	r3,r18,r3
 8212d78:	1023883a 	mov	r17,r2
 8212d7c:	003f5206 	br	8212ac8 <__divdf3+0x458>
 8212d80:	923f0436 	bltu	r18,r8,8212994 <__divdf3+0x324>
 8212d84:	800897fa 	slli	r4,r16,31
 8212d88:	9004d07a 	srli	r2,r18,1
 8212d8c:	8006d07a 	srli	r3,r16,1
 8212d90:	902097fa 	slli	r16,r18,31
 8212d94:	20a4b03a 	or	r18,r4,r2
 8212d98:	003f0106 	br	82129a0 <__divdf3+0x330>
 8212d9c:	e4bff51e 	bne	fp,r18,8212d74 <__divdf3+0x704>
 8212da0:	85bff22e 	bgeu	r16,r22,8212d6c <__divdf3+0x6fc>
 8212da4:	e0c7c83a 	sub	r3,fp,r3
 8212da8:	1023883a 	mov	r17,r2
 8212dac:	003f4606 	br	8212ac8 <__divdf3+0x458>
 8212db0:	100f883a 	mov	r7,r2
 8212db4:	003f2b06 	br	8212a64 <__divdf3+0x3f4>
 8212db8:	180d883a 	mov	r6,r3
 8212dbc:	003f1306 	br	8212a0c <__divdf3+0x39c>
 8212dc0:	813fe436 	bltu	r16,r4,8212d54 <__divdf3+0x6e4>
 8212dc4:	0007883a 	mov	r3,zero
 8212dc8:	003f3f06 	br	8212ac8 <__divdf3+0x458>
 8212dcc:	ba402c36 	bltu	r23,r9,8212e80 <__divdf3+0x810>
 8212dd0:	4dc05426 	beq	r9,r23,8212f24 <__divdf3+0x8b4>
 8212dd4:	1011883a 	mov	r8,r2
 8212dd8:	003f8906 	br	8212c00 <__divdf3+0x590>
 8212ddc:	023fffc4 	movi	r8,-1
 8212de0:	003f8806 	br	8212c04 <__divdf3+0x594>
 8212de4:	1811883a 	mov	r8,r3
 8212de8:	003f5406 	br	8212b3c <__divdf3+0x4cc>
 8212dec:	1025883a 	mov	r18,r2
 8212df0:	003f6d06 	br	8212ba8 <__divdf3+0x538>
 8212df4:	b827883a 	mov	r19,r23
 8212df8:	003f8206 	br	8212c04 <__divdf3+0x594>
 8212dfc:	010007c4 	movi	r4,31
 8212e00:	20c02616 	blt	r4,r3,8212e9c <__divdf3+0x82c>
 8212e04:	00800804 	movi	r2,32
 8212e08:	10c5c83a 	sub	r2,r2,r3
 8212e0c:	888a983a 	sll	r5,r17,r2
 8212e10:	40c8d83a 	srl	r4,r8,r3
 8212e14:	4084983a 	sll	r2,r8,r2
 8212e18:	88e2d83a 	srl	r17,r17,r3
 8212e1c:	2906b03a 	or	r3,r5,r4
 8212e20:	1004c03a 	cmpne	r2,r2,zero
 8212e24:	1886b03a 	or	r3,r3,r2
 8212e28:	188001cc 	andi	r2,r3,7
 8212e2c:	10000726 	beq	r2,zero,8212e4c <__divdf3+0x7dc>
 8212e30:	188003cc 	andi	r2,r3,15
 8212e34:	01000104 	movi	r4,4
 8212e38:	11000426 	beq	r2,r4,8212e4c <__divdf3+0x7dc>
 8212e3c:	1805883a 	mov	r2,r3
 8212e40:	10c00104 	addi	r3,r2,4
 8212e44:	1885803a 	cmpltu	r2,r3,r2
 8212e48:	88a3883a 	add	r17,r17,r2
 8212e4c:	8880202c 	andhi	r2,r17,128
 8212e50:	10002726 	beq	r2,zero,8212ef0 <__divdf3+0x880>
 8212e54:	98c0004c 	andi	r3,r19,1
 8212e58:	00800044 	movi	r2,1
 8212e5c:	000b883a 	mov	r5,zero
 8212e60:	0025883a 	mov	r18,zero
 8212e64:	003e6106 	br	82127ec <__divdf3+0x17c>
 8212e68:	85a1883a 	add	r16,r16,r22
 8212e6c:	8585803a 	cmpltu	r2,r16,r22
 8212e70:	1705883a 	add	r2,r2,fp
 8212e74:	14a5883a 	add	r18,r2,r18
 8212e78:	8c7fff84 	addi	r17,r17,-2
 8212e7c:	003f1106 	br	8212ac4 <__divdf3+0x454>
 8212e80:	b589883a 	add	r4,r22,r22
 8212e84:	25ad803a 	cmpltu	r22,r4,r22
 8212e88:	b739883a 	add	fp,r22,fp
 8212e8c:	40bfff84 	addi	r2,r8,-2
 8212e90:	bf2f883a 	add	r23,r23,fp
 8212e94:	202d883a 	mov	r22,r4
 8212e98:	003f9306 	br	8212ce8 <__divdf3+0x678>
 8212e9c:	013ff844 	movi	r4,-31
 8212ea0:	2085c83a 	sub	r2,r4,r2
 8212ea4:	8888d83a 	srl	r4,r17,r2
 8212ea8:	00800804 	movi	r2,32
 8212eac:	18802126 	beq	r3,r2,8212f34 <__divdf3+0x8c4>
 8212eb0:	00801004 	movi	r2,64
 8212eb4:	10c5c83a 	sub	r2,r2,r3
 8212eb8:	8884983a 	sll	r2,r17,r2
 8212ebc:	1204b03a 	or	r2,r2,r8
 8212ec0:	1004c03a 	cmpne	r2,r2,zero
 8212ec4:	2084b03a 	or	r2,r4,r2
 8212ec8:	144001cc 	andi	r17,r2,7
 8212ecc:	88000d1e 	bne	r17,zero,8212f04 <__divdf3+0x894>
 8212ed0:	000b883a 	mov	r5,zero
 8212ed4:	1024d0fa 	srli	r18,r2,3
 8212ed8:	98c0004c 	andi	r3,r19,1
 8212edc:	0005883a 	mov	r2,zero
 8212ee0:	9464b03a 	or	r18,r18,r17
 8212ee4:	003e4106 	br	82127ec <__divdf3+0x17c>
 8212ee8:	1007883a 	mov	r3,r2
 8212eec:	0023883a 	mov	r17,zero
 8212ef0:	880a927a 	slli	r5,r17,9
 8212ef4:	1805883a 	mov	r2,r3
 8212ef8:	8822977a 	slli	r17,r17,29
 8212efc:	280ad33a 	srli	r5,r5,12
 8212f00:	003ff406 	br	8212ed4 <__divdf3+0x864>
 8212f04:	10c003cc 	andi	r3,r2,15
 8212f08:	01000104 	movi	r4,4
 8212f0c:	193ff626 	beq	r3,r4,8212ee8 <__divdf3+0x878>
 8212f10:	0023883a 	mov	r17,zero
 8212f14:	003fca06 	br	8212e40 <__divdf3+0x7d0>
 8212f18:	813fd336 	bltu	r16,r4,8212e68 <__divdf3+0x7f8>
 8212f1c:	1023883a 	mov	r17,r2
 8212f20:	003fa806 	br	8212dc4 <__divdf3+0x754>
 8212f24:	b0ffd636 	bltu	r22,r3,8212e80 <__divdf3+0x810>
 8212f28:	1011883a 	mov	r8,r2
 8212f2c:	b0ff341e 	bne	r22,r3,8212c00 <__divdf3+0x590>
 8212f30:	003f3406 	br	8212c04 <__divdf3+0x594>
 8212f34:	0005883a 	mov	r2,zero
 8212f38:	003fe006 	br	8212ebc <__divdf3+0x84c>
 8212f3c:	00800434 	movhi	r2,16
 8212f40:	89400234 	orhi	r5,r17,8
 8212f44:	10bfffc4 	addi	r2,r2,-1
 8212f48:	b807883a 	mov	r3,r23
 8212f4c:	288a703a 	and	r5,r5,r2
 8212f50:	4025883a 	mov	r18,r8
 8212f54:	003e8206 	br	8212960 <__divdf3+0x2f0>

08212f58 <__eqdf2>:
 8212f58:	2804d53a 	srli	r2,r5,20
 8212f5c:	3806d53a 	srli	r3,r7,20
 8212f60:	02000434 	movhi	r8,16
 8212f64:	423fffc4 	addi	r8,r8,-1
 8212f68:	1081ffcc 	andi	r2,r2,2047
 8212f6c:	0281ffc4 	movi	r10,2047
 8212f70:	2a12703a 	and	r9,r5,r8
 8212f74:	18c1ffcc 	andi	r3,r3,2047
 8212f78:	3a10703a 	and	r8,r7,r8
 8212f7c:	280ad7fa 	srli	r5,r5,31
 8212f80:	380ed7fa 	srli	r7,r7,31
 8212f84:	12801026 	beq	r2,r10,8212fc8 <__eqdf2+0x70>
 8212f88:	0281ffc4 	movi	r10,2047
 8212f8c:	1a800a26 	beq	r3,r10,8212fb8 <__eqdf2+0x60>
 8212f90:	10c00226 	beq	r2,r3,8212f9c <__eqdf2+0x44>
 8212f94:	00800044 	movi	r2,1
 8212f98:	f800283a 	ret
 8212f9c:	4a3ffd1e 	bne	r9,r8,8212f94 <__eqdf2+0x3c>
 8212fa0:	21bffc1e 	bne	r4,r6,8212f94 <__eqdf2+0x3c>
 8212fa4:	29c00c26 	beq	r5,r7,8212fd8 <__eqdf2+0x80>
 8212fa8:	103ffa1e 	bne	r2,zero,8212f94 <__eqdf2+0x3c>
 8212fac:	2244b03a 	or	r2,r4,r9
 8212fb0:	1004c03a 	cmpne	r2,r2,zero
 8212fb4:	f800283a 	ret
 8212fb8:	3214b03a 	or	r10,r6,r8
 8212fbc:	503ff426 	beq	r10,zero,8212f90 <__eqdf2+0x38>
 8212fc0:	00800044 	movi	r2,1
 8212fc4:	f800283a 	ret
 8212fc8:	2254b03a 	or	r10,r4,r9
 8212fcc:	503fee26 	beq	r10,zero,8212f88 <__eqdf2+0x30>
 8212fd0:	00800044 	movi	r2,1
 8212fd4:	f800283a 	ret
 8212fd8:	0005883a 	mov	r2,zero
 8212fdc:	f800283a 	ret

08212fe0 <__gedf2>:
 8212fe0:	2804d53a 	srli	r2,r5,20
 8212fe4:	3806d53a 	srli	r3,r7,20
 8212fe8:	02000434 	movhi	r8,16
 8212fec:	423fffc4 	addi	r8,r8,-1
 8212ff0:	1081ffcc 	andi	r2,r2,2047
 8212ff4:	0241ffc4 	movi	r9,2047
 8212ff8:	2a14703a 	and	r10,r5,r8
 8212ffc:	18c1ffcc 	andi	r3,r3,2047
 8213000:	3a10703a 	and	r8,r7,r8
 8213004:	280ad7fa 	srli	r5,r5,31
 8213008:	380ed7fa 	srli	r7,r7,31
 821300c:	12401d26 	beq	r2,r9,8213084 <__gedf2+0xa4>
 8213010:	0241ffc4 	movi	r9,2047
 8213014:	1a401226 	beq	r3,r9,8213060 <__gedf2+0x80>
 8213018:	1000081e 	bne	r2,zero,821303c <__gedf2+0x5c>
 821301c:	2296b03a 	or	r11,r4,r10
 8213020:	5813003a 	cmpeq	r9,r11,zero
 8213024:	1800091e 	bne	r3,zero,821304c <__gedf2+0x6c>
 8213028:	3218b03a 	or	r12,r6,r8
 821302c:	6000071e 	bne	r12,zero,821304c <__gedf2+0x6c>
 8213030:	0005883a 	mov	r2,zero
 8213034:	5800101e 	bne	r11,zero,8213078 <__gedf2+0x98>
 8213038:	f800283a 	ret
 821303c:	18000c1e 	bne	r3,zero,8213070 <__gedf2+0x90>
 8213040:	3212b03a 	or	r9,r6,r8
 8213044:	48000c26 	beq	r9,zero,8213078 <__gedf2+0x98>
 8213048:	0013883a 	mov	r9,zero
 821304c:	39c03fcc 	andi	r7,r7,255
 8213050:	48000826 	beq	r9,zero,8213074 <__gedf2+0x94>
 8213054:	38000926 	beq	r7,zero,821307c <__gedf2+0x9c>
 8213058:	00800044 	movi	r2,1
 821305c:	f800283a 	ret
 8213060:	3212b03a 	or	r9,r6,r8
 8213064:	483fec26 	beq	r9,zero,8213018 <__gedf2+0x38>
 8213068:	00bfff84 	movi	r2,-2
 821306c:	f800283a 	ret
 8213070:	39c03fcc 	andi	r7,r7,255
 8213074:	29c00626 	beq	r5,r7,8213090 <__gedf2+0xb0>
 8213078:	283ff726 	beq	r5,zero,8213058 <__gedf2+0x78>
 821307c:	00bfffc4 	movi	r2,-1
 8213080:	f800283a 	ret
 8213084:	2292b03a 	or	r9,r4,r10
 8213088:	483fe126 	beq	r9,zero,8213010 <__gedf2+0x30>
 821308c:	003ff606 	br	8213068 <__gedf2+0x88>
 8213090:	18bff916 	blt	r3,r2,8213078 <__gedf2+0x98>
 8213094:	10c00316 	blt	r2,r3,82130a4 <__gedf2+0xc4>
 8213098:	42bff736 	bltu	r8,r10,8213078 <__gedf2+0x98>
 821309c:	52000326 	beq	r10,r8,82130ac <__gedf2+0xcc>
 82130a0:	5200042e 	bgeu	r10,r8,82130b4 <__gedf2+0xd4>
 82130a4:	283fec1e 	bne	r5,zero,8213058 <__gedf2+0x78>
 82130a8:	003ff406 	br	821307c <__gedf2+0x9c>
 82130ac:	313ff236 	bltu	r6,r4,8213078 <__gedf2+0x98>
 82130b0:	21bffc36 	bltu	r4,r6,82130a4 <__gedf2+0xc4>
 82130b4:	0005883a 	mov	r2,zero
 82130b8:	f800283a 	ret

082130bc <__ledf2>:
 82130bc:	2804d53a 	srli	r2,r5,20
 82130c0:	3810d53a 	srli	r8,r7,20
 82130c4:	00c00434 	movhi	r3,16
 82130c8:	18ffffc4 	addi	r3,r3,-1
 82130cc:	1081ffcc 	andi	r2,r2,2047
 82130d0:	0241ffc4 	movi	r9,2047
 82130d4:	28d4703a 	and	r10,r5,r3
 82130d8:	4201ffcc 	andi	r8,r8,2047
 82130dc:	38c6703a 	and	r3,r7,r3
 82130e0:	280ad7fa 	srli	r5,r5,31
 82130e4:	380ed7fa 	srli	r7,r7,31
 82130e8:	12401f26 	beq	r2,r9,8213168 <__ledf2+0xac>
 82130ec:	0241ffc4 	movi	r9,2047
 82130f0:	42401426 	beq	r8,r9,8213144 <__ledf2+0x88>
 82130f4:	1000091e 	bne	r2,zero,821311c <__ledf2+0x60>
 82130f8:	2296b03a 	or	r11,r4,r10
 82130fc:	5813003a 	cmpeq	r9,r11,zero
 8213100:	29403fcc 	andi	r5,r5,255
 8213104:	40000a1e 	bne	r8,zero,8213130 <__ledf2+0x74>
 8213108:	30d8b03a 	or	r12,r6,r3
 821310c:	6000081e 	bne	r12,zero,8213130 <__ledf2+0x74>
 8213110:	0005883a 	mov	r2,zero
 8213114:	5800111e 	bne	r11,zero,821315c <__ledf2+0xa0>
 8213118:	f800283a 	ret
 821311c:	29403fcc 	andi	r5,r5,255
 8213120:	40000c1e 	bne	r8,zero,8213154 <__ledf2+0x98>
 8213124:	30d2b03a 	or	r9,r6,r3
 8213128:	48000c26 	beq	r9,zero,821315c <__ledf2+0xa0>
 821312c:	0013883a 	mov	r9,zero
 8213130:	39c03fcc 	andi	r7,r7,255
 8213134:	48000826 	beq	r9,zero,8213158 <__ledf2+0x9c>
 8213138:	38001126 	beq	r7,zero,8213180 <__ledf2+0xc4>
 821313c:	00800044 	movi	r2,1
 8213140:	f800283a 	ret
 8213144:	30d2b03a 	or	r9,r6,r3
 8213148:	483fea26 	beq	r9,zero,82130f4 <__ledf2+0x38>
 821314c:	00800084 	movi	r2,2
 8213150:	f800283a 	ret
 8213154:	39c03fcc 	andi	r7,r7,255
 8213158:	39400726 	beq	r7,r5,8213178 <__ledf2+0xbc>
 821315c:	2800081e 	bne	r5,zero,8213180 <__ledf2+0xc4>
 8213160:	00800044 	movi	r2,1
 8213164:	f800283a 	ret
 8213168:	2292b03a 	or	r9,r4,r10
 821316c:	483fdf26 	beq	r9,zero,82130ec <__ledf2+0x30>
 8213170:	00800084 	movi	r2,2
 8213174:	f800283a 	ret
 8213178:	4080030e 	bge	r8,r2,8213188 <__ledf2+0xcc>
 821317c:	383fef26 	beq	r7,zero,821313c <__ledf2+0x80>
 8213180:	00bfffc4 	movi	r2,-1
 8213184:	f800283a 	ret
 8213188:	123feb16 	blt	r2,r8,8213138 <__ledf2+0x7c>
 821318c:	1abff336 	bltu	r3,r10,821315c <__ledf2+0xa0>
 8213190:	50c00326 	beq	r10,r3,82131a0 <__ledf2+0xe4>
 8213194:	50c0042e 	bgeu	r10,r3,82131a8 <__ledf2+0xec>
 8213198:	283fe81e 	bne	r5,zero,821313c <__ledf2+0x80>
 821319c:	003ff806 	br	8213180 <__ledf2+0xc4>
 82131a0:	313fee36 	bltu	r6,r4,821315c <__ledf2+0xa0>
 82131a4:	21bffc36 	bltu	r4,r6,8213198 <__ledf2+0xdc>
 82131a8:	0005883a 	mov	r2,zero
 82131ac:	f800283a 	ret

082131b0 <__muldf3>:
 82131b0:	defff304 	addi	sp,sp,-52
 82131b4:	2804d53a 	srli	r2,r5,20
 82131b8:	dd800915 	stw	r22,36(sp)
 82131bc:	282cd7fa 	srli	r22,r5,31
 82131c0:	dc000315 	stw	r16,12(sp)
 82131c4:	04000434 	movhi	r16,16
 82131c8:	dd400815 	stw	r21,32(sp)
 82131cc:	dc800515 	stw	r18,20(sp)
 82131d0:	843fffc4 	addi	r16,r16,-1
 82131d4:	dfc00c15 	stw	ra,48(sp)
 82131d8:	df000b15 	stw	fp,44(sp)
 82131dc:	ddc00a15 	stw	r23,40(sp)
 82131e0:	dd000715 	stw	r20,28(sp)
 82131e4:	dcc00615 	stw	r19,24(sp)
 82131e8:	dc400415 	stw	r17,16(sp)
 82131ec:	1481ffcc 	andi	r18,r2,2047
 82131f0:	2c20703a 	and	r16,r5,r16
 82131f4:	b02b883a 	mov	r21,r22
 82131f8:	b2403fcc 	andi	r9,r22,255
 82131fc:	90006026 	beq	r18,zero,8213380 <__muldf3+0x1d0>
 8213200:	0081ffc4 	movi	r2,2047
 8213204:	2029883a 	mov	r20,r4
 8213208:	90803626 	beq	r18,r2,82132e4 <__muldf3+0x134>
 821320c:	80800434 	orhi	r2,r16,16
 8213210:	100490fa 	slli	r2,r2,3
 8213214:	2020d77a 	srli	r16,r4,29
 8213218:	202890fa 	slli	r20,r4,3
 821321c:	94bf0044 	addi	r18,r18,-1023
 8213220:	80a0b03a 	or	r16,r16,r2
 8213224:	0027883a 	mov	r19,zero
 8213228:	0039883a 	mov	fp,zero
 821322c:	3804d53a 	srli	r2,r7,20
 8213230:	382ed7fa 	srli	r23,r7,31
 8213234:	04400434 	movhi	r17,16
 8213238:	8c7fffc4 	addi	r17,r17,-1
 821323c:	1081ffcc 	andi	r2,r2,2047
 8213240:	3011883a 	mov	r8,r6
 8213244:	3c62703a 	and	r17,r7,r17
 8213248:	ba803fcc 	andi	r10,r23,255
 821324c:	10006d26 	beq	r2,zero,8213404 <__muldf3+0x254>
 8213250:	00c1ffc4 	movi	r3,2047
 8213254:	10c06526 	beq	r2,r3,82133ec <__muldf3+0x23c>
 8213258:	88c00434 	orhi	r3,r17,16
 821325c:	180690fa 	slli	r3,r3,3
 8213260:	3022d77a 	srli	r17,r6,29
 8213264:	301090fa 	slli	r8,r6,3
 8213268:	10bf0044 	addi	r2,r2,-1023
 821326c:	88e2b03a 	or	r17,r17,r3
 8213270:	000b883a 	mov	r5,zero
 8213274:	9085883a 	add	r2,r18,r2
 8213278:	2cc8b03a 	or	r4,r5,r19
 821327c:	00c003c4 	movi	r3,15
 8213280:	bdacf03a 	xor	r22,r23,r22
 8213284:	12c00044 	addi	r11,r2,1
 8213288:	19009936 	bltu	r3,r4,82134f0 <__muldf3+0x340>
 821328c:	200890ba 	slli	r4,r4,2
 8213290:	00c20874 	movhi	r3,2081
 8213294:	18cca904 	addi	r3,r3,12964
 8213298:	20c9883a 	add	r4,r4,r3
 821329c:	20c00017 	ldw	r3,0(r4)
 82132a0:	1800683a 	jmp	r3
 82132a4:	082134f0 	cmpltui	zero,at,34003
 82132a8:	08213304 	addi	zero,at,-31540
 82132ac:	08213304 	addi	zero,at,-31540
 82132b0:	08213300 	call	821330 <OSCtxSw_SWITCH_PC+0x8212f0>
 82132b4:	082134cc 	andi	zero,at,34003
 82132b8:	082134cc 	andi	zero,at,34003
 82132bc:	082134b4 	orhi	zero,at,34002
 82132c0:	08213300 	call	821330 <OSCtxSw_SWITCH_PC+0x8212f0>
 82132c4:	082134cc 	andi	zero,at,34003
 82132c8:	082134b4 	orhi	zero,at,34002
 82132cc:	082134cc 	andi	zero,at,34003
 82132d0:	08213300 	call	821330 <OSCtxSw_SWITCH_PC+0x8212f0>
 82132d4:	082134dc 	xori	zero,at,34003
 82132d8:	082134dc 	xori	zero,at,34003
 82132dc:	082134dc 	xori	zero,at,34003
 82132e0:	082136f8 	rdprs	zero,at,-31525
 82132e4:	2404b03a 	or	r2,r4,r16
 82132e8:	10006f1e 	bne	r2,zero,82134a8 <__muldf3+0x2f8>
 82132ec:	04c00204 	movi	r19,8
 82132f0:	0021883a 	mov	r16,zero
 82132f4:	0029883a 	mov	r20,zero
 82132f8:	07000084 	movi	fp,2
 82132fc:	003fcb06 	br	821322c <__muldf3+0x7c>
 8213300:	502d883a 	mov	r22,r10
 8213304:	00800084 	movi	r2,2
 8213308:	28805726 	beq	r5,r2,8213468 <__muldf3+0x2b8>
 821330c:	008000c4 	movi	r2,3
 8213310:	28816626 	beq	r5,r2,82138ac <__muldf3+0x6fc>
 8213314:	00800044 	movi	r2,1
 8213318:	2881411e 	bne	r5,r2,8213820 <__muldf3+0x670>
 821331c:	b02b883a 	mov	r21,r22
 8213320:	0005883a 	mov	r2,zero
 8213324:	000b883a 	mov	r5,zero
 8213328:	0029883a 	mov	r20,zero
 821332c:	1004953a 	slli	r2,r2,20
 8213330:	a8c03fcc 	andi	r3,r21,255
 8213334:	04400434 	movhi	r17,16
 8213338:	8c7fffc4 	addi	r17,r17,-1
 821333c:	180697fa 	slli	r3,r3,31
 8213340:	2c4a703a 	and	r5,r5,r17
 8213344:	288ab03a 	or	r5,r5,r2
 8213348:	28c6b03a 	or	r3,r5,r3
 821334c:	a005883a 	mov	r2,r20
 8213350:	dfc00c17 	ldw	ra,48(sp)
 8213354:	df000b17 	ldw	fp,44(sp)
 8213358:	ddc00a17 	ldw	r23,40(sp)
 821335c:	dd800917 	ldw	r22,36(sp)
 8213360:	dd400817 	ldw	r21,32(sp)
 8213364:	dd000717 	ldw	r20,28(sp)
 8213368:	dcc00617 	ldw	r19,24(sp)
 821336c:	dc800517 	ldw	r18,20(sp)
 8213370:	dc400417 	ldw	r17,16(sp)
 8213374:	dc000317 	ldw	r16,12(sp)
 8213378:	dec00d04 	addi	sp,sp,52
 821337c:	f800283a 	ret
 8213380:	2404b03a 	or	r2,r4,r16
 8213384:	2027883a 	mov	r19,r4
 8213388:	10004226 	beq	r2,zero,8213494 <__muldf3+0x2e4>
 821338c:	8000fc26 	beq	r16,zero,8213780 <__muldf3+0x5d0>
 8213390:	8009883a 	mov	r4,r16
 8213394:	d9800215 	stw	r6,8(sp)
 8213398:	d9c00015 	stw	r7,0(sp)
 821339c:	da400115 	stw	r9,4(sp)
 82133a0:	82143c80 	call	82143c8 <__clzsi2>
 82133a4:	d9800217 	ldw	r6,8(sp)
 82133a8:	d9c00017 	ldw	r7,0(sp)
 82133ac:	da400117 	ldw	r9,4(sp)
 82133b0:	113ffd44 	addi	r4,r2,-11
 82133b4:	00c00704 	movi	r3,28
 82133b8:	1900ed16 	blt	r3,r4,8213770 <__muldf3+0x5c0>
 82133bc:	00c00744 	movi	r3,29
 82133c0:	147ffe04 	addi	r17,r2,-8
 82133c4:	1907c83a 	sub	r3,r3,r4
 82133c8:	8460983a 	sll	r16,r16,r17
 82133cc:	98c6d83a 	srl	r3,r19,r3
 82133d0:	9c68983a 	sll	r20,r19,r17
 82133d4:	1c20b03a 	or	r16,r3,r16
 82133d8:	1080fcc4 	addi	r2,r2,1011
 82133dc:	00a5c83a 	sub	r18,zero,r2
 82133e0:	0027883a 	mov	r19,zero
 82133e4:	0039883a 	mov	fp,zero
 82133e8:	003f9006 	br	821322c <__muldf3+0x7c>
 82133ec:	3446b03a 	or	r3,r6,r17
 82133f0:	1800261e 	bne	r3,zero,821348c <__muldf3+0x2dc>
 82133f4:	0023883a 	mov	r17,zero
 82133f8:	0011883a 	mov	r8,zero
 82133fc:	01400084 	movi	r5,2
 8213400:	003f9c06 	br	8213274 <__muldf3+0xc4>
 8213404:	3446b03a 	or	r3,r6,r17
 8213408:	18001c26 	beq	r3,zero,821347c <__muldf3+0x2cc>
 821340c:	8800ce26 	beq	r17,zero,8213748 <__muldf3+0x598>
 8213410:	8809883a 	mov	r4,r17
 8213414:	d9800215 	stw	r6,8(sp)
 8213418:	da400115 	stw	r9,4(sp)
 821341c:	da800015 	stw	r10,0(sp)
 8213420:	82143c80 	call	82143c8 <__clzsi2>
 8213424:	d9800217 	ldw	r6,8(sp)
 8213428:	da400117 	ldw	r9,4(sp)
 821342c:	da800017 	ldw	r10,0(sp)
 8213430:	113ffd44 	addi	r4,r2,-11
 8213434:	00c00704 	movi	r3,28
 8213438:	1900bf16 	blt	r3,r4,8213738 <__muldf3+0x588>
 821343c:	00c00744 	movi	r3,29
 8213440:	123ffe04 	addi	r8,r2,-8
 8213444:	1907c83a 	sub	r3,r3,r4
 8213448:	8a22983a 	sll	r17,r17,r8
 821344c:	30c6d83a 	srl	r3,r6,r3
 8213450:	3210983a 	sll	r8,r6,r8
 8213454:	1c62b03a 	or	r17,r3,r17
 8213458:	1080fcc4 	addi	r2,r2,1011
 821345c:	0085c83a 	sub	r2,zero,r2
 8213460:	000b883a 	mov	r5,zero
 8213464:	003f8306 	br	8213274 <__muldf3+0xc4>
 8213468:	b02b883a 	mov	r21,r22
 821346c:	0081ffc4 	movi	r2,2047
 8213470:	000b883a 	mov	r5,zero
 8213474:	0029883a 	mov	r20,zero
 8213478:	003fac06 	br	821332c <__muldf3+0x17c>
 821347c:	0023883a 	mov	r17,zero
 8213480:	0011883a 	mov	r8,zero
 8213484:	01400044 	movi	r5,1
 8213488:	003f7a06 	br	8213274 <__muldf3+0xc4>
 821348c:	014000c4 	movi	r5,3
 8213490:	003f7806 	br	8213274 <__muldf3+0xc4>
 8213494:	04c00104 	movi	r19,4
 8213498:	0021883a 	mov	r16,zero
 821349c:	0029883a 	mov	r20,zero
 82134a0:	07000044 	movi	fp,1
 82134a4:	003f6106 	br	821322c <__muldf3+0x7c>
 82134a8:	04c00304 	movi	r19,12
 82134ac:	070000c4 	movi	fp,3
 82134b0:	003f5e06 	br	821322c <__muldf3+0x7c>
 82134b4:	01400434 	movhi	r5,16
 82134b8:	002b883a 	mov	r21,zero
 82134bc:	297fffc4 	addi	r5,r5,-1
 82134c0:	053fffc4 	movi	r20,-1
 82134c4:	0081ffc4 	movi	r2,2047
 82134c8:	003f9806 	br	821332c <__muldf3+0x17c>
 82134cc:	8023883a 	mov	r17,r16
 82134d0:	a011883a 	mov	r8,r20
 82134d4:	e00b883a 	mov	r5,fp
 82134d8:	003f8a06 	br	8213304 <__muldf3+0x154>
 82134dc:	8023883a 	mov	r17,r16
 82134e0:	a011883a 	mov	r8,r20
 82134e4:	482d883a 	mov	r22,r9
 82134e8:	e00b883a 	mov	r5,fp
 82134ec:	003f8506 	br	8213304 <__muldf3+0x154>
 82134f0:	a00ad43a 	srli	r5,r20,16
 82134f4:	401ad43a 	srli	r13,r8,16
 82134f8:	a53fffcc 	andi	r20,r20,65535
 82134fc:	423fffcc 	andi	r8,r8,65535
 8213500:	4519383a 	mul	r12,r8,r20
 8213504:	4147383a 	mul	r3,r8,r5
 8213508:	6d09383a 	mul	r4,r13,r20
 821350c:	600cd43a 	srli	r6,r12,16
 8213510:	2b5d383a 	mul	r14,r5,r13
 8213514:	20c9883a 	add	r4,r4,r3
 8213518:	310d883a 	add	r6,r6,r4
 821351c:	30c0022e 	bgeu	r6,r3,8213528 <__muldf3+0x378>
 8213520:	00c00074 	movhi	r3,1
 8213524:	70dd883a 	add	r14,r14,r3
 8213528:	8826d43a 	srli	r19,r17,16
 821352c:	8bffffcc 	andi	r15,r17,65535
 8213530:	7d23383a 	mul	r17,r15,r20
 8213534:	7949383a 	mul	r4,r15,r5
 8213538:	9d29383a 	mul	r20,r19,r20
 821353c:	8814d43a 	srli	r10,r17,16
 8213540:	3012943a 	slli	r9,r6,16
 8213544:	a129883a 	add	r20,r20,r4
 8213548:	633fffcc 	andi	r12,r12,65535
 821354c:	5515883a 	add	r10,r10,r20
 8213550:	3006d43a 	srli	r3,r6,16
 8213554:	4b13883a 	add	r9,r9,r12
 8213558:	2ccb383a 	mul	r5,r5,r19
 821355c:	5100022e 	bgeu	r10,r4,8213568 <__muldf3+0x3b8>
 8213560:	01000074 	movhi	r4,1
 8213564:	290b883a 	add	r5,r5,r4
 8213568:	802ad43a 	srli	r21,r16,16
 821356c:	843fffcc 	andi	r16,r16,65535
 8213570:	440d383a 	mul	r6,r8,r16
 8213574:	4565383a 	mul	r18,r8,r21
 8213578:	8349383a 	mul	r4,r16,r13
 821357c:	500e943a 	slli	r7,r10,16
 8213580:	3010d43a 	srli	r8,r6,16
 8213584:	5028d43a 	srli	r20,r10,16
 8213588:	2489883a 	add	r4,r4,r18
 821358c:	8abfffcc 	andi	r10,r17,65535
 8213590:	3a95883a 	add	r10,r7,r10
 8213594:	4119883a 	add	r12,r8,r4
 8213598:	a169883a 	add	r20,r20,r5
 821359c:	1a87883a 	add	r3,r3,r10
 82135a0:	6d5b383a 	mul	r13,r13,r21
 82135a4:	6480022e 	bgeu	r12,r18,82135b0 <__muldf3+0x400>
 82135a8:	01000074 	movhi	r4,1
 82135ac:	691b883a 	add	r13,r13,r4
 82135b0:	7c25383a 	mul	r18,r15,r16
 82135b4:	7d4b383a 	mul	r5,r15,r21
 82135b8:	84cf383a 	mul	r7,r16,r19
 82135bc:	901ed43a 	srli	r15,r18,16
 82135c0:	6008d43a 	srli	r4,r12,16
 82135c4:	6010943a 	slli	r8,r12,16
 82135c8:	394f883a 	add	r7,r7,r5
 82135cc:	333fffcc 	andi	r12,r6,65535
 82135d0:	79df883a 	add	r15,r15,r7
 82135d4:	235b883a 	add	r13,r4,r13
 82135d8:	9d63383a 	mul	r17,r19,r21
 82135dc:	4309883a 	add	r4,r8,r12
 82135e0:	7940022e 	bgeu	r15,r5,82135ec <__muldf3+0x43c>
 82135e4:	01400074 	movhi	r5,1
 82135e8:	8963883a 	add	r17,r17,r5
 82135ec:	780a943a 	slli	r5,r15,16
 82135f0:	91bfffcc 	andi	r6,r18,65535
 82135f4:	70c7883a 	add	r3,r14,r3
 82135f8:	298d883a 	add	r6,r5,r6
 82135fc:	1a8f803a 	cmpltu	r7,r3,r10
 8213600:	350b883a 	add	r5,r6,r20
 8213604:	20c7883a 	add	r3,r4,r3
 8213608:	3955883a 	add	r10,r7,r5
 821360c:	1909803a 	cmpltu	r4,r3,r4
 8213610:	6a91883a 	add	r8,r13,r10
 8213614:	780cd43a 	srli	r6,r15,16
 8213618:	2219883a 	add	r12,r4,r8
 821361c:	2d0b803a 	cmpltu	r5,r5,r20
 8213620:	51cf803a 	cmpltu	r7,r10,r7
 8213624:	29ceb03a 	or	r7,r5,r7
 8213628:	4351803a 	cmpltu	r8,r8,r13
 821362c:	610b803a 	cmpltu	r5,r12,r4
 8213630:	4148b03a 	or	r4,r8,r5
 8213634:	398f883a 	add	r7,r7,r6
 8213638:	3909883a 	add	r4,r7,r4
 821363c:	1810927a 	slli	r8,r3,9
 8213640:	2449883a 	add	r4,r4,r17
 8213644:	2008927a 	slli	r4,r4,9
 8213648:	6022d5fa 	srli	r17,r12,23
 821364c:	1806d5fa 	srli	r3,r3,23
 8213650:	4252b03a 	or	r9,r8,r9
 8213654:	600a927a 	slli	r5,r12,9
 8213658:	4810c03a 	cmpne	r8,r9,zero
 821365c:	2462b03a 	or	r17,r4,r17
 8213660:	40c6b03a 	or	r3,r8,r3
 8213664:	8900402c 	andhi	r4,r17,256
 8213668:	1950b03a 	or	r8,r3,r5
 821366c:	20000726 	beq	r4,zero,821368c <__muldf3+0x4dc>
 8213670:	4006d07a 	srli	r3,r8,1
 8213674:	880497fa 	slli	r2,r17,31
 8213678:	4200004c 	andi	r8,r8,1
 821367c:	8822d07a 	srli	r17,r17,1
 8213680:	1a10b03a 	or	r8,r3,r8
 8213684:	1210b03a 	or	r8,r2,r8
 8213688:	5805883a 	mov	r2,r11
 821368c:	1140ffc4 	addi	r5,r2,1023
 8213690:	0140440e 	bge	zero,r5,82137a4 <__muldf3+0x5f4>
 8213694:	40c001cc 	andi	r3,r8,7
 8213698:	18000726 	beq	r3,zero,82136b8 <__muldf3+0x508>
 821369c:	40c003cc 	andi	r3,r8,15
 82136a0:	01000104 	movi	r4,4
 82136a4:	19000426 	beq	r3,r4,82136b8 <__muldf3+0x508>
 82136a8:	4107883a 	add	r3,r8,r4
 82136ac:	1a11803a 	cmpltu	r8,r3,r8
 82136b0:	8a23883a 	add	r17,r17,r8
 82136b4:	1811883a 	mov	r8,r3
 82136b8:	88c0402c 	andhi	r3,r17,256
 82136bc:	18000426 	beq	r3,zero,82136d0 <__muldf3+0x520>
 82136c0:	11410004 	addi	r5,r2,1024
 82136c4:	00bfc034 	movhi	r2,65280
 82136c8:	10bfffc4 	addi	r2,r2,-1
 82136cc:	88a2703a 	and	r17,r17,r2
 82136d0:	0081ff84 	movi	r2,2046
 82136d4:	117f6416 	blt	r2,r5,8213468 <__muldf3+0x2b8>
 82136d8:	8828977a 	slli	r20,r17,29
 82136dc:	4010d0fa 	srli	r8,r8,3
 82136e0:	8822927a 	slli	r17,r17,9
 82136e4:	2881ffcc 	andi	r2,r5,2047
 82136e8:	a228b03a 	or	r20,r20,r8
 82136ec:	880ad33a 	srli	r5,r17,12
 82136f0:	b02b883a 	mov	r21,r22
 82136f4:	003f0d06 	br	821332c <__muldf3+0x17c>
 82136f8:	8080022c 	andhi	r2,r16,8
 82136fc:	10000926 	beq	r2,zero,8213724 <__muldf3+0x574>
 8213700:	8880022c 	andhi	r2,r17,8
 8213704:	1000071e 	bne	r2,zero,8213724 <__muldf3+0x574>
 8213708:	00800434 	movhi	r2,16
 821370c:	89400234 	orhi	r5,r17,8
 8213710:	10bfffc4 	addi	r2,r2,-1
 8213714:	b82b883a 	mov	r21,r23
 8213718:	288a703a 	and	r5,r5,r2
 821371c:	4029883a 	mov	r20,r8
 8213720:	003f6806 	br	82134c4 <__muldf3+0x314>
 8213724:	00800434 	movhi	r2,16
 8213728:	81400234 	orhi	r5,r16,8
 821372c:	10bfffc4 	addi	r2,r2,-1
 8213730:	288a703a 	and	r5,r5,r2
 8213734:	003f6306 	br	82134c4 <__muldf3+0x314>
 8213738:	147ff604 	addi	r17,r2,-40
 821373c:	3462983a 	sll	r17,r6,r17
 8213740:	0011883a 	mov	r8,zero
 8213744:	003f4406 	br	8213458 <__muldf3+0x2a8>
 8213748:	3009883a 	mov	r4,r6
 821374c:	d9800215 	stw	r6,8(sp)
 8213750:	da400115 	stw	r9,4(sp)
 8213754:	da800015 	stw	r10,0(sp)
 8213758:	82143c80 	call	82143c8 <__clzsi2>
 821375c:	10800804 	addi	r2,r2,32
 8213760:	da800017 	ldw	r10,0(sp)
 8213764:	da400117 	ldw	r9,4(sp)
 8213768:	d9800217 	ldw	r6,8(sp)
 821376c:	003f3006 	br	8213430 <__muldf3+0x280>
 8213770:	143ff604 	addi	r16,r2,-40
 8213774:	9c20983a 	sll	r16,r19,r16
 8213778:	0029883a 	mov	r20,zero
 821377c:	003f1606 	br	82133d8 <__muldf3+0x228>
 8213780:	d9800215 	stw	r6,8(sp)
 8213784:	d9c00015 	stw	r7,0(sp)
 8213788:	da400115 	stw	r9,4(sp)
 821378c:	82143c80 	call	82143c8 <__clzsi2>
 8213790:	10800804 	addi	r2,r2,32
 8213794:	da400117 	ldw	r9,4(sp)
 8213798:	d9c00017 	ldw	r7,0(sp)
 821379c:	d9800217 	ldw	r6,8(sp)
 82137a0:	003f0306 	br	82133b0 <__muldf3+0x200>
 82137a4:	00c00044 	movi	r3,1
 82137a8:	1947c83a 	sub	r3,r3,r5
 82137ac:	00800e04 	movi	r2,56
 82137b0:	10feda16 	blt	r2,r3,821331c <__muldf3+0x16c>
 82137b4:	008007c4 	movi	r2,31
 82137b8:	10c01b16 	blt	r2,r3,8213828 <__muldf3+0x678>
 82137bc:	00800804 	movi	r2,32
 82137c0:	10c5c83a 	sub	r2,r2,r3
 82137c4:	888a983a 	sll	r5,r17,r2
 82137c8:	40c8d83a 	srl	r4,r8,r3
 82137cc:	4084983a 	sll	r2,r8,r2
 82137d0:	88e2d83a 	srl	r17,r17,r3
 82137d4:	2906b03a 	or	r3,r5,r4
 82137d8:	1004c03a 	cmpne	r2,r2,zero
 82137dc:	1886b03a 	or	r3,r3,r2
 82137e0:	188001cc 	andi	r2,r3,7
 82137e4:	10000726 	beq	r2,zero,8213804 <__muldf3+0x654>
 82137e8:	188003cc 	andi	r2,r3,15
 82137ec:	01000104 	movi	r4,4
 82137f0:	11000426 	beq	r2,r4,8213804 <__muldf3+0x654>
 82137f4:	1805883a 	mov	r2,r3
 82137f8:	10c00104 	addi	r3,r2,4
 82137fc:	1885803a 	cmpltu	r2,r3,r2
 8213800:	88a3883a 	add	r17,r17,r2
 8213804:	8880202c 	andhi	r2,r17,128
 8213808:	10001c26 	beq	r2,zero,821387c <__muldf3+0x6cc>
 821380c:	b02b883a 	mov	r21,r22
 8213810:	00800044 	movi	r2,1
 8213814:	000b883a 	mov	r5,zero
 8213818:	0029883a 	mov	r20,zero
 821381c:	003ec306 	br	821332c <__muldf3+0x17c>
 8213820:	5805883a 	mov	r2,r11
 8213824:	003f9906 	br	821368c <__muldf3+0x4dc>
 8213828:	00bff844 	movi	r2,-31
 821382c:	1145c83a 	sub	r2,r2,r5
 8213830:	8888d83a 	srl	r4,r17,r2
 8213834:	00800804 	movi	r2,32
 8213838:	18801a26 	beq	r3,r2,82138a4 <__muldf3+0x6f4>
 821383c:	00801004 	movi	r2,64
 8213840:	10c5c83a 	sub	r2,r2,r3
 8213844:	8884983a 	sll	r2,r17,r2
 8213848:	1204b03a 	or	r2,r2,r8
 821384c:	1004c03a 	cmpne	r2,r2,zero
 8213850:	2084b03a 	or	r2,r4,r2
 8213854:	144001cc 	andi	r17,r2,7
 8213858:	88000d1e 	bne	r17,zero,8213890 <__muldf3+0x6e0>
 821385c:	000b883a 	mov	r5,zero
 8213860:	1028d0fa 	srli	r20,r2,3
 8213864:	b02b883a 	mov	r21,r22
 8213868:	0005883a 	mov	r2,zero
 821386c:	a468b03a 	or	r20,r20,r17
 8213870:	003eae06 	br	821332c <__muldf3+0x17c>
 8213874:	1007883a 	mov	r3,r2
 8213878:	0023883a 	mov	r17,zero
 821387c:	880a927a 	slli	r5,r17,9
 8213880:	1805883a 	mov	r2,r3
 8213884:	8822977a 	slli	r17,r17,29
 8213888:	280ad33a 	srli	r5,r5,12
 821388c:	003ff406 	br	8213860 <__muldf3+0x6b0>
 8213890:	10c003cc 	andi	r3,r2,15
 8213894:	01000104 	movi	r4,4
 8213898:	193ff626 	beq	r3,r4,8213874 <__muldf3+0x6c4>
 821389c:	0023883a 	mov	r17,zero
 82138a0:	003fd506 	br	82137f8 <__muldf3+0x648>
 82138a4:	0005883a 	mov	r2,zero
 82138a8:	003fe706 	br	8213848 <__muldf3+0x698>
 82138ac:	00800434 	movhi	r2,16
 82138b0:	89400234 	orhi	r5,r17,8
 82138b4:	10bfffc4 	addi	r2,r2,-1
 82138b8:	b02b883a 	mov	r21,r22
 82138bc:	288a703a 	and	r5,r5,r2
 82138c0:	4029883a 	mov	r20,r8
 82138c4:	003eff06 	br	82134c4 <__muldf3+0x314>

082138c8 <__subdf3>:
 82138c8:	02000434 	movhi	r8,16
 82138cc:	423fffc4 	addi	r8,r8,-1
 82138d0:	defffb04 	addi	sp,sp,-20
 82138d4:	2a14703a 	and	r10,r5,r8
 82138d8:	3812d53a 	srli	r9,r7,20
 82138dc:	3a10703a 	and	r8,r7,r8
 82138e0:	2006d77a 	srli	r3,r4,29
 82138e4:	3004d77a 	srli	r2,r6,29
 82138e8:	dc000015 	stw	r16,0(sp)
 82138ec:	501490fa 	slli	r10,r10,3
 82138f0:	2820d53a 	srli	r16,r5,20
 82138f4:	401090fa 	slli	r8,r8,3
 82138f8:	dc800215 	stw	r18,8(sp)
 82138fc:	dc400115 	stw	r17,4(sp)
 8213900:	dfc00415 	stw	ra,16(sp)
 8213904:	202290fa 	slli	r17,r4,3
 8213908:	dcc00315 	stw	r19,12(sp)
 821390c:	4a41ffcc 	andi	r9,r9,2047
 8213910:	0101ffc4 	movi	r4,2047
 8213914:	2824d7fa 	srli	r18,r5,31
 8213918:	8401ffcc 	andi	r16,r16,2047
 821391c:	50c6b03a 	or	r3,r10,r3
 8213920:	380ed7fa 	srli	r7,r7,31
 8213924:	408ab03a 	or	r5,r8,r2
 8213928:	300c90fa 	slli	r6,r6,3
 821392c:	49009626 	beq	r9,r4,8213b88 <__subdf3+0x2c0>
 8213930:	39c0005c 	xori	r7,r7,1
 8213934:	8245c83a 	sub	r2,r16,r9
 8213938:	3c807426 	beq	r7,r18,8213b0c <__subdf3+0x244>
 821393c:	0080af0e 	bge	zero,r2,8213bfc <__subdf3+0x334>
 8213940:	48002a1e 	bne	r9,zero,82139ec <__subdf3+0x124>
 8213944:	2988b03a 	or	r4,r5,r6
 8213948:	20009a1e 	bne	r4,zero,8213bb4 <__subdf3+0x2ec>
 821394c:	888001cc 	andi	r2,r17,7
 8213950:	10000726 	beq	r2,zero,8213970 <__subdf3+0xa8>
 8213954:	888003cc 	andi	r2,r17,15
 8213958:	01000104 	movi	r4,4
 821395c:	11000426 	beq	r2,r4,8213970 <__subdf3+0xa8>
 8213960:	890b883a 	add	r5,r17,r4
 8213964:	2c63803a 	cmpltu	r17,r5,r17
 8213968:	1c47883a 	add	r3,r3,r17
 821396c:	2823883a 	mov	r17,r5
 8213970:	1880202c 	andhi	r2,r3,128
 8213974:	10005926 	beq	r2,zero,8213adc <__subdf3+0x214>
 8213978:	84000044 	addi	r16,r16,1
 821397c:	0081ffc4 	movi	r2,2047
 8213980:	8080be26 	beq	r16,r2,8213c7c <__subdf3+0x3b4>
 8213984:	017fe034 	movhi	r5,65408
 8213988:	297fffc4 	addi	r5,r5,-1
 821398c:	1946703a 	and	r3,r3,r5
 8213990:	1804977a 	slli	r2,r3,29
 8213994:	1806927a 	slli	r3,r3,9
 8213998:	8822d0fa 	srli	r17,r17,3
 821399c:	8401ffcc 	andi	r16,r16,2047
 82139a0:	180ad33a 	srli	r5,r3,12
 82139a4:	9100004c 	andi	r4,r18,1
 82139a8:	1444b03a 	or	r2,r2,r17
 82139ac:	80c1ffcc 	andi	r3,r16,2047
 82139b0:	1820953a 	slli	r16,r3,20
 82139b4:	20c03fcc 	andi	r3,r4,255
 82139b8:	180897fa 	slli	r4,r3,31
 82139bc:	00c00434 	movhi	r3,16
 82139c0:	18ffffc4 	addi	r3,r3,-1
 82139c4:	28c6703a 	and	r3,r5,r3
 82139c8:	1c06b03a 	or	r3,r3,r16
 82139cc:	1906b03a 	or	r3,r3,r4
 82139d0:	dfc00417 	ldw	ra,16(sp)
 82139d4:	dcc00317 	ldw	r19,12(sp)
 82139d8:	dc800217 	ldw	r18,8(sp)
 82139dc:	dc400117 	ldw	r17,4(sp)
 82139e0:	dc000017 	ldw	r16,0(sp)
 82139e4:	dec00504 	addi	sp,sp,20
 82139e8:	f800283a 	ret
 82139ec:	0101ffc4 	movi	r4,2047
 82139f0:	813fd626 	beq	r16,r4,821394c <__subdf3+0x84>
 82139f4:	29402034 	orhi	r5,r5,128
 82139f8:	01000e04 	movi	r4,56
 82139fc:	2080a316 	blt	r4,r2,8213c8c <__subdf3+0x3c4>
 8213a00:	010007c4 	movi	r4,31
 8213a04:	2080c616 	blt	r4,r2,8213d20 <__subdf3+0x458>
 8213a08:	01000804 	movi	r4,32
 8213a0c:	2089c83a 	sub	r4,r4,r2
 8213a10:	2910983a 	sll	r8,r5,r4
 8213a14:	308ed83a 	srl	r7,r6,r2
 8213a18:	3108983a 	sll	r4,r6,r4
 8213a1c:	2884d83a 	srl	r2,r5,r2
 8213a20:	41ccb03a 	or	r6,r8,r7
 8213a24:	2008c03a 	cmpne	r4,r4,zero
 8213a28:	310cb03a 	or	r6,r6,r4
 8213a2c:	898dc83a 	sub	r6,r17,r6
 8213a30:	89a3803a 	cmpltu	r17,r17,r6
 8213a34:	1887c83a 	sub	r3,r3,r2
 8213a38:	1c47c83a 	sub	r3,r3,r17
 8213a3c:	3023883a 	mov	r17,r6
 8213a40:	1880202c 	andhi	r2,r3,128
 8213a44:	10002326 	beq	r2,zero,8213ad4 <__subdf3+0x20c>
 8213a48:	04c02034 	movhi	r19,128
 8213a4c:	9cffffc4 	addi	r19,r19,-1
 8213a50:	1ce6703a 	and	r19,r3,r19
 8213a54:	98007a26 	beq	r19,zero,8213c40 <__subdf3+0x378>
 8213a58:	9809883a 	mov	r4,r19
 8213a5c:	82143c80 	call	82143c8 <__clzsi2>
 8213a60:	113ffe04 	addi	r4,r2,-8
 8213a64:	00c007c4 	movi	r3,31
 8213a68:	19007b16 	blt	r3,r4,8213c58 <__subdf3+0x390>
 8213a6c:	00800804 	movi	r2,32
 8213a70:	1105c83a 	sub	r2,r2,r4
 8213a74:	8884d83a 	srl	r2,r17,r2
 8213a78:	9906983a 	sll	r3,r19,r4
 8213a7c:	8922983a 	sll	r17,r17,r4
 8213a80:	10c4b03a 	or	r2,r2,r3
 8213a84:	24007816 	blt	r4,r16,8213c68 <__subdf3+0x3a0>
 8213a88:	2421c83a 	sub	r16,r4,r16
 8213a8c:	80c00044 	addi	r3,r16,1
 8213a90:	010007c4 	movi	r4,31
 8213a94:	20c09516 	blt	r4,r3,8213cec <__subdf3+0x424>
 8213a98:	01400804 	movi	r5,32
 8213a9c:	28cbc83a 	sub	r5,r5,r3
 8213aa0:	88c8d83a 	srl	r4,r17,r3
 8213aa4:	8962983a 	sll	r17,r17,r5
 8213aa8:	114a983a 	sll	r5,r2,r5
 8213aac:	10c6d83a 	srl	r3,r2,r3
 8213ab0:	8804c03a 	cmpne	r2,r17,zero
 8213ab4:	290ab03a 	or	r5,r5,r4
 8213ab8:	28a2b03a 	or	r17,r5,r2
 8213abc:	0021883a 	mov	r16,zero
 8213ac0:	003fa206 	br	821394c <__subdf3+0x84>
 8213ac4:	2090b03a 	or	r8,r4,r2
 8213ac8:	40018e26 	beq	r8,zero,8214104 <__subdf3+0x83c>
 8213acc:	1007883a 	mov	r3,r2
 8213ad0:	2023883a 	mov	r17,r4
 8213ad4:	888001cc 	andi	r2,r17,7
 8213ad8:	103f9e1e 	bne	r2,zero,8213954 <__subdf3+0x8c>
 8213adc:	1804977a 	slli	r2,r3,29
 8213ae0:	8822d0fa 	srli	r17,r17,3
 8213ae4:	1810d0fa 	srli	r8,r3,3
 8213ae8:	9100004c 	andi	r4,r18,1
 8213aec:	1444b03a 	or	r2,r2,r17
 8213af0:	00c1ffc4 	movi	r3,2047
 8213af4:	80c02826 	beq	r16,r3,8213b98 <__subdf3+0x2d0>
 8213af8:	01400434 	movhi	r5,16
 8213afc:	297fffc4 	addi	r5,r5,-1
 8213b00:	80e0703a 	and	r16,r16,r3
 8213b04:	414a703a 	and	r5,r8,r5
 8213b08:	003fa806 	br	82139ac <__subdf3+0xe4>
 8213b0c:	0080630e 	bge	zero,r2,8213c9c <__subdf3+0x3d4>
 8213b10:	48003026 	beq	r9,zero,8213bd4 <__subdf3+0x30c>
 8213b14:	0101ffc4 	movi	r4,2047
 8213b18:	813f8c26 	beq	r16,r4,821394c <__subdf3+0x84>
 8213b1c:	29402034 	orhi	r5,r5,128
 8213b20:	01000e04 	movi	r4,56
 8213b24:	2080a90e 	bge	r4,r2,8213dcc <__subdf3+0x504>
 8213b28:	298cb03a 	or	r6,r5,r6
 8213b2c:	3012c03a 	cmpne	r9,r6,zero
 8213b30:	0005883a 	mov	r2,zero
 8213b34:	4c53883a 	add	r9,r9,r17
 8213b38:	4c63803a 	cmpltu	r17,r9,r17
 8213b3c:	10c7883a 	add	r3,r2,r3
 8213b40:	88c7883a 	add	r3,r17,r3
 8213b44:	4823883a 	mov	r17,r9
 8213b48:	1880202c 	andhi	r2,r3,128
 8213b4c:	1000d026 	beq	r2,zero,8213e90 <__subdf3+0x5c8>
 8213b50:	84000044 	addi	r16,r16,1
 8213b54:	0081ffc4 	movi	r2,2047
 8213b58:	8080fe26 	beq	r16,r2,8213f54 <__subdf3+0x68c>
 8213b5c:	00bfe034 	movhi	r2,65408
 8213b60:	10bfffc4 	addi	r2,r2,-1
 8213b64:	1886703a 	and	r3,r3,r2
 8213b68:	880ad07a 	srli	r5,r17,1
 8213b6c:	180497fa 	slli	r2,r3,31
 8213b70:	8900004c 	andi	r4,r17,1
 8213b74:	2922b03a 	or	r17,r5,r4
 8213b78:	1806d07a 	srli	r3,r3,1
 8213b7c:	1462b03a 	or	r17,r2,r17
 8213b80:	3825883a 	mov	r18,r7
 8213b84:	003f7106 	br	821394c <__subdf3+0x84>
 8213b88:	2984b03a 	or	r2,r5,r6
 8213b8c:	103f6826 	beq	r2,zero,8213930 <__subdf3+0x68>
 8213b90:	39c03fcc 	andi	r7,r7,255
 8213b94:	003f6706 	br	8213934 <__subdf3+0x6c>
 8213b98:	4086b03a 	or	r3,r8,r2
 8213b9c:	18015226 	beq	r3,zero,82140e8 <__subdf3+0x820>
 8213ba0:	00c00434 	movhi	r3,16
 8213ba4:	41400234 	orhi	r5,r8,8
 8213ba8:	18ffffc4 	addi	r3,r3,-1
 8213bac:	28ca703a 	and	r5,r5,r3
 8213bb0:	003f7e06 	br	82139ac <__subdf3+0xe4>
 8213bb4:	10bfffc4 	addi	r2,r2,-1
 8213bb8:	1000491e 	bne	r2,zero,8213ce0 <__subdf3+0x418>
 8213bbc:	898fc83a 	sub	r7,r17,r6
 8213bc0:	89e3803a 	cmpltu	r17,r17,r7
 8213bc4:	1947c83a 	sub	r3,r3,r5
 8213bc8:	1c47c83a 	sub	r3,r3,r17
 8213bcc:	3823883a 	mov	r17,r7
 8213bd0:	003f9b06 	br	8213a40 <__subdf3+0x178>
 8213bd4:	2988b03a 	or	r4,r5,r6
 8213bd8:	203f5c26 	beq	r4,zero,821394c <__subdf3+0x84>
 8213bdc:	10bfffc4 	addi	r2,r2,-1
 8213be0:	1000931e 	bne	r2,zero,8213e30 <__subdf3+0x568>
 8213be4:	898d883a 	add	r6,r17,r6
 8213be8:	3463803a 	cmpltu	r17,r6,r17
 8213bec:	1947883a 	add	r3,r3,r5
 8213bf0:	88c7883a 	add	r3,r17,r3
 8213bf4:	3023883a 	mov	r17,r6
 8213bf8:	003fd306 	br	8213b48 <__subdf3+0x280>
 8213bfc:	1000541e 	bne	r2,zero,8213d50 <__subdf3+0x488>
 8213c00:	80800044 	addi	r2,r16,1
 8213c04:	1081ffcc 	andi	r2,r2,2047
 8213c08:	01000044 	movi	r4,1
 8213c0c:	2080a20e 	bge	r4,r2,8213e98 <__subdf3+0x5d0>
 8213c10:	8989c83a 	sub	r4,r17,r6
 8213c14:	8905803a 	cmpltu	r2,r17,r4
 8213c18:	1967c83a 	sub	r19,r3,r5
 8213c1c:	98a7c83a 	sub	r19,r19,r2
 8213c20:	9880202c 	andhi	r2,r19,128
 8213c24:	10006326 	beq	r2,zero,8213db4 <__subdf3+0x4ec>
 8213c28:	3463c83a 	sub	r17,r6,r17
 8213c2c:	28c7c83a 	sub	r3,r5,r3
 8213c30:	344d803a 	cmpltu	r6,r6,r17
 8213c34:	19a7c83a 	sub	r19,r3,r6
 8213c38:	3825883a 	mov	r18,r7
 8213c3c:	983f861e 	bne	r19,zero,8213a58 <__subdf3+0x190>
 8213c40:	8809883a 	mov	r4,r17
 8213c44:	82143c80 	call	82143c8 <__clzsi2>
 8213c48:	10800804 	addi	r2,r2,32
 8213c4c:	113ffe04 	addi	r4,r2,-8
 8213c50:	00c007c4 	movi	r3,31
 8213c54:	193f850e 	bge	r3,r4,8213a6c <__subdf3+0x1a4>
 8213c58:	10bff604 	addi	r2,r2,-40
 8213c5c:	8884983a 	sll	r2,r17,r2
 8213c60:	0023883a 	mov	r17,zero
 8213c64:	243f880e 	bge	r4,r16,8213a88 <__subdf3+0x1c0>
 8213c68:	00ffe034 	movhi	r3,65408
 8213c6c:	18ffffc4 	addi	r3,r3,-1
 8213c70:	8121c83a 	sub	r16,r16,r4
 8213c74:	10c6703a 	and	r3,r2,r3
 8213c78:	003f3406 	br	821394c <__subdf3+0x84>
 8213c7c:	9100004c 	andi	r4,r18,1
 8213c80:	000b883a 	mov	r5,zero
 8213c84:	0005883a 	mov	r2,zero
 8213c88:	003f4806 	br	82139ac <__subdf3+0xe4>
 8213c8c:	298cb03a 	or	r6,r5,r6
 8213c90:	300cc03a 	cmpne	r6,r6,zero
 8213c94:	0005883a 	mov	r2,zero
 8213c98:	003f6406 	br	8213a2c <__subdf3+0x164>
 8213c9c:	10009a1e 	bne	r2,zero,8213f08 <__subdf3+0x640>
 8213ca0:	82400044 	addi	r9,r16,1
 8213ca4:	4881ffcc 	andi	r2,r9,2047
 8213ca8:	02800044 	movi	r10,1
 8213cac:	5080670e 	bge	r10,r2,8213e4c <__subdf3+0x584>
 8213cb0:	0081ffc4 	movi	r2,2047
 8213cb4:	4880af26 	beq	r9,r2,8213f74 <__subdf3+0x6ac>
 8213cb8:	898d883a 	add	r6,r17,r6
 8213cbc:	1945883a 	add	r2,r3,r5
 8213cc0:	3447803a 	cmpltu	r3,r6,r17
 8213cc4:	1887883a 	add	r3,r3,r2
 8213cc8:	182297fa 	slli	r17,r3,31
 8213ccc:	300cd07a 	srli	r6,r6,1
 8213cd0:	1806d07a 	srli	r3,r3,1
 8213cd4:	4821883a 	mov	r16,r9
 8213cd8:	89a2b03a 	or	r17,r17,r6
 8213cdc:	003f1b06 	br	821394c <__subdf3+0x84>
 8213ce0:	0101ffc4 	movi	r4,2047
 8213ce4:	813f441e 	bne	r16,r4,82139f8 <__subdf3+0x130>
 8213ce8:	003f1806 	br	821394c <__subdf3+0x84>
 8213cec:	843ff844 	addi	r16,r16,-31
 8213cf0:	01400804 	movi	r5,32
 8213cf4:	1408d83a 	srl	r4,r2,r16
 8213cf8:	19405026 	beq	r3,r5,8213e3c <__subdf3+0x574>
 8213cfc:	01401004 	movi	r5,64
 8213d00:	28c7c83a 	sub	r3,r5,r3
 8213d04:	10c4983a 	sll	r2,r2,r3
 8213d08:	88a2b03a 	or	r17,r17,r2
 8213d0c:	8822c03a 	cmpne	r17,r17,zero
 8213d10:	2462b03a 	or	r17,r4,r17
 8213d14:	0007883a 	mov	r3,zero
 8213d18:	0021883a 	mov	r16,zero
 8213d1c:	003f6d06 	br	8213ad4 <__subdf3+0x20c>
 8213d20:	11fff804 	addi	r7,r2,-32
 8213d24:	01000804 	movi	r4,32
 8213d28:	29ced83a 	srl	r7,r5,r7
 8213d2c:	11004526 	beq	r2,r4,8213e44 <__subdf3+0x57c>
 8213d30:	01001004 	movi	r4,64
 8213d34:	2089c83a 	sub	r4,r4,r2
 8213d38:	2904983a 	sll	r2,r5,r4
 8213d3c:	118cb03a 	or	r6,r2,r6
 8213d40:	300cc03a 	cmpne	r6,r6,zero
 8213d44:	398cb03a 	or	r6,r7,r6
 8213d48:	0005883a 	mov	r2,zero
 8213d4c:	003f3706 	br	8213a2c <__subdf3+0x164>
 8213d50:	80002a26 	beq	r16,zero,8213dfc <__subdf3+0x534>
 8213d54:	0101ffc4 	movi	r4,2047
 8213d58:	49006626 	beq	r9,r4,8213ef4 <__subdf3+0x62c>
 8213d5c:	0085c83a 	sub	r2,zero,r2
 8213d60:	18c02034 	orhi	r3,r3,128
 8213d64:	01000e04 	movi	r4,56
 8213d68:	20807e16 	blt	r4,r2,8213f64 <__subdf3+0x69c>
 8213d6c:	010007c4 	movi	r4,31
 8213d70:	2080e716 	blt	r4,r2,8214110 <__subdf3+0x848>
 8213d74:	01000804 	movi	r4,32
 8213d78:	2089c83a 	sub	r4,r4,r2
 8213d7c:	1914983a 	sll	r10,r3,r4
 8213d80:	8890d83a 	srl	r8,r17,r2
 8213d84:	8908983a 	sll	r4,r17,r4
 8213d88:	1884d83a 	srl	r2,r3,r2
 8213d8c:	5222b03a 	or	r17,r10,r8
 8213d90:	2006c03a 	cmpne	r3,r4,zero
 8213d94:	88e2b03a 	or	r17,r17,r3
 8213d98:	3463c83a 	sub	r17,r6,r17
 8213d9c:	2885c83a 	sub	r2,r5,r2
 8213da0:	344d803a 	cmpltu	r6,r6,r17
 8213da4:	1187c83a 	sub	r3,r2,r6
 8213da8:	4821883a 	mov	r16,r9
 8213dac:	3825883a 	mov	r18,r7
 8213db0:	003f2306 	br	8213a40 <__subdf3+0x178>
 8213db4:	24d0b03a 	or	r8,r4,r19
 8213db8:	40001b1e 	bne	r8,zero,8213e28 <__subdf3+0x560>
 8213dbc:	0005883a 	mov	r2,zero
 8213dc0:	0009883a 	mov	r4,zero
 8213dc4:	0021883a 	mov	r16,zero
 8213dc8:	003f4906 	br	8213af0 <__subdf3+0x228>
 8213dcc:	010007c4 	movi	r4,31
 8213dd0:	20803a16 	blt	r4,r2,8213ebc <__subdf3+0x5f4>
 8213dd4:	01000804 	movi	r4,32
 8213dd8:	2089c83a 	sub	r4,r4,r2
 8213ddc:	2912983a 	sll	r9,r5,r4
 8213de0:	3090d83a 	srl	r8,r6,r2
 8213de4:	3108983a 	sll	r4,r6,r4
 8213de8:	2884d83a 	srl	r2,r5,r2
 8213dec:	4a12b03a 	or	r9,r9,r8
 8213df0:	2008c03a 	cmpne	r4,r4,zero
 8213df4:	4912b03a 	or	r9,r9,r4
 8213df8:	003f4e06 	br	8213b34 <__subdf3+0x26c>
 8213dfc:	1c48b03a 	or	r4,r3,r17
 8213e00:	20003c26 	beq	r4,zero,8213ef4 <__subdf3+0x62c>
 8213e04:	0084303a 	nor	r2,zero,r2
 8213e08:	1000381e 	bne	r2,zero,8213eec <__subdf3+0x624>
 8213e0c:	3463c83a 	sub	r17,r6,r17
 8213e10:	28c5c83a 	sub	r2,r5,r3
 8213e14:	344d803a 	cmpltu	r6,r6,r17
 8213e18:	1187c83a 	sub	r3,r2,r6
 8213e1c:	4821883a 	mov	r16,r9
 8213e20:	3825883a 	mov	r18,r7
 8213e24:	003f0606 	br	8213a40 <__subdf3+0x178>
 8213e28:	2023883a 	mov	r17,r4
 8213e2c:	003f0906 	br	8213a54 <__subdf3+0x18c>
 8213e30:	0101ffc4 	movi	r4,2047
 8213e34:	813f3a1e 	bne	r16,r4,8213b20 <__subdf3+0x258>
 8213e38:	003ec406 	br	821394c <__subdf3+0x84>
 8213e3c:	0005883a 	mov	r2,zero
 8213e40:	003fb106 	br	8213d08 <__subdf3+0x440>
 8213e44:	0005883a 	mov	r2,zero
 8213e48:	003fbc06 	br	8213d3c <__subdf3+0x474>
 8213e4c:	1c44b03a 	or	r2,r3,r17
 8213e50:	80008e1e 	bne	r16,zero,821408c <__subdf3+0x7c4>
 8213e54:	1000c826 	beq	r2,zero,8214178 <__subdf3+0x8b0>
 8213e58:	2984b03a 	or	r2,r5,r6
 8213e5c:	103ebb26 	beq	r2,zero,821394c <__subdf3+0x84>
 8213e60:	8989883a 	add	r4,r17,r6
 8213e64:	1945883a 	add	r2,r3,r5
 8213e68:	2447803a 	cmpltu	r3,r4,r17
 8213e6c:	1887883a 	add	r3,r3,r2
 8213e70:	1880202c 	andhi	r2,r3,128
 8213e74:	2023883a 	mov	r17,r4
 8213e78:	103f1626 	beq	r2,zero,8213ad4 <__subdf3+0x20c>
 8213e7c:	00bfe034 	movhi	r2,65408
 8213e80:	10bfffc4 	addi	r2,r2,-1
 8213e84:	5021883a 	mov	r16,r10
 8213e88:	1886703a 	and	r3,r3,r2
 8213e8c:	003eaf06 	br	821394c <__subdf3+0x84>
 8213e90:	3825883a 	mov	r18,r7
 8213e94:	003f0f06 	br	8213ad4 <__subdf3+0x20c>
 8213e98:	1c44b03a 	or	r2,r3,r17
 8213e9c:	8000251e 	bne	r16,zero,8213f34 <__subdf3+0x66c>
 8213ea0:	1000661e 	bne	r2,zero,821403c <__subdf3+0x774>
 8213ea4:	2990b03a 	or	r8,r5,r6
 8213ea8:	40009626 	beq	r8,zero,8214104 <__subdf3+0x83c>
 8213eac:	2807883a 	mov	r3,r5
 8213eb0:	3023883a 	mov	r17,r6
 8213eb4:	3825883a 	mov	r18,r7
 8213eb8:	003ea406 	br	821394c <__subdf3+0x84>
 8213ebc:	127ff804 	addi	r9,r2,-32
 8213ec0:	01000804 	movi	r4,32
 8213ec4:	2a52d83a 	srl	r9,r5,r9
 8213ec8:	11008c26 	beq	r2,r4,82140fc <__subdf3+0x834>
 8213ecc:	01001004 	movi	r4,64
 8213ed0:	2085c83a 	sub	r2,r4,r2
 8213ed4:	2884983a 	sll	r2,r5,r2
 8213ed8:	118cb03a 	or	r6,r2,r6
 8213edc:	300cc03a 	cmpne	r6,r6,zero
 8213ee0:	4992b03a 	or	r9,r9,r6
 8213ee4:	0005883a 	mov	r2,zero
 8213ee8:	003f1206 	br	8213b34 <__subdf3+0x26c>
 8213eec:	0101ffc4 	movi	r4,2047
 8213ef0:	493f9c1e 	bne	r9,r4,8213d64 <__subdf3+0x49c>
 8213ef4:	2807883a 	mov	r3,r5
 8213ef8:	3023883a 	mov	r17,r6
 8213efc:	4821883a 	mov	r16,r9
 8213f00:	3825883a 	mov	r18,r7
 8213f04:	003e9106 	br	821394c <__subdf3+0x84>
 8213f08:	80001f1e 	bne	r16,zero,8213f88 <__subdf3+0x6c0>
 8213f0c:	1c48b03a 	or	r4,r3,r17
 8213f10:	20005a26 	beq	r4,zero,821407c <__subdf3+0x7b4>
 8213f14:	0084303a 	nor	r2,zero,r2
 8213f18:	1000561e 	bne	r2,zero,8214074 <__subdf3+0x7ac>
 8213f1c:	89a3883a 	add	r17,r17,r6
 8213f20:	1945883a 	add	r2,r3,r5
 8213f24:	898d803a 	cmpltu	r6,r17,r6
 8213f28:	3087883a 	add	r3,r6,r2
 8213f2c:	4821883a 	mov	r16,r9
 8213f30:	003f0506 	br	8213b48 <__subdf3+0x280>
 8213f34:	10002b1e 	bne	r2,zero,8213fe4 <__subdf3+0x71c>
 8213f38:	2984b03a 	or	r2,r5,r6
 8213f3c:	10008026 	beq	r2,zero,8214140 <__subdf3+0x878>
 8213f40:	2807883a 	mov	r3,r5
 8213f44:	3023883a 	mov	r17,r6
 8213f48:	3825883a 	mov	r18,r7
 8213f4c:	0401ffc4 	movi	r16,2047
 8213f50:	003e7e06 	br	821394c <__subdf3+0x84>
 8213f54:	3809883a 	mov	r4,r7
 8213f58:	0011883a 	mov	r8,zero
 8213f5c:	0005883a 	mov	r2,zero
 8213f60:	003ee306 	br	8213af0 <__subdf3+0x228>
 8213f64:	1c62b03a 	or	r17,r3,r17
 8213f68:	8822c03a 	cmpne	r17,r17,zero
 8213f6c:	0005883a 	mov	r2,zero
 8213f70:	003f8906 	br	8213d98 <__subdf3+0x4d0>
 8213f74:	3809883a 	mov	r4,r7
 8213f78:	4821883a 	mov	r16,r9
 8213f7c:	0011883a 	mov	r8,zero
 8213f80:	0005883a 	mov	r2,zero
 8213f84:	003eda06 	br	8213af0 <__subdf3+0x228>
 8213f88:	0101ffc4 	movi	r4,2047
 8213f8c:	49003b26 	beq	r9,r4,821407c <__subdf3+0x7b4>
 8213f90:	0085c83a 	sub	r2,zero,r2
 8213f94:	18c02034 	orhi	r3,r3,128
 8213f98:	01000e04 	movi	r4,56
 8213f9c:	20806e16 	blt	r4,r2,8214158 <__subdf3+0x890>
 8213fa0:	010007c4 	movi	r4,31
 8213fa4:	20807716 	blt	r4,r2,8214184 <__subdf3+0x8bc>
 8213fa8:	01000804 	movi	r4,32
 8213fac:	2089c83a 	sub	r4,r4,r2
 8213fb0:	1914983a 	sll	r10,r3,r4
 8213fb4:	8890d83a 	srl	r8,r17,r2
 8213fb8:	8908983a 	sll	r4,r17,r4
 8213fbc:	1884d83a 	srl	r2,r3,r2
 8213fc0:	5222b03a 	or	r17,r10,r8
 8213fc4:	2006c03a 	cmpne	r3,r4,zero
 8213fc8:	88e2b03a 	or	r17,r17,r3
 8213fcc:	89a3883a 	add	r17,r17,r6
 8213fd0:	1145883a 	add	r2,r2,r5
 8213fd4:	898d803a 	cmpltu	r6,r17,r6
 8213fd8:	3087883a 	add	r3,r6,r2
 8213fdc:	4821883a 	mov	r16,r9
 8213fe0:	003ed906 	br	8213b48 <__subdf3+0x280>
 8213fe4:	2984b03a 	or	r2,r5,r6
 8213fe8:	10004226 	beq	r2,zero,82140f4 <__subdf3+0x82c>
 8213fec:	1808d0fa 	srli	r4,r3,3
 8213ff0:	8822d0fa 	srli	r17,r17,3
 8213ff4:	1806977a 	slli	r3,r3,29
 8213ff8:	2080022c 	andhi	r2,r4,8
 8213ffc:	1c62b03a 	or	r17,r3,r17
 8214000:	10000826 	beq	r2,zero,8214024 <__subdf3+0x75c>
 8214004:	2812d0fa 	srli	r9,r5,3
 8214008:	4880022c 	andhi	r2,r9,8
 821400c:	1000051e 	bne	r2,zero,8214024 <__subdf3+0x75c>
 8214010:	300cd0fa 	srli	r6,r6,3
 8214014:	2804977a 	slli	r2,r5,29
 8214018:	4809883a 	mov	r4,r9
 821401c:	3825883a 	mov	r18,r7
 8214020:	11a2b03a 	or	r17,r2,r6
 8214024:	8806d77a 	srli	r3,r17,29
 8214028:	200890fa 	slli	r4,r4,3
 821402c:	882290fa 	slli	r17,r17,3
 8214030:	0401ffc4 	movi	r16,2047
 8214034:	1906b03a 	or	r3,r3,r4
 8214038:	003e4406 	br	821394c <__subdf3+0x84>
 821403c:	2984b03a 	or	r2,r5,r6
 8214040:	103e4226 	beq	r2,zero,821394c <__subdf3+0x84>
 8214044:	8989c83a 	sub	r4,r17,r6
 8214048:	8911803a 	cmpltu	r8,r17,r4
 821404c:	1945c83a 	sub	r2,r3,r5
 8214050:	1205c83a 	sub	r2,r2,r8
 8214054:	1200202c 	andhi	r8,r2,128
 8214058:	403e9a26 	beq	r8,zero,8213ac4 <__subdf3+0x1fc>
 821405c:	3463c83a 	sub	r17,r6,r17
 8214060:	28c5c83a 	sub	r2,r5,r3
 8214064:	344d803a 	cmpltu	r6,r6,r17
 8214068:	1187c83a 	sub	r3,r2,r6
 821406c:	3825883a 	mov	r18,r7
 8214070:	003e3606 	br	821394c <__subdf3+0x84>
 8214074:	0101ffc4 	movi	r4,2047
 8214078:	493fc71e 	bne	r9,r4,8213f98 <__subdf3+0x6d0>
 821407c:	2807883a 	mov	r3,r5
 8214080:	3023883a 	mov	r17,r6
 8214084:	4821883a 	mov	r16,r9
 8214088:	003e3006 	br	821394c <__subdf3+0x84>
 821408c:	10003626 	beq	r2,zero,8214168 <__subdf3+0x8a0>
 8214090:	2984b03a 	or	r2,r5,r6
 8214094:	10001726 	beq	r2,zero,82140f4 <__subdf3+0x82c>
 8214098:	1808d0fa 	srli	r4,r3,3
 821409c:	8822d0fa 	srli	r17,r17,3
 82140a0:	1806977a 	slli	r3,r3,29
 82140a4:	2080022c 	andhi	r2,r4,8
 82140a8:	1c62b03a 	or	r17,r3,r17
 82140ac:	10000726 	beq	r2,zero,82140cc <__subdf3+0x804>
 82140b0:	2812d0fa 	srli	r9,r5,3
 82140b4:	4880022c 	andhi	r2,r9,8
 82140b8:	1000041e 	bne	r2,zero,82140cc <__subdf3+0x804>
 82140bc:	300cd0fa 	srli	r6,r6,3
 82140c0:	2804977a 	slli	r2,r5,29
 82140c4:	4809883a 	mov	r4,r9
 82140c8:	11a2b03a 	or	r17,r2,r6
 82140cc:	8806d77a 	srli	r3,r17,29
 82140d0:	200890fa 	slli	r4,r4,3
 82140d4:	882290fa 	slli	r17,r17,3
 82140d8:	3825883a 	mov	r18,r7
 82140dc:	1906b03a 	or	r3,r3,r4
 82140e0:	0401ffc4 	movi	r16,2047
 82140e4:	003e1906 	br	821394c <__subdf3+0x84>
 82140e8:	000b883a 	mov	r5,zero
 82140ec:	0005883a 	mov	r2,zero
 82140f0:	003e2e06 	br	82139ac <__subdf3+0xe4>
 82140f4:	0401ffc4 	movi	r16,2047
 82140f8:	003e1406 	br	821394c <__subdf3+0x84>
 82140fc:	0005883a 	mov	r2,zero
 8214100:	003f7506 	br	8213ed8 <__subdf3+0x610>
 8214104:	0005883a 	mov	r2,zero
 8214108:	0009883a 	mov	r4,zero
 821410c:	003e7806 	br	8213af0 <__subdf3+0x228>
 8214110:	123ff804 	addi	r8,r2,-32
 8214114:	01000804 	movi	r4,32
 8214118:	1a10d83a 	srl	r8,r3,r8
 821411c:	11002526 	beq	r2,r4,82141b4 <__subdf3+0x8ec>
 8214120:	01001004 	movi	r4,64
 8214124:	2085c83a 	sub	r2,r4,r2
 8214128:	1884983a 	sll	r2,r3,r2
 821412c:	1444b03a 	or	r2,r2,r17
 8214130:	1004c03a 	cmpne	r2,r2,zero
 8214134:	40a2b03a 	or	r17,r8,r2
 8214138:	0005883a 	mov	r2,zero
 821413c:	003f1606 	br	8213d98 <__subdf3+0x4d0>
 8214140:	02000434 	movhi	r8,16
 8214144:	0009883a 	mov	r4,zero
 8214148:	423fffc4 	addi	r8,r8,-1
 821414c:	00bfffc4 	movi	r2,-1
 8214150:	0401ffc4 	movi	r16,2047
 8214154:	003e6606 	br	8213af0 <__subdf3+0x228>
 8214158:	1c62b03a 	or	r17,r3,r17
 821415c:	8822c03a 	cmpne	r17,r17,zero
 8214160:	0005883a 	mov	r2,zero
 8214164:	003f9906 	br	8213fcc <__subdf3+0x704>
 8214168:	2807883a 	mov	r3,r5
 821416c:	3023883a 	mov	r17,r6
 8214170:	0401ffc4 	movi	r16,2047
 8214174:	003df506 	br	821394c <__subdf3+0x84>
 8214178:	2807883a 	mov	r3,r5
 821417c:	3023883a 	mov	r17,r6
 8214180:	003df206 	br	821394c <__subdf3+0x84>
 8214184:	123ff804 	addi	r8,r2,-32
 8214188:	01000804 	movi	r4,32
 821418c:	1a10d83a 	srl	r8,r3,r8
 8214190:	11000a26 	beq	r2,r4,82141bc <__subdf3+0x8f4>
 8214194:	01001004 	movi	r4,64
 8214198:	2085c83a 	sub	r2,r4,r2
 821419c:	1884983a 	sll	r2,r3,r2
 82141a0:	1444b03a 	or	r2,r2,r17
 82141a4:	1004c03a 	cmpne	r2,r2,zero
 82141a8:	40a2b03a 	or	r17,r8,r2
 82141ac:	0005883a 	mov	r2,zero
 82141b0:	003f8606 	br	8213fcc <__subdf3+0x704>
 82141b4:	0005883a 	mov	r2,zero
 82141b8:	003fdc06 	br	821412c <__subdf3+0x864>
 82141bc:	0005883a 	mov	r2,zero
 82141c0:	003ff706 	br	82141a0 <__subdf3+0x8d8>

082141c4 <__fixdfsi>:
 82141c4:	280cd53a 	srli	r6,r5,20
 82141c8:	00c00434 	movhi	r3,16
 82141cc:	18ffffc4 	addi	r3,r3,-1
 82141d0:	3181ffcc 	andi	r6,r6,2047
 82141d4:	01c0ff84 	movi	r7,1022
 82141d8:	28c6703a 	and	r3,r5,r3
 82141dc:	280ad7fa 	srli	r5,r5,31
 82141e0:	3980120e 	bge	r7,r6,821422c <__fixdfsi+0x68>
 82141e4:	00810744 	movi	r2,1053
 82141e8:	11800c16 	blt	r2,r6,821421c <__fixdfsi+0x58>
 82141ec:	00810cc4 	movi	r2,1075
 82141f0:	1185c83a 	sub	r2,r2,r6
 82141f4:	01c007c4 	movi	r7,31
 82141f8:	18c00434 	orhi	r3,r3,16
 82141fc:	38800d16 	blt	r7,r2,8214234 <__fixdfsi+0x70>
 8214200:	31befb44 	addi	r6,r6,-1043
 8214204:	2084d83a 	srl	r2,r4,r2
 8214208:	1986983a 	sll	r3,r3,r6
 821420c:	1884b03a 	or	r2,r3,r2
 8214210:	28000726 	beq	r5,zero,8214230 <__fixdfsi+0x6c>
 8214214:	0085c83a 	sub	r2,zero,r2
 8214218:	f800283a 	ret
 821421c:	00a00034 	movhi	r2,32768
 8214220:	10bfffc4 	addi	r2,r2,-1
 8214224:	2885883a 	add	r2,r5,r2
 8214228:	f800283a 	ret
 821422c:	0005883a 	mov	r2,zero
 8214230:	f800283a 	ret
 8214234:	008104c4 	movi	r2,1043
 8214238:	1185c83a 	sub	r2,r2,r6
 821423c:	1884d83a 	srl	r2,r3,r2
 8214240:	003ff306 	br	8214210 <__fixdfsi+0x4c>

08214244 <__floatsidf>:
 8214244:	defffd04 	addi	sp,sp,-12
 8214248:	dfc00215 	stw	ra,8(sp)
 821424c:	dc400115 	stw	r17,4(sp)
 8214250:	dc000015 	stw	r16,0(sp)
 8214254:	20002b26 	beq	r4,zero,8214304 <__floatsidf+0xc0>
 8214258:	2023883a 	mov	r17,r4
 821425c:	2020d7fa 	srli	r16,r4,31
 8214260:	20002d16 	blt	r4,zero,8214318 <__floatsidf+0xd4>
 8214264:	8809883a 	mov	r4,r17
 8214268:	82143c80 	call	82143c8 <__clzsi2>
 821426c:	01410784 	movi	r5,1054
 8214270:	288bc83a 	sub	r5,r5,r2
 8214274:	01010cc4 	movi	r4,1075
 8214278:	2149c83a 	sub	r4,r4,r5
 821427c:	00c007c4 	movi	r3,31
 8214280:	1900160e 	bge	r3,r4,82142dc <__floatsidf+0x98>
 8214284:	00c104c4 	movi	r3,1043
 8214288:	1947c83a 	sub	r3,r3,r5
 821428c:	88c6983a 	sll	r3,r17,r3
 8214290:	00800434 	movhi	r2,16
 8214294:	10bfffc4 	addi	r2,r2,-1
 8214298:	1886703a 	and	r3,r3,r2
 821429c:	2941ffcc 	andi	r5,r5,2047
 82142a0:	800d883a 	mov	r6,r16
 82142a4:	0005883a 	mov	r2,zero
 82142a8:	280a953a 	slli	r5,r5,20
 82142ac:	31803fcc 	andi	r6,r6,255
 82142b0:	01000434 	movhi	r4,16
 82142b4:	300c97fa 	slli	r6,r6,31
 82142b8:	213fffc4 	addi	r4,r4,-1
 82142bc:	1906703a 	and	r3,r3,r4
 82142c0:	1946b03a 	or	r3,r3,r5
 82142c4:	1986b03a 	or	r3,r3,r6
 82142c8:	dfc00217 	ldw	ra,8(sp)
 82142cc:	dc400117 	ldw	r17,4(sp)
 82142d0:	dc000017 	ldw	r16,0(sp)
 82142d4:	dec00304 	addi	sp,sp,12
 82142d8:	f800283a 	ret
 82142dc:	00c002c4 	movi	r3,11
 82142e0:	1887c83a 	sub	r3,r3,r2
 82142e4:	88c6d83a 	srl	r3,r17,r3
 82142e8:	8904983a 	sll	r2,r17,r4
 82142ec:	01000434 	movhi	r4,16
 82142f0:	213fffc4 	addi	r4,r4,-1
 82142f4:	2941ffcc 	andi	r5,r5,2047
 82142f8:	1906703a 	and	r3,r3,r4
 82142fc:	800d883a 	mov	r6,r16
 8214300:	003fe906 	br	82142a8 <__floatsidf+0x64>
 8214304:	000d883a 	mov	r6,zero
 8214308:	000b883a 	mov	r5,zero
 821430c:	0007883a 	mov	r3,zero
 8214310:	0005883a 	mov	r2,zero
 8214314:	003fe406 	br	82142a8 <__floatsidf+0x64>
 8214318:	0123c83a 	sub	r17,zero,r4
 821431c:	003fd106 	br	8214264 <__floatsidf+0x20>

08214320 <__floatunsidf>:
 8214320:	defffe04 	addi	sp,sp,-8
 8214324:	dc000015 	stw	r16,0(sp)
 8214328:	dfc00115 	stw	ra,4(sp)
 821432c:	2021883a 	mov	r16,r4
 8214330:	20002226 	beq	r4,zero,82143bc <__floatunsidf+0x9c>
 8214334:	82143c80 	call	82143c8 <__clzsi2>
 8214338:	01010784 	movi	r4,1054
 821433c:	2089c83a 	sub	r4,r4,r2
 8214340:	01810cc4 	movi	r6,1075
 8214344:	310dc83a 	sub	r6,r6,r4
 8214348:	00c007c4 	movi	r3,31
 821434c:	1980120e 	bge	r3,r6,8214398 <__floatunsidf+0x78>
 8214350:	00c104c4 	movi	r3,1043
 8214354:	1907c83a 	sub	r3,r3,r4
 8214358:	80ca983a 	sll	r5,r16,r3
 821435c:	00800434 	movhi	r2,16
 8214360:	10bfffc4 	addi	r2,r2,-1
 8214364:	2101ffcc 	andi	r4,r4,2047
 8214368:	0021883a 	mov	r16,zero
 821436c:	288a703a 	and	r5,r5,r2
 8214370:	2008953a 	slli	r4,r4,20
 8214374:	00c00434 	movhi	r3,16
 8214378:	18ffffc4 	addi	r3,r3,-1
 821437c:	28c6703a 	and	r3,r5,r3
 8214380:	8005883a 	mov	r2,r16
 8214384:	1906b03a 	or	r3,r3,r4
 8214388:	dfc00117 	ldw	ra,4(sp)
 821438c:	dc000017 	ldw	r16,0(sp)
 8214390:	dec00204 	addi	sp,sp,8
 8214394:	f800283a 	ret
 8214398:	00c002c4 	movi	r3,11
 821439c:	188bc83a 	sub	r5,r3,r2
 82143a0:	814ad83a 	srl	r5,r16,r5
 82143a4:	00c00434 	movhi	r3,16
 82143a8:	18ffffc4 	addi	r3,r3,-1
 82143ac:	81a0983a 	sll	r16,r16,r6
 82143b0:	2101ffcc 	andi	r4,r4,2047
 82143b4:	28ca703a 	and	r5,r5,r3
 82143b8:	003fed06 	br	8214370 <__floatunsidf+0x50>
 82143bc:	0009883a 	mov	r4,zero
 82143c0:	000b883a 	mov	r5,zero
 82143c4:	003fea06 	br	8214370 <__floatunsidf+0x50>

082143c8 <__clzsi2>:
 82143c8:	00bfffd4 	movui	r2,65535
 82143cc:	11000536 	bltu	r2,r4,82143e4 <__clzsi2+0x1c>
 82143d0:	00803fc4 	movi	r2,255
 82143d4:	11000f36 	bltu	r2,r4,8214414 <__clzsi2+0x4c>
 82143d8:	00800804 	movi	r2,32
 82143dc:	0007883a 	mov	r3,zero
 82143e0:	00000506 	br	82143f8 <__clzsi2+0x30>
 82143e4:	00804034 	movhi	r2,256
 82143e8:	10bfffc4 	addi	r2,r2,-1
 82143ec:	11000c2e 	bgeu	r2,r4,8214420 <__clzsi2+0x58>
 82143f0:	00800204 	movi	r2,8
 82143f4:	00c00604 	movi	r3,24
 82143f8:	20c8d83a 	srl	r4,r4,r3
 82143fc:	00c20974 	movhi	r3,2085
 8214400:	18f75d04 	addi	r3,r3,-8844
 8214404:	1909883a 	add	r4,r3,r4
 8214408:	20c00003 	ldbu	r3,0(r4)
 821440c:	10c5c83a 	sub	r2,r2,r3
 8214410:	f800283a 	ret
 8214414:	00800604 	movi	r2,24
 8214418:	00c00204 	movi	r3,8
 821441c:	003ff606 	br	82143f8 <__clzsi2+0x30>
 8214420:	00800404 	movi	r2,16
 8214424:	1007883a 	mov	r3,r2
 8214428:	003ff306 	br	82143f8 <__clzsi2+0x30>

0821442c <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
 821442c:	defffc04 	addi	sp,sp,-16
 8214430:	dfc00315 	stw	ra,12(sp)
 8214434:	df000215 	stw	fp,8(sp)
 8214438:	df000204 	addi	fp,sp,8
 821443c:	e13fff15 	stw	r4,-4(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
 8214440:	d1600704 	addi	r5,gp,-32740
 8214444:	e13fff17 	ldw	r4,-4(fp)
 8214448:	823bfac0 	call	823bfac <alt_find_dev>
 821444c:	e0bffe15 	stw	r2,-8(fp)

  if ((dev) && dev->open)
 8214450:	e0bffe17 	ldw	r2,-8(fp)
 8214454:	10000926 	beq	r2,zero,821447c <alt_flash_open_dev+0x50>
 8214458:	e0bffe17 	ldw	r2,-8(fp)
 821445c:	10800317 	ldw	r2,12(r2)
 8214460:	10000626 	beq	r2,zero,821447c <alt_flash_open_dev+0x50>
  {
    return dev->open(dev, name);
 8214464:	e0bffe17 	ldw	r2,-8(fp)
 8214468:	10800317 	ldw	r2,12(r2)
 821446c:	e17fff17 	ldw	r5,-4(fp)
 8214470:	e13ffe17 	ldw	r4,-8(fp)
 8214474:	103ee83a 	callr	r2
 8214478:	00000106 	br	8214480 <alt_flash_open_dev+0x54>
  }

  return dev;
 821447c:	e0bffe17 	ldw	r2,-8(fp)
}
 8214480:	e037883a 	mov	sp,fp
 8214484:	dfc00117 	ldw	ra,4(sp)
 8214488:	df000017 	ldw	fp,0(sp)
 821448c:	dec00204 	addi	sp,sp,8
 8214490:	f800283a 	ret

08214494 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
 8214494:	defffd04 	addi	sp,sp,-12
 8214498:	dfc00215 	stw	ra,8(sp)
 821449c:	df000115 	stw	fp,4(sp)
 82144a0:	df000104 	addi	fp,sp,4
 82144a4:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
 82144a8:	e0bfff17 	ldw	r2,-4(fp)
 82144ac:	10000826 	beq	r2,zero,82144d0 <alt_flash_close_dev+0x3c>
 82144b0:	e0bfff17 	ldw	r2,-4(fp)
 82144b4:	10800417 	ldw	r2,16(r2)
 82144b8:	10000526 	beq	r2,zero,82144d0 <alt_flash_close_dev+0x3c>
  {
    fd->close(fd);
 82144bc:	e0bfff17 	ldw	r2,-4(fp)
 82144c0:	10800417 	ldw	r2,16(r2)
 82144c4:	e13fff17 	ldw	r4,-4(fp)
 82144c8:	103ee83a 	callr	r2
  }
  return;
 82144cc:	0001883a 	nop
 82144d0:	0001883a 	nop
}
 82144d4:	e037883a 	mov	sp,fp
 82144d8:	dfc00117 	ldw	ra,4(sp)
 82144dc:	df000017 	ldw	fp,0(sp)
 82144e0:	dec00204 	addi	sp,sp,8
 82144e4:	f800283a 	ret

082144e8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 82144e8:	defffe04 	addi	sp,sp,-8
 82144ec:	dfc00115 	stw	ra,4(sp)
 82144f0:	df000015 	stw	fp,0(sp)
 82144f4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 82144f8:	d0a04717 	ldw	r2,-32484(gp)
 82144fc:	10000326 	beq	r2,zero,821450c <alt_get_errno+0x24>
 8214500:	d0a04717 	ldw	r2,-32484(gp)
 8214504:	103ee83a 	callr	r2
 8214508:	00000106 	br	8214510 <alt_get_errno+0x28>
 821450c:	d0a06304 	addi	r2,gp,-32372
}
 8214510:	e037883a 	mov	sp,fp
 8214514:	dfc00117 	ldw	ra,4(sp)
 8214518:	df000017 	ldw	fp,0(sp)
 821451c:	dec00204 	addi	sp,sp,8
 8214520:	f800283a 	ret

08214524 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 8214524:	defffb04 	addi	sp,sp,-20
 8214528:	dfc00415 	stw	ra,16(sp)
 821452c:	df000315 	stw	fp,12(sp)
 8214530:	df000304 	addi	fp,sp,12
 8214534:	e13ffe15 	stw	r4,-8(fp)
 8214538:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 821453c:	e0bffe17 	ldw	r2,-8(fp)
 8214540:	10000616 	blt	r2,zero,821455c <fstat+0x38>
 8214544:	e0bffe17 	ldw	r2,-8(fp)
 8214548:	10c00324 	muli	r3,r2,12
 821454c:	00820974 	movhi	r2,2085
 8214550:	108ef504 	addi	r2,r2,15316
 8214554:	1885883a 	add	r2,r3,r2
 8214558:	00000106 	br	8214560 <fstat+0x3c>
 821455c:	0005883a 	mov	r2,zero
 8214560:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
 8214564:	e0bffd17 	ldw	r2,-12(fp)
 8214568:	10001026 	beq	r2,zero,82145ac <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 821456c:	e0bffd17 	ldw	r2,-12(fp)
 8214570:	10800017 	ldw	r2,0(r2)
 8214574:	10800817 	ldw	r2,32(r2)
 8214578:	10000726 	beq	r2,zero,8214598 <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
 821457c:	e0bffd17 	ldw	r2,-12(fp)
 8214580:	10800017 	ldw	r2,0(r2)
 8214584:	10800817 	ldw	r2,32(r2)
 8214588:	e17fff17 	ldw	r5,-4(fp)
 821458c:	e13ffd17 	ldw	r4,-12(fp)
 8214590:	103ee83a 	callr	r2
 8214594:	00000a06 	br	82145c0 <fstat+0x9c>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 8214598:	e0bfff17 	ldw	r2,-4(fp)
 821459c:	00c80004 	movi	r3,8192
 82145a0:	10c00115 	stw	r3,4(r2)
      return 0;
 82145a4:	0005883a 	mov	r2,zero
 82145a8:	00000506 	br	82145c0 <fstat+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 82145ac:	82144e80 	call	82144e8 <alt_get_errno>
 82145b0:	1007883a 	mov	r3,r2
 82145b4:	00801444 	movi	r2,81
 82145b8:	18800015 	stw	r2,0(r3)
    return -1;
 82145bc:	00bfffc4 	movi	r2,-1
  }
}
 82145c0:	e037883a 	mov	sp,fp
 82145c4:	dfc00117 	ldw	ra,4(sp)
 82145c8:	df000017 	ldw	fp,0(sp)
 82145cc:	dec00204 	addi	sp,sp,8
 82145d0:	f800283a 	ret

082145d4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 82145d4:	defffe04 	addi	sp,sp,-8
 82145d8:	dfc00115 	stw	ra,4(sp)
 82145dc:	df000015 	stw	fp,0(sp)
 82145e0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 82145e4:	d0a04717 	ldw	r2,-32484(gp)
 82145e8:	10000326 	beq	r2,zero,82145f8 <alt_get_errno+0x24>
 82145ec:	d0a04717 	ldw	r2,-32484(gp)
 82145f0:	103ee83a 	callr	r2
 82145f4:	00000106 	br	82145fc <alt_get_errno+0x28>
 82145f8:	d0a06304 	addi	r2,gp,-32372
}
 82145fc:	e037883a 	mov	sp,fp
 8214600:	dfc00117 	ldw	ra,4(sp)
 8214604:	df000017 	ldw	fp,0(sp)
 8214608:	dec00204 	addi	sp,sp,8
 821460c:	f800283a 	ret

08214610 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 8214610:	deffed04 	addi	sp,sp,-76
 8214614:	dfc01215 	stw	ra,72(sp)
 8214618:	df001115 	stw	fp,68(sp)
 821461c:	df001104 	addi	fp,sp,68
 8214620:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 8214624:	e0bfff17 	ldw	r2,-4(fp)
 8214628:	10000616 	blt	r2,zero,8214644 <isatty+0x34>
 821462c:	e0bfff17 	ldw	r2,-4(fp)
 8214630:	10c00324 	muli	r3,r2,12
 8214634:	00820974 	movhi	r2,2085
 8214638:	108ef504 	addi	r2,r2,15316
 821463c:	1885883a 	add	r2,r3,r2
 8214640:	00000106 	br	8214648 <isatty+0x38>
 8214644:	0005883a 	mov	r2,zero
 8214648:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
 821464c:	e0bfef17 	ldw	r2,-68(fp)
 8214650:	10000e26 	beq	r2,zero,821468c <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 8214654:	e0bfef17 	ldw	r2,-68(fp)
 8214658:	10800017 	ldw	r2,0(r2)
 821465c:	10800817 	ldw	r2,32(r2)
 8214660:	1000021e 	bne	r2,zero,821466c <isatty+0x5c>
    {
      return 1;
 8214664:	00800044 	movi	r2,1
 8214668:	00000d06 	br	82146a0 <isatty+0x90>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 821466c:	e0bff004 	addi	r2,fp,-64
 8214670:	100b883a 	mov	r5,r2
 8214674:	e13fff17 	ldw	r4,-4(fp)
 8214678:	82145240 	call	8214524 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 821467c:	e0bff117 	ldw	r2,-60(fp)
 8214680:	10880020 	cmpeqi	r2,r2,8192
 8214684:	10803fcc 	andi	r2,r2,255
 8214688:	00000506 	br	82146a0 <isatty+0x90>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 821468c:	82145d40 	call	82145d4 <alt_get_errno>
 8214690:	1007883a 	mov	r3,r2
 8214694:	00801444 	movi	r2,81
 8214698:	18800015 	stw	r2,0(r3)
    return 0;
 821469c:	0005883a 	mov	r2,zero
  }
}
 82146a0:	e037883a 	mov	sp,fp
 82146a4:	dfc00117 	ldw	ra,4(sp)
 82146a8:	df000017 	ldw	fp,0(sp)
 82146ac:	dec00204 	addi	sp,sp,8
 82146b0:	f800283a 	ret

082146b4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 82146b4:	defffe04 	addi	sp,sp,-8
 82146b8:	dfc00115 	stw	ra,4(sp)
 82146bc:	df000015 	stw	fp,0(sp)
 82146c0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 82146c4:	d0a04717 	ldw	r2,-32484(gp)
 82146c8:	10000326 	beq	r2,zero,82146d8 <alt_get_errno+0x24>
 82146cc:	d0a04717 	ldw	r2,-32484(gp)
 82146d0:	103ee83a 	callr	r2
 82146d4:	00000106 	br	82146dc <alt_get_errno+0x28>
 82146d8:	d0a06304 	addi	r2,gp,-32372
}
 82146dc:	e037883a 	mov	sp,fp
 82146e0:	dfc00117 	ldw	ra,4(sp)
 82146e4:	df000017 	ldw	fp,0(sp)
 82146e8:	dec00204 	addi	sp,sp,8
 82146ec:	f800283a 	ret

082146f0 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 82146f0:	defff904 	addi	sp,sp,-28
 82146f4:	dfc00615 	stw	ra,24(sp)
 82146f8:	df000515 	stw	fp,20(sp)
 82146fc:	df000504 	addi	fp,sp,20
 8214700:	e13ffd15 	stw	r4,-12(fp)
 8214704:	e17ffe15 	stw	r5,-8(fp)
 8214708:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 821470c:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 8214710:	e0bffd17 	ldw	r2,-12(fp)
 8214714:	10000616 	blt	r2,zero,8214730 <lseek+0x40>
 8214718:	e0bffd17 	ldw	r2,-12(fp)
 821471c:	10c00324 	muli	r3,r2,12
 8214720:	00820974 	movhi	r2,2085
 8214724:	108ef504 	addi	r2,r2,15316
 8214728:	1885883a 	add	r2,r3,r2
 821472c:	00000106 	br	8214734 <lseek+0x44>
 8214730:	0005883a 	mov	r2,zero
 8214734:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
 8214738:	e0bffc17 	ldw	r2,-16(fp)
 821473c:	10001026 	beq	r2,zero,8214780 <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 8214740:	e0bffc17 	ldw	r2,-16(fp)
 8214744:	10800017 	ldw	r2,0(r2)
 8214748:	10800717 	ldw	r2,28(r2)
 821474c:	10000926 	beq	r2,zero,8214774 <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 8214750:	e0bffc17 	ldw	r2,-16(fp)
 8214754:	10800017 	ldw	r2,0(r2)
 8214758:	10800717 	ldw	r2,28(r2)
 821475c:	e1bfff17 	ldw	r6,-4(fp)
 8214760:	e17ffe17 	ldw	r5,-8(fp)
 8214764:	e13ffc17 	ldw	r4,-16(fp)
 8214768:	103ee83a 	callr	r2
 821476c:	e0bffb15 	stw	r2,-20(fp)
 8214770:	00000506 	br	8214788 <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 8214774:	00bfde84 	movi	r2,-134
 8214778:	e0bffb15 	stw	r2,-20(fp)
 821477c:	00000206 	br	8214788 <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
 8214780:	00bfebc4 	movi	r2,-81
 8214784:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
 8214788:	e0bffb17 	ldw	r2,-20(fp)
 821478c:	1000070e 	bge	r2,zero,82147ac <lseek+0xbc>
  {
    ALT_ERRNO = -rc;
 8214790:	82146b40 	call	82146b4 <alt_get_errno>
 8214794:	1007883a 	mov	r3,r2
 8214798:	e0bffb17 	ldw	r2,-20(fp)
 821479c:	0085c83a 	sub	r2,zero,r2
 82147a0:	18800015 	stw	r2,0(r3)
    rc = -1;
 82147a4:	00bfffc4 	movi	r2,-1
 82147a8:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
 82147ac:	e0bffb17 	ldw	r2,-20(fp)
}
 82147b0:	e037883a 	mov	sp,fp
 82147b4:	dfc00117 	ldw	ra,4(sp)
 82147b8:	df000017 	ldw	fp,0(sp)
 82147bc:	dec00204 	addi	sp,sp,8
 82147c0:	f800283a 	ret

082147c4 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 82147c4:	defff904 	addi	sp,sp,-28
 82147c8:	dfc00615 	stw	ra,24(sp)
 82147cc:	df000515 	stw	fp,20(sp)
 82147d0:	df000504 	addi	fp,sp,20
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 82147d4:	0009883a 	mov	r4,zero
 82147d8:	821c45c0 	call	821c45c <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 82147dc:	82154b00 	call	82154b0 <OSInit>
 82147e0:	01000044 	movi	r4,1
 82147e4:	8219e180 	call	8219e18 <OSSemCreate>
 82147e8:	d0a06815 	stw	r2,-32352(gp)
 82147ec:	01000044 	movi	r4,1
 82147f0:	8219e180 	call	8219e18 <OSSemCreate>
 82147f4:	d0a06a15 	stw	r2,-32344(gp)
 82147f8:	d0a0b604 	addi	r2,gp,-32040
 82147fc:	e0bffc15 	stw	r2,-16(fp)
 8214800:	00800044 	movi	r2,1
 8214804:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 8214808:	e0bffd0b 	ldhu	r2,-12(fp)
 821480c:	1009883a 	mov	r4,r2
 8214810:	8219e180 	call	8219e18 <OSSemCreate>
 8214814:	1007883a 	mov	r3,r2
 8214818:	e0bffc17 	ldw	r2,-16(fp)
 821481c:	10c00015 	stw	r3,0(r2)
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 8214820:	821c4940 	call	821c494 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 8214824:	01820974 	movhi	r6,2085
 8214828:	31b79d04 	addi	r6,r6,-8588
 821482c:	01420974 	movhi	r5,2085
 8214830:	29779d04 	addi	r5,r5,-8588
 8214834:	01020974 	movhi	r4,2085
 8214838:	21379d04 	addi	r4,r4,-8588
 821483c:	823c3a00 	call	823c3a0 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 8214840:	823beec0 	call	823beec <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 8214844:	01020934 	movhi	r4,2084
 8214848:	212fd304 	addi	r4,r4,-16564
 821484c:	824b6880 	call	824b688 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 8214850:	d0a06417 	ldw	r2,-32368(gp)
 8214854:	d0e06517 	ldw	r3,-32364(gp)
 8214858:	d1206617 	ldw	r4,-32360(gp)
 821485c:	200d883a 	mov	r6,r4
 8214860:	180b883a 	mov	r5,r3
 8214864:	1009883a 	mov	r4,r2
 8214868:	8200d180 	call	8200d18 <main>
 821486c:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
 8214870:	01000044 	movi	r4,1
 8214874:	82258940 	call	8225894 <close>
  exit (result);
 8214878:	e13ffb17 	ldw	r4,-20(fp)
 821487c:	824b6b40 	call	824b6b4 <exit>

08214880 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 8214880:	defff904 	addi	sp,sp,-28
 8214884:	df000615 	stw	fp,24(sp)
 8214888:	df000604 	addi	fp,sp,24
 821488c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214890:	0005303a 	rdctl	r2,status
 8214894:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8214898:	e0fffe17 	ldw	r3,-8(fp)
 821489c:	00bfff84 	movi	r2,-2
 82148a0:	1884703a 	and	r2,r3,r2
 82148a4:	1001703a 	wrctl	status,r2
  
  return context;
 82148a8:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 82148ac:	e0bffb15 	stw	r2,-20(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 82148b0:	d0a00917 	ldw	r2,-32732(gp)
 82148b4:	10c000c4 	addi	r3,r2,3
 82148b8:	00bfff04 	movi	r2,-4
 82148bc:	1884703a 	and	r2,r3,r2
 82148c0:	d0a00915 	stw	r2,-32732(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 82148c4:	d0e00917 	ldw	r3,-32732(gp)
 82148c8:	e0bfff17 	ldw	r2,-4(fp)
 82148cc:	1887883a 	add	r3,r3,r2
 82148d0:	00820e34 	movhi	r2,2104
 82148d4:	10800004 	addi	r2,r2,0
 82148d8:	10c0062e 	bgeu	r2,r3,82148f4 <sbrk+0x74>
 82148dc:	e0bffb17 	ldw	r2,-20(fp)
 82148e0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82148e4:	e0bffa17 	ldw	r2,-24(fp)
 82148e8:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 82148ec:	00bfffc4 	movi	r2,-1
 82148f0:	00000b06 	br	8214920 <sbrk+0xa0>
  }
#endif

  prev_heap_end = heap_end; 
 82148f4:	d0a00917 	ldw	r2,-32732(gp)
 82148f8:	e0bffd15 	stw	r2,-12(fp)
  heap_end += incr; 
 82148fc:	d0e00917 	ldw	r3,-32732(gp)
 8214900:	e0bfff17 	ldw	r2,-4(fp)
 8214904:	1885883a 	add	r2,r3,r2
 8214908:	d0a00915 	stw	r2,-32732(gp)
 821490c:	e0bffb17 	ldw	r2,-20(fp)
 8214910:	e0bffc15 	stw	r2,-16(fp)
 8214914:	e0bffc17 	ldw	r2,-16(fp)
 8214918:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 821491c:	e0bffd17 	ldw	r2,-12(fp)
} 
 8214920:	e037883a 	mov	sp,fp
 8214924:	df000017 	ldw	fp,0(sp)
 8214928:	dec00104 	addi	sp,sp,4
 821492c:	f800283a 	ret

08214930 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
 8214930:	deffdf04 	addi	sp,sp,-132
 8214934:	dfc02015 	stw	ra,128(sp)
 8214938:	df001f15 	stw	fp,124(sp)
 821493c:	df001f04 	addi	fp,sp,124
 8214940:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 8214944:	e0bfe204 	addi	r2,fp,-120
 8214948:	100b883a 	mov	r5,r2
 821494c:	01003fc4 	movi	r4,255
 8214950:	821bda00 	call	821bda0 <OSTaskQuery>
 8214954:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 8214958:	e0bffe83 	ldbu	r2,-6(fp)
 821495c:	10803fcc 	andi	r2,r2,255
 8214960:	10001e1e 	bne	r2,zero,82149dc <__env_lock+0xac>
    return;

  id = tcb.OSTCBPrio;
 8214964:	e0bfee83 	ldbu	r2,-70(fp)
 8214968:	10803fcc 	andi	r2,r2,255
 821496c:	e0bfe115 	stw	r2,-124(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
 8214970:	d0a06817 	ldw	r2,-32352(gp)
 8214974:	e0fffd04 	addi	r3,fp,-12
 8214978:	180b883a 	mov	r5,r3
 821497c:	1009883a 	mov	r4,r2
 8214980:	821a5b80 	call	821a5b8 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
 8214984:	e0bffe43 	ldbu	r2,-7(fp)
 8214988:	10803fcc 	andi	r2,r2,255
 821498c:	10000726 	beq	r2,zero,82149ac <__env_lock+0x7c>
 8214990:	d0a00a17 	ldw	r2,-32728(gp)
 8214994:	e0ffe117 	ldw	r3,-124(fp)
 8214998:	1880041e 	bne	r3,r2,82149ac <__env_lock+0x7c>
  {
    /* we do; just count the recursion */

    locks++;
 821499c:	d0a06717 	ldw	r2,-32356(gp)
 82149a0:	10800044 	addi	r2,r2,1
 82149a4:	d0a06715 	stw	r2,-32356(gp)
 82149a8:	00000a06 	br	82149d4 <__env_lock+0xa4>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
 82149ac:	d0a06817 	ldw	r2,-32352(gp)
 82149b0:	e0fffe84 	addi	r3,fp,-6
 82149b4:	180d883a 	mov	r6,r3
 82149b8:	000b883a 	mov	r5,zero
 82149bc:	1009883a 	mov	r4,r2
 82149c0:	821a1300 	call	821a130 <OSSemPend>
    locks  = 1;
 82149c4:	00800044 	movi	r2,1
 82149c8:	d0a06715 	stw	r2,-32356(gp)
    lockid = id;
 82149cc:	e0bfe117 	ldw	r2,-124(fp)
 82149d0:	d0a00a15 	stw	r2,-32728(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
 82149d4:	0001883a 	nop
 82149d8:	00000106 	br	82149e0 <__env_lock+0xb0>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
 82149dc:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 82149e0:	e037883a 	mov	sp,fp
 82149e4:	dfc00117 	ldw	ra,4(sp)
 82149e8:	df000017 	ldw	fp,0(sp)
 82149ec:	dec00204 	addi	sp,sp,8
 82149f0:	f800283a 	ret

082149f4 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
 82149f4:	defffd04 	addi	sp,sp,-12
 82149f8:	dfc00215 	stw	ra,8(sp)
 82149fc:	df000115 	stw	fp,4(sp)
 8214a00:	df000104 	addi	fp,sp,4
 8214a04:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
 8214a08:	d0a06717 	ldw	r2,-32356(gp)
 8214a0c:	10000b26 	beq	r2,zero,8214a3c <__env_unlock+0x48>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
 8214a10:	d0a06717 	ldw	r2,-32356(gp)
 8214a14:	10bfffc4 	addi	r2,r2,-1
 8214a18:	d0a06715 	stw	r2,-32356(gp)
 8214a1c:	d0a06717 	ldw	r2,-32356(gp)
 8214a20:	1000071e 	bne	r2,zero,8214a40 <__env_unlock+0x4c>
  {
    lockid = -1;
 8214a24:	00bfffc4 	movi	r2,-1
 8214a28:	d0a00a15 	stw	r2,-32728(gp)
    OSSemPost( alt_envsem );
 8214a2c:	d0a06817 	ldw	r2,-32352(gp)
 8214a30:	1009883a 	mov	r4,r2
 8214a34:	821a4a80 	call	821a4a8 <OSSemPost>
 8214a38:	00000106 	br	8214a40 <__env_unlock+0x4c>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
 8214a3c:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 8214a40:	e037883a 	mov	sp,fp
 8214a44:	dfc00117 	ldw	ra,4(sp)
 8214a48:	df000017 	ldw	fp,0(sp)
 8214a4c:	dec00204 	addi	sp,sp,8
 8214a50:	f800283a 	ret

08214a54 <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
 8214a54:	deffdb04 	addi	sp,sp,-148
 8214a58:	dfc02415 	stw	ra,144(sp)
 8214a5c:	df002315 	stw	fp,140(sp)
 8214a60:	df002304 	addi	fp,sp,140
 8214a64:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8214a68:	e03fdd15 	stw	zero,-140(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
 8214a6c:	d0a06b43 	ldbu	r2,-32339(gp)
 8214a70:	10803fcc 	andi	r2,r2,255
 8214a74:	10800060 	cmpeqi	r2,r2,1
 8214a78:	10003626 	beq	r2,zero,8214b54 <__malloc_lock+0x100>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 8214a7c:	e0bfe204 	addi	r2,fp,-120
 8214a80:	100b883a 	mov	r5,r2
 8214a84:	01003fc4 	movi	r4,255
 8214a88:	821bda00 	call	821bda0 <OSTaskQuery>
 8214a8c:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 8214a90:	e0bffe83 	ldbu	r2,-6(fp)
 8214a94:	10803fcc 	andi	r2,r2,255
 8214a98:	1000301e 	bne	r2,zero,8214b5c <__malloc_lock+0x108>
    return;

  id = tcb.OSTCBPrio;
 8214a9c:	e0bfee83 	ldbu	r2,-70(fp)
 8214aa0:	10803fcc 	andi	r2,r2,255
 8214aa4:	e0bfde15 	stw	r2,-136(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
 8214aa8:	d0a06a17 	ldw	r2,-32344(gp)
 8214aac:	e0fffd04 	addi	r3,fp,-12
 8214ab0:	180b883a 	mov	r5,r3
 8214ab4:	1009883a 	mov	r4,r2
 8214ab8:	821a5b80 	call	821a5b8 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214abc:	0005303a 	rdctl	r2,status
 8214ac0:	e0bfe115 	stw	r2,-124(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8214ac4:	e0ffe117 	ldw	r3,-124(fp)
 8214ac8:	00bfff84 	movi	r2,-2
 8214acc:	1884703a 	and	r2,r3,r2
 8214ad0:	1001703a 	wrctl	status,r2
  
  return context;
 8214ad4:	e0bfe117 	ldw	r2,-124(fp)
  
  OS_ENTER_CRITICAL();
 8214ad8:	e0bfdd15 	stw	r2,-140(fp)

  if( !semdata.OSCnt && id == lockid ) 
 8214adc:	e0bffd0b 	ldhu	r2,-12(fp)
 8214ae0:	10bfffcc 	andi	r2,r2,65535
 8214ae4:	10000b1e 	bne	r2,zero,8214b14 <__malloc_lock+0xc0>
 8214ae8:	d0a00b17 	ldw	r2,-32724(gp)
 8214aec:	e0ffde17 	ldw	r3,-136(fp)
 8214af0:	1880081e 	bne	r3,r2,8214b14 <__malloc_lock+0xc0>
  {
    /* we do; just count the recursion */
    locks++;
 8214af4:	d0a06917 	ldw	r2,-32348(gp)
 8214af8:	10800044 	addi	r2,r2,1
 8214afc:	d0a06915 	stw	r2,-32348(gp)
 8214b00:	e0bfdd17 	ldw	r2,-140(fp)
 8214b04:	e0bfdf15 	stw	r2,-132(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8214b08:	e0bfdf17 	ldw	r2,-132(fp)
 8214b0c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
 8214b10:	00000e06 	br	8214b4c <__malloc_lock+0xf8>
 8214b14:	e0bfdd17 	ldw	r2,-140(fp)
 8214b18:	e0bfe015 	stw	r2,-128(fp)
 8214b1c:	e0bfe017 	ldw	r2,-128(fp)
 8214b20:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
 8214b24:	d0a06a17 	ldw	r2,-32344(gp)
 8214b28:	e0fffe84 	addi	r3,fp,-6
 8214b2c:	180d883a 	mov	r6,r3
 8214b30:	000b883a 	mov	r5,zero
 8214b34:	1009883a 	mov	r4,r2
 8214b38:	821a1300 	call	821a130 <OSSemPend>
    locks  = 1;
 8214b3c:	00800044 	movi	r2,1
 8214b40:	d0a06915 	stw	r2,-32348(gp)
    lockid = id;
 8214b44:	e0bfde17 	ldw	r2,-136(fp)
 8214b48:	d0a00b15 	stw	r2,-32724(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
 8214b4c:	0001883a 	nop
 8214b50:	00000306 	br	8214b60 <__malloc_lock+0x10c>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
 8214b54:	0001883a 	nop
 8214b58:	00000106 	br	8214b60 <__malloc_lock+0x10c>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
 8214b5c:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 8214b60:	e037883a 	mov	sp,fp
 8214b64:	dfc00117 	ldw	ra,4(sp)
 8214b68:	df000017 	ldw	fp,0(sp)
 8214b6c:	dec00204 	addi	sp,sp,8
 8214b70:	f800283a 	ret

08214b74 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 8214b74:	defff804 	addi	sp,sp,-32
 8214b78:	dfc00715 	stw	ra,28(sp)
 8214b7c:	df000615 	stw	fp,24(sp)
 8214b80:	df000604 	addi	fp,sp,24
 8214b84:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8214b88:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
 8214b8c:	d0a06b43 	ldbu	r2,-32339(gp)
 8214b90:	10803fcc 	andi	r2,r2,255
 8214b94:	10800060 	cmpeqi	r2,r2,1
 8214b98:	10002326 	beq	r2,zero,8214c28 <__malloc_unlock+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214b9c:	0005303a 	rdctl	r2,status
 8214ba0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8214ba4:	e0fffe17 	ldw	r3,-8(fp)
 8214ba8:	00bfff84 	movi	r2,-2
 8214bac:	1884703a 	and	r2,r3,r2
 8214bb0:	1001703a 	wrctl	status,r2
  
  return context;
 8214bb4:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
 8214bb8:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
 8214bbc:	d0a06917 	ldw	r2,-32348(gp)
 8214bc0:	1000051e 	bne	r2,zero,8214bd8 <__malloc_unlock+0x64>
 8214bc4:	e0bffa17 	ldw	r2,-24(fp)
 8214bc8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8214bcc:	e0bffb17 	ldw	r2,-20(fp)
 8214bd0:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
 8214bd4:	00001506 	br	8214c2c <__malloc_unlock+0xb8>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
 8214bd8:	d0a06917 	ldw	r2,-32348(gp)
 8214bdc:	10bfffc4 	addi	r2,r2,-1
 8214be0:	d0a06915 	stw	r2,-32348(gp)
 8214be4:	d0a06917 	ldw	r2,-32348(gp)
 8214be8:	10000a1e 	bne	r2,zero,8214c14 <__malloc_unlock+0xa0>
  {
    lockid = -1;
 8214bec:	00bfffc4 	movi	r2,-1
 8214bf0:	d0a00b15 	stw	r2,-32724(gp)
 8214bf4:	e0bffa17 	ldw	r2,-24(fp)
 8214bf8:	e0bffc15 	stw	r2,-16(fp)
 8214bfc:	e0bffc17 	ldw	r2,-16(fp)
 8214c00:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
 8214c04:	d0a06a17 	ldw	r2,-32344(gp)
 8214c08:	1009883a 	mov	r4,r2
 8214c0c:	821a4a80 	call	821a4a8 <OSSemPost>
 8214c10:	00000606 	br	8214c2c <__malloc_unlock+0xb8>
 8214c14:	e0bffa17 	ldw	r2,-24(fp)
 8214c18:	e0bffd15 	stw	r2,-12(fp)
 8214c1c:	e0bffd17 	ldw	r2,-12(fp)
 8214c20:	1001703a 	wrctl	status,r2
 8214c24:	00000106 	br	8214c2c <__malloc_unlock+0xb8>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
 8214c28:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 8214c2c:	e037883a 	mov	sp,fp
 8214c30:	dfc00117 	ldw	ra,4(sp)
 8214c34:	df000017 	ldw	fp,0(sp)
 8214c38:	dec00204 	addi	sp,sp,8
 8214c3c:	f800283a 	ret

08214c40 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 8214c40:	defff704 	addi	sp,sp,-36
 8214c44:	dfc00815 	stw	ra,32(sp)
 8214c48:	df000715 	stw	fp,28(sp)
 8214c4c:	df000704 	addi	fp,sp,28
 8214c50:	e13ffd15 	stw	r4,-12(fp)
 8214c54:	e17ffe15 	stw	r5,-8(fp)
 8214c58:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8214c5c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8214c60:	e0bfff17 	ldw	r2,-4(fp)
 8214c64:	1000021e 	bne	r2,zero,8214c70 <OSEventNameGet+0x30>
        return (0);
 8214c68:	0005883a 	mov	r2,zero
 8214c6c:	00003706 	br	8214d4c <OSEventNameGet+0x10c>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 8214c70:	e0bffd17 	ldw	r2,-12(fp)
 8214c74:	1000051e 	bne	r2,zero,8214c8c <OSEventNameGet+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
 8214c78:	e0bfff17 	ldw	r2,-4(fp)
 8214c7c:	00c00104 	movi	r3,4
 8214c80:	10c00005 	stb	r3,0(r2)
        return (0);
 8214c84:	0005883a 	mov	r2,zero
 8214c88:	00003006 	br	8214d4c <OSEventNameGet+0x10c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 8214c8c:	e0bffe17 	ldw	r2,-8(fp)
 8214c90:	1000051e 	bne	r2,zero,8214ca8 <OSEventNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
 8214c94:	e0bfff17 	ldw	r2,-4(fp)
 8214c98:	00c00304 	movi	r3,12
 8214c9c:	10c00005 	stb	r3,0(r2)
        return (0);
 8214ca0:	0005883a 	mov	r2,zero
 8214ca4:	00002906 	br	8214d4c <OSEventNameGet+0x10c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 8214ca8:	d0a07903 	ldbu	r2,-32284(gp)
 8214cac:	10803fcc 	andi	r2,r2,255
 8214cb0:	10000526 	beq	r2,zero,8214cc8 <OSEventNameGet+0x88>
        *perr  = OS_ERR_NAME_GET_ISR;
 8214cb4:	e0bfff17 	ldw	r2,-4(fp)
 8214cb8:	00c00444 	movi	r3,17
 8214cbc:	10c00005 	stb	r3,0(r2)
        return (0);
 8214cc0:	0005883a 	mov	r2,zero
 8214cc4:	00002106 	br	8214d4c <OSEventNameGet+0x10c>
    }
    switch (pevent->OSEventType) {
 8214cc8:	e0bffd17 	ldw	r2,-12(fp)
 8214ccc:	10800003 	ldbu	r2,0(r2)
 8214cd0:	10803fcc 	andi	r2,r2,255
 8214cd4:	10bfffc4 	addi	r2,r2,-1
 8214cd8:	10800128 	cmpgeui	r2,r2,4
 8214cdc:	10000526 	beq	r2,zero,8214cf4 <OSEventNameGet+0xb4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 8214ce0:	e0bfff17 	ldw	r2,-4(fp)
 8214ce4:	00c00044 	movi	r3,1
 8214ce8:	10c00005 	stb	r3,0(r2)
             return (0);
 8214cec:	0005883a 	mov	r2,zero
 8214cf0:	00001606 	br	8214d4c <OSEventNameGet+0x10c>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
 8214cf4:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214cf8:	0005303a 	rdctl	r2,status
 8214cfc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8214d00:	e0fffb17 	ldw	r3,-20(fp)
 8214d04:	00bfff84 	movi	r2,-2
 8214d08:	1884703a 	and	r2,r3,r2
 8214d0c:	1001703a 	wrctl	status,r2
  
  return context;
 8214d10:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
 8214d14:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
 8214d18:	e0bffd17 	ldw	r2,-12(fp)
 8214d1c:	10800384 	addi	r2,r2,14
 8214d20:	100b883a 	mov	r5,r2
 8214d24:	e13ffe17 	ldw	r4,-8(fp)
 8214d28:	82166c40 	call	82166c4 <OS_StrCopy>
 8214d2c:	e0bffa05 	stb	r2,-24(fp)
 8214d30:	e0bff917 	ldw	r2,-28(fp)
 8214d34:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8214d38:	e0bffc17 	ldw	r2,-16(fp)
 8214d3c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8214d40:	e0bfff17 	ldw	r2,-4(fp)
 8214d44:	10000005 	stb	zero,0(r2)
    return (len);
 8214d48:	e0bffa03 	ldbu	r2,-24(fp)
}
 8214d4c:	e037883a 	mov	sp,fp
 8214d50:	dfc00117 	ldw	ra,4(sp)
 8214d54:	df000017 	ldw	fp,0(sp)
 8214d58:	dec00204 	addi	sp,sp,8
 8214d5c:	f800283a 	ret

08214d60 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 8214d60:	defff604 	addi	sp,sp,-40
 8214d64:	dfc00915 	stw	ra,36(sp)
 8214d68:	df000815 	stw	fp,32(sp)
 8214d6c:	df000804 	addi	fp,sp,32
 8214d70:	e13ffd15 	stw	r4,-12(fp)
 8214d74:	e17ffe15 	stw	r5,-8(fp)
 8214d78:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8214d7c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8214d80:	e0bfff17 	ldw	r2,-4(fp)
 8214d84:	10004026 	beq	r2,zero,8214e88 <OSEventNameSet+0x128>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 8214d88:	e0bffd17 	ldw	r2,-12(fp)
 8214d8c:	1000041e 	bne	r2,zero,8214da0 <OSEventNameSet+0x40>
        *perr = OS_ERR_PEVENT_NULL;
 8214d90:	e0bfff17 	ldw	r2,-4(fp)
 8214d94:	00c00104 	movi	r3,4
 8214d98:	10c00005 	stb	r3,0(r2)
        return;
 8214d9c:	00003b06 	br	8214e8c <OSEventNameSet+0x12c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 8214da0:	e0bffe17 	ldw	r2,-8(fp)
 8214da4:	1000041e 	bne	r2,zero,8214db8 <OSEventNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
 8214da8:	e0bfff17 	ldw	r2,-4(fp)
 8214dac:	00c00304 	movi	r3,12
 8214db0:	10c00005 	stb	r3,0(r2)
        return;
 8214db4:	00003506 	br	8214e8c <OSEventNameSet+0x12c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 8214db8:	d0a07903 	ldbu	r2,-32284(gp)
 8214dbc:	10803fcc 	andi	r2,r2,255
 8214dc0:	10000426 	beq	r2,zero,8214dd4 <OSEventNameSet+0x74>
        *perr = OS_ERR_NAME_SET_ISR;
 8214dc4:	e0bfff17 	ldw	r2,-4(fp)
 8214dc8:	00c00484 	movi	r3,18
 8214dcc:	10c00005 	stb	r3,0(r2)
        return;
 8214dd0:	00002e06 	br	8214e8c <OSEventNameSet+0x12c>
    }
    switch (pevent->OSEventType) {
 8214dd4:	e0bffd17 	ldw	r2,-12(fp)
 8214dd8:	10800003 	ldbu	r2,0(r2)
 8214ddc:	10803fcc 	andi	r2,r2,255
 8214de0:	10bfffc4 	addi	r2,r2,-1
 8214de4:	10800128 	cmpgeui	r2,r2,4
 8214de8:	10000426 	beq	r2,zero,8214dfc <OSEventNameSet+0x9c>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 8214dec:	e0bfff17 	ldw	r2,-4(fp)
 8214df0:	00c00044 	movi	r3,1
 8214df4:	10c00005 	stb	r3,0(r2)
             return;
 8214df8:	00002406 	br	8214e8c <OSEventNameSet+0x12c>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
 8214dfc:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214e00:	0005303a 	rdctl	r2,status
 8214e04:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8214e08:	e0fffc17 	ldw	r3,-16(fp)
 8214e0c:	00bfff84 	movi	r2,-2
 8214e10:	1884703a 	and	r2,r3,r2
 8214e14:	1001703a 	wrctl	status,r2
  
  return context;
 8214e18:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
 8214e1c:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
 8214e20:	e13ffe17 	ldw	r4,-8(fp)
 8214e24:	82167380 	call	8216738 <OS_StrLen>
 8214e28:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
 8214e2c:	e0bffa03 	ldbu	r2,-24(fp)
 8214e30:	10800830 	cmpltui	r2,r2,32
 8214e34:	1000081e 	bne	r2,zero,8214e58 <OSEventNameSet+0xf8>
 8214e38:	e0bff817 	ldw	r2,-32(fp)
 8214e3c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8214e40:	e0bff917 	ldw	r2,-28(fp)
 8214e44:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
 8214e48:	e0bfff17 	ldw	r2,-4(fp)
 8214e4c:	00c002c4 	movi	r3,11
 8214e50:	10c00005 	stb	r3,0(r2)
        return;
 8214e54:	00000d06 	br	8214e8c <OSEventNameSet+0x12c>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
 8214e58:	e0bffd17 	ldw	r2,-12(fp)
 8214e5c:	10800384 	addi	r2,r2,14
 8214e60:	e17ffe17 	ldw	r5,-8(fp)
 8214e64:	1009883a 	mov	r4,r2
 8214e68:	82166c40 	call	82166c4 <OS_StrCopy>
 8214e6c:	e0bff817 	ldw	r2,-32(fp)
 8214e70:	e0bffb15 	stw	r2,-20(fp)
 8214e74:	e0bffb17 	ldw	r2,-20(fp)
 8214e78:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8214e7c:	e0bfff17 	ldw	r2,-4(fp)
 8214e80:	10000005 	stb	zero,0(r2)
 8214e84:	00000106 	br	8214e8c <OSEventNameSet+0x12c>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
 8214e88:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
 8214e8c:	e037883a 	mov	sp,fp
 8214e90:	dfc00117 	ldw	ra,4(sp)
 8214e94:	df000017 	ldw	fp,0(sp)
 8214e98:	dec00204 	addi	sp,sp,8
 8214e9c:	f800283a 	ret

08214ea0 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
 8214ea0:	deffed04 	addi	sp,sp,-76
 8214ea4:	dfc01215 	stw	ra,72(sp)
 8214ea8:	df001115 	stw	fp,68(sp)
 8214eac:	df001104 	addi	fp,sp,68
 8214eb0:	e13ffc15 	stw	r4,-16(fp)
 8214eb4:	e17ffd15 	stw	r5,-12(fp)
 8214eb8:	e1bffe15 	stw	r6,-8(fp)
 8214ebc:	3805883a 	mov	r2,r7
 8214ec0:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
 8214ec4:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
 8214ec8:	e0800217 	ldw	r2,8(fp)
 8214ecc:	1000021e 	bne	r2,zero,8214ed8 <OSEventPendMulti+0x38>
        return (0);
 8214ed0:	0005883a 	mov	r2,zero
 8214ed4:	00017106 	br	821549c <OSEventPendMulti+0x5fc>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
 8214ed8:	e0bffc17 	ldw	r2,-16(fp)
 8214edc:	1000051e 	bne	r2,zero,8214ef4 <OSEventPendMulti+0x54>
       *perr =  OS_ERR_PEVENT_NULL;
 8214ee0:	e0800217 	ldw	r2,8(fp)
 8214ee4:	00c00104 	movi	r3,4
 8214ee8:	10c00005 	stb	r3,0(r2)
        return (0);
 8214eec:	0005883a 	mov	r2,zero
 8214ef0:	00016a06 	br	821549c <OSEventPendMulti+0x5fc>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
 8214ef4:	e0bffd17 	ldw	r2,-12(fp)
 8214ef8:	1000051e 	bne	r2,zero,8214f10 <OSEventPendMulti+0x70>
       *perr =  OS_ERR_PEVENT_NULL;
 8214efc:	e0800217 	ldw	r2,8(fp)
 8214f00:	00c00104 	movi	r3,4
 8214f04:	10c00005 	stb	r3,0(r2)
        return (0);
 8214f08:	0005883a 	mov	r2,zero
 8214f0c:	00016306 	br	821549c <OSEventPendMulti+0x5fc>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
 8214f10:	e0bffe17 	ldw	r2,-8(fp)
 8214f14:	1000051e 	bne	r2,zero,8214f2c <OSEventPendMulti+0x8c>
       *perr =  OS_ERR_PEVENT_NULL;
 8214f18:	e0800217 	ldw	r2,8(fp)
 8214f1c:	00c00104 	movi	r3,4
 8214f20:	10c00005 	stb	r3,0(r2)
        return (0);
 8214f24:	0005883a 	mov	r2,zero
 8214f28:	00015c06 	br	821549c <OSEventPendMulti+0x5fc>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
 8214f2c:	e0bffd17 	ldw	r2,-12(fp)
 8214f30:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
 8214f34:	e0bffc17 	ldw	r2,-16(fp)
 8214f38:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
 8214f3c:	e0bfef17 	ldw	r2,-68(fp)
 8214f40:	10800017 	ldw	r2,0(r2)
 8214f44:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
 8214f48:	00001906 	br	8214fb0 <OSEventPendMulti+0x110>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
 8214f4c:	e0bff017 	ldw	r2,-64(fp)
 8214f50:	10800003 	ldbu	r2,0(r2)
 8214f54:	10803fcc 	andi	r2,r2,255
 8214f58:	10c000a0 	cmpeqi	r3,r2,2
 8214f5c:	1800091e 	bne	r3,zero,8214f84 <OSEventPendMulti+0xe4>
 8214f60:	10c000e0 	cmpeqi	r3,r2,3
 8214f64:	1800091e 	bne	r3,zero,8214f8c <OSEventPendMulti+0xec>
 8214f68:	10800060 	cmpeqi	r2,r2,1
 8214f6c:	1000091e 	bne	r2,zero,8214f94 <OSEventPendMulti+0xf4>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
 8214f70:	e0800217 	ldw	r2,8(fp)
 8214f74:	00c00044 	movi	r3,1
 8214f78:	10c00005 	stb	r3,0(r2)
                 return (0);
 8214f7c:	0005883a 	mov	r2,zero
 8214f80:	00014606 	br	821549c <OSEventPendMulti+0x5fc>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
 8214f84:	0001883a 	nop
 8214f88:	00000306 	br	8214f98 <OSEventPendMulti+0xf8>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
 8214f8c:	0001883a 	nop
 8214f90:	00000106 	br	8214f98 <OSEventPendMulti+0xf8>
#endif
#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 break;
 8214f94:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
 8214f98:	e0bfef17 	ldw	r2,-68(fp)
 8214f9c:	10800104 	addi	r2,r2,4
 8214fa0:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
 8214fa4:	e0bfef17 	ldw	r2,-68(fp)
 8214fa8:	10800017 	ldw	r2,0(r2)
 8214fac:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
 8214fb0:	e0bff017 	ldw	r2,-64(fp)
 8214fb4:	103fe51e 	bne	r2,zero,8214f4c <OSEventPendMulti+0xac>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
 8214fb8:	d0a07903 	ldbu	r2,-32284(gp)
 8214fbc:	10803fcc 	andi	r2,r2,255
 8214fc0:	10000526 	beq	r2,zero,8214fd8 <OSEventPendMulti+0x138>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
 8214fc4:	e0800217 	ldw	r2,8(fp)
 8214fc8:	00c00084 	movi	r3,2
 8214fcc:	10c00005 	stb	r3,0(r2)
        return (0);
 8214fd0:	0005883a 	mov	r2,zero
 8214fd4:	00013106 	br	821549c <OSEventPendMulti+0x5fc>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
 8214fd8:	d0a06b03 	ldbu	r2,-32340(gp)
 8214fdc:	10803fcc 	andi	r2,r2,255
 8214fe0:	10000526 	beq	r2,zero,8214ff8 <OSEventPendMulti+0x158>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
 8214fe4:	e0800217 	ldw	r2,8(fp)
 8214fe8:	00c00344 	movi	r3,13
 8214fec:	10c00005 	stb	r3,0(r2)
        return (0);
 8214ff0:	0005883a 	mov	r2,zero
 8214ff4:	00012906 	br	821549c <OSEventPendMulti+0x5fc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214ff8:	0005303a 	rdctl	r2,status
 8214ffc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8215000:	e0fffb17 	ldw	r3,-20(fp)
 8215004:	00bfff84 	movi	r2,-2
 8215008:	1884703a 	and	r2,r3,r2
 821500c:	1001703a 	wrctl	status,r2
  
  return context;
 8215010:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
 8215014:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
 8215018:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
 821501c:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
 8215020:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
 8215024:	e0bffc17 	ldw	r2,-16(fp)
 8215028:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
 821502c:	e0bfef17 	ldw	r2,-68(fp)
 8215030:	10800017 	ldw	r2,0(r2)
 8215034:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 8215038:	00008106 	br	8215240 <OSEventPendMulti+0x3a0>
        switch (pevent->OSEventType) {
 821503c:	e0bff017 	ldw	r2,-64(fp)
 8215040:	10800003 	ldbu	r2,0(r2)
 8215044:	10803fcc 	andi	r2,r2,255
 8215048:	10c000a0 	cmpeqi	r3,r2,2
 821504c:	18003c1e 	bne	r3,zero,8215140 <OSEventPendMulti+0x2a0>
 8215050:	10c000e0 	cmpeqi	r3,r2,3
 8215054:	1800031e 	bne	r3,zero,8215064 <OSEventPendMulti+0x1c4>
 8215058:	10800060 	cmpeqi	r2,r2,1
 821505c:	10001e1e 	bne	r2,zero,82150d8 <OSEventPendMulti+0x238>
 8215060:	00006606 	br	82151fc <OSEventPendMulti+0x35c>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
 8215064:	e0bff017 	ldw	r2,-64(fp)
 8215068:	1080020b 	ldhu	r2,8(r2)
 821506c:	10bfffcc 	andi	r2,r2,65535
 8215070:	10001526 	beq	r2,zero,82150c8 <OSEventPendMulti+0x228>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
 8215074:	e0bff017 	ldw	r2,-64(fp)
 8215078:	1080020b 	ldhu	r2,8(r2)
 821507c:	10bfffc4 	addi	r2,r2,-1
 8215080:	1007883a 	mov	r3,r2
 8215084:	e0bff017 	ldw	r2,-64(fp)
 8215088:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
 821508c:	e0bffd17 	ldw	r2,-12(fp)
 8215090:	10c00104 	addi	r3,r2,4
 8215094:	e0fffd15 	stw	r3,-12(fp)
 8215098:	e0fff017 	ldw	r3,-64(fp)
 821509c:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
 82150a0:	00800044 	movi	r2,1
 82150a4:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
 82150a8:	e0bffe17 	ldw	r2,-8(fp)
 82150ac:	10c00104 	addi	r3,r2,4
 82150b0:	e0fffe15 	stw	r3,-8(fp)
 82150b4:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
 82150b8:	e0bff18b 	ldhu	r2,-58(fp)
 82150bc:	10800044 	addi	r2,r2,1
 82150c0:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
 82150c4:	00005806 	br	8215228 <OSEventPendMulti+0x388>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
 82150c8:	e0bff203 	ldbu	r2,-56(fp)
 82150cc:	10800054 	ori	r2,r2,1
 82150d0:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
 82150d4:	00005406 	br	8215228 <OSEventPendMulti+0x388>
#endif

#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
 82150d8:	e0bff017 	ldw	r2,-64(fp)
 82150dc:	10800117 	ldw	r2,4(r2)
 82150e0:	10001326 	beq	r2,zero,8215130 <OSEventPendMulti+0x290>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
 82150e4:	e0bffe17 	ldw	r2,-8(fp)
 82150e8:	10c00104 	addi	r3,r2,4
 82150ec:	e0fffe15 	stw	r3,-8(fp)
 82150f0:	e0fff017 	ldw	r3,-64(fp)
 82150f4:	18c00117 	ldw	r3,4(r3)
 82150f8:	10c00015 	stw	r3,0(r2)
                     pevent->OSEventPtr  = (void *)0;
 82150fc:	e0bff017 	ldw	r2,-64(fp)
 8215100:	10000115 	stw	zero,4(r2)
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
 8215104:	e0bffd17 	ldw	r2,-12(fp)
 8215108:	10c00104 	addi	r3,r2,4
 821510c:	e0fffd15 	stw	r3,-12(fp)
 8215110:	e0fff017 	ldw	r3,-64(fp)
 8215114:	10c00015 	stw	r3,0(r2)
                      events_rdy         =  OS_TRUE;
 8215118:	00800044 	movi	r2,1
 821511c:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
 8215120:	e0bff18b 	ldhu	r2,-58(fp)
 8215124:	10800044 	addi	r2,r2,1
 8215128:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
                 }
                 break;
 821512c:	00003e06 	br	8215228 <OSEventPendMulti+0x388>
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
                      events_rdy         =  OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
 8215130:	e0bff203 	ldbu	r2,-56(fp)
 8215134:	10800094 	ori	r2,r2,2
 8215138:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
 821513c:	00003a06 	br	8215228 <OSEventPendMulti+0x388>
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
 8215140:	e0bff017 	ldw	r2,-64(fp)
 8215144:	10800117 	ldw	r2,4(r2)
 8215148:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
 821514c:	e0bff517 	ldw	r2,-44(fp)
 8215150:	1080058b 	ldhu	r2,22(r2)
 8215154:	10bfffcc 	andi	r2,r2,65535
 8215158:	10002426 	beq	r2,zero,82151ec <OSEventPendMulti+0x34c>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
 821515c:	e0bffe17 	ldw	r2,-8(fp)
 8215160:	10c00104 	addi	r3,r2,4
 8215164:	e0fffe15 	stw	r3,-8(fp)
 8215168:	e0fff517 	ldw	r3,-44(fp)
 821516c:	18c00417 	ldw	r3,16(r3)
 8215170:	19400104 	addi	r5,r3,4
 8215174:	e13ff517 	ldw	r4,-44(fp)
 8215178:	21400415 	stw	r5,16(r4)
 821517c:	18c00017 	ldw	r3,0(r3)
 8215180:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
 8215184:	e0bff517 	ldw	r2,-44(fp)
 8215188:	10c00417 	ldw	r3,16(r2)
 821518c:	e0bff517 	ldw	r2,-44(fp)
 8215190:	10800217 	ldw	r2,8(r2)
 8215194:	1880041e 	bne	r3,r2,82151a8 <OSEventPendMulti+0x308>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
 8215198:	e0bff517 	ldw	r2,-44(fp)
 821519c:	10c00117 	ldw	r3,4(r2)
 82151a0:	e0bff517 	ldw	r2,-44(fp)
 82151a4:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
 82151a8:	e0bff517 	ldw	r2,-44(fp)
 82151ac:	1080058b 	ldhu	r2,22(r2)
 82151b0:	10bfffc4 	addi	r2,r2,-1
 82151b4:	1007883a 	mov	r3,r2
 82151b8:	e0bff517 	ldw	r2,-44(fp)
 82151bc:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
 82151c0:	e0bffd17 	ldw	r2,-12(fp)
 82151c4:	10c00104 	addi	r3,r2,4
 82151c8:	e0fffd15 	stw	r3,-12(fp)
 82151cc:	e0fff017 	ldw	r3,-64(fp)
 82151d0:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
 82151d4:	00800044 	movi	r2,1
 82151d8:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
 82151dc:	e0bff18b 	ldhu	r2,-58(fp)
 82151e0:	10800044 	addi	r2,r2,1
 82151e4:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
 82151e8:	00000f06 	br	8215228 <OSEventPendMulti+0x388>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
 82151ec:	e0bff203 	ldbu	r2,-56(fp)
 82151f0:	10800114 	ori	r2,r2,4
 82151f4:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
 82151f8:	00000b06 	br	8215228 <OSEventPendMulti+0x388>
 82151fc:	e0bff317 	ldw	r2,-52(fp)
 8215200:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8215204:	e0bff417 	ldw	r2,-48(fp)
 8215208:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
 821520c:	e0bffd17 	ldw	r2,-12(fp)
 8215210:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
 8215214:	e0800217 	ldw	r2,8(fp)
 8215218:	00c00044 	movi	r3,1
 821521c:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
 8215220:	e0bff18b 	ldhu	r2,-58(fp)
 8215224:	00009d06 	br	821549c <OSEventPendMulti+0x5fc>
        }
        pevents++;
 8215228:	e0bfef17 	ldw	r2,-68(fp)
 821522c:	10800104 	addi	r2,r2,4
 8215230:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
 8215234:	e0bfef17 	ldw	r2,-68(fp)
 8215238:	10800017 	ldw	r2,0(r2)
 821523c:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 8215240:	e0bff017 	ldw	r2,-64(fp)
 8215244:	103f7d1e 	bne	r2,zero,821503c <OSEventPendMulti+0x19c>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
 8215248:	e0bff103 	ldbu	r2,-60(fp)
 821524c:	10800058 	cmpnei	r2,r2,1
 8215250:	10000a1e 	bne	r2,zero,821527c <OSEventPendMulti+0x3dc>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
 8215254:	e0bffd17 	ldw	r2,-12(fp)
 8215258:	10000015 	stw	zero,0(r2)
 821525c:	e0bff317 	ldw	r2,-52(fp)
 8215260:	e0bff615 	stw	r2,-40(fp)
 8215264:	e0bff617 	ldw	r2,-40(fp)
 8215268:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
 821526c:	e0800217 	ldw	r2,8(fp)
 8215270:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
 8215274:	e0bff18b 	ldhu	r2,-58(fp)
 8215278:	00008806 	br	821549c <OSEventPendMulti+0x5fc>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
 821527c:	d0a07a17 	ldw	r2,-32280(gp)
 8215280:	d0e07a17 	ldw	r3,-32280(gp)
 8215284:	19000c03 	ldbu	r4,48(r3)
 8215288:	e0fff203 	ldbu	r3,-56(fp)
 821528c:	20c6b03a 	or	r3,r4,r3
 8215290:	1809883a 	mov	r4,r3
 8215294:	00ffe004 	movi	r3,-128
 8215298:	20c6b03a 	or	r3,r4,r3
 821529c:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 82152a0:	d0a07a17 	ldw	r2,-32280(gp)
 82152a4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
 82152a8:	d0a07a17 	ldw	r2,-32280(gp)
 82152ac:	e0ffff0b 	ldhu	r3,-4(fp)
 82152b0:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
 82152b4:	e13ffc17 	ldw	r4,-16(fp)
 82152b8:	8215ddc0 	call	8215ddc <OS_EventTaskWaitMulti>
 82152bc:	e0bff317 	ldw	r2,-52(fp)
 82152c0:	e0bff915 	stw	r2,-28(fp)
 82152c4:	e0bff917 	ldw	r2,-28(fp)
 82152c8:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
 82152cc:	82165800 	call	8216580 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82152d0:	0005303a 	rdctl	r2,status
 82152d4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82152d8:	e0fff717 	ldw	r3,-36(fp)
 82152dc:	00bfff84 	movi	r2,-2
 82152e0:	1884703a 	and	r2,r3,r2
 82152e4:	1001703a 	wrctl	status,r2
  
  return context;
 82152e8:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 82152ec:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
 82152f0:	d0a07a17 	ldw	r2,-32280(gp)
 82152f4:	10800c43 	ldbu	r2,49(r2)
 82152f8:	10803fcc 	andi	r2,r2,255
 82152fc:	10000226 	beq	r2,zero,8215308 <OSEventPendMulti+0x468>
 8215300:	108000a0 	cmpeqi	r2,r2,2
 8215304:	10001826 	beq	r2,zero,8215368 <OSEventPendMulti+0x4c8>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
 8215308:	d0a07a17 	ldw	r2,-32280(gp)
 821530c:	10800717 	ldw	r2,28(r2)
 8215310:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
 8215314:	e0bff017 	ldw	r2,-64(fp)
 8215318:	10000b26 	beq	r2,zero,8215348 <OSEventPendMulti+0x4a8>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
 821531c:	e0bffd17 	ldw	r2,-12(fp)
 8215320:	10c00104 	addi	r3,r2,4
 8215324:	e0fffd15 	stw	r3,-12(fp)
 8215328:	e0fff017 	ldw	r3,-64(fp)
 821532c:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
 8215330:	e0bffd17 	ldw	r2,-12(fp)
 8215334:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
 8215338:	e0bff18b 	ldhu	r2,-58(fp)
 821533c:	10800044 	addi	r2,r2,1
 8215340:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
 8215344:	00000d06 	br	821537c <OSEventPendMulti+0x4dc>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
 8215348:	d0a07a17 	ldw	r2,-32280(gp)
 821534c:	00c00044 	movi	r3,1
 8215350:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 8215354:	d0a07a17 	ldw	r2,-32280(gp)
 8215358:	e17ffc17 	ldw	r5,-16(fp)
 821535c:	1009883a 	mov	r4,r2
 8215360:	8215fe40 	call	8215fe4 <OS_EventTaskRemoveMulti>
             }
			 break;
 8215364:	00000506 	br	821537c <OSEventPendMulti+0x4dc>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 8215368:	d0a07a17 	ldw	r2,-32280(gp)
 821536c:	e17ffc17 	ldw	r5,-16(fp)
 8215370:	1009883a 	mov	r4,r2
 8215374:	8215fe40 	call	8215fe4 <OS_EventTaskRemoveMulti>
             break;
 8215378:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
 821537c:	d0a07a17 	ldw	r2,-32280(gp)
 8215380:	10800c43 	ldbu	r2,49(r2)
 8215384:	10803fcc 	andi	r2,r2,255
 8215388:	10000326 	beq	r2,zero,8215398 <OSEventPendMulti+0x4f8>
 821538c:	108000a0 	cmpeqi	r2,r2,2
 8215390:	1000231e 	bne	r2,zero,8215420 <OSEventPendMulti+0x580>
 8215394:	00002a06 	br	8215440 <OSEventPendMulti+0x5a0>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
 8215398:	e0bff017 	ldw	r2,-64(fp)
 821539c:	10800003 	ldbu	r2,0(r2)
 82153a0:	10803fcc 	andi	r2,r2,255
 82153a4:	0080100e 	bge	zero,r2,82153e8 <OSEventPendMulti+0x548>
 82153a8:	10c000d0 	cmplti	r3,r2,3
 82153ac:	1800071e 	bne	r3,zero,82153cc <OSEventPendMulti+0x52c>
 82153b0:	108000e0 	cmpeqi	r2,r2,3
 82153b4:	10000c26 	beq	r2,zero,82153e8 <OSEventPendMulti+0x548>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
 82153b8:	e0bffe17 	ldw	r2,-8(fp)
 82153bc:	10c00104 	addi	r3,r2,4
 82153c0:	e0fffe15 	stw	r3,-8(fp)
 82153c4:	10000015 	stw	zero,0(r2)
                      break;
 82153c8:	00001206 	br	8215414 <OSEventPendMulti+0x574>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
 82153cc:	e0bffe17 	ldw	r2,-8(fp)
 82153d0:	10c00104 	addi	r3,r2,4
 82153d4:	e0fffe15 	stw	r3,-8(fp)
 82153d8:	d0e07a17 	ldw	r3,-32280(gp)
 82153dc:	18c00917 	ldw	r3,36(r3)
 82153e0:	10c00015 	stw	r3,0(r2)
                      break;
 82153e4:	00000b06 	br	8215414 <OSEventPendMulti+0x574>
 82153e8:	e0bff317 	ldw	r2,-52(fp)
 82153ec:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82153f0:	e0bff817 	ldw	r2,-32(fp)
 82153f4:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
 82153f8:	e0bffd17 	ldw	r2,-12(fp)
 82153fc:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
 8215400:	e0800217 	ldw	r2,8(fp)
 8215404:	00c00044 	movi	r3,1
 8215408:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
 821540c:	e0bff18b 	ldhu	r2,-58(fp)
 8215410:	00002206 	br	821549c <OSEventPendMulti+0x5fc>
             }
            *perr = OS_ERR_NONE;
 8215414:	e0800217 	ldw	r2,8(fp)
 8215418:	10000005 	stb	zero,0(r2)
             break;
 821541c:	00001006 	br	8215460 <OSEventPendMulti+0x5c0>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
 8215420:	e0bffe17 	ldw	r2,-8(fp)
 8215424:	10c00104 	addi	r3,r2,4
 8215428:	e0fffe15 	stw	r3,-8(fp)
 821542c:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
 8215430:	e0800217 	ldw	r2,8(fp)
 8215434:	00c00384 	movi	r3,14
 8215438:	10c00005 	stb	r3,0(r2)
             break;
 821543c:	00000806 	br	8215460 <OSEventPendMulti+0x5c0>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
 8215440:	e0bffe17 	ldw	r2,-8(fp)
 8215444:	10c00104 	addi	r3,r2,4
 8215448:	e0fffe15 	stw	r3,-8(fp)
 821544c:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
 8215450:	e0800217 	ldw	r2,8(fp)
 8215454:	00c00284 	movi	r3,10
 8215458:	10c00005 	stb	r3,0(r2)
             break;
 821545c:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
 8215460:	d0a07a17 	ldw	r2,-32280(gp)
 8215464:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
 8215468:	d0a07a17 	ldw	r2,-32280(gp)
 821546c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
 8215470:	d0a07a17 	ldw	r2,-32280(gp)
 8215474:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 8215478:	d0a07a17 	ldw	r2,-32280(gp)
 821547c:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
 8215480:	d0a07a17 	ldw	r2,-32280(gp)
 8215484:	10000915 	stw	zero,36(r2)
 8215488:	e0bff317 	ldw	r2,-52(fp)
 821548c:	e0bffa15 	stw	r2,-24(fp)
 8215490:	e0bffa17 	ldw	r2,-24(fp)
 8215494:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
 8215498:	e0bff18b 	ldhu	r2,-58(fp)
}
 821549c:	e037883a 	mov	sp,fp
 82154a0:	dfc00117 	ldw	ra,4(sp)
 82154a4:	df000017 	ldw	fp,0(sp)
 82154a8:	dec00204 	addi	sp,sp,8
 82154ac:	f800283a 	ret

082154b0 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
 82154b0:	defffe04 	addi	sp,sp,-8
 82154b4:	dfc00115 	stw	ra,4(sp)
 82154b8:	df000015 	stw	fp,0(sp)
 82154bc:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
 82154c0:	823cff00 	call	823cff0 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
 82154c4:	821622c0 	call	821622c <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
 82154c8:	82162740 	call	8216274 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
 82154cc:	82163e00 	call	82163e0 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
 82154d0:	821614c0 	call	821614c <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
 82154d4:	82182980 	call	8218298 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
 82154d8:	8218b980 	call	8218b98 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
 82154dc:	8219cc00 	call	8219cc0 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
 82154e0:	82162e00 	call	82162e0 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
 82154e4:	82163600 	call	8216360 <OS_InitTaskStat>

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
 82154e8:	823d0100 	call	823d010 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
 82154ec:	8216c6c0 	call	8216c6c <OSDebugInit>
#endif
}
 82154f0:	0001883a 	nop
 82154f4:	e037883a 	mov	sp,fp
 82154f8:	dfc00117 	ldw	ra,4(sp)
 82154fc:	df000017 	ldw	fp,0(sp)
 8215500:	dec00204 	addi	sp,sp,8
 8215504:	f800283a 	ret

08215508 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
 8215508:	deffff04 	addi	sp,sp,-4
 821550c:	df000015 	stw	fp,0(sp)
 8215510:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
 8215514:	d0a06b43 	ldbu	r2,-32339(gp)
 8215518:	10803fcc 	andi	r2,r2,255
 821551c:	10800058 	cmpnei	r2,r2,1
 8215520:	1000071e 	bne	r2,zero,8215540 <OSIntEnter+0x38>
        if (OSIntNesting < 255u) {
 8215524:	d0a07903 	ldbu	r2,-32284(gp)
 8215528:	10803fcc 	andi	r2,r2,255
 821552c:	10803fe0 	cmpeqi	r2,r2,255
 8215530:	1000031e 	bne	r2,zero,8215540 <OSIntEnter+0x38>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
 8215534:	d0a07903 	ldbu	r2,-32284(gp)
 8215538:	10800044 	addi	r2,r2,1
 821553c:	d0a07905 	stb	r2,-32284(gp)
        }
    }
}
 8215540:	0001883a 	nop
 8215544:	e037883a 	mov	sp,fp
 8215548:	df000017 	ldw	fp,0(sp)
 821554c:	dec00104 	addi	sp,sp,4
 8215550:	f800283a 	ret

08215554 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
 8215554:	defffb04 	addi	sp,sp,-20
 8215558:	dfc00415 	stw	ra,16(sp)
 821555c:	df000315 	stw	fp,12(sp)
 8215560:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 8215564:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
 8215568:	d0a06b43 	ldbu	r2,-32339(gp)
 821556c:	10803fcc 	andi	r2,r2,255
 8215570:	10800058 	cmpnei	r2,r2,1
 8215574:	10002f1e 	bne	r2,zero,8215634 <OSIntExit+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8215578:	0005303a 	rdctl	r2,status
 821557c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8215580:	e0ffff17 	ldw	r3,-4(fp)
 8215584:	00bfff84 	movi	r2,-2
 8215588:	1884703a 	and	r2,r3,r2
 821558c:	1001703a 	wrctl	status,r2
  
  return context;
 8215590:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
 8215594:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
 8215598:	d0a07903 	ldbu	r2,-32284(gp)
 821559c:	10803fcc 	andi	r2,r2,255
 82155a0:	10000326 	beq	r2,zero,82155b0 <OSIntExit+0x5c>
            OSIntNesting--;
 82155a4:	d0a07903 	ldbu	r2,-32284(gp)
 82155a8:	10bfffc4 	addi	r2,r2,-1
 82155ac:	d0a07905 	stb	r2,-32284(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
 82155b0:	d0a07903 	ldbu	r2,-32284(gp)
 82155b4:	10803fcc 	andi	r2,r2,255
 82155b8:	10001a1e 	bne	r2,zero,8215624 <OSIntExit+0xd0>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
 82155bc:	d0a06b03 	ldbu	r2,-32340(gp)
 82155c0:	10803fcc 	andi	r2,r2,255
 82155c4:	1000171e 	bne	r2,zero,8215624 <OSIntExit+0xd0>
                OS_SchedNew();
 82155c8:	82166500 	call	8216650 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
 82155cc:	d0e06d03 	ldbu	r3,-32332(gp)
 82155d0:	d0a06d43 	ldbu	r2,-32331(gp)
 82155d4:	18c03fcc 	andi	r3,r3,255
 82155d8:	10803fcc 	andi	r2,r2,255
 82155dc:	18801126 	beq	r3,r2,8215624 <OSIntExit+0xd0>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
 82155e0:	d0a06d03 	ldbu	r2,-32332(gp)
 82155e4:	10c03fcc 	andi	r3,r2,255
 82155e8:	008209b4 	movhi	r2,2086
 82155ec:	10b6cb04 	addi	r2,r2,-9428
 82155f0:	18c7883a 	add	r3,r3,r3
 82155f4:	18c7883a 	add	r3,r3,r3
 82155f8:	10c5883a 	add	r2,r2,r3
 82155fc:	10800017 	ldw	r2,0(r2)
 8215600:	d0a07515 	stw	r2,-32300(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
 8215604:	d0a07517 	ldw	r2,-32300(gp)
 8215608:	10c00e17 	ldw	r3,56(r2)
 821560c:	18c00044 	addi	r3,r3,1
 8215610:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
 8215614:	d0a07017 	ldw	r2,-32320(gp)
 8215618:	10800044 	addi	r2,r2,1
 821561c:	d0a07015 	stw	r2,-32320(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
 8215620:	823cd100 	call	823cd10 <OSCtxSw>
 8215624:	e0bffd17 	ldw	r2,-12(fp)
 8215628:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821562c:	e0bffe17 	ldw	r2,-8(fp)
 8215630:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 8215634:	0001883a 	nop
 8215638:	e037883a 	mov	sp,fp
 821563c:	dfc00117 	ldw	ra,4(sp)
 8215640:	df000017 	ldw	fp,0(sp)
 8215644:	dec00204 	addi	sp,sp,8
 8215648:	f800283a 	ret

0821564c <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
 821564c:	defffc04 	addi	sp,sp,-16
 8215650:	df000315 	stw	fp,12(sp)
 8215654:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8215658:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
 821565c:	d0a06b43 	ldbu	r2,-32339(gp)
 8215660:	10803fcc 	andi	r2,r2,255
 8215664:	10800058 	cmpnei	r2,r2,1
 8215668:	1000161e 	bne	r2,zero,82156c4 <OSSchedLock+0x78>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821566c:	0005303a 	rdctl	r2,status
 8215670:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8215674:	e0ffff17 	ldw	r3,-4(fp)
 8215678:	00bfff84 	movi	r2,-2
 821567c:	1884703a 	and	r2,r3,r2
 8215680:	1001703a 	wrctl	status,r2
  
  return context;
 8215684:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
 8215688:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
 821568c:	d0a07903 	ldbu	r2,-32284(gp)
 8215690:	10803fcc 	andi	r2,r2,255
 8215694:	1000071e 	bne	r2,zero,82156b4 <OSSchedLock+0x68>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
 8215698:	d0a06b03 	ldbu	r2,-32340(gp)
 821569c:	10803fcc 	andi	r2,r2,255
 82156a0:	10803fe0 	cmpeqi	r2,r2,255
 82156a4:	1000031e 	bne	r2,zero,82156b4 <OSSchedLock+0x68>
                OSLockNesting++;                 /* Increment lock nesting level                       */
 82156a8:	d0a06b03 	ldbu	r2,-32340(gp)
 82156ac:	10800044 	addi	r2,r2,1
 82156b0:	d0a06b05 	stb	r2,-32340(gp)
 82156b4:	e0bffd17 	ldw	r2,-12(fp)
 82156b8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82156bc:	e0bffe17 	ldw	r2,-8(fp)
 82156c0:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 82156c4:	0001883a 	nop
 82156c8:	e037883a 	mov	sp,fp
 82156cc:	df000017 	ldw	fp,0(sp)
 82156d0:	dec00104 	addi	sp,sp,4
 82156d4:	f800283a 	ret

082156d8 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
 82156d8:	defff804 	addi	sp,sp,-32
 82156dc:	dfc00715 	stw	ra,28(sp)
 82156e0:	df000615 	stw	fp,24(sp)
 82156e4:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 82156e8:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
 82156ec:	d0a06b43 	ldbu	r2,-32339(gp)
 82156f0:	10803fcc 	andi	r2,r2,255
 82156f4:	10800058 	cmpnei	r2,r2,1
 82156f8:	1000281e 	bne	r2,zero,821579c <OSSchedUnlock+0xc4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82156fc:	0005303a 	rdctl	r2,status
 8215700:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8215704:	e0ffff17 	ldw	r3,-4(fp)
 8215708:	00bfff84 	movi	r2,-2
 821570c:	1884703a 	and	r2,r3,r2
 8215710:	1001703a 	wrctl	status,r2
  
  return context;
 8215714:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
 8215718:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
 821571c:	d0a06b03 	ldbu	r2,-32340(gp)
 8215720:	10803fcc 	andi	r2,r2,255
 8215724:	10001926 	beq	r2,zero,821578c <OSSchedUnlock+0xb4>
            OSLockNesting--;                               /* Decrement lock nesting level             */
 8215728:	d0a06b03 	ldbu	r2,-32340(gp)
 821572c:	10bfffc4 	addi	r2,r2,-1
 8215730:	d0a06b05 	stb	r2,-32340(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
 8215734:	d0a06b03 	ldbu	r2,-32340(gp)
 8215738:	10803fcc 	andi	r2,r2,255
 821573c:	10000e1e 	bne	r2,zero,8215778 <OSSchedUnlock+0xa0>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
 8215740:	d0a07903 	ldbu	r2,-32284(gp)
 8215744:	10803fcc 	andi	r2,r2,255
 8215748:	1000061e 	bne	r2,zero,8215764 <OSSchedUnlock+0x8c>
 821574c:	e0bffa17 	ldw	r2,-24(fp)
 8215750:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8215754:	e0bffb17 	ldw	r2,-20(fp)
 8215758:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
 821575c:	82165800 	call	8216580 <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
 8215760:	00000e06 	br	821579c <OSSchedUnlock+0xc4>
 8215764:	e0bffa17 	ldw	r2,-24(fp)
 8215768:	e0bffc15 	stw	r2,-16(fp)
 821576c:	e0bffc17 	ldw	r2,-16(fp)
 8215770:	1001703a 	wrctl	status,r2
 8215774:	00000906 	br	821579c <OSSchedUnlock+0xc4>
 8215778:	e0bffa17 	ldw	r2,-24(fp)
 821577c:	e0bffd15 	stw	r2,-12(fp)
 8215780:	e0bffd17 	ldw	r2,-12(fp)
 8215784:	1001703a 	wrctl	status,r2
 8215788:	00000406 	br	821579c <OSSchedUnlock+0xc4>
 821578c:	e0bffa17 	ldw	r2,-24(fp)
 8215790:	e0bffe15 	stw	r2,-8(fp)
 8215794:	e0bffe17 	ldw	r2,-8(fp)
 8215798:	1001703a 	wrctl	status,r2
 821579c:	0001883a 	nop
 82157a0:	e037883a 	mov	sp,fp
 82157a4:	dfc00117 	ldw	ra,4(sp)
 82157a8:	df000017 	ldw	fp,0(sp)
 82157ac:	dec00204 	addi	sp,sp,8
 82157b0:	f800283a 	ret

082157b4 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
 82157b4:	defffe04 	addi	sp,sp,-8
 82157b8:	dfc00115 	stw	ra,4(sp)
 82157bc:	df000015 	stw	fp,0(sp)
 82157c0:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
 82157c4:	d0a06b43 	ldbu	r2,-32339(gp)
 82157c8:	10803fcc 	andi	r2,r2,255
 82157cc:	10000f1e 	bne	r2,zero,821580c <OSStart+0x58>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
 82157d0:	82166500 	call	8216650 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
 82157d4:	d0a06d03 	ldbu	r2,-32332(gp)
 82157d8:	d0a06d45 	stb	r2,-32331(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
 82157dc:	d0a06d03 	ldbu	r2,-32332(gp)
 82157e0:	10c03fcc 	andi	r3,r2,255
 82157e4:	008209b4 	movhi	r2,2086
 82157e8:	10b6cb04 	addi	r2,r2,-9428
 82157ec:	18c7883a 	add	r3,r3,r3
 82157f0:	18c7883a 	add	r3,r3,r3
 82157f4:	10c5883a 	add	r2,r2,r3
 82157f8:	10800017 	ldw	r2,0(r2)
 82157fc:	d0a07515 	stw	r2,-32300(gp)
        OSTCBCur      = OSTCBHighRdy;
 8215800:	d0a07517 	ldw	r2,-32300(gp)
 8215804:	d0a07a15 	stw	r2,-32280(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
 8215808:	823cd9c0 	call	823cd9c <OSStartHighRdy>
    }
}
 821580c:	0001883a 	nop
 8215810:	e037883a 	mov	sp,fp
 8215814:	dfc00117 	ldw	ra,4(sp)
 8215818:	df000017 	ldw	fp,0(sp)
 821581c:	dec00204 	addi	sp,sp,8
 8215820:	f800283a 	ret

08215824 <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
 8215824:	defff904 	addi	sp,sp,-28
 8215828:	dfc00615 	stw	ra,24(sp)
 821582c:	df000515 	stw	fp,20(sp)
 8215830:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8215834:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
 8215838:	01000084 	movi	r4,2
 821583c:	821bf340 	call	821bf34 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8215840:	0005303a 	rdctl	r2,status
 8215844:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8215848:	e0fffc17 	ldw	r3,-16(fp)
 821584c:	00bfff84 	movi	r2,-2
 8215850:	1884703a 	and	r2,r3,r2
 8215854:	1001703a 	wrctl	status,r2
  
  return context;
 8215858:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
 821585c:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
 8215860:	d0206c15 	stw	zero,-32336(gp)
 8215864:	e0bffb17 	ldw	r2,-20(fp)
 8215868:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821586c:	e0bffd17 	ldw	r2,-12(fp)
 8215870:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
 8215874:	01000284 	movi	r4,10
 8215878:	821bf340 	call	821bf34 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821587c:	0005303a 	rdctl	r2,status
 8215880:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8215884:	e0fffe17 	ldw	r3,-8(fp)
 8215888:	00bfff84 	movi	r2,-2
 821588c:	1884703a 	and	r2,r3,r2
 8215890:	1001703a 	wrctl	status,r2
  
  return context;
 8215894:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
 8215898:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
 821589c:	d0a06c17 	ldw	r2,-32336(gp)
 82158a0:	d0a07115 	stw	r2,-32316(gp)
    OSStatRdy    = OS_TRUE;
 82158a4:	00800044 	movi	r2,1
 82158a8:	d0a07d05 	stb	r2,-32268(gp)
 82158ac:	e0bffb17 	ldw	r2,-20(fp)
 82158b0:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82158b4:	e0bfff17 	ldw	r2,-4(fp)
 82158b8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 82158bc:	0001883a 	nop
 82158c0:	e037883a 	mov	sp,fp
 82158c4:	dfc00117 	ldw	ra,4(sp)
 82158c8:	df000017 	ldw	fp,0(sp)
 82158cc:	dec00204 	addi	sp,sp,8
 82158d0:	f800283a 	ret

082158d4 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
 82158d4:	defff704 	addi	sp,sp,-36
 82158d8:	dfc00815 	stw	ra,32(sp)
 82158dc:	df000715 	stw	fp,28(sp)
 82158e0:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 82158e4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
 82158e8:	823cfc40 	call	823cfc4 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82158ec:	0005303a 	rdctl	r2,status
 82158f0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82158f4:	e0fffd17 	ldw	r3,-12(fp)
 82158f8:	00bfff84 	movi	r2,-2
 82158fc:	1884703a 	and	r2,r3,r2
 8215900:	1001703a 	wrctl	status,r2
  
  return context;
 8215904:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
 8215908:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
 821590c:	d0a07b17 	ldw	r2,-32276(gp)
 8215910:	10800044 	addi	r2,r2,1
 8215914:	d0a07b15 	stw	r2,-32276(gp)
 8215918:	e0bffb17 	ldw	r2,-20(fp)
 821591c:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8215920:	e0bfff17 	ldw	r2,-4(fp)
 8215924:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
 8215928:	d0a06b43 	ldbu	r2,-32339(gp)
 821592c:	10803fcc 	andi	r2,r2,255
 8215930:	10800058 	cmpnei	r2,r2,1
 8215934:	10006a1e 	bne	r2,zero,8215ae0 <OSTimeTick+0x20c>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
 8215938:	d0a06f03 	ldbu	r2,-32324(gp)
 821593c:	10803fcc 	andi	r2,r2,255
 8215940:	10c00060 	cmpeqi	r3,r2,1
 8215944:	1800061e 	bne	r3,zero,8215960 <OSTimeTick+0x8c>
 8215948:	10c000a0 	cmpeqi	r3,r2,2
 821594c:	1800061e 	bne	r3,zero,8215968 <OSTimeTick+0x94>
 8215950:	10000a1e 	bne	r2,zero,821597c <OSTimeTick+0xa8>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
 8215954:	00800044 	movi	r2,1
 8215958:	e0bffa05 	stb	r2,-24(fp)
                 break;
 821595c:	00000b06 	br	821598c <OSTimeTick+0xb8>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
 8215960:	e03ffa05 	stb	zero,-24(fp)
                 break;
 8215964:	00000906 	br	821598c <OSTimeTick+0xb8>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
 8215968:	00800044 	movi	r2,1
 821596c:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
 8215970:	00800044 	movi	r2,1
 8215974:	d0a06f05 	stb	r2,-32324(gp)
                 break;
 8215978:	00000406 	br	821598c <OSTimeTick+0xb8>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
 821597c:	00800044 	movi	r2,1
 8215980:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
 8215984:	d0206f05 	stb	zero,-32324(gp)
                 break;
 8215988:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
 821598c:	e0bffa03 	ldbu	r2,-24(fp)
 8215990:	10005226 	beq	r2,zero,8215adc <OSTimeTick+0x208>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
 8215994:	d0a06e17 	ldw	r2,-32328(gp)
 8215998:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 821599c:	00004906 	br	8215ac4 <OSTimeTick+0x1f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82159a0:	0005303a 	rdctl	r2,status
 82159a4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82159a8:	e0fffc17 	ldw	r3,-16(fp)
 82159ac:	00bfff84 	movi	r2,-2
 82159b0:	1884703a 	and	r2,r3,r2
 82159b4:	1001703a 	wrctl	status,r2
  
  return context;
 82159b8:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
 82159bc:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
 82159c0:	e0bff917 	ldw	r2,-28(fp)
 82159c4:	10800b8b 	ldhu	r2,46(r2)
 82159c8:	10bfffcc 	andi	r2,r2,65535
 82159cc:	10003626 	beq	r2,zero,8215aa8 <OSTimeTick+0x1d4>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
 82159d0:	e0bff917 	ldw	r2,-28(fp)
 82159d4:	10800b8b 	ldhu	r2,46(r2)
 82159d8:	10bfffc4 	addi	r2,r2,-1
 82159dc:	1007883a 	mov	r3,r2
 82159e0:	e0bff917 	ldw	r2,-28(fp)
 82159e4:	10c00b8d 	sth	r3,46(r2)
 82159e8:	e0bff917 	ldw	r2,-28(fp)
 82159ec:	10800b8b 	ldhu	r2,46(r2)
 82159f0:	10bfffcc 	andi	r2,r2,65535
 82159f4:	10002c1e 	bne	r2,zero,8215aa8 <OSTimeTick+0x1d4>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 82159f8:	e0bff917 	ldw	r2,-28(fp)
 82159fc:	10800c03 	ldbu	r2,48(r2)
 8215a00:	10803fcc 	andi	r2,r2,255
 8215a04:	10800dcc 	andi	r2,r2,55
 8215a08:	10000b26 	beq	r2,zero,8215a38 <OSTimeTick+0x164>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
 8215a0c:	e0bff917 	ldw	r2,-28(fp)
 8215a10:	10c00c03 	ldbu	r3,48(r2)
 8215a14:	00bff204 	movi	r2,-56
 8215a18:	1884703a 	and	r2,r3,r2
 8215a1c:	1007883a 	mov	r3,r2
 8215a20:	e0bff917 	ldw	r2,-28(fp)
 8215a24:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
 8215a28:	e0bff917 	ldw	r2,-28(fp)
 8215a2c:	00c00044 	movi	r3,1
 8215a30:	10c00c45 	stb	r3,49(r2)
 8215a34:	00000206 	br	8215a40 <OSTimeTick+0x16c>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 8215a38:	e0bff917 	ldw	r2,-28(fp)
 8215a3c:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
 8215a40:	e0bff917 	ldw	r2,-28(fp)
 8215a44:	10800c03 	ldbu	r2,48(r2)
 8215a48:	10803fcc 	andi	r2,r2,255
 8215a4c:	1080020c 	andi	r2,r2,8
 8215a50:	1000151e 	bne	r2,zero,8215aa8 <OSTimeTick+0x1d4>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
 8215a54:	e0bff917 	ldw	r2,-28(fp)
 8215a58:	10c00d83 	ldbu	r3,54(r2)
 8215a5c:	d0a07703 	ldbu	r2,-32292(gp)
 8215a60:	1884b03a 	or	r2,r3,r2
 8215a64:	d0a07705 	stb	r2,-32292(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 8215a68:	e0bff917 	ldw	r2,-28(fp)
 8215a6c:	10800d03 	ldbu	r2,52(r2)
 8215a70:	10c03fcc 	andi	r3,r2,255
 8215a74:	e0bff917 	ldw	r2,-28(fp)
 8215a78:	10800d03 	ldbu	r2,52(r2)
 8215a7c:	11003fcc 	andi	r4,r2,255
 8215a80:	d0a07744 	addi	r2,gp,-32291
 8215a84:	2085883a 	add	r2,r4,r2
 8215a88:	11000003 	ldbu	r4,0(r2)
 8215a8c:	e0bff917 	ldw	r2,-28(fp)
 8215a90:	10800d43 	ldbu	r2,53(r2)
 8215a94:	2084b03a 	or	r2,r4,r2
 8215a98:	1009883a 	mov	r4,r2
 8215a9c:	d0a07744 	addi	r2,gp,-32291
 8215aa0:	1885883a 	add	r2,r3,r2
 8215aa4:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
 8215aa8:	e0bff917 	ldw	r2,-28(fp)
 8215aac:	10800517 	ldw	r2,20(r2)
 8215ab0:	e0bff915 	stw	r2,-28(fp)
 8215ab4:	e0bffb17 	ldw	r2,-20(fp)
 8215ab8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8215abc:	e0bffe17 	ldw	r2,-8(fp)
 8215ac0:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 8215ac4:	e0bff917 	ldw	r2,-28(fp)
 8215ac8:	10800c83 	ldbu	r2,50(r2)
 8215acc:	10803fcc 	andi	r2,r2,255
 8215ad0:	10800518 	cmpnei	r2,r2,20
 8215ad4:	103fb21e 	bne	r2,zero,82159a0 <OSTimeTick+0xcc>
 8215ad8:	00000106 	br	8215ae0 <OSTimeTick+0x20c>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
 8215adc:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
 8215ae0:	e037883a 	mov	sp,fp
 8215ae4:	dfc00117 	ldw	ra,4(sp)
 8215ae8:	df000017 	ldw	fp,0(sp)
 8215aec:	dec00204 	addi	sp,sp,8
 8215af0:	f800283a 	ret

08215af4 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
 8215af4:	deffff04 	addi	sp,sp,-4
 8215af8:	df000015 	stw	fp,0(sp)
 8215afc:	d839883a 	mov	fp,sp
    return (OS_VERSION);
 8215b00:	00804784 	movi	r2,286
}
 8215b04:	e037883a 	mov	sp,fp
 8215b08:	df000017 	ldw	fp,0(sp)
 8215b0c:	dec00104 	addi	sp,sp,4
 8215b10:	f800283a 	ret

08215b14 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
 8215b14:	deffff04 	addi	sp,sp,-4
 8215b18:	df000015 	stw	fp,0(sp)
 8215b1c:	d839883a 	mov	fp,sp
}
 8215b20:	0001883a 	nop
 8215b24:	e037883a 	mov	sp,fp
 8215b28:	df000017 	ldw	fp,0(sp)
 8215b2c:	dec00104 	addi	sp,sp,4
 8215b30:	f800283a 	ret

08215b34 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
 8215b34:	defff804 	addi	sp,sp,-32
 8215b38:	dfc00715 	stw	ra,28(sp)
 8215b3c:	df000615 	stw	fp,24(sp)
 8215b40:	df000604 	addi	fp,sp,24
 8215b44:	e13ffc15 	stw	r4,-16(fp)
 8215b48:	e17ffd15 	stw	r5,-12(fp)
 8215b4c:	3007883a 	mov	r3,r6
 8215b50:	3805883a 	mov	r2,r7
 8215b54:	e0fffe05 	stb	r3,-8(fp)
 8215b58:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
 8215b5c:	e0bffc17 	ldw	r2,-16(fp)
 8215b60:	10800283 	ldbu	r2,10(r2)
 8215b64:	10c03fcc 	andi	r3,r2,255
 8215b68:	00820974 	movhi	r2,2085
 8215b6c:	10b7a204 	addi	r2,r2,-8568
 8215b70:	10c5883a 	add	r2,r2,r3
 8215b74:	10800003 	ldbu	r2,0(r2)
 8215b78:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
 8215b7c:	e0bffa03 	ldbu	r2,-24(fp)
 8215b80:	e0fffc17 	ldw	r3,-16(fp)
 8215b84:	1885883a 	add	r2,r3,r2
 8215b88:	108002c4 	addi	r2,r2,11
 8215b8c:	10800003 	ldbu	r2,0(r2)
 8215b90:	10c03fcc 	andi	r3,r2,255
 8215b94:	00820974 	movhi	r2,2085
 8215b98:	10b7a204 	addi	r2,r2,-8568
 8215b9c:	10c5883a 	add	r2,r2,r3
 8215ba0:	10800003 	ldbu	r2,0(r2)
 8215ba4:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
 8215ba8:	e0bffa03 	ldbu	r2,-24(fp)
 8215bac:	100490fa 	slli	r2,r2,3
 8215bb0:	1007883a 	mov	r3,r2
 8215bb4:	e0bffa43 	ldbu	r2,-23(fp)
 8215bb8:	1885883a 	add	r2,r3,r2
 8215bbc:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
 8215bc0:	e0fffa83 	ldbu	r3,-22(fp)
 8215bc4:	008209b4 	movhi	r2,2086
 8215bc8:	10b6cb04 	addi	r2,r2,-9428
 8215bcc:	18c7883a 	add	r3,r3,r3
 8215bd0:	18c7883a 	add	r3,r3,r3
 8215bd4:	10c5883a 	add	r2,r2,r3
 8215bd8:	10800017 	ldw	r2,0(r2)
 8215bdc:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
 8215be0:	e0bffb17 	ldw	r2,-20(fp)
 8215be4:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
 8215be8:	e0bffb17 	ldw	r2,-20(fp)
 8215bec:	e0fffd17 	ldw	r3,-12(fp)
 8215bf0:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
 8215bf4:	e0bffb17 	ldw	r2,-20(fp)
 8215bf8:	10800c03 	ldbu	r2,48(r2)
 8215bfc:	1007883a 	mov	r3,r2
 8215c00:	e0bffe03 	ldbu	r2,-8(fp)
 8215c04:	0084303a 	nor	r2,zero,r2
 8215c08:	1884703a 	and	r2,r3,r2
 8215c0c:	1007883a 	mov	r3,r2
 8215c10:	e0bffb17 	ldw	r2,-20(fp)
 8215c14:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
 8215c18:	e0bffb17 	ldw	r2,-20(fp)
 8215c1c:	e0ffff03 	ldbu	r3,-4(fp)
 8215c20:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
 8215c24:	e0bffb17 	ldw	r2,-20(fp)
 8215c28:	10800c03 	ldbu	r2,48(r2)
 8215c2c:	10803fcc 	andi	r2,r2,255
 8215c30:	1080020c 	andi	r2,r2,8
 8215c34:	1000111e 	bne	r2,zero,8215c7c <OS_EventTaskRdy+0x148>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
 8215c38:	e0bffb17 	ldw	r2,-20(fp)
 8215c3c:	10c00d83 	ldbu	r3,54(r2)
 8215c40:	d0a07703 	ldbu	r2,-32292(gp)
 8215c44:	1884b03a 	or	r2,r3,r2
 8215c48:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
 8215c4c:	e0fffa03 	ldbu	r3,-24(fp)
 8215c50:	e13ffa03 	ldbu	r4,-24(fp)
 8215c54:	d0a07744 	addi	r2,gp,-32291
 8215c58:	2085883a 	add	r2,r4,r2
 8215c5c:	11000003 	ldbu	r4,0(r2)
 8215c60:	e0bffb17 	ldw	r2,-20(fp)
 8215c64:	10800d43 	ldbu	r2,53(r2)
 8215c68:	2084b03a 	or	r2,r4,r2
 8215c6c:	1009883a 	mov	r4,r2
 8215c70:	d0a07744 	addi	r2,gp,-32291
 8215c74:	1885883a 	add	r2,r3,r2
 8215c78:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
 8215c7c:	e17ffc17 	ldw	r5,-16(fp)
 8215c80:	e13ffb17 	ldw	r4,-20(fp)
 8215c84:	8215f2c0 	call	8215f2c <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
 8215c88:	e0bffb17 	ldw	r2,-20(fp)
 8215c8c:	10800817 	ldw	r2,32(r2)
 8215c90:	10000826 	beq	r2,zero,8215cb4 <OS_EventTaskRdy+0x180>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 8215c94:	e0bffb17 	ldw	r2,-20(fp)
 8215c98:	10800817 	ldw	r2,32(r2)
 8215c9c:	100b883a 	mov	r5,r2
 8215ca0:	e13ffb17 	ldw	r4,-20(fp)
 8215ca4:	8215fe40 	call	8215fe4 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
 8215ca8:	e0bffb17 	ldw	r2,-20(fp)
 8215cac:	e0fffc17 	ldw	r3,-16(fp)
 8215cb0:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
 8215cb4:	e0bffa83 	ldbu	r2,-22(fp)
}
 8215cb8:	e037883a 	mov	sp,fp
 8215cbc:	dfc00117 	ldw	ra,4(sp)
 8215cc0:	df000017 	ldw	fp,0(sp)
 8215cc4:	dec00204 	addi	sp,sp,8
 8215cc8:	f800283a 	ret

08215ccc <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
 8215ccc:	defffd04 	addi	sp,sp,-12
 8215cd0:	df000215 	stw	fp,8(sp)
 8215cd4:	df000204 	addi	fp,sp,8
 8215cd8:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
 8215cdc:	d0a07a17 	ldw	r2,-32280(gp)
 8215ce0:	e0ffff17 	ldw	r3,-4(fp)
 8215ce4:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
 8215ce8:	d0a07a17 	ldw	r2,-32280(gp)
 8215cec:	10800d03 	ldbu	r2,52(r2)
 8215cf0:	10803fcc 	andi	r2,r2,255
 8215cf4:	d0e07a17 	ldw	r3,-32280(gp)
 8215cf8:	18c00d03 	ldbu	r3,52(r3)
 8215cfc:	18c03fcc 	andi	r3,r3,255
 8215d00:	e13fff17 	ldw	r4,-4(fp)
 8215d04:	20c7883a 	add	r3,r4,r3
 8215d08:	18c002c4 	addi	r3,r3,11
 8215d0c:	19000003 	ldbu	r4,0(r3)
 8215d10:	d0e07a17 	ldw	r3,-32280(gp)
 8215d14:	18c00d43 	ldbu	r3,53(r3)
 8215d18:	20c6b03a 	or	r3,r4,r3
 8215d1c:	1809883a 	mov	r4,r3
 8215d20:	e0ffff17 	ldw	r3,-4(fp)
 8215d24:	1885883a 	add	r2,r3,r2
 8215d28:	108002c4 	addi	r2,r2,11
 8215d2c:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 8215d30:	e0bfff17 	ldw	r2,-4(fp)
 8215d34:	10c00283 	ldbu	r3,10(r2)
 8215d38:	d0a07a17 	ldw	r2,-32280(gp)
 8215d3c:	10800d83 	ldbu	r2,54(r2)
 8215d40:	1884b03a 	or	r2,r3,r2
 8215d44:	1007883a 	mov	r3,r2
 8215d48:	e0bfff17 	ldw	r2,-4(fp)
 8215d4c:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 8215d50:	d0a07a17 	ldw	r2,-32280(gp)
 8215d54:	10800d03 	ldbu	r2,52(r2)
 8215d58:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 8215d5c:	e0fffe03 	ldbu	r3,-8(fp)
 8215d60:	e13ffe03 	ldbu	r4,-8(fp)
 8215d64:	d0a07744 	addi	r2,gp,-32291
 8215d68:	2085883a 	add	r2,r4,r2
 8215d6c:	10800003 	ldbu	r2,0(r2)
 8215d70:	1009883a 	mov	r4,r2
 8215d74:	d0a07a17 	ldw	r2,-32280(gp)
 8215d78:	10800d43 	ldbu	r2,53(r2)
 8215d7c:	0084303a 	nor	r2,zero,r2
 8215d80:	2084703a 	and	r2,r4,r2
 8215d84:	1009883a 	mov	r4,r2
 8215d88:	d0a07744 	addi	r2,gp,-32291
 8215d8c:	1885883a 	add	r2,r3,r2
 8215d90:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
 8215d94:	e0fffe03 	ldbu	r3,-8(fp)
 8215d98:	d0a07744 	addi	r2,gp,-32291
 8215d9c:	1885883a 	add	r2,r3,r2
 8215da0:	10800003 	ldbu	r2,0(r2)
 8215da4:	10803fcc 	andi	r2,r2,255
 8215da8:	1000071e 	bne	r2,zero,8215dc8 <OS_EventTaskWait+0xfc>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 8215dac:	d0a07a17 	ldw	r2,-32280(gp)
 8215db0:	10800d83 	ldbu	r2,54(r2)
 8215db4:	0084303a 	nor	r2,zero,r2
 8215db8:	1007883a 	mov	r3,r2
 8215dbc:	d0a07703 	ldbu	r2,-32292(gp)
 8215dc0:	1884703a 	and	r2,r3,r2
 8215dc4:	d0a07705 	stb	r2,-32292(gp)
    }
}
 8215dc8:	0001883a 	nop
 8215dcc:	e037883a 	mov	sp,fp
 8215dd0:	df000017 	ldw	fp,0(sp)
 8215dd4:	dec00104 	addi	sp,sp,4
 8215dd8:	f800283a 	ret

08215ddc <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
 8215ddc:	defffb04 	addi	sp,sp,-20
 8215de0:	df000415 	stw	fp,16(sp)
 8215de4:	df000404 	addi	fp,sp,16
 8215de8:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
 8215dec:	d0a07a17 	ldw	r2,-32280(gp)
 8215df0:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
 8215df4:	d0a07a17 	ldw	r2,-32280(gp)
 8215df8:	e0ffff17 	ldw	r3,-4(fp)
 8215dfc:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
 8215e00:	e0bfff17 	ldw	r2,-4(fp)
 8215e04:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
 8215e08:	e0bffc17 	ldw	r2,-16(fp)
 8215e0c:	10800017 	ldw	r2,0(r2)
 8215e10:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 8215e14:	00002006 	br	8215e98 <OS_EventTaskWaitMulti+0xbc>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
 8215e18:	d0a07a17 	ldw	r2,-32280(gp)
 8215e1c:	10800d03 	ldbu	r2,52(r2)
 8215e20:	10803fcc 	andi	r2,r2,255
 8215e24:	d0e07a17 	ldw	r3,-32280(gp)
 8215e28:	18c00d03 	ldbu	r3,52(r3)
 8215e2c:	18c03fcc 	andi	r3,r3,255
 8215e30:	e13ffd17 	ldw	r4,-12(fp)
 8215e34:	20c7883a 	add	r3,r4,r3
 8215e38:	18c002c4 	addi	r3,r3,11
 8215e3c:	19000003 	ldbu	r4,0(r3)
 8215e40:	d0e07a17 	ldw	r3,-32280(gp)
 8215e44:	18c00d43 	ldbu	r3,53(r3)
 8215e48:	20c6b03a 	or	r3,r4,r3
 8215e4c:	1809883a 	mov	r4,r3
 8215e50:	e0fffd17 	ldw	r3,-12(fp)
 8215e54:	1885883a 	add	r2,r3,r2
 8215e58:	108002c4 	addi	r2,r2,11
 8215e5c:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 8215e60:	e0bffd17 	ldw	r2,-12(fp)
 8215e64:	10c00283 	ldbu	r3,10(r2)
 8215e68:	d0a07a17 	ldw	r2,-32280(gp)
 8215e6c:	10800d83 	ldbu	r2,54(r2)
 8215e70:	1884b03a 	or	r2,r3,r2
 8215e74:	1007883a 	mov	r3,r2
 8215e78:	e0bffd17 	ldw	r2,-12(fp)
 8215e7c:	10c00285 	stb	r3,10(r2)
        pevents++;
 8215e80:	e0bffc17 	ldw	r2,-16(fp)
 8215e84:	10800104 	addi	r2,r2,4
 8215e88:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
 8215e8c:	e0bffc17 	ldw	r2,-16(fp)
 8215e90:	10800017 	ldw	r2,0(r2)
 8215e94:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 8215e98:	e0bffd17 	ldw	r2,-12(fp)
 8215e9c:	103fde1e 	bne	r2,zero,8215e18 <OS_EventTaskWaitMulti+0x3c>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 8215ea0:	d0a07a17 	ldw	r2,-32280(gp)
 8215ea4:	10800d03 	ldbu	r2,52(r2)
 8215ea8:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 8215eac:	e0fffe03 	ldbu	r3,-8(fp)
 8215eb0:	e13ffe03 	ldbu	r4,-8(fp)
 8215eb4:	d0a07744 	addi	r2,gp,-32291
 8215eb8:	2085883a 	add	r2,r4,r2
 8215ebc:	10800003 	ldbu	r2,0(r2)
 8215ec0:	1009883a 	mov	r4,r2
 8215ec4:	d0a07a17 	ldw	r2,-32280(gp)
 8215ec8:	10800d43 	ldbu	r2,53(r2)
 8215ecc:	0084303a 	nor	r2,zero,r2
 8215ed0:	2084703a 	and	r2,r4,r2
 8215ed4:	1009883a 	mov	r4,r2
 8215ed8:	d0a07744 	addi	r2,gp,-32291
 8215edc:	1885883a 	add	r2,r3,r2
 8215ee0:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
 8215ee4:	e0fffe03 	ldbu	r3,-8(fp)
 8215ee8:	d0a07744 	addi	r2,gp,-32291
 8215eec:	1885883a 	add	r2,r3,r2
 8215ef0:	10800003 	ldbu	r2,0(r2)
 8215ef4:	10803fcc 	andi	r2,r2,255
 8215ef8:	1000071e 	bne	r2,zero,8215f18 <OS_EventTaskWaitMulti+0x13c>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 8215efc:	d0a07a17 	ldw	r2,-32280(gp)
 8215f00:	10800d83 	ldbu	r2,54(r2)
 8215f04:	0084303a 	nor	r2,zero,r2
 8215f08:	1007883a 	mov	r3,r2
 8215f0c:	d0a07703 	ldbu	r2,-32292(gp)
 8215f10:	1884703a 	and	r2,r3,r2
 8215f14:	d0a07705 	stb	r2,-32292(gp)
    }
}
 8215f18:	0001883a 	nop
 8215f1c:	e037883a 	mov	sp,fp
 8215f20:	df000017 	ldw	fp,0(sp)
 8215f24:	dec00104 	addi	sp,sp,4
 8215f28:	f800283a 	ret

08215f2c <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
 8215f2c:	defffc04 	addi	sp,sp,-16
 8215f30:	df000315 	stw	fp,12(sp)
 8215f34:	df000304 	addi	fp,sp,12
 8215f38:	e13ffe15 	stw	r4,-8(fp)
 8215f3c:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
 8215f40:	e0bffe17 	ldw	r2,-8(fp)
 8215f44:	10800d03 	ldbu	r2,52(r2)
 8215f48:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
 8215f4c:	e0bffd03 	ldbu	r2,-12(fp)
 8215f50:	e0fffd03 	ldbu	r3,-12(fp)
 8215f54:	e13fff17 	ldw	r4,-4(fp)
 8215f58:	20c7883a 	add	r3,r4,r3
 8215f5c:	18c002c4 	addi	r3,r3,11
 8215f60:	18c00003 	ldbu	r3,0(r3)
 8215f64:	1809883a 	mov	r4,r3
 8215f68:	e0fffe17 	ldw	r3,-8(fp)
 8215f6c:	18c00d43 	ldbu	r3,53(r3)
 8215f70:	00c6303a 	nor	r3,zero,r3
 8215f74:	20c6703a 	and	r3,r4,r3
 8215f78:	1809883a 	mov	r4,r3
 8215f7c:	e0ffff17 	ldw	r3,-4(fp)
 8215f80:	1885883a 	add	r2,r3,r2
 8215f84:	108002c4 	addi	r2,r2,11
 8215f88:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
 8215f8c:	e0bffd03 	ldbu	r2,-12(fp)
 8215f90:	e0ffff17 	ldw	r3,-4(fp)
 8215f94:	1885883a 	add	r2,r3,r2
 8215f98:	108002c4 	addi	r2,r2,11
 8215f9c:	10800003 	ldbu	r2,0(r2)
 8215fa0:	10803fcc 	andi	r2,r2,255
 8215fa4:	10000a1e 	bne	r2,zero,8215fd0 <OS_EventTaskRemove+0xa4>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
 8215fa8:	e0bfff17 	ldw	r2,-4(fp)
 8215fac:	10800283 	ldbu	r2,10(r2)
 8215fb0:	1007883a 	mov	r3,r2
 8215fb4:	e0bffe17 	ldw	r2,-8(fp)
 8215fb8:	10800d83 	ldbu	r2,54(r2)
 8215fbc:	0084303a 	nor	r2,zero,r2
 8215fc0:	1884703a 	and	r2,r3,r2
 8215fc4:	1007883a 	mov	r3,r2
 8215fc8:	e0bfff17 	ldw	r2,-4(fp)
 8215fcc:	10c00285 	stb	r3,10(r2)
    }
}
 8215fd0:	0001883a 	nop
 8215fd4:	e037883a 	mov	sp,fp
 8215fd8:	df000017 	ldw	fp,0(sp)
 8215fdc:	dec00104 	addi	sp,sp,4
 8215fe0:	f800283a 	ret

08215fe4 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
 8215fe4:	defffa04 	addi	sp,sp,-24
 8215fe8:	df000515 	stw	fp,20(sp)
 8215fec:	df000504 	addi	fp,sp,20
 8215ff0:	e13ffe15 	stw	r4,-8(fp)
 8215ff4:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
 8215ff8:	e0bffe17 	ldw	r2,-8(fp)
 8215ffc:	10800d03 	ldbu	r2,52(r2)
 8216000:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
 8216004:	e0bffe17 	ldw	r2,-8(fp)
 8216008:	10800d83 	ldbu	r2,54(r2)
 821600c:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
 8216010:	e0bffe17 	ldw	r2,-8(fp)
 8216014:	10800d43 	ldbu	r2,53(r2)
 8216018:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
 821601c:	e0bfff17 	ldw	r2,-4(fp)
 8216020:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
 8216024:	e0bffb17 	ldw	r2,-20(fp)
 8216028:	10800017 	ldw	r2,0(r2)
 821602c:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 8216030:	00002506 	br	82160c8 <OS_EventTaskRemoveMulti+0xe4>
        pevent->OSEventTbl[y]  &= ~bitx;
 8216034:	e0bffd03 	ldbu	r2,-12(fp)
 8216038:	e0fffd03 	ldbu	r3,-12(fp)
 821603c:	e13ffc17 	ldw	r4,-16(fp)
 8216040:	20c7883a 	add	r3,r4,r3
 8216044:	18c002c4 	addi	r3,r3,11
 8216048:	18c00003 	ldbu	r3,0(r3)
 821604c:	1809883a 	mov	r4,r3
 8216050:	e0fffd83 	ldbu	r3,-10(fp)
 8216054:	00c6303a 	nor	r3,zero,r3
 8216058:	20c6703a 	and	r3,r4,r3
 821605c:	1809883a 	mov	r4,r3
 8216060:	e0fffc17 	ldw	r3,-16(fp)
 8216064:	1885883a 	add	r2,r3,r2
 8216068:	108002c4 	addi	r2,r2,11
 821606c:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
 8216070:	e0bffd03 	ldbu	r2,-12(fp)
 8216074:	e0fffc17 	ldw	r3,-16(fp)
 8216078:	1885883a 	add	r2,r3,r2
 821607c:	108002c4 	addi	r2,r2,11
 8216080:	10800003 	ldbu	r2,0(r2)
 8216084:	10803fcc 	andi	r2,r2,255
 8216088:	1000091e 	bne	r2,zero,82160b0 <OS_EventTaskRemoveMulti+0xcc>
            pevent->OSEventGrp &= ~bity;
 821608c:	e0bffc17 	ldw	r2,-16(fp)
 8216090:	10800283 	ldbu	r2,10(r2)
 8216094:	1007883a 	mov	r3,r2
 8216098:	e0bffd43 	ldbu	r2,-11(fp)
 821609c:	0084303a 	nor	r2,zero,r2
 82160a0:	1884703a 	and	r2,r3,r2
 82160a4:	1007883a 	mov	r3,r2
 82160a8:	e0bffc17 	ldw	r2,-16(fp)
 82160ac:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
 82160b0:	e0bffb17 	ldw	r2,-20(fp)
 82160b4:	10800104 	addi	r2,r2,4
 82160b8:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
 82160bc:	e0bffb17 	ldw	r2,-20(fp)
 82160c0:	10800017 	ldw	r2,0(r2)
 82160c4:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 82160c8:	e0bffc17 	ldw	r2,-16(fp)
 82160cc:	103fd91e 	bne	r2,zero,8216034 <OS_EventTaskRemoveMulti+0x50>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
 82160d0:	0001883a 	nop
 82160d4:	e037883a 	mov	sp,fp
 82160d8:	df000017 	ldw	fp,0(sp)
 82160dc:	dec00104 	addi	sp,sp,4
 82160e0:	f800283a 	ret

082160e4 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
 82160e4:	defffc04 	addi	sp,sp,-16
 82160e8:	df000315 	stw	fp,12(sp)
 82160ec:	df000304 	addi	fp,sp,12
 82160f0:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
 82160f4:	e0bfff17 	ldw	r2,-4(fp)
 82160f8:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
 82160fc:	e0bfff17 	ldw	r2,-4(fp)
 8216100:	108002c4 	addi	r2,r2,11
 8216104:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 8216108:	e03ffe05 	stb	zero,-8(fp)
 821610c:	00000706 	br	821612c <OS_EventWaitListInit+0x48>
        *ptbl++ = 0;
 8216110:	e0bffd17 	ldw	r2,-12(fp)
 8216114:	10c00044 	addi	r3,r2,1
 8216118:	e0fffd15 	stw	r3,-12(fp)
 821611c:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 8216120:	e0bffe03 	ldbu	r2,-8(fp)
 8216124:	10800044 	addi	r2,r2,1
 8216128:	e0bffe05 	stb	r2,-8(fp)
 821612c:	e0bffe03 	ldbu	r2,-8(fp)
 8216130:	108000f0 	cmpltui	r2,r2,3
 8216134:	103ff61e 	bne	r2,zero,8216110 <OS_EventWaitListInit+0x2c>
        *ptbl++ = 0;
    }
}
 8216138:	0001883a 	nop
 821613c:	e037883a 	mov	sp,fp
 8216140:	df000017 	ldw	fp,0(sp)
 8216144:	dec00104 	addi	sp,sp,4
 8216148:	f800283a 	ret

0821614c <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
 821614c:	defffb04 	addi	sp,sp,-20
 8216150:	dfc00415 	stw	ra,16(sp)
 8216154:	df000315 	stw	fp,12(sp)
 8216158:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
 821615c:	0142d004 	movi	r5,2880
 8216160:	010209b4 	movhi	r4,2086
 8216164:	2132b704 	addi	r4,r4,-13604
 8216168:	82164c40 	call	82164c4 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
 821616c:	008209b4 	movhi	r2,2086
 8216170:	10b2b704 	addi	r2,r2,-13604
 8216174:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
 8216178:	008209b4 	movhi	r2,2086
 821617c:	10b2c304 	addi	r2,r2,-13556
 8216180:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 8216184:	e03ffd0d 	sth	zero,-12(fp)
 8216188:	00001306 	br	82161d8 <OS_InitEventList+0x8c>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
 821618c:	e0bffe17 	ldw	r2,-8(fp)
 8216190:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
 8216194:	e0bffe17 	ldw	r2,-8(fp)
 8216198:	e0ffff17 	ldw	r3,-4(fp)
 821619c:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
 82161a0:	e0bffe17 	ldw	r2,-8(fp)
 82161a4:	00c00fc4 	movi	r3,63
 82161a8:	10c00385 	stb	r3,14(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
 82161ac:	e0bffe17 	ldw	r2,-8(fp)
 82161b0:	100003c5 	stb	zero,15(r2)
#endif
        pevent1++;
 82161b4:	e0bffe17 	ldw	r2,-8(fp)
 82161b8:	10800c04 	addi	r2,r2,48
 82161bc:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
 82161c0:	e0bfff17 	ldw	r2,-4(fp)
 82161c4:	10800c04 	addi	r2,r2,48
 82161c8:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 82161cc:	e0bffd0b 	ldhu	r2,-12(fp)
 82161d0:	10800044 	addi	r2,r2,1
 82161d4:	e0bffd0d 	sth	r2,-12(fp)
 82161d8:	e0bffd0b 	ldhu	r2,-12(fp)
 82161dc:	10800ef0 	cmpltui	r2,r2,59
 82161e0:	103fea1e 	bne	r2,zero,821618c <OS_InitEventList+0x40>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
 82161e4:	e0bffe17 	ldw	r2,-8(fp)
 82161e8:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
 82161ec:	e0bffe17 	ldw	r2,-8(fp)
 82161f0:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
 82161f4:	e0bffe17 	ldw	r2,-8(fp)
 82161f8:	00c00fc4 	movi	r3,63
 82161fc:	10c00385 	stb	r3,14(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
 8216200:	e0bffe17 	ldw	r2,-8(fp)
 8216204:	100003c5 	stb	zero,15(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
 8216208:	008209b4 	movhi	r2,2086
 821620c:	10b2b704 	addi	r2,r2,-13604
 8216210:	d0a07815 	stw	r2,-32288(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
 8216214:	0001883a 	nop
 8216218:	e037883a 	mov	sp,fp
 821621c:	dfc00117 	ldw	ra,4(sp)
 8216220:	df000017 	ldw	fp,0(sp)
 8216224:	dec00204 	addi	sp,sp,8
 8216228:	f800283a 	ret

0821622c <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
 821622c:	deffff04 	addi	sp,sp,-4
 8216230:	df000015 	stw	fp,0(sp)
 8216234:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
 8216238:	d0207b15 	stw	zero,-32276(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
 821623c:	d0207905 	stb	zero,-32284(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
 8216240:	d0206b05 	stb	zero,-32340(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
 8216244:	d0207345 	stb	zero,-32307(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
 8216248:	d0206b45 	stb	zero,-32339(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
 821624c:	d0207015 	stw	zero,-32320(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
 8216250:	d0206c15 	stw	zero,-32336(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
 8216254:	d0207e15 	stw	zero,-32264(gp)
    OSIdleCtrMax  = 0L;
 8216258:	d0207115 	stw	zero,-32316(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
 821625c:	d0207d05 	stb	zero,-32268(gp)
#endif
}
 8216260:	0001883a 	nop
 8216264:	e037883a 	mov	sp,fp
 8216268:	df000017 	ldw	fp,0(sp)
 821626c:	dec00104 	addi	sp,sp,4
 8216270:	f800283a 	ret

08216274 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
 8216274:	defffd04 	addi	sp,sp,-12
 8216278:	df000215 	stw	fp,8(sp)
 821627c:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
 8216280:	d0207705 	stb	zero,-32292(gp)
    prdytbl       = &OSRdyTbl[0];
 8216284:	d0a07744 	addi	r2,gp,-32291
 8216288:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 821628c:	e03ffe05 	stb	zero,-8(fp)
 8216290:	00000706 	br	82162b0 <OS_InitRdyList+0x3c>
        *prdytbl++ = 0;
 8216294:	e0bfff17 	ldw	r2,-4(fp)
 8216298:	10c00044 	addi	r3,r2,1
 821629c:	e0ffff15 	stw	r3,-4(fp)
 82162a0:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 82162a4:	e0bffe03 	ldbu	r2,-8(fp)
 82162a8:	10800044 	addi	r2,r2,1
 82162ac:	e0bffe05 	stb	r2,-8(fp)
 82162b0:	e0bffe03 	ldbu	r2,-8(fp)
 82162b4:	108000f0 	cmpltui	r2,r2,3
 82162b8:	103ff61e 	bne	r2,zero,8216294 <OS_InitRdyList+0x20>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
 82162bc:	d0206d45 	stb	zero,-32331(gp)
    OSPrioHighRdy = 0;
 82162c0:	d0206d05 	stb	zero,-32332(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
 82162c4:	d0207515 	stw	zero,-32300(gp)
    OSTCBCur      = (OS_TCB *)0;
 82162c8:	d0207a15 	stw	zero,-32280(gp)
}
 82162cc:	0001883a 	nop
 82162d0:	e037883a 	mov	sp,fp
 82162d4:	df000017 	ldw	fp,0(sp)
 82162d8:	dec00104 	addi	sp,sp,4
 82162dc:	f800283a 	ret

082162e0 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
 82162e0:	defff804 	addi	sp,sp,-32
 82162e4:	dfc00715 	stw	ra,28(sp)
 82162e8:	df000615 	stw	fp,24(sp)
 82162ec:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
 82162f0:	008000c4 	movi	r2,3
 82162f4:	d8800415 	stw	r2,16(sp)
 82162f8:	d8000315 	stw	zero,12(sp)
 82162fc:	00808004 	movi	r2,512
 8216300:	d8800215 	stw	r2,8(sp)
 8216304:	008209b4 	movhi	r2,2086
 8216308:	10b0b704 	addi	r2,r2,-15652
 821630c:	d8800115 	stw	r2,4(sp)
 8216310:	00bfffd4 	movui	r2,65535
 8216314:	d8800015 	stw	r2,0(sp)
 8216318:	01c00504 	movi	r7,20
 821631c:	018209b4 	movhi	r6,2086
 8216320:	31b2b604 	addi	r6,r6,-13608
 8216324:	000b883a 	mov	r5,zero
 8216328:	01020874 	movhi	r4,2081
 821632c:	2119e304 	addi	r4,r4,26508
 8216330:	821ae640 	call	821ae64 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
 8216334:	e1bfff04 	addi	r6,fp,-4
 8216338:	01420974 	movhi	r5,2085
 821633c:	2977e204 	addi	r5,r5,-8312
 8216340:	01000504 	movi	r4,20
 8216344:	821b6740 	call	821b674 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
 8216348:	0001883a 	nop
 821634c:	e037883a 	mov	sp,fp
 8216350:	dfc00117 	ldw	ra,4(sp)
 8216354:	df000017 	ldw	fp,0(sp)
 8216358:	dec00204 	addi	sp,sp,8
 821635c:	f800283a 	ret

08216360 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
 8216360:	defff804 	addi	sp,sp,-32
 8216364:	dfc00715 	stw	ra,28(sp)
 8216368:	df000615 	stw	fp,24(sp)
 821636c:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
 8216370:	008000c4 	movi	r2,3
 8216374:	d8800415 	stw	r2,16(sp)
 8216378:	d8000315 	stw	zero,12(sp)
 821637c:	00808004 	movi	r2,512
 8216380:	d8800215 	stw	r2,8(sp)
 8216384:	008209b4 	movhi	r2,2086
 8216388:	10ae3f04 	addi	r2,r2,-18180
 821638c:	d8800115 	stw	r2,4(sp)
 8216390:	00bfff94 	movui	r2,65534
 8216394:	d8800015 	stw	r2,0(sp)
 8216398:	01c004c4 	movi	r7,19
 821639c:	018209b4 	movhi	r6,2086
 82163a0:	31b03e04 	addi	r6,r6,-16136
 82163a4:	000b883a 	mov	r5,zero
 82163a8:	01020874 	movhi	r4,2081
 82163ac:	2119fa04 	addi	r4,r4,26600
 82163b0:	821ae640 	call	821ae64 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
 82163b4:	e1bfff04 	addi	r6,fp,-4
 82163b8:	01420974 	movhi	r5,2085
 82163bc:	2977e604 	addi	r5,r5,-8296
 82163c0:	010004c4 	movi	r4,19
 82163c4:	821b6740 	call	821b674 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
 82163c8:	0001883a 	nop
 82163cc:	e037883a 	mov	sp,fp
 82163d0:	dfc00117 	ldw	ra,4(sp)
 82163d4:	df000017 	ldw	fp,0(sp)
 82163d8:	dec00204 	addi	sp,sp,8
 82163dc:	f800283a 	ret

082163e0 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
 82163e0:	defffb04 	addi	sp,sp,-20
 82163e4:	dfc00415 	stw	ra,16(sp)
 82163e8:	df000315 	stw	fp,12(sp)
 82163ec:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
 82163f0:	01414404 	movi	r5,1296
 82163f4:	010209b4 	movhi	r4,2086
 82163f8:	21358704 	addi	r4,r4,-10724
 82163fc:	82164c40 	call	82164c4 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
 8216400:	01401504 	movi	r5,84
 8216404:	010209b4 	movhi	r4,2086
 8216408:	2136cb04 	addi	r4,r4,-9428
 821640c:	82164c40 	call	82164c4 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
 8216410:	008209b4 	movhi	r2,2086
 8216414:	10b58704 	addi	r2,r2,-10724
 8216418:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
 821641c:	008209b4 	movhi	r2,2086
 8216420:	10b5a204 	addi	r2,r2,-10616
 8216424:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 8216428:	e03ffd05 	stb	zero,-12(fp)
 821642c:	00001106 	br	8216474 <OS_InitTCBList+0x94>
        ptcb1->OSTCBNext = ptcb2;
 8216430:	e0bffe17 	ldw	r2,-8(fp)
 8216434:	e0ffff17 	ldw	r3,-4(fp)
 8216438:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
 821643c:	e0bffe17 	ldw	r2,-8(fp)
 8216440:	00c00fc4 	movi	r3,63
 8216444:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 8216448:	e0bffe17 	ldw	r2,-8(fp)
 821644c:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
 8216450:	e0bffe17 	ldw	r2,-8(fp)
 8216454:	10801b04 	addi	r2,r2,108
 8216458:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
 821645c:	e0bfff17 	ldw	r2,-4(fp)
 8216460:	10801b04 	addi	r2,r2,108
 8216464:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 8216468:	e0bffd03 	ldbu	r2,-12(fp)
 821646c:	10800044 	addi	r2,r2,1
 8216470:	e0bffd05 	stb	r2,-12(fp)
 8216474:	e0bffd03 	ldbu	r2,-12(fp)
 8216478:	108002f0 	cmpltui	r2,r2,11
 821647c:	103fec1e 	bne	r2,zero,8216430 <OS_InitTCBList+0x50>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
 8216480:	e0bffe17 	ldw	r2,-8(fp)
 8216484:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
 8216488:	e0bffe17 	ldw	r2,-8(fp)
 821648c:	00c00fc4 	movi	r3,63
 8216490:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 8216494:	e0bffe17 	ldw	r2,-8(fp)
 8216498:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
 821649c:	d0206e15 	stw	zero,-32328(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
 82164a0:	008209b4 	movhi	r2,2086
 82164a4:	10b58704 	addi	r2,r2,-10724
 82164a8:	d0a07215 	stw	r2,-32312(gp)
}
 82164ac:	0001883a 	nop
 82164b0:	e037883a 	mov	sp,fp
 82164b4:	dfc00117 	ldw	ra,4(sp)
 82164b8:	df000017 	ldw	fp,0(sp)
 82164bc:	dec00204 	addi	sp,sp,8
 82164c0:	f800283a 	ret

082164c4 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
 82164c4:	defffd04 	addi	sp,sp,-12
 82164c8:	df000215 	stw	fp,8(sp)
 82164cc:	df000204 	addi	fp,sp,8
 82164d0:	e13ffe15 	stw	r4,-8(fp)
 82164d4:	2805883a 	mov	r2,r5
 82164d8:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
 82164dc:	00000706 	br	82164fc <OS_MemClr+0x38>
        *pdest++ = (INT8U)0;
 82164e0:	e0bffe17 	ldw	r2,-8(fp)
 82164e4:	10c00044 	addi	r3,r2,1
 82164e8:	e0fffe15 	stw	r3,-8(fp)
 82164ec:	10000005 	stb	zero,0(r2)
        size--;
 82164f0:	e0bfff0b 	ldhu	r2,-4(fp)
 82164f4:	10bfffc4 	addi	r2,r2,-1
 82164f8:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
 82164fc:	e0bfff0b 	ldhu	r2,-4(fp)
 8216500:	103ff71e 	bne	r2,zero,82164e0 <OS_MemClr+0x1c>
        *pdest++ = (INT8U)0;
        size--;
    }
}
 8216504:	0001883a 	nop
 8216508:	e037883a 	mov	sp,fp
 821650c:	df000017 	ldw	fp,0(sp)
 8216510:	dec00104 	addi	sp,sp,4
 8216514:	f800283a 	ret

08216518 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
 8216518:	defffc04 	addi	sp,sp,-16
 821651c:	df000315 	stw	fp,12(sp)
 8216520:	df000304 	addi	fp,sp,12
 8216524:	e13ffd15 	stw	r4,-12(fp)
 8216528:	e17ffe15 	stw	r5,-8(fp)
 821652c:	3005883a 	mov	r2,r6
 8216530:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
 8216534:	00000b06 	br	8216564 <OS_MemCopy+0x4c>
        *pdest++ = *psrc++;
 8216538:	e0bffd17 	ldw	r2,-12(fp)
 821653c:	10c00044 	addi	r3,r2,1
 8216540:	e0fffd15 	stw	r3,-12(fp)
 8216544:	e0fffe17 	ldw	r3,-8(fp)
 8216548:	19000044 	addi	r4,r3,1
 821654c:	e13ffe15 	stw	r4,-8(fp)
 8216550:	18c00003 	ldbu	r3,0(r3)
 8216554:	10c00005 	stb	r3,0(r2)
        size--;
 8216558:	e0bfff0b 	ldhu	r2,-4(fp)
 821655c:	10bfffc4 	addi	r2,r2,-1
 8216560:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
 8216564:	e0bfff0b 	ldhu	r2,-4(fp)
 8216568:	103ff31e 	bne	r2,zero,8216538 <OS_MemCopy+0x20>
        *pdest++ = *psrc++;
        size--;
    }
}
 821656c:	0001883a 	nop
 8216570:	e037883a 	mov	sp,fp
 8216574:	df000017 	ldw	fp,0(sp)
 8216578:	dec00104 	addi	sp,sp,4
 821657c:	f800283a 	ret

08216580 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
 8216580:	defffb04 	addi	sp,sp,-20
 8216584:	dfc00415 	stw	ra,16(sp)
 8216588:	df000315 	stw	fp,12(sp)
 821658c:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 8216590:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8216594:	0005303a 	rdctl	r2,status
 8216598:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821659c:	e0ffff17 	ldw	r3,-4(fp)
 82165a0:	00bfff84 	movi	r2,-2
 82165a4:	1884703a 	and	r2,r3,r2
 82165a8:	1001703a 	wrctl	status,r2
  
  return context;
 82165ac:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
 82165b0:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
 82165b4:	d0a07903 	ldbu	r2,-32284(gp)
 82165b8:	10803fcc 	andi	r2,r2,255
 82165bc:	10001a1e 	bne	r2,zero,8216628 <OS_Sched+0xa8>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
 82165c0:	d0a06b03 	ldbu	r2,-32340(gp)
 82165c4:	10803fcc 	andi	r2,r2,255
 82165c8:	1000171e 	bne	r2,zero,8216628 <OS_Sched+0xa8>
            OS_SchedNew();
 82165cc:	82166500 	call	8216650 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
 82165d0:	d0e06d03 	ldbu	r3,-32332(gp)
 82165d4:	d0a06d43 	ldbu	r2,-32331(gp)
 82165d8:	18c03fcc 	andi	r3,r3,255
 82165dc:	10803fcc 	andi	r2,r2,255
 82165e0:	18801126 	beq	r3,r2,8216628 <OS_Sched+0xa8>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
 82165e4:	d0a06d03 	ldbu	r2,-32332(gp)
 82165e8:	10c03fcc 	andi	r3,r2,255
 82165ec:	008209b4 	movhi	r2,2086
 82165f0:	10b6cb04 	addi	r2,r2,-9428
 82165f4:	18c7883a 	add	r3,r3,r3
 82165f8:	18c7883a 	add	r3,r3,r3
 82165fc:	10c5883a 	add	r2,r2,r3
 8216600:	10800017 	ldw	r2,0(r2)
 8216604:	d0a07515 	stw	r2,-32300(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
 8216608:	d0a07517 	ldw	r2,-32300(gp)
 821660c:	10c00e17 	ldw	r3,56(r2)
 8216610:	18c00044 	addi	r3,r3,1
 8216614:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
 8216618:	d0a07017 	ldw	r2,-32320(gp)
 821661c:	10800044 	addi	r2,r2,1
 8216620:	d0a07015 	stw	r2,-32320(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
 8216624:	823cd100 	call	823cd10 <OSCtxSw>
 8216628:	e0bffd17 	ldw	r2,-12(fp)
 821662c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8216630:	e0bffe17 	ldw	r2,-8(fp)
 8216634:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
 8216638:	0001883a 	nop
 821663c:	e037883a 	mov	sp,fp
 8216640:	dfc00117 	ldw	ra,4(sp)
 8216644:	df000017 	ldw	fp,0(sp)
 8216648:	dec00204 	addi	sp,sp,8
 821664c:	f800283a 	ret

08216650 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
 8216650:	defffe04 	addi	sp,sp,-8
 8216654:	df000115 	stw	fp,4(sp)
 8216658:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
 821665c:	d0a07703 	ldbu	r2,-32292(gp)
 8216660:	10c03fcc 	andi	r3,r2,255
 8216664:	00820974 	movhi	r2,2085
 8216668:	10b7a204 	addi	r2,r2,-8568
 821666c:	10c5883a 	add	r2,r2,r3
 8216670:	10800003 	ldbu	r2,0(r2)
 8216674:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
 8216678:	e0bfff03 	ldbu	r2,-4(fp)
 821667c:	100490fa 	slli	r2,r2,3
 8216680:	1009883a 	mov	r4,r2
 8216684:	e0ffff03 	ldbu	r3,-4(fp)
 8216688:	d0a07744 	addi	r2,gp,-32291
 821668c:	1885883a 	add	r2,r3,r2
 8216690:	10800003 	ldbu	r2,0(r2)
 8216694:	10c03fcc 	andi	r3,r2,255
 8216698:	00820974 	movhi	r2,2085
 821669c:	10b7a204 	addi	r2,r2,-8568
 82166a0:	10c5883a 	add	r2,r2,r3
 82166a4:	10800003 	ldbu	r2,0(r2)
 82166a8:	2085883a 	add	r2,r4,r2
 82166ac:	d0a06d05 	stb	r2,-32332(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
 82166b0:	0001883a 	nop
 82166b4:	e037883a 	mov	sp,fp
 82166b8:	df000017 	ldw	fp,0(sp)
 82166bc:	dec00104 	addi	sp,sp,4
 82166c0:	f800283a 	ret

082166c4 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
 82166c4:	defffc04 	addi	sp,sp,-16
 82166c8:	df000315 	stw	fp,12(sp)
 82166cc:	df000304 	addi	fp,sp,12
 82166d0:	e13ffe15 	stw	r4,-8(fp)
 82166d4:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
 82166d8:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
 82166dc:	00000b06 	br	821670c <OS_StrCopy+0x48>
        *pdest++ = *psrc++;
 82166e0:	e0bffe17 	ldw	r2,-8(fp)
 82166e4:	10c00044 	addi	r3,r2,1
 82166e8:	e0fffe15 	stw	r3,-8(fp)
 82166ec:	e0ffff17 	ldw	r3,-4(fp)
 82166f0:	19000044 	addi	r4,r3,1
 82166f4:	e13fff15 	stw	r4,-4(fp)
 82166f8:	18c00003 	ldbu	r3,0(r3)
 82166fc:	10c00005 	stb	r3,0(r2)
        len++;
 8216700:	e0bffd03 	ldbu	r2,-12(fp)
 8216704:	10800044 	addi	r2,r2,1
 8216708:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 821670c:	e0bfff17 	ldw	r2,-4(fp)
 8216710:	10800003 	ldbu	r2,0(r2)
 8216714:	10803fcc 	andi	r2,r2,255
 8216718:	103ff11e 	bne	r2,zero,82166e0 <OS_StrCopy+0x1c>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
 821671c:	e0bffe17 	ldw	r2,-8(fp)
 8216720:	10000005 	stb	zero,0(r2)
    return (len);
 8216724:	e0bffd03 	ldbu	r2,-12(fp)
}
 8216728:	e037883a 	mov	sp,fp
 821672c:	df000017 	ldw	fp,0(sp)
 8216730:	dec00104 	addi	sp,sp,4
 8216734:	f800283a 	ret

08216738 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
 8216738:	defffd04 	addi	sp,sp,-12
 821673c:	df000215 	stw	fp,8(sp)
 8216740:	df000204 	addi	fp,sp,8
 8216744:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
 8216748:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
 821674c:	00000606 	br	8216768 <OS_StrLen+0x30>
        psrc++;
 8216750:	e0bfff17 	ldw	r2,-4(fp)
 8216754:	10800044 	addi	r2,r2,1
 8216758:	e0bfff15 	stw	r2,-4(fp)
        len++;
 821675c:	e0bffe03 	ldbu	r2,-8(fp)
 8216760:	10800044 	addi	r2,r2,1
 8216764:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 8216768:	e0bfff17 	ldw	r2,-4(fp)
 821676c:	10800003 	ldbu	r2,0(r2)
 8216770:	10803fcc 	andi	r2,r2,255
 8216774:	103ff61e 	bne	r2,zero,8216750 <OS_StrLen+0x18>
        psrc++;
        len++;
    }
    return (len);
 8216778:	e0bffe03 	ldbu	r2,-8(fp)
}
 821677c:	e037883a 	mov	sp,fp
 8216780:	df000017 	ldw	fp,0(sp)
 8216784:	dec00104 	addi	sp,sp,4
 8216788:	f800283a 	ret

0821678c <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
 821678c:	defffa04 	addi	sp,sp,-24
 8216790:	dfc00515 	stw	ra,20(sp)
 8216794:	df000415 	stw	fp,16(sp)
 8216798:	df000404 	addi	fp,sp,16
 821679c:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82167a0:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82167a4:	0005303a 	rdctl	r2,status
 82167a8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82167ac:	e0fffd17 	ldw	r3,-12(fp)
 82167b0:	00bfff84 	movi	r2,-2
 82167b4:	1884703a 	and	r2,r3,r2
 82167b8:	1001703a 	wrctl	status,r2
  
  return context;
 82167bc:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
 82167c0:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
 82167c4:	d0a06c17 	ldw	r2,-32336(gp)
 82167c8:	10800044 	addi	r2,r2,1
 82167cc:	d0a06c15 	stw	r2,-32336(gp)
 82167d0:	e0bffc17 	ldw	r2,-16(fp)
 82167d4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82167d8:	e0bffe17 	ldw	r2,-8(fp)
 82167dc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
 82167e0:	823d0300 	call	823d030 <OSTaskIdleHook>
    }
 82167e4:	003fef06 	br	82167a4 <OS_TaskIdle+0x18>

082167e8 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
 82167e8:	defff804 	addi	sp,sp,-32
 82167ec:	dfc00715 	stw	ra,28(sp)
 82167f0:	df000615 	stw	fp,24(sp)
 82167f4:	dc400515 	stw	r17,20(sp)
 82167f8:	dc000415 	stw	r16,16(sp)
 82167fc:	df000604 	addi	fp,sp,24
 8216800:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8216804:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 8216808:	00000206 	br	8216814 <OS_TaskStat+0x2c>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
 821680c:	01000504 	movi	r4,20
 8216810:	821bf340 	call	821bf34 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 8216814:	d0a07d03 	ldbu	r2,-32268(gp)
 8216818:	10803fcc 	andi	r2,r2,255
 821681c:	103ffb26 	beq	r2,zero,821680c <OS_TaskStat+0x24>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
 8216820:	d0e07117 	ldw	r3,-32316(gp)
 8216824:	00947b34 	movhi	r2,20972
 8216828:	10a147c4 	addi	r2,r2,-31457
 821682c:	1888383a 	mulxuu	r4,r3,r2
 8216830:	1885383a 	mul	r2,r3,r2
 8216834:	1021883a 	mov	r16,r2
 8216838:	2023883a 	mov	r17,r4
 821683c:	8804d17a 	srli	r2,r17,5
 8216840:	d0a07115 	stw	r2,-32316(gp)
    if (OSIdleCtrMax == 0L) {
 8216844:	d0a07117 	ldw	r2,-32316(gp)
 8216848:	1000031e 	bne	r2,zero,8216858 <OS_TaskStat+0x70>
        OSCPUUsage = 0;
 821684c:	d0207305 	stb	zero,-32308(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
 8216850:	01003fc4 	movi	r4,255
 8216854:	821bbbc0 	call	821bbbc <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8216858:	0005303a 	rdctl	r2,status
 821685c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8216860:	e0fffb17 	ldw	r3,-20(fp)
 8216864:	00bfff84 	movi	r2,-2
 8216868:	1884703a 	and	r2,r3,r2
 821686c:	1001703a 	wrctl	status,r2
  
  return context;
 8216870:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
 8216874:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
 8216878:	d0a06c17 	ldw	r2,-32336(gp)
 821687c:	d0a07e15 	stw	r2,-32264(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
 8216880:	d0206c15 	stw	zero,-32336(gp)
 8216884:	e0bffa17 	ldw	r2,-24(fp)
 8216888:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821688c:	e0bffc17 	ldw	r2,-16(fp)
 8216890:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
 8216894:	d0a07e17 	ldw	r2,-32264(gp)
 8216898:	d0e07117 	ldw	r3,-32316(gp)
 821689c:	180b883a 	mov	r5,r3
 82168a0:	1009883a 	mov	r4,r2
 82168a4:	8202c6c0 	call	8202c6c <__udivsi3>
 82168a8:	1007883a 	mov	r3,r2
 82168ac:	00801904 	movi	r2,100
 82168b0:	10c5c83a 	sub	r2,r2,r3
 82168b4:	d0a07305 	stb	r2,-32308(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
 82168b8:	823cfa40 	call	823cfa4 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
 82168bc:	82168cc0 	call	82168cc <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
 82168c0:	01000284 	movi	r4,10
 82168c4:	821bf340 	call	821bf34 <OSTimeDly>
    }
 82168c8:	003fe306 	br	8216858 <OS_TaskStat+0x70>

082168cc <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
 82168cc:	defffa04 	addi	sp,sp,-24
 82168d0:	dfc00515 	stw	ra,20(sp)
 82168d4:	df000415 	stw	fp,16(sp)
 82168d8:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 82168dc:	e03ffc05 	stb	zero,-16(fp)
 82168e0:	00002406 	br	8216974 <OS_TaskStatStkChk+0xa8>
        err = OSTaskStkChk(prio, &stk_data);
 82168e4:	e0bffc03 	ldbu	r2,-16(fp)
 82168e8:	e0fffe04 	addi	r3,fp,-8
 82168ec:	180b883a 	mov	r5,r3
 82168f0:	1009883a 	mov	r4,r2
 82168f4:	821b9fc0 	call	821b9fc <OSTaskStkChk>
 82168f8:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
 82168fc:	e0bffc43 	ldbu	r2,-15(fp)
 8216900:	1000191e 	bne	r2,zero,8216968 <OS_TaskStatStkChk+0x9c>
            ptcb = OSTCBPrioTbl[prio];
 8216904:	e0fffc03 	ldbu	r3,-16(fp)
 8216908:	008209b4 	movhi	r2,2086
 821690c:	10b6cb04 	addi	r2,r2,-9428
 8216910:	18c7883a 	add	r3,r3,r3
 8216914:	18c7883a 	add	r3,r3,r3
 8216918:	10c5883a 	add	r2,r2,r3
 821691c:	10800017 	ldw	r2,0(r2)
 8216920:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
 8216924:	e0bffd17 	ldw	r2,-12(fp)
 8216928:	10000f26 	beq	r2,zero,8216968 <OS_TaskStatStkChk+0x9c>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
 821692c:	e0bffd17 	ldw	r2,-12(fp)
 8216930:	10800060 	cmpeqi	r2,r2,1
 8216934:	10000c1e 	bne	r2,zero,8216968 <OS_TaskStatStkChk+0x9c>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
 8216938:	e0bffd17 	ldw	r2,-12(fp)
 821693c:	10c00217 	ldw	r3,8(r2)
 8216940:	e0bffd17 	ldw	r2,-12(fp)
 8216944:	10800317 	ldw	r2,12(r2)
 8216948:	1085883a 	add	r2,r2,r2
 821694c:	1085883a 	add	r2,r2,r2
 8216950:	1887883a 	add	r3,r3,r2
 8216954:	e0bffd17 	ldw	r2,-12(fp)
 8216958:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
 821695c:	e0ffff17 	ldw	r3,-4(fp)
 8216960:	e0bffd17 	ldw	r2,-12(fp)
 8216964:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 8216968:	e0bffc03 	ldbu	r2,-16(fp)
 821696c:	10800044 	addi	r2,r2,1
 8216970:	e0bffc05 	stb	r2,-16(fp)
 8216974:	e0bffc03 	ldbu	r2,-16(fp)
 8216978:	10800570 	cmpltui	r2,r2,21
 821697c:	103fd91e 	bne	r2,zero,82168e4 <OS_TaskStatStkChk+0x18>
#endif
                }
            }
        }
    }
}
 8216980:	0001883a 	nop
 8216984:	e037883a 	mov	sp,fp
 8216988:	dfc00117 	ldw	ra,4(sp)
 821698c:	df000017 	ldw	fp,0(sp)
 8216990:	dec00204 	addi	sp,sp,8
 8216994:	f800283a 	ret

08216998 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
 8216998:	defff204 	addi	sp,sp,-56
 821699c:	dfc00d15 	stw	ra,52(sp)
 82169a0:	df000c15 	stw	fp,48(sp)
 82169a4:	df000c04 	addi	fp,sp,48
 82169a8:	e17ffc15 	stw	r5,-16(fp)
 82169ac:	e1bffd15 	stw	r6,-12(fp)
 82169b0:	3807883a 	mov	r3,r7
 82169b4:	e0800417 	ldw	r2,16(fp)
 82169b8:	e13ffb05 	stb	r4,-20(fp)
 82169bc:	e0fffe0d 	sth	r3,-8(fp)
 82169c0:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 82169c4:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82169c8:	0005303a 	rdctl	r2,status
 82169cc:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82169d0:	e0fffa17 	ldw	r3,-24(fp)
 82169d4:	00bfff84 	movi	r2,-2
 82169d8:	1884703a 	and	r2,r3,r2
 82169dc:	1001703a 	wrctl	status,r2
  
  return context;
 82169e0:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
 82169e4:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
 82169e8:	d0a07217 	ldw	r2,-32312(gp)
 82169ec:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
 82169f0:	e0bff617 	ldw	r2,-40(fp)
 82169f4:	10009326 	beq	r2,zero,8216c44 <OS_TCBInit+0x2ac>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
 82169f8:	e0bff617 	ldw	r2,-40(fp)
 82169fc:	10800517 	ldw	r2,20(r2)
 8216a00:	d0a07215 	stw	r2,-32312(gp)
 8216a04:	e0bff417 	ldw	r2,-48(fp)
 8216a08:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8216a0c:	e0bff817 	ldw	r2,-32(fp)
 8216a10:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
 8216a14:	e0bff617 	ldw	r2,-40(fp)
 8216a18:	e0fffc17 	ldw	r3,-16(fp)
 8216a1c:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
 8216a20:	e0bff617 	ldw	r2,-40(fp)
 8216a24:	e0fffb03 	ldbu	r3,-20(fp)
 8216a28:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
 8216a2c:	e0bff617 	ldw	r2,-40(fp)
 8216a30:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
 8216a34:	e0bff617 	ldw	r2,-40(fp)
 8216a38:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
 8216a3c:	e0bff617 	ldw	r2,-40(fp)
 8216a40:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
 8216a44:	e0bff617 	ldw	r2,-40(fp)
 8216a48:	e0c00317 	ldw	r3,12(fp)
 8216a4c:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
 8216a50:	e0bff617 	ldw	r2,-40(fp)
 8216a54:	e0c00217 	ldw	r3,8(fp)
 8216a58:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
 8216a5c:	e0bff617 	ldw	r2,-40(fp)
 8216a60:	e0fffd17 	ldw	r3,-12(fp)
 8216a64:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
 8216a68:	e0bff617 	ldw	r2,-40(fp)
 8216a6c:	e0ffff0b 	ldhu	r3,-4(fp)
 8216a70:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
 8216a74:	e0bff617 	ldw	r2,-40(fp)
 8216a78:	e0fffe0b 	ldhu	r3,-8(fp)
 8216a7c:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
 8216a80:	e0bff617 	ldw	r2,-40(fp)
 8216a84:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
 8216a88:	e0bffb03 	ldbu	r2,-20(fp)
 8216a8c:	1004d0fa 	srli	r2,r2,3
 8216a90:	1007883a 	mov	r3,r2
 8216a94:	e0bff617 	ldw	r2,-40(fp)
 8216a98:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
 8216a9c:	e0bffb03 	ldbu	r2,-20(fp)
 8216aa0:	108001cc 	andi	r2,r2,7
 8216aa4:	1007883a 	mov	r3,r2
 8216aa8:	e0bff617 	ldw	r2,-40(fp)
 8216aac:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
 8216ab0:	e0bff617 	ldw	r2,-40(fp)
 8216ab4:	10800d03 	ldbu	r2,52(r2)
 8216ab8:	10803fcc 	andi	r2,r2,255
 8216abc:	00c00044 	movi	r3,1
 8216ac0:	1884983a 	sll	r2,r3,r2
 8216ac4:	1007883a 	mov	r3,r2
 8216ac8:	e0bff617 	ldw	r2,-40(fp)
 8216acc:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
 8216ad0:	e0bff617 	ldw	r2,-40(fp)
 8216ad4:	10800cc3 	ldbu	r2,51(r2)
 8216ad8:	10803fcc 	andi	r2,r2,255
 8216adc:	00c00044 	movi	r3,1
 8216ae0:	1884983a 	sll	r2,r3,r2
 8216ae4:	1007883a 	mov	r3,r2
 8216ae8:	e0bff617 	ldw	r2,-40(fp)
 8216aec:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
 8216af0:	e0bff617 	ldw	r2,-40(fp)
 8216af4:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
 8216af8:	e0bff617 	ldw	r2,-40(fp)
 8216afc:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
 8216b00:	e0bff617 	ldw	r2,-40(fp)
 8216b04:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
 8216b08:	e0bff617 	ldw	r2,-40(fp)
 8216b0c:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
 8216b10:	e0bff617 	ldw	r2,-40(fp)
 8216b14:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
 8216b18:	e0bff617 	ldw	r2,-40(fp)
 8216b1c:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
 8216b20:	e0bff617 	ldw	r2,-40(fp)
 8216b24:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
 8216b28:	e0bff617 	ldw	r2,-40(fp)
 8216b2c:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
 8216b30:	e0bff617 	ldw	r2,-40(fp)
 8216b34:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
 8216b38:	e0bff617 	ldw	r2,-40(fp)
 8216b3c:	00c00fc4 	movi	r3,63
 8216b40:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 8216b44:	e0bff617 	ldw	r2,-40(fp)
 8216b48:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
 8216b4c:	e13ff617 	ldw	r4,-40(fp)
 8216b50:	823d0500 	call	823d050 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
 8216b54:	e13ff617 	ldw	r4,-40(fp)
 8216b58:	823cf3c0 	call	823cf3c <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8216b5c:	0005303a 	rdctl	r2,status
 8216b60:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8216b64:	e0fff517 	ldw	r3,-44(fp)
 8216b68:	00bfff84 	movi	r2,-2
 8216b6c:	1884703a 	and	r2,r3,r2
 8216b70:	1001703a 	wrctl	status,r2
  
  return context;
 8216b74:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
 8216b78:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
 8216b7c:	e0fffb03 	ldbu	r3,-20(fp)
 8216b80:	008209b4 	movhi	r2,2086
 8216b84:	10b6cb04 	addi	r2,r2,-9428
 8216b88:	18c7883a 	add	r3,r3,r3
 8216b8c:	18c7883a 	add	r3,r3,r3
 8216b90:	10c5883a 	add	r2,r2,r3
 8216b94:	e0fff617 	ldw	r3,-40(fp)
 8216b98:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
 8216b9c:	d0e06e17 	ldw	r3,-32328(gp)
 8216ba0:	e0bff617 	ldw	r2,-40(fp)
 8216ba4:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
 8216ba8:	e0bff617 	ldw	r2,-40(fp)
 8216bac:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
 8216bb0:	d0a06e17 	ldw	r2,-32328(gp)
 8216bb4:	10000326 	beq	r2,zero,8216bc4 <OS_TCBInit+0x22c>
            OSTCBList->OSTCBPrev = ptcb;
 8216bb8:	d0a06e17 	ldw	r2,-32328(gp)
 8216bbc:	e0fff617 	ldw	r3,-40(fp)
 8216bc0:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
 8216bc4:	e0bff617 	ldw	r2,-40(fp)
 8216bc8:	d0a06e15 	stw	r2,-32328(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
 8216bcc:	e0bff617 	ldw	r2,-40(fp)
 8216bd0:	10c00d83 	ldbu	r3,54(r2)
 8216bd4:	d0a07703 	ldbu	r2,-32292(gp)
 8216bd8:	1884b03a 	or	r2,r3,r2
 8216bdc:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 8216be0:	e0bff617 	ldw	r2,-40(fp)
 8216be4:	10800d03 	ldbu	r2,52(r2)
 8216be8:	10c03fcc 	andi	r3,r2,255
 8216bec:	e0bff617 	ldw	r2,-40(fp)
 8216bf0:	10800d03 	ldbu	r2,52(r2)
 8216bf4:	11003fcc 	andi	r4,r2,255
 8216bf8:	d0a07744 	addi	r2,gp,-32291
 8216bfc:	2085883a 	add	r2,r4,r2
 8216c00:	11000003 	ldbu	r4,0(r2)
 8216c04:	e0bff617 	ldw	r2,-40(fp)
 8216c08:	10800d43 	ldbu	r2,53(r2)
 8216c0c:	2084b03a 	or	r2,r4,r2
 8216c10:	1009883a 	mov	r4,r2
 8216c14:	d0a07744 	addi	r2,gp,-32291
 8216c18:	1885883a 	add	r2,r3,r2
 8216c1c:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
 8216c20:	d0a07343 	ldbu	r2,-32307(gp)
 8216c24:	10800044 	addi	r2,r2,1
 8216c28:	d0a07345 	stb	r2,-32307(gp)
 8216c2c:	e0bff417 	ldw	r2,-48(fp)
 8216c30:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8216c34:	e0bff717 	ldw	r2,-36(fp)
 8216c38:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 8216c3c:	0005883a 	mov	r2,zero
 8216c40:	00000506 	br	8216c58 <OS_TCBInit+0x2c0>
 8216c44:	e0bff417 	ldw	r2,-48(fp)
 8216c48:	e0bff915 	stw	r2,-28(fp)
 8216c4c:	e0bff917 	ldw	r2,-28(fp)
 8216c50:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
 8216c54:	00801084 	movi	r2,66
}
 8216c58:	e037883a 	mov	sp,fp
 8216c5c:	dfc00117 	ldw	ra,4(sp)
 8216c60:	df000017 	ldw	fp,0(sp)
 8216c64:	dec00204 	addi	sp,sp,8
 8216c68:	f800283a 	ret

08216c6c <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
 8216c6c:	defffe04 	addi	sp,sp,-8
 8216c70:	df000115 	stw	fp,4(sp)
 8216c74:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
 8216c78:	d0a00c04 	addi	r2,gp,-32720
 8216c7c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
 8216c80:	d0a00d04 	addi	r2,gp,-32716
 8216c84:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
 8216c88:	d0a00e84 	addi	r2,gp,-32710
 8216c8c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
 8216c90:	d0a00f04 	addi	r2,gp,-32708
 8216c94:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
 8216c98:	d0a00e04 	addi	r2,gp,-32712
 8216c9c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
 8216ca0:	d0a00f84 	addi	r2,gp,-32706
 8216ca4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
 8216ca8:	d0a01004 	addi	r2,gp,-32704
 8216cac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
 8216cb0:	d0a01084 	addi	r2,gp,-32702
 8216cb4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
 8216cb8:	d0a01104 	addi	r2,gp,-32700
 8216cbc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
 8216cc0:	d0a01184 	addi	r2,gp,-32698
 8216cc4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
 8216cc8:	d0a01204 	addi	r2,gp,-32696
 8216ccc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
 8216cd0:	d0a01284 	addi	r2,gp,-32694
 8216cd4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
 8216cd8:	d0a01304 	addi	r2,gp,-32692
 8216cdc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
 8216ce0:	d0a01384 	addi	r2,gp,-32690
 8216ce4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
 8216ce8:	d0a01404 	addi	r2,gp,-32688
 8216cec:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
 8216cf0:	d0a01484 	addi	r2,gp,-32686
 8216cf4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
 8216cf8:	d0a01504 	addi	r2,gp,-32684
 8216cfc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
 8216d00:	d0a01584 	addi	r2,gp,-32682
 8216d04:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
 8216d08:	d0a01604 	addi	r2,gp,-32680
 8216d0c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
 8216d10:	d0a01684 	addi	r2,gp,-32678
 8216d14:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
 8216d18:	d0a01704 	addi	r2,gp,-32676
 8216d1c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
 8216d20:	d0a01784 	addi	r2,gp,-32674
 8216d24:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
 8216d28:	d0a01804 	addi	r2,gp,-32672
 8216d2c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
 8216d30:	d0a01884 	addi	r2,gp,-32670
 8216d34:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
 8216d38:	d0a01904 	addi	r2,gp,-32668
 8216d3c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
 8216d40:	d0a01984 	addi	r2,gp,-32666
 8216d44:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
 8216d48:	d0a01a04 	addi	r2,gp,-32664
 8216d4c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
 8216d50:	d0a01a84 	addi	r2,gp,-32662
 8216d54:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
 8216d58:	d0a01b04 	addi	r2,gp,-32660
 8216d5c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
 8216d60:	d0a01b84 	addi	r2,gp,-32658
 8216d64:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
 8216d68:	d0a01c04 	addi	r2,gp,-32656
 8216d6c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
 8216d70:	d0a01c84 	addi	r2,gp,-32654
 8216d74:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
 8216d78:	d0a01d04 	addi	r2,gp,-32652
 8216d7c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
 8216d80:	d0a01d84 	addi	r2,gp,-32650
 8216d84:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
 8216d88:	d0a01e04 	addi	r2,gp,-32648
 8216d8c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
 8216d90:	d0a01e84 	addi	r2,gp,-32646
 8216d94:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
 8216d98:	d0a01f04 	addi	r2,gp,-32644
 8216d9c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
 8216da0:	d0a01f84 	addi	r2,gp,-32642
 8216da4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
 8216da8:	d0a02004 	addi	r2,gp,-32640
 8216dac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
 8216db0:	d0a02084 	addi	r2,gp,-32638
 8216db4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
 8216db8:	d0a02104 	addi	r2,gp,-32636
 8216dbc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
 8216dc0:	d0a02184 	addi	r2,gp,-32634
 8216dc4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
 8216dc8:	d0a02204 	addi	r2,gp,-32632
 8216dcc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
 8216dd0:	d0a02284 	addi	r2,gp,-32630
 8216dd4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
    ptemp = (void *)&OSTmrWheelTblSize;
#endif

    ptemp = (void *)&OSVersionNbr;
 8216dd8:	d0a02304 	addi	r2,gp,-32628
 8216ddc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
 8216de0:	d0a02804 	addi	r2,gp,-32608
 8216de4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
 8216de8:	0001883a 	nop
 8216dec:	e037883a 	mov	sp,fp
 8216df0:	df000017 	ldw	fp,0(sp)
 8216df4:	dec00104 	addi	sp,sp,4
 8216df8:	f800283a 	ret

08216dfc <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
 8216dfc:	defff204 	addi	sp,sp,-56
 8216e00:	df000d15 	stw	fp,52(sp)
 8216e04:	df000d04 	addi	fp,sp,52
 8216e08:	e13ffc15 	stw	r4,-16(fp)
 8216e0c:	2807883a 	mov	r3,r5
 8216e10:	3005883a 	mov	r2,r6
 8216e14:	e1ffff15 	stw	r7,-4(fp)
 8216e18:	e0fffd0d 	sth	r3,-12(fp)
 8216e1c:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 8216e20:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 8216e24:	e0bfff17 	ldw	r2,-4(fp)
 8216e28:	1000021e 	bne	r2,zero,8216e34 <OSFlagAccept+0x38>
        return ((OS_FLAGS)0);
 8216e2c:	0005883a 	mov	r2,zero
 8216e30:	0000b006 	br	82170f4 <OSFlagAccept+0x2f8>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 8216e34:	e0bffc17 	ldw	r2,-16(fp)
 8216e38:	1000051e 	bne	r2,zero,8216e50 <OSFlagAccept+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8216e3c:	e0bfff17 	ldw	r2,-4(fp)
 8216e40:	00c01b84 	movi	r3,110
 8216e44:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8216e48:	0005883a 	mov	r2,zero
 8216e4c:	0000a906 	br	82170f4 <OSFlagAccept+0x2f8>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 8216e50:	e0bffc17 	ldw	r2,-16(fp)
 8216e54:	10800003 	ldbu	r2,0(r2)
 8216e58:	10803fcc 	andi	r2,r2,255
 8216e5c:	10800160 	cmpeqi	r2,r2,5
 8216e60:	1000051e 	bne	r2,zero,8216e78 <OSFlagAccept+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 8216e64:	e0bfff17 	ldw	r2,-4(fp)
 8216e68:	00c00044 	movi	r3,1
 8216e6c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8216e70:	0005883a 	mov	r2,zero
 8216e74:	00009f06 	br	82170f4 <OSFlagAccept+0x2f8>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 8216e78:	e0fffe03 	ldbu	r3,-8(fp)
 8216e7c:	00bfe004 	movi	r2,-128
 8216e80:	1884703a 	and	r2,r3,r2
 8216e84:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
 8216e88:	e0bff503 	ldbu	r2,-44(fp)
 8216e8c:	10000626 	beq	r2,zero,8216ea8 <OSFlagAccept+0xac>
        wait_type &= ~OS_FLAG_CONSUME;
 8216e90:	e0bffe03 	ldbu	r2,-8(fp)
 8216e94:	10801fcc 	andi	r2,r2,127
 8216e98:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
 8216e9c:	00800044 	movi	r2,1
 8216ea0:	e0bff385 	stb	r2,-50(fp)
 8216ea4:	00000106 	br	8216eac <OSFlagAccept+0xb0>
    } else {
        consume    = OS_FALSE;
 8216ea8:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
 8216eac:	e0bfff17 	ldw	r2,-4(fp)
 8216eb0:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8216eb4:	0005303a 	rdctl	r2,status
 8216eb8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8216ebc:	e0fffb17 	ldw	r3,-20(fp)
 8216ec0:	00bfff84 	movi	r2,-2
 8216ec4:	1884703a 	and	r2,r3,r2
 8216ec8:	1001703a 	wrctl	status,r2
  
  return context;
 8216ecc:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
 8216ed0:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
 8216ed4:	e0bffe03 	ldbu	r2,-8(fp)
 8216ed8:	10c00060 	cmpeqi	r3,r2,1
 8216edc:	18005f1e 	bne	r3,zero,821705c <OSFlagAccept+0x260>
 8216ee0:	10c00088 	cmpgei	r3,r2,2
 8216ee4:	1800021e 	bne	r3,zero,8216ef0 <OSFlagAccept+0xf4>
 8216ee8:	10003f26 	beq	r2,zero,8216fe8 <OSFlagAccept+0x1ec>
 8216eec:	00007706 	br	82170cc <OSFlagAccept+0x2d0>
 8216ef0:	10c000a0 	cmpeqi	r3,r2,2
 8216ef4:	1800031e 	bne	r3,zero,8216f04 <OSFlagAccept+0x108>
 8216ef8:	108000e0 	cmpeqi	r2,r2,3
 8216efc:	10001e1e 	bne	r2,zero,8216f78 <OSFlagAccept+0x17c>
 8216f00:	00007206 	br	82170cc <OSFlagAccept+0x2d0>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 8216f04:	e0bffc17 	ldw	r2,-16(fp)
 8216f08:	10c0020b 	ldhu	r3,8(r2)
 8216f0c:	e0bffd0b 	ldhu	r2,-12(fp)
 8216f10:	1884703a 	and	r2,r3,r2
 8216f14:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 8216f18:	e0fff30b 	ldhu	r3,-52(fp)
 8216f1c:	e0bffd0b 	ldhu	r2,-12(fp)
 8216f20:	18800d1e 	bne	r3,r2,8216f58 <OSFlagAccept+0x15c>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8216f24:	e0bff383 	ldbu	r2,-50(fp)
 8216f28:	10800058 	cmpnei	r2,r2,1
 8216f2c:	10000d1e 	bne	r2,zero,8216f64 <OSFlagAccept+0x168>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 8216f30:	e0bffc17 	ldw	r2,-16(fp)
 8216f34:	1080020b 	ldhu	r2,8(r2)
 8216f38:	1007883a 	mov	r3,r2
 8216f3c:	e0bff30b 	ldhu	r2,-52(fp)
 8216f40:	0084303a 	nor	r2,zero,r2
 8216f44:	1884703a 	and	r2,r3,r2
 8216f48:	1007883a 	mov	r3,r2
 8216f4c:	e0bffc17 	ldw	r2,-16(fp)
 8216f50:	10c0020d 	sth	r3,8(r2)
 8216f54:	00000306 	br	8216f64 <OSFlagAccept+0x168>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 8216f58:	e0bfff17 	ldw	r2,-4(fp)
 8216f5c:	00c01c04 	movi	r3,112
 8216f60:	10c00005 	stb	r3,0(r2)
 8216f64:	e0bff417 	ldw	r2,-48(fp)
 8216f68:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8216f6c:	e0bff617 	ldw	r2,-40(fp)
 8216f70:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 8216f74:	00005e06 	br	82170f0 <OSFlagAccept+0x2f4>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 8216f78:	e0bffc17 	ldw	r2,-16(fp)
 8216f7c:	10c0020b 	ldhu	r3,8(r2)
 8216f80:	e0bffd0b 	ldhu	r2,-12(fp)
 8216f84:	1884703a 	and	r2,r3,r2
 8216f88:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 8216f8c:	e0bff30b 	ldhu	r2,-52(fp)
 8216f90:	10000d26 	beq	r2,zero,8216fc8 <OSFlagAccept+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8216f94:	e0bff383 	ldbu	r2,-50(fp)
 8216f98:	10800058 	cmpnei	r2,r2,1
 8216f9c:	10000d1e 	bne	r2,zero,8216fd4 <OSFlagAccept+0x1d8>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 8216fa0:	e0bffc17 	ldw	r2,-16(fp)
 8216fa4:	1080020b 	ldhu	r2,8(r2)
 8216fa8:	1007883a 	mov	r3,r2
 8216fac:	e0bff30b 	ldhu	r2,-52(fp)
 8216fb0:	0084303a 	nor	r2,zero,r2
 8216fb4:	1884703a 	and	r2,r3,r2
 8216fb8:	1007883a 	mov	r3,r2
 8216fbc:	e0bffc17 	ldw	r2,-16(fp)
 8216fc0:	10c0020d 	sth	r3,8(r2)
 8216fc4:	00000306 	br	8216fd4 <OSFlagAccept+0x1d8>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 8216fc8:	e0bfff17 	ldw	r2,-4(fp)
 8216fcc:	00c01c04 	movi	r3,112
 8216fd0:	10c00005 	stb	r3,0(r2)
 8216fd4:	e0bff417 	ldw	r2,-48(fp)
 8216fd8:	e0bff715 	stw	r2,-36(fp)
 8216fdc:	e0bff717 	ldw	r2,-36(fp)
 8216fe0:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 8216fe4:	00004206 	br	82170f0 <OSFlagAccept+0x2f4>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 8216fe8:	e0bffc17 	ldw	r2,-16(fp)
 8216fec:	1080020b 	ldhu	r2,8(r2)
 8216ff0:	0084303a 	nor	r2,zero,r2
 8216ff4:	1007883a 	mov	r3,r2
 8216ff8:	e0bffd0b 	ldhu	r2,-12(fp)
 8216ffc:	1884703a 	and	r2,r3,r2
 8217000:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 8217004:	e0fff30b 	ldhu	r3,-52(fp)
 8217008:	e0bffd0b 	ldhu	r2,-12(fp)
 821700c:	18800b1e 	bne	r3,r2,821703c <OSFlagAccept+0x240>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8217010:	e0bff383 	ldbu	r2,-50(fp)
 8217014:	10800058 	cmpnei	r2,r2,1
 8217018:	10000b1e 	bne	r2,zero,8217048 <OSFlagAccept+0x24c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 821701c:	e0bffc17 	ldw	r2,-16(fp)
 8217020:	10c0020b 	ldhu	r3,8(r2)
 8217024:	e0bff30b 	ldhu	r2,-52(fp)
 8217028:	1884b03a 	or	r2,r3,r2
 821702c:	1007883a 	mov	r3,r2
 8217030:	e0bffc17 	ldw	r2,-16(fp)
 8217034:	10c0020d 	sth	r3,8(r2)
 8217038:	00000306 	br	8217048 <OSFlagAccept+0x24c>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 821703c:	e0bfff17 	ldw	r2,-4(fp)
 8217040:	00c01c04 	movi	r3,112
 8217044:	10c00005 	stb	r3,0(r2)
 8217048:	e0bff417 	ldw	r2,-48(fp)
 821704c:	e0bff815 	stw	r2,-32(fp)
 8217050:	e0bff817 	ldw	r2,-32(fp)
 8217054:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 8217058:	00002506 	br	82170f0 <OSFlagAccept+0x2f4>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 821705c:	e0bffc17 	ldw	r2,-16(fp)
 8217060:	1080020b 	ldhu	r2,8(r2)
 8217064:	0084303a 	nor	r2,zero,r2
 8217068:	1007883a 	mov	r3,r2
 821706c:	e0bffd0b 	ldhu	r2,-12(fp)
 8217070:	1884703a 	and	r2,r3,r2
 8217074:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 8217078:	e0bff30b 	ldhu	r2,-52(fp)
 821707c:	10000b26 	beq	r2,zero,82170ac <OSFlagAccept+0x2b0>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8217080:	e0bff383 	ldbu	r2,-50(fp)
 8217084:	10800058 	cmpnei	r2,r2,1
 8217088:	10000b1e 	bne	r2,zero,82170b8 <OSFlagAccept+0x2bc>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 821708c:	e0bffc17 	ldw	r2,-16(fp)
 8217090:	10c0020b 	ldhu	r3,8(r2)
 8217094:	e0bff30b 	ldhu	r2,-52(fp)
 8217098:	1884b03a 	or	r2,r3,r2
 821709c:	1007883a 	mov	r3,r2
 82170a0:	e0bffc17 	ldw	r2,-16(fp)
 82170a4:	10c0020d 	sth	r3,8(r2)
 82170a8:	00000306 	br	82170b8 <OSFlagAccept+0x2bc>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 82170ac:	e0bfff17 	ldw	r2,-4(fp)
 82170b0:	00c01c04 	movi	r3,112
 82170b4:	10c00005 	stb	r3,0(r2)
 82170b8:	e0bff417 	ldw	r2,-48(fp)
 82170bc:	e0bff915 	stw	r2,-28(fp)
 82170c0:	e0bff917 	ldw	r2,-28(fp)
 82170c4:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 82170c8:	00000906 	br	82170f0 <OSFlagAccept+0x2f4>
 82170cc:	e0bff417 	ldw	r2,-48(fp)
 82170d0:	e0bffa15 	stw	r2,-24(fp)
 82170d4:	e0bffa17 	ldw	r2,-24(fp)
 82170d8:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 82170dc:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
 82170e0:	e0bfff17 	ldw	r2,-4(fp)
 82170e4:	00c01bc4 	movi	r3,111
 82170e8:	10c00005 	stb	r3,0(r2)
             break;
 82170ec:	0001883a 	nop
    }
    return (flags_rdy);
 82170f0:	e0bff30b 	ldhu	r2,-52(fp)
}
 82170f4:	e037883a 	mov	sp,fp
 82170f8:	df000017 	ldw	fp,0(sp)
 82170fc:	dec00104 	addi	sp,sp,4
 8217100:	f800283a 	ret

08217104 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
 8217104:	defff804 	addi	sp,sp,-32
 8217108:	df000715 	stw	fp,28(sp)
 821710c:	df000704 	addi	fp,sp,28
 8217110:	2005883a 	mov	r2,r4
 8217114:	e17fff15 	stw	r5,-4(fp)
 8217118:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
 821711c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
 8217120:	e0bfff17 	ldw	r2,-4(fp)
 8217124:	1000021e 	bne	r2,zero,8217130 <OSFlagCreate+0x2c>
        return ((OS_FLAG_GRP *)0);
 8217128:	0005883a 	mov	r2,zero
 821712c:	00003306 	br	82171fc <OSFlagCreate+0xf8>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
 8217130:	d0a07903 	ldbu	r2,-32284(gp)
 8217134:	10803fcc 	andi	r2,r2,255
 8217138:	10000526 	beq	r2,zero,8217150 <OSFlagCreate+0x4c>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
 821713c:	e0bfff17 	ldw	r2,-4(fp)
 8217140:	00c00404 	movi	r3,16
 8217144:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
 8217148:	0005883a 	mov	r2,zero
 821714c:	00002b06 	br	82171fc <OSFlagCreate+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217150:	0005303a 	rdctl	r2,status
 8217154:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217158:	e0fffd17 	ldw	r3,-12(fp)
 821715c:	00bfff84 	movi	r2,-2
 8217160:	1884703a 	and	r2,r3,r2
 8217164:	1001703a 	wrctl	status,r2
  
  return context;
 8217168:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 821716c:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
 8217170:	d0a07c17 	ldw	r2,-32272(gp)
 8217174:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
 8217178:	e0bffb17 	ldw	r2,-20(fp)
 821717c:	10001726 	beq	r2,zero,82171dc <OSFlagCreate+0xd8>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
 8217180:	d0a07c17 	ldw	r2,-32272(gp)
 8217184:	10800117 	ldw	r2,4(r2)
 8217188:	d0a07c15 	stw	r2,-32272(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
 821718c:	e0bffb17 	ldw	r2,-20(fp)
 8217190:	00c00144 	movi	r3,5
 8217194:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
 8217198:	e0bffb17 	ldw	r2,-20(fp)
 821719c:	e0fffe0b 	ldhu	r3,-8(fp)
 82171a0:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
 82171a4:	e0bffb17 	ldw	r2,-20(fp)
 82171a8:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
 82171ac:	e0bffb17 	ldw	r2,-20(fp)
 82171b0:	00c00fc4 	movi	r3,63
 82171b4:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 82171b8:	e0bffb17 	ldw	r2,-20(fp)
 82171bc:	100002c5 	stb	zero,11(r2)
 82171c0:	e0bff917 	ldw	r2,-28(fp)
 82171c4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82171c8:	e0bffa17 	ldw	r2,-24(fp)
 82171cc:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
 82171d0:	e0bfff17 	ldw	r2,-4(fp)
 82171d4:	10000005 	stb	zero,0(r2)
 82171d8:	00000706 	br	82171f8 <OSFlagCreate+0xf4>
 82171dc:	e0bff917 	ldw	r2,-28(fp)
 82171e0:	e0bffc15 	stw	r2,-16(fp)
 82171e4:	e0bffc17 	ldw	r2,-16(fp)
 82171e8:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
 82171ec:	e0bfff17 	ldw	r2,-4(fp)
 82171f0:	00c01c84 	movi	r3,114
 82171f4:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
 82171f8:	e0bffb17 	ldw	r2,-20(fp)
}
 82171fc:	e037883a 	mov	sp,fp
 8217200:	df000017 	ldw	fp,0(sp)
 8217204:	dec00104 	addi	sp,sp,4
 8217208:	f800283a 	ret

0821720c <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
 821720c:	defff204 	addi	sp,sp,-56
 8217210:	dfc00d15 	stw	ra,52(sp)
 8217214:	df000c15 	stw	fp,48(sp)
 8217218:	df000c04 	addi	fp,sp,48
 821721c:	e13ffd15 	stw	r4,-12(fp)
 8217220:	2805883a 	mov	r2,r5
 8217224:	e1bfff15 	stw	r6,-4(fp)
 8217228:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 821722c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 8217230:	e0bfff17 	ldw	r2,-4(fp)
 8217234:	1000021e 	bne	r2,zero,8217240 <OSFlagDel+0x34>
        return (pgrp);
 8217238:	e0bffd17 	ldw	r2,-12(fp)
 821723c:	00008006 	br	8217440 <OSFlagDel+0x234>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 8217240:	e0bffd17 	ldw	r2,-12(fp)
 8217244:	1000051e 	bne	r2,zero,821725c <OSFlagDel+0x50>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8217248:	e0bfff17 	ldw	r2,-4(fp)
 821724c:	00c01b84 	movi	r3,110
 8217250:	10c00005 	stb	r3,0(r2)
        return (pgrp);
 8217254:	e0bffd17 	ldw	r2,-12(fp)
 8217258:	00007906 	br	8217440 <OSFlagDel+0x234>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 821725c:	d0a07903 	ldbu	r2,-32284(gp)
 8217260:	10803fcc 	andi	r2,r2,255
 8217264:	10000526 	beq	r2,zero,821727c <OSFlagDel+0x70>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 8217268:	e0bfff17 	ldw	r2,-4(fp)
 821726c:	00c003c4 	movi	r3,15
 8217270:	10c00005 	stb	r3,0(r2)
        return (pgrp);
 8217274:	e0bffd17 	ldw	r2,-12(fp)
 8217278:	00007106 	br	8217440 <OSFlagDel+0x234>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
 821727c:	e0bffd17 	ldw	r2,-12(fp)
 8217280:	10800003 	ldbu	r2,0(r2)
 8217284:	10803fcc 	andi	r2,r2,255
 8217288:	10800160 	cmpeqi	r2,r2,5
 821728c:	1000051e 	bne	r2,zero,82172a4 <OSFlagDel+0x98>
        *perr = OS_ERR_EVENT_TYPE;
 8217290:	e0bfff17 	ldw	r2,-4(fp)
 8217294:	00c00044 	movi	r3,1
 8217298:	10c00005 	stb	r3,0(r2)
        return (pgrp);
 821729c:	e0bffd17 	ldw	r2,-12(fp)
 82172a0:	00006706 	br	8217440 <OSFlagDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82172a4:	0005303a 	rdctl	r2,status
 82172a8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82172ac:	e0fffc17 	ldw	r3,-16(fp)
 82172b0:	00bfff84 	movi	r2,-2
 82172b4:	1884703a 	and	r2,r3,r2
 82172b8:	1001703a 	wrctl	status,r2
  
  return context;
 82172bc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 82172c0:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
 82172c4:	e0bffd17 	ldw	r2,-12(fp)
 82172c8:	10800117 	ldw	r2,4(r2)
 82172cc:	10000326 	beq	r2,zero,82172dc <OSFlagDel+0xd0>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 82172d0:	00800044 	movi	r2,1
 82172d4:	e0bff405 	stb	r2,-48(fp)
 82172d8:	00000106 	br	82172e0 <OSFlagDel+0xd4>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 82172dc:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
 82172e0:	e0bffe03 	ldbu	r2,-8(fp)
 82172e4:	10000326 	beq	r2,zero,82172f4 <OSFlagDel+0xe8>
 82172e8:	10800060 	cmpeqi	r2,r2,1
 82172ec:	1000231e 	bne	r2,zero,821737c <OSFlagDel+0x170>
 82172f0:	00004806 	br	8217414 <OSFlagDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
 82172f4:	e0bff403 	ldbu	r2,-48(fp)
 82172f8:	1000161e 	bne	r2,zero,8217354 <OSFlagDel+0x148>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
 82172fc:	e0bffd17 	ldw	r2,-12(fp)
 8217300:	00c00fc4 	movi	r3,63
 8217304:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 8217308:	e0bffd17 	ldw	r2,-12(fp)
 821730c:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 8217310:	e0bffd17 	ldw	r2,-12(fp)
 8217314:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
 8217318:	d0e07c17 	ldw	r3,-32272(gp)
 821731c:	e0bffd17 	ldw	r2,-12(fp)
 8217320:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
 8217324:	e0bffd17 	ldw	r2,-12(fp)
 8217328:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
 821732c:	e0bffd17 	ldw	r2,-12(fp)
 8217330:	d0a07c15 	stw	r2,-32272(gp)
 8217334:	e0bff717 	ldw	r2,-36(fp)
 8217338:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821733c:	e0bff817 	ldw	r2,-32(fp)
 8217340:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
 8217344:	e0bfff17 	ldw	r2,-4(fp)
 8217348:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
 821734c:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
 8217350:	00003a06 	br	821743c <OSFlagDel+0x230>
 8217354:	e0bff717 	ldw	r2,-36(fp)
 8217358:	e0bff915 	stw	r2,-28(fp)
 821735c:	e0bff917 	ldw	r2,-28(fp)
 8217360:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
 8217364:	e0bfff17 	ldw	r2,-4(fp)
 8217368:	00c01244 	movi	r3,73
 821736c:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
 8217370:	e0bffd17 	ldw	r2,-12(fp)
 8217374:	e0bff615 	stw	r2,-40(fp)
             }
             break;
 8217378:	00003006 	br	821743c <OSFlagDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 821737c:	e0bffd17 	ldw	r2,-12(fp)
 8217380:	10800117 	ldw	r2,4(r2)
 8217384:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 8217388:	00000606 	br	82173a4 <OSFlagDel+0x198>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
 821738c:	000b883a 	mov	r5,zero
 8217390:	e13ff517 	ldw	r4,-44(fp)
 8217394:	82183780 	call	8218378 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 8217398:	e0bff517 	ldw	r2,-44(fp)
 821739c:	10800017 	ldw	r2,0(r2)
 82173a0:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 82173a4:	e0bff517 	ldw	r2,-44(fp)
 82173a8:	103ff81e 	bne	r2,zero,821738c <OSFlagDel+0x180>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
 82173ac:	e0bffd17 	ldw	r2,-12(fp)
 82173b0:	00c00fc4 	movi	r3,63
 82173b4:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 82173b8:	e0bffd17 	ldw	r2,-12(fp)
 82173bc:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 82173c0:	e0bffd17 	ldw	r2,-12(fp)
 82173c4:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
 82173c8:	d0e07c17 	ldw	r3,-32272(gp)
 82173cc:	e0bffd17 	ldw	r2,-12(fp)
 82173d0:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
 82173d4:	e0bffd17 	ldw	r2,-12(fp)
 82173d8:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
 82173dc:	e0bffd17 	ldw	r2,-12(fp)
 82173e0:	d0a07c15 	stw	r2,-32272(gp)
 82173e4:	e0bff717 	ldw	r2,-36(fp)
 82173e8:	e0bffa15 	stw	r2,-24(fp)
 82173ec:	e0bffa17 	ldw	r2,-24(fp)
 82173f0:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 82173f4:	e0bff403 	ldbu	r2,-48(fp)
 82173f8:	10800058 	cmpnei	r2,r2,1
 82173fc:	1000011e 	bne	r2,zero,8217404 <OSFlagDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 8217400:	82165800 	call	8216580 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
 8217404:	e0bfff17 	ldw	r2,-4(fp)
 8217408:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
 821740c:	e03ff615 	stw	zero,-40(fp)
             break;
 8217410:	00000a06 	br	821743c <OSFlagDel+0x230>
 8217414:	e0bff717 	ldw	r2,-36(fp)
 8217418:	e0bffb15 	stw	r2,-20(fp)
 821741c:	e0bffb17 	ldw	r2,-20(fp)
 8217420:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
 8217424:	e0bfff17 	ldw	r2,-4(fp)
 8217428:	00c001c4 	movi	r3,7
 821742c:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
 8217430:	e0bffd17 	ldw	r2,-12(fp)
 8217434:	e0bff615 	stw	r2,-40(fp)
             break;
 8217438:	0001883a 	nop
    }
    return (pgrp_return);
 821743c:	e0bff617 	ldw	r2,-40(fp)
}
 8217440:	e037883a 	mov	sp,fp
 8217444:	dfc00117 	ldw	ra,4(sp)
 8217448:	df000017 	ldw	fp,0(sp)
 821744c:	dec00204 	addi	sp,sp,8
 8217450:	f800283a 	ret

08217454 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 8217454:	defff604 	addi	sp,sp,-40
 8217458:	dfc00915 	stw	ra,36(sp)
 821745c:	df000815 	stw	fp,32(sp)
 8217460:	df000804 	addi	fp,sp,32
 8217464:	e13ffd15 	stw	r4,-12(fp)
 8217468:	e17ffe15 	stw	r5,-8(fp)
 821746c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8217470:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8217474:	e0bfff17 	ldw	r2,-4(fp)
 8217478:	1000021e 	bne	r2,zero,8217484 <OSFlagNameGet+0x30>
        return (0);
 821747c:	0005883a 	mov	r2,zero
 8217480:	00003906 	br	8217568 <OSFlagNameGet+0x114>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 8217484:	e0bffd17 	ldw	r2,-12(fp)
 8217488:	1000051e 	bne	r2,zero,82174a0 <OSFlagNameGet+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 821748c:	e0bfff17 	ldw	r2,-4(fp)
 8217490:	00c01b84 	movi	r3,110
 8217494:	10c00005 	stb	r3,0(r2)
        return (0);
 8217498:	0005883a 	mov	r2,zero
 821749c:	00003206 	br	8217568 <OSFlagNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 82174a0:	e0bffe17 	ldw	r2,-8(fp)
 82174a4:	1000051e 	bne	r2,zero,82174bc <OSFlagNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
 82174a8:	e0bfff17 	ldw	r2,-4(fp)
 82174ac:	00c00304 	movi	r3,12
 82174b0:	10c00005 	stb	r3,0(r2)
        return (0);
 82174b4:	0005883a 	mov	r2,zero
 82174b8:	00002b06 	br	8217568 <OSFlagNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 82174bc:	d0a07903 	ldbu	r2,-32284(gp)
 82174c0:	10803fcc 	andi	r2,r2,255
 82174c4:	10000526 	beq	r2,zero,82174dc <OSFlagNameGet+0x88>
        *perr = OS_ERR_NAME_GET_ISR;
 82174c8:	e0bfff17 	ldw	r2,-4(fp)
 82174cc:	00c00444 	movi	r3,17
 82174d0:	10c00005 	stb	r3,0(r2)
        return (0);
 82174d4:	0005883a 	mov	r2,zero
 82174d8:	00002306 	br	8217568 <OSFlagNameGet+0x114>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82174dc:	0005303a 	rdctl	r2,status
 82174e0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82174e4:	e0fffc17 	ldw	r3,-16(fp)
 82174e8:	00bfff84 	movi	r2,-2
 82174ec:	1884703a 	and	r2,r3,r2
 82174f0:	1001703a 	wrctl	status,r2
  
  return context;
 82174f4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 82174f8:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 82174fc:	e0bffd17 	ldw	r2,-12(fp)
 8217500:	10800003 	ldbu	r2,0(r2)
 8217504:	10803fcc 	andi	r2,r2,255
 8217508:	10800160 	cmpeqi	r2,r2,5
 821750c:	1000091e 	bne	r2,zero,8217534 <OSFlagNameGet+0xe0>
 8217510:	e0bff817 	ldw	r2,-32(fp)
 8217514:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217518:	e0bff917 	ldw	r2,-28(fp)
 821751c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 8217520:	e0bfff17 	ldw	r2,-4(fp)
 8217524:	00c00044 	movi	r3,1
 8217528:	10c00005 	stb	r3,0(r2)
        return (0);
 821752c:	0005883a 	mov	r2,zero
 8217530:	00000d06 	br	8217568 <OSFlagNameGet+0x114>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
 8217534:	e0bffd17 	ldw	r2,-12(fp)
 8217538:	10800284 	addi	r2,r2,10
 821753c:	100b883a 	mov	r5,r2
 8217540:	e13ffe17 	ldw	r4,-8(fp)
 8217544:	82166c40 	call	82166c4 <OS_StrCopy>
 8217548:	e0bffb05 	stb	r2,-20(fp)
 821754c:	e0bff817 	ldw	r2,-32(fp)
 8217550:	e0bffa15 	stw	r2,-24(fp)
 8217554:	e0bffa17 	ldw	r2,-24(fp)
 8217558:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 821755c:	e0bfff17 	ldw	r2,-4(fp)
 8217560:	10000005 	stb	zero,0(r2)
    return (len);
 8217564:	e0bffb03 	ldbu	r2,-20(fp)
}
 8217568:	e037883a 	mov	sp,fp
 821756c:	dfc00117 	ldw	ra,4(sp)
 8217570:	df000017 	ldw	fp,0(sp)
 8217574:	dec00204 	addi	sp,sp,8
 8217578:	f800283a 	ret

0821757c <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 821757c:	defff504 	addi	sp,sp,-44
 8217580:	dfc00a15 	stw	ra,40(sp)
 8217584:	df000915 	stw	fp,36(sp)
 8217588:	df000904 	addi	fp,sp,36
 821758c:	e13ffd15 	stw	r4,-12(fp)
 8217590:	e17ffe15 	stw	r5,-8(fp)
 8217594:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8217598:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 821759c:	e0bfff17 	ldw	r2,-4(fp)
 82175a0:	10004326 	beq	r2,zero,82176b0 <OSFlagNameSet+0x134>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 82175a4:	e0bffd17 	ldw	r2,-12(fp)
 82175a8:	1000041e 	bne	r2,zero,82175bc <OSFlagNameSet+0x40>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 82175ac:	e0bfff17 	ldw	r2,-4(fp)
 82175b0:	00c01b84 	movi	r3,110
 82175b4:	10c00005 	stb	r3,0(r2)
        return;
 82175b8:	00003e06 	br	82176b4 <OSFlagNameSet+0x138>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 82175bc:	e0bffe17 	ldw	r2,-8(fp)
 82175c0:	1000041e 	bne	r2,zero,82175d4 <OSFlagNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
 82175c4:	e0bfff17 	ldw	r2,-4(fp)
 82175c8:	00c00304 	movi	r3,12
 82175cc:	10c00005 	stb	r3,0(r2)
        return;
 82175d0:	00003806 	br	82176b4 <OSFlagNameSet+0x138>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 82175d4:	d0a07903 	ldbu	r2,-32284(gp)
 82175d8:	10803fcc 	andi	r2,r2,255
 82175dc:	10000426 	beq	r2,zero,82175f0 <OSFlagNameSet+0x74>
        *perr = OS_ERR_NAME_SET_ISR;
 82175e0:	e0bfff17 	ldw	r2,-4(fp)
 82175e4:	00c00484 	movi	r3,18
 82175e8:	10c00005 	stb	r3,0(r2)
        return;
 82175ec:	00003106 	br	82176b4 <OSFlagNameSet+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82175f0:	0005303a 	rdctl	r2,status
 82175f4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82175f8:	e0fffc17 	ldw	r3,-16(fp)
 82175fc:	00bfff84 	movi	r2,-2
 8217600:	1884703a 	and	r2,r3,r2
 8217604:	1001703a 	wrctl	status,r2
  
  return context;
 8217608:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821760c:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 8217610:	e0bffd17 	ldw	r2,-12(fp)
 8217614:	10800003 	ldbu	r2,0(r2)
 8217618:	10803fcc 	andi	r2,r2,255
 821761c:	10800160 	cmpeqi	r2,r2,5
 8217620:	1000081e 	bne	r2,zero,8217644 <OSFlagNameSet+0xc8>
 8217624:	e0bff717 	ldw	r2,-36(fp)
 8217628:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821762c:	e0bff817 	ldw	r2,-32(fp)
 8217630:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 8217634:	e0bfff17 	ldw	r2,-4(fp)
 8217638:	00c00044 	movi	r3,1
 821763c:	10c00005 	stb	r3,0(r2)
        return;
 8217640:	00001c06 	br	82176b4 <OSFlagNameSet+0x138>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 8217644:	e13ffe17 	ldw	r4,-8(fp)
 8217648:	82167380 	call	8216738 <OS_StrLen>
 821764c:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
 8217650:	e0bffa03 	ldbu	r2,-24(fp)
 8217654:	10800830 	cmpltui	r2,r2,32
 8217658:	1000081e 	bne	r2,zero,821767c <OSFlagNameSet+0x100>
 821765c:	e0bff717 	ldw	r2,-36(fp)
 8217660:	e0bff915 	stw	r2,-28(fp)
 8217664:	e0bff917 	ldw	r2,-28(fp)
 8217668:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
 821766c:	e0bfff17 	ldw	r2,-4(fp)
 8217670:	00c01cc4 	movi	r3,115
 8217674:	10c00005 	stb	r3,0(r2)
        return;
 8217678:	00000e06 	br	82176b4 <OSFlagNameSet+0x138>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
 821767c:	e0bffd17 	ldw	r2,-12(fp)
 8217680:	10800284 	addi	r2,r2,10
 8217684:	e17ffe17 	ldw	r5,-8(fp)
 8217688:	1009883a 	mov	r4,r2
 821768c:	82166c40 	call	82166c4 <OS_StrCopy>
 8217690:	e0bff717 	ldw	r2,-36(fp)
 8217694:	e0bffb15 	stw	r2,-20(fp)
 8217698:	e0bffb17 	ldw	r2,-20(fp)
 821769c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 82176a0:	e0bfff17 	ldw	r2,-4(fp)
 82176a4:	10000005 	stb	zero,0(r2)
    return;
 82176a8:	0001883a 	nop
 82176ac:	00000106 	br	82176b4 <OSFlagNameSet+0x138>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
 82176b0:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
 82176b4:	e037883a 	mov	sp,fp
 82176b8:	dfc00117 	ldw	ra,4(sp)
 82176bc:	df000017 	ldw	fp,0(sp)
 82176c0:	dec00204 	addi	sp,sp,8
 82176c4:	f800283a 	ret

082176c8 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
 82176c8:	deffe104 	addi	sp,sp,-124
 82176cc:	dfc01e15 	stw	ra,120(sp)
 82176d0:	df001d15 	stw	fp,116(sp)
 82176d4:	df001d04 	addi	fp,sp,116
 82176d8:	e13ffc15 	stw	r4,-16(fp)
 82176dc:	2809883a 	mov	r4,r5
 82176e0:	3007883a 	mov	r3,r6
 82176e4:	3805883a 	mov	r2,r7
 82176e8:	e13ffd0d 	sth	r4,-12(fp)
 82176ec:	e0fffe05 	stb	r3,-8(fp)
 82176f0:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 82176f4:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 82176f8:	e0800217 	ldw	r2,8(fp)
 82176fc:	1000021e 	bne	r2,zero,8217708 <OSFlagPend+0x40>
        return ((OS_FLAGS)0);
 8217700:	0005883a 	mov	r2,zero
 8217704:	00015906 	br	8217c6c <OSFlagPend+0x5a4>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 8217708:	e0bffc17 	ldw	r2,-16(fp)
 821770c:	1000051e 	bne	r2,zero,8217724 <OSFlagPend+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8217710:	e0800217 	ldw	r2,8(fp)
 8217714:	00c01b84 	movi	r3,110
 8217718:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 821771c:	0005883a 	mov	r2,zero
 8217720:	00015206 	br	8217c6c <OSFlagPend+0x5a4>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 8217724:	d0a07903 	ldbu	r2,-32284(gp)
 8217728:	10803fcc 	andi	r2,r2,255
 821772c:	10000526 	beq	r2,zero,8217744 <OSFlagPend+0x7c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
 8217730:	e0800217 	ldw	r2,8(fp)
 8217734:	00c00084 	movi	r3,2
 8217738:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 821773c:	0005883a 	mov	r2,zero
 8217740:	00014a06 	br	8217c6c <OSFlagPend+0x5a4>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
 8217744:	d0a06b03 	ldbu	r2,-32340(gp)
 8217748:	10803fcc 	andi	r2,r2,255
 821774c:	10000526 	beq	r2,zero,8217764 <OSFlagPend+0x9c>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
 8217750:	e0800217 	ldw	r2,8(fp)
 8217754:	00c00344 	movi	r3,13
 8217758:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 821775c:	0005883a 	mov	r2,zero
 8217760:	00014206 	br	8217c6c <OSFlagPend+0x5a4>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 8217764:	e0bffc17 	ldw	r2,-16(fp)
 8217768:	10800003 	ldbu	r2,0(r2)
 821776c:	10803fcc 	andi	r2,r2,255
 8217770:	10800160 	cmpeqi	r2,r2,5
 8217774:	1000051e 	bne	r2,zero,821778c <OSFlagPend+0xc4>
        *perr = OS_ERR_EVENT_TYPE;
 8217778:	e0800217 	ldw	r2,8(fp)
 821777c:	00c00044 	movi	r3,1
 8217780:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217784:	0005883a 	mov	r2,zero
 8217788:	00013806 	br	8217c6c <OSFlagPend+0x5a4>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 821778c:	e0fffe03 	ldbu	r3,-8(fp)
 8217790:	00bfe004 	movi	r2,-128
 8217794:	1884703a 	and	r2,r3,r2
 8217798:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
 821779c:	e0bfe603 	ldbu	r2,-104(fp)
 82177a0:	10000626 	beq	r2,zero,82177bc <OSFlagPend+0xf4>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
 82177a4:	e0bffe03 	ldbu	r2,-8(fp)
 82177a8:	10801fcc 	andi	r2,r2,127
 82177ac:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
 82177b0:	00800044 	movi	r2,1
 82177b4:	e0bfe405 	stb	r2,-112(fp)
 82177b8:	00000106 	br	82177c0 <OSFlagPend+0xf8>
    } else {
        consume    = OS_FALSE;
 82177bc:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82177c0:	0005303a 	rdctl	r2,status
 82177c4:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82177c8:	e0fff617 	ldw	r3,-40(fp)
 82177cc:	00bfff84 	movi	r2,-2
 82177d0:	1884703a 	and	r2,r3,r2
 82177d4:	1001703a 	wrctl	status,r2
  
  return context;
 82177d8:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 82177dc:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
 82177e0:	e0bffe03 	ldbu	r2,-8(fp)
 82177e4:	10c00060 	cmpeqi	r3,r2,1
 82177e8:	1800921e 	bne	r3,zero,8217a34 <OSFlagPend+0x36c>
 82177ec:	10c00088 	cmpgei	r3,r2,2
 82177f0:	1800021e 	bne	r3,zero,82177fc <OSFlagPend+0x134>
 82177f4:	10006126 	beq	r2,zero,821797c <OSFlagPend+0x2b4>
 82177f8:	0000bb06 	br	8217ae8 <OSFlagPend+0x420>
 82177fc:	10c000a0 	cmpeqi	r3,r2,2
 8217800:	1800031e 	bne	r3,zero,8217810 <OSFlagPend+0x148>
 8217804:	108000e0 	cmpeqi	r2,r2,3
 8217808:	10002f1e 	bne	r2,zero,82178c8 <OSFlagPend+0x200>
 821780c:	0000b606 	br	8217ae8 <OSFlagPend+0x420>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
 8217810:	e0bffc17 	ldw	r2,-16(fp)
 8217814:	10c0020b 	ldhu	r3,8(r2)
 8217818:	e0bffd0b 	ldhu	r2,-12(fp)
 821781c:	1884703a 	and	r2,r3,r2
 8217820:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 8217824:	e0ffe80b 	ldhu	r3,-96(fp)
 8217828:	e0bffd0b 	ldhu	r2,-12(fp)
 821782c:	1880171e 	bne	r3,r2,821788c <OSFlagPend+0x1c4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8217830:	e0bfe403 	ldbu	r2,-112(fp)
 8217834:	10800058 	cmpnei	r2,r2,1
 8217838:	1000091e 	bne	r2,zero,8217860 <OSFlagPend+0x198>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 821783c:	e0bffc17 	ldw	r2,-16(fp)
 8217840:	1080020b 	ldhu	r2,8(r2)
 8217844:	1007883a 	mov	r3,r2
 8217848:	e0bfe80b 	ldhu	r2,-96(fp)
 821784c:	0084303a 	nor	r2,zero,r2
 8217850:	1884703a 	and	r2,r3,r2
 8217854:	1007883a 	mov	r3,r2
 8217858:	e0bffc17 	ldw	r2,-16(fp)
 821785c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 8217860:	d0a07a17 	ldw	r2,-32280(gp)
 8217864:	e0ffe80b 	ldhu	r3,-96(fp)
 8217868:	10c00b0d 	sth	r3,44(r2)
 821786c:	e0bfe517 	ldw	r2,-108(fp)
 8217870:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217874:	e0bfe717 	ldw	r2,-100(fp)
 8217878:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 821787c:	e0800217 	ldw	r2,8(fp)
 8217880:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 8217884:	e0bfe80b 	ldhu	r2,-96(fp)
 8217888:	0000f806 	br	8217c6c <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 821788c:	e13ffd0b 	ldhu	r4,-12(fp)
 8217890:	e17ffe03 	ldbu	r5,-8(fp)
 8217894:	e0bfff0b 	ldhu	r2,-4(fp)
 8217898:	e0fff704 	addi	r3,fp,-36
 821789c:	d8800015 	stw	r2,0(sp)
 82178a0:	280f883a 	mov	r7,r5
 82178a4:	200d883a 	mov	r6,r4
 82178a8:	180b883a 	mov	r5,r3
 82178ac:	e13ffc17 	ldw	r4,-16(fp)
 82178b0:	82181380 	call	8218138 <OS_FlagBlock>
 82178b4:	e0bfe517 	ldw	r2,-108(fp)
 82178b8:	e0bfe915 	stw	r2,-92(fp)
 82178bc:	e0bfe917 	ldw	r2,-92(fp)
 82178c0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 82178c4:	00009206 	br	8217b10 <OSFlagPend+0x448>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
 82178c8:	e0bffc17 	ldw	r2,-16(fp)
 82178cc:	10c0020b 	ldhu	r3,8(r2)
 82178d0:	e0bffd0b 	ldhu	r2,-12(fp)
 82178d4:	1884703a 	and	r2,r3,r2
 82178d8:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 82178dc:	e0bfe80b 	ldhu	r2,-96(fp)
 82178e0:	10001726 	beq	r2,zero,8217940 <OSFlagPend+0x278>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 82178e4:	e0bfe403 	ldbu	r2,-112(fp)
 82178e8:	10800058 	cmpnei	r2,r2,1
 82178ec:	1000091e 	bne	r2,zero,8217914 <OSFlagPend+0x24c>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 82178f0:	e0bffc17 	ldw	r2,-16(fp)
 82178f4:	1080020b 	ldhu	r2,8(r2)
 82178f8:	1007883a 	mov	r3,r2
 82178fc:	e0bfe80b 	ldhu	r2,-96(fp)
 8217900:	0084303a 	nor	r2,zero,r2
 8217904:	1884703a 	and	r2,r3,r2
 8217908:	1007883a 	mov	r3,r2
 821790c:	e0bffc17 	ldw	r2,-16(fp)
 8217910:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 8217914:	d0a07a17 	ldw	r2,-32280(gp)
 8217918:	e0ffe80b 	ldhu	r3,-96(fp)
 821791c:	10c00b0d 	sth	r3,44(r2)
 8217920:	e0bfe517 	ldw	r2,-108(fp)
 8217924:	e0bfea15 	stw	r2,-88(fp)
 8217928:	e0bfea17 	ldw	r2,-88(fp)
 821792c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 8217930:	e0800217 	ldw	r2,8(fp)
 8217934:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 8217938:	e0bfe80b 	ldhu	r2,-96(fp)
 821793c:	0000cb06 	br	8217c6c <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 8217940:	e13ffd0b 	ldhu	r4,-12(fp)
 8217944:	e17ffe03 	ldbu	r5,-8(fp)
 8217948:	e0bfff0b 	ldhu	r2,-4(fp)
 821794c:	e0fff704 	addi	r3,fp,-36
 8217950:	d8800015 	stw	r2,0(sp)
 8217954:	280f883a 	mov	r7,r5
 8217958:	200d883a 	mov	r6,r4
 821795c:	180b883a 	mov	r5,r3
 8217960:	e13ffc17 	ldw	r4,-16(fp)
 8217964:	82181380 	call	8218138 <OS_FlagBlock>
 8217968:	e0bfe517 	ldw	r2,-108(fp)
 821796c:	e0bfeb15 	stw	r2,-84(fp)
 8217970:	e0bfeb17 	ldw	r2,-84(fp)
 8217974:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 8217978:	00006506 	br	8217b10 <OSFlagPend+0x448>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 821797c:	e0bffc17 	ldw	r2,-16(fp)
 8217980:	1080020b 	ldhu	r2,8(r2)
 8217984:	0084303a 	nor	r2,zero,r2
 8217988:	1007883a 	mov	r3,r2
 821798c:	e0bffd0b 	ldhu	r2,-12(fp)
 8217990:	1884703a 	and	r2,r3,r2
 8217994:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 8217998:	e0ffe80b 	ldhu	r3,-96(fp)
 821799c:	e0bffd0b 	ldhu	r2,-12(fp)
 82179a0:	1880151e 	bne	r3,r2,82179f8 <OSFlagPend+0x330>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 82179a4:	e0bfe403 	ldbu	r2,-112(fp)
 82179a8:	10800058 	cmpnei	r2,r2,1
 82179ac:	1000071e 	bne	r2,zero,82179cc <OSFlagPend+0x304>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 82179b0:	e0bffc17 	ldw	r2,-16(fp)
 82179b4:	10c0020b 	ldhu	r3,8(r2)
 82179b8:	e0bfe80b 	ldhu	r2,-96(fp)
 82179bc:	1884b03a 	or	r2,r3,r2
 82179c0:	1007883a 	mov	r3,r2
 82179c4:	e0bffc17 	ldw	r2,-16(fp)
 82179c8:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 82179cc:	d0a07a17 	ldw	r2,-32280(gp)
 82179d0:	e0ffe80b 	ldhu	r3,-96(fp)
 82179d4:	10c00b0d 	sth	r3,44(r2)
 82179d8:	e0bfe517 	ldw	r2,-108(fp)
 82179dc:	e0bfec15 	stw	r2,-80(fp)
 82179e0:	e0bfec17 	ldw	r2,-80(fp)
 82179e4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 82179e8:	e0800217 	ldw	r2,8(fp)
 82179ec:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 82179f0:	e0bfe80b 	ldhu	r2,-96(fp)
 82179f4:	00009d06 	br	8217c6c <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 82179f8:	e13ffd0b 	ldhu	r4,-12(fp)
 82179fc:	e17ffe03 	ldbu	r5,-8(fp)
 8217a00:	e0bfff0b 	ldhu	r2,-4(fp)
 8217a04:	e0fff704 	addi	r3,fp,-36
 8217a08:	d8800015 	stw	r2,0(sp)
 8217a0c:	280f883a 	mov	r7,r5
 8217a10:	200d883a 	mov	r6,r4
 8217a14:	180b883a 	mov	r5,r3
 8217a18:	e13ffc17 	ldw	r4,-16(fp)
 8217a1c:	82181380 	call	8218138 <OS_FlagBlock>
 8217a20:	e0bfe517 	ldw	r2,-108(fp)
 8217a24:	e0bfed15 	stw	r2,-76(fp)
 8217a28:	e0bfed17 	ldw	r2,-76(fp)
 8217a2c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 8217a30:	00003706 	br	8217b10 <OSFlagPend+0x448>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 8217a34:	e0bffc17 	ldw	r2,-16(fp)
 8217a38:	1080020b 	ldhu	r2,8(r2)
 8217a3c:	0084303a 	nor	r2,zero,r2
 8217a40:	1007883a 	mov	r3,r2
 8217a44:	e0bffd0b 	ldhu	r2,-12(fp)
 8217a48:	1884703a 	and	r2,r3,r2
 8217a4c:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 8217a50:	e0bfe80b 	ldhu	r2,-96(fp)
 8217a54:	10001526 	beq	r2,zero,8217aac <OSFlagPend+0x3e4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8217a58:	e0bfe403 	ldbu	r2,-112(fp)
 8217a5c:	10800058 	cmpnei	r2,r2,1
 8217a60:	1000071e 	bne	r2,zero,8217a80 <OSFlagPend+0x3b8>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 8217a64:	e0bffc17 	ldw	r2,-16(fp)
 8217a68:	10c0020b 	ldhu	r3,8(r2)
 8217a6c:	e0bfe80b 	ldhu	r2,-96(fp)
 8217a70:	1884b03a 	or	r2,r3,r2
 8217a74:	1007883a 	mov	r3,r2
 8217a78:	e0bffc17 	ldw	r2,-16(fp)
 8217a7c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 8217a80:	d0a07a17 	ldw	r2,-32280(gp)
 8217a84:	e0ffe80b 	ldhu	r3,-96(fp)
 8217a88:	10c00b0d 	sth	r3,44(r2)
 8217a8c:	e0bfe517 	ldw	r2,-108(fp)
 8217a90:	e0bfee15 	stw	r2,-72(fp)
 8217a94:	e0bfee17 	ldw	r2,-72(fp)
 8217a98:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 8217a9c:	e0800217 	ldw	r2,8(fp)
 8217aa0:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 8217aa4:	e0bfe80b 	ldhu	r2,-96(fp)
 8217aa8:	00007006 	br	8217c6c <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 8217aac:	e13ffd0b 	ldhu	r4,-12(fp)
 8217ab0:	e17ffe03 	ldbu	r5,-8(fp)
 8217ab4:	e0bfff0b 	ldhu	r2,-4(fp)
 8217ab8:	e0fff704 	addi	r3,fp,-36
 8217abc:	d8800015 	stw	r2,0(sp)
 8217ac0:	280f883a 	mov	r7,r5
 8217ac4:	200d883a 	mov	r6,r4
 8217ac8:	180b883a 	mov	r5,r3
 8217acc:	e13ffc17 	ldw	r4,-16(fp)
 8217ad0:	82181380 	call	8218138 <OS_FlagBlock>
 8217ad4:	e0bfe517 	ldw	r2,-108(fp)
 8217ad8:	e0bfef15 	stw	r2,-68(fp)
 8217adc:	e0bfef17 	ldw	r2,-68(fp)
 8217ae0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 8217ae4:	00000a06 	br	8217b10 <OSFlagPend+0x448>
 8217ae8:	e0bfe517 	ldw	r2,-108(fp)
 8217aec:	e0bff015 	stw	r2,-64(fp)
 8217af0:	e0bff017 	ldw	r2,-64(fp)
 8217af4:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 8217af8:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
 8217afc:	e0800217 	ldw	r2,8(fp)
 8217b00:	00c01bc4 	movi	r3,111
 8217b04:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
 8217b08:	e0bfe80b 	ldhu	r2,-96(fp)
 8217b0c:	00005706 	br	8217c6c <OSFlagPend+0x5a4>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
 8217b10:	82165800 	call	8216580 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217b14:	0005303a 	rdctl	r2,status
 8217b18:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217b1c:	e0fff117 	ldw	r3,-60(fp)
 8217b20:	00bfff84 	movi	r2,-2
 8217b24:	1884703a 	and	r2,r3,r2
 8217b28:	1001703a 	wrctl	status,r2
  
  return context;
 8217b2c:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
 8217b30:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
 8217b34:	d0a07a17 	ldw	r2,-32280(gp)
 8217b38:	10800c43 	ldbu	r2,49(r2)
 8217b3c:	10803fcc 	andi	r2,r2,255
 8217b40:	10001c26 	beq	r2,zero,8217bb4 <OSFlagPend+0x4ec>
        pend_stat                = OSTCBCur->OSTCBStatPend;
 8217b44:	d0a07a17 	ldw	r2,-32280(gp)
 8217b48:	10800c43 	ldbu	r2,49(r2)
 8217b4c:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 8217b50:	d0a07a17 	ldw	r2,-32280(gp)
 8217b54:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
 8217b58:	e0bff704 	addi	r2,fp,-36
 8217b5c:	1009883a 	mov	r4,r2
 8217b60:	821846c0 	call	821846c <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
 8217b64:	d0a07a17 	ldw	r2,-32280(gp)
 8217b68:	10000c05 	stb	zero,48(r2)
 8217b6c:	e0bfe517 	ldw	r2,-108(fp)
 8217b70:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217b74:	e0bff217 	ldw	r2,-56(fp)
 8217b78:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
 8217b7c:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
 8217b80:	e0bff303 	ldbu	r2,-52(fp)
 8217b84:	108000a0 	cmpeqi	r2,r2,2
 8217b88:	10000426 	beq	r2,zero,8217b9c <OSFlagPend+0x4d4>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
 8217b8c:	e0800217 	ldw	r2,8(fp)
 8217b90:	00c00384 	movi	r3,14
 8217b94:	10c00005 	stb	r3,0(r2)
                 break;
 8217b98:	00000406 	br	8217bac <OSFlagPend+0x4e4>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
 8217b9c:	e0800217 	ldw	r2,8(fp)
 8217ba0:	00c00284 	movi	r3,10
 8217ba4:	10c00005 	stb	r3,0(r2)
                 break;
 8217ba8:	0001883a 	nop
        }
        return (flags_rdy);
 8217bac:	e0bfe80b 	ldhu	r2,-96(fp)
 8217bb0:	00002e06 	br	8217c6c <OSFlagPend+0x5a4>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
 8217bb4:	d0a07a17 	ldw	r2,-32280(gp)
 8217bb8:	10800b0b 	ldhu	r2,44(r2)
 8217bbc:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
 8217bc0:	e0bfe403 	ldbu	r2,-112(fp)
 8217bc4:	10800058 	cmpnei	r2,r2,1
 8217bc8:	1000211e 	bne	r2,zero,8217c50 <OSFlagPend+0x588>
        switch (wait_type) {
 8217bcc:	e0bffe03 	ldbu	r2,-8(fp)
 8217bd0:	10001616 	blt	r2,zero,8217c2c <OSFlagPend+0x564>
 8217bd4:	10c00090 	cmplti	r3,r2,2
 8217bd8:	18000c1e 	bne	r3,zero,8217c0c <OSFlagPend+0x544>
 8217bdc:	10800108 	cmpgei	r2,r2,4
 8217be0:	1000121e 	bne	r2,zero,8217c2c <OSFlagPend+0x564>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
 8217be4:	e0bffc17 	ldw	r2,-16(fp)
 8217be8:	1080020b 	ldhu	r2,8(r2)
 8217bec:	1007883a 	mov	r3,r2
 8217bf0:	e0bfe80b 	ldhu	r2,-96(fp)
 8217bf4:	0084303a 	nor	r2,zero,r2
 8217bf8:	1884703a 	and	r2,r3,r2
 8217bfc:	1007883a 	mov	r3,r2
 8217c00:	e0bffc17 	ldw	r2,-16(fp)
 8217c04:	10c0020d 	sth	r3,8(r2)
                 break;
 8217c08:	00001106 	br	8217c50 <OSFlagPend+0x588>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
 8217c0c:	e0bffc17 	ldw	r2,-16(fp)
 8217c10:	10c0020b 	ldhu	r3,8(r2)
 8217c14:	e0bfe80b 	ldhu	r2,-96(fp)
 8217c18:	1884b03a 	or	r2,r3,r2
 8217c1c:	1007883a 	mov	r3,r2
 8217c20:	e0bffc17 	ldw	r2,-16(fp)
 8217c24:	10c0020d 	sth	r3,8(r2)
                 break;
 8217c28:	00000906 	br	8217c50 <OSFlagPend+0x588>
 8217c2c:	e0bfe517 	ldw	r2,-108(fp)
 8217c30:	e0bff415 	stw	r2,-48(fp)
 8217c34:	e0bff417 	ldw	r2,-48(fp)
 8217c38:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 8217c3c:	e0800217 	ldw	r2,8(fp)
 8217c40:	00c01bc4 	movi	r3,111
 8217c44:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
 8217c48:	0005883a 	mov	r2,zero
 8217c4c:	00000706 	br	8217c6c <OSFlagPend+0x5a4>
 8217c50:	e0bfe517 	ldw	r2,-108(fp)
 8217c54:	e0bff515 	stw	r2,-44(fp)
 8217c58:	e0bff517 	ldw	r2,-44(fp)
 8217c5c:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
 8217c60:	e0800217 	ldw	r2,8(fp)
 8217c64:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
 8217c68:	e0bfe80b 	ldhu	r2,-96(fp)
}
 8217c6c:	e037883a 	mov	sp,fp
 8217c70:	dfc00117 	ldw	ra,4(sp)
 8217c74:	df000017 	ldw	fp,0(sp)
 8217c78:	dec00204 	addi	sp,sp,8
 8217c7c:	f800283a 	ret

08217c80 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
 8217c80:	defffb04 	addi	sp,sp,-20
 8217c84:	df000415 	stw	fp,16(sp)
 8217c88:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 8217c8c:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217c90:	0005303a 	rdctl	r2,status
 8217c94:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217c98:	e0fffe17 	ldw	r3,-8(fp)
 8217c9c:	00bfff84 	movi	r2,-2
 8217ca0:	1884703a 	and	r2,r3,r2
 8217ca4:	1001703a 	wrctl	status,r2
  
  return context;
 8217ca8:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
 8217cac:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
 8217cb0:	d0a07a17 	ldw	r2,-32280(gp)
 8217cb4:	10800b0b 	ldhu	r2,44(r2)
 8217cb8:	e0bffd0d 	sth	r2,-12(fp)
 8217cbc:	e0bffc17 	ldw	r2,-16(fp)
 8217cc0:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217cc4:	e0bfff17 	ldw	r2,-4(fp)
 8217cc8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
 8217ccc:	e0bffd0b 	ldhu	r2,-12(fp)
}
 8217cd0:	e037883a 	mov	sp,fp
 8217cd4:	df000017 	ldw	fp,0(sp)
 8217cd8:	dec00104 	addi	sp,sp,4
 8217cdc:	f800283a 	ret

08217ce0 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
 8217ce0:	deffef04 	addi	sp,sp,-68
 8217ce4:	dfc01015 	stw	ra,64(sp)
 8217ce8:	df000f15 	stw	fp,60(sp)
 8217cec:	df000f04 	addi	fp,sp,60
 8217cf0:	e13ffc15 	stw	r4,-16(fp)
 8217cf4:	2807883a 	mov	r3,r5
 8217cf8:	3005883a 	mov	r2,r6
 8217cfc:	e1ffff15 	stw	r7,-4(fp)
 8217d00:	e0fffd0d 	sth	r3,-12(fp)
 8217d04:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
 8217d08:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 8217d0c:	e0bfff17 	ldw	r2,-4(fp)
 8217d10:	1000021e 	bne	r2,zero,8217d1c <OSFlagPost+0x3c>
        return ((OS_FLAGS)0);
 8217d14:	0005883a 	mov	r2,zero
 8217d18:	0000d106 	br	8218060 <OSFlagPost+0x380>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
 8217d1c:	e0bffc17 	ldw	r2,-16(fp)
 8217d20:	1000051e 	bne	r2,zero,8217d38 <OSFlagPost+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8217d24:	e0bfff17 	ldw	r2,-4(fp)
 8217d28:	00c01b84 	movi	r3,110
 8217d2c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217d30:	0005883a 	mov	r2,zero
 8217d34:	0000ca06 	br	8218060 <OSFlagPost+0x380>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
 8217d38:	e0bffc17 	ldw	r2,-16(fp)
 8217d3c:	10800003 	ldbu	r2,0(r2)
 8217d40:	10803fcc 	andi	r2,r2,255
 8217d44:	10800160 	cmpeqi	r2,r2,5
 8217d48:	1000051e 	bne	r2,zero,8217d60 <OSFlagPost+0x80>
        *perr = OS_ERR_EVENT_TYPE;
 8217d4c:	e0bfff17 	ldw	r2,-4(fp)
 8217d50:	00c00044 	movi	r3,1
 8217d54:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217d58:	0005883a 	mov	r2,zero
 8217d5c:	0000c006 	br	8218060 <OSFlagPost+0x380>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217d60:	0005303a 	rdctl	r2,status
 8217d64:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217d68:	e0fffb17 	ldw	r3,-20(fp)
 8217d6c:	00bfff84 	movi	r2,-2
 8217d70:	1884703a 	and	r2,r3,r2
 8217d74:	1001703a 	wrctl	status,r2
  
  return context;
 8217d78:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 8217d7c:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
 8217d80:	e0bffe03 	ldbu	r2,-8(fp)
 8217d84:	10000326 	beq	r2,zero,8217d94 <OSFlagPost+0xb4>
 8217d88:	10800060 	cmpeqi	r2,r2,1
 8217d8c:	10000b1e 	bne	r2,zero,8217dbc <OSFlagPost+0xdc>
 8217d90:	00001206 	br	8217ddc <OSFlagPost+0xfc>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
 8217d94:	e0bffc17 	ldw	r2,-16(fp)
 8217d98:	1080020b 	ldhu	r2,8(r2)
 8217d9c:	1007883a 	mov	r3,r2
 8217da0:	e0bffd0b 	ldhu	r2,-12(fp)
 8217da4:	0084303a 	nor	r2,zero,r2
 8217da8:	1884703a 	and	r2,r3,r2
 8217dac:	1007883a 	mov	r3,r2
 8217db0:	e0bffc17 	ldw	r2,-16(fp)
 8217db4:	10c0020d 	sth	r3,8(r2)
             break;
 8217db8:	00001106 	br	8217e00 <OSFlagPost+0x120>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
 8217dbc:	e0bffc17 	ldw	r2,-16(fp)
 8217dc0:	10c0020b 	ldhu	r3,8(r2)
 8217dc4:	e0bffd0b 	ldhu	r2,-12(fp)
 8217dc8:	1884b03a 	or	r2,r3,r2
 8217dcc:	1007883a 	mov	r3,r2
 8217dd0:	e0bffc17 	ldw	r2,-16(fp)
 8217dd4:	10c0020d 	sth	r3,8(r2)
             break;
 8217dd8:	00000906 	br	8217e00 <OSFlagPost+0x120>
 8217ddc:	e0bff317 	ldw	r2,-52(fp)
 8217de0:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217de4:	e0bff417 	ldw	r2,-48(fp)
 8217de8:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
 8217dec:	e0bfff17 	ldw	r2,-4(fp)
 8217df0:	00c01c44 	movi	r3,113
 8217df4:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
 8217df8:	0005883a 	mov	r2,zero
 8217dfc:	00009806 	br	8218060 <OSFlagPost+0x380>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
 8217e00:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 8217e04:	e0bffc17 	ldw	r2,-16(fp)
 8217e08:	10800117 	ldw	r2,4(r2)
 8217e0c:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 8217e10:	00007706 	br	8217ff0 <OSFlagPost+0x310>
        switch (pnode->OSFlagNodeWaitType) {
 8217e14:	e0bff117 	ldw	r2,-60(fp)
 8217e18:	10800483 	ldbu	r2,18(r2)
 8217e1c:	10803fcc 	andi	r2,r2,255
 8217e20:	10c00060 	cmpeqi	r3,r2,1
 8217e24:	18004a1e 	bne	r3,zero,8217f50 <OSFlagPost+0x270>
 8217e28:	10c00088 	cmpgei	r3,r2,2
 8217e2c:	1800021e 	bne	r3,zero,8217e38 <OSFlagPost+0x158>
 8217e30:	10002f26 	beq	r2,zero,8217ef0 <OSFlagPost+0x210>
 8217e34:	00005b06 	br	8217fa4 <OSFlagPost+0x2c4>
 8217e38:	10c000a0 	cmpeqi	r3,r2,2
 8217e3c:	1800031e 	bne	r3,zero,8217e4c <OSFlagPost+0x16c>
 8217e40:	108000e0 	cmpeqi	r2,r2,3
 8217e44:	1000171e 	bne	r2,zero,8217ea4 <OSFlagPost+0x1c4>
 8217e48:	00005606 	br	8217fa4 <OSFlagPost+0x2c4>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 8217e4c:	e0bffc17 	ldw	r2,-16(fp)
 8217e50:	10c0020b 	ldhu	r3,8(r2)
 8217e54:	e0bff117 	ldw	r2,-60(fp)
 8217e58:	1080040b 	ldhu	r2,16(r2)
 8217e5c:	1884703a 	and	r2,r3,r2
 8217e60:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 8217e64:	e0bff117 	ldw	r2,-60(fp)
 8217e68:	1080040b 	ldhu	r2,16(r2)
 8217e6c:	10ffffcc 	andi	r3,r2,65535
 8217e70:	e0bff60b 	ldhu	r2,-40(fp)
 8217e74:	1880541e 	bne	r3,r2,8217fc8 <OSFlagPost+0x2e8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 8217e78:	e0bff60b 	ldhu	r2,-40(fp)
 8217e7c:	100b883a 	mov	r5,r2
 8217e80:	e13ff117 	ldw	r4,-60(fp)
 8217e84:	82183780 	call	8218378 <OS_FlagTaskRdy>
 8217e88:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 8217e8c:	e0bff683 	ldbu	r2,-38(fp)
 8217e90:	10800058 	cmpnei	r2,r2,1
 8217e94:	10004c1e 	bne	r2,zero,8217fc8 <OSFlagPost+0x2e8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 8217e98:	00800044 	movi	r2,1
 8217e9c:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 8217ea0:	00004906 	br	8217fc8 <OSFlagPost+0x2e8>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 8217ea4:	e0bffc17 	ldw	r2,-16(fp)
 8217ea8:	10c0020b 	ldhu	r3,8(r2)
 8217eac:	e0bff117 	ldw	r2,-60(fp)
 8217eb0:	1080040b 	ldhu	r2,16(r2)
 8217eb4:	1884703a 	and	r2,r3,r2
 8217eb8:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 8217ebc:	e0bff60b 	ldhu	r2,-40(fp)
 8217ec0:	10004326 	beq	r2,zero,8217fd0 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 8217ec4:	e0bff60b 	ldhu	r2,-40(fp)
 8217ec8:	100b883a 	mov	r5,r2
 8217ecc:	e13ff117 	ldw	r4,-60(fp)
 8217ed0:	82183780 	call	8218378 <OS_FlagTaskRdy>
 8217ed4:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 8217ed8:	e0bff683 	ldbu	r2,-38(fp)
 8217edc:	10800058 	cmpnei	r2,r2,1
 8217ee0:	10003b1e 	bne	r2,zero,8217fd0 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 8217ee4:	00800044 	movi	r2,1
 8217ee8:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 8217eec:	00003806 	br	8217fd0 <OSFlagPost+0x2f0>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 8217ef0:	e0bffc17 	ldw	r2,-16(fp)
 8217ef4:	1080020b 	ldhu	r2,8(r2)
 8217ef8:	0084303a 	nor	r2,zero,r2
 8217efc:	1007883a 	mov	r3,r2
 8217f00:	e0bff117 	ldw	r2,-60(fp)
 8217f04:	1080040b 	ldhu	r2,16(r2)
 8217f08:	1884703a 	and	r2,r3,r2
 8217f0c:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 8217f10:	e0bff117 	ldw	r2,-60(fp)
 8217f14:	1080040b 	ldhu	r2,16(r2)
 8217f18:	10ffffcc 	andi	r3,r2,65535
 8217f1c:	e0bff60b 	ldhu	r2,-40(fp)
 8217f20:	18802d1e 	bne	r3,r2,8217fd8 <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 8217f24:	e0bff60b 	ldhu	r2,-40(fp)
 8217f28:	100b883a 	mov	r5,r2
 8217f2c:	e13ff117 	ldw	r4,-60(fp)
 8217f30:	82183780 	call	8218378 <OS_FlagTaskRdy>
 8217f34:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 8217f38:	e0bff683 	ldbu	r2,-38(fp)
 8217f3c:	10800058 	cmpnei	r2,r2,1
 8217f40:	1000251e 	bne	r2,zero,8217fd8 <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 8217f44:	00800044 	movi	r2,1
 8217f48:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 8217f4c:	00002206 	br	8217fd8 <OSFlagPost+0x2f8>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 8217f50:	e0bffc17 	ldw	r2,-16(fp)
 8217f54:	1080020b 	ldhu	r2,8(r2)
 8217f58:	0084303a 	nor	r2,zero,r2
 8217f5c:	1007883a 	mov	r3,r2
 8217f60:	e0bff117 	ldw	r2,-60(fp)
 8217f64:	1080040b 	ldhu	r2,16(r2)
 8217f68:	1884703a 	and	r2,r3,r2
 8217f6c:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 8217f70:	e0bff60b 	ldhu	r2,-40(fp)
 8217f74:	10001a26 	beq	r2,zero,8217fe0 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 8217f78:	e0bff60b 	ldhu	r2,-40(fp)
 8217f7c:	100b883a 	mov	r5,r2
 8217f80:	e13ff117 	ldw	r4,-60(fp)
 8217f84:	82183780 	call	8218378 <OS_FlagTaskRdy>
 8217f88:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 8217f8c:	e0bff683 	ldbu	r2,-38(fp)
 8217f90:	10800058 	cmpnei	r2,r2,1
 8217f94:	1000121e 	bne	r2,zero,8217fe0 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 8217f98:	00800044 	movi	r2,1
 8217f9c:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 8217fa0:	00000f06 	br	8217fe0 <OSFlagPost+0x300>
 8217fa4:	e0bff317 	ldw	r2,-52(fp)
 8217fa8:	e0bff515 	stw	r2,-44(fp)
 8217fac:	e0bff517 	ldw	r2,-44(fp)
 8217fb0:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 8217fb4:	e0bfff17 	ldw	r2,-4(fp)
 8217fb8:	00c01bc4 	movi	r3,111
 8217fbc:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
 8217fc0:	0005883a 	mov	r2,zero
 8217fc4:	00002606 	br	8218060 <OSFlagPost+0x380>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 8217fc8:	0001883a 	nop
 8217fcc:	00000506 	br	8217fe4 <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 8217fd0:	0001883a 	nop
 8217fd4:	00000306 	br	8217fe4 <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 8217fd8:	0001883a 	nop
 8217fdc:	00000106 	br	8217fe4 <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 8217fe0:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
 8217fe4:	e0bff117 	ldw	r2,-60(fp)
 8217fe8:	10800017 	ldw	r2,0(r2)
 8217fec:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 8217ff0:	e0bff117 	ldw	r2,-60(fp)
 8217ff4:	103f871e 	bne	r2,zero,8217e14 <OSFlagPost+0x134>
 8217ff8:	e0bff317 	ldw	r2,-52(fp)
 8217ffc:	e0bff715 	stw	r2,-36(fp)
 8218000:	e0bff717 	ldw	r2,-36(fp)
 8218004:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
 8218008:	e0bff203 	ldbu	r2,-56(fp)
 821800c:	10800058 	cmpnei	r2,r2,1
 8218010:	1000011e 	bne	r2,zero,8218018 <OSFlagPost+0x338>
        OS_Sched();
 8218014:	82165800 	call	8216580 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218018:	0005303a 	rdctl	r2,status
 821801c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218020:	e0fffa17 	ldw	r3,-24(fp)
 8218024:	00bfff84 	movi	r2,-2
 8218028:	1884703a 	and	r2,r3,r2
 821802c:	1001703a 	wrctl	status,r2
  
  return context;
 8218030:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 8218034:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
 8218038:	e0bffc17 	ldw	r2,-16(fp)
 821803c:	1080020b 	ldhu	r2,8(r2)
 8218040:	e0bff90d 	sth	r2,-28(fp)
 8218044:	e0bff317 	ldw	r2,-52(fp)
 8218048:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821804c:	e0bff817 	ldw	r2,-32(fp)
 8218050:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
 8218054:	e0bfff17 	ldw	r2,-4(fp)
 8218058:	10000005 	stb	zero,0(r2)
    return (flags_cur);
 821805c:	e0bff90b 	ldhu	r2,-28(fp)
}
 8218060:	e037883a 	mov	sp,fp
 8218064:	dfc00117 	ldw	ra,4(sp)
 8218068:	df000017 	ldw	fp,0(sp)
 821806c:	dec00204 	addi	sp,sp,8
 8218070:	f800283a 	ret

08218074 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
 8218074:	defff904 	addi	sp,sp,-28
 8218078:	df000615 	stw	fp,24(sp)
 821807c:	df000604 	addi	fp,sp,24
 8218080:	e13ffe15 	stw	r4,-8(fp)
 8218084:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
 8218088:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
 821808c:	e0bfff17 	ldw	r2,-4(fp)
 8218090:	1000021e 	bne	r2,zero,821809c <OSFlagQuery+0x28>
        return ((OS_FLAGS)0);
 8218094:	0005883a 	mov	r2,zero
 8218098:	00002306 	br	8218128 <OSFlagQuery+0xb4>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
 821809c:	e0bffe17 	ldw	r2,-8(fp)
 82180a0:	1000051e 	bne	r2,zero,82180b8 <OSFlagQuery+0x44>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 82180a4:	e0bfff17 	ldw	r2,-4(fp)
 82180a8:	00c01b84 	movi	r3,110
 82180ac:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 82180b0:	0005883a 	mov	r2,zero
 82180b4:	00001c06 	br	8218128 <OSFlagQuery+0xb4>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
 82180b8:	e0bffe17 	ldw	r2,-8(fp)
 82180bc:	10800003 	ldbu	r2,0(r2)
 82180c0:	10803fcc 	andi	r2,r2,255
 82180c4:	10800160 	cmpeqi	r2,r2,5
 82180c8:	1000051e 	bne	r2,zero,82180e0 <OSFlagQuery+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
 82180cc:	e0bfff17 	ldw	r2,-4(fp)
 82180d0:	00c00044 	movi	r3,1
 82180d4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 82180d8:	0005883a 	mov	r2,zero
 82180dc:	00001206 	br	8218128 <OSFlagQuery+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82180e0:	0005303a 	rdctl	r2,status
 82180e4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82180e8:	e0fffc17 	ldw	r3,-16(fp)
 82180ec:	00bfff84 	movi	r2,-2
 82180f0:	1884703a 	and	r2,r3,r2
 82180f4:	1001703a 	wrctl	status,r2
  
  return context;
 82180f8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 82180fc:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
 8218100:	e0bffe17 	ldw	r2,-8(fp)
 8218104:	1080020b 	ldhu	r2,8(r2)
 8218108:	e0bffb0d 	sth	r2,-20(fp)
 821810c:	e0bffa17 	ldw	r2,-24(fp)
 8218110:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218114:	e0bffd17 	ldw	r2,-12(fp)
 8218118:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 821811c:	e0bfff17 	ldw	r2,-4(fp)
 8218120:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
 8218124:	e0bffb0b 	ldhu	r2,-20(fp)
}
 8218128:	e037883a 	mov	sp,fp
 821812c:	df000017 	ldw	fp,0(sp)
 8218130:	dec00104 	addi	sp,sp,4
 8218134:	f800283a 	ret

08218138 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
 8218138:	defff804 	addi	sp,sp,-32
 821813c:	df000715 	stw	fp,28(sp)
 8218140:	df000704 	addi	fp,sp,28
 8218144:	e13ffb15 	stw	r4,-20(fp)
 8218148:	e17ffc15 	stw	r5,-16(fp)
 821814c:	3009883a 	mov	r4,r6
 8218150:	3807883a 	mov	r3,r7
 8218154:	e0800117 	ldw	r2,4(fp)
 8218158:	e13ffd0d 	sth	r4,-12(fp)
 821815c:	e0fffe05 	stb	r3,-8(fp)
 8218160:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
 8218164:	d0a07a17 	ldw	r2,-32280(gp)
 8218168:	d0e07a17 	ldw	r3,-32280(gp)
 821816c:	18c00c03 	ldbu	r3,48(r3)
 8218170:	18c00814 	ori	r3,r3,32
 8218174:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
 8218178:	d0a07a17 	ldw	r2,-32280(gp)
 821817c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
 8218180:	d0a07a17 	ldw	r2,-32280(gp)
 8218184:	e0ffff0b 	ldhu	r3,-4(fp)
 8218188:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
 821818c:	d0a07a17 	ldw	r2,-32280(gp)
 8218190:	e0fffc17 	ldw	r3,-16(fp)
 8218194:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
 8218198:	e0bffc17 	ldw	r2,-16(fp)
 821819c:	e0fffd0b 	ldhu	r3,-12(fp)
 82181a0:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
 82181a4:	e0bffc17 	ldw	r2,-16(fp)
 82181a8:	e0fffe03 	ldbu	r3,-8(fp)
 82181ac:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
 82181b0:	d0e07a17 	ldw	r3,-32280(gp)
 82181b4:	e0bffc17 	ldw	r2,-16(fp)
 82181b8:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
 82181bc:	e0bffb17 	ldw	r2,-20(fp)
 82181c0:	10c00117 	ldw	r3,4(r2)
 82181c4:	e0bffc17 	ldw	r2,-16(fp)
 82181c8:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
 82181cc:	e0bffc17 	ldw	r2,-16(fp)
 82181d0:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
 82181d4:	e0bffc17 	ldw	r2,-16(fp)
 82181d8:	e0fffb17 	ldw	r3,-20(fp)
 82181dc:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 82181e0:	e0bffb17 	ldw	r2,-20(fp)
 82181e4:	10800117 	ldw	r2,4(r2)
 82181e8:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
 82181ec:	e0bff917 	ldw	r2,-28(fp)
 82181f0:	10000326 	beq	r2,zero,8218200 <OS_FlagBlock+0xc8>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
 82181f4:	e0bff917 	ldw	r2,-28(fp)
 82181f8:	e0fffc17 	ldw	r3,-16(fp)
 82181fc:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
 8218200:	e0bffb17 	ldw	r2,-20(fp)
 8218204:	e0fffc17 	ldw	r3,-16(fp)
 8218208:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
 821820c:	d0a07a17 	ldw	r2,-32280(gp)
 8218210:	10800d03 	ldbu	r2,52(r2)
 8218214:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 8218218:	e0fffa03 	ldbu	r3,-24(fp)
 821821c:	e13ffa03 	ldbu	r4,-24(fp)
 8218220:	d0a07744 	addi	r2,gp,-32291
 8218224:	2085883a 	add	r2,r4,r2
 8218228:	10800003 	ldbu	r2,0(r2)
 821822c:	1009883a 	mov	r4,r2
 8218230:	d0a07a17 	ldw	r2,-32280(gp)
 8218234:	10800d43 	ldbu	r2,53(r2)
 8218238:	0084303a 	nor	r2,zero,r2
 821823c:	2084703a 	and	r2,r4,r2
 8218240:	1009883a 	mov	r4,r2
 8218244:	d0a07744 	addi	r2,gp,-32291
 8218248:	1885883a 	add	r2,r3,r2
 821824c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
 8218250:	e0fffa03 	ldbu	r3,-24(fp)
 8218254:	d0a07744 	addi	r2,gp,-32291
 8218258:	1885883a 	add	r2,r3,r2
 821825c:	10800003 	ldbu	r2,0(r2)
 8218260:	10803fcc 	andi	r2,r2,255
 8218264:	1000071e 	bne	r2,zero,8218284 <OS_FlagBlock+0x14c>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 8218268:	d0a07a17 	ldw	r2,-32280(gp)
 821826c:	10800d83 	ldbu	r2,54(r2)
 8218270:	0084303a 	nor	r2,zero,r2
 8218274:	1007883a 	mov	r3,r2
 8218278:	d0a07703 	ldbu	r2,-32292(gp)
 821827c:	1884703a 	and	r2,r3,r2
 8218280:	d0a07705 	stb	r2,-32292(gp)
    }
}
 8218284:	0001883a 	nop
 8218288:	e037883a 	mov	sp,fp
 821828c:	df000017 	ldw	fp,0(sp)
 8218290:	dec00104 	addi	sp,sp,4
 8218294:	f800283a 	ret

08218298 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
 8218298:	defffb04 	addi	sp,sp,-20
 821829c:	dfc00415 	stw	ra,16(sp)
 82182a0:	df000315 	stw	fp,12(sp)
 82182a4:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
 82182a8:	0140dc04 	movi	r5,880
 82182ac:	010209b4 	movhi	r4,2086
 82182b0:	212a5704 	addi	r4,r4,-22180
 82182b4:	82164c40 	call	82164c4 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
 82182b8:	008209b4 	movhi	r2,2086
 82182bc:	10aa5704 	addi	r2,r2,-22180
 82182c0:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
 82182c4:	008209b4 	movhi	r2,2086
 82182c8:	10aa6204 	addi	r2,r2,-22136
 82182cc:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 82182d0:	e03ffd0d 	sth	zero,-12(fp)
 82182d4:	00001306 	br	8218324 <OS_FlagInit+0x8c>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 82182d8:	e0bffe17 	ldw	r2,-8(fp)
 82182dc:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
 82182e0:	e0bffe17 	ldw	r2,-8(fp)
 82182e4:	e0ffff17 	ldw	r3,-4(fp)
 82182e8:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
 82182ec:	e0bffe17 	ldw	r2,-8(fp)
 82182f0:	00c00fc4 	movi	r3,63
 82182f4:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 82182f8:	e0bffe17 	ldw	r2,-8(fp)
 82182fc:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
 8218300:	e0bffe17 	ldw	r2,-8(fp)
 8218304:	10800b04 	addi	r2,r2,44
 8218308:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
 821830c:	e0bfff17 	ldw	r2,-4(fp)
 8218310:	10800b04 	addi	r2,r2,44
 8218314:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 8218318:	e0bffd0b 	ldhu	r2,-12(fp)
 821831c:	10800044 	addi	r2,r2,1
 8218320:	e0bffd0d 	sth	r2,-12(fp)
 8218324:	e0bffd0b 	ldhu	r2,-12(fp)
 8218328:	108004f0 	cmpltui	r2,r2,19
 821832c:	103fea1e 	bne	r2,zero,82182d8 <OS_FlagInit+0x40>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 8218330:	e0bffe17 	ldw	r2,-8(fp)
 8218334:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
 8218338:	e0bffe17 	ldw	r2,-8(fp)
 821833c:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
 8218340:	e0bffe17 	ldw	r2,-8(fp)
 8218344:	00c00fc4 	movi	r3,63
 8218348:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 821834c:	e0bffe17 	ldw	r2,-8(fp)
 8218350:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
 8218354:	008209b4 	movhi	r2,2086
 8218358:	10aa5704 	addi	r2,r2,-22180
 821835c:	d0a07c15 	stw	r2,-32272(gp)
#endif
}
 8218360:	0001883a 	nop
 8218364:	e037883a 	mov	sp,fp
 8218368:	dfc00117 	ldw	ra,4(sp)
 821836c:	df000017 	ldw	fp,0(sp)
 8218370:	dec00204 	addi	sp,sp,8
 8218374:	f800283a 	ret

08218378 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
 8218378:	defffa04 	addi	sp,sp,-24
 821837c:	dfc00515 	stw	ra,20(sp)
 8218380:	df000415 	stw	fp,16(sp)
 8218384:	df000404 	addi	fp,sp,16
 8218388:	e13ffe15 	stw	r4,-8(fp)
 821838c:	2805883a 	mov	r2,r5
 8218390:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
 8218394:	e0bffe17 	ldw	r2,-8(fp)
 8218398:	10800217 	ldw	r2,8(r2)
 821839c:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
 82183a0:	e0bffd17 	ldw	r2,-12(fp)
 82183a4:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
 82183a8:	e0bffd17 	ldw	r2,-12(fp)
 82183ac:	e0ffff0b 	ldhu	r3,-4(fp)
 82183b0:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
 82183b4:	e0bffd17 	ldw	r2,-12(fp)
 82183b8:	10c00c03 	ldbu	r3,48(r2)
 82183bc:	00bff7c4 	movi	r2,-33
 82183c0:	1884703a 	and	r2,r3,r2
 82183c4:	1007883a 	mov	r3,r2
 82183c8:	e0bffd17 	ldw	r2,-12(fp)
 82183cc:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
 82183d0:	e0bffd17 	ldw	r2,-12(fp)
 82183d4:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
 82183d8:	e0bffd17 	ldw	r2,-12(fp)
 82183dc:	10800c03 	ldbu	r2,48(r2)
 82183e0:	10803fcc 	andi	r2,r2,255
 82183e4:	1000181e 	bne	r2,zero,8218448 <OS_FlagTaskRdy+0xd0>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
 82183e8:	e0bffd17 	ldw	r2,-12(fp)
 82183ec:	10c00d83 	ldbu	r3,54(r2)
 82183f0:	d0a07703 	ldbu	r2,-32292(gp)
 82183f4:	1884b03a 	or	r2,r3,r2
 82183f8:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 82183fc:	e0bffd17 	ldw	r2,-12(fp)
 8218400:	10800d03 	ldbu	r2,52(r2)
 8218404:	10c03fcc 	andi	r3,r2,255
 8218408:	e0bffd17 	ldw	r2,-12(fp)
 821840c:	10800d03 	ldbu	r2,52(r2)
 8218410:	11003fcc 	andi	r4,r2,255
 8218414:	d0a07744 	addi	r2,gp,-32291
 8218418:	2085883a 	add	r2,r4,r2
 821841c:	11000003 	ldbu	r4,0(r2)
 8218420:	e0bffd17 	ldw	r2,-12(fp)
 8218424:	10800d43 	ldbu	r2,53(r2)
 8218428:	2084b03a 	or	r2,r4,r2
 821842c:	1009883a 	mov	r4,r2
 8218430:	d0a07744 	addi	r2,gp,-32291
 8218434:	1885883a 	add	r2,r3,r2
 8218438:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
 821843c:	00800044 	movi	r2,1
 8218440:	e0bffc05 	stb	r2,-16(fp)
 8218444:	00000106 	br	821844c <OS_FlagTaskRdy+0xd4>
    } else {
        sched                   = OS_FALSE;
 8218448:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
 821844c:	e13ffe17 	ldw	r4,-8(fp)
 8218450:	821846c0 	call	821846c <OS_FlagUnlink>
    return (sched);
 8218454:	e0bffc03 	ldbu	r2,-16(fp)
}
 8218458:	e037883a 	mov	sp,fp
 821845c:	dfc00117 	ldw	ra,4(sp)
 8218460:	df000017 	ldw	fp,0(sp)
 8218464:	dec00204 	addi	sp,sp,8
 8218468:	f800283a 	ret

0821846c <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
 821846c:	defffa04 	addi	sp,sp,-24
 8218470:	df000515 	stw	fp,20(sp)
 8218474:	df000504 	addi	fp,sp,20
 8218478:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
 821847c:	e0bfff17 	ldw	r2,-4(fp)
 8218480:	10800117 	ldw	r2,4(r2)
 8218484:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 8218488:	e0bfff17 	ldw	r2,-4(fp)
 821848c:	10800017 	ldw	r2,0(r2)
 8218490:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
 8218494:	e0bffb17 	ldw	r2,-20(fp)
 8218498:	10000b1e 	bne	r2,zero,82184c8 <OS_FlagUnlink+0x5c>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
 821849c:	e0bfff17 	ldw	r2,-4(fp)
 82184a0:	10800317 	ldw	r2,12(r2)
 82184a4:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
 82184a8:	e0bffd17 	ldw	r2,-12(fp)
 82184ac:	e0fffc17 	ldw	r3,-16(fp)
 82184b0:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
 82184b4:	e0bffc17 	ldw	r2,-16(fp)
 82184b8:	10000b26 	beq	r2,zero,82184e8 <OS_FlagUnlink+0x7c>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
 82184bc:	e0bffc17 	ldw	r2,-16(fp)
 82184c0:	10000115 	stw	zero,4(r2)
 82184c4:	00000806 	br	82184e8 <OS_FlagUnlink+0x7c>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
 82184c8:	e0bffb17 	ldw	r2,-20(fp)
 82184cc:	e0fffc17 	ldw	r3,-16(fp)
 82184d0:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
 82184d4:	e0bffc17 	ldw	r2,-16(fp)
 82184d8:	10000326 	beq	r2,zero,82184e8 <OS_FlagUnlink+0x7c>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
 82184dc:	e0bffc17 	ldw	r2,-16(fp)
 82184e0:	e0fffb17 	ldw	r3,-20(fp)
 82184e4:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
 82184e8:	e0bfff17 	ldw	r2,-4(fp)
 82184ec:	10800217 	ldw	r2,8(r2)
 82184f0:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
 82184f4:	e0bffe17 	ldw	r2,-8(fp)
 82184f8:	10000a15 	stw	zero,40(r2)
#endif
}
 82184fc:	0001883a 	nop
 8218500:	e037883a 	mov	sp,fp
 8218504:	df000017 	ldw	fp,0(sp)
 8218508:	dec00104 	addi	sp,sp,4
 821850c:	f800283a 	ret

08218510 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
 8218510:	defff404 	addi	sp,sp,-48
 8218514:	df000b15 	stw	fp,44(sp)
 8218518:	df000b04 	addi	fp,sp,44
 821851c:	e13ffc15 	stw	r4,-16(fp)
 8218520:	e17ffd15 	stw	r5,-12(fp)
 8218524:	e1bffe15 	stw	r6,-8(fp)
 8218528:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821852c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 8218530:	e0bfff17 	ldw	r2,-4(fp)
 8218534:	1000021e 	bne	r2,zero,8218540 <OSMemCreate+0x30>
        return ((OS_MEM *)0);
 8218538:	0005883a 	mov	r2,zero
 821853c:	00006506 	br	82186d4 <OSMemCreate+0x1c4>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
 8218540:	e0bffc17 	ldw	r2,-16(fp)
 8218544:	1000051e 	bne	r2,zero,821855c <OSMemCreate+0x4c>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 8218548:	e0bfff17 	ldw	r2,-4(fp)
 821854c:	00c01884 	movi	r3,98
 8218550:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 8218554:	0005883a 	mov	r2,zero
 8218558:	00005e06 	br	82186d4 <OSMemCreate+0x1c4>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
 821855c:	e0bffc17 	ldw	r2,-16(fp)
 8218560:	108000cc 	andi	r2,r2,3
 8218564:	10000526 	beq	r2,zero,821857c <OSMemCreate+0x6c>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 8218568:	e0bfff17 	ldw	r2,-4(fp)
 821856c:	00c01884 	movi	r3,98
 8218570:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 8218574:	0005883a 	mov	r2,zero
 8218578:	00005606 	br	82186d4 <OSMemCreate+0x1c4>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
 821857c:	e0bffd17 	ldw	r2,-12(fp)
 8218580:	108000a8 	cmpgeui	r2,r2,2
 8218584:	1000051e 	bne	r2,zero,821859c <OSMemCreate+0x8c>
        *perr = OS_ERR_MEM_INVALID_BLKS;
 8218588:	e0bfff17 	ldw	r2,-4(fp)
 821858c:	00c016c4 	movi	r3,91
 8218590:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 8218594:	0005883a 	mov	r2,zero
 8218598:	00004e06 	br	82186d4 <OSMemCreate+0x1c4>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
 821859c:	e0bffe17 	ldw	r2,-8(fp)
 82185a0:	10800128 	cmpgeui	r2,r2,4
 82185a4:	1000051e 	bne	r2,zero,82185bc <OSMemCreate+0xac>
        *perr = OS_ERR_MEM_INVALID_SIZE;
 82185a8:	e0bfff17 	ldw	r2,-4(fp)
 82185ac:	00c01704 	movi	r3,92
 82185b0:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 82185b4:	0005883a 	mov	r2,zero
 82185b8:	00004606 	br	82186d4 <OSMemCreate+0x1c4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82185bc:	0005303a 	rdctl	r2,status
 82185c0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82185c4:	e0fffb17 	ldw	r3,-20(fp)
 82185c8:	00bfff84 	movi	r2,-2
 82185cc:	1884703a 	and	r2,r3,r2
 82185d0:	1001703a 	wrctl	status,r2
  
  return context;
 82185d4:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 82185d8:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
 82185dc:	d0a07417 	ldw	r2,-32304(gp)
 82185e0:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
 82185e4:	d0a07417 	ldw	r2,-32304(gp)
 82185e8:	10000326 	beq	r2,zero,82185f8 <OSMemCreate+0xe8>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
 82185ec:	d0a07417 	ldw	r2,-32304(gp)
 82185f0:	10800117 	ldw	r2,4(r2)
 82185f4:	d0a07415 	stw	r2,-32304(gp)
 82185f8:	e0bff817 	ldw	r2,-32(fp)
 82185fc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218600:	e0bff917 	ldw	r2,-28(fp)
 8218604:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
 8218608:	e0bffa17 	ldw	r2,-24(fp)
 821860c:	1000051e 	bne	r2,zero,8218624 <OSMemCreate+0x114>
        *perr = OS_ERR_MEM_INVALID_PART;
 8218610:	e0bfff17 	ldw	r2,-4(fp)
 8218614:	00c01684 	movi	r3,90
 8218618:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 821861c:	0005883a 	mov	r2,zero
 8218620:	00002c06 	br	82186d4 <OSMemCreate+0x1c4>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
 8218624:	e0bffc17 	ldw	r2,-16(fp)
 8218628:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
 821862c:	e0fffc17 	ldw	r3,-16(fp)
 8218630:	e0bffe17 	ldw	r2,-8(fp)
 8218634:	1885883a 	add	r2,r3,r2
 8218638:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
 821863c:	e03ff715 	stw	zero,-36(fp)
 8218640:	00000c06 	br	8218674 <OSMemCreate+0x164>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
 8218644:	e0bff617 	ldw	r2,-40(fp)
 8218648:	e0fff517 	ldw	r3,-44(fp)
 821864c:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
 8218650:	e0bff517 	ldw	r2,-44(fp)
 8218654:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
 8218658:	e0fff517 	ldw	r3,-44(fp)
 821865c:	e0bffe17 	ldw	r2,-8(fp)
 8218660:	1885883a 	add	r2,r3,r2
 8218664:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
 8218668:	e0bff717 	ldw	r2,-36(fp)
 821866c:	10800044 	addi	r2,r2,1
 8218670:	e0bff715 	stw	r2,-36(fp)
 8218674:	e0bffd17 	ldw	r2,-12(fp)
 8218678:	10bfffc4 	addi	r2,r2,-1
 821867c:	e0fff717 	ldw	r3,-36(fp)
 8218680:	18bff036 	bltu	r3,r2,8218644 <OSMemCreate+0x134>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
 8218684:	e0bff617 	ldw	r2,-40(fp)
 8218688:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
 821868c:	e0bffa17 	ldw	r2,-24(fp)
 8218690:	e0fffc17 	ldw	r3,-16(fp)
 8218694:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
 8218698:	e0bffa17 	ldw	r2,-24(fp)
 821869c:	e0fffc17 	ldw	r3,-16(fp)
 82186a0:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
 82186a4:	e0bffa17 	ldw	r2,-24(fp)
 82186a8:	e0fffd17 	ldw	r3,-12(fp)
 82186ac:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
 82186b0:	e0bffa17 	ldw	r2,-24(fp)
 82186b4:	e0fffd17 	ldw	r3,-12(fp)
 82186b8:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
 82186bc:	e0bffa17 	ldw	r2,-24(fp)
 82186c0:	e0fffe17 	ldw	r3,-8(fp)
 82186c4:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
 82186c8:	e0bfff17 	ldw	r2,-4(fp)
 82186cc:	10000005 	stb	zero,0(r2)
    return (pmem);
 82186d0:	e0bffa17 	ldw	r2,-24(fp)
}
 82186d4:	e037883a 	mov	sp,fp
 82186d8:	df000017 	ldw	fp,0(sp)
 82186dc:	dec00104 	addi	sp,sp,4
 82186e0:	f800283a 	ret

082186e4 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
 82186e4:	defff804 	addi	sp,sp,-32
 82186e8:	df000715 	stw	fp,28(sp)
 82186ec:	df000704 	addi	fp,sp,28
 82186f0:	e13ffe15 	stw	r4,-8(fp)
 82186f4:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 82186f8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 82186fc:	e0bfff17 	ldw	r2,-4(fp)
 8218700:	1000021e 	bne	r2,zero,821870c <OSMemGet+0x28>
        return ((void *)0);
 8218704:	0005883a 	mov	r2,zero
 8218708:	00002e06 	br	82187c4 <OSMemGet+0xe0>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
 821870c:	e0bffe17 	ldw	r2,-8(fp)
 8218710:	1000051e 	bne	r2,zero,8218728 <OSMemGet+0x44>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 8218714:	e0bfff17 	ldw	r2,-4(fp)
 8218718:	00c01804 	movi	r3,96
 821871c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8218720:	0005883a 	mov	r2,zero
 8218724:	00002706 	br	82187c4 <OSMemGet+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218728:	0005303a 	rdctl	r2,status
 821872c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218730:	e0fffd17 	ldw	r3,-12(fp)
 8218734:	00bfff84 	movi	r2,-2
 8218738:	1884703a 	and	r2,r3,r2
 821873c:	1001703a 	wrctl	status,r2
  
  return context;
 8218740:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 8218744:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
 8218748:	e0bffe17 	ldw	r2,-8(fp)
 821874c:	10800417 	ldw	r2,16(r2)
 8218750:	10001426 	beq	r2,zero,82187a4 <OSMemGet+0xc0>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
 8218754:	e0bffe17 	ldw	r2,-8(fp)
 8218758:	10800117 	ldw	r2,4(r2)
 821875c:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
 8218760:	e0bffb17 	ldw	r2,-20(fp)
 8218764:	10c00017 	ldw	r3,0(r2)
 8218768:	e0bffe17 	ldw	r2,-8(fp)
 821876c:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
 8218770:	e0bffe17 	ldw	r2,-8(fp)
 8218774:	10800417 	ldw	r2,16(r2)
 8218778:	10ffffc4 	addi	r3,r2,-1
 821877c:	e0bffe17 	ldw	r2,-8(fp)
 8218780:	10c00415 	stw	r3,16(r2)
 8218784:	e0bff917 	ldw	r2,-28(fp)
 8218788:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821878c:	e0bffa17 	ldw	r2,-24(fp)
 8218790:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
 8218794:	e0bfff17 	ldw	r2,-4(fp)
 8218798:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
 821879c:	e0bffb17 	ldw	r2,-20(fp)
 82187a0:	00000806 	br	82187c4 <OSMemGet+0xe0>
 82187a4:	e0bff917 	ldw	r2,-28(fp)
 82187a8:	e0bffc15 	stw	r2,-16(fp)
 82187ac:	e0bffc17 	ldw	r2,-16(fp)
 82187b0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
 82187b4:	e0bfff17 	ldw	r2,-4(fp)
 82187b8:	00c01744 	movi	r3,93
 82187bc:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
 82187c0:	0005883a 	mov	r2,zero
}
 82187c4:	e037883a 	mov	sp,fp
 82187c8:	df000017 	ldw	fp,0(sp)
 82187cc:	dec00104 	addi	sp,sp,4
 82187d0:	f800283a 	ret

082187d4 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 82187d4:	defff704 	addi	sp,sp,-36
 82187d8:	dfc00815 	stw	ra,32(sp)
 82187dc:	df000715 	stw	fp,28(sp)
 82187e0:	df000704 	addi	fp,sp,28
 82187e4:	e13ffd15 	stw	r4,-12(fp)
 82187e8:	e17ffe15 	stw	r5,-8(fp)
 82187ec:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82187f0:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 82187f4:	e0bfff17 	ldw	r2,-4(fp)
 82187f8:	1000021e 	bne	r2,zero,8218804 <OSMemNameGet+0x30>
        return (0);
 82187fc:	0005883a 	mov	r2,zero
 8218800:	00002b06 	br	82188b0 <OSMemNameGet+0xdc>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 8218804:	e0bffd17 	ldw	r2,-12(fp)
 8218808:	1000051e 	bne	r2,zero,8218820 <OSMemNameGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 821880c:	e0bfff17 	ldw	r2,-4(fp)
 8218810:	00c01804 	movi	r3,96
 8218814:	10c00005 	stb	r3,0(r2)
        return (0);
 8218818:	0005883a 	mov	r2,zero
 821881c:	00002406 	br	82188b0 <OSMemNameGet+0xdc>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 8218820:	e0bffe17 	ldw	r2,-8(fp)
 8218824:	1000051e 	bne	r2,zero,821883c <OSMemNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
 8218828:	e0bfff17 	ldw	r2,-4(fp)
 821882c:	00c00304 	movi	r3,12
 8218830:	10c00005 	stb	r3,0(r2)
        return (0);
 8218834:	0005883a 	mov	r2,zero
 8218838:	00001d06 	br	82188b0 <OSMemNameGet+0xdc>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 821883c:	d0a07903 	ldbu	r2,-32284(gp)
 8218840:	10803fcc 	andi	r2,r2,255
 8218844:	10000526 	beq	r2,zero,821885c <OSMemNameGet+0x88>
        *perr = OS_ERR_NAME_GET_ISR;
 8218848:	e0bfff17 	ldw	r2,-4(fp)
 821884c:	00c00444 	movi	r3,17
 8218850:	10c00005 	stb	r3,0(r2)
        return (0);
 8218854:	0005883a 	mov	r2,zero
 8218858:	00001506 	br	82188b0 <OSMemNameGet+0xdc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821885c:	0005303a 	rdctl	r2,status
 8218860:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218864:	e0fffb17 	ldw	r3,-20(fp)
 8218868:	00bfff84 	movi	r2,-2
 821886c:	1884703a 	and	r2,r3,r2
 8218870:	1001703a 	wrctl	status,r2
  
  return context;
 8218874:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 8218878:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
 821887c:	e0bffd17 	ldw	r2,-12(fp)
 8218880:	10800504 	addi	r2,r2,20
 8218884:	100b883a 	mov	r5,r2
 8218888:	e13ffe17 	ldw	r4,-8(fp)
 821888c:	82166c40 	call	82166c4 <OS_StrCopy>
 8218890:	e0bffa05 	stb	r2,-24(fp)
 8218894:	e0bff917 	ldw	r2,-28(fp)
 8218898:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821889c:	e0bffc17 	ldw	r2,-16(fp)
 82188a0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 82188a4:	e0bfff17 	ldw	r2,-4(fp)
 82188a8:	10000005 	stb	zero,0(r2)
    return (len);
 82188ac:	e0bffa03 	ldbu	r2,-24(fp)
}
 82188b0:	e037883a 	mov	sp,fp
 82188b4:	dfc00117 	ldw	ra,4(sp)
 82188b8:	df000017 	ldw	fp,0(sp)
 82188bc:	dec00204 	addi	sp,sp,8
 82188c0:	f800283a 	ret

082188c4 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 82188c4:	defff604 	addi	sp,sp,-40
 82188c8:	dfc00915 	stw	ra,36(sp)
 82188cc:	df000815 	stw	fp,32(sp)
 82188d0:	df000804 	addi	fp,sp,32
 82188d4:	e13ffd15 	stw	r4,-12(fp)
 82188d8:	e17ffe15 	stw	r5,-8(fp)
 82188dc:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82188e0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 82188e4:	e0bfff17 	ldw	r2,-4(fp)
 82188e8:	10003526 	beq	r2,zero,82189c0 <OSMemNameSet+0xfc>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 82188ec:	e0bffd17 	ldw	r2,-12(fp)
 82188f0:	1000041e 	bne	r2,zero,8218904 <OSMemNameSet+0x40>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 82188f4:	e0bfff17 	ldw	r2,-4(fp)
 82188f8:	00c01804 	movi	r3,96
 82188fc:	10c00005 	stb	r3,0(r2)
        return;
 8218900:	00003006 	br	82189c4 <OSMemNameSet+0x100>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 8218904:	e0bffe17 	ldw	r2,-8(fp)
 8218908:	1000041e 	bne	r2,zero,821891c <OSMemNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
 821890c:	e0bfff17 	ldw	r2,-4(fp)
 8218910:	00c00304 	movi	r3,12
 8218914:	10c00005 	stb	r3,0(r2)
        return;
 8218918:	00002a06 	br	82189c4 <OSMemNameSet+0x100>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 821891c:	d0a07903 	ldbu	r2,-32284(gp)
 8218920:	10803fcc 	andi	r2,r2,255
 8218924:	10000426 	beq	r2,zero,8218938 <OSMemNameSet+0x74>
        *perr = OS_ERR_NAME_SET_ISR;
 8218928:	e0bfff17 	ldw	r2,-4(fp)
 821892c:	00c00484 	movi	r3,18
 8218930:	10c00005 	stb	r3,0(r2)
        return;
 8218934:	00002306 	br	82189c4 <OSMemNameSet+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218938:	0005303a 	rdctl	r2,status
 821893c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218940:	e0fffc17 	ldw	r3,-16(fp)
 8218944:	00bfff84 	movi	r2,-2
 8218948:	1884703a 	and	r2,r3,r2
 821894c:	1001703a 	wrctl	status,r2
  
  return context;
 8218950:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8218954:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 8218958:	e13ffe17 	ldw	r4,-8(fp)
 821895c:	82167380 	call	8216738 <OS_StrLen>
 8218960:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
 8218964:	e0bffa03 	ldbu	r2,-24(fp)
 8218968:	10800830 	cmpltui	r2,r2,32
 821896c:	1000081e 	bne	r2,zero,8218990 <OSMemNameSet+0xcc>
 8218970:	e0bff817 	ldw	r2,-32(fp)
 8218974:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218978:	e0bff917 	ldw	r2,-28(fp)
 821897c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
 8218980:	e0bfff17 	ldw	r2,-4(fp)
 8218984:	00c018c4 	movi	r3,99
 8218988:	10c00005 	stb	r3,0(r2)
        return;
 821898c:	00000d06 	br	82189c4 <OSMemNameSet+0x100>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
 8218990:	e0bffd17 	ldw	r2,-12(fp)
 8218994:	10800504 	addi	r2,r2,20
 8218998:	e17ffe17 	ldw	r5,-8(fp)
 821899c:	1009883a 	mov	r4,r2
 82189a0:	82166c40 	call	82166c4 <OS_StrCopy>
 82189a4:	e0bff817 	ldw	r2,-32(fp)
 82189a8:	e0bffb15 	stw	r2,-20(fp)
 82189ac:	e0bffb17 	ldw	r2,-20(fp)
 82189b0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 82189b4:	e0bfff17 	ldw	r2,-4(fp)
 82189b8:	10000005 	stb	zero,0(r2)
 82189bc:	00000106 	br	82189c4 <OSMemNameSet+0x100>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
 82189c0:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
 82189c4:	e037883a 	mov	sp,fp
 82189c8:	dfc00117 	ldw	ra,4(sp)
 82189cc:	df000017 	ldw	fp,0(sp)
 82189d0:	dec00204 	addi	sp,sp,8
 82189d4:	f800283a 	ret

082189d8 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
 82189d8:	defff904 	addi	sp,sp,-28
 82189dc:	df000615 	stw	fp,24(sp)
 82189e0:	df000604 	addi	fp,sp,24
 82189e4:	e13ffe15 	stw	r4,-8(fp)
 82189e8:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82189ec:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 82189f0:	e0bffe17 	ldw	r2,-8(fp)
 82189f4:	1000021e 	bne	r2,zero,8218a00 <OSMemPut+0x28>
        return (OS_ERR_MEM_INVALID_PMEM);
 82189f8:	00801804 	movi	r2,96
 82189fc:	00002806 	br	8218aa0 <OSMemPut+0xc8>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
 8218a00:	e0bfff17 	ldw	r2,-4(fp)
 8218a04:	1000021e 	bne	r2,zero,8218a10 <OSMemPut+0x38>
        return (OS_ERR_MEM_INVALID_PBLK);
 8218a08:	008017c4 	movi	r2,95
 8218a0c:	00002406 	br	8218aa0 <OSMemPut+0xc8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218a10:	0005303a 	rdctl	r2,status
 8218a14:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218a18:	e0fffd17 	ldw	r3,-12(fp)
 8218a1c:	00bfff84 	movi	r2,-2
 8218a20:	1884703a 	and	r2,r3,r2
 8218a24:	1001703a 	wrctl	status,r2
  
  return context;
 8218a28:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 8218a2c:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
 8218a30:	e0bffe17 	ldw	r2,-8(fp)
 8218a34:	10c00417 	ldw	r3,16(r2)
 8218a38:	e0bffe17 	ldw	r2,-8(fp)
 8218a3c:	10800317 	ldw	r2,12(r2)
 8218a40:	18800636 	bltu	r3,r2,8218a5c <OSMemPut+0x84>
 8218a44:	e0bffa17 	ldw	r2,-24(fp)
 8218a48:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218a4c:	e0bffb17 	ldw	r2,-20(fp)
 8218a50:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
 8218a54:	00801784 	movi	r2,94
 8218a58:	00001106 	br	8218aa0 <OSMemPut+0xc8>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
 8218a5c:	e0bffe17 	ldw	r2,-8(fp)
 8218a60:	10c00117 	ldw	r3,4(r2)
 8218a64:	e0bfff17 	ldw	r2,-4(fp)
 8218a68:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
 8218a6c:	e0bffe17 	ldw	r2,-8(fp)
 8218a70:	e0ffff17 	ldw	r3,-4(fp)
 8218a74:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
 8218a78:	e0bffe17 	ldw	r2,-8(fp)
 8218a7c:	10800417 	ldw	r2,16(r2)
 8218a80:	10c00044 	addi	r3,r2,1
 8218a84:	e0bffe17 	ldw	r2,-8(fp)
 8218a88:	10c00415 	stw	r3,16(r2)
 8218a8c:	e0bffa17 	ldw	r2,-24(fp)
 8218a90:	e0bffc15 	stw	r2,-16(fp)
 8218a94:	e0bffc17 	ldw	r2,-16(fp)
 8218a98:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
 8218a9c:	0005883a 	mov	r2,zero
}
 8218aa0:	e037883a 	mov	sp,fp
 8218aa4:	df000017 	ldw	fp,0(sp)
 8218aa8:	dec00104 	addi	sp,sp,4
 8218aac:	f800283a 	ret

08218ab0 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
 8218ab0:	defffa04 	addi	sp,sp,-24
 8218ab4:	df000515 	stw	fp,20(sp)
 8218ab8:	df000504 	addi	fp,sp,20
 8218abc:	e13ffe15 	stw	r4,-8(fp)
 8218ac0:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8218ac4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 8218ac8:	e0bffe17 	ldw	r2,-8(fp)
 8218acc:	1000021e 	bne	r2,zero,8218ad8 <OSMemQuery+0x28>
        return (OS_ERR_MEM_INVALID_PMEM);
 8218ad0:	00801804 	movi	r2,96
 8218ad4:	00002c06 	br	8218b88 <OSMemQuery+0xd8>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
 8218ad8:	e0bfff17 	ldw	r2,-4(fp)
 8218adc:	1000021e 	bne	r2,zero,8218ae8 <OSMemQuery+0x38>
        return (OS_ERR_MEM_INVALID_PDATA);
 8218ae0:	00801844 	movi	r2,97
 8218ae4:	00002806 	br	8218b88 <OSMemQuery+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218ae8:	0005303a 	rdctl	r2,status
 8218aec:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218af0:	e0fffc17 	ldw	r3,-16(fp)
 8218af4:	00bfff84 	movi	r2,-2
 8218af8:	1884703a 	and	r2,r3,r2
 8218afc:	1001703a 	wrctl	status,r2
  
  return context;
 8218b00:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 8218b04:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
 8218b08:	e0bffe17 	ldw	r2,-8(fp)
 8218b0c:	10c00017 	ldw	r3,0(r2)
 8218b10:	e0bfff17 	ldw	r2,-4(fp)
 8218b14:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
 8218b18:	e0bffe17 	ldw	r2,-8(fp)
 8218b1c:	10c00117 	ldw	r3,4(r2)
 8218b20:	e0bfff17 	ldw	r2,-4(fp)
 8218b24:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
 8218b28:	e0bffe17 	ldw	r2,-8(fp)
 8218b2c:	10c00217 	ldw	r3,8(r2)
 8218b30:	e0bfff17 	ldw	r2,-4(fp)
 8218b34:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
 8218b38:	e0bffe17 	ldw	r2,-8(fp)
 8218b3c:	10c00317 	ldw	r3,12(r2)
 8218b40:	e0bfff17 	ldw	r2,-4(fp)
 8218b44:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
 8218b48:	e0bffe17 	ldw	r2,-8(fp)
 8218b4c:	10c00417 	ldw	r3,16(r2)
 8218b50:	e0bfff17 	ldw	r2,-4(fp)
 8218b54:	10c00415 	stw	r3,16(r2)
 8218b58:	e0bffb17 	ldw	r2,-20(fp)
 8218b5c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218b60:	e0bffd17 	ldw	r2,-12(fp)
 8218b64:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
 8218b68:	e0bfff17 	ldw	r2,-4(fp)
 8218b6c:	10c00317 	ldw	r3,12(r2)
 8218b70:	e0bfff17 	ldw	r2,-4(fp)
 8218b74:	10800417 	ldw	r2,16(r2)
 8218b78:	1887c83a 	sub	r3,r3,r2
 8218b7c:	e0bfff17 	ldw	r2,-4(fp)
 8218b80:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
 8218b84:	0005883a 	mov	r2,zero
}
 8218b88:	e037883a 	mov	sp,fp
 8218b8c:	df000017 	ldw	fp,0(sp)
 8218b90:	dec00104 	addi	sp,sp,4
 8218b94:	f800283a 	ret

08218b98 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
 8218b98:	defffc04 	addi	sp,sp,-16
 8218b9c:	dfc00315 	stw	ra,12(sp)
 8218ba0:	df000215 	stw	fp,8(sp)
 8218ba4:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
 8218ba8:	01430c04 	movi	r5,3120
 8218bac:	010209b4 	movhi	r4,2086
 8218bb0:	212b3304 	addi	r4,r4,-21300
 8218bb4:	82164c40 	call	82164c4 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
 8218bb8:	008209b4 	movhi	r2,2086
 8218bbc:	10ab3304 	addi	r2,r2,-21300
 8218bc0:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 8218bc4:	e03fff0d 	sth	zero,-4(fp)
 8218bc8:	00001306 	br	8218c18 <OS_MemInit+0x80>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
 8218bcc:	e0bfff0b 	ldhu	r2,-4(fp)
 8218bd0:	10800044 	addi	r2,r2,1
 8218bd4:	10c00d24 	muli	r3,r2,52
 8218bd8:	008209b4 	movhi	r2,2086
 8218bdc:	10ab3304 	addi	r2,r2,-21300
 8218be0:	1887883a 	add	r3,r3,r2
 8218be4:	e0bffe17 	ldw	r2,-8(fp)
 8218be8:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
 8218bec:	e0bffe17 	ldw	r2,-8(fp)
 8218bf0:	00c00fc4 	movi	r3,63
 8218bf4:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
 8218bf8:	e0bffe17 	ldw	r2,-8(fp)
 8218bfc:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
 8218c00:	e0bffe17 	ldw	r2,-8(fp)
 8218c04:	10800d04 	addi	r2,r2,52
 8218c08:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 8218c0c:	e0bfff0b 	ldhu	r2,-4(fp)
 8218c10:	10800044 	addi	r2,r2,1
 8218c14:	e0bfff0d 	sth	r2,-4(fp)
 8218c18:	e0bfff0b 	ldhu	r2,-4(fp)
 8218c1c:	10800ef0 	cmpltui	r2,r2,59
 8218c20:	103fea1e 	bne	r2,zero,8218bcc <OS_MemInit+0x34>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
 8218c24:	e0bffe17 	ldw	r2,-8(fp)
 8218c28:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
 8218c2c:	e0bffe17 	ldw	r2,-8(fp)
 8218c30:	00c00fc4 	movi	r3,63
 8218c34:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
 8218c38:	e0bffe17 	ldw	r2,-8(fp)
 8218c3c:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
 8218c40:	008209b4 	movhi	r2,2086
 8218c44:	10ab3304 	addi	r2,r2,-21300
 8218c48:	d0a07415 	stw	r2,-32304(gp)
#endif
}
 8218c4c:	0001883a 	nop
 8218c50:	e037883a 	mov	sp,fp
 8218c54:	dfc00117 	ldw	ra,4(sp)
 8218c58:	df000017 	ldw	fp,0(sp)
 8218c5c:	dec00204 	addi	sp,sp,8
 8218c60:	f800283a 	ret

08218c64 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
 8218c64:	defff804 	addi	sp,sp,-32
 8218c68:	df000715 	stw	fp,28(sp)
 8218c6c:	df000704 	addi	fp,sp,28
 8218c70:	e13ffe15 	stw	r4,-8(fp)
 8218c74:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8218c78:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8218c7c:	e0bfff17 	ldw	r2,-4(fp)
 8218c80:	1000021e 	bne	r2,zero,8218c8c <OSQAccept+0x28>
        return ((void *)0);
 8218c84:	0005883a 	mov	r2,zero
 8218c88:	00004206 	br	8218d94 <OSQAccept+0x130>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 8218c8c:	e0bffe17 	ldw	r2,-8(fp)
 8218c90:	1000051e 	bne	r2,zero,8218ca8 <OSQAccept+0x44>
        *perr = OS_ERR_PEVENT_NULL;
 8218c94:	e0bfff17 	ldw	r2,-4(fp)
 8218c98:	00c00104 	movi	r3,4
 8218c9c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8218ca0:	0005883a 	mov	r2,zero
 8218ca4:	00003b06 	br	8218d94 <OSQAccept+0x130>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 8218ca8:	e0bffe17 	ldw	r2,-8(fp)
 8218cac:	10800003 	ldbu	r2,0(r2)
 8218cb0:	10803fcc 	andi	r2,r2,255
 8218cb4:	108000a0 	cmpeqi	r2,r2,2
 8218cb8:	1000051e 	bne	r2,zero,8218cd0 <OSQAccept+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
 8218cbc:	e0bfff17 	ldw	r2,-4(fp)
 8218cc0:	00c00044 	movi	r3,1
 8218cc4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8218cc8:	0005883a 	mov	r2,zero
 8218ccc:	00003106 	br	8218d94 <OSQAccept+0x130>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218cd0:	0005303a 	rdctl	r2,status
 8218cd4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218cd8:	e0fffd17 	ldw	r3,-12(fp)
 8218cdc:	00bfff84 	movi	r2,-2
 8218ce0:	1884703a 	and	r2,r3,r2
 8218ce4:	1001703a 	wrctl	status,r2
  
  return context;
 8218ce8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 8218cec:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 8218cf0:	e0bffe17 	ldw	r2,-8(fp)
 8218cf4:	10800117 	ldw	r2,4(r2)
 8218cf8:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 8218cfc:	e0bffc17 	ldw	r2,-16(fp)
 8218d00:	1080058b 	ldhu	r2,22(r2)
 8218d04:	10bfffcc 	andi	r2,r2,65535
 8218d08:	10001926 	beq	r2,zero,8218d70 <OSQAccept+0x10c>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 8218d0c:	e0bffc17 	ldw	r2,-16(fp)
 8218d10:	10800417 	ldw	r2,16(r2)
 8218d14:	11000104 	addi	r4,r2,4
 8218d18:	e0fffc17 	ldw	r3,-16(fp)
 8218d1c:	19000415 	stw	r4,16(r3)
 8218d20:	10800017 	ldw	r2,0(r2)
 8218d24:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 8218d28:	e0bffc17 	ldw	r2,-16(fp)
 8218d2c:	1080058b 	ldhu	r2,22(r2)
 8218d30:	10bfffc4 	addi	r2,r2,-1
 8218d34:	1007883a 	mov	r3,r2
 8218d38:	e0bffc17 	ldw	r2,-16(fp)
 8218d3c:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 8218d40:	e0bffc17 	ldw	r2,-16(fp)
 8218d44:	10c00417 	ldw	r3,16(r2)
 8218d48:	e0bffc17 	ldw	r2,-16(fp)
 8218d4c:	10800217 	ldw	r2,8(r2)
 8218d50:	1880041e 	bne	r3,r2,8218d64 <OSQAccept+0x100>
            pq->OSQOut = pq->OSQStart;
 8218d54:	e0bffc17 	ldw	r2,-16(fp)
 8218d58:	10c00117 	ldw	r3,4(r2)
 8218d5c:	e0bffc17 	ldw	r2,-16(fp)
 8218d60:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
 8218d64:	e0bfff17 	ldw	r2,-4(fp)
 8218d68:	10000005 	stb	zero,0(r2)
 8218d6c:	00000406 	br	8218d80 <OSQAccept+0x11c>
    } else {
        *perr = OS_ERR_Q_EMPTY;
 8218d70:	e0bfff17 	ldw	r2,-4(fp)
 8218d74:	00c007c4 	movi	r3,31
 8218d78:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
 8218d7c:	e03ff915 	stw	zero,-28(fp)
 8218d80:	e0bffa17 	ldw	r2,-24(fp)
 8218d84:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218d88:	e0bffb17 	ldw	r2,-20(fp)
 8218d8c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
 8218d90:	e0bff917 	ldw	r2,-28(fp)
}
 8218d94:	e037883a 	mov	sp,fp
 8218d98:	df000017 	ldw	fp,0(sp)
 8218d9c:	dec00104 	addi	sp,sp,4
 8218da0:	f800283a 	ret

08218da4 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
 8218da4:	defff404 	addi	sp,sp,-48
 8218da8:	dfc00b15 	stw	ra,44(sp)
 8218dac:	df000a15 	stw	fp,40(sp)
 8218db0:	df000a04 	addi	fp,sp,40
 8218db4:	e13ffe15 	stw	r4,-8(fp)
 8218db8:	2805883a 	mov	r2,r5
 8218dbc:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8218dc0:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 8218dc4:	d0a07903 	ldbu	r2,-32284(gp)
 8218dc8:	10803fcc 	andi	r2,r2,255
 8218dcc:	10000226 	beq	r2,zero,8218dd8 <OSQCreate+0x34>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
 8218dd0:	0005883a 	mov	r2,zero
 8218dd4:	00005906 	br	8218f3c <OSQCreate+0x198>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218dd8:	0005303a 	rdctl	r2,status
 8218ddc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218de0:	e0fffd17 	ldw	r3,-12(fp)
 8218de4:	00bfff84 	movi	r2,-2
 8218de8:	1884703a 	and	r2,r3,r2
 8218dec:	1001703a 	wrctl	status,r2
  
  return context;
 8218df0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 8218df4:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
 8218df8:	d0a07817 	ldw	r2,-32288(gp)
 8218dfc:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
 8218e00:	d0a07817 	ldw	r2,-32288(gp)
 8218e04:	10000326 	beq	r2,zero,8218e14 <OSQCreate+0x70>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 8218e08:	d0a07817 	ldw	r2,-32288(gp)
 8218e0c:	10800117 	ldw	r2,4(r2)
 8218e10:	d0a07815 	stw	r2,-32288(gp)
 8218e14:	e0bff717 	ldw	r2,-36(fp)
 8218e18:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218e1c:	e0bff817 	ldw	r2,-32(fp)
 8218e20:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
 8218e24:	e0bff617 	ldw	r2,-40(fp)
 8218e28:	10004326 	beq	r2,zero,8218f38 <OSQCreate+0x194>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218e2c:	0005303a 	rdctl	r2,status
 8218e30:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218e34:	e0fff917 	ldw	r3,-28(fp)
 8218e38:	00bfff84 	movi	r2,-2
 8218e3c:	1884703a 	and	r2,r3,r2
 8218e40:	1001703a 	wrctl	status,r2
  
  return context;
 8218e44:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
 8218e48:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
 8218e4c:	d0a07617 	ldw	r2,-32296(gp)
 8218e50:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
 8218e54:	e0bffb17 	ldw	r2,-20(fp)
 8218e58:	10002d26 	beq	r2,zero,8218f10 <OSQCreate+0x16c>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
 8218e5c:	d0a07617 	ldw	r2,-32296(gp)
 8218e60:	10800017 	ldw	r2,0(r2)
 8218e64:	d0a07615 	stw	r2,-32296(gp)
 8218e68:	e0bff717 	ldw	r2,-36(fp)
 8218e6c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218e70:	e0bffa17 	ldw	r2,-24(fp)
 8218e74:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
 8218e78:	e0bffb17 	ldw	r2,-20(fp)
 8218e7c:	e0fffe17 	ldw	r3,-8(fp)
 8218e80:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
 8218e84:	e0bfff0b 	ldhu	r2,-4(fp)
 8218e88:	1085883a 	add	r2,r2,r2
 8218e8c:	1085883a 	add	r2,r2,r2
 8218e90:	1007883a 	mov	r3,r2
 8218e94:	e0bffe17 	ldw	r2,-8(fp)
 8218e98:	10c7883a 	add	r3,r2,r3
 8218e9c:	e0bffb17 	ldw	r2,-20(fp)
 8218ea0:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
 8218ea4:	e0bffb17 	ldw	r2,-20(fp)
 8218ea8:	e0fffe17 	ldw	r3,-8(fp)
 8218eac:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
 8218eb0:	e0bffb17 	ldw	r2,-20(fp)
 8218eb4:	e0fffe17 	ldw	r3,-8(fp)
 8218eb8:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
 8218ebc:	e0bffb17 	ldw	r2,-20(fp)
 8218ec0:	e0ffff0b 	ldhu	r3,-4(fp)
 8218ec4:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
 8218ec8:	e0bffb17 	ldw	r2,-20(fp)
 8218ecc:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
 8218ed0:	e0bff617 	ldw	r2,-40(fp)
 8218ed4:	00c00084 	movi	r3,2
 8218ed8:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
 8218edc:	e0bff617 	ldw	r2,-40(fp)
 8218ee0:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
 8218ee4:	e0bff617 	ldw	r2,-40(fp)
 8218ee8:	e0fffb17 	ldw	r3,-20(fp)
 8218eec:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
 8218ef0:	e0bff617 	ldw	r2,-40(fp)
 8218ef4:	00c00fc4 	movi	r3,63
 8218ef8:	10c00385 	stb	r3,14(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
 8218efc:	e0bff617 	ldw	r2,-40(fp)
 8218f00:	100003c5 	stb	zero,15(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
 8218f04:	e13ff617 	ldw	r4,-40(fp)
 8218f08:	82160e40 	call	82160e4 <OS_EventWaitListInit>
 8218f0c:	00000a06 	br	8218f38 <OSQCreate+0x194>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
 8218f10:	d0e07817 	ldw	r3,-32288(gp)
 8218f14:	e0bff617 	ldw	r2,-40(fp)
 8218f18:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
 8218f1c:	e0bff617 	ldw	r2,-40(fp)
 8218f20:	d0a07815 	stw	r2,-32288(gp)
 8218f24:	e0bff717 	ldw	r2,-36(fp)
 8218f28:	e0bffc15 	stw	r2,-16(fp)
 8218f2c:	e0bffc17 	ldw	r2,-16(fp)
 8218f30:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
 8218f34:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
 8218f38:	e0bff617 	ldw	r2,-40(fp)
}
 8218f3c:	e037883a 	mov	sp,fp
 8218f40:	dfc00117 	ldw	ra,4(sp)
 8218f44:	df000017 	ldw	fp,0(sp)
 8218f48:	dec00204 	addi	sp,sp,8
 8218f4c:	f800283a 	ret

08218f50 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 8218f50:	defff204 	addi	sp,sp,-56
 8218f54:	dfc00d15 	stw	ra,52(sp)
 8218f58:	df000c15 	stw	fp,48(sp)
 8218f5c:	df000c04 	addi	fp,sp,48
 8218f60:	e13ffd15 	stw	r4,-12(fp)
 8218f64:	2805883a 	mov	r2,r5
 8218f68:	e1bfff15 	stw	r6,-4(fp)
 8218f6c:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 8218f70:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 8218f74:	e0bfff17 	ldw	r2,-4(fp)
 8218f78:	1000021e 	bne	r2,zero,8218f84 <OSQDel+0x34>
        return (pevent);
 8218f7c:	e0bffd17 	ldw	r2,-12(fp)
 8218f80:	00008e06 	br	82191bc <OSQDel+0x26c>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 8218f84:	e0bffd17 	ldw	r2,-12(fp)
 8218f88:	1000051e 	bne	r2,zero,8218fa0 <OSQDel+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 8218f8c:	e0bfff17 	ldw	r2,-4(fp)
 8218f90:	00c00104 	movi	r3,4
 8218f94:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8218f98:	e0bffd17 	ldw	r2,-12(fp)
 8218f9c:	00008706 	br	82191bc <OSQDel+0x26c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 8218fa0:	e0bffd17 	ldw	r2,-12(fp)
 8218fa4:	10800003 	ldbu	r2,0(r2)
 8218fa8:	10803fcc 	andi	r2,r2,255
 8218fac:	108000a0 	cmpeqi	r2,r2,2
 8218fb0:	1000051e 	bne	r2,zero,8218fc8 <OSQDel+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 8218fb4:	e0bfff17 	ldw	r2,-4(fp)
 8218fb8:	00c00044 	movi	r3,1
 8218fbc:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8218fc0:	e0bffd17 	ldw	r2,-12(fp)
 8218fc4:	00007d06 	br	82191bc <OSQDel+0x26c>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 8218fc8:	d0a07903 	ldbu	r2,-32284(gp)
 8218fcc:	10803fcc 	andi	r2,r2,255
 8218fd0:	10000526 	beq	r2,zero,8218fe8 <OSQDel+0x98>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 8218fd4:	e0bfff17 	ldw	r2,-4(fp)
 8218fd8:	00c003c4 	movi	r3,15
 8218fdc:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8218fe0:	e0bffd17 	ldw	r2,-12(fp)
 8218fe4:	00007506 	br	82191bc <OSQDel+0x26c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218fe8:	0005303a 	rdctl	r2,status
 8218fec:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218ff0:	e0fffc17 	ldw	r3,-16(fp)
 8218ff4:	00bfff84 	movi	r2,-2
 8218ff8:	1884703a 	and	r2,r3,r2
 8218ffc:	1001703a 	wrctl	status,r2
  
  return context;
 8219000:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8219004:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
 8219008:	e0bffd17 	ldw	r2,-12(fp)
 821900c:	10800283 	ldbu	r2,10(r2)
 8219010:	10803fcc 	andi	r2,r2,255
 8219014:	10000326 	beq	r2,zero,8219024 <OSQDel+0xd4>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 8219018:	00800044 	movi	r2,1
 821901c:	e0bff405 	stb	r2,-48(fp)
 8219020:	00000106 	br	8219028 <OSQDel+0xd8>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 8219024:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
 8219028:	e0bffe03 	ldbu	r2,-8(fp)
 821902c:	10000326 	beq	r2,zero,821903c <OSQDel+0xec>
 8219030:	10800060 	cmpeqi	r2,r2,1
 8219034:	1000301e 	bne	r2,zero,82190f8 <OSQDel+0x1a8>
 8219038:	00005506 	br	8219190 <OSQDel+0x240>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
 821903c:	e0bff403 	ldbu	r2,-48(fp)
 8219040:	10001e1e 	bne	r2,zero,82190bc <OSQDel+0x16c>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 8219044:	e0bffd17 	ldw	r2,-12(fp)
 8219048:	00c00fc4 	movi	r3,63
 821904c:	10c00385 	stb	r3,14(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 8219050:	e0bffd17 	ldw	r2,-12(fp)
 8219054:	100003c5 	stb	zero,15(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
 8219058:	e0bffd17 	ldw	r2,-12(fp)
 821905c:	10800117 	ldw	r2,4(r2)
 8219060:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
 8219064:	d0e07617 	ldw	r3,-32296(gp)
 8219068:	e0bff817 	ldw	r2,-32(fp)
 821906c:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
 8219070:	e0bff817 	ldw	r2,-32(fp)
 8219074:	d0a07615 	stw	r2,-32296(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 8219078:	e0bffd17 	ldw	r2,-12(fp)
 821907c:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 8219080:	d0e07817 	ldw	r3,-32288(gp)
 8219084:	e0bffd17 	ldw	r2,-12(fp)
 8219088:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 821908c:	e0bffd17 	ldw	r2,-12(fp)
 8219090:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 8219094:	e0bffd17 	ldw	r2,-12(fp)
 8219098:	d0a07815 	stw	r2,-32288(gp)
 821909c:	e0bff617 	ldw	r2,-40(fp)
 82190a0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82190a4:	e0bff717 	ldw	r2,-36(fp)
 82190a8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 82190ac:	e0bfff17 	ldw	r2,-4(fp)
 82190b0:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
 82190b4:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
 82190b8:	00003f06 	br	82191b8 <OSQDel+0x268>
 82190bc:	e0bff617 	ldw	r2,-40(fp)
 82190c0:	e0bff915 	stw	r2,-28(fp)
 82190c4:	e0bff917 	ldw	r2,-28(fp)
 82190c8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 82190cc:	e0bfff17 	ldw	r2,-4(fp)
 82190d0:	00c01244 	movi	r3,73
 82190d4:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
 82190d8:	e0bffd17 	ldw	r2,-12(fp)
 82190dc:	e0bff515 	stw	r2,-44(fp)
             }
             break;
 82190e0:	00003506 	br	82191b8 <OSQDel+0x268>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
 82190e4:	000f883a 	mov	r7,zero
 82190e8:	01800104 	movi	r6,4
 82190ec:	000b883a 	mov	r5,zero
 82190f0:	e13ffd17 	ldw	r4,-12(fp)
 82190f4:	8215b340 	call	8215b34 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
 82190f8:	e0bffd17 	ldw	r2,-12(fp)
 82190fc:	10800283 	ldbu	r2,10(r2)
 8219100:	10803fcc 	andi	r2,r2,255
 8219104:	103ff71e 	bne	r2,zero,82190e4 <OSQDel+0x194>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 8219108:	e0bffd17 	ldw	r2,-12(fp)
 821910c:	00c00fc4 	movi	r3,63
 8219110:	10c00385 	stb	r3,14(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 8219114:	e0bffd17 	ldw	r2,-12(fp)
 8219118:	100003c5 	stb	zero,15(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
 821911c:	e0bffd17 	ldw	r2,-12(fp)
 8219120:	10800117 	ldw	r2,4(r2)
 8219124:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
 8219128:	d0e07617 	ldw	r3,-32296(gp)
 821912c:	e0bff817 	ldw	r2,-32(fp)
 8219130:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
 8219134:	e0bff817 	ldw	r2,-32(fp)
 8219138:	d0a07615 	stw	r2,-32296(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 821913c:	e0bffd17 	ldw	r2,-12(fp)
 8219140:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 8219144:	d0e07817 	ldw	r3,-32288(gp)
 8219148:	e0bffd17 	ldw	r2,-12(fp)
 821914c:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 8219150:	e0bffd17 	ldw	r2,-12(fp)
 8219154:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 8219158:	e0bffd17 	ldw	r2,-12(fp)
 821915c:	d0a07815 	stw	r2,-32288(gp)
 8219160:	e0bff617 	ldw	r2,-40(fp)
 8219164:	e0bffa15 	stw	r2,-24(fp)
 8219168:	e0bffa17 	ldw	r2,-24(fp)
 821916c:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 8219170:	e0bff403 	ldbu	r2,-48(fp)
 8219174:	10800058 	cmpnei	r2,r2,1
 8219178:	1000011e 	bne	r2,zero,8219180 <OSQDel+0x230>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 821917c:	82165800 	call	8216580 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 8219180:	e0bfff17 	ldw	r2,-4(fp)
 8219184:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
 8219188:	e03ff515 	stw	zero,-44(fp)
             break;
 821918c:	00000a06 	br	82191b8 <OSQDel+0x268>
 8219190:	e0bff617 	ldw	r2,-40(fp)
 8219194:	e0bffb15 	stw	r2,-20(fp)
 8219198:	e0bffb17 	ldw	r2,-20(fp)
 821919c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 82191a0:	e0bfff17 	ldw	r2,-4(fp)
 82191a4:	00c001c4 	movi	r3,7
 82191a8:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
 82191ac:	e0bffd17 	ldw	r2,-12(fp)
 82191b0:	e0bff515 	stw	r2,-44(fp)
             break;
 82191b4:	0001883a 	nop
    }
    return (pevent_return);
 82191b8:	e0bff517 	ldw	r2,-44(fp)
}
 82191bc:	e037883a 	mov	sp,fp
 82191c0:	dfc00117 	ldw	ra,4(sp)
 82191c4:	df000017 	ldw	fp,0(sp)
 82191c8:	dec00204 	addi	sp,sp,8
 82191cc:	f800283a 	ret

082191d0 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
 82191d0:	defffa04 	addi	sp,sp,-24
 82191d4:	df000515 	stw	fp,20(sp)
 82191d8:	df000504 	addi	fp,sp,20
 82191dc:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 82191e0:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 82191e4:	e0bfff17 	ldw	r2,-4(fp)
 82191e8:	1000021e 	bne	r2,zero,82191f4 <OSQFlush+0x24>
        return (OS_ERR_PEVENT_NULL);
 82191ec:	00800104 	movi	r2,4
 82191f0:	00002106 	br	8219278 <OSQFlush+0xa8>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 82191f4:	e0bfff17 	ldw	r2,-4(fp)
 82191f8:	10800003 	ldbu	r2,0(r2)
 82191fc:	10803fcc 	andi	r2,r2,255
 8219200:	108000a0 	cmpeqi	r2,r2,2
 8219204:	1000021e 	bne	r2,zero,8219210 <OSQFlush+0x40>
        return (OS_ERR_EVENT_TYPE);
 8219208:	00800044 	movi	r2,1
 821920c:	00001a06 	br	8219278 <OSQFlush+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219210:	0005303a 	rdctl	r2,status
 8219214:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219218:	e0fffd17 	ldw	r3,-12(fp)
 821921c:	00bfff84 	movi	r2,-2
 8219220:	1884703a 	and	r2,r3,r2
 8219224:	1001703a 	wrctl	status,r2
  
  return context;
 8219228:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821922c:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
 8219230:	e0bfff17 	ldw	r2,-4(fp)
 8219234:	10800117 	ldw	r2,4(r2)
 8219238:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
 821923c:	e0bffc17 	ldw	r2,-16(fp)
 8219240:	10c00117 	ldw	r3,4(r2)
 8219244:	e0bffc17 	ldw	r2,-16(fp)
 8219248:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
 821924c:	e0bffc17 	ldw	r2,-16(fp)
 8219250:	10c00117 	ldw	r3,4(r2)
 8219254:	e0bffc17 	ldw	r2,-16(fp)
 8219258:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
 821925c:	e0bffc17 	ldw	r2,-16(fp)
 8219260:	1000058d 	sth	zero,22(r2)
 8219264:	e0bffb17 	ldw	r2,-20(fp)
 8219268:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821926c:	e0bffe17 	ldw	r2,-8(fp)
 8219270:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 8219274:	0005883a 	mov	r2,zero
}
 8219278:	e037883a 	mov	sp,fp
 821927c:	df000017 	ldw	fp,0(sp)
 8219280:	dec00104 	addi	sp,sp,4
 8219284:	f800283a 	ret

08219288 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 8219288:	defff304 	addi	sp,sp,-52
 821928c:	dfc00c15 	stw	ra,48(sp)
 8219290:	df000b15 	stw	fp,44(sp)
 8219294:	df000b04 	addi	fp,sp,44
 8219298:	e13ffd15 	stw	r4,-12(fp)
 821929c:	2805883a 	mov	r2,r5
 82192a0:	e1bfff15 	stw	r6,-4(fp)
 82192a4:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82192a8:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 82192ac:	e0bfff17 	ldw	r2,-4(fp)
 82192b0:	1000021e 	bne	r2,zero,82192bc <OSQPend+0x34>
        return ((void *)0);
 82192b4:	0005883a 	mov	r2,zero
 82192b8:	00009106 	br	8219500 <OSQPend+0x278>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 82192bc:	e0bffd17 	ldw	r2,-12(fp)
 82192c0:	1000051e 	bne	r2,zero,82192d8 <OSQPend+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 82192c4:	e0bfff17 	ldw	r2,-4(fp)
 82192c8:	00c00104 	movi	r3,4
 82192cc:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 82192d0:	0005883a 	mov	r2,zero
 82192d4:	00008a06 	br	8219500 <OSQPend+0x278>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 82192d8:	e0bffd17 	ldw	r2,-12(fp)
 82192dc:	10800003 	ldbu	r2,0(r2)
 82192e0:	10803fcc 	andi	r2,r2,255
 82192e4:	108000a0 	cmpeqi	r2,r2,2
 82192e8:	1000051e 	bne	r2,zero,8219300 <OSQPend+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 82192ec:	e0bfff17 	ldw	r2,-4(fp)
 82192f0:	00c00044 	movi	r3,1
 82192f4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 82192f8:	0005883a 	mov	r2,zero
 82192fc:	00008006 	br	8219500 <OSQPend+0x278>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 8219300:	d0a07903 	ldbu	r2,-32284(gp)
 8219304:	10803fcc 	andi	r2,r2,255
 8219308:	10000526 	beq	r2,zero,8219320 <OSQPend+0x98>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
 821930c:	e0bfff17 	ldw	r2,-4(fp)
 8219310:	00c00084 	movi	r3,2
 8219314:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8219318:	0005883a 	mov	r2,zero
 821931c:	00007806 	br	8219500 <OSQPend+0x278>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
 8219320:	d0a06b03 	ldbu	r2,-32340(gp)
 8219324:	10803fcc 	andi	r2,r2,255
 8219328:	10000526 	beq	r2,zero,8219340 <OSQPend+0xb8>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
 821932c:	e0bfff17 	ldw	r2,-4(fp)
 8219330:	00c00344 	movi	r3,13
 8219334:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8219338:	0005883a 	mov	r2,zero
 821933c:	00007006 	br	8219500 <OSQPend+0x278>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219340:	0005303a 	rdctl	r2,status
 8219344:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219348:	e0fffc17 	ldw	r3,-16(fp)
 821934c:	00bfff84 	movi	r2,-2
 8219350:	1884703a 	and	r2,r3,r2
 8219354:	1001703a 	wrctl	status,r2
  
  return context;
 8219358:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821935c:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 8219360:	e0bffd17 	ldw	r2,-12(fp)
 8219364:	10800117 	ldw	r2,4(r2)
 8219368:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 821936c:	e0bff817 	ldw	r2,-32(fp)
 8219370:	1080058b 	ldhu	r2,22(r2)
 8219374:	10bfffcc 	andi	r2,r2,65535
 8219378:	10001e26 	beq	r2,zero,82193f4 <OSQPend+0x16c>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 821937c:	e0bff817 	ldw	r2,-32(fp)
 8219380:	10800417 	ldw	r2,16(r2)
 8219384:	11000104 	addi	r4,r2,4
 8219388:	e0fff817 	ldw	r3,-32(fp)
 821938c:	19000415 	stw	r4,16(r3)
 8219390:	10800017 	ldw	r2,0(r2)
 8219394:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 8219398:	e0bff817 	ldw	r2,-32(fp)
 821939c:	1080058b 	ldhu	r2,22(r2)
 82193a0:	10bfffc4 	addi	r2,r2,-1
 82193a4:	1007883a 	mov	r3,r2
 82193a8:	e0bff817 	ldw	r2,-32(fp)
 82193ac:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 82193b0:	e0bff817 	ldw	r2,-32(fp)
 82193b4:	10c00417 	ldw	r3,16(r2)
 82193b8:	e0bff817 	ldw	r2,-32(fp)
 82193bc:	10800217 	ldw	r2,8(r2)
 82193c0:	1880041e 	bne	r3,r2,82193d4 <OSQPend+0x14c>
            pq->OSQOut = pq->OSQStart;
 82193c4:	e0bff817 	ldw	r2,-32(fp)
 82193c8:	10c00117 	ldw	r3,4(r2)
 82193cc:	e0bff817 	ldw	r2,-32(fp)
 82193d0:	10c00415 	stw	r3,16(r2)
 82193d4:	e0bff617 	ldw	r2,-40(fp)
 82193d8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82193dc:	e0bff717 	ldw	r2,-36(fp)
 82193e0:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 82193e4:	e0bfff17 	ldw	r2,-4(fp)
 82193e8:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
 82193ec:	e0bff517 	ldw	r2,-44(fp)
 82193f0:	00004306 	br	8219500 <OSQPend+0x278>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
 82193f4:	d0a07a17 	ldw	r2,-32280(gp)
 82193f8:	d0e07a17 	ldw	r3,-32280(gp)
 82193fc:	18c00c03 	ldbu	r3,48(r3)
 8219400:	18c00114 	ori	r3,r3,4
 8219404:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 8219408:	d0a07a17 	ldw	r2,-32280(gp)
 821940c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
 8219410:	d0a07a17 	ldw	r2,-32280(gp)
 8219414:	e0fffe0b 	ldhu	r3,-8(fp)
 8219418:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
 821941c:	e13ffd17 	ldw	r4,-12(fp)
 8219420:	8215ccc0 	call	8215ccc <OS_EventTaskWait>
 8219424:	e0bff617 	ldw	r2,-40(fp)
 8219428:	e0bffb15 	stw	r2,-20(fp)
 821942c:	e0bffb17 	ldw	r2,-20(fp)
 8219430:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
 8219434:	82165800 	call	8216580 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219438:	0005303a 	rdctl	r2,status
 821943c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219440:	e0fff917 	ldw	r3,-28(fp)
 8219444:	00bfff84 	movi	r2,-2
 8219448:	1884703a 	and	r2,r3,r2
 821944c:	1001703a 	wrctl	status,r2
  
  return context;
 8219450:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
 8219454:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 8219458:	d0a07a17 	ldw	r2,-32280(gp)
 821945c:	10800c43 	ldbu	r2,49(r2)
 8219460:	10803fcc 	andi	r2,r2,255
 8219464:	10000326 	beq	r2,zero,8219474 <OSQPend+0x1ec>
 8219468:	108000a0 	cmpeqi	r2,r2,2
 821946c:	1000071e 	bne	r2,zero,821948c <OSQPend+0x204>
 8219470:	00000b06 	br	82194a0 <OSQPend+0x218>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
 8219474:	d0a07a17 	ldw	r2,-32280(gp)
 8219478:	10800917 	ldw	r2,36(r2)
 821947c:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
 8219480:	e0bfff17 	ldw	r2,-4(fp)
 8219484:	10000005 	stb	zero,0(r2)
             break;
 8219488:	00000e06 	br	82194c4 <OSQPend+0x23c>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
 821948c:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 8219490:	e0bfff17 	ldw	r2,-4(fp)
 8219494:	00c00384 	movi	r3,14
 8219498:	10c00005 	stb	r3,0(r2)
             break;
 821949c:	00000906 	br	82194c4 <OSQPend+0x23c>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
 82194a0:	d0a07a17 	ldw	r2,-32280(gp)
 82194a4:	e17ffd17 	ldw	r5,-12(fp)
 82194a8:	1009883a 	mov	r4,r2
 82194ac:	8215f2c0 	call	8215f2c <OS_EventTaskRemove>
             pmsg = (void *)0;
 82194b0:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 82194b4:	e0bfff17 	ldw	r2,-4(fp)
 82194b8:	00c00284 	movi	r3,10
 82194bc:	10c00005 	stb	r3,0(r2)
             break;
 82194c0:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 82194c4:	d0a07a17 	ldw	r2,-32280(gp)
 82194c8:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 82194cc:	d0a07a17 	ldw	r2,-32280(gp)
 82194d0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 82194d4:	d0a07a17 	ldw	r2,-32280(gp)
 82194d8:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 82194dc:	d0a07a17 	ldw	r2,-32280(gp)
 82194e0:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
 82194e4:	d0a07a17 	ldw	r2,-32280(gp)
 82194e8:	10000915 	stw	zero,36(r2)
 82194ec:	e0bff617 	ldw	r2,-40(fp)
 82194f0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82194f4:	e0bffa17 	ldw	r2,-24(fp)
 82194f8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
 82194fc:	e0bff517 	ldw	r2,-44(fp)
}
 8219500:	e037883a 	mov	sp,fp
 8219504:	dfc00117 	ldw	ra,4(sp)
 8219508:	df000017 	ldw	fp,0(sp)
 821950c:	dec00204 	addi	sp,sp,8
 8219510:	f800283a 	ret

08219514 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 8219514:	defff604 	addi	sp,sp,-40
 8219518:	dfc00915 	stw	ra,36(sp)
 821951c:	df000815 	stw	fp,32(sp)
 8219520:	df000804 	addi	fp,sp,32
 8219524:	e13ffd15 	stw	r4,-12(fp)
 8219528:	2805883a 	mov	r2,r5
 821952c:	e1bfff15 	stw	r6,-4(fp)
 8219530:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 8219534:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 8219538:	e0bfff17 	ldw	r2,-4(fp)
 821953c:	1000021e 	bne	r2,zero,8219548 <OSQPendAbort+0x34>
        return (0);
 8219540:	0005883a 	mov	r2,zero
 8219544:	00004906 	br	821966c <OSQPendAbort+0x158>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 8219548:	e0bffd17 	ldw	r2,-12(fp)
 821954c:	1000051e 	bne	r2,zero,8219564 <OSQPendAbort+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 8219550:	e0bfff17 	ldw	r2,-4(fp)
 8219554:	00c00104 	movi	r3,4
 8219558:	10c00005 	stb	r3,0(r2)
        return (0);
 821955c:	0005883a 	mov	r2,zero
 8219560:	00004206 	br	821966c <OSQPendAbort+0x158>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 8219564:	e0bffd17 	ldw	r2,-12(fp)
 8219568:	10800003 	ldbu	r2,0(r2)
 821956c:	10803fcc 	andi	r2,r2,255
 8219570:	108000a0 	cmpeqi	r2,r2,2
 8219574:	1000051e 	bne	r2,zero,821958c <OSQPendAbort+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 8219578:	e0bfff17 	ldw	r2,-4(fp)
 821957c:	00c00044 	movi	r3,1
 8219580:	10c00005 	stb	r3,0(r2)
        return (0);
 8219584:	0005883a 	mov	r2,zero
 8219588:	00003806 	br	821966c <OSQPendAbort+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821958c:	0005303a 	rdctl	r2,status
 8219590:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219594:	e0fffc17 	ldw	r3,-16(fp)
 8219598:	00bfff84 	movi	r2,-2
 821959c:	1884703a 	and	r2,r3,r2
 82195a0:	1001703a 	wrctl	status,r2
  
  return context;
 82195a4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 82195a8:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
 82195ac:	e0bffd17 	ldw	r2,-12(fp)
 82195b0:	10800283 	ldbu	r2,10(r2)
 82195b4:	10803fcc 	andi	r2,r2,255
 82195b8:	10002526 	beq	r2,zero,8219650 <OSQPendAbort+0x13c>
        nbr_tasks = 0;
 82195bc:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
 82195c0:	e0bffe03 	ldbu	r2,-8(fp)
 82195c4:	10800060 	cmpeqi	r2,r2,1
 82195c8:	10000e26 	beq	r2,zero,8219604 <OSQPendAbort+0xf0>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
 82195cc:	00000806 	br	82195f0 <OSQPendAbort+0xdc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 82195d0:	01c00084 	movi	r7,2
 82195d4:	01800104 	movi	r6,4
 82195d8:	000b883a 	mov	r5,zero
 82195dc:	e13ffd17 	ldw	r4,-12(fp)
 82195e0:	8215b340 	call	8215b34 <OS_EventTaskRdy>
                     nbr_tasks++;
 82195e4:	e0bff803 	ldbu	r2,-32(fp)
 82195e8:	10800044 	addi	r2,r2,1
 82195ec:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
 82195f0:	e0bffd17 	ldw	r2,-12(fp)
 82195f4:	10800283 	ldbu	r2,10(r2)
 82195f8:	10803fcc 	andi	r2,r2,255
 82195fc:	103ff41e 	bne	r2,zero,82195d0 <OSQPendAbort+0xbc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 8219600:	00000906 	br	8219628 <OSQPendAbort+0x114>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 8219604:	01c00084 	movi	r7,2
 8219608:	01800104 	movi	r6,4
 821960c:	000b883a 	mov	r5,zero
 8219610:	e13ffd17 	ldw	r4,-12(fp)
 8219614:	8215b340 	call	8215b34 <OS_EventTaskRdy>
                 nbr_tasks++;
 8219618:	e0bff803 	ldbu	r2,-32(fp)
 821961c:	10800044 	addi	r2,r2,1
 8219620:	e0bff805 	stb	r2,-32(fp)
                 break;
 8219624:	0001883a 	nop
 8219628:	e0bff917 	ldw	r2,-28(fp)
 821962c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219630:	e0bffa17 	ldw	r2,-24(fp)
 8219634:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
 8219638:	82165800 	call	8216580 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 821963c:	e0bfff17 	ldw	r2,-4(fp)
 8219640:	00c00384 	movi	r3,14
 8219644:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
 8219648:	e0bff803 	ldbu	r2,-32(fp)
 821964c:	00000706 	br	821966c <OSQPendAbort+0x158>
 8219650:	e0bff917 	ldw	r2,-28(fp)
 8219654:	e0bffb15 	stw	r2,-20(fp)
 8219658:	e0bffb17 	ldw	r2,-20(fp)
 821965c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8219660:	e0bfff17 	ldw	r2,-4(fp)
 8219664:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
 8219668:	0005883a 	mov	r2,zero
}
 821966c:	e037883a 	mov	sp,fp
 8219670:	dfc00117 	ldw	ra,4(sp)
 8219674:	df000017 	ldw	fp,0(sp)
 8219678:	dec00204 	addi	sp,sp,8
 821967c:	f800283a 	ret

08219680 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
 8219680:	defff604 	addi	sp,sp,-40
 8219684:	dfc00915 	stw	ra,36(sp)
 8219688:	df000815 	stw	fp,32(sp)
 821968c:	df000804 	addi	fp,sp,32
 8219690:	e13ffe15 	stw	r4,-8(fp)
 8219694:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 8219698:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 821969c:	e0bffe17 	ldw	r2,-8(fp)
 82196a0:	1000021e 	bne	r2,zero,82196ac <OSQPost+0x2c>
        return (OS_ERR_PEVENT_NULL);
 82196a4:	00800104 	movi	r2,4
 82196a8:	00004a06 	br	82197d4 <OSQPost+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 82196ac:	e0bffe17 	ldw	r2,-8(fp)
 82196b0:	10800003 	ldbu	r2,0(r2)
 82196b4:	10803fcc 	andi	r2,r2,255
 82196b8:	108000a0 	cmpeqi	r2,r2,2
 82196bc:	1000021e 	bne	r2,zero,82196c8 <OSQPost+0x48>
        return (OS_ERR_EVENT_TYPE);
 82196c0:	00800044 	movi	r2,1
 82196c4:	00004306 	br	82197d4 <OSQPost+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82196c8:	0005303a 	rdctl	r2,status
 82196cc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82196d0:	e0fffd17 	ldw	r3,-12(fp)
 82196d4:	00bfff84 	movi	r2,-2
 82196d8:	1884703a 	and	r2,r3,r2
 82196dc:	1001703a 	wrctl	status,r2
  
  return context;
 82196e0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 82196e4:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
 82196e8:	e0bffe17 	ldw	r2,-8(fp)
 82196ec:	10800283 	ldbu	r2,10(r2)
 82196f0:	10803fcc 	andi	r2,r2,255
 82196f4:	10000c26 	beq	r2,zero,8219728 <OSQPost+0xa8>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 82196f8:	000f883a 	mov	r7,zero
 82196fc:	01800104 	movi	r6,4
 8219700:	e17fff17 	ldw	r5,-4(fp)
 8219704:	e13ffe17 	ldw	r4,-8(fp)
 8219708:	8215b340 	call	8215b34 <OS_EventTaskRdy>
 821970c:	e0bff817 	ldw	r2,-32(fp)
 8219710:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219714:	e0bff917 	ldw	r2,-28(fp)
 8219718:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
 821971c:	82165800 	call	8216580 <OS_Sched>
        return (OS_ERR_NONE);
 8219720:	0005883a 	mov	r2,zero
 8219724:	00002b06 	br	82197d4 <OSQPost+0x154>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
 8219728:	e0bffe17 	ldw	r2,-8(fp)
 821972c:	10800117 	ldw	r2,4(r2)
 8219730:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
 8219734:	e0bffb17 	ldw	r2,-20(fp)
 8219738:	10c0058b 	ldhu	r3,22(r2)
 821973c:	e0bffb17 	ldw	r2,-20(fp)
 8219740:	1080050b 	ldhu	r2,20(r2)
 8219744:	18ffffcc 	andi	r3,r3,65535
 8219748:	10bfffcc 	andi	r2,r2,65535
 821974c:	18800636 	bltu	r3,r2,8219768 <OSQPost+0xe8>
 8219750:	e0bff817 	ldw	r2,-32(fp)
 8219754:	e0bffa15 	stw	r2,-24(fp)
 8219758:	e0bffa17 	ldw	r2,-24(fp)
 821975c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 8219760:	00800784 	movi	r2,30
 8219764:	00001b06 	br	82197d4 <OSQPost+0x154>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
 8219768:	e0bffb17 	ldw	r2,-20(fp)
 821976c:	10800317 	ldw	r2,12(r2)
 8219770:	11000104 	addi	r4,r2,4
 8219774:	e0fffb17 	ldw	r3,-20(fp)
 8219778:	19000315 	stw	r4,12(r3)
 821977c:	e0ffff17 	ldw	r3,-4(fp)
 8219780:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
 8219784:	e0bffb17 	ldw	r2,-20(fp)
 8219788:	1080058b 	ldhu	r2,22(r2)
 821978c:	10800044 	addi	r2,r2,1
 8219790:	1007883a 	mov	r3,r2
 8219794:	e0bffb17 	ldw	r2,-20(fp)
 8219798:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
 821979c:	e0bffb17 	ldw	r2,-20(fp)
 82197a0:	10c00317 	ldw	r3,12(r2)
 82197a4:	e0bffb17 	ldw	r2,-20(fp)
 82197a8:	10800217 	ldw	r2,8(r2)
 82197ac:	1880041e 	bne	r3,r2,82197c0 <OSQPost+0x140>
        pq->OSQIn = pq->OSQStart;
 82197b0:	e0bffb17 	ldw	r2,-20(fp)
 82197b4:	10c00117 	ldw	r3,4(r2)
 82197b8:	e0bffb17 	ldw	r2,-20(fp)
 82197bc:	10c00315 	stw	r3,12(r2)
 82197c0:	e0bff817 	ldw	r2,-32(fp)
 82197c4:	e0bffc15 	stw	r2,-16(fp)
 82197c8:	e0bffc17 	ldw	r2,-16(fp)
 82197cc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 82197d0:	0005883a 	mov	r2,zero
}
 82197d4:	e037883a 	mov	sp,fp
 82197d8:	dfc00117 	ldw	ra,4(sp)
 82197dc:	df000017 	ldw	fp,0(sp)
 82197e0:	dec00204 	addi	sp,sp,8
 82197e4:	f800283a 	ret

082197e8 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
 82197e8:	defff604 	addi	sp,sp,-40
 82197ec:	dfc00915 	stw	ra,36(sp)
 82197f0:	df000815 	stw	fp,32(sp)
 82197f4:	df000804 	addi	fp,sp,32
 82197f8:	e13ffe15 	stw	r4,-8(fp)
 82197fc:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 8219800:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 8219804:	e0bffe17 	ldw	r2,-8(fp)
 8219808:	1000021e 	bne	r2,zero,8219814 <OSQPostFront+0x2c>
        return (OS_ERR_PEVENT_NULL);
 821980c:	00800104 	movi	r2,4
 8219810:	00004c06 	br	8219944 <OSQPostFront+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 8219814:	e0bffe17 	ldw	r2,-8(fp)
 8219818:	10800003 	ldbu	r2,0(r2)
 821981c:	10803fcc 	andi	r2,r2,255
 8219820:	108000a0 	cmpeqi	r2,r2,2
 8219824:	1000021e 	bne	r2,zero,8219830 <OSQPostFront+0x48>
        return (OS_ERR_EVENT_TYPE);
 8219828:	00800044 	movi	r2,1
 821982c:	00004506 	br	8219944 <OSQPostFront+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219830:	0005303a 	rdctl	r2,status
 8219834:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219838:	e0fffd17 	ldw	r3,-12(fp)
 821983c:	00bfff84 	movi	r2,-2
 8219840:	1884703a 	and	r2,r3,r2
 8219844:	1001703a 	wrctl	status,r2
  
  return context;
 8219848:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 821984c:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
 8219850:	e0bffe17 	ldw	r2,-8(fp)
 8219854:	10800283 	ldbu	r2,10(r2)
 8219858:	10803fcc 	andi	r2,r2,255
 821985c:	10000c26 	beq	r2,zero,8219890 <OSQPostFront+0xa8>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 8219860:	000f883a 	mov	r7,zero
 8219864:	01800104 	movi	r6,4
 8219868:	e17fff17 	ldw	r5,-4(fp)
 821986c:	e13ffe17 	ldw	r4,-8(fp)
 8219870:	8215b340 	call	8215b34 <OS_EventTaskRdy>
 8219874:	e0bff817 	ldw	r2,-32(fp)
 8219878:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821987c:	e0bff917 	ldw	r2,-28(fp)
 8219880:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
 8219884:	82165800 	call	8216580 <OS_Sched>
        return (OS_ERR_NONE);
 8219888:	0005883a 	mov	r2,zero
 821988c:	00002d06 	br	8219944 <OSQPostFront+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 8219890:	e0bffe17 	ldw	r2,-8(fp)
 8219894:	10800117 	ldw	r2,4(r2)
 8219898:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 821989c:	e0bffb17 	ldw	r2,-20(fp)
 82198a0:	10c0058b 	ldhu	r3,22(r2)
 82198a4:	e0bffb17 	ldw	r2,-20(fp)
 82198a8:	1080050b 	ldhu	r2,20(r2)
 82198ac:	18ffffcc 	andi	r3,r3,65535
 82198b0:	10bfffcc 	andi	r2,r2,65535
 82198b4:	18800636 	bltu	r3,r2,82198d0 <OSQPostFront+0xe8>
 82198b8:	e0bff817 	ldw	r2,-32(fp)
 82198bc:	e0bffa15 	stw	r2,-24(fp)
 82198c0:	e0bffa17 	ldw	r2,-24(fp)
 82198c4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 82198c8:	00800784 	movi	r2,30
 82198cc:	00001d06 	br	8219944 <OSQPostFront+0x15c>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
 82198d0:	e0bffb17 	ldw	r2,-20(fp)
 82198d4:	10c00417 	ldw	r3,16(r2)
 82198d8:	e0bffb17 	ldw	r2,-20(fp)
 82198dc:	10800117 	ldw	r2,4(r2)
 82198e0:	1880041e 	bne	r3,r2,82198f4 <OSQPostFront+0x10c>
        pq->OSQOut = pq->OSQEnd;
 82198e4:	e0bffb17 	ldw	r2,-20(fp)
 82198e8:	10c00217 	ldw	r3,8(r2)
 82198ec:	e0bffb17 	ldw	r2,-20(fp)
 82198f0:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
 82198f4:	e0bffb17 	ldw	r2,-20(fp)
 82198f8:	10800417 	ldw	r2,16(r2)
 82198fc:	10ffff04 	addi	r3,r2,-4
 8219900:	e0bffb17 	ldw	r2,-20(fp)
 8219904:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
 8219908:	e0bffb17 	ldw	r2,-20(fp)
 821990c:	10800417 	ldw	r2,16(r2)
 8219910:	e0ffff17 	ldw	r3,-4(fp)
 8219914:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 8219918:	e0bffb17 	ldw	r2,-20(fp)
 821991c:	1080058b 	ldhu	r2,22(r2)
 8219920:	10800044 	addi	r2,r2,1
 8219924:	1007883a 	mov	r3,r2
 8219928:	e0bffb17 	ldw	r2,-20(fp)
 821992c:	10c0058d 	sth	r3,22(r2)
 8219930:	e0bff817 	ldw	r2,-32(fp)
 8219934:	e0bffc15 	stw	r2,-16(fp)
 8219938:	e0bffc17 	ldw	r2,-16(fp)
 821993c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 8219940:	0005883a 	mov	r2,zero
}
 8219944:	e037883a 	mov	sp,fp
 8219948:	dfc00117 	ldw	ra,4(sp)
 821994c:	df000017 	ldw	fp,0(sp)
 8219950:	dec00204 	addi	sp,sp,8
 8219954:	f800283a 	ret

08219958 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
 8219958:	defff504 	addi	sp,sp,-44
 821995c:	dfc00a15 	stw	ra,40(sp)
 8219960:	df000915 	stw	fp,36(sp)
 8219964:	df000904 	addi	fp,sp,36
 8219968:	e13ffd15 	stw	r4,-12(fp)
 821996c:	e17ffe15 	stw	r5,-8(fp)
 8219970:	3005883a 	mov	r2,r6
 8219974:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 8219978:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 821997c:	e0bffd17 	ldw	r2,-12(fp)
 8219980:	1000021e 	bne	r2,zero,821998c <OSQPostOpt+0x34>
        return (OS_ERR_PEVENT_NULL);
 8219984:	00800104 	movi	r2,4
 8219988:	00007106 	br	8219b50 <OSQPostOpt+0x1f8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 821998c:	e0bffd17 	ldw	r2,-12(fp)
 8219990:	10800003 	ldbu	r2,0(r2)
 8219994:	10803fcc 	andi	r2,r2,255
 8219998:	108000a0 	cmpeqi	r2,r2,2
 821999c:	1000021e 	bne	r2,zero,82199a8 <OSQPostOpt+0x50>
        return (OS_ERR_EVENT_TYPE);
 82199a0:	00800044 	movi	r2,1
 82199a4:	00006a06 	br	8219b50 <OSQPostOpt+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82199a8:	0005303a 	rdctl	r2,status
 82199ac:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82199b0:	e0fffc17 	ldw	r3,-16(fp)
 82199b4:	00bfff84 	movi	r2,-2
 82199b8:	1884703a 	and	r2,r3,r2
 82199bc:	1001703a 	wrctl	status,r2
  
  return context;
 82199c0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 82199c4:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
 82199c8:	e0bffd17 	ldw	r2,-12(fp)
 82199cc:	10800283 	ldbu	r2,10(r2)
 82199d0:	10803fcc 	andi	r2,r2,255
 82199d4:	10001d26 	beq	r2,zero,8219a4c <OSQPostOpt+0xf4>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
 82199d8:	e0bfff03 	ldbu	r2,-4(fp)
 82199dc:	1080004c 	andi	r2,r2,1
 82199e0:	10000b26 	beq	r2,zero,8219a10 <OSQPostOpt+0xb8>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 82199e4:	00000506 	br	82199fc <OSQPostOpt+0xa4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 82199e8:	000f883a 	mov	r7,zero
 82199ec:	01800104 	movi	r6,4
 82199f0:	e17ffe17 	ldw	r5,-8(fp)
 82199f4:	e13ffd17 	ldw	r4,-12(fp)
 82199f8:	8215b340 	call	8215b34 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 82199fc:	e0bffd17 	ldw	r2,-12(fp)
 8219a00:	10800283 	ldbu	r2,10(r2)
 8219a04:	10803fcc 	andi	r2,r2,255
 8219a08:	103ff71e 	bne	r2,zero,82199e8 <OSQPostOpt+0x90>
 8219a0c:	00000506 	br	8219a24 <OSQPostOpt+0xcc>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 8219a10:	000f883a 	mov	r7,zero
 8219a14:	01800104 	movi	r6,4
 8219a18:	e17ffe17 	ldw	r5,-8(fp)
 8219a1c:	e13ffd17 	ldw	r4,-12(fp)
 8219a20:	8215b340 	call	8215b34 <OS_EventTaskRdy>
 8219a24:	e0bff717 	ldw	r2,-36(fp)
 8219a28:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219a2c:	e0bff817 	ldw	r2,-32(fp)
 8219a30:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
 8219a34:	e0bfff03 	ldbu	r2,-4(fp)
 8219a38:	1080010c 	andi	r2,r2,4
 8219a3c:	1000011e 	bne	r2,zero,8219a44 <OSQPostOpt+0xec>
            OS_Sched();                               /* Find highest priority task ready to run       */
 8219a40:	82165800 	call	8216580 <OS_Sched>
        }
        return (OS_ERR_NONE);
 8219a44:	0005883a 	mov	r2,zero
 8219a48:	00004106 	br	8219b50 <OSQPostOpt+0x1f8>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 8219a4c:	e0bffd17 	ldw	r2,-12(fp)
 8219a50:	10800117 	ldw	r2,4(r2)
 8219a54:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 8219a58:	e0bffa17 	ldw	r2,-24(fp)
 8219a5c:	10c0058b 	ldhu	r3,22(r2)
 8219a60:	e0bffa17 	ldw	r2,-24(fp)
 8219a64:	1080050b 	ldhu	r2,20(r2)
 8219a68:	18ffffcc 	andi	r3,r3,65535
 8219a6c:	10bfffcc 	andi	r2,r2,65535
 8219a70:	18800636 	bltu	r3,r2,8219a8c <OSQPostOpt+0x134>
 8219a74:	e0bff717 	ldw	r2,-36(fp)
 8219a78:	e0bff915 	stw	r2,-28(fp)
 8219a7c:	e0bff917 	ldw	r2,-28(fp)
 8219a80:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 8219a84:	00800784 	movi	r2,30
 8219a88:	00003106 	br	8219b50 <OSQPostOpt+0x1f8>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
 8219a8c:	e0bfff03 	ldbu	r2,-4(fp)
 8219a90:	1080008c 	andi	r2,r2,2
 8219a94:	10001326 	beq	r2,zero,8219ae4 <OSQPostOpt+0x18c>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
 8219a98:	e0bffa17 	ldw	r2,-24(fp)
 8219a9c:	10c00417 	ldw	r3,16(r2)
 8219aa0:	e0bffa17 	ldw	r2,-24(fp)
 8219aa4:	10800117 	ldw	r2,4(r2)
 8219aa8:	1880041e 	bne	r3,r2,8219abc <OSQPostOpt+0x164>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
 8219aac:	e0bffa17 	ldw	r2,-24(fp)
 8219ab0:	10c00217 	ldw	r3,8(r2)
 8219ab4:	e0bffa17 	ldw	r2,-24(fp)
 8219ab8:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
 8219abc:	e0bffa17 	ldw	r2,-24(fp)
 8219ac0:	10800417 	ldw	r2,16(r2)
 8219ac4:	10ffff04 	addi	r3,r2,-4
 8219ac8:	e0bffa17 	ldw	r2,-24(fp)
 8219acc:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
 8219ad0:	e0bffa17 	ldw	r2,-24(fp)
 8219ad4:	10800417 	ldw	r2,16(r2)
 8219ad8:	e0fffe17 	ldw	r3,-8(fp)
 8219adc:	10c00015 	stw	r3,0(r2)
 8219ae0:	00001006 	br	8219b24 <OSQPostOpt+0x1cc>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
 8219ae4:	e0bffa17 	ldw	r2,-24(fp)
 8219ae8:	10800317 	ldw	r2,12(r2)
 8219aec:	11000104 	addi	r4,r2,4
 8219af0:	e0fffa17 	ldw	r3,-24(fp)
 8219af4:	19000315 	stw	r4,12(r3)
 8219af8:	e0fffe17 	ldw	r3,-8(fp)
 8219afc:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
 8219b00:	e0bffa17 	ldw	r2,-24(fp)
 8219b04:	10c00317 	ldw	r3,12(r2)
 8219b08:	e0bffa17 	ldw	r2,-24(fp)
 8219b0c:	10800217 	ldw	r2,8(r2)
 8219b10:	1880041e 	bne	r3,r2,8219b24 <OSQPostOpt+0x1cc>
            pq->OSQIn = pq->OSQStart;
 8219b14:	e0bffa17 	ldw	r2,-24(fp)
 8219b18:	10c00117 	ldw	r3,4(r2)
 8219b1c:	e0bffa17 	ldw	r2,-24(fp)
 8219b20:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 8219b24:	e0bffa17 	ldw	r2,-24(fp)
 8219b28:	1080058b 	ldhu	r2,22(r2)
 8219b2c:	10800044 	addi	r2,r2,1
 8219b30:	1007883a 	mov	r3,r2
 8219b34:	e0bffa17 	ldw	r2,-24(fp)
 8219b38:	10c0058d 	sth	r3,22(r2)
 8219b3c:	e0bff717 	ldw	r2,-36(fp)
 8219b40:	e0bffb15 	stw	r2,-20(fp)
 8219b44:	e0bffb17 	ldw	r2,-20(fp)
 8219b48:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 8219b4c:	0005883a 	mov	r2,zero
}
 8219b50:	e037883a 	mov	sp,fp
 8219b54:	dfc00117 	ldw	ra,4(sp)
 8219b58:	df000017 	ldw	fp,0(sp)
 8219b5c:	dec00204 	addi	sp,sp,8
 8219b60:	f800283a 	ret

08219b64 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
 8219b64:	defff604 	addi	sp,sp,-40
 8219b68:	df000915 	stw	fp,36(sp)
 8219b6c:	df000904 	addi	fp,sp,36
 8219b70:	e13ffe15 	stw	r4,-8(fp)
 8219b74:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 8219b78:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 8219b7c:	e0bffe17 	ldw	r2,-8(fp)
 8219b80:	1000021e 	bne	r2,zero,8219b8c <OSQQuery+0x28>
        return (OS_ERR_PEVENT_NULL);
 8219b84:	00800104 	movi	r2,4
 8219b88:	00004906 	br	8219cb0 <OSQQuery+0x14c>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
 8219b8c:	e0bfff17 	ldw	r2,-4(fp)
 8219b90:	1000021e 	bne	r2,zero,8219b9c <OSQQuery+0x38>
        return (OS_ERR_PDATA_NULL);
 8219b94:	00800244 	movi	r2,9
 8219b98:	00004506 	br	8219cb0 <OSQQuery+0x14c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 8219b9c:	e0bffe17 	ldw	r2,-8(fp)
 8219ba0:	10800003 	ldbu	r2,0(r2)
 8219ba4:	10803fcc 	andi	r2,r2,255
 8219ba8:	108000a0 	cmpeqi	r2,r2,2
 8219bac:	1000021e 	bne	r2,zero,8219bb8 <OSQQuery+0x54>
        return (OS_ERR_EVENT_TYPE);
 8219bb0:	00800044 	movi	r2,1
 8219bb4:	00003e06 	br	8219cb0 <OSQQuery+0x14c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219bb8:	0005303a 	rdctl	r2,status
 8219bbc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219bc0:	e0fffd17 	ldw	r3,-12(fp)
 8219bc4:	00bfff84 	movi	r2,-2
 8219bc8:	1884703a 	and	r2,r3,r2
 8219bcc:	1001703a 	wrctl	status,r2
  
  return context;
 8219bd0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 8219bd4:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
 8219bd8:	e0bffe17 	ldw	r2,-8(fp)
 8219bdc:	10c00283 	ldbu	r3,10(r2)
 8219be0:	e0bfff17 	ldw	r2,-4(fp)
 8219be4:	10c002c5 	stb	r3,11(r2)
    psrc                 = &pevent->OSEventTbl[0];
 8219be8:	e0bffe17 	ldw	r2,-8(fp)
 8219bec:	108002c4 	addi	r2,r2,11
 8219bf0:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
 8219bf4:	e0bfff17 	ldw	r2,-4(fp)
 8219bf8:	10800204 	addi	r2,r2,8
 8219bfc:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 8219c00:	e03ff705 	stb	zero,-36(fp)
 8219c04:	00000b06 	br	8219c34 <OSQQuery+0xd0>
        *pdest++ = *psrc++;
 8219c08:	e0bff917 	ldw	r2,-28(fp)
 8219c0c:	10c00044 	addi	r3,r2,1
 8219c10:	e0fff915 	stw	r3,-28(fp)
 8219c14:	e0fff817 	ldw	r3,-32(fp)
 8219c18:	19000044 	addi	r4,r3,1
 8219c1c:	e13ff815 	stw	r4,-32(fp)
 8219c20:	18c00003 	ldbu	r3,0(r3)
 8219c24:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 8219c28:	e0bff703 	ldbu	r2,-36(fp)
 8219c2c:	10800044 	addi	r2,r2,1
 8219c30:	e0bff705 	stb	r2,-36(fp)
 8219c34:	e0bff703 	ldbu	r2,-36(fp)
 8219c38:	108000f0 	cmpltui	r2,r2,3
 8219c3c:	103ff21e 	bne	r2,zero,8219c08 <OSQQuery+0xa4>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
 8219c40:	e0bffe17 	ldw	r2,-8(fp)
 8219c44:	10800117 	ldw	r2,4(r2)
 8219c48:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
 8219c4c:	e0bffc17 	ldw	r2,-16(fp)
 8219c50:	1080058b 	ldhu	r2,22(r2)
 8219c54:	10bfffcc 	andi	r2,r2,65535
 8219c58:	10000626 	beq	r2,zero,8219c74 <OSQQuery+0x110>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
 8219c5c:	e0bffc17 	ldw	r2,-16(fp)
 8219c60:	10800417 	ldw	r2,16(r2)
 8219c64:	10c00017 	ldw	r3,0(r2)
 8219c68:	e0bfff17 	ldw	r2,-4(fp)
 8219c6c:	10c00015 	stw	r3,0(r2)
 8219c70:	00000206 	br	8219c7c <OSQQuery+0x118>
    } else {
        p_q_data->OSMsg = (void *)0;
 8219c74:	e0bfff17 	ldw	r2,-4(fp)
 8219c78:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
 8219c7c:	e0bffc17 	ldw	r2,-16(fp)
 8219c80:	10c0058b 	ldhu	r3,22(r2)
 8219c84:	e0bfff17 	ldw	r2,-4(fp)
 8219c88:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
 8219c8c:	e0bffc17 	ldw	r2,-16(fp)
 8219c90:	10c0050b 	ldhu	r3,20(r2)
 8219c94:	e0bfff17 	ldw	r2,-4(fp)
 8219c98:	10c0018d 	sth	r3,6(r2)
 8219c9c:	e0bffa17 	ldw	r2,-24(fp)
 8219ca0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219ca4:	e0bffb17 	ldw	r2,-20(fp)
 8219ca8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 8219cac:	0005883a 	mov	r2,zero
}
 8219cb0:	e037883a 	mov	sp,fp
 8219cb4:	df000017 	ldw	fp,0(sp)
 8219cb8:	dec00104 	addi	sp,sp,4
 8219cbc:	f800283a 	ret

08219cc0 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
 8219cc0:	defffb04 	addi	sp,sp,-20
 8219cc4:	dfc00415 	stw	ra,16(sp)
 8219cc8:	df000315 	stw	fp,12(sp)
 8219ccc:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
 8219cd0:	01407804 	movi	r5,480
 8219cd4:	010209b4 	movhi	r4,2086
 8219cd8:	21303f04 	addi	r4,r4,-16132
 8219cdc:	82164c40 	call	82164c4 <OS_MemClr>
    pq1 = &OSQTbl[0];
 8219ce0:	008209b4 	movhi	r2,2086
 8219ce4:	10b03f04 	addi	r2,r2,-16132
 8219ce8:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
 8219cec:	008209b4 	movhi	r2,2086
 8219cf0:	10b04504 	addi	r2,r2,-16108
 8219cf4:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 8219cf8:	e03ffd0d 	sth	zero,-12(fp)
 8219cfc:	00000c06 	br	8219d30 <OS_QInit+0x70>
        pq1->OSQPtr = pq2;
 8219d00:	e0bffe17 	ldw	r2,-8(fp)
 8219d04:	e0ffff17 	ldw	r3,-4(fp)
 8219d08:	10c00015 	stw	r3,0(r2)
        pq1++;
 8219d0c:	e0bffe17 	ldw	r2,-8(fp)
 8219d10:	10800604 	addi	r2,r2,24
 8219d14:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
 8219d18:	e0bfff17 	ldw	r2,-4(fp)
 8219d1c:	10800604 	addi	r2,r2,24
 8219d20:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 8219d24:	e0bffd0b 	ldhu	r2,-12(fp)
 8219d28:	10800044 	addi	r2,r2,1
 8219d2c:	e0bffd0d 	sth	r2,-12(fp)
 8219d30:	e0bffd0b 	ldhu	r2,-12(fp)
 8219d34:	108004f0 	cmpltui	r2,r2,19
 8219d38:	103ff11e 	bne	r2,zero,8219d00 <OS_QInit+0x40>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
 8219d3c:	e0bffe17 	ldw	r2,-8(fp)
 8219d40:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
 8219d44:	008209b4 	movhi	r2,2086
 8219d48:	10b03f04 	addi	r2,r2,-16132
 8219d4c:	d0a07615 	stw	r2,-32296(gp)
#endif
}
 8219d50:	0001883a 	nop
 8219d54:	e037883a 	mov	sp,fp
 8219d58:	dfc00117 	ldw	ra,4(sp)
 8219d5c:	df000017 	ldw	fp,0(sp)
 8219d60:	dec00204 	addi	sp,sp,8
 8219d64:	f800283a 	ret

08219d68 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
 8219d68:	defffa04 	addi	sp,sp,-24
 8219d6c:	df000515 	stw	fp,20(sp)
 8219d70:	df000504 	addi	fp,sp,20
 8219d74:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 8219d78:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 8219d7c:	e0bfff17 	ldw	r2,-4(fp)
 8219d80:	1000021e 	bne	r2,zero,8219d8c <OSSemAccept+0x24>
        return (0);
 8219d84:	0005883a 	mov	r2,zero
 8219d88:	00001f06 	br	8219e08 <OSSemAccept+0xa0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 8219d8c:	e0bfff17 	ldw	r2,-4(fp)
 8219d90:	10800003 	ldbu	r2,0(r2)
 8219d94:	10803fcc 	andi	r2,r2,255
 8219d98:	108000e0 	cmpeqi	r2,r2,3
 8219d9c:	1000021e 	bne	r2,zero,8219da8 <OSSemAccept+0x40>
        return (0);
 8219da0:	0005883a 	mov	r2,zero
 8219da4:	00001806 	br	8219e08 <OSSemAccept+0xa0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219da8:	0005303a 	rdctl	r2,status
 8219dac:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219db0:	e0fffe17 	ldw	r3,-8(fp)
 8219db4:	00bfff84 	movi	r2,-2
 8219db8:	1884703a 	and	r2,r3,r2
 8219dbc:	1001703a 	wrctl	status,r2
  
  return context;
 8219dc0:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 8219dc4:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
 8219dc8:	e0bfff17 	ldw	r2,-4(fp)
 8219dcc:	1080020b 	ldhu	r2,8(r2)
 8219dd0:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
 8219dd4:	e0bffd0b 	ldhu	r2,-12(fp)
 8219dd8:	10000626 	beq	r2,zero,8219df4 <OSSemAccept+0x8c>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
 8219ddc:	e0bfff17 	ldw	r2,-4(fp)
 8219de0:	1080020b 	ldhu	r2,8(r2)
 8219de4:	10bfffc4 	addi	r2,r2,-1
 8219de8:	1007883a 	mov	r3,r2
 8219dec:	e0bfff17 	ldw	r2,-4(fp)
 8219df0:	10c0020d 	sth	r3,8(r2)
 8219df4:	e0bffb17 	ldw	r2,-20(fp)
 8219df8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219dfc:	e0bffc17 	ldw	r2,-16(fp)
 8219e00:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
 8219e04:	e0bffd0b 	ldhu	r2,-12(fp)
}
 8219e08:	e037883a 	mov	sp,fp
 8219e0c:	df000017 	ldw	fp,0(sp)
 8219e10:	dec00104 	addi	sp,sp,4
 8219e14:	f800283a 	ret

08219e18 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
 8219e18:	defff904 	addi	sp,sp,-28
 8219e1c:	dfc00615 	stw	ra,24(sp)
 8219e20:	df000515 	stw	fp,20(sp)
 8219e24:	df000504 	addi	fp,sp,20
 8219e28:	2005883a 	mov	r2,r4
 8219e2c:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 8219e30:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 8219e34:	d0a07903 	ldbu	r2,-32284(gp)
 8219e38:	10803fcc 	andi	r2,r2,255
 8219e3c:	10000226 	beq	r2,zero,8219e48 <OSSemCreate+0x30>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
 8219e40:	0005883a 	mov	r2,zero
 8219e44:	00002506 	br	8219edc <OSSemCreate+0xc4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219e48:	0005303a 	rdctl	r2,status
 8219e4c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219e50:	e0fffe17 	ldw	r3,-8(fp)
 8219e54:	00bfff84 	movi	r2,-2
 8219e58:	1884703a 	and	r2,r3,r2
 8219e5c:	1001703a 	wrctl	status,r2
  
  return context;
 8219e60:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 8219e64:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
 8219e68:	d0a07817 	ldw	r2,-32288(gp)
 8219e6c:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
 8219e70:	d0a07817 	ldw	r2,-32288(gp)
 8219e74:	10000326 	beq	r2,zero,8219e84 <OSSemCreate+0x6c>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 8219e78:	d0a07817 	ldw	r2,-32288(gp)
 8219e7c:	10800117 	ldw	r2,4(r2)
 8219e80:	d0a07815 	stw	r2,-32288(gp)
 8219e84:	e0bffb17 	ldw	r2,-20(fp)
 8219e88:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219e8c:	e0bffc17 	ldw	r2,-16(fp)
 8219e90:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
 8219e94:	e0bffd17 	ldw	r2,-12(fp)
 8219e98:	10000f26 	beq	r2,zero,8219ed8 <OSSemCreate+0xc0>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
 8219e9c:	e0bffd17 	ldw	r2,-12(fp)
 8219ea0:	00c000c4 	movi	r3,3
 8219ea4:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
 8219ea8:	e0bffd17 	ldw	r2,-12(fp)
 8219eac:	e0ffff0b 	ldhu	r3,-4(fp)
 8219eb0:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
 8219eb4:	e0bffd17 	ldw	r2,-12(fp)
 8219eb8:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
 8219ebc:	e0bffd17 	ldw	r2,-12(fp)
 8219ec0:	00c00fc4 	movi	r3,63
 8219ec4:	10c00385 	stb	r3,14(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
 8219ec8:	e0bffd17 	ldw	r2,-12(fp)
 8219ecc:	100003c5 	stb	zero,15(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
 8219ed0:	e13ffd17 	ldw	r4,-12(fp)
 8219ed4:	82160e40 	call	82160e4 <OS_EventWaitListInit>
    }
    return (pevent);
 8219ed8:	e0bffd17 	ldw	r2,-12(fp)
}
 8219edc:	e037883a 	mov	sp,fp
 8219ee0:	dfc00117 	ldw	ra,4(sp)
 8219ee4:	df000017 	ldw	fp,0(sp)
 8219ee8:	dec00204 	addi	sp,sp,8
 8219eec:	f800283a 	ret

08219ef0 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 8219ef0:	defff304 	addi	sp,sp,-52
 8219ef4:	dfc00c15 	stw	ra,48(sp)
 8219ef8:	df000b15 	stw	fp,44(sp)
 8219efc:	df000b04 	addi	fp,sp,44
 8219f00:	e13ffd15 	stw	r4,-12(fp)
 8219f04:	2805883a 	mov	r2,r5
 8219f08:	e1bfff15 	stw	r6,-4(fp)
 8219f0c:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 8219f10:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 8219f14:	e0bfff17 	ldw	r2,-4(fp)
 8219f18:	1000021e 	bne	r2,zero,8219f24 <OSSemDel+0x34>
        return (pevent);
 8219f1c:	e0bffd17 	ldw	r2,-12(fp)
 8219f20:	00007e06 	br	821a11c <OSSemDel+0x22c>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 8219f24:	e0bffd17 	ldw	r2,-12(fp)
 8219f28:	1000051e 	bne	r2,zero,8219f40 <OSSemDel+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 8219f2c:	e0bfff17 	ldw	r2,-4(fp)
 8219f30:	00c00104 	movi	r3,4
 8219f34:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8219f38:	e0bffd17 	ldw	r2,-12(fp)
 8219f3c:	00007706 	br	821a11c <OSSemDel+0x22c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 8219f40:	e0bffd17 	ldw	r2,-12(fp)
 8219f44:	10800003 	ldbu	r2,0(r2)
 8219f48:	10803fcc 	andi	r2,r2,255
 8219f4c:	108000e0 	cmpeqi	r2,r2,3
 8219f50:	1000051e 	bne	r2,zero,8219f68 <OSSemDel+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 8219f54:	e0bfff17 	ldw	r2,-4(fp)
 8219f58:	00c00044 	movi	r3,1
 8219f5c:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8219f60:	e0bffd17 	ldw	r2,-12(fp)
 8219f64:	00006d06 	br	821a11c <OSSemDel+0x22c>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 8219f68:	d0a07903 	ldbu	r2,-32284(gp)
 8219f6c:	10803fcc 	andi	r2,r2,255
 8219f70:	10000526 	beq	r2,zero,8219f88 <OSSemDel+0x98>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
 8219f74:	e0bfff17 	ldw	r2,-4(fp)
 8219f78:	00c003c4 	movi	r3,15
 8219f7c:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8219f80:	e0bffd17 	ldw	r2,-12(fp)
 8219f84:	00006506 	br	821a11c <OSSemDel+0x22c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219f88:	0005303a 	rdctl	r2,status
 8219f8c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219f90:	e0fffc17 	ldw	r3,-16(fp)
 8219f94:	00bfff84 	movi	r2,-2
 8219f98:	1884703a 	and	r2,r3,r2
 8219f9c:	1001703a 	wrctl	status,r2
  
  return context;
 8219fa0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8219fa4:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
 8219fa8:	e0bffd17 	ldw	r2,-12(fp)
 8219fac:	10800283 	ldbu	r2,10(r2)
 8219fb0:	10803fcc 	andi	r2,r2,255
 8219fb4:	10000326 	beq	r2,zero,8219fc4 <OSSemDel+0xd4>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 8219fb8:	00800044 	movi	r2,1
 8219fbc:	e0bff505 	stb	r2,-44(fp)
 8219fc0:	00000106 	br	8219fc8 <OSSemDel+0xd8>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 8219fc4:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
 8219fc8:	e0bffe03 	ldbu	r2,-8(fp)
 8219fcc:	10000326 	beq	r2,zero,8219fdc <OSSemDel+0xec>
 8219fd0:	10800060 	cmpeqi	r2,r2,1
 8219fd4:	1000281e 	bne	r2,zero,821a078 <OSSemDel+0x188>
 8219fd8:	00004506 	br	821a0f0 <OSSemDel+0x200>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
 8219fdc:	e0bff503 	ldbu	r2,-44(fp)
 8219fe0:	1000161e 	bne	r2,zero,821a03c <OSSemDel+0x14c>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 8219fe4:	e0bffd17 	ldw	r2,-12(fp)
 8219fe8:	00c00fc4 	movi	r3,63
 8219fec:	10c00385 	stb	r3,14(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 8219ff0:	e0bffd17 	ldw	r2,-12(fp)
 8219ff4:	100003c5 	stb	zero,15(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 8219ff8:	e0bffd17 	ldw	r2,-12(fp)
 8219ffc:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 821a000:	d0e07817 	ldw	r3,-32288(gp)
 821a004:	e0bffd17 	ldw	r2,-12(fp)
 821a008:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 821a00c:	e0bffd17 	ldw	r2,-12(fp)
 821a010:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 821a014:	e0bffd17 	ldw	r2,-12(fp)
 821a018:	d0a07815 	stw	r2,-32288(gp)
 821a01c:	e0bff717 	ldw	r2,-36(fp)
 821a020:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a024:	e0bff817 	ldw	r2,-32(fp)
 821a028:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 821a02c:	e0bfff17 	ldw	r2,-4(fp)
 821a030:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
 821a034:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
 821a038:	00003706 	br	821a118 <OSSemDel+0x228>
 821a03c:	e0bff717 	ldw	r2,-36(fp)
 821a040:	e0bff915 	stw	r2,-28(fp)
 821a044:	e0bff917 	ldw	r2,-28(fp)
 821a048:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 821a04c:	e0bfff17 	ldw	r2,-4(fp)
 821a050:	00c01244 	movi	r3,73
 821a054:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
 821a058:	e0bffd17 	ldw	r2,-12(fp)
 821a05c:	e0bff615 	stw	r2,-40(fp)
             }
             break;
 821a060:	00002d06 	br	821a118 <OSSemDel+0x228>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 821a064:	000f883a 	mov	r7,zero
 821a068:	01800044 	movi	r6,1
 821a06c:	000b883a 	mov	r5,zero
 821a070:	e13ffd17 	ldw	r4,-12(fp)
 821a074:	8215b340 	call	8215b34 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
 821a078:	e0bffd17 	ldw	r2,-12(fp)
 821a07c:	10800283 	ldbu	r2,10(r2)
 821a080:	10803fcc 	andi	r2,r2,255
 821a084:	103ff71e 	bne	r2,zero,821a064 <OSSemDel+0x174>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 821a088:	e0bffd17 	ldw	r2,-12(fp)
 821a08c:	00c00fc4 	movi	r3,63
 821a090:	10c00385 	stb	r3,14(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 821a094:	e0bffd17 	ldw	r2,-12(fp)
 821a098:	100003c5 	stb	zero,15(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 821a09c:	e0bffd17 	ldw	r2,-12(fp)
 821a0a0:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 821a0a4:	d0e07817 	ldw	r3,-32288(gp)
 821a0a8:	e0bffd17 	ldw	r2,-12(fp)
 821a0ac:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 821a0b0:	e0bffd17 	ldw	r2,-12(fp)
 821a0b4:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 821a0b8:	e0bffd17 	ldw	r2,-12(fp)
 821a0bc:	d0a07815 	stw	r2,-32288(gp)
 821a0c0:	e0bff717 	ldw	r2,-36(fp)
 821a0c4:	e0bffa15 	stw	r2,-24(fp)
 821a0c8:	e0bffa17 	ldw	r2,-24(fp)
 821a0cc:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 821a0d0:	e0bff503 	ldbu	r2,-44(fp)
 821a0d4:	10800058 	cmpnei	r2,r2,1
 821a0d8:	1000011e 	bne	r2,zero,821a0e0 <OSSemDel+0x1f0>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 821a0dc:	82165800 	call	8216580 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 821a0e0:	e0bfff17 	ldw	r2,-4(fp)
 821a0e4:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
 821a0e8:	e03ff615 	stw	zero,-40(fp)
             break;
 821a0ec:	00000a06 	br	821a118 <OSSemDel+0x228>
 821a0f0:	e0bff717 	ldw	r2,-36(fp)
 821a0f4:	e0bffb15 	stw	r2,-20(fp)
 821a0f8:	e0bffb17 	ldw	r2,-20(fp)
 821a0fc:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 821a100:	e0bfff17 	ldw	r2,-4(fp)
 821a104:	00c001c4 	movi	r3,7
 821a108:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
 821a10c:	e0bffd17 	ldw	r2,-12(fp)
 821a110:	e0bff615 	stw	r2,-40(fp)
             break;
 821a114:	0001883a 	nop
    }
    return (pevent_return);
 821a118:	e0bff617 	ldw	r2,-40(fp)
}
 821a11c:	e037883a 	mov	sp,fp
 821a120:	dfc00117 	ldw	ra,4(sp)
 821a124:	df000017 	ldw	fp,0(sp)
 821a128:	dec00204 	addi	sp,sp,8
 821a12c:	f800283a 	ret

0821a130 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 821a130:	defff504 	addi	sp,sp,-44
 821a134:	dfc00a15 	stw	ra,40(sp)
 821a138:	df000915 	stw	fp,36(sp)
 821a13c:	df000904 	addi	fp,sp,36
 821a140:	e13ffd15 	stw	r4,-12(fp)
 821a144:	2805883a 	mov	r2,r5
 821a148:	e1bfff15 	stw	r6,-4(fp)
 821a14c:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821a150:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 821a154:	e0bfff17 	ldw	r2,-4(fp)
 821a158:	10007226 	beq	r2,zero,821a324 <OSSemPend+0x1f4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 821a15c:	e0bffd17 	ldw	r2,-12(fp)
 821a160:	1000041e 	bne	r2,zero,821a174 <OSSemPend+0x44>
        *perr = OS_ERR_PEVENT_NULL;
 821a164:	e0bfff17 	ldw	r2,-4(fp)
 821a168:	00c00104 	movi	r3,4
 821a16c:	10c00005 	stb	r3,0(r2)
        return;
 821a170:	00006d06 	br	821a328 <OSSemPend+0x1f8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 821a174:	e0bffd17 	ldw	r2,-12(fp)
 821a178:	10800003 	ldbu	r2,0(r2)
 821a17c:	10803fcc 	andi	r2,r2,255
 821a180:	108000e0 	cmpeqi	r2,r2,3
 821a184:	1000041e 	bne	r2,zero,821a198 <OSSemPend+0x68>
        *perr = OS_ERR_EVENT_TYPE;
 821a188:	e0bfff17 	ldw	r2,-4(fp)
 821a18c:	00c00044 	movi	r3,1
 821a190:	10c00005 	stb	r3,0(r2)
        return;
 821a194:	00006406 	br	821a328 <OSSemPend+0x1f8>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
 821a198:	d0a07903 	ldbu	r2,-32284(gp)
 821a19c:	10803fcc 	andi	r2,r2,255
 821a1a0:	10000426 	beq	r2,zero,821a1b4 <OSSemPend+0x84>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
 821a1a4:	e0bfff17 	ldw	r2,-4(fp)
 821a1a8:	00c00084 	movi	r3,2
 821a1ac:	10c00005 	stb	r3,0(r2)
        return;
 821a1b0:	00005d06 	br	821a328 <OSSemPend+0x1f8>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
 821a1b4:	d0a06b03 	ldbu	r2,-32340(gp)
 821a1b8:	10803fcc 	andi	r2,r2,255
 821a1bc:	10000426 	beq	r2,zero,821a1d0 <OSSemPend+0xa0>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
 821a1c0:	e0bfff17 	ldw	r2,-4(fp)
 821a1c4:	00c00344 	movi	r3,13
 821a1c8:	10c00005 	stb	r3,0(r2)
        return;
 821a1cc:	00005606 	br	821a328 <OSSemPend+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a1d0:	0005303a 	rdctl	r2,status
 821a1d4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a1d8:	e0fffc17 	ldw	r3,-16(fp)
 821a1dc:	00bfff84 	movi	r2,-2
 821a1e0:	1884703a 	and	r2,r3,r2
 821a1e4:	1001703a 	wrctl	status,r2
  
  return context;
 821a1e8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821a1ec:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
 821a1f0:	e0bffd17 	ldw	r2,-12(fp)
 821a1f4:	1080020b 	ldhu	r2,8(r2)
 821a1f8:	10bfffcc 	andi	r2,r2,65535
 821a1fc:	10000d26 	beq	r2,zero,821a234 <OSSemPend+0x104>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
 821a200:	e0bffd17 	ldw	r2,-12(fp)
 821a204:	1080020b 	ldhu	r2,8(r2)
 821a208:	10bfffc4 	addi	r2,r2,-1
 821a20c:	1007883a 	mov	r3,r2
 821a210:	e0bffd17 	ldw	r2,-12(fp)
 821a214:	10c0020d 	sth	r3,8(r2)
 821a218:	e0bff717 	ldw	r2,-36(fp)
 821a21c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a220:	e0bff817 	ldw	r2,-32(fp)
 821a224:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 821a228:	e0bfff17 	ldw	r2,-4(fp)
 821a22c:	10000005 	stb	zero,0(r2)
        return;
 821a230:	00003d06 	br	821a328 <OSSemPend+0x1f8>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
 821a234:	d0a07a17 	ldw	r2,-32280(gp)
 821a238:	d0e07a17 	ldw	r3,-32280(gp)
 821a23c:	18c00c03 	ldbu	r3,48(r3)
 821a240:	18c00054 	ori	r3,r3,1
 821a244:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 821a248:	d0a07a17 	ldw	r2,-32280(gp)
 821a24c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
 821a250:	d0a07a17 	ldw	r2,-32280(gp)
 821a254:	e0fffe0b 	ldhu	r3,-8(fp)
 821a258:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
 821a25c:	e13ffd17 	ldw	r4,-12(fp)
 821a260:	8215ccc0 	call	8215ccc <OS_EventTaskWait>
 821a264:	e0bff717 	ldw	r2,-36(fp)
 821a268:	e0bffb15 	stw	r2,-20(fp)
 821a26c:	e0bffb17 	ldw	r2,-20(fp)
 821a270:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
 821a274:	82165800 	call	8216580 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a278:	0005303a 	rdctl	r2,status
 821a27c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a280:	e0fff917 	ldw	r3,-28(fp)
 821a284:	00bfff84 	movi	r2,-2
 821a288:	1884703a 	and	r2,r3,r2
 821a28c:	1001703a 	wrctl	status,r2
  
  return context;
 821a290:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
 821a294:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 821a298:	d0a07a17 	ldw	r2,-32280(gp)
 821a29c:	10800c43 	ldbu	r2,49(r2)
 821a2a0:	10803fcc 	andi	r2,r2,255
 821a2a4:	10000326 	beq	r2,zero,821a2b4 <OSSemPend+0x184>
 821a2a8:	108000a0 	cmpeqi	r2,r2,2
 821a2ac:	1000041e 	bne	r2,zero,821a2c0 <OSSemPend+0x190>
 821a2b0:	00000706 	br	821a2d0 <OSSemPend+0x1a0>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
 821a2b4:	e0bfff17 	ldw	r2,-4(fp)
 821a2b8:	10000005 	stb	zero,0(r2)
             break;
 821a2bc:	00000c06 	br	821a2f0 <OSSemPend+0x1c0>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 821a2c0:	e0bfff17 	ldw	r2,-4(fp)
 821a2c4:	00c00384 	movi	r3,14
 821a2c8:	10c00005 	stb	r3,0(r2)
             break;
 821a2cc:	00000806 	br	821a2f0 <OSSemPend+0x1c0>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
 821a2d0:	d0a07a17 	ldw	r2,-32280(gp)
 821a2d4:	e17ffd17 	ldw	r5,-12(fp)
 821a2d8:	1009883a 	mov	r4,r2
 821a2dc:	8215f2c0 	call	8215f2c <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 821a2e0:	e0bfff17 	ldw	r2,-4(fp)
 821a2e4:	00c00284 	movi	r3,10
 821a2e8:	10c00005 	stb	r3,0(r2)
             break;
 821a2ec:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 821a2f0:	d0a07a17 	ldw	r2,-32280(gp)
 821a2f4:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 821a2f8:	d0a07a17 	ldw	r2,-32280(gp)
 821a2fc:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 821a300:	d0a07a17 	ldw	r2,-32280(gp)
 821a304:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 821a308:	d0a07a17 	ldw	r2,-32280(gp)
 821a30c:	10000815 	stw	zero,32(r2)
 821a310:	e0bff717 	ldw	r2,-36(fp)
 821a314:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a318:	e0bffa17 	ldw	r2,-24(fp)
 821a31c:	1001703a 	wrctl	status,r2
 821a320:	00000106 	br	821a328 <OSSemPend+0x1f8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
 821a324:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
 821a328:	e037883a 	mov	sp,fp
 821a32c:	dfc00117 	ldw	ra,4(sp)
 821a330:	df000017 	ldw	fp,0(sp)
 821a334:	dec00204 	addi	sp,sp,8
 821a338:	f800283a 	ret

0821a33c <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 821a33c:	defff604 	addi	sp,sp,-40
 821a340:	dfc00915 	stw	ra,36(sp)
 821a344:	df000815 	stw	fp,32(sp)
 821a348:	df000804 	addi	fp,sp,32
 821a34c:	e13ffd15 	stw	r4,-12(fp)
 821a350:	2805883a 	mov	r2,r5
 821a354:	e1bfff15 	stw	r6,-4(fp)
 821a358:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821a35c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 821a360:	e0bfff17 	ldw	r2,-4(fp)
 821a364:	1000021e 	bne	r2,zero,821a370 <OSSemPendAbort+0x34>
        return (0);
 821a368:	0005883a 	mov	r2,zero
 821a36c:	00004906 	br	821a494 <OSSemPendAbort+0x158>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 821a370:	e0bffd17 	ldw	r2,-12(fp)
 821a374:	1000051e 	bne	r2,zero,821a38c <OSSemPendAbort+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 821a378:	e0bfff17 	ldw	r2,-4(fp)
 821a37c:	00c00104 	movi	r3,4
 821a380:	10c00005 	stb	r3,0(r2)
        return (0);
 821a384:	0005883a 	mov	r2,zero
 821a388:	00004206 	br	821a494 <OSSemPendAbort+0x158>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 821a38c:	e0bffd17 	ldw	r2,-12(fp)
 821a390:	10800003 	ldbu	r2,0(r2)
 821a394:	10803fcc 	andi	r2,r2,255
 821a398:	108000e0 	cmpeqi	r2,r2,3
 821a39c:	1000051e 	bne	r2,zero,821a3b4 <OSSemPendAbort+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 821a3a0:	e0bfff17 	ldw	r2,-4(fp)
 821a3a4:	00c00044 	movi	r3,1
 821a3a8:	10c00005 	stb	r3,0(r2)
        return (0);
 821a3ac:	0005883a 	mov	r2,zero
 821a3b0:	00003806 	br	821a494 <OSSemPendAbort+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a3b4:	0005303a 	rdctl	r2,status
 821a3b8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a3bc:	e0fffc17 	ldw	r3,-16(fp)
 821a3c0:	00bfff84 	movi	r2,-2
 821a3c4:	1884703a 	and	r2,r3,r2
 821a3c8:	1001703a 	wrctl	status,r2
  
  return context;
 821a3cc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821a3d0:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
 821a3d4:	e0bffd17 	ldw	r2,-12(fp)
 821a3d8:	10800283 	ldbu	r2,10(r2)
 821a3dc:	10803fcc 	andi	r2,r2,255
 821a3e0:	10002526 	beq	r2,zero,821a478 <OSSemPendAbort+0x13c>
        nbr_tasks = 0;
 821a3e4:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
 821a3e8:	e0bffe03 	ldbu	r2,-8(fp)
 821a3ec:	10800060 	cmpeqi	r2,r2,1
 821a3f0:	10000e26 	beq	r2,zero,821a42c <OSSemPendAbort+0xf0>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
 821a3f4:	00000806 	br	821a418 <OSSemPendAbort+0xdc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 821a3f8:	01c00084 	movi	r7,2
 821a3fc:	01800044 	movi	r6,1
 821a400:	000b883a 	mov	r5,zero
 821a404:	e13ffd17 	ldw	r4,-12(fp)
 821a408:	8215b340 	call	8215b34 <OS_EventTaskRdy>
                     nbr_tasks++;
 821a40c:	e0bff803 	ldbu	r2,-32(fp)
 821a410:	10800044 	addi	r2,r2,1
 821a414:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
 821a418:	e0bffd17 	ldw	r2,-12(fp)
 821a41c:	10800283 	ldbu	r2,10(r2)
 821a420:	10803fcc 	andi	r2,r2,255
 821a424:	103ff41e 	bne	r2,zero,821a3f8 <OSSemPendAbort+0xbc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 821a428:	00000906 	br	821a450 <OSSemPendAbort+0x114>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 821a42c:	01c00084 	movi	r7,2
 821a430:	01800044 	movi	r6,1
 821a434:	000b883a 	mov	r5,zero
 821a438:	e13ffd17 	ldw	r4,-12(fp)
 821a43c:	8215b340 	call	8215b34 <OS_EventTaskRdy>
                 nbr_tasks++;
 821a440:	e0bff803 	ldbu	r2,-32(fp)
 821a444:	10800044 	addi	r2,r2,1
 821a448:	e0bff805 	stb	r2,-32(fp)
                 break;
 821a44c:	0001883a 	nop
 821a450:	e0bff917 	ldw	r2,-28(fp)
 821a454:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a458:	e0bffa17 	ldw	r2,-24(fp)
 821a45c:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 821a460:	82165800 	call	8216580 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 821a464:	e0bfff17 	ldw	r2,-4(fp)
 821a468:	00c00384 	movi	r3,14
 821a46c:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
 821a470:	e0bff803 	ldbu	r2,-32(fp)
 821a474:	00000706 	br	821a494 <OSSemPendAbort+0x158>
 821a478:	e0bff917 	ldw	r2,-28(fp)
 821a47c:	e0bffb15 	stw	r2,-20(fp)
 821a480:	e0bffb17 	ldw	r2,-20(fp)
 821a484:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 821a488:	e0bfff17 	ldw	r2,-4(fp)
 821a48c:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
 821a490:	0005883a 	mov	r2,zero
}
 821a494:	e037883a 	mov	sp,fp
 821a498:	dfc00117 	ldw	ra,4(sp)
 821a49c:	df000017 	ldw	fp,0(sp)
 821a4a0:	dec00204 	addi	sp,sp,8
 821a4a4:	f800283a 	ret

0821a4a8 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
 821a4a8:	defff804 	addi	sp,sp,-32
 821a4ac:	dfc00715 	stw	ra,28(sp)
 821a4b0:	df000615 	stw	fp,24(sp)
 821a4b4:	df000604 	addi	fp,sp,24
 821a4b8:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821a4bc:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 821a4c0:	e0bfff17 	ldw	r2,-4(fp)
 821a4c4:	1000021e 	bne	r2,zero,821a4d0 <OSSemPost+0x28>
        return (OS_ERR_PEVENT_NULL);
 821a4c8:	00800104 	movi	r2,4
 821a4cc:	00003506 	br	821a5a4 <OSSemPost+0xfc>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 821a4d0:	e0bfff17 	ldw	r2,-4(fp)
 821a4d4:	10800003 	ldbu	r2,0(r2)
 821a4d8:	10803fcc 	andi	r2,r2,255
 821a4dc:	108000e0 	cmpeqi	r2,r2,3
 821a4e0:	1000021e 	bne	r2,zero,821a4ec <OSSemPost+0x44>
        return (OS_ERR_EVENT_TYPE);
 821a4e4:	00800044 	movi	r2,1
 821a4e8:	00002e06 	br	821a5a4 <OSSemPost+0xfc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a4ec:	0005303a 	rdctl	r2,status
 821a4f0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a4f4:	e0fffe17 	ldw	r3,-8(fp)
 821a4f8:	00bfff84 	movi	r2,-2
 821a4fc:	1884703a 	and	r2,r3,r2
 821a500:	1001703a 	wrctl	status,r2
  
  return context;
 821a504:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 821a508:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
 821a50c:	e0bfff17 	ldw	r2,-4(fp)
 821a510:	10800283 	ldbu	r2,10(r2)
 821a514:	10803fcc 	andi	r2,r2,255
 821a518:	10000c26 	beq	r2,zero,821a54c <OSSemPost+0xa4>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 821a51c:	000f883a 	mov	r7,zero
 821a520:	01800044 	movi	r6,1
 821a524:	000b883a 	mov	r5,zero
 821a528:	e13fff17 	ldw	r4,-4(fp)
 821a52c:	8215b340 	call	8215b34 <OS_EventTaskRdy>
 821a530:	e0bffa17 	ldw	r2,-24(fp)
 821a534:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a538:	e0bffb17 	ldw	r2,-20(fp)
 821a53c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 821a540:	82165800 	call	8216580 <OS_Sched>
        return (OS_ERR_NONE);
 821a544:	0005883a 	mov	r2,zero
 821a548:	00001606 	br	821a5a4 <OSSemPost+0xfc>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
 821a54c:	e0bfff17 	ldw	r2,-4(fp)
 821a550:	1080020b 	ldhu	r2,8(r2)
 821a554:	10ffffcc 	andi	r3,r2,65535
 821a558:	00bfffd4 	movui	r2,65535
 821a55c:	18800c26 	beq	r3,r2,821a590 <OSSemPost+0xe8>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
 821a560:	e0bfff17 	ldw	r2,-4(fp)
 821a564:	1080020b 	ldhu	r2,8(r2)
 821a568:	10800044 	addi	r2,r2,1
 821a56c:	1007883a 	mov	r3,r2
 821a570:	e0bfff17 	ldw	r2,-4(fp)
 821a574:	10c0020d 	sth	r3,8(r2)
 821a578:	e0bffa17 	ldw	r2,-24(fp)
 821a57c:	e0bffc15 	stw	r2,-16(fp)
 821a580:	e0bffc17 	ldw	r2,-16(fp)
 821a584:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 821a588:	0005883a 	mov	r2,zero
 821a58c:	00000506 	br	821a5a4 <OSSemPost+0xfc>
 821a590:	e0bffa17 	ldw	r2,-24(fp)
 821a594:	e0bffd15 	stw	r2,-12(fp)
 821a598:	e0bffd17 	ldw	r2,-12(fp)
 821a59c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
 821a5a0:	00800c84 	movi	r2,50
}
 821a5a4:	e037883a 	mov	sp,fp
 821a5a8:	dfc00117 	ldw	ra,4(sp)
 821a5ac:	df000017 	ldw	fp,0(sp)
 821a5b0:	dec00204 	addi	sp,sp,8
 821a5b4:	f800283a 	ret

0821a5b8 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
 821a5b8:	defff704 	addi	sp,sp,-36
 821a5bc:	df000815 	stw	fp,32(sp)
 821a5c0:	df000804 	addi	fp,sp,32
 821a5c4:	e13ffe15 	stw	r4,-8(fp)
 821a5c8:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 821a5cc:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 821a5d0:	e0bffe17 	ldw	r2,-8(fp)
 821a5d4:	1000021e 	bne	r2,zero,821a5e0 <OSSemQuery+0x28>
        return (OS_ERR_PEVENT_NULL);
 821a5d8:	00800104 	movi	r2,4
 821a5dc:	00003606 	br	821a6b8 <OSSemQuery+0x100>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
 821a5e0:	e0bfff17 	ldw	r2,-4(fp)
 821a5e4:	1000021e 	bne	r2,zero,821a5f0 <OSSemQuery+0x38>
        return (OS_ERR_PDATA_NULL);
 821a5e8:	00800244 	movi	r2,9
 821a5ec:	00003206 	br	821a6b8 <OSSemQuery+0x100>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 821a5f0:	e0bffe17 	ldw	r2,-8(fp)
 821a5f4:	10800003 	ldbu	r2,0(r2)
 821a5f8:	10803fcc 	andi	r2,r2,255
 821a5fc:	108000e0 	cmpeqi	r2,r2,3
 821a600:	1000021e 	bne	r2,zero,821a60c <OSSemQuery+0x54>
        return (OS_ERR_EVENT_TYPE);
 821a604:	00800044 	movi	r2,1
 821a608:	00002b06 	br	821a6b8 <OSSemQuery+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a60c:	0005303a 	rdctl	r2,status
 821a610:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a614:	e0fffd17 	ldw	r3,-12(fp)
 821a618:	00bfff84 	movi	r2,-2
 821a61c:	1884703a 	and	r2,r3,r2
 821a620:	1001703a 	wrctl	status,r2
  
  return context;
 821a624:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 821a628:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
 821a62c:	e0bffe17 	ldw	r2,-8(fp)
 821a630:	10c00283 	ldbu	r3,10(r2)
 821a634:	e0bfff17 	ldw	r2,-4(fp)
 821a638:	10c00145 	stb	r3,5(r2)
    psrc                   = &pevent->OSEventTbl[0];
 821a63c:	e0bffe17 	ldw	r2,-8(fp)
 821a640:	108002c4 	addi	r2,r2,11
 821a644:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
 821a648:	e0bfff17 	ldw	r2,-4(fp)
 821a64c:	10800084 	addi	r2,r2,2
 821a650:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 821a654:	e03ffa05 	stb	zero,-24(fp)
 821a658:	00000b06 	br	821a688 <OSSemQuery+0xd0>
        *pdest++ = *psrc++;
 821a65c:	e0bff917 	ldw	r2,-28(fp)
 821a660:	10c00044 	addi	r3,r2,1
 821a664:	e0fff915 	stw	r3,-28(fp)
 821a668:	e0fff817 	ldw	r3,-32(fp)
 821a66c:	19000044 	addi	r4,r3,1
 821a670:	e13ff815 	stw	r4,-32(fp)
 821a674:	18c00003 	ldbu	r3,0(r3)
 821a678:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 821a67c:	e0bffa03 	ldbu	r2,-24(fp)
 821a680:	10800044 	addi	r2,r2,1
 821a684:	e0bffa05 	stb	r2,-24(fp)
 821a688:	e0bffa03 	ldbu	r2,-24(fp)
 821a68c:	108000f0 	cmpltui	r2,r2,3
 821a690:	103ff21e 	bne	r2,zero,821a65c <OSSemQuery+0xa4>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
 821a694:	e0bffe17 	ldw	r2,-8(fp)
 821a698:	10c0020b 	ldhu	r3,8(r2)
 821a69c:	e0bfff17 	ldw	r2,-4(fp)
 821a6a0:	10c0000d 	sth	r3,0(r2)
 821a6a4:	e0bffb17 	ldw	r2,-20(fp)
 821a6a8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a6ac:	e0bffc17 	ldw	r2,-16(fp)
 821a6b0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 821a6b4:	0005883a 	mov	r2,zero
}
 821a6b8:	e037883a 	mov	sp,fp
 821a6bc:	df000017 	ldw	fp,0(sp)
 821a6c0:	dec00104 	addi	sp,sp,4
 821a6c4:	f800283a 	ret

0821a6c8 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
 821a6c8:	defff904 	addi	sp,sp,-28
 821a6cc:	df000615 	stw	fp,24(sp)
 821a6d0:	df000604 	addi	fp,sp,24
 821a6d4:	e13ffd15 	stw	r4,-12(fp)
 821a6d8:	2805883a 	mov	r2,r5
 821a6dc:	e1bfff15 	stw	r6,-4(fp)
 821a6e0:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821a6e4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 821a6e8:	e0bfff17 	ldw	r2,-4(fp)
 821a6ec:	10003126 	beq	r2,zero,821a7b4 <OSSemSet+0xec>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 821a6f0:	e0bffd17 	ldw	r2,-12(fp)
 821a6f4:	1000041e 	bne	r2,zero,821a708 <OSSemSet+0x40>
        *perr = OS_ERR_PEVENT_NULL;
 821a6f8:	e0bfff17 	ldw	r2,-4(fp)
 821a6fc:	00c00104 	movi	r3,4
 821a700:	10c00005 	stb	r3,0(r2)
        return;
 821a704:	00002c06 	br	821a7b8 <OSSemSet+0xf0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 821a708:	e0bffd17 	ldw	r2,-12(fp)
 821a70c:	10800003 	ldbu	r2,0(r2)
 821a710:	10803fcc 	andi	r2,r2,255
 821a714:	108000e0 	cmpeqi	r2,r2,3
 821a718:	1000041e 	bne	r2,zero,821a72c <OSSemSet+0x64>
        *perr = OS_ERR_EVENT_TYPE;
 821a71c:	e0bfff17 	ldw	r2,-4(fp)
 821a720:	00c00044 	movi	r3,1
 821a724:	10c00005 	stb	r3,0(r2)
        return;
 821a728:	00002306 	br	821a7b8 <OSSemSet+0xf0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a72c:	0005303a 	rdctl	r2,status
 821a730:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a734:	e0fffc17 	ldw	r3,-16(fp)
 821a738:	00bfff84 	movi	r2,-2
 821a73c:	1884703a 	and	r2,r3,r2
 821a740:	1001703a 	wrctl	status,r2
  
  return context;
 821a744:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821a748:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
 821a74c:	e0bfff17 	ldw	r2,-4(fp)
 821a750:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
 821a754:	e0bffd17 	ldw	r2,-12(fp)
 821a758:	1080020b 	ldhu	r2,8(r2)
 821a75c:	10bfffcc 	andi	r2,r2,65535
 821a760:	10000426 	beq	r2,zero,821a774 <OSSemSet+0xac>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
 821a764:	e0bffd17 	ldw	r2,-12(fp)
 821a768:	e0fffe0b 	ldhu	r3,-8(fp)
 821a76c:	10c0020d 	sth	r3,8(r2)
 821a770:	00000b06 	br	821a7a0 <OSSemSet+0xd8>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
 821a774:	e0bffd17 	ldw	r2,-12(fp)
 821a778:	10800283 	ldbu	r2,10(r2)
 821a77c:	10803fcc 	andi	r2,r2,255
 821a780:	1000041e 	bne	r2,zero,821a794 <OSSemSet+0xcc>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
 821a784:	e0bffd17 	ldw	r2,-12(fp)
 821a788:	e0fffe0b 	ldhu	r3,-8(fp)
 821a78c:	10c0020d 	sth	r3,8(r2)
 821a790:	00000306 	br	821a7a0 <OSSemSet+0xd8>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
 821a794:	e0bfff17 	ldw	r2,-4(fp)
 821a798:	00c01244 	movi	r3,73
 821a79c:	10c00005 	stb	r3,0(r2)
 821a7a0:	e0bffa17 	ldw	r2,-24(fp)
 821a7a4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a7a8:	e0bffb17 	ldw	r2,-20(fp)
 821a7ac:	1001703a 	wrctl	status,r2
 821a7b0:	00000106 	br	821a7b8 <OSSemSet+0xf0>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
 821a7b4:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
 821a7b8:	e037883a 	mov	sp,fp
 821a7bc:	df000017 	ldw	fp,0(sp)
 821a7c0:	dec00104 	addi	sp,sp,4
 821a7c4:	f800283a 	ret

0821a7c8 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
 821a7c8:	defff104 	addi	sp,sp,-60
 821a7cc:	dfc00e15 	stw	ra,56(sp)
 821a7d0:	df000d15 	stw	fp,52(sp)
 821a7d4:	df000d04 	addi	fp,sp,52
 821a7d8:	2007883a 	mov	r3,r4
 821a7dc:	2805883a 	mov	r2,r5
 821a7e0:	e0fffe05 	stb	r3,-8(fp)
 821a7e4:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
 821a7e8:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
 821a7ec:	e0bffe03 	ldbu	r2,-8(fp)
 821a7f0:	10800530 	cmpltui	r2,r2,20
 821a7f4:	1000051e 	bne	r2,zero,821a80c <OSTaskChangePrio+0x44>
        if (oldprio != OS_PRIO_SELF) {
 821a7f8:	e0bffe03 	ldbu	r2,-8(fp)
 821a7fc:	10803fe0 	cmpeqi	r2,r2,255
 821a800:	1000021e 	bne	r2,zero,821a80c <OSTaskChangePrio+0x44>
            return (OS_ERR_PRIO_INVALID);
 821a804:	00800a84 	movi	r2,42
 821a808:	00012606 	br	821aca4 <OSTaskChangePrio+0x4dc>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
 821a80c:	e0bfff03 	ldbu	r2,-4(fp)
 821a810:	10800530 	cmpltui	r2,r2,20
 821a814:	1000021e 	bne	r2,zero,821a820 <OSTaskChangePrio+0x58>
        return (OS_ERR_PRIO_INVALID);
 821a818:	00800a84 	movi	r2,42
 821a81c:	00012106 	br	821aca4 <OSTaskChangePrio+0x4dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a820:	0005303a 	rdctl	r2,status
 821a824:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a828:	e0fffd17 	ldw	r3,-12(fp)
 821a82c:	00bfff84 	movi	r2,-2
 821a830:	1884703a 	and	r2,r3,r2
 821a834:	1001703a 	wrctl	status,r2
  
  return context;
 821a838:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821a83c:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
 821a840:	e0ffff03 	ldbu	r3,-4(fp)
 821a844:	008209b4 	movhi	r2,2086
 821a848:	10b6cb04 	addi	r2,r2,-9428
 821a84c:	18c7883a 	add	r3,r3,r3
 821a850:	18c7883a 	add	r3,r3,r3
 821a854:	10c5883a 	add	r2,r2,r3
 821a858:	10800017 	ldw	r2,0(r2)
 821a85c:	10000626 	beq	r2,zero,821a878 <OSTaskChangePrio+0xb0>
 821a860:	e0bff517 	ldw	r2,-44(fp)
 821a864:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a868:	e0bff617 	ldw	r2,-40(fp)
 821a86c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
 821a870:	00800a04 	movi	r2,40
 821a874:	00010b06 	br	821aca4 <OSTaskChangePrio+0x4dc>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
 821a878:	e0bffe03 	ldbu	r2,-8(fp)
 821a87c:	10803fd8 	cmpnei	r2,r2,255
 821a880:	1000031e 	bne	r2,zero,821a890 <OSTaskChangePrio+0xc8>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
 821a884:	d0a07a17 	ldw	r2,-32280(gp)
 821a888:	10800c83 	ldbu	r2,50(r2)
 821a88c:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
 821a890:	e0fffe03 	ldbu	r3,-8(fp)
 821a894:	008209b4 	movhi	r2,2086
 821a898:	10b6cb04 	addi	r2,r2,-9428
 821a89c:	18c7883a 	add	r3,r3,r3
 821a8a0:	18c7883a 	add	r3,r3,r3
 821a8a4:	10c5883a 	add	r2,r2,r3
 821a8a8:	10800017 	ldw	r2,0(r2)
 821a8ac:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
 821a8b0:	e0bff817 	ldw	r2,-32(fp)
 821a8b4:	1000061e 	bne	r2,zero,821a8d0 <OSTaskChangePrio+0x108>
 821a8b8:	e0bff517 	ldw	r2,-44(fp)
 821a8bc:	e0bff715 	stw	r2,-36(fp)
 821a8c0:	e0bff717 	ldw	r2,-36(fp)
 821a8c4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
 821a8c8:	00800a44 	movi	r2,41
 821a8cc:	0000f506 	br	821aca4 <OSTaskChangePrio+0x4dc>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
 821a8d0:	e0bff817 	ldw	r2,-32(fp)
 821a8d4:	10800058 	cmpnei	r2,r2,1
 821a8d8:	1000061e 	bne	r2,zero,821a8f4 <OSTaskChangePrio+0x12c>
 821a8dc:	e0bff517 	ldw	r2,-44(fp)
 821a8e0:	e0bff915 	stw	r2,-28(fp)
 821a8e4:	e0bff917 	ldw	r2,-28(fp)
 821a8e8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
 821a8ec:	008010c4 	movi	r2,67
 821a8f0:	0000ec06 	br	821aca4 <OSTaskChangePrio+0x4dc>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
 821a8f4:	e0bfff03 	ldbu	r2,-4(fp)
 821a8f8:	1004d0fa 	srli	r2,r2,3
 821a8fc:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
 821a900:	e0bfff03 	ldbu	r2,-4(fp)
 821a904:	108001cc 	andi	r2,r2,7
 821a908:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
 821a90c:	e0bffb03 	ldbu	r2,-20(fp)
 821a910:	00c00044 	movi	r3,1
 821a914:	1884983a 	sll	r2,r3,r2
 821a918:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
 821a91c:	e0bffb43 	ldbu	r2,-19(fp)
 821a920:	00c00044 	movi	r3,1
 821a924:	1884983a 	sll	r2,r3,r2
 821a928:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
 821a92c:	e0fffe03 	ldbu	r3,-8(fp)
 821a930:	008209b4 	movhi	r2,2086
 821a934:	10b6cb04 	addi	r2,r2,-9428
 821a938:	18c7883a 	add	r3,r3,r3
 821a93c:	18c7883a 	add	r3,r3,r3
 821a940:	10c5883a 	add	r2,r2,r3
 821a944:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
 821a948:	e0ffff03 	ldbu	r3,-4(fp)
 821a94c:	008209b4 	movhi	r2,2086
 821a950:	10b6cb04 	addi	r2,r2,-9428
 821a954:	18c7883a 	add	r3,r3,r3
 821a958:	18c7883a 	add	r3,r3,r3
 821a95c:	10c5883a 	add	r2,r2,r3
 821a960:	e0fff817 	ldw	r3,-32(fp)
 821a964:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
 821a968:	e0bff817 	ldw	r2,-32(fp)
 821a96c:	10800d03 	ldbu	r2,52(r2)
 821a970:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
 821a974:	e0bff817 	ldw	r2,-32(fp)
 821a978:	10800d83 	ldbu	r2,54(r2)
 821a97c:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
 821a980:	e0bff817 	ldw	r2,-32(fp)
 821a984:	10800d43 	ldbu	r2,53(r2)
 821a988:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
 821a98c:	e0fffc03 	ldbu	r3,-16(fp)
 821a990:	d0a07744 	addi	r2,gp,-32291
 821a994:	1885883a 	add	r2,r3,r2
 821a998:	10c00003 	ldbu	r3,0(r2)
 821a99c:	e0bffc83 	ldbu	r2,-14(fp)
 821a9a0:	1884703a 	and	r2,r3,r2
 821a9a4:	10803fcc 	andi	r2,r2,255
 821a9a8:	10002826 	beq	r2,zero,821aa4c <OSTaskChangePrio+0x284>
         OSRdyTbl[y_old] &= ~bitx_old;
 821a9ac:	e0fffc03 	ldbu	r3,-16(fp)
 821a9b0:	e13ffc03 	ldbu	r4,-16(fp)
 821a9b4:	d0a07744 	addi	r2,gp,-32291
 821a9b8:	2085883a 	add	r2,r4,r2
 821a9bc:	10800003 	ldbu	r2,0(r2)
 821a9c0:	1009883a 	mov	r4,r2
 821a9c4:	e0bffc83 	ldbu	r2,-14(fp)
 821a9c8:	0084303a 	nor	r2,zero,r2
 821a9cc:	2084703a 	and	r2,r4,r2
 821a9d0:	1009883a 	mov	r4,r2
 821a9d4:	d0a07744 	addi	r2,gp,-32291
 821a9d8:	1885883a 	add	r2,r3,r2
 821a9dc:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
 821a9e0:	e0fffc03 	ldbu	r3,-16(fp)
 821a9e4:	d0a07744 	addi	r2,gp,-32291
 821a9e8:	1885883a 	add	r2,r3,r2
 821a9ec:	10800003 	ldbu	r2,0(r2)
 821a9f0:	10803fcc 	andi	r2,r2,255
 821a9f4:	1000061e 	bne	r2,zero,821aa10 <OSTaskChangePrio+0x248>
             OSRdyGrp &= ~bity_old;
 821a9f8:	e0bffc43 	ldbu	r2,-15(fp)
 821a9fc:	0084303a 	nor	r2,zero,r2
 821aa00:	1007883a 	mov	r3,r2
 821aa04:	d0a07703 	ldbu	r2,-32292(gp)
 821aa08:	1884703a 	and	r2,r3,r2
 821aa0c:	d0a07705 	stb	r2,-32292(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
 821aa10:	d0e07703 	ldbu	r3,-32292(gp)
 821aa14:	e0bffb83 	ldbu	r2,-18(fp)
 821aa18:	1884b03a 	or	r2,r3,r2
 821aa1c:	d0a07705 	stb	r2,-32292(gp)
         OSRdyTbl[y_new] |= bitx_new;
 821aa20:	e0fffb03 	ldbu	r3,-20(fp)
 821aa24:	e13ffb03 	ldbu	r4,-20(fp)
 821aa28:	d0a07744 	addi	r2,gp,-32291
 821aa2c:	2085883a 	add	r2,r4,r2
 821aa30:	11000003 	ldbu	r4,0(r2)
 821aa34:	e0bffbc3 	ldbu	r2,-17(fp)
 821aa38:	2084b03a 	or	r2,r4,r2
 821aa3c:	1009883a 	mov	r4,r2
 821aa40:	d0a07744 	addi	r2,gp,-32291
 821aa44:	1885883a 	add	r2,r3,r2
 821aa48:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
 821aa4c:	e0bff817 	ldw	r2,-32(fp)
 821aa50:	10800717 	ldw	r2,28(r2)
 821aa54:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
 821aa58:	e0bff317 	ldw	r2,-52(fp)
 821aa5c:	10003326 	beq	r2,zero,821ab2c <OSTaskChangePrio+0x364>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
 821aa60:	e0bffc03 	ldbu	r2,-16(fp)
 821aa64:	e0fffc03 	ldbu	r3,-16(fp)
 821aa68:	e13ff317 	ldw	r4,-52(fp)
 821aa6c:	20c7883a 	add	r3,r4,r3
 821aa70:	18c002c4 	addi	r3,r3,11
 821aa74:	18c00003 	ldbu	r3,0(r3)
 821aa78:	1809883a 	mov	r4,r3
 821aa7c:	e0fffc83 	ldbu	r3,-14(fp)
 821aa80:	00c6303a 	nor	r3,zero,r3
 821aa84:	20c6703a 	and	r3,r4,r3
 821aa88:	1809883a 	mov	r4,r3
 821aa8c:	e0fff317 	ldw	r3,-52(fp)
 821aa90:	1885883a 	add	r2,r3,r2
 821aa94:	108002c4 	addi	r2,r2,11
 821aa98:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
 821aa9c:	e0bffc03 	ldbu	r2,-16(fp)
 821aaa0:	e0fff317 	ldw	r3,-52(fp)
 821aaa4:	1885883a 	add	r2,r3,r2
 821aaa8:	108002c4 	addi	r2,r2,11
 821aaac:	10800003 	ldbu	r2,0(r2)
 821aab0:	10803fcc 	andi	r2,r2,255
 821aab4:	1000091e 	bne	r2,zero,821aadc <OSTaskChangePrio+0x314>
            pevent->OSEventGrp    &= ~bity_old;
 821aab8:	e0bff317 	ldw	r2,-52(fp)
 821aabc:	10800283 	ldbu	r2,10(r2)
 821aac0:	1007883a 	mov	r3,r2
 821aac4:	e0bffc43 	ldbu	r2,-15(fp)
 821aac8:	0084303a 	nor	r2,zero,r2
 821aacc:	1884703a 	and	r2,r3,r2
 821aad0:	1007883a 	mov	r3,r2
 821aad4:	e0bff317 	ldw	r2,-52(fp)
 821aad8:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
 821aadc:	e0bff317 	ldw	r2,-52(fp)
 821aae0:	10c00283 	ldbu	r3,10(r2)
 821aae4:	e0bffb83 	ldbu	r2,-18(fp)
 821aae8:	1884b03a 	or	r2,r3,r2
 821aaec:	1007883a 	mov	r3,r2
 821aaf0:	e0bff317 	ldw	r2,-52(fp)
 821aaf4:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
 821aaf8:	e0bffb03 	ldbu	r2,-20(fp)
 821aafc:	e0fffb03 	ldbu	r3,-20(fp)
 821ab00:	e13ff317 	ldw	r4,-52(fp)
 821ab04:	20c7883a 	add	r3,r4,r3
 821ab08:	18c002c4 	addi	r3,r3,11
 821ab0c:	19000003 	ldbu	r4,0(r3)
 821ab10:	e0fffbc3 	ldbu	r3,-17(fp)
 821ab14:	20c6b03a 	or	r3,r4,r3
 821ab18:	1809883a 	mov	r4,r3
 821ab1c:	e0fff317 	ldw	r3,-52(fp)
 821ab20:	1885883a 	add	r2,r3,r2
 821ab24:	108002c4 	addi	r2,r2,11
 821ab28:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
 821ab2c:	e0bff817 	ldw	r2,-32(fp)
 821ab30:	10800817 	ldw	r2,32(r2)
 821ab34:	10004226 	beq	r2,zero,821ac40 <OSTaskChangePrio+0x478>
        pevents =  ptcb->OSTCBEventMultiPtr;
 821ab38:	e0bff817 	ldw	r2,-32(fp)
 821ab3c:	10800817 	ldw	r2,32(r2)
 821ab40:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
 821ab44:	e0bff417 	ldw	r2,-48(fp)
 821ab48:	10800017 	ldw	r2,0(r2)
 821ab4c:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
 821ab50:	00003906 	br	821ac38 <OSTaskChangePrio+0x470>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
 821ab54:	e0bffc03 	ldbu	r2,-16(fp)
 821ab58:	e0fffc03 	ldbu	r3,-16(fp)
 821ab5c:	e13ff317 	ldw	r4,-52(fp)
 821ab60:	20c7883a 	add	r3,r4,r3
 821ab64:	18c002c4 	addi	r3,r3,11
 821ab68:	18c00003 	ldbu	r3,0(r3)
 821ab6c:	1809883a 	mov	r4,r3
 821ab70:	e0fffc83 	ldbu	r3,-14(fp)
 821ab74:	00c6303a 	nor	r3,zero,r3
 821ab78:	20c6703a 	and	r3,r4,r3
 821ab7c:	1809883a 	mov	r4,r3
 821ab80:	e0fff317 	ldw	r3,-52(fp)
 821ab84:	1885883a 	add	r2,r3,r2
 821ab88:	108002c4 	addi	r2,r2,11
 821ab8c:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
 821ab90:	e0bffc03 	ldbu	r2,-16(fp)
 821ab94:	e0fff317 	ldw	r3,-52(fp)
 821ab98:	1885883a 	add	r2,r3,r2
 821ab9c:	108002c4 	addi	r2,r2,11
 821aba0:	10800003 	ldbu	r2,0(r2)
 821aba4:	10803fcc 	andi	r2,r2,255
 821aba8:	1000091e 	bne	r2,zero,821abd0 <OSTaskChangePrio+0x408>
                pevent->OSEventGrp    &= ~bity_old;
 821abac:	e0bff317 	ldw	r2,-52(fp)
 821abb0:	10800283 	ldbu	r2,10(r2)
 821abb4:	1007883a 	mov	r3,r2
 821abb8:	e0bffc43 	ldbu	r2,-15(fp)
 821abbc:	0084303a 	nor	r2,zero,r2
 821abc0:	1884703a 	and	r2,r3,r2
 821abc4:	1007883a 	mov	r3,r2
 821abc8:	e0bff317 	ldw	r2,-52(fp)
 821abcc:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
 821abd0:	e0bff317 	ldw	r2,-52(fp)
 821abd4:	10c00283 	ldbu	r3,10(r2)
 821abd8:	e0bffb83 	ldbu	r2,-18(fp)
 821abdc:	1884b03a 	or	r2,r3,r2
 821abe0:	1007883a 	mov	r3,r2
 821abe4:	e0bff317 	ldw	r2,-52(fp)
 821abe8:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
 821abec:	e0bffb03 	ldbu	r2,-20(fp)
 821abf0:	e0fffb03 	ldbu	r3,-20(fp)
 821abf4:	e13ff317 	ldw	r4,-52(fp)
 821abf8:	20c7883a 	add	r3,r4,r3
 821abfc:	18c002c4 	addi	r3,r3,11
 821ac00:	19000003 	ldbu	r4,0(r3)
 821ac04:	e0fffbc3 	ldbu	r3,-17(fp)
 821ac08:	20c6b03a 	or	r3,r4,r3
 821ac0c:	1809883a 	mov	r4,r3
 821ac10:	e0fff317 	ldw	r3,-52(fp)
 821ac14:	1885883a 	add	r2,r3,r2
 821ac18:	108002c4 	addi	r2,r2,11
 821ac1c:	11000005 	stb	r4,0(r2)
            pevents++;
 821ac20:	e0bff417 	ldw	r2,-48(fp)
 821ac24:	10800104 	addi	r2,r2,4
 821ac28:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
 821ac2c:	e0bff417 	ldw	r2,-48(fp)
 821ac30:	10800017 	ldw	r2,0(r2)
 821ac34:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
 821ac38:	e0bff317 	ldw	r2,-52(fp)
 821ac3c:	103fc51e 	bne	r2,zero,821ab54 <OSTaskChangePrio+0x38c>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
 821ac40:	e0bff817 	ldw	r2,-32(fp)
 821ac44:	e0ffff03 	ldbu	r3,-4(fp)
 821ac48:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
 821ac4c:	e0bff817 	ldw	r2,-32(fp)
 821ac50:	e0fffb03 	ldbu	r3,-20(fp)
 821ac54:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
 821ac58:	e0bff817 	ldw	r2,-32(fp)
 821ac5c:	e0fffb43 	ldbu	r3,-19(fp)
 821ac60:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
 821ac64:	e0bff817 	ldw	r2,-32(fp)
 821ac68:	e0fffb83 	ldbu	r3,-18(fp)
 821ac6c:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
 821ac70:	e0bff817 	ldw	r2,-32(fp)
 821ac74:	e0fffbc3 	ldbu	r3,-17(fp)
 821ac78:	10c00d45 	stb	r3,53(r2)
 821ac7c:	e0bff517 	ldw	r2,-44(fp)
 821ac80:	e0bffa15 	stw	r2,-24(fp)
 821ac84:	e0bffa17 	ldw	r2,-24(fp)
 821ac88:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 821ac8c:	d0a06b43 	ldbu	r2,-32339(gp)
 821ac90:	10803fcc 	andi	r2,r2,255
 821ac94:	10800058 	cmpnei	r2,r2,1
 821ac98:	1000011e 	bne	r2,zero,821aca0 <OSTaskChangePrio+0x4d8>
        OS_Sched();                                         /* Find new highest priority task          */
 821ac9c:	82165800 	call	8216580 <OS_Sched>
    }
    return (OS_ERR_NONE);
 821aca0:	0005883a 	mov	r2,zero
}
 821aca4:	e037883a 	mov	sp,fp
 821aca8:	dfc00117 	ldw	ra,4(sp)
 821acac:	df000017 	ldw	fp,0(sp)
 821acb0:	dec00204 	addi	sp,sp,8
 821acb4:	f800283a 	ret

0821acb8 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
 821acb8:	deffee04 	addi	sp,sp,-72
 821acbc:	dfc01115 	stw	ra,68(sp)
 821acc0:	df001015 	stw	fp,64(sp)
 821acc4:	df001004 	addi	fp,sp,64
 821acc8:	e13ffc15 	stw	r4,-16(fp)
 821accc:	e17ffd15 	stw	r5,-12(fp)
 821acd0:	e1bffe15 	stw	r6,-8(fp)
 821acd4:	3805883a 	mov	r2,r7
 821acd8:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 821acdc:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 821ace0:	e0bfff03 	ldbu	r2,-4(fp)
 821ace4:	10800570 	cmpltui	r2,r2,21
 821ace8:	1000021e 	bne	r2,zero,821acf4 <OSTaskCreate+0x3c>
        return (OS_ERR_PRIO_INVALID);
 821acec:	00800a84 	movi	r2,42
 821acf0:	00005706 	br	821ae50 <OSTaskCreate+0x198>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821acf4:	0005303a 	rdctl	r2,status
 821acf8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821acfc:	e0fffb17 	ldw	r3,-20(fp)
 821ad00:	00bfff84 	movi	r2,-2
 821ad04:	1884703a 	and	r2,r3,r2
 821ad08:	1001703a 	wrctl	status,r2
  
  return context;
 821ad0c:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821ad10:	e0bff315 	stw	r2,-52(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 821ad14:	d0a07903 	ldbu	r2,-32284(gp)
 821ad18:	10803fcc 	andi	r2,r2,255
 821ad1c:	10000626 	beq	r2,zero,821ad38 <OSTaskCreate+0x80>
 821ad20:	e0bff317 	ldw	r2,-52(fp)
 821ad24:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821ad28:	e0bff417 	ldw	r2,-48(fp)
 821ad2c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 821ad30:	00800f04 	movi	r2,60
 821ad34:	00004606 	br	821ae50 <OSTaskCreate+0x198>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 821ad38:	e0ffff03 	ldbu	r3,-4(fp)
 821ad3c:	008209b4 	movhi	r2,2086
 821ad40:	10b6cb04 	addi	r2,r2,-9428
 821ad44:	18c7883a 	add	r3,r3,r3
 821ad48:	18c7883a 	add	r3,r3,r3
 821ad4c:	10c5883a 	add	r2,r2,r3
 821ad50:	10800017 	ldw	r2,0(r2)
 821ad54:	1000391e 	bne	r2,zero,821ae3c <OSTaskCreate+0x184>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 821ad58:	e0ffff03 	ldbu	r3,-4(fp)
 821ad5c:	008209b4 	movhi	r2,2086
 821ad60:	10b6cb04 	addi	r2,r2,-9428
 821ad64:	18c7883a 	add	r3,r3,r3
 821ad68:	18c7883a 	add	r3,r3,r3
 821ad6c:	10c5883a 	add	r2,r2,r3
 821ad70:	00c00044 	movi	r3,1
 821ad74:	10c00015 	stw	r3,0(r2)
 821ad78:	e0bff317 	ldw	r2,-52(fp)
 821ad7c:	e0bff515 	stw	r2,-44(fp)
 821ad80:	e0bff517 	ldw	r2,-44(fp)
 821ad84:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
 821ad88:	000f883a 	mov	r7,zero
 821ad8c:	e1bffe17 	ldw	r6,-8(fp)
 821ad90:	e17ffd17 	ldw	r5,-12(fp)
 821ad94:	e13ffc17 	ldw	r4,-16(fp)
 821ad98:	823cde00 	call	823cde0 <OSTaskStkInit>
 821ad9c:	e0bff715 	stw	r2,-36(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
 821ada0:	e0bfff03 	ldbu	r2,-4(fp)
 821ada4:	d8000215 	stw	zero,8(sp)
 821ada8:	d8000115 	stw	zero,4(sp)
 821adac:	d8000015 	stw	zero,0(sp)
 821adb0:	000f883a 	mov	r7,zero
 821adb4:	000d883a 	mov	r6,zero
 821adb8:	e17ff717 	ldw	r5,-36(fp)
 821adbc:	1009883a 	mov	r4,r2
 821adc0:	82169980 	call	8216998 <OS_TCBInit>
 821adc4:	e0bff805 	stb	r2,-32(fp)
        if (err == OS_ERR_NONE) {
 821adc8:	e0bff803 	ldbu	r2,-32(fp)
 821adcc:	1000061e 	bne	r2,zero,821ade8 <OSTaskCreate+0x130>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
 821add0:	d0a06b43 	ldbu	r2,-32339(gp)
 821add4:	10803fcc 	andi	r2,r2,255
 821add8:	10800058 	cmpnei	r2,r2,1
 821addc:	1000151e 	bne	r2,zero,821ae34 <OSTaskCreate+0x17c>
                OS_Sched();
 821ade0:	82165800 	call	8216580 <OS_Sched>
 821ade4:	00001306 	br	821ae34 <OSTaskCreate+0x17c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821ade8:	0005303a 	rdctl	r2,status
 821adec:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821adf0:	e0fffa17 	ldw	r3,-24(fp)
 821adf4:	00bfff84 	movi	r2,-2
 821adf8:	1884703a 	and	r2,r3,r2
 821adfc:	1001703a 	wrctl	status,r2
  
  return context;
 821ae00:	e0bffa17 	ldw	r2,-24(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 821ae04:	e0bff315 	stw	r2,-52(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
 821ae08:	e0ffff03 	ldbu	r3,-4(fp)
 821ae0c:	008209b4 	movhi	r2,2086
 821ae10:	10b6cb04 	addi	r2,r2,-9428
 821ae14:	18c7883a 	add	r3,r3,r3
 821ae18:	18c7883a 	add	r3,r3,r3
 821ae1c:	10c5883a 	add	r2,r2,r3
 821ae20:	10000015 	stw	zero,0(r2)
 821ae24:	e0bff317 	ldw	r2,-52(fp)
 821ae28:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821ae2c:	e0bff617 	ldw	r2,-40(fp)
 821ae30:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 821ae34:	e0bff803 	ldbu	r2,-32(fp)
 821ae38:	00000506 	br	821ae50 <OSTaskCreate+0x198>
 821ae3c:	e0bff317 	ldw	r2,-52(fp)
 821ae40:	e0bff915 	stw	r2,-28(fp)
 821ae44:	e0bff917 	ldw	r2,-28(fp)
 821ae48:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 821ae4c:	00800a04 	movi	r2,40
}
 821ae50:	e037883a 	mov	sp,fp
 821ae54:	dfc00117 	ldw	ra,4(sp)
 821ae58:	df000017 	ldw	fp,0(sp)
 821ae5c:	dec00204 	addi	sp,sp,8
 821ae60:	f800283a 	ret

0821ae64 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
 821ae64:	deffec04 	addi	sp,sp,-80
 821ae68:	dfc01315 	stw	ra,76(sp)
 821ae6c:	df001215 	stw	fp,72(sp)
 821ae70:	df001204 	addi	fp,sp,72
 821ae74:	e13ffa15 	stw	r4,-24(fp)
 821ae78:	e17ffb15 	stw	r5,-20(fp)
 821ae7c:	e1bffc15 	stw	r6,-16(fp)
 821ae80:	3809883a 	mov	r4,r7
 821ae84:	e0c00217 	ldw	r3,8(fp)
 821ae88:	e0800617 	ldw	r2,24(fp)
 821ae8c:	e13ffd05 	stb	r4,-12(fp)
 821ae90:	e0fffe0d 	sth	r3,-8(fp)
 821ae94:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 821ae98:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 821ae9c:	e0bffd03 	ldbu	r2,-12(fp)
 821aea0:	10800570 	cmpltui	r2,r2,21
 821aea4:	1000021e 	bne	r2,zero,821aeb0 <OSTaskCreateExt+0x4c>
        return (OS_ERR_PRIO_INVALID);
 821aea8:	00800a84 	movi	r2,42
 821aeac:	00006106 	br	821b034 <OSTaskCreateExt+0x1d0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821aeb0:	0005303a 	rdctl	r2,status
 821aeb4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821aeb8:	e0fff917 	ldw	r3,-28(fp)
 821aebc:	00bfff84 	movi	r2,-2
 821aec0:	1884703a 	and	r2,r3,r2
 821aec4:	1001703a 	wrctl	status,r2
  
  return context;
 821aec8:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821aecc:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 821aed0:	d0a07903 	ldbu	r2,-32284(gp)
 821aed4:	10803fcc 	andi	r2,r2,255
 821aed8:	10000626 	beq	r2,zero,821aef4 <OSTaskCreateExt+0x90>
 821aedc:	e0bff117 	ldw	r2,-60(fp)
 821aee0:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821aee4:	e0bff217 	ldw	r2,-56(fp)
 821aee8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 821aeec:	00800f04 	movi	r2,60
 821aef0:	00005006 	br	821b034 <OSTaskCreateExt+0x1d0>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 821aef4:	e0fffd03 	ldbu	r3,-12(fp)
 821aef8:	008209b4 	movhi	r2,2086
 821aefc:	10b6cb04 	addi	r2,r2,-9428
 821af00:	18c7883a 	add	r3,r3,r3
 821af04:	18c7883a 	add	r3,r3,r3
 821af08:	10c5883a 	add	r2,r2,r3
 821af0c:	10800017 	ldw	r2,0(r2)
 821af10:	1000431e 	bne	r2,zero,821b020 <OSTaskCreateExt+0x1bc>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 821af14:	e0fffd03 	ldbu	r3,-12(fp)
 821af18:	008209b4 	movhi	r2,2086
 821af1c:	10b6cb04 	addi	r2,r2,-9428
 821af20:	18c7883a 	add	r3,r3,r3
 821af24:	18c7883a 	add	r3,r3,r3
 821af28:	10c5883a 	add	r2,r2,r3
 821af2c:	00c00044 	movi	r3,1
 821af30:	10c00015 	stw	r3,0(r2)
 821af34:	e0bff117 	ldw	r2,-60(fp)
 821af38:	e0bff315 	stw	r2,-52(fp)
 821af3c:	e0bff317 	ldw	r2,-52(fp)
 821af40:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
 821af44:	e0bfff0b 	ldhu	r2,-4(fp)
 821af48:	100d883a 	mov	r6,r2
 821af4c:	e1400417 	ldw	r5,16(fp)
 821af50:	e1000317 	ldw	r4,12(fp)
 821af54:	821bec40 	call	821bec4 <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
 821af58:	e0bfff0b 	ldhu	r2,-4(fp)
 821af5c:	100f883a 	mov	r7,r2
 821af60:	e1bffc17 	ldw	r6,-16(fp)
 821af64:	e17ffb17 	ldw	r5,-20(fp)
 821af68:	e13ffa17 	ldw	r4,-24(fp)
 821af6c:	823cde00 	call	823cde0 <OSTaskStkInit>
 821af70:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
 821af74:	e0fffd03 	ldbu	r3,-12(fp)
 821af78:	e13ffe0b 	ldhu	r4,-8(fp)
 821af7c:	e0bfff0b 	ldhu	r2,-4(fp)
 821af80:	d8800215 	stw	r2,8(sp)
 821af84:	e0800517 	ldw	r2,20(fp)
 821af88:	d8800115 	stw	r2,4(sp)
 821af8c:	e0800417 	ldw	r2,16(fp)
 821af90:	d8800015 	stw	r2,0(sp)
 821af94:	200f883a 	mov	r7,r4
 821af98:	e1800317 	ldw	r6,12(fp)
 821af9c:	e17ff517 	ldw	r5,-44(fp)
 821afa0:	1809883a 	mov	r4,r3
 821afa4:	82169980 	call	8216998 <OS_TCBInit>
 821afa8:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
 821afac:	e0bff603 	ldbu	r2,-40(fp)
 821afb0:	1000061e 	bne	r2,zero,821afcc <OSTaskCreateExt+0x168>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
 821afb4:	d0a06b43 	ldbu	r2,-32339(gp)
 821afb8:	10803fcc 	andi	r2,r2,255
 821afbc:	10800058 	cmpnei	r2,r2,1
 821afc0:	1000151e 	bne	r2,zero,821b018 <OSTaskCreateExt+0x1b4>
                OS_Sched();
 821afc4:	82165800 	call	8216580 <OS_Sched>
 821afc8:	00001306 	br	821b018 <OSTaskCreateExt+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821afcc:	0005303a 	rdctl	r2,status
 821afd0:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821afd4:	e0fff817 	ldw	r3,-32(fp)
 821afd8:	00bfff84 	movi	r2,-2
 821afdc:	1884703a 	and	r2,r3,r2
 821afe0:	1001703a 	wrctl	status,r2
  
  return context;
 821afe4:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 821afe8:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
 821afec:	e0fffd03 	ldbu	r3,-12(fp)
 821aff0:	008209b4 	movhi	r2,2086
 821aff4:	10b6cb04 	addi	r2,r2,-9428
 821aff8:	18c7883a 	add	r3,r3,r3
 821affc:	18c7883a 	add	r3,r3,r3
 821b000:	10c5883a 	add	r2,r2,r3
 821b004:	10000015 	stw	zero,0(r2)
 821b008:	e0bff117 	ldw	r2,-60(fp)
 821b00c:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b010:	e0bff417 	ldw	r2,-48(fp)
 821b014:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 821b018:	e0bff603 	ldbu	r2,-40(fp)
 821b01c:	00000506 	br	821b034 <OSTaskCreateExt+0x1d0>
 821b020:	e0bff117 	ldw	r2,-60(fp)
 821b024:	e0bff715 	stw	r2,-36(fp)
 821b028:	e0bff717 	ldw	r2,-36(fp)
 821b02c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 821b030:	00800a04 	movi	r2,40
}
 821b034:	e037883a 	mov	sp,fp
 821b038:	dfc00117 	ldw	ra,4(sp)
 821b03c:	df000017 	ldw	fp,0(sp)
 821b040:	dec00204 	addi	sp,sp,8
 821b044:	f800283a 	ret

0821b048 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
 821b048:	defff404 	addi	sp,sp,-48
 821b04c:	dfc00b15 	stw	ra,44(sp)
 821b050:	df000a15 	stw	fp,40(sp)
 821b054:	df000a04 	addi	fp,sp,40
 821b058:	2005883a 	mov	r2,r4
 821b05c:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
 821b060:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
 821b064:	d0a07903 	ldbu	r2,-32284(gp)
 821b068:	10803fcc 	andi	r2,r2,255
 821b06c:	10000226 	beq	r2,zero,821b078 <OSTaskDel+0x30>
        return (OS_ERR_TASK_DEL_ISR);
 821b070:	00801004 	movi	r2,64
 821b074:	0000c006 	br	821b378 <OSTaskDel+0x330>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
 821b078:	e0bfff03 	ldbu	r2,-4(fp)
 821b07c:	10800518 	cmpnei	r2,r2,20
 821b080:	1000021e 	bne	r2,zero,821b08c <OSTaskDel+0x44>
        return (OS_ERR_TASK_DEL_IDLE);
 821b084:	00800f84 	movi	r2,62
 821b088:	0000bb06 	br	821b378 <OSTaskDel+0x330>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
 821b08c:	e0bfff03 	ldbu	r2,-4(fp)
 821b090:	10800530 	cmpltui	r2,r2,20
 821b094:	1000051e 	bne	r2,zero,821b0ac <OSTaskDel+0x64>
        if (prio != OS_PRIO_SELF) {
 821b098:	e0bfff03 	ldbu	r2,-4(fp)
 821b09c:	10803fe0 	cmpeqi	r2,r2,255
 821b0a0:	1000021e 	bne	r2,zero,821b0ac <OSTaskDel+0x64>
            return (OS_ERR_PRIO_INVALID);
 821b0a4:	00800a84 	movi	r2,42
 821b0a8:	0000b306 	br	821b378 <OSTaskDel+0x330>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b0ac:	0005303a 	rdctl	r2,status
 821b0b0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b0b4:	e0fffe17 	ldw	r3,-8(fp)
 821b0b8:	00bfff84 	movi	r2,-2
 821b0bc:	1884703a 	and	r2,r3,r2
 821b0c0:	1001703a 	wrctl	status,r2
  
  return context;
 821b0c4:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
 821b0c8:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
 821b0cc:	e0bfff03 	ldbu	r2,-4(fp)
 821b0d0:	10803fd8 	cmpnei	r2,r2,255
 821b0d4:	1000031e 	bne	r2,zero,821b0e4 <OSTaskDel+0x9c>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
 821b0d8:	d0a07a17 	ldw	r2,-32280(gp)
 821b0dc:	10800c83 	ldbu	r2,50(r2)
 821b0e0:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821b0e4:	e0ffff03 	ldbu	r3,-4(fp)
 821b0e8:	008209b4 	movhi	r2,2086
 821b0ec:	10b6cb04 	addi	r2,r2,-9428
 821b0f0:	18c7883a 	add	r3,r3,r3
 821b0f4:	18c7883a 	add	r3,r3,r3
 821b0f8:	10c5883a 	add	r2,r2,r3
 821b0fc:	10800017 	ldw	r2,0(r2)
 821b100:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
 821b104:	e0bff817 	ldw	r2,-32(fp)
 821b108:	1000061e 	bne	r2,zero,821b124 <OSTaskDel+0xdc>
 821b10c:	e0bff617 	ldw	r2,-40(fp)
 821b110:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b114:	e0bff717 	ldw	r2,-36(fp)
 821b118:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821b11c:	008010c4 	movi	r2,67
 821b120:	00009506 	br	821b378 <OSTaskDel+0x330>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
 821b124:	e0bff817 	ldw	r2,-32(fp)
 821b128:	10800058 	cmpnei	r2,r2,1
 821b12c:	1000061e 	bne	r2,zero,821b148 <OSTaskDel+0x100>
 821b130:	e0bff617 	ldw	r2,-40(fp)
 821b134:	e0bff915 	stw	r2,-28(fp)
 821b138:	e0bff917 	ldw	r2,-28(fp)
 821b13c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 821b140:	00800f44 	movi	r2,61
 821b144:	00008c06 	br	821b378 <OSTaskDel+0x330>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
 821b148:	e0bff817 	ldw	r2,-32(fp)
 821b14c:	10800d03 	ldbu	r2,52(r2)
 821b150:	10c03fcc 	andi	r3,r2,255
 821b154:	e0bff817 	ldw	r2,-32(fp)
 821b158:	10800d03 	ldbu	r2,52(r2)
 821b15c:	11003fcc 	andi	r4,r2,255
 821b160:	d0a07744 	addi	r2,gp,-32291
 821b164:	2085883a 	add	r2,r4,r2
 821b168:	10800003 	ldbu	r2,0(r2)
 821b16c:	1009883a 	mov	r4,r2
 821b170:	e0bff817 	ldw	r2,-32(fp)
 821b174:	10800d43 	ldbu	r2,53(r2)
 821b178:	0084303a 	nor	r2,zero,r2
 821b17c:	2084703a 	and	r2,r4,r2
 821b180:	1009883a 	mov	r4,r2
 821b184:	d0a07744 	addi	r2,gp,-32291
 821b188:	1885883a 	add	r2,r3,r2
 821b18c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
 821b190:	e0bff817 	ldw	r2,-32(fp)
 821b194:	10800d03 	ldbu	r2,52(r2)
 821b198:	10c03fcc 	andi	r3,r2,255
 821b19c:	d0a07744 	addi	r2,gp,-32291
 821b1a0:	1885883a 	add	r2,r3,r2
 821b1a4:	10800003 	ldbu	r2,0(r2)
 821b1a8:	10803fcc 	andi	r2,r2,255
 821b1ac:	1000071e 	bne	r2,zero,821b1cc <OSTaskDel+0x184>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
 821b1b0:	e0bff817 	ldw	r2,-32(fp)
 821b1b4:	10800d83 	ldbu	r2,54(r2)
 821b1b8:	0084303a 	nor	r2,zero,r2
 821b1bc:	1007883a 	mov	r3,r2
 821b1c0:	d0a07703 	ldbu	r2,-32292(gp)
 821b1c4:	1884703a 	and	r2,r3,r2
 821b1c8:	d0a07705 	stb	r2,-32292(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
 821b1cc:	e0bff817 	ldw	r2,-32(fp)
 821b1d0:	10800717 	ldw	r2,28(r2)
 821b1d4:	10000526 	beq	r2,zero,821b1ec <OSTaskDel+0x1a4>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
 821b1d8:	e0bff817 	ldw	r2,-32(fp)
 821b1dc:	10800717 	ldw	r2,28(r2)
 821b1e0:	100b883a 	mov	r5,r2
 821b1e4:	e13ff817 	ldw	r4,-32(fp)
 821b1e8:	8215f2c0 	call	8215f2c <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
 821b1ec:	e0bff817 	ldw	r2,-32(fp)
 821b1f0:	10800817 	ldw	r2,32(r2)
 821b1f4:	10000526 	beq	r2,zero,821b20c <OSTaskDel+0x1c4>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 821b1f8:	e0bff817 	ldw	r2,-32(fp)
 821b1fc:	10800817 	ldw	r2,32(r2)
 821b200:	100b883a 	mov	r5,r2
 821b204:	e13ff817 	ldw	r4,-32(fp)
 821b208:	8215fe40 	call	8215fe4 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
 821b20c:	e0bff817 	ldw	r2,-32(fp)
 821b210:	10800a17 	ldw	r2,40(r2)
 821b214:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
 821b218:	e0bffb17 	ldw	r2,-20(fp)
 821b21c:	10000226 	beq	r2,zero,821b228 <OSTaskDel+0x1e0>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
 821b220:	e13ffb17 	ldw	r4,-20(fp)
 821b224:	821846c0 	call	821846c <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
 821b228:	e0bff817 	ldw	r2,-32(fp)
 821b22c:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
 821b230:	e0bff817 	ldw	r2,-32(fp)
 821b234:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 821b238:	e0bff817 	ldw	r2,-32(fp)
 821b23c:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
 821b240:	d0a06b03 	ldbu	r2,-32340(gp)
 821b244:	10803fcc 	andi	r2,r2,255
 821b248:	10803fe0 	cmpeqi	r2,r2,255
 821b24c:	1000031e 	bne	r2,zero,821b25c <OSTaskDel+0x214>
        OSLockNesting++;
 821b250:	d0a06b03 	ldbu	r2,-32340(gp)
 821b254:	10800044 	addi	r2,r2,1
 821b258:	d0a06b05 	stb	r2,-32340(gp)
 821b25c:	e0bff617 	ldw	r2,-40(fp)
 821b260:	e0bffd15 	stw	r2,-12(fp)
 821b264:	e0bffd17 	ldw	r2,-12(fp)
 821b268:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
 821b26c:	8215b140 	call	8215b14 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b270:	0005303a 	rdctl	r2,status
 821b274:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b278:	e0fffa17 	ldw	r3,-24(fp)
 821b27c:	00bfff84 	movi	r2,-2
 821b280:	1884703a 	and	r2,r3,r2
 821b284:	1001703a 	wrctl	status,r2
  
  return context;
 821b288:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
 821b28c:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
 821b290:	d0a06b03 	ldbu	r2,-32340(gp)
 821b294:	10803fcc 	andi	r2,r2,255
 821b298:	10000326 	beq	r2,zero,821b2a8 <OSTaskDel+0x260>
        OSLockNesting--;
 821b29c:	d0a06b03 	ldbu	r2,-32340(gp)
 821b2a0:	10bfffc4 	addi	r2,r2,-1
 821b2a4:	d0a06b05 	stb	r2,-32340(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
 821b2a8:	e13ff817 	ldw	r4,-32(fp)
 821b2ac:	823cf600 	call	823cf60 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
 821b2b0:	d0a07343 	ldbu	r2,-32307(gp)
 821b2b4:	10bfffc4 	addi	r2,r2,-1
 821b2b8:	d0a07345 	stb	r2,-32307(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
 821b2bc:	e0ffff03 	ldbu	r3,-4(fp)
 821b2c0:	008209b4 	movhi	r2,2086
 821b2c4:	10b6cb04 	addi	r2,r2,-9428
 821b2c8:	18c7883a 	add	r3,r3,r3
 821b2cc:	18c7883a 	add	r3,r3,r3
 821b2d0:	10c5883a 	add	r2,r2,r3
 821b2d4:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
 821b2d8:	e0bff817 	ldw	r2,-32(fp)
 821b2dc:	10800617 	ldw	r2,24(r2)
 821b2e0:	1000071e 	bne	r2,zero,821b300 <OSTaskDel+0x2b8>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
 821b2e4:	e0bff817 	ldw	r2,-32(fp)
 821b2e8:	10800517 	ldw	r2,20(r2)
 821b2ec:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
 821b2f0:	e0bff817 	ldw	r2,-32(fp)
 821b2f4:	10800517 	ldw	r2,20(r2)
 821b2f8:	d0a06e15 	stw	r2,-32328(gp)
 821b2fc:	00000a06 	br	821b328 <OSTaskDel+0x2e0>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
 821b300:	e0bff817 	ldw	r2,-32(fp)
 821b304:	10800617 	ldw	r2,24(r2)
 821b308:	e0fff817 	ldw	r3,-32(fp)
 821b30c:	18c00517 	ldw	r3,20(r3)
 821b310:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
 821b314:	e0bff817 	ldw	r2,-32(fp)
 821b318:	10800517 	ldw	r2,20(r2)
 821b31c:	e0fff817 	ldw	r3,-32(fp)
 821b320:	18c00617 	ldw	r3,24(r3)
 821b324:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
 821b328:	d0e07217 	ldw	r3,-32312(gp)
 821b32c:	e0bff817 	ldw	r2,-32(fp)
 821b330:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
 821b334:	e0bff817 	ldw	r2,-32(fp)
 821b338:	d0a07215 	stw	r2,-32312(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
 821b33c:	e0bff817 	ldw	r2,-32(fp)
 821b340:	00c00fc4 	movi	r3,63
 821b344:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 821b348:	e0bff817 	ldw	r2,-32(fp)
 821b34c:	10001345 	stb	zero,77(r2)
 821b350:	e0bff617 	ldw	r2,-40(fp)
 821b354:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b358:	e0bffc17 	ldw	r2,-16(fp)
 821b35c:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 821b360:	d0a06b43 	ldbu	r2,-32339(gp)
 821b364:	10803fcc 	andi	r2,r2,255
 821b368:	10800058 	cmpnei	r2,r2,1
 821b36c:	1000011e 	bne	r2,zero,821b374 <OSTaskDel+0x32c>
        OS_Sched();                                     /* Find new highest priority task              */
 821b370:	82165800 	call	8216580 <OS_Sched>
    }
    return (OS_ERR_NONE);
 821b374:	0005883a 	mov	r2,zero
}
 821b378:	e037883a 	mov	sp,fp
 821b37c:	dfc00117 	ldw	ra,4(sp)
 821b380:	df000017 	ldw	fp,0(sp)
 821b384:	dec00204 	addi	sp,sp,8
 821b388:	f800283a 	ret

0821b38c <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
 821b38c:	defff504 	addi	sp,sp,-44
 821b390:	df000a15 	stw	fp,40(sp)
 821b394:	df000a04 	addi	fp,sp,40
 821b398:	2005883a 	mov	r2,r4
 821b39c:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821b3a0:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
 821b3a4:	e0bfff03 	ldbu	r2,-4(fp)
 821b3a8:	10800518 	cmpnei	r2,r2,20
 821b3ac:	1000021e 	bne	r2,zero,821b3b8 <OSTaskDelReq+0x2c>
        return (OS_ERR_TASK_DEL_IDLE);
 821b3b0:	00800f84 	movi	r2,62
 821b3b4:	00004506 	br	821b4cc <OSTaskDelReq+0x140>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 821b3b8:	e0bfff03 	ldbu	r2,-4(fp)
 821b3bc:	10800530 	cmpltui	r2,r2,20
 821b3c0:	1000051e 	bne	r2,zero,821b3d8 <OSTaskDelReq+0x4c>
        if (prio != OS_PRIO_SELF) {
 821b3c4:	e0bfff03 	ldbu	r2,-4(fp)
 821b3c8:	10803fe0 	cmpeqi	r2,r2,255
 821b3cc:	1000021e 	bne	r2,zero,821b3d8 <OSTaskDelReq+0x4c>
            return (OS_ERR_PRIO_INVALID);
 821b3d0:	00800a84 	movi	r2,42
 821b3d4:	00003d06 	br	821b4cc <OSTaskDelReq+0x140>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
 821b3d8:	e0bfff03 	ldbu	r2,-4(fp)
 821b3dc:	10803fd8 	cmpnei	r2,r2,255
 821b3e0:	1000111e 	bne	r2,zero,821b428 <OSTaskDelReq+0x9c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b3e4:	0005303a 	rdctl	r2,status
 821b3e8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b3ec:	e0fff917 	ldw	r3,-28(fp)
 821b3f0:	00bfff84 	movi	r2,-2
 821b3f4:	1884703a 	and	r2,r3,r2
 821b3f8:	1001703a 	wrctl	status,r2
  
  return context;
 821b3fc:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
 821b400:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
 821b404:	d0a07a17 	ldw	r2,-32280(gp)
 821b408:	10800dc3 	ldbu	r2,55(r2)
 821b40c:	e0bff805 	stb	r2,-32(fp)
 821b410:	e0bff617 	ldw	r2,-40(fp)
 821b414:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b418:	e0bffe17 	ldw	r2,-8(fp)
 821b41c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
 821b420:	e0bff803 	ldbu	r2,-32(fp)
 821b424:	00002906 	br	821b4cc <OSTaskDelReq+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b428:	0005303a 	rdctl	r2,status
 821b42c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b430:	e0fff717 	ldw	r3,-36(fp)
 821b434:	00bfff84 	movi	r2,-2
 821b438:	1884703a 	and	r2,r3,r2
 821b43c:	1001703a 	wrctl	status,r2
  
  return context;
 821b440:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 821b444:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
 821b448:	e0ffff03 	ldbu	r3,-4(fp)
 821b44c:	008209b4 	movhi	r2,2086
 821b450:	10b6cb04 	addi	r2,r2,-9428
 821b454:	18c7883a 	add	r3,r3,r3
 821b458:	18c7883a 	add	r3,r3,r3
 821b45c:	10c5883a 	add	r2,r2,r3
 821b460:	10800017 	ldw	r2,0(r2)
 821b464:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
 821b468:	e0bffb17 	ldw	r2,-20(fp)
 821b46c:	1000061e 	bne	r2,zero,821b488 <OSTaskDelReq+0xfc>
 821b470:	e0bff617 	ldw	r2,-40(fp)
 821b474:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b478:	e0bffa17 	ldw	r2,-24(fp)
 821b47c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
 821b480:	008010c4 	movi	r2,67
 821b484:	00001106 	br	821b4cc <OSTaskDelReq+0x140>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
 821b488:	e0bffb17 	ldw	r2,-20(fp)
 821b48c:	10800058 	cmpnei	r2,r2,1
 821b490:	1000061e 	bne	r2,zero,821b4ac <OSTaskDelReq+0x120>
 821b494:	e0bff617 	ldw	r2,-40(fp)
 821b498:	e0bffc15 	stw	r2,-16(fp)
 821b49c:	e0bffc17 	ldw	r2,-16(fp)
 821b4a0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 821b4a4:	00800f44 	movi	r2,61
 821b4a8:	00000806 	br	821b4cc <OSTaskDelReq+0x140>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
 821b4ac:	e0bffb17 	ldw	r2,-20(fp)
 821b4b0:	00c00fc4 	movi	r3,63
 821b4b4:	10c00dc5 	stb	r3,55(r2)
 821b4b8:	e0bff617 	ldw	r2,-40(fp)
 821b4bc:	e0bffd15 	stw	r2,-12(fp)
 821b4c0:	e0bffd17 	ldw	r2,-12(fp)
 821b4c4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 821b4c8:	0005883a 	mov	r2,zero
}
 821b4cc:	e037883a 	mov	sp,fp
 821b4d0:	df000017 	ldw	fp,0(sp)
 821b4d4:	dec00104 	addi	sp,sp,4
 821b4d8:	f800283a 	ret

0821b4dc <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
 821b4dc:	defff404 	addi	sp,sp,-48
 821b4e0:	dfc00b15 	stw	ra,44(sp)
 821b4e4:	df000a15 	stw	fp,40(sp)
 821b4e8:	df000a04 	addi	fp,sp,40
 821b4ec:	2005883a 	mov	r2,r4
 821b4f0:	e17ffe15 	stw	r5,-8(fp)
 821b4f4:	e1bfff15 	stw	r6,-4(fp)
 821b4f8:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
 821b4fc:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
 821b500:	e0bfff17 	ldw	r2,-4(fp)
 821b504:	1000021e 	bne	r2,zero,821b510 <OSTaskNameGet+0x34>
        return (0);
 821b508:	0005883a 	mov	r2,zero
 821b50c:	00005406 	br	821b660 <OSTaskNameGet+0x184>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
 821b510:	e0bffd03 	ldbu	r2,-12(fp)
 821b514:	10800570 	cmpltui	r2,r2,21
 821b518:	1000081e 	bne	r2,zero,821b53c <OSTaskNameGet+0x60>
        if (prio != OS_PRIO_SELF) {
 821b51c:	e0bffd03 	ldbu	r2,-12(fp)
 821b520:	10803fe0 	cmpeqi	r2,r2,255
 821b524:	1000051e 	bne	r2,zero,821b53c <OSTaskNameGet+0x60>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
 821b528:	e0bfff17 	ldw	r2,-4(fp)
 821b52c:	00c00a84 	movi	r3,42
 821b530:	10c00005 	stb	r3,0(r2)
            return (0);
 821b534:	0005883a 	mov	r2,zero
 821b538:	00004906 	br	821b660 <OSTaskNameGet+0x184>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
 821b53c:	e0bffe17 	ldw	r2,-8(fp)
 821b540:	1000051e 	bne	r2,zero,821b558 <OSTaskNameGet+0x7c>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
 821b544:	e0bfff17 	ldw	r2,-4(fp)
 821b548:	00c00304 	movi	r3,12
 821b54c:	10c00005 	stb	r3,0(r2)
        return (0);
 821b550:	0005883a 	mov	r2,zero
 821b554:	00004206 	br	821b660 <OSTaskNameGet+0x184>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
 821b558:	d0a07903 	ldbu	r2,-32284(gp)
 821b55c:	10803fcc 	andi	r2,r2,255
 821b560:	10000526 	beq	r2,zero,821b578 <OSTaskNameGet+0x9c>
        *perr = OS_ERR_NAME_GET_ISR;
 821b564:	e0bfff17 	ldw	r2,-4(fp)
 821b568:	00c00444 	movi	r3,17
 821b56c:	10c00005 	stb	r3,0(r2)
        return (0);
 821b570:	0005883a 	mov	r2,zero
 821b574:	00003a06 	br	821b660 <OSTaskNameGet+0x184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b578:	0005303a 	rdctl	r2,status
 821b57c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b580:	e0fffc17 	ldw	r3,-16(fp)
 821b584:	00bfff84 	movi	r2,-2
 821b588:	1884703a 	and	r2,r3,r2
 821b58c:	1001703a 	wrctl	status,r2
  
  return context;
 821b590:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821b594:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
 821b598:	e0bffd03 	ldbu	r2,-12(fp)
 821b59c:	10803fd8 	cmpnei	r2,r2,255
 821b5a0:	1000031e 	bne	r2,zero,821b5b0 <OSTaskNameGet+0xd4>
        prio = OSTCBCur->OSTCBPrio;
 821b5a4:	d0a07a17 	ldw	r2,-32280(gp)
 821b5a8:	10800c83 	ldbu	r2,50(r2)
 821b5ac:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821b5b0:	e0fffd03 	ldbu	r3,-12(fp)
 821b5b4:	008209b4 	movhi	r2,2086
 821b5b8:	10b6cb04 	addi	r2,r2,-9428
 821b5bc:	18c7883a 	add	r3,r3,r3
 821b5c0:	18c7883a 	add	r3,r3,r3
 821b5c4:	10c5883a 	add	r2,r2,r3
 821b5c8:	10800017 	ldw	r2,0(r2)
 821b5cc:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
 821b5d0:	e0bff817 	ldw	r2,-32(fp)
 821b5d4:	1000091e 	bne	r2,zero,821b5fc <OSTaskNameGet+0x120>
 821b5d8:	e0bff617 	ldw	r2,-40(fp)
 821b5dc:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b5e0:	e0bff717 	ldw	r2,-36(fp)
 821b5e4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
 821b5e8:	e0bfff17 	ldw	r2,-4(fp)
 821b5ec:	00c010c4 	movi	r3,67
 821b5f0:	10c00005 	stb	r3,0(r2)
        return (0);
 821b5f4:	0005883a 	mov	r2,zero
 821b5f8:	00001906 	br	821b660 <OSTaskNameGet+0x184>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
 821b5fc:	e0bff817 	ldw	r2,-32(fp)
 821b600:	10800058 	cmpnei	r2,r2,1
 821b604:	1000091e 	bne	r2,zero,821b62c <OSTaskNameGet+0x150>
 821b608:	e0bff617 	ldw	r2,-40(fp)
 821b60c:	e0bff915 	stw	r2,-28(fp)
 821b610:	e0bff917 	ldw	r2,-28(fp)
 821b614:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
 821b618:	e0bfff17 	ldw	r2,-4(fp)
 821b61c:	00c010c4 	movi	r3,67
 821b620:	10c00005 	stb	r3,0(r2)
        return (0);
 821b624:	0005883a 	mov	r2,zero
 821b628:	00000d06 	br	821b660 <OSTaskNameGet+0x184>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
 821b62c:	e0bff817 	ldw	r2,-32(fp)
 821b630:	10801304 	addi	r2,r2,76
 821b634:	100b883a 	mov	r5,r2
 821b638:	e13ffe17 	ldw	r4,-8(fp)
 821b63c:	82166c40 	call	82166c4 <OS_StrCopy>
 821b640:	e0bffb05 	stb	r2,-20(fp)
 821b644:	e0bff617 	ldw	r2,-40(fp)
 821b648:	e0bffa15 	stw	r2,-24(fp)
 821b64c:	e0bffa17 	ldw	r2,-24(fp)
 821b650:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 821b654:	e0bfff17 	ldw	r2,-4(fp)
 821b658:	10000005 	stb	zero,0(r2)
    return (len);
 821b65c:	e0bffb03 	ldbu	r2,-20(fp)
}
 821b660:	e037883a 	mov	sp,fp
 821b664:	dfc00117 	ldw	ra,4(sp)
 821b668:	df000017 	ldw	fp,0(sp)
 821b66c:	dec00204 	addi	sp,sp,8
 821b670:	f800283a 	ret

0821b674 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
 821b674:	defff304 	addi	sp,sp,-52
 821b678:	dfc00c15 	stw	ra,48(sp)
 821b67c:	df000b15 	stw	fp,44(sp)
 821b680:	df000b04 	addi	fp,sp,44
 821b684:	2005883a 	mov	r2,r4
 821b688:	e17ffe15 	stw	r5,-8(fp)
 821b68c:	e1bfff15 	stw	r6,-4(fp)
 821b690:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 821b694:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 821b698:	e0bfff17 	ldw	r2,-4(fp)
 821b69c:	10005c26 	beq	r2,zero,821b810 <OSTaskNameSet+0x19c>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
 821b6a0:	e0bffd03 	ldbu	r2,-12(fp)
 821b6a4:	10800570 	cmpltui	r2,r2,21
 821b6a8:	1000071e 	bne	r2,zero,821b6c8 <OSTaskNameSet+0x54>
        if (prio != OS_PRIO_SELF) {
 821b6ac:	e0bffd03 	ldbu	r2,-12(fp)
 821b6b0:	10803fe0 	cmpeqi	r2,r2,255
 821b6b4:	1000041e 	bne	r2,zero,821b6c8 <OSTaskNameSet+0x54>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
 821b6b8:	e0bfff17 	ldw	r2,-4(fp)
 821b6bc:	00c00a84 	movi	r3,42
 821b6c0:	10c00005 	stb	r3,0(r2)
            return;
 821b6c4:	00005306 	br	821b814 <OSTaskNameSet+0x1a0>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
 821b6c8:	e0bffe17 	ldw	r2,-8(fp)
 821b6cc:	1000041e 	bne	r2,zero,821b6e0 <OSTaskNameSet+0x6c>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
 821b6d0:	e0bfff17 	ldw	r2,-4(fp)
 821b6d4:	00c00304 	movi	r3,12
 821b6d8:	10c00005 	stb	r3,0(r2)
        return;
 821b6dc:	00004d06 	br	821b814 <OSTaskNameSet+0x1a0>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
 821b6e0:	d0a07903 	ldbu	r2,-32284(gp)
 821b6e4:	10803fcc 	andi	r2,r2,255
 821b6e8:	10000426 	beq	r2,zero,821b6fc <OSTaskNameSet+0x88>
        *perr = OS_ERR_NAME_SET_ISR;
 821b6ec:	e0bfff17 	ldw	r2,-4(fp)
 821b6f0:	00c00484 	movi	r3,18
 821b6f4:	10c00005 	stb	r3,0(r2)
        return;
 821b6f8:	00004606 	br	821b814 <OSTaskNameSet+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b6fc:	0005303a 	rdctl	r2,status
 821b700:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b704:	e0fffc17 	ldw	r3,-16(fp)
 821b708:	00bfff84 	movi	r2,-2
 821b70c:	1884703a 	and	r2,r3,r2
 821b710:	1001703a 	wrctl	status,r2
  
  return context;
 821b714:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821b718:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
 821b71c:	e0bffd03 	ldbu	r2,-12(fp)
 821b720:	10803fd8 	cmpnei	r2,r2,255
 821b724:	1000031e 	bne	r2,zero,821b734 <OSTaskNameSet+0xc0>
        prio = OSTCBCur->OSTCBPrio;
 821b728:	d0a07a17 	ldw	r2,-32280(gp)
 821b72c:	10800c83 	ldbu	r2,50(r2)
 821b730:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821b734:	e0fffd03 	ldbu	r3,-12(fp)
 821b738:	008209b4 	movhi	r2,2086
 821b73c:	10b6cb04 	addi	r2,r2,-9428
 821b740:	18c7883a 	add	r3,r3,r3
 821b744:	18c7883a 	add	r3,r3,r3
 821b748:	10c5883a 	add	r2,r2,r3
 821b74c:	10800017 	ldw	r2,0(r2)
 821b750:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
 821b754:	e0bff717 	ldw	r2,-36(fp)
 821b758:	1000081e 	bne	r2,zero,821b77c <OSTaskNameSet+0x108>
 821b75c:	e0bff517 	ldw	r2,-44(fp)
 821b760:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b764:	e0bff617 	ldw	r2,-40(fp)
 821b768:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
 821b76c:	e0bfff17 	ldw	r2,-4(fp)
 821b770:	00c010c4 	movi	r3,67
 821b774:	10c00005 	stb	r3,0(r2)
        return;
 821b778:	00002606 	br	821b814 <OSTaskNameSet+0x1a0>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
 821b77c:	e0bff717 	ldw	r2,-36(fp)
 821b780:	10800058 	cmpnei	r2,r2,1
 821b784:	1000081e 	bne	r2,zero,821b7a8 <OSTaskNameSet+0x134>
 821b788:	e0bff517 	ldw	r2,-44(fp)
 821b78c:	e0bff815 	stw	r2,-32(fp)
 821b790:	e0bff817 	ldw	r2,-32(fp)
 821b794:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
 821b798:	e0bfff17 	ldw	r2,-4(fp)
 821b79c:	00c010c4 	movi	r3,67
 821b7a0:	10c00005 	stb	r3,0(r2)
        return;
 821b7a4:	00001b06 	br	821b814 <OSTaskNameSet+0x1a0>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
 821b7a8:	e13ffe17 	ldw	r4,-8(fp)
 821b7ac:	82167380 	call	8216738 <OS_StrLen>
 821b7b0:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
 821b7b4:	e0bffa03 	ldbu	r2,-24(fp)
 821b7b8:	10800830 	cmpltui	r2,r2,32
 821b7bc:	1000081e 	bne	r2,zero,821b7e0 <OSTaskNameSet+0x16c>
 821b7c0:	e0bff517 	ldw	r2,-44(fp)
 821b7c4:	e0bff915 	stw	r2,-28(fp)
 821b7c8:	e0bff917 	ldw	r2,-28(fp)
 821b7cc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
 821b7d0:	e0bfff17 	ldw	r2,-4(fp)
 821b7d4:	00c01044 	movi	r3,65
 821b7d8:	10c00005 	stb	r3,0(r2)
        return;
 821b7dc:	00000d06 	br	821b814 <OSTaskNameSet+0x1a0>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
 821b7e0:	e0bff717 	ldw	r2,-36(fp)
 821b7e4:	10801304 	addi	r2,r2,76
 821b7e8:	e17ffe17 	ldw	r5,-8(fp)
 821b7ec:	1009883a 	mov	r4,r2
 821b7f0:	82166c40 	call	82166c4 <OS_StrCopy>
 821b7f4:	e0bff517 	ldw	r2,-44(fp)
 821b7f8:	e0bffb15 	stw	r2,-20(fp)
 821b7fc:	e0bffb17 	ldw	r2,-20(fp)
 821b800:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 821b804:	e0bfff17 	ldw	r2,-4(fp)
 821b808:	10000005 	stb	zero,0(r2)
 821b80c:	00000106 	br	821b814 <OSTaskNameSet+0x1a0>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
 821b810:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
 821b814:	e037883a 	mov	sp,fp
 821b818:	dfc00117 	ldw	ra,4(sp)
 821b81c:	df000017 	ldw	fp,0(sp)
 821b820:	dec00204 	addi	sp,sp,8
 821b824:	f800283a 	ret

0821b828 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
 821b828:	defff404 	addi	sp,sp,-48
 821b82c:	dfc00b15 	stw	ra,44(sp)
 821b830:	df000a15 	stw	fp,40(sp)
 821b834:	df000a04 	addi	fp,sp,40
 821b838:	2005883a 	mov	r2,r4
 821b83c:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 821b840:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
 821b844:	e0bfff03 	ldbu	r2,-4(fp)
 821b848:	10800530 	cmpltui	r2,r2,20
 821b84c:	1000021e 	bne	r2,zero,821b858 <OSTaskResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 821b850:	00800a84 	movi	r2,42
 821b854:	00006406 	br	821b9e8 <OSTaskResume+0x1c0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b858:	0005303a 	rdctl	r2,status
 821b85c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b860:	e0fffe17 	ldw	r3,-8(fp)
 821b864:	00bfff84 	movi	r2,-2
 821b868:	1884703a 	and	r2,r3,r2
 821b86c:	1001703a 	wrctl	status,r2
  
  return context;
 821b870:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821b874:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
 821b878:	e0ffff03 	ldbu	r3,-4(fp)
 821b87c:	008209b4 	movhi	r2,2086
 821b880:	10b6cb04 	addi	r2,r2,-9428
 821b884:	18c7883a 	add	r3,r3,r3
 821b888:	18c7883a 	add	r3,r3,r3
 821b88c:	10c5883a 	add	r2,r2,r3
 821b890:	10800017 	ldw	r2,0(r2)
 821b894:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
 821b898:	e0bff817 	ldw	r2,-32(fp)
 821b89c:	1000061e 	bne	r2,zero,821b8b8 <OSTaskResume+0x90>
 821b8a0:	e0bff617 	ldw	r2,-40(fp)
 821b8a4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b8a8:	e0bff717 	ldw	r2,-36(fp)
 821b8ac:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
 821b8b0:	00801184 	movi	r2,70
 821b8b4:	00004c06 	br	821b9e8 <OSTaskResume+0x1c0>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
 821b8b8:	e0bff817 	ldw	r2,-32(fp)
 821b8bc:	10800058 	cmpnei	r2,r2,1
 821b8c0:	1000061e 	bne	r2,zero,821b8dc <OSTaskResume+0xb4>
 821b8c4:	e0bff617 	ldw	r2,-40(fp)
 821b8c8:	e0bff915 	stw	r2,-28(fp)
 821b8cc:	e0bff917 	ldw	r2,-28(fp)
 821b8d0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821b8d4:	008010c4 	movi	r2,67
 821b8d8:	00004306 	br	821b9e8 <OSTaskResume+0x1c0>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
 821b8dc:	e0bff817 	ldw	r2,-32(fp)
 821b8e0:	10800c03 	ldbu	r2,48(r2)
 821b8e4:	10803fcc 	andi	r2,r2,255
 821b8e8:	1080020c 	andi	r2,r2,8
 821b8ec:	10003926 	beq	r2,zero,821b9d4 <OSTaskResume+0x1ac>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
 821b8f0:	e0bff817 	ldw	r2,-32(fp)
 821b8f4:	10c00c03 	ldbu	r3,48(r2)
 821b8f8:	00bffdc4 	movi	r2,-9
 821b8fc:	1884703a 	and	r2,r3,r2
 821b900:	1007883a 	mov	r3,r2
 821b904:	e0bff817 	ldw	r2,-32(fp)
 821b908:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
 821b90c:	e0bff817 	ldw	r2,-32(fp)
 821b910:	10800c03 	ldbu	r2,48(r2)
 821b914:	10803fcc 	andi	r2,r2,255
 821b918:	1000281e 	bne	r2,zero,821b9bc <OSTaskResume+0x194>
            if (ptcb->OSTCBDly == 0) {
 821b91c:	e0bff817 	ldw	r2,-32(fp)
 821b920:	10800b8b 	ldhu	r2,46(r2)
 821b924:	10bfffcc 	andi	r2,r2,65535
 821b928:	10001f1e 	bne	r2,zero,821b9a8 <OSTaskResume+0x180>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
 821b92c:	e0bff817 	ldw	r2,-32(fp)
 821b930:	10c00d83 	ldbu	r3,54(r2)
 821b934:	d0a07703 	ldbu	r2,-32292(gp)
 821b938:	1884b03a 	or	r2,r3,r2
 821b93c:	d0a07705 	stb	r2,-32292(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 821b940:	e0bff817 	ldw	r2,-32(fp)
 821b944:	10800d03 	ldbu	r2,52(r2)
 821b948:	10c03fcc 	andi	r3,r2,255
 821b94c:	e0bff817 	ldw	r2,-32(fp)
 821b950:	10800d03 	ldbu	r2,52(r2)
 821b954:	11003fcc 	andi	r4,r2,255
 821b958:	d0a07744 	addi	r2,gp,-32291
 821b95c:	2085883a 	add	r2,r4,r2
 821b960:	11000003 	ldbu	r4,0(r2)
 821b964:	e0bff817 	ldw	r2,-32(fp)
 821b968:	10800d43 	ldbu	r2,53(r2)
 821b96c:	2084b03a 	or	r2,r4,r2
 821b970:	1009883a 	mov	r4,r2
 821b974:	d0a07744 	addi	r2,gp,-32291
 821b978:	1885883a 	add	r2,r3,r2
 821b97c:	11000005 	stb	r4,0(r2)
 821b980:	e0bff617 	ldw	r2,-40(fp)
 821b984:	e0bffa15 	stw	r2,-24(fp)
 821b988:	e0bffa17 	ldw	r2,-24(fp)
 821b98c:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
 821b990:	d0a06b43 	ldbu	r2,-32339(gp)
 821b994:	10803fcc 	andi	r2,r2,255
 821b998:	10800058 	cmpnei	r2,r2,1
 821b99c:	10000b1e 	bne	r2,zero,821b9cc <OSTaskResume+0x1a4>
                    OS_Sched();                               /* Find new highest priority task        */
 821b9a0:	82165800 	call	8216580 <OS_Sched>
 821b9a4:	00000906 	br	821b9cc <OSTaskResume+0x1a4>
 821b9a8:	e0bff617 	ldw	r2,-40(fp)
 821b9ac:	e0bffb15 	stw	r2,-20(fp)
 821b9b0:	e0bffb17 	ldw	r2,-20(fp)
 821b9b4:	1001703a 	wrctl	status,r2
 821b9b8:	00000406 	br	821b9cc <OSTaskResume+0x1a4>
 821b9bc:	e0bff617 	ldw	r2,-40(fp)
 821b9c0:	e0bffc15 	stw	r2,-16(fp)
 821b9c4:	e0bffc17 	ldw	r2,-16(fp)
 821b9c8:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
 821b9cc:	0005883a 	mov	r2,zero
 821b9d0:	00000506 	br	821b9e8 <OSTaskResume+0x1c0>
 821b9d4:	e0bff617 	ldw	r2,-40(fp)
 821b9d8:	e0bffd15 	stw	r2,-12(fp)
 821b9dc:	e0bffd17 	ldw	r2,-12(fp)
 821b9e0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
 821b9e4:	00801104 	movi	r2,68
}
 821b9e8:	e037883a 	mov	sp,fp
 821b9ec:	dfc00117 	ldw	ra,4(sp)
 821b9f0:	df000017 	ldw	fp,0(sp)
 821b9f4:	dec00204 	addi	sp,sp,8
 821b9f8:	f800283a 	ret

0821b9fc <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
 821b9fc:	defff304 	addi	sp,sp,-52
 821ba00:	df000c15 	stw	fp,48(sp)
 821ba04:	df000c04 	addi	fp,sp,48
 821ba08:	2005883a 	mov	r2,r4
 821ba0c:	e17fff15 	stw	r5,-4(fp)
 821ba10:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 821ba14:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
 821ba18:	e0bffe03 	ldbu	r2,-8(fp)
 821ba1c:	10800570 	cmpltui	r2,r2,21
 821ba20:	1000051e 	bne	r2,zero,821ba38 <OSTaskStkChk+0x3c>
        if (prio != OS_PRIO_SELF) {
 821ba24:	e0bffe03 	ldbu	r2,-8(fp)
 821ba28:	10803fe0 	cmpeqi	r2,r2,255
 821ba2c:	1000021e 	bne	r2,zero,821ba38 <OSTaskStkChk+0x3c>
            return (OS_ERR_PRIO_INVALID);
 821ba30:	00800a84 	movi	r2,42
 821ba34:	00005d06 	br	821bbac <OSTaskStkChk+0x1b0>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
 821ba38:	e0bfff17 	ldw	r2,-4(fp)
 821ba3c:	1000021e 	bne	r2,zero,821ba48 <OSTaskStkChk+0x4c>
        return (OS_ERR_PDATA_NULL);
 821ba40:	00800244 	movi	r2,9
 821ba44:	00005906 	br	821bbac <OSTaskStkChk+0x1b0>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
 821ba48:	e0bfff17 	ldw	r2,-4(fp)
 821ba4c:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
 821ba50:	e0bfff17 	ldw	r2,-4(fp)
 821ba54:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821ba58:	0005303a 	rdctl	r2,status
 821ba5c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821ba60:	e0fffd17 	ldw	r3,-12(fp)
 821ba64:	00bfff84 	movi	r2,-2
 821ba68:	1884703a 	and	r2,r3,r2
 821ba6c:	1001703a 	wrctl	status,r2
  
  return context;
 821ba70:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
 821ba74:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
 821ba78:	e0bffe03 	ldbu	r2,-8(fp)
 821ba7c:	10803fd8 	cmpnei	r2,r2,255
 821ba80:	1000031e 	bne	r2,zero,821ba90 <OSTaskStkChk+0x94>
        prio = OSTCBCur->OSTCBPrio;
 821ba84:	d0a07a17 	ldw	r2,-32280(gp)
 821ba88:	10800c83 	ldbu	r2,50(r2)
 821ba8c:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821ba90:	e0fffe03 	ldbu	r3,-8(fp)
 821ba94:	008209b4 	movhi	r2,2086
 821ba98:	10b6cb04 	addi	r2,r2,-9428
 821ba9c:	18c7883a 	add	r3,r3,r3
 821baa0:	18c7883a 	add	r3,r3,r3
 821baa4:	10c5883a 	add	r2,r2,r3
 821baa8:	10800017 	ldw	r2,0(r2)
 821baac:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
 821bab0:	e0bff817 	ldw	r2,-32(fp)
 821bab4:	1000061e 	bne	r2,zero,821bad0 <OSTaskStkChk+0xd4>
 821bab8:	e0bff617 	ldw	r2,-40(fp)
 821babc:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821bac0:	e0bff717 	ldw	r2,-36(fp)
 821bac4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821bac8:	008010c4 	movi	r2,67
 821bacc:	00003706 	br	821bbac <OSTaskStkChk+0x1b0>
    }
    if (ptcb == OS_TCB_RESERVED) {
 821bad0:	e0bff817 	ldw	r2,-32(fp)
 821bad4:	10800058 	cmpnei	r2,r2,1
 821bad8:	1000061e 	bne	r2,zero,821baf4 <OSTaskStkChk+0xf8>
 821badc:	e0bff617 	ldw	r2,-40(fp)
 821bae0:	e0bff915 	stw	r2,-28(fp)
 821bae4:	e0bff917 	ldw	r2,-28(fp)
 821bae8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821baec:	008010c4 	movi	r2,67
 821baf0:	00002e06 	br	821bbac <OSTaskStkChk+0x1b0>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
 821baf4:	e0bff817 	ldw	r2,-32(fp)
 821baf8:	1080040b 	ldhu	r2,16(r2)
 821bafc:	10bfffcc 	andi	r2,r2,65535
 821bb00:	1080004c 	andi	r2,r2,1
 821bb04:	1000061e 	bne	r2,zero,821bb20 <OSTaskStkChk+0x124>
 821bb08:	e0bff617 	ldw	r2,-40(fp)
 821bb0c:	e0bffa15 	stw	r2,-24(fp)
 821bb10:	e0bffa17 	ldw	r2,-24(fp)
 821bb14:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
 821bb18:	00801144 	movi	r2,69
 821bb1c:	00002306 	br	821bbac <OSTaskStkChk+0x1b0>
    }
    nfree = 0;
 821bb20:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
 821bb24:	e0bff817 	ldw	r2,-32(fp)
 821bb28:	10800317 	ldw	r2,12(r2)
 821bb2c:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
 821bb30:	e0bff817 	ldw	r2,-32(fp)
 821bb34:	10800217 	ldw	r2,8(r2)
 821bb38:	e0bff415 	stw	r2,-48(fp)
 821bb3c:	e0bff617 	ldw	r2,-40(fp)
 821bb40:	e0bffb15 	stw	r2,-20(fp)
 821bb44:	e0bffb17 	ldw	r2,-20(fp)
 821bb48:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 821bb4c:	00000306 	br	821bb5c <OSTaskStkChk+0x160>
        nfree++;
 821bb50:	e0bff517 	ldw	r2,-44(fp)
 821bb54:	10800044 	addi	r2,r2,1
 821bb58:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 821bb5c:	e0bff417 	ldw	r2,-48(fp)
 821bb60:	10c00104 	addi	r3,r2,4
 821bb64:	e0fff415 	stw	r3,-48(fp)
 821bb68:	10800017 	ldw	r2,0(r2)
 821bb6c:	103ff826 	beq	r2,zero,821bb50 <OSTaskStkChk+0x154>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
 821bb70:	e0bff517 	ldw	r2,-44(fp)
 821bb74:	1085883a 	add	r2,r2,r2
 821bb78:	1085883a 	add	r2,r2,r2
 821bb7c:	1007883a 	mov	r3,r2
 821bb80:	e0bfff17 	ldw	r2,-4(fp)
 821bb84:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
 821bb88:	e0fffc17 	ldw	r3,-16(fp)
 821bb8c:	e0bff517 	ldw	r2,-44(fp)
 821bb90:	1885c83a 	sub	r2,r3,r2
 821bb94:	1085883a 	add	r2,r2,r2
 821bb98:	1085883a 	add	r2,r2,r2
 821bb9c:	1007883a 	mov	r3,r2
 821bba0:	e0bfff17 	ldw	r2,-4(fp)
 821bba4:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
 821bba8:	0005883a 	mov	r2,zero
}
 821bbac:	e037883a 	mov	sp,fp
 821bbb0:	df000017 	ldw	fp,0(sp)
 821bbb4:	dec00104 	addi	sp,sp,4
 821bbb8:	f800283a 	ret

0821bbbc <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
 821bbbc:	defff504 	addi	sp,sp,-44
 821bbc0:	dfc00a15 	stw	ra,40(sp)
 821bbc4:	df000915 	stw	fp,36(sp)
 821bbc8:	df000904 	addi	fp,sp,36
 821bbcc:	2005883a 	mov	r2,r4
 821bbd0:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821bbd4:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
 821bbd8:	e0bfff03 	ldbu	r2,-4(fp)
 821bbdc:	10800518 	cmpnei	r2,r2,20
 821bbe0:	1000021e 	bne	r2,zero,821bbec <OSTaskSuspend+0x30>
        return (OS_ERR_TASK_SUSPEND_IDLE);
 821bbe4:	008011c4 	movi	r2,71
 821bbe8:	00006806 	br	821bd8c <OSTaskSuspend+0x1d0>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 821bbec:	e0bfff03 	ldbu	r2,-4(fp)
 821bbf0:	10800530 	cmpltui	r2,r2,20
 821bbf4:	1000051e 	bne	r2,zero,821bc0c <OSTaskSuspend+0x50>
        if (prio != OS_PRIO_SELF) {
 821bbf8:	e0bfff03 	ldbu	r2,-4(fp)
 821bbfc:	10803fe0 	cmpeqi	r2,r2,255
 821bc00:	1000021e 	bne	r2,zero,821bc0c <OSTaskSuspend+0x50>
            return (OS_ERR_PRIO_INVALID);
 821bc04:	00800a84 	movi	r2,42
 821bc08:	00006006 	br	821bd8c <OSTaskSuspend+0x1d0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821bc0c:	0005303a 	rdctl	r2,status
 821bc10:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821bc14:	e0fffe17 	ldw	r3,-8(fp)
 821bc18:	00bfff84 	movi	r2,-2
 821bc1c:	1884703a 	and	r2,r3,r2
 821bc20:	1001703a 	wrctl	status,r2
  
  return context;
 821bc24:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
 821bc28:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
 821bc2c:	e0bfff03 	ldbu	r2,-4(fp)
 821bc30:	10803fd8 	cmpnei	r2,r2,255
 821bc34:	1000061e 	bne	r2,zero,821bc50 <OSTaskSuspend+0x94>
        prio = OSTCBCur->OSTCBPrio;
 821bc38:	d0a07a17 	ldw	r2,-32280(gp)
 821bc3c:	10800c83 	ldbu	r2,50(r2)
 821bc40:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
 821bc44:	00800044 	movi	r2,1
 821bc48:	e0bff705 	stb	r2,-36(fp)
 821bc4c:	00000906 	br	821bc74 <OSTaskSuspend+0xb8>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
 821bc50:	d0a07a17 	ldw	r2,-32280(gp)
 821bc54:	10800c83 	ldbu	r2,50(r2)
 821bc58:	10c03fcc 	andi	r3,r2,255
 821bc5c:	e0bfff03 	ldbu	r2,-4(fp)
 821bc60:	1880031e 	bne	r3,r2,821bc70 <OSTaskSuspend+0xb4>
        self = OS_TRUE;
 821bc64:	00800044 	movi	r2,1
 821bc68:	e0bff705 	stb	r2,-36(fp)
 821bc6c:	00000106 	br	821bc74 <OSTaskSuspend+0xb8>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
 821bc70:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821bc74:	e0ffff03 	ldbu	r3,-4(fp)
 821bc78:	008209b4 	movhi	r2,2086
 821bc7c:	10b6cb04 	addi	r2,r2,-9428
 821bc80:	18c7883a 	add	r3,r3,r3
 821bc84:	18c7883a 	add	r3,r3,r3
 821bc88:	10c5883a 	add	r2,r2,r3
 821bc8c:	10800017 	ldw	r2,0(r2)
 821bc90:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
 821bc94:	e0bffa17 	ldw	r2,-24(fp)
 821bc98:	1000061e 	bne	r2,zero,821bcb4 <OSTaskSuspend+0xf8>
 821bc9c:	e0bff817 	ldw	r2,-32(fp)
 821bca0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821bca4:	e0bff917 	ldw	r2,-28(fp)
 821bca8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
 821bcac:	00801204 	movi	r2,72
 821bcb0:	00003606 	br	821bd8c <OSTaskSuspend+0x1d0>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
 821bcb4:	e0bffa17 	ldw	r2,-24(fp)
 821bcb8:	10800058 	cmpnei	r2,r2,1
 821bcbc:	1000061e 	bne	r2,zero,821bcd8 <OSTaskSuspend+0x11c>
 821bcc0:	e0bff817 	ldw	r2,-32(fp)
 821bcc4:	e0bffb15 	stw	r2,-20(fp)
 821bcc8:	e0bffb17 	ldw	r2,-20(fp)
 821bccc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821bcd0:	008010c4 	movi	r2,67
 821bcd4:	00002d06 	br	821bd8c <OSTaskSuspend+0x1d0>
    }
    y            = ptcb->OSTCBY;
 821bcd8:	e0bffa17 	ldw	r2,-24(fp)
 821bcdc:	10800d03 	ldbu	r2,52(r2)
 821bce0:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
 821bce4:	e0fffd03 	ldbu	r3,-12(fp)
 821bce8:	e13ffd03 	ldbu	r4,-12(fp)
 821bcec:	d0a07744 	addi	r2,gp,-32291
 821bcf0:	2085883a 	add	r2,r4,r2
 821bcf4:	10800003 	ldbu	r2,0(r2)
 821bcf8:	1009883a 	mov	r4,r2
 821bcfc:	e0bffa17 	ldw	r2,-24(fp)
 821bd00:	10800d43 	ldbu	r2,53(r2)
 821bd04:	0084303a 	nor	r2,zero,r2
 821bd08:	2084703a 	and	r2,r4,r2
 821bd0c:	1009883a 	mov	r4,r2
 821bd10:	d0a07744 	addi	r2,gp,-32291
 821bd14:	1885883a 	add	r2,r3,r2
 821bd18:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
 821bd1c:	e0fffd03 	ldbu	r3,-12(fp)
 821bd20:	d0a07744 	addi	r2,gp,-32291
 821bd24:	1885883a 	add	r2,r3,r2
 821bd28:	10800003 	ldbu	r2,0(r2)
 821bd2c:	10803fcc 	andi	r2,r2,255
 821bd30:	1000071e 	bne	r2,zero,821bd50 <OSTaskSuspend+0x194>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
 821bd34:	e0bffa17 	ldw	r2,-24(fp)
 821bd38:	10800d83 	ldbu	r2,54(r2)
 821bd3c:	0084303a 	nor	r2,zero,r2
 821bd40:	1007883a 	mov	r3,r2
 821bd44:	d0a07703 	ldbu	r2,-32292(gp)
 821bd48:	1884703a 	and	r2,r3,r2
 821bd4c:	d0a07705 	stb	r2,-32292(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
 821bd50:	e0bffa17 	ldw	r2,-24(fp)
 821bd54:	10800c03 	ldbu	r2,48(r2)
 821bd58:	10800214 	ori	r2,r2,8
 821bd5c:	1007883a 	mov	r3,r2
 821bd60:	e0bffa17 	ldw	r2,-24(fp)
 821bd64:	10c00c05 	stb	r3,48(r2)
 821bd68:	e0bff817 	ldw	r2,-32(fp)
 821bd6c:	e0bffc15 	stw	r2,-16(fp)
 821bd70:	e0bffc17 	ldw	r2,-16(fp)
 821bd74:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
 821bd78:	e0bff703 	ldbu	r2,-36(fp)
 821bd7c:	10800058 	cmpnei	r2,r2,1
 821bd80:	1000011e 	bne	r2,zero,821bd88 <OSTaskSuspend+0x1cc>
        OS_Sched();                                             /* Find new highest priority task      */
 821bd84:	82165800 	call	8216580 <OS_Sched>
    }
    return (OS_ERR_NONE);
 821bd88:	0005883a 	mov	r2,zero
}
 821bd8c:	e037883a 	mov	sp,fp
 821bd90:	dfc00117 	ldw	ra,4(sp)
 821bd94:	df000017 	ldw	fp,0(sp)
 821bd98:	dec00204 	addi	sp,sp,8
 821bd9c:	f800283a 	ret

0821bda0 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
 821bda0:	defff604 	addi	sp,sp,-40
 821bda4:	dfc00915 	stw	ra,36(sp)
 821bda8:	df000815 	stw	fp,32(sp)
 821bdac:	df000804 	addi	fp,sp,32
 821bdb0:	2005883a 	mov	r2,r4
 821bdb4:	e17fff15 	stw	r5,-4(fp)
 821bdb8:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821bdbc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
 821bdc0:	e0bffe03 	ldbu	r2,-8(fp)
 821bdc4:	10800570 	cmpltui	r2,r2,21
 821bdc8:	1000051e 	bne	r2,zero,821bde0 <OSTaskQuery+0x40>
        if (prio != OS_PRIO_SELF) {
 821bdcc:	e0bffe03 	ldbu	r2,-8(fp)
 821bdd0:	10803fe0 	cmpeqi	r2,r2,255
 821bdd4:	1000021e 	bne	r2,zero,821bde0 <OSTaskQuery+0x40>
            return (OS_ERR_PRIO_INVALID);
 821bdd8:	00800a84 	movi	r2,42
 821bddc:	00003406 	br	821beb0 <OSTaskQuery+0x110>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
 821bde0:	e0bfff17 	ldw	r2,-4(fp)
 821bde4:	1000021e 	bne	r2,zero,821bdf0 <OSTaskQuery+0x50>
        return (OS_ERR_PDATA_NULL);
 821bde8:	00800244 	movi	r2,9
 821bdec:	00003006 	br	821beb0 <OSTaskQuery+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821bdf0:	0005303a 	rdctl	r2,status
 821bdf4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821bdf8:	e0fffd17 	ldw	r3,-12(fp)
 821bdfc:	00bfff84 	movi	r2,-2
 821be00:	1884703a 	and	r2,r3,r2
 821be04:	1001703a 	wrctl	status,r2
  
  return context;
 821be08:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821be0c:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
 821be10:	e0bffe03 	ldbu	r2,-8(fp)
 821be14:	10803fd8 	cmpnei	r2,r2,255
 821be18:	1000031e 	bne	r2,zero,821be28 <OSTaskQuery+0x88>
        prio = OSTCBCur->OSTCBPrio;
 821be1c:	d0a07a17 	ldw	r2,-32280(gp)
 821be20:	10800c83 	ldbu	r2,50(r2)
 821be24:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821be28:	e0fffe03 	ldbu	r3,-8(fp)
 821be2c:	008209b4 	movhi	r2,2086
 821be30:	10b6cb04 	addi	r2,r2,-9428
 821be34:	18c7883a 	add	r3,r3,r3
 821be38:	18c7883a 	add	r3,r3,r3
 821be3c:	10c5883a 	add	r2,r2,r3
 821be40:	10800017 	ldw	r2,0(r2)
 821be44:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
 821be48:	e0bffa17 	ldw	r2,-24(fp)
 821be4c:	1000061e 	bne	r2,zero,821be68 <OSTaskQuery+0xc8>
 821be50:	e0bff817 	ldw	r2,-32(fp)
 821be54:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821be58:	e0bff917 	ldw	r2,-28(fp)
 821be5c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
 821be60:	00800a44 	movi	r2,41
 821be64:	00001206 	br	821beb0 <OSTaskQuery+0x110>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
 821be68:	e0bffa17 	ldw	r2,-24(fp)
 821be6c:	10800058 	cmpnei	r2,r2,1
 821be70:	1000061e 	bne	r2,zero,821be8c <OSTaskQuery+0xec>
 821be74:	e0bff817 	ldw	r2,-32(fp)
 821be78:	e0bffb15 	stw	r2,-20(fp)
 821be7c:	e0bffb17 	ldw	r2,-20(fp)
 821be80:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821be84:	008010c4 	movi	r2,67
 821be88:	00000906 	br	821beb0 <OSTaskQuery+0x110>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
 821be8c:	01801b04 	movi	r6,108
 821be90:	e17ffa17 	ldw	r5,-24(fp)
 821be94:	e13fff17 	ldw	r4,-4(fp)
 821be98:	82165180 	call	8216518 <OS_MemCopy>
 821be9c:	e0bff817 	ldw	r2,-32(fp)
 821bea0:	e0bffc15 	stw	r2,-16(fp)
 821bea4:	e0bffc17 	ldw	r2,-16(fp)
 821bea8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 821beac:	0005883a 	mov	r2,zero
}
 821beb0:	e037883a 	mov	sp,fp
 821beb4:	dfc00117 	ldw	ra,4(sp)
 821beb8:	df000017 	ldw	fp,0(sp)
 821bebc:	dec00204 	addi	sp,sp,8
 821bec0:	f800283a 	ret

0821bec4 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
 821bec4:	defffc04 	addi	sp,sp,-16
 821bec8:	df000315 	stw	fp,12(sp)
 821becc:	df000304 	addi	fp,sp,12
 821bed0:	e13ffd15 	stw	r4,-12(fp)
 821bed4:	e17ffe15 	stw	r5,-8(fp)
 821bed8:	3005883a 	mov	r2,r6
 821bedc:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
 821bee0:	e0bfff0b 	ldhu	r2,-4(fp)
 821bee4:	1080004c 	andi	r2,r2,1
 821bee8:	10000d26 	beq	r2,zero,821bf20 <OS_TaskStkClr+0x5c>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
 821beec:	e0bfff0b 	ldhu	r2,-4(fp)
 821bef0:	1080008c 	andi	r2,r2,2
 821bef4:	10000a26 	beq	r2,zero,821bf20 <OS_TaskStkClr+0x5c>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 821bef8:	00000706 	br	821bf18 <OS_TaskStkClr+0x54>
                size--;
 821befc:	e0bffe17 	ldw	r2,-8(fp)
 821bf00:	10bfffc4 	addi	r2,r2,-1
 821bf04:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
 821bf08:	e0bffd17 	ldw	r2,-12(fp)
 821bf0c:	10c00104 	addi	r3,r2,4
 821bf10:	e0fffd15 	stw	r3,-12(fp)
 821bf14:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 821bf18:	e0bffe17 	ldw	r2,-8(fp)
 821bf1c:	103ff71e 	bne	r2,zero,821befc <OS_TaskStkClr+0x38>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
 821bf20:	0001883a 	nop
 821bf24:	e037883a 	mov	sp,fp
 821bf28:	df000017 	ldw	fp,0(sp)
 821bf2c:	dec00104 	addi	sp,sp,4
 821bf30:	f800283a 	ret

0821bf34 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
 821bf34:	defff904 	addi	sp,sp,-28
 821bf38:	dfc00615 	stw	ra,24(sp)
 821bf3c:	df000515 	stw	fp,20(sp)
 821bf40:	df000504 	addi	fp,sp,20
 821bf44:	2005883a 	mov	r2,r4
 821bf48:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821bf4c:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 821bf50:	d0a07903 	ldbu	r2,-32284(gp)
 821bf54:	10803fcc 	andi	r2,r2,255
 821bf58:	1000311e 	bne	r2,zero,821c020 <OSTimeDly+0xec>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
 821bf5c:	e0bfff0b 	ldhu	r2,-4(fp)
 821bf60:	10003026 	beq	r2,zero,821c024 <OSTimeDly+0xf0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821bf64:	0005303a 	rdctl	r2,status
 821bf68:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821bf6c:	e0fffe17 	ldw	r3,-8(fp)
 821bf70:	00bfff84 	movi	r2,-2
 821bf74:	1884703a 	and	r2,r3,r2
 821bf78:	1001703a 	wrctl	status,r2
  
  return context;
 821bf7c:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 821bf80:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
 821bf84:	d0a07a17 	ldw	r2,-32280(gp)
 821bf88:	10800d03 	ldbu	r2,52(r2)
 821bf8c:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 821bf90:	e0fffd03 	ldbu	r3,-12(fp)
 821bf94:	e13ffd03 	ldbu	r4,-12(fp)
 821bf98:	d0a07744 	addi	r2,gp,-32291
 821bf9c:	2085883a 	add	r2,r4,r2
 821bfa0:	10800003 	ldbu	r2,0(r2)
 821bfa4:	1009883a 	mov	r4,r2
 821bfa8:	d0a07a17 	ldw	r2,-32280(gp)
 821bfac:	10800d43 	ldbu	r2,53(r2)
 821bfb0:	0084303a 	nor	r2,zero,r2
 821bfb4:	2084703a 	and	r2,r4,r2
 821bfb8:	1009883a 	mov	r4,r2
 821bfbc:	d0a07744 	addi	r2,gp,-32291
 821bfc0:	1885883a 	add	r2,r3,r2
 821bfc4:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
 821bfc8:	e0fffd03 	ldbu	r3,-12(fp)
 821bfcc:	d0a07744 	addi	r2,gp,-32291
 821bfd0:	1885883a 	add	r2,r3,r2
 821bfd4:	10800003 	ldbu	r2,0(r2)
 821bfd8:	10803fcc 	andi	r2,r2,255
 821bfdc:	1000071e 	bne	r2,zero,821bffc <OSTimeDly+0xc8>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 821bfe0:	d0a07a17 	ldw	r2,-32280(gp)
 821bfe4:	10800d83 	ldbu	r2,54(r2)
 821bfe8:	0084303a 	nor	r2,zero,r2
 821bfec:	1007883a 	mov	r3,r2
 821bff0:	d0a07703 	ldbu	r2,-32292(gp)
 821bff4:	1884703a 	and	r2,r3,r2
 821bff8:	d0a07705 	stb	r2,-32292(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
 821bffc:	d0a07a17 	ldw	r2,-32280(gp)
 821c000:	e0ffff0b 	ldhu	r3,-4(fp)
 821c004:	10c00b8d 	sth	r3,46(r2)
 821c008:	e0bffb17 	ldw	r2,-20(fp)
 821c00c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821c010:	e0bffc17 	ldw	r2,-16(fp)
 821c014:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
 821c018:	82165800 	call	8216580 <OS_Sched>
 821c01c:	00000106 	br	821c024 <OSTimeDly+0xf0>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
 821c020:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
 821c024:	e037883a 	mov	sp,fp
 821c028:	dfc00117 	ldw	ra,4(sp)
 821c02c:	df000017 	ldw	fp,0(sp)
 821c030:	dec00204 	addi	sp,sp,8
 821c034:	f800283a 	ret

0821c038 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
 821c038:	defff804 	addi	sp,sp,-32
 821c03c:	dfc00715 	stw	ra,28(sp)
 821c040:	df000615 	stw	fp,24(sp)
 821c044:	df000604 	addi	fp,sp,24
 821c048:	2015883a 	mov	r10,r4
 821c04c:	2809883a 	mov	r4,r5
 821c050:	3007883a 	mov	r3,r6
 821c054:	3805883a 	mov	r2,r7
 821c058:	e2bffc05 	stb	r10,-16(fp)
 821c05c:	e13ffd05 	stb	r4,-12(fp)
 821c060:	e0fffe05 	stb	r3,-8(fp)
 821c064:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 821c068:	d0a07903 	ldbu	r2,-32284(gp)
 821c06c:	10803fcc 	andi	r2,r2,255
 821c070:	10000226 	beq	r2,zero,821c07c <OSTimeDlyHMSM+0x44>
        return (OS_ERR_TIME_DLY_ISR);
 821c074:	00801544 	movi	r2,85
 821c078:	00004206 	br	821c184 <OSTimeDlyHMSM+0x14c>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
 821c07c:	e0bffc03 	ldbu	r2,-16(fp)
 821c080:	1000081e 	bne	r2,zero,821c0a4 <OSTimeDlyHMSM+0x6c>
        if (minutes == 0) {
 821c084:	e0bffd03 	ldbu	r2,-12(fp)
 821c088:	1000061e 	bne	r2,zero,821c0a4 <OSTimeDlyHMSM+0x6c>
            if (seconds == 0) {
 821c08c:	e0bffe03 	ldbu	r2,-8(fp)
 821c090:	1000041e 	bne	r2,zero,821c0a4 <OSTimeDlyHMSM+0x6c>
                if (ms == 0) {
 821c094:	e0bfff0b 	ldhu	r2,-4(fp)
 821c098:	1000021e 	bne	r2,zero,821c0a4 <OSTimeDlyHMSM+0x6c>
                    return (OS_ERR_TIME_ZERO_DLY);
 821c09c:	00801504 	movi	r2,84
 821c0a0:	00003806 	br	821c184 <OSTimeDlyHMSM+0x14c>
                }
            }
        }
    }
    if (minutes > 59) {
 821c0a4:	e0bffd03 	ldbu	r2,-12(fp)
 821c0a8:	10800f30 	cmpltui	r2,r2,60
 821c0ac:	1000021e 	bne	r2,zero,821c0b8 <OSTimeDlyHMSM+0x80>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
 821c0b0:	00801444 	movi	r2,81
 821c0b4:	00003306 	br	821c184 <OSTimeDlyHMSM+0x14c>
    }
    if (seconds > 59) {
 821c0b8:	e0bffe03 	ldbu	r2,-8(fp)
 821c0bc:	10800f30 	cmpltui	r2,r2,60
 821c0c0:	1000021e 	bne	r2,zero,821c0cc <OSTimeDlyHMSM+0x94>
        return (OS_ERR_TIME_INVALID_SECONDS);
 821c0c4:	00801484 	movi	r2,82
 821c0c8:	00002e06 	br	821c184 <OSTimeDlyHMSM+0x14c>
    }
    if (ms > 999) {
 821c0cc:	e0bfff0b 	ldhu	r2,-4(fp)
 821c0d0:	1080fa30 	cmpltui	r2,r2,1000
 821c0d4:	1000021e 	bne	r2,zero,821c0e0 <OSTimeDlyHMSM+0xa8>
        return (OS_ERR_TIME_INVALID_MS);
 821c0d8:	008014c4 	movi	r2,83
 821c0dc:	00002906 	br	821c184 <OSTimeDlyHMSM+0x14c>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
 821c0e0:	e0bffc03 	ldbu	r2,-16(fp)
 821c0e4:	10c38424 	muli	r3,r2,3600
 821c0e8:	e0bffd03 	ldbu	r2,-12(fp)
 821c0ec:	10800f24 	muli	r2,r2,60
 821c0f0:	1887883a 	add	r3,r3,r2
 821c0f4:	e0bffe03 	ldbu	r2,-8(fp)
 821c0f8:	1885883a 	add	r2,r3,r2
 821c0fc:	11001924 	muli	r4,r2,100
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
 821c100:	e0bfff0b 	ldhu	r2,-4(fp)
 821c104:	10801924 	muli	r2,r2,100
 821c108:	10c07d04 	addi	r3,r2,500
 821c10c:	008418b4 	movhi	r2,4194
 821c110:	109374c4 	addi	r2,r2,19923
 821c114:	188a383a 	mulxuu	r5,r3,r2
 821c118:	1885383a 	mul	r2,r3,r2
 821c11c:	1011883a 	mov	r8,r2
 821c120:	2813883a 	mov	r9,r5
 821c124:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
 821c128:	2085883a 	add	r2,r4,r2
 821c12c:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
 821c130:	e0bffb17 	ldw	r2,-20(fp)
 821c134:	1004d43a 	srli	r2,r2,16
 821c138:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
 821c13c:	e0bffb17 	ldw	r2,-20(fp)
 821c140:	10bfffcc 	andi	r2,r2,65535
 821c144:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
 821c148:	e0bffb17 	ldw	r2,-20(fp)
 821c14c:	10bfffcc 	andi	r2,r2,65535
 821c150:	1009883a 	mov	r4,r2
 821c154:	821bf340 	call	821bf34 <OSTimeDly>
    while (loops > 0) {
 821c158:	00000706 	br	821c178 <OSTimeDlyHMSM+0x140>
        OSTimeDly((INT16U)32768u);
 821c15c:	01200014 	movui	r4,32768
 821c160:	821bf340 	call	821bf34 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
 821c164:	01200014 	movui	r4,32768
 821c168:	821bf340 	call	821bf34 <OSTimeDly>
        loops--;
 821c16c:	e0bffa0b 	ldhu	r2,-24(fp)
 821c170:	10bfffc4 	addi	r2,r2,-1
 821c174:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
 821c178:	e0bffa0b 	ldhu	r2,-24(fp)
 821c17c:	103ff71e 	bne	r2,zero,821c15c <OSTimeDlyHMSM+0x124>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
 821c180:	0005883a 	mov	r2,zero
}
 821c184:	e037883a 	mov	sp,fp
 821c188:	dfc00117 	ldw	ra,4(sp)
 821c18c:	df000017 	ldw	fp,0(sp)
 821c190:	dec00204 	addi	sp,sp,8
 821c194:	f800283a 	ret

0821c198 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
 821c198:	defff504 	addi	sp,sp,-44
 821c19c:	dfc00a15 	stw	ra,40(sp)
 821c1a0:	df000915 	stw	fp,36(sp)
 821c1a4:	df000904 	addi	fp,sp,36
 821c1a8:	2005883a 	mov	r2,r4
 821c1ac:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821c1b0:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
 821c1b4:	e0bfff03 	ldbu	r2,-4(fp)
 821c1b8:	10800530 	cmpltui	r2,r2,20
 821c1bc:	1000021e 	bne	r2,zero,821c1c8 <OSTimeDlyResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 821c1c0:	00800a84 	movi	r2,42
 821c1c4:	00006406 	br	821c358 <OSTimeDlyResume+0x1c0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821c1c8:	0005303a 	rdctl	r2,status
 821c1cc:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821c1d0:	e0fffe17 	ldw	r3,-8(fp)
 821c1d4:	00bfff84 	movi	r2,-2
 821c1d8:	1884703a 	and	r2,r3,r2
 821c1dc:	1001703a 	wrctl	status,r2
  
  return context;
 821c1e0:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 821c1e4:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
 821c1e8:	e0ffff03 	ldbu	r3,-4(fp)
 821c1ec:	008209b4 	movhi	r2,2086
 821c1f0:	10b6cb04 	addi	r2,r2,-9428
 821c1f4:	18c7883a 	add	r3,r3,r3
 821c1f8:	18c7883a 	add	r3,r3,r3
 821c1fc:	10c5883a 	add	r2,r2,r3
 821c200:	10800017 	ldw	r2,0(r2)
 821c204:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
 821c208:	e0bff917 	ldw	r2,-28(fp)
 821c20c:	1000061e 	bne	r2,zero,821c228 <OSTimeDlyResume+0x90>
 821c210:	e0bff717 	ldw	r2,-36(fp)
 821c214:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821c218:	e0bff817 	ldw	r2,-32(fp)
 821c21c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 821c220:	008010c4 	movi	r2,67
 821c224:	00004c06 	br	821c358 <OSTimeDlyResume+0x1c0>
    }
    if (ptcb == OS_TCB_RESERVED) {
 821c228:	e0bff917 	ldw	r2,-28(fp)
 821c22c:	10800058 	cmpnei	r2,r2,1
 821c230:	1000061e 	bne	r2,zero,821c24c <OSTimeDlyResume+0xb4>
 821c234:	e0bff717 	ldw	r2,-36(fp)
 821c238:	e0bffa15 	stw	r2,-24(fp)
 821c23c:	e0bffa17 	ldw	r2,-24(fp)
 821c240:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 821c244:	008010c4 	movi	r2,67
 821c248:	00004306 	br	821c358 <OSTimeDlyResume+0x1c0>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
 821c24c:	e0bff917 	ldw	r2,-28(fp)
 821c250:	10800b8b 	ldhu	r2,46(r2)
 821c254:	10bfffcc 	andi	r2,r2,65535
 821c258:	1000061e 	bne	r2,zero,821c274 <OSTimeDlyResume+0xdc>
 821c25c:	e0bff717 	ldw	r2,-36(fp)
 821c260:	e0bffb15 	stw	r2,-20(fp)
 821c264:	e0bffb17 	ldw	r2,-20(fp)
 821c268:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
 821c26c:	00801404 	movi	r2,80
 821c270:	00003906 	br	821c358 <OSTimeDlyResume+0x1c0>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
 821c274:	e0bff917 	ldw	r2,-28(fp)
 821c278:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 821c27c:	e0bff917 	ldw	r2,-28(fp)
 821c280:	10800c03 	ldbu	r2,48(r2)
 821c284:	10803fcc 	andi	r2,r2,255
 821c288:	10800dcc 	andi	r2,r2,55
 821c28c:	10000b26 	beq	r2,zero,821c2bc <OSTimeDlyResume+0x124>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
 821c290:	e0bff917 	ldw	r2,-28(fp)
 821c294:	10c00c03 	ldbu	r3,48(r2)
 821c298:	00bff204 	movi	r2,-56
 821c29c:	1884703a 	and	r2,r3,r2
 821c2a0:	1007883a 	mov	r3,r2
 821c2a4:	e0bff917 	ldw	r2,-28(fp)
 821c2a8:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
 821c2ac:	e0bff917 	ldw	r2,-28(fp)
 821c2b0:	00c00044 	movi	r3,1
 821c2b4:	10c00c45 	stb	r3,49(r2)
 821c2b8:	00000206 	br	821c2c4 <OSTimeDlyResume+0x12c>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
 821c2bc:	e0bff917 	ldw	r2,-28(fp)
 821c2c0:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
 821c2c4:	e0bff917 	ldw	r2,-28(fp)
 821c2c8:	10800c03 	ldbu	r2,48(r2)
 821c2cc:	10803fcc 	andi	r2,r2,255
 821c2d0:	1080020c 	andi	r2,r2,8
 821c2d4:	10001b1e 	bne	r2,zero,821c344 <OSTimeDlyResume+0x1ac>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
 821c2d8:	e0bff917 	ldw	r2,-28(fp)
 821c2dc:	10c00d83 	ldbu	r3,54(r2)
 821c2e0:	d0a07703 	ldbu	r2,-32292(gp)
 821c2e4:	1884b03a 	or	r2,r3,r2
 821c2e8:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 821c2ec:	e0bff917 	ldw	r2,-28(fp)
 821c2f0:	10800d03 	ldbu	r2,52(r2)
 821c2f4:	10c03fcc 	andi	r3,r2,255
 821c2f8:	e0bff917 	ldw	r2,-28(fp)
 821c2fc:	10800d03 	ldbu	r2,52(r2)
 821c300:	11003fcc 	andi	r4,r2,255
 821c304:	d0a07744 	addi	r2,gp,-32291
 821c308:	2085883a 	add	r2,r4,r2
 821c30c:	11000003 	ldbu	r4,0(r2)
 821c310:	e0bff917 	ldw	r2,-28(fp)
 821c314:	10800d43 	ldbu	r2,53(r2)
 821c318:	2084b03a 	or	r2,r4,r2
 821c31c:	1009883a 	mov	r4,r2
 821c320:	d0a07744 	addi	r2,gp,-32291
 821c324:	1885883a 	add	r2,r3,r2
 821c328:	11000005 	stb	r4,0(r2)
 821c32c:	e0bff717 	ldw	r2,-36(fp)
 821c330:	e0bffc15 	stw	r2,-16(fp)
 821c334:	e0bffc17 	ldw	r2,-16(fp)
 821c338:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
 821c33c:	82165800 	call	8216580 <OS_Sched>
 821c340:	00000406 	br	821c354 <OSTimeDlyResume+0x1bc>
 821c344:	e0bff717 	ldw	r2,-36(fp)
 821c348:	e0bffd15 	stw	r2,-12(fp)
 821c34c:	e0bffd17 	ldw	r2,-12(fp)
 821c350:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
 821c354:	0005883a 	mov	r2,zero
}
 821c358:	e037883a 	mov	sp,fp
 821c35c:	dfc00117 	ldw	ra,4(sp)
 821c360:	df000017 	ldw	fp,0(sp)
 821c364:	dec00204 	addi	sp,sp,8
 821c368:	f800283a 	ret

0821c36c <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
 821c36c:	defffb04 	addi	sp,sp,-20
 821c370:	df000415 	stw	fp,16(sp)
 821c374:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821c378:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821c37c:	0005303a 	rdctl	r2,status
 821c380:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821c384:	e0fffe17 	ldw	r3,-8(fp)
 821c388:	00bfff84 	movi	r2,-2
 821c38c:	1884703a 	and	r2,r3,r2
 821c390:	1001703a 	wrctl	status,r2
  
  return context;
 821c394:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
 821c398:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
 821c39c:	d0a07b17 	ldw	r2,-32276(gp)
 821c3a0:	e0bffd15 	stw	r2,-12(fp)
 821c3a4:	e0bffc17 	ldw	r2,-16(fp)
 821c3a8:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821c3ac:	e0bfff17 	ldw	r2,-4(fp)
 821c3b0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
 821c3b4:	e0bffd17 	ldw	r2,-12(fp)
}
 821c3b8:	e037883a 	mov	sp,fp
 821c3bc:	df000017 	ldw	fp,0(sp)
 821c3c0:	dec00104 	addi	sp,sp,4
 821c3c4:	f800283a 	ret

0821c3c8 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
 821c3c8:	defffb04 	addi	sp,sp,-20
 821c3cc:	df000415 	stw	fp,16(sp)
 821c3d0:	df000404 	addi	fp,sp,16
 821c3d4:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821c3d8:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821c3dc:	0005303a 	rdctl	r2,status
 821c3e0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821c3e4:	e0fffd17 	ldw	r3,-12(fp)
 821c3e8:	00bfff84 	movi	r2,-2
 821c3ec:	1884703a 	and	r2,r3,r2
 821c3f0:	1001703a 	wrctl	status,r2
  
  return context;
 821c3f4:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 821c3f8:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
 821c3fc:	e0bfff17 	ldw	r2,-4(fp)
 821c400:	d0a07b15 	stw	r2,-32276(gp)
 821c404:	e0bffc17 	ldw	r2,-16(fp)
 821c408:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821c40c:	e0bffe17 	ldw	r2,-8(fp)
 821c410:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 821c414:	0001883a 	nop
 821c418:	e037883a 	mov	sp,fp
 821c41c:	df000017 	ldw	fp,0(sp)
 821c420:	dec00104 	addi	sp,sp,4
 821c424:	f800283a 	ret

0821c428 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 821c428:	defffd04 	addi	sp,sp,-12
 821c42c:	dfc00215 	stw	ra,8(sp)
 821c430:	df000115 	stw	fp,4(sp)
 821c434:	df000104 	addi	fp,sp,4
 821c438:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 821c43c:	d1604404 	addi	r5,gp,-32496
 821c440:	e13fff17 	ldw	r4,-4(fp)
 821c444:	823be480 	call	823be48 <alt_dev_llist_insert>
}
 821c448:	e037883a 	mov	sp,fp
 821c44c:	dfc00117 	ldw	ra,4(sp)
 821c450:	df000017 	ldw	fp,0(sp)
 821c454:	dec00204 	addi	sp,sp,8
 821c458:	f800283a 	ret

0821c45c <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 821c45c:	defffd04 	addi	sp,sp,-12
 821c460:	dfc00215 	stw	ra,8(sp)
 821c464:	df000115 	stw	fp,4(sp)
 821c468:	df000104 	addi	fp,sp,4
 821c46c:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( CPU, cpu);
 821c470:	823ccec0 	call	823ccec <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 821c474:	00800044 	movi	r2,1
 821c478:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 821c47c:	0001883a 	nop
 821c480:	e037883a 	mov	sp,fp
 821c484:	dfc00117 	ldw	ra,4(sp)
 821c488:	df000017 	ldw	fp,0(sp)
 821c48c:	dec00204 	addi	sp,sp,8
 821c490:	f800283a 	ret

0821c494 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 821c494:	defffa04 	addi	sp,sp,-24
 821c498:	dfc00515 	stw	ra,20(sp)
 821c49c:	df000415 	stw	fp,16(sp)
 821c4a0:	df000404 	addi	fp,sp,16
    ALTERA_AVALON_TIMER_INIT ( HIGH_RES_TIMER, high_res_timer);
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER, sys_clk_timer);
 821c4a4:	01c01904 	movi	r7,100
 821c4a8:	000d883a 	mov	r6,zero
 821c4ac:	000b883a 	mov	r5,zero
 821c4b0:	01024034 	movhi	r4,2304
 821c4b4:	821f1640 	call	821f164 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
 821c4b8:	01800044 	movi	r6,1
 821c4bc:	000b883a 	mov	r5,zero
 821c4c0:	01020974 	movhi	r4,2085
 821c4c4:	210a5504 	addi	r4,r4,10580
 821c4c8:	821c8300 	call	821c830 <altera_avalon_jtag_uart_init>
 821c4cc:	01020974 	movhi	r4,2085
 821c4d0:	210a4b04 	addi	r4,r4,10540
 821c4d4:	821c4280 	call	821c428 <alt_dev_reg>
    ALTERA_AVALON_LCD_16207_INIT ( LCD, lcd);
 821c4d8:	01020974 	movhi	r4,2085
 821c4dc:	210e7004 	addi	r4,r4,14784
 821c4e0:	821e1780 	call	821e178 <altera_avalon_lcd_16207_init>
 821c4e4:	01020974 	movhi	r4,2085
 821c4e8:	210e6604 	addi	r4,r4,14744
 821c4ec:	821c4280 	call	821c428 <alt_dev_reg>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
 821c4f0:	01800084 	movi	r6,2
 821c4f4:	000b883a 	mov	r5,zero
 821c4f8:	01020974 	movhi	r4,2085
 821c4fc:	210eaf04 	addi	r4,r4,15036
 821c500:	821f0440 	call	821f044 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
 821c504:	018000c4 	movi	r6,3
 821c508:	000b883a 	mov	r5,zero
 821c50c:	01020974 	movhi	r4,2085
 821c510:	210ebb04 	addi	r4,r4,15084
 821c514:	821f0440 	call	821f044 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
 821c518:	0001883a 	nop
    ALTERA_ETH_TSE_INIT ( TSE_MAC, tse_mac);
 821c51c:	e03ffc15 	stw	zero,-16(fp)
 821c520:	00800044 	movi	r2,1
 821c524:	e0bffd15 	stw	r2,-12(fp)
 821c528:	e0bffd17 	ldw	r2,-12(fp)
 821c52c:	00800216 	blt	zero,r2,821c538 <alt_sys_init+0xa4>
 821c530:	00800044 	movi	r2,1
 821c534:	e0bffd15 	stw	r2,-12(fp)
 821c538:	e03ffc15 	stw	zero,-16(fp)
 821c53c:	00005a06 	br	821c6a8 <alt_sys_init+0x214>
 821c540:	008209b4 	movhi	r2,2086
 821c544:	10b6e004 	addi	r2,r2,-9344
 821c548:	e0fffc17 	ldw	r3,-16(fp)
 821c54c:	18c00724 	muli	r3,r3,28
 821c550:	10c5883a 	add	r2,r2,r3
 821c554:	10000015 	stw	zero,0(r2)
 821c558:	008209b4 	movhi	r2,2086
 821c55c:	10b6e004 	addi	r2,r2,-9344
 821c560:	e0fffc17 	ldw	r3,-16(fp)
 821c564:	18c00724 	muli	r3,r3,28
 821c568:	10c5883a 	add	r2,r2,r3
 821c56c:	10800104 	addi	r2,r2,4
 821c570:	10000015 	stw	zero,0(r2)
 821c574:	d0e02917 	ldw	r3,-32604(gp)
 821c578:	008209b4 	movhi	r2,2086
 821c57c:	10b6e004 	addi	r2,r2,-9344
 821c580:	e13ffc17 	ldw	r4,-16(fp)
 821c584:	21000724 	muli	r4,r4,28
 821c588:	1105883a 	add	r2,r2,r4
 821c58c:	10800204 	addi	r2,r2,8
 821c590:	10c00015 	stw	r3,0(r2)
 821c594:	008209b4 	movhi	r2,2086
 821c598:	10b6e004 	addi	r2,r2,-9344
 821c59c:	e0fffc17 	ldw	r3,-16(fp)
 821c5a0:	18c00724 	muli	r3,r3,28
 821c5a4:	10c5883a 	add	r2,r2,r3
 821c5a8:	10c00304 	addi	r3,r2,12
 821c5ac:	008208b4 	movhi	r2,2082
 821c5b0:	10907404 	addi	r2,r2,16848
 821c5b4:	18800015 	stw	r2,0(r3)
 821c5b8:	e0bffc17 	ldw	r2,-16(fp)
 821c5bc:	10c00724 	muli	r3,r2,28
 821c5c0:	008209b4 	movhi	r2,2086
 821c5c4:	10b6e004 	addi	r2,r2,-9344
 821c5c8:	1885883a 	add	r2,r3,r2
 821c5cc:	d0e02e04 	addi	r3,gp,-32584
 821c5d0:	e0fffe15 	stw	r3,-8(fp)
 821c5d4:	e0bfff15 	stw	r2,-4(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 821c5d8:	e0bfff17 	ldw	r2,-4(fp)
 821c5dc:	e0fffe17 	ldw	r3,-8(fp)
 821c5e0:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 821c5e4:	e0bffe17 	ldw	r2,-8(fp)
 821c5e8:	10c00017 	ldw	r3,0(r2)
 821c5ec:	e0bfff17 	ldw	r2,-4(fp)
 821c5f0:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 821c5f4:	e0bffe17 	ldw	r2,-8(fp)
 821c5f8:	10800017 	ldw	r2,0(r2)
 821c5fc:	e0ffff17 	ldw	r3,-4(fp)
 821c600:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 821c604:	e0bffe17 	ldw	r2,-8(fp)
 821c608:	e0ffff17 	ldw	r3,-4(fp)
 821c60c:	10c00015 	stw	r3,0(r2)
 821c610:	d0a08003 	ldbu	r2,-32256(gp)
 821c614:	11003fcc 	andi	r4,r2,255
 821c618:	e0bffc17 	ldw	r2,-16(fp)
 821c61c:	10c00724 	muli	r3,r2,28
 821c620:	008209b4 	movhi	r2,2086
 821c624:	10b6e004 	addi	r2,r2,-9344
 821c628:	1887883a 	add	r3,r3,r2
 821c62c:	008209b4 	movhi	r2,2086
 821c630:	10b72004 	addi	r2,r2,-9088
 821c634:	21000324 	muli	r4,r4,12
 821c638:	1105883a 	add	r2,r2,r4
 821c63c:	10c00015 	stw	r3,0(r2)
 821c640:	d0a08003 	ldbu	r2,-32256(gp)
 821c644:	10c03fcc 	andi	r3,r2,255
 821c648:	008209b4 	movhi	r2,2086
 821c64c:	10b72004 	addi	r2,r2,-9088
 821c650:	18c00324 	muli	r3,r3,12
 821c654:	10c5883a 	add	r2,r2,r3
 821c658:	10c00104 	addi	r3,r2,4
 821c65c:	00820034 	movhi	r2,2048
 821c660:	108c0004 	addi	r2,r2,12288
 821c664:	18800015 	stw	r2,0(r3)
 821c668:	d0a08003 	ldbu	r2,-32256(gp)
 821c66c:	10c03fcc 	andi	r3,r2,255
 821c670:	e0bffc17 	ldw	r2,-16(fp)
 821c674:	1009883a 	mov	r4,r2
 821c678:	008209b4 	movhi	r2,2086
 821c67c:	10b72004 	addi	r2,r2,-9088
 821c680:	18c00324 	muli	r3,r3,12
 821c684:	10c5883a 	add	r2,r2,r3
 821c688:	10800204 	addi	r2,r2,8
 821c68c:	11000005 	stb	r4,0(r2)
 821c690:	d0a08003 	ldbu	r2,-32256(gp)
 821c694:	10800044 	addi	r2,r2,1
 821c698:	d0a08005 	stb	r2,-32256(gp)
 821c69c:	e0bffc17 	ldw	r2,-16(fp)
 821c6a0:	10800044 	addi	r2,r2,1
 821c6a4:	e0bffc15 	stw	r2,-16(fp)
 821c6a8:	e0fffc17 	ldw	r3,-16(fp)
 821c6ac:	e0bffd17 	ldw	r2,-12(fp)
 821c6b0:	18bfa316 	blt	r3,r2,821c540 <alt_sys_init+0xac>
}
 821c6b4:	0001883a 	nop
 821c6b8:	e037883a 	mov	sp,fp
 821c6bc:	dfc00117 	ldw	ra,4(sp)
 821c6c0:	df000017 	ldw	fp,0(sp)
 821c6c4:	dec00204 	addi	sp,sp,8
 821c6c8:	f800283a 	ret

0821c6cc <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 821c6cc:	defffa04 	addi	sp,sp,-24
 821c6d0:	dfc00515 	stw	ra,20(sp)
 821c6d4:	df000415 	stw	fp,16(sp)
 821c6d8:	df000404 	addi	fp,sp,16
 821c6dc:	e13ffd15 	stw	r4,-12(fp)
 821c6e0:	e17ffe15 	stw	r5,-8(fp)
 821c6e4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 821c6e8:	e0bffd17 	ldw	r2,-12(fp)
 821c6ec:	10800017 	ldw	r2,0(r2)
 821c6f0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 821c6f4:	e0bffc17 	ldw	r2,-16(fp)
 821c6f8:	10c00a04 	addi	r3,r2,40
 821c6fc:	e0bffd17 	ldw	r2,-12(fp)
 821c700:	10800217 	ldw	r2,8(r2)
 821c704:	100f883a 	mov	r7,r2
 821c708:	e1bfff17 	ldw	r6,-4(fp)
 821c70c:	e17ffe17 	ldw	r5,-8(fp)
 821c710:	1809883a 	mov	r4,r3
 821c714:	821ce780 	call	821ce78 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 821c718:	e037883a 	mov	sp,fp
 821c71c:	dfc00117 	ldw	ra,4(sp)
 821c720:	df000017 	ldw	fp,0(sp)
 821c724:	dec00204 	addi	sp,sp,8
 821c728:	f800283a 	ret

0821c72c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 821c72c:	defffa04 	addi	sp,sp,-24
 821c730:	dfc00515 	stw	ra,20(sp)
 821c734:	df000415 	stw	fp,16(sp)
 821c738:	df000404 	addi	fp,sp,16
 821c73c:	e13ffd15 	stw	r4,-12(fp)
 821c740:	e17ffe15 	stw	r5,-8(fp)
 821c744:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 821c748:	e0bffd17 	ldw	r2,-12(fp)
 821c74c:	10800017 	ldw	r2,0(r2)
 821c750:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 821c754:	e0bffc17 	ldw	r2,-16(fp)
 821c758:	10c00a04 	addi	r3,r2,40
 821c75c:	e0bffd17 	ldw	r2,-12(fp)
 821c760:	10800217 	ldw	r2,8(r2)
 821c764:	100f883a 	mov	r7,r2
 821c768:	e1bfff17 	ldw	r6,-4(fp)
 821c76c:	e17ffe17 	ldw	r5,-8(fp)
 821c770:	1809883a 	mov	r4,r3
 821c774:	821d1340 	call	821d134 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 821c778:	e037883a 	mov	sp,fp
 821c77c:	dfc00117 	ldw	ra,4(sp)
 821c780:	df000017 	ldw	fp,0(sp)
 821c784:	dec00204 	addi	sp,sp,8
 821c788:	f800283a 	ret

0821c78c <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 821c78c:	defffc04 	addi	sp,sp,-16
 821c790:	dfc00315 	stw	ra,12(sp)
 821c794:	df000215 	stw	fp,8(sp)
 821c798:	df000204 	addi	fp,sp,8
 821c79c:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 821c7a0:	e0bfff17 	ldw	r2,-4(fp)
 821c7a4:	10800017 	ldw	r2,0(r2)
 821c7a8:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 821c7ac:	e0bffe17 	ldw	r2,-8(fp)
 821c7b0:	10c00a04 	addi	r3,r2,40
 821c7b4:	e0bfff17 	ldw	r2,-4(fp)
 821c7b8:	10800217 	ldw	r2,8(r2)
 821c7bc:	100b883a 	mov	r5,r2
 821c7c0:	1809883a 	mov	r4,r3
 821c7c4:	821cd200 	call	821cd20 <altera_avalon_jtag_uart_close>
}
 821c7c8:	e037883a 	mov	sp,fp
 821c7cc:	dfc00117 	ldw	ra,4(sp)
 821c7d0:	df000017 	ldw	fp,0(sp)
 821c7d4:	dec00204 	addi	sp,sp,8
 821c7d8:	f800283a 	ret

0821c7dc <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 821c7dc:	defffa04 	addi	sp,sp,-24
 821c7e0:	dfc00515 	stw	ra,20(sp)
 821c7e4:	df000415 	stw	fp,16(sp)
 821c7e8:	df000404 	addi	fp,sp,16
 821c7ec:	e13ffd15 	stw	r4,-12(fp)
 821c7f0:	e17ffe15 	stw	r5,-8(fp)
 821c7f4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 821c7f8:	e0bffd17 	ldw	r2,-12(fp)
 821c7fc:	10800017 	ldw	r2,0(r2)
 821c800:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 821c804:	e0bffc17 	ldw	r2,-16(fp)
 821c808:	10800a04 	addi	r2,r2,40
 821c80c:	e1bfff17 	ldw	r6,-4(fp)
 821c810:	e17ffe17 	ldw	r5,-8(fp)
 821c814:	1009883a 	mov	r4,r2
 821c818:	821cd880 	call	821cd88 <altera_avalon_jtag_uart_ioctl>
}
 821c81c:	e037883a 	mov	sp,fp
 821c820:	dfc00117 	ldw	ra,4(sp)
 821c824:	df000017 	ldw	fp,0(sp)
 821c828:	dec00204 	addi	sp,sp,8
 821c82c:	f800283a 	ret

0821c830 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 821c830:	defff104 	addi	sp,sp,-60
 821c834:	dfc00e15 	stw	ra,56(sp)
 821c838:	df000d15 	stw	fp,52(sp)
 821c83c:	df000d04 	addi	fp,sp,52
 821c840:	e13ff915 	stw	r4,-28(fp)
 821c844:	e17ffa15 	stw	r5,-24(fp)
 821c848:	e1bffb15 	stw	r6,-20(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
 821c84c:	e0bff917 	ldw	r2,-28(fp)
 821c850:	10800c04 	addi	r2,r2,48
 821c854:	e0bff415 	stw	r2,-48(fp)
 821c858:	e03ff80d 	sth	zero,-32(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
 821c85c:	e0bff80b 	ldhu	r2,-32(fp)
 821c860:	e0fff884 	addi	r3,fp,-30
 821c864:	180b883a 	mov	r5,r3
 821c868:	1009883a 	mov	r4,r2
 821c86c:	82171040 	call	8217104 <OSFlagCreate>
 821c870:	1007883a 	mov	r3,r2
 821c874:	e0bff417 	ldw	r2,-48(fp)
 821c878:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
 821c87c:	e0bff917 	ldw	r2,-28(fp)
 821c880:	10800a04 	addi	r2,r2,40
 821c884:	e0bff515 	stw	r2,-44(fp)
 821c888:	00800044 	movi	r2,1
 821c88c:	e0bff78d 	sth	r2,-34(fp)
 821c890:	e0bff78b 	ldhu	r2,-34(fp)
 821c894:	1009883a 	mov	r4,r2
 821c898:	8219e180 	call	8219e18 <OSSemCreate>
 821c89c:	1007883a 	mov	r3,r2
 821c8a0:	e0bff517 	ldw	r2,-44(fp)
 821c8a4:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
 821c8a8:	e0bff917 	ldw	r2,-28(fp)
 821c8ac:	10800b04 	addi	r2,r2,44
 821c8b0:	e0bff615 	stw	r2,-40(fp)
 821c8b4:	00800044 	movi	r2,1
 821c8b8:	e0bff70d 	sth	r2,-36(fp)
 821c8bc:	e0bff70b 	ldhu	r2,-36(fp)
 821c8c0:	1009883a 	mov	r4,r2
 821c8c4:	8219e180 	call	8219e18 <OSSemCreate>
 821c8c8:	1007883a 	mov	r3,r2
 821c8cc:	e0bff617 	ldw	r2,-40(fp)
 821c8d0:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 821c8d4:	e0bff917 	ldw	r2,-28(fp)
 821c8d8:	00c00044 	movi	r3,1
 821c8dc:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 821c8e0:	e0bff917 	ldw	r2,-28(fp)
 821c8e4:	10800017 	ldw	r2,0(r2)
 821c8e8:	10800104 	addi	r2,r2,4
 821c8ec:	1007883a 	mov	r3,r2
 821c8f0:	e0bff917 	ldw	r2,-28(fp)
 821c8f4:	10800817 	ldw	r2,32(r2)
 821c8f8:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 821c8fc:	e0bffa17 	ldw	r2,-24(fp)
 821c900:	e0fffb17 	ldw	r3,-20(fp)
 821c904:	d8000015 	stw	zero,0(sp)
 821c908:	e1fff917 	ldw	r7,-28(fp)
 821c90c:	018208b4 	movhi	r6,2082
 821c910:	31b25e04 	addi	r6,r6,-13960
 821c914:	180b883a 	mov	r5,r3
 821c918:	1009883a 	mov	r4,r2
 821c91c:	823c03c0 	call	823c03c <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 821c920:	e0bff917 	ldw	r2,-28(fp)
 821c924:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 821c928:	e0bff917 	ldw	r2,-28(fp)
 821c92c:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 821c930:	d0e0b817 	ldw	r3,-32032(gp)
 821c934:	e1fff917 	ldw	r7,-28(fp)
 821c938:	018208b4 	movhi	r6,2082
 821c93c:	31b30704 	addi	r6,r6,-13284
 821c940:	180b883a 	mov	r5,r3
 821c944:	1009883a 	mov	r4,r2
 821c948:	823bb300 	call	823bb30 <alt_alarm_start>
 821c94c:	1000040e 	bge	r2,zero,821c960 <altera_avalon_jtag_uart_init+0x130>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 821c950:	e0fff917 	ldw	r3,-28(fp)
 821c954:	00a00034 	movhi	r2,32768
 821c958:	10bfffc4 	addi	r2,r2,-1
 821c95c:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 821c960:	0001883a 	nop
 821c964:	e037883a 	mov	sp,fp
 821c968:	dfc00117 	ldw	ra,4(sp)
 821c96c:	df000017 	ldw	fp,0(sp)
 821c970:	dec00204 	addi	sp,sp,8
 821c974:	f800283a 	ret

0821c978 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 821c978:	defff204 	addi	sp,sp,-56
 821c97c:	dfc00d15 	stw	ra,52(sp)
 821c980:	df000c15 	stw	fp,48(sp)
 821c984:	df000c04 	addi	fp,sp,48
 821c988:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 821c98c:	e0bfff17 	ldw	r2,-4(fp)
 821c990:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
 821c994:	e0bff617 	ldw	r2,-40(fp)
 821c998:	10800017 	ldw	r2,0(r2)
 821c99c:	e0bff715 	stw	r2,-36(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 821c9a0:	e0bff717 	ldw	r2,-36(fp)
 821c9a4:	10800104 	addi	r2,r2,4
 821c9a8:	10800037 	ldwio	r2,0(r2)
 821c9ac:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 821c9b0:	e0bff817 	ldw	r2,-32(fp)
 821c9b4:	1080c00c 	andi	r2,r2,768
 821c9b8:	10009126 	beq	r2,zero,821cc00 <altera_avalon_jtag_uart_irq+0x288>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 821c9bc:	e0bff817 	ldw	r2,-32(fp)
 821c9c0:	1080400c 	andi	r2,r2,256
 821c9c4:	10004726 	beq	r2,zero,821cae4 <altera_avalon_jtag_uart_irq+0x16c>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 821c9c8:	00800074 	movhi	r2,1
 821c9cc:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821c9d0:	e0bff617 	ldw	r2,-40(fp)
 821c9d4:	10800d17 	ldw	r2,52(r2)
 821c9d8:	10800044 	addi	r2,r2,1
 821c9dc:	1081ffcc 	andi	r2,r2,2047
 821c9e0:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
 821c9e4:	e0bff617 	ldw	r2,-40(fp)
 821c9e8:	10c00e17 	ldw	r3,56(r2)
 821c9ec:	e0bff917 	ldw	r2,-28(fp)
 821c9f0:	18802726 	beq	r3,r2,821ca90 <altera_avalon_jtag_uart_irq+0x118>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 821c9f4:	e0bff717 	ldw	r2,-36(fp)
 821c9f8:	10800037 	ldwio	r2,0(r2)
 821c9fc:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 821ca00:	e0bff417 	ldw	r2,-48(fp)
 821ca04:	10a0000c 	andi	r2,r2,32768
 821ca08:	10002326 	beq	r2,zero,821ca98 <altera_avalon_jtag_uart_irq+0x120>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 821ca0c:	e0bff617 	ldw	r2,-40(fp)
 821ca10:	10800d17 	ldw	r2,52(r2)
 821ca14:	e0fff417 	ldw	r3,-48(fp)
 821ca18:	1809883a 	mov	r4,r3
 821ca1c:	e0fff617 	ldw	r3,-40(fp)
 821ca20:	1885883a 	add	r2,r3,r2
 821ca24:	10801104 	addi	r2,r2,68
 821ca28:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821ca2c:	e0bff617 	ldw	r2,-40(fp)
 821ca30:	10800d17 	ldw	r2,52(r2)
 821ca34:	10800044 	addi	r2,r2,1
 821ca38:	10c1ffcc 	andi	r3,r2,2047
 821ca3c:	e0bff617 	ldw	r2,-40(fp)
 821ca40:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
 821ca44:	e0bff617 	ldw	r2,-40(fp)
 821ca48:	10800c17 	ldw	r2,48(r2)
 821ca4c:	e0bffb15 	stw	r2,-20(fp)
 821ca50:	00800044 	movi	r2,1
 821ca54:	e0bffc0d 	sth	r2,-16(fp)
 821ca58:	00800044 	movi	r2,1
 821ca5c:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 821ca60:	d0a06b43 	ldbu	r2,-32339(gp)
 821ca64:	10803fcc 	andi	r2,r2,255
 821ca68:	103fd926 	beq	r2,zero,821c9d0 <altera_avalon_jtag_uart_irq+0x58>
  {
    OSFlagPost (group, flags, opt, &err);
 821ca6c:	e0bffc0b 	ldhu	r2,-16(fp)
 821ca70:	e0fffc83 	ldbu	r3,-14(fp)
 821ca74:	e13ffdc4 	addi	r4,fp,-9
 821ca78:	200f883a 	mov	r7,r4
 821ca7c:	180d883a 	mov	r6,r3
 821ca80:	100b883a 	mov	r5,r2
 821ca84:	e13ffb17 	ldw	r4,-20(fp)
 821ca88:	8217ce00 	call	8217ce0 <OSFlagPost>
      }
 821ca8c:	003fd006 	br	821c9d0 <altera_avalon_jtag_uart_irq+0x58>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
 821ca90:	0001883a 	nop
 821ca94:	00000106 	br	821ca9c <altera_avalon_jtag_uart_irq+0x124>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
 821ca98:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 821ca9c:	e0bff417 	ldw	r2,-48(fp)
 821caa0:	10bfffec 	andhi	r2,r2,65535
 821caa4:	10000f26 	beq	r2,zero,821cae4 <altera_avalon_jtag_uart_irq+0x16c>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 821caa8:	e0bff617 	ldw	r2,-40(fp)
 821caac:	10c00817 	ldw	r3,32(r2)
 821cab0:	00bfff84 	movi	r2,-2
 821cab4:	1886703a 	and	r3,r3,r2
 821cab8:	e0bff617 	ldw	r2,-40(fp)
 821cabc:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 821cac0:	e0bff717 	ldw	r2,-36(fp)
 821cac4:	10800104 	addi	r2,r2,4
 821cac8:	1007883a 	mov	r3,r2
 821cacc:	e0bff617 	ldw	r2,-40(fp)
 821cad0:	10800817 	ldw	r2,32(r2)
 821cad4:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 821cad8:	e0bff717 	ldw	r2,-36(fp)
 821cadc:	10800104 	addi	r2,r2,4
 821cae0:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 821cae4:	e0bff817 	ldw	r2,-32(fp)
 821cae8:	1080800c 	andi	r2,r2,512
 821caec:	103fac26 	beq	r2,zero,821c9a0 <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 821caf0:	e0bff817 	ldw	r2,-32(fp)
 821caf4:	1004d43a 	srli	r2,r2,16
 821caf8:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 821cafc:	00002606 	br	821cb98 <altera_avalon_jtag_uart_irq+0x220>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 821cb00:	e0bff717 	ldw	r2,-36(fp)
 821cb04:	e0fff617 	ldw	r3,-40(fp)
 821cb08:	18c01017 	ldw	r3,64(r3)
 821cb0c:	e13ff617 	ldw	r4,-40(fp)
 821cb10:	20c7883a 	add	r3,r4,r3
 821cb14:	18c21104 	addi	r3,r3,2116
 821cb18:	18c00003 	ldbu	r3,0(r3)
 821cb1c:	18c03fcc 	andi	r3,r3,255
 821cb20:	18c0201c 	xori	r3,r3,128
 821cb24:	18ffe004 	addi	r3,r3,-128
 821cb28:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821cb2c:	e0bff617 	ldw	r2,-40(fp)
 821cb30:	10801017 	ldw	r2,64(r2)
 821cb34:	10800044 	addi	r2,r2,1
 821cb38:	10c1ffcc 	andi	r3,r2,2047
 821cb3c:	e0bff617 	ldw	r2,-40(fp)
 821cb40:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
 821cb44:	e0bff617 	ldw	r2,-40(fp)
 821cb48:	10800c17 	ldw	r2,48(r2)
 821cb4c:	e0bffa15 	stw	r2,-24(fp)
 821cb50:	00800084 	movi	r2,2
 821cb54:	e0bffd0d 	sth	r2,-12(fp)
 821cb58:	00800044 	movi	r2,1
 821cb5c:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 821cb60:	d0a06b43 	ldbu	r2,-32339(gp)
 821cb64:	10803fcc 	andi	r2,r2,255
 821cb68:	10000826 	beq	r2,zero,821cb8c <altera_avalon_jtag_uart_irq+0x214>
  {
    OSFlagPost (group, flags, opt, &err);
 821cb6c:	e0bffd0b 	ldhu	r2,-12(fp)
 821cb70:	e0fffd83 	ldbu	r3,-10(fp)
 821cb74:	e13ffe04 	addi	r4,fp,-8
 821cb78:	200f883a 	mov	r7,r4
 821cb7c:	180d883a 	mov	r6,r3
 821cb80:	100b883a 	mov	r5,r2
 821cb84:	e13ffa17 	ldw	r4,-24(fp)
 821cb88:	8217ce00 	call	8217ce0 <OSFlagPost>

        space--;
 821cb8c:	e0bff517 	ldw	r2,-44(fp)
 821cb90:	10bfffc4 	addi	r2,r2,-1
 821cb94:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 821cb98:	e0bff517 	ldw	r2,-44(fp)
 821cb9c:	10000526 	beq	r2,zero,821cbb4 <altera_avalon_jtag_uart_irq+0x23c>
 821cba0:	e0bff617 	ldw	r2,-40(fp)
 821cba4:	10c01017 	ldw	r3,64(r2)
 821cba8:	e0bff617 	ldw	r2,-40(fp)
 821cbac:	10800f17 	ldw	r2,60(r2)
 821cbb0:	18bfd31e 	bne	r3,r2,821cb00 <altera_avalon_jtag_uart_irq+0x188>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 821cbb4:	e0bff517 	ldw	r2,-44(fp)
 821cbb8:	103f7926 	beq	r2,zero,821c9a0 <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 821cbbc:	e0bff617 	ldw	r2,-40(fp)
 821cbc0:	10c00817 	ldw	r3,32(r2)
 821cbc4:	00bfff44 	movi	r2,-3
 821cbc8:	1886703a 	and	r3,r3,r2
 821cbcc:	e0bff617 	ldw	r2,-40(fp)
 821cbd0:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 821cbd4:	e0bff617 	ldw	r2,-40(fp)
 821cbd8:	10800017 	ldw	r2,0(r2)
 821cbdc:	10800104 	addi	r2,r2,4
 821cbe0:	1007883a 	mov	r3,r2
 821cbe4:	e0bff617 	ldw	r2,-40(fp)
 821cbe8:	10800817 	ldw	r2,32(r2)
 821cbec:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 821cbf0:	e0bff717 	ldw	r2,-36(fp)
 821cbf4:	10800104 	addi	r2,r2,4
 821cbf8:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 821cbfc:	003f6806 	br	821c9a0 <altera_avalon_jtag_uart_irq+0x28>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
 821cc00:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
 821cc04:	0001883a 	nop
 821cc08:	e037883a 	mov	sp,fp
 821cc0c:	dfc00117 	ldw	ra,4(sp)
 821cc10:	df000017 	ldw	fp,0(sp)
 821cc14:	dec00204 	addi	sp,sp,8
 821cc18:	f800283a 	ret

0821cc1c <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 821cc1c:	defff904 	addi	sp,sp,-28
 821cc20:	dfc00615 	stw	ra,24(sp)
 821cc24:	df000515 	stw	fp,20(sp)
 821cc28:	df000504 	addi	fp,sp,20
 821cc2c:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 821cc30:	e0bfff17 	ldw	r2,-4(fp)
 821cc34:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 821cc38:	e0bffb17 	ldw	r2,-20(fp)
 821cc3c:	10800017 	ldw	r2,0(r2)
 821cc40:	10800104 	addi	r2,r2,4
 821cc44:	10800037 	ldwio	r2,0(r2)
 821cc48:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 821cc4c:	e0bffc17 	ldw	r2,-16(fp)
 821cc50:	1081000c 	andi	r2,r2,1024
 821cc54:	10000b26 	beq	r2,zero,821cc84 <altera_avalon_jtag_uart_timeout+0x68>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 821cc58:	e0bffb17 	ldw	r2,-20(fp)
 821cc5c:	10800017 	ldw	r2,0(r2)
 821cc60:	10800104 	addi	r2,r2,4
 821cc64:	1007883a 	mov	r3,r2
 821cc68:	e0bffb17 	ldw	r2,-20(fp)
 821cc6c:	10800817 	ldw	r2,32(r2)
 821cc70:	10810014 	ori	r2,r2,1024
 821cc74:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 821cc78:	e0bffb17 	ldw	r2,-20(fp)
 821cc7c:	10000915 	stw	zero,36(r2)
 821cc80:	00002106 	br	821cd08 <altera_avalon_jtag_uart_timeout+0xec>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 821cc84:	e0bffb17 	ldw	r2,-20(fp)
 821cc88:	10c00917 	ldw	r3,36(r2)
 821cc8c:	00a00034 	movhi	r2,32768
 821cc90:	10bfff04 	addi	r2,r2,-4
 821cc94:	10c01c36 	bltu	r2,r3,821cd08 <altera_avalon_jtag_uart_timeout+0xec>
    sp->host_inactive++;
 821cc98:	e0bffb17 	ldw	r2,-20(fp)
 821cc9c:	10800917 	ldw	r2,36(r2)
 821cca0:	10c00044 	addi	r3,r2,1
 821cca4:	e0bffb17 	ldw	r2,-20(fp)
 821cca8:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
 821ccac:	e0bffb17 	ldw	r2,-20(fp)
 821ccb0:	10c00917 	ldw	r3,36(r2)
 821ccb4:	e0bffb17 	ldw	r2,-20(fp)
 821ccb8:	10800117 	ldw	r2,4(r2)
 821ccbc:	18801236 	bltu	r3,r2,821cd08 <altera_avalon_jtag_uart_timeout+0xec>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
 821ccc0:	e0bffb17 	ldw	r2,-20(fp)
 821ccc4:	10800c17 	ldw	r2,48(r2)
 821ccc8:	e0bffd15 	stw	r2,-12(fp)
 821cccc:	00800104 	movi	r2,4
 821ccd0:	e0bffe0d 	sth	r2,-8(fp)
 821ccd4:	00800044 	movi	r2,1
 821ccd8:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 821ccdc:	d0a06b43 	ldbu	r2,-32339(gp)
 821cce0:	10803fcc 	andi	r2,r2,255
 821cce4:	10000826 	beq	r2,zero,821cd08 <altera_avalon_jtag_uart_timeout+0xec>
  {
    OSFlagPost (group, flags, opt, &err);
 821cce8:	e0bffe0b 	ldhu	r2,-8(fp)
 821ccec:	e0fffe83 	ldbu	r3,-6(fp)
 821ccf0:	e13ffec4 	addi	r4,fp,-5
 821ccf4:	200f883a 	mov	r7,r4
 821ccf8:	180d883a 	mov	r6,r3
 821ccfc:	100b883a 	mov	r5,r2
 821cd00:	e13ffd17 	ldw	r4,-12(fp)
 821cd04:	8217ce00 	call	8217ce0 <OSFlagPost>
 821cd08:	d0a0b817 	ldw	r2,-32032(gp)
    }
  }

  return alt_ticks_per_second();
}
 821cd0c:	e037883a 	mov	sp,fp
 821cd10:	dfc00117 	ldw	ra,4(sp)
 821cd14:	df000017 	ldw	fp,0(sp)
 821cd18:	dec00204 	addi	sp,sp,8
 821cd1c:	f800283a 	ret

0821cd20 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 821cd20:	defffd04 	addi	sp,sp,-12
 821cd24:	df000215 	stw	fp,8(sp)
 821cd28:	df000204 	addi	fp,sp,8
 821cd2c:	e13ffe15 	stw	r4,-8(fp)
 821cd30:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 821cd34:	00000506 	br	821cd4c <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 821cd38:	e0bfff17 	ldw	r2,-4(fp)
 821cd3c:	1090000c 	andi	r2,r2,16384
 821cd40:	10000226 	beq	r2,zero,821cd4c <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 821cd44:	00bffd44 	movi	r2,-11
 821cd48:	00000b06 	br	821cd78 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 821cd4c:	e0bffe17 	ldw	r2,-8(fp)
 821cd50:	10c01017 	ldw	r3,64(r2)
 821cd54:	e0bffe17 	ldw	r2,-8(fp)
 821cd58:	10800f17 	ldw	r2,60(r2)
 821cd5c:	18800526 	beq	r3,r2,821cd74 <altera_avalon_jtag_uart_close+0x54>
 821cd60:	e0bffe17 	ldw	r2,-8(fp)
 821cd64:	10c00917 	ldw	r3,36(r2)
 821cd68:	e0bffe17 	ldw	r2,-8(fp)
 821cd6c:	10800117 	ldw	r2,4(r2)
 821cd70:	18bff136 	bltu	r3,r2,821cd38 <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 821cd74:	0005883a 	mov	r2,zero
}
 821cd78:	e037883a 	mov	sp,fp
 821cd7c:	df000017 	ldw	fp,0(sp)
 821cd80:	dec00104 	addi	sp,sp,4
 821cd84:	f800283a 	ret

0821cd88 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 821cd88:	defffa04 	addi	sp,sp,-24
 821cd8c:	df000515 	stw	fp,20(sp)
 821cd90:	df000504 	addi	fp,sp,20
 821cd94:	e13ffd15 	stw	r4,-12(fp)
 821cd98:	e17ffe15 	stw	r5,-8(fp)
 821cd9c:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
 821cda0:	00bff9c4 	movi	r2,-25
 821cda4:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
 821cda8:	e0bffe17 	ldw	r2,-8(fp)
 821cdac:	10da8060 	cmpeqi	r3,r2,27137
 821cdb0:	1800031e 	bne	r3,zero,821cdc0 <altera_avalon_jtag_uart_ioctl+0x38>
 821cdb4:	109a80a0 	cmpeqi	r2,r2,27138
 821cdb8:	1000181e 	bne	r2,zero,821ce1c <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
 821cdbc:	00002906 	br	821ce64 <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 821cdc0:	e0bffd17 	ldw	r2,-12(fp)
 821cdc4:	10c00117 	ldw	r3,4(r2)
 821cdc8:	00a00034 	movhi	r2,32768
 821cdcc:	10bfffc4 	addi	r2,r2,-1
 821cdd0:	18802126 	beq	r3,r2,821ce58 <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
 821cdd4:	e0bfff17 	ldw	r2,-4(fp)
 821cdd8:	10800017 	ldw	r2,0(r2)
 821cddc:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 821cde0:	e0bffc17 	ldw	r2,-16(fp)
 821cde4:	10800090 	cmplti	r2,r2,2
 821cde8:	1000061e 	bne	r2,zero,821ce04 <altera_avalon_jtag_uart_ioctl+0x7c>
 821cdec:	e0fffc17 	ldw	r3,-16(fp)
 821cdf0:	00a00034 	movhi	r2,32768
 821cdf4:	10bfffc4 	addi	r2,r2,-1
 821cdf8:	18800226 	beq	r3,r2,821ce04 <altera_avalon_jtag_uart_ioctl+0x7c>
 821cdfc:	e0bffc17 	ldw	r2,-16(fp)
 821ce00:	00000206 	br	821ce0c <altera_avalon_jtag_uart_ioctl+0x84>
 821ce04:	00a00034 	movhi	r2,32768
 821ce08:	10bfff84 	addi	r2,r2,-2
 821ce0c:	e0fffd17 	ldw	r3,-12(fp)
 821ce10:	18800115 	stw	r2,4(r3)
      rc = 0;
 821ce14:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 821ce18:	00000f06 	br	821ce58 <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 821ce1c:	e0bffd17 	ldw	r2,-12(fp)
 821ce20:	10c00117 	ldw	r3,4(r2)
 821ce24:	00a00034 	movhi	r2,32768
 821ce28:	10bfffc4 	addi	r2,r2,-1
 821ce2c:	18800c26 	beq	r3,r2,821ce60 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 821ce30:	e0bffd17 	ldw	r2,-12(fp)
 821ce34:	10c00917 	ldw	r3,36(r2)
 821ce38:	e0bffd17 	ldw	r2,-12(fp)
 821ce3c:	10800117 	ldw	r2,4(r2)
 821ce40:	1885803a 	cmpltu	r2,r3,r2
 821ce44:	10c03fcc 	andi	r3,r2,255
 821ce48:	e0bfff17 	ldw	r2,-4(fp)
 821ce4c:	10c00015 	stw	r3,0(r2)
      rc = 0;
 821ce50:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 821ce54:	00000206 	br	821ce60 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
 821ce58:	0001883a 	nop
 821ce5c:	00000106 	br	821ce64 <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
 821ce60:	0001883a 	nop

  default:
    break;
  }

  return rc;
 821ce64:	e0bffb17 	ldw	r2,-20(fp)
}
 821ce68:	e037883a 	mov	sp,fp
 821ce6c:	df000017 	ldw	fp,0(sp)
 821ce70:	dec00104 	addi	sp,sp,4
 821ce74:	f800283a 	ret

0821ce78 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 821ce78:	deffed04 	addi	sp,sp,-76
 821ce7c:	dfc01215 	stw	ra,72(sp)
 821ce80:	df001115 	stw	fp,68(sp)
 821ce84:	df001104 	addi	fp,sp,68
 821ce88:	e13ffc15 	stw	r4,-16(fp)
 821ce8c:	e17ffd15 	stw	r5,-12(fp)
 821ce90:	e1bffe15 	stw	r6,-8(fp)
 821ce94:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
 821ce98:	e0bffd17 	ldw	r2,-12(fp)
 821ce9c:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
 821cea0:	e0bffc17 	ldw	r2,-16(fp)
 821cea4:	10800a17 	ldw	r2,40(r2)
 821cea8:	e0bff815 	stw	r2,-32(fp)
 821ceac:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 821ceb0:	e0bff90b 	ldhu	r2,-28(fp)
 821ceb4:	e0fffb04 	addi	r3,fp,-20
 821ceb8:	180d883a 	mov	r6,r3
 821cebc:	100b883a 	mov	r5,r2
 821cec0:	e13ff817 	ldw	r4,-32(fp)
 821cec4:	821a1300 	call	821a130 <OSSemPend>

  while (space > 0)
 821cec8:	00006106 	br	821d050 <altera_avalon_jtag_uart_read+0x1d8>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 821cecc:	e0bffc17 	ldw	r2,-16(fp)
 821ced0:	10800d17 	ldw	r2,52(r2)
 821ced4:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
 821ced8:	e0bffc17 	ldw	r2,-16(fp)
 821cedc:	10800e17 	ldw	r2,56(r2)
 821cee0:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
 821cee4:	e0fff317 	ldw	r3,-52(fp)
 821cee8:	e0bff417 	ldw	r2,-48(fp)
 821ceec:	18800536 	bltu	r3,r2,821cf04 <altera_avalon_jtag_uart_read+0x8c>
        n = in - out;
 821cef0:	e0fff317 	ldw	r3,-52(fp)
 821cef4:	e0bff417 	ldw	r2,-48(fp)
 821cef8:	1885c83a 	sub	r2,r3,r2
 821cefc:	e0bff115 	stw	r2,-60(fp)
 821cf00:	00000406 	br	821cf14 <altera_avalon_jtag_uart_read+0x9c>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 821cf04:	00c20004 	movi	r3,2048
 821cf08:	e0bff417 	ldw	r2,-48(fp)
 821cf0c:	1885c83a 	sub	r2,r3,r2
 821cf10:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
 821cf14:	e0bff117 	ldw	r2,-60(fp)
 821cf18:	10001e26 	beq	r2,zero,821cf94 <altera_avalon_jtag_uart_read+0x11c>
        break; /* No more data available */

      if (n > space)
 821cf1c:	e0fffe17 	ldw	r3,-8(fp)
 821cf20:	e0bff117 	ldw	r2,-60(fp)
 821cf24:	1880022e 	bgeu	r3,r2,821cf30 <altera_avalon_jtag_uart_read+0xb8>
        n = space;
 821cf28:	e0bffe17 	ldw	r2,-8(fp)
 821cf2c:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 821cf30:	e0bffc17 	ldw	r2,-16(fp)
 821cf34:	10c01104 	addi	r3,r2,68
 821cf38:	e0bff417 	ldw	r2,-48(fp)
 821cf3c:	1885883a 	add	r2,r3,r2
 821cf40:	e1bff117 	ldw	r6,-60(fp)
 821cf44:	100b883a 	mov	r5,r2
 821cf48:	e13ff017 	ldw	r4,-64(fp)
 821cf4c:	8202f6c0 	call	8202f6c <memcpy>
      ptr   += n;
 821cf50:	e0fff017 	ldw	r3,-64(fp)
 821cf54:	e0bff117 	ldw	r2,-60(fp)
 821cf58:	1885883a 	add	r2,r3,r2
 821cf5c:	e0bff015 	stw	r2,-64(fp)
      space -= n;
 821cf60:	e0fffe17 	ldw	r3,-8(fp)
 821cf64:	e0bff117 	ldw	r2,-60(fp)
 821cf68:	1885c83a 	sub	r2,r3,r2
 821cf6c:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821cf70:	e0fff417 	ldw	r3,-48(fp)
 821cf74:	e0bff117 	ldw	r2,-60(fp)
 821cf78:	1885883a 	add	r2,r3,r2
 821cf7c:	10c1ffcc 	andi	r3,r2,2047
 821cf80:	e0bffc17 	ldw	r2,-16(fp)
 821cf84:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
 821cf88:	e0bffe17 	ldw	r2,-8(fp)
 821cf8c:	00bfcf16 	blt	zero,r2,821cecc <altera_avalon_jtag_uart_read+0x54>
 821cf90:	00000106 	br	821cf98 <altera_avalon_jtag_uart_read+0x120>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
 821cf94:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
 821cf98:	e0fff017 	ldw	r3,-64(fp)
 821cf9c:	e0bffd17 	ldw	r2,-12(fp)
 821cfa0:	18802e1e 	bne	r3,r2,821d05c <altera_avalon_jtag_uart_read+0x1e4>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 821cfa4:	e0bfff17 	ldw	r2,-4(fp)
 821cfa8:	1090000c 	andi	r2,r2,16384
 821cfac:	10002d1e 	bne	r2,zero,821d064 <altera_avalon_jtag_uart_read+0x1ec>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
 821cfb0:	d0a06b43 	ldbu	r2,-32339(gp)
 821cfb4:	10803fcc 	andi	r2,r2,255
 821cfb8:	10800058 	cmpnei	r2,r2,1
 821cfbc:	1000161e 	bne	r2,zero,821d018 <altera_avalon_jtag_uart_read+0x1a0>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
 821cfc0:	e0bffc17 	ldw	r2,-16(fp)
 821cfc4:	10800c17 	ldw	r2,48(r2)
 821cfc8:	e0bff215 	stw	r2,-56(fp)
 821cfcc:	00800144 	movi	r2,5
 821cfd0:	e0bff98d 	sth	r2,-26(fp)
 821cfd4:	00bfe0c4 	movi	r2,-125
 821cfd8:	e0bffa05 	stb	r2,-24(fp)
 821cfdc:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 821cfe0:	d0a06b43 	ldbu	r2,-32339(gp)
 821cfe4:	10803fcc 	andi	r2,r2,255
 821cfe8:	10001526 	beq	r2,zero,821d040 <altera_avalon_jtag_uart_read+0x1c8>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 821cfec:	e0fff98b 	ldhu	r3,-26(fp)
 821cff0:	e13ffa03 	ldbu	r4,-24(fp)
 821cff4:	e17ffa8b 	ldhu	r5,-22(fp)
 821cff8:	e0bffb44 	addi	r2,fp,-19
 821cffc:	d8800015 	stw	r2,0(sp)
 821d000:	280f883a 	mov	r7,r5
 821d004:	200d883a 	mov	r6,r4
 821d008:	180b883a 	mov	r5,r3
 821d00c:	e13ff217 	ldw	r4,-56(fp)
 821d010:	82176c80 	call	82176c8 <OSFlagPend>
 821d014:	00000a06 	br	821d040 <altera_avalon_jtag_uart_read+0x1c8>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 821d018:	0001883a 	nop
 821d01c:	e0bffc17 	ldw	r2,-16(fp)
 821d020:	10c00d17 	ldw	r3,52(r2)
 821d024:	e0bff317 	ldw	r2,-52(fp)
 821d028:	1880051e 	bne	r3,r2,821d040 <altera_avalon_jtag_uart_read+0x1c8>
 821d02c:	e0bffc17 	ldw	r2,-16(fp)
 821d030:	10c00917 	ldw	r3,36(r2)
 821d034:	e0bffc17 	ldw	r2,-16(fp)
 821d038:	10800117 	ldw	r2,4(r2)
 821d03c:	18bff736 	bltu	r3,r2,821d01c <altera_avalon_jtag_uart_read+0x1a4>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 821d040:	e0bffc17 	ldw	r2,-16(fp)
 821d044:	10c00d17 	ldw	r3,52(r2)
 821d048:	e0bff317 	ldw	r2,-52(fp)
 821d04c:	18800726 	beq	r3,r2,821d06c <altera_avalon_jtag_uart_read+0x1f4>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 821d050:	e0bffe17 	ldw	r2,-8(fp)
 821d054:	00bf9d16 	blt	zero,r2,821cecc <altera_avalon_jtag_uart_read+0x54>
 821d058:	00000506 	br	821d070 <altera_avalon_jtag_uart_read+0x1f8>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
 821d05c:	0001883a 	nop
 821d060:	00000306 	br	821d070 <altera_avalon_jtag_uart_read+0x1f8>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
 821d064:	0001883a 	nop
 821d068:	00000106 	br	821d070 <altera_avalon_jtag_uart_read+0x1f8>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
 821d06c:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
 821d070:	e0bffc17 	ldw	r2,-16(fp)
 821d074:	10800a17 	ldw	r2,40(r2)
 821d078:	1009883a 	mov	r4,r2
 821d07c:	821a4a80 	call	821a4a8 <OSSemPost>

  if (ptr != buffer)
 821d080:	e0fff017 	ldw	r3,-64(fp)
 821d084:	e0bffd17 	ldw	r2,-12(fp)
 821d088:	18801826 	beq	r3,r2,821d0ec <altera_avalon_jtag_uart_read+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821d08c:	0005303a 	rdctl	r2,status
 821d090:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821d094:	e0fff717 	ldw	r3,-36(fp)
 821d098:	00bfff84 	movi	r2,-2
 821d09c:	1884703a 	and	r2,r3,r2
 821d0a0:	1001703a 	wrctl	status,r2
  
  return context;
 821d0a4:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 821d0a8:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 821d0ac:	e0bffc17 	ldw	r2,-16(fp)
 821d0b0:	10800817 	ldw	r2,32(r2)
 821d0b4:	10c00054 	ori	r3,r2,1
 821d0b8:	e0bffc17 	ldw	r2,-16(fp)
 821d0bc:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 821d0c0:	e0bffc17 	ldw	r2,-16(fp)
 821d0c4:	10800017 	ldw	r2,0(r2)
 821d0c8:	10800104 	addi	r2,r2,4
 821d0cc:	1007883a 	mov	r3,r2
 821d0d0:	e0bffc17 	ldw	r2,-16(fp)
 821d0d4:	10800817 	ldw	r2,32(r2)
 821d0d8:	18800035 	stwio	r2,0(r3)
 821d0dc:	e0bff617 	ldw	r2,-40(fp)
 821d0e0:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821d0e4:	e0bff517 	ldw	r2,-44(fp)
 821d0e8:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 821d0ec:	e0fff017 	ldw	r3,-64(fp)
 821d0f0:	e0bffd17 	ldw	r2,-12(fp)
 821d0f4:	18800426 	beq	r3,r2,821d108 <altera_avalon_jtag_uart_read+0x290>
    return ptr - buffer;
 821d0f8:	e0fff017 	ldw	r3,-64(fp)
 821d0fc:	e0bffd17 	ldw	r2,-12(fp)
 821d100:	1885c83a 	sub	r2,r3,r2
 821d104:	00000606 	br	821d120 <altera_avalon_jtag_uart_read+0x2a8>
  else if (flags & O_NONBLOCK)
 821d108:	e0bfff17 	ldw	r2,-4(fp)
 821d10c:	1090000c 	andi	r2,r2,16384
 821d110:	10000226 	beq	r2,zero,821d11c <altera_avalon_jtag_uart_read+0x2a4>
    return -EWOULDBLOCK;
 821d114:	00bffd44 	movi	r2,-11
 821d118:	00000106 	br	821d120 <altera_avalon_jtag_uart_read+0x2a8>
  else
    return -EIO;
 821d11c:	00bffec4 	movi	r2,-5
}
 821d120:	e037883a 	mov	sp,fp
 821d124:	dfc00117 	ldw	ra,4(sp)
 821d128:	df000017 	ldw	fp,0(sp)
 821d12c:	dec00204 	addi	sp,sp,8
 821d130:	f800283a 	ret

0821d134 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 821d134:	deffed04 	addi	sp,sp,-76
 821d138:	dfc01215 	stw	ra,72(sp)
 821d13c:	df001115 	stw	fp,68(sp)
 821d140:	df001104 	addi	fp,sp,68
 821d144:	e13ffc15 	stw	r4,-16(fp)
 821d148:	e17ffd15 	stw	r5,-12(fp)
 821d14c:	e1bffe15 	stw	r6,-8(fp)
 821d150:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 821d154:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 821d158:	e0bffd17 	ldw	r2,-12(fp)
 821d15c:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
 821d160:	e0bffc17 	ldw	r2,-16(fp)
 821d164:	10800b17 	ldw	r2,44(r2)
 821d168:	e0bff815 	stw	r2,-32(fp)
 821d16c:	e03ff90d 	sth	zero,-28(fp)
 821d170:	e0bff90b 	ldhu	r2,-28(fp)
 821d174:	e0fffb44 	addi	r3,fp,-19
 821d178:	180d883a 	mov	r6,r3
 821d17c:	100b883a 	mov	r5,r2
 821d180:	e13ff817 	ldw	r4,-32(fp)
 821d184:	821a1300 	call	821a130 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 821d188:	00003706 	br	821d268 <altera_avalon_jtag_uart_write+0x134>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 821d18c:	e0bffc17 	ldw	r2,-16(fp)
 821d190:	10800f17 	ldw	r2,60(r2)
 821d194:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
 821d198:	e0bffc17 	ldw	r2,-16(fp)
 821d19c:	10801017 	ldw	r2,64(r2)
 821d1a0:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
 821d1a4:	e0fff417 	ldw	r3,-48(fp)
 821d1a8:	e0bff017 	ldw	r2,-64(fp)
 821d1ac:	1880062e 	bgeu	r3,r2,821d1c8 <altera_avalon_jtag_uart_write+0x94>
        n = out - 1 - in;
 821d1b0:	e0fff017 	ldw	r3,-64(fp)
 821d1b4:	e0bff417 	ldw	r2,-48(fp)
 821d1b8:	1885c83a 	sub	r2,r3,r2
 821d1bc:	10bfffc4 	addi	r2,r2,-1
 821d1c0:	e0bff115 	stw	r2,-60(fp)
 821d1c4:	00000b06 	br	821d1f4 <altera_avalon_jtag_uart_write+0xc0>
      else if (out > 0)
 821d1c8:	e0bff017 	ldw	r2,-64(fp)
 821d1cc:	10000526 	beq	r2,zero,821d1e4 <altera_avalon_jtag_uart_write+0xb0>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 821d1d0:	00c20004 	movi	r3,2048
 821d1d4:	e0bff417 	ldw	r2,-48(fp)
 821d1d8:	1885c83a 	sub	r2,r3,r2
 821d1dc:	e0bff115 	stw	r2,-60(fp)
 821d1e0:	00000406 	br	821d1f4 <altera_avalon_jtag_uart_write+0xc0>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 821d1e4:	00c1ffc4 	movi	r3,2047
 821d1e8:	e0bff417 	ldw	r2,-48(fp)
 821d1ec:	1885c83a 	sub	r2,r3,r2
 821d1f0:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
 821d1f4:	e0bff117 	ldw	r2,-60(fp)
 821d1f8:	10001e26 	beq	r2,zero,821d274 <altera_avalon_jtag_uart_write+0x140>
        break;

      if (n > count)
 821d1fc:	e0fffe17 	ldw	r3,-8(fp)
 821d200:	e0bff117 	ldw	r2,-60(fp)
 821d204:	1880022e 	bgeu	r3,r2,821d210 <altera_avalon_jtag_uart_write+0xdc>
        n = count;
 821d208:	e0bffe17 	ldw	r2,-8(fp)
 821d20c:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 821d210:	e0bffc17 	ldw	r2,-16(fp)
 821d214:	10c21104 	addi	r3,r2,2116
 821d218:	e0bff417 	ldw	r2,-48(fp)
 821d21c:	1885883a 	add	r2,r3,r2
 821d220:	e1bff117 	ldw	r6,-60(fp)
 821d224:	e17ffd17 	ldw	r5,-12(fp)
 821d228:	1009883a 	mov	r4,r2
 821d22c:	8202f6c0 	call	8202f6c <memcpy>
      ptr   += n;
 821d230:	e0fffd17 	ldw	r3,-12(fp)
 821d234:	e0bff117 	ldw	r2,-60(fp)
 821d238:	1885883a 	add	r2,r3,r2
 821d23c:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
 821d240:	e0fffe17 	ldw	r3,-8(fp)
 821d244:	e0bff117 	ldw	r2,-60(fp)
 821d248:	1885c83a 	sub	r2,r3,r2
 821d24c:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821d250:	e0fff417 	ldw	r3,-48(fp)
 821d254:	e0bff117 	ldw	r2,-60(fp)
 821d258:	1885883a 	add	r2,r3,r2
 821d25c:	10c1ffcc 	andi	r3,r2,2047
 821d260:	e0bffc17 	ldw	r2,-16(fp)
 821d264:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 821d268:	e0bffe17 	ldw	r2,-8(fp)
 821d26c:	00bfc716 	blt	zero,r2,821d18c <altera_avalon_jtag_uart_write+0x58>
 821d270:	00000106 	br	821d278 <altera_avalon_jtag_uart_write+0x144>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
 821d274:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821d278:	0005303a 	rdctl	r2,status
 821d27c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821d280:	e0fff717 	ldw	r3,-36(fp)
 821d284:	00bfff84 	movi	r2,-2
 821d288:	1884703a 	and	r2,r3,r2
 821d28c:	1001703a 	wrctl	status,r2
  
  return context;
 821d290:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 821d294:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 821d298:	e0bffc17 	ldw	r2,-16(fp)
 821d29c:	10800817 	ldw	r2,32(r2)
 821d2a0:	10c00094 	ori	r3,r2,2
 821d2a4:	e0bffc17 	ldw	r2,-16(fp)
 821d2a8:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 821d2ac:	e0bffc17 	ldw	r2,-16(fp)
 821d2b0:	10800017 	ldw	r2,0(r2)
 821d2b4:	10800104 	addi	r2,r2,4
 821d2b8:	1007883a 	mov	r3,r2
 821d2bc:	e0bffc17 	ldw	r2,-16(fp)
 821d2c0:	10800817 	ldw	r2,32(r2)
 821d2c4:	18800035 	stwio	r2,0(r3)
 821d2c8:	e0bff617 	ldw	r2,-40(fp)
 821d2cc:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821d2d0:	e0bff317 	ldw	r2,-52(fp)
 821d2d4:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 821d2d8:	e0bffe17 	ldw	r2,-8(fp)
 821d2dc:	00802a0e 	bge	zero,r2,821d388 <altera_avalon_jtag_uart_write+0x254>
    {
      if (flags & O_NONBLOCK)
 821d2e0:	e0bfff17 	ldw	r2,-4(fp)
 821d2e4:	1090000c 	andi	r2,r2,16384
 821d2e8:	10002a1e 	bne	r2,zero,821d394 <altera_avalon_jtag_uart_write+0x260>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
 821d2ec:	d0a06b43 	ldbu	r2,-32339(gp)
 821d2f0:	10803fcc 	andi	r2,r2,255
 821d2f4:	10800058 	cmpnei	r2,r2,1
 821d2f8:	1000161e 	bne	r2,zero,821d354 <altera_avalon_jtag_uart_write+0x220>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
 821d2fc:	e0bffc17 	ldw	r2,-16(fp)
 821d300:	10800c17 	ldw	r2,48(r2)
 821d304:	e0bff515 	stw	r2,-44(fp)
 821d308:	00800184 	movi	r2,6
 821d30c:	e0bff98d 	sth	r2,-26(fp)
 821d310:	00bfe0c4 	movi	r2,-125
 821d314:	e0bffa05 	stb	r2,-24(fp)
 821d318:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 821d31c:	d0a06b43 	ldbu	r2,-32339(gp)
 821d320:	10803fcc 	andi	r2,r2,255
 821d324:	10001526 	beq	r2,zero,821d37c <altera_avalon_jtag_uart_write+0x248>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 821d328:	e0fff98b 	ldhu	r3,-26(fp)
 821d32c:	e13ffa03 	ldbu	r4,-24(fp)
 821d330:	e17ffa8b 	ldhu	r5,-22(fp)
 821d334:	e0bffb04 	addi	r2,fp,-20
 821d338:	d8800015 	stw	r2,0(sp)
 821d33c:	280f883a 	mov	r7,r5
 821d340:	200d883a 	mov	r6,r4
 821d344:	180b883a 	mov	r5,r3
 821d348:	e13ff517 	ldw	r4,-44(fp)
 821d34c:	82176c80 	call	82176c8 <OSFlagPend>
 821d350:	00000a06 	br	821d37c <altera_avalon_jtag_uart_write+0x248>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 821d354:	0001883a 	nop
 821d358:	e0bffc17 	ldw	r2,-16(fp)
 821d35c:	10c01017 	ldw	r3,64(r2)
 821d360:	e0bff017 	ldw	r2,-64(fp)
 821d364:	1880051e 	bne	r3,r2,821d37c <altera_avalon_jtag_uart_write+0x248>
 821d368:	e0bffc17 	ldw	r2,-16(fp)
 821d36c:	10c00917 	ldw	r3,36(r2)
 821d370:	e0bffc17 	ldw	r2,-16(fp)
 821d374:	10800117 	ldw	r2,4(r2)
 821d378:	18bff736 	bltu	r3,r2,821d358 <altera_avalon_jtag_uart_write+0x224>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 821d37c:	e0bffc17 	ldw	r2,-16(fp)
 821d380:	10800917 	ldw	r2,36(r2)
 821d384:	1000051e 	bne	r2,zero,821d39c <altera_avalon_jtag_uart_write+0x268>
         break;
    }
  }
  while (count > 0);
 821d388:	e0bffe17 	ldw	r2,-8(fp)
 821d38c:	00bfb616 	blt	zero,r2,821d268 <altera_avalon_jtag_uart_write+0x134>
 821d390:	00000306 	br	821d3a0 <altera_avalon_jtag_uart_write+0x26c>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
 821d394:	0001883a 	nop
 821d398:	00000106 	br	821d3a0 <altera_avalon_jtag_uart_write+0x26c>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
 821d39c:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
 821d3a0:	e0bffc17 	ldw	r2,-16(fp)
 821d3a4:	10800b17 	ldw	r2,44(r2)
 821d3a8:	1009883a 	mov	r4,r2
 821d3ac:	821a4a80 	call	821a4a8 <OSSemPost>

  if (ptr != start)
 821d3b0:	e0fffd17 	ldw	r3,-12(fp)
 821d3b4:	e0bff217 	ldw	r2,-56(fp)
 821d3b8:	18800426 	beq	r3,r2,821d3cc <altera_avalon_jtag_uart_write+0x298>
    return ptr - start;
 821d3bc:	e0fffd17 	ldw	r3,-12(fp)
 821d3c0:	e0bff217 	ldw	r2,-56(fp)
 821d3c4:	1885c83a 	sub	r2,r3,r2
 821d3c8:	00000606 	br	821d3e4 <altera_avalon_jtag_uart_write+0x2b0>
  else if (flags & O_NONBLOCK)
 821d3cc:	e0bfff17 	ldw	r2,-4(fp)
 821d3d0:	1090000c 	andi	r2,r2,16384
 821d3d4:	10000226 	beq	r2,zero,821d3e0 <altera_avalon_jtag_uart_write+0x2ac>
    return -EWOULDBLOCK;
 821d3d8:	00bffd44 	movi	r2,-11
 821d3dc:	00000106 	br	821d3e4 <altera_avalon_jtag_uart_write+0x2b0>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 821d3e0:	00bffec4 	movi	r2,-5
}
 821d3e4:	e037883a 	mov	sp,fp
 821d3e8:	dfc00117 	ldw	ra,4(sp)
 821d3ec:	df000017 	ldw	fp,0(sp)
 821d3f0:	dec00204 	addi	sp,sp,8
 821d3f4:	f800283a 	ret

0821d3f8 <lcd_write_command>:

/* --------------------------------------------------------------------- */

static void lcd_write_command(altera_avalon_lcd_16207_state* sp, 
  unsigned char command)
{
 821d3f8:	defffa04 	addi	sp,sp,-24
 821d3fc:	dfc00515 	stw	ra,20(sp)
 821d400:	df000415 	stw	fp,16(sp)
 821d404:	df000404 	addi	fp,sp,16
 821d408:	e13ffe15 	stw	r4,-8(fp)
 821d40c:	2805883a 	mov	r2,r5
 821d410:	e0bfff05 	stb	r2,-4(fp)
  unsigned int base = sp->base;
 821d414:	e0bffe17 	ldw	r2,-8(fp)
 821d418:	10800017 	ldw	r2,0(r2)
 821d41c:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 821d420:	008003f4 	movhi	r2,15
 821d424:	10909004 	addi	r2,r2,16960
 821d428:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 821d42c:	e0bffe17 	ldw	r2,-8(fp)
 821d430:	10800803 	ldbu	r2,32(r2)
 821d434:	10803fcc 	andi	r2,r2,255
 821d438:	1080201c 	xori	r2,r2,128
 821d43c:	10bfe004 	addi	r2,r2,-128
 821d440:	1000151e 	bne	r2,zero,821d498 <lcd_write_command+0xa0>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 821d444:	00000906 	br	821d46c <lcd_write_command+0x74>
    if (--i == 0)
 821d448:	e0bffc17 	ldw	r2,-16(fp)
 821d44c:	10bfffc4 	addi	r2,r2,-1
 821d450:	e0bffc15 	stw	r2,-16(fp)
 821d454:	e0bffc17 	ldw	r2,-16(fp)
 821d458:	1000041e 	bne	r2,zero,821d46c <lcd_write_command+0x74>
    {
      sp->broken = 1;
 821d45c:	e0bffe17 	ldw	r2,-8(fp)
 821d460:	00c00044 	movi	r3,1
 821d464:	10c00805 	stb	r3,32(r2)
      return;
 821d468:	00000c06 	br	821d49c <lcd_write_command+0xa4>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 821d46c:	e0bffd17 	ldw	r2,-12(fp)
 821d470:	10800104 	addi	r2,r2,4
 821d474:	10800037 	ldwio	r2,0(r2)
 821d478:	1080200c 	andi	r2,r2,128
 821d47c:	103ff21e 	bne	r2,zero,821d448 <lcd_write_command+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 821d480:	01001904 	movi	r4,100
 821d484:	823ca800 	call	823ca80 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, command);
 821d488:	e0bffd17 	ldw	r2,-12(fp)
 821d48c:	e0ffff03 	ldbu	r3,-4(fp)
 821d490:	10c00035 	stwio	r3,0(r2)
 821d494:	00000106 	br	821d49c <lcd_write_command+0xa4>
   */
  int i = 1000000;

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;
 821d498:	0001883a 	nop
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);

  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, command);
}
 821d49c:	e037883a 	mov	sp,fp
 821d4a0:	dfc00117 	ldw	ra,4(sp)
 821d4a4:	df000017 	ldw	fp,0(sp)
 821d4a8:	dec00204 	addi	sp,sp,8
 821d4ac:	f800283a 	ret

0821d4b0 <lcd_write_data>:

/* --------------------------------------------------------------------- */

static void lcd_write_data(altera_avalon_lcd_16207_state* sp, 
  unsigned char data)
{
 821d4b0:	defffa04 	addi	sp,sp,-24
 821d4b4:	dfc00515 	stw	ra,20(sp)
 821d4b8:	df000415 	stw	fp,16(sp)
 821d4bc:	df000404 	addi	fp,sp,16
 821d4c0:	e13ffe15 	stw	r4,-8(fp)
 821d4c4:	2805883a 	mov	r2,r5
 821d4c8:	e0bfff05 	stb	r2,-4(fp)
  unsigned int base = sp->base;
 821d4cc:	e0bffe17 	ldw	r2,-8(fp)
 821d4d0:	10800017 	ldw	r2,0(r2)
 821d4d4:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 821d4d8:	008003f4 	movhi	r2,15
 821d4dc:	10909004 	addi	r2,r2,16960
 821d4e0:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 821d4e4:	e0bffe17 	ldw	r2,-8(fp)
 821d4e8:	10800803 	ldbu	r2,32(r2)
 821d4ec:	10803fcc 	andi	r2,r2,255
 821d4f0:	1080201c 	xori	r2,r2,128
 821d4f4:	10bfe004 	addi	r2,r2,-128
 821d4f8:	10001d1e 	bne	r2,zero,821d570 <lcd_write_data+0xc0>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 821d4fc:	00000906 	br	821d524 <lcd_write_data+0x74>
    if (--i == 0)
 821d500:	e0bffc17 	ldw	r2,-16(fp)
 821d504:	10bfffc4 	addi	r2,r2,-1
 821d508:	e0bffc15 	stw	r2,-16(fp)
 821d50c:	e0bffc17 	ldw	r2,-16(fp)
 821d510:	1000041e 	bne	r2,zero,821d524 <lcd_write_data+0x74>
    {
      sp->broken = 1;
 821d514:	e0bffe17 	ldw	r2,-8(fp)
 821d518:	00c00044 	movi	r3,1
 821d51c:	10c00805 	stb	r3,32(r2)
      return;
 821d520:	00001406 	br	821d574 <lcd_write_data+0xc4>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 821d524:	e0bffd17 	ldw	r2,-12(fp)
 821d528:	10800104 	addi	r2,r2,4
 821d52c:	10800037 	ldwio	r2,0(r2)
 821d530:	1080200c 	andi	r2,r2,128
 821d534:	103ff21e 	bne	r2,zero,821d500 <lcd_write_data+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 821d538:	01001904 	movi	r4,100
 821d53c:	823ca800 	call	823ca80 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_DATA(base, data);
 821d540:	e0bffd17 	ldw	r2,-12(fp)
 821d544:	10800204 	addi	r2,r2,8
 821d548:	1007883a 	mov	r3,r2
 821d54c:	e0bfff03 	ldbu	r2,-4(fp)
 821d550:	18800035 	stwio	r2,0(r3)

  sp->address++;
 821d554:	e0bffe17 	ldw	r2,-8(fp)
 821d558:	108008c3 	ldbu	r2,35(r2)
 821d55c:	10800044 	addi	r2,r2,1
 821d560:	1007883a 	mov	r3,r2
 821d564:	e0bffe17 	ldw	r2,-8(fp)
 821d568:	10c008c5 	stb	r3,35(r2)
 821d56c:	00000106 	br	821d574 <lcd_write_data+0xc4>
   */
  int i = 1000000;

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;
 821d570:	0001883a 	nop
  usleep(100);

  IOWR_ALTERA_AVALON_LCD_16207_DATA(base, data);

  sp->address++;
}
 821d574:	e037883a 	mov	sp,fp
 821d578:	dfc00117 	ldw	ra,4(sp)
 821d57c:	df000017 	ldw	fp,0(sp)
 821d580:	dec00204 	addi	sp,sp,8
 821d584:	f800283a 	ret

0821d588 <lcd_clear_screen>:

/* --------------------------------------------------------------------- */

static void lcd_clear_screen(altera_avalon_lcd_16207_state* sp)
{
 821d588:	defffc04 	addi	sp,sp,-16
 821d58c:	dfc00315 	stw	ra,12(sp)
 821d590:	df000215 	stw	fp,8(sp)
 821d594:	df000204 	addi	fp,sp,8
 821d598:	e13fff15 	stw	r4,-4(fp)
  int y;

  lcd_write_command(sp, LCD_CMD_CLEAR);
 821d59c:	01400044 	movi	r5,1
 821d5a0:	e13fff17 	ldw	r4,-4(fp)
 821d5a4:	821d3f80 	call	821d3f8 <lcd_write_command>

  sp->x = 0;
 821d5a8:	e0bfff17 	ldw	r2,-4(fp)
 821d5ac:	10000845 	stb	zero,33(r2)
  sp->y = 0;
 821d5b0:	e0bfff17 	ldw	r2,-4(fp)
 821d5b4:	10000885 	stb	zero,34(r2)
  sp->address = 0;
 821d5b8:	e0bfff17 	ldw	r2,-4(fp)
 821d5bc:	100008c5 	stb	zero,35(r2)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d5c0:	e03ffe15 	stw	zero,-8(fp)
 821d5c4:	00001b06 	br	821d634 <lcd_clear_screen+0xac>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
 821d5c8:	e0bffe17 	ldw	r2,-8(fp)
 821d5cc:	108018e4 	muli	r2,r2,99
 821d5d0:	10801004 	addi	r2,r2,64
 821d5d4:	e0ffff17 	ldw	r3,-4(fp)
 821d5d8:	1885883a 	add	r2,r3,r2
 821d5dc:	01801444 	movi	r6,81
 821d5e0:	01400804 	movi	r5,32
 821d5e4:	1009883a 	mov	r4,r2
 821d5e8:	82032100 	call	8203210 <memset>
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
 821d5ec:	e0bffe17 	ldw	r2,-8(fp)
 821d5f0:	108018e4 	muli	r2,r2,99
 821d5f4:	10800c04 	addi	r2,r2,48
 821d5f8:	e0ffff17 	ldw	r3,-4(fp)
 821d5fc:	1885883a 	add	r2,r3,r2
 821d600:	01800404 	movi	r6,16
 821d604:	01400804 	movi	r5,32
 821d608:	1009883a 	mov	r4,r2
 821d60c:	82032100 	call	8203210 <memset>
    sp->line[y].width = 0;
 821d610:	e0ffff17 	ldw	r3,-4(fp)
 821d614:	e0bffe17 	ldw	r2,-8(fp)
 821d618:	108018e4 	muli	r2,r2,99
 821d61c:	1885883a 	add	r2,r3,r2
 821d620:	10802444 	addi	r2,r2,145
 821d624:	10000005 	stb	zero,0(r2)

  sp->x = 0;
  sp->y = 0;
  sp->address = 0;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d628:	e0bffe17 	ldw	r2,-8(fp)
 821d62c:	10800044 	addi	r2,r2,1
 821d630:	e0bffe15 	stw	r2,-8(fp)
 821d634:	e0bffe17 	ldw	r2,-8(fp)
 821d638:	10800090 	cmplti	r2,r2,2
 821d63c:	103fe21e 	bne	r2,zero,821d5c8 <lcd_clear_screen+0x40>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
    sp->line[y].width = 0;
  }
}
 821d640:	0001883a 	nop
 821d644:	e037883a 	mov	sp,fp
 821d648:	dfc00117 	ldw	ra,4(sp)
 821d64c:	df000017 	ldw	fp,0(sp)
 821d650:	dec00204 	addi	sp,sp,8
 821d654:	f800283a 	ret

0821d658 <lcd_repaint_screen>:

/* --------------------------------------------------------------------- */

static void lcd_repaint_screen(altera_avalon_lcd_16207_state* sp)
{
 821d658:	defff704 	addi	sp,sp,-36
 821d65c:	dfc00815 	stw	ra,32(sp)
 821d660:	df000715 	stw	fp,28(sp)
 821d664:	df000704 	addi	fp,sp,28
 821d668:	e13fff15 	stw	r4,-4(fp)
  /* scrollpos controls how much the lines have scrolled round.  The speed
   * each line scrolls at is controlled by its speed variable - while
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;
 821d66c:	e0bfff17 	ldw	r2,-4(fp)
 821d670:	10800943 	ldbu	r2,37(r2)
 821d674:	10803fcc 	andi	r2,r2,255
 821d678:	e0bffc15 	stw	r2,-16(fp)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d67c:	e03ff915 	stw	zero,-28(fp)
 821d680:	00006706 	br	821d820 <lcd_repaint_screen+0x1c8>
  {
    int width  = sp->line[y].width;
 821d684:	e0ffff17 	ldw	r3,-4(fp)
 821d688:	e0bff917 	ldw	r2,-28(fp)
 821d68c:	108018e4 	muli	r2,r2,99
 821d690:	1885883a 	add	r2,r3,r2
 821d694:	10802444 	addi	r2,r2,145
 821d698:	10800003 	ldbu	r2,0(r2)
 821d69c:	10803fcc 	andi	r2,r2,255
 821d6a0:	1080201c 	xori	r2,r2,128
 821d6a4:	10bfe004 	addi	r2,r2,-128
 821d6a8:	e0bffd15 	stw	r2,-12(fp)
    int offset = (scrollpos * sp->line[y].speed) >> 8;
 821d6ac:	e0ffff17 	ldw	r3,-4(fp)
 821d6b0:	e0bff917 	ldw	r2,-28(fp)
 821d6b4:	108018e4 	muli	r2,r2,99
 821d6b8:	1885883a 	add	r2,r3,r2
 821d6bc:	10802484 	addi	r2,r2,146
 821d6c0:	10800003 	ldbu	r2,0(r2)
 821d6c4:	10c03fcc 	andi	r3,r2,255
 821d6c8:	e0bffc17 	ldw	r2,-16(fp)
 821d6cc:	1885383a 	mul	r2,r3,r2
 821d6d0:	1005d23a 	srai	r2,r2,8
 821d6d4:	e0bffb15 	stw	r2,-20(fp)
    if (offset >= width)
 821d6d8:	e0fffb17 	ldw	r3,-20(fp)
 821d6dc:	e0bffd17 	ldw	r2,-12(fp)
 821d6e0:	18800116 	blt	r3,r2,821d6e8 <lcd_repaint_screen+0x90>
      offset = 0;
 821d6e4:	e03ffb15 	stw	zero,-20(fp)

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 821d6e8:	e03ffa15 	stw	zero,-24(fp)
 821d6ec:	00004606 	br	821d808 <lcd_repaint_screen+0x1b0>
    {
      char c = sp->line[y].data[(x + offset) % width];
 821d6f0:	e0fffa17 	ldw	r3,-24(fp)
 821d6f4:	e0bffb17 	ldw	r2,-20(fp)
 821d6f8:	1885883a 	add	r2,r3,r2
 821d6fc:	e17ffd17 	ldw	r5,-12(fp)
 821d700:	1009883a 	mov	r4,r2
 821d704:	8202bf80 	call	8202bf8 <__modsi3>
 821d708:	1009883a 	mov	r4,r2
 821d70c:	e0ffff17 	ldw	r3,-4(fp)
 821d710:	e0bff917 	ldw	r2,-28(fp)
 821d714:	108018e4 	muli	r2,r2,99
 821d718:	1885883a 	add	r2,r3,r2
 821d71c:	1105883a 	add	r2,r2,r4
 821d720:	10801004 	addi	r2,r2,64
 821d724:	10800003 	ldbu	r2,0(r2)
 821d728:	e0bffe05 	stb	r2,-8(fp)

      /* Writing data takes 40us, so don't do it unless required */
      if (sp->line[y].visible[x] != c)
 821d72c:	e0ffff17 	ldw	r3,-4(fp)
 821d730:	e0bff917 	ldw	r2,-28(fp)
 821d734:	108018e4 	muli	r2,r2,99
 821d738:	1887883a 	add	r3,r3,r2
 821d73c:	e0bffa17 	ldw	r2,-24(fp)
 821d740:	1885883a 	add	r2,r3,r2
 821d744:	10800c04 	addi	r2,r2,48
 821d748:	10800003 	ldbu	r2,0(r2)
 821d74c:	10c03fcc 	andi	r3,r2,255
 821d750:	18c0201c 	xori	r3,r3,128
 821d754:	18ffe004 	addi	r3,r3,-128
 821d758:	e0bffe07 	ldb	r2,-8(fp)
 821d75c:	18802726 	beq	r3,r2,821d7fc <lcd_repaint_screen+0x1a4>
      {
        unsigned char address = x + colstart[y];
 821d760:	e0fff917 	ldw	r3,-28(fp)
 821d764:	d0a02a04 	addi	r2,gp,-32600
 821d768:	1885883a 	add	r2,r3,r2
 821d76c:	10800003 	ldbu	r2,0(r2)
 821d770:	1007883a 	mov	r3,r2
 821d774:	e0bffa17 	ldw	r2,-24(fp)
 821d778:	1885883a 	add	r2,r3,r2
 821d77c:	e0bffe45 	stb	r2,-7(fp)

        if (address != sp->address)
 821d780:	e0fffe43 	ldbu	r3,-7(fp)
 821d784:	e0bfff17 	ldw	r2,-4(fp)
 821d788:	108008c3 	ldbu	r2,35(r2)
 821d78c:	10803fcc 	andi	r2,r2,255
 821d790:	1080201c 	xori	r2,r2,128
 821d794:	10bfe004 	addi	r2,r2,-128
 821d798:	18800a26 	beq	r3,r2,821d7c4 <lcd_repaint_screen+0x16c>
        {
          lcd_write_command(sp, LCD_CMD_WRITE_DATA | address);
 821d79c:	e0fffe43 	ldbu	r3,-7(fp)
 821d7a0:	00bfe004 	movi	r2,-128
 821d7a4:	1884b03a 	or	r2,r3,r2
 821d7a8:	10803fcc 	andi	r2,r2,255
 821d7ac:	100b883a 	mov	r5,r2
 821d7b0:	e13fff17 	ldw	r4,-4(fp)
 821d7b4:	821d3f80 	call	821d3f8 <lcd_write_command>
          sp->address = address;
 821d7b8:	e0fffe43 	ldbu	r3,-7(fp)
 821d7bc:	e0bfff17 	ldw	r2,-4(fp)
 821d7c0:	10c008c5 	stb	r3,35(r2)
        }

        lcd_write_data(sp, c);
 821d7c4:	e0bffe03 	ldbu	r2,-8(fp)
 821d7c8:	10803fcc 	andi	r2,r2,255
 821d7cc:	100b883a 	mov	r5,r2
 821d7d0:	e13fff17 	ldw	r4,-4(fp)
 821d7d4:	821d4b00 	call	821d4b0 <lcd_write_data>
        sp->line[y].visible[x] = c;
 821d7d8:	e0ffff17 	ldw	r3,-4(fp)
 821d7dc:	e0bff917 	ldw	r2,-28(fp)
 821d7e0:	108018e4 	muli	r2,r2,99
 821d7e4:	1887883a 	add	r3,r3,r2
 821d7e8:	e0bffa17 	ldw	r2,-24(fp)
 821d7ec:	1885883a 	add	r2,r3,r2
 821d7f0:	10800c04 	addi	r2,r2,48
 821d7f4:	e0fffe03 	ldbu	r3,-8(fp)
 821d7f8:	10c00005 	stb	r3,0(r2)
    int width  = sp->line[y].width;
    int offset = (scrollpos * sp->line[y].speed) >> 8;
    if (offset >= width)
      offset = 0;

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 821d7fc:	e0bffa17 	ldw	r2,-24(fp)
 821d800:	10800044 	addi	r2,r2,1
 821d804:	e0bffa15 	stw	r2,-24(fp)
 821d808:	e0bffa17 	ldw	r2,-24(fp)
 821d80c:	10800410 	cmplti	r2,r2,16
 821d810:	103fb71e 	bne	r2,zero,821d6f0 <lcd_repaint_screen+0x98>
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d814:	e0bff917 	ldw	r2,-28(fp)
 821d818:	10800044 	addi	r2,r2,1
 821d81c:	e0bff915 	stw	r2,-28(fp)
 821d820:	e0bff917 	ldw	r2,-28(fp)
 821d824:	10800090 	cmplti	r2,r2,2
 821d828:	103f961e 	bne	r2,zero,821d684 <lcd_repaint_screen+0x2c>
        lcd_write_data(sp, c);
        sp->line[y].visible[x] = c;
      }
    }
  }
}
 821d82c:	0001883a 	nop
 821d830:	e037883a 	mov	sp,fp
 821d834:	dfc00117 	ldw	ra,4(sp)
 821d838:	df000017 	ldw	fp,0(sp)
 821d83c:	dec00204 	addi	sp,sp,8
 821d840:	f800283a 	ret

0821d844 <lcd_scroll_up>:

/* --------------------------------------------------------------------- */

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
 821d844:	defffc04 	addi	sp,sp,-16
 821d848:	dfc00315 	stw	ra,12(sp)
 821d84c:	df000215 	stw	fp,8(sp)
 821d850:	df000204 	addi	fp,sp,8
 821d854:	e13fff15 	stw	r4,-4(fp)
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d858:	e03ffe15 	stw	zero,-8(fp)
 821d85c:	00001d06 	br	821d8d4 <lcd_scroll_up+0x90>
  {
    if (y < ALT_LCD_HEIGHT-1)
 821d860:	e0bffe17 	ldw	r2,-8(fp)
 821d864:	00800f16 	blt	zero,r2,821d8a4 <lcd_scroll_up+0x60>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
 821d868:	e0bffe17 	ldw	r2,-8(fp)
 821d86c:	108018e4 	muli	r2,r2,99
 821d870:	10801004 	addi	r2,r2,64
 821d874:	e0ffff17 	ldw	r3,-4(fp)
 821d878:	1889883a 	add	r4,r3,r2
 821d87c:	e0bffe17 	ldw	r2,-8(fp)
 821d880:	10800044 	addi	r2,r2,1
 821d884:	108018e4 	muli	r2,r2,99
 821d888:	10801004 	addi	r2,r2,64
 821d88c:	e0ffff17 	ldw	r3,-4(fp)
 821d890:	1885883a 	add	r2,r3,r2
 821d894:	01801404 	movi	r6,80
 821d898:	100b883a 	mov	r5,r2
 821d89c:	8202f6c0 	call	8202f6c <memcpy>
 821d8a0:	00000906 	br	821d8c8 <lcd_scroll_up+0x84>
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
 821d8a4:	e0bffe17 	ldw	r2,-8(fp)
 821d8a8:	108018e4 	muli	r2,r2,99
 821d8ac:	10801004 	addi	r2,r2,64
 821d8b0:	e0ffff17 	ldw	r3,-4(fp)
 821d8b4:	1885883a 	add	r2,r3,r2
 821d8b8:	01801404 	movi	r6,80
 821d8bc:	01400804 	movi	r5,32
 821d8c0:	1009883a 	mov	r4,r2
 821d8c4:	82032100 	call	8203210 <memset>

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d8c8:	e0bffe17 	ldw	r2,-8(fp)
 821d8cc:	10800044 	addi	r2,r2,1
 821d8d0:	e0bffe15 	stw	r2,-8(fp)
 821d8d4:	e0bffe17 	ldw	r2,-8(fp)
 821d8d8:	10800090 	cmplti	r2,r2,2
 821d8dc:	103fe01e 	bne	r2,zero,821d860 <lcd_scroll_up+0x1c>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
  }

  sp->y--;
 821d8e0:	e0bfff17 	ldw	r2,-4(fp)
 821d8e4:	10800883 	ldbu	r2,34(r2)
 821d8e8:	10bfffc4 	addi	r2,r2,-1
 821d8ec:	1007883a 	mov	r3,r2
 821d8f0:	e0bfff17 	ldw	r2,-4(fp)
 821d8f4:	10c00885 	stb	r3,34(r2)
}
 821d8f8:	0001883a 	nop
 821d8fc:	e037883a 	mov	sp,fp
 821d900:	dfc00117 	ldw	ra,4(sp)
 821d904:	df000017 	ldw	fp,0(sp)
 821d908:	dec00204 	addi	sp,sp,8
 821d90c:	f800283a 	ret

0821d910 <lcd_handle_escape>:

/* --------------------------------------------------------------------- */

static void lcd_handle_escape(altera_avalon_lcd_16207_state* sp, char c)
{
 821d910:	defff904 	addi	sp,sp,-28
 821d914:	dfc00615 	stw	ra,24(sp)
 821d918:	df000515 	stw	fp,20(sp)
 821d91c:	df000504 	addi	fp,sp,20
 821d920:	e13ffe15 	stw	r4,-8(fp)
 821d924:	2805883a 	mov	r2,r5
 821d928:	e0bfff05 	stb	r2,-4(fp)
  int parm1 = 0, parm2 = 0;
 821d92c:	e03ffb15 	stw	zero,-20(fp)
 821d930:	e03ffc15 	stw	zero,-16(fp)

  if (sp->escape[0] == '[')
 821d934:	e0bffe17 	ldw	r2,-8(fp)
 821d938:	10800a03 	ldbu	r2,40(r2)
 821d93c:	10803fcc 	andi	r2,r2,255
 821d940:	1080201c 	xori	r2,r2,128
 821d944:	10bfe004 	addi	r2,r2,-128
 821d948:	108016d8 	cmpnei	r2,r2,91
 821d94c:	1000411e 	bne	r2,zero,821da54 <lcd_handle_escape+0x144>
  {
    char * ptr = sp->escape+1;
 821d950:	e0bffe17 	ldw	r2,-8(fp)
 821d954:	10800a04 	addi	r2,r2,40
 821d958:	10800044 	addi	r2,r2,1
 821d95c:	e0bffd15 	stw	r2,-12(fp)
    while (isdigit(*ptr))
 821d960:	00000c06 	br	821d994 <lcd_handle_escape+0x84>
      parm1 = (parm1 * 10) + (*ptr++ - '0');
 821d964:	e0bffb17 	ldw	r2,-20(fp)
 821d968:	10c002a4 	muli	r3,r2,10
 821d96c:	e0bffd17 	ldw	r2,-12(fp)
 821d970:	11000044 	addi	r4,r2,1
 821d974:	e13ffd15 	stw	r4,-12(fp)
 821d978:	10800003 	ldbu	r2,0(r2)
 821d97c:	10803fcc 	andi	r2,r2,255
 821d980:	1080201c 	xori	r2,r2,128
 821d984:	10bfe004 	addi	r2,r2,-128
 821d988:	10bff404 	addi	r2,r2,-48
 821d98c:	1885883a 	add	r2,r3,r2
 821d990:	e0bffb15 	stw	r2,-20(fp)
  int parm1 = 0, parm2 = 0;

  if (sp->escape[0] == '[')
  {
    char * ptr = sp->escape+1;
    while (isdigit(*ptr))
 821d994:	d0e00017 	ldw	r3,-32768(gp)
 821d998:	e0bffd17 	ldw	r2,-12(fp)
 821d99c:	10800003 	ldbu	r2,0(r2)
 821d9a0:	10803fcc 	andi	r2,r2,255
 821d9a4:	1080201c 	xori	r2,r2,128
 821d9a8:	10bfe004 	addi	r2,r2,-128
 821d9ac:	10800044 	addi	r2,r2,1
 821d9b0:	1885883a 	add	r2,r3,r2
 821d9b4:	10800003 	ldbu	r2,0(r2)
 821d9b8:	10803fcc 	andi	r2,r2,255
 821d9bc:	1080010c 	andi	r2,r2,4
 821d9c0:	103fe81e 	bne	r2,zero,821d964 <lcd_handle_escape+0x54>
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
 821d9c4:	e0bffd17 	ldw	r2,-12(fp)
 821d9c8:	10800003 	ldbu	r2,0(r2)
 821d9cc:	10803fcc 	andi	r2,r2,255
 821d9d0:	1080201c 	xori	r2,r2,128
 821d9d4:	10bfe004 	addi	r2,r2,-128
 821d9d8:	10800ed8 	cmpnei	r2,r2,59
 821d9dc:	10001f1e 	bne	r2,zero,821da5c <lcd_handle_escape+0x14c>
    {
      ptr++;
 821d9e0:	e0bffd17 	ldw	r2,-12(fp)
 821d9e4:	10800044 	addi	r2,r2,1
 821d9e8:	e0bffd15 	stw	r2,-12(fp)
      while (isdigit(*ptr))
 821d9ec:	00000c06 	br	821da20 <lcd_handle_escape+0x110>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
 821d9f0:	e0bffc17 	ldw	r2,-16(fp)
 821d9f4:	10c002a4 	muli	r3,r2,10
 821d9f8:	e0bffd17 	ldw	r2,-12(fp)
 821d9fc:	11000044 	addi	r4,r2,1
 821da00:	e13ffd15 	stw	r4,-12(fp)
 821da04:	10800003 	ldbu	r2,0(r2)
 821da08:	10803fcc 	andi	r2,r2,255
 821da0c:	1080201c 	xori	r2,r2,128
 821da10:	10bfe004 	addi	r2,r2,-128
 821da14:	10bff404 	addi	r2,r2,-48
 821da18:	1885883a 	add	r2,r3,r2
 821da1c:	e0bffc15 	stw	r2,-16(fp)
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
    {
      ptr++;
      while (isdigit(*ptr))
 821da20:	d0e00017 	ldw	r3,-32768(gp)
 821da24:	e0bffd17 	ldw	r2,-12(fp)
 821da28:	10800003 	ldbu	r2,0(r2)
 821da2c:	10803fcc 	andi	r2,r2,255
 821da30:	1080201c 	xori	r2,r2,128
 821da34:	10bfe004 	addi	r2,r2,-128
 821da38:	10800044 	addi	r2,r2,1
 821da3c:	1885883a 	add	r2,r3,r2
 821da40:	10800003 	ldbu	r2,0(r2)
 821da44:	10803fcc 	andi	r2,r2,255
 821da48:	1080010c 	andi	r2,r2,4
 821da4c:	103fe81e 	bne	r2,zero,821d9f0 <lcd_handle_escape+0xe0>
 821da50:	00000206 	br	821da5c <lcd_handle_escape+0x14c>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
    }
  }
  else
    parm1 = -1;
 821da54:	00bfffc4 	movi	r2,-1
 821da58:	e0bffb15 	stw	r2,-20(fp)

  switch (c)
 821da5c:	e0bfff07 	ldb	r2,-4(fp)
 821da60:	10c012a0 	cmpeqi	r3,r2,74
 821da64:	1800291e 	bne	r3,zero,821db0c <lcd_handle_escape+0x1fc>
 821da68:	10c012c8 	cmpgei	r3,r2,75
 821da6c:	1800031e 	bne	r3,zero,821da7c <lcd_handle_escape+0x16c>
 821da70:	10801220 	cmpeqi	r2,r2,72
 821da74:	1000061e 	bne	r2,zero,821da90 <lcd_handle_escape+0x180>
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
    }
    break;
  }
}
 821da78:	00004a06 	br	821dba4 <lcd_handle_escape+0x294>
    }
  }
  else
    parm1 = -1;

  switch (c)
 821da7c:	10c012e0 	cmpeqi	r3,r2,75
 821da80:	1800281e 	bne	r3,zero,821db24 <lcd_handle_escape+0x214>
 821da84:	108019a0 	cmpeqi	r2,r2,102
 821da88:	1000011e 	bne	r2,zero,821da90 <lcd_handle_escape+0x180>
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
    }
    break;
  }
}
 821da8c:	00004506 	br	821dba4 <lcd_handle_escape+0x294>

  switch (c)
  {
  case 'H': /* ESC '[' <y> ';' <x> 'H'  : Move cursor to location */
  case 'f': /* Same as above */
    if (parm2 > 0)
 821da90:	e0bffc17 	ldw	r2,-16(fp)
 821da94:	0080050e 	bge	zero,r2,821daac <lcd_handle_escape+0x19c>
      sp->x = parm2 - 1;
 821da98:	e0bffc17 	ldw	r2,-16(fp)
 821da9c:	10bfffc4 	addi	r2,r2,-1
 821daa0:	1007883a 	mov	r3,r2
 821daa4:	e0bffe17 	ldw	r2,-8(fp)
 821daa8:	10c00845 	stb	r3,33(r2)
    if (parm1 > 0)
 821daac:	e0bffb17 	ldw	r2,-20(fp)
 821dab0:	0080370e 	bge	zero,r2,821db90 <lcd_handle_escape+0x280>
    {
      sp->y = parm1 - 1;
 821dab4:	e0bffb17 	ldw	r2,-20(fp)
 821dab8:	10bfffc4 	addi	r2,r2,-1
 821dabc:	1007883a 	mov	r3,r2
 821dac0:	e0bffe17 	ldw	r2,-8(fp)
 821dac4:	10c00885 	stb	r3,34(r2)
      if (sp->y > ALT_LCD_HEIGHT * 2)
 821dac8:	e0bffe17 	ldw	r2,-8(fp)
 821dacc:	10800883 	ldbu	r2,34(r2)
 821dad0:	10803fcc 	andi	r2,r2,255
 821dad4:	10800170 	cmpltui	r2,r2,5
 821dad8:	1000061e 	bne	r2,zero,821daf4 <lcd_handle_escape+0x1e4>
        sp->y = ALT_LCD_HEIGHT * 2;
 821dadc:	e0bffe17 	ldw	r2,-8(fp)
 821dae0:	00c00104 	movi	r3,4
 821dae4:	10c00885 	stb	r3,34(r2)
      while (sp->y > ALT_LCD_HEIGHT)
 821dae8:	00000206 	br	821daf4 <lcd_handle_escape+0x1e4>
        lcd_scroll_up(sp);
 821daec:	e13ffe17 	ldw	r4,-8(fp)
 821daf0:	821d8440 	call	821d844 <lcd_scroll_up>
    if (parm1 > 0)
    {
      sp->y = parm1 - 1;
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
 821daf4:	e0bffe17 	ldw	r2,-8(fp)
 821daf8:	10800883 	ldbu	r2,34(r2)
 821dafc:	10803fcc 	andi	r2,r2,255
 821db00:	108000e8 	cmpgeui	r2,r2,3
 821db04:	103ff91e 	bne	r2,zero,821daec <lcd_handle_escape+0x1dc>
        lcd_scroll_up(sp);
    }
    break;
 821db08:	00002106 	br	821db90 <lcd_handle_escape+0x280>
    /*   ESC J      is clear to beginning of line    [unimplemented]
     *   ESC [ 0 J  is clear to bottom of screen     [unimplemented]
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
 821db0c:	e0bffb17 	ldw	r2,-20(fp)
 821db10:	10800098 	cmpnei	r2,r2,2
 821db14:	1000201e 	bne	r2,zero,821db98 <lcd_handle_escape+0x288>
      lcd_clear_screen(sp);
 821db18:	e13ffe17 	ldw	r4,-8(fp)
 821db1c:	821d5880 	call	821d588 <lcd_clear_screen>
    break;
 821db20:	00001d06 	br	821db98 <lcd_handle_escape+0x288>
    /*   ESC K      is clear to end of line
     *   ESC [ 0 K  is clear to end of line
     *   ESC [ 1 K  is clear to beginning of line    [unimplemented]
     *   ESC [ 2 K  is clear line                    [unimplemented]
     */
    if (parm1 < 1)
 821db24:	e0bffb17 	ldw	r2,-20(fp)
 821db28:	00801d16 	blt	zero,r2,821dba0 <lcd_handle_escape+0x290>
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 821db2c:	e0bffe17 	ldw	r2,-8(fp)
 821db30:	10800843 	ldbu	r2,33(r2)
 821db34:	10803fcc 	andi	r2,r2,255
 821db38:	10801428 	cmpgeui	r2,r2,80
 821db3c:	1000181e 	bne	r2,zero,821dba0 <lcd_handle_escape+0x290>
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
 821db40:	e0bffe17 	ldw	r2,-8(fp)
 821db44:	10800883 	ldbu	r2,34(r2)
 821db48:	10803fcc 	andi	r2,r2,255
 821db4c:	108018e4 	muli	r2,r2,99
 821db50:	10801004 	addi	r2,r2,64
 821db54:	e0fffe17 	ldw	r3,-8(fp)
 821db58:	1887883a 	add	r3,r3,r2
 821db5c:	e0bffe17 	ldw	r2,-8(fp)
 821db60:	10800843 	ldbu	r2,33(r2)
 821db64:	10803fcc 	andi	r2,r2,255
 821db68:	1889883a 	add	r4,r3,r2
 821db6c:	e0bffe17 	ldw	r2,-8(fp)
 821db70:	10800843 	ldbu	r2,33(r2)
 821db74:	10803fcc 	andi	r2,r2,255
 821db78:	00c01404 	movi	r3,80
 821db7c:	1885c83a 	sub	r2,r3,r2
 821db80:	100d883a 	mov	r6,r2
 821db84:	01400804 	movi	r5,32
 821db88:	82032100 	call	8203210 <memset>
    }
    break;
 821db8c:	00000406 	br	821dba0 <lcd_handle_escape+0x290>
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
        lcd_scroll_up(sp);
    }
    break;
 821db90:	0001883a 	nop
 821db94:	00000306 	br	821dba4 <lcd_handle_escape+0x294>
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
      lcd_clear_screen(sp);
    break;
 821db98:	0001883a 	nop
 821db9c:	00000106 	br	821dba4 <lcd_handle_escape+0x294>
    if (parm1 < 1)
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
    }
    break;
 821dba0:	0001883a 	nop
  }
}
 821dba4:	0001883a 	nop
 821dba8:	e037883a 	mov	sp,fp
 821dbac:	dfc00117 	ldw	ra,4(sp)
 821dbb0:	df000017 	ldw	fp,0(sp)
 821dbb4:	dec00204 	addi	sp,sp,8
 821dbb8:	f800283a 	ret

0821dbbc <altera_avalon_lcd_16207_write>:

/* --------------------------------------------------------------------- */

int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp, 
  const char* ptr, int len, int flags)
{
 821dbbc:	defff104 	addi	sp,sp,-60
 821dbc0:	dfc00e15 	stw	ra,56(sp)
 821dbc4:	df000d15 	stw	fp,52(sp)
 821dbc8:	df000d04 	addi	fp,sp,52
 821dbcc:	e13ffc15 	stw	r4,-16(fp)
 821dbd0:	e17ffd15 	stw	r5,-12(fp)
 821dbd4:	e1bffe15 	stw	r6,-8(fp)
 821dbd8:	e1ffff15 	stw	r7,-4(fp)
  const char* end = ptr + len;
 821dbdc:	e0bffe17 	ldw	r2,-8(fp)
 821dbe0:	e0fffd17 	ldw	r3,-12(fp)
 821dbe4:	1885883a 	add	r2,r3,r2
 821dbe8:	e0bff615 	stw	r2,-40(fp)

  /* When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
 821dbec:	e0bffc17 	ldw	r2,-16(fp)
 821dbf0:	10803e17 	ldw	r2,248(r2)
 821dbf4:	e0bffa15 	stw	r2,-24(fp)
 821dbf8:	e03ffb0d 	sth	zero,-20(fp)
 821dbfc:	e0bffb0b 	ldhu	r2,-20(fp)
 821dc00:	e0fffb84 	addi	r3,fp,-18
 821dc04:	180d883a 	mov	r6,r3
 821dc08:	100b883a 	mov	r5,r2
 821dc0c:	e13ffa17 	ldw	r4,-24(fp)
 821dc10:	821a1300 	call	821a130 <OSSemPend>

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;
 821dc14:	e0bffc17 	ldw	r2,-16(fp)
 821dc18:	00c00044 	movi	r3,1
 821dc1c:	10c009c5 	stb	r3,39(r2)

  for ( ; ptr < end ; ptr++)
 821dc20:	00009906 	br	821de88 <altera_avalon_lcd_16207_write+0x2cc>
  {
    char c = *ptr;
 821dc24:	e0bffd17 	ldw	r2,-12(fp)
 821dc28:	10800003 	ldbu	r2,0(r2)
 821dc2c:	e0bff705 	stb	r2,-36(fp)

    if (sp->esccount >= 0)
 821dc30:	e0bffc17 	ldw	r2,-16(fp)
 821dc34:	10800903 	ldbu	r2,36(r2)
 821dc38:	10803fcc 	andi	r2,r2,255
 821dc3c:	1080201c 	xori	r2,r2,128
 821dc40:	10bfe004 	addi	r2,r2,-128
 821dc44:	10003716 	blt	r2,zero,821dd24 <altera_avalon_lcd_16207_write+0x168>
    {
      unsigned int esccount = sp->esccount;
 821dc48:	e0bffc17 	ldw	r2,-16(fp)
 821dc4c:	10800903 	ldbu	r2,36(r2)
 821dc50:	10803fcc 	andi	r2,r2,255
 821dc54:	1080201c 	xori	r2,r2,128
 821dc58:	10bfe004 	addi	r2,r2,-128
 821dc5c:	e0bff815 	stw	r2,-32(fp)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
 821dc60:	e0bff817 	ldw	r2,-32(fp)
 821dc64:	1000031e 	bne	r2,zero,821dc74 <altera_avalon_lcd_16207_write+0xb8>
 821dc68:	e0bff707 	ldb	r2,-36(fp)
 821dc6c:	108016d8 	cmpnei	r2,r2,91
 821dc70:	10000d1e 	bne	r2,zero,821dca8 <altera_avalon_lcd_16207_write+0xec>
 821dc74:	e0bff817 	ldw	r2,-32(fp)
 821dc78:	10001826 	beq	r2,zero,821dcdc <altera_avalon_lcd_16207_write+0x120>
          (esccount > 0 && !isdigit(c) && c != ';'))
 821dc7c:	d0e00017 	ldw	r3,-32768(gp)
 821dc80:	e0bff707 	ldb	r2,-36(fp)
 821dc84:	10800044 	addi	r2,r2,1
 821dc88:	1885883a 	add	r2,r3,r2
 821dc8c:	10800003 	ldbu	r2,0(r2)
 821dc90:	10803fcc 	andi	r2,r2,255
 821dc94:	1080010c 	andi	r2,r2,4
 821dc98:	1000101e 	bne	r2,zero,821dcdc <altera_avalon_lcd_16207_write+0x120>
 821dc9c:	e0bff707 	ldb	r2,-36(fp)
 821dca0:	10800ee0 	cmpeqi	r2,r2,59
 821dca4:	10000d1e 	bne	r2,zero,821dcdc <altera_avalon_lcd_16207_write+0x120>
      {
        sp->escape[esccount] = 0;
 821dca8:	e0fffc17 	ldw	r3,-16(fp)
 821dcac:	e0bff817 	ldw	r2,-32(fp)
 821dcb0:	1885883a 	add	r2,r3,r2
 821dcb4:	10800a04 	addi	r2,r2,40
 821dcb8:	10000005 	stb	zero,0(r2)

        lcd_handle_escape(sp, c);
 821dcbc:	e0bff707 	ldb	r2,-36(fp)
 821dcc0:	100b883a 	mov	r5,r2
 821dcc4:	e13ffc17 	ldw	r4,-16(fp)
 821dcc8:	821d9100 	call	821d910 <lcd_handle_escape>

        sp->esccount = -1;
 821dccc:	e0bffc17 	ldw	r2,-16(fp)
 821dcd0:	00ffffc4 	movi	r3,-1
 821dcd4:	10c00905 	stb	r3,36(r2)
 821dcd8:	00006806 	br	821de7c <altera_avalon_lcd_16207_write+0x2c0>
      }
      else if (sp->esccount < sizeof(sp->escape)-1)
 821dcdc:	e0bffc17 	ldw	r2,-16(fp)
 821dce0:	10800903 	ldbu	r2,36(r2)
 821dce4:	10803fcc 	andi	r2,r2,255
 821dce8:	108001e8 	cmpgeui	r2,r2,7
 821dcec:	1000631e 	bne	r2,zero,821de7c <altera_avalon_lcd_16207_write+0x2c0>
      {
        sp->escape[esccount] = c;
 821dcf0:	e0fffc17 	ldw	r3,-16(fp)
 821dcf4:	e0bff817 	ldw	r2,-32(fp)
 821dcf8:	1885883a 	add	r2,r3,r2
 821dcfc:	10800a04 	addi	r2,r2,40
 821dd00:	e0fff703 	ldbu	r3,-36(fp)
 821dd04:	10c00005 	stb	r3,0(r2)
        sp->esccount++;
 821dd08:	e0bffc17 	ldw	r2,-16(fp)
 821dd0c:	10800903 	ldbu	r2,36(r2)
 821dd10:	10800044 	addi	r2,r2,1
 821dd14:	1007883a 	mov	r3,r2
 821dd18:	e0bffc17 	ldw	r2,-16(fp)
 821dd1c:	10c00905 	stb	r3,36(r2)
 821dd20:	00005606 	br	821de7c <altera_avalon_lcd_16207_write+0x2c0>
      }
    }
    else if (c == 27) /* ESC */
 821dd24:	e0bff707 	ldb	r2,-36(fp)
 821dd28:	108006d8 	cmpnei	r2,r2,27
 821dd2c:	1000031e 	bne	r2,zero,821dd3c <altera_avalon_lcd_16207_write+0x180>
    {
      sp->esccount = 0;
 821dd30:	e0bffc17 	ldw	r2,-16(fp)
 821dd34:	10000905 	stb	zero,36(r2)
 821dd38:	00005006 	br	821de7c <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (c == '\r')
 821dd3c:	e0bff707 	ldb	r2,-36(fp)
 821dd40:	10800358 	cmpnei	r2,r2,13
 821dd44:	1000031e 	bne	r2,zero,821dd54 <altera_avalon_lcd_16207_write+0x198>
    {
      sp->x = 0;
 821dd48:	e0bffc17 	ldw	r2,-16(fp)
 821dd4c:	10000845 	stb	zero,33(r2)
 821dd50:	00004a06 	br	821de7c <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (c == '\n')
 821dd54:	e0bff707 	ldb	r2,-36(fp)
 821dd58:	10800298 	cmpnei	r2,r2,10
 821dd5c:	1000101e 	bne	r2,zero,821dda0 <altera_avalon_lcd_16207_write+0x1e4>
    {
      sp->x = 0;
 821dd60:	e0bffc17 	ldw	r2,-16(fp)
 821dd64:	10000845 	stb	zero,33(r2)
      sp->y++;
 821dd68:	e0bffc17 	ldw	r2,-16(fp)
 821dd6c:	10800883 	ldbu	r2,34(r2)
 821dd70:	10800044 	addi	r2,r2,1
 821dd74:	1007883a 	mov	r3,r2
 821dd78:	e0bffc17 	ldw	r2,-16(fp)
 821dd7c:	10c00885 	stb	r3,34(r2)

      /* Let the cursor sit at X=0, Y=HEIGHT without scrolling so the user
       * can print two lines of data without losing one.
       */
      if (sp->y > ALT_LCD_HEIGHT)
 821dd80:	e0bffc17 	ldw	r2,-16(fp)
 821dd84:	10800883 	ldbu	r2,34(r2)
 821dd88:	10803fcc 	andi	r2,r2,255
 821dd8c:	108000f0 	cmpltui	r2,r2,3
 821dd90:	10003a1e 	bne	r2,zero,821de7c <altera_avalon_lcd_16207_write+0x2c0>
        lcd_scroll_up(sp);
 821dd94:	e13ffc17 	ldw	r4,-16(fp)
 821dd98:	821d8440 	call	821d844 <lcd_scroll_up>
 821dd9c:	00003706 	br	821de7c <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (c == '\b')
 821dda0:	e0bff707 	ldb	r2,-36(fp)
 821dda4:	10800218 	cmpnei	r2,r2,8
 821dda8:	10000b1e 	bne	r2,zero,821ddd8 <altera_avalon_lcd_16207_write+0x21c>
    {
      if (sp->x > 0)
 821ddac:	e0bffc17 	ldw	r2,-16(fp)
 821ddb0:	10800843 	ldbu	r2,33(r2)
 821ddb4:	10803fcc 	andi	r2,r2,255
 821ddb8:	10003026 	beq	r2,zero,821de7c <altera_avalon_lcd_16207_write+0x2c0>
        sp->x--;
 821ddbc:	e0bffc17 	ldw	r2,-16(fp)
 821ddc0:	10800843 	ldbu	r2,33(r2)
 821ddc4:	10bfffc4 	addi	r2,r2,-1
 821ddc8:	1007883a 	mov	r3,r2
 821ddcc:	e0bffc17 	ldw	r2,-16(fp)
 821ddd0:	10c00845 	stb	r3,33(r2)
 821ddd4:	00002906 	br	821de7c <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (isprint(c))
 821ddd8:	d0e00017 	ldw	r3,-32768(gp)
 821dddc:	e0bff707 	ldb	r2,-36(fp)
 821dde0:	10800044 	addi	r2,r2,1
 821dde4:	1885883a 	add	r2,r3,r2
 821dde8:	10800003 	ldbu	r2,0(r2)
 821ddec:	10803fcc 	andi	r2,r2,255
 821ddf0:	1080201c 	xori	r2,r2,128
 821ddf4:	10bfe004 	addi	r2,r2,-128
 821ddf8:	108025cc 	andi	r2,r2,151
 821ddfc:	10001f26 	beq	r2,zero,821de7c <altera_avalon_lcd_16207_write+0x2c0>
    {
      /* If we didn't scroll on the last linefeed then we might need to do
       * it now. */
      if (sp->y >= ALT_LCD_HEIGHT)
 821de00:	e0bffc17 	ldw	r2,-16(fp)
 821de04:	10800883 	ldbu	r2,34(r2)
 821de08:	10803fcc 	andi	r2,r2,255
 821de0c:	108000b0 	cmpltui	r2,r2,2
 821de10:	1000021e 	bne	r2,zero,821de1c <altera_avalon_lcd_16207_write+0x260>
        lcd_scroll_up(sp);
 821de14:	e13ffc17 	ldw	r4,-16(fp)
 821de18:	821d8440 	call	821d844 <lcd_scroll_up>

      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 821de1c:	e0bffc17 	ldw	r2,-16(fp)
 821de20:	10800843 	ldbu	r2,33(r2)
 821de24:	10803fcc 	andi	r2,r2,255
 821de28:	10801428 	cmpgeui	r2,r2,80
 821de2c:	10000d1e 	bne	r2,zero,821de64 <altera_avalon_lcd_16207_write+0x2a8>
        sp->line[sp->y].data[sp->x] = c;
 821de30:	e0bffc17 	ldw	r2,-16(fp)
 821de34:	10800883 	ldbu	r2,34(r2)
 821de38:	10c03fcc 	andi	r3,r2,255
 821de3c:	e0bffc17 	ldw	r2,-16(fp)
 821de40:	10800843 	ldbu	r2,33(r2)
 821de44:	10803fcc 	andi	r2,r2,255
 821de48:	e13ffc17 	ldw	r4,-16(fp)
 821de4c:	18c018e4 	muli	r3,r3,99
 821de50:	20c7883a 	add	r3,r4,r3
 821de54:	1885883a 	add	r2,r3,r2
 821de58:	10801004 	addi	r2,r2,64
 821de5c:	e0fff703 	ldbu	r3,-36(fp)
 821de60:	10c00005 	stb	r3,0(r2)

      sp->x++;
 821de64:	e0bffc17 	ldw	r2,-16(fp)
 821de68:	10800843 	ldbu	r2,33(r2)
 821de6c:	10800044 	addi	r2,r2,1
 821de70:	1007883a 	mov	r3,r2
 821de74:	e0bffc17 	ldw	r2,-16(fp)
 821de78:	10c00845 	stb	r3,33(r2)

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;

  for ( ; ptr < end ; ptr++)
 821de7c:	e0bffd17 	ldw	r2,-12(fp)
 821de80:	10800044 	addi	r2,r2,1
 821de84:	e0bffd15 	stw	r2,-12(fp)
 821de88:	e0fffd17 	ldw	r3,-12(fp)
 821de8c:	e0bff617 	ldw	r2,-40(fp)
 821de90:	18bf6436 	bltu	r3,r2,821dc24 <altera_avalon_lcd_16207_write+0x68>
      sp->x++;
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
 821de94:	00800404 	movi	r2,16
 821de98:	e0bff415 	stw	r2,-48(fp)
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821de9c:	e03ff315 	stw	zero,-52(fp)
 821dea0:	00003706 	br	821df80 <altera_avalon_lcd_16207_write+0x3c4>
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 821dea4:	00801404 	movi	r2,80
 821dea8:	e0bff515 	stw	r2,-44(fp)
 821deac:	00001106 	br	821def4 <altera_avalon_lcd_16207_write+0x338>
      if (sp->line[y].data[width-1] != ' ')
 821deb0:	e0bff517 	ldw	r2,-44(fp)
 821deb4:	10bfffc4 	addi	r2,r2,-1
 821deb8:	e13ffc17 	ldw	r4,-16(fp)
 821debc:	e0fff317 	ldw	r3,-52(fp)
 821dec0:	18c018e4 	muli	r3,r3,99
 821dec4:	20c7883a 	add	r3,r4,r3
 821dec8:	1885883a 	add	r2,r3,r2
 821decc:	10801004 	addi	r2,r2,64
 821ded0:	10800003 	ldbu	r2,0(r2)
 821ded4:	10803fcc 	andi	r2,r2,255
 821ded8:	1080201c 	xori	r2,r2,128
 821dedc:	10bfe004 	addi	r2,r2,-128
 821dee0:	10800820 	cmpeqi	r2,r2,32
 821dee4:	10000626 	beq	r2,zero,821df00 <altera_avalon_lcd_16207_write+0x344>
  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 821dee8:	e0bff517 	ldw	r2,-44(fp)
 821deec:	10bfffc4 	addi	r2,r2,-1
 821def0:	e0bff515 	stw	r2,-44(fp)
 821def4:	e0bff517 	ldw	r2,-44(fp)
 821def8:	00bfed16 	blt	zero,r2,821deb0 <altera_avalon_lcd_16207_write+0x2f4>
 821defc:	00000106 	br	821df04 <altera_avalon_lcd_16207_write+0x348>
      if (sp->line[y].data[width-1] != ' ')
        break;
 821df00:	0001883a 	nop

    /* The minimum width is the size of the LCD panel.  If the real width
     * is long enough to require scrolling then add an extra space so the
     * end of the message doesn't run into the beginning of it.
     */
    if (width <= ALT_LCD_WIDTH)
 821df04:	e0bff517 	ldw	r2,-44(fp)
 821df08:	10800448 	cmpgei	r2,r2,17
 821df0c:	1000031e 	bne	r2,zero,821df1c <altera_avalon_lcd_16207_write+0x360>
      width = ALT_LCD_WIDTH;
 821df10:	00800404 	movi	r2,16
 821df14:	e0bff515 	stw	r2,-44(fp)
 821df18:	00000306 	br	821df28 <altera_avalon_lcd_16207_write+0x36c>
    else
      width++;
 821df1c:	e0bff517 	ldw	r2,-44(fp)
 821df20:	10800044 	addi	r2,r2,1
 821df24:	e0bff515 	stw	r2,-44(fp)

    sp->line[y].width = width;
 821df28:	e0bff517 	ldw	r2,-44(fp)
 821df2c:	1009883a 	mov	r4,r2
 821df30:	e0fffc17 	ldw	r3,-16(fp)
 821df34:	e0bff317 	ldw	r2,-52(fp)
 821df38:	108018e4 	muli	r2,r2,99
 821df3c:	1885883a 	add	r2,r3,r2
 821df40:	10802444 	addi	r2,r2,145
 821df44:	11000005 	stb	r4,0(r2)
    if (widthmax < width)
 821df48:	e0fff417 	ldw	r3,-48(fp)
 821df4c:	e0bff517 	ldw	r2,-44(fp)
 821df50:	1880020e 	bge	r3,r2,821df5c <altera_avalon_lcd_16207_write+0x3a0>
      widthmax = width;
 821df54:	e0bff517 	ldw	r2,-44(fp)
 821df58:	e0bff415 	stw	r2,-48(fp)
    sp->line[y].speed = 0; /* By default lines don't scroll */
 821df5c:	e0fffc17 	ldw	r3,-16(fp)
 821df60:	e0bff317 	ldw	r2,-52(fp)
 821df64:	108018e4 	muli	r2,r2,99
 821df68:	1885883a 	add	r2,r3,r2
 821df6c:	10802484 	addi	r2,r2,146
 821df70:	10000005 	stb	zero,0(r2)
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821df74:	e0bff317 	ldw	r2,-52(fp)
 821df78:	10800044 	addi	r2,r2,1
 821df7c:	e0bff315 	stw	r2,-52(fp)
 821df80:	e0bff317 	ldw	r2,-52(fp)
 821df84:	10800090 	cmplti	r2,r2,2
 821df88:	103fc61e 	bne	r2,zero,821dea4 <altera_avalon_lcd_16207_write+0x2e8>
    if (widthmax < width)
      widthmax = width;
    sp->line[y].speed = 0; /* By default lines don't scroll */
  }

  if (widthmax <= ALT_LCD_WIDTH)
 821df8c:	e0bff417 	ldw	r2,-48(fp)
 821df90:	10800448 	cmpgei	r2,r2,17
 821df94:	1000031e 	bne	r2,zero,821dfa4 <altera_avalon_lcd_16207_write+0x3e8>
    sp->scrollmax = 0;
 821df98:	e0bffc17 	ldw	r2,-16(fp)
 821df9c:	10000985 	stb	zero,38(r2)
 821dfa0:	00002e06 	br	821e05c <altera_avalon_lcd_16207_write+0x4a0>
  else
  {
    widthmax *= 2;
 821dfa4:	e0bff417 	ldw	r2,-48(fp)
 821dfa8:	1085883a 	add	r2,r2,r2
 821dfac:	e0bff415 	stw	r2,-48(fp)
    sp->scrollmax = widthmax;
 821dfb0:	e0bff417 	ldw	r2,-48(fp)
 821dfb4:	1007883a 	mov	r3,r2
 821dfb8:	e0bffc17 	ldw	r2,-16(fp)
 821dfbc:	10c00985 	stb	r3,38(r2)

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821dfc0:	e03ff315 	stw	zero,-52(fp)
 821dfc4:	00002206 	br	821e050 <altera_avalon_lcd_16207_write+0x494>
      if (sp->line[y].width > ALT_LCD_WIDTH)
 821dfc8:	e0fffc17 	ldw	r3,-16(fp)
 821dfcc:	e0bff317 	ldw	r2,-52(fp)
 821dfd0:	108018e4 	muli	r2,r2,99
 821dfd4:	1885883a 	add	r2,r3,r2
 821dfd8:	10802444 	addi	r2,r2,145
 821dfdc:	10800003 	ldbu	r2,0(r2)
 821dfe0:	10803fcc 	andi	r2,r2,255
 821dfe4:	1080201c 	xori	r2,r2,128
 821dfe8:	10bfe004 	addi	r2,r2,-128
 821dfec:	10800450 	cmplti	r2,r2,17
 821dff0:	1000141e 	bne	r2,zero,821e044 <altera_avalon_lcd_16207_write+0x488>
         */
#if 1
        /* This option makes all the lines scroll round at different speeds
         * which are chosen so that all the scrolls finish at the same time.
         */
        sp->line[y].speed = 256 * sp->line[y].width / widthmax;
 821dff4:	e0fffc17 	ldw	r3,-16(fp)
 821dff8:	e0bff317 	ldw	r2,-52(fp)
 821dffc:	108018e4 	muli	r2,r2,99
 821e000:	1885883a 	add	r2,r3,r2
 821e004:	10802444 	addi	r2,r2,145
 821e008:	10800003 	ldbu	r2,0(r2)
 821e00c:	10803fcc 	andi	r2,r2,255
 821e010:	1080201c 	xori	r2,r2,128
 821e014:	10bfe004 	addi	r2,r2,-128
 821e018:	1004923a 	slli	r2,r2,8
 821e01c:	e17ff417 	ldw	r5,-48(fp)
 821e020:	1009883a 	mov	r4,r2
 821e024:	8202b740 	call	8202b74 <__divsi3>
 821e028:	1009883a 	mov	r4,r2
 821e02c:	e0fffc17 	ldw	r3,-16(fp)
 821e030:	e0bff317 	ldw	r2,-52(fp)
 821e034:	108018e4 	muli	r2,r2,99
 821e038:	1885883a 	add	r2,r3,r2
 821e03c:	10802484 	addi	r2,r2,146
 821e040:	11000005 	stb	r4,0(r2)
  {
    widthmax *= 2;
    sp->scrollmax = widthmax;

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821e044:	e0bff317 	ldw	r2,-52(fp)
 821e048:	10800044 	addi	r2,r2,1
 821e04c:	e0bff315 	stw	r2,-52(fp)
 821e050:	e0bff317 	ldw	r2,-52(fp)
 821e054:	10800090 	cmplti	r2,r2,2
 821e058:	103fdb1e 	bne	r2,zero,821dfc8 <altera_avalon_lcd_16207_write+0x40c>
   * (because active was set when the timer interrupt occurred).  If there
   * has been a missed repaint then paint again.  And again.  etc.
   */
  for ( ; ; )
  {
    int old_scrollpos = sp->scrollpos;
 821e05c:	e0bffc17 	ldw	r2,-16(fp)
 821e060:	10800943 	ldbu	r2,37(r2)
 821e064:	10803fcc 	andi	r2,r2,255
 821e068:	e0bff915 	stw	r2,-28(fp)

    lcd_repaint_screen(sp);
 821e06c:	e13ffc17 	ldw	r4,-16(fp)
 821e070:	821d6580 	call	821d658 <lcd_repaint_screen>

    /* Let the timer routines repaint the display again */
    sp->active = 0;
 821e074:	e0bffc17 	ldw	r2,-16(fp)
 821e078:	100009c5 	stb	zero,39(r2)

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
 821e07c:	e0bffc17 	ldw	r2,-16(fp)
 821e080:	10800943 	ldbu	r2,37(r2)
 821e084:	10c03fcc 	andi	r3,r2,255
 821e088:	e0bff917 	ldw	r2,-28(fp)
 821e08c:	18800426 	beq	r3,r2,821e0a0 <altera_avalon_lcd_16207_write+0x4e4>
      break;

    /* We need to repaint again since the display scrolled while we were
     * painting last time */
    sp->active = 1;
 821e090:	e0bffc17 	ldw	r2,-16(fp)
 821e094:	00c00044 	movi	r3,1
 821e098:	10c009c5 	stb	r3,39(r2)
  }
 821e09c:	003fef06 	br	821e05c <altera_avalon_lcd_16207_write+0x4a0>
    sp->active = 0;

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
      break;
 821e0a0:	0001883a 	nop

  /* Now that access to the display is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
 821e0a4:	e0bffc17 	ldw	r2,-16(fp)
 821e0a8:	10803e17 	ldw	r2,248(r2)
 821e0ac:	1009883a 	mov	r4,r2
 821e0b0:	821a4a80 	call	821a4a8 <OSSemPost>

  return len;
 821e0b4:	e0bffe17 	ldw	r2,-8(fp)
}
 821e0b8:	e037883a 	mov	sp,fp
 821e0bc:	dfc00117 	ldw	ra,4(sp)
 821e0c0:	df000017 	ldw	fp,0(sp)
 821e0c4:	dec00204 	addi	sp,sp,8
 821e0c8:	f800283a 	ret

0821e0cc <alt_lcd_16207_timeout>:
/*
 * Timeout routine is called every second
 */

static alt_u32 alt_lcd_16207_timeout(void* context) 
{
 821e0cc:	defffc04 	addi	sp,sp,-16
 821e0d0:	dfc00315 	stw	ra,12(sp)
 821e0d4:	df000215 	stw	fp,8(sp)
 821e0d8:	df000204 	addi	fp,sp,8
 821e0dc:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_lcd_16207_state* sp = (altera_avalon_lcd_16207_state*)context;
 821e0e0:	e0bfff17 	ldw	r2,-4(fp)
 821e0e4:	e0bffe15 	stw	r2,-8(fp)

  /* Update the scrolling position */
  if (sp->scrollpos + 1 >= sp->scrollmax)
 821e0e8:	e0bffe17 	ldw	r2,-8(fp)
 821e0ec:	10800943 	ldbu	r2,37(r2)
 821e0f0:	10803fcc 	andi	r2,r2,255
 821e0f4:	10c00044 	addi	r3,r2,1
 821e0f8:	e0bffe17 	ldw	r2,-8(fp)
 821e0fc:	10800983 	ldbu	r2,38(r2)
 821e100:	10803fcc 	andi	r2,r2,255
 821e104:	18800316 	blt	r3,r2,821e114 <alt_lcd_16207_timeout+0x48>
    sp->scrollpos = 0;
 821e108:	e0bffe17 	ldw	r2,-8(fp)
 821e10c:	10000945 	stb	zero,37(r2)
 821e110:	00000606 	br	821e12c <alt_lcd_16207_timeout+0x60>
  else
    sp->scrollpos = sp->scrollpos + 1;
 821e114:	e0bffe17 	ldw	r2,-8(fp)
 821e118:	10800943 	ldbu	r2,37(r2)
 821e11c:	10800044 	addi	r2,r2,1
 821e120:	1007883a 	mov	r3,r2
 821e124:	e0bffe17 	ldw	r2,-8(fp)
 821e128:	10c00945 	stb	r3,37(r2)

  /* Repaint the panel unless the foreground will do it again soon */
  if (sp->scrollmax > 0 && !sp->active)
 821e12c:	e0bffe17 	ldw	r2,-8(fp)
 821e130:	10800983 	ldbu	r2,38(r2)
 821e134:	10803fcc 	andi	r2,r2,255
 821e138:	10000826 	beq	r2,zero,821e15c <alt_lcd_16207_timeout+0x90>
 821e13c:	e0bffe17 	ldw	r2,-8(fp)
 821e140:	108009c3 	ldbu	r2,39(r2)
 821e144:	10803fcc 	andi	r2,r2,255
 821e148:	1080201c 	xori	r2,r2,128
 821e14c:	10bfe004 	addi	r2,r2,-128
 821e150:	1000021e 	bne	r2,zero,821e15c <alt_lcd_16207_timeout+0x90>
    lcd_repaint_screen(sp);
 821e154:	e13ffe17 	ldw	r4,-8(fp)
 821e158:	821d6580 	call	821d658 <lcd_repaint_screen>

  return sp->period;
 821e15c:	e0bffe17 	ldw	r2,-8(fp)
 821e160:	10800717 	ldw	r2,28(r2)
}
 821e164:	e037883a 	mov	sp,fp
 821e168:	dfc00117 	ldw	ra,4(sp)
 821e16c:	df000017 	ldw	fp,0(sp)
 821e170:	dec00204 	addi	sp,sp,8
 821e174:	f800283a 	ret

0821e178 <altera_avalon_lcd_16207_init>:

/*
 * Called at boot time to initialise the LCD driver
 */
void altera_avalon_lcd_16207_init(altera_avalon_lcd_16207_state* sp)
{
 821e178:	defff604 	addi	sp,sp,-40
 821e17c:	dfc00915 	stw	ra,36(sp)
 821e180:	df000815 	stw	fp,32(sp)
 821e184:	dc400715 	stw	r17,28(sp)
 821e188:	dc000615 	stw	r16,24(sp)
 821e18c:	df000804 	addi	fp,sp,32
 821e190:	e13ffb15 	stw	r4,-20(fp)
  unsigned int base = sp->base;
 821e194:	e0bffb17 	ldw	r2,-20(fp)
 821e198:	10800017 	ldw	r2,0(r2)
 821e19c:	e0bff815 	stw	r2,-32(fp)

  /* Mark the device as functional */
  sp->broken = 0;
 821e1a0:	e0bffb17 	ldw	r2,-20(fp)
 821e1a4:	10000805 	stb	zero,32(r2)

  ALT_SEM_CREATE (&sp->write_lock, 1);
 821e1a8:	e0bffb17 	ldw	r2,-20(fp)
 821e1ac:	10803e04 	addi	r2,r2,248
 821e1b0:	e0bff915 	stw	r2,-28(fp)
 821e1b4:	00800044 	movi	r2,1
 821e1b8:	e0bffa0d 	sth	r2,-24(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 821e1bc:	e0bffa0b 	ldhu	r2,-24(fp)
 821e1c0:	1009883a 	mov	r4,r2
 821e1c4:	8219e180 	call	8219e18 <OSSemCreate>
 821e1c8:	1007883a 	mov	r3,r2
 821e1cc:	e0bff917 	ldw	r2,-28(fp)
 821e1d0:	10c00015 	stw	r3,0(r2)
   * the BUSY bit in the status register doesn't work until the display
   * has been reset three times.
   */

  /* Wait for 15 ms then reset */
  usleep(15000);
 821e1d4:	010ea604 	movi	r4,15000
 821e1d8:	823ca800 	call	823ca80 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 821e1dc:	e0bff817 	ldw	r2,-32(fp)
 821e1e0:	00c00c04 	movi	r3,48
 821e1e4:	10c00035 	stwio	r3,0(r2)

  /* Wait for another 4.1ms and reset again */
  usleep(4100);  
 821e1e8:	01040104 	movi	r4,4100
 821e1ec:	823ca800 	call	823ca80 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 821e1f0:	e0bff817 	ldw	r2,-32(fp)
 821e1f4:	00c00c04 	movi	r3,48
 821e1f8:	10c00035 	stwio	r3,0(r2)

  /* Wait a further 1 ms and reset a third time */
  usleep(1000);
 821e1fc:	0100fa04 	movi	r4,1000
 821e200:	823ca800 	call	823ca80 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 821e204:	e0bff817 	ldw	r2,-32(fp)
 821e208:	00c00c04 	movi	r3,48
 821e20c:	10c00035 	stwio	r3,0(r2)

  /* Setup interface parameters: 8 bit bus, 2 rows, 5x7 font */
  lcd_write_command(sp, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT | LCD_CMD_TWO_LINE);
 821e210:	01400e04 	movi	r5,56
 821e214:	e13ffb17 	ldw	r4,-20(fp)
 821e218:	821d3f80 	call	821d3f8 <lcd_write_command>
  
  /* Turn display off */
  lcd_write_command(sp, LCD_CMD_ONOFF);
 821e21c:	01400204 	movi	r5,8
 821e220:	e13ffb17 	ldw	r4,-20(fp)
 821e224:	821d3f80 	call	821d3f8 <lcd_write_command>

  /* Clear display */
  lcd_clear_screen(sp);
 821e228:	e13ffb17 	ldw	r4,-20(fp)
 821e22c:	821d5880 	call	821d588 <lcd_clear_screen>
  
  /* Set mode: increment after writing, don't shift display */
  lcd_write_command(sp, LCD_CMD_MODES | LCD_CMD_MODE_INC);
 821e230:	01400184 	movi	r5,6
 821e234:	e13ffb17 	ldw	r4,-20(fp)
 821e238:	821d3f80 	call	821d3f8 <lcd_write_command>

  /* Turn display on */
  lcd_write_command(sp, LCD_CMD_ONOFF | LCD_CMD_ENABLE_DISP);
 821e23c:	01400304 	movi	r5,12
 821e240:	e13ffb17 	ldw	r4,-20(fp)
 821e244:	821d3f80 	call	821d3f8 <lcd_write_command>

  sp->esccount = -1;
 821e248:	e0bffb17 	ldw	r2,-20(fp)
 821e24c:	00ffffc4 	movi	r3,-1
 821e250:	10c00905 	stb	r3,36(r2)
  memset(sp->escape, 0, sizeof(sp->escape));
 821e254:	e0bffb17 	ldw	r2,-20(fp)
 821e258:	10800a04 	addi	r2,r2,40
 821e25c:	01800204 	movi	r6,8
 821e260:	000b883a 	mov	r5,zero
 821e264:	1009883a 	mov	r4,r2
 821e268:	82032100 	call	8203210 <memset>

  sp->scrollpos = 0;
 821e26c:	e0bffb17 	ldw	r2,-20(fp)
 821e270:	10000945 	stb	zero,37(r2)
  sp->scrollmax = 0;
 821e274:	e0bffb17 	ldw	r2,-20(fp)
 821e278:	10000985 	stb	zero,38(r2)
  sp->active = 0;
 821e27c:	e0bffb17 	ldw	r2,-20(fp)
 821e280:	100009c5 	stb	zero,39(r2)
 821e284:	d0e0b817 	ldw	r3,-32032(gp)

  sp->period = alt_ticks_per_second() / 10; /* Call every 100ms */
 821e288:	00b33374 	movhi	r2,52429
 821e28c:	10b33344 	addi	r2,r2,-13107
 821e290:	1888383a 	mulxuu	r4,r3,r2
 821e294:	1885383a 	mul	r2,r3,r2
 821e298:	1021883a 	mov	r16,r2
 821e29c:	2023883a 	mov	r17,r4
 821e2a0:	8804d0fa 	srli	r2,r17,3
 821e2a4:	1007883a 	mov	r3,r2
 821e2a8:	e0bffb17 	ldw	r2,-20(fp)
 821e2ac:	10c00715 	stw	r3,28(r2)

  alt_alarm_start(&sp->alarm, sp->period, &alt_lcd_16207_timeout, sp);
 821e2b0:	e0bffb17 	ldw	r2,-20(fp)
 821e2b4:	10c00104 	addi	r3,r2,4
 821e2b8:	e0bffb17 	ldw	r2,-20(fp)
 821e2bc:	10800717 	ldw	r2,28(r2)
 821e2c0:	e1fffb17 	ldw	r7,-20(fp)
 821e2c4:	018208b4 	movhi	r6,2082
 821e2c8:	31b83304 	addi	r6,r6,-7988
 821e2cc:	100b883a 	mov	r5,r2
 821e2d0:	1809883a 	mov	r4,r3
 821e2d4:	823bb300 	call	823bb30 <alt_alarm_start>
}
 821e2d8:	0001883a 	nop
 821e2dc:	e6fffe04 	addi	sp,fp,-8
 821e2e0:	dfc00317 	ldw	ra,12(sp)
 821e2e4:	df000217 	ldw	fp,8(sp)
 821e2e8:	dc400117 	ldw	r17,4(sp)
 821e2ec:	dc000017 	ldw	r16,0(sp)
 821e2f0:	dec00404 	addi	sp,sp,16
 821e2f4:	f800283a 	ret

0821e2f8 <altera_avalon_lcd_16207_write_fd>:
extern int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp,
  const char* ptr, int count, int flags);

int 
altera_avalon_lcd_16207_write_fd(alt_fd* fd, const char* buffer, int space)
{
 821e2f8:	defffa04 	addi	sp,sp,-24
 821e2fc:	dfc00515 	stw	ra,20(sp)
 821e300:	df000415 	stw	fp,16(sp)
 821e304:	df000404 	addi	fp,sp,16
 821e308:	e13ffd15 	stw	r4,-12(fp)
 821e30c:	e17ffe15 	stw	r5,-8(fp)
 821e310:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_lcd_16207_dev* dev = (altera_avalon_lcd_16207_dev*) fd->dev; 
 821e314:	e0bffd17 	ldw	r2,-12(fp)
 821e318:	10800017 	ldw	r2,0(r2)
 821e31c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_lcd_16207_write(&dev->state, buffer, space,
 821e320:	e0bffc17 	ldw	r2,-16(fp)
 821e324:	10c00a04 	addi	r3,r2,40
 821e328:	e0bffd17 	ldw	r2,-12(fp)
 821e32c:	10800217 	ldw	r2,8(r2)
 821e330:	100f883a 	mov	r7,r2
 821e334:	e1bfff17 	ldw	r6,-4(fp)
 821e338:	e17ffe17 	ldw	r5,-8(fp)
 821e33c:	1809883a 	mov	r4,r3
 821e340:	821dbbc0 	call	821dbbc <altera_avalon_lcd_16207_write>
      fd->fd_flags);
}
 821e344:	e037883a 	mov	sp,fp
 821e348:	dfc00117 	ldw	ra,4(sp)
 821e34c:	df000017 	ldw	fp,0(sp)
 821e350:	dec00204 	addi	sp,sp,8
 821e354:	f800283a 	ret

0821e358 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 821e358:	defffe04 	addi	sp,sp,-8
 821e35c:	dfc00115 	stw	ra,4(sp)
 821e360:	df000015 	stw	fp,0(sp)
 821e364:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 821e368:	d0a04717 	ldw	r2,-32484(gp)
 821e36c:	10000326 	beq	r2,zero,821e37c <alt_get_errno+0x24>
 821e370:	d0a04717 	ldw	r2,-32484(gp)
 821e374:	103ee83a 	callr	r2
 821e378:	00000106 	br	821e380 <alt_get_errno+0x28>
 821e37c:	d0a06304 	addi	r2,gp,-32372
}
 821e380:	e037883a 	mov	sp,fp
 821e384:	dfc00117 	ldw	ra,4(sp)
 821e388:	df000017 	ldw	fp,0(sp)
 821e38c:	dec00204 	addi	sp,sp,8
 821e390:	f800283a 	ret

0821e394 <alt_avalon_sgdma_do_async_transfer>:
 * - 0 for success, or various errors defined in <errno.h>
 */
int alt_avalon_sgdma_do_async_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 821e394:	defffc04 	addi	sp,sp,-16
 821e398:	df000315 	stw	fp,12(sp)
 821e39c:	df000304 	addi	fp,sp,12
 821e3a0:	e13ffe15 	stw	r4,-8(fp)
 821e3a4:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 821e3a8:	e0bffe17 	ldw	r2,-8(fp)
 821e3ac:	10800317 	ldw	r2,12(r2)
 821e3b0:	10800037 	ldwio	r2,0(r2)
 821e3b4:	1080040c 	andi	r2,r2,16
 821e3b8:	10000226 	beq	r2,zero,821e3c4 <alt_avalon_sgdma_do_async_transfer+0x30>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
 821e3bc:	00bffc04 	movi	r2,-16
 821e3c0:	00003906 	br	821e4a8 <alt_avalon_sgdma_do_async_transfer+0x114>
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821e3c4:	e0bffe17 	ldw	r2,-8(fp)
 821e3c8:	10800317 	ldw	r2,12(r2)
 821e3cc:	10800404 	addi	r2,r2,16
 821e3d0:	e0fffe17 	ldw	r3,-8(fp)
 821e3d4:	18c00317 	ldw	r3,12(r3)
 821e3d8:	18c00404 	addi	r3,r3,16
 821e3dc:	19000037 	ldwio	r4,0(r3)
 821e3e0:	00fff7c4 	movi	r3,-33
 821e3e4:	20c6703a 	and	r3,r4,r3
 821e3e8:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 821e3ec:	e0bffe17 	ldw	r2,-8(fp)
 821e3f0:	10800317 	ldw	r2,12(r2)
 821e3f4:	00c03fc4 	movi	r3,255
 821e3f8:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 821e3fc:	e0bffe17 	ldw	r2,-8(fp)
 821e400:	10800317 	ldw	r2,12(r2)
 821e404:	10800804 	addi	r2,r2,32
 821e408:	e0ffff17 	ldw	r3,-4(fp)
 821e40c:	10c00035 	stwio	r3,0(r2)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
 821e410:	e0bffe17 	ldw	r2,-8(fp)
 821e414:	10800917 	ldw	r2,36(r2)
 821e418:	10001126 	beq	r2,zero,821e460 <alt_avalon_sgdma_do_async_transfer+0xcc>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e41c:	e0bffe17 	ldw	r2,-8(fp)
 821e420:	10800317 	ldw	r2,12(r2)
 821e424:	10800404 	addi	r2,r2,16
 821e428:	10800037 	ldwio	r2,0(r2)
 821e42c:	e0bffd15 	stw	r2,-12(fp)

    control |= (dev->chain_control                          |
 821e430:	e0bffe17 	ldw	r2,-8(fp)
 821e434:	10c00b17 	ldw	r3,44(r2)
 821e438:	e0bffd17 	ldw	r2,-12(fp)
 821e43c:	1884b03a 	or	r2,r3,r2
 821e440:	10801814 	ori	r2,r2,96
 821e444:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e448:	e0bffe17 	ldw	r2,-8(fp)
 821e44c:	10800317 	ldw	r2,12(r2)
 821e450:	10800404 	addi	r2,r2,16
 821e454:	e0fffd17 	ldw	r3,-12(fp)
 821e458:	10c00035 	stwio	r3,0(r2)
 821e45c:	00001106 	br	821e4a4 <alt_avalon_sgdma_do_async_transfer+0x110>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e460:	e0bffe17 	ldw	r2,-8(fp)
 821e464:	10800317 	ldw	r2,12(r2)
 821e468:	10800404 	addi	r2,r2,16
 821e46c:	10800037 	ldwio	r2,0(r2)
 821e470:	e0bffd15 	stw	r2,-12(fp)

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
 821e474:	e0bffd17 	ldw	r2,-12(fp)
 821e478:	10801814 	ori	r2,r2,96
 821e47c:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;
 821e480:	e0fffd17 	ldw	r3,-12(fp)
 821e484:	00bffbc4 	movi	r2,-17
 821e488:	1884703a 	and	r2,r3,r2
 821e48c:	e0bffd15 	stw	r2,-12(fp)

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e490:	e0bffe17 	ldw	r2,-8(fp)
 821e494:	10800317 	ldw	r2,12(r2)
 821e498:	10800404 	addi	r2,r2,16
 821e49c:	e0fffd17 	ldw	r3,-12(fp)
 821e4a0:	10c00035 	stwio	r3,0(r2)

  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
 821e4a4:	0005883a 	mov	r2,zero
}
 821e4a8:	e037883a 	mov	sp,fp
 821e4ac:	df000017 	ldw	fp,0(sp)
 821e4b0:	dec00104 	addi	sp,sp,4
 821e4b4:	f800283a 	ret

0821e4b8 <alt_avalon_sgdma_do_sync_transfer>:
 * - status: Content of SGDMA status register.
 */
alt_u8 alt_avalon_sgdma_do_sync_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 821e4b8:	defffc04 	addi	sp,sp,-16
 821e4bc:	df000315 	stw	fp,12(sp)
 821e4c0:	df000304 	addi	fp,sp,12
 821e4c4:	e13ffe15 	stw	r4,-8(fp)
 821e4c8:	e17fff15 	stw	r5,-4(fp)
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 821e4cc:	0001883a 	nop
 821e4d0:	e0bffe17 	ldw	r2,-8(fp)
 821e4d4:	10800317 	ldw	r2,12(r2)
 821e4d8:	10800037 	ldwio	r2,0(r2)
 821e4dc:	1080040c 	andi	r2,r2,16
 821e4e0:	103ffb1e 	bne	r2,zero,821e4d0 <alt_avalon_sgdma_do_sync_transfer+0x18>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821e4e4:	e0bffe17 	ldw	r2,-8(fp)
 821e4e8:	10800317 	ldw	r2,12(r2)
 821e4ec:	10800404 	addi	r2,r2,16
 821e4f0:	e0fffe17 	ldw	r3,-8(fp)
 821e4f4:	18c00317 	ldw	r3,12(r3)
 821e4f8:	18c00404 	addi	r3,r3,16
 821e4fc:	19000037 	ldwio	r4,0(r3)
 821e500:	00fff7c4 	movi	r3,-33
 821e504:	20c6703a 	and	r3,r4,r3
 821e508:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 821e50c:	e0bffe17 	ldw	r2,-8(fp)
 821e510:	10800317 	ldw	r2,12(r2)
 821e514:	00c03fc4 	movi	r3,255
 821e518:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 821e51c:	e0bffe17 	ldw	r2,-8(fp)
 821e520:	10800317 	ldw	r2,12(r2)
 821e524:	10800804 	addi	r2,r2,32
 821e528:	e0ffff17 	ldw	r3,-4(fp)
 821e52c:	10c00035 	stwio	r3,0(r2)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821e530:	e0bffe17 	ldw	r2,-8(fp)
 821e534:	10800317 	ldw	r2,12(r2)
 821e538:	10800404 	addi	r2,r2,16
 821e53c:	e0fffe17 	ldw	r3,-8(fp)
 821e540:	18c00317 	ldw	r3,12(r3)
 821e544:	18c00404 	addi	r3,r3,16
 821e548:	18c00037 	ldwio	r3,0(r3)
 821e54c:	18c01814 	ori	r3,r3,96
 821e550:	10c00035 	stwio	r3,0(r2)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 821e554:	0001883a 	nop
 821e558:	e0bffe17 	ldw	r2,-8(fp)
 821e55c:	10800317 	ldw	r2,12(r2)
 821e560:	10800037 	ldwio	r2,0(r2)
 821e564:	1080040c 	andi	r2,r2,16
 821e568:	103ffb1e 	bne	r2,zero,821e558 <alt_avalon_sgdma_do_sync_transfer+0xa0>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 821e56c:	e0bffe17 	ldw	r2,-8(fp)
 821e570:	10800317 	ldw	r2,12(r2)
 821e574:	10800404 	addi	r2,r2,16
 821e578:	e0fffe17 	ldw	r3,-8(fp)
 821e57c:	18c00317 	ldw	r3,12(r3)
 821e580:	18c00404 	addi	r3,r3,16
 821e584:	19000037 	ldwio	r4,0(r3)
 821e588:	00fff7c4 	movi	r3,-33
 821e58c:	20c6703a 	and	r3,r4,r3
 821e590:	10c00035 	stwio	r3,0(r2)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
 821e594:	e0bffe17 	ldw	r2,-8(fp)
 821e598:	10800317 	ldw	r2,12(r2)
 821e59c:	10800037 	ldwio	r2,0(r2)
 821e5a0:	e0bffd05 	stb	r2,-12(fp)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 821e5a4:	e0bffe17 	ldw	r2,-8(fp)
 821e5a8:	10800317 	ldw	r2,12(r2)
 821e5ac:	00c03fc4 	movi	r3,255
 821e5b0:	10c00035 	stwio	r3,0(r2)

  return status;
 821e5b4:	e0bffd03 	ldbu	r2,-12(fp)
}
 821e5b8:	e037883a 	mov	sp,fp
 821e5bc:	df000017 	ldw	fp,0(sp)
 821e5c0:	dec00104 	addi	sp,sp,4
 821e5c4:	f800283a 	ret

0821e5c8 <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
 821e5c8:	defff404 	addi	sp,sp,-48
 821e5cc:	dfc00b15 	stw	ra,44(sp)
 821e5d0:	df000a15 	stw	fp,40(sp)
 821e5d4:	df000a04 	addi	fp,sp,40
 821e5d8:	e13ffb15 	stw	r4,-20(fp)
 821e5dc:	e17ffc15 	stw	r5,-16(fp)
 821e5e0:	e1bffd15 	stw	r6,-12(fp)
 821e5e4:	e1fffe15 	stw	r7,-8(fp)
 821e5e8:	e0800217 	ldw	r2,8(fp)
 821e5ec:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
 821e5f0:	e0bfff0b 	ldhu	r2,-4(fp)
 821e5f4:	d8000415 	stw	zero,16(sp)
 821e5f8:	d8000315 	stw	zero,12(sp)
 821e5fc:	e0c00417 	ldw	r3,16(fp)
 821e600:	d8c00215 	stw	r3,8(sp)
 821e604:	e0c00317 	ldw	r3,12(fp)
 821e608:	d8c00115 	stw	r3,4(sp)
 821e60c:	d8800015 	stw	r2,0(sp)
 821e610:	e1fffe17 	ldw	r7,-8(fp)
 821e614:	e1bffd17 	ldw	r6,-12(fp)
 821e618:	e17ffc17 	ldw	r5,-16(fp)
 821e61c:	e13ffb17 	ldw	r4,-20(fp)
 821e620:	821e63c0 	call	821e63c <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
 821e624:	0001883a 	nop
 821e628:	e037883a 	mov	sp,fp
 821e62c:	dfc00117 	ldw	ra,4(sp)
 821e630:	df000017 	ldw	fp,0(sp)
 821e634:	dec00204 	addi	sp,sp,8
 821e638:	f800283a 	ret

0821e63c <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
 821e63c:	defff204 	addi	sp,sp,-56
 821e640:	dfc00d15 	stw	ra,52(sp)
 821e644:	df000c15 	stw	fp,48(sp)
 821e648:	df000c04 	addi	fp,sp,48
 821e64c:	e13ffb15 	stw	r4,-20(fp)
 821e650:	e17ffc15 	stw	r5,-16(fp)
 821e654:	e1bffd15 	stw	r6,-12(fp)
 821e658:	e1fffe15 	stw	r7,-8(fp)
 821e65c:	e0800217 	ldw	r2,8(fp)
 821e660:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 821e664:	e0bfff0b 	ldhu	r2,-4(fp)
 821e668:	d8000615 	stw	zero,24(sp)
 821e66c:	e0c00617 	ldw	r3,24(fp)
 821e670:	d8c00515 	stw	r3,20(sp)
 821e674:	e0c00517 	ldw	r3,20(fp)
 821e678:	d8c00415 	stw	r3,16(sp)
 821e67c:	e0c00417 	ldw	r3,16(fp)
 821e680:	d8c00315 	stw	r3,12(sp)
 821e684:	e0c00317 	ldw	r3,12(fp)
 821e688:	d8c00215 	stw	r3,8(sp)
 821e68c:	d8000115 	stw	zero,4(sp)
 821e690:	d8800015 	stw	r2,0(sp)
 821e694:	e1fffe17 	ldw	r7,-8(fp)
 821e698:	e1bffd17 	ldw	r6,-12(fp)
 821e69c:	e17ffc17 	ldw	r5,-16(fp)
 821e6a0:	e13ffb17 	ldw	r4,-20(fp)
 821e6a4:	821ebd00 	call	821ebd0 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
 821e6a8:	0001883a 	nop
 821e6ac:	e037883a 	mov	sp,fp
 821e6b0:	dfc00117 	ldw	ra,4(sp)
 821e6b4:	df000017 	ldw	fp,0(sp)
 821e6b8:	dec00204 	addi	sp,sp,8
 821e6bc:	f800283a 	ret

0821e6c0 <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
 821e6c0:	defff804 	addi	sp,sp,-32
 821e6c4:	dfc00715 	stw	ra,28(sp)
 821e6c8:	df000615 	stw	fp,24(sp)
 821e6cc:	df000604 	addi	fp,sp,24
 821e6d0:	e13ffc15 	stw	r4,-16(fp)
 821e6d4:	e17ffd15 	stw	r5,-12(fp)
 821e6d8:	e1bffe15 	stw	r6,-8(fp)
 821e6dc:	3805883a 	mov	r2,r7
 821e6e0:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
 821e6e4:	e0ffff0b 	ldhu	r3,-4(fp)
 821e6e8:	d8000115 	stw	zero,4(sp)
 821e6ec:	e0800217 	ldw	r2,8(fp)
 821e6f0:	d8800015 	stw	r2,0(sp)
 821e6f4:	180f883a 	mov	r7,r3
 821e6f8:	e1bffe17 	ldw	r6,-8(fp)
 821e6fc:	e17ffd17 	ldw	r5,-12(fp)
 821e700:	e13ffc17 	ldw	r4,-16(fp)
 821e704:	821e7200 	call	821e720 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
 821e708:	0001883a 	nop
 821e70c:	e037883a 	mov	sp,fp
 821e710:	dfc00117 	ldw	ra,4(sp)
 821e714:	df000017 	ldw	fp,0(sp)
 821e718:	dec00204 	addi	sp,sp,8
 821e71c:	f800283a 	ret

0821e720 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
 821e720:	defff304 	addi	sp,sp,-52
 821e724:	dfc00c15 	stw	ra,48(sp)
 821e728:	df000b15 	stw	fp,44(sp)
 821e72c:	df000b04 	addi	fp,sp,44
 821e730:	e13ffc15 	stw	r4,-16(fp)
 821e734:	e17ffd15 	stw	r5,-12(fp)
 821e738:	e1bffe15 	stw	r6,-8(fp)
 821e73c:	3805883a 	mov	r2,r7
 821e740:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 821e744:	e0bfff0b 	ldhu	r2,-4(fp)
 821e748:	d8000615 	stw	zero,24(sp)
 821e74c:	e0c00317 	ldw	r3,12(fp)
 821e750:	d8c00515 	stw	r3,20(sp)
 821e754:	d8000415 	stw	zero,16(sp)
 821e758:	e0c00217 	ldw	r3,8(fp)
 821e75c:	d8c00315 	stw	r3,12(sp)
 821e760:	d8000215 	stw	zero,8(sp)
 821e764:	d8000115 	stw	zero,4(sp)
 821e768:	d8800015 	stw	r2,0(sp)
 821e76c:	e1fffe17 	ldw	r7,-8(fp)
 821e770:	000d883a 	mov	r6,zero
 821e774:	e17ffd17 	ldw	r5,-12(fp)
 821e778:	e13ffc17 	ldw	r4,-16(fp)
 821e77c:	821ebd00 	call	821ebd0 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
 821e780:	0001883a 	nop
 821e784:	e037883a 	mov	sp,fp
 821e788:	dfc00117 	ldw	ra,4(sp)
 821e78c:	df000017 	ldw	fp,0(sp)
 821e790:	dec00204 	addi	sp,sp,8
 821e794:	f800283a 	ret

0821e798 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
 821e798:	defff404 	addi	sp,sp,-48
 821e79c:	dfc00b15 	stw	ra,44(sp)
 821e7a0:	df000a15 	stw	fp,40(sp)
 821e7a4:	df000a04 	addi	fp,sp,40
 821e7a8:	e13ffb15 	stw	r4,-20(fp)
 821e7ac:	e17ffc15 	stw	r5,-16(fp)
 821e7b0:	e1bffd15 	stw	r6,-12(fp)
 821e7b4:	3807883a 	mov	r3,r7
 821e7b8:	e0800517 	ldw	r2,20(fp)
 821e7bc:	e0fffe0d 	sth	r3,-8(fp)
 821e7c0:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
 821e7c4:	e0fffe0b 	ldhu	r3,-8(fp)
 821e7c8:	e0bfff03 	ldbu	r2,-4(fp)
 821e7cc:	d8800415 	stw	r2,16(sp)
 821e7d0:	d8000315 	stw	zero,12(sp)
 821e7d4:	e0800417 	ldw	r2,16(fp)
 821e7d8:	d8800215 	stw	r2,8(sp)
 821e7dc:	e0800317 	ldw	r2,12(fp)
 821e7e0:	d8800115 	stw	r2,4(sp)
 821e7e4:	e0800217 	ldw	r2,8(fp)
 821e7e8:	d8800015 	stw	r2,0(sp)
 821e7ec:	180f883a 	mov	r7,r3
 821e7f0:	e1bffd17 	ldw	r6,-12(fp)
 821e7f4:	e17ffc17 	ldw	r5,-16(fp)
 821e7f8:	e13ffb17 	ldw	r4,-20(fp)
 821e7fc:	821e8180 	call	821e818 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
 821e800:	0001883a 	nop
 821e804:	e037883a 	mov	sp,fp
 821e808:	dfc00117 	ldw	ra,4(sp)
 821e80c:	df000017 	ldw	fp,0(sp)
 821e810:	dec00204 	addi	sp,sp,8
 821e814:	f800283a 	ret

0821e818 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
 821e818:	defff204 	addi	sp,sp,-56
 821e81c:	dfc00d15 	stw	ra,52(sp)
 821e820:	df000c15 	stw	fp,48(sp)
 821e824:	df000c04 	addi	fp,sp,48
 821e828:	e13ffb15 	stw	r4,-20(fp)
 821e82c:	e17ffc15 	stw	r5,-16(fp)
 821e830:	e1bffd15 	stw	r6,-12(fp)
 821e834:	3807883a 	mov	r3,r7
 821e838:	e0800617 	ldw	r2,24(fp)
 821e83c:	e0fffe0d 	sth	r3,-8(fp)
 821e840:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 821e844:	e0bffe0b 	ldhu	r2,-8(fp)
 821e848:	e0ffff03 	ldbu	r3,-4(fp)
 821e84c:	d8c00615 	stw	r3,24(sp)
 821e850:	d8000515 	stw	zero,20(sp)
 821e854:	e0c00517 	ldw	r3,20(fp)
 821e858:	d8c00415 	stw	r3,16(sp)
 821e85c:	e0c00317 	ldw	r3,12(fp)
 821e860:	d8c00315 	stw	r3,12(sp)
 821e864:	e0c00217 	ldw	r3,8(fp)
 821e868:	d8c00215 	stw	r3,8(sp)
 821e86c:	e0c00417 	ldw	r3,16(fp)
 821e870:	d8c00115 	stw	r3,4(sp)
 821e874:	d8800015 	stw	r2,0(sp)
 821e878:	000f883a 	mov	r7,zero
 821e87c:	e1bffd17 	ldw	r6,-12(fp)
 821e880:	e17ffc17 	ldw	r5,-16(fp)
 821e884:	e13ffb17 	ldw	r4,-20(fp)
 821e888:	821ebd00 	call	821ebd0 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
 821e88c:	0001883a 	nop
 821e890:	e037883a 	mov	sp,fp
 821e894:	dfc00117 	ldw	ra,4(sp)
 821e898:	df000017 	ldw	fp,0(sp)
 821e89c:	dec00204 	addi	sp,sp,8
 821e8a0:	f800283a 	ret

0821e8a4 <alt_avalon_sgdma_register_callback>:
void alt_avalon_sgdma_register_callback(
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
 821e8a4:	defffb04 	addi	sp,sp,-20
 821e8a8:	df000415 	stw	fp,16(sp)
 821e8ac:	df000404 	addi	fp,sp,16
 821e8b0:	e13ffc15 	stw	r4,-16(fp)
 821e8b4:	e17ffd15 	stw	r5,-12(fp)
 821e8b8:	e1bffe15 	stw	r6,-8(fp)
 821e8bc:	e1ffff15 	stw	r7,-4(fp)
  dev->callback         = callback;
 821e8c0:	e0bffc17 	ldw	r2,-16(fp)
 821e8c4:	e0fffd17 	ldw	r3,-12(fp)
 821e8c8:	10c00915 	stw	r3,36(r2)
  dev->callback_context = context;
 821e8cc:	e0bffc17 	ldw	r2,-16(fp)
 821e8d0:	e0ffff17 	ldw	r3,-4(fp)
 821e8d4:	10c00a15 	stw	r3,40(r2)
  dev->chain_control    = chain_control;
 821e8d8:	e0bffc17 	ldw	r2,-16(fp)
 821e8dc:	e0fffe17 	ldw	r3,-8(fp)
 821e8e0:	10c00b15 	stw	r3,44(r2)
}
 821e8e4:	0001883a 	nop
 821e8e8:	e037883a 	mov	sp,fp
 821e8ec:	df000017 	ldw	fp,0(sp)
 821e8f0:	dec00104 	addi	sp,sp,4
 821e8f4:	f800283a 	ret

0821e8f8 <alt_avalon_sgdma_start>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct.
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
 821e8f8:	defffd04 	addi	sp,sp,-12
 821e8fc:	df000215 	stw	fp,8(sp)
 821e900:	df000204 	addi	fp,sp,8
 821e904:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e908:	e0bfff17 	ldw	r2,-4(fp)
 821e90c:	10800317 	ldw	r2,12(r2)
 821e910:	10800404 	addi	r2,r2,16
 821e914:	10800037 	ldwio	r2,0(r2)
 821e918:	e0bffe15 	stw	r2,-8(fp)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 821e91c:	e0bffe17 	ldw	r2,-8(fp)
 821e920:	10800814 	ori	r2,r2,32
 821e924:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e928:	e0bfff17 	ldw	r2,-4(fp)
 821e92c:	10800317 	ldw	r2,12(r2)
 821e930:	10800404 	addi	r2,r2,16
 821e934:	e0fffe17 	ldw	r3,-8(fp)
 821e938:	10c00035 	stwio	r3,0(r2)
}
 821e93c:	0001883a 	nop
 821e940:	e037883a 	mov	sp,fp
 821e944:	df000017 	ldw	fp,0(sp)
 821e948:	dec00104 	addi	sp,sp,4
 821e94c:	f800283a 	ret

0821e950 <alt_avalon_sgdma_stop>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
 821e950:	defffd04 	addi	sp,sp,-12
 821e954:	df000215 	stw	fp,8(sp)
 821e958:	df000204 	addi	fp,sp,8
 821e95c:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e960:	e0bfff17 	ldw	r2,-4(fp)
 821e964:	10800317 	ldw	r2,12(r2)
 821e968:	10800404 	addi	r2,r2,16
 821e96c:	10800037 	ldwio	r2,0(r2)
 821e970:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 821e974:	e0fffe17 	ldw	r3,-8(fp)
 821e978:	00bff7c4 	movi	r2,-33
 821e97c:	1884703a 	and	r2,r3,r2
 821e980:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e984:	e0bfff17 	ldw	r2,-4(fp)
 821e988:	10800317 	ldw	r2,12(r2)
 821e98c:	10800404 	addi	r2,r2,16
 821e990:	e0fffe17 	ldw	r3,-8(fp)
 821e994:	10c00035 	stwio	r3,0(r2)
}
 821e998:	0001883a 	nop
 821e99c:	e037883a 	mov	sp,fp
 821e9a0:	df000017 	ldw	fp,0(sp)
 821e9a4:	dec00104 	addi	sp,sp,4
 821e9a8:	f800283a 	ret

0821e9ac <alt_avalon_sgdma_check_descriptor_status>:
 * - 0 if the descriptor is error-free, not "owned by hardware", or
 *   a previously requested transfer has appeared to have completed
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
 821e9ac:	defffe04 	addi	sp,sp,-8
 821e9b0:	df000115 	stw	fp,4(sp)
 821e9b4:	df000104 	addi	fp,sp,4
 821e9b8:	e13fff15 	stw	r4,-4(fp)
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
 821e9bc:	e0bfff17 	ldw	r2,-4(fp)
 821e9c0:	10800784 	addi	r2,r2,30
 821e9c4:	10800023 	ldbuio	r2,0(r2)
 821e9c8:	10803fcc 	andi	r2,r2,255
 821e9cc:	10801fcc 	andi	r2,r2,127
 821e9d0:	10000226 	beq	r2,zero,821e9dc <alt_avalon_sgdma_check_descriptor_status+0x30>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
 821e9d4:	00bffec4 	movi	r2,-5
 821e9d8:	00000906 	br	821ea00 <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

  if( IORD_8DIRECT(&desc->control, 0) &
 821e9dc:	e0bfff17 	ldw	r2,-4(fp)
 821e9e0:	108007c4 	addi	r2,r2,31
 821e9e4:	10800023 	ldbuio	r2,0(r2)
 821e9e8:	10803fcc 	andi	r2,r2,255
 821e9ec:	1080200c 	andi	r2,r2,128
 821e9f0:	10000226 	beq	r2,zero,821e9fc <alt_avalon_sgdma_check_descriptor_status+0x50>
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
 821e9f4:	00bfe244 	movi	r2,-119
 821e9f8:	00000106 	br	821ea00 <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

    return 0;
 821e9fc:	0005883a 	mov	r2,zero
}
 821ea00:	e037883a 	mov	sp,fp
 821ea04:	df000017 	ldw	fp,0(sp)
 821ea08:	dec00104 	addi	sp,sp,4
 821ea0c:	f800283a 	ret

0821ea10 <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
 821ea10:	defffc04 	addi	sp,sp,-16
 821ea14:	dfc00315 	stw	ra,12(sp)
 821ea18:	df000215 	stw	fp,8(sp)
 821ea1c:	df000204 	addi	fp,sp,8
 821ea20:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
 821ea24:	d1602b04 	addi	r5,gp,-32596
 821ea28:	e13fff17 	ldw	r4,-4(fp)
 821ea2c:	823bfac0 	call	823bfac <alt_find_dev>
 821ea30:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev) {
 821ea34:	e0bffe17 	ldw	r2,-8(fp)
 821ea38:	1000041e 	bne	r2,zero,821ea4c <alt_avalon_sgdma_open+0x3c>
    ALT_ERRNO = ENODEV;
 821ea3c:	821e3580 	call	821e358 <alt_get_errno>
 821ea40:	1007883a 	mov	r3,r2
 821ea44:	008004c4 	movi	r2,19
 821ea48:	18800015 	stw	r2,0(r3)
  }

  return dev;
 821ea4c:	e0bffe17 	ldw	r2,-8(fp)
}
 821ea50:	e037883a 	mov	sp,fp
 821ea54:	dfc00117 	ldw	ra,4(sp)
 821ea58:	df000017 	ldw	fp,0(sp)
 821ea5c:	dec00204 	addi	sp,sp,8
 821ea60:	f800283a 	ret

0821ea64 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
 821ea64:	defff104 	addi	sp,sp,-60
 821ea68:	dfc00e15 	stw	ra,56(sp)
 821ea6c:	df000d15 	stw	fp,52(sp)
 821ea70:	df000d04 	addi	fp,sp,52
 821ea74:	e13ffa15 	stw	r4,-24(fp)
 821ea78:	e17ffb15 	stw	r5,-20(fp)
 821ea7c:	e1bffc15 	stw	r6,-16(fp)
 821ea80:	e1fffd15 	stw	r7,-12(fp)
 821ea84:	e0c00217 	ldw	r3,8(fp)
 821ea88:	e0800617 	ldw	r2,24(fp)
 821ea8c:	e0fffe0d 	sth	r3,-8(fp)
 821ea90:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
 821ea94:	e0bffe0b 	ldhu	r2,-8(fp)
 821ea98:	e0ffff03 	ldbu	r3,-4(fp)
 821ea9c:	d8c00615 	stw	r3,24(sp)
 821eaa0:	d8000515 	stw	zero,20(sp)
 821eaa4:	d8000415 	stw	zero,16(sp)
 821eaa8:	e0c00517 	ldw	r3,20(fp)
 821eaac:	d8c00315 	stw	r3,12(sp)
 821eab0:	e0c00417 	ldw	r3,16(fp)
 821eab4:	d8c00215 	stw	r3,8(sp)
 821eab8:	e0c00317 	ldw	r3,12(fp)
 821eabc:	d8c00115 	stw	r3,4(sp)
 821eac0:	d8800015 	stw	r2,0(sp)
 821eac4:	e1fffd17 	ldw	r7,-12(fp)
 821eac8:	e1bffc17 	ldw	r6,-16(fp)
 821eacc:	e17ffb17 	ldw	r5,-20(fp)
 821ead0:	e13ffa17 	ldw	r4,-24(fp)
 821ead4:	821ebd00 	call	821ebd0 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
 821ead8:	0001883a 	nop
 821eadc:	e037883a 	mov	sp,fp
 821eae0:	dfc00117 	ldw	ra,4(sp)
 821eae4:	df000017 	ldw	fp,0(sp)
 821eae8:	dec00204 	addi	sp,sp,8
 821eaec:	f800283a 	ret

0821eaf0 <alt_avalon_sgdma_enable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
 821eaf0:	defffc04 	addi	sp,sp,-16
 821eaf4:	df000315 	stw	fp,12(sp)
 821eaf8:	df000304 	addi	fp,sp,12
 821eafc:	e13ffe15 	stw	r4,-8(fp)
 821eb00:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821eb04:	e0bffe17 	ldw	r2,-8(fp)
 821eb08:	10800317 	ldw	r2,12(r2)
 821eb0c:	10800404 	addi	r2,r2,16
 821eb10:	10800037 	ldwio	r2,0(r2)
 821eb14:	e0bffd15 	stw	r2,-12(fp)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
 821eb18:	e0fffd17 	ldw	r3,-12(fp)
 821eb1c:	00a00434 	movhi	r2,32784
 821eb20:	10bfffc4 	addi	r2,r2,-1
 821eb24:	1884703a 	and	r2,r3,r2
 821eb28:	e0bffd15 	stw	r2,-12(fp)
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
 821eb2c:	e0bfff17 	ldw	r2,-4(fp)
 821eb30:	1004953a 	slli	r2,r2,20
 821eb34:	10dffc2c 	andhi	r3,r2,32752

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
 821eb38:	e0bffd17 	ldw	r2,-12(fp)
 821eb3c:	1884b03a 	or	r2,r3,r2
 821eb40:	10800134 	orhi	r2,r2,4
 821eb44:	e0bffd15 	stw	r2,-12(fp)
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821eb48:	e0bffe17 	ldw	r2,-8(fp)
 821eb4c:	10800317 	ldw	r2,12(r2)
 821eb50:	10800404 	addi	r2,r2,16
 821eb54:	e0fffd17 	ldw	r3,-12(fp)
 821eb58:	10c00035 	stwio	r3,0(r2)
  
  return;
 821eb5c:	0001883a 	nop
}
 821eb60:	e037883a 	mov	sp,fp
 821eb64:	df000017 	ldw	fp,0(sp)
 821eb68:	dec00104 	addi	sp,sp,4
 821eb6c:	f800283a 	ret

0821eb70 <alt_avalon_sgdma_disable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
 821eb70:	defffd04 	addi	sp,sp,-12
 821eb74:	df000215 	stw	fp,8(sp)
 821eb78:	df000204 	addi	fp,sp,8
 821eb7c:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821eb80:	e0bfff17 	ldw	r2,-4(fp)
 821eb84:	10800317 	ldw	r2,12(r2)
 821eb88:	10800404 	addi	r2,r2,16
 821eb8c:	10800037 	ldwio	r2,0(r2)
 821eb90:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;
 821eb94:	e0fffe17 	ldw	r3,-8(fp)
 821eb98:	00bfff34 	movhi	r2,65532
 821eb9c:	10bfffc4 	addi	r2,r2,-1
 821eba0:	1884703a 	and	r2,r3,r2
 821eba4:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821eba8:	e0bfff17 	ldw	r2,-4(fp)
 821ebac:	10800317 	ldw	r2,12(r2)
 821ebb0:	10800404 	addi	r2,r2,16
 821ebb4:	e0fffe17 	ldw	r3,-8(fp)
 821ebb8:	10c00035 	stwio	r3,0(r2)
  
  return;
 821ebbc:	0001883a 	nop
}
 821ebc0:	e037883a 	mov	sp,fp
 821ebc4:	df000017 	ldw	fp,0(sp)
 821ebc8:	dec00104 	addi	sp,sp,4
 821ebcc:	f800283a 	ret

0821ebd0 <alt_avalon_sgdma_construct_descriptor_burst>:
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
 821ebd0:	defff804 	addi	sp,sp,-32
 821ebd4:	dfc00715 	stw	ra,28(sp)
 821ebd8:	df000615 	stw	fp,24(sp)
 821ebdc:	df000604 	addi	fp,sp,24
 821ebe0:	e13ffa15 	stw	r4,-24(fp)
 821ebe4:	e17ffb15 	stw	r5,-20(fp)
 821ebe8:	e1bffc15 	stw	r6,-16(fp)
 821ebec:	e1fffd15 	stw	r7,-12(fp)
 821ebf0:	e0c00217 	ldw	r3,8(fp)
 821ebf4:	e0800817 	ldw	r2,32(fp)
 821ebf8:	e0fffe0d 	sth	r3,-8(fp)
 821ebfc:	e0bfff05 	stb	r2,-4(fp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
 821ec00:	e0bffb17 	ldw	r2,-20(fp)
 821ec04:	108007c4 	addi	r2,r2,31
 821ec08:	e0fffb17 	ldw	r3,-20(fp)
 821ec0c:	18c007c3 	ldbu	r3,31(r3)
 821ec10:	19003fcc 	andi	r4,r3,255
 821ec14:	00ffdfc4 	movi	r3,-129
 821ec18:	20c6703a 	and	r3,r4,r3
 821ec1c:	10c00025 	stbio	r3,0(r2)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
 821ec20:	e0bffa17 	ldw	r2,-24(fp)
 821ec24:	e0fffc17 	ldw	r3,-16(fp)
 821ec28:	19403fcc 	andi	r5,r3,255
 821ec2c:	10c00003 	ldbu	r3,0(r2)
 821ec30:	1806703a 	and	r3,r3,zero
 821ec34:	1809883a 	mov	r4,r3
 821ec38:	2807883a 	mov	r3,r5
 821ec3c:	20c6b03a 	or	r3,r4,r3
 821ec40:	10c00005 	stb	r3,0(r2)
 821ec44:	e0fffc17 	ldw	r3,-16(fp)
 821ec48:	1806d23a 	srli	r3,r3,8
 821ec4c:	19403fcc 	andi	r5,r3,255
 821ec50:	10c00043 	ldbu	r3,1(r2)
 821ec54:	1806703a 	and	r3,r3,zero
 821ec58:	1809883a 	mov	r4,r3
 821ec5c:	2807883a 	mov	r3,r5
 821ec60:	20c6b03a 	or	r3,r4,r3
 821ec64:	10c00045 	stb	r3,1(r2)
 821ec68:	e0fffc17 	ldw	r3,-16(fp)
 821ec6c:	1806d43a 	srli	r3,r3,16
 821ec70:	19403fcc 	andi	r5,r3,255
 821ec74:	10c00083 	ldbu	r3,2(r2)
 821ec78:	1806703a 	and	r3,r3,zero
 821ec7c:	1809883a 	mov	r4,r3
 821ec80:	2807883a 	mov	r3,r5
 821ec84:	20c6b03a 	or	r3,r4,r3
 821ec88:	10c00085 	stb	r3,2(r2)
 821ec8c:	e0fffc17 	ldw	r3,-16(fp)
 821ec90:	180ad63a 	srli	r5,r3,24
 821ec94:	10c000c3 	ldbu	r3,3(r2)
 821ec98:	1806703a 	and	r3,r3,zero
 821ec9c:	1809883a 	mov	r4,r3
 821eca0:	2807883a 	mov	r3,r5
 821eca4:	20c6b03a 	or	r3,r4,r3
 821eca8:	10c000c5 	stb	r3,3(r2)
  desc->write_addr               = write_addr;
 821ecac:	e0bffa17 	ldw	r2,-24(fp)
 821ecb0:	e0fffd17 	ldw	r3,-12(fp)
 821ecb4:	19403fcc 	andi	r5,r3,255
 821ecb8:	10c00203 	ldbu	r3,8(r2)
 821ecbc:	1806703a 	and	r3,r3,zero
 821ecc0:	1809883a 	mov	r4,r3
 821ecc4:	2807883a 	mov	r3,r5
 821ecc8:	20c6b03a 	or	r3,r4,r3
 821eccc:	10c00205 	stb	r3,8(r2)
 821ecd0:	e0fffd17 	ldw	r3,-12(fp)
 821ecd4:	1806d23a 	srli	r3,r3,8
 821ecd8:	19403fcc 	andi	r5,r3,255
 821ecdc:	10c00243 	ldbu	r3,9(r2)
 821ece0:	1806703a 	and	r3,r3,zero
 821ece4:	1809883a 	mov	r4,r3
 821ece8:	2807883a 	mov	r3,r5
 821ecec:	20c6b03a 	or	r3,r4,r3
 821ecf0:	10c00245 	stb	r3,9(r2)
 821ecf4:	e0fffd17 	ldw	r3,-12(fp)
 821ecf8:	1806d43a 	srli	r3,r3,16
 821ecfc:	19403fcc 	andi	r5,r3,255
 821ed00:	10c00283 	ldbu	r3,10(r2)
 821ed04:	1806703a 	and	r3,r3,zero
 821ed08:	1809883a 	mov	r4,r3
 821ed0c:	2807883a 	mov	r3,r5
 821ed10:	20c6b03a 	or	r3,r4,r3
 821ed14:	10c00285 	stb	r3,10(r2)
 821ed18:	e0fffd17 	ldw	r3,-12(fp)
 821ed1c:	180ad63a 	srli	r5,r3,24
 821ed20:	10c002c3 	ldbu	r3,11(r2)
 821ed24:	1806703a 	and	r3,r3,zero
 821ed28:	1809883a 	mov	r4,r3
 821ed2c:	2807883a 	mov	r3,r5
 821ed30:	20c6b03a 	or	r3,r4,r3
 821ed34:	10c002c5 	stb	r3,11(r2)
  desc->next                     = (alt_u32 *) next;
 821ed38:	e0bffa17 	ldw	r2,-24(fp)
 821ed3c:	e0fffb17 	ldw	r3,-20(fp)
 821ed40:	19403fcc 	andi	r5,r3,255
 821ed44:	10c00403 	ldbu	r3,16(r2)
 821ed48:	1806703a 	and	r3,r3,zero
 821ed4c:	1809883a 	mov	r4,r3
 821ed50:	2807883a 	mov	r3,r5
 821ed54:	20c6b03a 	or	r3,r4,r3
 821ed58:	10c00405 	stb	r3,16(r2)
 821ed5c:	e0fffb17 	ldw	r3,-20(fp)
 821ed60:	1806d23a 	srli	r3,r3,8
 821ed64:	19403fcc 	andi	r5,r3,255
 821ed68:	10c00443 	ldbu	r3,17(r2)
 821ed6c:	1806703a 	and	r3,r3,zero
 821ed70:	1809883a 	mov	r4,r3
 821ed74:	2807883a 	mov	r3,r5
 821ed78:	20c6b03a 	or	r3,r4,r3
 821ed7c:	10c00445 	stb	r3,17(r2)
 821ed80:	e0fffb17 	ldw	r3,-20(fp)
 821ed84:	1806d43a 	srli	r3,r3,16
 821ed88:	19403fcc 	andi	r5,r3,255
 821ed8c:	10c00483 	ldbu	r3,18(r2)
 821ed90:	1806703a 	and	r3,r3,zero
 821ed94:	1809883a 	mov	r4,r3
 821ed98:	2807883a 	mov	r3,r5
 821ed9c:	20c6b03a 	or	r3,r4,r3
 821eda0:	10c00485 	stb	r3,18(r2)
 821eda4:	e0fffb17 	ldw	r3,-20(fp)
 821eda8:	180ad63a 	srli	r5,r3,24
 821edac:	10c004c3 	ldbu	r3,19(r2)
 821edb0:	1806703a 	and	r3,r3,zero
 821edb4:	1809883a 	mov	r4,r3
 821edb8:	2807883a 	mov	r3,r5
 821edbc:	20c6b03a 	or	r3,r4,r3
 821edc0:	10c004c5 	stb	r3,19(r2)
  desc->read_addr_pad            = 0x0;
 821edc4:	e0bffa17 	ldw	r2,-24(fp)
 821edc8:	10c00103 	ldbu	r3,4(r2)
 821edcc:	1806703a 	and	r3,r3,zero
 821edd0:	10c00105 	stb	r3,4(r2)
 821edd4:	10c00143 	ldbu	r3,5(r2)
 821edd8:	1806703a 	and	r3,r3,zero
 821eddc:	10c00145 	stb	r3,5(r2)
 821ede0:	10c00183 	ldbu	r3,6(r2)
 821ede4:	1806703a 	and	r3,r3,zero
 821ede8:	10c00185 	stb	r3,6(r2)
 821edec:	10c001c3 	ldbu	r3,7(r2)
 821edf0:	1806703a 	and	r3,r3,zero
 821edf4:	10c001c5 	stb	r3,7(r2)
  desc->write_addr_pad           = 0x0;
 821edf8:	e0bffa17 	ldw	r2,-24(fp)
 821edfc:	10c00303 	ldbu	r3,12(r2)
 821ee00:	1806703a 	and	r3,r3,zero
 821ee04:	10c00305 	stb	r3,12(r2)
 821ee08:	10c00343 	ldbu	r3,13(r2)
 821ee0c:	1806703a 	and	r3,r3,zero
 821ee10:	10c00345 	stb	r3,13(r2)
 821ee14:	10c00383 	ldbu	r3,14(r2)
 821ee18:	1806703a 	and	r3,r3,zero
 821ee1c:	10c00385 	stb	r3,14(r2)
 821ee20:	10c003c3 	ldbu	r3,15(r2)
 821ee24:	1806703a 	and	r3,r3,zero
 821ee28:	10c003c5 	stb	r3,15(r2)
  desc->next_pad                 = 0x0;
 821ee2c:	e0bffa17 	ldw	r2,-24(fp)
 821ee30:	10c00503 	ldbu	r3,20(r2)
 821ee34:	1806703a 	and	r3,r3,zero
 821ee38:	10c00505 	stb	r3,20(r2)
 821ee3c:	10c00543 	ldbu	r3,21(r2)
 821ee40:	1806703a 	and	r3,r3,zero
 821ee44:	10c00545 	stb	r3,21(r2)
 821ee48:	10c00583 	ldbu	r3,22(r2)
 821ee4c:	1806703a 	and	r3,r3,zero
 821ee50:	10c00585 	stb	r3,22(r2)
 821ee54:	10c005c3 	ldbu	r3,23(r2)
 821ee58:	1806703a 	and	r3,r3,zero
 821ee5c:	10c005c5 	stb	r3,23(r2)
  desc->bytes_to_transfer        = length_or_eop;
 821ee60:	e0bffa17 	ldw	r2,-24(fp)
 821ee64:	e0fffe17 	ldw	r3,-8(fp)
 821ee68:	19403fcc 	andi	r5,r3,255
 821ee6c:	10c00603 	ldbu	r3,24(r2)
 821ee70:	1806703a 	and	r3,r3,zero
 821ee74:	1809883a 	mov	r4,r3
 821ee78:	2807883a 	mov	r3,r5
 821ee7c:	20c6b03a 	or	r3,r4,r3
 821ee80:	10c00605 	stb	r3,24(r2)
 821ee84:	e0fffe17 	ldw	r3,-8(fp)
 821ee88:	1806d23a 	srli	r3,r3,8
 821ee8c:	19403fcc 	andi	r5,r3,255
 821ee90:	10c00643 	ldbu	r3,25(r2)
 821ee94:	1806703a 	and	r3,r3,zero
 821ee98:	1809883a 	mov	r4,r3
 821ee9c:	2807883a 	mov	r3,r5
 821eea0:	20c6b03a 	or	r3,r4,r3
 821eea4:	10c00645 	stb	r3,25(r2)
  desc->actual_bytes_transferred = 0;
 821eea8:	e0bffa17 	ldw	r2,-24(fp)
 821eeac:	10c00703 	ldbu	r3,28(r2)
 821eeb0:	1806703a 	and	r3,r3,zero
 821eeb4:	10c00705 	stb	r3,28(r2)
 821eeb8:	10c00743 	ldbu	r3,29(r2)
 821eebc:	1806703a 	and	r3,r3,zero
 821eec0:	10c00745 	stb	r3,29(r2)
  desc->status                   = 0x0;
 821eec4:	e0bffa17 	ldw	r2,-24(fp)
 821eec8:	10000785 	stb	zero,30(r2)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
 821eecc:	e0800617 	ldw	r2,24(fp)
 821eed0:	1007883a 	mov	r3,r2
 821eed4:	e0bffa17 	ldw	r2,-24(fp)
 821eed8:	10c00685 	stb	r3,26(r2)
  desc->write_burst              = write_burst;
 821eedc:	e0800717 	ldw	r2,28(fp)
 821eee0:	1007883a 	mov	r3,r2
 821eee4:	e0bffa17 	ldw	r2,-24(fp)
 821eee8:	10c006c5 	stb	r3,27(r2)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
 821eeec:	e0800317 	ldw	r2,12(fp)
 821eef0:	10000226 	beq	r2,zero,821eefc <alt_avalon_sgdma_construct_descriptor_burst+0x32c>
 821eef4:	00bfe044 	movi	r2,-127
 821eef8:	00000106 	br	821ef00 <alt_avalon_sgdma_construct_descriptor_burst+0x330>
 821eefc:	00bfe004 	movi	r2,-128
 821ef00:	e0c00417 	ldw	r3,16(fp)
 821ef04:	18000226 	beq	r3,zero,821ef10 <alt_avalon_sgdma_construct_descriptor_burst+0x340>
 821ef08:	00c00084 	movi	r3,2
 821ef0c:	00000106 	br	821ef14 <alt_avalon_sgdma_construct_descriptor_burst+0x344>
 821ef10:	0007883a 	mov	r3,zero
 821ef14:	10c4b03a 	or	r2,r2,r3
 821ef18:	1007883a 	mov	r3,r2
 821ef1c:	e0800517 	ldw	r2,20(fp)
 821ef20:	10000226 	beq	r2,zero,821ef2c <alt_avalon_sgdma_construct_descriptor_burst+0x35c>
 821ef24:	00800104 	movi	r2,4
 821ef28:	00000106 	br	821ef30 <alt_avalon_sgdma_construct_descriptor_burst+0x360>
 821ef2c:	0005883a 	mov	r2,zero
 821ef30:	1884b03a 	or	r2,r3,r2
 821ef34:	1007883a 	mov	r3,r2
 821ef38:	e0bfff03 	ldbu	r2,-4(fp)
 821ef3c:	10000426 	beq	r2,zero,821ef50 <alt_avalon_sgdma_construct_descriptor_burst+0x380>
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_GENERATE_EOP_MSK : 0x0)        |
    (read_fixed ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_READ_FIXED_ADDRESS_MSK : 0x0)  |
    (write_fixed_or_sop ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_WRITE_FIXED_ADDRESS_MSK : 0x0) |
    (atlantic_channel ? ( (atlantic_channel & 0x0F) << 3) : 0)
 821ef40:	e0bfff03 	ldbu	r2,-4(fp)
 821ef44:	108003cc 	andi	r2,r2,15
 821ef48:	100490fa 	slli	r2,r2,3
 821ef4c:	00000106 	br	821ef54 <alt_avalon_sgdma_construct_descriptor_burst+0x384>
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
 821ef50:	0005883a 	mov	r2,zero
 821ef54:	1884b03a 	or	r2,r3,r2
 821ef58:	1007883a 	mov	r3,r2
 821ef5c:	e0bffa17 	ldw	r2,-24(fp)
 821ef60:	10c007c5 	stb	r3,31(r2)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
 821ef64:	01400804 	movi	r5,32
 821ef68:	e13ffa17 	ldw	r4,-24(fp)
 821ef6c:	823bd680 	call	823bd68 <alt_dcache_flush>
}
 821ef70:	0001883a 	nop
 821ef74:	e037883a 	mov	sp,fp
 821ef78:	dfc00117 	ldw	ra,4(sp)
 821ef7c:	df000017 	ldw	fp,0(sp)
 821ef80:	dec00204 	addi	sp,sp,8
 821ef84:	f800283a 	ret

0821ef88 <alt_avalon_sgdma_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
 821ef88:	defff904 	addi	sp,sp,-28
 821ef8c:	dfc00615 	stw	ra,24(sp)
 821ef90:	df000515 	stw	fp,20(sp)
 821ef94:	df000504 	addi	fp,sp,20
 821ef98:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev *dev = (alt_sgdma_dev *) context;
 821ef9c:	e0bfff17 	ldw	r2,-4(fp)
 821efa0:	e0bffb15 	stw	r2,-20(fp)
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 821efa4:	e0bffb17 	ldw	r2,-20(fp)
 821efa8:	10800317 	ldw	r2,12(r2)
 821efac:	10800404 	addi	r2,r2,16
 821efb0:	e0fffb17 	ldw	r3,-20(fp)
 821efb4:	18c00317 	ldw	r3,12(r3)
 821efb8:	18c00404 	addi	r3,r3,16
 821efbc:	18c00037 	ldwio	r3,0(r3)
 821efc0:	18e00034 	orhi	r3,r3,32768
 821efc4:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821efc8:	e0bffb17 	ldw	r2,-20(fp)
 821efcc:	10800317 	ldw	r2,12(r2)
 821efd0:	10800404 	addi	r2,r2,16
 821efd4:	10800037 	ldwio	r2,0(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
 821efd8:	e0bffb17 	ldw	r2,-20(fp)
 821efdc:	10800917 	ldw	r2,36(r2)
 821efe0:	10001226 	beq	r2,zero,821f02c <alt_avalon_sgdma_irq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821efe4:	0005303a 	rdctl	r2,status
 821efe8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821efec:	e0fffd17 	ldw	r3,-12(fp)
 821eff0:	00bfff84 	movi	r2,-2
 821eff4:	1884703a 	and	r2,r3,r2
 821eff8:	1001703a 	wrctl	status,r2
  
  return context;
 821effc:	e0bffd17 	ldw	r2,-12(fp)
    cpu_sr = alt_irq_disable_all();
 821f000:	e0bffc15 	stw	r2,-16(fp)
    (dev->callback)(dev->callback_context);
 821f004:	e0bffb17 	ldw	r2,-20(fp)
 821f008:	10800917 	ldw	r2,36(r2)
 821f00c:	e0fffb17 	ldw	r3,-20(fp)
 821f010:	18c00a17 	ldw	r3,40(r3)
 821f014:	1809883a 	mov	r4,r3
 821f018:	103ee83a 	callr	r2
 821f01c:	e0bffc17 	ldw	r2,-16(fp)
 821f020:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821f024:	e0bffe17 	ldw	r2,-8(fp)
 821f028:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
  }
}
 821f02c:	0001883a 	nop
 821f030:	e037883a 	mov	sp,fp
 821f034:	dfc00117 	ldw	ra,4(sp)
 821f038:	df000017 	ldw	fp,0(sp)
 821f03c:	dec00204 	addi	sp,sp,8
 821f040:	f800283a 	ret

0821f044 <alt_avalon_sgdma_init>:
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
 821f044:	defffa04 	addi	sp,sp,-24
 821f048:	dfc00515 	stw	ra,20(sp)
 821f04c:	df000415 	stw	fp,16(sp)
 821f050:	df000404 	addi	fp,sp,16
 821f054:	e13ffd15 	stw	r4,-12(fp)
 821f058:	e17ffe15 	stw	r5,-8(fp)
 821f05c:	e1bfff15 	stw	r6,-4(fp)

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821f060:	e0bffd17 	ldw	r2,-12(fp)
 821f064:	10800317 	ldw	r2,12(r2)
 821f068:	10800404 	addi	r2,r2,16
 821f06c:	00c00074 	movhi	r3,1
 821f070:	10c00035 	stwio	r3,0(r2)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821f074:	e0bffd17 	ldw	r2,-12(fp)
 821f078:	10800317 	ldw	r2,12(r2)
 821f07c:	10800404 	addi	r2,r2,16
 821f080:	00c00074 	movhi	r3,1
 821f084:	10c00035 	stwio	r3,0(r2)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
 821f088:	e0bffd17 	ldw	r2,-12(fp)
 821f08c:	10800317 	ldw	r2,12(r2)
 821f090:	10800404 	addi	r2,r2,16
 821f094:	0007883a 	mov	r3,zero
 821f098:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 821f09c:	e0bffd17 	ldw	r2,-12(fp)
 821f0a0:	10800317 	ldw	r2,12(r2)
 821f0a4:	00c03fc4 	movi	r3,255
 821f0a8:	10c00035 	stwio	r3,0(r2)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
 821f0ac:	d1602b04 	addi	r5,gp,-32596
 821f0b0:	e13ffd17 	ldw	r4,-12(fp)
 821f0b4:	823be480 	call	823be48 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
 821f0b8:	d8000015 	stw	zero,0(sp)
 821f0bc:	e1fffd17 	ldw	r7,-12(fp)
 821f0c0:	018208b4 	movhi	r6,2082
 821f0c4:	31bbe204 	addi	r6,r6,-4216
 821f0c8:	e17fff17 	ldw	r5,-4(fp)
 821f0cc:	e13ffe17 	ldw	r4,-8(fp)
 821f0d0:	823c03c0 	call	823c03c <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
 821f0d4:	0001883a 	nop
 821f0d8:	e037883a 	mov	sp,fp
 821f0dc:	dfc00117 	ldw	ra,4(sp)
 821f0e0:	df000017 	ldw	fp,0(sp)
 821f0e4:	dec00204 	addi	sp,sp,8
 821f0e8:	f800283a 	ret

0821f0ec <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 821f0ec:	defffa04 	addi	sp,sp,-24
 821f0f0:	dfc00515 	stw	ra,20(sp)
 821f0f4:	df000415 	stw	fp,16(sp)
 821f0f8:	df000404 	addi	fp,sp,16
 821f0fc:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 821f100:	0007883a 	mov	r3,zero
 821f104:	e0bfff17 	ldw	r2,-4(fp)
 821f108:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 821f10c:	e0bfff17 	ldw	r2,-4(fp)
 821f110:	10800104 	addi	r2,r2,4
 821f114:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821f118:	0005303a 	rdctl	r2,status
 821f11c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821f120:	e0fffd17 	ldw	r3,-12(fp)
 821f124:	00bfff84 	movi	r2,-2
 821f128:	1884703a 	and	r2,r3,r2
 821f12c:	1001703a 	wrctl	status,r2
  
  return context;
 821f130:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 821f134:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
 821f138:	823c8dc0 	call	823c8dc <alt_tick>
 821f13c:	e0bffc17 	ldw	r2,-16(fp)
 821f140:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821f144:	e0bffe17 	ldw	r2,-8(fp)
 821f148:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 821f14c:	0001883a 	nop
 821f150:	e037883a 	mov	sp,fp
 821f154:	dfc00117 	ldw	ra,4(sp)
 821f158:	df000017 	ldw	fp,0(sp)
 821f15c:	dec00204 	addi	sp,sp,8
 821f160:	f800283a 	ret

0821f164 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 821f164:	defff804 	addi	sp,sp,-32
 821f168:	dfc00715 	stw	ra,28(sp)
 821f16c:	df000615 	stw	fp,24(sp)
 821f170:	df000604 	addi	fp,sp,24
 821f174:	e13ffc15 	stw	r4,-16(fp)
 821f178:	e17ffd15 	stw	r5,-12(fp)
 821f17c:	e1bffe15 	stw	r6,-8(fp)
 821f180:	e1ffff15 	stw	r7,-4(fp)
 821f184:	e0bfff17 	ldw	r2,-4(fp)
 821f188:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 821f18c:	d0a0b817 	ldw	r2,-32032(gp)
 821f190:	1000021e 	bne	r2,zero,821f19c <alt_avalon_timer_sc_init+0x38>
  {
    _alt_tick_rate = nticks;
 821f194:	e0bffb17 	ldw	r2,-20(fp)
 821f198:	d0a0b815 	stw	r2,-32032(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 821f19c:	e0bffc17 	ldw	r2,-16(fp)
 821f1a0:	10800104 	addi	r2,r2,4
 821f1a4:	00c001c4 	movi	r3,7
 821f1a8:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 821f1ac:	d8000015 	stw	zero,0(sp)
 821f1b0:	e1fffc17 	ldw	r7,-16(fp)
 821f1b4:	018208b4 	movhi	r6,2082
 821f1b8:	31bc3b04 	addi	r6,r6,-3860
 821f1bc:	e17ffe17 	ldw	r5,-8(fp)
 821f1c0:	e13ffd17 	ldw	r4,-12(fp)
 821f1c4:	823c03c0 	call	823c03c <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 821f1c8:	0001883a 	nop
 821f1cc:	e037883a 	mov	sp,fp
 821f1d0:	dfc00117 	ldw	ra,4(sp)
 821f1d4:	df000017 	ldw	fp,0(sp)
 821f1d8:	dec00204 	addi	sp,sp,8
 821f1dc:	f800283a 	ret

0821f1e0 <no_printf>:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void no_printf (char *fmt, ...) {}
 821f1e0:	defffb04 	addi	sp,sp,-20
 821f1e4:	df000115 	stw	fp,4(sp)
 821f1e8:	df000104 	addi	fp,sp,4
 821f1ec:	e13fff15 	stw	r4,-4(fp)
 821f1f0:	e1400115 	stw	r5,4(fp)
 821f1f4:	e1800215 	stw	r6,8(fp)
 821f1f8:	e1c00315 	stw	r7,12(fp)
 821f1fc:	0001883a 	nop
 821f200:	e037883a 	mov	sp,fp
 821f204:	df000017 	ldw	fp,0(sp)
 821f208:	dec00404 	addi	sp,sp,16
 821f20c:	f800283a 	ret

0821f210 <tse_mac_initTransInfo2>:

alt_32 tse_mac_initTransInfo2( tse_mac_trans_info *mi,
                                        alt_u32 mac_base,
                                        alt_32 tx_sgdma,
                                        alt_32 rx_sgdma,
                                        alt_32 cfgflags) {
 821f210:	defffb04 	addi	sp,sp,-20
 821f214:	df000415 	stw	fp,16(sp)
 821f218:	df000404 	addi	fp,sp,16
 821f21c:	e13ffc15 	stw	r4,-16(fp)
 821f220:	e17ffd15 	stw	r5,-12(fp)
 821f224:	e1bffe15 	stw	r6,-8(fp)
 821f228:	e1ffff15 	stw	r7,-4(fp)
                                              
        mi->base     = (np_tse_mac*)mac_base;
 821f22c:	e0fffd17 	ldw	r3,-12(fp)
 821f230:	e0bffc17 	ldw	r2,-16(fp)
 821f234:	10c00015 	stw	r3,0(r2)
        mi->tx_sgdma = (alt_sgdma_dev *)tx_sgdma;
 821f238:	e0fffe17 	ldw	r3,-8(fp)
 821f23c:	e0bffc17 	ldw	r2,-16(fp)
 821f240:	10c00115 	stw	r3,4(r2)
        mi->rx_sgdma = (alt_sgdma_dev *)rx_sgdma;
 821f244:	e0ffff17 	ldw	r3,-4(fp)
 821f248:	e0bffc17 	ldw	r2,-16(fp)
 821f24c:	10c00215 	stw	r3,8(r2)
        mi->cfgflags = cfgflags;     
 821f250:	e0c00117 	ldw	r3,4(fp)
 821f254:	e0bffc17 	ldw	r2,-16(fp)
 821f258:	10c00415 	stw	r3,16(r2)
        return SUCCESS;
 821f25c:	0005883a 	mov	r2,zero
}
 821f260:	e037883a 	mov	sp,fp
 821f264:	df000017 	ldw	fp,0(sp)
 821f268:	dec00104 	addi	sp,sp,4
 821f26c:	f800283a 	ret

0821f270 <tse_mac_sTxWrite>:
  * @param txDesc           Pointer to the transmit SGDMA descriptor
  * @return actual bytes transferred if ok, else error (-1)
  */
alt_32 tse_mac_sTxWrite( tse_mac_trans_info *mi, 
                       alt_sgdma_descriptor *txDesc)   
{ 
 821f270:	defffa04 	addi	sp,sp,-24
 821f274:	dfc00515 	stw	ra,20(sp)
 821f278:	df000415 	stw	fp,16(sp)
 821f27c:	df000404 	addi	fp,sp,16
 821f280:	e13ffe15 	stw	r4,-8(fp)
 821f284:	e17fff15 	stw	r5,-4(fp)

  alt_32 timeout;
  alt_u8 result = 0;
 821f288:	e03ffd05 	stb	zero,-12(fp)
  alt_u16 actualBytesTransferred;
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
 821f28c:	e03ffc15 	stw	zero,-16(fp)
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 821f290:	00000b06 	br	821f2c0 <tse_mac_sTxWrite+0x50>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
           if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 821f294:	e0fffc17 	ldw	r3,-16(fp)
 821f298:	18800044 	addi	r2,r3,1
 821f29c:	e0bffc15 	stw	r2,-16(fp)
 821f2a0:	008003f4 	movhi	r2,15
 821f2a4:	10909004 	addi	r2,r2,16960
 821f2a8:	1880051e 	bne	r3,r2,821f2c0 <tse_mac_sTxWrite+0x50>
            tse_dprintf(4, "WARNING : TX SGDMA Timeout\n");
 821f2ac:	01020974 	movhi	r4,2085
 821f2b0:	2137fe04 	addi	r4,r4,-8200
 821f2b4:	82036800 	call	8203680 <puts>
            return ENP_RESOURCE;  // avoid being stuck here
 821f2b8:	00bffa84 	movi	r2,-22
 821f2bc:	00002006 	br	821f340 <tse_mac_sTxWrite+0xd0>
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 821f2c0:	e0bffe17 	ldw	r2,-8(fp)
 821f2c4:	10800117 	ldw	r2,4(r2)
 821f2c8:	10800317 	ldw	r2,12(r2)
 821f2cc:	10800037 	ldwio	r2,0(r2)
 821f2d0:	1080040c 	andi	r2,r2,16
 821f2d4:	103fef1e 	bne	r2,zero,821f294 <tse_mac_sTxWrite+0x24>
           }
  }

  // Set up the SGDMA
  // Clear the status and control bits of the SGDMA descriptor
  IOWR_ALTERA_AVALON_SGDMA_CONTROL (mi->tx_sgdma->base, 0);
 821f2d8:	e0bffe17 	ldw	r2,-8(fp)
 821f2dc:	10800117 	ldw	r2,4(r2)
 821f2e0:	10800317 	ldw	r2,12(r2)
 821f2e4:	10800404 	addi	r2,r2,16
 821f2e8:	0007883a 	mov	r3,zero
 821f2ec:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS (mi->tx_sgdma->base, 0xFF);
 821f2f0:	e0bffe17 	ldw	r2,-8(fp)
 821f2f4:	10800117 	ldw	r2,4(r2)
 821f2f8:	10800317 	ldw	r2,12(r2)
 821f2fc:	00c03fc4 	movi	r3,255
 821f300:	10c00035 	stwio	r3,0(r2)
  
  // Start SGDMA (blocking call)
  result = alt_avalon_sgdma_do_sync_transfer(
 821f304:	e0bffe17 	ldw	r2,-8(fp)
 821f308:	10800117 	ldw	r2,4(r2)
 821f30c:	e17fff17 	ldw	r5,-4(fp)
 821f310:	1009883a 	mov	r4,r2
 821f314:	821e4b80 	call	821e4b8 <alt_avalon_sgdma_do_sync_transfer>
 821f318:	e0bffd05 	stb	r2,-12(fp)
                mi->tx_sgdma, 
                (alt_sgdma_descriptor *) &txDesc[0]);
  
  if (result != 0)
 821f31c:	e0bffd03 	ldbu	r2,-12(fp)
 821f320:	10000226 	beq	r2,zero,821f32c <tse_mac_sTxWrite+0xbc>
    return -1;
 821f324:	00bfffc4 	movi	r2,-1
 821f328:	00000506 	br	821f340 <tse_mac_sTxWrite+0xd0>
  
  /* perform cache save read to obtain actual bytes transferred for current sgdma descriptor */
  actualBytesTransferred = IORD_ALTERA_TSE_SGDMA_DESC_ACTUAL_BYTES_TRANSFERRED(&txDesc[0]);
 821f32c:	e0bfff17 	ldw	r2,-4(fp)
 821f330:	10800704 	addi	r2,r2,28
 821f334:	10800037 	ldwio	r2,0(r2)
 821f338:	e0bffd8d 	sth	r2,-10(fp)

  return actualBytesTransferred;
 821f33c:	e0bffd8b 	ldhu	r2,-10(fp)
}
 821f340:	e037883a 	mov	sp,fp
 821f344:	dfc00117 	ldw	ra,4(sp)
 821f348:	df000017 	ldw	fp,0(sp)
 821f34c:	dec00204 	addi	sp,sp,8
 821f350:	f800283a 	ret

0821f354 <tse_mac_aRxRead>:
  *        the actual bytes transferred for current descriptor
  */
alt_32 tse_mac_aRxRead( 
  tse_mac_trans_info *mi,       
  alt_sgdma_descriptor *rxDesc)  
{
 821f354:	defffa04 	addi	sp,sp,-24
 821f358:	dfc00515 	stw	ra,20(sp)
 821f35c:	df000415 	stw	fp,16(sp)
 821f360:	df000404 	addi	fp,sp,16
 821f364:	e13ffe15 	stw	r4,-8(fp)
 821f368:	e17fff15 	stw	r5,-4(fp)
  alt_32 timeout;
  
  alt_u8 result = 0;
 821f36c:	e03ffd05 	stb	zero,-12(fp)
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
 821f370:	e03ffc15 	stw	zero,-16(fp)
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 821f374:	00000b06 	br	821f3a4 <tse_mac_aRxRead+0x50>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 821f378:	e0fffc17 	ldw	r3,-16(fp)
 821f37c:	18800044 	addi	r2,r3,1
 821f380:	e0bffc15 	stw	r2,-16(fp)
 821f384:	008003f4 	movhi	r2,15
 821f388:	10909004 	addi	r2,r2,16960
 821f38c:	1880051e 	bne	r3,r2,821f3a4 <tse_mac_aRxRead+0x50>
        tse_dprintf(4, "WARNING : RX SGDMA Timeout\n");
 821f390:	01020974 	movhi	r4,2085
 821f394:	21380504 	addi	r4,r4,-8172
 821f398:	82036800 	call	8203680 <puts>
        return ENP_RESOURCE;  // avoid being stuck here
 821f39c:	00bffa84 	movi	r2,-22
 821f3a0:	00001106 	br	821f3e8 <tse_mac_aRxRead+0x94>
  alt_u8 result = 0;
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 821f3a4:	e0bffe17 	ldw	r2,-8(fp)
 821f3a8:	10800217 	ldw	r2,8(r2)
 821f3ac:	10800317 	ldw	r2,12(r2)
 821f3b0:	10800037 	ldwio	r2,0(r2)
 821f3b4:	1080040c 	andi	r2,r2,16
 821f3b8:	103fef1e 	bne	r2,zero,821f378 <tse_mac_aRxRead+0x24>
    }
  }

 
  // SGDMA operation invoked for RX (non-blocking call)
  result = alt_avalon_sgdma_do_async_transfer(
 821f3bc:	e0bffe17 	ldw	r2,-8(fp)
 821f3c0:	10800217 	ldw	r2,8(r2)
 821f3c4:	e17fff17 	ldw	r5,-4(fp)
 821f3c8:	1009883a 	mov	r4,r2
 821f3cc:	821e3940 	call	821e394 <alt_avalon_sgdma_do_async_transfer>
 821f3d0:	e0bffd05 	stb	r2,-12(fp)
                mi->rx_sgdma, 
                (alt_sgdma_descriptor *) &rxDesc[0]);
  
  if (result != 0)
 821f3d4:	e0bffd03 	ldbu	r2,-12(fp)
 821f3d8:	10000226 	beq	r2,zero,821f3e4 <tse_mac_aRxRead+0x90>
    return -1;
 821f3dc:	00bfffc4 	movi	r2,-1
 821f3e0:	00000106 	br	821f3e8 <tse_mac_aRxRead+0x94>
 
  return SUCCESS;
 821f3e4:	0005883a 	mov	r2,zero
}
 821f3e8:	e037883a 	mov	sp,fp
 821f3ec:	dfc00117 	ldw	ra,4(sp)
 821f3f0:	df000017 	ldw	fp,0(sp)
 821f3f4:	dec00204 	addi	sp,sp,8
 821f3f8:	f800283a 	ret

0821f3fc <tse_mac_SwReset>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_SwReset(np_tse_mac *pmac) 
{
 821f3fc:	defffc04 	addi	sp,sp,-16
 821f400:	df000315 	stw	fp,12(sp)
 821f404:	df000304 	addi	fp,sp,12
 821f408:	e13fff15 	stw	r4,-4(fp)
	alt_32 timeout;
	alt_32 cc;
        
    cc = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 821f40c:	e0bfff17 	ldw	r2,-4(fp)
 821f410:	10800204 	addi	r2,r2,8
 821f414:	10800037 	ldwio	r2,0(r2)
 821f418:	e0bffe15 	stw	r2,-8(fp)
    
    // set reset and Gig-Speed bits to make sure we have an incoming clock on
    // tx side. If there is a 10/100 PHY, we will still have a valid clock on
    // tx_clk no matter what setting we have here, but on a Gig phy the
    // MII clock may be missing.
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,(ALTERA_TSEMAC_CMD_SW_RESET_MSK | ALTERA_TSEMAC_CMD_ETH_SPEED_MSK));
 821f41c:	e0bfff17 	ldw	r2,-4(fp)
 821f420:	10800204 	addi	r2,r2,8
 821f424:	00c80204 	movi	r3,8200
 821f428:	10c00035 	stwio	r3,0(r2)

    
    // wait for completion with fallback in case there is no PHY or it is
    // not connected and hence might not provide any clocks at all.
    timeout=0;
 821f42c:	e03ffd15 	stw	zero,-12(fp)
    while( (IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac) & ALTERA_TSEMAC_CMD_SW_RESET_MSK) != 0 && timeout < ALTERA_TSE_SW_RESET_TIME_OUT_CNT) timeout++;
 821f430:	00000306 	br	821f440 <tse_mac_SwReset+0x44>
 821f434:	e0bffd17 	ldw	r2,-12(fp)
 821f438:	10800044 	addi	r2,r2,1
 821f43c:	e0bffd15 	stw	r2,-12(fp)
 821f440:	e0bfff17 	ldw	r2,-4(fp)
 821f444:	10800204 	addi	r2,r2,8
 821f448:	10800037 	ldwio	r2,0(r2)
 821f44c:	1088000c 	andi	r2,r2,8192
 821f450:	10000326 	beq	r2,zero,821f460 <tse_mac_SwReset+0x64>
 821f454:	e0bffd17 	ldw	r2,-12(fp)
 821f458:	1089c410 	cmplti	r2,r2,10000
 821f45c:	103ff51e 	bne	r2,zero,821f434 <tse_mac_SwReset+0x38>
   
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,cc); // Restore
 821f460:	e0bfff17 	ldw	r2,-4(fp)
 821f464:	10800204 	addi	r2,r2,8
 821f468:	e0fffe17 	ldw	r3,-8(fp)
 821f46c:	10c00035 	stwio	r3,0(r2)
    return SUCCESS;
 821f470:	0005883a 	mov	r2,zero
}
 821f474:	e037883a 	mov	sp,fp
 821f478:	df000017 	ldw	fp,0(sp)
 821f47c:	dec00104 	addi	sp,sp,4
 821f480:	f800283a 	ret

0821f484 <tse_mac_setMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_setMIImode(np_tse_mac *pmac)
{
 821f484:	defffd04 	addi	sp,sp,-12
 821f488:	df000215 	stw	fp,8(sp)
 821f48c:	df000204 	addi	fp,sp,8
 821f490:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 821f494:	e0bfff17 	ldw	r2,-4(fp)
 821f498:	10800204 	addi	r2,r2,8
 821f49c:	10800037 	ldwio	r2,0(r2)
 821f4a0:	e0bffe15 	stw	r2,-8(fp)
  helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK; 
 821f4a4:	e0fffe17 	ldw	r3,-8(fp)
 821f4a8:	00bffdc4 	movi	r2,-9
 821f4ac:	1884703a 	and	r2,r3,r2
 821f4b0:	e0bffe15 	stw	r2,-8(fp)
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 821f4b4:	e0bfff17 	ldw	r2,-4(fp)
 821f4b8:	10800204 	addi	r2,r2,8
 821f4bc:	e0fffe17 	ldw	r3,-8(fp)
 821f4c0:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 821f4c4:	0005883a 	mov	r2,zero
}
 821f4c8:	e037883a 	mov	sp,fp
 821f4cc:	df000017 	ldw	fp,0(sp)
 821f4d0:	dec00104 	addi	sp,sp,4
 821f4d4:	f800283a 	ret

0821f4d8 <tse_mac_setGMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
 */
alt_32 tse_mac_setGMIImode(np_tse_mac *pmac)
{
 821f4d8:	defffd04 	addi	sp,sp,-12
 821f4dc:	df000215 	stw	fp,8(sp)
 821f4e0:	df000204 	addi	fp,sp,8
 821f4e4:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 821f4e8:	e0bfff17 	ldw	r2,-4(fp)
 821f4ec:	10800204 	addi	r2,r2,8
 821f4f0:	10800037 	ldwio	r2,0(r2)
 821f4f4:	e0bffe15 	stw	r2,-8(fp)
  helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 821f4f8:	e0bffe17 	ldw	r2,-8(fp)
 821f4fc:	10800214 	ori	r2,r2,8
 821f500:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 821f504:	e0bfff17 	ldw	r2,-4(fp)
 821f508:	10800204 	addi	r2,r2,8
 821f50c:	e0fffe17 	ldw	r3,-8(fp)
 821f510:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 821f514:	0005883a 	mov	r2,zero
}
 821f518:	e037883a 	mov	sp,fp
 821f51c:	df000017 	ldw	fp,0(sp)
 821f520:	dec00104 	addi	sp,sp,4
 821f524:	f800283a 	ret

0821f528 <alt_tse_phy_add_profile>:
 * @param  phy  pointer to alt_tse_phy_profile structure describing PHY registers
 * @return      index of PHY added in PHY profile on success, else return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 * PHY which are currently supported by default :  Marvell 88E1111, Marvell Quad PHY 88E1145, National DP83865, and National DP83848C
 */
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
 821f528:	defffb04 	addi	sp,sp,-20
 821f52c:	dfc00415 	stw	ra,16(sp)
 821f530:	df000315 	stw	fp,12(sp)
 821f534:	dc000215 	stw	r16,8(sp)
 821f538:	df000304 	addi	fp,sp,12
 821f53c:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 821f540:	e03ffd15 	stw	zero,-12(fp)
 821f544:	00002906 	br	821f5ec <alt_tse_phy_add_profile+0xc4>
    {
        if(pphy_profiles[i]->oui == phy->oui && pphy_profiles[i]->model_number == phy->model_number)
 821f548:	008209b4 	movhi	r2,2086
 821f54c:	10b71c04 	addi	r2,r2,-9104
 821f550:	e0fffd17 	ldw	r3,-12(fp)
 821f554:	18c7883a 	add	r3,r3,r3
 821f558:	18c7883a 	add	r3,r3,r3
 821f55c:	10c5883a 	add	r2,r2,r3
 821f560:	10800017 	ldw	r2,0(r2)
 821f564:	10c01417 	ldw	r3,80(r2)
 821f568:	e0bffe17 	ldw	r2,-8(fp)
 821f56c:	10801417 	ldw	r2,80(r2)
 821f570:	18801b1e 	bne	r3,r2,821f5e0 <alt_tse_phy_add_profile+0xb8>
 821f574:	008209b4 	movhi	r2,2086
 821f578:	10b71c04 	addi	r2,r2,-9104
 821f57c:	e0fffd17 	ldw	r3,-12(fp)
 821f580:	18c7883a 	add	r3,r3,r3
 821f584:	18c7883a 	add	r3,r3,r3
 821f588:	10c5883a 	add	r2,r2,r3
 821f58c:	10800017 	ldw	r2,0(r2)
 821f590:	10c01503 	ldbu	r3,84(r2)
 821f594:	e0bffe17 	ldw	r2,-8(fp)
 821f598:	10801503 	ldbu	r2,84(r2)
 821f59c:	18c03fcc 	andi	r3,r3,255
 821f5a0:	10803fcc 	andi	r2,r2,255
 821f5a4:	18800e1e 	bne	r3,r2,821f5e0 <alt_tse_phy_add_profile+0xb8>
        {
            tse_dprintf(4, "WARNING : PHY OUI 0x%06x, PHY Model Number 0x%02x already exist in PHY profile\n", (int) phy->oui, phy->model_number);
 821f5a8:	e0bffe17 	ldw	r2,-8(fp)
 821f5ac:	10801417 	ldw	r2,80(r2)
 821f5b0:	1007883a 	mov	r3,r2
 821f5b4:	e0bffe17 	ldw	r2,-8(fp)
 821f5b8:	10801503 	ldbu	r2,84(r2)
 821f5bc:	10803fcc 	andi	r2,r2,255
 821f5c0:	100d883a 	mov	r6,r2
 821f5c4:	180b883a 	mov	r5,r3
 821f5c8:	01020974 	movhi	r4,2085
 821f5cc:	21380c04 	addi	r4,r4,-8144
 821f5d0:	82033fc0 	call	82033fc <printf>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
 821f5d4:	01020974 	movhi	r4,2085
 821f5d8:	21382004 	addi	r4,r4,-8064
 821f5dc:	82036800 	call	8203680 <puts>
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 821f5e0:	e0bffd17 	ldw	r2,-12(fp)
 821f5e4:	10800044 	addi	r2,r2,1
 821f5e8:	e0bffd15 	stw	r2,-12(fp)
 821f5ec:	d0a07f03 	ldbu	r2,-32260(gp)
 821f5f0:	10803fcc 	andi	r2,r2,255
 821f5f4:	e0fffd17 	ldw	r3,-12(fp)
 821f5f8:	18bfd316 	blt	r3,r2,821f548 <alt_tse_phy_add_profile+0x20>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
        }
    }

    /* Allocate memory space to store the profile */    
    pphy_profiles[phy_profile_count] = (alt_tse_phy_profile *) malloc(sizeof(alt_tse_phy_profile));
 821f5fc:	d0a07f03 	ldbu	r2,-32260(gp)
 821f600:	14003fcc 	andi	r16,r2,255
 821f604:	01001904 	movi	r4,100
 821f608:	824b6ec0 	call	824b6ec <malloc>
 821f60c:	1009883a 	mov	r4,r2
 821f610:	008209b4 	movhi	r2,2086
 821f614:	10b71c04 	addi	r2,r2,-9104
 821f618:	8407883a 	add	r3,r16,r16
 821f61c:	18c7883a 	add	r3,r3,r3
 821f620:	10c5883a 	add	r2,r2,r3
 821f624:	11000015 	stw	r4,0(r2)
    if(!pphy_profiles[phy_profile_count]) {
 821f628:	d0a07f03 	ldbu	r2,-32260(gp)
 821f62c:	10c03fcc 	andi	r3,r2,255
 821f630:	008209b4 	movhi	r2,2086
 821f634:	10b71c04 	addi	r2,r2,-9104
 821f638:	18c7883a 	add	r3,r3,r3
 821f63c:	18c7883a 	add	r3,r3,r3
 821f640:	10c5883a 	add	r2,r2,r3
 821f644:	10800017 	ldw	r2,0(r2)
 821f648:	1000081e 	bne	r2,zero,821f66c <alt_tse_phy_add_profile+0x144>
        tse_dprintf(1, "ERROR   : Unable to allocate memory for pphy_profile[%d]\n", phy_profile_count);
 821f64c:	d0a07f03 	ldbu	r2,-32260(gp)
 821f650:	10803fcc 	andi	r2,r2,255
 821f654:	100b883a 	mov	r5,r2
 821f658:	01020974 	movhi	r4,2085
 821f65c:	21383804 	addi	r4,r4,-7968
 821f660:	82033fc0 	call	82033fc <printf>
        return ALTERA_TSE_MALLOC_FAILED;
 821f664:	00bfffc4 	movi	r2,-1
 821f668:	00002206 	br	821f6f4 <alt_tse_phy_add_profile+0x1cc>
    }

    /* Store PHY information */
    *pphy_profiles[phy_profile_count] = *phy;
 821f66c:	d0a07f03 	ldbu	r2,-32260(gp)
 821f670:	10c03fcc 	andi	r3,r2,255
 821f674:	008209b4 	movhi	r2,2086
 821f678:	10b71c04 	addi	r2,r2,-9104
 821f67c:	18c7883a 	add	r3,r3,r3
 821f680:	18c7883a 	add	r3,r3,r3
 821f684:	10c5883a 	add	r2,r2,r3
 821f688:	10c00017 	ldw	r3,0(r2)
 821f68c:	e0bffe17 	ldw	r2,-8(fp)
 821f690:	1009883a 	mov	r4,r2
 821f694:	00801904 	movi	r2,100
 821f698:	100d883a 	mov	r6,r2
 821f69c:	200b883a 	mov	r5,r4
 821f6a0:	1809883a 	mov	r4,r3
 821f6a4:	8202f6c0 	call	8202f6c <memcpy>
    strcpy(pphy_profiles[phy_profile_count]->name, phy->name);
 821f6a8:	d0a07f03 	ldbu	r2,-32260(gp)
 821f6ac:	10c03fcc 	andi	r3,r2,255
 821f6b0:	008209b4 	movhi	r2,2086
 821f6b4:	10b71c04 	addi	r2,r2,-9104
 821f6b8:	18c7883a 	add	r3,r3,r3
 821f6bc:	18c7883a 	add	r3,r3,r3
 821f6c0:	10c5883a 	add	r2,r2,r3
 821f6c4:	10800017 	ldw	r2,0(r2)
 821f6c8:	1007883a 	mov	r3,r2
 821f6cc:	e0bffe17 	ldw	r2,-8(fp)
 821f6d0:	100b883a 	mov	r5,r2
 821f6d4:	1809883a 	mov	r4,r3
 821f6d8:	824b7140 	call	824b714 <strcpy>
    
    phy_profile_count++;
 821f6dc:	d0a07f03 	ldbu	r2,-32260(gp)
 821f6e0:	10800044 	addi	r2,r2,1
 821f6e4:	d0a07f05 	stb	r2,-32260(gp)
    
    return phy_profile_count - 1;
 821f6e8:	d0a07f03 	ldbu	r2,-32260(gp)
 821f6ec:	10803fcc 	andi	r2,r2,255
 821f6f0:	10bfffc4 	addi	r2,r2,-1
}
 821f6f4:	e6ffff04 	addi	sp,fp,-4
 821f6f8:	dfc00217 	ldw	ra,8(sp)
 821f6fc:	df000117 	ldw	fp,4(sp)
 821f700:	dc000017 	ldw	r16,0(sp)
 821f704:	dec00304 	addi	sp,sp,12
 821f708:	f800283a 	ret

0821f70c <alt_tse_system_add_sys>:
alt_32 alt_tse_system_add_sys(
	alt_tse_system_mac					*psys_mac,
	alt_tse_system_sgdma				*psys_sgdma,
	alt_tse_system_desc_mem				*psys_mem,
	alt_tse_system_shared_fifo			*psys_shared_fifo,
	alt_tse_system_phy 					*psys_phy ) {
 821f70c:	defff204 	addi	sp,sp,-56
 821f710:	dfc00d15 	stw	ra,52(sp)
 821f714:	df000c15 	stw	fp,48(sp)
 821f718:	dc000b15 	stw	r16,44(sp)
 821f71c:	df000c04 	addi	fp,sp,48
 821f720:	e13ffb15 	stw	r4,-20(fp)
 821f724:	e17ffc15 	stw	r5,-16(fp)
 821f728:	e1bffd15 	stw	r6,-12(fp)
 821f72c:	e1fffe15 	stw	r7,-8(fp)

	int i;
	int loop_end;
	
	alt_tse_system_mac					*pmac	= psys_mac;
 821f730:	e0bffb17 	ldw	r2,-20(fp)
 821f734:	e0bffa15 	stw	r2,-24(fp)
	alt_tse_system_sgdma				*psgdma	= psys_sgdma;
 821f738:	e0bffc17 	ldw	r2,-16(fp)
 821f73c:	e0bff615 	stw	r2,-40(fp)
	alt_tse_system_desc_mem				*pmem	= psys_mem;
 821f740:	e0bffd17 	ldw	r2,-12(fp)
 821f744:	e0bff715 	stw	r2,-36(fp)
	alt_tse_system_shared_fifo			*pfifo	= psys_shared_fifo;
 821f748:	e0bffe17 	ldw	r2,-8(fp)
 821f74c:	e0bff815 	stw	r2,-32(fp)
	alt_tse_system_phy 					*pphy	= psys_phy;
 821f750:	e0800217 	ldw	r2,8(fp)
 821f754:	e0bff915 	stw	r2,-28(fp)
	
	static alt_8 tse_system_count = 0;
	
	/* Determine number of loop */
	/* Run at least one for non-multi-channel MAC */
	if(pmac->tse_num_of_channel == 0) {
 821f758:	e0bffa17 	ldw	r2,-24(fp)
 821f75c:	10800303 	ldbu	r2,12(r2)
 821f760:	10803fcc 	andi	r2,r2,255
 821f764:	1000031e 	bne	r2,zero,821f774 <alt_tse_system_add_sys+0x68>
		loop_end = 1;
 821f768:	00800044 	movi	r2,1
 821f76c:	e0bff515 	stw	r2,-44(fp)
 821f770:	00000e06 	br	821f7ac <alt_tse_system_add_sys+0xa0>
	}
	else if(pmac->tse_num_of_channel > 0) {
 821f774:	e0bffa17 	ldw	r2,-24(fp)
 821f778:	10800303 	ldbu	r2,12(r2)
 821f77c:	10803fcc 	andi	r2,r2,255
 821f780:	10000526 	beq	r2,zero,821f798 <alt_tse_system_add_sys+0x8c>
		loop_end = pmac->tse_num_of_channel; 
 821f784:	e0bffa17 	ldw	r2,-24(fp)
 821f788:	10800303 	ldbu	r2,12(r2)
 821f78c:	10803fcc 	andi	r2,r2,255
 821f790:	e0bff515 	stw	r2,-44(fp)
 821f794:	00000506 	br	821f7ac <alt_tse_system_add_sys+0xa0>
	}
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
 821f798:	01020974 	movhi	r4,2085
 821f79c:	21384704 	addi	r4,r4,-7908
 821f7a0:	82036800 	call	8203680 <puts>
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
 821f7a4:	00bfffc4 	movi	r2,-1
 821f7a8:	00025106 	br	82200f0 <alt_tse_system_add_sys+0x9e4>
	}

	for(i = 0; i < loop_end; i++) {
 821f7ac:	e03ff415 	stw	zero,-48(fp)
 821f7b0:	00024b06 	br	82200e0 <alt_tse_system_add_sys+0x9d4>
		
		/* Make sure the boundary of array is not exceeded */
		if(tse_system_count >= MAXNETS) {
 821f7b4:	d0a07f83 	ldbu	r2,-32258(gp)
 821f7b8:	10803fcc 	andi	r2,r2,255
 821f7bc:	1080201c 	xori	r2,r2,128
 821f7c0:	10bfe004 	addi	r2,r2,-128
 821f7c4:	10800110 	cmplti	r2,r2,4
 821f7c8:	10000c1e 	bne	r2,zero,821f7fc <alt_tse_system_add_sys+0xf0>
			tse_dprintf(2, "ERROR   : Number of TSE System added exceed the size of array!\n");
 821f7cc:	01020974 	movhi	r4,2085
 821f7d0:	21385304 	addi	r4,r4,-7860
 821f7d4:	82036800 	call	8203680 <puts>
			tse_dprintf(2, "ERROR   : Size of array = %d, Number of TSE System = %d\n", MAXNETS, tse_system_count);
 821f7d8:	d0a07f83 	ldbu	r2,-32258(gp)
 821f7dc:	10803fcc 	andi	r2,r2,255
 821f7e0:	1080201c 	xori	r2,r2,128
 821f7e4:	10bfe004 	addi	r2,r2,-128
 821f7e8:	100d883a 	mov	r6,r2
 821f7ec:	01400104 	movi	r5,4
 821f7f0:	01020974 	movhi	r4,2085
 821f7f4:	21386304 	addi	r4,r4,-7796
 821f7f8:	82033fc0 	call	82033fc <printf>
		}

		/* Add MAC info to alt_tse_system_info structure */
		if(pmac == 0) {
 821f7fc:	e0bffa17 	ldw	r2,-24(fp)
 821f800:	1000081e 	bne	r2,zero,821f824 <alt_tse_system_add_sys+0x118>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 821f804:	01020974 	movhi	r4,2085
 821f808:	21387204 	addi	r4,r4,-7736
 821f80c:	82036800 	call	8203680 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys()\n");
 821f810:	01020974 	movhi	r4,2085
 821f814:	21387c04 	addi	r4,r4,-7696
 821f818:	82036800 	call	8203680 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 821f81c:	00bfffc4 	movi	r2,-1
 821f820:	00023306 	br	82200f0 <alt_tse_system_add_sys+0x9e4>
		}		
		
		tse_mac_device[tse_system_count].tse_mac_base 					= pmac->tse_mac_base + (i * 0x400);
 821f824:	d0a07f83 	ldbu	r2,-32258(gp)
 821f828:	11003fcc 	andi	r4,r2,255
 821f82c:	2100201c 	xori	r4,r4,128
 821f830:	213fe004 	addi	r4,r4,-128
 821f834:	e0bffa17 	ldw	r2,-24(fp)
 821f838:	10800017 	ldw	r2,0(r2)
 821f83c:	e0fff417 	ldw	r3,-48(fp)
 821f840:	180692ba 	slli	r3,r3,10
 821f844:	10c7883a 	add	r3,r2,r3
 821f848:	00820974 	movhi	r2,2085
 821f84c:	1087da04 	addi	r2,r2,8040
 821f850:	21001224 	muli	r4,r4,72
 821f854:	1105883a 	add	r2,r2,r4
 821f858:	10c00015 	stw	r3,0(r2)
		tse_mac_device[tse_system_count].tse_tx_depth 					= pmac->tse_tx_depth;
 821f85c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f860:	11003fcc 	andi	r4,r2,255
 821f864:	2100201c 	xori	r4,r4,128
 821f868:	213fe004 	addi	r4,r4,-128
 821f86c:	e0bffa17 	ldw	r2,-24(fp)
 821f870:	10c0010b 	ldhu	r3,4(r2)
 821f874:	00820974 	movhi	r2,2085
 821f878:	1087da04 	addi	r2,r2,8040
 821f87c:	21001224 	muli	r4,r4,72
 821f880:	1105883a 	add	r2,r2,r4
 821f884:	10800104 	addi	r2,r2,4
 821f888:	10c0000d 	sth	r3,0(r2)
		tse_mac_device[tse_system_count].tse_rx_depth 					= pmac->tse_rx_depth;
 821f88c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f890:	11003fcc 	andi	r4,r2,255
 821f894:	2100201c 	xori	r4,r4,128
 821f898:	213fe004 	addi	r4,r4,-128
 821f89c:	e0bffa17 	ldw	r2,-24(fp)
 821f8a0:	10c0018b 	ldhu	r3,6(r2)
 821f8a4:	00820974 	movhi	r2,2085
 821f8a8:	1087da04 	addi	r2,r2,8040
 821f8ac:	21001224 	muli	r4,r4,72
 821f8b0:	1105883a 	add	r2,r2,r4
 821f8b4:	10800184 	addi	r2,r2,6
 821f8b8:	10c0000d 	sth	r3,0(r2)
		tse_mac_device[tse_system_count].tse_use_mdio 					= pmac->tse_use_mdio;
 821f8bc:	d0a07f83 	ldbu	r2,-32258(gp)
 821f8c0:	11003fcc 	andi	r4,r2,255
 821f8c4:	2100201c 	xori	r4,r4,128
 821f8c8:	213fe004 	addi	r4,r4,-128
 821f8cc:	e0bffa17 	ldw	r2,-24(fp)
 821f8d0:	10c00203 	ldbu	r3,8(r2)
 821f8d4:	00820974 	movhi	r2,2085
 821f8d8:	1087da04 	addi	r2,r2,8040
 821f8dc:	21001224 	muli	r4,r4,72
 821f8e0:	1105883a 	add	r2,r2,r4
 821f8e4:	10800204 	addi	r2,r2,8
 821f8e8:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_en_maclite 				= pmac->tse_en_maclite;
 821f8ec:	d0a07f83 	ldbu	r2,-32258(gp)
 821f8f0:	11003fcc 	andi	r4,r2,255
 821f8f4:	2100201c 	xori	r4,r4,128
 821f8f8:	213fe004 	addi	r4,r4,-128
 821f8fc:	e0bffa17 	ldw	r2,-24(fp)
 821f900:	10c00243 	ldbu	r3,9(r2)
 821f904:	00820974 	movhi	r2,2085
 821f908:	1087da04 	addi	r2,r2,8040
 821f90c:	21001224 	muli	r4,r4,72
 821f910:	1105883a 	add	r2,r2,r4
 821f914:	10800244 	addi	r2,r2,9
 821f918:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_maclite_gige 				= pmac->tse_maclite_gige;
 821f91c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f920:	11003fcc 	andi	r4,r2,255
 821f924:	2100201c 	xori	r4,r4,128
 821f928:	213fe004 	addi	r4,r4,-128
 821f92c:	e0bffa17 	ldw	r2,-24(fp)
 821f930:	10c00283 	ldbu	r3,10(r2)
 821f934:	00820974 	movhi	r2,2085
 821f938:	1087da04 	addi	r2,r2,8040
 821f93c:	21001224 	muli	r4,r4,72
 821f940:	1105883a 	add	r2,r2,r4
 821f944:	10800284 	addi	r2,r2,10
 821f948:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_multichannel_mac 			= pmac->tse_multichannel_mac;
 821f94c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f950:	11003fcc 	andi	r4,r2,255
 821f954:	2100201c 	xori	r4,r4,128
 821f958:	213fe004 	addi	r4,r4,-128
 821f95c:	e0bffa17 	ldw	r2,-24(fp)
 821f960:	10c002c3 	ldbu	r3,11(r2)
 821f964:	00820974 	movhi	r2,2085
 821f968:	1087da04 	addi	r2,r2,8040
 821f96c:	21001224 	muli	r4,r4,72
 821f970:	1105883a 	add	r2,r2,r4
 821f974:	108002c4 	addi	r2,r2,11
 821f978:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_num_of_channel 			= pmac->tse_num_of_channel;
 821f97c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f980:	11003fcc 	andi	r4,r2,255
 821f984:	2100201c 	xori	r4,r4,128
 821f988:	213fe004 	addi	r4,r4,-128
 821f98c:	e0bffa17 	ldw	r2,-24(fp)
 821f990:	10c00303 	ldbu	r3,12(r2)
 821f994:	00820974 	movhi	r2,2085
 821f998:	1087da04 	addi	r2,r2,8040
 821f99c:	21001224 	muli	r4,r4,72
 821f9a0:	1105883a 	add	r2,r2,r4
 821f9a4:	10800304 	addi	r2,r2,12
 821f9a8:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_mdio_shared 				= pmac->tse_mdio_shared;
 821f9ac:	d0a07f83 	ldbu	r2,-32258(gp)
 821f9b0:	11003fcc 	andi	r4,r2,255
 821f9b4:	2100201c 	xori	r4,r4,128
 821f9b8:	213fe004 	addi	r4,r4,-128
 821f9bc:	e0bffa17 	ldw	r2,-24(fp)
 821f9c0:	10c00343 	ldbu	r3,13(r2)
 821f9c4:	00820974 	movhi	r2,2085
 821f9c8:	1087da04 	addi	r2,r2,8040
 821f9cc:	21001224 	muli	r4,r4,72
 821f9d0:	1105883a 	add	r2,r2,r4
 821f9d4:	10800344 	addi	r2,r2,13
 821f9d8:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_number_of_mac_mdio_shared	= pmac->tse_number_of_mac_mdio_shared;
 821f9dc:	d0a07f83 	ldbu	r2,-32258(gp)
 821f9e0:	11003fcc 	andi	r4,r2,255
 821f9e4:	2100201c 	xori	r4,r4,128
 821f9e8:	213fe004 	addi	r4,r4,-128
 821f9ec:	e0bffa17 	ldw	r2,-24(fp)
 821f9f0:	10c00383 	ldbu	r3,14(r2)
 821f9f4:	00820974 	movhi	r2,2085
 821f9f8:	1087da04 	addi	r2,r2,8040
 821f9fc:	21001224 	muli	r4,r4,72
 821fa00:	1105883a 	add	r2,r2,r4
 821fa04:	10800384 	addi	r2,r2,14
 821fa08:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_pcs_ena 					= pmac->tse_pcs_ena;
 821fa0c:	d0a07f83 	ldbu	r2,-32258(gp)
 821fa10:	11003fcc 	andi	r4,r2,255
 821fa14:	2100201c 	xori	r4,r4,128
 821fa18:	213fe004 	addi	r4,r4,-128
 821fa1c:	e0bffa17 	ldw	r2,-24(fp)
 821fa20:	10c003c3 	ldbu	r3,15(r2)
 821fa24:	00820974 	movhi	r2,2085
 821fa28:	1087da04 	addi	r2,r2,8040
 821fa2c:	21001224 	muli	r4,r4,72
 821fa30:	1105883a 	add	r2,r2,r4
 821fa34:	108003c4 	addi	r2,r2,15
 821fa38:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_pcs_sgmii 					= pmac->tse_pcs_sgmii;
 821fa3c:	d0a07f83 	ldbu	r2,-32258(gp)
 821fa40:	11003fcc 	andi	r4,r2,255
 821fa44:	2100201c 	xori	r4,r4,128
 821fa48:	213fe004 	addi	r4,r4,-128
 821fa4c:	e0bffa17 	ldw	r2,-24(fp)
 821fa50:	10c00403 	ldbu	r3,16(r2)
 821fa54:	00820974 	movhi	r2,2085
 821fa58:	1087da04 	addi	r2,r2,8040
 821fa5c:	21001224 	muli	r4,r4,72
 821fa60:	1105883a 	add	r2,r2,r4
 821fa64:	10800404 	addi	r2,r2,16
 821fa68:	10c00005 	stb	r3,0(r2)
		
		/* Add SGDMA info to alt_tse_system_info structure */
		if(psgdma == 0) {
 821fa6c:	e0bff617 	ldw	r2,-40(fp)
 821fa70:	10000d1e 	bne	r2,zero,821faa8 <alt_tse_system_add_sys+0x39c>
			tse_dprintf(2, "ERROR   : SGDMA system structure == NULL\n");
 821fa74:	01020974 	movhi	r4,2085
 821fa78:	21388e04 	addi	r4,r4,-7624
 821fa7c:	82036800 	call	8203680 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys() for tse_mac_device[%d]\n", tse_system_count);
 821fa80:	d0a07f83 	ldbu	r2,-32258(gp)
 821fa84:	10803fcc 	andi	r2,r2,255
 821fa88:	1080201c 	xori	r2,r2,128
 821fa8c:	10bfe004 	addi	r2,r2,-128
 821fa90:	100b883a 	mov	r5,r2
 821fa94:	01020974 	movhi	r4,2085
 821fa98:	21389904 	addi	r4,r4,-7580
 821fa9c:	82033fc0 	call	82033fc <printf>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 821faa0:	00bfffc4 	movi	r2,-1
 821faa4:	00019206 	br	82200f0 <alt_tse_system_add_sys+0x9e4>
		}
		
		tse_mac_device[tse_system_count].tse_sgdma_tx = (char *) malloc(strlen(psgdma->tse_sgdma_tx) + 1);
 821faa8:	d0a07f83 	ldbu	r2,-32258(gp)
 821faac:	14003fcc 	andi	r16,r2,255
 821fab0:	8400201c 	xori	r16,r16,128
 821fab4:	843fe004 	addi	r16,r16,-128
 821fab8:	e0bff617 	ldw	r2,-40(fp)
 821fabc:	10800017 	ldw	r2,0(r2)
 821fac0:	1009883a 	mov	r4,r2
 821fac4:	8203fbc0 	call	8203fbc <strlen>
 821fac8:	10800044 	addi	r2,r2,1
 821facc:	1009883a 	mov	r4,r2
 821fad0:	824b6ec0 	call	824b6ec <malloc>
 821fad4:	1009883a 	mov	r4,r2
 821fad8:	00820974 	movhi	r2,2085
 821fadc:	1087da04 	addi	r2,r2,8040
 821fae0:	80c01224 	muli	r3,r16,72
 821fae4:	10c5883a 	add	r2,r2,r3
 821fae8:	10800504 	addi	r2,r2,20
 821faec:	11000015 	stw	r4,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_tx) {
 821faf0:	d0a07f83 	ldbu	r2,-32258(gp)
 821faf4:	10c03fcc 	andi	r3,r2,255
 821faf8:	18c0201c 	xori	r3,r3,128
 821fafc:	18ffe004 	addi	r3,r3,-128
 821fb00:	00820974 	movhi	r2,2085
 821fb04:	1087da04 	addi	r2,r2,8040
 821fb08:	18c01224 	muli	r3,r3,72
 821fb0c:	10c5883a 	add	r2,r2,r3
 821fb10:	10800504 	addi	r2,r2,20
 821fb14:	10800017 	ldw	r2,0(r2)
 821fb18:	10000a1e 	bne	r2,zero,821fb44 <alt_tse_system_add_sys+0x438>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_tx\n", tse_system_count);
 821fb1c:	d0a07f83 	ldbu	r2,-32258(gp)
 821fb20:	10803fcc 	andi	r2,r2,255
 821fb24:	1080201c 	xori	r2,r2,128
 821fb28:	10bfe004 	addi	r2,r2,-128
 821fb2c:	100b883a 	mov	r5,r2
 821fb30:	01020974 	movhi	r4,2085
 821fb34:	2138b104 	addi	r4,r4,-7484
 821fb38:	82033fc0 	call	82033fc <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 821fb3c:	00bfffc4 	movi	r2,-1
 821fb40:	00016b06 	br	82200f0 <alt_tse_system_add_sys+0x9e4>
	    }   
		strcpy(tse_mac_device[tse_system_count].tse_sgdma_tx, psgdma->tse_sgdma_tx);
 821fb44:	d0a07f83 	ldbu	r2,-32258(gp)
 821fb48:	10c03fcc 	andi	r3,r2,255
 821fb4c:	18c0201c 	xori	r3,r3,128
 821fb50:	18ffe004 	addi	r3,r3,-128
 821fb54:	00820974 	movhi	r2,2085
 821fb58:	1087da04 	addi	r2,r2,8040
 821fb5c:	18c01224 	muli	r3,r3,72
 821fb60:	10c5883a 	add	r2,r2,r3
 821fb64:	10800504 	addi	r2,r2,20
 821fb68:	10c00017 	ldw	r3,0(r2)
 821fb6c:	e0bff617 	ldw	r2,-40(fp)
 821fb70:	10800017 	ldw	r2,0(r2)
 821fb74:	100b883a 	mov	r5,r2
 821fb78:	1809883a 	mov	r4,r3
 821fb7c:	824b7140 	call	824b714 <strcpy>
		
		tse_mac_device[tse_system_count].tse_sgdma_rx = (char *) malloc(strlen(psgdma->tse_sgdma_rx) + 1);
 821fb80:	d0a07f83 	ldbu	r2,-32258(gp)
 821fb84:	14003fcc 	andi	r16,r2,255
 821fb88:	8400201c 	xori	r16,r16,128
 821fb8c:	843fe004 	addi	r16,r16,-128
 821fb90:	e0bff617 	ldw	r2,-40(fp)
 821fb94:	10800117 	ldw	r2,4(r2)
 821fb98:	1009883a 	mov	r4,r2
 821fb9c:	8203fbc0 	call	8203fbc <strlen>
 821fba0:	10800044 	addi	r2,r2,1
 821fba4:	1009883a 	mov	r4,r2
 821fba8:	824b6ec0 	call	824b6ec <malloc>
 821fbac:	1009883a 	mov	r4,r2
 821fbb0:	00820974 	movhi	r2,2085
 821fbb4:	1087da04 	addi	r2,r2,8040
 821fbb8:	80c01224 	muli	r3,r16,72
 821fbbc:	10c5883a 	add	r2,r2,r3
 821fbc0:	10800604 	addi	r2,r2,24
 821fbc4:	11000015 	stw	r4,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_rx) {
 821fbc8:	d0a07f83 	ldbu	r2,-32258(gp)
 821fbcc:	10c03fcc 	andi	r3,r2,255
 821fbd0:	18c0201c 	xori	r3,r3,128
 821fbd4:	18ffe004 	addi	r3,r3,-128
 821fbd8:	00820974 	movhi	r2,2085
 821fbdc:	1087da04 	addi	r2,r2,8040
 821fbe0:	18c01224 	muli	r3,r3,72
 821fbe4:	10c5883a 	add	r2,r2,r3
 821fbe8:	10800604 	addi	r2,r2,24
 821fbec:	10800017 	ldw	r2,0(r2)
 821fbf0:	10000a1e 	bne	r2,zero,821fc1c <alt_tse_system_add_sys+0x510>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_rx\n", tse_system_count);
 821fbf4:	d0a07f83 	ldbu	r2,-32258(gp)
 821fbf8:	10803fcc 	andi	r2,r2,255
 821fbfc:	1080201c 	xori	r2,r2,128
 821fc00:	10bfe004 	addi	r2,r2,-128
 821fc04:	100b883a 	mov	r5,r2
 821fc08:	01020974 	movhi	r4,2085
 821fc0c:	2138c404 	addi	r4,r4,-7408
 821fc10:	82033fc0 	call	82033fc <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 821fc14:	00bfffc4 	movi	r2,-1
 821fc18:	00013506 	br	82200f0 <alt_tse_system_add_sys+0x9e4>
	    }
	    strcpy(tse_mac_device[tse_system_count].tse_sgdma_rx, psgdma->tse_sgdma_rx);
 821fc1c:	d0a07f83 	ldbu	r2,-32258(gp)
 821fc20:	10c03fcc 	andi	r3,r2,255
 821fc24:	18c0201c 	xori	r3,r3,128
 821fc28:	18ffe004 	addi	r3,r3,-128
 821fc2c:	00820974 	movhi	r2,2085
 821fc30:	1087da04 	addi	r2,r2,8040
 821fc34:	18c01224 	muli	r3,r3,72
 821fc38:	10c5883a 	add	r2,r2,r3
 821fc3c:	10800604 	addi	r2,r2,24
 821fc40:	10c00017 	ldw	r3,0(r2)
 821fc44:	e0bff617 	ldw	r2,-40(fp)
 821fc48:	10800117 	ldw	r2,4(r2)
 821fc4c:	100b883a 	mov	r5,r2
 821fc50:	1809883a 	mov	r4,r3
 821fc54:	824b7140 	call	824b714 <strcpy>
	    
		tse_mac_device[tse_system_count].tse_sgdma_rx_irq = psgdma->tse_sgdma_rx_irq;
 821fc58:	d0a07f83 	ldbu	r2,-32258(gp)
 821fc5c:	11003fcc 	andi	r4,r2,255
 821fc60:	2100201c 	xori	r4,r4,128
 821fc64:	213fe004 	addi	r4,r4,-128
 821fc68:	e0bff617 	ldw	r2,-40(fp)
 821fc6c:	10c0020b 	ldhu	r3,8(r2)
 821fc70:	00820974 	movhi	r2,2085
 821fc74:	1087da04 	addi	r2,r2,8040
 821fc78:	21001224 	muli	r4,r4,72
 821fc7c:	1105883a 	add	r2,r2,r4
 821fc80:	10800704 	addi	r2,r2,28
 821fc84:	10c0000d 	sth	r3,0(r2)
		
		/* Add descriptor memory info to alt_tse_system_info structure */
		if(pmem == 0) {
 821fc88:	e0bff717 	ldw	r2,-36(fp)
 821fc8c:	1000151e 	bne	r2,zero,821fce4 <alt_tse_system_add_sys+0x5d8>
			tse_mac_device[tse_system_count].ext_desc_mem	= TSE_INT_DESC_MEM;
 821fc90:	d0a07f83 	ldbu	r2,-32258(gp)
 821fc94:	10c03fcc 	andi	r3,r2,255
 821fc98:	18c0201c 	xori	r3,r3,128
 821fc9c:	18ffe004 	addi	r3,r3,-128
 821fca0:	00820974 	movhi	r2,2085
 821fca4:	1087da04 	addi	r2,r2,8040
 821fca8:	18c01224 	muli	r3,r3,72
 821fcac:	10c5883a 	add	r2,r2,r3
 821fcb0:	10800784 	addi	r2,r2,30
 821fcb4:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= TSE_INT_DESC_MEM;
 821fcb8:	d0a07f83 	ldbu	r2,-32258(gp)
 821fcbc:	10c03fcc 	andi	r3,r2,255
 821fcc0:	18c0201c 	xori	r3,r3,128
 821fcc4:	18ffe004 	addi	r3,r3,-128
 821fcc8:	00820974 	movhi	r2,2085
 821fccc:	1087da04 	addi	r2,r2,8040
 821fcd0:	18c01224 	muli	r3,r3,72
 821fcd4:	10c5883a 	add	r2,r2,r3
 821fcd8:	10800804 	addi	r2,r2,32
 821fcdc:	10000015 	stw	zero,0(r2)
 821fce0:	00001806 	br	821fd44 <alt_tse_system_add_sys+0x638>
		}
		else {
			tse_mac_device[tse_system_count].ext_desc_mem	= pmem->ext_desc_mem;
 821fce4:	d0a07f83 	ldbu	r2,-32258(gp)
 821fce8:	11003fcc 	andi	r4,r2,255
 821fcec:	2100201c 	xori	r4,r4,128
 821fcf0:	213fe004 	addi	r4,r4,-128
 821fcf4:	e0bff717 	ldw	r2,-36(fp)
 821fcf8:	10c00003 	ldbu	r3,0(r2)
 821fcfc:	00820974 	movhi	r2,2085
 821fd00:	1087da04 	addi	r2,r2,8040
 821fd04:	21001224 	muli	r4,r4,72
 821fd08:	1105883a 	add	r2,r2,r4
 821fd0c:	10800784 	addi	r2,r2,30
 821fd10:	10c00005 	stb	r3,0(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= pmem->desc_mem_base;
 821fd14:	d0a07f83 	ldbu	r2,-32258(gp)
 821fd18:	11003fcc 	andi	r4,r2,255
 821fd1c:	2100201c 	xori	r4,r4,128
 821fd20:	213fe004 	addi	r4,r4,-128
 821fd24:	e0bff717 	ldw	r2,-36(fp)
 821fd28:	10c00117 	ldw	r3,4(r2)
 821fd2c:	00820974 	movhi	r2,2085
 821fd30:	1087da04 	addi	r2,r2,8040
 821fd34:	21001224 	muli	r4,r4,72
 821fd38:	1105883a 	add	r2,r2,r4
 821fd3c:	10800804 	addi	r2,r2,32
 821fd40:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add shared fifo info to alt_tse_system_info structure */
		if(pfifo == 0) {
 821fd44:	e0bff817 	ldw	r2,-32(fp)
 821fd48:	1000471e 	bne	r2,zero,821fe68 <alt_tse_system_add_sys+0x75c>
			tse_mac_device[tse_system_count].use_shared_fifo                = TSE_NO_SHARED_FIFO;
 821fd4c:	d0a07f83 	ldbu	r2,-32258(gp)
 821fd50:	10c03fcc 	andi	r3,r2,255
 821fd54:	18c0201c 	xori	r3,r3,128
 821fd58:	18ffe004 	addi	r3,r3,-128
 821fd5c:	00820974 	movhi	r2,2085
 821fd60:	1087da04 	addi	r2,r2,8040
 821fd64:	18c01224 	muli	r3,r3,72
 821fd68:	10c5883a 	add	r2,r2,r3
 821fd6c:	10800904 	addi	r2,r2,36
 821fd70:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= TSE_NO_SHARED_FIFO;
 821fd74:	d0a07f83 	ldbu	r2,-32258(gp)
 821fd78:	10c03fcc 	andi	r3,r2,255
 821fd7c:	18c0201c 	xori	r3,r3,128
 821fd80:	18ffe004 	addi	r3,r3,-128
 821fd84:	00820974 	movhi	r2,2085
 821fd88:	1087da04 	addi	r2,r2,8040
 821fd8c:	18c01224 	muli	r3,r3,72
 821fd90:	10c5883a 	add	r2,r2,r3
 821fd94:	10800a04 	addi	r2,r2,40
 821fd98:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= TSE_NO_SHARED_FIFO;
 821fd9c:	d0a07f83 	ldbu	r2,-32258(gp)
 821fda0:	10c03fcc 	andi	r3,r2,255
 821fda4:	18c0201c 	xori	r3,r3,128
 821fda8:	18ffe004 	addi	r3,r3,-128
 821fdac:	00820974 	movhi	r2,2085
 821fdb0:	1087da04 	addi	r2,r2,8040
 821fdb4:	18c01224 	muli	r3,r3,72
 821fdb8:	10c5883a 	add	r2,r2,r3
 821fdbc:	10800b04 	addi	r2,r2,44
 821fdc0:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = TSE_NO_SHARED_FIFO;
 821fdc4:	d0a07f83 	ldbu	r2,-32258(gp)
 821fdc8:	10c03fcc 	andi	r3,r2,255
 821fdcc:	18c0201c 	xori	r3,r3,128
 821fdd0:	18ffe004 	addi	r3,r3,-128
 821fdd4:	00820974 	movhi	r2,2085
 821fdd8:	1087da04 	addi	r2,r2,8040
 821fddc:	18c01224 	muli	r3,r3,72
 821fde0:	10c5883a 	add	r2,r2,r3
 821fde4:	10800c04 	addi	r2,r2,48
 821fde8:	10000015 	stw	zero,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= TSE_NO_SHARED_FIFO;
 821fdec:	d0a07f83 	ldbu	r2,-32258(gp)
 821fdf0:	10c03fcc 	andi	r3,r2,255
 821fdf4:	18c0201c 	xori	r3,r3,128
 821fdf8:	18ffe004 	addi	r3,r3,-128
 821fdfc:	00820974 	movhi	r2,2085
 821fe00:	1087da04 	addi	r2,r2,8040
 821fe04:	18c01224 	muli	r3,r3,72
 821fe08:	10c5883a 	add	r2,r2,r3
 821fe0c:	10800d04 	addi	r2,r2,52
 821fe10:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= TSE_NO_SHARED_FIFO;
 821fe14:	d0a07f83 	ldbu	r2,-32258(gp)
 821fe18:	10c03fcc 	andi	r3,r2,255
 821fe1c:	18c0201c 	xori	r3,r3,128
 821fe20:	18ffe004 	addi	r3,r3,-128
 821fe24:	00820974 	movhi	r2,2085
 821fe28:	1087da04 	addi	r2,r2,8040
 821fe2c:	18c01224 	muli	r3,r3,72
 821fe30:	10c5883a 	add	r2,r2,r3
 821fe34:	10800e04 	addi	r2,r2,56
 821fe38:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = TSE_NO_SHARED_FIFO;
 821fe3c:	d0a07f83 	ldbu	r2,-32258(gp)
 821fe40:	10c03fcc 	andi	r3,r2,255
 821fe44:	18c0201c 	xori	r3,r3,128
 821fe48:	18ffe004 	addi	r3,r3,-128
 821fe4c:	00820974 	movhi	r2,2085
 821fe50:	1087da04 	addi	r2,r2,8040
 821fe54:	18c01224 	muli	r3,r3,72
 821fe58:	10c5883a 	add	r2,r2,r3
 821fe5c:	10800f04 	addi	r2,r2,60
 821fe60:	10000015 	stw	zero,0(r2)
 821fe64:	00005406 	br	821ffb8 <alt_tse_system_add_sys+0x8ac>
		}
		else {
			tse_mac_device[tse_system_count].use_shared_fifo                = pfifo->use_shared_fifo;
 821fe68:	d0a07f83 	ldbu	r2,-32258(gp)
 821fe6c:	11003fcc 	andi	r4,r2,255
 821fe70:	2100201c 	xori	r4,r4,128
 821fe74:	213fe004 	addi	r4,r4,-128
 821fe78:	e0bff817 	ldw	r2,-32(fp)
 821fe7c:	10c00003 	ldbu	r3,0(r2)
 821fe80:	00820974 	movhi	r2,2085
 821fe84:	1087da04 	addi	r2,r2,8040
 821fe88:	21001224 	muli	r4,r4,72
 821fe8c:	1105883a 	add	r2,r2,r4
 821fe90:	10800904 	addi	r2,r2,36
 821fe94:	10c00005 	stb	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= pfifo->tse_shared_fifo_tx_ctrl_base;
 821fe98:	d0a07f83 	ldbu	r2,-32258(gp)
 821fe9c:	11003fcc 	andi	r4,r2,255
 821fea0:	2100201c 	xori	r4,r4,128
 821fea4:	213fe004 	addi	r4,r4,-128
 821fea8:	e0bff817 	ldw	r2,-32(fp)
 821feac:	10c00117 	ldw	r3,4(r2)
 821feb0:	00820974 	movhi	r2,2085
 821feb4:	1087da04 	addi	r2,r2,8040
 821feb8:	21001224 	muli	r4,r4,72
 821febc:	1105883a 	add	r2,r2,r4
 821fec0:	10800a04 	addi	r2,r2,40
 821fec4:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= pfifo->tse_shared_fifo_tx_stat_base;
 821fec8:	d0a07f83 	ldbu	r2,-32258(gp)
 821fecc:	11003fcc 	andi	r4,r2,255
 821fed0:	2100201c 	xori	r4,r4,128
 821fed4:	213fe004 	addi	r4,r4,-128
 821fed8:	e0bff817 	ldw	r2,-32(fp)
 821fedc:	10c00217 	ldw	r3,8(r2)
 821fee0:	00820974 	movhi	r2,2085
 821fee4:	1087da04 	addi	r2,r2,8040
 821fee8:	21001224 	muli	r4,r4,72
 821feec:	1105883a 	add	r2,r2,r4
 821fef0:	10800b04 	addi	r2,r2,44
 821fef4:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = pfifo->tse_shared_fifo_tx_depth;
 821fef8:	d0a07f83 	ldbu	r2,-32258(gp)
 821fefc:	11003fcc 	andi	r4,r2,255
 821ff00:	2100201c 	xori	r4,r4,128
 821ff04:	213fe004 	addi	r4,r4,-128
 821ff08:	e0bff817 	ldw	r2,-32(fp)
 821ff0c:	10c00317 	ldw	r3,12(r2)
 821ff10:	00820974 	movhi	r2,2085
 821ff14:	1087da04 	addi	r2,r2,8040
 821ff18:	21001224 	muli	r4,r4,72
 821ff1c:	1105883a 	add	r2,r2,r4
 821ff20:	10800c04 	addi	r2,r2,48
 821ff24:	10c00015 	stw	r3,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= pfifo->tse_shared_fifo_rx_ctrl_base;
 821ff28:	d0a07f83 	ldbu	r2,-32258(gp)
 821ff2c:	11003fcc 	andi	r4,r2,255
 821ff30:	2100201c 	xori	r4,r4,128
 821ff34:	213fe004 	addi	r4,r4,-128
 821ff38:	e0bff817 	ldw	r2,-32(fp)
 821ff3c:	10c00417 	ldw	r3,16(r2)
 821ff40:	00820974 	movhi	r2,2085
 821ff44:	1087da04 	addi	r2,r2,8040
 821ff48:	21001224 	muli	r4,r4,72
 821ff4c:	1105883a 	add	r2,r2,r4
 821ff50:	10800d04 	addi	r2,r2,52
 821ff54:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= pfifo->tse_shared_fifo_rx_stat_base;
 821ff58:	d0a07f83 	ldbu	r2,-32258(gp)
 821ff5c:	11003fcc 	andi	r4,r2,255
 821ff60:	2100201c 	xori	r4,r4,128
 821ff64:	213fe004 	addi	r4,r4,-128
 821ff68:	e0bff817 	ldw	r2,-32(fp)
 821ff6c:	10c00517 	ldw	r3,20(r2)
 821ff70:	00820974 	movhi	r2,2085
 821ff74:	1087da04 	addi	r2,r2,8040
 821ff78:	21001224 	muli	r4,r4,72
 821ff7c:	1105883a 	add	r2,r2,r4
 821ff80:	10800e04 	addi	r2,r2,56
 821ff84:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = pfifo->tse_shared_fifo_rx_depth;
 821ff88:	d0a07f83 	ldbu	r2,-32258(gp)
 821ff8c:	11003fcc 	andi	r4,r2,255
 821ff90:	2100201c 	xori	r4,r4,128
 821ff94:	213fe004 	addi	r4,r4,-128
 821ff98:	e0bff817 	ldw	r2,-32(fp)
 821ff9c:	10c00617 	ldw	r3,24(r2)
 821ffa0:	00820974 	movhi	r2,2085
 821ffa4:	1087da04 	addi	r2,r2,8040
 821ffa8:	21001224 	muli	r4,r4,72
 821ffac:	1105883a 	add	r2,r2,r4
 821ffb0:	10800f04 	addi	r2,r2,60
 821ffb4:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add PHY info to alt_tse_system_info structure */
		if(pphy == 0) {
 821ffb8:	e0bff917 	ldw	r2,-28(fp)
 821ffbc:	1000161e 	bne	r2,zero,8220018 <alt_tse_system_add_sys+0x90c>
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= TSE_PHY_AUTO_ADDRESS;
 821ffc0:	d0a07f83 	ldbu	r2,-32258(gp)
 821ffc4:	10c03fcc 	andi	r3,r2,255
 821ffc8:	18c0201c 	xori	r3,r3,128
 821ffcc:	18ffe004 	addi	r3,r3,-128
 821ffd0:	00820974 	movhi	r2,2085
 821ffd4:	1087da04 	addi	r2,r2,8040
 821ffd8:	18c01224 	muli	r3,r3,72
 821ffdc:	10c5883a 	add	r2,r2,r3
 821ffe0:	10801004 	addi	r2,r2,64
 821ffe4:	00ffffc4 	movi	r3,-1
 821ffe8:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= 0;
 821ffec:	d0a07f83 	ldbu	r2,-32258(gp)
 821fff0:	10c03fcc 	andi	r3,r2,255
 821fff4:	18c0201c 	xori	r3,r3,128
 821fff8:	18ffe004 	addi	r3,r3,-128
 821fffc:	00820974 	movhi	r2,2085
 8220000:	1087da04 	addi	r2,r2,8040
 8220004:	18c01224 	muli	r3,r3,72
 8220008:	10c5883a 	add	r2,r2,r3
 822000c:	10801104 	addi	r2,r2,68
 8220010:	10000015 	stw	zero,0(r2)
 8220014:	00001806 	br	8220078 <alt_tse_system_add_sys+0x96c>
		}
		else {
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= pphy->tse_phy_mdio_address;
 8220018:	d0a07f83 	ldbu	r2,-32258(gp)
 822001c:	11003fcc 	andi	r4,r2,255
 8220020:	2100201c 	xori	r4,r4,128
 8220024:	213fe004 	addi	r4,r4,-128
 8220028:	e0bff917 	ldw	r2,-28(fp)
 822002c:	10c00017 	ldw	r3,0(r2)
 8220030:	00820974 	movhi	r2,2085
 8220034:	1087da04 	addi	r2,r2,8040
 8220038:	21001224 	muli	r4,r4,72
 822003c:	1105883a 	add	r2,r2,r4
 8220040:	10801004 	addi	r2,r2,64
 8220044:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= pphy->tse_phy_cfg;
 8220048:	d0a07f83 	ldbu	r2,-32258(gp)
 822004c:	11003fcc 	andi	r4,r2,255
 8220050:	2100201c 	xori	r4,r4,128
 8220054:	213fe004 	addi	r4,r4,-128
 8220058:	e0bff917 	ldw	r2,-28(fp)
 822005c:	10c00117 	ldw	r3,4(r2)
 8220060:	00820974 	movhi	r2,2085
 8220064:	1087da04 	addi	r2,r2,8040
 8220068:	21001224 	muli	r4,r4,72
 822006c:	1105883a 	add	r2,r2,r4
 8220070:	10801104 	addi	r2,r2,68
 8220074:	10c00015 	stw	r3,0(r2)
		}
		
		/* Point to next structure */
		psgdma++;
 8220078:	e0bff617 	ldw	r2,-40(fp)
 822007c:	10800304 	addi	r2,r2,12
 8220080:	e0bff615 	stw	r2,-40(fp)
		if(pmem) pmem++;
 8220084:	e0bff717 	ldw	r2,-36(fp)
 8220088:	10000326 	beq	r2,zero,8220098 <alt_tse_system_add_sys+0x98c>
 822008c:	e0bff717 	ldw	r2,-36(fp)
 8220090:	10800204 	addi	r2,r2,8
 8220094:	e0bff715 	stw	r2,-36(fp)
		if(pfifo) pfifo++;
 8220098:	e0bff817 	ldw	r2,-32(fp)
 822009c:	10000326 	beq	r2,zero,82200ac <alt_tse_system_add_sys+0x9a0>
 82200a0:	e0bff817 	ldw	r2,-32(fp)
 82200a4:	10800704 	addi	r2,r2,28
 82200a8:	e0bff815 	stw	r2,-32(fp)
		if(pphy) pphy++;
 82200ac:	e0bff917 	ldw	r2,-28(fp)
 82200b0:	10000326 	beq	r2,zero,82200c0 <alt_tse_system_add_sys+0x9b4>
 82200b4:	e0bff917 	ldw	r2,-28(fp)
 82200b8:	10800204 	addi	r2,r2,8
 82200bc:	e0bff915 	stw	r2,-28(fp)
		
		tse_system_count++;
 82200c0:	d0a07f83 	ldbu	r2,-32258(gp)
 82200c4:	10800044 	addi	r2,r2,1
 82200c8:	d0a07f85 	stb	r2,-32258(gp)
		max_mac_system = tse_system_count;
 82200cc:	d0a07f83 	ldbu	r2,-32258(gp)
 82200d0:	d0a02d05 	stb	r2,-32588(gp)
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
	}

	for(i = 0; i < loop_end; i++) {
 82200d4:	e0bff417 	ldw	r2,-48(fp)
 82200d8:	10800044 	addi	r2,r2,1
 82200dc:	e0bff415 	stw	r2,-48(fp)
 82200e0:	e0fff417 	ldw	r3,-48(fp)
 82200e4:	e0bff517 	ldw	r2,-44(fp)
 82200e8:	18bdb216 	blt	r3,r2,821f7b4 <alt_tse_system_add_sys+0xa8>
		
		tse_system_count++;
		max_mac_system = tse_system_count;
	}
	
	return SUCCESS;
 82200ec:	0005883a 	mov	r2,zero
	
}
 82200f0:	e6ffff04 	addi	sp,fp,-4
 82200f4:	dfc00217 	ldw	ra,8(sp)
 82200f8:	df000117 	ldw	fp,4(sp)
 82200fc:	dc000017 	ldw	r16,0(sp)
 8220100:	dec00304 	addi	sp,sp,12
 8220104:	f800283a 	ret

08220108 <alt_tse_sys_enable_mdio_sharing>:
 * @param		number_of_mac  number of MAC sharing MDIO block
 * @return      SUCCESS on success
 * 				ALTERA_TSE_SYSTEM_DEF_ERROR if definition of system incorrect or pointer == NULL
 * Multi-channel MAC not supported
 */
alt_32 alt_tse_sys_enable_mdio_sharing(alt_tse_system_mac **psys_mac_list, alt_u8 number_of_mac) {
 8220108:	defff904 	addi	sp,sp,-28
 822010c:	dfc00615 	stw	ra,24(sp)
 8220110:	df000515 	stw	fp,20(sp)
 8220114:	df000504 	addi	fp,sp,20
 8220118:	e13ffe15 	stw	r4,-8(fp)
 822011c:	2805883a 	mov	r2,r5
 8220120:	e0bfff05 	stb	r2,-4(fp)
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 8220124:	e03ffb15 	stw	zero,-20(fp)
 8220128:	00004806 	br	822024c <alt_tse_sys_enable_mdio_sharing+0x144>
		psys_mac = psys_mac_list[i];
 822012c:	e0bffb17 	ldw	r2,-20(fp)
 8220130:	1085883a 	add	r2,r2,r2
 8220134:	1085883a 	add	r2,r2,r2
 8220138:	1007883a 	mov	r3,r2
 822013c:	e0bffe17 	ldw	r2,-8(fp)
 8220140:	10c5883a 	add	r2,r2,r3
 8220144:	10800017 	ldw	r2,0(r2)
 8220148:	e0bffd15 	stw	r2,-12(fp)
		
		if(psys_mac == 0) {
 822014c:	e0bffd17 	ldw	r2,-12(fp)
 8220150:	1000081e 	bne	r2,zero,8220174 <alt_tse_sys_enable_mdio_sharing+0x6c>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 8220154:	01020974 	movhi	r4,2085
 8220158:	21387204 	addi	r4,r4,-7736
 822015c:	82036800 	call	8203680 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
 8220160:	01020974 	movhi	r4,2085
 8220164:	2138d704 	addi	r4,r4,-7332
 8220168:	82036800 	call	8203680 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 822016c:	00bfffc4 	movi	r2,-1
 8220170:	00003a06 	br	822025c <alt_tse_sys_enable_mdio_sharing+0x154>
		}
		
		for(j = 0; j < max_mac_system; j++) {
 8220174:	e03ffc15 	stw	zero,-16(fp)
 8220178:	00002d06 	br	8220230 <alt_tse_sys_enable_mdio_sharing+0x128>
			
			if(psys_mac->tse_mac_base == tse_mac_device[j].tse_mac_base) {
 822017c:	e0bffd17 	ldw	r2,-12(fp)
 8220180:	10c00017 	ldw	r3,0(r2)
 8220184:	00820974 	movhi	r2,2085
 8220188:	1087da04 	addi	r2,r2,8040
 822018c:	e13ffc17 	ldw	r4,-16(fp)
 8220190:	21001224 	muli	r4,r4,72
 8220194:	1105883a 	add	r2,r2,r4
 8220198:	10800017 	ldw	r2,0(r2)
 822019c:	1880211e 	bne	r3,r2,8220224 <alt_tse_sys_enable_mdio_sharing+0x11c>
				if(tse_mac_device[j].tse_multichannel_mac) {
 82201a0:	00820974 	movhi	r2,2085
 82201a4:	1087da04 	addi	r2,r2,8040
 82201a8:	e0fffc17 	ldw	r3,-16(fp)
 82201ac:	18c01224 	muli	r3,r3,72
 82201b0:	10c5883a 	add	r2,r2,r3
 82201b4:	108002c4 	addi	r2,r2,11
 82201b8:	10800003 	ldbu	r2,0(r2)
 82201bc:	10803fcc 	andi	r2,r2,255
 82201c0:	10000826 	beq	r2,zero,82201e4 <alt_tse_sys_enable_mdio_sharing+0xdc>
					tse_dprintf(2, "ERROR   : MDIO sharing supported by default for Multi-channel MAC\n");
 82201c4:	01020974 	movhi	r4,2085
 82201c8:	2138eb04 	addi	r4,r4,-7252
 82201cc:	82036800 	call	8203680 <puts>
					tse_dprintf(2, "ERROR   : Do not include Multi-channel MAC in the MAC List\n");
 82201d0:	01020974 	movhi	r4,2085
 82201d4:	2138fc04 	addi	r4,r4,-7184
 82201d8:	82036800 	call	8203680 <puts>
					return ALTERA_TSE_SYSTEM_DEF_ERROR;
 82201dc:	00bfffc4 	movi	r2,-1
 82201e0:	00001e06 	br	822025c <alt_tse_sys_enable_mdio_sharing+0x154>
				}
				
				tse_mac_device[j].tse_mdio_shared = 1;
 82201e4:	00820974 	movhi	r2,2085
 82201e8:	1087da04 	addi	r2,r2,8040
 82201ec:	e0fffc17 	ldw	r3,-16(fp)
 82201f0:	18c01224 	muli	r3,r3,72
 82201f4:	10c5883a 	add	r2,r2,r3
 82201f8:	10800344 	addi	r2,r2,13
 82201fc:	00c00044 	movi	r3,1
 8220200:	10c00005 	stb	r3,0(r2)
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
 8220204:	00820974 	movhi	r2,2085
 8220208:	1087da04 	addi	r2,r2,8040
 822020c:	e0fffc17 	ldw	r3,-16(fp)
 8220210:	18c01224 	muli	r3,r3,72
 8220214:	10c5883a 	add	r2,r2,r3
 8220218:	10800384 	addi	r2,r2,14
 822021c:	e0ffff03 	ldbu	r3,-4(fp)
 8220220:	10c00005 	stb	r3,0(r2)
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}
		
		for(j = 0; j < max_mac_system; j++) {
 8220224:	e0bffc17 	ldw	r2,-16(fp)
 8220228:	10800044 	addi	r2,r2,1
 822022c:	e0bffc15 	stw	r2,-16(fp)
 8220230:	d0a02d03 	ldbu	r2,-32588(gp)
 8220234:	10803fcc 	andi	r2,r2,255
 8220238:	e0fffc17 	ldw	r3,-16(fp)
 822023c:	18bfcf16 	blt	r3,r2,822017c <alt_tse_sys_enable_mdio_sharing+0x74>
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 8220240:	e0bffb17 	ldw	r2,-20(fp)
 8220244:	10800044 	addi	r2,r2,1
 8220248:	e0bffb15 	stw	r2,-20(fp)
 822024c:	e0bfff03 	ldbu	r2,-4(fp)
 8220250:	e0fffb17 	ldw	r3,-20(fp)
 8220254:	18bfb516 	blt	r3,r2,822012c <alt_tse_sys_enable_mdio_sharing+0x24>
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
			}
		}	
	}
	
	return SUCCESS;
 8220258:	0005883a 	mov	r2,zero
}
 822025c:	e037883a 	mov	sp,fp
 8220260:	dfc00117 	ldw	ra,4(sp)
 8220264:	df000017 	ldw	fp,0(sp)
 8220268:	dec00204 	addi	sp,sp,8
 822026c:	f800283a 	ret

08220270 <alt_tse_mac_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Public
 * @param pmac          Pointer to the TSE MAC Control Interface Base address
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_mac_get_common_speed(np_tse_mac *pmac) {
 8220270:	defffc04 	addi	sp,sp,-16
 8220274:	dfc00315 	stw	ra,12(sp)
 8220278:	df000215 	stw	fp,8(sp)
 822027c:	df000204 	addi	fp,sp,8
 8220280:	e13fff15 	stw	r4,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 8220284:	e13fff17 	ldw	r4,-4(fp)
 8220288:	82204580 	call	8220458 <alt_tse_get_mac_info>
 822028c:	10800317 	ldw	r2,12(r2)
 8220290:	e0bffe15 	stw	r2,-8(fp)
    return alt_tse_phy_get_common_speed(pmac_group);
 8220294:	e13ffe17 	ldw	r4,-8(fp)
 8220298:	82236280 	call	8223628 <alt_tse_phy_get_common_speed>
}
 822029c:	e037883a 	mov	sp,fp
 82202a0:	dfc00117 	ldw	ra,4(sp)
 82202a4:	df000017 	ldw	fp,0(sp)
 82202a8:	dec00204 	addi	sp,sp,8
 82202ac:	f800283a 	ret

082202b0 <alt_tse_mac_set_common_speed>:
 * @API Type:               Public
 * @param pmac              Pointer to the TSE MAC Control Interface Base address
 *        common_speed      common speed supported by all PHYs
 * @return                  common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_mac_set_common_speed(np_tse_mac *pmac, alt_32 common_speed) {
 82202b0:	defffb04 	addi	sp,sp,-20
 82202b4:	dfc00415 	stw	ra,16(sp)
 82202b8:	df000315 	stw	fp,12(sp)
 82202bc:	df000304 	addi	fp,sp,12
 82202c0:	e13ffe15 	stw	r4,-8(fp)
 82202c4:	e17fff15 	stw	r5,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 82202c8:	e13ffe17 	ldw	r4,-8(fp)
 82202cc:	82204580 	call	8220458 <alt_tse_get_mac_info>
 82202d0:	10800317 	ldw	r2,12(r2)
 82202d4:	e0bffd15 	stw	r2,-12(fp)
    return alt_tse_phy_set_common_speed(pmac_group, common_speed);
 82202d8:	e17fff17 	ldw	r5,-4(fp)
 82202dc:	e13ffd17 	ldw	r4,-12(fp)
 82202e0:	82239500 	call	8223950 <alt_tse_phy_set_common_speed>
}
 82202e4:	e037883a 	mov	sp,fp
 82202e8:	dfc00117 	ldw	ra,4(sp)
 82202ec:	df000017 	ldw	fp,0(sp)
 82202f0:	dec00204 	addi	sp,sp,8
 82202f4:	f800283a 	ret

082202f8 <alt_tse_get_system_index>:
/* @Function Description: Get the index of alt_tse_system_info structure in tse_mac_device[]
 * @API Type:        Internal
 * @param psys_info  Pointer to the alt_tse_system_info structure
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
 82202f8:	defffd04 	addi	sp,sp,-12
 82202fc:	df000215 	stw	fp,8(sp)
 8220300:	df000204 	addi	fp,sp,8
 8220304:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 8220308:	e03ffe15 	stw	zero,-8(fp)
 822030c:	00000c06 	br	8220340 <alt_tse_get_system_index+0x48>
        if(psys_info == &tse_mac_device[i]) {
 8220310:	e0bffe17 	ldw	r2,-8(fp)
 8220314:	10c01224 	muli	r3,r2,72
 8220318:	00820974 	movhi	r2,2085
 822031c:	1087da04 	addi	r2,r2,8040
 8220320:	1887883a 	add	r3,r3,r2
 8220324:	e0bfff17 	ldw	r2,-4(fp)
 8220328:	1880021e 	bne	r3,r2,8220334 <alt_tse_get_system_index+0x3c>
            return i;
 822032c:	e0bffe17 	ldw	r2,-8(fp)
 8220330:	00000806 	br	8220354 <alt_tse_get_system_index+0x5c>
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 8220334:	e0bffe17 	ldw	r2,-8(fp)
 8220338:	10800044 	addi	r2,r2,1
 822033c:	e0bffe15 	stw	r2,-8(fp)
 8220340:	d0a02d03 	ldbu	r2,-32588(gp)
 8220344:	10803fcc 	andi	r2,r2,255
 8220348:	e0fffe17 	ldw	r3,-8(fp)
 822034c:	18bff016 	blt	r3,r2,8220310 <alt_tse_get_system_index+0x18>
        if(psys_info == &tse_mac_device[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 8220350:	00bfffc4 	movi	r2,-1
}
 8220354:	e037883a 	mov	sp,fp
 8220358:	df000017 	ldw	fp,0(sp)
 822035c:	dec00104 	addi	sp,sp,4
 8220360:	f800283a 	ret

08220364 <alt_tse_get_mac_group_index>:
/* @Function Description: Get the index of alt_tse_mac_group structure in pmac_groups[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_group structure
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
 8220364:	defffd04 	addi	sp,sp,-12
 8220368:	df000215 	stw	fp,8(sp)
 822036c:	df000204 	addi	fp,sp,8
 8220370:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 8220374:	e03ffe15 	stw	zero,-8(fp)
 8220378:	00000e06 	br	82203b4 <alt_tse_get_mac_group_index+0x50>
        if(pmac_group == pmac_groups[i]) {
 822037c:	008209b4 	movhi	r2,2086
 8220380:	10b71804 	addi	r2,r2,-9120
 8220384:	e0fffe17 	ldw	r3,-8(fp)
 8220388:	18c7883a 	add	r3,r3,r3
 822038c:	18c7883a 	add	r3,r3,r3
 8220390:	10c5883a 	add	r2,r2,r3
 8220394:	10c00017 	ldw	r3,0(r2)
 8220398:	e0bfff17 	ldw	r2,-4(fp)
 822039c:	1880021e 	bne	r3,r2,82203a8 <alt_tse_get_mac_group_index+0x44>
            return i;
 82203a0:	e0bffe17 	ldw	r2,-8(fp)
 82203a4:	00000806 	br	82203c8 <alt_tse_get_mac_group_index+0x64>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 82203a8:	e0bffe17 	ldw	r2,-8(fp)
 82203ac:	10800044 	addi	r2,r2,1
 82203b0:	e0bffe15 	stw	r2,-8(fp)
 82203b4:	d0a07f43 	ldbu	r2,-32259(gp)
 82203b8:	10803fcc 	andi	r2,r2,255
 82203bc:	e0fffe17 	ldw	r3,-8(fp)
 82203c0:	18bfee16 	blt	r3,r2,822037c <alt_tse_get_mac_group_index+0x18>
        if(pmac_group == pmac_groups[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 82203c4:	00bfffc4 	movi	r2,-1
}
 82203c8:	e037883a 	mov	sp,fp
 82203cc:	df000017 	ldw	fp,0(sp)
 82203d0:	dec00104 	addi	sp,sp,4
 82203d4:	f800283a 	ret

082203d8 <alt_tse_get_mac_info_index>:
/* @Function Description: Get the index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_info structure
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
 82203d8:	defffd04 	addi	sp,sp,-12
 82203dc:	df000215 	stw	fp,8(sp)
 82203e0:	df000204 	addi	fp,sp,8
 82203e4:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 82203e8:	e03ffe15 	stw	zero,-8(fp)
 82203ec:	00000f06 	br	822042c <alt_tse_get_mac_info_index+0x54>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
 82203f0:	e0bfff17 	ldw	r2,-4(fp)
 82203f4:	10c00317 	ldw	r3,12(r2)
 82203f8:	e0bffe17 	ldw	r2,-8(fp)
 82203fc:	10800044 	addi	r2,r2,1
 8220400:	1085883a 	add	r2,r2,r2
 8220404:	1085883a 	add	r2,r2,r2
 8220408:	1885883a 	add	r2,r3,r2
 822040c:	10c00017 	ldw	r3,0(r2)
 8220410:	e0bfff17 	ldw	r2,-4(fp)
 8220414:	1880021e 	bne	r3,r2,8220420 <alt_tse_get_mac_info_index+0x48>
            return i;
 8220418:	e0bffe17 	ldw	r2,-8(fp)
 822041c:	00000a06 	br	8220448 <alt_tse_get_mac_info_index+0x70>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 8220420:	e0bffe17 	ldw	r2,-8(fp)
 8220424:	10800044 	addi	r2,r2,1
 8220428:	e0bffe15 	stw	r2,-8(fp)
 822042c:	e0bfff17 	ldw	r2,-4(fp)
 8220430:	10800317 	ldw	r2,12(r2)
 8220434:	10800003 	ldbu	r2,0(r2)
 8220438:	10803fcc 	andi	r2,r2,255
 822043c:	e0fffe17 	ldw	r3,-8(fp)
 8220440:	18bfeb16 	blt	r3,r2,82203f0 <alt_tse_get_mac_info_index+0x18>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
            return i;
        }
    }
    
    return ALTERA_TSE_NO_INDEX_FOUND;
 8220444:	00bfffc4 	movi	r2,-1
}
 8220448:	e037883a 	mov	sp,fp
 822044c:	df000017 	ldw	fp,0(sp)
 8220450:	dec00104 	addi	sp,sp,4
 8220454:	f800283a 	ret

08220458 <alt_tse_get_mac_info>:
/* @Function Description: Get the pointer of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac        Pointer to the TSE MAC Control Interface Base address
 * @return            Pointer to alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_tse_mac_info *alt_tse_get_mac_info(np_tse_mac *pmac) {
 8220458:	defffa04 	addi	sp,sp,-24
 822045c:	df000515 	stw	fp,20(sp)
 8220460:	df000504 	addi	fp,sp,20
 8220464:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
 8220468:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
 822046c:	e03ffe15 	stw	zero,-8(fp)
    
    for(i = 0; i < mac_group_count; i++) {
 8220470:	e03ffb15 	stw	zero,-20(fp)
 8220474:	00002506 	br	822050c <alt_tse_get_mac_info+0xb4>
        pmac_group = pmac_groups[i];
 8220478:	008209b4 	movhi	r2,2086
 822047c:	10b71804 	addi	r2,r2,-9120
 8220480:	e0fffb17 	ldw	r3,-20(fp)
 8220484:	18c7883a 	add	r3,r3,r3
 8220488:	18c7883a 	add	r3,r3,r3
 822048c:	10c5883a 	add	r2,r2,r3
 8220490:	10800017 	ldw	r2,0(r2)
 8220494:	e0bffd15 	stw	r2,-12(fp)
        for(j = 0; j < pmac_group->channel; j++) {
 8220498:	e03ffc15 	stw	zero,-16(fp)
 822049c:	00001306 	br	82204ec <alt_tse_get_mac_info+0x94>
            pmac_info = pmac_group->pmac_info[j];
 82204a0:	e0fffd17 	ldw	r3,-12(fp)
 82204a4:	e0bffc17 	ldw	r2,-16(fp)
 82204a8:	10800044 	addi	r2,r2,1
 82204ac:	1085883a 	add	r2,r2,r2
 82204b0:	1085883a 	add	r2,r2,r2
 82204b4:	1885883a 	add	r2,r3,r2
 82204b8:	10800017 	ldw	r2,0(r2)
 82204bc:	e0bffe15 	stw	r2,-8(fp)
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
 82204c0:	e0bffe17 	ldw	r2,-8(fp)
 82204c4:	10800217 	ldw	r2,8(r2)
 82204c8:	10800017 	ldw	r2,0(r2)
 82204cc:	1007883a 	mov	r3,r2
 82204d0:	e0bfff17 	ldw	r2,-4(fp)
 82204d4:	1880021e 	bne	r3,r2,82204e0 <alt_tse_get_mac_info+0x88>
                return pmac_info;
 82204d8:	e0bffe17 	ldw	r2,-8(fp)
 82204dc:	00001006 	br	8220520 <alt_tse_get_mac_info+0xc8>
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
 82204e0:	e0bffc17 	ldw	r2,-16(fp)
 82204e4:	10800044 	addi	r2,r2,1
 82204e8:	e0bffc15 	stw	r2,-16(fp)
 82204ec:	e0bffd17 	ldw	r2,-12(fp)
 82204f0:	10800003 	ldbu	r2,0(r2)
 82204f4:	10803fcc 	andi	r2,r2,255
 82204f8:	e0fffc17 	ldw	r3,-16(fp)
 82204fc:	18bfe816 	blt	r3,r2,82204a0 <alt_tse_get_mac_info+0x48>
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
 8220500:	e0bffb17 	ldw	r2,-20(fp)
 8220504:	10800044 	addi	r2,r2,1
 8220508:	e0bffb15 	stw	r2,-20(fp)
 822050c:	d0a07f43 	ldbu	r2,-32259(gp)
 8220510:	10803fcc 	andi	r2,r2,255
 8220514:	e0fffb17 	ldw	r3,-20(fp)
 8220518:	18bfd716 	blt	r3,r2,8220478 <alt_tse_get_mac_info+0x20>
                return pmac_info;
            }
        }        
    }
    
    return 0;
 822051c:	0005883a 	mov	r2,zero
}
 8220520:	e037883a 	mov	sp,fp
 8220524:	df000017 	ldw	fp,0(sp)
 8220528:	dec00104 	addi	sp,sp,4
 822052c:	f800283a 	ret

08220530 <alt_tse_mac_set_speed>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param speed 2 = 1000 Mbps, 1 = 100 Mbps, 0 = 10 Mbps
 * @return ENP_PARAM if invalid speed specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_speed(np_tse_mac *pmac, alt_u8 speed)
{
 8220530:	defffc04 	addi	sp,sp,-16
 8220534:	df000315 	stw	fp,12(sp)
 8220538:	df000304 	addi	fp,sp,12
 822053c:	e13ffe15 	stw	r4,-8(fp)
 8220540:	2805883a 	mov	r2,r5
 8220544:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 8220548:	e0bffe17 	ldw	r2,-8(fp)
 822054c:	10800204 	addi	r2,r2,8
 8220550:	10800037 	ldwio	r2,0(r2)
 8220554:	e0bffd15 	stw	r2,-12(fp)
  
  /* 1000 Mbps */
  if(speed == TSE_PHY_SPEED_1000) {
 8220558:	e0bfff03 	ldbu	r2,-4(fp)
 822055c:	10800098 	cmpnei	r2,r2,2
 8220560:	1000091e 	bne	r2,zero,8220588 <alt_tse_mac_set_speed+0x58>
    helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 8220564:	e0bffd17 	ldw	r2,-12(fp)
 8220568:	10800214 	ori	r2,r2,8
 822056c:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8220570:	e0fffd17 	ldw	r3,-12(fp)
 8220574:	00bf8034 	movhi	r2,65024
 8220578:	10bfffc4 	addi	r2,r2,-1
 822057c:	1884703a 	and	r2,r3,r2
 8220580:	e0bffd15 	stw	r2,-12(fp)
 8220584:	00001906 	br	82205ec <alt_tse_mac_set_speed+0xbc>
  }
  /* 100 Mbps */
  else if(speed == TSE_PHY_SPEED_100) {
 8220588:	e0bfff03 	ldbu	r2,-4(fp)
 822058c:	10800058 	cmpnei	r2,r2,1
 8220590:	10000a1e 	bne	r2,zero,82205bc <alt_tse_mac_set_speed+0x8c>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 8220594:	e0fffd17 	ldw	r3,-12(fp)
 8220598:	00bffdc4 	movi	r2,-9
 822059c:	1884703a 	and	r2,r3,r2
 82205a0:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 82205a4:	e0fffd17 	ldw	r3,-12(fp)
 82205a8:	00bf8034 	movhi	r2,65024
 82205ac:	10bfffc4 	addi	r2,r2,-1
 82205b0:	1884703a 	and	r2,r3,r2
 82205b4:	e0bffd15 	stw	r2,-12(fp)
 82205b8:	00000c06 	br	82205ec <alt_tse_mac_set_speed+0xbc>
  }
  /* 10 Mbps */
  else if(speed == TSE_PHY_SPEED_10) {
 82205bc:	e0bfff03 	ldbu	r2,-4(fp)
 82205c0:	1000081e 	bne	r2,zero,82205e4 <alt_tse_mac_set_speed+0xb4>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 82205c4:	e0fffd17 	ldw	r3,-12(fp)
 82205c8:	00bffdc4 	movi	r2,-9
 82205cc:	1884703a 	and	r2,r3,r2
 82205d0:	e0bffd15 	stw	r2,-12(fp)
	helpvar |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 82205d4:	e0bffd17 	ldw	r2,-12(fp)
 82205d8:	10808034 	orhi	r2,r2,512
 82205dc:	e0bffd15 	stw	r2,-12(fp)
 82205e0:	00000206 	br	82205ec <alt_tse_mac_set_speed+0xbc>
  }  
  else {
    return ENP_PARAM;
 82205e4:	00bffd84 	movi	r2,-10
 82205e8:	00000506 	br	8220600 <alt_tse_mac_set_speed+0xd0>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 82205ec:	e0bffe17 	ldw	r2,-8(fp)
 82205f0:	10800204 	addi	r2,r2,8
 82205f4:	e0fffd17 	ldw	r3,-12(fp)
 82205f8:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 82205fc:	0005883a 	mov	r2,zero
}
 8220600:	e037883a 	mov	sp,fp
 8220604:	df000017 	ldw	fp,0(sp)
 8220608:	dec00104 	addi	sp,sp,4
 822060c:	f800283a 	ret

08220610 <alt_tse_mac_set_duplex>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param duplex 1 = Full Duplex, 0 = Half Duplex
 * @return ENP_PARAM if invalid duplex specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_duplex(np_tse_mac *pmac, alt_u8 duplex)
{
 8220610:	defffc04 	addi	sp,sp,-16
 8220614:	df000315 	stw	fp,12(sp)
 8220618:	df000304 	addi	fp,sp,12
 822061c:	e13ffe15 	stw	r4,-8(fp)
 8220620:	2805883a 	mov	r2,r5
 8220624:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 8220628:	e0bffe17 	ldw	r2,-8(fp)
 822062c:	10800204 	addi	r2,r2,8
 8220630:	10800037 	ldwio	r2,0(r2)
 8220634:	e0bffd15 	stw	r2,-12(fp)
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
 8220638:	e0bfff03 	ldbu	r2,-4(fp)
 822063c:	1000041e 	bne	r2,zero,8220650 <alt_tse_mac_set_duplex+0x40>
    helpvar |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 8220640:	e0bffd17 	ldw	r2,-12(fp)
 8220644:	10810014 	ori	r2,r2,1024
 8220648:	e0bffd15 	stw	r2,-12(fp)
 822064c:	00000a06 	br	8220678 <alt_tse_mac_set_duplex+0x68>
  } 
  /* Full Duplex */
  else if(duplex == TSE_PHY_DUPLEX_FULL) {
 8220650:	e0bfff03 	ldbu	r2,-4(fp)
 8220654:	10800058 	cmpnei	r2,r2,1
 8220658:	1000051e 	bne	r2,zero,8220670 <alt_tse_mac_set_duplex+0x60>
    helpvar &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 822065c:	e0fffd17 	ldw	r3,-12(fp)
 8220660:	00beffc4 	movi	r2,-1025
 8220664:	1884703a 	and	r2,r3,r2
 8220668:	e0bffd15 	stw	r2,-12(fp)
 822066c:	00000206 	br	8220678 <alt_tse_mac_set_duplex+0x68>
  }
  else {
    return ENP_PARAM;
 8220670:	00bffd84 	movi	r2,-10
 8220674:	00000506 	br	822068c <alt_tse_mac_set_duplex+0x7c>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 8220678:	e0bffe17 	ldw	r2,-8(fp)
 822067c:	10800204 	addi	r2,r2,8
 8220680:	e0fffd17 	ldw	r3,-12(fp)
 8220684:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 8220688:	0005883a 	mov	r2,zero

}
 822068c:	e037883a 	mov	sp,fp
 8220690:	df000017 	ldw	fp,0(sp)
 8220694:	dec00104 	addi	sp,sp,4
 8220698:	f800283a 	ret

0822069c <getPHYSpeed>:
  	(((speed == TSE_PHY_SPEED_1000) ? 1 : 0) << 1) |   \
	(((speed == TSE_PHY_SPEED_100) ? 1 : 0) << 2) |     \
	(((speed == TSE_PHY_SPEED_10) ? 1 : 0) << 3) |      \
	((speed == TSE_PHY_SPEED_INVALID) ? ALT_TSE_E_INVALID_SPEED : 0))
  
alt_32 getPHYSpeed(np_tse_mac *pmac) {
 822069c:	defff404 	addi	sp,sp,-48
 82206a0:	dfc00b15 	stw	ra,44(sp)
 82206a4:	df000a15 	stw	fp,40(sp)
 82206a8:	df000a04 	addi	fp,sp,40
 82206ac:	e13fff15 	stw	r4,-4(fp)

	alt_u8 speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 82206b0:	00800044 	movi	r2,1
 82206b4:	e0bff705 	stb	r2,-36(fp)
	alt_u8 duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;     /* 1 = full ; 0 = half*/
 82206b8:	00800044 	movi	r2,1
 82206bc:	e0bff745 	stb	r2,-35(fp)
	alt_32 result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 82206c0:	e0bff743 	ldbu	r2,-35(fp)
 82206c4:	10c0004c 	andi	r3,r2,1
 82206c8:	e0bff703 	ldbu	r2,-36(fp)
 82206cc:	10800098 	cmpnei	r2,r2,2
 82206d0:	1000021e 	bne	r2,zero,82206dc <getPHYSpeed+0x40>
 82206d4:	00800084 	movi	r2,2
 82206d8:	00000106 	br	82206e0 <getPHYSpeed+0x44>
 82206dc:	0005883a 	mov	r2,zero
 82206e0:	1886b03a 	or	r3,r3,r2
 82206e4:	e0bff703 	ldbu	r2,-36(fp)
 82206e8:	10800058 	cmpnei	r2,r2,1
 82206ec:	1000021e 	bne	r2,zero,82206f8 <getPHYSpeed+0x5c>
 82206f0:	00800104 	movi	r2,4
 82206f4:	00000106 	br	82206fc <getPHYSpeed+0x60>
 82206f8:	0005883a 	mov	r2,zero
 82206fc:	1886b03a 	or	r3,r3,r2
 8220700:	e0bff703 	ldbu	r2,-36(fp)
 8220704:	1000021e 	bne	r2,zero,8220710 <getPHYSpeed+0x74>
 8220708:	00800204 	movi	r2,8
 822070c:	00000106 	br	8220714 <getPHYSpeed+0x78>
 8220710:	0005883a 	mov	r2,zero
 8220714:	1886b03a 	or	r3,r3,r2
 8220718:	e0bff703 	ldbu	r2,-36(fp)
 822071c:	108000d8 	cmpnei	r2,r2,3
 8220720:	1000021e 	bne	r2,zero,822072c <getPHYSpeed+0x90>
 8220724:	00800074 	movhi	r2,1
 8220728:	00000106 	br	8220730 <getPHYSpeed+0x94>
 822072c:	0005883a 	mov	r2,zero
 8220730:	1884b03a 	or	r2,r3,r2
 8220734:	e0bff815 	stw	r2,-32(fp)
    
    alt_tse_phy_info *pphy = 0;
 8220738:	e03ff915 	stw	zero,-28(fp)
    alt_tse_mac_info *pmac_info = 0;
 822073c:	e03ffa15 	stw	zero,-24(fp)
    alt_tse_mac_group *pmac_group = 0;
 8220740:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_system_info *psys = 0;
 8220744:	e03ffc15 	stw	zero,-16(fp)
    
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 8220748:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = 0;
 822074c:	e03ffd45 	stb	zero,-11(fp)
    
    /* initialized PHYs only once */
    static alt_u8 is_init = 0;
    if(is_init == 0) {
 8220750:	d0a07fc3 	ldbu	r2,-32257(gp)
 8220754:	10803fcc 	andi	r2,r2,255
 8220758:	1000031e 	bne	r2,zero,8220768 <getPHYSpeed+0xcc>
        alt_tse_phy_init();
 822075c:	822269c0 	call	822269c <alt_tse_phy_init>
        is_init = 1;
 8220760:	00800044 	movi	r2,1
 8220764:	d0a07fc5 	stb	r2,-32257(gp)
    }
    
    /* Look for pmac_group and pmac_info structure based on pmac or iface */
    pmac_info = alt_tse_get_mac_info(pmac);
 8220768:	e13fff17 	ldw	r4,-4(fp)
 822076c:	82204580 	call	8220458 <alt_tse_get_mac_info>
 8220770:	e0bffa15 	stw	r2,-24(fp)
    
    if(pmac_info == 0) {
 8220774:	e0bffa17 	ldw	r2,-24(fp)
 8220778:	1000481e 	bne	r2,zero,822089c <getPHYSpeed+0x200>
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 822077c:	00800044 	movi	r2,1
 8220780:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 8220784:	00800044 	movi	r2,1
 8220788:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PMAC_FOUND;
 822078c:	e0bff743 	ldbu	r2,-35(fp)
 8220790:	10c0004c 	andi	r3,r2,1
 8220794:	e0bff703 	ldbu	r2,-36(fp)
 8220798:	10800098 	cmpnei	r2,r2,2
 822079c:	1000021e 	bne	r2,zero,82207a8 <getPHYSpeed+0x10c>
 82207a0:	00800084 	movi	r2,2
 82207a4:	00000106 	br	82207ac <getPHYSpeed+0x110>
 82207a8:	0005883a 	mov	r2,zero
 82207ac:	1886b03a 	or	r3,r3,r2
 82207b0:	e0bff703 	ldbu	r2,-36(fp)
 82207b4:	10800058 	cmpnei	r2,r2,1
 82207b8:	1000021e 	bne	r2,zero,82207c4 <getPHYSpeed+0x128>
 82207bc:	00800104 	movi	r2,4
 82207c0:	00000106 	br	82207c8 <getPHYSpeed+0x12c>
 82207c4:	0005883a 	mov	r2,zero
 82207c8:	1886b03a 	or	r3,r3,r2
 82207cc:	e0bff703 	ldbu	r2,-36(fp)
 82207d0:	1000021e 	bne	r2,zero,82207dc <getPHYSpeed+0x140>
 82207d4:	00800204 	movi	r2,8
 82207d8:	00000106 	br	82207e0 <getPHYSpeed+0x144>
 82207dc:	0005883a 	mov	r2,zero
 82207e0:	1886b03a 	or	r3,r3,r2
 82207e4:	e0bff703 	ldbu	r2,-36(fp)
 82207e8:	108000d8 	cmpnei	r2,r2,3
 82207ec:	1000021e 	bne	r2,zero,82207f8 <getPHYSpeed+0x15c>
 82207f0:	00800074 	movhi	r2,1
 82207f4:	00000106 	br	82207fc <getPHYSpeed+0x160>
 82207f8:	0005883a 	mov	r2,zero
 82207fc:	1884b03a 	or	r2,r3,r2
 8220800:	10802034 	orhi	r2,r2,128
 8220804:	e0bff815 	stw	r2,-32(fp)
        tse_dprintf(2, "ERROR   : [getPHYSpeed] pmac not found from list of pmac_info[]! Speed = %s Mbps, Duplex = %s\n", speed == TSE_PHY_SPEED_1000 ? "1000" :
 8220808:	e0bff703 	ldbu	r2,-36(fp)
 822080c:	108000a0 	cmpeqi	r2,r2,2
 8220810:	10000e1e 	bne	r2,zero,822084c <getPHYSpeed+0x1b0>
 8220814:	e0bff703 	ldbu	r2,-36(fp)
 8220818:	10800060 	cmpeqi	r2,r2,1
 822081c:	1000081e 	bne	r2,zero,8220840 <getPHYSpeed+0x1a4>
 8220820:	e0bff703 	ldbu	r2,-36(fp)
 8220824:	1000031e 	bne	r2,zero,8220834 <getPHYSpeed+0x198>
 8220828:	00820974 	movhi	r2,2085
 822082c:	10b90b04 	addi	r2,r2,-7124
 8220830:	00000806 	br	8220854 <getPHYSpeed+0x1b8>
 8220834:	00820974 	movhi	r2,2085
 8220838:	10b90c04 	addi	r2,r2,-7120
 822083c:	00000506 	br	8220854 <getPHYSpeed+0x1b8>
 8220840:	00820974 	movhi	r2,2085
 8220844:	10b90e04 	addi	r2,r2,-7112
 8220848:	00000206 	br	8220854 <getPHYSpeed+0x1b8>
 822084c:	00820974 	movhi	r2,2085
 8220850:	10b90f04 	addi	r2,r2,-7108
 8220854:	e0fff743 	ldbu	r3,-35(fp)
 8220858:	18c00058 	cmpnei	r3,r3,1
 822085c:	1800031e 	bne	r3,zero,822086c <getPHYSpeed+0x1d0>
 8220860:	00c20974 	movhi	r3,2085
 8220864:	18f91104 	addi	r3,r3,-7100
 8220868:	00000206 	br	8220874 <getPHYSpeed+0x1d8>
 822086c:	00c20974 	movhi	r3,2085
 8220870:	18f91304 	addi	r3,r3,-7092
 8220874:	180d883a 	mov	r6,r3
 8220878:	100b883a 	mov	r5,r2
 822087c:	01020974 	movhi	r4,2085
 8220880:	21391504 	addi	r4,r4,-7084
 8220884:	82033fc0 	call	82033fc <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        tse_dprintf(2, "ERROR   : [getPHYSpeed] Please define tse_mac_device[] correctly\n");
 8220888:	01020974 	movhi	r4,2085
 822088c:	21392d04 	addi	r4,r4,-6988
 8220890:	82036800 	call	8203680 <puts>
        return result;
 8220894:	e0bff817 	ldw	r2,-32(fp)
 8220898:	00021d06 	br	8221110 <getPHYSpeed+0xa74>
    }
    
    pphy = pmac_info->pphy_info;
 822089c:	e0bffa17 	ldw	r2,-24(fp)
 82208a0:	10800117 	ldw	r2,4(r2)
 82208a4:	e0bff915 	stw	r2,-28(fp)
    pmac_group = pmac_info->pmac_group;
 82208a8:	e0bffa17 	ldw	r2,-24(fp)
 82208ac:	10800317 	ldw	r2,12(r2)
 82208b0:	e0bffb15 	stw	r2,-20(fp)
    psys = pmac_info->psys_info;
 82208b4:	e0bffa17 	ldw	r2,-24(fp)
 82208b8:	10800217 	ldw	r2,8(r2)
 82208bc:	e0bffc15 	stw	r2,-16(fp)
    
    mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 82208c0:	e13ffa17 	ldw	r4,-24(fp)
 82208c4:	82203d80 	call	82203d8 <alt_tse_get_mac_info_index>
 82208c8:	e0bffd05 	stb	r2,-12(fp)
    mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 82208cc:	e13ffb17 	ldw	r4,-20(fp)
 82208d0:	82203640 	call	8220364 <alt_tse_get_mac_group_index>
 82208d4:	e0bffd45 	stb	r2,-11(fp)
         
    /* MDIO is not used */
    if (pmac_group->pmac_info[0]->psys_info->tse_use_mdio == 0)
 82208d8:	e0bffb17 	ldw	r2,-20(fp)
 82208dc:	10800117 	ldw	r2,4(r2)
 82208e0:	10800217 	ldw	r2,8(r2)
 82208e4:	10800203 	ldbu	r2,8(r2)
 82208e8:	10803fcc 	andi	r2,r2,255
 82208ec:	10005a1e 	bne	r2,zero,8220a58 <getPHYSpeed+0x3bc>
    {
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 82208f0:	00800044 	movi	r2,1
 82208f4:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 82208f8:	00800044 	movi	r2,1
 82208fc:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_MDIO;
 8220900:	e0bff743 	ldbu	r2,-35(fp)
 8220904:	10c0004c 	andi	r3,r2,1
 8220908:	e0bff703 	ldbu	r2,-36(fp)
 822090c:	10800098 	cmpnei	r2,r2,2
 8220910:	1000021e 	bne	r2,zero,822091c <getPHYSpeed+0x280>
 8220914:	00800084 	movi	r2,2
 8220918:	00000106 	br	8220920 <getPHYSpeed+0x284>
 822091c:	0005883a 	mov	r2,zero
 8220920:	1886b03a 	or	r3,r3,r2
 8220924:	e0bff703 	ldbu	r2,-36(fp)
 8220928:	10800058 	cmpnei	r2,r2,1
 822092c:	1000021e 	bne	r2,zero,8220938 <getPHYSpeed+0x29c>
 8220930:	00800104 	movi	r2,4
 8220934:	00000106 	br	822093c <getPHYSpeed+0x2a0>
 8220938:	0005883a 	mov	r2,zero
 822093c:	1886b03a 	or	r3,r3,r2
 8220940:	e0bff703 	ldbu	r2,-36(fp)
 8220944:	1000021e 	bne	r2,zero,8220950 <getPHYSpeed+0x2b4>
 8220948:	00800204 	movi	r2,8
 822094c:	00000106 	br	8220954 <getPHYSpeed+0x2b8>
 8220950:	0005883a 	mov	r2,zero
 8220954:	1886b03a 	or	r3,r3,r2
 8220958:	e0bff703 	ldbu	r2,-36(fp)
 822095c:	108000d8 	cmpnei	r2,r2,3
 8220960:	1000021e 	bne	r2,zero,822096c <getPHYSpeed+0x2d0>
 8220964:	00800074 	movhi	r2,1
 8220968:	00000106 	br	8220970 <getPHYSpeed+0x2d4>
 822096c:	0005883a 	mov	r2,zero
 8220970:	1884b03a 	or	r2,r3,r2
 8220974:	10801034 	orhi	r2,r2,64
 8220978:	e0bff815 	stw	r2,-32(fp)
        usleep(ALTERA_NOMDIO_TIMEOUT_THRESHOLD);
 822097c:	010003f4 	movhi	r4,15
 8220980:	21109004 	addi	r4,r4,16960
 8220984:	823ca800 	call	823ca80 <usleep>
        if(psys->tse_phy_cfg) {
 8220988:	e0bffc17 	ldw	r2,-16(fp)
 822098c:	10801117 	ldw	r2,68(r2)
 8220990:	10000d26 	beq	r2,zero,82209c8 <getPHYSpeed+0x32c>
        	tse_dprintf(4, "WARNING : PHY[%d.%d] - MDIO not enabled! Running user configuration...\n", mac_group_index, mac_info_index);
 8220994:	e0bffd47 	ldb	r2,-11(fp)
 8220998:	e0fffd07 	ldb	r3,-12(fp)
 822099c:	180d883a 	mov	r6,r3
 82209a0:	100b883a 	mov	r5,r2
 82209a4:	01020974 	movhi	r4,2085
 82209a8:	21393e04 	addi	r4,r4,-6920
 82209ac:	82033fc0 	call	82033fc <printf>
        	result = psys->tse_phy_cfg(pmac);
 82209b0:	e0bffc17 	ldw	r2,-16(fp)
 82209b4:	10801117 	ldw	r2,68(r2)
 82209b8:	e13fff17 	ldw	r4,-4(fp)
 82209bc:	103ee83a 	callr	r2
 82209c0:	e0bff815 	stw	r2,-32(fp)
 82209c4:	00002206 	br	8220a50 <getPHYSpeed+0x3b4>
        }
        else {
        	tse_dprintf(4, "WARNING : MAC Group[%d] - MDIO not enabled! Speed = %s, Duplex = %s\n", mac_group_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 82209c8:	e13ffd47 	ldb	r4,-11(fp)
 82209cc:	e0bff703 	ldbu	r2,-36(fp)
 82209d0:	108000a0 	cmpeqi	r2,r2,2
 82209d4:	10000e1e 	bne	r2,zero,8220a10 <getPHYSpeed+0x374>
 82209d8:	e0bff703 	ldbu	r2,-36(fp)
 82209dc:	10800060 	cmpeqi	r2,r2,1
 82209e0:	1000081e 	bne	r2,zero,8220a04 <getPHYSpeed+0x368>
 82209e4:	e0bff703 	ldbu	r2,-36(fp)
 82209e8:	1000031e 	bne	r2,zero,82209f8 <getPHYSpeed+0x35c>
 82209ec:	00820974 	movhi	r2,2085
 82209f0:	10b90b04 	addi	r2,r2,-7124
 82209f4:	00000806 	br	8220a18 <getPHYSpeed+0x37c>
 82209f8:	00820974 	movhi	r2,2085
 82209fc:	10b90c04 	addi	r2,r2,-7120
 8220a00:	00000506 	br	8220a18 <getPHYSpeed+0x37c>
 8220a04:	00820974 	movhi	r2,2085
 8220a08:	10b90e04 	addi	r2,r2,-7112
 8220a0c:	00000206 	br	8220a18 <getPHYSpeed+0x37c>
 8220a10:	00820974 	movhi	r2,2085
 8220a14:	10b90f04 	addi	r2,r2,-7108
 8220a18:	e0fff743 	ldbu	r3,-35(fp)
 8220a1c:	18c00058 	cmpnei	r3,r3,1
 8220a20:	1800031e 	bne	r3,zero,8220a30 <getPHYSpeed+0x394>
 8220a24:	00c20974 	movhi	r3,2085
 8220a28:	18f91104 	addi	r3,r3,-7100
 8220a2c:	00000206 	br	8220a38 <getPHYSpeed+0x39c>
 8220a30:	00c20974 	movhi	r3,2085
 8220a34:	18f91304 	addi	r3,r3,-7092
 8220a38:	180f883a 	mov	r7,r3
 8220a3c:	100d883a 	mov	r6,r2
 8220a40:	200b883a 	mov	r5,r4
 8220a44:	01020974 	movhi	r4,2085
 8220a48:	21395004 	addi	r4,r4,-6848
 8220a4c:	82033fc0 	call	82033fc <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        }
        return result;
 8220a50:	e0bff817 	ldw	r2,-32(fp)
 8220a54:	0001ae06 	br	8221110 <getPHYSpeed+0xa74>

    /* Not running simulation */
    #ifndef ALT_SIM_OPTIMIZE
	
		/* These variables declaration are here to avoid "warning: unused variable" message when compile for simulation */
		np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8220a58:	e0bffb17 	ldw	r2,-20(fp)
 8220a5c:	10800117 	ldw	r2,4(r2)
 8220a60:	10800217 	ldw	r2,8(r2)
 8220a64:	10800017 	ldw	r2,0(r2)
 8220a68:	e0bffe15 	stw	r2,-8(fp)
    
        /* if no PHY connected to the MAC */
        if(pphy == 0) {
 8220a6c:	e0bff917 	ldw	r2,-28(fp)
 8220a70:	1000491e 	bne	r2,zero,8220b98 <getPHYSpeed+0x4fc>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220a74:	00800044 	movi	r2,1
 8220a78:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 8220a7c:	00800044 	movi	r2,1
 8220a80:	e0bff745 	stb	r2,-35(fp)
            result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY;
 8220a84:	e0bff743 	ldbu	r2,-35(fp)
 8220a88:	10c0004c 	andi	r3,r2,1
 8220a8c:	e0bff703 	ldbu	r2,-36(fp)
 8220a90:	10800098 	cmpnei	r2,r2,2
 8220a94:	1000021e 	bne	r2,zero,8220aa0 <getPHYSpeed+0x404>
 8220a98:	00800084 	movi	r2,2
 8220a9c:	00000106 	br	8220aa4 <getPHYSpeed+0x408>
 8220aa0:	0005883a 	mov	r2,zero
 8220aa4:	1886b03a 	or	r3,r3,r2
 8220aa8:	e0bff703 	ldbu	r2,-36(fp)
 8220aac:	10800058 	cmpnei	r2,r2,1
 8220ab0:	1000021e 	bne	r2,zero,8220abc <getPHYSpeed+0x420>
 8220ab4:	00800104 	movi	r2,4
 8220ab8:	00000106 	br	8220ac0 <getPHYSpeed+0x424>
 8220abc:	0005883a 	mov	r2,zero
 8220ac0:	1886b03a 	or	r3,r3,r2
 8220ac4:	e0bff703 	ldbu	r2,-36(fp)
 8220ac8:	1000021e 	bne	r2,zero,8220ad4 <getPHYSpeed+0x438>
 8220acc:	00800204 	movi	r2,8
 8220ad0:	00000106 	br	8220ad8 <getPHYSpeed+0x43c>
 8220ad4:	0005883a 	mov	r2,zero
 8220ad8:	1886b03a 	or	r3,r3,r2
 8220adc:	e0bff703 	ldbu	r2,-36(fp)
 8220ae0:	108000d8 	cmpnei	r2,r2,3
 8220ae4:	1000021e 	bne	r2,zero,8220af0 <getPHYSpeed+0x454>
 8220ae8:	00800074 	movhi	r2,1
 8220aec:	00000106 	br	8220af4 <getPHYSpeed+0x458>
 8220af0:	0005883a 	mov	r2,zero
 8220af4:	1884b03a 	or	r2,r3,r2
 8220af8:	10800834 	orhi	r2,r2,32
 8220afc:	e0bff815 	stw	r2,-32(fp)
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - No PHY connected! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 8220b00:	e13ffd47 	ldb	r4,-11(fp)
 8220b04:	e17ffd07 	ldb	r5,-12(fp)
 8220b08:	e0bff703 	ldbu	r2,-36(fp)
 8220b0c:	108000a0 	cmpeqi	r2,r2,2
 8220b10:	10000e1e 	bne	r2,zero,8220b4c <getPHYSpeed+0x4b0>
 8220b14:	e0bff703 	ldbu	r2,-36(fp)
 8220b18:	10800060 	cmpeqi	r2,r2,1
 8220b1c:	1000081e 	bne	r2,zero,8220b40 <getPHYSpeed+0x4a4>
 8220b20:	e0bff703 	ldbu	r2,-36(fp)
 8220b24:	1000031e 	bne	r2,zero,8220b34 <getPHYSpeed+0x498>
 8220b28:	00820974 	movhi	r2,2085
 8220b2c:	10b90b04 	addi	r2,r2,-7124
 8220b30:	00000806 	br	8220b54 <getPHYSpeed+0x4b8>
 8220b34:	00820974 	movhi	r2,2085
 8220b38:	10b90c04 	addi	r2,r2,-7120
 8220b3c:	00000506 	br	8220b54 <getPHYSpeed+0x4b8>
 8220b40:	00820974 	movhi	r2,2085
 8220b44:	10b90e04 	addi	r2,r2,-7112
 8220b48:	00000206 	br	8220b54 <getPHYSpeed+0x4b8>
 8220b4c:	00820974 	movhi	r2,2085
 8220b50:	10b90f04 	addi	r2,r2,-7108
 8220b54:	e0fff743 	ldbu	r3,-35(fp)
 8220b58:	18c00058 	cmpnei	r3,r3,1
 8220b5c:	1800031e 	bne	r3,zero,8220b6c <getPHYSpeed+0x4d0>
 8220b60:	00c20974 	movhi	r3,2085
 8220b64:	18f91104 	addi	r3,r3,-7100
 8220b68:	00000206 	br	8220b74 <getPHYSpeed+0x4d8>
 8220b6c:	00c20974 	movhi	r3,2085
 8220b70:	18f91304 	addi	r3,r3,-7092
 8220b74:	d8c00015 	stw	r3,0(sp)
 8220b78:	100f883a 	mov	r7,r2
 8220b7c:	280d883a 	mov	r6,r5
 8220b80:	200b883a 	mov	r5,r4
 8220b84:	01020974 	movhi	r4,2085
 8220b88:	21396204 	addi	r4,r4,-6776
 8220b8c:	82033fc0 	call	82033fc <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
            return result;
 8220b90:	e0bff817 	ldw	r2,-32(fp)
 8220b94:	00015e06 	br	8221110 <getPHYSpeed+0xa74>
        }

		/* Small MAC */
		if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 8220b98:	e0bffa17 	ldw	r2,-24(fp)
 8220b9c:	10800003 	ldbu	r2,0(r2)
 8220ba0:	10803fcc 	andi	r2,r2,255
 8220ba4:	10800058 	cmpnei	r2,r2,1
 8220ba8:	1000081e 	bne	r2,zero,8220bcc <getPHYSpeed+0x530>
			alt_tse_phy_set_adv_1000(pphy, 0);
 8220bac:	000b883a 	mov	r5,zero
 8220bb0:	e13ff917 	ldw	r4,-28(fp)
 8220bb4:	82230680 	call	8223068 <alt_tse_phy_set_adv_1000>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 8220bb8:	01400134 	movhi	r5,4
 8220bbc:	29742404 	addi	r5,r5,-12144
 8220bc0:	e13ff917 	ldw	r4,-28(fp)
 8220bc4:	82227b40 	call	82227b4 <alt_tse_phy_restart_an>
 8220bc8:	00000f06 	br	8220c08 <getPHYSpeed+0x56c>
		}
		else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 8220bcc:	e0bffa17 	ldw	r2,-24(fp)
 8220bd0:	10800003 	ldbu	r2,0(r2)
 8220bd4:	10803fcc 	andi	r2,r2,255
 8220bd8:	10800098 	cmpnei	r2,r2,2
 8220bdc:	10000a1e 	bne	r2,zero,8220c08 <getPHYSpeed+0x56c>
			alt_tse_phy_set_adv_100(pphy, 0);
 8220be0:	000b883a 	mov	r5,zero
 8220be4:	e13ff917 	ldw	r4,-28(fp)
 8220be8:	822322c0 	call	822322c <alt_tse_phy_set_adv_100>
			alt_tse_phy_set_adv_10(pphy, 0);
 8220bec:	000b883a 	mov	r5,zero
 8220bf0:	e13ff917 	ldw	r4,-28(fp)
 8220bf4:	82234800 	call	8223480 <alt_tse_phy_set_adv_10>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 8220bf8:	01400134 	movhi	r5,4
 8220bfc:	29742404 	addi	r5,r5,-12144
 8220c00:	e13ff917 	ldw	r4,-28(fp)
 8220c04:	82227b40 	call	82227b4 <alt_tse_phy_restart_an>
		}
		
		/* check link connection for this PHY */
		if(alt_tse_phy_check_link(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD) == TSE_PHY_AN_NOT_COMPLETE) {
 8220c08:	01400134 	movhi	r5,4
 8220c0c:	29742404 	addi	r5,r5,-12144
 8220c10:	e13ff917 	ldw	r4,-28(fp)
 8220c14:	82229700 	call	8222970 <alt_tse_phy_check_link>
 8220c18:	10bfffd8 	cmpnei	r2,r2,-1
 8220c1c:	1000491e 	bne	r2,zero,8220d44 <getPHYSpeed+0x6a8>
			speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220c20:	00800044 	movi	r2,1
 8220c24:	e0bff705 	stb	r2,-36(fp)
			duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 8220c28:	00800044 	movi	r2,1
 8220c2c:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_AN_NOT_COMPLETE;
 8220c30:	e0bff743 	ldbu	r2,-35(fp)
 8220c34:	10c0004c 	andi	r3,r2,1
 8220c38:	e0bff703 	ldbu	r2,-36(fp)
 8220c3c:	10800098 	cmpnei	r2,r2,2
 8220c40:	1000021e 	bne	r2,zero,8220c4c <getPHYSpeed+0x5b0>
 8220c44:	00800084 	movi	r2,2
 8220c48:	00000106 	br	8220c50 <getPHYSpeed+0x5b4>
 8220c4c:	0005883a 	mov	r2,zero
 8220c50:	1886b03a 	or	r3,r3,r2
 8220c54:	e0bff703 	ldbu	r2,-36(fp)
 8220c58:	10800058 	cmpnei	r2,r2,1
 8220c5c:	1000021e 	bne	r2,zero,8220c68 <getPHYSpeed+0x5cc>
 8220c60:	00800104 	movi	r2,4
 8220c64:	00000106 	br	8220c6c <getPHYSpeed+0x5d0>
 8220c68:	0005883a 	mov	r2,zero
 8220c6c:	1886b03a 	or	r3,r3,r2
 8220c70:	e0bff703 	ldbu	r2,-36(fp)
 8220c74:	1000021e 	bne	r2,zero,8220c80 <getPHYSpeed+0x5e4>
 8220c78:	00800204 	movi	r2,8
 8220c7c:	00000106 	br	8220c84 <getPHYSpeed+0x5e8>
 8220c80:	0005883a 	mov	r2,zero
 8220c84:	1886b03a 	or	r3,r3,r2
 8220c88:	e0bff703 	ldbu	r2,-36(fp)
 8220c8c:	108000d8 	cmpnei	r2,r2,3
 8220c90:	1000021e 	bne	r2,zero,8220c9c <getPHYSpeed+0x600>
 8220c94:	00800074 	movhi	r2,1
 8220c98:	00000106 	br	8220ca0 <getPHYSpeed+0x604>
 8220c9c:	0005883a 	mov	r2,zero
 8220ca0:	1884b03a 	or	r2,r3,r2
 8220ca4:	10800234 	orhi	r2,r2,8
 8220ca8:	e0bff815 	stw	r2,-32(fp)
			tse_dprintf(3, "WARNING : PHY[%d.%d] - Auto-Negotiation not completed! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 8220cac:	e13ffd47 	ldb	r4,-11(fp)
 8220cb0:	e17ffd07 	ldb	r5,-12(fp)
 8220cb4:	e0bff703 	ldbu	r2,-36(fp)
 8220cb8:	108000a0 	cmpeqi	r2,r2,2
 8220cbc:	10000e1e 	bne	r2,zero,8220cf8 <getPHYSpeed+0x65c>
 8220cc0:	e0bff703 	ldbu	r2,-36(fp)
 8220cc4:	10800060 	cmpeqi	r2,r2,1
 8220cc8:	1000081e 	bne	r2,zero,8220cec <getPHYSpeed+0x650>
 8220ccc:	e0bff703 	ldbu	r2,-36(fp)
 8220cd0:	1000031e 	bne	r2,zero,8220ce0 <getPHYSpeed+0x644>
 8220cd4:	00820974 	movhi	r2,2085
 8220cd8:	10b90b04 	addi	r2,r2,-7124
 8220cdc:	00000806 	br	8220d00 <getPHYSpeed+0x664>
 8220ce0:	00820974 	movhi	r2,2085
 8220ce4:	10b90c04 	addi	r2,r2,-7120
 8220ce8:	00000506 	br	8220d00 <getPHYSpeed+0x664>
 8220cec:	00820974 	movhi	r2,2085
 8220cf0:	10b90e04 	addi	r2,r2,-7112
 8220cf4:	00000206 	br	8220d00 <getPHYSpeed+0x664>
 8220cf8:	00820974 	movhi	r2,2085
 8220cfc:	10b90f04 	addi	r2,r2,-7108
 8220d00:	e0fff743 	ldbu	r3,-35(fp)
 8220d04:	18c00058 	cmpnei	r3,r3,1
 8220d08:	1800031e 	bne	r3,zero,8220d18 <getPHYSpeed+0x67c>
 8220d0c:	00c20974 	movhi	r3,2085
 8220d10:	18f91104 	addi	r3,r3,-7100
 8220d14:	00000206 	br	8220d20 <getPHYSpeed+0x684>
 8220d18:	00c20974 	movhi	r3,2085
 8220d1c:	18f91304 	addi	r3,r3,-7092
 8220d20:	d8c00015 	stw	r3,0(sp)
 8220d24:	100f883a 	mov	r7,r2
 8220d28:	280d883a 	mov	r6,r5
 8220d2c:	200b883a 	mov	r5,r4
 8220d30:	01020974 	movhi	r4,2085
 8220d34:	21397304 	addi	r4,r4,-6708
 8220d38:	82033fc0 	call	82033fc <printf>
																			 speed == TSE_PHY_SPEED_100 ? "100" :
																			 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
																			 duplex == 1 ? "Full" : "Half");
			return result;
 8220d3c:	e0bff817 	ldw	r2,-32(fp)
 8220d40:	0000f306 	br	8221110 <getPHYSpeed+0xa74>
		}

        IOWR(&pmac_group_base->MDIO_ADDR1, 0, pphy->mdio_address);
 8220d44:	e0bffe17 	ldw	r2,-8(fp)
 8220d48:	10801004 	addi	r2,r2,64
 8220d4c:	e0fff917 	ldw	r3,-28(fp)
 8220d50:	18c00003 	ldbu	r3,0(r3)
 8220d54:	18c03fcc 	andi	r3,r3,255
 8220d58:	10c00035 	stwio	r3,0(r2)
        /* To enable PHY loopback */
        #if ENABLE_PHY_LOOPBACK
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Putting PHY in loopback\n", mac_group_index, mac_info_index);
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 1);   // enable PHY loopback
		#else
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 8220d5c:	d8000015 	stw	zero,0(sp)
 8220d60:	01c00044 	movi	r7,1
 8220d64:	01800384 	movi	r6,14
 8220d68:	000b883a 	mov	r5,zero
 8220d6c:	e13ff917 	ldw	r4,-28(fp)
 8220d70:	82211c40 	call	82211c4 <alt_tse_phy_wr_mdio_reg>
        #endif
       
        /* if PHY not found in profile */
        if(pphy->pphy_profile == 0) {
 8220d74:	e0bff917 	ldw	r2,-28(fp)
 8220d78:	10800517 	ldw	r2,20(r2)
 8220d7c:	10002b1e 	bne	r2,zero,8220e2c <getPHYSpeed+0x790>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not found in PHY profile\n", mac_group_index, mac_info_index);
 8220d80:	e0bffd47 	ldb	r2,-11(fp)
 8220d84:	e0fffd07 	ldb	r3,-12(fp)
 8220d88:	180d883a 	mov	r6,r3
 8220d8c:	100b883a 	mov	r5,r2
 8220d90:	01020974 	movhi	r4,2085
 8220d94:	21398704 	addi	r4,r4,-6628
 8220d98:	82033fc0 	call	82033fc <printf>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220d9c:	00800044 	movi	r2,1
 8220da0:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 8220da4:	00800044 	movi	r2,1
 8220da8:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY_PROFILE;
 8220dac:	e0bff743 	ldbu	r2,-35(fp)
 8220db0:	10c0004c 	andi	r3,r2,1
 8220db4:	e0bff703 	ldbu	r2,-36(fp)
 8220db8:	10800098 	cmpnei	r2,r2,2
 8220dbc:	1000021e 	bne	r2,zero,8220dc8 <getPHYSpeed+0x72c>
 8220dc0:	00800084 	movi	r2,2
 8220dc4:	00000106 	br	8220dcc <getPHYSpeed+0x730>
 8220dc8:	0005883a 	mov	r2,zero
 8220dcc:	1886b03a 	or	r3,r3,r2
 8220dd0:	e0bff703 	ldbu	r2,-36(fp)
 8220dd4:	10800058 	cmpnei	r2,r2,1
 8220dd8:	1000021e 	bne	r2,zero,8220de4 <getPHYSpeed+0x748>
 8220ddc:	00800104 	movi	r2,4
 8220de0:	00000106 	br	8220de8 <getPHYSpeed+0x74c>
 8220de4:	0005883a 	mov	r2,zero
 8220de8:	1886b03a 	or	r3,r3,r2
 8220dec:	e0bff703 	ldbu	r2,-36(fp)
 8220df0:	1000021e 	bne	r2,zero,8220dfc <getPHYSpeed+0x760>
 8220df4:	00800204 	movi	r2,8
 8220df8:	00000106 	br	8220e00 <getPHYSpeed+0x764>
 8220dfc:	0005883a 	mov	r2,zero
 8220e00:	1886b03a 	or	r3,r3,r2
 8220e04:	e0bff703 	ldbu	r2,-36(fp)
 8220e08:	108000d8 	cmpnei	r2,r2,3
 8220e0c:	1000021e 	bne	r2,zero,8220e18 <getPHYSpeed+0x77c>
 8220e10:	00800074 	movhi	r2,1
 8220e14:	00000106 	br	8220e1c <getPHYSpeed+0x780>
 8220e18:	0005883a 	mov	r2,zero
 8220e1c:	1884b03a 	or	r2,r3,r2
 8220e20:	10800134 	orhi	r2,r2,4
 8220e24:	e0bff815 	stw	r2,-32(fp)
 8220e28:	00009406 	br	822107c <getPHYSpeed+0x9e0>
        }
        // retrieve duplex information from PHY
		else
		{
			if(pphy->pphy_profile->link_status_read)
 8220e2c:	e0bff917 	ldw	r2,-28(fp)
 8220e30:	10800517 	ldw	r2,20(r2)
 8220e34:	10801817 	ldw	r2,96(r2)
 8220e38:	10002626 	beq	r2,zero,8220ed4 <getPHYSpeed+0x838>
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
 8220e3c:	e0bff917 	ldw	r2,-28(fp)
 8220e40:	10800517 	ldw	r2,20(r2)
 8220e44:	10801817 	ldw	r2,96(r2)
 8220e48:	e13ffe17 	ldw	r4,-8(fp)
 8220e4c:	103ee83a 	callr	r2
 8220e50:	e0bff815 	stw	r2,-32(fp)
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 8220e54:	e0bff817 	ldw	r2,-32(fp)
 8220e58:	1080008c 	andi	r2,r2,2
 8220e5c:	10000c1e 	bne	r2,zero,8220e90 <getPHYSpeed+0x7f4>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
 8220e60:	e0bff817 	ldw	r2,-32(fp)
 8220e64:	1080010c 	andi	r2,r2,4
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 8220e68:	1000071e 	bne	r2,zero,8220e88 <getPHYSpeed+0x7ec>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
 8220e6c:	e0bff817 	ldw	r2,-32(fp)
 8220e70:	1080020c 	andi	r2,r2,8
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 8220e74:	10000226 	beq	r2,zero,8220e80 <getPHYSpeed+0x7e4>
 8220e78:	0005883a 	mov	r2,zero
 8220e7c:	00000506 	br	8220e94 <getPHYSpeed+0x7f8>
 8220e80:	008000c4 	movi	r2,3
 8220e84:	00000306 	br	8220e94 <getPHYSpeed+0x7f8>
 8220e88:	00800044 	movi	r2,1
 8220e8c:	00000106 	br	8220e94 <getPHYSpeed+0x7f8>
 8220e90:	00800084 	movi	r2,2
 8220e94:	e0bff705 	stb	r2,-36(fp)
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
				duplex = (result & 0x01) ? TSE_PHY_DUPLEX_FULL : TSE_PHY_DUPLEX_HALF;
 8220e98:	e0bff817 	ldw	r2,-32(fp)
 8220e9c:	1080004c 	andi	r2,r2,1
 8220ea0:	1004c03a 	cmpne	r2,r2,zero
 8220ea4:	e0bff745 	stb	r2,-35(fp)
				
				if(result & ALT_TSE_E_INVALID_SPEED)
 8220ea8:	e0bff817 	ldw	r2,-32(fp)
 8220eac:	1080006c 	andhi	r2,r2,1
 8220eb0:	10007226 	beq	r2,zero,822107c <getPHYSpeed+0x9e0>
				{
					tse_dprintf(3, "WARNING : PHY[%d.%d] - Invalid speed read from PHY\n", mac_group_index, mac_info_index);
 8220eb4:	e0bffd47 	ldb	r2,-11(fp)
 8220eb8:	e0fffd07 	ldb	r3,-12(fp)
 8220ebc:	180d883a 	mov	r6,r3
 8220ec0:	100b883a 	mov	r5,r2
 8220ec4:	01020974 	movhi	r4,2085
 8220ec8:	21399504 	addi	r4,r4,-6572
 8220ecc:	82033fc0 	call	82033fc <printf>
 8220ed0:	00006a06 	br	822107c <getPHYSpeed+0x9e0>
				}
			}
			else if(pphy->pphy_profile->status_reg_location == 0)
 8220ed4:	e0bff917 	ldw	r2,-28(fp)
 8220ed8:	10800517 	ldw	r2,20(r2)
 8220edc:	10801583 	ldbu	r2,86(r2)
 8220ee0:	10803fcc 	andi	r2,r2,255
 8220ee4:	10002b1e 	bne	r2,zero,8220f94 <getPHYSpeed+0x8f8>
	        {
	            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY Specific Status register information not provided in profile\n", mac_group_index, mac_info_index);
 8220ee8:	e0bffd47 	ldb	r2,-11(fp)
 8220eec:	e0fffd07 	ldb	r3,-12(fp)
 8220ef0:	180d883a 	mov	r6,r3
 8220ef4:	100b883a 	mov	r5,r2
 8220ef8:	01020974 	movhi	r4,2085
 8220efc:	2139a204 	addi	r4,r4,-6520
 8220f00:	82033fc0 	call	82033fc <printf>
	            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220f04:	00800044 	movi	r2,1
 8220f08:	e0bff705 	stb	r2,-36(fp)
	            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 8220f0c:	00800044 	movi	r2,1
 8220f10:	e0bff745 	stb	r2,-35(fp)
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_PROFILE_INCORRECT_DEFINED;
 8220f14:	e0bff743 	ldbu	r2,-35(fp)
 8220f18:	10c0004c 	andi	r3,r2,1
 8220f1c:	e0bff703 	ldbu	r2,-36(fp)
 8220f20:	10800098 	cmpnei	r2,r2,2
 8220f24:	1000021e 	bne	r2,zero,8220f30 <getPHYSpeed+0x894>
 8220f28:	00800084 	movi	r2,2
 8220f2c:	00000106 	br	8220f34 <getPHYSpeed+0x898>
 8220f30:	0005883a 	mov	r2,zero
 8220f34:	1886b03a 	or	r3,r3,r2
 8220f38:	e0bff703 	ldbu	r2,-36(fp)
 8220f3c:	10800058 	cmpnei	r2,r2,1
 8220f40:	1000021e 	bne	r2,zero,8220f4c <getPHYSpeed+0x8b0>
 8220f44:	00800104 	movi	r2,4
 8220f48:	00000106 	br	8220f50 <getPHYSpeed+0x8b4>
 8220f4c:	0005883a 	mov	r2,zero
 8220f50:	1886b03a 	or	r3,r3,r2
 8220f54:	e0bff703 	ldbu	r2,-36(fp)
 8220f58:	1000021e 	bne	r2,zero,8220f64 <getPHYSpeed+0x8c8>
 8220f5c:	00800204 	movi	r2,8
 8220f60:	00000106 	br	8220f68 <getPHYSpeed+0x8cc>
 8220f64:	0005883a 	mov	r2,zero
 8220f68:	1886b03a 	or	r3,r3,r2
 8220f6c:	e0bff703 	ldbu	r2,-36(fp)
 8220f70:	108000d8 	cmpnei	r2,r2,3
 8220f74:	1000021e 	bne	r2,zero,8220f80 <getPHYSpeed+0x8e4>
 8220f78:	00800074 	movhi	r2,1
 8220f7c:	00000106 	br	8220f84 <getPHYSpeed+0x8e8>
 8220f80:	0005883a 	mov	r2,zero
 8220f84:	1884b03a 	or	r2,r3,r2
 8220f88:	108000b4 	orhi	r2,r2,2
 8220f8c:	e0bff815 	stw	r2,-32(fp)
 8220f90:	00003a06 	br	822107c <getPHYSpeed+0x9e0>
	        }
	        else
	        {
	            /* extract connection speed and duplex information */
	        	speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 8220f94:	e0bff917 	ldw	r2,-28(fp)
 8220f98:	10800517 	ldw	r2,20(r2)
 8220f9c:	10801583 	ldbu	r2,86(r2)
 8220fa0:	10c03fcc 	andi	r3,r2,255
 8220fa4:	e0bff917 	ldw	r2,-28(fp)
 8220fa8:	10800517 	ldw	r2,20(r2)
 8220fac:	108015c3 	ldbu	r2,87(r2)
 8220fb0:	10803fcc 	andi	r2,r2,255
 8220fb4:	01c00084 	movi	r7,2
 8220fb8:	100d883a 	mov	r6,r2
 8220fbc:	180b883a 	mov	r5,r3
 8220fc0:	e13ff917 	ldw	r4,-28(fp)
 8220fc4:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8220fc8:	e0bff705 	stb	r2,-36(fp)
	            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 8220fcc:	e0bff917 	ldw	r2,-28(fp)
 8220fd0:	10800517 	ldw	r2,20(r2)
 8220fd4:	10801583 	ldbu	r2,86(r2)
 8220fd8:	10c03fcc 	andi	r3,r2,255
 8220fdc:	e0bff917 	ldw	r2,-28(fp)
 8220fe0:	10800517 	ldw	r2,20(r2)
 8220fe4:	10801603 	ldbu	r2,88(r2)
 8220fe8:	10803fcc 	andi	r2,r2,255
 8220fec:	01c00044 	movi	r7,1
 8220ff0:	100d883a 	mov	r6,r2
 8220ff4:	180b883a 	mov	r5,r3
 8220ff8:	e13ff917 	ldw	r4,-28(fp)
 8220ffc:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8221000:	e0bff745 	stb	r2,-35(fp)
				
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 8221004:	e0bff743 	ldbu	r2,-35(fp)
 8221008:	10c0004c 	andi	r3,r2,1
 822100c:	e0bff703 	ldbu	r2,-36(fp)
 8221010:	10800098 	cmpnei	r2,r2,2
 8221014:	1000021e 	bne	r2,zero,8221020 <getPHYSpeed+0x984>
 8221018:	00800084 	movi	r2,2
 822101c:	00000106 	br	8221024 <getPHYSpeed+0x988>
 8221020:	0005883a 	mov	r2,zero
 8221024:	1886b03a 	or	r3,r3,r2
 8221028:	e0bff703 	ldbu	r2,-36(fp)
 822102c:	10800058 	cmpnei	r2,r2,1
 8221030:	1000021e 	bne	r2,zero,822103c <getPHYSpeed+0x9a0>
 8221034:	00800104 	movi	r2,4
 8221038:	00000106 	br	8221040 <getPHYSpeed+0x9a4>
 822103c:	0005883a 	mov	r2,zero
 8221040:	1886b03a 	or	r3,r3,r2
 8221044:	e0bff703 	ldbu	r2,-36(fp)
 8221048:	1000021e 	bne	r2,zero,8221054 <getPHYSpeed+0x9b8>
 822104c:	00800204 	movi	r2,8
 8221050:	00000106 	br	8221058 <getPHYSpeed+0x9bc>
 8221054:	0005883a 	mov	r2,zero
 8221058:	1886b03a 	or	r3,r3,r2
 822105c:	e0bff703 	ldbu	r2,-36(fp)
 8221060:	108000d8 	cmpnei	r2,r2,3
 8221064:	1000021e 	bne	r2,zero,8221070 <getPHYSpeed+0x9d4>
 8221068:	00800074 	movhi	r2,1
 822106c:	00000106 	br	8221074 <getPHYSpeed+0x9d8>
 8221070:	0005883a 	mov	r2,zero
 8221074:	1884b03a 	or	r2,r3,r2
 8221078:	e0bff815 	stw	r2,-32(fp)
        /* for simulation purpose, default to gigabit mode */
        speed = 1;
        duplex = 1;
    #endif

    tse_dprintf(5, "INFO    : PHY[%d.%d] - Speed = %s, Duplex = %s\n",  mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 822107c:	e13ffd47 	ldb	r4,-11(fp)
 8221080:	e17ffd07 	ldb	r5,-12(fp)
 8221084:	e0bff703 	ldbu	r2,-36(fp)
 8221088:	108000a0 	cmpeqi	r2,r2,2
 822108c:	10000e1e 	bne	r2,zero,82210c8 <getPHYSpeed+0xa2c>
 8221090:	e0bff703 	ldbu	r2,-36(fp)
 8221094:	10800060 	cmpeqi	r2,r2,1
 8221098:	1000081e 	bne	r2,zero,82210bc <getPHYSpeed+0xa20>
 822109c:	e0bff703 	ldbu	r2,-36(fp)
 82210a0:	1000031e 	bne	r2,zero,82210b0 <getPHYSpeed+0xa14>
 82210a4:	00820974 	movhi	r2,2085
 82210a8:	10b90b04 	addi	r2,r2,-7124
 82210ac:	00000806 	br	82210d0 <getPHYSpeed+0xa34>
 82210b0:	00820974 	movhi	r2,2085
 82210b4:	10b90c04 	addi	r2,r2,-7120
 82210b8:	00000506 	br	82210d0 <getPHYSpeed+0xa34>
 82210bc:	00820974 	movhi	r2,2085
 82210c0:	10b90e04 	addi	r2,r2,-7112
 82210c4:	00000206 	br	82210d0 <getPHYSpeed+0xa34>
 82210c8:	00820974 	movhi	r2,2085
 82210cc:	10b90f04 	addi	r2,r2,-7108
 82210d0:	e0fff743 	ldbu	r3,-35(fp)
 82210d4:	18c00058 	cmpnei	r3,r3,1
 82210d8:	1800031e 	bne	r3,zero,82210e8 <getPHYSpeed+0xa4c>
 82210dc:	00c20974 	movhi	r3,2085
 82210e0:	18f91104 	addi	r3,r3,-7100
 82210e4:	00000206 	br	82210f0 <getPHYSpeed+0xa54>
 82210e8:	00c20974 	movhi	r3,2085
 82210ec:	18f91304 	addi	r3,r3,-7092
 82210f0:	d8c00015 	stw	r3,0(sp)
 82210f4:	100f883a 	mov	r7,r2
 82210f8:	280d883a 	mov	r6,r5
 82210fc:	200b883a 	mov	r5,r4
 8221100:	01020974 	movhi	r4,2085
 8221104:	2139b904 	addi	r4,r4,-6428
 8221108:	82033fc0 	call	82033fc <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");

    return result;
 822110c:	e0bff817 	ldw	r2,-32(fp)
}
 8221110:	e037883a 	mov	sp,fp
 8221114:	dfc00117 	ldw	ra,4(sp)
 8221118:	df000017 	ldw	fp,0(sp)
 822111c:	dec00204 	addi	sp,sp,8
 8221120:	f800283a 	ret

08221124 <alt_tse_phy_rd_mdio_addr>:
/* @Function Description: Read MDIO address from the MDIO address1 register of first MAC within MAC group
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
 8221124:	defffd04 	addi	sp,sp,-12
 8221128:	df000215 	stw	fp,8(sp)
 822112c:	df000204 	addi	fp,sp,8
 8221130:	e13fff15 	stw	r4,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8221134:	e0bfff17 	ldw	r2,-4(fp)
 8221138:	10800617 	ldw	r2,24(r2)
 822113c:	10800317 	ldw	r2,12(r2)
 8221140:	10800117 	ldw	r2,4(r2)
 8221144:	10800217 	ldw	r2,8(r2)
 8221148:	10800017 	ldw	r2,0(r2)
 822114c:	e0bffe15 	stw	r2,-8(fp)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
 8221150:	e0bffe17 	ldw	r2,-8(fp)
 8221154:	10801004 	addi	r2,r2,64
 8221158:	10800037 	ldwio	r2,0(r2)
}
 822115c:	e037883a 	mov	sp,fp
 8221160:	df000017 	ldw	fp,0(sp)
 8221164:	dec00104 	addi	sp,sp,4
 8221168:	f800283a 	ret

0822116c <alt_tse_phy_wr_mdio_addr>:
 * @API Type:           Internal
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
 822116c:	defffc04 	addi	sp,sp,-16
 8221170:	df000315 	stw	fp,12(sp)
 8221174:	df000304 	addi	fp,sp,12
 8221178:	e13ffe15 	stw	r4,-8(fp)
 822117c:	2805883a 	mov	r2,r5
 8221180:	e0bfff05 	stb	r2,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8221184:	e0bffe17 	ldw	r2,-8(fp)
 8221188:	10800617 	ldw	r2,24(r2)
 822118c:	10800317 	ldw	r2,12(r2)
 8221190:	10800117 	ldw	r2,4(r2)
 8221194:	10800217 	ldw	r2,8(r2)
 8221198:	10800017 	ldw	r2,0(r2)
 822119c:	e0bffd15 	stw	r2,-12(fp)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
 82211a0:	e0bffd17 	ldw	r2,-12(fp)
 82211a4:	10801004 	addi	r2,r2,64
 82211a8:	e0ffff03 	ldbu	r3,-4(fp)
 82211ac:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 82211b0:	0005883a 	mov	r2,zero
}
 82211b4:	e037883a 	mov	sp,fp
 82211b8:	df000017 	ldw	fp,0(sp)
 82211bc:	dec00104 	addi	sp,sp,4
 82211c0:	f800283a 	ret

082211c4 <alt_tse_phy_wr_mdio_reg>:
  * @param  bit_length       number of bits to be written to the register.
  * @param  data             data to be written to the register at specific bit location of register.
  * @return SUCCESS 
  */
alt_32 alt_tse_phy_wr_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length, alt_u16 data)
{
 82211c4:	defff604 	addi	sp,sp,-40
 82211c8:	df000915 	stw	fp,36(sp)
 82211cc:	df000904 	addi	fp,sp,36
 82211d0:	e13ffb15 	stw	r4,-20(fp)
 82211d4:	3009883a 	mov	r4,r6
 82211d8:	3807883a 	mov	r3,r7
 82211dc:	e0800117 	ldw	r2,4(fp)
 82211e0:	e17ffc05 	stb	r5,-16(fp)
 82211e4:	e13ffd05 	stb	r4,-12(fp)
 82211e8:	e0fffe05 	stb	r3,-8(fp)
 82211ec:	e0bfff0d 	sth	r2,-4(fp)
    
    alt_u16 temp_data;
    alt_u16 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 82211f0:	e0bffb17 	ldw	r2,-20(fp)
 82211f4:	10800617 	ldw	r2,24(r2)
 82211f8:	10800317 	ldw	r2,12(r2)
 82211fc:	10800117 	ldw	r2,4(r2)
 8221200:	10800217 	ldw	r2,8(r2)
 8221204:	10800017 	ldw	r2,0(r2)
 8221208:	e0bff915 	stw	r2,-28(fp)
    
    bit_mask = 0x00;
 822120c:	e03ff70d 	sth	zero,-36(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 8221210:	e03ff815 	stw	zero,-32(fp)
 8221214:	00000906 	br	822123c <alt_tse_phy_wr_mdio_reg+0x78>
    {
        bit_mask <<= 1;
 8221218:	e0bff70b 	ldhu	r2,-36(fp)
 822121c:	1085883a 	add	r2,r2,r2
 8221220:	e0bff70d 	sth	r2,-36(fp)
        bit_mask |= 0x01;        
 8221224:	e0bff70b 	ldhu	r2,-36(fp)
 8221228:	10800054 	ori	r2,r2,1
 822122c:	e0bff70d 	sth	r2,-36(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 8221230:	e0bff817 	ldw	r2,-32(fp)
 8221234:	10800044 	addi	r2,r2,1
 8221238:	e0bff815 	stw	r2,-32(fp)
 822123c:	e0bffe03 	ldbu	r2,-8(fp)
 8221240:	e0fff817 	ldw	r3,-32(fp)
 8221244:	18bff416 	blt	r3,r2,8221218 <alt_tse_phy_wr_mdio_reg+0x54>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* shifting mask to left by bit_num */
    bit_mask <<= lsb_num;
 8221248:	e0fff70b 	ldhu	r3,-36(fp)
 822124c:	e0bffd03 	ldbu	r2,-12(fp)
 8221250:	1884983a 	sll	r2,r3,r2
 8221254:	e0bff70d 	sth	r2,-36(fp)

    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 8221258:	e0bff917 	ldw	r2,-28(fp)
 822125c:	10c0a004 	addi	r3,r2,640
 8221260:	e0bffc03 	ldbu	r2,-16(fp)
 8221264:	1085883a 	add	r2,r2,r2
 8221268:	1085883a 	add	r2,r2,r2
 822126c:	1885883a 	add	r2,r3,r2
 8221270:	10800037 	ldwio	r2,0(r2)
 8221274:	e0bffa0d 	sth	r2,-24(fp)
    
    /* clear bits to be written */
    temp_data &= ~bit_mask;
 8221278:	e0bff70b 	ldhu	r2,-36(fp)
 822127c:	0084303a 	nor	r2,zero,r2
 8221280:	1007883a 	mov	r3,r2
 8221284:	e0bffa0b 	ldhu	r2,-24(fp)
 8221288:	1884703a 	and	r2,r3,r2
 822128c:	e0bffa0d 	sth	r2,-24(fp)
    
    /* OR-ed together corresponding bits data */
    temp_data |= ((data << lsb_num) & bit_mask);    
 8221290:	e0ffff0b 	ldhu	r3,-4(fp)
 8221294:	e0bffd03 	ldbu	r2,-12(fp)
 8221298:	1884983a 	sll	r2,r3,r2
 822129c:	1007883a 	mov	r3,r2
 82212a0:	e0bff70b 	ldhu	r2,-36(fp)
 82212a4:	1884703a 	and	r2,r3,r2
 82212a8:	1007883a 	mov	r3,r2
 82212ac:	e0bffa0b 	ldhu	r2,-24(fp)
 82212b0:	1884b03a 	or	r2,r3,r2
 82212b4:	e0bffa0d 	sth	r2,-24(fp)
    
    /* write data to MDIO register */
    IOWR(&pmac->mdio1, reg_num, temp_data);
 82212b8:	e0bff917 	ldw	r2,-28(fp)
 82212bc:	10c0a004 	addi	r3,r2,640
 82212c0:	e0bffc03 	ldbu	r2,-16(fp)
 82212c4:	1085883a 	add	r2,r2,r2
 82212c8:	1085883a 	add	r2,r2,r2
 82212cc:	1885883a 	add	r2,r3,r2
 82212d0:	e0fffa0b 	ldhu	r3,-24(fp)
 82212d4:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 82212d8:	0005883a 	mov	r2,zero
    
}
 82212dc:	e037883a 	mov	sp,fp
 82212e0:	df000017 	ldw	fp,0(sp)
 82212e4:	dec00104 	addi	sp,sp,4
 82212e8:	f800283a 	ret

082212ec <alt_tse_phy_rd_mdio_reg>:
 * @param  bit_length       number of bits to be read from the register.
 * @return data read from MDIO register 
 */

alt_u32 alt_tse_phy_rd_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length)
{
 82212ec:	defff704 	addi	sp,sp,-36
 82212f0:	df000815 	stw	fp,32(sp)
 82212f4:	df000804 	addi	fp,sp,32
 82212f8:	e13ffc15 	stw	r4,-16(fp)
 82212fc:	2809883a 	mov	r4,r5
 8221300:	3007883a 	mov	r3,r6
 8221304:	3805883a 	mov	r2,r7
 8221308:	e13ffd05 	stb	r4,-12(fp)
 822130c:	e0fffe05 	stb	r3,-8(fp)
 8221310:	e0bfff05 	stb	r2,-4(fp)
    alt_u16 temp_data;
    alt_u32 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8221314:	e0bffc17 	ldw	r2,-16(fp)
 8221318:	10800617 	ldw	r2,24(r2)
 822131c:	10800317 	ldw	r2,12(r2)
 8221320:	10800117 	ldw	r2,4(r2)
 8221324:	10800217 	ldw	r2,8(r2)
 8221328:	10800017 	ldw	r2,0(r2)
 822132c:	e0bffa15 	stw	r2,-24(fp)
    
    bit_mask = 0x00;
 8221330:	e03ff815 	stw	zero,-32(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 8221334:	e03ff915 	stw	zero,-28(fp)
 8221338:	00000906 	br	8221360 <alt_tse_phy_rd_mdio_reg+0x74>
    {
        bit_mask <<= 1;
 822133c:	e0bff817 	ldw	r2,-32(fp)
 8221340:	1085883a 	add	r2,r2,r2
 8221344:	e0bff815 	stw	r2,-32(fp)
        bit_mask |= 0x01;        
 8221348:	e0bff817 	ldw	r2,-32(fp)
 822134c:	10800054 	ori	r2,r2,1
 8221350:	e0bff815 	stw	r2,-32(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 8221354:	e0bff917 	ldw	r2,-28(fp)
 8221358:	10800044 	addi	r2,r2,1
 822135c:	e0bff915 	stw	r2,-28(fp)
 8221360:	e0bfff03 	ldbu	r2,-4(fp)
 8221364:	e0fff917 	ldw	r3,-28(fp)
 8221368:	18bff416 	blt	r3,r2,822133c <alt_tse_phy_rd_mdio_reg+0x50>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 822136c:	e0bffa17 	ldw	r2,-24(fp)
 8221370:	10c0a004 	addi	r3,r2,640
 8221374:	e0bffd03 	ldbu	r2,-12(fp)
 8221378:	1085883a 	add	r2,r2,r2
 822137c:	1085883a 	add	r2,r2,r2
 8221380:	1885883a 	add	r2,r3,r2
 8221384:	10800037 	ldwio	r2,0(r2)
 8221388:	e0bffb0d 	sth	r2,-20(fp)
    
    /* shifting read data */
    temp_data >>= lsb_num;
 822138c:	e0fffb0b 	ldhu	r3,-20(fp)
 8221390:	e0bffe03 	ldbu	r2,-8(fp)
 8221394:	1885d83a 	sra	r2,r3,r2
 8221398:	e0bffb0d 	sth	r2,-20(fp)
    
    return (temp_data & bit_mask);
 822139c:	e0fffb0b 	ldhu	r3,-20(fp)
 82213a0:	e0bff817 	ldw	r2,-32(fp)
 82213a4:	1884703a 	and	r2,r3,r2
}
 82213a8:	e037883a 	mov	sp,fp
 82213ac:	df000017 	ldw	fp,0(sp)
 82213b0:	dec00104 	addi	sp,sp,4
 82213b4:	f800283a 	ret

082213b8 <alt_tse_phy_add_profile_default>:
 * @param pmac  N/A
 * @return      Number of PHY in profile
 * 
 * User might add their own PHY by calling alt_tse_phy_add_profile()
 */
alt_32 alt_tse_phy_add_profile_default() {
 82213b8:	deff9a04 	addi	sp,sp,-408
 82213bc:	dfc06515 	stw	ra,404(sp)
 82213c0:	df006415 	stw	fp,400(sp)
 82213c4:	df006404 	addi	fp,sp,400
        
    /* ------------------------------ */
    /* Marvell PHY on PHYWORKX board  */
    /* ------------------------------ */
    
    alt_tse_phy_profile MV88E1111 = {"Marvell 88E1111",      /* Marvell 88E1111                                  */
 82213c8:	e0ff9c04 	addi	r3,fp,-400
 82213cc:	00801904 	movi	r2,100
 82213d0:	100d883a 	mov	r6,r2
 82213d4:	000b883a 	mov	r5,zero
 82213d8:	1809883a 	mov	r4,r3
 82213dc:	82032100 	call	8203210 <memset>
 82213e0:	009d9cb4 	movhi	r2,30322
 82213e4:	10985344 	addi	r2,r2,24909
 82213e8:	e0bf9c15 	stw	r2,-400(fp)
 82213ec:	00881b34 	movhi	r2,8300
 82213f0:	109b1944 	addi	r2,r2,27749
 82213f4:	e0bf9d15 	stw	r2,-396(fp)
 82213f8:	008c5174 	movhi	r2,12613
 82213fc:	108e0e04 	addi	r2,r2,14392
 8221400:	e0bf9e15 	stw	r2,-392(fp)
 8221404:	00800c74 	movhi	r2,49
 8221408:	108c4c44 	addi	r2,r2,12593
 822140c:	e0bf9f15 	stw	r2,-388(fp)
 8221410:	e0bfa004 	addi	r2,fp,-384
 8221414:	00c01004 	movi	r3,64
 8221418:	180d883a 	mov	r6,r3
 822141c:	000b883a 	mov	r5,zero
 8221420:	1009883a 	mov	r4,r2
 8221424:	82032100 	call	8203210 <memset>
 8221428:	009410c4 	movi	r2,20547
 822142c:	e0bfb015 	stw	r2,-320(fp)
 8221430:	00800304 	movi	r2,12
 8221434:	e0bfb105 	stb	r2,-316(fp)
 8221438:	00800084 	movi	r2,2
 822143c:	e0bfb145 	stb	r2,-315(fp)
 8221440:	00800444 	movi	r2,17
 8221444:	e0bfb185 	stb	r2,-314(fp)
 8221448:	00800384 	movi	r2,14
 822144c:	e0bfb1c5 	stb	r2,-313(fp)
 8221450:	00800344 	movi	r2,13
 8221454:	e0bfb205 	stb	r2,-312(fp)
 8221458:	00800284 	movi	r2,10
 822145c:	e0bfb245 	stb	r2,-311(fp)
 8221460:	008208b4 	movhi	r2,2082
 8221464:	108f8204 	addi	r2,r2,15880
 8221468:	e0bfb315 	stw	r2,-308(fp)
    
    /* ---------------------------------- */
    /* Marvell Quad PHY on PHYWORKX board */
    /* ---------------------------------- */
    
    alt_tse_phy_profile MV88E1145 = {"Marvell Quad PHY 88E1145",      /* Marvell 88E1145                                  */
 822146c:	e0bfb504 	addi	r2,fp,-300
 8221470:	00c01904 	movi	r3,100
 8221474:	180d883a 	mov	r6,r3
 8221478:	000b883a 	mov	r5,zero
 822147c:	1009883a 	mov	r4,r2
 8221480:	82032100 	call	8203210 <memset>
 8221484:	009d9cb4 	movhi	r2,30322
 8221488:	10985344 	addi	r2,r2,24909
 822148c:	e0bfb515 	stw	r2,-300(fp)
 8221490:	00881b34 	movhi	r2,8300
 8221494:	109b1944 	addi	r2,r2,27749
 8221498:	e0bfb615 	stw	r2,-296(fp)
 822149c:	00991874 	movhi	r2,25697
 82214a0:	109d5444 	addi	r2,r2,30033
 82214a4:	e0bfb715 	stw	r2,-292(fp)
 82214a8:	00965234 	movhi	r2,22856
 82214ac:	10940804 	addi	r2,r2,20512
 82214b0:	e0bfb815 	stw	r2,-288(fp)
 82214b4:	00914e34 	movhi	r2,17720
 82214b8:	108e0804 	addi	r2,r2,14368
 82214bc:	e0bfb915 	stw	r2,-284(fp)
 82214c0:	008d4d34 	movhi	r2,13620
 82214c4:	108c4c44 	addi	r2,r2,12593
 82214c8:	e0bfba15 	stw	r2,-280(fp)
 82214cc:	e03fbb15 	stw	zero,-276(fp)
 82214d0:	e03fbc15 	stw	zero,-272(fp)
 82214d4:	e03fbd15 	stw	zero,-268(fp)
 82214d8:	e03fbe15 	stw	zero,-264(fp)
 82214dc:	e03fbf15 	stw	zero,-260(fp)
 82214e0:	e03fc015 	stw	zero,-256(fp)
 82214e4:	e03fc115 	stw	zero,-252(fp)
 82214e8:	e03fc215 	stw	zero,-248(fp)
 82214ec:	e03fc315 	stw	zero,-244(fp)
 82214f0:	e03fc415 	stw	zero,-240(fp)
 82214f4:	e03fc515 	stw	zero,-236(fp)
 82214f8:	e03fc615 	stw	zero,-232(fp)
 82214fc:	e03fc715 	stw	zero,-228(fp)
 8221500:	e03fc815 	stw	zero,-224(fp)
 8221504:	009410c4 	movi	r2,20547
 8221508:	e0bfc915 	stw	r2,-220(fp)
 822150c:	00800344 	movi	r2,13
 8221510:	e0bfca05 	stb	r2,-216(fp)
 8221514:	00800084 	movi	r2,2
 8221518:	e0bfca45 	stb	r2,-215(fp)
 822151c:	00800444 	movi	r2,17
 8221520:	e0bfca85 	stb	r2,-214(fp)
 8221524:	00800384 	movi	r2,14
 8221528:	e0bfcac5 	stb	r2,-213(fp)
 822152c:	00800344 	movi	r2,13
 8221530:	e0bfcb05 	stb	r2,-212(fp)
 8221534:	00800284 	movi	r2,10
 8221538:	e0bfcb45 	stb	r2,-211(fp)
 822153c:	008208b4 	movhi	r2,2082
 8221540:	108f8204 	addi	r2,r2,15880
 8221544:	e0bfcc15 	stw	r2,-208(fp)
                      
    /* ------------------------------ */
    /* National PHY on PHYWORKX board */
    /* ------------------------------ */  
    
    alt_tse_phy_profile DP83865 = {"National DP83865",     /* National DP83865                                 */
 8221548:	e0bfce04 	addi	r2,fp,-200
 822154c:	00c01904 	movi	r3,100
 8221550:	180d883a 	mov	r6,r3
 8221554:	000b883a 	mov	r5,zero
 8221558:	1009883a 	mov	r4,r2
 822155c:	82032100 	call	8203210 <memset>
 8221560:	009a5d34 	movhi	r2,26996
 8221564:	10985384 	addi	r2,r2,24910
 8221568:	e0bfce15 	stw	r2,-200(fp)
 822156c:	009b1874 	movhi	r2,27745
 8221570:	109b9bc4 	addi	r2,r2,28271
 8221574:	e0bfcf15 	stw	r2,-196(fp)
 8221578:	008e1434 	movhi	r2,14416
 822157c:	10910804 	addi	r2,r2,17440
 8221580:	e0bfd015 	stw	r2,-192(fp)
 8221584:	008d4db4 	movhi	r2,13622
 8221588:	108e0cc4 	addi	r2,r2,14387
 822158c:	e0bfd115 	stw	r2,-188(fp)
 8221590:	e03fd215 	stw	zero,-184(fp)
 8221594:	e0bfd304 	addi	r2,fp,-180
 8221598:	00c00f04 	movi	r3,60
 822159c:	180d883a 	mov	r6,r3
 82215a0:	000b883a 	mov	r5,zero
 82215a4:	1009883a 	mov	r4,r2
 82215a8:	82032100 	call	8203210 <memset>
 82215ac:	00800234 	movhi	r2,8
 82215b0:	108005c4 	addi	r2,r2,23
 82215b4:	e0bfe215 	stw	r2,-120(fp)
 82215b8:	008001c4 	movi	r2,7
 82215bc:	e0bfe305 	stb	r2,-116(fp)
 82215c0:	00800284 	movi	r2,10
 82215c4:	e0bfe345 	stb	r2,-115(fp)
 82215c8:	00800444 	movi	r2,17
 82215cc:	e0bfe385 	stb	r2,-114(fp)
 82215d0:	008000c4 	movi	r2,3
 82215d4:	e0bfe3c5 	stb	r2,-113(fp)
 82215d8:	00800044 	movi	r2,1
 82215dc:	e0bfe405 	stb	r2,-112(fp)
 82215e0:	00800084 	movi	r2,2
 82215e4:	e0bfe445 	stb	r2,-111(fp)
                      
    /* -------------------------------------- */
    /* National 10/100 PHY on PHYWORKX board  */
    /* -------------------------------------- */ 
                      
    alt_tse_phy_profile DP83848C = {"National DP83848C",  /* National DP83848C                                          */
 82215e8:	00820974 	movhi	r2,2085
 82215ec:	10b9c504 	addi	r2,r2,-6380
 82215f0:	e0ffe704 	addi	r3,fp,-100
 82215f4:	1009883a 	mov	r4,r2
 82215f8:	00801904 	movi	r2,100
 82215fc:	100d883a 	mov	r6,r2
 8221600:	200b883a 	mov	r5,r4
 8221604:	1809883a 	mov	r4,r3
 8221608:	8202f6c0 	call	8202f6c <memcpy>
						   0,                              /* No function pointer configure National DP83848C            */
						   &DP83848C_link_status_read      /* Function pointer to read from PHY specific status register */           
                          };
                      
    /* add supported PHY to profile */                          
    alt_tse_phy_add_profile(&MV88E1111);
 822160c:	e13f9c04 	addi	r4,fp,-400
 8221610:	821f5280 	call	821f528 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&MV88E1145);
 8221614:	e0bfb504 	addi	r2,fp,-300
 8221618:	1009883a 	mov	r4,r2
 822161c:	821f5280 	call	821f528 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83865);
 8221620:	e0bfce04 	addi	r2,fp,-200
 8221624:	1009883a 	mov	r4,r2
 8221628:	821f5280 	call	821f528 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83848C);
 822162c:	e0bfe704 	addi	r2,fp,-100
 8221630:	1009883a 	mov	r4,r2
 8221634:	821f5280 	call	821f528 <alt_tse_phy_add_profile>
    
    
    return phy_profile_count;
 8221638:	d0a07f03 	ldbu	r2,-32260(gp)
 822163c:	10803fcc 	andi	r2,r2,255
}
 8221640:	e037883a 	mov	sp,fp
 8221644:	dfc00117 	ldw	ra,4(sp)
 8221648:	df000017 	ldw	fp,0(sp)
 822164c:	dec00204 	addi	sp,sp,8
 8221650:	f800283a 	ret

08221654 <alt_tse_phy_print_profile>:
/* @Function Description: Display PHYs available in profile
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      Number of PHY in profile
 */
alt_32 alt_tse_phy_print_profile() {
 8221654:	defffd04 	addi	sp,sp,-12
 8221658:	dfc00215 	stw	ra,8(sp)
 822165c:	df000115 	stw	fp,4(sp)
 8221660:	df000104 	addi	fp,sp,4
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
 8221664:	d0a07f03 	ldbu	r2,-32260(gp)
 8221668:	10803fcc 	andi	r2,r2,255
 822166c:	100b883a 	mov	r5,r2
 8221670:	01020974 	movhi	r4,2085
 8221674:	2139de04 	addi	r4,r4,-6280
 8221678:	821f1e00 	call	821f1e0 <no_printf>
    
    for(i = 0; i < phy_profile_count; i++)
 822167c:	e03fff05 	stb	zero,-4(fp)
 8221680:	00006d06 	br	8221838 <alt_tse_phy_print_profile+0x1e4>
    {
        tse_dprintf(6, "Profile No.%2d   :\n", i);
 8221684:	e0bfff07 	ldb	r2,-4(fp)
 8221688:	100b883a 	mov	r5,r2
 822168c:	01020974 	movhi	r4,2085
 8221690:	2139ed04 	addi	r4,r4,-6220
 8221694:	821f1e00 	call	821f1e0 <no_printf>
        tse_dprintf(6, "PHY Name        : %s\n", pphy_profiles[i]->name);
 8221698:	e0ffff07 	ldb	r3,-4(fp)
 822169c:	008209b4 	movhi	r2,2086
 82216a0:	10b71c04 	addi	r2,r2,-9104
 82216a4:	18c7883a 	add	r3,r3,r3
 82216a8:	18c7883a 	add	r3,r3,r3
 82216ac:	10c5883a 	add	r2,r2,r3
 82216b0:	10800017 	ldw	r2,0(r2)
 82216b4:	100b883a 	mov	r5,r2
 82216b8:	01020974 	movhi	r4,2085
 82216bc:	2139f204 	addi	r4,r4,-6200
 82216c0:	821f1e00 	call	821f1e0 <no_printf>
   
        tse_dprintf(6, "PHY OUI         : 0x%06x\n", (int)pphy_profiles[i]->oui);
 82216c4:	e0ffff07 	ldb	r3,-4(fp)
 82216c8:	008209b4 	movhi	r2,2086
 82216cc:	10b71c04 	addi	r2,r2,-9104
 82216d0:	18c7883a 	add	r3,r3,r3
 82216d4:	18c7883a 	add	r3,r3,r3
 82216d8:	10c5883a 	add	r2,r2,r3
 82216dc:	10800017 	ldw	r2,0(r2)
 82216e0:	10801417 	ldw	r2,80(r2)
 82216e4:	100b883a 	mov	r5,r2
 82216e8:	01020974 	movhi	r4,2085
 82216ec:	2139f804 	addi	r4,r4,-6176
 82216f0:	821f1e00 	call	821f1e0 <no_printf>
        tse_dprintf(6, "PHY Model Num.  : 0x%02x\n", pphy_profiles[i]->model_number);
 82216f4:	e0ffff07 	ldb	r3,-4(fp)
 82216f8:	008209b4 	movhi	r2,2086
 82216fc:	10b71c04 	addi	r2,r2,-9104
 8221700:	18c7883a 	add	r3,r3,r3
 8221704:	18c7883a 	add	r3,r3,r3
 8221708:	10c5883a 	add	r2,r2,r3
 822170c:	10800017 	ldw	r2,0(r2)
 8221710:	10801503 	ldbu	r2,84(r2)
 8221714:	10803fcc 	andi	r2,r2,255
 8221718:	100b883a 	mov	r5,r2
 822171c:	01020974 	movhi	r4,2085
 8221720:	2139ff04 	addi	r4,r4,-6148
 8221724:	821f1e00 	call	821f1e0 <no_printf>
        tse_dprintf(6, "PHY Rev. Num.   : 0x%02x\n", pphy_profiles[i]->revision_number);
 8221728:	e0ffff07 	ldb	r3,-4(fp)
 822172c:	008209b4 	movhi	r2,2086
 8221730:	10b71c04 	addi	r2,r2,-9104
 8221734:	18c7883a 	add	r3,r3,r3
 8221738:	18c7883a 	add	r3,r3,r3
 822173c:	10c5883a 	add	r2,r2,r3
 8221740:	10800017 	ldw	r2,0(r2)
 8221744:	10801543 	ldbu	r2,85(r2)
 8221748:	10803fcc 	andi	r2,r2,255
 822174c:	100b883a 	mov	r5,r2
 8221750:	01020974 	movhi	r4,2085
 8221754:	213a0604 	addi	r4,r4,-6120
 8221758:	821f1e00 	call	821f1e0 <no_printf>
        
        tse_dprintf(6, "Status Register : 0x%02x\n", pphy_profiles[i]->status_reg_location); 
 822175c:	e0ffff07 	ldb	r3,-4(fp)
 8221760:	008209b4 	movhi	r2,2086
 8221764:	10b71c04 	addi	r2,r2,-9104
 8221768:	18c7883a 	add	r3,r3,r3
 822176c:	18c7883a 	add	r3,r3,r3
 8221770:	10c5883a 	add	r2,r2,r3
 8221774:	10800017 	ldw	r2,0(r2)
 8221778:	10801583 	ldbu	r2,86(r2)
 822177c:	10803fcc 	andi	r2,r2,255
 8221780:	100b883a 	mov	r5,r2
 8221784:	01020974 	movhi	r4,2085
 8221788:	213a0d04 	addi	r4,r4,-6092
 822178c:	821f1e00 	call	821f1e0 <no_printf>
        
        tse_dprintf(6, "Speed Bit       : %d\n", pphy_profiles[i]->speed_lsb_location);
 8221790:	e0ffff07 	ldb	r3,-4(fp)
 8221794:	008209b4 	movhi	r2,2086
 8221798:	10b71c04 	addi	r2,r2,-9104
 822179c:	18c7883a 	add	r3,r3,r3
 82217a0:	18c7883a 	add	r3,r3,r3
 82217a4:	10c5883a 	add	r2,r2,r3
 82217a8:	10800017 	ldw	r2,0(r2)
 82217ac:	108015c3 	ldbu	r2,87(r2)
 82217b0:	10803fcc 	andi	r2,r2,255
 82217b4:	100b883a 	mov	r5,r2
 82217b8:	01020974 	movhi	r4,2085
 82217bc:	213a1404 	addi	r4,r4,-6064
 82217c0:	821f1e00 	call	821f1e0 <no_printf>
        
        tse_dprintf(6, "Duplex Bit      : %d\n", pphy_profiles[i]->duplex_bit_location);
 82217c4:	e0ffff07 	ldb	r3,-4(fp)
 82217c8:	008209b4 	movhi	r2,2086
 82217cc:	10b71c04 	addi	r2,r2,-9104
 82217d0:	18c7883a 	add	r3,r3,r3
 82217d4:	18c7883a 	add	r3,r3,r3
 82217d8:	10c5883a 	add	r2,r2,r3
 82217dc:	10800017 	ldw	r2,0(r2)
 82217e0:	10801603 	ldbu	r2,88(r2)
 82217e4:	10803fcc 	andi	r2,r2,255
 82217e8:	100b883a 	mov	r5,r2
 82217ec:	01020974 	movhi	r4,2085
 82217f0:	213a1a04 	addi	r4,r4,-6040
 82217f4:	821f1e00 	call	821f1e0 <no_printf>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 82217f8:	e0ffff07 	ldb	r3,-4(fp)
 82217fc:	008209b4 	movhi	r2,2086
 8221800:	10b71c04 	addi	r2,r2,-9104
 8221804:	18c7883a 	add	r3,r3,r3
 8221808:	18c7883a 	add	r3,r3,r3
 822180c:	10c5883a 	add	r2,r2,r3
 8221810:	10800017 	ldw	r2,0(r2)
 8221814:	10801643 	ldbu	r2,89(r2)
 8221818:	10803fcc 	andi	r2,r2,255
 822181c:	100b883a 	mov	r5,r2
 8221820:	01020974 	movhi	r4,2085
 8221824:	213a2004 	addi	r4,r4,-6016
 8221828:	821f1e00 	call	821f1e0 <no_printf>
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
    
    for(i = 0; i < phy_profile_count; i++)
 822182c:	e0bfff03 	ldbu	r2,-4(fp)
 8221830:	10800044 	addi	r2,r2,1
 8221834:	e0bfff05 	stb	r2,-4(fp)
 8221838:	e0ffff07 	ldb	r3,-4(fp)
 822183c:	d0a07f03 	ldbu	r2,-32260(gp)
 8221840:	10803fcc 	andi	r2,r2,255
 8221844:	18bf8f16 	blt	r3,r2,8221684 <alt_tse_phy_print_profile+0x30>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 
    }
    
    return phy_profile_count;
 8221848:	d0a07f03 	ldbu	r2,-32260(gp)
 822184c:	10803fcc 	andi	r2,r2,255
}
 8221850:	e037883a 	mov	sp,fp
 8221854:	dfc00117 	ldw	ra,4(sp)
 8221858:	df000017 	ldw	fp,0(sp)
 822185c:	dec00204 	addi	sp,sp,8
 8221860:	f800283a 	ret

08221864 <alt_tse_mac_group_init>:
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      return SUCCESS
 *              return ALTERA_TSE_SYSTEM_DEF_ERROR if alt_tse_system_info structure definition error
 */
alt_32 alt_tse_mac_group_init() {
 8221864:	defffa04 	addi	sp,sp,-24
 8221868:	dfc00515 	stw	ra,20(sp)
 822186c:	df000415 	stw	fp,16(sp)
 8221870:	df000404 	addi	fp,sp,16
    
	alt_8 i;
	alt_8 j;
    
    alt_tse_mac_group *pmac_group = 0;
 8221874:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
 8221878:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_system_info *psys = 0;
 822187c:	e03fff15 	stw	zero,-4(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
 8221880:	d0207f45 	stb	zero,-32259(gp)
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 8221884:	e03ffc05 	stb	zero,-16(fp)
 8221888:	00019506 	br	8221ee0 <alt_tse_mac_group_init+0x67c>
        psys = &tse_mac_device[i];
 822188c:	e0bffc07 	ldb	r2,-16(fp)
 8221890:	10c01224 	muli	r3,r2,72
 8221894:	00820974 	movhi	r2,2085
 8221898:	1087da04 	addi	r2,r2,8040
 822189c:	1885883a 	add	r2,r3,r2
 82218a0:	e0bfff15 	stw	r2,-4(fp)

        if((psys->tse_sgdma_tx != 0) && (psys->tse_sgdma_rx != 0)) {    	
 82218a4:	e0bfff17 	ldw	r2,-4(fp)
 82218a8:	10800517 	ldw	r2,20(r2)
 82218ac:	10018926 	beq	r2,zero,8221ed4 <alt_tse_mac_group_init+0x670>
 82218b0:	e0bfff17 	ldw	r2,-4(fp)
 82218b4:	10800617 	ldw	r2,24(r2)
 82218b8:	10018626 	beq	r2,zero,8221ed4 <alt_tse_mac_group_init+0x670>
            tse_dprintf(5, "INFO    : TSE MAC %d found at address 0x%08x\n", mac_group_count, (int) psys->tse_mac_base);
 82218bc:	d0a07f43 	ldbu	r2,-32259(gp)
 82218c0:	10c03fcc 	andi	r3,r2,255
 82218c4:	e0bfff17 	ldw	r2,-4(fp)
 82218c8:	10800017 	ldw	r2,0(r2)
 82218cc:	100d883a 	mov	r6,r2
 82218d0:	180b883a 	mov	r5,r3
 82218d4:	01020974 	movhi	r4,2085
 82218d8:	213a2604 	addi	r4,r4,-5992
 82218dc:	82033fc0 	call	82033fc <printf>
            
            /* Allocate memory for the structure */
            pmac_group = (alt_tse_mac_group *) malloc(sizeof(alt_tse_mac_group));
 82218e0:	01000504 	movi	r4,20
 82218e4:	824b6ec0 	call	824b6ec <malloc>
 82218e8:	e0bffd15 	stw	r2,-12(fp)
            if(!pmac_group) {
 82218ec:	e0bffd17 	ldw	r2,-12(fp)
 82218f0:	1000081e 	bne	r2,zero,8221914 <alt_tse_mac_group_init+0xb0>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]\n", mac_group_count);
 82218f4:	d0a07f43 	ldbu	r2,-32259(gp)
 82218f8:	10803fcc 	andi	r2,r2,255
 82218fc:	100b883a 	mov	r5,r2
 8221900:	01020974 	movhi	r4,2085
 8221904:	213a3204 	addi	r4,r4,-5944
 8221908:	82033fc0 	call	82033fc <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 822190c:	00bfffc4 	movi	r2,-1
 8221910:	00017806 	br	8221ef4 <alt_tse_mac_group_init+0x690>
            }
           
            /* Non-multi-channel MAC considered as 1 channel */
            if(psys->tse_multichannel_mac) {
 8221914:	e0bfff17 	ldw	r2,-4(fp)
 8221918:	108002c3 	ldbu	r2,11(r2)
 822191c:	10803fcc 	andi	r2,r2,255
 8221920:	10001226 	beq	r2,zero,822196c <alt_tse_mac_group_init+0x108>
                pmac_group->channel = psys->tse_num_of_channel;
 8221924:	e0bfff17 	ldw	r2,-4(fp)
 8221928:	10c00303 	ldbu	r3,12(r2)
 822192c:	e0bffd17 	ldw	r2,-12(fp)
 8221930:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = Yes\n");
 8221934:	01020974 	movhi	r4,2085
 8221938:	213a4004 	addi	r4,r4,-5888
 822193c:	821f1e00 	call	821f1e0 <no_printf>
                tse_dprintf(6, "INFO    : Number of channel        = %d\n", pmac_group->channel);
 8221940:	e0bffd17 	ldw	r2,-12(fp)
 8221944:	10800003 	ldbu	r2,0(r2)
 8221948:	10803fcc 	andi	r2,r2,255
 822194c:	100b883a 	mov	r5,r2
 8221950:	01020974 	movhi	r4,2085
 8221954:	213a4b04 	addi	r4,r4,-5844
 8221958:	821f1e00 	call	821f1e0 <no_printf>
            	tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 822195c:	01020974 	movhi	r4,2085
 8221960:	213a5604 	addi	r4,r4,-5800
 8221964:	821f1e00 	call	821f1e0 <no_printf>
 8221968:	00001f06 	br	82219e8 <alt_tse_mac_group_init+0x184>
            }
            else if(psys->tse_mdio_shared) {
 822196c:	e0bfff17 	ldw	r2,-4(fp)
 8221970:	10800343 	ldbu	r2,13(r2)
 8221974:	10803fcc 	andi	r2,r2,255
 8221978:	10001226 	beq	r2,zero,82219c4 <alt_tse_mac_group_init+0x160>
                pmac_group->channel = psys->tse_number_of_mac_mdio_shared;
 822197c:	e0bfff17 	ldw	r2,-4(fp)
 8221980:	10c00383 	ldbu	r3,14(r2)
 8221984:	e0bffd17 	ldw	r2,-12(fp)
 8221988:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 822198c:	01020974 	movhi	r4,2085
 8221990:	213a6104 	addi	r4,r4,-5756
 8221994:	821f1e00 	call	821f1e0 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 8221998:	01020974 	movhi	r4,2085
 822199c:	213a5604 	addi	r4,r4,-5800
 82219a0:	821f1e00 	call	821f1e0 <no_printf>
                tse_dprintf(6, "INFO    : Number of MAC Share MDIO = %d\n", pmac_group->channel);
 82219a4:	e0bffd17 	ldw	r2,-12(fp)
 82219a8:	10800003 	ldbu	r2,0(r2)
 82219ac:	10803fcc 	andi	r2,r2,255
 82219b0:	100b883a 	mov	r5,r2
 82219b4:	01020974 	movhi	r4,2085
 82219b8:	213a6c04 	addi	r4,r4,-5712
 82219bc:	821f1e00 	call	821f1e0 <no_printf>
 82219c0:	00000906 	br	82219e8 <alt_tse_mac_group_init+0x184>
            }
            else {
                pmac_group->channel = 1;
 82219c4:	e0bffd17 	ldw	r2,-12(fp)
 82219c8:	00c00044 	movi	r3,1
 82219cc:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 82219d0:	01020974 	movhi	r4,2085
 82219d4:	213a6104 	addi	r4,r4,-5756
 82219d8:	821f1e00 	call	821f1e0 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
 82219dc:	01020974 	movhi	r4,2085
 82219e0:	213a7704 	addi	r4,r4,-5668
 82219e4:	821f1e00 	call	821f1e0 <no_printf>
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 82219e8:	e03ffc45 	stb	zero,-15(fp)
 82219ec:	00012206 	br	8221e78 <alt_tse_mac_group_init+0x614>
                /* Allocate memory for the structure */
                pmac_info = (alt_tse_mac_info *) malloc(sizeof(alt_tse_mac_info));
 82219f0:	01000404 	movi	r4,16
 82219f4:	824b6ec0 	call	824b6ec <malloc>
 82219f8:	e0bffe15 	stw	r2,-8(fp)
                if(!pmac_info) {
 82219fc:	e0bffe17 	ldw	r2,-8(fp)
 8221a00:	10000a1e 	bne	r2,zero,8221a2c <alt_tse_mac_group_init+0x1c8>
                    tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]->pmac_info[%d]\n", mac_group_count, j);
 8221a04:	d0a07f43 	ldbu	r2,-32259(gp)
 8221a08:	10803fcc 	andi	r2,r2,255
 8221a0c:	e0fffc47 	ldb	r3,-15(fp)
 8221a10:	180d883a 	mov	r6,r3
 8221a14:	100b883a 	mov	r5,r2
 8221a18:	01020974 	movhi	r4,2085
 8221a1c:	213a8204 	addi	r4,r4,-5624
 8221a20:	82033fc0 	call	82033fc <printf>
                    return ALTERA_TSE_MALLOC_FAILED;
 8221a24:	00bfffc4 	movi	r2,-1
 8221a28:	00013206 	br	8221ef4 <alt_tse_mac_group_init+0x690>
                }
                
                pmac_info->pmac_group = pmac_group;
 8221a2c:	e0bffe17 	ldw	r2,-8(fp)
 8221a30:	e0fffd17 	ldw	r3,-12(fp)
 8221a34:	10c00315 	stw	r3,12(r2)
                
                pmac_info->pphy_info = 0;
 8221a38:	e0bffe17 	ldw	r2,-8(fp)
 8221a3c:	10000115 	stw	zero,4(r2)
                
                pmac_info->psys_info = &tse_mac_device[i + j];
 8221a40:	e0fffc07 	ldb	r3,-16(fp)
 8221a44:	e0bffc47 	ldb	r2,-15(fp)
 8221a48:	1885883a 	add	r2,r3,r2
 8221a4c:	10c01224 	muli	r3,r2,72
 8221a50:	00820974 	movhi	r2,2085
 8221a54:	1087da04 	addi	r2,r2,8040
 8221a58:	1887883a 	add	r3,r3,r2
 8221a5c:	e0bffe17 	ldw	r2,-8(fp)
 8221a60:	10c00215 	stw	r3,8(r2)
                
                /* check to make sure the alt_tse_system_info defined correctly or has been defined */
                if((pmac_info->psys_info->tse_sgdma_tx == 0) || (pmac_info->psys_info->tse_sgdma_rx == 0)){                	
 8221a64:	e0bffe17 	ldw	r2,-8(fp)
 8221a68:	10800217 	ldw	r2,8(r2)
 8221a6c:	10800517 	ldw	r2,20(r2)
 8221a70:	10000426 	beq	r2,zero,8221a84 <alt_tse_mac_group_init+0x220>
 8221a74:	e0bffe17 	ldw	r2,-8(fp)
 8221a78:	10800217 	ldw	r2,8(r2)
 8221a7c:	10800617 	ldw	r2,24(r2)
 8221a80:	1000091e 	bne	r2,zero,8221aa8 <alt_tse_mac_group_init+0x244>
                    tse_dprintf(2, "ERROR   : tse_mac_device[%d] does not defined correctly!\n", i + j);
 8221a84:	e0fffc07 	ldb	r3,-16(fp)
 8221a88:	e0bffc47 	ldb	r2,-15(fp)
 8221a8c:	1885883a 	add	r2,r3,r2
 8221a90:	100b883a 	mov	r5,r2
 8221a94:	01020974 	movhi	r4,2085
 8221a98:	213a9404 	addi	r4,r4,-5552
 8221a9c:	82033fc0 	call	82033fc <printf>
                    return ALTERA_TSE_SYSTEM_DEF_ERROR;
 8221aa0:	00bfffc4 	movi	r2,-1
 8221aa4:	00011306 	br	8221ef4 <alt_tse_mac_group_init+0x690>
                }
                
                /* MAC type detection */
                if(pmac_info->psys_info->tse_en_maclite) {
 8221aa8:	e0bffe17 	ldw	r2,-8(fp)
 8221aac:	10800217 	ldw	r2,8(r2)
 8221ab0:	10800243 	ldbu	r2,9(r2)
 8221ab4:	10803fcc 	andi	r2,r2,255
 8221ab8:	10000d26 	beq	r2,zero,8221af0 <alt_tse_mac_group_init+0x28c>
                    if(pmac_info->psys_info->tse_maclite_gige) {
 8221abc:	e0bffe17 	ldw	r2,-8(fp)
 8221ac0:	10800217 	ldw	r2,8(r2)
 8221ac4:	10800283 	ldbu	r2,10(r2)
 8221ac8:	10803fcc 	andi	r2,r2,255
 8221acc:	10000426 	beq	r2,zero,8221ae0 <alt_tse_mac_group_init+0x27c>
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_1000;
 8221ad0:	e0bffe17 	ldw	r2,-8(fp)
 8221ad4:	00c00084 	movi	r3,2
 8221ad8:	10c00005 	stb	r3,0(r2)
 8221adc:	00000606 	br	8221af8 <alt_tse_mac_group_init+0x294>
                    }
                    else {
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_10_100;
 8221ae0:	e0bffe17 	ldw	r2,-8(fp)
 8221ae4:	00c00044 	movi	r3,1
 8221ae8:	10c00005 	stb	r3,0(r2)
 8221aec:	00000206 	br	8221af8 <alt_tse_mac_group_init+0x294>
                    }
                }
                else {
                    pmac_info->mac_type = ALTERA_TSE_FULL_MAC;                    
 8221af0:	e0bffe17 	ldw	r2,-8(fp)
 8221af4:	10000005 	stb	zero,0(r2)
                }
                
                if((pmac_info->psys_info->tse_mdio_shared) && (!pmac_info->psys_info->tse_multichannel_mac)){
 8221af8:	e0bffe17 	ldw	r2,-8(fp)
 8221afc:	10800217 	ldw	r2,8(r2)
 8221b00:	10800343 	ldbu	r2,13(r2)
 8221b04:	10803fcc 	andi	r2,r2,255
 8221b08:	10006626 	beq	r2,zero,8221ca4 <alt_tse_mac_group_init+0x440>
 8221b0c:	e0bffe17 	ldw	r2,-8(fp)
 8221b10:	10800217 	ldw	r2,8(r2)
 8221b14:	108002c3 	ldbu	r2,11(r2)
 8221b18:	10803fcc 	andi	r2,r2,255
 8221b1c:	1000611e 	bne	r2,zero,8221ca4 <alt_tse_mac_group_init+0x440>
                	tse_dprintf(6, "INFO    : MAC %2d Address           = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 8221b20:	e0fffc47 	ldb	r3,-15(fp)
 8221b24:	e0bffe17 	ldw	r2,-8(fp)
 8221b28:	10800217 	ldw	r2,8(r2)
 8221b2c:	10800017 	ldw	r2,0(r2)
 8221b30:	100d883a 	mov	r6,r2
 8221b34:	180b883a 	mov	r5,r3
 8221b38:	01020974 	movhi	r4,2085
 8221b3c:	213aa304 	addi	r4,r4,-5492
 8221b40:	821f1e00 	call	821f1e0 <no_printf>
                    tse_dprintf(6, "INFO    : MAC %2d Device            = tse_mac_device[%d]\n", j, i + j);
 8221b44:	e13ffc47 	ldb	r4,-15(fp)
 8221b48:	e0fffc07 	ldb	r3,-16(fp)
 8221b4c:	e0bffc47 	ldb	r2,-15(fp)
 8221b50:	1885883a 	add	r2,r3,r2
 8221b54:	100d883a 	mov	r6,r2
 8221b58:	200b883a 	mov	r5,r4
 8221b5c:	01020974 	movhi	r4,2085
 8221b60:	213aaf04 	addi	r4,r4,-5444
 8221b64:	821f1e00 	call	821f1e0 <no_printf>
                    
                	switch(pmac_info->mac_type) {
 8221b68:	e0bffe17 	ldw	r2,-8(fp)
 8221b6c:	10800003 	ldbu	r2,0(r2)
 8221b70:	10803fcc 	andi	r2,r2,255
 8221b74:	10c00060 	cmpeqi	r3,r2,1
 8221b78:	18000c1e 	bne	r3,zero,8221bac <alt_tse_mac_group_init+0x348>
 8221b7c:	10c000a0 	cmpeqi	r3,r2,2
 8221b80:	1800021e 	bne	r3,zero,8221b8c <alt_tse_mac_group_init+0x328>
 8221b84:	10001126 	beq	r2,zero,8221bcc <alt_tse_mac_group_init+0x368>
 8221b88:	00001806 	br	8221bec <alt_tse_mac_group_init+0x388>
                        case ALTERA_TSE_MACLITE_1000:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "1000 Mbps Small MAC");
 8221b8c:	e0bffc47 	ldb	r2,-15(fp)
 8221b90:	01820974 	movhi	r6,2085
 8221b94:	31babe04 	addi	r6,r6,-5384
 8221b98:	100b883a 	mov	r5,r2
 8221b9c:	01020974 	movhi	r4,2085
 8221ba0:	213ac304 	addi	r4,r4,-5364
 8221ba4:	821f1e00 	call	821f1e0 <no_printf>
                            break;
 8221ba8:	00001806 	br	8221c0c <alt_tse_mac_group_init+0x3a8>
                        case ALTERA_TSE_MACLITE_10_100:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100 Mbps Small MAC");
 8221bac:	e0bffc47 	ldb	r2,-15(fp)
 8221bb0:	01820974 	movhi	r6,2085
 8221bb4:	31bace04 	addi	r6,r6,-5320
 8221bb8:	100b883a 	mov	r5,r2
 8221bbc:	01020974 	movhi	r4,2085
 8221bc0:	213ac304 	addi	r4,r4,-5364
 8221bc4:	821f1e00 	call	821f1e0 <no_printf>
                            break;
 8221bc8:	00001006 	br	8221c0c <alt_tse_mac_group_init+0x3a8>
                        case ALTERA_TSE_FULL_MAC:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100/1000 Ethernet MAC");
 8221bcc:	e0bffc47 	ldb	r2,-15(fp)
 8221bd0:	01820974 	movhi	r6,2085
 8221bd4:	31bad404 	addi	r6,r6,-5296
 8221bd8:	100b883a 	mov	r5,r2
 8221bdc:	01020974 	movhi	r4,2085
 8221be0:	213ac304 	addi	r4,r4,-5364
 8221be4:	821f1e00 	call	821f1e0 <no_printf>
                            break;
 8221be8:	00000806 	br	8221c0c <alt_tse_mac_group_init+0x3a8>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
 8221bec:	e0bffc47 	ldb	r2,-15(fp)
 8221bf0:	01820974 	movhi	r6,2085
 8221bf4:	31b90c04 	addi	r6,r6,-7120
 8221bf8:	100b883a 	mov	r5,r2
 8221bfc:	01020974 	movhi	r4,2085
 8221c00:	213ac304 	addi	r4,r4,-5364
 8221c04:	821f1e00 	call	821f1e0 <no_printf>
                            break;
 8221c08:	0001883a 	nop
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
 8221c0c:	e0bffe17 	ldw	r2,-8(fp)
 8221c10:	10800217 	ldw	r2,8(r2)
 8221c14:	108003c3 	ldbu	r2,15(r2)
 8221c18:	10803fcc 	andi	r2,r2,255
 8221c1c:	10008b26 	beq	r2,zero,8221e4c <alt_tse_mac_group_init+0x5e8>
                        tse_dprintf(6, "INFO    : PCS %2d Enable            = %s\n", j, pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 8221c20:	e0fffc47 	ldb	r3,-15(fp)
 8221c24:	e0bffe17 	ldw	r2,-8(fp)
 8221c28:	10800217 	ldw	r2,8(r2)
 8221c2c:	108003c3 	ldbu	r2,15(r2)
 8221c30:	10803fcc 	andi	r2,r2,255
 8221c34:	10000326 	beq	r2,zero,8221c44 <alt_tse_mac_group_init+0x3e0>
 8221c38:	00820974 	movhi	r2,2085
 8221c3c:	10badb04 	addi	r2,r2,-5268
 8221c40:	00000206 	br	8221c4c <alt_tse_mac_group_init+0x3e8>
 8221c44:	00820974 	movhi	r2,2085
 8221c48:	10badc04 	addi	r2,r2,-5264
 8221c4c:	100d883a 	mov	r6,r2
 8221c50:	180b883a 	mov	r5,r3
 8221c54:	01020974 	movhi	r4,2085
 8221c58:	213add04 	addi	r4,r4,-5260
 8221c5c:	821f1e00 	call	821f1e0 <no_printf>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
 8221c60:	e0fffc47 	ldb	r3,-15(fp)
 8221c64:	e0bffe17 	ldw	r2,-8(fp)
 8221c68:	10800217 	ldw	r2,8(r2)
 8221c6c:	10800403 	ldbu	r2,16(r2)
 8221c70:	10803fcc 	andi	r2,r2,255
 8221c74:	10000326 	beq	r2,zero,8221c84 <alt_tse_mac_group_init+0x420>
 8221c78:	00820974 	movhi	r2,2085
 8221c7c:	10badb04 	addi	r2,r2,-5268
 8221c80:	00000206 	br	8221c8c <alt_tse_mac_group_init+0x428>
 8221c84:	00820974 	movhi	r2,2085
 8221c88:	10badc04 	addi	r2,r2,-5264
 8221c8c:	100d883a 	mov	r6,r2
 8221c90:	180b883a 	mov	r5,r3
 8221c94:	01020974 	movhi	r4,2085
 8221c98:	213ae804 	addi	r4,r4,-5216
 8221c9c:	821f1e00 	call	821f1e0 <no_printf>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
                            break;
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
 8221ca0:	00006a06 	br	8221e4c <alt_tse_mac_group_init+0x5e8>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
                    }
                }
                else {
                	/* display only once for all MAC, except shared MDIO MACs */
	                if(j == 0) {
 8221ca4:	e0bffc47 	ldb	r2,-15(fp)
 8221ca8:	1000421e 	bne	r2,zero,8221db4 <alt_tse_mac_group_init+0x550>
	                    switch(pmac_info->mac_type) {
 8221cac:	e0bffe17 	ldw	r2,-8(fp)
 8221cb0:	10800003 	ldbu	r2,0(r2)
 8221cb4:	10803fcc 	andi	r2,r2,255
 8221cb8:	10c00060 	cmpeqi	r3,r2,1
 8221cbc:	18000a1e 	bne	r3,zero,8221ce8 <alt_tse_mac_group_init+0x484>
 8221cc0:	10c000a0 	cmpeqi	r3,r2,2
 8221cc4:	1800021e 	bne	r3,zero,8221cd0 <alt_tse_mac_group_init+0x46c>
 8221cc8:	10000d26 	beq	r2,zero,8221d00 <alt_tse_mac_group_init+0x49c>
 8221ccc:	00001206 	br	8221d18 <alt_tse_mac_group_init+0x4b4>
	                        case ALTERA_TSE_MACLITE_1000:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "1000 Mbps Small MAC");
 8221cd0:	01420974 	movhi	r5,2085
 8221cd4:	297abe04 	addi	r5,r5,-5384
 8221cd8:	01020974 	movhi	r4,2085
 8221cdc:	213af304 	addi	r4,r4,-5172
 8221ce0:	821f1e00 	call	821f1e0 <no_printf>
	                            break;
 8221ce4:	00001206 	br	8221d30 <alt_tse_mac_group_init+0x4cc>
	                        case ALTERA_TSE_MACLITE_10_100:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100 Mbps Small MAC");
 8221ce8:	01420974 	movhi	r5,2085
 8221cec:	297ace04 	addi	r5,r5,-5320
 8221cf0:	01020974 	movhi	r4,2085
 8221cf4:	213af304 	addi	r4,r4,-5172
 8221cf8:	821f1e00 	call	821f1e0 <no_printf>
	                            break;
 8221cfc:	00000c06 	br	8221d30 <alt_tse_mac_group_init+0x4cc>
	                        case ALTERA_TSE_FULL_MAC:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100/1000 Ethernet MAC");
 8221d00:	01420974 	movhi	r5,2085
 8221d04:	297ad404 	addi	r5,r5,-5296
 8221d08:	01020974 	movhi	r4,2085
 8221d0c:	213af304 	addi	r4,r4,-5172
 8221d10:	821f1e00 	call	821f1e0 <no_printf>
	                            break;
 8221d14:	00000606 	br	8221d30 <alt_tse_mac_group_init+0x4cc>
	                        default :
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "Unknown");
 8221d18:	01420974 	movhi	r5,2085
 8221d1c:	29790c04 	addi	r5,r5,-7120
 8221d20:	01020974 	movhi	r4,2085
 8221d24:	213af304 	addi	r4,r4,-5172
 8221d28:	821f1e00 	call	821f1e0 <no_printf>
                                    break;
 8221d2c:	0001883a 	nop
			    }
	                    
	                    if(pmac_info->psys_info->tse_pcs_ena) {
 8221d30:	e0bffe17 	ldw	r2,-8(fp)
 8221d34:	10800217 	ldw	r2,8(r2)
 8221d38:	108003c3 	ldbu	r2,15(r2)
 8221d3c:	10803fcc 	andi	r2,r2,255
 8221d40:	10001c26 	beq	r2,zero,8221db4 <alt_tse_mac_group_init+0x550>
	                        tse_dprintf(6, "INFO    : PCS Enable               = %s\n", pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 8221d44:	e0bffe17 	ldw	r2,-8(fp)
 8221d48:	10800217 	ldw	r2,8(r2)
 8221d4c:	108003c3 	ldbu	r2,15(r2)
 8221d50:	10803fcc 	andi	r2,r2,255
 8221d54:	10000326 	beq	r2,zero,8221d64 <alt_tse_mac_group_init+0x500>
 8221d58:	00820974 	movhi	r2,2085
 8221d5c:	10badb04 	addi	r2,r2,-5268
 8221d60:	00000206 	br	8221d6c <alt_tse_mac_group_init+0x508>
 8221d64:	00820974 	movhi	r2,2085
 8221d68:	10badc04 	addi	r2,r2,-5264
 8221d6c:	100b883a 	mov	r5,r2
 8221d70:	01020974 	movhi	r4,2085
 8221d74:	213afe04 	addi	r4,r4,-5128
 8221d78:	821f1e00 	call	821f1e0 <no_printf>
	                        tse_dprintf(6, "INFO    : PCS SGMII Enable         = %s\n", pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");	                        
 8221d7c:	e0bffe17 	ldw	r2,-8(fp)
 8221d80:	10800217 	ldw	r2,8(r2)
 8221d84:	10800403 	ldbu	r2,16(r2)
 8221d88:	10803fcc 	andi	r2,r2,255
 8221d8c:	10000326 	beq	r2,zero,8221d9c <alt_tse_mac_group_init+0x538>
 8221d90:	00820974 	movhi	r2,2085
 8221d94:	10badb04 	addi	r2,r2,-5268
 8221d98:	00000206 	br	8221da4 <alt_tse_mac_group_init+0x540>
 8221d9c:	00820974 	movhi	r2,2085
 8221da0:	10badc04 	addi	r2,r2,-5264
 8221da4:	100b883a 	mov	r5,r2
 8221da8:	01020974 	movhi	r4,2085
 8221dac:	213b0904 	addi	r4,r4,-5084
 8221db0:	821f1e00 	call	821f1e0 <no_printf>
	                    }
	                }
	                
                	if(pmac_info->psys_info->tse_multichannel_mac) {
 8221db4:	e0bffe17 	ldw	r2,-8(fp)
 8221db8:	10800217 	ldw	r2,8(r2)
 8221dbc:	108002c3 	ldbu	r2,11(r2)
 8221dc0:	10803fcc 	andi	r2,r2,255
 8221dc4:	10001326 	beq	r2,zero,8221e14 <alt_tse_mac_group_init+0x5b0>
                		tse_dprintf(6, "INFO    : Channel %2d Address       = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 8221dc8:	e0fffc47 	ldb	r3,-15(fp)
 8221dcc:	e0bffe17 	ldw	r2,-8(fp)
 8221dd0:	10800217 	ldw	r2,8(r2)
 8221dd4:	10800017 	ldw	r2,0(r2)
 8221dd8:	100d883a 	mov	r6,r2
 8221ddc:	180b883a 	mov	r5,r3
 8221de0:	01020974 	movhi	r4,2085
 8221de4:	213b1404 	addi	r4,r4,-5040
 8221de8:	821f1e00 	call	821f1e0 <no_printf>
	                    tse_dprintf(6, "INFO    : Channel %2d Device        = tse_mac_device[%d]\n", j, i + j);
 8221dec:	e13ffc47 	ldb	r4,-15(fp)
 8221df0:	e0fffc07 	ldb	r3,-16(fp)
 8221df4:	e0bffc47 	ldb	r2,-15(fp)
 8221df8:	1885883a 	add	r2,r3,r2
 8221dfc:	100d883a 	mov	r6,r2
 8221e00:	200b883a 	mov	r5,r4
 8221e04:	01020974 	movhi	r4,2085
 8221e08:	213b2004 	addi	r4,r4,-4992
 8221e0c:	821f1e00 	call	821f1e0 <no_printf>
 8221e10:	00000e06 	br	8221e4c <alt_tse_mac_group_init+0x5e8>
	            	}                
	                else {
	                    tse_dprintf(6, "INFO    : MAC Address              = 0x%08x\n", (int) pmac_info->psys_info->tse_mac_base);
 8221e14:	e0bffe17 	ldw	r2,-8(fp)
 8221e18:	10800217 	ldw	r2,8(r2)
 8221e1c:	10800017 	ldw	r2,0(r2)
 8221e20:	100b883a 	mov	r5,r2
 8221e24:	01020974 	movhi	r4,2085
 8221e28:	213b2f04 	addi	r4,r4,-4932
 8221e2c:	821f1e00 	call	821f1e0 <no_printf>
	                    tse_dprintf(6, "INFO    : MAC Device               = tse_mac_device[%d]\n", i + j);
 8221e30:	e0fffc07 	ldb	r3,-16(fp)
 8221e34:	e0bffc47 	ldb	r2,-15(fp)
 8221e38:	1885883a 	add	r2,r3,r2
 8221e3c:	100b883a 	mov	r5,r2
 8221e40:	01020974 	movhi	r4,2085
 8221e44:	213b3b04 	addi	r4,r4,-4884
 8221e48:	821f1e00 	call	821f1e0 <no_printf>
	                }
                }
                
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
 8221e4c:	e0bffc47 	ldb	r2,-15(fp)
 8221e50:	e0fffd17 	ldw	r3,-12(fp)
 8221e54:	10800044 	addi	r2,r2,1
 8221e58:	1085883a 	add	r2,r2,r2
 8221e5c:	1085883a 	add	r2,r2,r2
 8221e60:	1885883a 	add	r2,r3,r2
 8221e64:	e0fffe17 	ldw	r3,-8(fp)
 8221e68:	10c00015 	stw	r3,0(r2)
                pmac_group->channel = 1;
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 8221e6c:	e0bffc43 	ldbu	r2,-15(fp)
 8221e70:	10800044 	addi	r2,r2,1
 8221e74:	e0bffc45 	stb	r2,-15(fp)
 8221e78:	e0fffc47 	ldb	r3,-15(fp)
 8221e7c:	e0bffd17 	ldw	r2,-12(fp)
 8221e80:	10800003 	ldbu	r2,0(r2)
 8221e84:	10803fcc 	andi	r2,r2,255
 8221e88:	18bed916 	blt	r3,r2,82219f0 <alt_tse_mac_group_init+0x18c>
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
            }
            
            /* store the pointer in global variable */
            pmac_groups[mac_group_count] = pmac_group;
 8221e8c:	d0a07f43 	ldbu	r2,-32259(gp)
 8221e90:	10c03fcc 	andi	r3,r2,255
 8221e94:	008209b4 	movhi	r2,2086
 8221e98:	10b71804 	addi	r2,r2,-9120
 8221e9c:	18c7883a 	add	r3,r3,r3
 8221ea0:	18c7883a 	add	r3,r3,r3
 8221ea4:	10c5883a 	add	r2,r2,r3
 8221ea8:	e0fffd17 	ldw	r3,-12(fp)
 8221eac:	10c00015 	stw	r3,0(r2)
            
            mac_group_count++;
 8221eb0:	d0a07f43 	ldbu	r2,-32259(gp)
 8221eb4:	10800044 	addi	r2,r2,1
 8221eb8:	d0a07f45 	stb	r2,-32259(gp)

            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
 8221ebc:	e0bffd17 	ldw	r2,-12(fp)
 8221ec0:	10c00003 	ldbu	r3,0(r2)
 8221ec4:	e0bffc03 	ldbu	r2,-16(fp)
 8221ec8:	1885883a 	add	r2,r3,r2
 8221ecc:	10bfffc4 	addi	r2,r2,-1
 8221ed0:	e0bffc05 	stb	r2,-16(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 8221ed4:	e0bffc03 	ldbu	r2,-16(fp)
 8221ed8:	10800044 	addi	r2,r2,1
 8221edc:	e0bffc05 	stb	r2,-16(fp)
 8221ee0:	e0fffc07 	ldb	r3,-16(fp)
 8221ee4:	d0a02d03 	ldbu	r2,-32588(gp)
 8221ee8:	10803fcc 	andi	r2,r2,255
 8221eec:	18be6716 	blt	r3,r2,822188c <alt_tse_mac_group_init+0x28>
            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
                        
        }
    }
    return SUCCESS;
 8221ef0:	0005883a 	mov	r2,zero
}
 8221ef4:	e037883a 	mov	sp,fp
 8221ef8:	dfc00117 	ldw	ra,4(sp)
 8221efc:	df000017 	ldw	fp,0(sp)
 8221f00:	dec00204 	addi	sp,sp,8
 8221f04:	f800283a 	ret

08221f08 <alt_tse_mac_get_phy>:
/* @Function Description: Store information of all the PHYs connected to MAC to phy_list
 * @API Type:         Internal
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @return            Number of PHY not in profile, return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 */
alt_32 alt_tse_mac_get_phy(alt_tse_mac_group *pmac_group) {
 8221f08:	deffed04 	addi	sp,sp,-76
 8221f0c:	dfc01215 	stw	ra,72(sp)
 8221f10:	df001115 	stw	fp,68(sp)
 8221f14:	df001104 	addi	fp,sp,68
 8221f18:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 phyid; 
	alt_32 phyid2 = 0;
 8221f1c:	e03ff515 	stw	zero,-44(fp)
    alt_u8 revision_number;

    alt_32 i;

    alt_u8 is_phy_in_profile;
    alt_32 return_value = 0;
 8221f20:	e03ff315 	stw	zero,-52(fp)
    
    alt_8 phy_info_count = 0;
 8221f24:	e03ff405 	stb	zero,-48(fp)
    
    alt_tse_phy_info *pphy = 0;
 8221f28:	e03ff615 	stw	zero,-40(fp)
    alt_tse_mac_info *pmac_info = 0;
 8221f2c:	e03ff715 	stw	zero,-36(fp)
    alt_tse_system_info *psys = 0;
 8221f30:	e03ff815 	stw	zero,-32(fp)
    
    np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8221f34:	e0bfff17 	ldw	r2,-4(fp)
 8221f38:	10800117 	ldw	r2,4(r2)
 8221f3c:	10800217 	ldw	r2,8(r2)
 8221f40:	10800017 	ldw	r2,0(r2)
 8221f44:	e0bff915 	stw	r2,-28(fp)
            
    /* Record previous MDIO address, to be restored at the end of function */
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 8221f48:	e0bff917 	ldw	r2,-28(fp)
 8221f4c:	10801004 	addi	r2,r2,64
 8221f50:	10800037 	ldwio	r2,0(r2)
 8221f54:	e0bffa15 	stw	r2,-24(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8221f58:	e13fff17 	ldw	r4,-4(fp)
 8221f5c:	82203640 	call	8220364 <alt_tse_get_mac_group_index>
 8221f60:	e0bffb05 	stb	r2,-20(fp)
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
 8221f64:	e03ff005 	stb	zero,-64(fp)
 8221f68:	0000cb06 	br	8222298 <alt_tse_mac_get_phy+0x390>
    {        
        IOWR(&pmac_group_base->MDIO_ADDR1, 0, phyadd);
 8221f6c:	e0bff917 	ldw	r2,-28(fp)
 8221f70:	10801004 	addi	r2,r2,64
 8221f74:	e0fff003 	ldbu	r3,-64(fp)
 8221f78:	10c00035 	stwio	r3,0(r2)
        phyid = IORD(&pmac_group_base->mdio1.PHY_ID1,0);     // read PHY ID
 8221f7c:	e0bff917 	ldw	r2,-28(fp)
 8221f80:	1080a204 	addi	r2,r2,648
 8221f84:	10800037 	ldwio	r2,0(r2)
 8221f88:	e0bffc15 	stw	r2,-16(fp)
        phyid2 = IORD(&pmac_group_base->mdio1.PHY_ID2,0);     // read PHY ID
 8221f8c:	e0bff917 	ldw	r2,-28(fp)
 8221f90:	1080a304 	addi	r2,r2,652
 8221f94:	10800037 	ldwio	r2,0(r2)
 8221f98:	e0bff515 	stw	r2,-44(fp)
        
        /* PHY found */
        if (phyid != phyid2)
 8221f9c:	e0fffc17 	ldw	r3,-16(fp)
 8221fa0:	e0bff517 	ldw	r2,-44(fp)
 8221fa4:	1880b926 	beq	r3,r2,822228c <alt_tse_mac_get_phy+0x384>
        {
            pphy = (alt_tse_phy_info *) malloc(sizeof(alt_tse_phy_info));
 8221fa8:	01000704 	movi	r4,28
 8221fac:	824b6ec0 	call	824b6ec <malloc>
 8221fb0:	e0bff615 	stw	r2,-40(fp)
            if(!pphy) {
 8221fb4:	e0bff617 	ldw	r2,-40(fp)
 8221fb8:	1000091e 	bne	r2,zero,8221fe0 <alt_tse_mac_get_phy+0xd8>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for phy_info[%d.%d]\n", mac_group_index, phy_info_count);
 8221fbc:	e0bffb07 	ldb	r2,-20(fp)
 8221fc0:	e0fff407 	ldb	r3,-48(fp)
 8221fc4:	180d883a 	mov	r6,r3
 8221fc8:	100b883a 	mov	r5,r2
 8221fcc:	01020974 	movhi	r4,2085
 8221fd0:	213b4a04 	addi	r4,r4,-4824
 8221fd4:	82033fc0 	call	82033fc <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 8221fd8:	00bfffc4 	movi	r2,-1
 8221fdc:	0000ce06 	br	8222318 <alt_tse_mac_get_phy+0x410>
            }
            
            /* store PHY address */
            pphy->mdio_address = phyadd;
 8221fe0:	e0bff617 	ldw	r2,-40(fp)
 8221fe4:	e0fff003 	ldbu	r3,-64(fp)
 8221fe8:	10c00005 	stb	r3,0(r2)

            /* get oui, model number, and revision number from PHYID and PHYID2 */
            oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
 8221fec:	e0bffc17 	ldw	r2,-16(fp)
 8221ff0:	100691ba 	slli	r3,r2,6
 8221ff4:	e0bff517 	ldw	r2,-44(fp)
 8221ff8:	1005d2ba 	srai	r2,r2,10
 8221ffc:	10800fcc 	andi	r2,r2,63
 8222000:	1884b03a 	or	r2,r3,r2
 8222004:	e0bffd15 	stw	r2,-12(fp)
            model_number = (phyid2 >> 4) & 0x3f;
 8222008:	e0bff517 	ldw	r2,-44(fp)
 822200c:	1005d13a 	srai	r2,r2,4
 8222010:	10800fcc 	andi	r2,r2,63
 8222014:	e0bffe05 	stb	r2,-8(fp)
            revision_number = phyid2 & 0x0f;
 8222018:	e0bff517 	ldw	r2,-44(fp)
 822201c:	108003cc 	andi	r2,r2,15
 8222020:	e0bffe45 	stb	r2,-7(fp)
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
 8222024:	e03ff205 	stb	zero,-56(fp)
            for(i = 0; i < phy_profile_count; i++) {
 8222028:	e03ff115 	stw	zero,-60(fp)
 822202c:	00003406 	br	8222100 <alt_tse_mac_get_phy+0x1f8>
                
                /* if PHY match with PHY in profile */
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
 8222030:	008209b4 	movhi	r2,2086
 8222034:	10b71c04 	addi	r2,r2,-9104
 8222038:	e0fff117 	ldw	r3,-60(fp)
 822203c:	18c7883a 	add	r3,r3,r3
 8222040:	18c7883a 	add	r3,r3,r3
 8222044:	10c5883a 	add	r2,r2,r3
 8222048:	10800017 	ldw	r2,0(r2)
 822204c:	10c01417 	ldw	r3,80(r2)
 8222050:	e0bffd17 	ldw	r2,-12(fp)
 8222054:	1880271e 	bne	r3,r2,82220f4 <alt_tse_mac_get_phy+0x1ec>
 8222058:	008209b4 	movhi	r2,2086
 822205c:	10b71c04 	addi	r2,r2,-9104
 8222060:	e0fff117 	ldw	r3,-60(fp)
 8222064:	18c7883a 	add	r3,r3,r3
 8222068:	18c7883a 	add	r3,r3,r3
 822206c:	10c5883a 	add	r2,r2,r3
 8222070:	10800017 	ldw	r2,0(r2)
 8222074:	10801503 	ldbu	r2,84(r2)
 8222078:	10c03fcc 	andi	r3,r2,255
 822207c:	e0bffe03 	ldbu	r2,-8(fp)
 8222080:	18801c1e 	bne	r3,r2,82220f4 <alt_tse_mac_get_phy+0x1ec>
                {
                    pphy->pphy_profile = pphy_profiles[i];
 8222084:	008209b4 	movhi	r2,2086
 8222088:	10b71c04 	addi	r2,r2,-9104
 822208c:	e0fff117 	ldw	r3,-60(fp)
 8222090:	18c7883a 	add	r3,r3,r3
 8222094:	18c7883a 	add	r3,r3,r3
 8222098:	10c5883a 	add	r2,r2,r3
 822209c:	10c00017 	ldw	r3,0(r2)
 82220a0:	e0bff617 	ldw	r2,-40(fp)
 82220a4:	10c00515 	stw	r3,20(r2)
                    
                    /* PHY found, add it to phy_list */
                    tse_dprintf(5, "INFO    : PHY %s found at PHY address 0x%02x of MAC Group[%d]\n", pphy_profiles[i]->name, phyadd, mac_group_index);
 82220a8:	008209b4 	movhi	r2,2086
 82220ac:	10b71c04 	addi	r2,r2,-9104
 82220b0:	e0fff117 	ldw	r3,-60(fp)
 82220b4:	18c7883a 	add	r3,r3,r3
 82220b8:	18c7883a 	add	r3,r3,r3
 82220bc:	10c5883a 	add	r2,r2,r3
 82220c0:	10800017 	ldw	r2,0(r2)
 82220c4:	1009883a 	mov	r4,r2
 82220c8:	e0bff003 	ldbu	r2,-64(fp)
 82220cc:	e0fffb07 	ldb	r3,-20(fp)
 82220d0:	180f883a 	mov	r7,r3
 82220d4:	100d883a 	mov	r6,r2
 82220d8:	200b883a 	mov	r5,r4
 82220dc:	01020974 	movhi	r4,2085
 82220e0:	213b5904 	addi	r4,r4,-4764
 82220e4:	82033fc0 	call	82033fc <printf>
                    is_phy_in_profile = 1;
 82220e8:	00800044 	movi	r2,1
 82220ec:	e0bff205 	stb	r2,-56(fp)
                    break;
 82220f0:	00000706 	br	8222110 <alt_tse_mac_get_phy+0x208>
            model_number = (phyid2 >> 4) & 0x3f;
            revision_number = phyid2 & 0x0f;
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
            for(i = 0; i < phy_profile_count; i++) {
 82220f4:	e0bff117 	ldw	r2,-60(fp)
 82220f8:	10800044 	addi	r2,r2,1
 82220fc:	e0bff115 	stw	r2,-60(fp)
 8222100:	d0a07f03 	ldbu	r2,-32260(gp)
 8222104:	10803fcc 	andi	r2,r2,255
 8222108:	e0fff117 	ldw	r3,-60(fp)
 822210c:	18bfc816 	blt	r3,r2,8222030 <alt_tse_mac_get_phy+0x128>
                    is_phy_in_profile = 1;
                    break;
                }
            }
            /* PHY not found in PHY profile */
            if(is_phy_in_profile == 0) {
 8222110:	e0bff203 	ldbu	r2,-56(fp)
 8222114:	10000f1e 	bne	r2,zero,8222154 <alt_tse_mac_get_phy+0x24c>
                pphy->pphy_profile = 0;
 8222118:	e0bff617 	ldw	r2,-40(fp)
 822211c:	10000515 	stw	zero,20(r2)
                tse_dprintf(3, "WARNING : Unknown PHY found at PHY address 0x%02x of MAC Group[%d]\n", phyadd, mac_group_index);
 8222120:	e0bff003 	ldbu	r2,-64(fp)
 8222124:	e0fffb07 	ldb	r3,-20(fp)
 8222128:	180d883a 	mov	r6,r3
 822212c:	100b883a 	mov	r5,r2
 8222130:	01020974 	movhi	r4,2085
 8222134:	213b6904 	addi	r4,r4,-4700
 8222138:	82033fc0 	call	82033fc <printf>
                tse_dprintf(3, "WARNING : Please add PHY information to PHY profile\n");
 822213c:	01020974 	movhi	r4,2085
 8222140:	213b7a04 	addi	r4,r4,-4632
 8222144:	82036800 	call	8203680 <puts>
                return_value++;
 8222148:	e0bff317 	ldw	r2,-52(fp)
 822214c:	10800044 	addi	r2,r2,1
 8222150:	e0bff315 	stw	r2,-52(fp)
            }
            
            tse_dprintf(6, "INFO    : PHY OUI             =  0x%06x\n", (int) oui);
 8222154:	e0bffd17 	ldw	r2,-12(fp)
 8222158:	100b883a 	mov	r5,r2
 822215c:	01020974 	movhi	r4,2085
 8222160:	213b8704 	addi	r4,r4,-4580
 8222164:	821f1e00 	call	821f1e0 <no_printf>
            tse_dprintf(6, "INFO    : PHY Model Number    =  0x%02x\n", model_number);
 8222168:	e0bffe03 	ldbu	r2,-8(fp)
 822216c:	100b883a 	mov	r5,r2
 8222170:	01020974 	movhi	r4,2085
 8222174:	213b9204 	addi	r4,r4,-4536
 8222178:	821f1e00 	call	821f1e0 <no_printf>
            tse_dprintf(6, "INFO    : PHY Revision Number =  0x%01x\n", revision_number);
 822217c:	e0bffe43 	ldbu	r2,-7(fp)
 8222180:	100b883a 	mov	r5,r2
 8222184:	01020974 	movhi	r4,2085
 8222188:	213b9d04 	addi	r4,r4,-4492
 822218c:	821f1e00 	call	821f1e0 <no_printf>
            
            /* map the detected PHY to connected MAC */
            if(alt_tse_mac_associate_phy(pmac_group, pphy) == TSE_PHY_MAP_SUCCESS) {
 8222190:	e17ff617 	ldw	r5,-40(fp)
 8222194:	e13fff17 	ldw	r4,-4(fp)
 8222198:	822232c0 	call	822232c <alt_tse_mac_associate_phy>
 822219c:	1000351e 	bne	r2,zero,8222274 <alt_tse_mac_get_phy+0x36c>
            	
            	pmac_info = pphy->pmac_info;
 82221a0:	e0bff617 	ldw	r2,-40(fp)
 82221a4:	10800617 	ldw	r2,24(r2)
 82221a8:	e0bff715 	stw	r2,-36(fp)
            	psys = pmac_info->psys_info;
 82221ac:	e0bff717 	ldw	r2,-36(fp)
 82221b0:	10800217 	ldw	r2,8(r2)
 82221b4:	e0bff815 	stw	r2,-32(fp)
            	
            	/* Disable PHY loopback to allow Auto-Negotiation completed */
    	        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 82221b8:	d8000015 	stw	zero,0(sp)
 82221bc:	01c00044 	movi	r7,1
 82221c0:	01800384 	movi	r6,14
 82221c4:	000b883a 	mov	r5,zero
 82221c8:	e13ff617 	ldw	r4,-40(fp)
 82221cc:	82211c40 	call	82211c4 <alt_tse_phy_wr_mdio_reg>
				
				/* Reset auto-negotiation advertisement */
				alt_tse_phy_set_adv_1000(pphy, 1);
 82221d0:	01400044 	movi	r5,1
 82221d4:	e13ff617 	ldw	r4,-40(fp)
 82221d8:	82230680 	call	8223068 <alt_tse_phy_set_adv_1000>
				alt_tse_phy_set_adv_100(pphy, 1);
 82221dc:	01400044 	movi	r5,1
 82221e0:	e13ff617 	ldw	r4,-40(fp)
 82221e4:	822322c0 	call	822322c <alt_tse_phy_set_adv_100>
				alt_tse_phy_set_adv_10(pphy, 1);
 82221e8:	01400044 	movi	r5,1
 82221ec:	e13ff617 	ldw	r4,-40(fp)
 82221f0:	82234800 	call	8223480 <alt_tse_phy_set_adv_10>
            	            	
	            /* check link connection for this PHY */
	            alt_tse_phy_restart_an(pphy, ALTERA_CHECKLINK_TIMEOUT_THRESHOLD);
 82221f4:	014003f4 	movhi	r5,15
 82221f8:	29509004 	addi	r5,r5,16960
 82221fc:	e13ff617 	ldw	r4,-40(fp)
 8222200:	82227b40 	call	82227b4 <alt_tse_phy_restart_an>
	            
	            /* Perform additional setting if there is any */
	            /* Profile specific */
	            if(pphy->pphy_profile) {
 8222204:	e0bff617 	ldw	r2,-40(fp)
 8222208:	10800517 	ldw	r2,20(r2)
 822220c:	10000f26 	beq	r2,zero,822224c <alt_tse_mac_get_phy+0x344>
		            if(pphy->pphy_profile->phy_cfg) {
 8222210:	e0bff617 	ldw	r2,-40(fp)
 8222214:	10800517 	ldw	r2,20(r2)
 8222218:	10801717 	ldw	r2,92(r2)
 822221c:	10000b26 	beq	r2,zero,822224c <alt_tse_mac_get_phy+0x344>
		                tse_dprintf(6, "INFO    : Applying additional PHY configuration of %s\n", pphy->pphy_profile->name);
 8222220:	e0bff617 	ldw	r2,-40(fp)
 8222224:	10800517 	ldw	r2,20(r2)
 8222228:	100b883a 	mov	r5,r2
 822222c:	01020974 	movhi	r4,2085
 8222230:	213ba804 	addi	r4,r4,-4448
 8222234:	821f1e00 	call	821f1e0 <no_printf>
		                pphy->pphy_profile->phy_cfg(pmac_group_base);
 8222238:	e0bff617 	ldw	r2,-40(fp)
 822223c:	10800517 	ldw	r2,20(r2)
 8222240:	10801717 	ldw	r2,92(r2)
 8222244:	e13ff917 	ldw	r4,-28(fp)
 8222248:	103ee83a 	callr	r2
		            }
	            }
	            
	            /* Initialize PHY, call user's function pointer in alt_tse_system_info structure */
	            /* Individual PHY specific */
            	if(psys->tse_phy_cfg) {
 822224c:	e0bff817 	ldw	r2,-32(fp)
 8222250:	10801117 	ldw	r2,68(r2)
 8222254:	10000726 	beq	r2,zero,8222274 <alt_tse_mac_get_phy+0x36c>
            		tse_dprintf(6, "INFO    : Applying additional user PHY configuration\n");
 8222258:	01020974 	movhi	r4,2085
 822225c:	213bb604 	addi	r4,r4,-4392
 8222260:	821f1e00 	call	821f1e0 <no_printf>
            		psys->tse_phy_cfg(pmac_group_base);
 8222264:	e0bff817 	ldw	r2,-32(fp)
 8222268:	10801117 	ldw	r2,68(r2)
 822226c:	e13ff917 	ldw	r4,-28(fp)
 8222270:	103ee83a 	callr	r2
            	}
            }
            
            tse_dprintf(6, "\n");
 8222274:	01020974 	movhi	r4,2085
 8222278:	213bc404 	addi	r4,r4,-4336
 822227c:	821f1e00 	call	821f1e0 <no_printf>
	            
            phy_info_count++;
 8222280:	e0bff403 	ldbu	r2,-48(fp)
 8222284:	10800044 	addi	r2,r2,1
 8222288:	e0bff405 	stb	r2,-48(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
 822228c:	e0bff003 	ldbu	r2,-64(fp)
 8222290:	10800044 	addi	r2,r2,1
 8222294:	e0bff005 	stb	r2,-64(fp)
 8222298:	e0bff003 	ldbu	r2,-64(fp)
 822229c:	10800830 	cmpltui	r2,r2,32
 82222a0:	103f321e 	bne	r2,zero,8221f6c <alt_tse_mac_get_phy+0x64>
            phy_info_count++;
        }
    }
    
    /* check to verify the number of connected PHY match the number of channel */
    if(pmac_group->channel != phy_info_count) {
 82222a4:	e0bfff17 	ldw	r2,-4(fp)
 82222a8:	10800003 	ldbu	r2,0(r2)
 82222ac:	10c03fcc 	andi	r3,r2,255
 82222b0:	e0bff407 	ldb	r2,-48(fp)
 82222b4:	18801326 	beq	r3,r2,8222304 <alt_tse_mac_get_phy+0x3fc>
        if(phy_info_count == 0) {
 82222b8:	e0bff407 	ldb	r2,-48(fp)
 82222bc:	1000061e 	bne	r2,zero,82222d8 <alt_tse_mac_get_phy+0x3d0>
            tse_dprintf(2, "ERROR   : MAC Group[%d] - No PHY connected!\n", mac_group_index);
 82222c0:	e0bffb07 	ldb	r2,-20(fp)
 82222c4:	100b883a 	mov	r5,r2
 82222c8:	01020974 	movhi	r4,2085
 82222cc:	213bc504 	addi	r4,r4,-4332
 82222d0:	82033fc0 	call	82033fc <printf>
 82222d4:	00000b06 	br	8222304 <alt_tse_mac_get_phy+0x3fc>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Group[%d] - Number of PHY connected is not equal to the number of channel, Number of PHY : %d, Channel : %d\n", mac_group_index, phy_info_count, pmac_group->channel);
 82222d8:	e0fffb07 	ldb	r3,-20(fp)
 82222dc:	e13ff407 	ldb	r4,-48(fp)
 82222e0:	e0bfff17 	ldw	r2,-4(fp)
 82222e4:	10800003 	ldbu	r2,0(r2)
 82222e8:	10803fcc 	andi	r2,r2,255
 82222ec:	100f883a 	mov	r7,r2
 82222f0:	200d883a 	mov	r6,r4
 82222f4:	180b883a 	mov	r5,r3
 82222f8:	01020974 	movhi	r4,2085
 82222fc:	213bd104 	addi	r4,r4,-4284
 8222300:	82033fc0 	call	82033fc <printf>
        }
    }
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 8222304:	e0bff917 	ldw	r2,-28(fp)
 8222308:	10801004 	addi	r2,r2,64
 822230c:	e0fffa17 	ldw	r3,-24(fp)
 8222310:	10c00035 	stwio	r3,0(r2)
    
    return return_value;
 8222314:	e0bff317 	ldw	r2,-52(fp)
}
 8222318:	e037883a 	mov	sp,fp
 822231c:	dfc00117 	ldw	ra,4(sp)
 8222320:	df000017 	ldw	fp,0(sp)
 8222324:	dec00204 	addi	sp,sp,8
 8222328:	f800283a 	ret

0822232c <alt_tse_mac_associate_phy>:
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @param pphy        Pointer to the TSE PHY info structure which hold information of PHY
 * @return            return TSE_PHY_MAP_ERROR if mapping error
 *                    return TSE_PHY_MAP_SUCCESS otherwise
 */
alt_32 alt_tse_mac_associate_phy(alt_tse_mac_group *pmac_group, alt_tse_phy_info *pphy) {
 822232c:	defff604 	addi	sp,sp,-40
 8222330:	dfc00915 	stw	ra,36(sp)
 8222334:	df000815 	stw	fp,32(sp)
 8222338:	df000804 	addi	fp,sp,32
 822233c:	e13ffe15 	stw	r4,-8(fp)
 8222340:	e17fff15 	stw	r5,-4(fp)
    
	alt_32 i;
	alt_32 return_value = TSE_PHY_MAP_SUCCESS;
 8222344:	e03ff915 	stw	zero,-28(fp)
    
	alt_u8 is_mapped;

    alt_tse_system_info *psys = 0;
 8222348:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_mac_info *pmac_info = 0;
 822234c:	e03ffc15 	stw	zero,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 8222350:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8222354:	e13ffe17 	ldw	r4,-8(fp)
 8222358:	82203640 	call	8220364 <alt_tse_get_mac_group_index>
 822235c:	e0bffd45 	stb	r2,-11(fp)
    alt_8 sys_info_index = 0;
 8222360:	e03ffd85 	stb	zero,-10(fp)
    
    is_mapped = 0;
 8222364:	e03ffa05 	stb	zero,-24(fp)
    
    for(i = 0; i < pmac_group->channel; i++) {
 8222368:	e03ff815 	stw	zero,-32(fp)
 822236c:	00002c06 	br	8222420 <alt_tse_mac_associate_phy+0xf4>
        pmac_info = pmac_group->pmac_info[i];
 8222370:	e0fffe17 	ldw	r3,-8(fp)
 8222374:	e0bff817 	ldw	r2,-32(fp)
 8222378:	10800044 	addi	r2,r2,1
 822237c:	1085883a 	add	r2,r2,r2
 8222380:	1085883a 	add	r2,r2,r2
 8222384:	1885883a 	add	r2,r3,r2
 8222388:	10800017 	ldw	r2,0(r2)
 822238c:	e0bffc15 	stw	r2,-16(fp)
        psys = pmac_info->psys_info;
 8222390:	e0bffc17 	ldw	r2,-16(fp)
 8222394:	10800217 	ldw	r2,8(r2)
 8222398:	e0bffb15 	stw	r2,-20(fp)
       
        /* map according to the PHY address in alt_tse_system_info.h */
        if(psys->tse_phy_mdio_address == pphy->mdio_address) {
 822239c:	e0bffb17 	ldw	r2,-20(fp)
 82223a0:	10c01017 	ldw	r3,64(r2)
 82223a4:	e0bfff17 	ldw	r2,-4(fp)
 82223a8:	10800003 	ldbu	r2,0(r2)
 82223ac:	10803fcc 	andi	r2,r2,255
 82223b0:	1880181e 	bne	r3,r2,8222414 <alt_tse_mac_associate_phy+0xe8>
        	mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 82223b4:	e13ffc17 	ldw	r4,-16(fp)
 82223b8:	82203d80 	call	82203d8 <alt_tse_get_mac_info_index>
 82223bc:	e0bffd05 	stb	r2,-12(fp)
	        sys_info_index = alt_tse_get_system_index(psys);
 82223c0:	e13ffb17 	ldw	r4,-20(fp)
 82223c4:	82202f80 	call	82202f8 <alt_tse_get_system_index>
 82223c8:	e0bffd85 	stb	r2,-10(fp)
	        
            pmac_info->pphy_info = pphy;
 82223cc:	e0bffc17 	ldw	r2,-16(fp)
 82223d0:	e0ffff17 	ldw	r3,-4(fp)
 82223d4:	10c00115 	stw	r3,4(r2)
            pphy->pmac_info = pmac_info;
 82223d8:	e0bfff17 	ldw	r2,-4(fp)
 82223dc:	e0fffc17 	ldw	r3,-16(fp)
 82223e0:	10c00615 	stw	r3,24(r2)
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Explicitly mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 82223e4:	e0bffd47 	ldb	r2,-11(fp)
 82223e8:	e0fffd07 	ldb	r3,-12(fp)
 82223ec:	e13ffd87 	ldb	r4,-10(fp)
 82223f0:	200f883a 	mov	r7,r4
 82223f4:	180d883a 	mov	r6,r3
 82223f8:	100b883a 	mov	r5,r2
 82223fc:	01020974 	movhi	r4,2085
 8222400:	213bf004 	addi	r4,r4,-4160
 8222404:	82033fc0 	call	82033fc <printf>
            is_mapped = 1;
 8222408:	00800044 	movi	r2,1
 822240c:	e0bffa05 	stb	r2,-24(fp)
            break;
 8222410:	00000806 	br	8222434 <alt_tse_mac_associate_phy+0x108>
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    alt_8 sys_info_index = 0;
    
    is_mapped = 0;
    
    for(i = 0; i < pmac_group->channel; i++) {
 8222414:	e0bff817 	ldw	r2,-32(fp)
 8222418:	10800044 	addi	r2,r2,1
 822241c:	e0bff815 	stw	r2,-32(fp)
 8222420:	e0bffe17 	ldw	r2,-8(fp)
 8222424:	10800003 	ldbu	r2,0(r2)
 8222428:	10803fcc 	andi	r2,r2,255
 822242c:	e0fff817 	ldw	r3,-32(fp)
 8222430:	18bfcf16 	blt	r3,r2,8222370 <alt_tse_mac_associate_phy+0x44>
            break;
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
 8222434:	e0bffa03 	ldbu	r2,-24(fp)
 8222438:	10003d1e 	bne	r2,zero,8222530 <alt_tse_mac_associate_phy+0x204>
        for(i = 0; i < pmac_group->channel; i++) {
 822243c:	e03ff815 	stw	zero,-32(fp)
 8222440:	00003606 	br	822251c <alt_tse_mac_associate_phy+0x1f0>
            pmac_info = pmac_group->pmac_info[i];
 8222444:	e0fffe17 	ldw	r3,-8(fp)
 8222448:	e0bff817 	ldw	r2,-32(fp)
 822244c:	10800044 	addi	r2,r2,1
 8222450:	1085883a 	add	r2,r2,r2
 8222454:	1085883a 	add	r2,r2,r2
 8222458:	1885883a 	add	r2,r3,r2
 822245c:	10800017 	ldw	r2,0(r2)
 8222460:	e0bffc15 	stw	r2,-16(fp)
            psys = pmac_info->psys_info;
 8222464:	e0bffc17 	ldw	r2,-16(fp)
 8222468:	10800217 	ldw	r2,8(r2)
 822246c:	e0bffb15 	stw	r2,-20(fp)
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
 8222470:	e0bffb17 	ldw	r2,-20(fp)
 8222474:	10800517 	ldw	r2,20(r2)
 8222478:	10002426 	beq	r2,zero,822250c <alt_tse_mac_associate_phy+0x1e0>
 822247c:	e0bffb17 	ldw	r2,-20(fp)
 8222480:	10800617 	ldw	r2,24(r2)
 8222484:	10002126 	beq	r2,zero,822250c <alt_tse_mac_associate_phy+0x1e0>
            	continue;
            }
            
            if(psys->tse_phy_mdio_address == TSE_PHY_AUTO_ADDRESS) {
 8222488:	e0bffb17 	ldw	r2,-20(fp)
 822248c:	10801017 	ldw	r2,64(r2)
 8222490:	10bfffd8 	cmpnei	r2,r2,-1
 8222494:	10001e1e 	bne	r2,zero,8222510 <alt_tse_mac_associate_phy+0x1e4>
                mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8222498:	e13ffc17 	ldw	r4,-16(fp)
 822249c:	82203d80 	call	82203d8 <alt_tse_get_mac_info_index>
 82224a0:	e0bffd05 	stb	r2,-12(fp)
                sys_info_index = alt_tse_get_system_index(psys);
 82224a4:	e13ffb17 	ldw	r4,-20(fp)
 82224a8:	82202f80 	call	82202f8 <alt_tse_get_system_index>
 82224ac:	e0bffd85 	stb	r2,-10(fp)
                
                pmac_info->pphy_info = pphy;
 82224b0:	e0bffc17 	ldw	r2,-16(fp)
 82224b4:	e0ffff17 	ldw	r3,-4(fp)
 82224b8:	10c00115 	stw	r3,4(r2)
                pphy->pmac_info = pmac_info;
 82224bc:	e0bfff17 	ldw	r2,-4(fp)
 82224c0:	e0fffc17 	ldw	r3,-16(fp)
 82224c4:	10c00615 	stw	r3,24(r2)
                psys->tse_phy_mdio_address = pphy->mdio_address;
 82224c8:	e0bfff17 	ldw	r2,-4(fp)
 82224cc:	10800003 	ldbu	r2,0(r2)
 82224d0:	10c03fcc 	andi	r3,r2,255
 82224d4:	e0bffb17 	ldw	r2,-20(fp)
 82224d8:	10c01015 	stw	r3,64(r2)
                tse_dprintf(5, "INFO    : PHY[%d.%d] - Automatically mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 82224dc:	e0bffd47 	ldb	r2,-11(fp)
 82224e0:	e0fffd07 	ldb	r3,-12(fp)
 82224e4:	e13ffd87 	ldb	r4,-10(fp)
 82224e8:	200f883a 	mov	r7,r4
 82224ec:	180d883a 	mov	r6,r3
 82224f0:	100b883a 	mov	r5,r2
 82224f4:	01020974 	movhi	r4,2085
 82224f8:	213c0004 	addi	r4,r4,-4096
 82224fc:	82033fc0 	call	82033fc <printf>
                is_mapped = 1;
 8222500:	00800044 	movi	r2,1
 8222504:	e0bffa05 	stb	r2,-24(fp)
                break;
 8222508:	00000906 	br	8222530 <alt_tse_mac_associate_phy+0x204>
            pmac_info = pmac_group->pmac_info[i];
            psys = pmac_info->psys_info;
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
            	continue;
 822250c:	0001883a 	nop
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
        for(i = 0; i < pmac_group->channel; i++) {
 8222510:	e0bff817 	ldw	r2,-32(fp)
 8222514:	10800044 	addi	r2,r2,1
 8222518:	e0bff815 	stw	r2,-32(fp)
 822251c:	e0bffe17 	ldw	r2,-8(fp)
 8222520:	10800003 	ldbu	r2,0(r2)
 8222524:	10803fcc 	andi	r2,r2,255
 8222528:	e0fff817 	ldw	r3,-32(fp)
 822252c:	18bfc516 	blt	r3,r2,8222444 <alt_tse_mac_associate_phy+0x118>
            }
        }
    }
    
    /* Still cannot find any matched MAC-PHY */
    if(is_mapped == 0) {
 8222530:	e0bffa03 	ldbu	r2,-24(fp)
 8222534:	1000091e 	bne	r2,zero,822255c <alt_tse_mac_associate_phy+0x230>
    	pphy->pmac_info = 0;
 8222538:	e0bfff17 	ldw	r2,-4(fp)
 822253c:	10000615 	stw	zero,24(r2)
        tse_dprintf(2, "WARNING : PHY[%d.X] - Mapping of PHY to MAC failed! Make sure the PHY address is defined correctly in tse_mac_device[] structure, and number of PHYs connected is equivalent to number of channel\n", mac_group_index);
 8222540:	e0bffd47 	ldb	r2,-11(fp)
 8222544:	100b883a 	mov	r5,r2
 8222548:	01020974 	movhi	r4,2085
 822254c:	213c1104 	addi	r4,r4,-4028
 8222550:	82033fc0 	call	82033fc <printf>
        return_value = TSE_PHY_MAP_ERROR;
 8222554:	00bfffc4 	movi	r2,-1
 8222558:	e0bff915 	stw	r2,-28(fp)
    }
    
    return return_value;
 822255c:	e0bff917 	ldw	r2,-28(fp)
}
 8222560:	e037883a 	mov	sp,fp
 8222564:	dfc00117 	ldw	ra,4(sp)
 8222568:	df000017 	ldw	fp,0(sp)
 822256c:	dec00204 	addi	sp,sp,8
 8222570:	f800283a 	ret

08222574 <alt_tse_phy_cfg_pcs>:
/* @Function Description: Configure operating mode of Altera PCS if available
 * @API Type:           Internal
 * @param pmac_info     pointer to MAC info variable
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_cfg_pcs(alt_tse_mac_info *pmac_info) {
 8222574:	defff804 	addi	sp,sp,-32
 8222578:	dfc00715 	stw	ra,28(sp)
 822257c:	df000615 	stw	fp,24(sp)
 8222580:	df000604 	addi	fp,sp,24
 8222584:	e13fff15 	stw	r4,-4(fp)
    
    alt_tse_system_info *psys = pmac_info->psys_info;
 8222588:	e0bfff17 	ldw	r2,-4(fp)
 822258c:	10800217 	ldw	r2,8(r2)
 8222590:	e0bffa15 	stw	r2,-24(fp)
    np_tse_mac *pmac = (np_tse_mac *) psys->tse_mac_base;
 8222594:	e0bffa17 	ldw	r2,-24(fp)
 8222598:	10800017 	ldw	r2,0(r2)
 822259c:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 82225a0:	e0bfff17 	ldw	r2,-4(fp)
 82225a4:	10800317 	ldw	r2,12(r2)
 82225a8:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 82225ac:	e13fff17 	ldw	r4,-4(fp)
 82225b0:	82203d80 	call	82203d8 <alt_tse_get_mac_info_index>
 82225b4:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 82225b8:	e13ffc17 	ldw	r4,-16(fp)
 82225bc:	82203640 	call	8220364 <alt_tse_get_mac_group_index>
 82225c0:	e0bffd45 	stb	r2,-11(fp)

    if(psys->tse_pcs_ena) {
 82225c4:	e0bffa17 	ldw	r2,-24(fp)
 82225c8:	108003c3 	ldbu	r2,15(r2)
 82225cc:	10803fcc 	andi	r2,r2,255
 82225d0:	10002c26 	beq	r2,zero,8222684 <alt_tse_phy_cfg_pcs+0x110>
        tse_dprintf(5, "INFO    : PCS[%d.%d] - Configuring PCS operating mode\n", mac_group_index, mac_info_index);
 82225d4:	e0bffd47 	ldb	r2,-11(fp)
 82225d8:	e0fffd07 	ldb	r3,-12(fp)
 82225dc:	180d883a 	mov	r6,r3
 82225e0:	100b883a 	mov	r5,r2
 82225e4:	01020974 	movhi	r4,2085
 82225e8:	213c4204 	addi	r4,r4,-3832
 82225ec:	82033fc0 	call	82033fc <printf>
        
        alt_32 data = IORD(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE); 
 82225f0:	e0bffb17 	ldw	r2,-20(fp)
 82225f4:	10808004 	addi	r2,r2,512
 82225f8:	10801404 	addi	r2,r2,80
 82225fc:	10800037 	ldwio	r2,0(r2)
 8222600:	e0bffe15 	stw	r2,-8(fp)
        
        if(psys->tse_pcs_sgmii) {
 8222604:	e0bffa17 	ldw	r2,-24(fp)
 8222608:	10800403 	ldbu	r2,16(r2)
 822260c:	10803fcc 	andi	r2,r2,255
 8222610:	10000e26 	beq	r2,zero,822264c <alt_tse_phy_cfg_pcs+0xd8>
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode enabled\n", mac_group_index, mac_info_index);
 8222614:	e0bffd47 	ldb	r2,-11(fp)
 8222618:	e0fffd07 	ldb	r3,-12(fp)
 822261c:	180d883a 	mov	r6,r3
 8222620:	100b883a 	mov	r5,r2
 8222624:	01020974 	movhi	r4,2085
 8222628:	213c5004 	addi	r4,r4,-3776
 822262c:	82033fc0 	call	82033fc <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data | 0x03);
 8222630:	e0bffb17 	ldw	r2,-20(fp)
 8222634:	10808004 	addi	r2,r2,512
 8222638:	10801404 	addi	r2,r2,80
 822263c:	e0fffe17 	ldw	r3,-8(fp)
 8222640:	18c000d4 	ori	r3,r3,3
 8222644:	10c00035 	stwio	r3,0(r2)
 8222648:	00000e06 	br	8222684 <alt_tse_phy_cfg_pcs+0x110>
            }
        else {
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode disabled\n", mac_group_index, mac_info_index);
 822264c:	e0bffd47 	ldb	r2,-11(fp)
 8222650:	e0fffd07 	ldb	r3,-12(fp)
 8222654:	180d883a 	mov	r6,r3
 8222658:	100b883a 	mov	r5,r2
 822265c:	01020974 	movhi	r4,2085
 8222660:	213c5c04 	addi	r4,r4,-3728
 8222664:	82033fc0 	call	82033fc <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data & ~0x03);
 8222668:	e0bffb17 	ldw	r2,-20(fp)
 822266c:	10808004 	addi	r2,r2,512
 8222670:	10801404 	addi	r2,r2,80
 8222674:	e13ffe17 	ldw	r4,-8(fp)
 8222678:	00ffff04 	movi	r3,-4
 822267c:	20c6703a 	and	r3,r4,r3
 8222680:	10c00035 	stwio	r3,0(r2)
        }
    }
    
    return SUCCESS;
 8222684:	0005883a 	mov	r2,zero
}
 8222688:	e037883a 	mov	sp,fp
 822268c:	dfc00117 	ldw	ra,4(sp)
 8222690:	df000017 	ldw	fp,0(sp)
 8222694:	dec00204 	addi	sp,sp,8
 8222698:	f800283a 	ret

0822269c <alt_tse_phy_init>:
/* @Function Description: Detect and initialize all the PHYs connected
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      SUCCESS
 */
alt_32 alt_tse_phy_init() {
 822269c:	defffb04 	addi	sp,sp,-20
 82226a0:	dfc00415 	stw	ra,16(sp)
 82226a4:	df000315 	stw	fp,12(sp)
 82226a8:	df000304 	addi	fp,sp,12
	alt_8 i = 0;
 82226ac:	e03ffd05 	stb	zero,-12(fp)
	alt_8 j = 0;
 82226b0:	e03ffd45 	stb	zero,-11(fp)
    
    alt_tse_mac_group *pmac_group = 0;
 82226b4:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_mac_info *pmac_info = 0;
 82226b8:	e03fff15 	stw	zero,-4(fp)
    
    /* add supported PHYs */
    alt_tse_phy_add_profile_default();
 82226bc:	82213b80 	call	82213b8 <alt_tse_phy_add_profile_default>
    
    /* display PHY in profile */
    alt_tse_phy_print_profile();
 82226c0:	82216540 	call	8221654 <alt_tse_phy_print_profile>
    
    alt_tse_mac_group_init();
 82226c4:	82218640 	call	8221864 <alt_tse_mac_group_init>
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 82226c8:	e03ffd05 	stb	zero,-12(fp)
 82226cc:	00002f06 	br	822278c <alt_tse_phy_init+0xf0>
        pmac_group = pmac_groups[i];
 82226d0:	e0fffd07 	ldb	r3,-12(fp)
 82226d4:	008209b4 	movhi	r2,2086
 82226d8:	10b71804 	addi	r2,r2,-9120
 82226dc:	18c7883a 	add	r3,r3,r3
 82226e0:	18c7883a 	add	r3,r3,r3
 82226e4:	10c5883a 	add	r2,r2,r3
 82226e8:	10800017 	ldw	r2,0(r2)
 82226ec:	e0bffe15 	stw	r2,-8(fp)
        
        if(pmac_group->pmac_info[0]->psys_info->tse_use_mdio) {
 82226f0:	e0bffe17 	ldw	r2,-8(fp)
 82226f4:	10800117 	ldw	r2,4(r2)
 82226f8:	10800217 	ldw	r2,8(r2)
 82226fc:	10800203 	ldbu	r2,8(r2)
 8222700:	10803fcc 	andi	r2,r2,255
 8222704:	10000326 	beq	r2,zero,8222714 <alt_tse_phy_init+0x78>
            
        	/* get connected PHYs */
            alt_tse_mac_get_phy(pmac_group);
 8222708:	e13ffe17 	ldw	r4,-8(fp)
 822270c:	8221f080 	call	8221f08 <alt_tse_mac_get_phy>
 8222710:	00000706 	br	8222730 <alt_tse_phy_init+0x94>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
 8222714:	e0bffd07 	ldb	r2,-12(fp)
 8222718:	e0fffd47 	ldb	r3,-11(fp)
 822271c:	180d883a 	mov	r6,r3
 8222720:	100b883a 	mov	r5,r2
 8222724:	01020974 	movhi	r4,2085
 8222728:	213c6804 	addi	r4,r4,-3680
 822272c:	82033fc0 	call	82033fc <printf>
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 8222730:	e03ffd45 	stb	zero,-11(fp)
 8222734:	00000d06 	br	822276c <alt_tse_phy_init+0xd0>
            pmac_info = pmac_group->pmac_info[j];
 8222738:	e0bffd47 	ldb	r2,-11(fp)
 822273c:	e0fffe17 	ldw	r3,-8(fp)
 8222740:	10800044 	addi	r2,r2,1
 8222744:	1085883a 	add	r2,r2,r2
 8222748:	1085883a 	add	r2,r2,r2
 822274c:	1885883a 	add	r2,r3,r2
 8222750:	10800017 	ldw	r2,0(r2)
 8222754:	e0bfff15 	stw	r2,-4(fp)
            
            alt_tse_phy_cfg_pcs(pmac_info);
 8222758:	e13fff17 	ldw	r4,-4(fp)
 822275c:	82225740 	call	8222574 <alt_tse_phy_cfg_pcs>
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 8222760:	e0bffd43 	ldbu	r2,-11(fp)
 8222764:	10800044 	addi	r2,r2,1
 8222768:	e0bffd45 	stb	r2,-11(fp)
 822276c:	e0fffd47 	ldb	r3,-11(fp)
 8222770:	e0bffe17 	ldw	r2,-8(fp)
 8222774:	10800003 	ldbu	r2,0(r2)
 8222778:	10803fcc 	andi	r2,r2,255
 822277c:	18bfee16 	blt	r3,r2,8222738 <alt_tse_phy_init+0x9c>
    
    alt_tse_mac_group_init();
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 8222780:	e0bffd03 	ldbu	r2,-12(fp)
 8222784:	10800044 	addi	r2,r2,1
 8222788:	e0bffd05 	stb	r2,-12(fp)
 822278c:	e0fffd07 	ldb	r3,-12(fp)
 8222790:	d0a07f43 	ldbu	r2,-32259(gp)
 8222794:	10803fcc 	andi	r2,r2,255
 8222798:	18bfcd16 	blt	r3,r2,82226d0 <alt_tse_phy_init+0x34>
            
            alt_tse_phy_cfg_pcs(pmac_info);
        }
    }
                
    return SUCCESS;
 822279c:	0005883a 	mov	r2,zero
}
 82227a0:	e037883a 	mov	sp,fp
 82227a4:	dfc00117 	ldw	ra,4(sp)
 82227a8:	df000017 	ldw	fp,0(sp)
 82227ac:	dec00204 	addi	sp,sp,8
 82227b0:	f800283a 	ret

082227b4 <alt_tse_phy_restart_an>:
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *                              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_restart_an(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 82227b4:	defff704 	addi	sp,sp,-36
 82227b8:	dfc00815 	stw	ra,32(sp)
 82227bc:	df000715 	stw	fp,28(sp)
 82227c0:	df000704 	addi	fp,sp,28
 82227c4:	e13ffe15 	stw	r4,-8(fp)
 82227c8:	e17fff15 	stw	r5,-4(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 82227cc:	e0bffe17 	ldw	r2,-8(fp)
 82227d0:	10800617 	ldw	r2,24(r2)
 82227d4:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 82227d8:	e0bffb17 	ldw	r2,-20(fp)
 82227dc:	10800317 	ldw	r2,12(r2)
 82227e0:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 82227e4:	e13ffb17 	ldw	r4,-20(fp)
 82227e8:	82203d80 	call	82203d8 <alt_tse_get_mac_info_index>
 82227ec:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 82227f0:	e13ffc17 	ldw	r4,-16(fp)
 82227f4:	82203640 	call	8220364 <alt_tse_get_mac_group_index>
 82227f8:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 82227fc:	e13ffe17 	ldw	r4,-8(fp)
 8222800:	82211240 	call	8221124 <alt_tse_phy_rd_mdio_addr>
 8222804:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 8222808:	e0bffe17 	ldw	r2,-8(fp)
 822280c:	10800003 	ldbu	r2,0(r2)
 8222810:	10803fcc 	andi	r2,r2,255
 8222814:	100b883a 	mov	r5,r2
 8222818:	e13ffe17 	ldw	r4,-8(fp)
 822281c:	822116c0 	call	822116c <alt_tse_phy_wr_mdio_addr>
    
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 8222820:	01c00044 	movi	r7,1
 8222824:	018000c4 	movi	r6,3
 8222828:	01400044 	movi	r5,1
 822282c:	e13ffe17 	ldw	r4,-8(fp)
 8222830:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8222834:	10000d1e 	bne	r2,zero,822286c <alt_tse_phy_restart_an+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 8222838:	e0bffd47 	ldb	r2,-11(fp)
 822283c:	e0fffd07 	ldb	r3,-12(fp)
 8222840:	180d883a 	mov	r6,r3
 8222844:	100b883a 	mov	r5,r2
 8222848:	01020974 	movhi	r4,2085
 822284c:	213c7e04 	addi	r4,r4,-3592
 8222850:	82033fc0 	call	82033fc <printf>
        
		/* Restore previous MDIO address */
		alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222854:	e0bffd83 	ldbu	r2,-10(fp)
 8222858:	100b883a 	mov	r5,r2
 822285c:	e13ffe17 	ldw	r4,-8(fp)
 8222860:	822116c0 	call	822116c <alt_tse_phy_wr_mdio_addr>
		
		return TSE_PHY_AN_NOT_CAPABLE;
 8222864:	00bfff84 	movi	r2,-2
 8222868:	00003c06 	br	822295c <alt_tse_phy_restart_an+0x1a8>
    }
    
    /* enable Auto-Negotiation */    
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_AN_ENA, 1, 1);
 822286c:	00800044 	movi	r2,1
 8222870:	d8800015 	stw	r2,0(sp)
 8222874:	01c00044 	movi	r7,1
 8222878:	01800304 	movi	r6,12
 822287c:	000b883a 	mov	r5,zero
 8222880:	e13ffe17 	ldw	r4,-8(fp)
 8222884:	82211c40 	call	82211c4 <alt_tse_phy_wr_mdio_reg>
    
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
 8222888:	00800044 	movi	r2,1
 822288c:	d8800015 	stw	r2,0(sp)
 8222890:	01c00044 	movi	r7,1
 8222894:	01800244 	movi	r6,9
 8222898:	000b883a 	mov	r5,zero
 822289c:	e13ffe17 	ldw	r4,-8(fp)
 82228a0:	82211c40 	call	82211c4 <alt_tse_phy_wr_mdio_reg>
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
 82228a4:	e0bffd47 	ldb	r2,-11(fp)
 82228a8:	e0fffd07 	ldb	r3,-12(fp)
 82228ac:	180d883a 	mov	r6,r3
 82228b0:	100b883a 	mov	r5,r2
 82228b4:	01020974 	movhi	r4,2085
 82228b8:	213c8e04 	addi	r4,r4,-3528
 82228bc:	82033fc0 	call	82033fc <printf>
    
    alt_32 timeout = 0;
 82228c0:	e03ffa15 	stw	zero,-24(fp)
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 82228c4:	00001306 	br	8222914 <alt_tse_phy_restart_an+0x160>
        if(timeout++ > timeout_threshold) {
 82228c8:	e0bffa17 	ldw	r2,-24(fp)
 82228cc:	10c00044 	addi	r3,r2,1
 82228d0:	e0fffa15 	stw	r3,-24(fp)
 82228d4:	1007883a 	mov	r3,r2
 82228d8:	e0bfff17 	ldw	r2,-4(fp)
 82228dc:	10c00d2e 	bgeu	r2,r3,8222914 <alt_tse_phy_restart_an+0x160>
           tse_dprintf(4, "WARNING : PHY[%d.%d] - Auto-Negotiation FAILED\n", mac_group_index, mac_info_index);
 82228e0:	e0bffd47 	ldb	r2,-11(fp)
 82228e4:	e0fffd07 	ldb	r3,-12(fp)
 82228e8:	180d883a 	mov	r6,r3
 82228ec:	100b883a 	mov	r5,r2
 82228f0:	01020974 	movhi	r4,2085
 82228f4:	213ca004 	addi	r4,r4,-3456
 82228f8:	82033fc0 	call	82033fc <printf>
		   
		   /* Restore previous MDIO address */
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 82228fc:	e0bffd83 	ldbu	r2,-10(fp)
 8222900:	100b883a 	mov	r5,r2
 8222904:	e13ffe17 	ldw	r4,-8(fp)
 8222908:	822116c0 	call	822116c <alt_tse_phy_wr_mdio_addr>
           
		   return TSE_PHY_AN_NOT_COMPLETE;
 822290c:	00bfffc4 	movi	r2,-1
 8222910:	00001206 	br	822295c <alt_tse_phy_restart_an+0x1a8>
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
    
    alt_32 timeout = 0;
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 8222914:	01c00044 	movi	r7,1
 8222918:	01800144 	movi	r6,5
 822291c:	01400044 	movi	r5,1
 8222920:	e13ffe17 	ldw	r4,-8(fp)
 8222924:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8222928:	103fe726 	beq	r2,zero,82228c8 <alt_tse_phy_restart_an+0x114>
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
           
		   return TSE_PHY_AN_NOT_COMPLETE;
        }
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Auto-Negotiation PASSED\n", mac_group_index, mac_info_index);
 822292c:	e0bffd47 	ldb	r2,-11(fp)
 8222930:	e0fffd07 	ldb	r3,-12(fp)
 8222934:	180d883a 	mov	r6,r3
 8222938:	100b883a 	mov	r5,r2
 822293c:	01020974 	movhi	r4,2085
 8222940:	213cac04 	addi	r4,r4,-3408
 8222944:	82033fc0 	call	82033fc <printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222948:	e0bffd83 	ldbu	r2,-10(fp)
 822294c:	100b883a 	mov	r5,r2
 8222950:	e13ffe17 	ldw	r4,-8(fp)
 8222954:	822116c0 	call	822116c <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE;
 8222958:	0005883a 	mov	r2,zero
}
 822295c:	e037883a 	mov	sp,fp
 8222960:	dfc00117 	ldw	ra,4(sp)
 8222964:	df000017 	ldw	fp,0(sp)
 8222968:	dec00204 	addi	sp,sp,8
 822296c:	f800283a 	ret

08222970 <alt_tse_phy_check_link>:
 * @param pphy                  Pointer to the alt_tse_phy_info structure
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 */
alt_32 alt_tse_phy_check_link(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 8222970:	defff904 	addi	sp,sp,-28
 8222974:	dfc00615 	stw	ra,24(sp)
 8222978:	df000515 	stw	fp,20(sp)
 822297c:	df000504 	addi	fp,sp,20
 8222980:	e13ffe15 	stw	r4,-8(fp)
 8222984:	e17fff15 	stw	r5,-4(fp)

    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 8222988:	e0bffe17 	ldw	r2,-8(fp)
 822298c:	10800617 	ldw	r2,24(r2)
 8222990:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 8222994:	e0bffb17 	ldw	r2,-20(fp)
 8222998:	10800317 	ldw	r2,12(r2)
 822299c:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 82229a0:	e13ffb17 	ldw	r4,-20(fp)
 82229a4:	82203d80 	call	82203d8 <alt_tse_get_mac_info_index>
 82229a8:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group); 
 82229ac:	e13ffc17 	ldw	r4,-16(fp)
 82229b0:	82203640 	call	8220364 <alt_tse_get_mac_group_index>
 82229b4:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 82229b8:	e13ffe17 	ldw	r4,-8(fp)
 82229bc:	82211240 	call	8221124 <alt_tse_phy_rd_mdio_addr>
 82229c0:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 82229c4:	e0bffe17 	ldw	r2,-8(fp)
 82229c8:	10800003 	ldbu	r2,0(r2)
 82229cc:	10803fcc 	andi	r2,r2,255
 82229d0:	100b883a 	mov	r5,r2
 82229d4:	e13ffe17 	ldw	r4,-8(fp)
 82229d8:	822116c0 	call	822116c <alt_tse_phy_wr_mdio_addr>
    /* Issue a PHY reset here and wait for the link
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
 82229dc:	e0bffd47 	ldb	r2,-11(fp)
 82229e0:	e0fffd07 	ldb	r3,-12(fp)
 82229e4:	180d883a 	mov	r6,r3
 82229e8:	100b883a 	mov	r5,r2
 82229ec:	01020974 	movhi	r4,2085
 82229f0:	213cb804 	addi	r4,r4,-3360
 82229f4:	82033fc0 	call	82033fc <printf>
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
 82229f8:	01c00044 	movi	r7,1
 82229fc:	01800384 	movi	r6,14
 8222a00:	000b883a 	mov	r5,zero
 8222a04:	e13ffe17 	ldw	r4,-8(fp)
 8222a08:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8222a0c:	1000061e 	bne	r2,zero,8222a28 <alt_tse_phy_check_link+0xb8>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
 8222a10:	01c00044 	movi	r7,1
 8222a14:	01800144 	movi	r6,5
 8222a18:	01400044 	movi	r5,1
 8222a1c:	e13ffe17 	ldw	r4,-8(fp)
 8222a20:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
 8222a24:	1000191e 	bne	r2,zero,8222a8c <alt_tse_phy_check_link+0x11c>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
        
        tse_dprintf(5, "INFO    : PHY[%d.%d] - Link not yet established, restart auto-negotiation...\n", mac_group_index, mac_info_index);
 8222a28:	e0bffd47 	ldb	r2,-11(fp)
 8222a2c:	e0fffd07 	ldb	r3,-12(fp)
 8222a30:	180d883a 	mov	r6,r3
 8222a34:	100b883a 	mov	r5,r2
 8222a38:	01020974 	movhi	r4,2085
 8222a3c:	213cc304 	addi	r4,r4,-3316
 8222a40:	82033fc0 	call	82033fc <printf>
        /* restart Auto-Negotiation */
        /* if Auto-Negotiation still cannot complete, then go to next PHY */
        if(alt_tse_phy_restart_an(pphy, timeout_threshold) == TSE_PHY_AN_NOT_COMPLETE) {
 8222a44:	e17fff17 	ldw	r5,-4(fp)
 8222a48:	e13ffe17 	ldw	r4,-8(fp)
 8222a4c:	82227b40 	call	82227b4 <alt_tse_phy_restart_an>
 8222a50:	10bfffd8 	cmpnei	r2,r2,-1
 8222a54:	10000d1e 	bne	r2,zero,8222a8c <alt_tse_phy_check_link+0x11c>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - Link could not established\n", mac_group_index, mac_info_index);
 8222a58:	e0bffd47 	ldb	r2,-11(fp)
 8222a5c:	e0fffd07 	ldb	r3,-12(fp)
 8222a60:	180d883a 	mov	r6,r3
 8222a64:	100b883a 	mov	r5,r2
 8222a68:	01020974 	movhi	r4,2085
 8222a6c:	213cd704 	addi	r4,r4,-3236
 8222a70:	82033fc0 	call	82033fc <printf>
			
			/* Restore previous MDIO address */
			alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222a74:	e0bffd83 	ldbu	r2,-10(fp)
 8222a78:	100b883a 	mov	r5,r2
 8222a7c:	e13ffe17 	ldw	r4,-8(fp)
 8222a80:	822116c0 	call	822116c <alt_tse_phy_wr_mdio_addr>
	
            return TSE_PHY_AN_NOT_COMPLETE;
 8222a84:	00bfffc4 	movi	r2,-1
 8222a88:	00000c06 	br	8222abc <alt_tse_phy_check_link+0x14c>
        }            
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Link established\n", mac_group_index, mac_info_index);
 8222a8c:	e0bffd47 	ldb	r2,-11(fp)
 8222a90:	e0fffd07 	ldb	r3,-12(fp)
 8222a94:	180d883a 	mov	r6,r3
 8222a98:	100b883a 	mov	r5,r2
 8222a9c:	01020974 	movhi	r4,2085
 8222aa0:	213ce404 	addi	r4,r4,-3184
 8222aa4:	82033fc0 	call	82033fc <printf>
            
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222aa8:	e0bffd83 	ldbu	r2,-10(fp)
 8222aac:	100b883a 	mov	r5,r2
 8222ab0:	e13ffe17 	ldw	r4,-8(fp)
 8222ab4:	822116c0 	call	822116c <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE; 
 8222ab8:	0005883a 	mov	r2,zero
}
 8222abc:	e037883a 	mov	sp,fp
 8222ac0:	dfc00117 	ldw	ra,4(sp)
 8222ac4:	df000017 	ldw	fp,0(sp)
 8222ac8:	dec00204 	addi	sp,sp,8
 8222acc:	f800283a 	ret

08222ad0 <alt_tse_phy_get_cap>:
 * @param pmac  Pointer to the alt_tse_phy_info structure
 * @return      return TSE_PHY_AN_COMPLETE if success
 *              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
 8222ad0:	defff904 	addi	sp,sp,-28
 8222ad4:	dfc00615 	stw	ra,24(sp)
 8222ad8:	df000515 	stw	fp,20(sp)
 8222adc:	df000504 	addi	fp,sp,20
 8222ae0:	e13fff15 	stw	r4,-4(fp)
	alt_32 return_value = TSE_PHY_AN_COMPLETE;
 8222ae4:	e03ffb15 	stw	zero,-20(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 8222ae8:	e0bfff17 	ldw	r2,-4(fp)
 8222aec:	10800617 	ldw	r2,24(r2)
 8222af0:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 8222af4:	e0bffc17 	ldw	r2,-16(fp)
 8222af8:	10800317 	ldw	r2,12(r2)
 8222afc:	e0bffd15 	stw	r2,-12(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8222b00:	e13ffc17 	ldw	r4,-16(fp)
 8222b04:	82203d80 	call	82203d8 <alt_tse_get_mac_info_index>
 8222b08:	e0bffe05 	stb	r2,-8(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);    
 8222b0c:	e13ffd17 	ldw	r4,-12(fp)
 8222b10:	82203640 	call	8220364 <alt_tse_get_mac_group_index>
 8222b14:	e0bffe45 	stb	r2,-7(fp)
        
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 8222b18:	e13fff17 	ldw	r4,-4(fp)
 8222b1c:	82211240 	call	8221124 <alt_tse_phy_rd_mdio_addr>
 8222b20:	e0bffe85 	stb	r2,-6(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 8222b24:	e0bfff17 	ldw	r2,-4(fp)
 8222b28:	10800003 	ldbu	r2,0(r2)
 8222b2c:	10803fcc 	andi	r2,r2,255
 8222b30:	100b883a 	mov	r5,r2
 8222b34:	e13fff17 	ldw	r4,-4(fp)
 8222b38:	822116c0 	call	822116c <alt_tse_phy_wr_mdio_addr>
            
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 8222b3c:	01c00044 	movi	r7,1
 8222b40:	018000c4 	movi	r6,3
 8222b44:	01400044 	movi	r5,1
 8222b48:	e13fff17 	ldw	r4,-4(fp)
 8222b4c:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8222b50:	10000d1e 	bne	r2,zero,8222b88 <alt_tse_phy_get_cap+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 8222b54:	e0bffe47 	ldb	r2,-7(fp)
 8222b58:	e0fffe07 	ldb	r3,-8(fp)
 8222b5c:	180d883a 	mov	r6,r3
 8222b60:	100b883a 	mov	r5,r2
 8222b64:	01020974 	movhi	r4,2085
 8222b68:	213c7e04 	addi	r4,r4,-3592
 8222b6c:	82033fc0 	call	82033fc <printf>
        
        /* Restore previous MDIO address */
        alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222b70:	e0bffe83 	ldbu	r2,-6(fp)
 8222b74:	100b883a 	mov	r5,r2
 8222b78:	e13fff17 	ldw	r4,-4(fp)
 8222b7c:	822116c0 	call	822116c <alt_tse_phy_wr_mdio_addr>
        
        return TSE_PHY_AN_NOT_CAPABLE;
 8222b80:	00bfff84 	movi	r2,-2
 8222b84:	00013306 	br	8223054 <alt_tse_phy_get_cap+0x584>
    }
    
    /* check whether link has been established */
    alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 8222b88:	01400134 	movhi	r5,4
 8222b8c:	29742404 	addi	r5,r5,-12144
 8222b90:	e13fff17 	ldw	r4,-4(fp)
 8222b94:	82227b40 	call	82227b4 <alt_tse_phy_restart_an>
    
    if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0) {
 8222b98:	01c00044 	movi	r7,1
 8222b9c:	01800144 	movi	r6,5
 8222ba0:	01400044 	movi	r5,1
 8222ba4:	e13fff17 	ldw	r4,-4(fp)
 8222ba8:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8222bac:	1000021e 	bne	r2,zero,8222bb8 <alt_tse_phy_get_cap+0xe8>
        return_value = TSE_PHY_AN_NOT_COMPLETE;
 8222bb0:	00bfffc4 	movi	r2,-1
 8222bb4:	e0bffb15 	stw	r2,-20(fp)
    }
    
    /* get PHY capabilities */
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
 8222bb8:	01c00044 	movi	r7,1
 8222bbc:	018003c4 	movi	r6,15
 8222bc0:	014003c4 	movi	r5,15
 8222bc4:	e13fff17 	ldw	r4,-4(fp)
 8222bc8:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8222bcc:	1007883a 	mov	r3,r2
 8222bd0:	e0bfff17 	ldw	r2,-4(fp)
 8222bd4:	10c00045 	stb	r3,1(r2)
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
 8222bd8:	01c00044 	movi	r7,1
 8222bdc:	01800384 	movi	r6,14
 8222be0:	014003c4 	movi	r5,15
 8222be4:	e13fff17 	ldw	r4,-4(fp)
 8222be8:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8222bec:	1007883a 	mov	r3,r2
 8222bf0:	e0bfff17 	ldw	r2,-4(fp)
 8222bf4:	10c00085 	stb	r3,2(r2)
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
 8222bf8:	01c00044 	movi	r7,1
 8222bfc:	01800344 	movi	r6,13
 8222c00:	014003c4 	movi	r5,15
 8222c04:	e13fff17 	ldw	r4,-4(fp)
 8222c08:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8222c0c:	1007883a 	mov	r3,r2
 8222c10:	e0bfff17 	ldw	r2,-4(fp)
 8222c14:	10c000c5 	stb	r3,3(r2)
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 8222c18:	01c00044 	movi	r7,1
 8222c1c:	01800304 	movi	r6,12
 8222c20:	014003c4 	movi	r5,15
 8222c24:	e13fff17 	ldw	r4,-4(fp)
 8222c28:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8222c2c:	1007883a 	mov	r3,r2
 8222c30:	e0bfff17 	ldw	r2,-4(fp)
 8222c34:	10c00105 	stb	r3,4(r2)
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 8222c38:	01c00044 	movi	r7,1
 8222c3c:	018003c4 	movi	r6,15
 8222c40:	01400044 	movi	r5,1
 8222c44:	e13fff17 	ldw	r4,-4(fp)
 8222c48:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8222c4c:	1007883a 	mov	r3,r2
 8222c50:	e0bfff17 	ldw	r2,-4(fp)
 8222c54:	10c00145 	stb	r3,5(r2)
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 8222c58:	01c00044 	movi	r7,1
 8222c5c:	01800384 	movi	r6,14
 8222c60:	01400044 	movi	r5,1
 8222c64:	e13fff17 	ldw	r4,-4(fp)
 8222c68:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8222c6c:	1007883a 	mov	r3,r2
 8222c70:	e0bfff17 	ldw	r2,-4(fp)
 8222c74:	10c00185 	stb	r3,6(r2)
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 8222c78:	01c00044 	movi	r7,1
 8222c7c:	01800344 	movi	r6,13
 8222c80:	01400044 	movi	r5,1
 8222c84:	e13fff17 	ldw	r4,-4(fp)
 8222c88:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8222c8c:	1007883a 	mov	r3,r2
 8222c90:	e0bfff17 	ldw	r2,-4(fp)
 8222c94:	10c001c5 	stb	r3,7(r2)
    pphy->link_capability.cap_100_base_t2_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_FULL, 1);
 8222c98:	01c00044 	movi	r7,1
 8222c9c:	01800284 	movi	r6,10
 8222ca0:	01400044 	movi	r5,1
 8222ca4:	e13fff17 	ldw	r4,-4(fp)
 8222ca8:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8222cac:	1007883a 	mov	r3,r2
 8222cb0:	e0bfff17 	ldw	r2,-4(fp)
 8222cb4:	10c00205 	stb	r3,8(r2)
    pphy->link_capability.cap_100_base_t2_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_HALF, 1);
 8222cb8:	01c00044 	movi	r7,1
 8222cbc:	01800244 	movi	r6,9
 8222cc0:	01400044 	movi	r5,1
 8222cc4:	e13fff17 	ldw	r4,-4(fp)
 8222cc8:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8222ccc:	1007883a 	mov	r3,r2
 8222cd0:	e0bfff17 	ldw	r2,-4(fp)
 8222cd4:	10c00245 	stb	r3,9(r2)
    pphy->link_capability.cap_10_base_t_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 8222cd8:	01c00044 	movi	r7,1
 8222cdc:	01800304 	movi	r6,12
 8222ce0:	01400044 	movi	r5,1
 8222ce4:	e13fff17 	ldw	r4,-4(fp)
 8222ce8:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8222cec:	1007883a 	mov	r3,r2
 8222cf0:	e0bfff17 	ldw	r2,-4(fp)
 8222cf4:	10c00285 	stb	r3,10(r2)
    pphy->link_capability.cap_10_base_t_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 8222cf8:	01c00044 	movi	r7,1
 8222cfc:	018002c4 	movi	r6,11
 8222d00:	01400044 	movi	r5,1
 8222d04:	e13fff17 	ldw	r4,-4(fp)
 8222d08:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8222d0c:	1007883a 	mov	r3,r2
 8222d10:	e0bfff17 	ldw	r2,-4(fp)
 8222d14:	10c002c5 	stb	r3,11(r2)
    
    /* get link partner capability */
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
 8222d18:	01c00044 	movi	r7,1
 8222d1c:	018002c4 	movi	r6,11
 8222d20:	01400284 	movi	r5,10
 8222d24:	e13fff17 	ldw	r4,-4(fp)
 8222d28:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8222d2c:	1007883a 	mov	r3,r2
 8222d30:	e0bfff17 	ldw	r2,-4(fp)
 8222d34:	10c00305 	stb	r3,12(r2)
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
 8222d38:	01c00044 	movi	r7,1
 8222d3c:	01800284 	movi	r6,10
 8222d40:	01400284 	movi	r5,10
 8222d44:	e13fff17 	ldw	r4,-4(fp)
 8222d48:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8222d4c:	1007883a 	mov	r3,r2
 8222d50:	e0bfff17 	ldw	r2,-4(fp)
 8222d54:	10c00345 	stb	r3,13(r2)
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
 8222d58:	01c00044 	movi	r7,1
 8222d5c:	01800244 	movi	r6,9
 8222d60:	01400144 	movi	r5,5
 8222d64:	e13fff17 	ldw	r4,-4(fp)
 8222d68:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8222d6c:	1007883a 	mov	r3,r2
 8222d70:	e0bfff17 	ldw	r2,-4(fp)
 8222d74:	10c00385 	stb	r3,14(r2)
    pphy->link_capability.lp_100_base_tx_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1);
 8222d78:	01c00044 	movi	r7,1
 8222d7c:	01800204 	movi	r6,8
 8222d80:	01400144 	movi	r5,5
 8222d84:	e13fff17 	ldw	r4,-4(fp)
 8222d88:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8222d8c:	1007883a 	mov	r3,r2
 8222d90:	e0bfff17 	ldw	r2,-4(fp)
 8222d94:	10c003c5 	stb	r3,15(r2)
    pphy->link_capability.lp_100_base_tx_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1);
 8222d98:	01c00044 	movi	r7,1
 8222d9c:	018001c4 	movi	r6,7
 8222da0:	01400144 	movi	r5,5
 8222da4:	e13fff17 	ldw	r4,-4(fp)
 8222da8:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8222dac:	1007883a 	mov	r3,r2
 8222db0:	e0bfff17 	ldw	r2,-4(fp)
 8222db4:	10c00405 	stb	r3,16(r2)
    pphy->link_capability.lp_10_base_tx_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1);
 8222db8:	01c00044 	movi	r7,1
 8222dbc:	01800184 	movi	r6,6
 8222dc0:	01400144 	movi	r5,5
 8222dc4:	e13fff17 	ldw	r4,-4(fp)
 8222dc8:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8222dcc:	1007883a 	mov	r3,r2
 8222dd0:	e0bfff17 	ldw	r2,-4(fp)
 8222dd4:	10c00445 	stb	r3,17(r2)
    pphy->link_capability.lp_10_base_tx_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1);
 8222dd8:	01c00044 	movi	r7,1
 8222ddc:	01800144 	movi	r6,5
 8222de0:	01400144 	movi	r5,5
 8222de4:	e13fff17 	ldw	r4,-4(fp)
 8222de8:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8222dec:	1007883a 	mov	r3,r2
 8222df0:	e0bfff17 	ldw	r2,-4(fp)
 8222df4:	10c00485 	stb	r3,18(r2)
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Capability of PHY :\n", mac_group_index, mac_info_index);
 8222df8:	e0bffe47 	ldb	r2,-7(fp)
 8222dfc:	e0fffe07 	ldb	r3,-8(fp)
 8222e00:	180d883a 	mov	r6,r3
 8222e04:	100b883a 	mov	r5,r2
 8222e08:	01020974 	movhi	r4,2085
 8222e0c:	213cef04 	addi	r4,r4,-3140
 8222e10:	821f1e00 	call	821f1e0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Full Duplex = %d\n", pphy->link_capability.cap_1000_base_x_full);
 8222e14:	e0bfff17 	ldw	r2,-4(fp)
 8222e18:	10800043 	ldbu	r2,1(r2)
 8222e1c:	10803fcc 	andi	r2,r2,255
 8222e20:	100b883a 	mov	r5,r2
 8222e24:	01020974 	movhi	r4,2085
 8222e28:	213cfa04 	addi	r4,r4,-3096
 8222e2c:	821f1e00 	call	821f1e0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Half Duplex = %d\n", pphy->link_capability.cap_1000_base_x_half);
 8222e30:	e0bfff17 	ldw	r2,-4(fp)
 8222e34:	10800083 	ldbu	r2,2(r2)
 8222e38:	10803fcc 	andi	r2,r2,255
 8222e3c:	100b883a 	mov	r5,r2
 8222e40:	01020974 	movhi	r4,2085
 8222e44:	213d0404 	addi	r4,r4,-3056
 8222e48:	821f1e00 	call	821f1e0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.cap_1000_base_t_full);
 8222e4c:	e0bfff17 	ldw	r2,-4(fp)
 8222e50:	108000c3 	ldbu	r2,3(r2)
 8222e54:	10803fcc 	andi	r2,r2,255
 8222e58:	100b883a 	mov	r5,r2
 8222e5c:	01020974 	movhi	r4,2085
 8222e60:	213d0e04 	addi	r4,r4,-3016
 8222e64:	821f1e00 	call	821f1e0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.cap_1000_base_t_half);
 8222e68:	e0bfff17 	ldw	r2,-4(fp)
 8222e6c:	10800103 	ldbu	r2,4(r2)
 8222e70:	10803fcc 	andi	r2,r2,255
 8222e74:	100b883a 	mov	r5,r2
 8222e78:	01020974 	movhi	r4,2085
 8222e7c:	213d1804 	addi	r4,r4,-2976
 8222e80:	821f1e00 	call	821f1e0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.cap_100_base_t4);
 8222e84:	e0bfff17 	ldw	r2,-4(fp)
 8222e88:	10800143 	ldbu	r2,5(r2)
 8222e8c:	10803fcc 	andi	r2,r2,255
 8222e90:	100b883a 	mov	r5,r2
 8222e94:	01020974 	movhi	r4,2085
 8222e98:	213d2204 	addi	r4,r4,-2936
 8222e9c:	821f1e00 	call	821f1e0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Full Duplex  = %d\n", pphy->link_capability.cap_100_base_x_full);
 8222ea0:	e0bfff17 	ldw	r2,-4(fp)
 8222ea4:	10800183 	ldbu	r2,6(r2)
 8222ea8:	10803fcc 	andi	r2,r2,255
 8222eac:	100b883a 	mov	r5,r2
 8222eb0:	01020974 	movhi	r4,2085
 8222eb4:	213d2c04 	addi	r4,r4,-2896
 8222eb8:	821f1e00 	call	821f1e0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Half Duplex  = %d\n", pphy->link_capability.cap_100_base_x_half);
 8222ebc:	e0bfff17 	ldw	r2,-4(fp)
 8222ec0:	108001c3 	ldbu	r2,7(r2)
 8222ec4:	10803fcc 	andi	r2,r2,255
 8222ec8:	100b883a 	mov	r5,r2
 8222ecc:	01020974 	movhi	r4,2085
 8222ed0:	213d3604 	addi	r4,r4,-2856
 8222ed4:	821f1e00 	call	821f1e0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Full Duplex = %d\n", pphy->link_capability.cap_100_base_t2_full);
 8222ed8:	e0bfff17 	ldw	r2,-4(fp)
 8222edc:	10800203 	ldbu	r2,8(r2)
 8222ee0:	10803fcc 	andi	r2,r2,255
 8222ee4:	100b883a 	mov	r5,r2
 8222ee8:	01020974 	movhi	r4,2085
 8222eec:	213d4004 	addi	r4,r4,-2816
 8222ef0:	821f1e00 	call	821f1e0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Half Duplex = %d\n", pphy->link_capability.cap_100_base_t2_half);
 8222ef4:	e0bfff17 	ldw	r2,-4(fp)
 8222ef8:	10800243 	ldbu	r2,9(r2)
 8222efc:	10803fcc 	andi	r2,r2,255
 8222f00:	100b883a 	mov	r5,r2
 8222f04:	01020974 	movhi	r4,2085
 8222f08:	213d4a04 	addi	r4,r4,-2776
 8222f0c:	821f1e00 	call	821f1e0 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Full Duplex   = %d\n", pphy->link_capability.cap_10_base_t_full);
 8222f10:	e0bfff17 	ldw	r2,-4(fp)
 8222f14:	10800283 	ldbu	r2,10(r2)
 8222f18:	10803fcc 	andi	r2,r2,255
 8222f1c:	100b883a 	mov	r5,r2
 8222f20:	01020974 	movhi	r4,2085
 8222f24:	213d5404 	addi	r4,r4,-2736
 8222f28:	821f1e00 	call	821f1e0 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Half Duplex   = %d\n", pphy->link_capability.cap_10_base_t_half);
 8222f2c:	e0bfff17 	ldw	r2,-4(fp)
 8222f30:	108002c3 	ldbu	r2,11(r2)
 8222f34:	10803fcc 	andi	r2,r2,255
 8222f38:	100b883a 	mov	r5,r2
 8222f3c:	01020974 	movhi	r4,2085
 8222f40:	213d5e04 	addi	r4,r4,-2696
 8222f44:	821f1e00 	call	821f1e0 <no_printf>
    tse_dprintf(6, "\n");
 8222f48:	01020974 	movhi	r4,2085
 8222f4c:	213bc404 	addi	r4,r4,-4336
 8222f50:	821f1e00 	call	821f1e0 <no_printf>
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Link Partner Capability :\n", mac_group_index, mac_info_index);
 8222f54:	e0bffe47 	ldb	r2,-7(fp)
 8222f58:	e0fffe07 	ldb	r3,-8(fp)
 8222f5c:	180d883a 	mov	r6,r3
 8222f60:	100b883a 	mov	r5,r2
 8222f64:	01020974 	movhi	r4,2085
 8222f68:	213d6804 	addi	r4,r4,-2656
 8222f6c:	821f1e00 	call	821f1e0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.lp_1000_base_t_full);
 8222f70:	e0bfff17 	ldw	r2,-4(fp)
 8222f74:	10800303 	ldbu	r2,12(r2)
 8222f78:	10803fcc 	andi	r2,r2,255
 8222f7c:	100b883a 	mov	r5,r2
 8222f80:	01020974 	movhi	r4,2085
 8222f84:	213d0e04 	addi	r4,r4,-3016
 8222f88:	821f1e00 	call	821f1e0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.lp_1000_base_t_half);
 8222f8c:	e0bfff17 	ldw	r2,-4(fp)
 8222f90:	10800343 	ldbu	r2,13(r2)
 8222f94:	10803fcc 	andi	r2,r2,255
 8222f98:	100b883a 	mov	r5,r2
 8222f9c:	01020974 	movhi	r4,2085
 8222fa0:	213d1804 	addi	r4,r4,-2976
 8222fa4:	821f1e00 	call	821f1e0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.lp_100_base_t4);
 8222fa8:	e0bfff17 	ldw	r2,-4(fp)
 8222fac:	10800383 	ldbu	r2,14(r2)
 8222fb0:	10803fcc 	andi	r2,r2,255
 8222fb4:	100b883a 	mov	r5,r2
 8222fb8:	01020974 	movhi	r4,2085
 8222fbc:	213d2204 	addi	r4,r4,-2936
 8222fc0:	821f1e00 	call	821f1e0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Full Duplex = %d\n", pphy->link_capability.lp_100_base_tx_full);
 8222fc4:	e0bfff17 	ldw	r2,-4(fp)
 8222fc8:	108003c3 	ldbu	r2,15(r2)
 8222fcc:	10803fcc 	andi	r2,r2,255
 8222fd0:	100b883a 	mov	r5,r2
 8222fd4:	01020974 	movhi	r4,2085
 8222fd8:	213d7504 	addi	r4,r4,-2604
 8222fdc:	821f1e00 	call	821f1e0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Half Duplex = %d\n", pphy->link_capability.lp_100_base_tx_half);
 8222fe0:	e0bfff17 	ldw	r2,-4(fp)
 8222fe4:	10800403 	ldbu	r2,16(r2)
 8222fe8:	10803fcc 	andi	r2,r2,255
 8222fec:	100b883a 	mov	r5,r2
 8222ff0:	01020974 	movhi	r4,2085
 8222ff4:	213d7f04 	addi	r4,r4,-2564
 8222ff8:	821f1e00 	call	821f1e0 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Full Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_full);
 8222ffc:	e0bfff17 	ldw	r2,-4(fp)
 8223000:	10800443 	ldbu	r2,17(r2)
 8223004:	10803fcc 	andi	r2,r2,255
 8223008:	100b883a 	mov	r5,r2
 822300c:	01020974 	movhi	r4,2085
 8223010:	213d8904 	addi	r4,r4,-2524
 8223014:	821f1e00 	call	821f1e0 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Half Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_half);
 8223018:	e0bfff17 	ldw	r2,-4(fp)
 822301c:	10800483 	ldbu	r2,18(r2)
 8223020:	10803fcc 	andi	r2,r2,255
 8223024:	100b883a 	mov	r5,r2
 8223028:	01020974 	movhi	r4,2085
 822302c:	213d9304 	addi	r4,r4,-2484
 8223030:	821f1e00 	call	821f1e0 <no_printf>
    tse_dprintf(6, "\n");
 8223034:	01020974 	movhi	r4,2085
 8223038:	213bc404 	addi	r4,r4,-4336
 822303c:	821f1e00 	call	821f1e0 <no_printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8223040:	e0bffe83 	ldbu	r2,-6(fp)
 8223044:	100b883a 	mov	r5,r2
 8223048:	e13fff17 	ldw	r4,-4(fp)
 822304c:	822116c0 	call	822116c <alt_tse_phy_wr_mdio_addr>
    
    return return_value;
 8223050:	e0bffb17 	ldw	r2,-20(fp)
    
}
 8223054:	e037883a 	mov	sp,fp
 8223058:	dfc00117 	ldw	ra,4(sp)
 822305c:	df000017 	ldw	fp,0(sp)
 8223060:	dec00204 	addi	sp,sp,8
 8223064:	f800283a 	ret

08223068 <alt_tse_phy_set_adv_1000>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_1000(alt_tse_phy_info *pphy, alt_u8 enable) {
 8223068:	defff804 	addi	sp,sp,-32
 822306c:	dfc00715 	stw	ra,28(sp)
 8223070:	df000615 	stw	fp,24(sp)
 8223074:	df000604 	addi	fp,sp,24
 8223078:	e13ffe15 	stw	r4,-8(fp)
 822307c:	2805883a 	mov	r2,r5
 8223080:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 8223084:	e0bffe17 	ldw	r2,-8(fp)
 8223088:	10800617 	ldw	r2,24(r2)
 822308c:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 8223090:	e0bffb17 	ldw	r2,-20(fp)
 8223094:	10800317 	ldw	r2,12(r2)
 8223098:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 822309c:	e13ffb17 	ldw	r4,-20(fp)
 82230a0:	82203d80 	call	82203d8 <alt_tse_get_mac_info_index>
 82230a4:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 82230a8:	e13ffc17 	ldw	r4,-16(fp)
 82230ac:	82203640 	call	8220364 <alt_tse_get_mac_group_index>
 82230b0:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 82230b4:	e13ffe17 	ldw	r4,-8(fp)
 82230b8:	82211240 	call	8221124 <alt_tse_phy_rd_mdio_addr>
 82230bc:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 82230c0:	e0bffe17 	ldw	r2,-8(fp)
 82230c4:	10800003 	ldbu	r2,0(r2)
 82230c8:	10803fcc 	andi	r2,r2,255
 82230cc:	100b883a 	mov	r5,r2
 82230d0:	e13ffe17 	ldw	r4,-8(fp)
 82230d4:	822116c0 	call	822116c <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 82230d8:	e0bfff03 	ldbu	r2,-4(fp)
 82230dc:	10002d26 	beq	r2,zero,8223194 <alt_tse_phy_set_adv_1000+0x12c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1); 
 82230e0:	01c00044 	movi	r7,1
 82230e4:	01800344 	movi	r6,13
 82230e8:	014003c4 	movi	r5,15
 82230ec:	e13ffe17 	ldw	r4,-8(fp)
 82230f0:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 82230f4:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, cap);
 82230f8:	e0bffdc3 	ldbu	r2,-9(fp)
 82230fc:	d8800015 	stw	r2,0(sp)
 8223100:	01c00044 	movi	r7,1
 8223104:	01800244 	movi	r6,9
 8223108:	01400244 	movi	r5,9
 822310c:	e13ffe17 	ldw	r4,-8(fp)
 8223110:	82211c40 	call	82211c4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 8223114:	e0bffd47 	ldb	r2,-11(fp)
 8223118:	e0fffd07 	ldb	r3,-12(fp)
 822311c:	e13ffdc3 	ldbu	r4,-9(fp)
 8223120:	200f883a 	mov	r7,r4
 8223124:	180d883a 	mov	r6,r3
 8223128:	100b883a 	mov	r5,r2
 822312c:	01020974 	movhi	r4,2085
 8223130:	213d9d04 	addi	r4,r4,-2444
 8223134:	821f1e00 	call	821f1e0 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 8223138:	01c00044 	movi	r7,1
 822313c:	01800304 	movi	r6,12
 8223140:	014003c4 	movi	r5,15
 8223144:	e13ffe17 	ldw	r4,-8(fp)
 8223148:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 822314c:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, cap);
 8223150:	e0bffdc3 	ldbu	r2,-9(fp)
 8223154:	d8800015 	stw	r2,0(sp)
 8223158:	01c00044 	movi	r7,1
 822315c:	01800204 	movi	r6,8
 8223160:	01400244 	movi	r5,9
 8223164:	e13ffe17 	ldw	r4,-8(fp)
 8223168:	82211c40 	call	82211c4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 822316c:	e0bffd47 	ldb	r2,-11(fp)
 8223170:	e0fffd07 	ldb	r3,-12(fp)
 8223174:	e13ffdc3 	ldbu	r4,-9(fp)
 8223178:	200f883a 	mov	r7,r4
 822317c:	180d883a 	mov	r6,r3
 8223180:	100b883a 	mov	r5,r2
 8223184:	01020974 	movhi	r4,2085
 8223188:	213db004 	addi	r4,r4,-2368
 822318c:	821f1e00 	call	821f1e0 <no_printf>
 8223190:	00001c06 	br	8223204 <alt_tse_phy_set_adv_1000+0x19c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, 0);
 8223194:	d8000015 	stw	zero,0(sp)
 8223198:	01c00044 	movi	r7,1
 822319c:	01800244 	movi	r6,9
 82231a0:	01400244 	movi	r5,9
 82231a4:	e13ffe17 	ldw	r4,-8(fp)
 82231a8:	82211c40 	call	82211c4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 82231ac:	e0bffd47 	ldb	r2,-11(fp)
 82231b0:	e0fffd07 	ldb	r3,-12(fp)
 82231b4:	000f883a 	mov	r7,zero
 82231b8:	180d883a 	mov	r6,r3
 82231bc:	100b883a 	mov	r5,r2
 82231c0:	01020974 	movhi	r4,2085
 82231c4:	213d9d04 	addi	r4,r4,-2444
 82231c8:	821f1e00 	call	821f1e0 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, 0);
 82231cc:	d8000015 	stw	zero,0(sp)
 82231d0:	01c00044 	movi	r7,1
 82231d4:	01800204 	movi	r6,8
 82231d8:	01400244 	movi	r5,9
 82231dc:	e13ffe17 	ldw	r4,-8(fp)
 82231e0:	82211c40 	call	82211c4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement 1000 Base-T half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 82231e4:	e0bffd47 	ldb	r2,-11(fp)
 82231e8:	e0fffd07 	ldb	r3,-12(fp)
 82231ec:	000f883a 	mov	r7,zero
 82231f0:	180d883a 	mov	r6,r3
 82231f4:	100b883a 	mov	r5,r2
 82231f8:	01020974 	movhi	r4,2085
 82231fc:	213dc304 	addi	r4,r4,-2292
 8223200:	821f1e00 	call	821f1e0 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);    
 8223204:	e0bffd83 	ldbu	r2,-10(fp)
 8223208:	100b883a 	mov	r5,r2
 822320c:	e13ffe17 	ldw	r4,-8(fp)
 8223210:	822116c0 	call	822116c <alt_tse_phy_wr_mdio_addr>

    return SUCCESS;
 8223214:	0005883a 	mov	r2,zero
}
 8223218:	e037883a 	mov	sp,fp
 822321c:	dfc00117 	ldw	ra,4(sp)
 8223220:	df000017 	ldw	fp,0(sp)
 8223224:	dec00204 	addi	sp,sp,8
 8223228:	f800283a 	ret

0822322c <alt_tse_phy_set_adv_100>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_100(alt_tse_phy_info *pphy, alt_u8 enable) {
 822322c:	defff804 	addi	sp,sp,-32
 8223230:	dfc00715 	stw	ra,28(sp)
 8223234:	df000615 	stw	fp,24(sp)
 8223238:	df000604 	addi	fp,sp,24
 822323c:	e13ffe15 	stw	r4,-8(fp)
 8223240:	2805883a 	mov	r2,r5
 8223244:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 8223248:	e0bffe17 	ldw	r2,-8(fp)
 822324c:	10800617 	ldw	r2,24(r2)
 8223250:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 8223254:	e0bffb17 	ldw	r2,-20(fp)
 8223258:	10800317 	ldw	r2,12(r2)
 822325c:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8223260:	e13ffb17 	ldw	r4,-20(fp)
 8223264:	82203d80 	call	82203d8 <alt_tse_get_mac_info_index>
 8223268:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 822326c:	e13ffc17 	ldw	r4,-16(fp)
 8223270:	82203640 	call	8220364 <alt_tse_get_mac_group_index>
 8223274:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 8223278:	e13ffe17 	ldw	r4,-8(fp)
 822327c:	82211240 	call	8221124 <alt_tse_phy_rd_mdio_addr>
 8223280:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 8223284:	e0bffe17 	ldw	r2,-8(fp)
 8223288:	10800003 	ldbu	r2,0(r2)
 822328c:	10803fcc 	andi	r2,r2,255
 8223290:	100b883a 	mov	r5,r2
 8223294:	e13ffe17 	ldw	r4,-8(fp)
 8223298:	822116c0 	call	822116c <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 822329c:	e0bfff03 	ldbu	r2,-4(fp)
 82232a0:	10004326 	beq	r2,zero,82233b0 <alt_tse_phy_set_adv_100+0x184>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 82232a4:	01c00044 	movi	r7,1
 82232a8:	018003c4 	movi	r6,15
 82232ac:	01400044 	movi	r5,1
 82232b0:	e13ffe17 	ldw	r4,-8(fp)
 82232b4:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 82232b8:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, cap);
 82232bc:	e0bffdc3 	ldbu	r2,-9(fp)
 82232c0:	d8800015 	stw	r2,0(sp)
 82232c4:	01c00044 	movi	r7,1
 82232c8:	01800244 	movi	r6,9
 82232cc:	01400104 	movi	r5,4
 82232d0:	e13ffe17 	ldw	r4,-8(fp)
 82232d4:	82211c40 	call	82211c4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, cap);
 82232d8:	e0bffd47 	ldb	r2,-11(fp)
 82232dc:	e0fffd07 	ldb	r3,-12(fp)
 82232e0:	e13ffdc3 	ldbu	r4,-9(fp)
 82232e4:	200f883a 	mov	r7,r4
 82232e8:	180d883a 	mov	r6,r3
 82232ec:	100b883a 	mov	r5,r2
 82232f0:	01020974 	movhi	r4,2085
 82232f4:	213dd504 	addi	r4,r4,-2220
 82232f8:	821f1e00 	call	821f1e0 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 82232fc:	01c00044 	movi	r7,1
 8223300:	01800384 	movi	r6,14
 8223304:	01400044 	movi	r5,1
 8223308:	e13ffe17 	ldw	r4,-8(fp)
 822330c:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8223310:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, cap);
 8223314:	e0bffdc3 	ldbu	r2,-9(fp)
 8223318:	d8800015 	stw	r2,0(sp)
 822331c:	01c00044 	movi	r7,1
 8223320:	01800204 	movi	r6,8
 8223324:	01400104 	movi	r5,4
 8223328:	e13ffe17 	ldw	r4,-8(fp)
 822332c:	82211c40 	call	82211c4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 8223330:	e0bffd47 	ldb	r2,-11(fp)
 8223334:	e0fffd07 	ldb	r3,-12(fp)
 8223338:	e13ffdc3 	ldbu	r4,-9(fp)
 822333c:	200f883a 	mov	r7,r4
 8223340:	180d883a 	mov	r6,r3
 8223344:	100b883a 	mov	r5,r2
 8223348:	01020974 	movhi	r4,2085
 822334c:	213de504 	addi	r4,r4,-2156
 8223350:	821f1e00 	call	821f1e0 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 8223354:	01c00044 	movi	r7,1
 8223358:	01800344 	movi	r6,13
 822335c:	01400044 	movi	r5,1
 8223360:	e13ffe17 	ldw	r4,-8(fp)
 8223364:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8223368:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, cap);
 822336c:	e0bffdc3 	ldbu	r2,-9(fp)
 8223370:	d8800015 	stw	r2,0(sp)
 8223374:	01c00044 	movi	r7,1
 8223378:	018001c4 	movi	r6,7
 822337c:	01400104 	movi	r5,4
 8223380:	e13ffe17 	ldw	r4,-8(fp)
 8223384:	82211c40 	call	82211c4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 8223388:	e0bffd47 	ldb	r2,-11(fp)
 822338c:	e0fffd07 	ldb	r3,-12(fp)
 8223390:	e13ffdc3 	ldbu	r4,-9(fp)
 8223394:	200f883a 	mov	r7,r4
 8223398:	180d883a 	mov	r6,r3
 822339c:	100b883a 	mov	r5,r2
 82233a0:	01020974 	movhi	r4,2085
 82233a4:	213df804 	addi	r4,r4,-2080
 82233a8:	821f1e00 	call	821f1e0 <no_printf>
 82233ac:	00002a06 	br	8223458 <alt_tse_phy_set_adv_100+0x22c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, 0);
 82233b0:	d8000015 	stw	zero,0(sp)
 82233b4:	01c00044 	movi	r7,1
 82233b8:	01800244 	movi	r6,9
 82233bc:	01400104 	movi	r5,4
 82233c0:	e13ffe17 	ldw	r4,-8(fp)
 82233c4:	82211c40 	call	82211c4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, 0);
 82233c8:	e0bffd47 	ldb	r2,-11(fp)
 82233cc:	e0fffd07 	ldb	r3,-12(fp)
 82233d0:	000f883a 	mov	r7,zero
 82233d4:	180d883a 	mov	r6,r3
 82233d8:	100b883a 	mov	r5,r2
 82233dc:	01020974 	movhi	r4,2085
 82233e0:	213dd504 	addi	r4,r4,-2220
 82233e4:	821f1e00 	call	821f1e0 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, 0);
 82233e8:	d8000015 	stw	zero,0(sp)
 82233ec:	01c00044 	movi	r7,1
 82233f0:	01800204 	movi	r6,8
 82233f4:	01400104 	movi	r5,4
 82233f8:	e13ffe17 	ldw	r4,-8(fp)
 82233fc:	82211c40 	call	82211c4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 8223400:	e0bffd47 	ldb	r2,-11(fp)
 8223404:	e0fffd07 	ldb	r3,-12(fp)
 8223408:	000f883a 	mov	r7,zero
 822340c:	180d883a 	mov	r6,r3
 8223410:	100b883a 	mov	r5,r2
 8223414:	01020974 	movhi	r4,2085
 8223418:	213de504 	addi	r4,r4,-2156
 822341c:	821f1e00 	call	821f1e0 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, 0);
 8223420:	d8000015 	stw	zero,0(sp)
 8223424:	01c00044 	movi	r7,1
 8223428:	018001c4 	movi	r6,7
 822342c:	01400104 	movi	r5,4
 8223430:	e13ffe17 	ldw	r4,-8(fp)
 8223434:	82211c40 	call	82211c4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 8223438:	e0bffd47 	ldb	r2,-11(fp)
 822343c:	e0fffd07 	ldb	r3,-12(fp)
 8223440:	000f883a 	mov	r7,zero
 8223444:	180d883a 	mov	r6,r3
 8223448:	100b883a 	mov	r5,r2
 822344c:	01020974 	movhi	r4,2085
 8223450:	213df804 	addi	r4,r4,-2080
 8223454:	821f1e00 	call	821f1e0 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);  
 8223458:	e0bffd83 	ldbu	r2,-10(fp)
 822345c:	100b883a 	mov	r5,r2
 8223460:	e13ffe17 	ldw	r4,-8(fp)
 8223464:	822116c0 	call	822116c <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 8223468:	0005883a 	mov	r2,zero
}
 822346c:	e037883a 	mov	sp,fp
 8223470:	dfc00117 	ldw	ra,4(sp)
 8223474:	df000017 	ldw	fp,0(sp)
 8223478:	dec00204 	addi	sp,sp,8
 822347c:	f800283a 	ret

08223480 <alt_tse_phy_set_adv_10>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_10(alt_tse_phy_info *pphy, alt_u8 enable) {
 8223480:	defff504 	addi	sp,sp,-44
 8223484:	dfc00a15 	stw	ra,40(sp)
 8223488:	df000915 	stw	fp,36(sp)
 822348c:	df000904 	addi	fp,sp,36
 8223490:	e13ffe15 	stw	r4,-8(fp)
 8223494:	2805883a 	mov	r2,r5
 8223498:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 822349c:	e0bffe17 	ldw	r2,-8(fp)
 82234a0:	10800617 	ldw	r2,24(r2)
 82234a4:	e0bff815 	stw	r2,-32(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 82234a8:	e0bff817 	ldw	r2,-32(fp)
 82234ac:	10800317 	ldw	r2,12(r2)
 82234b0:	e0bff915 	stw	r2,-28(fp)
    
    /* get index of the pointers in pointer array list */
    int mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 82234b4:	e13ff817 	ldw	r4,-32(fp)
 82234b8:	82203d80 	call	82203d8 <alt_tse_get_mac_info_index>
 82234bc:	e0bffa15 	stw	r2,-24(fp)
    int mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 82234c0:	e13ff917 	ldw	r4,-28(fp)
 82234c4:	82203640 	call	8220364 <alt_tse_get_mac_group_index>
 82234c8:	e0bffb15 	stw	r2,-20(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    int mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 82234cc:	e13ffe17 	ldw	r4,-8(fp)
 82234d0:	82211240 	call	8221124 <alt_tse_phy_rd_mdio_addr>
 82234d4:	e0bffc15 	stw	r2,-16(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 82234d8:	e0bffe17 	ldw	r2,-8(fp)
 82234dc:	10800003 	ldbu	r2,0(r2)
 82234e0:	10803fcc 	andi	r2,r2,255
 82234e4:	100b883a 	mov	r5,r2
 82234e8:	e13ffe17 	ldw	r4,-8(fp)
 82234ec:	822116c0 	call	822116c <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 82234f0:	e0bfff03 	ldbu	r2,-4(fp)
 82234f4:	10002926 	beq	r2,zero,822359c <alt_tse_phy_set_adv_10+0x11c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 82234f8:	01c00044 	movi	r7,1
 82234fc:	01800304 	movi	r6,12
 8223500:	01400044 	movi	r5,1
 8223504:	e13ffe17 	ldw	r4,-8(fp)
 8223508:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 822350c:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, cap);
 8223510:	e0bffd03 	ldbu	r2,-12(fp)
 8223514:	d8800015 	stw	r2,0(sp)
 8223518:	01c00044 	movi	r7,1
 822351c:	01800184 	movi	r6,6
 8223520:	01400104 	movi	r5,4
 8223524:	e13ffe17 	ldw	r4,-8(fp)
 8223528:	82211c40 	call	82211c4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 822352c:	e0bffd03 	ldbu	r2,-12(fp)
 8223530:	100f883a 	mov	r7,r2
 8223534:	e1bffa17 	ldw	r6,-24(fp)
 8223538:	e17ffb17 	ldw	r5,-20(fp)
 822353c:	01020974 	movhi	r4,2085
 8223540:	213e0b04 	addi	r4,r4,-2004
 8223544:	821f1e00 	call	821f1e0 <no_printf>
    
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 8223548:	01c00044 	movi	r7,1
 822354c:	018002c4 	movi	r6,11
 8223550:	01400044 	movi	r5,1
 8223554:	e13ffe17 	ldw	r4,-8(fp)
 8223558:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 822355c:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, cap);
 8223560:	e0bffd03 	ldbu	r2,-12(fp)
 8223564:	d8800015 	stw	r2,0(sp)
 8223568:	01c00044 	movi	r7,1
 822356c:	01800144 	movi	r6,5
 8223570:	01400104 	movi	r5,4
 8223574:	e13ffe17 	ldw	r4,-8(fp)
 8223578:	82211c40 	call	82211c4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 822357c:	e0bffd03 	ldbu	r2,-12(fp)
 8223580:	100f883a 	mov	r7,r2
 8223584:	e1bffa17 	ldw	r6,-24(fp)
 8223588:	e17ffb17 	ldw	r5,-20(fp)
 822358c:	01020974 	movhi	r4,2085
 8223590:	213e1e04 	addi	r4,r4,-1928
 8223594:	821f1e00 	call	821f1e0 <no_printf>
 8223598:	00001806 	br	82235fc <alt_tse_phy_set_adv_10+0x17c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, 0);
 822359c:	d8000015 	stw	zero,0(sp)
 82235a0:	01c00044 	movi	r7,1
 82235a4:	01800184 	movi	r6,6
 82235a8:	01400104 	movi	r5,4
 82235ac:	e13ffe17 	ldw	r4,-8(fp)
 82235b0:	82211c40 	call	82211c4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 82235b4:	000f883a 	mov	r7,zero
 82235b8:	e1bffa17 	ldw	r6,-24(fp)
 82235bc:	e17ffb17 	ldw	r5,-20(fp)
 82235c0:	01020974 	movhi	r4,2085
 82235c4:	213e0b04 	addi	r4,r4,-2004
 82235c8:	821f1e00 	call	821f1e0 <no_printf>
    
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, 0);
 82235cc:	d8000015 	stw	zero,0(sp)
 82235d0:	01c00044 	movi	r7,1
 82235d4:	01800144 	movi	r6,5
 82235d8:	01400104 	movi	r5,4
 82235dc:	e13ffe17 	ldw	r4,-8(fp)
 82235e0:	82211c40 	call	82211c4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 82235e4:	000f883a 	mov	r7,zero
 82235e8:	e1bffa17 	ldw	r6,-24(fp)
 82235ec:	e17ffb17 	ldw	r5,-20(fp)
 82235f0:	01020974 	movhi	r4,2085
 82235f4:	213e1e04 	addi	r4,r4,-1928
 82235f8:	821f1e00 	call	821f1e0 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 82235fc:	e0bffc17 	ldw	r2,-16(fp)
 8223600:	10803fcc 	andi	r2,r2,255
 8223604:	100b883a 	mov	r5,r2
 8223608:	e13ffe17 	ldw	r4,-8(fp)
 822360c:	822116c0 	call	822116c <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 8223610:	0005883a 	mov	r2,zero
}
 8223614:	e037883a 	mov	sp,fp
 8223618:	dfc00117 	ldw	ra,4(sp)
 822361c:	df000017 	ldw	fp,0(sp)
 8223620:	dec00204 	addi	sp,sp,8
 8223624:	f800283a 	ret

08223628 <alt_tse_phy_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Internal
 * @param pmac_group    Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_phy_get_common_speed(alt_tse_mac_group *pmac_group) {
 8223628:	defff604 	addi	sp,sp,-40
 822362c:	dfc00915 	stw	ra,36(sp)
 8223630:	df000815 	stw	fp,32(sp)
 8223634:	df000804 	addi	fp,sp,32
 8223638:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 i;
	alt_u8 common_1000 = 1;
 822363c:	00800044 	movi	r2,1
 8223640:	e0bff905 	stb	r2,-28(fp)
	alt_u8 common_100 = 1;
 8223644:	00800044 	movi	r2,1
 8223648:	e0bff945 	stb	r2,-27(fp)
	alt_u8 common_10 = 1;
 822364c:	00800044 	movi	r2,1
 8223650:	e0bff985 	stb	r2,-26(fp)
    
	alt_32 common_speed;
    
	alt_u8 none_an_complete = 1;
 8223654:	00800044 	movi	r2,1
 8223658:	e0bffb05 	stb	r2,-20(fp)
    
    alt_tse_mac_info *pmac_info = 0;
 822365c:	e03ffc15 	stw	zero,-16(fp)
    alt_tse_phy_info *pphy = 0;
 8223660:	e03ffd15 	stw	zero,-12(fp)
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8223664:	e13fff17 	ldw	r4,-4(fp)
 8223668:	82203640 	call	8220364 <alt_tse_get_mac_group_index>
 822366c:	e0bffe05 	stb	r2,-8(fp)
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 8223670:	e03ff815 	stw	zero,-32(fp)
 8223674:	00001c06 	br	82236e8 <alt_tse_phy_get_common_speed+0xc0>
        pmac_info = pmac_group->pmac_info[i];
 8223678:	e0ffff17 	ldw	r3,-4(fp)
 822367c:	e0bff817 	ldw	r2,-32(fp)
 8223680:	10800044 	addi	r2,r2,1
 8223684:	1085883a 	add	r2,r2,r2
 8223688:	1085883a 	add	r2,r2,r2
 822368c:	1885883a 	add	r2,r3,r2
 8223690:	10800017 	ldw	r2,0(r2)
 8223694:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
 8223698:	e0bffc17 	ldw	r2,-16(fp)
 822369c:	10800117 	ldw	r2,4(r2)
 82236a0:	e0bffd15 	stw	r2,-12(fp)
        
        /* run only if PHY connected */
        if(pphy) {
 82236a4:	e0bffd17 	ldw	r2,-12(fp)
 82236a8:	10000926 	beq	r2,zero,82236d0 <alt_tse_phy_get_common_speed+0xa8>
            alt_tse_phy_set_adv_1000(pphy, 1);
 82236ac:	01400044 	movi	r5,1
 82236b0:	e13ffd17 	ldw	r4,-12(fp)
 82236b4:	82230680 	call	8223068 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 82236b8:	01400044 	movi	r5,1
 82236bc:	e13ffd17 	ldw	r4,-12(fp)
 82236c0:	822322c0 	call	822322c <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 82236c4:	01400044 	movi	r5,1
 82236c8:	e13ffd17 	ldw	r4,-12(fp)
 82236cc:	82234800 	call	8223480 <alt_tse_phy_set_adv_10>
        }
        tse_dprintf(6, "\n");
 82236d0:	01020974 	movhi	r4,2085
 82236d4:	213bc404 	addi	r4,r4,-4336
 82236d8:	821f1e00 	call	821f1e0 <no_printf>
    alt_tse_phy_info *pphy = 0;
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 82236dc:	e0bff817 	ldw	r2,-32(fp)
 82236e0:	10800044 	addi	r2,r2,1
 82236e4:	e0bff815 	stw	r2,-32(fp)
 82236e8:	e0bfff17 	ldw	r2,-4(fp)
 82236ec:	10800003 	ldbu	r2,0(r2)
 82236f0:	10803fcc 	andi	r2,r2,255
 82236f4:	e0fff817 	ldw	r3,-32(fp)
 82236f8:	18bfdf16 	blt	r3,r2,8223678 <alt_tse_phy_get_common_speed+0x50>
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 82236fc:	e03ff815 	stw	zero,-32(fp)
 8223700:	00005606 	br	822385c <alt_tse_phy_get_common_speed+0x234>

        pmac_info = pmac_group->pmac_info[i];
 8223704:	e0ffff17 	ldw	r3,-4(fp)
 8223708:	e0bff817 	ldw	r2,-32(fp)
 822370c:	10800044 	addi	r2,r2,1
 8223710:	1085883a 	add	r2,r2,r2
 8223714:	1085883a 	add	r2,r2,r2
 8223718:	1885883a 	add	r2,r3,r2
 822371c:	10800017 	ldw	r2,0(r2)
 8223720:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
 8223724:	e0bffc17 	ldw	r2,-16(fp)
 8223728:	10800117 	ldw	r2,4(r2)
 822372c:	e0bffd15 	stw	r2,-12(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 8223730:	e0bffd17 	ldw	r2,-12(fp)
 8223734:	10004326 	beq	r2,zero,8223844 <alt_tse_phy_get_common_speed+0x21c>
            continue;
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
 8223738:	e13ffd17 	ldw	r4,-12(fp)
 822373c:	8222ad00 	call	8222ad0 <alt_tse_phy_get_cap>
 8223740:	1000421e 	bne	r2,zero,822384c <alt_tse_phy_get_common_speed+0x224>
            continue;
        }
        
        none_an_complete = 0;
 8223744:	e03ffb05 	stb	zero,-20(fp)
        
        /* Small MAC */
        if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 8223748:	e0bffc17 	ldw	r2,-16(fp)
 822374c:	10800003 	ldbu	r2,0(r2)
 8223750:	10803fcc 	andi	r2,r2,255
 8223754:	10800058 	cmpnei	r2,r2,1
 8223758:	1000021e 	bne	r2,zero,8223764 <alt_tse_phy_get_common_speed+0x13c>
            common_1000 = 0;
 822375c:	e03ff905 	stb	zero,-28(fp)
 8223760:	00000706 	br	8223780 <alt_tse_phy_get_common_speed+0x158>
        }
        else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 8223764:	e0bffc17 	ldw	r2,-16(fp)
 8223768:	10800003 	ldbu	r2,0(r2)
 822376c:	10803fcc 	andi	r2,r2,255
 8223770:	10800098 	cmpnei	r2,r2,2
 8223774:	1000021e 	bne	r2,zero,8223780 <alt_tse_phy_get_common_speed+0x158>
            common_100 = 0;
 8223778:	e03ff945 	stb	zero,-27(fp)
            common_10 = 0;            
 822377c:	e03ff985 	stb	zero,-26(fp)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
 8223780:	e0bffd17 	ldw	r2,-12(fp)
 8223784:	10c000c3 	ldbu	r3,3(r2)
 8223788:	e0bffd17 	ldw	r2,-12(fp)
 822378c:	10800303 	ldbu	r2,12(r2)
 8223790:	1884703a 	and	r2,r3,r2
 8223794:	1007883a 	mov	r3,r2
 8223798:	e0bff903 	ldbu	r2,-28(fp)
 822379c:	1884703a 	and	r2,r3,r2
 82237a0:	e0bff905 	stb	r2,-28(fp)
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 82237a4:	e0bffd17 	ldw	r2,-12(fp)
 82237a8:	10c00183 	ldbu	r3,6(r2)
 82237ac:	e0bffd17 	ldw	r2,-12(fp)
 82237b0:	108003c3 	ldbu	r2,15(r2)
 82237b4:	1884703a 	and	r2,r3,r2
 82237b8:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
 82237bc:	e0bffd17 	ldw	r2,-12(fp)
 82237c0:	10c001c3 	ldbu	r3,7(r2)
 82237c4:	e0bffd17 	ldw	r2,-12(fp)
 82237c8:	10800403 	ldbu	r2,16(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 82237cc:	1884703a 	and	r2,r3,r2
 82237d0:	2084b03a 	or	r2,r4,r2
 82237d4:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
 82237d8:	e0bffd17 	ldw	r2,-12(fp)
 82237dc:	10c00143 	ldbu	r3,5(r2)
 82237e0:	e0bffd17 	ldw	r2,-12(fp)
 82237e4:	10800383 	ldbu	r2,14(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 82237e8:	1884703a 	and	r2,r3,r2
 82237ec:	2084b03a 	or	r2,r4,r2
 82237f0:	1007883a 	mov	r3,r2
 82237f4:	e0bff943 	ldbu	r2,-27(fp)
 82237f8:	1884703a 	and	r2,r3,r2
 82237fc:	e0bff945 	stb	r2,-27(fp)
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
 8223800:	e0bffd17 	ldw	r2,-12(fp)
 8223804:	10c00283 	ldbu	r3,10(r2)
 8223808:	e0bffd17 	ldw	r2,-12(fp)
 822380c:	10800443 	ldbu	r2,17(r2)
 8223810:	1884703a 	and	r2,r3,r2
 8223814:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));
 8223818:	e0bffd17 	ldw	r2,-12(fp)
 822381c:	10c002c3 	ldbu	r3,11(r2)
 8223820:	e0bffd17 	ldw	r2,-12(fp)
 8223824:	10800483 	ldbu	r2,18(r2)
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
 8223828:	1884703a 	and	r2,r3,r2
 822382c:	2084b03a 	or	r2,r4,r2
 8223830:	1007883a 	mov	r3,r2
 8223834:	e0bff983 	ldbu	r2,-26(fp)
 8223838:	1884703a 	and	r2,r3,r2
 822383c:	e0bff985 	stb	r2,-26(fp)
 8223840:	00000306 	br	8223850 <alt_tse_phy_get_common_speed+0x228>
        pmac_info = pmac_group->pmac_info[i];
        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
 8223844:	0001883a 	nop
 8223848:	00000106 	br	8223850 <alt_tse_phy_get_common_speed+0x228>
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
            continue;
 822384c:	0001883a 	nop
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 8223850:	e0bff817 	ldw	r2,-32(fp)
 8223854:	10800044 	addi	r2,r2,1
 8223858:	e0bff815 	stw	r2,-32(fp)
 822385c:	e0bfff17 	ldw	r2,-4(fp)
 8223860:	10800003 	ldbu	r2,0(r2)
 8223864:	10803fcc 	andi	r2,r2,255
 8223868:	e0fff817 	ldw	r3,-32(fp)
 822386c:	18bfa516 	blt	r3,r2,8223704 <alt_tse_phy_get_common_speed+0xdc>
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));

    }
    
    /* get common speed based on capabilities */
    if(none_an_complete == 1) {
 8223870:	e0bffb03 	ldbu	r2,-20(fp)
 8223874:	10800058 	cmpnei	r2,r2,1
 8223878:	1000081e 	bne	r2,zero,822389c <alt_tse_phy_get_common_speed+0x274>
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 822387c:	00bfffc4 	movi	r2,-1
 8223880:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - None of the PHYs Auto-Negotiation completed!\n", mac_group_index);
 8223884:	e0bffe07 	ldb	r2,-8(fp)
 8223888:	100b883a 	mov	r5,r2
 822388c:	01020974 	movhi	r4,2085
 8223890:	213e3104 	addi	r4,r4,-1852
 8223894:	82033fc0 	call	82033fc <printf>
 8223898:	00002706 	br	8223938 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_1000) {
 822389c:	e0bff903 	ldbu	r2,-28(fp)
 82238a0:	10000926 	beq	r2,zero,82238c8 <alt_tse_phy_get_common_speed+0x2a0>
        common_speed = TSE_PHY_SPEED_1000;
 82238a4:	00800084 	movi	r2,2
 82238a8:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 1000);
 82238ac:	e0bffe07 	ldb	r2,-8(fp)
 82238b0:	0180fa04 	movi	r6,1000
 82238b4:	100b883a 	mov	r5,r2
 82238b8:	01020974 	movhi	r4,2085
 82238bc:	213e4304 	addi	r4,r4,-1780
 82238c0:	82033fc0 	call	82033fc <printf>
 82238c4:	00001c06 	br	8223938 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_100) {
 82238c8:	e0bff943 	ldbu	r2,-27(fp)
 82238cc:	10000926 	beq	r2,zero,82238f4 <alt_tse_phy_get_common_speed+0x2cc>
        common_speed = TSE_PHY_SPEED_100;
 82238d0:	00800044 	movi	r2,1
 82238d4:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 100);
 82238d8:	e0bffe07 	ldb	r2,-8(fp)
 82238dc:	01801904 	movi	r6,100
 82238e0:	100b883a 	mov	r5,r2
 82238e4:	01020974 	movhi	r4,2085
 82238e8:	213e4304 	addi	r4,r4,-1780
 82238ec:	82033fc0 	call	82033fc <printf>
 82238f0:	00001106 	br	8223938 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_10) {
 82238f4:	e0bff983 	ldbu	r2,-26(fp)
 82238f8:	10000826 	beq	r2,zero,822391c <alt_tse_phy_get_common_speed+0x2f4>
        common_speed = TSE_PHY_SPEED_10;
 82238fc:	e03ffa15 	stw	zero,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 10);
 8223900:	e0bffe07 	ldb	r2,-8(fp)
 8223904:	01800284 	movi	r6,10
 8223908:	100b883a 	mov	r5,r2
 822390c:	01020974 	movhi	r4,2085
 8223910:	213e4304 	addi	r4,r4,-1780
 8223914:	82033fc0 	call	82033fc <printf>
 8223918:	00000706 	br	8223938 <alt_tse_phy_get_common_speed+0x310>
    }
    else {
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 822391c:	00bfffc4 	movi	r2,-1
 8223920:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - No common speed at all!\n", mac_group_index);    }
 8223924:	e0bffe07 	ldb	r2,-8(fp)
 8223928:	100b883a 	mov	r5,r2
 822392c:	01020974 	movhi	r4,2085
 8223930:	213e5004 	addi	r4,r4,-1728
 8223934:	82033fc0 	call	82033fc <printf>

    return common_speed;
 8223938:	e0bffa17 	ldw	r2,-24(fp)
}
 822393c:	e037883a 	mov	sp,fp
 8223940:	dfc00117 	ldw	ra,4(sp)
 8223944:	df000017 	ldw	fp,0(sp)
 8223948:	dec00204 	addi	sp,sp,8
 822394c:	f800283a 	ret

08223950 <alt_tse_phy_set_common_speed>:
 * @API Type:               Internal
 * @param pmac_group        Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 *        common_speed      common speed supported by all PHYs
 * @return      common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_phy_set_common_speed(alt_tse_mac_group *pmac_group, alt_32 common_speed) {
 8223950:	defff004 	addi	sp,sp,-64
 8223954:	dfc00f15 	stw	ra,60(sp)
 8223958:	df000e15 	stw	fp,56(sp)
 822395c:	dc400d15 	stw	r17,52(sp)
 8223960:	dc000c15 	stw	r16,48(sp)
 8223964:	df000e04 	addi	fp,sp,56
 8223968:	e13ffc15 	stw	r4,-16(fp)
 822396c:	e17ffd15 	stw	r5,-12(fp)
	alt_u8 speed;
	alt_u8 duplex;
    
	alt_u8 gb_capable;
    
    alt_tse_phy_info *pphy = 0;
 8223970:	e03ff515 	stw	zero,-44(fp)
    alt_tse_mac_info *pmac_info = 0;
 8223974:	e03ff615 	stw	zero,-40(fp)
    alt_tse_system_info *psys = 0;
 8223978:	e03ff715 	stw	zero,-36(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 822397c:	e03ff805 	stb	zero,-32(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8223980:	e13ffc17 	ldw	r4,-16(fp)
 8223984:	82203640 	call	8220364 <alt_tse_get_mac_group_index>
 8223988:	e0bff845 	stb	r2,-31(fp)
         
    /* Record previous MDIO address, to be restored at the end of function */
    np_tse_mac *pmac_group_base = (np_tse_mac *)pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 822398c:	e0bffc17 	ldw	r2,-16(fp)
 8223990:	10800117 	ldw	r2,4(r2)
 8223994:	10800217 	ldw	r2,8(r2)
 8223998:	10800017 	ldw	r2,0(r2)
 822399c:	e0bff915 	stw	r2,-28(fp)
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 82239a0:	e0bff917 	ldw	r2,-28(fp)
 82239a4:	10801004 	addi	r2,r2,64
 82239a8:	10800037 	ldwio	r2,0(r2)
 82239ac:	e0bffa15 	stw	r2,-24(fp)
    
    if((common_speed < TSE_PHY_SPEED_10) || (common_speed > TSE_PHY_SPEED_1000)) {
 82239b0:	e0bffd17 	ldw	r2,-12(fp)
 82239b4:	10000316 	blt	r2,zero,82239c4 <alt_tse_phy_set_common_speed+0x74>
 82239b8:	e0bffd17 	ldw	r2,-12(fp)
 82239bc:	108000d0 	cmplti	r2,r2,3
 82239c0:	10000c1e 	bne	r2,zero,82239f4 <alt_tse_phy_set_common_speed+0xa4>
        tse_dprintf(2, "ERROR   : MAC Group[%d] - Invalid common speed specified! common speed = %d\n", mac_group_index, (int)common_speed);
 82239c4:	e0bff847 	ldb	r2,-31(fp)
 82239c8:	e1bffd17 	ldw	r6,-12(fp)
 82239cc:	100b883a 	mov	r5,r2
 82239d0:	01020974 	movhi	r4,2085
 82239d4:	213e5d04 	addi	r4,r4,-1676
 82239d8:	82033fc0 	call	82033fc <printf>
		/* Restore previous MDIO address */
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 82239dc:	e0bff917 	ldw	r2,-28(fp)
 82239e0:	10801004 	addi	r2,r2,64
 82239e4:	e0fffa17 	ldw	r3,-24(fp)
 82239e8:	10c00035 	stwio	r3,0(r2)
        return TSE_PHY_SPEED_NO_COMMON;
 82239ec:	00bfffc4 	movi	r2,-1
 82239f0:	0000fe06 	br	8223dec <alt_tse_phy_set_common_speed+0x49c>
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 82239f4:	e03ff315 	stw	zero,-52(fp)
 82239f8:	0000dc06 	br	8223d6c <alt_tse_phy_set_common_speed+0x41c>
        pmac_info = pmac_group->pmac_info[i];
 82239fc:	e0fffc17 	ldw	r3,-16(fp)
 8223a00:	e0bff317 	ldw	r2,-52(fp)
 8223a04:	10800044 	addi	r2,r2,1
 8223a08:	1085883a 	add	r2,r2,r2
 8223a0c:	1085883a 	add	r2,r2,r2
 8223a10:	1885883a 	add	r2,r3,r2
 8223a14:	10800017 	ldw	r2,0(r2)
 8223a18:	e0bff615 	stw	r2,-40(fp)
        mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8223a1c:	e13ff617 	ldw	r4,-40(fp)
 8223a20:	82203d80 	call	82203d8 <alt_tse_get_mac_info_index>
 8223a24:	e0bff805 	stb	r2,-32(fp)

        pphy = pmac_info->pphy_info;
 8223a28:	e0bff617 	ldw	r2,-40(fp)
 8223a2c:	10800117 	ldw	r2,4(r2)
 8223a30:	e0bff515 	stw	r2,-44(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 8223a34:	e0bff517 	ldw	r2,-44(fp)
 8223a38:	1000c826 	beq	r2,zero,8223d5c <alt_tse_phy_set_common_speed+0x40c>
            continue;
        }
        
        psys = pmac_info->psys_info; 
 8223a3c:	e0bff617 	ldw	r2,-40(fp)
 8223a40:	10800217 	ldw	r2,8(r2)
 8223a44:	e0bff715 	stw	r2,-36(fp)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 8223a48:	e0bff517 	ldw	r2,-44(fp)
 8223a4c:	10800003 	ldbu	r2,0(r2)
 8223a50:	10803fcc 	andi	r2,r2,255
 8223a54:	100b883a 	mov	r5,r2
 8223a58:	e13ff517 	ldw	r4,-44(fp)
 8223a5c:	822116c0 	call	822116c <alt_tse_phy_wr_mdio_addr>

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 8223a60:	e0bff517 	ldw	r2,-44(fp)
 8223a64:	108000c3 	ldbu	r2,3(r2)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 8223a68:	10803fcc 	andi	r2,r2,255
 8223a6c:	10000c1e 	bne	r2,zero,8223aa0 <alt_tse_phy_set_common_speed+0x150>
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 8223a70:	e0bff517 	ldw	r2,-44(fp)
 8223a74:	10800103 	ldbu	r2,4(r2)
 8223a78:	10803fcc 	andi	r2,r2,255
 8223a7c:	1000081e 	bne	r2,zero,8223aa0 <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 8223a80:	e0bff517 	ldw	r2,-44(fp)
 8223a84:	10800043 	ldbu	r2,1(r2)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 8223a88:	10803fcc 	andi	r2,r2,255
 8223a8c:	1000041e 	bne	r2,zero,8223aa0 <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 8223a90:	e0bff517 	ldw	r2,-44(fp)
 8223a94:	10800083 	ldbu	r2,2(r2)
 8223a98:	10803fcc 	andi	r2,r2,255
 8223a9c:	10000226 	beq	r2,zero,8223aa8 <alt_tse_phy_set_common_speed+0x158>
 8223aa0:	00800044 	movi	r2,1
 8223aa4:	00000106 	br	8223aac <alt_tse_phy_set_common_speed+0x15c>
 8223aa8:	0005883a 	mov	r2,zero
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 8223aac:	e0bffb05 	stb	r2,-20(fp)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
        
        /* if PHY does not supports 1000 Mbps, and common speed is 1000 Mbps */
        if((!gb_capable) && (common_speed == TSE_PHY_SPEED_1000)) {
 8223ab0:	e0bffb03 	ldbu	r2,-20(fp)
 8223ab4:	1000101e 	bne	r2,zero,8223af8 <alt_tse_phy_set_common_speed+0x1a8>
 8223ab8:	e0bffd17 	ldw	r2,-12(fp)
 8223abc:	10800098 	cmpnei	r2,r2,2
 8223ac0:	10000d1e 	bne	r2,zero,8223af8 <alt_tse_phy_set_common_speed+0x1a8>
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - PHY does not support 1000 Mbps, please specify valid common speed\n", mac_group_index, mac_info_index);
 8223ac4:	e0bff847 	ldb	r2,-31(fp)
 8223ac8:	e0fff807 	ldb	r3,-32(fp)
 8223acc:	180d883a 	mov	r6,r3
 8223ad0:	100b883a 	mov	r5,r2
 8223ad4:	01020974 	movhi	r4,2085
 8223ad8:	213e7104 	addi	r4,r4,-1596
 8223adc:	82033fc0 	call	82033fc <printf>
			/* Restore previous MDIO address */
			IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 8223ae0:	e0bff917 	ldw	r2,-28(fp)
 8223ae4:	10801004 	addi	r2,r2,64
 8223ae8:	e0fffa17 	ldw	r3,-24(fp)
 8223aec:	10c00035 	stwio	r3,0(r2)
            return TSE_PHY_SPEED_NO_COMMON;
 8223af0:	00bfffc4 	movi	r2,-1
 8223af4:	0000bd06 	br	8223dec <alt_tse_phy_set_common_speed+0x49c>
        }
        
        /* if PHY is not Auto-Negotiation capable */
        if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 8223af8:	01c00044 	movi	r7,1
 8223afc:	018000c4 	movi	r6,3
 8223b00:	01400044 	movi	r5,1
 8223b04:	e13ff517 	ldw	r4,-44(fp)
 8223b08:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8223b0c:	1000141e 	bne	r2,zero,8223b60 <alt_tse_phy_set_common_speed+0x210>
            
            /* if PHY supports 1000 Mbps, write msb of speed */
            if(gb_capable) {
 8223b10:	e0bffb03 	ldbu	r2,-20(fp)
 8223b14:	10000926 	beq	r2,zero,8223b3c <alt_tse_phy_set_common_speed+0x1ec>
                alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_MSB, 1, common_speed >> 1);
 8223b18:	e0bffd17 	ldw	r2,-12(fp)
 8223b1c:	1005d07a 	srai	r2,r2,1
 8223b20:	10bfffcc 	andi	r2,r2,65535
 8223b24:	d8800015 	stw	r2,0(sp)
 8223b28:	01c00044 	movi	r7,1
 8223b2c:	01800184 	movi	r6,6
 8223b30:	000b883a 	mov	r5,zero
 8223b34:	e13ff517 	ldw	r4,-44(fp)
 8223b38:	82211c40 	call	82211c4 <alt_tse_phy_wr_mdio_reg>
            }
            /* write lsb of speed */
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_LSB, 1, common_speed);
 8223b3c:	e0bffd17 	ldw	r2,-12(fp)
 8223b40:	10bfffcc 	andi	r2,r2,65535
 8223b44:	d8800015 	stw	r2,0(sp)
 8223b48:	01c00044 	movi	r7,1
 8223b4c:	01800344 	movi	r6,13
 8223b50:	000b883a 	mov	r5,zero
 8223b54:	e13ff517 	ldw	r4,-44(fp)
 8223b58:	82211c40 	call	82211c4 <alt_tse_phy_wr_mdio_reg>
            
            /* continue to next PHY */
            continue;
 8223b5c:	00008006 	br	8223d60 <alt_tse_phy_set_common_speed+0x410>
        }
        
        /* set Auto-Negotiation advertisement based on common speed */
        if(common_speed == TSE_PHY_SPEED_1000) {
 8223b60:	e0bffd17 	ldw	r2,-12(fp)
 8223b64:	10800098 	cmpnei	r2,r2,2
 8223b68:	10000a1e 	bne	r2,zero,8223b94 <alt_tse_phy_set_common_speed+0x244>
            alt_tse_phy_set_adv_1000(pphy, 1);
 8223b6c:	01400044 	movi	r5,1
 8223b70:	e13ff517 	ldw	r4,-44(fp)
 8223b74:	82230680 	call	8223068 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 8223b78:	01400044 	movi	r5,1
 8223b7c:	e13ff517 	ldw	r4,-44(fp)
 8223b80:	822322c0 	call	822322c <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 8223b84:	01400044 	movi	r5,1
 8223b88:	e13ff517 	ldw	r4,-44(fp)
 8223b8c:	82234800 	call	8223480 <alt_tse_phy_set_adv_10>
 8223b90:	00002206 	br	8223c1c <alt_tse_phy_set_common_speed+0x2cc>
        }
        else if(common_speed == TSE_PHY_SPEED_100) {
 8223b94:	e0bffd17 	ldw	r2,-12(fp)
 8223b98:	10800058 	cmpnei	r2,r2,1
 8223b9c:	10000a1e 	bne	r2,zero,8223bc8 <alt_tse_phy_set_common_speed+0x278>
            alt_tse_phy_set_adv_1000(pphy, 0);
 8223ba0:	000b883a 	mov	r5,zero
 8223ba4:	e13ff517 	ldw	r4,-44(fp)
 8223ba8:	82230680 	call	8223068 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 8223bac:	01400044 	movi	r5,1
 8223bb0:	e13ff517 	ldw	r4,-44(fp)
 8223bb4:	822322c0 	call	822322c <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 8223bb8:	01400044 	movi	r5,1
 8223bbc:	e13ff517 	ldw	r4,-44(fp)
 8223bc0:	82234800 	call	8223480 <alt_tse_phy_set_adv_10>
 8223bc4:	00001506 	br	8223c1c <alt_tse_phy_set_common_speed+0x2cc>
        }    
        else if(common_speed == TSE_PHY_SPEED_10) {
 8223bc8:	e0bffd17 	ldw	r2,-12(fp)
 8223bcc:	10000a1e 	bne	r2,zero,8223bf8 <alt_tse_phy_set_common_speed+0x2a8>
            alt_tse_phy_set_adv_1000(pphy, 0);
 8223bd0:	000b883a 	mov	r5,zero
 8223bd4:	e13ff517 	ldw	r4,-44(fp)
 8223bd8:	82230680 	call	8223068 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 8223bdc:	000b883a 	mov	r5,zero
 8223be0:	e13ff517 	ldw	r4,-44(fp)
 8223be4:	822322c0 	call	822322c <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 8223be8:	01400044 	movi	r5,1
 8223bec:	e13ff517 	ldw	r4,-44(fp)
 8223bf0:	82234800 	call	8223480 <alt_tse_phy_set_adv_10>
 8223bf4:	00000906 	br	8223c1c <alt_tse_phy_set_common_speed+0x2cc>
        }
        else {
            alt_tse_phy_set_adv_1000(pphy, 0);
 8223bf8:	000b883a 	mov	r5,zero
 8223bfc:	e13ff517 	ldw	r4,-44(fp)
 8223c00:	82230680 	call	8223068 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 8223c04:	000b883a 	mov	r5,zero
 8223c08:	e13ff517 	ldw	r4,-44(fp)
 8223c0c:	822322c0 	call	822322c <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 0);
 8223c10:	000b883a 	mov	r5,zero
 8223c14:	e13ff517 	ldw	r4,-44(fp)
 8223c18:	82234800 	call	8223480 <alt_tse_phy_set_adv_10>
        }
        
        /* if PHY Auto-Negotiation is completed */
        if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 1) {
 8223c1c:	01c00044 	movi	r7,1
 8223c20:	01800144 	movi	r6,5
 8223c24:	01400044 	movi	r5,1
 8223c28:	e13ff517 	ldw	r4,-44(fp)
 8223c2c:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8223c30:	10800058 	cmpnei	r2,r2,1
 8223c34:	10003b1e 	bne	r2,zero,8223d24 <alt_tse_phy_set_common_speed+0x3d4>
            
            /* read both msb and lsb of speed bits if PHY support 1000 Mbps */
            if(gb_capable) {
 8223c38:	e0bffb03 	ldbu	r2,-20(fp)
 8223c3c:	10000f26 	beq	r2,zero,8223c7c <alt_tse_phy_set_common_speed+0x32c>
        
                /* get speed information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 8223c40:	e0bff517 	ldw	r2,-44(fp)
 8223c44:	10800517 	ldw	r2,20(r2)
 8223c48:	10801583 	ldbu	r2,86(r2)
 8223c4c:	10c03fcc 	andi	r3,r2,255
 8223c50:	e0bff517 	ldw	r2,-44(fp)
 8223c54:	10800517 	ldw	r2,20(r2)
 8223c58:	108015c3 	ldbu	r2,87(r2)
 8223c5c:	10803fcc 	andi	r2,r2,255
 8223c60:	01c00084 	movi	r7,2
 8223c64:	100d883a 	mov	r6,r2
 8223c68:	180b883a 	mov	r5,r3
 8223c6c:	e13ff517 	ldw	r4,-44(fp)
 8223c70:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8223c74:	e0bff405 	stb	r2,-48(fp)
 8223c78:	00000e06 	br	8223cb4 <alt_tse_phy_set_common_speed+0x364>
            }
            
            /* read lsb of speed only if PHY support only 10/100 Mbps */
            else {
                /* get speed and link information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 1);
 8223c7c:	e0bff517 	ldw	r2,-44(fp)
 8223c80:	10800517 	ldw	r2,20(r2)
 8223c84:	10801583 	ldbu	r2,86(r2)
 8223c88:	10c03fcc 	andi	r3,r2,255
 8223c8c:	e0bff517 	ldw	r2,-44(fp)
 8223c90:	10800517 	ldw	r2,20(r2)
 8223c94:	108015c3 	ldbu	r2,87(r2)
 8223c98:	10803fcc 	andi	r2,r2,255
 8223c9c:	01c00044 	movi	r7,1
 8223ca0:	100d883a 	mov	r6,r2
 8223ca4:	180b883a 	mov	r5,r3
 8223ca8:	e13ff517 	ldw	r4,-44(fp)
 8223cac:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8223cb0:	e0bff405 	stb	r2,-48(fp)
            }
            
            /* if current speed != common speed, then restart Auto-Negotiation */
            if(speed != common_speed) {
 8223cb4:	e0fff403 	ldbu	r3,-48(fp)
 8223cb8:	e0bffd17 	ldw	r2,-12(fp)
 8223cbc:	18800426 	beq	r3,r2,8223cd0 <alt_tse_phy_set_common_speed+0x380>
                alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 8223cc0:	01400134 	movhi	r5,4
 8223cc4:	29742404 	addi	r5,r5,-12144
 8223cc8:	e13ff517 	ldw	r4,-44(fp)
 8223ccc:	82227b40 	call	82227b4 <alt_tse_phy_restart_an>
            }
            
            /* get speed information after Auto-Negotiation */
            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 8223cd0:	e0bff517 	ldw	r2,-44(fp)
 8223cd4:	10800517 	ldw	r2,20(r2)
 8223cd8:	10801583 	ldbu	r2,86(r2)
 8223cdc:	10c03fcc 	andi	r3,r2,255
 8223ce0:	e0bff517 	ldw	r2,-44(fp)
 8223ce4:	10800517 	ldw	r2,20(r2)
 8223ce8:	10801603 	ldbu	r2,88(r2)
 8223cec:	10803fcc 	andi	r2,r2,255
 8223cf0:	01c00044 	movi	r7,1
 8223cf4:	100d883a 	mov	r6,r2
 8223cf8:	180b883a 	mov	r5,r3
 8223cfc:	e13ff517 	ldw	r4,-44(fp)
 8223d00:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8223d04:	e0bffb45 	stb	r2,-19(fp)
            
            /* Set MAC duplex register */
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
 8223d08:	e0bff717 	ldw	r2,-36(fp)
 8223d0c:	10800017 	ldw	r2,0(r2)
 8223d10:	1007883a 	mov	r3,r2
 8223d14:	e0bffb43 	ldbu	r2,-19(fp)
 8223d18:	100b883a 	mov	r5,r2
 8223d1c:	1809883a 	mov	r4,r3
 8223d20:	82206100 	call	8220610 <alt_tse_mac_set_duplex>
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
 8223d24:	e43ff847 	ldb	r16,-31(fp)
 8223d28:	e47ff807 	ldb	r17,-32(fp)
 8223d2c:	01c00404 	movi	r7,16
 8223d30:	000d883a 	mov	r6,zero
 8223d34:	01400044 	movi	r5,1
 8223d38:	e13ff517 	ldw	r4,-44(fp)
 8223d3c:	82212ec0 	call	82212ec <alt_tse_phy_rd_mdio_reg>
 8223d40:	100f883a 	mov	r7,r2
 8223d44:	880d883a 	mov	r6,r17
 8223d48:	800b883a 	mov	r5,r16
 8223d4c:	01020974 	movhi	r4,2085
 8223d50:	213e8804 	addi	r4,r4,-1504
 8223d54:	82033fc0 	call	82033fc <printf>
 8223d58:	00000106 	br	8223d60 <alt_tse_phy_set_common_speed+0x410>

        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
 8223d5c:	0001883a 	nop
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
        return TSE_PHY_SPEED_NO_COMMON;
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 8223d60:	e0bff317 	ldw	r2,-52(fp)
 8223d64:	10800044 	addi	r2,r2,1
 8223d68:	e0bff315 	stw	r2,-52(fp)
 8223d6c:	e0bffc17 	ldw	r2,-16(fp)
 8223d70:	10800003 	ldbu	r2,0(r2)
 8223d74:	10803fcc 	andi	r2,r2,255
 8223d78:	e0fff317 	ldw	r3,-52(fp)
 8223d7c:	18bf1f16 	blt	r3,r2,82239fc <alt_tse_phy_set_common_speed+0xac>
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
    }
    tse_dprintf(5, "INFO    : MAC Group[%d] - All PHYs set to common speed : %d Mbps\n", mac_group_index, (common_speed == TSE_PHY_SPEED_1000) ? 1000 : ((common_speed == TSE_PHY_SPEED_100) ? 100 : 10));
 8223d80:	e0fff847 	ldb	r3,-31(fp)
 8223d84:	e0bffd17 	ldw	r2,-12(fp)
 8223d88:	108000a0 	cmpeqi	r2,r2,2
 8223d8c:	1000071e 	bne	r2,zero,8223dac <alt_tse_phy_set_common_speed+0x45c>
 8223d90:	e0bffd17 	ldw	r2,-12(fp)
 8223d94:	10800058 	cmpnei	r2,r2,1
 8223d98:	1000021e 	bne	r2,zero,8223da4 <alt_tse_phy_set_common_speed+0x454>
 8223d9c:	00801904 	movi	r2,100
 8223da0:	00000306 	br	8223db0 <alt_tse_phy_set_common_speed+0x460>
 8223da4:	00800284 	movi	r2,10
 8223da8:	00000106 	br	8223db0 <alt_tse_phy_set_common_speed+0x460>
 8223dac:	0080fa04 	movi	r2,1000
 8223db0:	100d883a 	mov	r6,r2
 8223db4:	180b883a 	mov	r5,r3
 8223db8:	01020974 	movhi	r4,2085
 8223dbc:	213e9404 	addi	r4,r4,-1456
 8223dc0:	82033fc0 	call	82033fc <printf>

    /* Set MAC speed register */
    alt_tse_mac_set_speed(pmac_group_base, common_speed);
 8223dc4:	e0bffd17 	ldw	r2,-12(fp)
 8223dc8:	10803fcc 	andi	r2,r2,255
 8223dcc:	100b883a 	mov	r5,r2
 8223dd0:	e13ff917 	ldw	r4,-28(fp)
 8223dd4:	82205300 	call	8220530 <alt_tse_mac_set_speed>
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 8223dd8:	e0bff917 	ldw	r2,-28(fp)
 8223ddc:	10801004 	addi	r2,r2,64
 8223de0:	e0fffa17 	ldw	r3,-24(fp)
 8223de4:	10c00035 	stwio	r3,0(r2)
        
    return common_speed;
 8223de8:	e0bffd17 	ldw	r2,-12(fp)
}
 8223dec:	e6fffe04 	addi	sp,fp,-8
 8223df0:	dfc00317 	ldw	ra,12(sp)
 8223df4:	df000217 	ldw	fp,8(sp)
 8223df8:	dc400117 	ldw	r17,4(sp)
 8223dfc:	dc000017 	ldw	r16,0(sp)
 8223e00:	dec00404 	addi	sp,sp,16
 8223e04:	f800283a 	ret

08223e08 <marvell_phy_cfg>:

/* @Function Description: Additional configuration for Marvell PHY
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address of MAC group
 */
alt_32 marvell_phy_cfg(np_tse_mac *pmac) {
 8223e08:	defffc04 	addi	sp,sp,-16
 8223e0c:	dfc00315 	stw	ra,12(sp)
 8223e10:	df000215 	stw	fp,8(sp)
 8223e14:	df000204 	addi	fp,sp,8
 8223e18:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat;
    
    /* If there is no link yet, we enable auto crossover and reset the PHY */
    if((IORD(&pmac->mdio1.STATUS, 0) & PCS_ST_an_done) == 0) {
 8223e1c:	e0bfff17 	ldw	r2,-4(fp)
 8223e20:	1080a104 	addi	r2,r2,644
 8223e24:	10800037 	ldwio	r2,0(r2)
 8223e28:	1080080c 	andi	r2,r2,32
 8223e2c:	1000161e 	bne	r2,zero,8223e88 <marvell_phy_cfg+0x80>
        tse_dprintf(5, "MARVELL : Enabling auto crossover\n");
 8223e30:	01020974 	movhi	r4,2085
 8223e34:	213ea504 	addi	r4,r4,-1388
 8223e38:	82036800 	call	8203680 <puts>
        IOWR(&pmac->mdio1.CONTROL, 16, 0x0078);
 8223e3c:	e0bfff17 	ldw	r2,-4(fp)
 8223e40:	1080a004 	addi	r2,r2,640
 8223e44:	10801004 	addi	r2,r2,64
 8223e48:	00c01e04 	movi	r3,120
 8223e4c:	10c00035 	stwio	r3,0(r2)
        tse_dprintf(5, "MARVELL : PHY reset\n");
 8223e50:	01020974 	movhi	r4,2085
 8223e54:	213eae04 	addi	r4,r4,-1352
 8223e58:	82036800 	call	8203680 <puts>
        dat = IORD(&pmac->mdio1.CONTROL, 0); 
 8223e5c:	e0bfff17 	ldw	r2,-4(fp)
 8223e60:	1080a004 	addi	r2,r2,640
 8223e64:	10800037 	ldwio	r2,0(r2)
 8223e68:	e0bffe0d 	sth	r2,-8(fp)
        IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);        
 8223e6c:	e0bfff17 	ldw	r2,-4(fp)
 8223e70:	1080a004 	addi	r2,r2,640
 8223e74:	e13ffe0b 	ldhu	r4,-8(fp)
 8223e78:	00e00004 	movi	r3,-32768
 8223e7c:	20c6b03a 	or	r3,r4,r3
 8223e80:	18ffffcc 	andi	r3,r3,65535
 8223e84:	10c00035 	stwio	r3,0(r2)
    }
    
    return 0;
 8223e88:	0005883a 	mov	r2,zero
}
 8223e8c:	e037883a 	mov	sp,fp
 8223e90:	dfc00117 	ldw	ra,4(sp)
 8223e94:	df000017 	ldw	fp,0(sp)
 8223e98:	dec00204 	addi	sp,sp,8
 8223e9c:	f800283a 	ret

08223ea0 <marvell_cfg_gmii>:

/* @Function Description: Change operating mode of Marvell PHY to GMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_gmii(np_tse_mac *pmac) {
 8223ea0:	defffc04 	addi	sp,sp,-16
 8223ea4:	dfc00315 	stw	ra,12(sp)
 8223ea8:	df000215 	stw	fp,8(sp)
 8223eac:	df000204 	addi	fp,sp,8
 8223eb0:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 8223eb4:	e0bfff17 	ldw	r2,-4(fp)
 8223eb8:	1080bb04 	addi	r2,r2,748
 8223ebc:	10800037 	ldwio	r2,0(r2)
 8223ec0:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 8223ec4:	e0fffe0b 	ldhu	r3,-8(fp)
 8223ec8:	00bffc04 	movi	r2,-16
 8223ecc:	1884703a 	and	r2,r3,r2
 8223ed0:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to GMII to copper mode\n");
 8223ed4:	01020974 	movhi	r4,2085
 8223ed8:	213eb304 	addi	r4,r4,-1332
 8223edc:	82036800 	call	8203680 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xf);
 8223ee0:	e0bfff17 	ldw	r2,-4(fp)
 8223ee4:	1080bb04 	addi	r2,r2,748
 8223ee8:	e0fffe0b 	ldhu	r3,-8(fp)
 8223eec:	18c003d4 	ori	r3,r3,15
 8223ef0:	18ffffcc 	andi	r3,r3,65535
 8223ef4:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 8223ef8:	01020974 	movhi	r4,2085
 8223efc:	213ebf04 	addi	r4,r4,-1284
 8223f00:	82036800 	call	8203680 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 8223f04:	e0bfff17 	ldw	r2,-4(fp)
 8223f08:	1080b404 	addi	r2,r2,720
 8223f0c:	10800037 	ldwio	r2,0(r2)
 8223f10:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 8223f14:	e0fffe0b 	ldhu	r3,-8(fp)
 8223f18:	00bfdf44 	movi	r2,-131
 8223f1c:	1884703a 	and	r2,r3,r2
 8223f20:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 8223f24:	e0bfff17 	ldw	r2,-4(fp)
 8223f28:	1080b404 	addi	r2,r2,720
 8223f2c:	e0fffe0b 	ldhu	r3,-8(fp)
 8223f30:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 8223f34:	01020974 	movhi	r4,2085
 8223f38:	213eae04 	addi	r4,r4,-1352
 8223f3c:	82036800 	call	8203680 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 8223f40:	e0bfff17 	ldw	r2,-4(fp)
 8223f44:	1080a004 	addi	r2,r2,640
 8223f48:	10800037 	ldwio	r2,0(r2)
 8223f4c:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 8223f50:	e0bfff17 	ldw	r2,-4(fp)
 8223f54:	1080a004 	addi	r2,r2,640
 8223f58:	e13ffe0b 	ldhu	r4,-8(fp)
 8223f5c:	00e00004 	movi	r3,-32768
 8223f60:	20c6b03a 	or	r3,r4,r3
 8223f64:	18ffffcc 	andi	r3,r3,65535
 8223f68:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 8223f6c:	00800044 	movi	r2,1
}
 8223f70:	e037883a 	mov	sp,fp
 8223f74:	dfc00117 	ldw	ra,4(sp)
 8223f78:	df000017 	ldw	fp,0(sp)
 8223f7c:	dec00204 	addi	sp,sp,8
 8223f80:	f800283a 	ret

08223f84 <marvell_cfg_sgmii>:

/* @Function Description: Change operating mode of Marvell PHY to SGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_sgmii(np_tse_mac *pmac) {
 8223f84:	defffc04 	addi	sp,sp,-16
 8223f88:	dfc00315 	stw	ra,12(sp)
 8223f8c:	df000215 	stw	fp,8(sp)
 8223f90:	df000204 	addi	fp,sp,8
 8223f94:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 8223f98:	e0bfff17 	ldw	r2,-4(fp)
 8223f9c:	1080bb04 	addi	r2,r2,748
 8223fa0:	10800037 	ldwio	r2,0(r2)
 8223fa4:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 8223fa8:	e0fffe0b 	ldhu	r3,-8(fp)
 8223fac:	00bffc04 	movi	r2,-16
 8223fb0:	1884703a 	and	r2,r3,r2
 8223fb4:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to SGMII without clock with SGMII Auto-Neg to copper mode\n");
 8223fb8:	01020974 	movhi	r4,2085
 8223fbc:	213ec904 	addi	r4,r4,-1244
 8223fc0:	82036800 	call	8203680 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0x4);
 8223fc4:	e0bfff17 	ldw	r2,-4(fp)
 8223fc8:	1080bb04 	addi	r2,r2,748
 8223fcc:	e0fffe0b 	ldhu	r3,-8(fp)
 8223fd0:	18c00114 	ori	r3,r3,4
 8223fd4:	18ffffcc 	andi	r3,r3,65535
 8223fd8:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 8223fdc:	01020974 	movhi	r4,2085
 8223fe0:	213ebf04 	addi	r4,r4,-1284
 8223fe4:	82036800 	call	8203680 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 8223fe8:	e0bfff17 	ldw	r2,-4(fp)
 8223fec:	1080b404 	addi	r2,r2,720
 8223ff0:	10800037 	ldwio	r2,0(r2)
 8223ff4:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 8223ff8:	e0fffe0b 	ldhu	r3,-8(fp)
 8223ffc:	00bfdf44 	movi	r2,-131
 8224000:	1884703a 	and	r2,r3,r2
 8224004:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 8224008:	e0bfff17 	ldw	r2,-4(fp)
 822400c:	1080b404 	addi	r2,r2,720
 8224010:	e0fffe0b 	ldhu	r3,-8(fp)
 8224014:	10c00035 	stwio	r3,0(r2)

    tse_dprintf(5, "MARVELL : PHY reset\n");
 8224018:	01020974 	movhi	r4,2085
 822401c:	213eae04 	addi	r4,r4,-1352
 8224020:	82036800 	call	8203680 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 8224024:	e0bfff17 	ldw	r2,-4(fp)
 8224028:	1080a004 	addi	r2,r2,640
 822402c:	10800037 	ldwio	r2,0(r2)
 8224030:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 8224034:	e0bfff17 	ldw	r2,-4(fp)
 8224038:	1080a004 	addi	r2,r2,640
 822403c:	e13ffe0b 	ldhu	r4,-8(fp)
 8224040:	00e00004 	movi	r3,-32768
 8224044:	20c6b03a 	or	r3,r4,r3
 8224048:	18ffffcc 	andi	r3,r3,65535
 822404c:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 8224050:	00800044 	movi	r2,1
}
 8224054:	e037883a 	mov	sp,fp
 8224058:	dfc00117 	ldw	ra,4(sp)
 822405c:	df000017 	ldw	fp,0(sp)
 8224060:	dec00204 	addi	sp,sp,8
 8224064:	f800283a 	ret

08224068 <marvell_cfg_rgmii>:

/* @Function Description: Change operating mode of Marvell PHY to RGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_rgmii(np_tse_mac *pmac) {
 8224068:	defffc04 	addi	sp,sp,-16
 822406c:	dfc00315 	stw	ra,12(sp)
 8224070:	df000215 	stw	fp,8(sp)
 8224074:	df000204 	addi	fp,sp,8
 8224078:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 822407c:	e0bfff17 	ldw	r2,-4(fp)
 8224080:	1080bb04 	addi	r2,r2,748
 8224084:	10800037 	ldwio	r2,0(r2)
 8224088:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 822408c:	e0fffe0b 	ldhu	r3,-8(fp)
 8224090:	00bffc04 	movi	r2,-16
 8224094:	1884703a 	and	r2,r3,r2
 8224098:	e0bffe0d 	sth	r2,-8(fp)
    
    tse_dprintf(5, "MARVELL : Mode changed to RGMII/Modified MII to Copper mode\n");
 822409c:	01020974 	movhi	r4,2085
 82240a0:	213ede04 	addi	r4,r4,-1160
 82240a4:	82036800 	call	8203680 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xb);
 82240a8:	e0bfff17 	ldw	r2,-4(fp)
 82240ac:	1080bb04 	addi	r2,r2,748
 82240b0:	e0fffe0b 	ldhu	r3,-8(fp)
 82240b4:	18c002d4 	ori	r3,r3,11
 82240b8:	18ffffcc 	andi	r3,r3,65535
 82240bc:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Enable RGMII Timing Control\n");
 82240c0:	01020974 	movhi	r4,2085
 82240c4:	213eed04 	addi	r4,r4,-1100
 82240c8:	82036800 	call	8203680 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0);
 82240cc:	e0bfff17 	ldw	r2,-4(fp)
 82240d0:	1080b404 	addi	r2,r2,720
 82240d4:	10800037 	ldwio	r2,0(r2)
 82240d8:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 82240dc:	e0fffe0b 	ldhu	r3,-8(fp)
 82240e0:	00bfdf44 	movi	r2,-131
 82240e4:	1884703a 	and	r2,r3,r2
 82240e8:	e0bffe0d 	sth	r2,-8(fp)
    dat |= 0x82;
 82240ec:	e0bffe0b 	ldhu	r2,-8(fp)
 82240f0:	10802094 	ori	r2,r2,130
 82240f4:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);    
 82240f8:	e0bfff17 	ldw	r2,-4(fp)
 82240fc:	1080b404 	addi	r2,r2,720
 8224100:	e0fffe0b 	ldhu	r3,-8(fp)
 8224104:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 8224108:	01020974 	movhi	r4,2085
 822410c:	213eae04 	addi	r4,r4,-1352
 8224110:	82036800 	call	8203680 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 8224114:	e0bfff17 	ldw	r2,-4(fp)
 8224118:	1080a004 	addi	r2,r2,640
 822411c:	10800037 	ldwio	r2,0(r2)
 8224120:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 8224124:	e0bfff17 	ldw	r2,-4(fp)
 8224128:	1080a004 	addi	r2,r2,640
 822412c:	e13ffe0b 	ldhu	r4,-8(fp)
 8224130:	00e00004 	movi	r3,-32768
 8224134:	20c6b03a 	or	r3,r4,r3
 8224138:	18ffffcc 	andi	r3,r3,65535
 822413c:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 8224140:	00800044 	movi	r2,1
    
}
 8224144:	e037883a 	mov	sp,fp
 8224148:	dfc00117 	ldw	ra,4(sp)
 822414c:	df000017 	ldw	fp,0(sp)
 8224150:	dec00204 	addi	sp,sp,8
 8224154:	f800283a 	ret

08224158 <DP83848C_link_status_read>:

/* @Function Description: Read link status from PHY specific status register of DP83848C
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_u32 DP83848C_link_status_read(np_tse_mac *pmac) {
 8224158:	defffc04 	addi	sp,sp,-16
 822415c:	df000315 	stw	fp,12(sp)
 8224160:	df000304 	addi	fp,sp,12
 8224164:	e13fff15 	stw	r4,-4(fp)
	alt_u32 link_status = 0;
 8224168:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 reg_status = IORD(&pmac->mdio1.reg10, 0);
 822416c:	e0bfff17 	ldw	r2,-4(fp)
 8224170:	1080b004 	addi	r2,r2,704
 8224174:	10800037 	ldwio	r2,0(r2)
 8224178:	e0bffe15 	stw	r2,-8(fp)
	
	/* If speed == 10 Mbps */
	if(reg_status & 0x2) {
 822417c:	e0bffe17 	ldw	r2,-8(fp)
 8224180:	1080008c 	andi	r2,r2,2
 8224184:	10000426 	beq	r2,zero,8224198 <DP83848C_link_status_read+0x40>
		link_status |= 0x8;
 8224188:	e0bffd17 	ldw	r2,-12(fp)
 822418c:	10800214 	ori	r2,r2,8
 8224190:	e0bffd15 	stw	r2,-12(fp)
 8224194:	00000306 	br	82241a4 <DP83848C_link_status_read+0x4c>
	}
	/* Else speed = 100 Mbps */
	else {
		link_status |= 0x4;
 8224198:	e0bffd17 	ldw	r2,-12(fp)
 822419c:	10800114 	ori	r2,r2,4
 82241a0:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* If duplex == Full */
	if(reg_status & 0x4) {
 82241a4:	e0bffe17 	ldw	r2,-8(fp)
 82241a8:	1080010c 	andi	r2,r2,4
 82241ac:	10000326 	beq	r2,zero,82241bc <DP83848C_link_status_read+0x64>
		link_status |= 0x1;
 82241b0:	e0bffd17 	ldw	r2,-12(fp)
 82241b4:	10800054 	ori	r2,r2,1
 82241b8:	e0bffd15 	stw	r2,-12(fp)
	}
	
	return link_status;
 82241bc:	e0bffd17 	ldw	r2,-12(fp)
}
 82241c0:	e037883a 	mov	sp,fp
 82241c4:	df000017 	ldw	fp,0(sp)
 82241c8:	dec00104 	addi	sp,sp,4
 82241cc:	f800283a 	ret

082241d0 <altera_eth_tse_init>:
 * @Return ENP_HARDWARE on error, otherwise return SUCCESS
 */

error_t altera_eth_tse_init(
    alt_iniche_dev              *p_dev)
{
 82241d0:	defffa04 	addi	sp,sp,-24
 82241d4:	dfc00515 	stw	ra,20(sp)
 82241d8:	df000415 	stw	fp,16(sp)
 82241dc:	df000404 	addi	fp,sp,16
 82241e0:	e13fff15 	stw	r4,-4(fp)
    int i;
    
    alt_tse_iniche_dev_driver_data *p_driver_data = 0;
 82241e4:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_system_info *psys_info = 0;
 82241e8:	e03ffe15 	stw	zero,-8(fp)
    #ifdef PRINTIF
        dprintf("altera_eth_tse_init %d\n", p_dev->if_num);
    #endif

    /* Get the pointer to the alt_tse_iniche_dev_driver_data structure from the global array */
    for(i = 0; i < number_of_tse_mac; i++) {
 82241ec:	e03ffc15 	stw	zero,-16(fp)
 82241f0:	00001106 	br	8224238 <altera_eth_tse_init+0x68>
        if(tse_iniche_dev_driver_data[i].p_dev == p_dev) {
 82241f4:	008209b4 	movhi	r2,2086
 82241f8:	10b72004 	addi	r2,r2,-9088
 82241fc:	e0fffc17 	ldw	r3,-16(fp)
 8224200:	18c00324 	muli	r3,r3,12
 8224204:	10c5883a 	add	r2,r2,r3
 8224208:	10c00017 	ldw	r3,0(r2)
 822420c:	e0bfff17 	ldw	r2,-4(fp)
 8224210:	1880061e 	bne	r3,r2,822422c <altera_eth_tse_init+0x5c>
            p_driver_data = &tse_iniche_dev_driver_data[i];
 8224214:	e0bffc17 	ldw	r2,-16(fp)
 8224218:	10c00324 	muli	r3,r2,12
 822421c:	008209b4 	movhi	r2,2086
 8224220:	10b72004 	addi	r2,r2,-9088
 8224224:	1885883a 	add	r2,r3,r2
 8224228:	e0bffd15 	stw	r2,-12(fp)
    #ifdef PRINTIF
        dprintf("altera_eth_tse_init %d\n", p_dev->if_num);
    #endif

    /* Get the pointer to the alt_tse_iniche_dev_driver_data structure from the global array */
    for(i = 0; i < number_of_tse_mac; i++) {
 822422c:	e0bffc17 	ldw	r2,-16(fp)
 8224230:	10800044 	addi	r2,r2,1
 8224234:	e0bffc15 	stw	r2,-16(fp)
 8224238:	d0a08003 	ldbu	r2,-32256(gp)
 822423c:	10803fcc 	andi	r2,r2,255
 8224240:	e0fffc17 	ldw	r3,-16(fp)
 8224244:	18bfeb16 	blt	r3,r2,82241f4 <altera_eth_tse_init+0x24>
        if(tse_iniche_dev_driver_data[i].p_dev == p_dev) {
            p_driver_data = &tse_iniche_dev_driver_data[i];
        }
    }
    /* If pointer could not found */
    if(p_driver_data == 0) {
 8224248:	e0bffd17 	ldw	r2,-12(fp)
 822424c:	1000021e 	bne	r2,zero,8224258 <altera_eth_tse_init+0x88>
        return ENP_HARDWARE;
 8224250:	00bff744 	movi	r2,-35
 8224254:	00002706 	br	82242f4 <altera_eth_tse_init+0x124>
    }
    
    /* Get the pointer to the alt_tse_system_info structure from the global array */
    for(i = 0; i < max_mac_system; i++) {
 8224258:	e03ffc15 	stw	zero,-16(fp)
 822425c:	00001206 	br	82242a8 <altera_eth_tse_init+0xd8>
        if(tse_mac_device[i].tse_mac_base == p_driver_data->hw_mac_base_addr) {
 8224260:	00820974 	movhi	r2,2085
 8224264:	1087da04 	addi	r2,r2,8040
 8224268:	e0fffc17 	ldw	r3,-16(fp)
 822426c:	18c01224 	muli	r3,r3,72
 8224270:	10c5883a 	add	r2,r2,r3
 8224274:	10c00017 	ldw	r3,0(r2)
 8224278:	e0bffd17 	ldw	r2,-12(fp)
 822427c:	10800117 	ldw	r2,4(r2)
 8224280:	1880061e 	bne	r3,r2,822429c <altera_eth_tse_init+0xcc>
            psys_info = &tse_mac_device[i];
 8224284:	e0bffc17 	ldw	r2,-16(fp)
 8224288:	10c01224 	muli	r3,r2,72
 822428c:	00820974 	movhi	r2,2085
 8224290:	1087da04 	addi	r2,r2,8040
 8224294:	1885883a 	add	r2,r3,r2
 8224298:	e0bffe15 	stw	r2,-8(fp)
    if(p_driver_data == 0) {
        return ENP_HARDWARE;
    }
    
    /* Get the pointer to the alt_tse_system_info structure from the global array */
    for(i = 0; i < max_mac_system; i++) {
 822429c:	e0bffc17 	ldw	r2,-16(fp)
 82242a0:	10800044 	addi	r2,r2,1
 82242a4:	e0bffc15 	stw	r2,-16(fp)
 82242a8:	d0a02d03 	ldbu	r2,-32588(gp)
 82242ac:	10803fcc 	andi	r2,r2,255
 82242b0:	e0fffc17 	ldw	r3,-16(fp)
 82242b4:	18bfea16 	blt	r3,r2,8224260 <altera_eth_tse_init+0x90>
        if(tse_mac_device[i].tse_mac_base == p_driver_data->hw_mac_base_addr) {
            psys_info = &tse_mac_device[i];
        }
    }
    /* If pointer could not found */
    if(psys_info == 0) {
 82242b8:	e0bffe17 	ldw	r2,-8(fp)
 82242bc:	1000021e 	bne	r2,zero,82242c8 <altera_eth_tse_init+0xf8>
        return ENP_HARDWARE;
 82242c0:	00bff744 	movi	r2,-35
 82242c4:	00000b06 	br	82242f4 <altera_eth_tse_init+0x124>
    }
    
    prep_tse_mac(p_dev->if_num, psys_info + p_driver_data->hw_channel_number);
 82242c8:	e0bfff17 	ldw	r2,-4(fp)
 82242cc:	11000517 	ldw	r4,20(r2)
 82242d0:	e0bffd17 	ldw	r2,-12(fp)
 82242d4:	10800203 	ldbu	r2,8(r2)
 82242d8:	10803fcc 	andi	r2,r2,255
 82242dc:	10801224 	muli	r2,r2,72
 82242e0:	e0fffe17 	ldw	r3,-8(fp)
 82242e4:	1885883a 	add	r2,r3,r2
 82242e8:	100b883a 	mov	r5,r2
 82242ec:	82243080 	call	8224308 <prep_tse_mac>
    
    return SUCCESS;
 82242f0:	0005883a 	mov	r2,zero
}
 82242f4:	e037883a 	mov	sp,fp
 82242f8:	dfc00117 	ldw	ra,4(sp)
 82242fc:	df000017 	ldw	fp,0(sp)
 8224300:	dec00204 	addi	sp,sp,8
 8224304:	f800283a 	ret

08224308 <prep_tse_mac>:
 * @Param index     index of the NET structure associated with TSE instance
 * @Param psys_info pointer to the TSE hardware info structure
 * @Return next index of NET
 */
int prep_tse_mac(int index, alt_tse_system_info *psys_info)
{
 8224308:	defffb04 	addi	sp,sp,-20
 822430c:	dfc00415 	stw	ra,16(sp)
 8224310:	df000315 	stw	fp,12(sp)
 8224314:	df000304 	addi	fp,sp,12
 8224318:	e13ffe15 	stw	r4,-8(fp)
 822431c:	e17fff15 	stw	r5,-4(fp)
    NET ifp;
    dprintf("prep_tse_mac %d\n", index);
 8224320:	e17ffe17 	ldw	r5,-8(fp)
 8224324:	01020974 	movhi	r4,2085
 8224328:	213ef704 	addi	r4,r4,-1060
 822432c:	82033fc0 	call	82033fc <printf>
    {
        tse[index].sem = 0; /*Tx IDLE*/
 8224330:	008209b4 	movhi	r2,2086
 8224334:	10b72c04 	addi	r2,r2,-9040
 8224338:	e0fffe17 	ldw	r3,-8(fp)
 822433c:	18c01324 	muli	r3,r3,76
 8224340:	10c5883a 	add	r2,r2,r3
 8224344:	10800c04 	addi	r2,r2,48
 8224348:	10000015 	stw	zero,0(r2)
        tse[index].tse = (void *)psys_info;
 822434c:	008209b4 	movhi	r2,2086
 8224350:	10b72c04 	addi	r2,r2,-9040
 8224354:	e0fffe17 	ldw	r3,-8(fp)
 8224358:	18c01324 	muli	r3,r3,76
 822435c:	10c5883a 	add	r2,r2,r3
 8224360:	10801204 	addi	r2,r2,72
 8224364:	e0ffff17 	ldw	r3,-4(fp)
 8224368:	10c00015 	stw	r3,0(r2)

        ifp = nets[index];
 822436c:	008209b4 	movhi	r2,2086
 8224370:	10b83d04 	addi	r2,r2,-7948
 8224374:	e0fffe17 	ldw	r3,-8(fp)
 8224378:	18c7883a 	add	r3,r3,r3
 822437c:	18c7883a 	add	r3,r3,r3
 8224380:	10c5883a 	add	r2,r2,r3
 8224384:	10800017 	ldw	r2,0(r2)
 8224388:	e0bffd15 	stw	r2,-12(fp)
        ifp->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_DOWN; /* status = down */
 822438c:	e0bffd17 	ldw	r2,-12(fp)
 8224390:	10802717 	ldw	r2,156(r2)
 8224394:	00c00084 	movi	r3,2
 8224398:	10c00615 	stw	r3,24(r2)
        ifp->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_DOWN;   
 822439c:	e0bffd17 	ldw	r2,-12(fp)
 82243a0:	10802717 	ldw	r2,156(r2)
 82243a4:	00c00084 	movi	r3,2
 82243a8:	10c00715 	stw	r3,28(r2)
        ifp->n_mib->ifLastChange =  cticks * (100/TPS);
 82243ac:	e0bffd17 	ldw	r2,-12(fp)
 82243b0:	10802717 	ldw	r2,156(r2)
 82243b4:	d0e0a817 	ldw	r3,-32096(gp)
 82243b8:	10c00815 	stw	r3,32(r2)
        ifp->n_mib->ifPhysAddress = (u_char*)tse[index].mac_addr;
 82243bc:	e0bffd17 	ldw	r2,-12(fp)
 82243c0:	10c02717 	ldw	r3,156(r2)
 82243c4:	e0bffe17 	ldw	r2,-8(fp)
 82243c8:	10801324 	muli	r2,r2,76
 82243cc:	11000604 	addi	r4,r2,24
 82243d0:	008209b4 	movhi	r2,2086
 82243d4:	10b72c04 	addi	r2,r2,-9040
 82243d8:	2085883a 	add	r2,r4,r2
 82243dc:	18800515 	stw	r2,20(r3)
        ifp->n_mib->ifDescr =       "Altera TSE MAC ethernet";
 82243e0:	e0bffd17 	ldw	r2,-12(fp)
 82243e4:	10c02717 	ldw	r3,156(r2)
 82243e8:	00820974 	movhi	r2,2085
 82243ec:	10befc04 	addi	r2,r2,-1040
 82243f0:	18800115 	stw	r2,4(r3)
        ifp->n_lnh =                ETHHDR_SIZE; /* ethernet header size. was:14 */
 82243f4:	e0bffd17 	ldw	r2,-12(fp)
 82243f8:	00c00404 	movi	r3,16
 82243fc:	10c00815 	stw	r3,32(r2)
        ifp->n_hal =                ALTERA_TSE_HAL_ADDR_LEN;  /* hardware address length */
 8224400:	e0bffd17 	ldw	r2,-12(fp)
 8224404:	00c00184 	movi	r3,6
 8224408:	10c01115 	stw	r3,68(r2)
        ifp->n_mib->ifType =        ETHERNET;   /* device type */
 822440c:	e0bffd17 	ldw	r2,-12(fp)
 8224410:	10802717 	ldw	r2,156(r2)
 8224414:	00c00184 	movi	r3,6
 8224418:	10c00215 	stw	r3,8(r2)
        ifp->n_mtu =                ALTERA_TSE_MAX_MTU_SIZE;  /* max frame size */
 822441c:	e0bffd17 	ldw	r2,-12(fp)
 8224420:	00c17a84 	movi	r3,1514
 8224424:	10c00915 	stw	r3,36(r2)
    
        /* install our hardware driver routines */
        ifp->n_init =       tse_mac_init;
 8224428:	e0fffd17 	ldw	r3,-12(fp)
 822442c:	008208b4 	movhi	r2,2082
 8224430:	10915804 	addi	r2,r2,17760
 8224434:	18800215 	stw	r2,8(r3)
        ifp->pkt_send =     NULL;
 8224438:	e0bffd17 	ldw	r2,-12(fp)
 822443c:	10000415 	stw	zero,16(r2)
        ifp->raw_send =     tse_mac_raw_send;
 8224440:	e0fffd17 	ldw	r3,-12(fp)
 8224444:	008208b4 	movhi	r2,2082
 8224448:	1093f004 	addi	r2,r2,20416
 822444c:	18800315 	stw	r2,12(r3)
        ifp->n_close =      tse_mac_close;
 8224450:	e0fffd17 	ldw	r3,-12(fp)
 8224454:	008208b4 	movhi	r2,2082
 8224458:	1095e404 	addi	r2,r2,22416
 822445c:	18800515 	stw	r2,20(r3)
        ifp->n_stats =      (void(*)(void *, int))tse_mac_stats; 
 8224460:	e0fffd17 	ldw	r3,-12(fp)
 8224464:	008208b4 	movhi	r2,2082
 8224468:	1095d404 	addi	r2,r2,22352
 822446c:	18800715 	stw	r2,28(r3)
    
    #ifdef IP_V6
        ifp->n_flags |= (NF_NBPROT | NF_IPV6);
    #else
        ifp->n_flags |= NF_NBPROT;
 8224470:	e0bffd17 	ldw	r2,-12(fp)
 8224474:	10802a17 	ldw	r2,168(r2)
 8224478:	10c00214 	ori	r3,r2,8
 822447c:	e0bffd17 	ldw	r2,-12(fp)
 8224480:	10c02a15 	stw	r3,168(r2)
    #endif
    
        nets[index]->n_mib->ifPhysAddress = (u_char*)tse[index].mac_addr;   /* ptr to MAC address */
 8224484:	008209b4 	movhi	r2,2086
 8224488:	10b83d04 	addi	r2,r2,-7948
 822448c:	e0fffe17 	ldw	r3,-8(fp)
 8224490:	18c7883a 	add	r3,r3,r3
 8224494:	18c7883a 	add	r3,r3,r3
 8224498:	10c5883a 	add	r2,r2,r3
 822449c:	10800017 	ldw	r2,0(r2)
 82244a0:	10c02717 	ldw	r3,156(r2)
 82244a4:	e0bffe17 	ldw	r2,-8(fp)
 82244a8:	10801324 	muli	r2,r2,76
 82244ac:	11000604 	addi	r4,r2,24
 82244b0:	008209b4 	movhi	r2,2086
 82244b4:	10b72c04 	addi	r2,r2,-9040
 82244b8:	2085883a 	add	r2,r4,r2
 82244bc:	18800515 	stw	r2,20(r3)
    
    #ifdef ALT_INICHE
        /* get the MAC address. */
        get_mac_addr(ifp, (unsigned char *)tse[index].mac_addr);
 82244c0:	e0bffe17 	ldw	r2,-8(fp)
 82244c4:	10801324 	muli	r2,r2,76
 82244c8:	10c00604 	addi	r3,r2,24
 82244cc:	008209b4 	movhi	r2,2086
 82244d0:	10b72c04 	addi	r2,r2,-9040
 82244d4:	1885883a 	add	r2,r3,r2
 82244d8:	100b883a 	mov	r5,r2
 82244dc:	e13ffd17 	ldw	r4,-12(fp)
 82244e0:	82010c40 	call	82010c4 <get_mac_addr>
    #endif /* ALT_INICHE */
    
        /* set cross-pointers between iface and tse structs */
        tse[index].index = index;
 82244e4:	008209b4 	movhi	r2,2086
 82244e8:	10b72c04 	addi	r2,r2,-9040
 82244ec:	e0fffe17 	ldw	r3,-8(fp)
 82244f0:	18c01324 	muli	r3,r3,76
 82244f4:	10c5883a 	add	r2,r2,r3
 82244f8:	e0fffe17 	ldw	r3,-8(fp)
 82244fc:	10c00015 	stw	r3,0(r2)
        tse[index].netp = ifp;
 8224500:	008209b4 	movhi	r2,2086
 8224504:	10b72c04 	addi	r2,r2,-9040
 8224508:	e0fffe17 	ldw	r3,-8(fp)
 822450c:	18c01324 	muli	r3,r3,76
 8224510:	10c5883a 	add	r2,r2,r3
 8224514:	10800804 	addi	r2,r2,32
 8224518:	e0fffd17 	ldw	r3,-12(fp)
 822451c:	10c00015 	stw	r3,0(r2)
        ifp->n_local = (void*)(&tse[index]);
 8224520:	e0bffe17 	ldw	r2,-8(fp)
 8224524:	10c01324 	muli	r3,r2,76
 8224528:	008209b4 	movhi	r2,2086
 822452c:	10b72c04 	addi	r2,r2,-9040
 8224530:	1887883a 	add	r3,r3,r2
 8224534:	e0bffd17 	ldw	r2,-12(fp)
 8224538:	10c02815 	stw	r3,160(r2)
    
        index++;
 822453c:	e0bffe17 	ldw	r2,-8(fp)
 8224540:	10800044 	addi	r2,r2,1
 8224544:	e0bffe15 	stw	r2,-8(fp)
   }
 
   return index;
 8224548:	e0bffe17 	ldw	r2,-8(fp)
}
 822454c:	e037883a 	mov	sp,fp
 8224550:	dfc00117 	ldw	ra,4(sp)
 8224554:	df000017 	ldw	fp,0(sp)
 8224558:	dec00204 	addi	sp,sp,8
 822455c:	f800283a 	ret

08224560 <tse_mac_init>:
 * @API TYPE: Internal
 * @Param iface index of the NET structure associated with TSE instance
 * @Return 0 if ok, else -1 if error
 */
int tse_mac_init(int iface)
{
 8224560:	defff004 	addi	sp,sp,-64
 8224564:	dfc00f15 	stw	ra,60(sp)
 8224568:	df000e15 	stw	fp,56(sp)
 822456c:	df000e04 	addi	fp,sp,56
 8224570:	e13fff15 	stw	r4,-4(fp)
   int dat;
   int speed, duplex, result, x;
   int status = SUCCESS;
 8224574:	e03ff815 	stw	zero,-32(fp)
   
   alt_sgdma_dev *sgdma_tx_dev;
   alt_sgdma_dev *sgdma_rx_dev;
   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse[iface].tse;
 8224578:	008209b4 	movhi	r2,2086
 822457c:	10b72c04 	addi	r2,r2,-9040
 8224580:	e0ffff17 	ldw	r3,-4(fp)
 8224584:	18c01324 	muli	r3,r3,76
 8224588:	10c5883a 	add	r2,r2,r3
 822458c:	10801204 	addi	r2,r2,72
 8224590:	10800017 	ldw	r2,0(r2)
 8224594:	e0bff915 	stw	r2,-28(fp)
   
   dprintf("[tse_mac_init]\n");
 8224598:	01020974 	movhi	r4,2085
 822459c:	213f0204 	addi	r4,r4,-1016
 82245a0:	82036800 	call	8203680 <puts>
#ifdef PRINTIF
    dprintf("tse_mac_init %d\n", iface);
#endif    

    if (tse_hw->ext_desc_mem == 1) {
 82245a4:	e0bff917 	ldw	r2,-28(fp)
 82245a8:	10800783 	ldbu	r2,30(r2)
 82245ac:	10803fcc 	andi	r2,r2,255
 82245b0:	10800058 	cmpnei	r2,r2,1
 82245b4:	10000b1e 	bne	r2,zero,82245e4 <tse_mac_init+0x84>
        tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
 82245b8:	e0bff917 	ldw	r2,-28(fp)
 82245bc:	10800817 	ldw	r2,32(r2)
 82245c0:	1009883a 	mov	r4,r2
 82245c4:	008209b4 	movhi	r2,2086
 82245c8:	10b72c04 	addi	r2,r2,-9040
 82245cc:	e0ffff17 	ldw	r3,-4(fp)
 82245d0:	18c01324 	muli	r3,r3,76
 82245d4:	10c5883a 	add	r2,r2,r3
 82245d8:	10800f04 	addi	r2,r2,60
 82245dc:	11000015 	stw	r4,0(r2)
 82245e0:	00001206 	br	822462c <tse_mac_init+0xcc>
    }
    else {
        unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
 82245e4:	01002804 	movi	r4,160
 82245e8:	823ca280 	call	823ca28 <alt_uncached_malloc>
 82245ec:	e0bff515 	stw	r2,-44(fp)
    
        while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 82245f0:	00000306 	br	8224600 <tse_mac_init+0xa0>
        {
            temp_desc++;
 82245f4:	e0bff517 	ldw	r2,-44(fp)
 82245f8:	10800044 	addi	r2,r2,1
 82245fc:	e0bff515 	stw	r2,-44(fp)
        tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
    }
    else {
        unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
    
        while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 8224600:	e0bff517 	ldw	r2,-44(fp)
 8224604:	108007cc 	andi	r2,r2,31
 8224608:	103ffa1e 	bne	r2,zero,82245f4 <tse_mac_init+0x94>
        {
            temp_desc++;
        }
        tse[iface].desc = (alt_sgdma_descriptor *) temp_desc;
 822460c:	008209b4 	movhi	r2,2086
 8224610:	10b72c04 	addi	r2,r2,-9040
 8224614:	e0ffff17 	ldw	r3,-4(fp)
 8224618:	18c01324 	muli	r3,r3,76
 822461c:	10c5883a 	add	r2,r2,r3
 8224620:	10800f04 	addi	r2,r2,60
 8224624:	e0fff517 	ldw	r3,-44(fp)
 8224628:	10c00015 	stw	r3,0(r2)
    }

   
   /* Get the Rx and Tx SGDMA addresses */
   sgdma_tx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_tx);
 822462c:	e0bff917 	ldw	r2,-28(fp)
 8224630:	10800517 	ldw	r2,20(r2)
 8224634:	1009883a 	mov	r4,r2
 8224638:	821ea100 	call	821ea10 <alt_avalon_sgdma_open>
 822463c:	e0bffa15 	stw	r2,-24(fp)
   
   if(!sgdma_tx_dev) {
 8224640:	e0bffa17 	ldw	r2,-24(fp)
 8224644:	1000051e 	bne	r2,zero,822465c <tse_mac_init+0xfc>
      dprintf("[altera_eth_tse_init] Error opening TX SGDMA\n");
 8224648:	01020974 	movhi	r4,2085
 822464c:	213f0604 	addi	r4,r4,-1000
 8224650:	82036800 	call	8203680 <puts>
      return ENP_RESOURCE;
 8224654:	00bffa84 	movi	r2,-22
 8224658:	00025406 	br	8224fac <tse_mac_init+0xa4c>
   }
  
   sgdma_rx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_rx);
 822465c:	e0bff917 	ldw	r2,-28(fp)
 8224660:	10800617 	ldw	r2,24(r2)
 8224664:	1009883a 	mov	r4,r2
 8224668:	821ea100 	call	821ea10 <alt_avalon_sgdma_open>
 822466c:	e0bffb15 	stw	r2,-20(fp)
   if(!sgdma_rx_dev) {
 8224670:	e0bffb17 	ldw	r2,-20(fp)
 8224674:	1000051e 	bne	r2,zero,822468c <tse_mac_init+0x12c>
      dprintf("[altera_eth_tse_init] Error opening RX SGDMA\n");
 8224678:	01020974 	movhi	r4,2085
 822467c:	213f1204 	addi	r4,r4,-952
 8224680:	82036800 	call	8203680 <puts>
      return ENP_RESOURCE;
 8224684:	00bffa84 	movi	r2,-22
 8224688:	00024806 	br	8224fac <tse_mac_init+0xa4c>
   }

   /* Initialize mtip_mac_trans_info structure with values from <system.h>*/
   tse_mac_initTransInfo2(&tse[iface].mi, (int)tse_hw->tse_mac_base,
 822468c:	e0bfff17 	ldw	r2,-4(fp)
 8224690:	10801324 	muli	r2,r2,76
 8224694:	10c00104 	addi	r3,r2,4
 8224698:	008209b4 	movhi	r2,2086
 822469c:	10b72c04 	addi	r2,r2,-9040
 82246a0:	1887883a 	add	r3,r3,r2
 82246a4:	e0bff917 	ldw	r2,-28(fp)
 82246a8:	10800017 	ldw	r2,0(r2)
 82246ac:	e13ffa17 	ldw	r4,-24(fp)
 82246b0:	e17ffb17 	ldw	r5,-20(fp)
 82246b4:	d8000015 	stw	zero,0(sp)
 82246b8:	280f883a 	mov	r7,r5
 82246bc:	200d883a 	mov	r6,r4
 82246c0:	100b883a 	mov	r5,r2
 82246c4:	1809883a 	mov	r4,r3
 82246c8:	821f2100 	call	821f210 <tse_mac_initTransInfo2>
                                   (unsigned int)sgdma_tx_dev,            
                                   (unsigned int)sgdma_rx_dev,
                                   0);

   /* Reset RX-side SGDMA */
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base,
 82246cc:	008209b4 	movhi	r2,2086
 82246d0:	10b72c04 	addi	r2,r2,-9040
 82246d4:	e0ffff17 	ldw	r3,-4(fp)
 82246d8:	18c01324 	muli	r3,r3,76
 82246dc:	10c5883a 	add	r2,r2,r3
 82246e0:	10800304 	addi	r2,r2,12
 82246e4:	10800017 	ldw	r2,0(r2)
 82246e8:	10800317 	ldw	r2,12(r2)
 82246ec:	10800404 	addi	r2,r2,16
 82246f0:	00c00074 	movhi	r3,1
 82246f4:	10c00035 	stwio	r3,0(r2)
     ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, 0x0);
 82246f8:	008209b4 	movhi	r2,2086
 82246fc:	10b72c04 	addi	r2,r2,-9040
 8224700:	e0ffff17 	ldw	r3,-4(fp)
 8224704:	18c01324 	muli	r3,r3,76
 8224708:	10c5883a 	add	r2,r2,r3
 822470c:	10800304 	addi	r2,r2,12
 8224710:	10800017 	ldw	r2,0(r2)
 8224714:	10800317 	ldw	r2,12(r2)
 8224718:	10800404 	addi	r2,r2,16
 822471c:	0007883a 	mov	r3,zero
 8224720:	10c00035 	stwio	r3,0(r2)
   
   tse[iface].interruptNR = tse_hw->tse_sgdma_rx_irq;
 8224724:	e0bff917 	ldw	r2,-28(fp)
 8224728:	1080070b 	ldhu	r2,28(r2)
 822472c:	10ffffcc 	andi	r3,r2,65535
 8224730:	008209b4 	movhi	r2,2086
 8224734:	10b72c04 	addi	r2,r2,-9040
 8224738:	e13fff17 	ldw	r4,-4(fp)
 822473c:	21001324 	muli	r4,r4,76
 8224740:	1105883a 	add	r2,r2,r4
 8224744:	10800904 	addi	r2,r2,36
 8224748:	10c00015 	stw	r3,0(r2)

   /* reset the PHY if necessary */   
   result = getPHYSpeed(tse[iface].mi.base);
 822474c:	008209b4 	movhi	r2,2086
 8224750:	10b72c04 	addi	r2,r2,-9040
 8224754:	e0ffff17 	ldw	r3,-4(fp)
 8224758:	18c01324 	muli	r3,r3,76
 822475c:	10c5883a 	add	r2,r2,r3
 8224760:	10800104 	addi	r2,r2,4
 8224764:	10800017 	ldw	r2,0(r2)
 8224768:	1009883a 	mov	r4,r2
 822476c:	822069c0 	call	822069c <getPHYSpeed>
 8224770:	e0bffc15 	stw	r2,-16(fp)
   speed = (result >> 1) & 0x07;
 8224774:	e0bffc17 	ldw	r2,-16(fp)
 8224778:	1005d07a 	srai	r2,r2,1
 822477c:	108001cc 	andi	r2,r2,7
 8224780:	e0bffd15 	stw	r2,-12(fp)
   duplex = result & 0x01;
 8224784:	e0bffc17 	ldw	r2,-16(fp)
 8224788:	1080004c 	andi	r2,r2,1
 822478c:	e0bffe15 	stw	r2,-8(fp)
    
   /* reset the mac */ 
   IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,
 8224790:	008209b4 	movhi	r2,2086
 8224794:	10b72c04 	addi	r2,r2,-9040
 8224798:	e0ffff17 	ldw	r3,-4(fp)
 822479c:	18c01324 	muli	r3,r3,76
 82247a0:	10c5883a 	add	r2,r2,r3
 82247a4:	10800104 	addi	r2,r2,4
 82247a8:	10800017 	ldw	r2,0(r2)
 82247ac:	10800204 	addi	r2,r2,8
 82247b0:	00c800c4 	movi	r3,8195
 82247b4:	10c00035 	stwio	r3,0(r2)
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
 82247b8:	e03ff415 	stw	zero,-48(fp)
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
 82247bc:	00000506 	br	82247d4 <tse_mac_init+0x274>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) {
     if( x++ > 10000 ) {
 82247c0:	e0bff417 	ldw	r2,-48(fp)
 82247c4:	10c00044 	addi	r3,r2,1
 82247c8:	e0fff415 	stw	r3,-48(fp)
 82247cc:	1089c450 	cmplti	r2,r2,10001
 82247d0:	10000c26 	beq	r2,zero,8224804 <tse_mac_init+0x2a4>
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
 82247d4:	008209b4 	movhi	r2,2086
 82247d8:	10b72c04 	addi	r2,r2,-9040
 82247dc:	e0ffff17 	ldw	r3,-4(fp)
 82247e0:	18c01324 	muli	r3,r3,76
 82247e4:	10c5883a 	add	r2,r2,r3
 82247e8:	10800104 	addi	r2,r2,4
 82247ec:	10800017 	ldw	r2,0(r2)
 82247f0:	10800204 	addi	r2,r2,8
 82247f4:	10800037 	ldwio	r2,0(r2)
 82247f8:	1088000c 	andi	r2,r2,8192
 82247fc:	103ff01e 	bne	r2,zero,82247c0 <tse_mac_init+0x260>
 8224800:	00000106 	br	8224808 <tse_mac_init+0x2a8>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) {
     if( x++ > 10000 ) {
       break;
 8224804:	0001883a 	nop
     }
   }
   if(x >= 10000) {
 8224808:	e0bff417 	ldw	r2,-48(fp)
 822480c:	1089c410 	cmplti	r2,r2,10000
 8224810:	1000031e 	bne	r2,zero,8224820 <tse_mac_init+0x2c0>
     dprintf("TSEMAC SW reset bit never cleared!\n");
 8224814:	01020974 	movhi	r4,2085
 8224818:	213f1e04 	addi	r4,r4,-904
 822481c:	82036800 	call	8203680 <puts>
   }

   dat = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
 8224820:	008209b4 	movhi	r2,2086
 8224824:	10b72c04 	addi	r2,r2,-9040
 8224828:	e0ffff17 	ldw	r3,-4(fp)
 822482c:	18c01324 	muli	r3,r3,76
 8224830:	10c5883a 	add	r2,r2,r3
 8224834:	10800104 	addi	r2,r2,4
 8224838:	10800017 	ldw	r2,0(r2)
 822483c:	10800204 	addi	r2,r2,8
 8224840:	10800037 	ldwio	r2,0(r2)
 8224844:	e0bff315 	stw	r2,-52(fp)
   if( (dat & 0x03) != 0 ) {
 8224848:	e0bff317 	ldw	r2,-52(fp)
 822484c:	108000cc 	andi	r2,r2,3
 8224850:	10000526 	beq	r2,zero,8224868 <tse_mac_init+0x308>
     dprintf("WARN: RX/TX not disabled after reset... missing PHY clock? CMD_CONFIG=0x%08x\n", dat);
 8224854:	e17ff317 	ldw	r5,-52(fp)
 8224858:	01020974 	movhi	r4,2085
 822485c:	213f2704 	addi	r4,r4,-868
 8224860:	82033fc0 	call	82033fc <printf>
 8224864:	00000506 	br	822487c <tse_mac_init+0x31c>
   } 
   else {
     dprintf("OK, x=%d, CMD_CONFIG=0x%08x\n", x, dat);
 8224868:	e1bff317 	ldw	r6,-52(fp)
 822486c:	e17ff417 	ldw	r5,-48(fp)
 8224870:	01020974 	movhi	r4,2085
 8224874:	213f3b04 	addi	r4,r4,-788
 8224878:	82033fc0 	call	82033fc <printf>
  
    /* Hack code to determine the Channel number <- Someone please fix this ugly code in the future */
    extern alt_u8 mac_group_count;
    extern alt_tse_mac_group *pmac_groups[TSE_MAX_MAC_IN_SYSTEM];
      
    if(tse_hw->use_shared_fifo == 1) {
 822487c:	e0bff917 	ldw	r2,-28(fp)
 8224880:	10800903 	ldbu	r2,36(r2)
 8224884:	10803fcc 	andi	r2,r2,255
 8224888:	10800058 	cmpnei	r2,r2,1
 822488c:	1000331e 	bne	r2,zero,822495c <tse_mac_init+0x3fc>
      int channel_loop = 0;
 8224890:	e03ff615 	stw	zero,-40(fp)
      int mac_loop = 0;
 8224894:	e03ff715 	stw	zero,-36(fp)
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
 8224898:	e03ff615 	stw	zero,-40(fp)
 822489c:	00002b06 	br	822494c <tse_mac_init+0x3ec>
        for (mac_loop = 0; mac_loop < pmac_groups[channel_loop]->channel; mac_loop ++) {
 82248a0:	e03ff715 	stw	zero,-36(fp)
 82248a4:	00001b06 	br	8224914 <tse_mac_init+0x3b4>
          if (pmac_groups[channel_loop]->pmac_info[mac_loop]->psys_info == tse_hw) {
 82248a8:	008209b4 	movhi	r2,2086
 82248ac:	10b71804 	addi	r2,r2,-9120
 82248b0:	e0fff617 	ldw	r3,-40(fp)
 82248b4:	18c7883a 	add	r3,r3,r3
 82248b8:	18c7883a 	add	r3,r3,r3
 82248bc:	10c5883a 	add	r2,r2,r3
 82248c0:	10c00017 	ldw	r3,0(r2)
 82248c4:	e0bff717 	ldw	r2,-36(fp)
 82248c8:	10800044 	addi	r2,r2,1
 82248cc:	1085883a 	add	r2,r2,r2
 82248d0:	1085883a 	add	r2,r2,r2
 82248d4:	1885883a 	add	r2,r3,r2
 82248d8:	10800017 	ldw	r2,0(r2)
 82248dc:	10c00217 	ldw	r3,8(r2)
 82248e0:	e0bff917 	ldw	r2,-28(fp)
 82248e4:	1880081e 	bne	r3,r2,8224908 <tse_mac_init+0x3a8>
            tse[iface].channel = mac_loop;
 82248e8:	008209b4 	movhi	r2,2086
 82248ec:	10b72c04 	addi	r2,r2,-9040
 82248f0:	e0ffff17 	ldw	r3,-4(fp)
 82248f4:	18c01324 	muli	r3,r3,76
 82248f8:	10c5883a 	add	r2,r2,r3
 82248fc:	10800d04 	addi	r2,r2,52
 8224900:	e0fff717 	ldw	r3,-36(fp)
 8224904:	10c00015 	stw	r3,0(r2)
    if(tse_hw->use_shared_fifo == 1) {
      int channel_loop = 0;
      int mac_loop = 0;
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
        for (mac_loop = 0; mac_loop < pmac_groups[channel_loop]->channel; mac_loop ++) {
 8224908:	e0bff717 	ldw	r2,-36(fp)
 822490c:	10800044 	addi	r2,r2,1
 8224910:	e0bff715 	stw	r2,-36(fp)
 8224914:	008209b4 	movhi	r2,2086
 8224918:	10b71804 	addi	r2,r2,-9120
 822491c:	e0fff617 	ldw	r3,-40(fp)
 8224920:	18c7883a 	add	r3,r3,r3
 8224924:	18c7883a 	add	r3,r3,r3
 8224928:	10c5883a 	add	r2,r2,r3
 822492c:	10800017 	ldw	r2,0(r2)
 8224930:	10800003 	ldbu	r2,0(r2)
 8224934:	10803fcc 	andi	r2,r2,255
 8224938:	e0fff717 	ldw	r3,-36(fp)
 822493c:	18bfda16 	blt	r3,r2,82248a8 <tse_mac_init+0x348>
      
    if(tse_hw->use_shared_fifo == 1) {
      int channel_loop = 0;
      int mac_loop = 0;
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
 8224940:	e0bff617 	ldw	r2,-40(fp)
 8224944:	10800044 	addi	r2,r2,1
 8224948:	e0bff615 	stw	r2,-40(fp)
 822494c:	d0a07f43 	ldbu	r2,-32259(gp)
 8224950:	10803fcc 	andi	r2,r2,255
 8224954:	e0fff617 	ldw	r3,-40(fp)
 8224958:	18bfd116 	blt	r3,r2,82248a0 <tse_mac_init+0x340>
        }
      }
    }
    /* End of Hack code */
  
  if(tse_hw->use_shared_fifo == 1) {
 822495c:	e0bff917 	ldw	r2,-28(fp)
 8224960:	10800903 	ldbu	r2,36(r2)
 8224964:	10803fcc 	andi	r2,r2,255
 8224968:	10800058 	cmpnei	r2,r2,1
 822496c:	10000f1e 	bne	r2,zero,82249ac <tse_mac_init+0x44c>
      IOWR_ALTERA_MULTI_CHAN_FIFO_SEC_FULL_THRESHOLD(tse_hw->tse_shared_fifo_rx_ctrl_base,tse_hw->tse_shared_fifo_rx_depth);
 8224970:	e0bff917 	ldw	r2,-28(fp)
 8224974:	10800d17 	ldw	r2,52(r2)
 8224978:	1007883a 	mov	r3,r2
 822497c:	e0bff917 	ldw	r2,-28(fp)
 8224980:	10800f17 	ldw	r2,60(r2)
 8224984:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_MULTI_CHAN_FIFO_ALMOST_FULL_THRESHOLD(tse_hw->tse_shared_fifo_rx_ctrl_base,((tse_hw->tse_shared_fifo_rx_depth) - 140));
 8224988:	e0bff917 	ldw	r2,-28(fp)
 822498c:	10800d17 	ldw	r2,52(r2)
 8224990:	10800204 	addi	r2,r2,8
 8224994:	1007883a 	mov	r3,r2
 8224998:	e0bff917 	ldw	r2,-28(fp)
 822499c:	10800f17 	ldw	r2,60(r2)
 82249a0:	10bfdd04 	addi	r2,r2,-140
 82249a4:	18800035 	stwio	r2,0(r3)
 82249a8:	00006006 	br	8224b2c <tse_mac_init+0x5cc>
  }
  else {
      /* Initialize MAC registers */
      IOWR_ALTERA_TSEMAC_FRM_LENGTH(tse[iface].mi.base, ALTERA_TSE_MAC_MAX_FRAME_LENGTH); 
 82249ac:	008209b4 	movhi	r2,2086
 82249b0:	10b72c04 	addi	r2,r2,-9040
 82249b4:	e0ffff17 	ldw	r3,-4(fp)
 82249b8:	18c01324 	muli	r3,r3,76
 82249bc:	10c5883a 	add	r2,r2,r3
 82249c0:	10800104 	addi	r2,r2,4
 82249c4:	10800017 	ldw	r2,0(r2)
 82249c8:	10800504 	addi	r2,r2,20
 82249cc:	00c17b84 	movi	r3,1518
 82249d0:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_ALMOST_EMPTY(tse[iface].mi.base, 8);
 82249d4:	008209b4 	movhi	r2,2086
 82249d8:	10b72c04 	addi	r2,r2,-9040
 82249dc:	e0ffff17 	ldw	r3,-4(fp)
 82249e0:	18c01324 	muli	r3,r3,76
 82249e4:	10c5883a 	add	r2,r2,r3
 82249e8:	10800104 	addi	r2,r2,4
 82249ec:	10800017 	ldw	r2,0(r2)
 82249f0:	10800b04 	addi	r2,r2,44
 82249f4:	00c00204 	movi	r3,8
 82249f8:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_ALMOST_FULL(tse[iface].mi.base, 8);
 82249fc:	008209b4 	movhi	r2,2086
 8224a00:	10b72c04 	addi	r2,r2,-9040
 8224a04:	e0ffff17 	ldw	r3,-4(fp)
 8224a08:	18c01324 	muli	r3,r3,76
 8224a0c:	10c5883a 	add	r2,r2,r3
 8224a10:	10800104 	addi	r2,r2,4
 8224a14:	10800017 	ldw	r2,0(r2)
 8224a18:	10800c04 	addi	r2,r2,48
 8224a1c:	00c00204 	movi	r3,8
 8224a20:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_ALMOST_EMPTY(tse[iface].mi.base, 8);
 8224a24:	008209b4 	movhi	r2,2086
 8224a28:	10b72c04 	addi	r2,r2,-9040
 8224a2c:	e0ffff17 	ldw	r3,-4(fp)
 8224a30:	18c01324 	muli	r3,r3,76
 8224a34:	10c5883a 	add	r2,r2,r3
 8224a38:	10800104 	addi	r2,r2,4
 8224a3c:	10800017 	ldw	r2,0(r2)
 8224a40:	10800d04 	addi	r2,r2,52
 8224a44:	00c00204 	movi	r3,8
 8224a48:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_ALMOST_FULL(tse[iface].mi.base,  3);
 8224a4c:	008209b4 	movhi	r2,2086
 8224a50:	10b72c04 	addi	r2,r2,-9040
 8224a54:	e0ffff17 	ldw	r3,-4(fp)
 8224a58:	18c01324 	muli	r3,r3,76
 8224a5c:	10c5883a 	add	r2,r2,r3
 8224a60:	10800104 	addi	r2,r2,4
 8224a64:	10800017 	ldw	r2,0(r2)
 8224a68:	10800e04 	addi	r2,r2,56
 8224a6c:	00c000c4 	movi	r3,3
 8224a70:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_SECTION_EMPTY(tse[iface].mi.base, tse_hw->tse_tx_depth - 16); //1024/4;  
 8224a74:	008209b4 	movhi	r2,2086
 8224a78:	10b72c04 	addi	r2,r2,-9040
 8224a7c:	e0ffff17 	ldw	r3,-4(fp)
 8224a80:	18c01324 	muli	r3,r3,76
 8224a84:	10c5883a 	add	r2,r2,r3
 8224a88:	10800104 	addi	r2,r2,4
 8224a8c:	10800017 	ldw	r2,0(r2)
 8224a90:	10800904 	addi	r2,r2,36
 8224a94:	e0fff917 	ldw	r3,-28(fp)
 8224a98:	18c0010b 	ldhu	r3,4(r3)
 8224a9c:	18ffffcc 	andi	r3,r3,65535
 8224aa0:	18fffc04 	addi	r3,r3,-16
 8224aa4:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_SECTION_FULL(tse[iface].mi.base,  0); //32/4; // start transmit when there are 48 bytes
 8224aa8:	008209b4 	movhi	r2,2086
 8224aac:	10b72c04 	addi	r2,r2,-9040
 8224ab0:	e0ffff17 	ldw	r3,-4(fp)
 8224ab4:	18c01324 	muli	r3,r3,76
 8224ab8:	10c5883a 	add	r2,r2,r3
 8224abc:	10800104 	addi	r2,r2,4
 8224ac0:	10800017 	ldw	r2,0(r2)
 8224ac4:	10800a04 	addi	r2,r2,40
 8224ac8:	0007883a 	mov	r3,zero
 8224acc:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_SECTION_EMPTY(tse[iface].mi.base, tse_hw->tse_rx_depth - 16); //4000/4);
 8224ad0:	008209b4 	movhi	r2,2086
 8224ad4:	10b72c04 	addi	r2,r2,-9040
 8224ad8:	e0ffff17 	ldw	r3,-4(fp)
 8224adc:	18c01324 	muli	r3,r3,76
 8224ae0:	10c5883a 	add	r2,r2,r3
 8224ae4:	10800104 	addi	r2,r2,4
 8224ae8:	10800017 	ldw	r2,0(r2)
 8224aec:	10800704 	addi	r2,r2,28
 8224af0:	e0fff917 	ldw	r3,-28(fp)
 8224af4:	18c0018b 	ldhu	r3,6(r3)
 8224af8:	18ffffcc 	andi	r3,r3,65535
 8224afc:	18fffc04 	addi	r3,r3,-16
 8224b00:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_SECTION_FULL(tse[iface].mi.base,  0);
 8224b04:	008209b4 	movhi	r2,2086
 8224b08:	10b72c04 	addi	r2,r2,-9040
 8224b0c:	e0ffff17 	ldw	r3,-4(fp)
 8224b10:	18c01324 	muli	r3,r3,76
 8224b14:	10c5883a 	add	r2,r2,r3
 8224b18:	10800104 	addi	r2,r2,4
 8224b1c:	10800017 	ldw	r2,0(r2)
 8224b20:	10800804 	addi	r2,r2,32
 8224b24:	0007883a 	mov	r3,zero
 8224b28:	10c00035 	stwio	r3,0(r2)
      tse[iface].rxShift16OK = 0;
    }
  } /* if(ETHHDR_BIAS == 0) */
 
  if(ETHHDR_BIAS == 2) {
    IOWR_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK);
 8224b2c:	008209b4 	movhi	r2,2086
 8224b30:	10b72c04 	addi	r2,r2,-9040
 8224b34:	e0ffff17 	ldw	r3,-4(fp)
 8224b38:	18c01324 	muli	r3,r3,76
 8224b3c:	10c5883a 	add	r2,r2,r3
 8224b40:	10800104 	addi	r2,r2,4
 8224b44:	10800017 	ldw	r2,0(r2)
 8224b48:	10803a04 	addi	r2,r2,232
 8224b4c:	00c00134 	movhi	r3,4
 8224b50:	10c00035 	stwio	r3,0(r2)
 
    /*
     * check if the MAC supports the 16-bit shift option allowing us
     * to send BIASed frames without copying. Used by the send function later.
     */
    if(IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) &
 8224b54:	008209b4 	movhi	r2,2086
 8224b58:	10b72c04 	addi	r2,r2,-9040
 8224b5c:	e0ffff17 	ldw	r3,-4(fp)
 8224b60:	18c01324 	muli	r3,r3,76
 8224b64:	10c5883a 	add	r2,r2,r3
 8224b68:	10800104 	addi	r2,r2,4
 8224b6c:	10800017 	ldw	r2,0(r2)
 8224b70:	10803a04 	addi	r2,r2,232
 8224b74:	10800037 	ldwio	r2,0(r2)
 8224b78:	1080012c 	andhi	r2,r2,4
 8224b7c:	10001e26 	beq	r2,zero,8224bf8 <tse_mac_init+0x698>
      ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) {
      tse[iface].txShift16OK = 1;
 8224b80:	008209b4 	movhi	r2,2086
 8224b84:	10b72c04 	addi	r2,r2,-9040
 8224b88:	e0ffff17 	ldw	r3,-4(fp)
 8224b8c:	18c01324 	muli	r3,r3,76
 8224b90:	10c5883a 	add	r2,r2,r3
 8224b94:	10800a04 	addi	r2,r2,40
 8224b98:	00c00044 	movi	r3,1
 8224b9c:	10c00015 	stw	r3,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETHHDR_BIAS);
      return ENP_LOGIC;
    }
  
    /* Enable RX shift 16 for alignment of all received frames on 16-bit start address */
    IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
 8224ba0:	008209b4 	movhi	r2,2086
 8224ba4:	10b72c04 	addi	r2,r2,-9040
 8224ba8:	e0ffff17 	ldw	r3,-4(fp)
 8224bac:	18c01324 	muli	r3,r3,76
 8224bb0:	10c5883a 	add	r2,r2,r3
 8224bb4:	10800104 	addi	r2,r2,4
 8224bb8:	10800017 	ldw	r2,0(r2)
 8224bbc:	10803b04 	addi	r2,r2,236
 8224bc0:	00c08034 	movhi	r3,512
 8224bc4:	10c00035 	stwio	r3,0(r2)
 
    /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
 8224bc8:	008209b4 	movhi	r2,2086
 8224bcc:	10b72c04 	addi	r2,r2,-9040
 8224bd0:	e0ffff17 	ldw	r3,-4(fp)
 8224bd4:	18c01324 	muli	r3,r3,76
 8224bd8:	10c5883a 	add	r2,r2,r3
 8224bdc:	10800104 	addi	r2,r2,4
 8224be0:	10800017 	ldw	r2,0(r2)
 8224be4:	10803b04 	addi	r2,r2,236
 8224be8:	10800037 	ldwio	r2,0(r2)
 8224bec:	1080802c 	andhi	r2,r2,512
 8224bf0:	10001d26 	beq	r2,zero,8224c68 <tse_mac_init+0x708>
 8224bf4:	00000d06 	br	8224c2c <tse_mac_init+0x6cc>
    if(IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) &
      ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) {
      tse[iface].txShift16OK = 1;
    } 
    else {
      tse[iface].txShift16OK = 0;
 8224bf8:	008209b4 	movhi	r2,2086
 8224bfc:	10b72c04 	addi	r2,r2,-9040
 8224c00:	e0ffff17 	ldw	r3,-4(fp)
 8224c04:	18c01324 	muli	r3,r3,76
 8224c08:	10c5883a 	add	r2,r2,r3
 8224c0c:	10800a04 	addi	r2,r2,40
 8224c10:	10000015 	stw	zero,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETHHDR_BIAS);
 8224c14:	01400084 	movi	r5,2
 8224c18:	01020974 	movhi	r4,2085
 8224c1c:	213f4304 	addi	r4,r4,-756
 8224c20:	82033fc0 	call	82033fc <printf>
      return ENP_LOGIC;
 8224c24:	00bffd44 	movi	r2,-11
 8224c28:	0000e006 	br	8224fac <tse_mac_init+0xa4c>
    IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
 
    /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
    {
      tse[iface].rxShift16OK = 1;
 8224c2c:	008209b4 	movhi	r2,2086
 8224c30:	10b72c04 	addi	r2,r2,-9040
 8224c34:	e0ffff17 	ldw	r3,-4(fp)
 8224c38:	18c01324 	muli	r3,r3,76
 8224c3c:	10c5883a 	add	r2,r2,r3
 8224c40:	10800b04 	addi	r2,r2,44
 8224c44:	00c00044 	movi	r3,1
 8224c48:	10c00015 	stw	r3,0(r2)
      return ENP_LOGIC;
    }
  } /* if(ETHHDR_BIAS == 2) */
  
  /* enable MAC */
  dat = ALTERA_TSEMAC_CMD_TX_ENA_MSK       |
 8224c4c:	00810034 	movhi	r2,1024
 8224c50:	108080c4 	addi	r2,r2,515
 8224c54:	e0bff315 	stw	r2,-52(fp)
        ALTERA_TSEMAC_CMD_TX_ADDR_INS_MSK  |
        ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
  
  /* 1000 Mbps */
  if(speed == 0x01) {
 8224c58:	e0bffd17 	ldw	r2,-12(fp)
 8224c5c:	10800058 	cmpnei	r2,r2,1
 8224c60:	1000171e 	bne	r2,zero,8224cc0 <tse_mac_init+0x760>
 8224c64:	00000d06 	br	8224c9c <tse_mac_init+0x73c>
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
    {
      tse[iface].rxShift16OK = 1;
    } 
    else {
      tse[iface].rxShift16OK = 0;
 8224c68:	008209b4 	movhi	r2,2086
 8224c6c:	10b72c04 	addi	r2,r2,-9040
 8224c70:	e0ffff17 	ldw	r3,-4(fp)
 8224c74:	18c01324 	muli	r3,r3,76
 8224c78:	10c5883a 	add	r2,r2,r3
 8224c7c:	10800b04 	addi	r2,r2,44
 8224c80:	10000015 	stw	zero,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with RX_CMD_STAT register return RxShift16 value. \n",ETHHDR_BIAS);
 8224c84:	01400084 	movi	r5,2
 8224c88:	01020974 	movhi	r4,2085
 8224c8c:	213f5b04 	addi	r4,r4,-660
 8224c90:	82033fc0 	call	82033fc <printf>
      return ENP_LOGIC;
 8224c94:	00bffd44 	movi	r2,-11
 8224c98:	0000c406 	br	8224fac <tse_mac_init+0xa4c>
        ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
  
  /* 1000 Mbps */
  if(speed == 0x01) {
    dat |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 8224c9c:	e0bff317 	ldw	r2,-52(fp)
 8224ca0:	10800214 	ori	r2,r2,8
 8224ca4:	e0bff315 	stw	r2,-52(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8224ca8:	e0fff317 	ldw	r3,-52(fp)
 8224cac:	00bf8034 	movhi	r2,65024
 8224cb0:	10bfffc4 	addi	r2,r2,-1
 8224cb4:	1884703a 	and	r2,r3,r2
 8224cb8:	e0bff315 	stw	r2,-52(fp)
 8224cbc:	00002106 	br	8224d44 <tse_mac_init+0x7e4>
  }
  /* 100 Mbps */
  else if(speed == 0x02) {
 8224cc0:	e0bffd17 	ldw	r2,-12(fp)
 8224cc4:	10800098 	cmpnei	r2,r2,2
 8224cc8:	10000a1e 	bne	r2,zero,8224cf4 <tse_mac_init+0x794>
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 8224ccc:	e0fff317 	ldw	r3,-52(fp)
 8224cd0:	00bffdc4 	movi	r2,-9
 8224cd4:	1884703a 	and	r2,r3,r2
 8224cd8:	e0bff315 	stw	r2,-52(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8224cdc:	e0fff317 	ldw	r3,-52(fp)
 8224ce0:	00bf8034 	movhi	r2,65024
 8224ce4:	10bfffc4 	addi	r2,r2,-1
 8224ce8:	1884703a 	and	r2,r3,r2
 8224cec:	e0bff315 	stw	r2,-52(fp)
 8224cf0:	00001406 	br	8224d44 <tse_mac_init+0x7e4>
  }
  /* 10 Mbps */
  else if(speed == 0x04) {
 8224cf4:	e0bffd17 	ldw	r2,-12(fp)
 8224cf8:	10800118 	cmpnei	r2,r2,4
 8224cfc:	1000081e 	bne	r2,zero,8224d20 <tse_mac_init+0x7c0>
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 8224d00:	e0fff317 	ldw	r3,-52(fp)
 8224d04:	00bffdc4 	movi	r2,-9
 8224d08:	1884703a 	and	r2,r3,r2
 8224d0c:	e0bff315 	stw	r2,-52(fp)
	dat |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8224d10:	e0bff317 	ldw	r2,-52(fp)
 8224d14:	10808034 	orhi	r2,r2,512
 8224d18:	e0bff315 	stw	r2,-52(fp)
 8224d1c:	00000906 	br	8224d44 <tse_mac_init+0x7e4>
  }
  /* default to 100 Mbps if returned invalid speed */
  else {
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 8224d20:	e0fff317 	ldw	r3,-52(fp)
 8224d24:	00bffdc4 	movi	r2,-9
 8224d28:	1884703a 	and	r2,r3,r2
 8224d2c:	e0bff315 	stw	r2,-52(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8224d30:	e0fff317 	ldw	r3,-52(fp)
 8224d34:	00bf8034 	movhi	r2,65024
 8224d38:	10bfffc4 	addi	r2,r2,-1
 8224d3c:	1884703a 	and	r2,r3,r2
 8224d40:	e0bff315 	stw	r2,-52(fp)
  }
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
 8224d44:	e0bffe17 	ldw	r2,-8(fp)
 8224d48:	1000041e 	bne	r2,zero,8224d5c <tse_mac_init+0x7fc>
    dat |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 8224d4c:	e0bff317 	ldw	r2,-52(fp)
 8224d50:	10810014 	ori	r2,r2,1024
 8224d54:	e0bff315 	stw	r2,-52(fp)
 8224d58:	00000406 	br	8224d6c <tse_mac_init+0x80c>
  }
  /* Full Duplex */
  else {
    dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 8224d5c:	e0fff317 	ldw	r3,-52(fp)
 8224d60:	00beffc4 	movi	r2,-1025
 8224d64:	1884703a 	and	r2,r3,r2
 8224d68:	e0bff315 	stw	r2,-52(fp)
  }
          
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
 8224d6c:	008209b4 	movhi	r2,2086
 8224d70:	10b72c04 	addi	r2,r2,-9040
 8224d74:	e0ffff17 	ldw	r3,-4(fp)
 8224d78:	18c01324 	muli	r3,r3,76
 8224d7c:	10c5883a 	add	r2,r2,r3
 8224d80:	10800104 	addi	r2,r2,4
 8224d84:	10800017 	ldw	r2,0(r2)
 8224d88:	10800204 	addi	r2,r2,8
 8224d8c:	e0fff317 	ldw	r3,-52(fp)
 8224d90:	10c00035 	stwio	r3,0(r2)
  dprintf("\nMAC post-initialization: CMD_CONFIG=0x%08x\n", 
  IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base));
 8224d94:	008209b4 	movhi	r2,2086
 8224d98:	10b72c04 	addi	r2,r2,-9040
 8224d9c:	e0ffff17 	ldw	r3,-4(fp)
 8224da0:	18c01324 	muli	r3,r3,76
 8224da4:	10c5883a 	add	r2,r2,r3
 8224da8:	10800104 	addi	r2,r2,4
 8224dac:	10800017 	ldw	r2,0(r2)
  else {
    dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
  }
          
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
  dprintf("\nMAC post-initialization: CMD_CONFIG=0x%08x\n", 
 8224db0:	10800204 	addi	r2,r2,8
 8224db4:	10800037 	ldwio	r2,0(r2)
 8224db8:	100b883a 	mov	r5,r2
 8224dbc:	01020974 	movhi	r4,2085
 8224dc0:	213f7304 	addi	r4,r4,-564
 8224dc4:	82033fc0 	call	82033fc <printf>
  IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base));
  
                          
#ifdef ALT_INICHE
   /* Set the MAC address */  
   IOWR_ALTERA_TSEMAC_MAC_0(tse[iface].mi.base,
 8224dc8:	008209b4 	movhi	r2,2086
 8224dcc:	10b72c04 	addi	r2,r2,-9040
 8224dd0:	e0ffff17 	ldw	r3,-4(fp)
 8224dd4:	18c01324 	muli	r3,r3,76
 8224dd8:	10c5883a 	add	r2,r2,r3
 8224ddc:	10800104 	addi	r2,r2,4
 8224de0:	10800017 	ldw	r2,0(r2)
 8224de4:	10c00304 	addi	r3,r2,12
 8224de8:	008209b4 	movhi	r2,2086
 8224dec:	10b72c04 	addi	r2,r2,-9040
 8224df0:	e13fff17 	ldw	r4,-4(fp)
 8224df4:	21001324 	muli	r4,r4,76
 8224df8:	1105883a 	add	r2,r2,r4
 8224dfc:	10800604 	addi	r2,r2,24
 8224e00:	10800003 	ldbu	r2,0(r2)
 8224e04:	11003fcc 	andi	r4,r2,255
 8224e08:	008209b4 	movhi	r2,2086
 8224e0c:	10b72c04 	addi	r2,r2,-9040
 8224e10:	e17fff17 	ldw	r5,-4(fp)
 8224e14:	29401324 	muli	r5,r5,76
 8224e18:	1145883a 	add	r2,r2,r5
 8224e1c:	10800644 	addi	r2,r2,25
 8224e20:	10800003 	ldbu	r2,0(r2)
 8224e24:	10803fcc 	andi	r2,r2,255
 8224e28:	1004923a 	slli	r2,r2,8
 8224e2c:	2088b03a 	or	r4,r4,r2
 8224e30:	008209b4 	movhi	r2,2086
 8224e34:	10b72c04 	addi	r2,r2,-9040
 8224e38:	e17fff17 	ldw	r5,-4(fp)
 8224e3c:	29401324 	muli	r5,r5,76
 8224e40:	1145883a 	add	r2,r2,r5
 8224e44:	10800684 	addi	r2,r2,26
 8224e48:	10800003 	ldbu	r2,0(r2)
 8224e4c:	10803fcc 	andi	r2,r2,255
 8224e50:	1004943a 	slli	r2,r2,16
 8224e54:	2088b03a 	or	r4,r4,r2
 8224e58:	008209b4 	movhi	r2,2086
 8224e5c:	10b72c04 	addi	r2,r2,-9040
 8224e60:	e17fff17 	ldw	r5,-4(fp)
 8224e64:	29401324 	muli	r5,r5,76
 8224e68:	1145883a 	add	r2,r2,r5
 8224e6c:	108006c4 	addi	r2,r2,27
 8224e70:	10800003 	ldbu	r2,0(r2)
 8224e74:	10803fcc 	andi	r2,r2,255
 8224e78:	1004963a 	slli	r2,r2,24
 8224e7c:	2084b03a 	or	r2,r4,r2
 8224e80:	18800035 	stwio	r2,0(r3)
                           ((int)((unsigned char) tse[iface].mac_addr[0]) | 
                            (int)((unsigned char) tse[iface].mac_addr[1] <<  8) |
                            (int)((unsigned char) tse[iface].mac_addr[2] << 16) | 
                            (int)((unsigned char) tse[iface].mac_addr[3] << 24)));
  
   IOWR_ALTERA_TSEMAC_MAC_1(tse[iface].mi.base, 
 8224e84:	008209b4 	movhi	r2,2086
 8224e88:	10b72c04 	addi	r2,r2,-9040
 8224e8c:	e0ffff17 	ldw	r3,-4(fp)
 8224e90:	18c01324 	muli	r3,r3,76
 8224e94:	10c5883a 	add	r2,r2,r3
 8224e98:	10800104 	addi	r2,r2,4
 8224e9c:	10800017 	ldw	r2,0(r2)
 8224ea0:	10c00404 	addi	r3,r2,16
 8224ea4:	008209b4 	movhi	r2,2086
 8224ea8:	10b72c04 	addi	r2,r2,-9040
 8224eac:	e13fff17 	ldw	r4,-4(fp)
 8224eb0:	21001324 	muli	r4,r4,76
 8224eb4:	1105883a 	add	r2,r2,r4
 8224eb8:	10800704 	addi	r2,r2,28
 8224ebc:	10800003 	ldbu	r2,0(r2)
 8224ec0:	11003fcc 	andi	r4,r2,255
 8224ec4:	008209b4 	movhi	r2,2086
 8224ec8:	10b72c04 	addi	r2,r2,-9040
 8224ecc:	e17fff17 	ldw	r5,-4(fp)
 8224ed0:	29401324 	muli	r5,r5,76
 8224ed4:	1145883a 	add	r2,r2,r5
 8224ed8:	10800744 	addi	r2,r2,29
 8224edc:	10800003 	ldbu	r2,0(r2)
 8224ee0:	10803fcc 	andi	r2,r2,255
 8224ee4:	1004923a 	slli	r2,r2,8
 8224ee8:	2084b03a 	or	r2,r4,r2
 8224eec:	10bfffcc 	andi	r2,r2,65535
 8224ef0:	18800035 	stwio	r2,0(r3)
   tse[iface].mac_addr[5] = 0xBA;

#endif /* not ALT_INICHE */

   /* status = UP */ 
   nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_UP;    
 8224ef4:	008209b4 	movhi	r2,2086
 8224ef8:	10b83d04 	addi	r2,r2,-7948
 8224efc:	e0ffff17 	ldw	r3,-4(fp)
 8224f00:	18c7883a 	add	r3,r3,r3
 8224f04:	18c7883a 	add	r3,r3,r3
 8224f08:	10c5883a 	add	r2,r2,r3
 8224f0c:	10800017 	ldw	r2,0(r2)
 8224f10:	10802717 	ldw	r2,156(r2)
 8224f14:	00c00044 	movi	r3,1
 8224f18:	10c00615 	stw	r3,24(r2)
   nets[iface]->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_UP;
 8224f1c:	008209b4 	movhi	r2,2086
 8224f20:	10b83d04 	addi	r2,r2,-7948
 8224f24:	e0ffff17 	ldw	r3,-4(fp)
 8224f28:	18c7883a 	add	r3,r3,r3
 8224f2c:	18c7883a 	add	r3,r3,r3
 8224f30:	10c5883a 	add	r2,r2,r3
 8224f34:	10800017 	ldw	r2,0(r2)
 8224f38:	10802717 	ldw	r2,156(r2)
 8224f3c:	00c00044 	movi	r3,1
 8224f40:	10c00715 	stw	r3,28(r2)
   
   /* Install SGDMA (RX) interrupt handler */
   alt_avalon_sgdma_register_callback(
 8224f44:	008209b4 	movhi	r2,2086
 8224f48:	10b72c04 	addi	r2,r2,-9040
 8224f4c:	e0ffff17 	ldw	r3,-4(fp)
 8224f50:	18c01324 	muli	r3,r3,76
 8224f54:	10c5883a 	add	r2,r2,r3
 8224f58:	10800304 	addi	r2,r2,12
 8224f5c:	11000017 	ldw	r4,0(r2)
        tse[iface].mi.rx_sgdma,
        (alt_avalon_sgdma_callback)&tse_sgdmaRx_isr,
        (alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,
        (void*)(&tse[iface]));
 8224f60:	e0bfff17 	ldw	r2,-4(fp)
 8224f64:	10c01324 	muli	r3,r2,76
 8224f68:	008209b4 	movhi	r2,2086
 8224f6c:	10b72c04 	addi	r2,r2,-9040
 8224f70:	1885883a 	add	r2,r3,r2
   /* status = UP */ 
   nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_UP;    
   nets[iface]->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_UP;
   
   /* Install SGDMA (RX) interrupt handler */
   alt_avalon_sgdma_register_callback(
 8224f74:	100f883a 	mov	r7,r2
 8224f78:	01800604 	movi	r6,24
 8224f7c:	014208b4 	movhi	r5,2082
 8224f80:	2954ae04 	addi	r5,r5,21176
 8224f84:	821e8a40 	call	821e8a4 <alt_avalon_sgdma_register_callback>
        tse[iface].mi.rx_sgdma,
        (alt_avalon_sgdma_callback)&tse_sgdmaRx_isr,
        (alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,
        (void*)(&tse[iface]));
    
  status = tse_sgdma_read_init(&tse[iface]);
 8224f88:	e0bfff17 	ldw	r2,-4(fp)
 8224f8c:	10c01324 	muli	r3,r2,76
 8224f90:	008209b4 	movhi	r2,2086
 8224f94:	10b72c04 	addi	r2,r2,-9040
 8224f98:	1885883a 	add	r2,r3,r2
 8224f9c:	1009883a 	mov	r4,r2
 8224fa0:	82253640 	call	8225364 <tse_sgdma_read_init>
 8224fa4:	e0bff815 	stw	r2,-32(fp)
  
  return status;
 8224fa8:	e0bff817 	ldw	r2,-32(fp)
}
 8224fac:	e037883a 	mov	sp,fp
 8224fb0:	dfc00117 	ldw	ra,4(sp)
 8224fb4:	df000017 	ldw	fp,0(sp)
 8224fb8:	dec00204 	addi	sp,sp,8
 8224fbc:	f800283a 	ret

08224fc0 <tse_mac_raw_send>:
 * @param  data - pointer to the data payload
 * @param  data_bytes - number of bytes of the data payload to be sent to the MAC
 * @return SUCCESS if success, else a negative value
 */
int tse_mac_raw_send(NET net, char * data, unsigned data_bytes)
{
 8224fc0:	defe6504 	addi	sp,sp,-1644
 8224fc4:	dfc19a15 	stw	ra,1640(sp)
 8224fc8:	df019915 	stw	fp,1636(sp)
 8224fcc:	df019904 	addi	fp,sp,1636
 8224fd0:	e13ffd15 	stw	r4,-12(fp)
 8224fd4:	e17ffe15 	stw	r5,-8(fp)
 8224fd8:	e1bfff15 	stw	r6,-4(fp)
   int result,i;
   unsigned len = data_bytes;
 8224fdc:	e0bfff17 	ldw	r2,-4(fp)
 8224fe0:	e0be6e15 	stw	r2,-1608(fp)

   ins_tse_info* tse_ptr = (ins_tse_info*) net->n_local;
 8224fe4:	e0bffd17 	ldw	r2,-12(fp)
 8224fe8:	10802817 	ldw	r2,160(r2)
 8224fec:	e0be6f15 	stw	r2,-1604(fp)

   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse_ptr->tse;
 8224ff0:	e0be6f17 	ldw	r2,-1604(fp)
 8224ff4:	10801217 	ldw	r2,72(r2)
 8224ff8:	e0be7015 	stw	r2,-1600(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8224ffc:	0005303a 	rdctl	r2,status
 8225000:	e0be7615 	stw	r2,-1576(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8225004:	e0fe7617 	ldw	r3,-1576(fp)
 8225008:	00bfff84 	movi	r2,-2
 822500c:	1884703a 	and	r2,r3,r2
 8225010:	1001703a 	wrctl	status,r2
  
  return context;
 8225014:	e0be7617 	ldw	r2,-1576(fp)
   unsigned int* ActualData;
   int cpu_sr;
   /* Intermediate buffers used for temporary copy of frames that cannot be directrly DMA'ed*/
   char buf2[1560];

   OS_ENTER_CRITICAL();
 8225018:	e0be7215 	stw	r2,-1592(fp)
   mi = &tse_ptr->mi;
 822501c:	e0be6f17 	ldw	r2,-1604(fp)
 8225020:	10800104 	addi	r2,r2,4
 8225024:	e0be7315 	stw	r2,-1588(fp)
   
   if(tse_ptr->sem!=0) /* Tx is busy*/
 8225028:	e0be6f17 	ldw	r2,-1604(fp)
 822502c:	10800c17 	ldw	r2,48(r2)
 8225030:	10000926 	beq	r2,zero,8225058 <tse_mac_raw_send+0x98>
   {
      dprintf("raw_send CALLED AGAIN!!!\n");
 8225034:	01020974 	movhi	r4,2085
 8225038:	213f7f04 	addi	r4,r4,-516
 822503c:	82036800 	call	8203680 <puts>
 8225040:	e0be7217 	ldw	r2,-1592(fp)
 8225044:	e0be7115 	stw	r2,-1596(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8225048:	e0be7117 	ldw	r2,-1596(fp)
 822504c:	1001703a 	wrctl	status,r2
      OS_EXIT_CRITICAL();
      return ENP_RESOURCE;
 8225050:	00bffa84 	movi	r2,-22
 8225054:	00009306 	br	82252a4 <tse_mac_raw_send+0x2e4>
   }
 
   tse_ptr->sem = 1;  
 8225058:	e0be6f17 	ldw	r2,-1604(fp)
 822505c:	00c00044 	movi	r3,1
 8225060:	10c00c15 	stw	r3,48(r2)

   if(((unsigned long)data & 0x03) == 0) 
 8225064:	e0bffe17 	ldw	r2,-8(fp)
 8225068:	108000cc 	andi	r2,r2,3
 822506c:	1000031e 	bne	r2,zero,822507c <tse_mac_raw_send+0xbc>
   { 
      /* 32-bit aligned start, then header starts ETHHDR_BIAS later => 16 bit shift is ok */    
      ActualData = (unsigned int*)data;  /* base driver will detect 16-bit shift. */
 8225070:	e0bffe17 	ldw	r2,-8(fp)
 8225074:	e0be6d15 	stw	r2,-1612(fp)
 8225078:	00001406 	br	82250cc <tse_mac_raw_send+0x10c>
      /* 
       * Copy data to temporary buffer <buf2>. This is done because of allignment 
       * issues. The SGDMA cannot copy the data directly from (data + ETHHDR_BIAS)
       * because it needs a 32-bit alligned address space. 
       */
      for(i=0;i<len;i++) {
 822507c:	e03e6c15 	stw	zero,-1616(fp)
 8225080:	00000d06 	br	82250b8 <tse_mac_raw_send+0xf8>
         buf2[i] = IORD_8DIRECT(&data[i], 0);
 8225084:	e0be6c17 	ldw	r2,-1616(fp)
 8225088:	e0fffe17 	ldw	r3,-8(fp)
 822508c:	1885883a 	add	r2,r3,r2
 8225090:	10800023 	ldbuio	r2,0(r2)
 8225094:	10803fcc 	andi	r2,r2,255
 8225098:	1009883a 	mov	r4,r2
 822509c:	e0fe7704 	addi	r3,fp,-1572
 82250a0:	e0be6c17 	ldw	r2,-1616(fp)
 82250a4:	1885883a 	add	r2,r3,r2
 82250a8:	11000005 	stb	r4,0(r2)
      /* 
       * Copy data to temporary buffer <buf2>. This is done because of allignment 
       * issues. The SGDMA cannot copy the data directly from (data + ETHHDR_BIAS)
       * because it needs a 32-bit alligned address space. 
       */
      for(i=0;i<len;i++) {
 82250ac:	e0be6c17 	ldw	r2,-1616(fp)
 82250b0:	10800044 	addi	r2,r2,1
 82250b4:	e0be6c15 	stw	r2,-1616(fp)
 82250b8:	e0fe6c17 	ldw	r3,-1616(fp)
 82250bc:	e0be6e17 	ldw	r2,-1608(fp)
 82250c0:	18bff036 	bltu	r3,r2,8225084 <tse_mac_raw_send+0xc4>
         buf2[i] = IORD_8DIRECT(&data[i], 0);
      }
      ActualData = (unsigned int*)buf2;
 82250c4:	e0be7704 	addi	r2,fp,-1572
 82250c8:	e0be6d15 	stw	r2,-1612(fp)
   }  
   
     // clear bit-31 before passing it to SGDMA Driver
    ActualData = (unsigned int*)alt_remap_cached ((volatile void*) ActualData, 4);
 82250cc:	01400104 	movi	r5,4
 82250d0:	e13e6d17 	ldw	r4,-1612(fp)
 82250d4:	823c80c0 	call	823c80c <alt_remap_cached>
 82250d8:	e0be6d15 	stw	r2,-1612(fp)

   /* Write data to Tx FIFO using the DMA */
   if((tse_hw->use_shared_fifo == 1) && (( len > ALTERA_TSE_MIN_MTU_SIZE )) && (IORD_ALTERA_MULTI_CHAN_FILL_LEVEL(tse_hw->tse_shared_fifo_tx_stat_base, tse_ptr->channel) < ALTERA_TSE_MIN_MTU_SIZE))
 82250dc:	e0be7017 	ldw	r2,-1600(fp)
 82250e0:	10800903 	ldbu	r2,36(r2)
 82250e4:	10803fcc 	andi	r2,r2,255
 82250e8:	10800058 	cmpnei	r2,r2,1
 82250ec:	1000271e 	bne	r2,zero,822518c <tse_mac_raw_send+0x1cc>
 82250f0:	e0be6e17 	ldw	r2,-1608(fp)
 82250f4:	108003f0 	cmpltui	r2,r2,15
 82250f8:	1000241e 	bne	r2,zero,822518c <tse_mac_raw_send+0x1cc>
 82250fc:	e0be6f17 	ldw	r2,-1604(fp)
 8225100:	10800d17 	ldw	r2,52(r2)
 8225104:	1085883a 	add	r2,r2,r2
 8225108:	1085883a 	add	r2,r2,r2
 822510c:	1007883a 	mov	r3,r2
 8225110:	e0be7017 	ldw	r2,-1600(fp)
 8225114:	10800b17 	ldw	r2,44(r2)
 8225118:	1885883a 	add	r2,r3,r2
 822511c:	10800037 	ldwio	r2,0(r2)
 8225120:	10800388 	cmpgei	r2,r2,14
 8225124:	1000191e 	bne	r2,zero,822518c <tse_mac_raw_send+0x1cc>
   {
        /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 8225128:	e0be6f17 	ldw	r2,-1604(fp)
 822512c:	10c00f17 	ldw	r3,60(r2)
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
 8225130:	e0be6f17 	ldw	r2,-1604(fp)
 8225134:	10800f17 	ldw	r2,60(r2)

   /* Write data to Tx FIFO using the DMA */
   if((tse_hw->use_shared_fifo == 1) && (( len > ALTERA_TSE_MIN_MTU_SIZE )) && (IORD_ALTERA_MULTI_CHAN_FILL_LEVEL(tse_hw->tse_shared_fifo_tx_stat_base, tse_ptr->channel) < ALTERA_TSE_MIN_MTU_SIZE))
   {
        /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 8225138:	11000804 	addi	r4,r2,32
 822513c:	e0be6e17 	ldw	r2,-1608(fp)
 8225140:	117fffcc 	andi	r5,r2,65535
 8225144:	d8000315 	stw	zero,12(sp)
 8225148:	00800044 	movi	r2,1
 822514c:	d8800215 	stw	r2,8(sp)
 8225150:	00800044 	movi	r2,1
 8225154:	d8800115 	stw	r2,4(sp)
 8225158:	d8000015 	stw	zero,0(sp)
 822515c:	280f883a 	mov	r7,r5
 8225160:	e1be6d17 	ldw	r6,-1612(fp)
 8225164:	200b883a 	mov	r5,r4
 8225168:	1809883a 	mov	r4,r3
 822516c:	821e7980 	call	821e798 <alt_avalon_sgdma_construct_mem_to_stream_desc>
           0,                                        // don't read from constant address
           1,                                        // generate sop
           1,                                        // generate endofpacket signal
           0);                                       // atlantic channel (don't know/don't care: set to 0)

        tse_mac_sTxWrite(mi,tse_ptr->desc);
 8225170:	e0be6f17 	ldw	r2,-1604(fp)
 8225174:	10800f17 	ldw	r2,60(r2)
 8225178:	100b883a 	mov	r5,r2
 822517c:	e13e7317 	ldw	r4,-1588(fp)
 8225180:	821f2700 	call	821f270 <tse_mac_sTxWrite>
        result = 0;
 8225184:	e03e6b15 	stw	zero,-1620(fp)
 8225188:	00001e06 	br	8225204 <tse_mac_raw_send+0x244>
   }
   else if( len > ALTERA_TSE_MIN_MTU_SIZE ) {    
 822518c:	e0be6e17 	ldw	r2,-1608(fp)
 8225190:	108003f0 	cmpltui	r2,r2,15
 8225194:	1000191e 	bne	r2,zero,82251fc <tse_mac_raw_send+0x23c>

       /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 8225198:	e0be6f17 	ldw	r2,-1604(fp)
 822519c:	10c00f17 	ldw	r3,60(r2)
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
 82251a0:	e0be6f17 	ldw	r2,-1604(fp)
 82251a4:	10800f17 	ldw	r2,60(r2)
        result = 0;
   }
   else if( len > ALTERA_TSE_MIN_MTU_SIZE ) {    

       /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 82251a8:	11000804 	addi	r4,r2,32
 82251ac:	e0be6e17 	ldw	r2,-1608(fp)
 82251b0:	117fffcc 	andi	r5,r2,65535
 82251b4:	d8000315 	stw	zero,12(sp)
 82251b8:	00800044 	movi	r2,1
 82251bc:	d8800215 	stw	r2,8(sp)
 82251c0:	00800044 	movi	r2,1
 82251c4:	d8800115 	stw	r2,4(sp)
 82251c8:	d8000015 	stw	zero,0(sp)
 82251cc:	280f883a 	mov	r7,r5
 82251d0:	e1be6d17 	ldw	r6,-1612(fp)
 82251d4:	200b883a 	mov	r5,r4
 82251d8:	1809883a 	mov	r4,r3
 82251dc:	821e7980 	call	821e798 <alt_avalon_sgdma_construct_mem_to_stream_desc>
           1,                                        // generate sop
           1,                                        // generate endofpacket signal
           0);                                       // atlantic channel (don't know/don't care: set to 0)
                  
    
       tse_mac_sTxWrite(mi,tse_ptr->desc);
 82251e0:	e0be6f17 	ldw	r2,-1604(fp)
 82251e4:	10800f17 	ldw	r2,60(r2)
 82251e8:	100b883a 	mov	r5,r2
 82251ec:	e13e7317 	ldw	r4,-1588(fp)
 82251f0:	821f2700 	call	821f270 <tse_mac_sTxWrite>
       result = 0;
 82251f4:	e03e6b15 	stw	zero,-1620(fp)
 82251f8:	00000206 	br	8225204 <tse_mac_raw_send+0x244>

   } else {
       result = -3;
 82251fc:	00bfff44 	movi	r2,-3
 8225200:	e0be6b15 	stw	r2,-1620(fp)
   }

   if(result < 0)   /* SGDMA not available */
 8225204:	e0be6b17 	ldw	r2,-1620(fp)
 8225208:	1000120e 	bge	r2,zero,8225254 <tse_mac_raw_send+0x294>
   {
      dprintf("raw_send() SGDMA not available, ret=%d, len=%d\n",result, len);
 822520c:	e1be6e17 	ldw	r6,-1608(fp)
 8225210:	e17e6b17 	ldw	r5,-1620(fp)
 8225214:	01020974 	movhi	r4,2085
 8225218:	213f8604 	addi	r4,r4,-488
 822521c:	82033fc0 	call	82033fc <printf>
      net->n_mib->ifOutDiscards++;
 8225220:	e0bffd17 	ldw	r2,-12(fp)
 8225224:	10802717 	ldw	r2,156(r2)
 8225228:	10c01217 	ldw	r3,72(r2)
 822522c:	18c00044 	addi	r3,r3,1
 8225230:	10c01215 	stw	r3,72(r2)
      tse_ptr->sem = 0;
 8225234:	e0be6f17 	ldw	r2,-1604(fp)
 8225238:	10000c15 	stw	zero,48(r2)
 822523c:	e0be7217 	ldw	r2,-1592(fp)
 8225240:	e0be7415 	stw	r2,-1584(fp)
 8225244:	e0be7417 	ldw	r2,-1584(fp)
 8225248:	1001703a 	wrctl	status,r2

      OS_EXIT_CRITICAL();
      return SEND_DROPPED;   /* ENP_RESOURCE and SEND_DROPPED have the same value! */
 822524c:	00bffa84 	movi	r2,-22
 8225250:	00001406 	br	82252a4 <tse_mac_raw_send+0x2e4>
   }
   else   /* = 0, success */
   {
      net->n_mib->ifOutOctets += data_bytes;
 8225254:	e0bffd17 	ldw	r2,-12(fp)
 8225258:	10802717 	ldw	r2,156(r2)
 822525c:	e0fffd17 	ldw	r3,-12(fp)
 8225260:	18c02717 	ldw	r3,156(r3)
 8225264:	19000f17 	ldw	r4,60(r3)
 8225268:	e0ffff17 	ldw	r3,-4(fp)
 822526c:	20c7883a 	add	r3,r4,r3
 8225270:	10c00f15 	stw	r3,60(r2)
      /* we dont know whether it was unicast or not, we count both in <ifOutUcastPkts> */
      net->n_mib->ifOutUcastPkts++;
 8225274:	e0bffd17 	ldw	r2,-12(fp)
 8225278:	10802717 	ldw	r2,156(r2)
 822527c:	10c01017 	ldw	r3,64(r2)
 8225280:	18c00044 	addi	r3,r3,1
 8225284:	10c01015 	stw	r3,64(r2)
      tse_ptr->sem = 0;
 8225288:	e0be6f17 	ldw	r2,-1604(fp)
 822528c:	10000c15 	stw	zero,48(r2)
 8225290:	e0be7217 	ldw	r2,-1592(fp)
 8225294:	e0be7515 	stw	r2,-1580(fp)
 8225298:	e0be7517 	ldw	r2,-1580(fp)
 822529c:	1001703a 	wrctl	status,r2

      OS_EXIT_CRITICAL();
      return SUCCESS;  /*success */
 82252a0:	0005883a 	mov	r2,zero
   }
}
 82252a4:	e037883a 	mov	sp,fp
 82252a8:	dfc00117 	ldw	ra,4(sp)
 82252ac:	df000017 	ldw	fp,0(sp)
 82252b0:	dec00204 	addi	sp,sp,8
 82252b4:	f800283a 	ret

082252b8 <tse_sgdmaRx_isr>:
 * @API TYPE - callback
 * @param  context  - context of the TSE MAC instance
 * @param  intnum - temporary storage
 */
void tse_sgdmaRx_isr(void * context)
{
 82252b8:	defffa04 	addi	sp,sp,-24
 82252bc:	dfc00515 	stw	ra,20(sp)
 82252c0:	df000415 	stw	fp,16(sp)
 82252c4:	df000404 	addi	fp,sp,16
 82252c8:	e13fff15 	stw	r4,-4(fp)
  ins_tse_info* tse_ptr = (ins_tse_info *) context; 
 82252cc:	e0bfff17 	ldw	r2,-4(fp)
 82252d0:	e0bffc15 	stw	r2,-16(fp)
  alt_u8 sgdma_status;
  
  /* Capture whether there are existing packets on stack rcv queue */
  int initial_rcvdq_len = rcvdq.q_len;
 82252d4:	008209b4 	movhi	r2,2086
 82252d8:	10b77804 	addi	r2,r2,-8736
 82252dc:	10800217 	ldw	r2,8(r2)
 82252e0:	e0bffd15 	stw	r2,-12(fp)
   * IO read to peripheral that generated the IRQ is done after IO write
   * to negate the interrupt request. This ensures at the IO write reaches 
   * the peripheral (through any high-latency hardware in the system)
   * before the ISR exits.
   */   
  sgdma_status = IORD_ALTERA_AVALON_SGDMA_STATUS(tse_ptr->mi.rx_sgdma->base);
 82252e4:	e0bffc17 	ldw	r2,-16(fp)
 82252e8:	10800317 	ldw	r2,12(r2)
 82252ec:	10800317 	ldw	r2,12(r2)
 82252f0:	10800037 	ldwio	r2,0(r2)
 82252f4:	e0bffe05 	stb	r2,-8(fp)
  
  /* Why are we here; should we be? */
  if(sgdma_status & (ALTERA_AVALON_SGDMA_STATUS_CHAIN_COMPLETED_MSK | 
 82252f8:	e0bffe03 	ldbu	r2,-8(fp)
 82252fc:	1080030c 	andi	r2,r2,12
 8225300:	10001226 	beq	r2,zero,822534c <tse_sgdmaRx_isr+0x94>
                     ALTERA_AVALON_SGDMA_STATUS_DESC_COMPLETED_MSK) ) {
    /* Handle received packet(s) */
    tse_mac_rcv(tse_ptr); 
 8225304:	e13ffc17 	ldw	r4,-16(fp)
 8225308:	82255100 	call	8225510 <tse_mac_rcv>
        tse_ptr->mi.rx_sgdma, 
        &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
    }
#else
    /* Re-start SGDMA (always, if we have a single descriptor) */
    alt_avalon_sgdma_do_async_transfer(
 822530c:	e0bffc17 	ldw	r2,-16(fp)
 8225310:	10c00317 	ldw	r3,12(r2)
      tse_ptr->mi.rx_sgdma, 
      &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
 8225314:	e0bffc17 	ldw	r2,-16(fp)
 8225318:	10800f17 	ldw	r2,60(r2)
        tse_ptr->mi.rx_sgdma, 
        &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
    }
#else
    /* Re-start SGDMA (always, if we have a single descriptor) */
    alt_avalon_sgdma_do_async_transfer(
 822531c:	10801004 	addi	r2,r2,64
 8225320:	100b883a 	mov	r5,r2
 8225324:	1809883a 	mov	r4,r3
 8225328:	821e3940 	call	821e394 <alt_avalon_sgdma_do_async_transfer>
      tse_ptr->mi.rx_sgdma, 
      &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
#endif
  
    /* Wake up Niche stack if there are new packets are on queue */
    if ((rcvdq.q_len) > initial_rcvdq_len) {
 822532c:	008209b4 	movhi	r2,2086
 8225330:	10b77804 	addi	r2,r2,-8736
 8225334:	10800217 	ldw	r2,8(r2)
 8225338:	e0fffd17 	ldw	r3,-12(fp)
 822533c:	1880030e 	bge	r3,r2,822534c <tse_sgdmaRx_isr+0x94>
      SignalPktDemux();
 8225340:	d0a0ab17 	ldw	r2,-32084(gp)
 8225344:	1009883a 	mov	r4,r2
 8225348:	821a4a80 	call	821a4a8 <OSSemPost>
    }  
  } /* if (valid SGDMA interrupt) */
}
 822534c:	0001883a 	nop
 8225350:	e037883a 	mov	sp,fp
 8225354:	dfc00117 	ldw	ra,4(sp)
 8225358:	df000017 	ldw	fp,0(sp)
 822535c:	dec00204 	addi	sp,sp,8
 8225360:	f800283a 	ret

08225364 <tse_sgdma_read_init>:
 * 
 * @API TYPE - Internal
 * @return SUCCESS on success 
 */
int tse_sgdma_read_init(ins_tse_info* tse_ptr)
{     
 8225364:	defffa04 	addi	sp,sp,-24
 8225368:	dfc00515 	stw	ra,20(sp)
 822536c:	df000415 	stw	fp,16(sp)
 8225370:	dc000315 	stw	r16,12(sp)
 8225374:	df000404 	addi	fp,sp,16
 8225378:	e13ffe15 	stw	r4,-8(fp)
  alt_u32 *uncached_packet_payload;
  
  for(tse_ptr->chain_loop = 0; tse_ptr->chain_loop < ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE; tse_ptr->chain_loop++)
 822537c:	e0bffe17 	ldw	r2,-8(fp)
 8225380:	10000e15 	stw	zero,56(r2)
 8225384:	00004406 	br	8225498 <tse_sgdma_read_init+0x134>
  { 
    tse_ptr->pkt_array[tse_ptr->chain_loop] = pk_alloc(ALTERA_TSE_PKT_INIT_LEN+4);
 8225388:	e0bffe17 	ldw	r2,-8(fp)
 822538c:	14000e17 	ldw	r16,56(r2)
 8225390:	01017f04 	movi	r4,1532
 8225394:	822ca480 	call	822ca48 <pk_alloc>
 8225398:	1009883a 	mov	r4,r2
 822539c:	e0fffe17 	ldw	r3,-8(fp)
 82253a0:	80800444 	addi	r2,r16,17
 82253a4:	1085883a 	add	r2,r2,r2
 82253a8:	1085883a 	add	r2,r2,r2
 82253ac:	1885883a 	add	r2,r3,r2
 82253b0:	11000015 	stw	r4,0(r2)
    
    if (!tse_ptr->pkt_array[tse_ptr->chain_loop])   /* couldn't get a free buffer for rx */
 82253b4:	e0bffe17 	ldw	r2,-8(fp)
 82253b8:	10800e17 	ldw	r2,56(r2)
 82253bc:	e0fffe17 	ldw	r3,-8(fp)
 82253c0:	10800444 	addi	r2,r2,17
 82253c4:	1085883a 	add	r2,r2,r2
 82253c8:	1085883a 	add	r2,r2,r2
 82253cc:	1885883a 	add	r2,r3,r2
 82253d0:	10800017 	ldw	r2,0(r2)
 82253d4:	10000b1e 	bne	r2,zero,8225404 <tse_sgdma_read_init+0xa0>
    {
      dprintf("[tse_sgdma_read_init] Fatal error: No free packet buffers for RX\n");
 82253d8:	01020974 	movhi	r4,2085
 82253dc:	213f9204 	addi	r4,r4,-440
 82253e0:	82036800 	call	8203680 <puts>
      tse_ptr->netp->n_mib->ifInDiscards++;
 82253e4:	e0bffe17 	ldw	r2,-8(fp)
 82253e8:	10800817 	ldw	r2,32(r2)
 82253ec:	10802717 	ldw	r2,156(r2)
 82253f0:	10c00c17 	ldw	r3,48(r2)
 82253f4:	18c00044 	addi	r3,r3,1
 82253f8:	10c00c15 	stw	r3,48(r2)
      
      return ENP_NOBUFFER;
 82253fc:	00bffac4 	movi	r2,-21
 8225400:	00003d06 	br	82254f8 <tse_sgdma_read_init+0x194>
    }
    
    // ensure bit-31 of tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff is clear before passing
    // to SGDMA Driver
    uncached_packet_payload = (alt_u32 *)alt_remap_cached ((volatile void*) tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);
 8225404:	e0bffe17 	ldw	r2,-8(fp)
 8225408:	10800e17 	ldw	r2,56(r2)
 822540c:	e0fffe17 	ldw	r3,-8(fp)
 8225410:	10800444 	addi	r2,r2,17
 8225414:	1085883a 	add	r2,r2,r2
 8225418:	1085883a 	add	r2,r2,r2
 822541c:	1885883a 	add	r2,r3,r2
 8225420:	10800017 	ldw	r2,0(r2)
 8225424:	10800117 	ldw	r2,4(r2)
 8225428:	01400104 	movi	r5,4
 822542c:	1009883a 	mov	r4,r2
 8225430:	823c80c0 	call	823c80c <alt_remap_cached>
 8225434:	e0bffd15 	stw	r2,-12(fp)

    alt_avalon_sgdma_construct_stream_to_mem_desc(
            (alt_sgdma_descriptor *) &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
 8225438:	e0bffe17 	ldw	r2,-8(fp)
 822543c:	10c00f17 	ldw	r3,60(r2)
 8225440:	e0bffe17 	ldw	r2,-8(fp)
 8225444:	10800e17 	ldw	r2,56(r2)
    
    // ensure bit-31 of tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff is clear before passing
    // to SGDMA Driver
    uncached_packet_payload = (alt_u32 *)alt_remap_cached ((volatile void*) tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);

    alt_avalon_sgdma_construct_stream_to_mem_desc(
 8225448:	10800084 	addi	r2,r2,2
 822544c:	1004917a 	slli	r2,r2,5
 8225450:	1889883a 	add	r4,r3,r2
            (alt_sgdma_descriptor *) &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
            (alt_sgdma_descriptor *) &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST], // pointer to "next"
 8225454:	e0bffe17 	ldw	r2,-8(fp)
 8225458:	10c00f17 	ldw	r3,60(r2)
 822545c:	e0bffe17 	ldw	r2,-8(fp)
 8225460:	10800e17 	ldw	r2,56(r2)
    
    // ensure bit-31 of tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff is clear before passing
    // to SGDMA Driver
    uncached_packet_payload = (alt_u32 *)alt_remap_cached ((volatile void*) tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);

    alt_avalon_sgdma_construct_stream_to_mem_desc(
 8225464:	108000c4 	addi	r2,r2,3
 8225468:	1004917a 	slli	r2,r2,5
 822546c:	1885883a 	add	r2,r3,r2
 8225470:	d8000015 	stw	zero,0(sp)
 8225474:	000f883a 	mov	r7,zero
 8225478:	e1bffd17 	ldw	r6,-12(fp)
 822547c:	100b883a 	mov	r5,r2
 8225480:	821e6c00 	call	821e6c0 <alt_avalon_sgdma_construct_stream_to_mem_desc>
 */
int tse_sgdma_read_init(ins_tse_info* tse_ptr)
{     
  alt_u32 *uncached_packet_payload;
  
  for(tse_ptr->chain_loop = 0; tse_ptr->chain_loop < ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE; tse_ptr->chain_loop++)
 8225484:	e0bffe17 	ldw	r2,-8(fp)
 8225488:	10800e17 	ldw	r2,56(r2)
 822548c:	10c00044 	addi	r3,r2,1
 8225490:	e0bffe17 	ldw	r2,-8(fp)
 8225494:	10c00e15 	stw	r3,56(r2)
 8225498:	e0bffe17 	ldw	r2,-8(fp)
 822549c:	10800e17 	ldw	r2,56(r2)
 82254a0:	00bfb90e 	bge	zero,r2,8225388 <tse_sgdma_read_init+0x24>
            0,                          // read until EOP
            0);                         // don't write to constant address

  } // for

  dprintf("[tse_sgdma_read_init] RX descriptor chain desc (%d depth) created\n", 
 82254a4:	e0bffe17 	ldw	r2,-8(fp)
 82254a8:	10800e17 	ldw	r2,56(r2)
 82254ac:	100b883a 	mov	r5,r2
 82254b0:	01020974 	movhi	r4,2085
 82254b4:	213fa304 	addi	r4,r4,-372
 82254b8:	82033fc0 	call	82033fc <printf>
    tse_ptr->chain_loop);
   
  tse_ptr->chain_loop = 0;
 82254bc:	e0bffe17 	ldw	r2,-8(fp)
 82254c0:	10000e15 	stw	zero,56(r2)
  tse_ptr->currdescriptor_ptr =  &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
 82254c4:	e0bffe17 	ldw	r2,-8(fp)
 82254c8:	10800f17 	ldw	r2,60(r2)
 82254cc:	10c01004 	addi	r3,r2,64
 82254d0:	e0bffe17 	ldw	r2,-8(fp)
 82254d4:	10c01015 	stw	r3,64(r2)

  tse_mac_aRxRead( &tse_ptr->mi, tse_ptr->currdescriptor_ptr);
 82254d8:	e0bffe17 	ldw	r2,-8(fp)
 82254dc:	10c00104 	addi	r3,r2,4
 82254e0:	e0bffe17 	ldw	r2,-8(fp)
 82254e4:	10801017 	ldw	r2,64(r2)
 82254e8:	100b883a 	mov	r5,r2
 82254ec:	1809883a 	mov	r4,r3
 82254f0:	821f3540 	call	821f354 <tse_mac_aRxRead>
  
  return SUCCESS;
 82254f4:	0005883a 	mov	r2,zero
}
 82254f8:	e6ffff04 	addi	sp,fp,-4
 82254fc:	dfc00217 	ldw	ra,8(sp)
 8225500:	df000117 	ldw	fp,4(sp)
 8225504:	dc000017 	ldw	r16,0(sp)
 8225508:	dec00304 	addi	sp,sp,12
 822550c:	f800283a 	ret

08225510 <tse_mac_rcv>:
 * @API TYPE        - callback internal function
 * @return SUCCESS on success
 */

ALT_INLINE void tse_mac_rcv(ins_tse_info* tse_ptr)
{     
 8225510:	defff704 	addi	sp,sp,-36
 8225514:	dfc00815 	stw	ra,32(sp)
 8225518:	df000715 	stw	fp,28(sp)
 822551c:	df000704 	addi	fp,sp,28
 8225520:	e13fff15 	stw	r4,-4(fp)
  PACKET rx_packet;
  alt_u32 *uncached_packet_payload;
  alt_u8 desc_status;

  tse_ptr->currdescriptor_ptr = 
    &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
 8225524:	e0bfff17 	ldw	r2,-4(fp)
 8225528:	10c00f17 	ldw	r3,60(r2)
 822552c:	e0bfff17 	ldw	r2,-4(fp)
 8225530:	10800e17 	ldw	r2,56(r2)
 8225534:	10800084 	addi	r2,r2,2
 8225538:	1004917a 	slli	r2,r2,5
 822553c:	1887883a 	add	r3,r3,r2
  PACKET replacement_pkt;
  PACKET rx_packet;
  alt_u32 *uncached_packet_payload;
  alt_u8 desc_status;

  tse_ptr->currdescriptor_ptr = 
 8225540:	e0bfff17 	ldw	r2,-4(fp)
 8225544:	10c01015 	stw	r3,64(r2)
    &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
  
  /* Grab status bits from descriptor under test. Bypass cache */
  desc_status = IORD_ALTERA_TSE_SGDMA_DESC_STATUS(tse_ptr->currdescriptor_ptr);
 8225548:	e0bfff17 	ldw	r2,-4(fp)
 822554c:	10801017 	ldw	r2,64(r2)
 8225550:	10800704 	addi	r2,r2,28
 8225554:	10800037 	ldwio	r2,0(r2)
 8225558:	1005d43a 	srai	r2,r2,16
 822555c:	e0bff905 	stb	r2,-28(fp)
  while ( desc_status & 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_TERMINATED_BY_EOP_MSK )
#endif
{      
    /* Correct frame length to actual (this is different from TX side) */
    pklen = IORD_16DIRECT(&tse_ptr->currdescriptor_ptr->actual_bytes_transferred, 0) - 2;
 8225560:	e0bfff17 	ldw	r2,-4(fp)
 8225564:	10801017 	ldw	r2,64(r2)
 8225568:	10800704 	addi	r2,r2,28
 822556c:	1080002b 	ldhuio	r2,0(r2)
 8225570:	10bfffcc 	andi	r2,r2,65535
 8225574:	10bfff84 	addi	r2,r2,-2
 8225578:	e0bffa15 	stw	r2,-24(fp)
    tse_ptr->netp->n_mib->ifInOctets += (u_long)pklen;
 822557c:	e0bfff17 	ldw	r2,-4(fp)
 8225580:	10800817 	ldw	r2,32(r2)
 8225584:	10802717 	ldw	r2,156(r2)
 8225588:	e0ffff17 	ldw	r3,-4(fp)
 822558c:	18c00817 	ldw	r3,32(r3)
 8225590:	18c02717 	ldw	r3,156(r3)
 8225594:	19000917 	ldw	r4,36(r3)
 8225598:	e0fffa17 	ldw	r3,-24(fp)
 822559c:	20c7883a 	add	r3,r4,r3
 82255a0:	10c00915 	stw	r3,36(r2)
  
    rx_packet = tse_ptr->pkt_array[tse_ptr->chain_loop];   
 82255a4:	e0bfff17 	ldw	r2,-4(fp)
 82255a8:	10800e17 	ldw	r2,56(r2)
 82255ac:	e0ffff17 	ldw	r3,-4(fp)
 82255b0:	10800444 	addi	r2,r2,17
 82255b4:	1085883a 	add	r2,r2,r2
 82255b8:	1085883a 	add	r2,r2,r2
 82255bc:	1885883a 	add	r2,r3,r2
 82255c0:	10800017 	ldw	r2,0(r2)
 82255c4:	e0bffb15 	stw	r2,-20(fp)
    
    rx_packet->nb_prot = rx_packet->nb_buff + ETHHDR_SIZE;
 82255c8:	e0bffb17 	ldw	r2,-20(fp)
 82255cc:	10800117 	ldw	r2,4(r2)
 82255d0:	10c00404 	addi	r3,r2,16
 82255d4:	e0bffb17 	ldw	r2,-20(fp)
 82255d8:	10c00315 	stw	r3,12(r2)
    rx_packet->nb_plen = pklen - 14;
 82255dc:	e0bffa17 	ldw	r2,-24(fp)
 82255e0:	10bffc84 	addi	r2,r2,-14
 82255e4:	1007883a 	mov	r3,r2
 82255e8:	e0bffb17 	ldw	r2,-20(fp)
 82255ec:	10c00415 	stw	r3,16(r2)
    rx_packet->nb_tstamp = cticks;
 82255f0:	d0a0a817 	ldw	r2,-32096(gp)
 82255f4:	1007883a 	mov	r3,r2
 82255f8:	e0bffb17 	ldw	r2,-20(fp)
 82255fc:	10c00515 	stw	r3,20(r2)
    rx_packet->net = tse_ptr->netp;
 8225600:	e0bfff17 	ldw	r2,-4(fp)
 8225604:	10c00817 	ldw	r3,32(r2)
 8225608:	e0bffb17 	ldw	r2,-20(fp)
 822560c:	10c00615 	stw	r3,24(r2)
    
    // set packet type for demux routine
    eth = (struct ethhdr *)(rx_packet->nb_buff + ETHHDR_BIAS);
 8225610:	e0bffb17 	ldw	r2,-20(fp)
 8225614:	10800117 	ldw	r2,4(r2)
 8225618:	10800084 	addi	r2,r2,2
 822561c:	e0bffc15 	stw	r2,-16(fp)
    rx_packet->type = eth->e_type;
 8225620:	e0bffc17 	ldw	r2,-16(fp)
 8225624:	10c0030b 	ldhu	r3,12(r2)
 8225628:	e0bffb17 	ldw	r2,-20(fp)
 822562c:	10c0080d 	sth	r3,32(r2)
    
    if( (desc_status & 
 8225630:	e0bff903 	ldbu	r2,-28(fp)
 8225634:	10801fcc 	andi	r2,r2,127
 8225638:	1000251e 	bne	r2,zero,82256d0 <tse_mac_rcv+0x1c0>
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) == 0)
    {
      replacement_pkt = pk_alloc(ALTERA_TSE_PKT_INIT_LEN + 4);
 822563c:	01017f04 	movi	r4,1532
 8225640:	822ca480 	call	822ca48 <pk_alloc>
 8225644:	e0bffd15 	stw	r2,-12(fp)
      if (!replacement_pkt) { /* couldn't get a free buffer for rx */
 8225648:	e0bffd17 	ldw	r2,-12(fp)
 822564c:	10000a1e 	bne	r2,zero,8225678 <tse_mac_rcv+0x168>
        dprintf("No free buffers for rx\n");
 8225650:	01020974 	movhi	r4,2085
 8225654:	213fb404 	addi	r4,r4,-304
 8225658:	82036800 	call	8203680 <puts>
        tse_ptr->netp->n_mib->ifInDiscards++;
 822565c:	e0bfff17 	ldw	r2,-4(fp)
 8225660:	10800817 	ldw	r2,32(r2)
 8225664:	10802717 	ldw	r2,156(r2)
 8225668:	10c00c17 	ldw	r3,48(r2)
 822566c:	18c00044 	addi	r3,r3,1
 8225670:	10c00c15 	stw	r3,48(r2)
 8225674:	00001906 	br	82256dc <tse_mac_rcv+0x1cc>
      }
      else {
        putq(&rcvdq, tse_ptr->pkt_array[tse_ptr->chain_loop]);
 8225678:	e0bfff17 	ldw	r2,-4(fp)
 822567c:	10800e17 	ldw	r2,56(r2)
 8225680:	e0ffff17 	ldw	r3,-4(fp)
 8225684:	10800444 	addi	r2,r2,17
 8225688:	1085883a 	add	r2,r2,r2
 822568c:	1085883a 	add	r2,r2,r2
 8225690:	1885883a 	add	r2,r3,r2
 8225694:	10800017 	ldw	r2,0(r2)
 8225698:	100b883a 	mov	r5,r2
 822569c:	010209b4 	movhi	r4,2086
 82256a0:	21377804 	addi	r4,r4,-8736
 82256a4:	822cfd80 	call	822cfd8 <putq>
        tse_ptr->pkt_array[tse_ptr->chain_loop] = replacement_pkt;
 82256a8:	e0bfff17 	ldw	r2,-4(fp)
 82256ac:	10800e17 	ldw	r2,56(r2)
 82256b0:	e0ffff17 	ldw	r3,-4(fp)
 82256b4:	10800444 	addi	r2,r2,17
 82256b8:	1085883a 	add	r2,r2,r2
 82256bc:	1085883a 	add	r2,r2,r2
 82256c0:	1885883a 	add	r2,r3,r2
 82256c4:	e0fffd17 	ldw	r3,-12(fp)
 82256c8:	10c00015 	stw	r3,0(r2)
 82256cc:	00000306 	br	82256dc <tse_mac_rcv+0x1cc>
      }
    } /* if(descriptor had no errors) */ 
    else {
      dprintf("RX descriptor reported error. packet dropped\n");
 82256d0:	01020974 	movhi	r4,2085
 82256d4:	213fba04 	addi	r4,r4,-280
 82256d8:	82036800 	call	8203680 <puts>
    }     
             
    uncached_packet_payload = (alt_u32 *)alt_remap_cached(tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);
 82256dc:	e0bfff17 	ldw	r2,-4(fp)
 82256e0:	10800e17 	ldw	r2,56(r2)
 82256e4:	e0ffff17 	ldw	r3,-4(fp)
 82256e8:	10800444 	addi	r2,r2,17
 82256ec:	1085883a 	add	r2,r2,r2
 82256f0:	1085883a 	add	r2,r2,r2
 82256f4:	1885883a 	add	r2,r3,r2
 82256f8:	10800017 	ldw	r2,0(r2)
 82256fc:	10800117 	ldw	r2,4(r2)
 8225700:	01400104 	movi	r5,4
 8225704:	1009883a 	mov	r4,r2
 8225708:	823c80c0 	call	823c80c <alt_remap_cached>
 822570c:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Re-cycle previously constructed SGDMA buffer directly rather
     * than calling the SGDMA utility routines. This saves some call/return
     * overhead and only does cache-bypass writes of what we need
     */
    IOWR_32DIRECT(&tse_ptr->currdescriptor_ptr->write_addr, 0, 
 8225710:	e0bfff17 	ldw	r2,-4(fp)
 8225714:	10801017 	ldw	r2,64(r2)
 8225718:	10800204 	addi	r2,r2,8
 822571c:	e0fffe17 	ldw	r3,-8(fp)
 8225720:	10c00035 	stwio	r3,0(r2)
     *   |31...24|23..16|15.....................0|
     *   |control|status|actual_bytes_transferred|
     * 
     * Set relevant control bits and ensure the rest are cleared.
     */
    IOWR_32DIRECT(&tse_ptr->currdescriptor_ptr->actual_bytes_transferred, 0, 
 8225724:	e0bfff17 	ldw	r2,-4(fp)
 8225728:	10801017 	ldw	r2,64(r2)
 822572c:	10800704 	addi	r2,r2,28
 8225730:	00e04034 	movhi	r3,33024
 8225734:	10c00035 	stwio	r3,0(r2)
    
    /* Grab next descriptor status */
    desc_status = IORD_ALTERA_TSE_SGDMA_DESC_STATUS(tse_ptr->currdescriptor_ptr);
#endif
  } /* while (descriptor terminated by EOP) */
} 
 8225738:	0001883a 	nop
 822573c:	e037883a 	mov	sp,fp
 8225740:	dfc00117 	ldw	ra,4(sp)
 8225744:	df000017 	ldw	fp,0(sp)
 8225748:	dec00204 	addi	sp,sp,8
 822574c:	f800283a 	ret

08225750 <tse_mac_stats>:

int tse_mac_stats(void * pio, int iface)
{
 8225750:	defffc04 	addi	sp,sp,-16
 8225754:	dfc00315 	stw	ra,12(sp)
 8225758:	df000215 	stw	fp,8(sp)
 822575c:	df000204 	addi	fp,sp,8
 8225760:	e13ffe15 	stw	r4,-8(fp)
 8225764:	e17fff15 	stw	r5,-4(fp)
   ns_printf(pio, "tse_mac_stats(), stats will be added later!\n");
 8225768:	01420974 	movhi	r5,2085
 822576c:	297fc604 	addi	r5,r5,-232
 8225770:	e13ffe17 	ldw	r4,-8(fp)
 8225774:	8228ebc0 	call	8228ebc <ns_printf>
   return SUCCESS;
 8225778:	0005883a 	mov	r2,zero
}
 822577c:	e037883a 	mov	sp,fp
 8225780:	dfc00117 	ldw	ra,4(sp)
 8225784:	df000017 	ldw	fp,0(sp)
 8225788:	dec00204 	addi	sp,sp,8
 822578c:	f800283a 	ret

08225790 <tse_mac_close>:
 * @API TYPE - Public
 * @param  iface    index of the NET interface associated with the TSE MAC.
 * @return SUCCESS
 */
int tse_mac_close(int iface)
{
 8225790:	defffc04 	addi	sp,sp,-16
 8225794:	dfc00315 	stw	ra,12(sp)
 8225798:	df000215 	stw	fp,8(sp)
 822579c:	df000204 	addi	fp,sp,8
 82257a0:	e13fff15 	stw	r4,-4(fp)
  int state;
   
  /* status = down */
  nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_DOWN;    
 82257a4:	008209b4 	movhi	r2,2086
 82257a8:	10b83d04 	addi	r2,r2,-7948
 82257ac:	e0ffff17 	ldw	r3,-4(fp)
 82257b0:	18c7883a 	add	r3,r3,r3
 82257b4:	18c7883a 	add	r3,r3,r3
 82257b8:	10c5883a 	add	r2,r2,r3
 82257bc:	10800017 	ldw	r2,0(r2)
 82257c0:	10802717 	ldw	r2,156(r2)
 82257c4:	00c00084 	movi	r3,2
 82257c8:	10c00615 	stw	r3,24(r2)

  /* disable the interrupt in the OS*/
  alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma, 0, 0, 0);
 82257cc:	008209b4 	movhi	r2,2086
 82257d0:	10b72c04 	addi	r2,r2,-9040
 82257d4:	e0ffff17 	ldw	r3,-4(fp)
 82257d8:	18c01324 	muli	r3,r3,76
 82257dc:	10c5883a 	add	r2,r2,r3
 82257e0:	10800304 	addi	r2,r2,12
 82257e4:	10800017 	ldw	r2,0(r2)
 82257e8:	000f883a 	mov	r7,zero
 82257ec:	000d883a 	mov	r6,zero
 82257f0:	000b883a 	mov	r5,zero
 82257f4:	1009883a 	mov	r4,r2
 82257f8:	821e8a40 	call	821e8a4 <alt_avalon_sgdma_register_callback>
   
  /* Disable Receive path on the device*/
  state = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
 82257fc:	008209b4 	movhi	r2,2086
 8225800:	10b72c04 	addi	r2,r2,-9040
 8225804:	e0ffff17 	ldw	r3,-4(fp)
 8225808:	18c01324 	muli	r3,r3,76
 822580c:	10c5883a 	add	r2,r2,r3
 8225810:	10800104 	addi	r2,r2,4
 8225814:	10800017 	ldw	r2,0(r2)
 8225818:	10800204 	addi	r2,r2,8
 822581c:	10800037 	ldwio	r2,0(r2)
 8225820:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,state & ~ALTERA_TSEMAC_CMD_RX_ENA_MSK); 
 8225824:	008209b4 	movhi	r2,2086
 8225828:	10b72c04 	addi	r2,r2,-9040
 822582c:	e0ffff17 	ldw	r3,-4(fp)
 8225830:	18c01324 	muli	r3,r3,76
 8225834:	10c5883a 	add	r2,r2,r3
 8225838:	10800104 	addi	r2,r2,4
 822583c:	10800017 	ldw	r2,0(r2)
 8225840:	10800204 	addi	r2,r2,8
 8225844:	e13ffe17 	ldw	r4,-8(fp)
 8225848:	00ffff44 	movi	r3,-3
 822584c:	20c6703a 	and	r3,r4,r3
 8225850:	10c00035 	stwio	r3,0(r2)
  
  /* status = down */                                     
  nets[iface]->n_mib->ifOperStatus = ALTERA_TSE_ADMIN_STATUS_DOWN;     
 8225854:	008209b4 	movhi	r2,2086
 8225858:	10b83d04 	addi	r2,r2,-7948
 822585c:	e0ffff17 	ldw	r3,-4(fp)
 8225860:	18c7883a 	add	r3,r3,r3
 8225864:	18c7883a 	add	r3,r3,r3
 8225868:	10c5883a 	add	r2,r2,r3
 822586c:	10800017 	ldw	r2,0(r2)
 8225870:	10802717 	ldw	r2,156(r2)
 8225874:	00c00084 	movi	r3,2
 8225878:	10c00715 	stw	r3,28(r2)

  return SUCCESS;
 822587c:	0005883a 	mov	r2,zero
}
 8225880:	e037883a 	mov	sp,fp
 8225884:	dfc00117 	ldw	ra,4(sp)
 8225888:	df000017 	ldw	fp,0(sp)
 822588c:	dec00204 	addi	sp,sp,8
 8225890:	f800283a 	ret

08225894 <close>:
 * (for files and device drivers) or the InterNiche soclose() function for
 * sockets.
 */
 
int close (int fd)
{
 8225894:	defffd04 	addi	sp,sp,-12
 8225898:	dfc00215 	stw	ra,8(sp)
 822589c:	df000115 	stw	fp,4(sp)
 82258a0:	df000104 	addi	fp,sp,4
 82258a4:	e13fff15 	stw	r4,-4(fp)
  return (fd < ALT_MAX_FD) ? alt_close (fd) : t_socketclose ((long) fd);
 82258a8:	e0bfff17 	ldw	r2,-4(fp)
 82258ac:	10800808 	cmpgei	r2,r2,32
 82258b0:	1000031e 	bne	r2,zero,82258c0 <close+0x2c>
 82258b4:	e13fff17 	ldw	r4,-4(fp)
 82258b8:	823bc980 	call	823bc98 <alt_close>
 82258bc:	00000206 	br	82258c8 <close+0x34>
 82258c0:	e13fff17 	ldw	r4,-4(fp)
 82258c4:	82318a80 	call	82318a8 <t_socketclose>
}
 82258c8:	e037883a 	mov	sp,fp
 82258cc:	dfc00117 	ldw	ra,4(sp)
 82258d0:	df000017 	ldw	fp,0(sp)
 82258d4:	dec00204 	addi	sp,sp,8
 82258d8:	f800283a 	ret

082258dc <iniche_devices_init>:
 * total number of interfaces after initialization.
 */

int iniche_devices_init(
    int                         if_count)
{
 82258dc:	defff504 	addi	sp,sp,-44
 82258e0:	dfc00a15 	stw	ra,40(sp)
 82258e4:	df000915 	stw	fp,36(sp)
 82258e8:	df000904 	addi	fp,sp,36
 82258ec:	e13fff15 	stw	r4,-4(fp)
                                netmask,
                                gw;
    int                         use_dhcp;

    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
 82258f0:	d0a02e17 	ldw	r2,-32584(gp)
 82258f4:	e0bff815 	stw	r2,-32(fp)
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));
 82258f8:	d0a02e04 	addi	r2,gp,-32584
 82258fc:	e0bff915 	stw	r2,-28(fp)

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 8225900:	00003f06 	br	8225a00 <iniche_devices_init+0x124>
    {
        /* Initialize the InterNiche device data record. */
        p_dev->p_driver_data = p_dev;
 8225904:	e0bff817 	ldw	r2,-32(fp)
 8225908:	e0fff817 	ldw	r3,-32(fp)
 822590c:	10c00415 	stw	r3,16(r2)
        p_dev->if_num = if_count;
 8225910:	e0bff817 	ldw	r2,-32(fp)
 8225914:	e0ffff17 	ldw	r3,-4(fp)
 8225918:	10c00515 	stw	r3,20(r2)
        p_dev->p_net = nets[p_dev->if_num];
 822591c:	e0bff817 	ldw	r2,-32(fp)
 8225920:	10c00517 	ldw	r3,20(r2)
 8225924:	008209b4 	movhi	r2,2086
 8225928:	10b83d04 	addi	r2,r2,-7948
 822592c:	18c7883a 	add	r3,r3,r3
 8225930:	18c7883a 	add	r3,r3,r3
 8225934:	10c5883a 	add	r2,r2,r3
 8225938:	10c00017 	ldw	r3,0(r2)
 822593c:	e0bff817 	ldw	r2,-32(fp)
 8225940:	10c00615 	stw	r3,24(r2)

        /* Perform device specific initialization. */
        (*(p_dev->init_func))(p_dev);
 8225944:	e0bff817 	ldw	r2,-32(fp)
 8225948:	10800317 	ldw	r2,12(r2)
 822594c:	e13ff817 	ldw	r4,-32(fp)
 8225950:	103ee83a 	callr	r2

        /* Get the interface IP address. */
        p_net = p_dev->p_net;
 8225954:	e0bff817 	ldw	r2,-32(fp)
 8225958:	10800617 	ldw	r2,24(r2)
 822595c:	e0bffa15 	stw	r2,-24(fp)
                
        if (get_ip_addr(p_dev, &ipaddr, &netmask, &gw, &use_dhcp))
 8225960:	e17ffd04 	addi	r5,fp,-12
 8225964:	e13ffc04 	addi	r4,fp,-16
 8225968:	e0fffb04 	addi	r3,fp,-20
 822596c:	e0bffe04 	addi	r2,fp,-8
 8225970:	d8800015 	stw	r2,0(sp)
 8225974:	280f883a 	mov	r7,r5
 8225978:	200d883a 	mov	r6,r4
 822597c:	180b883a 	mov	r5,r3
 8225980:	e13ff817 	ldw	r4,-32(fp)
 8225984:	82011180 	call	8201118 <get_ip_addr>
 8225988:	10001726 	beq	r2,zero,82259e8 <iniche_devices_init+0x10c>
            /* 
             * OR in the DHCP flag, if enabled. This will allow any
             * application-specific flag setting in get_ip_addr(), such 
             * as enabling AUTOIP, to occur 
             */
            if (use_dhcp) {
 822598c:	e0bffe17 	ldw	r2,-8(fp)
 8225990:	10000526 	beq	r2,zero,82259a8 <iniche_devices_init+0xcc>
                p_net->n_flags |= NF_DHCPC;
 8225994:	e0bffa17 	ldw	r2,-24(fp)
 8225998:	10802a17 	ldw	r2,168(r2)
 822599c:	10c04014 	ori	r3,r2,256
 82259a0:	e0bffa17 	ldw	r2,-24(fp)
 82259a4:	10c02a15 	stw	r3,168(r2)
            }
#endif
            p_net->n_ipaddr = ipaddr;
 82259a8:	e0fffb17 	ldw	r3,-20(fp)
 82259ac:	e0bffa17 	ldw	r2,-24(fp)
 82259b0:	10c00a15 	stw	r3,40(r2)
            p_net->snmask = netmask;
 82259b4:	e0fffc17 	ldw	r3,-16(fp)
 82259b8:	e0bffa17 	ldw	r2,-24(fp)
 82259bc:	10c00c15 	stw	r3,48(r2)
            p_net->n_defgw = gw;
 82259c0:	e0fffd17 	ldw	r3,-12(fp)
 82259c4:	e0bffa17 	ldw	r2,-24(fp)
 82259c8:	10c00d15 	stw	r3,52(r2)
#ifdef IP_MULTICAST
	    p_net->n_mcastlist = mcastlist;
 82259cc:	e0fffa17 	ldw	r3,-24(fp)
 82259d0:	00820934 	movhi	r2,2084
 82259d4:	10b4fc04 	addi	r2,r2,-11280
 82259d8:	18802b15 	stw	r2,172(r3)
#if defined (IGMP_V1) || defined (IGMP_V2)
            p_net->igmp_oper_mode = IGMP_MODE_DEFAULT;
 82259dc:	e0bffa17 	ldw	r2,-24(fp)
 82259e0:	00c00084 	movi	r3,2
 82259e4:	10c02f05 	stb	r3,188(r2)
#endif  /* IGMPv1 or IGMPv2 */
#endif  /* IP_MULTICAST */
        }

        /* Initialize next device. */
        if_count++;
 82259e8:	e0bfff17 	ldw	r2,-4(fp)
 82259ec:	10800044 	addi	r2,r2,1
 82259f0:	e0bfff15 	stw	r2,-4(fp)
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
 82259f4:	e0bff817 	ldw	r2,-32(fp)
 82259f8:	10800017 	ldw	r2,0(r2)
 82259fc:	e0bff815 	stw	r2,-32(fp)
    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 8225a00:	e0fff817 	ldw	r3,-32(fp)
 8225a04:	e0bff917 	ldw	r2,-28(fp)
 8225a08:	18bfbe1e 	bne	r3,r2,8225904 <iniche_devices_init+0x28>
        /* Initialize next device. */
        if_count++;
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
    }

    return (if_count);
 8225a0c:	e0bfff17 	ldw	r2,-4(fp)
}
 8225a10:	e037883a 	mov	sp,fp
 8225a14:	dfc00117 	ldw	ra,4(sp)
 8225a18:	df000017 	ldw	fp,0(sp)
 8225a1c:	dec00204 	addi	sp,sp,8
 8225a20:	f800283a 	ret

08225a24 <read>:
 * (for files and device drivers) or the InterNiche recvfrom() function for
 * sockets.
 */

int read (int fd, void *ptr, size_t len)
{
 8225a24:	defff904 	addi	sp,sp,-28
 8225a28:	dfc00615 	stw	ra,24(sp)
 8225a2c:	df000515 	stw	fp,20(sp)
 8225a30:	df000504 	addi	fp,sp,20
 8225a34:	e13ffd15 	stw	r4,-12(fp)
 8225a38:	e17ffe15 	stw	r5,-8(fp)
 8225a3c:	e1bfff15 	stw	r6,-4(fp)
  return (fd < ALT_MAX_FD) ? alt_read (fd, ptr, len)
                           : recvfrom(fd, ptr, len, 0, NULL, NULL);
 8225a40:	e0bffd17 	ldw	r2,-12(fp)
 8225a44:	10800808 	cmpgei	r2,r2,32
 8225a48:	1000051e 	bne	r2,zero,8225a60 <read+0x3c>
 8225a4c:	e1bfff17 	ldw	r6,-4(fp)
 8225a50:	e17ffe17 	ldw	r5,-8(fp)
 8225a54:	e13ffd17 	ldw	r4,-12(fp)
 8225a58:	823c6ac0 	call	823c6ac <alt_read>
 * sockets.
 */

int read (int fd, void *ptr, size_t len)
{
  return (fd < ALT_MAX_FD) ? alt_read (fd, ptr, len)
 8225a5c:	00000806 	br	8225a80 <read+0x5c>
                           : recvfrom(fd, ptr, len, 0, NULL, NULL);
 8225a60:	e0bfff17 	ldw	r2,-4(fp)
 8225a64:	d8000115 	stw	zero,4(sp)
 8225a68:	d8000015 	stw	zero,0(sp)
 8225a6c:	000f883a 	mov	r7,zero
 8225a70:	100d883a 	mov	r6,r2
 8225a74:	e17ffe17 	ldw	r5,-8(fp)
 8225a78:	e13ffd17 	ldw	r4,-12(fp)
 8225a7c:	82283c00 	call	82283c0 <bsd_recvfrom>
}
 8225a80:	e037883a 	mov	sp,fp
 8225a84:	dfc00117 	ldw	ra,4(sp)
 8225a88:	df000017 	ldw	fp,0(sp)
 8225a8c:	dec00204 	addi	sp,sp,8
 8225a90:	f800283a 	ret

08225a94 <write>:
 * This implementation vectors requests to either the HAL alt_write() function 
 * (for files and device drivers) or the InterNiche send() function for sockets.
 */

int write (int fd, const void *ptr, size_t len)
{
 8225a94:	defffb04 	addi	sp,sp,-20
 8225a98:	dfc00415 	stw	ra,16(sp)
 8225a9c:	df000315 	stw	fp,12(sp)
 8225aa0:	df000304 	addi	fp,sp,12
 8225aa4:	e13ffd15 	stw	r4,-12(fp)
 8225aa8:	e17ffe15 	stw	r5,-8(fp)
 8225aac:	e1bfff15 	stw	r6,-4(fp)
  if (fd < ALT_MAX_FD)
 8225ab0:	e0bffd17 	ldw	r2,-12(fp)
 8225ab4:	10800808 	cmpgei	r2,r2,32
 8225ab8:	1000051e 	bne	r2,zero,8225ad0 <write+0x3c>
  {
    return alt_write (fd, ptr, len);
 8225abc:	e1bfff17 	ldw	r6,-4(fp)
 8225ac0:	e17ffe17 	ldw	r5,-8(fp)
 8225ac4:	e13ffd17 	ldw	r4,-12(fp)
 8225ac8:	823cbf40 	call	823cbf4 <alt_write>
 8225acc:	00000606 	br	8225ae8 <write+0x54>
  }
  else
  { 
    return send (fd, (void*) ptr, len, 0);
 8225ad0:	e0bfff17 	ldw	r2,-4(fp)
 8225ad4:	000f883a 	mov	r7,zero
 8225ad8:	100d883a 	mov	r6,r2
 8225adc:	e17ffe17 	ldw	r5,-8(fp)
 8225ae0:	e13ffd17 	ldw	r4,-12(fp)
 8225ae4:	82315cc0 	call	82315cc <t_send>
  }  
}
 8225ae8:	e037883a 	mov	sp,fp
 8225aec:	dfc00117 	ldw	ra,4(sp)
 8225af0:	df000017 	ldw	fp,0(sp)
 8225af4:	dec00204 	addi	sp,sp,8
 8225af8:	f800283a 	ret

08225afc <Netinit>:
 * a non-zero error code
 */

int
Netinit()
{
 8225afc:	defffc04 	addi	sp,sp,-16
 8225b00:	dfc00315 	stw	ra,12(sp)
 8225b04:	df000215 	stw	fp,8(sp)
 8225b08:	df000204 	addi	fp,sp,8
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 8225b0c:	e03ffe15 	stw	zero,-8(fp)
 8225b10:	00004a06 	br	8225c3c <Netinit+0x140>
   {
      /* sanity check on mtu, et.al. We added this because earlier 
       * drivers were sloppy about setting them, but new
       * logic depends on these sizes.
       */
      if (nets[i]->n_mib->ifType == ETHERNET)   /* ethernet? */
 8225b14:	008209b4 	movhi	r2,2086
 8225b18:	10b83d04 	addi	r2,r2,-7948
 8225b1c:	e0fffe17 	ldw	r3,-8(fp)
 8225b20:	18c7883a 	add	r3,r3,r3
 8225b24:	18c7883a 	add	r3,r3,r3
 8225b28:	10c5883a 	add	r2,r2,r3
 8225b2c:	10800017 	ldw	r2,0(r2)
 8225b30:	10802717 	ldw	r2,156(r2)
 8225b34:	10800217 	ldw	r2,8(r2)
 8225b38:	10800198 	cmpnei	r2,r2,6
 8225b3c:	1000241e 	bne	r2,zero,8225bd0 <Netinit+0xd4>
      {
         if (nets[i]->n_mtu == 0)   /* let device code override */
 8225b40:	008209b4 	movhi	r2,2086
 8225b44:	10b83d04 	addi	r2,r2,-7948
 8225b48:	e0fffe17 	ldw	r3,-8(fp)
 8225b4c:	18c7883a 	add	r3,r3,r3
 8225b50:	18c7883a 	add	r3,r3,r3
 8225b54:	10c5883a 	add	r2,r2,r3
 8225b58:	10800017 	ldw	r2,0(r2)
 8225b5c:	10800917 	ldw	r2,36(r2)
 8225b60:	1000091e 	bne	r2,zero,8225b88 <Netinit+0x8c>
            nets[i]->n_mtu = 1514;
 8225b64:	008209b4 	movhi	r2,2086
 8225b68:	10b83d04 	addi	r2,r2,-7948
 8225b6c:	e0fffe17 	ldw	r3,-8(fp)
 8225b70:	18c7883a 	add	r3,r3,r3
 8225b74:	18c7883a 	add	r3,r3,r3
 8225b78:	10c5883a 	add	r2,r2,r3
 8225b7c:	10800017 	ldw	r2,0(r2)
 8225b80:	00c17a84 	movi	r3,1514
 8225b84:	10c00915 	stw	r3,36(r2)

         if (nets[i]->n_lnh == 0)
 8225b88:	008209b4 	movhi	r2,2086
 8225b8c:	10b83d04 	addi	r2,r2,-7948
 8225b90:	e0fffe17 	ldw	r3,-8(fp)
 8225b94:	18c7883a 	add	r3,r3,r3
 8225b98:	18c7883a 	add	r3,r3,r3
 8225b9c:	10c5883a 	add	r2,r2,r3
 8225ba0:	10800017 	ldw	r2,0(r2)
 8225ba4:	10800817 	ldw	r2,32(r2)
 8225ba8:	1000091e 	bne	r2,zero,8225bd0 <Netinit+0xd4>
         {
#ifdef IEEE_802_3
            nets[i]->n_lnh = ETHHDR_SIZE + sizeof(struct snap_hdr);
#else
            nets[i]->n_lnh = ETHHDR_SIZE;
 8225bac:	008209b4 	movhi	r2,2086
 8225bb0:	10b83d04 	addi	r2,r2,-7948
 8225bb4:	e0fffe17 	ldw	r3,-8(fp)
 8225bb8:	18c7883a 	add	r3,r3,r3
 8225bbc:	18c7883a 	add	r3,r3,r3
 8225bc0:	10c5883a 	add	r2,r2,r3
 8225bc4:	10800017 	ldw	r2,0(r2)
 8225bc8:	00c00404 	movi	r3,16
 8225bcc:	10c00815 	stw	r3,32(r2)
      {
         continue;
      }
#endif   /* IP_V6 */

      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
 8225bd0:	008209b4 	movhi	r2,2086
 8225bd4:	10b83d04 	addi	r2,r2,-7948
 8225bd8:	e0fffe17 	ldw	r3,-8(fp)
 8225bdc:	18c7883a 	add	r3,r3,r3
 8225be0:	18c7883a 	add	r3,r3,r3
 8225be4:	10c5883a 	add	r2,r2,r3
 8225be8:	10800017 	ldw	r2,0(r2)
 8225bec:	10800817 	ldw	r2,32(r2)
 8225bf0:	d0e08117 	ldw	r3,-32252(gp)
 8225bf4:	10c0010e 	bge	r2,r3,8225bfc <Netinit+0x100>
 8225bf8:	1805883a 	mov	r2,r3
 8225bfc:	d0a08115 	stw	r2,-32252(gp)
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
 8225c00:	008209b4 	movhi	r2,2086
 8225c04:	10b83d04 	addi	r2,r2,-7948
 8225c08:	e0fffe17 	ldw	r3,-8(fp)
 8225c0c:	18c7883a 	add	r3,r3,r3
 8225c10:	18c7883a 	add	r3,r3,r3
 8225c14:	10c5883a 	add	r2,r2,r3
 8225c18:	10800017 	ldw	r2,0(r2)
 8225c1c:	10800917 	ldw	r2,36(r2)
 8225c20:	d0e08217 	ldw	r3,-32248(gp)
 8225c24:	10c0010e 	bge	r2,r3,8225c2c <Netinit+0x130>
 8225c28:	1805883a 	mov	r2,r3
 8225c2c:	d0a08215 	stw	r2,-32248(gp)
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 8225c30:	e0bffe17 	ldw	r2,-8(fp)
 8225c34:	10800044 	addi	r2,r2,1
 8225c38:	e0bffe15 	stw	r2,-8(fp)
 8225c3c:	d0a08417 	ldw	r2,-32240(gp)
 8225c40:	1007883a 	mov	r3,r2
 8225c44:	e0bffe17 	ldw	r2,-8(fp)
 8225c48:	10ffb216 	blt	r2,r3,8225b14 <Netinit+0x18>
      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
   }

   /* set up the received packet queue */
   rcvdq.q_head = rcvdq.q_tail = NULL;
 8225c4c:	008209b4 	movhi	r2,2086
 8225c50:	10b77804 	addi	r2,r2,-8736
 8225c54:	10000115 	stw	zero,4(r2)
 8225c58:	008209b4 	movhi	r2,2086
 8225c5c:	10b77804 	addi	r2,r2,-8736
 8225c60:	10c00117 	ldw	r3,4(r2)
 8225c64:	008209b4 	movhi	r2,2086
 8225c68:	10b77804 	addi	r2,r2,-8736
 8225c6c:	10c00015 	stw	r3,0(r2)
   rcvdq.q_max = rcvdq.q_min = rcvdq.q_len = 0;
 8225c70:	008209b4 	movhi	r2,2086
 8225c74:	10b77804 	addi	r2,r2,-8736
 8225c78:	10000215 	stw	zero,8(r2)
 8225c7c:	008209b4 	movhi	r2,2086
 8225c80:	10b77804 	addi	r2,r2,-8736
 8225c84:	10c00217 	ldw	r3,8(r2)
 8225c88:	008209b4 	movhi	r2,2086
 8225c8c:	10b77804 	addi	r2,r2,-8736
 8225c90:	10c00415 	stw	r3,16(r2)
 8225c94:	008209b4 	movhi	r2,2086
 8225c98:	10b77804 	addi	r2,r2,-8736
 8225c9c:	10c00417 	ldw	r3,16(r2)
 8225ca0:	008209b4 	movhi	r2,2086
 8225ca4:	10b77804 	addi	r2,r2,-8736
 8225ca8:	10c00315 	stw	r3,12(r2)

   /* initialize freeq */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8225cac:	01000084 	movi	r4,2
 8225cb0:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   e = pk_init();
 8225cb4:	822c7ac0 	call	822c7ac <pk_init>
 8225cb8:	e0bfff15 	stw	r2,-4(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8225cbc:	01000084 	movi	r4,2
 8225cc0:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   if (e)   /* report error (memory ran out?) */
 8225cc4:	e0bfff17 	ldw	r2,-4(fp)
 8225cc8:	10000226 	beq	r2,zero,8225cd4 <Netinit+0x1d8>
      return e;
 8225ccc:	e0bfff17 	ldw	r2,-4(fp)
 8225cd0:	0000ff06 	br	82260d0 <Netinit+0x5d4>

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */
 8225cd4:	010208b4 	movhi	r4,2082
 8225cd8:	21188f04 	addi	r4,r4,25148
 8225cdc:	8226b840 	call	8226b84 <exit_hook>

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 8225ce0:	e03ffe15 	stw	zero,-8(fp)
 8225ce4:	0000f506 	br	82260bc <Netinit+0x5c0>
   {
      if (nets[i]->n_init != NULL)  /* If iface has init routine... */
 8225ce8:	008209b4 	movhi	r2,2086
 8225cec:	10b83d04 	addi	r2,r2,-7948
 8225cf0:	e0fffe17 	ldw	r3,-8(fp)
 8225cf4:	18c7883a 	add	r3,r3,r3
 8225cf8:	18c7883a 	add	r3,r3,r3
 8225cfc:	10c5883a 	add	r2,r2,r3
 8225d00:	10800017 	ldw	r2,0(r2)
 8225d04:	10800217 	ldw	r2,8(r2)
 8225d08:	10009126 	beq	r2,zero,8225f50 <Netinit+0x454>
      {
         if ((e = (*nets[i]->n_init)(i)) != 0)  /* call init routine */
 8225d0c:	008209b4 	movhi	r2,2086
 8225d10:	10b83d04 	addi	r2,r2,-7948
 8225d14:	e0fffe17 	ldw	r3,-8(fp)
 8225d18:	18c7883a 	add	r3,r3,r3
 8225d1c:	18c7883a 	add	r3,r3,r3
 8225d20:	10c5883a 	add	r2,r2,r3
 8225d24:	10800017 	ldw	r2,0(r2)
 8225d28:	10800217 	ldw	r2,8(r2)
 8225d2c:	e13ffe17 	ldw	r4,-8(fp)
 8225d30:	103ee83a 	callr	r2
 8225d34:	e0bfff15 	stw	r2,-4(fp)
 8225d38:	e0bfff17 	ldw	r2,-4(fp)
 8225d3c:	10001026 	beq	r2,zero,8225d80 <Netinit+0x284>
         {
            dprintf("init error %d on net[%d]\n", e, i);
 8225d40:	e1bffe17 	ldw	r6,-8(fp)
 8225d44:	e17fff17 	ldw	r5,-4(fp)
 8225d48:	01020974 	movhi	r4,2085
 8225d4c:	213fd204 	addi	r4,r4,-184
 8225d50:	82033fc0 	call	82033fc <printf>
            nets[i]->n_mib->ifOperStatus = NI_DOWN;
 8225d54:	008209b4 	movhi	r2,2086
 8225d58:	10b83d04 	addi	r2,r2,-7948
 8225d5c:	e0fffe17 	ldw	r3,-8(fp)
 8225d60:	18c7883a 	add	r3,r3,r3
 8225d64:	18c7883a 	add	r3,r3,r3
 8225d68:	10c5883a 	add	r2,r2,r3
 8225d6c:	10800017 	ldw	r2,0(r2)
 8225d70:	10802717 	ldw	r2,156(r2)
 8225d74:	00c00084 	movi	r3,2
 8225d78:	10c00715 	stw	r3,28(r2)
            continue;   /* ignore ifaces which fail */
 8225d7c:	0000cc06 	br	82260b0 <Netinit+0x5b4>
         }
         /* If interface is ethernet, set bcast flag bit. This
          * should really be done by the init routine, but we handle it
          * here to support MAC drivers which predate the flags field.
          */
         if(nets[i]->n_mib->ifType == ETHERNET)
 8225d80:	008209b4 	movhi	r2,2086
 8225d84:	10b83d04 	addi	r2,r2,-7948
 8225d88:	e0fffe17 	ldw	r3,-8(fp)
 8225d8c:	18c7883a 	add	r3,r3,r3
 8225d90:	18c7883a 	add	r3,r3,r3
 8225d94:	10c5883a 	add	r2,r2,r3
 8225d98:	10800017 	ldw	r2,0(r2)
 8225d9c:	10802717 	ldw	r2,156(r2)
 8225da0:	10800217 	ldw	r2,8(r2)
 8225da4:	10800198 	cmpnei	r2,r2,6
 8225da8:	1000111e 	bne	r2,zero,8225df0 <Netinit+0x2f4>
            nets[i]->n_flags |= NF_BCAST;
 8225dac:	008209b4 	movhi	r2,2086
 8225db0:	10b83d04 	addi	r2,r2,-7948
 8225db4:	e0fffe17 	ldw	r3,-8(fp)
 8225db8:	18c7883a 	add	r3,r3,r3
 8225dbc:	18c7883a 	add	r3,r3,r3
 8225dc0:	10c5883a 	add	r2,r2,r3
 8225dc4:	11000017 	ldw	r4,0(r2)
 8225dc8:	008209b4 	movhi	r2,2086
 8225dcc:	10b83d04 	addi	r2,r2,-7948
 8225dd0:	e0fffe17 	ldw	r3,-8(fp)
 8225dd4:	18c7883a 	add	r3,r3,r3
 8225dd8:	18c7883a 	add	r3,r3,r3
 8225ddc:	10c5883a 	add	r2,r2,r3
 8225de0:	10800017 	ldw	r2,0(r2)
 8225de4:	10802a17 	ldw	r2,168(r2)
 8225de8:	10800054 	ori	r2,r2,1
 8225dec:	20802a15 	stw	r2,168(r4)

         /* set ifAdminStatus in case init() routine forgot to. IfOperStatus
          * is not nessecarily up at this point, as in the case of a modem which
          * is now in autoanswer mode.
          */
         nets[i]->n_mib->ifAdminStatus = NI_UP;
 8225df0:	008209b4 	movhi	r2,2086
 8225df4:	10b83d04 	addi	r2,r2,-7948
 8225df8:	e0fffe17 	ldw	r3,-8(fp)
 8225dfc:	18c7883a 	add	r3,r3,r3
 8225e00:	18c7883a 	add	r3,r3,r3
 8225e04:	10c5883a 	add	r2,r2,r3
 8225e08:	10800017 	ldw	r2,0(r2)
 8225e0c:	10802717 	ldw	r2,156(r2)
 8225e10:	00c00044 	movi	r3,1
 8225e14:	10c00615 	stw	r3,24(r2)

         /* assign default names to unnamed ifaces */
         if(nets[i]->name[0] == 0)     /* no name set by prep or init */
 8225e18:	008209b4 	movhi	r2,2086
 8225e1c:	10b83d04 	addi	r2,r2,-7948
 8225e20:	e0fffe17 	ldw	r3,-8(fp)
 8225e24:	18c7883a 	add	r3,r3,r3
 8225e28:	18c7883a 	add	r3,r3,r3
 8225e2c:	10c5883a 	add	r2,r2,r3
 8225e30:	10800017 	ldw	r2,0(r2)
 8225e34:	10800103 	ldbu	r2,4(r2)
 8225e38:	10803fcc 	andi	r2,r2,255
 8225e3c:	1080201c 	xori	r2,r2,128
 8225e40:	10bfe004 	addi	r2,r2,-128
 8225e44:	1000421e 	bne	r2,zero,8225f50 <Netinit+0x454>
         {
            if(nets[i]->n_mib->ifType == ETHERNET)
 8225e48:	008209b4 	movhi	r2,2086
 8225e4c:	10b83d04 	addi	r2,r2,-7948
 8225e50:	e0fffe17 	ldw	r3,-8(fp)
 8225e54:	18c7883a 	add	r3,r3,r3
 8225e58:	18c7883a 	add	r3,r3,r3
 8225e5c:	10c5883a 	add	r2,r2,r3
 8225e60:	10800017 	ldw	r2,0(r2)
 8225e64:	10802717 	ldw	r2,156(r2)
 8225e68:	10800217 	ldw	r2,8(r2)
 8225e6c:	10800198 	cmpnei	r2,r2,6
 8225e70:	1000131e 	bne	r2,zero,8225ec0 <Netinit+0x3c4>
            {
               nets[i]->name[0] = 'e';    /* "et1", "et2", etc. */
 8225e74:	008209b4 	movhi	r2,2086
 8225e78:	10b83d04 	addi	r2,r2,-7948
 8225e7c:	e0fffe17 	ldw	r3,-8(fp)
 8225e80:	18c7883a 	add	r3,r3,r3
 8225e84:	18c7883a 	add	r3,r3,r3
 8225e88:	10c5883a 	add	r2,r2,r3
 8225e8c:	10800017 	ldw	r2,0(r2)
 8225e90:	00c01944 	movi	r3,101
 8225e94:	10c00105 	stb	r3,4(r2)
               nets[i]->name[1] = 't';
 8225e98:	008209b4 	movhi	r2,2086
 8225e9c:	10b83d04 	addi	r2,r2,-7948
 8225ea0:	e0fffe17 	ldw	r3,-8(fp)
 8225ea4:	18c7883a 	add	r3,r3,r3
 8225ea8:	18c7883a 	add	r3,r3,r3
 8225eac:	10c5883a 	add	r2,r2,r3
 8225eb0:	10800017 	ldw	r2,0(r2)
 8225eb4:	00c01d04 	movi	r3,116
 8225eb8:	10c00145 	stb	r3,5(r2)
 8225ebc:	00001206 	br	8225f08 <Netinit+0x40c>
            }
            else
            {
               nets[i]->name[0] = 'i';    /* "if1", "if2", etc. */
 8225ec0:	008209b4 	movhi	r2,2086
 8225ec4:	10b83d04 	addi	r2,r2,-7948
 8225ec8:	e0fffe17 	ldw	r3,-8(fp)
 8225ecc:	18c7883a 	add	r3,r3,r3
 8225ed0:	18c7883a 	add	r3,r3,r3
 8225ed4:	10c5883a 	add	r2,r2,r3
 8225ed8:	10800017 	ldw	r2,0(r2)
 8225edc:	00c01a44 	movi	r3,105
 8225ee0:	10c00105 	stb	r3,4(r2)
               nets[i]->name[1] = 'f';
 8225ee4:	008209b4 	movhi	r2,2086
 8225ee8:	10b83d04 	addi	r2,r2,-7948
 8225eec:	e0fffe17 	ldw	r3,-8(fp)
 8225ef0:	18c7883a 	add	r3,r3,r3
 8225ef4:	18c7883a 	add	r3,r3,r3
 8225ef8:	10c5883a 	add	r2,r2,r3
 8225efc:	10800017 	ldw	r2,0(r2)
 8225f00:	00c01984 	movi	r3,102
 8225f04:	10c00145 	stb	r3,5(r2)
            }
            nets[i]->name[2] = (char)(i + '1');
 8225f08:	008209b4 	movhi	r2,2086
 8225f0c:	10b83d04 	addi	r2,r2,-7948
 8225f10:	e0fffe17 	ldw	r3,-8(fp)
 8225f14:	18c7883a 	add	r3,r3,r3
 8225f18:	18c7883a 	add	r3,r3,r3
 8225f1c:	10c5883a 	add	r2,r2,r3
 8225f20:	10800017 	ldw	r2,0(r2)
 8225f24:	e0fffe17 	ldw	r3,-8(fp)
 8225f28:	18c00c44 	addi	r3,r3,49
 8225f2c:	10c00185 	stb	r3,6(r2)
            nets[i]->name[3] = '\0';
 8225f30:	008209b4 	movhi	r2,2086
 8225f34:	10b83d04 	addi	r2,r2,-7948
 8225f38:	e0fffe17 	ldw	r3,-8(fp)
 8225f3c:	18c7883a 	add	r3,r3,r3
 8225f40:	18c7883a 	add	r3,r3,r3
 8225f44:	10c5883a 	add	r2,r2,r3
 8225f48:	10800017 	ldw	r2,0(r2)
 8225f4c:	100001c5 	stb	zero,7(r2)
         }
      }
      /* check on subnet routing - if no mask then make one */
      fixup_subnet_mask(i);      /* make mask for this net */
 8225f50:	e13ffe17 	ldw	r4,-8(fp)
 8225f54:	82260e40 	call	82260e4 <fixup_subnet_mask>

      /* build broadcast addresses */
      if(nets[i]->n_ipaddr != 0)
 8225f58:	008209b4 	movhi	r2,2086
 8225f5c:	10b83d04 	addi	r2,r2,-7948
 8225f60:	e0fffe17 	ldw	r3,-8(fp)
 8225f64:	18c7883a 	add	r3,r3,r3
 8225f68:	18c7883a 	add	r3,r3,r3
 8225f6c:	10c5883a 	add	r2,r2,r3
 8225f70:	10800017 	ldw	r2,0(r2)
 8225f74:	10800a17 	ldw	r2,40(r2)
 8225f78:	10004d26 	beq	r2,zero,82260b0 <Netinit+0x5b4>
      {
         nets[i]->n_netbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 8225f7c:	008209b4 	movhi	r2,2086
 8225f80:	10b83d04 	addi	r2,r2,-7948
 8225f84:	e0fffe17 	ldw	r3,-8(fp)
 8225f88:	18c7883a 	add	r3,r3,r3
 8225f8c:	18c7883a 	add	r3,r3,r3
 8225f90:	10c5883a 	add	r2,r2,r3
 8225f94:	11000017 	ldw	r4,0(r2)
 8225f98:	008209b4 	movhi	r2,2086
 8225f9c:	10b83d04 	addi	r2,r2,-7948
 8225fa0:	e0fffe17 	ldw	r3,-8(fp)
 8225fa4:	18c7883a 	add	r3,r3,r3
 8225fa8:	18c7883a 	add	r3,r3,r3
 8225fac:	10c5883a 	add	r2,r2,r3
 8225fb0:	10800017 	ldw	r2,0(r2)
 8225fb4:	11400a17 	ldw	r5,40(r2)
 8225fb8:	008209b4 	movhi	r2,2086
 8225fbc:	10b83d04 	addi	r2,r2,-7948
 8225fc0:	e0fffe17 	ldw	r3,-8(fp)
 8225fc4:	18c7883a 	add	r3,r3,r3
 8225fc8:	18c7883a 	add	r3,r3,r3
 8225fcc:	10c5883a 	add	r2,r2,r3
 8225fd0:	10800017 	ldw	r2,0(r2)
 8225fd4:	10800c17 	ldw	r2,48(r2)
 8225fd8:	0084303a 	nor	r2,zero,r2
 8225fdc:	2884b03a 	or	r2,r5,r2
 8225fe0:	20800e15 	stw	r2,56(r4)
         nets[i]->n_netbr42 = nets[i]->n_ipaddr & nets[i]->snmask;
 8225fe4:	008209b4 	movhi	r2,2086
 8225fe8:	10b83d04 	addi	r2,r2,-7948
 8225fec:	e0fffe17 	ldw	r3,-8(fp)
 8225ff0:	18c7883a 	add	r3,r3,r3
 8225ff4:	18c7883a 	add	r3,r3,r3
 8225ff8:	10c5883a 	add	r2,r2,r3
 8225ffc:	11000017 	ldw	r4,0(r2)
 8226000:	008209b4 	movhi	r2,2086
 8226004:	10b83d04 	addi	r2,r2,-7948
 8226008:	e0fffe17 	ldw	r3,-8(fp)
 822600c:	18c7883a 	add	r3,r3,r3
 8226010:	18c7883a 	add	r3,r3,r3
 8226014:	10c5883a 	add	r2,r2,r3
 8226018:	10800017 	ldw	r2,0(r2)
 822601c:	11400a17 	ldw	r5,40(r2)
 8226020:	008209b4 	movhi	r2,2086
 8226024:	10b83d04 	addi	r2,r2,-7948
 8226028:	e0fffe17 	ldw	r3,-8(fp)
 822602c:	18c7883a 	add	r3,r3,r3
 8226030:	18c7883a 	add	r3,r3,r3
 8226034:	10c5883a 	add	r2,r2,r3
 8226038:	10800017 	ldw	r2,0(r2)
 822603c:	10800c17 	ldw	r2,48(r2)
 8226040:	2884703a 	and	r2,r5,r2
 8226044:	20800f15 	stw	r2,60(r4)
         nets[i]->n_subnetbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 8226048:	008209b4 	movhi	r2,2086
 822604c:	10b83d04 	addi	r2,r2,-7948
 8226050:	e0fffe17 	ldw	r3,-8(fp)
 8226054:	18c7883a 	add	r3,r3,r3
 8226058:	18c7883a 	add	r3,r3,r3
 822605c:	10c5883a 	add	r2,r2,r3
 8226060:	11000017 	ldw	r4,0(r2)
 8226064:	008209b4 	movhi	r2,2086
 8226068:	10b83d04 	addi	r2,r2,-7948
 822606c:	e0fffe17 	ldw	r3,-8(fp)
 8226070:	18c7883a 	add	r3,r3,r3
 8226074:	18c7883a 	add	r3,r3,r3
 8226078:	10c5883a 	add	r2,r2,r3
 822607c:	10800017 	ldw	r2,0(r2)
 8226080:	11400a17 	ldw	r5,40(r2)
 8226084:	008209b4 	movhi	r2,2086
 8226088:	10b83d04 	addi	r2,r2,-7948
 822608c:	e0fffe17 	ldw	r3,-8(fp)
 8226090:	18c7883a 	add	r3,r3,r3
 8226094:	18c7883a 	add	r3,r3,r3
 8226098:	10c5883a 	add	r2,r2,r3
 822609c:	10800017 	ldw	r2,0(r2)
 82260a0:	10800c17 	ldw	r2,48(r2)
 82260a4:	0084303a 	nor	r2,zero,r2
 82260a8:	2884b03a 	or	r2,r5,r2
 82260ac:	20801015 	stw	r2,64(r4)

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 82260b0:	e0bffe17 	ldw	r2,-8(fp)
 82260b4:	10800044 	addi	r2,r2,1
 82260b8:	e0bffe15 	stw	r2,-8(fp)
 82260bc:	d0a08417 	ldw	r2,-32240(gp)
 82260c0:	1007883a 	mov	r3,r2
 82260c4:	e0bffe17 	ldw	r2,-8(fp)
 82260c8:	10ff0716 	blt	r2,r3,8225ce8 <Netinit+0x1ec>
#if defined(DYNAMIC_IFACES) && defined(IN_MENUS)
   /* Install dynamic iface menu */
   install_menu(&dynif_menu[0]);
#endif /* DYNAMIC_IFACES && IN_MENUS */

   return(0);
 82260cc:	0005883a 	mov	r2,zero
}
 82260d0:	e037883a 	mov	sp,fp
 82260d4:	dfc00117 	ldw	ra,4(sp)
 82260d8:	df000017 	ldw	fp,0(sp)
 82260dc:	dec00204 	addi	sp,sp,8
 82260e0:	f800283a 	ret

082260e4 <fixup_subnet_mask>:
 * RETURNS: 
 */

void
fixup_subnet_mask(int netnum)      /* which of the nets[] to do. */
{
 82260e4:	defffc04 	addi	sp,sp,-16
 82260e8:	dfc00315 	stw	ra,12(sp)
 82260ec:	df000215 	stw	fp,8(sp)
 82260f0:	df000204 	addi	fp,sp,8
 82260f4:	e13fff15 	stw	r4,-4(fp)
   u_long   smask;

   if (nets[netnum]->snmask)  /* if mask is already set, don't bother */
 82260f8:	008209b4 	movhi	r2,2086
 82260fc:	10b83d04 	addi	r2,r2,-7948
 8226100:	e0ffff17 	ldw	r3,-4(fp)
 8226104:	18c7883a 	add	r3,r3,r3
 8226108:	18c7883a 	add	r3,r3,r3
 822610c:	10c5883a 	add	r2,r2,r3
 8226110:	10800017 	ldw	r2,0(r2)
 8226114:	10800c17 	ldw	r2,48(r2)
 8226118:	1000421e 	bne	r2,zero,8226224 <fixup_subnet_mask+0x140>
      return;

   /* things depending on IP address class: */
   if ((nets[netnum]->n_ipaddr & AMASK) == AADDR)
 822611c:	008209b4 	movhi	r2,2086
 8226120:	10b83d04 	addi	r2,r2,-7948
 8226124:	e0ffff17 	ldw	r3,-4(fp)
 8226128:	18c7883a 	add	r3,r3,r3
 822612c:	18c7883a 	add	r3,r3,r3
 8226130:	10c5883a 	add	r2,r2,r3
 8226134:	10800017 	ldw	r2,0(r2)
 8226138:	10800a17 	ldw	r2,40(r2)
 822613c:	1080200c 	andi	r2,r2,128
 8226140:	1000031e 	bne	r2,zero,8226150 <fixup_subnet_mask+0x6c>
      smask = 0xFF000000L;
 8226144:	00bfc034 	movhi	r2,65280
 8226148:	e0bffe15 	stw	r2,-8(fp)
 822614c:	00001f06 	br	82261cc <fixup_subnet_mask+0xe8>
   else if((nets[netnum]->n_ipaddr & BMASK) == BADDR)
 8226150:	008209b4 	movhi	r2,2086
 8226154:	10b83d04 	addi	r2,r2,-7948
 8226158:	e0ffff17 	ldw	r3,-4(fp)
 822615c:	18c7883a 	add	r3,r3,r3
 8226160:	18c7883a 	add	r3,r3,r3
 8226164:	10c5883a 	add	r2,r2,r3
 8226168:	10800017 	ldw	r2,0(r2)
 822616c:	10800a17 	ldw	r2,40(r2)
 8226170:	1080300c 	andi	r2,r2,192
 8226174:	10802018 	cmpnei	r2,r2,128
 8226178:	1000031e 	bne	r2,zero,8226188 <fixup_subnet_mask+0xa4>
      smask = 0xFFFF0000L;
 822617c:	00bffff4 	movhi	r2,65535
 8226180:	e0bffe15 	stw	r2,-8(fp)
 8226184:	00001106 	br	82261cc <fixup_subnet_mask+0xe8>
   else if((nets[netnum]->n_ipaddr & CMASK) == CADDR)
 8226188:	008209b4 	movhi	r2,2086
 822618c:	10b83d04 	addi	r2,r2,-7948
 8226190:	e0ffff17 	ldw	r3,-4(fp)
 8226194:	18c7883a 	add	r3,r3,r3
 8226198:	18c7883a 	add	r3,r3,r3
 822619c:	10c5883a 	add	r2,r2,r3
 82261a0:	10800017 	ldw	r2,0(r2)
 82261a4:	10800a17 	ldw	r2,40(r2)
 82261a8:	1080380c 	andi	r2,r2,224
 82261ac:	10803018 	cmpnei	r2,r2,192
 82261b0:	1000031e 	bne	r2,zero,82261c0 <fixup_subnet_mask+0xdc>
      smask = 0xFFFFFF00L;
 82261b4:	00bfc004 	movi	r2,-256
 82261b8:	e0bffe15 	stw	r2,-8(fp)
 82261bc:	00000306 	br	82261cc <fixup_subnet_mask+0xe8>
   else
   {
      dtrap();    /* bad logic or setup values */
 82261c0:	822d5f00 	call	822d5f0 <dtrap>
      smask = 0xFFFFFF00L;
 82261c4:	00bfc004 	movi	r2,-256
 82261c8:	e0bffe15 	stw	r2,-8(fp)
   }
   nets[netnum]->snmask = htonl(smask);
 82261cc:	008209b4 	movhi	r2,2086
 82261d0:	10b83d04 	addi	r2,r2,-7948
 82261d4:	e0ffff17 	ldw	r3,-4(fp)
 82261d8:	18c7883a 	add	r3,r3,r3
 82261dc:	18c7883a 	add	r3,r3,r3
 82261e0:	10c5883a 	add	r2,r2,r3
 82261e4:	10800017 	ldw	r2,0(r2)
 82261e8:	e0fffe17 	ldw	r3,-8(fp)
 82261ec:	1808d63a 	srli	r4,r3,24
 82261f0:	e0fffe17 	ldw	r3,-8(fp)
 82261f4:	1806d23a 	srli	r3,r3,8
 82261f8:	18ffc00c 	andi	r3,r3,65280
 82261fc:	20c8b03a 	or	r4,r4,r3
 8226200:	e0fffe17 	ldw	r3,-8(fp)
 8226204:	18ffc00c 	andi	r3,r3,65280
 8226208:	1806923a 	slli	r3,r3,8
 822620c:	20c8b03a 	or	r4,r4,r3
 8226210:	e0fffe17 	ldw	r3,-8(fp)
 8226214:	1806963a 	slli	r3,r3,24
 8226218:	20c6b03a 	or	r3,r4,r3
 822621c:	10c00c15 	stw	r3,48(r2)
 8226220:	00000106 	br	8226228 <fixup_subnet_mask+0x144>
fixup_subnet_mask(int netnum)      /* which of the nets[] to do. */
{
   u_long   smask;

   if (nets[netnum]->snmask)  /* if mask is already set, don't bother */
      return;
 8226224:	0001883a 	nop
   {
      dtrap();    /* bad logic or setup values */
      smask = 0xFFFFFF00L;
   }
   nets[netnum]->snmask = htonl(smask);
}
 8226228:	e037883a 	mov	sp,fp
 822622c:	dfc00117 	ldw	ra,4(sp)
 8226230:	df000017 	ldw	fp,0(sp)
 8226234:	dec00204 	addi	sp,sp,8
 8226238:	f800283a 	ret

0822623c <netclose>:
 * RETURNS: 
 */

void
netclose()
{
 822623c:	defffc04 	addi	sp,sp,-16
 8226240:	dfc00315 	stw	ra,12(sp)
 8226244:	df000215 	stw	fp,8(sp)
 8226248:	df000204 	addi	fp,sp,8
   NET ifp;
   int index = 0;
 822624c:	e03fff15 	stw	zero,-4(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
 8226250:	d0a08317 	ldw	r2,-32244(gp)
 8226254:	1080010c 	andi	r2,r2,4
 8226258:	10000326 	beq	r2,zero,8226268 <netclose+0x2c>
 822625c:	01020974 	movhi	r4,2085
 8226260:	213fd904 	addi	r4,r4,-156
 8226264:	82036800 	call	8203680 <puts>
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 8226268:	008209b4 	movhi	r2,2086
 822626c:	10ba7e04 	addi	r2,r2,-5640
 8226270:	10800017 	ldw	r2,0(r2)
 8226274:	e0bffe15 	stw	r2,-8(fp)
 8226278:	00002106 	br	8226300 <netclose+0xc4>
   {
      if (ifp->n_close)
 822627c:	e0bffe17 	ldw	r2,-8(fp)
 8226280:	10800517 	ldw	r2,20(r2)
 8226284:	10000f26 	beq	r2,zero,82262c4 <netclose+0x88>
      {
         dprintf("netclose: closing iface %s\n", ifp->n_mib->ifDescr);
 8226288:	e0bffe17 	ldw	r2,-8(fp)
 822628c:	10802717 	ldw	r2,156(r2)
 8226290:	10800117 	ldw	r2,4(r2)
 8226294:	100b883a 	mov	r5,r2
 8226298:	01020974 	movhi	r4,2085
 822629c:	213fde04 	addi	r4,r4,-136
 82262a0:	82033fc0 	call	82033fc <printf>
         (*(ifp->n_close))(index++);
 82262a4:	e0bffe17 	ldw	r2,-8(fp)
 82262a8:	10c00517 	ldw	r3,20(r2)
 82262ac:	e0bfff17 	ldw	r2,-4(fp)
 82262b0:	11000044 	addi	r4,r2,1
 82262b4:	e13fff15 	stw	r4,-4(fp)
 82262b8:	1009883a 	mov	r4,r2
 82262bc:	183ee83a 	callr	r3
 82262c0:	00000c06 	br	82262f4 <netclose+0xb8>
      }
      else
      {
#ifdef NPDEBUG
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
 82262c4:	d0a08317 	ldw	r2,-32244(gp)
 82262c8:	1080010c 	andi	r2,r2,4
 82262cc:	10000626 	beq	r2,zero,82262e8 <netclose+0xac>
 82262d0:	e0bffe17 	ldw	r2,-8(fp)
 82262d4:	10800104 	addi	r2,r2,4
 82262d8:	100b883a 	mov	r5,r2
 82262dc:	01020974 	movhi	r4,2085
 82262e0:	213fe504 	addi	r4,r4,-108
 82262e4:	82033fc0 	call	82033fc <printf>
#endif
         index++;
 82262e8:	e0bfff17 	ldw	r2,-4(fp)
 82262ec:	10800044 	addi	r2,r2,1
 82262f0:	e0bfff15 	stw	r2,-4(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 82262f4:	e0bffe17 	ldw	r2,-8(fp)
 82262f8:	10800017 	ldw	r2,0(r2)
 82262fc:	e0bffe15 	stw	r2,-8(fp)
 8226300:	e0bffe17 	ldw	r2,-8(fp)
 8226304:	103fdd1e 	bne	r2,zero,822627c <netclose+0x40>
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
#endif
         index++;
      }
   }
}
 8226308:	0001883a 	nop
 822630c:	e037883a 	mov	sp,fp
 8226310:	dfc00117 	ldw	ra,4(sp)
 8226314:	df000017 	ldw	fp,0(sp)
 8226318:	dec00204 	addi	sp,sp,8
 822631c:	f800283a 	ret

08226320 <pktdemux>:
 * RETURNS: void
 */

void
pktdemux()
{
 8226320:	defff904 	addi	sp,sp,-28
 8226324:	dfc00615 	stw	ra,24(sp)
 8226328:	df000515 	stw	fp,20(sp)
 822632c:	df000504 	addi	fp,sp,20
   NET      ifc;                /* interface packet came from */
   IFMIB    mib;
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */
 8226330:	e03ffb15 	stw	zero,-20(fp)

   while (rcvdq.q_len)
 8226334:	0000d906 	br	822669c <pktdemux+0x37c>
   {
      /* If we are low on free packets, don't hog CPU cycles */
      if (pkts++ > bigfreeq.q_len)
 8226338:	e0fffb17 	ldw	r3,-20(fp)
 822633c:	18800044 	addi	r2,r3,1
 8226340:	e0bffb15 	stw	r2,-20(fp)
 8226344:	008209b4 	movhi	r2,2086
 8226348:	10b8e404 	addi	r2,r2,-7280
 822634c:	10800217 	ldw	r2,8(r2)
 8226350:	10c0020e 	bge	r2,r3,822635c <pktdemux+0x3c>
      {
#ifdef SUPERLOOP
         return;        /* don't hog stack on superloop */
#else    /* SUPERLOOP */
         tk_yield(); /* let application tasks process received packets */
 8226354:	82298680 	call	8229868 <tk_yield>
         pkts = 0;   /* reset counter */
 8226358:	e03ffb15 	stw	zero,-20(fp)
#endif   /* SUPERLOOP else */
      }

      /* If we get receive interupt from the net during this
      lock, the MAC driver needs to wait or reschedule */
      LOCK_NET_RESOURCE(RXQ_RESID);
 822635c:	01000044 	movi	r4,1
 8226360:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pkt = (PACKET)q_deq(&rcvdq);
 8226364:	010209b4 	movhi	r4,2086
 8226368:	21377804 	addi	r4,r4,-8736
 822636c:	822cf200 	call	822cf20 <getq>
 8226370:	e0bffc15 	stw	r2,-16(fp)
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 8226374:	01000044 	movi	r4,1
 8226378:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      if (!pkt) panic("pktdemux: got null pkt");
 822637c:	e0bffc17 	ldw	r2,-16(fp)
 8226380:	1000031e 	bne	r2,zero,8226390 <pktdemux+0x70>
 8226384:	01020974 	movhi	r4,2085
 8226388:	213fec04 	addi	r4,r4,-80
 822638c:	8228ca40 	call	8228ca4 <panic>
      ifc = pkt->net;
 8226390:	e0bffc17 	ldw	r2,-16(fp)
 8226394:	10800617 	ldw	r2,24(r2)
 8226398:	e0bffd15 	stw	r2,-12(fp)

      mib = ifc->n_mib;
 822639c:	e0bffd17 	ldw	r2,-12(fp)
 82263a0:	10802717 	ldw	r2,156(r2)
 82263a4:	e0bffe15 	stw	r2,-8(fp)
      /* maintain mib stats for unicast and broadcast */
      if (isbcast(ifc, (u_char*)pkt->nb_buff + ETHHDR_BIAS))
 82263a8:	e0bffc17 	ldw	r2,-16(fp)
 82263ac:	10800117 	ldw	r2,4(r2)
 82263b0:	10800084 	addi	r2,r2,2
 82263b4:	100b883a 	mov	r5,r2
 82263b8:	e13ffd17 	ldw	r4,-12(fp)
 82263bc:	823ee140 	call	823ee14 <isbcast>
 82263c0:	10000626 	beq	r2,zero,82263dc <pktdemux+0xbc>
         mib->ifInNUcastPkts++;
 82263c4:	e0bffe17 	ldw	r2,-8(fp)
 82263c8:	10800b17 	ldw	r2,44(r2)
 82263cc:	10c00044 	addi	r3,r2,1
 82263d0:	e0bffe17 	ldw	r2,-8(fp)
 82263d4:	10c00b15 	stw	r3,44(r2)
 82263d8:	00000506 	br	82263f0 <pktdemux+0xd0>
      else
         mib->ifInUcastPkts++;
 82263dc:	e0bffe17 	ldw	r2,-8(fp)
 82263e0:	10800a17 	ldw	r2,40(r2)
 82263e4:	10c00044 	addi	r3,r2,1
 82263e8:	e0bffe17 	ldw	r2,-8(fp)
 82263ec:	10c00a15 	stw	r3,40(r2)

      if(mib->ifAdminStatus == NI_DOWN)
 82263f0:	e0bffe17 	ldw	r2,-8(fp)
 82263f4:	10800617 	ldw	r2,24(r2)
 82263f8:	10800098 	cmpnei	r2,r2,2
 82263fc:	10000c1e 	bne	r2,zero,8226430 <pktdemux+0x110>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 8226400:	01000084 	movi	r4,2
 8226404:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
         pk_free(pkt);  /* dump packet from downed interface */
 8226408:	e13ffc17 	ldw	r4,-16(fp)
 822640c:	822cd980 	call	822cd98 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8226410:	01000084 	movi	r4,2
 8226414:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         mib->ifInDiscards++;
 8226418:	e0bffe17 	ldw	r2,-8(fp)
 822641c:	10800c17 	ldw	r2,48(r2)
 8226420:	10c00044 	addi	r3,r2,1
 8226424:	e0bffe17 	ldw	r2,-8(fp)
 8226428:	10c00c15 	stw	r3,48(r2)
         continue;      /* next packet */
 822642c:	00009b06 	br	822669c <pktdemux+0x37c>
      }

#ifdef NPDEBUG
      if (*(pkt->nb_buff - ALIGN_TYPE) != 'M' ||
 8226430:	e0bffc17 	ldw	r2,-16(fp)
 8226434:	10800117 	ldw	r2,4(r2)
 8226438:	10bfff04 	addi	r2,r2,-4
 822643c:	10800003 	ldbu	r2,0(r2)
 8226440:	10803fcc 	andi	r2,r2,255
 8226444:	1080201c 	xori	r2,r2,128
 8226448:	10bfe004 	addi	r2,r2,-128
 822644c:	10801358 	cmpnei	r2,r2,77
 8226450:	10000b1e 	bne	r2,zero,8226480 <pktdemux+0x160>
          *(pkt->nb_buff + pkt->nb_blen) != 'M')
 8226454:	e0bffc17 	ldw	r2,-16(fp)
 8226458:	10c00117 	ldw	r3,4(r2)
 822645c:	e0bffc17 	ldw	r2,-16(fp)
 8226460:	10800217 	ldw	r2,8(r2)
 8226464:	1885883a 	add	r2,r3,r2
 8226468:	10800003 	ldbu	r2,0(r2)
         mib->ifInDiscards++;
         continue;      /* next packet */
      }

#ifdef NPDEBUG
      if (*(pkt->nb_buff - ALIGN_TYPE) != 'M' ||
 822646c:	10803fcc 	andi	r2,r2,255
 8226470:	1080201c 	xori	r2,r2,128
 8226474:	10bfe004 	addi	r2,r2,-128
 8226478:	10801360 	cmpeqi	r2,r2,77
 822647c:	1000041e 	bne	r2,zero,8226490 <pktdemux+0x170>
          *(pkt->nb_buff + pkt->nb_blen) != 'M')
      {
         dtrap();
 8226480:	822d5f00 	call	822d5f0 <dtrap>
         panic("pktdemux: corrupt pkt");
 8226484:	01020974 	movhi	r4,2085
 8226488:	213ff204 	addi	r4,r4,-56
 822648c:	8228ca40 	call	8228ca4 <panic>
         }
      }
#endif   /* LOSSY_IO */

      /* see if driver set pkt->nb_prot and pkt->type */
      if((ifc->n_flags & NF_NBPROT) == 0)
 8226490:	e0bffd17 	ldw	r2,-12(fp)
 8226494:	10802a17 	ldw	r2,168(r2)
 8226498:	1080020c 	andi	r2,r2,8
 822649c:	1000491e 	bne	r2,zero,82265c4 <pktdemux+0x2a4>
          * probably the right thing to do, but because of this historic
          * inconsistency we don't try to fix it here - the longer size
          * turns out to be harmless since the IP layer fixes the size
          * based on the IP header length field.
          */
         switch(ifc->n_mib->ifType)
 82264a0:	e0bffd17 	ldw	r2,-12(fp)
 82264a4:	10802717 	ldw	r2,156(r2)
 82264a8:	10800217 	ldw	r2,8(r2)
 82264ac:	108001a0 	cmpeqi	r2,r2,6
 82264b0:	10003626 	beq	r2,zero,822658c <pktdemux+0x26c>
         {
         case ETHERNET:
            /* get pointer to ethernet header */
            eth = (pkt->nb_buff + ETHHDR_BIAS);
 82264b4:	e0bffc17 	ldw	r2,-16(fp)
 82264b8:	10800117 	ldw	r2,4(r2)
 82264bc:	10800084 	addi	r2,r2,2
 82264c0:	e0bfff15 	stw	r2,-4(fp)
            {
               pkt->type = htons((unshort)ET_TYPE_GET(eth));
               pkt->nb_prot = pkt->nb_buff + ETHHDR_SIZE;
            }
#else
            pkt->type = htons((unshort)ET_TYPE_GET(eth));
 82264c4:	e0bfff17 	ldw	r2,-4(fp)
 82264c8:	10800304 	addi	r2,r2,12
 82264cc:	10800003 	ldbu	r2,0(r2)
 82264d0:	10803fcc 	andi	r2,r2,255
 82264d4:	1080201c 	xori	r2,r2,128
 82264d8:	10bfe004 	addi	r2,r2,-128
 82264dc:	1004923a 	slli	r2,r2,8
 82264e0:	1007883a 	mov	r3,r2
 82264e4:	e0bfff17 	ldw	r2,-4(fp)
 82264e8:	10800344 	addi	r2,r2,13
 82264ec:	10800003 	ldbu	r2,0(r2)
 82264f0:	10803fcc 	andi	r2,r2,255
 82264f4:	1080201c 	xori	r2,r2,128
 82264f8:	10bfe004 	addi	r2,r2,-128
 82264fc:	10803fcc 	andi	r2,r2,255
 8226500:	1885883a 	add	r2,r3,r2
 8226504:	10bfffcc 	andi	r2,r2,65535
 8226508:	1004d23a 	srli	r2,r2,8
 822650c:	1007883a 	mov	r3,r2
 8226510:	e0bfff17 	ldw	r2,-4(fp)
 8226514:	10800304 	addi	r2,r2,12
 8226518:	10800003 	ldbu	r2,0(r2)
 822651c:	10803fcc 	andi	r2,r2,255
 8226520:	1080201c 	xori	r2,r2,128
 8226524:	10bfe004 	addi	r2,r2,-128
 8226528:	1004923a 	slli	r2,r2,8
 822652c:	1009883a 	mov	r4,r2
 8226530:	e0bfff17 	ldw	r2,-4(fp)
 8226534:	10800344 	addi	r2,r2,13
 8226538:	10800003 	ldbu	r2,0(r2)
 822653c:	10803fcc 	andi	r2,r2,255
 8226540:	1080201c 	xori	r2,r2,128
 8226544:	10bfe004 	addi	r2,r2,-128
 8226548:	10803fcc 	andi	r2,r2,255
 822654c:	2085883a 	add	r2,r4,r2
 8226550:	10bfffcc 	andi	r2,r2,65535
 8226554:	1004923a 	slli	r2,r2,8
 8226558:	1884b03a 	or	r2,r3,r2
 822655c:	1007883a 	mov	r3,r2
 8226560:	e0bffc17 	ldw	r2,-16(fp)
 8226564:	10c0080d 	sth	r3,32(r2)
            pkt->nb_prot = pkt->nb_buff + pkt->net->n_lnh;
 8226568:	e0bffc17 	ldw	r2,-16(fp)
 822656c:	10800117 	ldw	r2,4(r2)
 8226570:	e0fffc17 	ldw	r3,-16(fp)
 8226574:	18c00617 	ldw	r3,24(r3)
 8226578:	18c00817 	ldw	r3,32(r3)
 822657c:	10c7883a 	add	r3,r2,r3
 8226580:	e0bffc17 	ldw	r2,-16(fp)
 8226584:	10c00315 	stw	r3,12(r2)
#endif   /* IEEE_802_3 */
            break;
 8226588:	00000e06 	br	82265c4 <pktdemux+0x2a4>
         case PPPOE:
            /* do not change type yet, for PPPoE */
            break;
#endif   /* USE_PPPOE */
         default:    /* driver bug? */
            dprintf("pktdemux: bad Iface type %ld\n",ifc->n_mib->ifType);
 822658c:	e0bffd17 	ldw	r2,-12(fp)
 8226590:	10802717 	ldw	r2,156(r2)
 8226594:	10800217 	ldw	r2,8(r2)
 8226598:	100b883a 	mov	r5,r2
 822659c:	01020974 	movhi	r4,2085
 82265a0:	213ff804 	addi	r4,r4,-32
 82265a4:	82033fc0 	call	82033fc <printf>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 82265a8:	01000084 	movi	r4,2
 82265ac:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
            pk_free(pkt);
 82265b0:	e13ffc17 	ldw	r4,-16(fp)
 82265b4:	822cd980 	call	822cd98 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82265b8:	01000084 	movi	r4,2
 82265bc:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
            continue;
 82265c0:	00003606 	br	822669c <pktdemux+0x37c>
         }
      }

      /* pkt->nb_prot and pkt->type are now set. pass pkt to upper layer */
      switch(pkt->type)
 82265c4:	e0bffc17 	ldw	r2,-16(fp)
 82265c8:	1080080b 	ldhu	r2,32(r2)
 82265cc:	10bfffcc 	andi	r2,r2,65535
 82265d0:	10c00220 	cmpeqi	r3,r2,8
 82265d4:	1800031e 	bne	r3,zero,82265e4 <pktdemux+0x2c4>
 82265d8:	10818220 	cmpeqi	r2,r2,1544
 82265dc:	1000081e 	bne	r2,zero,8226600 <pktdemux+0x2e0>
 82265e0:	00000e06 	br	822661c <pktdemux+0x2fc>
      {
      case IPTP:     /* IP type */
         LOCK_NET_RESOURCE(NET_RESID);
 82265e4:	0009883a 	mov	r4,zero
 82265e8:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
#ifdef SHARED_IPADDRS
         add_share_route(pkt);
#endif /* SHARED_IPADDRS */
#ifdef IP_V4
         ip_rcv(pkt);
 82265ec:	e13ffc17 	ldw	r4,-16(fp)
 82265f0:	8242c8c0 	call	8242c8c <ip_rcv>
            /* don't care, it's IPv4 */
            LOCK_NET_RESOURCE(FREEQ_RESID);
            pk_free(pkt);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif
		UNLOCK_NET_RESOURCE(NET_RESID);
 82265f4:	0009883a 	mov	r4,zero
 82265f8:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         break;
 82265fc:	00002606 	br	8226698 <pktdemux+0x378>
#ifdef INCLUDE_ARP
      case ARPTP:       /* ARP type */
         LOCK_NET_RESOURCE(NET_RESID);
 8226600:	0009883a 	mov	r4,zero
 8226604:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
         arprcv(pkt);
 8226608:	e13ffc17 	ldw	r4,-16(fp)
 822660c:	823e5fc0 	call	823e5fc <arprcv>
         UNLOCK_NET_RESOURCE(NET_RESID);
 8226610:	0009883a 	mov	r4,zero
 8226614:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         break;
 8226618:	00001f06 	br	8226698 <pktdemux+0x378>
         UNLOCK_NET_RESOURCE(NET_RESID);
         break;
#endif
      default:
#ifdef NPDEBUG
         if (NDEBUG & UPCTRACE)
 822661c:	d0a08317 	ldw	r2,-32244(gp)
 8226620:	1081000c 	andi	r2,r2,1024
 8226624:	10001026 	beq	r2,zero,8226668 <pktdemux+0x348>
            dprintf("pktdemux: bad pkt type 0x%04x\n", ntohs(pkt->type));
 8226628:	e0bffc17 	ldw	r2,-16(fp)
 822662c:	1080080b 	ldhu	r2,32(r2)
 8226630:	10bfffcc 	andi	r2,r2,65535
 8226634:	1004d23a 	srli	r2,r2,8
 8226638:	10bfffcc 	andi	r2,r2,65535
 822663c:	10c03fcc 	andi	r3,r2,255
 8226640:	e0bffc17 	ldw	r2,-16(fp)
 8226644:	1080080b 	ldhu	r2,32(r2)
 8226648:	10bfffcc 	andi	r2,r2,65535
 822664c:	1004923a 	slli	r2,r2,8
 8226650:	10bfffcc 	andi	r2,r2,65535
 8226654:	1884b03a 	or	r2,r3,r2
 8226658:	100b883a 	mov	r5,r2
 822665c:	01020974 	movhi	r4,2085
 8226660:	21000004 	addi	r4,r4,0
 8226664:	82033fc0 	call	82033fc <printf>
#endif   /* NPDEBUG */
         ifc->n_mib->ifInUnknownProtos++;
 8226668:	e0bffd17 	ldw	r2,-12(fp)
 822666c:	10802717 	ldw	r2,156(r2)
 8226670:	10c00e17 	ldw	r3,56(r2)
 8226674:	18c00044 	addi	r3,r3,1
 8226678:	10c00e15 	stw	r3,56(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 822667c:	01000084 	movi	r4,2
 8226680:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
         pk_free(pkt);           /* return to free buffer */
 8226684:	e13ffc17 	ldw	r4,-16(fp)
 8226688:	822cd980 	call	822cd98 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822668c:	01000084 	movi	r4,2
 8226690:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         break;
 8226694:	0001883a 	nop
      }
      continue;
 8226698:	0001883a 	nop
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */

   while (rcvdq.q_len)
 822669c:	008209b4 	movhi	r2,2086
 82266a0:	10b77804 	addi	r2,r2,-8736
 82266a4:	10800217 	ldw	r2,8(r2)
 82266a8:	103f231e 	bne	r2,zero,8226338 <pktdemux+0x18>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
         break;
      }
      continue;
   }
}
 82266ac:	0001883a 	nop
 82266b0:	e037883a 	mov	sp,fp
 82266b4:	dfc00117 	ldw	ra,4(sp)
 82266b8:	df000017 	ldw	fp,0(sp)
 82266bc:	dec00204 	addi	sp,sp,8
 82266c0:	f800283a 	ret

082266c4 <c_older>:
 * RETURNS: the older of the two passed tick counts
 */

u_long
c_older(u_long ct1, u_long ct2)
{
 82266c4:	defffd04 	addi	sp,sp,-12
 82266c8:	df000215 	stw	fp,8(sp)
 82266cc:	df000204 	addi	fp,sp,8
 82266d0:	e13ffe15 	stw	r4,-8(fp)
 82266d4:	e17fff15 	stw	r5,-4(fp)

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
 82266d8:	d0a0a817 	ldw	r2,-32096(gp)
 82266dc:	10000c0e 	bge	r2,zero,8226710 <c_older+0x4c>
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
 82266e0:	d0e0a817 	ldw	r3,-32096(gp)

u_long
c_older(u_long ct1, u_long ct2)
{

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
 82266e4:	e0bffe17 	ldw	r2,-8(fp)
 82266e8:	18800336 	bltu	r3,r2,82266f8 <c_older+0x34>
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
 82266ec:	d0e0a817 	ldw	r3,-32096(gp)
 82266f0:	e0bfff17 	ldw	r2,-4(fp)
 82266f4:	1880062e 	bgeu	r3,r2,8226710 <c_older+0x4c>
       (ct1 >= cticks && ct2 >= cticks))   /* both are above cticks */
 82266f8:	d0a0a817 	ldw	r2,-32096(gp)
u_long
c_older(u_long ct1, u_long ct2)
{

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
 82266fc:	e0fffe17 	ldw	r3,-8(fp)
 8226700:	18800a36 	bltu	r3,r2,822672c <c_older+0x68>
       (ct1 >= cticks && ct2 >= cticks))   /* both are above cticks */
 8226704:	d0a0a817 	ldw	r2,-32096(gp)
 8226708:	e0ffff17 	ldw	r3,-4(fp)
 822670c:	18800736 	bltu	r3,r2,822672c <c_older+0x68>
   {
      if (ct1 < ct2)
 8226710:	e0fffe17 	ldw	r3,-8(fp)
 8226714:	e0bfff17 	ldw	r2,-4(fp)
 8226718:	1880022e 	bgeu	r3,r2,8226724 <c_older+0x60>
         return(ct1);      /* then smaller is oldest */
 822671c:	e0bffe17 	ldw	r2,-8(fp)
 8226720:	00000806 	br	8226744 <c_older+0x80>
      else 
         return(ct2);
 8226724:	e0bfff17 	ldw	r2,-4(fp)
 8226728:	00000606 	br	8226744 <c_older+0x80>
   }

   /* else one is less than cticks, and one is greater.
   the larger value is then the oldest */
   if (ct1 >= ct2)
 822672c:	e0fffe17 	ldw	r3,-8(fp)
 8226730:	e0bfff17 	ldw	r2,-4(fp)
 8226734:	18800236 	bltu	r3,r2,8226740 <c_older+0x7c>
      return(ct1);
 8226738:	e0bffe17 	ldw	r2,-8(fp)
 822673c:	00000106 	br	8226744 <c_older+0x80>
   else
      return(ct2);
 8226740:	e0bfff17 	ldw	r2,-4(fp)
}
 8226744:	e037883a 	mov	sp,fp
 8226748:	df000017 	ldw	fp,0(sp)
 822674c:	dec00104 	addi	sp,sp,4
 8226750:	f800283a 	ret

08226754 <ip2mac>:
 */

int
ip2mac(PACKET pkt,         /* the packet itself, all set but for dest MAC address */
   ip_addr  dest_ip)    /* the IP host or gateway to get MAC addr for */
{
 8226754:	defffb04 	addi	sp,sp,-20
 8226758:	dfc00415 	stw	ra,16(sp)
 822675c:	df000315 	stw	fp,12(sp)
 8226760:	df000304 	addi	fp,sp,12
 8226764:	e13ffe15 	stw	r4,-8(fp)
 8226768:	e17fff15 	stw	r5,-4(fp)
   IFMIB ifmib = pkt->net->n_mib;   /* mib info for this interface */
 822676c:	e0bffe17 	ldw	r2,-8(fp)
 8226770:	10800617 	ldw	r2,24(r2)
 8226774:	10802717 	ldw	r2,156(r2)
 8226778:	e0bffd15 	stw	r2,-12(fp)

   /* Always punt if iface ifAdminStatus is DOWN. ifOperStatus may 
    * be down too, but our packet may be the event required to bring 
    * it up - so don't worry about ifOperStatus here.
    */
   if(ifmib->ifAdminStatus == NI_DOWN)
 822677c:	e0bffd17 	ldw	r2,-12(fp)
 8226780:	10800617 	ldw	r2,24(r2)
 8226784:	10800098 	cmpnei	r2,r2,2
 8226788:	1000081e 	bne	r2,zero,82267ac <ip2mac+0x58>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 822678c:	01000084 	movi	r4,2
 8226790:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free(pkt);
 8226794:	e13ffe17 	ldw	r4,-8(fp)
 8226798:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822679c:	01000084 	movi	r4,2
 82267a0:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return(ENP_NO_ROUTE);
 82267a4:	00bff7c4 	movi	r2,-33
 82267a8:	00004806 	br	82268cc <ip2mac+0x178>
         return ENP_NOBUFFER;
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
 82267ac:	e0bffe17 	ldw	r2,-8(fp)
 82267b0:	10800617 	ldw	r2,24(r2)
 82267b4:	10800817 	ldw	r2,32(r2)
 82267b8:	10000826 	beq	r2,zero,82267dc <ip2mac+0x88>
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
 82267bc:	e0bffd17 	ldw	r2,-12(fp)
 82267c0:	10800217 	ldw	r2,8(r2)
         return ENP_NOBUFFER;
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
 82267c4:	108005e0 	cmpeqi	r2,r2,23
 82267c8:	1000041e 	bne	r2,zero,82267dc <ip2mac+0x88>
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
       (ifmib->ifType == SLIP))
 82267cc:	e0bffd17 	ldw	r2,-12(fp)
 82267d0:	10800217 	ldw	r2,8(r2)
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
 82267d4:	10800718 	cmpnei	r2,r2,28
 82267d8:	1000291e 	bne	r2,zero,8226880 <ip2mac+0x12c>
       (ifmib->ifType == SLIP))
   {
      ifmib->ifOutUcastPkts++;   /* maintain MIB counters */
 82267dc:	e0bffd17 	ldw	r2,-12(fp)
 82267e0:	10801017 	ldw	r2,64(r2)
 82267e4:	10c00044 	addi	r3,r2,1
 82267e8:	e0bffd17 	ldw	r2,-12(fp)
 82267ec:	10c01015 	stw	r3,64(r2)
      ifmib->ifOutOctets += pkt->nb_plen;
 82267f0:	e0bffd17 	ldw	r2,-12(fp)
 82267f4:	10c00f17 	ldw	r3,60(r2)
 82267f8:	e0bffe17 	ldw	r2,-8(fp)
 82267fc:	10800417 	ldw	r2,16(r2)
 8226800:	1887883a 	add	r3,r3,r2
 8226804:	e0bffd17 	ldw	r2,-12(fp)
 8226808:	10c00f15 	stw	r3,60(r2)

      /* send packet on media */
      if (pkt->net->pkt_send) /* favor using packet send */
 822680c:	e0bffe17 	ldw	r2,-8(fp)
 8226810:	10800617 	ldw	r2,24(r2)
 8226814:	10800417 	ldw	r2,16(r2)
 8226818:	10000626 	beq	r2,zero,8226834 <ip2mac+0xe0>
         pkt->net->pkt_send(pkt);   /* pkt will be freed by MAC code */
 822681c:	e0bffe17 	ldw	r2,-8(fp)
 8226820:	10800617 	ldw	r2,24(r2)
 8226824:	10800417 	ldw	r2,16(r2)
 8226828:	e13ffe17 	ldw	r4,-8(fp)
 822682c:	103ee83a 	callr	r2
 8226830:	00001106 	br	8226878 <ip2mac+0x124>
      else  /* no packet send; try raw send */
      {
         pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 8226834:	e0bffe17 	ldw	r2,-8(fp)
 8226838:	10800617 	ldw	r2,24(r2)
 822683c:	10800317 	ldw	r2,12(r2)
 8226840:	e0fffe17 	ldw	r3,-8(fp)
 8226844:	19000617 	ldw	r4,24(r3)
 8226848:	e0fffe17 	ldw	r3,-8(fp)
 822684c:	19400317 	ldw	r5,12(r3)
 8226850:	e0fffe17 	ldw	r3,-8(fp)
 8226854:	18c00417 	ldw	r3,16(r3)
 8226858:	180d883a 	mov	r6,r3
 822685c:	103ee83a 	callr	r2
         LOCK_NET_RESOURCE(FREEQ_RESID);
 8226860:	01000084 	movi	r4,2
 8226864:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
         pk_free(pkt);
 8226868:	e13ffe17 	ldw	r4,-8(fp)
 822686c:	822cd980 	call	822cd98 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8226870:	01000084 	movi	r4,2
 8226874:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      }
      return(SUCCESS);
 8226878:	0005883a 	mov	r2,zero
 822687c:	00001306 	br	82268cc <ip2mac+0x178>
   }

   /* don't allow unicast sends if NIC iface has no IP address. This
    * is to prevent DHCP clients from sending prior to assignment.
    */
   if (pkt->net->n_ipaddr == 0L)
 8226880:	e0bffe17 	ldw	r2,-8(fp)
 8226884:	10800617 	ldw	r2,24(r2)
 8226888:	10800a17 	ldw	r2,40(r2)
 822688c:	10000c1e 	bne	r2,zero,82268c0 <ip2mac+0x16c>
   {
      if (pkt->fhost != 0xFFFFFFFF) /* check for broadcast packet */
 8226890:	e0bffe17 	ldw	r2,-8(fp)
 8226894:	10800717 	ldw	r2,28(r2)
 8226898:	10bfffe0 	cmpeqi	r2,r2,-1
 822689c:	1000081e 	bne	r2,zero,82268c0 <ip2mac+0x16c>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 82268a0:	01000084 	movi	r4,2
 82268a4:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
         pk_free(pkt);
 82268a8:	e13ffe17 	ldw	r4,-8(fp)
 82268ac:	822cd980 	call	822cd98 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82268b0:	01000084 	movi	r4,2
 82268b4:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         return ENP_SENDERR;
 82268b8:	00bff884 	movi	r2,-30
 82268bc:	00000306 	br	82268cc <ip2mac+0x178>
      }
   }

#ifdef INCLUDE_ARP   /* must be ethernet or token ring */
   return(send_via_arp(pkt, dest_ip));
 82268c0:	e17fff17 	ldw	r5,-4(fp)
 82268c4:	e13ffe17 	ldw	r4,-8(fp)
 82268c8:	823e8600 	call	823e860 <send_via_arp>
#else
   dtrap();    /* Bad option combination? */
   return ENP_NO_IFACE; /* sent to unknown interface type */
#endif   /* INCLUDE_ARP */
}
 82268cc:	e037883a 	mov	sp,fp
 82268d0:	dfc00117 	ldw	ra,4(sp)
 82268d4:	df000017 	ldw	fp,0(sp)
 82268d8:	dec00204 	addi	sp,sp,8
 82268dc:	f800283a 	ret

082268e0 <ip_startup>:
 * RETURNS: returns NULL if OK, or text of an error message 
 */

char *   
ip_startup()
{
 82268e0:	defffc04 	addi	sp,sp,-16
 82268e4:	dfc00315 	stw	ra,12(sp)
 82268e8:	df000215 	stw	fp,8(sp)
 82268ec:	df000204 	addi	fp,sp,8
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 82268f0:	e03ffe15 	stw	zero,-8(fp)
 82268f4:	00002a06 	br	82269a0 <ip_startup+0xc0>
   {
      nets[i] = &netstatic[i];   /* set up array of pointers */
 82268f8:	e0bffe17 	ldw	r2,-8(fp)
 82268fc:	10c03024 	muli	r3,r2,192
 8226900:	008209b4 	movhi	r2,2086
 8226904:	10b77d04 	addi	r2,r2,-8716
 8226908:	1889883a 	add	r4,r3,r2
 822690c:	008209b4 	movhi	r2,2086
 8226910:	10b83d04 	addi	r2,r2,-7948
 8226914:	e0fffe17 	ldw	r3,-8(fp)
 8226918:	18c7883a 	add	r3,r3,r3
 822691c:	18c7883a 	add	r3,r3,r3
 8226920:	10c5883a 	add	r2,r2,r3
 8226924:	11000015 	stw	r4,0(r2)
      nets[i]->n_mib = &nets[i]->mib;   /* set mib pointer */
 8226928:	008209b4 	movhi	r2,2086
 822692c:	10b83d04 	addi	r2,r2,-7948
 8226930:	e0fffe17 	ldw	r3,-8(fp)
 8226934:	18c7883a 	add	r3,r3,r3
 8226938:	18c7883a 	add	r3,r3,r3
 822693c:	10c5883a 	add	r2,r2,r3
 8226940:	11000017 	ldw	r4,0(r2)
 8226944:	008209b4 	movhi	r2,2086
 8226948:	10b83d04 	addi	r2,r2,-7948
 822694c:	e0fffe17 	ldw	r3,-8(fp)
 8226950:	18c7883a 	add	r3,r3,r3
 8226954:	18c7883a 	add	r3,r3,r3
 8226958:	10c5883a 	add	r2,r2,r3
 822695c:	10800017 	ldw	r2,0(r2)
 8226960:	10801204 	addi	r2,r2,72
 8226964:	20802715 	stw	r2,156(r4)

      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
 8226968:	008209b4 	movhi	r2,2086
 822696c:	10b83d04 	addi	r2,r2,-7948
 8226970:	e0fffe17 	ldw	r3,-8(fp)
 8226974:	18c7883a 	add	r3,r3,r3
 8226978:	18c7883a 	add	r3,r3,r3
 822697c:	10c5883a 	add	r2,r2,r3
 8226980:	10800017 	ldw	r2,0(r2)
 8226984:	100b883a 	mov	r5,r2
 8226988:	010209b4 	movhi	r4,2086
 822698c:	213a7e04 	addi	r4,r4,-5640
 8226990:	822cfd80 	call	822cfd8 <putq>
{
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 8226994:	e0bffe17 	ldw	r2,-8(fp)
 8226998:	10800044 	addi	r2,r2,1
 822699c:	e0bffe15 	stw	r2,-8(fp)
 82269a0:	e0bffe17 	ldw	r2,-8(fp)
 82269a4:	10800110 	cmplti	r2,r2,4
 82269a8:	103fd31e 	bne	r2,zero,82268f8 <ip_startup+0x18>
      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
   }

   /* call port routine to locate and init network interfaces. */
   ifNumber = (unsigned)prep_ifaces(ifNumber);
 82269ac:	d0a08417 	ldw	r2,-32240(gp)
 82269b0:	1009883a 	mov	r4,r2
 82269b4:	8243c680 	call	8243c68 <prep_ifaces>
 82269b8:	d0a08415 	stw	r2,-32240(gp)

   if (ifNumber < 1)    /* no static interfaces? */
 82269bc:	d0a08417 	ldw	r2,-32240(gp)
 82269c0:	1000031e 	bne	r2,zero,82269d0 <ip_startup+0xf0>
#ifdef DYNAMIC_IFACES
      /* print a debug message and hope user knows what he's doing */
      dprintf("unable to find any working interfaces");
#else /* static ifaces only */
      /* no static and no dynamic interfaces is probably a bug... */
      return("unable to find any working interfaces");
 82269c4:	00820974 	movhi	r2,2085
 82269c8:	10801104 	addi	r2,r2,68
 82269cc:	00006806 	br	8226b70 <ip_startup+0x290>
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 82269d0:	d0a08417 	ldw	r2,-32240(gp)
 82269d4:	e0bffe15 	stw	r2,-8(fp)
 82269d8:	00001506 	br	8226a30 <ip_startup+0x150>
   {
      qdel(&netlist, (qp)nets[i]);  /* remove from queue */
 82269dc:	008209b4 	movhi	r2,2086
 82269e0:	10b83d04 	addi	r2,r2,-7948
 82269e4:	e0fffe17 	ldw	r3,-8(fp)
 82269e8:	18c7883a 	add	r3,r3,r3
 82269ec:	18c7883a 	add	r3,r3,r3
 82269f0:	10c5883a 	add	r2,r2,r3
 82269f4:	10800017 	ldw	r2,0(r2)
 82269f8:	100b883a 	mov	r5,r2
 82269fc:	010209b4 	movhi	r4,2086
 8226a00:	213a7e04 	addi	r4,r4,-5640
 8226a04:	822d0880 	call	822d088 <qdel>
      nets[i] = NULL;               /* remove from array */
 8226a08:	008209b4 	movhi	r2,2086
 8226a0c:	10b83d04 	addi	r2,r2,-7948
 8226a10:	e0fffe17 	ldw	r3,-8(fp)
 8226a14:	18c7883a 	add	r3,r3,r3
 8226a18:	18c7883a 	add	r3,r3,r3
 8226a1c:	10c5883a 	add	r2,r2,r3
 8226a20:	10000015 	stw	zero,0(r2)
      return("unable to find any working interfaces");
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 8226a24:	e0bffe17 	ldw	r2,-8(fp)
 8226a28:	10800044 	addi	r2,r2,1
 8226a2c:	e0bffe15 	stw	r2,-8(fp)
 8226a30:	e0bffe17 	ldw	r2,-8(fp)
 8226a34:	10800110 	cmplti	r2,r2,4
 8226a38:	103fe81e 	bne	r2,zero,82269dc <ip_startup+0xfc>
   /* The sequence of events when initing the net & interface systems 
    * is very important. Be very carefull about altering the order of 
    * the following statements. 
    */
   /* once these are done, we should call ip_exit before quiting IP */
   clock_init();           /* start clock system */
 8226a3c:	822d7140 	call	822d714 <clock_init>
   exit_hook(clock_c);
 8226a40:	010208f4 	movhi	r4,2083
 8226a44:	2135d304 	addi	r4,r4,-10420
 8226a48:	8226b840 	call	8226b84 <exit_hook>

   e = Netinit();    /* start net interface(s) */
 8226a4c:	8225afc0 	call	8225afc <Netinit>
 8226a50:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 8226a54:	e0bfff17 	ldw	r2,-4(fp)
 8226a58:	10000326 	beq	r2,zero,8226a68 <ip_startup+0x188>
   {
      return("unable to initialize net");
 8226a5c:	00820974 	movhi	r2,2085
 8226a60:	10801b04 	addi	r2,r2,108
 8226a64:	00004206 	br	8226b70 <ip_startup+0x290>
   }

#ifdef INCLUDE_ARP
   e = etainit();          /* startup ARP layer */
 8226a68:	823d9bc0 	call	823d9bc <etainit>
 8226a6c:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 8226a70:	e0bfff17 	ldw	r2,-4(fp)
 8226a74:	10000426 	beq	r2,zero,8226a88 <ip_startup+0x1a8>
   {
      ip_exit();
 8226a78:	8226bf40 	call	8226bf4 <ip_exit>
      return("unable to initialize arp");
 8226a7c:	00820974 	movhi	r2,2085
 8226a80:	10802204 	addi	r2,r2,136
 8226a84:	00003a06 	br	8226b70 <ip_startup+0x290>
   }
#endif

#ifdef IP_V4
   e = ip_init();       /* start up IP layer */
 8226a88:	823f00c0 	call	823f00c <ip_init>
 8226a8c:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 8226a90:	e0bfff17 	ldw	r2,-4(fp)
 8226a94:	10000426 	beq	r2,zero,8226aa8 <ip_startup+0x1c8>
   {
      ip_exit();
 8226a98:	8226bf40 	call	8226bf4 <ip_exit>
      return("unable to initialize IP");
 8226a9c:	00820974 	movhi	r2,2085
 8226aa0:	10802904 	addi	r2,r2,164
 8226aa4:	00003206 	br	8226b70 <ip_startup+0x290>

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Join the All hosts group on every interface that IP multicast is
    * supported
    */
   e = igmp_init();         /* Initialize igmp */
 8226aa8:	8226d480 	call	8226d48 <igmp_init>
 8226aac:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 8226ab0:	e0bfff17 	ldw	r2,-4(fp)
 8226ab4:	10000326 	beq	r2,zero,8226ac4 <ip_startup+0x1e4>
   {
      ip_exit();
 8226ab8:	8226bf40 	call	8226bf4 <ip_exit>
      return(ipmcfail_str);
 8226abc:	d0a03017 	ldw	r2,-32576(gp)
 8226ac0:	00002b06 	br	8226b70 <ip_startup+0x290>
   }

   for (i = 0; i < (int)ifNumber; i++)
 8226ac4:	e03ffe15 	stw	zero,-8(fp)
 8226ac8:	00001b06 	br	8226b38 <ip_startup+0x258>
   {
      if (nets[i]->n_mcastlist != NULL)
 8226acc:	008209b4 	movhi	r2,2086
 8226ad0:	10b83d04 	addi	r2,r2,-7948
 8226ad4:	e0fffe17 	ldw	r3,-8(fp)
 8226ad8:	18c7883a 	add	r3,r3,r3
 8226adc:	18c7883a 	add	r3,r3,r3
 8226ae0:	10c5883a 	add	r2,r2,r3
 8226ae4:	10800017 	ldw	r2,0(r2)
 8226ae8:	10802b17 	ldw	r2,172(r2)
 8226aec:	10000f26 	beq	r2,zero,8226b2c <ip_startup+0x24c>
         if ((in_addmulti(&igmp_all_hosts_group, nets[i], 4) == NULL))
 8226af0:	008209b4 	movhi	r2,2086
 8226af4:	10b83d04 	addi	r2,r2,-7948
 8226af8:	e0fffe17 	ldw	r3,-8(fp)
 8226afc:	18c7883a 	add	r3,r3,r3
 8226b00:	18c7883a 	add	r3,r3,r3
 8226b04:	10c5883a 	add	r2,r2,r3
 8226b08:	10800017 	ldw	r2,0(r2)
 8226b0c:	01800104 	movi	r6,4
 8226b10:	100b883a 	mov	r5,r2
 8226b14:	d1208804 	addi	r4,gp,-32224
 8226b18:	82439ac0 	call	82439ac <in_addmulti>
 8226b1c:	1000031e 	bne	r2,zero,8226b2c <ip_startup+0x24c>
      {
         ip_exit();
 8226b20:	8226bf40 	call	8226bf4 <ip_exit>
         return(ipmcfail_str);
 8226b24:	d0a03017 	ldw	r2,-32576(gp)
 8226b28:	00001106 	br	8226b70 <ip_startup+0x290>
   {
      ip_exit();
      return(ipmcfail_str);
   }

   for (i = 0; i < (int)ifNumber; i++)
 8226b2c:	e0bffe17 	ldw	r2,-8(fp)
 8226b30:	10800044 	addi	r2,r2,1
 8226b34:	e0bffe15 	stw	r2,-8(fp)
 8226b38:	d0a08417 	ldw	r2,-32240(gp)
 8226b3c:	1007883a 	mov	r3,r2
 8226b40:	e0bffe17 	ldw	r2,-8(fp)
 8226b44:	10ffe116 	blt	r2,r3,8226acc <ip_startup+0x1ec>
      }
   }
#endif /* IP_MULTICAST and (IGMPv1 or IGMPv2) */   

#ifdef INCLUDE_TCP
   e = tcpinit();
 8226b48:	823af3c0 	call	823af3c <tcpinit>
 8226b4c:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 8226b50:	e0bfff17 	ldw	r2,-4(fp)
 8226b54:	10000426 	beq	r2,zero,8226b68 <ip_startup+0x288>
   {
      ip_exit();
 8226b58:	8226bf40 	call	8226bf4 <ip_exit>
      return("unable to initialize TCP");
 8226b5c:	00820974 	movhi	r2,2085
 8226b60:	10802f04 	addi	r2,r2,188
 8226b64:	00000206 	br	8226b70 <ip_startup+0x290>
   /* setup event map for (UDP and TCP) socket library's events (such as 
    * those used by tcp_sleep () and tcp_wakeup ()).  These events either 
    * map into operating system primitives such as events or semaphores, 
    * or into task suspend and task resume mechanisms.
    */
   evtmap_setup ();
 8226b68:	8243d100 	call	8243d10 <evtmap_setup>
      return("unable to initialize IP Filter table");
   else
      exit_hook(ipf_cleanup);
#endif

   return(NULL);     /* we got through with no errors */
 8226b6c:	0005883a 	mov	r2,zero
}
 8226b70:	e037883a 	mov	sp,fp
 8226b74:	dfc00117 	ldw	ra,4(sp)
 8226b78:	df000017 	ldw	fp,0(sp)
 8226b7c:	dec00204 	addi	sp,sp,8
 8226b80:	f800283a 	ret

08226b84 <exit_hook>:
 * RETURNS: 
 */

void
exit_hook(void (*func)(void))
{
 8226b84:	defffd04 	addi	sp,sp,-12
 8226b88:	dfc00215 	stw	ra,8(sp)
 8226b8c:	df000115 	stw	fp,4(sp)
 8226b90:	df000104 	addi	fp,sp,4
 8226b94:	e13fff15 	stw	r4,-4(fp)
   if (nclosers >= (NUMCLOSERS-1))
 8226b98:	d0a08517 	ldw	r2,-32236(gp)
 8226b9c:	10800390 	cmplti	r2,r2,14
 8226ba0:	1000031e 	bne	r2,zero,8226bb0 <exit_hook+0x2c>
      panic("exit_hook");
 8226ba4:	01020974 	movhi	r4,2085
 8226ba8:	21003604 	addi	r4,r4,216
 8226bac:	8228ca40 	call	8228ca4 <panic>

   closers[++nclosers] = func;
 8226bb0:	d0a08517 	ldw	r2,-32236(gp)
 8226bb4:	10800044 	addi	r2,r2,1
 8226bb8:	d0a08515 	stw	r2,-32236(gp)
 8226bbc:	d0e08517 	ldw	r3,-32236(gp)
 8226bc0:	00820974 	movhi	r2,2085
 8226bc4:	10921c04 	addi	r2,r2,18544
 8226bc8:	18c7883a 	add	r3,r3,r3
 8226bcc:	18c7883a 	add	r3,r3,r3
 8226bd0:	10c5883a 	add	r2,r2,r3
 8226bd4:	e0ffff17 	ldw	r3,-4(fp)
 8226bd8:	10c00015 	stw	r3,0(r2)
}
 8226bdc:	0001883a 	nop
 8226be0:	e037883a 	mov	sp,fp
 8226be4:	dfc00117 	ldw	ra,4(sp)
 8226be8:	df000017 	ldw	fp,0(sp)
 8226bec:	dec00204 	addi	sp,sp,8
 8226bf0:	f800283a 	ret

08226bf4 <ip_exit>:
 * RETURNS: void
 */

void
ip_exit()
{
 8226bf4:	defffd04 	addi	sp,sp,-12
 8226bf8:	dfc00215 	stw	ra,8(sp)
 8226bfc:	df000115 	stw	fp,4(sp)
 8226c00:	df000104 	addi	fp,sp,4
   int   n;

   for (n=nclosers; n; n--)
 8226c04:	d0a08517 	ldw	r2,-32236(gp)
 8226c08:	e0bfff15 	stw	r2,-4(fp)
 8226c0c:	00002506 	br	8226ca4 <ip_exit+0xb0>
   {
#ifdef NPDEBUG
      dprintf("ip_exit: calling func %p\n", closers[n]);
 8226c10:	00820974 	movhi	r2,2085
 8226c14:	10921c04 	addi	r2,r2,18544
 8226c18:	e0ffff17 	ldw	r3,-4(fp)
 8226c1c:	18c7883a 	add	r3,r3,r3
 8226c20:	18c7883a 	add	r3,r3,r3
 8226c24:	10c5883a 	add	r2,r2,r3
 8226c28:	10800017 	ldw	r2,0(r2)
 8226c2c:	100b883a 	mov	r5,r2
 8226c30:	01020974 	movhi	r4,2085
 8226c34:	21003904 	addi	r4,r4,228
 8226c38:	82033fc0 	call	82033fc <printf>
#endif
      if(closers[n])
 8226c3c:	00820974 	movhi	r2,2085
 8226c40:	10921c04 	addi	r2,r2,18544
 8226c44:	e0ffff17 	ldw	r3,-4(fp)
 8226c48:	18c7883a 	add	r3,r3,r3
 8226c4c:	18c7883a 	add	r3,r3,r3
 8226c50:	10c5883a 	add	r2,r2,r3
 8226c54:	10800017 	ldw	r2,0(r2)
 8226c58:	10000f26 	beq	r2,zero,8226c98 <ip_exit+0xa4>
      {
         (*closers[n])();
 8226c5c:	00820974 	movhi	r2,2085
 8226c60:	10921c04 	addi	r2,r2,18544
 8226c64:	e0ffff17 	ldw	r3,-4(fp)
 8226c68:	18c7883a 	add	r3,r3,r3
 8226c6c:	18c7883a 	add	r3,r3,r3
 8226c70:	10c5883a 	add	r2,r2,r3
 8226c74:	10800017 	ldw	r2,0(r2)
 8226c78:	103ee83a 	callr	r2
         closers[n] = NULL;
 8226c7c:	00820974 	movhi	r2,2085
 8226c80:	10921c04 	addi	r2,r2,18544
 8226c84:	e0ffff17 	ldw	r3,-4(fp)
 8226c88:	18c7883a 	add	r3,r3,r3
 8226c8c:	18c7883a 	add	r3,r3,r3
 8226c90:	10c5883a 	add	r2,r2,r3
 8226c94:	10000015 	stw	zero,0(r2)
void
ip_exit()
{
   int   n;

   for (n=nclosers; n; n--)
 8226c98:	e0bfff17 	ldw	r2,-4(fp)
 8226c9c:	10bfffc4 	addi	r2,r2,-1
 8226ca0:	e0bfff15 	stw	r2,-4(fp)
 8226ca4:	e0bfff17 	ldw	r2,-4(fp)
 8226ca8:	103fd91e 	bne	r2,zero,8226c10 <ip_exit+0x1c>
      {
         (*closers[n])();
         closers[n] = NULL;
      }
   }
}
 8226cac:	0001883a 	nop
 8226cb0:	e037883a 	mov	sp,fp
 8226cb4:	dfc00117 	ldw	ra,4(sp)
 8226cb8:	df000017 	ldw	fp,0(sp)
 8226cbc:	dec00204 	addi	sp,sp,8
 8226cc0:	f800283a 	ret

08226cc4 <if_netnumber>:
 * RETURNS: net index for passed net pointer
 */

int
if_netnumber(NET nptr)
{
 8226cc4:	defffb04 	addi	sp,sp,-20
 8226cc8:	dfc00415 	stw	ra,16(sp)
 8226ccc:	df000315 	stw	fp,12(sp)
 8226cd0:	df000304 	addi	fp,sp,12
 8226cd4:	e13fff15 	stw	r4,-4(fp)
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 8226cd8:	008209b4 	movhi	r2,2086
 8226cdc:	10ba7e04 	addi	r2,r2,-5640
 8226ce0:	10800017 	ldw	r2,0(r2)
 8226ce4:	e0bffe15 	stw	r2,-8(fp)
 8226ce8:	e03ffd15 	stw	zero,-12(fp)
 8226cec:	00000b06 	br	8226d1c <if_netnumber+0x58>
   {
      if(ifp == nptr)
 8226cf0:	e0fffe17 	ldw	r3,-8(fp)
 8226cf4:	e0bfff17 	ldw	r2,-4(fp)
 8226cf8:	1880021e 	bne	r3,r2,8226d04 <if_netnumber+0x40>
        return (int)i;
 8226cfc:	e0bffd17 	ldw	r2,-12(fp)
 8226d00:	00000c06 	br	8226d34 <if_netnumber+0x70>
if_netnumber(NET nptr)
{
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 8226d04:	e0bffe17 	ldw	r2,-8(fp)
 8226d08:	10800017 	ldw	r2,0(r2)
 8226d0c:	e0bffe15 	stw	r2,-8(fp)
 8226d10:	e0bffd17 	ldw	r2,-12(fp)
 8226d14:	10800044 	addi	r2,r2,1
 8226d18:	e0bffd15 	stw	r2,-12(fp)
 8226d1c:	e0bffe17 	ldw	r2,-8(fp)
 8226d20:	103ff31e 	bne	r2,zero,8226cf0 <if_netnumber+0x2c>
   {
      if(ifp == nptr)
        return (int)i;
   }

   panic("bad net ptr");
 8226d24:	01020974 	movhi	r4,2085
 8226d28:	21004004 	addi	r4,r4,256
 8226d2c:	8228ca40 	call	8228ca4 <panic>
   return 0;
 8226d30:	0005883a 	mov	r2,zero
}
 8226d34:	e037883a 	mov	sp,fp
 8226d38:	dfc00117 	ldw	ra,4(sp)
 8226d3c:	df000017 	ldw	fp,0(sp)
 8226d40:	dec00204 	addi	sp,sp,8
 8226d44:	f800283a 	ret

08226d48 <igmp_init>:
 *
 * OUTPUT: None.
 */

int igmp_init(void)
{
 8226d48:	defffe04 	addi	sp,sp,-8
 8226d4c:	df000115 	stw	fp,4(sp)
 8226d50:	df000104 	addi	fp,sp,4
   NET ifp;

   /*
    * To avoid byte-swapping the same value over and over again.
    */
   igmp_all_hosts_group = htonl(INADDR_ALLHOSTS_GROUP);
 8226d54:	00804034 	movhi	r2,256
 8226d58:	10803804 	addi	r2,r2,224
 8226d5c:	d0a08815 	stw	r2,-32224(gp)
   igmp_all_rtrs_group = htonl(INADDR_ALLRTRS_GROUP);
 8226d60:	00808034 	movhi	r2,512
 8226d64:	10803804 	addi	r2,r2,224
 8226d68:	d0a08915 	stw	r2,-32220(gp)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 8226d6c:	008209b4 	movhi	r2,2086
 8226d70:	10ba7e04 	addi	r2,r2,-5640
 8226d74:	10800017 	ldw	r2,0(r2)
 8226d78:	e0bfff15 	stw	r2,-4(fp)
 8226d7c:	00001006 	br	8226dc0 <igmp_init+0x78>
   {
      if (ifp->igmp_oper_mode == IGMP_MODE_V1)
 8226d80:	e0bfff17 	ldw	r2,-4(fp)
 8226d84:	10802f03 	ldbu	r2,188(r2)
 8226d88:	10803fcc 	andi	r2,r2,255
 8226d8c:	10800058 	cmpnei	r2,r2,1
 8226d90:	1000041e 	bne	r2,zero,8226da4 <igmp_init+0x5c>
      {
         ifp->igmpv1_rtr_present = 1;
 8226d94:	e0bfff17 	ldw	r2,-4(fp)
 8226d98:	00c00044 	movi	r3,1
 8226d9c:	10c02d05 	stb	r3,180(r2)
 8226da0:	00000406 	br	8226db4 <igmp_init+0x6c>
      }
      else
      {
         ifp->igmpv1_rtr_present = 0;
 8226da4:	e0bfff17 	ldw	r2,-4(fp)
 8226da8:	10002d05 	stb	zero,180(r2)
         /* not really required, only referred to if IGMPv1 router is 
          * "present" */
         ifp->igmpv1_query_rcvd_time = 0;
 8226dac:	e0bfff17 	ldw	r2,-4(fp)
 8226db0:	10002e15 	stw	zero,184(r2)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 8226db4:	e0bfff17 	ldw	r2,-4(fp)
 8226db8:	10800017 	ldw	r2,0(r2)
 8226dbc:	e0bfff15 	stw	r2,-4(fp)
 8226dc0:	e0bfff17 	ldw	r2,-4(fp)
 8226dc4:	103fee1e 	bne	r2,zero,8226d80 <igmp_init+0x38>
   }

   /*
    * Call igmp_fasttimo PR_FASTHZ (5) times per second
    */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 8226dc8:	d0a0a817 	ldw	r2,-32096(gp)
 8226dcc:	10800504 	addi	r2,r2,20
 8226dd0:	d0a08715 	stw	r2,-32228(gp)

   /* there are no timers running initially */
   igmp_timers_are_running = 0;
 8226dd4:	d0208615 	stw	zero,-32232(gp)

   return IGMP_OK;
 8226dd8:	0005883a 	mov	r2,zero
}
 8226ddc:	e037883a 	mov	sp,fp
 8226de0:	df000017 	ldw	fp,0(sp)
 8226de4:	dec00104 	addi	sp,sp,4
 8226de8:	f800283a 	ret

08226dec <igmp_input>:
 * returned if the operating mode is not correctly configured
 * to a valid IGMP operating mode.
 */

int igmp_input (PACKET p)
{
 8226dec:	defffb04 	addi	sp,sp,-20
 8226df0:	dfc00415 	stw	ra,16(sp)
 8226df4:	df000315 	stw	fp,12(sp)
 8226df8:	df000304 	addi	fp,sp,12
 8226dfc:	e13fff15 	stw	r4,-4(fp)
   u_char mode;
   int rc;
     
   ++igmpstats.igmp_total_rcvd;
 8226e00:	008209b4 	movhi	r2,2086
 8226e04:	10b84104 	addi	r2,r2,-7932
 8226e08:	10800017 	ldw	r2,0(r2)
 8226e0c:	10c00044 	addi	r3,r2,1
 8226e10:	008209b4 	movhi	r2,2086
 8226e14:	10b84104 	addi	r2,r2,-7932
 8226e18:	10c00015 	stw	r3,0(r2)
   
   /* validate the received packet; if validation fails,
    * drop the packet and return */
   if ((rc = igmp_validate (p)) != IGMP_OK) goto end;
 8226e1c:	e13fff17 	ldw	r4,-4(fp)
 8226e20:	82275b00 	call	82275b0 <igmp_validate>
 8226e24:	e0bffd15 	stw	r2,-12(fp)
 8226e28:	e0bffd17 	ldw	r2,-12(fp)
 8226e2c:	10001a1e 	bne	r2,zero,8226e98 <igmp_input+0xac>

   /* determine the operating mode for IGMP on the ingress link */
   mode = p->net->igmp_oper_mode;
 8226e30:	e0bfff17 	ldw	r2,-4(fp)
 8226e34:	10800617 	ldw	r2,24(r2)
 8226e38:	10802f03 	ldbu	r2,188(r2)
 8226e3c:	e0bffe05 	stb	r2,-8(fp)
   
   /* feed packet to IGMPv1 or IGMPv2 code based on the operating
    * mode of the ingress link */
   switch (mode)
 8226e40:	e0bffe03 	ldbu	r2,-8(fp)
 8226e44:	10c00060 	cmpeqi	r3,r2,1
 8226e48:	1800031e 	bne	r3,zero,8226e58 <igmp_input+0x6c>
 8226e4c:	108000a0 	cmpeqi	r2,r2,2
 8226e50:	1000041e 	bne	r2,zero,8226e64 <igmp_input+0x78>
 8226e54:	00000606 	br	8226e70 <igmp_input+0x84>
   {
#ifdef IGMP_V1   
      case IGMP_MODE_V1:   
         return (igmpv1_input (p)); 
 8226e58:	e13fff17 	ldw	r4,-4(fp)
 8226e5c:	82455680 	call	8245568 <igmpv1_input>
 8226e60:	00001506 	br	8226eb8 <igmp_input+0xcc>
#endif
#ifdef IGMP_V2         
      case IGMP_MODE_V2:       
         return (igmpv2_input (p));
 8226e64:	e13fff17 	ldw	r4,-4(fp)
 8226e68:	824580c0 	call	824580c <igmpv2_input>
 8226e6c:	00001206 	br	8226eb8 <igmp_input+0xcc>
#endif
      default:
         ++igmpstats.igmp_bad_oper_mode;     
 8226e70:	008209b4 	movhi	r2,2086
 8226e74:	10b84104 	addi	r2,r2,-7932
 8226e78:	10800d17 	ldw	r2,52(r2)
 8226e7c:	10c00044 	addi	r3,r2,1
 8226e80:	008209b4 	movhi	r2,2086
 8226e84:	10b84104 	addi	r2,r2,-7932
 8226e88:	10c00d15 	stw	r3,52(r2)
         rc = IGMP_ERR;
 8226e8c:	00bfffc4 	movi	r2,-1
 8226e90:	e0bffd15 	stw	r2,-12(fp)
         break;
 8226e94:	00000106 	br	8226e9c <igmp_input+0xb0>
     
   ++igmpstats.igmp_total_rcvd;
   
   /* validate the received packet; if validation fails,
    * drop the packet and return */
   if ((rc = igmp_validate (p)) != IGMP_OK) goto end;
 8226e98:	0001883a 	nop
         break;
   }
   
end:   
   /* return packet buffer back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8226e9c:	01000084 	movi	r4,2
 8226ea0:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   pk_free(p);
 8226ea4:	e13fff17 	ldw	r4,-4(fp)
 8226ea8:	822cd980 	call	822cd98 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8226eac:	01000084 	movi	r4,2
 8226eb0:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      
   return rc;
 8226eb4:	e0bffd17 	ldw	r2,-12(fp)
}
 8226eb8:	e037883a 	mov	sp,fp
 8226ebc:	dfc00117 	ldw	ra,4(sp)
 8226ec0:	df000017 	ldw	fp,0(sp)
 8226ec4:	dec00204 	addi	sp,sp,8
 8226ec8:	f800283a 	ret

08226ecc <igmp_fasttimo>:
 *
 * OUTPUT: None.
 */

void igmp_fasttimo (void)
{
 8226ecc:	defffc04 	addi	sp,sp,-16
 8226ed0:	dfc00315 	stw	ra,12(sp)
 8226ed4:	df000215 	stw	fp,8(sp)
 8226ed8:	df000204 	addi	fp,sp,8
   struct in_multi * inm;
   NET ifp;
     
   LOCK_NET_RESOURCE (NET_RESID);
 8226edc:	0009883a 	mov	r4,zero
 8226ee0:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   
   /*
    * Quick check to see if any work needs to be done, in order
    * to minimize the overhead of fasttimo processing.
    */
   if (!igmp_timers_are_running)
 8226ee4:	d0a08617 	ldw	r2,-32232(gp)
 8226ee8:	1000031e 	bne	r2,zero,8226ef8 <igmp_fasttimo+0x2c>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
 8226eec:	0009883a 	mov	r4,zero
 8226ef0:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return;
 8226ef4:	00004d06 	br	822702c <igmp_fasttimo+0x160>
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 8226ef8:	008209b4 	movhi	r2,2086
 8226efc:	10ba7e04 	addi	r2,r2,-5640
 8226f00:	10800017 	ldw	r2,0(r2)
 8226f04:	e0bfff15 	stw	r2,-4(fp)
 8226f08:	00004006 	br	822700c <igmp_fasttimo+0x140>
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 8226f0c:	e0bfff17 	ldw	r2,-4(fp)
 8226f10:	10802c17 	ldw	r2,176(r2)
 8226f14:	e0bffe15 	stw	r2,-8(fp)
 8226f18:	00003706 	br	8226ff8 <igmp_fasttimo+0x12c>
      {
         /* skip IPv6 entries */
         if (inm->inm_addr == 0) 
 8226f1c:	e0bffe17 	ldw	r2,-8(fp)
 8226f20:	10800017 	ldw	r2,0(r2)
 8226f24:	10003026 	beq	r2,zero,8226fe8 <igmp_fasttimo+0x11c>
               continue;

         if (inm->inm_timer == 0)   /* timer not set */
 8226f28:	e0bffe17 	ldw	r2,-8(fp)
 8226f2c:	10800317 	ldw	r2,12(r2)
 8226f30:	10002e26 	beq	r2,zero,8226fec <igmp_fasttimo+0x120>
         {
            /* do nothing */
         }
         else if (--inm->inm_timer == 0)  /* timer expired */
 8226f34:	e0bffe17 	ldw	r2,-8(fp)
 8226f38:	10800317 	ldw	r2,12(r2)
 8226f3c:	10ffffc4 	addi	r3,r2,-1
 8226f40:	e0bffe17 	ldw	r2,-8(fp)
 8226f44:	10c00315 	stw	r3,12(r2)
 8226f48:	e0bffe17 	ldw	r2,-8(fp)
 8226f4c:	10800317 	ldw	r2,12(r2)
 8226f50:	1000261e 	bne	r2,zero,8226fec <igmp_fasttimo+0x120>
         {
            /* send membership report in appropriate format */
            if (ifp->igmpv1_rtr_present)
 8226f54:	e0bfff17 	ldw	r2,-4(fp)
 8226f58:	10802d03 	ldbu	r2,180(r2)
 8226f5c:	10803fcc 	andi	r2,r2,255
 8226f60:	10000426 	beq	r2,zero,8226f74 <igmp_fasttimo+0xa8>
            {
               /* always true for IGMPv1, may be true for IGMPv2 */
               igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 8226f64:	e17ffe17 	ldw	r5,-8(fp)
 8226f68:	01000484 	movi	r4,18
 8226f6c:	82270400 	call	8227040 <igmp_send>
 8226f70:	00000306 	br	8226f80 <igmp_fasttimo+0xb4>
            }
            else
            {
               igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 8226f74:	e17ffe17 	ldw	r5,-8(fp)
 8226f78:	01000584 	movi	r4,22
 8226f7c:	82270400 	call	8227040 <igmp_send>

            /* for IGMPv2, indicate that we were the last to send 
             * a Report for this multicast group (relevant for 
             * IGMPv2 only).  also check to see if we should mark 
             * the IGMPv1 router as "absent". */
            if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 8226f80:	e0bfff17 	ldw	r2,-4(fp)
 8226f84:	10802f03 	ldbu	r2,188(r2)
 8226f88:	10803fcc 	andi	r2,r2,255
 8226f8c:	10800098 	cmpnei	r2,r2,2
 8226f90:	1000111e 	bne	r2,zero,8226fd8 <igmp_fasttimo+0x10c>
            {
               inm->last2send_report = IGMP_TRUE;
 8226f94:	e0bffe17 	ldw	r2,-8(fp)
 8226f98:	00c00044 	movi	r3,1
 8226f9c:	10c00405 	stb	r3,16(r2)
               
               if (ifp->igmpv1_rtr_present)
 8226fa0:	e0bfff17 	ldw	r2,-4(fp)
 8226fa4:	10802d03 	ldbu	r2,180(r2)
 8226fa8:	10803fcc 	andi	r2,r2,255
 8226fac:	10000a26 	beq	r2,zero,8226fd8 <igmp_fasttimo+0x10c>
               {
                  if (cticks > (ifp->igmpv1_query_rcvd_time + (IGMPv1_RTR_PRESENT_TMO * TPS)))
 8226fb0:	e0bfff17 	ldw	r2,-4(fp)
 8226fb4:	10c02e17 	ldw	r3,184(r2)
 8226fb8:	00a71014 	movui	r2,40000
 8226fbc:	1887883a 	add	r3,r3,r2
 8226fc0:	d0a0a817 	ldw	r2,-32096(gp)
 8226fc4:	1880042e 	bgeu	r3,r2,8226fd8 <igmp_fasttimo+0x10c>
                     /* we haven't heard from the IGMPv1 router for a duration
                      * greater than or equal to Version 1 Router Present Timeout 
                      * (400 seconds), and will now update the igmpv1_rtr_present 
                      * variable to reflect that.
                      */
                     ifp->igmpv1_rtr_present = IGMP_FALSE;
 8226fc8:	e0bfff17 	ldw	r2,-4(fp)
 8226fcc:	10002d05 	stb	zero,180(r2)
                     ifp->igmpv1_query_rcvd_time = 0;
 8226fd0:	e0bfff17 	ldw	r2,-4(fp)
 8226fd4:	10002e15 	stw	zero,184(r2)
                  }
               }  
            }

            /* decrement the count of running IGMP timers */
            --igmp_timers_are_running;
 8226fd8:	d0a08617 	ldw	r2,-32232(gp)
 8226fdc:	10bfffc4 	addi	r2,r2,-1
 8226fe0:	d0a08615 	stw	r2,-32232(gp)
 8226fe4:	00000106 	br	8226fec <igmp_fasttimo+0x120>
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
      {
         /* skip IPv6 entries */
         if (inm->inm_addr == 0) 
               continue;
 8226fe8:	0001883a 	nop
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 8226fec:	e0bffe17 	ldw	r2,-8(fp)
 8226ff0:	10800517 	ldw	r2,20(r2)
 8226ff4:	e0bffe15 	stw	r2,-8(fp)
 8226ff8:	e0bffe17 	ldw	r2,-8(fp)
 8226ffc:	103fc71e 	bne	r2,zero,8226f1c <igmp_fasttimo+0x50>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 8227000:	e0bfff17 	ldw	r2,-4(fp)
 8227004:	10800017 	ldw	r2,0(r2)
 8227008:	e0bfff15 	stw	r2,-4(fp)
 822700c:	e0bfff17 	ldw	r2,-4(fp)
 8227010:	103fbe1e 	bne	r2,zero,8226f0c <igmp_fasttimo+0x40>
      }     
   }

   /* Setup time for the next call into igmp_fasttimo ()
    * (200 ms later). */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 8227014:	d0a0a817 	ldw	r2,-32096(gp)
 8227018:	10800504 	addi	r2,r2,20
 822701c:	d0a08715 	stw	r2,-32228(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 8227020:	0009883a 	mov	r4,zero
 8227024:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   
   return;
 8227028:	0001883a 	nop
}
 822702c:	e037883a 	mov	sp,fp
 8227030:	dfc00117 	ldw	ra,4(sp)
 8227034:	df000017 	ldw	fp,0(sp)
 8227038:	dec00204 	addi	sp,sp,8
 822703c:	f800283a 	ret

08227040 <igmp_send>:
 *
 * OUTPUT: None.
 */

void igmp_send (u_char type, struct in_multi * inm)
{
 8227040:	deffde04 	addi	sp,sp,-136
 8227044:	dfc02115 	stw	ra,132(sp)
 8227048:	df002015 	stw	fp,128(sp)
 822704c:	df002004 	addi	fp,sp,128
 8227050:	2005883a 	mov	r2,r4
 8227054:	e17fff15 	stw	r5,-4(fp)
 8227058:	e0bffe05 	stb	r2,-8(fp)
   struct igmp * igmp;
   struct ip_moptions * imop;
   struct ip_moptions simo;
   struct ip * pip;
   u_char * tmpp;
   u_char opts [2] = {IP_RTR_ALERT_OPT, EOL_OPT};
 822705c:	00800504 	movi	r2,20
 8227060:	e0bffd05 	stb	r2,-12(fp)
 8227064:	e03ffd45 	stb	zero,-11(fp)
   u_char reqd_len;

   /* compute length of buffer required for outgoing packet.
    * also account for the length of the IP Router Alert 
    * option, if required. */   
   reqd_len = MaxLnh + sizeof (struct ip) + sizeof (struct igmp);
 8227068:	d0a08117 	ldw	r2,-32252(gp)
 822706c:	10800704 	addi	r2,r2,28
 8227070:	e0bfe205 	stb	r2,-120(fp)
   if ((type == IGMPv2_LEAVE_GROUP) || 
 8227074:	e0bffe03 	ldbu	r2,-8(fp)
 8227078:	108005e0 	cmpeqi	r2,r2,23
 822707c:	1000031e 	bne	r2,zero,822708c <igmp_send+0x4c>
 8227080:	e0bffe03 	ldbu	r2,-8(fp)
 8227084:	10800598 	cmpnei	r2,r2,22
 8227088:	1000031e 	bne	r2,zero,8227098 <igmp_send+0x58>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      reqd_len += IP_RTR_ALERT_OPT_SIZE;
 822708c:	e0bfe203 	ldbu	r2,-120(fp)
 8227090:	10800104 	addi	r2,r2,4
 8227094:	e0bfe205 	stb	r2,-120(fp)
   }

   /* obtain a packet to send the IGMP message */
   LOCK_NET_RESOURCE (FREEQ_RESID);
 8227098:	01000084 	movi	r4,2
 822709c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   p = pk_alloc (reqd_len);
 82270a0:	e0bfe203 	ldbu	r2,-120(fp)
 82270a4:	1009883a 	mov	r4,r2
 82270a8:	822ca480 	call	822ca48 <pk_alloc>
 82270ac:	e0bfe315 	stw	r2,-116(fp)
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 82270b0:	01000084 	movi	r4,2
 82270b4:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   
   /* log an error and return if the allocation fails */   
   if (!p)
 82270b8:	e0bfe317 	ldw	r2,-116(fp)
 82270bc:	1000081e 	bne	r2,zero,82270e0 <igmp_send+0xa0>
   {
      ++igmpstats.igmp_pkt_alloc_fail;
 82270c0:	008209b4 	movhi	r2,2086
 82270c4:	10b84104 	addi	r2,r2,-7932
 82270c8:	10800c17 	ldw	r2,48(r2)
 82270cc:	10c00044 	addi	r3,r2,1
 82270d0:	008209b4 	movhi	r2,2086
 82270d4:	10b84104 	addi	r2,r2,-7932
 82270d8:	10c00c15 	stw	r3,48(r2)
 82270dc:	00007a06 	br	82272c8 <igmp_send+0x288>
      return;
   }

   /* Need to fill in the source and destination ip addresses */
   pip = (struct ip *) p->nb_prot;
 82270e0:	e0bfe317 	ldw	r2,-116(fp)
 82270e4:	10800317 	ldw	r2,12(r2)
 82270e8:	e0bfe415 	stw	r2,-112(fp)
   pip->ip_src = inm->inm_netp->n_ipaddr;
 82270ec:	e0bfff17 	ldw	r2,-4(fp)
 82270f0:	10800117 	ldw	r2,4(r2)
 82270f4:	10c00a17 	ldw	r3,40(r2)
 82270f8:	e0bfe417 	ldw	r2,-112(fp)
 82270fc:	10c00315 	stw	r3,12(r2)
   /* Leave Group messages are sent to the all-routers multicast group */
   if (type == IGMPv2_LEAVE_GROUP)
 8227100:	e0bffe03 	ldbu	r2,-8(fp)
 8227104:	108005d8 	cmpnei	r2,r2,23
 8227108:	1000041e 	bne	r2,zero,822711c <igmp_send+0xdc>
   {
      /* igmp_all_rtrs_group is already in network byte order */
      pip->ip_dest = igmp_all_rtrs_group;
 822710c:	d0e08917 	ldw	r3,-32220(gp)
 8227110:	e0bfe417 	ldw	r2,-112(fp)
 8227114:	10c00415 	stw	r3,16(r2)
 8227118:	00000406 	br	822712c <igmp_send+0xec>
   }
   else
      pip->ip_dest = inm->inm_addr;
 822711c:	e0bfff17 	ldw	r2,-4(fp)
 8227120:	10c00017 	ldw	r3,0(r2)
 8227124:	e0bfe417 	ldw	r2,-112(fp)
 8227128:	10c00415 	stw	r3,16(r2)
   
   p->fhost = pip->ip_dest;
 822712c:	e0bfe417 	ldw	r2,-112(fp)
 8227130:	10c00417 	ldw	r3,16(r2)
 8227134:	e0bfe317 	ldw	r2,-116(fp)
 8227138:	10c00715 	stw	r3,28(r2)

   tmpp = (((u_char *) p->nb_prot) + sizeof (struct ip));
 822713c:	e0bfe317 	ldw	r2,-116(fp)
 8227140:	10800317 	ldw	r2,12(r2)
 8227144:	10800504 	addi	r2,r2,20
 8227148:	e0bfe015 	stw	r2,-128(fp)

   /* when transmitting an IGMP packet, our IGMP module will insert
    * data for the Router Alert option in the following types of
    * packets: Version 2 Membership Report (0x16) and Leave Group 
    * (0x17) */
   if ((type == IGMPv2_LEAVE_GROUP) || 
 822714c:	e0bffe03 	ldbu	r2,-8(fp)
 8227150:	108005e0 	cmpeqi	r2,r2,23
 8227154:	1000031e 	bne	r2,zero,8227164 <igmp_send+0x124>
 8227158:	e0bffe03 	ldbu	r2,-8(fp)
 822715c:	10800598 	cmpnei	r2,r2,22
 8227160:	1000061e 	bne	r2,zero,822717c <igmp_send+0x13c>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      /* provide space for ip_write2 () to write option-related data */
      tmpp += IP_RTR_ALERT_OPT_SIZE;
 8227164:	e0bfe017 	ldw	r2,-128(fp)
 8227168:	10800104 	addi	r2,r2,4
 822716c:	e0bfe015 	stw	r2,-128(fp)
      optp = &(opts [0]); /* one option (IP Router Alert) */
 8227170:	e0bffd04 	addi	r2,fp,-12
 8227174:	e0bfe115 	stw	r2,-124(fp)
 8227178:	00000306 	br	8227188 <igmp_send+0x148>
   }
   /* outgoing packet does not require any options */
   else 
      optp = &(opts [1]);
 822717c:	e0bffd04 	addi	r2,fp,-12
 8227180:	10800044 	addi	r2,r2,1
 8227184:	e0bfe115 	stw	r2,-124(fp)
   /* point to the start of the IGMP header */
   igmp = (struct igmp *) tmpp;
 8227188:	e0bfe017 	ldw	r2,-128(fp)
 822718c:	e0bfe515 	stw	r2,-108(fp)
   
   igmp->igmp_type = type;
 8227190:	e0bfe517 	ldw	r2,-108(fp)
 8227194:	e0fffe03 	ldbu	r3,-8(fp)
 8227198:	10c00005 	stb	r3,0(r2)
   igmp->igmp_code = 0;
 822719c:	e0bfe517 	ldw	r2,-108(fp)
 82271a0:	10000045 	stb	zero,1(r2)
   
   /* all messages (Report or Leave) have Group Address field 
    * set to the group being reported or left */
   igmp->igmp_group = inm->inm_addr;
 82271a4:	e0bfff17 	ldw	r2,-4(fp)
 82271a8:	10c00017 	ldw	r3,0(r2)
 82271ac:	e0bfe517 	ldw	r2,-108(fp)
 82271b0:	10c00115 	stw	r3,4(r2)
   igmp->igmp_cksum = 0;
 82271b4:	e0bfe517 	ldw	r2,-108(fp)
 82271b8:	1000008d 	sth	zero,2(r2)
   igmp->igmp_cksum = ~cksum((void*)igmp, IGMP_MINLEN>>1);
 82271bc:	01400104 	movi	r5,4
 82271c0:	e13fe517 	ldw	r4,-108(fp)
 82271c4:	82288100 	call	8228810 <cksum>
 82271c8:	0084303a 	nor	r2,zero,r2
 82271cc:	1007883a 	mov	r3,r2
 82271d0:	e0bfe517 	ldw	r2,-108(fp)
 82271d4:	10c0008d 	sth	r3,2(r2)

   imop = &simo;
 82271d8:	e0bfe704 	addi	r2,fp,-100
 82271dc:	e0bfe615 	stw	r2,-104(fp)
   MEMSET(imop, 0, sizeof(simo));
 82271e0:	01801604 	movi	r6,88
 82271e4:	000b883a 	mov	r5,zero
 82271e8:	e13fe617 	ldw	r4,-104(fp)
 82271ec:	82032100 	call	8203210 <memset>
   imop->imo_multicast_netp = inm->inm_netp;
 82271f0:	e0bfff17 	ldw	r2,-4(fp)
 82271f4:	10c00117 	ldw	r3,4(r2)
 82271f8:	e0bfe617 	ldw	r2,-104(fp)
 82271fc:	10c00015 	stw	r3,0(r2)
   imop->imo_multicast_ttl = 1;
 8227200:	e0bfe617 	ldw	r2,-104(fp)
 8227204:	00c00044 	movi	r3,1
 8227208:	10c00105 	stb	r3,4(r2)
   /* we do not want our own reports to be looped back */
   imop->imo_multicast_loop = 0;
 822720c:	e0bfe617 	ldw	r2,-104(fp)
 8227210:	10000145 	stb	zero,5(r2)

   /* set nb_prot to point to the beginning of the IGMP data,
    * and nb_plen to the length of the IGMP data, and attach
    * the multicast options structure to the outgoing packet */
   p->nb_prot = (char *) tmpp;
 8227214:	e0bfe317 	ldw	r2,-116(fp)
 8227218:	e0ffe017 	ldw	r3,-128(fp)
 822721c:	10c00315 	stw	r3,12(r2)
   p->nb_plen = sizeof(struct igmp);
 8227220:	e0bfe317 	ldw	r2,-116(fp)
 8227224:	00c00204 	movi	r3,8
 8227228:	10c00415 	stw	r3,16(r2)
   p->imo = imop;
 822722c:	e0bfe317 	ldw	r2,-116(fp)
 8227230:	e0ffe617 	ldw	r3,-104(fp)
 8227234:	10c00b15 	stw	r3,44(r2)
   
   ip_write2 (IGMP_PROT, p, optp);
 8227238:	e1bfe117 	ldw	r6,-124(fp)
 822723c:	e17fe317 	ldw	r5,-116(fp)
 8227240:	01000084 	movi	r4,2
 8227244:	823fbc80 	call	823fbc8 <ip_write2>

   if (type == IGMPv2_LEAVE_GROUP)
 8227248:	e0bffe03 	ldbu	r2,-8(fp)
 822724c:	108005d8 	cmpnei	r2,r2,23
 8227250:	1000081e 	bne	r2,zero,8227274 <igmp_send+0x234>
      ++igmpstats.igmpv2mode_v2_leave_msgs_sent;
 8227254:	008209b4 	movhi	r2,2086
 8227258:	10b84104 	addi	r2,r2,-7932
 822725c:	10801717 	ldw	r2,92(r2)
 8227260:	10c00044 	addi	r3,r2,1
 8227264:	008209b4 	movhi	r2,2086
 8227268:	10b84104 	addi	r2,r2,-7932
 822726c:	10c01715 	stw	r3,92(r2)
 8227270:	00001506 	br	82272c8 <igmp_send+0x288>
   else if (type == IGMPv2_MEMBERSHIP_REPORT)
 8227274:	e0bffe03 	ldbu	r2,-8(fp)
 8227278:	10800598 	cmpnei	r2,r2,22
 822727c:	1000081e 	bne	r2,zero,82272a0 <igmp_send+0x260>
      ++igmpstats.igmpv2mode_v2_reports_sent;
 8227280:	008209b4 	movhi	r2,2086
 8227284:	10b84104 	addi	r2,r2,-7932
 8227288:	10801817 	ldw	r2,96(r2)
 822728c:	10c00044 	addi	r3,r2,1
 8227290:	008209b4 	movhi	r2,2086
 8227294:	10b84104 	addi	r2,r2,-7932
 8227298:	10c01815 	stw	r3,96(r2)
 822729c:	00000a06 	br	82272c8 <igmp_send+0x288>
   else if (type == IGMP_HOST_MEMBERSHIP_REPORT)
 82272a0:	e0bffe03 	ldbu	r2,-8(fp)
 82272a4:	10800498 	cmpnei	r2,r2,18
 82272a8:	1000071e 	bne	r2,zero,82272c8 <igmp_send+0x288>
      ++igmpstats.igmp_v1_reports_sent;
 82272ac:	008209b4 	movhi	r2,2086
 82272b0:	10b84104 	addi	r2,r2,-7932
 82272b4:	10801617 	ldw	r2,88(r2)
 82272b8:	10c00044 	addi	r3,r2,1
 82272bc:	008209b4 	movhi	r2,2086
 82272c0:	10b84104 	addi	r2,r2,-7932
 82272c4:	10c01615 	stw	r3,88(r2)
}
 82272c8:	e037883a 	mov	sp,fp
 82272cc:	dfc00117 	ldw	ra,4(sp)
 82272d0:	df000017 	ldw	fp,0(sp)
 82272d4:	dec00204 	addi	sp,sp,8
 82272d8:	f800283a 	ret

082272dc <igmp_joingroup>:
 *
 * OUTPUT: None.
 */
 
void igmp_joingroup(struct in_multi * inm)
{
 82272dc:	defffc04 	addi	sp,sp,-16
 82272e0:	dfc00315 	stw	ra,12(sp)
 82272e4:	df000215 	stw	fp,8(sp)
 82272e8:	df000204 	addi	fp,sp,8
 82272ec:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   /* extract the network interface to which this multicast
    * address is "attached" */
   ifp = inm->inm_netp;
 82272f0:	e0bfff17 	ldw	r2,-4(fp)
 82272f4:	10800117 	ldw	r2,4(r2)
 82272f8:	e0bffe15 	stw	r2,-8(fp)

   if (inm->inm_addr == igmp_all_hosts_group)
 82272fc:	e0bfff17 	ldw	r2,-4(fp)
 8227300:	10c00017 	ldw	r3,0(r2)
 8227304:	d0a08817 	ldw	r2,-32224(gp)
 8227308:	1880031e 	bne	r3,r2,8227318 <igmp_joingroup+0x3c>
   {
      inm->inm_timer = 0;
 822730c:	e0bfff17 	ldw	r2,-4(fp)
 8227310:	10000315 	stw	zero,12(r2)
      }

      ++igmp_timers_are_running;
   }
   
   return;
 8227314:	00008106 	br	822751c <igmp_joingroup+0x240>
      inm->inm_timer = 0;
   }
   else 
   {
      /* send unsolicited membership report in appropriate format */
      if (ifp->igmpv1_rtr_present)
 8227318:	e0bffe17 	ldw	r2,-8(fp)
 822731c:	10802d03 	ldbu	r2,180(r2)
 8227320:	10803fcc 	andi	r2,r2,255
 8227324:	10003926 	beq	r2,zero,822740c <igmp_joingroup+0x130>
      {
         /* always true for IGMPv1, may be true for IGMPv2 */
         igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 8227328:	e17fff17 	ldw	r5,-4(fp)
 822732c:	01000484 	movi	r4,18
 8227330:	82270400 	call	8227040 <igmp_send>
         /* set a delay timer (with a duration of 
          * IGMP_MAX_HOST_REPORT_DELAY) for a second unsolicited report */
         inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 8227334:	008209b4 	movhi	r2,2086
 8227338:	10ba8304 	addi	r2,r2,-5620
 822733c:	10c00217 	ldw	r3,8(r2)
 8227340:	008209b4 	movhi	r2,2086
 8227344:	10b83d04 	addi	r2,r2,-7948
 8227348:	10800017 	ldw	r2,0(r2)
 822734c:	10800a17 	ldw	r2,40(r2)
 8227350:	1008d63a 	srli	r4,r2,24
 8227354:	008209b4 	movhi	r2,2086
 8227358:	10b83d04 	addi	r2,r2,-7948
 822735c:	10800017 	ldw	r2,0(r2)
 8227360:	10800a17 	ldw	r2,40(r2)
 8227364:	1004d23a 	srli	r2,r2,8
 8227368:	10bfc00c 	andi	r2,r2,65280
 822736c:	2088b03a 	or	r4,r4,r2
 8227370:	008209b4 	movhi	r2,2086
 8227374:	10b83d04 	addi	r2,r2,-7948
 8227378:	10800017 	ldw	r2,0(r2)
 822737c:	10800a17 	ldw	r2,40(r2)
 8227380:	10bfc00c 	andi	r2,r2,65280
 8227384:	1004923a 	slli	r2,r2,8
 8227388:	2088b03a 	or	r4,r4,r2
 822738c:	008209b4 	movhi	r2,2086
 8227390:	10b83d04 	addi	r2,r2,-7948
 8227394:	10800017 	ldw	r2,0(r2)
 8227398:	10800a17 	ldw	r2,40(r2)
 822739c:	1004963a 	slli	r2,r2,24
 82273a0:	2084b03a 	or	r2,r4,r2
 82273a4:	1887883a 	add	r3,r3,r2
 82273a8:	e0bfff17 	ldw	r2,-4(fp)
 82273ac:	10800017 	ldw	r2,0(r2)
 82273b0:	1008d63a 	srli	r4,r2,24
 82273b4:	e0bfff17 	ldw	r2,-4(fp)
 82273b8:	10800017 	ldw	r2,0(r2)
 82273bc:	1004d23a 	srli	r2,r2,8
 82273c0:	10bfc00c 	andi	r2,r2,65280
 82273c4:	2088b03a 	or	r4,r4,r2
 82273c8:	e0bfff17 	ldw	r2,-4(fp)
 82273cc:	10800017 	ldw	r2,0(r2)
 82273d0:	10bfc00c 	andi	r2,r2,65280
 82273d4:	1004923a 	slli	r2,r2,8
 82273d8:	2088b03a 	or	r4,r4,r2
 82273dc:	e0bfff17 	ldw	r2,-4(fp)
 82273e0:	10800017 	ldw	r2,0(r2)
 82273e4:	1004963a 	slli	r2,r2,24
 82273e8:	2084b03a 	or	r2,r4,r2
 82273ec:	1885883a 	add	r2,r3,r2
 82273f0:	01400c84 	movi	r5,50
 82273f4:	1009883a 	mov	r4,r2
 82273f8:	8202cd00 	call	8202cd0 <__umodsi3>
 82273fc:	10c00044 	addi	r3,r2,1
 8227400:	e0bfff17 	ldw	r2,-4(fp)
 8227404:	10c00315 	stw	r3,12(r2)
 8227408:	00003806 	br	82274ec <igmp_joingroup+0x210>
      }
      else
      {
         igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 822740c:	e17fff17 	ldw	r5,-4(fp)
 8227410:	01000584 	movi	r4,22
 8227414:	82270400 	call	8227040 <igmp_send>
         /* the delay time duration is the Unsolicited Report Interval */
         inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY ((UNSOLIC_RPT_INTERVAL * PR_FASTHZ), inm->inm_addr);
 8227418:	008209b4 	movhi	r2,2086
 822741c:	10ba8304 	addi	r2,r2,-5620
 8227420:	10c00217 	ldw	r3,8(r2)
 8227424:	008209b4 	movhi	r2,2086
 8227428:	10b83d04 	addi	r2,r2,-7948
 822742c:	10800017 	ldw	r2,0(r2)
 8227430:	10800a17 	ldw	r2,40(r2)
 8227434:	1008d63a 	srli	r4,r2,24
 8227438:	008209b4 	movhi	r2,2086
 822743c:	10b83d04 	addi	r2,r2,-7948
 8227440:	10800017 	ldw	r2,0(r2)
 8227444:	10800a17 	ldw	r2,40(r2)
 8227448:	1004d23a 	srli	r2,r2,8
 822744c:	10bfc00c 	andi	r2,r2,65280
 8227450:	2088b03a 	or	r4,r4,r2
 8227454:	008209b4 	movhi	r2,2086
 8227458:	10b83d04 	addi	r2,r2,-7948
 822745c:	10800017 	ldw	r2,0(r2)
 8227460:	10800a17 	ldw	r2,40(r2)
 8227464:	10bfc00c 	andi	r2,r2,65280
 8227468:	1004923a 	slli	r2,r2,8
 822746c:	2088b03a 	or	r4,r4,r2
 8227470:	008209b4 	movhi	r2,2086
 8227474:	10b83d04 	addi	r2,r2,-7948
 8227478:	10800017 	ldw	r2,0(r2)
 822747c:	10800a17 	ldw	r2,40(r2)
 8227480:	1004963a 	slli	r2,r2,24
 8227484:	2084b03a 	or	r2,r4,r2
 8227488:	1887883a 	add	r3,r3,r2
 822748c:	e0bfff17 	ldw	r2,-4(fp)
 8227490:	10800017 	ldw	r2,0(r2)
 8227494:	1008d63a 	srli	r4,r2,24
 8227498:	e0bfff17 	ldw	r2,-4(fp)
 822749c:	10800017 	ldw	r2,0(r2)
 82274a0:	1004d23a 	srli	r2,r2,8
 82274a4:	10bfc00c 	andi	r2,r2,65280
 82274a8:	2088b03a 	or	r4,r4,r2
 82274ac:	e0bfff17 	ldw	r2,-4(fp)
 82274b0:	10800017 	ldw	r2,0(r2)
 82274b4:	10bfc00c 	andi	r2,r2,65280
 82274b8:	1004923a 	slli	r2,r2,8
 82274bc:	2088b03a 	or	r4,r4,r2
 82274c0:	e0bfff17 	ldw	r2,-4(fp)
 82274c4:	10800017 	ldw	r2,0(r2)
 82274c8:	1004963a 	slli	r2,r2,24
 82274cc:	2084b03a 	or	r2,r4,r2
 82274d0:	1885883a 	add	r2,r3,r2
 82274d4:	01400c84 	movi	r5,50
 82274d8:	1009883a 	mov	r4,r2
 82274dc:	8202cd00 	call	8202cd0 <__umodsi3>
 82274e0:	10c00044 	addi	r3,r2,1
 82274e4:	e0bfff17 	ldw	r2,-4(fp)
 82274e8:	10c00315 	stw	r3,12(r2)
      }
      
      /* for IGMPv2, indicate that we were the last to send 
       * a Report for this multicast group (relevant for 
       * IGMPv2 only). */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 82274ec:	e0bffe17 	ldw	r2,-8(fp)
 82274f0:	10802f03 	ldbu	r2,188(r2)
 82274f4:	10803fcc 	andi	r2,r2,255
 82274f8:	10800098 	cmpnei	r2,r2,2
 82274fc:	1000031e 	bne	r2,zero,822750c <igmp_joingroup+0x230>
      {
         inm->last2send_report = IGMP_TRUE;
 8227500:	e0bfff17 	ldw	r2,-4(fp)
 8227504:	00c00044 	movi	r3,1
 8227508:	10c00405 	stb	r3,16(r2)
      }

      ++igmp_timers_are_running;
 822750c:	d0a08617 	ldw	r2,-32232(gp)
 8227510:	10800044 	addi	r2,r2,1
 8227514:	d0a08615 	stw	r2,-32232(gp)
   }
   
   return;
 8227518:	0001883a 	nop
}     
 822751c:	e037883a 	mov	sp,fp
 8227520:	dfc00117 	ldw	ra,4(sp)
 8227524:	df000017 	ldw	fp,0(sp)
 8227528:	dec00204 	addi	sp,sp,8
 822752c:	f800283a 	ret

08227530 <igmp_leavegroup>:
 *
 * OUTPUT: None.
 */

void igmp_leavegroup (struct in_multi * inm)
{
 8227530:	defffc04 	addi	sp,sp,-16
 8227534:	dfc00315 	stw	ra,12(sp)
 8227538:	df000215 	stw	fp,8(sp)
 822753c:	df000204 	addi	fp,sp,8
 8227540:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = inm->inm_netp;
 8227544:	e0bfff17 	ldw	r2,-4(fp)
 8227548:	10800117 	ldw	r2,4(r2)
 822754c:	e0bffe15 	stw	r2,-8(fp)

   if ((ifp->igmp_oper_mode == IGMP_MODE_V2) && 
 8227550:	e0bffe17 	ldw	r2,-8(fp)
 8227554:	10802f03 	ldbu	r2,188(r2)
 8227558:	10803fcc 	andi	r2,r2,255
 822755c:	10800098 	cmpnei	r2,r2,2
 8227560:	10000d1e 	bne	r2,zero,8227598 <igmp_leavegroup+0x68>
       !ifp->igmpv1_rtr_present)
 8227564:	e0bffe17 	ldw	r2,-8(fp)
 8227568:	10802d03 	ldbu	r2,180(r2)
{
   NET ifp;

   ifp = inm->inm_netp;

   if ((ifp->igmp_oper_mode == IGMP_MODE_V2) && 
 822756c:	10803fcc 	andi	r2,r2,255
 8227570:	1000091e 	bne	r2,zero,8227598 <igmp_leavegroup+0x68>
       !ifp->igmpv1_rtr_present)
   {
      if (inm->last2send_report == IGMP_TRUE)
 8227574:	e0bfff17 	ldw	r2,-4(fp)
 8227578:	10800403 	ldbu	r2,16(r2)
 822757c:	10803fcc 	andi	r2,r2,255
 8227580:	10800058 	cmpnei	r2,r2,1
 8227584:	1000041e 	bne	r2,zero,8227598 <igmp_leavegroup+0x68>
         igmp_send (IGMPv2_LEAVE_GROUP, inm);
 8227588:	e17fff17 	ldw	r5,-4(fp)
 822758c:	010005c4 	movi	r4,23
 8227590:	82270400 	call	8227040 <igmp_send>
   }
   
   return;
 8227594:	0001883a 	nop
 8227598:	0001883a 	nop
}
 822759c:	e037883a 	mov	sp,fp
 82275a0:	dfc00117 	ldw	ra,4(sp)
 82275a4:	df000017 	ldw	fp,0(sp)
 82275a8:	dec00204 	addi	sp,sp,8
 82275ac:	f800283a 	ret

082275b0 <igmp_validate>:
 *         validation fails; otherwise, it returns
 *         IGMP_OK.
 */

int igmp_validate (PACKET p)
{
 82275b0:	defff604 	addi	sp,sp,-40
 82275b4:	dfc00915 	stw	ra,36(sp)
 82275b8:	df000815 	stw	fp,32(sp)
 82275bc:	df000804 	addi	fp,sp,32
 82275c0:	e13fff15 	stw	r4,-4(fp)
   u_short xsum;  
   u_char type;
   ip_addr mcgrp_addr;
   u_char resp_time;

   pip = ip_head (p);
 82275c4:	e0bfff17 	ldw	r2,-4(fp)
 82275c8:	10800317 	ldw	r2,12(r2)
 82275cc:	e0bff815 	stw	r2,-32(fp)

   /* compute length of IGMP packet (after accounting for IP header, 
    * including the IP Router Alert option (if present)) */
   igmplen = p->nb_plen - ip_hlen (pip);
 82275d0:	e0bfff17 	ldw	r2,-4(fp)
 82275d4:	10c00417 	ldw	r3,16(r2)
 82275d8:	e0bff817 	ldw	r2,-32(fp)
 82275dc:	10800003 	ldbu	r2,0(r2)
 82275e0:	10803fcc 	andi	r2,r2,255
 82275e4:	108003cc 	andi	r2,r2,15
 82275e8:	1085883a 	add	r2,r2,r2
 82275ec:	1085883a 	add	r2,r2,r2
 82275f0:	1885c83a 	sub	r2,r3,r2
 82275f4:	e0bff915 	stw	r2,-28(fp)

   /* validate length (IGMP_MINLEN is 8 bytes) */
   if (igmplen != IGMP_MINLEN) 
 82275f8:	e0bff917 	ldw	r2,-28(fp)
 82275fc:	10800220 	cmpeqi	r2,r2,8
 8227600:	1000091e 	bne	r2,zero,8227628 <igmp_validate+0x78>
   {
      ++igmpstats.igmp_badlen_rcvd;
 8227604:	008209b4 	movhi	r2,2086
 8227608:	10b84104 	addi	r2,r2,-7932
 822760c:	10800a17 	ldw	r2,40(r2)
 8227610:	10c00044 	addi	r3,r2,1
 8227614:	008209b4 	movhi	r2,2086
 8227618:	10b84104 	addi	r2,r2,-7932
 822761c:	10c00a15 	stw	r3,40(r2)
      return ENP_BAD_HEADER;
 8227620:	00bff804 	movi	r2,-32
 8227624:	0000a306 	br	82278b4 <igmp_validate+0x304>
   }

   /* validate checksum */
   igmp = (struct igmp *) (ip_data (pip));
 8227628:	e0bff817 	ldw	r2,-32(fp)
 822762c:	10800003 	ldbu	r2,0(r2)
 8227630:	10803fcc 	andi	r2,r2,255
 8227634:	108003cc 	andi	r2,r2,15
 8227638:	1085883a 	add	r2,r2,r2
 822763c:	1085883a 	add	r2,r2,r2
 8227640:	1007883a 	mov	r3,r2
 8227644:	e0bff817 	ldw	r2,-32(fp)
 8227648:	10c5883a 	add	r2,r2,r3
 822764c:	e0bffa15 	stw	r2,-24(fp)
   osum = igmp->igmp_cksum;
 8227650:	e0bffa17 	ldw	r2,-24(fp)
 8227654:	1080008b 	ldhu	r2,2(r2)
 8227658:	e0bffb0d 	sth	r2,-20(fp)
   igmp->igmp_cksum = 0;
 822765c:	e0bffa17 	ldw	r2,-24(fp)
 8227660:	1000008d 	sth	zero,2(r2)
   xsum = ~cksum(igmp, igmplen>>1);
 8227664:	e0bff917 	ldw	r2,-28(fp)
 8227668:	1005d07a 	srai	r2,r2,1
 822766c:	100b883a 	mov	r5,r2
 8227670:	e13ffa17 	ldw	r4,-24(fp)
 8227674:	82288100 	call	8228810 <cksum>
 8227678:	0084303a 	nor	r2,zero,r2
 822767c:	e0bffb8d 	sth	r2,-18(fp)
   if (xsum != osum)
 8227680:	e0fffb8b 	ldhu	r3,-18(fp)
 8227684:	e0bffb0b 	ldhu	r2,-20(fp)
 8227688:	18800c26 	beq	r3,r2,82276bc <igmp_validate+0x10c>
   {
      igmp->igmp_cksum = osum;
 822768c:	e0bffa17 	ldw	r2,-24(fp)
 8227690:	e0fffb0b 	ldhu	r3,-20(fp)
 8227694:	10c0008d 	sth	r3,2(r2)
      ++igmpstats.igmp_badsum_rcvd;
 8227698:	008209b4 	movhi	r2,2086
 822769c:	10b84104 	addi	r2,r2,-7932
 82276a0:	10800b17 	ldw	r2,44(r2)
 82276a4:	10c00044 	addi	r3,r2,1
 82276a8:	008209b4 	movhi	r2,2086
 82276ac:	10b84104 	addi	r2,r2,-7932
 82276b0:	10c00b15 	stw	r3,44(r2)
      return ENP_BAD_HEADER;
 82276b4:	00bff804 	movi	r2,-32
 82276b8:	00007e06 	br	82278b4 <igmp_validate+0x304>
   }
   
   /* extract the IGMP packet type, Group Address, and Max Response Time 
    * (unused for IGMPv1) fields from received packet */
   type = igmp->igmp_type;
 82276bc:	e0bffa17 	ldw	r2,-24(fp)
 82276c0:	10800003 	ldbu	r2,0(r2)
 82276c4:	e0bffc05 	stb	r2,-16(fp)
   mcgrp_addr = ntohl(igmp->igmp_group); 
 82276c8:	e0bffa17 	ldw	r2,-24(fp)
 82276cc:	10800117 	ldw	r2,4(r2)
 82276d0:	1006d63a 	srli	r3,r2,24
 82276d4:	e0bffa17 	ldw	r2,-24(fp)
 82276d8:	10800117 	ldw	r2,4(r2)
 82276dc:	1004d23a 	srli	r2,r2,8
 82276e0:	10bfc00c 	andi	r2,r2,65280
 82276e4:	1886b03a 	or	r3,r3,r2
 82276e8:	e0bffa17 	ldw	r2,-24(fp)
 82276ec:	10800117 	ldw	r2,4(r2)
 82276f0:	10bfc00c 	andi	r2,r2,65280
 82276f4:	1004923a 	slli	r2,r2,8
 82276f8:	1886b03a 	or	r3,r3,r2
 82276fc:	e0bffa17 	ldw	r2,-24(fp)
 8227700:	10800117 	ldw	r2,4(r2)
 8227704:	1004963a 	slli	r2,r2,24
 8227708:	1884b03a 	or	r2,r3,r2
 822770c:	e0bffd15 	stw	r2,-12(fp)
   resp_time = igmp->igmp_code;
 8227710:	e0bffa17 	ldw	r2,-24(fp)
 8227714:	10800043 	ldbu	r2,1(r2)
 8227718:	e0bffe05 	stb	r2,-8(fp)
      
   if (type == IGMP_HOST_MEMBERSHIP_QUERY)
 822771c:	e0bffc03 	ldbu	r2,-16(fp)
 8227720:	10800458 	cmpnei	r2,r2,17
 8227724:	1000301e 	bne	r2,zero,82277e8 <igmp_validate+0x238>
   {
      if ((resp_time == 0) || /* IGMPv1 Query */
 8227728:	e0bffe03 	ldbu	r2,-8(fp)
 822772c:	10000426 	beq	r2,zero,8227740 <igmp_validate+0x190>
 8227730:	e0bffe03 	ldbu	r2,-8(fp)
 8227734:	10000f26 	beq	r2,zero,8227774 <igmp_validate+0x1c4>
          ((resp_time > 0) && (mcgrp_addr == 0))) /* IGMPv2 General Query */     
 8227738:	e0bffd17 	ldw	r2,-12(fp)
 822773c:	10000d1e 	bne	r2,zero,8227774 <igmp_validate+0x1c4>
      {
         /* if this is a IGMPv1 Host Membership Query or a IGMPv2 
          * General Query, it must be addressed to the all-hosts 
          * group */
         if (pip->ip_dest != igmp_all_hosts_group) 
 8227740:	e0bff817 	ldw	r2,-32(fp)
 8227744:	10c00417 	ldw	r3,16(r2)
 8227748:	d0a08817 	ldw	r2,-32224(gp)
 822774c:	18800926 	beq	r3,r2,8227774 <igmp_validate+0x1c4>
         {
            ++igmpstats.igmp_bad_queries_rcvd;
 8227750:	008209b4 	movhi	r2,2086
 8227754:	10b84104 	addi	r2,r2,-7932
 8227758:	10800e17 	ldw	r2,56(r2)
 822775c:	10c00044 	addi	r3,r2,1
 8227760:	008209b4 	movhi	r2,2086
 8227764:	10b84104 	addi	r2,r2,-7932
 8227768:	10c00e15 	stw	r3,56(r2)
            return ENP_BAD_HEADER;
 822776c:	00bff804 	movi	r2,-32
 8227770:	00005006 	br	82278b4 <igmp_validate+0x304>
         }     
      }
      
      if ((resp_time > 0) && (mcgrp_addr != 0))
 8227774:	e0bffe03 	ldbu	r2,-8(fp)
 8227778:	10001b26 	beq	r2,zero,82277e8 <igmp_validate+0x238>
 822777c:	e0bffd17 	ldw	r2,-12(fp)
 8227780:	10001926 	beq	r2,zero,82277e8 <igmp_validate+0x238>
      {
         /* this is a IGMPv2 Group-Specific Query. */
         if (p->net->igmp_oper_mode == IGMP_MODE_V1)
 8227784:	e0bfff17 	ldw	r2,-4(fp)
 8227788:	10800617 	ldw	r2,24(r2)
 822778c:	10802f03 	ldbu	r2,188(r2)
 8227790:	10803fcc 	andi	r2,r2,255
 8227794:	10800058 	cmpnei	r2,r2,1
 8227798:	1000021e 	bne	r2,zero,82277a4 <igmp_validate+0x1f4>
         {
            /* IGMPv1 code does not understand a IGMPv2 Group-
             * Specific Query */
            return ENP_BAD_HEADER; 
 822779c:	00bff804 	movi	r2,-32
 82277a0:	00004406 	br	82278b4 <igmp_validate+0x304>
         /* check to make sure that the group address field carries
          * a valid multicast address; if it doesn't, we
          * drop the packet.  Also drop packets that
          * carry the multicast address for the all-hosts
          * group. */
         if ((!IN_MULTICAST(mcgrp_addr)) ||
 82277a4:	e0bffd17 	ldw	r2,-12(fp)
 82277a8:	10fc002c 	andhi	r3,r2,61440
 82277ac:	00b80034 	movhi	r2,57344
 82277b0:	1880041e 	bne	r3,r2,82277c4 <igmp_validate+0x214>
             /* igmp_all_hosts_group is already in network byte order */
             (igmp->igmp_group == igmp_all_hosts_group))
 82277b4:	e0bffa17 	ldw	r2,-24(fp)
 82277b8:	10c00117 	ldw	r3,4(r2)
 82277bc:	d0a08817 	ldw	r2,-32224(gp)
         /* check to make sure that the group address field carries
          * a valid multicast address; if it doesn't, we
          * drop the packet.  Also drop packets that
          * carry the multicast address for the all-hosts
          * group. */
         if ((!IN_MULTICAST(mcgrp_addr)) ||
 82277c0:	1880091e 	bne	r3,r2,82277e8 <igmp_validate+0x238>
             /* igmp_all_hosts_group is already in network byte order */
             (igmp->igmp_group == igmp_all_hosts_group))
         {
            ++igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd;
 82277c4:	008209b4 	movhi	r2,2086
 82277c8:	10b84104 	addi	r2,r2,-7932
 82277cc:	10801117 	ldw	r2,68(r2)
 82277d0:	10c00044 	addi	r3,r2,1
 82277d4:	008209b4 	movhi	r2,2086
 82277d8:	10b84104 	addi	r2,r2,-7932
 82277dc:	10c01115 	stw	r3,68(r2)
            /* caller will free received packet */
            return ENP_BAD_HEADER;
 82277e0:	00bff804 	movi	r2,-32
 82277e4:	00003306 	br	82278b4 <igmp_validate+0x304>
   
   /* check to ensure that a received IGMPv1 or v2 Report has the 
    * same IP host group address in its IP destination field and 
    * its IGMP group address field, and that the group address is
    * a valid multicast address */
   if ((type == IGMP_HOST_MEMBERSHIP_REPORT) ||
 82277e8:	e0bffc03 	ldbu	r2,-16(fp)
 82277ec:	108004a0 	cmpeqi	r2,r2,18
 82277f0:	1000031e 	bne	r2,zero,8227800 <igmp_validate+0x250>
 82277f4:	e0bffc03 	ldbu	r2,-16(fp)
 82277f8:	10800598 	cmpnei	r2,r2,22
 82277fc:	1000121e 	bne	r2,zero,8227848 <igmp_validate+0x298>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      if ((igmp->igmp_group != pip->ip_dest) ||
 8227800:	e0bffa17 	ldw	r2,-24(fp)
 8227804:	10c00117 	ldw	r3,4(r2)
 8227808:	e0bff817 	ldw	r2,-32(fp)
 822780c:	10800417 	ldw	r2,16(r2)
 8227810:	1880041e 	bne	r3,r2,8227824 <igmp_validate+0x274>
          (!IN_MULTICAST(mcgrp_addr)))
 8227814:	e0bffd17 	ldw	r2,-12(fp)
 8227818:	10fc002c 	andhi	r3,r2,61440
    * its IGMP group address field, and that the group address is
    * a valid multicast address */
   if ((type == IGMP_HOST_MEMBERSHIP_REPORT) ||
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      if ((igmp->igmp_group != pip->ip_dest) ||
 822781c:	00b80034 	movhi	r2,57344
 8227820:	18800926 	beq	r3,r2,8227848 <igmp_validate+0x298>
          (!IN_MULTICAST(mcgrp_addr)))
      {
         ++igmpstats.igmp_bad_reports_rcvd;
 8227824:	008209b4 	movhi	r2,2086
 8227828:	10b84104 	addi	r2,r2,-7932
 822782c:	10800f17 	ldw	r2,60(r2)
 8227830:	10c00044 	addi	r3,r2,1
 8227834:	008209b4 	movhi	r2,2086
 8227838:	10b84104 	addi	r2,r2,-7932
 822783c:	10c00f15 	stw	r3,60(r2)
         return ENP_BAD_HEADER;    
 8227840:	00bff804 	movi	r2,-32
 8227844:	00001b06 	br	82278b4 <igmp_validate+0x304>

    * Version 1 Host Membership Reports and Version 1 Host Membership Query
    * packets will not be checked for the IP Router Alert option.
    */
#ifdef IGMP_V2    
   if ((type == IGMPv2_LEAVE_GROUP) || 
 8227848:	e0bffc03 	ldbu	r2,-16(fp)
 822784c:	108005e0 	cmpeqi	r2,r2,23
 8227850:	10000a1e 	bne	r2,zero,822787c <igmp_validate+0x2cc>
 8227854:	e0bffc03 	ldbu	r2,-16(fp)
 8227858:	108005a0 	cmpeqi	r2,r2,22
 822785c:	1000071e 	bne	r2,zero,822787c <igmp_validate+0x2cc>
       (type == IGMPv2_MEMBERSHIP_REPORT) ||
 8227860:	e0bffc03 	ldbu	r2,-16(fp)
 8227864:	10800458 	cmpnei	r2,r2,17
 8227868:	1000111e 	bne	r2,zero,82278b0 <igmp_validate+0x300>
       ((type == IGMP_HOST_MEMBERSHIP_QUERY) && (igmp->igmp_code > 0)))
 822786c:	e0bffa17 	ldw	r2,-24(fp)
 8227870:	10800043 	ldbu	r2,1(r2)
 8227874:	10803fcc 	andi	r2,r2,255
 8227878:	10000d26 	beq	r2,zero,82278b0 <igmp_validate+0x300>
       
   {
      if (!igmpv2_chk4_rtr_alert_opt (pip))
 822787c:	e13ff817 	ldw	r4,-32(fp)
 8227880:	8245d940 	call	8245d94 <igmpv2_chk4_rtr_alert_opt>
 8227884:	10803fcc 	andi	r2,r2,255
 8227888:	1000091e 	bne	r2,zero,82278b0 <igmp_validate+0x300>
      { 
         ++igmpstats.igmpv2mode_v2_rtr_alert_missing;
 822788c:	008209b4 	movhi	r2,2086
 8227890:	10b84104 	addi	r2,r2,-7932
 8227894:	10801417 	ldw	r2,80(r2)
 8227898:	10c00044 	addi	r3,r2,1
 822789c:	008209b4 	movhi	r2,2086
 82278a0:	10b84104 	addi	r2,r2,-7932
 82278a4:	10c01415 	stw	r3,80(r2)
         return ENP_BAD_HEADER;
 82278a8:	00bff804 	movi	r2,-32
 82278ac:	00000106 	br	82278b4 <igmp_validate+0x304>
      }
   }
#endif   

   /* validation successful */
   return IGMP_OK;
 82278b0:	0005883a 	mov	r2,zero
}
 82278b4:	e037883a 	mov	sp,fp
 82278b8:	dfc00117 	ldw	ra,4(sp)
 82278bc:	df000017 	ldw	fp,0(sp)
 82278c0:	dec00204 	addi	sp,sp,8
 82278c4:	f800283a 	ret

082278c8 <igmp_print_stats>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */
   
int igmp_print_stats (void * pio)
{  
 82278c8:	defffa04 	addi	sp,sp,-24
 82278cc:	dfc00515 	stw	ra,20(sp)
 82278d0:	df000415 	stw	fp,16(sp)
 82278d4:	df000404 	addi	fp,sp,16
 82278d8:	e13fff15 	stw	r4,-4(fp)
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 82278dc:	008209b4 	movhi	r2,2086
 82278e0:	10ba7e04 	addi	r2,r2,-5640
 82278e4:	10800017 	ldw	r2,0(r2)
 82278e8:	e0bffe15 	stw	r2,-8(fp)
 82278ec:	00003b06 	br	82279dc <igmp_print_stats+0x114>
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
                 ifp->name, 
 82278f0:	e0bffe17 	ldw	r2,-8(fp)
 82278f4:	10c00104 	addi	r3,r2,4
                 ifp->igmp_oper_mode, 
 82278f8:	e0bffe17 	ldw	r2,-8(fp)
 82278fc:	10802f03 	ldbu	r2,188(r2)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
 8227900:	11003fcc 	andi	r4,r2,255
                 ifp->name, 
                 ifp->igmp_oper_mode, 
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
 8227904:	e0bffe17 	ldw	r2,-8(fp)
 8227908:	10802f03 	ldbu	r2,188(r2)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
 822790c:	10803fcc 	andi	r2,r2,255
 8227910:	10800058 	cmpnei	r2,r2,1
 8227914:	1000031e 	bne	r2,zero,8227924 <igmp_print_stats+0x5c>
 8227918:	00820974 	movhi	r2,2085
 822791c:	10804304 	addi	r2,r2,268
 8227920:	00000206 	br	822792c <igmp_print_stats+0x64>
 8227924:	00820974 	movhi	r2,2085
 8227928:	10804404 	addi	r2,r2,272
 822792c:	d8800015 	stw	r2,0(sp)
 8227930:	200f883a 	mov	r7,r4
 8227934:	180d883a 	mov	r6,r3
 8227938:	01420974 	movhi	r5,2085
 822793c:	29404504 	addi	r5,r5,276
 8227940:	e13fff17 	ldw	r4,-4(fp)
 8227944:	8228ebc0 	call	8228ebc <ns_printf>
                 ifp->name, 
                 ifp->igmp_oper_mode, 
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 8227948:	e0bffe17 	ldw	r2,-8(fp)
 822794c:	10802f03 	ldbu	r2,188(r2)
 8227950:	10803fcc 	andi	r2,r2,255
 8227954:	10800098 	cmpnei	r2,r2,2
 8227958:	1000191e 	bne	r2,zero,82279c0 <igmp_print_stats+0xf8>
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
                    ifp->igmpv1_rtr_present,
 822795c:	e0bffe17 	ldw	r2,-8(fp)
 8227960:	10802d03 	ldbu	r2,180(r2)
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
 8227964:	11403fcc 	andi	r5,r2,255
                    ifp->igmpv1_rtr_present,
                    ((ifp->igmpv1_rtr_present == IGMP_TRUE)? "present" : "absent"),
 8227968:	e0bffe17 	ldw	r2,-8(fp)
 822796c:	10802d03 	ldbu	r2,180(r2)
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
 8227970:	10803fcc 	andi	r2,r2,255
 8227974:	10800058 	cmpnei	r2,r2,1
 8227978:	1000031e 	bne	r2,zero,8227988 <igmp_print_stats+0xc0>
 822797c:	00820974 	movhi	r2,2085
 8227980:	10804a04 	addi	r2,r2,296
 8227984:	00000206 	br	8227990 <igmp_print_stats+0xc8>
 8227988:	00820974 	movhi	r2,2085
 822798c:	10804c04 	addi	r2,r2,304
 8227990:	e0fffe17 	ldw	r3,-8(fp)
 8227994:	18c02e17 	ldw	r3,184(r3)
 8227998:	d120a817 	ldw	r4,-32096(gp)
 822799c:	d9000115 	stw	r4,4(sp)
 82279a0:	d8c00015 	stw	r3,0(sp)
 82279a4:	100f883a 	mov	r7,r2
 82279a8:	280d883a 	mov	r6,r5
 82279ac:	01420974 	movhi	r5,2085
 82279b0:	29404e04 	addi	r5,r5,312
 82279b4:	e13fff17 	ldw	r4,-4(fp)
 82279b8:	8228ebc0 	call	8228ebc <ns_printf>
 82279bc:	00000406 	br	82279d0 <igmp_print_stats+0x108>
                    ifp->igmpv1_rtr_present,
                    ((ifp->igmpv1_rtr_present == IGMP_TRUE)? "present" : "absent"),
                    ifp->igmpv1_query_rcvd_time,
                    cticks);
      }
      else ns_printf (pio, "\n");
 82279c0:	01420974 	movhi	r5,2085
 82279c4:	29405904 	addi	r5,r5,356
 82279c8:	e13fff17 	ldw	r4,-4(fp)
 82279cc:	8228ebc0 	call	8228ebc <ns_printf>
   
int igmp_print_stats (void * pio)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 82279d0:	e0bffe17 	ldw	r2,-8(fp)
 82279d4:	10800017 	ldw	r2,0(r2)
 82279d8:	e0bffe15 	stw	r2,-8(fp)
 82279dc:	e0bffe17 	ldw	r2,-8(fp)
 82279e0:	103fc31e 	bne	r2,zero,82278f0 <igmp_print_stats+0x28>
      }
      else ns_printf (pio, "\n");
   }   

   /* rx and timer statistics */
   ns_printf (pio, "[Rx ] IGMP messages rcvd: %lu, timers running: %lu\n", igmpstats.igmp_total_rcvd, igmp_timers_are_running);
 82279e4:	008209b4 	movhi	r2,2086
 82279e8:	10b84104 	addi	r2,r2,-7932
 82279ec:	10800017 	ldw	r2,0(r2)
 82279f0:	d0e08617 	ldw	r3,-32232(gp)
 82279f4:	180f883a 	mov	r7,r3
 82279f8:	100d883a 	mov	r6,r2
 82279fc:	01420974 	movhi	r5,2085
 8227a00:	29405a04 	addi	r5,r5,360
 8227a04:	e13fff17 	ldw	r4,-4(fp)
 8227a08:	8228ebc0 	call	8228ebc <ns_printf>
   
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v1-mode links): %lu\n", igmpstats.igmpv1mode_v1_queries_rcvd);
 8227a0c:	008209b4 	movhi	r2,2086
 8227a10:	10b84104 	addi	r2,r2,-7932
 8227a14:	10800117 	ldw	r2,4(r2)
 8227a18:	100d883a 	mov	r6,r2
 8227a1c:	01420974 	movhi	r5,2085
 8227a20:	29406704 	addi	r5,r5,412
 8227a24:	e13fff17 	ldw	r4,-4(fp)
 8227a28:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Reports rcvd: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd);
 8227a2c:	008209b4 	movhi	r2,2086
 8227a30:	10b84104 	addi	r2,r2,-7932
 8227a34:	10800217 	ldw	r2,8(r2)
 8227a38:	100d883a 	mov	r6,r2
 8227a3c:	01420974 	movhi	r5,2085
 8227a40:	29407804 	addi	r5,r5,480
 8227a44:	e13fff17 	ldw	r4,-4(fp)
 8227a48:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer);
 8227a4c:	008209b4 	movhi	r2,2086
 8227a50:	10b84104 	addi	r2,r2,-7932
 8227a54:	10800317 	ldw	r2,12(r2)
 8227a58:	100d883a 	mov	r6,r2
 8227a5c:	01420974 	movhi	r5,2085
 8227a60:	29408404 	addi	r5,r5,528
 8227a64:	e13fff17 	ldw	r4,-4(fp)
 8227a68:	8228ebc0 	call	8228ebc <ns_printf>
      
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v2-mode links): %lu\n", igmpstats.igmpv2mode_v1_queries_rcvd);
 8227a6c:	008209b4 	movhi	r2,2086
 8227a70:	10b84104 	addi	r2,r2,-7932
 8227a74:	10800417 	ldw	r2,16(r2)
 8227a78:	100d883a 	mov	r6,r2
 8227a7c:	01420974 	movhi	r5,2085
 8227a80:	29409704 	addi	r5,r5,604
 8227a84:	e13fff17 	ldw	r4,-4(fp)
 8227a88:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 General Queries rcvd: %lu, Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_general_queries_rcvd, igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd);
 8227a8c:	008209b4 	movhi	r2,2086
 8227a90:	10b84104 	addi	r2,r2,-7932
 8227a94:	10c00517 	ldw	r3,20(r2)
 8227a98:	008209b4 	movhi	r2,2086
 8227a9c:	10b84104 	addi	r2,r2,-7932
 8227aa0:	10800617 	ldw	r2,24(r2)
 8227aa4:	100f883a 	mov	r7,r2
 8227aa8:	180d883a 	mov	r6,r3
 8227aac:	01420974 	movhi	r5,2085
 8227ab0:	2940a804 	addi	r5,r5,672
 8227ab4:	e13fff17 	ldw	r4,-4(fp)
 8227ab8:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer);   
 8227abc:	008209b4 	movhi	r2,2086
 8227ac0:	10b84104 	addi	r2,r2,-7932
 8227ac4:	10800717 	ldw	r2,28(r2)
 8227ac8:	100d883a 	mov	r6,r2
 8227acc:	01420974 	movhi	r5,2085
 8227ad0:	29408404 	addi	r5,r5,528
 8227ad4:	e13fff17 	ldw	r4,-4(fp)
 8227ad8:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd with no local timer: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_no_timer);
 8227adc:	008209b4 	movhi	r2,2086
 8227ae0:	10b84104 	addi	r2,r2,-7932
 8227ae4:	10800817 	ldw	r2,32(r2)
 8227ae8:	100d883a 	mov	r6,r2
 8227aec:	01420974 	movhi	r5,2085
 8227af0:	2940bb04 	addi	r5,r5,748
 8227af4:	e13fff17 	ldw	r4,-4(fp)
 8227af8:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 Leave Group messages rcvd: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_rcvd);
 8227afc:	008209b4 	movhi	r2,2086
 8227b00:	10b84104 	addi	r2,r2,-7932
 8227b04:	10800917 	ldw	r2,36(r2)
 8227b08:	100d883a 	mov	r6,r2
 8227b0c:	01420974 	movhi	r5,2085
 8227b10:	2940cc04 	addi	r5,r5,816
 8227b14:	e13fff17 	ldw	r4,-4(fp)
 8227b18:	8228ebc0 	call	8228ebc <ns_printf>
   
   /* tx statistics */
   ns_printf (pio, "[Tx ] IGMPv2 Leave Group messages sent: %lu, Membership Reports sent: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_sent, igmpstats.igmpv2mode_v2_reports_sent);
 8227b1c:	008209b4 	movhi	r2,2086
 8227b20:	10b84104 	addi	r2,r2,-7932
 8227b24:	10c01717 	ldw	r3,92(r2)
 8227b28:	008209b4 	movhi	r2,2086
 8227b2c:	10b84104 	addi	r2,r2,-7932
 8227b30:	10801817 	ldw	r2,96(r2)
 8227b34:	100f883a 	mov	r7,r2
 8227b38:	180d883a 	mov	r6,r3
 8227b3c:	01420974 	movhi	r5,2085
 8227b40:	2940d804 	addi	r5,r5,864
 8227b44:	e13fff17 	ldw	r4,-4(fp)
 8227b48:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf (pio, "[Tx ] IGMPv1 Host Membership Reports sent: %lu\n", igmpstats.igmp_v1_reports_sent);
 8227b4c:	008209b4 	movhi	r2,2086
 8227b50:	10b84104 	addi	r2,r2,-7932
 8227b54:	10801617 	ldw	r2,88(r2)
 8227b58:	100d883a 	mov	r6,r2
 8227b5c:	01420974 	movhi	r5,2085
 8227b60:	2940eb04 	addi	r5,r5,940
 8227b64:	e13fff17 	ldw	r4,-4(fp)
 8227b68:	8228ebc0 	call	8228ebc <ns_printf>

   /* error statistics */
   ns_printf (pio, "[Err] IGMP packets rcvd with bad length: %lu\n", igmpstats.igmp_badlen_rcvd);
 8227b6c:	008209b4 	movhi	r2,2086
 8227b70:	10b84104 	addi	r2,r2,-7932
 8227b74:	10800a17 	ldw	r2,40(r2)
 8227b78:	100d883a 	mov	r6,r2
 8227b7c:	01420974 	movhi	r5,2085
 8227b80:	2940f704 	addi	r5,r5,988
 8227b84:	e13fff17 	ldw	r4,-4(fp)
 8227b88:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf (pio, "[Err] IGMP packets rcvd with bad checksum: %lu\n", igmpstats.igmp_badsum_rcvd);
 8227b8c:	008209b4 	movhi	r2,2086
 8227b90:	10b84104 	addi	r2,r2,-7932
 8227b94:	10800b17 	ldw	r2,44(r2)
 8227b98:	100d883a 	mov	r6,r2
 8227b9c:	01420974 	movhi	r5,2085
 8227ba0:	29410304 	addi	r5,r5,1036
 8227ba4:	e13fff17 	ldw	r4,-4(fp)
 8227ba8:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf (pio, "[Err] Packet buffer allocation failures: %lu, Bad IGMP Oper Mode config: %lu\n",igmpstats.igmp_pkt_alloc_fail, igmpstats.igmp_bad_oper_mode);
 8227bac:	008209b4 	movhi	r2,2086
 8227bb0:	10b84104 	addi	r2,r2,-7932
 8227bb4:	10c00c17 	ldw	r3,48(r2)
 8227bb8:	008209b4 	movhi	r2,2086
 8227bbc:	10b84104 	addi	r2,r2,-7932
 8227bc0:	10800d17 	ldw	r2,52(r2)
 8227bc4:	100f883a 	mov	r7,r2
 8227bc8:	180d883a 	mov	r6,r3
 8227bcc:	01420974 	movhi	r5,2085
 8227bd0:	29410f04 	addi	r5,r5,1084
 8227bd4:	e13fff17 	ldw	r4,-4(fp)
 8227bd8:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf (pio, "[Err] Bad IGMP Queries rcvd: %lu, Bad IGMP Reports rcvd: %lu\n", igmpstats.igmp_bad_queries_rcvd, igmpstats.igmp_bad_reports_rcvd); 
 8227bdc:	008209b4 	movhi	r2,2086
 8227be0:	10b84104 	addi	r2,r2,-7932
 8227be4:	10c00e17 	ldw	r3,56(r2)
 8227be8:	008209b4 	movhi	r2,2086
 8227bec:	10b84104 	addi	r2,r2,-7932
 8227bf0:	10800f17 	ldw	r2,60(r2)
 8227bf4:	100f883a 	mov	r7,r2
 8227bf8:	180d883a 	mov	r6,r3
 8227bfc:	01420974 	movhi	r5,2085
 8227c00:	29412304 	addi	r5,r5,1164
 8227c04:	e13fff17 	ldw	r4,-4(fp)
 8227c08:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf (pio, "[Err] Bad IGMPv2 Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd);
 8227c0c:	008209b4 	movhi	r2,2086
 8227c10:	10b84104 	addi	r2,r2,-7932
 8227c14:	10801117 	ldw	r2,68(r2)
 8227c18:	100d883a 	mov	r6,r2
 8227c1c:	01420974 	movhi	r5,2085
 8227c20:	29413304 	addi	r5,r5,1228
 8227c24:	e13fff17 	ldw	r4,-4(fp)
 8227c28:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf (pio, "[Err] IGMPv2 Group-Specific Queries rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd);
 8227c2c:	008209b4 	movhi	r2,2086
 8227c30:	10b84104 	addi	r2,r2,-7932
 8227c34:	10801217 	ldw	r2,72(r2)
 8227c38:	100d883a 	mov	r6,r2
 8227c3c:	01420974 	movhi	r5,2085
 8227c40:	29414004 	addi	r5,r5,1280
 8227c44:	e13fff17 	ldw	r4,-4(fp)
 8227c48:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf (pio, "[Err] IGMP Membership Reports rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd);
 8227c4c:	008209b4 	movhi	r2,2086
 8227c50:	10b84104 	addi	r2,r2,-7932
 8227c54:	10801317 	ldw	r2,76(r2)
 8227c58:	100d883a 	mov	r6,r2
 8227c5c:	01420974 	movhi	r5,2085
 8227c60:	29415304 	addi	r5,r5,1356
 8227c64:	e13fff17 	ldw	r4,-4(fp)
 8227c68:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf (pio, "[Err] Number of IGMPv2 messages rcvd without Router Alert option: %lu\n", igmpstats.igmpv2mode_v2_rtr_alert_missing); 
 8227c6c:	008209b4 	movhi	r2,2086
 8227c70:	10b84104 	addi	r2,r2,-7932
 8227c74:	10801417 	ldw	r2,80(r2)
 8227c78:	100d883a 	mov	r6,r2
 8227c7c:	01420974 	movhi	r5,2085
 8227c80:	29416404 	addi	r5,r5,1424
 8227c84:	e13fff17 	ldw	r4,-4(fp)
 8227c88:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v1-mode links: %lu\n", igmpstats.igmpv1mode_unknown_pkttype);
 8227c8c:	008209b4 	movhi	r2,2086
 8227c90:	10b84104 	addi	r2,r2,-7932
 8227c94:	10801017 	ldw	r2,64(r2)
 8227c98:	100d883a 	mov	r6,r2
 8227c9c:	01420974 	movhi	r5,2085
 8227ca0:	29417604 	addi	r5,r5,1496
 8227ca4:	e13fff17 	ldw	r4,-4(fp)
 8227ca8:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v2-mode links: %lu\n", igmpstats.igmpv2mode_unknown_pkttype);
 8227cac:	008209b4 	movhi	r2,2086
 8227cb0:	10b84104 	addi	r2,r2,-7932
 8227cb4:	10801517 	ldw	r2,84(r2)
 8227cb8:	100d883a 	mov	r6,r2
 8227cbc:	01420974 	movhi	r5,2085
 8227cc0:	29418604 	addi	r5,r5,1560
 8227cc4:	e13fff17 	ldw	r4,-4(fp)
 8227cc8:	8228ebc0 	call	8228ebc <ns_printf>
   
   return IGMP_OK;
 8227ccc:	0005883a 	mov	r2,zero
}
 8227cd0:	e037883a 	mov	sp,fp
 8227cd4:	dfc00117 	ldw	ra,4(sp)
 8227cd8:	df000017 	ldw	fp,0(sp)
 8227cdc:	dec00204 	addi	sp,sp,8
 8227ce0:	f800283a 	ret

08227ce4 <bsd_accept>:
 *          The error is available via bsd_errno(s).
 */
BSD_SOCKET
bsd_accept(BSD_SOCKET s,
           struct sockaddr * addr, int * addrlen)
{
 8227ce4:	defff404 	addi	sp,sp,-48
 8227ce8:	dfc00b15 	stw	ra,44(sp)
 8227cec:	df000a15 	stw	fp,40(sp)
 8227cf0:	df000a04 	addi	fp,sp,40
 8227cf4:	e13ffd15 	stw	r4,-12(fp)
 8227cf8:	e17ffe15 	stw	r5,-8(fp)
 8227cfc:	e1bfff15 	stw	r6,-4(fp)
   struct socket * so;
   struct sockaddr laddr;
   long lret;

   so = LONG2SO(s);
 8227d00:	e0bffd17 	ldw	r2,-12(fp)
 8227d04:	10bff804 	addi	r2,r2,-32
 8227d08:	1085883a 	add	r2,r2,r2
 8227d0c:	1085883a 	add	r2,r2,r2
 8227d10:	e0bff715 	stw	r2,-36(fp)
   SOC_CHECK(so);
 8227d14:	008209b4 	movhi	r2,2086
 8227d18:	10b97a04 	addi	r2,r2,-6680
 8227d1c:	e0bff615 	stw	r2,-40(fp)
 8227d20:	00000606 	br	8227d3c <bsd_accept+0x58>
 8227d24:	e0fff617 	ldw	r3,-40(fp)
 8227d28:	e0bff717 	ldw	r2,-36(fp)
 8227d2c:	18800626 	beq	r3,r2,8227d48 <bsd_accept+0x64>
 8227d30:	e0bff617 	ldw	r2,-40(fp)
 8227d34:	10800017 	ldw	r2,0(r2)
 8227d38:	e0bff615 	stw	r2,-40(fp)
 8227d3c:	e0bff617 	ldw	r2,-40(fp)
 8227d40:	103ff81e 	bne	r2,zero,8227d24 <bsd_accept+0x40>
 8227d44:	00000106 	br	8227d4c <bsd_accept+0x68>
 8227d48:	0001883a 	nop
 8227d4c:	e0fff617 	ldw	r3,-40(fp)
 8227d50:	e0bff717 	ldw	r2,-36(fp)
 8227d54:	18800326 	beq	r3,r2,8227d64 <bsd_accept+0x80>
 8227d58:	822d5f00 	call	822d5f0 <dtrap>
 8227d5c:	00bfffc4 	movi	r2,-1
 8227d60:	00002406 	br	8227df4 <bsd_accept+0x110>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (addr != NULL)
 8227d64:	e0bffe17 	ldw	r2,-8(fp)
 8227d68:	10000726 	beq	r2,zero,8227d88 <bsd_accept+0xa4>
   {
      if (addrlen == 0)
 8227d6c:	e0bfff17 	ldw	r2,-4(fp)
 8227d70:	1000051e 	bne	r2,zero,8227d88 <bsd_accept+0xa4>
      {
         so->so_error = EFAULT;
 8227d74:	e0bff717 	ldw	r2,-36(fp)
 8227d78:	00c00384 	movi	r3,14
 8227d7c:	10c00615 	stw	r3,24(r2)
         return -1;
 8227d80:	00bfffc4 	movi	r2,-1
 8227d84:	00001b06 	br	8227df4 <bsd_accept+0x110>
      }
   }

   lret = t_accept(s, &laddr, addrlen);
 8227d88:	e0bff904 	addi	r2,fp,-28
 8227d8c:	e1bfff17 	ldw	r6,-4(fp)
 8227d90:	100b883a 	mov	r5,r2
 8227d94:	e13ffd17 	ldw	r4,-12(fp)
 8227d98:	82307480 	call	8230748 <t_accept>
 8227d9c:	e0bff815 	stw	r2,-32(fp)
    * address: copy the peer's address back into the buffer, but limit
    * the copy to the lesser of the buffer's length and sizeof(struct
    * sockaddr_in), which is all that t_accept() can return as a peer
    * address.  
    */
   if ((lret != -1) && (addr != NULL))
 8227da0:	e0bff817 	ldw	r2,-32(fp)
 8227da4:	10bfffe0 	cmpeqi	r2,r2,-1
 8227da8:	1000111e 	bne	r2,zero,8227df0 <bsd_accept+0x10c>
 8227dac:	e0bffe17 	ldw	r2,-8(fp)
 8227db0:	10000f26 	beq	r2,zero,8227df0 <bsd_accept+0x10c>
   {
      if (*addrlen > sizeof(struct sockaddr_in))
 8227db4:	e0bfff17 	ldw	r2,-4(fp)
 8227db8:	10800017 	ldw	r2,0(r2)
 8227dbc:	10800470 	cmpltui	r2,r2,17
 8227dc0:	1000031e 	bne	r2,zero,8227dd0 <bsd_accept+0xec>
         *addrlen = sizeof(struct sockaddr_in);
 8227dc4:	e0bfff17 	ldw	r2,-4(fp)
 8227dc8:	00c00404 	movi	r3,16
 8227dcc:	10c00015 	stw	r3,0(r2)
      MEMCPY(addr, &laddr, *addrlen);
 8227dd0:	e0bfff17 	ldw	r2,-4(fp)
 8227dd4:	10800017 	ldw	r2,0(r2)
 8227dd8:	1007883a 	mov	r3,r2
 8227ddc:	e0bff904 	addi	r2,fp,-28
 8227de0:	180d883a 	mov	r6,r3
 8227de4:	100b883a 	mov	r5,r2
 8227de8:	e13ffe17 	ldw	r4,-8(fp)
 8227dec:	8202f6c0 	call	8202f6c <memcpy>
   }

   return lret;
 8227df0:	e0bff817 	ldw	r2,-32(fp)
}
 8227df4:	e037883a 	mov	sp,fp
 8227df8:	dfc00117 	ldw	ra,4(sp)
 8227dfc:	df000017 	ldw	fp,0(sp)
 8227e00:	dec00204 	addi	sp,sp,8
 8227e04:	f800283a 	ret

08227e08 <bsd_getpeername>:
 *          available via bsd_errno(s).
 */
int
bsd_getpeername(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 8227e08:	defff304 	addi	sp,sp,-52
 8227e0c:	dfc00c15 	stw	ra,48(sp)
 8227e10:	df000b15 	stw	fp,44(sp)
 8227e14:	df000b04 	addi	fp,sp,44
 8227e18:	e13ffd15 	stw	r4,-12(fp)
 8227e1c:	e17ffe15 	stw	r5,-8(fp)
 8227e20:	e1bfff15 	stw	r6,-4(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 8227e24:	e0bffd17 	ldw	r2,-12(fp)
 8227e28:	10bff804 	addi	r2,r2,-32
 8227e2c:	1085883a 	add	r2,r2,r2
 8227e30:	1085883a 	add	r2,r2,r2
 8227e34:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 8227e38:	008209b4 	movhi	r2,2086
 8227e3c:	10b97a04 	addi	r2,r2,-6680
 8227e40:	e0bff515 	stw	r2,-44(fp)
 8227e44:	00000606 	br	8227e60 <bsd_getpeername+0x58>
 8227e48:	e0fff517 	ldw	r3,-44(fp)
 8227e4c:	e0bff617 	ldw	r2,-40(fp)
 8227e50:	18800626 	beq	r3,r2,8227e6c <bsd_getpeername+0x64>
 8227e54:	e0bff517 	ldw	r2,-44(fp)
 8227e58:	10800017 	ldw	r2,0(r2)
 8227e5c:	e0bff515 	stw	r2,-44(fp)
 8227e60:	e0bff517 	ldw	r2,-44(fp)
 8227e64:	103ff81e 	bne	r2,zero,8227e48 <bsd_getpeername+0x40>
 8227e68:	00000106 	br	8227e70 <bsd_getpeername+0x68>
 8227e6c:	0001883a 	nop
 8227e70:	e0fff517 	ldw	r3,-44(fp)
 8227e74:	e0bff617 	ldw	r2,-40(fp)
 8227e78:	18800326 	beq	r3,r2,8227e88 <bsd_getpeername+0x80>
 8227e7c:	822d5f00 	call	822d5f0 <dtrap>
 8227e80:	00bfffc4 	movi	r2,-1
 8227e84:	00002406 	br	8227f18 <bsd_getpeername+0x110>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 8227e88:	e0bfff17 	ldw	r2,-4(fp)
 8227e8c:	1000051e 	bne	r2,zero,8227ea4 <bsd_getpeername+0x9c>
   {
      so->so_error = EFAULT;
 8227e90:	e0bff617 	ldw	r2,-40(fp)
 8227e94:	00c00384 	movi	r3,14
 8227e98:	10c00615 	stw	r3,24(r2)
      return -1;
 8227e9c:	00bfffc4 	movi	r2,-1
 8227ea0:	00001d06 	br	8227f18 <bsd_getpeername+0x110>
   }
   lnamelen = *namelen;
 8227ea4:	e0bfff17 	ldw	r2,-4(fp)
 8227ea8:	10800017 	ldw	r2,0(r2)
 8227eac:	e0bffc15 	stw	r2,-16(fp)

   lret = t_getpeername(s, &lname, &lnamelen);
 8227eb0:	e0fffc04 	addi	r3,fp,-16
 8227eb4:	e0bff804 	addi	r2,fp,-32
 8227eb8:	180d883a 	mov	r6,r3
 8227ebc:	100b883a 	mov	r5,r2
 8227ec0:	e13ffd17 	ldw	r4,-12(fp)
 8227ec4:	8230c080 	call	8230c08 <t_getpeername>
 8227ec8:	e0bff715 	stw	r2,-36(fp)
    * t_getpeername() can return as a peer address, and pass the
    * copied length back to the caller.  
    * For IPV6 addresses, or for dual IPV4/IPV6 stack, 
    * the max size is sizeof(struct sockaddr_in6)
    */
   if (lret != -1)
 8227ecc:	e0bff717 	ldw	r2,-36(fp)
 8227ed0:	10bfffe0 	cmpeqi	r2,r2,-1
 8227ed4:	10000f1e 	bne	r2,zero,8227f14 <bsd_getpeername+0x10c>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 8227ed8:	e0bffc17 	ldw	r2,-16(fp)
 8227edc:	10800470 	cmpltui	r2,r2,17
 8227ee0:	1000021e 	bne	r2,zero,8227eec <bsd_getpeername+0xe4>
         lnamelen = sizeof(struct sockaddr_in);
 8227ee4:	00800404 	movi	r2,16
 8227ee8:	e0bffc15 	stw	r2,-16(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(name, &lname, lnamelen);
 8227eec:	e0bffc17 	ldw	r2,-16(fp)
 8227ef0:	1007883a 	mov	r3,r2
 8227ef4:	e0bff804 	addi	r2,fp,-32
 8227ef8:	180d883a 	mov	r6,r3
 8227efc:	100b883a 	mov	r5,r2
 8227f00:	e13ffe17 	ldw	r4,-8(fp)
 8227f04:	8202f6c0 	call	8202f6c <memcpy>
      *namelen = lnamelen;
 8227f08:	e0fffc17 	ldw	r3,-16(fp)
 8227f0c:	e0bfff17 	ldw	r2,-4(fp)
 8227f10:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 8227f14:	e0bff717 	ldw	r2,-36(fp)
}
 8227f18:	e037883a 	mov	sp,fp
 8227f1c:	dfc00117 	ldw	ra,4(sp)
 8227f20:	df000017 	ldw	fp,0(sp)
 8227f24:	dec00204 	addi	sp,sp,8
 8227f28:	f800283a 	ret

08227f2c <bsd_getsockname>:
 *          available via bsd_errno(s).
 */
int
bsd_getsockname(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 8227f2c:	defff304 	addi	sp,sp,-52
 8227f30:	dfc00c15 	stw	ra,48(sp)
 8227f34:	df000b15 	stw	fp,44(sp)
 8227f38:	df000b04 	addi	fp,sp,44
 8227f3c:	e13ffd15 	stw	r4,-12(fp)
 8227f40:	e17ffe15 	stw	r5,-8(fp)
 8227f44:	e1bfff15 	stw	r6,-4(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 8227f48:	e0bffd17 	ldw	r2,-12(fp)
 8227f4c:	10bff804 	addi	r2,r2,-32
 8227f50:	1085883a 	add	r2,r2,r2
 8227f54:	1085883a 	add	r2,r2,r2
 8227f58:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 8227f5c:	008209b4 	movhi	r2,2086
 8227f60:	10b97a04 	addi	r2,r2,-6680
 8227f64:	e0bff515 	stw	r2,-44(fp)
 8227f68:	00000606 	br	8227f84 <bsd_getsockname+0x58>
 8227f6c:	e0fff517 	ldw	r3,-44(fp)
 8227f70:	e0bff617 	ldw	r2,-40(fp)
 8227f74:	18800626 	beq	r3,r2,8227f90 <bsd_getsockname+0x64>
 8227f78:	e0bff517 	ldw	r2,-44(fp)
 8227f7c:	10800017 	ldw	r2,0(r2)
 8227f80:	e0bff515 	stw	r2,-44(fp)
 8227f84:	e0bff517 	ldw	r2,-44(fp)
 8227f88:	103ff81e 	bne	r2,zero,8227f6c <bsd_getsockname+0x40>
 8227f8c:	00000106 	br	8227f94 <bsd_getsockname+0x68>
 8227f90:	0001883a 	nop
 8227f94:	e0fff517 	ldw	r3,-44(fp)
 8227f98:	e0bff617 	ldw	r2,-40(fp)
 8227f9c:	18800326 	beq	r3,r2,8227fac <bsd_getsockname+0x80>
 8227fa0:	822d5f00 	call	822d5f0 <dtrap>
 8227fa4:	00bfffc4 	movi	r2,-1
 8227fa8:	00002406 	br	822803c <bsd_getsockname+0x110>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 8227fac:	e0bfff17 	ldw	r2,-4(fp)
 8227fb0:	1000051e 	bne	r2,zero,8227fc8 <bsd_getsockname+0x9c>
   {
      so->so_error = EFAULT;
 8227fb4:	e0bff617 	ldw	r2,-40(fp)
 8227fb8:	00c00384 	movi	r3,14
 8227fbc:	10c00615 	stw	r3,24(r2)
      return -1;
 8227fc0:	00bfffc4 	movi	r2,-1
 8227fc4:	00001d06 	br	822803c <bsd_getsockname+0x110>
   }
   lnamelen = *namelen;
 8227fc8:	e0bfff17 	ldw	r2,-4(fp)
 8227fcc:	10800017 	ldw	r2,0(r2)
 8227fd0:	e0bffc15 	stw	r2,-16(fp)

   lret = t_getsockname(s, &lname, &lnamelen);
 8227fd4:	e0fffc04 	addi	r3,fp,-16
 8227fd8:	e0bff804 	addi	r2,fp,-32
 8227fdc:	180d883a 	mov	r6,r3
 8227fe0:	100b883a 	mov	r5,r2
 8227fe4:	e13ffd17 	ldw	r4,-12(fp)
 8227fe8:	8230c4c0 	call	8230c4c <t_getsockname>
 8227fec:	e0bff715 	stw	r2,-36(fp)
    * copied length back to the caller.  
    * For IPV6 addresses, or for a dual IPV4/IPV6 stack, 
    * the max size copied is sizeof(struct sockaddr_in6)
    *
    */
   if (lret != -1)
 8227ff0:	e0bff717 	ldw	r2,-36(fp)
 8227ff4:	10bfffe0 	cmpeqi	r2,r2,-1
 8227ff8:	10000f1e 	bne	r2,zero,8228038 <bsd_getsockname+0x10c>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 8227ffc:	e0bffc17 	ldw	r2,-16(fp)
 8228000:	10800470 	cmpltui	r2,r2,17
 8228004:	1000021e 	bne	r2,zero,8228010 <bsd_getsockname+0xe4>
         lnamelen = sizeof(struct sockaddr_in);
 8228008:	00800404 	movi	r2,16
 822800c:	e0bffc15 	stw	r2,-16(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);
#endif
      MEMCPY(name, &lname, lnamelen);
 8228010:	e0bffc17 	ldw	r2,-16(fp)
 8228014:	1007883a 	mov	r3,r2
 8228018:	e0bff804 	addi	r2,fp,-32
 822801c:	180d883a 	mov	r6,r3
 8228020:	100b883a 	mov	r5,r2
 8228024:	e13ffe17 	ldw	r4,-8(fp)
 8228028:	8202f6c0 	call	8202f6c <memcpy>
      *namelen = lnamelen;
 822802c:	e0fffc17 	ldw	r3,-16(fp)
 8228030:	e0bfff17 	ldw	r2,-4(fp)
 8228034:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 8228038:	e0bff717 	ldw	r2,-36(fp)
}
 822803c:	e037883a 	mov	sp,fp
 8228040:	dfc00117 	ldw	ra,4(sp)
 8228044:	df000017 	ldw	fp,0(sp)
 8228048:	dec00204 	addi	sp,sp,8
 822804c:	f800283a 	ret

08228050 <bsd_i_sockoptlen>:
 * RETURNS: minimum length of the named socket option, in bytes
 */
int 
bsd_i_sockoptlen(int level,
                 int name)
{
 8228050:	defffd04 	addi	sp,sp,-12
 8228054:	df000215 	stw	fp,8(sp)
 8228058:	df000204 	addi	fp,sp,8
 822805c:	e13ffe15 	stw	r4,-8(fp)
 8228060:	e17fff15 	stw	r5,-4(fp)
   USE_ARG(level);

   switch (name)
 8228064:	e0bfff17 	ldw	r2,-4(fp)
 8228068:	10c02020 	cmpeqi	r3,r2,128
 822806c:	1800341e 	bne	r3,zero,8228140 <bsd_i_sockoptlen+0xf0>
 8228070:	10c02048 	cmpgei	r3,r2,129
 8228074:	18001a1e 	bne	r3,zero,82280e0 <bsd_i_sockoptlen+0x90>
 8228078:	10c00308 	cmpgei	r3,r2,12
 822807c:	18000e1e 	bne	r3,zero,82280b8 <bsd_i_sockoptlen+0x68>
 8228080:	10c00288 	cmpgei	r3,r2,10
 8228084:	1800361e 	bne	r3,zero,8228160 <bsd_i_sockoptlen+0x110>
 8228088:	10c00120 	cmpeqi	r3,r2,4
 822808c:	1800301e 	bne	r3,zero,8228150 <bsd_i_sockoptlen+0x100>
 8228090:	10c00148 	cmpgei	r3,r2,5
 8228094:	1800031e 	bne	r3,zero,82280a4 <bsd_i_sockoptlen+0x54>
 8228098:	108000e0 	cmpeqi	r2,r2,3
 822809c:	1000341e 	bne	r2,zero,8228170 <bsd_i_sockoptlen+0x120>
 82280a0:	00003506 	br	8228178 <bsd_i_sockoptlen+0x128>
 82280a4:	10c00220 	cmpeqi	r3,r2,8
 82280a8:	1800291e 	bne	r3,zero,8228150 <bsd_i_sockoptlen+0x100>
 82280ac:	10800260 	cmpeqi	r2,r2,9
 82280b0:	1000291e 	bne	r2,zero,8228158 <bsd_i_sockoptlen+0x108>
 82280b4:	00003006 	br	8228178 <bsd_i_sockoptlen+0x128>
 82280b8:	10c00420 	cmpeqi	r3,r2,16
 82280bc:	1800241e 	bne	r3,zero,8228150 <bsd_i_sockoptlen+0x100>
 82280c0:	10c00448 	cmpgei	r3,r2,17
 82280c4:	1800031e 	bne	r3,zero,82280d4 <bsd_i_sockoptlen+0x84>
 82280c8:	10800388 	cmpgei	r2,r2,14
 82280cc:	10002a1e 	bne	r2,zero,8228178 <bsd_i_sockoptlen+0x128>
 82280d0:	00002506 	br	8228168 <bsd_i_sockoptlen+0x118>
 82280d4:	10800820 	cmpeqi	r2,r2,32
 82280d8:	10001d1e 	bne	r2,zero,8228150 <bsd_i_sockoptlen+0x100>
 82280dc:	00002606 	br	8228178 <bsd_i_sockoptlen+0x128>
 82280e0:	10c401c8 	cmpgei	r3,r2,4103
 82280e4:	18000a1e 	bne	r3,zero,8228110 <bsd_i_sockoptlen+0xc0>
 82280e8:	10c40148 	cmpgei	r3,r2,4101
 82280ec:	1800161e 	bne	r3,zero,8228148 <bsd_i_sockoptlen+0xf8>
 82280f0:	10c04020 	cmpeqi	r3,r2,256
 82280f4:	1800161e 	bne	r3,zero,8228150 <bsd_i_sockoptlen+0x100>
 82280f8:	10c04010 	cmplti	r3,r2,256
 82280fc:	18001e1e 	bne	r3,zero,8228178 <bsd_i_sockoptlen+0x128>
 8228100:	10bbffc4 	addi	r2,r2,-4097
 8228104:	108000a8 	cmpgeui	r2,r2,2
 8228108:	10001b1e 	bne	r2,zero,8228178 <bsd_i_sockoptlen+0x128>
 822810c:	00001006 	br	8228150 <bsd_i_sockoptlen+0x100>
 8228110:	10c40588 	cmpgei	r3,r2,4118
 8228114:	1800051e 	bne	r3,zero,822812c <bsd_i_sockoptlen+0xdc>
 8228118:	10c40508 	cmpgei	r3,r2,4116
 822811c:	1800061e 	bne	r3,zero,8228138 <bsd_i_sockoptlen+0xe8>
 8228120:	10840248 	cmpgei	r2,r2,4105
 8228124:	1000141e 	bne	r2,zero,8228178 <bsd_i_sockoptlen+0x128>
 8228128:	00000906 	br	8228150 <bsd_i_sockoptlen+0x100>
 822812c:	108405a0 	cmpeqi	r2,r2,4118
 8228130:	1000071e 	bne	r2,zero,8228150 <bsd_i_sockoptlen+0x100>
 8228134:	00001006 	br	8228178 <bsd_i_sockoptlen+0x128>
   {
   case SO_BIO:
   case SO_NBIO:
      /* these don't use an option value */
      return 0;
 8228138:	0005883a 	mov	r2,zero
 822813c:	00000f06 	br	822817c <bsd_i_sockoptlen+0x12c>
   case SO_LINGER:
      /* this option is a struct linger */
      return sizeof(struct linger);
 8228140:	00800204 	movi	r2,8
 8228144:	00000d06 	br	822817c <bsd_i_sockoptlen+0x12c>
   case SO_RCVTIMEO:
   case SO_SNDTIMEO:
      /* these options are type short */
      return sizeof(short);
 8228148:	00800084 	movi	r2,2
 822814c:	00000b06 	br	822817c <bsd_i_sockoptlen+0x12c>
   case SO_RCVBUF:
   case SO_NONBLOCK:
   case SO_ERROR:
   case SO_TYPE:
      /* these options are type int */
      return sizeof(int);
 8228150:	00800104 	movi	r2,4
 8228154:	00000906 	br	822817c <bsd_i_sockoptlen+0x12c>
      return sizeof(int (*)());
#endif /* TCP_ZEROCOPY */
#ifdef IP_MULTICAST
   case IP_MULTICAST_IF:
      /* this option is type ip_addr */
      return sizeof(ip_addr);
 8228158:	00800104 	movi	r2,4
 822815c:	00000706 	br	822817c <bsd_i_sockoptlen+0x12c>
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      /* these options are type u_char */
      return sizeof(u_char);
 8228160:	00800044 	movi	r2,1
 8228164:	00000506 	br	822817c <bsd_i_sockoptlen+0x12c>
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      /* these options are struct ip_mreq */
      return sizeof(struct ip_mreq);
 8228168:	00800204 	movi	r2,8
 822816c:	00000306 	br	822817c <bsd_i_sockoptlen+0x12c>
 * IP_TTL_OPT == SOREUSEADDR. This causes a build erro
 * due to duplicate cases. Removing this one. They both
 * return the same value (sizeof(int)).
 */
  // case IP_TTL_OPT:
      return sizeof(int);
 8228170:	00800104 	movi	r2,4
 8228174:	00000106 	br	822817c <bsd_i_sockoptlen+0x12c>
   default:
      /* we don't know what type these options are */
      return 0;
 8228178:	0005883a 	mov	r2,zero
   }
   
}
 822817c:	e037883a 	mov	sp,fp
 8228180:	df000017 	ldw	fp,0(sp)
 8228184:	dec00104 	addi	sp,sp,4
 8228188:	f800283a 	ret

0822818c <bsd_getsockopt>:
int
bsd_getsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int * optlen)
{
 822818c:	defff504 	addi	sp,sp,-44
 8228190:	dfc00a15 	stw	ra,40(sp)
 8228194:	df000915 	stw	fp,36(sp)
 8228198:	df000904 	addi	fp,sp,36
 822819c:	e13ffc15 	stw	r4,-16(fp)
 82281a0:	e17ffd15 	stw	r5,-12(fp)
 82281a4:	e1bffe15 	stw	r6,-8(fp)
 82281a8:	e1ffff15 	stw	r7,-4(fp)
   struct socket * so;
   int loptlen;
   int e;

   so = LONG2SO(s);
 82281ac:	e0bffc17 	ldw	r2,-16(fp)
 82281b0:	10bff804 	addi	r2,r2,-32
 82281b4:	1085883a 	add	r2,r2,r2
 82281b8:	1085883a 	add	r2,r2,r2
 82281bc:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 82281c0:	008209b4 	movhi	r2,2086
 82281c4:	10b97a04 	addi	r2,r2,-6680
 82281c8:	e0bff815 	stw	r2,-32(fp)
 82281cc:	00000606 	br	82281e8 <bsd_getsockopt+0x5c>
 82281d0:	e0fff817 	ldw	r3,-32(fp)
 82281d4:	e0bff917 	ldw	r2,-28(fp)
 82281d8:	18800626 	beq	r3,r2,82281f4 <bsd_getsockopt+0x68>
 82281dc:	e0bff817 	ldw	r2,-32(fp)
 82281e0:	10800017 	ldw	r2,0(r2)
 82281e4:	e0bff815 	stw	r2,-32(fp)
 82281e8:	e0bff817 	ldw	r2,-32(fp)
 82281ec:	103ff81e 	bne	r2,zero,82281d0 <bsd_getsockopt+0x44>
 82281f0:	00000106 	br	82281f8 <bsd_getsockopt+0x6c>
 82281f4:	0001883a 	nop
 82281f8:	e0fff817 	ldw	r3,-32(fp)
 82281fc:	e0bff917 	ldw	r2,-28(fp)
 8228200:	18800326 	beq	r3,r2,8228210 <bsd_getsockopt+0x84>
 8228204:	822d5f00 	call	822d5f0 <dtrap>
 8228208:	00bfffc4 	movi	r2,-1
 822820c:	00001d06 	br	8228284 <bsd_getsockopt+0xf8>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   loptlen = bsd_i_sockoptlen(level, name);
 8228210:	e17ffe17 	ldw	r5,-8(fp)
 8228214:	e13ffd17 	ldw	r4,-12(fp)
 8228218:	82280500 	call	8228050 <bsd_i_sockoptlen>
 822821c:	e0bffa15 	stw	r2,-24(fp)
   if ((optlen == NULL) || (*optlen < loptlen))
 8228220:	e0800217 	ldw	r2,8(fp)
 8228224:	10000426 	beq	r2,zero,8228238 <bsd_getsockopt+0xac>
 8228228:	e0800217 	ldw	r2,8(fp)
 822822c:	10c00017 	ldw	r3,0(r2)
 8228230:	e0bffa17 	ldw	r2,-24(fp)
 8228234:	1880050e 	bge	r3,r2,822824c <bsd_getsockopt+0xc0>
   {
      so->so_error = EFAULT;
 8228238:	e0bff917 	ldw	r2,-28(fp)
 822823c:	00c00384 	movi	r3,14
 8228240:	10c00615 	stw	r3,24(r2)
      return -1;
 8228244:	00bfffc4 	movi	r2,-1
 8228248:	00000e06 	br	8228284 <bsd_getsockopt+0xf8>
   }

   e = t_getsockopt(s, level, name, opt, loptlen);
 822824c:	e0bffa17 	ldw	r2,-24(fp)
 8228250:	d8800015 	stw	r2,0(sp)
 8228254:	e1ffff17 	ldw	r7,-4(fp)
 8228258:	e1bffe17 	ldw	r6,-8(fp)
 822825c:	e17ffd17 	ldw	r5,-12(fp)
 8228260:	e13ffc17 	ldw	r4,-16(fp)
 8228264:	823102c0 	call	823102c <t_getsockopt>
 8228268:	e0bffb15 	stw	r2,-20(fp)

   /* if it worked, copy the option length back for the caller's use */
   if (e == 0)
 822826c:	e0bffb17 	ldw	r2,-20(fp)
 8228270:	1000031e 	bne	r2,zero,8228280 <bsd_getsockopt+0xf4>
   {
      *optlen = loptlen;
 8228274:	e0800217 	ldw	r2,8(fp)
 8228278:	e0fffa17 	ldw	r3,-24(fp)
 822827c:	10c00015 	stw	r3,0(r2)
   }

   return e;
 8228280:	e0bffb17 	ldw	r2,-20(fp)
   
}
 8228284:	e037883a 	mov	sp,fp
 8228288:	dfc00117 	ldw	ra,4(sp)
 822828c:	df000017 	ldw	fp,0(sp)
 8228290:	dec00204 	addi	sp,sp,8
 8228294:	f800283a 	ret

08228298 <bsd_ioctl>:
 *          available via bsd_errno(s).
 */
int
bsd_ioctl(BSD_SOCKET s, 
          unsigned long request, ...)
{
 8228298:	defff504 	addi	sp,sp,-44
 822829c:	dfc00815 	stw	ra,32(sp)
 82282a0:	df000715 	stw	fp,28(sp)
 82282a4:	df000704 	addi	fp,sp,28
 82282a8:	e13ffe15 	stw	r4,-8(fp)
 82282ac:	e17fff15 	stw	r5,-4(fp)
 82282b0:	e1800215 	stw	r6,8(fp)
 82282b4:	e1c00315 	stw	r7,12(fp)
   struct socket * so;
   va_list argptr;
   int iarg;

   so = LONG2SO(s);
 82282b8:	e0bffe17 	ldw	r2,-8(fp)
 82282bc:	10bff804 	addi	r2,r2,-32
 82282c0:	1085883a 	add	r2,r2,r2
 82282c4:	1085883a 	add	r2,r2,r2
 82282c8:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 82282cc:	008209b4 	movhi	r2,2086
 82282d0:	10b97a04 	addi	r2,r2,-6680
 82282d4:	e0bffa15 	stw	r2,-24(fp)
 82282d8:	00000606 	br	82282f4 <bsd_ioctl+0x5c>
 82282dc:	e0fffa17 	ldw	r3,-24(fp)
 82282e0:	e0bffb17 	ldw	r2,-20(fp)
 82282e4:	18800626 	beq	r3,r2,8228300 <bsd_ioctl+0x68>
 82282e8:	e0bffa17 	ldw	r2,-24(fp)
 82282ec:	10800017 	ldw	r2,0(r2)
 82282f0:	e0bffa15 	stw	r2,-24(fp)
 82282f4:	e0bffa17 	ldw	r2,-24(fp)
 82282f8:	103ff81e 	bne	r2,zero,82282dc <bsd_ioctl+0x44>
 82282fc:	00000106 	br	8228304 <bsd_ioctl+0x6c>
 8228300:	0001883a 	nop
 8228304:	e0fffa17 	ldw	r3,-24(fp)
 8228308:	e0bffb17 	ldw	r2,-20(fp)
 822830c:	18800326 	beq	r3,r2,822831c <bsd_ioctl+0x84>
 8228310:	822d5f00 	call	822d5f0 <dtrap>
 8228314:	00bfffc4 	movi	r2,-1
 8228318:	00001706 	br	8228378 <bsd_ioctl+0xe0>

   va_start(argptr, request);
 822831c:	e0800204 	addi	r2,fp,8
 8228320:	e0bffc15 	stw	r2,-16(fp)

   switch (request)
 8228324:	e0bfff17 	ldw	r2,-4(fp)
 8228328:	108405a0 	cmpeqi	r2,r2,4118
 822832c:	10000e26 	beq	r2,zero,8228368 <bsd_ioctl+0xd0>
   {
   case FIONBIO:
      iarg = va_arg(argptr, int);
 8228330:	e0bffc17 	ldw	r2,-16(fp)
 8228334:	10c00104 	addi	r3,r2,4
 8228338:	e0fffc15 	stw	r3,-16(fp)
 822833c:	10800017 	ldw	r2,0(r2)
 8228340:	e0bffd15 	stw	r2,-12(fp)
      va_end(argptr);
      return t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, &iarg, sizeof(iarg));
 8228344:	e0fffd04 	addi	r3,fp,-12
 8228348:	00800104 	movi	r2,4
 822834c:	d8800015 	stw	r2,0(sp)
 8228350:	180f883a 	mov	r7,r3
 8228354:	01840584 	movi	r6,4118
 8228358:	017fffc4 	movi	r5,-1
 822835c:	e13ffe17 	ldw	r4,-8(fp)
 8228360:	8230e6c0 	call	8230e6c <t_setsockopt>
 8228364:	00000406 	br	8228378 <bsd_ioctl+0xe0>
   default:
      so->so_error = EINVAL;
 8228368:	e0bffb17 	ldw	r2,-20(fp)
 822836c:	00c00584 	movi	r3,22
 8228370:	10c00615 	stw	r3,24(r2)
      return -1;
 8228374:	00bfffc4 	movi	r2,-1
   }
}
 8228378:	e037883a 	mov	sp,fp
 822837c:	dfc00117 	ldw	ra,4(sp)
 8228380:	df000017 	ldw	fp,0(sp)
 8228384:	dec00404 	addi	sp,sp,16
 8228388:	f800283a 	ret

0822838c <bsd_inet_ntoa>:
 * RETURNS: pointer to null-terminated string containing dotted-decimal
 *          printable representation of in
 */
char *
bsd_inet_ntoa(struct in_addr in)
{
 822838c:	defffd04 	addi	sp,sp,-12
 8228390:	dfc00215 	stw	ra,8(sp)
 8228394:	df000115 	stw	fp,4(sp)
 8228398:	df000104 	addi	fp,sp,4
 822839c:	e13fff15 	stw	r4,-4(fp)
   return print_ipad(in.s_addr);
 82283a0:	e0bfff17 	ldw	r2,-4(fp)
 82283a4:	1009883a 	mov	r4,r2
 82283a8:	8228a500 	call	8228a50 <print_ipad>
}
 82283ac:	e037883a 	mov	sp,fp
 82283b0:	dfc00117 	ldw	ra,4(sp)
 82283b4:	df000017 	ldw	fp,0(sp)
 82283b8:	dec00204 	addi	sp,sp,8
 82283bc:	f800283a 	ret

082283c0 <bsd_recvfrom>:
bsd_recvfrom(BSD_SOCKET s,
             void * buf,
             BSD_SIZE_T len,
             int flags,
             struct sockaddr * from, int * fromlen)
{
 82283c0:	defff004 	addi	sp,sp,-64
 82283c4:	dfc00f15 	stw	ra,60(sp)
 82283c8:	df000e15 	stw	fp,56(sp)
 82283cc:	df000e04 	addi	fp,sp,56
 82283d0:	e13ffc15 	stw	r4,-16(fp)
 82283d4:	e17ffd15 	stw	r5,-12(fp)
 82283d8:	e1bffe15 	stw	r6,-8(fp)
 82283dc:	e1ffff15 	stw	r7,-4(fp)
   struct socket * so;
   struct sockaddr lfrom;
   int lfromlen = 0;
 82283e0:	e03ffb15 	stw	zero,-20(fp)
   int lret;

   so = LONG2SO(s);
 82283e4:	e0bffc17 	ldw	r2,-16(fp)
 82283e8:	10bff804 	addi	r2,r2,-32
 82283ec:	1085883a 	add	r2,r2,r2
 82283f0:	1085883a 	add	r2,r2,r2
 82283f4:	e0bff515 	stw	r2,-44(fp)
   SOC_CHECK(so);
 82283f8:	008209b4 	movhi	r2,2086
 82283fc:	10b97a04 	addi	r2,r2,-6680
 8228400:	e0bff415 	stw	r2,-48(fp)
 8228404:	00000606 	br	8228420 <bsd_recvfrom+0x60>
 8228408:	e0fff417 	ldw	r3,-48(fp)
 822840c:	e0bff517 	ldw	r2,-44(fp)
 8228410:	18800626 	beq	r3,r2,822842c <bsd_recvfrom+0x6c>
 8228414:	e0bff417 	ldw	r2,-48(fp)
 8228418:	10800017 	ldw	r2,0(r2)
 822841c:	e0bff415 	stw	r2,-48(fp)
 8228420:	e0bff417 	ldw	r2,-48(fp)
 8228424:	103ff81e 	bne	r2,zero,8228408 <bsd_recvfrom+0x48>
 8228428:	00000106 	br	8228430 <bsd_recvfrom+0x70>
 822842c:	0001883a 	nop
 8228430:	e0fff417 	ldw	r3,-48(fp)
 8228434:	e0bff517 	ldw	r2,-44(fp)
 8228438:	18800326 	beq	r3,r2,8228448 <bsd_recvfrom+0x88>
 822843c:	822d5f00 	call	822d5f0 <dtrap>
 8228440:	00bfffc4 	movi	r2,-1
 8228444:	00002b06 	br	82284f4 <bsd_recvfrom+0x134>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (from != NULL)
 8228448:	e0800217 	ldw	r2,8(fp)
 822844c:	10000a26 	beq	r2,zero,8228478 <bsd_recvfrom+0xb8>
   {
      if (fromlen == NULL)
 8228450:	e0800317 	ldw	r2,12(fp)
 8228454:	1000051e 	bne	r2,zero,822846c <bsd_recvfrom+0xac>
      {
         so->so_error = EFAULT;
 8228458:	e0bff517 	ldw	r2,-44(fp)
 822845c:	00c00384 	movi	r3,14
 8228460:	10c00615 	stw	r3,24(r2)
         return -1;
 8228464:	00bfffc4 	movi	r2,-1
 8228468:	00002206 	br	82284f4 <bsd_recvfrom+0x134>
      }
      lfromlen = *fromlen;
 822846c:	e0800317 	ldw	r2,12(fp)
 8228470:	10800017 	ldw	r2,0(r2)
 8228474:	e0bffb15 	stw	r2,-20(fp)
   }

   lret = t_recvfrom(s, (char *)buf, len, flags, &lfrom, &lfromlen );
 8228478:	e0bffb04 	addi	r2,fp,-20
 822847c:	d8800115 	stw	r2,4(sp)
 8228480:	e0bff704 	addi	r2,fp,-36
 8228484:	d8800015 	stw	r2,0(sp)
 8228488:	e1ffff17 	ldw	r7,-4(fp)
 822848c:	e1bffe17 	ldw	r6,-8(fp)
 8228490:	e17ffd17 	ldw	r5,-12(fp)
 8228494:	e13ffc17 	ldw	r4,-16(fp)
 8228498:	82312980 	call	8231298 <t_recvfrom>
 822849c:	e0bff615 	stw	r2,-40(fp)
    * sockaddr_in), which is all that t_recvfrom() can return as a peer
    * name.
    * For IPV6 addresses or dual IPV4/IPV6 stack, the max size copied
    * is sizeof(struct sockaddr_in6)
    */
   if ((lret != -1) && (from != NULL))
 82284a0:	e0bff617 	ldw	r2,-40(fp)
 82284a4:	10bfffe0 	cmpeqi	r2,r2,-1
 82284a8:	1000111e 	bne	r2,zero,82284f0 <bsd_recvfrom+0x130>
 82284ac:	e0800217 	ldw	r2,8(fp)
 82284b0:	10000f26 	beq	r2,zero,82284f0 <bsd_recvfrom+0x130>
   {
#ifndef IP_V6
      if (lfromlen > sizeof(struct sockaddr_in))
 82284b4:	e0bffb17 	ldw	r2,-20(fp)
 82284b8:	10800470 	cmpltui	r2,r2,17
 82284bc:	1000021e 	bne	r2,zero,82284c8 <bsd_recvfrom+0x108>
         lfromlen = sizeof(struct sockaddr_in);
 82284c0:	00800404 	movi	r2,16
 82284c4:	e0bffb15 	stw	r2,-20(fp)
#else
      if (lfromlen > sizeof(struct sockaddr_in6))
         lfromlen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(from, &lfrom, lfromlen);
 82284c8:	e0bffb17 	ldw	r2,-20(fp)
 82284cc:	1007883a 	mov	r3,r2
 82284d0:	e0bff704 	addi	r2,fp,-36
 82284d4:	180d883a 	mov	r6,r3
 82284d8:	100b883a 	mov	r5,r2
 82284dc:	e1000217 	ldw	r4,8(fp)
 82284e0:	8202f6c0 	call	8202f6c <memcpy>
      *fromlen = lfromlen;
 82284e4:	e0fffb17 	ldw	r3,-20(fp)
 82284e8:	e0800317 	ldw	r2,12(fp)
 82284ec:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 82284f0:	e0bff617 	ldw	r2,-40(fp)
}
 82284f4:	e037883a 	mov	sp,fp
 82284f8:	dfc00117 	ldw	ra,4(sp)
 82284fc:	df000017 	ldw	fp,0(sp)
 8228500:	dec00204 	addi	sp,sp,8
 8228504:	f800283a 	ret

08228508 <bsd_select>:
bsd_select(int nfds,
           fd_set * readfds,
           fd_set * writefds,
           fd_set * exceptfds,
           BSD_TIMEVAL_T * timeout)
{
 8228508:	defff804 	addi	sp,sp,-32
 822850c:	dfc00715 	stw	ra,28(sp)
 8228510:	df000615 	stw	fp,24(sp)
 8228514:	df000604 	addi	fp,sp,24
 8228518:	e13ffc15 	stw	r4,-16(fp)
 822851c:	e17ffd15 	stw	r5,-12(fp)
 8228520:	e1bffe15 	stw	r6,-8(fp)
 8228524:	e1ffff15 	stw	r7,-4(fp)
   long ltv;    /* timeout expressed in ticks */
   long tps;    /* local copy of TPS */

   USE_ARG(nfds);

   if (timeout != NULL)
 8228528:	e0800217 	ldw	r2,8(fp)
 822852c:	10004b26 	beq	r2,zero,822865c <bsd_select+0x154>
       * million (i.e. any number of microseconds up to one second).
       * So we scale tv_usec from microseconds to something reasonable
       * based on TPS, multiply it by TPS, then scale it the rest of
       * the way to ticks-per-second.
       */
      tps = TPS;
 8228530:	00801904 	movi	r2,100
 8228534:	e0bffb15 	stw	r2,-20(fp)
      if (tps >= 1000)
 8228538:	e0bffb17 	ldw	r2,-20(fp)
 822853c:	1080fa10 	cmplti	r2,r2,1000
 8228540:	10000e1e 	bne	r2,zero,822857c <bsd_select+0x74>
      {
         ltv = (((timeout->tv_usec + 50) / 100) * tps) / 10000;
 8228544:	e0800217 	ldw	r2,8(fp)
 8228548:	10800117 	ldw	r2,4(r2)
 822854c:	10800c84 	addi	r2,r2,50
 8228550:	01401904 	movi	r5,100
 8228554:	1009883a 	mov	r4,r2
 8228558:	8202b740 	call	8202b74 <__divsi3>
 822855c:	1007883a 	mov	r3,r2
 8228560:	e0bffb17 	ldw	r2,-20(fp)
 8228564:	1885383a 	mul	r2,r3,r2
 8228568:	0149c404 	movi	r5,10000
 822856c:	1009883a 	mov	r4,r2
 8228570:	8202b740 	call	8202b74 <__divsi3>
 8228574:	e0bffa15 	stw	r2,-24(fp)
 8228578:	00003106 	br	8228640 <bsd_select+0x138>
      }
      else if (tps >= 100)
 822857c:	e0bffb17 	ldw	r2,-20(fp)
 8228580:	10801910 	cmplti	r2,r2,100
 8228584:	10000e1e 	bne	r2,zero,82285c0 <bsd_select+0xb8>
      {
         ltv = (((timeout->tv_usec + 500) / 1000) * tps) / 1000;
 8228588:	e0800217 	ldw	r2,8(fp)
 822858c:	10800117 	ldw	r2,4(r2)
 8228590:	10807d04 	addi	r2,r2,500
 8228594:	0140fa04 	movi	r5,1000
 8228598:	1009883a 	mov	r4,r2
 822859c:	8202b740 	call	8202b74 <__divsi3>
 82285a0:	1007883a 	mov	r3,r2
 82285a4:	e0bffb17 	ldw	r2,-20(fp)
 82285a8:	1885383a 	mul	r2,r3,r2
 82285ac:	0140fa04 	movi	r5,1000
 82285b0:	1009883a 	mov	r4,r2
 82285b4:	8202b740 	call	8202b74 <__divsi3>
 82285b8:	e0bffa15 	stw	r2,-24(fp)
 82285bc:	00002006 	br	8228640 <bsd_select+0x138>
      }
      else if (tps >= 10)
 82285c0:	e0bffb17 	ldw	r2,-20(fp)
 82285c4:	10800290 	cmplti	r2,r2,10
 82285c8:	10000e1e 	bne	r2,zero,8228604 <bsd_select+0xfc>
      {
         ltv = (((timeout->tv_usec + 5000) / 10000) * tps) / 100;
 82285cc:	e0800217 	ldw	r2,8(fp)
 82285d0:	10800117 	ldw	r2,4(r2)
 82285d4:	1084e204 	addi	r2,r2,5000
 82285d8:	0149c404 	movi	r5,10000
 82285dc:	1009883a 	mov	r4,r2
 82285e0:	8202b740 	call	8202b74 <__divsi3>
 82285e4:	1007883a 	mov	r3,r2
 82285e8:	e0bffb17 	ldw	r2,-20(fp)
 82285ec:	1885383a 	mul	r2,r3,r2
 82285f0:	01401904 	movi	r5,100
 82285f4:	1009883a 	mov	r4,r2
 82285f8:	8202b740 	call	8202b74 <__divsi3>
 82285fc:	e0bffa15 	stw	r2,-24(fp)
 8228600:	00000f06 	br	8228640 <bsd_select+0x138>
      }
      else
      {
         ltv = (((timeout->tv_usec + 50000) / 100000) * tps) / 10;
 8228604:	e0800217 	ldw	r2,8(fp)
 8228608:	10c00117 	ldw	r3,4(r2)
 822860c:	00b0d414 	movui	r2,50000
 8228610:	1885883a 	add	r2,r3,r2
 8228614:	014000b4 	movhi	r5,2
 8228618:	2961a804 	addi	r5,r5,-31072
 822861c:	1009883a 	mov	r4,r2
 8228620:	8202b740 	call	8202b74 <__divsi3>
 8228624:	1007883a 	mov	r3,r2
 8228628:	e0bffb17 	ldw	r2,-20(fp)
 822862c:	1885383a 	mul	r2,r3,r2
 8228630:	01400284 	movi	r5,10
 8228634:	1009883a 	mov	r4,r2
 8228638:	8202b740 	call	8202b74 <__divsi3>
 822863c:	e0bffa15 	stw	r2,-24(fp)
      }
      ltv += (timeout->tv_sec * TPS);
 8228640:	e0800217 	ldw	r2,8(fp)
 8228644:	10800017 	ldw	r2,0(r2)
 8228648:	10801924 	muli	r2,r2,100
 822864c:	e0fffa17 	ldw	r3,-24(fp)
 8228650:	1885883a 	add	r2,r3,r2
 8228654:	e0bffa15 	stw	r2,-24(fp)
 8228658:	00000206 	br	8228664 <bsd_select+0x15c>
   }
   else {
      /*
       * NULL timeout: wait indefinitely in t_select()
       */
      ltv = -1;
 822865c:	00bfffc4 	movi	r2,-1
 8228660:	e0bffa15 	stw	r2,-24(fp)
   }

   return (t_select(readfds, writefds, exceptfds, ltv));
 8228664:	e1fffa17 	ldw	r7,-24(fp)
 8228668:	e1bfff17 	ldw	r6,-4(fp)
 822866c:	e17ffe17 	ldw	r5,-8(fp)
 8228670:	e13ffd17 	ldw	r4,-12(fp)
 8228674:	8234d500 	call	8234d50 <t_select>
}
 8228678:	e037883a 	mov	sp,fp
 822867c:	dfc00117 	ldw	ra,4(sp)
 8228680:	df000017 	ldw	fp,0(sp)
 8228684:	dec00204 	addi	sp,sp,8
 8228688:	f800283a 	ret

0822868c <bsd_setsockopt>:
int 
bsd_setsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int optlen)
{
 822868c:	defff704 	addi	sp,sp,-36
 8228690:	dfc00815 	stw	ra,32(sp)
 8228694:	df000715 	stw	fp,28(sp)
 8228698:	df000704 	addi	fp,sp,28
 822869c:	e13ffc15 	stw	r4,-16(fp)
 82286a0:	e17ffd15 	stw	r5,-12(fp)
 82286a4:	e1bffe15 	stw	r6,-8(fp)
 82286a8:	e1ffff15 	stw	r7,-4(fp)
   struct socket * so;

   so = LONG2SO(s);
 82286ac:	e0bffc17 	ldw	r2,-16(fp)
 82286b0:	10bff804 	addi	r2,r2,-32
 82286b4:	1085883a 	add	r2,r2,r2
 82286b8:	1085883a 	add	r2,r2,r2
 82286bc:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 82286c0:	008209b4 	movhi	r2,2086
 82286c4:	10b97a04 	addi	r2,r2,-6680
 82286c8:	e0bffa15 	stw	r2,-24(fp)
 82286cc:	00000606 	br	82286e8 <bsd_setsockopt+0x5c>
 82286d0:	e0fffa17 	ldw	r3,-24(fp)
 82286d4:	e0bffb17 	ldw	r2,-20(fp)
 82286d8:	18800626 	beq	r3,r2,82286f4 <bsd_setsockopt+0x68>
 82286dc:	e0bffa17 	ldw	r2,-24(fp)
 82286e0:	10800017 	ldw	r2,0(r2)
 82286e4:	e0bffa15 	stw	r2,-24(fp)
 82286e8:	e0bffa17 	ldw	r2,-24(fp)
 82286ec:	103ff81e 	bne	r2,zero,82286d0 <bsd_setsockopt+0x44>
 82286f0:	00000106 	br	82286f8 <bsd_setsockopt+0x6c>
 82286f4:	0001883a 	nop
 82286f8:	e0fffa17 	ldw	r3,-24(fp)
 82286fc:	e0bffb17 	ldw	r2,-20(fp)
 8228700:	18800326 	beq	r3,r2,8228710 <bsd_setsockopt+0x84>
 8228704:	822d5f00 	call	822d5f0 <dtrap>
 8228708:	00bfffc4 	movi	r2,-1
 822870c:	00001206 	br	8228758 <bsd_setsockopt+0xcc>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   if (optlen < bsd_i_sockoptlen(level, name))
 8228710:	e17ffe17 	ldw	r5,-8(fp)
 8228714:	e13ffd17 	ldw	r4,-12(fp)
 8228718:	82280500 	call	8228050 <bsd_i_sockoptlen>
 822871c:	1007883a 	mov	r3,r2
 8228720:	e0800217 	ldw	r2,8(fp)
 8228724:	10c0050e 	bge	r2,r3,822873c <bsd_setsockopt+0xb0>
   {
      so->so_error = EFAULT;
 8228728:	e0bffb17 	ldw	r2,-20(fp)
 822872c:	00c00384 	movi	r3,14
 8228730:	10c00615 	stw	r3,24(r2)
      return -1;
 8228734:	00bfffc4 	movi	r2,-1
 8228738:	00000706 	br	8228758 <bsd_setsockopt+0xcc>
   }

   return t_setsockopt(s, level, name, opt, optlen);
 822873c:	e0800217 	ldw	r2,8(fp)
 8228740:	d8800015 	stw	r2,0(sp)
 8228744:	e1ffff17 	ldw	r7,-4(fp)
 8228748:	e1bffe17 	ldw	r6,-8(fp)
 822874c:	e17ffd17 	ldw	r5,-12(fp)
 8228750:	e13ffc17 	ldw	r4,-16(fp)
 8228754:	8230e6c0 	call	8230e6c <t_setsockopt>
}
 8228758:	e037883a 	mov	sp,fp
 822875c:	dfc00117 	ldw	ra,4(sp)
 8228760:	df000017 	ldw	fp,0(sp)
 8228764:	dec00204 	addi	sp,sp,8
 8228768:	f800283a 	ret

0822876c <ccksum>:
 * be done in 16-bit chunks.
 */

unsigned short
ccksum (void *ptr, unsigned words)
{
 822876c:	defffa04 	addi	sp,sp,-24
 8228770:	df000515 	stw	fp,20(sp)
 8228774:	df000504 	addi	fp,sp,20
 8228778:	e13ffe15 	stw	r4,-8(fp)
 822877c:	e17fff15 	stw	r5,-4(fp)
   unsigned short *addr = (unsigned short *)ptr;
 8228780:	e0bffe17 	ldw	r2,-8(fp)
 8228784:	e0bffb15 	stw	r2,-20(fp)
   unsigned long sum = 0;
 8228788:	e03ffc15 	stw	zero,-16(fp)
   int count = (int)words;
 822878c:	e0bfff17 	ldw	r2,-4(fp)
 8228790:	e0bffd15 	stw	r2,-12(fp)

   while (--count >= 0)
 8228794:	00000806 	br	82287b8 <ccksum+0x4c>
   {
      /*  This is the inner loop */
      sum += *addr++;
 8228798:	e0bffb17 	ldw	r2,-20(fp)
 822879c:	10c00084 	addi	r3,r2,2
 82287a0:	e0fffb15 	stw	r3,-20(fp)
 82287a4:	1080000b 	ldhu	r2,0(r2)
 82287a8:	10bfffcc 	andi	r2,r2,65535
 82287ac:	e0fffc17 	ldw	r3,-16(fp)
 82287b0:	1885883a 	add	r2,r3,r2
 82287b4:	e0bffc15 	stw	r2,-16(fp)
{
   unsigned short *addr = (unsigned short *)ptr;
   unsigned long sum = 0;
   int count = (int)words;

   while (--count >= 0)
 82287b8:	e0bffd17 	ldw	r2,-12(fp)
 82287bc:	10bfffc4 	addi	r2,r2,-1
 82287c0:	e0bffd15 	stw	r2,-12(fp)
 82287c4:	e0bffd17 	ldw	r2,-12(fp)
 82287c8:	103ff30e 	bge	r2,zero,8228798 <ccksum+0x2c>
      /*  This is the inner loop */
      sum += *addr++;
   }

   /*  Fold 32-bit sum to 16 bits */
   sum = (sum & 0xffff) + (sum >> 16);
 82287cc:	e0bffc17 	ldw	r2,-16(fp)
 82287d0:	10ffffcc 	andi	r3,r2,65535
 82287d4:	e0bffc17 	ldw	r2,-16(fp)
 82287d8:	1004d43a 	srli	r2,r2,16
 82287dc:	1885883a 	add	r2,r3,r2
 82287e0:	e0bffc15 	stw	r2,-16(fp)
   sum = (sum & 0xffff) + (sum >> 16);
 82287e4:	e0bffc17 	ldw	r2,-16(fp)
 82287e8:	10ffffcc 	andi	r3,r2,65535
 82287ec:	e0bffc17 	ldw	r2,-16(fp)
 82287f0:	1004d43a 	srli	r2,r2,16
 82287f4:	1885883a 	add	r2,r3,r2
 82287f8:	e0bffc15 	stw	r2,-16(fp)

   /* checksum = ~sum; *//* removed for MIT IP stack */
   return ((unsigned short)sum);
 82287fc:	e0bffc17 	ldw	r2,-16(fp)
}
 8228800:	e037883a 	mov	sp,fp
 8228804:	df000017 	ldw	fp,0(sp)
 8228808:	dec00104 	addi	sp,sp,4
 822880c:	f800283a 	ret

08228810 <cksum>:
 *    3 = user-supplied alternate implementation
 */

unsigned short
cksum (void *ptr, unsigned count)
{
 8228810:	defffc04 	addi	sp,sp,-16
 8228814:	dfc00315 	stw	ra,12(sp)
 8228818:	df000215 	stw	fp,8(sp)
 822881c:	df000204 	addi	fp,sp,8
 8228820:	e13ffe15 	stw	r4,-8(fp)
 8228824:	e17fff15 	stw	r5,-4(fp)
   switch (cksum_select)
 8228828:	d0a03117 	ldw	r2,-32572(gp)
 822882c:	108000a0 	cmpeqi	r2,r2,2
 8228830:	1000041e 	bne	r2,zero,8228844 <cksum+0x34>
   {
      case 1:
      default:
         return (ccksum(ptr, count));
 8228834:	e17fff17 	ldw	r5,-4(fp)
 8228838:	e13ffe17 	ldw	r4,-8(fp)
 822883c:	822876c0 	call	822876c <ccksum>
 8228840:	00000306 	br	8228850 <cksum+0x40>
 #ifndef C_CHECKSUM
      case 2:
         return (asm_cksum(ptr, count));
 8228844:	e17fff17 	ldw	r5,-4(fp)
 8228848:	e13ffe17 	ldw	r4,-8(fp)
 822884c:	822d45c0 	call	822d45c <asm_cksum>
#else
#endif
         return (alt_cksum(ptr, count));
#endif
   }
}
 8228850:	e037883a 	mov	sp,fp
 8228854:	dfc00117 	ldw	ra,4(sp)
 8228858:	df000017 	ldw	fp,0(sp)
 822885c:	dec00204 	addi	sp,sp,8
 8228860:	f800283a 	ret

08228864 <do_trap>:
 * RETURNS: 0
 */

int
do_trap(void)
{
 8228864:	defffe04 	addi	sp,sp,-8
 8228868:	dfc00115 	stw	ra,4(sp)
 822886c:	df000015 	stw	fp,0(sp)
 8228870:	d839883a 	mov	fp,sp
   dtrap();
 8228874:	822d5f00 	call	822d5f0 <dtrap>
   return 0;
 8228878:	0005883a 	mov	r2,zero
}
 822887c:	e037883a 	mov	sp,fp
 8228880:	dfc00117 	ldw	ra,4(sp)
 8228884:	df000017 	ldw	fp,0(sp)
 8228888:	dec00204 	addi	sp,sp,8
 822888c:	f800283a 	ret

08228890 <nextarg>:
 * RETURNS:  pointer to next arg in string 
 */

char *   
nextarg(char * argp)
{
 8228890:	defffe04 	addi	sp,sp,-8
 8228894:	df000115 	stw	fp,4(sp)
 8228898:	df000104 	addi	fp,sp,4
 822889c:	e13fff15 	stw	r4,-4(fp)
   while (*argp > ' ')argp++; /* scan past current arg */
 82288a0:	00000306 	br	82288b0 <nextarg+0x20>
 82288a4:	e0bfff17 	ldw	r2,-4(fp)
 82288a8:	10800044 	addi	r2,r2,1
 82288ac:	e0bfff15 	stw	r2,-4(fp)
 82288b0:	e0bfff17 	ldw	r2,-4(fp)
 82288b4:	10800003 	ldbu	r2,0(r2)
 82288b8:	10803fcc 	andi	r2,r2,255
 82288bc:	1080201c 	xori	r2,r2,128
 82288c0:	10bfe004 	addi	r2,r2,-128
 82288c4:	10800848 	cmpgei	r2,r2,33
 82288c8:	103ff61e 	bne	r2,zero,82288a4 <nextarg+0x14>
      while (*argp == ' ')argp++;   /* scan past spaces */
 82288cc:	00000306 	br	82288dc <nextarg+0x4c>
 82288d0:	e0bfff17 	ldw	r2,-4(fp)
 82288d4:	10800044 	addi	r2,r2,1
 82288d8:	e0bfff15 	stw	r2,-4(fp)
 82288dc:	e0bfff17 	ldw	r2,-4(fp)
 82288e0:	10800003 	ldbu	r2,0(r2)
 82288e4:	10803fcc 	andi	r2,r2,255
 82288e8:	1080201c 	xori	r2,r2,128
 82288ec:	10bfe004 	addi	r2,r2,-128
 82288f0:	10800820 	cmpeqi	r2,r2,32
 82288f4:	103ff61e 	bne	r2,zero,82288d0 <nextarg+0x40>
      return (argp);
 82288f8:	e0bfff17 	ldw	r2,-4(fp)
}
 82288fc:	e037883a 	mov	sp,fp
 8228900:	df000017 	ldw	fp,0(sp)
 8228904:	dec00104 	addi	sp,sp,4
 8228908:	f800283a 	ret

0822890c <hexdump>:

#define  HEX_BYTES_PER_LINE   16

void
hexdump(void * pio, void * buffer, unsigned len)
{
 822890c:	defff804 	addi	sp,sp,-32
 8228910:	dfc00715 	stw	ra,28(sp)
 8228914:	df000615 	stw	fp,24(sp)
 8228918:	df000604 	addi	fp,sp,24
 822891c:	e13ffd15 	stw	r4,-12(fp)
 8228920:	e17ffe15 	stw	r5,-8(fp)
 8228924:	e1bfff15 	stw	r6,-4(fp)
   u_char * data  =  (u_char *)buffer;
 8228928:	e0bffe17 	ldw	r2,-8(fp)
 822892c:	e0bffa15 	stw	r2,-24(fp)
   unsigned int count;
   char  c;

   while (len)
 8228930:	00003f06 	br	8228a30 <hexdump+0x124>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 8228934:	e03ffb15 	stw	zero,-20(fp)
 8228938:	00000d06 	br	8228970 <hexdump+0x64>
         ns_printf(pio, "%02x ", *(data + count));
 822893c:	e0fffa17 	ldw	r3,-24(fp)
 8228940:	e0bffb17 	ldw	r2,-20(fp)
 8228944:	1885883a 	add	r2,r3,r2
 8228948:	10800003 	ldbu	r2,0(r2)
 822894c:	10803fcc 	andi	r2,r2,255
 8228950:	100d883a 	mov	r6,r2
 8228954:	01420974 	movhi	r5,2085
 8228958:	29419604 	addi	r5,r5,1624
 822895c:	e13ffd17 	ldw	r4,-12(fp)
 8228960:	8228ebc0 	call	8228ebc <ns_printf>
   char  c;

   while (len)
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 8228964:	e0bffb17 	ldw	r2,-20(fp)
 8228968:	10800044 	addi	r2,r2,1
 822896c:	e0bffb15 	stw	r2,-20(fp)
 8228970:	e0bffb17 	ldw	r2,-20(fp)
 8228974:	10800428 	cmpgeui	r2,r2,16
 8228978:	1000031e 	bne	r2,zero,8228988 <hexdump+0x7c>
 822897c:	e0fffb17 	ldw	r3,-20(fp)
 8228980:	e0bfff17 	ldw	r2,-4(fp)
 8228984:	18bfed36 	bltu	r3,r2,822893c <hexdump+0x30>
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 8228988:	e03ffb15 	stw	zero,-20(fp)
 822898c:	00001606 	br	82289e8 <hexdump+0xdc>
      {
         c = *(data + count);
 8228990:	e0fffa17 	ldw	r3,-24(fp)
 8228994:	e0bffb17 	ldw	r2,-20(fp)
 8228998:	1885883a 	add	r2,r3,r2
 822899c:	10800003 	ldbu	r2,0(r2)
 82289a0:	e0bffc05 	stb	r2,-16(fp)
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
 82289a4:	e0bffc07 	ldb	r2,-16(fp)
 82289a8:	10800810 	cmplti	r2,r2,32
 82289ac:	1000051e 	bne	r2,zero,82289c4 <hexdump+0xb8>
 82289b0:	e0bffc07 	ldb	r2,-16(fp)
 82289b4:	10801fe0 	cmpeqi	r2,r2,127
 82289b8:	1000021e 	bne	r2,zero,82289c4 <hexdump+0xb8>
 82289bc:	e0bffc07 	ldb	r2,-16(fp)
 82289c0:	00000106 	br	82289c8 <hexdump+0xbc>
 82289c4:	00800b84 	movi	r2,46
 82289c8:	100d883a 	mov	r6,r2
 82289cc:	01420974 	movhi	r5,2085
 82289d0:	29419804 	addi	r5,r5,1632
 82289d4:	e13ffd17 	ldw	r4,-12(fp)
 82289d8:	8228ebc0 	call	8228ebc <ns_printf>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 82289dc:	e0bffb17 	ldw	r2,-20(fp)
 82289e0:	10800044 	addi	r2,r2,1
 82289e4:	e0bffb15 	stw	r2,-20(fp)
 82289e8:	e0bffb17 	ldw	r2,-20(fp)
 82289ec:	10800428 	cmpgeui	r2,r2,16
 82289f0:	1000031e 	bne	r2,zero,8228a00 <hexdump+0xf4>
 82289f4:	e0fffb17 	ldw	r3,-20(fp)
 82289f8:	e0bfff17 	ldw	r2,-4(fp)
 82289fc:	18bfe436 	bltu	r3,r2,8228990 <hexdump+0x84>
      {
         c = *(data + count);
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
      }
      ns_printf(pio,"\n");
 8228a00:	01420974 	movhi	r5,2085
 8228a04:	29419904 	addi	r5,r5,1636
 8228a08:	e13ffd17 	ldw	r4,-12(fp)
 8228a0c:	8228ebc0 	call	8228ebc <ns_printf>
      len -= count;
 8228a10:	e0ffff17 	ldw	r3,-4(fp)
 8228a14:	e0bffb17 	ldw	r2,-20(fp)
 8228a18:	1885c83a 	sub	r2,r3,r2
 8228a1c:	e0bfff15 	stw	r2,-4(fp)
      data += count;
 8228a20:	e0fffa17 	ldw	r3,-24(fp)
 8228a24:	e0bffb17 	ldw	r2,-20(fp)
 8228a28:	1885883a 	add	r2,r3,r2
 8228a2c:	e0bffa15 	stw	r2,-24(fp)
{
   u_char * data  =  (u_char *)buffer;
   unsigned int count;
   char  c;

   while (len)
 8228a30:	e0bfff17 	ldw	r2,-4(fp)
 8228a34:	103fbf1e 	bne	r2,zero,8228934 <hexdump+0x28>
      }
      ns_printf(pio,"\n");
      len -= count;
      data += count;
   }
}
 8228a38:	0001883a 	nop
 8228a3c:	e037883a 	mov	sp,fp
 8228a40:	dfc00117 	ldw	ra,4(sp)
 8228a44:	df000017 	ldw	fp,0(sp)
 8228a48:	dec00204 	addi	sp,sp,8
 8228a4c:	f800283a 	ret

08228a50 <print_ipad>:

char     ipreturn[18];     /* buffer for return */

char *   
print_ipad(unsigned long ipaddr)
{
 8228a50:	defffa04 	addi	sp,sp,-24
 8228a54:	dfc00515 	stw	ra,20(sp)
 8228a58:	df000415 	stw	fp,16(sp)
 8228a5c:	df000404 	addi	fp,sp,16
 8228a60:	e13fff15 	stw	r4,-4(fp)
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
 8228a64:	e0bfff17 	ldw	r2,-4(fp)
 8228a68:	e0bffe15 	stw	r2,-8(fp)
   sprintf(ipreturn, "%u.%u.%u.%u", 
    ip.ip.ipchar[0],
 8228a6c:	e0bffe03 	ldbu	r2,-8(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 8228a70:	11003fcc 	andi	r4,r2,255
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
 8228a74:	e0bffe43 	ldbu	r2,-7(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 8228a78:	11403fcc 	andi	r5,r2,255
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
 8228a7c:	e0bffe83 	ldbu	r2,-6(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 8228a80:	10803fcc 	andi	r2,r2,255
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
    ip.ip.ipchar[3]);
 8228a84:	e0fffec3 	ldbu	r3,-5(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 8228a88:	18c03fcc 	andi	r3,r3,255
 8228a8c:	d8c00115 	stw	r3,4(sp)
 8228a90:	d8800015 	stw	r2,0(sp)
 8228a94:	280f883a 	mov	r7,r5
 8228a98:	200d883a 	mov	r6,r4
 8228a9c:	01420974 	movhi	r5,2085
 8228aa0:	29419a04 	addi	r5,r5,1640
 8228aa4:	010209b4 	movhi	r4,2086
 8228aa8:	21385e84 	addi	r4,r4,-7814
 8228aac:	82037740 	call	8203774 <sprintf>
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
    ip.ip.ipchar[3]);

   return ipreturn;
 8228ab0:	008209b4 	movhi	r2,2086
 8228ab4:	10b85e84 	addi	r2,r2,-7814
}
 8228ab8:	e037883a 	mov	sp,fp
 8228abc:	dfc00117 	ldw	ra,4(sp)
 8228ac0:	df000017 	ldw	fp,0(sp)
 8228ac4:	dec00204 	addi	sp,sp,8
 8228ac8:	f800283a 	ret

08228acc <print_uptime>:

static char tistring[24];     /* buffer for return */

char *   
print_uptime(unsigned long timetick)
{
 8228acc:	defff004 	addi	sp,sp,-64
 8228ad0:	dfc00f15 	stw	ra,60(sp)
 8228ad4:	df000e15 	stw	fp,56(sp)
 8228ad8:	ddc00d15 	stw	r23,52(sp)
 8228adc:	dd800c15 	stw	r22,48(sp)
 8228ae0:	dd400b15 	stw	r21,44(sp)
 8228ae4:	dd000a15 	stw	r20,40(sp)
 8228ae8:	dcc00915 	stw	r19,36(sp)
 8228aec:	dc800815 	stw	r18,32(sp)
 8228af0:	dc400715 	stw	r17,28(sp)
 8228af4:	dc000615 	stw	r16,24(sp)
 8228af8:	df000e04 	addi	fp,sp,56
 8228afc:	e13ff715 	stw	r4,-36(fp)
   unsigned seconds, minutes, hours;

   timetick = timetick/100;   /* turn timetick into seconds */
 8228b00:	e0fff717 	ldw	r3,-36(fp)
 8228b04:	00947b34 	movhi	r2,20972
 8228b08:	10a147c4 	addi	r2,r2,-31457
 8228b0c:	1888383a 	mulxuu	r4,r3,r2
 8228b10:	1885383a 	mul	r2,r3,r2
 8228b14:	100b883a 	mov	r5,r2
 8228b18:	200d883a 	mov	r6,r4
 8228b1c:	3004d17a 	srli	r2,r6,5
 8228b20:	e0bff715 	stw	r2,-36(fp)
   seconds = (unsigned)(timetick%60);
 8228b24:	e0bff717 	ldw	r2,-36(fp)
 8228b28:	01400f04 	movi	r5,60
 8228b2c:	1009883a 	mov	r4,r2
 8228b30:	8202cd00 	call	8202cd0 <__umodsi3>
 8228b34:	e0bff415 	stw	r2,-48(fp)
   timetick = timetick/60;    /* turn timetick into minutes */
 8228b38:	e0fff717 	ldw	r3,-36(fp)
 8228b3c:	00a22274 	movhi	r2,34953
 8228b40:	10a22244 	addi	r2,r2,-30583
 8228b44:	1888383a 	mulxuu	r4,r3,r2
 8228b48:	1885383a 	mul	r2,r3,r2
 8228b4c:	102d883a 	mov	r22,r2
 8228b50:	202f883a 	mov	r23,r4
 8228b54:	b804d17a 	srli	r2,r23,5
 8228b58:	e0bff715 	stw	r2,-36(fp)
   minutes = (unsigned)(timetick%60);
 8228b5c:	e0fff717 	ldw	r3,-36(fp)
 8228b60:	00a22274 	movhi	r2,34953
 8228b64:	10a22244 	addi	r2,r2,-30583
 8228b68:	1888383a 	mulxuu	r4,r3,r2
 8228b6c:	1885383a 	mul	r2,r3,r2
 8228b70:	1029883a 	mov	r20,r2
 8228b74:	202b883a 	mov	r21,r4
 8228b78:	a804d17a 	srli	r2,r21,5
 8228b7c:	10800f24 	muli	r2,r2,60
 8228b80:	1885c83a 	sub	r2,r3,r2
 8228b84:	e0bff515 	stw	r2,-44(fp)
   timetick = timetick/60;    /* turn timetick into hours */
 8228b88:	e0fff717 	ldw	r3,-36(fp)
 8228b8c:	00a22274 	movhi	r2,34953
 8228b90:	10a22244 	addi	r2,r2,-30583
 8228b94:	1888383a 	mulxuu	r4,r3,r2
 8228b98:	1885383a 	mul	r2,r3,r2
 8228b9c:	1025883a 	mov	r18,r2
 8228ba0:	2027883a 	mov	r19,r4
 8228ba4:	9804d17a 	srli	r2,r19,5
 8228ba8:	e0bff715 	stw	r2,-36(fp)
   hours = (unsigned)(timetick%24);
 8228bac:	e0bff717 	ldw	r2,-36(fp)
 8228bb0:	01400604 	movi	r5,24
 8228bb4:	1009883a 	mov	r4,r2
 8228bb8:	8202cd00 	call	8202cd0 <__umodsi3>
 8228bbc:	e0bff615 	stw	r2,-40(fp)
   timetick = timetick/24;    /* turn timetick into days */
 8228bc0:	e0fff717 	ldw	r3,-36(fp)
 8228bc4:	00aaaaf4 	movhi	r2,43691
 8228bc8:	10aaaac4 	addi	r2,r2,-21845
 8228bcc:	1888383a 	mulxuu	r4,r3,r2
 8228bd0:	1885383a 	mul	r2,r3,r2
 8228bd4:	1021883a 	mov	r16,r2
 8228bd8:	2023883a 	mov	r17,r4
 8228bdc:	8804d13a 	srli	r2,r17,4
 8228be0:	e0bff715 	stw	r2,-36(fp)

   if (timetick)  /* Is there a whole number of days? */
 8228be4:	e0bff717 	ldw	r2,-36(fp)
 8228be8:	10000c26 	beq	r2,zero,8228c1c <print_uptime+0x150>
      sprintf(tistring, "%ld days, %dh:%dm:%ds", 
 8228bec:	e0bff417 	ldw	r2,-48(fp)
 8228bf0:	d8800115 	stw	r2,4(sp)
 8228bf4:	e0bff517 	ldw	r2,-44(fp)
 8228bf8:	d8800015 	stw	r2,0(sp)
 8228bfc:	e1fff617 	ldw	r7,-40(fp)
 8228c00:	e1bff717 	ldw	r6,-36(fp)
 8228c04:	01420974 	movhi	r5,2085
 8228c08:	29419d04 	addi	r5,r5,1652
 8228c0c:	01020974 	movhi	r4,2085
 8228c10:	21122b04 	addi	r4,r4,18604
 8228c14:	82037740 	call	8203774 <sprintf>
 8228c18:	00001306 	br	8228c68 <print_uptime+0x19c>
    timetick, hours, minutes, seconds);
   else if (hours)
 8228c1c:	e0bff617 	ldw	r2,-40(fp)
 8228c20:	10000a26 	beq	r2,zero,8228c4c <print_uptime+0x180>
      sprintf(tistring, "%d hours, %dm:%ds", hours, minutes, seconds);
 8228c24:	e0bff417 	ldw	r2,-48(fp)
 8228c28:	d8800015 	stw	r2,0(sp)
 8228c2c:	e1fff517 	ldw	r7,-44(fp)
 8228c30:	e1bff617 	ldw	r6,-40(fp)
 8228c34:	01420974 	movhi	r5,2085
 8228c38:	2941a304 	addi	r5,r5,1676
 8228c3c:	01020974 	movhi	r4,2085
 8228c40:	21122b04 	addi	r4,r4,18604
 8228c44:	82037740 	call	8203774 <sprintf>
 8228c48:	00000706 	br	8228c68 <print_uptime+0x19c>
   else
      sprintf(tistring, "%d minutes, %d sec.", minutes, seconds);
 8228c4c:	e1fff417 	ldw	r7,-48(fp)
 8228c50:	e1bff517 	ldw	r6,-44(fp)
 8228c54:	01420974 	movhi	r5,2085
 8228c58:	2941a804 	addi	r5,r5,1696
 8228c5c:	01020974 	movhi	r4,2085
 8228c60:	21122b04 	addi	r4,r4,18604
 8228c64:	82037740 	call	8203774 <sprintf>
   return tistring;
 8228c68:	00820974 	movhi	r2,2085
 8228c6c:	10922b04 	addi	r2,r2,18604
}
 8228c70:	e6fff804 	addi	sp,fp,-32
 8228c74:	dfc00917 	ldw	ra,36(sp)
 8228c78:	df000817 	ldw	fp,32(sp)
 8228c7c:	ddc00717 	ldw	r23,28(sp)
 8228c80:	dd800617 	ldw	r22,24(sp)
 8228c84:	dd400517 	ldw	r21,20(sp)
 8228c88:	dd000417 	ldw	r20,16(sp)
 8228c8c:	dcc00317 	ldw	r19,12(sp)
 8228c90:	dc800217 	ldw	r18,8(sp)
 8228c94:	dc400117 	ldw	r17,4(sp)
 8228c98:	dc000017 	ldw	r16,0(sp)
 8228c9c:	dec00a04 	addi	sp,sp,40
 8228ca0:	f800283a 	ret

08228ca4 <panic>:
/* allow to be ifdeffed out on systems which already have a panic */
#ifndef PANIC_ALREADY

void
panic(char * msg)
{
 8228ca4:	defffd04 	addi	sp,sp,-12
 8228ca8:	dfc00215 	stw	ra,8(sp)
 8228cac:	df000115 	stw	fp,4(sp)
 8228cb0:	df000104 	addi	fp,sp,4
 8228cb4:	e13fff15 	stw	r4,-4(fp)
   dprintf("panic: %s\n", msg);
 8228cb8:	e17fff17 	ldw	r5,-4(fp)
 8228cbc:	01020974 	movhi	r4,2085
 8228cc0:	2101ad04 	addi	r4,r4,1716
 8228cc4:	82033fc0 	call	82033fc <printf>
   dtrap();                   /* try to hook debugger */
 8228cc8:	822d5f00 	call	822d5f0 <dtrap>
   netexit(1);                /* try to clean up */
 8228ccc:	01000044 	movi	r4,1
 8228cd0:	8243ce80 	call	8243ce8 <netexit>
}
 8228cd4:	0001883a 	nop
 8228cd8:	e037883a 	mov	sp,fp
 8228cdc:	dfc00117 	ldw	ra,4(sp)
 8228ce0:	df000017 	ldw	fp,0(sp)
 8228ce4:	dec00204 	addi	sp,sp,8
 8228ce8:	f800283a 	ret

08228cec <print_eth>:

char     eth_prt_buf[18];  /* buffer for return */

char *   
print_eth(char * addr, char spacer)
{
 8228cec:	defffb04 	addi	sp,sp,-20
 8228cf0:	df000415 	stw	fp,16(sp)
 8228cf4:	df000404 	addi	fp,sp,16
 8228cf8:	e13ffe15 	stw	r4,-8(fp)
 8228cfc:	2805883a 	mov	r2,r5
 8228d00:	e0bfff05 	stb	r2,-4(fp)
   int   i;
   char *   out   =  eth_prt_buf;
 8228d04:	008209b4 	movhi	r2,2086
 8228d08:	10b85a04 	addi	r2,r2,-7832
 8228d0c:	e0bffd15 	stw	r2,-12(fp)

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 8228d10:	e03ffc15 	stw	zero,-16(fp)
 8228d14:	00003f06 	br	8228e14 <print_eth+0x128>
   {
      /* high nibble */
      *out = (char)(((*addr >> 4) & 0x0f) + 0x30);
 8228d18:	e0bffe17 	ldw	r2,-8(fp)
 8228d1c:	10800003 	ldbu	r2,0(r2)
 8228d20:	10803fcc 	andi	r2,r2,255
 8228d24:	1004d13a 	srli	r2,r2,4
 8228d28:	10800c04 	addi	r2,r2,48
 8228d2c:	1007883a 	mov	r3,r2
 8228d30:	e0bffd17 	ldw	r2,-12(fp)
 8228d34:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 8228d38:	e0bffd17 	ldw	r2,-12(fp)
 8228d3c:	10800003 	ldbu	r2,0(r2)
 8228d40:	10803fcc 	andi	r2,r2,255
 8228d44:	1080201c 	xori	r2,r2,128
 8228d48:	10bfe004 	addi	r2,r2,-128
 8228d4c:	10800e90 	cmplti	r2,r2,58
 8228d50:	1000061e 	bne	r2,zero,8228d6c <print_eth+0x80>
         (*out) += 7;
 8228d54:	e0bffd17 	ldw	r2,-12(fp)
 8228d58:	10800003 	ldbu	r2,0(r2)
 8228d5c:	108001c4 	addi	r2,r2,7
 8228d60:	1007883a 	mov	r3,r2
 8228d64:	e0bffd17 	ldw	r2,-12(fp)
 8228d68:	10c00005 	stb	r3,0(r2)
      out++;
 8228d6c:	e0bffd17 	ldw	r2,-12(fp)
 8228d70:	10800044 	addi	r2,r2,1
 8228d74:	e0bffd15 	stw	r2,-12(fp)

      /* low nibble */
      *out = (char)((*addr & 0x0f) + 0x30);  /* low nibble to digit */
 8228d78:	e0bffe17 	ldw	r2,-8(fp)
 8228d7c:	10800003 	ldbu	r2,0(r2)
 8228d80:	108003cc 	andi	r2,r2,15
 8228d84:	10800c04 	addi	r2,r2,48
 8228d88:	1007883a 	mov	r3,r2
 8228d8c:	e0bffd17 	ldw	r2,-12(fp)
 8228d90:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 8228d94:	e0bffd17 	ldw	r2,-12(fp)
 8228d98:	10800003 	ldbu	r2,0(r2)
 8228d9c:	10803fcc 	andi	r2,r2,255
 8228da0:	1080201c 	xori	r2,r2,128
 8228da4:	10bfe004 	addi	r2,r2,-128
 8228da8:	10800e90 	cmplti	r2,r2,58
 8228dac:	1000061e 	bne	r2,zero,8228dc8 <print_eth+0xdc>
         (*out) += 7;   /* eg 0x3a -> 0x41 ('A') */
 8228db0:	e0bffd17 	ldw	r2,-12(fp)
 8228db4:	10800003 	ldbu	r2,0(r2)
 8228db8:	108001c4 	addi	r2,r2,7
 8228dbc:	1007883a 	mov	r3,r2
 8228dc0:	e0bffd17 	ldw	r2,-12(fp)
 8228dc4:	10c00005 	stb	r3,0(r2)
      out++;
 8228dc8:	e0bffd17 	ldw	r2,-12(fp)
 8228dcc:	10800044 	addi	r2,r2,1
 8228dd0:	e0bffd15 	stw	r2,-12(fp)

      /* optional spacer character */
      if (spacer && i < 5)
 8228dd4:	e0bfff07 	ldb	r2,-4(fp)
 8228dd8:	10000826 	beq	r2,zero,8228dfc <print_eth+0x110>
 8228ddc:	e0bffc17 	ldw	r2,-16(fp)
 8228de0:	10800148 	cmpgei	r2,r2,5
 8228de4:	1000051e 	bne	r2,zero,8228dfc <print_eth+0x110>
         *out++ = spacer;
 8228de8:	e0bffd17 	ldw	r2,-12(fp)
 8228dec:	10c00044 	addi	r3,r2,1
 8228df0:	e0fffd15 	stw	r3,-12(fp)
 8228df4:	e0ffff03 	ldbu	r3,-4(fp)
 8228df8:	10c00005 	stb	r3,0(r2)
      addr++;
 8228dfc:	e0bffe17 	ldw	r2,-8(fp)
 8228e00:	10800044 	addi	r2,r2,1
 8228e04:	e0bffe15 	stw	r2,-8(fp)
{
   int   i;
   char *   out   =  eth_prt_buf;

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 8228e08:	e0bffc17 	ldw	r2,-16(fp)
 8228e0c:	10800044 	addi	r2,r2,1
 8228e10:	e0bffc15 	stw	r2,-16(fp)
 8228e14:	e0bffc17 	ldw	r2,-16(fp)
 8228e18:	10800190 	cmplti	r2,r2,6
 8228e1c:	103fbe1e 	bne	r2,zero,8228d18 <print_eth+0x2c>
      /* optional spacer character */
      if (spacer && i < 5)
         *out++ = spacer;
      addr++;
   }
   *out = 0;
 8228e20:	e0bffd17 	ldw	r2,-12(fp)
 8228e24:	10000005 	stb	zero,0(r2)
   return eth_prt_buf;
 8228e28:	008209b4 	movhi	r2,2086
 8228e2c:	10b85a04 	addi	r2,r2,-7832
}
 8228e30:	e037883a 	mov	sp,fp
 8228e34:	df000017 	ldw	fp,0(sp)
 8228e38:	dec00104 	addi	sp,sp,4
 8228e3c:	f800283a 	ret

08228e40 <uslash>:
 * RETURNS:  pointer to formatted text
 */

char *   
uslash(char * path)
{
 8228e40:	defffd04 	addi	sp,sp,-12
 8228e44:	df000215 	stw	fp,8(sp)
 8228e48:	df000204 	addi	fp,sp,8
 8228e4c:	e13fff15 	stw	r4,-4(fp)
   char *   cp;

   for (cp = path; *cp; cp++)
 8228e50:	e0bfff17 	ldw	r2,-4(fp)
 8228e54:	e0bffe15 	stw	r2,-8(fp)
 8228e58:	00000d06 	br	8228e90 <uslash+0x50>
      if (*cp == '\\')
 8228e5c:	e0bffe17 	ldw	r2,-8(fp)
 8228e60:	10800003 	ldbu	r2,0(r2)
 8228e64:	10803fcc 	andi	r2,r2,255
 8228e68:	1080201c 	xori	r2,r2,128
 8228e6c:	10bfe004 	addi	r2,r2,-128
 8228e70:	10801718 	cmpnei	r2,r2,92
 8228e74:	1000031e 	bne	r2,zero,8228e84 <uslash+0x44>
      *cp = '/';
 8228e78:	e0bffe17 	ldw	r2,-8(fp)
 8228e7c:	00c00bc4 	movi	r3,47
 8228e80:	10c00005 	stb	r3,0(r2)
char *   
uslash(char * path)
{
   char *   cp;

   for (cp = path; *cp; cp++)
 8228e84:	e0bffe17 	ldw	r2,-8(fp)
 8228e88:	10800044 	addi	r2,r2,1
 8228e8c:	e0bffe15 	stw	r2,-8(fp)
 8228e90:	e0bffe17 	ldw	r2,-8(fp)
 8228e94:	10800003 	ldbu	r2,0(r2)
 8228e98:	10803fcc 	andi	r2,r2,255
 8228e9c:	1080201c 	xori	r2,r2,128
 8228ea0:	10bfe004 	addi	r2,r2,-128
 8228ea4:	103fed1e 	bne	r2,zero,8228e5c <uslash+0x1c>
      if (*cp == '\\')
      *cp = '/';
   return path;
 8228ea8:	e0bfff17 	ldw	r2,-4(fp)
}
 8228eac:	e037883a 	mov	sp,fp
 8228eb0:	df000017 	ldw	fp,0(sp)
 8228eb4:	dec00104 	addi	sp,sp,4
 8228eb8:	f800283a 	ret

08228ebc <ns_printf>:
 */
#ifndef ns_printf

int 
ns_printf(void * vio, char * format, ...)
{
 8228ebc:	defff304 	addi	sp,sp,-52
 8228ec0:	dfc00a15 	stw	ra,40(sp)
 8228ec4:	df000915 	stw	fp,36(sp)
 8228ec8:	dc400815 	stw	r17,32(sp)
 8228ecc:	dc000715 	stw	r16,28(sp)
 8228ed0:	df000904 	addi	fp,sp,36
 8228ed4:	e13ffc15 	stw	r4,-16(fp)
 8228ed8:	e17ffd15 	stw	r5,-12(fp)
 8228edc:	e1800215 	stw	r6,8(fp)
 8228ee0:	e1c00315 	stw	r7,12(fp)
   char *   outbuf=NULL;
 8228ee4:	e03ff815 	stw	zero,-32(fp)
   int   ret_value   ;
   int   buf_size =  MAXIOSIZE   ;
 8228ee8:	00802704 	movi	r2,156
 8228eec:	e0bff715 	stw	r2,-36(fp)
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 8228ef0:	e0bffc17 	ldw	r2,-16(fp)
 8228ef4:	e0bff915 	stw	r2,-28(fp)
   int * next_arg=(int *)  &format;
   next_arg +=  sizeof(char *)/sizeof(int) ;
#endif   /* NATIVE_PRINTF || PRINTF_STRING */

   /* a NULL pio means just dump the output to stdout */
   if (pio == NULL)
 8228ef8:	e0bff917 	ldw	r2,-28(fp)
 8228efc:	1000091e 	bne	r2,zero,8228f24 <ns_printf+0x68>
   {
#ifdef NATIVE_PRINTF
      /* use the target system's ANSI routines */
      va_start(argList,format);
 8228f00:	e0800204 	addi	r2,fp,8
 8228f04:	e0bffb15 	stw	r2,-20(fp)
      ret_value = vprintf(format,argList);
 8228f08:	e0bffb17 	ldw	r2,-20(fp)
 8228f0c:	100b883a 	mov	r5,r2
 8228f10:	e13ffd17 	ldw	r4,-12(fp)
 8228f14:	824bbb40 	call	824bbb4 <vprintf>
 8228f18:	e0bffa15 	stw	r2,-24(fp)
      va_end(argList);
      return ret_value;
 8228f1c:	e0bffa17 	ldw	r2,-24(fp)
 8228f20:	00003b06 	br	8229010 <ns_printf+0x154>
      return strlen(format);
#endif   /* NATIVE_PRINTF */
   }

   /* Check if the output function is set */
   if (pio->out == NULL)
 8228f24:	e0bff917 	ldw	r2,-28(fp)
 8228f28:	10800117 	ldw	r2,4(r2)
 8228f2c:	1000021e 	bne	r2,zero,8228f38 <ns_printf+0x7c>
   {
      /* Programming mistake. Output function not set. */
      return -1;
 8228f30:	00bfffc4 	movi	r2,-1
 8228f34:	00003606 	br	8229010 <ns_printf+0x154>

   /* Allocate memory for the output string 
    * If the format string is greater than MAXIOSIZE, then
    * we surely need to allocate a bigger block
    */
   ret_value = strlen(format); 
 8228f38:	e13ffd17 	ldw	r4,-12(fp)
 8228f3c:	8203fbc0 	call	8203fbc <strlen>
 8228f40:	e0bffa15 	stw	r2,-24(fp)
   if (ret_value >= MAXIOSIZE)
 8228f44:	e0bffa17 	ldw	r2,-24(fp)
 8228f48:	10802710 	cmplti	r2,r2,156
 8228f4c:	1000041e 	bne	r2,zero,8228f60 <ns_printf+0xa4>
   {
      buf_size += ret_value ;
 8228f50:	e0fff717 	ldw	r3,-36(fp)
 8228f54:	e0bffa17 	ldw	r2,-24(fp)
 8228f58:	1885883a 	add	r2,r3,r2
 8228f5c:	e0bff715 	stw	r2,-36(fp)
   }

   outbuf=(char *)npalloc(buf_size); 
 8228f60:	e0bff717 	ldw	r2,-36(fp)
 8228f64:	1009883a 	mov	r4,r2
 8228f68:	822e1c80 	call	822e1c8 <npalloc>
 8228f6c:	e0bff815 	stw	r2,-32(fp)

   if (outbuf == NULL)
 8228f70:	e0bff817 	ldw	r2,-32(fp)
 8228f74:	1000021e 	bne	r2,zero,8228f80 <ns_printf+0xc4>
   {
      return -2;
 8228f78:	00bfff84 	movi	r2,-2
 8228f7c:	00002406 	br	8229010 <ns_printf+0x154>

   /* Now populate the output string */

#ifdef NATIVE_PRINTF
   /* use the target system's ANSI routines */
   va_start(argList,format);
 8228f80:	e0800204 	addi	r2,fp,8
 8228f84:	e0bffb15 	stw	r2,-20(fp)
   ret_value = vsprintf(outbuf,format,argList);
 8228f88:	e0bffb17 	ldw	r2,-20(fp)
 8228f8c:	100d883a 	mov	r6,r2
 8228f90:	e17ffd17 	ldw	r5,-12(fp)
 8228f94:	e13ff817 	ldw	r4,-32(fp)
 8228f98:	824bc300 	call	824bc30 <vsprintf>
 8228f9c:	e0bffa15 	stw	r2,-24(fp)
#endif   /* PRINTF_STDARG */
#endif   /* NATIVE_PRINTF */

#ifdef NATIVE_PRINTF
   /* Check if we have overwritten the output buffer */
   if ((int)strlen(outbuf) > buf_size)
 8228fa0:	e13ff817 	ldw	r4,-32(fp)
 8228fa4:	8203fbc0 	call	8203fbc <strlen>
 8228fa8:	1007883a 	mov	r3,r2
 8228fac:	e0bff717 	ldw	r2,-36(fp)
 8228fb0:	10c0080e 	bge	r2,r3,8228fd4 <ns_printf+0x118>
       */
      /* Yes , we have overwritten. Truncate the output string.
       * Some memory in the heap has been corrupted, but it is too
       * late to rectify.
       */
      panic("ns_printf:Buffer overflow");
 8228fb4:	01020974 	movhi	r4,2085
 8228fb8:	2101b004 	addi	r4,r4,1728
 8228fbc:	8228ca40 	call	8228ca4 <panic>
      outbuf[buf_size-1]=0;   /* Null terminate the string */
 8228fc0:	e0bff717 	ldw	r2,-36(fp)
 8228fc4:	10bfffc4 	addi	r2,r2,-1
 8228fc8:	e0fff817 	ldw	r3,-32(fp)
 8228fcc:	1885883a 	add	r2,r3,r2
 8228fd0:	10000005 	stb	zero,0(r2)
   }
#endif

   ret_value =(pio->out)(pio->id,outbuf,strlen(outbuf)) ;
 8228fd4:	e0bff917 	ldw	r2,-28(fp)
 8228fd8:	14000117 	ldw	r16,4(r2)
 8228fdc:	e0bff917 	ldw	r2,-28(fp)
 8228fe0:	14400217 	ldw	r17,8(r2)
 8228fe4:	e13ff817 	ldw	r4,-32(fp)
 8228fe8:	8203fbc0 	call	8203fbc <strlen>
 8228fec:	100d883a 	mov	r6,r2
 8228ff0:	e17ff817 	ldw	r5,-32(fp)
 8228ff4:	8809883a 	mov	r4,r17
 8228ff8:	803ee83a 	callr	r16
 8228ffc:	e0bffa15 	stw	r2,-24(fp)

   /* Free memory for the output string */
   npfree(outbuf); 
 8229000:	e13ff817 	ldw	r4,-32(fp)
 8229004:	822e1fc0 	call	822e1fc <npfree>

   /* since ns_printf() can get called repeatedly down in the bowels 
    * of a single command interpretting function, spin tk_yield() so 
    * that some packets get a chance to get received 
    */
   tk_yield();
 8229008:	82298680 	call	8229868 <tk_yield>

   return ret_value ;
 822900c:	e0bffa17 	ldw	r2,-24(fp)
}
 8229010:	e6fffe04 	addi	sp,fp,-8
 8229014:	dfc00317 	ldw	ra,12(sp)
 8229018:	df000217 	ldw	fp,8(sp)
 822901c:	dc400117 	ldw	r17,4(sp)
 8229020:	dc000017 	ldw	r16,0(sp)
 8229024:	dec00604 	addi	sp,sp,24
 8229028:	f800283a 	ret

0822902c <std_out>:
 *
 * RETURNS: Number of bytes send to standard output. 
 */

int std_out(long s, char * buf, int len)
{
 822902c:	defffb04 	addi	sp,sp,-20
 8229030:	dfc00415 	stw	ra,16(sp)
 8229034:	df000315 	stw	fp,12(sp)
 8229038:	df000304 	addi	fp,sp,12
 822903c:	e13ffd15 	stw	r4,-12(fp)
 8229040:	e17ffe15 	stw	r5,-8(fp)
 8229044:	e1bfff15 	stw	r6,-4(fp)
   /* puts(buf); - This does newline expansion return 
    * write(0,buf,len); - This doesn't printf(buf); - This has 
    * problems when printf format strings (eg %s) is part of data. 
    */
   printf("%s",buf);
 8229048:	e17ffe17 	ldw	r5,-8(fp)
 822904c:	01020974 	movhi	r4,2085
 8229050:	2101b704 	addi	r4,r4,1756
 8229054:	82033fc0 	call	82033fc <printf>
   USE_ARG(s);
   return len;
 8229058:	e0bfff17 	ldw	r2,-4(fp)
}
 822905c:	e037883a 	mov	sp,fp
 8229060:	dfc00117 	ldw	ra,4(sp)
 8229064:	df000017 	ldw	fp,0(sp)
 8229068:	dec00204 	addi	sp,sp,8
 822906c:	f800283a 	ret

08229070 <con_page>:
 * RETURNS: 1 if we got a break, 0 to keep printing
 */

int
con_page(void * vio, int lines)
{
 8229070:	defffa04 	addi	sp,sp,-24
 8229074:	dfc00515 	stw	ra,20(sp)
 8229078:	df000415 	stw	fp,16(sp)
 822907c:	df000404 	addi	fp,sp,16
 8229080:	e13ffe15 	stw	r4,-8(fp)
 8229084:	e17fff15 	stw	r5,-4(fp)
   int   ch;
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 8229088:	e0bffe17 	ldw	r2,-8(fp)
 822908c:	e0bffc15 	stw	r2,-16(fp)

   if (lines % 20 == 0)   /* Time to get user input */
 8229090:	e0bfff17 	ldw	r2,-4(fp)
 8229094:	01400504 	movi	r5,20
 8229098:	1009883a 	mov	r4,r2
 822909c:	8202bf80 	call	8202bf8 <__modsi3>
 82290a0:	1000231e 	bne	r2,zero,8229130 <con_page+0xc0>
   {
      if (pio && pio->getch)   /*if i/p func is supplied*/
 82290a4:	e0bffc17 	ldw	r2,-16(fp)
 82290a8:	10002126 	beq	r2,zero,8229130 <con_page+0xc0>
 82290ac:	e0bffc17 	ldw	r2,-16(fp)
 82290b0:	10800317 	ldw	r2,12(r2)
 82290b4:	10001e26 	beq	r2,zero,8229130 <con_page+0xc0>
      {
         ns_printf(pio,"....press any key for more (ESC to break)....");
 82290b8:	01420974 	movhi	r5,2085
 82290bc:	2941b804 	addi	r5,r5,1760
 82290c0:	e13ffc17 	ldw	r4,-16(fp)
 82290c4:	8228ebc0 	call	8228ebc <ns_printf>

         do 
         {
            ch = (pio->getch)(pio->id);
 82290c8:	e0bffc17 	ldw	r2,-16(fp)
 82290cc:	10800317 	ldw	r2,12(r2)
 82290d0:	e0fffc17 	ldw	r3,-16(fp)
 82290d4:	18c00217 	ldw	r3,8(r3)
 82290d8:	1809883a 	mov	r4,r3
 82290dc:	103ee83a 	callr	r2
 82290e0:	e0bffd15 	stw	r2,-12(fp)
            if (ch == 0)
 82290e4:	e0bffd17 	ldw	r2,-12(fp)
 82290e8:	1000011e 	bne	r2,zero,82290f0 <con_page+0x80>
               tk_yield();    /* Give timeslice to other processes */
 82290ec:	82298680 	call	8229868 <tk_yield>
         } while (ch == 0) ;
 82290f0:	e0bffd17 	ldw	r2,-12(fp)
 82290f4:	103ff426 	beq	r2,zero,82290c8 <con_page+0x58>

            /* if there is fatal error, we don't want to do any I/O */
         if (ch == -1)   /* fatal error */
 82290f8:	e0bffd17 	ldw	r2,-12(fp)
 82290fc:	10bfffd8 	cmpnei	r2,r2,-1
 8229100:	1000021e 	bne	r2,zero,822910c <con_page+0x9c>
            return 1 ;
 8229104:	00800044 	movi	r2,1
 8229108:	00000a06 	br	8229134 <con_page+0xc4>

         ns_printf(pio,"\n");
 822910c:	01420974 	movhi	r5,2085
 8229110:	29419904 	addi	r5,r5,1636
 8229114:	e13ffc17 	ldw	r4,-16(fp)
 8229118:	8228ebc0 	call	8228ebc <ns_printf>
         if (ch == 27)   /* ESC key pressed */
 822911c:	e0bffd17 	ldw	r2,-12(fp)
 8229120:	108006d8 	cmpnei	r2,r2,27
 8229124:	1000021e 	bne	r2,zero,8229130 <con_page+0xc0>
            return 1 ;
 8229128:	00800044 	movi	r2,1
 822912c:	00000106 	br	8229134 <con_page+0xc4>
      }
   }
   return  0;
 8229130:	0005883a 	mov	r2,zero
}
 8229134:	e037883a 	mov	sp,fp
 8229138:	dfc00117 	ldw	ra,4(sp)
 822913c:	df000017 	ldw	fp,0(sp)
 8229140:	dec00204 	addi	sp,sp,8
 8229144:	f800283a 	ret

08229148 <parse_args>:

char **parse_args(char *buf, int argc, int *pargc_index)
{
 8229148:	defff704 	addi	sp,sp,-36
 822914c:	dfc00815 	stw	ra,32(sp)
 8229150:	df000715 	stw	fp,28(sp)
 8229154:	df000704 	addi	fp,sp,28
 8229158:	e13ffd15 	stw	r4,-12(fp)
 822915c:	e17ffe15 	stw	r5,-8(fp)
 8229160:	e1bfff15 	stw	r6,-4(fp)
   /* This routine assumes buf is a null terminated string */
   int i;
   int len;
   char *bp = buf;
 8229164:	e0bffd17 	ldw	r2,-12(fp)
 8229168:	e0bffa15 	stw	r2,-24(fp)
   char **pargv = NULL;
 822916c:	e03ffb15 	stw	zero,-20(fp)
   *pargc_index = 0;
 8229170:	e0bfff17 	ldw	r2,-4(fp)
 8229174:	10000015 	stw	zero,0(r2)
   if (buf == NULL)
 8229178:	e0bffd17 	ldw	r2,-12(fp)
 822917c:	1000021e 	bne	r2,zero,8229188 <parse_args+0x40>
   {
      return (NULL);
 8229180:	0005883a 	mov	r2,zero
 8229184:	00006c06 	br	8229338 <parse_args+0x1f0>
   }
   len = strlen(buf);
 8229188:	e13ffd17 	ldw	r4,-12(fp)
 822918c:	8203fbc0 	call	8203fbc <strlen>
 8229190:	e0bffc15 	stw	r2,-16(fp)
   if (len <= 0)
 8229194:	e0bffc17 	ldw	r2,-16(fp)
 8229198:	00800216 	blt	zero,r2,82291a4 <parse_args+0x5c>
   {
      return (NULL);
 822919c:	0005883a 	mov	r2,zero
 82291a0:	00006506 	br	8229338 <parse_args+0x1f0>
   }
   pargv = (char **) npalloc(argc * sizeof(char *));
 82291a4:	e0bffe17 	ldw	r2,-8(fp)
 82291a8:	1085883a 	add	r2,r2,r2
 82291ac:	1085883a 	add	r2,r2,r2
 82291b0:	1009883a 	mov	r4,r2
 82291b4:	822e1c80 	call	822e1c8 <npalloc>
 82291b8:	e0bffb15 	stw	r2,-20(fp)
   if (pargv == NULL)
 82291bc:	e0bffb17 	ldw	r2,-20(fp)
 82291c0:	1000051e 	bne	r2,zero,82291d8 <parse_args+0x90>
   {
      return (NULL);
 82291c4:	0005883a 	mov	r2,zero
 82291c8:	00005b06 	br	8229338 <parse_args+0x1f0>
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
 82291cc:	e0bffa17 	ldw	r2,-24(fp)
 82291d0:	10800044 	addi	r2,r2,1
 82291d4:	e0bffa15 	stw	r2,-24(fp)
   if (pargv == NULL)
   {
      return (NULL);
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
 82291d8:	e0bffa17 	ldw	r2,-24(fp)
 82291dc:	10800003 	ldbu	r2,0(r2)
 82291e0:	10803fcc 	andi	r2,r2,255
 82291e4:	1080201c 	xori	r2,r2,128
 82291e8:	10bfe004 	addi	r2,r2,-128
 82291ec:	10800820 	cmpeqi	r2,r2,32
 82291f0:	103ff61e 	bne	r2,zero,82291cc <parse_args+0x84>
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 82291f4:	00003006 	br	82292b8 <parse_args+0x170>
   {
      pargv[(*pargc_index)] = bp;
 82291f8:	e0bfff17 	ldw	r2,-4(fp)
 82291fc:	10800017 	ldw	r2,0(r2)
 8229200:	1085883a 	add	r2,r2,r2
 8229204:	1085883a 	add	r2,r2,r2
 8229208:	1007883a 	mov	r3,r2
 822920c:	e0bffb17 	ldw	r2,-20(fp)
 8229210:	10c5883a 	add	r2,r2,r3
 8229214:	e0fffa17 	ldw	r3,-24(fp)
 8229218:	10c00015 	stw	r3,0(r2)
      (*pargc_index)++;
 822921c:	e0bfff17 	ldw	r2,-4(fp)
 8229220:	10800017 	ldw	r2,0(r2)
 8229224:	10c00044 	addi	r3,r2,1
 8229228:	e0bfff17 	ldw	r2,-4(fp)
 822922c:	10c00015 	stw	r3,0(r2)
      while (*bp != ' ' && *bp != '\0')
 8229230:	00000306 	br	8229240 <parse_args+0xf8>
      {
         bp++; 
 8229234:	e0bffa17 	ldw	r2,-24(fp)
 8229238:	10800044 	addi	r2,r2,1
 822923c:	e0bffa15 	stw	r2,-24(fp)
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
   {
      pargv[(*pargc_index)] = bp;
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
 8229240:	e0bffa17 	ldw	r2,-24(fp)
 8229244:	10800003 	ldbu	r2,0(r2)
 8229248:	10803fcc 	andi	r2,r2,255
 822924c:	1080201c 	xori	r2,r2,128
 8229250:	10bfe004 	addi	r2,r2,-128
 8229254:	10800820 	cmpeqi	r2,r2,32
 8229258:	10000a1e 	bne	r2,zero,8229284 <parse_args+0x13c>
 822925c:	e0bffa17 	ldw	r2,-24(fp)
 8229260:	10800003 	ldbu	r2,0(r2)
 8229264:	10803fcc 	andi	r2,r2,255
 8229268:	1080201c 	xori	r2,r2,128
 822926c:	10bfe004 	addi	r2,r2,-128
 8229270:	103ff01e 	bne	r2,zero,8229234 <parse_args+0xec>
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 8229274:	00000306 	br	8229284 <parse_args+0x13c>
      {
         bp++; 
 8229278:	e0bffa17 	ldw	r2,-24(fp)
 822927c:	10800044 	addi	r2,r2,1
 8229280:	e0bffa15 	stw	r2,-24(fp)
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 8229284:	e0bffa17 	ldw	r2,-24(fp)
 8229288:	10800003 	ldbu	r2,0(r2)
 822928c:	10803fcc 	andi	r2,r2,255
 8229290:	1080201c 	xori	r2,r2,128
 8229294:	10bfe004 	addi	r2,r2,-128
 8229298:	10800818 	cmpnei	r2,r2,32
 822929c:	1000061e 	bne	r2,zero,82292b8 <parse_args+0x170>
 82292a0:	e0bffa17 	ldw	r2,-24(fp)
 82292a4:	10800003 	ldbu	r2,0(r2)
 82292a8:	10803fcc 	andi	r2,r2,255
 82292ac:	1080201c 	xori	r2,r2,128
 82292b0:	10bfe004 	addi	r2,r2,-128
 82292b4:	103ff01e 	bne	r2,zero,8229278 <parse_args+0x130>
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 82292b8:	e0bffa17 	ldw	r2,-24(fp)
 82292bc:	10800003 	ldbu	r2,0(r2)
 82292c0:	10803fcc 	andi	r2,r2,255
 82292c4:	1080201c 	xori	r2,r2,128
 82292c8:	10bfe004 	addi	r2,r2,-128
 82292cc:	10000426 	beq	r2,zero,82292e0 <parse_args+0x198>
 82292d0:	e0bfff17 	ldw	r2,-4(fp)
 82292d4:	10c00017 	ldw	r3,0(r2)
 82292d8:	e0bffe17 	ldw	r2,-8(fp)
 82292dc:	18bfc616 	blt	r3,r2,82291f8 <parse_args+0xb0>
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 82292e0:	e03ff915 	stw	zero,-28(fp)
 82292e4:	00001006 	br	8229328 <parse_args+0x1e0>
   {
      if (buf[i] == ' ')
 82292e8:	e0bff917 	ldw	r2,-28(fp)
 82292ec:	e0fffd17 	ldw	r3,-12(fp)
 82292f0:	1885883a 	add	r2,r3,r2
 82292f4:	10800003 	ldbu	r2,0(r2)
 82292f8:	10803fcc 	andi	r2,r2,255
 82292fc:	1080201c 	xori	r2,r2,128
 8229300:	10bfe004 	addi	r2,r2,-128
 8229304:	10800818 	cmpnei	r2,r2,32
 8229308:	1000041e 	bne	r2,zero,822931c <parse_args+0x1d4>
         buf[i] = '\0';
 822930c:	e0bff917 	ldw	r2,-28(fp)
 8229310:	e0fffd17 	ldw	r3,-12(fp)
 8229314:	1885883a 	add	r2,r3,r2
 8229318:	10000005 	stb	zero,0(r2)
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 822931c:	e0bff917 	ldw	r2,-28(fp)
 8229320:	10800044 	addi	r2,r2,1
 8229324:	e0bff915 	stw	r2,-28(fp)
 8229328:	e0fff917 	ldw	r3,-28(fp)
 822932c:	e0bffc17 	ldw	r2,-16(fp)
 8229330:	18bfed16 	blt	r3,r2,82292e8 <parse_args+0x1a0>
   {
      printf("pargv[%d] = %s\n", i, pargv[i]);
   }
#endif

   return (pargv);
 8229334:	e0bffb17 	ldw	r2,-20(fp)
}
 8229338:	e037883a 	mov	sp,fp
 822933c:	dfc00117 	ldw	ra,4(sp)
 8229340:	df000017 	ldw	fp,0(sp)
 8229344:	dec00204 	addi	sp,sp,8
 8229348:	f800283a 	ret

0822934c <netmain>:
 * RETURNS: 
 */

int
netmain(void)
{
 822934c:	defffc04 	addi	sp,sp,-16
 8229350:	dfc00315 	stw	ra,12(sp)
 8229354:	df000215 	stw	fp,8(sp)
 8229358:	df000204 	addi	fp,sp,8
   int   i;
   int   e;

   iniche_net_ready = FALSE;
 822935c:	d0208c15 	stw	zero,-32208(gp)

   e = prep_modules();
 8229360:	823d4140 	call	823d414 <prep_modules>
 8229364:	e0bfff15 	stw	r2,-4(fp)

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 8229368:	e03ffe15 	stw	zero,-8(fp)
 822936c:	00001a06 	br	82293d8 <netmain+0x8c>
   {
      e = TK_NEWTASK(&nettasks[i]);
 8229370:	e0bffe17 	ldw	r2,-8(fp)
 8229374:	10c00624 	muli	r3,r2,24
 8229378:	00820974 	movhi	r2,2085
 822937c:	108ec704 	addi	r2,r2,15132
 8229380:	1885883a 	add	r2,r3,r2
 8229384:	1009883a 	mov	r4,r2
 8229388:	822d9b80 	call	822d9b8 <TK_NEWTASK>
 822938c:	e0bfff15 	stw	r2,-4(fp)
      if (e != 0)
 8229390:	e0bfff17 	ldw	r2,-4(fp)
 8229394:	10000d26 	beq	r2,zero,82293cc <netmain+0x80>
      {
         dprintf("task create error\n");
 8229398:	01020974 	movhi	r4,2085
 822939c:	2101ca04 	addi	r4,r4,1832
 82293a0:	82036800 	call	8203680 <puts>
         panic((char *)&nettasks[i].name);
 82293a4:	e0bffe17 	ldw	r2,-8(fp)
 82293a8:	10800624 	muli	r2,r2,24
 82293ac:	10c00104 	addi	r3,r2,4
 82293b0:	00820974 	movhi	r2,2085
 82293b4:	108ec704 	addi	r2,r2,15132
 82293b8:	1885883a 	add	r2,r3,r2
 82293bc:	1009883a 	mov	r4,r2
 82293c0:	8228ca40 	call	8228ca4 <panic>
         return -1;  /* compiler warnings */
 82293c4:	00bfffc4 	movi	r2,-1
 82293c8:	00001306 	br	8229418 <netmain+0xcc>
   iniche_net_ready = FALSE;

   e = prep_modules();

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 82293cc:	e0bffe17 	ldw	r2,-8(fp)
 82293d0:	10800044 	addi	r2,r2,1
 82293d4:	e0bffe15 	stw	r2,-8(fp)
 82293d8:	d0a03217 	ldw	r2,-32568(gp)
 82293dc:	e0fffe17 	ldw	r3,-8(fp)
 82293e0:	18bfe316 	blt	r3,r2,8229370 <netmain+0x24>
         panic((char *)&nettasks[i].name);
         return -1;  /* compiler warnings */
      }
   }
   
   e = create_apptasks();
 82293e4:	823d87c0 	call	823d87c <create_apptasks>
 82293e8:	e0bfff15 	stw	r2,-4(fp)
   if (e != 0) 
 82293ec:	e0bfff17 	ldw	r2,-4(fp)
 82293f0:	10000826 	beq	r2,zero,8229414 <netmain+0xc8>
   {
      dprintf("task create error\n");
 82293f4:	01020974 	movhi	r4,2085
 82293f8:	2101ca04 	addi	r4,r4,1832
 82293fc:	82036800 	call	8203680 <puts>
      panic("netmain");
 8229400:	01020974 	movhi	r4,2085
 8229404:	2101cf04 	addi	r4,r4,1852
 8229408:	8228ca40 	call	8228ca4 <panic>
      return -1;  /* compiler warnings */
 822940c:	00bfffc4 	movi	r2,-1
 8229410:	00000106 	br	8229418 <netmain+0xcc>
#ifdef MAIN_TASK_IS_NET
   tk_netmain(TK_NETMAINPARM);
   panic("net task return");
   return -1;
#else
   return 0;
 8229414:	0005883a 	mov	r2,zero
#endif
#endif   /* NO_INET_STACK */
}
 8229418:	e037883a 	mov	sp,fp
 822941c:	dfc00117 	ldw	ra,4(sp)
 8229420:	df000017 	ldw	fp,0(sp)
 8229424:	dec00204 	addi	sp,sp,8
 8229428:	f800283a 	ret

0822942c <tk_netmain>:
 * RETURNS: n/a
 */

#ifndef NO_INET_STACK
TK_ENTRY(tk_netmain)
{
 822942c:	defffc04 	addi	sp,sp,-16
 8229430:	dfc00315 	stw	ra,12(sp)
 8229434:	df000215 	stw	fp,8(sp)
 8229438:	df000204 	addi	fp,sp,8
 822943c:	e13fff15 	stw	r4,-4(fp)
   netmain_init(); /* initialize all modules */
 8229440:	823d0740 	call	823d074 <netmain_init>

   iniche_net_ready = TRUE;    /* let the other threads spin */
 8229444:	00800044 	movi	r2,1
 8229448:	d0a08c15 	stw	r2,-32208(gp)

   for (;;)
   {
      TK_NETRX_BLOCK();
 822944c:	d0a0ab17 	ldw	r2,-32084(gp)
 8229450:	e1bffe04 	addi	r6,fp,-8
 8229454:	01401904 	movi	r5,100
 8229458:	1009883a 	mov	r4,r2
 822945c:	821a1300 	call	821a130 <OSSemPend>
 8229460:	e0bffe03 	ldbu	r2,-8(fp)
 8229464:	10803fcc 	andi	r2,r2,255
 8229468:	10000526 	beq	r2,zero,8229480 <tk_netmain+0x54>
 822946c:	e0bffe03 	ldbu	r2,-8(fp)
 8229470:	10803fcc 	andi	r2,r2,255
 8229474:	108002a0 	cmpeqi	r2,r2,10
 8229478:	1000011e 	bne	r2,zero,8229480 <tk_netmain+0x54>
 822947c:	822d5f00 	call	822d5f0 <dtrap>
      netmain_wakes++;  /* count wakeups */
 8229480:	d0a08a17 	ldw	r2,-32216(gp)
 8229484:	10800044 	addi	r2,r2,1
 8229488:	d0a08a15 	stw	r2,-32216(gp)

      /* see if there's newly received network packets */
      if (rcvdq.q_len)
 822948c:	008209b4 	movhi	r2,2086
 8229490:	10b77804 	addi	r2,r2,-8736
 8229494:	10800217 	ldw	r2,8(r2)
 8229498:	103fec26 	beq	r2,zero,822944c <tk_netmain+0x20>
         pktdemux();
 822949c:	82263200 	call	8226320 <pktdemux>
       * vital to a clean shutdown 
       */
#ifdef USE_LCD
      update_display();
#endif
   }
 82294a0:	003fea06 	br	822944c <tk_netmain+0x20>

082294a4 <tk_nettick>:
extern   int dhc_second(void);
#endif

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
 82294a4:	defffd04 	addi	sp,sp,-12
 82294a8:	dfc00215 	stw	ra,8(sp)
 82294ac:	df000115 	stw	fp,4(sp)
 82294b0:	df000104 	addi	fp,sp,4
 82294b4:	e13fff15 	stw	r4,-4(fp)
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 82294b8:	00000306 	br	82294c8 <tk_nettick+0x24>
       * request and then we receive a NAK. At this point the DHCP
       * client is reset to INIT state and dhc_second() needs to be
       * run to restart it.
       */
#ifdef DHCP_CLIENT
      dhc_second();
 82294bc:	822bd6c0 	call	822bd6c <dhc_second>
#endif
      TK_SLEEP(1);
 82294c0:	01000084 	movi	r4,2
 82294c4:	821bf340 	call	821bf34 <OSTimeDly>

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 82294c8:	d0a08c17 	ldw	r2,-32208(gp)
 82294cc:	103ffb26 	beq	r2,zero,82294bc <tk_nettick+0x18>
      TK_SLEEP(1);
   }

   for (;;)
   {
      TK_SLEEP(SYS_SHORT_SLEEP);
 82294d0:	01000084 	movi	r4,2
 82294d4:	821bf340 	call	821bf34 <OSTimeDly>
      nettick_wakes++;  /* count wakeups */
 82294d8:	d0a08b17 	ldw	r2,-32212(gp)
 82294dc:	10800044 	addi	r2,r2,1
 82294e0:	d0a08b15 	stw	r2,-32212(gp)
      inet_timer();  /* let various timeouts occur */
 82294e4:	823d4680 	call	823d468 <inet_timer>
      /* do not kill timers on net_system_exit. They may be
       * vital to a clean shutdown 
       */
   }
 82294e8:	003ff906 	br	82294d0 <tk_nettick+0x2c>

082294ec <TK_OSTimeDly>:
u_char   TK_OSTaskQuery(void);



void TK_OSTimeDly(void)
{
 82294ec:	defffe04 	addi	sp,sp,-8
 82294f0:	dfc00115 	stw	ra,4(sp)
 82294f4:	df000015 	stw	fp,0(sp)
 82294f8:	d839883a 	mov	fp,sp
   OSTimeDly(2);
 82294fc:	01000084 	movi	r4,2
 8229500:	821bf340 	call	821bf34 <OSTimeDly>
}
 8229504:	0001883a 	nop
 8229508:	e037883a 	mov	sp,fp
 822950c:	dfc00117 	ldw	ra,4(sp)
 8229510:	df000017 	ldw	fp,0(sp)
 8229514:	dec00204 	addi	sp,sp,8
 8229518:	f800283a 	ret

0822951c <TK_OSTaskResume>:



void TK_OSTaskResume(u_char * Id)
{
 822951c:	defffc04 	addi	sp,sp,-16
 8229520:	dfc00315 	stw	ra,12(sp)
 8229524:	df000215 	stw	fp,8(sp)
 8229528:	df000204 	addi	fp,sp,8
 822952c:	e13fff15 	stw	r4,-4(fp)
INT8U err;

   err = OSTaskResume(*Id);
 8229530:	e0bfff17 	ldw	r2,-4(fp)
 8229534:	10800003 	ldbu	r2,0(r2)
 8229538:	10803fcc 	andi	r2,r2,255
 822953c:	1009883a 	mov	r4,r2
 8229540:	821b8280 	call	821b828 <OSTaskResume>
 8229544:	e0bffe05 	stb	r2,-8(fp)
   
#ifdef NPDEBUG
   if ((err != OS_NO_ERR) && (err != OS_TASK_NOT_SUSPENDED))
 8229548:	e0bffe03 	ldbu	r2,-8(fp)
 822954c:	10000a26 	beq	r2,zero,8229578 <TK_OSTaskResume+0x5c>
 8229550:	e0bffe03 	ldbu	r2,-8(fp)
 8229554:	10801120 	cmpeqi	r2,r2,68
 8229558:	1000071e 	bne	r2,zero,8229578 <TK_OSTaskResume+0x5c>
   {
      dprintf("ChronOS API call failure, to Resume Suspended Task!\n");
 822955c:	01020974 	movhi	r4,2085
 8229560:	2101d104 	addi	r4,r4,1860
 8229564:	82036800 	call	8203680 <puts>
      dtrap();
 8229568:	822d5f00 	call	822d5f0 <dtrap>
      panic("TK_OSTaskResume");      
 822956c:	01020974 	movhi	r4,2085
 8229570:	2101de04 	addi	r4,r4,1912
 8229574:	8228ca40 	call	8228ca4 <panic>
   }
#endif
}
 8229578:	0001883a 	nop
 822957c:	e037883a 	mov	sp,fp
 8229580:	dfc00117 	ldw	ra,4(sp)
 8229584:	df000017 	ldw	fp,0(sp)
 8229588:	dec00204 	addi	sp,sp,8
 822958c:	f800283a 	ret

08229590 <tcp_sleep>:
 *
 * RETURN: none
 */
void
tcp_sleep(void * event)
{
 8229590:	defffb04 	addi	sp,sp,-20
 8229594:	dfc00415 	stw	ra,16(sp)
 8229598:	df000315 	stw	fp,12(sp)
 822959c:	df000304 	addi	fp,sp,12
 82295a0:	e13fff15 	stw	r4,-4(fp)
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 82295a4:	e03ffd15 	stw	zero,-12(fp)
 82295a8:	00004706 	br	82296c8 <tcp_sleep+0x138>
   {
      if (global_TCPwakeup_set[i].soc_event == NULL)
 82295ac:	008209b4 	movhi	r2,2086
 82295b0:	10b92804 	addi	r2,r2,-7008
 82295b4:	e0fffd17 	ldw	r3,-12(fp)
 82295b8:	18c00324 	muli	r3,r3,12
 82295bc:	10c5883a 	add	r2,r2,r3
 82295c0:	10800104 	addi	r2,r2,4
 82295c4:	10800017 	ldw	r2,0(r2)
 82295c8:	10003c1e 	bne	r2,zero,82296bc <tcp_sleep+0x12c>
      {
         global_TCPwakeup_set[i].soc_event = event;
 82295cc:	008209b4 	movhi	r2,2086
 82295d0:	10b92804 	addi	r2,r2,-7008
 82295d4:	e0fffd17 	ldw	r3,-12(fp)
 82295d8:	18c00324 	muli	r3,r3,12
 82295dc:	10c5883a 	add	r2,r2,r3
 82295e0:	10800104 	addi	r2,r2,4
 82295e4:	e0ffff17 	ldw	r3,-4(fp)
 82295e8:	10c00015 	stw	r3,0(r2)
         global_TCPwakeup_set[i].ctick = cticks;
 82295ec:	d0e0a817 	ldw	r3,-32096(gp)
 82295f0:	008209b4 	movhi	r2,2086
 82295f4:	10b92804 	addi	r2,r2,-7008
 82295f8:	e13ffd17 	ldw	r4,-12(fp)
 82295fc:	21000324 	muli	r4,r4,12
 8229600:	1105883a 	add	r2,r2,r4
 8229604:	10c00015 	stw	r3,0(r2)
         if (i > global_TCPwakeup_setIndx)
 8229608:	d0e0a717 	ldw	r3,-32100(gp)
 822960c:	e0bffd17 	ldw	r2,-12(fp)
 8229610:	1880020e 	bge	r3,r2,822961c <tcp_sleep+0x8c>
            global_TCPwakeup_setIndx = i;
 8229614:	e0bffd17 	ldw	r2,-12(fp)
 8229618:	d0a0a715 	stw	r2,-32100(gp)

         tcp_sleep_count++;
 822961c:	d0a0a317 	ldw	r2,-32116(gp)
 8229620:	10800044 	addi	r2,r2,1
 8229624:	d0a0a315 	stw	r2,-32116(gp)

         /* Give up the lock before going to sleep. This can
          * potentially cause a context switch to the task
          * signaling the event.
          */
         UNLOCK_NET_RESOURCE(NET_RESID);
 8229628:	0009883a 	mov	r4,zero
 822962c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>

         /* don't wait forever in case we miss the event */
         OSSemPend(global_TCPwakeup_set[i].semaphore, TPS, &err);
 8229630:	008209b4 	movhi	r2,2086
 8229634:	10b92804 	addi	r2,r2,-7008
 8229638:	e0fffd17 	ldw	r3,-12(fp)
 822963c:	18c00324 	muli	r3,r3,12
 8229640:	10c5883a 	add	r2,r2,r3
 8229644:	10800204 	addi	r2,r2,8
 8229648:	10800017 	ldw	r2,0(r2)
 822964c:	e0fffe04 	addi	r3,fp,-8
 8229650:	180d883a 	mov	r6,r3
 8229654:	01401904 	movi	r5,100
 8229658:	1009883a 	mov	r4,r2
 822965c:	821a1300 	call	821a130 <OSSemPend>
         if (err == 10)
 8229660:	e0bffe03 	ldbu	r2,-8(fp)
 8229664:	10803fcc 	andi	r2,r2,255
 8229668:	10800298 	cmpnei	r2,r2,10
 822966c:	1000101e 	bne	r2,zero,82296b0 <tcp_sleep+0x120>
         {
            ++tcp_sleep_timeout;
 8229670:	d0a08e17 	ldw	r2,-32200(gp)
 8229674:	10800044 	addi	r2,r2,1
 8229678:	d0a08e15 	stw	r2,-32200(gp)

            /* clear the entry */
            global_TCPwakeup_set[i].ctick = 0;
 822967c:	008209b4 	movhi	r2,2086
 8229680:	10b92804 	addi	r2,r2,-7008
 8229684:	e0fffd17 	ldw	r3,-12(fp)
 8229688:	18c00324 	muli	r3,r3,12
 822968c:	10c5883a 	add	r2,r2,r3
 8229690:	10000015 	stw	zero,0(r2)
            global_TCPwakeup_set[i].soc_event = NULL;
 8229694:	008209b4 	movhi	r2,2086
 8229698:	10b92804 	addi	r2,r2,-7008
 822969c:	e0fffd17 	ldw	r3,-12(fp)
 82296a0:	18c00324 	muli	r3,r3,12
 82296a4:	10c5883a 	add	r2,r2,r3
 82296a8:	10800104 	addi	r2,r2,4
 82296ac:	10000015 	stw	zero,0(r2)
         }

         /* Regain the lock */
         LOCK_NET_RESOURCE(NET_RESID);
 82296b0:	0009883a 	mov	r4,zero
 82296b4:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
 82296b8:	00000d06 	br	82296f0 <tcp_sleep+0x160>
tcp_sleep(void * event)
{
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 82296bc:	e0bffd17 	ldw	r2,-12(fp)
 82296c0:	10800044 	addi	r2,r2,1
 82296c4:	e0bffd15 	stw	r2,-12(fp)
 82296c8:	e0bffd17 	ldw	r2,-12(fp)
 82296cc:	10800510 	cmplti	r2,r2,20
 82296d0:	103fb61e 	bne	r2,zero,82295ac <tcp_sleep+0x1c>

   /* The table is full. Try calling TK_YIELD() and hope for the best.
    * The user should increase the size of the table.
    * We'll record the max index for debugging purposes.
    */
   global_TCPwakeup_setIndx = i;
 82296d4:	e0bffd17 	ldw	r2,-12(fp)
 82296d8:	d0a0a715 	stw	r2,-32100(gp)

   UNLOCK_NET_RESOURCE(NET_RESID);
 82296dc:	0009883a 	mov	r4,zero
 82296e0:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   TK_YIELD();
 82296e4:	82298680 	call	8229868 <tk_yield>
   LOCK_NET_RESOURCE(NET_RESID);
 82296e8:	0009883a 	mov	r4,zero
 82296ec:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
}
 82296f0:	e037883a 	mov	sp,fp
 82296f4:	dfc00117 	ldw	ra,4(sp)
 82296f8:	df000017 	ldw	fp,0(sp)
 82296fc:	dec00204 	addi	sp,sp,8
 8229700:	f800283a 	ret

08229704 <tcp_wakeup>:
 *
 * RETURN: none
 */
void
tcp_wakeup(void *event)
{
 8229704:	defffc04 	addi	sp,sp,-16
 8229708:	dfc00315 	stw	ra,12(sp)
 822970c:	df000215 	stw	fp,8(sp)
 8229710:	df000204 	addi	fp,sp,8
 8229714:	e13fff15 	stw	r4,-4(fp)
   int i;

   OSSchedLock();
 8229718:	821564c0 	call	821564c <OSSchedLock>

   for (i = 0; i < GLOBWAKE_SZ; i++)
 822971c:	e03ffe15 	stw	zero,-8(fp)
 8229720:	00002c06 	br	82297d4 <tcp_wakeup+0xd0>
   {
      if ((global_TCPwakeup_set[i].ctick != 0) &&
 8229724:	008209b4 	movhi	r2,2086
 8229728:	10b92804 	addi	r2,r2,-7008
 822972c:	e0fffe17 	ldw	r3,-8(fp)
 8229730:	18c00324 	muli	r3,r3,12
 8229734:	10c5883a 	add	r2,r2,r3
 8229738:	10800017 	ldw	r2,0(r2)
 822973c:	10002226 	beq	r2,zero,82297c8 <tcp_wakeup+0xc4>
          (global_TCPwakeup_set[i].soc_event == event))
 8229740:	008209b4 	movhi	r2,2086
 8229744:	10b92804 	addi	r2,r2,-7008
 8229748:	e0fffe17 	ldw	r3,-8(fp)
 822974c:	18c00324 	muli	r3,r3,12
 8229750:	10c5883a 	add	r2,r2,r3
 8229754:	10800104 	addi	r2,r2,4
 8229758:	10c00017 	ldw	r3,0(r2)

   OSSchedLock();

   for (i = 0; i < GLOBWAKE_SZ; i++)
   {
      if ((global_TCPwakeup_set[i].ctick != 0) &&
 822975c:	e0bfff17 	ldw	r2,-4(fp)
 8229760:	1880191e 	bne	r3,r2,82297c8 <tcp_wakeup+0xc4>
          (global_TCPwakeup_set[i].soc_event == event))
      {
         /* signal the event */
         OSSemPost(global_TCPwakeup_set[i].semaphore);
 8229764:	008209b4 	movhi	r2,2086
 8229768:	10b92804 	addi	r2,r2,-7008
 822976c:	e0fffe17 	ldw	r3,-8(fp)
 8229770:	18c00324 	muli	r3,r3,12
 8229774:	10c5883a 	add	r2,r2,r3
 8229778:	10800204 	addi	r2,r2,8
 822977c:	10800017 	ldw	r2,0(r2)
 8229780:	1009883a 	mov	r4,r2
 8229784:	821a4a80 	call	821a4a8 <OSSemPost>

         /* clear the entry */
         global_TCPwakeup_set[i].ctick = 0;
 8229788:	008209b4 	movhi	r2,2086
 822978c:	10b92804 	addi	r2,r2,-7008
 8229790:	e0fffe17 	ldw	r3,-8(fp)
 8229794:	18c00324 	muli	r3,r3,12
 8229798:	10c5883a 	add	r2,r2,r3
 822979c:	10000015 	stw	zero,0(r2)
         global_TCPwakeup_set[i].soc_event = NULL;
 82297a0:	008209b4 	movhi	r2,2086
 82297a4:	10b92804 	addi	r2,r2,-7008
 82297a8:	e0fffe17 	ldw	r3,-8(fp)
 82297ac:	18c00324 	muli	r3,r3,12
 82297b0:	10c5883a 	add	r2,r2,r3
 82297b4:	10800104 	addi	r2,r2,4
 82297b8:	10000015 	stw	zero,0(r2)

         tcp_wakeup_count++;
 82297bc:	d0a0a417 	ldw	r2,-32112(gp)
 82297c0:	10800044 	addi	r2,r2,1
 82297c4:	d0a0a415 	stw	r2,-32112(gp)
{
   int i;

   OSSchedLock();

   for (i = 0; i < GLOBWAKE_SZ; i++)
 82297c8:	e0bffe17 	ldw	r2,-8(fp)
 82297cc:	10800044 	addi	r2,r2,1
 82297d0:	e0bffe15 	stw	r2,-8(fp)
 82297d4:	e0bffe17 	ldw	r2,-8(fp)
 82297d8:	10800510 	cmplti	r2,r2,20
 82297dc:	103fd11e 	bne	r2,zero,8229724 <tcp_wakeup+0x20>

         tcp_wakeup_count++;
      }
   }

   OSSchedUnlock();
 82297e0:	82156d80 	call	82156d8 <OSSchedUnlock>
}
 82297e4:	0001883a 	nop
 82297e8:	e037883a 	mov	sp,fp
 82297ec:	dfc00117 	ldw	ra,4(sp)
 82297f0:	df000017 	ldw	fp,0(sp)
 82297f4:	dec00204 	addi	sp,sp,8
 82297f8:	f800283a 	ret

082297fc <TK_OSTaskQuery>:



u_char TK_OSTaskQuery(void)
{
 82297fc:	deffe204 	addi	sp,sp,-120
 8229800:	dfc01d15 	stw	ra,116(sp)
 8229804:	df001c15 	stw	fp,112(sp)
 8229808:	df001c04 	addi	fp,sp,112
   OS_TCB task_data;
   INT8U err, task_prio;

   err = OSTaskQuery(OS_PRIO_SELF, &task_data);
 822980c:	e0bfe504 	addi	r2,fp,-108
 8229810:	100b883a 	mov	r5,r2
 8229814:	01003fc4 	movi	r4,255
 8229818:	821bda00 	call	821bda0 <OSTaskQuery>
 822981c:	e0bfe405 	stb	r2,-112(fp)

   if (err == OS_NO_ERR)
 8229820:	e0bfe403 	ldbu	r2,-112(fp)
 8229824:	1000041e 	bne	r2,zero,8229838 <TK_OSTaskQuery+0x3c>
   {
      task_prio = task_data.OSTCBPrio;
 8229828:	e0bff183 	ldbu	r2,-58(fp)
 822982c:	e0bfe445 	stb	r2,-111(fp)
      dprintf("ChronOS API call failure, unable to identify task!");
      panic("TK_OSTaskQuery");
      return 0;
   }
   
   return task_prio;
 8229830:	e0bfe443 	ldbu	r2,-111(fp)
 8229834:	00000706 	br	8229854 <TK_OSTaskQuery+0x58>
   {
      task_prio = task_data.OSTCBPrio;
   }
   else
   {
      dprintf("ChronOS API call failure, unable to identify task!");
 8229838:	01020974 	movhi	r4,2085
 822983c:	2101e204 	addi	r4,r4,1928
 8229840:	82033fc0 	call	82033fc <printf>
      panic("TK_OSTaskQuery");
 8229844:	01020974 	movhi	r4,2085
 8229848:	2101ef04 	addi	r4,r4,1980
 822984c:	8228ca40 	call	8228ca4 <panic>
      return 0;
 8229850:	0005883a 	mov	r2,zero
   }
   
   return task_prio;
}
 8229854:	e037883a 	mov	sp,fp
 8229858:	dfc00117 	ldw	ra,4(sp)
 822985c:	df000017 	ldw	fp,0(sp)
 8229860:	dec00204 	addi	sp,sp,8
 8229864:	f800283a 	ret

08229868 <tk_yield>:



void
tk_yield(void)
{
 8229868:	defffe04 	addi	sp,sp,-8
 822986c:	dfc00115 	stw	ra,4(sp)
 8229870:	df000015 	stw	fp,0(sp)
 8229874:	d839883a 	mov	fp,sp
   /* To ensure cycles to the lower priority tasks we should really
    * delay by two ticks, but that really hurts performance on some
    * long-tick targets. One tick works better overall....
    */
   OSTimeDly(1);
 8229878:	01000044 	movi	r4,1
 822987c:	821bf340 	call	821bf34 <OSTimeDly>
}
 8229880:	0001883a 	nop
 8229884:	e037883a 	mov	sp,fp
 8229888:	dfc00117 	ldw	ra,4(sp)
 822988c:	df000017 	ldw	fp,0(sp)
 8229890:	dec00204 	addi	sp,sp,8
 8229894:	f800283a 	ret

08229898 <tk_stats>:
extern struct inet_taskinfo * nettask;
extern int num_net_tasks;

int
tk_stats(void * pio)
{
 8229898:	deffef04 	addi	sp,sp,-68
 822989c:	dfc01015 	stw	ra,64(sp)
 82298a0:	df000f15 	stw	fp,60(sp)
 82298a4:	df000f04 	addi	fp,sp,60
 82298a8:	e13fff15 	stw	r4,-4(fp)
   int      stackuse;
   char     name[OS_TASK_NAME_SIZE+1];
   INT8U    err;
   

   ns_printf(pio, "ChronOS RTOS stats:\n");
 82298ac:	01420974 	movhi	r5,2085
 82298b0:	2941f304 	addi	r5,r5,1996
 82298b4:	e13fff17 	ldw	r4,-4(fp)
 82298b8:	8228ebc0 	call	8228ebc <ns_printf>

#ifdef NO_INICHE_EXTENSIONS
   ns_printf(pio, "Context switches; Delay:  %lu\n",
 82298bc:	d0a07017 	ldw	r2,-32320(gp)
 82298c0:	100d883a 	mov	r6,r2
 82298c4:	01420974 	movhi	r5,2085
 82298c8:	2941f904 	addi	r5,r5,2020
 82298cc:	e13fff17 	ldw	r4,-4(fp)
 82298d0:	8228ebc0 	call	8228ebc <ns_printf>
#else
   ns_printf(pio, "Context switches; Delay:  %lu, Interrupt: %lu\n",
      OSCtxSwCtr, OSCtxIntCtr);
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");
 82298d4:	01420974 	movhi	r5,2085
 82298d8:	29420104 	addi	r5,r5,2052
 82298dc:	e13fff17 	ldw	r4,-4(fp)
 82298e0:	8228ebc0 	call	8228ebc <ns_printf>

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 82298e4:	e03ff215 	stw	zero,-56(fp)
 82298e8:	00005406 	br	8229a3c <tk_stats+0x1a4>
   {
      /* get pointer to TCB and see if entry is in use and not a mutex */
      tcb = OSTCBPrioTbl[t];
 82298ec:	008209b4 	movhi	r2,2086
 82298f0:	10b6cb04 	addi	r2,r2,-9428
 82298f4:	e0fff217 	ldw	r3,-56(fp)
 82298f8:	18c7883a 	add	r3,r3,r3
 82298fc:	18c7883a 	add	r3,r3,r3
 8229900:	10c5883a 	add	r2,r2,r3
 8229904:	10800017 	ldw	r2,0(r2)
 8229908:	e0bff415 	stw	r2,-48(fp)
      if ((tcb == NULL) || (tcb == (OS_TCB *)1))
 822990c:	e0bff417 	ldw	r2,-48(fp)
 8229910:	10004626 	beq	r2,zero,8229a2c <tk_stats+0x194>
 8229914:	e0bff417 	ldw	r2,-48(fp)
 8229918:	10800058 	cmpnei	r2,r2,1
 822991c:	10004326 	beq	r2,zero,8229a2c <tk_stats+0x194>
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);
 8229920:	e0bff417 	ldw	r2,-48(fp)
 8229924:	10800c83 	ldbu	r2,50(r2)
 8229928:	10803fcc 	andi	r2,r2,255
 822992c:	e13ffe44 	addi	r4,fp,-7
 8229930:	e0fff604 	addi	r3,fp,-40
 8229934:	200d883a 	mov	r6,r4
 8229938:	180b883a 	mov	r5,r3
 822993c:	1009883a 	mov	r4,r2
 8229940:	821b4dc0 	call	821b4dc <OSTaskNameGet>

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
                     name, tcb->OSTCBPrio, tcb->OSTCBStat);
 8229944:	e0bff417 	ldw	r2,-48(fp)
 8229948:	10800c83 	ldbu	r2,50(r2)
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
 822994c:	11003fcc 	andi	r4,r2,255
                     name, tcb->OSTCBPrio, tcb->OSTCBStat);
 8229950:	e0bff417 	ldw	r2,-48(fp)
 8229954:	10800c03 	ldbu	r2,48(r2)
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
 8229958:	10803fcc 	andi	r2,r2,255
 822995c:	e0fff604 	addi	r3,fp,-40
 8229960:	d8800015 	stw	r2,0(sp)
 8229964:	200f883a 	mov	r7,r4
 8229968:	180d883a 	mov	r6,r3
 822996c:	01420974 	movhi	r5,2085
 8229970:	29421104 	addi	r5,r5,2116
 8229974:	e13fff17 	ldw	r4,-4(fp)
 8229978:	8228ebc0 	call	8228ebc <ns_printf>
      /* Find lowest non-zero value in stack so we can estimate the
       * unused portion. Subtracting this from size gives us the used
       * portion of the stack.
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
 822997c:	e0bff417 	ldw	r2,-48(fp)
 8229980:	10800217 	ldw	r2,8(r2)
 8229984:	10002426 	beq	r2,zero,8229a18 <tk_stats+0x180>
 8229988:	e0bff417 	ldw	r2,-48(fp)
 822998c:	10800317 	ldw	r2,12(r2)
 8229990:	10002126 	beq	r2,zero,8229a18 <tk_stats+0x180>
      {
         sp = tcb->OSTCBStkBottom + 1;
 8229994:	e0bff417 	ldw	r2,-48(fp)
 8229998:	10800217 	ldw	r2,8(r2)
 822999c:	10800104 	addi	r2,r2,4
 82299a0:	e0bff315 	stw	r2,-52(fp)
         while(*sp == 0)
 82299a4:	00000306 	br	82299b4 <tk_stats+0x11c>
            sp++;
 82299a8:	e0bff317 	ldw	r2,-52(fp)
 82299ac:	10800104 	addi	r2,r2,4
 82299b0:	e0bff315 	stw	r2,-52(fp)
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
      {
         sp = tcb->OSTCBStkBottom + 1;
         while(*sp == 0)
 82299b4:	e0bff317 	ldw	r2,-52(fp)
 82299b8:	10800017 	ldw	r2,0(r2)
 82299bc:	103ffa26 	beq	r2,zero,82299a8 <tk_stats+0x110>
            sp++;
         /* This OS traditionally keeps the size in OS_STK (int) units rather
          * than bytes, so convert back to bytes for display.
          */
         stackuse = (tcb->OSTCBStkSize - (sp - tcb->OSTCBStkBottom)) * sizeof(OS_STK);
 82299c0:	e0bff417 	ldw	r2,-48(fp)
 82299c4:	10800317 	ldw	r2,12(r2)
 82299c8:	e0fff317 	ldw	r3,-52(fp)
 82299cc:	e13ff417 	ldw	r4,-48(fp)
 82299d0:	21000217 	ldw	r4,8(r4)
 82299d4:	1907c83a 	sub	r3,r3,r4
 82299d8:	1807d0ba 	srai	r3,r3,2
 82299dc:	10c5c83a 	sub	r2,r2,r3
 82299e0:	1085883a 	add	r2,r2,r2
 82299e4:	1085883a 	add	r2,r2,r2
 82299e8:	e0bff515 	stw	r2,-44(fp)
         ns_printf(pio, "%6d,      %6d\n",
            tcb->OSTCBStkSize * sizeof(OS_STK),  stackuse);
 82299ec:	e0bff417 	ldw	r2,-48(fp)
 82299f0:	10800317 	ldw	r2,12(r2)
            sp++;
         /* This OS traditionally keeps the size in OS_STK (int) units rather
          * than bytes, so convert back to bytes for display.
          */
         stackuse = (tcb->OSTCBStkSize - (sp - tcb->OSTCBStkBottom)) * sizeof(OS_STK);
         ns_printf(pio, "%6d,      %6d\n",
 82299f4:	1085883a 	add	r2,r2,r2
 82299f8:	1085883a 	add	r2,r2,r2
 82299fc:	e1fff517 	ldw	r7,-44(fp)
 8229a00:	100d883a 	mov	r6,r2
 8229a04:	01420974 	movhi	r5,2085
 8229a08:	29421904 	addi	r5,r5,2148
 8229a0c:	e13fff17 	ldw	r4,-4(fp)
 8229a10:	8228ebc0 	call	8228ebc <ns_printf>
 8229a14:	00000606 	br	8229a30 <tk_stats+0x198>
            tcb->OSTCBStkSize * sizeof(OS_STK),  stackuse);
      }
      else
#endif
      {
         ns_printf(pio, "No stack data\n");
 8229a18:	01420974 	movhi	r5,2085
 8229a1c:	29421d04 	addi	r5,r5,2164
 8229a20:	e13fff17 	ldw	r4,-4(fp)
 8229a24:	8228ebc0 	call	8228ebc <ns_printf>
 8229a28:	00000106 	br	8229a30 <tk_stats+0x198>
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
   {
      /* get pointer to TCB and see if entry is in use and not a mutex */
      tcb = OSTCBPrioTbl[t];
      if ((tcb == NULL) || (tcb == (OS_TCB *)1))
         continue;
 8229a2c:	0001883a 	nop
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 8229a30:	e0bff217 	ldw	r2,-56(fp)
 8229a34:	10800044 	addi	r2,r2,1
 8229a38:	e0bff215 	stw	r2,-56(fp)
 8229a3c:	e0bff217 	ldw	r2,-56(fp)
 8229a40:	10800550 	cmplti	r2,r2,21
 8229a44:	103fa91e 	bne	r2,zero,82298ec <tk_stats+0x54>
      {
         ns_printf(pio, "No stack data\n");
      }
   }

   ns_printf(pio, "tcp_sleep_count = %lu, tcp_wakeup_count = %lu\n",
 8229a48:	d0a0a317 	ldw	r2,-32116(gp)
 8229a4c:	d0e0a417 	ldw	r3,-32112(gp)
 8229a50:	180f883a 	mov	r7,r3
 8229a54:	100d883a 	mov	r6,r2
 8229a58:	01420974 	movhi	r5,2085
 8229a5c:	29422104 	addi	r5,r5,2180
 8229a60:	e13fff17 	ldw	r4,-4(fp)
 8229a64:	8228ebc0 	call	8228ebc <ns_printf>
                  tcp_sleep_count, tcp_wakeup_count);
   ns_printf(pio, "global_TCPwakeup_setIndx = %d, tcp_sleep_timeout = %lu\n",
 8229a68:	d0a0a717 	ldw	r2,-32100(gp)
 8229a6c:	d0e08e17 	ldw	r3,-32200(gp)
 8229a70:	180f883a 	mov	r7,r3
 8229a74:	100d883a 	mov	r6,r2
 8229a78:	01420974 	movhi	r5,2085
 8229a7c:	29422d04 	addi	r5,r5,2228
 8229a80:	e13fff17 	ldw	r4,-4(fp)
 8229a84:	8228ebc0 	call	8228ebc <ns_printf>
                  global_TCPwakeup_setIndx, tcp_sleep_timeout);

   return 0;
 8229a88:	0005883a 	mov	r2,zero
}
 8229a8c:	e037883a 	mov	sp,fp
 8229a90:	dfc00117 	ldw	ra,4(sp)
 8229a94:	df000017 	ldw	fp,0(sp)
 8229a98:	dec00204 	addi	sp,sp,8
 8229a9c:	f800283a 	ret

08229aa0 <dhc_get_srv_ipaddr>:
 * RETURNS: 
 */

ip_addr 
dhc_get_srv_ipaddr(u_char *options /* after magic cookie */) 
{
 8229aa0:	defffa04 	addi	sp,sp,-24
 8229aa4:	dfc00515 	stw	ra,20(sp)
 8229aa8:	df000415 	stw	fp,16(sp)
 8229aac:	df000404 	addi	fp,sp,16
 8229ab0:	e13fff15 	stw	r4,-4(fp)
    u_char * opts;
    u_char   optlen;
   ip_addr srv_ipaddr = 0;
 8229ab4:	e03ffc15 	stw	zero,-16(fp)

   if ((opts = find_opt(DHOP_SERVER, options)) != NULL) 
 8229ab8:	e17fff17 	ldw	r5,-4(fp)
 8229abc:	01000d84 	movi	r4,54
 8229ac0:	822c6ec0 	call	822c6ec <find_opt>
 8229ac4:	e0bffd15 	stw	r2,-12(fp)
 8229ac8:	e0bffd17 	ldw	r2,-12(fp)
 8229acc:	10001026 	beq	r2,zero,8229b10 <dhc_get_srv_ipaddr+0x70>
   {
      opts++;
 8229ad0:	e0bffd17 	ldw	r2,-12(fp)
 8229ad4:	10800044 	addi	r2,r2,1
 8229ad8:	e0bffd15 	stw	r2,-12(fp)
      optlen = *opts;
 8229adc:	e0bffd17 	ldw	r2,-12(fp)
 8229ae0:	10800003 	ldbu	r2,0(r2)
 8229ae4:	e0bffe05 	stb	r2,-8(fp)
      opts++;
 8229ae8:	e0bffd17 	ldw	r2,-12(fp)
 8229aec:	10800044 	addi	r2,r2,1
 8229af0:	e0bffd15 	stw	r2,-12(fp)
      srv_ipaddr = dh_getlong(opts);
 8229af4:	e13ffd17 	ldw	r4,-12(fp)
 8229af8:	822ba500 	call	822ba50 <dh_getlong>
 8229afc:	e0bffc15 	stw	r2,-16(fp)
      opts += optlen;
 8229b00:	e0bffe03 	ldbu	r2,-8(fp)
 8229b04:	e0fffd17 	ldw	r3,-12(fp)
 8229b08:	1885883a 	add	r2,r3,r2
 8229b0c:	e0bffd15 	stw	r2,-12(fp)
   }

   return (srv_ipaddr);
 8229b10:	e0bffc17 	ldw	r2,-16(fp)
} 
 8229b14:	e037883a 	mov	sp,fp
 8229b18:	dfc00117 	ldw	ra,4(sp)
 8229b1c:	df000017 	ldw	fp,0(sp)
 8229b20:	dec00204 	addi	sp,sp,8
 8229b24:	f800283a 	ret

08229b28 <dhc_init>:
 * RETURNS: Returns 0 if OK, else negative error code from net.h file 
 */

int
dhc_init(void)
{
 8229b28:	defffc04 	addi	sp,sp,-16
 8229b2c:	dfc00315 	stw	ra,12(sp)
 8229b30:	df000215 	stw	fp,8(sp)
 8229b34:	df000204 	addi	fp,sp,8
   int   i;

   /* open UDP connection to receive incoming DHCP replys */
   dhc_conn = udp_open(0L,    /* wildcard foriegn host */
 8229b38:	00bfff44 	movi	r2,-3
 8229b3c:	d8800015 	stw	r2,0(sp)
 8229b40:	01c208f4 	movhi	r7,2083
 8229b44:	39e70804 	addi	r7,r7,-25568
 8229b48:	01801104 	movi	r6,68
 8229b4c:	014010c4 	movi	r5,67
 8229b50:	0009883a 	mov	r4,zero
 8229b54:	822d1880 	call	822d188 <udp_open>
 8229b58:	d0a08f15 	stw	r2,-32196(gp)
      BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT,
      dhc_upcall, DHCPDATA);

   if (!dhc_conn)
 8229b5c:	d0a08f17 	ldw	r2,-32196(gp)
 8229b60:	1000021e 	bne	r2,zero,8229b6c <dhc_init+0x44>
      return ENP_RESOURCE;
 8229b64:	00bffa84 	movi	r2,-22
 8229b68:	00001606 	br	8229bc4 <dhc_init+0x9c>

   for (i = 0; i < MAXNETS; i++)
 8229b6c:	e03fff15 	stw	zero,-4(fp)
 8229b70:	00001006 	br	8229bb4 <dhc_init+0x8c>
   {
      dhc_states[i].state = DHCS_UNUSED;
 8229b74:	008209b4 	movhi	r2,2086
 8229b78:	10b86304 	addi	r2,r2,-7796
 8229b7c:	e0ffff17 	ldw	r3,-4(fp)
 8229b80:	18c00f24 	muli	r3,r3,60
 8229b84:	10c5883a 	add	r2,r2,r3
 8229b88:	10000015 	stw	zero,0(r2)
      dhc_states[i].tries = 0;
 8229b8c:	008209b4 	movhi	r2,2086
 8229b90:	10b86304 	addi	r2,r2,-7796
 8229b94:	e0ffff17 	ldw	r3,-4(fp)
 8229b98:	18c00f24 	muli	r3,r3,60
 8229b9c:	10c5883a 	add	r2,r2,r3
 8229ba0:	10800104 	addi	r2,r2,4
 8229ba4:	10000015 	stw	zero,0(r2)
      dhc_upcall, DHCPDATA);

   if (!dhc_conn)
      return ENP_RESOURCE;

   for (i = 0; i < MAXNETS; i++)
 8229ba8:	e0bfff17 	ldw	r2,-4(fp)
 8229bac:	10800044 	addi	r2,r2,1
 8229bb0:	e0bfff15 	stw	r2,-4(fp)
 8229bb4:	e0bfff17 	ldw	r2,-4(fp)
 8229bb8:	10800110 	cmplti	r2,r2,4
 8229bbc:	103fed1e 	bne	r2,zero,8229b74 <dhc_init+0x4c>
   {
      dhc_states[i].state = DHCS_UNUSED;
      dhc_states[i].tries = 0;
   }

   return 0;
 8229bc0:	0005883a 	mov	r2,zero
}
 8229bc4:	e037883a 	mov	sp,fp
 8229bc8:	dfc00117 	ldw	ra,4(sp)
 8229bcc:	df000017 	ldw	fp,0(sp)
 8229bd0:	dec00204 	addi	sp,sp,8
 8229bd4:	f800283a 	ret

08229bd8 <dhc_set_callback>:
 * RETURNS: 
 */

void
dhc_set_callback(int iface, int (*routine)(int,int) )
{
 8229bd8:	defffd04 	addi	sp,sp,-12
 8229bdc:	df000215 	stw	fp,8(sp)
 8229be0:	df000204 	addi	fp,sp,8
 8229be4:	e13ffe15 	stw	r4,-8(fp)
 8229be8:	e17fff15 	stw	r5,-4(fp)
   dhc_states[iface].callback = routine;
 8229bec:	008209b4 	movhi	r2,2086
 8229bf0:	10b86304 	addi	r2,r2,-7796
 8229bf4:	e0fffe17 	ldw	r3,-8(fp)
 8229bf8:	18c00f24 	muli	r3,r3,60
 8229bfc:	10c5883a 	add	r2,r2,r3
 8229c00:	10800e04 	addi	r2,r2,56
 8229c04:	e0ffff17 	ldw	r3,-4(fp)
 8229c08:	10c00015 	stw	r3,0(r2)
}
 8229c0c:	0001883a 	nop
 8229c10:	e037883a 	mov	sp,fp
 8229c14:	df000017 	ldw	fp,0(sp)
 8229c18:	dec00104 	addi	sp,sp,4
 8229c1c:	f800283a 	ret

08229c20 <dhc_upcall>:
 * returned
 */

int
dhc_upcall(PACKET pkt, void * data)
{
 8229c20:	defff504 	addi	sp,sp,-44
 8229c24:	dfc00a15 	stw	ra,40(sp)
 8229c28:	df000915 	stw	fp,36(sp)
 8229c2c:	dc000815 	stw	r16,32(sp)
 8229c30:	df000904 	addi	fp,sp,36
 8229c34:	e13ffd15 	stw	r4,-12(fp)
 8229c38:	e17ffe15 	stw	r5,-8(fp)
   struct bootp * bp;
   int      len      =  pkt->nb_plen;  /* len of UDP data - the bootp/dhcp struct */
 8229c3c:	e0bffd17 	ldw	r2,-12(fp)
 8229c40:	10800417 	ldw	r2,16(r2)
 8229c44:	e0bff815 	stw	r2,-32(fp)
   int      dhcptype =  0;    /* DHCP type - not valid if bootp */
 8229c48:	e03ff715 	stw	zero,-36(fp)
   int      e;
   int      iface;
   u_char * opts;          /* scratch options pointer */

   if (data != DHCPDATA)
 8229c4c:	e0bffe17 	ldw	r2,-8(fp)
 8229c50:	10bfff60 	cmpeqi	r2,r2,-3
 8229c54:	1000031e 	bne	r2,zero,8229c64 <dhc_upcall+0x44>
   {
      dtrap();
 8229c58:	822d5f00 	call	822d5f0 <dtrap>
      return ENP_LOGIC;    /* internal logic error */
 8229c5c:	00bffd44 	movi	r2,-11
 8229c60:	0001d506 	br	822a3b8 <dhc_upcall+0x798>
   }

   /* punt if packet didn't come in a net we sent on */
   iface = net_num(pkt->net);
 8229c64:	e0bffd17 	ldw	r2,-12(fp)
 8229c68:	10800617 	ldw	r2,24(r2)
 8229c6c:	1009883a 	mov	r4,r2
 8229c70:	8226cc40 	call	8226cc4 <if_netnumber>
 8229c74:	e0bff915 	stw	r2,-28(fp)
   if (dhc_states[iface].state == DHCS_UNUSED)
 8229c78:	008209b4 	movhi	r2,2086
 8229c7c:	10b86304 	addi	r2,r2,-7796
 8229c80:	e0fff917 	ldw	r3,-28(fp)
 8229c84:	18c00f24 	muli	r3,r3,60
 8229c88:	10c5883a 	add	r2,r2,r3
 8229c8c:	10800017 	ldw	r2,0(r2)
 8229c90:	1000021e 	bne	r2,zero,8229c9c <dhc_upcall+0x7c>
      return ENP_NOT_MINE;
 8229c94:	00800084 	movi	r2,2
 8229c98:	0001c706 	br	822a3b8 <dhc_upcall+0x798>

   bp = (struct bootp *)pkt->nb_prot;
 8229c9c:	e0bffd17 	ldw	r2,-12(fp)
 8229ca0:	10800317 	ldw	r2,12(r2)
 8229ca4:	e0bffa15 	stw	r2,-24(fp)

   /*   Validate various fields   */
   if ((len < (sizeof(struct bootp)-BOOTP_OPTSIZE) ) || 
 8229ca8:	e0bff817 	ldw	r2,-32(fp)
 8229cac:	10803b30 	cmpltui	r2,r2,236
 8229cb0:	10000b1e 	bne	r2,zero,8229ce0 <dhc_upcall+0xc0>
       (bp->op != BOOTREPLY) ||
 8229cb4:	e0bffa17 	ldw	r2,-24(fp)
 8229cb8:	10800003 	ldbu	r2,0(r2)
      return ENP_NOT_MINE;

   bp = (struct bootp *)pkt->nb_prot;

   /*   Validate various fields   */
   if ((len < (sizeof(struct bootp)-BOOTP_OPTSIZE) ) || 
 8229cbc:	10803fcc 	andi	r2,r2,255
 8229cc0:	10800098 	cmpnei	r2,r2,2
 8229cc4:	1000061e 	bne	r2,zero,8229ce0 <dhc_upcall+0xc0>
       (bp->op != BOOTREPLY) ||
       (*(u_long*)(&bp->options) != RFC1084_MAGIC_COOKIE))
 8229cc8:	e0bffa17 	ldw	r2,-24(fp)
 8229ccc:	10803b04 	addi	r2,r2,236
 8229cd0:	10c00017 	ldw	r3,0(r2)

   bp = (struct bootp *)pkt->nb_prot;

   /*   Validate various fields   */
   if ((len < (sizeof(struct bootp)-BOOTP_OPTSIZE) ) || 
       (bp->op != BOOTREPLY) ||
 8229cd4:	0098d534 	movhi	r2,25428
 8229cd8:	10a098c4 	addi	r2,r2,-32157
 8229cdc:	18800626 	beq	r3,r2,8229cf8 <dhc_upcall+0xd8>
       (*(u_long*)(&bp->options) != RFC1084_MAGIC_COOKIE))
   {
      dtrap();
 8229ce0:	822d5f00 	call	822d5f0 <dtrap>
      dsc_errors++;
 8229ce4:	d0a09017 	ldw	r2,-32192(gp)
 8229ce8:	10800044 	addi	r2,r2,1
 8229cec:	d0a09015 	stw	r2,-32192(gp)
      return ENP_NOT_MINE;
 8229cf0:	00800084 	movi	r2,2
 8229cf4:	0001b006 	br	822a3b8 <dhc_upcall+0x798>
   }

   /* punt offers or replys which are not for me */
   if(MEMCMP(bp->chaddr, pkt->net->mib.ifPhysAddress, pkt->net->n_hal))
 8229cf8:	e0bffa17 	ldw	r2,-24(fp)
 8229cfc:	10c00704 	addi	r3,r2,28
 8229d00:	e0bffd17 	ldw	r2,-12(fp)
 8229d04:	10800617 	ldw	r2,24(r2)
 8229d08:	11001717 	ldw	r4,92(r2)
 8229d0c:	e0bffd17 	ldw	r2,-12(fp)
 8229d10:	10800617 	ldw	r2,24(r2)
 8229d14:	10801117 	ldw	r2,68(r2)
 8229d18:	100d883a 	mov	r6,r2
 8229d1c:	200b883a 	mov	r5,r4
 8229d20:	1809883a 	mov	r4,r3
 8229d24:	820c6380 	call	820c638 <memcmp>
 8229d28:	10000226 	beq	r2,zero,8229d34 <dhc_upcall+0x114>
      return ENP_NOT_MINE;    /* not an error, just ignore it */
 8229d2c:	00800084 	movi	r2,2
 8229d30:	0001a106 	br	822a3b8 <dhc_upcall+0x798>

   /* see if it's full DHCP or plain bootp by looking for dhcp type option */
   opts = find_opt(DHOP_TYPE ,&bp->options[4]);
 8229d34:	e0bffa17 	ldw	r2,-24(fp)
 8229d38:	10803c04 	addi	r2,r2,240
 8229d3c:	100b883a 	mov	r5,r2
 8229d40:	01000d44 	movi	r4,53
 8229d44:	822c6ec0 	call	822c6ec <find_opt>
 8229d48:	e0bffb15 	stw	r2,-20(fp)
   if (opts && *opts == DHOP_TYPE)
 8229d4c:	e0bffb17 	ldw	r2,-20(fp)
 8229d50:	10001026 	beq	r2,zero,8229d94 <dhc_upcall+0x174>
 8229d54:	e0bffb17 	ldw	r2,-20(fp)
 8229d58:	10800003 	ldbu	r2,0(r2)
 8229d5c:	10803fcc 	andi	r2,r2,255
 8229d60:	10800d58 	cmpnei	r2,r2,53
 8229d64:	10000b1e 	bne	r2,zero,8229d94 <dhc_upcall+0x174>
   {
      dhcptype = *(opts+2);
 8229d68:	e0bffb17 	ldw	r2,-20(fp)
 8229d6c:	10800084 	addi	r2,r2,2
 8229d70:	10800003 	ldbu	r2,0(r2)
 8229d74:	10803fcc 	andi	r2,r2,255
 8229d78:	e0bff715 	stw	r2,-36(fp)
      bp->op |= ISDHCP;       /* tag packet for isdhcp() macro */
 8229d7c:	e0bffa17 	ldw	r2,-24(fp)
 8229d80:	10800003 	ldbu	r2,0(r2)
 8229d84:	10800114 	ori	r2,r2,4
 8229d88:	1007883a 	mov	r3,r2
 8229d8c:	e0bffa17 	ldw	r2,-24(fp)
 8229d90:	10c00005 	stb	r3,0(r2)
   }

   if (isdhcp(bp))
 8229d94:	e0bffa17 	ldw	r2,-24(fp)
 8229d98:	10800003 	ldbu	r2,0(r2)
 8229d9c:	10803fcc 	andi	r2,r2,255
 8229da0:	1080010c 	andi	r2,r2,4
 8229da4:	10016326 	beq	r2,zero,822a334 <dhc_upcall+0x714>
   {
      switch (dhcptype)
 8229da8:	e0bff717 	ldw	r2,-36(fp)
 8229dac:	10c00148 	cmpgei	r3,r2,5
 8229db0:	1800051e 	bne	r3,zero,8229dc8 <dhc_upcall+0x1a8>
 8229db4:	10c000c8 	cmpgei	r3,r2,3
 8229db8:	1800051e 	bne	r3,zero,8229dd0 <dhc_upcall+0x1b0>
 8229dbc:	10800060 	cmpeqi	r2,r2,1
 8229dc0:	1000031e 	bne	r2,zero,8229dd0 <dhc_upcall+0x1b0>
 8229dc4:	00000706 	br	8229de4 <dhc_upcall+0x1c4>
 8229dc8:	108001e0 	cmpeqi	r2,r2,7
 8229dcc:	10000526 	beq	r2,zero,8229de4 <dhc_upcall+0x1c4>
      {
      case DHCP_DISCOVER:
      case DHCP_REQUEST:
      case DHCP_DECLINE:
      case DHCP_RELEASE:
         dsc_errors++;     /* these should only be upcalled to a server */
 8229dd0:	d0a09017 	ldw	r2,-32192(gp)
 8229dd4:	10800044 	addi	r2,r2,1
 8229dd8:	d0a09015 	stw	r2,-32192(gp)
         return ENP_NOT_MINE;
 8229ddc:	00800084 	movi	r2,2
 8229de0:	00017506 	br	822a3b8 <dhc_upcall+0x798>
      }

      switch (dhc_states[iface].state)
 8229de4:	008209b4 	movhi	r2,2086
 8229de8:	10b86304 	addi	r2,r2,-7796
 8229dec:	e0fff917 	ldw	r3,-28(fp)
 8229df0:	18c00f24 	muli	r3,r3,60
 8229df4:	10c5883a 	add	r2,r2,r3
 8229df8:	10800017 	ldw	r2,0(r2)
 8229dfc:	10c00268 	cmpgeui	r3,r2,9
 8229e00:	1801431e 	bne	r3,zero,822a310 <dhc_upcall+0x6f0>
 8229e04:	100690ba 	slli	r3,r2,2
 8229e08:	008208f4 	movhi	r2,2083
 8229e0c:	10a78704 	addi	r2,r2,-25060
 8229e10:	1885883a 	add	r2,r3,r2
 8229e14:	10800017 	ldw	r2,0(r2)
 8229e18:	1000683a 	jmp	r2
 8229e1c:	0822a310 	cmplti	zero,at,-30068
 8229e20:	08229e40 	call	8229e4 <OSCtxSw_SWITCH_PC+0x8229a4>
 8229e24:	08229e40 	call	8229e4 <OSCtxSw_SWITCH_PC+0x8229a4>
 8229e28:	0822a074 	orhi	zero,at,35457
 8229e2c:	08229e54 	ori	zero,at,35449
 8229e30:	08229fc8 	cmpgei	zero,at,-30081
 8229e34:	08229e40 	call	8229e4 <OSCtxSw_SWITCH_PC+0x8229a4>
 8229e38:	08229fc8 	cmpgei	zero,at,-30081
 8229e3c:	08229fc8 	cmpgei	zero,at,-30081
      case DHCS_INITREBOOT:
         /* How can we receive any response when we never sent one */
      case DHCS_BOUND:
         /* If there are multiple DHCP Servers, and one of them is slow
            in responding, we might get OFFER pkts when are in BOUND state */
         dsc_errors++;     /* these should only be upcalled to a server */
 8229e40:	d0a09017 	ldw	r2,-32192(gp)
 8229e44:	10800044 	addi	r2,r2,1
 8229e48:	d0a09015 	stw	r2,-32192(gp)
         return ENP_NOT_MINE;
 8229e4c:	00800084 	movi	r2,2
 8229e50:	00015906 	br	822a3b8 <dhc_upcall+0x798>
      case DHCS_SELECTING:
         /* We will respond to the first offer packet that we receive ) */
         if ( dhcptype == DHCP_OFFER ) /* got offer back from server */
 8229e54:	e0bff717 	ldw	r2,-36(fp)
 8229e58:	10800098 	cmpnei	r2,r2,2
 8229e5c:	10004f1e 	bne	r2,zero,8229f9c <dhc_upcall+0x37c>
         {
            dsc_offers++;
 8229e60:	d0a09217 	ldw	r2,-32184(gp)
 8229e64:	10800044 	addi	r2,r2,1
 8229e68:	d0a09215 	stw	r2,-32184(gp)
            dhc_states[iface].srv_ipaddr = dhc_get_srv_ipaddr(&bp->options[4]);
 8229e6c:	e0bffa17 	ldw	r2,-24(fp)
 8229e70:	10803c04 	addi	r2,r2,240
 8229e74:	1009883a 	mov	r4,r2
 8229e78:	8229aa00 	call	8229aa0 <dhc_get_srv_ipaddr>
 8229e7c:	1009883a 	mov	r4,r2
 8229e80:	008209b4 	movhi	r2,2086
 8229e84:	10b86304 	addi	r2,r2,-7796
 8229e88:	e0fff917 	ldw	r3,-28(fp)
 8229e8c:	18c00f24 	muli	r3,r3,60
 8229e90:	10c5883a 	add	r2,r2,r3
 8229e94:	10800d04 	addi	r2,r2,52
 8229e98:	11000015 	stw	r4,0(r2)
            if (dhc_states[iface].srv_ipaddr == 0 )
 8229e9c:	008209b4 	movhi	r2,2086
 8229ea0:	10b86304 	addi	r2,r2,-7796
 8229ea4:	e0fff917 	ldw	r3,-28(fp)
 8229ea8:	18c00f24 	muli	r3,r3,60
 8229eac:	10c5883a 	add	r2,r2,r3
 8229eb0:	10800d04 	addi	r2,r2,52
 8229eb4:	10800017 	ldw	r2,0(r2)
 8229eb8:	10000d1e 	bne	r2,zero,8229ef0 <dhc_upcall+0x2d0>
            {
               dtrap(); /* didn't receive server-identifier option */
 8229ebc:	822d5f00 	call	822d5f0 <dtrap>
               dsc_errors++;
 8229ec0:	d0a09017 	ldw	r2,-32192(gp)
 8229ec4:	10800044 	addi	r2,r2,1
 8229ec8:	d0a09015 	stw	r2,-32192(gp)
               dhc_states[iface].srv_ipaddr = pkt->fhost;   /* Try using fhost */
 8229ecc:	e0bffd17 	ldw	r2,-12(fp)
 8229ed0:	10c00717 	ldw	r3,28(r2)
 8229ed4:	008209b4 	movhi	r2,2086
 8229ed8:	10b86304 	addi	r2,r2,-7796
 8229edc:	e13ff917 	ldw	r4,-28(fp)
 8229ee0:	21000f24 	muli	r4,r4,60
 8229ee4:	1105883a 	add	r2,r2,r4
 8229ee8:	10800d04 	addi	r2,r2,52
 8229eec:	10c00015 	stw	r3,0(r2)
            }

            if (bp->hops)
 8229ef0:	e0bffa17 	ldw	r2,-24(fp)
 8229ef4:	108000c3 	ldbu	r2,3(r2)
 8229ef8:	10803fcc 	andi	r2,r2,255
 8229efc:	10000a26 	beq	r2,zero,8229f28 <dhc_upcall+0x308>
            {
               /* OFFER is received via DHCP Relay Agent. Remember the
                * IP addr of DHCP Relay Agent, so that packets from other
                * DHCP Relay Agents can be discarded 
                */
               dhc_states[iface].rly_ipaddr = pkt->fhost;   /* Try using fhost */
 8229f00:	e0bffd17 	ldw	r2,-12(fp)
 8229f04:	10c00717 	ldw	r3,28(r2)
 8229f08:	008209b4 	movhi	r2,2086
 8229f0c:	10b86304 	addi	r2,r2,-7796
 8229f10:	e13ff917 	ldw	r4,-28(fp)
 8229f14:	21000f24 	muli	r4,r4,60
 8229f18:	1105883a 	add	r2,r2,r4
 8229f1c:	10800c04 	addi	r2,r2,48
 8229f20:	10c00015 	stw	r3,0(r2)
 8229f24:	00000706 	br	8229f44 <dhc_upcall+0x324>
            }
            else
               dhc_states[iface].rly_ipaddr = 0;
 8229f28:	008209b4 	movhi	r2,2086
 8229f2c:	10b86304 	addi	r2,r2,-7796
 8229f30:	e0fff917 	ldw	r3,-28(fp)
 8229f34:	18c00f24 	muli	r3,r3,60
 8229f38:	10c5883a 	add	r2,r2,r3
 8229f3c:	10800c04 	addi	r2,r2,48
 8229f40:	10000015 	stw	zero,0(r2)

            e = dhc_rx_offer(iface,bp,pkt->nb_plen);     /* send request */
 8229f44:	e0bffd17 	ldw	r2,-12(fp)
 8229f48:	10800417 	ldw	r2,16(r2)
 8229f4c:	100d883a 	mov	r6,r2
 8229f50:	e17ffa17 	ldw	r5,-24(fp)
 8229f54:	e13ff917 	ldw	r4,-28(fp)
 8229f58:	822aa800 	call	822aa80 <dhc_rx_offer>
 8229f5c:	e0bffc15 	stw	r2,-16(fp)
            if (e)
 8229f60:	e0bffc17 	ldw	r2,-16(fp)
 8229f64:	10000926 	beq	r2,zero,8229f8c <dhc_upcall+0x36c>
            {
               dsc_errors++;
 8229f68:	d0a09017 	ldw	r2,-32192(gp)
 8229f6c:	10800044 	addi	r2,r2,1
 8229f70:	d0a09015 	stw	r2,-32192(gp)
               dhc_set_state(iface,DHCS_INIT);
 8229f74:	01400044 	movi	r5,1
 8229f78:	e13ff917 	ldw	r4,-28(fp)
 8229f7c:	822c63c0 	call	822c63c <dhc_set_state>
               dtrap();
 8229f80:	822d5f00 	call	822d5f0 <dtrap>
               return ENP_NOT_MINE;
 8229f84:	00800084 	movi	r2,2
 8229f88:	00010b06 	br	822a3b8 <dhc_upcall+0x798>
            }
            else
               dhc_set_state(iface,DHCS_REQUESTING);
 8229f8c:	01400144 	movi	r5,5
 8229f90:	e13ff917 	ldw	r4,-28(fp)
 8229f94:	822c63c0 	call	822c63c <dhc_set_state>
            dsc_errors++;
            if ( dhcptype == DHCP_NAK ) 
               dsc_naks++;
            return ENP_NOT_MINE;
         }
         break;
 8229f98:	00010406 	br	822a3ac <dhc_upcall+0x78c>
             * Report an error and remain in SELECTING state, so that 
             * an OFFER packet from another DHCP server can be 
             * accepted. If we timeout waiting for a OFFER packet, 
             * then dhc_second() will transition to DHCS_INIT state. 
             */
            dsc_errors++;
 8229f9c:	d0a09017 	ldw	r2,-32192(gp)
 8229fa0:	10800044 	addi	r2,r2,1
 8229fa4:	d0a09015 	stw	r2,-32192(gp)
            if ( dhcptype == DHCP_NAK ) 
 8229fa8:	e0bff717 	ldw	r2,-36(fp)
 8229fac:	10800198 	cmpnei	r2,r2,6
 8229fb0:	1000031e 	bne	r2,zero,8229fc0 <dhc_upcall+0x3a0>
               dsc_naks++;
 8229fb4:	d0a09817 	ldw	r2,-32160(gp)
 8229fb8:	10800044 	addi	r2,r2,1
 8229fbc:	d0a09815 	stw	r2,-32160(gp)
            return ENP_NOT_MINE;
 8229fc0:	00800084 	movi	r2,2
 8229fc4:	0000fc06 	br	822a3b8 <dhc_upcall+0x798>
      case DHCS_RENEWING:
         /* If the ACK/NACK is not from the same server which sent 
          * the OFFER packet, then discard it. in DHCS_REBOOTING 
          * state, srv_ipaddr is 0. Hence don't check in that state 
          */
         if ( dhc_states[iface].srv_ipaddr != 
 8229fc8:	008209b4 	movhi	r2,2086
 8229fcc:	10b86304 	addi	r2,r2,-7796
 8229fd0:	e0fff917 	ldw	r3,-28(fp)
 8229fd4:	18c00f24 	muli	r3,r3,60
 8229fd8:	10c5883a 	add	r2,r2,r3
 8229fdc:	10800d04 	addi	r2,r2,52
 8229fe0:	14000017 	ldw	r16,0(r2)
             dhc_get_srv_ipaddr(&bp->options[4]) )
 8229fe4:	e0bffa17 	ldw	r2,-24(fp)
 8229fe8:	10803c04 	addi	r2,r2,240
 8229fec:	1009883a 	mov	r4,r2
 8229ff0:	8229aa00 	call	8229aa0 <dhc_get_srv_ipaddr>
      case DHCS_RENEWING:
         /* If the ACK/NACK is not from the same server which sent 
          * the OFFER packet, then discard it. in DHCS_REBOOTING 
          * state, srv_ipaddr is 0. Hence don't check in that state 
          */
         if ( dhc_states[iface].srv_ipaddr != 
 8229ff4:	80800526 	beq	r16,r2,822a00c <dhc_upcall+0x3ec>
             dhc_get_srv_ipaddr(&bp->options[4]) )
         {
            dsc_errors++;
 8229ff8:	d0a09017 	ldw	r2,-32192(gp)
 8229ffc:	10800044 	addi	r2,r2,1
 822a000:	d0a09015 	stw	r2,-32192(gp)
            return ENP_NOT_MINE;
 822a004:	00800084 	movi	r2,2
 822a008:	0000eb06 	br	822a3b8 <dhc_upcall+0x798>
         }
         if (dhc_states[iface].rly_ipaddr &&
 822a00c:	008209b4 	movhi	r2,2086
 822a010:	10b86304 	addi	r2,r2,-7796
 822a014:	e0fff917 	ldw	r3,-28(fp)
 822a018:	18c00f24 	muli	r3,r3,60
 822a01c:	10c5883a 	add	r2,r2,r3
 822a020:	10800c04 	addi	r2,r2,48
 822a024:	10800017 	ldw	r2,0(r2)
 822a028:	10001226 	beq	r2,zero,822a074 <dhc_upcall+0x454>
            (dhc_states[iface].rly_ipaddr != pkt->fhost))
 822a02c:	008209b4 	movhi	r2,2086
 822a030:	10b86304 	addi	r2,r2,-7796
 822a034:	e0fff917 	ldw	r3,-28(fp)
 822a038:	18c00f24 	muli	r3,r3,60
 822a03c:	10c5883a 	add	r2,r2,r3
 822a040:	10800c04 	addi	r2,r2,48
 822a044:	10c00017 	ldw	r3,0(r2)
 822a048:	e0bffd17 	ldw	r2,-12(fp)
 822a04c:	10800717 	ldw	r2,28(r2)
             dhc_get_srv_ipaddr(&bp->options[4]) )
         {
            dsc_errors++;
            return ENP_NOT_MINE;
         }
         if (dhc_states[iface].rly_ipaddr &&
 822a050:	18800826 	beq	r3,r2,822a074 <dhc_upcall+0x454>
            (dhc_states[iface].rly_ipaddr != pkt->fhost))
         {
            dsc_rlyerrs++;
 822a054:	d0a09b17 	ldw	r2,-32148(gp)
 822a058:	10800044 	addi	r2,r2,1
 822a05c:	d0a09b15 	stw	r2,-32148(gp)
            dsc_errors++;
 822a060:	d0a09017 	ldw	r2,-32192(gp)
 822a064:	10800044 	addi	r2,r2,1
 822a068:	d0a09015 	stw	r2,-32192(gp)
            return ENP_NOT_MINE;
 822a06c:	00800084 	movi	r2,2
 822a070:	0000d106 	br	822a3b8 <dhc_upcall+0x798>
         }
      case DHCS_REBOOTING:
         if ( dhcptype == DHCP_ACK )   /* Server OKed our request */
 822a074:	e0bff717 	ldw	r2,-36(fp)
 822a078:	10800158 	cmpnei	r2,r2,5
 822a07c:	1000851e 	bne	r2,zero,822a294 <dhc_upcall+0x674>
         {
            dsc_acks++;
 822a080:	d0a09417 	ldw	r2,-32176(gp)
 822a084:	10800044 	addi	r2,r2,1
 822a088:	d0a09415 	stw	r2,-32176(gp)
            dhc_extract_opts(iface,&bp->options[4]);
 822a08c:	e0bffa17 	ldw	r2,-24(fp)
 822a090:	10803c04 	addi	r2,r2,240
 822a094:	100b883a 	mov	r5,r2
 822a098:	e13ff917 	ldw	r4,-28(fp)
 822a09c:	822bafc0 	call	822bafc <dhc_extract_opts>
            if ( dhc_states[iface].lease == DHC_INFINITY )
 822a0a0:	008209b4 	movhi	r2,2086
 822a0a4:	10b86304 	addi	r2,r2,-7796
 822a0a8:	e0fff917 	ldw	r3,-28(fp)
 822a0ac:	18c00f24 	muli	r3,r3,60
 822a0b0:	10c5883a 	add	r2,r2,r3
 822a0b4:	10800504 	addi	r2,r2,20
 822a0b8:	10800017 	ldw	r2,0(r2)
 822a0bc:	10bfffd8 	cmpnei	r2,r2,-1
 822a0c0:	1000111e 	bne	r2,zero,822a108 <dhc_upcall+0x4e8>
            {
               dhc_states[iface].t1 = DHC_INFINITY ;
 822a0c4:	008209b4 	movhi	r2,2086
 822a0c8:	10b86304 	addi	r2,r2,-7796
 822a0cc:	e0fff917 	ldw	r3,-28(fp)
 822a0d0:	18c00f24 	muli	r3,r3,60
 822a0d4:	10c5883a 	add	r2,r2,r3
 822a0d8:	10800604 	addi	r2,r2,24
 822a0dc:	00ffffc4 	movi	r3,-1
 822a0e0:	10c00015 	stw	r3,0(r2)
               dhc_states[iface].t2 = DHC_INFINITY ;
 822a0e4:	008209b4 	movhi	r2,2086
 822a0e8:	10b86304 	addi	r2,r2,-7796
 822a0ec:	e0fff917 	ldw	r3,-28(fp)
 822a0f0:	18c00f24 	muli	r3,r3,60
 822a0f4:	10c5883a 	add	r2,r2,r3
 822a0f8:	10800704 	addi	r2,r2,28
 822a0fc:	00ffffc4 	movi	r3,-1
 822a100:	10c00015 	stw	r3,0(r2)
 822a104:	00001f06 	br	822a184 <dhc_upcall+0x564>
            }
            else
            {
               dhc_states[iface].t1 = dhc_states[iface].lease/2     ;
 822a108:	008209b4 	movhi	r2,2086
 822a10c:	10b86304 	addi	r2,r2,-7796
 822a110:	e0fff917 	ldw	r3,-28(fp)
 822a114:	18c00f24 	muli	r3,r3,60
 822a118:	10c5883a 	add	r2,r2,r3
 822a11c:	10800504 	addi	r2,r2,20
 822a120:	10800017 	ldw	r2,0(r2)
 822a124:	1006d07a 	srli	r3,r2,1
 822a128:	008209b4 	movhi	r2,2086
 822a12c:	10b86304 	addi	r2,r2,-7796
 822a130:	e13ff917 	ldw	r4,-28(fp)
 822a134:	21000f24 	muli	r4,r4,60
 822a138:	1105883a 	add	r2,r2,r4
 822a13c:	10800604 	addi	r2,r2,24
 822a140:	10c00015 	stw	r3,0(r2)
               dhc_states[iface].t2 = (dhc_states[iface].lease/8)*7 ;
 822a144:	008209b4 	movhi	r2,2086
 822a148:	10b86304 	addi	r2,r2,-7796
 822a14c:	e0fff917 	ldw	r3,-28(fp)
 822a150:	18c00f24 	muli	r3,r3,60
 822a154:	10c5883a 	add	r2,r2,r3
 822a158:	10800504 	addi	r2,r2,20
 822a15c:	10800017 	ldw	r2,0(r2)
 822a160:	1004d0fa 	srli	r2,r2,3
 822a164:	10c001e4 	muli	r3,r2,7
 822a168:	008209b4 	movhi	r2,2086
 822a16c:	10b86304 	addi	r2,r2,-7796
 822a170:	e13ff917 	ldw	r4,-28(fp)
 822a174:	21000f24 	muli	r4,r4,60
 822a178:	1105883a 	add	r2,r2,r4
 822a17c:	10800704 	addi	r2,r2,28
 822a180:	10c00015 	stw	r3,0(r2)
            }
            dhc_states[iface].lease_start = cticks;   /* to calc lease expiry */
 822a184:	d0e0a817 	ldw	r3,-32096(gp)
 822a188:	008209b4 	movhi	r2,2086
 822a18c:	10b86304 	addi	r2,r2,-7796
 822a190:	e13ff917 	ldw	r4,-28(fp)
 822a194:	21000f24 	muli	r4,r4,60
 822a198:	1105883a 	add	r2,r2,r4
 822a19c:	10800804 	addi	r2,r2,32
 822a1a0:	10c00015 	stw	r3,0(r2)
            dhc_states[iface].srv_ipaddr = dhc_get_srv_ipaddr(&bp->options[4]); 
 822a1a4:	e0bffa17 	ldw	r2,-24(fp)
 822a1a8:	10803c04 	addi	r2,r2,240
 822a1ac:	1009883a 	mov	r4,r2
 822a1b0:	8229aa00 	call	8229aa0 <dhc_get_srv_ipaddr>
 822a1b4:	1009883a 	mov	r4,r2
 822a1b8:	008209b4 	movhi	r2,2086
 822a1bc:	10b86304 	addi	r2,r2,-7796
 822a1c0:	e0fff917 	ldw	r3,-28(fp)
 822a1c4:	18c00f24 	muli	r3,r3,60
 822a1c8:	10c5883a 	add	r2,r2,r3
 822a1cc:	10800d04 	addi	r2,r2,52
 822a1d0:	11000015 	stw	r4,0(r2)
            if (dhc_states[iface].srv_ipaddr == 0 )
 822a1d4:	008209b4 	movhi	r2,2086
 822a1d8:	10b86304 	addi	r2,r2,-7796
 822a1dc:	e0fff917 	ldw	r3,-28(fp)
 822a1e0:	18c00f24 	muli	r3,r3,60
 822a1e4:	10c5883a 	add	r2,r2,r3
 822a1e8:	10800d04 	addi	r2,r2,52
 822a1ec:	10800017 	ldw	r2,0(r2)
 822a1f0:	10000d1e 	bne	r2,zero,822a228 <dhc_upcall+0x608>
            {
               dtrap(); /* didn't receive server-identifier option */
 822a1f4:	822d5f00 	call	822d5f0 <dtrap>
               dsc_errors++;
 822a1f8:	d0a09017 	ldw	r2,-32192(gp)
 822a1fc:	10800044 	addi	r2,r2,1
 822a200:	d0a09015 	stw	r2,-32192(gp)
               dhc_states[iface].srv_ipaddr = pkt->fhost;   /* Try using fhost */
 822a204:	e0bffd17 	ldw	r2,-12(fp)
 822a208:	10c00717 	ldw	r3,28(r2)
 822a20c:	008209b4 	movhi	r2,2086
 822a210:	10b86304 	addi	r2,r2,-7796
 822a214:	e13ff917 	ldw	r4,-28(fp)
 822a218:	21000f24 	muli	r4,r4,60
 822a21c:	1105883a 	add	r2,r2,r4
 822a220:	10800d04 	addi	r2,r2,52
 822a224:	10c00015 	stw	r3,0(r2)
            }
            if (bp->hops)
 822a228:	e0bffa17 	ldw	r2,-24(fp)
 822a22c:	108000c3 	ldbu	r2,3(r2)
 822a230:	10803fcc 	andi	r2,r2,255
 822a234:	10000a26 	beq	r2,zero,822a260 <dhc_upcall+0x640>
            {
               /* OFFER is received via DHCP Relay Agent. Remember the
                * IP addr of DHCP Relay Agent, so that packets from other
                * DHCP Relay Agents can be discarded 
                */
               dhc_states[iface].rly_ipaddr = pkt->fhost;   /* Try using fhost */
 822a238:	e0bffd17 	ldw	r2,-12(fp)
 822a23c:	10c00717 	ldw	r3,28(r2)
 822a240:	008209b4 	movhi	r2,2086
 822a244:	10b86304 	addi	r2,r2,-7796
 822a248:	e13ff917 	ldw	r4,-28(fp)
 822a24c:	21000f24 	muli	r4,r4,60
 822a250:	1105883a 	add	r2,r2,r4
 822a254:	10800c04 	addi	r2,r2,48
 822a258:	10c00015 	stw	r3,0(r2)
 822a25c:	00000706 	br	822a27c <dhc_upcall+0x65c>
            }
            else
               dhc_states[iface].rly_ipaddr = 0;
 822a260:	008209b4 	movhi	r2,2086
 822a264:	10b86304 	addi	r2,r2,-7796
 822a268:	e0fff917 	ldw	r3,-28(fp)
 822a26c:	18c00f24 	muli	r3,r3,60
 822a270:	10c5883a 	add	r2,r2,r3
 822a274:	10800c04 	addi	r2,r2,48
 822a278:	10000015 	stw	zero,0(r2)

            dhc_setip(iface);
 822a27c:	e13ff917 	ldw	r4,-28(fp)
 822a280:	822b5e80 	call	822b5e8 <dhc_setip>
            dhc_set_state(iface,DHCS_BOUND);
 822a284:	01400184 	movi	r5,6
 822a288:	e13ff917 	ldw	r4,-28(fp)
 822a28c:	822c63c0 	call	822c63c <dhc_set_state>
             * error and discard it with no change to our state.
             */
            dsc_errors++;
            return ENP_NOT_MINE;
         }
         break;
 822a290:	00004606 	br	822a3ac <dhc_upcall+0x78c>
               dhc_states[iface].rly_ipaddr = 0;

            dhc_setip(iface);
            dhc_set_state(iface,DHCS_BOUND);
         }
         else if ( dhcptype == DHCP_NAK ) /* Server denied our request */
 822a294:	e0bff717 	ldw	r2,-36(fp)
 822a298:	10800198 	cmpnei	r2,r2,6
 822a29c:	1000071e 	bne	r2,zero,822a2bc <dhc_upcall+0x69c>
         {
            dhc_set_state(iface,DHCS_INIT);
 822a2a0:	01400044 	movi	r5,1
 822a2a4:	e13ff917 	ldw	r4,-28(fp)
 822a2a8:	822c63c0 	call	822c63c <dhc_set_state>
            dsc_naks++;
 822a2ac:	d0a09817 	ldw	r2,-32160(gp)
 822a2b0:	10800044 	addi	r2,r2,1
 822a2b4:	d0a09815 	stw	r2,-32160(gp)
             * error and discard it with no change to our state.
             */
            dsc_errors++;
            return ENP_NOT_MINE;
         }
         break;
 822a2b8:	00003c06 	br	822a3ac <dhc_upcall+0x78c>
         {
            /* In REQUESTING state, we might receive a retransmitted
             * OFFER, which we should discard, but it's not an error,
             * so we log it.
             */
            if ((dhc_states[iface].state == DHCS_REQUESTING) &&
 822a2bc:	008209b4 	movhi	r2,2086
 822a2c0:	10b86304 	addi	r2,r2,-7796
 822a2c4:	e0fff917 	ldw	r3,-28(fp)
 822a2c8:	18c00f24 	muli	r3,r3,60
 822a2cc:	10c5883a 	add	r2,r2,r3
 822a2d0:	10800017 	ldw	r2,0(r2)
 822a2d4:	10800158 	cmpnei	r2,r2,5
 822a2d8:	1000081e 	bne	r2,zero,822a2fc <dhc_upcall+0x6dc>
 822a2dc:	e0bff717 	ldw	r2,-36(fp)
 822a2e0:	10800098 	cmpnei	r2,r2,2
 822a2e4:	1000051e 	bne	r2,zero,822a2fc <dhc_upcall+0x6dc>
                (dhcptype == DHCP_OFFER))
            {
               dsc_offers++;
 822a2e8:	d0a09217 	ldw	r2,-32184(gp)
 822a2ec:	10800044 	addi	r2,r2,1
 822a2f0:	d0a09215 	stw	r2,-32184(gp)
               return ENP_NOT_MINE;
 822a2f4:	00800084 	movi	r2,2
 822a2f8:	00002f06 	br	822a3b8 <dhc_upcall+0x798>
             * only receive ACK or NAK, and in REQUESTING state we
             * should only receive ACK or NAK or OFFER; these are
             * accounted for above, so we log whatever this is as an
             * error and discard it with no change to our state.
             */
            dsc_errors++;
 822a2fc:	d0a09017 	ldw	r2,-32192(gp)
 822a300:	10800044 	addi	r2,r2,1
 822a304:	d0a09015 	stw	r2,-32192(gp)
            return ENP_NOT_MINE;
 822a308:	00800084 	movi	r2,2
 822a30c:	00002a06 	br	822a3b8 <dhc_upcall+0x798>
         }
         break;
      default:    /* bad state */
         dtrap();
 822a310:	822d5f00 	call	822d5f0 <dtrap>
         dhc_set_state(iface,DHCS_INIT);
 822a314:	01400044 	movi	r5,1
 822a318:	e13ff917 	ldw	r4,-28(fp)
 822a31c:	822c63c0 	call	822c63c <dhc_set_state>
         dsc_errors++;
 822a320:	d0a09017 	ldw	r2,-32192(gp)
 822a324:	10800044 	addi	r2,r2,1
 822a328:	d0a09015 	stw	r2,-32192(gp)
         return -1;
 822a32c:	00bfffc4 	movi	r2,-1
 822a330:	00002106 	br	822a3b8 <dhc_upcall+0x798>
      }
   }
   else     /* plain bootp reply */
   {
      dsc_bpreplys++;
 822a334:	d0a09517 	ldw	r2,-32172(gp)
 822a338:	10800044 	addi	r2,r2,1
 822a33c:	d0a09515 	stw	r2,-32172(gp)
      dhc_extract_opts(iface,&bp->options[4]);
 822a340:	e0bffa17 	ldw	r2,-24(fp)
 822a344:	10803c04 	addi	r2,r2,240
 822a348:	100b883a 	mov	r5,r2
 822a34c:	e13ff917 	ldw	r4,-28(fp)
 822a350:	822bafc0 	call	822bafc <dhc_extract_opts>
      dhc_states[iface].ipaddr = bp->yiaddr;
 822a354:	e0bffa17 	ldw	r2,-24(fp)
 822a358:	10c00417 	ldw	r3,16(r2)
 822a35c:	008209b4 	movhi	r2,2086
 822a360:	10b86304 	addi	r2,r2,-7796
 822a364:	e13ff917 	ldw	r4,-28(fp)
 822a368:	21000f24 	muli	r4,r4,60
 822a36c:	1105883a 	add	r2,r2,r4
 822a370:	10800904 	addi	r2,r2,36
 822a374:	10c00015 	stw	r3,0(r2)
      dhc_setip(iface);
 822a378:	e13ff917 	ldw	r4,-28(fp)
 822a37c:	822b5e80 	call	822b5e8 <dhc_setip>

      /* Set values so that DHCP State Machine remains happy */
      dhc_set_state(iface,DHCS_BOUND);
 822a380:	01400184 	movi	r5,6
 822a384:	e13ff917 	ldw	r4,-28(fp)
 822a388:	822c63c0 	call	822c63c <dhc_set_state>
      dhc_states[iface].t1    = DHC_INFINITY ;
 822a38c:	008209b4 	movhi	r2,2086
 822a390:	10b86304 	addi	r2,r2,-7796
 822a394:	e0fff917 	ldw	r3,-28(fp)
 822a398:	18c00f24 	muli	r3,r3,60
 822a39c:	10c5883a 	add	r2,r2,r3
 822a3a0:	10800604 	addi	r2,r2,24
 822a3a4:	00ffffc4 	movi	r3,-1
 822a3a8:	10c00015 	stw	r3,0(r2)
   }

   udp_free(pkt);
 822a3ac:	e13ffd17 	ldw	r4,-12(fp)
 822a3b0:	82455240 	call	8245524 <udp_free>
   return 0;
 822a3b4:	0005883a 	mov	r2,zero
}
 822a3b8:	e6ffff04 	addi	sp,fp,-4
 822a3bc:	dfc00217 	ldw	ra,8(sp)
 822a3c0:	df000117 	ldw	fp,4(sp)
 822a3c4:	dc000017 	ldw	r16,0(sp)
 822a3c8:	dec00304 	addi	sp,sp,12
 822a3cc:	f800283a 	ret

0822a3d0 <dhc_buildheader>:
 * RETURNS: Returns 0 on success, else an ENP_ error code. 
 */

int
dhc_buildheader(int iface, struct bootp * outbp)
{
 822a3d0:	defffb04 	addi	sp,sp,-20
 822a3d4:	dfc00415 	stw	ra,16(sp)
 822a3d8:	df000315 	stw	fp,12(sp)
 822a3dc:	df000304 	addi	fp,sp,12
 822a3e0:	e13ffe15 	stw	r4,-8(fp)
 822a3e4:	e17fff15 	stw	r5,-4(fp)
   int   addrlen;    /* length of hardware address */

   MEMSET(outbp, 0, sizeof(struct bootp));   /* most of this is 0 anyway */
 822a3e8:	01804b04 	movi	r6,300
 822a3ec:	000b883a 	mov	r5,zero
 822a3f0:	e13fff17 	ldw	r4,-4(fp)
 822a3f4:	82032100 	call	8203210 <memset>
   outbp->op = BOOTREQUEST;
 822a3f8:	e0bfff17 	ldw	r2,-4(fp)
 822a3fc:	00c00044 	movi	r3,1
 822a400:	10c00005 	stb	r3,0(r2)

   /* map SNMPish hardware types into bootp types */
   switch (nets[iface]->n_mib->ifType)
 822a404:	008209b4 	movhi	r2,2086
 822a408:	10b83d04 	addi	r2,r2,-7948
 822a40c:	e0fffe17 	ldw	r3,-8(fp)
 822a410:	18c7883a 	add	r3,r3,r3
 822a414:	18c7883a 	add	r3,r3,r3
 822a418:	10c5883a 	add	r2,r2,r3
 822a41c:	10800017 	ldw	r2,0(r2)
 822a420:	10802717 	ldw	r2,156(r2)
 822a424:	10800217 	ldw	r2,8(r2)
 822a428:	10c005e0 	cmpeqi	r3,r2,23
 822a42c:	1800081e 	bne	r3,zero,822a450 <dhc_buildheader+0x80>
 822a430:	10c00720 	cmpeqi	r3,r2,28
 822a434:	1800061e 	bne	r3,zero,822a450 <dhc_buildheader+0x80>
 822a438:	108001a0 	cmpeqi	r2,r2,6
 822a43c:	10000826 	beq	r2,zero,822a460 <dhc_buildheader+0x90>
   {
   case ETHERNET:       /* ETHERNET defined in net.h */
      outbp->htype = ETHHWTYPE;  /* defined in dhcp.h */
 822a440:	e0bfff17 	ldw	r2,-4(fp)
 822a444:	00c00044 	movi	r3,1
 822a448:	10c00045 	stb	r3,1(r2)
   break;
 822a44c:	00000706 	br	822a46c <dhc_buildheader+0x9c>
   case PPP:
   case SLIP:
      outbp->htype = LINEHWTYPE;    /* line type for PPP or SLIP */
 822a450:	e0bfff17 	ldw	r2,-4(fp)
 822a454:	00c00504 	movi	r3,20
 822a458:	10c00045 	stb	r3,1(r2)
   break;
 822a45c:	00000306 	br	822a46c <dhc_buildheader+0x9c>
      default:
      dtrap();
 822a460:	822d5f00 	call	822d5f0 <dtrap>
      return ENP_LOGIC;             /* this shouldn't happen */
 822a464:	00bffd44 	movi	r2,-11
 822a468:	00004d06 	br	822a5a0 <dhc_buildheader+0x1d0>
   }

   addrlen = min(16, nets[iface]->n_hal);
 822a46c:	008209b4 	movhi	r2,2086
 822a470:	10b83d04 	addi	r2,r2,-7948
 822a474:	e0fffe17 	ldw	r3,-8(fp)
 822a478:	18c7883a 	add	r3,r3,r3
 822a47c:	18c7883a 	add	r3,r3,r3
 822a480:	10c5883a 	add	r2,r2,r3
 822a484:	10800017 	ldw	r2,0(r2)
 822a488:	10801117 	ldw	r2,68(r2)
 822a48c:	10c00470 	cmpltui	r3,r2,17
 822a490:	1800011e 	bne	r3,zero,822a498 <dhc_buildheader+0xc8>
 822a494:	00800404 	movi	r2,16
 822a498:	e0bffd15 	stw	r2,-12(fp)
   outbp->hlen = (u_char)addrlen;
 822a49c:	e0bffd17 	ldw	r2,-12(fp)
 822a4a0:	1007883a 	mov	r3,r2
 822a4a4:	e0bfff17 	ldw	r2,-4(fp)
 822a4a8:	10c00085 	stb	r3,2(r2)
   outbp->hops = 0;
 822a4ac:	e0bfff17 	ldw	r2,-4(fp)
 822a4b0:	100000c5 	stb	zero,3(r2)
   if(dhc_states[iface].state == DHCS_RENEWING) 
 822a4b4:	008209b4 	movhi	r2,2086
 822a4b8:	10b86304 	addi	r2,r2,-7796
 822a4bc:	e0fffe17 	ldw	r3,-8(fp)
 822a4c0:	18c00f24 	muli	r3,r3,60
 822a4c4:	10c5883a 	add	r2,r2,r3
 822a4c8:	10800017 	ldw	r2,0(r2)
 822a4cc:	108001d8 	cmpnei	r2,r2,7
 822a4d0:	1000031e 	bne	r2,zero,822a4e0 <dhc_buildheader+0x110>
      outbp->flags = 0; /* Renewing needs unicast */
 822a4d4:	e0bfff17 	ldw	r2,-4(fp)
 822a4d8:	1000028d 	sth	zero,10(r2)
 822a4dc:	00000306 	br	822a4ec <dhc_buildheader+0x11c>
   else
      outbp->flags = htons(DHC_BCASTFLAG); /* Othwise broadcast */
 822a4e0:	e0bfff17 	ldw	r2,-4(fp)
 822a4e4:	00c02004 	movi	r3,128
 822a4e8:	10c0028d 	sth	r3,10(r2)
   outbp->xid = dhc_states[iface].xid;
 822a4ec:	008209b4 	movhi	r2,2086
 822a4f0:	10b86304 	addi	r2,r2,-7796
 822a4f4:	e0fffe17 	ldw	r3,-8(fp)
 822a4f8:	18c00f24 	muli	r3,r3,60
 822a4fc:	10c5883a 	add	r2,r2,r3
 822a500:	10800204 	addi	r2,r2,8
 822a504:	10c00017 	ldw	r3,0(r2)
 822a508:	e0bfff17 	ldw	r2,-4(fp)
 822a50c:	10c00115 	stw	r3,4(r2)
   outbp->secs = dhc_states[iface].secs;
 822a510:	008209b4 	movhi	r2,2086
 822a514:	10b86304 	addi	r2,r2,-7796
 822a518:	e0fffe17 	ldw	r3,-8(fp)
 822a51c:	18c00f24 	muli	r3,r3,60
 822a520:	10c5883a 	add	r2,r2,r3
 822a524:	10800304 	addi	r2,r2,12
 822a528:	10c0000b 	ldhu	r3,0(r2)
 822a52c:	e0bfff17 	ldw	r2,-4(fp)
 822a530:	10c0020d 	sth	r3,8(r2)
#ifdef NPDEBUG
   /* make sure net[] has a MAC address, even if length is zero */
   if(nets[iface]->mib.ifPhysAddress == NULL)
 822a534:	008209b4 	movhi	r2,2086
 822a538:	10b83d04 	addi	r2,r2,-7948
 822a53c:	e0fffe17 	ldw	r3,-8(fp)
 822a540:	18c7883a 	add	r3,r3,r3
 822a544:	18c7883a 	add	r3,r3,r3
 822a548:	10c5883a 	add	r2,r2,r3
 822a54c:	10800017 	ldw	r2,0(r2)
 822a550:	10801717 	ldw	r2,92(r2)
 822a554:	1000031e 	bne	r2,zero,822a564 <dhc_buildheader+0x194>
   {
      dtrap();
 822a558:	822d5f00 	call	822d5f0 <dtrap>
      return ENP_LOGIC;
 822a55c:	00bffd44 	movi	r2,-11
 822a560:	00000f06 	br	822a5a0 <dhc_buildheader+0x1d0>
   }
#endif
   MEMCPY(outbp->chaddr, nets[iface]->mib.ifPhysAddress, addrlen);
 822a564:	e0bfff17 	ldw	r2,-4(fp)
 822a568:	11000704 	addi	r4,r2,28
 822a56c:	008209b4 	movhi	r2,2086
 822a570:	10b83d04 	addi	r2,r2,-7948
 822a574:	e0fffe17 	ldw	r3,-8(fp)
 822a578:	18c7883a 	add	r3,r3,r3
 822a57c:	18c7883a 	add	r3,r3,r3
 822a580:	10c5883a 	add	r2,r2,r3
 822a584:	10800017 	ldw	r2,0(r2)
 822a588:	10801717 	ldw	r2,92(r2)
 822a58c:	e0fffd17 	ldw	r3,-12(fp)
 822a590:	180d883a 	mov	r6,r3
 822a594:	100b883a 	mov	r5,r2
 822a598:	8202f6c0 	call	8202f6c <memcpy>

   /* return success */
   return 0;
 822a59c:	0005883a 	mov	r2,zero
}
 822a5a0:	e037883a 	mov	sp,fp
 822a5a4:	dfc00117 	ldw	ra,4(sp)
 822a5a8:	df000017 	ldw	fp,0(sp)
 822a5ac:	dec00204 	addi	sp,sp,8
 822a5b0:	f800283a 	ret

0822a5b4 <dhc_discover>:
 * RETURNS: Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_discover(int iface)
{
 822a5b4:	defff404 	addi	sp,sp,-48
 822a5b8:	dfc00b15 	stw	ra,44(sp)
 822a5bc:	df000a15 	stw	fp,40(sp)
 822a5c0:	dc400915 	stw	r17,36(sp)
 822a5c4:	dc000815 	stw	r16,32(sp)
 822a5c8:	df000a04 	addi	fp,sp,40
 822a5cc:	e13ffd15 	stw	r4,-12(fp)
   u_char * opts;       /* scratch pointer to DHCP options field */
   long     leasetime;
   int      e;

   /* get a UDP packet buffer for DHCP sending */
   pkt = udp_alloc(sizeof(struct bootp), 0);
 822a5d0:	000b883a 	mov	r5,zero
 822a5d4:	01004b04 	movi	r4,300
 822a5d8:	82454440 	call	8245444 <udp_alloc>
 822a5dc:	e0bff815 	stw	r2,-32(fp)
   if (!pkt) 
 822a5e0:	e0bff817 	ldw	r2,-32(fp)
 822a5e4:	1000021e 	bne	r2,zero,822a5f0 <dhc_discover+0x3c>
      return ENP_NOMEM;
 822a5e8:	00bffb04 	movi	r2,-20
 822a5ec:	00011d06 	br	822aa64 <dhc_discover+0x4b0>
   pkt->nb_plen = sizeof(struct bootp);
 822a5f0:	e0bff817 	ldw	r2,-32(fp)
 822a5f4:	00c04b04 	movi	r3,300
 822a5f8:	10c00415 	stw	r3,16(r2)

   /* start a new DHCP transaction */
   dhc_states[iface].xid = xids++;
 822a5fc:	d0a03317 	ldw	r2,-32564(gp)
 822a600:	10c00044 	addi	r3,r2,1
 822a604:	d0e03315 	stw	r3,-32564(gp)
 822a608:	1009883a 	mov	r4,r2
 822a60c:	008209b4 	movhi	r2,2086
 822a610:	10b86304 	addi	r2,r2,-7796
 822a614:	e0fffd17 	ldw	r3,-12(fp)
 822a618:	18c00f24 	muli	r3,r3,60
 822a61c:	10c5883a 	add	r2,r2,r3
 822a620:	10800204 	addi	r2,r2,8
 822a624:	11000015 	stw	r4,0(r2)
   dhc_states[iface].secs = (unsigned short)(sysuptime()/100L);
 822a628:	823d3600 	call	823d360 <sysuptime>
 822a62c:	1007883a 	mov	r3,r2
 822a630:	00947b34 	movhi	r2,20972
 822a634:	10a147c4 	addi	r2,r2,-31457
 822a638:	1888383a 	mulxuu	r4,r3,r2
 822a63c:	1885383a 	mul	r2,r3,r2
 822a640:	1021883a 	mov	r16,r2
 822a644:	2023883a 	mov	r17,r4
 822a648:	8804d17a 	srli	r2,r17,5
 822a64c:	1009883a 	mov	r4,r2
 822a650:	008209b4 	movhi	r2,2086
 822a654:	10b86304 	addi	r2,r2,-7796
 822a658:	e0fffd17 	ldw	r3,-12(fp)
 822a65c:	18c00f24 	muli	r3,r3,60
 822a660:	10c5883a 	add	r2,r2,r3
 822a664:	10800304 	addi	r2,r2,12
 822a668:	1100000d 	sth	r4,0(r2)

   /* set up DHCP/BOOTP header in buffer */
   outbp = (struct bootp *)pkt->nb_prot;     /* overlay bootp struct on buffer */
 822a66c:	e0bff817 	ldw	r2,-32(fp)
 822a670:	10800317 	ldw	r2,12(r2)
 822a674:	e0bff915 	stw	r2,-28(fp)
   e = dhc_buildheader(iface,outbp);
 822a678:	e17ff917 	ldw	r5,-28(fp)
 822a67c:	e13ffd17 	ldw	r4,-12(fp)
 822a680:	822a3d00 	call	822a3d0 <dhc_buildheader>
 822a684:	e0bffa15 	stw	r2,-24(fp)
   if (e)
 822a688:	e0bffa17 	ldw	r2,-24(fp)
 822a68c:	10000226 	beq	r2,zero,822a698 <dhc_discover+0xe4>
      return e;
 822a690:	e0bffa17 	ldw	r2,-24(fp)
 822a694:	0000f306 	br	822aa64 <dhc_discover+0x4b0>

   /* and turn it into a DHCP DISCOVER packet */
   *(long*)(&outbp->options) = RFC1084_MAGIC_COOKIE; 
 822a698:	e0bff917 	ldw	r2,-28(fp)
 822a69c:	10c03b04 	addi	r3,r2,236
 822a6a0:	0098d534 	movhi	r2,25428
 822a6a4:	10a098c4 	addi	r2,r2,-32157
 822a6a8:	18800015 	stw	r2,0(r3)
   opts = &outbp->options[4];    /* encode options after cookie */
 822a6ac:	e0bff917 	ldw	r2,-28(fp)
 822a6b0:	10803c04 	addi	r2,r2,240
 822a6b4:	e0bff615 	stw	r2,-40(fp)
   *opts++ = DHOP_TYPE;
 822a6b8:	e0bff617 	ldw	r2,-40(fp)
 822a6bc:	10c00044 	addi	r3,r2,1
 822a6c0:	e0fff615 	stw	r3,-40(fp)
 822a6c4:	00c00d44 	movi	r3,53
 822a6c8:	10c00005 	stb	r3,0(r2)
   *opts++ = 1;   /* length of option field */
 822a6cc:	e0bff617 	ldw	r2,-40(fp)
 822a6d0:	10c00044 	addi	r3,r2,1
 822a6d4:	e0fff615 	stw	r3,-40(fp)
 822a6d8:	00c00044 	movi	r3,1
 822a6dc:	10c00005 	stb	r3,0(r2)
   *opts++ = DHCP_DISCOVER;
 822a6e0:	e0bff617 	ldw	r2,-40(fp)
 822a6e4:	10c00044 	addi	r3,r2,1
 822a6e8:	e0fff615 	stw	r3,-40(fp)
 822a6ec:	00c00044 	movi	r3,1
 822a6f0:	10c00005 	stb	r3,0(r2)
   leasetime = -1L ;    /* ask for infinite lease */
 822a6f4:	00bfffc4 	movi	r2,-1
 822a6f8:	e0bffb15 	stw	r2,-20(fp)
   PUT_IP_OPT(opts, DHOP_LEASE, leasetime);
 822a6fc:	e0bff617 	ldw	r2,-40(fp)
 822a700:	10c00044 	addi	r3,r2,1
 822a704:	e0fff615 	stw	r3,-40(fp)
 822a708:	00c00cc4 	movi	r3,51
 822a70c:	10c00005 	stb	r3,0(r2)
 822a710:	e0bff617 	ldw	r2,-40(fp)
 822a714:	10c00044 	addi	r3,r2,1
 822a718:	e0fff615 	stw	r3,-40(fp)
 822a71c:	00c00104 	movi	r3,4
 822a720:	10c00005 	stb	r3,0(r2)
 822a724:	e0bff617 	ldw	r2,-40(fp)
 822a728:	108000c4 	addi	r2,r2,3
 822a72c:	e0fffb04 	addi	r3,fp,-20
 822a730:	18c00003 	ldbu	r3,0(r3)
 822a734:	10c00005 	stb	r3,0(r2)
 822a738:	e0bff617 	ldw	r2,-40(fp)
 822a73c:	10c00084 	addi	r3,r2,2
 822a740:	e0bffb04 	addi	r2,fp,-20
 822a744:	10800044 	addi	r2,r2,1
 822a748:	10800003 	ldbu	r2,0(r2)
 822a74c:	18800005 	stb	r2,0(r3)
 822a750:	e0bff617 	ldw	r2,-40(fp)
 822a754:	10c00044 	addi	r3,r2,1
 822a758:	e0bffb04 	addi	r2,fp,-20
 822a75c:	10800084 	addi	r2,r2,2
 822a760:	10800003 	ldbu	r2,0(r2)
 822a764:	18800005 	stb	r2,0(r3)
 822a768:	e0bffb04 	addi	r2,fp,-20
 822a76c:	108000c4 	addi	r2,r2,3
 822a770:	10800003 	ldbu	r2,0(r2)
 822a774:	1007883a 	mov	r3,r2
 822a778:	e0bff617 	ldw	r2,-40(fp)
 822a77c:	10c00005 	stb	r3,0(r2)
 822a780:	e0bff617 	ldw	r2,-40(fp)
 822a784:	10800104 	addi	r2,r2,4
 822a788:	e0bff615 	stw	r2,-40(fp)

   /* if we already have an IP address, try to get it from the server */
   if (nets[iface]->n_ipaddr != 0)
 822a78c:	008209b4 	movhi	r2,2086
 822a790:	10b83d04 	addi	r2,r2,-7948
 822a794:	e0fffd17 	ldw	r3,-12(fp)
 822a798:	18c7883a 	add	r3,r3,r3
 822a79c:	18c7883a 	add	r3,r3,r3
 822a7a0:	10c5883a 	add	r2,r2,r3
 822a7a4:	10800017 	ldw	r2,0(r2)
 822a7a8:	10800a17 	ldw	r2,40(r2)
 822a7ac:	10004e26 	beq	r2,zero,822a8e8 <dhc_discover+0x334>
   {
      ip_addr my_ip = htonl(nets[iface]->n_ipaddr);
 822a7b0:	008209b4 	movhi	r2,2086
 822a7b4:	10b83d04 	addi	r2,r2,-7948
 822a7b8:	e0fffd17 	ldw	r3,-12(fp)
 822a7bc:	18c7883a 	add	r3,r3,r3
 822a7c0:	18c7883a 	add	r3,r3,r3
 822a7c4:	10c5883a 	add	r2,r2,r3
 822a7c8:	10800017 	ldw	r2,0(r2)
 822a7cc:	10800a17 	ldw	r2,40(r2)
 822a7d0:	1008d63a 	srli	r4,r2,24
 822a7d4:	008209b4 	movhi	r2,2086
 822a7d8:	10b83d04 	addi	r2,r2,-7948
 822a7dc:	e0fffd17 	ldw	r3,-12(fp)
 822a7e0:	18c7883a 	add	r3,r3,r3
 822a7e4:	18c7883a 	add	r3,r3,r3
 822a7e8:	10c5883a 	add	r2,r2,r3
 822a7ec:	10800017 	ldw	r2,0(r2)
 822a7f0:	10800a17 	ldw	r2,40(r2)
 822a7f4:	1004d23a 	srli	r2,r2,8
 822a7f8:	10bfc00c 	andi	r2,r2,65280
 822a7fc:	2088b03a 	or	r4,r4,r2
 822a800:	008209b4 	movhi	r2,2086
 822a804:	10b83d04 	addi	r2,r2,-7948
 822a808:	e0fffd17 	ldw	r3,-12(fp)
 822a80c:	18c7883a 	add	r3,r3,r3
 822a810:	18c7883a 	add	r3,r3,r3
 822a814:	10c5883a 	add	r2,r2,r3
 822a818:	10800017 	ldw	r2,0(r2)
 822a81c:	10800a17 	ldw	r2,40(r2)
 822a820:	10bfc00c 	andi	r2,r2,65280
 822a824:	1004923a 	slli	r2,r2,8
 822a828:	2088b03a 	or	r4,r4,r2
 822a82c:	008209b4 	movhi	r2,2086
 822a830:	10b83d04 	addi	r2,r2,-7948
 822a834:	e0fffd17 	ldw	r3,-12(fp)
 822a838:	18c7883a 	add	r3,r3,r3
 822a83c:	18c7883a 	add	r3,r3,r3
 822a840:	10c5883a 	add	r2,r2,r3
 822a844:	10800017 	ldw	r2,0(r2)
 822a848:	10800a17 	ldw	r2,40(r2)
 822a84c:	1004963a 	slli	r2,r2,24
 822a850:	2084b03a 	or	r2,r4,r2
 822a854:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_CADDR, my_ip);
 822a858:	e0bff617 	ldw	r2,-40(fp)
 822a85c:	10c00044 	addi	r3,r2,1
 822a860:	e0fff615 	stw	r3,-40(fp)
 822a864:	00c00c84 	movi	r3,50
 822a868:	10c00005 	stb	r3,0(r2)
 822a86c:	e0bff617 	ldw	r2,-40(fp)
 822a870:	10c00044 	addi	r3,r2,1
 822a874:	e0fff615 	stw	r3,-40(fp)
 822a878:	00c00104 	movi	r3,4
 822a87c:	10c00005 	stb	r3,0(r2)
 822a880:	e0bff617 	ldw	r2,-40(fp)
 822a884:	108000c4 	addi	r2,r2,3
 822a888:	e0fffc04 	addi	r3,fp,-16
 822a88c:	18c00003 	ldbu	r3,0(r3)
 822a890:	10c00005 	stb	r3,0(r2)
 822a894:	e0bff617 	ldw	r2,-40(fp)
 822a898:	10c00084 	addi	r3,r2,2
 822a89c:	e0bffc04 	addi	r2,fp,-16
 822a8a0:	10800044 	addi	r2,r2,1
 822a8a4:	10800003 	ldbu	r2,0(r2)
 822a8a8:	18800005 	stb	r2,0(r3)
 822a8ac:	e0bff617 	ldw	r2,-40(fp)
 822a8b0:	10c00044 	addi	r3,r2,1
 822a8b4:	e0bffc04 	addi	r2,fp,-16
 822a8b8:	10800084 	addi	r2,r2,2
 822a8bc:	10800003 	ldbu	r2,0(r2)
 822a8c0:	18800005 	stb	r2,0(r3)
 822a8c4:	e0bffc04 	addi	r2,fp,-16
 822a8c8:	108000c4 	addi	r2,r2,3
 822a8cc:	10800003 	ldbu	r2,0(r2)
 822a8d0:	1007883a 	mov	r3,r2
 822a8d4:	e0bff617 	ldw	r2,-40(fp)
 822a8d8:	10c00005 	stb	r3,0(r2)
 822a8dc:	e0bff617 	ldw	r2,-40(fp)
 822a8e0:	10800104 	addi	r2,r2,4
 822a8e4:	e0bff615 	stw	r2,-40(fp)
   }

   /* If there is a list of options to be requested from server, include it*/
#ifdef DHCP_REQLIST
   if ( reqlist_len > 0 )
 822a8e8:	d0a03517 	ldw	r2,-32556(gp)
 822a8ec:	00801a0e 	bge	zero,r2,822a958 <dhc_discover+0x3a4>
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
 822a8f0:	e0bff617 	ldw	r2,-40(fp)
 822a8f4:	10c00044 	addi	r3,r2,1
 822a8f8:	e0fff615 	stw	r3,-40(fp)
 822a8fc:	00c00dc4 	movi	r3,55
 822a900:	10c00005 	stb	r3,0(r2)
      *opts++ = (u_char)reqlist_len ;
 822a904:	e0bff617 	ldw	r2,-40(fp)
 822a908:	10c00044 	addi	r3,r2,1
 822a90c:	e0fff615 	stw	r3,-40(fp)
 822a910:	d0e03517 	ldw	r3,-32556(gp)
 822a914:	10c00005 	stb	r3,0(r2)

      for (i=0 ; i < reqlist_len ; i++ )
 822a918:	e03ff715 	stw	zero,-36(fp)
 822a91c:	00000b06 	br	822a94c <dhc_discover+0x398>
         *opts++ = reqlist[i];
 822a920:	e0bff617 	ldw	r2,-40(fp)
 822a924:	10c00044 	addi	r3,r2,1
 822a928:	e0fff615 	stw	r3,-40(fp)
 822a92c:	e13ff717 	ldw	r4,-36(fp)
 822a930:	d0e03404 	addi	r3,gp,-32560
 822a934:	20c7883a 	add	r3,r4,r3
 822a938:	18c00003 	ldbu	r3,0(r3)
 822a93c:	10c00005 	stb	r3,0(r2)
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
      *opts++ = (u_char)reqlist_len ;

      for (i=0 ; i < reqlist_len ; i++ )
 822a940:	e0bff717 	ldw	r2,-36(fp)
 822a944:	10800044 	addi	r2,r2,1
 822a948:	e0bff715 	stw	r2,-36(fp)
 822a94c:	d0a03517 	ldw	r2,-32556(gp)
 822a950:	e0fff717 	ldw	r3,-36(fp)
 822a954:	18bff216 	blt	r3,r2,822a920 <dhc_discover+0x36c>
         *opts++ = reqlist[i];
   }
#endif   /* DHCP_REQLIST */

   *opts++ = DHOP_END;
 822a958:	e0bff617 	ldw	r2,-40(fp)
 822a95c:	10c00044 	addi	r3,r2,1
 822a960:	e0fff615 	stw	r3,-40(fp)
 822a964:	00ffffc4 	movi	r3,-1
 822a968:	10c00005 	stb	r3,0(r2)

   /* last_tick needs to be set in case we are doing a retry. It 
    * prevents dhc_second from calling us to do another retry while 
    * we are stuck 
    */
   dhc_states[iface].last_tick = cticks;
 822a96c:	d0e0a817 	ldw	r3,-32096(gp)
 822a970:	008209b4 	movhi	r2,2086
 822a974:	10b86304 	addi	r2,r2,-7796
 822a978:	e13ffd17 	ldw	r4,-12(fp)
 822a97c:	21000f24 	muli	r4,r4,60
 822a980:	1105883a 	add	r2,r2,r4
 822a984:	10800404 	addi	r2,r2,16
 822a988:	10c00015 	stw	r3,0(r2)

   pkt->fhost = 0xFFFFFFFF;   /* broadcast discovery request */
 822a98c:	e0bff817 	ldw	r2,-32(fp)
 822a990:	00ffffc4 	movi	r3,-1
 822a994:	10c00715 	stw	r3,28(r2)
   pkt->net = nets[iface];    /* send out caller spec'ed net */
 822a998:	008209b4 	movhi	r2,2086
 822a99c:	10b83d04 	addi	r2,r2,-7948
 822a9a0:	e0fffd17 	ldw	r3,-12(fp)
 822a9a4:	18c7883a 	add	r3,r3,r3
 822a9a8:	18c7883a 	add	r3,r3,r3
 822a9ac:	10c5883a 	add	r2,r2,r3
 822a9b0:	10c00017 	ldw	r3,0(r2)
 822a9b4:	e0bff817 	ldw	r2,-32(fp)
 822a9b8:	10c00615 	stw	r3,24(r2)

   /* we need to change the DHCP state before sending to avoid a 
    * race condition with the expected reply 
    */
   if (dhc_states[iface].state != DHCS_SELECTING)
 822a9bc:	008209b4 	movhi	r2,2086
 822a9c0:	10b86304 	addi	r2,r2,-7796
 822a9c4:	e0fffd17 	ldw	r3,-12(fp)
 822a9c8:	18c00f24 	muli	r3,r3,60
 822a9cc:	10c5883a 	add	r2,r2,r3
 822a9d0:	10800017 	ldw	r2,0(r2)
 822a9d4:	10800120 	cmpeqi	r2,r2,4
 822a9d8:	1000031e 	bne	r2,zero,822a9e8 <dhc_discover+0x434>
      dhc_set_state(iface, DHCS_SELECTING);
 822a9dc:	01400104 	movi	r5,4
 822a9e0:	e13ffd17 	ldw	r4,-12(fp)
 822a9e4:	822c63c0 	call	822c63c <dhc_set_state>

   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 822a9e8:	e1bff817 	ldw	r6,-32(fp)
 822a9ec:	01401104 	movi	r5,68
 822a9f0:	010010c4 	movi	r4,67
 822a9f4:	82450080 	call	8245008 <udp_send>
   dsc_discovers++;
 822a9f8:	d0a09117 	ldw	r2,-32188(gp)
 822a9fc:	10800044 	addi	r2,r2,1
 822aa00:	d0a09115 	stw	r2,-32188(gp)

   /* state info is the same even if udp_send() failed */
   dhc_states[iface].last_tick = cticks;     /* set this again, post udp_send */
 822aa04:	d0e0a817 	ldw	r3,-32096(gp)
 822aa08:	008209b4 	movhi	r2,2086
 822aa0c:	10b86304 	addi	r2,r2,-7796
 822aa10:	e13ffd17 	ldw	r4,-12(fp)
 822aa14:	21000f24 	muli	r4,r4,60
 822aa18:	1105883a 	add	r2,r2,r4
 822aa1c:	10800404 	addi	r2,r2,16
 822aa20:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].tries++;
 822aa24:	008209b4 	movhi	r2,2086
 822aa28:	10b86304 	addi	r2,r2,-7796
 822aa2c:	e0fffd17 	ldw	r3,-12(fp)
 822aa30:	18c00f24 	muli	r3,r3,60
 822aa34:	10c5883a 	add	r2,r2,r3
 822aa38:	10800104 	addi	r2,r2,4
 822aa3c:	10800017 	ldw	r2,0(r2)
 822aa40:	10c00044 	addi	r3,r2,1
 822aa44:	008209b4 	movhi	r2,2086
 822aa48:	10b86304 	addi	r2,r2,-7796
 822aa4c:	e13ffd17 	ldw	r4,-12(fp)
 822aa50:	21000f24 	muli	r4,r4,60
 822aa54:	1105883a 	add	r2,r2,r4
 822aa58:	10800104 	addi	r2,r2,4
 822aa5c:	10c00015 	stw	r3,0(r2)

   return 0;
 822aa60:	0005883a 	mov	r2,zero
}
 822aa64:	e6fffe04 	addi	sp,fp,-8
 822aa68:	dfc00317 	ldw	ra,12(sp)
 822aa6c:	df000217 	ldw	fp,8(sp)
 822aa70:	dc400117 	ldw	r17,4(sp)
 822aa74:	dc000017 	ldw	r16,0(sp)
 822aa78:	dec00404 	addi	sp,sp,16
 822aa7c:	f800283a 	ret

0822aa80 <dhc_rx_offer>:
 * RETURNS: 0 if OK, else ENP_ error
 */

int
dhc_rx_offer(int iface, struct bootp * bp, unsigned bplen)
{
 822aa80:	defff904 	addi	sp,sp,-28
 822aa84:	dfc00615 	stw	ra,24(sp)
 822aa88:	df000515 	stw	fp,20(sp)
 822aa8c:	df000504 	addi	fp,sp,20
 822aa90:	e13ffd15 	stw	r4,-12(fp)
 822aa94:	e17ffe15 	stw	r5,-8(fp)
 822aa98:	e1bfff15 	stw	r6,-4(fp)
   u_char * opts;
   int   e;

   if (dhc_states[iface].xid != bp->xid)
 822aa9c:	008209b4 	movhi	r2,2086
 822aaa0:	10b86304 	addi	r2,r2,-7796
 822aaa4:	e0fffd17 	ldw	r3,-12(fp)
 822aaa8:	18c00f24 	muli	r3,r3,60
 822aaac:	10c5883a 	add	r2,r2,r3
 822aab0:	10800204 	addi	r2,r2,8
 822aab4:	10c00017 	ldw	r3,0(r2)
 822aab8:	e0bffe17 	ldw	r2,-8(fp)
 822aabc:	10800117 	ldw	r2,4(r2)
 822aac0:	18800226 	beq	r3,r2,822aacc <dhc_rx_offer+0x4c>
      return ENP_NOT_MINE;
 822aac4:	00800084 	movi	r2,2
 822aac8:	00002106 	br	822ab50 <dhc_rx_offer+0xd0>

   opts = &bp->options[4];    /* examine options after cookie */
 822aacc:	e0bffe17 	ldw	r2,-8(fp)
 822aad0:	10803c04 	addi	r2,r2,240
 822aad4:	e0bffb15 	stw	r2,-20(fp)
   e = dhc_extract_opts(iface,opts);
 822aad8:	e17ffb17 	ldw	r5,-20(fp)
 822aadc:	e13ffd17 	ldw	r4,-12(fp)
 822aae0:	822bafc0 	call	822bafc <dhc_extract_opts>
 822aae4:	e0bffc15 	stw	r2,-16(fp)
   if (e)   /* parse error? */
 822aae8:	e0bffc17 	ldw	r2,-16(fp)
 822aaec:	10000326 	beq	r2,zero,822aafc <dhc_rx_offer+0x7c>
   {
      dtrap();
 822aaf0:	822d5f00 	call	822d5f0 <dtrap>
      return e;
 822aaf4:	e0bffc17 	ldw	r2,-16(fp)
 822aaf8:	00001506 	br	822ab50 <dhc_rx_offer+0xd0>
   }
   if (!bp->yiaddr)  /* require an IP address */
 822aafc:	e0bffe17 	ldw	r2,-8(fp)
 822ab00:	10800417 	ldw	r2,16(r2)
 822ab04:	1000061e 	bne	r2,zero,822ab20 <dhc_rx_offer+0xa0>
   {
      dhc_decline(iface,bp, bplen);
 822ab08:	e1bfff17 	ldw	r6,-4(fp)
 822ab0c:	e17ffe17 	ldw	r5,-8(fp)
 822ab10:	e13ffd17 	ldw	r4,-12(fp)
 822ab14:	822b9480 	call	822b948 <dhc_decline>
      return ENP_NOT_MINE;
 822ab18:	00800084 	movi	r2,2
 822ab1c:	00000c06 	br	822ab50 <dhc_rx_offer+0xd0>
   }
   dhc_states[iface].ipaddr = bp->yiaddr;
 822ab20:	e0bffe17 	ldw	r2,-8(fp)
 822ab24:	10c00417 	ldw	r3,16(r2)
 822ab28:	008209b4 	movhi	r2,2086
 822ab2c:	10b86304 	addi	r2,r2,-7796
 822ab30:	e13ffd17 	ldw	r4,-12(fp)
 822ab34:	21000f24 	muli	r4,r4,60
 822ab38:	1105883a 	add	r2,r2,r4
 822ab3c:	10800904 	addi	r2,r2,36
 822ab40:	10c00015 	stw	r3,0(r2)

   /* if we got here, we must like the offer -- send a DHCP REQUEST */
   return (dhc_request(iface,FALSE));
 822ab44:	000b883a 	mov	r5,zero
 822ab48:	e13ffd17 	ldw	r4,-12(fp)
 822ab4c:	822ab640 	call	822ab64 <dhc_request>
}
 822ab50:	e037883a 	mov	sp,fp
 822ab54:	dfc00117 	ldw	ra,4(sp)
 822ab58:	df000017 	ldw	fp,0(sp)
 822ab5c:	dec00204 	addi	sp,sp,8
 822ab60:	f800283a 	ret

0822ab64 <dhc_request>:
 * RETURNS:  Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_request(int iface,int xid_flag)
{
 822ab64:	defff404 	addi	sp,sp,-48
 822ab68:	dfc00b15 	stw	ra,44(sp)
 822ab6c:	df000a15 	stw	fp,40(sp)
 822ab70:	df000a04 	addi	fp,sp,40
 822ab74:	e13ffe15 	stw	r4,-8(fp)
 822ab78:	e17fff15 	stw	r5,-4(fp)
   u_char  *   opts; /* scratch pointer to DHCP options field */
   ip_addr opt_ip;      /* IP address temporary */
   int      e;       /* error holder */

   /* get a UDP packet buffer for sending DHCP request */
   pkt = udp_alloc(sizeof(struct bootp) + DHCP_OPTSIZE - BOOTP_OPTSIZE, 0);
 822ab7c:	000b883a 	mov	r5,zero
 822ab80:	01008904 	movi	r4,548
 822ab84:	82454440 	call	8245444 <udp_alloc>
 822ab88:	e0bff815 	stw	r2,-32(fp)
   if (!pkt) 
 822ab8c:	e0bff817 	ldw	r2,-32(fp)
 822ab90:	1000021e 	bne	r2,zero,822ab9c <dhc_request+0x38>
      return ENP_NOMEM;
 822ab94:	00bffb04 	movi	r2,-20
 822ab98:	00028e06 	br	822b5d4 <dhc_request+0xa70>
   pkt->nb_plen = sizeof(struct bootp) - BOOTP_OPTSIZE;
 822ab9c:	e0bff817 	ldw	r2,-32(fp)
 822aba0:	00c03b04 	movi	r3,236
 822aba4:	10c00415 	stw	r3,16(r2)

   if ( xid_flag == TRUE )
 822aba8:	e0bfff17 	ldw	r2,-4(fp)
 822abac:	10800058 	cmpnei	r2,r2,1
 822abb0:	1000121e 	bne	r2,zero,822abfc <dhc_request+0x98>
   {
      dhc_states[iface].xid  = xids++;
 822abb4:	d0a03317 	ldw	r2,-32564(gp)
 822abb8:	10c00044 	addi	r3,r2,1
 822abbc:	d0e03315 	stw	r3,-32564(gp)
 822abc0:	1009883a 	mov	r4,r2
 822abc4:	008209b4 	movhi	r2,2086
 822abc8:	10b86304 	addi	r2,r2,-7796
 822abcc:	e0fffe17 	ldw	r3,-8(fp)
 822abd0:	18c00f24 	muli	r3,r3,60
 822abd4:	10c5883a 	add	r2,r2,r3
 822abd8:	10800204 	addi	r2,r2,8
 822abdc:	11000015 	stw	r4,0(r2)
      dhc_states[iface].secs = 0;
 822abe0:	008209b4 	movhi	r2,2086
 822abe4:	10b86304 	addi	r2,r2,-7796
 822abe8:	e0fffe17 	ldw	r3,-8(fp)
 822abec:	18c00f24 	muli	r3,r3,60
 822abf0:	10c5883a 	add	r2,r2,r3
 822abf4:	10800304 	addi	r2,r2,12
 822abf8:	1000000d 	sth	zero,0(r2)
   }

   /* build a BOOTP request header */
   outbp = (struct bootp *)pkt->nb_prot;
 822abfc:	e0bff817 	ldw	r2,-32(fp)
 822ac00:	10800317 	ldw	r2,12(r2)
 822ac04:	e0bff915 	stw	r2,-28(fp)
   e     = dhc_buildheader(iface,outbp);
 822ac08:	e17ff917 	ldw	r5,-28(fp)
 822ac0c:	e13ffe17 	ldw	r4,-8(fp)
 822ac10:	822a3d00 	call	822a3d0 <dhc_buildheader>
 822ac14:	e0bffa15 	stw	r2,-24(fp)
   if (e)
 822ac18:	e0bffa17 	ldw	r2,-24(fp)
 822ac1c:	10000226 	beq	r2,zero,822ac28 <dhc_request+0xc4>
      return e;
 822ac20:	e0bffa17 	ldw	r2,-24(fp)
 822ac24:	00026b06 	br	822b5d4 <dhc_request+0xa70>

   /* turn it into a DHCP REQUEST packet */
   *(long*)(&outbp->options) = RFC1084_MAGIC_COOKIE; 
 822ac28:	e0bff917 	ldw	r2,-28(fp)
 822ac2c:	10c03b04 	addi	r3,r2,236
 822ac30:	0098d534 	movhi	r2,25428
 822ac34:	10a098c4 	addi	r2,r2,-32157
 822ac38:	18800015 	stw	r2,0(r3)
   opts    = &outbp->options[4];    /* encode options after cookie */
 822ac3c:	e0bff917 	ldw	r2,-28(fp)
 822ac40:	10803c04 	addi	r2,r2,240
 822ac44:	e0bff615 	stw	r2,-40(fp)
   *opts++ = DHOP_TYPE;
 822ac48:	e0bff617 	ldw	r2,-40(fp)
 822ac4c:	10c00044 	addi	r3,r2,1
 822ac50:	e0fff615 	stw	r3,-40(fp)
 822ac54:	00c00d44 	movi	r3,53
 822ac58:	10c00005 	stb	r3,0(r2)
   *opts++ = 1;   /* length of option field */
 822ac5c:	e0bff617 	ldw	r2,-40(fp)
 822ac60:	10c00044 	addi	r3,r2,1
 822ac64:	e0fff615 	stw	r3,-40(fp)
 822ac68:	00c00044 	movi	r3,1
 822ac6c:	10c00005 	stb	r3,0(r2)
   *opts++ = DHCP_REQUEST;
 822ac70:	e0bff617 	ldw	r2,-40(fp)
 822ac74:	10c00044 	addi	r3,r2,1
 822ac78:	e0fff615 	stw	r3,-40(fp)
 822ac7c:	00c000c4 	movi	r3,3
 822ac80:	10c00005 	stb	r3,0(r2)

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 822ac84:	008209b4 	movhi	r2,2086
 822ac88:	10b86304 	addi	r2,r2,-7796
 822ac8c:	e0fffe17 	ldw	r3,-8(fp)
 822ac90:	18c00f24 	muli	r3,r3,60
 822ac94:	10c5883a 	add	r2,r2,r3
 822ac98:	10800017 	ldw	r2,0(r2)
 822ac9c:	10800120 	cmpeqi	r2,r2,4
 822aca0:	1000181e 	bne	r2,zero,822ad04 <dhc_request+0x1a0>
       (dhc_states[iface].state == DHCS_REQUESTING) ||
 822aca4:	008209b4 	movhi	r2,2086
 822aca8:	10b86304 	addi	r2,r2,-7796
 822acac:	e0fffe17 	ldw	r3,-8(fp)
 822acb0:	18c00f24 	muli	r3,r3,60
 822acb4:	10c5883a 	add	r2,r2,r3
 822acb8:	10800017 	ldw	r2,0(r2)
   *opts++ = DHOP_TYPE;
   *opts++ = 1;   /* length of option field */
   *opts++ = DHCP_REQUEST;

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 822acbc:	10800160 	cmpeqi	r2,r2,5
 822acc0:	1000101e 	bne	r2,zero,822ad04 <dhc_request+0x1a0>
       (dhc_states[iface].state == DHCS_REQUESTING) ||
       (dhc_states[iface].state == DHCS_REBOOTING) ||
 822acc4:	008209b4 	movhi	r2,2086
 822acc8:	10b86304 	addi	r2,r2,-7796
 822accc:	e0fffe17 	ldw	r3,-8(fp)
 822acd0:	18c00f24 	muli	r3,r3,60
 822acd4:	10c5883a 	add	r2,r2,r3
 822acd8:	10800017 	ldw	r2,0(r2)
   *opts++ = 1;   /* length of option field */
   *opts++ = DHCP_REQUEST;

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
       (dhc_states[iface].state == DHCS_REQUESTING) ||
 822acdc:	108000e0 	cmpeqi	r2,r2,3
 822ace0:	1000081e 	bne	r2,zero,822ad04 <dhc_request+0x1a0>
       (dhc_states[iface].state == DHCS_REBOOTING) ||
       (dhc_states[iface].state == DHCS_INITREBOOT))
 822ace4:	008209b4 	movhi	r2,2086
 822ace8:	10b86304 	addi	r2,r2,-7796
 822acec:	e0fffe17 	ldw	r3,-8(fp)
 822acf0:	18c00f24 	muli	r3,r3,60
 822acf4:	10c5883a 	add	r2,r2,r3
 822acf8:	10800017 	ldw	r2,0(r2)
   *opts++ = DHCP_REQUEST;

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
       (dhc_states[iface].state == DHCS_REQUESTING) ||
       (dhc_states[iface].state == DHCS_REBOOTING) ||
 822acfc:	10800098 	cmpnei	r2,r2,2
 822ad00:	10004a1e 	bne	r2,zero,822ae2c <dhc_request+0x2c8>
       (dhc_states[iface].state == DHCS_INITREBOOT))
   {
      opt_ip = ntohl(dhc_states[iface].ipaddr);
 822ad04:	008209b4 	movhi	r2,2086
 822ad08:	10b86304 	addi	r2,r2,-7796
 822ad0c:	e0fffe17 	ldw	r3,-8(fp)
 822ad10:	18c00f24 	muli	r3,r3,60
 822ad14:	10c5883a 	add	r2,r2,r3
 822ad18:	10800904 	addi	r2,r2,36
 822ad1c:	10800017 	ldw	r2,0(r2)
 822ad20:	1006d63a 	srli	r3,r2,24
 822ad24:	008209b4 	movhi	r2,2086
 822ad28:	10b86304 	addi	r2,r2,-7796
 822ad2c:	e13ffe17 	ldw	r4,-8(fp)
 822ad30:	21000f24 	muli	r4,r4,60
 822ad34:	1105883a 	add	r2,r2,r4
 822ad38:	10800904 	addi	r2,r2,36
 822ad3c:	10800017 	ldw	r2,0(r2)
 822ad40:	1004d23a 	srli	r2,r2,8
 822ad44:	10bfc00c 	andi	r2,r2,65280
 822ad48:	1886b03a 	or	r3,r3,r2
 822ad4c:	008209b4 	movhi	r2,2086
 822ad50:	10b86304 	addi	r2,r2,-7796
 822ad54:	e13ffe17 	ldw	r4,-8(fp)
 822ad58:	21000f24 	muli	r4,r4,60
 822ad5c:	1105883a 	add	r2,r2,r4
 822ad60:	10800904 	addi	r2,r2,36
 822ad64:	10800017 	ldw	r2,0(r2)
 822ad68:	10bfc00c 	andi	r2,r2,65280
 822ad6c:	1004923a 	slli	r2,r2,8
 822ad70:	1886b03a 	or	r3,r3,r2
 822ad74:	008209b4 	movhi	r2,2086
 822ad78:	10b86304 	addi	r2,r2,-7796
 822ad7c:	e13ffe17 	ldw	r4,-8(fp)
 822ad80:	21000f24 	muli	r4,r4,60
 822ad84:	1105883a 	add	r2,r2,r4
 822ad88:	10800904 	addi	r2,r2,36
 822ad8c:	10800017 	ldw	r2,0(r2)
 822ad90:	1004963a 	slli	r2,r2,24
 822ad94:	1884b03a 	or	r2,r3,r2
 822ad98:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_CADDR, opt_ip);
 822ad9c:	e0bff617 	ldw	r2,-40(fp)
 822ada0:	10c00044 	addi	r3,r2,1
 822ada4:	e0fff615 	stw	r3,-40(fp)
 822ada8:	00c00c84 	movi	r3,50
 822adac:	10c00005 	stb	r3,0(r2)
 822adb0:	e0bff617 	ldw	r2,-40(fp)
 822adb4:	10c00044 	addi	r3,r2,1
 822adb8:	e0fff615 	stw	r3,-40(fp)
 822adbc:	00c00104 	movi	r3,4
 822adc0:	10c00005 	stb	r3,0(r2)
 822adc4:	e0bff617 	ldw	r2,-40(fp)
 822adc8:	108000c4 	addi	r2,r2,3
 822adcc:	e0fffd04 	addi	r3,fp,-12
 822add0:	18c00003 	ldbu	r3,0(r3)
 822add4:	10c00005 	stb	r3,0(r2)
 822add8:	e0bff617 	ldw	r2,-40(fp)
 822addc:	10c00084 	addi	r3,r2,2
 822ade0:	e0bffd04 	addi	r2,fp,-12
 822ade4:	10800044 	addi	r2,r2,1
 822ade8:	10800003 	ldbu	r2,0(r2)
 822adec:	18800005 	stb	r2,0(r3)
 822adf0:	e0bff617 	ldw	r2,-40(fp)
 822adf4:	10c00044 	addi	r3,r2,1
 822adf8:	e0bffd04 	addi	r2,fp,-12
 822adfc:	10800084 	addi	r2,r2,2
 822ae00:	10800003 	ldbu	r2,0(r2)
 822ae04:	18800005 	stb	r2,0(r3)
 822ae08:	e0bffd04 	addi	r2,fp,-12
 822ae0c:	108000c4 	addi	r2,r2,3
 822ae10:	10800003 	ldbu	r2,0(r2)
 822ae14:	1007883a 	mov	r3,r2
 822ae18:	e0bff617 	ldw	r2,-40(fp)
 822ae1c:	10c00005 	stb	r3,0(r2)
 822ae20:	e0bff617 	ldw	r2,-40(fp)
 822ae24:	10800104 	addi	r2,r2,4
 822ae28:	e0bff615 	stw	r2,-40(fp)
   }
   if (dhc_states[iface].snmask)
 822ae2c:	008209b4 	movhi	r2,2086
 822ae30:	10b86304 	addi	r2,r2,-7796
 822ae34:	e0fffe17 	ldw	r3,-8(fp)
 822ae38:	18c00f24 	muli	r3,r3,60
 822ae3c:	10c5883a 	add	r2,r2,r3
 822ae40:	10800a04 	addi	r2,r2,40
 822ae44:	10800017 	ldw	r2,0(r2)
 822ae48:	10004a26 	beq	r2,zero,822af74 <dhc_request+0x410>
   {
      opt_ip = ntohl(dhc_states[iface].snmask);
 822ae4c:	008209b4 	movhi	r2,2086
 822ae50:	10b86304 	addi	r2,r2,-7796
 822ae54:	e0fffe17 	ldw	r3,-8(fp)
 822ae58:	18c00f24 	muli	r3,r3,60
 822ae5c:	10c5883a 	add	r2,r2,r3
 822ae60:	10800a04 	addi	r2,r2,40
 822ae64:	10800017 	ldw	r2,0(r2)
 822ae68:	1006d63a 	srli	r3,r2,24
 822ae6c:	008209b4 	movhi	r2,2086
 822ae70:	10b86304 	addi	r2,r2,-7796
 822ae74:	e13ffe17 	ldw	r4,-8(fp)
 822ae78:	21000f24 	muli	r4,r4,60
 822ae7c:	1105883a 	add	r2,r2,r4
 822ae80:	10800a04 	addi	r2,r2,40
 822ae84:	10800017 	ldw	r2,0(r2)
 822ae88:	1004d23a 	srli	r2,r2,8
 822ae8c:	10bfc00c 	andi	r2,r2,65280
 822ae90:	1886b03a 	or	r3,r3,r2
 822ae94:	008209b4 	movhi	r2,2086
 822ae98:	10b86304 	addi	r2,r2,-7796
 822ae9c:	e13ffe17 	ldw	r4,-8(fp)
 822aea0:	21000f24 	muli	r4,r4,60
 822aea4:	1105883a 	add	r2,r2,r4
 822aea8:	10800a04 	addi	r2,r2,40
 822aeac:	10800017 	ldw	r2,0(r2)
 822aeb0:	10bfc00c 	andi	r2,r2,65280
 822aeb4:	1004923a 	slli	r2,r2,8
 822aeb8:	1886b03a 	or	r3,r3,r2
 822aebc:	008209b4 	movhi	r2,2086
 822aec0:	10b86304 	addi	r2,r2,-7796
 822aec4:	e13ffe17 	ldw	r4,-8(fp)
 822aec8:	21000f24 	muli	r4,r4,60
 822aecc:	1105883a 	add	r2,r2,r4
 822aed0:	10800a04 	addi	r2,r2,40
 822aed4:	10800017 	ldw	r2,0(r2)
 822aed8:	1004963a 	slli	r2,r2,24
 822aedc:	1884b03a 	or	r2,r3,r2
 822aee0:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_SNMASK, opt_ip);
 822aee4:	e0bff617 	ldw	r2,-40(fp)
 822aee8:	10c00044 	addi	r3,r2,1
 822aeec:	e0fff615 	stw	r3,-40(fp)
 822aef0:	00c00044 	movi	r3,1
 822aef4:	10c00005 	stb	r3,0(r2)
 822aef8:	e0bff617 	ldw	r2,-40(fp)
 822aefc:	10c00044 	addi	r3,r2,1
 822af00:	e0fff615 	stw	r3,-40(fp)
 822af04:	00c00104 	movi	r3,4
 822af08:	10c00005 	stb	r3,0(r2)
 822af0c:	e0bff617 	ldw	r2,-40(fp)
 822af10:	108000c4 	addi	r2,r2,3
 822af14:	e0fffd04 	addi	r3,fp,-12
 822af18:	18c00003 	ldbu	r3,0(r3)
 822af1c:	10c00005 	stb	r3,0(r2)
 822af20:	e0bff617 	ldw	r2,-40(fp)
 822af24:	10c00084 	addi	r3,r2,2
 822af28:	e0bffd04 	addi	r2,fp,-12
 822af2c:	10800044 	addi	r2,r2,1
 822af30:	10800003 	ldbu	r2,0(r2)
 822af34:	18800005 	stb	r2,0(r3)
 822af38:	e0bff617 	ldw	r2,-40(fp)
 822af3c:	10c00044 	addi	r3,r2,1
 822af40:	e0bffd04 	addi	r2,fp,-12
 822af44:	10800084 	addi	r2,r2,2
 822af48:	10800003 	ldbu	r2,0(r2)
 822af4c:	18800005 	stb	r2,0(r3)
 822af50:	e0bffd04 	addi	r2,fp,-12
 822af54:	108000c4 	addi	r2,r2,3
 822af58:	10800003 	ldbu	r2,0(r2)
 822af5c:	1007883a 	mov	r3,r2
 822af60:	e0bff617 	ldw	r2,-40(fp)
 822af64:	10c00005 	stb	r3,0(r2)
 822af68:	e0bff617 	ldw	r2,-40(fp)
 822af6c:	10800104 	addi	r2,r2,4
 822af70:	e0bff615 	stw	r2,-40(fp)
   }
   if (dhc_states[iface].defgw)
 822af74:	008209b4 	movhi	r2,2086
 822af78:	10b86304 	addi	r2,r2,-7796
 822af7c:	e0fffe17 	ldw	r3,-8(fp)
 822af80:	18c00f24 	muli	r3,r3,60
 822af84:	10c5883a 	add	r2,r2,r3
 822af88:	10800b04 	addi	r2,r2,44
 822af8c:	10800017 	ldw	r2,0(r2)
 822af90:	10004a26 	beq	r2,zero,822b0bc <dhc_request+0x558>
   {
      opt_ip = ntohl(dhc_states[iface].defgw);
 822af94:	008209b4 	movhi	r2,2086
 822af98:	10b86304 	addi	r2,r2,-7796
 822af9c:	e0fffe17 	ldw	r3,-8(fp)
 822afa0:	18c00f24 	muli	r3,r3,60
 822afa4:	10c5883a 	add	r2,r2,r3
 822afa8:	10800b04 	addi	r2,r2,44
 822afac:	10800017 	ldw	r2,0(r2)
 822afb0:	1006d63a 	srli	r3,r2,24
 822afb4:	008209b4 	movhi	r2,2086
 822afb8:	10b86304 	addi	r2,r2,-7796
 822afbc:	e13ffe17 	ldw	r4,-8(fp)
 822afc0:	21000f24 	muli	r4,r4,60
 822afc4:	1105883a 	add	r2,r2,r4
 822afc8:	10800b04 	addi	r2,r2,44
 822afcc:	10800017 	ldw	r2,0(r2)
 822afd0:	1004d23a 	srli	r2,r2,8
 822afd4:	10bfc00c 	andi	r2,r2,65280
 822afd8:	1886b03a 	or	r3,r3,r2
 822afdc:	008209b4 	movhi	r2,2086
 822afe0:	10b86304 	addi	r2,r2,-7796
 822afe4:	e13ffe17 	ldw	r4,-8(fp)
 822afe8:	21000f24 	muli	r4,r4,60
 822afec:	1105883a 	add	r2,r2,r4
 822aff0:	10800b04 	addi	r2,r2,44
 822aff4:	10800017 	ldw	r2,0(r2)
 822aff8:	10bfc00c 	andi	r2,r2,65280
 822affc:	1004923a 	slli	r2,r2,8
 822b000:	1886b03a 	or	r3,r3,r2
 822b004:	008209b4 	movhi	r2,2086
 822b008:	10b86304 	addi	r2,r2,-7796
 822b00c:	e13ffe17 	ldw	r4,-8(fp)
 822b010:	21000f24 	muli	r4,r4,60
 822b014:	1105883a 	add	r2,r2,r4
 822b018:	10800b04 	addi	r2,r2,44
 822b01c:	10800017 	ldw	r2,0(r2)
 822b020:	1004963a 	slli	r2,r2,24
 822b024:	1884b03a 	or	r2,r3,r2
 822b028:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_ROUTER, opt_ip);
 822b02c:	e0bff617 	ldw	r2,-40(fp)
 822b030:	10c00044 	addi	r3,r2,1
 822b034:	e0fff615 	stw	r3,-40(fp)
 822b038:	00c000c4 	movi	r3,3
 822b03c:	10c00005 	stb	r3,0(r2)
 822b040:	e0bff617 	ldw	r2,-40(fp)
 822b044:	10c00044 	addi	r3,r2,1
 822b048:	e0fff615 	stw	r3,-40(fp)
 822b04c:	00c00104 	movi	r3,4
 822b050:	10c00005 	stb	r3,0(r2)
 822b054:	e0bff617 	ldw	r2,-40(fp)
 822b058:	108000c4 	addi	r2,r2,3
 822b05c:	e0fffd04 	addi	r3,fp,-12
 822b060:	18c00003 	ldbu	r3,0(r3)
 822b064:	10c00005 	stb	r3,0(r2)
 822b068:	e0bff617 	ldw	r2,-40(fp)
 822b06c:	10c00084 	addi	r3,r2,2
 822b070:	e0bffd04 	addi	r2,fp,-12
 822b074:	10800044 	addi	r2,r2,1
 822b078:	10800003 	ldbu	r2,0(r2)
 822b07c:	18800005 	stb	r2,0(r3)
 822b080:	e0bff617 	ldw	r2,-40(fp)
 822b084:	10c00044 	addi	r3,r2,1
 822b088:	e0bffd04 	addi	r2,fp,-12
 822b08c:	10800084 	addi	r2,r2,2
 822b090:	10800003 	ldbu	r2,0(r2)
 822b094:	18800005 	stb	r2,0(r3)
 822b098:	e0bffd04 	addi	r2,fp,-12
 822b09c:	108000c4 	addi	r2,r2,3
 822b0a0:	10800003 	ldbu	r2,0(r2)
 822b0a4:	1007883a 	mov	r3,r2
 822b0a8:	e0bff617 	ldw	r2,-40(fp)
 822b0ac:	10c00005 	stb	r3,0(r2)
 822b0b0:	e0bff617 	ldw	r2,-40(fp)
 822b0b4:	10800104 	addi	r2,r2,4
 822b0b8:	e0bff615 	stw	r2,-40(fp)
         }
      }
   }
#endif

   if (dhc_states[iface].lease)
 822b0bc:	008209b4 	movhi	r2,2086
 822b0c0:	10b86304 	addi	r2,r2,-7796
 822b0c4:	e0fffe17 	ldw	r3,-8(fp)
 822b0c8:	18c00f24 	muli	r3,r3,60
 822b0cc:	10c5883a 	add	r2,r2,r3
 822b0d0:	10800504 	addi	r2,r2,20
 822b0d4:	10800017 	ldw	r2,0(r2)
 822b0d8:	10003826 	beq	r2,zero,822b1bc <dhc_request+0x658>
   {
      PUT_IP_OPT(opts, DHOP_LEASE, dhc_states[iface].lease);
 822b0dc:	e0bff617 	ldw	r2,-40(fp)
 822b0e0:	10c00044 	addi	r3,r2,1
 822b0e4:	e0fff615 	stw	r3,-40(fp)
 822b0e8:	00c00cc4 	movi	r3,51
 822b0ec:	10c00005 	stb	r3,0(r2)
 822b0f0:	e0bff617 	ldw	r2,-40(fp)
 822b0f4:	10c00044 	addi	r3,r2,1
 822b0f8:	e0fff615 	stw	r3,-40(fp)
 822b0fc:	00c00104 	movi	r3,4
 822b100:	10c00005 	stb	r3,0(r2)
 822b104:	e0bff617 	ldw	r2,-40(fp)
 822b108:	10c000c4 	addi	r3,r2,3
 822b10c:	e0bffe17 	ldw	r2,-8(fp)
 822b110:	10800f24 	muli	r2,r2,60
 822b114:	11000504 	addi	r4,r2,20
 822b118:	008209b4 	movhi	r2,2086
 822b11c:	10b86304 	addi	r2,r2,-7796
 822b120:	2085883a 	add	r2,r4,r2
 822b124:	10800003 	ldbu	r2,0(r2)
 822b128:	18800005 	stb	r2,0(r3)
 822b12c:	e0bff617 	ldw	r2,-40(fp)
 822b130:	10c00084 	addi	r3,r2,2
 822b134:	e0bffe17 	ldw	r2,-8(fp)
 822b138:	10800f24 	muli	r2,r2,60
 822b13c:	11000504 	addi	r4,r2,20
 822b140:	008209b4 	movhi	r2,2086
 822b144:	10b86304 	addi	r2,r2,-7796
 822b148:	2085883a 	add	r2,r4,r2
 822b14c:	10800044 	addi	r2,r2,1
 822b150:	10800003 	ldbu	r2,0(r2)
 822b154:	18800005 	stb	r2,0(r3)
 822b158:	e0bff617 	ldw	r2,-40(fp)
 822b15c:	10c00044 	addi	r3,r2,1
 822b160:	e0bffe17 	ldw	r2,-8(fp)
 822b164:	10800f24 	muli	r2,r2,60
 822b168:	11000504 	addi	r4,r2,20
 822b16c:	008209b4 	movhi	r2,2086
 822b170:	10b86304 	addi	r2,r2,-7796
 822b174:	2085883a 	add	r2,r4,r2
 822b178:	10800084 	addi	r2,r2,2
 822b17c:	10800003 	ldbu	r2,0(r2)
 822b180:	18800005 	stb	r2,0(r3)
 822b184:	e0bffe17 	ldw	r2,-8(fp)
 822b188:	10800f24 	muli	r2,r2,60
 822b18c:	10c00504 	addi	r3,r2,20
 822b190:	008209b4 	movhi	r2,2086
 822b194:	10b86304 	addi	r2,r2,-7796
 822b198:	1885883a 	add	r2,r3,r2
 822b19c:	108000c4 	addi	r2,r2,3
 822b1a0:	10800003 	ldbu	r2,0(r2)
 822b1a4:	1007883a 	mov	r3,r2
 822b1a8:	e0bff617 	ldw	r2,-40(fp)
 822b1ac:	10c00005 	stb	r3,0(r2)
 822b1b0:	e0bff617 	ldw	r2,-40(fp)
 822b1b4:	10800104 	addi	r2,r2,4
 822b1b8:	e0bff615 	stw	r2,-40(fp)
   }

   /* If there is a list of options to be requested from server, include it*/
#ifdef DHCP_REQLIST
   if ( reqlist_len > 0 )
 822b1bc:	d0a03517 	ldw	r2,-32556(gp)
 822b1c0:	00801a0e 	bge	zero,r2,822b22c <dhc_request+0x6c8>
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
 822b1c4:	e0bff617 	ldw	r2,-40(fp)
 822b1c8:	10c00044 	addi	r3,r2,1
 822b1cc:	e0fff615 	stw	r3,-40(fp)
 822b1d0:	00c00dc4 	movi	r3,55
 822b1d4:	10c00005 	stb	r3,0(r2)
      *opts++ = (u_char)reqlist_len ;
 822b1d8:	e0bff617 	ldw	r2,-40(fp)
 822b1dc:	10c00044 	addi	r3,r2,1
 822b1e0:	e0fff615 	stw	r3,-40(fp)
 822b1e4:	d0e03517 	ldw	r3,-32556(gp)
 822b1e8:	10c00005 	stb	r3,0(r2)

      for (i=0 ; i < reqlist_len ; i++ )
 822b1ec:	e03ff715 	stw	zero,-36(fp)
 822b1f0:	00000b06 	br	822b220 <dhc_request+0x6bc>
         *opts++ = reqlist[i];
 822b1f4:	e0bff617 	ldw	r2,-40(fp)
 822b1f8:	10c00044 	addi	r3,r2,1
 822b1fc:	e0fff615 	stw	r3,-40(fp)
 822b200:	e13ff717 	ldw	r4,-36(fp)
 822b204:	d0e03404 	addi	r3,gp,-32560
 822b208:	20c7883a 	add	r3,r4,r3
 822b20c:	18c00003 	ldbu	r3,0(r3)
 822b210:	10c00005 	stb	r3,0(r2)
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
      *opts++ = (u_char)reqlist_len ;

      for (i=0 ; i < reqlist_len ; i++ )
 822b214:	e0bff717 	ldw	r2,-36(fp)
 822b218:	10800044 	addi	r2,r2,1
 822b21c:	e0bff715 	stw	r2,-36(fp)
 822b220:	d0a03517 	ldw	r2,-32556(gp)
 822b224:	e0fff717 	ldw	r3,-36(fp)
 822b228:	18bff216 	blt	r3,r2,822b1f4 <dhc_request+0x690>
         *opts++ = reqlist[i];
   }
#endif   /* DHCP_REQLIST */

   /* only set client IP address (ours) when renewing or rebinding */
   if ((dhc_states[iface].state == DHCS_RENEWING)
 822b22c:	008209b4 	movhi	r2,2086
 822b230:	10b86304 	addi	r2,r2,-7796
 822b234:	e0fffe17 	ldw	r3,-8(fp)
 822b238:	18c00f24 	muli	r3,r3,60
 822b23c:	10c5883a 	add	r2,r2,r3
 822b240:	10800017 	ldw	r2,0(r2)
 822b244:	108001e0 	cmpeqi	r2,r2,7
 822b248:	1000081e 	bne	r2,zero,822b26c <dhc_request+0x708>
       || (dhc_states[iface].state == DHCS_REBINDING))
 822b24c:	008209b4 	movhi	r2,2086
 822b250:	10b86304 	addi	r2,r2,-7796
 822b254:	e0fffe17 	ldw	r3,-8(fp)
 822b258:	18c00f24 	muli	r3,r3,60
 822b25c:	10c5883a 	add	r2,r2,r3
 822b260:	10800017 	ldw	r2,0(r2)
 822b264:	10800218 	cmpnei	r2,r2,8
 822b268:	10000a1e 	bne	r2,zero,822b294 <dhc_request+0x730>
   {
      outbp->ciaddr = nets[iface]->n_ipaddr;
 822b26c:	008209b4 	movhi	r2,2086
 822b270:	10b83d04 	addi	r2,r2,-7948
 822b274:	e0fffe17 	ldw	r3,-8(fp)
 822b278:	18c7883a 	add	r3,r3,r3
 822b27c:	18c7883a 	add	r3,r3,r3
 822b280:	10c5883a 	add	r2,r2,r3
 822b284:	10800017 	ldw	r2,0(r2)
 822b288:	10c00a17 	ldw	r3,40(r2)
 822b28c:	e0bff917 	ldw	r2,-28(fp)
 822b290:	10c00315 	stw	r3,12(r2)
    * "Client inserts the address of the selected server in 'server 
    * identifier'. . . ." RFC 951, p. 4 definition of 'siaddr' is 
    * "server IP address; returned in bootreply by server." 
    */
   /* Only include server identifier option when selecting a server. */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 822b294:	008209b4 	movhi	r2,2086
 822b298:	10b86304 	addi	r2,r2,-7796
 822b29c:	e0fffe17 	ldw	r3,-8(fp)
 822b2a0:	18c00f24 	muli	r3,r3,60
 822b2a4:	10c5883a 	add	r2,r2,r3
 822b2a8:	10800017 	ldw	r2,0(r2)
 822b2ac:	10800120 	cmpeqi	r2,r2,4
 822b2b0:	1000081e 	bne	r2,zero,822b2d4 <dhc_request+0x770>
       (dhc_states[iface].state == DHCS_REQUESTING))
 822b2b4:	008209b4 	movhi	r2,2086
 822b2b8:	10b86304 	addi	r2,r2,-7796
 822b2bc:	e0fffe17 	ldw	r3,-8(fp)
 822b2c0:	18c00f24 	muli	r3,r3,60
 822b2c4:	10c5883a 	add	r2,r2,r3
 822b2c8:	10800017 	ldw	r2,0(r2)
    * "Client inserts the address of the selected server in 'server 
    * identifier'. . . ." RFC 951, p. 4 definition of 'siaddr' is 
    * "server IP address; returned in bootreply by server." 
    */
   /* Only include server identifier option when selecting a server. */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 822b2cc:	10800158 	cmpnei	r2,r2,5
 822b2d0:	10004a1e 	bne	r2,zero,822b3fc <dhc_request+0x898>
       (dhc_states[iface].state == DHCS_REQUESTING))
   {
      opt_ip = ntohl(dhc_states[iface].srv_ipaddr);
 822b2d4:	008209b4 	movhi	r2,2086
 822b2d8:	10b86304 	addi	r2,r2,-7796
 822b2dc:	e0fffe17 	ldw	r3,-8(fp)
 822b2e0:	18c00f24 	muli	r3,r3,60
 822b2e4:	10c5883a 	add	r2,r2,r3
 822b2e8:	10800d04 	addi	r2,r2,52
 822b2ec:	10800017 	ldw	r2,0(r2)
 822b2f0:	1006d63a 	srli	r3,r2,24
 822b2f4:	008209b4 	movhi	r2,2086
 822b2f8:	10b86304 	addi	r2,r2,-7796
 822b2fc:	e13ffe17 	ldw	r4,-8(fp)
 822b300:	21000f24 	muli	r4,r4,60
 822b304:	1105883a 	add	r2,r2,r4
 822b308:	10800d04 	addi	r2,r2,52
 822b30c:	10800017 	ldw	r2,0(r2)
 822b310:	1004d23a 	srli	r2,r2,8
 822b314:	10bfc00c 	andi	r2,r2,65280
 822b318:	1886b03a 	or	r3,r3,r2
 822b31c:	008209b4 	movhi	r2,2086
 822b320:	10b86304 	addi	r2,r2,-7796
 822b324:	e13ffe17 	ldw	r4,-8(fp)
 822b328:	21000f24 	muli	r4,r4,60
 822b32c:	1105883a 	add	r2,r2,r4
 822b330:	10800d04 	addi	r2,r2,52
 822b334:	10800017 	ldw	r2,0(r2)
 822b338:	10bfc00c 	andi	r2,r2,65280
 822b33c:	1004923a 	slli	r2,r2,8
 822b340:	1886b03a 	or	r3,r3,r2
 822b344:	008209b4 	movhi	r2,2086
 822b348:	10b86304 	addi	r2,r2,-7796
 822b34c:	e13ffe17 	ldw	r4,-8(fp)
 822b350:	21000f24 	muli	r4,r4,60
 822b354:	1105883a 	add	r2,r2,r4
 822b358:	10800d04 	addi	r2,r2,52
 822b35c:	10800017 	ldw	r2,0(r2)
 822b360:	1004963a 	slli	r2,r2,24
 822b364:	1884b03a 	or	r2,r3,r2
 822b368:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_SERVER, opt_ip);
 822b36c:	e0bff617 	ldw	r2,-40(fp)
 822b370:	10c00044 	addi	r3,r2,1
 822b374:	e0fff615 	stw	r3,-40(fp)
 822b378:	00c00d84 	movi	r3,54
 822b37c:	10c00005 	stb	r3,0(r2)
 822b380:	e0bff617 	ldw	r2,-40(fp)
 822b384:	10c00044 	addi	r3,r2,1
 822b388:	e0fff615 	stw	r3,-40(fp)
 822b38c:	00c00104 	movi	r3,4
 822b390:	10c00005 	stb	r3,0(r2)
 822b394:	e0bff617 	ldw	r2,-40(fp)
 822b398:	108000c4 	addi	r2,r2,3
 822b39c:	e0fffd04 	addi	r3,fp,-12
 822b3a0:	18c00003 	ldbu	r3,0(r3)
 822b3a4:	10c00005 	stb	r3,0(r2)
 822b3a8:	e0bff617 	ldw	r2,-40(fp)
 822b3ac:	10c00084 	addi	r3,r2,2
 822b3b0:	e0bffd04 	addi	r2,fp,-12
 822b3b4:	10800044 	addi	r2,r2,1
 822b3b8:	10800003 	ldbu	r2,0(r2)
 822b3bc:	18800005 	stb	r2,0(r3)
 822b3c0:	e0bff617 	ldw	r2,-40(fp)
 822b3c4:	10c00044 	addi	r3,r2,1
 822b3c8:	e0bffd04 	addi	r2,fp,-12
 822b3cc:	10800084 	addi	r2,r2,2
 822b3d0:	10800003 	ldbu	r2,0(r2)
 822b3d4:	18800005 	stb	r2,0(r3)
 822b3d8:	e0bffd04 	addi	r2,fp,-12
 822b3dc:	108000c4 	addi	r2,r2,3
 822b3e0:	10800003 	ldbu	r2,0(r2)
 822b3e4:	1007883a 	mov	r3,r2
 822b3e8:	e0bff617 	ldw	r2,-40(fp)
 822b3ec:	10c00005 	stb	r3,0(r2)
 822b3f0:	e0bff617 	ldw	r2,-40(fp)
 822b3f4:	10800104 	addi	r2,r2,4
 822b3f8:	e0bff615 	stw	r2,-40(fp)
   /* add hostname (code 12) */
   PUT_STRING_OPT(opts, 12, dhc_hostname()); 
#endif /* USE_AUTOIP */

   /* Client Fully Qualified Domain Name */
   PUT_STRING_OPT(opts, 81, DC_DOMAINNAME); 
 822b3fc:	e0bff617 	ldw	r2,-40(fp)
 822b400:	10c00044 	addi	r3,r2,1
 822b404:	e0fff615 	stw	r3,-40(fp)
 822b408:	00c01444 	movi	r3,81
 822b40c:	10c00005 	stb	r3,0(r2)
 822b410:	00800184 	movi	r2,6
 822b414:	e0bffb15 	stw	r2,-20(fp)
 822b418:	e0bff617 	ldw	r2,-40(fp)
 822b41c:	10c00044 	addi	r3,r2,1
 822b420:	e0fff615 	stw	r3,-40(fp)
 822b424:	e0fffb17 	ldw	r3,-20(fp)
 822b428:	10c00005 	stb	r3,0(r2)
 822b42c:	e0bffb17 	ldw	r2,-20(fp)
 822b430:	100d883a 	mov	r6,r2
 822b434:	01420974 	movhi	r5,2085
 822b438:	29423b04 	addi	r5,r5,2284
 822b43c:	e13ff617 	ldw	r4,-40(fp)
 822b440:	824b8740 	call	824b874 <strncpy>
 822b444:	e0bffb17 	ldw	r2,-20(fp)
 822b448:	e0fff617 	ldw	r3,-40(fp)
 822b44c:	1885883a 	add	r2,r3,r2
 822b450:	e0bff615 	stw	r2,-40(fp)
   /* Vendor Class Identifier */
   PUT_STRING_OPT(opts, 60, name); 
 822b454:	e0bff617 	ldw	r2,-40(fp)
 822b458:	10c00044 	addi	r3,r2,1
 822b45c:	e0fff615 	stw	r3,-40(fp)
 822b460:	00c00f04 	movi	r3,60
 822b464:	10c00005 	stb	r3,0(r2)
 822b468:	d0a04b17 	ldw	r2,-32468(gp)
 822b46c:	1009883a 	mov	r4,r2
 822b470:	8203fbc0 	call	8203fbc <strlen>
 822b474:	e0bffc15 	stw	r2,-16(fp)
 822b478:	e0bff617 	ldw	r2,-40(fp)
 822b47c:	10c00044 	addi	r3,r2,1
 822b480:	e0fff615 	stw	r3,-40(fp)
 822b484:	e0fffc17 	ldw	r3,-16(fp)
 822b488:	10c00005 	stb	r3,0(r2)
 822b48c:	d0a04b17 	ldw	r2,-32468(gp)
 822b490:	e0fffc17 	ldw	r3,-16(fp)
 822b494:	180d883a 	mov	r6,r3
 822b498:	100b883a 	mov	r5,r2
 822b49c:	e13ff617 	ldw	r4,-40(fp)
 822b4a0:	824b8740 	call	824b874 <strncpy>
 822b4a4:	e0bffc17 	ldw	r2,-16(fp)
 822b4a8:	e0fff617 	ldw	r3,-40(fp)
 822b4ac:	1885883a 	add	r2,r3,r2
 822b4b0:	e0bff615 	stw	r2,-40(fp)

   *opts++ = DHOP_END;  /* Mark the end of options */
 822b4b4:	e0bff617 	ldw	r2,-40(fp)
 822b4b8:	10c00044 	addi	r3,r2,1
 822b4bc:	e0fff615 	stw	r3,-40(fp)
 822b4c0:	00ffffc4 	movi	r3,-1
 822b4c4:	10c00005 	stb	r3,0(r2)

   /* figure out whether to send via unicast or broadcast */
   if (dhc_states[iface].state == DHCS_RENEWING)
 822b4c8:	008209b4 	movhi	r2,2086
 822b4cc:	10b86304 	addi	r2,r2,-7796
 822b4d0:	e0fffe17 	ldw	r3,-8(fp)
 822b4d4:	18c00f24 	muli	r3,r3,60
 822b4d8:	10c5883a 	add	r2,r2,r3
 822b4dc:	10800017 	ldw	r2,0(r2)
 822b4e0:	108001d8 	cmpnei	r2,r2,7
 822b4e4:	10000a1e 	bne	r2,zero,822b510 <dhc_request+0x9ac>
   {
      pkt->fhost = dhc_states[iface].srv_ipaddr;
 822b4e8:	008209b4 	movhi	r2,2086
 822b4ec:	10b86304 	addi	r2,r2,-7796
 822b4f0:	e0fffe17 	ldw	r3,-8(fp)
 822b4f4:	18c00f24 	muli	r3,r3,60
 822b4f8:	10c5883a 	add	r2,r2,r3
 822b4fc:	10800d04 	addi	r2,r2,52
 822b500:	10c00017 	ldw	r3,0(r2)
 822b504:	e0bff817 	ldw	r2,-32(fp)
 822b508:	10c00715 	stw	r3,28(r2)
 822b50c:	00000306 	br	822b51c <dhc_request+0x9b8>
   }
   else
   {
      pkt->fhost = 0xFFFFFFFF;   /* broadcast request */
 822b510:	e0bff817 	ldw	r2,-32(fp)
 822b514:	00ffffc4 	movi	r3,-1
 822b518:	10c00715 	stw	r3,28(r2)
   }

   pkt->net = nets[iface];    /* send out caller spec'ed net */
 822b51c:	008209b4 	movhi	r2,2086
 822b520:	10b83d04 	addi	r2,r2,-7948
 822b524:	e0fffe17 	ldw	r3,-8(fp)
 822b528:	18c7883a 	add	r3,r3,r3
 822b52c:	18c7883a 	add	r3,r3,r3
 822b530:	10c5883a 	add	r2,r2,r3
 822b534:	10c00017 	ldw	r3,0(r2)
 822b538:	e0bff817 	ldw	r2,-32(fp)
 822b53c:	10c00615 	stw	r3,24(r2)
   pkt->nb_plen = (char *)opts - (char *)outbp;
 822b540:	e0fff617 	ldw	r3,-40(fp)
 822b544:	e0bff917 	ldw	r2,-28(fp)
 822b548:	1885c83a 	sub	r2,r3,r2
 822b54c:	1007883a 	mov	r3,r2
 822b550:	e0bff817 	ldw	r2,-32(fp)
 822b554:	10c00415 	stw	r3,16(r2)
   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 822b558:	e1bff817 	ldw	r6,-32(fp)
 822b55c:	01401104 	movi	r5,68
 822b560:	010010c4 	movi	r4,67
 822b564:	82450080 	call	8245008 <udp_send>
   dsc_requests++;
 822b568:	d0a09317 	ldw	r2,-32180(gp)
 822b56c:	10800044 	addi	r2,r2,1
 822b570:	d0a09315 	stw	r2,-32180(gp)

   dhc_states[iface].last_tick = cticks;
 822b574:	d0e0a817 	ldw	r3,-32096(gp)
 822b578:	008209b4 	movhi	r2,2086
 822b57c:	10b86304 	addi	r2,r2,-7796
 822b580:	e13ffe17 	ldw	r4,-8(fp)
 822b584:	21000f24 	muli	r4,r4,60
 822b588:	1105883a 	add	r2,r2,r4
 822b58c:	10800404 	addi	r2,r2,16
 822b590:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].tries++;
 822b594:	008209b4 	movhi	r2,2086
 822b598:	10b86304 	addi	r2,r2,-7796
 822b59c:	e0fffe17 	ldw	r3,-8(fp)
 822b5a0:	18c00f24 	muli	r3,r3,60
 822b5a4:	10c5883a 	add	r2,r2,r3
 822b5a8:	10800104 	addi	r2,r2,4
 822b5ac:	10800017 	ldw	r2,0(r2)
 822b5b0:	10c00044 	addi	r3,r2,1
 822b5b4:	008209b4 	movhi	r2,2086
 822b5b8:	10b86304 	addi	r2,r2,-7796
 822b5bc:	e13ffe17 	ldw	r4,-8(fp)
 822b5c0:	21000f24 	muli	r4,r4,60
 822b5c4:	1105883a 	add	r2,r2,r4
 822b5c8:	10800104 	addi	r2,r2,4
 822b5cc:	10c00015 	stw	r3,0(r2)

   return 0;   /* return OK code */
 822b5d0:	0005883a 	mov	r2,zero
}
 822b5d4:	e037883a 	mov	sp,fp
 822b5d8:	dfc00117 	ldw	ra,4(sp)
 822b5dc:	df000017 	ldw	fp,0(sp)
 822b5e0:	dec00204 	addi	sp,sp,8
 822b5e4:	f800283a 	ret

0822b5e8 <dhc_setip>:
 * RETURNS: Returns 0 if ok, else non-zero ENP error.
 */

int
dhc_setip(int iface)
{
 822b5e8:	defffd04 	addi	sp,sp,-12
 822b5ec:	dfc00215 	stw	ra,8(sp)
 822b5f0:	df000115 	stw	fp,4(sp)
 822b5f4:	df000104 	addi	fp,sp,4
 822b5f8:	e13fff15 	stw	r4,-4(fp)
   nets[iface]->n_ipaddr = dhc_states[iface].ipaddr;
 822b5fc:	008209b4 	movhi	r2,2086
 822b600:	10b83d04 	addi	r2,r2,-7948
 822b604:	e0ffff17 	ldw	r3,-4(fp)
 822b608:	18c7883a 	add	r3,r3,r3
 822b60c:	18c7883a 	add	r3,r3,r3
 822b610:	10c5883a 	add	r2,r2,r3
 822b614:	10c00017 	ldw	r3,0(r2)
 822b618:	008209b4 	movhi	r2,2086
 822b61c:	10b86304 	addi	r2,r2,-7796
 822b620:	e13fff17 	ldw	r4,-4(fp)
 822b624:	21000f24 	muli	r4,r4,60
 822b628:	1105883a 	add	r2,r2,r4
 822b62c:	10800904 	addi	r2,r2,36
 822b630:	10800017 	ldw	r2,0(r2)
 822b634:	18800a15 	stw	r2,40(r3)
   nets[iface]->snmask   = dhc_states[iface].snmask;
 822b638:	008209b4 	movhi	r2,2086
 822b63c:	10b83d04 	addi	r2,r2,-7948
 822b640:	e0ffff17 	ldw	r3,-4(fp)
 822b644:	18c7883a 	add	r3,r3,r3
 822b648:	18c7883a 	add	r3,r3,r3
 822b64c:	10c5883a 	add	r2,r2,r3
 822b650:	10c00017 	ldw	r3,0(r2)
 822b654:	008209b4 	movhi	r2,2086
 822b658:	10b86304 	addi	r2,r2,-7796
 822b65c:	e13fff17 	ldw	r4,-4(fp)
 822b660:	21000f24 	muli	r4,r4,60
 822b664:	1105883a 	add	r2,r2,r4
 822b668:	10800a04 	addi	r2,r2,40
 822b66c:	10800017 	ldw	r2,0(r2)
 822b670:	18800c15 	stw	r2,48(r3)
   nets[iface]->n_defgw  = dhc_states[iface].defgw;
 822b674:	008209b4 	movhi	r2,2086
 822b678:	10b83d04 	addi	r2,r2,-7948
 822b67c:	e0ffff17 	ldw	r3,-4(fp)
 822b680:	18c7883a 	add	r3,r3,r3
 822b684:	18c7883a 	add	r3,r3,r3
 822b688:	10c5883a 	add	r2,r2,r3
 822b68c:	10c00017 	ldw	r3,0(r2)
 822b690:	008209b4 	movhi	r2,2086
 822b694:	10b86304 	addi	r2,r2,-7796
 822b698:	e13fff17 	ldw	r4,-4(fp)
 822b69c:	21000f24 	muli	r4,r4,60
 822b6a0:	1105883a 	add	r2,r2,r4
 822b6a4:	10800b04 	addi	r2,r2,44
 822b6a8:	10800017 	ldw	r2,0(r2)
 822b6ac:	18800d15 	stw	r2,52(r3)

   if ( nets[iface]->snmask == 0 )
 822b6b0:	008209b4 	movhi	r2,2086
 822b6b4:	10b83d04 	addi	r2,r2,-7948
 822b6b8:	e0ffff17 	ldw	r3,-4(fp)
 822b6bc:	18c7883a 	add	r3,r3,r3
 822b6c0:	18c7883a 	add	r3,r3,r3
 822b6c4:	10c5883a 	add	r2,r2,r3
 822b6c8:	10800017 	ldw	r2,0(r2)
 822b6cc:	10800c17 	ldw	r2,48(r2)
 822b6d0:	1000111e 	bne	r2,zero,822b718 <dhc_setip+0x130>
   {
      fixup_subnet_mask(iface);
 822b6d4:	e13fff17 	ldw	r4,-4(fp)
 822b6d8:	82260e40 	call	82260e4 <fixup_subnet_mask>
      dhc_states[iface].snmask = nets[iface]->snmask; 
 822b6dc:	008209b4 	movhi	r2,2086
 822b6e0:	10b83d04 	addi	r2,r2,-7948
 822b6e4:	e0ffff17 	ldw	r3,-4(fp)
 822b6e8:	18c7883a 	add	r3,r3,r3
 822b6ec:	18c7883a 	add	r3,r3,r3
 822b6f0:	10c5883a 	add	r2,r2,r3
 822b6f4:	10800017 	ldw	r2,0(r2)
 822b6f8:	10c00c17 	ldw	r3,48(r2)
 822b6fc:	008209b4 	movhi	r2,2086
 822b700:	10b86304 	addi	r2,r2,-7796
 822b704:	e13fff17 	ldw	r4,-4(fp)
 822b708:	21000f24 	muli	r4,r4,60
 822b70c:	1105883a 	add	r2,r2,r4
 822b710:	10800a04 	addi	r2,r2,40
 822b714:	10c00015 	stw	r3,0(r2)
   }

   /* fixup broadcast addresses */
   nets[iface]->n_netbr    = nets[iface]->n_ipaddr | ~nets[iface]->snmask;
 822b718:	008209b4 	movhi	r2,2086
 822b71c:	10b83d04 	addi	r2,r2,-7948
 822b720:	e0ffff17 	ldw	r3,-4(fp)
 822b724:	18c7883a 	add	r3,r3,r3
 822b728:	18c7883a 	add	r3,r3,r3
 822b72c:	10c5883a 	add	r2,r2,r3
 822b730:	11000017 	ldw	r4,0(r2)
 822b734:	008209b4 	movhi	r2,2086
 822b738:	10b83d04 	addi	r2,r2,-7948
 822b73c:	e0ffff17 	ldw	r3,-4(fp)
 822b740:	18c7883a 	add	r3,r3,r3
 822b744:	18c7883a 	add	r3,r3,r3
 822b748:	10c5883a 	add	r2,r2,r3
 822b74c:	10800017 	ldw	r2,0(r2)
 822b750:	11400a17 	ldw	r5,40(r2)
 822b754:	008209b4 	movhi	r2,2086
 822b758:	10b83d04 	addi	r2,r2,-7948
 822b75c:	e0ffff17 	ldw	r3,-4(fp)
 822b760:	18c7883a 	add	r3,r3,r3
 822b764:	18c7883a 	add	r3,r3,r3
 822b768:	10c5883a 	add	r2,r2,r3
 822b76c:	10800017 	ldw	r2,0(r2)
 822b770:	10800c17 	ldw	r2,48(r2)
 822b774:	0084303a 	nor	r2,zero,r2
 822b778:	2884b03a 	or	r2,r5,r2
 822b77c:	20800e15 	stw	r2,56(r4)
   nets[iface]->n_netbr42  = nets[iface]->n_ipaddr &  nets[iface]->snmask;
 822b780:	008209b4 	movhi	r2,2086
 822b784:	10b83d04 	addi	r2,r2,-7948
 822b788:	e0ffff17 	ldw	r3,-4(fp)
 822b78c:	18c7883a 	add	r3,r3,r3
 822b790:	18c7883a 	add	r3,r3,r3
 822b794:	10c5883a 	add	r2,r2,r3
 822b798:	11000017 	ldw	r4,0(r2)
 822b79c:	008209b4 	movhi	r2,2086
 822b7a0:	10b83d04 	addi	r2,r2,-7948
 822b7a4:	e0ffff17 	ldw	r3,-4(fp)
 822b7a8:	18c7883a 	add	r3,r3,r3
 822b7ac:	18c7883a 	add	r3,r3,r3
 822b7b0:	10c5883a 	add	r2,r2,r3
 822b7b4:	10800017 	ldw	r2,0(r2)
 822b7b8:	11400a17 	ldw	r5,40(r2)
 822b7bc:	008209b4 	movhi	r2,2086
 822b7c0:	10b83d04 	addi	r2,r2,-7948
 822b7c4:	e0ffff17 	ldw	r3,-4(fp)
 822b7c8:	18c7883a 	add	r3,r3,r3
 822b7cc:	18c7883a 	add	r3,r3,r3
 822b7d0:	10c5883a 	add	r2,r2,r3
 822b7d4:	10800017 	ldw	r2,0(r2)
 822b7d8:	10800c17 	ldw	r2,48(r2)
 822b7dc:	2884703a 	and	r2,r5,r2
 822b7e0:	20800f15 	stw	r2,60(r4)
   nets[iface]->n_subnetbr = nets[iface]->n_ipaddr | ~nets[iface]->snmask;
 822b7e4:	008209b4 	movhi	r2,2086
 822b7e8:	10b83d04 	addi	r2,r2,-7948
 822b7ec:	e0ffff17 	ldw	r3,-4(fp)
 822b7f0:	18c7883a 	add	r3,r3,r3
 822b7f4:	18c7883a 	add	r3,r3,r3
 822b7f8:	10c5883a 	add	r2,r2,r3
 822b7fc:	11000017 	ldw	r4,0(r2)
 822b800:	008209b4 	movhi	r2,2086
 822b804:	10b83d04 	addi	r2,r2,-7948
 822b808:	e0ffff17 	ldw	r3,-4(fp)
 822b80c:	18c7883a 	add	r3,r3,r3
 822b810:	18c7883a 	add	r3,r3,r3
 822b814:	10c5883a 	add	r2,r2,r3
 822b818:	10800017 	ldw	r2,0(r2)
 822b81c:	11400a17 	ldw	r5,40(r2)
 822b820:	008209b4 	movhi	r2,2086
 822b824:	10b83d04 	addi	r2,r2,-7948
 822b828:	e0ffff17 	ldw	r3,-4(fp)
 822b82c:	18c7883a 	add	r3,r3,r3
 822b830:	18c7883a 	add	r3,r3,r3
 822b834:	10c5883a 	add	r2,r2,r3
 822b838:	10800017 	ldw	r2,0(r2)
 822b83c:	10800c17 	ldw	r2,48(r2)
 822b840:	0084303a 	nor	r2,zero,r2
 822b844:	2884b03a 	or	r2,r5,r2
 822b848:	20801015 	stw	r2,64(r4)

   return 0;   /* return OK code */
 822b84c:	0005883a 	mov	r2,zero
}
 822b850:	e037883a 	mov	sp,fp
 822b854:	dfc00117 	ldw	ra,4(sp)
 822b858:	df000017 	ldw	fp,0(sp)
 822b85c:	dec00204 	addi	sp,sp,8
 822b860:	f800283a 	ret

0822b864 <dhc_resetip>:
 * RETURNS: Returns 0 if ok, else non-zero error. 
 */

int
dhc_resetip(int iface)
{
 822b864:	defffe04 	addi	sp,sp,-8
 822b868:	df000115 	stw	fp,4(sp)
 822b86c:	df000104 	addi	fp,sp,4
 822b870:	e13fff15 	stw	r4,-4(fp)
   /* reset the ipaddress */
   nets[iface]->n_ipaddr = 0;
 822b874:	008209b4 	movhi	r2,2086
 822b878:	10b83d04 	addi	r2,r2,-7948
 822b87c:	e0ffff17 	ldw	r3,-4(fp)
 822b880:	18c7883a 	add	r3,r3,r3
 822b884:	18c7883a 	add	r3,r3,r3
 822b888:	10c5883a 	add	r2,r2,r3
 822b88c:	10800017 	ldw	r2,0(r2)
 822b890:	10000a15 	stw	zero,40(r2)
   nets[iface]->snmask   = 0;
 822b894:	008209b4 	movhi	r2,2086
 822b898:	10b83d04 	addi	r2,r2,-7948
 822b89c:	e0ffff17 	ldw	r3,-4(fp)
 822b8a0:	18c7883a 	add	r3,r3,r3
 822b8a4:	18c7883a 	add	r3,r3,r3
 822b8a8:	10c5883a 	add	r2,r2,r3
 822b8ac:	10800017 	ldw	r2,0(r2)
 822b8b0:	10000c15 	stw	zero,48(r2)
   nets[iface]->n_defgw  = 0;
 822b8b4:	008209b4 	movhi	r2,2086
 822b8b8:	10b83d04 	addi	r2,r2,-7948
 822b8bc:	e0ffff17 	ldw	r3,-4(fp)
 822b8c0:	18c7883a 	add	r3,r3,r3
 822b8c4:	18c7883a 	add	r3,r3,r3
 822b8c8:	10c5883a 	add	r2,r2,r3
 822b8cc:	10800017 	ldw	r2,0(r2)
 822b8d0:	10000d15 	stw	zero,52(r2)

   /* reset the broadcast addresses */
   nets[iface]->n_netbr    = 0;
 822b8d4:	008209b4 	movhi	r2,2086
 822b8d8:	10b83d04 	addi	r2,r2,-7948
 822b8dc:	e0ffff17 	ldw	r3,-4(fp)
 822b8e0:	18c7883a 	add	r3,r3,r3
 822b8e4:	18c7883a 	add	r3,r3,r3
 822b8e8:	10c5883a 	add	r2,r2,r3
 822b8ec:	10800017 	ldw	r2,0(r2)
 822b8f0:	10000e15 	stw	zero,56(r2)
   nets[iface]->n_netbr42  = 0;
 822b8f4:	008209b4 	movhi	r2,2086
 822b8f8:	10b83d04 	addi	r2,r2,-7948
 822b8fc:	e0ffff17 	ldw	r3,-4(fp)
 822b900:	18c7883a 	add	r3,r3,r3
 822b904:	18c7883a 	add	r3,r3,r3
 822b908:	10c5883a 	add	r2,r2,r3
 822b90c:	10800017 	ldw	r2,0(r2)
 822b910:	10000f15 	stw	zero,60(r2)
   nets[iface]->n_subnetbr = 0;
 822b914:	008209b4 	movhi	r2,2086
 822b918:	10b83d04 	addi	r2,r2,-7948
 822b91c:	e0ffff17 	ldw	r3,-4(fp)
 822b920:	18c7883a 	add	r3,r3,r3
 822b924:	18c7883a 	add	r3,r3,r3
 822b928:	10c5883a 	add	r2,r2,r3
 822b92c:	10800017 	ldw	r2,0(r2)
 822b930:	10001015 	stw	zero,64(r2)

   return 0;   /* return OK code */
 822b934:	0005883a 	mov	r2,zero
}
 822b938:	e037883a 	mov	sp,fp
 822b93c:	df000017 	ldw	fp,0(sp)
 822b940:	dec00104 	addi	sp,sp,4
 822b944:	f800283a 	ret

0822b948 <dhc_decline>:
 * RETURNS: Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_decline(int iface,struct bootp * bp, unsigned bplen)
{
 822b948:	defff804 	addi	sp,sp,-32
 822b94c:	dfc00715 	stw	ra,28(sp)
 822b950:	df000615 	stw	fp,24(sp)
 822b954:	df000604 	addi	fp,sp,24
 822b958:	e13ffd15 	stw	r4,-12(fp)
 822b95c:	e17ffe15 	stw	r5,-8(fp)
 822b960:	e1bfff15 	stw	r6,-4(fp)
   struct bootp * outbp;
   PACKET pkt;
   u_char * opts;    /* scratch pointer to DHCP options field */

   /* get a UDP packet buffer for sending DHCP */
   pkt = udp_alloc(bplen, 0);
 822b964:	e0bfff17 	ldw	r2,-4(fp)
 822b968:	000b883a 	mov	r5,zero
 822b96c:	1009883a 	mov	r4,r2
 822b970:	82454440 	call	8245444 <udp_alloc>
 822b974:	e0bffa15 	stw	r2,-24(fp)
   if (!pkt) 
 822b978:	e0bffa17 	ldw	r2,-24(fp)
 822b97c:	1000021e 	bne	r2,zero,822b988 <dhc_decline+0x40>
      return ENP_NOMEM;
 822b980:	00bffb04 	movi	r2,-20
 822b984:	00002d06 	br	822ba3c <dhc_decline+0xf4>
   pkt->nb_plen = bplen;
 822b988:	e0bffa17 	ldw	r2,-24(fp)
 822b98c:	e0ffff17 	ldw	r3,-4(fp)
 822b990:	10c00415 	stw	r3,16(r2)

   outbp = (struct bootp *)pkt->nb_prot;
 822b994:	e0bffa17 	ldw	r2,-24(fp)
 822b998:	10800317 	ldw	r2,12(r2)
 822b99c:	e0bffb15 	stw	r2,-20(fp)
   MEMCPY(outbp, bp, bplen);
 822b9a0:	e1bfff17 	ldw	r6,-4(fp)
 822b9a4:	e17ffe17 	ldw	r5,-8(fp)
 822b9a8:	e13ffb17 	ldw	r4,-20(fp)
 822b9ac:	8202f6c0 	call	8202f6c <memcpy>
   outbp->op = BOOTREQUEST;
 822b9b0:	e0bffb17 	ldw	r2,-20(fp)
 822b9b4:	00c00044 	movi	r3,1
 822b9b8:	10c00005 	stb	r3,0(r2)

   /* find DHCP TYPE option so we can overwrite it */   
   opts = find_opt(DHOP_TYPE, &outbp->options[4]);
 822b9bc:	e0bffb17 	ldw	r2,-20(fp)
 822b9c0:	10803c04 	addi	r2,r2,240
 822b9c4:	100b883a 	mov	r5,r2
 822b9c8:	01000d44 	movi	r4,53
 822b9cc:	822c6ec0 	call	822c6ec <find_opt>
 822b9d0:	e0bffc15 	stw	r2,-16(fp)
   opts += 2;     /* point to actual op code */
 822b9d4:	e0bffc17 	ldw	r2,-16(fp)
 822b9d8:	10800084 	addi	r2,r2,2
 822b9dc:	e0bffc15 	stw	r2,-16(fp)
   *opts = DHCP_DECLINE;   /* overwrite op code */
 822b9e0:	e0bffc17 	ldw	r2,-16(fp)
 822b9e4:	00c00104 	movi	r3,4
 822b9e8:	10c00005 	stb	r3,0(r2)

   pkt->fhost = 0xFFFFFFFF;   /* broadcast decline pkt */
 822b9ec:	e0bffa17 	ldw	r2,-24(fp)
 822b9f0:	00ffffc4 	movi	r3,-1
 822b9f4:	10c00715 	stw	r3,28(r2)
   pkt->net = nets[iface];    /* send out caller speced net */
 822b9f8:	008209b4 	movhi	r2,2086
 822b9fc:	10b83d04 	addi	r2,r2,-7948
 822ba00:	e0fffd17 	ldw	r3,-12(fp)
 822ba04:	18c7883a 	add	r3,r3,r3
 822ba08:	18c7883a 	add	r3,r3,r3
 822ba0c:	10c5883a 	add	r2,r2,r3
 822ba10:	10c00017 	ldw	r3,0(r2)
 822ba14:	e0bffa17 	ldw	r2,-24(fp)
 822ba18:	10c00615 	stw	r3,24(r2)
   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 822ba1c:	e1bffa17 	ldw	r6,-24(fp)
 822ba20:	01401104 	movi	r5,68
 822ba24:	010010c4 	movi	r4,67
 822ba28:	82450080 	call	8245008 <udp_send>
   dsc_declines++;   /* count declines sent */
 822ba2c:	d0a09617 	ldw	r2,-32168(gp)
 822ba30:	10800044 	addi	r2,r2,1
 822ba34:	d0a09615 	stw	r2,-32168(gp)
   return 0;
 822ba38:	0005883a 	mov	r2,zero
}
 822ba3c:	e037883a 	mov	sp,fp
 822ba40:	dfc00117 	ldw	ra,4(sp)
 822ba44:	df000017 	ldw	fp,0(sp)
 822ba48:	dec00204 	addi	sp,sp,8
 822ba4c:	f800283a 	ret

0822ba50 <dh_getlong>:
 *
 * RETURNS: the extracted 32 bit value
 */

static   long dh_getlong( u_char *ptr )
{
 822ba50:	defffc04 	addi	sp,sp,-16
 822ba54:	df000315 	stw	fp,12(sp)
 822ba58:	df000304 	addi	fp,sp,12
 822ba5c:	e13fff15 	stw	r4,-4(fp)
     long  v;
     u_char * p2 =  (u_char *)&v;
 822ba60:	e0bffe04 	addi	r2,fp,-8
 822ba64:	e0bffd15 	stw	r2,-12(fp)

   *p2++ = *ptr++;
 822ba68:	e0bffd17 	ldw	r2,-12(fp)
 822ba6c:	10c00044 	addi	r3,r2,1
 822ba70:	e0fffd15 	stw	r3,-12(fp)
 822ba74:	e0ffff17 	ldw	r3,-4(fp)
 822ba78:	19000044 	addi	r4,r3,1
 822ba7c:	e13fff15 	stw	r4,-4(fp)
 822ba80:	18c00003 	ldbu	r3,0(r3)
 822ba84:	10c00005 	stb	r3,0(r2)
   *p2++ = *ptr++;
 822ba88:	e0bffd17 	ldw	r2,-12(fp)
 822ba8c:	10c00044 	addi	r3,r2,1
 822ba90:	e0fffd15 	stw	r3,-12(fp)
 822ba94:	e0ffff17 	ldw	r3,-4(fp)
 822ba98:	19000044 	addi	r4,r3,1
 822ba9c:	e13fff15 	stw	r4,-4(fp)
 822baa0:	18c00003 	ldbu	r3,0(r3)
 822baa4:	10c00005 	stb	r3,0(r2)
   *p2++ = *ptr++;
 822baa8:	e0bffd17 	ldw	r2,-12(fp)
 822baac:	10c00044 	addi	r3,r2,1
 822bab0:	e0fffd15 	stw	r3,-12(fp)
 822bab4:	e0ffff17 	ldw	r3,-4(fp)
 822bab8:	19000044 	addi	r4,r3,1
 822babc:	e13fff15 	stw	r4,-4(fp)
 822bac0:	18c00003 	ldbu	r3,0(r3)
 822bac4:	10c00005 	stb	r3,0(r2)
   *p2++ = *ptr++;
 822bac8:	e0bffd17 	ldw	r2,-12(fp)
 822bacc:	10c00044 	addi	r3,r2,1
 822bad0:	e0fffd15 	stw	r3,-12(fp)
 822bad4:	e0ffff17 	ldw	r3,-4(fp)
 822bad8:	19000044 	addi	r4,r3,1
 822badc:	e13fff15 	stw	r4,-4(fp)
 822bae0:	18c00003 	ldbu	r3,0(r3)
 822bae4:	10c00005 	stb	r3,0(r2)

   return v;
 822bae8:	e0bffe17 	ldw	r2,-8(fp)
}
 822baec:	e037883a 	mov	sp,fp
 822baf0:	df000017 	ldw	fp,0(sp)
 822baf4:	dec00104 	addi	sp,sp,4
 822baf8:	f800283a 	ret

0822bafc <dhc_extract_opts>:
 * of the options passed were filled in with good values. 
 */

int
dhc_extract_opts(int iface, u_char *opts)
{
 822bafc:	defff904 	addi	sp,sp,-28
 822bb00:	dfc00615 	stw	ra,24(sp)
 822bb04:	df000515 	stw	fp,20(sp)
 822bb08:	dc000415 	stw	r16,16(sp)
 822bb0c:	df000504 	addi	fp,sp,20
 822bb10:	e13ffd15 	stw	r4,-12(fp)
 822bb14:	e17ffe15 	stw	r5,-8(fp)
   u_char *end = opts + DHCP_OPTSIZE;  /* limit scope of search */
 822bb18:	e0bffe17 	ldw	r2,-8(fp)
 822bb1c:	10804e04 	addi	r2,r2,312
 822bb20:	e0bffb15 	stw	r2,-20(fp)
   u_char optlen;

   /* first, clear the options */
   dhc_states[iface].snmask = 0; 
 822bb24:	008209b4 	movhi	r2,2086
 822bb28:	10b86304 	addi	r2,r2,-7796
 822bb2c:	e0fffd17 	ldw	r3,-12(fp)
 822bb30:	18c00f24 	muli	r3,r3,60
 822bb34:	10c5883a 	add	r2,r2,r3
 822bb38:	10800a04 	addi	r2,r2,40
 822bb3c:	10000015 	stw	zero,0(r2)
   dhc_states[iface].defgw = 0; 
 822bb40:	008209b4 	movhi	r2,2086
 822bb44:	10b86304 	addi	r2,r2,-7796
 822bb48:	e0fffd17 	ldw	r3,-12(fp)
 822bb4c:	18c00f24 	muli	r3,r3,60
 822bb50:	10c5883a 	add	r2,r2,r3
 822bb54:	10800b04 	addi	r2,r2,44
 822bb58:	10000015 	stw	zero,0(r2)
   dhc_states[iface].lease = 0; 
 822bb5c:	008209b4 	movhi	r2,2086
 822bb60:	10b86304 	addi	r2,r2,-7796
 822bb64:	e0fffd17 	ldw	r3,-12(fp)
 822bb68:	18c00f24 	muli	r3,r3,60
 822bb6c:	10c5883a 	add	r2,r2,r3
 822bb70:	10800504 	addi	r2,r2,20
 822bb74:	10000015 	stw	zero,0(r2)
#if defined(DHC_MAXDNSRVS) && (DHC_MAXDNSRVS > 0)
   MEMSET(dhc_states[iface].dnsrv, 0, sizeof(dhc_states[iface].dnsrv));
#endif   /* DHC_MAXDNSRVS */

   /* then fill them in from the DHCP data */
   while (opts <= end)
 822bb78:	00007106 	br	822bd40 <dhc_extract_opts+0x244>
   {
      switch (*opts++)
 822bb7c:	e0bffe17 	ldw	r2,-8(fp)
 822bb80:	10c00044 	addi	r3,r2,1
 822bb84:	e0fffe15 	stw	r3,-8(fp)
 822bb88:	10800003 	ldbu	r2,0(r2)
 822bb8c:	10803fcc 	andi	r2,r2,255
 822bb90:	10c000e0 	cmpeqi	r3,r2,3
 822bb94:	1800201e 	bne	r3,zero,822bc18 <dhc_extract_opts+0x11c>
 822bb98:	10c00108 	cmpgei	r3,r2,4
 822bb9c:	1800041e 	bne	r3,zero,822bbb0 <dhc_extract_opts+0xb4>
 822bba0:	10006726 	beq	r2,zero,822bd40 <dhc_extract_opts+0x244>
 822bba4:	10800060 	cmpeqi	r2,r2,1
 822bba8:	10000a1e 	bne	r2,zero,822bbd4 <dhc_extract_opts+0xd8>
 822bbac:	00005c06 	br	822bd20 <dhc_extract_opts+0x224>
 822bbb0:	10c00ce0 	cmpeqi	r3,r2,51
 822bbb4:	18002f1e 	bne	r3,zero,822bc74 <dhc_extract_opts+0x178>
 822bbb8:	10c03fe0 	cmpeqi	r3,r2,255
 822bbbc:	1800031e 	bne	r3,zero,822bbcc <dhc_extract_opts+0xd0>
 822bbc0:	108001a0 	cmpeqi	r2,r2,6
 822bbc4:	10004c1e 	bne	r2,zero,822bcf8 <dhc_extract_opts+0x1fc>
 822bbc8:	00005506 	br	822bd20 <dhc_extract_opts+0x224>
      {
      case DHOP_PAD:
         break;
      case DHOP_END:
         return 0;   /* only good exit point */
 822bbcc:	0005883a 	mov	r2,zero
 822bbd0:	00006006 	br	822bd54 <dhc_extract_opts+0x258>
      case DHOP_SNMASK:
         opts++;
 822bbd4:	e0bffe17 	ldw	r2,-8(fp)
 822bbd8:	10800044 	addi	r2,r2,1
 822bbdc:	e0bffe15 	stw	r2,-8(fp)
         dhc_states[iface].snmask = dh_getlong(opts);
 822bbe0:	e13ffe17 	ldw	r4,-8(fp)
 822bbe4:	822ba500 	call	822ba50 <dh_getlong>
 822bbe8:	1009883a 	mov	r4,r2
 822bbec:	008209b4 	movhi	r2,2086
 822bbf0:	10b86304 	addi	r2,r2,-7796
 822bbf4:	e0fffd17 	ldw	r3,-12(fp)
 822bbf8:	18c00f24 	muli	r3,r3,60
 822bbfc:	10c5883a 	add	r2,r2,r3
 822bc00:	10800a04 	addi	r2,r2,40
 822bc04:	11000015 	stw	r4,0(r2)
         opts += 4;
 822bc08:	e0bffe17 	ldw	r2,-8(fp)
 822bc0c:	10800104 	addi	r2,r2,4
 822bc10:	e0bffe15 	stw	r2,-8(fp)
         break;
 822bc14:	00004a06 	br	822bd40 <dhc_extract_opts+0x244>
      case DHOP_ROUTER:
         optlen = *opts++;
 822bc18:	e0bffe17 	ldw	r2,-8(fp)
 822bc1c:	10c00044 	addi	r3,r2,1
 822bc20:	e0fffe15 	stw	r3,-8(fp)
 822bc24:	10800003 	ldbu	r2,0(r2)
 822bc28:	e0bffc05 	stb	r2,-16(fp)
         if (optlen >= 4)
 822bc2c:	e0bffc03 	ldbu	r2,-16(fp)
 822bc30:	10800130 	cmpltui	r2,r2,4
 822bc34:	10000a1e 	bne	r2,zero,822bc60 <dhc_extract_opts+0x164>
            dhc_states[iface].defgw = dh_getlong(opts);
 822bc38:	e13ffe17 	ldw	r4,-8(fp)
 822bc3c:	822ba500 	call	822ba50 <dh_getlong>
 822bc40:	1009883a 	mov	r4,r2
 822bc44:	008209b4 	movhi	r2,2086
 822bc48:	10b86304 	addi	r2,r2,-7796
 822bc4c:	e0fffd17 	ldw	r3,-12(fp)
 822bc50:	18c00f24 	muli	r3,r3,60
 822bc54:	10c5883a 	add	r2,r2,r3
 822bc58:	10800b04 	addi	r2,r2,44
 822bc5c:	11000015 	stw	r4,0(r2)
         opts += optlen;
 822bc60:	e0bffc03 	ldbu	r2,-16(fp)
 822bc64:	e0fffe17 	ldw	r3,-8(fp)
 822bc68:	1885883a 	add	r2,r3,r2
 822bc6c:	e0bffe15 	stw	r2,-8(fp)
         break;
 822bc70:	00003306 	br	822bd40 <dhc_extract_opts+0x244>
      case DHOP_LEASE:
         opts++;
 822bc74:	e0bffe17 	ldw	r2,-8(fp)
 822bc78:	10800044 	addi	r2,r2,1
 822bc7c:	e0bffe15 	stw	r2,-8(fp)
         dhc_states[iface].lease = htonl(dh_getlong(opts));
 822bc80:	e13ffe17 	ldw	r4,-8(fp)
 822bc84:	822ba500 	call	822ba50 <dh_getlong>
 822bc88:	1004d63a 	srli	r2,r2,24
 822bc8c:	1021883a 	mov	r16,r2
 822bc90:	e13ffe17 	ldw	r4,-8(fp)
 822bc94:	822ba500 	call	822ba50 <dh_getlong>
 822bc98:	1005d23a 	srai	r2,r2,8
 822bc9c:	10bfc00c 	andi	r2,r2,65280
 822bca0:	80a0b03a 	or	r16,r16,r2
 822bca4:	e13ffe17 	ldw	r4,-8(fp)
 822bca8:	822ba500 	call	822ba50 <dh_getlong>
 822bcac:	10bfc00c 	andi	r2,r2,65280
 822bcb0:	1004923a 	slli	r2,r2,8
 822bcb4:	80a0b03a 	or	r16,r16,r2
 822bcb8:	e13ffe17 	ldw	r4,-8(fp)
 822bcbc:	822ba500 	call	822ba50 <dh_getlong>
 822bcc0:	1004963a 	slli	r2,r2,24
 822bcc4:	8084b03a 	or	r2,r16,r2
 822bcc8:	1009883a 	mov	r4,r2
 822bccc:	008209b4 	movhi	r2,2086
 822bcd0:	10b86304 	addi	r2,r2,-7796
 822bcd4:	e0fffd17 	ldw	r3,-12(fp)
 822bcd8:	18c00f24 	muli	r3,r3,60
 822bcdc:	10c5883a 	add	r2,r2,r3
 822bce0:	10800504 	addi	r2,r2,20
 822bce4:	11000015 	stw	r4,0(r2)
         opts += 4;
 822bce8:	e0bffe17 	ldw	r2,-8(fp)
 822bcec:	10800104 	addi	r2,r2,4
 822bcf0:	e0bffe15 	stw	r2,-8(fp)
         break;
 822bcf4:	00001206 	br	822bd40 <dhc_extract_opts+0x244>
      case DHOP_DNSRV:
         optlen = *opts++;
 822bcf8:	e0bffe17 	ldw	r2,-8(fp)
 822bcfc:	10c00044 	addi	r3,r2,1
 822bd00:	e0fffe15 	stw	r3,-8(fp)
 822bd04:	10800003 	ldbu	r2,0(r2)
 822bd08:	e0bffc05 	stb	r2,-16(fp)
               opts += 4;
               i++;
            }
         }
#endif   /* DHC_MAXDNSRVS */
         opts += optlen;
 822bd0c:	e0bffc03 	ldbu	r2,-16(fp)
 822bd10:	e0fffe17 	ldw	r3,-8(fp)
 822bd14:	1885883a 	add	r2,r3,r2
 822bd18:	e0bffe15 	stw	r2,-8(fp)
         break;
 822bd1c:	00000806 	br	822bd40 <dhc_extract_opts+0x244>
      default:
         opts += ((*opts) + 1);
 822bd20:	e0bffe17 	ldw	r2,-8(fp)
 822bd24:	10800003 	ldbu	r2,0(r2)
 822bd28:	10803fcc 	andi	r2,r2,255
 822bd2c:	10800044 	addi	r2,r2,1
 822bd30:	e0fffe17 	ldw	r3,-8(fp)
 822bd34:	1885883a 	add	r2,r3,r2
 822bd38:	e0bffe15 	stw	r2,-8(fp)
         break;
 822bd3c:	0001883a 	nop
#if defined(DHC_MAXDNSRVS) && (DHC_MAXDNSRVS > 0)
   MEMSET(dhc_states[iface].dnsrv, 0, sizeof(dhc_states[iface].dnsrv));
#endif   /* DHC_MAXDNSRVS */

   /* then fill them in from the DHCP data */
   while (opts <= end)
 822bd40:	e0bffe17 	ldw	r2,-8(fp)
 822bd44:	e0fffb17 	ldw	r3,-20(fp)
 822bd48:	18bf8c2e 	bgeu	r3,r2,822bb7c <dhc_extract_opts+0x80>
      default:
         opts += ((*opts) + 1);
         break;
      }
   }
   dtrap();
 822bd4c:	822d5f00 	call	822d5f0 <dtrap>
   return -1;
 822bd50:	00bfffc4 	movi	r2,-1
}
 822bd54:	e6ffff04 	addi	sp,fp,-4
 822bd58:	dfc00217 	ldw	ra,8(sp)
 822bd5c:	df000117 	ldw	fp,4(sp)
 822bd60:	dc000017 	ldw	r16,0(sp)
 822bd64:	dec00304 	addi	sp,sp,12
 822bd68:	f800283a 	ret

0822bd6c <dhc_second>:
 * RETURNS: Returns 0 or ENP_ error code 
 */

int
dhc_second(void)
{
 822bd6c:	defffa04 	addi	sp,sp,-24
 822bd70:	dfc00515 	stw	ra,20(sp)
 822bd74:	df000415 	stw	fp,16(sp)
 822bd78:	df000404 	addi	fp,sp,16
   int   iface;
   int   tries;
   int   e;
   u_long   half_time;

   for (iface = 0; iface < MAXNETS; iface++)
 822bd7c:	e03ffc15 	stw	zero,-16(fp)
 822bd80:	00014506 	br	822c298 <dhc_second+0x52c>
   {
      switch (dhc_states[iface].state)
 822bd84:	008209b4 	movhi	r2,2086
 822bd88:	10b86304 	addi	r2,r2,-7796
 822bd8c:	e0fffc17 	ldw	r3,-16(fp)
 822bd90:	18c00f24 	muli	r3,r3,60
 822bd94:	10c5883a 	add	r2,r2,r3
 822bd98:	10800017 	ldw	r2,0(r2)
 822bd9c:	10c00268 	cmpgeui	r3,r2,9
 822bda0:	1801311e 	bne	r3,zero,822c268 <dhc_second+0x4fc>
 822bda4:	100690ba 	slli	r3,r2,2
 822bda8:	008208f4 	movhi	r2,2083
 822bdac:	10af6f04 	addi	r2,r2,-16964
 822bdb0:	1885883a 	add	r2,r3,r2
 822bdb4:	10800017 	ldw	r2,0(r2)
 822bdb8:	1000683a 	jmp	r2
 822bdbc:	0822c268 	cmpgeui	zero,at,35593
 822bdc0:	0822bde0 	cmpeqi	zero,at,-29961
 822bdc4:	0822be10 	cmplti	zero,at,-29960
 822bdc8:	0822be40 	call	822be4 <OSCtxSw_SWITCH_PC+0x822ba4>
 822bdcc:	0822be40 	call	822be4 <OSCtxSw_SWITCH_PC+0x822ba4>
 822bdd0:	0822be40 	call	822be4 <OSCtxSw_SWITCH_PC+0x822ba4>
 822bdd4:	0822c080 	call	822c08 <OSCtxSw_SWITCH_PC+0x822bc8>
 822bdd8:	0822c128 	cmpgeui	zero,at,35588
 822bddc:	0822bf5c 	xori	zero,at,35581
      {
      case DHCS_INIT:         /* Send a discover packet */
         e = dhc_discover(iface);
 822bde0:	e13ffc17 	ldw	r4,-16(fp)
 822bde4:	822a5b40 	call	822a5b4 <dhc_discover>
 822bde8:	e0bfff15 	stw	r2,-4(fp)
         /* Error while sending a discover packet */
         if (e)
 822bdec:	e0bfff17 	ldw	r2,-4(fp)
 822bdf0:	10000326 	beq	r2,zero,822be00 <dhc_second+0x94>
         {
            dtrap();
 822bdf4:	822d5f00 	call	822d5f0 <dtrap>
            return e;
 822bdf8:	e0bfff17 	ldw	r2,-4(fp)
 822bdfc:	00012a06 	br	822c2a8 <dhc_second+0x53c>
         }
         dhc_set_state(iface,DHCS_SELECTING);
 822be00:	01400104 	movi	r5,4
 822be04:	e13ffc17 	ldw	r4,-16(fp)
 822be08:	822c63c0 	call	822c63c <dhc_set_state>
         break;
 822be0c:	00011f06 	br	822c28c <dhc_second+0x520>
      case DHCS_INITREBOOT:   /* Send a request packet */
         e = dhc_reclaim(iface);
 822be10:	e13ffc17 	ldw	r4,-16(fp)
 822be14:	822c33c0 	call	822c33c <dhc_reclaim>
 822be18:	e0bfff15 	stw	r2,-4(fp)
         if (e)
 822be1c:	e0bfff17 	ldw	r2,-4(fp)
 822be20:	10000326 	beq	r2,zero,822be30 <dhc_second+0xc4>
         {
            dtrap();
 822be24:	822d5f00 	call	822d5f0 <dtrap>
            return e;
 822be28:	e0bfff17 	ldw	r2,-4(fp)
 822be2c:	00011e06 	br	822c2a8 <dhc_second+0x53c>
         }
         dhc_set_state(iface,DHCS_REBOOTING);
 822be30:	014000c4 	movi	r5,3
 822be34:	e13ffc17 	ldw	r4,-16(fp)
 822be38:	822c63c0 	call	822c63c <dhc_set_state>
         break;
 822be3c:	00011306 	br	822c28c <dhc_second+0x520>
         /* Send discover packet on timeout */
      case DHCS_REBOOTING:
      case DHCS_REQUESTING:
         /* Discovery timeout = DHC_RETRY_TMO secs * (2 ** retries), max 64 */

         tries = dhc_states[iface].tries ;
 822be40:	008209b4 	movhi	r2,2086
 822be44:	10b86304 	addi	r2,r2,-7796
 822be48:	e0fffc17 	ldw	r3,-16(fp)
 822be4c:	18c00f24 	muli	r3,r3,60
 822be50:	10c5883a 	add	r2,r2,r3
 822be54:	10800104 	addi	r2,r2,4
 822be58:	10800017 	ldw	r2,0(r2)
 822be5c:	e0bffd15 	stw	r2,-12(fp)

         /* Set the exponential count */
         if ( tries >= DHC_MAX_TRIES) 
 822be60:	e0bffd17 	ldw	r2,-12(fp)
 822be64:	10800110 	cmplti	r2,r2,4
 822be68:	1000021e 	bne	r2,zero,822be74 <dhc_second+0x108>
            tries= DHC_MAX_TRIES;
 822be6c:	00800104 	movi	r2,4
 822be70:	e0bffd15 	stw	r2,-12(fp)
         if ( cticks > (dhc_states[iface].last_tick + 
 822be74:	008209b4 	movhi	r2,2086
 822be78:	10b86304 	addi	r2,r2,-7796
 822be7c:	e0fffc17 	ldw	r3,-16(fp)
 822be80:	18c00f24 	muli	r3,r3,60
 822be84:	10c5883a 	add	r2,r2,r3
 822be88:	10800404 	addi	r2,r2,16
 822be8c:	10c00017 	ldw	r3,0(r2)
             (((u_long) (DHC_RETRY_TMO*TPS)) << tries ) ) )
 822be90:	01006404 	movi	r4,400
 822be94:	e0bffd17 	ldw	r2,-12(fp)
 822be98:	2084983a 	sll	r2,r4,r2
         tries = dhc_states[iface].tries ;

         /* Set the exponential count */
         if ( tries >= DHC_MAX_TRIES) 
            tries= DHC_MAX_TRIES;
         if ( cticks > (dhc_states[iface].last_tick + 
 822be9c:	1887883a 	add	r3,r3,r2
 822bea0:	d0a0a817 	ldw	r2,-32096(gp)
 822bea4:	1880192e 	bgeu	r3,r2,822bf0c <dhc_second+0x1a0>
             (((u_long) (DHC_RETRY_TMO*TPS)) << tries ) ) )
         {
            /* Timeout while waiting for a OFFER/ACK/NAK. Retransmit */
            switch(dhc_states[iface].state)
 822bea8:	008209b4 	movhi	r2,2086
 822beac:	10b86304 	addi	r2,r2,-7796
 822beb0:	e0fffc17 	ldw	r3,-16(fp)
 822beb4:	18c00f24 	muli	r3,r3,60
 822beb8:	10c5883a 	add	r2,r2,r3
 822bebc:	10800017 	ldw	r2,0(r2)
 822bec0:	10c00120 	cmpeqi	r3,r2,4
 822bec4:	1800051e 	bne	r3,zero,822bedc <dhc_second+0x170>
 822bec8:	10c00160 	cmpeqi	r3,r2,5
 822becc:	1800061e 	bne	r3,zero,822bee8 <dhc_second+0x17c>
 822bed0:	108000e0 	cmpeqi	r2,r2,3
 822bed4:	1000081e 	bne	r2,zero,822bef8 <dhc_second+0x18c>
 822bed8:	00000a06 	br	822bf04 <dhc_second+0x198>
            {
            case DHCS_SELECTING:
               dhc_discover(iface);
 822bedc:	e13ffc17 	ldw	r4,-16(fp)
 822bee0:	822a5b40 	call	822a5b4 <dhc_discover>
               break;
 822bee4:	00000906 	br	822bf0c <dhc_second+0x1a0>
            case DHCS_REQUESTING:
               dhc_request(iface,FALSE);
 822bee8:	000b883a 	mov	r5,zero
 822beec:	e13ffc17 	ldw	r4,-16(fp)
 822bef0:	822ab640 	call	822ab64 <dhc_request>
               break;
 822bef4:	00000506 	br	822bf0c <dhc_second+0x1a0>
            case DHCS_REBOOTING:
               dhc_reclaim(iface);
 822bef8:	e13ffc17 	ldw	r4,-16(fp)
 822befc:	822c33c0 	call	822c33c <dhc_reclaim>
               break;
 822bf00:	00000206 	br	822bf0c <dhc_second+0x1a0>
            default:
               dtrap(); /* bogus state */
 822bf04:	822d5f00 	call	822d5f0 <dtrap>
               break;
 822bf08:	0001883a 	nop
            }
         }
         if ( tries == DHC_MAX_TRIES && 
 822bf0c:	e0bffd17 	ldw	r2,-12(fp)
 822bf10:	10800118 	cmpnei	r2,r2,4
 822bf14:	1000d61e 	bne	r2,zero,822c270 <dhc_second+0x504>
             (dhc_states[iface].state !=DHCS_SELECTING) )
 822bf18:	008209b4 	movhi	r2,2086
 822bf1c:	10b86304 	addi	r2,r2,-7796
 822bf20:	e0fffc17 	ldw	r3,-16(fp)
 822bf24:	18c00f24 	muli	r3,r3,60
 822bf28:	10c5883a 	add	r2,r2,r3
 822bf2c:	10800017 	ldw	r2,0(r2)
            default:
               dtrap(); /* bogus state */
               break;
            }
         }
         if ( tries == DHC_MAX_TRIES && 
 822bf30:	10800120 	cmpeqi	r2,r2,4
 822bf34:	1000ce1e 	bne	r2,zero,822c270 <dhc_second+0x504>
             (dhc_states[iface].state !=DHCS_SELECTING) )
         {
            /* We have tried enough. Restart from INIT state */
            dhc_set_state(iface,DHCS_RESTARTING);
 822bf38:	01400244 	movi	r5,9
 822bf3c:	e13ffc17 	ldw	r4,-16(fp)
 822bf40:	822c63c0 	call	822c63c <dhc_set_state>
            dhc_resetip(iface);
 822bf44:	e13ffc17 	ldw	r4,-16(fp)
 822bf48:	822b8640 	call	822b864 <dhc_resetip>
            dhc_set_state(iface,DHCS_INIT);
 822bf4c:	01400044 	movi	r5,1
 822bf50:	e13ffc17 	ldw	r4,-16(fp)
 822bf54:	822c63c0 	call	822c63c <dhc_set_state>
         }
         break;
 822bf58:	0000c506 	br	822c270 <dhc_second+0x504>
      case DHCS_REBINDING:
         /* Check for timeout. Retry if we didn't get a ACK/NAK response. */

         if ( (dhc_states[iface].lease*TPS+dhc_states[iface].lease_start) > cticks )
 822bf5c:	008209b4 	movhi	r2,2086
 822bf60:	10b86304 	addi	r2,r2,-7796
 822bf64:	e0fffc17 	ldw	r3,-16(fp)
 822bf68:	18c00f24 	muli	r3,r3,60
 822bf6c:	10c5883a 	add	r2,r2,r3
 822bf70:	10800504 	addi	r2,r2,20
 822bf74:	10800017 	ldw	r2,0(r2)
 822bf78:	10c01924 	muli	r3,r2,100
 822bf7c:	008209b4 	movhi	r2,2086
 822bf80:	10b86304 	addi	r2,r2,-7796
 822bf84:	e13ffc17 	ldw	r4,-16(fp)
 822bf88:	21000f24 	muli	r4,r4,60
 822bf8c:	1105883a 	add	r2,r2,r4
 822bf90:	10800804 	addi	r2,r2,32
 822bf94:	10800017 	ldw	r2,0(r2)
 822bf98:	1885883a 	add	r2,r3,r2
 822bf9c:	d0e0a817 	ldw	r3,-32096(gp)
 822bfa0:	18802e2e 	bgeu	r3,r2,822c05c <dhc_second+0x2f0>
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
 822bfa4:	008209b4 	movhi	r2,2086
 822bfa8:	10b86304 	addi	r2,r2,-7796
 822bfac:	e0fffc17 	ldw	r3,-16(fp)
 822bfb0:	18c00f24 	muli	r3,r3,60
 822bfb4:	10c5883a 	add	r2,r2,r3
 822bfb8:	10800804 	addi	r2,r2,32
 822bfbc:	10c00017 	ldw	r3,0(r2)
             dhc_states[iface].lease*TPS - 
 822bfc0:	008209b4 	movhi	r2,2086
 822bfc4:	10b86304 	addi	r2,r2,-7796
 822bfc8:	e13ffc17 	ldw	r4,-16(fp)
 822bfcc:	21000f24 	muli	r4,r4,60
 822bfd0:	1105883a 	add	r2,r2,r4
 822bfd4:	10800504 	addi	r2,r2,20
 822bfd8:	10800017 	ldw	r2,0(r2)
 822bfdc:	10801924 	muli	r2,r2,100
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
 822bfe0:	1887883a 	add	r3,r3,r2
             dhc_states[iface].lease*TPS - 
             dhc_states[iface].last_tick)/2;
 822bfe4:	008209b4 	movhi	r2,2086
 822bfe8:	10b86304 	addi	r2,r2,-7796
 822bfec:	e13ffc17 	ldw	r4,-16(fp)
 822bff0:	21000f24 	muli	r4,r4,60
 822bff4:	1105883a 	add	r2,r2,r4
 822bff8:	10800404 	addi	r2,r2,16
 822bffc:	10800017 	ldw	r2,0(r2)
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
             dhc_states[iface].lease*TPS - 
 822c000:	1885c83a 	sub	r2,r3,r2
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
 822c004:	1004d07a 	srli	r2,r2,1
 822c008:	e0bffe15 	stw	r2,-8(fp)
             dhc_states[iface].lease*TPS - 
             dhc_states[iface].last_tick)/2;

            if ( half_time < 60*TPS )
 822c00c:	e0bffe17 	ldw	r2,-8(fp)
 822c010:	1085dc28 	cmpgeui	r2,r2,6000
 822c014:	1000021e 	bne	r2,zero,822c020 <dhc_second+0x2b4>
               half_time = 60*TPS;
 822c018:	0085dc04 	movi	r2,6000
 822c01c:	e0bffe15 	stw	r2,-8(fp)
            if ( dhc_states[iface].last_tick + half_time < cticks )
 822c020:	008209b4 	movhi	r2,2086
 822c024:	10b86304 	addi	r2,r2,-7796
 822c028:	e0fffc17 	ldw	r3,-16(fp)
 822c02c:	18c00f24 	muli	r3,r3,60
 822c030:	10c5883a 	add	r2,r2,r3
 822c034:	10800404 	addi	r2,r2,16
 822c038:	10c00017 	ldw	r3,0(r2)
 822c03c:	e0bffe17 	ldw	r2,-8(fp)
 822c040:	1887883a 	add	r3,r3,r2
 822c044:	d0a0a817 	ldw	r2,-32096(gp)
 822c048:	18808b2e 	bgeu	r3,r2,822c278 <dhc_second+0x50c>
            {
               dhc_request(iface,FALSE);
 822c04c:	000b883a 	mov	r5,zero
 822c050:	e13ffc17 	ldw	r4,-16(fp)
 822c054:	822ab640 	call	822ab64 <dhc_request>
            /* Lease has expired. We didn't receive a ACK/NAK. Hence restart*/
            dhc_set_state(iface,DHCS_RESTARTING);
            dhc_resetip(iface);
            dhc_set_state(iface,DHCS_INIT);
         }
         break;
 822c058:	00008706 	br	822c278 <dhc_second+0x50c>
            }
         }
         else
         {
            /* Lease has expired. We didn't receive a ACK/NAK. Hence restart*/
            dhc_set_state(iface,DHCS_RESTARTING);
 822c05c:	01400244 	movi	r5,9
 822c060:	e13ffc17 	ldw	r4,-16(fp)
 822c064:	822c63c0 	call	822c63c <dhc_set_state>
            dhc_resetip(iface);
 822c068:	e13ffc17 	ldw	r4,-16(fp)
 822c06c:	822b8640 	call	822b864 <dhc_resetip>
            dhc_set_state(iface,DHCS_INIT);
 822c070:	01400044 	movi	r5,1
 822c074:	e13ffc17 	ldw	r4,-16(fp)
 822c078:	822c63c0 	call	822c63c <dhc_set_state>
         }
         break;
 822c07c:	00007e06 	br	822c278 <dhc_second+0x50c>

      case DHCS_BOUND:
         /* Test for lease expiry. The RENEW timer. */
         if ( (dhc_states[iface].t1 != DHC_INFINITY) &&
 822c080:	008209b4 	movhi	r2,2086
 822c084:	10b86304 	addi	r2,r2,-7796
 822c088:	e0fffc17 	ldw	r3,-16(fp)
 822c08c:	18c00f24 	muli	r3,r3,60
 822c090:	10c5883a 	add	r2,r2,r3
 822c094:	10800604 	addi	r2,r2,24
 822c098:	10800017 	ldw	r2,0(r2)
 822c09c:	10bfffe0 	cmpeqi	r2,r2,-1
 822c0a0:	1000771e 	bne	r2,zero,822c280 <dhc_second+0x514>
             (((dhc_states[iface].t1*TPS)+dhc_states[iface].lease_start) < cticks ) )
 822c0a4:	008209b4 	movhi	r2,2086
 822c0a8:	10b86304 	addi	r2,r2,-7796
 822c0ac:	e0fffc17 	ldw	r3,-16(fp)
 822c0b0:	18c00f24 	muli	r3,r3,60
 822c0b4:	10c5883a 	add	r2,r2,r3
 822c0b8:	10800604 	addi	r2,r2,24
 822c0bc:	10800017 	ldw	r2,0(r2)
 822c0c0:	10c01924 	muli	r3,r2,100
 822c0c4:	008209b4 	movhi	r2,2086
 822c0c8:	10b86304 	addi	r2,r2,-7796
 822c0cc:	e13ffc17 	ldw	r4,-16(fp)
 822c0d0:	21000f24 	muli	r4,r4,60
 822c0d4:	1105883a 	add	r2,r2,r4
 822c0d8:	10800804 	addi	r2,r2,32
 822c0dc:	10800017 	ldw	r2,0(r2)
 822c0e0:	1887883a 	add	r3,r3,r2
 822c0e4:	d0a0a817 	ldw	r2,-32096(gp)
         }
         break;

      case DHCS_BOUND:
         /* Test for lease expiry. The RENEW timer. */
         if ( (dhc_states[iface].t1 != DHC_INFINITY) &&
 822c0e8:	1880652e 	bgeu	r3,r2,822c280 <dhc_second+0x514>
             (((dhc_states[iface].t1*TPS)+dhc_states[iface].lease_start) < cticks ) )
         {
            /* Time to renew. Send a UNICAST to the DHCP server */
            dhc_set_state(iface,DHCS_RENEWING);
 822c0ec:	014001c4 	movi	r5,7
 822c0f0:	e13ffc17 	ldw	r4,-16(fp)
 822c0f4:	822c63c0 	call	822c63c <dhc_set_state>
            e = dhc_reclaim(iface); /* unicast */ 
 822c0f8:	e13ffc17 	ldw	r4,-16(fp)
 822c0fc:	822c33c0 	call	822c33c <dhc_reclaim>
 822c100:	e0bfff15 	stw	r2,-4(fp)
            if (e)
 822c104:	e0bfff17 	ldw	r2,-4(fp)
 822c108:	10000326 	beq	r2,zero,822c118 <dhc_second+0x3ac>
            {
               dtrap();
 822c10c:	822d5f00 	call	822d5f0 <dtrap>
               return e;
 822c110:	e0bfff17 	ldw	r2,-4(fp)
 822c114:	00006406 	br	822c2a8 <dhc_second+0x53c>
            }
            dsc_renew++;
 822c118:	d0a09917 	ldw	r2,-32156(gp)
 822c11c:	10800044 	addi	r2,r2,1
 822c120:	d0a09915 	stw	r2,-32156(gp)
         }
         break;
 822c124:	00005606 	br	822c280 <dhc_second+0x514>
      case DHCS_RENEWING:
         /* Test for lease expiry. The REBIND timer. */
         if ( (dhc_states[iface].t2*TPS+dhc_states[iface].lease_start) > cticks )
 822c128:	008209b4 	movhi	r2,2086
 822c12c:	10b86304 	addi	r2,r2,-7796
 822c130:	e0fffc17 	ldw	r3,-16(fp)
 822c134:	18c00f24 	muli	r3,r3,60
 822c138:	10c5883a 	add	r2,r2,r3
 822c13c:	10800704 	addi	r2,r2,28
 822c140:	10800017 	ldw	r2,0(r2)
 822c144:	10c01924 	muli	r3,r2,100
 822c148:	008209b4 	movhi	r2,2086
 822c14c:	10b86304 	addi	r2,r2,-7796
 822c150:	e13ffc17 	ldw	r4,-16(fp)
 822c154:	21000f24 	muli	r4,r4,60
 822c158:	1105883a 	add	r2,r2,r4
 822c15c:	10800804 	addi	r2,r2,32
 822c160:	10800017 	ldw	r2,0(r2)
 822c164:	1885883a 	add	r2,r3,r2
 822c168:	d0e0a817 	ldw	r3,-32096(gp)
 822c16c:	18802e2e 	bgeu	r3,r2,822c228 <dhc_second+0x4bc>
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
 822c170:	008209b4 	movhi	r2,2086
 822c174:	10b86304 	addi	r2,r2,-7796
 822c178:	e0fffc17 	ldw	r3,-16(fp)
 822c17c:	18c00f24 	muli	r3,r3,60
 822c180:	10c5883a 	add	r2,r2,r3
 822c184:	10800804 	addi	r2,r2,32
 822c188:	10c00017 	ldw	r3,0(r2)
             dhc_states[iface].t2*TPS - 
 822c18c:	008209b4 	movhi	r2,2086
 822c190:	10b86304 	addi	r2,r2,-7796
 822c194:	e13ffc17 	ldw	r4,-16(fp)
 822c198:	21000f24 	muli	r4,r4,60
 822c19c:	1105883a 	add	r2,r2,r4
 822c1a0:	10800704 	addi	r2,r2,28
 822c1a4:	10800017 	ldw	r2,0(r2)
 822c1a8:	10801924 	muli	r2,r2,100
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
 822c1ac:	1887883a 	add	r3,r3,r2
             dhc_states[iface].t2*TPS - 
             dhc_states[iface].last_tick)/2;
 822c1b0:	008209b4 	movhi	r2,2086
 822c1b4:	10b86304 	addi	r2,r2,-7796
 822c1b8:	e13ffc17 	ldw	r4,-16(fp)
 822c1bc:	21000f24 	muli	r4,r4,60
 822c1c0:	1105883a 	add	r2,r2,r4
 822c1c4:	10800404 	addi	r2,r2,16
 822c1c8:	10800017 	ldw	r2,0(r2)
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
             dhc_states[iface].t2*TPS - 
 822c1cc:	1885c83a 	sub	r2,r3,r2
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
 822c1d0:	1004d07a 	srli	r2,r2,1
 822c1d4:	e0bffe15 	stw	r2,-8(fp)
             dhc_states[iface].t2*TPS - 
             dhc_states[iface].last_tick)/2;

            if ( half_time < 60*TPS )
 822c1d8:	e0bffe17 	ldw	r2,-8(fp)
 822c1dc:	1085dc28 	cmpgeui	r2,r2,6000
 822c1e0:	1000021e 	bne	r2,zero,822c1ec <dhc_second+0x480>
               half_time = 60*TPS;
 822c1e4:	0085dc04 	movi	r2,6000
 822c1e8:	e0bffe15 	stw	r2,-8(fp)
            if ( dhc_states[iface].last_tick + half_time < cticks )
 822c1ec:	008209b4 	movhi	r2,2086
 822c1f0:	10b86304 	addi	r2,r2,-7796
 822c1f4:	e0fffc17 	ldw	r3,-16(fp)
 822c1f8:	18c00f24 	muli	r3,r3,60
 822c1fc:	10c5883a 	add	r2,r2,r3
 822c200:	10800404 	addi	r2,r2,16
 822c204:	10c00017 	ldw	r3,0(r2)
 822c208:	e0bffe17 	ldw	r2,-8(fp)
 822c20c:	1887883a 	add	r3,r3,r2
 822c210:	d0a0a817 	ldw	r2,-32096(gp)
 822c214:	18801c2e 	bgeu	r3,r2,822c288 <dhc_second+0x51c>
            {
               dhc_request(iface,FALSE);
 822c218:	000b883a 	mov	r5,zero
 822c21c:	e13ffc17 	ldw	r4,-16(fp)
 822c220:	822ab640 	call	822ab64 <dhc_request>
               dtrap();
               return e;
            }
            dsc_rebind++;
         }
         break;
 822c224:	00001806 	br	822c288 <dhc_second+0x51c>
         {
            /* No Response has come from the Server that assigned our 
             * IP. Hence send a broadcast packet to see if we can 
             * lease this IP from some other server 
             */
            dhc_set_state(iface,DHCS_REBINDING);
 822c228:	01400204 	movi	r5,8
 822c22c:	e13ffc17 	ldw	r4,-16(fp)
 822c230:	822c63c0 	call	822c63c <dhc_set_state>
            e = dhc_request(iface,TRUE);  /* broadcast */
 822c234:	01400044 	movi	r5,1
 822c238:	e13ffc17 	ldw	r4,-16(fp)
 822c23c:	822ab640 	call	822ab64 <dhc_request>
 822c240:	e0bfff15 	stw	r2,-4(fp)
            if (e)
 822c244:	e0bfff17 	ldw	r2,-4(fp)
 822c248:	10000326 	beq	r2,zero,822c258 <dhc_second+0x4ec>
            {
               dtrap();
 822c24c:	822d5f00 	call	822d5f0 <dtrap>
               return e;
 822c250:	e0bfff17 	ldw	r2,-4(fp)
 822c254:	00001406 	br	822c2a8 <dhc_second+0x53c>
            }
            dsc_rebind++;
 822c258:	d0a09a17 	ldw	r2,-32152(gp)
 822c25c:	10800044 	addi	r2,r2,1
 822c260:	d0a09a15 	stw	r2,-32152(gp)
         }
         break;
 822c264:	00000806 	br	822c288 <dhc_second+0x51c>
      case DHCS_UNUSED:
      default:
         continue;
 822c268:	0001883a 	nop
 822c26c:	00000706 	br	822c28c <dhc_second+0x520>
            /* We have tried enough. Restart from INIT state */
            dhc_set_state(iface,DHCS_RESTARTING);
            dhc_resetip(iface);
            dhc_set_state(iface,DHCS_INIT);
         }
         break;
 822c270:	0001883a 	nop
 822c274:	00000506 	br	822c28c <dhc_second+0x520>
            /* Lease has expired. We didn't receive a ACK/NAK. Hence restart*/
            dhc_set_state(iface,DHCS_RESTARTING);
            dhc_resetip(iface);
            dhc_set_state(iface,DHCS_INIT);
         }
         break;
 822c278:	0001883a 	nop
 822c27c:	00000306 	br	822c28c <dhc_second+0x520>
               dtrap();
               return e;
            }
            dsc_renew++;
         }
         break;
 822c280:	0001883a 	nop
 822c284:	00000106 	br	822c28c <dhc_second+0x520>
               dtrap();
               return e;
            }
            dsc_rebind++;
         }
         break;
 822c288:	0001883a 	nop
   int   iface;
   int   tries;
   int   e;
   u_long   half_time;

   for (iface = 0; iface < MAXNETS; iface++)
 822c28c:	e0bffc17 	ldw	r2,-16(fp)
 822c290:	10800044 	addi	r2,r2,1
 822c294:	e0bffc15 	stw	r2,-16(fp)
 822c298:	e0bffc17 	ldw	r2,-16(fp)
 822c29c:	10800110 	cmplti	r2,r2,4
 822c2a0:	103eb81e 	bne	r2,zero,822bd84 <dhc_second+0x18>
      case DHCS_UNUSED:
      default:
         continue;
      }
   }
   return 0;
 822c2a4:	0005883a 	mov	r2,zero
}
 822c2a8:	e037883a 	mov	sp,fp
 822c2ac:	dfc00117 	ldw	ra,4(sp)
 822c2b0:	df000017 	ldw	fp,0(sp)
 822c2b4:	dec00204 	addi	sp,sp,8
 822c2b8:	f800283a 	ret

0822c2bc <dhc_halt>:
 * RETURNS: void
 */

void
dhc_halt(int iface)
{
 822c2bc:	defffd04 	addi	sp,sp,-12
 822c2c0:	dfc00215 	stw	ra,8(sp)
 822c2c4:	df000115 	stw	fp,4(sp)
 822c2c8:	df000104 	addi	fp,sp,4
 822c2cc:	e13fff15 	stw	r4,-4(fp)
   if (iface < 0 || iface > MAXNETS)
 822c2d0:	e0bfff17 	ldw	r2,-4(fp)
 822c2d4:	10000316 	blt	r2,zero,822c2e4 <dhc_halt+0x28>
 822c2d8:	e0bfff17 	ldw	r2,-4(fp)
 822c2dc:	10800150 	cmplti	r2,r2,5
 822c2e0:	1000021e 	bne	r2,zero,822c2ec <dhc_halt+0x30>
   {
      dtrap();
 822c2e4:	822d5f00 	call	822d5f0 <dtrap>
      return;
 822c2e8:	00000f06 	br	822c328 <dhc_halt+0x6c>
   }
   /* clear dhc_states entry - (kills retrys) */
   MEMSET(&dhc_states[iface], 0, sizeof(struct dhc_state));
 822c2ec:	e0bfff17 	ldw	r2,-4(fp)
 822c2f0:	10c00f24 	muli	r3,r2,60
 822c2f4:	008209b4 	movhi	r2,2086
 822c2f8:	10b86304 	addi	r2,r2,-7796
 822c2fc:	1885883a 	add	r2,r3,r2
 822c300:	01800f04 	movi	r6,60
 822c304:	000b883a 	mov	r5,zero
 822c308:	1009883a 	mov	r4,r2
 822c30c:	82032100 	call	8203210 <memset>
   dhc_states[iface].state = DHCS_UNUSED;
 822c310:	008209b4 	movhi	r2,2086
 822c314:	10b86304 	addi	r2,r2,-7796
 822c318:	e0ffff17 	ldw	r3,-4(fp)
 822c31c:	18c00f24 	muli	r3,r3,60
 822c320:	10c5883a 	add	r2,r2,r3
 822c324:	10000015 	stw	zero,0(r2)
}
 822c328:	e037883a 	mov	sp,fp
 822c32c:	dfc00117 	ldw	ra,4(sp)
 822c330:	df000017 	ldw	fp,0(sp)
 822c334:	dec00204 	addi	sp,sp,8
 822c338:	f800283a 	ret

0822c33c <dhc_reclaim>:
 * RETURNS: Returns 0 if DHCP request was sent OK, else non-zero error. 
 */

int   
dhc_reclaim(int iface)
{
 822c33c:	defffc04 	addi	sp,sp,-16
 822c340:	dfc00315 	stw	ra,12(sp)
 822c344:	df000215 	stw	fp,8(sp)
 822c348:	df000204 	addi	fp,sp,8
 822c34c:	e13fff15 	stw	r4,-4(fp)
   /* punt if IP address is not set */
   if (nets[iface]->n_ipaddr == 0L)
 822c350:	008209b4 	movhi	r2,2086
 822c354:	10b83d04 	addi	r2,r2,-7948
 822c358:	e0ffff17 	ldw	r3,-4(fp)
 822c35c:	18c7883a 	add	r3,r3,r3
 822c360:	18c7883a 	add	r3,r3,r3
 822c364:	10c5883a 	add	r2,r2,r3
 822c368:	10800017 	ldw	r2,0(r2)
 822c36c:	10800a17 	ldw	r2,40(r2)
 822c370:	1000031e 	bne	r2,zero,822c380 <dhc_reclaim+0x44>
   {
      dtrap();    /* programming bug? */
 822c374:	822d5f00 	call	822d5f0 <dtrap>
      return ENP_LOGIC;
 822c378:	00bffd44 	movi	r2,-11
 822c37c:	00005806 	br	822c4e0 <dhc_reclaim+0x1a4>
   }

   dhc_states[iface].ipaddr = nets[iface]->n_ipaddr;
 822c380:	008209b4 	movhi	r2,2086
 822c384:	10b83d04 	addi	r2,r2,-7948
 822c388:	e0ffff17 	ldw	r3,-4(fp)
 822c38c:	18c7883a 	add	r3,r3,r3
 822c390:	18c7883a 	add	r3,r3,r3
 822c394:	10c5883a 	add	r2,r2,r3
 822c398:	10800017 	ldw	r2,0(r2)
 822c39c:	10c00a17 	ldw	r3,40(r2)
 822c3a0:	008209b4 	movhi	r2,2086
 822c3a4:	10b86304 	addi	r2,r2,-7796
 822c3a8:	e13fff17 	ldw	r4,-4(fp)
 822c3ac:	21000f24 	muli	r4,r4,60
 822c3b0:	1105883a 	add	r2,r2,r4
 822c3b4:	10800904 	addi	r2,r2,36
 822c3b8:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].snmask = nets[iface]->snmask;
 822c3bc:	008209b4 	movhi	r2,2086
 822c3c0:	10b83d04 	addi	r2,r2,-7948
 822c3c4:	e0ffff17 	ldw	r3,-4(fp)
 822c3c8:	18c7883a 	add	r3,r3,r3
 822c3cc:	18c7883a 	add	r3,r3,r3
 822c3d0:	10c5883a 	add	r2,r2,r3
 822c3d4:	10800017 	ldw	r2,0(r2)
 822c3d8:	10c00c17 	ldw	r3,48(r2)
 822c3dc:	008209b4 	movhi	r2,2086
 822c3e0:	10b86304 	addi	r2,r2,-7796
 822c3e4:	e13fff17 	ldw	r4,-4(fp)
 822c3e8:	21000f24 	muli	r4,r4,60
 822c3ec:	1105883a 	add	r2,r2,r4
 822c3f0:	10800a04 	addi	r2,r2,40
 822c3f4:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].defgw  = nets[iface]->n_defgw;
 822c3f8:	008209b4 	movhi	r2,2086
 822c3fc:	10b83d04 	addi	r2,r2,-7948
 822c400:	e0ffff17 	ldw	r3,-4(fp)
 822c404:	18c7883a 	add	r3,r3,r3
 822c408:	18c7883a 	add	r3,r3,r3
 822c40c:	10c5883a 	add	r2,r2,r3
 822c410:	10800017 	ldw	r2,0(r2)
 822c414:	10c00d17 	ldw	r3,52(r2)
 822c418:	008209b4 	movhi	r2,2086
 822c41c:	10b86304 	addi	r2,r2,-7796
 822c420:	e13fff17 	ldw	r4,-4(fp)
 822c424:	21000f24 	muli	r4,r4,60
 822c428:	1105883a 	add	r2,r2,r4
 822c42c:	10800b04 	addi	r2,r2,44
 822c430:	10c00015 	stw	r3,0(r2)

#ifdef IP_ROUTING
   /* If the DHCP Server is on other network, route the request
    * from the same DHCP relay agent. To do that, add a route.
    */
   if (dhc_states[iface].rly_ipaddr)
 822c434:	008209b4 	movhi	r2,2086
 822c438:	10b86304 	addi	r2,r2,-7796
 822c43c:	e0ffff17 	ldw	r3,-4(fp)
 822c440:	18c00f24 	muli	r3,r3,60
 822c444:	10c5883a 	add	r2,r2,r3
 822c448:	10800c04 	addi	r2,r2,48
 822c44c:	10800017 	ldw	r2,0(r2)
 822c450:	10002026 	beq	r2,zero,822c4d4 <dhc_reclaim+0x198>
   {
      if (dhc_states[iface].srv_ipaddr)
 822c454:	008209b4 	movhi	r2,2086
 822c458:	10b86304 	addi	r2,r2,-7796
 822c45c:	e0ffff17 	ldw	r3,-4(fp)
 822c460:	18c00f24 	muli	r3,r3,60
 822c464:	10c5883a 	add	r2,r2,r3
 822c468:	10800d04 	addi	r2,r2,52
 822c46c:	10800017 	ldw	r2,0(r2)
 822c470:	10001726 	beq	r2,zero,822c4d0 <dhc_reclaim+0x194>
      {
         /* yes, earlier negotiation was done via a relay agent */
         if ( !add_route(dhc_states[iface].srv_ipaddr, 0xFFFFFFFF,
 822c474:	008209b4 	movhi	r2,2086
 822c478:	10b86304 	addi	r2,r2,-7796
 822c47c:	e0ffff17 	ldw	r3,-4(fp)
 822c480:	18c00f24 	muli	r3,r3,60
 822c484:	10c5883a 	add	r2,r2,r3
 822c488:	10800d04 	addi	r2,r2,52
 822c48c:	11000017 	ldw	r4,0(r2)
 822c490:	008209b4 	movhi	r2,2086
 822c494:	10b86304 	addi	r2,r2,-7796
 822c498:	e0ffff17 	ldw	r3,-4(fp)
 822c49c:	18c00f24 	muli	r3,r3,60
 822c4a0:	10c5883a 	add	r2,r2,r3
 822c4a4:	10800c04 	addi	r2,r2,48
 822c4a8:	10c00017 	ldw	r3,0(r2)
 822c4ac:	00800084 	movi	r2,2
 822c4b0:	d8800015 	stw	r2,0(sp)
 822c4b4:	e1ffff17 	ldw	r7,-4(fp)
 822c4b8:	180d883a 	mov	r6,r3
 822c4bc:	017fffc4 	movi	r5,-1
 822c4c0:	824438c0 	call	824438c <add_route>
 822c4c4:	1000031e 	bne	r2,zero,822c4d4 <dhc_reclaim+0x198>
             dhc_states[iface].rly_ipaddr, iface, IPRP_LOCAL))
         {
            /* route was not added. check this case */
            dtrap(); 
 822c4c8:	822d5f00 	call	822d5f0 <dtrap>
 822c4cc:	00000106 	br	822c4d4 <dhc_reclaim+0x198>
      else
      {
         /* DHCP relay IP address is set, but DHCP Server IP address is
          * not set ! How can this happen ?
          */
         dtrap();
 822c4d0:	822d5f00 	call	822d5f0 <dtrap>
      }
   }
#endif  /* IP_ROUTING */

   /* send the request */
   return(dhc_request(iface,TRUE));  
 822c4d4:	01400044 	movi	r5,1
 822c4d8:	e13fff17 	ldw	r4,-4(fp)
 822c4dc:	822ab640 	call	822ab64 <dhc_request>
}
 822c4e0:	e037883a 	mov	sp,fp
 822c4e4:	dfc00117 	ldw	ra,4(sp)
 822c4e8:	df000017 	ldw	fp,0(sp)
 822c4ec:	dec00204 	addi	sp,sp,8
 822c4f0:	f800283a 	ret

0822c4f4 <dhc_state_init>:
 * RETURNS: void
 */

void 
dhc_state_init(int iface, int init_flag)
{
 822c4f4:	defffb04 	addi	sp,sp,-20
 822c4f8:	dfc00415 	stw	ra,16(sp)
 822c4fc:	df000315 	stw	fp,12(sp)
 822c500:	df000304 	addi	fp,sp,12
 822c504:	e13ffe15 	stw	r4,-8(fp)
 822c508:	e17fff15 	stw	r5,-4(fp)
   int state = (init_flag == TRUE) ? DHCS_INIT : DHCS_INITREBOOT;
 822c50c:	e0bfff17 	ldw	r2,-4(fp)
 822c510:	10800058 	cmpnei	r2,r2,1
 822c514:	1000021e 	bne	r2,zero,822c520 <dhc_state_init+0x2c>
 822c518:	00800044 	movi	r2,1
 822c51c:	00000106 	br	822c524 <dhc_state_init+0x30>
 822c520:	00800084 	movi	r2,2
 822c524:	e0bffd15 	stw	r2,-12(fp)
   
   dhc_set_state(iface, state);
 822c528:	e17ffd17 	ldw	r5,-12(fp)
 822c52c:	e13ffe17 	ldw	r4,-8(fp)
 822c530:	822c63c0 	call	822c63c <dhc_set_state>
}
 822c534:	0001883a 	nop
 822c538:	e037883a 	mov	sp,fp
 822c53c:	dfc00117 	ldw	ra,4(sp)
 822c540:	df000017 	ldw	fp,0(sp)
 822c544:	dec00204 	addi	sp,sp,8
 822c548:	f800283a 	ret

0822c54c <dhc_alldone>:
 * otherwise. 
 */

int 
dhc_alldone(void)
{
 822c54c:	defffe04 	addi	sp,sp,-8
 822c550:	df000115 	stw	fp,4(sp)
 822c554:	df000104 	addi	fp,sp,4
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 822c558:	e03fff15 	stw	zero,-4(fp)
 822c55c:	00001506 	br	822c5b4 <dhc_alldone+0x68>
   {
      if ( ( dhc_states[i].state == DHCS_UNUSED ) || 
 822c560:	008209b4 	movhi	r2,2086
 822c564:	10b86304 	addi	r2,r2,-7796
 822c568:	e0ffff17 	ldw	r3,-4(fp)
 822c56c:	18c00f24 	muli	r3,r3,60
 822c570:	10c5883a 	add	r2,r2,r3
 822c574:	10800017 	ldw	r2,0(r2)
 822c578:	10000826 	beq	r2,zero,822c59c <dhc_alldone+0x50>
          ( dhc_states[i].state == DHCS_BOUND  )  )
 822c57c:	008209b4 	movhi	r2,2086
 822c580:	10b86304 	addi	r2,r2,-7796
 822c584:	e0ffff17 	ldw	r3,-4(fp)
 822c588:	18c00f24 	muli	r3,r3,60
 822c58c:	10c5883a 	add	r2,r2,r3
 822c590:	10800017 	ldw	r2,0(r2)
dhc_alldone(void)
{
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
   {
      if ( ( dhc_states[i].state == DHCS_UNUSED ) || 
 822c594:	10800198 	cmpnei	r2,r2,6
 822c598:	1000041e 	bne	r2,zero,822c5ac <dhc_alldone+0x60>

int 
dhc_alldone(void)
{
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 822c59c:	e0bfff17 	ldw	r2,-4(fp)
 822c5a0:	10800044 	addi	r2,r2,1
 822c5a4:	e0bfff15 	stw	r2,-4(fp)
 822c5a8:	00000206 	br	822c5b4 <dhc_alldone+0x68>
      {
         continue ;
      }
      else
      {
         return FALSE ;
 822c5ac:	0005883a 	mov	r2,zero
 822c5b0:	00000406 	br	822c5c4 <dhc_alldone+0x78>

int 
dhc_alldone(void)
{
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 822c5b4:	e0bfff17 	ldw	r2,-4(fp)
 822c5b8:	10800110 	cmplti	r2,r2,4
 822c5bc:	103fe81e 	bne	r2,zero,822c560 <dhc_alldone+0x14>
      else
      {
         return FALSE ;
      }
   }
   return TRUE ;
 822c5c0:	00800044 	movi	r2,1
}
 822c5c4:	e037883a 	mov	sp,fp
 822c5c8:	df000017 	ldw	fp,0(sp)
 822c5cc:	dec00104 	addi	sp,sp,4
 822c5d0:	f800283a 	ret

0822c5d4 <dhc_ifacedone>:
 * RETURNS: 
 */

int 
dhc_ifacedone(int iface)
{
 822c5d4:	defffe04 	addi	sp,sp,-8
 822c5d8:	df000115 	stw	fp,4(sp)
 822c5dc:	df000104 	addi	fp,sp,4
 822c5e0:	e13fff15 	stw	r4,-4(fp)
   if ( ( dhc_states[iface].state == DHCS_UNUSED ) || 
 822c5e4:	008209b4 	movhi	r2,2086
 822c5e8:	10b86304 	addi	r2,r2,-7796
 822c5ec:	e0ffff17 	ldw	r3,-4(fp)
 822c5f0:	18c00f24 	muli	r3,r3,60
 822c5f4:	10c5883a 	add	r2,r2,r3
 822c5f8:	10800017 	ldw	r2,0(r2)
 822c5fc:	10000826 	beq	r2,zero,822c620 <dhc_ifacedone+0x4c>
       ( dhc_states[iface].state == DHCS_BOUND  )  )
 822c600:	008209b4 	movhi	r2,2086
 822c604:	10b86304 	addi	r2,r2,-7796
 822c608:	e0ffff17 	ldw	r3,-4(fp)
 822c60c:	18c00f24 	muli	r3,r3,60
 822c610:	10c5883a 	add	r2,r2,r3
 822c614:	10800017 	ldw	r2,0(r2)
 */

int 
dhc_ifacedone(int iface)
{
   if ( ( dhc_states[iface].state == DHCS_UNUSED ) || 
 822c618:	10800198 	cmpnei	r2,r2,6
 822c61c:	1000021e 	bne	r2,zero,822c628 <dhc_ifacedone+0x54>
       ( dhc_states[iface].state == DHCS_BOUND  )  )
   {
      return TRUE ;
 822c620:	00800044 	movi	r2,1
 822c624:	00000106 	br	822c62c <dhc_ifacedone+0x58>
   }
   else
   {
      return FALSE ;
 822c628:	0005883a 	mov	r2,zero
   }
}
 822c62c:	e037883a 	mov	sp,fp
 822c630:	df000017 	ldw	fp,0(sp)
 822c634:	dec00104 	addi	sp,sp,4
 822c638:	f800283a 	ret

0822c63c <dhc_set_state>:
 *
 * RETURNS: 
 */

void dhc_set_state(int iface, int state)
{
 822c63c:	defffc04 	addi	sp,sp,-16
 822c640:	dfc00315 	stw	ra,12(sp)
 822c644:	df000215 	stw	fp,8(sp)
 822c648:	df000204 	addi	fp,sp,8
 822c64c:	e13ffe15 	stw	r4,-8(fp)
 822c650:	e17fff15 	stw	r5,-4(fp)
   dhc_states[iface].state = state; /* Set the new state */
 822c654:	e0ffff17 	ldw	r3,-4(fp)
 822c658:	008209b4 	movhi	r2,2086
 822c65c:	10b86304 	addi	r2,r2,-7796
 822c660:	e13ffe17 	ldw	r4,-8(fp)
 822c664:	21000f24 	muli	r4,r4,60
 822c668:	1105883a 	add	r2,r2,r4
 822c66c:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].tries = 0;     /* Reset the number of tries */
 822c670:	008209b4 	movhi	r2,2086
 822c674:	10b86304 	addi	r2,r2,-7796
 822c678:	e0fffe17 	ldw	r3,-8(fp)
 822c67c:	18c00f24 	muli	r3,r3,60
 822c680:	10c5883a 	add	r2,r2,r3
 822c684:	10800104 	addi	r2,r2,4
 822c688:	10000015 	stw	zero,0(r2)

   /* If callback is set, call it */
   if (dhc_states[iface].callback)
 822c68c:	008209b4 	movhi	r2,2086
 822c690:	10b86304 	addi	r2,r2,-7796
 822c694:	e0fffe17 	ldw	r3,-8(fp)
 822c698:	18c00f24 	muli	r3,r3,60
 822c69c:	10c5883a 	add	r2,r2,r3
 822c6a0:	10800e04 	addi	r2,r2,56
 822c6a4:	10800017 	ldw	r2,0(r2)
 822c6a8:	10000a26 	beq	r2,zero,822c6d4 <dhc_set_state+0x98>
      dhc_states[iface].callback(iface,state);
 822c6ac:	008209b4 	movhi	r2,2086
 822c6b0:	10b86304 	addi	r2,r2,-7796
 822c6b4:	e0fffe17 	ldw	r3,-8(fp)
 822c6b8:	18c00f24 	muli	r3,r3,60
 822c6bc:	10c5883a 	add	r2,r2,r3
 822c6c0:	10800e04 	addi	r2,r2,56
 822c6c4:	10800017 	ldw	r2,0(r2)
 822c6c8:	e17fff17 	ldw	r5,-4(fp)
 822c6cc:	e13ffe17 	ldw	r4,-8(fp)
 822c6d0:	103ee83a 	callr	r2
}
 822c6d4:	0001883a 	nop
 822c6d8:	e037883a 	mov	sp,fp
 822c6dc:	dfc00117 	ldw	ra,4(sp)
 822c6e0:	df000017 	ldw	fp,0(sp)
 822c6e4:	dec00204 	addi	sp,sp,8
 822c6e8:	f800283a 	ret

0822c6ec <find_opt>:
 * RETURNS:  Return pointer to that code if found, NULL if not found.
 */

u_char * 
find_opt(u_char opcode, u_char * opts)
{
 822c6ec:	defffc04 	addi	sp,sp,-16
 822c6f0:	df000315 	stw	fp,12(sp)
 822c6f4:	df000304 	addi	fp,sp,12
 822c6f8:	2005883a 	mov	r2,r4
 822c6fc:	e17fff15 	stw	r5,-4(fp)
 822c700:	e0bffe05 	stb	r2,-8(fp)
   u_char * end   =  opts  +  DHCP_OPTSIZE;  /* limit scope of search */
 822c704:	e0bfff17 	ldw	r2,-4(fp)
 822c708:	10804e04 	addi	r2,r2,312
 822c70c:	e0bffd15 	stw	r2,-12(fp)

   while (opts < end)
 822c710:	00001e06 	br	822c78c <find_opt+0xa0>
   {
      if (*opts == opcode) /* found it */
 822c714:	e0bfff17 	ldw	r2,-4(fp)
 822c718:	10800003 	ldbu	r2,0(r2)
 822c71c:	10c03fcc 	andi	r3,r2,255
 822c720:	e0bffe03 	ldbu	r2,-8(fp)
 822c724:	1880021e 	bne	r3,r2,822c730 <find_opt+0x44>
         return opts;
 822c728:	e0bfff17 	ldw	r2,-4(fp)
 822c72c:	00001b06 	br	822c79c <find_opt+0xb0>
      if (*opts == DHOP_END)  /* end of options; opcode not found */
 822c730:	e0bfff17 	ldw	r2,-4(fp)
 822c734:	10800003 	ldbu	r2,0(r2)
 822c738:	10803fcc 	andi	r2,r2,255
 822c73c:	10803fd8 	cmpnei	r2,r2,255
 822c740:	1000021e 	bne	r2,zero,822c74c <find_opt+0x60>
         return NULL;
 822c744:	0005883a 	mov	r2,zero
 822c748:	00001406 	br	822c79c <find_opt+0xb0>
      if (*opts == DHOP_PAD)  /* PAD has only 1 byte */
 822c74c:	e0bfff17 	ldw	r2,-4(fp)
 822c750:	10800003 	ldbu	r2,0(r2)
 822c754:	10803fcc 	andi	r2,r2,255
 822c758:	1000041e 	bne	r2,zero,822c76c <find_opt+0x80>
         opts++;
 822c75c:	e0bfff17 	ldw	r2,-4(fp)
 822c760:	10800044 	addi	r2,r2,1
 822c764:	e0bfff15 	stw	r2,-4(fp)
 822c768:	00000806 	br	822c78c <find_opt+0xa0>
      else     /* all other options should have a length field */
         opts += (*(opts+1))+2;
 822c76c:	e0bfff17 	ldw	r2,-4(fp)
 822c770:	10800044 	addi	r2,r2,1
 822c774:	10800003 	ldbu	r2,0(r2)
 822c778:	10803fcc 	andi	r2,r2,255
 822c77c:	10800084 	addi	r2,r2,2
 822c780:	e0ffff17 	ldw	r3,-4(fp)
 822c784:	1885883a 	add	r2,r3,r2
 822c788:	e0bfff15 	stw	r2,-4(fp)
u_char * 
find_opt(u_char opcode, u_char * opts)
{
   u_char * end   =  opts  +  DHCP_OPTSIZE;  /* limit scope of search */

   while (opts < end)
 822c78c:	e0ffff17 	ldw	r3,-4(fp)
 822c790:	e0bffd17 	ldw	r2,-12(fp)
 822c794:	18bfdf36 	bltu	r3,r2,822c714 <find_opt+0x28>
         opts++;
      else     /* all other options should have a length field */
         opts += (*(opts+1))+2;
   }
   /* no DHOP_END option?? */
   return NULL;
 822c798:	0005883a 	mov	r2,zero
}
 822c79c:	e037883a 	mov	sp,fp
 822c7a0:	df000017 	ldw	fp,0(sp)
 822c7a4:	dec00104 	addi	sp,sp,4
 822c7a8:	f800283a 	ret

0822c7ac <pk_init>:
 * for a PACKET buffer or a data buffer fails, or if there is an inconsistency
 * between (bigbufs + lilbufs) and MAXPACKETS) it returns -1. 
 */

int pk_init (void)
{
 822c7ac:	defff804 	addi	sp,sp,-32
 822c7b0:	dfc00715 	stw	ra,28(sp)
 822c7b4:	df000615 	stw	fp,24(sp)
 822c7b8:	df000604 	addi	fp,sp,24
   PACKET packet;
   unsigned i;
   unsigned numpkts = bigbufs + lilbufs;
 822c7bc:	d0e03817 	ldw	r3,-32544(gp)
 822c7c0:	d0a03617 	ldw	r2,-32552(gp)
 822c7c4:	1885883a 	add	r2,r3,r2
 822c7c8:	e0bffd15 	stw	r2,-12(fp)
   u_char align_req;
   
#ifdef ALIGN_BUFS
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
 822c7cc:	e03ffe05 	stb	zero,-8(fp)
#endif

   for (i = 0; i < numpkts; i++)
 822c7d0:	e03ffa15 	stw	zero,-24(fp)
 822c7d4:	00007a06 	br	822c9c0 <pk_init+0x214>
   {
      packet = (PACKET)NB_ALLOC(sizeof(struct netbuf));
 822c7d8:	01000d04 	movi	r4,52
 822c7dc:	822e1c80 	call	822e1c8 <npalloc>
 822c7e0:	e0bfff15 	stw	r2,-4(fp)
      if (packet == NULL)
 822c7e4:	e0bfff17 	ldw	r2,-4(fp)
 822c7e8:	10008426 	beq	r2,zero,822c9fc <pk_init+0x250>
         goto no_pkt_buf;

#ifdef NPDEBUG
      if (i >= MAXPACKETS)
 822c7ec:	e0bffa17 	ldw	r2,-24(fp)
 822c7f0:	10800f30 	cmpltui	r2,r2,60
 822c7f4:	1000051e 	bne	r2,zero,822c80c <pk_init+0x60>
      {
         dprintf("pk_init: bad define\n");
 822c7f8:	01020974 	movhi	r4,2085
 822c7fc:	21023d04 	addi	r4,r4,2292
 822c800:	82036800 	call	8203680 <puts>
         return -1;
 822c804:	00bfffc4 	movi	r2,-1
 822c808:	00008a06 	br	822ca34 <pk_init+0x288>
      }
      pktlog[i] = packet;     /* save for debugging */
 822c80c:	008209b4 	movhi	r2,2086
 822c810:	10b8a804 	addi	r2,r2,-7520
 822c814:	e0fffa17 	ldw	r3,-24(fp)
 822c818:	18c7883a 	add	r3,r3,r3
 822c81c:	18c7883a 	add	r3,r3,r3
 822c820:	10c5883a 	add	r2,r2,r3
 822c824:	e0ffff17 	ldw	r3,-4(fp)
 822c828:	10c00015 	stw	r3,0(r2)
#endif

      packet->nb_tstamp = 0L;
 822c82c:	e0bfff17 	ldw	r2,-4(fp)
 822c830:	10000515 	stw	zero,20(r2)

      if (i < bigbufs)
 822c834:	d0a03817 	ldw	r2,-32544(gp)
 822c838:	e0fffa17 	ldw	r3,-24(fp)
 822c83c:	18802f2e 	bgeu	r3,r2,822c8fc <pk_init+0x150>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
 822c840:	d0a03917 	ldw	r2,-32540(gp)
 822c844:	10800144 	addi	r2,r2,5
 822c848:	1009883a 	mov	r4,r2
 822c84c:	822e23c0 	call	822e23c <ncpalloc>
 822c850:	1007883a 	mov	r3,r2
 822c854:	e0bfff17 	ldw	r2,-4(fp)
 822c858:	10c00115 	stw	r3,4(r2)
            if (!(packet->nb_buff))
 822c85c:	e0bfff17 	ldw	r2,-4(fp)
 822c860:	10800117 	ldw	r2,4(r2)
 822c864:	10006726 	beq	r2,zero,822ca04 <pk_init+0x258>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 822c868:	e03ffb15 	stw	zero,-20(fp)
 822c86c:	00000906 	br	822c894 <pk_init+0xe8>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 822c870:	e0bfff17 	ldw	r2,-4(fp)
 822c874:	10c00117 	ldw	r3,4(r2)
 822c878:	e0bffb17 	ldw	r2,-20(fp)
 822c87c:	1885883a 	add	r2,r3,r2
 822c880:	00c01344 	movi	r3,77
 822c884:	10c00005 	stb	r3,0(r2)
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 822c888:	e0bffb17 	ldw	r2,-20(fp)
 822c88c:	10800044 	addi	r2,r2,1
 822c890:	e0bffb15 	stw	r2,-20(fp)
 822c894:	e0bffb17 	ldw	r2,-20(fp)
 822c898:	10800110 	cmplti	r2,r2,4
 822c89c:	103ff41e 	bne	r2,zero,822c870 <pk_init+0xc4>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + bigbufsiz + ALIGN_TYPE) = 'M';
 822c8a0:	e0bfff17 	ldw	r2,-4(fp)
 822c8a4:	10c00117 	ldw	r3,4(r2)
 822c8a8:	d0a03917 	ldw	r2,-32540(gp)
 822c8ac:	10800104 	addi	r2,r2,4
 822c8b0:	1885883a 	add	r2,r3,r2
 822c8b4:	00c01344 	movi	r3,77
 822c8b8:	10c00005 	stb	r3,0(r2)
            packet->nb_buff += ALIGN_TYPE;   /* bump buf past MMs */
 822c8bc:	e0bfff17 	ldw	r2,-4(fp)
 822c8c0:	10800117 	ldw	r2,4(r2)
 822c8c4:	10c00104 	addi	r3,r2,4
 822c8c8:	e0bfff17 	ldw	r2,-4(fp)
 822c8cc:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 822c8d0:	e0bfff17 	ldw	r2,-4(fp)
 822c8d4:	10800117 	ldw	r2,4(r2)
 822c8d8:	10004c26 	beq	r2,zero,822ca0c <pk_init+0x260>
            goto no_pkt_buf;
         packet->nb_blen = bigbufsiz;
 822c8dc:	d0e03917 	ldw	r3,-32540(gp)
 822c8e0:	e0bfff17 	ldw	r2,-4(fp)
 822c8e4:	10c00215 	stw	r3,8(r2)
         q_add(&bigfreeq, packet);        /* save it in big pkt free queue */
 822c8e8:	e17fff17 	ldw	r5,-4(fp)
 822c8ec:	010209b4 	movhi	r4,2086
 822c8f0:	2138e404 	addi	r4,r4,-7280
 822c8f4:	822cfd80 	call	822cfd8 <putq>
 822c8f8:	00002e06 	br	822c9b4 <pk_init+0x208>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
 822c8fc:	d0a03717 	ldw	r2,-32548(gp)
 822c900:	10800144 	addi	r2,r2,5
 822c904:	1009883a 	mov	r4,r2
 822c908:	822e23c0 	call	822e23c <ncpalloc>
 822c90c:	1007883a 	mov	r3,r2
 822c910:	e0bfff17 	ldw	r2,-4(fp)
 822c914:	10c00115 	stw	r3,4(r2)
            if (!(packet->nb_buff))
 822c918:	e0bfff17 	ldw	r2,-4(fp)
 822c91c:	10800117 	ldw	r2,4(r2)
 822c920:	10003c26 	beq	r2,zero,822ca14 <pk_init+0x268>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 822c924:	e03ffc15 	stw	zero,-16(fp)
 822c928:	00000906 	br	822c950 <pk_init+0x1a4>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 822c92c:	e0bfff17 	ldw	r2,-4(fp)
 822c930:	10c00117 	ldw	r3,4(r2)
 822c934:	e0bffc17 	ldw	r2,-16(fp)
 822c938:	1885883a 	add	r2,r3,r2
 822c93c:	00c01344 	movi	r3,77
 822c940:	10c00005 	stb	r3,0(r2)
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 822c944:	e0bffc17 	ldw	r2,-16(fp)
 822c948:	10800044 	addi	r2,r2,1
 822c94c:	e0bffc15 	stw	r2,-16(fp)
 822c950:	e0bffc17 	ldw	r2,-16(fp)
 822c954:	10800110 	cmplti	r2,r2,4
 822c958:	103ff41e 	bne	r2,zero,822c92c <pk_init+0x180>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + lilbufsiz + ALIGN_TYPE) = 'M';
 822c95c:	e0bfff17 	ldw	r2,-4(fp)
 822c960:	10c00117 	ldw	r3,4(r2)
 822c964:	d0a03717 	ldw	r2,-32548(gp)
 822c968:	10800104 	addi	r2,r2,4
 822c96c:	1885883a 	add	r2,r3,r2
 822c970:	00c01344 	movi	r3,77
 822c974:	10c00005 	stb	r3,0(r2)
            packet->nb_buff += ALIGN_TYPE;
 822c978:	e0bfff17 	ldw	r2,-4(fp)
 822c97c:	10800117 	ldw	r2,4(r2)
 822c980:	10c00104 	addi	r3,r2,4
 822c984:	e0bfff17 	ldw	r2,-4(fp)
 822c988:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 822c98c:	e0bfff17 	ldw	r2,-4(fp)
 822c990:	10800117 	ldw	r2,4(r2)
 822c994:	10002126 	beq	r2,zero,822ca1c <pk_init+0x270>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
 822c998:	d0e03717 	ldw	r3,-32548(gp)
 822c99c:	e0bfff17 	ldw	r2,-4(fp)
 822c9a0:	10c00215 	stw	r3,8(r2)
         q_add(&lilfreeq, packet);        /* save it in little free queue */
 822c9a4:	e17fff17 	ldw	r5,-4(fp)
 822c9a8:	010209b4 	movhi	r4,2086
 822c9ac:	21389f04 	addi	r4,r4,-7556
 822c9b0:	822cfd80 	call	822cfd8 <putq>
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
#endif

   for (i = 0; i < numpkts; i++)
 822c9b4:	e0bffa17 	ldw	r2,-24(fp)
 822c9b8:	10800044 	addi	r2,r2,1
 822c9bc:	e0bffa15 	stw	r2,-24(fp)
 822c9c0:	e0fffa17 	ldw	r3,-24(fp)
 822c9c4:	e0bffd17 	ldw	r2,-12(fp)
 822c9c8:	18bf8336 	bltu	r3,r2,822c7d8 <pk_init+0x2c>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
         q_add(&lilfreeq, packet);        /* save it in little free queue */
      }
   }
   bigfreeq.q_min = bigbufs;
 822c9cc:	d0a03817 	ldw	r2,-32544(gp)
 822c9d0:	1007883a 	mov	r3,r2
 822c9d4:	008209b4 	movhi	r2,2086
 822c9d8:	10b8e404 	addi	r2,r2,-7280
 822c9dc:	10c00415 	stw	r3,16(r2)
   lilfreeq.q_min = lilbufs;
 822c9e0:	d0a03617 	ldw	r2,-32552(gp)
 822c9e4:	1007883a 	mov	r3,r2
 822c9e8:	008209b4 	movhi	r2,2086
 822c9ec:	10b89f04 	addi	r2,r2,-7556
 822c9f0:	10c00415 	stw	r3,16(r2)
   heap_curr_mem_hi_watermark = 0;
   /* set the heap's access type to blocking */
   heap_type = HEAP_ACCESS_BLOCKING;
#endif

   return 0;
 822c9f4:	0005883a 	mov	r2,zero
 822c9f8:	00000e06 	br	822ca34 <pk_init+0x288>

   for (i = 0; i < numpkts; i++)
   {
      packet = (PACKET)NB_ALLOC(sizeof(struct netbuf));
      if (packet == NULL)
         goto no_pkt_buf;
 822c9fc:	0001883a 	nop
 822ca00:	00000706 	br	822ca20 <pk_init+0x274>
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;
 822ca04:	0001883a 	nop
 822ca08:	00000506 	br	822ca20 <pk_init+0x274>
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
            goto no_pkt_buf;
 822ca0c:	0001883a 	nop
 822ca10:	00000306 	br	822ca20 <pk_init+0x274>
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;
 822ca14:	0001883a 	nop
 822ca18:	00000106 	br	822ca20 <pk_init+0x274>
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
            goto no_pkt_buf;
 822ca1c:	0001883a 	nop

   return 0;

no_pkt_buf:
#ifdef NPDEBUG
   dprintf("Netinit: calloc failed getting buffer %d\n", i);
 822ca20:	e17ffa17 	ldw	r5,-24(fp)
 822ca24:	01020974 	movhi	r4,2085
 822ca28:	21024204 	addi	r4,r4,2312
 822ca2c:	82033fc0 	call	82033fc <printf>
#endif
   return(-1);
 822ca30:	00bfffc4 	movi	r2,-1
}
 822ca34:	e037883a 	mov	sp,fp
 822ca38:	dfc00117 	ldw	ra,4(sp)
 822ca3c:	df000017 	ldw	fp,0(sp)
 822ca40:	dec00204 	addi	sp,sp,8
 822ca44:	f800283a 	ret

0822ca48 <pk_alloc>:
 * OUTPUT: 0 if the request cannot be satisfied, or a pointer to the struct
 * netbuf structure that corresponds to the just allocated data buffer.
 */

PACKET pk_alloc(unsigned len)
{
 822ca48:	defffc04 	addi	sp,sp,-16
 822ca4c:	dfc00315 	stw	ra,12(sp)
 822ca50:	df000215 	stw	fp,8(sp)
 822ca54:	df000204 	addi	fp,sp,8
 822ca58:	e13fff15 	stw	r4,-4(fp)
   PACKET p;

   if (len > bigbufsiz) /* caller wants oversize buffer? */
 822ca5c:	d0e03917 	ldw	r3,-32540(gp)
 822ca60:	e0bfff17 	ldw	r2,-4(fp)
 822ca64:	1880022e 	bgeu	r3,r2,822ca70 <pk_alloc+0x28>
   {
#ifdef HEAPBUFS
      if ((p = pk_alloc_heapbuf (len)) == NULL)
         return NULL;
#else
      return(NULL);
 822ca68:	0005883a 	mov	r2,zero
 822ca6c:	00002206 	br	822caf8 <pk_alloc+0xb0>
#endif
   }
   else
   {
      if ((len > lilbufsiz) || (lilfreeq.q_len == 0)) /* must use a big buffer */
 822ca70:	d0e03717 	ldw	r3,-32548(gp)
 822ca74:	e0bfff17 	ldw	r2,-4(fp)
 822ca78:	18800436 	bltu	r3,r2,822ca8c <pk_alloc+0x44>
 822ca7c:	008209b4 	movhi	r2,2086
 822ca80:	10b89f04 	addi	r2,r2,-7556
 822ca84:	10800217 	ldw	r2,8(r2)
 822ca88:	1000051e 	bne	r2,zero,822caa0 <pk_alloc+0x58>
         p = (PACKET)getq(&bigfreeq);
 822ca8c:	010209b4 	movhi	r4,2086
 822ca90:	2138e404 	addi	r4,r4,-7280
 822ca94:	822cf200 	call	822cf20 <getq>
 822ca98:	e0bffe15 	stw	r2,-8(fp)
 822ca9c:	00000406 	br	822cab0 <pk_alloc+0x68>
      else
         p = (PACKET)getq(&lilfreeq);
 822caa0:	010209b4 	movhi	r4,2086
 822caa4:	21389f04 	addi	r4,r4,-7556
 822caa8:	822cf200 	call	822cf20 <getq>
 822caac:	e0bffe15 	stw	r2,-8(fp)

      if (!p)
 822cab0:	e0bffe17 	ldw	r2,-8(fp)
 822cab4:	1000021e 	bne	r2,zero,822cac0 <pk_alloc+0x78>
         return NULL;
 822cab8:	0005883a 	mov	r2,zero
 822cabc:	00000e06 	br	822caf8 <pk_alloc+0xb0>
   }

   p->nb_prot = p->nb_buff + MaxLnh;   /* point past biggest mac header */
 822cac0:	e0bffe17 	ldw	r2,-8(fp)
 822cac4:	10800117 	ldw	r2,4(r2)
 822cac8:	d0e08117 	ldw	r3,-32252(gp)
 822cacc:	10c7883a 	add	r3,r2,r3
 822cad0:	e0bffe17 	ldw	r2,-8(fp)
 822cad4:	10c00315 	stw	r3,12(r2)
   p->nb_plen = 0;   /* no protocol data there yet */
 822cad8:	e0bffe17 	ldw	r2,-8(fp)
 822cadc:	10000415 	stw	zero,16(r2)
   p->net = NULL;
 822cae0:	e0bffe17 	ldw	r2,-8(fp)
 822cae4:	10000615 	stw	zero,24(r2)
   p->nexthop = NULL;      /* no next hop  */
   p->nb_pmtu = 1240;      /* Set minimum IPv6 Path MTU */
#endif   /* IP_V6 */
#endif /* LINKED_PKTS */

   p->inuse = 1;  /* initially buffer in use by 1 user */
 822cae8:	e0bffe17 	ldw	r2,-8(fp)
 822caec:	00c00044 	movi	r3,1
 822caf0:	10c00915 	stw	r3,36(r2)

   /* note that 'type' and 'fhost' fields are not set in pk_alloc () */
   return(p);
 822caf4:	e0bffe17 	ldw	r2,-8(fp)
}
 822caf8:	e037883a 	mov	sp,fp
 822cafc:	dfc00117 	ldw	ra,4(sp)
 822cb00:	df000017 	ldw	fp,0(sp)
 822cb04:	dec00204 	addi	sp,sp,8
 822cb08:	f800283a 	ret

0822cb0c <pk_validate>:
 * OUTPUT: 0 if the buffer being freed was successfully validated, or
 * -1 if the validation failed.
 */

int pk_validate(PACKET pkt)   /* check if pk_free() can free the pkt */
{
 822cb0c:	defffb04 	addi	sp,sp,-20
 822cb10:	dfc00415 	stw	ra,16(sp)
 822cb14:	df000315 	stw	fp,12(sp)
 822cb18:	df000304 	addi	fp,sp,12
 822cb1c:	e13fff15 	stw	r4,-4(fp)
   /* If packet link is non-zero, then this packet is
    * part of a chain and deleted this packet would break
    * the chain and cause memory leak for subsequent pkts.
    * Note that heapbufs do not use the 'next' field at all.
    */
   if ((pkt->next) && (pkt->inuse >= 1))
 822cb20:	e0bfff17 	ldw	r2,-4(fp)
 822cb24:	10800017 	ldw	r2,0(r2)
 822cb28:	10000e26 	beq	r2,zero,822cb64 <pk_validate+0x58>
 822cb2c:	e0bfff17 	ldw	r2,-4(fp)
 822cb30:	10800917 	ldw	r2,36(r2)
 822cb34:	10000b26 	beq	r2,zero,822cb64 <pk_validate+0x58>
   {
      INCR_SHARED_VAR (memestats, INCONSISTENT_LOCATION_ERR, 1);   
 822cb38:	822d7c80 	call	822d7c8 <irq_Mask>
 822cb3c:	008209b4 	movhi	r2,2086
 822cb40:	10b8a404 	addi	r2,r2,-7536
 822cb44:	10800317 	ldw	r2,12(r2)
 822cb48:	10c00044 	addi	r3,r2,1
 822cb4c:	008209b4 	movhi	r2,2086
 822cb50:	10b8a404 	addi	r2,r2,-7536
 822cb54:	10c00315 	stw	r3,12(r2)
 822cb58:	822d8280 	call	822d828 <irq_Unmask>
      return -1;
 822cb5c:	00bfffc4 	movi	r2,-1
 822cb60:	00008806 	br	822cd84 <pk_validate+0x278>
   }
   else  
#endif /* HEAPBUFS */
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
 822cb64:	e0bfff17 	ldw	r2,-4(fp)
 822cb68:	10c00217 	ldw	r3,8(r2)
 822cb6c:	d0a03917 	ldw	r2,-32540(gp)
 822cb70:	1880201e 	bne	r3,r2,822cbf4 <pk_validate+0xe8>
      {
         ENTER_CRIT_SECTION(&bigfreeq);
 822cb74:	822d7c80 	call	822d7c8 <irq_Mask>
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 822cb78:	008209b4 	movhi	r2,2086
 822cb7c:	10b8e404 	addi	r2,r2,-7280
 822cb80:	10800017 	ldw	r2,0(r2)
 822cb84:	e0bffd15 	stw	r2,-12(fp)
 822cb88:	00001606 	br	822cbe4 <pk_validate+0xd8>
            if (p == pkt)
 822cb8c:	e0fffd17 	ldw	r3,-12(fp)
 822cb90:	e0bfff17 	ldw	r2,-4(fp)
 822cb94:	1880101e 	bne	r3,r2,822cbd8 <pk_validate+0xcc>
            {
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
 822cb98:	e17fff17 	ldw	r5,-4(fp)
 822cb9c:	01020974 	movhi	r4,2085
 822cba0:	21024d04 	addi	r4,r4,2356
 822cba4:	82033fc0 	call	82033fc <printf>
               EXIT_CRIT_SECTION(&bigfreeq);
 822cba8:	822d8280 	call	822d828 <irq_Unmask>
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 822cbac:	822d7c80 	call	822d7c8 <irq_Mask>
 822cbb0:	008209b4 	movhi	r2,2086
 822cbb4:	10b8a404 	addi	r2,r2,-7536
 822cbb8:	10800217 	ldw	r2,8(r2)
 822cbbc:	10c00044 	addi	r3,r2,1
 822cbc0:	008209b4 	movhi	r2,2086
 822cbc4:	10b8a404 	addi	r2,r2,-7536
 822cbc8:	10c00215 	stw	r3,8(r2)
 822cbcc:	822d8280 	call	822d828 <irq_Unmask>
               return -1;
 822cbd0:	00bfffc4 	movi	r2,-1
 822cbd4:	00006b06 	br	822cd84 <pk_validate+0x278>
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
      {
         ENTER_CRIT_SECTION(&bigfreeq);
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 822cbd8:	e0bffd17 	ldw	r2,-12(fp)
 822cbdc:	10800017 	ldw	r2,0(r2)
 822cbe0:	e0bffd15 	stw	r2,-12(fp)
 822cbe4:	e0bffd17 	ldw	r2,-12(fp)
 822cbe8:	103fe81e 	bne	r2,zero,822cb8c <pk_validate+0x80>
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
               EXIT_CRIT_SECTION(&bigfreeq);
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
               return -1;
            }
         EXIT_CRIT_SECTION(&bigfreeq);
 822cbec:	822d8280 	call	822d828 <irq_Unmask>
 822cbf0:	00002f06 	br	822ccb0 <pk_validate+0x1a4>
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
 822cbf4:	e0bfff17 	ldw	r2,-4(fp)
 822cbf8:	10c00217 	ldw	r3,8(r2)
 822cbfc:	d0a03717 	ldw	r2,-32548(gp)
 822cc00:	1880201e 	bne	r3,r2,822cc84 <pk_validate+0x178>
      {
         ENTER_CRIT_SECTION(&lilfreeq);
 822cc04:	822d7c80 	call	822d7c8 <irq_Mask>
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 822cc08:	008209b4 	movhi	r2,2086
 822cc0c:	10b89f04 	addi	r2,r2,-7556
 822cc10:	10800017 	ldw	r2,0(r2)
 822cc14:	e0bffd15 	stw	r2,-12(fp)
 822cc18:	00001606 	br	822cc74 <pk_validate+0x168>
            if (p == pkt)
 822cc1c:	e0fffd17 	ldw	r3,-12(fp)
 822cc20:	e0bfff17 	ldw	r2,-4(fp)
 822cc24:	1880101e 	bne	r3,r2,822cc68 <pk_validate+0x15c>
         {
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
 822cc28:	e17fff17 	ldw	r5,-4(fp)
 822cc2c:	01020974 	movhi	r4,2085
 822cc30:	21025704 	addi	r4,r4,2396
 822cc34:	82033fc0 	call	82033fc <printf>
            EXIT_CRIT_SECTION(&lilfreeq);
 822cc38:	822d8280 	call	822d828 <irq_Unmask>
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 822cc3c:	822d7c80 	call	822d7c8 <irq_Mask>
 822cc40:	008209b4 	movhi	r2,2086
 822cc44:	10b8a404 	addi	r2,r2,-7536
 822cc48:	10800217 	ldw	r2,8(r2)
 822cc4c:	10c00044 	addi	r3,r2,1
 822cc50:	008209b4 	movhi	r2,2086
 822cc54:	10b8a404 	addi	r2,r2,-7536
 822cc58:	10c00215 	stw	r3,8(r2)
 822cc5c:	822d8280 	call	822d828 <irq_Unmask>
            return -1;
 822cc60:	00bfffc4 	movi	r2,-1
 822cc64:	00004706 	br	822cd84 <pk_validate+0x278>
         EXIT_CRIT_SECTION(&bigfreeq);
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
      {
         ENTER_CRIT_SECTION(&lilfreeq);
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 822cc68:	e0bffd17 	ldw	r2,-12(fp)
 822cc6c:	10800017 	ldw	r2,0(r2)
 822cc70:	e0bffd15 	stw	r2,-12(fp)
 822cc74:	e0bffd17 	ldw	r2,-12(fp)
 822cc78:	103fe81e 	bne	r2,zero,822cc1c <pk_validate+0x110>
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
            EXIT_CRIT_SECTION(&lilfreeq);
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
            return -1;
         }
         EXIT_CRIT_SECTION(&lilfreeq);
 822cc7c:	822d8280 	call	822d828 <irq_Unmask>
 822cc80:	00000b06 	br	822ccb0 <pk_validate+0x1a4>
      }
      else
      {
         /* log an error */
         INCR_SHARED_VAR (memestats, BAD_REGULAR_BUF_LEN_ERR, 1);
 822cc84:	822d7c80 	call	822d7c8 <irq_Mask>
 822cc88:	008209b4 	movhi	r2,2086
 822cc8c:	10b8a404 	addi	r2,r2,-7536
 822cc90:	10800017 	ldw	r2,0(r2)
 822cc94:	10c00044 	addi	r3,r2,1
 822cc98:	008209b4 	movhi	r2,2086
 822cc9c:	10b8a404 	addi	r2,r2,-7536
 822cca0:	10c00015 	stw	r3,0(r2)
 822cca4:	822d8280 	call	822d828 <irq_Unmask>
         return -1;
 822cca8:	00bfffc4 	movi	r2,-1
 822ccac:	00003506 	br	822cd84 <pk_validate+0x278>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 822ccb0:	00800104 	movi	r2,4
 822ccb4:	e0bffe15 	stw	r2,-8(fp)
 822ccb8:	00001906 	br	822cd20 <pk_validate+0x214>
   {
      if (*(pkt->nb_buff - j) != 'M')
 822ccbc:	e0bfff17 	ldw	r2,-4(fp)
 822ccc0:	10c00117 	ldw	r3,4(r2)
 822ccc4:	e0bffe17 	ldw	r2,-8(fp)
 822ccc8:	0085c83a 	sub	r2,zero,r2
 822cccc:	1885883a 	add	r2,r3,r2
 822ccd0:	10800003 	ldbu	r2,0(r2)
 822ccd4:	10803fcc 	andi	r2,r2,255
 822ccd8:	1080201c 	xori	r2,r2,128
 822ccdc:	10bfe004 	addi	r2,r2,-128
 822cce0:	10801360 	cmpeqi	r2,r2,77
 822cce4:	10000b1e 	bne	r2,zero,822cd14 <pk_validate+0x208>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 822cce8:	822d7c80 	call	822d7c8 <irq_Mask>
 822ccec:	008209b4 	movhi	r2,2086
 822ccf0:	10b8a404 	addi	r2,r2,-7536
 822ccf4:	10800117 	ldw	r2,4(r2)
 822ccf8:	10c00044 	addi	r3,r2,1
 822ccfc:	008209b4 	movhi	r2,2086
 822cd00:	10b8a404 	addi	r2,r2,-7536
 822cd04:	10c00115 	stw	r3,4(r2)
 822cd08:	822d8280 	call	822d828 <irq_Unmask>
         return -1;
 822cd0c:	00bfffc4 	movi	r2,-1
 822cd10:	00001c06 	br	822cd84 <pk_validate+0x278>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 822cd14:	e0bffe17 	ldw	r2,-8(fp)
 822cd18:	10bfffc4 	addi	r2,r2,-1
 822cd1c:	e0bffe15 	stw	r2,-8(fp)
 822cd20:	e0bffe17 	ldw	r2,-8(fp)
 822cd24:	00bfe516 	blt	zero,r2,822ccbc <pk_validate+0x1b0>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
         return -1;
      }
   }
   if (*(pkt->nb_buff + pkt->nb_blen) != 'M')
 822cd28:	e0bfff17 	ldw	r2,-4(fp)
 822cd2c:	10c00117 	ldw	r3,4(r2)
 822cd30:	e0bfff17 	ldw	r2,-4(fp)
 822cd34:	10800217 	ldw	r2,8(r2)
 822cd38:	1885883a 	add	r2,r3,r2
 822cd3c:	10800003 	ldbu	r2,0(r2)
 822cd40:	10803fcc 	andi	r2,r2,255
 822cd44:	1080201c 	xori	r2,r2,128
 822cd48:	10bfe004 	addi	r2,r2,-128
 822cd4c:	10801360 	cmpeqi	r2,r2,77
 822cd50:	10000b1e 	bne	r2,zero,822cd80 <pk_validate+0x274>
   {
      INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 822cd54:	822d7c80 	call	822d7c8 <irq_Mask>
 822cd58:	008209b4 	movhi	r2,2086
 822cd5c:	10b8a404 	addi	r2,r2,-7536
 822cd60:	10800117 	ldw	r2,4(r2)
 822cd64:	10c00044 	addi	r3,r2,1
 822cd68:	008209b4 	movhi	r2,2086
 822cd6c:	10b8a404 	addi	r2,r2,-7536
 822cd70:	10c00115 	stw	r3,4(r2)
 822cd74:	822d8280 	call	822d828 <irq_Unmask>
      return -1;
 822cd78:	00bfffc4 	movi	r2,-1
 822cd7c:	00000106 	br	822cd84 <pk_validate+0x278>
   }
#endif /* NPDEBUG */

   return 0;
 822cd80:	0005883a 	mov	r2,zero
}
 822cd84:	e037883a 	mov	sp,fp
 822cd88:	dfc00117 	ldw	ra,4(sp)
 822cd8c:	df000017 	ldw	fp,0(sp)
 822cd90:	dec00204 	addi	sp,sp,8
 822cd94:	f800283a 	ret

0822cd98 <pk_free>:
 *
 * OUTPUT: None.
 */

void pk_free(PACKET pkt)   /* PACKET to place in free queue */
{
 822cd98:	defffc04 	addi	sp,sp,-16
 822cd9c:	dfc00315 	stw	ra,12(sp)
 822cda0:	df000215 	stw	fp,8(sp)
 822cda4:	df000204 	addi	fp,sp,8
 822cda8:	e13fff15 	stw	r4,-4(fp)
      PACKET pknext;
      pknext = pkt->pk_next;
#endif /* LINKED_PKTS */

      /* validate the pkt before freeing */
      e = pk_validate(pkt);
 822cdac:	e13fff17 	ldw	r4,-4(fp)
 822cdb0:	822cb0c0 	call	822cb0c <pk_validate>
 822cdb4:	e0bffe15 	stw	r2,-8(fp)
      if (e)
 822cdb8:	e0bffe17 	ldw	r2,-8(fp)
 822cdbc:	1000191e 	bne	r2,zero,822ce24 <pk_free+0x8c>
            continue; /* skip this pkt, examine the next pkt */
         }
#endif
         return;
      }
      if (pkt->inuse-- > 1)   /* more than 1 owner? */
 822cdc0:	e0bfff17 	ldw	r2,-4(fp)
 822cdc4:	10800917 	ldw	r2,36(r2)
 822cdc8:	113fffc4 	addi	r4,r2,-1
 822cdcc:	e0ffff17 	ldw	r3,-4(fp)
 822cdd0:	19000915 	stw	r4,36(r3)
 822cdd4:	108000b0 	cmpltui	r2,r2,2
 822cdd8:	10001426 	beq	r2,zero,822ce2c <pk_free+0x94>
         pk_free_heapbuf (pkt);
      }
      else 
#endif /* HEAPBUFS */
      {
         if (pkt->nb_blen == bigbufsiz)
 822cddc:	e0bfff17 	ldw	r2,-4(fp)
 822cde0:	10c00217 	ldw	r3,8(r2)
 822cde4:	d0a03917 	ldw	r2,-32540(gp)
 822cde8:	1880051e 	bne	r3,r2,822ce00 <pk_free+0x68>
            q_add(&bigfreeq, (qp)pkt);
 822cdec:	e17fff17 	ldw	r5,-4(fp)
 822cdf0:	010209b4 	movhi	r4,2086
 822cdf4:	2138e404 	addi	r4,r4,-7280
 822cdf8:	822cfd80 	call	822cfd8 <putq>
 822cdfc:	00000c06 	br	822ce30 <pk_free+0x98>
         else if (pkt->nb_blen == lilbufsiz)
 822ce00:	e0bfff17 	ldw	r2,-4(fp)
 822ce04:	10c00217 	ldw	r3,8(r2)
 822ce08:	d0a03717 	ldw	r2,-32548(gp)
 822ce0c:	1880081e 	bne	r3,r2,822ce30 <pk_free+0x98>
            q_add(&lilfreeq, (qp)pkt);
 822ce10:	e17fff17 	ldw	r5,-4(fp)
 822ce14:	010209b4 	movhi	r4,2086
 822ce18:	21389f04 	addi	r4,r4,-7556
 822ce1c:	822cfd80 	call	822cfd8 <putq>
 822ce20:	00000306 	br	822ce30 <pk_free+0x98>
         {
            pkt = pknext;
            continue; /* skip this pkt, examine the next pkt */
         }
#endif
         return;
 822ce24:	0001883a 	nop
 822ce28:	00000106 	br	822ce30 <pk_free+0x98>
      }
      if (pkt->inuse-- > 1)   /* more than 1 owner? */
         return;  /* packet was cloned, don't delete yet */
 822ce2c:	0001883a 	nop
#ifdef LINKED_PKTS
      pkt = pknext;
   }
#endif 

}
 822ce30:	e037883a 	mov	sp,fp
 822ce34:	dfc00117 	ldw	ra,4(sp)
 822ce38:	df000017 	ldw	fp,0(sp)
 822ce3c:	dec00204 	addi	sp,sp,8
 822ce40:	f800283a 	ret

0822ce44 <pk_get_max_intrsafe_buf_len>:
 *
 * OUTPUT: This function always returns the length of a big buffer (bigbufsiz).
 */

unsigned pk_get_max_intrsafe_buf_len(void)
{
 822ce44:	deffff04 	addi	sp,sp,-4
 822ce48:	df000015 	stw	fp,0(sp)
 822ce4c:	d839883a 	mov	fp,sp
   return bigbufsiz;
 822ce50:	d0a03917 	ldw	r2,-32540(gp)
}
 822ce54:	e037883a 	mov	sp,fp
 822ce58:	df000017 	ldw	fp,0(sp)
 822ce5c:	dec00104 	addi	sp,sp,4
 822ce60:	f800283a 	ret

0822ce64 <dump_buf_estats>:
 *
 * OUTPUT: This function always returns 0.
 */

int dump_buf_estats (void * pio)
{
 822ce64:	defff904 	addi	sp,sp,-28
 822ce68:	dfc00615 	stw	ra,24(sp)
 822ce6c:	df000515 	stw	fp,20(sp)
 822ce70:	df000504 	addi	fp,sp,20
 822ce74:	e13fff15 	stw	r4,-4(fp)
   u_long mlocal [MEMERR_NUM_STATS];

   LOCK_NET_RESOURCE(FREEQ_RESID);
 822ce78:	01000084 	movi	r4,2
 822ce7c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   ENTER_CRIT_SECTION(&memestats);
 822ce80:	822d7c80 	call	822d7c8 <irq_Mask>
   MEMCPY (&mlocal, &memestats, sizeof(memestats));
 822ce84:	008209b4 	movhi	r2,2086
 822ce88:	10b8a404 	addi	r2,r2,-7536
 822ce8c:	10c00017 	ldw	r3,0(r2)
 822ce90:	e0fffb15 	stw	r3,-20(fp)
 822ce94:	10c00117 	ldw	r3,4(r2)
 822ce98:	e0fffc15 	stw	r3,-16(fp)
 822ce9c:	10c00217 	ldw	r3,8(r2)
 822cea0:	e0fffd15 	stw	r3,-12(fp)
 822cea4:	10800317 	ldw	r2,12(r2)
 822cea8:	e0bffe15 	stw	r2,-8(fp)
   EXIT_CRIT_SECTION(&memestats);
 822ceac:	822d8280 	call	822d828 <irq_Unmask>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822ceb0:	01000084 	movi	r4,2
 822ceb4:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>

   ns_printf(pio, "Regular buffer error statistics:\n");
 822ceb8:	01420974 	movhi	r5,2085
 822cebc:	29426104 	addi	r5,r5,2436
 822cec0:	e13fff17 	ldw	r4,-4(fp)
 822cec4:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf(pio, "Bad buffer length %lu, Guard band violations %lu\n",mlocal[BAD_REGULAR_BUF_LEN_ERR],mlocal[GUARD_BAND_VIOLATED_ERR]);
 822cec8:	e0bffb17 	ldw	r2,-20(fp)
 822cecc:	e0fffc17 	ldw	r3,-16(fp)
 822ced0:	180f883a 	mov	r7,r3
 822ced4:	100d883a 	mov	r6,r2
 822ced8:	01420974 	movhi	r5,2085
 822cedc:	29426a04 	addi	r5,r5,2472
 822cee0:	e13fff17 	ldw	r4,-4(fp)
 822cee4:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf(pio, "Multiple frees %lu, Inconsistent location %lu\n",mlocal[MULTIPLE_FREE_ERR],mlocal[INCONSISTENT_LOCATION_ERR]);
 822cee8:	e0bffd17 	ldw	r2,-12(fp)
 822ceec:	e0fffe17 	ldw	r3,-8(fp)
 822cef0:	180f883a 	mov	r7,r3
 822cef4:	100d883a 	mov	r6,r2
 822cef8:	01420974 	movhi	r5,2085
 822cefc:	29427704 	addi	r5,r5,2524
 822cf00:	e13fff17 	ldw	r4,-4(fp)
 822cf04:	8228ebc0 	call	8228ebc <ns_printf>

   return 0;
 822cf08:	0005883a 	mov	r2,zero
}
 822cf0c:	e037883a 	mov	sp,fp
 822cf10:	dfc00117 	ldw	ra,4(sp)
 822cf14:	df000017 	ldw	fp,0(sp)
 822cf18:	dec00204 	addi	sp,sp,8
 822cf1c:	f800283a 	ret

0822cf20 <getq>:
 * RETURNS: pointer to the first element if any, or 0 if the queue is empty.
 */

void*
getq(queue * q)
{
 822cf20:	defffc04 	addi	sp,sp,-16
 822cf24:	dfc00315 	stw	ra,12(sp)
 822cf28:	df000215 	stw	fp,8(sp)
 822cf2c:	df000204 	addi	fp,sp,8
 822cf30:	e13fff15 	stw	r4,-4(fp)
   q_elt   temp;        /* temp for result */


   ENTER_CRIT_SECTION(q);     /* shut off ints, save old state */   
 822cf34:	822d7c80 	call	822d7c8 <irq_Mask>

   LOCKNET_CHECK(q);          /* make sure queue is protected */

   if ((temp = q->q_head) == 0)  /* queue empty? */
 822cf38:	e0bfff17 	ldw	r2,-4(fp)
 822cf3c:	10800017 	ldw	r2,0(r2)
 822cf40:	e0bffe15 	stw	r2,-8(fp)
 822cf44:	e0bffe17 	ldw	r2,-8(fp)
 822cf48:	1000031e 	bne	r2,zero,822cf58 <getq+0x38>
   {
      EXIT_CRIT_SECTION(q);
 822cf4c:	822d8280 	call	822d828 <irq_Unmask>
      return (0);             /* yes, show none */
 822cf50:	0005883a 	mov	r2,zero
 822cf54:	00001b06 	br	822cfc4 <getq+0xa4>
   }

   q->q_head = temp->qe_next; /* else unlink */
 822cf58:	e0bffe17 	ldw	r2,-8(fp)
 822cf5c:	10c00017 	ldw	r3,0(r2)
 822cf60:	e0bfff17 	ldw	r2,-4(fp)
 822cf64:	10c00015 	stw	r3,0(r2)
   temp->qe_next = 0;         /* avoid dangling pointers */
 822cf68:	e0bffe17 	ldw	r2,-8(fp)
 822cf6c:	10000015 	stw	zero,0(r2)
   if (q->q_head == 0)        /* queue empty? */
 822cf70:	e0bfff17 	ldw	r2,-4(fp)
 822cf74:	10800017 	ldw	r2,0(r2)
 822cf78:	1000021e 	bne	r2,zero,822cf84 <getq+0x64>
      q->q_tail = 0;          /* yes, update tail pointer too */
 822cf7c:	e0bfff17 	ldw	r2,-4(fp)
 822cf80:	10000115 	stw	zero,4(r2)
   q->q_len--;                /* update queue length */
 822cf84:	e0bfff17 	ldw	r2,-4(fp)
 822cf88:	10800217 	ldw	r2,8(r2)
 822cf8c:	10ffffc4 	addi	r3,r2,-1
 822cf90:	e0bfff17 	ldw	r2,-4(fp)
 822cf94:	10c00215 	stw	r3,8(r2)
   if (q->q_len < q->q_min)
 822cf98:	e0bfff17 	ldw	r2,-4(fp)
 822cf9c:	10c00217 	ldw	r3,8(r2)
 822cfa0:	e0bfff17 	ldw	r2,-4(fp)
 822cfa4:	10800417 	ldw	r2,16(r2)
 822cfa8:	1880040e 	bge	r3,r2,822cfbc <getq+0x9c>
      q->q_min = q->q_len;
 822cfac:	e0bfff17 	ldw	r2,-4(fp)
 822cfb0:	10c00217 	ldw	r3,8(r2)
 822cfb4:	e0bfff17 	ldw	r2,-4(fp)
 822cfb8:	10c00415 	stw	r3,16(r2)

   QUEUE_CHECK(q);         /* make sure queue is not corrupted */

   EXIT_CRIT_SECTION(q);   /* restore caller's int state */
 822cfbc:	822d8280 	call	822d828 <irq_Unmask>

   return ((void*)temp);
 822cfc0:	e0bffe17 	ldw	r2,-8(fp)
}
 822cfc4:	e037883a 	mov	sp,fp
 822cfc8:	dfc00117 	ldw	ra,4(sp)
 822cfcc:	df000017 	ldw	fp,0(sp)
 822cfd0:	dec00204 	addi	sp,sp,8
 822cfd4:	f800283a 	ret

0822cfd8 <putq>:

void
putq(
   queue   *   q,       /* the queue */
   void *   elt)        /* element to delete */
{
 822cfd8:	defffc04 	addi	sp,sp,-16
 822cfdc:	dfc00315 	stw	ra,12(sp)
 822cfe0:	df000215 	stw	fp,8(sp)
 822cfe4:	df000204 	addi	fp,sp,8
 822cfe8:	e13ffe15 	stw	r4,-8(fp)
 822cfec:	e17fff15 	stw	r5,-4(fp)
   ENTER_CRIT_SECTION(q);
 822cff0:	822d7c80 	call	822d7c8 <irq_Mask>
   LOCKNET_CHECK(q);       /* make sure queue is protected */
   q_addt(q, (qp)elt);     /* use macro to do work */
 822cff4:	e0bfff17 	ldw	r2,-4(fp)
 822cff8:	10000015 	stw	zero,0(r2)
 822cffc:	e0bffe17 	ldw	r2,-8(fp)
 822d000:	10800017 	ldw	r2,0(r2)
 822d004:	1000041e 	bne	r2,zero,822d018 <putq+0x40>
 822d008:	e0bffe17 	ldw	r2,-8(fp)
 822d00c:	e0ffff17 	ldw	r3,-4(fp)
 822d010:	10c00015 	stw	r3,0(r2)
 822d014:	00000406 	br	822d028 <putq+0x50>
 822d018:	e0bffe17 	ldw	r2,-8(fp)
 822d01c:	10800117 	ldw	r2,4(r2)
 822d020:	e0ffff17 	ldw	r3,-4(fp)
 822d024:	10c00015 	stw	r3,0(r2)
 822d028:	e0bffe17 	ldw	r2,-8(fp)
 822d02c:	e0ffff17 	ldw	r3,-4(fp)
 822d030:	10c00115 	stw	r3,4(r2)
 822d034:	e0bffe17 	ldw	r2,-8(fp)
 822d038:	10800217 	ldw	r2,8(r2)
 822d03c:	10c00044 	addi	r3,r2,1
 822d040:	e0bffe17 	ldw	r2,-8(fp)
 822d044:	10c00215 	stw	r3,8(r2)
 822d048:	e0bffe17 	ldw	r2,-8(fp)
 822d04c:	10800217 	ldw	r2,8(r2)
 822d050:	e0fffe17 	ldw	r3,-8(fp)
 822d054:	18c00317 	ldw	r3,12(r3)
 822d058:	1880040e 	bge	r3,r2,822d06c <putq+0x94>
 822d05c:	e0bffe17 	ldw	r2,-8(fp)
 822d060:	10c00217 	ldw	r3,8(r2)
 822d064:	e0bffe17 	ldw	r2,-8(fp)
 822d068:	10c00315 	stw	r3,12(r2)
   QUEUE_CHECK(q);         /* make sure queue is not corrupted */
   EXIT_CRIT_SECTION(q);   /* restore int state */
 822d06c:	822d8280 	call	822d828 <irq_Unmask>
}
 822d070:	0001883a 	nop
 822d074:	e037883a 	mov	sp,fp
 822d078:	dfc00117 	ldw	ra,4(sp)
 822d07c:	df000017 	ldw	fp,0(sp)
 822d080:	dec00204 	addi	sp,sp,8
 822d084:	f800283a 	ret

0822d088 <qdel>:
 * RETURNS: Return pointer to queue member if found, else NULL. 
 */

qp
qdel(queue * q, void * elt)
{
 822d088:	defffa04 	addi	sp,sp,-24
 822d08c:	dfc00515 	stw	ra,20(sp)
 822d090:	df000415 	stw	fp,16(sp)
 822d094:	df000404 	addi	fp,sp,16
 822d098:	e13ffe15 	stw	r4,-8(fp)
 822d09c:	e17fff15 	stw	r5,-4(fp)
   qp qptr;
   qp qlast;

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
 822d0a0:	822d7c80 	call	822d7c8 <irq_Mask>
   qptr = q->q_head;
 822d0a4:	e0bffe17 	ldw	r2,-8(fp)
 822d0a8:	10800017 	ldw	r2,0(r2)
 822d0ac:	e0bffc15 	stw	r2,-16(fp)
   qlast = NULL;
 822d0b0:	e03ffd15 	stw	zero,-12(fp)
   while (qptr)
 822d0b4:	00002b06 	br	822d164 <qdel+0xdc>
   {
      if (qptr == (qp)elt)
 822d0b8:	e0fffc17 	ldw	r3,-16(fp)
 822d0bc:	e0bfff17 	ldw	r2,-4(fp)
 822d0c0:	1880231e 	bne	r3,r2,822d150 <qdel+0xc8>
      {
         /* found our item; dequeue it */
         if (qlast)
 822d0c4:	e0bffd17 	ldw	r2,-12(fp)
 822d0c8:	10000526 	beq	r2,zero,822d0e0 <qdel+0x58>
            qlast->qe_next = qptr->qe_next;
 822d0cc:	e0bffc17 	ldw	r2,-16(fp)
 822d0d0:	10c00017 	ldw	r3,0(r2)
 822d0d4:	e0bffd17 	ldw	r2,-12(fp)
 822d0d8:	10c00015 	stw	r3,0(r2)
 822d0dc:	00000406 	br	822d0f0 <qdel+0x68>
         else     /* item was at head of queqe */
            q->q_head = qptr->qe_next;
 822d0e0:	e0bffc17 	ldw	r2,-16(fp)
 822d0e4:	10c00017 	ldw	r3,0(r2)
 822d0e8:	e0bffe17 	ldw	r2,-8(fp)
 822d0ec:	10c00015 	stw	r3,0(r2)

         /* fix queue tail pointer if needed */
         if (q->q_tail == (qp)elt)
 822d0f0:	e0bffe17 	ldw	r2,-8(fp)
 822d0f4:	10c00117 	ldw	r3,4(r2)
 822d0f8:	e0bfff17 	ldw	r2,-4(fp)
 822d0fc:	1880031e 	bne	r3,r2,822d10c <qdel+0x84>
            q->q_tail = qlast;
 822d100:	e0bffe17 	ldw	r2,-8(fp)
 822d104:	e0fffd17 	ldw	r3,-12(fp)
 822d108:	10c00115 	stw	r3,4(r2)

         /* fix queue counters */
         q->q_len--;
 822d10c:	e0bffe17 	ldw	r2,-8(fp)
 822d110:	10800217 	ldw	r2,8(r2)
 822d114:	10ffffc4 	addi	r3,r2,-1
 822d118:	e0bffe17 	ldw	r2,-8(fp)
 822d11c:	10c00215 	stw	r3,8(r2)
         if (q->q_len < q->q_min)
 822d120:	e0bffe17 	ldw	r2,-8(fp)
 822d124:	10c00217 	ldw	r3,8(r2)
 822d128:	e0bffe17 	ldw	r2,-8(fp)
 822d12c:	10800417 	ldw	r2,16(r2)
 822d130:	1880040e 	bge	r3,r2,822d144 <qdel+0xbc>
            q->q_min = q->q_len;
 822d134:	e0bffe17 	ldw	r2,-8(fp)
 822d138:	10c00217 	ldw	r3,8(r2)
 822d13c:	e0bffe17 	ldw	r2,-8(fp)
 822d140:	10c00415 	stw	r3,16(r2)
         EXIT_CRIT_SECTION(q);   /* restore int state */
 822d144:	822d8280 	call	822d828 <irq_Unmask>
         return (qp)elt;   /* success exit point */
 822d148:	e0bfff17 	ldw	r2,-4(fp)
 822d14c:	00000906 	br	822d174 <qdel+0xec>
      }
      qlast = qptr;
 822d150:	e0bffc17 	ldw	r2,-16(fp)
 822d154:	e0bffd15 	stw	r2,-12(fp)
      qptr = qptr->qe_next;
 822d158:	e0bffc17 	ldw	r2,-16(fp)
 822d15c:	10800017 	ldw	r2,0(r2)
 822d160:	e0bffc15 	stw	r2,-16(fp)

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
   qptr = q->q_head;
   qlast = NULL;
   while (qptr)
 822d164:	e0bffc17 	ldw	r2,-16(fp)
 822d168:	103fd31e 	bne	r2,zero,822d0b8 <qdel+0x30>
         return (qp)elt;   /* success exit point */
      }
      qlast = qptr;
      qptr = qptr->qe_next;
   }
   EXIT_CRIT_SECTION(q);   /* restore int state */
 822d16c:	822d8280 	call	822d828 <irq_Unmask>
   return NULL;   /* item not found in queue */
 822d170:	0005883a 	mov	r2,zero
}
 822d174:	e037883a 	mov	sp,fp
 822d178:	dfc00117 	ldw	ra,4(sp)
 822d17c:	df000017 	ldw	fp,0(sp)
 822d180:	dec00204 	addi	sp,sp,8
 822d184:	f800283a 	ret

0822d188 <udp_open>:
   ip_addr  fhost,      /* foreign host, 0L for any */
   unshort  fsock,      /* foreign socket, 0 for any */
   unshort  lsock,      /* local socket */
   int (*handler)(PACKET, void*),   /* rcv upcall */
   void *   data)       /* random data, returned on upcalls to aid demuxing */
{
 822d188:	defff404 	addi	sp,sp,-48
 822d18c:	dfc00b15 	stw	ra,44(sp)
 822d190:	df000a15 	stw	fp,40(sp)
 822d194:	df000a04 	addi	fp,sp,40
 822d198:	e13ffc15 	stw	r4,-16(fp)
 822d19c:	2807883a 	mov	r3,r5
 822d1a0:	3005883a 	mov	r2,r6
 822d1a4:	e1ffff15 	stw	r7,-4(fp)
 822d1a8:	e0fffd0d 	sth	r3,-12(fp)
 822d1ac:	e0bffe0d 	sth	r2,-8(fp)
/*
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
 822d1b0:	d0a08317 	ldw	r2,-32244(gp)
 822d1b4:	1080010c 	andi	r2,r2,4
 822d1b8:	10001526 	beq	r2,zero,822d210 <udp_open+0x88>
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 822d1bc:	e0bffc17 	ldw	r2,-16(fp)
 822d1c0:	12003fcc 	andi	r8,r2,255
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
 822d1c4:	e0bffc17 	ldw	r2,-16(fp)
 822d1c8:	1004d23a 	srli	r2,r2,8
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 822d1cc:	11803fcc 	andi	r6,r2,255
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
 822d1d0:	e0bffc17 	ldw	r2,-16(fp)
 822d1d4:	1004d43a 	srli	r2,r2,16
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 822d1d8:	11c03fcc 	andi	r7,r2,255
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
 822d1dc:	e0bffc17 	ldw	r2,-16(fp)
 822d1e0:	1004d63a 	srli	r2,r2,24
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 822d1e4:	e0fffe0b 	ldhu	r3,-8(fp)
 822d1e8:	e13ffd0b 	ldhu	r4,-12(fp)
 822d1ec:	e1400217 	ldw	r5,8(fp)
 822d1f0:	d9400315 	stw	r5,12(sp)
 822d1f4:	d9000215 	stw	r4,8(sp)
 822d1f8:	d8c00115 	stw	r3,4(sp)
 822d1fc:	d8800015 	stw	r2,0(sp)
 822d200:	400b883a 	mov	r5,r8
 822d204:	01020974 	movhi	r4,2085
 822d208:	21028304 	addi	r4,r4,2572
 822d20c:	82033fc0 	call	82033fc <printf>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 822d210:	0009883a 	mov	r4,zero
 822d214:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   ocon = NULL;
 822d218:	e03ffb15 	stw	zero,-20(fp)
   for (con = firstudp; con; con = con->u_next)
 822d21c:	d0a09c17 	ldw	r2,-32144(gp)
 822d220:	e0bffa15 	stw	r2,-24(fp)
 822d224:	00002006 	br	822d2a8 <udp_open+0x120>
   {
      ocon = con;       /* remember last con in list */
 822d228:	e0bffa17 	ldw	r2,-24(fp)
 822d22c:	e0bffb15 	stw	r2,-20(fp)
      /* we only want to check UDP-over-IPv4 connections */
      if (!(con->u_flags & UDPCF_V4))
         continue;
#endif

      if (con->u_lport == lsock && con->u_fport == fsock &&
 822d230:	e0bffa17 	ldw	r2,-24(fp)
 822d234:	1080018b 	ldhu	r2,6(r2)
 822d238:	10ffffcc 	andi	r3,r2,65535
 822d23c:	e0bffe0b 	ldhu	r2,-8(fp)
 822d240:	1880161e 	bne	r3,r2,822d29c <udp_open+0x114>
 822d244:	e0bffa17 	ldw	r2,-24(fp)
 822d248:	1080020b 	ldhu	r2,8(r2)
 822d24c:	10ffffcc 	andi	r3,r2,65535
 822d250:	e0bffd0b 	ldhu	r2,-12(fp)
 822d254:	1880111e 	bne	r3,r2,822d29c <udp_open+0x114>
          con->u_lhost == 0 && con->u_fhost == fhost)
 822d258:	e0bffa17 	ldw	r2,-24(fp)
 822d25c:	10800317 	ldw	r2,12(r2)
      /* we only want to check UDP-over-IPv4 connections */
      if (!(con->u_flags & UDPCF_V4))
         continue;
#endif

      if (con->u_lport == lsock && con->u_fport == fsock &&
 822d260:	10000e1e 	bne	r2,zero,822d29c <udp_open+0x114>
          con->u_lhost == 0 && con->u_fhost == fhost)
 822d264:	e0bffa17 	ldw	r2,-24(fp)
 822d268:	10c00417 	ldw	r3,16(r2)
 822d26c:	e0bffc17 	ldw	r2,-16(fp)
 822d270:	18800a1e 	bne	r3,r2,822d29c <udp_open+0x114>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (INFOMSG|PROTERR))
 822d274:	d0a08317 	ldw	r2,-32244(gp)
 822d278:	1080050c 	andi	r2,r2,20
 822d27c:	10000326 	beq	r2,zero,822d28c <udp_open+0x104>
            dprintf("UDP: Connection already exists.\n");
 822d280:	01020974 	movhi	r4,2085
 822d284:	21029204 	addi	r4,r4,2632
 822d288:	82036800 	call	8203680 <puts>
#endif
         UNLOCK_NET_RESOURCE(NET_RESID);
 822d28c:	0009883a 	mov	r4,zero
 822d290:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         return(NULL);
 822d294:	0005883a 	mov	r2,zero
 822d298:	00003506 	br	822d370 <udp_open+0x1e8>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
   ocon = NULL;
   for (con = firstudp; con; con = con->u_next)
 822d29c:	e0bffa17 	ldw	r2,-24(fp)
 822d2a0:	10800017 	ldw	r2,0(r2)
 822d2a4:	e0bffa15 	stw	r2,-24(fp)
 822d2a8:	e0bffa17 	ldw	r2,-24(fp)
 822d2ac:	103fde1e 	bne	r2,zero,822d228 <udp_open+0xa0>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return(NULL);
      }
   }

   con = (UDPCONN)UC_ALLOC(sizeof(struct udp_conn));
 822d2b0:	01000804 	movi	r4,32
 822d2b4:	822e1c80 	call	822e1c8 <npalloc>
 822d2b8:	e0bffa15 	stw	r2,-24(fp)
   if (con == 0)
 822d2bc:	e0bffa17 	ldw	r2,-24(fp)
 822d2c0:	10000a1e 	bne	r2,zero,822d2ec <udp_open+0x164>
   {
#ifdef   NPDEBUG
      if (NDEBUG & INFOMSG)
 822d2c4:	d0a08317 	ldw	r2,-32244(gp)
 822d2c8:	1080010c 	andi	r2,r2,4
 822d2cc:	10000326 	beq	r2,zero,822d2dc <udp_open+0x154>
         dprintf("UDP: Couldn't allocate conn storage.\n");
 822d2d0:	01020974 	movhi	r4,2085
 822d2d4:	21029a04 	addi	r4,r4,2664
 822d2d8:	82036800 	call	8203680 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 822d2dc:	0009883a 	mov	r4,zero
 822d2e0:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return(NULL);
 822d2e4:	0005883a 	mov	r2,zero
 822d2e8:	00002106 	br	822d370 <udp_open+0x1e8>
   }

   if (ocon)   /* ocon is end of list */
 822d2ec:	e0bffb17 	ldw	r2,-20(fp)
 822d2f0:	10000426 	beq	r2,zero,822d304 <udp_open+0x17c>
      ocon->u_next = con;  /* add new connection to end */
 822d2f4:	e0bffb17 	ldw	r2,-20(fp)
 822d2f8:	e0fffa17 	ldw	r3,-24(fp)
 822d2fc:	10c00015 	stw	r3,0(r2)
 822d300:	00000206 	br	822d30c <udp_open+0x184>
   else  /* no list, start one */
      firstudp = con;
 822d304:	e0bffa17 	ldw	r2,-24(fp)
 822d308:	d0a09c15 	stw	r2,-32144(gp)

   con->u_next = 0;
 822d30c:	e0bffa17 	ldw	r2,-24(fp)
 822d310:	10000015 	stw	zero,0(r2)

   con->u_lport = lsock;      /* fill in connection info */
 822d314:	e0bffa17 	ldw	r2,-24(fp)
 822d318:	e0fffe0b 	ldhu	r3,-8(fp)
 822d31c:	10c0018d 	sth	r3,6(r2)
   con->u_fport = fsock;
 822d320:	e0bffa17 	ldw	r2,-24(fp)
 822d324:	e0fffd0b 	ldhu	r3,-12(fp)
 822d328:	10c0020d 	sth	r3,8(r2)
   con->u_lhost = 0;
 822d32c:	e0bffa17 	ldw	r2,-24(fp)
 822d330:	10000315 	stw	zero,12(r2)
   con->u_fhost = fhost;
 822d334:	e0bffa17 	ldw	r2,-24(fp)
 822d338:	e0fffc17 	ldw	r3,-16(fp)
 822d33c:	10c00415 	stw	r3,16(r2)
   con->u_rcv   = handler;
 822d340:	e0bffa17 	ldw	r2,-24(fp)
 822d344:	e0ffff17 	ldw	r3,-4(fp)
 822d348:	10c00515 	stw	r3,20(r2)
   con->u_data  = data;
 822d34c:	e0bffa17 	ldw	r2,-24(fp)
 822d350:	e0c00217 	ldw	r3,8(fp)
 822d354:	10c00615 	stw	r3,24(r2)
   con->u_flags = UDPCF_V4;
 822d358:	e0bffa17 	ldw	r2,-24(fp)
 822d35c:	00c00044 	movi	r3,1
 822d360:	10c0010d 	sth	r3,4(r2)

   UNLOCK_NET_RESOURCE(NET_RESID);
 822d364:	0009883a 	mov	r4,zero
 822d368:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   return(con);
 822d36c:	e0bffa17 	ldw	r2,-24(fp)
}
 822d370:	e037883a 	mov	sp,fp
 822d374:	dfc00117 	ldw	ra,4(sp)
 822d378:	df000017 	ldw	fp,0(sp)
 822d37c:	dec00204 	addi	sp,sp,8
 822d380:	f800283a 	ret

0822d384 <udp_close>:
 * RETURNS: void
 */

void
udp_close(UDPCONN con)
{
 822d384:	defffb04 	addi	sp,sp,-20
 822d388:	dfc00415 	stw	ra,16(sp)
 822d38c:	df000315 	stw	fp,12(sp)
 822d390:	df000304 	addi	fp,sp,12
 822d394:	e13fff15 	stw	r4,-4(fp)
   UDPCONN pcon;
   UDPCONN lcon;

#ifdef NPDEBUG
   if ((con == NULL) || (firstudp == NULL))
 822d398:	e0bfff17 	ldw	r2,-4(fp)
 822d39c:	10000226 	beq	r2,zero,822d3a8 <udp_close+0x24>
 822d3a0:	d0a09c17 	ldw	r2,-32144(gp)
 822d3a4:	1000021e 	bne	r2,zero,822d3b0 <udp_close+0x2c>
   {
      dtrap(); /* bad programming! */
 822d3a8:	822d5f00 	call	822d5f0 <dtrap>
      return;
 822d3ac:	00002606 	br	822d448 <udp_close+0xc4>
   }
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 822d3b0:	0009883a 	mov	r4,zero
 822d3b4:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
 822d3b8:	e03ffe15 	stw	zero,-8(fp)
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 822d3bc:	d0a09c17 	ldw	r2,-32144(gp)
 822d3c0:	e0bffd15 	stw	r2,-12(fp)
 822d3c4:	00000806 	br	822d3e8 <udp_close+0x64>
   {
      if (pcon == con)  /* found connection to delete */
 822d3c8:	e0fffd17 	ldw	r3,-12(fp)
 822d3cc:	e0bfff17 	ldw	r2,-4(fp)
 822d3d0:	18800826 	beq	r3,r2,822d3f4 <udp_close+0x70>
      break;
      lcon = pcon;   /* remember last connection */
 822d3d4:	e0bffd17 	ldw	r2,-12(fp)
 822d3d8:	e0bffe15 	stw	r2,-8(fp)
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 822d3dc:	e0bffd17 	ldw	r2,-12(fp)
 822d3e0:	10800017 	ldw	r2,0(r2)
 822d3e4:	e0bffd15 	stw	r2,-12(fp)
 822d3e8:	e0bffd17 	ldw	r2,-12(fp)
 822d3ec:	103ff61e 	bne	r2,zero,822d3c8 <udp_close+0x44>
 822d3f0:	00000106 	br	822d3f8 <udp_close+0x74>
   {
      if (pcon == con)  /* found connection to delete */
      break;
 822d3f4:	0001883a 	nop
      lcon = pcon;   /* remember last connection */
   }

   if (!pcon)
 822d3f8:	e0bffd17 	ldw	r2,-12(fp)
 822d3fc:	1000041e 	bne	r2,zero,822d410 <udp_close+0x8c>
   {
      dtrap(); /* prog error - connenction not in list */
 822d400:	822d5f00 	call	822d5f0 <dtrap>
      UNLOCK_NET_RESOURCE(NET_RESID);
 822d404:	0009883a 	mov	r4,zero
 822d408:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return;
 822d40c:	00000e06 	br	822d448 <udp_close+0xc4>
   }

   if (lcon)   /* in con is not head of list */
 822d410:	e0bffe17 	ldw	r2,-8(fp)
 822d414:	10000526 	beq	r2,zero,822d42c <udp_close+0xa8>
      lcon->u_next = con->u_next;   /* unlink */
 822d418:	e0bfff17 	ldw	r2,-4(fp)
 822d41c:	10c00017 	ldw	r3,0(r2)
 822d420:	e0bffe17 	ldw	r2,-8(fp)
 822d424:	10c00015 	stw	r3,0(r2)
 822d428:	00000306 	br	822d438 <udp_close+0xb4>
   else
      firstudp = con->u_next; /* remove from head */
 822d42c:	e0bfff17 	ldw	r2,-4(fp)
 822d430:	10800017 	ldw	r2,0(r2)
 822d434:	d0a09c15 	stw	r2,-32144(gp)

   UC_FREE(con);  /* free memory for structure */
 822d438:	e13fff17 	ldw	r4,-4(fp)
 822d43c:	822e1fc0 	call	822e1fc <npfree>
   UNLOCK_NET_RESOURCE(NET_RESID);
 822d440:	0009883a 	mov	r4,zero
 822d444:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
}
 822d448:	e037883a 	mov	sp,fp
 822d44c:	dfc00117 	ldw	ra,4(sp)
 822d450:	df000017 	ldw	fp,0(sp)
 822d454:	dec00204 	addi	sp,sp,8
 822d458:	f800283a 	ret

0822d45c <asm_cksum>:
      .text

      .global	  asm_cksum

asm_cksum:
      mov   r2, zero		       /* accumulator = 0 */
 822d45c:	0005883a 	mov	r2,zero
      ble   r5, zero, done	       /* count <= 0 ? */
 822d460:	0140620e 	bge	zero,r5,822d5ec <done>

      mov   r6, zero		       /* carry accumulator */
 822d464:	000d883a 	mov	r6,zero

      andi  r3, r4, 2		       /* ptr 32-bit aligned? */
 822d468:	20c0008c 	andi	r3,r4,2
      beq   r3, zero, asm1
 822d46c:	18000326 	beq	r3,zero,822d47c <asm1>
      ldhu  r2, (r4)		       /* no - process first 16-bits */
 822d470:	2080000b 	ldhu	r2,0(r4)
      addi  r4, r4, 2
 822d474:	21000084 	addi	r4,r4,2
      subi  r5, r5, 1
 822d478:	297fffc4 	addi	r5,r5,-1

0822d47c <asm1>:
 822d47c:	02c208f4 	movhi	r11,2083
/*
 * adjust ptr by ((count/2) mod 16) * 4 bytes
 * jump to location: loop0 - (count/2 mod 16) * 4 instructions
 */
asm1:
      movia r11, loop0
 822d480:	5af56a04 	addi	r11,r11,-10840
      andi  r9, r5, 1		       /* r9 = last halfword flag */
 822d484:	2a40004c 	andi	r9,r5,1
      srai  r5, r5, 1		       /* count = number of words */
 822d488:	280bd07a 	srai	r5,r5,1
      andi  r10, r5, 0xf	       /* modulo 16 */
 822d48c:	2a8003cc 	andi	r10,r5,15
      slli  r10, r10, 2		       /*      * 4 bytes per word */
 822d490:	501490ba 	slli	r10,r10,2
      add   r4, r10, r4		       /* adjust ptr */
 822d494:	5109883a 	add	r4,r10,r4
      slli  r10, r10, 2		       /*      * 4 instructions per 4 bytes */
 822d498:	501490ba 	slli	r10,r10,2
      sub   r11, r11, r10
 822d49c:	5a97c83a 	sub	r11,r11,r10
      jmp   r11
 822d4a0:	5800683a 	jmp	r11

0822d4a4 <loop>:
      
loop:
      addi  r4, r4, 64		       /* increment data pointer */
 822d4a4:	21001004 	addi	r4,r4,64

      ldw   r7, -64(r4)
 822d4a8:	21fff017 	ldw	r7,-64(r4)
      add   r2, r7, r2
 822d4ac:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d4b0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d4b4:	418d883a 	add	r6,r8,r6

      ldw   r7, -60(r4)
 822d4b8:	21fff117 	ldw	r7,-60(r4)
      add   r2, r7, r2
 822d4bc:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d4c0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d4c4:	418d883a 	add	r6,r8,r6

      ldw   r7, -56(r4)
 822d4c8:	21fff217 	ldw	r7,-56(r4)
      add   r2, r7, r2
 822d4cc:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d4d0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d4d4:	418d883a 	add	r6,r8,r6

      ldw   r7, -52(r4)
 822d4d8:	21fff317 	ldw	r7,-52(r4)
      add   r2, r7, r2
 822d4dc:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d4e0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d4e4:	418d883a 	add	r6,r8,r6

      ldw   r7, -48(r4)
 822d4e8:	21fff417 	ldw	r7,-48(r4)
      add   r2, r7, r2
 822d4ec:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d4f0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d4f4:	418d883a 	add	r6,r8,r6

      ldw   r7, -44(r4)
 822d4f8:	21fff517 	ldw	r7,-44(r4)
      add   r2, r7, r2
 822d4fc:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d500:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d504:	418d883a 	add	r6,r8,r6

      ldw   r7, -40(r4)
 822d508:	21fff617 	ldw	r7,-40(r4)
      add   r2, r7, r2
 822d50c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d510:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d514:	418d883a 	add	r6,r8,r6

      ldw   r7, -36(r4)
 822d518:	21fff717 	ldw	r7,-36(r4)
      add   r2, r7, r2
 822d51c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d520:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d524:	418d883a 	add	r6,r8,r6

      ldw   r7, -32(r4)
 822d528:	21fff817 	ldw	r7,-32(r4)
      add   r2, r7, r2
 822d52c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d530:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d534:	418d883a 	add	r6,r8,r6

      ldw   r7, -28(r4)
 822d538:	21fff917 	ldw	r7,-28(r4)
      add   r2, r7, r2
 822d53c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d540:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d544:	418d883a 	add	r6,r8,r6

      ldw   r7, -24(r4)
 822d548:	21fffa17 	ldw	r7,-24(r4)
      add   r2, r7, r2
 822d54c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d550:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d554:	418d883a 	add	r6,r8,r6

      ldw   r7, -20(r4)
 822d558:	21fffb17 	ldw	r7,-20(r4)
      add   r2, r7, r2
 822d55c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d560:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d564:	418d883a 	add	r6,r8,r6

      ldw   r7, -16(r4)
 822d568:	21fffc17 	ldw	r7,-16(r4)
      add   r2, r7, r2
 822d56c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d570:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d574:	418d883a 	add	r6,r8,r6

      ldw   r7, -12(r4)
 822d578:	21fffd17 	ldw	r7,-12(r4)
      add   r2, r7, r2
 822d57c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d580:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d584:	418d883a 	add	r6,r8,r6

      ldw   r7, -8(r4)
 822d588:	21fffe17 	ldw	r7,-8(r4)
      add   r2, r7, r2
 822d58c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d590:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d594:	418d883a 	add	r6,r8,r6

      ldw   r7, -4(r4)
 822d598:	21ffff17 	ldw	r7,-4(r4)
      add   r2, r7, r2
 822d59c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d5a0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d5a4:	418d883a 	add	r6,r8,r6

0822d5a8 <loop0>:
loop0:
      subi  r5, r5, 16
 822d5a8:	297ffc04 	addi	r5,r5,-16
      bge   r5, zero, loop
 822d5ac:	283fbd0e 	bge	r5,zero,822d4a4 <loop>
/*
 * process last halfword (if any)
 */
      beq   r9, zero, fold
 822d5b0:	48000426 	beq	r9,zero,822d5c4 <fold>
      ldhu  r7, 0(r4)
 822d5b4:	21c0000b 	ldhu	r7,0(r4)
      add   r2, r7, r2
 822d5b8:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d5bc:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d5c0:	418d883a 	add	r6,r8,r6

0822d5c4 <fold>:
      
fold:
      srli  r7, r2, 16
 822d5c4:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 822d5c8:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add the upper and lower halfwords */
 822d5cc:	3885883a 	add	r2,r7,r2
      add   r2, r6, r2		    /* add the carries */
 822d5d0:	3085883a 	add	r2,r6,r2
/* the accumulator is 18 bits */
      srli  r7, r2, 16
 822d5d4:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 822d5d8:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add 2 carry bits to lower halfword */
 822d5dc:	3885883a 	add	r2,r7,r2
/* the accumulator is 17 bits */
      srli  r7, r2, 16
 822d5e0:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 822d5e4:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add carry to lower halfword */
 822d5e8:	3885883a 	add	r2,r7,r2

0822d5ec <done>:

done:
      ret			    		/* r2 = 16-bit checksum */
 822d5ec:	f800283a 	ret

0822d5f0 <dtrap>:
void irq_Unmask(void);

/* dtrap() - function to trap to debugger */
void
dtrap(void)
{
 822d5f0:	defffe04 	addi	sp,sp,-8
 822d5f4:	dfc00115 	stw	ra,4(sp)
 822d5f8:	df000015 	stw	fp,0(sp)
 822d5fc:	d839883a 	mov	fp,sp
   printf("dtrap - needs breakpoint\n");
 822d600:	01020974 	movhi	r4,2085
 822d604:	2102a404 	addi	r4,r4,2704
 822d608:	82036800 	call	8203680 <puts>
}
 822d60c:	0001883a 	nop
 822d610:	e037883a 	mov	sp,fp
 822d614:	dfc00117 	ldw	ra,4(sp)
 822d618:	df000017 	ldw	fp,0(sp)
 822d61c:	dec00204 	addi	sp,sp,8
 822d620:	f800283a 	ret

0822d624 <kbhit>:

int
kbhit()
{
 822d624:	defffd04 	addi	sp,sp,-12
 822d628:	dfc00215 	stw	ra,8(sp)
 822d62c:	df000115 	stw	fp,4(sp)
 822d630:	df000104 	addi	fp,sp,4
   static int kbd_init = 0;
   int   kb;
   
   if (!kbd_init)
 822d634:	d0a0a017 	ldw	r2,-32128(gp)
 822d638:	10000b1e 	bne	r2,zero,822d668 <kbhit+0x44>
      /* we really should read the flags, OR in O_NONBLOCK, and write
       * the flags back to STDIN, but the NIOS-II/HAL implementation
       * will only let us modify O_NONBLOCK and O_APPEND, so we'll
       * just write the new flag value.
       */
      if (fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK) != 0)
 822d63c:	01900004 	movi	r6,16384
 822d640:	01400104 	movi	r5,4
 822d644:	0009883a 	mov	r4,zero
 822d648:	823d91c0 	call	823d91c <fcntl>
 822d64c:	10000426 	beq	r2,zero,822d660 <kbhit+0x3c>
      {
         printf("F_SETFL failed.\n");
 822d650:	01020974 	movhi	r4,2085
 822d654:	2102ab04 	addi	r4,r4,2732
 822d658:	82036800 	call	8203680 <puts>
         dtrap();
 822d65c:	822d5f00 	call	822d5f0 <dtrap>
      }
      kbd_init = 1; 
 822d660:	00800044 	movi	r2,1
 822d664:	d0a0a015 	stw	r2,-32128(gp)
   }

   /* we have to do a read to see if there is a character available.
    * we save the character, if there was one, to be read later. */
   if (kb_last == EOF)
 822d668:	d0a03a17 	ldw	r2,-32536(gp)
 822d66c:	10bfffd8 	cmpnei	r2,r2,-1
 822d670:	10000b1e 	bne	r2,zero,822d6a0 <kbhit+0x7c>
   {
      kb = getchar();
 822d674:	d0a00217 	ldw	r2,-32760(gp)
 822d678:	10800117 	ldw	r2,4(r2)
 822d67c:	1009883a 	mov	r4,r2
 822d680:	8202ee40 	call	8202ee4 <getc>
 822d684:	e0bfff15 	stw	r2,-4(fp)
      if (kb < 0)       /* any error means no character present */
 822d688:	e0bfff17 	ldw	r2,-4(fp)
 822d68c:	1000020e 	bge	r2,zero,822d698 <kbhit+0x74>
         return (FALSE);
 822d690:	0005883a 	mov	r2,zero
 822d694:	00000306 	br	822d6a4 <kbhit+0x80>
         
      /* there was a character, and we read it. */
      kb_last = kb;
 822d698:	e0bfff17 	ldw	r2,-4(fp)
 822d69c:	d0a03a15 	stw	r2,-32536(gp)
   }

   return (TRUE);
 822d6a0:	00800044 	movi	r2,1
}
 822d6a4:	e037883a 	mov	sp,fp
 822d6a8:	dfc00117 	ldw	ra,4(sp)
 822d6ac:	df000017 	ldw	fp,0(sp)
 822d6b0:	dec00204 	addi	sp,sp,8
 822d6b4:	f800283a 	ret

0822d6b8 <getch>:

int 
getch()
{
 822d6b8:	defffd04 	addi	sp,sp,-12
 822d6bc:	dfc00215 	stw	ra,8(sp)
 822d6c0:	df000115 	stw	fp,4(sp)
 822d6c4:	df000104 	addi	fp,sp,4
int chr;

   if(kb_last != EOF)
 822d6c8:	d0a03a17 	ldw	r2,-32536(gp)
 822d6cc:	10bfffe0 	cmpeqi	r2,r2,-1
 822d6d0:	1000051e 	bne	r2,zero,822d6e8 <getch+0x30>
   {
      chr = kb_last;
 822d6d4:	d0a03a17 	ldw	r2,-32536(gp)
 822d6d8:	e0bfff15 	stw	r2,-4(fp)
      kb_last = EOF;
 822d6dc:	00bfffc4 	movi	r2,-1
 822d6e0:	d0a03a15 	stw	r2,-32536(gp)
 822d6e4:	00000506 	br	822d6fc <getch+0x44>
   }
   else
      chr = getchar();
 822d6e8:	d0a00217 	ldw	r2,-32760(gp)
 822d6ec:	10800117 	ldw	r2,4(r2)
 822d6f0:	1009883a 	mov	r4,r2
 822d6f4:	8202ee40 	call	8202ee4 <getc>
 822d6f8:	e0bfff15 	stw	r2,-4(fp)

   return chr;
 822d6fc:	e0bfff17 	ldw	r2,-4(fp)
}
 822d700:	e037883a 	mov	sp,fp
 822d704:	dfc00117 	ldw	ra,4(sp)
 822d708:	df000017 	ldw	fp,0(sp)
 822d70c:	dec00204 	addi	sp,sp,8
 822d710:	f800283a 	ret

0822d714 <clock_init>:
int OS_TPS;
int cticks_factor;
int cticks_initialized = 0;

void clock_init(void)
{
 822d714:	deffff04 	addi	sp,sp,-4
 822d718:	df000015 	stw	fp,0(sp)
 822d71c:	d839883a 	mov	fp,sp
   OS_TPS = OS_TICKS_PER_SEC;
 822d720:	00801904 	movi	r2,100
 822d724:	d0a0a215 	stw	r2,-32120(gp)
   cticks_factor = 0;
 822d728:	d020a115 	stw	zero,-32124(gp)
   cticks = 0;
 822d72c:	d020a815 	stw	zero,-32096(gp)
   cticks_initialized = 1;
 822d730:	00800044 	movi	r2,1
 822d734:	d0a09d15 	stw	r2,-32140(gp)
}
 822d738:	0001883a 	nop
 822d73c:	e037883a 	mov	sp,fp
 822d740:	df000017 	ldw	fp,0(sp)
 822d744:	dec00104 	addi	sp,sp,4
 822d748:	f800283a 	ret

0822d74c <clock_c>:

/* undo effects of clock_init (i.e. restore ISR vector) 
 * NO OP since using RTOS's timer.
 */
void clock_c(void)
{
 822d74c:	deffff04 	addi	sp,sp,-4
 822d750:	df000015 	stw	fp,0(sp)
 822d754:	d839883a 	mov	fp,sp
   /* null */ ;
}
 822d758:	0001883a 	nop
 822d75c:	e037883a 	mov	sp,fp
 822d760:	df000017 	ldw	fp,0(sp)
 822d764:	dec00104 	addi	sp,sp,4
 822d768:	f800283a 	ret

0822d76c <cticks_hook>:
 * Use the uCOS-II/Altera HAL BSP's timer and scale cticks as per TPS.
 */

void
cticks_hook(void)
{
 822d76c:	deffff04 	addi	sp,sp,-4
 822d770:	df000015 	stw	fp,0(sp)
 822d774:	d839883a 	mov	fp,sp
   if (cticks_initialized) 
 822d778:	d0a09d17 	ldw	r2,-32140(gp)
 822d77c:	10000d26 	beq	r2,zero,822d7b4 <cticks_hook+0x48>
   {
      cticks_factor += TPS;
 822d780:	d0a0a117 	ldw	r2,-32124(gp)
 822d784:	10801904 	addi	r2,r2,100
 822d788:	d0a0a115 	stw	r2,-32124(gp)
      if (cticks_factor >= OS_TPS)
 822d78c:	d0e0a117 	ldw	r3,-32124(gp)
 822d790:	d0a0a217 	ldw	r2,-32120(gp)
 822d794:	18800716 	blt	r3,r2,822d7b4 <cticks_hook+0x48>
      {
         cticks++;
 822d798:	d0a0a817 	ldw	r2,-32096(gp)
 822d79c:	10800044 	addi	r2,r2,1
 822d7a0:	d0a0a815 	stw	r2,-32096(gp)
         cticks_factor -= OS_TPS;
 822d7a4:	d0e0a117 	ldw	r3,-32124(gp)
 822d7a8:	d0a0a217 	ldw	r2,-32120(gp)
 822d7ac:	1885c83a 	sub	r2,r3,r2
 822d7b0:	d0a0a115 	stw	r2,-32124(gp)
#ifdef USE_LCD
         update_display();
#endif
      }
   }
}
 822d7b4:	0001883a 	nop
 822d7b8:	e037883a 	mov	sp,fp
 822d7bc:	df000017 	ldw	fp,0(sp)
 822d7c0:	dec00104 	addi	sp,sp,4
 822d7c4:	f800283a 	ret

0822d7c8 <irq_Mask>:
 * ENTER_CRIT_SECTION() and enable them in EXIT_CRIT_SECTION()
 * because calls to ENTER_CRIT_SECTION() can be nested."
 */
void
irq_Mask(void)
{
 822d7c8:	defffd04 	addi	sp,sp,-12
 822d7cc:	df000215 	stw	fp,8(sp)
 822d7d0:	df000204 	addi	fp,sp,8
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 822d7d4:	0005303a 	rdctl	r2,status
 822d7d8:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 822d7dc:	e0ffff17 	ldw	r3,-4(fp)
 822d7e0:	00bfff84 	movi	r2,-2
 822d7e4:	1884703a 	and	r2,r3,r2
 822d7e8:	1001703a 	wrctl	status,r2
  
  return context;
 822d7ec:	e0bfff17 	ldw	r2,-4(fp)
   alt_irq_context  local_cpu_statusreg;

   local_cpu_statusreg = alt_irq_disable_all();
 822d7f0:	e0bffe15 	stw	r2,-8(fp)
	
   if (++irq_level == 1)
 822d7f4:	d0a09e17 	ldw	r2,-32136(gp)
 822d7f8:	10800044 	addi	r2,r2,1
 822d7fc:	d0a09e15 	stw	r2,-32136(gp)
 822d800:	d0a09e17 	ldw	r2,-32136(gp)
 822d804:	10800058 	cmpnei	r2,r2,1
 822d808:	1000021e 	bne	r2,zero,822d814 <irq_Mask+0x4c>
   {
      cpu_statusreg = local_cpu_statusreg;
 822d80c:	e0bffe17 	ldw	r2,-8(fp)
 822d810:	d0a09f15 	stw	r2,-32132(gp)
   }
}
 822d814:	0001883a 	nop
 822d818:	e037883a 	mov	sp,fp
 822d81c:	df000017 	ldw	fp,0(sp)
 822d820:	dec00104 	addi	sp,sp,4
 822d824:	f800283a 	ret

0822d828 <irq_Unmask>:


/* Re-Enable Interrupts */
void
irq_Unmask(void)
{
 822d828:	defffe04 	addi	sp,sp,-8
 822d82c:	df000115 	stw	fp,4(sp)
 822d830:	df000104 	addi	fp,sp,4
   if (--irq_level == 0)
 822d834:	d0a09e17 	ldw	r2,-32136(gp)
 822d838:	10bfffc4 	addi	r2,r2,-1
 822d83c:	d0a09e15 	stw	r2,-32136(gp)
 822d840:	d0a09e17 	ldw	r2,-32136(gp)
 822d844:	1000041e 	bne	r2,zero,822d858 <irq_Unmask+0x30>
   {
      alt_irq_enable_all(cpu_statusreg);
 822d848:	d0a09f17 	ldw	r2,-32132(gp)
 822d84c:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 822d850:	e0bfff17 	ldw	r2,-4(fp)
 822d854:	1001703a 	wrctl	status,r2
   }
}
 822d858:	0001883a 	nop
 822d85c:	e037883a 	mov	sp,fp
 822d860:	df000017 	ldw	fp,0(sp)
 822d864:	dec00104 	addi	sp,sp,4
 822d868:	f800283a 	ret

0822d86c <LOCK_NET_RESOURCE>:
extern void irq_Mask(void);
extern void irq_Unmask(void);

void
LOCK_NET_RESOURCE(int resid)
{
 822d86c:	defffb04 	addi	sp,sp,-20
 822d870:	dfc00415 	stw	ra,16(sp)
 822d874:	df000315 	stw	fp,12(sp)
 822d878:	df000304 	addi	fp,sp,12
 822d87c:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 822d880:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 822d884:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 822d888:	e0bfff17 	ldw	r2,-4(fp)
 822d88c:	10002216 	blt	r2,zero,822d918 <LOCK_NET_RESOURCE+0xac>
 822d890:	e0bfff17 	ldw	r2,-4(fp)
 822d894:	10800408 	cmpgei	r2,r2,16
 822d898:	10001f1e 	bne	r2,zero,822d918 <LOCK_NET_RESOURCE+0xac>
   {
      do
      {
         OSSemPend(resid_semaphore[resid], 0, &error);
 822d89c:	008209b4 	movhi	r2,2086
 822d8a0:	10b96404 	addi	r2,r2,-6768
 822d8a4:	e0ffff17 	ldw	r3,-4(fp)
 822d8a8:	18c7883a 	add	r3,r3,r3
 822d8ac:	18c7883a 	add	r3,r3,r3
 822d8b0:	10c5883a 	add	r2,r2,r3
 822d8b4:	10800017 	ldw	r2,0(r2)
 822d8b8:	e0fffe04 	addi	r3,fp,-8
 822d8bc:	180d883a 	mov	r6,r3
 822d8c0:	000b883a 	mov	r5,zero
 822d8c4:	1009883a 	mov	r4,r2
 822d8c8:	821a1300 	call	821a130 <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 822d8cc:	e0bffe03 	ldbu	r2,-8(fp)
 822d8d0:	10803fcc 	andi	r2,r2,255
 822d8d4:	10800298 	cmpnei	r2,r2,10
 822d8d8:	10000a1e 	bne	r2,zero,822d904 <LOCK_NET_RESOURCE+0x98>
 822d8dc:	e0bffd17 	ldw	r2,-12(fp)
 822d8e0:	10800044 	addi	r2,r2,1
 822d8e4:	e0bffd15 	stw	r2,-12(fp)
 822d8e8:	e0bffd17 	ldw	r2,-12(fp)
 822d8ec:	1080fa50 	cmplti	r2,r2,1001
 822d8f0:	1000041e 	bne	r2,zero,822d904 <LOCK_NET_RESOURCE+0x98>
         {
            panic("lock NET");   /* fatal */
 822d8f4:	01020974 	movhi	r4,2085
 822d8f8:	2102af04 	addi	r4,r4,2748
 822d8fc:	8228ca40 	call	8228ca4 <panic>
 822d900:	00000606 	br	822d91c <LOCK_NET_RESOURCE+0xb0>
            return;
         }
      } while (error == 10);
 822d904:	e0bffe03 	ldbu	r2,-8(fp)
 822d908:	10803fcc 	andi	r2,r2,255
 822d90c:	108002a0 	cmpeqi	r2,r2,10
 822d910:	103fe21e 	bne	r2,zero,822d89c <LOCK_NET_RESOURCE+0x30>
LOCK_NET_RESOURCE(int resid)
{
   INT8U error = 0;
   int   errct = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
 822d914:	00000106 	br	822d91c <LOCK_NET_RESOURCE+0xb0>
            return;
         }
      } while (error == 10);
   }
   else
      dtrap();
 822d918:	822d5f00 	call	822d5f0 <dtrap>
}
 822d91c:	e037883a 	mov	sp,fp
 822d920:	dfc00117 	ldw	ra,4(sp)
 822d924:	df000017 	ldw	fp,0(sp)
 822d928:	dec00204 	addi	sp,sp,8
 822d92c:	f800283a 	ret

0822d930 <UNLOCK_NET_RESOURCE>:

void
UNLOCK_NET_RESOURCE(int resid)
{
 822d930:	defffc04 	addi	sp,sp,-16
 822d934:	dfc00315 	stw	ra,12(sp)
 822d938:	df000215 	stw	fp,8(sp)
 822d93c:	df000204 	addi	fp,sp,8
 822d940:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 822d944:	e03ffe05 	stb	zero,-8(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 822d948:	e0bfff17 	ldw	r2,-4(fp)
 822d94c:	10001316 	blt	r2,zero,822d99c <UNLOCK_NET_RESOURCE+0x6c>
 822d950:	e0bfff17 	ldw	r2,-4(fp)
 822d954:	10800408 	cmpgei	r2,r2,16
 822d958:	1000101e 	bne	r2,zero,822d99c <UNLOCK_NET_RESOURCE+0x6c>
   {
      error = OSSemPost(resid_semaphore[resid]);
 822d95c:	008209b4 	movhi	r2,2086
 822d960:	10b96404 	addi	r2,r2,-6768
 822d964:	e0ffff17 	ldw	r3,-4(fp)
 822d968:	18c7883a 	add	r3,r3,r3
 822d96c:	18c7883a 	add	r3,r3,r3
 822d970:	10c5883a 	add	r2,r2,r3
 822d974:	10800017 	ldw	r2,0(r2)
 822d978:	1009883a 	mov	r4,r2
 822d97c:	821a4a80 	call	821a4a8 <OSSemPost>
 822d980:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 822d984:	e0bffe03 	ldbu	r2,-8(fp)
 822d988:	10000526 	beq	r2,zero,822d9a0 <UNLOCK_NET_RESOURCE+0x70>
      {
         panic("unlock NET");
 822d98c:	01020974 	movhi	r4,2085
 822d990:	2102b204 	addi	r4,r4,2760
 822d994:	8228ca40 	call	8228ca4 <panic>
   INT8U error = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
   {
      error = OSSemPost(resid_semaphore[resid]);
      if (error != OS_NO_ERR)
 822d998:	00000106 	br	822d9a0 <UNLOCK_NET_RESOURCE+0x70>
      {
         panic("unlock NET");
      }
   }
   else
      dtrap();
 822d99c:	822d5f00 	call	822d5f0 <dtrap>
}
 822d9a0:	0001883a 	nop
 822d9a4:	e037883a 	mov	sp,fp
 822d9a8:	dfc00117 	ldw	ra,4(sp)
 822d9ac:	df000017 	ldw	fp,0(sp)
 822d9b0:	dec00204 	addi	sp,sp,8
 822d9b4:	f800283a 	ret

0822d9b8 <TK_NEWTASK>:
extern long     nettick_wakes;


int
TK_NEWTASK(struct inet_taskinfo * nettask)
{
 822d9b8:	deffee04 	addi	sp,sp,-72
 822d9bc:	dfc01115 	stw	ra,68(sp)
 822d9c0:	df001015 	stw	fp,64(sp)
 822d9c4:	df001004 	addi	fp,sp,64
 822d9c8:	e13fff15 	stw	r4,-4(fp)
   INT8U    error;
   OS_STK * stack;

   stack = (OS_STK*)npalloc(nettask->stacksize);
 822d9cc:	e0bfff17 	ldw	r2,-4(fp)
 822d9d0:	10800417 	ldw	r2,16(r2)
 822d9d4:	1009883a 	mov	r4,r2
 822d9d8:	822e1c80 	call	822e1c8 <npalloc>
 822d9dc:	e0bff515 	stw	r2,-44(fp)
   if(!stack)
 822d9e0:	e0bff517 	ldw	r2,-44(fp)
 822d9e4:	1000031e 	bne	r2,zero,822d9f4 <TK_NEWTASK+0x3c>
      panic("stack alloc");
 822d9e8:	01020974 	movhi	r4,2085
 822d9ec:	2102b504 	addi	r4,r4,2772
 822d9f0:	8228ca40 	call	8228ca4 <panic>

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822d9f4:	e0bfff17 	ldw	r2,-4(fp)
 822d9f8:	12000217 	ldw	r8,8(r2)
      nettask->entry,
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
 822d9fc:	e0bfff17 	ldw	r2,-4(fp)
 822da00:	10800417 	ldw	r2,16(r2)
 822da04:	1006d0ba 	srli	r3,r2,2
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822da08:	00900034 	movhi	r2,16384
 822da0c:	10bfffc4 	addi	r2,r2,-1
 822da10:	1885883a 	add	r2,r3,r2
 822da14:	1085883a 	add	r2,r2,r2
 822da18:	1085883a 	add	r2,r2,r2
 822da1c:	1007883a 	mov	r3,r2
 822da20:	e0bff517 	ldw	r2,-44(fp)
 822da24:	10cb883a 	add	r5,r2,r3
      nettask->entry,
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority,
 822da28:	e0bfff17 	ldw	r2,-4(fp)
 822da2c:	10800317 	ldw	r2,12(r2)
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822da30:	11803fcc 	andi	r6,r2,255
      nettask->entry,
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority,
      nettask->priority,
 822da34:	e0bfff17 	ldw	r2,-4(fp)
 822da38:	10800317 	ldw	r2,12(r2)
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822da3c:	10bfffcc 	andi	r2,r2,65535
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority,
      nettask->priority,
      stack, 
      (INT32U)nettask->stacksize / sizeof(OS_STK),
 822da40:	e0ffff17 	ldw	r3,-4(fp)
 822da44:	18c00417 	ldw	r3,16(r3)
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822da48:	1806d0ba 	srli	r3,r3,2
 822da4c:	010000c4 	movi	r4,3
 822da50:	d9000415 	stw	r4,16(sp)
 822da54:	d8000315 	stw	zero,12(sp)
 822da58:	d8c00215 	stw	r3,8(sp)
 822da5c:	e0fff517 	ldw	r3,-44(fp)
 822da60:	d8c00115 	stw	r3,4(sp)
 822da64:	d8800015 	stw	r2,0(sp)
 822da68:	300f883a 	mov	r7,r6
 822da6c:	280d883a 	mov	r6,r5
 822da70:	000b883a 	mov	r5,zero
 822da74:	4009883a 	mov	r4,r8
 822da78:	821ae640 	call	821ae64 <OSTaskCreateExt>
 822da7c:	e0bff605 	stb	r2,-40(fp)
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority);
#endif
   /* If we go here, then there's another task using our priority */
   /* Tell the user and exit with an error */
   if (error == OS_PRIO_EXIST)
 822da80:	e0bff603 	ldbu	r2,-40(fp)
 822da84:	10803fcc 	andi	r2,r2,255
 822da88:	10800a18 	cmpnei	r2,r2,40
 822da8c:	10001c1e 	bne	r2,zero,822db00 <TK_NEWTASK+0x148>
   { 
     char curr_task[OS_TASK_NAME_SIZE];
     INT8U err;
     OSTaskNameGet(nettask->priority, (INT8U*)curr_task, &err);
 822da90:	e0bfff17 	ldw	r2,-4(fp)
 822da94:	10800317 	ldw	r2,12(r2)
 822da98:	10803fcc 	andi	r2,r2,255
 822da9c:	e13ff644 	addi	r4,fp,-39
 822daa0:	e0fff684 	addi	r3,fp,-38
 822daa4:	200d883a 	mov	r6,r4
 822daa8:	180b883a 	mov	r5,r3
 822daac:	1009883a 	mov	r4,r2
 822dab0:	821b4dc0 	call	821b4dc <OSTaskNameGet>
     curr_task[OS_TASK_NAME_SIZE-1]=0;
 822dab4:	e03ffe45 	stb	zero,-7(fp)
    
     printf("Priority requested for task \"%s\" (Prio:%d) conflicts with "\
 822dab8:	e0bfff17 	ldw	r2,-4(fp)
 822dabc:	10c00117 	ldw	r3,4(r2)
 822dac0:	e0bfff17 	ldw	r2,-4(fp)
 822dac4:	11000317 	ldw	r4,12(r2)
 822dac8:	e0bfff17 	ldw	r2,-4(fp)
 822dacc:	10800317 	ldw	r2,12(r2)
 822dad0:	e17ff684 	addi	r5,fp,-38
 822dad4:	d8800015 	stw	r2,0(sp)
 822dad8:	280f883a 	mov	r7,r5
 822dadc:	200d883a 	mov	r6,r4
 822dae0:	180b883a 	mov	r5,r3
 822dae4:	01020974 	movhi	r4,2085
 822dae8:	2102b804 	addi	r4,r4,2784
 822daec:	82033fc0 	call	82033fc <printf>
            "already running task \"%s\" (Prio: %d)\n",
             nettask->name, nettask->priority, curr_task, nettask->priority);
             
     printf("You may wish to check your task priority settings in "\
 822daf0:	01020974 	movhi	r4,2085
 822daf4:	2102d004 	addi	r4,r4,2880
 822daf8:	82036800 	call	8203680 <puts>
 822dafc:	00002006 	br	822db80 <TK_NEWTASK+0x1c8>
            "\"<bsp path>\\iniche\\src\\h\\nios2\\ipport.h\" against "\
            "the priority settings in your application and recompile.\n\n");
   }
   else if (error == OS_PRIO_INVALID)
 822db00:	e0bff603 	ldbu	r2,-40(fp)
 822db04:	10803fcc 	andi	r2,r2,255
 822db08:	10800a98 	cmpnei	r2,r2,42
 822db0c:	10000e1e 	bne	r2,zero,822db48 <TK_NEWTASK+0x190>
   {
     printf("Priority requested for task \"%s\" (Prio:%d) exceeds "\
 822db10:	e0bfff17 	ldw	r2,-4(fp)
 822db14:	10c00117 	ldw	r3,4(r2)
 822db18:	e0bfff17 	ldw	r2,-4(fp)
 822db1c:	10800317 	ldw	r2,12(r2)
 822db20:	01c00504 	movi	r7,20
 822db24:	100d883a 	mov	r6,r2
 822db28:	180b883a 	mov	r5,r3
 822db2c:	01020974 	movhi	r4,2085
 822db30:	2102f804 	addi	r4,r4,3040
 822db34:	82033fc0 	call	82033fc <printf>
            "available priority levels in the system (OS_LOWEST_PRIO = %d)\n\n",
             nettask->name, nettask->priority, OS_LOWEST_PRIO);
             
     printf("Please modify the tasks priority level, or modify the "\
 822db38:	01020974 	movhi	r4,2085
 822db3c:	21031504 	addi	r4,r4,3156
 822db40:	82036800 	call	8203680 <puts>
 822db44:	00000e06 	br	822db80 <TK_NEWTASK+0x1c8>
            "\"Lowest assignable priority\" setting in the MicroC/OS-II "\
            "component\n");
   }
   else if (error != OS_NO_ERR)
 822db48:	e0bff603 	ldbu	r2,-40(fp)
 822db4c:	10803fcc 	andi	r2,r2,255
 822db50:	10000b26 	beq	r2,zero,822db80 <TK_NEWTASK+0x1c8>
   {                          /* All other errors are fatal */
      printf("Task create error /(MicroC/OS-II error code:%d/) on %s\n",
 822db54:	e0bff603 	ldbu	r2,-40(fp)
 822db58:	10c03fcc 	andi	r3,r2,255
 822db5c:	e0bfff17 	ldw	r2,-4(fp)
 822db60:	10800117 	ldw	r2,4(r2)
 822db64:	100d883a 	mov	r6,r2
 822db68:	180b883a 	mov	r5,r3
 822db6c:	01020974 	movhi	r4,2085
 822db70:	21033404 	addi	r4,r4,3280
 822db74:	82033fc0 	call	82033fc <printf>
             error, nettask->name);
      return (-1);
 822db78:	00bfffc4 	movi	r2,-1
 822db7c:	00001c06 	br	822dbf0 <TK_NEWTASK+0x238>
   }

   /* Include the task name, so that uc/osII (os aware) debuggers can
    * display it.
    */
   OSTaskNameSet(nettask->priority, (INT8U*)&nettask->name[0], &error);
 822db80:	e0bfff17 	ldw	r2,-4(fp)
 822db84:	10800317 	ldw	r2,12(r2)
 822db88:	10c03fcc 	andi	r3,r2,255
 822db8c:	e0bfff17 	ldw	r2,-4(fp)
 822db90:	10800117 	ldw	r2,4(r2)
 822db94:	e13ff604 	addi	r4,fp,-40
 822db98:	200d883a 	mov	r6,r4
 822db9c:	100b883a 	mov	r5,r2
 822dba0:	1809883a 	mov	r4,r3
 822dba4:	821b6740 	call	821b674 <OSTaskNameSet>

   nettask->stackbase = (char*)stack;
 822dba8:	e0bfff17 	ldw	r2,-4(fp)
 822dbac:	e0fff517 	ldw	r3,-44(fp)
 822dbb0:	10c00515 	stw	r3,20(r2)
   *nettask->tk_ptr = (INT8U)nettask->priority;  
 822dbb4:	e0bfff17 	ldw	r2,-4(fp)
 822dbb8:	10800017 	ldw	r2,0(r2)
 822dbbc:	e0ffff17 	ldw	r3,-4(fp)
 822dbc0:	18c00317 	ldw	r3,12(r3)
 822dbc4:	10c00005 	stb	r3,0(r2)

   printf("Created \"%s\" task (Prio: %d)\n",
 822dbc8:	e0bfff17 	ldw	r2,-4(fp)
 822dbcc:	10c00117 	ldw	r3,4(r2)
 822dbd0:	e0bfff17 	ldw	r2,-4(fp)
 822dbd4:	10800317 	ldw	r2,12(r2)
 822dbd8:	100d883a 	mov	r6,r2
 822dbdc:	180b883a 	mov	r5,r3
 822dbe0:	01020974 	movhi	r4,2085
 822dbe4:	21034204 	addi	r4,r4,3336
 822dbe8:	82033fc0 	call	82033fc <printf>
         (char *)nettask->name, nettask->priority);

   return (0);
 822dbec:	0005883a 	mov	r2,zero
}
 822dbf0:	e037883a 	mov	sp,fp
 822dbf4:	dfc00117 	ldw	ra,4(sp)
 822dbf8:	df000017 	ldw	fp,0(sp)
 822dbfc:	dec00204 	addi	sp,sp,8
 822dc00:	f800283a 	ret

0822dc04 <wait_app_sem>:
 * event (e.g., configuration inputs from user, initiation of a new session,
 * or a periodic timeout notification.
 */
void
wait_app_sem(unsigned long semid)
{
 822dc04:	defffb04 	addi	sp,sp,-20
 822dc08:	dfc00415 	stw	ra,16(sp)
 822dc0c:	df000315 	stw	fp,12(sp)
 822dc10:	df000304 	addi	fp,sp,12
 822dc14:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 822dc18:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 822dc1c:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= semid) && (semid <= MAX_SEMID))
 822dc20:	e0bfff17 	ldw	r2,-4(fp)
 822dc24:	108001a8 	cmpgeui	r2,r2,6
 822dc28:	10001f1e 	bne	r2,zero,822dca8 <wait_app_sem+0xa4>
   {
      do
      {
         OSSemPend(app_semaphore[semid], 0, &error);
 822dc2c:	008209b4 	movhi	r2,2086
 822dc30:	10b97404 	addi	r2,r2,-6704
 822dc34:	e0ffff17 	ldw	r3,-4(fp)
 822dc38:	18c7883a 	add	r3,r3,r3
 822dc3c:	18c7883a 	add	r3,r3,r3
 822dc40:	10c5883a 	add	r2,r2,r3
 822dc44:	10800017 	ldw	r2,0(r2)
 822dc48:	e0fffe04 	addi	r3,fp,-8
 822dc4c:	180d883a 	mov	r6,r3
 822dc50:	000b883a 	mov	r5,zero
 822dc54:	1009883a 	mov	r4,r2
 822dc58:	821a1300 	call	821a130 <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 822dc5c:	e0bffe03 	ldbu	r2,-8(fp)
 822dc60:	10803fcc 	andi	r2,r2,255
 822dc64:	10800298 	cmpnei	r2,r2,10
 822dc68:	10000a1e 	bne	r2,zero,822dc94 <wait_app_sem+0x90>
 822dc6c:	e0bffd17 	ldw	r2,-12(fp)
 822dc70:	10800044 	addi	r2,r2,1
 822dc74:	e0bffd15 	stw	r2,-12(fp)
 822dc78:	e0bffd17 	ldw	r2,-12(fp)
 822dc7c:	1080fa50 	cmplti	r2,r2,1001
 822dc80:	1000041e 	bne	r2,zero,822dc94 <wait_app_sem+0x90>
         {
            panic("lock NET");   /* fatal */
 822dc84:	01020974 	movhi	r4,2085
 822dc88:	2102af04 	addi	r4,r4,2748
 822dc8c:	8228ca40 	call	8228ca4 <panic>
 822dc90:	00000606 	br	822dcac <wait_app_sem+0xa8>
            return;
         }
      } while (error == 10);
 822dc94:	e0bffe03 	ldbu	r2,-8(fp)
 822dc98:	10803fcc 	andi	r2,r2,255
 822dc9c:	108002a0 	cmpeqi	r2,r2,10
 822dca0:	103fe21e 	bne	r2,zero,822dc2c <wait_app_sem+0x28>
 822dca4:	00000106 	br	822dcac <wait_app_sem+0xa8>
   }
   else
      dtrap();
 822dca8:	822d5f00 	call	822d5f0 <dtrap>
}
 822dcac:	e037883a 	mov	sp,fp
 822dcb0:	dfc00117 	ldw	ra,4(sp)
 822dcb4:	df000017 	ldw	fp,0(sp)
 822dcb8:	dec00204 	addi	sp,sp,8
 822dcbc:	f800283a 	ret

0822dcc0 <post_app_sem>:
 * notification. It signals the corresponding application event.
 */

void
post_app_sem(unsigned long semid)
{
 822dcc0:	defffc04 	addi	sp,sp,-16
 822dcc4:	dfc00315 	stw	ra,12(sp)
 822dcc8:	df000215 	stw	fp,8(sp)
 822dccc:	df000204 	addi	fp,sp,8
 822dcd0:	e13fff15 	stw	r4,-4(fp)
   INT8U error;

   if ((0 <= semid) && (semid <= MAX_SEMID))
 822dcd4:	e0bfff17 	ldw	r2,-4(fp)
 822dcd8:	108001a8 	cmpgeui	r2,r2,6
 822dcdc:	1000101e 	bne	r2,zero,822dd20 <post_app_sem+0x60>
   {
      error = OSSemPost(app_semaphore[semid]);
 822dce0:	008209b4 	movhi	r2,2086
 822dce4:	10b97404 	addi	r2,r2,-6704
 822dce8:	e0ffff17 	ldw	r3,-4(fp)
 822dcec:	18c7883a 	add	r3,r3,r3
 822dcf0:	18c7883a 	add	r3,r3,r3
 822dcf4:	10c5883a 	add	r2,r2,r3
 822dcf8:	10800017 	ldw	r2,0(r2)
 822dcfc:	1009883a 	mov	r4,r2
 822dd00:	821a4a80 	call	821a4a8 <OSSemPost>
 822dd04:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 822dd08:	e0bffe03 	ldbu	r2,-8(fp)
 822dd0c:	10000526 	beq	r2,zero,822dd24 <post_app_sem+0x64>
      {
         panic("unlock NET");
 822dd10:	01020974 	movhi	r4,2085
 822dd14:	2102b204 	addi	r4,r4,2760
 822dd18:	8228ca40 	call	8228ca4 <panic>
      }
   }
   else
      dtrap();
}
 822dd1c:	00000106 	br	822dd24 <post_app_sem+0x64>
      {
         panic("unlock NET");
      }
   }
   else
      dtrap();
 822dd20:	822d5f00 	call	822d5f0 <dtrap>
}
 822dd24:	0001883a 	nop
 822dd28:	e037883a 	mov	sp,fp
 822dd2c:	dfc00117 	ldw	ra,4(sp)
 822dd30:	df000017 	ldw	fp,0(sp)
 822dd34:	dec00204 	addi	sp,sp,8
 822dd38:	f800283a 	ret

0822dd3c <alt_iniche_init>:
#ifndef SUPERLOOP

extern OS_EVENT *resid_semaphore[MAX_RESID+1];

void alt_iniche_init(void)
{
 822dd3c:	defffd04 	addi	sp,sp,-12
 822dd40:	dfc00215 	stw	ra,8(sp)
 822dd44:	df000115 	stw	fp,4(sp)
 822dd48:	df000104 	addi	fp,sp,4
   int i;

   /* initialize the npalloc() heap semaphore */
   mheap_sem_ptr = OSSemCreate(1);
 822dd4c:	01000044 	movi	r4,1
 822dd50:	8219e180 	call	8219e18 <OSSemCreate>
 822dd54:	d0a0aa15 	stw	r2,-32088(gp)
   if (!mheap_sem_ptr)
 822dd58:	d0a0aa17 	ldw	r2,-32088(gp)
 822dd5c:	1000031e 	bne	r2,zero,822dd6c <alt_iniche_init+0x30>
      panic("mheap_sem_ptr create err"); 
 822dd60:	01020974 	movhi	r4,2085
 822dd64:	21034a04 	addi	r4,r4,3368
 822dd68:	8228ca40 	call	8228ca4 <panic>

   rcvdq_sem_ptr = OSSemCreate(0);
 822dd6c:	0009883a 	mov	r4,zero
 822dd70:	8219e180 	call	8219e18 <OSSemCreate>
 822dd74:	d0a0ab15 	stw	r2,-32084(gp)
   if (!rcvdq_sem_ptr)
 822dd78:	d0a0ab17 	ldw	r2,-32084(gp)
 822dd7c:	1000031e 	bne	r2,zero,822dd8c <alt_iniche_init+0x50>
      panic("rcvdq_sem_ptr create err"); 
 822dd80:	01020974 	movhi	r4,2085
 822dd84:	21035104 	addi	r4,r4,3396
 822dd88:	8228ca40 	call	8228ca4 <panic>

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 822dd8c:	e03fff15 	stw	zero,-4(fp)
 822dd90:	00001806 	br	822ddf4 <alt_iniche_init+0xb8>
   {
      resid_semaphore[i] = OSSemCreate(1);
 822dd94:	01000044 	movi	r4,1
 822dd98:	8219e180 	call	8219e18 <OSSemCreate>
 822dd9c:	1009883a 	mov	r4,r2
 822dda0:	008209b4 	movhi	r2,2086
 822dda4:	10b96404 	addi	r2,r2,-6768
 822dda8:	e0ffff17 	ldw	r3,-4(fp)
 822ddac:	18c7883a 	add	r3,r3,r3
 822ddb0:	18c7883a 	add	r3,r3,r3
 822ddb4:	10c5883a 	add	r2,r2,r3
 822ddb8:	11000015 	stw	r4,0(r2)
      if (!resid_semaphore[i])
 822ddbc:	008209b4 	movhi	r2,2086
 822ddc0:	10b96404 	addi	r2,r2,-6768
 822ddc4:	e0ffff17 	ldw	r3,-4(fp)
 822ddc8:	18c7883a 	add	r3,r3,r3
 822ddcc:	18c7883a 	add	r3,r3,r3
 822ddd0:	10c5883a 	add	r2,r2,r3
 822ddd4:	10800017 	ldw	r2,0(r2)
 822ddd8:	1000031e 	bne	r2,zero,822dde8 <alt_iniche_init+0xac>
         panic("resid_semaphore create err");  
 822dddc:	01020974 	movhi	r4,2085
 822dde0:	21035804 	addi	r4,r4,3424
 822dde4:	8228ca40 	call	8228ca4 <panic>
   rcvdq_sem_ptr = OSSemCreate(0);
   if (!rcvdq_sem_ptr)
      panic("rcvdq_sem_ptr create err"); 

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 822dde8:	e0bfff17 	ldw	r2,-4(fp)
 822ddec:	10800044 	addi	r2,r2,1
 822ddf0:	e0bfff15 	stw	r2,-4(fp)
 822ddf4:	e0bfff17 	ldw	r2,-4(fp)
 822ddf8:	10800410 	cmplti	r2,r2,16
 822ddfc:	103fe51e 	bne	r2,zero,822dd94 <alt_iniche_init+0x58>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 822de00:	e03fff15 	stw	zero,-4(fp)
 822de04:	00001806 	br	822de68 <alt_iniche_init+0x12c>
   {
      app_semaphore[i] = OSSemCreate(1);
 822de08:	01000044 	movi	r4,1
 822de0c:	8219e180 	call	8219e18 <OSSemCreate>
 822de10:	1009883a 	mov	r4,r2
 822de14:	008209b4 	movhi	r2,2086
 822de18:	10b97404 	addi	r2,r2,-6704
 822de1c:	e0ffff17 	ldw	r3,-4(fp)
 822de20:	18c7883a 	add	r3,r3,r3
 822de24:	18c7883a 	add	r3,r3,r3
 822de28:	10c5883a 	add	r2,r2,r3
 822de2c:	11000015 	stw	r4,0(r2)
      if (!app_semaphore[i])
 822de30:	008209b4 	movhi	r2,2086
 822de34:	10b97404 	addi	r2,r2,-6704
 822de38:	e0ffff17 	ldw	r3,-4(fp)
 822de3c:	18c7883a 	add	r3,r3,r3
 822de40:	18c7883a 	add	r3,r3,r3
 822de44:	10c5883a 	add	r2,r2,r3
 822de48:	10800017 	ldw	r2,0(r2)
 822de4c:	1000031e 	bne	r2,zero,822de5c <alt_iniche_init+0x120>
         panic("app_semaphore create err");  
 822de50:	01020974 	movhi	r4,2085
 822de54:	21035f04 	addi	r4,r4,3452
 822de58:	8228ca40 	call	8228ca4 <panic>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 822de5c:	e0bfff17 	ldw	r2,-4(fp)
 822de60:	10800044 	addi	r2,r2,1
 822de64:	e0bfff15 	stw	r2,-4(fp)
 822de68:	e0bfff17 	ldw	r2,-4(fp)
 822de6c:	10800190 	cmplti	r2,r2,6
 822de70:	103fe51e 	bne	r2,zero,822de08 <alt_iniche_init+0xcc>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 822de74:	e03fff15 	stw	zero,-4(fp)
 822de78:	00002506 	br	822df10 <alt_iniche_init+0x1d4>
   {
      global_TCPwakeup_set[i].ctick = 0;
 822de7c:	008209b4 	movhi	r2,2086
 822de80:	10b92804 	addi	r2,r2,-7008
 822de84:	e0ffff17 	ldw	r3,-4(fp)
 822de88:	18c00324 	muli	r3,r3,12
 822de8c:	10c5883a 	add	r2,r2,r3
 822de90:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].soc_event = NULL;
 822de94:	008209b4 	movhi	r2,2086
 822de98:	10b92804 	addi	r2,r2,-7008
 822de9c:	e0ffff17 	ldw	r3,-4(fp)
 822dea0:	18c00324 	muli	r3,r3,12
 822dea4:	10c5883a 	add	r2,r2,r3
 822dea8:	10800104 	addi	r2,r2,4
 822deac:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
 822deb0:	0009883a 	mov	r4,zero
 822deb4:	8219e180 	call	8219e18 <OSSemCreate>
 822deb8:	1009883a 	mov	r4,r2
 822debc:	008209b4 	movhi	r2,2086
 822dec0:	10b92804 	addi	r2,r2,-7008
 822dec4:	e0ffff17 	ldw	r3,-4(fp)
 822dec8:	18c00324 	muli	r3,r3,12
 822decc:	10c5883a 	add	r2,r2,r3
 822ded0:	10800204 	addi	r2,r2,8
 822ded4:	11000015 	stw	r4,0(r2)
      if (!global_TCPwakeup_set[i].semaphore)
 822ded8:	008209b4 	movhi	r2,2086
 822dedc:	10b92804 	addi	r2,r2,-7008
 822dee0:	e0ffff17 	ldw	r3,-4(fp)
 822dee4:	18c00324 	muli	r3,r3,12
 822dee8:	10c5883a 	add	r2,r2,r3
 822deec:	10800204 	addi	r2,r2,8
 822def0:	10800017 	ldw	r2,0(r2)
 822def4:	1000031e 	bne	r2,zero,822df04 <alt_iniche_init+0x1c8>
         panic("globwake_semaphore create err");  
 822def8:	01020974 	movhi	r4,2085
 822defc:	21036604 	addi	r4,r4,3480
 822df00:	8228ca40 	call	8228ca4 <panic>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 822df04:	e0bfff17 	ldw	r2,-4(fp)
 822df08:	10800044 	addi	r2,r2,1
 822df0c:	e0bfff15 	stw	r2,-4(fp)
 822df10:	e0bfff17 	ldw	r2,-4(fp)
 822df14:	10800510 	cmplti	r2,r2,20
 822df18:	103fd81e 	bne	r2,zero,822de7c <alt_iniche_init+0x140>
      global_TCPwakeup_set[i].soc_event = NULL;
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
      if (!global_TCPwakeup_set[i].semaphore)
         panic("globwake_semaphore create err");  
   }
   global_TCPwakeup_setIndx = 0;
 822df1c:	d020a715 	stw	zero,-32100(gp)
#endif  /* TCPWAKE_RTOS */
}
 822df20:	0001883a 	nop
 822df24:	e037883a 	mov	sp,fp
 822df28:	dfc00117 	ldw	ra,4(sp)
 822df2c:	df000017 	ldw	fp,0(sp)
 822df30:	dec00204 	addi	sp,sp,8
 822df34:	f800283a 	ret

0822df38 <pre_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
pre_task_setup()
{
 822df38:	deffff04 	addi	sp,sp,-4
 822df3c:	df000015 	stw	fp,0(sp)
 822df40:	d839883a 	mov	fp,sp
   write_leds(0);
   write_7seg_raw(0x0000);
#endif

   /* preset buffer counts; may be overridden from command line */
   bigbufs = MAXBIGPKTS;
 822df44:	00800784 	movi	r2,30
 822df48:	d0a03815 	stw	r2,-32544(gp)
   lilbufs = MAXLILPKTS;
 822df4c:	00800784 	movi	r2,30
 822df50:	d0a03615 	stw	r2,-32552(gp)
   bigbufsiz = BIGBUFSIZE;
 822df54:	00818004 	movi	r2,1536
 822df58:	d0a03915 	stw	r2,-32540(gp)
   lilbufsiz = LILBUFSIZE;
 822df5c:	00802004 	movi	r2,128
 822df60:	d0a03715 	stw	r2,-32548(gp)

   /* Install callback to prep_armintcp from prep_ifaces() */
   port_prep = prep_armintcp;
 822df64:	008208f4 	movhi	r2,2083
 822df68:	10b7e904 	addi	r2,r2,-8284
 822df6c:	d0a0ca15 	stw	r2,-31960(gp)
#endif   /* NOTDEF */

#endif   /* USE_PPP */


   return NULL;
 822df70:	0005883a 	mov	r2,zero
}
 822df74:	e037883a 	mov	sp,fp
 822df78:	df000017 	ldw	fp,0(sp)
 822df7c:	dec00104 	addi	sp,sp,4
 822df80:	f800283a 	ret

0822df84 <post_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
post_task_setup()
{
 822df84:	deffff04 	addi	sp,sp,-4
 822df88:	df000015 	stw	fp,0(sp)
 822df8c:	d839883a 	mov	fp,sp
   return NULL;
 822df90:	0005883a 	mov	r2,zero
}
 822df94:	e037883a 	mov	sp,fp
 822df98:	df000017 	ldw	fp,0(sp)
 822df9c:	dec00104 	addi	sp,sp,4
 822dfa0:	f800283a 	ret

0822dfa4 <prep_armintcp>:

#endif  /* INCLUDE_NVPARMS */

int 
prep_armintcp(int ifaces_found)
{
 822dfa4:	defffd04 	addi	sp,sp,-12
 822dfa8:	dfc00215 	stw	ra,8(sp)
 822dfac:	df000115 	stw	fp,4(sp)
 822dfb0:	df000104 	addi	fp,sp,4
 822dfb4:	e13fff15 	stw	r4,-4(fp)
 * Call iniche_devices_init, in alt_iniche_dev.c, 
 * to step through all devices and all their respective
 * low-level initialization routines.
 */
#ifdef ALT_INICHE
   ifaces_found = iniche_devices_init(ifaces_found);
 822dfb8:	e13fff17 	ldw	r4,-4(fp)
 822dfbc:	82258dc0 	call	82258dc <iniche_devices_init>
 822dfc0:	e0bfff15 	stw	r2,-4(fp)

#ifdef USE_SLIP
   ifaces_found = prep_slip(ifaces_found);
#endif

   return ifaces_found;
 822dfc4:	e0bfff17 	ldw	r2,-4(fp)
}
 822dfc8:	e037883a 	mov	sp,fp
 822dfcc:	dfc00117 	ldw	ra,4(sp)
 822dfd0:	df000017 	ldw	fp,0(sp)
 822dfd4:	dec00204 	addi	sp,sp,8
 822dfd8:	f800283a 	ret

0822dfdc <npalloc_base>:
#endif


char *
npalloc_base(unsigned size, int cacheable)
{
 822dfdc:	defff804 	addi	sp,sp,-32
 822dfe0:	dfc00715 	stw	ra,28(sp)
 822dfe4:	df000615 	stw	fp,24(sp)
 822dfe8:	df000604 	addi	fp,sp,24
 822dfec:	e13ffe15 	stw	r4,-8(fp)
 822dff0:	e17fff15 	stw	r5,-4(fp)
char * ptr;
void *(*alloc_rtn)(size_t size) = cacheable ? malloc : alt_uncached_malloc;
 822dff4:	e0bfff17 	ldw	r2,-4(fp)
 822dff8:	10000326 	beq	r2,zero,822e008 <npalloc_base+0x2c>
 822dffc:	00820974 	movhi	r2,2085
 822e000:	10adbb04 	addi	r2,r2,-18708
 822e004:	00000206 	br	822e010 <npalloc_base+0x34>
 822e008:	00820934 	movhi	r2,2084
 822e00c:	10b28a04 	addi	r2,r2,-13784
 822e010:	e0bffb15 	stw	r2,-20(fp)
#ifdef UCOS_II
   INT8U err;
#endif

#ifdef UCOS_II
   OSSemPend(mheap_sem_ptr, 0, &err);
 822e014:	d0a0aa17 	ldw	r2,-32088(gp)
 822e018:	e0fffd04 	addi	r3,fp,-12
 822e01c:	180d883a 	mov	r6,r3
 822e020:	000b883a 	mov	r5,zero
 822e024:	1009883a 	mov	r4,r2
 822e028:	821a1300 	call	821a130 <OSSemPend>
   if(err)
 822e02c:	e0bffd03 	ldbu	r2,-12(fp)
 822e030:	10803fcc 	andi	r2,r2,255
 822e034:	10001626 	beq	r2,zero,822e090 <npalloc_base+0xb4>
   {
      int errct = 0;
 822e038:	e03ffa15 	stw	zero,-24(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 822e03c:	00001006 	br	822e080 <npalloc_base+0xa4>
      {
         if(errct++ > 1000)
 822e040:	e0bffa17 	ldw	r2,-24(fp)
 822e044:	10c00044 	addi	r3,r2,1
 822e048:	e0fffa15 	stw	r3,-24(fp)
 822e04c:	1080fa50 	cmplti	r2,r2,1001
 822e050:	1000051e 	bne	r2,zero,822e068 <npalloc_base+0x8c>
         {
            panic("npalloc");    /* fatal? */
 822e054:	01020974 	movhi	r4,2085
 822e058:	21036e04 	addi	r4,r4,3512
 822e05c:	8228ca40 	call	8228ca4 <panic>
            return NULL;
 822e060:	0005883a 	mov	r2,zero
 822e064:	00001b06 	br	822e0d4 <npalloc_base+0xf8>
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 822e068:	d0a0aa17 	ldw	r2,-32088(gp)
 822e06c:	e0fffd04 	addi	r3,fp,-12
 822e070:	180d883a 	mov	r6,r3
 822e074:	000b883a 	mov	r5,zero
 822e078:	1009883a 	mov	r4,r2
 822e07c:	821a1300 	call	821a130 <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 822e080:	e0bffd03 	ldbu	r2,-12(fp)
 822e084:	10803fcc 	andi	r2,r2,255
 822e088:	108002a0 	cmpeqi	r2,r2,10
 822e08c:	103fec1e 	bne	r2,zero,822e040 <npalloc_base+0x64>
#endif

#ifdef   MEM_WRAPPERS
   ptr = wrap_alloc(size, alloc_rtn);
#else
   ptr = (*alloc_rtn)(size);
 822e090:	e0bffb17 	ldw	r2,-20(fp)
 822e094:	e13ffe17 	ldw	r4,-8(fp)
 822e098:	103ee83a 	callr	r2
 822e09c:	e0bffc15 	stw	r2,-16(fp)
#endif

#ifdef UCOS_II 
   err = OSSemPost(mheap_sem_ptr);
 822e0a0:	d0a0aa17 	ldw	r2,-32088(gp)
 822e0a4:	1009883a 	mov	r4,r2
 822e0a8:	821a4a80 	call	821a4a8 <OSSemPost>
 822e0ac:	e0bffd05 	stb	r2,-12(fp)
#endif
   
   if(!ptr)
 822e0b0:	e0bffc17 	ldw	r2,-16(fp)
 822e0b4:	1000021e 	bne	r2,zero,822e0c0 <npalloc_base+0xe4>
      return NULL;
 822e0b8:	0005883a 	mov	r2,zero
 822e0bc:	00000506 	br	822e0d4 <npalloc_base+0xf8>

   MEMSET(ptr, 0, size);
 822e0c0:	e1bffe17 	ldw	r6,-8(fp)
 822e0c4:	000b883a 	mov	r5,zero
 822e0c8:	e13ffc17 	ldw	r4,-16(fp)
 822e0cc:	82032100 	call	8203210 <memset>
   return ptr;      
 822e0d0:	e0bffc17 	ldw	r2,-16(fp)
}
 822e0d4:	e037883a 	mov	sp,fp
 822e0d8:	dfc00117 	ldw	ra,4(sp)
 822e0dc:	df000017 	ldw	fp,0(sp)
 822e0e0:	dec00204 	addi	sp,sp,8
 822e0e4:	f800283a 	ret

0822e0e8 <npfree_base>:

void
npfree_base(void *ptr, int cacheable)
{
 822e0e8:	defff904 	addi	sp,sp,-28
 822e0ec:	dfc00615 	stw	ra,24(sp)
 822e0f0:	df000515 	stw	fp,20(sp)
 822e0f4:	df000504 	addi	fp,sp,20
 822e0f8:	e13ffe15 	stw	r4,-8(fp)
 822e0fc:	e17fff15 	stw	r5,-4(fp)
   void (*free_rtn)(void *ptr) = cacheable ? free : alt_uncached_free;
 822e100:	e0bfff17 	ldw	r2,-4(fp)
 822e104:	10000326 	beq	r2,zero,822e114 <npfree_base+0x2c>
 822e108:	00820974 	movhi	r2,2085
 822e10c:	10adc004 	addi	r2,r2,-18688
 822e110:	00000206 	br	822e11c <npfree_base+0x34>
 822e114:	00820934 	movhi	r2,2084
 822e118:	10b27904 	addi	r2,r2,-13852
 822e11c:	e0bffc15 	stw	r2,-16(fp)
#ifdef UCOS_II
   INT8U err;

   OSSemPend(mheap_sem_ptr, 0, &err);
 822e120:	d0a0aa17 	ldw	r2,-32088(gp)
 822e124:	e0fffd04 	addi	r3,fp,-12
 822e128:	180d883a 	mov	r6,r3
 822e12c:	000b883a 	mov	r5,zero
 822e130:	1009883a 	mov	r4,r2
 822e134:	821a1300 	call	821a130 <OSSemPend>
   if (err)
 822e138:	e0bffd03 	ldbu	r2,-12(fp)
 822e13c:	10803fcc 	andi	r2,r2,255
 822e140:	10001526 	beq	r2,zero,822e198 <npfree_base+0xb0>
   {
      int errct = 0;
 822e144:	e03ffb15 	stw	zero,-20(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 822e148:	00000f06 	br	822e188 <npfree_base+0xa0>
      {
         if (errct++ > 1000)
 822e14c:	e0bffb17 	ldw	r2,-20(fp)
 822e150:	10c00044 	addi	r3,r2,1
 822e154:	e0fffb15 	stw	r3,-20(fp)
 822e158:	1080fa50 	cmplti	r2,r2,1001
 822e15c:	1000041e 	bne	r2,zero,822e170 <npfree_base+0x88>
         {
            panic("npfree");    /* fatal? */
 822e160:	01020974 	movhi	r4,2085
 822e164:	21037004 	addi	r4,r4,3520
 822e168:	8228ca40 	call	8228ca4 <panic>
            return;
 822e16c:	00001106 	br	822e1b4 <npfree_base+0xcc>
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 822e170:	d0a0aa17 	ldw	r2,-32088(gp)
 822e174:	e0fffd04 	addi	r3,fp,-12
 822e178:	180d883a 	mov	r6,r3
 822e17c:	000b883a 	mov	r5,zero
 822e180:	1009883a 	mov	r4,r2
 822e184:	821a1300 	call	821a130 <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 822e188:	e0bffd03 	ldbu	r2,-12(fp)
 822e18c:	10803fcc 	andi	r2,r2,255
 822e190:	108002a0 	cmpeqi	r2,r2,10
 822e194:	103fed1e 	bne	r2,zero,822e14c <npfree_base+0x64>
   }
   
#ifdef   MEM_WRAPPERS
   wrap_free((char*)ptr, free_rtn);
#else
   (*free_rtn)(ptr);
 822e198:	e0bffc17 	ldw	r2,-16(fp)
 822e19c:	e13ffe17 	ldw	r4,-8(fp)
 822e1a0:	103ee83a 	callr	r2
#endif

   err = OSSemPost(mheap_sem_ptr);
 822e1a4:	d0a0aa17 	ldw	r2,-32088(gp)
 822e1a8:	1009883a 	mov	r4,r2
 822e1ac:	821a4a80 	call	821a4a8 <OSSemPost>
 822e1b0:	e0bffd05 	stb	r2,-12(fp)
#else
   (*free_rtn)(ptr);
#endif
#endif

}
 822e1b4:	e037883a 	mov	sp,fp
 822e1b8:	dfc00117 	ldw	ra,4(sp)
 822e1bc:	df000017 	ldw	fp,0(sp)
 822e1c0:	dec00204 	addi	sp,sp,8
 822e1c4:	f800283a 	ret

0822e1c8 <npalloc>:

char *
npalloc(unsigned size)
{
 822e1c8:	defffd04 	addi	sp,sp,-12
 822e1cc:	dfc00215 	stw	ra,8(sp)
 822e1d0:	df000115 	stw	fp,4(sp)
 822e1d4:	df000104 	addi	fp,sp,4
 822e1d8:	e13fff15 	stw	r4,-4(fp)
   return npalloc_base(size, 1);
 822e1dc:	01400044 	movi	r5,1
 822e1e0:	e13fff17 	ldw	r4,-4(fp)
 822e1e4:	822dfdc0 	call	822dfdc <npalloc_base>
}
 822e1e8:	e037883a 	mov	sp,fp
 822e1ec:	dfc00117 	ldw	ra,4(sp)
 822e1f0:	df000017 	ldw	fp,0(sp)
 822e1f4:	dec00204 	addi	sp,sp,8
 822e1f8:	f800283a 	ret

0822e1fc <npfree>:

void
npfree(void *ptr)
{
 822e1fc:	defffd04 	addi	sp,sp,-12
 822e200:	dfc00215 	stw	ra,8(sp)
 822e204:	df000115 	stw	fp,4(sp)
 822e208:	df000104 	addi	fp,sp,4
 822e20c:	e13fff15 	stw	r4,-4(fp)
   if(ptr) {
 822e210:	e0bfff17 	ldw	r2,-4(fp)
 822e214:	10000326 	beq	r2,zero,822e224 <npfree+0x28>
      npfree_base(ptr, 1);
 822e218:	01400044 	movi	r5,1
 822e21c:	e13fff17 	ldw	r4,-4(fp)
 822e220:	822e0e80 	call	822e0e8 <npfree_base>
   }
}
 822e224:	0001883a 	nop
 822e228:	e037883a 	mov	sp,fp
 822e22c:	dfc00117 	ldw	ra,4(sp)
 822e230:	df000017 	ldw	fp,0(sp)
 822e234:	dec00204 	addi	sp,sp,8
 822e238:	f800283a 	ret

0822e23c <ncpalloc>:
 * contains macro definitions that assign specific memory
 * allocation calls to these routines.
 */
#ifdef ALT_INICHE
char * ncpalloc(unsigned size)
{
 822e23c:	defffd04 	addi	sp,sp,-12
 822e240:	dfc00215 	stw	ra,8(sp)
 822e244:	df000115 	stw	fp,4(sp)
 822e248:	df000104 	addi	fp,sp,4
 822e24c:	e13fff15 	stw	r4,-4(fp)
   return npalloc_base(size, 0);
 822e250:	000b883a 	mov	r5,zero
 822e254:	e13fff17 	ldw	r4,-4(fp)
 822e258:	822dfdc0 	call	822dfdc <npalloc_base>
}
 822e25c:	e037883a 	mov	sp,fp
 822e260:	dfc00117 	ldw	ra,4(sp)
 822e264:	df000017 	ldw	fp,0(sp)
 822e268:	dec00204 	addi	sp,sp,8
 822e26c:	f800283a 	ret

0822e270 <ncpfree>:

void ncpfree(void *ptr)
{
 822e270:	defffd04 	addi	sp,sp,-12
 822e274:	dfc00215 	stw	ra,8(sp)
 822e278:	df000115 	stw	fp,4(sp)
 822e27c:	df000104 	addi	fp,sp,4
 822e280:	e13fff15 	stw	r4,-4(fp)
   if(ptr) {
 822e284:	e0bfff17 	ldw	r2,-4(fp)
 822e288:	10000326 	beq	r2,zero,822e298 <ncpfree+0x28>
      npfree_base(ptr, 0);
 822e28c:	000b883a 	mov	r5,zero
 822e290:	e13fff17 	ldw	r4,-4(fp)
 822e294:	822e0e80 	call	822e0e8 <npfree_base>
   }
}
 822e298:	0001883a 	nop
 822e29c:	e037883a 	mov	sp,fp
 822e2a0:	dfc00117 	ldw	ra,4(sp)
 822e2a4:	df000017 	ldw	fp,0(sp)
 822e2a8:	dec00204 	addi	sp,sp,8
 822e2ac:	f800283a 	ret

0822e2b0 <pffindtype>:
 * RETURNS: 
 */

struct protosw *  
pffindtype(int domain, int type)
{
 822e2b0:	defffc04 	addi	sp,sp,-16
 822e2b4:	dfc00315 	stw	ra,12(sp)
 822e2b8:	df000215 	stw	fp,8(sp)
 822e2bc:	df000204 	addi	fp,sp,8
 822e2c0:	e13ffe15 	stw	r4,-8(fp)
 822e2c4:	e17fff15 	stw	r5,-4(fp)

   /* check that the passed domain is vaid for the build */
   if (domain != AF_INET)
 822e2c8:	e0bffe17 	ldw	r2,-8(fp)
 822e2cc:	108000a0 	cmpeqi	r2,r2,2
 822e2d0:	1000031e 	bne	r2,zero,822e2e0 <pffindtype+0x30>
   {
#ifdef IP_V6
      if(domain != AF_INET6)
#endif
      {
         dtrap();    /* programming error */
 822e2d4:	822d5f00 	call	822d5f0 <dtrap>
         return NULL;
 822e2d8:	0005883a 	mov	r2,zero
 822e2dc:	00001306 	br	822e32c <pffindtype+0x7c>
      }
   }

   if (type == SOCK_STREAM)
 822e2e0:	e0bfff17 	ldw	r2,-4(fp)
 822e2e4:	10800058 	cmpnei	r2,r2,1
 822e2e8:	1000031e 	bne	r2,zero,822e2f8 <pffindtype+0x48>
      return &tcp_protosw;
 822e2ec:	00820974 	movhi	r2,2085
 822e2f0:	108ed304 	addi	r2,r2,15180
 822e2f4:	00000d06 	br	822e32c <pffindtype+0x7c>
#ifdef UDP_SOCKETS
   else if(type == SOCK_DGRAM)
 822e2f8:	e0bfff17 	ldw	r2,-4(fp)
 822e2fc:	10800098 	cmpnei	r2,r2,2
 822e300:	1000031e 	bne	r2,zero,822e310 <pffindtype+0x60>
      return &udp_protosw;
 822e304:	00820974 	movhi	r2,2085
 822e308:	108ed904 	addi	r2,r2,15204
 822e30c:	00000706 	br	822e32c <pffindtype+0x7c>
#endif   /* UDP_SOCKETS */
#ifdef IP_RAW
   else if(type == SOCK_RAW)
 822e310:	e0bfff17 	ldw	r2,-4(fp)
 822e314:	108000d8 	cmpnei	r2,r2,3
 822e318:	1000031e 	bne	r2,zero,822e328 <pffindtype+0x78>
      return &rawip_protosw;
 822e31c:	00820974 	movhi	r2,2085
 822e320:	108edf04 	addi	r2,r2,15228
 822e324:	00000106 	br	822e32c <pffindtype+0x7c>
#endif  /* IP_RAW */
   else
      return NULL;
 822e328:	0005883a 	mov	r2,zero
}
 822e32c:	e037883a 	mov	sp,fp
 822e330:	dfc00117 	ldw	ra,4(sp)
 822e334:	df000017 	ldw	fp,0(sp)
 822e338:	dec00204 	addi	sp,sp,8
 822e33c:	f800283a 	ret

0822e340 <pffindproto>:
 * RETURNS: 
 */

struct protosw *  
pffindproto(int domain, int protocol, int type)
{
 822e340:	defffb04 	addi	sp,sp,-20
 822e344:	dfc00415 	stw	ra,16(sp)
 822e348:	df000315 	stw	fp,12(sp)
 822e34c:	df000304 	addi	fp,sp,12
 822e350:	e13ffd15 	stw	r4,-12(fp)
 822e354:	e17ffe15 	stw	r5,-8(fp)
 822e358:	e1bfff15 	stw	r6,-4(fp)
#ifdef IP_RAW
   if (type == SOCK_RAW)
 822e35c:	e0bfff17 	ldw	r2,-4(fp)
 822e360:	108000d8 	cmpnei	r2,r2,3
 822e364:	1000041e 	bne	r2,zero,822e378 <pffindproto+0x38>
      return(pffindtype(domain, type));
 822e368:	e17fff17 	ldw	r5,-4(fp)
 822e36c:	e13ffd17 	ldw	r4,-12(fp)
 822e370:	822e2b00 	call	822e2b0 <pffindtype>
 822e374:	00001e06 	br	822e3f0 <pffindproto+0xb0>
#endif

   switch (protocol)
 822e378:	e0bffe17 	ldw	r2,-8(fp)
 822e37c:	10c001a0 	cmpeqi	r3,r2,6
 822e380:	1800041e 	bne	r3,zero,822e394 <pffindproto+0x54>
 822e384:	10c00460 	cmpeqi	r3,r2,17
 822e388:	1800081e 	bne	r3,zero,822e3ac <pffindproto+0x6c>
 822e38c:	10001026 	beq	r2,zero,822e3d0 <pffindproto+0x90>
 822e390:	00000c06 	br	822e3c4 <pffindproto+0x84>
   {
#ifdef BSD_SOCKETS
   case IPPROTO_TCP:
      if (type == SOCK_STREAM)
 822e394:	e0bfff17 	ldw	r2,-4(fp)
 822e398:	10800058 	cmpnei	r2,r2,1
 822e39c:	10000e26 	beq	r2,zero,822e3d8 <pffindproto+0x98>
         break;
      /* IPPROTO_TCP protocol on non-SOCK_STREAM type socket */
      dtrap();
 822e3a0:	822d5f00 	call	822d5f0 <dtrap>
      return NULL;
 822e3a4:	0005883a 	mov	r2,zero
 822e3a8:	00001106 	br	822e3f0 <pffindproto+0xb0>
   case IPPROTO_UDP:
      if (type == SOCK_DGRAM)
 822e3ac:	e0bfff17 	ldw	r2,-4(fp)
 822e3b0:	10800098 	cmpnei	r2,r2,2
 822e3b4:	10000a26 	beq	r2,zero,822e3e0 <pffindproto+0xa0>
         break;
      /* IPPROTO_UDP protocol on non-SOCK_DGRAM type socket */
      dtrap();
 822e3b8:	822d5f00 	call	822d5f0 <dtrap>
      return NULL;
 822e3bc:	0005883a 	mov	r2,zero
 822e3c0:	00000b06 	br	822e3f0 <pffindproto+0xb0>
   case 0:
      /* let protocol default based on socket type */
      break;
   default:
      /* unknown/unsupported protocol on socket */
      dtrap();
 822e3c4:	822d5f00 	call	822d5f0 <dtrap>
      return NULL;
 822e3c8:	0005883a 	mov	r2,zero
 822e3cc:	00000806 	br	822e3f0 <pffindproto+0xb0>
      dtrap();
      return NULL;
#endif /* BSD_SOCKETS */
   case 0:
      /* let protocol default based on socket type */
      break;
 822e3d0:	0001883a 	nop
 822e3d4:	00000306 	br	822e3e4 <pffindproto+0xa4>
   switch (protocol)
   {
#ifdef BSD_SOCKETS
   case IPPROTO_TCP:
      if (type == SOCK_STREAM)
         break;
 822e3d8:	0001883a 	nop
 822e3dc:	00000106 	br	822e3e4 <pffindproto+0xa4>
      /* IPPROTO_TCP protocol on non-SOCK_STREAM type socket */
      dtrap();
      return NULL;
   case IPPROTO_UDP:
      if (type == SOCK_DGRAM)
         break;
 822e3e0:	0001883a 	nop
   default:
      /* unknown/unsupported protocol on socket */
      dtrap();
      return NULL;
   }
   return(pffindtype(domain, type));   /* map to findtype */
 822e3e4:	e17fff17 	ldw	r5,-4(fp)
 822e3e8:	e13ffd17 	ldw	r4,-12(fp)
 822e3ec:	822e2b00 	call	822e2b0 <pffindtype>
}
 822e3f0:	e037883a 	mov	sp,fp
 822e3f4:	dfc00117 	ldw	ra,4(sp)
 822e3f8:	df000017 	ldw	fp,0(sp)
 822e3fc:	dec00204 	addi	sp,sp,8
 822e400:	f800283a 	ret

0822e404 <m_getnbuf>:
 * RETURNS: 
 */

struct mbuf *  
m_getnbuf(int type, int len)
{
 822e404:	defffa04 	addi	sp,sp,-24
 822e408:	dfc00515 	stw	ra,20(sp)
 822e40c:	df000415 	stw	fp,16(sp)
 822e410:	df000404 	addi	fp,sp,16
 822e414:	e13ffe15 	stw	r4,-8(fp)
 822e418:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;
   PACKET pkt = NULL;
 822e41c:	e03ffc15 	stw	zero,-16(fp)

#ifdef NPDEBUG
   if (type < MT_RXDATA || type > MT_IFADDR)
 822e420:	e0bffe17 	ldw	r2,-8(fp)
 822e424:	0080030e 	bge	zero,r2,822e434 <m_getnbuf+0x30>
 822e428:	e0bffe17 	ldw	r2,-8(fp)
 822e42c:	10800390 	cmplti	r2,r2,14
 822e430:	1000011e 	bne	r2,zero,822e438 <m_getnbuf+0x34>
   {
      dtrap(); /* is this OK? */
 822e434:	822d5f00 	call	822d5f0 <dtrap>
   }
#endif

   /* if caller has data (len >= 0), we need to allocate 
    * a packet buffer; else all we need is the mbuf */
   if (len != 0)
 822e438:	e0bfff17 	ldw	r2,-4(fp)
 822e43c:	10000d26 	beq	r2,zero,822e474 <m_getnbuf+0x70>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 822e440:	01000084 	movi	r4,2
 822e444:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pkt = pk_alloc(len + HDRSLEN);
 822e448:	e0bfff17 	ldw	r2,-4(fp)
 822e44c:	10800e04 	addi	r2,r2,56
 822e450:	1009883a 	mov	r4,r2
 822e454:	822ca480 	call	822ca48 <pk_alloc>
 822e458:	e0bffc15 	stw	r2,-16(fp)

      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822e45c:	01000084 	movi	r4,2
 822e460:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      if (!pkt)
 822e464:	e0bffc17 	ldw	r2,-16(fp)
 822e468:	1000021e 	bne	r2,zero,822e474 <m_getnbuf+0x70>
         return NULL;
 822e46c:	0005883a 	mov	r2,zero
 822e470:	00004106 	br	822e578 <m_getnbuf+0x174>
   }

   m = (struct mbuf *)getq(&mfreeq);
 822e474:	010209b4 	movhi	r4,2086
 822e478:	21399304 	addi	r4,r4,-6580
 822e47c:	822cf200 	call	822cf20 <getq>
 822e480:	e0bffd15 	stw	r2,-12(fp)
   if (!m)
 822e484:	e0bffd17 	ldw	r2,-12(fp)
 822e488:	10000a1e 	bne	r2,zero,822e4b4 <m_getnbuf+0xb0>
   {
      if (pkt) 
 822e48c:	e0bffc17 	ldw	r2,-16(fp)
 822e490:	10000626 	beq	r2,zero,822e4ac <m_getnbuf+0xa8>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 822e494:	01000084 	movi	r4,2
 822e498:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
         pk_free(pkt);
 822e49c:	e13ffc17 	ldw	r4,-16(fp)
 822e4a0:	822cd980 	call	822cd98 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822e4a4:	01000084 	movi	r4,2
 822e4a8:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      }
      return NULL;
 822e4ac:	0005883a 	mov	r2,zero
 822e4b0:	00003106 	br	822e578 <m_getnbuf+0x174>
   }
   m->m_type = type;
 822e4b4:	e0bffd17 	ldw	r2,-12(fp)
 822e4b8:	e0fffe17 	ldw	r3,-8(fp)
 822e4bc:	10c00815 	stw	r3,32(r2)
   if (len == 0)
 822e4c0:	e0bfff17 	ldw	r2,-4(fp)
 822e4c4:	1000071e 	bne	r2,zero,822e4e4 <m_getnbuf+0xe0>
   {
      m->pkt = NULL;
 822e4c8:	e0bffd17 	ldw	r2,-12(fp)
 822e4cc:	10000115 	stw	zero,4(r2)
      m->m_base = NULL;    /* caller better fill these in! */
 822e4d0:	e0bffd17 	ldw	r2,-12(fp)
 822e4d4:	10000415 	stw	zero,16(r2)
      m->m_memsz = 0;
 822e4d8:	e0bffd17 	ldw	r2,-12(fp)
 822e4dc:	10000515 	stw	zero,20(r2)
 822e4e0:	00001506 	br	822e538 <m_getnbuf+0x134>
   }
   else
   {
      m->pkt = pkt;
 822e4e4:	e0bffd17 	ldw	r2,-12(fp)
 822e4e8:	e0fffc17 	ldw	r3,-16(fp)
 822e4ec:	10c00115 	stw	r3,4(r2)
      /* set m_data to the part where tcp data should go */
      m->m_base = m->m_data = pkt->nb_prot = pkt->nb_buff + HDRSLEN;
 822e4f0:	e0bffc17 	ldw	r2,-16(fp)
 822e4f4:	10800117 	ldw	r2,4(r2)
 822e4f8:	10c00e04 	addi	r3,r2,56
 822e4fc:	e0bffc17 	ldw	r2,-16(fp)
 822e500:	10c00315 	stw	r3,12(r2)
 822e504:	e0bffc17 	ldw	r2,-16(fp)
 822e508:	10c00317 	ldw	r3,12(r2)
 822e50c:	e0bffd17 	ldw	r2,-12(fp)
 822e510:	10c00315 	stw	r3,12(r2)
 822e514:	e0bffd17 	ldw	r2,-12(fp)
 822e518:	10c00317 	ldw	r3,12(r2)
 822e51c:	e0bffd17 	ldw	r2,-12(fp)
 822e520:	10c00415 	stw	r3,16(r2)
      m->m_memsz = pkt->nb_blen - HDRSLEN;
 822e524:	e0bffc17 	ldw	r2,-16(fp)
 822e528:	10800217 	ldw	r2,8(r2)
 822e52c:	10fff204 	addi	r3,r2,-56
 822e530:	e0bffd17 	ldw	r2,-12(fp)
 822e534:	10c00515 	stw	r3,20(r2)
   }
   m->m_len = 0;
 822e538:	e0bffd17 	ldw	r2,-12(fp)
 822e53c:	10000215 	stw	zero,8(r2)
   m->m_next = m->m_act = NULL;
 822e540:	e0bffd17 	ldw	r2,-12(fp)
 822e544:	10000715 	stw	zero,28(r2)
 822e548:	e0bffd17 	ldw	r2,-12(fp)
 822e54c:	10c00717 	ldw	r3,28(r2)
 822e550:	e0bffd17 	ldw	r2,-12(fp)
 822e554:	10c00615 	stw	r3,24(r2)
   mbstat.allocs++;        /* maintain local statistics */
 822e558:	d0a0ae17 	ldw	r2,-32072(gp)
 822e55c:	10800044 	addi	r2,r2,1
 822e560:	d0a0ae15 	stw	r2,-32072(gp)
   putq(&mbufq, (qp)m);
 822e564:	e17ffd17 	ldw	r5,-12(fp)
 822e568:	010209b4 	movhi	r4,2086
 822e56c:	21398e04 	addi	r4,r4,-6600
 822e570:	822cfd80 	call	822cfd8 <putq>
   return m;
 822e574:	e0bffd17 	ldw	r2,-12(fp)
}
 822e578:	e037883a 	mov	sp,fp
 822e57c:	dfc00117 	ldw	ra,4(sp)
 822e580:	df000017 	ldw	fp,0(sp)
 822e584:	dec00204 	addi	sp,sp,8
 822e588:	f800283a 	ret

0822e58c <m_free>:
 */


struct mbuf *  
m_free(struct mbuf * m)
{
 822e58c:	defffc04 	addi	sp,sp,-16
 822e590:	dfc00315 	stw	ra,12(sp)
 822e594:	df000215 	stw	fp,8(sp)
 822e598:	df000204 	addi	fp,sp,8
 822e59c:	e13fff15 	stw	r4,-4(fp)
   struct mbuf *  nextptr;

#ifdef NPDEBUG
   if (mbufq.q_len < 1)
 822e5a0:	008209b4 	movhi	r2,2086
 822e5a4:	10b98e04 	addi	r2,r2,-6600
 822e5a8:	10800217 	ldw	r2,8(r2)
 822e5ac:	00800316 	blt	zero,r2,822e5bc <m_free+0x30>
      panic("mfree: q_len");
 822e5b0:	01020974 	movhi	r4,2085
 822e5b4:	21037204 	addi	r4,r4,3528
 822e5b8:	8228ca40 	call	8228ca4 <panic>

   if (m->m_type < MT_RXDATA || m->m_type > MT_IFADDR)
 822e5bc:	e0bfff17 	ldw	r2,-4(fp)
 822e5c0:	10800817 	ldw	r2,32(r2)
 822e5c4:	0080040e 	bge	zero,r2,822e5d8 <m_free+0x4c>
 822e5c8:	e0bfff17 	ldw	r2,-4(fp)
 822e5cc:	10800817 	ldw	r2,32(r2)
 822e5d0:	10800390 	cmplti	r2,r2,14
 822e5d4:	10000a1e 	bne	r2,zero,822e600 <m_free+0x74>
   {
      if (m->m_type == MT_FREE)
 822e5d8:	e0bfff17 	ldw	r2,-4(fp)
 822e5dc:	10800817 	ldw	r2,32(r2)
 822e5e0:	1000041e 	bne	r2,zero,822e5f4 <m_free+0x68>
      {
         dtrap(); /* debug double free of mbuf by tcp_in() */
 822e5e4:	822d5f00 	call	822d5f0 <dtrap>
         return m->m_next; /* seems harmless, though.... */
 822e5e8:	e0bfff17 	ldw	r2,-4(fp)
 822e5ec:	10800617 	ldw	r2,24(r2)
 822e5f0:	00002306 	br	822e680 <m_free+0xf4>
      }
      else
         panic("m_free: type");
 822e5f4:	01020974 	movhi	r4,2085
 822e5f8:	21037604 	addi	r4,r4,3544
 822e5fc:	8228ca40 	call	8228ca4 <panic>
   }
#endif   /* NPDEBUG */

   nextptr = m->m_next;    /* remember value to return */
 822e600:	e0bfff17 	ldw	r2,-4(fp)
 822e604:	10800617 	ldw	r2,24(r2)
 822e608:	e0bffe15 	stw	r2,-8(fp)

   if (qdel(&mbufq, m) == NULL)
 822e60c:	e17fff17 	ldw	r5,-4(fp)
 822e610:	010209b4 	movhi	r4,2086
 822e614:	21398e04 	addi	r4,r4,-6600
 822e618:	822d0880 	call	822d088 <qdel>
 822e61c:	1000031e 	bne	r2,zero,822e62c <m_free+0xa0>
      panic("m_free: missing");
 822e620:	01020974 	movhi	r4,2085
 822e624:	21037a04 	addi	r4,r4,3560
 822e628:	8228ca40 	call	8228ca4 <panic>

   m->m_type = MT_FREE;    /* this may seem silly, but helps error checking */
 822e62c:	e0bfff17 	ldw	r2,-4(fp)
 822e630:	10000815 	stw	zero,32(r2)

   if (m->pkt)
 822e634:	e0bfff17 	ldw	r2,-4(fp)
 822e638:	10800117 	ldw	r2,4(r2)
 822e63c:	10000826 	beq	r2,zero,822e660 <m_free+0xd4>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 822e640:	01000084 	movi	r4,2
 822e644:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free(m->pkt);     /* free up the netport buffer */
 822e648:	e0bfff17 	ldw	r2,-4(fp)
 822e64c:	10800117 	ldw	r2,4(r2)
 822e650:	1009883a 	mov	r4,r2
 822e654:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822e658:	01000084 	movi	r4,2
 822e65c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   }
   mbstat.frees++;
 822e660:	d0a0af17 	ldw	r2,-32068(gp)
 822e664:	10800044 	addi	r2,r2,1
 822e668:	d0a0af15 	stw	r2,-32068(gp)
   putq(&mfreeq, (qp)m);
 822e66c:	e17fff17 	ldw	r5,-4(fp)
 822e670:	010209b4 	movhi	r4,2086
 822e674:	21399304 	addi	r4,r4,-6580
 822e678:	822cfd80 	call	822cfd8 <putq>
   return nextptr;
 822e67c:	e0bffe17 	ldw	r2,-8(fp)
}
 822e680:	e037883a 	mov	sp,fp
 822e684:	dfc00117 	ldw	ra,4(sp)
 822e688:	df000017 	ldw	fp,0(sp)
 822e68c:	dec00204 	addi	sp,sp,8
 822e690:	f800283a 	ret

0822e694 <m_freem>:
 * RETURNS: 
 */

void
m_freem(struct mbuf * m)
{
 822e694:	defffd04 	addi	sp,sp,-12
 822e698:	dfc00215 	stw	ra,8(sp)
 822e69c:	df000115 	stw	fp,4(sp)
 822e6a0:	df000104 	addi	fp,sp,4
 822e6a4:	e13fff15 	stw	r4,-4(fp)
   while (m != NULL)
 822e6a8:	00000306 	br	822e6b8 <m_freem+0x24>
      m = m_free(m);
 822e6ac:	e13fff17 	ldw	r4,-4(fp)
 822e6b0:	822e58c0 	call	822e58c <m_free>
 822e6b4:	e0bfff15 	stw	r2,-4(fp)
 */

void
m_freem(struct mbuf * m)
{
   while (m != NULL)
 822e6b8:	e0bfff17 	ldw	r2,-4(fp)
 822e6bc:	103ffb1e 	bne	r2,zero,822e6ac <m_freem+0x18>
      m = m_free(m);
}
 822e6c0:	0001883a 	nop
 822e6c4:	e037883a 	mov	sp,fp
 822e6c8:	dfc00117 	ldw	ra,4(sp)
 822e6cc:	df000017 	ldw	fp,0(sp)
 822e6d0:	dec00204 	addi	sp,sp,8
 822e6d4:	f800283a 	ret

0822e6d8 <m_copy>:
 * RETURNS: 
 */

struct mbuf *  
m_copy(struct mbuf * m, int off, int len)
{
 822e6d8:	defff704 	addi	sp,sp,-36
 822e6dc:	dfc00815 	stw	ra,32(sp)
 822e6e0:	df000715 	stw	fp,28(sp)
 822e6e4:	df000704 	addi	fp,sp,28
 822e6e8:	e13ffd15 	stw	r4,-12(fp)
 822e6ec:	e17ffe15 	stw	r5,-8(fp)
 822e6f0:	e1bfff15 	stw	r6,-4(fp)
   struct mbuf *  nb, * head, *  tail;
   int   tocopy;

   if (len == 0)  /* nothing to do */
 822e6f4:	e0bfff17 	ldw	r2,-4(fp)
 822e6f8:	1000021e 	bne	r2,zero,822e704 <m_copy+0x2c>
      return NULL;
 822e6fc:	0005883a 	mov	r2,zero
 822e700:	0000ad06 	br	822e9b8 <m_copy+0x2e0>

#ifdef NPDEBUG
   /* sanity test parms */
   if (off < 0 || (len < 0 && len != M_COPYALL))
 822e704:	e0bffe17 	ldw	r2,-8(fp)
 822e708:	10000516 	blt	r2,zero,822e720 <m_copy+0x48>
 822e70c:	e0bfff17 	ldw	r2,-4(fp)
 822e710:	1000180e 	bge	r2,zero,822e774 <m_copy+0x9c>
 822e714:	e0bfff17 	ldw	r2,-4(fp)
 822e718:	10bfffe0 	cmpeqi	r2,r2,-1
 822e71c:	1000151e 	bne	r2,zero,822e774 <m_copy+0x9c>
   {
      dtrap();
 822e720:	822d5f00 	call	822d5f0 <dtrap>
      return NULL;
 822e724:	0005883a 	mov	r2,zero
 822e728:	0000a306 	br	822e9b8 <m_copy+0x2e0>
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
   {
      if (!m)
 822e72c:	e0bffd17 	ldw	r2,-12(fp)
 822e730:	1000031e 	bne	r2,zero,822e740 <m_copy+0x68>
      {
         dtrap();
 822e734:	822d5f00 	call	822d5f0 <dtrap>
         return NULL;
 822e738:	0005883a 	mov	r2,zero
 822e73c:	00009e06 	br	822e9b8 <m_copy+0x2e0>
      }
      if (off < (int)m->m_len)
 822e740:	e0bffd17 	ldw	r2,-12(fp)
 822e744:	10800217 	ldw	r2,8(r2)
 822e748:	1007883a 	mov	r3,r2
 822e74c:	e0bffe17 	ldw	r2,-8(fp)
 822e750:	10c00b16 	blt	r2,r3,822e780 <m_copy+0xa8>
         break;
      off -= m->m_len;
 822e754:	e0fffe17 	ldw	r3,-8(fp)
 822e758:	e0bffd17 	ldw	r2,-12(fp)
 822e75c:	10800217 	ldw	r2,8(r2)
 822e760:	1885c83a 	sub	r2,r3,r2
 822e764:	e0bffe15 	stw	r2,-8(fp)
      m = m->m_next;
 822e768:	e0bffd17 	ldw	r2,-12(fp)
 822e76c:	10800617 	ldw	r2,24(r2)
 822e770:	e0bffd15 	stw	r2,-12(fp)
      return NULL;
   }
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
 822e774:	e0bffe17 	ldw	r2,-8(fp)
 822e778:	00bfec16 	blt	zero,r2,822e72c <m_copy+0x54>
 822e77c:	00000106 	br	822e784 <m_copy+0xac>
      {
         dtrap();
         return NULL;
      }
      if (off < (int)m->m_len)
         break;
 822e780:	0001883a 	nop
      off -= m->m_len;
      m = m->m_next;
   }

   head = tail = NULL;
 822e784:	e03ffb15 	stw	zero,-20(fp)
 822e788:	e0bffb17 	ldw	r2,-20(fp)
 822e78c:	e0bffa15 	stw	r2,-24(fp)

   while (len > 0)
 822e790:	00007f06 	br	822e990 <m_copy+0x2b8>
   {
      if (m == NULL) /* at end of queue? */
 822e794:	e0bffd17 	ldw	r2,-12(fp)
 822e798:	1000051e 	bne	r2,zero,822e7b0 <m_copy+0xd8>
      {
         panic("m_copy: bad len");
 822e79c:	01020974 	movhi	r4,2085
 822e7a0:	21037e04 	addi	r4,r4,3576
 822e7a4:	8228ca40 	call	8228ca4 <panic>
         return NULL;
 822e7a8:	0005883a 	mov	r2,zero
 822e7ac:	00008206 	br	822e9b8 <m_copy+0x2e0>
      }
      tocopy = (int)MIN(len, (int)(m->m_len - off));
 822e7b0:	e0bffd17 	ldw	r2,-12(fp)
 822e7b4:	10c00217 	ldw	r3,8(r2)
 822e7b8:	e0bffe17 	ldw	r2,-8(fp)
 822e7bc:	1885c83a 	sub	r2,r3,r2
 822e7c0:	e0ffff17 	ldw	r3,-4(fp)
 822e7c4:	1880010e 	bge	r3,r2,822e7cc <m_copy+0xf4>
 822e7c8:	1805883a 	mov	r2,r3
 822e7cc:	e0bffc15 	stw	r2,-16(fp)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 822e7d0:	e0bffe17 	ldw	r2,-8(fp)
 822e7d4:	108000cc 	andi	r2,r2,3
 822e7d8:	1000051e 	bne	r2,zero,822e7f0 <m_copy+0x118>
          (m->pkt->inuse != 1))
 822e7dc:	e0bffd17 	ldw	r2,-12(fp)
 822e7e0:	10800117 	ldw	r2,4(r2)
 822e7e4:	10800917 	ldw	r2,36(r2)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 822e7e8:	10800060 	cmpeqi	r2,r2,1
 822e7ec:	1000251e 	bne	r2,zero,822e884 <m_copy+0x1ac>
          (m->pkt->inuse != 1))
      {
         if ((nb = m_getwithdata (m->m_type, tocopy)) == NULL)
 822e7f0:	e0bffd17 	ldw	r2,-12(fp)
 822e7f4:	10800817 	ldw	r2,32(r2)
 822e7f8:	e17ffc17 	ldw	r5,-16(fp)
 822e7fc:	1009883a 	mov	r4,r2
 822e800:	822e4040 	call	822e404 <m_getnbuf>
 822e804:	e0bff915 	stw	r2,-28(fp)
 822e808:	e0bff917 	ldw	r2,-28(fp)
 822e80c:	10006426 	beq	r2,zero,822e9a0 <m_copy+0x2c8>
            goto nospace;
         MEMCPY(nb->m_data, m->m_data+off, tocopy);
 822e810:	e0bff917 	ldw	r2,-28(fp)
 822e814:	11000317 	ldw	r4,12(r2)
 822e818:	e0bffd17 	ldw	r2,-12(fp)
 822e81c:	10c00317 	ldw	r3,12(r2)
 822e820:	e0bffe17 	ldw	r2,-8(fp)
 822e824:	1885883a 	add	r2,r3,r2
 822e828:	e0fffc17 	ldw	r3,-16(fp)
 822e82c:	180d883a 	mov	r6,r3
 822e830:	100b883a 	mov	r5,r2
 822e834:	8202f6c0 	call	8202f6c <memcpy>
         nb->m_len = tocopy;  /* set length of data we just moved into new mbuf */
 822e838:	e0fffc17 	ldw	r3,-16(fp)
 822e83c:	e0bff917 	ldw	r2,-28(fp)
 822e840:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mcopies++;
 822e844:	008209b4 	movhi	r2,2086
 822e848:	10b9ad04 	addi	r2,r2,-6476
 822e84c:	10802e17 	ldw	r2,184(r2)
 822e850:	10c00044 	addi	r3,r2,1
 822e854:	008209b4 	movhi	r2,2086
 822e858:	10b9ad04 	addi	r2,r2,-6476
 822e85c:	10c02e15 	stw	r3,184(r2)
         tcpstat.tcps_mcopiedbytes += tocopy;
 822e860:	008209b4 	movhi	r2,2086
 822e864:	10b9ad04 	addi	r2,r2,-6476
 822e868:	10c03017 	ldw	r3,192(r2)
 822e86c:	e0bffc17 	ldw	r2,-16(fp)
 822e870:	1887883a 	add	r3,r3,r2
 822e874:	008209b4 	movhi	r2,2086
 822e878:	10b9ad04 	addi	r2,r2,-6476
 822e87c:	10c03015 	stw	r3,192(r2)
 822e880:	00003106 	br	822e948 <m_copy+0x270>
      {
         /* Rather than memcpy every mbuf's data, "clone" the data by 
          * making a duplicate of the mbufs involved and bumping the 
          * inuse count of the actual packet structs
          */
         if ((nb = m_getwithdata (m->m_type, 0)) == NULL)
 822e884:	e0bffd17 	ldw	r2,-12(fp)
 822e888:	10800817 	ldw	r2,32(r2)
 822e88c:	000b883a 	mov	r5,zero
 822e890:	1009883a 	mov	r4,r2
 822e894:	822e4040 	call	822e404 <m_getnbuf>
 822e898:	e0bff915 	stw	r2,-28(fp)
 822e89c:	e0bff917 	ldw	r2,-28(fp)
 822e8a0:	10004126 	beq	r2,zero,822e9a8 <m_copy+0x2d0>
            goto nospace;

         m->pkt->inuse++;     /* bump pkt use count to clone it */
 822e8a4:	e0bffd17 	ldw	r2,-12(fp)
 822e8a8:	10800117 	ldw	r2,4(r2)
 822e8ac:	10c00917 	ldw	r3,36(r2)
 822e8b0:	18c00044 	addi	r3,r3,1
 822e8b4:	10c00915 	stw	r3,36(r2)

         /* set up new mbuf with pointers to cloned packet */
         nb->pkt = m->pkt;
 822e8b8:	e0bffd17 	ldw	r2,-12(fp)
 822e8bc:	10c00117 	ldw	r3,4(r2)
 822e8c0:	e0bff917 	ldw	r2,-28(fp)
 822e8c4:	10c00115 	stw	r3,4(r2)
         nb->m_base = m->m_base;
 822e8c8:	e0bffd17 	ldw	r2,-12(fp)
 822e8cc:	10c00417 	ldw	r3,16(r2)
 822e8d0:	e0bff917 	ldw	r2,-28(fp)
 822e8d4:	10c00415 	stw	r3,16(r2)
         nb->m_memsz = m->m_memsz;
 822e8d8:	e0bffd17 	ldw	r2,-12(fp)
 822e8dc:	10c00517 	ldw	r3,20(r2)
 822e8e0:	e0bff917 	ldw	r2,-28(fp)
 822e8e4:	10c00515 	stw	r3,20(r2)
         nb->m_data = m->m_data + off;
 822e8e8:	e0bffd17 	ldw	r2,-12(fp)
 822e8ec:	10c00317 	ldw	r3,12(r2)
 822e8f0:	e0bffe17 	ldw	r2,-8(fp)
 822e8f4:	1887883a 	add	r3,r3,r2
 822e8f8:	e0bff917 	ldw	r2,-28(fp)
 822e8fc:	10c00315 	stw	r3,12(r2)
         nb->m_len = tocopy;
 822e900:	e0fffc17 	ldw	r3,-16(fp)
 822e904:	e0bff917 	ldw	r2,-28(fp)
 822e908:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mclones++;
 822e90c:	008209b4 	movhi	r2,2086
 822e910:	10b9ad04 	addi	r2,r2,-6476
 822e914:	10802f17 	ldw	r2,188(r2)
 822e918:	10c00044 	addi	r3,r2,1
 822e91c:	008209b4 	movhi	r2,2086
 822e920:	10b9ad04 	addi	r2,r2,-6476
 822e924:	10c02f15 	stw	r3,188(r2)
         tcpstat.tcps_mclonedbytes += tocopy;
 822e928:	008209b4 	movhi	r2,2086
 822e92c:	10b9ad04 	addi	r2,r2,-6476
 822e930:	10c03117 	ldw	r3,196(r2)
 822e934:	e0bffc17 	ldw	r2,-16(fp)
 822e938:	1887883a 	add	r3,r3,r2
 822e93c:	008209b4 	movhi	r2,2086
 822e940:	10b9ad04 	addi	r2,r2,-6476
 822e944:	10c03115 	stw	r3,196(r2)
      }

      len -= tocopy;
 822e948:	e0ffff17 	ldw	r3,-4(fp)
 822e94c:	e0bffc17 	ldw	r2,-16(fp)
 822e950:	1885c83a 	sub	r2,r3,r2
 822e954:	e0bfff15 	stw	r2,-4(fp)
      off = 0;
 822e958:	e03ffe15 	stw	zero,-8(fp)
      if (tail)      /* head & tail are set by first pass thru loop */
 822e95c:	e0bffb17 	ldw	r2,-20(fp)
 822e960:	10000426 	beq	r2,zero,822e974 <m_copy+0x29c>
         tail->m_next = nb;
 822e964:	e0bffb17 	ldw	r2,-20(fp)
 822e968:	e0fff917 	ldw	r3,-28(fp)
 822e96c:	10c00615 	stw	r3,24(r2)
 822e970:	00000206 	br	822e97c <m_copy+0x2a4>
      else
         head = nb;
 822e974:	e0bff917 	ldw	r2,-28(fp)
 822e978:	e0bffa15 	stw	r2,-24(fp)
      tail = nb;     /* always make new mbuf the tail */
 822e97c:	e0bff917 	ldw	r2,-28(fp)
 822e980:	e0bffb15 	stw	r2,-20(fp)
      m = m->m_next;
 822e984:	e0bffd17 	ldw	r2,-12(fp)
 822e988:	10800617 	ldw	r2,24(r2)
 822e98c:	e0bffd15 	stw	r2,-12(fp)
      m = m->m_next;
   }

   head = tail = NULL;

   while (len > 0)
 822e990:	e0bfff17 	ldw	r2,-4(fp)
 822e994:	00bf7f16 	blt	zero,r2,822e794 <m_copy+0xbc>
      tail = nb;     /* always make new mbuf the tail */
      m = m->m_next;

   }

   return head;
 822e998:	e0bffa17 	ldw	r2,-24(fp)
 822e99c:	00000606 	br	822e9b8 <m_copy+0x2e0>
       */
      if ((off & (ALIGN_TYPE - 1)) ||
          (m->pkt->inuse != 1))
      {
         if ((nb = m_getwithdata (m->m_type, tocopy)) == NULL)
            goto nospace;
 822e9a0:	0001883a 	nop
 822e9a4:	00000106 	br	822e9ac <m_copy+0x2d4>
         /* Rather than memcpy every mbuf's data, "clone" the data by 
          * making a duplicate of the mbufs involved and bumping the 
          * inuse count of the actual packet structs
          */
         if ((nb = m_getwithdata (m->m_type, 0)) == NULL)
            goto nospace;
 822e9a8:	0001883a 	nop
   }

   return head;

nospace:
   m_freem (head);
 822e9ac:	e13ffa17 	ldw	r4,-24(fp)
 822e9b0:	822e6940 	call	822e694 <m_freem>
   return NULL;
 822e9b4:	0005883a 	mov	r2,zero
}
 822e9b8:	e037883a 	mov	sp,fp
 822e9bc:	dfc00117 	ldw	ra,4(sp)
 822e9c0:	df000017 	ldw	fp,0(sp)
 822e9c4:	dec00204 	addi	sp,sp,8
 822e9c8:	f800283a 	ret

0822e9cc <m_adj>:
 * RETURNS: 
 */

void
m_adj(struct mbuf * mp, int len)
{
 822e9cc:	defffb04 	addi	sp,sp,-20
 822e9d0:	df000415 	stw	fp,16(sp)
 822e9d4:	df000404 	addi	fp,sp,16
 822e9d8:	e13ffe15 	stw	r4,-8(fp)
 822e9dc:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;
   int   count;

   if ((m = mp) == NULL)
 822e9e0:	e0bffe17 	ldw	r2,-8(fp)
 822e9e4:	e0bffc15 	stw	r2,-16(fp)
 822e9e8:	e0bffc17 	ldw	r2,-16(fp)
 822e9ec:	10006226 	beq	r2,zero,822eb78 <m_adj+0x1ac>
      return;

   if (len >= 0) 
 822e9f0:	e0bfff17 	ldw	r2,-4(fp)
 822e9f4:	10002216 	blt	r2,zero,822ea80 <m_adj+0xb4>
   {
      while (m != NULL && len > 0) 
 822e9f8:	00001c06 	br	822ea6c <m_adj+0xa0>
      {
         if (m->m_len <= (unsigned)len)
 822e9fc:	e0bffc17 	ldw	r2,-16(fp)
 822ea00:	10800217 	ldw	r2,8(r2)
 822ea04:	e0ffff17 	ldw	r3,-4(fp)
 822ea08:	18800b36 	bltu	r3,r2,822ea38 <m_adj+0x6c>
         {
            len -= m->m_len;
 822ea0c:	e0ffff17 	ldw	r3,-4(fp)
 822ea10:	e0bffc17 	ldw	r2,-16(fp)
 822ea14:	10800217 	ldw	r2,8(r2)
 822ea18:	1885c83a 	sub	r2,r3,r2
 822ea1c:	e0bfff15 	stw	r2,-4(fp)
            m->m_len = 0;
 822ea20:	e0bffc17 	ldw	r2,-16(fp)
 822ea24:	10000215 	stw	zero,8(r2)
            m = m->m_next;
 822ea28:	e0bffc17 	ldw	r2,-16(fp)
 822ea2c:	10800617 	ldw	r2,24(r2)
 822ea30:	e0bffc15 	stw	r2,-16(fp)
 822ea34:	00000d06 	br	822ea6c <m_adj+0xa0>
         }
         else
         {
            m->m_len -= len;
 822ea38:	e0bffc17 	ldw	r2,-16(fp)
 822ea3c:	10c00217 	ldw	r3,8(r2)
 822ea40:	e0bfff17 	ldw	r2,-4(fp)
 822ea44:	1887c83a 	sub	r3,r3,r2
 822ea48:	e0bffc17 	ldw	r2,-16(fp)
 822ea4c:	10c00215 	stw	r3,8(r2)
            m->m_data += len;
 822ea50:	e0bffc17 	ldw	r2,-16(fp)
 822ea54:	10c00317 	ldw	r3,12(r2)
 822ea58:	e0bfff17 	ldw	r2,-4(fp)
 822ea5c:	1887883a 	add	r3,r3,r2
 822ea60:	e0bffc17 	ldw	r2,-16(fp)
 822ea64:	10c00315 	stw	r3,12(r2)
            break;
 822ea68:	00004406 	br	822eb7c <m_adj+0x1b0>
   if ((m = mp) == NULL)
      return;

   if (len >= 0) 
   {
      while (m != NULL && len > 0) 
 822ea6c:	e0bffc17 	ldw	r2,-16(fp)
 822ea70:	10004226 	beq	r2,zero,822eb7c <m_adj+0x1b0>
 822ea74:	e0bfff17 	ldw	r2,-4(fp)
 822ea78:	00bfe016 	blt	zero,r2,822e9fc <m_adj+0x30>
 822ea7c:	00003f06 	br	822eb7c <m_adj+0x1b0>
       * calculating its length and finding the last mbuf.
       * If the adjustment only affects this mbuf, then just
       * adjust and return.  Otherwise, rescan and truncate
       * after the remaining size.
       */
      len = -len;
 822ea80:	e0bfff17 	ldw	r2,-4(fp)
 822ea84:	0085c83a 	sub	r2,zero,r2
 822ea88:	e0bfff15 	stw	r2,-4(fp)
      count = 0;
 822ea8c:	e03ffd15 	stw	zero,-12(fp)
      for (;;) 
      {
         count += m->m_len;
 822ea90:	e0bffc17 	ldw	r2,-16(fp)
 822ea94:	10c00217 	ldw	r3,8(r2)
 822ea98:	e0bffd17 	ldw	r2,-12(fp)
 822ea9c:	1885883a 	add	r2,r3,r2
 822eaa0:	e0bffd15 	stw	r2,-12(fp)
         if (m->m_next == (struct mbuf *)0)
 822eaa4:	e0bffc17 	ldw	r2,-16(fp)
 822eaa8:	10800617 	ldw	r2,24(r2)
 822eaac:	10000426 	beq	r2,zero,822eac0 <m_adj+0xf4>
            break;
         m = m->m_next;
 822eab0:	e0bffc17 	ldw	r2,-16(fp)
 822eab4:	10800617 	ldw	r2,24(r2)
 822eab8:	e0bffc15 	stw	r2,-16(fp)
      }
 822eabc:	003ff406 	br	822ea90 <m_adj+0xc4>
      count = 0;
      for (;;) 
      {
         count += m->m_len;
         if (m->m_next == (struct mbuf *)0)
            break;
 822eac0:	0001883a 	nop
         m = m->m_next;
      }
      if (m->m_len >= (unsigned)len)
 822eac4:	e0bffc17 	ldw	r2,-16(fp)
 822eac8:	10c00217 	ldw	r3,8(r2)
 822eacc:	e0bfff17 	ldw	r2,-4(fp)
 822ead0:	18800736 	bltu	r3,r2,822eaf0 <m_adj+0x124>
      {
         m->m_len -= len;
 822ead4:	e0bffc17 	ldw	r2,-16(fp)
 822ead8:	10c00217 	ldw	r3,8(r2)
 822eadc:	e0bfff17 	ldw	r2,-4(fp)
 822eae0:	1887c83a 	sub	r3,r3,r2
 822eae4:	e0bffc17 	ldw	r2,-16(fp)
 822eae8:	10c00215 	stw	r3,8(r2)
         return;
 822eaec:	00002306 	br	822eb7c <m_adj+0x1b0>
      }
      count -= len;
 822eaf0:	e0fffd17 	ldw	r3,-12(fp)
 822eaf4:	e0bfff17 	ldw	r2,-4(fp)
 822eaf8:	1885c83a 	sub	r2,r3,r2
 822eafc:	e0bffd15 	stw	r2,-12(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 822eb00:	e0bffe17 	ldw	r2,-8(fp)
 822eb04:	e0bffc15 	stw	r2,-16(fp)
 822eb08:	00001006 	br	822eb4c <m_adj+0x180>
      {
         if (m->m_len >= (unsigned)count)
 822eb0c:	e0bffc17 	ldw	r2,-16(fp)
 822eb10:	10c00217 	ldw	r3,8(r2)
 822eb14:	e0bffd17 	ldw	r2,-12(fp)
 822eb18:	18800436 	bltu	r3,r2,822eb2c <m_adj+0x160>
         {
            m->m_len = count;
 822eb1c:	e0fffd17 	ldw	r3,-12(fp)
 822eb20:	e0bffc17 	ldw	r2,-16(fp)
 822eb24:	10c00215 	stw	r3,8(r2)
            break;
 822eb28:	00000a06 	br	822eb54 <m_adj+0x188>
         }
         count -= m->m_len;
 822eb2c:	e0fffd17 	ldw	r3,-12(fp)
 822eb30:	e0bffc17 	ldw	r2,-16(fp)
 822eb34:	10800217 	ldw	r2,8(r2)
 822eb38:	1885c83a 	sub	r2,r3,r2
 822eb3c:	e0bffd15 	stw	r2,-12(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 822eb40:	e0bffc17 	ldw	r2,-16(fp)
 822eb44:	10800617 	ldw	r2,24(r2)
 822eb48:	e0bffc15 	stw	r2,-16(fp)
 822eb4c:	e0bffc17 	ldw	r2,-16(fp)
 822eb50:	103fee1e 	bne	r2,zero,822eb0c <m_adj+0x140>
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 822eb54:	00000206 	br	822eb60 <m_adj+0x194>
         m->m_len = 0;
 822eb58:	e0bffc17 	ldw	r2,-16(fp)
 822eb5c:	10000215 	stw	zero,8(r2)
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 822eb60:	e0bffc17 	ldw	r2,-16(fp)
 822eb64:	10800617 	ldw	r2,24(r2)
 822eb68:	e0bffc15 	stw	r2,-16(fp)
 822eb6c:	e0bffc17 	ldw	r2,-16(fp)
 822eb70:	103ff91e 	bne	r2,zero,822eb58 <m_adj+0x18c>
 822eb74:	00000106 	br	822eb7c <m_adj+0x1b0>
{
   struct mbuf *  m;
   int   count;

   if ((m = mp) == NULL)
      return;
 822eb78:	0001883a 	nop
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
         m->m_len = 0;
   }
}
 822eb7c:	e037883a 	mov	sp,fp
 822eb80:	df000017 	ldw	fp,0(sp)
 822eb84:	dec00104 	addi	sp,sp,4
 822eb88:	f800283a 	ret

0822eb8c <mbuf_len>:
 * RETURNS: 
 */

int
mbuf_len (struct mbuf * m)
{
 822eb8c:	defffd04 	addi	sp,sp,-12
 822eb90:	df000215 	stw	fp,8(sp)
 822eb94:	df000204 	addi	fp,sp,8
 822eb98:	e13fff15 	stw	r4,-4(fp)
   int   len   =  0;
 822eb9c:	e03ffe15 	stw	zero,-8(fp)

   while (m)
 822eba0:	00000806 	br	822ebc4 <mbuf_len+0x38>
   {
      len += m->m_len;
 822eba4:	e0bfff17 	ldw	r2,-4(fp)
 822eba8:	10c00217 	ldw	r3,8(r2)
 822ebac:	e0bffe17 	ldw	r2,-8(fp)
 822ebb0:	1885883a 	add	r2,r3,r2
 822ebb4:	e0bffe15 	stw	r2,-8(fp)
      m = m->m_next;
 822ebb8:	e0bfff17 	ldw	r2,-4(fp)
 822ebbc:	10800617 	ldw	r2,24(r2)
 822ebc0:	e0bfff15 	stw	r2,-4(fp)
int
mbuf_len (struct mbuf * m)
{
   int   len   =  0;

   while (m)
 822ebc4:	e0bfff17 	ldw	r2,-4(fp)
 822ebc8:	103ff61e 	bne	r2,zero,822eba4 <mbuf_len+0x18>
   {
      len += m->m_len;
      m = m->m_next;
   }
   return len;
 822ebcc:	e0bffe17 	ldw	r2,-8(fp)
}
 822ebd0:	e037883a 	mov	sp,fp
 822ebd4:	df000017 	ldw	fp,0(sp)
 822ebd8:	dec00104 	addi	sp,sp,4
 822ebdc:	f800283a 	ret

0822ebe0 <dtom>:
 * RETURNS: 
 */

struct mbuf *  
dtom(void * data)
{
 822ebe0:	defffb04 	addi	sp,sp,-20
 822ebe4:	dfc00415 	stw	ra,16(sp)
 822ebe8:	df000315 	stw	fp,12(sp)
 822ebec:	df000304 	addi	fp,sp,12
 822ebf0:	e13fff15 	stw	r4,-4(fp)
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 822ebf4:	008209b4 	movhi	r2,2086
 822ebf8:	10b98e04 	addi	r2,r2,-6600
 822ebfc:	10800017 	ldw	r2,0(r2)
 822ec00:	e0bffd15 	stw	r2,-12(fp)
 822ec04:	00001206 	br	822ec50 <dtom+0x70>
   {
      m = (struct mbuf *)qptr;
 822ec08:	e0bffd17 	ldw	r2,-12(fp)
 822ec0c:	e0bffe15 	stw	r2,-8(fp)

      if (IN_RANGE(m->m_base, m->m_memsz, (char*)data))
 822ec10:	e0bffe17 	ldw	r2,-8(fp)
 822ec14:	10800417 	ldw	r2,16(r2)
 822ec18:	e0ffff17 	ldw	r3,-4(fp)
 822ec1c:	18800936 	bltu	r3,r2,822ec44 <dtom+0x64>
 822ec20:	e0bffe17 	ldw	r2,-8(fp)
 822ec24:	10c00417 	ldw	r3,16(r2)
 822ec28:	e0bffe17 	ldw	r2,-8(fp)
 822ec2c:	10800517 	ldw	r2,20(r2)
 822ec30:	1885883a 	add	r2,r3,r2
 822ec34:	e0ffff17 	ldw	r3,-4(fp)
 822ec38:	1880022e 	bgeu	r3,r2,822ec44 <dtom+0x64>
         return (struct mbuf *)qptr;
 822ec3c:	e0bffd17 	ldw	r2,-12(fp)
 822ec40:	00000906 	br	822ec68 <dtom+0x88>
dtom(void * data)
{
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 822ec44:	e0bffd17 	ldw	r2,-12(fp)
 822ec48:	10800017 	ldw	r2,0(r2)
 822ec4c:	e0bffd15 	stw	r2,-12(fp)
 822ec50:	e0bffd17 	ldw	r2,-12(fp)
 822ec54:	103fec1e 	bne	r2,zero,822ec08 <dtom+0x28>
      else
         continue;

   }

   panic("dtom");    /* data not found in any "in use" mbuf */
 822ec58:	01020974 	movhi	r4,2085
 822ec5c:	21038204 	addi	r4,r4,3592
 822ec60:	8228ca40 	call	8228ca4 <panic>
   return NULL;
 822ec64:	0005883a 	mov	r2,zero
}
 822ec68:	e037883a 	mov	sp,fp
 822ec6c:	dfc00117 	ldw	ra,4(sp)
 822ec70:	df000017 	ldw	fp,0(sp)
 822ec74:	dec00204 	addi	sp,sp,8
 822ec78:	f800283a 	ret

0822ec7c <remque>:
};


void
remque (void * arg)
{
 822ec7c:	defffd04 	addi	sp,sp,-12
 822ec80:	df000215 	stw	fp,8(sp)
 822ec84:	df000204 	addi	fp,sp,8
 822ec88:	e13fff15 	stw	r4,-4(fp)
   struct bsdq *  old;

   old = (struct bsdq *)arg;
 822ec8c:	e0bfff17 	ldw	r2,-4(fp)
 822ec90:	e0bffe15 	stw	r2,-8(fp)
   if (!old->prev) return;
 822ec94:	e0bffe17 	ldw	r2,-8(fp)
 822ec98:	10800117 	ldw	r2,4(r2)
 822ec9c:	10000e26 	beq	r2,zero,822ecd8 <remque+0x5c>
      old->prev->next = old->next;
 822eca0:	e0bffe17 	ldw	r2,-8(fp)
 822eca4:	10800117 	ldw	r2,4(r2)
 822eca8:	e0fffe17 	ldw	r3,-8(fp)
 822ecac:	18c00017 	ldw	r3,0(r3)
 822ecb0:	10c00015 	stw	r3,0(r2)
   if (old->next)
 822ecb4:	e0bffe17 	ldw	r2,-8(fp)
 822ecb8:	10800017 	ldw	r2,0(r2)
 822ecbc:	10000726 	beq	r2,zero,822ecdc <remque+0x60>
      old->next->prev = old->prev;
 822ecc0:	e0bffe17 	ldw	r2,-8(fp)
 822ecc4:	10800017 	ldw	r2,0(r2)
 822ecc8:	e0fffe17 	ldw	r3,-8(fp)
 822eccc:	18c00117 	ldw	r3,4(r3)
 822ecd0:	10c00115 	stw	r3,4(r2)
 822ecd4:	00000106 	br	822ecdc <remque+0x60>
remque (void * arg)
{
   struct bsdq *  old;

   old = (struct bsdq *)arg;
   if (!old->prev) return;
 822ecd8:	0001883a 	nop
      old->prev->next = old->next;
   if (old->next)
      old->next->prev = old->prev;
}
 822ecdc:	e037883a 	mov	sp,fp
 822ece0:	df000017 	ldw	fp,0(sp)
 822ece4:	dec00104 	addi	sp,sp,4
 822ece8:	f800283a 	ret

0822ecec <insque>:
 * RETURNS: 
 */

void
insque(void * n, void * p)
{
 822ecec:	defffb04 	addi	sp,sp,-20
 822ecf0:	df000415 	stw	fp,16(sp)
 822ecf4:	df000404 	addi	fp,sp,16
 822ecf8:	e13ffe15 	stw	r4,-8(fp)
 822ecfc:	e17fff15 	stw	r5,-4(fp)
   struct bsdq *  newe, *  prev;

   newe = (struct bsdq *)n;
 822ed00:	e0bffe17 	ldw	r2,-8(fp)
 822ed04:	e0bffc15 	stw	r2,-16(fp)
   prev = (struct bsdq *)p;
 822ed08:	e0bfff17 	ldw	r2,-4(fp)
 822ed0c:	e0bffd15 	stw	r2,-12(fp)
   newe->next = prev->next;
 822ed10:	e0bffd17 	ldw	r2,-12(fp)
 822ed14:	10c00017 	ldw	r3,0(r2)
 822ed18:	e0bffc17 	ldw	r2,-16(fp)
 822ed1c:	10c00015 	stw	r3,0(r2)
   newe->prev = prev;
 822ed20:	e0bffc17 	ldw	r2,-16(fp)
 822ed24:	e0fffd17 	ldw	r3,-12(fp)
 822ed28:	10c00115 	stw	r3,4(r2)
   prev->next = newe;
 822ed2c:	e0bffd17 	ldw	r2,-12(fp)
 822ed30:	e0fffc17 	ldw	r3,-16(fp)
 822ed34:	10c00015 	stw	r3,0(r2)
   if (newe->next)
 822ed38:	e0bffc17 	ldw	r2,-16(fp)
 822ed3c:	10800017 	ldw	r2,0(r2)
 822ed40:	10000426 	beq	r2,zero,822ed54 <insque+0x68>
      newe->next->prev = newe;
 822ed44:	e0bffc17 	ldw	r2,-16(fp)
 822ed48:	10800017 	ldw	r2,0(r2)
 822ed4c:	e0fffc17 	ldw	r3,-16(fp)
 822ed50:	10c00115 	stw	r3,4(r2)
}
 822ed54:	0001883a 	nop
 822ed58:	e037883a 	mov	sp,fp
 822ed5c:	df000017 	ldw	fp,0(sp)
 822ed60:	dec00104 	addi	sp,sp,4
 822ed64:	f800283a 	ret

0822ed68 <nptcp_init>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
nptcp_init()
{
 822ed68:	defffb04 	addi	sp,sp,-20
 822ed6c:	dfc00415 	stw	ra,16(sp)
 822ed70:	df000315 	stw	fp,12(sp)
 822ed74:	df000304 	addi	fp,sp,12
    * buffers, soreceive() can't complete and the packet buffers stay 
    * on the queue, so we allocate 3 extra mbufs in the hope that 
    * this will allow soreceive() to complete and free up the packet 
    * buffers. yes, its kind of an ugly hack and 3 is a wild guess.
    */
   unsigned bufcount = (lilbufs + bigbufs) * 2 + 3;
 822ed78:	d0e03617 	ldw	r3,-32552(gp)
 822ed7c:	d0a03817 	ldw	r2,-32544(gp)
 822ed80:	1885883a 	add	r2,r3,r2
 822ed84:	1085883a 	add	r2,r2,r2
 822ed88:	108000c4 	addi	r2,r2,3
 822ed8c:	e0bffe15 	stw	r2,-8(fp)
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
 822ed90:	01800504 	movi	r6,20
 822ed94:	000b883a 	mov	r5,zero
 822ed98:	010209b4 	movhi	r4,2086
 822ed9c:	21397a04 	addi	r4,r4,-6680
 822eda0:	82032100 	call	8203210 <memset>
   MEMSET(&mbufq, 0, sizeof(mbufq));
 822eda4:	01800504 	movi	r6,20
 822eda8:	000b883a 	mov	r5,zero
 822edac:	010209b4 	movhi	r4,2086
 822edb0:	21398e04 	addi	r4,r4,-6600
 822edb4:	82032100 	call	8203210 <memset>
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
 822edb8:	01800504 	movi	r6,20
 822edbc:	000b883a 	mov	r5,zero
 822edc0:	010209b4 	movhi	r4,2086
 822edc4:	21399304 	addi	r4,r4,-6580
 822edc8:	82032100 	call	8203210 <memset>
   for (i = 0; i < (int)bufcount; i++)
 822edcc:	e03ffd15 	stw	zero,-12(fp)
 822edd0:	00001506 	br	822ee28 <nptcp_init+0xc0>
   {
      m = MBU_ALLOC(sizeof(struct mbuf));
 822edd4:	01000904 	movi	r4,36
 822edd8:	822e1c80 	call	822e1c8 <npalloc>
 822eddc:	e0bfff15 	stw	r2,-4(fp)
      if (!m)  /* malloc error, bail out */
 822ede0:	e0bfff17 	ldw	r2,-4(fp)
 822ede4:	1000031e 	bne	r2,zero,822edf4 <nptcp_init+0x8c>
         panic("tcpinit");
 822ede8:	01020974 	movhi	r4,2085
 822edec:	21038404 	addi	r4,r4,3600
 822edf0:	8228ca40 	call	8228ca4 <panic>
      m->m_type = MT_FREE;
 822edf4:	e0bfff17 	ldw	r2,-4(fp)
 822edf8:	10000815 	stw	zero,32(r2)
      m->m_len = 0;
 822edfc:	e0bfff17 	ldw	r2,-4(fp)
 822ee00:	10000215 	stw	zero,8(r2)
      m->m_data = NULL;
 822ee04:	e0bfff17 	ldw	r2,-4(fp)
 822ee08:	10000315 	stw	zero,12(r2)
      putq(&mfreeq, (qp)m);
 822ee0c:	e17fff17 	ldw	r5,-4(fp)
 822ee10:	010209b4 	movhi	r4,2086
 822ee14:	21399304 	addi	r4,r4,-6580
 822ee18:	822cfd80 	call	822cfd8 <putq>
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
   MEMSET(&mbufq, 0, sizeof(mbufq));
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
   for (i = 0; i < (int)bufcount; i++)
 822ee1c:	e0bffd17 	ldw	r2,-12(fp)
 822ee20:	10800044 	addi	r2,r2,1
 822ee24:	e0bffd15 	stw	r2,-12(fp)
 822ee28:	e0bffe17 	ldw	r2,-8(fp)
 822ee2c:	e0fffd17 	ldw	r3,-12(fp)
 822ee30:	18bfe816 	blt	r3,r2,822edd4 <nptcp_init+0x6c>
      m->m_type = MT_FREE;
      m->m_len = 0;
      m->m_data = NULL;
      putq(&mfreeq, (qp)m);
   }
   mfreeq.q_min = (int)bufcount;   /* this should match q_max and q_len */
 822ee34:	e0fffe17 	ldw	r3,-8(fp)
 822ee38:	008209b4 	movhi	r2,2086
 822ee3c:	10b99304 	addi	r2,r2,-6580
 822ee40:	10c00415 	stw	r3,16(r2)
   tcpmib.tcpRtoAlgorithm = 4;     /* Van Jacobson's algorithm */
   tcpmib.tcpRtoMin = TCPTV_MIN * 1000;      /* PR_SLOWHZ */
   tcpmib.tcpRtoMax = TCPTV_REXMTMAX * 1000; /* PR_SLOWHZ */
#endif

   tcp_init();    /* call the BSD init in tcp_usr.c */
 822ee44:	82395280 	call	8239528 <tcp_init>

#ifdef TCP_MENUS
   install_menu(&tcpmenu[0]);
#endif   /* IN_MENUS */

   return 0;   /* good return */
 822ee48:	0005883a 	mov	r2,zero
}
 822ee4c:	e037883a 	mov	sp,fp
 822ee50:	dfc00117 	ldw	ra,4(sp)
 822ee54:	df000017 	ldw	fp,0(sp)
 822ee58:	dec00204 	addi	sp,sp,8
 822ee5c:	f800283a 	ret

0822ee60 <tcp_rcv>:

#ifdef IP_V4
 
int
tcp_rcv(PACKET pkt)     /* NOTE: pkt has nb_prot pointing to IP header */
{
 822ee60:	defff904 	addi	sp,sp,-28
 822ee64:	dfc00615 	stw	ra,24(sp)
 822ee68:	df000515 	stw	fp,20(sp)
 822ee6c:	df000504 	addi	fp,sp,20
 822ee70:	e13fff15 	stw	r4,-4(fp)

   /* For TCP, the netport IP layer is modified to set nb_prot to the 
    * start of the IP header (not TCP). We need to do some further
    * mods which the BSD code expects:
    */
   bip = (struct ip *)pkt->nb_prot;    /* get ip header */
 822ee74:	e0bfff17 	ldw	r2,-4(fp)
 822ee78:	10800317 	ldw	r2,12(r2)
 822ee7c:	e0bffb15 	stw	r2,-20(fp)
   len = ntohs(bip->ip_len);  /* get length in local endian */
 822ee80:	e0bffb17 	ldw	r2,-20(fp)
 822ee84:	1080008b 	ldhu	r2,2(r2)
 822ee88:	10bfffcc 	andi	r2,r2,65535
 822ee8c:	1004d23a 	srli	r2,r2,8
 822ee90:	1007883a 	mov	r3,r2
 822ee94:	e0bffb17 	ldw	r2,-20(fp)
 822ee98:	1080008b 	ldhu	r2,2(r2)
 822ee9c:	10bfffcc 	andi	r2,r2,65535
 822eea0:	1004923a 	slli	r2,r2,8
 822eea4:	1884b03a 	or	r2,r3,r2
 822eea8:	e0bffc0d 	sth	r2,-16(fp)

   /* verify checksum of received packet */

   tcpp = (struct tcphdr *)ip_data(bip);
 822eeac:	e0bffb17 	ldw	r2,-20(fp)
 822eeb0:	10800003 	ldbu	r2,0(r2)
 822eeb4:	10803fcc 	andi	r2,r2,255
 822eeb8:	108003cc 	andi	r2,r2,15
 822eebc:	1085883a 	add	r2,r2,r2
 822eec0:	1085883a 	add	r2,r2,r2
 822eec4:	1007883a 	mov	r3,r2
 822eec8:	e0bffb17 	ldw	r2,-20(fp)
 822eecc:	10c5883a 	add	r2,r2,r3
 822eed0:	e0bffd15 	stw	r2,-12(fp)
   if (tcp_cksum(bip) != tcpp->th_sum)
 822eed4:	e13ffb17 	ldw	r4,-20(fp)
 822eed8:	8247cf40 	call	8247cf4 <tcp_cksum>
 822eedc:	1007883a 	mov	r3,r2
 822eee0:	e0bffd17 	ldw	r2,-12(fp)
 822eee4:	1080040b 	ldhu	r2,16(r2)
 822eee8:	18ffffcc 	andi	r3,r3,65535
 822eeec:	10bfffcc 	andi	r2,r2,65535
 822eef0:	18801626 	beq	r3,r2,822ef4c <tcp_rcv+0xec>
   {
      TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 822eef4:	008209b4 	movhi	r2,2086
 822eef8:	10b97f04 	addi	r2,r2,-6660
 822eefc:	10800d17 	ldw	r2,52(r2)
 822ef00:	10c00044 	addi	r3,r2,1
 822ef04:	008209b4 	movhi	r2,2086
 822ef08:	10b97f04 	addi	r2,r2,-6660
 822ef0c:	10c00d15 	stw	r3,52(r2)
      tcpstat.tcps_rcvbadsum++;  /* keep BSD stats */
 822ef10:	008209b4 	movhi	r2,2086
 822ef14:	10b9ad04 	addi	r2,r2,-6476
 822ef18:	10801c17 	ldw	r2,112(r2)
 822ef1c:	10c00044 	addi	r3,r2,1
 822ef20:	008209b4 	movhi	r2,2086
 822ef24:	10b9ad04 	addi	r2,r2,-6476
 822ef28:	10c01c15 	stw	r3,112(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 822ef2c:	01000084 	movi	r4,2
 822ef30:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free(pkt);  /* punt packet */
 822ef34:	e13fff17 	ldw	r4,-4(fp)
 822ef38:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822ef3c:	01000084 	movi	r4,2
 822ef40:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 822ef44:	00bff804 	movi	r2,-32
 822ef48:	00003406 	br	822f01c <tcp_rcv+0x1bc>
   }

   m_in = m_getnbuf(MT_RXDATA, 0);
 822ef4c:	000b883a 	mov	r5,zero
 822ef50:	01000044 	movi	r4,1
 822ef54:	822e4040 	call	822e404 <m_getnbuf>
 822ef58:	e0bffe15 	stw	r2,-8(fp)
   if (!m_in){
 822ef5c:	e0bffe17 	ldw	r2,-8(fp)
 822ef60:	1000081e 	bne	r2,zero,822ef84 <tcp_rcv+0x124>
      LOCK_NET_RESOURCE(FREEQ_RESID);
 822ef64:	01000084 	movi	r4,2
 822ef68:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free(pkt);
 822ef6c:	e13fff17 	ldw	r4,-4(fp)
 822ef70:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822ef74:	01000084 	movi	r4,2
 822ef78:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;  
 822ef7c:	00bffa84 	movi	r2,-22
 822ef80:	00002606 	br	822f01c <tcp_rcv+0x1bc>
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);      /* measure time in TCP */

   /* subtract IP header length from total IP packet length */
   len -= ((unshort)(bip->ip_ver_ihl & 0x0f) << 2);
 822ef84:	e0bffb17 	ldw	r2,-20(fp)
 822ef88:	10800003 	ldbu	r2,0(r2)
 822ef8c:	10803fcc 	andi	r2,r2,255
 822ef90:	108003cc 	andi	r2,r2,15
 822ef94:	1085883a 	add	r2,r2,r2
 822ef98:	1085883a 	add	r2,r2,r2
 822ef9c:	1007883a 	mov	r3,r2
 822efa0:	e0bffc0b 	ldhu	r2,-16(fp)
 822efa4:	10c5c83a 	sub	r2,r2,r3
 822efa8:	e0bffc0d 	sth	r2,-16(fp)
   bip->ip_len = len;   /* put TCP length in struct for TCP code to use */
 822efac:	e0bffb17 	ldw	r2,-20(fp)
 822efb0:	e0fffc0b 	ldhu	r3,-16(fp)
 822efb4:	10c0008d 	sth	r3,2(r2)

   /* set mbuf to point to start of IP header (not TCP) */
   m_in->pkt = pkt;
 822efb8:	e0bffe17 	ldw	r2,-8(fp)
 822efbc:	e0ffff17 	ldw	r3,-4(fp)
 822efc0:	10c00115 	stw	r3,4(r2)
   m_in->m_data = pkt->nb_prot;
 822efc4:	e0bfff17 	ldw	r2,-4(fp)
 822efc8:	10c00317 	ldw	r3,12(r2)
 822efcc:	e0bffe17 	ldw	r2,-8(fp)
 822efd0:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 822efd4:	e0bfff17 	ldw	r2,-4(fp)
 822efd8:	10c00417 	ldw	r3,16(r2)
 822efdc:	e0bffe17 	ldw	r2,-8(fp)
 822efe0:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;     /* ??? */
 822efe4:	e0bfff17 	ldw	r2,-4(fp)
 822efe8:	10c00117 	ldw	r3,4(r2)
 822efec:	e0bffe17 	ldw	r2,-8(fp)
 822eff0:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;    /* ??? */
 822eff4:	e0bfff17 	ldw	r2,-4(fp)
 822eff8:	10c00217 	ldw	r3,8(r2)
 822effc:	e0bffe17 	ldw	r2,-8(fp)
 822f000:	10c00515 	stw	r3,20(r2)

   tcp_input(m_in, pkt->net);
 822f004:	e0bfff17 	ldw	r2,-4(fp)
 822f008:	10800617 	ldw	r2,24(r2)
 822f00c:	100b883a 	mov	r5,r2
 822f010:	e13ffe17 	ldw	r4,-8(fp)
 822f014:	82359dc0 	call	82359dc <tcp_input>

   IN_PROFILER(PF_TCP, PF_EXIT);      /* measure time in TCP */

   return 0;
 822f018:	0005883a 	mov	r2,zero
}
 822f01c:	e037883a 	mov	sp,fp
 822f020:	dfc00117 	ldw	ra,4(sp)
 822f024:	df000017 	ldw	fp,0(sp)
 822f028:	dec00204 	addi	sp,sp,8
 822f02c:	f800283a 	ret

0822f030 <ip_output>:
 * RETURNS: 
 */

int
ip_output(struct mbuf * data, struct   ip_socopts * so_optsPack) /* mbuf chain with data to send */
{
 822f030:	defff404 	addi	sp,sp,-48
 822f034:	dfc00b15 	stw	ra,44(sp)
 822f038:	df000a15 	stw	fp,40(sp)
 822f03c:	df000a04 	addi	fp,sp,40
 822f040:	e13ffe15 	stw	r4,-8(fp)
 822f044:	e17fff15 	stw	r5,-4(fp)
    * little copying as possible. Typically the mbufs will be either 
    * 1) a single mbuf with iptcp header info only (e.g.tcp ACK 
    * packet), or 2) iptcp header with data mbuf chained to it, or 3) 
    * #2) with a tiny option data mbuf between header and data. 
    */
   if ((data->m_next))
 822f048:	e0bffe17 	ldw	r2,-8(fp)
 822f04c:	10800617 	ldw	r2,24(r2)
 822f050:	10010a26 	beq	r2,zero,822f47c <ip_output+0x44c>
   {
      m1 = data;
 822f054:	e0bffe17 	ldw	r2,-8(fp)
 822f058:	e0bff615 	stw	r2,-40(fp)
      m2 = data->m_next;
 822f05c:	e0bffe17 	ldw	r2,-8(fp)
 822f060:	10800617 	ldw	r2,24(r2)
 822f064:	e0bff715 	stw	r2,-36(fp)

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 822f068:	00003506 	br	822f140 <ip_output+0x110>
      {
         pkt = m1->pkt;
 822f06c:	e0bff617 	ldw	r2,-40(fp)
 822f070:	10800117 	ldw	r2,4(r2)
 822f074:	e0bffa15 	stw	r2,-24(fp)
         if ((pkt->nb_buff + pkt->nb_blen) > /* make sure m2 will fit in m1 */
 822f078:	e0bffa17 	ldw	r2,-24(fp)
 822f07c:	10c00117 	ldw	r3,4(r2)
 822f080:	e0bffa17 	ldw	r2,-24(fp)
 822f084:	10800217 	ldw	r2,8(r2)
 822f088:	1885883a 	add	r2,r3,r2
             (m1->m_data + m1->m_len + m2->m_len))
 822f08c:	e0fff617 	ldw	r3,-40(fp)
 822f090:	19000317 	ldw	r4,12(r3)
 822f094:	e0fff617 	ldw	r3,-40(fp)
 822f098:	19400217 	ldw	r5,8(r3)
 822f09c:	e0fff717 	ldw	r3,-36(fp)
 822f0a0:	18c00217 	ldw	r3,8(r3)
 822f0a4:	28c7883a 	add	r3,r5,r3
 822f0a8:	20c7883a 	add	r3,r4,r3

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
      {
         pkt = m1->pkt;
         if ((pkt->nb_buff + pkt->nb_blen) > /* make sure m2 will fit in m1 */
 822f0ac:	18802b2e 	bgeu	r3,r2,822f15c <ip_output+0x12c>
             (m1->m_data + m1->m_len + m2->m_len))
         {
            MEMCPY((m1->m_data + m1->m_len), m2->m_data, m2->m_len);
 822f0b0:	e0bff617 	ldw	r2,-40(fp)
 822f0b4:	10c00317 	ldw	r3,12(r2)
 822f0b8:	e0bff617 	ldw	r2,-40(fp)
 822f0bc:	10800217 	ldw	r2,8(r2)
 822f0c0:	1887883a 	add	r3,r3,r2
 822f0c4:	e0bff717 	ldw	r2,-36(fp)
 822f0c8:	11000317 	ldw	r4,12(r2)
 822f0cc:	e0bff717 	ldw	r2,-36(fp)
 822f0d0:	10800217 	ldw	r2,8(r2)
 822f0d4:	100d883a 	mov	r6,r2
 822f0d8:	200b883a 	mov	r5,r4
 822f0dc:	1809883a 	mov	r4,r3
 822f0e0:	8202f6c0 	call	8202f6c <memcpy>
            m1->m_len += m2->m_len;
 822f0e4:	e0bff617 	ldw	r2,-40(fp)
 822f0e8:	10c00217 	ldw	r3,8(r2)
 822f0ec:	e0bff717 	ldw	r2,-36(fp)
 822f0f0:	10800217 	ldw	r2,8(r2)
 822f0f4:	1887883a 	add	r3,r3,r2
 822f0f8:	e0bff617 	ldw	r2,-40(fp)
 822f0fc:	10c00215 	stw	r3,8(r2)
            m1->m_next = m2->m_next;
 822f100:	e0bff717 	ldw	r2,-36(fp)
 822f104:	10c00617 	ldw	r3,24(r2)
 822f108:	e0bff617 	ldw	r2,-40(fp)
 822f10c:	10c00615 	stw	r3,24(r2)
            m_free(m2);    /* free this m2.... */
 822f110:	e13ff717 	ldw	r4,-36(fp)
 822f114:	822e58c0 	call	822e58c <m_free>
            m2 = m1->m_next;  /* ...and thread the next one */
 822f118:	e0bff617 	ldw	r2,-40(fp)
 822f11c:	10800617 	ldw	r2,24(r2)
 822f120:	e0bff715 	stw	r2,-36(fp)
            tcpstat.tcps_oappends++;
 822f124:	008209b4 	movhi	r2,2086
 822f128:	10b9ad04 	addi	r2,r2,-6476
 822f12c:	10803317 	ldw	r2,204(r2)
 822f130:	10c00044 	addi	r3,r2,1
 822f134:	008209b4 	movhi	r2,2086
 822f138:	10b9ad04 	addi	r2,r2,-6476
 822f13c:	10c03315 	stw	r3,204(r2)
   {
      m1 = data;
      m2 = data->m_next;

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 822f140:	e0bff717 	ldw	r2,-36(fp)
 822f144:	10005b26 	beq	r2,zero,822f2b4 <ip_output+0x284>
 822f148:	e0bff717 	ldw	r2,-36(fp)
 822f14c:	10800217 	ldw	r2,8(r2)
 822f150:	108002b0 	cmpltui	r2,r2,10
 822f154:	103fc51e 	bne	r2,zero,822f06c <ip_output+0x3c>
 822f158:	00005606 	br	822f2b4 <ip_output+0x284>
            m_free(m2);    /* free this m2.... */
            m2 = m1->m_next;  /* ...and thread the next one */
            tcpstat.tcps_oappends++;
         }
         else     /* if won't fit, fall to next copy */
            break;
 822f15c:	0001883a 	nop
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 822f160:	00005406 	br	822f2b4 <ip_output+0x284>
      {
         /* try prepending m1 to m2, first see if it fits: */
         e = m2->m_data - m2->pkt->nb_buff;  /* e is prepend space */
 822f164:	e0bff717 	ldw	r2,-36(fp)
 822f168:	10800317 	ldw	r2,12(r2)
 822f16c:	1007883a 	mov	r3,r2
 822f170:	e0bff717 	ldw	r2,-36(fp)
 822f174:	10800117 	ldw	r2,4(r2)
 822f178:	10800117 	ldw	r2,4(r2)
 822f17c:	1885c83a 	sub	r2,r3,r2
 822f180:	e0bffb15 	stw	r2,-20(fp)
         if (e < MaxLnh)
 822f184:	d0a08117 	ldw	r2,-32252(gp)
 822f188:	e0fffb17 	ldw	r3,-20(fp)
 822f18c:	1880090e 	bge	r3,r2,822f1b4 <ip_output+0x184>
         { 
#ifdef NPDEBUG
            dprintf("nptcp: MaxLnh:%d, e:%d\n", MaxLnh, e);
 822f190:	d0a08117 	ldw	r2,-32252(gp)
 822f194:	e1bffb17 	ldw	r6,-20(fp)
 822f198:	100b883a 	mov	r5,r2
 822f19c:	01020974 	movhi	r4,2085
 822f1a0:	21038604 	addi	r4,r4,3608
 822f1a4:	82033fc0 	call	82033fc <printf>
#endif
            panic("tcp_out:mbuf-nbuf");   /* sanity check */
 822f1a8:	01020974 	movhi	r4,2085
 822f1ac:	21038c04 	addi	r4,r4,3632
 822f1b0:	8228ca40 	call	8228ca4 <panic>
         }

         if ((m1->m_len < (unsigned)(e - MaxLnh))  /* leave room for MAC */
 822f1b4:	e0bff617 	ldw	r2,-40(fp)
 822f1b8:	10800217 	ldw	r2,8(r2)
 822f1bc:	d0e08117 	ldw	r3,-32252(gp)
 822f1c0:	e13ffb17 	ldw	r4,-20(fp)
 822f1c4:	20c7c83a 	sub	r3,r4,r3
 822f1c8:	10c03c2e 	bgeu	r2,r3,822f2bc <ip_output+0x28c>
             && ((m1->m_len & (ALIGN_TYPE - 1)) == 0)  /* and stay aligned */
 822f1cc:	e0bff617 	ldw	r2,-40(fp)
 822f1d0:	10800217 	ldw	r2,8(r2)
 822f1d4:	108000cc 	andi	r2,r2,3
 822f1d8:	1000381e 	bne	r2,zero,822f2bc <ip_output+0x28c>
             && ((m2->m_data - m2->pkt->nb_buff) == HDRSLEN))   /* be at start */
 822f1dc:	e0bff717 	ldw	r2,-36(fp)
 822f1e0:	10800317 	ldw	r2,12(r2)
 822f1e4:	1007883a 	mov	r3,r2
 822f1e8:	e0bff717 	ldw	r2,-36(fp)
 822f1ec:	10800117 	ldw	r2,4(r2)
 822f1f0:	10800117 	ldw	r2,4(r2)
 822f1f4:	1885c83a 	sub	r2,r3,r2
 822f1f8:	10800e18 	cmpnei	r2,r2,56
 822f1fc:	10002f1e 	bne	r2,zero,822f2bc <ip_output+0x28c>
         {
            MEMCPY((m2->m_data - m1->m_len), m1->m_data, m1->m_len);
 822f200:	e0bff717 	ldw	r2,-36(fp)
 822f204:	10c00317 	ldw	r3,12(r2)
 822f208:	e0bff617 	ldw	r2,-40(fp)
 822f20c:	10800217 	ldw	r2,8(r2)
 822f210:	0085c83a 	sub	r2,zero,r2
 822f214:	1887883a 	add	r3,r3,r2
 822f218:	e0bff617 	ldw	r2,-40(fp)
 822f21c:	11000317 	ldw	r4,12(r2)
 822f220:	e0bff617 	ldw	r2,-40(fp)
 822f224:	10800217 	ldw	r2,8(r2)
 822f228:	100d883a 	mov	r6,r2
 822f22c:	200b883a 	mov	r5,r4
 822f230:	1809883a 	mov	r4,r3
 822f234:	8202f6c0 	call	8202f6c <memcpy>
            m2->m_data -= m1->m_len;   /* fix target to reflect prepend */
 822f238:	e0bff717 	ldw	r2,-36(fp)
 822f23c:	10c00317 	ldw	r3,12(r2)
 822f240:	e0bff617 	ldw	r2,-40(fp)
 822f244:	10800217 	ldw	r2,8(r2)
 822f248:	0085c83a 	sub	r2,zero,r2
 822f24c:	1887883a 	add	r3,r3,r2
 822f250:	e0bff717 	ldw	r2,-36(fp)
 822f254:	10c00315 	stw	r3,12(r2)
            m2->m_len += m1->m_len;
 822f258:	e0bff717 	ldw	r2,-36(fp)
 822f25c:	10c00217 	ldw	r3,8(r2)
 822f260:	e0bff617 	ldw	r2,-40(fp)
 822f264:	10800217 	ldw	r2,8(r2)
 822f268:	1887883a 	add	r3,r3,r2
 822f26c:	e0bff717 	ldw	r2,-36(fp)
 822f270:	10c00215 	stw	r3,8(r2)
            m_free(m1);    /* free head (copied) mbuf */
 822f274:	e13ff617 	ldw	r4,-40(fp)
 822f278:	822e58c0 	call	822e58c <m_free>
            data = m1 = m2;   /* move other mbufs up the chain */
 822f27c:	e0bff717 	ldw	r2,-36(fp)
 822f280:	e0bff615 	stw	r2,-40(fp)
 822f284:	e0bff617 	ldw	r2,-40(fp)
 822f288:	e0bffe15 	stw	r2,-8(fp)
            m2 = m2->m_next;  /* loop to while(m2) test */
 822f28c:	e0bff717 	ldw	r2,-36(fp)
 822f290:	10800617 	ldw	r2,24(r2)
 822f294:	e0bff715 	stw	r2,-36(fp)
            tcpstat.tcps_oprepends++;
 822f298:	008209b4 	movhi	r2,2086
 822f29c:	10b9ad04 	addi	r2,r2,-6476
 822f2a0:	10803217 	ldw	r2,200(r2)
 822f2a4:	10c00044 	addi	r3,r2,1
 822f2a8:	008209b4 	movhi	r2,2086
 822f2ac:	10b9ad04 	addi	r2,r2,-6476
 822f2b0:	10c03215 	stw	r3,200(r2)
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 822f2b4:	e0bff717 	ldw	r2,-36(fp)
 822f2b8:	103faa1e 	bne	r2,zero,822f164 <ip_output+0x134>
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      if (m2)  /* If all else fails, brute force copy: */
 822f2bc:	e0bff717 	ldw	r2,-36(fp)
 822f2c0:	10006e26 	beq	r2,zero,822f47c <ip_output+0x44c>
      {
         total = 0;
 822f2c4:	e03ff915 	stw	zero,-28(fp)
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 822f2c8:	e0bff617 	ldw	r2,-40(fp)
 822f2cc:	e0bff815 	stw	r2,-32(fp)
 822f2d0:	00000806 	br	822f2f4 <ip_output+0x2c4>
            total += mtmp->m_len;
 822f2d4:	e0bff817 	ldw	r2,-32(fp)
 822f2d8:	10c00217 	ldw	r3,8(r2)
 822f2dc:	e0bff917 	ldw	r2,-28(fp)
 822f2e0:	1885883a 	add	r2,r3,r2
 822f2e4:	e0bff915 	stw	r2,-28(fp)
      }

      if (m2)  /* If all else fails, brute force copy: */
      {
         total = 0;
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 822f2e8:	e0bff817 	ldw	r2,-32(fp)
 822f2ec:	10800617 	ldw	r2,24(r2)
 822f2f0:	e0bff815 	stw	r2,-32(fp)
 822f2f4:	e0bff817 	ldw	r2,-32(fp)
 822f2f8:	103ff61e 	bne	r2,zero,822f2d4 <ip_output+0x2a4>
            total += mtmp->m_len;
         LOCK_NET_RESOURCE(FREEQ_RESID);
 822f2fc:	01000084 	movi	r4,2
 822f300:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
         pkt = pk_alloc(total + HDRSLEN);
 822f304:	e0bff917 	ldw	r2,-28(fp)
 822f308:	10800e04 	addi	r2,r2,56
 822f30c:	1009883a 	mov	r4,r2
 822f310:	822ca480 	call	822ca48 <pk_alloc>
 822f314:	e0bffa15 	stw	r2,-24(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822f318:	01000084 	movi	r4,2
 822f31c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         if (!pkt)
 822f320:	e0bffa17 	ldw	r2,-24(fp)
 822f324:	1000021e 	bne	r2,zero,822f330 <ip_output+0x300>
            return ENOBUFS;
 822f328:	00801a44 	movi	r2,105
 822f32c:	0000a706 	br	822f5cc <ip_output+0x59c>
         pkt->nb_prot = pkt->nb_buff + MaxLnh;
 822f330:	e0bffa17 	ldw	r2,-24(fp)
 822f334:	10800117 	ldw	r2,4(r2)
 822f338:	d0e08117 	ldw	r3,-32252(gp)
 822f33c:	10c7883a 	add	r3,r2,r3
 822f340:	e0bffa17 	ldw	r2,-24(fp)
 822f344:	10c00315 	stw	r3,12(r2)

         mtmp = m1;
 822f348:	e0bff617 	ldw	r2,-40(fp)
 822f34c:	e0bff815 	stw	r2,-32(fp)
         while (mtmp)
 822f350:	00002906 	br	822f3f8 <ip_output+0x3c8>
         {
            MEMCPY(pkt->nb_prot, mtmp->m_data, mtmp->m_len);
 822f354:	e0bffa17 	ldw	r2,-24(fp)
 822f358:	10c00317 	ldw	r3,12(r2)
 822f35c:	e0bff817 	ldw	r2,-32(fp)
 822f360:	11000317 	ldw	r4,12(r2)
 822f364:	e0bff817 	ldw	r2,-32(fp)
 822f368:	10800217 	ldw	r2,8(r2)
 822f36c:	100d883a 	mov	r6,r2
 822f370:	200b883a 	mov	r5,r4
 822f374:	1809883a 	mov	r4,r3
 822f378:	8202f6c0 	call	8202f6c <memcpy>
            pkt->nb_prot += mtmp->m_len;
 822f37c:	e0bffa17 	ldw	r2,-24(fp)
 822f380:	10c00317 	ldw	r3,12(r2)
 822f384:	e0bff817 	ldw	r2,-32(fp)
 822f388:	10800217 	ldw	r2,8(r2)
 822f38c:	1887883a 	add	r3,r3,r2
 822f390:	e0bffa17 	ldw	r2,-24(fp)
 822f394:	10c00315 	stw	r3,12(r2)
            pkt->nb_plen += mtmp->m_len;
 822f398:	e0bffa17 	ldw	r2,-24(fp)
 822f39c:	10c00417 	ldw	r3,16(r2)
 822f3a0:	e0bff817 	ldw	r2,-32(fp)
 822f3a4:	10800217 	ldw	r2,8(r2)
 822f3a8:	1887883a 	add	r3,r3,r2
 822f3ac:	e0bffa17 	ldw	r2,-24(fp)
 822f3b0:	10c00415 	stw	r3,16(r2)
            m2 = mtmp;
 822f3b4:	e0bff817 	ldw	r2,-32(fp)
 822f3b8:	e0bff715 	stw	r2,-36(fp)
            mtmp = mtmp->m_next;
 822f3bc:	e0bff817 	ldw	r2,-32(fp)
 822f3c0:	10800617 	ldw	r2,24(r2)
 822f3c4:	e0bff815 	stw	r2,-32(fp)
            if (m2 != data)   /* save original head */
 822f3c8:	e0fff717 	ldw	r3,-36(fp)
 822f3cc:	e0bffe17 	ldw	r2,-8(fp)
 822f3d0:	18800226 	beq	r3,r2,822f3dc <ip_output+0x3ac>
               m_free(m2);
 822f3d4:	e13ff717 	ldw	r4,-36(fp)
 822f3d8:	822e58c0 	call	822e58c <m_free>
            tcpstat.tcps_ocopies++;
 822f3dc:	008209b4 	movhi	r2,2086
 822f3e0:	10b9ad04 	addi	r2,r2,-6476
 822f3e4:	10803417 	ldw	r2,208(r2)
 822f3e8:	10c00044 	addi	r3,r2,1
 822f3ec:	008209b4 	movhi	r2,2086
 822f3f0:	10b9ad04 	addi	r2,r2,-6476
 822f3f4:	10c03415 	stw	r3,208(r2)
         if (!pkt)
            return ENOBUFS;
         pkt->nb_prot = pkt->nb_buff + MaxLnh;

         mtmp = m1;
         while (mtmp)
 822f3f8:	e0bff817 	ldw	r2,-32(fp)
 822f3fc:	103fd51e 	bne	r2,zero,822f354 <ip_output+0x324>
            mtmp = mtmp->m_next;
            if (m2 != data)   /* save original head */
               m_free(m2);
            tcpstat.tcps_ocopies++;
         }
         pkt->nb_prot -= total;     /* fix data pointer */
 822f400:	e0bffa17 	ldw	r2,-24(fp)
 822f404:	10c00317 	ldw	r3,12(r2)
 822f408:	e0bff917 	ldw	r2,-28(fp)
 822f40c:	0085c83a 	sub	r2,zero,r2
 822f410:	1887883a 	add	r3,r3,r2
 822f414:	e0bffa17 	ldw	r2,-24(fp)
 822f418:	10c00315 	stw	r3,12(r2)

         /* release the original mbufs packet install the new one */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 822f41c:	01000084 	movi	r4,2
 822f420:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
         pk_free(data->pkt);
 822f424:	e0bffe17 	ldw	r2,-8(fp)
 822f428:	10800117 	ldw	r2,4(r2)
 822f42c:	1009883a 	mov	r4,r2
 822f430:	822cd980 	call	822cd98 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822f434:	01000084 	movi	r4,2
 822f438:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         data->pkt = pkt;
 822f43c:	e0bffe17 	ldw	r2,-8(fp)
 822f440:	e0fffa17 	ldw	r3,-24(fp)
 822f444:	10c00115 	stw	r3,4(r2)
         data->m_len = pkt->nb_plen;
 822f448:	e0bffa17 	ldw	r2,-24(fp)
 822f44c:	10c00417 	ldw	r3,16(r2)
 822f450:	e0bffe17 	ldw	r2,-8(fp)
 822f454:	10c00215 	stw	r3,8(r2)
         data->m_next = NULL;
 822f458:	e0bffe17 	ldw	r2,-8(fp)
 822f45c:	10000615 	stw	zero,24(r2)
         data->m_data = pkt->nb_prot;
 822f460:	e0bffa17 	ldw	r2,-24(fp)
 822f464:	10c00317 	ldw	r3,12(r2)
 822f468:	e0bffe17 	ldw	r2,-8(fp)
 822f46c:	10c00315 	stw	r3,12(r2)
         data->m_len = total;
 822f470:	e0fff917 	ldw	r3,-28(fp)
 822f474:	e0bffe17 	ldw	r2,-8(fp)
 822f478:	10c00215 	stw	r3,8(r2)
      }
   }

   if ((data->m_data < (data->pkt->nb_buff + MaxLnh)))
 822f47c:	e0bffe17 	ldw	r2,-8(fp)
 822f480:	10c00317 	ldw	r3,12(r2)
 822f484:	e0bffe17 	ldw	r2,-8(fp)
 822f488:	10800117 	ldw	r2,4(r2)
 822f48c:	10800117 	ldw	r2,4(r2)
 822f490:	d1208117 	ldw	r4,-32252(gp)
 822f494:	1105883a 	add	r2,r2,r4
 822f498:	1880032e 	bgeu	r3,r2,822f4a8 <ip_output+0x478>
      panic("ip_output: overflow");
 822f49c:	01020974 	movhi	r4,2085
 822f4a0:	21039104 	addi	r4,r4,3652
 822f4a4:	8228ca40 	call	8228ca4 <panic>

   pkt = data->pkt;
 822f4a8:	e0bffe17 	ldw	r2,-8(fp)
 822f4ac:	10800117 	ldw	r2,4(r2)
 822f4b0:	e0bffa15 	stw	r2,-24(fp)

   /* do we have options? */
   if (so_optsPack)
 822f4b4:	e0bfff17 	ldw	r2,-4(fp)
 822f4b8:	10000326 	beq	r2,zero,822f4c8 <ip_output+0x498>
	   pkt->soxopts = so_optsPack;   /* yup */
 822f4bc:	e0bffa17 	ldw	r2,-24(fp)
 822f4c0:	e0ffff17 	ldw	r3,-4(fp)
 822f4c4:	10c00c15 	stw	r3,48(r2)
      panic("ip_output: no so_optsPack for the IPv6 scope");     
   }
#endif

   /* fill in dest host for IP layer */
   bip = (struct ip *)data->m_data;
 822f4c8:	e0bffe17 	ldw	r2,-8(fp)
 822f4cc:	10800317 	ldw	r2,12(r2)
 822f4d0:	e0bffc15 	stw	r2,-16(fp)
   pkt->fhost = bip->ip_dest;
 822f4d4:	e0bffc17 	ldw	r2,-16(fp)
 822f4d8:	10c00417 	ldw	r3,16(r2)
 822f4dc:	e0bffa17 	ldw	r2,-24(fp)
 822f4e0:	10c00715 	stw	r3,28(r2)

   /* make enough IP header for cksum calculation */
   bip->ip_ver_ihl = 0x45;
 822f4e4:	e0bffc17 	ldw	r2,-16(fp)
 822f4e8:	00c01144 	movi	r3,69
 822f4ec:	10c00005 	stb	r3,0(r2)
   bip->ip_len = htons(bip->ip_len);   /* make net endian for calculation */
 822f4f0:	e0bffc17 	ldw	r2,-16(fp)
 822f4f4:	1080008b 	ldhu	r2,2(r2)
 822f4f8:	10bfffcc 	andi	r2,r2,65535
 822f4fc:	1004d23a 	srli	r2,r2,8
 822f500:	1007883a 	mov	r3,r2
 822f504:	e0bffc17 	ldw	r2,-16(fp)
 822f508:	1080008b 	ldhu	r2,2(r2)
 822f50c:	10bfffcc 	andi	r2,r2,65535
 822f510:	1004923a 	slli	r2,r2,8
 822f514:	1884b03a 	or	r2,r3,r2
 822f518:	1007883a 	mov	r3,r2
 822f51c:	e0bffc17 	ldw	r2,-16(fp)
 822f520:	10c0008d 	sth	r3,2(r2)
   tcpp = (struct tcphdr *)ip_data(bip);
 822f524:	e0bffc17 	ldw	r2,-16(fp)
 822f528:	10800003 	ldbu	r2,0(r2)
 822f52c:	10803fcc 	andi	r2,r2,255
 822f530:	108003cc 	andi	r2,r2,15
 822f534:	1085883a 	add	r2,r2,r2
 822f538:	1085883a 	add	r2,r2,r2
 822f53c:	1007883a 	mov	r3,r2
 822f540:	e0bffc17 	ldw	r2,-16(fp)
 822f544:	10c5883a 	add	r2,r2,r3
 822f548:	e0bffd15 	stw	r2,-12(fp)
#ifdef CSUM_DEMO
   if (!(tcpp->th_flags & TH_SYN))
   tcpp->th_flags |= TH_PUSH;     /* force the PSH flag in TCP hdr */
#endif
   tcpp->th_sum = tcp_cksum(bip);
 822f54c:	e13ffc17 	ldw	r4,-16(fp)
 822f550:	8247cf40 	call	8247cf4 <tcp_cksum>
 822f554:	1007883a 	mov	r3,r2
 822f558:	e0bffd17 	ldw	r2,-12(fp)
 822f55c:	10c0040d 	sth	r3,16(r2)

   pkt->nb_prot = (char*)(bip + 1);    /* point past IP header */
 822f560:	e0bffc17 	ldw	r2,-16(fp)
 822f564:	10c00504 	addi	r3,r2,20
 822f568:	e0bffa17 	ldw	r2,-24(fp)
 822f56c:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen = data->m_len - sizeof(struct ip);
 822f570:	e0bffe17 	ldw	r2,-8(fp)
 822f574:	10800217 	ldw	r2,8(r2)
 822f578:	10fffb04 	addi	r3,r2,-20
 822f57c:	e0bffa17 	ldw	r2,-24(fp)
 822f580:	10c00415 	stw	r3,16(r2)

   e = ip_write(IPPROTO_TCP, pkt);
 822f584:	e17ffa17 	ldw	r5,-24(fp)
 822f588:	01000184 	movi	r4,6
 822f58c:	823f9a80 	call	823f9a8 <ip_write>
 822f590:	e0bffb15 	stw	r2,-20(fp)

   /* ip_write() is now responsable for data->pkt, so... */
   data->pkt = NULL;
 822f594:	e0bffe17 	ldw	r2,-8(fp)
 822f598:	10000115 	stw	zero,4(r2)
   m_freem(data);
 822f59c:	e13ffe17 	ldw	r4,-8(fp)
 822f5a0:	822e6940 	call	822e694 <m_freem>

   if (e < 0)
 822f5a4:	e0bffb17 	ldw	r2,-20(fp)
 822f5a8:	1000070e 	bge	r2,zero,822f5c8 <ip_output+0x598>
   {
      /* don't report dropped sends, it causes socket applications to 
      bail when a TCP retry will fix the problem */
      if (e == SEND_DROPPED)
 822f5ac:	e0bffb17 	ldw	r2,-20(fp)
 822f5b0:	10bffa98 	cmpnei	r2,r2,-22
 822f5b4:	1000021e 	bne	r2,zero,822f5c0 <ip_output+0x590>
         return 0;
 822f5b8:	0005883a 	mov	r2,zero
 822f5bc:	00000306 	br	822f5cc <ip_output+0x59c>
      return e;
 822f5c0:	e0bffb17 	ldw	r2,-20(fp)
 822f5c4:	00000106 	br	822f5cc <ip_output+0x59c>
   }
   else
      return 0;
 822f5c8:	0005883a 	mov	r2,zero
}
 822f5cc:	e037883a 	mov	sp,fp
 822f5d0:	dfc00117 	ldw	ra,4(sp)
 822f5d4:	df000017 	ldw	fp,0(sp)
 822f5d8:	dec00204 	addi	sp,sp,8
 822f5dc:	f800283a 	ret

0822f5e0 <in_broadcast>:
 * RETURNS: TRUE if broadcast, else FALSE
 */

int
in_broadcast(u_long ipaddr)   /* passed in net endian */
{
 822f5e0:	defffe04 	addi	sp,sp,-8
 822f5e4:	df000115 	stw	fp,4(sp)
 822f5e8:	df000104 	addi	fp,sp,4
 822f5ec:	e13fff15 	stw	r4,-4(fp)
   if (ipaddr == 0xffffffff)
 822f5f0:	e0bfff17 	ldw	r2,-4(fp)
 822f5f4:	10bfffd8 	cmpnei	r2,r2,-1
 822f5f8:	1000021e 	bne	r2,zero,822f604 <in_broadcast+0x24>
      return TRUE;
 822f5fc:	00800044 	movi	r2,1
 822f600:	00000106 	br	822f608 <in_broadcast+0x28>

   return FALSE;
 822f604:	0005883a 	mov	r2,zero
}
 822f608:	e037883a 	mov	sp,fp
 822f60c:	df000017 	ldw	fp,0(sp)
 822f610:	dec00104 	addi	sp,sp,4
 822f614:	f800283a 	ret

0822f618 <np_stripoptions>:
 * RETURNS: void
 */

void
np_stripoptions(struct ip * ti, struct mbuf * m)
{
 822f618:	defffb04 	addi	sp,sp,-20
 822f61c:	dfc00415 	stw	ra,16(sp)
 822f620:	df000315 	stw	fp,12(sp)
 822f624:	df000304 	addi	fp,sp,12
 822f628:	e13ffe15 	stw	r4,-8(fp)
 822f62c:	e17fff15 	stw	r5,-4(fp)
   int   ihlen;

   /* get the IP header length in octets */
   ihlen = (ti->ip_ver_ihl & 0x0f) << 2;
 822f630:	e0bffe17 	ldw	r2,-8(fp)
 822f634:	10800003 	ldbu	r2,0(r2)
 822f638:	10803fcc 	andi	r2,r2,255
 822f63c:	108003cc 	andi	r2,r2,15
 822f640:	1085883a 	add	r2,r2,r2
 822f644:	1085883a 	add	r2,r2,r2
 822f648:	e0bffd15 	stw	r2,-12(fp)

   /* if it's <= 20 octets, there are no IP header options to strip */
   if (ihlen <= 20)
 822f64c:	e0bffd17 	ldw	r2,-12(fp)
 822f650:	10800548 	cmpgei	r2,r2,21
 822f654:	10002726 	beq	r2,zero,822f6f4 <np_stripoptions+0xdc>
      return;

   /* figure out how much to strip: we want to keep the 20-octet IP header */
   ihlen -= 20;
 822f658:	e0bffd17 	ldw	r2,-12(fp)
 822f65c:	10bffb04 	addi	r2,r2,-20
 822f660:	e0bffd15 	stw	r2,-12(fp)

   /* remove the stripped options from the IP datagram length */
   ti->ip_len -= ihlen;
 822f664:	e0bffe17 	ldw	r2,-8(fp)
 822f668:	1080008b 	ldhu	r2,2(r2)
 822f66c:	e0fffd17 	ldw	r3,-12(fp)
 822f670:	10c5c83a 	sub	r2,r2,r3
 822f674:	1007883a 	mov	r3,r2
 822f678:	e0bffe17 	ldw	r2,-8(fp)
 822f67c:	10c0008d 	sth	r3,2(r2)

   /* and from the IP header length (which will be 5*4 octets long) */
   ti->ip_ver_ihl = (ti->ip_ver_ihl & 0xf0) | 5;
 822f680:	e0bffe17 	ldw	r2,-8(fp)
 822f684:	10800003 	ldbu	r2,0(r2)
 822f688:	1007883a 	mov	r3,r2
 822f68c:	00bffc04 	movi	r2,-16
 822f690:	1884703a 	and	r2,r3,r2
 822f694:	10800154 	ori	r2,r2,5
 822f698:	1007883a 	mov	r3,r2
 822f69c:	e0bffe17 	ldw	r2,-8(fp)
 822f6a0:	10c00005 	stb	r3,0(r2)

   /* move the 20-octet IP header up against the IP payload */
   MEMMOVE( ((char*)ti) + ihlen, ti, 20);
 822f6a4:	e0bffd17 	ldw	r2,-12(fp)
 822f6a8:	e0fffe17 	ldw	r3,-8(fp)
 822f6ac:	1885883a 	add	r2,r3,r2
 822f6b0:	01800504 	movi	r6,20
 822f6b4:	e17ffe17 	ldw	r5,-8(fp)
 822f6b8:	1009883a 	mov	r4,r2
 822f6bc:	82030b40 	call	82030b4 <memmove>
   m->m_len -= ihlen;
 822f6c0:	e0bfff17 	ldw	r2,-4(fp)
 822f6c4:	10c00217 	ldw	r3,8(r2)
 822f6c8:	e0bffd17 	ldw	r2,-12(fp)
 822f6cc:	1887c83a 	sub	r3,r3,r2
 822f6d0:	e0bfff17 	ldw	r2,-4(fp)
 822f6d4:	10c00215 	stw	r3,8(r2)
   m->m_data += ihlen;
 822f6d8:	e0bfff17 	ldw	r2,-4(fp)
 822f6dc:	10c00317 	ldw	r3,12(r2)
 822f6e0:	e0bffd17 	ldw	r2,-12(fp)
 822f6e4:	1887883a 	add	r3,r3,r2
 822f6e8:	e0bfff17 	ldw	r2,-4(fp)
 822f6ec:	10c00315 	stw	r3,12(r2)
 822f6f0:	00000106 	br	822f6f8 <np_stripoptions+0xe0>
   /* get the IP header length in octets */
   ihlen = (ti->ip_ver_ihl & 0x0f) << 2;

   /* if it's <= 20 octets, there are no IP header options to strip */
   if (ihlen <= 20)
      return;
 822f6f4:	0001883a 	nop

   /* move the 20-octet IP header up against the IP payload */
   MEMMOVE( ((char*)ti) + ihlen, ti, 20);
   m->m_len -= ihlen;
   m->m_data += ihlen;
}
 822f6f8:	e037883a 	mov	sp,fp
 822f6fc:	dfc00117 	ldw	ra,4(sp)
 822f700:	df000017 	ldw	fp,0(sp)
 822f704:	dec00204 	addi	sp,sp,8
 822f708:	f800283a 	ret

0822f70c <so_icmpdu>:
 * RETURNS: 
 */

void
so_icmpdu(PACKET p, struct destun * pdp)
{
 822f70c:	defff304 	addi	sp,sp,-52
 822f710:	dfc00c15 	stw	ra,48(sp)
 822f714:	df000b15 	stw	fp,44(sp)
 822f718:	df000b04 	addi	fp,sp,44
 822f71c:	e13ffe15 	stw	r4,-8(fp)
 822f720:	e17fff15 	stw	r5,-4(fp)
   struct inpcb * inp;
   struct socket *   so;
   struct tcpcb * tp;

   /* extract information about packet which generated DU */
   fhost = htonl(pdp->dip.ip_dest);
 822f724:	e0bfff17 	ldw	r2,-4(fp)
 822f728:	10800617 	ldw	r2,24(r2)
 822f72c:	1006d63a 	srli	r3,r2,24
 822f730:	e0bfff17 	ldw	r2,-4(fp)
 822f734:	10800617 	ldw	r2,24(r2)
 822f738:	1004d23a 	srli	r2,r2,8
 822f73c:	10bfc00c 	andi	r2,r2,65280
 822f740:	1886b03a 	or	r3,r3,r2
 822f744:	e0bfff17 	ldw	r2,-4(fp)
 822f748:	10800617 	ldw	r2,24(r2)
 822f74c:	10bfc00c 	andi	r2,r2,65280
 822f750:	1004923a 	slli	r2,r2,8
 822f754:	1886b03a 	or	r3,r3,r2
 822f758:	e0bfff17 	ldw	r2,-4(fp)
 822f75c:	10800617 	ldw	r2,24(r2)
 822f760:	1004963a 	slli	r2,r2,24
 822f764:	1884b03a 	or	r2,r3,r2
 822f768:	e0bff815 	stw	r2,-32(fp)
   lhost = htonl(pdp->dip.ip_src);
 822f76c:	e0bfff17 	ldw	r2,-4(fp)
 822f770:	10800517 	ldw	r2,20(r2)
 822f774:	1006d63a 	srli	r3,r2,24
 822f778:	e0bfff17 	ldw	r2,-4(fp)
 822f77c:	10800517 	ldw	r2,20(r2)
 822f780:	1004d23a 	srli	r2,r2,8
 822f784:	10bfc00c 	andi	r2,r2,65280
 822f788:	1886b03a 	or	r3,r3,r2
 822f78c:	e0bfff17 	ldw	r2,-4(fp)
 822f790:	10800517 	ldw	r2,20(r2)
 822f794:	10bfc00c 	andi	r2,r2,65280
 822f798:	1004923a 	slli	r2,r2,8
 822f79c:	1886b03a 	or	r3,r3,r2
 822f7a0:	e0bfff17 	ldw	r2,-4(fp)
 822f7a4:	10800517 	ldw	r2,20(r2)
 822f7a8:	1004963a 	slli	r2,r2,24
 822f7ac:	1884b03a 	or	r2,r3,r2
 822f7b0:	e0bff915 	stw	r2,-28(fp)
   lport = htons(*(unshort*)(&pdp->ddata[0]));
 822f7b4:	e0bfff17 	ldw	r2,-4(fp)
 822f7b8:	10800704 	addi	r2,r2,28
 822f7bc:	1080000b 	ldhu	r2,0(r2)
 822f7c0:	10bfffcc 	andi	r2,r2,65535
 822f7c4:	1004d23a 	srli	r2,r2,8
 822f7c8:	1007883a 	mov	r3,r2
 822f7cc:	e0bfff17 	ldw	r2,-4(fp)
 822f7d0:	10800704 	addi	r2,r2,28
 822f7d4:	1080000b 	ldhu	r2,0(r2)
 822f7d8:	10bfffcc 	andi	r2,r2,65535
 822f7dc:	1004923a 	slli	r2,r2,8
 822f7e0:	1884b03a 	or	r2,r3,r2
 822f7e4:	e0bffa0d 	sth	r2,-24(fp)
   fport = htons(*(unshort*)(&pdp->ddata[2]));
 822f7e8:	e0bfff17 	ldw	r2,-4(fp)
 822f7ec:	10800784 	addi	r2,r2,30
 822f7f0:	1080000b 	ldhu	r2,0(r2)
 822f7f4:	10bfffcc 	andi	r2,r2,65535
 822f7f8:	1004d23a 	srli	r2,r2,8
 822f7fc:	1007883a 	mov	r3,r2
 822f800:	e0bfff17 	ldw	r2,-4(fp)
 822f804:	10800784 	addi	r2,r2,30
 822f808:	1080000b 	ldhu	r2,0(r2)
 822f80c:	10bfffcc 	andi	r2,r2,65535
 822f810:	1004923a 	slli	r2,r2,8
 822f814:	1884b03a 	or	r2,r3,r2
 822f818:	e0bffa8d 	sth	r2,-22(fp)
#ifndef IP_PMTU
   /* if it's a datagram-too-big message, ignore it -- As the
    * build isn't using PMTU Discovery this packet is most 
    * probably a Denial of Service Attack.
    */
    if(pdp->dcode == DSTFRAG)
 822f81c:	e0bfff17 	ldw	r2,-4(fp)
 822f820:	10800043 	ldbu	r2,1(r2)
 822f824:	10803fcc 	andi	r2,r2,255
 822f828:	1080201c 	xori	r2,r2,128
 822f82c:	10bfe004 	addi	r2,r2,-128
 822f830:	10800118 	cmpnei	r2,r2,4
 822f834:	10006e26 	beq	r2,zero,822f9f0 <so_icmpdu+0x2e4>
       goto done;
    }
#endif   /* IP_PMTU */

   /* if it's a TCP connection, clean it up */
   if (pdp->dip.ip_prot == TCPTP)
 822f838:	e0bfff17 	ldw	r2,-4(fp)
 822f83c:	10800443 	ldbu	r2,17(r2)
 822f840:	10803fcc 	andi	r2,r2,255
 822f844:	10800198 	cmpnei	r2,r2,6
 822f848:	1000221e 	bne	r2,zero,822f8d4 <so_icmpdu+0x1c8>
   {
      /* find associated data structs and socket */
      inp = in_pcblookup(&tcb, fhost, fport, lhost, lport, INPLOOKUP_WILDCARD);
 822f84c:	e13ffa8b 	ldhu	r4,-22(fp)
 822f850:	e0bffa0b 	ldhu	r2,-24(fp)
 822f854:	00c00044 	movi	r3,1
 822f858:	d8c00115 	stw	r3,4(sp)
 822f85c:	d8800015 	stw	r2,0(sp)
 822f860:	e1fff917 	ldw	r7,-28(fp)
 822f864:	200d883a 	mov	r6,r4
 822f868:	e17ff817 	ldw	r5,-32(fp)
 822f86c:	010209b4 	movhi	r4,2086
 822f870:	2139a204 	addi	r4,r4,-6520
 822f874:	82484c80 	call	82484c8 <in_pcblookup>
 822f878:	e0bffb15 	stw	r2,-20(fp)
      if (inp == 0)
 822f87c:	e0bffb17 	ldw	r2,-20(fp)
 822f880:	10005d26 	beq	r2,zero,822f9f8 <so_icmpdu+0x2ec>
         goto done;
      so = inp->inp_socket;
 822f884:	e0bffb17 	ldw	r2,-20(fp)
 822f888:	10800817 	ldw	r2,32(r2)
 822f88c:	e0bffc15 	stw	r2,-16(fp)
      if (so == 0)
 822f890:	e0bffc17 	ldw	r2,-16(fp)
 822f894:	10005a26 	beq	r2,zero,822fa00 <so_icmpdu+0x2f4>
         goto done;
      tp = intotcpcb(inp);
 822f898:	e0bffb17 	ldw	r2,-20(fp)
 822f89c:	10800917 	ldw	r2,36(r2)
 822f8a0:	e0bffd15 	stw	r2,-12(fp)
      if (tp)
 822f8a4:	e0bffd17 	ldw	r2,-12(fp)
 822f8a8:	10000626 	beq	r2,zero,822f8c4 <so_icmpdu+0x1b8>
      {
         if (tp->t_state <= TCPS_LISTEN)
 822f8ac:	e0bffd17 	ldw	r2,-12(fp)
 822f8b0:	10800217 	ldw	r2,8(r2)
 822f8b4:	10800088 	cmpgei	r2,r2,2
 822f8b8:	10005326 	beq	r2,zero,822fa08 <so_icmpdu+0x2fc>
               goto done;
        }
   }
#endif

         tcp_close(tp);
 822f8bc:	e13ffd17 	ldw	r4,-12(fp)
 822f8c0:	8239c3c0 	call	8239c3c <tcp_close>
      }
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 822f8c4:	e0bffc17 	ldw	r2,-16(fp)
 822f8c8:	00c01bc4 	movi	r3,111
 822f8cc:	10c00615 	stw	r3,24(r2)
 822f8d0:	00005406 	br	822fa24 <so_icmpdu+0x318>
   }   
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
 822f8d4:	e0bfff17 	ldw	r2,-4(fp)
 822f8d8:	10800443 	ldbu	r2,17(r2)
 822f8dc:	10803fcc 	andi	r2,r2,255
 822f8e0:	10800458 	cmpnei	r2,r2,17
 822f8e4:	10004a1e 	bne	r2,zero,822fa10 <so_icmpdu+0x304>
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 822f8e8:	d0a09c17 	ldw	r2,-32144(gp)
 822f8ec:	e0bff715 	stw	r2,-36(fp)
 822f8f0:	00002106 	br	822f978 <so_icmpdu+0x26c>
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
 822f8f4:	e0bff717 	ldw	r2,-36(fp)
 822f8f8:	1080020b 	ldhu	r2,8(r2)
 822f8fc:	10ffffcc 	andi	r3,r2,65535
 822f900:	e0bffa8b 	ldhu	r2,-22(fp)
 822f904:	18800426 	beq	r3,r2,822f918 <so_icmpdu+0x20c>
 822f908:	e0bff717 	ldw	r2,-36(fp)
 822f90c:	1080020b 	ldhu	r2,8(r2)
 822f910:	10bfffcc 	andi	r2,r2,65535
 822f914:	1000151e 	bne	r2,zero,822f96c <so_icmpdu+0x260>
             (tmp->u_fhost == htonl(fhost)) &&
 822f918:	e0bff717 	ldw	r2,-36(fp)
 822f91c:	10c00417 	ldw	r3,16(r2)
 822f920:	e0bff817 	ldw	r2,-32(fp)
 822f924:	1008d63a 	srli	r4,r2,24
 822f928:	e0bff817 	ldw	r2,-32(fp)
 822f92c:	1004d23a 	srli	r2,r2,8
 822f930:	10bfc00c 	andi	r2,r2,65280
 822f934:	2088b03a 	or	r4,r4,r2
 822f938:	e0bff817 	ldw	r2,-32(fp)
 822f93c:	10bfc00c 	andi	r2,r2,65280
 822f940:	1004923a 	slli	r2,r2,8
 822f944:	2088b03a 	or	r4,r4,r2
 822f948:	e0bff817 	ldw	r2,-32(fp)
 822f94c:	1004963a 	slli	r2,r2,24
 822f950:	2084b03a 	or	r2,r4,r2
   else if(pdp->dip.ip_prot == UDP_PROT)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
 822f954:	1880051e 	bne	r3,r2,822f96c <so_icmpdu+0x260>
             (tmp->u_fhost == htonl(fhost)) &&
             (tmp->u_lport == lport))
 822f958:	e0bff717 	ldw	r2,-36(fp)
 822f95c:	1080018b 	ldhu	r2,6(r2)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
             (tmp->u_fhost == htonl(fhost)) &&
 822f960:	10ffffcc 	andi	r3,r2,65535
 822f964:	e0bffa0b 	ldhu	r2,-24(fp)
 822f968:	18800626 	beq	r3,r2,822f984 <so_icmpdu+0x278>
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 822f96c:	e0bff717 	ldw	r2,-36(fp)
 822f970:	10800017 	ldw	r2,0(r2)
 822f974:	e0bff715 	stw	r2,-36(fp)
 822f978:	e0bff717 	ldw	r2,-36(fp)
 822f97c:	103fdd1e 	bne	r2,zero,822f8f4 <so_icmpdu+0x1e8>
 822f980:	00000106 	br	822f988 <so_icmpdu+0x27c>
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
             (tmp->u_fhost == htonl(fhost)) &&
             (tmp->u_lport == lport))
         {
            break;   /* found our UDP table entry */
 822f984:	0001883a 	nop
         }
      if (!tmp) 
 822f988:	e0bff717 	ldw	r2,-36(fp)
 822f98c:	10002226 	beq	r2,zero,822fa18 <so_icmpdu+0x30c>
         goto done;
      so = (struct socket *)tmp->u_data;
 822f990:	e0bff717 	ldw	r2,-36(fp)
 822f994:	10800617 	ldw	r2,24(r2)
 822f998:	e0bffc15 	stw	r2,-16(fp)
      /* May be non-socket (lightweight) UDP connection. */
      if (so->so_type != SOCK_DGRAM)
 822f99c:	e0bffc17 	ldw	r2,-16(fp)
 822f9a0:	10800983 	ldbu	r2,38(r2)
 822f9a4:	10803fcc 	andi	r2,r2,255
 822f9a8:	1080201c 	xori	r2,r2,128
 822f9ac:	10bfe004 	addi	r2,r2,-128
 822f9b0:	108000a0 	cmpeqi	r2,r2,2
 822f9b4:	10001a26 	beq	r2,zero,822fa20 <so_icmpdu+0x314>
         goto done;
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 822f9b8:	e0bffc17 	ldw	r2,-16(fp)
 822f9bc:	00c01bc4 	movi	r3,111
 822f9c0:	10c00615 	stw	r3,24(r2)
      /* do a select() notify on socket here */
      sorwakeup(so);
 822f9c4:	e0bffc17 	ldw	r2,-16(fp)
 822f9c8:	10800a04 	addi	r2,r2,40
 822f9cc:	100b883a 	mov	r5,r2
 822f9d0:	e13ffc17 	ldw	r4,-16(fp)
 822f9d4:	82342a00 	call	82342a0 <sbwakeup>
      sowwakeup(so);
 822f9d8:	e0bffc17 	ldw	r2,-16(fp)
 822f9dc:	10801204 	addi	r2,r2,72
 822f9e0:	100b883a 	mov	r5,r2
 822f9e4:	e13ffc17 	ldw	r4,-16(fp)
 822f9e8:	82342a00 	call	82342a0 <sbwakeup>
 822f9ec:	00000d06 	br	822fa24 <so_icmpdu+0x318>
    * build isn't using PMTU Discovery this packet is most 
    * probably a Denial of Service Attack.
    */
    if(pdp->dcode == DSTFRAG)
    {
       goto done;
 822f9f0:	0001883a 	nop
 822f9f4:	00000b06 	br	822fa24 <so_icmpdu+0x318>
   if (pdp->dip.ip_prot == TCPTP)
   {
      /* find associated data structs and socket */
      inp = in_pcblookup(&tcb, fhost, fport, lhost, lport, INPLOOKUP_WILDCARD);
      if (inp == 0)
         goto done;
 822f9f8:	0001883a 	nop
 822f9fc:	00000906 	br	822fa24 <so_icmpdu+0x318>
      so = inp->inp_socket;
      if (so == 0)
         goto done;
 822fa00:	0001883a 	nop
 822fa04:	00000706 	br	822fa24 <so_icmpdu+0x318>
      tp = intotcpcb(inp);
      if (tp)
      {
         if (tp->t_state <= TCPS_LISTEN)
         {
            goto done;
 822fa08:	0001883a 	nop
 822fa0c:	00000506 	br	822fa24 <so_icmpdu+0x318>
      sorwakeup(so);
      sowwakeup(so);
   }
#endif   /* UDP_SOCKETS */
   else
      goto done;
 822fa10:	0001883a 	nop
 822fa14:	00000306 	br	822fa24 <so_icmpdu+0x318>
             (tmp->u_lport == lport))
         {
            break;   /* found our UDP table entry */
         }
      if (!tmp) 
         goto done;
 822fa18:	0001883a 	nop
 822fa1c:	00000106 	br	822fa24 <so_icmpdu+0x318>
      so = (struct socket *)tmp->u_data;
      /* May be non-socket (lightweight) UDP connection. */
      if (so->so_type != SOCK_DGRAM)
         goto done;
 822fa20:	0001883a 	nop
   if (pdp->dcode == DSTFRAG)
      pmtucache_set(pdp->dip.ip_dest, htons(pdp->dno2));
#endif   /* IP_PMTU */

done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
 822fa24:	01000084 	movi	r4,2
 822fa28:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   pk_free(p); /* done with original packet */
 822fa2c:	e13ffe17 	ldw	r4,-8(fp)
 822fa30:	822cd980 	call	822cd98 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822fa34:	01000084 	movi	r4,2
 822fa38:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   return;
 822fa3c:	0001883a 	nop
}
 822fa40:	e037883a 	mov	sp,fp
 822fa44:	dfc00117 	ldw	ra,4(sp)
 822fa48:	df000017 	ldw	fp,0(sp)
 822fa4c:	dec00204 	addi	sp,sp,8
 822fa50:	f800283a 	ret

0822fa54 <tcp_tick>:
unsigned long nextslow = 0L;     /* next slow tcp timer time */
static int in_tcptick = 0;       /* reentry gaurd */

void
tcp_tick()
{
 822fa54:	defffe04 	addi	sp,sp,-8
 822fa58:	dfc00115 	stw	ra,4(sp)
 822fa5c:	df000015 	stw	fp,0(sp)
 822fa60:	d839883a 	mov	fp,sp
   /* guard against re-entry */
   if (in_tcptick)
 822fa64:	d0a0ad17 	ldw	r2,-32076(gp)
 822fa68:	1000121e 	bne	r2,zero,822fab4 <tcp_tick+0x60>
      return;
   in_tcptick++;
 822fa6c:	d0a0ad17 	ldw	r2,-32076(gp)
 822fa70:	10800044 	addi	r2,r2,1
 822fa74:	d0a0ad15 	stw	r2,-32076(gp)

   LOCK_NET_RESOURCE(NET_RESID);
 822fa78:	0009883a 	mov	r4,zero
 822fa7c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>

   if (cticks >= nextslow) /* time to do it again */
 822fa80:	d0e0a817 	ldw	r3,-32096(gp)
 822fa84:	d0a0ac17 	ldw	r2,-32080(gp)
 822fa88:	18800436 	bltu	r3,r2,822fa9c <tcp_tick+0x48>
   {
      tcp_slowtimo();      /* call routine in BSD tcp_timr.c */
 822fa8c:	8239e640 	call	8239e64 <tcp_slowtimo>
#ifdef CSUM_DEMO
      nextslow = cticks + (TPS/5);  /* another 200 ms */
#else
      nextslow = cticks + (TPS/2);  /* another 500 ms */
 822fa90:	d0a0a817 	ldw	r2,-32096(gp)
 822fa94:	10800c84 	addi	r2,r2,50
 822fa98:	d0a0ac15 	stw	r2,-32080(gp)

#ifdef DO_DELAY_ACKS
   tcp_fasttimo();
#endif   /* DO_DELAY_ACKS */

   UNLOCK_NET_RESOURCE(NET_RESID);
 822fa9c:	0009883a 	mov	r4,zero
 822faa0:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>

   in_tcptick--;
 822faa4:	d0a0ad17 	ldw	r2,-32076(gp)
 822faa8:	10bfffc4 	addi	r2,r2,-1
 822faac:	d0a0ad15 	stw	r2,-32076(gp)
 822fab0:	00000106 	br	822fab8 <tcp_tick+0x64>
void
tcp_tick()
{
   /* guard against re-entry */
   if (in_tcptick)
      return;
 822fab4:	0001883a 	nop
#endif   /* DO_DELAY_ACKS */

   UNLOCK_NET_RESOURCE(NET_RESID);

   in_tcptick--;
}
 822fab8:	e037883a 	mov	sp,fp
 822fabc:	dfc00117 	ldw	ra,4(sp)
 822fac0:	df000017 	ldw	fp,0(sp)
 822fac4:	dec00204 	addi	sp,sp,8
 822fac8:	f800283a 	ret

0822facc <rawip_lookup>:
 *          or NULL if no matching raw IP endpoint is found.
 */

struct ipraw_ep *
rawip_lookup(struct socket * so)
{
 822facc:	defffd04 	addi	sp,sp,-12
 822fad0:	df000215 	stw	fp,8(sp)
 822fad4:	df000204 	addi	fp,sp,8
 822fad8:	e13fff15 	stw	r4,-4(fp)
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 822fadc:	d0a0cf17 	ldw	r2,-31940(gp)
 822fae0:	e0bffe15 	stw	r2,-8(fp)
 822fae4:	00000906 	br	822fb0c <rawip_lookup+0x40>
      if (tmp->ipr_data == (void*)so)
 822fae8:	e0bffe17 	ldw	r2,-8(fp)
 822faec:	10c00417 	ldw	r3,16(r2)
 822faf0:	e0bfff17 	ldw	r2,-4(fp)
 822faf4:	1880021e 	bne	r3,r2,822fb00 <rawip_lookup+0x34>
      return (tmp);
 822faf8:	e0bffe17 	ldw	r2,-8(fp)
 822fafc:	00000606 	br	822fb18 <rawip_lookup+0x4c>
struct ipraw_ep *
rawip_lookup(struct socket * so)
{
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 822fb00:	e0bffe17 	ldw	r2,-8(fp)
 822fb04:	10800017 	ldw	r2,0(r2)
 822fb08:	e0bffe15 	stw	r2,-8(fp)
 822fb0c:	e0bffe17 	ldw	r2,-8(fp)
 822fb10:	103ff51e 	bne	r2,zero,822fae8 <rawip_lookup+0x1c>
      if (tmp->ipr_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 822fb14:	0005883a 	mov	r2,zero
}
 822fb18:	e037883a 	mov	sp,fp
 822fb1c:	df000017 	ldw	fp,0(sp)
 822fb20:	dec00104 	addi	sp,sp,4
 822fb24:	f800283a 	ret

0822fb28 <rawip_soinput>:
 *          indicates that the packet has not been accepted.
 */

int
rawip_soinput(PACKET pkt, void * so_ptr)
{
 822fb28:	defff504 	addi	sp,sp,-44
 822fb2c:	dfc00a15 	stw	ra,40(sp)
 822fb30:	df000915 	stw	fp,36(sp)
 822fb34:	df000904 	addi	fp,sp,36
 822fb38:	e13ffe15 	stw	r4,-8(fp)
 822fb3c:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 822fb40:	e0bfff17 	ldw	r2,-4(fp)
 822fb44:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;

   LOCK_NET_RESOURCE(NET_RESID); 
 822fb48:	0009883a 	mov	r4,zero
 822fb4c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 822fb50:	e0bff717 	ldw	r2,-36(fp)
 822fb54:	10c00a17 	ldw	r3,40(r2)
 822fb58:	e0bffe17 	ldw	r2,-8(fp)
 822fb5c:	10800417 	ldw	r2,16(r2)
 822fb60:	1887883a 	add	r3,r3,r2
 822fb64:	e0bff717 	ldw	r2,-36(fp)
 822fb68:	10800b17 	ldw	r2,44(r2)
 822fb6c:	18800436 	bltu	r3,r2,822fb80 <rawip_soinput+0x58>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 822fb70:	0009883a 	mov	r4,zero
 822fb74:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 822fb78:	00801a44 	movi	r2,105
 822fb7c:	00005706 	br	822fcdc <rawip_soinput+0x1b4>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 822fb80:	000b883a 	mov	r5,zero
 822fb84:	01000044 	movi	r4,1
 822fb88:	822e4040 	call	822e404 <m_getnbuf>
 822fb8c:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 822fb90:	e0bff817 	ldw	r2,-32(fp)
 822fb94:	1000041e 	bne	r2,zero,822fba8 <rawip_soinput+0x80>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 822fb98:	0009883a 	mov	r4,zero
 822fb9c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 822fba0:	00801a44 	movi	r2,105
 822fba4:	00004d06 	br	822fcdc <rawip_soinput+0x1b4>
   }

   /* set data mbuf to point to start of IP header */
   m_in->pkt = pkt;
 822fba8:	e0bff817 	ldw	r2,-32(fp)
 822fbac:	e0fffe17 	ldw	r3,-8(fp)
 822fbb0:	10c00115 	stw	r3,4(r2)
   m_in->m_base = pkt->nb_buff;
 822fbb4:	e0bffe17 	ldw	r2,-8(fp)
 822fbb8:	10c00117 	ldw	r3,4(r2)
 822fbbc:	e0bff817 	ldw	r2,-32(fp)
 822fbc0:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 822fbc4:	e0bffe17 	ldw	r2,-8(fp)
 822fbc8:	10c00217 	ldw	r3,8(r2)
 822fbcc:	e0bff817 	ldw	r2,-32(fp)
 822fbd0:	10c00515 	stw	r3,20(r2)
   m_in->m_data = pkt->nb_prot;
 822fbd4:	e0bffe17 	ldw	r2,-8(fp)
 822fbd8:	10c00317 	ldw	r3,12(r2)
 822fbdc:	e0bff817 	ldw	r2,-32(fp)
 822fbe0:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 822fbe4:	e0bffe17 	ldw	r2,-8(fp)
 822fbe8:	10c00417 	ldw	r3,16(r2)
 822fbec:	e0bff817 	ldw	r2,-32(fp)
 822fbf0:	10c00215 	stw	r3,8(r2)

   /* if this socket doesn't have IP_HDRINCL set, adjust the
    * mbuf to skip past the IP header
    */
   if (!(so->so_options & SO_HDRINCL))
 822fbf4:	e0bff717 	ldw	r2,-36(fp)
 822fbf8:	10800417 	ldw	r2,16(r2)
 822fbfc:	1088000c 	andi	r2,r2,8192
 822fc00:	1000141e 	bne	r2,zero,822fc54 <rawip_soinput+0x12c>
   {
      unsigned int ihl = 
         (((struct ip *)(pkt->nb_prot))->ip_ver_ihl & 0x0f) << 2;
 822fc04:	e0bffe17 	ldw	r2,-8(fp)
 822fc08:	10800317 	ldw	r2,12(r2)
 822fc0c:	10800003 	ldbu	r2,0(r2)
 822fc10:	10803fcc 	andi	r2,r2,255
 822fc14:	108003cc 	andi	r2,r2,15
 822fc18:	1085883a 	add	r2,r2,r2
 822fc1c:	1085883a 	add	r2,r2,r2
   /* if this socket doesn't have IP_HDRINCL set, adjust the
    * mbuf to skip past the IP header
    */
   if (!(so->so_options & SO_HDRINCL))
   {
      unsigned int ihl = 
 822fc20:	e0bff915 	stw	r2,-28(fp)
         (((struct ip *)(pkt->nb_prot))->ip_ver_ihl & 0x0f) << 2;
      m_in->m_data += ihl;
 822fc24:	e0bff817 	ldw	r2,-32(fp)
 822fc28:	10c00317 	ldw	r3,12(r2)
 822fc2c:	e0bff917 	ldw	r2,-28(fp)
 822fc30:	1887883a 	add	r3,r3,r2
 822fc34:	e0bff817 	ldw	r2,-32(fp)
 822fc38:	10c00315 	stw	r3,12(r2)
      m_in->m_len -= ihl;
 822fc3c:	e0bff817 	ldw	r2,-32(fp)
 822fc40:	10c00217 	ldw	r3,8(r2)
 822fc44:	e0bff917 	ldw	r2,-28(fp)
 822fc48:	1887c83a 	sub	r3,r3,r2
 822fc4c:	e0bff817 	ldw	r2,-32(fp)
 822fc50:	10c00215 	stw	r3,8(r2)
   }

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 822fc54:	e0bffe17 	ldw	r2,-8(fp)
 822fc58:	10800717 	ldw	r2,28(r2)
 822fc5c:	e0bffb15 	stw	r2,-20(fp)
   sin.sin_port = 0;
 822fc60:	e03ffa8d 	sth	zero,-22(fp)
   sin.sin_family = AF_INET;
 822fc64:	00800084 	movi	r2,2
 822fc68:	e0bffa0d 	sth	r2,-24(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 822fc6c:	e0bff717 	ldw	r2,-36(fp)
 822fc70:	10800a04 	addi	r2,r2,40
 822fc74:	e0fffa04 	addi	r3,fp,-24
 822fc78:	e1bff817 	ldw	r6,-32(fp)
 822fc7c:	180b883a 	mov	r5,r3
 822fc80:	1009883a 	mov	r4,r2
 822fc84:	82345c80 	call	82345c8 <sbappendaddr>
 822fc88:	1000081e 	bne	r2,zero,822fcac <rawip_soinput+0x184>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       * underlying stack
       */
      m_in->pkt = NULL;
 822fc8c:	e0bff817 	ldw	r2,-32(fp)
 822fc90:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 822fc94:	e13ff817 	ldw	r4,-32(fp)
 822fc98:	822e58c0 	call	822e58c <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 822fc9c:	0009883a 	mov	r4,zero
 822fca0:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 822fca4:	00801a44 	movi	r2,105
 822fca8:	00000c06 	br	822fcdc <rawip_soinput+0x1b4>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 822fcac:	e0bff717 	ldw	r2,-36(fp)
 822fcb0:	10800a04 	addi	r2,r2,40
 822fcb4:	1009883a 	mov	r4,r2
 822fcb8:	82297040 	call	8229704 <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 822fcbc:	e0bff717 	ldw	r2,-36(fp)
 822fcc0:	10800a04 	addi	r2,r2,40
 822fcc4:	100b883a 	mov	r5,r2
 822fcc8:	e13ff717 	ldw	r4,-36(fp)
 822fccc:	82342a00 	call	82342a0 <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 822fcd0:	0009883a 	mov	r4,zero
 822fcd4:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   return 0;
 822fcd8:	0005883a 	mov	r2,zero
}
 822fcdc:	e037883a 	mov	sp,fp
 822fce0:	dfc00117 	ldw	ra,4(sp)
 822fce4:	df000017 	ldw	fp,0(sp)
 822fce8:	dec00204 	addi	sp,sp,8
 822fcec:	f800283a 	ret

0822fcf0 <rawip_usrreq>:

int
rawip_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 822fcf0:	deffef04 	addi	sp,sp,-68
 822fcf4:	dfc01015 	stw	ra,64(sp)
 822fcf8:	df000f15 	stw	fp,60(sp)
 822fcfc:	dc000e15 	stw	r16,56(sp)
 822fd00:	df000f04 	addi	fp,sp,60
 822fd04:	e13ffc15 	stw	r4,-16(fp)
 822fd08:	e17ffd15 	stw	r5,-12(fp)
 822fd0c:	e1bffe15 	stw	r6,-8(fp)
   u_char prot;
   struct ip * pip;
   int   req;
   NET   ifp;     /* ptr to network interface structure */

   req = so->so_req;    /* get request from socket struct */
 822fd10:	e0bffc17 	ldw	r2,-16(fp)
 822fd14:	10800717 	ldw	r2,28(r2)
 822fd18:	e0bff615 	stw	r2,-40(fp)

   switch (req) 
 822fd1c:	e0bff617 	ldw	r2,-40(fp)
 822fd20:	10800468 	cmpgeui	r2,r2,17
 822fd24:	1001be1e 	bne	r2,zero,8230420 <rawip_usrreq+0x730>
 822fd28:	e0bff617 	ldw	r2,-40(fp)
 822fd2c:	100690ba 	slli	r3,r2,2
 822fd30:	008208f4 	movhi	r2,2083
 822fd34:	10bf5104 	addi	r2,r2,-700
 822fd38:	1885883a 	add	r2,r3,r2
 822fd3c:	10800017 	ldw	r2,0(r2)
 822fd40:	1000683a 	jmp	r2
 822fd44:	0822fd88 	cmpgei	zero,at,-29706
 822fd48:	0822fe10 	cmplti	zero,at,-29704
 822fd4c:	0822fe4c 	andi	zero,at,35833
 822fd50:	08230420 	cmpeqi	zero,at,-29680
 822fd54:	0822fe4c 	andi	zero,at,35833
 822fd58:	08230420 	cmpeqi	zero,at,-29680
 822fd5c:	08230414 	ori	zero,at,35856
 822fd60:	08230420 	cmpeqi	zero,at,-29680
 822fd64:	08230414 	ori	zero,at,35856
 822fd68:	0822ffd8 	cmpnei	zero,at,-29697
 822fd6c:	08230420 	cmpeqi	zero,at,-29680
 822fd70:	08230420 	cmpeqi	zero,at,-29680
 822fd74:	08230420 	cmpeqi	zero,at,-29680
 822fd78:	08230420 	cmpeqi	zero,at,-29680
 822fd7c:	08230420 	cmpeqi	zero,at,-29680
 822fd80:	08230380 	call	823038 <OSCtxSw_SWITCH_PC+0x822ff8>
 822fd84:	08230380 	call	823038 <OSCtxSw_SWITCH_PC+0x822ff8>
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = 
         ip_raw_maxalloc(so->so_options & SO_HDRINCL);
 822fd88:	e0bffc17 	ldw	r2,-16(fp)
 822fd8c:	10800417 	ldw	r2,16(r2)
 822fd90:	1088000c 	andi	r2,r2,8192
 822fd94:	1009883a 	mov	r4,r2
 822fd98:	82441f00 	call	82441f0 <ip_raw_maxalloc>

   switch (req) 
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = 
 822fd9c:	1007883a 	mov	r3,r2
 822fda0:	e0bffc17 	ldw	r2,-16(fp)
 822fda4:	10c01315 	stw	r3,76(r2)
 822fda8:	e0bffc17 	ldw	r2,-16(fp)
 822fdac:	10c01317 	ldw	r3,76(r2)
 822fdb0:	e0bffc17 	ldw	r2,-16(fp)
 822fdb4:	10c00b15 	stw	r3,44(r2)
         ip_raw_maxalloc(so->so_options & SO_HDRINCL);
      /* make a raw IP endpoint */
      prot = (u_char)(MBUF2LONG(nam));
 822fdb8:	e0bffe17 	ldw	r2,-8(fp)
 822fdbc:	e0bff705 	stb	r2,-36(fp)
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 822fdc0:	0009883a 	mov	r4,zero
 822fdc4:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      ep = ip_raw_open(prot, 0L, 0L, rawip_soinput, so);
 822fdc8:	e0fff703 	ldbu	r3,-36(fp)
 822fdcc:	e0bffc17 	ldw	r2,-16(fp)
 822fdd0:	d8800015 	stw	r2,0(sp)
 822fdd4:	01c208f4 	movhi	r7,2083
 822fdd8:	39feca04 	addi	r7,r7,-1240
 822fddc:	000d883a 	mov	r6,zero
 822fde0:	000b883a 	mov	r5,zero
 822fde4:	1809883a 	mov	r4,r3
 822fde8:	8243d3c0 	call	8243d3c <ip_raw_open>
 822fdec:	e0bff815 	stw	r2,-32(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 822fdf0:	0009883a 	mov	r4,zero
 822fdf4:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      if (!ep)
 822fdf8:	e0bff817 	ldw	r2,-32(fp)
 822fdfc:	1000021e 	bne	r2,zero,822fe08 <rawip_usrreq+0x118>
         return(EINVAL);
 822fe00:	00800584 	movi	r2,22
 822fe04:	00018706 	br	8230424 <rawip_usrreq+0x734>
      return 0;
 822fe08:	0005883a 	mov	r2,zero
 822fe0c:	00018506 	br	8230424 <rawip_usrreq+0x734>
   case PRU_DETACH:
      /* delete the raw IP endpoint */
      ep = rawip_lookup(so);
 822fe10:	e13ffc17 	ldw	r4,-16(fp)
 822fe14:	822facc0 	call	822facc <rawip_lookup>
 822fe18:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 822fe1c:	e0bff817 	ldw	r2,-32(fp)
 822fe20:	1000021e 	bne	r2,zero,822fe2c <rawip_usrreq+0x13c>
         return(EINVAL);
 822fe24:	00800584 	movi	r2,22
 822fe28:	00017e06 	br	8230424 <rawip_usrreq+0x734>
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 822fe2c:	0009883a 	mov	r4,zero
 822fe30:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      ip_raw_close(ep);
 822fe34:	e13ff817 	ldw	r4,-32(fp)
 822fe38:	8243e140 	call	8243e14 <ip_raw_close>
      LOCK_NET_RESOURCE(NET_RESID);
 822fe3c:	0009883a 	mov	r4,zero
 822fe40:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      return 0;
 822fe44:	0005883a 	mov	r2,zero
 822fe48:	00017606 	br	8230424 <rawip_usrreq+0x734>
       * a default address for sending
       */
      /* fall through to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 822fe4c:	e0bffe17 	ldw	r2,-8(fp)
 822fe50:	1000021e 	bne	r2,zero,822fe5c <rawip_usrreq+0x16c>
         return(EINVAL);
 822fe54:	00800584 	movi	r2,22
 822fe58:	00017206 	br	8230424 <rawip_usrreq+0x734>
      sin = mtod(nam, struct sockaddr_in *);
 822fe5c:	e0bffe17 	ldw	r2,-8(fp)
 822fe60:	10800317 	ldw	r2,12(r2)
 822fe64:	e0bff915 	stw	r2,-28(fp)
      if (sin == NULL)
 822fe68:	e0bff917 	ldw	r2,-28(fp)
 822fe6c:	1000021e 	bne	r2,zero,822fe78 <rawip_usrreq+0x188>
         return(EINVAL);
 822fe70:	00800584 	movi	r2,22
 822fe74:	00016b06 	br	8230424 <rawip_usrreq+0x734>
      if (nam->m_len != sizeof (*sin))
 822fe78:	e0bffe17 	ldw	r2,-8(fp)
 822fe7c:	10800217 	ldw	r2,8(r2)
 822fe80:	10800420 	cmpeqi	r2,r2,16
 822fe84:	1000021e 	bne	r2,zero,822fe90 <rawip_usrreq+0x1a0>
         return(EINVAL);
 822fe88:	00800584 	movi	r2,22
 822fe8c:	00016506 	br	8230424 <rawip_usrreq+0x734>
      ep = rawip_lookup(so);
 822fe90:	e13ffc17 	ldw	r4,-16(fp)
 822fe94:	822facc0 	call	822facc <rawip_lookup>
 822fe98:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 822fe9c:	e0bff817 	ldw	r2,-32(fp)
 822fea0:	1000021e 	bne	r2,zero,822feac <rawip_usrreq+0x1bc>
         return(EINVAL);
 822fea4:	00800584 	movi	r2,22
 822fea8:	00015e06 	br	8230424 <rawip_usrreq+0x734>
      if (req == PRU_BIND)
 822feac:	e0bff617 	ldw	r2,-40(fp)
 822feb0:	10800098 	cmpnei	r2,r2,2
 822feb4:	1000201e 	bne	r2,zero,822ff38 <rawip_usrreq+0x248>
          * if the caller-supplied address is INADDR_ANY,
          * don't bind to a specific address; else, 
          * make sure the caller-supplied address is
          * an interface IP address and if so, bind to that
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 822feb8:	e0bff917 	ldw	r2,-28(fp)
 822febc:	10800117 	ldw	r2,4(r2)
 822fec0:	1000021e 	bne	r2,zero,822fecc <rawip_usrreq+0x1dc>
         {
            lhost = 0L;
 822fec4:	e03ff415 	stw	zero,-48(fp)
 822fec8:	00001706 	br	822ff28 <rawip_usrreq+0x238>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
 822fecc:	e0bff917 	ldw	r2,-28(fp)
 822fed0:	10800117 	ldw	r2,4(r2)
 822fed4:	e0bff415 	stw	r2,-48(fp)
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822fed8:	008209b4 	movhi	r2,2086
 822fedc:	10ba7e04 	addi	r2,r2,-5640
 822fee0:	10800017 	ldw	r2,0(r2)
 822fee4:	e0bff515 	stw	r2,-44(fp)
 822fee8:	00000706 	br	822ff08 <rawip_usrreq+0x218>
               if (ifp->n_ipaddr == lhost)
 822feec:	e0bff517 	ldw	r2,-44(fp)
 822fef0:	10c00a17 	ldw	r3,40(r2)
 822fef4:	e0bff417 	ldw	r2,-48(fp)
 822fef8:	18800626 	beq	r3,r2,822ff14 <rawip_usrreq+0x224>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822fefc:	e0bff517 	ldw	r2,-44(fp)
 822ff00:	10800017 	ldw	r2,0(r2)
 822ff04:	e0bff515 	stw	r2,-44(fp)
 822ff08:	e0bff517 	ldw	r2,-44(fp)
 822ff0c:	103ff71e 	bne	r2,zero,822feec <rawip_usrreq+0x1fc>
 822ff10:	00000106 	br	822ff18 <rawip_usrreq+0x228>
               if (ifp->n_ipaddr == lhost)
                  break;
 822ff14:	0001883a 	nop
            if (ifp == NULL)
 822ff18:	e0bff517 	ldw	r2,-44(fp)
 822ff1c:	1000021e 	bne	r2,zero,822ff28 <rawip_usrreq+0x238>
               return(EADDRNOTAVAIL);
 822ff20:	00801f44 	movi	r2,125
 822ff24:	00013f06 	br	8230424 <rawip_usrreq+0x734>
         }

         /* bind the endpoint */
         ep->ipr_laddr = lhost;
 822ff28:	e0bff817 	ldw	r2,-32(fp)
 822ff2c:	e0fff417 	ldw	r3,-48(fp)
 822ff30:	10c00115 	stw	r3,4(r2)
 822ff34:	00002606 	br	822ffd0 <rawip_usrreq+0x2e0>
          *
          * if the caller-supplied address is INADDR_ANY,
          * use the wildcard address; else, use the caller-
          * supplied address
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 822ff38:	e0bff917 	ldw	r2,-28(fp)
 822ff3c:	10800117 	ldw	r2,4(r2)
 822ff40:	1000021e 	bne	r2,zero,822ff4c <rawip_usrreq+0x25c>
            fhost = 0L;
 822ff44:	e03ff315 	stw	zero,-52(fp)
 822ff48:	00000306 	br	822ff58 <rawip_usrreq+0x268>
         else
            fhost = sin->sin_addr.s_addr;
 822ff4c:	e0bff917 	ldw	r2,-28(fp)
 822ff50:	10800117 	ldw	r2,4(r2)
 822ff54:	e0bff315 	stw	r2,-52(fp)
         /* connect the IP endpoint */
         ep->ipr_faddr = fhost;
 822ff58:	e0bff817 	ldw	r2,-32(fp)
 822ff5c:	e0fff317 	ldw	r3,-52(fp)
 822ff60:	10c00215 	stw	r3,8(r2)
         /* mark the socket as connected or disconnected, as appropriate */
         if (fhost != 0L) {
 822ff64:	e0bff317 	ldw	r2,-52(fp)
 822ff68:	10000e26 	beq	r2,zero,822ffa4 <rawip_usrreq+0x2b4>
            so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 822ff6c:	e0bffc17 	ldw	r2,-16(fp)
 822ff70:	10c0088b 	ldhu	r3,34(r2)
 822ff74:	00bffcc4 	movi	r2,-13
 822ff78:	1884703a 	and	r2,r3,r2
 822ff7c:	1007883a 	mov	r3,r2
 822ff80:	e0bffc17 	ldw	r2,-16(fp)
 822ff84:	10c0088d 	sth	r3,34(r2)
            so->so_state |= SS_ISCONNECTED;
 822ff88:	e0bffc17 	ldw	r2,-16(fp)
 822ff8c:	1080088b 	ldhu	r2,34(r2)
 822ff90:	10800094 	ori	r2,r2,2
 822ff94:	1007883a 	mov	r3,r2
 822ff98:	e0bffc17 	ldw	r2,-16(fp)
 822ff9c:	10c0088d 	sth	r3,34(r2)
 822ffa0:	00000706 	br	822ffc0 <rawip_usrreq+0x2d0>
         }
         else
         {
            so->so_state &= ~SS_ISCONNECTED;
 822ffa4:	e0bffc17 	ldw	r2,-16(fp)
 822ffa8:	10c0088b 	ldhu	r3,34(r2)
 822ffac:	00bfff44 	movi	r2,-3
 822ffb0:	1884703a 	and	r2,r3,r2
 822ffb4:	1007883a 	mov	r3,r2
 822ffb8:	e0bffc17 	ldw	r2,-16(fp)
 822ffbc:	10c0088d 	sth	r3,34(r2)
         }
         /* since socket was in listen state, packets may be queued */
         sbflush(&so->so_rcv);   /* dump these now */
 822ffc0:	e0bffc17 	ldw	r2,-16(fp)
 822ffc4:	10800a04 	addi	r2,r2,40
 822ffc8:	1009883a 	mov	r4,r2
 822ffcc:	82349840 	call	8234984 <sbflush>
      }
      return 0;
 822ffd0:	0005883a 	mov	r2,zero
 822ffd4:	00011306 	br	8230424 <rawip_usrreq+0x734>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 822ffd8:	e0bffd17 	ldw	r2,-12(fp)
 822ffdc:	1000021e 	bne	r2,zero,822ffe8 <rawip_usrreq+0x2f8>
         return(EINVAL);
 822ffe0:	00800584 	movi	r2,22
 822ffe4:	00010f06 	br	8230424 <rawip_usrreq+0x734>

      ep = rawip_lookup(so);
 822ffe8:	e13ffc17 	ldw	r4,-16(fp)
 822ffec:	822facc0 	call	822facc <rawip_lookup>
 822fff0:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 822fff4:	e0bff817 	ldw	r2,-32(fp)
 822fff8:	1000041e 	bne	r2,zero,823000c <rawip_usrreq+0x31c>
      {
         m_free(m);
 822fffc:	e13ffd17 	ldw	r4,-12(fp)
 8230000:	822e58c0 	call	822e58c <m_free>
         /* may be bogus socket, but more likely the connection may 
         have closed due to ICMP dest unreachable from other side. */
         return(ECONNREFUSED);
 8230004:	00801bc4 	movi	r2,111
 8230008:	00010606 	br	8230424 <rawip_usrreq+0x734>
      }

      if (nam == NULL)  /* no sendto() info passed, must be send() */
 823000c:	e0bffe17 	ldw	r2,-8(fp)
 8230010:	10000b1e 	bne	r2,zero,8230040 <rawip_usrreq+0x350>
      {
         if (!(so->so_state & SS_ISCONNECTED))
 8230014:	e0bffc17 	ldw	r2,-16(fp)
 8230018:	1080088b 	ldhu	r2,34(r2)
 823001c:	10bfffcc 	andi	r2,r2,65535
 8230020:	1080008c 	andi	r2,r2,2
 8230024:	1000021e 	bne	r2,zero,8230030 <rawip_usrreq+0x340>
            return (ENOTCONN);
 8230028:	00802004 	movi	r2,128
 823002c:	0000fd06 	br	8230424 <rawip_usrreq+0x734>
         fhost = ep->ipr_faddr;
 8230030:	e0bff817 	ldw	r2,-32(fp)
 8230034:	10800217 	ldw	r2,8(r2)
 8230038:	e0bff315 	stw	r2,-52(fp)
 823003c:	00001406 	br	8230090 <rawip_usrreq+0x3a0>
      }
      else 
      {
         if (so->so_state & SS_ISCONNECTED)
 8230040:	e0bffc17 	ldw	r2,-16(fp)
 8230044:	1080088b 	ldhu	r2,34(r2)
 8230048:	10bfffcc 	andi	r2,r2,65535
 823004c:	1080008c 	andi	r2,r2,2
 8230050:	10000226 	beq	r2,zero,823005c <rawip_usrreq+0x36c>
            return (EISCONN);
 8230054:	00801fc4 	movi	r2,127
 8230058:	0000f206 	br	8230424 <rawip_usrreq+0x734>
         if (nam->m_len != sizeof (*sin))
 823005c:	e0bffe17 	ldw	r2,-8(fp)
 8230060:	10800217 	ldw	r2,8(r2)
 8230064:	10800420 	cmpeqi	r2,r2,16
 8230068:	1000031e 	bne	r2,zero,8230078 <rawip_usrreq+0x388>
         {
            dtrap();
 823006c:	822d5f00 	call	822d5f0 <dtrap>
            return (EINVAL);
 8230070:	00800584 	movi	r2,22
 8230074:	0000eb06 	br	8230424 <rawip_usrreq+0x734>
         }
         sin = mtod(nam, struct sockaddr_in *);
 8230078:	e0bffe17 	ldw	r2,-8(fp)
 823007c:	10800317 	ldw	r2,12(r2)
 8230080:	e0bff915 	stw	r2,-28(fp)
         fhost = sin->sin_addr.s_addr;
 8230084:	e0bff917 	ldw	r2,-28(fp)
 8230088:	10800117 	ldw	r2,4(r2)
 823008c:	e0bff315 	stw	r2,-52(fp)

      /* since our pkt->nb_buff size is tied to max packet size, we 
       * assume our raw IP datagrams are always in one mbuf and that the 
       * mbuf -- but check anyway
       */
      if (m->m_len > (unsigned)ip_raw_maxalloc(so->so_options & SO_HDRINCL))
 8230090:	e0bffd17 	ldw	r2,-12(fp)
 8230094:	14000217 	ldw	r16,8(r2)
 8230098:	e0bffc17 	ldw	r2,-16(fp)
 823009c:	10800417 	ldw	r2,16(r2)
 82300a0:	1088000c 	andi	r2,r2,8192
 82300a4:	1009883a 	mov	r4,r2
 82300a8:	82441f00 	call	82441f0 <ip_raw_maxalloc>
 82300ac:	1400032e 	bgeu	r2,r16,82300bc <rawip_usrreq+0x3cc>
      {
         dtrap(); /* should never happen */
 82300b0:	822d5f00 	call	822d5f0 <dtrap>
         return EMSGSIZE;  /* try to recover */
 82300b4:	00801e84 	movi	r2,122
 82300b8:	0000da06 	br	8230424 <rawip_usrreq+0x734>
      }
      /* get a packet buffer for send */
      pkt = ip_raw_alloc(m->m_len, so->so_options & SO_HDRINCL);
 82300bc:	e0bffd17 	ldw	r2,-12(fp)
 82300c0:	10800217 	ldw	r2,8(r2)
 82300c4:	1007883a 	mov	r3,r2
 82300c8:	e0bffc17 	ldw	r2,-16(fp)
 82300cc:	10800417 	ldw	r2,16(r2)
 82300d0:	1088000c 	andi	r2,r2,8192
 82300d4:	100b883a 	mov	r5,r2
 82300d8:	1809883a 	mov	r4,r3
 82300dc:	82440f40 	call	82440f4 <ip_raw_alloc>
 82300e0:	e0bffa15 	stw	r2,-24(fp)
      if (!pkt)
 82300e4:	e0bffa17 	ldw	r2,-24(fp)
 82300e8:	1000041e 	bne	r2,zero,82300fc <rawip_usrreq+0x40c>
      {
         m_free(m);
 82300ec:	e13ffd17 	ldw	r4,-12(fp)
 82300f0:	822e58c0 	call	822e58c <m_free>
         return ENOBUFS;   /* report buffer shortages */
 82300f4:	00801a44 	movi	r2,105
 82300f8:	0000ca06 	br	8230424 <rawip_usrreq+0x734>
      }
      MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 82300fc:	e0bffa17 	ldw	r2,-24(fp)
 8230100:	10c00317 	ldw	r3,12(r2)
 8230104:	e0bffd17 	ldw	r2,-12(fp)
 8230108:	11000317 	ldw	r4,12(r2)
 823010c:	e0bffd17 	ldw	r2,-12(fp)
 8230110:	10800217 	ldw	r2,8(r2)
 8230114:	100d883a 	mov	r6,r2
 8230118:	200b883a 	mov	r5,r4
 823011c:	1809883a 	mov	r4,r3
 8230120:	8202f6c0 	call	8202f6c <memcpy>
      pkt->nb_plen = m->m_len;
 8230124:	e0bffd17 	ldw	r2,-12(fp)
 8230128:	10c00217 	ldw	r3,8(r2)
 823012c:	e0bffa17 	ldw	r2,-24(fp)
 8230130:	10c00415 	stw	r3,16(r2)
      /* finished with mbuf, free it now */
      m_free(m);
 8230134:	e13ffd17 	ldw	r4,-12(fp)
 8230138:	822e58c0 	call	822e58c <m_free>
      pkt->fhost = fhost;
 823013c:	e0bffa17 	ldw	r2,-24(fp)
 8230140:	e0fff317 	ldw	r3,-52(fp)
 8230144:	10c00715 	stw	r3,28(r2)
       * is up; if (after all that) we don't have an interface then we
       * fail with error EADDRNOTAVAIL; and finally, if we're built
       * for a single-homed configuration where there's only one
       * interface, we might as well use it, so we do.  
       */
      if (fhost == 0xffffffff)
 8230148:	e0bff317 	ldw	r2,-52(fp)
 823014c:	10bfffd8 	cmpnei	r2,r2,-1
 8230150:	10004a1e 	bne	r2,zero,823027c <rawip_usrreq+0x58c>
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
 8230154:	e0bff817 	ldw	r2,-32(fp)
 8230158:	10800117 	ldw	r2,4(r2)
 823015c:	10001026 	beq	r2,zero,82301a0 <rawip_usrreq+0x4b0>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 8230160:	008209b4 	movhi	r2,2086
 8230164:	10ba7e04 	addi	r2,r2,-5640
 8230168:	10800017 	ldw	r2,0(r2)
 823016c:	e0bff515 	stw	r2,-44(fp)
 8230170:	00000806 	br	8230194 <rawip_usrreq+0x4a4>
               if (ifp->n_ipaddr == ep->ipr_laddr)
 8230174:	e0bff517 	ldw	r2,-44(fp)
 8230178:	10c00a17 	ldw	r3,40(r2)
 823017c:	e0bff817 	ldw	r2,-32(fp)
 8230180:	10800117 	ldw	r2,4(r2)
 8230184:	18801d26 	beq	r3,r2,82301fc <rawip_usrreq+0x50c>
      if (fhost == 0xffffffff)
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 8230188:	e0bff517 	ldw	r2,-44(fp)
 823018c:	10800017 	ldw	r2,0(r2)
 8230190:	e0bff515 	stw	r2,-44(fp)
 8230194:	e0bff517 	ldw	r2,-44(fp)
 8230198:	103ff61e 	bne	r2,zero,8230174 <rawip_usrreq+0x484>
 823019c:	00001a06 	br	8230208 <rawip_usrreq+0x518>
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 82301a0:	008209b4 	movhi	r2,2086
 82301a4:	10ba7e04 	addi	r2,r2,-5640
 82301a8:	10800017 	ldw	r2,0(r2)
 82301ac:	e0bff515 	stw	r2,-44(fp)
 82301b0:	00000f06 	br	82301f0 <rawip_usrreq+0x500>
               if ((ifp->n_flags & NF_BCAST) &&
 82301b4:	e0bff517 	ldw	r2,-44(fp)
 82301b8:	10802a17 	ldw	r2,168(r2)
 82301bc:	1080004c 	andi	r2,r2,1
 82301c0:	10000826 	beq	r2,zero,82301e4 <rawip_usrreq+0x4f4>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 82301c4:	e0bff517 	ldw	r2,-44(fp)
 82301c8:	10802717 	ldw	r2,156(r2)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if ((ifp->n_flags & NF_BCAST) &&
 82301cc:	10000526 	beq	r2,zero,82301e4 <rawip_usrreq+0x4f4>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 82301d0:	e0bff517 	ldw	r2,-44(fp)
 82301d4:	10802717 	ldw	r2,156(r2)
 82301d8:	10800617 	ldw	r2,24(r2)
 82301dc:	10800058 	cmpnei	r2,r2,1
 82301e0:	10000826 	beq	r2,zero,8230204 <rawip_usrreq+0x514>
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 82301e4:	e0bff517 	ldw	r2,-44(fp)
 82301e8:	10800017 	ldw	r2,0(r2)
 82301ec:	e0bff515 	stw	r2,-44(fp)
 82301f0:	e0bff517 	ldw	r2,-44(fp)
 82301f4:	103fef1e 	bne	r2,zero,82301b4 <rawip_usrreq+0x4c4>
 82301f8:	00000306 	br	8230208 <rawip_usrreq+0x518>
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
 82301fc:	0001883a 	nop
 8230200:	00000106 	br	8230208 <rawip_usrreq+0x518>
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if ((ifp->n_flags & NF_BCAST) &&
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
 8230204:	0001883a 	nop
         }
         if (ifp == NULL)
 8230208:	e0bff517 	ldw	r2,-44(fp)
 823020c:	1000181e 	bne	r2,zero,8230270 <rawip_usrreq+0x580>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 8230210:	008209b4 	movhi	r2,2086
 8230214:	10ba7e04 	addi	r2,r2,-5640
 8230218:	10800017 	ldw	r2,0(r2)
 823021c:	e0bff515 	stw	r2,-44(fp)
 8230220:	00000b06 	br	8230250 <rawip_usrreq+0x560>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 8230224:	e0bff517 	ldw	r2,-44(fp)
 8230228:	10802717 	ldw	r2,156(r2)
 823022c:	10000526 	beq	r2,zero,8230244 <rawip_usrreq+0x554>
 8230230:	e0bff517 	ldw	r2,-44(fp)
 8230234:	10802717 	ldw	r2,156(r2)
 8230238:	10800617 	ldw	r2,24(r2)
 823023c:	10800058 	cmpnei	r2,r2,1
 8230240:	10000626 	beq	r2,zero,823025c <rawip_usrreq+0x56c>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
         }
         if (ifp == NULL)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 8230244:	e0bff517 	ldw	r2,-44(fp)
 8230248:	10800017 	ldw	r2,0(r2)
 823024c:	e0bff515 	stw	r2,-44(fp)
 8230250:	e0bff517 	ldw	r2,-44(fp)
 8230254:	103ff31e 	bne	r2,zero,8230224 <rawip_usrreq+0x534>
 8230258:	00000106 	br	8230260 <rawip_usrreq+0x570>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
 823025c:	0001883a 	nop
            if (ifp == NULL)
 8230260:	e0bff517 	ldw	r2,-44(fp)
 8230264:	1000021e 	bne	r2,zero,8230270 <rawip_usrreq+0x580>
               return(EADDRNOTAVAIL);
 8230268:	00801f44 	movi	r2,125
 823026c:	00006d06 	br	8230424 <rawip_usrreq+0x734>
         }
         pkt->net = ifp;
 8230270:	e0bffa17 	ldw	r2,-24(fp)
 8230274:	e0fff517 	ldw	r3,-44(fp)
 8230278:	10c00615 	stw	r3,24(r2)
#ifdef IP_MULTICAST

      /* If the socket has an IP moptions structure for multicast options,
       * place a pointer to this structure in the PACKET structure.
       */
      if (so->inp_moptions)
 823027c:	e0bffc17 	ldw	r2,-16(fp)
 8230280:	10800317 	ldw	r2,12(r2)
 8230284:	10000426 	beq	r2,zero,8230298 <rawip_usrreq+0x5a8>
         pkt->imo = so->inp_moptions;
 8230288:	e0bffc17 	ldw	r2,-16(fp)
 823028c:	10c00317 	ldw	r3,12(r2)
 8230290:	e0bffa17 	ldw	r2,-24(fp)
 8230294:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

      if (so->so_options & SO_HDRINCL)
 8230298:	e0bffc17 	ldw	r2,-16(fp)
 823029c:	10800417 	ldw	r2,16(r2)
 82302a0:	1088000c 	andi	r2,r2,8192
 82302a4:	10000826 	beq	r2,zero,82302c8 <rawip_usrreq+0x5d8>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 82302a8:	0009883a 	mov	r4,zero
 82302ac:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         e = ip_raw_write(pkt);
 82302b0:	e13ffa17 	ldw	r4,-24(fp)
 82302b4:	823ff4c0 	call	823ff4c <ip_raw_write>
 82302b8:	e0bff215 	stw	r2,-56(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 82302bc:	0009883a 	mov	r4,zero
 82302c0:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
 82302c4:	00002806 	br	8230368 <rawip_usrreq+0x678>
      }
      else
      {
         pip = (struct ip *)(pkt->nb_prot - IPHSIZ);
 82302c8:	e0bffa17 	ldw	r2,-24(fp)
 82302cc:	10800317 	ldw	r2,12(r2)
 82302d0:	10bffb04 	addi	r2,r2,-20
 82302d4:	e0bffb15 	stw	r2,-20(fp)
         if (ep->ipr_laddr)
 82302d8:	e0bff817 	ldw	r2,-32(fp)
 82302dc:	10800117 	ldw	r2,4(r2)
 82302e0:	10000526 	beq	r2,zero,82302f8 <rawip_usrreq+0x608>
            pip->ip_src = ep->ipr_laddr;
 82302e4:	e0bff817 	ldw	r2,-32(fp)
 82302e8:	10c00117 	ldw	r3,4(r2)
 82302ec:	e0bffb17 	ldw	r2,-20(fp)
 82302f0:	10c00315 	stw	r3,12(r2)
 82302f4:	00000e06 	br	8230330 <rawip_usrreq+0x640>
         else
         {
            if (fhost == 0xffffffff)
 82302f8:	e0bff317 	ldw	r2,-52(fp)
 82302fc:	10bfffd8 	cmpnei	r2,r2,-1
 8230300:	1000061e 	bne	r2,zero,823031c <rawip_usrreq+0x62c>
               pip->ip_src = pkt->net->n_ipaddr;
 8230304:	e0bffa17 	ldw	r2,-24(fp)
 8230308:	10800617 	ldw	r2,24(r2)
 823030c:	10c00a17 	ldw	r3,40(r2)
 8230310:	e0bffb17 	ldw	r2,-20(fp)
 8230314:	10c00315 	stw	r3,12(r2)
 8230318:	00000506 	br	8230330 <rawip_usrreq+0x640>
            else
               pip->ip_src = ip_mymach(fhost);
 823031c:	e13ff317 	ldw	r4,-52(fp)
 8230320:	82409f80 	call	82409f8 <ip_mymach>
 8230324:	1007883a 	mov	r3,r2
 8230328:	e0bffb17 	ldw	r2,-20(fp)
 823032c:	10c00315 	stw	r3,12(r2)
         }
         pip->ip_dest = fhost;
 8230330:	e0bffb17 	ldw	r2,-20(fp)
 8230334:	e0fff317 	ldw	r3,-52(fp)
 8230338:	10c00415 	stw	r3,16(r2)
         UNLOCK_NET_RESOURCE(NET_RESID);
 823033c:	0009883a 	mov	r4,zero
 8230340:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         e = ip_write(ep->ipr_prot, pkt);
 8230344:	e0bff817 	ldw	r2,-32(fp)
 8230348:	10800503 	ldbu	r2,20(r2)
 823034c:	10803fcc 	andi	r2,r2,255
 8230350:	e17ffa17 	ldw	r5,-24(fp)
 8230354:	1009883a 	mov	r4,r2
 8230358:	823f9a80 	call	823f9a8 <ip_write>
 823035c:	e0bff215 	stw	r2,-56(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 8230360:	0009883a 	mov	r4,zero
 8230364:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      }         
      if (e < 0) 
 8230368:	e0bff217 	ldw	r2,-56(fp)
 823036c:	1000020e 	bge	r2,zero,8230378 <rawip_usrreq+0x688>
         return(e);
 8230370:	e0bff217 	ldw	r2,-56(fp)
 8230374:	00002b06 	br	8230424 <rawip_usrreq+0x734>
      return 0;
 8230378:	0005883a 	mov	r2,zero
 823037c:	00002906 	br	8230424 <rawip_usrreq+0x734>
   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 8230380:	e0bffe17 	ldw	r2,-8(fp)
 8230384:	1000021e 	bne	r2,zero,8230390 <rawip_usrreq+0x6a0>
         return(EINVAL);
 8230388:	00800584 	movi	r2,22
 823038c:	00002506 	br	8230424 <rawip_usrreq+0x734>
      sin = mtod(nam, struct sockaddr_in *);
 8230390:	e0bffe17 	ldw	r2,-8(fp)
 8230394:	10800317 	ldw	r2,12(r2)
 8230398:	e0bff915 	stw	r2,-28(fp)
      if (sin == NULL)
 823039c:	e0bff917 	ldw	r2,-28(fp)
 82303a0:	1000021e 	bne	r2,zero,82303ac <rawip_usrreq+0x6bc>
         return(EINVAL);
 82303a4:	00800584 	movi	r2,22
 82303a8:	00001e06 	br	8230424 <rawip_usrreq+0x734>
      ep = rawip_lookup(so);
 82303ac:	e13ffc17 	ldw	r4,-16(fp)
 82303b0:	822facc0 	call	822facc <rawip_lookup>
 82303b4:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 82303b8:	e0bff817 	ldw	r2,-32(fp)
 82303bc:	1000021e 	bne	r2,zero,82303c8 <rawip_usrreq+0x6d8>
         return(EINVAL);
 82303c0:	00800584 	movi	r2,22
 82303c4:	00001706 	br	8230424 <rawip_usrreq+0x734>
      sin->sin_port = 0;
 82303c8:	e0bff917 	ldw	r2,-28(fp)
 82303cc:	1000008d 	sth	zero,2(r2)
      nam->m_len = sizeof(*sin);
 82303d0:	e0bffe17 	ldw	r2,-8(fp)
 82303d4:	00c00404 	movi	r3,16
 82303d8:	10c00215 	stw	r3,8(r2)
      if (req == PRU_SOCKADDR)
 82303dc:	e0bff617 	ldw	r2,-40(fp)
 82303e0:	108003d8 	cmpnei	r2,r2,15
 82303e4:	1000051e 	bne	r2,zero,82303fc <rawip_usrreq+0x70c>
      {
         sin->sin_addr.s_addr = ep->ipr_laddr;
 82303e8:	e0bff817 	ldw	r2,-32(fp)
 82303ec:	10c00117 	ldw	r3,4(r2)
 82303f0:	e0bff917 	ldw	r2,-28(fp)
 82303f4:	10c00115 	stw	r3,4(r2)
 82303f8:	00000406 	br	823040c <rawip_usrreq+0x71c>
      }
      else /* PRU_PEERADDR */
      {
         sin->sin_addr.s_addr = ep->ipr_faddr;
 82303fc:	e0bff817 	ldw	r2,-32(fp)
 8230400:	10c00217 	ldw	r3,8(r2)
 8230404:	e0bff917 	ldw	r2,-28(fp)
 8230408:	10c00115 	stw	r3,4(r2)
      }
      return 0;
 823040c:	0005883a 	mov	r2,zero
 8230410:	00000406 	br	8230424 <rawip_usrreq+0x734>
   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 8230414:	822d5f00 	call	822d5f0 <dtrap>
      return 0;
 8230418:	0005883a 	mov	r2,zero
 823041c:	00000106 	br	8230424 <rawip_usrreq+0x734>
   case PRU_LISTEN:     /* don't support these for raw IP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 8230420:	008017c4 	movi	r2,95
   }
}
 8230424:	e6ffff04 	addi	sp,fp,-4
 8230428:	dfc00217 	ldw	ra,8(sp)
 823042c:	df000117 	ldw	fp,4(sp)
 8230430:	dc000017 	ldw	r16,0(sp)
 8230434:	dec00304 	addi	sp,sp,12
 8230438:	f800283a 	ret

0823043c <DOMAIN_CHECK>:
 */

#ifdef NPDEBUG
void
DOMAIN_CHECK(struct socket * so, int size)
{
 823043c:	defffc04 	addi	sp,sp,-16
 8230440:	dfc00315 	stw	ra,12(sp)
 8230444:	df000215 	stw	fp,8(sp)
 8230448:	df000204 	addi	fp,sp,8
 823044c:	e13ffe15 	stw	r4,-8(fp)
 8230450:	e17fff15 	stw	r5,-4(fp)
#ifdef IP_V4
   if((so->so_domain == AF_INET) &&
 8230454:	e0bffe17 	ldw	r2,-8(fp)
 8230458:	10800517 	ldw	r2,20(r2)
 823045c:	10800098 	cmpnei	r2,r2,2
 8230460:	1000041e 	bne	r2,zero,8230474 <DOMAIN_CHECK+0x38>
      (size < sizeof(struct sockaddr_in)))
 8230464:	e0bfff17 	ldw	r2,-4(fp)
#ifdef NPDEBUG
void
DOMAIN_CHECK(struct socket * so, int size)
{
#ifdef IP_V4
   if((so->so_domain == AF_INET) &&
 8230468:	10800428 	cmpgeui	r2,r2,16
 823046c:	1000011e 	bne	r2,zero,8230474 <DOMAIN_CHECK+0x38>
      (size < sizeof(struct sockaddr_in)))
   {
      dtrap(); /* programmer passed wrong structure */
 8230470:	822d5f00 	call	822d5f0 <dtrap>
      (size != sizeof(struct sockaddr_in6)))
   {
      dtrap(); /* programmer passed wrong structure */
   }
#endif   /* IP_V6 */
}
 8230474:	0001883a 	nop
 8230478:	e037883a 	mov	sp,fp
 823047c:	dfc00117 	ldw	ra,4(sp)
 8230480:	df000017 	ldw	fp,0(sp)
 8230484:	dec00204 	addi	sp,sp,8
 8230488:	f800283a 	ret

0823048c <t_socket>:

long
t_socket(int family, 
   int   type, 
   int   proto)
{
 823048c:	defffa04 	addi	sp,sp,-24
 8230490:	dfc00515 	stw	ra,20(sp)
 8230494:	df000415 	stw	fp,16(sp)
 8230498:	df000404 	addi	fp,sp,16
 823049c:	e13ffd15 	stw	r4,-12(fp)
 82304a0:	e17ffe15 	stw	r5,-8(fp)
 82304a4:	e1bfff15 	stw	r6,-4(fp)
   struct socket *   so;

   INET_TRACE (INETM_SOCKET, ("SOCK:sock:family %d, typ %d, proto %d\n",
    family, type, proto));
   LOCK_NET_RESOURCE(NET_RESID);
 82304a8:	0009883a 	mov	r4,zero
 82304ac:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   if ((so = socreate (family, type, proto)) == NULL) 
 82304b0:	e1bfff17 	ldw	r6,-4(fp)
 82304b4:	e17ffe17 	ldw	r5,-8(fp)
 82304b8:	e13ffd17 	ldw	r4,-12(fp)
 82304bc:	8231a900 	call	8231a90 <socreate>
 82304c0:	e0bffc15 	stw	r2,-16(fp)
 82304c4:	e0bffc17 	ldw	r2,-16(fp)
 82304c8:	1000041e 	bne	r2,zero,82304dc <t_socket+0x50>
   {  /* can't really return error info since no socket.... */
      UNLOCK_NET_RESOURCE(NET_RESID);
 82304cc:	0009883a 	mov	r4,zero
 82304d0:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 82304d4:	00bfffc4 	movi	r2,-1
 82304d8:	00000706 	br	82304f8 <t_socket+0x6c>
   }
   SOC_RANGE(so);
   so->so_error = 0;
 82304dc:	e0bffc17 	ldw	r2,-16(fp)
 82304e0:	10000615 	stw	zero,24(r2)
   UNLOCK_NET_RESOURCE(NET_RESID);
 82304e4:	0009883a 	mov	r4,zero
 82304e8:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   return SO2LONG(so);
 82304ec:	e0bffc17 	ldw	r2,-16(fp)
 82304f0:	1004d0ba 	srli	r2,r2,2
 82304f4:	10800804 	addi	r2,r2,32
}
 82304f8:	e037883a 	mov	sp,fp
 82304fc:	dfc00117 	ldw	ra,4(sp)
 8230500:	df000017 	ldw	fp,0(sp)
 8230504:	dec00204 	addi	sp,sp,8
 8230508:	f800283a 	ret

0823050c <t_bind>:

int
t_bind (long s, 
   struct sockaddr * addr,
   int addrlen)
{
 823050c:	defff204 	addi	sp,sp,-56
 8230510:	dfc00d15 	stw	ra,52(sp)
 8230514:	df000c15 	stw	fp,48(sp)
 8230518:	df000c04 	addi	fp,sp,48
 823051c:	e13ffd15 	stw	r4,-12(fp)
 8230520:	e17ffe15 	stw	r5,-8(fp)
 8230524:	e1bfff15 	stw	r6,-4(fp)
   struct sockaddr   sa;
   struct sockaddr * sap;
   struct socket *   so;
   int               err;

   so = LONG2SO(s);  /* convert long to socket */
 8230528:	e0bffd17 	ldw	r2,-12(fp)
 823052c:	10bff804 	addi	r2,r2,-32
 8230530:	1085883a 	add	r2,r2,r2
 8230534:	1085883a 	add	r2,r2,r2
 8230538:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 823053c:	008209b4 	movhi	r2,2086
 8230540:	10b97a04 	addi	r2,r2,-6680
 8230544:	e0bff515 	stw	r2,-44(fp)
 8230548:	00000606 	br	8230564 <t_bind+0x58>
 823054c:	e0fff517 	ldw	r3,-44(fp)
 8230550:	e0bff617 	ldw	r2,-40(fp)
 8230554:	18800626 	beq	r3,r2,8230570 <t_bind+0x64>
 8230558:	e0bff517 	ldw	r2,-44(fp)
 823055c:	10800017 	ldw	r2,0(r2)
 8230560:	e0bff515 	stw	r2,-44(fp)
 8230564:	e0bff517 	ldw	r2,-44(fp)
 8230568:	103ff81e 	bne	r2,zero,823054c <t_bind+0x40>
 823056c:	00000106 	br	8230574 <t_bind+0x68>
 8230570:	0001883a 	nop
 8230574:	e0fff517 	ldw	r3,-44(fp)
 8230578:	e0bff617 	ldw	r2,-40(fp)
 823057c:	18800326 	beq	r3,r2,823058c <t_bind+0x80>
 8230580:	822d5f00 	call	822d5f0 <dtrap>
 8230584:	00bfffc4 	movi	r2,-1
 8230588:	00003406 	br	823065c <t_bind+0x150>
   DOMAIN_CHECK(so, addrlen);
 823058c:	e17fff17 	ldw	r5,-4(fp)
 8230590:	e13ff617 	ldw	r4,-40(fp)
 8230594:	823043c0 	call	823043c <DOMAIN_CHECK>

   so->so_error = 0;
 8230598:	e0bff617 	ldw	r2,-40(fp)
 823059c:	10000615 	stw	zero,24(r2)
   if (addr == (struct sockaddr *)NULL) 
 82305a0:	e0bffe17 	ldw	r2,-8(fp)
 82305a4:	10000d1e 	bne	r2,zero,82305dc <t_bind+0xd0>
   {
      MEMSET ((void *)&sa, 0, sizeof(sa));
 82305a8:	e0bff904 	addi	r2,fp,-28
 82305ac:	01800404 	movi	r6,16
 82305b0:	000b883a 	mov	r5,zero
 82305b4:	1009883a 	mov	r4,r2
 82305b8:	82032100 	call	8203210 <memset>
      addrlen = sizeof(sa);
 82305bc:	00800404 	movi	r2,16
 82305c0:	e0bfff15 	stw	r2,-4(fp)
      sa.sa_family = so->so_domain;
 82305c4:	e0bff617 	ldw	r2,-40(fp)
 82305c8:	10800517 	ldw	r2,20(r2)
 82305cc:	e0bff90d 	sth	r2,-28(fp)
      sap = &sa;
 82305d0:	e0bff904 	addi	r2,fp,-28
 82305d4:	e0bff415 	stw	r2,-48(fp)
 82305d8:	00000206 	br	82305e4 <t_bind+0xd8>
   } else
      sap = addr;
 82305dc:	e0bffe17 	ldw	r2,-8(fp)
 82305e0:	e0bff415 	stw	r2,-48(fp)

   if ((nam = sockargs (sap, addrlen, MT_SONAME)) == NULL) 
 82305e4:	01800244 	movi	r6,9
 82305e8:	e17fff17 	ldw	r5,-4(fp)
 82305ec:	e13ff417 	ldw	r4,-48(fp)
 82305f0:	823196c0 	call	823196c <sockargs>
 82305f4:	e0bff715 	stw	r2,-36(fp)
 82305f8:	e0bff717 	ldw	r2,-36(fp)
 82305fc:	1000051e 	bne	r2,zero,8230614 <t_bind+0x108>
   {
      so->so_error = ENOMEM;
 8230600:	e0bff617 	ldw	r2,-40(fp)
 8230604:	00c00304 	movi	r3,12
 8230608:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 823060c:	00bfffc4 	movi	r2,-1
 8230610:	00001206 	br	823065c <t_bind+0x150>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 8230614:	0009883a 	mov	r4,zero
 8230618:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   err = sobind (so, nam);
 823061c:	e17ff717 	ldw	r5,-36(fp)
 8230620:	e13ff617 	ldw	r4,-40(fp)
 8230624:	8231c380 	call	8231c38 <sobind>
 8230628:	e0bff815 	stw	r2,-32(fp)
   m_freem(nam);
 823062c:	e13ff717 	ldw	r4,-36(fp)
 8230630:	822e6940 	call	822e694 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 8230634:	0009883a 	mov	r4,zero
 8230638:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   if (err) 
 823063c:	e0bff817 	ldw	r2,-32(fp)
 8230640:	10000526 	beq	r2,zero,8230658 <t_bind+0x14c>
   {
      so->so_error = err;
 8230644:	e0bff617 	ldw	r2,-40(fp)
 8230648:	e0fff817 	ldw	r3,-32(fp)
 823064c:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8230650:	00bfffc4 	movi	r2,-1
 8230654:	00000106 	br	823065c <t_bind+0x150>
   }
   return 0;
 8230658:	0005883a 	mov	r2,zero
}
 823065c:	e037883a 	mov	sp,fp
 8230660:	dfc00117 	ldw	ra,4(sp)
 8230664:	df000017 	ldw	fp,0(sp)
 8230668:	dec00204 	addi	sp,sp,8
 823066c:	f800283a 	ret

08230670 <t_listen>:
 */

int
t_listen(long s, 
   int   backlog)
{
 8230670:	defff904 	addi	sp,sp,-28
 8230674:	dfc00615 	stw	ra,24(sp)
 8230678:	df000515 	stw	fp,20(sp)
 823067c:	df000504 	addi	fp,sp,20
 8230680:	e13ffe15 	stw	r4,-8(fp)
 8230684:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);  /* convert long to socket */
 8230688:	e0bffe17 	ldw	r2,-8(fp)
 823068c:	10bff804 	addi	r2,r2,-32
 8230690:	1085883a 	add	r2,r2,r2
 8230694:	1085883a 	add	r2,r2,r2
 8230698:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 823069c:	008209b4 	movhi	r2,2086
 82306a0:	10b97a04 	addi	r2,r2,-6680
 82306a4:	e0bffb15 	stw	r2,-20(fp)
 82306a8:	00000606 	br	82306c4 <t_listen+0x54>
 82306ac:	e0fffb17 	ldw	r3,-20(fp)
 82306b0:	e0bffc17 	ldw	r2,-16(fp)
 82306b4:	18800626 	beq	r3,r2,82306d0 <t_listen+0x60>
 82306b8:	e0bffb17 	ldw	r2,-20(fp)
 82306bc:	10800017 	ldw	r2,0(r2)
 82306c0:	e0bffb15 	stw	r2,-20(fp)
 82306c4:	e0bffb17 	ldw	r2,-20(fp)
 82306c8:	103ff81e 	bne	r2,zero,82306ac <t_listen+0x3c>
 82306cc:	00000106 	br	82306d4 <t_listen+0x64>
 82306d0:	0001883a 	nop
 82306d4:	e0fffb17 	ldw	r3,-20(fp)
 82306d8:	e0bffc17 	ldw	r2,-16(fp)
 82306dc:	18800326 	beq	r3,r2,82306ec <t_listen+0x7c>
 82306e0:	822d5f00 	call	822d5f0 <dtrap>
 82306e4:	00bfffc4 	movi	r2,-1
 82306e8:	00001206 	br	8230734 <t_listen+0xc4>
   so->so_error = 0;
 82306ec:	e0bffc17 	ldw	r2,-16(fp)
 82306f0:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("SOCK:listen:qlen %d\n", backlog));

   LOCK_NET_RESOURCE(NET_RESID);
 82306f4:	0009883a 	mov	r4,zero
 82306f8:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   err = solisten (so, backlog);
 82306fc:	e17fff17 	ldw	r5,-4(fp)
 8230700:	e13ffc17 	ldw	r4,-16(fp)
 8230704:	8231c940 	call	8231c94 <solisten>
 8230708:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 823070c:	0009883a 	mov	r4,zero
 8230710:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 8230714:	e0bffd17 	ldw	r2,-12(fp)
 8230718:	10000526 	beq	r2,zero,8230730 <t_listen+0xc0>
   {
      so->so_error = err;
 823071c:	e0bffc17 	ldw	r2,-16(fp)
 8230720:	e0fffd17 	ldw	r3,-12(fp)
 8230724:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8230728:	00bfffc4 	movi	r2,-1
 823072c:	00000106 	br	8230734 <t_listen+0xc4>
   }
   return 0;
 8230730:	0005883a 	mov	r2,zero
}
 8230734:	e037883a 	mov	sp,fp
 8230738:	dfc00117 	ldw	ra,4(sp)
 823073c:	df000017 	ldw	fp,0(sp)
 8230740:	dec00204 	addi	sp,sp,8
 8230744:	f800283a 	ret

08230748 <t_accept>:

long
t_accept(long s, 
   struct sockaddr * addr,
   int * addrlen)
{
 8230748:	defff704 	addi	sp,sp,-36
 823074c:	dfc00815 	stw	ra,32(sp)
 8230750:	df000715 	stw	fp,28(sp)
 8230754:	df000704 	addi	fp,sp,28
 8230758:	e13ffd15 	stw	r4,-12(fp)
 823075c:	e17ffe15 	stw	r5,-8(fp)
 8230760:	e1bfff15 	stw	r6,-4(fp)
   char logbuf[10];
#endif
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 8230764:	e0bffd17 	ldw	r2,-12(fp)
 8230768:	10bff804 	addi	r2,r2,-32
 823076c:	1085883a 	add	r2,r2,r2
 8230770:	1085883a 	add	r2,r2,r2
 8230774:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 8230778:	008209b4 	movhi	r2,2086
 823077c:	10b97a04 	addi	r2,r2,-6680
 8230780:	e0bff915 	stw	r2,-28(fp)
 8230784:	00000606 	br	82307a0 <t_accept+0x58>
 8230788:	e0fff917 	ldw	r3,-28(fp)
 823078c:	e0bffa17 	ldw	r2,-24(fp)
 8230790:	18800626 	beq	r3,r2,82307ac <t_accept+0x64>
 8230794:	e0bff917 	ldw	r2,-28(fp)
 8230798:	10800017 	ldw	r2,0(r2)
 823079c:	e0bff915 	stw	r2,-28(fp)
 82307a0:	e0bff917 	ldw	r2,-28(fp)
 82307a4:	103ff81e 	bne	r2,zero,8230788 <t_accept+0x40>
 82307a8:	00000106 	br	82307b0 <t_accept+0x68>
 82307ac:	0001883a 	nop
 82307b0:	e0fff917 	ldw	r3,-28(fp)
 82307b4:	e0bffa17 	ldw	r2,-24(fp)
 82307b8:	18800326 	beq	r3,r2,82307c8 <t_accept+0x80>
 82307bc:	822d5f00 	call	822d5f0 <dtrap>
 82307c0:	00bfffc4 	movi	r2,-1
 82307c4:	00007006 	br	8230988 <t_accept+0x240>
   DOMAIN_CHECK(so, *addrlen);
 82307c8:	e0bfff17 	ldw	r2,-4(fp)
 82307cc:	10800017 	ldw	r2,0(r2)
 82307d0:	100b883a 	mov	r5,r2
 82307d4:	e13ffa17 	ldw	r4,-24(fp)
 82307d8:	823043c0 	call	823043c <DOMAIN_CHECK>

   so->so_error = 0;
 82307dc:	e0bffa17 	ldw	r2,-24(fp)
 82307e0:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
      ("INET:accept:so %x so_qlen %d so_state %x\n", so, so->so_qlen, so->so_state));
   if ((so->so_options & SO_ACCEPTCONN) == 0)
 82307e4:	e0bffa17 	ldw	r2,-24(fp)
 82307e8:	10800417 	ldw	r2,16(r2)
 82307ec:	1080008c 	andi	r2,r2,2
 82307f0:	1000051e 	bne	r2,zero,8230808 <t_accept+0xc0>
   {
      so->so_error = EINVAL;
 82307f4:	e0bffa17 	ldw	r2,-24(fp)
 82307f8:	00c00584 	movi	r3,22
 82307fc:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 8230800:	00bfffc4 	movi	r2,-1
 8230804:	00006006 	br	8230988 <t_accept+0x240>
   }
   if ((so->so_state & SS_NBIO) && so->so_qlen == 0)
 8230808:	e0bffa17 	ldw	r2,-24(fp)
 823080c:	1080088b 	ldhu	r2,34(r2)
 8230810:	10bfffcc 	andi	r2,r2,65535
 8230814:	1080400c 	andi	r2,r2,256
 8230818:	10000b26 	beq	r2,zero,8230848 <t_accept+0x100>
 823081c:	e0bffa17 	ldw	r2,-24(fp)
 8230820:	10801e43 	ldbu	r2,121(r2)
 8230824:	10803fcc 	andi	r2,r2,255
 8230828:	1080201c 	xori	r2,r2,128
 823082c:	10bfe004 	addi	r2,r2,-128
 8230830:	1000051e 	bne	r2,zero,8230848 <t_accept+0x100>
   {
      so->so_error = EWOULDBLOCK;
 8230834:	e0bffa17 	ldw	r2,-24(fp)
 8230838:	00c002c4 	movi	r3,11
 823083c:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 8230840:	00bfffc4 	movi	r2,-1
 8230844:	00005006 	br	8230988 <t_accept+0x240>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 8230848:	0009883a 	mov	r4,zero
 823084c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   while (so->so_qlen == 0 && so->so_error == 0)
 8230850:	00001006 	br	8230894 <t_accept+0x14c>
   {
      if (so->so_state & SS_CANTRCVMORE)
 8230854:	e0bffa17 	ldw	r2,-24(fp)
 8230858:	1080088b 	ldhu	r2,34(r2)
 823085c:	10bfffcc 	andi	r2,r2,65535
 8230860:	1080080c 	andi	r2,r2,32
 8230864:	10000726 	beq	r2,zero,8230884 <t_accept+0x13c>
      {
         so->so_error = ECONNABORTED;
 8230868:	e0bffa17 	ldw	r2,-24(fp)
 823086c:	00c01c44 	movi	r3,113
 8230870:	10c00615 	stw	r3,24(r2)
         UNLOCK_NET_RESOURCE(NET_RESID);
 8230874:	0009883a 	mov	r4,zero
 8230878:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 823087c:	00bfffc4 	movi	r2,-1
 8230880:	00004106 	br	8230988 <t_accept+0x240>
      }
      tcp_sleep ((char *)&so->so_timeo);
 8230884:	e0bffa17 	ldw	r2,-24(fp)
 8230888:	10800904 	addi	r2,r2,36
 823088c:	1009883a 	mov	r4,r2
 8230890:	82295900 	call	8229590 <tcp_sleep>
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
   }
   LOCK_NET_RESOURCE(NET_RESID);
   while (so->so_qlen == 0 && so->so_error == 0)
 8230894:	e0bffa17 	ldw	r2,-24(fp)
 8230898:	10801e43 	ldbu	r2,121(r2)
 823089c:	10803fcc 	andi	r2,r2,255
 82308a0:	1080201c 	xori	r2,r2,128
 82308a4:	10bfe004 	addi	r2,r2,-128
 82308a8:	1000031e 	bne	r2,zero,82308b8 <t_accept+0x170>
 82308ac:	e0bffa17 	ldw	r2,-24(fp)
 82308b0:	10800617 	ldw	r2,24(r2)
 82308b4:	103fe726 	beq	r2,zero,8230854 <t_accept+0x10c>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return SOCKET_ERROR;
      }
      tcp_sleep ((char *)&so->so_timeo);
   }
   if (so->so_error)
 82308b8:	e0bffa17 	ldw	r2,-24(fp)
 82308bc:	10800617 	ldw	r2,24(r2)
 82308c0:	10000426 	beq	r2,zero,82308d4 <t_accept+0x18c>
   {
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 82308c4:	0009883a 	mov	r4,zero
 82308c8:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 82308cc:	00bfffc4 	movi	r2,-1
 82308d0:	00002d06 	br	8230988 <t_accept+0x240>
   }
   nam = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 82308d4:	01400404 	movi	r5,16
 82308d8:	01000244 	movi	r4,9
 82308dc:	822e4040 	call	822e404 <m_getnbuf>
 82308e0:	e0bffb15 	stw	r2,-20(fp)
   if (nam == NULL) 
 82308e4:	e0bffb17 	ldw	r2,-20(fp)
 82308e8:	1000071e 	bne	r2,zero,8230908 <t_accept+0x1c0>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 82308ec:	0009883a 	mov	r4,zero
 82308f0:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      so->so_error = ENOMEM;
 82308f4:	e0bffa17 	ldw	r2,-24(fp)
 82308f8:	00c00304 	movi	r3,12
 82308fc:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 8230900:	00bfffc4 	movi	r2,-1
 8230904:	00002006 	br	8230988 <t_accept+0x240>
   }
   { 
      struct socket *aso = so->so_q;
 8230908:	e0bffa17 	ldw	r2,-24(fp)
 823090c:	10801d17 	ldw	r2,116(r2)
 8230910:	e0bffc15 	stw	r2,-16(fp)
      if (soqremque (aso, 1) == 0)
 8230914:	01400044 	movi	r5,1
 8230918:	e13ffc17 	ldw	r4,-16(fp)
 823091c:	82340400 	call	8234040 <soqremque>
 8230920:	1000031e 	bne	r2,zero,8230930 <t_accept+0x1e8>
         panic("accept");
 8230924:	01020974 	movhi	r4,2085
 8230928:	21039604 	addi	r4,r4,3672
 823092c:	8228ca40 	call	8228ca4 <panic>
      so = aso;
 8230930:	e0bffc17 	ldw	r2,-16(fp)
 8230934:	e0bffa15 	stw	r2,-24(fp)
   }
   (void)soaccept (so, nam);
 8230938:	e17ffb17 	ldw	r5,-20(fp)
 823093c:	e13ffa17 	ldw	r4,-24(fp)
 8230940:	82321800 	call	8232180 <soaccept>
      INET_TRACE (INETM_SOCKET, ("INET:accept:done so %lx port %d addr %lx\n",
       so, sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_INET */
   /* return the addressing info in the passed structure */
   if (addr != NULL)
 8230944:	e0bffe17 	ldw	r2,-8(fp)
 8230948:	10000826 	beq	r2,zero,823096c <t_accept+0x224>
      MEMCPY(addr, nam->m_data, *addrlen);
 823094c:	e0bffb17 	ldw	r2,-20(fp)
 8230950:	10c00317 	ldw	r3,12(r2)
 8230954:	e0bfff17 	ldw	r2,-4(fp)
 8230958:	10800017 	ldw	r2,0(r2)
 823095c:	100d883a 	mov	r6,r2
 8230960:	180b883a 	mov	r5,r3
 8230964:	e13ffe17 	ldw	r4,-8(fp)
 8230968:	8202f6c0 	call	8202f6c <memcpy>
   m_freem (nam);
 823096c:	e13ffb17 	ldw	r4,-20(fp)
 8230970:	822e6940 	call	822e694 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 8230974:	0009883a 	mov	r4,zero
 8230978:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   SOC_RANGE(so);
   return SO2LONG(so);
 823097c:	e0bffa17 	ldw	r2,-24(fp)
 8230980:	1004d0ba 	srli	r2,r2,2
 8230984:	10800804 	addi	r2,r2,32
}
 8230988:	e037883a 	mov	sp,fp
 823098c:	dfc00117 	ldw	ra,4(sp)
 8230990:	df000017 	ldw	fp,0(sp)
 8230994:	dec00204 	addi	sp,sp,8
 8230998:	f800283a 	ret

0823099c <t_connect>:

int
t_connect(long s, 
   struct sockaddr * addr,
   int   addrlen)
{
 823099c:	defff804 	addi	sp,sp,-32
 82309a0:	dfc00715 	stw	ra,28(sp)
 82309a4:	df000615 	stw	fp,24(sp)
 82309a8:	df000604 	addi	fp,sp,24
 82309ac:	e13ffd15 	stw	r4,-12(fp)
 82309b0:	e17ffe15 	stw	r5,-8(fp)
 82309b4:	e1bfff15 	stw	r6,-4(fp)
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 82309b8:	e0bffd17 	ldw	r2,-12(fp)
 82309bc:	10bff804 	addi	r2,r2,-32
 82309c0:	1085883a 	add	r2,r2,r2
 82309c4:	1085883a 	add	r2,r2,r2
 82309c8:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 82309cc:	008209b4 	movhi	r2,2086
 82309d0:	10b97a04 	addi	r2,r2,-6680
 82309d4:	e0bffa15 	stw	r2,-24(fp)
 82309d8:	00000606 	br	82309f4 <t_connect+0x58>
 82309dc:	e0fffa17 	ldw	r3,-24(fp)
 82309e0:	e0bffb17 	ldw	r2,-20(fp)
 82309e4:	18800626 	beq	r3,r2,8230a00 <t_connect+0x64>
 82309e8:	e0bffa17 	ldw	r2,-24(fp)
 82309ec:	10800017 	ldw	r2,0(r2)
 82309f0:	e0bffa15 	stw	r2,-24(fp)
 82309f4:	e0bffa17 	ldw	r2,-24(fp)
 82309f8:	103ff81e 	bne	r2,zero,82309dc <t_connect+0x40>
 82309fc:	00000106 	br	8230a04 <t_connect+0x68>
 8230a00:	0001883a 	nop
 8230a04:	e0fffa17 	ldw	r3,-24(fp)
 8230a08:	e0bffb17 	ldw	r2,-20(fp)
 8230a0c:	18800326 	beq	r3,r2,8230a1c <t_connect+0x80>
 8230a10:	822d5f00 	call	822d5f0 <dtrap>
 8230a14:	00bfffc4 	movi	r2,-1
 8230a18:	00007606 	br	8230bf4 <t_connect+0x258>
   DOMAIN_CHECK(so, addrlen);
 8230a1c:	e17fff17 	ldw	r5,-4(fp)
 8230a20:	e13ffb17 	ldw	r4,-20(fp)
 8230a24:	823043c0 	call	823043c <DOMAIN_CHECK>

#ifdef NB_CONNECT
   /* need to test non blocking connect bits in case this is a 
      poll of a previous request */
   if (so->so_state & SS_NBIO)
 8230a28:	e0bffb17 	ldw	r2,-20(fp)
 8230a2c:	1080088b 	ldhu	r2,34(r2)
 8230a30:	10bfffcc 	andi	r2,r2,65535
 8230a34:	1080400c 	andi	r2,r2,256
 8230a38:	10002426 	beq	r2,zero,8230acc <t_connect+0x130>
   {
      if (so->so_state & SS_ISCONNECTING) /* still trying */
 8230a3c:	e0bffb17 	ldw	r2,-20(fp)
 8230a40:	1080088b 	ldhu	r2,34(r2)
 8230a44:	10bfffcc 	andi	r2,r2,65535
 8230a48:	1080010c 	andi	r2,r2,4
 8230a4c:	10000526 	beq	r2,zero,8230a64 <t_connect+0xc8>
      {
         so->so_error = EINPROGRESS;
 8230a50:	e0bffb17 	ldw	r2,-20(fp)
 8230a54:	00c01dc4 	movi	r3,119
 8230a58:	10c00615 	stw	r3,24(r2)
         return SOCKET_ERROR;
 8230a5c:	00bfffc4 	movi	r2,-1
 8230a60:	00006406 	br	8230bf4 <t_connect+0x258>
      }
      if (so->so_state & SS_ISCONNECTED)  /* connected OK */
 8230a64:	e0bffb17 	ldw	r2,-20(fp)
 8230a68:	1080088b 	ldhu	r2,34(r2)
 8230a6c:	10bfffcc 	andi	r2,r2,65535
 8230a70:	1080008c 	andi	r2,r2,2
 8230a74:	10000426 	beq	r2,zero,8230a88 <t_connect+0xec>
      {
         so->so_error = 0;
 8230a78:	e0bffb17 	ldw	r2,-20(fp)
 8230a7c:	10000615 	stw	zero,24(r2)
         return 0;
 8230a80:	0005883a 	mov	r2,zero
 8230a84:	00005b06 	br	8230bf4 <t_connect+0x258>
      }
      if (so->so_state & SS_WASCONNECTING)
 8230a88:	e0bffb17 	ldw	r2,-20(fp)
 8230a8c:	1080088b 	ldhu	r2,34(r2)
 8230a90:	10bfffcc 	andi	r2,r2,65535
 8230a94:	1088000c 	andi	r2,r2,8192
 8230a98:	10000c26 	beq	r2,zero,8230acc <t_connect+0x130>
      {
         so->so_state &= ~SS_WASCONNECTING;
 8230a9c:	e0bffb17 	ldw	r2,-20(fp)
 8230aa0:	10c0088b 	ldhu	r3,34(r2)
 8230aa4:	00b7ffc4 	movi	r2,-8193
 8230aa8:	1884703a 	and	r2,r3,r2
 8230aac:	1007883a 	mov	r3,r2
 8230ab0:	e0bffb17 	ldw	r2,-20(fp)
 8230ab4:	10c0088d 	sth	r3,34(r2)
         if (so->so_error) /* connect error - maybe timeout */
 8230ab8:	e0bffb17 	ldw	r2,-20(fp)
 8230abc:	10800617 	ldw	r2,24(r2)
 8230ac0:	10000226 	beq	r2,zero,8230acc <t_connect+0x130>
            return SOCKET_ERROR;
 8230ac4:	00bfffc4 	movi	r2,-1
 8230ac8:	00004a06 	br	8230bf4 <t_connect+0x258>
      }
   }
#endif   /*  NB_CONNECT */

   so->so_error = 0;
 8230acc:	e0bffb17 	ldw	r2,-20(fp)
 8230ad0:	10000615 	stw	zero,24(r2)

   if ((nam = sockargs (addr, addrlen, MT_SONAME))
 8230ad4:	01800244 	movi	r6,9
 8230ad8:	e17fff17 	ldw	r5,-4(fp)
 8230adc:	e13ffe17 	ldw	r4,-8(fp)
 8230ae0:	823196c0 	call	823196c <sockargs>
 8230ae4:	e0bffc15 	stw	r2,-16(fp)
 8230ae8:	e0bffc17 	ldw	r2,-16(fp)
 8230aec:	1000051e 	bne	r2,zero,8230b04 <t_connect+0x168>
       == NULL)
   {
      so->so_error = ENOMEM;
 8230af0:	e0bffb17 	ldw	r2,-20(fp)
 8230af4:	00c00304 	movi	r3,12
 8230af8:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8230afc:	00bfffc4 	movi	r2,-1
 8230b00:	00003c06 	br	8230bf4 <t_connect+0x258>
      INET_TRACE (INETM_SOCKET, ("INET: connect, port %d addr %lx\n",
       sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_DEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 8230b04:	0009883a 	mov	r4,zero
 8230b08:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   if ((so->so_error = soconnect (so, nam)) != 0)
 8230b0c:	e17ffc17 	ldw	r5,-16(fp)
 8230b10:	e13ffb17 	ldw	r4,-20(fp)
 8230b14:	82322180 	call	8232218 <soconnect>
 8230b18:	1007883a 	mov	r3,r2
 8230b1c:	e0bffb17 	ldw	r2,-20(fp)
 8230b20:	10c00615 	stw	r3,24(r2)
 8230b24:	e0bffb17 	ldw	r2,-20(fp)
 8230b28:	10800617 	ldw	r2,24(r2)
 8230b2c:	10001b1e 	bne	r2,zero,8230b9c <t_connect+0x200>
      goto bad;

#ifdef NB_CONNECT
   /* need to test non blocking connect bits after soconnect() call */
   if ((so->so_state & SS_NBIO)&& (so->so_state & SS_ISCONNECTING))
 8230b30:	e0bffb17 	ldw	r2,-20(fp)
 8230b34:	1080088b 	ldhu	r2,34(r2)
 8230b38:	10bfffcc 	andi	r2,r2,65535
 8230b3c:	1080400c 	andi	r2,r2,256
 8230b40:	10000d26 	beq	r2,zero,8230b78 <t_connect+0x1dc>
 8230b44:	e0bffb17 	ldw	r2,-20(fp)
 8230b48:	1080088b 	ldhu	r2,34(r2)
 8230b4c:	10bfffcc 	andi	r2,r2,65535
 8230b50:	1080010c 	andi	r2,r2,4
 8230b54:	10000826 	beq	r2,zero,8230b78 <t_connect+0x1dc>
   {
      so->so_error = EINPROGRESS;
 8230b58:	e0bffb17 	ldw	r2,-20(fp)
 8230b5c:	00c01dc4 	movi	r3,119
 8230b60:	10c00615 	stw	r3,24(r2)
      goto bad;
 8230b64:	00000e06 	br	8230ba0 <t_connect+0x204>
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
   {
      tcp_sleep ((char *)&so->so_timeo);
 8230b68:	e0bffb17 	ldw	r2,-20(fp)
 8230b6c:	10800904 	addi	r2,r2,36
 8230b70:	1009883a 	mov	r4,r2
 8230b74:	82295900 	call	8229590 <tcp_sleep>
   }
#endif   /*  NB_CONNECT */
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
 8230b78:	e0bffb17 	ldw	r2,-20(fp)
 8230b7c:	1080088b 	ldhu	r2,34(r2)
 8230b80:	10bfffcc 	andi	r2,r2,65535
 8230b84:	1080010c 	andi	r2,r2,4
 8230b88:	10000526 	beq	r2,zero,8230ba0 <t_connect+0x204>
 8230b8c:	e0bffb17 	ldw	r2,-20(fp)
 8230b90:	10800617 	ldw	r2,24(r2)
 8230b94:	103ff426 	beq	r2,zero,8230b68 <t_connect+0x1cc>
 8230b98:	00000106 	br	8230ba0 <t_connect+0x204>
   }
#endif   /* TRACE_DEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
   if ((so->so_error = soconnect (so, nam)) != 0)
      goto bad;
 8230b9c:	0001883a 	nop
   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
   {
      tcp_sleep ((char *)&so->so_timeo);
   }
bad:
   if (so->so_error != EINPROGRESS)
 8230ba0:	e0bffb17 	ldw	r2,-20(fp)
 8230ba4:	10800617 	ldw	r2,24(r2)
 8230ba8:	10801de0 	cmpeqi	r2,r2,119
 8230bac:	1000071e 	bne	r2,zero,8230bcc <t_connect+0x230>
      so->so_state &= ~(SS_ISCONNECTING|SS_WASCONNECTING);
 8230bb0:	e0bffb17 	ldw	r2,-20(fp)
 8230bb4:	10c0088b 	ldhu	r3,34(r2)
 8230bb8:	00b7fec4 	movi	r2,-8197
 8230bbc:	1884703a 	and	r2,r3,r2
 8230bc0:	1007883a 	mov	r3,r2
 8230bc4:	e0bffb17 	ldw	r2,-20(fp)
 8230bc8:	10c0088d 	sth	r3,34(r2)
   m_freem (nam);
 8230bcc:	e13ffc17 	ldw	r4,-16(fp)
 8230bd0:	822e6940 	call	822e694 <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 8230bd4:	0009883a 	mov	r4,zero
 8230bd8:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   if (so->so_error)
 8230bdc:	e0bffb17 	ldw	r2,-20(fp)
 8230be0:	10800617 	ldw	r2,24(r2)
 8230be4:	10000226 	beq	r2,zero,8230bf0 <t_connect+0x254>
   {
/*      printf("t_connect(): so_error = %d\n", so->so_error);*/
      return SOCKET_ERROR;
 8230be8:	00bfffc4 	movi	r2,-1
 8230bec:	00000106 	br	8230bf4 <t_connect+0x258>

   }
      return 0;
 8230bf0:	0005883a 	mov	r2,zero
}
 8230bf4:	e037883a 	mov	sp,fp
 8230bf8:	dfc00117 	ldw	ra,4(sp)
 8230bfc:	df000017 	ldw	fp,0(sp)
 8230c00:	dec00204 	addi	sp,sp,8
 8230c04:	f800283a 	ret

08230c08 <t_getpeername>:
 * RETURNS: 
 */

int
t_getpeername(long s, struct sockaddr * addr, int * addrlen)
{
 8230c08:	defffb04 	addi	sp,sp,-20
 8230c0c:	dfc00415 	stw	ra,16(sp)
 8230c10:	df000315 	stw	fp,12(sp)
 8230c14:	df000304 	addi	fp,sp,12
 8230c18:	e13ffd15 	stw	r4,-12(fp)
 8230c1c:	e17ffe15 	stw	r5,-8(fp)
 8230c20:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_PEERADDR));
 8230c24:	01c00404 	movi	r7,16
 8230c28:	e1bfff17 	ldw	r6,-4(fp)
 8230c2c:	e17ffe17 	ldw	r5,-8(fp)
 8230c30:	e13ffd17 	ldw	r4,-12(fp)
 8230c34:	8230c900 	call	8230c90 <t_getname>
}
 8230c38:	e037883a 	mov	sp,fp
 8230c3c:	dfc00117 	ldw	ra,4(sp)
 8230c40:	df000017 	ldw	fp,0(sp)
 8230c44:	dec00204 	addi	sp,sp,8
 8230c48:	f800283a 	ret

08230c4c <t_getsockname>:
 * RETURNS: 
 */

int 
t_getsockname(long s, struct sockaddr * addr, int * addrlen)
{
 8230c4c:	defffb04 	addi	sp,sp,-20
 8230c50:	dfc00415 	stw	ra,16(sp)
 8230c54:	df000315 	stw	fp,12(sp)
 8230c58:	df000304 	addi	fp,sp,12
 8230c5c:	e13ffd15 	stw	r4,-12(fp)
 8230c60:	e17ffe15 	stw	r5,-8(fp)
 8230c64:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_SOCKADDR));
 8230c68:	01c003c4 	movi	r7,15
 8230c6c:	e1bfff17 	ldw	r6,-4(fp)
 8230c70:	e17ffe17 	ldw	r5,-8(fp)
 8230c74:	e13ffd17 	ldw	r4,-12(fp)
 8230c78:	8230c900 	call	8230c90 <t_getname>
}
 8230c7c:	e037883a 	mov	sp,fp
 8230c80:	dfc00117 	ldw	ra,4(sp)
 8230c84:	df000017 	ldw	fp,0(sp)
 8230c88:	dec00204 	addi	sp,sp,8
 8230c8c:	f800283a 	ret

08230c90 <t_getname>:
 * RETURNS: 
 */

static int
t_getname(long s, struct sockaddr * addr, int * addrlen, int opcode)
{
 8230c90:	defff604 	addi	sp,sp,-40
 8230c94:	dfc00915 	stw	ra,36(sp)
 8230c98:	df000815 	stw	fp,32(sp)
 8230c9c:	df000804 	addi	fp,sp,32
 8230ca0:	e13ffc15 	stw	r4,-16(fp)
 8230ca4:	e17ffd15 	stw	r5,-12(fp)
 8230ca8:	e1bffe15 	stw	r6,-8(fp)
 8230cac:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   struct mbuf *  m;
   int   err;

   so = LONG2SO(s);
 8230cb0:	e0bffc17 	ldw	r2,-16(fp)
 8230cb4:	10bff804 	addi	r2,r2,-32
 8230cb8:	1085883a 	add	r2,r2,r2
 8230cbc:	1085883a 	add	r2,r2,r2
 8230cc0:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 8230cc4:	008209b4 	movhi	r2,2086
 8230cc8:	10b97a04 	addi	r2,r2,-6680
 8230ccc:	e0bff815 	stw	r2,-32(fp)
 8230cd0:	00000606 	br	8230cec <t_getname+0x5c>
 8230cd4:	e0fff817 	ldw	r3,-32(fp)
 8230cd8:	e0bff917 	ldw	r2,-28(fp)
 8230cdc:	18800626 	beq	r3,r2,8230cf8 <t_getname+0x68>
 8230ce0:	e0bff817 	ldw	r2,-32(fp)
 8230ce4:	10800017 	ldw	r2,0(r2)
 8230ce8:	e0bff815 	stw	r2,-32(fp)
 8230cec:	e0bff817 	ldw	r2,-32(fp)
 8230cf0:	103ff81e 	bne	r2,zero,8230cd4 <t_getname+0x44>
 8230cf4:	00000106 	br	8230cfc <t_getname+0x6c>
 8230cf8:	0001883a 	nop
 8230cfc:	e0fff817 	ldw	r3,-32(fp)
 8230d00:	e0bff917 	ldw	r2,-28(fp)
 8230d04:	18800326 	beq	r3,r2,8230d14 <t_getname+0x84>
 8230d08:	822d5f00 	call	822d5f0 <dtrap>
 8230d0c:	00bfffc4 	movi	r2,-1
 8230d10:	00005106 	br	8230e58 <t_getname+0x1c8>

   so->so_error = 0;
 8230d14:	e0bff917 	ldw	r2,-28(fp)
 8230d18:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:get[sock|peer]name so %x\n", so));
   if((opcode == PRU_PEERADDR) && (so->so_state & SS_ISCONNECTED) == 0)
 8230d1c:	e0bfff17 	ldw	r2,-4(fp)
 8230d20:	10800418 	cmpnei	r2,r2,16
 8230d24:	10000a1e 	bne	r2,zero,8230d50 <t_getname+0xc0>
 8230d28:	e0bff917 	ldw	r2,-28(fp)
 8230d2c:	1080088b 	ldhu	r2,34(r2)
 8230d30:	10bfffcc 	andi	r2,r2,65535
 8230d34:	1080008c 	andi	r2,r2,2
 8230d38:	1000051e 	bne	r2,zero,8230d50 <t_getname+0xc0>
   {
      so->so_error = ENOTCONN;
 8230d3c:	e0bff917 	ldw	r2,-28(fp)
 8230d40:	00c02004 	movi	r3,128
 8230d44:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8230d48:	00bfffc4 	movi	r2,-1
 8230d4c:	00004206 	br	8230e58 <t_getname+0x1c8>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 8230d50:	0009883a 	mov	r4,zero
 8230d54:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 8230d58:	01400404 	movi	r5,16
 8230d5c:	01000244 	movi	r4,9
 8230d60:	822e4040 	call	822e404 <m_getnbuf>
 8230d64:	e0bffa15 	stw	r2,-24(fp)
   if (m == NULL) 
 8230d68:	e0bffa17 	ldw	r2,-24(fp)
 8230d6c:	1000071e 	bne	r2,zero,8230d8c <t_getname+0xfc>
   {
      so->so_error = ENOMEM;
 8230d70:	e0bff917 	ldw	r2,-28(fp)
 8230d74:	00c00304 	movi	r3,12
 8230d78:	10c00615 	stw	r3,24(r2)
      UNLOCK_NET_RESOURCE(NET_RESID);
 8230d7c:	0009883a 	mov	r4,zero
 8230d80:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 8230d84:	00bfffc4 	movi	r2,-1
 8230d88:	00003306 	br	8230e58 <t_getname+0x1c8>
   }
   so->so_req = opcode;
 8230d8c:	e0bff917 	ldw	r2,-28(fp)
 8230d90:	e0ffff17 	ldw	r3,-4(fp)
 8230d94:	10c00715 	stw	r3,28(r2)
   if ((err = (*so->so_proto->pr_usrreq)(so, 0, m)) != 0)
 8230d98:	e0bff917 	ldw	r2,-28(fp)
 8230d9c:	10800217 	ldw	r2,8(r2)
 8230da0:	10800317 	ldw	r2,12(r2)
 8230da4:	e1bffa17 	ldw	r6,-24(fp)
 8230da8:	000b883a 	mov	r5,zero
 8230dac:	e13ff917 	ldw	r4,-28(fp)
 8230db0:	103ee83a 	callr	r2
 8230db4:	e0bffb15 	stw	r2,-20(fp)
 8230db8:	e0bffb17 	ldw	r2,-20(fp)
 8230dbc:	1000191e 	bne	r2,zero,8230e24 <t_getname+0x194>
      goto bad;

#ifdef IP_V4
   if(so->so_domain == AF_INET)
 8230dc0:	e0bff917 	ldw	r2,-28(fp)
 8230dc4:	10800517 	ldw	r2,20(r2)
 8230dc8:	10800098 	cmpnei	r2,r2,2
 8230dcc:	1000161e 	bne	r2,zero,8230e28 <t_getname+0x198>
   {
      if(*addrlen < sizeof(struct sockaddr_in))
 8230dd0:	e0bffe17 	ldw	r2,-8(fp)
 8230dd4:	10800017 	ldw	r2,0(r2)
 8230dd8:	10800428 	cmpgeui	r2,r2,16
 8230ddc:	1000071e 	bne	r2,zero,8230dfc <t_getname+0x16c>
      {
         dtrap();    /* programming error */
 8230de0:	822d5f00 	call	822d5f0 <dtrap>
         m_freem(m);
 8230de4:	e13ffa17 	ldw	r4,-24(fp)
 8230de8:	822e6940 	call	822e694 <m_freem>
         UNLOCK_NET_RESOURCE(NET_RESID);
 8230dec:	0009883a 	mov	r4,zero
 8230df0:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         return EINVAL;
 8230df4:	00800584 	movi	r2,22
 8230df8:	00001706 	br	8230e58 <t_getname+0x1c8>
      }
      MEMCPY(addr, m->m_data, sizeof(struct sockaddr_in));
 8230dfc:	e0bffa17 	ldw	r2,-24(fp)
 8230e00:	10800317 	ldw	r2,12(r2)
 8230e04:	01800404 	movi	r6,16
 8230e08:	100b883a 	mov	r5,r2
 8230e0c:	e13ffd17 	ldw	r4,-12(fp)
 8230e10:	8202f6c0 	call	8202f6c <memcpy>
      *addrlen = sizeof(struct sockaddr_in);
 8230e14:	e0bffe17 	ldw	r2,-8(fp)
 8230e18:	00c00404 	movi	r3,16
 8230e1c:	10c00015 	stw	r3,0(r2)
 8230e20:	00000106 	br	8230e28 <t_getname+0x198>
      UNLOCK_NET_RESOURCE(NET_RESID);
      return SOCKET_ERROR;
   }
   so->so_req = opcode;
   if ((err = (*so->so_proto->pr_usrreq)(so, 0, m)) != 0)
      goto bad;
 8230e24:	0001883a 	nop
   }
#endif   /* IP_V6 */


bad:
   m_freem(m);
 8230e28:	e13ffa17 	ldw	r4,-24(fp)
 8230e2c:	822e6940 	call	822e694 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 8230e30:	0009883a 	mov	r4,zero
 8230e34:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   if (err) 
 8230e38:	e0bffb17 	ldw	r2,-20(fp)
 8230e3c:	10000526 	beq	r2,zero,8230e54 <t_getname+0x1c4>
   {
      so->so_error = err;
 8230e40:	e0bff917 	ldw	r2,-28(fp)
 8230e44:	e0fffb17 	ldw	r3,-20(fp)
 8230e48:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8230e4c:	00bfffc4 	movi	r2,-1
 8230e50:	00000106 	br	8230e58 <t_getname+0x1c8>
   }
   return 0;
 8230e54:	0005883a 	mov	r2,zero
}
 8230e58:	e037883a 	mov	sp,fp
 8230e5c:	dfc00117 	ldw	ra,4(sp)
 8230e60:	df000017 	ldw	fp,0(sp)
 8230e64:	dec00204 	addi	sp,sp,8
 8230e68:	f800283a 	ret

08230e6c <t_setsockopt>:
t_setsockopt(long s,
   int   level,
   int   name,
   void * arg,
   int arglen)
{
 8230e6c:	defff704 	addi	sp,sp,-36
 8230e70:	dfc00815 	stw	ra,32(sp)
 8230e74:	df000715 	stw	fp,28(sp)
 8230e78:	df000704 	addi	fp,sp,28
 8230e7c:	e13ffc15 	stw	r4,-16(fp)
 8230e80:	e17ffd15 	stw	r5,-12(fp)
 8230e84:	e1bffe15 	stw	r6,-8(fp)
 8230e88:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 8230e8c:	e0bffc17 	ldw	r2,-16(fp)
 8230e90:	10bff804 	addi	r2,r2,-32
 8230e94:	1085883a 	add	r2,r2,r2
 8230e98:	1085883a 	add	r2,r2,r2
 8230e9c:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 8230ea0:	008209b4 	movhi	r2,2086
 8230ea4:	10b97a04 	addi	r2,r2,-6680
 8230ea8:	e0bff915 	stw	r2,-28(fp)
 8230eac:	00000606 	br	8230ec8 <t_setsockopt+0x5c>
 8230eb0:	e0fff917 	ldw	r3,-28(fp)
 8230eb4:	e0bffa17 	ldw	r2,-24(fp)
 8230eb8:	18800626 	beq	r3,r2,8230ed4 <t_setsockopt+0x68>
 8230ebc:	e0bff917 	ldw	r2,-28(fp)
 8230ec0:	10800017 	ldw	r2,0(r2)
 8230ec4:	e0bff915 	stw	r2,-28(fp)
 8230ec8:	e0bff917 	ldw	r2,-28(fp)
 8230ecc:	103ff81e 	bne	r2,zero,8230eb0 <t_setsockopt+0x44>
 8230ed0:	00000106 	br	8230ed8 <t_setsockopt+0x6c>
 8230ed4:	0001883a 	nop
 8230ed8:	e0fff917 	ldw	r3,-28(fp)
 8230edc:	e0bffa17 	ldw	r2,-24(fp)
 8230ee0:	18800326 	beq	r3,r2,8230ef0 <t_setsockopt+0x84>
 8230ee4:	822d5f00 	call	822d5f0 <dtrap>
 8230ee8:	00bfffc4 	movi	r2,-1
 8230eec:	00004a06 	br	8231018 <t_setsockopt+0x1ac>
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 8230ef0:	0009883a 	mov	r4,zero
 8230ef4:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>

   so->so_error = 0;
 8230ef8:	e0bffa17 	ldw	r2,-24(fp)
 8230efc:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
    ("INET: setsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 8230f00:	e0bffd17 	ldw	r2,-12(fp)
 8230f04:	10800060 	cmpeqi	r2,r2,1
 8230f08:	10000e1e 	bne	r2,zero,8230f44 <t_setsockopt+0xd8>
   {
      if ((err = sosetopt (so, name, arg)) != 0) 
 8230f0c:	e1bfff17 	ldw	r6,-4(fp)
 8230f10:	e17ffe17 	ldw	r5,-8(fp)
 8230f14:	e13ffa17 	ldw	r4,-24(fp)
 8230f18:	82331a00 	call	82331a0 <sosetopt>
 8230f1c:	e0bffb15 	stw	r2,-20(fp)
 8230f20:	e0bffb17 	ldw	r2,-20(fp)
 8230f24:	10003926 	beq	r2,zero,823100c <t_setsockopt+0x1a0>
      {
         so->so_error = err;
 8230f28:	e0bffa17 	ldw	r2,-24(fp)
 8230f2c:	e0fffb17 	ldw	r3,-20(fp)
 8230f30:	10c00615 	stw	r3,24(r2)
         UNLOCK_NET_RESOURCE (NET_RESID);
 8230f34:	0009883a 	mov	r4,zero
 8230f38:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 8230f3c:	00bfffc4 	movi	r2,-1
 8230f40:	00003506 	br	8231018 <t_setsockopt+0x1ac>
   {
   /* level 1 options are for the IP packet level.
    * the info is carried in the socket CB, then put 
    * into the PACKET.
    */
      if (!so->so_optsPack)
 8230f44:	e0bffa17 	ldw	r2,-24(fp)
 8230f48:	10801f17 	ldw	r2,124(r2)
 8230f4c:	10000f1e 	bne	r2,zero,8230f8c <t_setsockopt+0x120>
      {
         so->so_optsPack = (struct ip_socopts *) SOCOPT_ALLOC (sizeof(struct ip_socopts *));
 8230f50:	01000104 	movi	r4,4
 8230f54:	822e1c80 	call	822e1c8 <npalloc>
 8230f58:	1007883a 	mov	r3,r2
 8230f5c:	e0bffa17 	ldw	r2,-24(fp)
 8230f60:	10c01f15 	stw	r3,124(r2)
         if (!so->so_optsPack) 
 8230f64:	e0bffa17 	ldw	r2,-24(fp)
 8230f68:	10801f17 	ldw	r2,124(r2)
 8230f6c:	1000071e 	bne	r2,zero,8230f8c <t_setsockopt+0x120>
         {
            so->so_error = ENOMEM;
 8230f70:	e0bffa17 	ldw	r2,-24(fp)
 8230f74:	00c00304 	movi	r3,12
 8230f78:	10c00615 	stw	r3,24(r2)
            UNLOCK_NET_RESOURCE (NET_RESID);
 8230f7c:	0009883a 	mov	r4,zero
 8230f80:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
            return SOCKET_ERROR;
 8230f84:	00bfffc4 	movi	r2,-1
 8230f88:	00002306 	br	8231018 <t_setsockopt+0x1ac>
         }
      }
      
      if (name == IP_TTL_OPT)
 8230f8c:	e0bffe17 	ldw	r2,-8(fp)
 8230f90:	10800118 	cmpnei	r2,r2,4
 8230f94:	1000061e 	bne	r2,zero,8230fb0 <t_setsockopt+0x144>
         so->so_optsPack->ip_ttl = (u_char)(*(int *)arg);
 8230f98:	e0bffa17 	ldw	r2,-24(fp)
 8230f9c:	10801f17 	ldw	r2,124(r2)
 8230fa0:	e0ffff17 	ldw	r3,-4(fp)
 8230fa4:	18c00017 	ldw	r3,0(r3)
 8230fa8:	10c00045 	stb	r3,1(r2)
 8230fac:	00001706 	br	823100c <t_setsockopt+0x1a0>
      else
      if (name == IP_TOS)
 8230fb0:	e0bffe17 	ldw	r2,-8(fp)
 8230fb4:	108000d8 	cmpnei	r2,r2,3
 8230fb8:	1000061e 	bne	r2,zero,8230fd4 <t_setsockopt+0x168>
         so->so_optsPack->ip_tos = (u_char)(*(int *)arg);
 8230fbc:	e0bffa17 	ldw	r2,-24(fp)
 8230fc0:	10801f17 	ldw	r2,124(r2)
 8230fc4:	e0ffff17 	ldw	r3,-4(fp)
 8230fc8:	18c00017 	ldw	r3,0(r3)
 8230fcc:	10c00005 	stb	r3,0(r2)
 8230fd0:	00000e06 	br	823100c <t_setsockopt+0x1a0>
	   else
	   if (name == IP_SCOPEID)
 8230fd4:	e0bffe17 	ldw	r2,-8(fp)
 8230fd8:	10800398 	cmpnei	r2,r2,14
 8230fdc:	1000071e 	bne	r2,zero,8230ffc <t_setsockopt+0x190>
            so->so_optsPack->ip_scopeid = (u_char)(*(u_int *)arg);
 8230fe0:	e0bffa17 	ldw	r2,-24(fp)
 8230fe4:	10801f17 	ldw	r2,124(r2)
 8230fe8:	e0ffff17 	ldw	r3,-4(fp)
 8230fec:	18c00017 	ldw	r3,0(r3)
 8230ff0:	18c03fcc 	andi	r3,r3,255
 8230ff4:	10c00115 	stw	r3,4(r2)
 8230ff8:	00000406 	br	823100c <t_setsockopt+0x1a0>
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 8230ffc:	0009883a 	mov	r4,zero
 8231000:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 8231004:	00bfffc4 	movi	r2,-1
 8231008:	00000306 	br	8231018 <t_setsockopt+0x1ac>
      }   
   }

   UNLOCK_NET_RESOURCE (NET_RESID);
 823100c:	0009883a 	mov	r4,zero
 8231010:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   return 0;
 8231014:	0005883a 	mov	r2,zero
}
 8231018:	e037883a 	mov	sp,fp
 823101c:	dfc00117 	ldw	ra,4(sp)
 8231020:	df000017 	ldw	fp,0(sp)
 8231024:	dec00204 	addi	sp,sp,8
 8231028:	f800283a 	ret

0823102c <t_getsockopt>:
   int   level,
   int   name,
   void *   arg,
   int   arglen)

{
 823102c:	defff704 	addi	sp,sp,-36
 8231030:	dfc00815 	stw	ra,32(sp)
 8231034:	df000715 	stw	fp,28(sp)
 8231038:	df000704 	addi	fp,sp,28
 823103c:	e13ffc15 	stw	r4,-16(fp)
 8231040:	e17ffd15 	stw	r5,-12(fp)
 8231044:	e1bffe15 	stw	r6,-8(fp)
 8231048:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 823104c:	e0bffc17 	ldw	r2,-16(fp)
 8231050:	10bff804 	addi	r2,r2,-32
 8231054:	1085883a 	add	r2,r2,r2
 8231058:	1085883a 	add	r2,r2,r2
 823105c:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 8231060:	008209b4 	movhi	r2,2086
 8231064:	10b97a04 	addi	r2,r2,-6680
 8231068:	e0bff915 	stw	r2,-28(fp)
 823106c:	00000606 	br	8231088 <t_getsockopt+0x5c>
 8231070:	e0fff917 	ldw	r3,-28(fp)
 8231074:	e0bffa17 	ldw	r2,-24(fp)
 8231078:	18800626 	beq	r3,r2,8231094 <t_getsockopt+0x68>
 823107c:	e0bff917 	ldw	r2,-28(fp)
 8231080:	10800017 	ldw	r2,0(r2)
 8231084:	e0bff915 	stw	r2,-28(fp)
 8231088:	e0bff917 	ldw	r2,-28(fp)
 823108c:	103ff81e 	bne	r2,zero,8231070 <t_getsockopt+0x44>
 8231090:	00000106 	br	8231098 <t_getsockopt+0x6c>
 8231094:	0001883a 	nop
 8231098:	e0fff917 	ldw	r3,-28(fp)
 823109c:	e0bffa17 	ldw	r2,-24(fp)
 82310a0:	18800326 	beq	r3,r2,82310b0 <t_getsockopt+0x84>
 82310a4:	822d5f00 	call	822d5f0 <dtrap>
 82310a8:	00bfffc4 	movi	r2,-1
 82310ac:	00003d06 	br	82311a4 <t_getsockopt+0x178>
   USE_ARG(level);
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 82310b0:	0009883a 	mov	r4,zero
 82310b4:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   INET_TRACE (INETM_SOCKET,
    ("INET: getsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 82310b8:	e0bffd17 	ldw	r2,-12(fp)
 82310bc:	10800060 	cmpeqi	r2,r2,1
 82310c0:	10000e1e 	bne	r2,zero,82310fc <t_getsockopt+0xd0>
   {
      if ((err = sogetopt (so, name, arg)) != 0) 
 82310c4:	e1bfff17 	ldw	r6,-4(fp)
 82310c8:	e17ffe17 	ldw	r5,-8(fp)
 82310cc:	e13ffa17 	ldw	r4,-24(fp)
 82310d0:	82335d00 	call	82335d0 <sogetopt>
 82310d4:	e0bffb15 	stw	r2,-20(fp)
 82310d8:	e0bffb17 	ldw	r2,-20(fp)
 82310dc:	10002c26 	beq	r2,zero,8231190 <t_getsockopt+0x164>
      {
         so->so_error = err;
 82310e0:	e0bffa17 	ldw	r2,-24(fp)
 82310e4:	e0fffb17 	ldw	r3,-20(fp)
 82310e8:	10c00615 	stw	r3,24(r2)
         UNLOCK_NET_RESOURCE (NET_RESID);
 82310ec:	0009883a 	mov	r4,zero
 82310f0:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 82310f4:	00bfffc4 	movi	r2,-1
 82310f8:	00002a06 	br	82311a4 <t_getsockopt+0x178>
   {
      /* level 1 options are for the IP packet level.
       * the info is carried in the socket CB, then put 
       * into the PACKET.
       */
      if (name == IP_TTL_OPT)
 82310fc:	e0bffe17 	ldw	r2,-8(fp)
 8231100:	10800118 	cmpnei	r2,r2,4
 8231104:	10000e1e 	bne	r2,zero,8231140 <t_getsockopt+0x114>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TTL;
 8231108:	e0bffa17 	ldw	r2,-24(fp)
 823110c:	10801f17 	ldw	r2,124(r2)
 8231110:	1000041e 	bne	r2,zero,8231124 <t_getsockopt+0xf8>
 8231114:	e0bfff17 	ldw	r2,-4(fp)
 8231118:	00c01004 	movi	r3,64
 823111c:	10c00015 	stw	r3,0(r2)
 8231120:	00001b06 	br	8231190 <t_getsockopt+0x164>
         else *(int *)arg = (int)so->so_optsPack->ip_ttl;
 8231124:	e0bffa17 	ldw	r2,-24(fp)
 8231128:	10801f17 	ldw	r2,124(r2)
 823112c:	10800043 	ldbu	r2,1(r2)
 8231130:	10c03fcc 	andi	r3,r2,255
 8231134:	e0bfff17 	ldw	r2,-4(fp)
 8231138:	10c00015 	stw	r3,0(r2)
 823113c:	00001406 	br	8231190 <t_getsockopt+0x164>
      }
      else if (name == IP_TOS)
 8231140:	e0bffe17 	ldw	r2,-8(fp)
 8231144:	108000d8 	cmpnei	r2,r2,3
 8231148:	10000d1e 	bne	r2,zero,8231180 <t_getsockopt+0x154>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TOS_DEFVAL;
 823114c:	e0bffa17 	ldw	r2,-24(fp)
 8231150:	10801f17 	ldw	r2,124(r2)
 8231154:	1000031e 	bne	r2,zero,8231164 <t_getsockopt+0x138>
 8231158:	e0bfff17 	ldw	r2,-4(fp)
 823115c:	10000015 	stw	zero,0(r2)
 8231160:	00000b06 	br	8231190 <t_getsockopt+0x164>
         else *(int *)arg = (int)so->so_optsPack->ip_tos;
 8231164:	e0bffa17 	ldw	r2,-24(fp)
 8231168:	10801f17 	ldw	r2,124(r2)
 823116c:	10800003 	ldbu	r2,0(r2)
 8231170:	10c03fcc 	andi	r3,r2,255
 8231174:	e0bfff17 	ldw	r2,-4(fp)
 8231178:	10c00015 	stw	r3,0(r2)
 823117c:	00000406 	br	8231190 <t_getsockopt+0x164>
      }
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 8231180:	0009883a 	mov	r4,zero
 8231184:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 8231188:	00bfffc4 	movi	r2,-1
 823118c:	00000506 	br	82311a4 <t_getsockopt+0x178>
      }
   }   
   so->so_error = 0;
 8231190:	e0bffa17 	ldw	r2,-24(fp)
 8231194:	10000615 	stw	zero,24(r2)

   UNLOCK_NET_RESOURCE (NET_RESID);
 8231198:	0009883a 	mov	r4,zero
 823119c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   return 0;
 82311a0:	0005883a 	mov	r2,zero
}
 82311a4:	e037883a 	mov	sp,fp
 82311a8:	dfc00117 	ldw	ra,4(sp)
 82311ac:	df000017 	ldw	fp,0(sp)
 82311b0:	dec00204 	addi	sp,sp,8
 82311b4:	f800283a 	ret

082311b8 <t_recv>:
int
t_recv (long s, 
   char *   buf,
   int   len, 
   int   flag)
{
 82311b8:	defff604 	addi	sp,sp,-40
 82311bc:	dfc00915 	stw	ra,36(sp)
 82311c0:	df000815 	stw	fp,32(sp)
 82311c4:	df000804 	addi	fp,sp,32
 82311c8:	e13ffc15 	stw	r4,-16(fp)
 82311cc:	e17ffd15 	stw	r5,-12(fp)
 82311d0:	e1bffe15 	stw	r6,-8(fp)
 82311d4:	e1ffff15 	stw	r7,-4(fp)
#ifdef SOCKDEBUG
   char logbuf[10];
#endif
   struct socket *   so;
   int   err;
   int   sendlen = len;
 82311d8:	e0bffe17 	ldw	r2,-8(fp)
 82311dc:	e0bff915 	stw	r2,-28(fp)

   so = LONG2SO(s);
 82311e0:	e0bffc17 	ldw	r2,-16(fp)
 82311e4:	10bff804 	addi	r2,r2,-32
 82311e8:	1085883a 	add	r2,r2,r2
 82311ec:	1085883a 	add	r2,r2,r2
 82311f0:	e0bffa15 	stw	r2,-24(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 82311f4:	e0bffa17 	ldw	r2,-24(fp)
 82311f8:	1080088b 	ldhu	r2,34(r2)
 82311fc:	10bfffcc 	andi	r2,r2,65535
 8231200:	1080038c 	andi	r2,r2,14
 8231204:	108000a0 	cmpeqi	r2,r2,2
 8231208:	1000051e 	bne	r2,zero,8231220 <t_recv+0x68>
   {
      so->so_error = EPIPE;
 823120c:	e0bffa17 	ldw	r2,-24(fp)
 8231210:	00c00804 	movi	r3,32
 8231214:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 8231218:	00bfffc4 	movi	r2,-1
 823121c:	00001906 	br	8231284 <t_recv+0xcc>
   }
   so->so_error = 0;
 8231220:	e0bffa17 	ldw	r2,-24(fp)
 8231224:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 8231228:	0009883a 	mov	r4,zero
 823122c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   IN_PROFILER(PF_TCP, PF_ENTRY);        /* measure time in TCP */
   INET_TRACE (INETM_IO, ("INET:recv: so %x, len %d\n", so, len));
   err = soreceive(so, NULL, buf, &len, flag);
 8231230:	e0fffe04 	addi	r3,fp,-8
 8231234:	e0bfff17 	ldw	r2,-4(fp)
 8231238:	d8800015 	stw	r2,0(sp)
 823123c:	180f883a 	mov	r7,r3
 8231240:	e1bffd17 	ldw	r6,-12(fp)
 8231244:	000b883a 	mov	r5,zero
 8231248:	e13ffa17 	ldw	r4,-24(fp)
 823124c:	82328c00 	call	82328c0 <soreceive>
 8231250:	e0bffb15 	stw	r2,-20(fp)
   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   UNLOCK_NET_RESOURCE(NET_RESID);
 8231254:	0009883a 	mov	r4,zero
 8231258:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>

   if(err)
 823125c:	e0bffb17 	ldw	r2,-20(fp)
 8231260:	10000526 	beq	r2,zero,8231278 <t_recv+0xc0>
   {
      so->so_error = err;
 8231264:	e0bffa17 	ldw	r2,-24(fp)
 8231268:	e0fffb17 	ldw	r3,-20(fp)
 823126c:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 8231270:	00bfffc4 	movi	r2,-1
 8231274:	00000306 	br	8231284 <t_recv+0xcc>
   }

   /* return bytes we sent - the amount we wanted to send minus
    * the amount left in the buffer.
    */
   return (sendlen - len);
 8231278:	e0bffe17 	ldw	r2,-8(fp)
 823127c:	e0fff917 	ldw	r3,-28(fp)
 8231280:	1885c83a 	sub	r2,r3,r2
}
 8231284:	e037883a 	mov	sp,fp
 8231288:	dfc00117 	ldw	ra,4(sp)
 823128c:	df000017 	ldw	fp,0(sp)
 8231290:	dec00204 	addi	sp,sp,8
 8231294:	f800283a 	ret

08231298 <t_recvfrom>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * from,
   int * fromlen)
{
 8231298:	defff404 	addi	sp,sp,-48
 823129c:	dfc00b15 	stw	ra,44(sp)
 82312a0:	df000a15 	stw	fp,40(sp)
 82312a4:	df000a04 	addi	fp,sp,40
 82312a8:	e13ffc15 	stw	r4,-16(fp)
 82312ac:	e17ffd15 	stw	r5,-12(fp)
 82312b0:	e1bffe15 	stw	r6,-8(fp)
 82312b4:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   struct mbuf *     sender = NULL;
 82312b8:	e03ffb15 	stw	zero,-20(fp)
   int   err;
   int   sendlen = len;
 82312bc:	e0bffe17 	ldw	r2,-8(fp)
 82312c0:	e0bff815 	stw	r2,-32(fp)

   so = LONG2SO(s);
 82312c4:	e0bffc17 	ldw	r2,-16(fp)
 82312c8:	10bff804 	addi	r2,r2,-32
 82312cc:	1085883a 	add	r2,r2,r2
 82312d0:	1085883a 	add	r2,r2,r2
 82312d4:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 82312d8:	008209b4 	movhi	r2,2086
 82312dc:	10b97a04 	addi	r2,r2,-6680
 82312e0:	e0bff715 	stw	r2,-36(fp)
 82312e4:	00000606 	br	8231300 <t_recvfrom+0x68>
 82312e8:	e0fff717 	ldw	r3,-36(fp)
 82312ec:	e0bff917 	ldw	r2,-28(fp)
 82312f0:	18800626 	beq	r3,r2,823130c <t_recvfrom+0x74>
 82312f4:	e0bff717 	ldw	r2,-36(fp)
 82312f8:	10800017 	ldw	r2,0(r2)
 82312fc:	e0bff715 	stw	r2,-36(fp)
 8231300:	e0bff717 	ldw	r2,-36(fp)
 8231304:	103ff81e 	bne	r2,zero,82312e8 <t_recvfrom+0x50>
 8231308:	00000106 	br	8231310 <t_recvfrom+0x78>
 823130c:	0001883a 	nop
 8231310:	e0fff717 	ldw	r3,-36(fp)
 8231314:	e0bff917 	ldw	r2,-28(fp)
 8231318:	18800326 	beq	r3,r2,8231328 <t_recvfrom+0x90>
 823131c:	822d5f00 	call	822d5f0 <dtrap>
 8231320:	00bfffc4 	movi	r2,-1
 8231324:	00002706 	br	82313c4 <t_recvfrom+0x12c>
   so->so_error = 0;
 8231328:	e0bff917 	ldw	r2,-28(fp)
 823132c:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 8231330:	0009883a 	mov	r4,zero
 8231334:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>

   err = soreceive(so, &sender, buf, &len, flags);
 8231338:	e13ffe04 	addi	r4,fp,-8
 823133c:	e0fffb04 	addi	r3,fp,-20
 8231340:	e0bfff17 	ldw	r2,-4(fp)
 8231344:	d8800015 	stw	r2,0(sp)
 8231348:	200f883a 	mov	r7,r4
 823134c:	e1bffd17 	ldw	r6,-12(fp)
 8231350:	180b883a 	mov	r5,r3
 8231354:	e13ff917 	ldw	r4,-28(fp)
 8231358:	82328c00 	call	82328c0 <soreceive>
 823135c:	e0bffa15 	stw	r2,-24(fp)

   /* copy sender info from mbuf to sockaddr */
   if (sender)
 8231360:	e0bffb17 	ldw	r2,-20(fp)
 8231364:	10000b26 	beq	r2,zero,8231394 <t_recvfrom+0xfc>
   {
      MEMCPY(from, (mtod(sender, struct sockaddr *)), *fromlen );
 8231368:	e0bffb17 	ldw	r2,-20(fp)
 823136c:	10c00317 	ldw	r3,12(r2)
 8231370:	e0800317 	ldw	r2,12(fp)
 8231374:	10800017 	ldw	r2,0(r2)
 8231378:	100d883a 	mov	r6,r2
 823137c:	180b883a 	mov	r5,r3
 8231380:	e1000217 	ldw	r4,8(fp)
 8231384:	8202f6c0 	call	8202f6c <memcpy>
      m_freem (sender);
 8231388:	e0bffb17 	ldw	r2,-20(fp)
 823138c:	1009883a 	mov	r4,r2
 8231390:	822e6940 	call	822e694 <m_freem>
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 8231394:	0009883a 	mov	r4,zero
 8231398:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>

   if(err)
 823139c:	e0bffa17 	ldw	r2,-24(fp)
 82313a0:	10000526 	beq	r2,zero,82313b8 <t_recvfrom+0x120>
   {
      so->so_error = err;
 82313a4:	e0bff917 	ldw	r2,-28(fp)
 82313a8:	e0fffa17 	ldw	r3,-24(fp)
 82313ac:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 82313b0:	00bfffc4 	movi	r2,-1
 82313b4:	00000306 	br	82313c4 <t_recvfrom+0x12c>
   }

   /* OK return: amount of data actually sent */
   return (sendlen - len);
 82313b8:	e0bffe17 	ldw	r2,-8(fp)
 82313bc:	e0fff817 	ldw	r3,-32(fp)
 82313c0:	1885c83a 	sub	r2,r3,r2
}
 82313c4:	e037883a 	mov	sp,fp
 82313c8:	dfc00117 	ldw	ra,4(sp)
 82313cc:	df000017 	ldw	fp,0(sp)
 82313d0:	dec00204 	addi	sp,sp,8
 82313d4:	f800283a 	ret

082313d8 <t_sendto>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * to,
   int   tolen)
{
 82313d8:	defff404 	addi	sp,sp,-48
 82313dc:	dfc00b15 	stw	ra,44(sp)
 82313e0:	df000a15 	stw	fp,40(sp)
 82313e4:	df000a04 	addi	fp,sp,40
 82313e8:	e13ffc15 	stw	r4,-16(fp)
 82313ec:	e17ffd15 	stw	r5,-12(fp)
 82313f0:	e1bffe15 	stw	r6,-8(fp)
 82313f4:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   sendlen;
   int   err;
   struct mbuf *     name;

   so = LONG2SO(s);
 82313f8:	e0bffc17 	ldw	r2,-16(fp)
 82313fc:	10bff804 	addi	r2,r2,-32
 8231400:	1085883a 	add	r2,r2,r2
 8231404:	1085883a 	add	r2,r2,r2
 8231408:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 823140c:	008209b4 	movhi	r2,2086
 8231410:	10b97a04 	addi	r2,r2,-6680
 8231414:	e0bff815 	stw	r2,-32(fp)
 8231418:	00000606 	br	8231434 <t_sendto+0x5c>
 823141c:	e0fff817 	ldw	r3,-32(fp)
 8231420:	e0bff917 	ldw	r2,-28(fp)
 8231424:	18800626 	beq	r3,r2,8231440 <t_sendto+0x68>
 8231428:	e0bff817 	ldw	r2,-32(fp)
 823142c:	10800017 	ldw	r2,0(r2)
 8231430:	e0bff815 	stw	r2,-32(fp)
 8231434:	e0bff817 	ldw	r2,-32(fp)
 8231438:	103ff81e 	bne	r2,zero,823141c <t_sendto+0x44>
 823143c:	00000106 	br	8231444 <t_sendto+0x6c>
 8231440:	0001883a 	nop
 8231444:	e0fff817 	ldw	r3,-32(fp)
 8231448:	e0bff917 	ldw	r2,-28(fp)
 823144c:	18800326 	beq	r3,r2,823145c <t_sendto+0x84>
 8231450:	822d5f00 	call	822d5f0 <dtrap>
 8231454:	00bfffc4 	movi	r2,-1
 8231458:	00005706 	br	82315b8 <t_sendto+0x1e0>
   so->so_error = 0;
 823145c:	e0bff917 	ldw	r2,-28(fp)
 8231460:	10000615 	stw	zero,24(r2)

   switch (so->so_type)
 8231464:	e0bff917 	ldw	r2,-28(fp)
 8231468:	10800983 	ldbu	r2,38(r2)
 823146c:	10803fcc 	andi	r2,r2,255
 8231470:	1080201c 	xori	r2,r2,128
 8231474:	10bfe004 	addi	r2,r2,-128
 8231478:	10c000a0 	cmpeqi	r3,r2,2
 823147c:	18000a1e 	bne	r3,zero,82314a8 <t_sendto+0xd0>
 8231480:	10c000e0 	cmpeqi	r3,r2,3
 8231484:	18000b1e 	bne	r3,zero,82314b4 <t_sendto+0xdc>
 8231488:	10800060 	cmpeqi	r2,r2,1
 823148c:	10001026 	beq	r2,zero,82314d0 <t_sendto+0xf8>
   {
   case SOCK_STREAM:
      /* this is a stream socket, so pass this request through
       * t_send() for its large-send support.
       */
      return t_send(s, buf, len, flags);
 8231490:	e1ffff17 	ldw	r7,-4(fp)
 8231494:	e1bffe17 	ldw	r6,-8(fp)
 8231498:	e17ffd17 	ldw	r5,-12(fp)
 823149c:	e13ffc17 	ldw	r4,-16(fp)
 82314a0:	82315cc0 	call	82315cc <t_send>
 82314a4:	00004406 	br	82315b8 <t_sendto+0x1e0>
      /*NOTREACHED*/
   case SOCK_DGRAM:
      /* datagram (UDP) socket -- prepare to check length */
      sendlen = udp_maxalloc();
 82314a8:	82455000 	call	8245500 <udp_maxalloc>
 82314ac:	e0bffb15 	stw	r2,-20(fp)
      break;
 82314b0:	00000d06 	br	82314e8 <t_sendto+0x110>
#ifdef IP_RAW
   case SOCK_RAW:
      /* raw socket -- prepare to check length */
      sendlen = ip_raw_maxalloc(so->so_options & SO_HDRINCL);
 82314b4:	e0bff917 	ldw	r2,-28(fp)
 82314b8:	10800417 	ldw	r2,16(r2)
 82314bc:	1088000c 	andi	r2,r2,8192
 82314c0:	1009883a 	mov	r4,r2
 82314c4:	82441f00 	call	82441f0 <ip_raw_maxalloc>
 82314c8:	e0bffb15 	stw	r2,-20(fp)
      break;
 82314cc:	00000606 	br	82314e8 <t_sendto+0x110>
#endif /* IP_RAW */
   default:
      /* socket has unknown type */
      dtrap();
 82314d0:	822d5f00 	call	822d5f0 <dtrap>
      so->so_error = EFAULT;
 82314d4:	e0bff917 	ldw	r2,-28(fp)
 82314d8:	00c00384 	movi	r3,14
 82314dc:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 82314e0:	00bfffc4 	movi	r2,-1
 82314e4:	00003406 	br	82315b8 <t_sendto+0x1e0>
   /* fall through for non-stream sockets: SOCK_DGRAM (UDP) and
    * SOCK_RAW (raw IP)
    */

   /* check length against underlying stack's maximum */
   if (len > sendlen)
 82314e8:	e0fffb17 	ldw	r3,-20(fp)
 82314ec:	e0bffe17 	ldw	r2,-8(fp)
 82314f0:	1880050e 	bge	r3,r2,8231508 <t_sendto+0x130>
   {
      so->so_error = EMSGSIZE;
 82314f4:	e0bff917 	ldw	r2,-28(fp)
 82314f8:	00c01e84 	movi	r3,122
 82314fc:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8231500:	00bfffc4 	movi	r2,-1
 8231504:	00002c06 	br	82315b8 <t_sendto+0x1e0>
   /* if a sockaddr was passed, wrap it in an mbuf and pas it into the
    * bowels of the BSD code; else assume this is a bound UDP socket
    * and this call came from t_send() below.
    */

   if (to)  /* sockaddr was passed */
 8231508:	e0800217 	ldw	r2,8(fp)
 823150c:	10000c26 	beq	r2,zero,8231540 <t_sendto+0x168>
   {
      name = sockargs(to, tolen, MT_SONAME);
 8231510:	01800244 	movi	r6,9
 8231514:	e1400317 	ldw	r5,12(fp)
 8231518:	e1000217 	ldw	r4,8(fp)
 823151c:	823196c0 	call	823196c <sockargs>
 8231520:	e0bff715 	stw	r2,-36(fp)
      if(name == NULL)
 8231524:	e0bff717 	ldw	r2,-36(fp)
 8231528:	1000061e 	bne	r2,zero,8231544 <t_sendto+0x16c>
      {
         so->so_error = ENOMEM;
 823152c:	e0bff917 	ldw	r2,-28(fp)
 8231530:	00c00304 	movi	r3,12
 8231534:	10c00615 	stw	r3,24(r2)
         return SOCKET_ERROR;
 8231538:	00bfffc4 	movi	r2,-1
 823153c:	00001e06 	br	82315b8 <t_sendto+0x1e0>
      }
   }
   else     /* hope user called bind() first... */
      name = NULL;
 8231540:	e03ff715 	stw	zero,-36(fp)
   
   sendlen = len;
 8231544:	e0bffe17 	ldw	r2,-8(fp)
 8231548:	e0bffb15 	stw	r2,-20(fp)

   LOCK_NET_RESOURCE(NET_RESID);
 823154c:	0009883a 	mov	r4,zero
 8231550:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>

   err = sosend (so, name, buf, &sendlen, flags);
 8231554:	e0fffb04 	addi	r3,fp,-20
 8231558:	e0bfff17 	ldw	r2,-4(fp)
 823155c:	d8800015 	stw	r2,0(sp)
 8231560:	180f883a 	mov	r7,r3
 8231564:	e1bffd17 	ldw	r6,-12(fp)
 8231568:	e17ff717 	ldw	r5,-36(fp)
 823156c:	e13ff917 	ldw	r4,-28(fp)
 8231570:	82323680 	call	8232368 <sosend>
 8231574:	e0bffa15 	stw	r2,-24(fp)

   if (name)
 8231578:	e0bff717 	ldw	r2,-36(fp)
 823157c:	10000226 	beq	r2,zero,8231588 <t_sendto+0x1b0>
      m_freem(name);
 8231580:	e13ff717 	ldw	r4,-36(fp)
 8231584:	822e6940 	call	822e694 <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 8231588:	0009883a 	mov	r4,zero
 823158c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>

   if (err != 0)
 8231590:	e0bffa17 	ldw	r2,-24(fp)
 8231594:	10000526 	beq	r2,zero,82315ac <t_sendto+0x1d4>
   {
      so->so_error = err;
 8231598:	e0bff917 	ldw	r2,-28(fp)
 823159c:	e0fffa17 	ldw	r3,-24(fp)
 82315a0:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 82315a4:	00bfffc4 	movi	r2,-1
 82315a8:	00000306 	br	82315b8 <t_sendto+0x1e0>
   }

   return (len - sendlen);
 82315ac:	e0bffb17 	ldw	r2,-20(fp)
 82315b0:	e0fffe17 	ldw	r3,-8(fp)
 82315b4:	1885c83a 	sub	r2,r3,r2
}
 82315b8:	e037883a 	mov	sp,fp
 82315bc:	dfc00117 	ldw	ra,4(sp)
 82315c0:	df000017 	ldw	fp,0(sp)
 82315c4:	dec00204 	addi	sp,sp,8
 82315c8:	f800283a 	ret

082315cc <t_send>:
int
t_send(long s, 
   char *   buf,
   int      len, 
   int      flags)
{
 82315cc:	defff104 	addi	sp,sp,-60
 82315d0:	dfc00e15 	stw	ra,56(sp)
 82315d4:	df000d15 	stw	fp,52(sp)
 82315d8:	df000d04 	addi	fp,sp,52
 82315dc:	e13ffc15 	stw	r4,-16(fp)
 82315e0:	e17ffd15 	stw	r5,-12(fp)
 82315e4:	e1bffe15 	stw	r6,-8(fp)
 82315e8:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   e;       /* error holder */
   int   total_sent  =  0;
 82315ec:	e03ff515 	stw	zero,-44(fp)
   int   maxpkt;
   int   sendlen;
   int   sent;

   so = LONG2SO(s);
 82315f0:	e0bffc17 	ldw	r2,-16(fp)
 82315f4:	10bff804 	addi	r2,r2,-32
 82315f8:	1085883a 	add	r2,r2,r2
 82315fc:	1085883a 	add	r2,r2,r2
 8231600:	e0bff715 	stw	r2,-36(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 8231604:	e0bff717 	ldw	r2,-36(fp)
 8231608:	1080088b 	ldhu	r2,34(r2)
 823160c:	10bfffcc 	andi	r2,r2,65535
 8231610:	1080038c 	andi	r2,r2,14
 8231614:	108000a0 	cmpeqi	r2,r2,2
 8231618:	1000051e 	bne	r2,zero,8231630 <t_send+0x64>
   {
      so->so_error = EPIPE;
 823161c:	e0bff717 	ldw	r2,-36(fp)
 8231620:	00c00804 	movi	r3,32
 8231624:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8231628:	00bfffc4 	movi	r2,-1
 823162c:	00006306 	br	82317bc <t_send+0x1f0>
   }
   so->so_error = 0;
 8231630:	e0bff717 	ldw	r2,-36(fp)
 8231634:	10000615 	stw	zero,24(r2)

   /* If this is not a stream socket, assume it is bound and pass to
    * t_sendto() with a null sockaddr
    */
   if (so->so_type != SOCK_STREAM)
 8231638:	e0bff717 	ldw	r2,-36(fp)
 823163c:	10800983 	ldbu	r2,38(r2)
 8231640:	10803fcc 	andi	r2,r2,255
 8231644:	1080201c 	xori	r2,r2,128
 8231648:	10bfe004 	addi	r2,r2,-128
 823164c:	10800060 	cmpeqi	r2,r2,1
 8231650:	1000081e 	bne	r2,zero,8231674 <t_send+0xa8>
      return(t_sendto(s, buf, len, flags, NULL, 0));
 8231654:	d8000115 	stw	zero,4(sp)
 8231658:	d8000015 	stw	zero,0(sp)
 823165c:	e1ffff17 	ldw	r7,-4(fp)
 8231660:	e1bffe17 	ldw	r6,-8(fp)
 8231664:	e17ffd17 	ldw	r5,-12(fp)
 8231668:	e13ffc17 	ldw	r4,-16(fp)
 823166c:	82313d80 	call	82313d8 <t_sendto>
 8231670:	00005206 	br	82317bc <t_send+0x1f0>

   maxpkt = TCP_MSS;
 8231674:	00816d04 	movi	r2,1460
 8231678:	e0bff615 	stw	r2,-40(fp)
   if(so->so_pcb)
 823167c:	e0bff717 	ldw	r2,-36(fp)
 8231680:	10800117 	ldw	r2,4(r2)
 8231684:	10004826 	beq	r2,zero,82317a8 <t_send+0x1dc>
   { 
      struct tcpcb * tp;
      tp = intotcpcb(so->so_pcb);   /* get tcp structure with mss */
 8231688:	e0bff717 	ldw	r2,-36(fp)
 823168c:	10800117 	ldw	r2,4(r2)
 8231690:	10800917 	ldw	r2,36(r2)
 8231694:	e0bff815 	stw	r2,-32(fp)
      if(tp->t_maxseg)              /* Make sure it's set */
 8231698:	e0bff817 	ldw	r2,-32(fp)
 823169c:	10800a0b 	ldhu	r2,40(r2)
 82316a0:	10bfffcc 	andi	r2,r2,65535
 82316a4:	10004026 	beq	r2,zero,82317a8 <t_send+0x1dc>
         maxpkt = tp->t_maxseg;
 82316a8:	e0bff817 	ldw	r2,-32(fp)
 82316ac:	10800a0b 	ldhu	r2,40(r2)
 82316b0:	10bfffcc 	andi	r2,r2,65535
 82316b4:	e0bff615 	stw	r2,-40(fp)
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 82316b8:	00003b06 	br	82317a8 <t_send+0x1dc>
   {
      if (len > maxpkt)
 82316bc:	e0bffe17 	ldw	r2,-8(fp)
 82316c0:	e0fff617 	ldw	r3,-40(fp)
 82316c4:	1880030e 	bge	r3,r2,82316d4 <t_send+0x108>
         sendlen = maxpkt;  /* take biggest block we can */
 82316c8:	e0bff617 	ldw	r2,-40(fp)
 82316cc:	e0bffb15 	stw	r2,-20(fp)
 82316d0:	00000206 	br	82316dc <t_send+0x110>
      else
         sendlen = len;
 82316d4:	e0bffe17 	ldw	r2,-8(fp)
 82316d8:	e0bffb15 	stw	r2,-20(fp)
      sent = sendlen;
 82316dc:	e0bffb17 	ldw	r2,-20(fp)
 82316e0:	e0bff915 	stw	r2,-28(fp)

      LOCK_NET_RESOURCE(NET_RESID);
 82316e4:	0009883a 	mov	r4,zero
 82316e8:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      e = sosend (so, NULL, buf, &sendlen, flags);
 82316ec:	e0fffb04 	addi	r3,fp,-20
 82316f0:	e0bfff17 	ldw	r2,-4(fp)
 82316f4:	d8800015 	stw	r2,0(sp)
 82316f8:	180f883a 	mov	r7,r3
 82316fc:	e1bffd17 	ldw	r6,-12(fp)
 8231700:	000b883a 	mov	r5,zero
 8231704:	e13ff717 	ldw	r4,-36(fp)
 8231708:	82323680 	call	8232368 <sosend>
 823170c:	e0bffa15 	stw	r2,-24(fp)
      UNLOCK_NET_RESOURCE(NET_RESID);
 8231710:	0009883a 	mov	r4,zero
 8231714:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
 
      if (e != 0)  /* sock_sendit failed? */
 8231718:	e0bffa17 	ldw	r2,-24(fp)
 823171c:	10001026 	beq	r2,zero,8231760 <t_send+0x194>
      {
         /* if we simply ran out of bufs, report back to caller. */
         if ((e == ENOBUFS) || (e == EWOULDBLOCK))
 8231720:	e0bffa17 	ldw	r2,-24(fp)
 8231724:	10801a60 	cmpeqi	r2,r2,105
 8231728:	1000031e 	bne	r2,zero,8231738 <t_send+0x16c>
 823172c:	e0bffa17 	ldw	r2,-24(fp)
 8231730:	108002d8 	cmpnei	r2,r2,11
 8231734:	1000051e 	bne	r2,zero,823174c <t_send+0x180>
            /* if we actually sent something before running out
             * of buffers, report what we sent; 
             * else, report the error and let the application 
             * retry the call later
             */
            if (total_sent != 0)
 8231738:	e0bff517 	ldw	r2,-44(fp)
 823173c:	10000326 	beq	r2,zero,823174c <t_send+0x180>
            {
               so->so_error = 0;
 8231740:	e0bff717 	ldw	r2,-36(fp)
 8231744:	10000615 	stw	zero,24(r2)
               break;      /* break out of while(len) loop */
 8231748:	00001b06 	br	82317b8 <t_send+0x1ec>
            }
         }
         so->so_error = e;
 823174c:	e0bff717 	ldw	r2,-36(fp)
 8231750:	e0fffa17 	ldw	r3,-24(fp)
 8231754:	10c00615 	stw	r3,24(r2)
         return SOCKET_ERROR;
 8231758:	00bfffc4 	movi	r2,-1
 823175c:	00001706 	br	82317bc <t_send+0x1f0>
      }
      /* if we can't send anymore, return now */
      if (sendlen != 0)
 8231760:	e0bffb17 	ldw	r2,-20(fp)
 8231764:	1000131e 	bne	r2,zero,82317b4 <t_send+0x1e8>
         break;         /* break out of while(len) loop */

      /* adjust numbers & pointers, and go do next send loop */
      sent -= sendlen;        /* subtract anything that didn't get sent */
 8231768:	e0bffb17 	ldw	r2,-20(fp)
 823176c:	e0fff917 	ldw	r3,-28(fp)
 8231770:	1885c83a 	sub	r2,r3,r2
 8231774:	e0bff915 	stw	r2,-28(fp)
      buf += sent;
 8231778:	e0bff917 	ldw	r2,-28(fp)
 823177c:	e0fffd17 	ldw	r3,-12(fp)
 8231780:	1885883a 	add	r2,r3,r2
 8231784:	e0bffd15 	stw	r2,-12(fp)
      len -= sent;
 8231788:	e0fffe17 	ldw	r3,-8(fp)
 823178c:	e0bff917 	ldw	r2,-28(fp)
 8231790:	1885c83a 	sub	r2,r3,r2
 8231794:	e0bffe15 	stw	r2,-8(fp)
      total_sent += sent;
 8231798:	e0fff517 	ldw	r3,-44(fp)
 823179c:	e0bff917 	ldw	r2,-28(fp)
 82317a0:	1885883a 	add	r2,r3,r2
 82317a4:	e0bff515 	stw	r2,-44(fp)
         maxpkt = tp->t_maxseg;
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 82317a8:	e0bffe17 	ldw	r2,-8(fp)
 82317ac:	103fc31e 	bne	r2,zero,82316bc <t_send+0xf0>
 82317b0:	00000106 	br	82317b8 <t_send+0x1ec>
         so->so_error = e;
         return SOCKET_ERROR;
      }
      /* if we can't send anymore, return now */
      if (sendlen != 0)
         break;         /* break out of while(len) loop */
 82317b4:	0001883a 	nop
      len -= sent;
      total_sent += sent;
   }

   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   return total_sent;
 82317b8:	e0bff517 	ldw	r2,-44(fp)
}
 82317bc:	e037883a 	mov	sp,fp
 82317c0:	dfc00117 	ldw	ra,4(sp)
 82317c4:	df000017 	ldw	fp,0(sp)
 82317c8:	dec00204 	addi	sp,sp,8
 82317cc:	f800283a 	ret

082317d0 <t_shutdown>:
 * RETURNS: 
 */

int
t_shutdown(long s, int   how)
{
 82317d0:	defff904 	addi	sp,sp,-28
 82317d4:	dfc00615 	stw	ra,24(sp)
 82317d8:	df000515 	stw	fp,20(sp)
 82317dc:	df000504 	addi	fp,sp,20
 82317e0:	e13ffe15 	stw	r4,-8(fp)
 82317e4:	e17fff15 	stw	r5,-4(fp)
   struct socket *so;
   int   err;

   so = LONG2SO(s);
 82317e8:	e0bffe17 	ldw	r2,-8(fp)
 82317ec:	10bff804 	addi	r2,r2,-32
 82317f0:	1085883a 	add	r2,r2,r2
 82317f4:	1085883a 	add	r2,r2,r2
 82317f8:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 82317fc:	008209b4 	movhi	r2,2086
 8231800:	10b97a04 	addi	r2,r2,-6680
 8231804:	e0bffb15 	stw	r2,-20(fp)
 8231808:	00000606 	br	8231824 <t_shutdown+0x54>
 823180c:	e0fffb17 	ldw	r3,-20(fp)
 8231810:	e0bffc17 	ldw	r2,-16(fp)
 8231814:	18800626 	beq	r3,r2,8231830 <t_shutdown+0x60>
 8231818:	e0bffb17 	ldw	r2,-20(fp)
 823181c:	10800017 	ldw	r2,0(r2)
 8231820:	e0bffb15 	stw	r2,-20(fp)
 8231824:	e0bffb17 	ldw	r2,-20(fp)
 8231828:	103ff81e 	bne	r2,zero,823180c <t_shutdown+0x3c>
 823182c:	00000106 	br	8231834 <t_shutdown+0x64>
 8231830:	0001883a 	nop
 8231834:	e0fffb17 	ldw	r3,-20(fp)
 8231838:	e0bffc17 	ldw	r2,-16(fp)
 823183c:	18800326 	beq	r3,r2,823184c <t_shutdown+0x7c>
 8231840:	822d5f00 	call	822d5f0 <dtrap>
 8231844:	00bfffc4 	movi	r2,-1
 8231848:	00001206 	br	8231894 <t_shutdown+0xc4>
   so->so_error = 0;
 823184c:	e0bffc17 	ldw	r2,-16(fp)
 8231850:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:shutdown so %x how %d\n", so, how));

   LOCK_NET_RESOURCE(NET_RESID);
 8231854:	0009883a 	mov	r4,zero
 8231858:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   err = soshutdown(so, how);
 823185c:	e17fff17 	ldw	r5,-4(fp)
 8231860:	e13ffc17 	ldw	r4,-16(fp)
 8231864:	823300c0 	call	823300c <soshutdown>
 8231868:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 823186c:	0009883a 	mov	r4,zero
 8231870:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>

   if (err != 0)
 8231874:	e0bffd17 	ldw	r2,-12(fp)
 8231878:	10000526 	beq	r2,zero,8231890 <t_shutdown+0xc0>
   {
      so->so_error = err;
 823187c:	e0bffc17 	ldw	r2,-16(fp)
 8231880:	e0fffd17 	ldw	r3,-12(fp)
 8231884:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8231888:	00bfffc4 	movi	r2,-1
 823188c:	00000106 	br	8231894 <t_shutdown+0xc4>
   }
   return 0;
 8231890:	0005883a 	mov	r2,zero
}
 8231894:	e037883a 	mov	sp,fp
 8231898:	dfc00117 	ldw	ra,4(sp)
 823189c:	df000017 	ldw	fp,0(sp)
 82318a0:	dec00204 	addi	sp,sp,8
 82318a4:	f800283a 	ret

082318a8 <t_socketclose>:
 * RETURNS: 
 */

int
t_socketclose(long s)
{
 82318a8:	defffa04 	addi	sp,sp,-24
 82318ac:	dfc00515 	stw	ra,20(sp)
 82318b0:	df000415 	stw	fp,16(sp)
 82318b4:	df000404 	addi	fp,sp,16
 82318b8:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 82318bc:	e0bfff17 	ldw	r2,-4(fp)
 82318c0:	10bff804 	addi	r2,r2,-32
 82318c4:	1085883a 	add	r2,r2,r2
 82318c8:	1085883a 	add	r2,r2,r2
 82318cc:	e0bffd15 	stw	r2,-12(fp)
   SOC_CHECK(so);
 82318d0:	008209b4 	movhi	r2,2086
 82318d4:	10b97a04 	addi	r2,r2,-6680
 82318d8:	e0bffc15 	stw	r2,-16(fp)
 82318dc:	00000606 	br	82318f8 <t_socketclose+0x50>
 82318e0:	e0fffc17 	ldw	r3,-16(fp)
 82318e4:	e0bffd17 	ldw	r2,-12(fp)
 82318e8:	18800626 	beq	r3,r2,8231904 <t_socketclose+0x5c>
 82318ec:	e0bffc17 	ldw	r2,-16(fp)
 82318f0:	10800017 	ldw	r2,0(r2)
 82318f4:	e0bffc15 	stw	r2,-16(fp)
 82318f8:	e0bffc17 	ldw	r2,-16(fp)
 82318fc:	103ff81e 	bne	r2,zero,82318e0 <t_socketclose+0x38>
 8231900:	00000106 	br	8231908 <t_socketclose+0x60>
 8231904:	0001883a 	nop
 8231908:	e0fffc17 	ldw	r3,-16(fp)
 823190c:	e0bffd17 	ldw	r2,-12(fp)
 8231910:	18800326 	beq	r3,r2,8231920 <t_socketclose+0x78>
 8231914:	822d5f00 	call	822d5f0 <dtrap>
 8231918:	00bfffc4 	movi	r2,-1
 823191c:	00000e06 	br	8231958 <t_socketclose+0xb0>
   so->so_error = 0;
 8231920:	e0bffd17 	ldw	r2,-12(fp)
 8231924:	10000615 	stw	zero,24(r2)
   INET_TRACE ((INETM_CLOSE|INETM_SOCKET), ("INET:close, so %lx\n",so));

   LOCK_NET_RESOURCE(NET_RESID);
 8231928:	0009883a 	mov	r4,zero
 823192c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   err = soclose(so);
 8231930:	e13ffd17 	ldw	r4,-12(fp)
 8231934:	8231e740 	call	8231e74 <soclose>
 8231938:	e0bffe15 	stw	r2,-8(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 823193c:	0009883a 	mov	r4,zero
 8231940:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 8231944:	e0bffe17 	ldw	r2,-8(fp)
 8231948:	10000226 	beq	r2,zero,8231954 <t_socketclose+0xac>
   {
      /* do not do the following assignment since the socket structure
         addressed by so has been freed by this point, jharan 12-10-98 */
      /*      so->so_error = err;   */
      return SOCKET_ERROR;
 823194c:	00bfffc4 	movi	r2,-1
 8231950:	00000106 	br	8231958 <t_socketclose+0xb0>
   }
   return 0;
 8231954:	0005883a 	mov	r2,zero
}
 8231958:	e037883a 	mov	sp,fp
 823195c:	dfc00117 	ldw	ra,4(sp)
 8231960:	df000017 	ldw	fp,0(sp)
 8231964:	dec00204 	addi	sp,sp,8
 8231968:	f800283a 	ret

0823196c <sockargs>:

static struct mbuf  * 
sockargs (void * arg, 
   int   arglen, 
   int   type)
{
 823196c:	defffa04 	addi	sp,sp,-24
 8231970:	dfc00515 	stw	ra,20(sp)
 8231974:	df000415 	stw	fp,16(sp)
 8231978:	df000404 	addi	fp,sp,16
 823197c:	e13ffd15 	stw	r4,-12(fp)
 8231980:	e17ffe15 	stw	r5,-8(fp)
 8231984:	e1bfff15 	stw	r6,-4(fp)
   struct mbuf *  m;

   LOCK_NET_RESOURCE(NET_RESID);    /* protect mfreeq */
 8231988:	0009883a 	mov	r4,zero
 823198c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   m = m_getwithdata (type, arglen);
 8231990:	e17ffe17 	ldw	r5,-8(fp)
 8231994:	e13fff17 	ldw	r4,-4(fp)
 8231998:	822e4040 	call	822e404 <m_getnbuf>
 823199c:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 82319a0:	0009883a 	mov	r4,zero
 82319a4:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   if (m == NULL)
 82319a8:	e0bffc17 	ldw	r2,-16(fp)
 82319ac:	1000021e 	bne	r2,zero,82319b8 <sockargs+0x4c>
      return NULL;
 82319b0:	0005883a 	mov	r2,zero
 82319b4:	00000b06 	br	82319e4 <sockargs+0x78>
   m->m_len = arglen;
 82319b8:	e0fffe17 	ldw	r3,-8(fp)
 82319bc:	e0bffc17 	ldw	r2,-16(fp)
 82319c0:	10c00215 	stw	r3,8(r2)
   MEMCPY(mtod (m, char *), arg, arglen);
 82319c4:	e0bffc17 	ldw	r2,-16(fp)
 82319c8:	10800317 	ldw	r2,12(r2)
 82319cc:	e0fffe17 	ldw	r3,-8(fp)
 82319d0:	180d883a 	mov	r6,r3
 82319d4:	e17ffd17 	ldw	r5,-12(fp)
 82319d8:	1009883a 	mov	r4,r2
 82319dc:	8202f6c0 	call	8202f6c <memcpy>
   return m;
 82319e0:	e0bffc17 	ldw	r2,-16(fp)
}
 82319e4:	e037883a 	mov	sp,fp
 82319e8:	dfc00117 	ldw	ra,4(sp)
 82319ec:	df000017 	ldw	fp,0(sp)
 82319f0:	dec00204 	addi	sp,sp,8
 82319f4:	f800283a 	ret

082319f8 <t_errno>:
 *                            ENOTSOCK if socket not found
 */

int
t_errno(long s)
{
 82319f8:	defffa04 	addi	sp,sp,-24
 82319fc:	dfc00515 	stw	ra,20(sp)
 8231a00:	df000415 	stw	fp,16(sp)
 8231a04:	df000404 	addi	fp,sp,16
 8231a08:	e13fff15 	stw	r4,-4(fp)
   struct socket *so = LONG2SO(s);
 8231a0c:	e0bfff17 	ldw	r2,-4(fp)
 8231a10:	10bff804 	addi	r2,r2,-32
 8231a14:	1085883a 	add	r2,r2,r2
 8231a18:	1085883a 	add	r2,r2,r2
 8231a1c:	e0bffe15 	stw	r2,-8(fp)
   struct socket *tmp;
   int errcode = ENOTSOCK;
 8231a20:	00801b04 	movi	r2,108
 8231a24:	e0bffd15 	stw	r2,-12(fp)

   LOCK_NET_RESOURCE(NET_RESID);    /* protect soq */
 8231a28:	0009883a 	mov	r4,zero
 8231a2c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 8231a30:	008209b4 	movhi	r2,2086
 8231a34:	10b97a04 	addi	r2,r2,-6680
 8231a38:	e0bffc15 	stw	r2,-16(fp)
 8231a3c:	00000a06 	br	8231a68 <t_errno+0x70>
   {
      if (tmp == so)  /* found socket, return error */
 8231a40:	e0fffc17 	ldw	r3,-16(fp)
 8231a44:	e0bffe17 	ldw	r2,-8(fp)
 8231a48:	1880041e 	bne	r3,r2,8231a5c <t_errno+0x64>
      {
         errcode = so->so_error;
 8231a4c:	e0bffe17 	ldw	r2,-8(fp)
 8231a50:	10800617 	ldw	r2,24(r2)
 8231a54:	e0bffd15 	stw	r2,-12(fp)
         break;
 8231a58:	00000506 	br	8231a70 <t_errno+0x78>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 8231a5c:	e0bffc17 	ldw	r2,-16(fp)
 8231a60:	10800017 	ldw	r2,0(r2)
 8231a64:	e0bffc15 	stw	r2,-16(fp)
 8231a68:	e0bffc17 	ldw	r2,-16(fp)
 8231a6c:	103ff41e 	bne	r2,zero,8231a40 <t_errno+0x48>
         errcode = so->so_error;
         break;
      }
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 8231a70:	0009883a 	mov	r4,zero
 8231a74:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>

   return errcode;
 8231a78:	e0bffd17 	ldw	r2,-12(fp)
}
 8231a7c:	e037883a 	mov	sp,fp
 8231a80:	dfc00117 	ldw	ra,4(sp)
 8231a84:	df000017 	ldw	fp,0(sp)
 8231a88:	dec00204 	addi	sp,sp,8
 8231a8c:	f800283a 	ret

08231a90 <socreate>:
 * RETURNS: 
 */

struct socket *   
socreate (int dom, int type, int proto)
{
 8231a90:	defff704 	addi	sp,sp,-36
 8231a94:	dfc00815 	stw	ra,32(sp)
 8231a98:	df000715 	stw	fp,28(sp)
 8231a9c:	df000704 	addi	fp,sp,28
 8231aa0:	e13ffd15 	stw	r4,-12(fp)
 8231aa4:	e17ffe15 	stw	r5,-8(fp)
 8231aa8:	e1bfff15 	stw	r6,-4(fp)
   struct protosw *prp;
   struct socket *so;
   int   error;
   int rc;

   if (proto)
 8231aac:	e0bfff17 	ldw	r2,-4(fp)
 8231ab0:	10000626 	beq	r2,zero,8231acc <socreate+0x3c>
      prp = pffindproto(dom, proto, type);
 8231ab4:	e1bffe17 	ldw	r6,-8(fp)
 8231ab8:	e17fff17 	ldw	r5,-4(fp)
 8231abc:	e13ffd17 	ldw	r4,-12(fp)
 8231ac0:	822e3400 	call	822e340 <pffindproto>
 8231ac4:	e0bff915 	stw	r2,-28(fp)
 8231ac8:	00000406 	br	8231adc <socreate+0x4c>
   else
      prp = pffindtype(dom, type);
 8231acc:	e17ffe17 	ldw	r5,-8(fp)
 8231ad0:	e13ffd17 	ldw	r4,-12(fp)
 8231ad4:	822e2b00 	call	822e2b0 <pffindtype>
 8231ad8:	e0bff915 	stw	r2,-28(fp)
   if (prp == 0)
 8231adc:	e0bff917 	ldw	r2,-28(fp)
 8231ae0:	1000021e 	bne	r2,zero,8231aec <socreate+0x5c>
      return NULL;
 8231ae4:	0005883a 	mov	r2,zero
 8231ae8:	00004e06 	br	8231c24 <socreate+0x194>
   if (prp->pr_type != type)
 8231aec:	e0bff917 	ldw	r2,-28(fp)
 8231af0:	1080000b 	ldhu	r2,0(r2)
 8231af4:	10ffffcc 	andi	r3,r2,65535
 8231af8:	18e0001c 	xori	r3,r3,32768
 8231afc:	18e00004 	addi	r3,r3,-32768
 8231b00:	e0bffe17 	ldw	r2,-8(fp)
 8231b04:	18800226 	beq	r3,r2,8231b10 <socreate+0x80>
      return NULL;
 8231b08:	0005883a 	mov	r2,zero
 8231b0c:	00004506 	br	8231c24 <socreate+0x194>
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 8231b10:	01002104 	movi	r4,132
 8231b14:	822e1c80 	call	822e1c8 <npalloc>
 8231b18:	e0bffa15 	stw	r2,-24(fp)
 8231b1c:	e0bffa17 	ldw	r2,-24(fp)
 8231b20:	1000021e 	bne	r2,zero,8231b2c <socreate+0x9c>
      return NULL;
 8231b24:	0005883a 	mov	r2,zero
 8231b28:	00003e06 	br	8231c24 <socreate+0x194>
   so->next = NULL;
 8231b2c:	e0bffa17 	ldw	r2,-24(fp)
 8231b30:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);
 8231b34:	e17ffa17 	ldw	r5,-24(fp)
 8231b38:	010209b4 	movhi	r4,2086
 8231b3c:	21397a04 	addi	r4,r4,-6680
 8231b40:	822cfd80 	call	822cfd8 <putq>

   so->so_options = socket_defaults;
 8231b44:	d0a03c0b 	ldhu	r2,-32528(gp)
 8231b48:	10ffffcc 	andi	r3,r2,65535
 8231b4c:	e0bffa17 	ldw	r2,-24(fp)
 8231b50:	10c00415 	stw	r3,16(r2)
   so->so_domain = dom;
 8231b54:	e0bffa17 	ldw	r2,-24(fp)
 8231b58:	e0fffd17 	ldw	r3,-12(fp)
 8231b5c:	10c00515 	stw	r3,20(r2)
   so->so_state = 0;
 8231b60:	e0bffa17 	ldw	r2,-24(fp)
 8231b64:	1000088d 	sth	zero,34(r2)
   so->so_type = (char)type;
 8231b68:	e0bffe17 	ldw	r2,-8(fp)
 8231b6c:	1007883a 	mov	r3,r2
 8231b70:	e0bffa17 	ldw	r2,-24(fp)
 8231b74:	10c00985 	stb	r3,38(r2)
   so->so_proto = prp;
 8231b78:	e0bffa17 	ldw	r2,-24(fp)
 8231b7c:	e0fff917 	ldw	r3,-28(fp)
 8231b80:	10c00215 	stw	r3,8(r2)

#ifdef IP_MULTICAST
   so->inp_moptions = NULL;
 8231b84:	e0bffa17 	ldw	r2,-24(fp)
 8231b88:	10000315 	stw	zero,12(r2)
#endif   /* IP_MULTICAST */

   so->so_req = PRU_ATTACH;
 8231b8c:	e0bffa17 	ldw	r2,-24(fp)
 8231b90:	10000715 	stw	zero,28(r2)
   error = (*prp->pr_usrreq)(so,(struct mbuf *)0, LONG2MBUF((long)proto));
 8231b94:	e0bff917 	ldw	r2,-28(fp)
 8231b98:	10800317 	ldw	r2,12(r2)
 8231b9c:	e0ffff17 	ldw	r3,-4(fp)
 8231ba0:	180d883a 	mov	r6,r3
 8231ba4:	000b883a 	mov	r5,zero
 8231ba8:	e13ffa17 	ldw	r4,-24(fp)
 8231bac:	103ee83a 	callr	r2
 8231bb0:	e0bffb15 	stw	r2,-20(fp)
   if (error) goto bad;
 8231bb4:	e0bffb17 	ldw	r2,-20(fp)
 8231bb8:	10000a1e 	bne	r2,zero,8231be4 <socreate+0x154>

   if (so_evtmap)
 8231bbc:	d0a0ce03 	ldbu	r2,-31944(gp)
 8231bc0:	10803fcc 	andi	r2,r2,255
 8231bc4:	10001626 	beq	r2,zero,8231c20 <socreate+0x190>
   {                       
      rc = (*so_evtmap_create) (so);
 8231bc8:	d0a0cc17 	ldw	r2,-31952(gp)
 8231bcc:	e13ffa17 	ldw	r4,-24(fp)
 8231bd0:	103ee83a 	callr	r2
 8231bd4:	e0bffc15 	stw	r2,-16(fp)
      if (rc != 0)
 8231bd8:	e0bffc17 	ldw	r2,-16(fp)
 8231bdc:	10000c26 	beq	r2,zero,8231c10 <socreate+0x180>
 8231be0:	00000106 	br	8231be8 <socreate+0x158>
   so->inp_moptions = NULL;
#endif   /* IP_MULTICAST */

   so->so_req = PRU_ATTACH;
   error = (*prp->pr_usrreq)(so,(struct mbuf *)0, LONG2MBUF((long)proto));
   if (error) goto bad;
 8231be4:	0001883a 	nop
   {                       
      rc = (*so_evtmap_create) (so);
      if (rc != 0)
      {
bad:   
         so->so_state |= SS_NOFDREF;
 8231be8:	e0bffa17 	ldw	r2,-24(fp)
 8231bec:	1080088b 	ldhu	r2,34(r2)
 8231bf0:	10800054 	ori	r2,r2,1
 8231bf4:	1007883a 	mov	r3,r2
 8231bf8:	e0bffa17 	ldw	r2,-24(fp)
 8231bfc:	10c0088d 	sth	r3,34(r2)
         sofree (so);
 8231c00:	e13ffa17 	ldw	r4,-24(fp)
 8231c04:	8231d640 	call	8231d64 <sofree>
         return NULL;   
 8231c08:	0005883a 	mov	r2,zero
 8231c0c:	00000506 	br	8231c24 <socreate+0x194>
      /*
       * Altera Niche Stack Nios port modification:
       * Remove (void *) cast since -> owner is now TK_OBJECT
       * to fix build warning.
       */
      so->owner = TK_THIS;
 8231c10:	82297fc0 	call	82297fc <TK_OSTaskQuery>
 8231c14:	1007883a 	mov	r3,r2
 8231c18:	e0bffa17 	ldw	r2,-24(fp)
 8231c1c:	10c02005 	stb	r3,128(r2)
   }

   return so;
 8231c20:	e0bffa17 	ldw	r2,-24(fp)
}
 8231c24:	e037883a 	mov	sp,fp
 8231c28:	dfc00117 	ldw	ra,4(sp)
 8231c2c:	df000017 	ldw	fp,0(sp)
 8231c30:	dec00204 	addi	sp,sp,8
 8231c34:	f800283a 	ret

08231c38 <sobind>:
 */

int
sobind(struct socket * so, 
   struct mbuf *  nam)
{
 8231c38:	defffb04 	addi	sp,sp,-20
 8231c3c:	dfc00415 	stw	ra,16(sp)
 8231c40:	df000315 	stw	fp,12(sp)
 8231c44:	df000304 	addi	fp,sp,12
 8231c48:	e13ffe15 	stw	r4,-8(fp)
 8231c4c:	e17fff15 	stw	r5,-4(fp)
   int   error;

   so->so_req = PRU_BIND;
 8231c50:	e0bffe17 	ldw	r2,-8(fp)
 8231c54:	00c00084 	movi	r3,2
 8231c58:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 8231c5c:	e0bffe17 	ldw	r2,-8(fp)
 8231c60:	10800217 	ldw	r2,8(r2)
 8231c64:	10800317 	ldw	r2,12(r2)
 8231c68:	e1bfff17 	ldw	r6,-4(fp)
 8231c6c:	000b883a 	mov	r5,zero
 8231c70:	e13ffe17 	ldw	r4,-8(fp)
 8231c74:	103ee83a 	callr	r2
 8231c78:	e0bffd15 	stw	r2,-12(fp)
   return (error);
 8231c7c:	e0bffd17 	ldw	r2,-12(fp)
}
 8231c80:	e037883a 	mov	sp,fp
 8231c84:	dfc00117 	ldw	ra,4(sp)
 8231c88:	df000017 	ldw	fp,0(sp)
 8231c8c:	dec00204 	addi	sp,sp,8
 8231c90:	f800283a 	ret

08231c94 <solisten>:
 */

int
solisten(struct socket * so, 
   int   backlog)
{
 8231c94:	defffb04 	addi	sp,sp,-20
 8231c98:	dfc00415 	stw	ra,16(sp)
 8231c9c:	df000315 	stw	fp,12(sp)
 8231ca0:	df000304 	addi	fp,sp,12
 8231ca4:	e13ffe15 	stw	r4,-8(fp)
 8231ca8:	e17fff15 	stw	r5,-4(fp)
   int   error;

   so->so_req = PRU_LISTEN;
 8231cac:	e0bffe17 	ldw	r2,-8(fp)
 8231cb0:	00c000c4 	movi	r3,3
 8231cb4:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so,
 8231cb8:	e0bffe17 	ldw	r2,-8(fp)
 8231cbc:	10800217 	ldw	r2,8(r2)
 8231cc0:	10800317 	ldw	r2,12(r2)
 8231cc4:	000d883a 	mov	r6,zero
 8231cc8:	000b883a 	mov	r5,zero
 8231ccc:	e13ffe17 	ldw	r4,-8(fp)
 8231cd0:	103ee83a 	callr	r2
 8231cd4:	e0bffd15 	stw	r2,-12(fp)
    (struct mbuf *)0, (struct mbuf *)0);
   if (error) 
 8231cd8:	e0bffd17 	ldw	r2,-12(fp)
 8231cdc:	10000226 	beq	r2,zero,8231ce8 <solisten+0x54>
   {
      return (error);
 8231ce0:	e0bffd17 	ldw	r2,-12(fp)
 8231ce4:	00001a06 	br	8231d50 <solisten+0xbc>
   }
   if (so->so_q == 0) 
 8231ce8:	e0bffe17 	ldw	r2,-8(fp)
 8231cec:	10801d17 	ldw	r2,116(r2)
 8231cf0:	10000b1e 	bne	r2,zero,8231d20 <solisten+0x8c>
   {
      so->so_q = so;
 8231cf4:	e0bffe17 	ldw	r2,-8(fp)
 8231cf8:	e0fffe17 	ldw	r3,-8(fp)
 8231cfc:	10c01d15 	stw	r3,116(r2)
      so->so_q0 = so;
 8231d00:	e0bffe17 	ldw	r2,-8(fp)
 8231d04:	e0fffe17 	ldw	r3,-8(fp)
 8231d08:	10c01c15 	stw	r3,112(r2)
      so->so_options |= SO_ACCEPTCONN;
 8231d0c:	e0bffe17 	ldw	r2,-8(fp)
 8231d10:	10800417 	ldw	r2,16(r2)
 8231d14:	10c00094 	ori	r3,r2,2
 8231d18:	e0bffe17 	ldw	r2,-8(fp)
 8231d1c:	10c00415 	stw	r3,16(r2)
   }
   if (backlog < 0)
 8231d20:	e0bfff17 	ldw	r2,-4(fp)
 8231d24:	1000010e 	bge	r2,zero,8231d2c <solisten+0x98>
      backlog = 0;
 8231d28:	e03fff15 	stw	zero,-4(fp)
   so->so_qlimit = (char)MIN(backlog, SOMAXCONN);
 8231d2c:	e0bfff17 	ldw	r2,-4(fp)
 8231d30:	10800188 	cmpgei	r2,r2,6
 8231d34:	1000021e 	bne	r2,zero,8231d40 <solisten+0xac>
 8231d38:	e0bfff17 	ldw	r2,-4(fp)
 8231d3c:	00000106 	br	8231d44 <solisten+0xb0>
 8231d40:	00800144 	movi	r2,5
 8231d44:	e0fffe17 	ldw	r3,-8(fp)
 8231d48:	18801e85 	stb	r2,122(r3)
   return 0;
 8231d4c:	0005883a 	mov	r2,zero
}
 8231d50:	e037883a 	mov	sp,fp
 8231d54:	dfc00117 	ldw	ra,4(sp)
 8231d58:	df000017 	ldw	fp,0(sp)
 8231d5c:	dec00204 	addi	sp,sp,8
 8231d60:	f800283a 	ret

08231d64 <sofree>:
 * RETURNS: 
 */

void
sofree(struct socket * so)
{
 8231d64:	defffd04 	addi	sp,sp,-12
 8231d68:	dfc00215 	stw	ra,8(sp)
 8231d6c:	df000115 	stw	fp,4(sp)
 8231d70:	df000104 	addi	fp,sp,4
 8231d74:	e13fff15 	stw	r4,-4(fp)
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sofree, so %lx so_pcb %lx so_state %x so_head %lx\n",
    so, so->so_pcb, so->so_state, so->so_head));

   if (so->so_pcb || (so->so_state & SS_NOFDREF) == 0)
 8231d78:	e0bfff17 	ldw	r2,-4(fp)
 8231d7c:	10800117 	ldw	r2,4(r2)
 8231d80:	1000361e 	bne	r2,zero,8231e5c <sofree+0xf8>
 8231d84:	e0bfff17 	ldw	r2,-4(fp)
 8231d88:	1080088b 	ldhu	r2,34(r2)
 8231d8c:	10bfffcc 	andi	r2,r2,65535
 8231d90:	1080004c 	andi	r2,r2,1
 8231d94:	10003126 	beq	r2,zero,8231e5c <sofree+0xf8>
      return;
   if (so->so_head) 
 8231d98:	e0bfff17 	ldw	r2,-4(fp)
 8231d9c:	10801b17 	ldw	r2,108(r2)
 8231da0:	10000d26 	beq	r2,zero,8231dd8 <sofree+0x74>
   {
      if (!soqremque(so, 0) && !soqremque(so, 1))
 8231da4:	000b883a 	mov	r5,zero
 8231da8:	e13fff17 	ldw	r4,-4(fp)
 8231dac:	82340400 	call	8234040 <soqremque>
 8231db0:	1000071e 	bne	r2,zero,8231dd0 <sofree+0x6c>
 8231db4:	01400044 	movi	r5,1
 8231db8:	e13fff17 	ldw	r4,-4(fp)
 8231dbc:	82340400 	call	8234040 <soqremque>
 8231dc0:	1000031e 	bne	r2,zero,8231dd0 <sofree+0x6c>
         panic("sofree");
 8231dc4:	01020974 	movhi	r4,2085
 8231dc8:	21039804 	addi	r4,r4,3680
 8231dcc:	8228ca40 	call	8228ca4 <panic>
      so->so_head = 0;
 8231dd0:	e0bfff17 	ldw	r2,-4(fp)
 8231dd4:	10001b15 	stw	zero,108(r2)
   }
   sbrelease(&so->so_snd);
 8231dd8:	e0bfff17 	ldw	r2,-4(fp)
 8231ddc:	10801204 	addi	r2,r2,72
 8231de0:	1009883a 	mov	r4,r2
 8231de4:	82344040 	call	8234404 <sbrelease>
   sorflush(so);
 8231de8:	e13fff17 	ldw	r4,-4(fp)
 8231dec:	82330a40 	call	82330a4 <sorflush>
      _socket_free_entry (so);
#endif   /* SAVE_SOCK_ENDPOINTS */

#ifdef IP_MULTICAST
   /* multicast opts? */
   if (so->inp_moptions)
 8231df0:	e0bfff17 	ldw	r2,-4(fp)
 8231df4:	10800317 	ldw	r2,12(r2)
 8231df8:	10000426 	beq	r2,zero,8231e0c <sofree+0xa8>
	   ip_freemoptions(so->inp_moptions);
 8231dfc:	e0bfff17 	ldw	r2,-4(fp)
 8231e00:	10800317 	ldw	r2,12(r2)
 8231e04:	1009883a 	mov	r4,r2
 8231e08:	82466d80 	call	82466d8 <ip_freemoptions>
#endif   /* IP_MULTICAST */

   /* IP_TOS opts? */
   if (so->so_optsPack)
 8231e0c:	e0bfff17 	ldw	r2,-4(fp)
 8231e10:	10801f17 	ldw	r2,124(r2)
 8231e14:	10000426 	beq	r2,zero,8231e28 <sofree+0xc4>
      SOCOPT_FREE(so->so_optsPack);
 8231e18:	e0bfff17 	ldw	r2,-4(fp)
 8231e1c:	10801f17 	ldw	r2,124(r2)
 8231e20:	1009883a 	mov	r4,r2
 8231e24:	822e1fc0 	call	822e1fc <npfree>
	   
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 8231e28:	e17fff17 	ldw	r5,-4(fp)
 8231e2c:	010209b4 	movhi	r4,2086
 8231e30:	21397a04 	addi	r4,r4,-6680
 8231e34:	822d0880 	call	822d088 <qdel>
   
   if (so_evtmap)  
 8231e38:	d0a0ce03 	ldbu	r2,-31944(gp)
 8231e3c:	10803fcc 	andi	r2,r2,255
 8231e40:	10000326 	beq	r2,zero,8231e50 <sofree+0xec>
      (*so_evtmap_delete) (so);
 8231e44:	d0a0cd17 	ldw	r2,-31948(gp)
 8231e48:	e13fff17 	ldw	r4,-4(fp)
 8231e4c:	103ee83a 	callr	r2
   
   SOC_FREE(so);
 8231e50:	e13fff17 	ldw	r4,-4(fp)
 8231e54:	822e1fc0 	call	822e1fc <npfree>
 8231e58:	00000106 	br	8231e60 <sofree+0xfc>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sofree, so %lx so_pcb %lx so_state %x so_head %lx\n",
    so, so->so_pcb, so->so_state, so->so_head));

   if (so->so_pcb || (so->so_state & SS_NOFDREF) == 0)
      return;
 8231e5c:	0001883a 	nop
   
   if (so_evtmap)  
      (*so_evtmap_delete) (so);
   
   SOC_FREE(so);
}
 8231e60:	e037883a 	mov	sp,fp
 8231e64:	dfc00117 	ldw	ra,4(sp)
 8231e68:	df000017 	ldw	fp,0(sp)
 8231e6c:	dec00204 	addi	sp,sp,8
 8231e70:	f800283a 	ret

08231e74 <soclose>:
 * RETURNS: 
 */

int
soclose(struct socket * so)
{
 8231e74:	defff904 	addi	sp,sp,-28
 8231e78:	dfc00615 	stw	ra,24(sp)
 8231e7c:	df000515 	stw	fp,20(sp)
 8231e80:	df000504 	addi	fp,sp,20
 8231e84:	e13fff15 	stw	r4,-4(fp)
   int   error =  0;
 8231e88:	e03ffb15 	stw	zero,-20(fp)
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 8231e8c:	008209b4 	movhi	r2,2086
 8231e90:	10b97a04 	addi	r2,r2,-6680
 8231e94:	10800017 	ldw	r2,0(r2)
 8231e98:	e0bffc15 	stw	r2,-16(fp)
 8231e9c:	00000606 	br	8231eb8 <soclose+0x44>
   {
      if (so == tmpso)
 8231ea0:	e0ffff17 	ldw	r3,-4(fp)
 8231ea4:	e0bffc17 	ldw	r2,-16(fp)
 8231ea8:	18800626 	beq	r3,r2,8231ec4 <soclose+0x50>
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 8231eac:	e0bffc17 	ldw	r2,-16(fp)
 8231eb0:	10800017 	ldw	r2,0(r2)
 8231eb4:	e0bffc15 	stw	r2,-16(fp)
 8231eb8:	e0bffc17 	ldw	r2,-16(fp)
 8231ebc:	103ff81e 	bne	r2,zero,8231ea0 <soclose+0x2c>
 8231ec0:	00000106 	br	8231ec8 <soclose+0x54>
   {
      if (so == tmpso)
         break;
 8231ec4:	0001883a 	nop
   }
   if ( tmpso == NULL)
 8231ec8:	e0bffc17 	ldw	r2,-16(fp)
 8231ecc:	1000021e 	bne	r2,zero,8231ed8 <soclose+0x64>
      return EINVAL;
 8231ed0:	00800584 	movi	r2,22
 8231ed4:	00009106 	br	823211c <soclose+0x2a8>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
 8231ed8:	e0bfff17 	ldw	r2,-4(fp)
 8231edc:	10800417 	ldw	r2,16(r2)
 8231ee0:	1080008c 	andi	r2,r2,2
 8231ee4:	10001226 	beq	r2,zero,8231f30 <soclose+0xbc>
   {
      while (so->so_q0 != so)
 8231ee8:	00000406 	br	8231efc <soclose+0x88>
         (void) soabort(so->so_q0);
 8231eec:	e0bfff17 	ldw	r2,-4(fp)
 8231ef0:	10801c17 	ldw	r2,112(r2)
 8231ef4:	1009883a 	mov	r4,r2
 8231ef8:	82321300 	call	8232130 <soabort>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
 8231efc:	e0bfff17 	ldw	r2,-4(fp)
 8231f00:	10c01c17 	ldw	r3,112(r2)
 8231f04:	e0bfff17 	ldw	r2,-4(fp)
 8231f08:	18bff81e 	bne	r3,r2,8231eec <soclose+0x78>
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 8231f0c:	00000406 	br	8231f20 <soclose+0xac>
         (void) soabort(so->so_q);
 8231f10:	e0bfff17 	ldw	r2,-4(fp)
 8231f14:	10801d17 	ldw	r2,116(r2)
 8231f18:	1009883a 	mov	r4,r2
 8231f1c:	82321300 	call	8232130 <soabort>
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 8231f20:	e0bfff17 	ldw	r2,-4(fp)
 8231f24:	10c01d17 	ldw	r3,116(r2)
 8231f28:	e0bfff17 	ldw	r2,-4(fp)
 8231f2c:	18bff81e 	bne	r3,r2,8231f10 <soclose+0x9c>
         (void) soabort(so->so_q);
   }
   /* for datagram-oriented sockets, dispense with further tests */
   if (so->so_type != SOCK_STREAM)
 8231f30:	e0bfff17 	ldw	r2,-4(fp)
 8231f34:	10800983 	ldbu	r2,38(r2)
 8231f38:	10803fcc 	andi	r2,r2,255
 8231f3c:	1080201c 	xori	r2,r2,128
 8231f40:	10bfe004 	addi	r2,r2,-128
 8231f44:	10800060 	cmpeqi	r2,r2,1
 8231f48:	10000c1e 	bne	r2,zero,8231f7c <soclose+0x108>
   { 
      so->so_req = PRU_DETACH;
 8231f4c:	e0bfff17 	ldw	r2,-4(fp)
 8231f50:	00c00044 	movi	r3,1
 8231f54:	10c00715 	stw	r3,28(r2)
      error = (*so->so_proto->pr_usrreq)(so,
 8231f58:	e0bfff17 	ldw	r2,-4(fp)
 8231f5c:	10800217 	ldw	r2,8(r2)
 8231f60:	10800317 	ldw	r2,12(r2)
 8231f64:	000d883a 	mov	r6,zero
 8231f68:	000b883a 	mov	r5,zero
 8231f6c:	e13fff17 	ldw	r4,-4(fp)
 8231f70:	103ee83a 	callr	r2
 8231f74:	e0bffb15 	stw	r2,-20(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      goto discard;
 8231f78:	00005906 	br	82320e0 <soclose+0x26c>
   }

   if (so->so_pcb == 0)
 8231f7c:	e0bfff17 	ldw	r2,-4(fp)
 8231f80:	10800117 	ldw	r2,4(r2)
 8231f84:	10005526 	beq	r2,zero,82320dc <soclose+0x268>
      goto discard;
   if (so->so_state & SS_ISCONNECTED) 
 8231f88:	e0bfff17 	ldw	r2,-4(fp)
 8231f8c:	1080088b 	ldhu	r2,34(r2)
 8231f90:	10bfffcc 	andi	r2,r2,65535
 8231f94:	1080008c 	andi	r2,r2,2
 8231f98:	10003d26 	beq	r2,zero,8232090 <soclose+0x21c>
   {
      if ((so->so_state & SS_ISDISCONNECTING) == 0) 
 8231f9c:	e0bfff17 	ldw	r2,-4(fp)
 8231fa0:	1080088b 	ldhu	r2,34(r2)
 8231fa4:	10bfffcc 	andi	r2,r2,65535
 8231fa8:	1080020c 	andi	r2,r2,8
 8231fac:	1000051e 	bne	r2,zero,8231fc4 <soclose+0x150>
      {
         error = sodisconnect(so);
 8231fb0:	e13fff17 	ldw	r4,-4(fp)
 8231fb4:	82322d00 	call	82322d0 <sodisconnect>
 8231fb8:	e0bffb15 	stw	r2,-20(fp)
         if (error)
 8231fbc:	e0bffb17 	ldw	r2,-20(fp)
 8231fc0:	1000301e 	bne	r2,zero,8232084 <soclose+0x210>
            goto drop;
      }
      if (so->so_options & SO_LINGER) 
 8231fc4:	e0bfff17 	ldw	r2,-4(fp)
 8231fc8:	10800417 	ldw	r2,16(r2)
 8231fcc:	1080200c 	andi	r2,r2,128
 8231fd0:	10002126 	beq	r2,zero,8232058 <soclose+0x1e4>
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
 8231fd4:	e0bfff17 	ldw	r2,-4(fp)
 8231fd8:	1080088b 	ldhu	r2,34(r2)
 8231fdc:	10bfffcc 	andi	r2,r2,65535
 8231fe0:	1080020c 	andi	r2,r2,8
 8231fe4:	10000526 	beq	r2,zero,8231ffc <soclose+0x188>
             (so->so_state & SS_NBIO))
 8231fe8:	e0bfff17 	ldw	r2,-4(fp)
 8231fec:	1080088b 	ldhu	r2,34(r2)
 8231ff0:	10bfffcc 	andi	r2,r2,65535
 8231ff4:	1080400c 	andi	r2,r2,256
         if (error)
            goto drop;
      }
      if (so->so_options & SO_LINGER) 
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
 8231ff8:	1000241e 	bne	r2,zero,823208c <soclose+0x218>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
 8231ffc:	e0bfff17 	ldw	r2,-4(fp)
 8232000:	1080080b 	ldhu	r2,32(r2)
 8232004:	10bfffcc 	andi	r2,r2,65535
 8232008:	10a0001c 	xori	r2,r2,32768
 823200c:	10a00004 	addi	r2,r2,-32768
 8232010:	10c01924 	muli	r3,r2,100
 8232014:	d0a0a817 	ldw	r2,-32096(gp)
 8232018:	1885883a 	add	r2,r3,r2
 823201c:	e0bffd15 	stw	r2,-12(fp)
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 8232020:	00000406 	br	8232034 <soclose+0x1c0>
         {
            tcp_sleep((char *)&so->so_timeo);
 8232024:	e0bfff17 	ldw	r2,-4(fp)
 8232028:	10800904 	addi	r2,r2,36
 823202c:	1009883a 	mov	r4,r2
 8232030:	82295900 	call	8229590 <tcp_sleep>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 8232034:	e0bfff17 	ldw	r2,-4(fp)
 8232038:	1080088b 	ldhu	r2,34(r2)
 823203c:	10bfffcc 	andi	r2,r2,65535
 8232040:	1080008c 	andi	r2,r2,2
 8232044:	10001226 	beq	r2,zero,8232090 <soclose+0x21c>
 8232048:	d0e0a817 	ldw	r3,-32096(gp)
 823204c:	e0bffd17 	ldw	r2,-12(fp)
 8232050:	18bff436 	bltu	r3,r2,8232024 <soclose+0x1b0>
 8232054:	00000e06 	br	8232090 <soclose+0x21c>
      {
         /* If socket still has send data just return now, leaving the 
          * socket intact so the data can be sent. Socket should be cleaned
          * up later by timers.
          */
         if(so->so_snd.sb_cc)
 8232058:	e0bfff17 	ldw	r2,-4(fp)
 823205c:	10801217 	ldw	r2,72(r2)
 8232060:	10000b26 	beq	r2,zero,8232090 <soclose+0x21c>
         {
            so->so_state |= SS_NOFDREF;   /* mark as OK to close */
 8232064:	e0bfff17 	ldw	r2,-4(fp)
 8232068:	1080088b 	ldhu	r2,34(r2)
 823206c:	10800054 	ori	r2,r2,1
 8232070:	1007883a 	mov	r3,r2
 8232074:	e0bfff17 	ldw	r2,-4(fp)
 8232078:	10c0088d 	sth	r3,34(r2)
            return 0;
 823207c:	0005883a 	mov	r2,zero
 8232080:	00002606 	br	823211c <soclose+0x2a8>
   {
      if ((so->so_state & SS_ISDISCONNECTING) == 0) 
      {
         error = sodisconnect(so);
         if (error)
            goto drop;
 8232084:	0001883a 	nop
 8232088:	00000106 	br	8232090 <soclose+0x21c>
      if (so->so_options & SO_LINGER) 
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
             (so->so_state & SS_NBIO))
         {
            goto drop;
 823208c:	0001883a 	nop
            return 0;
         }
      }
   }
drop:
   if (so->so_pcb) 
 8232090:	e0bfff17 	ldw	r2,-4(fp)
 8232094:	10800117 	ldw	r2,4(r2)
 8232098:	10001126 	beq	r2,zero,82320e0 <soclose+0x26c>
   {
      int   error2;
      so->so_req = PRU_DETACH;
 823209c:	e0bfff17 	ldw	r2,-4(fp)
 82320a0:	00c00044 	movi	r3,1
 82320a4:	10c00715 	stw	r3,28(r2)
      error2 = (*so->so_proto->pr_usrreq)(so,
 82320a8:	e0bfff17 	ldw	r2,-4(fp)
 82320ac:	10800217 	ldw	r2,8(r2)
 82320b0:	10800317 	ldw	r2,12(r2)
 82320b4:	000d883a 	mov	r6,zero
 82320b8:	000b883a 	mov	r5,zero
 82320bc:	e13fff17 	ldw	r4,-4(fp)
 82320c0:	103ee83a 	callr	r2
 82320c4:	e0bffe15 	stw	r2,-8(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      if (error == 0)
 82320c8:	e0bffb17 	ldw	r2,-20(fp)
 82320cc:	1000041e 	bne	r2,zero,82320e0 <soclose+0x26c>
         error = error2;
 82320d0:	e0bffe17 	ldw	r2,-8(fp)
 82320d4:	e0bffb15 	stw	r2,-20(fp)
 82320d8:	00000106 	br	82320e0 <soclose+0x26c>
       (struct mbuf *)0, (struct mbuf *)0);
      goto discard;
   }

   if (so->so_pcb == 0)
      goto discard;
 82320dc:	0001883a 	nop
       (struct mbuf *)0, (struct mbuf *)0);
      if (error == 0)
         error = error2;
   }
discard:
   if (so->so_state & SS_NOFDREF)
 82320e0:	e0bfff17 	ldw	r2,-4(fp)
 82320e4:	1080088b 	ldhu	r2,34(r2)
 82320e8:	10bfffcc 	andi	r2,r2,65535
 82320ec:	1080004c 	andi	r2,r2,1
 82320f0:	10000126 	beq	r2,zero,82320f8 <soclose+0x284>
   {
      /* panic("soclose");  - non-fatal - degrade to dtrap() for now */
      dtrap();
 82320f4:	822d5f00 	call	822d5f0 <dtrap>
   }
   so->so_state |= SS_NOFDREF;
 82320f8:	e0bfff17 	ldw	r2,-4(fp)
 82320fc:	1080088b 	ldhu	r2,34(r2)
 8232100:	10800054 	ori	r2,r2,1
 8232104:	1007883a 	mov	r3,r2
 8232108:	e0bfff17 	ldw	r2,-4(fp)
 823210c:	10c0088d 	sth	r3,34(r2)
   sofree(so);
 8232110:	e13fff17 	ldw	r4,-4(fp)
 8232114:	8231d640 	call	8231d64 <sofree>
   return (error);
 8232118:	e0bffb17 	ldw	r2,-20(fp)
}
 823211c:	e037883a 	mov	sp,fp
 8232120:	dfc00117 	ldw	ra,4(sp)
 8232124:	df000017 	ldw	fp,0(sp)
 8232128:	dec00204 	addi	sp,sp,8
 823212c:	f800283a 	ret

08232130 <soabort>:
 * RETURNS: 
 */

int
soabort(struct socket * so)
{
 8232130:	defffd04 	addi	sp,sp,-12
 8232134:	dfc00215 	stw	ra,8(sp)
 8232138:	df000115 	stw	fp,4(sp)
 823213c:	df000104 	addi	fp,sp,4
 8232140:	e13fff15 	stw	r4,-4(fp)
   so->so_req = PRU_ABORT;
 8232144:	e0bfff17 	ldw	r2,-4(fp)
 8232148:	00c00284 	movi	r3,10
 823214c:	10c00715 	stw	r3,28(r2)
   return(*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 8232150:	e0bfff17 	ldw	r2,-4(fp)
 8232154:	10800217 	ldw	r2,8(r2)
 8232158:	10800317 	ldw	r2,12(r2)
 823215c:	000d883a 	mov	r6,zero
 8232160:	000b883a 	mov	r5,zero
 8232164:	e13fff17 	ldw	r4,-4(fp)
 8232168:	103ee83a 	callr	r2
}
 823216c:	e037883a 	mov	sp,fp
 8232170:	dfc00117 	ldw	ra,4(sp)
 8232174:	df000017 	ldw	fp,0(sp)
 8232178:	dec00204 	addi	sp,sp,8
 823217c:	f800283a 	ret

08232180 <soaccept>:
 */

int
soaccept(struct socket * so, 
   struct mbuf *  nam)
{
 8232180:	defffb04 	addi	sp,sp,-20
 8232184:	dfc00415 	stw	ra,16(sp)
 8232188:	df000315 	stw	fp,12(sp)
 823218c:	df000304 	addi	fp,sp,12
 8232190:	e13ffe15 	stw	r4,-8(fp)
 8232194:	e17fff15 	stw	r5,-4(fp)
   int   error;

   if ((so->so_state & SS_NOFDREF) == 0)
 8232198:	e0bffe17 	ldw	r2,-8(fp)
 823219c:	1080088b 	ldhu	r2,34(r2)
 82321a0:	10bfffcc 	andi	r2,r2,65535
 82321a4:	1080004c 	andi	r2,r2,1
 82321a8:	1000031e 	bne	r2,zero,82321b8 <soaccept+0x38>
      panic("soaccept");
 82321ac:	01020974 	movhi	r4,2085
 82321b0:	21039a04 	addi	r4,r4,3688
 82321b4:	8228ca40 	call	8228ca4 <panic>
   so->so_state &= ~SS_NOFDREF;
 82321b8:	e0bffe17 	ldw	r2,-8(fp)
 82321bc:	10c0088b 	ldhu	r3,34(r2)
 82321c0:	00bfff84 	movi	r2,-2
 82321c4:	1884703a 	and	r2,r3,r2
 82321c8:	1007883a 	mov	r3,r2
 82321cc:	e0bffe17 	ldw	r2,-8(fp)
 82321d0:	10c0088d 	sth	r3,34(r2)
   so->so_req = PRU_ACCEPT;
 82321d4:	e0bffe17 	ldw	r2,-8(fp)
 82321d8:	00c00144 	movi	r3,5
 82321dc:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 82321e0:	e0bffe17 	ldw	r2,-8(fp)
 82321e4:	10800217 	ldw	r2,8(r2)
 82321e8:	10800317 	ldw	r2,12(r2)
 82321ec:	e1bfff17 	ldw	r6,-4(fp)
 82321f0:	000b883a 	mov	r5,zero
 82321f4:	e13ffe17 	ldw	r4,-8(fp)
 82321f8:	103ee83a 	callr	r2
 82321fc:	e0bffd15 	stw	r2,-12(fp)

   return (error);
 8232200:	e0bffd17 	ldw	r2,-12(fp)
}
 8232204:	e037883a 	mov	sp,fp
 8232208:	dfc00117 	ldw	ra,4(sp)
 823220c:	df000017 	ldw	fp,0(sp)
 8232210:	dec00204 	addi	sp,sp,8
 8232214:	f800283a 	ret

08232218 <soconnect>:
 */

int
soconnect(struct socket * so, 
   struct mbuf *  nam)
{
 8232218:	defffb04 	addi	sp,sp,-20
 823221c:	dfc00415 	stw	ra,16(sp)
 8232220:	df000315 	stw	fp,12(sp)
 8232224:	df000304 	addi	fp,sp,12
 8232228:	e13ffe15 	stw	r4,-8(fp)
 823222c:	e17fff15 	stw	r5,-4(fp)
   int   error;

   if (so->so_options & SO_ACCEPTCONN)
 8232230:	e0bffe17 	ldw	r2,-8(fp)
 8232234:	10800417 	ldw	r2,16(r2)
 8232238:	1080008c 	andi	r2,r2,2
 823223c:	10000226 	beq	r2,zero,8232248 <soconnect+0x30>
      return (EOPNOTSUPP);
 8232240:	008017c4 	movi	r2,95
 8232244:	00001d06 	br	82322bc <soconnect+0xa4>
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 8232248:	e0bffe17 	ldw	r2,-8(fp)
 823224c:	1080088b 	ldhu	r2,34(r2)
 8232250:	10bfffcc 	andi	r2,r2,65535
 8232254:	1080018c 	andi	r2,r2,6
 8232258:	10000c26 	beq	r2,zero,823228c <soconnect+0x74>
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
 823225c:	e0bffe17 	ldw	r2,-8(fp)
 8232260:	10800217 	ldw	r2,8(r2)
 8232264:	1080010b 	ldhu	r2,4(r2)
 8232268:	10bfffcc 	andi	r2,r2,65535
 823226c:	1080010c 	andi	r2,r2,4
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 8232270:	1000031e 	bne	r2,zero,8232280 <soconnect+0x68>
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
       (sodisconnect(so) != 0)))
 8232274:	e13ffe17 	ldw	r4,-8(fp)
 8232278:	82322d00 	call	82322d0 <sodisconnect>
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
 823227c:	10000326 	beq	r2,zero,823228c <soconnect+0x74>
       (sodisconnect(so) != 0)))
   {
      error = EISCONN;
 8232280:	00801fc4 	movi	r2,127
 8232284:	e0bffd15 	stw	r2,-12(fp)
 8232288:	00000b06 	br	82322b8 <soconnect+0xa0>
   }
   else
   {
      so->so_req = PRU_CONNECT;
 823228c:	e0bffe17 	ldw	r2,-8(fp)
 8232290:	00c00104 	movi	r3,4
 8232294:	10c00715 	stw	r3,28(r2)
      error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 8232298:	e0bffe17 	ldw	r2,-8(fp)
 823229c:	10800217 	ldw	r2,8(r2)
 82322a0:	10800317 	ldw	r2,12(r2)
 82322a4:	e1bfff17 	ldw	r6,-4(fp)
 82322a8:	000b883a 	mov	r5,zero
 82322ac:	e13ffe17 	ldw	r4,-8(fp)
 82322b0:	103ee83a 	callr	r2
 82322b4:	e0bffd15 	stw	r2,-12(fp)
   }
   return error;
 82322b8:	e0bffd17 	ldw	r2,-12(fp)
}
 82322bc:	e037883a 	mov	sp,fp
 82322c0:	dfc00117 	ldw	ra,4(sp)
 82322c4:	df000017 	ldw	fp,0(sp)
 82322c8:	dec00204 	addi	sp,sp,8
 82322cc:	f800283a 	ret

082322d0 <sodisconnect>:
 * RETURNS: 
 */

int
sodisconnect(struct socket * so)
{
 82322d0:	defffc04 	addi	sp,sp,-16
 82322d4:	dfc00315 	stw	ra,12(sp)
 82322d8:	df000215 	stw	fp,8(sp)
 82322dc:	df000204 	addi	fp,sp,8
 82322e0:	e13fff15 	stw	r4,-4(fp)
   int   error;

   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sodisconnect, so %lx so_state %x\n", so, so->so_state));

   if ((so->so_state & SS_ISCONNECTED) == 0) 
 82322e4:	e0bfff17 	ldw	r2,-4(fp)
 82322e8:	1080088b 	ldhu	r2,34(r2)
 82322ec:	10bfffcc 	andi	r2,r2,65535
 82322f0:	1080008c 	andi	r2,r2,2
 82322f4:	1000031e 	bne	r2,zero,8232304 <sodisconnect+0x34>
   {
      error = ENOTCONN;
 82322f8:	00802004 	movi	r2,128
 82322fc:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 8232300:	00001306 	br	8232350 <sodisconnect+0x80>
   }
   if (so->so_state & SS_ISDISCONNECTING) 
 8232304:	e0bfff17 	ldw	r2,-4(fp)
 8232308:	1080088b 	ldhu	r2,34(r2)
 823230c:	10bfffcc 	andi	r2,r2,65535
 8232310:	1080020c 	andi	r2,r2,8
 8232314:	10000326 	beq	r2,zero,8232324 <sodisconnect+0x54>
   {
      error = EALREADY;
 8232318:	00801e04 	movi	r2,120
 823231c:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 8232320:	00000b06 	br	8232350 <sodisconnect+0x80>
   }
   so->so_req = PRU_DISCONNECT;
 8232324:	e0bfff17 	ldw	r2,-4(fp)
 8232328:	00c00184 	movi	r3,6
 823232c:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 8232330:	e0bfff17 	ldw	r2,-4(fp)
 8232334:	10800217 	ldw	r2,8(r2)
 8232338:	10800317 	ldw	r2,12(r2)
 823233c:	000d883a 	mov	r6,zero
 8232340:	000b883a 	mov	r5,zero
 8232344:	e13fff17 	ldw	r4,-4(fp)
 8232348:	103ee83a 	callr	r2
 823234c:	e0bffe15 	stw	r2,-8(fp)

bad:
   return (error);
 8232350:	e0bffe17 	ldw	r2,-8(fp)
}
 8232354:	e037883a 	mov	sp,fp
 8232358:	dfc00117 	ldw	ra,4(sp)
 823235c:	df000017 	ldw	fp,0(sp)
 8232360:	dec00204 	addi	sp,sp,8
 8232364:	f800283a 	ret

08232368 <sosend>:
sosend(struct socket *so, 
       struct mbuf *nam,      /* sockaddr, if UDP socket, NULL if TCP */
       char  *data,           /* data to send */
       int   *data_length,    /* IN/OUT  length of (remaining) data */
       int   flags)
{
 8232368:	defff204 	addi	sp,sp,-56
 823236c:	dfc00d15 	stw	ra,52(sp)
 8232370:	df000c15 	stw	fp,48(sp)
 8232374:	df000c04 	addi	fp,sp,48
 8232378:	e13ffc15 	stw	r4,-16(fp)
 823237c:	e17ffd15 	stw	r5,-12(fp)
 8232380:	e1bffe15 	stw	r6,-8(fp)
 8232384:	e1ffff15 	stw	r7,-4(fp)
   struct mbuf *head = (struct mbuf *)NULL;
 8232388:	e03ff415 	stw	zero,-48(fp)
   struct mbuf *m;
   int   space;
   int   resid;
   int   len;
   int   error = 0;
 823238c:	e03ff815 	stw	zero,-32(fp)
   int   dontroute;
   int   first = 1;
 8232390:	00800044 	movi	r2,1
 8232394:	e0bff915 	stw	r2,-28(fp)

   resid = *data_length;
 8232398:	e0bfff17 	ldw	r2,-4(fp)
 823239c:	10800017 	ldw	r2,0(r2)
 82323a0:	e0bff715 	stw	r2,-36(fp)
    * However, space must be signed, as it might be less than 0
    * if we over-committed, and we must use a signed comparison
    * of space and resid.  On the other hand, a negative resid
    * causes us to loop sending 0-length segments to the protocol.
    */
   if (resid < 0)
 82323a4:	e0bff717 	ldw	r2,-36(fp)
 82323a8:	1000020e 	bge	r2,zero,82323b4 <sosend+0x4c>
      return (EINVAL);
 82323ac:	00800584 	movi	r2,22
 82323b0:	00013e06 	br	82328ac <sosend+0x544>

   INET_TRACE (INETM_IO, ("INET:sosend: so %lx resid %d sb_hiwat %d so_state %x\n",
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
 82323b4:	e0bffc17 	ldw	r2,-16(fp)
 82323b8:	10800217 	ldw	r2,8(r2)
 82323bc:	1080010b 	ldhu	r2,4(r2)
 82323c0:	10bfffcc 	andi	r2,r2,65535
 82323c4:	1080004c 	andi	r2,r2,1
 82323c8:	10000726 	beq	r2,zero,82323e8 <sosend+0x80>
 82323cc:	e0bffc17 	ldw	r2,-16(fp)
 82323d0:	10801317 	ldw	r2,76(r2)
 82323d4:	1007883a 	mov	r3,r2
 82323d8:	e0bff717 	ldw	r2,-36(fp)
 82323dc:	1880020e 	bge	r3,r2,82323e8 <sosend+0x80>
      return (EMSGSIZE);
 82323e0:	00801e84 	movi	r2,122
 82323e4:	00013106 	br	82328ac <sosend+0x544>

   dontroute = (flags & MSG_DONTROUTE) &&
 82323e8:	e0800217 	ldw	r2,8(fp)
 82323ec:	1080010c 	andi	r2,r2,4
               ((so->so_options & SO_DONTROUTE) == 0) &&
 82323f0:	10000c26 	beq	r2,zero,8232424 <sosend+0xbc>
 82323f4:	e0bffc17 	ldw	r2,-16(fp)
 82323f8:	10800417 	ldw	r2,16(r2)
 82323fc:	1080040c 	andi	r2,r2,16
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
      return (EMSGSIZE);

   dontroute = (flags & MSG_DONTROUTE) &&
 8232400:	1000081e 	bne	r2,zero,8232424 <sosend+0xbc>
               ((so->so_options & SO_DONTROUTE) == 0) &&
               (so->so_proto->pr_flags & PR_ATOMIC);
 8232404:	e0bffc17 	ldw	r2,-16(fp)
 8232408:	10800217 	ldw	r2,8(r2)
 823240c:	1080010b 	ldhu	r2,4(r2)
 8232410:	10bfffcc 	andi	r2,r2,65535
 8232414:	1080004c 	andi	r2,r2,1

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
      return (EMSGSIZE);

   dontroute = (flags & MSG_DONTROUTE) &&
               ((so->so_options & SO_DONTROUTE) == 0) &&
 8232418:	10000226 	beq	r2,zero,8232424 <sosend+0xbc>
 823241c:	00800044 	movi	r2,1
 8232420:	00000106 	br	8232428 <sosend+0xc0>
 8232424:	0005883a 	mov	r2,zero
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
      return (EMSGSIZE);

   dontroute = (flags & MSG_DONTROUTE) &&
 8232428:	e0bffa15 	stw	r2,-24(fp)
               (so->so_proto->pr_flags & PR_ATOMIC);

#define     snderr(errno)     {  error =  errno;   goto  release; }

restart:
   sblock(&so->so_snd);
 823242c:	00000406 	br	8232440 <sosend+0xd8>
 8232430:	e0bffc17 	ldw	r2,-16(fp)
 8232434:	10801904 	addi	r2,r2,100
 8232438:	1009883a 	mov	r4,r2
 823243c:	82295900 	call	8229590 <tcp_sleep>
 8232440:	e0bffc17 	ldw	r2,-16(fp)
 8232444:	1080190b 	ldhu	r2,100(r2)
 8232448:	10bfffcc 	andi	r2,r2,65535
 823244c:	1080004c 	andi	r2,r2,1
 8232450:	103ff71e 	bne	r2,zero,8232430 <sosend+0xc8>
 8232454:	e0bffc17 	ldw	r2,-16(fp)
 8232458:	1080190b 	ldhu	r2,100(r2)
 823245c:	10800054 	ori	r2,r2,1
 8232460:	1007883a 	mov	r3,r2
 8232464:	e0bffc17 	ldw	r2,-16(fp)
 8232468:	10c0190d 	sth	r3,100(r2)
   do 
   {
      if (so->so_error) 
 823246c:	e0bffc17 	ldw	r2,-16(fp)
 8232470:	10800617 	ldw	r2,24(r2)
 8232474:	10000626 	beq	r2,zero,8232490 <sosend+0x128>
      {
         error = so->so_error;
 8232478:	e0bffc17 	ldw	r2,-16(fp)
 823247c:	10800617 	ldw	r2,24(r2)
 8232480:	e0bff815 	stw	r2,-32(fp)
         so->so_error = 0;          /* ??? */
 8232484:	e0bffc17 	ldw	r2,-16(fp)
 8232488:	10000615 	stw	zero,24(r2)
         goto release;
 823248c:	0000f706 	br	823286c <sosend+0x504>
      }
      if (so->so_state & SS_CANTSENDMORE)
 8232490:	e0bffc17 	ldw	r2,-16(fp)
 8232494:	1080088b 	ldhu	r2,34(r2)
 8232498:	10bfffcc 	andi	r2,r2,65535
 823249c:	1080040c 	andi	r2,r2,16
 82324a0:	10000326 	beq	r2,zero,82324b0 <sosend+0x148>
         snderr(EPIPE);
 82324a4:	00800804 	movi	r2,32
 82324a8:	e0bff815 	stw	r2,-32(fp)
 82324ac:	0000ef06 	br	823286c <sosend+0x504>
      if ((so->so_state & SS_ISCONNECTED) == 0) 
 82324b0:	e0bffc17 	ldw	r2,-16(fp)
 82324b4:	1080088b 	ldhu	r2,34(r2)
 82324b8:	10bfffcc 	andi	r2,r2,65535
 82324bc:	1080008c 	andi	r2,r2,2
 82324c0:	10000e1e 	bne	r2,zero,82324fc <sosend+0x194>
      {
         if (so->so_proto->pr_flags & PR_CONNREQUIRED)
 82324c4:	e0bffc17 	ldw	r2,-16(fp)
 82324c8:	10800217 	ldw	r2,8(r2)
 82324cc:	1080010b 	ldhu	r2,4(r2)
 82324d0:	10bfffcc 	andi	r2,r2,65535
 82324d4:	1080010c 	andi	r2,r2,4
 82324d8:	10000326 	beq	r2,zero,82324e8 <sosend+0x180>
            snderr(ENOTCONN);
 82324dc:	00802004 	movi	r2,128
 82324e0:	e0bff815 	stw	r2,-32(fp)
 82324e4:	0000e106 	br	823286c <sosend+0x504>
         if (nam == 0)
 82324e8:	e0bffd17 	ldw	r2,-12(fp)
 82324ec:	1000031e 	bne	r2,zero,82324fc <sosend+0x194>
            snderr(EDESTADDRREQ);
 82324f0:	00801e44 	movi	r2,121
 82324f4:	e0bff815 	stw	r2,-32(fp)
 82324f8:	0000dc06 	br	823286c <sosend+0x504>
      }
      if (flags & MSG_OOB)
 82324fc:	e0800217 	ldw	r2,8(fp)
 8232500:	1080004c 	andi	r2,r2,1
 8232504:	10000326 	beq	r2,zero,8232514 <sosend+0x1ac>
         space = 1024;
 8232508:	00810004 	movi	r2,1024
 823250c:	e0bff615 	stw	r2,-40(fp)
 8232510:	00004706 	br	8232630 <sosend+0x2c8>
      else 
      {
         space = (int)sbspace(&so->so_snd);
 8232514:	e0bffc17 	ldw	r2,-16(fp)
 8232518:	10801317 	ldw	r2,76(r2)
 823251c:	1007883a 	mov	r3,r2
 8232520:	e0bffc17 	ldw	r2,-16(fp)
 8232524:	10801217 	ldw	r2,72(r2)
 8232528:	1885c83a 	sub	r2,r3,r2
 823252c:	10000616 	blt	r2,zero,8232548 <sosend+0x1e0>
 8232530:	e0bffc17 	ldw	r2,-16(fp)
 8232534:	10c01317 	ldw	r3,76(r2)
 8232538:	e0bffc17 	ldw	r2,-16(fp)
 823253c:	10801217 	ldw	r2,72(r2)
 8232540:	1885c83a 	sub	r2,r3,r2
 8232544:	00000106 	br	823254c <sosend+0x1e4>
 8232548:	0005883a 	mov	r2,zero
 823254c:	e0bff615 	stw	r2,-40(fp)
         if ((sosendallatonce(so) && (space < resid)) ||
 8232550:	e0bffc17 	ldw	r2,-16(fp)
 8232554:	10800217 	ldw	r2,8(r2)
 8232558:	1080010b 	ldhu	r2,4(r2)
 823255c:	10bfffcc 	andi	r2,r2,65535
 8232560:	1080004c 	andi	r2,r2,1
 8232564:	10000326 	beq	r2,zero,8232574 <sosend+0x20c>
 8232568:	e0fff617 	ldw	r3,-40(fp)
 823256c:	e0bff717 	ldw	r2,-36(fp)
 8232570:	18801216 	blt	r3,r2,82325bc <sosend+0x254>
 8232574:	e0bff717 	ldw	r2,-36(fp)
 8232578:	10815e10 	cmplti	r2,r2,1400
 823257c:	10002c1e 	bne	r2,zero,8232630 <sosend+0x2c8>
             ((resid >= CLBYTES) && (space < CLBYTES) &&
 8232580:	e0bff617 	ldw	r2,-40(fp)
 8232584:	10815e08 	cmpgei	r2,r2,1400
 8232588:	1000291e 	bne	r2,zero,8232630 <sosend+0x2c8>
              (so->so_snd.sb_cc >= CLBYTES) &&
 823258c:	e0bffc17 	ldw	r2,-16(fp)
 8232590:	10801217 	ldw	r2,72(r2)
         space = 1024;
      else 
      {
         space = (int)sbspace(&so->so_snd);
         if ((sosendallatonce(so) && (space < resid)) ||
             ((resid >= CLBYTES) && (space < CLBYTES) &&
 8232594:	10815e30 	cmpltui	r2,r2,1400
 8232598:	1000251e 	bne	r2,zero,8232630 <sosend+0x2c8>
              (so->so_snd.sb_cc >= CLBYTES) &&
              ((so->so_state & SS_NBIO) == 0) &&
 823259c:	e0bffc17 	ldw	r2,-16(fp)
 82325a0:	1080088b 	ldhu	r2,34(r2)
 82325a4:	10bfffcc 	andi	r2,r2,65535
 82325a8:	1080400c 	andi	r2,r2,256
      else 
      {
         space = (int)sbspace(&so->so_snd);
         if ((sosendallatonce(so) && (space < resid)) ||
             ((resid >= CLBYTES) && (space < CLBYTES) &&
              (so->so_snd.sb_cc >= CLBYTES) &&
 82325ac:	1000201e 	bne	r2,zero,8232630 <sosend+0x2c8>
              ((so->so_state & SS_NBIO) == 0) &&
              ((flags & MSG_DONTWAIT) == 0)))
 82325b0:	e0800217 	ldw	r2,8(fp)
 82325b4:	1080080c 	andi	r2,r2,32
      {
         space = (int)sbspace(&so->so_snd);
         if ((sosendallatonce(so) && (space < resid)) ||
             ((resid >= CLBYTES) && (space < CLBYTES) &&
              (so->so_snd.sb_cc >= CLBYTES) &&
              ((so->so_state & SS_NBIO) == 0) &&
 82325b8:	10001d1e 	bne	r2,zero,8232630 <sosend+0x2c8>
              ((flags & MSG_DONTWAIT) == 0)))
         {
            if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 82325bc:	e0bffc17 	ldw	r2,-16(fp)
 82325c0:	1080088b 	ldhu	r2,34(r2)
 82325c4:	10bfffcc 	andi	r2,r2,65535
 82325c8:	1080400c 	andi	r2,r2,256
 82325cc:	1000031e 	bne	r2,zero,82325dc <sosend+0x274>
 82325d0:	e0800217 	ldw	r2,8(fp)
 82325d4:	1080080c 	andi	r2,r2,32
 82325d8:	10000526 	beq	r2,zero,82325f0 <sosend+0x288>
            {
               if (first)
 82325dc:	e0bff917 	ldw	r2,-28(fp)
 82325e0:	10009d26 	beq	r2,zero,8232858 <sosend+0x4f0>
                  error = EWOULDBLOCK;
 82325e4:	008002c4 	movi	r2,11
 82325e8:	e0bff815 	stw	r2,-32(fp)
               goto release;
 82325ec:	00009a06 	br	8232858 <sosend+0x4f0>
            }
            sbunlock(&so->so_snd);
 82325f0:	e0bffc17 	ldw	r2,-16(fp)
 82325f4:	10c0190b 	ldhu	r3,100(r2)
 82325f8:	00bfff84 	movi	r2,-2
 82325fc:	1884703a 	and	r2,r3,r2
 8232600:	1007883a 	mov	r3,r2
 8232604:	e0bffc17 	ldw	r2,-16(fp)
 8232608:	10c0190d 	sth	r3,100(r2)
 823260c:	e0bffc17 	ldw	r2,-16(fp)
 8232610:	10801904 	addi	r2,r2,100
 8232614:	1009883a 	mov	r4,r2
 8232618:	82297040 	call	8229704 <tcp_wakeup>
            sbwait(&so->so_snd);
 823261c:	e0bffc17 	ldw	r2,-16(fp)
 8232620:	10801204 	addi	r2,r2,72
 8232624:	1009883a 	mov	r4,r2
 8232628:	82342340 	call	8234234 <sbwait>
            goto restart;
 823262c:	003f7f06 	br	823242c <sosend+0xc4>
         }
      }
      if ( space <= 0 ) 
 8232630:	e0bff617 	ldw	r2,-40(fp)
 8232634:	00805e16 	blt	zero,r2,82327b0 <sosend+0x448>
      {
         /* no space in socket send buffer - see if we can wait */
         if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 8232638:	e0bffc17 	ldw	r2,-16(fp)
 823263c:	1080088b 	ldhu	r2,34(r2)
 8232640:	10bfffcc 	andi	r2,r2,65535
 8232644:	1080400c 	andi	r2,r2,256
 8232648:	1000031e 	bne	r2,zero,8232658 <sosend+0x2f0>
 823264c:	e0800217 	ldw	r2,8(fp)
 8232650:	1080080c 	andi	r2,r2,32
 8232654:	10000526 	beq	r2,zero,823266c <sosend+0x304>
         {
            if (first)     /* report first error */
 8232658:	e0bff917 	ldw	r2,-28(fp)
 823265c:	10008026 	beq	r2,zero,8232860 <sosend+0x4f8>
               error = EWOULDBLOCK;
 8232660:	008002c4 	movi	r2,11
 8232664:	e0bff815 	stw	r2,-32(fp)
            goto release;
 8232668:	00007d06 	br	8232860 <sosend+0x4f8>
         }
         /* If blocking socket, let someone else run */
         sbunlock(&so->so_snd);
 823266c:	e0bffc17 	ldw	r2,-16(fp)
 8232670:	10c0190b 	ldhu	r3,100(r2)
 8232674:	00bfff84 	movi	r2,-2
 8232678:	1884703a 	and	r2,r3,r2
 823267c:	1007883a 	mov	r3,r2
 8232680:	e0bffc17 	ldw	r2,-16(fp)
 8232684:	10c0190d 	sth	r3,100(r2)
 8232688:	e0bffc17 	ldw	r2,-16(fp)
 823268c:	10801904 	addi	r2,r2,100
 8232690:	1009883a 	mov	r4,r2
 8232694:	82297040 	call	8229704 <tcp_wakeup>
         sbwait(&so->so_snd);
 8232698:	e0bffc17 	ldw	r2,-16(fp)
 823269c:	10801204 	addi	r2,r2,72
 82326a0:	1009883a 	mov	r4,r2
 82326a4:	82342340 	call	8234234 <sbwait>
         goto restart;
 82326a8:	003f6006 	br	823242c <sosend+0xc4>
      }

      while (space > 0) 
      {
         len = resid;
 82326ac:	e0bff717 	ldw	r2,-36(fp)
 82326b0:	e0bffb15 	stw	r2,-20(fp)
         if ( so->so_type == SOCK_STREAM )
 82326b4:	e0bffc17 	ldw	r2,-16(fp)
 82326b8:	10800983 	ldbu	r2,38(r2)
 82326bc:	10803fcc 	andi	r2,r2,255
 82326c0:	1080201c 	xori	r2,r2,128
 82326c4:	10bfe004 	addi	r2,r2,-128
 82326c8:	10800058 	cmpnei	r2,r2,1
 82326cc:	1000171e 	bne	r2,zero,823272c <sosend+0x3c4>
         {
            m = m_getwithdata(MT_TXDATA, len);
 82326d0:	e17ffb17 	ldw	r5,-20(fp)
 82326d4:	01000084 	movi	r4,2
 82326d8:	822e4040 	call	822e404 <m_getnbuf>
 82326dc:	e0bff515 	stw	r2,-44(fp)
            if (!m)   
 82326e0:	e0bff517 	ldw	r2,-44(fp)
 82326e4:	1000031e 	bne	r2,zero,82326f4 <sosend+0x38c>
               snderr(ENOBUFS);
 82326e8:	00801a44 	movi	r2,105
 82326ec:	e0bff815 	stw	r2,-32(fp)
 82326f0:	00005e06 	br	823286c <sosend+0x504>
            MEMCPY(m->m_data, data, len);
 82326f4:	e0bff517 	ldw	r2,-44(fp)
 82326f8:	10800317 	ldw	r2,12(r2)
 82326fc:	e0fffb17 	ldw	r3,-20(fp)
 8232700:	180d883a 	mov	r6,r3
 8232704:	e17ffe17 	ldw	r5,-8(fp)
 8232708:	1009883a 	mov	r4,r2
 823270c:	8202f6c0 	call	8202f6c <memcpy>
            so->so_snd.sb_flags |= SB_MBCOMP;   /* allow compression */
 8232710:	e0bffc17 	ldw	r2,-16(fp)
 8232714:	1080190b 	ldhu	r2,100(r2)
 8232718:	10802014 	ori	r2,r2,128
 823271c:	1007883a 	mov	r3,r2
 8232720:	e0bffc17 	ldw	r2,-16(fp)
 8232724:	10c0190d 	sth	r3,100(r2)
 8232728:	00000706 	br	8232748 <sosend+0x3e0>
         }
         else
         {
            m = m_get (M_WAIT, MT_TXDATA);
 823272c:	000b883a 	mov	r5,zero
 8232730:	01000084 	movi	r4,2
 8232734:	822e4040 	call	822e404 <m_getnbuf>
 8232738:	e0bff515 	stw	r2,-44(fp)
            m->m_data = data;
 823273c:	e0bff517 	ldw	r2,-44(fp)
 8232740:	e0fffe17 	ldw	r3,-8(fp)
 8232744:	10c00315 	stw	r3,12(r2)
         }
         INET_TRACE (INETM_IO,
          ("sosend:got %d bytes so %lx mlen %d, off %d mtod %x\n",
             len, so, m->m_len, m->m_off, mtod (m, caddr_t)));

         *data_length -= len;
 8232748:	e0bfff17 	ldw	r2,-4(fp)
 823274c:	10c00017 	ldw	r3,0(r2)
 8232750:	e0bffb17 	ldw	r2,-20(fp)
 8232754:	1887c83a 	sub	r3,r3,r2
 8232758:	e0bfff17 	ldw	r2,-4(fp)
 823275c:	10c00015 	stw	r3,0(r2)
         resid -= len;
 8232760:	e0fff717 	ldw	r3,-36(fp)
 8232764:	e0bffb17 	ldw	r2,-20(fp)
 8232768:	1885c83a 	sub	r2,r3,r2
 823276c:	e0bff715 	stw	r2,-36(fp)
         data += len;
 8232770:	e0bffb17 	ldw	r2,-20(fp)
 8232774:	e0fffe17 	ldw	r3,-8(fp)
 8232778:	1885883a 	add	r2,r3,r2
 823277c:	e0bffe15 	stw	r2,-8(fp)
         m->m_len = len;
 8232780:	e0fffb17 	ldw	r3,-20(fp)
 8232784:	e0bff517 	ldw	r2,-44(fp)
 8232788:	10c00215 	stw	r3,8(r2)
         if (head == (struct mbuf *)NULL)
 823278c:	e0bff417 	ldw	r2,-48(fp)
 8232790:	1000021e 	bne	r2,zero,823279c <sosend+0x434>
            head = m;
 8232794:	e0bff517 	ldw	r2,-44(fp)
 8232798:	e0bff415 	stw	r2,-48(fp)
         if (error)
 823279c:	e0bff817 	ldw	r2,-32(fp)
 82327a0:	1000311e 	bne	r2,zero,8232868 <sosend+0x500>
            goto release;
         if (*data_length <= 0)
 82327a4:	e0bfff17 	ldw	r2,-4(fp)
 82327a8:	10800017 	ldw	r2,0(r2)
 82327ac:	0080030e 	bge	zero,r2,82327bc <sosend+0x454>
         sbunlock(&so->so_snd);
         sbwait(&so->so_snd);
         goto restart;
      }

      while (space > 0) 
 82327b0:	e0bff617 	ldw	r2,-40(fp)
 82327b4:	00bfbd16 	blt	zero,r2,82326ac <sosend+0x344>
 82327b8:	00000106 	br	82327c0 <sosend+0x458>
         if (head == (struct mbuf *)NULL)
            head = m;
         if (error)
            goto release;
         if (*data_length <= 0)
            break;
 82327bc:	0001883a 	nop
      }

      if (dontroute)
 82327c0:	e0bffa17 	ldw	r2,-24(fp)
 82327c4:	10000526 	beq	r2,zero,82327dc <sosend+0x474>
         so->so_options |= SO_DONTROUTE;
 82327c8:	e0bffc17 	ldw	r2,-16(fp)
 82327cc:	10800417 	ldw	r2,16(r2)
 82327d0:	10c00414 	ori	r3,r2,16
 82327d4:	e0bffc17 	ldw	r2,-16(fp)
 82327d8:	10c00415 	stw	r3,16(r2)

      so->so_req = (flags & MSG_OOB) ? PRU_SENDOOB : PRU_SEND;
 82327dc:	e0800217 	ldw	r2,8(fp)
 82327e0:	1080004c 	andi	r2,r2,1
 82327e4:	10000226 	beq	r2,zero,82327f0 <sosend+0x488>
 82327e8:	00800384 	movi	r2,14
 82327ec:	00000106 	br	82327f4 <sosend+0x48c>
 82327f0:	00800244 	movi	r2,9
 82327f4:	e0fffc17 	ldw	r3,-16(fp)
 82327f8:	18800715 	stw	r2,28(r3)
      error = (*so->so_proto->pr_usrreq)(so, head, nam);
 82327fc:	e0bffc17 	ldw	r2,-16(fp)
 8232800:	10800217 	ldw	r2,8(r2)
 8232804:	10800317 	ldw	r2,12(r2)
 8232808:	e1bffd17 	ldw	r6,-12(fp)
 823280c:	e17ff417 	ldw	r5,-48(fp)
 8232810:	e13ffc17 	ldw	r4,-16(fp)
 8232814:	103ee83a 	callr	r2
 8232818:	e0bff815 	stw	r2,-32(fp)

      if (dontroute)
 823281c:	e0bffa17 	ldw	r2,-24(fp)
 8232820:	10000626 	beq	r2,zero,823283c <sosend+0x4d4>
         so->so_options &= ~SO_DONTROUTE;
 8232824:	e0bffc17 	ldw	r2,-16(fp)
 8232828:	10c00417 	ldw	r3,16(r2)
 823282c:	00bffbc4 	movi	r2,-17
 8232830:	1886703a 	and	r3,r3,r2
 8232834:	e0bffc17 	ldw	r2,-16(fp)
 8232838:	10c00415 	stw	r3,16(r2)

      head = (struct mbuf *)NULL;
 823283c:	e03ff415 	stw	zero,-48(fp)
      first = 0;
 8232840:	e03ff915 	stw	zero,-28(fp)
   } while ((resid != 0) && (error == 0));
 8232844:	e0bff717 	ldw	r2,-36(fp)
 8232848:	10000826 	beq	r2,zero,823286c <sosend+0x504>
 823284c:	e0bff817 	ldw	r2,-32(fp)
 8232850:	103f0626 	beq	r2,zero,823246c <sosend+0x104>
 8232854:	00000506 	br	823286c <sosend+0x504>
         {
            if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
            {
               if (first)
                  error = EWOULDBLOCK;
               goto release;
 8232858:	0001883a 	nop
 823285c:	00000306 	br	823286c <sosend+0x504>
         /* no space in socket send buffer - see if we can wait */
         if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
         {
            if (first)     /* report first error */
               error = EWOULDBLOCK;
            goto release;
 8232860:	0001883a 	nop
 8232864:	00000106 	br	823286c <sosend+0x504>
         data += len;
         m->m_len = len;
         if (head == (struct mbuf *)NULL)
            head = m;
         if (error)
            goto release;
 8232868:	0001883a 	nop
      head = (struct mbuf *)NULL;
      first = 0;
   } while ((resid != 0) && (error == 0));

release:
   sbunlock(&so->so_snd);  
 823286c:	e0bffc17 	ldw	r2,-16(fp)
 8232870:	10c0190b 	ldhu	r3,100(r2)
 8232874:	00bfff84 	movi	r2,-2
 8232878:	1884703a 	and	r2,r3,r2
 823287c:	1007883a 	mov	r3,r2
 8232880:	e0bffc17 	ldw	r2,-16(fp)
 8232884:	10c0190d 	sth	r3,100(r2)
 8232888:	e0bffc17 	ldw	r2,-16(fp)
 823288c:	10801904 	addi	r2,r2,100
 8232890:	1009883a 	mov	r4,r2
 8232894:	82297040 	call	8229704 <tcp_wakeup>
   if (head)
 8232898:	e0bff417 	ldw	r2,-48(fp)
 823289c:	10000226 	beq	r2,zero,82328a8 <sosend+0x540>
      m_freem(head);
 82328a0:	e13ff417 	ldw	r4,-48(fp)
 82328a4:	822e6940 	call	822e694 <m_freem>
   return error;
 82328a8:	e0bff817 	ldw	r2,-32(fp)
}
 82328ac:	e037883a 	mov	sp,fp
 82328b0:	dfc00117 	ldw	ra,4(sp)
 82328b4:	df000017 	ldw	fp,0(sp)
 82328b8:	dec00204 	addi	sp,sp,8
 82328bc:	f800283a 	ret

082328c0 <soreceive>:
soreceive(struct socket * so, 
   struct mbuf **aname,
   char * data,
   int * datalen,
   int   flags)
{
 82328c0:	defff204 	addi	sp,sp,-56
 82328c4:	dfc00d15 	stw	ra,52(sp)
 82328c8:	df000c15 	stw	fp,48(sp)
 82328cc:	df000c04 	addi	fp,sp,48
 82328d0:	e13ffc15 	stw	r4,-16(fp)
 82328d4:	e17ffd15 	stw	r5,-12(fp)
 82328d8:	e1bffe15 	stw	r6,-8(fp)
 82328dc:	e1ffff15 	stw	r7,-4(fp)
   struct mbuf *  m;
   int   len;
   int   error =  0;
 82328e0:	e03ff615 	stw	zero,-40(fp)
   int   offset;
   struct protosw *  pr =  so->so_proto;
 82328e4:	e0bffc17 	ldw	r2,-16(fp)
 82328e8:	10800217 	ldw	r2,8(r2)
 82328ec:	e0bffa15 	stw	r2,-24(fp)
   struct mbuf *  nextrecord;
   int   moff;
   int   lflags;

   if (aname)
 82328f0:	e0bffd17 	ldw	r2,-12(fp)
 82328f4:	10000226 	beq	r2,zero,8232900 <soreceive+0x40>
      *aname = 0;
 82328f8:	e0bffd17 	ldw	r2,-12(fp)
 82328fc:	10000015 	stw	zero,0(r2)
   if (flags & MSG_OOB) 
 8232900:	e0800217 	ldw	r2,8(fp)
 8232904:	1080004c 	andi	r2,r2,1
 8232908:	10004626 	beq	r2,zero,8232a24 <soreceive+0x164>
   {
      m = m_get (M_WAIT, MT_RXDATA);
 823290c:	000b883a 	mov	r5,zero
 8232910:	01000044 	movi	r4,1
 8232914:	822e4040 	call	822e404 <m_getnbuf>
 8232918:	e0bff415 	stw	r2,-48(fp)
      if (m == NULL)
 823291c:	e0bff417 	ldw	r2,-48(fp)
 8232920:	1000021e 	bne	r2,zero,823292c <soreceive+0x6c>
         return ENOBUFS;
 8232924:	00801a44 	movi	r2,105
 8232928:	0001b306 	br	8232ff8 <soreceive+0x738>
      lflags = flags & MSG_PEEK;
 823292c:	e0800217 	ldw	r2,8(fp)
 8232930:	1080008c 	andi	r2,r2,2
 8232934:	e0bffb15 	stw	r2,-20(fp)

      so->so_req = PRU_RCVOOB;
 8232938:	e0bffc17 	ldw	r2,-16(fp)
 823293c:	00c00344 	movi	r3,13
 8232940:	10c00715 	stw	r3,28(r2)
      error = (*pr->pr_usrreq)(so, m, LONG2MBUF((long)lflags));
 8232944:	e0bffa17 	ldw	r2,-24(fp)
 8232948:	10800317 	ldw	r2,12(r2)
 823294c:	e0fffb17 	ldw	r3,-20(fp)
 8232950:	180d883a 	mov	r6,r3
 8232954:	e17ff417 	ldw	r5,-48(fp)
 8232958:	e13ffc17 	ldw	r4,-16(fp)
 823295c:	103ee83a 	callr	r2
 8232960:	e0bff615 	stw	r2,-40(fp)
      if (error == 0)
 8232964:	e0bff617 	ldw	r2,-40(fp)
 8232968:	1000231e 	bne	r2,zero,82329f8 <soreceive+0x138>
      {
         do 
         {
            len = *datalen;
 823296c:	e0bfff17 	ldw	r2,-4(fp)
 8232970:	10800017 	ldw	r2,0(r2)
 8232974:	e0bff515 	stw	r2,-44(fp)
            if (len > (int)m->m_len)
 8232978:	e0bff417 	ldw	r2,-48(fp)
 823297c:	10800217 	ldw	r2,8(r2)
 8232980:	1007883a 	mov	r3,r2
 8232984:	e0bff517 	ldw	r2,-44(fp)
 8232988:	1880030e 	bge	r3,r2,8232998 <soreceive+0xd8>
               len = m->m_len;
 823298c:	e0bff417 	ldw	r2,-48(fp)
 8232990:	10800217 	ldw	r2,8(r2)
 8232994:	e0bff515 	stw	r2,-44(fp)

            MEMCPY(data, mtod(m, char*), len);
 8232998:	e0bff417 	ldw	r2,-48(fp)
 823299c:	10800317 	ldw	r2,12(r2)
 82329a0:	e0fff517 	ldw	r3,-44(fp)
 82329a4:	180d883a 	mov	r6,r3
 82329a8:	100b883a 	mov	r5,r2
 82329ac:	e13ffe17 	ldw	r4,-8(fp)
 82329b0:	8202f6c0 	call	8202f6c <memcpy>
            data += len;
 82329b4:	e0bff517 	ldw	r2,-44(fp)
 82329b8:	e0fffe17 	ldw	r3,-8(fp)
 82329bc:	1885883a 	add	r2,r3,r2
 82329c0:	e0bffe15 	stw	r2,-8(fp)
            *datalen = len;
 82329c4:	e0bfff17 	ldw	r2,-4(fp)
 82329c8:	e0fff517 	ldw	r3,-44(fp)
 82329cc:	10c00015 	stw	r3,0(r2)
            m = m_free(m);
 82329d0:	e13ff417 	ldw	r4,-48(fp)
 82329d4:	822e58c0 	call	822e58c <m_free>
 82329d8:	e0bff415 	stw	r2,-48(fp)
         } while (*datalen && (error == 0) && m);
 82329dc:	e0bfff17 	ldw	r2,-4(fp)
 82329e0:	10800017 	ldw	r2,0(r2)
 82329e4:	10000426 	beq	r2,zero,82329f8 <soreceive+0x138>
 82329e8:	e0bff617 	ldw	r2,-40(fp)
 82329ec:	1000021e 	bne	r2,zero,82329f8 <soreceive+0x138>
 82329f0:	e0bff417 	ldw	r2,-48(fp)
 82329f4:	103fdd1e 	bne	r2,zero,823296c <soreceive+0xac>
      }

      if (m)
 82329f8:	e0bff417 	ldw	r2,-48(fp)
 82329fc:	10000226 	beq	r2,zero,8232a08 <soreceive+0x148>
         m_freem(m);
 8232a00:	e13ff417 	ldw	r4,-48(fp)
 8232a04:	822e6940 	call	822e694 <m_freem>
      return (error);
 8232a08:	e0bff617 	ldw	r2,-40(fp)
 8232a0c:	00017a06 	br	8232ff8 <soreceive+0x738>
   }

restart:
   sblock (&so->so_rcv);
 8232a10:	00000406 	br	8232a24 <soreceive+0x164>
 8232a14:	e0bffc17 	ldw	r2,-16(fp)
 8232a18:	10801104 	addi	r2,r2,68
 8232a1c:	1009883a 	mov	r4,r2
 8232a20:	82295900 	call	8229590 <tcp_sleep>
 8232a24:	e0bffc17 	ldw	r2,-16(fp)
 8232a28:	1080110b 	ldhu	r2,68(r2)
 8232a2c:	10bfffcc 	andi	r2,r2,65535
 8232a30:	1080004c 	andi	r2,r2,1
 8232a34:	103ff71e 	bne	r2,zero,8232a14 <soreceive+0x154>
 8232a38:	e0bffc17 	ldw	r2,-16(fp)
 8232a3c:	1080110b 	ldhu	r2,68(r2)
 8232a40:	10800054 	ori	r2,r2,1
 8232a44:	1007883a 	mov	r3,r2
 8232a48:	e0bffc17 	ldw	r2,-16(fp)
 8232a4c:	10c0110d 	sth	r3,68(r2)
   INET_TRACE (INETM_IO,
    ("INET:soreceive sbcc %d soerror %d so_state %d *datalen %d\n",
    so->so_rcv.sb_cc, so->so_error, so->so_state, *datalen));

   /* If no data is ready, see if we should wait or return */
   if (so->so_rcv.sb_cc == 0) 
 8232a50:	e0bffc17 	ldw	r2,-16(fp)
 8232a54:	10800a17 	ldw	r2,40(r2)
 8232a58:	10003a1e 	bne	r2,zero,8232b44 <soreceive+0x284>
   {
      if (so->so_error) 
 8232a5c:	e0bffc17 	ldw	r2,-16(fp)
 8232a60:	10800617 	ldw	r2,24(r2)
 8232a64:	10000626 	beq	r2,zero,8232a80 <soreceive+0x1c0>
      {
         error = so->so_error;
 8232a68:	e0bffc17 	ldw	r2,-16(fp)
 8232a6c:	10800617 	ldw	r2,24(r2)
 8232a70:	e0bff615 	stw	r2,-40(fp)
         so->so_error = 0;
 8232a74:	e0bffc17 	ldw	r2,-16(fp)
 8232a78:	10000615 	stw	zero,24(r2)
         goto release;
 8232a7c:	00015206 	br	8232fc8 <soreceive+0x708>
      }
      if (so->so_state & SS_CANTRCVMORE)
 8232a80:	e0bffc17 	ldw	r2,-16(fp)
 8232a84:	1080088b 	ldhu	r2,34(r2)
 8232a88:	10bfffcc 	andi	r2,r2,65535
 8232a8c:	1080080c 	andi	r2,r2,32
 8232a90:	10014a1e 	bne	r2,zero,8232fbc <soreceive+0x6fc>
         goto release;
      if ((so->so_state & SS_ISCONNECTED) == 0 &&
 8232a94:	e0bffc17 	ldw	r2,-16(fp)
 8232a98:	1080088b 	ldhu	r2,34(r2)
 8232a9c:	10bfffcc 	andi	r2,r2,65535
 8232aa0:	1080008c 	andi	r2,r2,2
 8232aa4:	1000091e 	bne	r2,zero,8232acc <soreceive+0x20c>
          (so->so_proto->pr_flags & PR_CONNREQUIRED)) 
 8232aa8:	e0bffc17 	ldw	r2,-16(fp)
 8232aac:	10800217 	ldw	r2,8(r2)
 8232ab0:	1080010b 	ldhu	r2,4(r2)
 8232ab4:	10bfffcc 	andi	r2,r2,65535
 8232ab8:	1080010c 	andi	r2,r2,4
         so->so_error = 0;
         goto release;
      }
      if (so->so_state & SS_CANTRCVMORE)
         goto release;
      if ((so->so_state & SS_ISCONNECTED) == 0 &&
 8232abc:	10000326 	beq	r2,zero,8232acc <soreceive+0x20c>
          (so->so_proto->pr_flags & PR_CONNREQUIRED)) 
      {
         error = ENOTCONN;
 8232ac0:	00802004 	movi	r2,128
 8232ac4:	e0bff615 	stw	r2,-40(fp)
         goto release;
 8232ac8:	00013f06 	br	8232fc8 <soreceive+0x708>
      }
      if (*datalen == 0)
 8232acc:	e0bfff17 	ldw	r2,-4(fp)
 8232ad0:	10800017 	ldw	r2,0(r2)
 8232ad4:	10013b26 	beq	r2,zero,8232fc4 <soreceive+0x704>
         goto release;
      if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT)) 
 8232ad8:	e0bffc17 	ldw	r2,-16(fp)
 8232adc:	1080088b 	ldhu	r2,34(r2)
 8232ae0:	10bfffcc 	andi	r2,r2,65535
 8232ae4:	1080400c 	andi	r2,r2,256
 8232ae8:	1000031e 	bne	r2,zero,8232af8 <soreceive+0x238>
 8232aec:	e0800217 	ldw	r2,8(fp)
 8232af0:	1080080c 	andi	r2,r2,32
 8232af4:	10000326 	beq	r2,zero,8232b04 <soreceive+0x244>
      {
         error = EWOULDBLOCK;
 8232af8:	008002c4 	movi	r2,11
 8232afc:	e0bff615 	stw	r2,-40(fp)
         goto release;
 8232b00:	00013106 	br	8232fc8 <soreceive+0x708>
      }
      sbunlock(&so->so_rcv);
 8232b04:	e0bffc17 	ldw	r2,-16(fp)
 8232b08:	10c0110b 	ldhu	r3,68(r2)
 8232b0c:	00bfff84 	movi	r2,-2
 8232b10:	1884703a 	and	r2,r3,r2
 8232b14:	1007883a 	mov	r3,r2
 8232b18:	e0bffc17 	ldw	r2,-16(fp)
 8232b1c:	10c0110d 	sth	r3,68(r2)
 8232b20:	e0bffc17 	ldw	r2,-16(fp)
 8232b24:	10801104 	addi	r2,r2,68
 8232b28:	1009883a 	mov	r4,r2
 8232b2c:	82297040 	call	8229704 <tcp_wakeup>
      sbwait(&so->so_rcv);
 8232b30:	e0bffc17 	ldw	r2,-16(fp)
 8232b34:	10800a04 	addi	r2,r2,40
 8232b38:	1009883a 	mov	r4,r2
 8232b3c:	82342340 	call	8234234 <sbwait>
      goto restart;
 8232b40:	003fb306 	br	8232a10 <soreceive+0x150>
   }
   m = so->so_rcv.sb_mb;
 8232b44:	e0bffc17 	ldw	r2,-16(fp)
 8232b48:	10801017 	ldw	r2,64(r2)
 8232b4c:	e0bff415 	stw	r2,-48(fp)
   if (m == 0)
 8232b50:	e0bff417 	ldw	r2,-48(fp)
 8232b54:	1000031e 	bne	r2,zero,8232b64 <soreceive+0x2a4>
      panic("sorecv 1");
 8232b58:	01020974 	movhi	r4,2085
 8232b5c:	21039d04 	addi	r4,r4,3700
 8232b60:	8228ca40 	call	8228ca4 <panic>
   nextrecord = m->m_act;
 8232b64:	e0bff417 	ldw	r2,-48(fp)
 8232b68:	10800717 	ldw	r2,28(r2)
 8232b6c:	e0bff815 	stw	r2,-32(fp)
   if (pr->pr_flags & PR_ADDR) 
 8232b70:	e0bffa17 	ldw	r2,-24(fp)
 8232b74:	1080010b 	ldhu	r2,4(r2)
 8232b78:	10bfffcc 	andi	r2,r2,65535
 8232b7c:	1080008c 	andi	r2,r2,2
 8232b80:	10004226 	beq	r2,zero,8232c8c <soreceive+0x3cc>
   {
      if (m->m_type != MT_SONAME) 
 8232b84:	e0bff417 	ldw	r2,-48(fp)
 8232b88:	10800817 	ldw	r2,32(r2)
 8232b8c:	10800260 	cmpeqi	r2,r2,9
 8232b90:	1000091e 	bne	r2,zero,8232bb8 <soreceive+0x2f8>
      {
         dprintf ("sorecv:type %d not nam", m->m_type);
 8232b94:	e0bff417 	ldw	r2,-48(fp)
 8232b98:	10800817 	ldw	r2,32(r2)
 8232b9c:	100b883a 	mov	r5,r2
 8232ba0:	01020974 	movhi	r4,2085
 8232ba4:	2103a004 	addi	r4,r4,3712
 8232ba8:	82033fc0 	call	82033fc <printf>
         panic("sorecv 2");
 8232bac:	01020974 	movhi	r4,2085
 8232bb0:	2103a604 	addi	r4,r4,3736
 8232bb4:	8228ca40 	call	8228ca4 <panic>
      }
      if (flags & MSG_PEEK) 
 8232bb8:	e0800217 	ldw	r2,8(fp)
 8232bbc:	1080008c 	andi	r2,r2,2
 8232bc0:	10000f26 	beq	r2,zero,8232c00 <soreceive+0x340>
      {
         if (aname)
 8232bc4:	e0bffd17 	ldw	r2,-12(fp)
 8232bc8:	10000926 	beq	r2,zero,8232bf0 <soreceive+0x330>
            *aname = m_copy (m, 0, m->m_len);
 8232bcc:	e0bff417 	ldw	r2,-48(fp)
 8232bd0:	10800217 	ldw	r2,8(r2)
 8232bd4:	100d883a 	mov	r6,r2
 8232bd8:	000b883a 	mov	r5,zero
 8232bdc:	e13ff417 	ldw	r4,-48(fp)
 8232be0:	822e6d80 	call	822e6d8 <m_copy>
 8232be4:	1007883a 	mov	r3,r2
 8232be8:	e0bffd17 	ldw	r2,-12(fp)
 8232bec:	10c00015 	stw	r3,0(r2)
         m = m->m_next;
 8232bf0:	e0bff417 	ldw	r2,-48(fp)
 8232bf4:	10800617 	ldw	r2,24(r2)
 8232bf8:	e0bff415 	stw	r2,-48(fp)
 8232bfc:	00002306 	br	8232c8c <soreceive+0x3cc>
      } else 
      {
         sbfree (&so->so_rcv, m);
 8232c00:	e0bffc17 	ldw	r2,-16(fp)
 8232c04:	10c00a17 	ldw	r3,40(r2)
 8232c08:	e0bff417 	ldw	r2,-48(fp)
 8232c0c:	10800217 	ldw	r2,8(r2)
 8232c10:	1887c83a 	sub	r3,r3,r2
 8232c14:	e0bffc17 	ldw	r2,-16(fp)
 8232c18:	10c00a15 	stw	r3,40(r2)
         if (aname) 
 8232c1c:	e0bffd17 	ldw	r2,-12(fp)
 8232c20:	10000d26 	beq	r2,zero,8232c58 <soreceive+0x398>
         {
            *aname = m;
 8232c24:	e0bffd17 	ldw	r2,-12(fp)
 8232c28:	e0fff417 	ldw	r3,-48(fp)
 8232c2c:	10c00015 	stw	r3,0(r2)
            m = m->m_next;
 8232c30:	e0bff417 	ldw	r2,-48(fp)
 8232c34:	10800617 	ldw	r2,24(r2)
 8232c38:	e0bff415 	stw	r2,-48(fp)
            (*aname)->m_next = 0;
 8232c3c:	e0bffd17 	ldw	r2,-12(fp)
 8232c40:	10800017 	ldw	r2,0(r2)
 8232c44:	10000615 	stw	zero,24(r2)
            so->so_rcv.sb_mb = m;
 8232c48:	e0bffc17 	ldw	r2,-16(fp)
 8232c4c:	e0fff417 	ldw	r3,-48(fp)
 8232c50:	10c01015 	stw	r3,64(r2)
 8232c54:	00000806 	br	8232c78 <soreceive+0x3b8>
         } else 
         {
            MFREE(m, so->so_rcv.sb_mb);
 8232c58:	e13ff417 	ldw	r4,-48(fp)
 8232c5c:	822e58c0 	call	822e58c <m_free>
 8232c60:	1007883a 	mov	r3,r2
 8232c64:	e0bffc17 	ldw	r2,-16(fp)
 8232c68:	10c01015 	stw	r3,64(r2)
            m = so->so_rcv.sb_mb;
 8232c6c:	e0bffc17 	ldw	r2,-16(fp)
 8232c70:	10801017 	ldw	r2,64(r2)
 8232c74:	e0bff415 	stw	r2,-48(fp)
         }
         if (m)
 8232c78:	e0bff417 	ldw	r2,-48(fp)
 8232c7c:	10000326 	beq	r2,zero,8232c8c <soreceive+0x3cc>
            m->m_act = nextrecord;
 8232c80:	e0bff417 	ldw	r2,-48(fp)
 8232c84:	e0fff817 	ldw	r3,-32(fp)
 8232c88:	10c00715 	stw	r3,28(r2)
      }
   }
   moff = 0;
 8232c8c:	e03ff915 	stw	zero,-28(fp)
   offset = 0;
 8232c90:	e03ff715 	stw	zero,-36(fp)
   while (m && (*datalen > 0) && (error == 0))
 8232c94:	00009e06 	br	8232f10 <soreceive+0x650>
   {
      if (m->m_type != MT_RXDATA && m->m_type != MT_HEADER)
 8232c98:	e0bff417 	ldw	r2,-48(fp)
 8232c9c:	10800817 	ldw	r2,32(r2)
 8232ca0:	10800060 	cmpeqi	r2,r2,1
 8232ca4:	1000071e 	bne	r2,zero,8232cc4 <soreceive+0x404>
 8232ca8:	e0bff417 	ldw	r2,-48(fp)
 8232cac:	10800817 	ldw	r2,32(r2)
 8232cb0:	108000e0 	cmpeqi	r2,r2,3
 8232cb4:	1000031e 	bne	r2,zero,8232cc4 <soreceive+0x404>
         panic("sorecv 3");
 8232cb8:	01020974 	movhi	r4,2085
 8232cbc:	2103a904 	addi	r4,r4,3748
 8232cc0:	8228ca40 	call	8228ca4 <panic>
      len = *datalen;
 8232cc4:	e0bfff17 	ldw	r2,-4(fp)
 8232cc8:	10800017 	ldw	r2,0(r2)
 8232ccc:	e0bff515 	stw	r2,-44(fp)
      so->so_state &= ~SS_RCVATMARK;
 8232cd0:	e0bffc17 	ldw	r2,-16(fp)
 8232cd4:	10c0088b 	ldhu	r3,34(r2)
 8232cd8:	00bfefc4 	movi	r2,-65
 8232cdc:	1884703a 	and	r2,r3,r2
 8232ce0:	1007883a 	mov	r3,r2
 8232ce4:	e0bffc17 	ldw	r2,-16(fp)
 8232ce8:	10c0088d 	sth	r3,34(r2)
      if (so->so_oobmark && (len > (int)(so->so_oobmark - offset)))
 8232cec:	e0bffc17 	ldw	r2,-16(fp)
 8232cf0:	10801a17 	ldw	r2,104(r2)
 8232cf4:	10000c26 	beq	r2,zero,8232d28 <soreceive+0x468>
 8232cf8:	e0bffc17 	ldw	r2,-16(fp)
 8232cfc:	10c01a17 	ldw	r3,104(r2)
 8232d00:	e0bff717 	ldw	r2,-36(fp)
 8232d04:	1885c83a 	sub	r2,r3,r2
 8232d08:	1007883a 	mov	r3,r2
 8232d0c:	e0bff517 	ldw	r2,-44(fp)
 8232d10:	1880050e 	bge	r3,r2,8232d28 <soreceive+0x468>
         len = (int)(so->so_oobmark - offset);
 8232d14:	e0bffc17 	ldw	r2,-16(fp)
 8232d18:	10c01a17 	ldw	r3,104(r2)
 8232d1c:	e0bff717 	ldw	r2,-36(fp)
 8232d20:	1885c83a 	sub	r2,r3,r2
 8232d24:	e0bff515 	stw	r2,-44(fp)
      if (len > (int)(m->m_len - moff))
 8232d28:	e0bff417 	ldw	r2,-48(fp)
 8232d2c:	10c00217 	ldw	r3,8(r2)
 8232d30:	e0bff917 	ldw	r2,-28(fp)
 8232d34:	1885c83a 	sub	r2,r3,r2
 8232d38:	1007883a 	mov	r3,r2
 8232d3c:	e0bff517 	ldw	r2,-44(fp)
 8232d40:	1880050e 	bge	r3,r2,8232d58 <soreceive+0x498>
         len = m->m_len - moff;
 8232d44:	e0bff417 	ldw	r2,-48(fp)
 8232d48:	10c00217 	ldw	r3,8(r2)
 8232d4c:	e0bff917 	ldw	r2,-28(fp)
 8232d50:	1885c83a 	sub	r2,r3,r2
 8232d54:	e0bff515 	stw	r2,-44(fp)
       * it points to next record) when we drop priority;
       * we must note any additions to the sockbuf when we
       * block interrupts again.
       */

      MEMCPY(data, (mtod(m, char *) + moff), len);
 8232d58:	e0bff417 	ldw	r2,-48(fp)
 8232d5c:	10c00317 	ldw	r3,12(r2)
 8232d60:	e0bff917 	ldw	r2,-28(fp)
 8232d64:	1885883a 	add	r2,r3,r2
 8232d68:	e0fff517 	ldw	r3,-44(fp)
 8232d6c:	180d883a 	mov	r6,r3
 8232d70:	100b883a 	mov	r5,r2
 8232d74:	e13ffe17 	ldw	r4,-8(fp)
 8232d78:	8202f6c0 	call	8202f6c <memcpy>
      data += len;
 8232d7c:	e0bff517 	ldw	r2,-44(fp)
 8232d80:	e0fffe17 	ldw	r3,-8(fp)
 8232d84:	1885883a 	add	r2,r3,r2
 8232d88:	e0bffe15 	stw	r2,-8(fp)
      *datalen -= len;
 8232d8c:	e0bfff17 	ldw	r2,-4(fp)
 8232d90:	10c00017 	ldw	r3,0(r2)
 8232d94:	e0bff517 	ldw	r2,-44(fp)
 8232d98:	1887c83a 	sub	r3,r3,r2
 8232d9c:	e0bfff17 	ldw	r2,-4(fp)
 8232da0:	10c00015 	stw	r3,0(r2)

      if (len == (int)(m->m_len - moff))
 8232da4:	e0bff417 	ldw	r2,-48(fp)
 8232da8:	10c00217 	ldw	r3,8(r2)
 8232dac:	e0bff917 	ldw	r2,-28(fp)
 8232db0:	1885c83a 	sub	r2,r3,r2
 8232db4:	1007883a 	mov	r3,r2
 8232db8:	e0bff517 	ldw	r2,-44(fp)
 8232dbc:	1880201e 	bne	r3,r2,8232e40 <soreceive+0x580>
      {
         if (flags & MSG_PEEK) 
 8232dc0:	e0800217 	ldw	r2,8(fp)
 8232dc4:	1080008c 	andi	r2,r2,2
 8232dc8:	10000526 	beq	r2,zero,8232de0 <soreceive+0x520>
         {
            m = m->m_next;
 8232dcc:	e0bff417 	ldw	r2,-48(fp)
 8232dd0:	10800617 	ldw	r2,24(r2)
 8232dd4:	e0bff415 	stw	r2,-48(fp)
            moff = 0;
 8232dd8:	e03ff915 	stw	zero,-28(fp)
 8232ddc:	00003206 	br	8232ea8 <soreceive+0x5e8>
         } else 
         {
            nextrecord = m->m_act;
 8232de0:	e0bff417 	ldw	r2,-48(fp)
 8232de4:	10800717 	ldw	r2,28(r2)
 8232de8:	e0bff815 	stw	r2,-32(fp)
            sbfree(&so->so_rcv, m);
 8232dec:	e0bffc17 	ldw	r2,-16(fp)
 8232df0:	10c00a17 	ldw	r3,40(r2)
 8232df4:	e0bff417 	ldw	r2,-48(fp)
 8232df8:	10800217 	ldw	r2,8(r2)
 8232dfc:	1887c83a 	sub	r3,r3,r2
 8232e00:	e0bffc17 	ldw	r2,-16(fp)
 8232e04:	10c00a15 	stw	r3,40(r2)
            {
               MFREE(m, so->so_rcv.sb_mb);
 8232e08:	e13ff417 	ldw	r4,-48(fp)
 8232e0c:	822e58c0 	call	822e58c <m_free>
 8232e10:	1007883a 	mov	r3,r2
 8232e14:	e0bffc17 	ldw	r2,-16(fp)
 8232e18:	10c01015 	stw	r3,64(r2)
               m = so->so_rcv.sb_mb;
 8232e1c:	e0bffc17 	ldw	r2,-16(fp)
 8232e20:	10801017 	ldw	r2,64(r2)
 8232e24:	e0bff415 	stw	r2,-48(fp)
            }
            if (m)
 8232e28:	e0bff417 	ldw	r2,-48(fp)
 8232e2c:	10001e26 	beq	r2,zero,8232ea8 <soreceive+0x5e8>
               m->m_act = nextrecord;
 8232e30:	e0bff417 	ldw	r2,-48(fp)
 8232e34:	e0fff817 	ldw	r3,-32(fp)
 8232e38:	10c00715 	stw	r3,28(r2)
 8232e3c:	00001a06 	br	8232ea8 <soreceive+0x5e8>
         }
      } else 
      {
         if (flags & MSG_PEEK)
 8232e40:	e0800217 	ldw	r2,8(fp)
 8232e44:	1080008c 	andi	r2,r2,2
 8232e48:	10000526 	beq	r2,zero,8232e60 <soreceive+0x5a0>
            moff += len;
 8232e4c:	e0fff917 	ldw	r3,-28(fp)
 8232e50:	e0bff517 	ldw	r2,-44(fp)
 8232e54:	1885883a 	add	r2,r3,r2
 8232e58:	e0bff915 	stw	r2,-28(fp)
 8232e5c:	00001206 	br	8232ea8 <soreceive+0x5e8>
         else 
         {
            m->m_data += len;
 8232e60:	e0bff417 	ldw	r2,-48(fp)
 8232e64:	10c00317 	ldw	r3,12(r2)
 8232e68:	e0bff517 	ldw	r2,-44(fp)
 8232e6c:	1887883a 	add	r3,r3,r2
 8232e70:	e0bff417 	ldw	r2,-48(fp)
 8232e74:	10c00315 	stw	r3,12(r2)
            m->m_len -= len;
 8232e78:	e0bff417 	ldw	r2,-48(fp)
 8232e7c:	10c00217 	ldw	r3,8(r2)
 8232e80:	e0bff517 	ldw	r2,-44(fp)
 8232e84:	1887c83a 	sub	r3,r3,r2
 8232e88:	e0bff417 	ldw	r2,-48(fp)
 8232e8c:	10c00215 	stw	r3,8(r2)
            so->so_rcv.sb_cc -= len;
 8232e90:	e0bffc17 	ldw	r2,-16(fp)
 8232e94:	10c00a17 	ldw	r3,40(r2)
 8232e98:	e0bff517 	ldw	r2,-44(fp)
 8232e9c:	1887c83a 	sub	r3,r3,r2
 8232ea0:	e0bffc17 	ldw	r2,-16(fp)
 8232ea4:	10c00a15 	stw	r3,40(r2)
         }
      }
      if (so->so_oobmark) 
 8232ea8:	e0bffc17 	ldw	r2,-16(fp)
 8232eac:	10801a17 	ldw	r2,104(r2)
 8232eb0:	10001726 	beq	r2,zero,8232f10 <soreceive+0x650>
      {
         if ((flags & MSG_PEEK) == 0) 
 8232eb4:	e0800217 	ldw	r2,8(fp)
 8232eb8:	1080008c 	andi	r2,r2,2
 8232ebc:	1000101e 	bne	r2,zero,8232f00 <soreceive+0x640>
         {
            so->so_oobmark -= len;
 8232ec0:	e0bffc17 	ldw	r2,-16(fp)
 8232ec4:	10c01a17 	ldw	r3,104(r2)
 8232ec8:	e0bff517 	ldw	r2,-44(fp)
 8232ecc:	1887c83a 	sub	r3,r3,r2
 8232ed0:	e0bffc17 	ldw	r2,-16(fp)
 8232ed4:	10c01a15 	stw	r3,104(r2)
            if (so->so_oobmark == 0) 
 8232ed8:	e0bffc17 	ldw	r2,-16(fp)
 8232edc:	10801a17 	ldw	r2,104(r2)
 8232ee0:	10000b1e 	bne	r2,zero,8232f10 <soreceive+0x650>
            {
               so->so_state |= SS_RCVATMARK;
 8232ee4:	e0bffc17 	ldw	r2,-16(fp)
 8232ee8:	1080088b 	ldhu	r2,34(r2)
 8232eec:	10801014 	ori	r2,r2,64
 8232ef0:	1007883a 	mov	r3,r2
 8232ef4:	e0bffc17 	ldw	r2,-16(fp)
 8232ef8:	10c0088d 	sth	r3,34(r2)
               break;
 8232efc:	00000b06 	br	8232f2c <soreceive+0x66c>
            }
         } else
            offset += len;
 8232f00:	e0fff717 	ldw	r3,-36(fp)
 8232f04:	e0bff517 	ldw	r2,-44(fp)
 8232f08:	1885883a 	add	r2,r3,r2
 8232f0c:	e0bff715 	stw	r2,-36(fp)
            m->m_act = nextrecord;
      }
   }
   moff = 0;
   offset = 0;
   while (m && (*datalen > 0) && (error == 0))
 8232f10:	e0bff417 	ldw	r2,-48(fp)
 8232f14:	10000526 	beq	r2,zero,8232f2c <soreceive+0x66c>
 8232f18:	e0bfff17 	ldw	r2,-4(fp)
 8232f1c:	10800017 	ldw	r2,0(r2)
 8232f20:	0080020e 	bge	zero,r2,8232f2c <soreceive+0x66c>
 8232f24:	e0bff617 	ldw	r2,-40(fp)
 8232f28:	103f5b26 	beq	r2,zero,8232c98 <soreceive+0x3d8>
         } else
            offset += len;
      }
   }

   if ((flags & MSG_PEEK) == 0) 
 8232f2c:	e0800217 	ldw	r2,8(fp)
 8232f30:	1080008c 	andi	r2,r2,2
 8232f34:	1000241e 	bne	r2,zero,8232fc8 <soreceive+0x708>
   {
      if (m == 0)
 8232f38:	e0bff417 	ldw	r2,-48(fp)
 8232f3c:	1000041e 	bne	r2,zero,8232f50 <soreceive+0x690>
         so->so_rcv.sb_mb = nextrecord;
 8232f40:	e0bffc17 	ldw	r2,-16(fp)
 8232f44:	e0fff817 	ldw	r3,-32(fp)
 8232f48:	10c01015 	stw	r3,64(r2)
 8232f4c:	00000906 	br	8232f74 <soreceive+0x6b4>
      else if (pr->pr_flags & PR_ATOMIC)
 8232f50:	e0bffa17 	ldw	r2,-24(fp)
 8232f54:	1080010b 	ldhu	r2,4(r2)
 8232f58:	10bfffcc 	andi	r2,r2,65535
 8232f5c:	1080004c 	andi	r2,r2,1
 8232f60:	10000426 	beq	r2,zero,8232f74 <soreceive+0x6b4>
         (void) sbdroprecord(&so->so_rcv);
 8232f64:	e0bffc17 	ldw	r2,-16(fp)
 8232f68:	10800a04 	addi	r2,r2,40
 8232f6c:	1009883a 	mov	r4,r2
 8232f70:	8234cc00 	call	8234cc0 <sbdroprecord>
      if (pr->pr_flags & PR_WANTRCVD && so->so_pcb)
 8232f74:	e0bffa17 	ldw	r2,-24(fp)
 8232f78:	1080010b 	ldhu	r2,4(r2)
 8232f7c:	10bfffcc 	andi	r2,r2,65535
 8232f80:	1080020c 	andi	r2,r2,8
 8232f84:	10001026 	beq	r2,zero,8232fc8 <soreceive+0x708>
 8232f88:	e0bffc17 	ldw	r2,-16(fp)
 8232f8c:	10800117 	ldw	r2,4(r2)
 8232f90:	10000d26 	beq	r2,zero,8232fc8 <soreceive+0x708>
      {
         so->so_req = PRU_RCVD;
 8232f94:	e0bffc17 	ldw	r2,-16(fp)
 8232f98:	00c00204 	movi	r3,8
 8232f9c:	10c00715 	stw	r3,28(r2)
         (*pr->pr_usrreq)(so, (struct mbuf *)0,
 8232fa0:	e0bffa17 	ldw	r2,-24(fp)
 8232fa4:	10800317 	ldw	r2,12(r2)
 8232fa8:	000d883a 	mov	r6,zero
 8232fac:	000b883a 	mov	r5,zero
 8232fb0:	e13ffc17 	ldw	r4,-16(fp)
 8232fb4:	103ee83a 	callr	r2
 8232fb8:	00000306 	br	8232fc8 <soreceive+0x708>
         error = so->so_error;
         so->so_error = 0;
         goto release;
      }
      if (so->so_state & SS_CANTRCVMORE)
         goto release;
 8232fbc:	0001883a 	nop
 8232fc0:	00000106 	br	8232fc8 <soreceive+0x708>
      {
         error = ENOTCONN;
         goto release;
      }
      if (*datalen == 0)
         goto release;
 8232fc4:	0001883a 	nop
         (*pr->pr_usrreq)(so, (struct mbuf *)0,
          (struct mbuf *)0);
      }
   }
release:
   sbunlock(&so->so_rcv);
 8232fc8:	e0bffc17 	ldw	r2,-16(fp)
 8232fcc:	10c0110b 	ldhu	r3,68(r2)
 8232fd0:	00bfff84 	movi	r2,-2
 8232fd4:	1884703a 	and	r2,r3,r2
 8232fd8:	1007883a 	mov	r3,r2
 8232fdc:	e0bffc17 	ldw	r2,-16(fp)
 8232fe0:	10c0110d 	sth	r3,68(r2)
 8232fe4:	e0bffc17 	ldw	r2,-16(fp)
 8232fe8:	10801104 	addi	r2,r2,68
 8232fec:	1009883a 	mov	r4,r2
 8232ff0:	82297040 	call	8229704 <tcp_wakeup>
   return (error);
 8232ff4:	e0bff617 	ldw	r2,-40(fp)
}
 8232ff8:	e037883a 	mov	sp,fp
 8232ffc:	dfc00117 	ldw	ra,4(sp)
 8233000:	df000017 	ldw	fp,0(sp)
 8233004:	dec00204 	addi	sp,sp,8
 8233008:	f800283a 	ret

0823300c <soshutdown>:
 *
 * RETURNS: int               0 if successful, else error code
 */
int
soshutdown(struct socket *so, int how)
{
 823300c:	defffc04 	addi	sp,sp,-16
 8233010:	dfc00315 	stw	ra,12(sp)
 8233014:	df000215 	stw	fp,8(sp)
 8233018:	df000204 	addi	fp,sp,8
 823301c:	e13ffe15 	stw	r4,-8(fp)
 8233020:	e17fff15 	stw	r5,-4(fp)
   how++;   /* convert 0,1,2 into 1,2,3 */
 8233024:	e0bfff17 	ldw	r2,-4(fp)
 8233028:	10800044 	addi	r2,r2,1
 823302c:	e0bfff15 	stw	r2,-4(fp)
   if (how & 1)   /* caller wanted READ or BOTH */
 8233030:	e0bfff17 	ldw	r2,-4(fp)
 8233034:	1080004c 	andi	r2,r2,1
 8233038:	10000226 	beq	r2,zero,8233044 <soshutdown+0x38>
      sorflush(so);
 823303c:	e13ffe17 	ldw	r4,-8(fp)
 8233040:	82330a40 	call	82330a4 <sorflush>

   if (how & 2)   /* caller wanted WRITE or BOTH */
 8233044:	e0bfff17 	ldw	r2,-4(fp)
 8233048:	1080008c 	andi	r2,r2,2
 823304c:	10000f26 	beq	r2,zero,823308c <soshutdown+0x80>
   {
      sbflush(&so->so_snd); /* flush the socket send queue */
 8233050:	e0bffe17 	ldw	r2,-8(fp)
 8233054:	10801204 	addi	r2,r2,72
 8233058:	1009883a 	mov	r4,r2
 823305c:	82349840 	call	8234984 <sbflush>
      so->so_req = PRU_SHUTDOWN;
 8233060:	e0bffe17 	ldw	r2,-8(fp)
 8233064:	00c001c4 	movi	r3,7
 8233068:	10c00715 	stw	r3,28(r2)
      return ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0));
 823306c:	e0bffe17 	ldw	r2,-8(fp)
 8233070:	10800217 	ldw	r2,8(r2)
 8233074:	10800317 	ldw	r2,12(r2)
 8233078:	000d883a 	mov	r6,zero
 823307c:	000b883a 	mov	r5,zero
 8233080:	e13ffe17 	ldw	r4,-8(fp)
 8233084:	103ee83a 	callr	r2
 8233088:	00000106 	br	8233090 <soshutdown+0x84>
   }

   return 0;
 823308c:	0005883a 	mov	r2,zero
}
 8233090:	e037883a 	mov	sp,fp
 8233094:	dfc00117 	ldw	ra,4(sp)
 8233098:	df000017 	ldw	fp,0(sp)
 823309c:	dec00204 	addi	sp,sp,8
 82330a0:	f800283a 	ret

082330a4 <sorflush>:
 * socket receive buffer is discarded. Wakeup any processes waiting
 * on the socket.
 */
void
sorflush(struct socket * so)
{
 82330a4:	defffb04 	addi	sp,sp,-20
 82330a8:	dfc00415 	stw	ra,16(sp)
 82330ac:	df000315 	stw	fp,12(sp)
 82330b0:	df000304 	addi	fp,sp,12
 82330b4:	e13fff15 	stw	r4,-4(fp)
   struct sockbuf *sb =  &so->so_rcv;
 82330b8:	e0bfff17 	ldw	r2,-4(fp)
 82330bc:	10800a04 	addi	r2,r2,40
 82330c0:	e0bffd15 	stw	r2,-12(fp)
   int   s;

   sblock(sb);
 82330c4:	00000406 	br	82330d8 <sorflush+0x34>
 82330c8:	e0bffd17 	ldw	r2,-12(fp)
 82330cc:	10800704 	addi	r2,r2,28
 82330d0:	1009883a 	mov	r4,r2
 82330d4:	82295900 	call	8229590 <tcp_sleep>
 82330d8:	e0bffd17 	ldw	r2,-12(fp)
 82330dc:	1080070b 	ldhu	r2,28(r2)
 82330e0:	10bfffcc 	andi	r2,r2,65535
 82330e4:	1080004c 	andi	r2,r2,1
 82330e8:	103ff71e 	bne	r2,zero,82330c8 <sorflush+0x24>
 82330ec:	e0bffd17 	ldw	r2,-12(fp)
 82330f0:	1080070b 	ldhu	r2,28(r2)
 82330f4:	10800054 	ori	r2,r2,1
 82330f8:	1007883a 	mov	r3,r2
 82330fc:	e0bffd17 	ldw	r2,-12(fp)
 8233100:	10c0070d 	sth	r3,28(r2)
   socantrcvmore(so);
 8233104:	e13fff17 	ldw	r4,-4(fp)
 8233108:	82341a00 	call	82341a0 <socantrcvmore>
   sbunlock(sb);
 823310c:	e0bffd17 	ldw	r2,-12(fp)
 8233110:	10c0070b 	ldhu	r3,28(r2)
 8233114:	00bfff84 	movi	r2,-2
 8233118:	1884703a 	and	r2,r3,r2
 823311c:	1007883a 	mov	r3,r2
 8233120:	e0bffd17 	ldw	r2,-12(fp)
 8233124:	10c0070d 	sth	r3,28(r2)
 8233128:	e0bffd17 	ldw	r2,-12(fp)
 823312c:	10800704 	addi	r2,r2,28
 8233130:	1009883a 	mov	r4,r2
 8233134:	82297040 	call	8229704 <tcp_wakeup>
   sbrelease(sb);
 8233138:	e13ffd17 	ldw	r4,-12(fp)
 823313c:	82344040 	call	8234404 <sbrelease>
   MEMSET((char *)sb, 0, sizeof (*sb));
 8233140:	01800804 	movi	r6,32
 8233144:	000b883a 	mov	r5,zero
 8233148:	e13ffd17 	ldw	r4,-12(fp)
 823314c:	82032100 	call	8203210 <memset>
   s = so->so_error;
 8233150:	e0bfff17 	ldw	r2,-4(fp)
 8233154:	10800617 	ldw	r2,24(r2)
 8233158:	e0bffe15 	stw	r2,-8(fp)
   so->so_error = ESHUTDOWN;
 823315c:	e0bfff17 	ldw	r2,-4(fp)
 8233160:	00c01b84 	movi	r3,110
 8233164:	10c00615 	stw	r3,24(r2)
   sorwakeup(so);
 8233168:	e0bfff17 	ldw	r2,-4(fp)
 823316c:	10800a04 	addi	r2,r2,40
 8233170:	100b883a 	mov	r5,r2
 8233174:	e13fff17 	ldw	r4,-4(fp)
 8233178:	82342a00 	call	82342a0 <sbwakeup>
   so->so_error = s;
 823317c:	e0bfff17 	ldw	r2,-4(fp)
 8233180:	e0fffe17 	ldw	r3,-8(fp)
 8233184:	10c00615 	stw	r3,24(r2)
}
 8233188:	0001883a 	nop
 823318c:	e037883a 	mov	sp,fp
 8233190:	dfc00117 	ldw	ra,4(sp)
 8233194:	df000017 	ldw	fp,0(sp)
 8233198:	dec00204 	addi	sp,sp,8
 823319c:	f800283a 	ret

082331a0 <sosetopt>:

int
sosetopt(struct socket * so, 
   int   optname,
   void *   arg)
{
 82331a0:	defff604 	addi	sp,sp,-40
 82331a4:	dfc00915 	stw	ra,36(sp)
 82331a8:	df000815 	stw	fp,32(sp)
 82331ac:	df000804 	addi	fp,sp,32
 82331b0:	e13ffd15 	stw	r4,-12(fp)
 82331b4:	e17ffe15 	stw	r5,-8(fp)
 82331b8:	e1bfff15 	stw	r6,-4(fp)
   int   error =  0;
 82331bc:	e03ff815 	stw	zero,-32(fp)

   switch (optname) 
 82331c0:	e0bffe17 	ldw	r2,-8(fp)
 82331c4:	10c08020 	cmpeqi	r3,r2,512
 82331c8:	18003b1e 	bne	r3,zero,82332b8 <sosetopt+0x118>
 82331cc:	10c08048 	cmpgei	r3,r2,513
 82331d0:	1800171e 	bne	r3,zero,8233230 <sosetopt+0x90>
 82331d4:	10c00388 	cmpgei	r3,r2,14
 82331d8:	1800091e 	bne	r3,zero,8233200 <sosetopt+0x60>
 82331dc:	10c00248 	cmpgei	r3,r2,9
 82331e0:	1800831e 	bne	r3,zero,82333f0 <sosetopt+0x250>
 82331e4:	10c00120 	cmpeqi	r3,r2,4
 82331e8:	1800331e 	bne	r3,zero,82332b8 <sosetopt+0x118>
 82331ec:	10c00220 	cmpeqi	r3,r2,8
 82331f0:	1800311e 	bne	r3,zero,82332b8 <sosetopt+0x118>
 82331f4:	108000a0 	cmpeqi	r2,r2,2
 82331f8:	1000831e 	bne	r2,zero,8233408 <sosetopt+0x268>
 82331fc:	0000ea06 	br	82335a8 <sosetopt+0x408>
 8233200:	10c00820 	cmpeqi	r3,r2,32
 8233204:	18002c1e 	bne	r3,zero,82332b8 <sosetopt+0x118>
 8233208:	10c00848 	cmpgei	r3,r2,33
 823320c:	1800031e 	bne	r3,zero,823321c <sosetopt+0x7c>
 8233210:	10800420 	cmpeqi	r2,r2,16
 8233214:	1000281e 	bne	r2,zero,82332b8 <sosetopt+0x118>
 8233218:	0000e306 	br	82335a8 <sosetopt+0x408>
 823321c:	10c02020 	cmpeqi	r3,r2,128
 8233220:	1800201e 	bne	r3,zero,82332a4 <sosetopt+0x104>
 8233224:	10804020 	cmpeqi	r2,r2,256
 8233228:	1000231e 	bne	r2,zero,82332b8 <sosetopt+0x118>
 823322c:	0000de06 	br	82335a8 <sosetopt+0x408>
 8233230:	10c40520 	cmpeqi	r3,r2,4116
 8233234:	1800481e 	bne	r3,zero,8233358 <sosetopt+0x1b8>
 8233238:	10c40548 	cmpgei	r3,r2,4117
 823323c:	18000b1e 	bne	r3,zero,823326c <sosetopt+0xcc>
 8233240:	10c401a0 	cmpeqi	r3,r2,4102
 8233244:	18003f1e 	bne	r3,zero,8233344 <sosetopt+0x1a4>
 8233248:	10c401c8 	cmpgei	r3,r2,4103
 823324c:	1800041e 	bne	r3,zero,8233260 <sosetopt+0xc0>
 8233250:	10bbffc4 	addi	r2,r2,-4097
 8233254:	108000a8 	cmpgeui	r2,r2,2
 8233258:	1000d31e 	bne	r2,zero,82335a8 <sosetopt+0x408>
 823325c:	00002806 	br	8233300 <sosetopt+0x160>
 8233260:	10840420 	cmpeqi	r2,r2,4112
 8233264:	1000a91e 	bne	r2,zero,823350c <sosetopt+0x36c>
 8233268:	0000cf06 	br	82335a8 <sosetopt+0x408>
 823326c:	10c800e0 	cmpeqi	r3,r2,8195
 8233270:	1800a61e 	bne	r3,zero,823350c <sosetopt+0x36c>
 8233274:	10c80108 	cmpgei	r3,r2,8196
 8233278:	1800051e 	bne	r3,zero,8233290 <sosetopt+0xf0>
 823327c:	10c40560 	cmpeqi	r3,r2,4117
 8233280:	18003c1e 	bne	r3,zero,8233374 <sosetopt+0x1d4>
 8233284:	108405a0 	cmpeqi	r2,r2,4118
 8233288:	1000421e 	bne	r2,zero,8233394 <sosetopt+0x1f4>
 823328c:	0000c606 	br	82335a8 <sosetopt+0x408>
 8233290:	10c80120 	cmpeqi	r3,r2,8196
 8233294:	1800711e 	bne	r3,zero,823345c <sosetopt+0x2bc>
 8233298:	10900020 	cmpeqi	r2,r2,16384
 823329c:	1000061e 	bne	r2,zero,82332b8 <sosetopt+0x118>
 82332a0:	0000c106 	br	82335a8 <sosetopt+0x408>
   {
   case SO_LINGER:
      so->so_linger = (short)((struct linger *)arg)->l_linger;
 82332a4:	e0bfff17 	ldw	r2,-4(fp)
 82332a8:	10800117 	ldw	r2,4(r2)
 82332ac:	1007883a 	mov	r3,r2
 82332b0:	e0bffd17 	ldw	r2,-12(fp)
 82332b4:	10c0080d 	sth	r3,32(r2)
   case SO_TCPSACK:
   case SO_NOSLOWSTART:
#ifdef SUPPORT_SO_FULLMSS
   case SO_FULLMSS:
#endif
      if (*(int *)arg) 
 82332b8:	e0bfff17 	ldw	r2,-4(fp)
 82332bc:	10800017 	ldw	r2,0(r2)
 82332c0:	10000726 	beq	r2,zero,82332e0 <sosetopt+0x140>
         so->so_options |= optname;
 82332c4:	e0bffd17 	ldw	r2,-12(fp)
 82332c8:	10c00417 	ldw	r3,16(r2)
 82332cc:	e0bffe17 	ldw	r2,-8(fp)
 82332d0:	1886b03a 	or	r3,r3,r2
 82332d4:	e0bffd17 	ldw	r2,-12(fp)
 82332d8:	10c00415 	stw	r3,16(r2)
      else
         so->so_options &= ~optname;
      break;
 82332dc:	0000b606 	br	82335b8 <sosetopt+0x418>
   case SO_FULLMSS:
#endif
      if (*(int *)arg) 
         so->so_options |= optname;
      else
         so->so_options &= ~optname;
 82332e0:	e0bffd17 	ldw	r2,-12(fp)
 82332e4:	10800417 	ldw	r2,16(r2)
 82332e8:	e0fffe17 	ldw	r3,-8(fp)
 82332ec:	00c6303a 	nor	r3,zero,r3
 82332f0:	10c6703a 	and	r3,r2,r3
 82332f4:	e0bffd17 	ldw	r2,-12(fp)
 82332f8:	10c00415 	stw	r3,16(r2)
      break;
 82332fc:	0000ae06 	br	82335b8 <sosetopt+0x418>
      break;
#endif /* TCP_BIGCWND */

   case SO_SNDBUF:
   case SO_RCVBUF:
      if (sbreserve(optname == SO_SNDBUF ?
 8233300:	e0bffe17 	ldw	r2,-8(fp)
 8233304:	10840058 	cmpnei	r2,r2,4097
 8233308:	1000031e 	bne	r2,zero,8233318 <sosetopt+0x178>
 823330c:	e0bffd17 	ldw	r2,-12(fp)
 8233310:	10801204 	addi	r2,r2,72
 8233314:	00000206 	br	8233320 <sosetopt+0x180>
 8233318:	e0bffd17 	ldw	r2,-12(fp)
 823331c:	10800a04 	addi	r2,r2,40
          &so->so_snd : &so->so_rcv,
          (u_long) * (int *)arg) == 0) 
 8233320:	e0ffff17 	ldw	r3,-4(fp)
 8233324:	18c00017 	ldw	r3,0(r3)
      break;
#endif /* TCP_BIGCWND */

   case SO_SNDBUF:
   case SO_RCVBUF:
      if (sbreserve(optname == SO_SNDBUF ?
 8233328:	180b883a 	mov	r5,r3
 823332c:	1009883a 	mov	r4,r2
 8233330:	82343b40 	call	82343b4 <sbreserve>
 8233334:	10009f1e 	bne	r2,zero,82335b4 <sosetopt+0x414>
          &so->so_snd : &so->so_rcv,
          (u_long) * (int *)arg) == 0) 
      {
         error = ENOBUFS;
 8233338:	00801a44 	movi	r2,105
 823333c:	e0bff815 	stw	r2,-32(fp)
         goto bad;
 8233340:	00009d06 	br	82335b8 <sosetopt+0x418>
      }
      break;

   case SO_RCVTIMEO:
      so->so_rcv.sb_timeo = *(short *)arg;
 8233344:	e0bfff17 	ldw	r2,-4(fp)
 8233348:	10c0000b 	ldhu	r3,0(r2)
 823334c:	e0bffd17 	ldw	r2,-12(fp)
 8233350:	10c0118d 	sth	r3,70(r2)
      break;
 8233354:	00009806 	br	82335b8 <sosetopt+0x418>

   case SO_NBIO:     /* set socket into NON-blocking mode */
      so->so_state |= SS_NBIO;
 8233358:	e0bffd17 	ldw	r2,-12(fp)
 823335c:	1080088b 	ldhu	r2,34(r2)
 8233360:	10804014 	ori	r2,r2,256
 8233364:	1007883a 	mov	r3,r2
 8233368:	e0bffd17 	ldw	r2,-12(fp)
 823336c:	10c0088d 	sth	r3,34(r2)
      break;
 8233370:	00009106 	br	82335b8 <sosetopt+0x418>

   case SO_BIO:   /* set socket into blocking mode */
      so->so_state &= ~SS_NBIO;
 8233374:	e0bffd17 	ldw	r2,-12(fp)
 8233378:	10c0088b 	ldhu	r3,34(r2)
 823337c:	00bfbfc4 	movi	r2,-257
 8233380:	1884703a 	and	r2,r3,r2
 8233384:	1007883a 	mov	r3,r2
 8233388:	e0bffd17 	ldw	r2,-12(fp)
 823338c:	10c0088d 	sth	r3,34(r2)
      break;
 8233390:	00008906 	br	82335b8 <sosetopt+0x418>

   case SO_NONBLOCK:    /* set blocking mode according to arg */
      /* sanity check the arg parameter */
      if (!arg)
 8233394:	e0bfff17 	ldw	r2,-4(fp)
 8233398:	1000031e 	bne	r2,zero,82333a8 <sosetopt+0x208>
      {
         error = ENP_PARAM;
 823339c:	00bffd84 	movi	r2,-10
 82333a0:	e0bff815 	stw	r2,-32(fp)
         break;
 82333a4:	00008406 	br	82335b8 <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 82333a8:	e0bfff17 	ldw	r2,-4(fp)
 82333ac:	10800017 	ldw	r2,0(r2)
 82333b0:	10000726 	beq	r2,zero,82333d0 <sosetopt+0x230>
         so->so_state |= SS_NBIO;   /* set non-blocking mode */
 82333b4:	e0bffd17 	ldw	r2,-12(fp)
 82333b8:	1080088b 	ldhu	r2,34(r2)
 82333bc:	10804014 	ori	r2,r2,256
 82333c0:	1007883a 	mov	r3,r2
 82333c4:	e0bffd17 	ldw	r2,-12(fp)
 82333c8:	10c0088d 	sth	r3,34(r2)
      else
         so->so_state &= ~SS_NBIO;  /* set blocking mode */
      break;
 82333cc:	00007a06 	br	82335b8 <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
         so->so_state |= SS_NBIO;   /* set non-blocking mode */
      else
         so->so_state &= ~SS_NBIO;  /* set blocking mode */
 82333d0:	e0bffd17 	ldw	r2,-12(fp)
 82333d4:	10c0088b 	ldhu	r3,34(r2)
 82333d8:	00bfbfc4 	movi	r2,-257
 82333dc:	1884703a 	and	r2,r3,r2
 82333e0:	1007883a 	mov	r3,r2
 82333e4:	e0bffd17 	ldw	r2,-12(fp)
 82333e8:	10c0088d 	sth	r3,34(r2)
      break;
 82333ec:	00007206 	br	82335b8 <sosetopt+0x418>
   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      error = ip_setmoptions(optname, so, arg);
 82333f0:	e1bfff17 	ldw	r6,-4(fp)
 82333f4:	e17ffd17 	ldw	r5,-12(fp)
 82333f8:	e13ffe17 	ldw	r4,-8(fp)
 82333fc:	82460080 	call	8246008 <ip_setmoptions>
 8233400:	e0bff815 	stw	r2,-32(fp)
      break;
 8233404:	00006c06 	br	82335b8 <sosetopt+0x418>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 8233408:	e0bfff17 	ldw	r2,-4(fp)
 823340c:	1000031e 	bne	r2,zero,823341c <sosetopt+0x27c>
      {
         error = ENP_PARAM;
 8233410:	00bffd84 	movi	r2,-10
 8233414:	e0bff815 	stw	r2,-32(fp)
         break;
 8233418:	00006706 	br	82335b8 <sosetopt+0x418>
      }
      /* set the socket option flag based on the pointed-to argument */
      if (*(int *)arg)
 823341c:	e0bfff17 	ldw	r2,-4(fp)
 8233420:	10800017 	ldw	r2,0(r2)
 8233424:	10000626 	beq	r2,zero,8233440 <sosetopt+0x2a0>
         so->so_options |= SO_HDRINCL;
 8233428:	e0bffd17 	ldw	r2,-12(fp)
 823342c:	10800417 	ldw	r2,16(r2)
 8233430:	10c80014 	ori	r3,r2,8192
 8233434:	e0bffd17 	ldw	r2,-12(fp)
 8233438:	10c00415 	stw	r3,16(r2)
      else
         so->so_options &= ~SO_HDRINCL;
      break;
 823343c:	00005e06 	br	82335b8 <sosetopt+0x418>
      }
      /* set the socket option flag based on the pointed-to argument */
      if (*(int *)arg)
         so->so_options |= SO_HDRINCL;
      else
         so->so_options &= ~SO_HDRINCL;
 8233440:	e0bffd17 	ldw	r2,-12(fp)
 8233444:	10c00417 	ldw	r3,16(r2)
 8233448:	00b7ffc4 	movi	r2,-8193
 823344c:	1886703a 	and	r3,r3,r2
 8233450:	e0bffd17 	ldw	r2,-12(fp)
 8233454:	10c00415 	stw	r3,16(r2)
      break;
 8233458:	00005706 	br	82335b8 <sosetopt+0x418>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 823345c:	e0bffd17 	ldw	r2,-12(fp)
 8233460:	10800983 	ldbu	r2,38(r2)
 8233464:	10803fcc 	andi	r2,r2,255
 8233468:	1080201c 	xori	r2,r2,128
 823346c:	10bfe004 	addi	r2,r2,-128
 8233470:	10800060 	cmpeqi	r2,r2,1
 8233474:	1000031e 	bne	r2,zero,8233484 <sosetopt+0x2e4>
      {
         error = EINVAL;
 8233478:	00800584 	movi	r2,22
 823347c:	e0bff815 	stw	r2,-32(fp)
         break;
 8233480:	00004d06 	br	82335b8 <sosetopt+0x418>
      }
      inp = (struct inpcb *)(so->so_pcb);
 8233484:	e0bffd17 	ldw	r2,-12(fp)
 8233488:	10800117 	ldw	r2,4(r2)
 823348c:	e0bff915 	stw	r2,-28(fp)
      tp = intotcpcb(inp);
 8233490:	e0bff917 	ldw	r2,-28(fp)
 8233494:	10800917 	ldw	r2,36(r2)
 8233498:	e0bffa15 	stw	r2,-24(fp)
      if(!tp)
 823349c:	e0bffa17 	ldw	r2,-24(fp)
 82334a0:	1000031e 	bne	r2,zero,82334b0 <sosetopt+0x310>
      {
         error = ENOTCONN;
 82334a4:	00802004 	movi	r2,128
 82334a8:	e0bff815 	stw	r2,-32(fp)
         break;
 82334ac:	00004206 	br	82335b8 <sosetopt+0x418>
      }
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 82334b0:	e0bfff17 	ldw	r2,-4(fp)
 82334b4:	1000031e 	bne	r2,zero,82334c4 <sosetopt+0x324>
      {
         error = ENP_PARAM;
 82334b8:	00bffd84 	movi	r2,-10
 82334bc:	e0bff815 	stw	r2,-32(fp)
         break;
 82334c0:	00003d06 	br	82335b8 <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 82334c4:	e0bfff17 	ldw	r2,-4(fp)
 82334c8:	10800017 	ldw	r2,0(r2)
 82334cc:	10000726 	beq	r2,zero,82334ec <sosetopt+0x34c>
         tp->t_flags |= TF_NODELAY;   /* Disable Nagle Algorithm */
 82334d0:	e0bffa17 	ldw	r2,-24(fp)
 82334d4:	10800b0b 	ldhu	r2,44(r2)
 82334d8:	10800114 	ori	r2,r2,4
 82334dc:	1007883a 	mov	r3,r2
 82334e0:	e0bffa17 	ldw	r2,-24(fp)
 82334e4:	10c00b0d 	sth	r3,44(r2)
      else
         tp->t_flags &= ~TF_NODELAY;  /* Enable Nagle Algorithm */

      break;
 82334e8:	00003306 	br	82335b8 <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
         tp->t_flags |= TF_NODELAY;   /* Disable Nagle Algorithm */
      else
         tp->t_flags &= ~TF_NODELAY;  /* Enable Nagle Algorithm */
 82334ec:	e0bffa17 	ldw	r2,-24(fp)
 82334f0:	10c00b0b 	ldhu	r3,44(r2)
 82334f4:	00bffec4 	movi	r2,-5
 82334f8:	1884703a 	and	r2,r3,r2
 82334fc:	1007883a 	mov	r3,r2
 8233500:	e0bffa17 	ldw	r2,-24(fp)
 8233504:	10c00b0d 	sth	r3,44(r2)

      break;
 8233508:	00002b06 	br	82335b8 <sosetopt+0x418>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 823350c:	e0bffd17 	ldw	r2,-12(fp)
 8233510:	10800983 	ldbu	r2,38(r2)
 8233514:	10803fcc 	andi	r2,r2,255
 8233518:	1080201c 	xori	r2,r2,128
 823351c:	10bfe004 	addi	r2,r2,-128
 8233520:	10800060 	cmpeqi	r2,r2,1
 8233524:	1000031e 	bne	r2,zero,8233534 <sosetopt+0x394>
      {
         error = EINVAL;
 8233528:	00800584 	movi	r2,22
 823352c:	e0bff815 	stw	r2,-32(fp)
         break;
 8233530:	00002106 	br	82335b8 <sosetopt+0x418>
      }
      inp = (struct inpcb *)(so->so_pcb);
 8233534:	e0bffd17 	ldw	r2,-12(fp)
 8233538:	10800117 	ldw	r2,4(r2)
 823353c:	e0bffb15 	stw	r2,-20(fp)
      tp = intotcpcb(inp);
 8233540:	e0bffb17 	ldw	r2,-20(fp)
 8233544:	10800917 	ldw	r2,36(r2)
 8233548:	e0bffc15 	stw	r2,-16(fp)
      if(!tp)
 823354c:	e0bffc17 	ldw	r2,-16(fp)
 8233550:	1000031e 	bne	r2,zero,8233560 <sosetopt+0x3c0>
      {
         error = ENOTCONN;
 8233554:	00802004 	movi	r2,128
 8233558:	e0bff815 	stw	r2,-32(fp)
         break;
 823355c:	00001606 	br	82335b8 <sosetopt+0x418>
      }
      if (tp->t_state != TCPS_CLOSED)
 8233560:	e0bffc17 	ldw	r2,-16(fp)
 8233564:	10800217 	ldw	r2,8(r2)
 8233568:	10000326 	beq	r2,zero,8233578 <sosetopt+0x3d8>
      {
         error = EINVAL;
 823356c:	00800584 	movi	r2,22
 8233570:	e0bff815 	stw	r2,-32(fp)
         break;
 8233574:	00001006 	br	82335b8 <sosetopt+0x418>
      }
      tp->t_maxseg = *(int*)(arg);    /* set TCP MSS */
 8233578:	e0bfff17 	ldw	r2,-4(fp)
 823357c:	10800017 	ldw	r2,0(r2)
 8233580:	1007883a 	mov	r3,r2
 8233584:	e0bffc17 	ldw	r2,-16(fp)
 8233588:	10c00a0d 	sth	r3,40(r2)
      tp->t_flags |= TF_MAXSEG;   /* mark as user set max seg */
 823358c:	e0bffc17 	ldw	r2,-16(fp)
 8233590:	10800b0b 	ldhu	r2,44(r2)
 8233594:	10810014 	ori	r2,r2,1024
 8233598:	1007883a 	mov	r3,r2
 823359c:	e0bffc17 	ldw	r2,-16(fp)
 82335a0:	10c00b0d 	sth	r3,44(r2)
      break;
 82335a4:	00000406 	br	82335b8 <sosetopt+0x418>
   }
   default:
      error = ENOPROTOOPT;
 82335a8:	00801b44 	movi	r2,109
 82335ac:	e0bff815 	stw	r2,-32(fp)
      break;
 82335b0:	00000106 	br	82335b8 <sosetopt+0x418>
          (u_long) * (int *)arg) == 0) 
      {
         error = ENOBUFS;
         goto bad;
      }
      break;
 82335b4:	0001883a 	nop
   default:
      error = ENOPROTOOPT;
      break;
   }
bad:
   return (error);
 82335b8:	e0bff817 	ldw	r2,-32(fp)
}
 82335bc:	e037883a 	mov	sp,fp
 82335c0:	dfc00117 	ldw	ra,4(sp)
 82335c4:	df000017 	ldw	fp,0(sp)
 82335c8:	dec00204 	addi	sp,sp,8
 82335cc:	f800283a 	ret

082335d0 <sogetopt>:

int
sogetopt(struct socket * so, 
   int   optname,
   void *   val)
{
 82335d0:	defff504 	addi	sp,sp,-44
 82335d4:	dfc00a15 	stw	ra,40(sp)
 82335d8:	df000915 	stw	fp,36(sp)
 82335dc:	df000904 	addi	fp,sp,36
 82335e0:	e13ffd15 	stw	r4,-12(fp)
 82335e4:	e17ffe15 	stw	r5,-8(fp)
 82335e8:	e1bfff15 	stw	r6,-4(fp)
   int   error =  0;
 82335ec:	e03ff715 	stw	zero,-36(fp)

   /* sanity check the val parameter */
   if (!val)
 82335f0:	e0bfff17 	ldw	r2,-4(fp)
 82335f4:	1000021e 	bne	r2,zero,8233600 <sogetopt+0x30>
   {
      return ENP_PARAM;
 82335f8:	00bffd84 	movi	r2,-10
 82335fc:	00011906 	br	8233a64 <sogetopt+0x494>
   }

   switch (optname) 
 8233600:	e0bffe17 	ldw	r2,-8(fp)
 8233604:	10c400e0 	cmpeqi	r3,r2,4099
 8233608:	1800701e 	bne	r3,zero,82337cc <sogetopt+0x1fc>
 823360c:	10c40108 	cmpgei	r3,r2,4100
 8233610:	1800201e 	bne	r3,zero,8233694 <sogetopt+0xc4>
 8233614:	10c00420 	cmpeqi	r3,r2,16
 8233618:	1800641e 	bne	r3,zero,82337ac <sogetopt+0x1dc>
 823361c:	10c00448 	cmpgei	r3,r2,17
 8233620:	18000c1e 	bne	r3,zero,8233654 <sogetopt+0x84>
 8233624:	10c00220 	cmpeqi	r3,r2,8
 8233628:	1800601e 	bne	r3,zero,82337ac <sogetopt+0x1dc>
 823362c:	10c00248 	cmpgei	r3,r2,9
 8233630:	1800051e 	bne	r3,zero,8233648 <sogetopt+0x78>
 8233634:	10c000a0 	cmpeqi	r3,r2,2
 8233638:	1800d61e 	bne	r3,zero,8233994 <sogetopt+0x3c4>
 823363c:	10800120 	cmpeqi	r2,r2,4
 8233640:	10005a1e 	bne	r2,zero,82337ac <sogetopt+0x1dc>
 8233644:	00010406 	br	8233a58 <sogetopt+0x488>
 8233648:	10800308 	cmpgei	r2,r2,12
 823364c:	1001021e 	bne	r2,zero,8233a58 <sogetopt+0x488>
 8233650:	0000ca06 	br	823397c <sogetopt+0x3ac>
 8233654:	10c04020 	cmpeqi	r3,r2,256
 8233658:	1800541e 	bne	r3,zero,82337ac <sogetopt+0x1dc>
 823365c:	10c04048 	cmpgei	r3,r2,257
 8233660:	1800051e 	bne	r3,zero,8233678 <sogetopt+0xa8>
 8233664:	10c00820 	cmpeqi	r3,r2,32
 8233668:	1800501e 	bne	r3,zero,82337ac <sogetopt+0x1dc>
 823366c:	10802020 	cmpeqi	r2,r2,128
 8233670:	10003f1e 	bne	r2,zero,8233770 <sogetopt+0x1a0>
 8233674:	0000f806 	br	8233a58 <sogetopt+0x488>
 8233678:	10c40060 	cmpeqi	r3,r2,4097
 823367c:	18005f1e 	bne	r3,zero,82337fc <sogetopt+0x22c>
 8233680:	10c40088 	cmpgei	r3,r2,4098
 8233684:	1800631e 	bne	r3,zero,8233814 <sogetopt+0x244>
 8233688:	10808020 	cmpeqi	r2,r2,512
 823368c:	1000471e 	bne	r2,zero,82337ac <sogetopt+0x1dc>
 8233690:	0000f106 	br	8233a58 <sogetopt+0x488>
 8233694:	10c40420 	cmpeqi	r3,r2,4112
 8233698:	18007f1e 	bne	r3,zero,8233898 <sogetopt+0x2c8>
 823369c:	10c40448 	cmpgei	r3,r2,4113
 82336a0:	1800101e 	bne	r3,zero,82336e4 <sogetopt+0x114>
 82336a4:	10c401a0 	cmpeqi	r3,r2,4102
 82336a8:	18009b1e 	bne	r3,zero,8233918 <sogetopt+0x348>
 82336ac:	10c401c8 	cmpgei	r3,r2,4103
 82336b0:	1800051e 	bne	r3,zero,82336c8 <sogetopt+0xf8>
 82336b4:	10c40120 	cmpeqi	r3,r2,4100
 82336b8:	18004a1e 	bne	r3,zero,82337e4 <sogetopt+0x214>
 82336bc:	10840160 	cmpeqi	r2,r2,4101
 82336c0:	1000901e 	bne	r2,zero,8233904 <sogetopt+0x334>
 82336c4:	0000e406 	br	8233a58 <sogetopt+0x488>
 82336c8:	10c40220 	cmpeqi	r3,r2,4104
 82336cc:	1800631e 	bne	r3,zero,823385c <sogetopt+0x28c>
 82336d0:	10c40210 	cmplti	r3,r2,4104
 82336d4:	1800691e 	bne	r3,zero,823387c <sogetopt+0x2ac>
 82336d8:	10840260 	cmpeqi	r2,r2,4105
 82336dc:	1000931e 	bne	r2,zero,823392c <sogetopt+0x35c>
 82336e0:	0000dd06 	br	8233a58 <sogetopt+0x488>
 82336e4:	10c404e0 	cmpeqi	r3,r2,4115
 82336e8:	18000e1e 	bne	r3,zero,8233724 <sogetopt+0x154>
 82336ec:	10c40508 	cmpgei	r3,r2,4116
 82336f0:	1800051e 	bne	r3,zero,8233708 <sogetopt+0x138>
 82336f4:	10c40460 	cmpeqi	r3,r2,4113
 82336f8:	18004c1e 	bne	r3,zero,823382c <sogetopt+0x25c>
 82336fc:	108404a0 	cmpeqi	r2,r2,4114
 8233700:	1000501e 	bne	r2,zero,8233844 <sogetopt+0x274>
 8233704:	0000d406 	br	8233a58 <sogetopt+0x488>
 8233708:	10c800e0 	cmpeqi	r3,r2,8195
 823370c:	1800621e 	bne	r3,zero,8233898 <sogetopt+0x2c8>
 8233710:	10c80120 	cmpeqi	r3,r2,8196
 8233714:	1800aa1e 	bne	r3,zero,82339c0 <sogetopt+0x3f0>
 8233718:	108405a0 	cmpeqi	r2,r2,4118
 823371c:	10008b1e 	bne	r2,zero,823394c <sogetopt+0x37c>
 8233720:	0000cd06 	br	8233a58 <sogetopt+0x488>
   {
   case SO_MYADDR:
      /* Get my IP address. */
      if (so->so_state & SS_ISCONNECTED)
 8233724:	e0bffd17 	ldw	r2,-12(fp)
 8233728:	1080088b 	ldhu	r2,34(r2)
 823372c:	10bfffcc 	andi	r2,r2,65535
 8233730:	1080008c 	andi	r2,r2,2
 8233734:	10000726 	beq	r2,zero,8233754 <sogetopt+0x184>
      {
         *(u_long *)val = so->so_pcb->ifp->n_ipaddr;
 8233738:	e0bffd17 	ldw	r2,-12(fp)
 823373c:	10800117 	ldw	r2,4(r2)
 8233740:	10800a17 	ldw	r2,40(r2)
 8233744:	10c00a17 	ldw	r3,40(r2)
 8233748:	e0bfff17 	ldw	r2,-4(fp)
 823374c:	10c00015 	stw	r3,0(r2)
      }
      else  /* not connected, use first iface */
         *(u_long *)val = nets[0]->n_ipaddr;
      break;
 8233750:	0000c306 	br	8233a60 <sogetopt+0x490>
      if (so->so_state & SS_ISCONNECTED)
      {
         *(u_long *)val = so->so_pcb->ifp->n_ipaddr;
      }
      else  /* not connected, use first iface */
         *(u_long *)val = nets[0]->n_ipaddr;
 8233754:	008209b4 	movhi	r2,2086
 8233758:	10b83d04 	addi	r2,r2,-7948
 823375c:	10800017 	ldw	r2,0(r2)
 8233760:	10c00a17 	ldw	r3,40(r2)
 8233764:	e0bfff17 	ldw	r2,-4(fp)
 8233768:	10c00015 	stw	r3,0(r2)
      break;
 823376c:	0000bc06 	br	8233a60 <sogetopt+0x490>
   case SO_LINGER:
      {
         struct linger *   l  =  (struct  linger *)val;
 8233770:	e0bfff17 	ldw	r2,-4(fp)
 8233774:	e0bff815 	stw	r2,-32(fp)
         l->l_onoff = so->so_options & SO_LINGER;
 8233778:	e0bffd17 	ldw	r2,-12(fp)
 823377c:	10800417 	ldw	r2,16(r2)
 8233780:	10c0200c 	andi	r3,r2,128
 8233784:	e0bff817 	ldw	r2,-32(fp)
 8233788:	10c00015 	stw	r3,0(r2)
         l->l_linger = so->so_linger;
 823378c:	e0bffd17 	ldw	r2,-12(fp)
 8233790:	1080080b 	ldhu	r2,32(r2)
 8233794:	10ffffcc 	andi	r3,r2,65535
 8233798:	18e0001c 	xori	r3,r3,32768
 823379c:	18e00004 	addi	r3,r3,-32768
 82337a0:	e0bff817 	ldw	r2,-32(fp)
 82337a4:	10c00115 	stw	r3,4(r2)
      }
      break;
 82337a8:	0000ad06 	br	8233a60 <sogetopt+0x490>
   case SO_OOBINLINE:
   case SO_DONTROUTE:
   case SO_REUSEADDR:
   case SO_BROADCAST:
   case SO_TCPSACK:
      *(int *)val = so->so_options & optname;
 82337ac:	e0bffd17 	ldw	r2,-12(fp)
 82337b0:	10c00417 	ldw	r3,16(r2)
 82337b4:	e0bffe17 	ldw	r2,-8(fp)
 82337b8:	1884703a 	and	r2,r3,r2
 82337bc:	1007883a 	mov	r3,r2
 82337c0:	e0bfff17 	ldw	r2,-4(fp)
 82337c4:	10c00015 	stw	r3,0(r2)
      break;
 82337c8:	0000a506 	br	8233a60 <sogetopt+0x490>

   case SO_SNDLOWAT:
      *(int *)val = (int)so->so_snd.sb_lowat;
 82337cc:	e0bffd17 	ldw	r2,-12(fp)
 82337d0:	10801617 	ldw	r2,88(r2)
 82337d4:	1007883a 	mov	r3,r2
 82337d8:	e0bfff17 	ldw	r2,-4(fp)
 82337dc:	10c00015 	stw	r3,0(r2)
      break;
 82337e0:	00009f06 	br	8233a60 <sogetopt+0x490>

   case SO_RCVLOWAT:
      *(int *)val = (int)so->so_rcv.sb_lowat;
 82337e4:	e0bffd17 	ldw	r2,-12(fp)
 82337e8:	10800e17 	ldw	r2,56(r2)
 82337ec:	1007883a 	mov	r3,r2
 82337f0:	e0bfff17 	ldw	r2,-4(fp)
 82337f4:	10c00015 	stw	r3,0(r2)
      break;
 82337f8:	00009906 	br	8233a60 <sogetopt+0x490>

   case SO_SNDBUF:
      *(int *)val = (int)so->so_snd.sb_hiwat;
 82337fc:	e0bffd17 	ldw	r2,-12(fp)
 8233800:	10801317 	ldw	r2,76(r2)
 8233804:	1007883a 	mov	r3,r2
 8233808:	e0bfff17 	ldw	r2,-4(fp)
 823380c:	10c00015 	stw	r3,0(r2)
      break;
 8233810:	00009306 	br	8233a60 <sogetopt+0x490>

   case SO_RCVBUF:
      *(int *)val = (int)so->so_rcv.sb_hiwat;
 8233814:	e0bffd17 	ldw	r2,-12(fp)
 8233818:	10800b17 	ldw	r2,44(r2)
 823381c:	1007883a 	mov	r3,r2
 8233820:	e0bfff17 	ldw	r2,-4(fp)
 8233824:	10c00015 	stw	r3,0(r2)
      break;
 8233828:	00008d06 	br	8233a60 <sogetopt+0x490>

   case SO_RXDATA:   /* added, JB */
      *(int *)val = (int)so->so_rcv.sb_cc;
 823382c:	e0bffd17 	ldw	r2,-12(fp)
 8233830:	10800a17 	ldw	r2,40(r2)
 8233834:	1007883a 	mov	r3,r2
 8233838:	e0bfff17 	ldw	r2,-4(fp)
 823383c:	10c00015 	stw	r3,0(r2)
      break;
 8233840:	00008706 	br	8233a60 <sogetopt+0x490>

   case SO_TXDATA:   /* added for rel 1.8 */
      *(int *)val = (int)so->so_snd.sb_cc;
 8233844:	e0bffd17 	ldw	r2,-12(fp)
 8233848:	10801217 	ldw	r2,72(r2)
 823384c:	1007883a 	mov	r3,r2
 8233850:	e0bfff17 	ldw	r2,-4(fp)
 8233854:	10c00015 	stw	r3,0(r2)
      break;
 8233858:	00008106 	br	8233a60 <sogetopt+0x490>

   case SO_TYPE:
      *(int *)val = so->so_type;
 823385c:	e0bffd17 	ldw	r2,-12(fp)
 8233860:	10800983 	ldbu	r2,38(r2)
 8233864:	10c03fcc 	andi	r3,r2,255
 8233868:	18c0201c 	xori	r3,r3,128
 823386c:	18ffe004 	addi	r3,r3,-128
 8233870:	e0bfff17 	ldw	r2,-4(fp)
 8233874:	10c00015 	stw	r3,0(r2)
      break;
 8233878:	00007906 	br	8233a60 <sogetopt+0x490>

   case SO_ERROR:
      *(int *)val = so->so_error;
 823387c:	e0bffd17 	ldw	r2,-12(fp)
 8233880:	10c00617 	ldw	r3,24(r2)
 8233884:	e0bfff17 	ldw	r2,-4(fp)
 8233888:	10c00015 	stw	r3,0(r2)
      so->so_error = 0;
 823388c:	e0bffd17 	ldw	r2,-12(fp)
 8233890:	10000615 	stw	zero,24(r2)
      break;
 8233894:	00007206 	br	8233a60 <sogetopt+0x490>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 8233898:	e0bffd17 	ldw	r2,-12(fp)
 823389c:	10800983 	ldbu	r2,38(r2)
 82338a0:	10803fcc 	andi	r2,r2,255
 82338a4:	1080201c 	xori	r2,r2,128
 82338a8:	10bfe004 	addi	r2,r2,-128
 82338ac:	10800060 	cmpeqi	r2,r2,1
 82338b0:	1000031e 	bne	r2,zero,82338c0 <sogetopt+0x2f0>
      {
         error = EINVAL;
 82338b4:	00800584 	movi	r2,22
 82338b8:	e0bff715 	stw	r2,-36(fp)
         break;
 82338bc:	00006806 	br	8233a60 <sogetopt+0x490>
      }
      inp = (struct inpcb *)(so->so_pcb);
 82338c0:	e0bffd17 	ldw	r2,-12(fp)
 82338c4:	10800117 	ldw	r2,4(r2)
 82338c8:	e0bff915 	stw	r2,-28(fp)
      tp = intotcpcb(inp);
 82338cc:	e0bff917 	ldw	r2,-28(fp)
 82338d0:	10800917 	ldw	r2,36(r2)
 82338d4:	e0bffa15 	stw	r2,-24(fp)
      if(!tp)
 82338d8:	e0bffa17 	ldw	r2,-24(fp)
 82338dc:	1000031e 	bne	r2,zero,82338ec <sogetopt+0x31c>
      {
         error = ENOTCONN;
 82338e0:	00802004 	movi	r2,128
 82338e4:	e0bff715 	stw	r2,-36(fp)
         break;
 82338e8:	00005d06 	br	8233a60 <sogetopt+0x490>
      }
      *(int *)val = tp->t_maxseg;     /* Fill in TCP MSS for current socket */
 82338ec:	e0bffa17 	ldw	r2,-24(fp)
 82338f0:	10800a0b 	ldhu	r2,40(r2)
 82338f4:	10ffffcc 	andi	r3,r2,65535
 82338f8:	e0bfff17 	ldw	r2,-4(fp)
 82338fc:	10c00015 	stw	r3,0(r2)
      break;
 8233900:	00005706 	br	8233a60 <sogetopt+0x490>
   }
 
   case SO_SNDTIMEO:
      *(short*)val = so->so_snd.sb_timeo;
 8233904:	e0bffd17 	ldw	r2,-12(fp)
 8233908:	10c0198b 	ldhu	r3,102(r2)
 823390c:	e0bfff17 	ldw	r2,-4(fp)
 8233910:	10c0000d 	sth	r3,0(r2)
      break;
 8233914:	00005206 	br	8233a60 <sogetopt+0x490>

   case SO_RCVTIMEO:
      *(short*)val = so->so_rcv.sb_timeo;
 8233918:	e0bffd17 	ldw	r2,-12(fp)
 823391c:	10c0118b 	ldhu	r3,70(r2)
 8233920:	e0bfff17 	ldw	r2,-4(fp)
 8233924:	10c0000d 	sth	r3,0(r2)
      break;
 8233928:	00004d06 	br	8233a60 <sogetopt+0x490>

   case SO_HOPCNT:
      *(int *)val = so->so_hopcnt;
 823392c:	e0bffd17 	ldw	r2,-12(fp)
 8233930:	108009c3 	ldbu	r2,39(r2)
 8233934:	10c03fcc 	andi	r3,r2,255
 8233938:	18c0201c 	xori	r3,r3,128
 823393c:	18ffe004 	addi	r3,r3,-128
 8233940:	e0bfff17 	ldw	r2,-4(fp)
 8233944:	10c00015 	stw	r3,0(r2)
      break;
 8233948:	00004506 	br	8233a60 <sogetopt+0x490>

   case SO_NONBLOCK:    /* get blocking mode according to val */
      /* if the non-blocking I/O bit is set in the state */
      if (so->so_state & SS_NBIO)
 823394c:	e0bffd17 	ldw	r2,-12(fp)
 8233950:	1080088b 	ldhu	r2,34(r2)
 8233954:	10bfffcc 	andi	r2,r2,65535
 8233958:	1080400c 	andi	r2,r2,256
 823395c:	10000426 	beq	r2,zero,8233970 <sogetopt+0x3a0>
         *(int *)val = 1;   /* return 1 in val */
 8233960:	e0bfff17 	ldw	r2,-4(fp)
 8233964:	00c00044 	movi	r3,1
 8233968:	10c00015 	stw	r3,0(r2)
      else
         *(int *)val = 0;     /* return 0 in val */
      break;
 823396c:	00003c06 	br	8233a60 <sogetopt+0x490>
   case SO_NONBLOCK:    /* get blocking mode according to val */
      /* if the non-blocking I/O bit is set in the state */
      if (so->so_state & SS_NBIO)
         *(int *)val = 1;   /* return 1 in val */
      else
         *(int *)val = 0;     /* return 0 in val */
 8233970:	e0bfff17 	ldw	r2,-4(fp)
 8233974:	10000015 	stw	zero,0(r2)
      break;
 8233978:	00003906 	br	8233a60 <sogetopt+0x490>
#ifdef IP_MULTICAST

   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      error = ip_getmoptions(optname, so, val);
 823397c:	e1bfff17 	ldw	r6,-4(fp)
 8233980:	e17ffd17 	ldw	r5,-12(fp)
 8233984:	e13ffe17 	ldw	r4,-8(fp)
 8233988:	82465d00 	call	82465d0 <ip_getmoptions>
 823398c:	e0bff715 	stw	r2,-36(fp)
      break;
 8233990:	00003306 	br	8233a60 <sogetopt+0x490>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* indicate based on header-include flag in socket state */
      if (so->so_options & SO_HDRINCL)
 8233994:	e0bffd17 	ldw	r2,-12(fp)
 8233998:	10800417 	ldw	r2,16(r2)
 823399c:	1088000c 	andi	r2,r2,8192
 82339a0:	10000426 	beq	r2,zero,82339b4 <sogetopt+0x3e4>
         *(int *)val = 1;
 82339a4:	e0bfff17 	ldw	r2,-4(fp)
 82339a8:	00c00044 	movi	r3,1
 82339ac:	10c00015 	stw	r3,0(r2)
      else
         *(int *)val = 0;
      break;
 82339b0:	00002b06 	br	8233a60 <sogetopt+0x490>
   case IP_HDRINCL:
      /* indicate based on header-include flag in socket state */
      if (so->so_options & SO_HDRINCL)
         *(int *)val = 1;
      else
         *(int *)val = 0;
 82339b4:	e0bfff17 	ldw	r2,-4(fp)
 82339b8:	10000015 	stw	zero,0(r2)
      break;
 82339bc:	00002806 	br	8233a60 <sogetopt+0x490>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 82339c0:	e0bffd17 	ldw	r2,-12(fp)
 82339c4:	10800983 	ldbu	r2,38(r2)
 82339c8:	10803fcc 	andi	r2,r2,255
 82339cc:	1080201c 	xori	r2,r2,128
 82339d0:	10bfe004 	addi	r2,r2,-128
 82339d4:	10800060 	cmpeqi	r2,r2,1
 82339d8:	1000031e 	bne	r2,zero,82339e8 <sogetopt+0x418>
      {
         error = EINVAL;
 82339dc:	00800584 	movi	r2,22
 82339e0:	e0bff715 	stw	r2,-36(fp)
         break;
 82339e4:	00001e06 	br	8233a60 <sogetopt+0x490>
      }
      inp = (struct inpcb *)(so->so_pcb);
 82339e8:	e0bffd17 	ldw	r2,-12(fp)
 82339ec:	10800117 	ldw	r2,4(r2)
 82339f0:	e0bffb15 	stw	r2,-20(fp)
      tp = intotcpcb(inp);
 82339f4:	e0bffb17 	ldw	r2,-20(fp)
 82339f8:	10800917 	ldw	r2,36(r2)
 82339fc:	e0bffc15 	stw	r2,-16(fp)
      if (!tp)
 8233a00:	e0bffc17 	ldw	r2,-16(fp)
 8233a04:	1000031e 	bne	r2,zero,8233a14 <sogetopt+0x444>
      {
         error = ENOTCONN;
 8233a08:	00802004 	movi	r2,128
 8233a0c:	e0bff715 	stw	r2,-36(fp)
         break;
 8233a10:	00001306 	br	8233a60 <sogetopt+0x490>
      }
      /* try to make sure that the argument pointer is valid */
      if (val == NULL)
 8233a14:	e0bfff17 	ldw	r2,-4(fp)
 8233a18:	1000031e 	bne	r2,zero,8233a28 <sogetopt+0x458>
      {
         error = ENP_PARAM;
 8233a1c:	00bffd84 	movi	r2,-10
 8233a20:	e0bff715 	stw	r2,-36(fp)
         break;
 8233a24:	00000e06 	br	8233a60 <sogetopt+0x490>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (tp->t_flags & TF_NODELAY)
 8233a28:	e0bffc17 	ldw	r2,-16(fp)
 8233a2c:	10800b0b 	ldhu	r2,44(r2)
 8233a30:	10bfffcc 	andi	r2,r2,65535
 8233a34:	1080010c 	andi	r2,r2,4
 8233a38:	10000426 	beq	r2,zero,8233a4c <sogetopt+0x47c>
         *(int *)val = 1;  /* Nagle Algorithm is Enabled */
 8233a3c:	e0bfff17 	ldw	r2,-4(fp)
 8233a40:	00c00044 	movi	r3,1
 8233a44:	10c00015 	stw	r3,0(r2)
      else
         *(int *)val = 0;  /* Nagle Algorithm is NOT Enabled */

      break;
 8233a48:	00000506 	br	8233a60 <sogetopt+0x490>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (tp->t_flags & TF_NODELAY)
         *(int *)val = 1;  /* Nagle Algorithm is Enabled */
      else
         *(int *)val = 0;  /* Nagle Algorithm is NOT Enabled */
 8233a4c:	e0bfff17 	ldw	r2,-4(fp)
 8233a50:	10000015 	stw	zero,0(r2)

      break;
 8233a54:	00000206 	br	8233a60 <sogetopt+0x490>
   }

   default:
      return ENOPROTOOPT;
 8233a58:	00801b44 	movi	r2,109
 8233a5c:	00000106 	br	8233a64 <sogetopt+0x494>
   }
   return error;     /* no error */
 8233a60:	e0bff717 	ldw	r2,-36(fp)
}
 8233a64:	e037883a 	mov	sp,fp
 8233a68:	dfc00117 	ldw	ra,4(sp)
 8233a6c:	df000017 	ldw	fp,0(sp)
 8233a70:	dec00204 	addi	sp,sp,8
 8233a74:	f800283a 	ret

08233a78 <sohasoutofband>:
 * RETURNS: 
 */

void
sohasoutofband(struct socket * so)
{
 8233a78:	defffd04 	addi	sp,sp,-12
 8233a7c:	dfc00215 	stw	ra,8(sp)
 8233a80:	df000115 	stw	fp,4(sp)
 8233a84:	df000104 	addi	fp,sp,4
 8233a88:	e13fff15 	stw	r4,-4(fp)
   so->so_error = EHAVEOOB;   /* WILL be picked up by the socket */
 8233a8c:	e0bfff17 	ldw	r2,-4(fp)
 8233a90:	00c03644 	movi	r3,217
 8233a94:	10c00615 	stw	r3,24(r2)
   sorwakeup (so);
 8233a98:	e0bfff17 	ldw	r2,-4(fp)
 8233a9c:	10800a04 	addi	r2,r2,40
 8233aa0:	100b883a 	mov	r5,r2
 8233aa4:	e13fff17 	ldw	r4,-4(fp)
 8233aa8:	82342a00 	call	82342a0 <sbwakeup>
}
 8233aac:	0001883a 	nop
 8233ab0:	e037883a 	mov	sp,fp
 8233ab4:	dfc00117 	ldw	ra,4(sp)
 8233ab8:	df000017 	ldw	fp,0(sp)
 8233abc:	dec00204 	addi	sp,sp,8
 8233ac0:	f800283a 	ret

08233ac4 <soisconnecting>:
 * RETURNS: 
 */

void
soisconnecting(struct socket * so)
{
 8233ac4:	defffd04 	addi	sp,sp,-12
 8233ac8:	dfc00215 	stw	ra,8(sp)
 8233acc:	df000115 	stw	fp,4(sp)
 8233ad0:	df000104 	addi	fp,sp,4
 8233ad4:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~(SS_ISCONNECTED|SS_ISDISCONNECTING);
 8233ad8:	e0bfff17 	ldw	r2,-4(fp)
 8233adc:	10c0088b 	ldhu	r3,34(r2)
 8233ae0:	00bffd44 	movi	r2,-11
 8233ae4:	1884703a 	and	r2,r3,r2
 8233ae8:	1007883a 	mov	r3,r2
 8233aec:	e0bfff17 	ldw	r2,-4(fp)
 8233af0:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTING;
 8233af4:	e0bfff17 	ldw	r2,-4(fp)
 8233af8:	1080088b 	ldhu	r2,34(r2)
 8233afc:	10800114 	ori	r2,r2,4
 8233b00:	1007883a 	mov	r3,r2
 8233b04:	e0bfff17 	ldw	r2,-4(fp)
 8233b08:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 8233b0c:	e0bfff17 	ldw	r2,-4(fp)
 8233b10:	10800904 	addi	r2,r2,36
 8233b14:	1009883a 	mov	r4,r2
 8233b18:	82297040 	call	8229704 <tcp_wakeup>
}
 8233b1c:	0001883a 	nop
 8233b20:	e037883a 	mov	sp,fp
 8233b24:	dfc00117 	ldw	ra,4(sp)
 8233b28:	df000017 	ldw	fp,0(sp)
 8233b2c:	dec00204 	addi	sp,sp,8
 8233b30:	f800283a 	ret

08233b34 <soisconnected>:
 * RETURNS: 
 */

void
soisconnected(struct socket * so)
{
 8233b34:	defffc04 	addi	sp,sp,-16
 8233b38:	dfc00315 	stw	ra,12(sp)
 8233b3c:	df000215 	stw	fp,8(sp)
 8233b40:	df000204 	addi	fp,sp,8
 8233b44:	e13fff15 	stw	r4,-4(fp)
   struct socket *   head  =  so->so_head;
 8233b48:	e0bfff17 	ldw	r2,-4(fp)
 8233b4c:	10801b17 	ldw	r2,108(r2)
 8233b50:	e0bffe15 	stw	r2,-8(fp)

   if (head) 
 8233b54:	e0bffe17 	ldw	r2,-8(fp)
 8233b58:	10001426 	beq	r2,zero,8233bac <soisconnected+0x78>
   {
      if (soqremque(so, 0) == 0)
 8233b5c:	000b883a 	mov	r5,zero
 8233b60:	e13fff17 	ldw	r4,-4(fp)
 8233b64:	82340400 	call	8234040 <soqremque>
 8233b68:	1000031e 	bne	r2,zero,8233b78 <soisconnected+0x44>
         panic("soisconnected");
 8233b6c:	01020974 	movhi	r4,2085
 8233b70:	2103ac04 	addi	r4,r4,3760
 8233b74:	8228ca40 	call	8228ca4 <panic>
      soqinsque(head, so, 1);
 8233b78:	01800044 	movi	r6,1
 8233b7c:	e17fff17 	ldw	r5,-4(fp)
 8233b80:	e13ffe17 	ldw	r4,-8(fp)
 8233b84:	8233f940 	call	8233f94 <soqinsque>
      sorwakeup(head);
 8233b88:	e0bffe17 	ldw	r2,-8(fp)
 8233b8c:	10800a04 	addi	r2,r2,40
 8233b90:	100b883a 	mov	r5,r2
 8233b94:	e13ffe17 	ldw	r4,-8(fp)
 8233b98:	82342a00 	call	82342a0 <sbwakeup>
      tcp_wakeup ((char *)&head->so_timeo);
 8233b9c:	e0bffe17 	ldw	r2,-8(fp)
 8233ba0:	10800904 	addi	r2,r2,36
 8233ba4:	1009883a 	mov	r4,r2
 8233ba8:	82297040 	call	8229704 <tcp_wakeup>
   }

   so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 8233bac:	e0bfff17 	ldw	r2,-4(fp)
 8233bb0:	10c0088b 	ldhu	r3,34(r2)
 8233bb4:	00bffcc4 	movi	r2,-13
 8233bb8:	1884703a 	and	r2,r3,r2
 8233bbc:	1007883a 	mov	r3,r2
 8233bc0:	e0bfff17 	ldw	r2,-4(fp)
 8233bc4:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTED;
 8233bc8:	e0bfff17 	ldw	r2,-4(fp)
 8233bcc:	1080088b 	ldhu	r2,34(r2)
 8233bd0:	10800094 	ori	r2,r2,2
 8233bd4:	1007883a 	mov	r3,r2
 8233bd8:	e0bfff17 	ldw	r2,-4(fp)
 8233bdc:	10c0088d 	sth	r3,34(r2)
   so->so_error = 0;
 8233be0:	e0bfff17 	ldw	r2,-4(fp)
 8233be4:	10000615 	stw	zero,24(r2)
   tcp_wakeup  ((char *)&so->so_timeo);
 8233be8:	e0bfff17 	ldw	r2,-4(fp)
 8233bec:	10800904 	addi	r2,r2,36
 8233bf0:	1009883a 	mov	r4,r2
 8233bf4:	82297040 	call	8229704 <tcp_wakeup>
   sorwakeup (so);
 8233bf8:	e0bfff17 	ldw	r2,-4(fp)
 8233bfc:	10800a04 	addi	r2,r2,40
 8233c00:	100b883a 	mov	r5,r2
 8233c04:	e13fff17 	ldw	r4,-4(fp)
 8233c08:	82342a00 	call	82342a0 <sbwakeup>
   sowwakeup (so);
 8233c0c:	e0bfff17 	ldw	r2,-4(fp)
 8233c10:	10801204 	addi	r2,r2,72
 8233c14:	100b883a 	mov	r5,r2
 8233c18:	e13fff17 	ldw	r4,-4(fp)
 8233c1c:	82342a00 	call	82342a0 <sbwakeup>
}
 8233c20:	0001883a 	nop
 8233c24:	e037883a 	mov	sp,fp
 8233c28:	dfc00117 	ldw	ra,4(sp)
 8233c2c:	df000017 	ldw	fp,0(sp)
 8233c30:	dec00204 	addi	sp,sp,8
 8233c34:	f800283a 	ret

08233c38 <soisdisconnecting>:
 * RETURNS: 
 */

void
soisdisconnecting(struct socket * so)
{
 8233c38:	defffd04 	addi	sp,sp,-12
 8233c3c:	dfc00215 	stw	ra,8(sp)
 8233c40:	df000115 	stw	fp,4(sp)
 8233c44:	df000104 	addi	fp,sp,4
 8233c48:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~SS_ISCONNECTING;
 8233c4c:	e0bfff17 	ldw	r2,-4(fp)
 8233c50:	10c0088b 	ldhu	r3,34(r2)
 8233c54:	00bffec4 	movi	r2,-5
 8233c58:	1884703a 	and	r2,r3,r2
 8233c5c:	1007883a 	mov	r3,r2
 8233c60:	e0bfff17 	ldw	r2,-4(fp)
 8233c64:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_ISDISCONNECTING|SS_CANTRCVMORE|SS_CANTSENDMORE);
 8233c68:	e0bfff17 	ldw	r2,-4(fp)
 8233c6c:	1080088b 	ldhu	r2,34(r2)
 8233c70:	10800e14 	ori	r2,r2,56
 8233c74:	1007883a 	mov	r3,r2
 8233c78:	e0bfff17 	ldw	r2,-4(fp)
 8233c7c:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup  ((char *)&so->so_timeo);   
 8233c80:	e0bfff17 	ldw	r2,-4(fp)
 8233c84:	10800904 	addi	r2,r2,36
 8233c88:	1009883a 	mov	r4,r2
 8233c8c:	82297040 	call	8229704 <tcp_wakeup>
   sowwakeup (so);
 8233c90:	e0bfff17 	ldw	r2,-4(fp)
 8233c94:	10801204 	addi	r2,r2,72
 8233c98:	100b883a 	mov	r5,r2
 8233c9c:	e13fff17 	ldw	r4,-4(fp)
 8233ca0:	82342a00 	call	82342a0 <sbwakeup>
   sorwakeup (so);
 8233ca4:	e0bfff17 	ldw	r2,-4(fp)
 8233ca8:	10800a04 	addi	r2,r2,40
 8233cac:	100b883a 	mov	r5,r2
 8233cb0:	e13fff17 	ldw	r4,-4(fp)
 8233cb4:	82342a00 	call	82342a0 <sbwakeup>
}
 8233cb8:	0001883a 	nop
 8233cbc:	e037883a 	mov	sp,fp
 8233cc0:	dfc00117 	ldw	ra,4(sp)
 8233cc4:	df000017 	ldw	fp,0(sp)
 8233cc8:	dec00204 	addi	sp,sp,8
 8233ccc:	f800283a 	ret

08233cd0 <soisdisconnected>:
 * RETURNS: 
 */

void
soisdisconnected(struct socket * so)
{
 8233cd0:	defffd04 	addi	sp,sp,-12
 8233cd4:	dfc00215 	stw	ra,8(sp)
 8233cd8:	df000115 	stw	fp,4(sp)
 8233cdc:	df000104 	addi	fp,sp,4
 8233ce0:	e13fff15 	stw	r4,-4(fp)
   if (so->so_state & SS_ISCONNECTING)
 8233ce4:	e0bfff17 	ldw	r2,-4(fp)
 8233ce8:	1080088b 	ldhu	r2,34(r2)
 8233cec:	10bfffcc 	andi	r2,r2,65535
 8233cf0:	1080010c 	andi	r2,r2,4
 8233cf4:	10000626 	beq	r2,zero,8233d10 <soisdisconnected+0x40>
      so->so_state |= SS_WASCONNECTING;
 8233cf8:	e0bfff17 	ldw	r2,-4(fp)
 8233cfc:	1080088b 	ldhu	r2,34(r2)
 8233d00:	10880014 	ori	r2,r2,8192
 8233d04:	1007883a 	mov	r3,r2
 8233d08:	e0bfff17 	ldw	r2,-4(fp)
 8233d0c:	10c0088d 	sth	r3,34(r2)
   so->so_state &= ~(SS_ISCONNECTING|SS_ISCONNECTED|SS_ISDISCONNECTING);
 8233d10:	e0bfff17 	ldw	r2,-4(fp)
 8233d14:	10c0088b 	ldhu	r3,34(r2)
 8233d18:	00bffc44 	movi	r2,-15
 8233d1c:	1884703a 	and	r2,r3,r2
 8233d20:	1007883a 	mov	r3,r2
 8233d24:	e0bfff17 	ldw	r2,-4(fp)
 8233d28:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_CANTRCVMORE|SS_CANTSENDMORE);
 8233d2c:	e0bfff17 	ldw	r2,-4(fp)
 8233d30:	1080088b 	ldhu	r2,34(r2)
 8233d34:	10800c14 	ori	r2,r2,48
 8233d38:	1007883a 	mov	r3,r2
 8233d3c:	e0bfff17 	ldw	r2,-4(fp)
 8233d40:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 8233d44:	e0bfff17 	ldw	r2,-4(fp)
 8233d48:	10800904 	addi	r2,r2,36
 8233d4c:	1009883a 	mov	r4,r2
 8233d50:	82297040 	call	8229704 <tcp_wakeup>
   sowwakeup (so);
 8233d54:	e0bfff17 	ldw	r2,-4(fp)
 8233d58:	10801204 	addi	r2,r2,72
 8233d5c:	100b883a 	mov	r5,r2
 8233d60:	e13fff17 	ldw	r4,-4(fp)
 8233d64:	82342a00 	call	82342a0 <sbwakeup>
   sorwakeup (so);
 8233d68:	e0bfff17 	ldw	r2,-4(fp)
 8233d6c:	10800a04 	addi	r2,r2,40
 8233d70:	100b883a 	mov	r5,r2
 8233d74:	e13fff17 	ldw	r4,-4(fp)
 8233d78:	82342a00 	call	82342a0 <sbwakeup>
}
 8233d7c:	0001883a 	nop
 8233d80:	e037883a 	mov	sp,fp
 8233d84:	dfc00117 	ldw	ra,4(sp)
 8233d88:	df000017 	ldw	fp,0(sp)
 8233d8c:	dec00204 	addi	sp,sp,8
 8233d90:	f800283a 	ret

08233d94 <sonewconn>:
 * RETURNS: 
 */

struct socket *   
sonewconn(struct socket * head)
{
 8233d94:	defffb04 	addi	sp,sp,-20
 8233d98:	dfc00415 	stw	ra,16(sp)
 8233d9c:	df000315 	stw	fp,12(sp)
 8233da0:	df000304 	addi	fp,sp,12
 8233da4:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so;
   int rc;  

   if (head->so_qlen + head->so_q0len > 3 * head->so_qlimit / 2)
 8233da8:	e0bfff17 	ldw	r2,-4(fp)
 8233dac:	10801e43 	ldbu	r2,121(r2)
 8233db0:	10c03fcc 	andi	r3,r2,255
 8233db4:	18c0201c 	xori	r3,r3,128
 8233db8:	18ffe004 	addi	r3,r3,-128
 8233dbc:	e0bfff17 	ldw	r2,-4(fp)
 8233dc0:	10801e03 	ldbu	r2,120(r2)
 8233dc4:	10803fcc 	andi	r2,r2,255
 8233dc8:	1080201c 	xori	r2,r2,128
 8233dcc:	10bfe004 	addi	r2,r2,-128
 8233dd0:	1889883a 	add	r4,r3,r2
 8233dd4:	e0bfff17 	ldw	r2,-4(fp)
 8233dd8:	10801e83 	ldbu	r2,122(r2)
 8233ddc:	10c03fcc 	andi	r3,r2,255
 8233de0:	18c0201c 	xori	r3,r3,128
 8233de4:	18ffe004 	addi	r3,r3,-128
 8233de8:	1805883a 	mov	r2,r3
 8233dec:	1085883a 	add	r2,r2,r2
 8233df0:	10c5883a 	add	r2,r2,r3
 8233df4:	1006d7fa 	srli	r3,r2,31
 8233df8:	1885883a 	add	r2,r3,r2
 8233dfc:	1005d07a 	srai	r2,r2,1
 8233e00:	11005b16 	blt	r2,r4,8233f70 <sonewconn+0x1dc>
      goto bad;
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 8233e04:	01002104 	movi	r4,132
 8233e08:	822e1c80 	call	822e1c8 <npalloc>
 8233e0c:	e0bffd15 	stw	r2,-12(fp)
 8233e10:	e0bffd17 	ldw	r2,-12(fp)
 8233e14:	10005826 	beq	r2,zero,8233f78 <sonewconn+0x1e4>
      goto bad;
   so->next = NULL;
 8233e18:	e0bffd17 	ldw	r2,-12(fp)
 8233e1c:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);      /* Place newly created socket in a queue */
 8233e20:	e17ffd17 	ldw	r5,-12(fp)
 8233e24:	010209b4 	movhi	r4,2086
 8233e28:	21397a04 	addi	r4,r4,-6680
 8233e2c:	822cfd80 	call	822cfd8 <putq>
   so->so_type = head->so_type;
 8233e30:	e0bfff17 	ldw	r2,-4(fp)
 8233e34:	10c00983 	ldbu	r3,38(r2)
 8233e38:	e0bffd17 	ldw	r2,-12(fp)
 8233e3c:	10c00985 	stb	r3,38(r2)
   so->so_options = head->so_options &~ (unshort)SO_ACCEPTCONN;
 8233e40:	e0bfff17 	ldw	r2,-4(fp)
 8233e44:	10c00417 	ldw	r3,16(r2)
 8233e48:	00bfff44 	movi	r2,-3
 8233e4c:	1886703a 	and	r3,r3,r2
 8233e50:	e0bffd17 	ldw	r2,-12(fp)
 8233e54:	10c00415 	stw	r3,16(r2)
   so->so_linger = head->so_linger;
 8233e58:	e0bfff17 	ldw	r2,-4(fp)
 8233e5c:	10c0080b 	ldhu	r3,32(r2)
 8233e60:	e0bffd17 	ldw	r2,-12(fp)
 8233e64:	10c0080d 	sth	r3,32(r2)
   so->so_state = head->so_state | (unshort)SS_NOFDREF;
 8233e68:	e0bfff17 	ldw	r2,-4(fp)
 8233e6c:	1080088b 	ldhu	r2,34(r2)
 8233e70:	10800054 	ori	r2,r2,1
 8233e74:	1007883a 	mov	r3,r2
 8233e78:	e0bffd17 	ldw	r2,-12(fp)
 8233e7c:	10c0088d 	sth	r3,34(r2)
   so->so_proto = head->so_proto;
 8233e80:	e0bfff17 	ldw	r2,-4(fp)
 8233e84:	10c00217 	ldw	r3,8(r2)
 8233e88:	e0bffd17 	ldw	r2,-12(fp)
 8233e8c:	10c00215 	stw	r3,8(r2)
   so->so_timeo = head->so_timeo;
 8233e90:	e0bfff17 	ldw	r2,-4(fp)
 8233e94:	10c0090b 	ldhu	r3,36(r2)
 8233e98:	e0bffd17 	ldw	r2,-12(fp)
 8233e9c:	10c0090d 	sth	r3,36(r2)
   so->so_rcv.sb_hiwat = (u_int)tcp_recvspace;
 8233ea0:	d0e04117 	ldw	r3,-32508(gp)
 8233ea4:	e0bffd17 	ldw	r2,-12(fp)
 8233ea8:	10c00b15 	stw	r3,44(r2)
   so->so_snd.sb_hiwat = (u_int)tcp_sendspace;
 8233eac:	d0e04017 	ldw	r3,-32512(gp)
 8233eb0:	e0bffd17 	ldw	r2,-12(fp)
 8233eb4:	10c01315 	stw	r3,76(r2)
   soqinsque (head, so, 0);
 8233eb8:	000d883a 	mov	r6,zero
 8233ebc:	e17ffd17 	ldw	r5,-12(fp)
 8233ec0:	e13fff17 	ldw	r4,-4(fp)
 8233ec4:	8233f940 	call	8233f94 <soqinsque>
   so->so_req = PRU_ATTACH;
 8233ec8:	e0bffd17 	ldw	r2,-12(fp)
 8233ecc:	10000715 	stw	zero,28(r2)
   so->so_domain = head->so_domain;
 8233ed0:	e0bfff17 	ldw	r2,-4(fp)
 8233ed4:	10c00517 	ldw	r3,20(r2)
 8233ed8:	e0bffd17 	ldw	r2,-12(fp)
 8233edc:	10c00515 	stw	r3,20(r2)

   if ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0))
 8233ee0:	e0bffd17 	ldw	r2,-12(fp)
 8233ee4:	10800217 	ldw	r2,8(r2)
 8233ee8:	10800317 	ldw	r2,12(r2)
 8233eec:	000d883a 	mov	r6,zero
 8233ef0:	000b883a 	mov	r5,zero
 8233ef4:	e13ffd17 	ldw	r4,-12(fp)
 8233ef8:	103ee83a 	callr	r2
 8233efc:	10000f1e 	bne	r2,zero,8233f3c <sonewconn+0x1a8>
      goto bad2;
   if (so_evtmap)
 8233f00:	d0a0ce03 	ldbu	r2,-31944(gp)
 8233f04:	10803fcc 	andi	r2,r2,255
 8233f08:	10000a26 	beq	r2,zero,8233f34 <sonewconn+0x1a0>
   {
      rc = (*so_evtmap_create) (so);                       
 8233f0c:	d0a0cc17 	ldw	r2,-31952(gp)
 8233f10:	e13ffd17 	ldw	r4,-12(fp)
 8233f14:	103ee83a 	callr	r2
 8233f18:	e0bffe15 	stw	r2,-8(fp)
      if (rc != 0) goto bad2;
 8233f1c:	e0bffe17 	ldw	r2,-8(fp)
 8233f20:	1000081e 	bne	r2,zero,8233f44 <sonewconn+0x1b0>
      so->owner = head->owner;
 8233f24:	e0bfff17 	ldw	r2,-4(fp)
 8233f28:	10c02003 	ldbu	r3,128(r2)
 8233f2c:	e0bffd17 	ldw	r2,-12(fp)
 8233f30:	10c02005 	stb	r3,128(r2)
   }
   return (so);
 8233f34:	e0bffd17 	ldw	r2,-12(fp)
 8233f38:	00001106 	br	8233f80 <sonewconn+0x1ec>
   soqinsque (head, so, 0);
   so->so_req = PRU_ATTACH;
   so->so_domain = head->so_domain;

   if ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0))
      goto bad2;
 8233f3c:	0001883a 	nop
 8233f40:	00000106 	br	8233f48 <sonewconn+0x1b4>
   if (so_evtmap)
   {
      rc = (*so_evtmap_create) (so);                       
      if (rc != 0) goto bad2;
 8233f44:	0001883a 	nop
      so->owner = head->owner;
   }
   return (so);
   
bad2:
   (void) soqremque (so, 0);
 8233f48:	000b883a 	mov	r5,zero
 8233f4c:	e13ffd17 	ldw	r4,-12(fp)
 8233f50:	82340400 	call	8234040 <soqremque>
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 8233f54:	e17ffd17 	ldw	r5,-12(fp)
 8233f58:	010209b4 	movhi	r4,2086
 8233f5c:	21397a04 	addi	r4,r4,-6680
 8233f60:	822d0880 	call	822d088 <qdel>
   SOC_FREE(so);  /* Free the socket structure */
 8233f64:	e13ffd17 	ldw	r4,-12(fp)
 8233f68:	822e1fc0 	call	822e1fc <npfree>
 8233f6c:	00000306 	br	8233f7c <sonewconn+0x1e8>
{
   struct socket *   so;
   int rc;  

   if (head->so_qlen + head->so_q0len > 3 * head->so_qlimit / 2)
      goto bad;
 8233f70:	0001883a 	nop
 8233f74:	00000106 	br	8233f7c <sonewconn+0x1e8>
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
      goto bad;
 8233f78:	0001883a 	nop
bad2:
   (void) soqremque (so, 0);
   qdel(&soq, so);   /* Delete the socket entry from the queue */
   SOC_FREE(so);  /* Free the socket structure */
bad:
   return ((struct socket *)0);
 8233f7c:	0005883a 	mov	r2,zero
}
 8233f80:	e037883a 	mov	sp,fp
 8233f84:	dfc00117 	ldw	ra,4(sp)
 8233f88:	df000017 	ldw	fp,0(sp)
 8233f8c:	dec00204 	addi	sp,sp,8
 8233f90:	f800283a 	ret

08233f94 <soqinsque>:

void
soqinsque(struct socket * head, 
   struct socket *   so,
   int   q)
{
 8233f94:	defffc04 	addi	sp,sp,-16
 8233f98:	df000315 	stw	fp,12(sp)
 8233f9c:	df000304 	addi	fp,sp,12
 8233fa0:	e13ffd15 	stw	r4,-12(fp)
 8233fa4:	e17ffe15 	stw	r5,-8(fp)
 8233fa8:	e1bfff15 	stw	r6,-4(fp)
   so->so_head = head;
 8233fac:	e0bffe17 	ldw	r2,-8(fp)
 8233fb0:	e0fffd17 	ldw	r3,-12(fp)
 8233fb4:	10c01b15 	stw	r3,108(r2)
   if (q == 0) 
 8233fb8:	e0bfff17 	ldw	r2,-4(fp)
 8233fbc:	10000e1e 	bne	r2,zero,8233ff8 <soqinsque+0x64>
   {
      head->so_q0len++;
 8233fc0:	e0bffd17 	ldw	r2,-12(fp)
 8233fc4:	10801e03 	ldbu	r2,120(r2)
 8233fc8:	10800044 	addi	r2,r2,1
 8233fcc:	1007883a 	mov	r3,r2
 8233fd0:	e0bffd17 	ldw	r2,-12(fp)
 8233fd4:	10c01e05 	stb	r3,120(r2)
      so->so_q0 = head->so_q0;
 8233fd8:	e0bffd17 	ldw	r2,-12(fp)
 8233fdc:	10c01c17 	ldw	r3,112(r2)
 8233fe0:	e0bffe17 	ldw	r2,-8(fp)
 8233fe4:	10c01c15 	stw	r3,112(r2)
      head->so_q0 = so;
 8233fe8:	e0bffd17 	ldw	r2,-12(fp)
 8233fec:	e0fffe17 	ldw	r3,-8(fp)
 8233ff0:	10c01c15 	stw	r3,112(r2)
   {
      head->so_qlen++;
      so->so_q = head->so_q;
      head->so_q = so;
   }
}
 8233ff4:	00000d06 	br	823402c <soqinsque+0x98>
      head->so_q0len++;
      so->so_q0 = head->so_q0;
      head->so_q0 = so;
   } else 
   {
      head->so_qlen++;
 8233ff8:	e0bffd17 	ldw	r2,-12(fp)
 8233ffc:	10801e43 	ldbu	r2,121(r2)
 8234000:	10800044 	addi	r2,r2,1
 8234004:	1007883a 	mov	r3,r2
 8234008:	e0bffd17 	ldw	r2,-12(fp)
 823400c:	10c01e45 	stb	r3,121(r2)
      so->so_q = head->so_q;
 8234010:	e0bffd17 	ldw	r2,-12(fp)
 8234014:	10c01d17 	ldw	r3,116(r2)
 8234018:	e0bffe17 	ldw	r2,-8(fp)
 823401c:	10c01d15 	stw	r3,116(r2)
      head->so_q = so;
 8234020:	e0bffd17 	ldw	r2,-12(fp)
 8234024:	e0fffe17 	ldw	r3,-8(fp)
 8234028:	10c01d15 	stw	r3,116(r2)
   }
}
 823402c:	0001883a 	nop
 8234030:	e037883a 	mov	sp,fp
 8234034:	df000017 	ldw	fp,0(sp)
 8234038:	dec00104 	addi	sp,sp,4
 823403c:	f800283a 	ret

08234040 <soqremque>:
 * RETURNS: 
 */

int
soqremque(struct socket * so, int q)
{
 8234040:	defffa04 	addi	sp,sp,-24
 8234044:	df000515 	stw	fp,20(sp)
 8234048:	df000504 	addi	fp,sp,20
 823404c:	e13ffe15 	stw	r4,-8(fp)
 8234050:	e17fff15 	stw	r5,-4(fp)
   struct socket *   head, *  prev, *  next;

   head = so->so_head;
 8234054:	e0bffe17 	ldw	r2,-8(fp)
 8234058:	10801b17 	ldw	r2,108(r2)
 823405c:	e0bffc15 	stw	r2,-16(fp)
   prev = head;
 8234060:	e0bffc17 	ldw	r2,-16(fp)
 8234064:	e0bffb15 	stw	r2,-20(fp)
   for (;;) 
   {
      next = q ? prev->so_q : prev->so_q0;
 8234068:	e0bfff17 	ldw	r2,-4(fp)
 823406c:	10000326 	beq	r2,zero,823407c <soqremque+0x3c>
 8234070:	e0bffb17 	ldw	r2,-20(fp)
 8234074:	10801d17 	ldw	r2,116(r2)
 8234078:	00000206 	br	8234084 <soqremque+0x44>
 823407c:	e0bffb17 	ldw	r2,-20(fp)
 8234080:	10801c17 	ldw	r2,112(r2)
 8234084:	e0bffd15 	stw	r2,-12(fp)
      if (next == so)
 8234088:	e0fffd17 	ldw	r3,-12(fp)
 823408c:	e0bffe17 	ldw	r2,-8(fp)
 8234090:	18800826 	beq	r3,r2,82340b4 <soqremque+0x74>
         break;
      if (next == head)
 8234094:	e0fffd17 	ldw	r3,-12(fp)
 8234098:	e0bffc17 	ldw	r2,-16(fp)
 823409c:	1880021e 	bne	r3,r2,82340a8 <soqremque+0x68>
         return (0);
 82340a0:	0005883a 	mov	r2,zero
 82340a4:	00002406 	br	8234138 <soqremque+0xf8>
      prev = next;
 82340a8:	e0bffd17 	ldw	r2,-12(fp)
 82340ac:	e0bffb15 	stw	r2,-20(fp)
   }
 82340b0:	003fed06 	br	8234068 <soqremque+0x28>
   prev = head;
   for (;;) 
   {
      next = q ? prev->so_q : prev->so_q0;
      if (next == so)
         break;
 82340b4:	0001883a 	nop
      if (next == head)
         return (0);
      prev = next;
   }
   if (q == 0) 
 82340b8:	e0bfff17 	ldw	r2,-4(fp)
 82340bc:	10000b1e 	bne	r2,zero,82340ec <soqremque+0xac>
   {
      prev->so_q0 = next->so_q0;
 82340c0:	e0bffd17 	ldw	r2,-12(fp)
 82340c4:	10c01c17 	ldw	r3,112(r2)
 82340c8:	e0bffb17 	ldw	r2,-20(fp)
 82340cc:	10c01c15 	stw	r3,112(r2)
      head->so_q0len--;
 82340d0:	e0bffc17 	ldw	r2,-16(fp)
 82340d4:	10801e03 	ldbu	r2,120(r2)
 82340d8:	10bfffc4 	addi	r2,r2,-1
 82340dc:	1007883a 	mov	r3,r2
 82340e0:	e0bffc17 	ldw	r2,-16(fp)
 82340e4:	10c01e05 	stb	r3,120(r2)
 82340e8:	00000a06 	br	8234114 <soqremque+0xd4>
   } else 
   {
      prev->so_q = next->so_q;
 82340ec:	e0bffd17 	ldw	r2,-12(fp)
 82340f0:	10c01d17 	ldw	r3,116(r2)
 82340f4:	e0bffb17 	ldw	r2,-20(fp)
 82340f8:	10c01d15 	stw	r3,116(r2)
      head->so_qlen--;
 82340fc:	e0bffc17 	ldw	r2,-16(fp)
 8234100:	10801e43 	ldbu	r2,121(r2)
 8234104:	10bfffc4 	addi	r2,r2,-1
 8234108:	1007883a 	mov	r3,r2
 823410c:	e0bffc17 	ldw	r2,-16(fp)
 8234110:	10c01e45 	stb	r3,121(r2)
   }
   next->so_q0 = next->so_q = 0;
 8234114:	e0bffd17 	ldw	r2,-12(fp)
 8234118:	10001d15 	stw	zero,116(r2)
 823411c:	e0bffd17 	ldw	r2,-12(fp)
 8234120:	10c01d17 	ldw	r3,116(r2)
 8234124:	e0bffd17 	ldw	r2,-12(fp)
 8234128:	10c01c15 	stw	r3,112(r2)
   next->so_head = 0;
 823412c:	e0bffd17 	ldw	r2,-12(fp)
 8234130:	10001b15 	stw	zero,108(r2)
   return 1;
 8234134:	00800044 	movi	r2,1
}
 8234138:	e037883a 	mov	sp,fp
 823413c:	df000017 	ldw	fp,0(sp)
 8234140:	dec00104 	addi	sp,sp,4
 8234144:	f800283a 	ret

08234148 <socantsendmore>:
 * RETURNS: 
 */

void
socantsendmore(struct socket * so)
{
 8234148:	defffd04 	addi	sp,sp,-12
 823414c:	dfc00215 	stw	ra,8(sp)
 8234150:	df000115 	stw	fp,4(sp)
 8234154:	df000104 	addi	fp,sp,4
 8234158:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTSENDMORE;
 823415c:	e0bfff17 	ldw	r2,-4(fp)
 8234160:	1080088b 	ldhu	r2,34(r2)
 8234164:	10800414 	ori	r2,r2,16
 8234168:	1007883a 	mov	r3,r2
 823416c:	e0bfff17 	ldw	r2,-4(fp)
 8234170:	10c0088d 	sth	r3,34(r2)
   sowwakeup(so);
 8234174:	e0bfff17 	ldw	r2,-4(fp)
 8234178:	10801204 	addi	r2,r2,72
 823417c:	100b883a 	mov	r5,r2
 8234180:	e13fff17 	ldw	r4,-4(fp)
 8234184:	82342a00 	call	82342a0 <sbwakeup>
}
 8234188:	0001883a 	nop
 823418c:	e037883a 	mov	sp,fp
 8234190:	dfc00117 	ldw	ra,4(sp)
 8234194:	df000017 	ldw	fp,0(sp)
 8234198:	dec00204 	addi	sp,sp,8
 823419c:	f800283a 	ret

082341a0 <socantrcvmore>:
 * RETURNS: 
 */

void
socantrcvmore(struct socket * so)
{
 82341a0:	defffd04 	addi	sp,sp,-12
 82341a4:	dfc00215 	stw	ra,8(sp)
 82341a8:	df000115 	stw	fp,4(sp)
 82341ac:	df000104 	addi	fp,sp,4
 82341b0:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTRCVMORE;
 82341b4:	e0bfff17 	ldw	r2,-4(fp)
 82341b8:	1080088b 	ldhu	r2,34(r2)
 82341bc:	10800814 	ori	r2,r2,32
 82341c0:	1007883a 	mov	r3,r2
 82341c4:	e0bfff17 	ldw	r2,-4(fp)
 82341c8:	10c0088d 	sth	r3,34(r2)
   sorwakeup(so);
 82341cc:	e0bfff17 	ldw	r2,-4(fp)
 82341d0:	10800a04 	addi	r2,r2,40
 82341d4:	100b883a 	mov	r5,r2
 82341d8:	e13fff17 	ldw	r4,-4(fp)
 82341dc:	82342a00 	call	82342a0 <sbwakeup>
}
 82341e0:	0001883a 	nop
 82341e4:	e037883a 	mov	sp,fp
 82341e8:	dfc00117 	ldw	ra,4(sp)
 82341ec:	df000017 	ldw	fp,0(sp)
 82341f0:	dec00204 	addi	sp,sp,8
 82341f4:	f800283a 	ret

082341f8 <sbselqueue>:
 * RETURNS: 
 */

void
sbselqueue(struct sockbuf * sb)
{
 82341f8:	defffe04 	addi	sp,sp,-8
 82341fc:	df000115 	stw	fp,4(sp)
 8234200:	df000104 	addi	fp,sp,4
 8234204:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_SEL;
 8234208:	e0bfff17 	ldw	r2,-4(fp)
 823420c:	1080070b 	ldhu	r2,28(r2)
 8234210:	10800214 	ori	r2,r2,8
 8234214:	1007883a 	mov	r3,r2
 8234218:	e0bfff17 	ldw	r2,-4(fp)
 823421c:	10c0070d 	sth	r3,28(r2)
}
 8234220:	0001883a 	nop
 8234224:	e037883a 	mov	sp,fp
 8234228:	df000017 	ldw	fp,0(sp)
 823422c:	dec00104 	addi	sp,sp,4
 8234230:	f800283a 	ret

08234234 <sbwait>:
 * RETURNS: 
 */

void
sbwait(struct sockbuf * sb)
{
 8234234:	defffd04 	addi	sp,sp,-12
 8234238:	dfc00215 	stw	ra,8(sp)
 823423c:	df000115 	stw	fp,4(sp)
 8234240:	df000104 	addi	fp,sp,4
 8234244:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_WAIT;
 8234248:	e0bfff17 	ldw	r2,-4(fp)
 823424c:	1080070b 	ldhu	r2,28(r2)
 8234250:	10800114 	ori	r2,r2,4
 8234254:	1007883a 	mov	r3,r2
 8234258:	e0bfff17 	ldw	r2,-4(fp)
 823425c:	10c0070d 	sth	r3,28(r2)
   tcp_sleep ((char *)&sb->sb_cc);
 8234260:	e0bfff17 	ldw	r2,-4(fp)
 8234264:	1009883a 	mov	r4,r2
 8234268:	82295900 	call	8229590 <tcp_sleep>
   sb->sb_flags &= ~SB_WAIT;
 823426c:	e0bfff17 	ldw	r2,-4(fp)
 8234270:	10c0070b 	ldhu	r3,28(r2)
 8234274:	00bffec4 	movi	r2,-5
 8234278:	1884703a 	and	r2,r3,r2
 823427c:	1007883a 	mov	r3,r2
 8234280:	e0bfff17 	ldw	r2,-4(fp)
 8234284:	10c0070d 	sth	r3,28(r2)
}
 8234288:	0001883a 	nop
 823428c:	e037883a 	mov	sp,fp
 8234290:	dfc00117 	ldw	ra,4(sp)
 8234294:	df000017 	ldw	fp,0(sp)
 8234298:	dec00204 	addi	sp,sp,8
 823429c:	f800283a 	ret

082342a0 <sbwakeup>:
 * RETURNS: 
 */

void
sbwakeup(struct socket * so, struct sockbuf * sb)
{
 82342a0:	defffc04 	addi	sp,sp,-16
 82342a4:	dfc00315 	stw	ra,12(sp)
 82342a8:	df000215 	stw	fp,8(sp)
 82342ac:	df000204 	addi	fp,sp,8
 82342b0:	e13ffe15 	stw	r4,-8(fp)
 82342b4:	e17fff15 	stw	r5,-4(fp)
   if (sb->sb_flags & SB_SEL) 
 82342b8:	e0bfff17 	ldw	r2,-4(fp)
 82342bc:	1080070b 	ldhu	r2,28(r2)
 82342c0:	10bfffcc 	andi	r2,r2,65535
 82342c4:	1080020c 	andi	r2,r2,8
 82342c8:	10000a26 	beq	r2,zero,82342f4 <sbwakeup+0x54>
   {
      select_wait = 0;
 82342cc:	d020b00d 	sth	zero,-32064(gp)
#ifndef SOCK_MAP_EVENTS
      tcp_wakeup ((char *)&select_wait);
 82342d0:	d120b004 	addi	r4,gp,-32064
 82342d4:	82297040 	call	8229704 <tcp_wakeup>
#else
      tcp_wakeup2 (so->owner);
#endif      
      sb->sb_flags &= ~SB_SEL;
 82342d8:	e0bfff17 	ldw	r2,-4(fp)
 82342dc:	10c0070b 	ldhu	r3,28(r2)
 82342e0:	00bffdc4 	movi	r2,-9
 82342e4:	1884703a 	and	r2,r3,r2
 82342e8:	1007883a 	mov	r3,r2
 82342ec:	e0bfff17 	ldw	r2,-4(fp)
 82342f0:	10c0070d 	sth	r3,28(r2)
#ifdef SOCK_WAKEALWAYS  /* Always wake the socket? */
   /* Systems Like Green Hills Integrity RTOS, need to process socket
      input even if looks like no one is blocked on the socket */
   tcp_wakeup ((char *)&sb->sb_cc); /* signal wake on socket */
#else /* older BSD style code - only call tcp_wakeup if blocked */
   if (sb->sb_flags & SB_WAIT)   /* is sockbuf's WAIT flag set? */
 82342f4:	e0bfff17 	ldw	r2,-4(fp)
 82342f8:	1080070b 	ldhu	r2,28(r2)
 82342fc:	10bfffcc 	andi	r2,r2,65535
 8234300:	1080010c 	andi	r2,r2,4
 8234304:	10000326 	beq	r2,zero,8234314 <sbwakeup+0x74>
   {
      tcp_wakeup ((char *)&sb->sb_cc);   /* call port wakeup routine */
 8234308:	e0bfff17 	ldw	r2,-4(fp)
 823430c:	1009883a 	mov	r4,r2
 8234310:	82297040 	call	8229704 <tcp_wakeup>
   }
#endif   /* SOCK_WAKEALWAYS */
}
 8234314:	0001883a 	nop
 8234318:	e037883a 	mov	sp,fp
 823431c:	dfc00117 	ldw	ra,4(sp)
 8234320:	df000017 	ldw	fp,0(sp)
 8234324:	dec00204 	addi	sp,sp,8
 8234328:	f800283a 	ret

0823432c <soreserve>:

int
soreserve(struct socket * so, 
   u_long   sndcc, 
   u_long   rcvcc)
{
 823432c:	defffb04 	addi	sp,sp,-20
 8234330:	dfc00415 	stw	ra,16(sp)
 8234334:	df000315 	stw	fp,12(sp)
 8234338:	df000304 	addi	fp,sp,12
 823433c:	e13ffd15 	stw	r4,-12(fp)
 8234340:	e17ffe15 	stw	r5,-8(fp)
 8234344:	e1bfff15 	stw	r6,-4(fp)
   if (sbreserve(&so->so_snd, sndcc) == 0)
 8234348:	e0bffd17 	ldw	r2,-12(fp)
 823434c:	10801204 	addi	r2,r2,72
 8234350:	e17ffe17 	ldw	r5,-8(fp)
 8234354:	1009883a 	mov	r4,r2
 8234358:	82343b40 	call	82343b4 <sbreserve>
 823435c:	10000e26 	beq	r2,zero,8234398 <soreserve+0x6c>
      goto bad;
   if (sbreserve(&so->so_rcv, rcvcc) == 0)
 8234360:	e0bffd17 	ldw	r2,-12(fp)
 8234364:	10800a04 	addi	r2,r2,40
 8234368:	e17fff17 	ldw	r5,-4(fp)
 823436c:	1009883a 	mov	r4,r2
 8234370:	82343b40 	call	82343b4 <sbreserve>
 8234374:	10000226 	beq	r2,zero,8234380 <soreserve+0x54>
      goto bad2;
   return (0);
 8234378:	0005883a 	mov	r2,zero
 823437c:	00000806 	br	82343a0 <soreserve+0x74>
   u_long   rcvcc)
{
   if (sbreserve(&so->so_snd, sndcc) == 0)
      goto bad;
   if (sbreserve(&so->so_rcv, rcvcc) == 0)
      goto bad2;
 8234380:	0001883a 	nop
   return (0);
bad2:
   sbrelease(&so->so_snd);
 8234384:	e0bffd17 	ldw	r2,-12(fp)
 8234388:	10801204 	addi	r2,r2,72
 823438c:	1009883a 	mov	r4,r2
 8234390:	82344040 	call	8234404 <sbrelease>
 8234394:	00000106 	br	823439c <soreserve+0x70>
soreserve(struct socket * so, 
   u_long   sndcc, 
   u_long   rcvcc)
{
   if (sbreserve(&so->so_snd, sndcc) == 0)
      goto bad;
 8234398:	0001883a 	nop
      goto bad2;
   return (0);
bad2:
   sbrelease(&so->so_snd);
bad:
   return (ENOBUFS);
 823439c:	00801a44 	movi	r2,105
}
 82343a0:	e037883a 	mov	sp,fp
 82343a4:	dfc00117 	ldw	ra,4(sp)
 82343a8:	df000017 	ldw	fp,0(sp)
 82343ac:	dec00204 	addi	sp,sp,8
 82343b0:	f800283a 	ret

082343b4 <sbreserve>:
 * RETURNS: 
 */

int
sbreserve(struct sockbuf * sb, u_long cc)
{
 82343b4:	defffd04 	addi	sp,sp,-12
 82343b8:	df000215 	stw	fp,8(sp)
 82343bc:	df000204 	addi	fp,sp,8
 82343c0:	e13ffe15 	stw	r4,-8(fp)
 82343c4:	e17fff15 	stw	r5,-4(fp)
#ifdef COMPILER_32BIT
   if (cc > (u_long)SB_MAX * CLBYTES / (2 * MSIZE + CLBYTES))
      return (0);
#endif
   sb->sb_hiwat = cc;
 82343c8:	e0bffe17 	ldw	r2,-8(fp)
 82343cc:	e0ffff17 	ldw	r3,-4(fp)
 82343d0:	10c00115 	stw	r3,4(r2)
   sb->sb_mbmax = MIN(cc * 2, SB_MAX);
 82343d4:	e0bfff17 	ldw	r2,-4(fp)
 82343d8:	1085883a 	add	r2,r2,r2
 82343dc:	10d00070 	cmpltui	r3,r2,16385
 82343e0:	1800011e 	bne	r3,zero,82343e8 <sbreserve+0x34>
 82343e4:	00900004 	movi	r2,16384
 82343e8:	e0fffe17 	ldw	r3,-8(fp)
 82343ec:	18800315 	stw	r2,12(r3)
   return (1);
 82343f0:	00800044 	movi	r2,1
}
 82343f4:	e037883a 	mov	sp,fp
 82343f8:	df000017 	ldw	fp,0(sp)
 82343fc:	dec00104 	addi	sp,sp,4
 8234400:	f800283a 	ret

08234404 <sbrelease>:
 * RETURNS: 
 */

void
sbrelease(struct sockbuf * sb)
{
 8234404:	defffd04 	addi	sp,sp,-12
 8234408:	dfc00215 	stw	ra,8(sp)
 823440c:	df000115 	stw	fp,4(sp)
 8234410:	df000104 	addi	fp,sp,4
 8234414:	e13fff15 	stw	r4,-4(fp)
   sbflush(sb);
 8234418:	e13fff17 	ldw	r4,-4(fp)
 823441c:	82349840 	call	8234984 <sbflush>
   sb->sb_hiwat = sb->sb_mbmax = 0;
 8234420:	e0bfff17 	ldw	r2,-4(fp)
 8234424:	10000315 	stw	zero,12(r2)
 8234428:	e0bfff17 	ldw	r2,-4(fp)
 823442c:	10c00317 	ldw	r3,12(r2)
 8234430:	e0bfff17 	ldw	r2,-4(fp)
 8234434:	10c00115 	stw	r3,4(r2)
}
 8234438:	0001883a 	nop
 823443c:	e037883a 	mov	sp,fp
 8234440:	dfc00117 	ldw	ra,4(sp)
 8234444:	df000017 	ldw	fp,0(sp)
 8234448:	dec00204 	addi	sp,sp,8
 823444c:	f800283a 	ret

08234450 <sbappend>:
 * RETURNS: 
 */

void
sbappend(struct sockbuf * sb, struct mbuf * m)
{
 8234450:	defffb04 	addi	sp,sp,-20
 8234454:	dfc00415 	stw	ra,16(sp)
 8234458:	df000315 	stw	fp,12(sp)
 823445c:	df000304 	addi	fp,sp,12
 8234460:	e13ffe15 	stw	r4,-8(fp)
 8234464:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  n;

   if (m == 0)
 8234468:	e0bfff17 	ldw	r2,-4(fp)
 823446c:	10001a26 	beq	r2,zero,82344d8 <sbappend+0x88>
      return;
   ENTER_CRIT_SECTION(sb);
 8234470:	822d7c80 	call	822d7c8 <irq_Mask>
   if ((n = sb->sb_mb) != NULL) 
 8234474:	e0bffe17 	ldw	r2,-8(fp)
 8234478:	10800617 	ldw	r2,24(r2)
 823447c:	e0bffd15 	stw	r2,-12(fp)
 8234480:	e0bffd17 	ldw	r2,-12(fp)
 8234484:	10000e26 	beq	r2,zero,82344c0 <sbappend+0x70>
   {
      while (n->m_act)
 8234488:	00000306 	br	8234498 <sbappend+0x48>
         n = n->m_act;
 823448c:	e0bffd17 	ldw	r2,-12(fp)
 8234490:	10800717 	ldw	r2,28(r2)
 8234494:	e0bffd15 	stw	r2,-12(fp)
   if (m == 0)
      return;
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 8234498:	e0bffd17 	ldw	r2,-12(fp)
 823449c:	10800717 	ldw	r2,28(r2)
 82344a0:	103ffa1e 	bne	r2,zero,823448c <sbappend+0x3c>
         n = n->m_act;
      while (n->m_next)
 82344a4:	00000306 	br	82344b4 <sbappend+0x64>
         n = n->m_next;
 82344a8:	e0bffd17 	ldw	r2,-12(fp)
 82344ac:	10800617 	ldw	r2,24(r2)
 82344b0:	e0bffd15 	stw	r2,-12(fp)
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
         n = n->m_act;
      while (n->m_next)
 82344b4:	e0bffd17 	ldw	r2,-12(fp)
 82344b8:	10800617 	ldw	r2,24(r2)
 82344bc:	103ffa1e 	bne	r2,zero,82344a8 <sbappend+0x58>
         n = n->m_next;
   }
   sbcompress(sb, m, n);
 82344c0:	e1bffd17 	ldw	r6,-12(fp)
 82344c4:	e17fff17 	ldw	r5,-4(fp)
 82344c8:	e13ffe17 	ldw	r4,-8(fp)
 82344cc:	82347a40 	call	82347a4 <sbcompress>
   EXIT_CRIT_SECTION(sb);
 82344d0:	822d8280 	call	822d828 <irq_Unmask>
 82344d4:	00000106 	br	82344dc <sbappend+0x8c>
sbappend(struct sockbuf * sb, struct mbuf * m)
{
   struct mbuf *  n;

   if (m == 0)
      return;
 82344d8:	0001883a 	nop
      while (n->m_next)
         n = n->m_next;
   }
   sbcompress(sb, m, n);
   EXIT_CRIT_SECTION(sb);
}
 82344dc:	e037883a 	mov	sp,fp
 82344e0:	dfc00117 	ldw	ra,4(sp)
 82344e4:	df000017 	ldw	fp,0(sp)
 82344e8:	dec00204 	addi	sp,sp,8
 82344ec:	f800283a 	ret

082344f0 <sbappendrecord>:
 */

void
sbappendrecord(struct sockbuf * sb, 
   struct mbuf *  m0)
{
 82344f0:	defffb04 	addi	sp,sp,-20
 82344f4:	dfc00415 	stw	ra,16(sp)
 82344f8:	df000315 	stw	fp,12(sp)
 82344fc:	df000304 	addi	fp,sp,12
 8234500:	e13ffe15 	stw	r4,-8(fp)
 8234504:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;

   if (m0 == 0)
 8234508:	e0bfff17 	ldw	r2,-4(fp)
 823450c:	10002826 	beq	r2,zero,82345b0 <sbappendrecord+0xc0>
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
 8234510:	822d7c80 	call	822d7c8 <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 8234514:	e0bffe17 	ldw	r2,-8(fp)
 8234518:	10800617 	ldw	r2,24(r2)
 823451c:	e0bffd15 	stw	r2,-12(fp)
 8234520:	e0bffd17 	ldw	r2,-12(fp)
 8234524:	10000726 	beq	r2,zero,8234544 <sbappendrecord+0x54>
      while (m->m_act)
 8234528:	00000306 	br	8234538 <sbappendrecord+0x48>
      m = m->m_act;
 823452c:	e0bffd17 	ldw	r2,-12(fp)
 8234530:	10800717 	ldw	r2,28(r2)
 8234534:	e0bffd15 	stw	r2,-12(fp)

   if (m0 == 0)
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
   if ((m = sb->sb_mb) != NULL)
      while (m->m_act)
 8234538:	e0bffd17 	ldw	r2,-12(fp)
 823453c:	10800717 	ldw	r2,28(r2)
 8234540:	103ffa1e 	bne	r2,zero,823452c <sbappendrecord+0x3c>
      m = m->m_act;
   /*
    * Put the first mbuf on the queue.
    * Note this permits zero length records.
    */
   sballoc(sb, m0);
 8234544:	e0bffe17 	ldw	r2,-8(fp)
 8234548:	10c00017 	ldw	r3,0(r2)
 823454c:	e0bfff17 	ldw	r2,-4(fp)
 8234550:	10800217 	ldw	r2,8(r2)
 8234554:	1887883a 	add	r3,r3,r2
 8234558:	e0bffe17 	ldw	r2,-8(fp)
 823455c:	10c00015 	stw	r3,0(r2)
   if (m)
 8234560:	e0bffd17 	ldw	r2,-12(fp)
 8234564:	10000426 	beq	r2,zero,8234578 <sbappendrecord+0x88>
      m->m_act = m0;
 8234568:	e0bffd17 	ldw	r2,-12(fp)
 823456c:	e0ffff17 	ldw	r3,-4(fp)
 8234570:	10c00715 	stw	r3,28(r2)
 8234574:	00000306 	br	8234584 <sbappendrecord+0x94>
   else
      sb->sb_mb = m0;
 8234578:	e0bffe17 	ldw	r2,-8(fp)
 823457c:	e0ffff17 	ldw	r3,-4(fp)
 8234580:	10c00615 	stw	r3,24(r2)
   m = m0->m_next;
 8234584:	e0bfff17 	ldw	r2,-4(fp)
 8234588:	10800617 	ldw	r2,24(r2)
 823458c:	e0bffd15 	stw	r2,-12(fp)
   m0->m_next = 0;
 8234590:	e0bfff17 	ldw	r2,-4(fp)
 8234594:	10000615 	stw	zero,24(r2)
   sbcompress(sb, m, m0);
 8234598:	e1bfff17 	ldw	r6,-4(fp)
 823459c:	e17ffd17 	ldw	r5,-12(fp)
 82345a0:	e13ffe17 	ldw	r4,-8(fp)
 82345a4:	82347a40 	call	82347a4 <sbcompress>
   EXIT_CRIT_SECTION(sb);
 82345a8:	822d8280 	call	822d828 <irq_Unmask>
 82345ac:	00000106 	br	82345b4 <sbappendrecord+0xc4>
   struct mbuf *  m0)
{
   struct mbuf *  m;

   if (m0 == 0)
      return;
 82345b0:	0001883a 	nop
      sb->sb_mb = m0;
   m = m0->m_next;
   m0->m_next = 0;
   sbcompress(sb, m, m0);
   EXIT_CRIT_SECTION(sb);
}
 82345b4:	e037883a 	mov	sp,fp
 82345b8:	dfc00117 	ldw	ra,4(sp)
 82345bc:	df000017 	ldw	fp,0(sp)
 82345c0:	dec00204 	addi	sp,sp,8
 82345c4:	f800283a 	ret

082345c8 <sbappendaddr>:

int
sbappendaddr(struct sockbuf * sb, 
   struct sockaddr * asa,
   struct mbuf *  m0)
{
 82345c8:	defff804 	addi	sp,sp,-32
 82345cc:	dfc00715 	stw	ra,28(sp)
 82345d0:	df000615 	stw	fp,24(sp)
 82345d4:	df000604 	addi	fp,sp,24
 82345d8:	e13ffd15 	stw	r4,-12(fp)
 82345dc:	e17ffe15 	stw	r5,-8(fp)
 82345e0:	e1bfff15 	stw	r6,-4(fp)
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);
 82345e4:	00800404 	movi	r2,16
 82345e8:	e0bffc15 	stw	r2,-16(fp)

   ENTER_CRIT_SECTION(sb);
 82345ec:	822d7c80 	call	822d7c8 <irq_Mask>
   for (m = m0; m; m = m->m_next)
 82345f0:	e0bfff17 	ldw	r2,-4(fp)
 82345f4:	e0bffa15 	stw	r2,-24(fp)
 82345f8:	00000806 	br	823461c <sbappendaddr+0x54>
      space += m->m_len;
 82345fc:	e0bffa17 	ldw	r2,-24(fp)
 8234600:	10c00217 	ldw	r3,8(r2)
 8234604:	e0bffc17 	ldw	r2,-16(fp)
 8234608:	1885883a 	add	r2,r3,r2
 823460c:	e0bffc15 	stw	r2,-16(fp)
{
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);

   ENTER_CRIT_SECTION(sb);
   for (m = m0; m; m = m->m_next)
 8234610:	e0bffa17 	ldw	r2,-24(fp)
 8234614:	10800617 	ldw	r2,24(r2)
 8234618:	e0bffa15 	stw	r2,-24(fp)
 823461c:	e0bffa17 	ldw	r2,-24(fp)
 8234620:	103ff61e 	bne	r2,zero,82345fc <sbappendaddr+0x34>
      space += m->m_len;
   if (space > (int)sbspace(sb))
 8234624:	e0bffd17 	ldw	r2,-12(fp)
 8234628:	10800117 	ldw	r2,4(r2)
 823462c:	1007883a 	mov	r3,r2
 8234630:	e0bffd17 	ldw	r2,-12(fp)
 8234634:	10800017 	ldw	r2,0(r2)
 8234638:	1885c83a 	sub	r2,r3,r2
 823463c:	10000716 	blt	r2,zero,823465c <sbappendaddr+0x94>
 8234640:	e0bffd17 	ldw	r2,-12(fp)
 8234644:	10c00117 	ldw	r3,4(r2)
 8234648:	e0bffd17 	ldw	r2,-12(fp)
 823464c:	10800017 	ldw	r2,0(r2)
 8234650:	1885c83a 	sub	r2,r3,r2
 8234654:	1007883a 	mov	r3,r2
 8234658:	00000106 	br	8234660 <sbappendaddr+0x98>
 823465c:	0007883a 	mov	r3,zero
 8234660:	e0bffc17 	ldw	r2,-16(fp)
 8234664:	1880030e 	bge	r3,r2,8234674 <sbappendaddr+0xac>
   {
      EXIT_CRIT_SECTION(sb);
 8234668:	822d8280 	call	822d828 <irq_Unmask>
      return (0);
 823466c:	0005883a 	mov	r2,zero
 8234670:	00004706 	br	8234790 <sbappendaddr+0x1c8>
   }
   if ((m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr))) == NULL)
 8234674:	01400404 	movi	r5,16
 8234678:	01000244 	movi	r4,9
 823467c:	822e4040 	call	822e404 <m_getnbuf>
 8234680:	e0bffa15 	stw	r2,-24(fp)
 8234684:	e0bffa17 	ldw	r2,-24(fp)
 8234688:	1000031e 	bne	r2,zero,8234698 <sbappendaddr+0xd0>
   {
      EXIT_CRIT_SECTION(sb);
 823468c:	822d8280 	call	822d828 <irq_Unmask>
      return 0;
 8234690:	0005883a 	mov	r2,zero
 8234694:	00003e06 	br	8234790 <sbappendaddr+0x1c8>
   }
   *mtod(m, struct sockaddr *) = *asa;
 8234698:	e0bffa17 	ldw	r2,-24(fp)
 823469c:	10800317 	ldw	r2,12(r2)
 82346a0:	e0fffe17 	ldw	r3,-8(fp)
 82346a4:	1900000b 	ldhu	r4,0(r3)
 82346a8:	1100000d 	sth	r4,0(r2)
 82346ac:	1900008b 	ldhu	r4,2(r3)
 82346b0:	1100008d 	sth	r4,2(r2)
 82346b4:	1900010b 	ldhu	r4,4(r3)
 82346b8:	1100010d 	sth	r4,4(r2)
 82346bc:	1900018b 	ldhu	r4,6(r3)
 82346c0:	1100018d 	sth	r4,6(r2)
 82346c4:	1900020b 	ldhu	r4,8(r3)
 82346c8:	1100020d 	sth	r4,8(r2)
 82346cc:	1900028b 	ldhu	r4,10(r3)
 82346d0:	1100028d 	sth	r4,10(r2)
 82346d4:	1900030b 	ldhu	r4,12(r3)
 82346d8:	1100030d 	sth	r4,12(r2)
 82346dc:	18c0038b 	ldhu	r3,14(r3)
 82346e0:	10c0038d 	sth	r3,14(r2)
   m->m_len = sizeof (*asa);
 82346e4:	e0bffa17 	ldw	r2,-24(fp)
 82346e8:	00c00404 	movi	r3,16
 82346ec:	10c00215 	stw	r3,8(r2)
   sballoc (sb, m);
 82346f0:	e0bffd17 	ldw	r2,-12(fp)
 82346f4:	10c00017 	ldw	r3,0(r2)
 82346f8:	e0bffa17 	ldw	r2,-24(fp)
 82346fc:	10800217 	ldw	r2,8(r2)
 8234700:	1887883a 	add	r3,r3,r2
 8234704:	e0bffd17 	ldw	r2,-12(fp)
 8234708:	10c00015 	stw	r3,0(r2)
   if ((n = sb->sb_mb) != NULL) 
 823470c:	e0bffd17 	ldw	r2,-12(fp)
 8234710:	10800617 	ldw	r2,24(r2)
 8234714:	e0bffb15 	stw	r2,-20(fp)
 8234718:	e0bffb17 	ldw	r2,-20(fp)
 823471c:	10000b26 	beq	r2,zero,823474c <sbappendaddr+0x184>
   {
      while (n->m_act)
 8234720:	00000306 	br	8234730 <sbappendaddr+0x168>
         n = n->m_act;
 8234724:	e0bffb17 	ldw	r2,-20(fp)
 8234728:	10800717 	ldw	r2,28(r2)
 823472c:	e0bffb15 	stw	r2,-20(fp)
   *mtod(m, struct sockaddr *) = *asa;
   m->m_len = sizeof (*asa);
   sballoc (sb, m);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 8234730:	e0bffb17 	ldw	r2,-20(fp)
 8234734:	10800717 	ldw	r2,28(r2)
 8234738:	103ffa1e 	bne	r2,zero,8234724 <sbappendaddr+0x15c>
         n = n->m_act;
      n->m_act = m;
 823473c:	e0bffb17 	ldw	r2,-20(fp)
 8234740:	e0fffa17 	ldw	r3,-24(fp)
 8234744:	10c00715 	stw	r3,28(r2)
 8234748:	00000306 	br	8234758 <sbappendaddr+0x190>
   } else
      sb->sb_mb = m;
 823474c:	e0bffd17 	ldw	r2,-12(fp)
 8234750:	e0fffa17 	ldw	r3,-24(fp)
 8234754:	10c00615 	stw	r3,24(r2)
   if (m->m_next)
 8234758:	e0bffa17 	ldw	r2,-24(fp)
 823475c:	10800617 	ldw	r2,24(r2)
 8234760:	10000326 	beq	r2,zero,8234770 <sbappendaddr+0x1a8>
      m = m->m_next;
 8234764:	e0bffa17 	ldw	r2,-24(fp)
 8234768:	10800617 	ldw	r2,24(r2)
 823476c:	e0bffa15 	stw	r2,-24(fp)
   if (m0)
 8234770:	e0bfff17 	ldw	r2,-4(fp)
 8234774:	10000426 	beq	r2,zero,8234788 <sbappendaddr+0x1c0>
      sbcompress(sb, m0, m);
 8234778:	e1bffa17 	ldw	r6,-24(fp)
 823477c:	e17fff17 	ldw	r5,-4(fp)
 8234780:	e13ffd17 	ldw	r4,-12(fp)
 8234784:	82347a40 	call	82347a4 <sbcompress>

   EXIT_CRIT_SECTION(sb);
 8234788:	822d8280 	call	822d828 <irq_Unmask>
   return (1);
 823478c:	00800044 	movi	r2,1
}
 8234790:	e037883a 	mov	sp,fp
 8234794:	dfc00117 	ldw	ra,4(sp)
 8234798:	df000017 	ldw	fp,0(sp)
 823479c:	dec00204 	addi	sp,sp,8
 82347a0:	f800283a 	ret

082347a4 <sbcompress>:

void
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{
 82347a4:	defffb04 	addi	sp,sp,-20
 82347a8:	dfc00415 	stw	ra,16(sp)
 82347ac:	df000315 	stw	fp,12(sp)
 82347b0:	df000304 	addi	fp,sp,12
 82347b4:	e13ffd15 	stw	r4,-12(fp)
 82347b8:	e17ffe15 	stw	r5,-8(fp)
 82347bc:	e1bfff15 	stw	r6,-4(fp)

   while (m) 
 82347c0:	00006806 	br	8234964 <sbcompress+0x1c0>
   {
      if (m->m_len == 0) 
 82347c4:	e0bffe17 	ldw	r2,-8(fp)
 82347c8:	10800217 	ldw	r2,8(r2)
 82347cc:	1000041e 	bne	r2,zero,82347e0 <sbcompress+0x3c>
      {
         m = m_free(m);
 82347d0:	e13ffe17 	ldw	r4,-8(fp)
 82347d4:	822e58c0 	call	822e58c <m_free>
 82347d8:	e0bffe15 	stw	r2,-8(fp)
         continue;
 82347dc:	00006106 	br	8234964 <sbcompress+0x1c0>
      }
      if (m->m_type != MT_RXDATA && 
 82347e0:	e0bffe17 	ldw	r2,-8(fp)
 82347e4:	10800817 	ldw	r2,32(r2)
 82347e8:	10800060 	cmpeqi	r2,r2,1
 82347ec:	1000111e 	bne	r2,zero,8234834 <sbcompress+0x90>
          m->m_type != MT_TXDATA && 
 82347f0:	e0bffe17 	ldw	r2,-8(fp)
 82347f4:	10800817 	ldw	r2,32(r2)
      if (m->m_len == 0) 
      {
         m = m_free(m);
         continue;
      }
      if (m->m_type != MT_RXDATA && 
 82347f8:	108000a0 	cmpeqi	r2,r2,2
 82347fc:	10000d1e 	bne	r2,zero,8234834 <sbcompress+0x90>
          m->m_type != MT_TXDATA && 
          m->m_type != MT_SONAME) 
 8234800:	e0bffe17 	ldw	r2,-8(fp)
 8234804:	10800817 	ldw	r2,32(r2)
      {
         m = m_free(m);
         continue;
      }
      if (m->m_type != MT_RXDATA && 
          m->m_type != MT_TXDATA && 
 8234808:	10800260 	cmpeqi	r2,r2,9
 823480c:	1000091e 	bne	r2,zero,8234834 <sbcompress+0x90>
          m->m_type != MT_SONAME) 
      {
         dprintf ("sbcomp:bad type %d\n", m->m_type);
 8234810:	e0bffe17 	ldw	r2,-8(fp)
 8234814:	10800817 	ldw	r2,32(r2)
 8234818:	100b883a 	mov	r5,r2
 823481c:	01020974 	movhi	r4,2085
 8234820:	2103b004 	addi	r4,r4,3776
 8234824:	82033fc0 	call	82033fc <printf>
         panic ("sbcomp:bad");
 8234828:	01020974 	movhi	r4,2085
 823482c:	2103b504 	addi	r4,r4,3796
 8234830:	8228ca40 	call	8228ca4 <panic>
      /* If there is room for all the data in M in N, then
       * just copy the data to N.  Note that sbdrop will 
       * increment the n->m_data pointer, so that we must
       * correct n->m_memsz.
       */
      if ( n && (sb->sb_flags & SB_MBCOMP) &&
 8234834:	e0bfff17 	ldw	r2,-4(fp)
 8234838:	10003326 	beq	r2,zero,8234908 <sbcompress+0x164>
 823483c:	e0bffd17 	ldw	r2,-12(fp)
 8234840:	1080070b 	ldhu	r2,28(r2)
 8234844:	10bfffcc 	andi	r2,r2,65535
 8234848:	1080200c 	andi	r2,r2,128
 823484c:	10002e26 	beq	r2,zero,8234908 <sbcompress+0x164>
          ((n->m_len + m->m_len) <
 8234850:	e0bfff17 	ldw	r2,-4(fp)
 8234854:	10c00217 	ldw	r3,8(r2)
 8234858:	e0bffe17 	ldw	r2,-8(fp)
 823485c:	10800217 	ldw	r2,8(r2)
 8234860:	1887883a 	add	r3,r3,r2
          n->m_memsz - (n->m_data - n->m_base) ) ) 
 8234864:	e0bfff17 	ldw	r2,-4(fp)
 8234868:	10800517 	ldw	r2,20(r2)
 823486c:	e13fff17 	ldw	r4,-4(fp)
 8234870:	21000317 	ldw	r4,12(r4)
 8234874:	200b883a 	mov	r5,r4
 8234878:	e13fff17 	ldw	r4,-4(fp)
 823487c:	21000417 	ldw	r4,16(r4)
 8234880:	2909c83a 	sub	r4,r5,r4
 8234884:	1105c83a 	sub	r2,r2,r4
      /* If there is room for all the data in M in N, then
       * just copy the data to N.  Note that sbdrop will 
       * increment the n->m_data pointer, so that we must
       * correct n->m_memsz.
       */
      if ( n && (sb->sb_flags & SB_MBCOMP) &&
 8234888:	18801f2e 	bgeu	r3,r2,8234908 <sbcompress+0x164>
          ((n->m_len + m->m_len) <
          n->m_memsz - (n->m_data - n->m_base) ) ) 
      {
         MEMCPY(n->m_data+n->m_len, m->m_data, m->m_len);
 823488c:	e0bfff17 	ldw	r2,-4(fp)
 8234890:	10c00317 	ldw	r3,12(r2)
 8234894:	e0bfff17 	ldw	r2,-4(fp)
 8234898:	10800217 	ldw	r2,8(r2)
 823489c:	1887883a 	add	r3,r3,r2
 82348a0:	e0bffe17 	ldw	r2,-8(fp)
 82348a4:	11000317 	ldw	r4,12(r2)
 82348a8:	e0bffe17 	ldw	r2,-8(fp)
 82348ac:	10800217 	ldw	r2,8(r2)
 82348b0:	100d883a 	mov	r6,r2
 82348b4:	200b883a 	mov	r5,r4
 82348b8:	1809883a 	mov	r4,r3
 82348bc:	8202f6c0 	call	8202f6c <memcpy>
         sballoc(sb, m);
 82348c0:	e0bffd17 	ldw	r2,-12(fp)
 82348c4:	10c00017 	ldw	r3,0(r2)
 82348c8:	e0bffe17 	ldw	r2,-8(fp)
 82348cc:	10800217 	ldw	r2,8(r2)
 82348d0:	1887883a 	add	r3,r3,r2
 82348d4:	e0bffd17 	ldw	r2,-12(fp)
 82348d8:	10c00015 	stw	r3,0(r2)
         n->m_len += m->m_len;
 82348dc:	e0bfff17 	ldw	r2,-4(fp)
 82348e0:	10c00217 	ldw	r3,8(r2)
 82348e4:	e0bffe17 	ldw	r2,-8(fp)
 82348e8:	10800217 	ldw	r2,8(r2)
 82348ec:	1887883a 	add	r3,r3,r2
 82348f0:	e0bfff17 	ldw	r2,-4(fp)
 82348f4:	10c00215 	stw	r3,8(r2)
         m = m_free(m);
 82348f8:	e13ffe17 	ldw	r4,-8(fp)
 82348fc:	822e58c0 	call	822e58c <m_free>
 8234900:	e0bffe15 	stw	r2,-8(fp)
         continue;
 8234904:	00001706 	br	8234964 <sbcompress+0x1c0>
      }
      sballoc(sb, m);
 8234908:	e0bffd17 	ldw	r2,-12(fp)
 823490c:	10c00017 	ldw	r3,0(r2)
 8234910:	e0bffe17 	ldw	r2,-8(fp)
 8234914:	10800217 	ldw	r2,8(r2)
 8234918:	1887883a 	add	r3,r3,r2
 823491c:	e0bffd17 	ldw	r2,-12(fp)
 8234920:	10c00015 	stw	r3,0(r2)
      if (n)
 8234924:	e0bfff17 	ldw	r2,-4(fp)
 8234928:	10000426 	beq	r2,zero,823493c <sbcompress+0x198>
         n->m_next = m;
 823492c:	e0bfff17 	ldw	r2,-4(fp)
 8234930:	e0fffe17 	ldw	r3,-8(fp)
 8234934:	10c00615 	stw	r3,24(r2)
 8234938:	00000306 	br	8234948 <sbcompress+0x1a4>
      else
         sb->sb_mb = m;
 823493c:	e0bffd17 	ldw	r2,-12(fp)
 8234940:	e0fffe17 	ldw	r3,-8(fp)
 8234944:	10c00615 	stw	r3,24(r2)
      n = m;
 8234948:	e0bffe17 	ldw	r2,-8(fp)
 823494c:	e0bfff15 	stw	r2,-4(fp)
      m = m->m_next;
 8234950:	e0bffe17 	ldw	r2,-8(fp)
 8234954:	10800617 	ldw	r2,24(r2)
 8234958:	e0bffe15 	stw	r2,-8(fp)
      n->m_next = 0;
 823495c:	e0bfff17 	ldw	r2,-4(fp)
 8234960:	10000615 	stw	zero,24(r2)
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{

   while (m) 
 8234964:	e0bffe17 	ldw	r2,-8(fp)
 8234968:	103f961e 	bne	r2,zero,82347c4 <sbcompress+0x20>
         sb->sb_mb = m;
      n = m;
      m = m->m_next;
      n->m_next = 0;
   }
}
 823496c:	0001883a 	nop
 8234970:	e037883a 	mov	sp,fp
 8234974:	dfc00117 	ldw	ra,4(sp)
 8234978:	df000017 	ldw	fp,0(sp)
 823497c:	dec00204 	addi	sp,sp,8
 8234980:	f800283a 	ret

08234984 <sbflush>:
 * RETURNS: 
 */

void
sbflush(struct sockbuf * sb)
{
 8234984:	defffd04 	addi	sp,sp,-12
 8234988:	dfc00215 	stw	ra,8(sp)
 823498c:	df000115 	stw	fp,4(sp)
 8234990:	df000104 	addi	fp,sp,4
 8234994:	e13fff15 	stw	r4,-4(fp)
   ENTER_CRIT_SECTION(sb);
 8234998:	822d7c80 	call	822d7c8 <irq_Mask>
   if (sb->sb_flags & SB_LOCK)
 823499c:	e0bfff17 	ldw	r2,-4(fp)
 82349a0:	1080070b 	ldhu	r2,28(r2)
 82349a4:	10bfffcc 	andi	r2,r2,65535
 82349a8:	1080004c 	andi	r2,r2,1
 82349ac:	10000926 	beq	r2,zero,82349d4 <sbflush+0x50>
      panic("sbflush");
 82349b0:	01020974 	movhi	r4,2085
 82349b4:	2103b804 	addi	r4,r4,3808
 82349b8:	8228ca40 	call	8228ca4 <panic>
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 82349bc:	00000506 	br	82349d4 <sbflush+0x50>
      sbdrop (sb, (int)sb->sb_cc);
 82349c0:	e0bfff17 	ldw	r2,-4(fp)
 82349c4:	10800017 	ldw	r2,0(r2)
 82349c8:	100b883a 	mov	r5,r2
 82349cc:	e13fff17 	ldw	r4,-4(fp)
 82349d0:	8234a080 	call	8234a08 <sbdrop>
sbflush(struct sockbuf * sb)
{
   ENTER_CRIT_SECTION(sb);
   if (sb->sb_flags & SB_LOCK)
      panic("sbflush");
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 82349d4:	e0bfff17 	ldw	r2,-4(fp)
 82349d8:	10800217 	ldw	r2,8(r2)
 82349dc:	103ff81e 	bne	r2,zero,82349c0 <sbflush+0x3c>
 82349e0:	e0bfff17 	ldw	r2,-4(fp)
 82349e4:	10800017 	ldw	r2,0(r2)
 82349e8:	103ff51e 	bne	r2,zero,82349c0 <sbflush+0x3c>
      sbdrop (sb, (int)sb->sb_cc);
   EXIT_CRIT_SECTION(sb);
 82349ec:	822d8280 	call	822d828 <irq_Unmask>
}
 82349f0:	0001883a 	nop
 82349f4:	e037883a 	mov	sp,fp
 82349f8:	dfc00117 	ldw	ra,4(sp)
 82349fc:	df000017 	ldw	fp,0(sp)
 8234a00:	dec00204 	addi	sp,sp,8
 8234a04:	f800283a 	ret

08234a08 <sbdrop>:
 * RETURNS: 
 */

void
sbdrop(struct sockbuf * sb, int len)
{
 8234a08:	defff904 	addi	sp,sp,-28
 8234a0c:	dfc00615 	stw	ra,24(sp)
 8234a10:	df000515 	stw	fp,20(sp)
 8234a14:	df000504 	addi	fp,sp,20
 8234a18:	e13ffe15 	stw	r4,-8(fp)
 8234a1c:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m, *  mn;
   struct mbuf *  next;

   ENTER_CRIT_SECTION(sb);
 8234a20:	822d7c80 	call	822d7c8 <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 8234a24:	e0bffe17 	ldw	r2,-8(fp)
 8234a28:	10800617 	ldw	r2,24(r2)
 8234a2c:	e0bffb15 	stw	r2,-20(fp)
 8234a30:	e0bffb17 	ldw	r2,-20(fp)
 8234a34:	10000426 	beq	r2,zero,8234a48 <sbdrop+0x40>
      next = m->m_act;
 8234a38:	e0bffb17 	ldw	r2,-20(fp)
 8234a3c:	10800717 	ldw	r2,28(r2)
 8234a40:	e0bffc15 	stw	r2,-16(fp)
 8234a44:	00003706 	br	8234b24 <sbdrop+0x11c>
   else
      next = NULL;
 8234a48:	e03ffc15 	stw	zero,-16(fp)
   while (len > 0) 
 8234a4c:	00003506 	br	8234b24 <sbdrop+0x11c>
   {
      if (m == 0) 
 8234a50:	e0bffb17 	ldw	r2,-20(fp)
 8234a54:	10000b1e 	bne	r2,zero,8234a84 <sbdrop+0x7c>
      {
         if (next == 0)
 8234a58:	e0bffc17 	ldw	r2,-16(fp)
 8234a5c:	1000031e 	bne	r2,zero,8234a6c <sbdrop+0x64>
            panic("sbdrop");
 8234a60:	01020974 	movhi	r4,2085
 8234a64:	2103ba04 	addi	r4,r4,3816
 8234a68:	8228ca40 	call	8228ca4 <panic>
         m = next;
 8234a6c:	e0bffc17 	ldw	r2,-16(fp)
 8234a70:	e0bffb15 	stw	r2,-20(fp)
         next = m->m_act;
 8234a74:	e0bffb17 	ldw	r2,-20(fp)
 8234a78:	10800717 	ldw	r2,28(r2)
 8234a7c:	e0bffc15 	stw	r2,-16(fp)
         continue;
 8234a80:	00002806 	br	8234b24 <sbdrop+0x11c>
      }
      if (m->m_len > (unsigned)len) 
 8234a84:	e0bffb17 	ldw	r2,-20(fp)
 8234a88:	10800217 	ldw	r2,8(r2)
 8234a8c:	e0ffff17 	ldw	r3,-4(fp)
 8234a90:	1880132e 	bgeu	r3,r2,8234ae0 <sbdrop+0xd8>
      {
         m->m_len -= len;
 8234a94:	e0bffb17 	ldw	r2,-20(fp)
 8234a98:	10c00217 	ldw	r3,8(r2)
 8234a9c:	e0bfff17 	ldw	r2,-4(fp)
 8234aa0:	1887c83a 	sub	r3,r3,r2
 8234aa4:	e0bffb17 	ldw	r2,-20(fp)
 8234aa8:	10c00215 	stw	r3,8(r2)
         m->m_data += len;
 8234aac:	e0bffb17 	ldw	r2,-20(fp)
 8234ab0:	10c00317 	ldw	r3,12(r2)
 8234ab4:	e0bfff17 	ldw	r2,-4(fp)
 8234ab8:	1887883a 	add	r3,r3,r2
 8234abc:	e0bffb17 	ldw	r2,-20(fp)
 8234ac0:	10c00315 	stw	r3,12(r2)
         sb->sb_cc -= len;
 8234ac4:	e0bffe17 	ldw	r2,-8(fp)
 8234ac8:	10c00017 	ldw	r3,0(r2)
 8234acc:	e0bfff17 	ldw	r2,-4(fp)
 8234ad0:	1887c83a 	sub	r3,r3,r2
 8234ad4:	e0bffe17 	ldw	r2,-8(fp)
 8234ad8:	10c00015 	stw	r3,0(r2)
         break;
 8234adc:	00001306 	br	8234b2c <sbdrop+0x124>
      }
      len -= m->m_len;
 8234ae0:	e0ffff17 	ldw	r3,-4(fp)
 8234ae4:	e0bffb17 	ldw	r2,-20(fp)
 8234ae8:	10800217 	ldw	r2,8(r2)
 8234aec:	1885c83a 	sub	r2,r3,r2
 8234af0:	e0bfff15 	stw	r2,-4(fp)
      sbfree (sb, m);
 8234af4:	e0bffe17 	ldw	r2,-8(fp)
 8234af8:	10c00017 	ldw	r3,0(r2)
 8234afc:	e0bffb17 	ldw	r2,-20(fp)
 8234b00:	10800217 	ldw	r2,8(r2)
 8234b04:	1887c83a 	sub	r3,r3,r2
 8234b08:	e0bffe17 	ldw	r2,-8(fp)
 8234b0c:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 8234b10:	e13ffb17 	ldw	r4,-20(fp)
 8234b14:	822e58c0 	call	822e58c <m_free>
 8234b18:	e0bffd15 	stw	r2,-12(fp)
      m = mn;
 8234b1c:	e0bffd17 	ldw	r2,-12(fp)
 8234b20:	e0bffb15 	stw	r2,-20(fp)
   ENTER_CRIT_SECTION(sb);
   if ((m = sb->sb_mb) != NULL)
      next = m->m_act;
   else
      next = NULL;
   while (len > 0) 
 8234b24:	e0bfff17 	ldw	r2,-4(fp)
 8234b28:	00bfc916 	blt	zero,r2,8234a50 <sbdrop+0x48>
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 8234b2c:	00000c06 	br	8234b60 <sbdrop+0x158>
   {
      sbfree(sb, m);
 8234b30:	e0bffe17 	ldw	r2,-8(fp)
 8234b34:	10c00017 	ldw	r3,0(r2)
 8234b38:	e0bffb17 	ldw	r2,-20(fp)
 8234b3c:	10800217 	ldw	r2,8(r2)
 8234b40:	1887c83a 	sub	r3,r3,r2
 8234b44:	e0bffe17 	ldw	r2,-8(fp)
 8234b48:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 8234b4c:	e13ffb17 	ldw	r4,-20(fp)
 8234b50:	822e58c0 	call	822e58c <m_free>
 8234b54:	e0bffd15 	stw	r2,-12(fp)
      m = mn;
 8234b58:	e0bffd17 	ldw	r2,-12(fp)
 8234b5c:	e0bffb15 	stw	r2,-20(fp)
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 8234b60:	e0bffb17 	ldw	r2,-20(fp)
 8234b64:	10000326 	beq	r2,zero,8234b74 <sbdrop+0x16c>
 8234b68:	e0bffb17 	ldw	r2,-20(fp)
 8234b6c:	10800217 	ldw	r2,8(r2)
 8234b70:	103fef26 	beq	r2,zero,8234b30 <sbdrop+0x128>
   {
      sbfree(sb, m);
      MFREE(m, mn);
      m = mn;
   }
   if (m) 
 8234b74:	e0bffb17 	ldw	r2,-20(fp)
 8234b78:	10000726 	beq	r2,zero,8234b98 <sbdrop+0x190>
   {
      sb->sb_mb = m;
 8234b7c:	e0bffe17 	ldw	r2,-8(fp)
 8234b80:	e0fffb17 	ldw	r3,-20(fp)
 8234b84:	10c00615 	stw	r3,24(r2)
      m->m_act = next;
 8234b88:	e0bffb17 	ldw	r2,-20(fp)
 8234b8c:	e0fffc17 	ldw	r3,-16(fp)
 8234b90:	10c00715 	stw	r3,28(r2)
 8234b94:	00000306 	br	8234ba4 <sbdrop+0x19c>
   } else
      sb->sb_mb = next;
 8234b98:	e0bffe17 	ldw	r2,-8(fp)
 8234b9c:	e0fffc17 	ldw	r3,-16(fp)
 8234ba0:	10c00615 	stw	r3,24(r2)
   EXIT_CRIT_SECTION(sb);
 8234ba4:	822d8280 	call	822d828 <irq_Unmask>
}
 8234ba8:	0001883a 	nop
 8234bac:	e037883a 	mov	sp,fp
 8234bb0:	dfc00117 	ldw	ra,4(sp)
 8234bb4:	df000017 	ldw	fp,0(sp)
 8234bb8:	dec00204 	addi	sp,sp,8
 8234bbc:	f800283a 	ret

08234bc0 <sbdropend>:
 * RETURNS: 
 */

void
sbdropend(struct sockbuf * sb, struct mbuf * m)
{
 8234bc0:	defff904 	addi	sp,sp,-28
 8234bc4:	dfc00615 	stw	ra,24(sp)
 8234bc8:	df000515 	stw	fp,20(sp)
 8234bcc:	df000504 	addi	fp,sp,20
 8234bd0:	e13ffe15 	stw	r4,-8(fp)
 8234bd4:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  nmb, *   pmb;
   int   len;
   ENTER_CRIT_SECTION(sb);
 8234bd8:	822d7c80 	call	822d7c8 <irq_Mask>
   len = mbuf_len(m);
 8234bdc:	e13fff17 	ldw	r4,-4(fp)
 8234be0:	822eb8c0 	call	822eb8c <mbuf_len>
 8234be4:	e0bffd15 	stw	r2,-12(fp)
   if (len > 0)
 8234be8:	e0bffd17 	ldw	r2,-12(fp)
 8234bec:	0080070e 	bge	zero,r2,8234c0c <sbdropend+0x4c>
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
 8234bf0:	e0bffe17 	ldw	r2,-8(fp)
 8234bf4:	10c00617 	ldw	r3,24(r2)
 8234bf8:	e0bffd17 	ldw	r2,-12(fp)
 8234bfc:	0085c83a 	sub	r2,zero,r2
 8234c00:	100b883a 	mov	r5,r2
 8234c04:	1809883a 	mov	r4,r3
 8234c08:	822e9cc0 	call	822e9cc <m_adj>
   nmb = sb->sb_mb;
 8234c0c:	e0bffe17 	ldw	r2,-8(fp)
 8234c10:	10800617 	ldw	r2,24(r2)
 8234c14:	e0bffb15 	stw	r2,-20(fp)
   pmb = NULL;
 8234c18:	e03ffc15 	stw	zero,-16(fp)
   if (sb->sb_mb->m_len == 0)
 8234c1c:	e0bffe17 	ldw	r2,-8(fp)
 8234c20:	10800617 	ldw	r2,24(r2)
 8234c24:	10800217 	ldw	r2,8(r2)
 8234c28:	1000081e 	bne	r2,zero,8234c4c <sbdropend+0x8c>
      sb->sb_mb = NULL;
 8234c2c:	e0bffe17 	ldw	r2,-8(fp)
 8234c30:	10000615 	stw	zero,24(r2)
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 8234c34:	00000506 	br	8234c4c <sbdropend+0x8c>
   {
      pmb = nmb;  /* Remember previous */
 8234c38:	e0bffb17 	ldw	r2,-20(fp)
 8234c3c:	e0bffc15 	stw	r2,-16(fp)
      nmb = nmb->m_next;    
 8234c40:	e0bffb17 	ldw	r2,-20(fp)
 8234c44:	10800617 	ldw	r2,24(r2)
 8234c48:	e0bffb15 	stw	r2,-20(fp)
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
   nmb = sb->sb_mb;
   pmb = NULL;
   if (sb->sb_mb->m_len == 0)
      sb->sb_mb = NULL;
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 8234c4c:	e0bffb17 	ldw	r2,-20(fp)
 8234c50:	10000326 	beq	r2,zero,8234c60 <sbdropend+0xa0>
 8234c54:	e0bffb17 	ldw	r2,-20(fp)
 8234c58:	10800217 	ldw	r2,8(r2)
 8234c5c:	103ff61e 	bne	r2,zero,8234c38 <sbdropend+0x78>
   {
      pmb = nmb;  /* Remember previous */
      nmb = nmb->m_next;    
   }
   if (nmb && (nmb->m_len == 0)) /* Assume once 0 len found, all the rest */
 8234c60:	e0bffb17 	ldw	r2,-20(fp)
 8234c64:	10000926 	beq	r2,zero,8234c8c <sbdropend+0xcc>
 8234c68:	e0bffb17 	ldw	r2,-20(fp)
 8234c6c:	10800217 	ldw	r2,8(r2)
 8234c70:	1000061e 	bne	r2,zero,8234c8c <sbdropend+0xcc>
   {                             /* are zeroes */ 
      if (pmb != NULL)
 8234c74:	e0bffc17 	ldw	r2,-16(fp)
 8234c78:	10000226 	beq	r2,zero,8234c84 <sbdropend+0xc4>
         pmb->m_next = NULL;
 8234c7c:	e0bffc17 	ldw	r2,-16(fp)
 8234c80:	10000615 	stw	zero,24(r2)
      m_freem(nmb);            
 8234c84:	e13ffb17 	ldw	r4,-20(fp)
 8234c88:	822e6940 	call	822e694 <m_freem>
   }
   sb->sb_cc -= len;       /* Do a sbfree using the len */
 8234c8c:	e0bffe17 	ldw	r2,-8(fp)
 8234c90:	10c00017 	ldw	r3,0(r2)
 8234c94:	e0bffd17 	ldw	r2,-12(fp)
 8234c98:	1887c83a 	sub	r3,r3,r2
 8234c9c:	e0bffe17 	ldw	r2,-8(fp)
 8234ca0:	10c00015 	stw	r3,0(r2)
   EXIT_CRIT_SECTION(sb);
 8234ca4:	822d8280 	call	822d828 <irq_Unmask>
}
 8234ca8:	0001883a 	nop
 8234cac:	e037883a 	mov	sp,fp
 8234cb0:	dfc00117 	ldw	ra,4(sp)
 8234cb4:	df000017 	ldw	fp,0(sp)
 8234cb8:	dec00204 	addi	sp,sp,8
 8234cbc:	f800283a 	ret

08234cc0 <sbdroprecord>:
 * RETURNS: 
 */

void
sbdroprecord(struct sockbuf * sb)
{
 8234cc0:	defffb04 	addi	sp,sp,-20
 8234cc4:	dfc00415 	stw	ra,16(sp)
 8234cc8:	df000315 	stw	fp,12(sp)
 8234ccc:	df000304 	addi	fp,sp,12
 8234cd0:	e13fff15 	stw	r4,-4(fp)
   struct mbuf *  m, *  mn;

   ENTER_CRIT_SECTION(sb);
 8234cd4:	822d7c80 	call	822d7c8 <irq_Mask>
   m = sb->sb_mb;
 8234cd8:	e0bfff17 	ldw	r2,-4(fp)
 8234cdc:	10800617 	ldw	r2,24(r2)
 8234ce0:	e0bffd15 	stw	r2,-12(fp)
   if (m)
 8234ce4:	e0bffd17 	ldw	r2,-12(fp)
 8234ce8:	10001226 	beq	r2,zero,8234d34 <sbdroprecord+0x74>
   {  sb->sb_mb = m->m_act;
 8234cec:	e0bffd17 	ldw	r2,-12(fp)
 8234cf0:	10c00717 	ldw	r3,28(r2)
 8234cf4:	e0bfff17 	ldw	r2,-4(fp)
 8234cf8:	10c00615 	stw	r3,24(r2)
      do 
      {  sbfree(sb, m);
 8234cfc:	e0bfff17 	ldw	r2,-4(fp)
 8234d00:	10c00017 	ldw	r3,0(r2)
 8234d04:	e0bffd17 	ldw	r2,-12(fp)
 8234d08:	10800217 	ldw	r2,8(r2)
 8234d0c:	1887c83a 	sub	r3,r3,r2
 8234d10:	e0bfff17 	ldw	r2,-4(fp)
 8234d14:	10c00015 	stw	r3,0(r2)
         MFREE(m, mn);
 8234d18:	e13ffd17 	ldw	r4,-12(fp)
 8234d1c:	822e58c0 	call	822e58c <m_free>
 8234d20:	e0bffe15 	stw	r2,-8(fp)
      } while ((m = mn) != NULL);
 8234d24:	e0bffe17 	ldw	r2,-8(fp)
 8234d28:	e0bffd15 	stw	r2,-12(fp)
 8234d2c:	e0bffd17 	ldw	r2,-12(fp)
 8234d30:	103ff21e 	bne	r2,zero,8234cfc <sbdroprecord+0x3c>
         }
   EXIT_CRIT_SECTION(sb);
 8234d34:	822d8280 	call	822d828 <irq_Unmask>
}
 8234d38:	0001883a 	nop
 8234d3c:	e037883a 	mov	sp,fp
 8234d40:	dfc00117 	ldw	ra,4(sp)
 8234d44:	df000017 	ldw	fp,0(sp)
 8234d48:	dec00204 	addi	sp,sp,8
 8234d4c:	f800283a 	ret

08234d50 <t_select>:
int
t_select(fd_set * in,   /* lists of sockets to watch */
   fd_set * out,
   fd_set * ex,
   long  tv)   /* ticks to wait */
{
 8234d50:	defe7204 	addi	sp,sp,-1592
 8234d54:	dfc18d15 	stw	ra,1588(sp)
 8234d58:	df018c15 	stw	fp,1584(sp)
 8234d5c:	df018c04 	addi	fp,sp,1584
 8234d60:	e13ffc15 	stw	r4,-16(fp)
 8234d64:	e17ffd15 	stw	r5,-12(fp)
 8234d68:	e1bffe15 	stw	r6,-8(fp)
 8234d6c:	e1ffff15 	stw	r7,-4(fp)
   fd_set obits[3], ibits [3];
   u_long   tmo;
   int   retval   =  0;
 8234d70:	e03e7415 	stw	zero,-1584(fp)

   MEMSET(&obits, 0, sizeof(obits));
 8234d74:	e0be7604 	addi	r2,fp,-1576
 8234d78:	0180c304 	movi	r6,780
 8234d7c:	000b883a 	mov	r5,zero
 8234d80:	1009883a 	mov	r4,r2
 8234d84:	82032100 	call	8203210 <memset>
   MEMSET(&ibits, 0, sizeof(ibits));
 8234d88:	e0bf3904 	addi	r2,fp,-796
 8234d8c:	0180c304 	movi	r6,780
 8234d90:	000b883a 	mov	r5,zero
 8234d94:	1009883a 	mov	r4,r2
 8234d98:	82032100 	call	8203210 <memset>

   if (in)
 8234d9c:	e0bffc17 	ldw	r2,-16(fp)
 8234da0:	10000526 	beq	r2,zero,8234db8 <t_select+0x68>
      MEMCPY(&ibits[0], in, sizeof(fd_set));
 8234da4:	e0bf3904 	addi	r2,fp,-796
 8234da8:	01804104 	movi	r6,260
 8234dac:	e17ffc17 	ldw	r5,-16(fp)
 8234db0:	1009883a 	mov	r4,r2
 8234db4:	8202f6c0 	call	8202f6c <memcpy>
   if (out)
 8234db8:	e0bffd17 	ldw	r2,-12(fp)
 8234dbc:	10000626 	beq	r2,zero,8234dd8 <t_select+0x88>
      MEMCPY(&ibits[1], out, sizeof(fd_set));
 8234dc0:	e0bf3904 	addi	r2,fp,-796
 8234dc4:	10804104 	addi	r2,r2,260
 8234dc8:	01804104 	movi	r6,260
 8234dcc:	e17ffd17 	ldw	r5,-12(fp)
 8234dd0:	1009883a 	mov	r4,r2
 8234dd4:	8202f6c0 	call	8202f6c <memcpy>
   if (ex)
 8234dd8:	e0bffe17 	ldw	r2,-8(fp)
 8234ddc:	10000626 	beq	r2,zero,8234df8 <t_select+0xa8>
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
 8234de0:	e0bf3904 	addi	r2,fp,-796
 8234de4:	10808204 	addi	r2,r2,520
 8234de8:	01804104 	movi	r6,260
 8234dec:	e17ffe17 	ldw	r5,-8(fp)
 8234df0:	1009883a 	mov	r4,r2
 8234df4:	8202f6c0 	call	8202f6c <memcpy>
   tmo = cticks + tv;
 8234df8:	d0e0a817 	ldw	r3,-32096(gp)
 8234dfc:	e0bfff17 	ldw	r2,-4(fp)
 8234e00:	1885883a 	add	r2,r3,r2
 8234e04:	e0be7515 	stw	r2,-1580(fp)

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 8234e08:	e0bf3917 	ldw	r2,-796(fp)
 8234e0c:	10000c1e 	bne	r2,zero,8234e40 <t_select+0xf0>
 8234e10:	e0bf7a17 	ldw	r2,-536(fp)
 8234e14:	10000a1e 	bne	r2,zero,8234e40 <t_select+0xf0>
       (ibits[2].fd_count == 0))
 8234e18:	e0bfbb17 	ldw	r2,-276(fp)
   if (ex)
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
   tmo = cticks + tv;

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 8234e1c:	1000081e 	bne	r2,zero,8234e40 <t_select+0xf0>
       (ibits[2].fd_count == 0))
   {
      if (tv > 0)      /* make sure we don't block on nothing forever */
 8234e20:	e0bfff17 	ldw	r2,-4(fp)
 8234e24:	00801f0e 	bge	zero,r2,8234ea4 <t_select+0x154>
         while (tmo > cticks)
         {
            tk_yield();
         }
#else
         TK_SLEEP(tv);
 8234e28:	e0bfff17 	ldw	r2,-4(fp)
 8234e2c:	10800044 	addi	r2,r2,1
 8234e30:	10bfffcc 	andi	r2,r2,65535
 8234e34:	1009883a 	mov	r4,r2
 8234e38:	821bf340 	call	821bf34 <OSTimeDly>

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
       (ibits[2].fd_count == 0))
   {
      if (tv > 0)      /* make sure we don't block on nothing forever */
 8234e3c:	00001906 	br	8234ea4 <t_select+0x154>

      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
 8234e40:	0009883a 	mov	r4,zero
 8234e44:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      while ((retval = sock_selscan(ibits, obits)) == 0)
 8234e48:	00000a06 	br	8234e74 <t_select+0x124>
      {
         if (tv != -1L) 
 8234e4c:	e0bfff17 	ldw	r2,-4(fp)
 8234e50:	10bfffe0 	cmpeqi	r2,r2,-1
 8234e54:	1000031e 	bne	r2,zero,8234e64 <t_select+0x114>
         {
            if (tmo <= cticks)
 8234e58:	d0e0a817 	ldw	r3,-32096(gp)
 8234e5c:	e0be7517 	ldw	r2,-1580(fp)
 8234e60:	18800d2e 	bgeu	r3,r2,8234e98 <t_select+0x148>
               break;
         }
         select_wait = 1;
 8234e64:	00800044 	movi	r2,1
 8234e68:	d0a0b00d 	sth	r2,-32064(gp)
         tcp_sleep (&select_wait);
 8234e6c:	d120b004 	addi	r4,gp,-32064
 8234e70:	82295900 	call	8229590 <tcp_sleep>
      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
      while ((retval = sock_selscan(ibits, obits)) == 0)
 8234e74:	e0fe7604 	addi	r3,fp,-1576
 8234e78:	e0bf3904 	addi	r2,fp,-796
 8234e7c:	180b883a 	mov	r5,r3
 8234e80:	1009883a 	mov	r4,r2
 8234e84:	8234f200 	call	8234f20 <sock_selscan>
 8234e88:	e0be7415 	stw	r2,-1584(fp)
 8234e8c:	e0be7417 	ldw	r2,-1584(fp)
 8234e90:	103fee26 	beq	r2,zero,8234e4c <t_select+0xfc>
 8234e94:	00000106 	br	8234e9c <t_select+0x14c>
      {
         if (tv != -1L) 
         {
            if (tmo <= cticks)
               break;
 8234e98:	0001883a 	nop
         }
         select_wait = 1;
         tcp_sleep (&select_wait);
      }
      UNLOCK_NET_RESOURCE(NET_RESID);
 8234e9c:	0009883a 	mov	r4,zero
 8234ea0:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>

   }

   if (retval >= 0)
 8234ea4:	e0be7417 	ldw	r2,-1584(fp)
 8234ea8:	10001716 	blt	r2,zero,8234f08 <t_select+0x1b8>
   {
      if (in)
 8234eac:	e0bffc17 	ldw	r2,-16(fp)
 8234eb0:	10000526 	beq	r2,zero,8234ec8 <t_select+0x178>
         MEMCPY(in, &obits[0], sizeof(fd_set));
 8234eb4:	e0be7604 	addi	r2,fp,-1576
 8234eb8:	01804104 	movi	r6,260
 8234ebc:	100b883a 	mov	r5,r2
 8234ec0:	e13ffc17 	ldw	r4,-16(fp)
 8234ec4:	8202f6c0 	call	8202f6c <memcpy>
      if (out)
 8234ec8:	e0bffd17 	ldw	r2,-12(fp)
 8234ecc:	10000626 	beq	r2,zero,8234ee8 <t_select+0x198>
         MEMCPY(out, &obits[1], sizeof(fd_set));
 8234ed0:	e0be7604 	addi	r2,fp,-1576
 8234ed4:	10804104 	addi	r2,r2,260
 8234ed8:	01804104 	movi	r6,260
 8234edc:	100b883a 	mov	r5,r2
 8234ee0:	e13ffd17 	ldw	r4,-12(fp)
 8234ee4:	8202f6c0 	call	8202f6c <memcpy>
      if (ex)
 8234ee8:	e0bffe17 	ldw	r2,-8(fp)
 8234eec:	10000626 	beq	r2,zero,8234f08 <t_select+0x1b8>
         MEMCPY(ex, &obits[2], sizeof(fd_set));
 8234ef0:	e0be7604 	addi	r2,fp,-1576
 8234ef4:	10808204 	addi	r2,r2,520
 8234ef8:	01804104 	movi	r6,260
 8234efc:	100b883a 	mov	r5,r2
 8234f00:	e13ffe17 	ldw	r4,-8(fp)
 8234f04:	8202f6c0 	call	8202f6c <memcpy>
   }
   return retval;
 8234f08:	e0be7417 	ldw	r2,-1584(fp)
}
 8234f0c:	e037883a 	mov	sp,fp
 8234f10:	dfc00117 	ldw	ra,4(sp)
 8234f14:	df000017 	ldw	fp,0(sp)
 8234f18:	dec00204 	addi	sp,sp,8
 8234f1c:	f800283a 	ret

08234f20 <sock_selscan>:
 * RETURNS: 
 */

int
sock_selscan(fd_set * ibits, fd_set * obits)
{
 8234f20:	defff604 	addi	sp,sp,-40
 8234f24:	dfc00915 	stw	ra,36(sp)
 8234f28:	df000815 	stw	fp,32(sp)
 8234f2c:	df000804 	addi	fp,sp,32
 8234f30:	e13ffe15 	stw	r4,-8(fp)
 8234f34:	e17fff15 	stw	r5,-4(fp)
   fd_set *in, *out;
   int   which;
   int   sock;
   int   flag  =  0;
 8234f38:	e03ffa15 	stw	zero,-24(fp)
   int   num_sel  =  0;
 8234f3c:	e03ffb15 	stw	zero,-20(fp)

   for (which = 0; which < 3; which++)
 8234f40:	e03ff815 	stw	zero,-32(fp)
 8234f44:	00003d06 	br	823503c <sock_selscan+0x11c>
   {
      switch (which)
 8234f48:	e0bff817 	ldw	r2,-32(fp)
 8234f4c:	10c00060 	cmpeqi	r3,r2,1
 8234f50:	1800061e 	bne	r3,zero,8234f6c <sock_selscan+0x4c>
 8234f54:	10c000a0 	cmpeqi	r3,r2,2
 8234f58:	1800071e 	bne	r3,zero,8234f78 <sock_selscan+0x58>
 8234f5c:	1000081e 	bne	r2,zero,8234f80 <sock_selscan+0x60>
      {
      case 0:
         flag = SOREAD; break;
 8234f60:	00800044 	movi	r2,1
 8234f64:	e0bffa15 	stw	r2,-24(fp)
 8234f68:	00000506 	br	8234f80 <sock_selscan+0x60>

      case 1:
         flag = SOWRITE; break;
 8234f6c:	00800084 	movi	r2,2
 8234f70:	e0bffa15 	stw	r2,-24(fp)
 8234f74:	00000206 	br	8234f80 <sock_selscan+0x60>

      case 2:
         flag = 0; break;
 8234f78:	e03ffa15 	stw	zero,-24(fp)
 8234f7c:	0001883a 	nop
      }
      in = &ibits [which];
 8234f80:	e0bff817 	ldw	r2,-32(fp)
 8234f84:	10804124 	muli	r2,r2,260
 8234f88:	e0fffe17 	ldw	r3,-8(fp)
 8234f8c:	1885883a 	add	r2,r3,r2
 8234f90:	e0bffc15 	stw	r2,-16(fp)
      out = &obits [which];
 8234f94:	e0bff817 	ldw	r2,-32(fp)
 8234f98:	10804124 	muli	r2,r2,260
 8234f9c:	e0ffff17 	ldw	r3,-4(fp)
 8234fa0:	1885883a 	add	r2,r3,r2
 8234fa4:	e0bffd15 	stw	r2,-12(fp)
      for (sock = 0; sock < (int)in->fd_count; sock++)
 8234fa8:	e03ff915 	stw	zero,-28(fp)
 8234fac:	00001b06 	br	823501c <sock_selscan+0xfc>
      {
         if (sock_select (in->fd_array[sock], flag))
 8234fb0:	e0fffc17 	ldw	r3,-16(fp)
 8234fb4:	e0bff917 	ldw	r2,-28(fp)
 8234fb8:	10800044 	addi	r2,r2,1
 8234fbc:	1085883a 	add	r2,r2,r2
 8234fc0:	1085883a 	add	r2,r2,r2
 8234fc4:	1885883a 	add	r2,r3,r2
 8234fc8:	10800017 	ldw	r2,0(r2)
 8234fcc:	e17ffa17 	ldw	r5,-24(fp)
 8234fd0:	1009883a 	mov	r4,r2
 8234fd4:	82350600 	call	8235060 <sock_select>
 8234fd8:	10000d26 	beq	r2,zero,8235010 <sock_selscan+0xf0>
         {
            FD_SET(in->fd_array[sock], out);
 8234fdc:	e0fffc17 	ldw	r3,-16(fp)
 8234fe0:	e0bff917 	ldw	r2,-28(fp)
 8234fe4:	10800044 	addi	r2,r2,1
 8234fe8:	1085883a 	add	r2,r2,r2
 8234fec:	1085883a 	add	r2,r2,r2
 8234ff0:	1885883a 	add	r2,r3,r2
 8234ff4:	10800017 	ldw	r2,0(r2)
 8234ff8:	e17ffd17 	ldw	r5,-12(fp)
 8234ffc:	1009883a 	mov	r4,r2
 8235000:	82354780 	call	8235478 <ifd_set>
            num_sel++;
 8235004:	e0bffb17 	ldw	r2,-20(fp)
 8235008:	10800044 	addi	r2,r2,1
 823500c:	e0bffb15 	stw	r2,-20(fp)
      case 2:
         flag = 0; break;
      }
      in = &ibits [which];
      out = &obits [which];
      for (sock = 0; sock < (int)in->fd_count; sock++)
 8235010:	e0bff917 	ldw	r2,-28(fp)
 8235014:	10800044 	addi	r2,r2,1
 8235018:	e0bff915 	stw	r2,-28(fp)
 823501c:	e0bffc17 	ldw	r2,-16(fp)
 8235020:	10800017 	ldw	r2,0(r2)
 8235024:	1007883a 	mov	r3,r2
 8235028:	e0bff917 	ldw	r2,-28(fp)
 823502c:	10ffe016 	blt	r2,r3,8234fb0 <sock_selscan+0x90>
   int   which;
   int   sock;
   int   flag  =  0;
   int   num_sel  =  0;

   for (which = 0; which < 3; which++)
 8235030:	e0bff817 	ldw	r2,-32(fp)
 8235034:	10800044 	addi	r2,r2,1
 8235038:	e0bff815 	stw	r2,-32(fp)
 823503c:	e0bff817 	ldw	r2,-32(fp)
 8235040:	108000d0 	cmplti	r2,r2,3
 8235044:	103fc01e 	bne	r2,zero,8234f48 <sock_selscan+0x28>
            FD_SET(in->fd_array[sock], out);
            num_sel++;
         }
      }
   }
   return num_sel;
 8235048:	e0bffb17 	ldw	r2,-20(fp)
}
 823504c:	e037883a 	mov	sp,fp
 8235050:	dfc00117 	ldw	ra,4(sp)
 8235054:	df000017 	ldw	fp,0(sp)
 8235058:	dec00204 	addi	sp,sp,8
 823505c:	f800283a 	ret

08235060 <sock_select>:
 * RETURNS: 
 */

int
sock_select(long sock, int flag)
{
 8235060:	defffa04 	addi	sp,sp,-24
 8235064:	dfc00515 	stw	ra,20(sp)
 8235068:	df000415 	stw	fp,16(sp)
 823506c:	df000404 	addi	fp,sp,16
 8235070:	e13ffe15 	stw	r4,-8(fp)
 8235074:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so;
   int   ready =  0;
 8235078:	e03ffc15 	stw	zero,-16(fp)

   so = LONG2SO(sock);
 823507c:	e0bffe17 	ldw	r2,-8(fp)
 8235080:	10bff804 	addi	r2,r2,-32
 8235084:	1085883a 	add	r2,r2,r2
 8235088:	1085883a 	add	r2,r2,r2
 823508c:	e0bffd15 	stw	r2,-12(fp)

   switch (flag) 
 8235090:	e0bfff17 	ldw	r2,-4(fp)
 8235094:	10c00060 	cmpeqi	r3,r2,1
 8235098:	1800041e 	bne	r3,zero,82350ac <sock_select+0x4c>
 823509c:	10c000a0 	cmpeqi	r3,r2,2
 82350a0:	1800201e 	bne	r3,zero,8235124 <sock_select+0xc4>
 82350a4:	10004326 	beq	r2,zero,82351b4 <sock_select+0x154>
 82350a8:	00006006 	br	823522c <sock_select+0x1cc>
   {
   case SOREAD:
      /* can we read something from so? */
      if (so->so_rcv.sb_cc)
 82350ac:	e0bffd17 	ldw	r2,-12(fp)
 82350b0:	10800a17 	ldw	r2,40(r2)
 82350b4:	10000326 	beq	r2,zero,82350c4 <sock_select+0x64>
      {
         ready = 1;
 82350b8:	00800044 	movi	r2,1
 82350bc:	e0bffc15 	stw	r2,-16(fp)
         break;
 82350c0:	00005a06 	br	823522c <sock_select+0x1cc>
      }
      if (so->so_state & SS_CANTRCVMORE)
 82350c4:	e0bffd17 	ldw	r2,-12(fp)
 82350c8:	1080088b 	ldhu	r2,34(r2)
 82350cc:	10bfffcc 	andi	r2,r2,65535
 82350d0:	1080080c 	andi	r2,r2,32
 82350d4:	10000326 	beq	r2,zero,82350e4 <sock_select+0x84>
      {  ready = 1;
 82350d8:	00800044 	movi	r2,1
 82350dc:	e0bffc15 	stw	r2,-16(fp)
         break;
 82350e0:	00005206 	br	823522c <sock_select+0x1cc>
      }
      if (so->so_qlen)  /* attach is ready */
 82350e4:	e0bffd17 	ldw	r2,-12(fp)
 82350e8:	10801e43 	ldbu	r2,121(r2)
 82350ec:	10803fcc 	andi	r2,r2,255
 82350f0:	1080201c 	xori	r2,r2,128
 82350f4:	10bfe004 	addi	r2,r2,-128
 82350f8:	10000326 	beq	r2,zero,8235108 <sock_select+0xa8>
      {
         ready = 1;
 82350fc:	00800044 	movi	r2,1
 8235100:	e0bffc15 	stw	r2,-16(fp)
         break;
 8235104:	00004906 	br	823522c <sock_select+0x1cc>
         }
      }
#endif   /* TCP_ZEROCOPY */

      /* fall to here if so is not ready to read */
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
 8235108:	e0bffd17 	ldw	r2,-12(fp)
 823510c:	1080110b 	ldhu	r2,68(r2)
 8235110:	10800214 	ori	r2,r2,8
 8235114:	1007883a 	mov	r3,r2
 8235118:	e0bffd17 	ldw	r2,-12(fp)
 823511c:	10c0110d 	sth	r3,68(r2)
      break;
 8235120:	00004206 	br	823522c <sock_select+0x1cc>

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
 8235124:	e0bffd17 	ldw	r2,-12(fp)
 8235128:	10801317 	ldw	r2,76(r2)
 823512c:	1007883a 	mov	r3,r2
 8235130:	e0bffd17 	ldw	r2,-12(fp)
 8235134:	10801217 	ldw	r2,72(r2)
 8235138:	1885c83a 	sub	r2,r3,r2
 823513c:	10001816 	blt	r2,zero,82351a0 <sock_select+0x140>
 8235140:	e0bffd17 	ldw	r2,-12(fp)
 8235144:	10c01317 	ldw	r3,76(r2)
 8235148:	e0bffd17 	ldw	r2,-12(fp)
 823514c:	10801217 	ldw	r2,72(r2)
 8235150:	18801326 	beq	r3,r2,82351a0 <sock_select+0x140>
          ((((so)->so_state&SS_ISCONNECTED) || 
 8235154:	e0bffd17 	ldw	r2,-12(fp)
 8235158:	1080088b 	ldhu	r2,34(r2)
 823515c:	10bfffcc 	andi	r2,r2,65535
 8235160:	1080008c 	andi	r2,r2,2
      /* fall to here if so is not ready to read */
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
      break;

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
 8235164:	10000b1e 	bne	r2,zero,8235194 <sock_select+0x134>
          ((((so)->so_state&SS_ISCONNECTED) || 
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
 8235168:	e0bffd17 	ldw	r2,-12(fp)
 823516c:	10800217 	ldw	r2,8(r2)
 8235170:	1080010b 	ldhu	r2,4(r2)
 8235174:	10bfffcc 	andi	r2,r2,65535
 8235178:	1080010c 	andi	r2,r2,4
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
      break;

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
          ((((so)->so_state&SS_ISCONNECTED) || 
 823517c:	10000526 	beq	r2,zero,8235194 <sock_select+0x134>
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
           ((so)->so_state & SS_CANTSENDMORE)))
 8235180:	e0bffd17 	ldw	r2,-12(fp)
 8235184:	1080088b 	ldhu	r2,34(r2)
 8235188:	10bfffcc 	andi	r2,r2,65535
 823518c:	1080040c 	andi	r2,r2,16
      break;

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
          ((((so)->so_state&SS_ISCONNECTED) || 
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
 8235190:	10000326 	beq	r2,zero,82351a0 <sock_select+0x140>
           ((so)->so_state & SS_CANTSENDMORE)))
      {
         ready = 1;
 8235194:	00800044 	movi	r2,1
 8235198:	e0bffc15 	stw	r2,-16(fp)
         break;
 823519c:	00002306 	br	823522c <sock_select+0x1cc>
      }
      sbselqueue (&so->so_snd);
 82351a0:	e0bffd17 	ldw	r2,-12(fp)
 82351a4:	10801204 	addi	r2,r2,72
 82351a8:	1009883a 	mov	r4,r2
 82351ac:	82341f80 	call	82341f8 <sbselqueue>
      break;
 82351b0:	00001e06 	br	823522c <sock_select+0x1cc>

   case 0:
      if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
 82351b4:	e0bffd17 	ldw	r2,-12(fp)
 82351b8:	10801a17 	ldw	r2,104(r2)
 82351bc:	1000051e 	bne	r2,zero,82351d4 <sock_select+0x174>
 82351c0:	e0bffd17 	ldw	r2,-12(fp)
 82351c4:	1080088b 	ldhu	r2,34(r2)
 82351c8:	10bfffcc 	andi	r2,r2,65535
 82351cc:	1080100c 	andi	r2,r2,64
 82351d0:	10000326 	beq	r2,zero,82351e0 <sock_select+0x180>
      {
         ready = 1;
 82351d4:	00800044 	movi	r2,1
 82351d8:	e0bffc15 	stw	r2,-16(fp)
         break;
 82351dc:	00001306 	br	823522c <sock_select+0x1cc>
      }
      if (so->so_error &&
 82351e0:	e0bffd17 	ldw	r2,-12(fp)
 82351e4:	10800617 	ldw	r2,24(r2)
 82351e8:	10000b26 	beq	r2,zero,8235218 <sock_select+0x1b8>
          (so->so_error != EINPROGRESS) &&
 82351ec:	e0bffd17 	ldw	r2,-12(fp)
 82351f0:	10800617 	ldw	r2,24(r2)
      if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
      {
         ready = 1;
         break;
      }
      if (so->so_error &&
 82351f4:	10801de0 	cmpeqi	r2,r2,119
 82351f8:	1000071e 	bne	r2,zero,8235218 <sock_select+0x1b8>
          (so->so_error != EINPROGRESS) &&
          (so->so_error != EWOULDBLOCK))
 82351fc:	e0bffd17 	ldw	r2,-12(fp)
 8235200:	10800617 	ldw	r2,24(r2)
      {
         ready = 1;
         break;
      }
      if (so->so_error &&
          (so->so_error != EINPROGRESS) &&
 8235204:	108002e0 	cmpeqi	r2,r2,11
 8235208:	1000031e 	bne	r2,zero,8235218 <sock_select+0x1b8>
          (so->so_error != EWOULDBLOCK))
      {
         ready = 1;
 823520c:	00800044 	movi	r2,1
 8235210:	e0bffc15 	stw	r2,-16(fp)
         break;
 8235214:	00000506 	br	823522c <sock_select+0x1cc>
      }
      sbselqueue(&so->so_rcv);
 8235218:	e0bffd17 	ldw	r2,-12(fp)
 823521c:	10800a04 	addi	r2,r2,40
 8235220:	1009883a 	mov	r4,r2
 8235224:	82341f80 	call	82341f8 <sbselqueue>
      break;
 8235228:	0001883a 	nop
   }

   return ready;
 823522c:	e0bffc17 	ldw	r2,-16(fp)
}
 8235230:	e037883a 	mov	sp,fp
 8235234:	dfc00117 	ldw	ra,4(sp)
 8235238:	df000017 	ldw	fp,0(sp)
 823523c:	dec00204 	addi	sp,sp,8
 8235240:	f800283a 	ret

08235244 <in_pcbnotify>:
void
in_pcbnotify(struct inpcb * head, 
   struct in_addr *  dst,
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
 8235244:	defff804 	addi	sp,sp,-32
 8235248:	dfc00715 	stw	ra,28(sp)
 823524c:	df000615 	stw	fp,24(sp)
 8235250:	df000604 	addi	fp,sp,24
 8235254:	e13ffc15 	stw	r4,-16(fp)
 8235258:	e17ffd15 	stw	r5,-12(fp)
 823525c:	e1bffe15 	stw	r6,-8(fp)
 8235260:	e1ffff15 	stw	r7,-4(fp)
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 8235264:	e0bffc17 	ldw	r2,-16(fp)
 8235268:	10800017 	ldw	r2,0(r2)
 823526c:	e0bffa15 	stw	r2,-24(fp)
 8235270:	00001c06 	br	82352e4 <in_pcbnotify+0xa0>
   {
      if (inp->inp_faddr.s_addr != dst->s_addr ||
 8235274:	e0bffa17 	ldw	r2,-24(fp)
 8235278:	10c00317 	ldw	r3,12(r2)
 823527c:	e0bffd17 	ldw	r2,-12(fp)
 8235280:	10800017 	ldw	r2,0(r2)
 8235284:	1880031e 	bne	r3,r2,8235294 <in_pcbnotify+0x50>
          inp->inp_socket == 0) 
 8235288:	e0bffa17 	ldw	r2,-24(fp)
 823528c:	10800817 	ldw	r2,32(r2)
{
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
   {
      if (inp->inp_faddr.s_addr != dst->s_addr ||
 8235290:	1000041e 	bne	r2,zero,82352a4 <in_pcbnotify+0x60>
          inp->inp_socket == 0) 
      {
         inp = inp->inp_next;
 8235294:	e0bffa17 	ldw	r2,-24(fp)
 8235298:	10800017 	ldw	r2,0(r2)
 823529c:	e0bffa15 	stw	r2,-24(fp)
         continue;
 82352a0:	00001006 	br	82352e4 <in_pcbnotify+0xa0>
      }
      if (errnum) 
 82352a4:	e0bffe17 	ldw	r2,-8(fp)
 82352a8:	10000426 	beq	r2,zero,82352bc <in_pcbnotify+0x78>
         inp->inp_socket->so_error = errnum;
 82352ac:	e0bffa17 	ldw	r2,-24(fp)
 82352b0:	10800817 	ldw	r2,32(r2)
 82352b4:	e0fffe17 	ldw	r3,-8(fp)
 82352b8:	10c00615 	stw	r3,24(r2)
      oinp = inp;
 82352bc:	e0bffa17 	ldw	r2,-24(fp)
 82352c0:	e0bffb15 	stw	r2,-20(fp)
      inp = inp->inp_next;
 82352c4:	e0bffa17 	ldw	r2,-24(fp)
 82352c8:	10800017 	ldw	r2,0(r2)
 82352cc:	e0bffa15 	stw	r2,-24(fp)
      if (notify)
 82352d0:	e0bfff17 	ldw	r2,-4(fp)
 82352d4:	10000326 	beq	r2,zero,82352e4 <in_pcbnotify+0xa0>
         (*notify)(oinp);
 82352d8:	e0bfff17 	ldw	r2,-4(fp)
 82352dc:	e13ffb17 	ldw	r4,-20(fp)
 82352e0:	103ee83a 	callr	r2
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 82352e4:	e0fffa17 	ldw	r3,-24(fp)
 82352e8:	e0bffc17 	ldw	r2,-16(fp)
 82352ec:	18bfe11e 	bne	r3,r2,8235274 <in_pcbnotify+0x30>
      oinp = inp;
      inp = inp->inp_next;
      if (notify)
         (*notify)(oinp);
   }
}
 82352f0:	0001883a 	nop
 82352f4:	e037883a 	mov	sp,fp
 82352f8:	dfc00117 	ldw	ra,4(sp)
 82352fc:	df000017 	ldw	fp,0(sp)
 8235300:	dec00204 	addi	sp,sp,8
 8235304:	f800283a 	ret

08235308 <tcp_notify>:
 * RETURNS: 
 */

void
tcp_notify(struct inpcb * inp)
{
 8235308:	defffd04 	addi	sp,sp,-12
 823530c:	dfc00215 	stw	ra,8(sp)
 8235310:	df000115 	stw	fp,4(sp)
 8235314:	df000104 	addi	fp,sp,4
 8235318:	e13fff15 	stw	r4,-4(fp)
   tcp_wakeup(&inp->inp_socket->so_timeo);
 823531c:	e0bfff17 	ldw	r2,-4(fp)
 8235320:	10800817 	ldw	r2,32(r2)
 8235324:	10800904 	addi	r2,r2,36
 8235328:	1009883a 	mov	r4,r2
 823532c:	82297040 	call	8229704 <tcp_wakeup>
   sorwakeup(inp->inp_socket);
 8235330:	e0bfff17 	ldw	r2,-4(fp)
 8235334:	10c00817 	ldw	r3,32(r2)
 8235338:	e0bfff17 	ldw	r2,-4(fp)
 823533c:	10800817 	ldw	r2,32(r2)
 8235340:	10800a04 	addi	r2,r2,40
 8235344:	100b883a 	mov	r5,r2
 8235348:	1809883a 	mov	r4,r3
 823534c:	82342a00 	call	82342a0 <sbwakeup>
   sowwakeup(inp->inp_socket);
 8235350:	e0bfff17 	ldw	r2,-4(fp)
 8235354:	10c00817 	ldw	r3,32(r2)
 8235358:	e0bfff17 	ldw	r2,-4(fp)
 823535c:	10800817 	ldw	r2,32(r2)
 8235360:	10801204 	addi	r2,r2,72
 8235364:	100b883a 	mov	r5,r2
 8235368:	1809883a 	mov	r4,r3
 823536c:	82342a00 	call	82342a0 <sbwakeup>
}
 8235370:	0001883a 	nop
 8235374:	e037883a 	mov	sp,fp
 8235378:	dfc00117 	ldw	ra,4(sp)
 823537c:	df000017 	ldw	fp,0(sp)
 8235380:	dec00204 	addi	sp,sp,8
 8235384:	f800283a 	ret

08235388 <ifd_clr>:
 * compacts the fd_set.
 */

void
ifd_clr(long sock, fd_set *set)
{
 8235388:	defffb04 	addi	sp,sp,-20
 823538c:	dfc00415 	stw	ra,16(sp)
 8235390:	df000315 	stw	fp,12(sp)
 8235394:	df000304 	addi	fp,sp,12
 8235398:	e13ffe15 	stw	r4,-8(fp)
 823539c:	e17fff15 	stw	r5,-4(fp)
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 82353a0:	e03ffd15 	stw	zero,-12(fp)
 82353a4:	00002a06 	br	8235450 <ifd_clr+0xc8>
   {
      if (set->fd_array[i] == sock)
 82353a8:	e0ffff17 	ldw	r3,-4(fp)
 82353ac:	e0bffd17 	ldw	r2,-12(fp)
 82353b0:	10800044 	addi	r2,r2,1
 82353b4:	1085883a 	add	r2,r2,r2
 82353b8:	1085883a 	add	r2,r2,r2
 82353bc:	1885883a 	add	r2,r3,r2
 82353c0:	10c00017 	ldw	r3,0(r2)
 82353c4:	e0bffe17 	ldw	r2,-8(fp)
 82353c8:	18801e1e 	bne	r3,r2,8235444 <ifd_clr+0xbc>
      {
         while (i + 1 < set->fd_count)
 82353cc:	00001206 	br	8235418 <ifd_clr+0x90>
         {
            set->fd_array[i] = set->fd_array[i + 1];
 82353d0:	e0bffd17 	ldw	r2,-12(fp)
 82353d4:	10800044 	addi	r2,r2,1
 82353d8:	e0ffff17 	ldw	r3,-4(fp)
 82353dc:	10800044 	addi	r2,r2,1
 82353e0:	1085883a 	add	r2,r2,r2
 82353e4:	1085883a 	add	r2,r2,r2
 82353e8:	1885883a 	add	r2,r3,r2
 82353ec:	10c00017 	ldw	r3,0(r2)
 82353f0:	e13fff17 	ldw	r4,-4(fp)
 82353f4:	e0bffd17 	ldw	r2,-12(fp)
 82353f8:	10800044 	addi	r2,r2,1
 82353fc:	1085883a 	add	r2,r2,r2
 8235400:	1085883a 	add	r2,r2,r2
 8235404:	2085883a 	add	r2,r4,r2
 8235408:	10c00015 	stw	r3,0(r2)
            i++;
 823540c:	e0bffd17 	ldw	r2,-12(fp)
 8235410:	10800044 	addi	r2,r2,1
 8235414:	e0bffd15 	stw	r2,-12(fp)

   for (i = 0; i < set->fd_count ; i++) 
   {
      if (set->fd_array[i] == sock)
      {
         while (i + 1 < set->fd_count)
 8235418:	e0bffd17 	ldw	r2,-12(fp)
 823541c:	10c00044 	addi	r3,r2,1
 8235420:	e0bfff17 	ldw	r2,-4(fp)
 8235424:	10800017 	ldw	r2,0(r2)
 8235428:	18bfe936 	bltu	r3,r2,82353d0 <ifd_clr+0x48>
         {
            set->fd_array[i] = set->fd_array[i + 1];
            i++;
         }
         set->fd_count--;
 823542c:	e0bfff17 	ldw	r2,-4(fp)
 8235430:	10800017 	ldw	r2,0(r2)
 8235434:	10ffffc4 	addi	r3,r2,-1
 8235438:	e0bfff17 	ldw	r2,-4(fp)
 823543c:	10c00015 	stw	r3,0(r2)
         return;
 8235440:	00000806 	br	8235464 <ifd_clr+0xdc>
void
ifd_clr(long sock, fd_set *set)
{
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 8235444:	e0bffd17 	ldw	r2,-12(fp)
 8235448:	10800044 	addi	r2,r2,1
 823544c:	e0bffd15 	stw	r2,-12(fp)
 8235450:	e0bfff17 	ldw	r2,-4(fp)
 8235454:	10800017 	ldw	r2,0(r2)
 8235458:	e0fffd17 	ldw	r3,-12(fp)
 823545c:	18bfd236 	bltu	r3,r2,82353a8 <ifd_clr+0x20>
         return;
      }
   }

#ifdef NPDEBUG
   dtrap(); /* socket wasn't found in array */
 8235460:	822d5f00 	call	822d5f0 <dtrap>
#endif
}
 8235464:	e037883a 	mov	sp,fp
 8235468:	dfc00117 	ldw	ra,4(sp)
 823546c:	df000017 	ldw	fp,0(sp)
 8235470:	dec00204 	addi	sp,sp,8
 8235474:	f800283a 	ret

08235478 <ifd_set>:
 * called if the fd_set structure is already full.
 */

void
ifd_set(long sock, fd_set *set)
{
 8235478:	defffc04 	addi	sp,sp,-16
 823547c:	dfc00315 	stw	ra,12(sp)
 8235480:	df000215 	stw	fp,8(sp)
 8235484:	df000204 	addi	fp,sp,8
 8235488:	e13ffe15 	stw	r4,-8(fp)
 823548c:	e17fff15 	stw	r5,-4(fp)
   if (set->fd_count < FD_SETSIZE)
 8235490:	e0bfff17 	ldw	r2,-4(fp)
 8235494:	10800017 	ldw	r2,0(r2)
 8235498:	10801028 	cmpgeui	r2,r2,64
 823549c:	10000d1e 	bne	r2,zero,82354d4 <ifd_set+0x5c>
      set->fd_array[set->fd_count++] = sock;
 82354a0:	e0bfff17 	ldw	r2,-4(fp)
 82354a4:	10800017 	ldw	r2,0(r2)
 82354a8:	11000044 	addi	r4,r2,1
 82354ac:	e0ffff17 	ldw	r3,-4(fp)
 82354b0:	19000015 	stw	r4,0(r3)
 82354b4:	e0ffff17 	ldw	r3,-4(fp)
 82354b8:	10800044 	addi	r2,r2,1
 82354bc:	1085883a 	add	r2,r2,r2
 82354c0:	1085883a 	add	r2,r2,r2
 82354c4:	1885883a 	add	r2,r3,r2
 82354c8:	e0fffe17 	ldw	r3,-8(fp)
 82354cc:	10c00015 	stw	r3,0(r2)
#ifdef NPDEBUG
   else
      dtrap();
#endif
}
 82354d0:	00000106 	br	82354d8 <ifd_set+0x60>
{
   if (set->fd_count < FD_SETSIZE)
      set->fd_array[set->fd_count++] = sock;
#ifdef NPDEBUG
   else
      dtrap();
 82354d4:	822d5f00 	call	822d5f0 <dtrap>
#endif
}
 82354d8:	0001883a 	nop
 82354dc:	e037883a 	mov	sp,fp
 82354e0:	dfc00117 	ldw	ra,4(sp)
 82354e4:	df000017 	ldw	fp,0(sp)
 82354e8:	dec00204 	addi	sp,sp,8
 82354ec:	f800283a 	ret

082354f0 <ifd_isset>:
 * Tests if a socket is a member of a file descriptor set.
 */

int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
 82354f0:	defffc04 	addi	sp,sp,-16
 82354f4:	df000315 	stw	fp,12(sp)
 82354f8:	df000304 	addi	fp,sp,12
 82354fc:	e13ffe15 	stw	r4,-8(fp)
 8235500:	e17fff15 	stw	r5,-4(fp)
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 8235504:	e03ffd15 	stw	zero,-12(fp)
 8235508:	00000e06 	br	8235544 <ifd_isset+0x54>
   {
      if (set->fd_array[i] == sock)
 823550c:	e0ffff17 	ldw	r3,-4(fp)
 8235510:	e0bffd17 	ldw	r2,-12(fp)
 8235514:	10800044 	addi	r2,r2,1
 8235518:	1085883a 	add	r2,r2,r2
 823551c:	1085883a 	add	r2,r2,r2
 8235520:	1885883a 	add	r2,r3,r2
 8235524:	10c00017 	ldw	r3,0(r2)
 8235528:	e0bffe17 	ldw	r2,-8(fp)
 823552c:	1880021e 	bne	r3,r2,8235538 <ifd_isset+0x48>
         return TRUE;
 8235530:	00800044 	movi	r2,1
 8235534:	00000806 	br	8235558 <ifd_isset+0x68>
int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 8235538:	e0bffd17 	ldw	r2,-12(fp)
 823553c:	10800044 	addi	r2,r2,1
 8235540:	e0bffd15 	stw	r2,-12(fp)
 8235544:	e0bfff17 	ldw	r2,-4(fp)
 8235548:	10800017 	ldw	r2,0(r2)
 823554c:	e0fffd17 	ldw	r3,-12(fp)
 8235550:	18bfee36 	bltu	r3,r2,823550c <ifd_isset+0x1c>
   {
      if (set->fd_array[i] == sock)
         return TRUE;
   }
   return FALSE;
 8235554:	0005883a 	mov	r2,zero
}
 8235558:	e037883a 	mov	sp,fp
 823555c:	df000017 	ldw	fp,0(sp)
 8235560:	dec00104 	addi	sp,sp,4
 8235564:	f800283a 	ret

08235568 <ifd_get>:
 * NOTE: This is not part of the original FD_XXX() functionality.
 */

long
ifd_get(unsigned i, fd_set *set)
{
 8235568:	defffc04 	addi	sp,sp,-16
 823556c:	dfc00315 	stw	ra,12(sp)
 8235570:	df000215 	stw	fp,8(sp)
 8235574:	df000204 	addi	fp,sp,8
 8235578:	e13ffe15 	stw	r4,-8(fp)
 823557c:	e17fff15 	stw	r5,-4(fp)
   if (i < set->fd_count)
 8235580:	e0bfff17 	ldw	r2,-4(fp)
 8235584:	10800017 	ldw	r2,0(r2)
 8235588:	e0fffe17 	ldw	r3,-8(fp)
 823558c:	1880082e 	bgeu	r3,r2,82355b0 <ifd_get+0x48>
      return set->fd_array[i];
 8235590:	e0ffff17 	ldw	r3,-4(fp)
 8235594:	e0bffe17 	ldw	r2,-8(fp)
 8235598:	10800044 	addi	r2,r2,1
 823559c:	1085883a 	add	r2,r2,r2
 82355a0:	1085883a 	add	r2,r2,r2
 82355a4:	1885883a 	add	r2,r3,r2
 82355a8:	10800017 	ldw	r2,0(r2)
 82355ac:	00000206 	br	82355b8 <ifd_get+0x50>
   else
   {
#ifdef NPDEBUG
      dtrap();
 82355b0:	822d5f00 	call	822d5f0 <dtrap>
#endif
      return INVALID_SOCKET;
 82355b4:	00bfffc4 	movi	r2,-1
   }
}
 82355b8:	e037883a 	mov	sp,fp
 82355bc:	dfc00117 	ldw	ra,4(sp)
 82355c0:	df000017 	ldw	fp,0(sp)
 82355c4:	dec00204 	addi	sp,sp,8
 82355c8:	f800283a 	ret

082355cc <tcp_reass>:

int
tcp_reass(struct tcpcb * tp, 
   struct tcpiphdr * ti,
   struct mbuf *  ti_mbuf)
{
 82355cc:	defff504 	addi	sp,sp,-44
 82355d0:	dfc00a15 	stw	ra,40(sp)
 82355d4:	df000915 	stw	fp,36(sp)
 82355d8:	df000904 	addi	fp,sp,36
 82355dc:	e13ffd15 	stw	r4,-12(fp)
 82355e0:	e17ffe15 	stw	r5,-8(fp)
 82355e4:	e1bfff15 	stw	r6,-4(fp)
   struct tcpiphdr * q;
   struct socket *   so =  tp->t_inpcb->inp_socket;
 82355e8:	e0bffd17 	ldw	r2,-12(fp)
 82355ec:	10800d17 	ldw	r2,52(r2)
 82355f0:	10800817 	ldw	r2,32(r2)
 82355f4:	e0bff815 	stw	r2,-32(fp)

   /*
    * Call with ti==0 after become established to
    * force pre-ESTABLISHED data up to user socket.
    */
   if (ti == 0)
 82355f8:	e0bffe17 	ldw	r2,-8(fp)
 82355fc:	1000a426 	beq	r2,zero,8235890 <tcp_reass+0x2c4>
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 8235600:	e0bffd17 	ldw	r2,-12(fp)
 8235604:	10800017 	ldw	r2,0(r2)
 8235608:	e0bff715 	stw	r2,-36(fp)
 823560c:	00000906 	br	8235634 <tcp_reass+0x68>
       q = (struct tcpiphdr *)q->ti_next)
   {
      if (SEQ_GT(q->ti_seq, ti->ti_seq))
 8235610:	e0bff717 	ldw	r2,-36(fp)
 8235614:	10c00617 	ldw	r3,24(r2)
 8235618:	e0bffe17 	ldw	r2,-8(fp)
 823561c:	10800617 	ldw	r2,24(r2)
 8235620:	1885c83a 	sub	r2,r3,r2
 8235624:	00800716 	blt	zero,r2,8235644 <tcp_reass+0x78>

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
       q = (struct tcpiphdr *)q->ti_next)
 8235628:	e0bff717 	ldw	r2,-36(fp)
 823562c:	10800017 	ldw	r2,0(r2)
 8235630:	e0bff715 	stw	r2,-36(fp)
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 8235634:	e0fff717 	ldw	r3,-36(fp)
 8235638:	e0bffd17 	ldw	r2,-12(fp)
 823563c:	18bff41e 	bne	r3,r2,8235610 <tcp_reass+0x44>
 8235640:	00000106 	br	8235648 <tcp_reass+0x7c>
       q = (struct tcpiphdr *)q->ti_next)
   {
      if (SEQ_GT(q->ti_seq, ti->ti_seq))
      break;
 8235644:	0001883a 	nop
   /*
    * If there is a preceding segment, it may provide some of
    * our data already.  If so, drop the data from the incoming
    * segment.  If it provides all of our data, drop us.
    */
   if ((struct tcpiphdr *)q->ti_prev != (struct tcpiphdr *)tp) 
 8235648:	e0bff717 	ldw	r2,-36(fp)
 823564c:	10c00117 	ldw	r3,4(r2)
 8235650:	e0bffd17 	ldw	r2,-12(fp)
 8235654:	18803f26 	beq	r3,r2,8235754 <tcp_reass+0x188>
   {
      long  i;
      q = (struct tcpiphdr *)q->ti_prev;
 8235658:	e0bff717 	ldw	r2,-36(fp)
 823565c:	10800117 	ldw	r2,4(r2)
 8235660:	e0bff715 	stw	r2,-36(fp)
      /* conversion to int (in i) handles seq wraparound */
      i = q->ti_seq + q->ti_len - ti->ti_seq;
 8235664:	e0bff717 	ldw	r2,-36(fp)
 8235668:	10c00617 	ldw	r3,24(r2)
 823566c:	e0bff717 	ldw	r2,-36(fp)
 8235670:	1080028b 	ldhu	r2,10(r2)
 8235674:	10bfffcc 	andi	r2,r2,65535
 8235678:	1887883a 	add	r3,r3,r2
 823567c:	e0bffe17 	ldw	r2,-8(fp)
 8235680:	10800617 	ldw	r2,24(r2)
 8235684:	1885c83a 	sub	r2,r3,r2
 8235688:	e0bff915 	stw	r2,-28(fp)
      if (i > 0) 
 823568c:	e0bff917 	ldw	r2,-28(fp)
 8235690:	00802d0e 	bge	zero,r2,8235748 <tcp_reass+0x17c>
      {
         if (i >= (long)ti->ti_len) 
 8235694:	e0bffe17 	ldw	r2,-8(fp)
 8235698:	1080028b 	ldhu	r2,10(r2)
 823569c:	10bfffcc 	andi	r2,r2,65535
 82356a0:	e0fff917 	ldw	r3,-28(fp)
 82356a4:	18801816 	blt	r3,r2,8235708 <tcp_reass+0x13c>
         {
            tcpstat.tcps_rcvduppack++;
 82356a8:	008209b4 	movhi	r2,2086
 82356ac:	10b9ad04 	addi	r2,r2,-6476
 82356b0:	10801f17 	ldw	r2,124(r2)
 82356b4:	10c00044 	addi	r3,r2,1
 82356b8:	008209b4 	movhi	r2,2086
 82356bc:	10b9ad04 	addi	r2,r2,-6476
 82356c0:	10c01f15 	stw	r3,124(r2)
            tcpstat.tcps_rcvdupbyte += ti->ti_len;
 82356c4:	008209b4 	movhi	r2,2086
 82356c8:	10b9ad04 	addi	r2,r2,-6476
 82356cc:	10c02017 	ldw	r3,128(r2)
 82356d0:	e0bffe17 	ldw	r2,-8(fp)
 82356d4:	1080028b 	ldhu	r2,10(r2)
 82356d8:	10bfffcc 	andi	r2,r2,65535
 82356dc:	1887883a 	add	r3,r3,r2
 82356e0:	008209b4 	movhi	r2,2086
 82356e4:	10b9ad04 	addi	r2,r2,-6476
 82356e8:	10c02015 	stw	r3,128(r2)
            GOTO_DROP;
 82356ec:	008025c4 	movi	r2,151
 82356f0:	d0a0b215 	stw	r2,-32056(gp)
 82356f4:	0001883a 	nop
   } while (ti != (struct tcpiphdr *)tp && ti->ti_seq == tp->rcv_nxt);
      sorwakeup(so);
   return (flags);
drop:
   /**m_freem (dtom(ti));**/
   m_freem (ti_mbuf);
 82356f8:	e13fff17 	ldw	r4,-4(fp)
 82356fc:	822e6940 	call	822e694 <m_freem>
   return (0);
 8235700:	0005883a 	mov	r2,zero
 8235704:	0000b006 	br	82359c8 <tcp_reass+0x3fc>
         {
            tcpstat.tcps_rcvduppack++;
            tcpstat.tcps_rcvdupbyte += ti->ti_len;
            GOTO_DROP;
         }
         m_adj (ti_mbuf, (int)i);
 8235708:	e17ff917 	ldw	r5,-28(fp)
 823570c:	e13fff17 	ldw	r4,-4(fp)
 8235710:	822e9cc0 	call	822e9cc <m_adj>
         ti->ti_len -= (short)i;
 8235714:	e0bffe17 	ldw	r2,-8(fp)
 8235718:	1080028b 	ldhu	r2,10(r2)
 823571c:	e0fff917 	ldw	r3,-28(fp)
 8235720:	10c5c83a 	sub	r2,r2,r3
 8235724:	1007883a 	mov	r3,r2
 8235728:	e0bffe17 	ldw	r2,-8(fp)
 823572c:	10c0028d 	sth	r3,10(r2)
         ti->ti_seq += (tcp_seq)i;
 8235730:	e0bffe17 	ldw	r2,-8(fp)
 8235734:	10c00617 	ldw	r3,24(r2)
 8235738:	e0bff917 	ldw	r2,-28(fp)
 823573c:	1887883a 	add	r3,r3,r2
 8235740:	e0bffe17 	ldw	r2,-8(fp)
 8235744:	10c00615 	stw	r3,24(r2)
      }
      q = (struct tcpiphdr *)(q->ti_next);
 8235748:	e0bff717 	ldw	r2,-36(fp)
 823574c:	10800017 	ldw	r2,0(r2)
 8235750:	e0bff715 	stw	r2,-36(fp)
   }
   tcpstat.tcps_rcvoopack++;
 8235754:	008209b4 	movhi	r2,2086
 8235758:	10b9ad04 	addi	r2,r2,-6476
 823575c:	10802317 	ldw	r2,140(r2)
 8235760:	10c00044 	addi	r3,r2,1
 8235764:	008209b4 	movhi	r2,2086
 8235768:	10b9ad04 	addi	r2,r2,-6476
 823576c:	10c02315 	stw	r3,140(r2)
   tcpstat.tcps_rcvoobyte += ti->ti_len;
 8235770:	008209b4 	movhi	r2,2086
 8235774:	10b9ad04 	addi	r2,r2,-6476
 8235778:	10c02417 	ldw	r3,144(r2)
 823577c:	e0bffe17 	ldw	r2,-8(fp)
 8235780:	1080028b 	ldhu	r2,10(r2)
 8235784:	10bfffcc 	andi	r2,r2,65535
 8235788:	1887883a 	add	r3,r3,r2
 823578c:	008209b4 	movhi	r2,2086
 8235790:	10b9ad04 	addi	r2,r2,-6476
 8235794:	10c02415 	stw	r3,144(r2)

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 8235798:	00003206 	br	8235864 <tcp_reass+0x298>
   {
      int   i  =  (int)((ti->ti_seq +  ti->ti_len) -  q->ti_seq);
 823579c:	e0bffe17 	ldw	r2,-8(fp)
 82357a0:	10c00617 	ldw	r3,24(r2)
 82357a4:	e0bffe17 	ldw	r2,-8(fp)
 82357a8:	1080028b 	ldhu	r2,10(r2)
 82357ac:	10bfffcc 	andi	r2,r2,65535
 82357b0:	1887883a 	add	r3,r3,r2
 82357b4:	e0bff717 	ldw	r2,-36(fp)
 82357b8:	10800617 	ldw	r2,24(r2)
 82357bc:	1885c83a 	sub	r2,r3,r2
 82357c0:	e0bffa15 	stw	r2,-24(fp)
      if (i <= 0)
 82357c4:	e0bffa17 	ldw	r2,-24(fp)
 82357c8:	00802a0e 	bge	zero,r2,8235874 <tcp_reass+0x2a8>
         break;
      if (i < (int)(q->ti_len))
 82357cc:	e0bff717 	ldw	r2,-36(fp)
 82357d0:	1080028b 	ldhu	r2,10(r2)
 82357d4:	10bfffcc 	andi	r2,r2,65535
 82357d8:	e0fffa17 	ldw	r3,-24(fp)
 82357dc:	1880130e 	bge	r3,r2,823582c <tcp_reass+0x260>
      {
         q->ti_seq += i;
 82357e0:	e0bff717 	ldw	r2,-36(fp)
 82357e4:	10c00617 	ldw	r3,24(r2)
 82357e8:	e0bffa17 	ldw	r2,-24(fp)
 82357ec:	1887883a 	add	r3,r3,r2
 82357f0:	e0bff717 	ldw	r2,-36(fp)
 82357f4:	10c00615 	stw	r3,24(r2)
         q->ti_len -= (u_short)i;
 82357f8:	e0bff717 	ldw	r2,-36(fp)
 82357fc:	1080028b 	ldhu	r2,10(r2)
 8235800:	e0fffa17 	ldw	r3,-24(fp)
 8235804:	10c5c83a 	sub	r2,r2,r3
 8235808:	1007883a 	mov	r3,r2
 823580c:	e0bff717 	ldw	r2,-36(fp)
 8235810:	10c0028d 	sth	r3,10(r2)
         m_adj (dtom(q), (int)i);
 8235814:	e13ff717 	ldw	r4,-36(fp)
 8235818:	822ebe00 	call	822ebe0 <dtom>
 823581c:	e17ffa17 	ldw	r5,-24(fp)
 8235820:	1009883a 	mov	r4,r2
 8235824:	822e9cc0 	call	822e9cc <m_adj>
         break;
 8235828:	00001306 	br	8235878 <tcp_reass+0x2ac>
      }
      q = (struct tcpiphdr *)q->ti_next;
 823582c:	e0bff717 	ldw	r2,-36(fp)
 8235830:	10800017 	ldw	r2,0(r2)
 8235834:	e0bff715 	stw	r2,-36(fp)
      m = dtom(q->ti_prev);
 8235838:	e0bff717 	ldw	r2,-36(fp)
 823583c:	10800117 	ldw	r2,4(r2)
 8235840:	1009883a 	mov	r4,r2
 8235844:	822ebe00 	call	822ebe0 <dtom>
 8235848:	e0bffb15 	stw	r2,-20(fp)
      remque (q->ti_prev);
 823584c:	e0bff717 	ldw	r2,-36(fp)
 8235850:	10800117 	ldw	r2,4(r2)
 8235854:	1009883a 	mov	r4,r2
 8235858:	822ec7c0 	call	822ec7c <remque>
      m_freem (m);
 823585c:	e13ffb17 	ldw	r4,-20(fp)
 8235860:	822e6940 	call	822e694 <m_freem>

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 8235864:	e0fff717 	ldw	r3,-36(fp)
 8235868:	e0bffd17 	ldw	r2,-12(fp)
 823586c:	18bfcb1e 	bne	r3,r2,823579c <tcp_reass+0x1d0>
 8235870:	00000106 	br	8235878 <tcp_reass+0x2ac>
   {
      int   i  =  (int)((ti->ti_seq +  ti->ti_len) -  q->ti_seq);
      if (i <= 0)
         break;
 8235874:	0001883a 	nop
   }

   /*
    * Stick new segment in its place.
    */
   insque(ti, q->ti_prev);
 8235878:	e0bff717 	ldw	r2,-36(fp)
 823587c:	10800117 	ldw	r2,4(r2)
 8235880:	100b883a 	mov	r5,r2
 8235884:	e13ffe17 	ldw	r4,-8(fp)
 8235888:	822ecec0 	call	822ecec <insque>
 823588c:	00000106 	br	8235894 <tcp_reass+0x2c8>
   /*
    * Call with ti==0 after become established to
    * force pre-ESTABLISHED data up to user socket.
    */
   if (ti == 0)
      goto present;
 8235890:	0001883a 	nop
present:
   /*
    * Present data to user, advancing rcv_nxt through
    * completed sequence space.
    */
   if (TCPS_HAVERCVDSYN (tp->t_state) == 0)
 8235894:	e0bffd17 	ldw	r2,-12(fp)
 8235898:	10800217 	ldw	r2,8(r2)
 823589c:	108000c8 	cmpgei	r2,r2,3
 82358a0:	1000021e 	bne	r2,zero,82358ac <tcp_reass+0x2e0>
      return (0);
 82358a4:	0005883a 	mov	r2,zero
 82358a8:	00004706 	br	82359c8 <tcp_reass+0x3fc>
   ti = tp->seg_next;
 82358ac:	e0bffd17 	ldw	r2,-12(fp)
 82358b0:	10800017 	ldw	r2,0(r2)
 82358b4:	e0bffe15 	stw	r2,-8(fp)
   if (ti == (struct tcpiphdr *)tp || ti->ti_seq != tp->rcv_nxt)
 82358b8:	e0fffe17 	ldw	r3,-8(fp)
 82358bc:	e0bffd17 	ldw	r2,-12(fp)
 82358c0:	18800526 	beq	r3,r2,82358d8 <tcp_reass+0x30c>
 82358c4:	e0bffe17 	ldw	r2,-8(fp)
 82358c8:	10c00617 	ldw	r3,24(r2)
 82358cc:	e0bffd17 	ldw	r2,-12(fp)
 82358d0:	10801617 	ldw	r2,88(r2)
 82358d4:	18800226 	beq	r3,r2,82358e0 <tcp_reass+0x314>
      return (0);
 82358d8:	0005883a 	mov	r2,zero
 82358dc:	00003a06 	br	82359c8 <tcp_reass+0x3fc>
   if (tp->t_state == TCPS_SYN_RECEIVED && ti->ti_len)
 82358e0:	e0bffd17 	ldw	r2,-12(fp)
 82358e4:	10800217 	ldw	r2,8(r2)
 82358e8:	108000d8 	cmpnei	r2,r2,3
 82358ec:	1000061e 	bne	r2,zero,8235908 <tcp_reass+0x33c>
 82358f0:	e0bffe17 	ldw	r2,-8(fp)
 82358f4:	1080028b 	ldhu	r2,10(r2)
 82358f8:	10bfffcc 	andi	r2,r2,65535
 82358fc:	10000226 	beq	r2,zero,8235908 <tcp_reass+0x33c>
      return (0);
 8235900:	0005883a 	mov	r2,zero
 8235904:	00003006 	br	82359c8 <tcp_reass+0x3fc>
   do 
   {
      tp->rcv_nxt += ti->ti_len;
 8235908:	e0bffd17 	ldw	r2,-12(fp)
 823590c:	10c01617 	ldw	r3,88(r2)
 8235910:	e0bffe17 	ldw	r2,-8(fp)
 8235914:	1080028b 	ldhu	r2,10(r2)
 8235918:	10bfffcc 	andi	r2,r2,65535
 823591c:	1887883a 	add	r3,r3,r2
 8235920:	e0bffd17 	ldw	r2,-12(fp)
 8235924:	10c01615 	stw	r3,88(r2)
      flags = ti->ti_flags & TH_FIN;
 8235928:	e0bffe17 	ldw	r2,-8(fp)
 823592c:	10800843 	ldbu	r2,33(r2)
 8235930:	10803fcc 	andi	r2,r2,255
 8235934:	1080004c 	andi	r2,r2,1
 8235938:	e0bffc15 	stw	r2,-16(fp)
      remque(ti);
 823593c:	e13ffe17 	ldw	r4,-8(fp)
 8235940:	822ec7c0 	call	822ec7c <remque>
      m = dtom(ti);
 8235944:	e13ffe17 	ldw	r4,-8(fp)
 8235948:	822ebe00 	call	822ebe0 <dtom>
 823594c:	e0bffb15 	stw	r2,-20(fp)
      ti = (struct tcpiphdr *)ti->ti_next;
 8235950:	e0bffe17 	ldw	r2,-8(fp)
 8235954:	10800017 	ldw	r2,0(r2)
 8235958:	e0bffe15 	stw	r2,-8(fp)
      if (so->so_state & SS_CANTRCVMORE)
 823595c:	e0bff817 	ldw	r2,-32(fp)
 8235960:	1080088b 	ldhu	r2,34(r2)
 8235964:	10bfffcc 	andi	r2,r2,65535
 8235968:	1080080c 	andi	r2,r2,32
 823596c:	10000326 	beq	r2,zero,823597c <tcp_reass+0x3b0>
         m_freem (m);
 8235970:	e13ffb17 	ldw	r4,-20(fp)
 8235974:	822e6940 	call	822e694 <m_freem>
 8235978:	00000506 	br	8235990 <tcp_reass+0x3c4>
      else
         sbappend (&so->so_rcv, m);
 823597c:	e0bff817 	ldw	r2,-32(fp)
 8235980:	10800a04 	addi	r2,r2,40
 8235984:	e17ffb17 	ldw	r5,-20(fp)
 8235988:	1009883a 	mov	r4,r2
 823598c:	82344500 	call	8234450 <sbappend>
   } while (ti != (struct tcpiphdr *)tp && ti->ti_seq == tp->rcv_nxt);
 8235990:	e0fffe17 	ldw	r3,-8(fp)
 8235994:	e0bffd17 	ldw	r2,-12(fp)
 8235998:	18800526 	beq	r3,r2,82359b0 <tcp_reass+0x3e4>
 823599c:	e0bffe17 	ldw	r2,-8(fp)
 82359a0:	10c00617 	ldw	r3,24(r2)
 82359a4:	e0bffd17 	ldw	r2,-12(fp)
 82359a8:	10801617 	ldw	r2,88(r2)
 82359ac:	18bfd626 	beq	r3,r2,8235908 <tcp_reass+0x33c>
      sorwakeup(so);
 82359b0:	e0bff817 	ldw	r2,-32(fp)
 82359b4:	10800a04 	addi	r2,r2,40
 82359b8:	100b883a 	mov	r5,r2
 82359bc:	e13ff817 	ldw	r4,-32(fp)
 82359c0:	82342a00 	call	82342a0 <sbwakeup>
   return (flags);
 82359c4:	e0bffc17 	ldw	r2,-16(fp)
drop:
   /**m_freem (dtom(ti));**/
   m_freem (ti_mbuf);
   return (0);
}
 82359c8:	e037883a 	mov	sp,fp
 82359cc:	dfc00117 	ldw	ra,4(sp)
 82359d0:	df000017 	ldw	fp,0(sp)
 82359d4:	dec00204 	addi	sp,sp,8
 82359d8:	f800283a 	ret

082359dc <tcp_input>:
 * RETURNS: void
 */

void
tcp_input(struct mbuf * m, NET ifp)
{
 82359dc:	deffdf04 	addi	sp,sp,-132
 82359e0:	dfc02015 	stw	ra,128(sp)
 82359e4:	df001f15 	stw	fp,124(sp)
 82359e8:	df001f04 	addi	fp,sp,124
 82359ec:	e13ffe15 	stw	r4,-8(fp)
 82359f0:	e17fff15 	stw	r5,-4(fp)
   ip6_addr    ip6_src;
   ip6_addr    ip6_dst;
#endif   /* IP_V6 */
   struct tcpiphdr * ti;
   struct inpcb * inp;
   struct mbuf *  om =  0;
 82359f4:	e03fe515 	stw	zero,-108(fp)
   int   len,  tlen, off;
   struct tcpcb * tp =  0;
 82359f8:	e03fe615 	stw	zero,-104(fp)
   int   tiflags;
   struct socket *   so =  NULL;
 82359fc:	e03fe815 	stw	zero,-96(fp)
   int   todrop,  acked,   ourfinisacked, needoutput  =  0;
 8235a00:	e03feb15 	stw	zero,-84(fp)
   int   dropsocket  =  0;
 8235a04:	e03fec15 	stw	zero,-80(fp)
   long  iss   =  0;
 8235a08:	e03fed15 	stw	zero,-76(fp)
#ifdef DO_TCPTRACE
   int   ostate;
#endif


   tcpstat.tcps_rcvtotal++;
 8235a0c:	008209b4 	movhi	r2,2086
 8235a10:	10b9ad04 	addi	r2,r2,-6476
 8235a14:	10801917 	ldw	r2,100(r2)
 8235a18:	10c00044 	addi	r3,r2,1
 8235a1c:	008209b4 	movhi	r2,2086
 8235a20:	10b9ad04 	addi	r2,r2,-6476
 8235a24:	10c01915 	stw	r3,100(r2)
   TCP_MIB_INC(tcpInSegs);    /* keep MIB stats */
 8235a28:	008209b4 	movhi	r2,2086
 8235a2c:	10b97f04 	addi	r2,r2,-6660
 8235a30:	10800917 	ldw	r2,36(r2)
 8235a34:	10c00044 	addi	r3,r2,1
 8235a38:	008209b4 	movhi	r2,2086
 8235a3c:	10b97f04 	addi	r2,r2,-6660
 8235a40:	10c00915 	stw	r3,36(r2)
   {
      /*
       * Get IP and TCP header together in first mbuf.
       * Note: IP leaves IP header in first mbuf.
       */
      pip = mtod(m, struct ip *);
 8235a44:	e0bffe17 	ldw	r2,-8(fp)
 8235a48:	10800317 	ldw	r2,12(r2)
 8235a4c:	e0bfe315 	stw	r2,-116(fp)
      if (pip->ip_ver_ihl > 0x45)   /* IP v4, 5 dword hdr len */
 8235a50:	e0bfe317 	ldw	r2,-116(fp)
 8235a54:	10800003 	ldbu	r2,0(r2)
 8235a58:	10803fcc 	andi	r2,r2,255
 8235a5c:	108011b0 	cmpltui	r2,r2,70
 8235a60:	1000061e 	bne	r2,zero,8235a7c <tcp_input+0xa0>
      {
         np_stripoptions(pip, (struct mbuf *)m);
 8235a64:	e17ffe17 	ldw	r5,-8(fp)
 8235a68:	e13fe317 	ldw	r4,-116(fp)
 8235a6c:	822f6180 	call	822f618 <np_stripoptions>
         pip = mtod(m, struct ip *);
 8235a70:	e0bffe17 	ldw	r2,-8(fp)
 8235a74:	10800317 	ldw	r2,12(r2)
 8235a78:	e0bfe315 	stw	r2,-116(fp)
      }
      if (m->m_len < ((sizeof (struct ip) + sizeof (struct tcphdr))))
 8235a7c:	e0bffe17 	ldw	r2,-8(fp)
 8235a80:	10800217 	ldw	r2,8(r2)
 8235a84:	10800a28 	cmpgeui	r2,r2,40
 8235a88:	1000081e 	bne	r2,zero,8235aac <tcp_input+0xd0>
      {
         tcpstat.tcps_rcvshort++;
 8235a8c:	008209b4 	movhi	r2,2086
 8235a90:	10b9ad04 	addi	r2,r2,-6476
 8235a94:	10801e17 	ldw	r2,120(r2)
 8235a98:	10c00044 	addi	r3,r2,1
 8235a9c:	008209b4 	movhi	r2,2086
 8235aa0:	10b9ad04 	addi	r2,r2,-6476
 8235aa4:	10c01e15 	stw	r3,120(r2)
         return;
 8235aa8:	00089306 	br	8237cf8 <tcp_input+0x231c>
      }
      tlen = pip->ip_len;     /* this was fudged by IP layer */
 8235aac:	e0bfe317 	ldw	r2,-116(fp)
 8235ab0:	1080008b 	ldhu	r2,2(r2)
 8235ab4:	10bfffcc 	andi	r2,r2,65535
 8235ab8:	e0bff115 	stw	r2,-60(fp)
      /* The following is needed in the cases where the size of the
       * overlay structure is larger than the size of the ip header.
       * This can happen if the ih_next and ih_prev pointers in the
       * overlay structure are larger than 32 bit pointers.
       */
      ti = (struct tcpiphdr *)(m->m_data + sizeof(struct ip) - 
 8235abc:	e0bffe17 	ldw	r2,-8(fp)
 8235ac0:	10800317 	ldw	r2,12(r2)
 8235ac4:	e0bff215 	stw	r2,-56(fp)
         sizeof(struct ipovly));
      if ((char *)ti < m->pkt->nb_buff)
 8235ac8:	e0bffe17 	ldw	r2,-8(fp)
 8235acc:	10800117 	ldw	r2,4(r2)
 8235ad0:	10800117 	ldw	r2,4(r2)
 8235ad4:	e0fff217 	ldw	r3,-56(fp)
 8235ad8:	1880032e 	bgeu	r3,r2,8235ae8 <tcp_input+0x10c>
      {
         panic("tcp_input");
 8235adc:	01020974 	movhi	r4,2085
 8235ae0:	2103bc04 	addi	r4,r4,3824
 8235ae4:	8228ca40 	call	8228ca4 <panic>
   /*
    * Check that TCP offset makes sense,
    * pull out TCP options and adjust length.
    */

   off = GET_TH_OFF(ti->ti_t) << 2;
 8235ae8:	e0bff217 	ldw	r2,-56(fp)
 8235aec:	10800803 	ldbu	r2,32(r2)
 8235af0:	10803fcc 	andi	r2,r2,255
 8235af4:	1004d13a 	srli	r2,r2,4
 8235af8:	10803fcc 	andi	r2,r2,255
 8235afc:	1085883a 	add	r2,r2,r2
 8235b00:	1085883a 	add	r2,r2,r2
 8235b04:	e0bff315 	stw	r2,-52(fp)
   if (off < sizeof (struct tcphdr) || off > tlen) 
 8235b08:	e0bff317 	ldw	r2,-52(fp)
 8235b0c:	10800530 	cmpltui	r2,r2,20
 8235b10:	1000031e 	bne	r2,zero,8235b20 <tcp_input+0x144>
 8235b14:	e0bff317 	ldw	r2,-52(fp)
 8235b18:	e0fff117 	ldw	r3,-60(fp)
 8235b1c:	1880110e 	bge	r3,r2,8235b64 <tcp_input+0x188>
   {
#ifdef DO_TCPTRACE
      tcp_trace("tcp off: src %x off %d\n", ti->ti_src, off);
#endif
      tcpstat.tcps_rcvbadoff++;
 8235b20:	008209b4 	movhi	r2,2086
 8235b24:	10b9ad04 	addi	r2,r2,-6476
 8235b28:	10801d17 	ldw	r2,116(r2)
 8235b2c:	10c00044 	addi	r3,r2,1
 8235b30:	008209b4 	movhi	r2,2086
 8235b34:	10b9ad04 	addi	r2,r2,-6476
 8235b38:	10c01d15 	stw	r3,116(r2)
      TCP_MIB_INC(tcpInErrs);   /* keep MIB stats */
 8235b3c:	008209b4 	movhi	r2,2086
 8235b40:	10b97f04 	addi	r2,r2,-6660
 8235b44:	10800d17 	ldw	r2,52(r2)
 8235b48:	10c00044 	addi	r3,r2,1
 8235b4c:	008209b4 	movhi	r2,2086
 8235b50:	10b97f04 	addi	r2,r2,-6660
 8235b54:	10c00d15 	stw	r3,52(r2)
      GOTO_DROP;
 8235b58:	00805784 	movi	r2,350
 8235b5c:	d0a0b215 	stw	r2,-32056(gp)
 8235b60:	00085006 	br	8237ca4 <tcp_input+0x22c8>
   }
   tlen -= (int)off;
 8235b64:	e0fff117 	ldw	r3,-60(fp)
 8235b68:	e0bff317 	ldw	r2,-52(fp)
 8235b6c:	1885c83a 	sub	r2,r3,r2
 8235b70:	e0bff115 	stw	r2,-60(fp)
   ti->ti_len = (u_short)tlen;
 8235b74:	e0bff117 	ldw	r2,-60(fp)
 8235b78:	1007883a 	mov	r3,r2
 8235b7c:	e0bff217 	ldw	r2,-56(fp)
 8235b80:	10c0028d 	sth	r3,10(r2)
   if (off > sizeof (struct tcphdr)) 
 8235b84:	e0bff317 	ldw	r2,-52(fp)
 8235b88:	10800570 	cmpltui	r2,r2,21
 8235b8c:	1000331e 	bne	r2,zero,8235c5c <tcp_input+0x280>
   {
      int olen;      /* length of options field */
      u_char * op;   /* scratch option pointer */

      olen = off - sizeof (struct tcphdr);   /* get options length */
 8235b90:	e0bff317 	ldw	r2,-52(fp)
 8235b94:	10bffb04 	addi	r2,r2,-20
 8235b98:	e0bff415 	stw	r2,-48(fp)
      om = m_getwithdata (MT_RXDATA, olen);  /* get mbuf for opts */
 8235b9c:	e17ff417 	ldw	r5,-48(fp)
 8235ba0:	01000044 	movi	r4,1
 8235ba4:	822e4040 	call	822e404 <m_getnbuf>
 8235ba8:	e0bfe515 	stw	r2,-108(fp)
      if (om == 0)
 8235bac:	e0bfe517 	ldw	r2,-108(fp)
 8235bb0:	1000031e 	bne	r2,zero,8235bc0 <tcp_input+0x1e4>
         GOTO_DROP;
 8235bb4:	00805a84 	movi	r2,362
 8235bb8:	d0a0b215 	stw	r2,-32056(gp)
 8235bbc:	00083906 	br	8237ca4 <tcp_input+0x22c8>
      om->m_len = olen;       /* set mbuf length */
 8235bc0:	e0fff417 	ldw	r3,-48(fp)
 8235bc4:	e0bfe517 	ldw	r2,-108(fp)
 8235bc8:	10c00215 	stw	r3,8(r2)
      /* set pointer to options field at end of TCP header */
      if(m->pkt->type == htons(0x86DD))   /* IPv6 packet */
 8235bcc:	e0bffe17 	ldw	r2,-8(fp)
 8235bd0:	10800117 	ldw	r2,4(r2)
 8235bd4:	1080080b 	ldhu	r2,32(r2)
 8235bd8:	10ffffcc 	andi	r3,r2,65535
 8235bdc:	00b76194 	movui	r2,56710
 8235be0:	1880051e 	bne	r3,r2,8235bf8 <tcp_input+0x21c>
         op = (u_char*)(m->m_data + 20);  /* past TCP header */
 8235be4:	e0bffe17 	ldw	r2,-8(fp)
 8235be8:	10800317 	ldw	r2,12(r2)
 8235bec:	10800504 	addi	r2,r2,20
 8235bf0:	e0bfee15 	stw	r2,-72(fp)
 8235bf4:	00000406 	br	8235c08 <tcp_input+0x22c>
      else
         op = (u_char*)(m->m_data + 40);  /* past IP + TCP */
 8235bf8:	e0bffe17 	ldw	r2,-8(fp)
 8235bfc:	10800317 	ldw	r2,12(r2)
 8235c00:	10800a04 	addi	r2,r2,40
 8235c04:	e0bfee15 	stw	r2,-72(fp)
      MEMCPY(om->m_data, op, olen); /* copy to new mbuf */
 8235c08:	e0bfe517 	ldw	r2,-108(fp)
 8235c0c:	10800317 	ldw	r2,12(r2)
 8235c10:	e0fff417 	ldw	r3,-48(fp)
 8235c14:	180d883a 	mov	r6,r3
 8235c18:	e17fee17 	ldw	r5,-72(fp)
 8235c1c:	1009883a 	mov	r4,r2
 8235c20:	8202f6c0 	call	8202f6c <memcpy>

      /* strip options from data mbuf. This actually just cuts the first 
       * m_len bytes from the TCP header, but it leaves the mbuf members 
       * set so the adjustment below does the right thing.
       */
      m->m_data += om->m_len;
 8235c24:	e0bffe17 	ldw	r2,-8(fp)
 8235c28:	10c00317 	ldw	r3,12(r2)
 8235c2c:	e0bfe517 	ldw	r2,-108(fp)
 8235c30:	10800217 	ldw	r2,8(r2)
 8235c34:	1887883a 	add	r3,r3,r2
 8235c38:	e0bffe17 	ldw	r2,-8(fp)
 8235c3c:	10c00315 	stw	r3,12(r2)
      m->m_len -= om->m_len;
 8235c40:	e0bffe17 	ldw	r2,-8(fp)
 8235c44:	10c00217 	ldw	r3,8(r2)
 8235c48:	e0bfe517 	ldw	r2,-108(fp)
 8235c4c:	10800217 	ldw	r2,8(r2)
 8235c50:	1887c83a 	sub	r3,r3,r2
 8235c54:	e0bffe17 	ldw	r2,-8(fp)
 8235c58:	10c00215 	stw	r3,8(r2)
   }
   tiflags = ti->ti_flags;
 8235c5c:	e0bff217 	ldw	r2,-56(fp)
 8235c60:	10800843 	ldbu	r2,33(r2)
 8235c64:	10803fcc 	andi	r2,r2,255
 8235c68:	e0bfe715 	stw	r2,-100(fp)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   /* Convert TCP protocol specific fields to host format. */
   ti->ti_seq = ntohl(ti->ti_seq);
 8235c6c:	e0bff217 	ldw	r2,-56(fp)
 8235c70:	10800617 	ldw	r2,24(r2)
 8235c74:	1006d63a 	srli	r3,r2,24
 8235c78:	e0bff217 	ldw	r2,-56(fp)
 8235c7c:	10800617 	ldw	r2,24(r2)
 8235c80:	1004d23a 	srli	r2,r2,8
 8235c84:	10bfc00c 	andi	r2,r2,65280
 8235c88:	1886b03a 	or	r3,r3,r2
 8235c8c:	e0bff217 	ldw	r2,-56(fp)
 8235c90:	10800617 	ldw	r2,24(r2)
 8235c94:	10bfc00c 	andi	r2,r2,65280
 8235c98:	1004923a 	slli	r2,r2,8
 8235c9c:	1886b03a 	or	r3,r3,r2
 8235ca0:	e0bff217 	ldw	r2,-56(fp)
 8235ca4:	10800617 	ldw	r2,24(r2)
 8235ca8:	1004963a 	slli	r2,r2,24
 8235cac:	1886b03a 	or	r3,r3,r2
 8235cb0:	e0bff217 	ldw	r2,-56(fp)
 8235cb4:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = ntohl(ti->ti_ack);
 8235cb8:	e0bff217 	ldw	r2,-56(fp)
 8235cbc:	10800717 	ldw	r2,28(r2)
 8235cc0:	1006d63a 	srli	r3,r2,24
 8235cc4:	e0bff217 	ldw	r2,-56(fp)
 8235cc8:	10800717 	ldw	r2,28(r2)
 8235ccc:	1004d23a 	srli	r2,r2,8
 8235cd0:	10bfc00c 	andi	r2,r2,65280
 8235cd4:	1886b03a 	or	r3,r3,r2
 8235cd8:	e0bff217 	ldw	r2,-56(fp)
 8235cdc:	10800717 	ldw	r2,28(r2)
 8235ce0:	10bfc00c 	andi	r2,r2,65280
 8235ce4:	1004923a 	slli	r2,r2,8
 8235ce8:	1886b03a 	or	r3,r3,r2
 8235cec:	e0bff217 	ldw	r2,-56(fp)
 8235cf0:	10800717 	ldw	r2,28(r2)
 8235cf4:	1004963a 	slli	r2,r2,24
 8235cf8:	1886b03a 	or	r3,r3,r2
 8235cfc:	e0bff217 	ldw	r2,-56(fp)
 8235d00:	10c00715 	stw	r3,28(r2)
   ti->ti_urp = ntohs(ti->ti_urp);
 8235d04:	e0bff217 	ldw	r2,-56(fp)
 8235d08:	1080098b 	ldhu	r2,38(r2)
 8235d0c:	10bfffcc 	andi	r2,r2,65535
 8235d10:	1004d23a 	srli	r2,r2,8
 8235d14:	1007883a 	mov	r3,r2
 8235d18:	e0bff217 	ldw	r2,-56(fp)
 8235d1c:	1080098b 	ldhu	r2,38(r2)
 8235d20:	10bfffcc 	andi	r2,r2,65535
 8235d24:	1004923a 	slli	r2,r2,8
 8235d28:	1884b03a 	or	r2,r3,r2
 8235d2c:	1007883a 	mov	r3,r2
 8235d30:	e0bff217 	ldw	r2,-56(fp)
 8235d34:	10c0098d 	sth	r3,38(r2)
   /*
    * Locate pcb for segment.
    */
findpcb:

   switch(m->pkt->type)
 8235d38:	e0bffe17 	ldw	r2,-8(fp)
 8235d3c:	10800117 	ldw	r2,4(r2)
 8235d40:	1080080b 	ldhu	r2,32(r2)
 8235d44:	10bfffcc 	andi	r2,r2,65535
 8235d48:	10800220 	cmpeqi	r2,r2,8
 8235d4c:	10002226 	beq	r2,zero,8235dd8 <tcp_input+0x3fc>
   {
#ifdef IP_V4
   case  IPTP:   /* IPv4 packet */
      /* Drop TCP and IP headers; TCP options were dropped above. */
      m->m_data += 40;
 8235d50:	e0bffe17 	ldw	r2,-8(fp)
 8235d54:	10800317 	ldw	r2,12(r2)
 8235d58:	10c00a04 	addi	r3,r2,40
 8235d5c:	e0bffe17 	ldw	r2,-8(fp)
 8235d60:	10c00315 	stw	r3,12(r2)
      m->m_len -= 40;
 8235d64:	e0bffe17 	ldw	r2,-8(fp)
 8235d68:	10800217 	ldw	r2,8(r2)
 8235d6c:	10fff604 	addi	r3,r2,-40
 8235d70:	e0bffe17 	ldw	r2,-8(fp)
 8235d74:	10c00215 	stw	r3,8(r2)

      inp = in_pcblookup(&tcb, ti->ti_src.s_addr, ti->ti_sport, 
 8235d78:	e0bff217 	ldw	r2,-56(fp)
 8235d7c:	11000317 	ldw	r4,12(r2)
 8235d80:	e0bff217 	ldw	r2,-56(fp)
 8235d84:	1080050b 	ldhu	r2,20(r2)
 8235d88:	117fffcc 	andi	r5,r2,65535
 8235d8c:	e0bff217 	ldw	r2,-56(fp)
 8235d90:	11800417 	ldw	r6,16(r2)
         ti->ti_dst.s_addr, ti->ti_dport, INPLOOKUP_WILDCARD);
 8235d94:	e0bff217 	ldw	r2,-56(fp)
 8235d98:	1080058b 	ldhu	r2,22(r2)
   case  IPTP:   /* IPv4 packet */
      /* Drop TCP and IP headers; TCP options were dropped above. */
      m->m_data += 40;
      m->m_len -= 40;

      inp = in_pcblookup(&tcb, ti->ti_src.s_addr, ti->ti_sport, 
 8235d9c:	10bfffcc 	andi	r2,r2,65535
 8235da0:	00c00044 	movi	r3,1
 8235da4:	d8c00115 	stw	r3,4(sp)
 8235da8:	d8800015 	stw	r2,0(sp)
 8235dac:	300f883a 	mov	r7,r6
 8235db0:	280d883a 	mov	r6,r5
 8235db4:	200b883a 	mov	r5,r4
 8235db8:	010209b4 	movhi	r4,2086
 8235dbc:	2139a204 	addi	r4,r4,-6520
 8235dc0:	82484c80 	call	82484c8 <in_pcblookup>
 8235dc4:	e0bfe415 	stw	r2,-112(fp)
         ti->ti_dst.s_addr, ti->ti_dport, INPLOOKUP_WILDCARD);
      break;
 8235dc8:	0001883a 	nop
    * If the state is CLOSED (i.e., TCB does not exist) then
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
 8235dcc:	e0bfe417 	ldw	r2,-112(fp)
 8235dd0:	1000061e 	bne	r2,zero,8235dec <tcp_input+0x410>
 8235dd4:	00000206 	br	8235de0 <tcp_input+0x404>
      inp = ip6_pcblookup(&tcb, &ip6_src, ti->ti_sport, 
         &ip6_dst, ti->ti_dport, INPLOOKUP_WILDCARD);
      break;
#endif   /* IP_V6 */
   default:
      dtrap();
 8235dd8:	822d5f00 	call	822d5f0 <dtrap>
      return;
 8235ddc:	0007c606 	br	8237cf8 <tcp_input+0x231c>
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
      GOTO_DROPWITHRESET;
 8235de0:	00806b04 	movi	r2,428
 8235de4:	d0a0b215 	stw	r2,-32056(gp)
 8235de8:	00076d06 	br	8237ba0 <tcp_input+0x21c4>
   tp = intotcpcb (inp);
 8235dec:	e0bfe417 	ldw	r2,-112(fp)
 8235df0:	10800917 	ldw	r2,36(r2)
 8235df4:	e0bfe615 	stw	r2,-104(fp)
   if (tp == 0)
 8235df8:	e0bfe617 	ldw	r2,-104(fp)
 8235dfc:	1000031e 	bne	r2,zero,8235e0c <tcp_input+0x430>
      GOTO_DROPWITHRESET;
 8235e00:	00806bc4 	movi	r2,431
 8235e04:	d0a0b215 	stw	r2,-32056(gp)
 8235e08:	00076506 	br	8237ba0 <tcp_input+0x21c4>
   if (tp->t_state == TCPS_CLOSED)
 8235e0c:	e0bfe617 	ldw	r2,-104(fp)
 8235e10:	10800217 	ldw	r2,8(r2)
 8235e14:	1000031e 	bne	r2,zero,8235e24 <tcp_input+0x448>
      GOTO_DROP;
 8235e18:	00806c44 	movi	r2,433
 8235e1c:	d0a0b215 	stw	r2,-32056(gp)
 8235e20:	0007a006 	br	8237ca4 <tcp_input+0x22c8>
   so = inp->inp_socket;
 8235e24:	e0bfe417 	ldw	r2,-112(fp)
 8235e28:	10800817 	ldw	r2,32(r2)
 8235e2c:	e0bfe815 	stw	r2,-96(fp)
      tcp_saveti = *ti;
   }
#endif

   /* figure out the size of the other guy's receive window */
   rx_win = (tcp_win)(ntohs(ti->ti_win));    /* convert endian */
 8235e30:	e0bff217 	ldw	r2,-56(fp)
 8235e34:	1080088b 	ldhu	r2,34(r2)
 8235e38:	10bfffcc 	andi	r2,r2,65535
 8235e3c:	1004d23a 	srli	r2,r2,8
 8235e40:	10bfffcc 	andi	r2,r2,65535
 8235e44:	10c03fcc 	andi	r3,r2,255
 8235e48:	e0bff217 	ldw	r2,-56(fp)
 8235e4c:	1080088b 	ldhu	r2,34(r2)
 8235e50:	10bfffcc 	andi	r2,r2,65535
 8235e54:	1004923a 	slli	r2,r2,8
 8235e58:	10bfffcc 	andi	r2,r2,65535
 8235e5c:	1884b03a 	or	r2,r3,r2
 8235e60:	e0bff515 	stw	r2,-44(fp)
   {
      rx_win <<= tp->snd_wind_scale;         /* apply scale */
   }
#endif /* TCP_WIN_SCALE */

   if (so->so_options & SO_ACCEPTCONN) 
 8235e64:	e0bfe817 	ldw	r2,-96(fp)
 8235e68:	10800417 	ldw	r2,16(r2)
 8235e6c:	1080008c 	andi	r2,r2,2
 8235e70:	10002c26 	beq	r2,zero,8235f24 <tcp_input+0x548>
   {
      so = sonewconn(so);
 8235e74:	e13fe817 	ldw	r4,-96(fp)
 8235e78:	8233d940 	call	8233d94 <sonewconn>
 8235e7c:	e0bfe815 	stw	r2,-96(fp)
      if (so == 0)
 8235e80:	e0bfe817 	ldw	r2,-96(fp)
 8235e84:	1000031e 	bne	r2,zero,8235e94 <tcp_input+0x4b8>
         GOTO_DROP;
 8235e88:	00807344 	movi	r2,461
 8235e8c:	d0a0b215 	stw	r2,-32056(gp)
 8235e90:	00078406 	br	8237ca4 <tcp_input+0x22c8>
       * flag dropsocket to see if the temporary
       * socket created here should be discarded.
       * We mark the socket as discardable until
       * we're committed to it below in TCPS_LISTEN.
       */
      dropsocket++;
 8235e94:	e0bfec17 	ldw	r2,-80(fp)
 8235e98:	10800044 	addi	r2,r2,1
 8235e9c:	e0bfec15 	stw	r2,-80(fp)

      inp = (struct inpcb *)so->so_pcb;
 8235ea0:	e0bfe817 	ldw	r2,-96(fp)
 8235ea4:	10800117 	ldw	r2,4(r2)
 8235ea8:	e0bfe415 	stw	r2,-112(fp)
      inp->ifp = ifp;      /* save iface to peer */
 8235eac:	e0bfe417 	ldw	r2,-112(fp)
 8235eb0:	e0ffff17 	ldw	r3,-4(fp)
 8235eb4:	10c00a15 	stw	r3,40(r2)

      switch(so->so_domain)
 8235eb8:	e0bfe817 	ldw	r2,-96(fp)
 8235ebc:	10800517 	ldw	r2,20(r2)
 8235ec0:	108000a0 	cmpeqi	r2,r2,2
 8235ec4:	10000d26 	beq	r2,zero,8235efc <tcp_input+0x520>
      {
#ifdef IP_V4
      case AF_INET:
         inp->inp_laddr = ti->ti_dst;
 8235ec8:	e0bfe417 	ldw	r2,-112(fp)
 8235ecc:	e0fff217 	ldw	r3,-56(fp)
 8235ed0:	18c00417 	ldw	r3,16(r3)
 8235ed4:	10c00415 	stw	r3,16(r2)
#ifdef IP_PMTU
         inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
         inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 8235ed8:	e0bfff17 	ldw	r2,-4(fp)
 8235edc:	10c00917 	ldw	r3,36(r2)
 8235ee0:	e0bfff17 	ldw	r2,-4(fp)
 8235ee4:	10800817 	ldw	r2,32(r2)
 8235ee8:	10800a04 	addi	r2,r2,40
 8235eec:	1887c83a 	sub	r3,r3,r2
 8235ef0:	e0bfe417 	ldw	r2,-112(fp)
 8235ef4:	10c00615 	stw	r3,24(r2)
#endif   /* IP_PMTU */
         break;
 8235ef8:	0001883a 	nop
         inp->inp_pmtu = ip6_pmtulookup(&ip6_src, ifp);
         break;
#endif   /* end v6 */
      }

      inp->inp_lport = ti->ti_dport;
 8235efc:	e0bff217 	ldw	r2,-56(fp)
 8235f00:	10c0058b 	ldhu	r3,22(r2)
 8235f04:	e0bfe417 	ldw	r2,-112(fp)
 8235f08:	10c0078d 	sth	r3,30(r2)
      tp = intotcpcb(inp);
 8235f0c:	e0bfe417 	ldw	r2,-112(fp)
 8235f10:	10800917 	ldw	r2,36(r2)
 8235f14:	e0bfe615 	stw	r2,-104(fp)
      tp->t_state = TCPS_LISTEN;
 8235f18:	e0bfe617 	ldw	r2,-104(fp)
 8235f1c:	00c00044 	movi	r3,1
 8235f20:	10c00215 	stw	r3,8(r2)

   /*
    * Segment received on connection.
    * Reset idle time and keep-alive timer.
    */
   tp->t_idle = 0;
 8235f24:	e0bfe617 	ldw	r2,-104(fp)
 8235f28:	10001d15 	stw	zero,116(r2)
   tp->t_timer[TCPT_KEEP] = tcp_keepidle;
 8235f2c:	d0e03e17 	ldw	r3,-32520(gp)
 8235f30:	e0bfe617 	ldw	r2,-104(fp)
 8235f34:	10c00515 	stw	r3,20(r2)

   /*
    * Process options if not in LISTEN state,
    * else do it below (after getting remote address).
    */
   if (om && tp->t_state != TCPS_LISTEN) 
 8235f38:	e0bfe517 	ldw	r2,-108(fp)
 8235f3c:	10000926 	beq	r2,zero,8235f64 <tcp_input+0x588>
 8235f40:	e0bfe617 	ldw	r2,-104(fp)
 8235f44:	10800217 	ldw	r2,8(r2)
 8235f48:	10800060 	cmpeqi	r2,r2,1
 8235f4c:	1000051e 	bne	r2,zero,8235f64 <tcp_input+0x588>
   {
      tcp_dooptions(tp, om, ti);
 8235f50:	e1bff217 	ldw	r6,-56(fp)
 8235f54:	e17fe517 	ldw	r5,-108(fp)
 8235f58:	e13fe617 	ldw	r4,-104(fp)
 8235f5c:	8237d0c0 	call	8237d0c <tcp_dooptions>
      om = 0;
 8235f60:	e03fe515 	stw	zero,-108(fp)
   }

   acked = (int)(ti->ti_ack - tp->snd_una);
 8235f64:	e0bff217 	ldw	r2,-56(fp)
 8235f68:	10c00717 	ldw	r3,28(r2)
 8235f6c:	e0bfe617 	ldw	r2,-104(fp)
 8235f70:	10800e17 	ldw	r2,56(r2)
 8235f74:	1885c83a 	sub	r2,r3,r2
 8235f78:	e0bff615 	stw	r2,-40(fp)
    * Receive window is amount of space in rcv queue,
    * but not less than advertised window.
    */
   { long win;

      win = (long)sbspace(&so->so_rcv);
 8235f7c:	e0bfe817 	ldw	r2,-96(fp)
 8235f80:	10800b17 	ldw	r2,44(r2)
 8235f84:	1007883a 	mov	r3,r2
 8235f88:	e0bfe817 	ldw	r2,-96(fp)
 8235f8c:	10800a17 	ldw	r2,40(r2)
 8235f90:	1885c83a 	sub	r2,r3,r2
 8235f94:	10000616 	blt	r2,zero,8235fb0 <tcp_input+0x5d4>
 8235f98:	e0bfe817 	ldw	r2,-96(fp)
 8235f9c:	10c00b17 	ldw	r3,44(r2)
 8235fa0:	e0bfe817 	ldw	r2,-96(fp)
 8235fa4:	10800a17 	ldw	r2,40(r2)
 8235fa8:	1885c83a 	sub	r2,r3,r2
 8235fac:	00000106 	br	8235fb4 <tcp_input+0x5d8>
 8235fb0:	0005883a 	mov	r2,zero
 8235fb4:	e0bfef15 	stw	r2,-68(fp)
      if (win < 0)
 8235fb8:	e0bfef17 	ldw	r2,-68(fp)
 8235fbc:	1000010e 	bge	r2,zero,8235fc4 <tcp_input+0x5e8>
         win = 0;
 8235fc0:	e03fef15 	stw	zero,-68(fp)
      tp->rcv_wnd = (tcp_win)MAX((u_long)win, (tp->rcv_adv - tp->rcv_nxt));
 8235fc4:	e0bfe617 	ldw	r2,-104(fp)
 8235fc8:	10c01917 	ldw	r3,100(r2)
 8235fcc:	e0bfe617 	ldw	r2,-104(fp)
 8235fd0:	10801617 	ldw	r2,88(r2)
 8235fd4:	1885c83a 	sub	r2,r3,r2
 8235fd8:	e0ffef17 	ldw	r3,-68(fp)
 8235fdc:	10c0012e 	bgeu	r2,r3,8235fe4 <tcp_input+0x608>
 8235fe0:	1805883a 	mov	r2,r3
 8235fe4:	e0ffe617 	ldw	r3,-104(fp)
 8235fe8:	18801515 	stw	r2,84(r3)
    * is non-zero and the ack didn't move, we're the
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
 8235fec:	e0bfe617 	ldw	r2,-104(fp)
 8235ff0:	10800217 	ldw	r2,8(r2)
 8235ff4:	10800118 	cmpnei	r2,r2,4
 8235ff8:	1001021e 	bne	r2,zero,8236404 <tcp_input+0xa28>
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
 8235ffc:	e0bfe717 	ldw	r2,-100(fp)
 8236000:	10800dcc 	andi	r2,r2,55
    * is non-zero and the ack didn't move, we're the
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
 8236004:	10800418 	cmpnei	r2,r2,16
 8236008:	1000fe1e 	bne	r2,zero,8236404 <tcp_input+0xa28>
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
       (ti->ti_seq == tp->rcv_nxt) &&
 823600c:	e0bff217 	ldw	r2,-56(fp)
 8236010:	10c00617 	ldw	r3,24(r2)
 8236014:	e0bfe617 	ldw	r2,-104(fp)
 8236018:	10801617 	ldw	r2,88(r2)
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
 823601c:	1880f91e 	bne	r3,r2,8236404 <tcp_input+0xa28>
       (ti->ti_seq == tp->rcv_nxt) &&
 8236020:	e0bff517 	ldw	r2,-44(fp)
 8236024:	1000f726 	beq	r2,zero,8236404 <tcp_input+0xa28>
       (rx_win && rx_win == tp->snd_wnd) &&
 8236028:	e0bfe617 	ldw	r2,-104(fp)
 823602c:	10c01417 	ldw	r3,80(r2)
 8236030:	e0bff517 	ldw	r2,-44(fp)
 8236034:	1880f31e 	bne	r3,r2,8236404 <tcp_input+0xa28>
       (tp->snd_nxt == tp->snd_max))
 8236038:	e0bfe617 	ldw	r2,-104(fp)
 823603c:	10c00f17 	ldw	r3,60(r2)
 8236040:	e0bfe617 	ldw	r2,-104(fp)
 8236044:	10801a17 	ldw	r2,104(r2)
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
       (ti->ti_seq == tp->rcv_nxt) &&
       (rx_win && rx_win == tp->snd_wnd) &&
 8236048:	1880ee1e 	bne	r3,r2,8236404 <tcp_input+0xa28>
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
 823604c:	e0bff217 	ldw	r2,-56(fp)
 8236050:	1080028b 	ldhu	r2,10(r2)
 8236054:	10bfffcc 	andi	r2,r2,65535
 8236058:	1000611e 	bne	r2,zero,82361e0 <tcp_input+0x804>
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
 823605c:	e0bff217 	ldw	r2,-56(fp)
 8236060:	10c00717 	ldw	r3,28(r2)
 8236064:	e0bfe617 	ldw	r2,-104(fp)
 8236068:	10800e17 	ldw	r2,56(r2)
 823606c:	1885c83a 	sub	r2,r3,r2
 8236070:	0080e40e 	bge	zero,r2,8236404 <tcp_input+0xa28>
             SEQ_LEQ(ti->ti_ack, tp->snd_max) &&
 8236074:	e0bff217 	ldw	r2,-56(fp)
 8236078:	10c00717 	ldw	r3,28(r2)
 823607c:	e0bfe617 	ldw	r2,-104(fp)
 8236080:	10801a17 	ldw	r2,104(r2)
 8236084:	1885c83a 	sub	r2,r3,r2
       (rx_win && rx_win == tp->snd_wnd) &&
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
 8236088:	0080de16 	blt	zero,r2,8236404 <tcp_input+0xa28>
             SEQ_LEQ(ti->ti_ack, tp->snd_max) &&
             tp->snd_cwnd >= tp->snd_wnd) 
 823608c:	e0bfe617 	ldw	r2,-104(fp)
 8236090:	10c01b17 	ldw	r3,108(r2)
 8236094:	e0bfe617 	ldw	r2,-104(fp)
 8236098:	10801417 	ldw	r2,80(r2)
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
             SEQ_LEQ(ti->ti_ack, tp->snd_max) &&
 823609c:	1880d936 	bltu	r3,r2,8236404 <tcp_input+0xa28>
             tp->snd_cwnd >= tp->snd_wnd) 
         {
            /*
             * this is a pure ack for outstanding data.
             */
            ++tcpstat.tcps_predack;
 82360a0:	008209b4 	movhi	r2,2086
 82360a4:	10b9ad04 	addi	r2,r2,-6476
 82360a8:	10803517 	ldw	r2,212(r2)
 82360ac:	10c00044 	addi	r3,r2,1
 82360b0:	008209b4 	movhi	r2,2086
 82360b4:	10b9ad04 	addi	r2,r2,-6476
 82360b8:	10c03515 	stw	r3,212(r2)
            if (tp->t_rttick && 
 82360bc:	e0bfe617 	ldw	r2,-104(fp)
 82360c0:	10801e17 	ldw	r2,120(r2)
 82360c4:	10000826 	beq	r2,zero,82360e8 <tcp_input+0x70c>
#ifdef TCP_TIMESTAMP
               ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
               (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
 82360c8:	e0bff217 	ldw	r2,-56(fp)
 82360cc:	10c00717 	ldw	r3,28(r2)
 82360d0:	e0bfe617 	ldw	r2,-104(fp)
 82360d4:	10801f17 	ldw	r2,124(r2)
 82360d8:	1885c83a 	sub	r2,r3,r2
         {
            /*
             * this is a pure ack for outstanding data.
             */
            ++tcpstat.tcps_predack;
            if (tp->t_rttick && 
 82360dc:	0080020e 	bge	zero,r2,82360e8 <tcp_input+0x70c>
#ifdef TCP_TIMESTAMP
               ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
               (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
            {
               tcp_xmit_timer(tp);
 82360e0:	e13fe617 	ldw	r4,-104(fp)
 82360e4:	8237fc00 	call	8237fc0 <tcp_xmit_timer>
            }

            tcpstat.tcps_rcvackpack++;
 82360e8:	008209b4 	movhi	r2,2086
 82360ec:	10b9ad04 	addi	r2,r2,-6476
 82360f0:	10802b17 	ldw	r2,172(r2)
 82360f4:	10c00044 	addi	r3,r2,1
 82360f8:	008209b4 	movhi	r2,2086
 82360fc:	10b9ad04 	addi	r2,r2,-6476
 8236100:	10c02b15 	stw	r3,172(r2)
            tcpstat.tcps_rcvackbyte += acked;
 8236104:	008209b4 	movhi	r2,2086
 8236108:	10b9ad04 	addi	r2,r2,-6476
 823610c:	10c02c17 	ldw	r3,176(r2)
 8236110:	e0bff617 	ldw	r2,-40(fp)
 8236114:	1887883a 	add	r3,r3,r2
 8236118:	008209b4 	movhi	r2,2086
 823611c:	10b9ad04 	addi	r2,r2,-6476
 8236120:	10c02c15 	stw	r3,176(r2)
            sbdrop(&so->so_snd, acked);
 8236124:	e0bfe817 	ldw	r2,-96(fp)
 8236128:	10801204 	addi	r2,r2,72
 823612c:	e17ff617 	ldw	r5,-40(fp)
 8236130:	1009883a 	mov	r4,r2
 8236134:	8234a080 	call	8234a08 <sbdrop>
            tp->snd_una = ti->ti_ack;
 8236138:	e0bff217 	ldw	r2,-56(fp)
 823613c:	10c00717 	ldw	r3,28(r2)
 8236140:	e0bfe617 	ldw	r2,-104(fp)
 8236144:	10c00e15 	stw	r3,56(r2)
            m_freem(m);
 8236148:	e13ffe17 	ldw	r4,-8(fp)
 823614c:	822e6940 	call	822e694 <m_freem>
             * If process is waiting for space,
             * wakeup/selwakeup/signal.  If data
             * are ready to send, let tcp_output
             * decide between more output or persist.
             */
            if (tp->snd_una == tp->snd_max)
 8236150:	e0bfe617 	ldw	r2,-104(fp)
 8236154:	10c00e17 	ldw	r3,56(r2)
 8236158:	e0bfe617 	ldw	r2,-104(fp)
 823615c:	10801a17 	ldw	r2,104(r2)
 8236160:	1880031e 	bne	r3,r2,8236170 <tcp_input+0x794>
               tp->t_timer[TCPT_REXMT] = 0;
 8236164:	e0bfe617 	ldw	r2,-104(fp)
 8236168:	10000315 	stw	zero,12(r2)
 823616c:	00000706 	br	823618c <tcp_input+0x7b0>
            else if (tp->t_timer[TCPT_PERSIST] == 0)
 8236170:	e0bfe617 	ldw	r2,-104(fp)
 8236174:	10800417 	ldw	r2,16(r2)
 8236178:	1000041e 	bne	r2,zero,823618c <tcp_input+0x7b0>
               tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 823617c:	e0bfe617 	ldw	r2,-104(fp)
 8236180:	10c00817 	ldw	r3,32(r2)
 8236184:	e0bfe617 	ldw	r2,-104(fp)
 8236188:	10c00315 	stw	r3,12(r2)

            if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 823618c:	e0bfe817 	ldw	r2,-96(fp)
 8236190:	1080190b 	ldhu	r2,100(r2)
 8236194:	10bfffcc 	andi	r2,r2,65535
 8236198:	1080030c 	andi	r2,r2,12
 823619c:	10000526 	beq	r2,zero,82361b4 <tcp_input+0x7d8>
               sowwakeup(so);
 82361a0:	e0bfe817 	ldw	r2,-96(fp)
 82361a4:	10801204 	addi	r2,r2,72
 82361a8:	100b883a 	mov	r5,r2
 82361ac:	e13fe817 	ldw	r4,-96(fp)
 82361b0:	82342a00 	call	82342a0 <sbwakeup>

            /* If there is more data in the send buffer, and some is
             * still unsent, then call tcp_output() to try to send it
             */
            if (so->so_snd.sb_cc > (tp->snd_nxt - tp->snd_una))
 82361b4:	e0bfe817 	ldw	r2,-96(fp)
 82361b8:	10801217 	ldw	r2,72(r2)
 82361bc:	e0ffe617 	ldw	r3,-104(fp)
 82361c0:	19000f17 	ldw	r4,60(r3)
 82361c4:	e0ffe617 	ldw	r3,-104(fp)
 82361c8:	18c00e17 	ldw	r3,56(r3)
 82361cc:	20c7c83a 	sub	r3,r4,r3
 82361d0:	1886c02e 	bgeu	r3,r2,8237cd4 <tcp_input+0x22f8>
               (void) tcp_output(tp);
 82361d4:	e13fe617 	ldw	r4,-104(fp)
 82361d8:	823835c0 	call	823835c <tcp_output>
            return;
 82361dc:	0006bd06 	br	8237cd4 <tcp_input+0x22f8>
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
 82361e0:	e0bff217 	ldw	r2,-56(fp)
 82361e4:	10c00717 	ldw	r3,28(r2)
 82361e8:	e0bfe617 	ldw	r2,-104(fp)
 82361ec:	10800e17 	ldw	r2,56(r2)
 82361f0:	1880841e 	bne	r3,r2,8236404 <tcp_input+0xa28>
          tp->seg_next == (struct tcpiphdr *)tp &&
 82361f4:	e0bfe617 	ldw	r2,-104(fp)
 82361f8:	10c00017 	ldw	r3,0(r2)
            if (so->so_snd.sb_cc > (tp->snd_nxt - tp->snd_una))
               (void) tcp_output(tp);
            return;
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
 82361fc:	e0bfe617 	ldw	r2,-104(fp)
 8236200:	1880801e 	bne	r3,r2,8236404 <tcp_input+0xa28>
          tp->seg_next == (struct tcpiphdr *)tp &&
          ti->ti_len <= sbspace(&so->so_rcv))
 8236204:	e0bff217 	ldw	r2,-56(fp)
 8236208:	1080028b 	ldhu	r2,10(r2)
 823620c:	10ffffcc 	andi	r3,r2,65535
 8236210:	e0bfe817 	ldw	r2,-96(fp)
 8236214:	10800b17 	ldw	r2,44(r2)
 8236218:	1009883a 	mov	r4,r2
 823621c:	e0bfe817 	ldw	r2,-96(fp)
 8236220:	10800a17 	ldw	r2,40(r2)
 8236224:	2085c83a 	sub	r2,r4,r2
 8236228:	10000616 	blt	r2,zero,8236244 <tcp_input+0x868>
 823622c:	e0bfe817 	ldw	r2,-96(fp)
 8236230:	11000b17 	ldw	r4,44(r2)
 8236234:	e0bfe817 	ldw	r2,-96(fp)
 8236238:	10800a17 	ldw	r2,40(r2)
 823623c:	2085c83a 	sub	r2,r4,r2
 8236240:	00000106 	br	8236248 <tcp_input+0x86c>
 8236244:	0005883a 	mov	r2,zero
               (void) tcp_output(tp);
            return;
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
          tp->seg_next == (struct tcpiphdr *)tp &&
 8236248:	10c06e36 	bltu	r2,r3,8236404 <tcp_input+0xa28>
#endif   /* TCP_ZEROCOPY */

         /* this may also be a garden-variety probe received because
          * the socket sendbuf was full.
          */
         if(tp->rcv_wnd == 0)
 823624c:	e0bfe617 	ldw	r2,-104(fp)
 8236250:	10801517 	ldw	r2,84(r2)
 8236254:	10000c1e 	bne	r2,zero,8236288 <tcp_input+0x8ac>
             * info in this seg, but Windows NT 4.0 has a nasty bug where it
             * will hammer us mericilessly with these probes (one customer
             * reports thousands per second) so we just dump it ASAP to
             * save cycles.
             */
            tcpstat.tcps_rcvwinprobe++;
 8236258:	008209b4 	movhi	r2,2086
 823625c:	10b9ad04 	addi	r2,r2,-6476
 8236260:	10802817 	ldw	r2,160(r2)
 8236264:	10c00044 	addi	r3,r2,1
 8236268:	008209b4 	movhi	r2,2086
 823626c:	10b9ad04 	addi	r2,r2,-6476
 8236270:	10c02815 	stw	r3,160(r2)
            m_freem (m);      /* free the received mbuf */
 8236274:	e13ffe17 	ldw	r4,-8(fp)
 8236278:	822e6940 	call	822e694 <m_freem>
            tcp_output(tp);   /* send the ack now... */
 823627c:	e13fe617 	ldw	r4,-104(fp)
 8236280:	823835c0 	call	823835c <tcp_output>
            return;
 8236284:	00069c06 	br	8237cf8 <tcp_input+0x231c>
         /*
          * this is a pure, in-sequence data packet
          * with nothing on the reassembly queue and
          * we have enough buffer space to take it.
          */
         ++tcpstat.tcps_preddat;
 8236288:	008209b4 	movhi	r2,2086
 823628c:	10b9ad04 	addi	r2,r2,-6476
 8236290:	10803617 	ldw	r2,216(r2)
 8236294:	10c00044 	addi	r3,r2,1
 8236298:	008209b4 	movhi	r2,2086
 823629c:	10b9ad04 	addi	r2,r2,-6476
 82362a0:	10c03615 	stw	r3,216(r2)
         tp->rcv_nxt += ti->ti_len;
 82362a4:	e0bfe617 	ldw	r2,-104(fp)
 82362a8:	10c01617 	ldw	r3,88(r2)
 82362ac:	e0bff217 	ldw	r2,-56(fp)
 82362b0:	1080028b 	ldhu	r2,10(r2)
 82362b4:	10bfffcc 	andi	r2,r2,65535
 82362b8:	1887883a 	add	r3,r3,r2
 82362bc:	e0bfe617 	ldw	r2,-104(fp)
 82362c0:	10c01615 	stw	r3,88(r2)
         tcpstat.tcps_rcvpack++;
 82362c4:	008209b4 	movhi	r2,2086
 82362c8:	10b9ad04 	addi	r2,r2,-6476
 82362cc:	10801a17 	ldw	r2,104(r2)
 82362d0:	10c00044 	addi	r3,r2,1
 82362d4:	008209b4 	movhi	r2,2086
 82362d8:	10b9ad04 	addi	r2,r2,-6476
 82362dc:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 82362e0:	008209b4 	movhi	r2,2086
 82362e4:	10b9ad04 	addi	r2,r2,-6476
 82362e8:	10c01b17 	ldw	r3,108(r2)
 82362ec:	e0bff217 	ldw	r2,-56(fp)
 82362f0:	1080028b 	ldhu	r2,10(r2)
 82362f4:	10bfffcc 	andi	r2,r2,65535
 82362f8:	1887883a 	add	r3,r3,r2
 82362fc:	008209b4 	movhi	r2,2086
 8236300:	10b9ad04 	addi	r2,r2,-6476
 8236304:	10c01b15 	stw	r3,108(r2)
         /*
          * Add data to socket buffer.
          */
         sbappend(&so->so_rcv, m);
 8236308:	e0bfe817 	ldw	r2,-96(fp)
 823630c:	10800a04 	addi	r2,r2,40
 8236310:	e17ffe17 	ldw	r5,-8(fp)
 8236314:	1009883a 	mov	r4,r2
 8236318:	82344500 	call	8234450 <sbappend>
         sorwakeup(so);
 823631c:	e0bfe817 	ldw	r2,-96(fp)
 8236320:	10800a04 	addi	r2,r2,40
 8236324:	100b883a 	mov	r5,r2
 8236328:	e13fe817 	ldw	r4,-96(fp)
 823632c:	82342a00 	call	82342a0 <sbwakeup>
         /*
          * If this is a short packet, then ACK now - with Nagel
          *   congestion avoidance sender won't send more until
          *   he gets an ACK.
          */
         if (tiflags & TH_PUSH)
 8236330:	e0bfe717 	ldw	r2,-100(fp)
 8236334:	1080020c 	andi	r2,r2,8
 8236338:	10000726 	beq	r2,zero,8236358 <tcp_input+0x97c>
            tp->t_flags |= TF_ACKNOW;
 823633c:	e0bfe617 	ldw	r2,-104(fp)
 8236340:	10800b0b 	ldhu	r2,44(r2)
 8236344:	10800054 	ori	r2,r2,1
 8236348:	1007883a 	mov	r3,r2
 823634c:	e0bfe617 	ldw	r2,-104(fp)
 8236350:	10c00b0d 	sth	r3,44(r2)
 8236354:	00000606 	br	8236370 <tcp_input+0x994>
         else
            tp->t_flags |= TF_DELACK;
 8236358:	e0bfe617 	ldw	r2,-104(fp)
 823635c:	10800b0b 	ldhu	r2,44(r2)
 8236360:	10800094 	ori	r2,r2,2
 8236364:	1007883a 	mov	r3,r2
 8236368:	e0bfe617 	ldw	r2,-104(fp)
 823636c:	10c00b0d 	sth	r3,44(r2)

         /* see if we need to send an ack */
         adv = (int)(tp->rcv_wnd - (tcp_win)(tp->rcv_adv - tp->rcv_nxt));
 8236370:	e0bfe617 	ldw	r2,-104(fp)
 8236374:	10c01517 	ldw	r3,84(r2)
 8236378:	e0bfe617 	ldw	r2,-104(fp)
 823637c:	11001617 	ldw	r4,88(r2)
 8236380:	e0bfe617 	ldw	r2,-104(fp)
 8236384:	10801917 	ldw	r2,100(r2)
 8236388:	2085c83a 	sub	r2,r4,r2
 823638c:	1885883a 	add	r2,r3,r2
 8236390:	e0bff715 	stw	r2,-36(fp)

         if ((adv >= (int)(tp->t_maxseg * 2)) ||
 8236394:	e0bfe617 	ldw	r2,-104(fp)
 8236398:	10800a0b 	ldhu	r2,40(r2)
 823639c:	10bfffcc 	andi	r2,r2,65535
 82363a0:	1085883a 	add	r2,r2,r2
 82363a4:	1007883a 	mov	r3,r2
 82363a8:	e0bff717 	ldw	r2,-36(fp)
 82363ac:	10c0050e 	bge	r2,r3,82363c4 <tcp_input+0x9e8>
             (tp->t_flags & TF_ACKNOW))
 82363b0:	e0bfe617 	ldw	r2,-104(fp)
 82363b4:	10800b0b 	ldhu	r2,44(r2)
 82363b8:	10bfffcc 	andi	r2,r2,65535
 82363bc:	1080004c 	andi	r2,r2,1
            tp->t_flags |= TF_DELACK;

         /* see if we need to send an ack */
         adv = (int)(tp->rcv_wnd - (tcp_win)(tp->rcv_adv - tp->rcv_nxt));

         if ((adv >= (int)(tp->t_maxseg * 2)) ||
 82363c0:	10064626 	beq	r2,zero,8237cdc <tcp_input+0x2300>
               tp->t_flags &= ~TF_ACKNOW;
               return;
            }
#endif   /* DO_DELAY_ACKS */

            tp->t_flags |= TF_ACKNOW;
 82363c4:	e0bfe617 	ldw	r2,-104(fp)
 82363c8:	10800b0b 	ldhu	r2,44(r2)
 82363cc:	10800054 	ori	r2,r2,1
 82363d0:	1007883a 	mov	r3,r2
 82363d4:	e0bfe617 	ldw	r2,-104(fp)
 82363d8:	10c00b0d 	sth	r3,44(r2)
            tp->t_flags &= ~TF_DELACK;
 82363dc:	e0bfe617 	ldw	r2,-104(fp)
 82363e0:	10c00b0b 	ldhu	r3,44(r2)
 82363e4:	00bfff44 	movi	r2,-3
 82363e8:	1884703a 	and	r2,r3,r2
 82363ec:	1007883a 	mov	r3,r2
 82363f0:	e0bfe617 	ldw	r2,-104(fp)
 82363f4:	10c00b0d 	sth	r3,44(r2)
            tcp_output(tp);   /* send the ack now... */
 82363f8:	e13fe617 	ldw	r4,-104(fp)
 82363fc:	823835c0 	call	823835c <tcp_output>
         }

         return;
 8236400:	00063606 	br	8237cdc <tcp_input+0x2300>
      }
   }

   switch (tp->t_state) 
 8236404:	e0bfe617 	ldw	r2,-104(fp)
 8236408:	10800217 	ldw	r2,8(r2)
 823640c:	10c00060 	cmpeqi	r3,r2,1
 8236410:	1800031e 	bne	r3,zero,8236420 <tcp_input+0xa44>
 8236414:	108000a0 	cmpeqi	r2,r2,2
 8236418:	1000aa1e 	bne	r2,zero,82366c4 <tcp_input+0xce8>
 823641c:	00017e06 	br	8236a18 <tcp_input+0x103c>
    */
   case TCPS_LISTEN: 
   {
         struct mbuf *  am;

         if (tiflags & TH_RST)
 8236420:	e0bfe717 	ldw	r2,-100(fp)
 8236424:	1080010c 	andi	r2,r2,4
 8236428:	10000326 	beq	r2,zero,8236438 <tcp_input+0xa5c>
            GOTO_DROP;
 823642c:	0080bec4 	movi	r2,763
 8236430:	d0a0b215 	stw	r2,-32056(gp)
 8236434:	00061b06 	br	8237ca4 <tcp_input+0x22c8>
         if (tiflags & TH_ACK)
 8236438:	e0bfe717 	ldw	r2,-100(fp)
 823643c:	1080040c 	andi	r2,r2,16
 8236440:	10000326 	beq	r2,zero,8236450 <tcp_input+0xa74>
            GOTO_DROPWITHRESET;
 8236444:	0080bf44 	movi	r2,765
 8236448:	d0a0b215 	stw	r2,-32056(gp)
 823644c:	0005d406 	br	8237ba0 <tcp_input+0x21c4>
         if ((tiflags & TH_SYN) == 0)
 8236450:	e0bfe717 	ldw	r2,-100(fp)
 8236454:	1080008c 	andi	r2,r2,2
 8236458:	1000031e 	bne	r2,zero,8236468 <tcp_input+0xa8c>
            GOTO_DROP;
 823645c:	0080bfc4 	movi	r2,767
 8236460:	d0a0b215 	stw	r2,-32056(gp)
 8236464:	00060f06 	br	8237ca4 <tcp_input+0x22c8>
         if(in_broadcast(ti->ti_dst.s_addr))
 8236468:	e0bff217 	ldw	r2,-56(fp)
 823646c:	10800417 	ldw	r2,16(r2)
 8236470:	1009883a 	mov	r4,r2
 8236474:	822f5e00 	call	822f5e0 <in_broadcast>
 8236478:	10000326 	beq	r2,zero,8236488 <tcp_input+0xaac>
            GOTO_DROP;
 823647c:	0080c044 	movi	r2,769
 8236480:	d0a0b215 	stw	r2,-32056(gp)
 8236484:	00060706 	br	8237ca4 <tcp_input+0x22c8>
         am = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 8236488:	01400404 	movi	r5,16
 823648c:	01000244 	movi	r4,9
 8236490:	822e4040 	call	822e404 <m_getnbuf>
 8236494:	e0bffa15 	stw	r2,-24(fp)
         if (am == NULL)
 8236498:	e0bffa17 	ldw	r2,-24(fp)
 823649c:	1000031e 	bne	r2,zero,82364ac <tcp_input+0xad0>
            GOTO_DROP;
 82364a0:	0080c104 	movi	r2,772
 82364a4:	d0a0b215 	stw	r2,-32056(gp)
 82364a8:	0005fe06 	br	8237ca4 <tcp_input+0x22c8>

#ifdef IP_V4
         if(inp->inp_socket->so_domain == AF_INET)
 82364ac:	e0bfe417 	ldw	r2,-112(fp)
 82364b0:	10800817 	ldw	r2,32(r2)
 82364b4:	10800517 	ldw	r2,20(r2)
 82364b8:	10800098 	cmpnei	r2,r2,2
 82364bc:	10002c1e 	bne	r2,zero,8236570 <tcp_input+0xb94>
         {
         struct sockaddr_in * sin;
         am->m_len = sizeof (struct sockaddr_in);
 82364c0:	e0bffa17 	ldw	r2,-24(fp)
 82364c4:	00c00404 	movi	r3,16
 82364c8:	10c00215 	stw	r3,8(r2)
         sin = mtod(am, struct sockaddr_in *);
 82364cc:	e0bffa17 	ldw	r2,-24(fp)
 82364d0:	10800317 	ldw	r2,12(r2)
 82364d4:	e0bffb15 	stw	r2,-20(fp)
         sin->sin_family = AF_INET;
 82364d8:	e0bffb17 	ldw	r2,-20(fp)
 82364dc:	00c00084 	movi	r3,2
 82364e0:	10c0000d 	sth	r3,0(r2)
         sin->sin_addr = ti->ti_src;
 82364e4:	e0bffb17 	ldw	r2,-20(fp)
 82364e8:	e0fff217 	ldw	r3,-56(fp)
 82364ec:	18c00317 	ldw	r3,12(r3)
 82364f0:	10c00115 	stw	r3,4(r2)
         sin->sin_port = ti->ti_sport;
 82364f4:	e0bff217 	ldw	r2,-56(fp)
 82364f8:	10c0050b 	ldhu	r3,20(r2)
 82364fc:	e0bffb17 	ldw	r2,-20(fp)
 8236500:	10c0008d 	sth	r3,2(r2)
         /* Assuming pcbconnect will work, we put the sender's address in 
          * the inp_laddr (after saving a local laddr copy). If the connect
          * fails we restore the inpcb before going to drop:
          */
         laddr = inp->inp_laddr;    /* save tmp laddr */
 8236504:	e0bfe417 	ldw	r2,-112(fp)
 8236508:	10800417 	ldw	r2,16(r2)
 823650c:	e0bffd15 	stw	r2,-12(fp)
         if (inp->inp_laddr.s_addr == INADDR_ANY)
 8236510:	e0bfe417 	ldw	r2,-112(fp)
 8236514:	10800417 	ldw	r2,16(r2)
 8236518:	1000041e 	bne	r2,zero,823652c <tcp_input+0xb50>
            inp->inp_laddr = ti->ti_dst;
 823651c:	e0bfe417 	ldw	r2,-112(fp)
 8236520:	e0fff217 	ldw	r3,-56(fp)
 8236524:	18c00417 	ldw	r3,16(r3)
 8236528:	10c00415 	stw	r3,16(r2)
         if (in_pcbconnect (inp, am)) 
 823652c:	e17ffa17 	ldw	r5,-24(fp)
 8236530:	e13fe417 	ldw	r4,-112(fp)
 8236534:	82481840 	call	8248184 <in_pcbconnect>
 8236538:	10000826 	beq	r2,zero,823655c <tcp_input+0xb80>
         {
            inp->inp_laddr = laddr;
 823653c:	e0bfe417 	ldw	r2,-112(fp)
 8236540:	e0fffd17 	ldw	r3,-12(fp)
 8236544:	10c00415 	stw	r3,16(r2)
            (void) m_free(am);
 8236548:	e13ffa17 	ldw	r4,-24(fp)
 823654c:	822e58c0 	call	822e58c <m_free>
            GOTO_DROP;
 8236550:	0080c684 	movi	r2,794
 8236554:	d0a0b215 	stw	r2,-32056(gp)
 8236558:	0005d206 	br	8237ca4 <tcp_input+0x22c8>
         }
         
         inp->ifp = ifp;      /* set interface for conn.*/
 823655c:	e0bfe417 	ldw	r2,-112(fp)
 8236560:	e0ffff17 	ldw	r3,-4(fp)
 8236564:	10c00a15 	stw	r3,40(r2)
         
         (void) m_free (am);
 8236568:	e13ffa17 	ldw	r4,-24(fp)
 823656c:	822e58c0 	call	822e58c <m_free>
            }
            (void) m_free(am);
         }
#endif   /* end v6 */

         tp->t_template = tcp_template(tp);
 8236570:	e13fe617 	ldw	r4,-104(fp)
 8236574:	823957c0 	call	823957c <tcp_template>
 8236578:	1007883a 	mov	r3,r2
 823657c:	e0bfe617 	ldw	r2,-104(fp)
 8236580:	10c00c15 	stw	r3,48(r2)
         if (tp->t_template == 0) 
 8236584:	e0bfe617 	ldw	r2,-104(fp)
 8236588:	10800c17 	ldw	r2,48(r2)
 823658c:	1000071e 	bne	r2,zero,82365ac <tcp_input+0xbd0>
         {
            SETTP(tp, tcp_drop(tp, ENOBUFS));
 8236590:	01401a44 	movi	r5,105
 8236594:	e13fe617 	ldw	r4,-104(fp)
 8236598:	8239b900 	call	8239b90 <tcp_drop>
            dropsocket = 0;      /* socket is already gone */
 823659c:	e03fec15 	stw	zero,-80(fp)
            GOTO_DROP;
 82365a0:	0080d1c4 	movi	r2,839
 82365a4:	d0a0b215 	stw	r2,-32056(gp)
 82365a8:	0005be06 	br	8237ca4 <tcp_input+0x22c8>
         }
         if (om) 
 82365ac:	e0bfe517 	ldw	r2,-108(fp)
 82365b0:	10000526 	beq	r2,zero,82365c8 <tcp_input+0xbec>
         {
            tcp_dooptions(tp, om, ti);
 82365b4:	e1bff217 	ldw	r6,-56(fp)
 82365b8:	e17fe517 	ldw	r5,-108(fp)
 82365bc:	e13fe617 	ldw	r4,-104(fp)
 82365c0:	8237d0c0 	call	8237d0c <tcp_dooptions>
            om = 0;
 82365c4:	e03fe515 	stw	zero,-108(fp)
         }
         if (iss)
 82365c8:	e0bfed17 	ldw	r2,-76(fp)
 82365cc:	10000426 	beq	r2,zero,82365e0 <tcp_input+0xc04>
            tp->iss = iss;
 82365d0:	e0ffed17 	ldw	r3,-76(fp)
 82365d4:	e0bfe617 	ldw	r2,-104(fp)
 82365d8:	10c01315 	stw	r3,76(r2)
 82365dc:	00000306 	br	82365ec <tcp_input+0xc10>
         else
            tp->iss = tcp_iss;
 82365e0:	d0e0b517 	ldw	r3,-32044(gp)
 82365e4:	e0bfe617 	ldw	r2,-104(fp)
 82365e8:	10c01315 	stw	r3,76(r2)
         tcp_iss += (unsigned)(TCP_ISSINCR/2);
 82365ec:	d0e0b517 	ldw	r3,-32044(gp)
 82365f0:	00be9fd4 	movui	r2,64127
 82365f4:	1885883a 	add	r2,r3,r2
 82365f8:	d0a0b515 	stw	r2,-32044(gp)
         tp->irs = ti->ti_seq;
 82365fc:	e0bff217 	ldw	r2,-56(fp)
 8236600:	10c00617 	ldw	r3,24(r2)
 8236604:	e0bfe617 	ldw	r2,-104(fp)
 8236608:	10c01815 	stw	r3,96(r2)
         tcp_sendseqinit(tp);
 823660c:	e0bfe617 	ldw	r2,-104(fp)
 8236610:	10c01317 	ldw	r3,76(r2)
 8236614:	e0bfe617 	ldw	r2,-104(fp)
 8236618:	10c01015 	stw	r3,64(r2)
 823661c:	e0bfe617 	ldw	r2,-104(fp)
 8236620:	10c01017 	ldw	r3,64(r2)
 8236624:	e0bfe617 	ldw	r2,-104(fp)
 8236628:	10c01a15 	stw	r3,104(r2)
 823662c:	e0bfe617 	ldw	r2,-104(fp)
 8236630:	10c01a17 	ldw	r3,104(r2)
 8236634:	e0bfe617 	ldw	r2,-104(fp)
 8236638:	10c00f15 	stw	r3,60(r2)
 823663c:	e0bfe617 	ldw	r2,-104(fp)
 8236640:	10c00f17 	ldw	r3,60(r2)
 8236644:	e0bfe617 	ldw	r2,-104(fp)
 8236648:	10c00e15 	stw	r3,56(r2)
         tcp_rcvseqinit(tp);
 823664c:	e0bfe617 	ldw	r2,-104(fp)
 8236650:	10801817 	ldw	r2,96(r2)
 8236654:	10c00044 	addi	r3,r2,1
 8236658:	e0bfe617 	ldw	r2,-104(fp)
 823665c:	10c01615 	stw	r3,88(r2)
 8236660:	e0bfe617 	ldw	r2,-104(fp)
 8236664:	10c01617 	ldw	r3,88(r2)
 8236668:	e0bfe617 	ldw	r2,-104(fp)
 823666c:	10c01915 	stw	r3,100(r2)
         tp->t_flags |= TF_ACKNOW;
 8236670:	e0bfe617 	ldw	r2,-104(fp)
 8236674:	10800b0b 	ldhu	r2,44(r2)
 8236678:	10800054 	ori	r2,r2,1
 823667c:	1007883a 	mov	r3,r2
 8236680:	e0bfe617 	ldw	r2,-104(fp)
 8236684:	10c00b0d 	sth	r3,44(r2)
         tp->t_state = TCPS_SYN_RECEIVED;
 8236688:	e0bfe617 	ldw	r2,-104(fp)
 823668c:	00c000c4 	movi	r3,3
 8236690:	10c00215 	stw	r3,8(r2)
         tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 8236694:	e0bfe617 	ldw	r2,-104(fp)
 8236698:	00c02584 	movi	r3,150
 823669c:	10c00515 	stw	r3,20(r2)
         dropsocket = 0;      /* committed to socket */
 82366a0:	e03fec15 	stw	zero,-80(fp)
         tcpstat.tcps_accepts++;
 82366a4:	008209b4 	movhi	r2,2086
 82366a8:	10b9ad04 	addi	r2,r2,-6476
 82366ac:	10800117 	ldw	r2,4(r2)
 82366b0:	10c00044 	addi	r3,r2,1
 82366b4:	008209b4 	movhi	r2,2086
 82366b8:	10b9ad04 	addi	r2,r2,-6476
 82366bc:	10c00115 	stw	r3,4(r2)
         goto trimthenstep6;
 82366c0:	00009006 	br	8236904 <tcp_input+0xf28>
    *   if SYN has been acked change to ESTABLISHED else SYN_RCVD state
    *   arrange for segment to be acked (eventually)
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
 82366c4:	e0bfe417 	ldw	r2,-112(fp)
 82366c8:	e0ffff17 	ldw	r3,-4(fp)
 82366cc:	10c00a15 	stw	r3,40(r2)
      if ((tiflags & TH_ACK) &&
 82366d0:	e0bfe717 	ldw	r2,-100(fp)
 82366d4:	1080040c 	andi	r2,r2,16
 82366d8:	10000f26 	beq	r2,zero,8236718 <tcp_input+0xd3c>
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
 82366dc:	e0bff217 	ldw	r2,-56(fp)
 82366e0:	10c00717 	ldw	r3,28(r2)
 82366e4:	e0bfe617 	ldw	r2,-104(fp)
 82366e8:	10801317 	ldw	r2,76(r2)
 82366ec:	1885c83a 	sub	r2,r3,r2
    *   arrange for segment to be acked (eventually)
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
      if ((tiflags & TH_ACK) &&
 82366f0:	0080060e 	bge	zero,r2,823670c <tcp_input+0xd30>
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
          SEQ_GT(ti->ti_ack, tp->snd_max)))
 82366f4:	e0bff217 	ldw	r2,-56(fp)
 82366f8:	10c00717 	ldw	r3,28(r2)
 82366fc:	e0bfe617 	ldw	r2,-104(fp)
 8236700:	10801a17 	ldw	r2,104(r2)
 8236704:	1885c83a 	sub	r2,r3,r2
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
      if ((tiflags & TH_ACK) &&
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
 8236708:	0080030e 	bge	zero,r2,8236718 <tcp_input+0xd3c>
          SEQ_GT(ti->ti_ack, tp->snd_max)))
      {
         GOTO_DROPWITHRESET;
 823670c:	0080dc04 	movi	r2,880
 8236710:	d0a0b215 	stw	r2,-32056(gp)
 8236714:	00052206 	br	8237ba0 <tcp_input+0x21c4>
      }
      if (tiflags & TH_RST) 
 8236718:	e0bfe717 	ldw	r2,-100(fp)
 823671c:	1080010c 	andi	r2,r2,4
 8236720:	10000926 	beq	r2,zero,8236748 <tcp_input+0xd6c>
      {
         if (tiflags & TH_ACK)
 8236724:	e0bfe717 	ldw	r2,-100(fp)
 8236728:	1080040c 	andi	r2,r2,16
 823672c:	10000326 	beq	r2,zero,823673c <tcp_input+0xd60>
            SETTP(tp, tcp_drop(tp, ECONNREFUSED));
 8236730:	01401bc4 	movi	r5,111
 8236734:	e13fe617 	ldw	r4,-104(fp)
 8236738:	8239b900 	call	8239b90 <tcp_drop>
         GOTO_DROP;
 823673c:	0080dd84 	movi	r2,886
 8236740:	d0a0b215 	stw	r2,-32056(gp)
 8236744:	00055706 	br	8237ca4 <tcp_input+0x22c8>
      }
      if ((tiflags & TH_SYN) == 0)
 8236748:	e0bfe717 	ldw	r2,-100(fp)
 823674c:	1080008c 	andi	r2,r2,2
 8236750:	1000031e 	bne	r2,zero,8236760 <tcp_input+0xd84>
         GOTO_DROP;
 8236754:	0080de44 	movi	r2,889
 8236758:	d0a0b215 	stw	r2,-32056(gp)
 823675c:	00055106 	br	8237ca4 <tcp_input+0x22c8>
      if (tiflags & TH_ACK) 
 8236760:	e0bfe717 	ldw	r2,-100(fp)
 8236764:	1080040c 	andi	r2,r2,16
 8236768:	10000e26 	beq	r2,zero,82367a4 <tcp_input+0xdc8>
      {
         tp->snd_una = ti->ti_ack;
 823676c:	e0bff217 	ldw	r2,-56(fp)
 8236770:	10c00717 	ldw	r3,28(r2)
 8236774:	e0bfe617 	ldw	r2,-104(fp)
 8236778:	10c00e15 	stw	r3,56(r2)
         if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 823677c:	e0bfe617 	ldw	r2,-104(fp)
 8236780:	10c00f17 	ldw	r3,60(r2)
 8236784:	e0bfe617 	ldw	r2,-104(fp)
 8236788:	10800e17 	ldw	r2,56(r2)
 823678c:	1885c83a 	sub	r2,r3,r2
 8236790:	1000040e 	bge	r2,zero,82367a4 <tcp_input+0xdc8>
            tp->snd_nxt = tp->snd_una;
 8236794:	e0bfe617 	ldw	r2,-104(fp)
 8236798:	10c00e17 	ldw	r3,56(r2)
 823679c:	e0bfe617 	ldw	r2,-104(fp)
 82367a0:	10c00f15 	stw	r3,60(r2)
      }
      tp->t_timer[TCPT_REXMT] = 0;
 82367a4:	e0bfe617 	ldw	r2,-104(fp)
 82367a8:	10000315 	stw	zero,12(r2)
      tp->irs = ti->ti_seq;
 82367ac:	e0bff217 	ldw	r2,-56(fp)
 82367b0:	10c00617 	ldw	r3,24(r2)
 82367b4:	e0bfe617 	ldw	r2,-104(fp)
 82367b8:	10c01815 	stw	r3,96(r2)
      tcp_rcvseqinit(tp);
 82367bc:	e0bfe617 	ldw	r2,-104(fp)
 82367c0:	10801817 	ldw	r2,96(r2)
 82367c4:	10c00044 	addi	r3,r2,1
 82367c8:	e0bfe617 	ldw	r2,-104(fp)
 82367cc:	10c01615 	stw	r3,88(r2)
 82367d0:	e0bfe617 	ldw	r2,-104(fp)
 82367d4:	10c01617 	ldw	r3,88(r2)
 82367d8:	e0bfe617 	ldw	r2,-104(fp)
 82367dc:	10c01915 	stw	r3,100(r2)
      if (inp->inp_laddr.s_addr != ti->ti_dst.s_addr) 
 82367e0:	e0bfe417 	ldw	r2,-112(fp)
 82367e4:	10c00417 	ldw	r3,16(r2)
 82367e8:	e0bff217 	ldw	r2,-56(fp)
 82367ec:	10800417 	ldw	r2,16(r2)
 82367f0:	18801726 	beq	r3,r2,8236850 <tcp_input+0xe74>
          * the IP interface may have changed address since we sent our SYN
          * (e.g. PPP brings link up as a result of said SYN and gets new
          * address via IPCP); if so we need to update the inpcb and the
          * TCP header template with the new address.
          */
         if ((m->pkt->net != NULL)
 82367f4:	e0bffe17 	ldw	r2,-8(fp)
 82367f8:	10800117 	ldw	r2,4(r2)
 82367fc:	10800617 	ldw	r2,24(r2)
 8236800:	10001326 	beq	r2,zero,8236850 <tcp_input+0xe74>
             && (m->pkt->net->n_ipaddr == ti->ti_dst.s_addr)) 
 8236804:	e0bffe17 	ldw	r2,-8(fp)
 8236808:	10800117 	ldw	r2,4(r2)
 823680c:	10800617 	ldw	r2,24(r2)
 8236810:	10c00a17 	ldw	r3,40(r2)
 8236814:	e0bff217 	ldw	r2,-56(fp)
 8236818:	10800417 	ldw	r2,16(r2)
 823681c:	18800c1e 	bne	r3,r2,8236850 <tcp_input+0xe74>
      /* send an ack */
         {
            inp->inp_laddr = ti->ti_dst;
 8236820:	e0bfe417 	ldw	r2,-112(fp)
 8236824:	e0fff217 	ldw	r3,-56(fp)
 8236828:	18c00417 	ldw	r3,16(r3)
 823682c:	10c00415 	stw	r3,16(r2)
            if (tp->t_template != NULL)
 8236830:	e0bfe617 	ldw	r2,-104(fp)
 8236834:	10800c17 	ldw	r2,48(r2)
 8236838:	10000526 	beq	r2,zero,8236850 <tcp_input+0xe74>
               tp->t_template->ti_src = ti->ti_dst;
 823683c:	e0bfe617 	ldw	r2,-104(fp)
 8236840:	10800c17 	ldw	r2,48(r2)
 8236844:	e0fff217 	ldw	r3,-56(fp)
 8236848:	18c00417 	ldw	r3,16(r3)
 823684c:	10c00315 	stw	r3,12(r2)
         }
      }
      tp->t_flags |= TF_ACKNOW;
 8236850:	e0bfe617 	ldw	r2,-104(fp)
 8236854:	10800b0b 	ldhu	r2,44(r2)
 8236858:	10800054 	ori	r2,r2,1
 823685c:	1007883a 	mov	r3,r2
 8236860:	e0bfe617 	ldw	r2,-104(fp)
 8236864:	10c00b0d 	sth	r3,44(r2)
      if (tiflags & TH_ACK && SEQ_GT(tp->snd_una, tp->iss)) 
 8236868:	e0bfe717 	ldw	r2,-100(fp)
 823686c:	1080040c 	andi	r2,r2,16
 8236870:	10002126 	beq	r2,zero,82368f8 <tcp_input+0xf1c>
 8236874:	e0bfe617 	ldw	r2,-104(fp)
 8236878:	10c00e17 	ldw	r3,56(r2)
 823687c:	e0bfe617 	ldw	r2,-104(fp)
 8236880:	10801317 	ldw	r2,76(r2)
 8236884:	1885c83a 	sub	r2,r3,r2
 8236888:	00801b0e 	bge	zero,r2,82368f8 <tcp_input+0xf1c>
      {
         tcpstat.tcps_connects++;
 823688c:	008209b4 	movhi	r2,2086
 8236890:	10b9ad04 	addi	r2,r2,-6476
 8236894:	10800217 	ldw	r2,8(r2)
 8236898:	10c00044 	addi	r3,r2,1
 823689c:	008209b4 	movhi	r2,2086
 82368a0:	10b9ad04 	addi	r2,r2,-6476
 82368a4:	10c00215 	stw	r3,8(r2)
         tp->t_state = TCPS_ESTABLISHED;
 82368a8:	e0bfe617 	ldw	r2,-104(fp)
 82368ac:	00c00104 	movi	r3,4
 82368b0:	10c00215 	stw	r3,8(r2)
         soisconnected (so);
 82368b4:	e13fe817 	ldw	r4,-96(fp)
 82368b8:	8233b340 	call	8233b34 <soisconnected>
         tp->t_maxseg = tcp_mss(so);
 82368bc:	e13fe817 	ldw	r4,-96(fp)
 82368c0:	82382640 	call	8238264 <tcp_mss>
 82368c4:	1007883a 	mov	r3,r2
 82368c8:	e0bfe617 	ldw	r2,-104(fp)
 82368cc:	10c00a0d 	sth	r3,40(r2)
         (void) tcp_reass (tp, (struct tcpiphdr *)0, m);
 82368d0:	e1bffe17 	ldw	r6,-8(fp)
 82368d4:	000b883a 	mov	r5,zero
 82368d8:	e13fe617 	ldw	r4,-104(fp)
 82368dc:	82355cc0 	call	82355cc <tcp_reass>
         /*
          * if we didn't have to retransmit the SYN,
          * use its rtt as our initial srtt & rtt var.
          */
         if (tp->t_rttick) 
 82368e0:	e0bfe617 	ldw	r2,-104(fp)
 82368e4:	10801e17 	ldw	r2,120(r2)
 82368e8:	10000626 	beq	r2,zero,8236904 <tcp_input+0xf28>
         {
            tcp_xmit_timer(tp);
 82368ec:	e13fe617 	ldw	r4,-104(fp)
 82368f0:	8237fc00 	call	8237fc0 <tcp_xmit_timer>
         (void) tcp_reass (tp, (struct tcpiphdr *)0, m);
         /*
          * if we didn't have to retransmit the SYN,
          * use its rtt as our initial srtt & rtt var.
          */
         if (tp->t_rttick) 
 82368f4:	00000306 	br	8236904 <tcp_input+0xf28>
         {
            tcp_xmit_timer(tp);
         }
      } else
         tp->t_state = TCPS_SYN_RECEIVED;
 82368f8:	e0bfe617 	ldw	r2,-104(fp)
 82368fc:	00c000c4 	movi	r3,3
 8236900:	10c00215 	stw	r3,8(r2)
      /*
       * Advance ti->ti_seq to correspond to first data byte.
       * If data, trim to stay within window,
       * dropping FIN if necessary.
       */
      ti->ti_seq++;
 8236904:	e0bff217 	ldw	r2,-56(fp)
 8236908:	10800617 	ldw	r2,24(r2)
 823690c:	10c00044 	addi	r3,r2,1
 8236910:	e0bff217 	ldw	r2,-56(fp)
 8236914:	10c00615 	stw	r3,24(r2)
      if ((tcp_win)ti->ti_len > tp->rcv_wnd) 
 8236918:	e0bff217 	ldw	r2,-56(fp)
 823691c:	1080028b 	ldhu	r2,10(r2)
 8236920:	10bfffcc 	andi	r2,r2,65535
 8236924:	e0ffe617 	ldw	r3,-104(fp)
 8236928:	18c01517 	ldw	r3,84(r3)
 823692c:	1880302e 	bgeu	r3,r2,82369f0 <tcp_input+0x1014>
      {
         todrop = ti->ti_len - (u_short)tp->rcv_wnd;
 8236930:	e0bff217 	ldw	r2,-56(fp)
 8236934:	1080028b 	ldhu	r2,10(r2)
 8236938:	10ffffcc 	andi	r3,r2,65535
 823693c:	e0bfe617 	ldw	r2,-104(fp)
 8236940:	10801517 	ldw	r2,84(r2)
 8236944:	10bfffcc 	andi	r2,r2,65535
 8236948:	1885c83a 	sub	r2,r3,r2
 823694c:	e0bfe915 	stw	r2,-92(fp)
         /* XXX work around 4.2 m_adj bug */
         if (m->m_len) 
 8236950:	e0bffe17 	ldw	r2,-8(fp)
 8236954:	10800217 	ldw	r2,8(r2)
 8236958:	10000626 	beq	r2,zero,8236974 <tcp_input+0xf98>
         {
            m_adj(m, -todrop);
 823695c:	e0bfe917 	ldw	r2,-92(fp)
 8236960:	0085c83a 	sub	r2,zero,r2
 8236964:	100b883a 	mov	r5,r2
 8236968:	e13ffe17 	ldw	r4,-8(fp)
 823696c:	822e9cc0 	call	822e9cc <m_adj>
 8236970:	00000706 	br	8236990 <tcp_input+0xfb4>
         }
         else 
         {
            /* skip tcp/ip header in first mbuf */
            m_adj(m->m_next, -todrop);
 8236974:	e0bffe17 	ldw	r2,-8(fp)
 8236978:	10c00617 	ldw	r3,24(r2)
 823697c:	e0bfe917 	ldw	r2,-92(fp)
 8236980:	0085c83a 	sub	r2,zero,r2
 8236984:	100b883a 	mov	r5,r2
 8236988:	1809883a 	mov	r4,r3
 823698c:	822e9cc0 	call	822e9cc <m_adj>
         }
         ti->ti_len = (u_short)tp->rcv_wnd;
 8236990:	e0bfe617 	ldw	r2,-104(fp)
 8236994:	10801517 	ldw	r2,84(r2)
 8236998:	1007883a 	mov	r3,r2
 823699c:	e0bff217 	ldw	r2,-56(fp)
 82369a0:	10c0028d 	sth	r3,10(r2)
         tiflags &= ~TH_FIN;
 82369a4:	e0ffe717 	ldw	r3,-100(fp)
 82369a8:	00bfff84 	movi	r2,-2
 82369ac:	1884703a 	and	r2,r3,r2
 82369b0:	e0bfe715 	stw	r2,-100(fp)
         tcpstat.tcps_rcvpackafterwin++;
 82369b4:	008209b4 	movhi	r2,2086
 82369b8:	10b9ad04 	addi	r2,r2,-6476
 82369bc:	10802517 	ldw	r2,148(r2)
 82369c0:	10c00044 	addi	r3,r2,1
 82369c4:	008209b4 	movhi	r2,2086
 82369c8:	10b9ad04 	addi	r2,r2,-6476
 82369cc:	10c02515 	stw	r3,148(r2)
         tcpstat.tcps_rcvbyteafterwin += todrop;
 82369d0:	008209b4 	movhi	r2,2086
 82369d4:	10b9ad04 	addi	r2,r2,-6476
 82369d8:	10c02617 	ldw	r3,152(r2)
 82369dc:	e0bfe917 	ldw	r2,-92(fp)
 82369e0:	1887883a 	add	r3,r3,r2
 82369e4:	008209b4 	movhi	r2,2086
 82369e8:	10b9ad04 	addi	r2,r2,-6476
 82369ec:	10c02615 	stw	r3,152(r2)
      }
      tp->snd_wl1 = ti->ti_seq - 1;
 82369f0:	e0bff217 	ldw	r2,-56(fp)
 82369f4:	10800617 	ldw	r2,24(r2)
 82369f8:	10ffffc4 	addi	r3,r2,-1
 82369fc:	e0bfe617 	ldw	r2,-104(fp)
 8236a00:	10c01115 	stw	r3,68(r2)
      tp->rcv_up = ti->ti_seq;
 8236a04:	e0bff217 	ldw	r2,-56(fp)
 8236a08:	10c00617 	ldw	r3,24(r2)
 8236a0c:	e0bfe617 	ldw	r2,-104(fp)
 8236a10:	10c01715 	stw	r3,92(r2)
      goto step6;
 8236a14:	0002ee06 	br	82375d0 <tcp_input+0x1bf4>
    * States other than LISTEN or SYN_SENT.
    * First check that at least some bytes of segment are within 
    * receive window.  If segment begins before rcv_nxt,
    * drop leading data (and SYN); if nothing left, just ack.
    */
   todrop = (int)(tp->rcv_nxt - ti->ti_seq);
 8236a18:	e0bfe617 	ldw	r2,-104(fp)
 8236a1c:	10c01617 	ldw	r3,88(r2)
 8236a20:	e0bff217 	ldw	r2,-56(fp)
 8236a24:	10800617 	ldw	r2,24(r2)
 8236a28:	1885c83a 	sub	r2,r3,r2
 8236a2c:	e0bfe915 	stw	r2,-92(fp)
   if (todrop > 0) 
 8236a30:	e0bfe917 	ldw	r2,-92(fp)
 8236a34:	0080910e 	bge	zero,r2,8236c7c <tcp_input+0x12a0>
   {
      if (tiflags & TH_SYN) 
 8236a38:	e0bfe717 	ldw	r2,-100(fp)
 8236a3c:	1080008c 	andi	r2,r2,2
 8236a40:	10001c26 	beq	r2,zero,8236ab4 <tcp_input+0x10d8>
      {
         tiflags &= ~TH_SYN;
 8236a44:	e0ffe717 	ldw	r3,-100(fp)
 8236a48:	00bfff44 	movi	r2,-3
 8236a4c:	1884703a 	and	r2,r3,r2
 8236a50:	e0bfe715 	stw	r2,-100(fp)
         ti->ti_seq++;
 8236a54:	e0bff217 	ldw	r2,-56(fp)
 8236a58:	10800617 	ldw	r2,24(r2)
 8236a5c:	10c00044 	addi	r3,r2,1
 8236a60:	e0bff217 	ldw	r2,-56(fp)
 8236a64:	10c00615 	stw	r3,24(r2)
         if (ti->ti_urp > 1) 
 8236a68:	e0bff217 	ldw	r2,-56(fp)
 8236a6c:	1080098b 	ldhu	r2,38(r2)
 8236a70:	10bfffcc 	andi	r2,r2,65535
 8236a74:	108000b0 	cmpltui	r2,r2,2
 8236a78:	1000071e 	bne	r2,zero,8236a98 <tcp_input+0x10bc>
            ti->ti_urp--;
 8236a7c:	e0bff217 	ldw	r2,-56(fp)
 8236a80:	1080098b 	ldhu	r2,38(r2)
 8236a84:	10bfffc4 	addi	r2,r2,-1
 8236a88:	1007883a 	mov	r3,r2
 8236a8c:	e0bff217 	ldw	r2,-56(fp)
 8236a90:	10c0098d 	sth	r3,38(r2)
 8236a94:	00000406 	br	8236aa8 <tcp_input+0x10cc>
         else
            tiflags &= ~TH_URG;
 8236a98:	e0ffe717 	ldw	r3,-100(fp)
 8236a9c:	00bff7c4 	movi	r2,-33
 8236aa0:	1884703a 	and	r2,r3,r2
 8236aa4:	e0bfe715 	stw	r2,-100(fp)
         todrop--;
 8236aa8:	e0bfe917 	ldw	r2,-92(fp)
 8236aac:	10bfffc4 	addi	r2,r2,-1
 8236ab0:	e0bfe915 	stw	r2,-92(fp)
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 8236ab4:	e0bff217 	ldw	r2,-56(fp)
 8236ab8:	1080028b 	ldhu	r2,10(r2)
 8236abc:	10ffffcc 	andi	r3,r2,65535
 8236ac0:	e0bfe917 	ldw	r2,-92(fp)
 8236ac4:	18800816 	blt	r3,r2,8236ae8 <tcp_input+0x110c>
          ((todrop == (int)ti->ti_len) && 
 8236ac8:	e0bff217 	ldw	r2,-56(fp)
 8236acc:	1080028b 	ldhu	r2,10(r2)
 8236ad0:	10ffffcc 	andi	r3,r2,65535
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 8236ad4:	e0bfe917 	ldw	r2,-92(fp)
 8236ad8:	1880351e 	bne	r3,r2,8236bb0 <tcp_input+0x11d4>
          ((todrop == (int)ti->ti_len) && 
          (tiflags&TH_FIN) == 0)) 
 8236adc:	e0bfe717 	ldw	r2,-100(fp)
 8236ae0:	1080004c 	andi	r2,r2,1
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
          ((todrop == (int)ti->ti_len) && 
 8236ae4:	1000321e 	bne	r2,zero,8236bb0 <tcp_input+0x11d4>
          (tiflags&TH_FIN) == 0)) 
      {
         tcpstat.tcps_rcvduppack++;
 8236ae8:	008209b4 	movhi	r2,2086
 8236aec:	10b9ad04 	addi	r2,r2,-6476
 8236af0:	10801f17 	ldw	r2,124(r2)
 8236af4:	10c00044 	addi	r3,r2,1
 8236af8:	008209b4 	movhi	r2,2086
 8236afc:	10b9ad04 	addi	r2,r2,-6476
 8236b00:	10c01f15 	stw	r3,124(r2)
         tcpstat.tcps_rcvdupbyte += ti->ti_len;
 8236b04:	008209b4 	movhi	r2,2086
 8236b08:	10b9ad04 	addi	r2,r2,-6476
 8236b0c:	10c02017 	ldw	r3,128(r2)
 8236b10:	e0bff217 	ldw	r2,-56(fp)
 8236b14:	1080028b 	ldhu	r2,10(r2)
 8236b18:	10bfffcc 	andi	r2,r2,65535
 8236b1c:	1887883a 	add	r3,r3,r2
 8236b20:	008209b4 	movhi	r2,2086
 8236b24:	10b9ad04 	addi	r2,r2,-6476
 8236b28:	10c02015 	stw	r3,128(r2)
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 8236b2c:	e0bfe717 	ldw	r2,-100(fp)
 8236b30:	1080004c 	andi	r2,r2,1
 8236b34:	10000626 	beq	r2,zero,8236b50 <tcp_input+0x1174>
 8236b38:	e0bff217 	ldw	r2,-56(fp)
 8236b3c:	1080028b 	ldhu	r2,10(r2)
 8236b40:	10bfffcc 	andi	r2,r2,65535
 8236b44:	10c00044 	addi	r3,r2,1
 8236b48:	e0bfe917 	ldw	r2,-92(fp)
 8236b4c:	18800926 	beq	r3,r2,8236b74 <tcp_input+0x1198>
            (tiflags & TH_RST && ti->ti_seq == tp->rcv_nxt - 1))
 8236b50:	e0bfe717 	ldw	r2,-100(fp)
 8236b54:	1080010c 	andi	r2,r2,4
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 8236b58:	10040026 	beq	r2,zero,8237b5c <tcp_input+0x2180>
            (tiflags & TH_RST && ti->ti_seq == tp->rcv_nxt - 1))
 8236b5c:	e0bff217 	ldw	r2,-56(fp)
 8236b60:	10c00617 	ldw	r3,24(r2)
 8236b64:	e0bfe617 	ldw	r2,-104(fp)
 8236b68:	10801617 	ldw	r2,88(r2)
 8236b6c:	10bfffc4 	addi	r2,r2,-1
 8236b70:	1883fa1e 	bne	r3,r2,8237b5c <tcp_input+0x2180>
         {
            todrop = ti->ti_len;
 8236b74:	e0bff217 	ldw	r2,-56(fp)
 8236b78:	1080028b 	ldhu	r2,10(r2)
 8236b7c:	10bfffcc 	andi	r2,r2,65535
 8236b80:	e0bfe915 	stw	r2,-92(fp)
            tiflags &= ~TH_FIN;
 8236b84:	e0ffe717 	ldw	r3,-100(fp)
 8236b88:	00bfff84 	movi	r2,-2
 8236b8c:	1884703a 	and	r2,r3,r2
 8236b90:	e0bfe715 	stw	r2,-100(fp)
            tp->t_flags |= TF_ACKNOW;
 8236b94:	e0bfe617 	ldw	r2,-104(fp)
 8236b98:	10800b0b 	ldhu	r2,44(r2)
 8236b9c:	10800054 	ori	r2,r2,1
 8236ba0:	1007883a 	mov	r3,r2
 8236ba4:	e0bfe617 	ldw	r2,-104(fp)
 8236ba8:	10c00b0d 	sth	r3,44(r2)
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 8236bac:	00000f06 	br	8236bec <tcp_input+0x1210>
         else
            goto dropafterack;
      }
      else 
      {
         tcpstat.tcps_rcvpartduppack++;
 8236bb0:	008209b4 	movhi	r2,2086
 8236bb4:	10b9ad04 	addi	r2,r2,-6476
 8236bb8:	10802117 	ldw	r2,132(r2)
 8236bbc:	10c00044 	addi	r3,r2,1
 8236bc0:	008209b4 	movhi	r2,2086
 8236bc4:	10b9ad04 	addi	r2,r2,-6476
 8236bc8:	10c02115 	stw	r3,132(r2)
         tcpstat.tcps_rcvpartdupbyte += todrop;
 8236bcc:	008209b4 	movhi	r2,2086
 8236bd0:	10b9ad04 	addi	r2,r2,-6476
 8236bd4:	10c02217 	ldw	r3,136(r2)
 8236bd8:	e0bfe917 	ldw	r2,-92(fp)
 8236bdc:	1887883a 	add	r3,r3,r2
 8236be0:	008209b4 	movhi	r2,2086
 8236be4:	10b9ad04 	addi	r2,r2,-6476
 8236be8:	10c02215 	stw	r3,136(r2)
      }
      m_adj(m, todrop);
 8236bec:	e17fe917 	ldw	r5,-92(fp)
 8236bf0:	e13ffe17 	ldw	r4,-8(fp)
 8236bf4:	822e9cc0 	call	822e9cc <m_adj>
      ti->ti_seq += todrop;
 8236bf8:	e0bff217 	ldw	r2,-56(fp)
 8236bfc:	10c00617 	ldw	r3,24(r2)
 8236c00:	e0bfe917 	ldw	r2,-92(fp)
 8236c04:	1887883a 	add	r3,r3,r2
 8236c08:	e0bff217 	ldw	r2,-56(fp)
 8236c0c:	10c00615 	stw	r3,24(r2)
      ti->ti_len -= (u_short)todrop;
 8236c10:	e0bff217 	ldw	r2,-56(fp)
 8236c14:	1080028b 	ldhu	r2,10(r2)
 8236c18:	e0ffe917 	ldw	r3,-92(fp)
 8236c1c:	10c5c83a 	sub	r2,r2,r3
 8236c20:	1007883a 	mov	r3,r2
 8236c24:	e0bff217 	ldw	r2,-56(fp)
 8236c28:	10c0028d 	sth	r3,10(r2)
      if (ti->ti_urp > (u_short)todrop)
 8236c2c:	e0bff217 	ldw	r2,-56(fp)
 8236c30:	1080098b 	ldhu	r2,38(r2)
 8236c34:	10bfffcc 	andi	r2,r2,65535
 8236c38:	e0ffe917 	ldw	r3,-92(fp)
 8236c3c:	18ffffcc 	andi	r3,r3,65535
 8236c40:	1880080e 	bge	r3,r2,8236c64 <tcp_input+0x1288>
         ti->ti_urp -= (u_short)todrop;
 8236c44:	e0bff217 	ldw	r2,-56(fp)
 8236c48:	1080098b 	ldhu	r2,38(r2)
 8236c4c:	e0ffe917 	ldw	r3,-92(fp)
 8236c50:	10c5c83a 	sub	r2,r2,r3
 8236c54:	1007883a 	mov	r3,r2
 8236c58:	e0bff217 	ldw	r2,-56(fp)
 8236c5c:	10c0098d 	sth	r3,38(r2)
 8236c60:	00000606 	br	8236c7c <tcp_input+0x12a0>
      else 
      {
         tiflags &= ~TH_URG;
 8236c64:	e0ffe717 	ldw	r3,-100(fp)
 8236c68:	00bff7c4 	movi	r2,-33
 8236c6c:	1884703a 	and	r2,r3,r2
 8236c70:	e0bfe715 	stw	r2,-100(fp)
         ti->ti_urp = 0;
 8236c74:	e0bff217 	ldw	r2,-56(fp)
 8236c78:	1000098d 	sth	zero,38(r2)

   /*
    * If new data are received on a connection after the
    * user processes are gone, then RST the other end.
    */
   if ((so->so_state & SS_NOFDREF) &&
 8236c7c:	e0bfe817 	ldw	r2,-96(fp)
 8236c80:	1080088b 	ldhu	r2,34(r2)
 8236c84:	10bfffcc 	andi	r2,r2,65535
 8236c88:	1080004c 	andi	r2,r2,1
 8236c8c:	10001526 	beq	r2,zero,8236ce4 <tcp_input+0x1308>
       tp->t_state > TCPS_CLOSE_WAIT && ti->ti_len) 
 8236c90:	e0bfe617 	ldw	r2,-104(fp)
 8236c94:	10800217 	ldw	r2,8(r2)

   /*
    * If new data are received on a connection after the
    * user processes are gone, then RST the other end.
    */
   if ((so->so_state & SS_NOFDREF) &&
 8236c98:	10800190 	cmplti	r2,r2,6
 8236c9c:	1000111e 	bne	r2,zero,8236ce4 <tcp_input+0x1308>
       tp->t_state > TCPS_CLOSE_WAIT && ti->ti_len) 
 8236ca0:	e0bff217 	ldw	r2,-56(fp)
 8236ca4:	1080028b 	ldhu	r2,10(r2)
 8236ca8:	10bfffcc 	andi	r2,r2,65535
 8236cac:	10000d26 	beq	r2,zero,8236ce4 <tcp_input+0x1308>
   {
      tp = tcp_close(tp);
 8236cb0:	e13fe617 	ldw	r4,-104(fp)
 8236cb4:	8239c3c0 	call	8239c3c <tcp_close>
 8236cb8:	e0bfe615 	stw	r2,-104(fp)
      tcpstat.tcps_rcvafterclose++;
 8236cbc:	008209b4 	movhi	r2,2086
 8236cc0:	10b9ad04 	addi	r2,r2,-6476
 8236cc4:	10802717 	ldw	r2,156(r2)
 8236cc8:	10c00044 	addi	r3,r2,1
 8236ccc:	008209b4 	movhi	r2,2086
 8236cd0:	10b9ad04 	addi	r2,r2,-6476
 8236cd4:	10c02715 	stw	r3,156(r2)
      GOTO_DROPWITHRESET;
 8236cd8:	00810444 	movi	r2,1041
 8236cdc:	d0a0b215 	stw	r2,-32056(gp)
 8236ce0:	0003af06 	br	8237ba0 <tcp_input+0x21c4>

   /*
    * If segment ends after window, drop trailing data
    * (and PUSH and FIN); if nothing left, just ACK.
    */
   todrop = (int)((ti->ti_seq + (short)ti->ti_len) - (tp->rcv_nxt+tp->rcv_wnd));
 8236ce4:	e0bff217 	ldw	r2,-56(fp)
 8236ce8:	10c00617 	ldw	r3,24(r2)
 8236cec:	e0bff217 	ldw	r2,-56(fp)
 8236cf0:	1080028b 	ldhu	r2,10(r2)
 8236cf4:	10bfffcc 	andi	r2,r2,65535
 8236cf8:	10a0001c 	xori	r2,r2,32768
 8236cfc:	10a00004 	addi	r2,r2,-32768
 8236d00:	1887883a 	add	r3,r3,r2
 8236d04:	e0bfe617 	ldw	r2,-104(fp)
 8236d08:	11001617 	ldw	r4,88(r2)
 8236d0c:	e0bfe617 	ldw	r2,-104(fp)
 8236d10:	10801517 	ldw	r2,84(r2)
 8236d14:	2085883a 	add	r2,r4,r2
 8236d18:	1885c83a 	sub	r2,r3,r2
 8236d1c:	e0bfe915 	stw	r2,-92(fp)
   if (todrop > 0) 
 8236d20:	e0bfe917 	ldw	r2,-92(fp)
 8236d24:	0080690e 	bge	zero,r2,8236ecc <tcp_input+0x14f0>
   {
      tcpstat.tcps_rcvpackafterwin++;
 8236d28:	008209b4 	movhi	r2,2086
 8236d2c:	10b9ad04 	addi	r2,r2,-6476
 8236d30:	10802517 	ldw	r2,148(r2)
 8236d34:	10c00044 	addi	r3,r2,1
 8236d38:	008209b4 	movhi	r2,2086
 8236d3c:	10b9ad04 	addi	r2,r2,-6476
 8236d40:	10c02515 	stw	r3,148(r2)
      if (todrop >= (int)ti->ti_len) 
 8236d44:	e0bff217 	ldw	r2,-56(fp)
 8236d48:	1080028b 	ldhu	r2,10(r2)
 8236d4c:	10bfffcc 	andi	r2,r2,65535
 8236d50:	e0ffe917 	ldw	r3,-92(fp)
 8236d54:	18803a16 	blt	r3,r2,8236e40 <tcp_input+0x1464>
      {
         tcpstat.tcps_rcvbyteafterwin += ti->ti_len;
 8236d58:	008209b4 	movhi	r2,2086
 8236d5c:	10b9ad04 	addi	r2,r2,-6476
 8236d60:	10c02617 	ldw	r3,152(r2)
 8236d64:	e0bff217 	ldw	r2,-56(fp)
 8236d68:	1080028b 	ldhu	r2,10(r2)
 8236d6c:	10bfffcc 	andi	r2,r2,65535
 8236d70:	1887883a 	add	r3,r3,r2
 8236d74:	008209b4 	movhi	r2,2086
 8236d78:	10b9ad04 	addi	r2,r2,-6476
 8236d7c:	10c02615 	stw	r3,152(r2)
          * If a new connection request is received
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
 8236d80:	e0bfe717 	ldw	r2,-100(fp)
 8236d84:	1080008c 	andi	r2,r2,2
 8236d88:	10001726 	beq	r2,zero,8236de8 <tcp_input+0x140c>
             tp->t_state == TCPS_TIME_WAIT &&
 8236d8c:	e0bfe617 	ldw	r2,-104(fp)
 8236d90:	10800217 	ldw	r2,8(r2)
          * If a new connection request is received
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
 8236d94:	10800298 	cmpnei	r2,r2,10
 8236d98:	1000131e 	bne	r2,zero,8236de8 <tcp_input+0x140c>
             tp->t_state == TCPS_TIME_WAIT &&
             SEQ_GT(ti->ti_seq, tp->rcv_nxt)) 
 8236d9c:	e0bff217 	ldw	r2,-56(fp)
 8236da0:	10c00617 	ldw	r3,24(r2)
 8236da4:	e0bfe617 	ldw	r2,-104(fp)
 8236da8:	10801617 	ldw	r2,88(r2)
 8236dac:	1885c83a 	sub	r2,r3,r2
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
             tp->t_state == TCPS_TIME_WAIT &&
 8236db0:	00800d0e 	bge	zero,r2,8236de8 <tcp_input+0x140c>
             SEQ_GT(ti->ti_seq, tp->rcv_nxt)) 
         {
            iss = (tcp_seq)(tp->rcv_nxt + (TCP_ISSINCR));
 8236db4:	e0bfe617 	ldw	r2,-104(fp)
 8236db8:	10c01617 	ldw	r3,88(r2)
 8236dbc:	008000b4 	movhi	r2,2
 8236dc0:	10bd3fc4 	addi	r2,r2,-2817
 8236dc4:	1885883a 	add	r2,r3,r2
 8236dc8:	e0bfed15 	stw	r2,-76(fp)
            if (iss & 0xff000000)
 8236dcc:	e0bfed17 	ldw	r2,-76(fp)
 8236dd0:	10bfc02c 	andhi	r2,r2,65280
 8236dd4:	10000126 	beq	r2,zero,8236ddc <tcp_input+0x1400>
            {
               iss = 0L;
 8236dd8:	e03fed15 	stw	zero,-76(fp)
            }
            (void) tcp_close(tp);
 8236ddc:	e13fe617 	ldw	r4,-104(fp)
 8236de0:	8239c3c0 	call	8239c3c <tcp_close>
            goto findpcb;
 8236de4:	003bd406 	br	8235d38 <tcp_input+0x35c>
          * window edge, and have to drop data and PUSH from
          * incoming segments.  Continue processing, but
          * remember to ack.  Otherwise, drop segment
          * and ack.
          */
         if ((tp->rcv_wnd == 0) && (ti->ti_seq == tp->rcv_nxt))
 8236de8:	e0bfe617 	ldw	r2,-104(fp)
 8236dec:	10801517 	ldw	r2,84(r2)
 8236df0:	10035a1e 	bne	r2,zero,8237b5c <tcp_input+0x2180>
 8236df4:	e0bff217 	ldw	r2,-56(fp)
 8236df8:	10c00617 	ldw	r3,24(r2)
 8236dfc:	e0bfe617 	ldw	r2,-104(fp)
 8236e00:	10801617 	ldw	r2,88(r2)
 8236e04:	1883551e 	bne	r3,r2,8237b5c <tcp_input+0x2180>
         {
            tp->t_flags |= TF_ACKNOW;
 8236e08:	e0bfe617 	ldw	r2,-104(fp)
 8236e0c:	10800b0b 	ldhu	r2,44(r2)
 8236e10:	10800054 	ori	r2,r2,1
 8236e14:	1007883a 	mov	r3,r2
 8236e18:	e0bfe617 	ldw	r2,-104(fp)
 8236e1c:	10c00b0d 	sth	r3,44(r2)
            tcpstat.tcps_rcvwinprobe++;
 8236e20:	008209b4 	movhi	r2,2086
 8236e24:	10b9ad04 	addi	r2,r2,-6476
 8236e28:	10802817 	ldw	r2,160(r2)
 8236e2c:	10c00044 	addi	r3,r2,1
 8236e30:	008209b4 	movhi	r2,2086
 8236e34:	10b9ad04 	addi	r2,r2,-6476
 8236e38:	10c02815 	stw	r3,160(r2)
 8236e3c:	00000806 	br	8236e60 <tcp_input+0x1484>
         } else
            goto dropafterack;
      } else
         tcpstat.tcps_rcvbyteafterwin += todrop;
 8236e40:	008209b4 	movhi	r2,2086
 8236e44:	10b9ad04 	addi	r2,r2,-6476
 8236e48:	10c02617 	ldw	r3,152(r2)
 8236e4c:	e0bfe917 	ldw	r2,-92(fp)
 8236e50:	1887883a 	add	r3,r3,r2
 8236e54:	008209b4 	movhi	r2,2086
 8236e58:	10b9ad04 	addi	r2,r2,-6476
 8236e5c:	10c02615 	stw	r3,152(r2)
      /* XXX work around m_adj bug */
      if (m->m_len) 
 8236e60:	e0bffe17 	ldw	r2,-8(fp)
 8236e64:	10800217 	ldw	r2,8(r2)
 8236e68:	10000626 	beq	r2,zero,8236e84 <tcp_input+0x14a8>
      {
         m_adj(m, -todrop);
 8236e6c:	e0bfe917 	ldw	r2,-92(fp)
 8236e70:	0085c83a 	sub	r2,zero,r2
 8236e74:	100b883a 	mov	r5,r2
 8236e78:	e13ffe17 	ldw	r4,-8(fp)
 8236e7c:	822e9cc0 	call	822e9cc <m_adj>
 8236e80:	00000706 	br	8236ea0 <tcp_input+0x14c4>
      }
      else 
      {
         /* skip tcp/ip header in first mbuf */
         m_adj(m->m_next, -todrop);
 8236e84:	e0bffe17 	ldw	r2,-8(fp)
 8236e88:	10c00617 	ldw	r3,24(r2)
 8236e8c:	e0bfe917 	ldw	r2,-92(fp)
 8236e90:	0085c83a 	sub	r2,zero,r2
 8236e94:	100b883a 	mov	r5,r2
 8236e98:	1809883a 	mov	r4,r3
 8236e9c:	822e9cc0 	call	822e9cc <m_adj>
      }
      ti->ti_len -= (u_short)todrop;
 8236ea0:	e0bff217 	ldw	r2,-56(fp)
 8236ea4:	1080028b 	ldhu	r2,10(r2)
 8236ea8:	e0ffe917 	ldw	r3,-92(fp)
 8236eac:	10c5c83a 	sub	r2,r2,r3
 8236eb0:	1007883a 	mov	r3,r2
 8236eb4:	e0bff217 	ldw	r2,-56(fp)
 8236eb8:	10c0028d 	sth	r3,10(r2)
      tiflags &= ~(TH_PUSH|TH_FIN);
 8236ebc:	e0ffe717 	ldw	r3,-100(fp)
 8236ec0:	00bffd84 	movi	r2,-10
 8236ec4:	1884703a 	and	r2,r3,r2
 8236ec8:	e0bfe715 	stw	r2,-100(fp)
      tiflags &= ~TH_RST;  /* clear reset flag */
      goto dropafterack;   /* send an ack and drop current packet */
   }
#endif /* DOS_RST */

   if (tiflags&TH_RST) 
 8236ecc:	e0bfe717 	ldw	r2,-100(fp)
 8236ed0:	1080010c 	andi	r2,r2,4
 8236ed4:	10003426 	beq	r2,zero,8236fa8 <tcp_input+0x15cc>
   {
      switch (tp->t_state) 
 8236ed8:	e0bfe617 	ldw	r2,-104(fp)
 8236edc:	10800217 	ldw	r2,8(r2)
 8236ee0:	10bfff44 	addi	r2,r2,-3
 8236ee4:	10c00228 	cmpgeui	r3,r2,8
 8236ee8:	18002f1e 	bne	r3,zero,8236fa8 <tcp_input+0x15cc>
 8236eec:	100690ba 	slli	r3,r2,2
 8236ef0:	008208f4 	movhi	r2,2083
 8236ef4:	109bc104 	addi	r2,r2,28420
 8236ef8:	1885883a 	add	r2,r3,r2
 8236efc:	10800017 	ldw	r2,0(r2)
 8236f00:	1000683a 	jmp	r2
 8236f04:	08236f24 	muli	zero,at,-29252
 8236f08:	08236f34 	orhi	zero,at,36284
 8236f0c:	08236f50 	cmplti	zero,at,-29251
 8236f10:	08236f50 	cmplti	zero,at,-29251
 8236f14:	08236f94 	ori	zero,at,36286
 8236f18:	08236f94 	ori	zero,at,36286
 8236f1c:	08236f50 	cmplti	zero,at,-29251
 8236f20:	08236f94 	ori	zero,at,36286
      {
   
      case TCPS_SYN_RECEIVED:
         so->so_error = ECONNREFUSED;
 8236f24:	e0bfe817 	ldw	r2,-96(fp)
 8236f28:	00c01bc4 	movi	r3,111
 8236f2c:	10c00615 	stw	r3,24(r2)
         goto close;
 8236f30:	00000a06 	br	8236f5c <tcp_input+0x1580>
   
      case TCPS_ESTABLISHED:
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 8236f34:	008209b4 	movhi	r2,2086
 8236f38:	10b97f04 	addi	r2,r2,-6660
 8236f3c:	10800717 	ldw	r2,28(r2)
 8236f40:	10c00044 	addi	r3,r2,1
 8236f44:	008209b4 	movhi	r2,2086
 8236f48:	10b97f04 	addi	r2,r2,-6660
 8236f4c:	10c00715 	stw	r3,28(r2)
      case TCPS_FIN_WAIT_1:
      case TCPS_FIN_WAIT_2:
      case TCPS_CLOSE_WAIT:
         so->so_error = ECONNRESET;
 8236f50:	e0bfe817 	ldw	r2,-96(fp)
 8236f54:	00c01a04 	movi	r3,104
 8236f58:	10c00615 	stw	r3,24(r2)
         close:
         tp->t_state = TCPS_CLOSED;
 8236f5c:	e0bfe617 	ldw	r2,-104(fp)
 8236f60:	10000215 	stw	zero,8(r2)
         tcpstat.tcps_drops++;
 8236f64:	008209b4 	movhi	r2,2086
 8236f68:	10b9ad04 	addi	r2,r2,-6476
 8236f6c:	10800317 	ldw	r2,12(r2)
 8236f70:	10c00044 	addi	r3,r2,1
 8236f74:	008209b4 	movhi	r2,2086
 8236f78:	10b9ad04 	addi	r2,r2,-6476
 8236f7c:	10c00315 	stw	r3,12(r2)
         SETTP(tp, tcp_close(tp));
 8236f80:	e13fe617 	ldw	r4,-104(fp)
 8236f84:	8239c3c0 	call	8239c3c <tcp_close>
#ifdef TCP_ZEROCOPY
         if (so->rx_upcall)
            so->rx_upcall(so, NULL, ECONNRESET);
#endif   /* TCP_ZEROCOPY */
         GOTO_DROP;
 8236f88:	00812204 	movi	r2,1160
 8236f8c:	d0a0b215 	stw	r2,-32056(gp)
 8236f90:	00034406 	br	8237ca4 <tcp_input+0x22c8>
   
      case TCPS_CLOSING:
      case TCPS_LAST_ACK:
      case TCPS_TIME_WAIT:
         SETTP(tp, tcp_close(tp));
 8236f94:	e13fe617 	ldw	r4,-104(fp)
 8236f98:	8239c3c0 	call	8239c3c <tcp_close>
         GOTO_DROP;
 8236f9c:	00812384 	movi	r2,1166
 8236fa0:	d0a0b215 	stw	r2,-32056(gp)
 8236fa4:	00033f06 	br	8237ca4 <tcp_input+0x22c8>
     tcp_trace("rcvd SYN in established state - ignoring SYN.\n");
#endif
      GOTO_DROP;
   }
#else
   if (tiflags & TH_SYN) 
 8236fa8:	e0bfe717 	ldw	r2,-100(fp)
 8236fac:	1080008c 	andi	r2,r2,2
 8236fb0:	10000726 	beq	r2,zero,8236fd0 <tcp_input+0x15f4>
   {
      tp = tcp_drop(tp, ECONNRESET);
 8236fb4:	01401a04 	movi	r5,104
 8236fb8:	e13fe617 	ldw	r4,-104(fp)
 8236fbc:	8239b900 	call	8239b90 <tcp_drop>
 8236fc0:	e0bfe615 	stw	r2,-104(fp)
      GOTO_DROPWITHRESET;
 8236fc4:	00812b04 	movi	r2,1196
 8236fc8:	d0a0b215 	stw	r2,-32056(gp)
 8236fcc:	0002f406 	br	8237ba0 <tcp_input+0x21c4>
#endif /* end of else of DOS_SYN */

   /*
    * If the ACK bit is off we drop the segment and return.
    */
   if ((tiflags & TH_ACK) == 0)
 8236fd0:	e0bfe717 	ldw	r2,-100(fp)
 8236fd4:	1080040c 	andi	r2,r2,16
 8236fd8:	1000031e 	bne	r2,zero,8236fe8 <tcp_input+0x160c>
      GOTO_DROP;
 8236fdc:	00812d04 	movi	r2,1204
 8236fe0:	d0a0b215 	stw	r2,-32056(gp)
 8236fe4:	00032f06 	br	8237ca4 <tcp_input+0x22c8>

   /*
    * Ack processing.
    */
   switch (tp->t_state) 
 8236fe8:	e0bfe617 	ldw	r2,-104(fp)
 8236fec:	10800217 	ldw	r2,8(r2)
 8236ff0:	10c000e0 	cmpeqi	r3,r2,3
 8236ff4:	1800051e 	bne	r3,zero,823700c <tcp_input+0x1630>
 8236ff8:	10c000d0 	cmplti	r3,r2,3
 8236ffc:	1801741e 	bne	r3,zero,82375d0 <tcp_input+0x1bf4>
 8237000:	108002c8 	cmpgei	r2,r2,11
 8237004:	1001721e 	bne	r2,zero,82375d0 <tcp_input+0x1bf4>
 8237008:	00003006 	br	82370cc <tcp_input+0x16f0>
    * In SYN_RECEIVED state if the ack ACKs our SYN then enter
    * ESTABLISHED state and continue processing, otherwise
    * send an RST.
    */
   case TCPS_SYN_RECEIVED:
      if (SEQ_GT(tp->snd_una, ti->ti_ack) ||
 823700c:	e0bfe617 	ldw	r2,-104(fp)
 8237010:	10c00e17 	ldw	r3,56(r2)
 8237014:	e0bff217 	ldw	r2,-56(fp)
 8237018:	10800717 	ldw	r2,28(r2)
 823701c:	1885c83a 	sub	r2,r3,r2
 8237020:	00800616 	blt	zero,r2,823703c <tcp_input+0x1660>
          SEQ_GT(ti->ti_ack, tp->snd_max))
 8237024:	e0bff217 	ldw	r2,-56(fp)
 8237028:	10c00717 	ldw	r3,28(r2)
 823702c:	e0bfe617 	ldw	r2,-104(fp)
 8237030:	10801a17 	ldw	r2,104(r2)
 8237034:	1885c83a 	sub	r2,r3,r2
    * In SYN_RECEIVED state if the ack ACKs our SYN then enter
    * ESTABLISHED state and continue processing, otherwise
    * send an RST.
    */
   case TCPS_SYN_RECEIVED:
      if (SEQ_GT(tp->snd_una, ti->ti_ack) ||
 8237038:	00800a0e 	bge	zero,r2,8237064 <tcp_input+0x1688>
          SEQ_GT(ti->ti_ack, tp->snd_max))
      {
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 823703c:	008209b4 	movhi	r2,2086
 8237040:	10b97f04 	addi	r2,r2,-6660
 8237044:	10800717 	ldw	r2,28(r2)
 8237048:	10c00044 	addi	r3,r2,1
 823704c:	008209b4 	movhi	r2,2086
 8237050:	10b97f04 	addi	r2,r2,-6660
 8237054:	10c00715 	stw	r3,28(r2)
         GOTO_DROPWITHRESET;
 8237058:	00813184 	movi	r2,1222
 823705c:	d0a0b215 	stw	r2,-32056(gp)
 8237060:	0002cf06 	br	8237ba0 <tcp_input+0x21c4>
      }
      tcpstat.tcps_connects++;
 8237064:	008209b4 	movhi	r2,2086
 8237068:	10b9ad04 	addi	r2,r2,-6476
 823706c:	10800217 	ldw	r2,8(r2)
 8237070:	10c00044 	addi	r3,r2,1
 8237074:	008209b4 	movhi	r2,2086
 8237078:	10b9ad04 	addi	r2,r2,-6476
 823707c:	10c00215 	stw	r3,8(r2)
      tp->t_state = TCPS_ESTABLISHED;
 8237080:	e0bfe617 	ldw	r2,-104(fp)
 8237084:	00c00104 	movi	r3,4
 8237088:	10c00215 	stw	r3,8(r2)
      soisconnected(so);
 823708c:	e13fe817 	ldw	r4,-96(fp)
 8237090:	8233b340 	call	8233b34 <soisconnected>
      tp->t_maxseg = tcp_mss(so);
 8237094:	e13fe817 	ldw	r4,-96(fp)
 8237098:	82382640 	call	8238264 <tcp_mss>
 823709c:	1007883a 	mov	r3,r2
 82370a0:	e0bfe617 	ldw	r2,-104(fp)
 82370a4:	10c00a0d 	sth	r3,40(r2)
      (void) tcp_reass(tp, (struct tcpiphdr *)0, m);
 82370a8:	e1bffe17 	ldw	r6,-8(fp)
 82370ac:	000b883a 	mov	r5,zero
 82370b0:	e13fe617 	ldw	r4,-104(fp)
 82370b4:	82355cc0 	call	82355cc <tcp_reass>
      tp->snd_wl1 = ti->ti_seq - 1;
 82370b8:	e0bff217 	ldw	r2,-56(fp)
 82370bc:	10800617 	ldw	r2,24(r2)
 82370c0:	10ffffc4 	addi	r3,r2,-1
 82370c4:	e0bfe617 	ldw	r2,-104(fp)
 82370c8:	10c01115 	stw	r3,68(r2)
   case TCPS_CLOSE_WAIT:
   case TCPS_CLOSING:
   case TCPS_LAST_ACK:
   case TCPS_TIME_WAIT:

      if (SEQ_LEQ(ti->ti_ack, tp->snd_una)) 
 82370cc:	e0bff217 	ldw	r2,-56(fp)
 82370d0:	10c00717 	ldw	r3,28(r2)
 82370d4:	e0bfe617 	ldw	r2,-104(fp)
 82370d8:	10800e17 	ldw	r2,56(r2)
 82370dc:	1885c83a 	sub	r2,r3,r2
 82370e0:	00806316 	blt	zero,r2,8237270 <tcp_input+0x1894>
      {
         if (ti->ti_len == 0 && rx_win == tp->snd_wnd) 
 82370e4:	e0bff217 	ldw	r2,-56(fp)
 82370e8:	1080028b 	ldhu	r2,10(r2)
 82370ec:	10bfffcc 	andi	r2,r2,65535
 82370f0:	10005a1e 	bne	r2,zero,823725c <tcp_input+0x1880>
 82370f4:	e0bfe617 	ldw	r2,-104(fp)
 82370f8:	10c01417 	ldw	r3,80(r2)
 82370fc:	e0bff517 	ldw	r2,-44(fp)
 8237100:	1880561e 	bne	r3,r2,823725c <tcp_input+0x1880>
         {
            tcpstat.tcps_rcvdupack++;
 8237104:	008209b4 	movhi	r2,2086
 8237108:	10b9ad04 	addi	r2,r2,-6476
 823710c:	10802917 	ldw	r2,164(r2)
 8237110:	10c00044 	addi	r3,r2,1
 8237114:	008209b4 	movhi	r2,2086
 8237118:	10b9ad04 	addi	r2,r2,-6476
 823711c:	10c02915 	stw	r3,164(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 8237120:	e0bfe617 	ldw	r2,-104(fp)
 8237124:	10800317 	ldw	r2,12(r2)
 8237128:	10000526 	beq	r2,zero,8237140 <tcp_input+0x1764>
                ti->ti_ack != tp->snd_una)
 823712c:	e0bff217 	ldw	r2,-56(fp)
 8237130:	10c00717 	ldw	r3,28(r2)
 8237134:	e0bfe617 	ldw	r2,-104(fp)
 8237138:	10800e17 	ldw	r2,56(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 823713c:	18800326 	beq	r3,r2,823714c <tcp_input+0x1770>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
 8237140:	e0bfe617 	ldw	r2,-104(fp)
 8237144:	10000915 	stw	zero,36(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 8237148:	00004706 	br	8237268 <tcp_input+0x188c>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
 823714c:	e0bfe617 	ldw	r2,-104(fp)
 8237150:	10800917 	ldw	r2,36(r2)
 8237154:	10c00044 	addi	r3,r2,1
 8237158:	e0bfe617 	ldw	r2,-104(fp)
 823715c:	10c00915 	stw	r3,36(r2)
 8237160:	e0bfe617 	ldw	r2,-104(fp)
 8237164:	10c00917 	ldw	r3,36(r2)
 8237168:	d0a03c83 	ldbu	r2,-32526(gp)
 823716c:	10803fcc 	andi	r2,r2,255
 8237170:	1080201c 	xori	r2,r2,128
 8237174:	10bfe004 	addi	r2,r2,-128
 8237178:	18803b1e 	bne	r3,r2,8237268 <tcp_input+0x188c>
            {
               tcp_seq onxt = tp->snd_nxt;
 823717c:	e0bfe617 	ldw	r2,-104(fp)
 8237180:	10800f17 	ldw	r2,60(r2)
 8237184:	e0bff815 	stw	r2,-32(fp)
               u_short  win   =
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
 8237188:	e0bfe617 	ldw	r2,-104(fp)
 823718c:	11001417 	ldw	r4,80(r2)
 8237190:	e0bfe617 	ldw	r2,-104(fp)
 8237194:	10c01b17 	ldw	r3,108(r2)
 8237198:	2005883a 	mov	r2,r4
 823719c:	1880012e 	bgeu	r3,r2,82371a4 <tcp_input+0x17c8>
 82371a0:	1805883a 	mov	r2,r3
 82371a4:	1006d07a 	srli	r3,r2,1
               tp->t_maxseg;
 82371a8:	e0bfe617 	ldw	r2,-104(fp)
 82371ac:	10800a0b 	ldhu	r2,40(r2)
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
            {
               tcp_seq onxt = tp->snd_nxt;
               u_short  win   =
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
 82371b0:	10bfffcc 	andi	r2,r2,65535
 82371b4:	100b883a 	mov	r5,r2
 82371b8:	1809883a 	mov	r4,r3
 82371bc:	8202c6c0 	call	8202c6c <__udivsi3>
               tp->t_dupacks = 0;
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
            {
               tcp_seq onxt = tp->snd_nxt;
               u_short  win   =
 82371c0:	e0bff00d 	sth	r2,-64(fp)
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
               tp->t_maxseg;

               if (win < 2)
 82371c4:	e0bff00b 	ldhu	r2,-64(fp)
 82371c8:	108000a8 	cmpgeui	r2,r2,2
 82371cc:	1000021e 	bne	r2,zero,82371d8 <tcp_input+0x17fc>
                  win = 2;
 82371d0:	00800084 	movi	r2,2
 82371d4:	e0bff00d 	sth	r2,-64(fp)
               tp->snd_ssthresh = (u_short)(win * tp->t_maxseg);
 82371d8:	e0bfe617 	ldw	r2,-104(fp)
 82371dc:	10c00a0b 	ldhu	r3,40(r2)
 82371e0:	e0bff00b 	ldhu	r2,-64(fp)
 82371e4:	1885383a 	mul	r2,r3,r2
 82371e8:	10ffffcc 	andi	r3,r2,65535
 82371ec:	e0bfe617 	ldw	r2,-104(fp)
 82371f0:	10c01c15 	stw	r3,112(r2)

               tp->t_timer[TCPT_REXMT] = 0;
 82371f4:	e0bfe617 	ldw	r2,-104(fp)
 82371f8:	10000315 	stw	zero,12(r2)
               tp->t_rttick = 0;
 82371fc:	e0bfe617 	ldw	r2,-104(fp)
 8237200:	10001e15 	stw	zero,120(r2)
               tp->snd_nxt = ti->ti_ack;
 8237204:	e0bff217 	ldw	r2,-56(fp)
 8237208:	10c00717 	ldw	r3,28(r2)
 823720c:	e0bfe617 	ldw	r2,-104(fp)
 8237210:	10c00f15 	stw	r3,60(r2)
               tp->snd_cwnd = tp->t_maxseg;
 8237214:	e0bfe617 	ldw	r2,-104(fp)
 8237218:	10800a0b 	ldhu	r2,40(r2)
 823721c:	10ffffcc 	andi	r3,r2,65535
 8237220:	e0bfe617 	ldw	r2,-104(fp)
 8237224:	10c01b15 	stw	r3,108(r2)
               (void) tcp_output(tp);
 8237228:	e13fe617 	ldw	r4,-104(fp)
 823722c:	823835c0 	call	823835c <tcp_output>

               if (SEQ_GT(onxt, tp->snd_nxt))
 8237230:	e0bfe617 	ldw	r2,-104(fp)
 8237234:	10800f17 	ldw	r2,60(r2)
 8237238:	e0fff817 	ldw	r3,-32(fp)
 823723c:	1885c83a 	sub	r2,r3,r2
 8237240:	0080030e 	bge	zero,r2,8237250 <tcp_input+0x1874>
                  tp->snd_nxt = onxt;
 8237244:	e0bfe617 	ldw	r2,-104(fp)
 8237248:	e0fff817 	ldw	r3,-32(fp)
 823724c:	10c00f15 	stw	r3,60(r2)
               GOTO_DROP;
 8237250:	00814544 	movi	r2,1301
 8237254:	d0a0b215 	stw	r2,-32056(gp)
 8237258:	00029206 	br	8237ca4 <tcp_input+0x22c8>
            }
         } else
            tp->t_dupacks = 0;
 823725c:	e0bfe617 	ldw	r2,-104(fp)
 8237260:	10000915 	stw	zero,36(r2)
         break;
 8237264:	0000da06 	br	82375d0 <tcp_input+0x1bf4>
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 8237268:	0001883a 	nop
                  tp->snd_nxt = onxt;
               GOTO_DROP;
            }
         } else
            tp->t_dupacks = 0;
         break;
 823726c:	0000d806 	br	82375d0 <tcp_input+0x1bf4>
      }
      tp->t_dupacks = 0;
 8237270:	e0bfe617 	ldw	r2,-104(fp)
 8237274:	10000915 	stw	zero,36(r2)
      if (SEQ_GT(ti->ti_ack, tp->snd_max)) 
 8237278:	e0bff217 	ldw	r2,-56(fp)
 823727c:	10c00717 	ldw	r3,28(r2)
 8237280:	e0bfe617 	ldw	r2,-104(fp)
 8237284:	10801a17 	ldw	r2,104(r2)
 8237288:	1885c83a 	sub	r2,r3,r2
 823728c:	0080080e 	bge	zero,r2,82372b0 <tcp_input+0x18d4>
      {
         tcpstat.tcps_rcvacktoomuch++;
 8237290:	008209b4 	movhi	r2,2086
 8237294:	10b9ad04 	addi	r2,r2,-6476
 8237298:	10802a17 	ldw	r2,168(r2)
 823729c:	10c00044 	addi	r3,r2,1
 82372a0:	008209b4 	movhi	r2,2086
 82372a4:	10b9ad04 	addi	r2,r2,-6476
 82372a8:	10c02a15 	stw	r3,168(r2)
         goto dropafterack;
 82372ac:	00022b06 	br	8237b5c <tcp_input+0x2180>
      }
      acked = (int)(ti->ti_ack - tp->snd_una);
 82372b0:	e0bff217 	ldw	r2,-56(fp)
 82372b4:	10c00717 	ldw	r3,28(r2)
 82372b8:	e0bfe617 	ldw	r2,-104(fp)
 82372bc:	10800e17 	ldw	r2,56(r2)
 82372c0:	1885c83a 	sub	r2,r3,r2
 82372c4:	e0bff615 	stw	r2,-40(fp)
      tcpstat.tcps_rcvackpack++;
 82372c8:	008209b4 	movhi	r2,2086
 82372cc:	10b9ad04 	addi	r2,r2,-6476
 82372d0:	10802b17 	ldw	r2,172(r2)
 82372d4:	10c00044 	addi	r3,r2,1
 82372d8:	008209b4 	movhi	r2,2086
 82372dc:	10b9ad04 	addi	r2,r2,-6476
 82372e0:	10c02b15 	stw	r3,172(r2)
      tcpstat.tcps_rcvackbyte += acked;
 82372e4:	008209b4 	movhi	r2,2086
 82372e8:	10b9ad04 	addi	r2,r2,-6476
 82372ec:	10c02c17 	ldw	r3,176(r2)
 82372f0:	e0bff617 	ldw	r2,-40(fp)
 82372f4:	1887883a 	add	r3,r3,r2
 82372f8:	008209b4 	movhi	r2,2086
 82372fc:	10b9ad04 	addi	r2,r2,-6476
 8237300:	10c02c15 	stw	r3,176(r2)
       * number was acked, update smoothed round trip time.
       * Since we now have an rtt measurement, cancel the
       * timer backoff (cf., Phil Karn's retransmit alg.).
       * Recompute the initial retransmit timer.
       */
      if((tp->t_rttick) && 
 8237304:	e0bfe617 	ldw	r2,-104(fp)
 8237308:	10801e17 	ldw	r2,120(r2)
 823730c:	10000826 	beq	r2,zero,8237330 <tcp_input+0x1954>
#ifdef TCP_TIMESTAMP
         ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
         (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
 8237310:	e0bff217 	ldw	r2,-56(fp)
 8237314:	10c00717 	ldw	r3,28(r2)
 8237318:	e0bfe617 	ldw	r2,-104(fp)
 823731c:	10801f17 	ldw	r2,124(r2)
 8237320:	1885c83a 	sub	r2,r3,r2
       * number was acked, update smoothed round trip time.
       * Since we now have an rtt measurement, cancel the
       * timer backoff (cf., Phil Karn's retransmit alg.).
       * Recompute the initial retransmit timer.
       */
      if((tp->t_rttick) && 
 8237324:	0080020e 	bge	zero,r2,8237330 <tcp_input+0x1954>
#ifdef TCP_TIMESTAMP
         ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
         (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
         tcp_xmit_timer(tp);
 8237328:	e13fe617 	ldw	r4,-104(fp)
 823732c:	8237fc00 	call	8237fc0 <tcp_xmit_timer>
       * If all outstanding data is acked, stop retransmit
       * timer and remember to restart (more output or persist).
       * If there is more data to be acked, restart retransmit
       * timer, using current (possibly backed-off) value.
       */
      if (ti->ti_ack == tp->snd_max) 
 8237330:	e0bff217 	ldw	r2,-56(fp)
 8237334:	10c00717 	ldw	r3,28(r2)
 8237338:	e0bfe617 	ldw	r2,-104(fp)
 823733c:	10801a17 	ldw	r2,104(r2)
 8237340:	1880051e 	bne	r3,r2,8237358 <tcp_input+0x197c>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 8237344:	e0bfe617 	ldw	r2,-104(fp)
 8237348:	10000315 	stw	zero,12(r2)
         needoutput = 1;
 823734c:	00800044 	movi	r2,1
 8237350:	e0bfeb15 	stw	r2,-84(fp)
 8237354:	00000706 	br	8237374 <tcp_input+0x1998>
      } else if (tp->t_timer[TCPT_PERSIST] == 0)
 8237358:	e0bfe617 	ldw	r2,-104(fp)
 823735c:	10800417 	ldw	r2,16(r2)
 8237360:	1000041e 	bne	r2,zero,8237374 <tcp_input+0x1998>
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 8237364:	e0bfe617 	ldw	r2,-104(fp)
 8237368:	10c00817 	ldw	r3,32(r2)
 823736c:	e0bfe617 	ldw	r2,-104(fp)
 8237370:	10c00315 	stw	r3,12(r2)
       * in flight, open exponentially (maxseg per packet).
       * Otherwise open linearly (maxseg per window,
       * or maxseg^2 / cwnd per packet).
       */
      {
         tcp_win  cw =  tp->snd_cwnd;
 8237374:	e0bfe617 	ldw	r2,-104(fp)
 8237378:	10801b17 	ldw	r2,108(r2)
 823737c:	e0bff915 	stw	r2,-28(fp)
         u_short  incr  =  tp->t_maxseg;
 8237380:	e0bfe617 	ldw	r2,-104(fp)
 8237384:	10800a0b 	ldhu	r2,40(r2)
 8237388:	e0bff08d 	sth	r2,-62(fp)

         if (cw > tp->snd_ssthresh)
 823738c:	e0bfe617 	ldw	r2,-104(fp)
 8237390:	10c01c17 	ldw	r3,112(r2)
 8237394:	e0bff917 	ldw	r2,-28(fp)
 8237398:	18800a2e 	bgeu	r3,r2,82373c4 <tcp_input+0x19e8>
            incr = MAX( (incr * incr / cw), (ALIGN_TYPE << 2) );
 823739c:	e0fff08b 	ldhu	r3,-62(fp)
 82373a0:	e0bff08b 	ldhu	r2,-62(fp)
 82373a4:	1885383a 	mul	r2,r3,r2
 82373a8:	e17ff917 	ldw	r5,-28(fp)
 82373ac:	1009883a 	mov	r4,r2
 82373b0:	8202c6c0 	call	8202c6c <__udivsi3>
 82373b4:	10c00428 	cmpgeui	r3,r2,16
 82373b8:	1800011e 	bne	r3,zero,82373c0 <tcp_input+0x19e4>
 82373bc:	00800404 	movi	r2,16
 82373c0:	e0bff08d 	sth	r2,-62(fp)

         tp->snd_cwnd = MIN(cw + (u_short)incr, (IP_MAXPACKET));
 82373c4:	e0fff08b 	ldhu	r3,-62(fp)
 82373c8:	e0bff917 	ldw	r2,-28(fp)
 82373cc:	1885883a 	add	r2,r3,r2
 82373d0:	10d80070 	cmpltui	r3,r2,24577
 82373d4:	1800011e 	bne	r3,zero,82373dc <tcp_input+0x1a00>
 82373d8:	00980004 	movi	r2,24576
 82373dc:	e0ffe617 	ldw	r3,-104(fp)
 82373e0:	18801b15 	stw	r2,108(r3)
      }
      if (acked > (int)so->so_snd.sb_cc) 
 82373e4:	e0bfe817 	ldw	r2,-96(fp)
 82373e8:	10801217 	ldw	r2,72(r2)
 82373ec:	1007883a 	mov	r3,r2
 82373f0:	e0bff617 	ldw	r2,-40(fp)
 82373f4:	1880120e 	bge	r3,r2,8237440 <tcp_input+0x1a64>
      {
         tp->snd_wnd -= (u_short)so->so_snd.sb_cc;
 82373f8:	e0bfe617 	ldw	r2,-104(fp)
 82373fc:	10c01417 	ldw	r3,80(r2)
 8237400:	e0bfe817 	ldw	r2,-96(fp)
 8237404:	10801217 	ldw	r2,72(r2)
 8237408:	10bfffcc 	andi	r2,r2,65535
 823740c:	1887c83a 	sub	r3,r3,r2
 8237410:	e0bfe617 	ldw	r2,-104(fp)
 8237414:	10c01415 	stw	r3,80(r2)
         sbdrop(&so->so_snd, (int)so->so_snd.sb_cc);
 8237418:	e0bfe817 	ldw	r2,-96(fp)
 823741c:	10c01204 	addi	r3,r2,72
 8237420:	e0bfe817 	ldw	r2,-96(fp)
 8237424:	10801217 	ldw	r2,72(r2)
 8237428:	100b883a 	mov	r5,r2
 823742c:	1809883a 	mov	r4,r3
 8237430:	8234a080 	call	8234a08 <sbdrop>
         ourfinisacked = 1;
 8237434:	00800044 	movi	r2,1
 8237438:	e0bfea15 	stw	r2,-88(fp)
 823743c:	00000d06 	br	8237474 <tcp_input+0x1a98>
      } 
      else 
      {
         sbdrop(&so->so_snd, acked);
 8237440:	e0bfe817 	ldw	r2,-96(fp)
 8237444:	10801204 	addi	r2,r2,72
 8237448:	e17ff617 	ldw	r5,-40(fp)
 823744c:	1009883a 	mov	r4,r2
 8237450:	8234a080 	call	8234a08 <sbdrop>
         tp->snd_wnd -= (u_short)acked;
 8237454:	e0bfe617 	ldw	r2,-104(fp)
 8237458:	10c01417 	ldw	r3,80(r2)
 823745c:	e0bff617 	ldw	r2,-40(fp)
 8237460:	10bfffcc 	andi	r2,r2,65535
 8237464:	1887c83a 	sub	r3,r3,r2
 8237468:	e0bfe617 	ldw	r2,-104(fp)
 823746c:	10c01415 	stw	r3,80(r2)
         ourfinisacked = 0;
 8237470:	e03fea15 	stw	zero,-88(fp)
      }

      if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 8237474:	e0bfe817 	ldw	r2,-96(fp)
 8237478:	1080190b 	ldhu	r2,100(r2)
 823747c:	10bfffcc 	andi	r2,r2,65535
 8237480:	1080030c 	andi	r2,r2,12
 8237484:	10000526 	beq	r2,zero,823749c <tcp_input+0x1ac0>
         sowwakeup(so);
 8237488:	e0bfe817 	ldw	r2,-96(fp)
 823748c:	10801204 	addi	r2,r2,72
 8237490:	100b883a 	mov	r5,r2
 8237494:	e13fe817 	ldw	r4,-96(fp)
 8237498:	82342a00 	call	82342a0 <sbwakeup>

      tp->snd_una = ti->ti_ack;
 823749c:	e0bff217 	ldw	r2,-56(fp)
 82374a0:	10c00717 	ldw	r3,28(r2)
 82374a4:	e0bfe617 	ldw	r2,-104(fp)
 82374a8:	10c00e15 	stw	r3,56(r2)
      if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 82374ac:	e0bfe617 	ldw	r2,-104(fp)
 82374b0:	10c00f17 	ldw	r3,60(r2)
 82374b4:	e0bfe617 	ldw	r2,-104(fp)
 82374b8:	10800e17 	ldw	r2,56(r2)
 82374bc:	1885c83a 	sub	r2,r3,r2
 82374c0:	1000040e 	bge	r2,zero,82374d4 <tcp_input+0x1af8>
         tp->snd_nxt = tp->snd_una;
 82374c4:	e0bfe617 	ldw	r2,-104(fp)
 82374c8:	10c00e17 	ldw	r3,56(r2)
 82374cc:	e0bfe617 	ldw	r2,-104(fp)
 82374d0:	10c00f15 	stw	r3,60(r2)


      switch (tp->t_state) 
 82374d4:	e0bfe617 	ldw	r2,-104(fp)
 82374d8:	10800217 	ldw	r2,8(r2)
 82374dc:	10c001e0 	cmpeqi	r3,r2,7
 82374e0:	18001a1e 	bne	r3,zero,823754c <tcp_input+0x1b70>
 82374e4:	10c00208 	cmpgei	r3,r2,8
 82374e8:	1800031e 	bne	r3,zero,82374f8 <tcp_input+0x1b1c>
 82374ec:	108001a0 	cmpeqi	r2,r2,6
 82374f0:	1000061e 	bne	r2,zero,823750c <tcp_input+0x1b30>
 82374f4:	00003606 	br	82375d0 <tcp_input+0x1bf4>
 82374f8:	10c00220 	cmpeqi	r3,r2,8
 82374fc:	1800221e 	bne	r3,zero,8237588 <tcp_input+0x1bac>
 8237500:	108002a0 	cmpeqi	r2,r2,10
 8237504:	1000271e 	bne	r2,zero,82375a4 <tcp_input+0x1bc8>
 8237508:	00003106 	br	82375d0 <tcp_input+0x1bf4>
       * In FIN_WAIT_1 STATE in addition to the processing
       * for the ESTABLISHED state if our FIN is now acknowledged
       * then enter FIN_WAIT_2.
       */
      case TCPS_FIN_WAIT_1:
         if (ourfinisacked) 
 823750c:	e0bfea17 	ldw	r2,-88(fp)
 8237510:	10002a26 	beq	r2,zero,82375bc <tcp_input+0x1be0>
             * data, then closing user can proceed.
             * Starting the timer is contrary to the
             * specification, but if we don't get a FIN
             * we'll hang forever.
             */
            if (so->so_state & SS_CANTRCVMORE) 
 8237514:	e0bfe817 	ldw	r2,-96(fp)
 8237518:	1080088b 	ldhu	r2,34(r2)
 823751c:	10bfffcc 	andi	r2,r2,65535
 8237520:	1080080c 	andi	r2,r2,32
 8237524:	10000526 	beq	r2,zero,823753c <tcp_input+0x1b60>
            {
               soisdisconnected(so);
 8237528:	e13fe817 	ldw	r4,-96(fp)
 823752c:	8233cd00 	call	8233cd0 <soisdisconnected>
               tp->t_timer[TCPT_2MSL] = tcp_maxidle;
 8237530:	d0e0b417 	ldw	r3,-32048(gp)
 8237534:	e0bfe617 	ldw	r2,-104(fp)
 8237538:	10c00615 	stw	r3,24(r2)
            }
            tp->t_state = TCPS_FIN_WAIT_2;
 823753c:	e0bfe617 	ldw	r2,-104(fp)
 8237540:	00c00244 	movi	r3,9
 8237544:	10c00215 	stw	r3,8(r2)
         }
         break;
 8237548:	00001c06 	br	82375bc <tcp_input+0x1be0>
       * the ESTABLISHED state if the ACK acknowledges our FIN
       * then enter the TIME-WAIT state, otherwise ignore
       * the segment.
       */
      case TCPS_CLOSING:
         if (ourfinisacked) 
 823754c:	e0bfea17 	ldw	r2,-88(fp)
 8237550:	10001c26 	beq	r2,zero,82375c4 <tcp_input+0x1be8>
         {
            tp->t_state = TCPS_TIME_WAIT;
 8237554:	e0bfe617 	ldw	r2,-104(fp)
 8237558:	00c00284 	movi	r3,10
 823755c:	10c00215 	stw	r3,8(r2)
            tcp_canceltimers(tp);
 8237560:	e13fe617 	ldw	r4,-104(fp)
 8237564:	823a0d40 	call	823a0d4 <tcp_canceltimers>
            tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 8237568:	d0a03b17 	ldw	r2,-32532(gp)
 823756c:	1085883a 	add	r2,r2,r2
 8237570:	1007883a 	mov	r3,r2
 8237574:	e0bfe617 	ldw	r2,-104(fp)
 8237578:	10c00615 	stw	r3,24(r2)
            soisdisconnected(so);
 823757c:	e13fe817 	ldw	r4,-96(fp)
 8237580:	8233cd00 	call	8233cd0 <soisdisconnected>
         }
         break;
 8237584:	00000f06 	br	82375c4 <tcp_input+0x1be8>
       * and/or to be acked, as well as for the ack of our FIN.
       * If our FIN is now acknowledged, delete the TCB,
       * enter the closed state and return.
       */
      case TCPS_LAST_ACK:
         if (ourfinisacked) 
 8237588:	e0bfea17 	ldw	r2,-88(fp)
 823758c:	10000f26 	beq	r2,zero,82375cc <tcp_input+0x1bf0>
         {
            SETTP(tp, tcp_close(tp));
 8237590:	e13fe617 	ldw	r4,-104(fp)
 8237594:	8239c3c0 	call	8239c3c <tcp_close>
            GOTO_DROP;
 8237598:	00816644 	movi	r2,1433
 823759c:	d0a0b215 	stw	r2,-32056(gp)
 82375a0:	0001c006 	br	8237ca4 <tcp_input+0x22c8>
       * In TIME_WAIT state the only thing that should arrive
       * is a retransmission of the remote FIN.  Acknowledge
       * it and restart the finack timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 82375a4:	d0a03b17 	ldw	r2,-32532(gp)
 82375a8:	1085883a 	add	r2,r2,r2
 82375ac:	1007883a 	mov	r3,r2
 82375b0:	e0bfe617 	ldw	r2,-104(fp)
 82375b4:	10c00615 	stw	r3,24(r2)
         goto dropafterack;
 82375b8:	00016806 	br	8237b5c <tcp_input+0x2180>
               soisdisconnected(so);
               tp->t_timer[TCPT_2MSL] = tcp_maxidle;
            }
            tp->t_state = TCPS_FIN_WAIT_2;
         }
         break;
 82375bc:	0001883a 	nop
 82375c0:	00000306 	br	82375d0 <tcp_input+0x1bf4>
            tp->t_state = TCPS_TIME_WAIT;
            tcp_canceltimers(tp);
            tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
            soisdisconnected(so);
         }
         break;
 82375c4:	0001883a 	nop
 82375c8:	00000106 	br	82375d0 <tcp_input+0x1bf4>
         if (ourfinisacked) 
         {
            SETTP(tp, tcp_close(tp));
            GOTO_DROP;
         }
         break;
 82375cc:	0001883a 	nop
step6:
   /*
    * Update window information.
    * Don't look at window if no ACK: TAC's send garbage on first SYN.
    */
   if ((tiflags & TH_ACK) &&
 82375d0:	e0bfe717 	ldw	r2,-100(fp)
 82375d4:	1080040c 	andi	r2,r2,16
 82375d8:	10004426 	beq	r2,zero,82376ec <tcp_input+0x1d10>
       /*
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
 82375dc:	e0bfe617 	ldw	r2,-104(fp)
 82375e0:	10c01117 	ldw	r3,68(r2)
 82375e4:	e0bff217 	ldw	r2,-56(fp)
 82375e8:	10800617 	ldw	r2,24(r2)
 82375ec:	1885c83a 	sub	r2,r3,r2
step6:
   /*
    * Update window information.
    * Don't look at window if no ACK: TAC's send garbage on first SYN.
    */
   if ((tiflags & TH_ACK) &&
 82375f0:	10001416 	blt	r2,zero,8237644 <tcp_input+0x1c68>
       /*
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
 82375f4:	e0bfe617 	ldw	r2,-104(fp)
 82375f8:	10c01117 	ldw	r3,68(r2)
 82375fc:	e0bff217 	ldw	r2,-56(fp)
 8237600:	10800617 	ldw	r2,24(r2)
 8237604:	1880391e 	bne	r3,r2,82376ec <tcp_input+0x1d10>
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
 8237608:	e0bfe617 	ldw	r2,-104(fp)
 823760c:	10c01217 	ldw	r3,72(r2)
 8237610:	e0bff217 	ldw	r2,-56(fp)
 8237614:	10800717 	ldw	r2,28(r2)
 8237618:	1885c83a 	sub	r2,r3,r2
       /*
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
 823761c:	10000916 	blt	r2,zero,8237644 <tcp_input+0x1c68>
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
 8237620:	e0bfe617 	ldw	r2,-104(fp)
 8237624:	10c01217 	ldw	r3,72(r2)
 8237628:	e0bff217 	ldw	r2,-56(fp)
 823762c:	10800717 	ldw	r2,28(r2)
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
 8237630:	18802e1e 	bne	r3,r2,82376ec <tcp_input+0x1d10>
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
 8237634:	e0bfe617 	ldw	r2,-104(fp)
 8237638:	10c01417 	ldw	r3,80(r2)
 823763c:	e0bff517 	ldw	r2,-44(fp)
 8237640:	18802a2e 	bgeu	r3,r2,82376ec <tcp_input+0x1d10>
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
 8237644:	e0bff217 	ldw	r2,-56(fp)
 8237648:	1080028b 	ldhu	r2,10(r2)
 823764c:	10bfffcc 	andi	r2,r2,65535
 8237650:	1000101e 	bne	r2,zero,8237694 <tcp_input+0x1cb8>
          (tp->snd_wl2 == ti->ti_ack) &&
 8237654:	e0bfe617 	ldw	r2,-104(fp)
 8237658:	10c01217 	ldw	r3,72(r2)
 823765c:	e0bff217 	ldw	r2,-56(fp)
 8237660:	10800717 	ldw	r2,28(r2)
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
 8237664:	18800b1e 	bne	r3,r2,8237694 <tcp_input+0x1cb8>
          (tp->snd_wl2 == ti->ti_ack) &&
          (rx_win > tp->snd_wnd))
 8237668:	e0bfe617 	ldw	r2,-104(fp)
 823766c:	10c01417 	ldw	r3,80(r2)
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
          (tp->snd_wl2 == ti->ti_ack) &&
 8237670:	e0bff517 	ldw	r2,-44(fp)
 8237674:	1880072e 	bgeu	r3,r2,8237694 <tcp_input+0x1cb8>
          (rx_win > tp->snd_wnd))
      {
         tcpstat.tcps_rcvwinupd++;
 8237678:	008209b4 	movhi	r2,2086
 823767c:	10b9ad04 	addi	r2,r2,-6476
 8237680:	10802d17 	ldw	r2,180(r2)
 8237684:	10c00044 	addi	r3,r2,1
 8237688:	008209b4 	movhi	r2,2086
 823768c:	10b9ad04 	addi	r2,r2,-6476
 8237690:	10c02d15 	stw	r3,180(r2)
      }
      tp->snd_wnd = rx_win;
 8237694:	e0bfe617 	ldw	r2,-104(fp)
 8237698:	e0fff517 	ldw	r3,-44(fp)
 823769c:	10c01415 	stw	r3,80(r2)
      tp->snd_wl1 = ti->ti_seq;
 82376a0:	e0bff217 	ldw	r2,-56(fp)
 82376a4:	10c00617 	ldw	r3,24(r2)
 82376a8:	e0bfe617 	ldw	r2,-104(fp)
 82376ac:	10c01115 	stw	r3,68(r2)
      tp->snd_wl2 = ti->ti_ack;
 82376b0:	e0bff217 	ldw	r2,-56(fp)
 82376b4:	10c00717 	ldw	r3,28(r2)
 82376b8:	e0bfe617 	ldw	r2,-104(fp)
 82376bc:	10c01215 	stw	r3,72(r2)
      if (tp->snd_wnd > tp->max_sndwnd)
 82376c0:	e0bfe617 	ldw	r2,-104(fp)
 82376c4:	10801417 	ldw	r2,80(r2)
 82376c8:	e0ffe617 	ldw	r3,-104(fp)
 82376cc:	18c02317 	ldw	r3,140(r3)
 82376d0:	1880042e 	bgeu	r3,r2,82376e4 <tcp_input+0x1d08>
         tp->max_sndwnd = tp->snd_wnd;
 82376d4:	e0bfe617 	ldw	r2,-104(fp)
 82376d8:	10c01417 	ldw	r3,80(r2)
 82376dc:	e0bfe617 	ldw	r2,-104(fp)
 82376e0:	10c02315 	stw	r3,140(r2)
      needoutput = 1;
 82376e4:	00800044 	movi	r2,1
 82376e8:	e0bfeb15 	stw	r2,-84(fp)
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 82376ec:	e0bfe717 	ldw	r2,-100(fp)
 82376f0:	1080080c 	andi	r2,r2,32
 82376f4:	10005626 	beq	r2,zero,8237850 <tcp_input+0x1e74>
 82376f8:	e0bff217 	ldw	r2,-56(fp)
 82376fc:	1080098b 	ldhu	r2,38(r2)
 8237700:	10bfffcc 	andi	r2,r2,65535
 8237704:	10005226 	beq	r2,zero,8237850 <tcp_input+0x1e74>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 8237708:	e0bfe617 	ldw	r2,-104(fp)
 823770c:	10800217 	ldw	r2,8(r2)
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 8237710:	10800288 	cmpgei	r2,r2,10
 8237714:	10004e1e 	bne	r2,zero,8237850 <tcp_input+0x1e74>
       * This is a kludge, but if we receive and accept
       * random urgent pointers, we'll crash in
       * soreceive.  It's hard to imagine someone
       * actually wanting to send this much urgent data.
       */
      if (ti->ti_urp + so->so_rcv.sb_cc > SB_MAX) 
 8237718:	e0bff217 	ldw	r2,-56(fp)
 823771c:	1080098b 	ldhu	r2,38(r2)
 8237720:	10ffffcc 	andi	r3,r2,65535
 8237724:	e0bfe817 	ldw	r2,-96(fp)
 8237728:	10800a17 	ldw	r2,40(r2)
 823772c:	1885883a 	add	r2,r3,r2
 8237730:	10900070 	cmpltui	r2,r2,16385
 8237734:	1000071e 	bne	r2,zero,8237754 <tcp_input+0x1d78>
      {
         ti->ti_urp = 0;         /* XXX */
 8237738:	e0bff217 	ldw	r2,-56(fp)
 823773c:	1000098d 	sth	zero,38(r2)
         tiflags &= ~TH_URG;     /* XXX */
 8237740:	e0ffe717 	ldw	r3,-100(fp)
 8237744:	00bff7c4 	movi	r2,-33
 8237748:	1884703a 	and	r2,r3,r2
 823774c:	e0bfe715 	stw	r2,-100(fp)
         goto dodata;         /* XXX */
 8237750:	00004b06 	br	8237880 <tcp_input+0x1ea4>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
 8237754:	e0bff217 	ldw	r2,-56(fp)
 8237758:	10c00617 	ldw	r3,24(r2)
 823775c:	e0bff217 	ldw	r2,-56(fp)
 8237760:	1080098b 	ldhu	r2,38(r2)
 8237764:	10bfffcc 	andi	r2,r2,65535
 8237768:	1887883a 	add	r3,r3,r2
 823776c:	e0bfe617 	ldw	r2,-104(fp)
 8237770:	10801717 	ldw	r2,92(r2)
 8237774:	1885c83a 	sub	r2,r3,r2
 8237778:	0080250e 	bge	zero,r2,8237810 <tcp_input+0x1e34>
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
 823777c:	e0bff217 	ldw	r2,-56(fp)
 8237780:	10c00617 	ldw	r3,24(r2)
 8237784:	e0bff217 	ldw	r2,-56(fp)
 8237788:	1080098b 	ldhu	r2,38(r2)
 823778c:	10bfffcc 	andi	r2,r2,65535
 8237790:	1887883a 	add	r3,r3,r2
 8237794:	e0bfe617 	ldw	r2,-104(fp)
 8237798:	10c01715 	stw	r3,92(r2)
         so->so_oobmark = so->so_rcv.sb_cc +
 823779c:	e0bfe817 	ldw	r2,-96(fp)
 82377a0:	10c00a17 	ldw	r3,40(r2)
         (tp->rcv_up - tp->rcv_nxt) - 1;
 82377a4:	e0bfe617 	ldw	r2,-104(fp)
 82377a8:	11001717 	ldw	r4,92(r2)
 82377ac:	e0bfe617 	ldw	r2,-104(fp)
 82377b0:	10801617 	ldw	r2,88(r2)
 82377b4:	2085c83a 	sub	r2,r4,r2
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
         so->so_oobmark = so->so_rcv.sb_cc +
 82377b8:	1885883a 	add	r2,r3,r2
         (tp->rcv_up - tp->rcv_nxt) - 1;
 82377bc:	10ffffc4 	addi	r3,r2,-1
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
         so->so_oobmark = so->so_rcv.sb_cc +
 82377c0:	e0bfe817 	ldw	r2,-96(fp)
 82377c4:	10c01a15 	stw	r3,104(r2)
         (tp->rcv_up - tp->rcv_nxt) - 1;
         if (so->so_oobmark == 0)
 82377c8:	e0bfe817 	ldw	r2,-96(fp)
 82377cc:	10801a17 	ldw	r2,104(r2)
 82377d0:	1000061e 	bne	r2,zero,82377ec <tcp_input+0x1e10>
            so->so_state |= SS_RCVATMARK;
 82377d4:	e0bfe817 	ldw	r2,-96(fp)
 82377d8:	1080088b 	ldhu	r2,34(r2)
 82377dc:	10801014 	ori	r2,r2,64
 82377e0:	1007883a 	mov	r3,r2
 82377e4:	e0bfe817 	ldw	r2,-96(fp)
 82377e8:	10c0088d 	sth	r3,34(r2)
         sohasoutofband(so);
 82377ec:	e13fe817 	ldw	r4,-96(fp)
 82377f0:	8233a780 	call	8233a78 <sohasoutofband>
         tp->t_oobflags &= ~(TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 82377f4:	e0bfe617 	ldw	r2,-104(fp)
 82377f8:	10c02403 	ldbu	r3,144(r2)
 82377fc:	00bfff04 	movi	r2,-4
 8237800:	1884703a 	and	r2,r3,r2
 8237804:	1007883a 	mov	r3,r2
 8237808:	e0bfe617 	ldw	r2,-104(fp)
 823780c:	10c02405 	stb	r3,144(r2)
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 8237810:	e0bff217 	ldw	r2,-56(fp)
 8237814:	1100098b 	ldhu	r4,38(r2)
 8237818:	e0bff217 	ldw	r2,-56(fp)
 823781c:	10c0028b 	ldhu	r3,10(r2)
 8237820:	20bfffcc 	andi	r2,r4,65535
 8237824:	18ffffcc 	andi	r3,r3,65535
 8237828:	18801436 	bltu	r3,r2,823787c <tcp_input+0x1ea0>
#ifdef SO_OOBINLINE
       && (so->so_options & SO_OOBINLINE) == 0
 823782c:	e0bfe817 	ldw	r2,-96(fp)
 8237830:	10800417 	ldw	r2,16(r2)
 8237834:	1080400c 	andi	r2,r2,256
 8237838:	1000101e 	bne	r2,zero,823787c <tcp_input+0x1ea0>
#endif
       )
      {
         tcp_pulloutofband(so, ti, m);
 823783c:	e1bffe17 	ldw	r6,-8(fp)
 8237840:	e17ff217 	ldw	r5,-56(fp)
 8237844:	e13fe817 	ldw	r4,-96(fp)
 8237848:	8237e940 	call	8237e94 <tcp_pulloutofband>
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 823784c:	00000b06 	br	823787c <tcp_input+0x1ea0>
      /*
       * If no out of band data is expected,
       * pull receive urgent pointer along
       * with the receive window.
       */
   if (SEQ_GT(tp->rcv_nxt, tp->rcv_up))
 8237850:	e0bfe617 	ldw	r2,-104(fp)
 8237854:	10c01617 	ldw	r3,88(r2)
 8237858:	e0bfe617 	ldw	r2,-104(fp)
 823785c:	10801717 	ldw	r2,92(r2)
 8237860:	1885c83a 	sub	r2,r3,r2
 8237864:	0080060e 	bge	zero,r2,8237880 <tcp_input+0x1ea4>
      tp->rcv_up = tp->rcv_nxt;
 8237868:	e0bfe617 	ldw	r2,-104(fp)
 823786c:	10c01617 	ldw	r3,88(r2)
 8237870:	e0bfe617 	ldw	r2,-104(fp)
 8237874:	10c01715 	stw	r3,92(r2)
 8237878:	00000106 	br	8237880 <tcp_input+0x1ea4>
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 823787c:	0001883a 	nop
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 8237880:	e0bff217 	ldw	r2,-56(fp)
 8237884:	1080028b 	ldhu	r2,10(r2)
 8237888:	10bfffcc 	andi	r2,r2,65535
 823788c:	1000031e 	bne	r2,zero,823789c <tcp_input+0x1ec0>
 8237890:	e0bfe717 	ldw	r2,-100(fp)
 8237894:	1080004c 	andi	r2,r2,1
 8237898:	10005e26 	beq	r2,zero,8237a14 <tcp_input+0x2038>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 823789c:	e0bfe617 	ldw	r2,-104(fp)
 82378a0:	10800217 	ldw	r2,8(r2)
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 82378a4:	10800288 	cmpgei	r2,r2,10
 82378a8:	10005a1e 	bne	r2,zero,8237a14 <tcp_input+0x2038>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 82378ac:	e0bff217 	ldw	r2,-56(fp)
 82378b0:	10c00617 	ldw	r3,24(r2)
 82378b4:	e0bfe617 	ldw	r2,-104(fp)
 82378b8:	10801617 	ldw	r2,88(r2)
 82378bc:	1880371e 	bne	r3,r2,823799c <tcp_input+0x1fc0>
         (tp->seg_next == (struct tcpiphdr *)(tp) ) &&
 82378c0:	e0bfe617 	ldw	r2,-104(fp)
 82378c4:	10c00017 	ldw	r3,0(r2)
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 82378c8:	e0bfe617 	ldw	r2,-104(fp)
 82378cc:	1880331e 	bne	r3,r2,823799c <tcp_input+0x1fc0>
         (tp->seg_next == (struct tcpiphdr *)(tp) ) &&
         (tp->t_state == TCPS_ESTABLISHED))
 82378d0:	e0bfe617 	ldw	r2,-104(fp)
 82378d4:	10800217 	ldw	r2,8(r2)
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
         (tp->seg_next == (struct tcpiphdr *)(tp) ) &&
 82378d8:	10800118 	cmpnei	r2,r2,4
 82378dc:	10002f1e 	bne	r2,zero,823799c <tcp_input+0x1fc0>
         else
         {
            tp->t_flags |= TF_ACKNOW;
         }
#else    /* not DO_DELAY_ACKS */
            tp->t_flags |= TF_ACKNOW;
 82378e0:	e0bfe617 	ldw	r2,-104(fp)
 82378e4:	10800b0b 	ldhu	r2,44(r2)
 82378e8:	10800054 	ori	r2,r2,1
 82378ec:	1007883a 	mov	r3,r2
 82378f0:	e0bfe617 	ldw	r2,-104(fp)
 82378f4:	10c00b0d 	sth	r3,44(r2)
#endif   /* DO_DELAY_ACKS */

         tp->rcv_nxt += ti->ti_len;
 82378f8:	e0bfe617 	ldw	r2,-104(fp)
 82378fc:	10c01617 	ldw	r3,88(r2)
 8237900:	e0bff217 	ldw	r2,-56(fp)
 8237904:	1080028b 	ldhu	r2,10(r2)
 8237908:	10bfffcc 	andi	r2,r2,65535
 823790c:	1887883a 	add	r3,r3,r2
 8237910:	e0bfe617 	ldw	r2,-104(fp)
 8237914:	10c01615 	stw	r3,88(r2)
         tiflags = ti->ti_flags & TH_FIN;
 8237918:	e0bff217 	ldw	r2,-56(fp)
 823791c:	10800843 	ldbu	r2,33(r2)
 8237920:	10803fcc 	andi	r2,r2,255
 8237924:	1080004c 	andi	r2,r2,1
 8237928:	e0bfe715 	stw	r2,-100(fp)
         tcpstat.tcps_rcvpack++;
 823792c:	008209b4 	movhi	r2,2086
 8237930:	10b9ad04 	addi	r2,r2,-6476
 8237934:	10801a17 	ldw	r2,104(r2)
 8237938:	10c00044 	addi	r3,r2,1
 823793c:	008209b4 	movhi	r2,2086
 8237940:	10b9ad04 	addi	r2,r2,-6476
 8237944:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 8237948:	008209b4 	movhi	r2,2086
 823794c:	10b9ad04 	addi	r2,r2,-6476
 8237950:	10c01b17 	ldw	r3,108(r2)
 8237954:	e0bff217 	ldw	r2,-56(fp)
 8237958:	1080028b 	ldhu	r2,10(r2)
 823795c:	10bfffcc 	andi	r2,r2,65535
 8237960:	1887883a 	add	r3,r3,r2
 8237964:	008209b4 	movhi	r2,2086
 8237968:	10b9ad04 	addi	r2,r2,-6476
 823796c:	10c01b15 	stw	r3,108(r2)
         sbappend(&so->so_rcv, (m));
 8237970:	e0bfe817 	ldw	r2,-96(fp)
 8237974:	10800a04 	addi	r2,r2,40
 8237978:	e17ffe17 	ldw	r5,-8(fp)
 823797c:	1009883a 	mov	r4,r2
 8237980:	82344500 	call	8234450 <sbappend>
         sorwakeup(so);
 8237984:	e0bfe817 	ldw	r2,-96(fp)
 8237988:	10800a04 	addi	r2,r2,40
 823798c:	100b883a 	mov	r5,r2
 8237990:	e13fe817 	ldw	r4,-96(fp)
 8237994:	82342a00 	call	82342a0 <sbwakeup>
 8237998:	00000b06 	br	82379c8 <tcp_input+0x1fec>
#endif /* TCP_SACK */
      }
      else     /* received out of sequence segment */
      {
         /* Drop it in the reassmbly queue */
         tiflags = tcp_reass(tp, ti, m);
 823799c:	e1bffe17 	ldw	r6,-8(fp)
 82379a0:	e17ff217 	ldw	r5,-56(fp)
 82379a4:	e13fe617 	ldw	r4,-104(fp)
 82379a8:	82355cc0 	call	82355cc <tcp_reass>
 82379ac:	e0bfe715 	stw	r2,-100(fp)
         tp->t_flags |= TF_ACKNOW;
 82379b0:	e0bfe617 	ldw	r2,-104(fp)
 82379b4:	10800b0b 	ldhu	r2,44(r2)
 82379b8:	10800054 	ori	r2,r2,1
 82379bc:	1007883a 	mov	r3,r2
 82379c0:	e0bfe617 	ldw	r2,-104(fp)
 82379c4:	10c00b0d 	sth	r3,44(r2)
      /*
       * Note the amount of data that peer has sent into
       * our window, in order to estimate the sender's
       * buffer size.
       */
      len = (int)(so->so_rcv.sb_hiwat - (tp->rcv_adv - tp->rcv_nxt));
 82379c8:	e0bfe817 	ldw	r2,-96(fp)
 82379cc:	10c00b17 	ldw	r3,44(r2)
 82379d0:	e0bfe617 	ldw	r2,-104(fp)
 82379d4:	11001617 	ldw	r4,88(r2)
 82379d8:	e0bfe617 	ldw	r2,-104(fp)
 82379dc:	10801917 	ldw	r2,100(r2)
 82379e0:	2085c83a 	sub	r2,r4,r2
 82379e4:	1885883a 	add	r2,r3,r2
 82379e8:	e0bffc15 	stw	r2,-16(fp)
      if (len > (int)tp->max_rcvd)
 82379ec:	e0bfe617 	ldw	r2,-104(fp)
 82379f0:	10802217 	ldw	r2,136(r2)
 82379f4:	1007883a 	mov	r3,r2
 82379f8:	e0bffc17 	ldw	r2,-16(fp)
 82379fc:	18800b0e 	bge	r3,r2,8237a2c <tcp_input+0x2050>
         tp->max_rcvd = (u_short)len;
 8237a00:	e0bffc17 	ldw	r2,-16(fp)
 8237a04:	10ffffcc 	andi	r3,r2,65535
 8237a08:	e0bfe617 	ldw	r2,-104(fp)
 8237a0c:	10c02215 	stw	r3,136(r2)
       * Note the amount of data that peer has sent into
       * our window, in order to estimate the sender's
       * buffer size.
       */
      len = (int)(so->so_rcv.sb_hiwat - (tp->rcv_adv - tp->rcv_nxt));
      if (len > (int)tp->max_rcvd)
 8237a10:	00000606 	br	8237a2c <tcp_input+0x2050>
      }
#endif   /* TCP_ZEROCOPY */
   } 
   else
   {
      m_freem(m);
 8237a14:	e13ffe17 	ldw	r4,-8(fp)
 8237a18:	822e6940 	call	822e694 <m_freem>
      tiflags &= ~TH_FIN;
 8237a1c:	e0ffe717 	ldw	r3,-100(fp)
 8237a20:	00bfff84 	movi	r2,-2
 8237a24:	1884703a 	and	r2,r3,r2
 8237a28:	e0bfe715 	stw	r2,-100(fp)

   /*
    * If FIN is received ACK the FIN and let the user know
    * that the connection is closing.
    */
   if (tiflags & TH_FIN) 
 8237a2c:	e0bfe717 	ldw	r2,-100(fp)
 8237a30:	1080004c 	andi	r2,r2,1
 8237a34:	10003f26 	beq	r2,zero,8237b34 <tcp_input+0x2158>
   {
      if (TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 8237a38:	e0bfe617 	ldw	r2,-104(fp)
 8237a3c:	10800217 	ldw	r2,8(r2)
 8237a40:	10800288 	cmpgei	r2,r2,10
 8237a44:	10000d1e 	bne	r2,zero,8237a7c <tcp_input+0x20a0>
      {
         socantrcvmore(so);
 8237a48:	e13fe817 	ldw	r4,-96(fp)
 8237a4c:	82341a00 	call	82341a0 <socantrcvmore>
         tp->t_flags |= TF_ACKNOW;
 8237a50:	e0bfe617 	ldw	r2,-104(fp)
 8237a54:	10800b0b 	ldhu	r2,44(r2)
 8237a58:	10800054 	ori	r2,r2,1
 8237a5c:	1007883a 	mov	r3,r2
 8237a60:	e0bfe617 	ldw	r2,-104(fp)
 8237a64:	10c00b0d 	sth	r3,44(r2)
         tp->rcv_nxt++;
 8237a68:	e0bfe617 	ldw	r2,-104(fp)
 8237a6c:	10801617 	ldw	r2,88(r2)
 8237a70:	10c00044 	addi	r3,r2,1
 8237a74:	e0bfe617 	ldw	r2,-104(fp)
 8237a78:	10c01615 	stw	r3,88(r2)
      }
      switch (tp->t_state) 
 8237a7c:	e0bfe617 	ldw	r2,-104(fp)
 8237a80:	10800217 	ldw	r2,8(r2)
 8237a84:	10bfff44 	addi	r2,r2,-3
 8237a88:	10c00228 	cmpgeui	r3,r2,8
 8237a8c:	1800291e 	bne	r3,zero,8237b34 <tcp_input+0x2158>
 8237a90:	100690ba 	slli	r3,r2,2
 8237a94:	008208f4 	movhi	r2,2083
 8237a98:	109eaa04 	addi	r2,r2,31400
 8237a9c:	1885883a 	add	r2,r3,r2
 8237aa0:	10800017 	ldw	r2,0(r2)
 8237aa4:	1000683a 	jmp	r2
 8237aa8:	08237ac8 	cmpgei	zero,at,-29205
 8237aac:	08237ac8 	cmpgei	zero,at,-29205
 8237ab0:	08237b34 	orhi	zero,at,36332
 8237ab4:	08237ad8 	cmpnei	zero,at,-29205
 8237ab8:	08237b34 	orhi	zero,at,36332
 8237abc:	08237b34 	orhi	zero,at,36332
 8237ac0:	08237ae8 	cmpgeui	zero,at,36331
 8237ac4:	08237b1c 	xori	zero,at,36332
       * In SYN_RECEIVED and ESTABLISHED STATES
       * enter the CLOSE_WAIT state.
       */
      case TCPS_SYN_RECEIVED:
      case TCPS_ESTABLISHED:
         tp->t_state = TCPS_CLOSE_WAIT;
 8237ac8:	e0bfe617 	ldw	r2,-104(fp)
 8237acc:	00c00144 	movi	r3,5
 8237ad0:	10c00215 	stw	r3,8(r2)
         break;
 8237ad4:	00001706 	br	8237b34 <tcp_input+0x2158>
       /*
       * If still in FIN_WAIT_1 STATE FIN has not been acked so
       * enter the CLOSING state.
       */
      case TCPS_FIN_WAIT_1:
         tp->t_state = TCPS_CLOSING;
 8237ad8:	e0bfe617 	ldw	r2,-104(fp)
 8237adc:	00c001c4 	movi	r3,7
 8237ae0:	10c00215 	stw	r3,8(r2)
         break;
 8237ae4:	00001306 	br	8237b34 <tcp_input+0x2158>
       * In FIN_WAIT_2 state enter the TIME_WAIT state,
       * starting the time-wait timer, turning off the other 
       * standard timers.
       */
      case TCPS_FIN_WAIT_2:
         tp->t_state = TCPS_TIME_WAIT;
 8237ae8:	e0bfe617 	ldw	r2,-104(fp)
 8237aec:	00c00284 	movi	r3,10
 8237af0:	10c00215 	stw	r3,8(r2)
         tcp_canceltimers(tp);
 8237af4:	e13fe617 	ldw	r4,-104(fp)
 8237af8:	823a0d40 	call	823a0d4 <tcp_canceltimers>
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 8237afc:	d0a03b17 	ldw	r2,-32532(gp)
 8237b00:	1085883a 	add	r2,r2,r2
 8237b04:	1007883a 	mov	r3,r2
 8237b08:	e0bfe617 	ldw	r2,-104(fp)
 8237b0c:	10c00615 	stw	r3,24(r2)
         soisdisconnected(so);
 8237b10:	e13fe817 	ldw	r4,-96(fp)
 8237b14:	8233cd00 	call	8233cd0 <soisdisconnected>
         break;
 8237b18:	00000606 	br	8237b34 <tcp_input+0x2158>

      /*
       * In TIME_WAIT state restart the 2 MSL time_wait timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 8237b1c:	d0a03b17 	ldw	r2,-32532(gp)
 8237b20:	1085883a 	add	r2,r2,r2
 8237b24:	1007883a 	mov	r3,r2
 8237b28:	e0bfe617 	ldw	r2,-104(fp)
 8237b2c:	10c00615 	stw	r3,24(r2)
         break;
 8237b30:	0001883a 	nop
    ostate, tp, &tcp_saveti);
#endif
   /*
    * Return any desired output.
    */
   if (needoutput || (tp->t_flags & TF_ACKNOW))
 8237b34:	e0bfeb17 	ldw	r2,-84(fp)
 8237b38:	1000051e 	bne	r2,zero,8237b50 <tcp_input+0x2174>
 8237b3c:	e0bfe617 	ldw	r2,-104(fp)
 8237b40:	10800b0b 	ldhu	r2,44(r2)
 8237b44:	10bfffcc 	andi	r2,r2,65535
 8237b48:	1080004c 	andi	r2,r2,1
 8237b4c:	10006526 	beq	r2,zero,8237ce4 <tcp_input+0x2308>
      (void) tcp_output(tp);
 8237b50:	e13fe617 	ldw	r4,-104(fp)
 8237b54:	823835c0 	call	823835c <tcp_output>
   return;
 8237b58:	00006206 	br	8237ce4 <tcp_input+0x2308>
dropafterack:
   /*
    * Generate an ACK dropping incoming segment if it occupies
    * sequence space, where the ACK reflects our state.
    */
   if (tiflags & TH_RST)
 8237b5c:	e0bfe717 	ldw	r2,-100(fp)
 8237b60:	1080010c 	andi	r2,r2,4
 8237b64:	10000326 	beq	r2,zero,8237b74 <tcp_input+0x2198>
      GOTO_DROP;
 8237b68:	0081a904 	movi	r2,1700
 8237b6c:	d0a0b215 	stw	r2,-32056(gp)
 8237b70:	00004c06 	br	8237ca4 <tcp_input+0x22c8>
   m_freem (m);
 8237b74:	e13ffe17 	ldw	r4,-8(fp)
 8237b78:	822e6940 	call	822e694 <m_freem>
   tp->t_flags |= TF_ACKNOW;
 8237b7c:	e0bfe617 	ldw	r2,-104(fp)
 8237b80:	10800b0b 	ldhu	r2,44(r2)
 8237b84:	10800054 	ori	r2,r2,1
 8237b88:	1007883a 	mov	r3,r2
 8237b8c:	e0bfe617 	ldw	r2,-104(fp)
 8237b90:	10c00b0d 	sth	r3,44(r2)
   (void) tcp_output (tp);
 8237b94:	e13fe617 	ldw	r4,-104(fp)
 8237b98:	823835c0 	call	823835c <tcp_output>
   return;
 8237b9c:	00005606 	br	8237cf8 <tcp_input+0x231c>

dropwithreset:
   TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 8237ba0:	008209b4 	movhi	r2,2086
 8237ba4:	10b97f04 	addi	r2,r2,-6660
 8237ba8:	10800d17 	ldw	r2,52(r2)
 8237bac:	10c00044 	addi	r3,r2,1
 8237bb0:	008209b4 	movhi	r2,2086
 8237bb4:	10b97f04 	addi	r2,r2,-6660
 8237bb8:	10c00d15 	stw	r3,52(r2)
   if (om) 
 8237bbc:	e0bfe517 	ldw	r2,-108(fp)
 8237bc0:	10000326 	beq	r2,zero,8237bd0 <tcp_input+0x21f4>
   {
      (void) m_free(om);
 8237bc4:	e13fe517 	ldw	r4,-108(fp)
 8237bc8:	822e58c0 	call	822e58c <m_free>
      om = 0;
 8237bcc:	e03fe515 	stw	zero,-108(fp)
   }

   /* Don't reset resets */
   if (tiflags & TH_RST)
 8237bd0:	e0bfe717 	ldw	r2,-100(fp)
 8237bd4:	1080010c 	andi	r2,r2,4
 8237bd8:	10000326 	beq	r2,zero,8237be8 <tcp_input+0x220c>
      GOTO_DROP;
 8237bdc:	0081ad04 	movi	r2,1716
 8237be0:	d0a0b215 	stw	r2,-32056(gp)
 8237be4:	00002f06 	br	8237ca4 <tcp_input+0x22c8>
    * Generate a RST, dropping incoming segment.
    * Make ACK acceptable to originator of segment.
    * Don't bother to respond if destination was broadcast.
    */
#ifdef IP_V4
   if (in_broadcast(ti->ti_dst.s_addr))
 8237be8:	e0bff217 	ldw	r2,-56(fp)
 8237bec:	10800417 	ldw	r2,16(r2)
 8237bf0:	1009883a 	mov	r4,r2
 8237bf4:	822f5e00 	call	822f5e0 <in_broadcast>
 8237bf8:	10000326 	beq	r2,zero,8237c08 <tcp_input+0x222c>
      GOTO_DROP;
 8237bfc:	0081af44 	movi	r2,1725
 8237c00:	d0a0b215 	stw	r2,-32056(gp)
 8237c04:	00002706 	br	8237ca4 <tcp_input+0x22c8>
      IP6CPY(&(m->pkt->ip6_hdr->ip_src), &ip6_src);
      IP6CPY(&(m->pkt->ip6_hdr->ip_dest), &ip6_dst);
   }
#endif   /* IP_V6 */

   if (tiflags & TH_ACK)
 8237c08:	e0bfe717 	ldw	r2,-100(fp)
 8237c0c:	1080040c 	andi	r2,r2,16
 8237c10:	10000c26 	beq	r2,zero,8237c44 <tcp_input+0x2268>
      tcp_respond (tp, ti, (tcp_seq)0, ti->ti_ack, TH_RST, m);
 8237c14:	e0bff217 	ldw	r2,-56(fp)
 8237c18:	10c00717 	ldw	r3,28(r2)
 8237c1c:	e0bffe17 	ldw	r2,-8(fp)
 8237c20:	d8800115 	stw	r2,4(sp)
 8237c24:	00800104 	movi	r2,4
 8237c28:	d8800015 	stw	r2,0(sp)
 8237c2c:	180f883a 	mov	r7,r3
 8237c30:	000d883a 	mov	r6,zero
 8237c34:	e17ff217 	ldw	r5,-56(fp)
 8237c38:	e13fe617 	ldw	r4,-104(fp)
 8237c3c:	82396840 	call	8239684 <tcp_respond>
 8237c40:	00001306 	br	8237c90 <tcp_input+0x22b4>
   else
   {
      if (tiflags & TH_SYN)
 8237c44:	e0bfe717 	ldw	r2,-100(fp)
 8237c48:	1080008c 	andi	r2,r2,2
 8237c4c:	10000526 	beq	r2,zero,8237c64 <tcp_input+0x2288>
         ti->ti_seq++;
 8237c50:	e0bff217 	ldw	r2,-56(fp)
 8237c54:	10800617 	ldw	r2,24(r2)
 8237c58:	10c00044 	addi	r3,r2,1
 8237c5c:	e0bff217 	ldw	r2,-56(fp)
 8237c60:	10c00615 	stw	r3,24(r2)
      tcp_respond(tp, ti, ti->ti_seq, (tcp_seq)0, TH_RST|TH_ACK, m);
 8237c64:	e0bff217 	ldw	r2,-56(fp)
 8237c68:	10c00617 	ldw	r3,24(r2)
 8237c6c:	e0bffe17 	ldw	r2,-8(fp)
 8237c70:	d8800115 	stw	r2,4(sp)
 8237c74:	00800504 	movi	r2,20
 8237c78:	d8800015 	stw	r2,0(sp)
 8237c7c:	000f883a 	mov	r7,zero
 8237c80:	180d883a 	mov	r6,r3
 8237c84:	e17ff217 	ldw	r5,-56(fp)
 8237c88:	e13fe617 	ldw	r4,-104(fp)
 8237c8c:	82396840 	call	8239684 <tcp_respond>
   }
   /* destroy temporarily created socket */
   if (dropsocket)
 8237c90:	e0bfec17 	ldw	r2,-80(fp)
 8237c94:	10001526 	beq	r2,zero,8237cec <tcp_input+0x2310>
      (void) soabort(so);
 8237c98:	e13fe817 	ldw	r4,-96(fp)
 8237c9c:	82321300 	call	8232130 <soabort>
   return;
 8237ca0:	00001206 	br	8237cec <tcp_input+0x2310>

drop:
   if (om)
 8237ca4:	e0bfe517 	ldw	r2,-108(fp)
 8237ca8:	10000226 	beq	r2,zero,8237cb4 <tcp_input+0x22d8>
      (void) m_free(om);
 8237cac:	e13fe517 	ldw	r4,-108(fp)
 8237cb0:	822e58c0 	call	822e58c <m_free>
#ifdef DO_TCPTRACE
   if (tp && (tp->t_inpcb->inp_socket->so_options & SO_DEBUG))
      tcp_trace("drop: state %d, tcpcb: %x, saveti: %x",
    ostate, tp, &tcp_saveti);
#endif
   m_freem(m);
 8237cb4:	e13ffe17 	ldw	r4,-8(fp)
 8237cb8:	822e6940 	call	822e694 <m_freem>
   /* destroy temporarily created socket */
   if (dropsocket)
 8237cbc:	e0bfec17 	ldw	r2,-80(fp)
 8237cc0:	10000c26 	beq	r2,zero,8237cf4 <tcp_input+0x2318>
      (void) soabort(so);
 8237cc4:	e13fe817 	ldw	r4,-96(fp)
 8237cc8:	82321300 	call	8232130 <soabort>
   return;
 8237ccc:	0001883a 	nop
 8237cd0:	00000806 	br	8237cf4 <tcp_input+0x2318>
            /* If there is more data in the send buffer, and some is
             * still unsent, then call tcp_output() to try to send it
             */
            if (so->so_snd.sb_cc > (tp->snd_nxt - tp->snd_una))
               (void) tcp_output(tp);
            return;
 8237cd4:	0001883a 	nop
 8237cd8:	00000706 	br	8237cf8 <tcp_input+0x231c>
            tp->t_flags |= TF_ACKNOW;
            tp->t_flags &= ~TF_DELACK;
            tcp_output(tp);   /* send the ack now... */
         }

         return;
 8237cdc:	0001883a 	nop
 8237ce0:	00000506 	br	8237cf8 <tcp_input+0x231c>
   /*
    * Return any desired output.
    */
   if (needoutput || (tp->t_flags & TF_ACKNOW))
      (void) tcp_output(tp);
   return;
 8237ce4:	0001883a 	nop
 8237ce8:	00000306 	br	8237cf8 <tcp_input+0x231c>
      tcp_respond(tp, ti, ti->ti_seq, (tcp_seq)0, TH_RST|TH_ACK, m);
   }
   /* destroy temporarily created socket */
   if (dropsocket)
      (void) soabort(so);
   return;
 8237cec:	0001883a 	nop
 8237cf0:	00000106 	br	8237cf8 <tcp_input+0x231c>
#endif
   m_freem(m);
   /* destroy temporarily created socket */
   if (dropsocket)
      (void) soabort(so);
   return;
 8237cf4:	0001883a 	nop
}
 8237cf8:	e037883a 	mov	sp,fp
 8237cfc:	dfc00117 	ldw	ra,4(sp)
 8237d00:	df000017 	ldw	fp,0(sp)
 8237d04:	dec00204 	addi	sp,sp,8
 8237d08:	f800283a 	ret

08237d0c <tcp_dooptions>:

void
tcp_dooptions(struct tcpcb * tp, 
   struct mbuf *  om,
   struct tcpiphdr * ti)
{
 8237d0c:	defff404 	addi	sp,sp,-48
 8237d10:	dfc00b15 	stw	ra,44(sp)
 8237d14:	df000a15 	stw	fp,40(sp)
 8237d18:	dc000915 	stw	r16,36(sp)
 8237d1c:	df000a04 	addi	fp,sp,40
 8237d20:	e13ffc15 	stw	r4,-16(fp)
 8237d24:	e17ffd15 	stw	r5,-12(fp)
 8237d28:	e1bffe15 	stw	r6,-8(fp)
   u_char * cp;   /* pointer into option buffer */
   int   opt;     /* current option code */
   int   optlen;  /* length of current option */
   int   cnt;     /* byte count left in header */
   struct socket * so = tp->t_inpcb->inp_socket;
 8237d2c:	e0bffc17 	ldw	r2,-16(fp)
 8237d30:	10800d17 	ldw	r2,52(r2)
 8237d34:	10800817 	ldw	r2,32(r2)
 8237d38:	e0bff915 	stw	r2,-28(fp)
#ifdef TCP_TIMESTAMP
   int   gotstamp = FALSE;    /* TRUE if we got a timestamp */
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
 8237d3c:	e0bffd17 	ldw	r2,-12(fp)
 8237d40:	10800317 	ldw	r2,12(r2)
 8237d44:	e0bff615 	stw	r2,-40(fp)
   cnt = om->m_len;
 8237d48:	e0bffd17 	ldw	r2,-12(fp)
 8237d4c:	10800217 	ldw	r2,8(r2)
 8237d50:	e0bff815 	stw	r2,-32(fp)
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 8237d54:	00004006 	br	8237e58 <tcp_dooptions+0x14c>
   {
      opt = cp[0];
 8237d58:	e0bff617 	ldw	r2,-40(fp)
 8237d5c:	10800003 	ldbu	r2,0(r2)
 8237d60:	10803fcc 	andi	r2,r2,255
 8237d64:	e0bffa15 	stw	r2,-24(fp)
      if (opt == TCPOPT_EOL)
 8237d68:	e0bffa17 	ldw	r2,-24(fp)
 8237d6c:	10003d26 	beq	r2,zero,8237e64 <tcp_dooptions+0x158>
         break;
      if (opt == TCPOPT_NOP)
 8237d70:	e0bffa17 	ldw	r2,-24(fp)
 8237d74:	10800058 	cmpnei	r2,r2,1
 8237d78:	1000031e 	bne	r2,zero,8237d88 <tcp_dooptions+0x7c>
         optlen = 1;
 8237d7c:	00800044 	movi	r2,1
 8237d80:	e0bff715 	stw	r2,-36(fp)
 8237d84:	00000706 	br	8237da4 <tcp_dooptions+0x98>
      else 
      {
         optlen = cp[1];
 8237d88:	e0bff617 	ldw	r2,-40(fp)
 8237d8c:	10800044 	addi	r2,r2,1
 8237d90:	10800003 	ldbu	r2,0(r2)
 8237d94:	10803fcc 	andi	r2,r2,255
 8237d98:	e0bff715 	stw	r2,-36(fp)
         if (optlen <= 0)
 8237d9c:	e0bff717 	ldw	r2,-36(fp)
 8237da0:	0080320e 	bge	zero,r2,8237e6c <tcp_dooptions+0x160>
            break;
      }

      switch (opt) 
 8237da4:	e0bffa17 	ldw	r2,-24(fp)
 8237da8:	108000a0 	cmpeqi	r2,r2,2
 8237dac:	1000011e 	bne	r2,zero,8237db4 <tcp_dooptions+0xa8>
         }
         break;
#endif   /* TCP_TIMESTAMP */

      default:
         break;
 8237db0:	00002106 	br	8237e38 <tcp_dooptions+0x12c>
      switch (opt) 
      {
      case TCPOPT_MAXSEG:
      {
         u_short mssval;
         if (optlen != 4)
 8237db4:	e0bff717 	ldw	r2,-36(fp)
 8237db8:	10800120 	cmpeqi	r2,r2,4
 8237dbc:	10001b26 	beq	r2,zero,8237e2c <tcp_dooptions+0x120>
            continue;
         if (!(ti->ti_flags & TH_SYN))    /* MSS only on SYN */
 8237dc0:	e0bffe17 	ldw	r2,-8(fp)
 8237dc4:	10800843 	ldbu	r2,33(r2)
 8237dc8:	10803fcc 	andi	r2,r2,255
 8237dcc:	1080008c 	andi	r2,r2,2
 8237dd0:	10001826 	beq	r2,zero,8237e34 <tcp_dooptions+0x128>
            continue;
         mssval = *(u_short *)(cp + 2);
 8237dd4:	e0bff617 	ldw	r2,-40(fp)
 8237dd8:	1080008b 	ldhu	r2,2(r2)
 8237ddc:	e0bffb0d 	sth	r2,-20(fp)
         mssval = ntohs(mssval);
 8237de0:	e0bffb0b 	ldhu	r2,-20(fp)
 8237de4:	1004d23a 	srli	r2,r2,8
 8237de8:	1007883a 	mov	r3,r2
 8237dec:	e0bffb0b 	ldhu	r2,-20(fp)
 8237df0:	1004923a 	slli	r2,r2,8
 8237df4:	1884b03a 	or	r2,r3,r2
 8237df8:	e0bffb0d 	sth	r2,-20(fp)
         tp->t_maxseg = (u_short)MIN(mssval, (u_short)tcp_mss(so));
 8237dfc:	e43ffb0b 	ldhu	r16,-20(fp)
 8237e00:	e13ff917 	ldw	r4,-28(fp)
 8237e04:	82382640 	call	8238264 <tcp_mss>
 8237e08:	10bfffcc 	andi	r2,r2,65535
 8237e0c:	1400030e 	bge	r2,r16,8237e1c <tcp_dooptions+0x110>
 8237e10:	e13ff917 	ldw	r4,-28(fp)
 8237e14:	82382640 	call	8238264 <tcp_mss>
 8237e18:	00000106 	br	8237e20 <tcp_dooptions+0x114>
 8237e1c:	e0bffb0b 	ldhu	r2,-20(fp)
 8237e20:	e0fffc17 	ldw	r3,-16(fp)
 8237e24:	18800a0d 	sth	r2,40(r3)
         break;
 8237e28:	00000306 	br	8237e38 <tcp_dooptions+0x12c>
      {
      case TCPOPT_MAXSEG:
      {
         u_short mssval;
         if (optlen != 4)
            continue;
 8237e2c:	0001883a 	nop
 8237e30:	00000106 	br	8237e38 <tcp_dooptions+0x12c>
         if (!(ti->ti_flags & TH_SYN))    /* MSS only on SYN */
            continue;
 8237e34:	0001883a 	nop
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
   cnt = om->m_len;
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 8237e38:	e0fff817 	ldw	r3,-32(fp)
 8237e3c:	e0bff717 	ldw	r2,-36(fp)
 8237e40:	1885c83a 	sub	r2,r3,r2
 8237e44:	e0bff815 	stw	r2,-32(fp)
 8237e48:	e0bff717 	ldw	r2,-36(fp)
 8237e4c:	e0fff617 	ldw	r3,-40(fp)
 8237e50:	1885883a 	add	r2,r3,r2
 8237e54:	e0bff615 	stw	r2,-40(fp)
 8237e58:	e0bff817 	ldw	r2,-32(fp)
 8237e5c:	00bfbe16 	blt	zero,r2,8237d58 <tcp_dooptions+0x4c>
 8237e60:	00000306 	br	8237e70 <tcp_dooptions+0x164>
   {
      opt = cp[0];
      if (opt == TCPOPT_EOL)
         break;
 8237e64:	0001883a 	nop
 8237e68:	00000106 	br	8237e70 <tcp_dooptions+0x164>
         optlen = 1;
      else 
      {
         optlen = cp[1];
         if (optlen <= 0)
            break;
 8237e6c:	0001883a 	nop

      default:
         break;
      }
   }
   (void) m_free(om);
 8237e70:	e13ffd17 	ldw	r4,-12(fp)
 8237e74:	822e58c0 	call	822e58c <m_free>
      if(!gotstamp)
         tp->t_flags &= ~TF_TIMESTAMP;
   }
#endif /* TCP_TIMESTAMP */

   return;
 8237e78:	0001883a 	nop
}
 8237e7c:	e6ffff04 	addi	sp,fp,-4
 8237e80:	dfc00217 	ldw	ra,8(sp)
 8237e84:	df000117 	ldw	fp,4(sp)
 8237e88:	dc000017 	ldw	r16,0(sp)
 8237e8c:	dec00304 	addi	sp,sp,12
 8237e90:	f800283a 	ret

08237e94 <tcp_pulloutofband>:

void
tcp_pulloutofband(struct socket * so, 
   struct tcpiphdr * ti,
   struct mbuf *  m)
{
 8237e94:	defff804 	addi	sp,sp,-32
 8237e98:	dfc00715 	stw	ra,28(sp)
 8237e9c:	df000615 	stw	fp,24(sp)
 8237ea0:	df000604 	addi	fp,sp,24
 8237ea4:	e13ffd15 	stw	r4,-12(fp)
 8237ea8:	e17ffe15 	stw	r5,-8(fp)
 8237eac:	e1bfff15 	stw	r6,-4(fp)
   int   cnt   =  ti->ti_urp  -  1;
 8237eb0:	e0bffe17 	ldw	r2,-8(fp)
 8237eb4:	1080098b 	ldhu	r2,38(r2)
 8237eb8:	10bfffcc 	andi	r2,r2,65535
 8237ebc:	10bfffc4 	addi	r2,r2,-1
 8237ec0:	e0bffa15 	stw	r2,-24(fp)

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 8237ec4:	00003206 	br	8237f90 <tcp_pulloutofband+0xfc>
   {
      if (m->m_len > (unsigned)cnt) 
 8237ec8:	e0bfff17 	ldw	r2,-4(fp)
 8237ecc:	10800217 	ldw	r2,8(r2)
 8237ed0:	e0fffa17 	ldw	r3,-24(fp)
 8237ed4:	1880242e 	bgeu	r3,r2,8237f68 <tcp_pulloutofband+0xd4>
      {
         char *   cp =  mtod(m,  char *) +  cnt;
 8237ed8:	e0bfff17 	ldw	r2,-4(fp)
 8237edc:	10c00317 	ldw	r3,12(r2)
 8237ee0:	e0bffa17 	ldw	r2,-24(fp)
 8237ee4:	1885883a 	add	r2,r3,r2
 8237ee8:	e0bffb15 	stw	r2,-20(fp)
         struct tcpcb * tp =  sototcpcb(so);
 8237eec:	e0bffd17 	ldw	r2,-12(fp)
 8237ef0:	10800117 	ldw	r2,4(r2)
 8237ef4:	10800917 	ldw	r2,36(r2)
 8237ef8:	e0bffc15 	stw	r2,-16(fp)

         tp->t_iobc = *cp;
 8237efc:	e0bffb17 	ldw	r2,-20(fp)
 8237f00:	10c00003 	ldbu	r3,0(r2)
 8237f04:	e0bffc17 	ldw	r2,-16(fp)
 8237f08:	10c02445 	stb	r3,145(r2)
         tp->t_oobflags |= TCPOOB_HAVEDATA;
 8237f0c:	e0bffc17 	ldw	r2,-16(fp)
 8237f10:	10802403 	ldbu	r2,144(r2)
 8237f14:	10800054 	ori	r2,r2,1
 8237f18:	1007883a 	mov	r3,r2
 8237f1c:	e0bffc17 	ldw	r2,-16(fp)
 8237f20:	10c02405 	stb	r3,144(r2)
         MEMCPY(cp, cp+1, (unsigned)(m->m_len - cnt - 1));
 8237f24:	e0bffb17 	ldw	r2,-20(fp)
 8237f28:	11000044 	addi	r4,r2,1
 8237f2c:	e0bfff17 	ldw	r2,-4(fp)
 8237f30:	10c00217 	ldw	r3,8(r2)
 8237f34:	e0bffa17 	ldw	r2,-24(fp)
 8237f38:	1885c83a 	sub	r2,r3,r2
 8237f3c:	10bfffc4 	addi	r2,r2,-1
 8237f40:	100d883a 	mov	r6,r2
 8237f44:	200b883a 	mov	r5,r4
 8237f48:	e13ffb17 	ldw	r4,-20(fp)
 8237f4c:	8202f6c0 	call	8202f6c <memcpy>
         m->m_len--;
 8237f50:	e0bfff17 	ldw	r2,-4(fp)
 8237f54:	10800217 	ldw	r2,8(r2)
 8237f58:	10ffffc4 	addi	r3,r2,-1
 8237f5c:	e0bfff17 	ldw	r2,-4(fp)
 8237f60:	10c00215 	stw	r3,8(r2)
         return;
 8237f64:	00001106 	br	8237fac <tcp_pulloutofband+0x118>
      }
      cnt -= m->m_len;
 8237f68:	e0fffa17 	ldw	r3,-24(fp)
 8237f6c:	e0bfff17 	ldw	r2,-4(fp)
 8237f70:	10800217 	ldw	r2,8(r2)
 8237f74:	1885c83a 	sub	r2,r3,r2
 8237f78:	e0bffa15 	stw	r2,-24(fp)
      m = m->m_next;
 8237f7c:	e0bfff17 	ldw	r2,-4(fp)
 8237f80:	10800617 	ldw	r2,24(r2)
 8237f84:	e0bfff15 	stw	r2,-4(fp)
      if (m == 0)
 8237f88:	e0bfff17 	ldw	r2,-4(fp)
 8237f8c:	10000326 	beq	r2,zero,8237f9c <tcp_pulloutofband+0x108>
   struct mbuf *  m)
{
   int   cnt   =  ti->ti_urp  -  1;

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 8237f90:	e0bffa17 	ldw	r2,-24(fp)
 8237f94:	103fcc0e 	bge	r2,zero,8237ec8 <tcp_pulloutofband+0x34>
 8237f98:	00000106 	br	8237fa0 <tcp_pulloutofband+0x10c>
         return;
      }
      cnt -= m->m_len;
      m = m->m_next;
      if (m == 0)
         break;
 8237f9c:	0001883a 	nop
   }
   panic("tcp_pulloutofband");
 8237fa0:	01020974 	movhi	r4,2085
 8237fa4:	2103bf04 	addi	r4,r4,3836
 8237fa8:	8228ca40 	call	8228ca4 <panic>
}
 8237fac:	e037883a 	mov	sp,fp
 8237fb0:	dfc00117 	ldw	ra,4(sp)
 8237fb4:	df000017 	ldw	fp,0(sp)
 8237fb8:	dec00204 	addi	sp,sp,8
 8237fbc:	f800283a 	ret

08237fc0 <tcp_xmit_timer>:
 * RETURNS: 
 */

void
tcp_xmit_timer(struct tcpcb * tp)
{
 8237fc0:	defffb04 	addi	sp,sp,-20
 8237fc4:	dfc00415 	stw	ra,16(sp)
 8237fc8:	df000315 	stw	fp,12(sp)
 8237fcc:	df000304 	addi	fp,sp,12
 8237fd0:	e13fff15 	stw	r4,-4(fp)
   int delta;
   int rtt;

#ifdef NPDEBUG
   if(tp->t_rttick == 0){ dtrap(); return; }
 8237fd4:	e0bfff17 	ldw	r2,-4(fp)
 8237fd8:	10801e17 	ldw	r2,120(r2)
 8237fdc:	1000021e 	bne	r2,zero,8237fe8 <tcp_xmit_timer+0x28>
 8237fe0:	822d5f00 	call	822d5f0 <dtrap>
 8237fe4:	00008806 	br	8238208 <tcp_xmit_timer+0x248>
#endif

   tcpstat.tcps_rttupdated++;
 8237fe8:	008209b4 	movhi	r2,2086
 8237fec:	10b9ad04 	addi	r2,r2,-6476
 8237ff0:	10800717 	ldw	r2,28(r2)
 8237ff4:	10c00044 	addi	r3,r2,1
 8237ff8:	008209b4 	movhi	r2,2086
 8237ffc:	10b9ad04 	addi	r2,r2,-6476
 8238000:	10c00715 	stw	r3,28(r2)

   /* get  this rtt. Convert from cticks to TCP slow ticks */
   rtt = (int)((cticks - tp->t_rttick) / (TPS/2));
 8238004:	d0e0a817 	ldw	r3,-32096(gp)
 8238008:	e0bfff17 	ldw	r2,-4(fp)
 823800c:	10801e17 	ldw	r2,120(r2)
 8238010:	1887c83a 	sub	r3,r3,r2
 8238014:	00947b34 	movhi	r2,20972
 8238018:	10a147c4 	addi	r2,r2,-31457
 823801c:	1888383a 	mulxuu	r4,r3,r2
 8238020:	1885383a 	mul	r2,r3,r2
 8238024:	100b883a 	mov	r5,r2
 8238028:	200d883a 	mov	r6,r4
 823802c:	3004d13a 	srli	r2,r6,4
 8238030:	e0bffe15 	stw	r2,-8(fp)
   if(tp->t_srtt != 0)
 8238034:	e0bfff17 	ldw	r2,-4(fp)
 8238038:	10802017 	ldw	r2,128(r2)
 823803c:	10004626 	beq	r2,zero,8238158 <tcp_xmit_timer+0x198>
   {
      if(rtt == 0)      /* fast path for small round trip */
 8238040:	e0bffe17 	ldw	r2,-8(fp)
 8238044:	1000131e 	bne	r2,zero,8238094 <tcp_xmit_timer+0xd4>
      {
         /* if either the rtt or varience is over 1, reduce it. */
         if(tp->t_srtt > 1)
 8238048:	e0bfff17 	ldw	r2,-4(fp)
 823804c:	10802017 	ldw	r2,128(r2)
 8238050:	10800090 	cmplti	r2,r2,2
 8238054:	1000051e 	bne	r2,zero,823806c <tcp_xmit_timer+0xac>
            tp->t_srtt--;
 8238058:	e0bfff17 	ldw	r2,-4(fp)
 823805c:	10802017 	ldw	r2,128(r2)
 8238060:	10ffffc4 	addi	r3,r2,-1
 8238064:	e0bfff17 	ldw	r2,-4(fp)
 8238068:	10c02015 	stw	r3,128(r2)
         if(tp->t_rttvar > 1)
 823806c:	e0bfff17 	ldw	r2,-4(fp)
 8238070:	10802117 	ldw	r2,132(r2)
 8238074:	10800090 	cmplti	r2,r2,2
 8238078:	1000441e 	bne	r2,zero,823818c <tcp_xmit_timer+0x1cc>
            tp->t_rttvar--;
 823807c:	e0bfff17 	ldw	r2,-4(fp)
 8238080:	10802117 	ldw	r2,132(r2)
 8238084:	10ffffc4 	addi	r3,r2,-1
 8238088:	e0bfff17 	ldw	r2,-4(fp)
 823808c:	10c02115 	stw	r3,132(r2)
 8238090:	00003e06 	br	823818c <tcp_xmit_timer+0x1cc>
       * The following magic is equivalent
       * to the smoothing algorithm in rfc793
       * with an alpha of .875
       * (srtt = rtt/8 + srtt*7/8 in fixed point).
       */
      delta = ((rtt - 1) << 2) - (int)(tp->t_srtt >> 3);
 8238094:	e0bffe17 	ldw	r2,-8(fp)
 8238098:	10bfffc4 	addi	r2,r2,-1
 823809c:	1085883a 	add	r2,r2,r2
 82380a0:	1085883a 	add	r2,r2,r2
 82380a4:	1007883a 	mov	r3,r2
 82380a8:	e0bfff17 	ldw	r2,-4(fp)
 82380ac:	10802017 	ldw	r2,128(r2)
 82380b0:	1005d0fa 	srai	r2,r2,3
 82380b4:	1885c83a 	sub	r2,r3,r2
 82380b8:	e0bffd15 	stw	r2,-12(fp)
      if ((tp->t_srtt += delta) <= 0)
 82380bc:	e0bfff17 	ldw	r2,-4(fp)
 82380c0:	10c02017 	ldw	r3,128(r2)
 82380c4:	e0bffd17 	ldw	r2,-12(fp)
 82380c8:	1887883a 	add	r3,r3,r2
 82380cc:	e0bfff17 	ldw	r2,-4(fp)
 82380d0:	10c02015 	stw	r3,128(r2)
 82380d4:	e0bfff17 	ldw	r2,-4(fp)
 82380d8:	10802017 	ldw	r2,128(r2)
 82380dc:	00800316 	blt	zero,r2,82380ec <tcp_xmit_timer+0x12c>
         tp->t_srtt = 1;
 82380e0:	e0bfff17 	ldw	r2,-4(fp)
 82380e4:	00c00044 	movi	r3,1
 82380e8:	10c02015 	stw	r3,128(r2)
       * (scaled by 4).  The following is equivalent
       * to rfc793 smoothing with an alpha of .75
       * (rttvar = rttvar*3/4 + |delta| / 4).
       * This replaces rfc793's wired-in beta.
       */
      if (delta < 0)
 82380ec:	e0bffd17 	ldw	r2,-12(fp)
 82380f0:	1000030e 	bge	r2,zero,8238100 <tcp_xmit_timer+0x140>
         delta = -delta;
 82380f4:	e0bffd17 	ldw	r2,-12(fp)
 82380f8:	0085c83a 	sub	r2,zero,r2
 82380fc:	e0bffd15 	stw	r2,-12(fp)
      delta -= (short)(tp->t_rttvar >> 1);
 8238100:	e0bfff17 	ldw	r2,-4(fp)
 8238104:	10802117 	ldw	r2,132(r2)
 8238108:	1005d07a 	srai	r2,r2,1
 823810c:	10bfffcc 	andi	r2,r2,65535
 8238110:	10a0001c 	xori	r2,r2,32768
 8238114:	10a00004 	addi	r2,r2,-32768
 8238118:	e0fffd17 	ldw	r3,-12(fp)
 823811c:	1885c83a 	sub	r2,r3,r2
 8238120:	e0bffd15 	stw	r2,-12(fp)
      if ((tp->t_rttvar += delta) <= 0)
 8238124:	e0bfff17 	ldw	r2,-4(fp)
 8238128:	10c02117 	ldw	r3,132(r2)
 823812c:	e0bffd17 	ldw	r2,-12(fp)
 8238130:	1887883a 	add	r3,r3,r2
 8238134:	e0bfff17 	ldw	r2,-4(fp)
 8238138:	10c02115 	stw	r3,132(r2)
 823813c:	e0bfff17 	ldw	r2,-4(fp)
 8238140:	10802117 	ldw	r2,132(r2)
 8238144:	00801116 	blt	zero,r2,823818c <tcp_xmit_timer+0x1cc>
         tp->t_rttvar = 1;
 8238148:	e0bfff17 	ldw	r2,-4(fp)
 823814c:	00c00044 	movi	r3,1
 8238150:	10c02115 	stw	r3,132(r2)
 8238154:	00000d06 	br	823818c <tcp_xmit_timer+0x1cc>
       * No rtt measurement yet - use the
       * unsmoothed rtt.  Set the variance
       * to half the rtt (so our first
       * retransmit happens at 2*rtt)
       */
      if(rtt < 1)
 8238158:	e0bffe17 	ldw	r2,-8(fp)
 823815c:	00800216 	blt	zero,r2,8238168 <tcp_xmit_timer+0x1a8>
         rtt = 1;
 8238160:	00800044 	movi	r2,1
 8238164:	e0bffe15 	stw	r2,-8(fp)
      tp->t_srtt = rtt << 3;
 8238168:	e0bffe17 	ldw	r2,-8(fp)
 823816c:	100690fa 	slli	r3,r2,3
 8238170:	e0bfff17 	ldw	r2,-4(fp)
 8238174:	10c02015 	stw	r3,128(r2)
      tp->t_rttvar = rtt << 1;
 8238178:	e0bffe17 	ldw	r2,-8(fp)
 823817c:	1085883a 	add	r2,r2,r2
 8238180:	1007883a 	mov	r3,r2
 8238184:	e0bfff17 	ldw	r2,-4(fp)
 8238188:	10c02115 	stw	r3,132(r2)
   }
   tp->t_rttick = 0;       /* clear RT timer */
 823818c:	e0bfff17 	ldw	r2,-4(fp)
 8238190:	10001e15 	stw	zero,120(r2)
   tp->t_rxtshift = 0;
 8238194:	e0bfff17 	ldw	r2,-4(fp)
 8238198:	10000715 	stw	zero,28(r2)
   TCPT_RANGESET(tp->t_rxtcur, 
 823819c:	e0bfff17 	ldw	r2,-4(fp)
 82381a0:	10802017 	ldw	r2,128(r2)
 82381a4:	1007d0ba 	srai	r3,r2,2
 82381a8:	e0bfff17 	ldw	r2,-4(fp)
 82381ac:	10802117 	ldw	r2,132(r2)
 82381b0:	1885883a 	add	r2,r3,r2
 82381b4:	1005d07a 	srai	r2,r2,1
 82381b8:	10ffffcc 	andi	r3,r2,65535
 82381bc:	18e0001c 	xori	r3,r3,32768
 82381c0:	18e00004 	addi	r3,r3,-32768
 82381c4:	e0bfff17 	ldw	r2,-4(fp)
 82381c8:	10c00815 	stw	r3,32(r2)
 82381cc:	e0bfff17 	ldw	r2,-4(fp)
 82381d0:	10800817 	ldw	r2,32(r2)
 82381d4:	10800088 	cmpgei	r2,r2,2
 82381d8:	1000041e 	bne	r2,zero,82381ec <tcp_xmit_timer+0x22c>
 82381dc:	e0bfff17 	ldw	r2,-4(fp)
 82381e0:	00c00084 	movi	r3,2
 82381e4:	10c00815 	stw	r3,32(r2)
 82381e8:	00000706 	br	8238208 <tcp_xmit_timer+0x248>
 82381ec:	e0bfff17 	ldw	r2,-4(fp)
 82381f0:	10800817 	ldw	r2,32(r2)
 82381f4:	10802050 	cmplti	r2,r2,129
 82381f8:	1000031e 	bne	r2,zero,8238208 <tcp_xmit_timer+0x248>
 82381fc:	e0bfff17 	ldw	r2,-4(fp)
 8238200:	00c02004 	movi	r3,128
 8238204:	10c00815 	stw	r3,32(r2)
    ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1,
    TCPTV_MIN, TCPTV_REXMTMAX);
}
 8238208:	e037883a 	mov	sp,fp
 823820c:	dfc00117 	ldw	ra,4(sp)
 8238210:	df000017 	ldw	fp,0(sp)
 8238214:	dec00204 	addi	sp,sp,8
 8238218:	f800283a 	ret

0823821c <ip4_tcpmss>:


#ifdef IP_V4
int
ip4_tcpmss(struct socket * so)
{
 823821c:	defffd04 	addi	sp,sp,-12
 8238220:	df000215 	stw	fp,8(sp)
 8238224:	df000204 	addi	fp,sp,8
 8238228:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = so->so_pcb->ifp;
 823822c:	e0bfff17 	ldw	r2,-4(fp)
 8238230:	10800117 	ldw	r2,4(r2)
 8238234:	10800a17 	ldw	r2,40(r2)
 8238238:	e0bffe15 	stw	r2,-8(fp)
   return(ifp->n_mtu - (40 + ifp->n_lnh));
 823823c:	e0bffe17 	ldw	r2,-8(fp)
 8238240:	10c00917 	ldw	r3,36(r2)
 8238244:	e0bffe17 	ldw	r2,-8(fp)
 8238248:	10800817 	ldw	r2,32(r2)
 823824c:	10800a04 	addi	r2,r2,40
 8238250:	1885c83a 	sub	r2,r3,r2
}
 8238254:	e037883a 	mov	sp,fp
 8238258:	df000017 	ldw	fp,0(sp)
 823825c:	dec00104 	addi	sp,sp,4
 8238260:	f800283a 	ret

08238264 <tcp_mss>:
 */


int
tcp_mss(struct socket * so)
{
 8238264:	defffa04 	addi	sp,sp,-24
 8238268:	dfc00515 	stw	ra,20(sp)
 823826c:	df000415 	stw	fp,16(sp)
 8238270:	df000404 	addi	fp,sp,16
 8238274:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp;
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
 8238278:	e0bfff17 	ldw	r2,-4(fp)
 823827c:	10000726 	beq	r2,zero,823829c <tcp_mss+0x38>
       (so->so_pcb == NULL) ||
 8238280:	e0bfff17 	ldw	r2,-4(fp)
 8238284:	10800117 	ldw	r2,4(r2)
   struct tcpcb * tp;
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
 8238288:	10000426 	beq	r2,zero,823829c <tcp_mss+0x38>
       (so->so_pcb == NULL) ||
       (so->so_pcb->ifp == NULL))
 823828c:	e0bfff17 	ldw	r2,-4(fp)
 8238290:	10800117 	ldw	r2,4(r2)
 8238294:	10800a17 	ldw	r2,40(r2)
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
       (so->so_pcb == NULL) ||
 8238298:	1000061e 	bne	r2,zero,82382b4 <tcp_mss+0x50>
       (so->so_pcb->ifp == NULL))
   {
      if (so->so_domain == AF_INET)  /* IPv4 */
 823829c:	e0bfff17 	ldw	r2,-4(fp)
 82382a0:	10800517 	ldw	r2,20(r2)
 82382a4:	10800098 	cmpnei	r2,r2,2
 82382a8:	1000021e 	bne	r2,zero,82382b4 <tcp_mss+0x50>
         return TCP_MSS;            /* user defined */
 82382ac:	00816d04 	movi	r2,1460
 82382b0:	00002506 	br	8238348 <tcp_mss+0xe4>
#endif   /* IP_V6 */


#ifdef IP_V4   /* Begin messy domain defines */
#ifndef IP_V6  /* V4 only version */
   mss = ip4_tcpmss(so);
 82382b4:	e13fff17 	ldw	r4,-4(fp)
 82382b8:	823821c0 	call	823821c <ip4_tcpmss>
 82382bc:	e0bffc15 	stw	r2,-16(fp)
#endif         /* end of dual mode */
#else          /* no IP_v4, assume V6 only */
      mss = ip6_tcpmss(so, ifp);
#endif         /* end messy domain defines */

   if (mss > TCP_MSS)    /* check upper limit from compile */
 82382c0:	e0bffc17 	ldw	r2,-16(fp)
 82382c4:	10816d50 	cmplti	r2,r2,1461
 82382c8:	1000021e 	bne	r2,zero,82382d4 <tcp_mss+0x70>
      mss = TCP_MSS;
 82382cc:	00816d04 	movi	r2,1460
 82382d0:	e0bffc15 	stw	r2,-16(fp)

   /* check upper limit which may be set by setsockopt() */
   inp = (struct inpcb *)so->so_pcb;         /* Map socket to IP cb */
 82382d4:	e0bfff17 	ldw	r2,-4(fp)
 82382d8:	10800117 	ldw	r2,4(r2)
 82382dc:	e0bffd15 	stw	r2,-12(fp)
   tp = (struct tcpcb *)inp->inp_ppcb;       /* Map IP to TCP cb */
 82382e0:	e0bffd17 	ldw	r2,-12(fp)
 82382e4:	10800917 	ldw	r2,36(r2)
 82382e8:	e0bffe15 	stw	r2,-8(fp)
   
   /* has user set max seg? */
   if (tp->t_flags & TF_MAXSEG)
 82382ec:	e0bffe17 	ldw	r2,-8(fp)
 82382f0:	10800b0b 	ldhu	r2,44(r2)
 82382f4:	10bfffcc 	andi	r2,r2,65535
 82382f8:	1081000c 	andi	r2,r2,1024
 82382fc:	10000426 	beq	r2,zero,8238310 <tcp_mss+0xac>
      return tp->t_maxseg;    /* yup */
 8238300:	e0bffe17 	ldw	r2,-8(fp)
 8238304:	10800a0b 	ldhu	r2,40(r2)
 8238308:	10bfffcc 	andi	r2,r2,65535
 823830c:	00000e06 	br	8238348 <tcp_mss+0xe4>
      
   if (tp->t_maxseg && (mss > tp->t_maxseg))  /* check tcp's mss */
 8238310:	e0bffe17 	ldw	r2,-8(fp)
 8238314:	10800a0b 	ldhu	r2,40(r2)
 8238318:	10bfffcc 	andi	r2,r2,65535
 823831c:	10000926 	beq	r2,zero,8238344 <tcp_mss+0xe0>
 8238320:	e0bffe17 	ldw	r2,-8(fp)
 8238324:	10800a0b 	ldhu	r2,40(r2)
 8238328:	10ffffcc 	andi	r3,r2,65535
 823832c:	e0bffc17 	ldw	r2,-16(fp)
 8238330:	1880040e 	bge	r3,r2,8238344 <tcp_mss+0xe0>
   {
      mss = tp->t_maxseg;        /* limit new MSS to set MSS */
 8238334:	e0bffe17 	ldw	r2,-8(fp)
 8238338:	10800a0b 	ldhu	r2,40(r2)
 823833c:	10bfffcc 	andi	r2,r2,65535
 8238340:	e0bffc15 	stw	r2,-16(fp)
   }

   return mss;
 8238344:	e0bffc17 	ldw	r2,-16(fp)
}
 8238348:	e037883a 	mov	sp,fp
 823834c:	dfc00117 	ldw	ra,4(sp)
 8238350:	df000017 	ldw	fp,0(sp)
 8238354:	dec00204 	addi	sp,sp,8
 8238358:	f800283a 	ret

0823835c <tcp_output>:
 * RETURNS: 0 if OK, else a sockets error code.
 */

int
tcp_output(struct tcpcb * tp)
{
 823835c:	deffe804 	addi	sp,sp,-96
 8238360:	dfc01715 	stw	ra,92(sp)
 8238364:	df001615 	stw	fp,88(sp)
 8238368:	df001604 	addi	fp,sp,88
 823836c:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 8238370:	e0bfff17 	ldw	r2,-4(fp)
 8238374:	10800d17 	ldw	r2,52(r2)
 8238378:	10800817 	ldw	r2,32(r2)
 823837c:	e0bff215 	stw	r2,-56(fp)
   int   len;
   long  win;
   int   off,  flags,   error;
   struct mbuf *  m;
   struct tcpiphdr * ti;
   unsigned optlen = 0;
 8238380:	e03fee15 	stw	zero,-72(fp)
    * Determine length of data that should be transmitted,
    * and flags that will be used.
    * If there is some data or critical controls (SYN, RST)
    * to send, then transmit; otherwise, investigate further.
    */
   idle = (tp->snd_max == tp->snd_una);
 8238384:	e0bfff17 	ldw	r2,-4(fp)
 8238388:	10c01a17 	ldw	r3,104(r2)
 823838c:	e0bfff17 	ldw	r2,-4(fp)
 8238390:	10800e17 	ldw	r2,56(r2)
 8238394:	1885003a 	cmpeq	r2,r3,r2
 8238398:	10803fcc 	andi	r2,r2,255
 823839c:	e0bff315 	stw	r2,-52(fp)

again:
   sendalot = 0;
 82383a0:	e03fef15 	stw	zero,-68(fp)
   off = (int)(tp->snd_nxt - tp->snd_una);
 82383a4:	e0bfff17 	ldw	r2,-4(fp)
 82383a8:	10c00f17 	ldw	r3,60(r2)
 82383ac:	e0bfff17 	ldw	r2,-4(fp)
 82383b0:	10800e17 	ldw	r2,56(r2)
 82383b4:	1885c83a 	sub	r2,r3,r2
 82383b8:	e0bff415 	stw	r2,-48(fp)
   win = (long)tp->snd_wnd;   /* set basic send window */
 82383bc:	e0bfff17 	ldw	r2,-4(fp)
 82383c0:	10801417 	ldw	r2,80(r2)
 82383c4:	e0bfeb15 	stw	r2,-84(fp)
   if (win > (long)tp->snd_cwnd) /* see if we need congestion control */
 82383c8:	e0bfff17 	ldw	r2,-4(fp)
 82383cc:	10801b17 	ldw	r2,108(r2)
 82383d0:	1007883a 	mov	r3,r2
 82383d4:	e0bfeb17 	ldw	r2,-84(fp)
 82383d8:	1880060e 	bge	r3,r2,82383f4 <tcp_output+0x98>
   {
      win = (int)(tp->snd_cwnd & ~(ALIGN_TYPE-1)); /* keep data aligned */
 82383dc:	e0bfff17 	ldw	r2,-4(fp)
 82383e0:	10801b17 	ldw	r2,108(r2)
 82383e4:	1007883a 	mov	r3,r2
 82383e8:	00bfff04 	movi	r2,-4
 82383ec:	1884703a 	and	r2,r3,r2
 82383f0:	e0bfeb15 	stw	r2,-84(fp)
    * If in persist timeout with window of 0, send 1 byte.
    * Otherwise, if window is small but nonzero
    * and timer expired, we will send what we can
    * and go to transmit state.
    */
   if (tp->t_force) 
 82383f4:	e0bfff17 	ldw	r2,-4(fp)
 82383f8:	10800a83 	ldbu	r2,42(r2)
 82383fc:	10803fcc 	andi	r2,r2,255
 8238400:	1080201c 	xori	r2,r2,128
 8238404:	10bfe004 	addi	r2,r2,-128
 8238408:	10000926 	beq	r2,zero,8238430 <tcp_output+0xd4>
   {
      if (win == 0)
 823840c:	e0bfeb17 	ldw	r2,-84(fp)
 8238410:	1000031e 	bne	r2,zero,8238420 <tcp_output+0xc4>
         win = 1;
 8238414:	00800044 	movi	r2,1
 8238418:	e0bfeb15 	stw	r2,-84(fp)
 823841c:	00000406 	br	8238430 <tcp_output+0xd4>
      else 
      {
         tp->t_timer[TCPT_PERSIST] = 0;
 8238420:	e0bfff17 	ldw	r2,-4(fp)
 8238424:	10000415 	stw	zero,16(r2)
         tp->t_rxtshift = 0;
 8238428:	e0bfff17 	ldw	r2,-4(fp)
 823842c:	10000715 	stw	zero,28(r2)
   }
   else
#endif /* TCP_SACK */
   {
      /* set length of packets which are not sack resends */
      len = (int)MIN(so->so_snd.sb_cc, (unsigned)win) - off;
 8238430:	e0bff217 	ldw	r2,-56(fp)
 8238434:	10801217 	ldw	r2,72(r2)
 8238438:	e0ffeb17 	ldw	r3,-84(fp)
 823843c:	1880012e 	bgeu	r3,r2,8238444 <tcp_output+0xe8>
 8238440:	1805883a 	mov	r2,r3
 8238444:	1007883a 	mov	r3,r2
 8238448:	e0bff417 	ldw	r2,-48(fp)
 823844c:	1885c83a 	sub	r2,r3,r2
 8238450:	e0bfea15 	stw	r2,-88(fp)
   }

   flags = tcp_outflags[tp->t_state];
 8238454:	e0bfff17 	ldw	r2,-4(fp)
 8238458:	10c00217 	ldw	r3,8(r2)
 823845c:	00820974 	movhi	r2,2085
 8238460:	108ee504 	addi	r2,r2,15252
 8238464:	10c5883a 	add	r2,r2,r3
 8238468:	10800003 	ldbu	r2,0(r2)
 823846c:	10803fcc 	andi	r2,r2,255
 8238470:	e0bfec15 	stw	r2,-80(fp)
   }
#else
   /* If other options not defined this build then don't bother to call bld_options() except 
    * on SYN packets
    */
   if(flags & TH_SYN)
 8238474:	e0bfec17 	ldw	r2,-80(fp)
 8238478:	1080008c 	andi	r2,r2,2
 823847c:	10000926 	beq	r2,zero,82384a4 <tcp_output+0x148>
   {
      optlen = bld_options(tp, &tcp_optionbuf[optlen], flags, so);
 8238480:	e0ffee17 	ldw	r3,-72(fp)
 8238484:	d0a0b304 	addi	r2,gp,-32052
 8238488:	1885883a 	add	r2,r3,r2
 823848c:	e1fff217 	ldw	r7,-56(fp)
 8238490:	e1bfec17 	ldw	r6,-80(fp)
 8238494:	100b883a 	mov	r5,r2
 8238498:	e13fff17 	ldw	r4,-4(fp)
 823849c:	82394600 	call	8239460 <bld_options>
 82384a0:	e0bfee15 	stw	r2,-72(fp)
   }
#endif

   if (len < 0)
 82384a4:	e0bfea17 	ldw	r2,-88(fp)
 82384a8:	1000090e 	bge	r2,zero,82384d0 <tcp_output+0x174>
       * cancel pending retransmit and pull snd_nxt
       * back to (closed) window.  We will enter persist
       * state below.  If the window didn't close completely,
       * just wait for an ACK.
       */
      len = 0;
 82384ac:	e03fea15 	stw	zero,-88(fp)
      if (win == 0) 
 82384b0:	e0bfeb17 	ldw	r2,-84(fp)
 82384b4:	1000061e 	bne	r2,zero,82384d0 <tcp_output+0x174>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 82384b8:	e0bfff17 	ldw	r2,-4(fp)
 82384bc:	10000315 	stw	zero,12(r2)
         tp->snd_nxt = tp->snd_una;
 82384c0:	e0bfff17 	ldw	r2,-4(fp)
 82384c4:	10c00e17 	ldw	r3,56(r2)
 82384c8:	e0bfff17 	ldw	r2,-4(fp)
 82384cc:	10c00f15 	stw	r3,60(r2)
      }
   }

   if (len > (int)tp->t_maxseg)
 82384d0:	e0bfff17 	ldw	r2,-4(fp)
 82384d4:	10800a0b 	ldhu	r2,40(r2)
 82384d8:	10ffffcc 	andi	r3,r2,65535
 82384dc:	e0bfea17 	ldw	r2,-88(fp)
 82384e0:	1880060e 	bge	r3,r2,82384fc <tcp_output+0x1a0>
   {
      len = tp->t_maxseg;
 82384e4:	e0bfff17 	ldw	r2,-4(fp)
 82384e8:	10800a0b 	ldhu	r2,40(r2)
 82384ec:	10bfffcc 	andi	r2,r2,65535
 82384f0:	e0bfea15 	stw	r2,-88(fp)
      sendalot = 1;
 82384f4:	00800044 	movi	r2,1
 82384f8:	e0bfef15 	stw	r2,-68(fp)
   /* We don't need a pmtu test for IPv6. V6 code limits t_maxseg to
    * the Path MTU, so the test above the v4 ifdef above covers us.
    */
#endif /* IP_V4 */

   if (SEQ_LT(tp->snd_nxt + len, tp->snd_una + so->so_snd.sb_cc))
 82384fc:	e0bfff17 	ldw	r2,-4(fp)
 8238500:	10c00f17 	ldw	r3,60(r2)
 8238504:	e0bfea17 	ldw	r2,-88(fp)
 8238508:	1887883a 	add	r3,r3,r2
 823850c:	e0bfff17 	ldw	r2,-4(fp)
 8238510:	11000e17 	ldw	r4,56(r2)
 8238514:	e0bff217 	ldw	r2,-56(fp)
 8238518:	10801217 	ldw	r2,72(r2)
 823851c:	2085883a 	add	r2,r4,r2
 8238520:	1885c83a 	sub	r2,r3,r2
 8238524:	1000040e 	bge	r2,zero,8238538 <tcp_output+0x1dc>
      flags &= ~TH_FIN;
 8238528:	e0ffec17 	ldw	r3,-80(fp)
 823852c:	00bfff84 	movi	r2,-2
 8238530:	1884703a 	and	r2,r3,r2
 8238534:	e0bfec15 	stw	r2,-80(fp)
   win = (long)(sbspace(&so->so_rcv));
 8238538:	e0bff217 	ldw	r2,-56(fp)
 823853c:	10800b17 	ldw	r2,44(r2)
 8238540:	1007883a 	mov	r3,r2
 8238544:	e0bff217 	ldw	r2,-56(fp)
 8238548:	10800a17 	ldw	r2,40(r2)
 823854c:	1885c83a 	sub	r2,r3,r2
 8238550:	10000616 	blt	r2,zero,823856c <tcp_output+0x210>
 8238554:	e0bff217 	ldw	r2,-56(fp)
 8238558:	10c00b17 	ldw	r3,44(r2)
 823855c:	e0bff217 	ldw	r2,-56(fp)
 8238560:	10800a17 	ldw	r2,40(r2)
 8238564:	1885c83a 	sub	r2,r3,r2
 8238568:	00000106 	br	8238570 <tcp_output+0x214>
 823856c:	0005883a 	mov	r2,zero
 8238570:	e0bfeb15 	stw	r2,-84(fp)
   /*
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
 8238574:	e0bfec17 	ldw	r2,-80(fp)
 8238578:	1080004c 	andi	r2,r2,1
 823857c:	10000d26 	beq	r2,zero,82385b4 <tcp_output+0x258>
       (so->so_snd.sb_cc == 0) &&
 8238580:	e0bff217 	ldw	r2,-56(fp)
 8238584:	10801217 	ldw	r2,72(r2)
   /*
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
 8238588:	10000a1e 	bne	r2,zero,82385b4 <tcp_output+0x258>
       (so->so_snd.sb_cc == 0) &&
       ((tp->t_flags & TF_SENTFIN) == 0 || tp->snd_nxt == tp->snd_una))
 823858c:	e0bfff17 	ldw	r2,-4(fp)
 8238590:	10800b0b 	ldhu	r2,44(r2)
 8238594:	10bfffcc 	andi	r2,r2,65535
 8238598:	1080040c 	andi	r2,r2,16
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
       (so->so_snd.sb_cc == 0) &&
 823859c:	10007926 	beq	r2,zero,8238784 <tcp_output+0x428>
       ((tp->t_flags & TF_SENTFIN) == 0 || tp->snd_nxt == tp->snd_una))
 82385a0:	e0bfff17 	ldw	r2,-4(fp)
 82385a4:	10c00f17 	ldw	r3,60(r2)
 82385a8:	e0bfff17 	ldw	r2,-4(fp)
 82385ac:	10800e17 	ldw	r2,56(r2)
 82385b0:	18807426 	beq	r3,r2,8238784 <tcp_output+0x428>
      goto send;
   }
   /*
    * Send if we owe peer an ACK.
    */
   if (tp->t_flags & TF_ACKNOW)
 82385b4:	e0bfff17 	ldw	r2,-4(fp)
 82385b8:	10800b0b 	ldhu	r2,44(r2)
 82385bc:	10bfffcc 	andi	r2,r2,65535
 82385c0:	1080004c 	andi	r2,r2,1
 82385c4:	10005c1e 	bne	r2,zero,8238738 <tcp_output+0x3dc>
      goto send;
   if (flags & (TH_SYN|TH_RST))
 82385c8:	e0bfec17 	ldw	r2,-80(fp)
 82385cc:	1080018c 	andi	r2,r2,6
 82385d0:	10005b1e 	bne	r2,zero,8238740 <tcp_output+0x3e4>
      goto send;
   if (SEQ_GT(tp->snd_up, tp->snd_una))
 82385d4:	e0bfff17 	ldw	r2,-4(fp)
 82385d8:	10c01017 	ldw	r3,64(r2)
 82385dc:	e0bfff17 	ldw	r2,-4(fp)
 82385e0:	10800e17 	ldw	r2,56(r2)
 82385e4:	1885c83a 	sub	r2,r3,r2
 82385e8:	00805716 	blt	zero,r2,8238748 <tcp_output+0x3ec>
    * If peer's buffer is tiny, then send
    * when window is at least half open.
    * If retransmitting (possibly after persist timer forced us
    * to send into a small window), then must resend.
    */
   if (len)
 82385ec:	e0bfea17 	ldw	r2,-88(fp)
 82385f0:	10002426 	beq	r2,zero,8238684 <tcp_output+0x328>
   {
      if (len == (int)tp->t_maxseg)
 82385f4:	e0bfff17 	ldw	r2,-4(fp)
 82385f8:	10800a0b 	ldhu	r2,40(r2)
 82385fc:	10ffffcc 	andi	r3,r2,65535
 8238600:	e0bfea17 	ldw	r2,-88(fp)
 8238604:	18805226 	beq	r3,r2,8238750 <tcp_output+0x3f4>
         goto send;
      if ((idle || tp->t_flags & TF_NODELAY) &&
 8238608:	e0bff317 	ldw	r2,-52(fp)
 823860c:	1000051e 	bne	r2,zero,8238624 <tcp_output+0x2c8>
 8238610:	e0bfff17 	ldw	r2,-4(fp)
 8238614:	10800b0b 	ldhu	r2,44(r2)
 8238618:	10bfffcc 	andi	r2,r2,65535
 823861c:	1080010c 	andi	r2,r2,4
 8238620:	10000626 	beq	r2,zero,823863c <tcp_output+0x2e0>
          len + off >= (int)so->so_snd.sb_cc)
 8238624:	e0ffea17 	ldw	r3,-88(fp)
 8238628:	e0bff417 	ldw	r2,-48(fp)
 823862c:	1885883a 	add	r2,r3,r2
 8238630:	e0fff217 	ldw	r3,-56(fp)
 8238634:	18c01217 	ldw	r3,72(r3)
    */
   if (len)
   {
      if (len == (int)tp->t_maxseg)
         goto send;
      if ((idle || tp->t_flags & TF_NODELAY) &&
 8238638:	10c0470e 	bge	r2,r3,8238758 <tcp_output+0x3fc>
          len + off >= (int)so->so_snd.sb_cc)
      {
         goto send;
      }
      if (tp->t_force)
 823863c:	e0bfff17 	ldw	r2,-4(fp)
 8238640:	10800a83 	ldbu	r2,42(r2)
 8238644:	10803fcc 	andi	r2,r2,255
 8238648:	1080201c 	xori	r2,r2,128
 823864c:	10bfe004 	addi	r2,r2,-128
 8238650:	1000431e 	bne	r2,zero,8238760 <tcp_output+0x404>
         goto send;
      if (len >= (int)(tp->max_sndwnd / 2))
 8238654:	e0bfff17 	ldw	r2,-4(fp)
 8238658:	10802317 	ldw	r2,140(r2)
 823865c:	1004d07a 	srli	r2,r2,1
 8238660:	1007883a 	mov	r3,r2
 8238664:	e0bfea17 	ldw	r2,-88(fp)
 8238668:	10c03f0e 	bge	r2,r3,8238768 <tcp_output+0x40c>
         goto send;
      if (SEQ_LT(tp->snd_nxt, tp->snd_max))
 823866c:	e0bfff17 	ldw	r2,-4(fp)
 8238670:	10c00f17 	ldw	r3,60(r2)
 8238674:	e0bfff17 	ldw	r2,-4(fp)
 8238678:	10801a17 	ldw	r2,104(r2)
 823867c:	1885c83a 	sub	r2,r3,r2
 8238680:	10003b16 	blt	r2,zero,8238770 <tcp_output+0x414>
    * known to peer (as advertised window less
    * next expected input).  If the difference is at least two
    * max size segments or at least 35% of the maximum possible
    * window, then want to send a window update to peer.
    */
   if (win > 0)
 8238684:	e0bfeb17 	ldw	r2,-84(fp)
 8238688:	00801c0e 	bge	zero,r2,82386fc <tcp_output+0x3a0>
   {
      int   adv   =  (int)win -  (int)(tp->rcv_adv -  tp->rcv_nxt);
 823868c:	e0bfff17 	ldw	r2,-4(fp)
 8238690:	10c01617 	ldw	r3,88(r2)
 8238694:	e0bfff17 	ldw	r2,-4(fp)
 8238698:	10801917 	ldw	r2,100(r2)
 823869c:	1885c83a 	sub	r2,r3,r2
 82386a0:	1007883a 	mov	r3,r2
 82386a4:	e0bfeb17 	ldw	r2,-84(fp)
 82386a8:	1885883a 	add	r2,r3,r2
 82386ac:	e0bffd15 	stw	r2,-12(fp)

      if (so->so_rcv.sb_cc == 0 && adv >= (int)(tp->t_maxseg * 2))
 82386b0:	e0bff217 	ldw	r2,-56(fp)
 82386b4:	10800a17 	ldw	r2,40(r2)
 82386b8:	1000071e 	bne	r2,zero,82386d8 <tcp_output+0x37c>
 82386bc:	e0bfff17 	ldw	r2,-4(fp)
 82386c0:	10800a0b 	ldhu	r2,40(r2)
 82386c4:	10bfffcc 	andi	r2,r2,65535
 82386c8:	1085883a 	add	r2,r2,r2
 82386cc:	1007883a 	mov	r3,r2
 82386d0:	e0bffd17 	ldw	r2,-12(fp)
 82386d4:	10c0280e 	bge	r2,r3,8238778 <tcp_output+0x41c>
         goto send;
      if (100 * (u_int)adv / so->so_rcv.sb_hiwat >= 35)
 82386d8:	e0bffd17 	ldw	r2,-12(fp)
 82386dc:	10c01924 	muli	r3,r2,100
 82386e0:	e0bff217 	ldw	r2,-56(fp)
 82386e4:	10800b17 	ldw	r2,44(r2)
 82386e8:	100b883a 	mov	r5,r2
 82386ec:	1809883a 	mov	r4,r3
 82386f0:	8202c6c0 	call	8202c6c <__udivsi3>
 82386f4:	108008f0 	cmpltui	r2,r2,35
 82386f8:	10002126 	beq	r2,zero,8238780 <tcp_output+0x424>
    * retransmit or persist is pending, then go to persist state.
    * If nothing happens soon, send when timer expires:
    * if window is nonzero, transmit what we can,
    * otherwise force out a byte.
    */
   if (so->so_snd.sb_cc && tp->t_timer[TCPT_REXMT] == 0 &&
 82386fc:	e0bff217 	ldw	r2,-56(fp)
 8238700:	10801217 	ldw	r2,72(r2)
 8238704:	10000a26 	beq	r2,zero,8238730 <tcp_output+0x3d4>
 8238708:	e0bfff17 	ldw	r2,-4(fp)
 823870c:	10800317 	ldw	r2,12(r2)
 8238710:	1000071e 	bne	r2,zero,8238730 <tcp_output+0x3d4>
       tp->t_timer[TCPT_PERSIST] == 0) 
 8238714:	e0bfff17 	ldw	r2,-4(fp)
 8238718:	10800417 	ldw	r2,16(r2)
    * retransmit or persist is pending, then go to persist state.
    * If nothing happens soon, send when timer expires:
    * if window is nonzero, transmit what we can,
    * otherwise force out a byte.
    */
   if (so->so_snd.sb_cc && tp->t_timer[TCPT_REXMT] == 0 &&
 823871c:	1000041e 	bne	r2,zero,8238730 <tcp_output+0x3d4>
       tp->t_timer[TCPT_PERSIST] == 0) 
   {
      tp->t_rxtshift = 0;
 8238720:	e0bfff17 	ldw	r2,-4(fp)
 8238724:	10000715 	stw	zero,28(r2)
      tcp_setpersist(tp);
 8238728:	e13fff17 	ldw	r4,-4(fp)
 823872c:	82393600 	call	8239360 <tcp_setpersist>
   }

   /*
    * No reason to send a segment, just return.
    */
   return (0);
 8238730:	0005883a 	mov	r2,zero
 8238734:	00030506 	br	823934c <tcp_output+0xff0>
   }
   /*
    * Send if we owe peer an ACK.
    */
   if (tp->t_flags & TF_ACKNOW)
      goto send;
 8238738:	0001883a 	nop
 823873c:	00001106 	br	8238784 <tcp_output+0x428>
   if (flags & (TH_SYN|TH_RST))
      goto send;
 8238740:	0001883a 	nop
 8238744:	00000f06 	br	8238784 <tcp_output+0x428>
   if (SEQ_GT(tp->snd_up, tp->snd_una))
      goto send;
 8238748:	0001883a 	nop
 823874c:	00000d06 	br	8238784 <tcp_output+0x428>
    * to send into a small window), then must resend.
    */
   if (len)
   {
      if (len == (int)tp->t_maxseg)
         goto send;
 8238750:	0001883a 	nop
 8238754:	00000b06 	br	8238784 <tcp_output+0x428>
      if ((idle || tp->t_flags & TF_NODELAY) &&
          len + off >= (int)so->so_snd.sb_cc)
      {
         goto send;
 8238758:	0001883a 	nop
 823875c:	00000906 	br	8238784 <tcp_output+0x428>
      }
      if (tp->t_force)
         goto send;
 8238760:	0001883a 	nop
 8238764:	00000706 	br	8238784 <tcp_output+0x428>
      if (len >= (int)(tp->max_sndwnd / 2))
         goto send;
 8238768:	0001883a 	nop
 823876c:	00000506 	br	8238784 <tcp_output+0x428>
      if (SEQ_LT(tp->snd_nxt, tp->snd_max))
         goto send;
 8238770:	0001883a 	nop
 8238774:	00000306 	br	8238784 <tcp_output+0x428>
   if (win > 0)
   {
      int   adv   =  (int)win -  (int)(tp->rcv_adv -  tp->rcv_nxt);

      if (so->so_rcv.sb_cc == 0 && adv >= (int)(tp->t_maxseg * 2))
         goto send;
 8238778:	0001883a 	nop
 823877c:	00000106 	br	8238784 <tcp_output+0x428>
      if (100 * (u_int)adv / so->so_rcv.sb_hiwat >= 35)
         goto send;
 8238780:	0001883a 	nop
    * No reason to send a segment, just return.
    */
   return (0);

send:
   ENTER_CRIT_SECTION(tp);
 8238784:	822d7c80 	call	822d7c8 <irq_Mask>

   /* Limit send length to the current buffer so as to
    * avoid doing the "mbuf shuffle" in m_copy().
    */
   bufoff = off;
 8238788:	e0bff417 	ldw	r2,-48(fp)
 823878c:	e0bff115 	stw	r2,-60(fp)
   sendm = so->so_snd.sb_mb;
 8238790:	e0bff217 	ldw	r2,-56(fp)
 8238794:	10801817 	ldw	r2,96(r2)
 8238798:	e0bff015 	stw	r2,-64(fp)
   if (len)
 823879c:	e0bfea17 	ldw	r2,-88(fp)
 82387a0:	10005526 	beq	r2,zero,82388f8 <tcp_output+0x59c>
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 82387a4:	00000a06 	br	82387d0 <tcp_output+0x474>
      {
         bufoff -= sendm->m_len;
 82387a8:	e0fff117 	ldw	r3,-60(fp)
 82387ac:	e0bff017 	ldw	r2,-64(fp)
 82387b0:	10800217 	ldw	r2,8(r2)
 82387b4:	1885c83a 	sub	r2,r3,r2
 82387b8:	e0bff115 	stw	r2,-60(fp)
         if (bufoff < 0)   /* if off is in this buffer, break */
 82387bc:	e0bff117 	ldw	r2,-60(fp)
 82387c0:	10000616 	blt	r2,zero,82387dc <tcp_output+0x480>
            break;
         sendm = sendm->m_next;
 82387c4:	e0bff017 	ldw	r2,-64(fp)
 82387c8:	10800617 	ldw	r2,24(r2)
 82387cc:	e0bff015 	stw	r2,-64(fp)
   bufoff = off;
   sendm = so->so_snd.sb_mb;
   if (len)
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 82387d0:	e0bff017 	ldw	r2,-64(fp)
 82387d4:	103ff41e 	bne	r2,zero,82387a8 <tcp_output+0x44c>
 82387d8:	00000106 	br	82387e0 <tcp_output+0x484>
      {
         bufoff -= sendm->m_len;
         if (bufoff < 0)   /* if off is in this buffer, break */
            break;
 82387dc:	0001883a 	nop
         sendm = sendm->m_next;
      }
      if (!sendm) { dtrap();  /* shouldn't happen */ }
 82387e0:	e0bff017 	ldw	r2,-64(fp)
 82387e4:	1000011e 	bne	r2,zero,82387ec <tcp_output+0x490>
 82387e8:	822d5f00 	call	822d5f0 <dtrap>
      bufoff += sendm->m_len; /* index to next data to send in msend */
 82387ec:	e0bff017 	ldw	r2,-64(fp)
 82387f0:	10c00217 	ldw	r3,8(r2)
 82387f4:	e0bff117 	ldw	r2,-60(fp)
 82387f8:	1885883a 	add	r2,r3,r2
 82387fc:	e0bff115 	stw	r2,-60(fp)

      /* if socket has multiple unsent mbufs, set flag for send to loop */
      if ((sendm->m_next) && (len > (int)sendm->m_len))
 8238800:	e0bff017 	ldw	r2,-64(fp)
 8238804:	10800617 	ldw	r2,24(r2)
 8238808:	10000b26 	beq	r2,zero,8238838 <tcp_output+0x4dc>
 823880c:	e0bff017 	ldw	r2,-64(fp)
 8238810:	10800217 	ldw	r2,8(r2)
 8238814:	1007883a 	mov	r3,r2
 8238818:	e0bfea17 	ldw	r2,-88(fp)
 823881c:	1880060e 	bge	r3,r2,8238838 <tcp_output+0x4dc>
      {
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 8238820:	e0ffec17 	ldw	r3,-80(fp)
 8238824:	00bfff84 	movi	r2,-2
 8238828:	1884703a 	and	r2,r3,r2
 823882c:	e0bfec15 	stw	r2,-80(fp)
         sendalot = 1;     /* set to send more segments */
 8238830:	00800044 	movi	r2,1
 8238834:	e0bfef15 	stw	r2,-68(fp)
      }
      if((flags & TH_FIN) && (so->so_snd.sb_cc > (unsigned)len))
 8238838:	e0bfec17 	ldw	r2,-80(fp)
 823883c:	1080004c 	andi	r2,r2,1
 8238840:	10000826 	beq	r2,zero,8238864 <tcp_output+0x508>
 8238844:	e0bff217 	ldw	r2,-56(fp)
 8238848:	10801217 	ldw	r2,72(r2)
 823884c:	e0ffea17 	ldw	r3,-88(fp)
 8238850:	1880042e 	bgeu	r3,r2,8238864 <tcp_output+0x508>
      {
         /* This can happen on slow links (PPP) which retry the last 
          * segment - the one with the FIN bit attached to data.
          */
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 8238854:	e0ffec17 	ldw	r3,-80(fp)
 8238858:	00bfff84 	movi	r2,-2
 823885c:	1884703a 	and	r2,r3,r2
 8238860:	e0bfec15 	stw	r2,-80(fp)
      }

      /* only send the rest of msend */
      len = min(len, (int)sendm->m_len);
 8238864:	e0bff017 	ldw	r2,-64(fp)
 8238868:	10800217 	ldw	r2,8(r2)
 823886c:	e0ffea17 	ldw	r3,-88(fp)
 8238870:	1880010e 	bge	r3,r2,8238878 <tcp_output+0x51c>
 8238874:	1805883a 	mov	r2,r3
 8238878:	e0bfea15 	stw	r2,-88(fp)
       * Similarly, if sendm->m_data is not aligned with respect to 
       * sendm->m_base and ALIGN_TYPE, we will copy the data to 
       * ensure that it (and the then-prepended IP/TCP headers) will 
       * be aligned according to ALIGN_TYPE. 
       */
      if ((bufoff != 0) ||       /* data not front aligned in send mbuf? */
 823887c:	e0bff117 	ldw	r2,-60(fp)
 8238880:	1000081e 	bne	r2,zero,82388a4 <tcp_output+0x548>
          (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) != 0))
 8238884:	e0bff017 	ldw	r2,-64(fp)
 8238888:	10800317 	ldw	r2,12(r2)
 823888c:	1007883a 	mov	r3,r2
 8238890:	e0bff017 	ldw	r2,-64(fp)
 8238894:	10800417 	ldw	r2,16(r2)
 8238898:	1885c83a 	sub	r2,r3,r2
 823889c:	108000cc 	andi	r2,r2,3
       * Similarly, if sendm->m_data is not aligned with respect to 
       * sendm->m_base and ALIGN_TYPE, we will copy the data to 
       * ensure that it (and the then-prepended IP/TCP headers) will 
       * be aligned according to ALIGN_TYPE. 
       */
      if ((bufoff != 0) ||       /* data not front aligned in send mbuf? */
 82388a0:	10001526 	beq	r2,zero,82388f8 <tcp_output+0x59c>
          (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) != 0))
      {
         len = min(len, (int)(sendm->m_len - bufoff));   /* limit len again */
 82388a4:	e0bff017 	ldw	r2,-64(fp)
 82388a8:	10c00217 	ldw	r3,8(r2)
 82388ac:	e0bff117 	ldw	r2,-60(fp)
 82388b0:	1885c83a 	sub	r2,r3,r2
 82388b4:	e0ffea17 	ldw	r3,-88(fp)
 82388b8:	1880010e 	bge	r3,r2,82388c0 <tcp_output+0x564>
 82388bc:	1805883a 	mov	r2,r3
 82388c0:	e0bfea15 	stw	r2,-88(fp)
          * of the m_data buffer then we can't use it in place, else we
          * might write the IP/TCP header over data that has not yet
          * been acked. In this case we must make sure our send
          * fits into a little buffer and send what we can.
          */
         if ((len > (int)(lilbufsiz - HDRSLEN)) && /* length is bigger the small buffer? */
 82388c4:	d0a03717 	ldw	r2,-32548(gp)
 82388c8:	10bff204 	addi	r2,r2,-56
 82388cc:	1007883a 	mov	r3,r2
 82388d0:	e0bfea17 	ldw	r2,-88(fp)
 82388d4:	1880080e 	bge	r3,r2,82388f8 <tcp_output+0x59c>
             (bigfreeq.q_len < 2))      /* and we are low on big buffers */
 82388d8:	008209b4 	movhi	r2,2086
 82388dc:	10b8e404 	addi	r2,r2,-7280
 82388e0:	10800217 	ldw	r2,8(r2)
          * of the m_data buffer then we can't use it in place, else we
          * might write the IP/TCP header over data that has not yet
          * been acked. In this case we must make sure our send
          * fits into a little buffer and send what we can.
          */
         if ((len > (int)(lilbufsiz - HDRSLEN)) && /* length is bigger the small buffer? */
 82388e4:	10800088 	cmpgei	r2,r2,2
 82388e8:	1000031e 	bne	r2,zero,82388f8 <tcp_output+0x59c>
             (bigfreeq.q_len < 2))      /* and we are low on big buffers */
         {
            len = lilbufsiz - HDRSLEN;
 82388ec:	d0a03717 	ldw	r2,-32548(gp)
 82388f0:	10bff204 	addi	r2,r2,-56
 82388f4:	e0bfea15 	stw	r2,-88(fp)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 82388f8:	e0bfea17 	ldw	r2,-88(fp)
 82388fc:	10003626 	beq	r2,zero,82389d8 <tcp_output+0x67c>
 8238900:	e0bff117 	ldw	r2,-60(fp)
 8238904:	1000341e 	bne	r2,zero,82389d8 <tcp_output+0x67c>
       (sendm->pkt->inuse == 1) &&
 8238908:	e0bff017 	ldw	r2,-64(fp)
 823890c:	10800117 	ldw	r2,4(r2)
 8238910:	10800917 	ldw	r2,36(r2)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 8238914:	10800058 	cmpnei	r2,r2,1
 8238918:	10002f1e 	bne	r2,zero,82389d8 <tcp_output+0x67c>
       (sendm->pkt->inuse == 1) &&
       (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) == 0) && 
 823891c:	e0bff017 	ldw	r2,-64(fp)
 8238920:	10800317 	ldw	r2,12(r2)
 8238924:	1007883a 	mov	r3,r2
 8238928:	e0bff017 	ldw	r2,-64(fp)
 823892c:	10800417 	ldw	r2,16(r2)
 8238930:	1885c83a 	sub	r2,r3,r2
 8238934:	108000cc 	andi	r2,r2,3

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
       (sendm->pkt->inuse == 1) &&
 8238938:	1000271e 	bne	r2,zero,82389d8 <tcp_output+0x67c>
       (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) == 0) && 
 823893c:	e0bfee17 	ldw	r2,-72(fp)
 8238940:	1000251e 	bne	r2,zero,82389d8 <tcp_output+0x67c>
       (optlen == 0))
   {
      /* get an empty mbuf to "clone" the data */
      m = m_getnbuf(MT_TXDATA, 0);
 8238944:	000b883a 	mov	r5,zero
 8238948:	01000084 	movi	r4,2
 823894c:	822e4040 	call	822e404 <m_getnbuf>
 8238950:	e0bfed15 	stw	r2,-76(fp)
      if (!m)
 8238954:	e0bfed17 	ldw	r2,-76(fp)
 8238958:	1000031e 	bne	r2,zero,8238968 <tcp_output+0x60c>
      {
         EXIT_CRIT_SECTION(tp);
 823895c:	822d8280 	call	822d828 <irq_Unmask>
         return (ENOBUFS);
 8238960:	00801a44 	movi	r2,105
 8238964:	00027906 	br	823934c <tcp_output+0xff0>
      }
      m->pkt = sendm->pkt; /* copy packet location in new mbuf */
 8238968:	e0bff017 	ldw	r2,-64(fp)
 823896c:	10c00117 	ldw	r3,4(r2)
 8238970:	e0bfed17 	ldw	r2,-76(fp)
 8238974:	10c00115 	stw	r3,4(r2)
      m->pkt->inuse++;     /* bump packet's use count */
 8238978:	e0bfed17 	ldw	r2,-76(fp)
 823897c:	10800117 	ldw	r2,4(r2)
 8238980:	10c00917 	ldw	r3,36(r2)
 8238984:	18c00044 	addi	r3,r3,1
 8238988:	10c00915 	stw	r3,36(r2)
      m->m_base = sendm->m_base; /* clone mbuf members */
 823898c:	e0bff017 	ldw	r2,-64(fp)
 8238990:	10c00417 	ldw	r3,16(r2)
 8238994:	e0bfed17 	ldw	r2,-76(fp)
 8238998:	10c00415 	stw	r3,16(r2)
      m->m_memsz = sendm->m_memsz;
 823899c:	e0bff017 	ldw	r2,-64(fp)
 82389a0:	10c00517 	ldw	r3,20(r2)
 82389a4:	e0bfed17 	ldw	r2,-76(fp)
 82389a8:	10c00515 	stw	r3,20(r2)
      m->m_len = len + TCPIPHDRSZ;  /* adjust clone for header */
 82389ac:	e0bfea17 	ldw	r2,-88(fp)
 82389b0:	10800a04 	addi	r2,r2,40
 82389b4:	1007883a 	mov	r3,r2
 82389b8:	e0bfed17 	ldw	r2,-76(fp)
 82389bc:	10c00215 	stw	r3,8(r2)
      m->m_data = sendm->m_data - TCPIPHDRSZ;
 82389c0:	e0bff017 	ldw	r2,-64(fp)
 82389c4:	10800317 	ldw	r2,12(r2)
 82389c8:	10fff604 	addi	r3,r2,-40
 82389cc:	e0bfed17 	ldw	r2,-76(fp)
 82389d0:	10c00315 	stw	r3,12(r2)
 82389d4:	00002706 	br	8238a74 <tcp_output+0x718>
   {
      /* Grab a header mbuf, attaching a copy of data to be 
       * transmitted, and initialize the header from 
       * the template for sends on this connection.
       */
      m = m_getwithdata (MT_HEADER, IFNETHDR_SIZE + TCPIPHDRSZ);
 82389d8:	d0a08117 	ldw	r2,-32252(gp)
 82389dc:	10800a04 	addi	r2,r2,40
 82389e0:	100b883a 	mov	r5,r2
 82389e4:	010000c4 	movi	r4,3
 82389e8:	822e4040 	call	822e404 <m_getnbuf>
 82389ec:	e0bfed15 	stw	r2,-76(fp)
      if (m ==(struct mbuf *)NULL)
 82389f0:	e0bfed17 	ldw	r2,-76(fp)
 82389f4:	1000031e 	bne	r2,zero,8238a04 <tcp_output+0x6a8>
      {
         EXIT_CRIT_SECTION(tp);
 82389f8:	822d8280 	call	822d828 <irq_Unmask>
         return ENOBUFS;
 82389fc:	00801a44 	movi	r2,105
 8238a00:	00025206 	br	823934c <tcp_output+0xff0>
      }

      m->m_len = TCPIPHDRSZ;
 8238a04:	e0bfed17 	ldw	r2,-76(fp)
 8238a08:	00c00a04 	movi	r3,40
 8238a0c:	10c00215 	stw	r3,8(r2)
      m->m_data += IFNETHDR_SIZE;/* Move this to sizeof tcpip hdr leave*/
 8238a10:	e0bfed17 	ldw	r2,-76(fp)
 8238a14:	10800317 	ldw	r2,12(r2)
 8238a18:	d0e08117 	ldw	r3,-32252(gp)
 8238a1c:	10c7883a 	add	r3,r2,r3
 8238a20:	e0bfed17 	ldw	r2,-76(fp)
 8238a24:	10c00315 	stw	r3,12(r2)
      /* 14 bytes for ethernet header      */

      if (len) /* attach any data to send */
 8238a28:	e0bfea17 	ldw	r2,-88(fp)
 8238a2c:	10001126 	beq	r2,zero,8238a74 <tcp_output+0x718>
      {
         m->m_next = m_copy(so->so_snd.sb_mb, off, (int) len);
 8238a30:	e0bff217 	ldw	r2,-56(fp)
 8238a34:	10801817 	ldw	r2,96(r2)
 8238a38:	e1bfea17 	ldw	r6,-88(fp)
 8238a3c:	e17ff417 	ldw	r5,-48(fp)
 8238a40:	1009883a 	mov	r4,r2
 8238a44:	822e6d80 	call	822e6d8 <m_copy>
 8238a48:	1007883a 	mov	r3,r2
 8238a4c:	e0bfed17 	ldw	r2,-76(fp)
 8238a50:	10c00615 	stw	r3,24(r2)
         if (m->m_next == 0)
 8238a54:	e0bfed17 	ldw	r2,-76(fp)
 8238a58:	10800617 	ldw	r2,24(r2)
 8238a5c:	1000051e 	bne	r2,zero,8238a74 <tcp_output+0x718>
         {
            m_freem(m);
 8238a60:	e13fed17 	ldw	r4,-76(fp)
 8238a64:	822e6940 	call	822e694 <m_freem>
            EXIT_CRIT_SECTION(tp);
 8238a68:	822d8280 	call	822d828 <irq_Unmask>
            return ENOBUFS;
 8238a6c:	00801a44 	movi	r2,105
 8238a70:	00023606 	br	823934c <tcp_output+0xff0>
         }
      }
   }
   EXIT_CRIT_SECTION(tp);
 8238a74:	822d8280 	call	822d828 <irq_Unmask>

   if (len) 
 8238a78:	e0bfea17 	ldw	r2,-88(fp)
 8238a7c:	10003726 	beq	r2,zero,8238b5c <tcp_output+0x800>
   {
      if (tp->t_force && len == 1)
 8238a80:	e0bfff17 	ldw	r2,-4(fp)
 8238a84:	10800a83 	ldbu	r2,42(r2)
 8238a88:	10803fcc 	andi	r2,r2,255
 8238a8c:	1080201c 	xori	r2,r2,128
 8238a90:	10bfe004 	addi	r2,r2,-128
 8238a94:	10000b26 	beq	r2,zero,8238ac4 <tcp_output+0x768>
 8238a98:	e0bfea17 	ldw	r2,-88(fp)
 8238a9c:	10800058 	cmpnei	r2,r2,1
 8238aa0:	1000081e 	bne	r2,zero,8238ac4 <tcp_output+0x768>
         tcpstat.tcps_sndprobe++;
 8238aa4:	008209b4 	movhi	r2,2086
 8238aa8:	10b9ad04 	addi	r2,r2,-6476
 8238aac:	10801517 	ldw	r2,84(r2)
 8238ab0:	10c00044 	addi	r3,r2,1
 8238ab4:	008209b4 	movhi	r2,2086
 8238ab8:	10b9ad04 	addi	r2,r2,-6476
 8238abc:	10c01515 	stw	r3,84(r2)
 8238ac0:	00005306 	br	8238c10 <tcp_output+0x8b4>
      else if (SEQ_LT(tp->snd_nxt, tp->snd_max)) 
 8238ac4:	e0bfff17 	ldw	r2,-4(fp)
 8238ac8:	10c00f17 	ldw	r3,60(r2)
 8238acc:	e0bfff17 	ldw	r2,-4(fp)
 8238ad0:	10801a17 	ldw	r2,104(r2)
 8238ad4:	1885c83a 	sub	r2,r3,r2
 8238ad8:	1000100e 	bge	r2,zero,8238b1c <tcp_output+0x7c0>
      {
         tcpstat.tcps_sndrexmitpack++;
 8238adc:	008209b4 	movhi	r2,2086
 8238ae0:	10b9ad04 	addi	r2,r2,-6476
 8238ae4:	10801217 	ldw	r2,72(r2)
 8238ae8:	10c00044 	addi	r3,r2,1
 8238aec:	008209b4 	movhi	r2,2086
 8238af0:	10b9ad04 	addi	r2,r2,-6476
 8238af4:	10c01215 	stw	r3,72(r2)
         tcpstat.tcps_sndrexmitbyte += len;
 8238af8:	008209b4 	movhi	r2,2086
 8238afc:	10b9ad04 	addi	r2,r2,-6476
 8238b00:	10c01317 	ldw	r3,76(r2)
 8238b04:	e0bfea17 	ldw	r2,-88(fp)
 8238b08:	1887883a 	add	r3,r3,r2
 8238b0c:	008209b4 	movhi	r2,2086
 8238b10:	10b9ad04 	addi	r2,r2,-6476
 8238b14:	10c01315 	stw	r3,76(r2)
 8238b18:	00003d06 	br	8238c10 <tcp_output+0x8b4>
         tcpstat.tcps_sackresend++;
#endif
      } 
      else 
      {
         tcpstat.tcps_sndpack++;
 8238b1c:	008209b4 	movhi	r2,2086
 8238b20:	10b9ad04 	addi	r2,r2,-6476
 8238b24:	10801017 	ldw	r2,64(r2)
 8238b28:	10c00044 	addi	r3,r2,1
 8238b2c:	008209b4 	movhi	r2,2086
 8238b30:	10b9ad04 	addi	r2,r2,-6476
 8238b34:	10c01015 	stw	r3,64(r2)
         tcpstat.tcps_sndbyte += len;
 8238b38:	008209b4 	movhi	r2,2086
 8238b3c:	10b9ad04 	addi	r2,r2,-6476
 8238b40:	10c01117 	ldw	r3,68(r2)
 8238b44:	e0bfea17 	ldw	r2,-88(fp)
 8238b48:	1887883a 	add	r3,r3,r2
 8238b4c:	008209b4 	movhi	r2,2086
 8238b50:	10b9ad04 	addi	r2,r2,-6476
 8238b54:	10c01115 	stw	r3,68(r2)
 8238b58:	00002d06 	br	8238c10 <tcp_output+0x8b4>
      }
   }
   else if (tp->t_flags & TF_ACKNOW)
 8238b5c:	e0bfff17 	ldw	r2,-4(fp)
 8238b60:	10800b0b 	ldhu	r2,44(r2)
 8238b64:	10bfffcc 	andi	r2,r2,65535
 8238b68:	1080004c 	andi	r2,r2,1
 8238b6c:	10000826 	beq	r2,zero,8238b90 <tcp_output+0x834>
   {
      tcpstat.tcps_sndacks++;
 8238b70:	008209b4 	movhi	r2,2086
 8238b74:	10b9ad04 	addi	r2,r2,-6476
 8238b78:	10801417 	ldw	r2,80(r2)
 8238b7c:	10c00044 	addi	r3,r2,1
 8238b80:	008209b4 	movhi	r2,2086
 8238b84:	10b9ad04 	addi	r2,r2,-6476
 8238b88:	10c01415 	stw	r3,80(r2)
 8238b8c:	00002006 	br	8238c10 <tcp_output+0x8b4>
   }
   else if (flags & (TH_SYN|TH_FIN|TH_RST))
 8238b90:	e0bfec17 	ldw	r2,-80(fp)
 8238b94:	108001cc 	andi	r2,r2,7
 8238b98:	10000826 	beq	r2,zero,8238bbc <tcp_output+0x860>
      tcpstat.tcps_sndctrl++;
 8238b9c:	008209b4 	movhi	r2,2086
 8238ba0:	10b9ad04 	addi	r2,r2,-6476
 8238ba4:	10801817 	ldw	r2,96(r2)
 8238ba8:	10c00044 	addi	r3,r2,1
 8238bac:	008209b4 	movhi	r2,2086
 8238bb0:	10b9ad04 	addi	r2,r2,-6476
 8238bb4:	10c01815 	stw	r3,96(r2)
 8238bb8:	00001506 	br	8238c10 <tcp_output+0x8b4>
   else if (SEQ_GT(tp->snd_up, tp->snd_una))
 8238bbc:	e0bfff17 	ldw	r2,-4(fp)
 8238bc0:	10c01017 	ldw	r3,64(r2)
 8238bc4:	e0bfff17 	ldw	r2,-4(fp)
 8238bc8:	10800e17 	ldw	r2,56(r2)
 8238bcc:	1885c83a 	sub	r2,r3,r2
 8238bd0:	0080080e 	bge	zero,r2,8238bf4 <tcp_output+0x898>
      tcpstat.tcps_sndurg++;
 8238bd4:	008209b4 	movhi	r2,2086
 8238bd8:	10b9ad04 	addi	r2,r2,-6476
 8238bdc:	10801617 	ldw	r2,88(r2)
 8238be0:	10c00044 	addi	r3,r2,1
 8238be4:	008209b4 	movhi	r2,2086
 8238be8:	10b9ad04 	addi	r2,r2,-6476
 8238bec:	10c01615 	stw	r3,88(r2)
 8238bf0:	00000706 	br	8238c10 <tcp_output+0x8b4>
   else
      tcpstat.tcps_sndwinup++;
 8238bf4:	008209b4 	movhi	r2,2086
 8238bf8:	10b9ad04 	addi	r2,r2,-6476
 8238bfc:	10801717 	ldw	r2,92(r2)
 8238c00:	10c00044 	addi	r3,r2,1
 8238c04:	008209b4 	movhi	r2,2086
 8238c08:	10b9ad04 	addi	r2,r2,-6476
 8238c0c:	10c01715 	stw	r3,92(r2)

   ti = (struct tcpiphdr *)(m->m_data+sizeof(struct ip)-sizeof(struct ipovly));
 8238c10:	e0bfed17 	ldw	r2,-76(fp)
 8238c14:	10800317 	ldw	r2,12(r2)
 8238c18:	e0bff515 	stw	r2,-44(fp)
   if ((char *)ti < m->pkt->nb_buff)
 8238c1c:	e0bfed17 	ldw	r2,-76(fp)
 8238c20:	10800117 	ldw	r2,4(r2)
 8238c24:	10800117 	ldw	r2,4(r2)
 8238c28:	e0fff517 	ldw	r3,-44(fp)
 8238c2c:	1880032e 	bgeu	r3,r2,8238c3c <tcp_output+0x8e0>
   {
      panic("tcp_out- packet ptr underflow\n");
 8238c30:	01020974 	movhi	r4,2085
 8238c34:	2103c404 	addi	r4,r4,3856
 8238c38:	8228ca40 	call	8228ca4 <panic>
   }
   tcp_mbuf = m;        /* flag TCP header mbuf */
 8238c3c:	e0bfed17 	ldw	r2,-76(fp)
 8238c40:	e0bff615 	stw	r2,-40(fp)
      tcp_mbuf->m_data += sizeof(struct ipovly);
      tcp_mbuf->m_len -= sizeof(struct ipovly);
   }
#endif   /* end IP_V6 */

   if (tp->t_template == 0)
 8238c44:	e0bfff17 	ldw	r2,-4(fp)
 8238c48:	10800c17 	ldw	r2,48(r2)
 8238c4c:	1000031e 	bne	r2,zero,8238c5c <tcp_output+0x900>
      panic("tcp_output");
 8238c50:	01020974 	movhi	r4,2085
 8238c54:	2103cc04 	addi	r4,r4,3888
 8238c58:	8228ca40 	call	8228ca4 <panic>

   MEMCPY((char*)ti, (char*)tp->t_template, sizeof(struct tcpiphdr));
 8238c5c:	e0bfff17 	ldw	r2,-4(fp)
 8238c60:	10800c17 	ldw	r2,48(r2)
 8238c64:	01800a04 	movi	r6,40
 8238c68:	100b883a 	mov	r5,r2
 8238c6c:	e13ff517 	ldw	r4,-44(fp)
 8238c70:	8202f6c0 	call	8202f6c <memcpy>
   /*
    * Fill in fields, remembering maximum advertised
    * window for use in delaying messages about window sizes.
    * If resending a FIN, be sure not to use a new sequence number.
    */
   if (flags & TH_FIN && tp->t_flags & TF_SENTFIN && 
 8238c74:	e0bfec17 	ldw	r2,-80(fp)
 8238c78:	1080004c 	andi	r2,r2,1
 8238c7c:	10000f26 	beq	r2,zero,8238cbc <tcp_output+0x960>
 8238c80:	e0bfff17 	ldw	r2,-4(fp)
 8238c84:	10800b0b 	ldhu	r2,44(r2)
 8238c88:	10bfffcc 	andi	r2,r2,65535
 8238c8c:	1080040c 	andi	r2,r2,16
 8238c90:	10000a26 	beq	r2,zero,8238cbc <tcp_output+0x960>
       tp->snd_nxt == tp->snd_max)
 8238c94:	e0bfff17 	ldw	r2,-4(fp)
 8238c98:	10c00f17 	ldw	r3,60(r2)
 8238c9c:	e0bfff17 	ldw	r2,-4(fp)
 8238ca0:	10801a17 	ldw	r2,104(r2)
   /*
    * Fill in fields, remembering maximum advertised
    * window for use in delaying messages about window sizes.
    * If resending a FIN, be sure not to use a new sequence number.
    */
   if (flags & TH_FIN && tp->t_flags & TF_SENTFIN && 
 8238ca4:	1880051e 	bne	r3,r2,8238cbc <tcp_output+0x960>
       tp->snd_nxt == tp->snd_max)
   {
      tp->snd_nxt--;
 8238ca8:	e0bfff17 	ldw	r2,-4(fp)
 8238cac:	10800f17 	ldw	r2,60(r2)
 8238cb0:	10ffffc4 	addi	r3,r2,-1
 8238cb4:	e0bfff17 	ldw	r2,-4(fp)
 8238cb8:	10c00f15 	stw	r3,60(r2)
   }

   ti->ti_seq = htonl(tp->snd_nxt);
 8238cbc:	e0bfff17 	ldw	r2,-4(fp)
 8238cc0:	10800f17 	ldw	r2,60(r2)
 8238cc4:	1006d63a 	srli	r3,r2,24
 8238cc8:	e0bfff17 	ldw	r2,-4(fp)
 8238ccc:	10800f17 	ldw	r2,60(r2)
 8238cd0:	1004d23a 	srli	r2,r2,8
 8238cd4:	10bfc00c 	andi	r2,r2,65280
 8238cd8:	1886b03a 	or	r3,r3,r2
 8238cdc:	e0bfff17 	ldw	r2,-4(fp)
 8238ce0:	10800f17 	ldw	r2,60(r2)
 8238ce4:	10bfc00c 	andi	r2,r2,65280
 8238ce8:	1004923a 	slli	r2,r2,8
 8238cec:	1886b03a 	or	r3,r3,r2
 8238cf0:	e0bfff17 	ldw	r2,-4(fp)
 8238cf4:	10800f17 	ldw	r2,60(r2)
 8238cf8:	1004963a 	slli	r2,r2,24
 8238cfc:	1886b03a 	or	r3,r3,r2
 8238d00:	e0bff517 	ldw	r2,-44(fp)
 8238d04:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(tp->rcv_nxt);
 8238d08:	e0bfff17 	ldw	r2,-4(fp)
 8238d0c:	10801617 	ldw	r2,88(r2)
 8238d10:	1006d63a 	srli	r3,r2,24
 8238d14:	e0bfff17 	ldw	r2,-4(fp)
 8238d18:	10801617 	ldw	r2,88(r2)
 8238d1c:	1004d23a 	srli	r2,r2,8
 8238d20:	10bfc00c 	andi	r2,r2,65280
 8238d24:	1886b03a 	or	r3,r3,r2
 8238d28:	e0bfff17 	ldw	r2,-4(fp)
 8238d2c:	10801617 	ldw	r2,88(r2)
 8238d30:	10bfc00c 	andi	r2,r2,65280
 8238d34:	1004923a 	slli	r2,r2,8
 8238d38:	1886b03a 	or	r3,r3,r2
 8238d3c:	e0bfff17 	ldw	r2,-4(fp)
 8238d40:	10801617 	ldw	r2,88(r2)
 8238d44:	1004963a 	slli	r2,r2,24
 8238d48:	1886b03a 	or	r3,r3,r2
 8238d4c:	e0bff517 	ldw	r2,-44(fp)
 8238d50:	10c00715 	stw	r3,28(r2)
    * a retransmission, and the original SYN caused PPP to start
    * bringing the interface up, and PPP has got a new IP address
    * via IPCP), update the template and the inpcb with the new 
    * address.
    */
   if (flags & TH_SYN)
 8238d54:	e0bfec17 	ldw	r2,-80(fp)
 8238d58:	1080008c 	andi	r2,r2,2
 8238d5c:	10002426 	beq	r2,zero,8238df0 <tcp_output+0xa94>
   {
      struct inpcb * inp;
      inp = (struct inpcb *)so->so_pcb;
 8238d60:	e0bff217 	ldw	r2,-56(fp)
 8238d64:	10800117 	ldw	r2,4(r2)
 8238d68:	e0bff715 	stw	r2,-36(fp)

      switch(so->so_domain)
 8238d6c:	e0bff217 	ldw	r2,-56(fp)
 8238d70:	10800517 	ldw	r2,20(r2)
 8238d74:	108000a0 	cmpeqi	r2,r2,2
 8238d78:	10001a26 	beq	r2,zero,8238de4 <tcp_output+0xa88>
         }
         }
#endif   /* INCLUDE_PPP */

         /* If this is a SYN (not a SYN/ACK) then set the pmtu */
         if((flags & TH_ACK) == 0)
 8238d7c:	e0bfec17 	ldw	r2,-80(fp)
 8238d80:	1080040c 	andi	r2,r2,16
 8238d84:	1000191e 	bne	r2,zero,8238dec <tcp_output+0xa90>
            inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
            {
               NET ifp;
               /* find iface for route. Pass "src" as nexthop return */
               ifp = iproute(ti->ti_dst.s_addr, &src);
 8238d88:	e0bff517 	ldw	r2,-44(fp)
 8238d8c:	10800417 	ldw	r2,16(r2)
 8238d90:	e0fffe04 	addi	r3,fp,-8
 8238d94:	180b883a 	mov	r5,r3
 8238d98:	1009883a 	mov	r4,r2
 8238d9c:	8240d440 	call	8240d44 <iproute>
 8238da0:	e0bff815 	stw	r2,-32(fp)
               if(ifp)
 8238da4:	e0bff817 	ldw	r2,-32(fp)
 8238da8:	10000926 	beq	r2,zero,8238dd0 <tcp_output+0xa74>
                  inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 8238dac:	e0bff817 	ldw	r2,-32(fp)
 8238db0:	10c00917 	ldw	r3,36(r2)
 8238db4:	e0bff817 	ldw	r2,-32(fp)
 8238db8:	10800817 	ldw	r2,32(r2)
 8238dbc:	10800a04 	addi	r2,r2,40
 8238dc0:	1887c83a 	sub	r3,r3,r2
 8238dc4:	e0bff717 	ldw	r2,-36(fp)
 8238dc8:	10c00615 	stw	r3,24(r2)
               else
                  inp->inp_pmtu = 580;  /* Ugh. */
            }
#endif   /* IP_PMTU */
         }
         break;
 8238dcc:	00000706 	br	8238dec <tcp_output+0xa90>
               /* find iface for route. Pass "src" as nexthop return */
               ifp = iproute(ti->ti_dst.s_addr, &src);
               if(ifp)
                  inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
               else
                  inp->inp_pmtu = 580;  /* Ugh. */
 8238dd0:	e0bff717 	ldw	r2,-36(fp)
 8238dd4:	00c09104 	movi	r3,580
 8238dd8:	10c00615 	stw	r3,24(r2)
            }
#endif   /* IP_PMTU */
         }
         break;
 8238ddc:	0001883a 	nop
 8238de0:	00000206 	br	8238dec <tcp_output+0xa90>
         }
         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();    /* bad domain setting */
 8238de4:	822d5f00 	call	822d5f0 <dtrap>
 8238de8:	00000106 	br	8238df0 <tcp_output+0xa94>
               else
                  inp->inp_pmtu = 580;  /* Ugh. */
            }
#endif   /* IP_PMTU */
         }
         break;
 8238dec:	0001883a 	nop
         dtrap();    /* bad domain setting */
      }
   }

   /* fill in options if any are set */
   if (optlen)
 8238df0:	e0bfee17 	ldw	r2,-72(fp)
 8238df4:	10002b26 	beq	r2,zero,8238ea4 <tcp_output+0xb48>
   {
      struct mbuf * mopt;

      mopt = m_getwithdata(MT_TXDATA, MAXOPTLEN);
 8238df8:	01404004 	movi	r5,256
 8238dfc:	01000084 	movi	r4,2
 8238e00:	822e4040 	call	822e404 <m_getnbuf>
 8238e04:	e0bff915 	stw	r2,-28(fp)
      if (mopt == NULL) 
 8238e08:	e0bff917 	ldw	r2,-28(fp)
 8238e0c:	1000041e 	bne	r2,zero,8238e20 <tcp_output+0xac4>
      {
         m_freem(m);
 8238e10:	e13fed17 	ldw	r4,-76(fp)
 8238e14:	822e6940 	call	822e694 <m_freem>
         return (ENOBUFS);
 8238e18:	00801a44 	movi	r2,105
 8238e1c:	00014b06 	br	823934c <tcp_output+0xff0>
      }

      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
 8238e20:	e0bff617 	ldw	r2,-40(fp)
 8238e24:	10c00617 	ldw	r3,24(r2)
 8238e28:	e0bff917 	ldw	r2,-28(fp)
 8238e2c:	10c00615 	stw	r3,24(r2)
      tcp_mbuf->m_next = mopt;
 8238e30:	e0bff617 	ldw	r2,-40(fp)
 8238e34:	e0fff917 	ldw	r3,-28(fp)
 8238e38:	10c00615 	stw	r3,24(r2)

      /* extend options to aligned address */
      while(optlen & 0x03)
 8238e3c:	00000606 	br	8238e58 <tcp_output+0xafc>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;
 8238e40:	e0bfee17 	ldw	r2,-72(fp)
 8238e44:	10c00044 	addi	r3,r2,1
 8238e48:	e0ffee15 	stw	r3,-72(fp)
 8238e4c:	d0e0b304 	addi	r3,gp,-32052
 8238e50:	10c5883a 	add	r2,r2,r3
 8238e54:	10000005 	stb	zero,0(r2)
      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
      tcp_mbuf->m_next = mopt;

      /* extend options to aligned address */
      while(optlen & 0x03)
 8238e58:	e0bfee17 	ldw	r2,-72(fp)
 8238e5c:	108000cc 	andi	r2,r2,3
 8238e60:	103ff71e 	bne	r2,zero,8238e40 <tcp_output+0xae4>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;

      MEMCPY(mtod(mopt, char *), tcp_optionbuf, optlen);
 8238e64:	e0bff917 	ldw	r2,-28(fp)
 8238e68:	10800317 	ldw	r2,12(r2)
 8238e6c:	e1bfee17 	ldw	r6,-72(fp)
 8238e70:	d160b304 	addi	r5,gp,-32052
 8238e74:	1009883a 	mov	r4,r2
 8238e78:	8202f6c0 	call	8202f6c <memcpy>
      mopt->m_len = optlen;
 8238e7c:	e0bff917 	ldw	r2,-28(fp)
 8238e80:	e0ffee17 	ldw	r3,-72(fp)
 8238e84:	10c00215 	stw	r3,8(r2)
      /* use portable macro to set tcp data offset bits */
      SET_TH_OFF(ti->ti_t, ((sizeof (struct tcphdr) + optlen) >> 2));
 8238e88:	e0bfee17 	ldw	r2,-72(fp)
 8238e8c:	10800504 	addi	r2,r2,20
 8238e90:	1004d0ba 	srli	r2,r2,2
 8238e94:	1004913a 	slli	r2,r2,4
 8238e98:	1007883a 	mov	r3,r2
 8238e9c:	e0bff517 	ldw	r2,-44(fp)
 8238ea0:	10c00805 	stb	r3,32(r2)
   }

   ti->ti_flags = (u_char)flags;
 8238ea4:	e0bfec17 	ldw	r2,-80(fp)
 8238ea8:	1007883a 	mov	r3,r2
 8238eac:	e0bff517 	ldw	r2,-44(fp)
 8238eb0:	10c00845 	stb	r3,33(r2)
   /*
    * Calculate receive window. Don't shrink window,
    * but avoid silly window syndrome.
    */
   if (win < (long)(so->so_rcv.sb_hiwat / 4) && win < (long)tp->t_maxseg)
 8238eb4:	e0bff217 	ldw	r2,-56(fp)
 8238eb8:	10800b17 	ldw	r2,44(r2)
 8238ebc:	1004d0ba 	srli	r2,r2,2
 8238ec0:	1007883a 	mov	r3,r2
 8238ec4:	e0bfeb17 	ldw	r2,-84(fp)
 8238ec8:	10c0060e 	bge	r2,r3,8238ee4 <tcp_output+0xb88>
 8238ecc:	e0bfff17 	ldw	r2,-4(fp)
 8238ed0:	10800a0b 	ldhu	r2,40(r2)
 8238ed4:	10bfffcc 	andi	r2,r2,65535
 8238ed8:	e0ffeb17 	ldw	r3,-84(fp)
 8238edc:	1880010e 	bge	r3,r2,8238ee4 <tcp_output+0xb88>
      win = 0;
 8238ee0:	e03feb15 	stw	zero,-84(fp)
   if (win < (long)(tp->rcv_adv - tp->rcv_nxt))
 8238ee4:	e0bfff17 	ldw	r2,-4(fp)
 8238ee8:	10c01917 	ldw	r3,100(r2)
 8238eec:	e0bfff17 	ldw	r2,-4(fp)
 8238ef0:	10801617 	ldw	r2,88(r2)
 8238ef4:	1885c83a 	sub	r2,r3,r2
 8238ef8:	1007883a 	mov	r3,r2
 8238efc:	e0bfeb17 	ldw	r2,-84(fp)
 8238f00:	10c0060e 	bge	r2,r3,8238f1c <tcp_output+0xbc0>
      win = (long)(tp->rcv_adv - tp->rcv_nxt);
 8238f04:	e0bfff17 	ldw	r2,-4(fp)
 8238f08:	10c01917 	ldw	r3,100(r2)
 8238f0c:	e0bfff17 	ldw	r2,-4(fp)
 8238f10:	10801617 	ldw	r2,88(r2)
 8238f14:	1885c83a 	sub	r2,r3,r2
 8238f18:	e0bfeb15 	stw	r2,-84(fp)

   /* do check for Iniche buffer limits -JB- */
   if (bigfreeq.q_len == 0)   /* If queue length is 0, set window to 0 */
 8238f1c:	008209b4 	movhi	r2,2086
 8238f20:	10b8e404 	addi	r2,r2,-7280
 8238f24:	10800217 	ldw	r2,8(r2)
 8238f28:	1000021e 	bne	r2,zero,8238f34 <tcp_output+0xbd8>
   {
      win = 0;
 8238f2c:	e03feb15 	stw	zero,-84(fp)
 8238f30:	00001006 	br	8238f74 <tcp_output+0xc18>
   }
   else if(win > (((long)bigfreeq.q_len - 1) * (long)bigbufsiz))
 8238f34:	008209b4 	movhi	r2,2086
 8238f38:	10b8e404 	addi	r2,r2,-7280
 8238f3c:	10800217 	ldw	r2,8(r2)
 8238f40:	10bfffc4 	addi	r2,r2,-1
 8238f44:	d0e03917 	ldw	r3,-32540(gp)
 8238f48:	10c7383a 	mul	r3,r2,r3
 8238f4c:	e0bfeb17 	ldw	r2,-84(fp)
 8238f50:	1880080e 	bge	r3,r2,8238f74 <tcp_output+0xc18>
   {
      win = ((long)bigfreeq.q_len - 1) * bigbufsiz;
 8238f54:	008209b4 	movhi	r2,2086
 8238f58:	10b8e404 	addi	r2,r2,-7280
 8238f5c:	10800217 	ldw	r2,8(r2)
 8238f60:	10bfffc4 	addi	r2,r2,-1
 8238f64:	1007883a 	mov	r3,r2
 8238f68:	d0a03917 	ldw	r2,-32540(gp)
 8238f6c:	1885383a 	mul	r2,r3,r2
 8238f70:	e0bfeb15 	stw	r2,-84(fp)
      ti->ti_win = htons((u_short)(win >> tp->rcv_wind_scale)); /* apply scale */
   }
   else
#endif /* TCP_WIN_SCALE */
   {
      ti->ti_win = htons((u_short)win);
 8238f74:	e0bfeb17 	ldw	r2,-84(fp)
 8238f78:	10bfffcc 	andi	r2,r2,65535
 8238f7c:	1005d23a 	srai	r2,r2,8
 8238f80:	10803fcc 	andi	r2,r2,255
 8238f84:	1007883a 	mov	r3,r2
 8238f88:	e0bfeb17 	ldw	r2,-84(fp)
 8238f8c:	10bfffcc 	andi	r2,r2,65535
 8238f90:	1004923a 	slli	r2,r2,8
 8238f94:	1884b03a 	or	r2,r3,r2
 8238f98:	1007883a 	mov	r3,r2
 8238f9c:	e0bff517 	ldw	r2,-44(fp)
 8238fa0:	10c0088d 	sth	r3,34(r2)
   }

   if (SEQ_GT(tp->snd_up, tp->snd_nxt)) 
 8238fa4:	e0bfff17 	ldw	r2,-4(fp)
 8238fa8:	10c01017 	ldw	r3,64(r2)
 8238fac:	e0bfff17 	ldw	r2,-4(fp)
 8238fb0:	10800f17 	ldw	r2,60(r2)
 8238fb4:	1885c83a 	sub	r2,r3,r2
 8238fb8:	00801c0e 	bge	zero,r2,823902c <tcp_output+0xcd0>
   {
      ti->ti_urp = htons((u_short)(tp->snd_up - tp->snd_nxt));
 8238fbc:	e0bfff17 	ldw	r2,-4(fp)
 8238fc0:	10801017 	ldw	r2,64(r2)
 8238fc4:	1007883a 	mov	r3,r2
 8238fc8:	e0bfff17 	ldw	r2,-4(fp)
 8238fcc:	10800f17 	ldw	r2,60(r2)
 8238fd0:	1885c83a 	sub	r2,r3,r2
 8238fd4:	10bfffcc 	andi	r2,r2,65535
 8238fd8:	1004d23a 	srli	r2,r2,8
 8238fdc:	1007883a 	mov	r3,r2
 8238fe0:	e0bfff17 	ldw	r2,-4(fp)
 8238fe4:	10801017 	ldw	r2,64(r2)
 8238fe8:	1009883a 	mov	r4,r2
 8238fec:	e0bfff17 	ldw	r2,-4(fp)
 8238ff0:	10800f17 	ldw	r2,60(r2)
 8238ff4:	2085c83a 	sub	r2,r4,r2
 8238ff8:	10bfffcc 	andi	r2,r2,65535
 8238ffc:	1004923a 	slli	r2,r2,8
 8239000:	1884b03a 	or	r2,r3,r2
 8239004:	1007883a 	mov	r3,r2
 8239008:	e0bff517 	ldw	r2,-44(fp)
 823900c:	10c0098d 	sth	r3,38(r2)
      ti->ti_flags |= TH_URG;
 8239010:	e0bff517 	ldw	r2,-44(fp)
 8239014:	10800843 	ldbu	r2,33(r2)
 8239018:	10800814 	ori	r2,r2,32
 823901c:	1007883a 	mov	r3,r2
 8239020:	e0bff517 	ldw	r2,-44(fp)
 8239024:	10c00845 	stb	r3,33(r2)
 8239028:	00000406 	br	823903c <tcp_output+0xce0>
       * If no urgent pointer to send, then we pull
       * the urgent pointer to the left edge of the send window
       * so that it doesn't drift into the send window on sequence
       * number wraparound.
       */
      tp->snd_up = tp->snd_una;        /* drag it along */
 823902c:	e0bfff17 	ldw	r2,-4(fp)
 8239030:	10c00e17 	ldw	r3,56(r2)
 8239034:	e0bfff17 	ldw	r2,-4(fp)
 8239038:	10c01015 	stw	r3,64(r2)
   /*
    * If anything to send and we can send it all, set PUSH.
    * (This will keep happy those implementations which only
    * give data to the user when a buffer fills or a PUSH comes in.)
    */
   if (len && off+len == (int)so->so_snd.sb_cc)
 823903c:	e0bfea17 	ldw	r2,-88(fp)
 8239040:	10000c26 	beq	r2,zero,8239074 <tcp_output+0xd18>
 8239044:	e0fff417 	ldw	r3,-48(fp)
 8239048:	e0bfea17 	ldw	r2,-88(fp)
 823904c:	1885883a 	add	r2,r3,r2
 8239050:	e0fff217 	ldw	r3,-56(fp)
 8239054:	18c01217 	ldw	r3,72(r3)
 8239058:	10c0061e 	bne	r2,r3,8239074 <tcp_output+0xd18>
      ti->ti_flags |= TH_PUSH;
 823905c:	e0bff517 	ldw	r2,-44(fp)
 8239060:	10800843 	ldbu	r2,33(r2)
 8239064:	10800214 	ori	r2,r2,8
 8239068:	1007883a 	mov	r3,r2
 823906c:	e0bff517 	ldw	r2,-44(fp)
 8239070:	10c00845 	stb	r3,33(r2)

   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
 8239074:	e0bfff17 	ldw	r2,-4(fp)
 8239078:	10800a83 	ldbu	r2,42(r2)
 823907c:	10803fcc 	andi	r2,r2,255
 8239080:	1080201c 	xori	r2,r2,128
 8239084:	10bfe004 	addi	r2,r2,-128
 8239088:	10000326 	beq	r2,zero,8239098 <tcp_output+0xd3c>
 823908c:	e0bfff17 	ldw	r2,-4(fp)
 8239090:	10800417 	ldw	r2,16(r2)
 8239094:	10004d1e 	bne	r2,zero,82391cc <tcp_output+0xe70>
   {
      tcp_seq startseq = tp->snd_nxt;
 8239098:	e0bfff17 	ldw	r2,-4(fp)
 823909c:	10800f17 	ldw	r2,60(r2)
 82390a0:	e0bffa15 	stw	r2,-24(fp)

      /*
       * Advance snd_nxt over sequence space of this segment.
       */
      if (flags & TH_SYN)
 82390a4:	e0bfec17 	ldw	r2,-80(fp)
 82390a8:	1080008c 	andi	r2,r2,2
 82390ac:	10000526 	beq	r2,zero,82390c4 <tcp_output+0xd68>
         tp->snd_nxt++;
 82390b0:	e0bfff17 	ldw	r2,-4(fp)
 82390b4:	10800f17 	ldw	r2,60(r2)
 82390b8:	10c00044 	addi	r3,r2,1
 82390bc:	e0bfff17 	ldw	r2,-4(fp)
 82390c0:	10c00f15 	stw	r3,60(r2)

      if (flags & TH_FIN)
 82390c4:	e0bfec17 	ldw	r2,-80(fp)
 82390c8:	1080004c 	andi	r2,r2,1
 82390cc:	10000b26 	beq	r2,zero,82390fc <tcp_output+0xda0>
      {
         tp->snd_nxt++;
 82390d0:	e0bfff17 	ldw	r2,-4(fp)
 82390d4:	10800f17 	ldw	r2,60(r2)
 82390d8:	10c00044 	addi	r3,r2,1
 82390dc:	e0bfff17 	ldw	r2,-4(fp)
 82390e0:	10c00f15 	stw	r3,60(r2)
         tp->t_flags |= TF_SENTFIN;
 82390e4:	e0bfff17 	ldw	r2,-4(fp)
 82390e8:	10800b0b 	ldhu	r2,44(r2)
 82390ec:	10800414 	ori	r2,r2,16
 82390f0:	1007883a 	mov	r3,r2
 82390f4:	e0bfff17 	ldw	r2,-4(fp)
 82390f8:	10c00b0d 	sth	r3,44(r2)
      }
      tp->snd_nxt += len;
 82390fc:	e0bfff17 	ldw	r2,-4(fp)
 8239100:	10c00f17 	ldw	r3,60(r2)
 8239104:	e0bfea17 	ldw	r2,-88(fp)
 8239108:	1887883a 	add	r3,r3,r2
 823910c:	e0bfff17 	ldw	r2,-4(fp)
 8239110:	10c00f15 	stw	r3,60(r2)
      if (SEQ_GT(tp->snd_nxt, tp->snd_max)) 
 8239114:	e0bfff17 	ldw	r2,-4(fp)
 8239118:	10c00f17 	ldw	r3,60(r2)
 823911c:	e0bfff17 	ldw	r2,-4(fp)
 8239120:	10801a17 	ldw	r2,104(r2)
 8239124:	1885c83a 	sub	r2,r3,r2
 8239128:	0080140e 	bge	zero,r2,823917c <tcp_output+0xe20>
      {
         tp->snd_max = tp->snd_nxt;
 823912c:	e0bfff17 	ldw	r2,-4(fp)
 8239130:	10c00f17 	ldw	r3,60(r2)
 8239134:	e0bfff17 	ldw	r2,-4(fp)
 8239138:	10c01a15 	stw	r3,104(r2)
         /*
          * Time this transmission if not a retransmission and
          * not currently timing anything.
          */
         if (tp->t_rttick == 0) 
 823913c:	e0bfff17 	ldw	r2,-4(fp)
 8239140:	10801e17 	ldw	r2,120(r2)
 8239144:	10000d1e 	bne	r2,zero,823917c <tcp_output+0xe20>
         {
            tp->t_rttick = cticks;
 8239148:	d0e0a817 	ldw	r3,-32096(gp)
 823914c:	e0bfff17 	ldw	r2,-4(fp)
 8239150:	10c01e15 	stw	r3,120(r2)
            tp->t_rtseq = startseq;
 8239154:	e0bfff17 	ldw	r2,-4(fp)
 8239158:	e0fffa17 	ldw	r3,-24(fp)
 823915c:	10c01f15 	stw	r3,124(r2)
            tcpstat.tcps_segstimed++;
 8239160:	008209b4 	movhi	r2,2086
 8239164:	10b9ad04 	addi	r2,r2,-6476
 8239168:	10800617 	ldw	r2,24(r2)
 823916c:	10c00044 	addi	r3,r2,1
 8239170:	008209b4 	movhi	r2,2086
 8239174:	10b9ad04 	addi	r2,r2,-6476
 8239178:	10c00615 	stw	r3,24(r2)
       * Initial value for retransmit timer is smoothed
       * round-trip time + 2 * round-trip time variance.
       * Initialize shift counter which is used for backoff
       * of retransmit time.
       */
      if (tp->t_timer[TCPT_REXMT] == 0 &&
 823917c:	e0bfff17 	ldw	r2,-4(fp)
 8239180:	10800317 	ldw	r2,12(r2)
 8239184:	1000201e 	bne	r2,zero,8239208 <tcp_output+0xeac>
          tp->snd_nxt != tp->snd_una) 
 8239188:	e0bfff17 	ldw	r2,-4(fp)
 823918c:	10c00f17 	ldw	r3,60(r2)
 8239190:	e0bfff17 	ldw	r2,-4(fp)
 8239194:	10800e17 	ldw	r2,56(r2)
       * Initial value for retransmit timer is smoothed
       * round-trip time + 2 * round-trip time variance.
       * Initialize shift counter which is used for backoff
       * of retransmit time.
       */
      if (tp->t_timer[TCPT_REXMT] == 0 &&
 8239198:	18801b26 	beq	r3,r2,8239208 <tcp_output+0xeac>
          tp->snd_nxt != tp->snd_una) 
      {
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 823919c:	e0bfff17 	ldw	r2,-4(fp)
 82391a0:	10c00817 	ldw	r3,32(r2)
 82391a4:	e0bfff17 	ldw	r2,-4(fp)
 82391a8:	10c00315 	stw	r3,12(r2)
         if (tp->t_timer[TCPT_PERSIST]) 
 82391ac:	e0bfff17 	ldw	r2,-4(fp)
 82391b0:	10800417 	ldw	r2,16(r2)
 82391b4:	10001426 	beq	r2,zero,8239208 <tcp_output+0xeac>
         {
            tp->t_timer[TCPT_PERSIST] = 0;
 82391b8:	e0bfff17 	ldw	r2,-4(fp)
 82391bc:	10000415 	stw	zero,16(r2)
            tp->t_rxtshift = 0;
 82391c0:	e0bfff17 	ldw	r2,-4(fp)
 82391c4:	10000715 	stw	zero,28(r2)
   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
   {
 82391c8:	00000f06 	br	8239208 <tcp_output+0xeac>
         }
      }
   }
   else
   {
      if (SEQ_GT(tp->snd_nxt + len, tp->snd_max))
 82391cc:	e0bfff17 	ldw	r2,-4(fp)
 82391d0:	10c00f17 	ldw	r3,60(r2)
 82391d4:	e0bfea17 	ldw	r2,-88(fp)
 82391d8:	1887883a 	add	r3,r3,r2
 82391dc:	e0bfff17 	ldw	r2,-4(fp)
 82391e0:	10801a17 	ldw	r2,104(r2)
 82391e4:	1885c83a 	sub	r2,r3,r2
 82391e8:	0080080e 	bge	zero,r2,823920c <tcp_output+0xeb0>
         tp->snd_max = tp->snd_nxt + len;
 82391ec:	e0bfff17 	ldw	r2,-4(fp)
 82391f0:	10c00f17 	ldw	r3,60(r2)
 82391f4:	e0bfea17 	ldw	r2,-88(fp)
 82391f8:	1887883a 	add	r3,r3,r2
 82391fc:	e0bfff17 	ldw	r2,-4(fp)
 8239200:	10c01a15 	stw	r3,104(r2)
 8239204:	00000106 	br	823920c <tcp_output+0xeb0>
   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
   {
 8239208:	0001883a 	nop
   tcp_trace("tcp_output: sending, state %d, tcpcb: %x",
    tp->t_state, tp );
#endif

#ifdef MUTE_WARNS
   error = 0;
 823920c:	e03ffb15 	stw	zero,-20(fp)
   if(so->so_domain != AF_INET6)
#endif   /* IP_V6 */
   {
      struct ip * pip;
   
      pip = mtod(m, struct ip *);
 8239210:	e0bfed17 	ldw	r2,-76(fp)
 8239214:	10800317 	ldw	r2,12(r2)
 8239218:	e0bffc15 	stw	r2,-16(fp)
      /* Fill in IP length and send to IP level. */
      pip->ip_len = (u_short)(TCPIPHDRSZ + optlen + len);
 823921c:	e0bfee17 	ldw	r2,-72(fp)
 8239220:	1007883a 	mov	r3,r2
 8239224:	e0bfea17 	ldw	r2,-88(fp)
 8239228:	1885883a 	add	r2,r3,r2
 823922c:	10800a04 	addi	r2,r2,40
 8239230:	1007883a 	mov	r3,r2
 8239234:	e0bffc17 	ldw	r2,-16(fp)
 8239238:	10c0008d 	sth	r3,2(r2)
      error = ip_output(m, so->so_optsPack);
 823923c:	e0bff217 	ldw	r2,-56(fp)
 8239240:	10801f17 	ldw	r2,124(r2)
 8239244:	100b883a 	mov	r5,r2
 8239248:	e13fed17 	ldw	r4,-76(fp)
 823924c:	822f0300 	call	822f030 <ip_output>
 8239250:	e0bffb15 	stw	r2,-20(fp)
                    (sizeof(struct ipv6) + sizeof(struct tcphdr) + optlen + len),
                    (struct   ip_socopts *)0);          
   }
#endif   /* IP_V6 */

   if (error)
 8239254:	e0bffb17 	ldw	r2,-20(fp)
 8239258:	10001326 	beq	r2,zero,82392a8 <tcp_output+0xf4c>
   {
      if (error == ENOBUFS)   /* ip_output needed a copy buffer it couldn't get */
 823925c:	e0bffb17 	ldw	r2,-20(fp)
 8239260:	10801a58 	cmpnei	r2,r2,105
 8239264:	10000e1e 	bne	r2,zero,82392a0 <tcp_output+0xf44>
      {
         if (m->m_type == MT_FREE)  /* ip_output() probably freed first mbuf */
 8239268:	e0bfed17 	ldw	r2,-76(fp)
 823926c:	10800817 	ldw	r2,32(r2)
 8239270:	1000031e 	bne	r2,zero,8239280 <tcp_output+0xf24>
            m = m->m_next;
 8239274:	e0bfed17 	ldw	r2,-76(fp)
 8239278:	10800617 	ldw	r2,24(r2)
 823927c:	e0bfed15 	stw	r2,-76(fp)
         m_freem(m); /* free the mbuf chain */
 8239280:	e13fed17 	ldw	r4,-76(fp)
 8239284:	822e6940 	call	822e694 <m_freem>
         tcp_quench(tp->t_inpcb);
 8239288:	e0bfff17 	ldw	r2,-4(fp)
 823928c:	10800d17 	ldw	r2,52(r2)
 8239290:	1009883a 	mov	r4,r2
 8239294:	8239d2c0 	call	8239d2c <tcp_quench>
         return (error);
 8239298:	e0bffb17 	ldw	r2,-20(fp)
 823929c:	00002b06 	br	823934c <tcp_output+0xff0>
      }
      return (error);
 82392a0:	e0bffb17 	ldw	r2,-20(fp)
 82392a4:	00002906 	br	823934c <tcp_output+0xff0>

   /*
    * Data sent (as far as we can tell).
    */

   TCP_MIB_INC(tcpOutSegs);   /* keep MIB stats */
 82392a8:	008209b4 	movhi	r2,2086
 82392ac:	10b97f04 	addi	r2,r2,-6660
 82392b0:	10800a17 	ldw	r2,40(r2)
 82392b4:	10c00044 	addi	r3,r2,1
 82392b8:	008209b4 	movhi	r2,2086
 82392bc:	10b97f04 	addi	r2,r2,-6660
 82392c0:	10c00a15 	stw	r3,40(r2)
   tcpstat.tcps_sndtotal++;
 82392c4:	008209b4 	movhi	r2,2086
 82392c8:	10b9ad04 	addi	r2,r2,-6476
 82392cc:	10800f17 	ldw	r2,60(r2)
 82392d0:	10c00044 	addi	r3,r2,1
 82392d4:	008209b4 	movhi	r2,2086
 82392d8:	10b9ad04 	addi	r2,r2,-6476
 82392dc:	10c00f15 	stw	r3,60(r2)
   /*
    * If this advertises a larger window than any other segment,
    * then remember the size of the advertised window.
    * Any pending ACK has now been sent.
    */
   if (win > 0 && SEQ_GT(tp->rcv_nxt+win, tp->rcv_adv))
 82392e0:	e0bfeb17 	ldw	r2,-84(fp)
 82392e4:	00800e0e 	bge	zero,r2,8239320 <tcp_output+0xfc4>
 82392e8:	e0bfff17 	ldw	r2,-4(fp)
 82392ec:	10c01617 	ldw	r3,88(r2)
 82392f0:	e0bfeb17 	ldw	r2,-84(fp)
 82392f4:	1887883a 	add	r3,r3,r2
 82392f8:	e0bfff17 	ldw	r2,-4(fp)
 82392fc:	10801917 	ldw	r2,100(r2)
 8239300:	1885c83a 	sub	r2,r3,r2
 8239304:	0080060e 	bge	zero,r2,8239320 <tcp_output+0xfc4>
      tp->rcv_adv = tp->rcv_nxt + (unsigned)win;
 8239308:	e0bfff17 	ldw	r2,-4(fp)
 823930c:	10c01617 	ldw	r3,88(r2)
 8239310:	e0bfeb17 	ldw	r2,-84(fp)
 8239314:	1887883a 	add	r3,r3,r2
 8239318:	e0bfff17 	ldw	r2,-4(fp)
 823931c:	10c01915 	stw	r3,100(r2)
   tp->t_flags &= ~(TF_ACKNOW|TF_SACKNOW|TF_DELACK);
 8239320:	e0bfff17 	ldw	r2,-4(fp)
 8239324:	10c00b0b 	ldhu	r3,44(r2)
 8239328:	00bfef04 	movi	r2,-68
 823932c:	1884703a 	and	r2,r3,r2
 8239330:	1007883a 	mov	r3,r2
 8239334:	e0bfff17 	ldw	r2,-4(fp)
 8239338:	10c00b0d 	sth	r3,44(r2)
   if (sendalot)
 823933c:	e0bfef17 	ldw	r2,-68(fp)
 8239340:	10000126 	beq	r2,zero,8239348 <tcp_output+0xfec>
      goto again;
 8239344:	003c1606 	br	82383a0 <tcp_output+0x44>
   return (0);
 8239348:	0005883a 	mov	r2,zero
}
 823934c:	e037883a 	mov	sp,fp
 8239350:	dfc00117 	ldw	ra,4(sp)
 8239354:	df000017 	ldw	fp,0(sp)
 8239358:	dec00204 	addi	sp,sp,8
 823935c:	f800283a 	ret

08239360 <tcp_setpersist>:
 * RETURNS: NA
 */

void
tcp_setpersist(struct tcpcb * tp)
{
 8239360:	defffc04 	addi	sp,sp,-16
 8239364:	dfc00315 	stw	ra,12(sp)
 8239368:	df000215 	stw	fp,8(sp)
 823936c:	df000204 	addi	fp,sp,8
 8239370:	e13fff15 	stw	r4,-4(fp)
   int   t;

   t = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 8239374:	e0bfff17 	ldw	r2,-4(fp)
 8239378:	10802017 	ldw	r2,128(r2)
 823937c:	1007d0ba 	srai	r3,r2,2
 8239380:	e0bfff17 	ldw	r2,-4(fp)
 8239384:	10802117 	ldw	r2,132(r2)
 8239388:	1885883a 	add	r2,r3,r2
 823938c:	1005d07a 	srai	r2,r2,1
 8239390:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_timer[TCPT_REXMT])
 8239394:	e0bfff17 	ldw	r2,-4(fp)
 8239398:	10800317 	ldw	r2,12(r2)
 823939c:	10000326 	beq	r2,zero,82393ac <tcp_setpersist+0x4c>
      panic("tcp_output REXMT");
 82393a0:	01020974 	movhi	r4,2085
 82393a4:	2103cf04 	addi	r4,r4,3900
 82393a8:	8228ca40 	call	8228ca4 <panic>
   /*
    * Start/restart persistance timer.
    */
   TCPT_RANGESET(tp->t_timer[TCPT_PERSIST],
 82393ac:	e0bffe17 	ldw	r2,-8(fp)
 82393b0:	1009883a 	mov	r4,r2
 82393b4:	e0bfff17 	ldw	r2,-4(fp)
 82393b8:	10c00717 	ldw	r3,28(r2)
 82393bc:	00820974 	movhi	r2,2085
 82393c0:	108ee7c4 	addi	r2,r2,15263
 82393c4:	10c5883a 	add	r2,r2,r3
 82393c8:	10800003 	ldbu	r2,0(r2)
 82393cc:	10803fcc 	andi	r2,r2,255
 82393d0:	2085383a 	mul	r2,r4,r2
 82393d4:	10ffffcc 	andi	r3,r2,65535
 82393d8:	18e0001c 	xori	r3,r3,32768
 82393dc:	18e00004 	addi	r3,r3,-32768
 82393e0:	e0bfff17 	ldw	r2,-4(fp)
 82393e4:	10c00415 	stw	r3,16(r2)
 82393e8:	e0bfff17 	ldw	r2,-4(fp)
 82393ec:	10800417 	ldw	r2,16(r2)
 82393f0:	10800288 	cmpgei	r2,r2,10
 82393f4:	1000041e 	bne	r2,zero,8239408 <tcp_setpersist+0xa8>
 82393f8:	e0bfff17 	ldw	r2,-4(fp)
 82393fc:	00c00284 	movi	r3,10
 8239400:	10c00415 	stw	r3,16(r2)
 8239404:	00000706 	br	8239424 <tcp_setpersist+0xc4>
 8239408:	e0bfff17 	ldw	r2,-4(fp)
 823940c:	10800417 	ldw	r2,16(r2)
 8239410:	10801e50 	cmplti	r2,r2,121
 8239414:	1000031e 	bne	r2,zero,8239424 <tcp_setpersist+0xc4>
 8239418:	e0bfff17 	ldw	r2,-4(fp)
 823941c:	00c01e04 	movi	r3,120
 8239420:	10c00415 	stw	r3,16(r2)
    t * tcp_backoff[tp->t_rxtshift],
    TCPTV_PERSMIN, TCPTV_PERSMAX);
   if (tp->t_rxtshift < TCP_MAXRXTSHIFT)
 8239424:	e0bfff17 	ldw	r2,-4(fp)
 8239428:	10800717 	ldw	r2,28(r2)
 823942c:	10800308 	cmpgei	r2,r2,12
 8239430:	1000051e 	bne	r2,zero,8239448 <tcp_setpersist+0xe8>
      tp->t_rxtshift++;
 8239434:	e0bfff17 	ldw	r2,-4(fp)
 8239438:	10800717 	ldw	r2,28(r2)
 823943c:	10c00044 	addi	r3,r2,1
 8239440:	e0bfff17 	ldw	r2,-4(fp)
 8239444:	10c00715 	stw	r3,28(r2)

}
 8239448:	0001883a 	nop
 823944c:	e037883a 	mov	sp,fp
 8239450:	dfc00117 	ldw	ra,4(sp)
 8239454:	df000017 	ldw	fp,0(sp)
 8239458:	dec00204 	addi	sp,sp,8
 823945c:	f800283a 	ret

08239460 <bld_options>:
 * RETURNS: length of option data added to buffer
 */

static int
bld_options(struct tcpcb * tp, u_char * cp, int flags, struct socket * so)
{
 8239460:	defff804 	addi	sp,sp,-32
 8239464:	dfc00715 	stw	ra,28(sp)
 8239468:	df000615 	stw	fp,24(sp)
 823946c:	df000604 	addi	fp,sp,24
 8239470:	e13ffc15 	stw	r4,-16(fp)
 8239474:	e17ffd15 	stw	r5,-12(fp)
 8239478:	e1bffe15 	stw	r6,-8(fp)
 823947c:	e1ffff15 	stw	r7,-4(fp)
   int      len;
   u_short  mss;

   if(tp->t_flags & TF_NOOPT)    /* no options allowed? */
 8239480:	e0bffc17 	ldw	r2,-16(fp)
 8239484:	10800b0b 	ldhu	r2,44(r2)
 8239488:	10bfffcc 	andi	r2,r2,65535
 823948c:	1080020c 	andi	r2,r2,8
 8239490:	10000226 	beq	r2,zero,823949c <bld_options+0x3c>
      return 0;
 8239494:	0005883a 	mov	r2,zero
 8239498:	00001e06 	br	8239514 <bld_options+0xb4>

   /* Alway put MSS option on SYN packets */
   if (flags & TH_SYN)
 823949c:	e0bffe17 	ldw	r2,-8(fp)
 82394a0:	1080008c 	andi	r2,r2,2
 82394a4:	10001926 	beq	r2,zero,823950c <bld_options+0xac>
   {
      mss   =  (u_short)tcp_mss(so);
 82394a8:	e13fff17 	ldw	r4,-4(fp)
 82394ac:	82382640 	call	8238264 <tcp_mss>
 82394b0:	e0bffb0d 	sth	r2,-20(fp)

      /* always send MSS option on SYN, fill in MSS parm */
      *(cp + 0) = TCPOPT_MAXSEG;
 82394b4:	e0bffd17 	ldw	r2,-12(fp)
 82394b8:	00c00084 	movi	r3,2
 82394bc:	10c00005 	stb	r3,0(r2)
      *(cp + 1) = MSSOPT_LEN;               /* length byte */
 82394c0:	e0bffd17 	ldw	r2,-12(fp)
 82394c4:	10800044 	addi	r2,r2,1
 82394c8:	00c00104 	movi	r3,4
 82394cc:	10c00005 	stb	r3,0(r2)
      *(cp + 2)  = (u_char) ((mss & 0xff00) >> 8);
 82394d0:	e0bffd17 	ldw	r2,-12(fp)
 82394d4:	10800084 	addi	r2,r2,2
 82394d8:	e0fffb0b 	ldhu	r3,-20(fp)
 82394dc:	1806d23a 	srli	r3,r3,8
 82394e0:	10c00005 	stb	r3,0(r2)
      *(cp + 3)  = (u_char) (mss & 0xff);
 82394e4:	e0bffd17 	ldw	r2,-12(fp)
 82394e8:	108000c4 	addi	r2,r2,3
 82394ec:	e0fffb0b 	ldhu	r3,-20(fp)
 82394f0:	10c00005 	stb	r3,0(r2)
      len = 4;
 82394f4:	00800104 	movi	r2,4
 82394f8:	e0bffa15 	stw	r2,-24(fp)
      cp += 4;
 82394fc:	e0bffd17 	ldw	r2,-12(fp)
 8239500:	10800104 	addi	r2,r2,4
 8239504:	e0bffd15 	stw	r2,-12(fp)
 8239508:	00000106 	br	8239510 <bld_options+0xb0>
   }
   else
      len = 0;
 823950c:	e03ffa15 	stw	zero,-24(fp)
      len += 10;
   }
#endif   /* TCP_TIMESTAMP */

   USE_ARG(so);
   return len;
 8239510:	e0bffa17 	ldw	r2,-24(fp)
}
 8239514:	e037883a 	mov	sp,fp
 8239518:	dfc00117 	ldw	ra,4(sp)
 823951c:	df000017 	ldw	fp,0(sp)
 8239520:	dec00204 	addi	sp,sp,8
 8239524:	f800283a 	ret

08239528 <tcp_init>:
 * RETURNS: 
 */

void
tcp_init()
{
 8239528:	deffff04 	addi	sp,sp,-4
 823952c:	df000015 	stw	fp,0(sp)
 8239530:	d839883a 	mov	fp,sp
   tcp_iss = 1;      /* wrong */
 8239534:	00800044 	movi	r2,1
 8239538:	d0a0b515 	stw	r2,-32044(gp)
   tcb.inp_next = tcb.inp_prev = &tcb;
 823953c:	008209b4 	movhi	r2,2086
 8239540:	10b9a204 	addi	r2,r2,-6520
 8239544:	00c209b4 	movhi	r3,2086
 8239548:	18f9a204 	addi	r3,r3,-6520
 823954c:	10c00115 	stw	r3,4(r2)
 8239550:	008209b4 	movhi	r2,2086
 8239554:	10b9a204 	addi	r2,r2,-6520
 8239558:	10c00117 	ldw	r3,4(r2)
 823955c:	008209b4 	movhi	r2,2086
 8239560:	10b9a204 	addi	r2,r2,-6520
 8239564:	10c00015 	stw	r3,0(r2)
}
 8239568:	0001883a 	nop
 823956c:	e037883a 	mov	sp,fp
 8239570:	df000017 	ldw	fp,0(sp)
 8239574:	dec00104 	addi	sp,sp,4
 8239578:	f800283a 	ret

0823957c <tcp_template>:
 * RETURNS: 
 */

struct tcpiphdr * 
tcp_template(struct tcpcb * tp)
{
 823957c:	defffb04 	addi	sp,sp,-20
 8239580:	dfc00415 	stw	ra,16(sp)
 8239584:	df000315 	stw	fp,12(sp)
 8239588:	df000304 	addi	fp,sp,12
 823958c:	e13fff15 	stw	r4,-4(fp)
   struct inpcb * inp   =  tp->t_inpcb;
 8239590:	e0bfff17 	ldw	r2,-4(fp)
 8239594:	10800d17 	ldw	r2,52(r2)
 8239598:	e0bffe15 	stw	r2,-8(fp)
   struct tcpiphdr * n;

   if ((n = tp->t_template) == 0)
 823959c:	e0bfff17 	ldw	r2,-4(fp)
 82395a0:	10800c17 	ldw	r2,48(r2)
 82395a4:	e0bffd15 	stw	r2,-12(fp)
 82395a8:	e0bffd17 	ldw	r2,-12(fp)
 82395ac:	1000071e 	bne	r2,zero,82395cc <tcp_template+0x50>
   {
      n = (struct tcpiphdr *)TPH_ALLOC (sizeof (*n));
 82395b0:	01000a04 	movi	r4,40
 82395b4:	822e1c80 	call	822e1c8 <npalloc>
 82395b8:	e0bffd15 	stw	r2,-12(fp)
      if (n == NULL)
 82395bc:	e0bffd17 	ldw	r2,-12(fp)
 82395c0:	1000021e 	bne	r2,zero,82395cc <tcp_template+0x50>
         return (0);
 82395c4:	0005883a 	mov	r2,zero
 82395c8:	00002906 	br	8239670 <tcp_template+0xf4>
   }
   n->ti_next = n->ti_prev = 0;
 82395cc:	e0bffd17 	ldw	r2,-12(fp)
 82395d0:	10000115 	stw	zero,4(r2)
 82395d4:	e0bffd17 	ldw	r2,-12(fp)
 82395d8:	10c00117 	ldw	r3,4(r2)
 82395dc:	e0bffd17 	ldw	r2,-12(fp)
 82395e0:	10c00015 	stw	r3,0(r2)
   n->ti_len = htons(sizeof (struct tcpiphdr) - sizeof (struct ip));
 82395e4:	e0bffd17 	ldw	r2,-12(fp)
 82395e8:	00c50004 	movi	r3,5120
 82395ec:	10c0028d 	sth	r3,10(r2)
   n->ti_src = inp->inp_laddr;
 82395f0:	e0bffd17 	ldw	r2,-12(fp)
 82395f4:	e0fffe17 	ldw	r3,-8(fp)
 82395f8:	18c00417 	ldw	r3,16(r3)
 82395fc:	10c00315 	stw	r3,12(r2)
   n->ti_dst = inp->inp_faddr;
 8239600:	e0bffd17 	ldw	r2,-12(fp)
 8239604:	e0fffe17 	ldw	r3,-8(fp)
 8239608:	18c00317 	ldw	r3,12(r3)
 823960c:	10c00415 	stw	r3,16(r2)
   n->ti_sport = inp->inp_lport;
 8239610:	e0bffe17 	ldw	r2,-8(fp)
 8239614:	10c0078b 	ldhu	r3,30(r2)
 8239618:	e0bffd17 	ldw	r2,-12(fp)
 823961c:	10c0050d 	sth	r3,20(r2)
   n->ti_dport = inp->inp_fport;
 8239620:	e0bffe17 	ldw	r2,-8(fp)
 8239624:	10c0070b 	ldhu	r3,28(r2)
 8239628:	e0bffd17 	ldw	r2,-12(fp)
 823962c:	10c0058d 	sth	r3,22(r2)
   n->ti_seq = 0;
 8239630:	e0bffd17 	ldw	r2,-12(fp)
 8239634:	10000615 	stw	zero,24(r2)
   n->ti_ack = 0;
 8239638:	e0bffd17 	ldw	r2,-12(fp)
 823963c:	10000715 	stw	zero,28(r2)
   n->ti_t.th_doff = (5 << 4);   /* NetPort */
 8239640:	e0bffd17 	ldw	r2,-12(fp)
 8239644:	00c01404 	movi	r3,80
 8239648:	10c00805 	stb	r3,32(r2)
   n->ti_flags = 0;
 823964c:	e0bffd17 	ldw	r2,-12(fp)
 8239650:	10000845 	stb	zero,33(r2)
   n->ti_win = 0;
 8239654:	e0bffd17 	ldw	r2,-12(fp)
 8239658:	1000088d 	sth	zero,34(r2)
   n->ti_sum = 0;
 823965c:	e0bffd17 	ldw	r2,-12(fp)
 8239660:	1000090d 	sth	zero,36(r2)
   n->ti_urp = 0;
 8239664:	e0bffd17 	ldw	r2,-12(fp)
 8239668:	1000098d 	sth	zero,38(r2)
   return (n);
 823966c:	e0bffd17 	ldw	r2,-12(fp)
}
 8239670:	e037883a 	mov	sp,fp
 8239674:	dfc00117 	ldw	ra,4(sp)
 8239678:	df000017 	ldw	fp,0(sp)
 823967c:	dec00204 	addi	sp,sp,8
 8239680:	f800283a 	ret

08239684 <tcp_respond>:
   struct tcpiphdr * ti,
   tcp_seq  ack,
   tcp_seq  seq,
   int   flags,
   struct mbuf *  ti_mbuf)
{
 8239684:	defff204 	addi	sp,sp,-56
 8239688:	dfc00d15 	stw	ra,52(sp)
 823968c:	df000c15 	stw	fp,48(sp)
 8239690:	df000c04 	addi	fp,sp,48
 8239694:	e13ffc15 	stw	r4,-16(fp)
 8239698:	e17ffd15 	stw	r5,-12(fp)
 823969c:	e1bffe15 	stw	r6,-8(fp)
 82396a0:	e1ffff15 	stw	r7,-4(fp)
   int      tlen;       /* tcp data len - 0 or 1 */
   int      domain;     /* AF_INET or AF_INET6 */
   int      win = 0;    /* window to use in sent packet */
 82396a4:	e03ff615 	stw	zero,-40(fp)
   struct mbuf *  m;    /* mbuf to send */
   struct tcpiphdr * tmp_thdr;   /* scratch */

   if (tp)
 82396a8:	e0bffc17 	ldw	r2,-16(fp)
 82396ac:	10001726 	beq	r2,zero,823970c <tcp_respond+0x88>
      win = (int)sbspace(&tp->t_inpcb->inp_socket->so_rcv);
 82396b0:	e0bffc17 	ldw	r2,-16(fp)
 82396b4:	10800d17 	ldw	r2,52(r2)
 82396b8:	10800817 	ldw	r2,32(r2)
 82396bc:	10800b17 	ldw	r2,44(r2)
 82396c0:	1007883a 	mov	r3,r2
 82396c4:	e0bffc17 	ldw	r2,-16(fp)
 82396c8:	10800d17 	ldw	r2,52(r2)
 82396cc:	10800817 	ldw	r2,32(r2)
 82396d0:	10800a17 	ldw	r2,40(r2)
 82396d4:	1885c83a 	sub	r2,r3,r2
 82396d8:	10000a16 	blt	r2,zero,8239704 <tcp_respond+0x80>
 82396dc:	e0bffc17 	ldw	r2,-16(fp)
 82396e0:	10800d17 	ldw	r2,52(r2)
 82396e4:	10800817 	ldw	r2,32(r2)
 82396e8:	10c00b17 	ldw	r3,44(r2)
 82396ec:	e0bffc17 	ldw	r2,-16(fp)
 82396f0:	10800d17 	ldw	r2,52(r2)
 82396f4:	10800817 	ldw	r2,32(r2)
 82396f8:	10800a17 	ldw	r2,40(r2)
 82396fc:	1885c83a 	sub	r2,r3,r2
 8239700:	00000106 	br	8239708 <tcp_respond+0x84>
 8239704:	0005883a 	mov	r2,zero
 8239708:	e0bff615 	stw	r2,-40(fp)

   /* Figure out of we can recycle the passed buffer or if we need a 
    * new one. Construct the easy parts of the the TCP and IP headers.
    */
   if (flags == 0)   /* sending keepalive from timer */
 823970c:	e0800217 	ldw	r2,8(fp)
 8239710:	1000261e 	bne	r2,zero,82397ac <tcp_respond+0x128>
   {
      /* no flags == need a new buffer */
      m = m_getwithdata (MT_HEADER, 64);
 8239714:	01401004 	movi	r5,64
 8239718:	010000c4 	movi	r4,3
 823971c:	822e4040 	call	822e404 <m_getnbuf>
 8239720:	e0bff715 	stw	r2,-36(fp)
      if (m == NULL)
 8239724:	e0bff717 	ldw	r2,-36(fp)
 8239728:	1000d026 	beq	r2,zero,8239a6c <tcp_respond+0x3e8>
         return;
      tlen = 1;   /* Keepalives have one byte of data */
 823972c:	00800044 	movi	r2,1
 8239730:	e0bff415 	stw	r2,-48(fp)
      m->m_len = TCPIPHDRSZ + tlen;
 8239734:	e0bff417 	ldw	r2,-48(fp)
 8239738:	10800a04 	addi	r2,r2,40
 823973c:	1007883a 	mov	r3,r2
 8239740:	e0bff717 	ldw	r2,-36(fp)
 8239744:	10c00215 	stw	r3,8(r2)
      /*
       * Copy template contents into the mbuf and set ti to point
       * to the header structure in the mbuf.
       */
      tmp_thdr = (struct tcpiphdr *)((char *)m->m_data+sizeof(struct ip)
 8239748:	e0bff717 	ldw	r2,-36(fp)
 823974c:	10800317 	ldw	r2,12(r2)
 8239750:	e0bff815 	stw	r2,-32(fp)
         - sizeof(struct ipovly));
      if ((char *)tmp_thdr < m->pkt->nb_buff)
 8239754:	e0bff717 	ldw	r2,-36(fp)
 8239758:	10800117 	ldw	r2,4(r2)
 823975c:	10800117 	ldw	r2,4(r2)
 8239760:	e0fff817 	ldw	r3,-32(fp)
 8239764:	1880032e 	bgeu	r3,r2,8239774 <tcp_respond+0xf0>
      {
         panic("tcp_respond- packet ptr underflow\n");
 8239768:	01020974 	movhi	r4,2085
 823976c:	2103d404 	addi	r4,r4,3920
 8239770:	8228ca40 	call	8228ca4 <panic>
      }
      MEMCPY(tmp_thdr, ti, sizeof(struct tcpiphdr));
 8239774:	01800a04 	movi	r6,40
 8239778:	e17ffd17 	ldw	r5,-12(fp)
 823977c:	e13ff817 	ldw	r4,-32(fp)
 8239780:	8202f6c0 	call	8202f6c <memcpy>
      ti = tmp_thdr;
 8239784:	e0bff817 	ldw	r2,-32(fp)
 8239788:	e0bffd15 	stw	r2,-12(fp)
      flags = TH_ACK;
 823978c:	00800404 	movi	r2,16
 8239790:	e0800215 	stw	r2,8(fp)
      domain = tp->t_inpcb->inp_socket->so_domain;
 8239794:	e0bffc17 	ldw	r2,-16(fp)
 8239798:	10800d17 	ldw	r2,52(r2)
 823979c:	10800817 	ldw	r2,32(r2)
 82397a0:	10800517 	ldw	r2,20(r2)
 82397a4:	e0bff515 	stw	r2,-44(fp)
 82397a8:	00003b06 	br	8239898 <tcp_respond+0x214>
   }
   else  /* Flag was passed (e.g. reset); recycle passed mbuf */
   {
      m = ti_mbuf;   /*dtom(ti);*/
 82397ac:	e0800317 	ldw	r2,12(fp)
 82397b0:	e0bff715 	stw	r2,-36(fp)
      if(m->pkt->type == IPTP)   /* IPv4 packet */
 82397b4:	e0bff717 	ldw	r2,-36(fp)
 82397b8:	10800117 	ldw	r2,4(r2)
 82397bc:	1080080b 	ldhu	r2,32(r2)
 82397c0:	10bfffcc 	andi	r2,r2,65535
 82397c4:	10800218 	cmpnei	r2,r2,8
 82397c8:	1000031e 	bne	r2,zero,82397d8 <tcp_respond+0x154>
         domain = AF_INET;
 82397cc:	00800084 	movi	r2,2
 82397d0:	e0bff515 	stw	r2,-44(fp)
 82397d4:	00000206 	br	82397e0 <tcp_respond+0x15c>
      else
         domain = AF_INET6;
 82397d8:	008000c4 	movi	r2,3
 82397dc:	e0bff515 	stw	r2,-44(fp)

      m_freem(m->m_next);
 82397e0:	e0bff717 	ldw	r2,-36(fp)
 82397e4:	10800617 	ldw	r2,24(r2)
 82397e8:	1009883a 	mov	r4,r2
 82397ec:	822e6940 	call	822e694 <m_freem>
      m->m_next = 0;
 82397f0:	e0bff717 	ldw	r2,-36(fp)
 82397f4:	10000615 	stw	zero,24(r2)
      tlen = 0;         /* NO data */
 82397f8:	e03ff415 	stw	zero,-48(fp)
      m->m_len = TCPIPHDRSZ;
 82397fc:	e0bff717 	ldw	r2,-36(fp)
 8239800:	00c00a04 	movi	r3,40
 8239804:	10c00215 	stw	r3,8(r2)
      xchg(ti->ti_dport, ti->ti_sport, u_short);
 8239808:	e0bffd17 	ldw	r2,-12(fp)
 823980c:	1080058b 	ldhu	r2,22(r2)
 8239810:	e0bff90d 	sth	r2,-28(fp)
 8239814:	e0bffd17 	ldw	r2,-12(fp)
 8239818:	10c0050b 	ldhu	r3,20(r2)
 823981c:	e0bffd17 	ldw	r2,-12(fp)
 8239820:	10c0058d 	sth	r3,22(r2)
 8239824:	e0bffd17 	ldw	r2,-12(fp)
 8239828:	e0fff90b 	ldhu	r3,-28(fp)
 823982c:	10c0050d 	sth	r3,20(r2)
      if(m->pkt->type == IPTP)
 8239830:	e0bff717 	ldw	r2,-36(fp)
 8239834:	10800117 	ldw	r2,4(r2)
 8239838:	1080080b 	ldhu	r2,32(r2)
 823983c:	10bfffcc 	andi	r2,r2,65535
 8239840:	10800218 	cmpnei	r2,r2,8
 8239844:	10000a1e 	bne	r2,zero,8239870 <tcp_respond+0x1ec>
         xchg(ti->ti_dst.s_addr, ti->ti_src.s_addr, u_long);
 8239848:	e0bffd17 	ldw	r2,-12(fp)
 823984c:	10800417 	ldw	r2,16(r2)
 8239850:	e0bffa15 	stw	r2,-24(fp)
 8239854:	e0bffd17 	ldw	r2,-12(fp)
 8239858:	10c00317 	ldw	r3,12(r2)
 823985c:	e0bffd17 	ldw	r2,-12(fp)
 8239860:	10c00415 	stw	r3,16(r2)
 8239864:	e0bffd17 	ldw	r2,-12(fp)
 8239868:	e0fffa17 	ldw	r3,-24(fp)
 823986c:	10c00315 	stw	r3,12(r2)
      if (flags & TH_RST)  /* count resets in MIB */
 8239870:	e0800217 	ldw	r2,8(fp)
 8239874:	1080010c 	andi	r2,r2,4
 8239878:	10000726 	beq	r2,zero,8239898 <tcp_respond+0x214>
         TCP_MIB_INC(tcpOutRsts);   /* keep MIB stats */
 823987c:	008209b4 	movhi	r2,2086
 8239880:	10b97f04 	addi	r2,r2,-6660
 8239884:	10800e17 	ldw	r2,56(r2)
 8239888:	10c00044 	addi	r3,r2,1
 823988c:	008209b4 	movhi	r2,2086
 8239890:	10b97f04 	addi	r2,r2,-6660
 8239894:	10c00e15 	stw	r3,56(r2)
   }

   /* finish constructing the TCP header */
   ti->ti_seq = htonl(seq);
 8239898:	e0bfff17 	ldw	r2,-4(fp)
 823989c:	1006d63a 	srli	r3,r2,24
 82398a0:	e0bfff17 	ldw	r2,-4(fp)
 82398a4:	1004d23a 	srli	r2,r2,8
 82398a8:	10bfc00c 	andi	r2,r2,65280
 82398ac:	1886b03a 	or	r3,r3,r2
 82398b0:	e0bfff17 	ldw	r2,-4(fp)
 82398b4:	10bfc00c 	andi	r2,r2,65280
 82398b8:	1004923a 	slli	r2,r2,8
 82398bc:	1886b03a 	or	r3,r3,r2
 82398c0:	e0bfff17 	ldw	r2,-4(fp)
 82398c4:	1004963a 	slli	r2,r2,24
 82398c8:	1886b03a 	or	r3,r3,r2
 82398cc:	e0bffd17 	ldw	r2,-12(fp)
 82398d0:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(ack);
 82398d4:	e0bffe17 	ldw	r2,-8(fp)
 82398d8:	1006d63a 	srli	r3,r2,24
 82398dc:	e0bffe17 	ldw	r2,-8(fp)
 82398e0:	1004d23a 	srli	r2,r2,8
 82398e4:	10bfc00c 	andi	r2,r2,65280
 82398e8:	1886b03a 	or	r3,r3,r2
 82398ec:	e0bffe17 	ldw	r2,-8(fp)
 82398f0:	10bfc00c 	andi	r2,r2,65280
 82398f4:	1004923a 	slli	r2,r2,8
 82398f8:	1886b03a 	or	r3,r3,r2
 82398fc:	e0bffe17 	ldw	r2,-8(fp)
 8239900:	1004963a 	slli	r2,r2,24
 8239904:	1886b03a 	or	r3,r3,r2
 8239908:	e0bffd17 	ldw	r2,-12(fp)
 823990c:	10c00715 	stw	r3,28(r2)
   ti->ti_t.th_doff = 0x50;      /* NetPort: init data offset bits */
 8239910:	e0bffd17 	ldw	r2,-12(fp)
 8239914:	00c01404 	movi	r3,80
 8239918:	10c00805 	stb	r3,32(r2)
   ti->ti_flags = (u_char)flags;
 823991c:	e0800217 	ldw	r2,8(fp)
 8239920:	1007883a 	mov	r3,r2
 8239924:	e0bffd17 	ldw	r2,-12(fp)
 8239928:	10c00845 	stb	r3,33(r2)
   ti->ti_win = htons((u_short)win);
 823992c:	e0bff617 	ldw	r2,-40(fp)
 8239930:	10bfffcc 	andi	r2,r2,65535
 8239934:	1005d23a 	srai	r2,r2,8
 8239938:	10803fcc 	andi	r2,r2,255
 823993c:	1007883a 	mov	r3,r2
 8239940:	e0bff617 	ldw	r2,-40(fp)
 8239944:	10bfffcc 	andi	r2,r2,65535
 8239948:	1004923a 	slli	r2,r2,8
 823994c:	1884b03a 	or	r2,r3,r2
 8239950:	1007883a 	mov	r3,r2
 8239954:	e0bffd17 	ldw	r2,-12(fp)
 8239958:	10c0088d 	sth	r3,34(r2)
   ti->ti_urp = 0;
 823995c:	e0bffd17 	ldw	r2,-12(fp)
 8239960:	1000098d 	sth	zero,38(r2)

   /* Finish constructing IP header and send, based on IP type in use */
   switch(domain)
 8239964:	e0bff517 	ldw	r2,-44(fp)
 8239968:	108000a0 	cmpeqi	r2,r2,2
 823996c:	10003b26 	beq	r2,zero,8239a5c <tcp_respond+0x3d8>
#ifdef IP_V4
      case AF_INET:
      {
         struct ip * pip;

         pip = (struct ip *)((char*)ti+sizeof(struct ipovly)-sizeof(struct ip));
 8239970:	e0bffd17 	ldw	r2,-12(fp)
 8239974:	e0bffb15 	stw	r2,-20(fp)

         pip->ip_len = (unshort)(TCPIPHDRSZ + tlen);
 8239978:	e0bff417 	ldw	r2,-48(fp)
 823997c:	10800a04 	addi	r2,r2,40
 8239980:	1007883a 	mov	r3,r2
 8239984:	e0bffb17 	ldw	r2,-20(fp)
 8239988:	10c0008d 	sth	r3,2(r2)
         /* If our system's max. MAC header size is geater than the size 
          * of the MAC header in the received packet then we need to 
          * adjust the IP header offset to allow for this. Since the packets 
          * are only headers they should always fit.
          */
         if(pip >= (struct ip *)(m->pkt->nb_buff + MaxLnh))
 823998c:	e0bff717 	ldw	r2,-36(fp)
 8239990:	10800117 	ldw	r2,4(r2)
 8239994:	10800117 	ldw	r2,4(r2)
 8239998:	d0e08117 	ldw	r3,-32252(gp)
 823999c:	10c5883a 	add	r2,r2,r3
 82399a0:	e0fffb17 	ldw	r3,-20(fp)
 82399a4:	18800436 	bltu	r3,r2,82399b8 <tcp_respond+0x334>
         {
            m->m_data = (char*)pip; /* headers will fit, just set pointer */
 82399a8:	e0bff717 	ldw	r2,-36(fp)
 82399ac:	e0fffb17 	ldw	r3,-20(fp)
 82399b0:	10c00315 	stw	r3,12(r2)
 82399b4:	00001106 	br	82399fc <tcp_respond+0x378>
         }
         else     /* MAC may not fit, adjust pointer and move headers back */
         {
            m->m_data = m->pkt->nb_prot = m->pkt->nb_buff + MaxLnh;  /* new ptr */
 82399b8:	e0bff717 	ldw	r2,-36(fp)
 82399bc:	10800117 	ldw	r2,4(r2)
 82399c0:	e0fff717 	ldw	r3,-36(fp)
 82399c4:	18c00117 	ldw	r3,4(r3)
 82399c8:	18c00117 	ldw	r3,4(r3)
 82399cc:	d1208117 	ldw	r4,-32252(gp)
 82399d0:	1907883a 	add	r3,r3,r4
 82399d4:	10c00315 	stw	r3,12(r2)
 82399d8:	10c00317 	ldw	r3,12(r2)
 82399dc:	e0bff717 	ldw	r2,-36(fp)
 82399e0:	10c00315 	stw	r3,12(r2)
            MEMMOVE(m->m_data, pip, TCPIPHDRSZ);  /* move back tcp/ip headers */
 82399e4:	e0bff717 	ldw	r2,-36(fp)
 82399e8:	10800317 	ldw	r2,12(r2)
 82399ec:	01800a04 	movi	r6,40
 82399f0:	e17ffb17 	ldw	r5,-20(fp)
 82399f4:	1009883a 	mov	r4,r2
 82399f8:	82030b40 	call	82030b4 <memmove>

         /*
          * In the case of a SYN DOS attack, many RST|ACK replies
          *   have no tp structure and need to be freed.
          */
         if (!tp)
 82399fc:	e0bffc17 	ldw	r2,-16(fp)
 8239a00:	1000031e 	bne	r2,zero,8239a10 <tcp_respond+0x38c>
              m_freem(m);
 8239a04:	e13ff717 	ldw	r4,-36(fp)
 8239a08:	822e6940 	call	822e694 <m_freem>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
		 }

         break;
 8239a0c:	00001506 	br	8239a64 <tcp_respond+0x3e0>
          */
         if (!tp)
              m_freem(m);
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
 8239a10:	e0bffc17 	ldw	r2,-16(fp)
 8239a14:	10800d17 	ldw	r2,52(r2)
 8239a18:	10000c26 	beq	r2,zero,8239a4c <tcp_respond+0x3c8>
 8239a1c:	e0bffc17 	ldw	r2,-16(fp)
 8239a20:	10800d17 	ldw	r2,52(r2)
 8239a24:	10800817 	ldw	r2,32(r2)
 8239a28:	10000826 	beq	r2,zero,8239a4c <tcp_respond+0x3c8>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
 8239a2c:	e0bffc17 	ldw	r2,-16(fp)
 8239a30:	10800d17 	ldw	r2,52(r2)
 8239a34:	10800817 	ldw	r2,32(r2)
 8239a38:	10801f17 	ldw	r2,124(r2)
 8239a3c:	100b883a 	mov	r5,r2
 8239a40:	e13ff717 	ldw	r4,-36(fp)
 8239a44:	822f0300 	call	822f030 <ip_output>
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
		 }

         break;
 8239a48:	00000606 	br	8239a64 <tcp_respond+0x3e0>
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
 8239a4c:	000b883a 	mov	r5,zero
 8239a50:	e13ff717 	ldw	r4,-36(fp)
 8239a54:	822f0300 	call	822f030 <ip_output>
		 }

         break;
 8239a58:	00000206 	br	8239a64 <tcp_respond+0x3e0>

         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();
 8239a5c:	822d5f00 	call	822d5f0 <dtrap>
         break;
 8239a60:	0001883a 	nop
   }
   return;
 8239a64:	0001883a 	nop
 8239a68:	00000106 	br	8239a70 <tcp_respond+0x3ec>
   if (flags == 0)   /* sending keepalive from timer */
   {
      /* no flags == need a new buffer */
      m = m_getwithdata (MT_HEADER, 64);
      if (m == NULL)
         return;
 8239a6c:	0001883a 	nop
      default:
         dtrap();
         break;
   }
   return;
}
 8239a70:	e037883a 	mov	sp,fp
 8239a74:	dfc00117 	ldw	ra,4(sp)
 8239a78:	df000017 	ldw	fp,0(sp)
 8239a7c:	dec00204 	addi	sp,sp,8
 8239a80:	f800283a 	ret

08239a84 <tcp_newtcpcb>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_newtcpcb(struct inpcb * inp)
{
 8239a84:	defffb04 	addi	sp,sp,-20
 8239a88:	dfc00415 	stw	ra,16(sp)
 8239a8c:	df000315 	stw	fp,12(sp)
 8239a90:	df000304 	addi	fp,sp,12
 8239a94:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp;
   short t_time;

   tp = TCB_ALLOC(sizeof (*tp));
 8239a98:	01002504 	movi	r4,148
 8239a9c:	822e1c80 	call	822e1c8 <npalloc>
 8239aa0:	e0bffd15 	stw	r2,-12(fp)
   if (tp == NULL)
 8239aa4:	e0bffd17 	ldw	r2,-12(fp)
 8239aa8:	1000021e 	bne	r2,zero,8239ab4 <tcp_newtcpcb+0x30>
      return (struct tcpcb *)NULL;
 8239aac:	0005883a 	mov	r2,zero
 8239ab0:	00003206 	br	8239b7c <tcp_newtcpcb+0xf8>
   tp->seg_next = tp->seg_prev = (struct tcpiphdr *)tp;
 8239ab4:	e0bffd17 	ldw	r2,-12(fp)
 8239ab8:	e0fffd17 	ldw	r3,-12(fp)
 8239abc:	10c00115 	stw	r3,4(r2)
 8239ac0:	e0bffd17 	ldw	r2,-12(fp)
 8239ac4:	10c00117 	ldw	r3,4(r2)
 8239ac8:	e0bffd17 	ldw	r2,-12(fp)
 8239acc:	10c00015 	stw	r3,0(r2)
   tp->t_maxseg = TCP_MSS;
 8239ad0:	e0bffd17 	ldw	r2,-12(fp)
 8239ad4:	00c16d04 	movi	r3,1460
 8239ad8:	10c00a0d 	sth	r3,40(r2)
   tp->t_flags = 0;        /* sends options! */
 8239adc:	e0bffd17 	ldw	r2,-12(fp)
 8239ae0:	10000b0d 	sth	zero,44(r2)
   tp->t_inpcb = inp;
 8239ae4:	e0bffd17 	ldw	r2,-12(fp)
 8239ae8:	e0ffff17 	ldw	r3,-4(fp)
 8239aec:	10c00d15 	stw	r3,52(r2)
   /*
    * Init srtt to TCPTV_SRTTBASE (0), so we can tell that we have no
    * rtt estimate.  Set rttvar so that srtt + 2 * rttvar gives
    * reasonable initial retransmit time.
    */
   tp->t_srtt = TCPTV_SRTTBASE;
 8239af0:	e0bffd17 	ldw	r2,-12(fp)
 8239af4:	10002015 	stw	zero,128(r2)
   tp->t_rttvar = TCPTV_SRTTDFLT << 2;
 8239af8:	e0bffd17 	ldw	r2,-12(fp)
 8239afc:	00c00604 	movi	r3,24
 8239b00:	10c02115 	stw	r3,132(r2)

   t_time = ((TCPTV_SRTTBASE >> 2) + (TCPTV_SRTTDFLT << 2)) >> 1;
 8239b04:	00800304 	movi	r2,12
 8239b08:	e0bffe0d 	sth	r2,-8(fp)
   TCPT_RANGESET(tp->t_rxtcur, t_time, TCPTV_MIN, TCPTV_REXMTMAX);
 8239b0c:	e0fffe0f 	ldh	r3,-8(fp)
 8239b10:	e0bffd17 	ldw	r2,-12(fp)
 8239b14:	10c00815 	stw	r3,32(r2)
 8239b18:	e0bffd17 	ldw	r2,-12(fp)
 8239b1c:	10800817 	ldw	r2,32(r2)
 8239b20:	10800088 	cmpgei	r2,r2,2
 8239b24:	1000041e 	bne	r2,zero,8239b38 <tcp_newtcpcb+0xb4>
 8239b28:	e0bffd17 	ldw	r2,-12(fp)
 8239b2c:	00c00084 	movi	r3,2
 8239b30:	10c00815 	stw	r3,32(r2)
 8239b34:	00000706 	br	8239b54 <tcp_newtcpcb+0xd0>
 8239b38:	e0bffd17 	ldw	r2,-12(fp)
 8239b3c:	10800817 	ldw	r2,32(r2)
 8239b40:	10802050 	cmplti	r2,r2,129
 8239b44:	1000031e 	bne	r2,zero,8239b54 <tcp_newtcpcb+0xd0>
 8239b48:	e0bffd17 	ldw	r2,-12(fp)
 8239b4c:	00c02004 	movi	r3,128
 8239b50:	10c00815 	stw	r3,32(r2)

   /* Set initial congestion window - RFC-2581, pg 4. */
   tp->snd_cwnd = 2 * TCP_MSS;
 8239b54:	e0bffd17 	ldw	r2,-12(fp)
 8239b58:	00c2da04 	movi	r3,2920
 8239b5c:	10c01b15 	stw	r3,108(r2)

#ifdef DO_DELAY_ACKS
   tp->t_delacktime = 1;
#endif   /* DO_DELAY_ACKS */

   tp->snd_ssthresh = 65535;  /* Start with high slow-start threshold */
 8239b60:	e0bffd17 	ldw	r2,-12(fp)
 8239b64:	00ffffd4 	movui	r3,65535
 8239b68:	10c01c15 	stw	r3,112(r2)

   inp->inp_ppcb = (char *)tp;
 8239b6c:	e0bfff17 	ldw	r2,-4(fp)
 8239b70:	e0fffd17 	ldw	r3,-12(fp)
 8239b74:	10c00915 	stw	r3,36(r2)
   return (tp);
 8239b78:	e0bffd17 	ldw	r2,-12(fp)
}
 8239b7c:	e037883a 	mov	sp,fp
 8239b80:	dfc00117 	ldw	ra,4(sp)
 8239b84:	df000017 	ldw	fp,0(sp)
 8239b88:	dec00204 	addi	sp,sp,8
 8239b8c:	f800283a 	ret

08239b90 <tcp_drop>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_drop(struct tcpcb * tp, int err)
{
 8239b90:	defffb04 	addi	sp,sp,-20
 8239b94:	dfc00415 	stw	ra,16(sp)
 8239b98:	df000315 	stw	fp,12(sp)
 8239b9c:	df000304 	addi	fp,sp,12
 8239ba0:	e13ffe15 	stw	r4,-8(fp)
 8239ba4:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 8239ba8:	e0bffe17 	ldw	r2,-8(fp)
 8239bac:	10800d17 	ldw	r2,52(r2)
 8239bb0:	10800817 	ldw	r2,32(r2)
 8239bb4:	e0bffd15 	stw	r2,-12(fp)

   if (TCPS_HAVERCVDSYN(tp->t_state)) 
 8239bb8:	e0bffe17 	ldw	r2,-8(fp)
 8239bbc:	10800217 	ldw	r2,8(r2)
 8239bc0:	108000d0 	cmplti	r2,r2,3
 8239bc4:	10000c1e 	bne	r2,zero,8239bf8 <tcp_drop+0x68>
   {
      tp->t_state = TCPS_CLOSED;
 8239bc8:	e0bffe17 	ldw	r2,-8(fp)
 8239bcc:	10000215 	stw	zero,8(r2)
      (void) tcp_output(tp);
 8239bd0:	e13ffe17 	ldw	r4,-8(fp)
 8239bd4:	823835c0 	call	823835c <tcp_output>
      tcpstat.tcps_drops++;
 8239bd8:	008209b4 	movhi	r2,2086
 8239bdc:	10b9ad04 	addi	r2,r2,-6476
 8239be0:	10800317 	ldw	r2,12(r2)
 8239be4:	10c00044 	addi	r3,r2,1
 8239be8:	008209b4 	movhi	r2,2086
 8239bec:	10b9ad04 	addi	r2,r2,-6476
 8239bf0:	10c00315 	stw	r3,12(r2)
 8239bf4:	00000706 	br	8239c14 <tcp_drop+0x84>
   }
   else
      tcpstat.tcps_conndrops++;
 8239bf8:	008209b4 	movhi	r2,2086
 8239bfc:	10b9ad04 	addi	r2,r2,-6476
 8239c00:	10800417 	ldw	r2,16(r2)
 8239c04:	10c00044 	addi	r3,r2,1
 8239c08:	008209b4 	movhi	r2,2086
 8239c0c:	10b9ad04 	addi	r2,r2,-6476
 8239c10:	10c00415 	stw	r3,16(r2)
   so->so_error = err;
 8239c14:	e0bffd17 	ldw	r2,-12(fp)
 8239c18:	e0ffff17 	ldw	r3,-4(fp)
 8239c1c:	10c00615 	stw	r3,24(r2)
#ifdef TCP_ZEROCOPY
   if (so->rx_upcall)
      so->rx_upcall(so, NULL, err);
#endif   /* TCP_ZEROCOPY */
   return (tcp_close(tp));
 8239c20:	e13ffe17 	ldw	r4,-8(fp)
 8239c24:	8239c3c0 	call	8239c3c <tcp_close>
}
 8239c28:	e037883a 	mov	sp,fp
 8239c2c:	dfc00117 	ldw	ra,4(sp)
 8239c30:	df000017 	ldw	fp,0(sp)
 8239c34:	dec00204 	addi	sp,sp,8
 8239c38:	f800283a 	ret

08239c3c <tcp_close>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_close(struct tcpcb * tp)
{
 8239c3c:	defff904 	addi	sp,sp,-28
 8239c40:	dfc00615 	stw	ra,24(sp)
 8239c44:	df000515 	stw	fp,20(sp)
 8239c48:	df000504 	addi	fp,sp,20
 8239c4c:	e13fff15 	stw	r4,-4(fp)
   struct tcpiphdr * t;
   struct inpcb * inp   =  tp->t_inpcb;
 8239c50:	e0bfff17 	ldw	r2,-4(fp)
 8239c54:	10800d17 	ldw	r2,52(r2)
 8239c58:	e0bffc15 	stw	r2,-16(fp)
   struct socket *   so =  inp->inp_socket;
 8239c5c:	e0bffc17 	ldw	r2,-16(fp)
 8239c60:	10800817 	ldw	r2,32(r2)
 8239c64:	e0bffd15 	stw	r2,-12(fp)
   struct mbuf *  m;

   t = tp->seg_next;
 8239c68:	e0bfff17 	ldw	r2,-4(fp)
 8239c6c:	10800017 	ldw	r2,0(r2)
 8239c70:	e0bffb15 	stw	r2,-20(fp)
   while (t != (struct tcpiphdr *)tp) 
 8239c74:	00000e06 	br	8239cb0 <tcp_close+0x74>
   {
      t = (struct tcpiphdr *)t->ti_next;
 8239c78:	e0bffb17 	ldw	r2,-20(fp)
 8239c7c:	10800017 	ldw	r2,0(r2)
 8239c80:	e0bffb15 	stw	r2,-20(fp)
      m = dtom(t->ti_prev);
 8239c84:	e0bffb17 	ldw	r2,-20(fp)
 8239c88:	10800117 	ldw	r2,4(r2)
 8239c8c:	1009883a 	mov	r4,r2
 8239c90:	822ebe00 	call	822ebe0 <dtom>
 8239c94:	e0bffe15 	stw	r2,-8(fp)
      remque(t->ti_prev);
 8239c98:	e0bffb17 	ldw	r2,-20(fp)
 8239c9c:	10800117 	ldw	r2,4(r2)
 8239ca0:	1009883a 	mov	r4,r2
 8239ca4:	822ec7c0 	call	822ec7c <remque>
      m_freem (m);
 8239ca8:	e13ffe17 	ldw	r4,-8(fp)
 8239cac:	822e6940 	call	822e694 <m_freem>
   struct inpcb * inp   =  tp->t_inpcb;
   struct socket *   so =  inp->inp_socket;
   struct mbuf *  m;

   t = tp->seg_next;
   while (t != (struct tcpiphdr *)tp) 
 8239cb0:	e0fffb17 	ldw	r3,-20(fp)
 8239cb4:	e0bfff17 	ldw	r2,-4(fp)
 8239cb8:	18bfef1e 	bne	r3,r2,8239c78 <tcp_close+0x3c>
      t = (struct tcpiphdr *)t->ti_next;
      m = dtom(t->ti_prev);
      remque(t->ti_prev);
      m_freem (m);
   }
   if (tp->t_template)
 8239cbc:	e0bfff17 	ldw	r2,-4(fp)
 8239cc0:	10800c17 	ldw	r2,48(r2)
 8239cc4:	10000426 	beq	r2,zero,8239cd8 <tcp_close+0x9c>
      TPH_FREE (tp->t_template);
 8239cc8:	e0bfff17 	ldw	r2,-4(fp)
 8239ccc:	10800c17 	ldw	r2,48(r2)
 8239cd0:	1009883a 	mov	r4,r2
 8239cd4:	822e1fc0 	call	822e1fc <npfree>
   TCB_FREE (tp);
 8239cd8:	e13fff17 	ldw	r4,-4(fp)
 8239cdc:	822e1fc0 	call	822e1fc <npfree>
   inp->inp_ppcb = 0;
 8239ce0:	e0bffc17 	ldw	r2,-16(fp)
 8239ce4:	10000915 	stw	zero,36(r2)
   soisdisconnected(so);
 8239ce8:	e13ffd17 	ldw	r4,-12(fp)
 8239cec:	8233cd00 	call	8233cd0 <soisdisconnected>
   in_pcbdetach(inp);
 8239cf0:	e13ffc17 	ldw	r4,-16(fp)
 8239cf4:	8247f1c0 	call	8247f1c <in_pcbdetach>
   tcpstat.tcps_closed++;
 8239cf8:	008209b4 	movhi	r2,2086
 8239cfc:	10b9ad04 	addi	r2,r2,-6476
 8239d00:	10800517 	ldw	r2,20(r2)
 8239d04:	10c00044 	addi	r3,r2,1
 8239d08:	008209b4 	movhi	r2,2086
 8239d0c:	10b9ad04 	addi	r2,r2,-6476
 8239d10:	10c00515 	stw	r3,20(r2)
   return ((struct tcpcb *)0);
 8239d14:	0005883a 	mov	r2,zero
}
 8239d18:	e037883a 	mov	sp,fp
 8239d1c:	dfc00117 	ldw	ra,4(sp)
 8239d20:	df000017 	ldw	fp,0(sp)
 8239d24:	dec00204 	addi	sp,sp,8
 8239d28:	f800283a 	ret

08239d2c <tcp_quench>:
 * RETURNS: 
 */

void
tcp_quench(struct inpcb * inp)
{
 8239d2c:	defffd04 	addi	sp,sp,-12
 8239d30:	df000215 	stw	fp,8(sp)
 8239d34:	df000204 	addi	fp,sp,8
 8239d38:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp =  intotcpcb(inp);
 8239d3c:	e0bfff17 	ldw	r2,-4(fp)
 8239d40:	10800917 	ldw	r2,36(r2)
 8239d44:	e0bffe15 	stw	r2,-8(fp)

   if (tp)
 8239d48:	e0bffe17 	ldw	r2,-8(fp)
 8239d4c:	10000526 	beq	r2,zero,8239d64 <tcp_quench+0x38>
      tp->snd_cwnd = tp->t_maxseg;
 8239d50:	e0bffe17 	ldw	r2,-8(fp)
 8239d54:	10800a0b 	ldhu	r2,40(r2)
 8239d58:	10ffffcc 	andi	r3,r2,65535
 8239d5c:	e0bffe17 	ldw	r2,-8(fp)
 8239d60:	10c01b15 	stw	r3,108(r2)
}
 8239d64:	0001883a 	nop
 8239d68:	e037883a 	mov	sp,fp
 8239d6c:	df000017 	ldw	fp,0(sp)
 8239d70:	dec00104 	addi	sp,sp,4
 8239d74:	f800283a 	ret

08239d78 <tcp_putseq>:

/* tcp_putseq()  */

u_char *
tcp_putseq(u_char * cp, tcp_seq seq)
{
 8239d78:	defffc04 	addi	sp,sp,-16
 8239d7c:	df000315 	stw	fp,12(sp)
 8239d80:	df000304 	addi	fp,sp,12
 8239d84:	e13ffe15 	stw	r4,-8(fp)
 8239d88:	e17fff15 	stw	r5,-4(fp)
   int   i;

   cp += 3;                /* do low byte first */
 8239d8c:	e0bffe17 	ldw	r2,-8(fp)
 8239d90:	108000c4 	addi	r2,r2,3
 8239d94:	e0bffe15 	stw	r2,-8(fp)
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 8239d98:	e03ffd15 	stw	zero,-12(fp)
 8239d9c:	00000b06 	br	8239dcc <tcp_putseq+0x54>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
 8239da0:	e0bffe17 	ldw	r2,-8(fp)
 8239da4:	10ffffc4 	addi	r3,r2,-1
 8239da8:	e0fffe15 	stw	r3,-8(fp)
 8239dac:	e0ffff17 	ldw	r3,-4(fp)
 8239db0:	10c00005 	stb	r3,0(r2)
      seq >>= 8;
 8239db4:	e0bfff17 	ldw	r2,-4(fp)
 8239db8:	1004d23a 	srli	r2,r2,8
 8239dbc:	e0bfff15 	stw	r2,-4(fp)
tcp_putseq(u_char * cp, tcp_seq seq)
{
   int   i;

   cp += 3;                /* do low byte first */
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 8239dc0:	e0bffd17 	ldw	r2,-12(fp)
 8239dc4:	10800044 	addi	r2,r2,1
 8239dc8:	e0bffd15 	stw	r2,-12(fp)
 8239dcc:	e0bffd17 	ldw	r2,-12(fp)
 8239dd0:	10800110 	cmplti	r2,r2,4
 8239dd4:	103ff21e 	bne	r2,zero,8239da0 <tcp_putseq+0x28>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
      seq >>= 8;
   }
   return (cp + 5);
 8239dd8:	e0bffe17 	ldw	r2,-8(fp)
 8239ddc:	10800144 	addi	r2,r2,5
}
 8239de0:	e037883a 	mov	sp,fp
 8239de4:	df000017 	ldw	fp,0(sp)
 8239de8:	dec00104 	addi	sp,sp,4
 8239dec:	f800283a 	ret

08239df0 <tcp_getseq>:
 * RETURNS: a long in local endian
 */

u_long
tcp_getseq(u_char * cp)
{
 8239df0:	defffc04 	addi	sp,sp,-16
 8239df4:	df000315 	stw	fp,12(sp)
 8239df8:	df000304 	addi	fp,sp,12
 8239dfc:	e13fff15 	stw	r4,-4(fp)
   int i;
   ulong seq = 0;
 8239e00:	e03ffe15 	stw	zero,-8(fp)

   for(i = 0; i < 4; i++)
 8239e04:	e03ffd15 	stw	zero,-12(fp)
 8239e08:	00000e06 	br	8239e44 <tcp_getseq+0x54>
   {
      seq <<= 8;
 8239e0c:	e0bffe17 	ldw	r2,-8(fp)
 8239e10:	1004923a 	slli	r2,r2,8
 8239e14:	e0bffe15 	stw	r2,-8(fp)
      seq += (u_long)*(cp++);
 8239e18:	e0bfff17 	ldw	r2,-4(fp)
 8239e1c:	10c00044 	addi	r3,r2,1
 8239e20:	e0ffff15 	stw	r3,-4(fp)
 8239e24:	10800003 	ldbu	r2,0(r2)
 8239e28:	10803fcc 	andi	r2,r2,255
 8239e2c:	e0fffe17 	ldw	r3,-8(fp)
 8239e30:	1885883a 	add	r2,r3,r2
 8239e34:	e0bffe15 	stw	r2,-8(fp)
tcp_getseq(u_char * cp)
{
   int i;
   ulong seq = 0;

   for(i = 0; i < 4; i++)
 8239e38:	e0bffd17 	ldw	r2,-12(fp)
 8239e3c:	10800044 	addi	r2,r2,1
 8239e40:	e0bffd15 	stw	r2,-12(fp)
 8239e44:	e0bffd17 	ldw	r2,-12(fp)
 8239e48:	10800110 	cmplti	r2,r2,4
 8239e4c:	103fef1e 	bne	r2,zero,8239e0c <tcp_getseq+0x1c>
   {
      seq <<= 8;
      seq += (u_long)*(cp++);
   }
   return seq;
 8239e50:	e0bffe17 	ldw	r2,-8(fp)
}
 8239e54:	e037883a 	mov	sp,fp
 8239e58:	df000017 	ldw	fp,0(sp)
 8239e5c:	dec00104 	addi	sp,sp,4
 8239e60:	f800283a 	ret

08239e64 <tcp_slowtimo>:
 * RETURNS: 
 */

void
tcp_slowtimo(void)
{
 8239e64:	defff704 	addi	sp,sp,-36
 8239e68:	dfc00815 	stw	ra,32(sp)
 8239e6c:	df000715 	stw	fp,28(sp)
 8239e70:	df000704 	addi	fp,sp,28
   struct tcpcb * tp;
   int   i;
   struct socket * so, * sonext;
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;
 8239e74:	d0a03f17 	ldw	r2,-32516(gp)
 8239e78:	100490fa 	slli	r2,r2,3
 8239e7c:	d0a0b415 	stw	r2,-32048(gp)

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 8239e80:	008209b4 	movhi	r2,2086
 8239e84:	10b97a04 	addi	r2,r2,-6680
 8239e88:	10800017 	ldw	r2,0(r2)
 8239e8c:	e0bffa15 	stw	r2,-24(fp)
 8239e90:	00008006 	br	823a094 <tcp_slowtimo+0x230>
   {
      sonext = so->next;
 8239e94:	e0bffa17 	ldw	r2,-24(fp)
 8239e98:	10800017 	ldw	r2,0(r2)
 8239e9c:	e0bffb15 	stw	r2,-20(fp)

      /* for SOCK_STREAM (TCP) sockets, we must do slow-timeout 
       * processing and (optionally) processing of pending 
       * zero-copy socket upcalls.
       */
      if (so->so_type == SOCK_STREAM)
 8239ea0:	e0bffa17 	ldw	r2,-24(fp)
 8239ea4:	10800983 	ldbu	r2,38(r2)
 8239ea8:	10803fcc 	andi	r2,r2,255
 8239eac:	1080201c 	xori	r2,r2,128
 8239eb0:	10bfe004 	addi	r2,r2,-128
 8239eb4:	10800058 	cmpnei	r2,r2,1
 8239eb8:	1000461e 	bne	r2,zero,8239fd4 <tcp_slowtimo+0x170>
      {
         ip = so->so_pcb;
 8239ebc:	e0bffa17 	ldw	r2,-24(fp)
 8239ec0:	10800117 	ldw	r2,4(r2)
 8239ec4:	e0bffc15 	stw	r2,-16(fp)
         if (!ip)
 8239ec8:	e0bffc17 	ldw	r2,-16(fp)
 8239ecc:	10006a26 	beq	r2,zero,823a078 <tcp_slowtimo+0x214>
            continue;
         ipnxt = ip->inp_next;
 8239ed0:	e0bffc17 	ldw	r2,-16(fp)
 8239ed4:	10800017 	ldw	r2,0(r2)
 8239ed8:	e0bffd15 	stw	r2,-12(fp)

         tp = intotcpcb(so->so_pcb);
 8239edc:	e0bffa17 	ldw	r2,-24(fp)
 8239ee0:	10800117 	ldw	r2,4(r2)
 8239ee4:	10800917 	ldw	r2,36(r2)
 8239ee8:	e0bffe15 	stw	r2,-8(fp)
         if (!tp)
 8239eec:	e0bffe17 	ldw	r2,-8(fp)
 8239ef0:	10006326 	beq	r2,zero,823a080 <tcp_slowtimo+0x21c>
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 8239ef4:	e03ff915 	stw	zero,-28(fp)
 8239ef8:	00002e06 	br	8239fb4 <tcp_slowtimo+0x150>
         {
            if (tp->t_timer[i] && --tp->t_timer[i] == 0) 
 8239efc:	e0fffe17 	ldw	r3,-8(fp)
 8239f00:	e0bff917 	ldw	r2,-28(fp)
 8239f04:	108000c4 	addi	r2,r2,3
 8239f08:	1085883a 	add	r2,r2,r2
 8239f0c:	1085883a 	add	r2,r2,r2
 8239f10:	1885883a 	add	r2,r3,r2
 8239f14:	10800017 	ldw	r2,0(r2)
 8239f18:	10002326 	beq	r2,zero,8239fa8 <tcp_slowtimo+0x144>
 8239f1c:	e0fffe17 	ldw	r3,-8(fp)
 8239f20:	e0bff917 	ldw	r2,-28(fp)
 8239f24:	108000c4 	addi	r2,r2,3
 8239f28:	1085883a 	add	r2,r2,r2
 8239f2c:	1085883a 	add	r2,r2,r2
 8239f30:	1885883a 	add	r2,r3,r2
 8239f34:	10800017 	ldw	r2,0(r2)
 8239f38:	10ffffc4 	addi	r3,r2,-1
 8239f3c:	e13ffe17 	ldw	r4,-8(fp)
 8239f40:	e0bff917 	ldw	r2,-28(fp)
 8239f44:	108000c4 	addi	r2,r2,3
 8239f48:	1085883a 	add	r2,r2,r2
 8239f4c:	1085883a 	add	r2,r2,r2
 8239f50:	2085883a 	add	r2,r4,r2
 8239f54:	10c00015 	stw	r3,0(r2)
 8239f58:	e0fffe17 	ldw	r3,-8(fp)
 8239f5c:	e0bff917 	ldw	r2,-28(fp)
 8239f60:	108000c4 	addi	r2,r2,3
 8239f64:	1085883a 	add	r2,r2,r2
 8239f68:	1085883a 	add	r2,r2,r2
 8239f6c:	1885883a 	add	r2,r3,r2
 8239f70:	10800017 	ldw	r2,0(r2)
 8239f74:	10000c1e 	bne	r2,zero,8239fa8 <tcp_slowtimo+0x144>
            {
               /* call usrreq to do actual work */
               so->so_req = PRU_SLOWTIMO;
 8239f78:	e0bffa17 	ldw	r2,-24(fp)
 8239f7c:	00c004c4 	movi	r3,19
 8239f80:	10c00715 	stw	r3,28(r2)
               (void) tcp_usrreq(so, (struct mbuf *)0, 
 8239f84:	e0bff917 	ldw	r2,-28(fp)
 8239f88:	100d883a 	mov	r6,r2
 8239f8c:	000b883a 	mov	r5,zero
 8239f90:	e13ffa17 	ldw	r4,-24(fp)
 8239f94:	823a5b40 	call	823a5b4 <tcp_usrreq>
                                 LONG2MBUF((long)i));

               /* If ip disappeared on us, handle it */
               if (ipnxt->inp_prev != ip)
 8239f98:	e0bffd17 	ldw	r2,-12(fp)
 8239f9c:	10c00117 	ldw	r3,4(r2)
 8239fa0:	e0bffc17 	ldw	r2,-16(fp)
 8239fa4:	1880381e 	bne	r3,r2,823a088 <tcp_slowtimo+0x224>

         tp = intotcpcb(so->so_pcb);
         if (!tp)
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 8239fa8:	e0bff917 	ldw	r2,-28(fp)
 8239fac:	10800044 	addi	r2,r2,1
 8239fb0:	e0bff915 	stw	r2,-28(fp)
 8239fb4:	e0bff917 	ldw	r2,-28(fp)
 8239fb8:	10800110 	cmplti	r2,r2,4
 8239fbc:	103fcf1e 	bne	r2,zero,8239efc <tcp_slowtimo+0x98>
               }
            }
         }
#endif   /* TCP_ZEROCOPY */

         tp->t_idle++;
 8239fc0:	e0bffe17 	ldw	r2,-8(fp)
 8239fc4:	10801d17 	ldw	r2,116(r2)
 8239fc8:	10c00044 	addi	r3,r2,1
 8239fcc:	e0bffe17 	ldw	r2,-8(fp)
 8239fd0:	10c01d15 	stw	r3,116(r2)
      }

      /* wake up anyone sleeping in a select() involving this socket */
      sb = &so->so_rcv;
 8239fd4:	e0bffa17 	ldw	r2,-24(fp)
 8239fd8:	10800a04 	addi	r2,r2,40
 8239fdc:	e0bfff15 	stw	r2,-4(fp)
      if (sb->sb_flags & SB_SEL) 
 8239fe0:	e0bfff17 	ldw	r2,-4(fp)
 8239fe4:	1080070b 	ldhu	r2,28(r2)
 8239fe8:	10bfffcc 	andi	r2,r2,65535
 8239fec:	1080020c 	andi	r2,r2,8
 8239ff0:	10000a26 	beq	r2,zero,823a01c <tcp_slowtimo+0x1b8>
      {
         select_wait = 0;
 8239ff4:	d020b00d 	sth	zero,-32064(gp)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 8239ff8:	d120b004 	addi	r4,gp,-32064
 8239ffc:	82297040 	call	8229704 <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 823a000:	e0bfff17 	ldw	r2,-4(fp)
 823a004:	10c0070b 	ldhu	r3,28(r2)
 823a008:	00bffdc4 	movi	r2,-9
 823a00c:	1884703a 	and	r2,r3,r2
 823a010:	1007883a 	mov	r3,r2
 823a014:	e0bfff17 	ldw	r2,-4(fp)
 823a018:	10c0070d 	sth	r3,28(r2)
      }
      sb = &so->so_snd;
 823a01c:	e0bffa17 	ldw	r2,-24(fp)
 823a020:	10801204 	addi	r2,r2,72
 823a024:	e0bfff15 	stw	r2,-4(fp)
      if (sb->sb_flags & SB_SEL) 
 823a028:	e0bfff17 	ldw	r2,-4(fp)
 823a02c:	1080070b 	ldhu	r2,28(r2)
 823a030:	10bfffcc 	andi	r2,r2,65535
 823a034:	1080020c 	andi	r2,r2,8
 823a038:	10000a26 	beq	r2,zero,823a064 <tcp_slowtimo+0x200>
      {
         select_wait = 0;         
 823a03c:	d020b00d 	sth	zero,-32064(gp)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 823a040:	d120b004 	addi	r4,gp,-32064
 823a044:	82297040 	call	8229704 <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 823a048:	e0bfff17 	ldw	r2,-4(fp)
 823a04c:	10c0070b 	ldhu	r3,28(r2)
 823a050:	00bffdc4 	movi	r2,-9
 823a054:	1884703a 	and	r2,r3,r2
 823a058:	1007883a 	mov	r3,r2
 823a05c:	e0bfff17 	ldw	r2,-4(fp)
 823a060:	10c0070d 	sth	r3,28(r2)
      }

      /* wake any thread with a timer going for a connection state change */     
      tcp_wakeup((char*)&so->so_timeo);
 823a064:	e0bffa17 	ldw	r2,-24(fp)
 823a068:	10800904 	addi	r2,r2,36
 823a06c:	1009883a 	mov	r4,r2
 823a070:	82297040 	call	8229704 <tcp_wakeup>
 823a074:	00000506 	br	823a08c <tcp_slowtimo+0x228>
       */
      if (so->so_type == SOCK_STREAM)
      {
         ip = so->so_pcb;
         if (!ip)
            continue;
 823a078:	0001883a 	nop
 823a07c:	00000306 	br	823a08c <tcp_slowtimo+0x228>
         ipnxt = ip->inp_next;

         tp = intotcpcb(so->so_pcb);
         if (!tp)
            continue;
 823a080:	0001883a 	nop
 823a084:	00000106 	br	823a08c <tcp_slowtimo+0x228>
               (void) tcp_usrreq(so, (struct mbuf *)0, 
                                 LONG2MBUF((long)i));

               /* If ip disappeared on us, handle it */
               if (ipnxt->inp_prev != ip)
                  goto tpgone;
 823a088:	0001883a 	nop
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 823a08c:	e0bffb17 	ldw	r2,-20(fp)
 823a090:	e0bffa15 	stw	r2,-24(fp)
 823a094:	e0bffa17 	ldw	r2,-24(fp)
 823a098:	103f7e1e 	bne	r2,zero,8239e94 <tcp_slowtimo+0x30>

tpgone:
      ;
   }

   tcp_iss += (unsigned)(TCP_ISSINCR/PR_SLOWHZ);      /* increment iss */
 823a09c:	d0e0b517 	ldw	r3,-32044(gp)
 823a0a0:	00be9fd4 	movui	r2,64127
 823a0a4:	1885883a 	add	r2,r3,r2
 823a0a8:	d0a0b515 	stw	r2,-32044(gp)

   if (tcp_iss & 0xff000000)
 823a0ac:	d0a0b517 	ldw	r2,-32044(gp)
 823a0b0:	10bfc02c 	andhi	r2,r2,65280
 823a0b4:	10000126 	beq	r2,zero,823a0bc <tcp_slowtimo+0x258>
      tcp_iss = 0L;
 823a0b8:	d020b515 	stw	zero,-32044(gp)
}
 823a0bc:	0001883a 	nop
 823a0c0:	e037883a 	mov	sp,fp
 823a0c4:	dfc00117 	ldw	ra,4(sp)
 823a0c8:	df000017 	ldw	fp,0(sp)
 823a0cc:	dec00204 	addi	sp,sp,8
 823a0d0:	f800283a 	ret

0823a0d4 <tcp_canceltimers>:
 * RETURNS: 
 */

void
tcp_canceltimers(struct tcpcb * tp)
{
 823a0d4:	defffd04 	addi	sp,sp,-12
 823a0d8:	df000215 	stw	fp,8(sp)
 823a0dc:	df000204 	addi	fp,sp,8
 823a0e0:	e13fff15 	stw	r4,-4(fp)
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 823a0e4:	e03ffe15 	stw	zero,-8(fp)
 823a0e8:	00000a06 	br	823a114 <tcp_canceltimers+0x40>
      tp->t_timer[i] = 0;
 823a0ec:	e0ffff17 	ldw	r3,-4(fp)
 823a0f0:	e0bffe17 	ldw	r2,-8(fp)
 823a0f4:	108000c4 	addi	r2,r2,3
 823a0f8:	1085883a 	add	r2,r2,r2
 823a0fc:	1085883a 	add	r2,r2,r2
 823a100:	1885883a 	add	r2,r3,r2
 823a104:	10000015 	stw	zero,0(r2)
void
tcp_canceltimers(struct tcpcb * tp)
{
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 823a108:	e0bffe17 	ldw	r2,-8(fp)
 823a10c:	10800044 	addi	r2,r2,1
 823a110:	e0bffe15 	stw	r2,-8(fp)
 823a114:	e0bffe17 	ldw	r2,-8(fp)
 823a118:	10800110 	cmplti	r2,r2,4
 823a11c:	103ff31e 	bne	r2,zero,823a0ec <tcp_canceltimers+0x18>
      tp->t_timer[i] = 0;
}
 823a120:	0001883a 	nop
 823a124:	e037883a 	mov	sp,fp
 823a128:	df000017 	ldw	fp,0(sp)
 823a12c:	dec00104 	addi	sp,sp,4
 823a130:	f800283a 	ret

0823a134 <tcp_timers>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_timers(struct tcpcb * tp, int timer)
{
 823a134:	defff804 	addi	sp,sp,-32
 823a138:	dfc00715 	stw	ra,28(sp)
 823a13c:	df000615 	stw	fp,24(sp)
 823a140:	df000604 	addi	fp,sp,24
 823a144:	e13ffe15 	stw	r4,-8(fp)
 823a148:	e17fff15 	stw	r5,-4(fp)
   int   rexmt;

   switch (timer) 
 823a14c:	e0bfff17 	ldw	r2,-4(fp)
 823a150:	10c00060 	cmpeqi	r3,r2,1
 823a154:	1800b21e 	bne	r3,zero,823a420 <tcp_timers+0x2ec>
 823a158:	10c00088 	cmpgei	r3,r2,2
 823a15c:	1800021e 	bne	r3,zero,823a168 <tcp_timers+0x34>
 823a160:	10001826 	beq	r2,zero,823a1c4 <tcp_timers+0x90>
 823a164:	00010d06 	br	823a59c <tcp_timers+0x468>
 823a168:	10c000a0 	cmpeqi	r3,r2,2
 823a16c:	1800bd1e 	bne	r3,zero,823a464 <tcp_timers+0x330>
 823a170:	108000e0 	cmpeqi	r2,r2,3
 823a174:	10010926 	beq	r2,zero,823a59c <tcp_timers+0x468>
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 823a178:	e0bffe17 	ldw	r2,-8(fp)
 823a17c:	10800217 	ldw	r2,8(r2)
 823a180:	108002a0 	cmpeqi	r2,r2,10
 823a184:	10000b1e 	bne	r2,zero,823a1b4 <tcp_timers+0x80>
          tp->t_idle <= tcp_maxidle)
 823a188:	e0bffe17 	ldw	r2,-8(fp)
 823a18c:	10801d17 	ldw	r2,116(r2)
 823a190:	d0e0b417 	ldw	r3,-32048(gp)
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 823a194:	18800716 	blt	r3,r2,823a1b4 <tcp_timers+0x80>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
 823a198:	d0a03f17 	ldw	r2,-32516(gp)
 823a19c:	10ffffcc 	andi	r3,r2,65535
 823a1a0:	18e0001c 	xori	r3,r3,32768
 823a1a4:	18e00004 	addi	r3,r3,-32768
 823a1a8:	e0bffe17 	ldw	r2,-8(fp)
 823a1ac:	10c00615 	stw	r3,24(r2)
      }
      else
         tp = tcp_close(tp);
      break;
 823a1b0:	0000fa06 	br	823a59c <tcp_timers+0x468>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
      }
      else
         tp = tcp_close(tp);
 823a1b4:	e13ffe17 	ldw	r4,-8(fp)
 823a1b8:	8239c3c0 	call	8239c3c <tcp_close>
 823a1bc:	e0bffe15 	stw	r2,-8(fp)
      break;
 823a1c0:	0000f606 	br	823a59c <tcp_timers+0x468>
    * Retransmission timer went off.  Message has not
    * been acked within retransmit interval.  Back off
    * to a longer retransmit interval and retransmit one segment.
    */
   case TCPT_REXMT:
      TCP_MIB_INC(tcpRetransSegs);     /* keep MIB stats */
 823a1c4:	008209b4 	movhi	r2,2086
 823a1c8:	10b97f04 	addi	r2,r2,-6660
 823a1cc:	10800b17 	ldw	r2,44(r2)
 823a1d0:	10c00044 	addi	r3,r2,1
 823a1d4:	008209b4 	movhi	r2,2086
 823a1d8:	10b97f04 	addi	r2,r2,-6660
 823a1dc:	10c00b15 	stw	r3,44(r2)
      if (++tp->t_rxtshift > TCP_MAXRXTSHIFT) 
 823a1e0:	e0bffe17 	ldw	r2,-8(fp)
 823a1e4:	10800717 	ldw	r2,28(r2)
 823a1e8:	10c00044 	addi	r3,r2,1
 823a1ec:	e0bffe17 	ldw	r2,-8(fp)
 823a1f0:	10c00715 	stw	r3,28(r2)
 823a1f4:	e0bffe17 	ldw	r2,-8(fp)
 823a1f8:	10800717 	ldw	r2,28(r2)
 823a1fc:	10800350 	cmplti	r2,r2,13
 823a200:	10000f1e 	bne	r2,zero,823a240 <tcp_timers+0x10c>
      {
         tp->t_rxtshift = TCP_MAXRXTSHIFT;
 823a204:	e0bffe17 	ldw	r2,-8(fp)
 823a208:	00c00304 	movi	r3,12
 823a20c:	10c00715 	stw	r3,28(r2)
         tcpstat.tcps_timeoutdrop++;
 823a210:	008209b4 	movhi	r2,2086
 823a214:	10b9ad04 	addi	r2,r2,-6476
 823a218:	10800917 	ldw	r2,36(r2)
 823a21c:	10c00044 	addi	r3,r2,1
 823a220:	008209b4 	movhi	r2,2086
 823a224:	10b9ad04 	addi	r2,r2,-6476
 823a228:	10c00915 	stw	r3,36(r2)
         tp = tcp_drop(tp, ETIMEDOUT);
 823a22c:	01401d04 	movi	r5,116
 823a230:	e13ffe17 	ldw	r4,-8(fp)
 823a234:	8239b900 	call	8239b90 <tcp_drop>
 823a238:	e0bffe15 	stw	r2,-8(fp)
         break;
 823a23c:	0000d706 	br	823a59c <tcp_timers+0x468>
      }
      tcpstat.tcps_rexmttimeo++;
 823a240:	008209b4 	movhi	r2,2086
 823a244:	10b9ad04 	addi	r2,r2,-6476
 823a248:	10800a17 	ldw	r2,40(r2)
 823a24c:	10c00044 	addi	r3,r2,1
 823a250:	008209b4 	movhi	r2,2086
 823a254:	10b9ad04 	addi	r2,r2,-6476
 823a258:	10c00a15 	stw	r3,40(r2)
      rexmt = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 823a25c:	e0bffe17 	ldw	r2,-8(fp)
 823a260:	10802017 	ldw	r2,128(r2)
 823a264:	1007d0ba 	srai	r3,r2,2
 823a268:	e0bffe17 	ldw	r2,-8(fp)
 823a26c:	10802117 	ldw	r2,132(r2)
 823a270:	1885883a 	add	r2,r3,r2
 823a274:	1005d07a 	srai	r2,r2,1
 823a278:	e0bffd15 	stw	r2,-12(fp)
      rexmt *= tcp_backoff[tp->t_rxtshift];
 823a27c:	e0bffe17 	ldw	r2,-8(fp)
 823a280:	10c00717 	ldw	r3,28(r2)
 823a284:	00820974 	movhi	r2,2085
 823a288:	108ee7c4 	addi	r2,r2,15263
 823a28c:	10c5883a 	add	r2,r2,r3
 823a290:	10800003 	ldbu	r2,0(r2)
 823a294:	10803fcc 	andi	r2,r2,255
 823a298:	e0fffd17 	ldw	r3,-12(fp)
 823a29c:	1885383a 	mul	r2,r3,r2
 823a2a0:	e0bffd15 	stw	r2,-12(fp)
      TCPT_RANGESET(tp->t_rxtcur, rexmt, TCPTV_MIN, TCPTV_REXMTMAX);
 823a2a4:	e0bffd17 	ldw	r2,-12(fp)
 823a2a8:	10ffffcc 	andi	r3,r2,65535
 823a2ac:	18e0001c 	xori	r3,r3,32768
 823a2b0:	18e00004 	addi	r3,r3,-32768
 823a2b4:	e0bffe17 	ldw	r2,-8(fp)
 823a2b8:	10c00815 	stw	r3,32(r2)
 823a2bc:	e0bffe17 	ldw	r2,-8(fp)
 823a2c0:	10800817 	ldw	r2,32(r2)
 823a2c4:	10800088 	cmpgei	r2,r2,2
 823a2c8:	1000041e 	bne	r2,zero,823a2dc <tcp_timers+0x1a8>
 823a2cc:	e0bffe17 	ldw	r2,-8(fp)
 823a2d0:	00c00084 	movi	r3,2
 823a2d4:	10c00815 	stw	r3,32(r2)
 823a2d8:	00000706 	br	823a2f8 <tcp_timers+0x1c4>
 823a2dc:	e0bffe17 	ldw	r2,-8(fp)
 823a2e0:	10800817 	ldw	r2,32(r2)
 823a2e4:	10802050 	cmplti	r2,r2,129
 823a2e8:	1000031e 	bne	r2,zero,823a2f8 <tcp_timers+0x1c4>
 823a2ec:	e0bffe17 	ldw	r2,-8(fp)
 823a2f0:	00c02004 	movi	r3,128
 823a2f4:	10c00815 	stw	r3,32(r2)
      tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 823a2f8:	e0bffe17 	ldw	r2,-8(fp)
 823a2fc:	10c00817 	ldw	r3,32(r2)
 823a300:	e0bffe17 	ldw	r2,-8(fp)
 823a304:	10c00315 	stw	r3,12(r2)
       * so we'll take the next rtt measurement as our srtt;
       * move the current srtt into rttvar to keep the current
       * retransmit times until then. Don't clobber with rtt
       * if we got it from a timestamp option.
       */
      if((tp->t_rxtshift > TCP_MAXRXTSHIFT / 4) &&
 823a308:	e0bffe17 	ldw	r2,-8(fp)
 823a30c:	10800717 	ldw	r2,28(r2)
 823a310:	10800110 	cmplti	r2,r2,4
 823a314:	10000f1e 	bne	r2,zero,823a354 <tcp_timers+0x220>
         ((tp->t_flags & TF_TIMESTAMP) == 0))
 823a318:	e0bffe17 	ldw	r2,-8(fp)
 823a31c:	10800b0b 	ldhu	r2,44(r2)
 823a320:	10bfffcc 	andi	r2,r2,65535
 823a324:	1080400c 	andi	r2,r2,256
       * so we'll take the next rtt measurement as our srtt;
       * move the current srtt into rttvar to keep the current
       * retransmit times until then. Don't clobber with rtt
       * if we got it from a timestamp option.
       */
      if((tp->t_rxtshift > TCP_MAXRXTSHIFT / 4) &&
 823a328:	10000a1e 	bne	r2,zero,823a354 <tcp_timers+0x220>
         ((tp->t_flags & TF_TIMESTAMP) == 0))
      {
         tp->t_rttvar += (tp->t_srtt >> 2);
 823a32c:	e0bffe17 	ldw	r2,-8(fp)
 823a330:	10c02117 	ldw	r3,132(r2)
 823a334:	e0bffe17 	ldw	r2,-8(fp)
 823a338:	10802017 	ldw	r2,128(r2)
 823a33c:	1005d0ba 	srai	r2,r2,2
 823a340:	1887883a 	add	r3,r3,r2
 823a344:	e0bffe17 	ldw	r2,-8(fp)
 823a348:	10c02115 	stw	r3,132(r2)
         tp->t_srtt = 0;
 823a34c:	e0bffe17 	ldw	r2,-8(fp)
 823a350:	10002015 	stw	zero,128(r2)
      }
      tp->snd_nxt = tp->snd_una;
 823a354:	e0bffe17 	ldw	r2,-8(fp)
 823a358:	10c00e17 	ldw	r3,56(r2)
 823a35c:	e0bffe17 	ldw	r2,-8(fp)
 823a360:	10c00f15 	stw	r3,60(r2)
      /*
       * If timing a segment in this window, stop the timer.
       */
      tp->t_rttick = 0;
 823a364:	e0bffe17 	ldw	r2,-8(fp)
 823a368:	10001e15 	stw	zero,120(r2)
       * to go below this.)
       *
       * Vers 1.9 - Skip slow start if the SO_NOSLOWSTART socket option
       * is set.
       */
      if((tp->t_inpcb->inp_socket->so_options & SO_NOSLOWSTART) == 0)
 823a36c:	e0bffe17 	ldw	r2,-8(fp)
 823a370:	10800d17 	ldw	r2,52(r2)
 823a374:	10800817 	ldw	r2,32(r2)
 823a378:	10800417 	ldw	r2,16(r2)
 823a37c:	1090000c 	andi	r2,r2,16384
 823a380:	1000241e 	bne	r2,zero,823a414 <tcp_timers+0x2e0>
      {
         u_int win = MIN(tp->snd_wnd, tp->snd_cwnd);
 823a384:	e0bffe17 	ldw	r2,-8(fp)
 823a388:	11001417 	ldw	r4,80(r2)
 823a38c:	e0bffe17 	ldw	r2,-8(fp)
 823a390:	10c01b17 	ldw	r3,108(r2)
 823a394:	2005883a 	mov	r2,r4
 823a398:	1880012e 	bgeu	r3,r2,823a3a0 <tcp_timers+0x26c>
 823a39c:	1805883a 	mov	r2,r3
 823a3a0:	e0bffc15 	stw	r2,-16(fp)
         win = win / 2 / tp->t_maxseg;
 823a3a4:	e0bffc17 	ldw	r2,-16(fp)
 823a3a8:	1006d07a 	srli	r3,r2,1
 823a3ac:	e0bffe17 	ldw	r2,-8(fp)
 823a3b0:	10800a0b 	ldhu	r2,40(r2)
 823a3b4:	10bfffcc 	andi	r2,r2,65535
 823a3b8:	100b883a 	mov	r5,r2
 823a3bc:	1809883a 	mov	r4,r3
 823a3c0:	8202c6c0 	call	8202c6c <__udivsi3>
 823a3c4:	e0bffc15 	stw	r2,-16(fp)
         if (win < 2)
 823a3c8:	e0bffc17 	ldw	r2,-16(fp)
 823a3cc:	108000a8 	cmpgeui	r2,r2,2
 823a3d0:	1000021e 	bne	r2,zero,823a3dc <tcp_timers+0x2a8>
            win = 2;
 823a3d4:	00800084 	movi	r2,2
 823a3d8:	e0bffc15 	stw	r2,-16(fp)
         tp->snd_cwnd = tp->t_maxseg;
 823a3dc:	e0bffe17 	ldw	r2,-8(fp)
 823a3e0:	10800a0b 	ldhu	r2,40(r2)
 823a3e4:	10ffffcc 	andi	r3,r2,65535
 823a3e8:	e0bffe17 	ldw	r2,-8(fp)
 823a3ec:	10c01b15 	stw	r3,108(r2)
         tp->snd_ssthresh = (u_short)win * tp->t_maxseg;
 823a3f0:	e0bffc17 	ldw	r2,-16(fp)
 823a3f4:	10ffffcc 	andi	r3,r2,65535
 823a3f8:	e0bffe17 	ldw	r2,-8(fp)
 823a3fc:	10800a0b 	ldhu	r2,40(r2)
 823a400:	10bfffcc 	andi	r2,r2,65535
 823a404:	1885383a 	mul	r2,r3,r2
 823a408:	1007883a 	mov	r3,r2
 823a40c:	e0bffe17 	ldw	r2,-8(fp)
 823a410:	10c01c15 	stw	r3,112(r2)
      }
      (void) tcp_output(tp);
 823a414:	e13ffe17 	ldw	r4,-8(fp)
 823a418:	823835c0 	call	823835c <tcp_output>
      break;
 823a41c:	00005f06 	br	823a59c <tcp_timers+0x468>
   /*
    * Persistance timer into zero window.
    * Force a byte to be output, if possible.
    */
   case TCPT_PERSIST:
      tcpstat.tcps_persisttimeo++;
 823a420:	008209b4 	movhi	r2,2086
 823a424:	10b9ad04 	addi	r2,r2,-6476
 823a428:	10800b17 	ldw	r2,44(r2)
 823a42c:	10c00044 	addi	r3,r2,1
 823a430:	008209b4 	movhi	r2,2086
 823a434:	10b9ad04 	addi	r2,r2,-6476
 823a438:	10c00b15 	stw	r3,44(r2)
      tcp_setpersist(tp);
 823a43c:	e13ffe17 	ldw	r4,-8(fp)
 823a440:	82393600 	call	8239360 <tcp_setpersist>
      tp->t_force = 1;
 823a444:	e0bffe17 	ldw	r2,-8(fp)
 823a448:	00c00044 	movi	r3,1
 823a44c:	10c00a85 	stb	r3,42(r2)
      (void) tcp_output(tp);
 823a450:	e13ffe17 	ldw	r4,-8(fp)
 823a454:	823835c0 	call	823835c <tcp_output>
      tp->t_force = 0;
 823a458:	e0bffe17 	ldw	r2,-8(fp)
 823a45c:	10000a85 	stb	zero,42(r2)
      break;
 823a460:	00004e06 	br	823a59c <tcp_timers+0x468>
   /*
    * Keep-alive timer went off; send something
    * or drop connection if idle for too long.
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
 823a464:	008209b4 	movhi	r2,2086
 823a468:	10b9ad04 	addi	r2,r2,-6476
 823a46c:	10800c17 	ldw	r2,48(r2)
 823a470:	10c00044 	addi	r3,r2,1
 823a474:	008209b4 	movhi	r2,2086
 823a478:	10b9ad04 	addi	r2,r2,-6476
 823a47c:	10c00c15 	stw	r3,48(r2)
      if (tp->t_state < TCPS_ESTABLISHED)
 823a480:	e0bffe17 	ldw	r2,-8(fp)
 823a484:	10800217 	ldw	r2,8(r2)
 823a488:	10800108 	cmpgei	r2,r2,4
 823a48c:	10003426 	beq	r2,zero,823a560 <tcp_timers+0x42c>
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 823a490:	e0bffe17 	ldw	r2,-8(fp)
 823a494:	10800d17 	ldw	r2,52(r2)
 823a498:	10800817 	ldw	r2,32(r2)
 823a49c:	10800417 	ldw	r2,16(r2)
 823a4a0:	1080020c 	andi	r2,r2,8
 823a4a4:	10002726 	beq	r2,zero,823a544 <tcp_timers+0x410>
          tp->t_state <= TCPS_CLOSE_WAIT) 
 823a4a8:	e0bffe17 	ldw	r2,-8(fp)
 823a4ac:	10800217 	ldw	r2,8(r2)
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
      if (tp->t_state < TCPS_ESTABLISHED)
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 823a4b0:	10800188 	cmpgei	r2,r2,6
 823a4b4:	1000231e 	bne	r2,zero,823a544 <tcp_timers+0x410>
          tp->t_state <= TCPS_CLOSE_WAIT) 
      {
         if (tp->t_idle >= tcp_keepidle + tcp_maxidle)
 823a4b8:	e0bffe17 	ldw	r2,-8(fp)
 823a4bc:	10c01d17 	ldw	r3,116(r2)
 823a4c0:	d1203e17 	ldw	r4,-32520(gp)
 823a4c4:	d0a0b417 	ldw	r2,-32048(gp)
 823a4c8:	2085883a 	add	r2,r4,r2
 823a4cc:	1880260e 	bge	r3,r2,823a568 <tcp_timers+0x434>
          * causes the transmitted zero-length segment
          * to lie outside the receive window;
          * by the protocol spec, this requires the
          * correspondent TCP to respond.
          */
         tcpstat.tcps_keepprobe++;
 823a4d0:	008209b4 	movhi	r2,2086
 823a4d4:	10b9ad04 	addi	r2,r2,-6476
 823a4d8:	10800d17 	ldw	r2,52(r2)
 823a4dc:	10c00044 	addi	r3,r2,1
 823a4e0:	008209b4 	movhi	r2,2086
 823a4e4:	10b9ad04 	addi	r2,r2,-6476
 823a4e8:	10c00d15 	stw	r3,52(r2)

         /*
          * The keepalive packet must have nonzero length
          * to get a 4.2 host to respond.
          */
         tcp_respond(tp, tp->t_template, tp->rcv_nxt - 1,
 823a4ec:	e0bffe17 	ldw	r2,-8(fp)
 823a4f0:	10c00c17 	ldw	r3,48(r2)
 823a4f4:	e0bffe17 	ldw	r2,-8(fp)
 823a4f8:	10801617 	ldw	r2,88(r2)
 823a4fc:	113fffc4 	addi	r4,r2,-1
            tp->snd_una - 1, 0, (struct mbuf *)NULL);
 823a500:	e0bffe17 	ldw	r2,-8(fp)
 823a504:	10800e17 	ldw	r2,56(r2)

         /*
          * The keepalive packet must have nonzero length
          * to get a 4.2 host to respond.
          */
         tcp_respond(tp, tp->t_template, tp->rcv_nxt - 1,
 823a508:	10bfffc4 	addi	r2,r2,-1
 823a50c:	d8000115 	stw	zero,4(sp)
 823a510:	d8000015 	stw	zero,0(sp)
 823a514:	100f883a 	mov	r7,r2
 823a518:	200d883a 	mov	r6,r4
 823a51c:	180b883a 	mov	r5,r3
 823a520:	e13ffe17 	ldw	r4,-8(fp)
 823a524:	82396840 	call	8239684 <tcp_respond>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
 823a528:	d0a03f17 	ldw	r2,-32516(gp)
 823a52c:	10ffffcc 	andi	r3,r2,65535
 823a530:	18e0001c 	xori	r3,r3,32768
 823a534:	18e00004 	addi	r3,r3,-32768
 823a538:	e0bffe17 	ldw	r2,-8(fp)
 823a53c:	10c00515 	stw	r3,20(r2)
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
      break;
 823a540:	00001606 	br	823a59c <tcp_timers+0x468>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
 823a544:	d0a03e17 	ldw	r2,-32520(gp)
 823a548:	10ffffcc 	andi	r3,r2,65535
 823a54c:	18e0001c 	xori	r3,r3,32768
 823a550:	18e00004 	addi	r3,r3,-32768
 823a554:	e0bffe17 	ldw	r2,-8(fp)
 823a558:	10c00515 	stw	r3,20(r2)
      break;
 823a55c:	00000f06 	br	823a59c <tcp_timers+0x468>
    * or drop connection if idle for too long.
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
      if (tp->t_state < TCPS_ESTABLISHED)
         goto dropit;
 823a560:	0001883a 	nop
 823a564:	00000106 	br	823a56c <tcp_timers+0x438>
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
          tp->t_state <= TCPS_CLOSE_WAIT) 
      {
         if (tp->t_idle >= tcp_keepidle + tcp_maxidle)
            goto dropit;
 823a568:	0001883a 	nop
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
      break;
      dropit:
      tcpstat.tcps_keepdrops++;
 823a56c:	008209b4 	movhi	r2,2086
 823a570:	10b9ad04 	addi	r2,r2,-6476
 823a574:	10800e17 	ldw	r2,56(r2)
 823a578:	10c00044 	addi	r3,r2,1
 823a57c:	008209b4 	movhi	r2,2086
 823a580:	10b9ad04 	addi	r2,r2,-6476
 823a584:	10c00e15 	stw	r3,56(r2)
      tp = tcp_drop (tp, ETIMEDOUT);
 823a588:	01401d04 	movi	r5,116
 823a58c:	e13ffe17 	ldw	r4,-8(fp)
 823a590:	8239b900 	call	8239b90 <tcp_drop>
 823a594:	e0bffe15 	stw	r2,-8(fp)
      break;
 823a598:	0001883a 	nop
   }
   return tp;
 823a59c:	e0bffe17 	ldw	r2,-8(fp)
}
 823a5a0:	e037883a 	mov	sp,fp
 823a5a4:	dfc00117 	ldw	ra,4(sp)
 823a5a8:	df000017 	ldw	fp,0(sp)
 823a5ac:	dec00204 	addi	sp,sp,8
 823a5b0:	f800283a 	ret

0823a5b4 <tcp_usrreq>:

int
tcp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 823a5b4:	defff604 	addi	sp,sp,-40
 823a5b8:	dfc00915 	stw	ra,36(sp)
 823a5bc:	df000815 	stw	fp,32(sp)
 823a5c0:	df000804 	addi	fp,sp,32
 823a5c4:	e13ffd15 	stw	r4,-12(fp)
 823a5c8:	e17ffe15 	stw	r5,-8(fp)
 823a5cc:	e1bfff15 	stw	r6,-4(fp)
   struct inpcb * inp;
   struct tcpcb * tp;
   int   error =  0;
 823a5d0:	e03ff915 	stw	zero,-28(fp)

#ifdef DO_TCPTRACE
   int   ostate;
#endif

   req = so->so_req;    /* get request from socket struct */
 823a5d4:	e0bffd17 	ldw	r2,-12(fp)
 823a5d8:	10800717 	ldw	r2,28(r2)
 823a5dc:	e0bffa15 	stw	r2,-24(fp)
   inp = sotoinpcb(so);
 823a5e0:	e0bffd17 	ldw	r2,-12(fp)
 823a5e4:	10800117 	ldw	r2,4(r2)
 823a5e8:	e0bffb15 	stw	r2,-20(fp)
   /*
    * When a TCP is attached to a socket, then there will be
    * a (struct inpcb) pointed at by the socket, and this
    * structure will point at a subsidary (struct tcpcb).
    */
   if (inp == 0 && req != PRU_ATTACH) 
 823a5ec:	e0bffb17 	ldw	r2,-20(fp)
 823a5f0:	1000041e 	bne	r2,zero,823a604 <tcp_usrreq+0x50>
 823a5f4:	e0bffa17 	ldw	r2,-24(fp)
 823a5f8:	10000226 	beq	r2,zero,823a604 <tcp_usrreq+0x50>
   {
      return (EINVAL);
 823a5fc:	00800584 	movi	r2,22
 823a600:	00019c06 	br	823ac74 <tcp_usrreq+0x6c0>
   }

   if (inp)
 823a604:	e0bffb17 	ldw	r2,-20(fp)
 823a608:	10000426 	beq	r2,zero,823a61c <tcp_usrreq+0x68>
      tp = intotcpcb(inp);
 823a60c:	e0bffb17 	ldw	r2,-20(fp)
 823a610:	10800917 	ldw	r2,36(r2)
 823a614:	e0bff815 	stw	r2,-32(fp)
 823a618:	00000706 	br	823a638 <tcp_usrreq+0x84>
   else  /* inp and tp not set, make sure this is OK: */
   { 
      if (req == PRU_ATTACH)
 823a61c:	e0bffa17 	ldw	r2,-24(fp)
 823a620:	1000021e 	bne	r2,zero,823a62c <tcp_usrreq+0x78>
         tp = NULL;  /* stifle compiler warnings about using unassigned tp*/
 823a624:	e03ff815 	stw	zero,-32(fp)
 823a628:	00000306 	br	823a638 <tcp_usrreq+0x84>
      else
      {
         dtrap(); /* programming error? */
 823a62c:	822d5f00 	call	822d5f0 <dtrap>
         return EINVAL;
 823a630:	00800584 	movi	r2,22
 823a634:	00018f06 	br	823ac74 <tcp_usrreq+0x6c0>
      }
   }

   switch (req) 
 823a638:	e0bffa17 	ldw	r2,-24(fp)
 823a63c:	10800528 	cmpgeui	r2,r2,20
 823a640:	1001761e 	bne	r2,zero,823ac1c <tcp_usrreq+0x668>
 823a644:	e0bffa17 	ldw	r2,-24(fp)
 823a648:	100690ba 	slli	r3,r2,2
 823a64c:	00820934 	movhi	r2,2084
 823a650:	10a99804 	addi	r2,r2,-22944
 823a654:	1885883a 	add	r2,r3,r2
 823a658:	10800017 	ldw	r2,0(r2)
 823a65c:	1000683a 	jmp	r2
 823a660:	0823a6b0 	cmpltui	zero,at,36506
 823a664:	0823a710 	cmplti	zero,at,-29028
 823a668:	0823a738 	rdprs	zero,at,-29028
 823a66c:	0823a770 	cmpltui	zero,at,36509
 823a670:	0823a7a8 	cmpgeui	zero,at,36510
 823a674:	0823a900 	call	823a90 <OSCtxSw_SWITCH_PC+0x823a50>
 823a678:	0823a8f4 	orhi	zero,at,36515
 823a67c:	0823a9b0 	cmpltui	zero,at,36518
 823a680:	0823a9dc 	xori	zero,at,36519
 823a684:	0823a9e8 	cmpgeui	zero,at,36519
 823a688:	0823aa44 	addi	zero,at,-29015
 823a68c:	0823ac1c 	xori	zero,at,36528
 823a690:	0823aa54 	ori	zero,at,36521
 823a694:	0823aa60 	cmpeqi	zero,at,-29015
 823a698:	0823ab18 	cmpnei	zero,at,-29012
 823a69c:	0823abe8 	cmpgeui	zero,at,36527
 823a6a0:	0823abf8 	rdprs	zero,at,-29009
 823a6a4:	0823a8e8 	cmpgeui	zero,at,36515
 823a6a8:	0823ac1c 	xori	zero,at,36528
 823a6ac:	0823ac08 	cmpgei	zero,at,-29008
   /*
    * TCP attaches to socket via PRU_ATTACH, reserving space,
    * and an internet control block.
    */
   case PRU_ATTACH:
      if (inp) 
 823a6b0:	e0bffb17 	ldw	r2,-20(fp)
 823a6b4:	10000326 	beq	r2,zero,823a6c4 <tcp_usrreq+0x110>
      {
         error = EISCONN;
 823a6b8:	00801fc4 	movi	r2,127
 823a6bc:	e0bff915 	stw	r2,-28(fp)
         break;
 823a6c0:	00016b06 	br	823ac70 <tcp_usrreq+0x6bc>
      }
      error = tcp_attach(so);
 823a6c4:	e13ffd17 	ldw	r4,-12(fp)
 823a6c8:	823ac880 	call	823ac88 <tcp_attach>
 823a6cc:	e0bff915 	stw	r2,-28(fp)
      if (error)
 823a6d0:	e0bff917 	ldw	r2,-28(fp)
 823a6d4:	1001551e 	bne	r2,zero,823ac2c <tcp_usrreq+0x678>
         break;
      if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 823a6d8:	e0bffd17 	ldw	r2,-12(fp)
 823a6dc:	10800417 	ldw	r2,16(r2)
 823a6e0:	1080200c 	andi	r2,r2,128
 823a6e4:	10015326 	beq	r2,zero,823ac34 <tcp_usrreq+0x680>
 823a6e8:	e0bffd17 	ldw	r2,-12(fp)
 823a6ec:	1080080b 	ldhu	r2,32(r2)
 823a6f0:	10bfffcc 	andi	r2,r2,65535
 823a6f4:	10a0001c 	xori	r2,r2,32768
 823a6f8:	10a00004 	addi	r2,r2,-32768
 823a6fc:	10014d1e 	bne	r2,zero,823ac34 <tcp_usrreq+0x680>
         so->so_linger = TCP_LINGERTIME;
 823a700:	e0bffd17 	ldw	r2,-12(fp)
 823a704:	00c01e04 	movi	r3,120
 823a708:	10c0080d 	sth	r3,32(r2)
#ifdef   DO_TCPTRACE
      SETTP(tp, sototcpcb(so));
#endif
      break;
 823a70c:	00014906 	br	823ac34 <tcp_usrreq+0x680>
    * do this directly: have to initiate a PRU_DISCONNECT,
    * which may finish later; embryonic TCB's can just
    * be discarded here.
    */
   case PRU_DETACH:
      if (tp->t_state > TCPS_LISTEN)
 823a710:	e0bff817 	ldw	r2,-32(fp)
 823a714:	10800217 	ldw	r2,8(r2)
 823a718:	10800090 	cmplti	r2,r2,2
 823a71c:	1000031e 	bne	r2,zero,823a72c <tcp_usrreq+0x178>
         SETTP(tp, tcp_disconnect(tp));
 823a720:	e13ff817 	ldw	r4,-32(fp)
 823a724:	823ada00 	call	823ada0 <tcp_disconnect>
      else
         SETTP(tp, tcp_close(tp));
      break;
 823a728:	00015106 	br	823ac70 <tcp_usrreq+0x6bc>
    */
   case PRU_DETACH:
      if (tp->t_state > TCPS_LISTEN)
         SETTP(tp, tcp_disconnect(tp));
      else
         SETTP(tp, tcp_close(tp));
 823a72c:	e13ff817 	ldw	r4,-32(fp)
 823a730:	8239c3c0 	call	8239c3c <tcp_close>
      break;
 823a734:	00014e06 	br	823ac70 <tcp_usrreq+0x6bc>
      /* bind is quite different for IPv4 and v6, so we use two 
       * seperate pcbbind routines. so_domain was checked for 
       * validity way up in t_bind()
       */
#ifdef IP_V4
      if(inp->inp_socket->so_domain == AF_INET)
 823a738:	e0bffb17 	ldw	r2,-20(fp)
 823a73c:	10800817 	ldw	r2,32(r2)
 823a740:	10800517 	ldw	r2,20(r2)
 823a744:	10800098 	cmpnei	r2,r2,2
 823a748:	1000051e 	bne	r2,zero,823a760 <tcp_usrreq+0x1ac>
      {
         error = in_pcbbind(inp, nam);
 823a74c:	e17fff17 	ldw	r5,-4(fp)
 823a750:	e13ffb17 	ldw	r4,-20(fp)
 823a754:	8247f740 	call	8247f74 <in_pcbbind>
 823a758:	e0bff915 	stw	r2,-28(fp)
         break;
 823a75c:	00014406 	br	823ac70 <tcp_usrreq+0x6bc>
      {
         error = ip6_pcbbind(inp, nam);
         break;
      }
#endif /* IP_V6 */
      dtrap();    /* not v4 or v6? */
 823a760:	822d5f00 	call	822d5f0 <dtrap>
      error = EINVAL;
 823a764:	00800584 	movi	r2,22
 823a768:	e0bff915 	stw	r2,-28(fp)
      break;
 823a76c:	00014006 	br	823ac70 <tcp_usrreq+0x6bc>
   /*
    * Prepare to accept connections.
    */
   case PRU_LISTEN:
      if (inp->inp_lport == 0)
 823a770:	e0bffb17 	ldw	r2,-20(fp)
 823a774:	1080078b 	ldhu	r2,30(r2)
 823a778:	10bfffcc 	andi	r2,r2,65535
 823a77c:	1000041e 	bne	r2,zero,823a790 <tcp_usrreq+0x1dc>
         error = in_pcbbind(inp, (struct mbuf *)0);
 823a780:	000b883a 	mov	r5,zero
 823a784:	e13ffb17 	ldw	r4,-20(fp)
 823a788:	8247f740 	call	8247f74 <in_pcbbind>
 823a78c:	e0bff915 	stw	r2,-28(fp)
      if (error == 0)
 823a790:	e0bff917 	ldw	r2,-28(fp)
 823a794:	1001291e 	bne	r2,zero,823ac3c <tcp_usrreq+0x688>
         tp->t_state = TCPS_LISTEN;
 823a798:	e0bff817 	ldw	r2,-32(fp)
 823a79c:	00c00044 	movi	r3,1
 823a7a0:	10c00215 	stw	r3,8(r2)
      break;
 823a7a4:	00012506 	br	823ac3c <tcp_usrreq+0x688>
    * Enter SYN_SENT state, and mark socket as connecting.
    * Start keep-alive timer, and seed output sequence space.
    * Send initial segment on connection.
    */
   case PRU_CONNECT:
      if (inp->inp_lport == 0) 
 823a7a8:	e0bffb17 	ldw	r2,-20(fp)
 823a7ac:	1080078b 	ldhu	r2,30(r2)
 823a7b0:	10bfffcc 	andi	r2,r2,65535
 823a7b4:	1000061e 	bne	r2,zero,823a7d0 <tcp_usrreq+0x21c>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbbind(inp, (struct mbuf *)0);
 823a7b8:	000b883a 	mov	r5,zero
 823a7bc:	e13ffb17 	ldw	r4,-20(fp)
 823a7c0:	8247f740 	call	8247f74 <in_pcbbind>
 823a7c4:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbbind(inp, (struct mbuf *)0);
#endif   /* end v6 only */

         if (error)
 823a7c8:	e0bff917 	ldw	r2,-28(fp)
 823a7cc:	10011d1e 	bne	r2,zero,823ac44 <tcp_usrreq+0x690>
            break;
      }

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbconnect(inp, nam);
 823a7d0:	e17fff17 	ldw	r5,-4(fp)
 823a7d4:	e13ffb17 	ldw	r4,-20(fp)
 823a7d8:	82481840 	call	8248184 <in_pcbconnect>
 823a7dc:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbconnect(inp, nam);
#endif   /* end v6 only */

      if (error)
 823a7e0:	e0bff917 	ldw	r2,-28(fp)
 823a7e4:	1001191e 	bne	r2,zero,823ac4c <tcp_usrreq+0x698>
         break;
      tp->t_template = tcp_template(tp);
 823a7e8:	e13ff817 	ldw	r4,-32(fp)
 823a7ec:	823957c0 	call	823957c <tcp_template>
 823a7f0:	1007883a 	mov	r3,r2
 823a7f4:	e0bff817 	ldw	r2,-32(fp)
 823a7f8:	10c00c15 	stw	r3,48(r2)
      if (tp->t_template == 0) 
 823a7fc:	e0bff817 	ldw	r2,-32(fp)
 823a800:	10800c17 	ldw	r2,48(r2)
 823a804:	1000051e 	bne	r2,zero,823a81c <tcp_usrreq+0x268>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
         in_pcbdisconnect(inp);
 823a808:	e13ffb17 	ldw	r4,-20(fp)
 823a80c:	82483640 	call	8248364 <in_pcbdisconnect>
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
         ip6_pcbdisconnect(inp);
#endif   /* end v6 only */

         error = ENOBUFS;
 823a810:	00801a44 	movi	r2,105
 823a814:	e0bff915 	stw	r2,-28(fp)
         break;
 823a818:	00011506 	br	823ac70 <tcp_usrreq+0x6bc>
      }

      soisconnecting(so);
 823a81c:	e13ffd17 	ldw	r4,-12(fp)
 823a820:	8233ac40 	call	8233ac4 <soisconnecting>
      tcpstat.tcps_connattempt++;
 823a824:	008209b4 	movhi	r2,2086
 823a828:	10b9ad04 	addi	r2,r2,-6476
 823a82c:	10800017 	ldw	r2,0(r2)
 823a830:	10c00044 	addi	r3,r2,1
 823a834:	008209b4 	movhi	r2,2086
 823a838:	10b9ad04 	addi	r2,r2,-6476
 823a83c:	10c00015 	stw	r3,0(r2)
      tp->t_state = TCPS_SYN_SENT;
 823a840:	e0bff817 	ldw	r2,-32(fp)
 823a844:	00c00084 	movi	r3,2
 823a848:	10c00215 	stw	r3,8(r2)
      tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 823a84c:	e0bff817 	ldw	r2,-32(fp)
 823a850:	00c02584 	movi	r3,150
 823a854:	10c00515 	stw	r3,20(r2)
      tp->iss = tcp_iss; 
 823a858:	d0e0b517 	ldw	r3,-32044(gp)
 823a85c:	e0bff817 	ldw	r2,-32(fp)
 823a860:	10c01315 	stw	r3,76(r2)
      tcp_iss += (tcp_seq)(TCP_ISSINCR/2);
 823a864:	d0e0b517 	ldw	r3,-32044(gp)
 823a868:	00be9fd4 	movui	r2,64127
 823a86c:	1885883a 	add	r2,r3,r2
 823a870:	d0a0b515 	stw	r2,-32044(gp)
      tcp_sendseqinit(tp);
 823a874:	e0bff817 	ldw	r2,-32(fp)
 823a878:	10c01317 	ldw	r3,76(r2)
 823a87c:	e0bff817 	ldw	r2,-32(fp)
 823a880:	10c01015 	stw	r3,64(r2)
 823a884:	e0bff817 	ldw	r2,-32(fp)
 823a888:	10c01017 	ldw	r3,64(r2)
 823a88c:	e0bff817 	ldw	r2,-32(fp)
 823a890:	10c01a15 	stw	r3,104(r2)
 823a894:	e0bff817 	ldw	r2,-32(fp)
 823a898:	10c01a17 	ldw	r3,104(r2)
 823a89c:	e0bff817 	ldw	r2,-32(fp)
 823a8a0:	10c00f15 	stw	r3,60(r2)
 823a8a4:	e0bff817 	ldw	r2,-32(fp)
 823a8a8:	10c00f17 	ldw	r3,60(r2)
 823a8ac:	e0bff817 	ldw	r2,-32(fp)
 823a8b0:	10c00e15 	stw	r3,56(r2)
      error = tcp_output(tp);
 823a8b4:	e13ff817 	ldw	r4,-32(fp)
 823a8b8:	823835c0 	call	823835c <tcp_output>
 823a8bc:	e0bff915 	stw	r2,-28(fp)
      if (!error)
 823a8c0:	e0bff917 	ldw	r2,-28(fp)
 823a8c4:	1000e31e 	bne	r2,zero,823ac54 <tcp_usrreq+0x6a0>
         TCP_MIB_INC(tcpActiveOpens);     /* keep MIB stats */
 823a8c8:	008209b4 	movhi	r2,2086
 823a8cc:	10b97f04 	addi	r2,r2,-6660
 823a8d0:	10800417 	ldw	r2,16(r2)
 823a8d4:	10c00044 	addi	r3,r2,1
 823a8d8:	008209b4 	movhi	r2,2086
 823a8dc:	10b97f04 	addi	r2,r2,-6660
 823a8e0:	10c00415 	stw	r3,16(r2)
      break;
 823a8e4:	0000db06 	br	823ac54 <tcp_usrreq+0x6a0>

   /*
    * Create a TCP connection between two sockets.
    */
   case PRU_CONNECT2:
      error = EOPNOTSUPP;
 823a8e8:	008017c4 	movi	r2,95
 823a8ec:	e0bff915 	stw	r2,-28(fp)
      break;
 823a8f0:	0000df06 	br	823ac70 <tcp_usrreq+0x6bc>
    * when peer sends FIN and acks ours.
    *
    * SHOULD IMPLEMENT LATER PRU_CONNECT VIA REALLOC TCPCB.
    */
   case PRU_DISCONNECT:
      SETTP(tp, tcp_disconnect(tp));
 823a8f4:	e13ff817 	ldw	r4,-32(fp)
 823a8f8:	823ada00 	call	823ada0 <tcp_disconnect>
      break;
 823a8fc:	0000dc06 	br	823ac70 <tcp_usrreq+0x6bc>
    * done at higher levels; just return the address
    * of the peer, storing through addr.
    */
   case PRU_ACCEPT: 
   {
         struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 823a900:	e0bfff17 	ldw	r2,-4(fp)
 823a904:	10800317 	ldw	r2,12(r2)
 823a908:	e0bffc15 	stw	r2,-16(fp)
            IP6CPY(&sin6->sin6_addr, &inp->ip6_faddr);
         }
#endif

#ifdef IP_V4
         if (so->so_domain == AF_INET)
 823a90c:	e0bffd17 	ldw	r2,-12(fp)
 823a910:	10800517 	ldw	r2,20(r2)
 823a914:	10800098 	cmpnei	r2,r2,2
 823a918:	10000e1e 	bne	r2,zero,823a954 <tcp_usrreq+0x3a0>
         {
            nam->m_len = sizeof (struct sockaddr_in);
 823a91c:	e0bfff17 	ldw	r2,-4(fp)
 823a920:	00c00404 	movi	r3,16
 823a924:	10c00215 	stw	r3,8(r2)
            sin->sin_family = AF_INET;
 823a928:	e0bffc17 	ldw	r2,-16(fp)
 823a92c:	00c00084 	movi	r3,2
 823a930:	10c0000d 	sth	r3,0(r2)
            sin->sin_port = inp->inp_fport;
 823a934:	e0bffb17 	ldw	r2,-20(fp)
 823a938:	10c0070b 	ldhu	r3,28(r2)
 823a93c:	e0bffc17 	ldw	r2,-16(fp)
 823a940:	10c0008d 	sth	r3,2(r2)
            sin->sin_addr = inp->inp_faddr;
 823a944:	e0bffc17 	ldw	r2,-16(fp)
 823a948:	e0fffb17 	ldw	r3,-20(fp)
 823a94c:	18c00317 	ldw	r3,12(r3)
 823a950:	10c00115 	stw	r3,4(r2)
         }
#endif
         if ( !(so->so_domain == AF_INET) &&
 823a954:	e0bffd17 	ldw	r2,-12(fp)
 823a958:	10800517 	ldw	r2,20(r2)
 823a95c:	108000a0 	cmpeqi	r2,r2,2
 823a960:	10000b1e 	bne	r2,zero,823a990 <tcp_usrreq+0x3dc>
              !(so->so_domain == AF_INET6)
 823a964:	e0bffd17 	ldw	r2,-12(fp)
 823a968:	10800517 	ldw	r2,20(r2)
            sin->sin_family = AF_INET;
            sin->sin_port = inp->inp_fport;
            sin->sin_addr = inp->inp_faddr;
         }
#endif
         if ( !(so->so_domain == AF_INET) &&
 823a96c:	108000e0 	cmpeqi	r2,r2,3
 823a970:	1000071e 	bne	r2,zero,823a990 <tcp_usrreq+0x3dc>
              !(so->so_domain == AF_INET6)
             )
         {
            dprintf("*** PRU_ACCEPT bad domain = %d\n", so->so_domain);
 823a974:	e0bffd17 	ldw	r2,-12(fp)
 823a978:	10800517 	ldw	r2,20(r2)
 823a97c:	100b883a 	mov	r5,r2
 823a980:	01020974 	movhi	r4,2085
 823a984:	2103dd04 	addi	r4,r4,3956
 823a988:	82033fc0 	call	82033fc <printf>
            dtrap();
 823a98c:	822d5f00 	call	822d5f0 <dtrap>
         } 
         TCP_MIB_INC(tcpPassiveOpens);    /* keep MIB stats */
 823a990:	008209b4 	movhi	r2,2086
 823a994:	10b97f04 	addi	r2,r2,-6660
 823a998:	10800517 	ldw	r2,20(r2)
 823a99c:	10c00044 	addi	r3,r2,1
 823a9a0:	008209b4 	movhi	r2,2086
 823a9a4:	10b97f04 	addi	r2,r2,-6660
 823a9a8:	10c00515 	stw	r3,20(r2)
         break;
 823a9ac:	0000b006 	br	823ac70 <tcp_usrreq+0x6bc>

   /*
    * Mark the connection as being incapable of further output.
    */
   case PRU_SHUTDOWN:
      socantsendmore(so);
 823a9b0:	e13ffd17 	ldw	r4,-12(fp)
 823a9b4:	82341480 	call	8234148 <socantsendmore>
      tp = tcp_usrclosed(tp);
 823a9b8:	e13ff817 	ldw	r4,-32(fp)
 823a9bc:	823ae6c0 	call	823ae6c <tcp_usrclosed>
 823a9c0:	e0bff815 	stw	r2,-32(fp)
      if (tp)
 823a9c4:	e0bff817 	ldw	r2,-32(fp)
 823a9c8:	1000a426 	beq	r2,zero,823ac5c <tcp_usrreq+0x6a8>
         error = tcp_output(tp);
 823a9cc:	e13ff817 	ldw	r4,-32(fp)
 823a9d0:	823835c0 	call	823835c <tcp_output>
 823a9d4:	e0bff915 	stw	r2,-28(fp)
      break;
 823a9d8:	0000a006 	br	823ac5c <tcp_usrreq+0x6a8>

   /*
    * After a receive, possibly send window update to peer.
    */
   case PRU_RCVD:
      (void) tcp_output(tp);
 823a9dc:	e13ff817 	ldw	r4,-32(fp)
 823a9e0:	823835c0 	call	823835c <tcp_output>
      break;
 823a9e4:	0000a206 	br	823ac70 <tcp_usrreq+0x6bc>
   /*
    * Do a send by putting data in output queue and updating urgent
    * marker if URG set.  Possibly send more data.
    */
   case PRU_SEND:
      if (so->so_pcb == NULL)
 823a9e8:	e0bffd17 	ldw	r2,-12(fp)
 823a9ec:	10800117 	ldw	r2,4(r2)
 823a9f0:	1000031e 	bne	r2,zero,823aa00 <tcp_usrreq+0x44c>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 823a9f4:	00800804 	movi	r2,32
 823a9f8:	e0bff915 	stw	r2,-28(fp)
         break;
 823a9fc:	00009c06 	br	823ac70 <tcp_usrreq+0x6bc>
      }
      sbappend(&so->so_snd, m);
 823aa00:	e0bffd17 	ldw	r2,-12(fp)
 823aa04:	10801204 	addi	r2,r2,72
 823aa08:	e17ffe17 	ldw	r5,-8(fp)
 823aa0c:	1009883a 	mov	r4,r2
 823aa10:	82344500 	call	8234450 <sbappend>
      error = tcp_output(tp);
 823aa14:	e13ff817 	ldw	r4,-32(fp)
 823aa18:	823835c0 	call	823835c <tcp_output>
 823aa1c:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 823aa20:	e0bff917 	ldw	r2,-28(fp)
 823aa24:	10801a58 	cmpnei	r2,r2,105
 823aa28:	10008e1e 	bne	r2,zero,823ac64 <tcp_usrreq+0x6b0>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 823aa2c:	e0bffd17 	ldw	r2,-12(fp)
 823aa30:	10801204 	addi	r2,r2,72
 823aa34:	e17ffe17 	ldw	r5,-8(fp)
 823aa38:	1009883a 	mov	r4,r2
 823aa3c:	8234bc00 	call	8234bc0 <sbdropend>
      break;
 823aa40:	00008806 	br	823ac64 <tcp_usrreq+0x6b0>

   /*
    * Abort the TCP.
    */
   case PRU_ABORT:
      SETTP(tp, tcp_drop(tp, ECONNABORTED));
 823aa44:	01401c44 	movi	r5,113
 823aa48:	e13ff817 	ldw	r4,-32(fp)
 823aa4c:	8239b900 	call	8239b90 <tcp_drop>
      break;
 823aa50:	00008706 	br	823ac70 <tcp_usrreq+0x6bc>

   case PRU_SENSE:
      /*      ((struct stat *) m)->st_blksize = so->so_snd.sb_hiwat; */
      dtrap();    /* does this ever happen? */
 823aa54:	822d5f00 	call	822d5f0 <dtrap>
      return (0);
 823aa58:	0005883a 	mov	r2,zero
 823aa5c:	00008506 	br	823ac74 <tcp_usrreq+0x6c0>

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
 823aa60:	e0bffd17 	ldw	r2,-12(fp)
 823aa64:	10801a17 	ldw	r2,104(r2)
 823aa68:	1000051e 	bne	r2,zero,823aa80 <tcp_usrreq+0x4cc>
          (so->so_state & SS_RCVATMARK) == 0) ||
 823aa6c:	e0bffd17 	ldw	r2,-12(fp)
 823aa70:	1080088b 	ldhu	r2,34(r2)
 823aa74:	10bfffcc 	andi	r2,r2,65535
 823aa78:	1080100c 	andi	r2,r2,64
      /*      ((struct stat *) m)->st_blksize = so->so_snd.sb_hiwat; */
      dtrap();    /* does this ever happen? */
      return (0);

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
 823aa7c:	10000926 	beq	r2,zero,823aaa4 <tcp_usrreq+0x4f0>
          (so->so_state & SS_RCVATMARK) == 0) ||
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
 823aa80:	e0bffd17 	ldw	r2,-12(fp)
 823aa84:	10800417 	ldw	r2,16(r2)
 823aa88:	1080400c 	andi	r2,r2,256
      dtrap();    /* does this ever happen? */
      return (0);

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
          (so->so_state & SS_RCVATMARK) == 0) ||
 823aa8c:	1000051e 	bne	r2,zero,823aaa4 <tcp_usrreq+0x4f0>
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
#endif
       tp->t_oobflags & TCPOOB_HADDATA) 
 823aa90:	e0bff817 	ldw	r2,-32(fp)
 823aa94:	10802403 	ldbu	r2,144(r2)
 823aa98:	10803fcc 	andi	r2,r2,255
 823aa9c:	1080008c 	andi	r2,r2,2

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
          (so->so_state & SS_RCVATMARK) == 0) ||
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
 823aaa0:	10000326 	beq	r2,zero,823aab0 <tcp_usrreq+0x4fc>
#endif
       tp->t_oobflags & TCPOOB_HADDATA) 
       {
         error = EINVAL;
 823aaa4:	00800584 	movi	r2,22
 823aaa8:	e0bff915 	stw	r2,-28(fp)
         break;
 823aaac:	00007006 	br	823ac70 <tcp_usrreq+0x6bc>
      }
      if ((tp->t_oobflags & TCPOOB_HAVEDATA) == 0) 
 823aab0:	e0bff817 	ldw	r2,-32(fp)
 823aab4:	10802403 	ldbu	r2,144(r2)
 823aab8:	10803fcc 	andi	r2,r2,255
 823aabc:	1080004c 	andi	r2,r2,1
 823aac0:	1000031e 	bne	r2,zero,823aad0 <tcp_usrreq+0x51c>
      {
         error = EWOULDBLOCK;
 823aac4:	008002c4 	movi	r2,11
 823aac8:	e0bff915 	stw	r2,-28(fp)
         break;
 823aacc:	00006806 	br	823ac70 <tcp_usrreq+0x6bc>
      }
      m->m_len = 1;
 823aad0:	e0bffe17 	ldw	r2,-8(fp)
 823aad4:	00c00044 	movi	r3,1
 823aad8:	10c00215 	stw	r3,8(r2)
      *mtod(m, char *) = tp->t_iobc;
 823aadc:	e0bffe17 	ldw	r2,-8(fp)
 823aae0:	10800317 	ldw	r2,12(r2)
 823aae4:	e0fff817 	ldw	r3,-32(fp)
 823aae8:	18c02443 	ldbu	r3,145(r3)
 823aaec:	10c00005 	stb	r3,0(r2)
      if ((MBUF2LONG(nam) & MSG_PEEK) == 0)
 823aaf0:	e0bfff17 	ldw	r2,-4(fp)
 823aaf4:	1080008c 	andi	r2,r2,2
 823aaf8:	10005c1e 	bne	r2,zero,823ac6c <tcp_usrreq+0x6b8>
         tp->t_oobflags ^= (TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 823aafc:	e0bff817 	ldw	r2,-32(fp)
 823ab00:	10802403 	ldbu	r2,144(r2)
 823ab04:	108000dc 	xori	r2,r2,3
 823ab08:	1007883a 	mov	r3,r2
 823ab0c:	e0bff817 	ldw	r2,-32(fp)
 823ab10:	10c02405 	stb	r3,144(r2)
      break;
 823ab14:	00005506 	br	823ac6c <tcp_usrreq+0x6b8>

   case PRU_SENDOOB:
      if (so->so_pcb == NULL)
 823ab18:	e0bffd17 	ldw	r2,-12(fp)
 823ab1c:	10800117 	ldw	r2,4(r2)
 823ab20:	1000031e 	bne	r2,zero,823ab30 <tcp_usrreq+0x57c>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 823ab24:	00800804 	movi	r2,32
 823ab28:	e0bff915 	stw	r2,-28(fp)
         break;
 823ab2c:	00005006 	br	823ac70 <tcp_usrreq+0x6bc>
      }
      if (sbspace(&so->so_snd) == 0) 
 823ab30:	e0bffd17 	ldw	r2,-12(fp)
 823ab34:	10801317 	ldw	r2,76(r2)
 823ab38:	1007883a 	mov	r3,r2
 823ab3c:	e0bffd17 	ldw	r2,-12(fp)
 823ab40:	10801217 	ldw	r2,72(r2)
 823ab44:	1885c83a 	sub	r2,r3,r2
 823ab48:	10000516 	blt	r2,zero,823ab60 <tcp_usrreq+0x5ac>
 823ab4c:	e0bffd17 	ldw	r2,-12(fp)
 823ab50:	10c01317 	ldw	r3,76(r2)
 823ab54:	e0bffd17 	ldw	r2,-12(fp)
 823ab58:	10801217 	ldw	r2,72(r2)
 823ab5c:	1880051e 	bne	r3,r2,823ab74 <tcp_usrreq+0x5c0>
      {
         m_freem(m);
 823ab60:	e13ffe17 	ldw	r4,-8(fp)
 823ab64:	822e6940 	call	822e694 <m_freem>
         error = ENOBUFS;
 823ab68:	00801a44 	movi	r2,105
 823ab6c:	e0bff915 	stw	r2,-28(fp)
         break;
 823ab70:	00003f06 	br	823ac70 <tcp_usrreq+0x6bc>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section.
       * Otherwise, snd_up should be one lower.
       */
      sbappend(&so->so_snd, m);
 823ab74:	e0bffd17 	ldw	r2,-12(fp)
 823ab78:	10801204 	addi	r2,r2,72
 823ab7c:	e17ffe17 	ldw	r5,-8(fp)
 823ab80:	1009883a 	mov	r4,r2
 823ab84:	82344500 	call	8234450 <sbappend>
      tp->snd_up = tp->snd_una + so->so_snd.sb_cc;
 823ab88:	e0bff817 	ldw	r2,-32(fp)
 823ab8c:	10c00e17 	ldw	r3,56(r2)
 823ab90:	e0bffd17 	ldw	r2,-12(fp)
 823ab94:	10801217 	ldw	r2,72(r2)
 823ab98:	1887883a 	add	r3,r3,r2
 823ab9c:	e0bff817 	ldw	r2,-32(fp)
 823aba0:	10c01015 	stw	r3,64(r2)
      tp->t_force = 1;
 823aba4:	e0bff817 	ldw	r2,-32(fp)
 823aba8:	00c00044 	movi	r3,1
 823abac:	10c00a85 	stb	r3,42(r2)
      error = tcp_output(tp);
 823abb0:	e13ff817 	ldw	r4,-32(fp)
 823abb4:	823835c0 	call	823835c <tcp_output>
 823abb8:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 823abbc:	e0bff917 	ldw	r2,-28(fp)
 823abc0:	10801a58 	cmpnei	r2,r2,105
 823abc4:	1000051e 	bne	r2,zero,823abdc <tcp_usrreq+0x628>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 823abc8:	e0bffd17 	ldw	r2,-12(fp)
 823abcc:	10801204 	addi	r2,r2,72
 823abd0:	e17ffe17 	ldw	r5,-8(fp)
 823abd4:	1009883a 	mov	r4,r2
 823abd8:	8234bc00 	call	8234bc0 <sbdropend>
      tp->t_force = 0;
 823abdc:	e0bff817 	ldw	r2,-32(fp)
 823abe0:	10000a85 	stb	zero,42(r2)
      break;
 823abe4:	00002206 	br	823ac70 <tcp_usrreq+0x6bc>
   case PRU_SOCKADDR:

   /* sockaddr and peeraddr have to switch based on IP type */
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setsockaddr(inp, nam);
 823abe8:	e17fff17 	ldw	r5,-4(fp)
 823abec:	e13ffb17 	ldw	r4,-20(fp)
 823abf0:	82483c00 	call	82483c0 <in_setsockaddr>
         in_setsockaddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setsockaddr(inp, nam);
#endif
      break;         
 823abf4:	00001e06 	br	823ac70 <tcp_usrreq+0x6bc>

   case PRU_PEERADDR:
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setpeeraddr(inp, nam);
 823abf8:	e17fff17 	ldw	r5,-4(fp)
 823abfc:	e13ffb17 	ldw	r4,-20(fp)
 823ac00:	82484440 	call	8248444 <in_setpeeraddr>
         in_setpeeraddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setpeeraddr(inp, nam);
#endif
      break;
 823ac04:	00001a06 	br	823ac70 <tcp_usrreq+0x6bc>

   case PRU_SLOWTIMO:
      SETTP(tp, tcp_timers(tp, (int)MBUF2LONG(nam)));
 823ac08:	e0bfff17 	ldw	r2,-4(fp)
 823ac0c:	100b883a 	mov	r5,r2
 823ac10:	e13ff817 	ldw	r4,-32(fp)
 823ac14:	823a1340 	call	823a134 <tcp_timers>
#ifdef DO_TCPTRACE
      req |= (long)nam << 8;        /* for debug's sake */
#endif
      break;
 823ac18:	00001506 	br	823ac70 <tcp_usrreq+0x6bc>

      default:
      panic("tcp_usrreq");
 823ac1c:	01020974 	movhi	r4,2085
 823ac20:	2103e504 	addi	r4,r4,3988
 823ac24:	8228ca40 	call	8228ca4 <panic>
 823ac28:	00001106 	br	823ac70 <tcp_usrreq+0x6bc>
         error = EISCONN;
         break;
      }
      error = tcp_attach(so);
      if (error)
         break;
 823ac2c:	0001883a 	nop
 823ac30:	00000f06 	br	823ac70 <tcp_usrreq+0x6bc>
      if ((so->so_options & SO_LINGER) && so->so_linger == 0)
         so->so_linger = TCP_LINGERTIME;
#ifdef   DO_TCPTRACE
      SETTP(tp, sototcpcb(so));
#endif
      break;
 823ac34:	0001883a 	nop
 823ac38:	00000d06 	br	823ac70 <tcp_usrreq+0x6bc>
   case PRU_LISTEN:
      if (inp->inp_lport == 0)
         error = in_pcbbind(inp, (struct mbuf *)0);
      if (error == 0)
         tp->t_state = TCPS_LISTEN;
      break;
 823ac3c:	0001883a 	nop
 823ac40:	00000b06 	br	823ac70 <tcp_usrreq+0x6bc>
#else    /* no v4, v6 only */
      error = ip6_pcbbind(inp, (struct mbuf *)0);
#endif   /* end v6 only */

         if (error)
            break;
 823ac44:	0001883a 	nop
 823ac48:	00000906 	br	823ac70 <tcp_usrreq+0x6bc>
#else    /* no v4, v6 only */
      error = ip6_pcbconnect(inp, nam);
#endif   /* end v6 only */

      if (error)
         break;
 823ac4c:	0001883a 	nop
 823ac50:	00000706 	br	823ac70 <tcp_usrreq+0x6bc>
      tcp_iss += (tcp_seq)(TCP_ISSINCR/2);
      tcp_sendseqinit(tp);
      error = tcp_output(tp);
      if (!error)
         TCP_MIB_INC(tcpActiveOpens);     /* keep MIB stats */
      break;
 823ac54:	0001883a 	nop
 823ac58:	00000506 	br	823ac70 <tcp_usrreq+0x6bc>
   case PRU_SHUTDOWN:
      socantsendmore(so);
      tp = tcp_usrclosed(tp);
      if (tp)
         error = tcp_output(tp);
      break;
 823ac5c:	0001883a 	nop
 823ac60:	00000306 	br	823ac70 <tcp_usrreq+0x6bc>
      }
      sbappend(&so->so_snd, m);
      error = tcp_output(tp);
      if (error == ENOBUFS)
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
      break;
 823ac64:	0001883a 	nop
 823ac68:	00000106 	br	823ac70 <tcp_usrreq+0x6bc>
      }
      m->m_len = 1;
      *mtod(m, char *) = tp->t_iobc;
      if ((MBUF2LONG(nam) & MSG_PEEK) == 0)
         tp->t_oobflags ^= (TCPOOB_HAVEDATA | TCPOOB_HADDATA);
      break;
 823ac6c:	0001883a 	nop
#ifdef DO_TCPTRACE
   if (tp && (so->so_options & SO_DEBUG))
      tcp_trace("usrreq: state: %d, tcpcb: %x, req: %d",
    ostate, tp, req);
#endif
   return (error);
 823ac70:	e0bff917 	ldw	r2,-28(fp)
}
 823ac74:	e037883a 	mov	sp,fp
 823ac78:	dfc00117 	ldw	ra,4(sp)
 823ac7c:	df000017 	ldw	fp,0(sp)
 823ac80:	dec00204 	addi	sp,sp,8
 823ac84:	f800283a 	ret

0823ac88 <tcp_attach>:
 * RETURNS: 0 if OK, or nonzero error code.
 */

int
tcp_attach(struct socket * so)
{
 823ac88:	defff904 	addi	sp,sp,-28
 823ac8c:	dfc00615 	stw	ra,24(sp)
 823ac90:	df000515 	stw	fp,20(sp)
 823ac94:	df000504 	addi	fp,sp,20
 823ac98:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp;
   struct inpcb * inp;
   int   error;

   if (so->so_snd.sb_hiwat == 0 || so->so_rcv.sb_hiwat == 0) 
 823ac9c:	e0bfff17 	ldw	r2,-4(fp)
 823aca0:	10801317 	ldw	r2,76(r2)
 823aca4:	10000326 	beq	r2,zero,823acb4 <tcp_attach+0x2c>
 823aca8:	e0bfff17 	ldw	r2,-4(fp)
 823acac:	10800b17 	ldw	r2,44(r2)
 823acb0:	10000b1e 	bne	r2,zero,823ace0 <tcp_attach+0x58>
   {
      error = soreserve(so, tcp_sendspace, tcp_recvspace);
 823acb4:	d0a04017 	ldw	r2,-32512(gp)
 823acb8:	d0e04117 	ldw	r3,-32508(gp)
 823acbc:	180d883a 	mov	r6,r3
 823acc0:	100b883a 	mov	r5,r2
 823acc4:	e13fff17 	ldw	r4,-4(fp)
 823acc8:	823432c0 	call	823432c <soreserve>
 823accc:	e0bffb15 	stw	r2,-20(fp)
      if (error)
 823acd0:	e0bffb17 	ldw	r2,-20(fp)
 823acd4:	10000226 	beq	r2,zero,823ace0 <tcp_attach+0x58>
         return (error);
 823acd8:	e0bffb17 	ldw	r2,-20(fp)
 823acdc:	00002b06 	br	823ad8c <tcp_attach+0x104>
   }
   error = in_pcballoc(so, &tcb);
 823ace0:	014209b4 	movhi	r5,2086
 823ace4:	2979a204 	addi	r5,r5,-6520
 823ace8:	e13fff17 	ldw	r4,-4(fp)
 823acec:	8247e940 	call	8247e94 <in_pcballoc>
 823acf0:	e0bffb15 	stw	r2,-20(fp)
   if (error)
 823acf4:	e0bffb17 	ldw	r2,-20(fp)
 823acf8:	10000226 	beq	r2,zero,823ad04 <tcp_attach+0x7c>
      return (error);
 823acfc:	e0bffb17 	ldw	r2,-20(fp)
 823ad00:	00002206 	br	823ad8c <tcp_attach+0x104>
   inp = sotoinpcb(so);
 823ad04:	e0bfff17 	ldw	r2,-4(fp)
 823ad08:	10800117 	ldw	r2,4(r2)
 823ad0c:	e0bffc15 	stw	r2,-16(fp)
   tp = tcp_newtcpcb(inp);
 823ad10:	e13ffc17 	ldw	r4,-16(fp)
 823ad14:	8239a840 	call	8239a84 <tcp_newtcpcb>
 823ad18:	e0bffd15 	stw	r2,-12(fp)
   if (tp == 0) 
 823ad1c:	e0bffd17 	ldw	r2,-12(fp)
 823ad20:	1000171e 	bne	r2,zero,823ad80 <tcp_attach+0xf8>
   {
      int   nofd  =  so->so_state   &  SS_NOFDREF; /* XXX */
 823ad24:	e0bfff17 	ldw	r2,-4(fp)
 823ad28:	1080088b 	ldhu	r2,34(r2)
 823ad2c:	10bfffcc 	andi	r2,r2,65535
 823ad30:	1080004c 	andi	r2,r2,1
 823ad34:	e0bffe15 	stw	r2,-8(fp)

      so->so_state &= ~SS_NOFDREF;     /* don't free the socket yet */
 823ad38:	e0bfff17 	ldw	r2,-4(fp)
 823ad3c:	10c0088b 	ldhu	r3,34(r2)
 823ad40:	00bfff84 	movi	r2,-2
 823ad44:	1884703a 	and	r2,r3,r2
 823ad48:	1007883a 	mov	r3,r2
 823ad4c:	e0bfff17 	ldw	r2,-4(fp)
 823ad50:	10c0088d 	sth	r3,34(r2)
      in_pcbdetach(inp);
 823ad54:	e13ffc17 	ldw	r4,-16(fp)
 823ad58:	8247f1c0 	call	8247f1c <in_pcbdetach>
      so->so_state |= nofd;
 823ad5c:	e0bfff17 	ldw	r2,-4(fp)
 823ad60:	1080088b 	ldhu	r2,34(r2)
 823ad64:	e0fffe17 	ldw	r3,-8(fp)
 823ad68:	10c4b03a 	or	r2,r2,r3
 823ad6c:	1007883a 	mov	r3,r2
 823ad70:	e0bfff17 	ldw	r2,-4(fp)
 823ad74:	10c0088d 	sth	r3,34(r2)
      return (ENOBUFS);
 823ad78:	00801a44 	movi	r2,105
 823ad7c:	00000306 	br	823ad8c <tcp_attach+0x104>
   }
   tp->t_state = TCPS_CLOSED;
 823ad80:	e0bffd17 	ldw	r2,-12(fp)
 823ad84:	10000215 	stw	zero,8(r2)
   return (0);
 823ad88:	0005883a 	mov	r2,zero
}
 823ad8c:	e037883a 	mov	sp,fp
 823ad90:	dfc00117 	ldw	ra,4(sp)
 823ad94:	df000017 	ldw	fp,0(sp)
 823ad98:	dec00204 	addi	sp,sp,8
 823ad9c:	f800283a 	ret

0823ada0 <tcp_disconnect>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_disconnect(struct tcpcb * tp)
{
 823ada0:	defffc04 	addi	sp,sp,-16
 823ada4:	dfc00315 	stw	ra,12(sp)
 823ada8:	df000215 	stw	fp,8(sp)
 823adac:	df000204 	addi	fp,sp,8
 823adb0:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 823adb4:	e0bfff17 	ldw	r2,-4(fp)
 823adb8:	10800d17 	ldw	r2,52(r2)
 823adbc:	10800817 	ldw	r2,32(r2)
 823adc0:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_state < TCPS_ESTABLISHED)
 823adc4:	e0bfff17 	ldw	r2,-4(fp)
 823adc8:	10800217 	ldw	r2,8(r2)
 823adcc:	10800108 	cmpgei	r2,r2,4
 823add0:	1000041e 	bne	r2,zero,823ade4 <tcp_disconnect+0x44>
      tp = tcp_close(tp);
 823add4:	e13fff17 	ldw	r4,-4(fp)
 823add8:	8239c3c0 	call	8239c3c <tcp_close>
 823addc:	e0bfff15 	stw	r2,-4(fp)
 823ade0:	00001c06 	br	823ae54 <tcp_disconnect+0xb4>
   else if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 823ade4:	e0bffe17 	ldw	r2,-8(fp)
 823ade8:	10800417 	ldw	r2,16(r2)
 823adec:	1080200c 	andi	r2,r2,128
 823adf0:	10000b26 	beq	r2,zero,823ae20 <tcp_disconnect+0x80>
 823adf4:	e0bffe17 	ldw	r2,-8(fp)
 823adf8:	1080080b 	ldhu	r2,32(r2)
 823adfc:	10bfffcc 	andi	r2,r2,65535
 823ae00:	10a0001c 	xori	r2,r2,32768
 823ae04:	10a00004 	addi	r2,r2,-32768
 823ae08:	1000051e 	bne	r2,zero,823ae20 <tcp_disconnect+0x80>
      tp = tcp_drop(tp, 0);
 823ae0c:	000b883a 	mov	r5,zero
 823ae10:	e13fff17 	ldw	r4,-4(fp)
 823ae14:	8239b900 	call	8239b90 <tcp_drop>
 823ae18:	e0bfff15 	stw	r2,-4(fp)
 823ae1c:	00000d06 	br	823ae54 <tcp_disconnect+0xb4>
   else 
   {
      soisdisconnecting(so);
 823ae20:	e13ffe17 	ldw	r4,-8(fp)
 823ae24:	8233c380 	call	8233c38 <soisdisconnecting>
      sbflush(&so->so_rcv);
 823ae28:	e0bffe17 	ldw	r2,-8(fp)
 823ae2c:	10800a04 	addi	r2,r2,40
 823ae30:	1009883a 	mov	r4,r2
 823ae34:	82349840 	call	8234984 <sbflush>
      tp = tcp_usrclosed(tp);
 823ae38:	e13fff17 	ldw	r4,-4(fp)
 823ae3c:	823ae6c0 	call	823ae6c <tcp_usrclosed>
 823ae40:	e0bfff15 	stw	r2,-4(fp)
      if (tp)
 823ae44:	e0bfff17 	ldw	r2,-4(fp)
 823ae48:	10000226 	beq	r2,zero,823ae54 <tcp_disconnect+0xb4>
         (void) tcp_output(tp);
 823ae4c:	e13fff17 	ldw	r4,-4(fp)
 823ae50:	823835c0 	call	823835c <tcp_output>
   }
   return (tp);
 823ae54:	e0bfff17 	ldw	r2,-4(fp)
}
 823ae58:	e037883a 	mov	sp,fp
 823ae5c:	dfc00117 	ldw	ra,4(sp)
 823ae60:	df000017 	ldw	fp,0(sp)
 823ae64:	dec00204 	addi	sp,sp,8
 823ae68:	f800283a 	ret

0823ae6c <tcp_usrclosed>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_usrclosed(struct tcpcb * tp)
{
 823ae6c:	defffd04 	addi	sp,sp,-12
 823ae70:	dfc00215 	stw	ra,8(sp)
 823ae74:	df000115 	stw	fp,4(sp)
 823ae78:	df000104 	addi	fp,sp,4
 823ae7c:	e13fff15 	stw	r4,-4(fp)

   switch (tp->t_state) 
 823ae80:	e0bfff17 	ldw	r2,-4(fp)
 823ae84:	10800217 	ldw	r2,8(r2)
 823ae88:	10c001a8 	cmpgeui	r3,r2,6
 823ae8c:	18001a1e 	bne	r3,zero,823aef8 <tcp_usrclosed+0x8c>
 823ae90:	100690ba 	slli	r3,r2,2
 823ae94:	00820934 	movhi	r2,2084
 823ae98:	10abaa04 	addi	r2,r2,-20824
 823ae9c:	1885883a 	add	r2,r3,r2
 823aea0:	10800017 	ldw	r2,0(r2)
 823aea4:	1000683a 	jmp	r2
 823aea8:	0823aec0 	call	823aec <OSCtxSw_SWITCH_PC+0x823aac>
 823aeac:	0823aec0 	call	823aec <OSCtxSw_SWITCH_PC+0x823aac>
 823aeb0:	0823aec0 	call	823aec <OSCtxSw_SWITCH_PC+0x823aac>
 823aeb4:	0823aed8 	cmpnei	zero,at,-28997
 823aeb8:	0823aed8 	cmpnei	zero,at,-28997
 823aebc:	0823aee8 	cmpgeui	zero,at,36539
   {
   case TCPS_CLOSED:
   case TCPS_LISTEN:
   case TCPS_SYN_SENT:
      tp->t_state = TCPS_CLOSED;
 823aec0:	e0bfff17 	ldw	r2,-4(fp)
 823aec4:	10000215 	stw	zero,8(r2)
      tp = tcp_close(tp);
 823aec8:	e13fff17 	ldw	r4,-4(fp)
 823aecc:	8239c3c0 	call	8239c3c <tcp_close>
 823aed0:	e0bfff15 	stw	r2,-4(fp)
      break;
 823aed4:	00000806 	br	823aef8 <tcp_usrclosed+0x8c>

   case TCPS_SYN_RECEIVED:
   case TCPS_ESTABLISHED:
      tp->t_state = TCPS_FIN_WAIT_1;
 823aed8:	e0bfff17 	ldw	r2,-4(fp)
 823aedc:	00c00184 	movi	r3,6
 823aee0:	10c00215 	stw	r3,8(r2)
      break;
 823aee4:	00000406 	br	823aef8 <tcp_usrclosed+0x8c>

   case TCPS_CLOSE_WAIT:
      tp->t_state = TCPS_LAST_ACK;
 823aee8:	e0bfff17 	ldw	r2,-4(fp)
 823aeec:	00c00204 	movi	r3,8
 823aef0:	10c00215 	stw	r3,8(r2)
      break;
 823aef4:	0001883a 	nop
   }
   if (tp && tp->t_state >= TCPS_FIN_WAIT_2)
 823aef8:	e0bfff17 	ldw	r2,-4(fp)
 823aefc:	10000926 	beq	r2,zero,823af24 <tcp_usrclosed+0xb8>
 823af00:	e0bfff17 	ldw	r2,-4(fp)
 823af04:	10800217 	ldw	r2,8(r2)
 823af08:	10800250 	cmplti	r2,r2,9
 823af0c:	1000051e 	bne	r2,zero,823af24 <tcp_usrclosed+0xb8>
      soisdisconnected(tp->t_inpcb->inp_socket);
 823af10:	e0bfff17 	ldw	r2,-4(fp)
 823af14:	10800d17 	ldw	r2,52(r2)
 823af18:	10800817 	ldw	r2,32(r2)
 823af1c:	1009883a 	mov	r4,r2
 823af20:	8233cd00 	call	8233cd0 <soisdisconnected>
   return (tp);
 823af24:	e0bfff17 	ldw	r2,-4(fp)
}
 823af28:	e037883a 	mov	sp,fp
 823af2c:	dfc00117 	ldw	ra,4(sp)
 823af30:	df000017 	ldw	fp,0(sp)
 823af34:	dec00204 	addi	sp,sp,8
 823af38:	f800283a 	ret

0823af3c <tcpinit>:
 * RETURNS: 0 if OK, else one of the ENP_ error codes
 */

int
tcpinit(void)
{
 823af3c:	defffd04 	addi	sp,sp,-12
 823af40:	dfc00215 	stw	ra,8(sp)
 823af44:	df000115 	stw	fp,4(sp)
 823af48:	df000104 	addi	fp,sp,4
   tcp_sendspace = (TCP_MSS) * 2;
   tcp_recvspace = (TCP_MSS) * 2;
   TCPTV_MSL =    (4 * PR_SLOWHZ);     /* max seg lifetime default */
#endif

   e = nptcp_init();    /* call the NetPort init in nptcp.c */
 823af4c:	822ed680 	call	822ed68 <nptcp_init>
 823af50:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 823af54:	e0bfff17 	ldw	r2,-4(fp)
 823af58:	10000226 	beq	r2,zero,823af64 <tcpinit+0x28>
      return e;
 823af5c:	e0bfff17 	ldw	r2,-4(fp)
 823af60:	00000106 	br	823af68 <tcpinit+0x2c>

   return 0;   /* good return */
 823af64:	0005883a 	mov	r2,zero
}
 823af68:	e037883a 	mov	sp,fp
 823af6c:	dfc00117 	ldw	ra,4(sp)
 823af70:	df000017 	ldw	fp,0(sp)
 823af74:	dec00204 	addi	sp,sp,8
 823af78:	f800283a 	ret

0823af7c <udp_lookup>:
 * RETURNS: 
 */

UDPCONN
udp_lookup(struct socket * so)
{
 823af7c:	defffd04 	addi	sp,sp,-12
 823af80:	df000215 	stw	fp,8(sp)
 823af84:	df000204 	addi	fp,sp,8
 823af88:	e13fff15 	stw	r4,-4(fp)
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 823af8c:	d0a09c17 	ldw	r2,-32144(gp)
 823af90:	e0bffe15 	stw	r2,-8(fp)
 823af94:	00000906 	br	823afbc <udp_lookup+0x40>
      if (tmp->u_data == (void*)so)
 823af98:	e0bffe17 	ldw	r2,-8(fp)
 823af9c:	10c00617 	ldw	r3,24(r2)
 823afa0:	e0bfff17 	ldw	r2,-4(fp)
 823afa4:	1880021e 	bne	r3,r2,823afb0 <udp_lookup+0x34>
      return (tmp);
 823afa8:	e0bffe17 	ldw	r2,-8(fp)
 823afac:	00000606 	br	823afc8 <udp_lookup+0x4c>
UDPCONN
udp_lookup(struct socket * so)
{
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 823afb0:	e0bffe17 	ldw	r2,-8(fp)
 823afb4:	10800017 	ldw	r2,0(r2)
 823afb8:	e0bffe15 	stw	r2,-8(fp)
 823afbc:	e0bffe17 	ldw	r2,-8(fp)
 823afc0:	103ff51e 	bne	r2,zero,823af98 <udp_lookup+0x1c>
      if (tmp->u_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 823afc4:	0005883a 	mov	r2,zero
}
 823afc8:	e037883a 	mov	sp,fp
 823afcc:	df000017 	ldw	fp,0(sp)
 823afd0:	dec00104 	addi	sp,sp,4
 823afd4:	f800283a 	ret

0823afd8 <udp_soinput>:
 * RETURNS: 
 */

int
udp_soinput(PACKET pkt, void * so_ptr)
{
 823afd8:	defff504 	addi	sp,sp,-44
 823afdc:	dfc00a15 	stw	ra,40(sp)
 823afe0:	df000915 	stw	fp,36(sp)
 823afe4:	df000904 	addi	fp,sp,36
 823afe8:	e13ffe15 	stw	r4,-8(fp)
 823afec:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 823aff0:	e0bfff17 	ldw	r2,-4(fp)
 823aff4:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;
   struct udp *   udpp;

   LOCK_NET_RESOURCE(NET_RESID); 
 823aff8:	0009883a 	mov	r4,zero
 823affc:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 823b000:	e0bff717 	ldw	r2,-36(fp)
 823b004:	10c00a17 	ldw	r3,40(r2)
 823b008:	e0bffe17 	ldw	r2,-8(fp)
 823b00c:	10800417 	ldw	r2,16(r2)
 823b010:	1887883a 	add	r3,r3,r2
 823b014:	e0bff717 	ldw	r2,-36(fp)
 823b018:	10800b17 	ldw	r2,44(r2)
 823b01c:	18800436 	bltu	r3,r2,823b030 <udp_soinput+0x58>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 823b020:	0009883a 	mov	r4,zero
 823b024:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 823b028:	00801a44 	movi	r2,105
 823b02c:	00004d06 	br	823b164 <udp_soinput+0x18c>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 823b030:	000b883a 	mov	r5,zero
 823b034:	01000044 	movi	r4,1
 823b038:	822e4040 	call	822e404 <m_getnbuf>
 823b03c:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 823b040:	e0bff817 	ldw	r2,-32(fp)
 823b044:	1000041e 	bne	r2,zero,823b058 <udp_soinput+0x80>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 823b048:	0009883a 	mov	r4,zero
 823b04c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 823b050:	00801a44 	movi	r2,105
 823b054:	00004306 	br	823b164 <udp_soinput+0x18c>
   }

   /* set data mbuf to point to start of UDP data */
   m_in->pkt = pkt;
 823b058:	e0bff817 	ldw	r2,-32(fp)
 823b05c:	e0fffe17 	ldw	r3,-8(fp)
 823b060:	10c00115 	stw	r3,4(r2)
   m_in->m_data = pkt->nb_prot;
 823b064:	e0bffe17 	ldw	r2,-8(fp)
 823b068:	10c00317 	ldw	r3,12(r2)
 823b06c:	e0bff817 	ldw	r2,-32(fp)
 823b070:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 823b074:	e0bffe17 	ldw	r2,-8(fp)
 823b078:	10c00417 	ldw	r3,16(r2)
 823b07c:	e0bff817 	ldw	r2,-32(fp)
 823b080:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;
 823b084:	e0bffe17 	ldw	r2,-8(fp)
 823b088:	10c00117 	ldw	r3,4(r2)
 823b08c:	e0bff817 	ldw	r2,-32(fp)
 823b090:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 823b094:	e0bffe17 	ldw	r2,-8(fp)
 823b098:	10c00217 	ldw	r3,8(r2)
 823b09c:	e0bff817 	ldw	r2,-32(fp)
 823b0a0:	10c00515 	stw	r3,20(r2)

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 823b0a4:	e0bffe17 	ldw	r2,-8(fp)
 823b0a8:	10800717 	ldw	r2,28(r2)
 823b0ac:	e0bffb15 	stw	r2,-20(fp)
   udpp = (struct udp *)(pkt->nb_prot - sizeof(struct udp));
 823b0b0:	e0bffe17 	ldw	r2,-8(fp)
 823b0b4:	10800317 	ldw	r2,12(r2)
 823b0b8:	10bffe04 	addi	r2,r2,-8
 823b0bc:	e0bff915 	stw	r2,-28(fp)
   sin.sin_port = htons(udpp->ud_srcp);
 823b0c0:	e0bff917 	ldw	r2,-28(fp)
 823b0c4:	1080000b 	ldhu	r2,0(r2)
 823b0c8:	10bfffcc 	andi	r2,r2,65535
 823b0cc:	1004d23a 	srli	r2,r2,8
 823b0d0:	1007883a 	mov	r3,r2
 823b0d4:	e0bff917 	ldw	r2,-28(fp)
 823b0d8:	1080000b 	ldhu	r2,0(r2)
 823b0dc:	10bfffcc 	andi	r2,r2,65535
 823b0e0:	1004923a 	slli	r2,r2,8
 823b0e4:	1884b03a 	or	r2,r3,r2
 823b0e8:	e0bffa8d 	sth	r2,-22(fp)
   sin.sin_family = AF_INET;
 823b0ec:	00800084 	movi	r2,2
 823b0f0:	e0bffa0d 	sth	r2,-24(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 823b0f4:	e0bff717 	ldw	r2,-36(fp)
 823b0f8:	10800a04 	addi	r2,r2,40
 823b0fc:	e0fffa04 	addi	r3,fp,-24
 823b100:	e1bff817 	ldw	r6,-32(fp)
 823b104:	180b883a 	mov	r5,r3
 823b108:	1009883a 	mov	r4,r2
 823b10c:	82345c80 	call	82345c8 <sbappendaddr>
 823b110:	1000081e 	bne	r2,zero,823b134 <udp_soinput+0x15c>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       */
      m_in->pkt = NULL;
 823b114:	e0bff817 	ldw	r2,-32(fp)
 823b118:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 823b11c:	e13ff817 	ldw	r4,-32(fp)
 823b120:	822e58c0 	call	822e58c <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 823b124:	0009883a 	mov	r4,zero
 823b128:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 823b12c:	00801a44 	movi	r2,105
 823b130:	00000c06 	br	823b164 <udp_soinput+0x18c>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 823b134:	e0bff717 	ldw	r2,-36(fp)
 823b138:	10800a04 	addi	r2,r2,40
 823b13c:	1009883a 	mov	r4,r2
 823b140:	82297040 	call	8229704 <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 823b144:	e0bff717 	ldw	r2,-36(fp)
 823b148:	10800a04 	addi	r2,r2,40
 823b14c:	100b883a 	mov	r5,r2
 823b150:	e13ff717 	ldw	r4,-36(fp)
 823b154:	82342a00 	call	82342a0 <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 823b158:	0009883a 	mov	r4,zero
 823b15c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   return 0;
 823b160:	0005883a 	mov	r2,zero
}
 823b164:	e037883a 	mov	sp,fp
 823b168:	dfc00117 	ldw	ra,4(sp)
 823b16c:	df000017 	ldw	fp,0(sp)
 823b170:	dec00204 	addi	sp,sp,8
 823b174:	f800283a 	ret

0823b178 <udp_usrreq>:

int
udp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 823b178:	defff804 	addi	sp,sp,-32
 823b17c:	dfc00715 	stw	ra,28(sp)
 823b180:	df000615 	stw	fp,24(sp)
 823b184:	df000604 	addi	fp,sp,24
 823b188:	e13ffd15 	stw	r4,-12(fp)
 823b18c:	e17ffe15 	stw	r5,-8(fp)
 823b190:	e1bfff15 	stw	r6,-4(fp)
   UDPCONN udpconn = (UDPCONN)NULL;
 823b194:	e03ffb15 	stw	zero,-20(fp)
   int   req;

   req = so->so_req;    /* get request from socket struct */
 823b198:	e0bffd17 	ldw	r2,-12(fp)
 823b19c:	10800717 	ldw	r2,28(r2)
 823b1a0:	e0bffc15 	stw	r2,-16(fp)

   switch (req) 
 823b1a4:	e0bffc17 	ldw	r2,-16(fp)
 823b1a8:	10800468 	cmpgeui	r2,r2,17
 823b1ac:	10007b1e 	bne	r2,zero,823b39c <udp_usrreq+0x224>
 823b1b0:	e0bffc17 	ldw	r2,-16(fp)
 823b1b4:	100690ba 	slli	r3,r2,2
 823b1b8:	00820934 	movhi	r2,2084
 823b1bc:	10ac7304 	addi	r2,r2,-20020
 823b1c0:	1885883a 	add	r2,r3,r2
 823b1c4:	10800017 	ldw	r2,0(r2)
 823b1c8:	1000683a 	jmp	r2
 823b1cc:	0823b210 	cmplti	zero,at,-28984
 823b1d0:	0823b294 	ori	zero,at,36554
 823b1d4:	0823b2d0 	cmplti	zero,at,-28981
 823b1d8:	0823b39c 	xori	zero,at,36558
 823b1dc:	0823b2d0 	cmplti	zero,at,-28981
 823b1e0:	0823b39c 	xori	zero,at,36558
 823b1e4:	0823b390 	cmplti	zero,at,-28978
 823b1e8:	0823b39c 	xori	zero,at,36558
 823b1ec:	0823b390 	cmplti	zero,at,-28978
 823b1f0:	0823b310 	cmplti	zero,at,-28980
 823b1f4:	0823b39c 	xori	zero,at,36558
 823b1f8:	0823b39c 	xori	zero,at,36558
 823b1fc:	0823b39c 	xori	zero,at,36558
 823b200:	0823b39c 	xori	zero,at,36558
 823b204:	0823b39c 	xori	zero,at,36558
 823b208:	0823b350 	cmplti	zero,at,-28979
 823b20c:	0823b350 	cmplti	zero,at,-28979
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = udp_maxalloc();
 823b210:	82455000 	call	8245500 <udp_maxalloc>
 823b214:	1007883a 	mov	r3,r2
 823b218:	e0bffd17 	ldw	r2,-12(fp)
 823b21c:	10c01315 	stw	r3,76(r2)
 823b220:	e0bffd17 	ldw	r2,-12(fp)
 823b224:	10c01317 	ldw	r3,76(r2)
 823b228:	e0bffd17 	ldw	r2,-12(fp)
 823b22c:	10c00b15 	stw	r3,44(r2)

#ifdef IP_V4
      /* make a NetPort UDP connection */
      /* unlock the net resource; UDP will immediatly re-lock it */
      if (so->so_domain  == AF_INET){
 823b230:	e0bffd17 	ldw	r2,-12(fp)
 823b234:	10800517 	ldw	r2,20(r2)
 823b238:	10800098 	cmpnei	r2,r2,2
 823b23c:	10000f1e 	bne	r2,zero,823b27c <udp_usrreq+0x104>
        UNLOCK_NET_RESOURCE(NET_RESID);
 823b240:	0009883a 	mov	r4,zero
 823b244:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
        udpconn = udp_open(0L, 0, udp_socket(), udp_soinput, so);
 823b248:	82453940 	call	8245394 <udp_socket>
 823b24c:	10ffffcc 	andi	r3,r2,65535
 823b250:	e0bffd17 	ldw	r2,-12(fp)
 823b254:	d8800015 	stw	r2,0(sp)
 823b258:	01c20934 	movhi	r7,2084
 823b25c:	39ebf604 	addi	r7,r7,-20520
 823b260:	180d883a 	mov	r6,r3
 823b264:	000b883a 	mov	r5,zero
 823b268:	0009883a 	mov	r4,zero
 823b26c:	822d1880 	call	822d188 <udp_open>
 823b270:	e0bffb15 	stw	r2,-20(fp)
        LOCK_NET_RESOURCE(NET_RESID);
 823b274:	0009883a 	mov	r4,zero
 823b278:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
        UNLOCK_NET_RESOURCE(NET_RESID);
        udpconn = udp6_open(0L, 0, udp_socket(), udp6_soinput, so);
        LOCK_NET_RESOURCE(NET_RESID);
      }
#endif
      if (!udpconn)
 823b27c:	e0bffb17 	ldw	r2,-20(fp)
 823b280:	1000021e 	bne	r2,zero,823b28c <udp_usrreq+0x114>
         return(EINVAL);
 823b284:	00800584 	movi	r2,22
 823b288:	00004506 	br	823b3a0 <udp_usrreq+0x228>
      return 0;
 823b28c:	0005883a 	mov	r2,zero
 823b290:	00004306 	br	823b3a0 <udp_usrreq+0x228>
   case PRU_DETACH:
      /* delete the NetPort UDP connection */
      udpconn = udp_lookup(so);
 823b294:	e13ffd17 	ldw	r4,-12(fp)
 823b298:	823af7c0 	call	823af7c <udp_lookup>
 823b29c:	e0bffb15 	stw	r2,-20(fp)
      if (!udpconn)
 823b2a0:	e0bffb17 	ldw	r2,-20(fp)
 823b2a4:	1000021e 	bne	r2,zero,823b2b0 <udp_usrreq+0x138>
         return(EINVAL);
 823b2a8:	00800584 	movi	r2,22
 823b2ac:	00003c06 	br	823b3a0 <udp_usrreq+0x228>
      /* unlock the net resource; UDP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 823b2b0:	0009883a 	mov	r4,zero
 823b2b4:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      udp_close(udpconn);
 823b2b8:	e13ffb17 	ldw	r4,-20(fp)
 823b2bc:	822d3840 	call	822d384 <udp_close>
      LOCK_NET_RESOURCE(NET_RESID);
 823b2c0:	0009883a 	mov	r4,zero
 823b2c4:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      return 0;
 823b2c8:	0005883a 	mov	r2,zero
 823b2cc:	00003406 	br	823b3a0 <udp_usrreq+0x228>
   case PRU_CONNECT:
      /* Install foreign port for UDP, making a virtual connection */
      /* fall to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 823b2d0:	e0bfff17 	ldw	r2,-4(fp)
 823b2d4:	1000021e 	bne	r2,zero,823b2e0 <udp_usrreq+0x168>
         return(EINVAL);
 823b2d8:	00800584 	movi	r2,22
 823b2dc:	00003006 	br	823b3a0 <udp_usrreq+0x228>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 823b2e0:	e0bffd17 	ldw	r2,-12(fp)
 823b2e4:	10800517 	ldw	r2,20(r2)
 823b2e8:	10800098 	cmpnei	r2,r2,2
 823b2ec:	1000051e 	bne	r2,zero,823b304 <udp_usrreq+0x18c>
        return udp4_sockbind(so, nam, req );
 823b2f0:	e1bffc17 	ldw	r6,-16(fp)
 823b2f4:	e17fff17 	ldw	r5,-4(fp)
 823b2f8:	e13ffd17 	ldw	r4,-12(fp)
 823b2fc:	823b3b40 	call	823b3b4 <udp4_sockbind>
 823b300:	00002706 	br	823b3a0 <udp_usrreq+0x228>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockbind(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 823b304:	822d5f00 	call	822d5f0 <dtrap>
      return EINVAL;
 823b308:	00800584 	movi	r2,22
 823b30c:	00002406 	br	823b3a0 <udp_usrreq+0x228>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 823b310:	e0bffe17 	ldw	r2,-8(fp)
 823b314:	1000021e 	bne	r2,zero,823b320 <udp_usrreq+0x1a8>
         return(EINVAL);
 823b318:	00800584 	movi	r2,22
 823b31c:	00002006 	br	823b3a0 <udp_usrreq+0x228>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 823b320:	e0bffd17 	ldw	r2,-12(fp)
 823b324:	10800517 	ldw	r2,20(r2)
 823b328:	10800098 	cmpnei	r2,r2,2
 823b32c:	1000051e 	bne	r2,zero,823b344 <udp_usrreq+0x1cc>
        return udp4_socksend(so, m, nam );
 823b330:	e1bfff17 	ldw	r6,-4(fp)
 823b334:	e17ffe17 	ldw	r5,-8(fp)
 823b338:	e13ffd17 	ldw	r4,-12(fp)
 823b33c:	823b6880 	call	823b688 <udp4_socksend>
 823b340:	00001706 	br	823b3a0 <udp_usrreq+0x228>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_socksend(so, m, nam);
      }
#endif
      dtrap();   /* invalid address */
 823b344:	822d5f00 	call	822d5f0 <dtrap>
      return EINVAL;
 823b348:	00800584 	movi	r2,22
 823b34c:	00001406 	br	823b3a0 <udp_usrreq+0x228>

   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 823b350:	e0bfff17 	ldw	r2,-4(fp)
 823b354:	1000021e 	bne	r2,zero,823b360 <udp_usrreq+0x1e8>
         return(EINVAL);
 823b358:	00800584 	movi	r2,22
 823b35c:	00001006 	br	823b3a0 <udp_usrreq+0x228>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 823b360:	e0bffd17 	ldw	r2,-12(fp)
 823b364:	10800517 	ldw	r2,20(r2)
 823b368:	10800098 	cmpnei	r2,r2,2
 823b36c:	1000051e 	bne	r2,zero,823b384 <udp_usrreq+0x20c>
        return udp4_sockaddr(so, nam, req );
 823b370:	e1bffc17 	ldw	r6,-16(fp)
 823b374:	e17fff17 	ldw	r5,-4(fp)
 823b378:	e13ffd17 	ldw	r4,-12(fp)
 823b37c:	823ba080 	call	823ba08 <udp4_sockaddr>
 823b380:	00000706 	br	823b3a0 <udp_usrreq+0x228>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockaddr(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 823b384:	822d5f00 	call	822d5f0 <dtrap>
      return EINVAL;
 823b388:	00800584 	movi	r2,22
 823b38c:	00000406 	br	823b3a0 <udp_usrreq+0x228>

   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 823b390:	822d5f00 	call	822d5f0 <dtrap>
      return 0;
 823b394:	0005883a 	mov	r2,zero
 823b398:	00000106 	br	823b3a0 <udp_usrreq+0x228>
   case PRU_LISTEN:     /* don't support these for UDP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 823b39c:	008017c4 	movi	r2,95
   }
}
 823b3a0:	e037883a 	mov	sp,fp
 823b3a4:	dfc00117 	ldw	ra,4(sp)
 823b3a8:	df000017 	ldw	fp,0(sp)
 823b3ac:	dec00204 	addi	sp,sp,8
 823b3b0:	f800283a 	ret

0823b3b4 <udp4_sockbind>:

#ifdef IP_V4
int udp4_sockbind(struct socket *so, struct mbuf *nam, int req ) 
{
 823b3b4:	defff304 	addi	sp,sp,-52
 823b3b8:	dfc00c15 	stw	ra,48(sp)
 823b3bc:	df000b15 	stw	fp,44(sp)
 823b3c0:	df000b04 	addi	fp,sp,44
 823b3c4:	e13ffd15 	stw	r4,-12(fp)
 823b3c8:	e17ffe15 	stw	r5,-8(fp)
 823b3cc:	e1bfff15 	stw	r6,-4(fp)
  u_short  lport;   /* local port (local byte order) */
  ip_addr fhost; /* host to send to/recv from (network byte order) */
  ip_addr lhost; /* local IP address to bind to (network byte order) */
  NET ifp;

  sin = mtod(nam, struct sockaddr_in *);
 823b3d0:	e0bffe17 	ldw	r2,-8(fp)
 823b3d4:	10800317 	ldw	r2,12(r2)
 823b3d8:	e0bffa15 	stw	r2,-24(fp)
  if (sin == NULL)
 823b3dc:	e0bffa17 	ldw	r2,-24(fp)
 823b3e0:	1000021e 	bne	r2,zero,823b3ec <udp4_sockbind+0x38>
    return(EINVAL);
 823b3e4:	00800584 	movi	r2,22
 823b3e8:	0000a206 	br	823b674 <udp4_sockbind+0x2c0>
  if (nam->m_len != sizeof (*sin))
 823b3ec:	e0bffe17 	ldw	r2,-8(fp)
 823b3f0:	10800217 	ldw	r2,8(r2)
 823b3f4:	10800420 	cmpeqi	r2,r2,16
 823b3f8:	1000021e 	bne	r2,zero,823b404 <udp4_sockbind+0x50>
    return(EINVAL);
 823b3fc:	00800584 	movi	r2,22
 823b400:	00009c06 	br	823b674 <udp4_sockbind+0x2c0>
  udpconn = udp_lookup(so);
 823b404:	e13ffd17 	ldw	r4,-12(fp)
 823b408:	823af7c0 	call	823af7c <udp_lookup>
 823b40c:	e0bffb15 	stw	r2,-20(fp)
  if (!udpconn)
 823b410:	e0bffb17 	ldw	r2,-20(fp)
 823b414:	1000021e 	bne	r2,zero,823b420 <udp4_sockbind+0x6c>
     return(EINVAL);
 823b418:	00800584 	movi	r2,22
 823b41c:	00009506 	br	823b674 <udp4_sockbind+0x2c0>
  if (req == PRU_BIND)
 823b420:	e0bfff17 	ldw	r2,-4(fp)
 823b424:	10800098 	cmpnei	r2,r2,2
 823b428:	1000531e 	bne	r2,zero,823b578 <udp4_sockbind+0x1c4>
     * if the caller-supplied port is 0, try to get
     * the port from the UDP endpoint, or pick a new
     * unique port; else, use the caller-supplied
     * port
     */
    if (sin->sin_port == 0)
 823b42c:	e0bffa17 	ldw	r2,-24(fp)
 823b430:	1080008b 	ldhu	r2,2(r2)
 823b434:	10bfffcc 	andi	r2,r2,65535
 823b438:	10000b1e 	bne	r2,zero,823b468 <udp4_sockbind+0xb4>
    {
      if (udpconn->u_lport != 0)
 823b43c:	e0bffb17 	ldw	r2,-20(fp)
 823b440:	1080018b 	ldhu	r2,6(r2)
 823b444:	10bfffcc 	andi	r2,r2,65535
 823b448:	10000426 	beq	r2,zero,823b45c <udp4_sockbind+0xa8>
        lport = udpconn->u_lport;
 823b44c:	e0bffb17 	ldw	r2,-20(fp)
 823b450:	1080018b 	ldhu	r2,6(r2)
 823b454:	e0bff60d 	sth	r2,-40(fp)
 823b458:	00000e06 	br	823b494 <udp4_sockbind+0xe0>
      else
        lport = udp_socket();
 823b45c:	82453940 	call	8245394 <udp_socket>
 823b460:	e0bff60d 	sth	r2,-40(fp)
 823b464:	00000b06 	br	823b494 <udp4_sockbind+0xe0>
    }
    else
    {
      lport = ntohs(sin->sin_port);
 823b468:	e0bffa17 	ldw	r2,-24(fp)
 823b46c:	1080008b 	ldhu	r2,2(r2)
 823b470:	10bfffcc 	andi	r2,r2,65535
 823b474:	1004d23a 	srli	r2,r2,8
 823b478:	1007883a 	mov	r3,r2
 823b47c:	e0bffa17 	ldw	r2,-24(fp)
 823b480:	1080008b 	ldhu	r2,2(r2)
 823b484:	10bfffcc 	andi	r2,r2,65535
 823b488:	1004923a 	slli	r2,r2,8
 823b48c:	1884b03a 	or	r2,r3,r2
 823b490:	e0bff60d 	sth	r2,-40(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * don't bind to a specific address; else, 
     * make sure the caller-supplied address is
     * an interface IP address and if so, bind to that
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 823b494:	e0bffa17 	ldw	r2,-24(fp)
 823b498:	10800117 	ldw	r2,4(r2)
 823b49c:	1000021e 	bne	r2,zero,823b4a8 <udp4_sockbind+0xf4>
    {
      lhost = 0L;
 823b4a0:	e03ff815 	stw	zero,-32(fp)
 823b4a4:	00001706 	br	823b504 <udp4_sockbind+0x150>
    }
    else
    {
      lhost = sin->sin_addr.s_addr;
 823b4a8:	e0bffa17 	ldw	r2,-24(fp)
 823b4ac:	10800117 	ldw	r2,4(r2)
 823b4b0:	e0bff815 	stw	r2,-32(fp)
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b4b4:	008209b4 	movhi	r2,2086
 823b4b8:	10ba7e04 	addi	r2,r2,-5640
 823b4bc:	10800017 	ldw	r2,0(r2)
 823b4c0:	e0bff915 	stw	r2,-28(fp)
 823b4c4:	00000706 	br	823b4e4 <udp4_sockbind+0x130>
        if (ifp->n_ipaddr == lhost)
 823b4c8:	e0bff917 	ldw	r2,-28(fp)
 823b4cc:	10c00a17 	ldw	r3,40(r2)
 823b4d0:	e0bff817 	ldw	r2,-32(fp)
 823b4d4:	18800626 	beq	r3,r2,823b4f0 <udp4_sockbind+0x13c>
    else
    {
      lhost = sin->sin_addr.s_addr;
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b4d8:	e0bff917 	ldw	r2,-28(fp)
 823b4dc:	10800017 	ldw	r2,0(r2)
 823b4e0:	e0bff915 	stw	r2,-28(fp)
 823b4e4:	e0bff917 	ldw	r2,-28(fp)
 823b4e8:	103ff71e 	bne	r2,zero,823b4c8 <udp4_sockbind+0x114>
 823b4ec:	00000106 	br	823b4f4 <udp4_sockbind+0x140>
        if (ifp->n_ipaddr == lhost)
          break;
 823b4f0:	0001883a 	nop
      if (ifp == NULL)
 823b4f4:	e0bff917 	ldw	r2,-28(fp)
 823b4f8:	1000021e 	bne	r2,zero,823b504 <udp4_sockbind+0x150>
        return(EADDRNOTAVAIL);
 823b4fc:	00801f44 	movi	r2,125
 823b500:	00005c06 	br	823b674 <udp4_sockbind+0x2c0>
    }

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
 823b504:	e0bffd17 	ldw	r2,-12(fp)
 823b508:	10800417 	ldw	r2,16(r2)
 823b50c:	1080010c 	andi	r2,r2,4
 823b510:	1000121e 	bne	r2,zero,823b55c <udp4_sockbind+0x1a8>
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 823b514:	d0a09c17 	ldw	r2,-32144(gp)
 823b518:	e0bff515 	stw	r2,-44(fp)
 823b51c:	00000d06 	br	823b554 <udp4_sockbind+0x1a0>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
 823b520:	e0bff517 	ldw	r2,-44(fp)
 823b524:	1080018b 	ldhu	r2,6(r2)
 823b528:	10ffffcc 	andi	r3,r2,65535
 823b52c:	e0bff60b 	ldhu	r2,-40(fp)
 823b530:	1880051e 	bne	r3,r2,823b548 <udp4_sockbind+0x194>
 823b534:	e0fff517 	ldw	r3,-44(fp)
 823b538:	e0bffb17 	ldw	r2,-20(fp)
 823b53c:	18800226 	beq	r3,r2,823b548 <udp4_sockbind+0x194>
          return(EADDRINUSE);
 823b540:	00801c04 	movi	r2,112
 823b544:	00004b06 	br	823b674 <udp4_sockbind+0x2c0>

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 823b548:	e0bff517 	ldw	r2,-44(fp)
 823b54c:	10800017 	ldw	r2,0(r2)
 823b550:	e0bff515 	stw	r2,-44(fp)
 823b554:	e0bff517 	ldw	r2,-44(fp)
 823b558:	103ff11e 	bne	r2,zero,823b520 <udp4_sockbind+0x16c>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
          return(EADDRINUSE);
    /* bind the UDP endpoint */
    udpconn->u_lport = lport;
 823b55c:	e0bffb17 	ldw	r2,-20(fp)
 823b560:	e0fff60b 	ldhu	r3,-40(fp)
 823b564:	10c0018d 	sth	r3,6(r2)
    udpconn->u_lhost = lhost;
 823b568:	e0bffb17 	ldw	r2,-20(fp)
 823b56c:	e0fff817 	ldw	r3,-32(fp)
 823b570:	10c00315 	stw	r3,12(r2)
 823b574:	00003e06 	br	823b670 <udp4_sockbind+0x2bc>
  else /* PRU_CONNECT */
  {
    /* connect the socket to a remote IP address and
     * UDP port.
     */
    fport = ntohs(sin->sin_port);
 823b578:	e0bffa17 	ldw	r2,-24(fp)
 823b57c:	1080008b 	ldhu	r2,2(r2)
 823b580:	10bfffcc 	andi	r2,r2,65535
 823b584:	1004d23a 	srli	r2,r2,8
 823b588:	1007883a 	mov	r3,r2
 823b58c:	e0bffa17 	ldw	r2,-24(fp)
 823b590:	1080008b 	ldhu	r2,2(r2)
 823b594:	10bfffcc 	andi	r2,r2,65535
 823b598:	1004923a 	slli	r2,r2,8
 823b59c:	1884b03a 	or	r2,r3,r2
 823b5a0:	e0bffc0d 	sth	r2,-16(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * use the wildcard address; else, use the caller-
     * supplied address
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 823b5a4:	e0bffa17 	ldw	r2,-24(fp)
 823b5a8:	10800117 	ldw	r2,4(r2)
 823b5ac:	1000021e 	bne	r2,zero,823b5b8 <udp4_sockbind+0x204>
      fhost = 0L;
 823b5b0:	e03ff715 	stw	zero,-36(fp)
 823b5b4:	00000306 	br	823b5c4 <udp4_sockbind+0x210>
    else
      fhost = sin->sin_addr.s_addr;
 823b5b8:	e0bffa17 	ldw	r2,-24(fp)
 823b5bc:	10800117 	ldw	r2,4(r2)
 823b5c0:	e0bff715 	stw	r2,-36(fp)
    /* prepare to bind the socket to the appropriate 
     * local interface address for the to-be-connected 
     * peer
     */
    lhost = ip_mymach(fhost);
 823b5c4:	e13ff717 	ldw	r4,-36(fp)
 823b5c8:	82409f80 	call	82409f8 <ip_mymach>
 823b5cc:	e0bff815 	stw	r2,-32(fp)
    if (lhost == 0)
 823b5d0:	e0bff817 	ldw	r2,-32(fp)
 823b5d4:	1000021e 	bne	r2,zero,823b5e0 <udp4_sockbind+0x22c>
      return(ENETUNREACH);
 823b5d8:	00801c84 	movi	r2,114
 823b5dc:	00002506 	br	823b674 <udp4_sockbind+0x2c0>
    /* if the socket hasn't been bound to a local
     * port yet, do so now
     */
    lport = udpconn->u_lport;
 823b5e0:	e0bffb17 	ldw	r2,-20(fp)
 823b5e4:	1080018b 	ldhu	r2,6(r2)
 823b5e8:	e0bff60d 	sth	r2,-40(fp)
    if (lport == 0)
 823b5ec:	e0bff60b 	ldhu	r2,-40(fp)
 823b5f0:	1000021e 	bne	r2,zero,823b5fc <udp4_sockbind+0x248>
      lport = udp_socket();
 823b5f4:	82453940 	call	8245394 <udp_socket>
 823b5f8:	e0bff60d 	sth	r2,-40(fp)
    /* bind and connect the UDP endpoint */
    udpconn->u_lhost = lhost;
 823b5fc:	e0bffb17 	ldw	r2,-20(fp)
 823b600:	e0fff817 	ldw	r3,-32(fp)
 823b604:	10c00315 	stw	r3,12(r2)
    udpconn->u_lport = lport;
 823b608:	e0bffb17 	ldw	r2,-20(fp)
 823b60c:	e0fff60b 	ldhu	r3,-40(fp)
 823b610:	10c0018d 	sth	r3,6(r2)
    udpconn->u_fhost = fhost;
 823b614:	e0bffb17 	ldw	r2,-20(fp)
 823b618:	e0fff717 	ldw	r3,-36(fp)
 823b61c:	10c00415 	stw	r3,16(r2)
    udpconn->u_fport = fport;
 823b620:	e0bffb17 	ldw	r2,-20(fp)
 823b624:	e0fffc0b 	ldhu	r3,-16(fp)
 823b628:	10c0020d 	sth	r3,8(r2)
    /* mark the socket as connected */
    so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 823b62c:	e0bffd17 	ldw	r2,-12(fp)
 823b630:	10c0088b 	ldhu	r3,34(r2)
 823b634:	00bffcc4 	movi	r2,-13
 823b638:	1884703a 	and	r2,r3,r2
 823b63c:	1007883a 	mov	r3,r2
 823b640:	e0bffd17 	ldw	r2,-12(fp)
 823b644:	10c0088d 	sth	r3,34(r2)
    so->so_state |= SS_ISCONNECTED;
 823b648:	e0bffd17 	ldw	r2,-12(fp)
 823b64c:	1080088b 	ldhu	r2,34(r2)
 823b650:	10800094 	ori	r2,r2,2
 823b654:	1007883a 	mov	r3,r2
 823b658:	e0bffd17 	ldw	r2,-12(fp)
 823b65c:	10c0088d 	sth	r3,34(r2)
    /* since socket was in listen state, packets may be queued */
    sbflush(&so->so_rcv);   /* dump these now */
 823b660:	e0bffd17 	ldw	r2,-12(fp)
 823b664:	10800a04 	addi	r2,r2,40
 823b668:	1009883a 	mov	r4,r2
 823b66c:	82349840 	call	8234984 <sbflush>
  }
  return 0;
 823b670:	0005883a 	mov	r2,zero
}
 823b674:	e037883a 	mov	sp,fp
 823b678:	dfc00117 	ldw	ra,4(sp)
 823b67c:	df000017 	ldw	fp,0(sp)
 823b680:	dec00204 	addi	sp,sp,8
 823b684:	f800283a 	ret

0823b688 <udp4_socksend>:

int udp4_socksend(struct socket *so, struct mbuf *m, 
		struct mbuf *nam ) 
{
 823b688:	defff304 	addi	sp,sp,-52
 823b68c:	dfc00c15 	stw	ra,48(sp)
 823b690:	df000b15 	stw	fp,44(sp)
 823b694:	dc000a15 	stw	r16,40(sp)
 823b698:	df000b04 	addi	fp,sp,44
 823b69c:	e13ffc15 	stw	r4,-16(fp)
 823b6a0:	e17ffd15 	stw	r5,-12(fp)
 823b6a4:	e1bffe15 	stw	r6,-8(fp)
  PACKET pkt;
#ifdef MULTI_HOMED
  NET ifp;
#endif

  udpconn = udp_lookup(so);
 823b6a8:	e13ffc17 	ldw	r4,-16(fp)
 823b6ac:	823af7c0 	call	823af7c <udp_lookup>
 823b6b0:	e0bff815 	stw	r2,-32(fp)
  if (!udpconn)
 823b6b4:	e0bff817 	ldw	r2,-32(fp)
 823b6b8:	1000041e 	bne	r2,zero,823b6cc <udp4_socksend+0x44>
  {
    m_free(m);
 823b6bc:	e13ffd17 	ldw	r4,-12(fp)
 823b6c0:	822e58c0 	call	822e58c <m_free>
    /* may be bogus socket, but more likely the connection may 
       have closed due to ICMP dest unreachable from other side. */
    return(ECONNREFUSED);
 823b6c4:	00801bc4 	movi	r2,111
 823b6c8:	0000c906 	br	823b9f0 <udp4_socksend+0x368>
  }

  if (nam == NULL)  /* no sendto() info passed, must be send() */
 823b6cc:	e0bffe17 	ldw	r2,-8(fp)
 823b6d0:	10000e1e 	bne	r2,zero,823b70c <udp4_socksend+0x84>
  { 
    if (so->so_state & SS_ISCONNECTED)
 823b6d4:	e0bffc17 	ldw	r2,-16(fp)
 823b6d8:	1080088b 	ldhu	r2,34(r2)
 823b6dc:	10bfffcc 	andi	r2,r2,65535
 823b6e0:	1080008c 	andi	r2,r2,2
 823b6e4:	10000726 	beq	r2,zero,823b704 <udp4_socksend+0x7c>
    {
      fport = udpconn->u_fport;
 823b6e8:	e0bff817 	ldw	r2,-32(fp)
 823b6ec:	1080020b 	ldhu	r2,8(r2)
 823b6f0:	e0bff50d 	sth	r2,-44(fp)
      fhost = udpconn->u_fhost;
 823b6f4:	e0bff817 	ldw	r2,-32(fp)
 823b6f8:	10800417 	ldw	r2,16(r2)
 823b6fc:	e0bff615 	stw	r2,-40(fp)
 823b700:	00002806 	br	823b7a4 <udp4_socksend+0x11c>
    }
    else
      return (EINVAL);
 823b704:	00800584 	movi	r2,22
 823b708:	0000b906 	br	823b9f0 <udp4_socksend+0x368>
  }
  else if(nam->m_len != sizeof (*sin))
 823b70c:	e0bffe17 	ldw	r2,-8(fp)
 823b710:	10800217 	ldw	r2,8(r2)
 823b714:	10800420 	cmpeqi	r2,r2,16
 823b718:	1000031e 	bne	r2,zero,823b728 <udp4_socksend+0xa0>
  {
    dtrap();
 823b71c:	822d5f00 	call	822d5f0 <dtrap>
    return (EINVAL);
 823b720:	00800584 	movi	r2,22
 823b724:	0000b206 	br	823b9f0 <udp4_socksend+0x368>
  }
  else
  {
    sin = mtod(nam, struct sockaddr_in *);
 823b728:	e0bffe17 	ldw	r2,-8(fp)
 823b72c:	10800317 	ldw	r2,12(r2)
 823b730:	e0bff915 	stw	r2,-28(fp)
    fhost = sin->sin_addr.s_addr;
 823b734:	e0bff917 	ldw	r2,-28(fp)
 823b738:	10800117 	ldw	r2,4(r2)
 823b73c:	e0bff615 	stw	r2,-40(fp)
    /* use caller's fport if specified, ours may be a wildcard */
    if (sin->sin_port)   /* caller gets to change fport on the fly */
 823b740:	e0bff917 	ldw	r2,-28(fp)
 823b744:	1080008b 	ldhu	r2,2(r2)
 823b748:	10bfffcc 	andi	r2,r2,65535
 823b74c:	10000c26 	beq	r2,zero,823b780 <udp4_socksend+0xf8>
      fport = ntohs(sin->sin_port);
 823b750:	e0bff917 	ldw	r2,-28(fp)
 823b754:	1080008b 	ldhu	r2,2(r2)
 823b758:	10bfffcc 	andi	r2,r2,65535
 823b75c:	1004d23a 	srli	r2,r2,8
 823b760:	1007883a 	mov	r3,r2
 823b764:	e0bff917 	ldw	r2,-28(fp)
 823b768:	1080008b 	ldhu	r2,2(r2)
 823b76c:	10bfffcc 	andi	r2,r2,65535
 823b770:	1004923a 	slli	r2,r2,8
 823b774:	1884b03a 	or	r2,r3,r2
 823b778:	e0bff50d 	sth	r2,-44(fp)
 823b77c:	00000906 	br	823b7a4 <udp4_socksend+0x11c>
    else  /* use port already set in UDP connection */
    {
      if (udpconn->u_fport == 0) /* don't send to port 0 */
 823b780:	e0bff817 	ldw	r2,-32(fp)
 823b784:	1080020b 	ldhu	r2,8(r2)
 823b788:	10bfffcc 	andi	r2,r2,65535
 823b78c:	1000021e 	bne	r2,zero,823b798 <udp4_socksend+0x110>
        return (EINVAL);
 823b790:	00800584 	movi	r2,22
 823b794:	00009606 	br	823b9f0 <udp4_socksend+0x368>
      fport = udpconn->u_fport;
 823b798:	e0bff817 	ldw	r2,-32(fp)
 823b79c:	1080020b 	ldhu	r2,8(r2)
 823b7a0:	e0bff50d 	sth	r2,-44(fp)

  /* since our pkt->nb_buff size is tied to max packet size, we 
   * assume our UDP datagrams are always in one mbuf and that the 
   * mbuf 
   */
  if (m->m_len > (unsigned)udp_maxalloc()) /* but check anyway:*/
 823b7a4:	e0bffd17 	ldw	r2,-12(fp)
 823b7a8:	14000217 	ldw	r16,8(r2)
 823b7ac:	82455000 	call	8245500 <udp_maxalloc>
 823b7b0:	1400032e 	bgeu	r2,r16,823b7c0 <udp4_socksend+0x138>
  {
    dtrap(); /* should never happen */
 823b7b4:	822d5f00 	call	822d5f0 <dtrap>
    return EMSGSIZE;  /* try to recover */
 823b7b8:	00801e84 	movi	r2,122
 823b7bc:	00008c06 	br	823b9f0 <udp4_socksend+0x368>
  }
  pkt = udp_alloc(m->m_len, 0);    /* get a NetPort buffer for send */
 823b7c0:	e0bffd17 	ldw	r2,-12(fp)
 823b7c4:	10800217 	ldw	r2,8(r2)
 823b7c8:	000b883a 	mov	r5,zero
 823b7cc:	1009883a 	mov	r4,r2
 823b7d0:	82454440 	call	8245444 <udp_alloc>
 823b7d4:	e0bffa15 	stw	r2,-24(fp)
  if (!pkt)
 823b7d8:	e0bffa17 	ldw	r2,-24(fp)
 823b7dc:	1000041e 	bne	r2,zero,823b7f0 <udp4_socksend+0x168>
  {
    m_free(m);
 823b7e0:	e13ffd17 	ldw	r4,-12(fp)
 823b7e4:	822e58c0 	call	822e58c <m_free>
    return ENOBUFS;   /* report buffer shortages */
 823b7e8:	00801a44 	movi	r2,105
 823b7ec:	00008006 	br	823b9f0 <udp4_socksend+0x368>
  }
  MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 823b7f0:	e0bffa17 	ldw	r2,-24(fp)
 823b7f4:	10c00317 	ldw	r3,12(r2)
 823b7f8:	e0bffd17 	ldw	r2,-12(fp)
 823b7fc:	11000317 	ldw	r4,12(r2)
 823b800:	e0bffd17 	ldw	r2,-12(fp)
 823b804:	10800217 	ldw	r2,8(r2)
 823b808:	100d883a 	mov	r6,r2
 823b80c:	200b883a 	mov	r5,r4
 823b810:	1809883a 	mov	r4,r3
 823b814:	8202f6c0 	call	8202f6c <memcpy>
  pkt->nb_plen = m->m_len;
 823b818:	e0bffd17 	ldw	r2,-12(fp)
 823b81c:	10c00217 	ldw	r3,8(r2)
 823b820:	e0bffa17 	ldw	r2,-24(fp)
 823b824:	10c00415 	stw	r3,16(r2)
  /* finished with mbuf, free it now */
  m_free(m);
 823b828:	e13ffd17 	ldw	r4,-12(fp)
 823b82c:	822e58c0 	call	822e58c <m_free>
  pkt->fhost = fhost;
 823b830:	e0bffa17 	ldw	r2,-24(fp)
 823b834:	e0fff617 	ldw	r3,-40(fp)
 823b838:	10c00715 	stw	r3,28(r2)
     * is up; if (after all that) we don't have an interface then we
     * fail with error EADDRNOTAVAIL; and finally, if we're built
     * for a single-homed configuration where there's only one
     * interface, we might as well use it, so we do.  
   */
  if (fhost == 0xffffffff)
 823b83c:	e0bff617 	ldw	r2,-40(fp)
 823b840:	10bfffd8 	cmpnei	r2,r2,-1
 823b844:	10004a1e 	bne	r2,zero,823b970 <udp4_socksend+0x2e8>
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
 823b848:	e0bff817 	ldw	r2,-32(fp)
 823b84c:	10800317 	ldw	r2,12(r2)
 823b850:	10001026 	beq	r2,zero,823b894 <udp4_socksend+0x20c>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b854:	008209b4 	movhi	r2,2086
 823b858:	10ba7e04 	addi	r2,r2,-5640
 823b85c:	10800017 	ldw	r2,0(r2)
 823b860:	e0bff715 	stw	r2,-36(fp)
 823b864:	00000806 	br	823b888 <udp4_socksend+0x200>
        if (ifp->n_ipaddr == udpconn->u_lhost)
 823b868:	e0bff717 	ldw	r2,-36(fp)
 823b86c:	10c00a17 	ldw	r3,40(r2)
 823b870:	e0bff817 	ldw	r2,-32(fp)
 823b874:	10800317 	ldw	r2,12(r2)
 823b878:	18801d26 	beq	r3,r2,823b8f0 <udp4_socksend+0x268>
  if (fhost == 0xffffffff)
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b87c:	e0bff717 	ldw	r2,-36(fp)
 823b880:	10800017 	ldw	r2,0(r2)
 823b884:	e0bff715 	stw	r2,-36(fp)
 823b888:	e0bff717 	ldw	r2,-36(fp)
 823b88c:	103ff61e 	bne	r2,zero,823b868 <udp4_socksend+0x1e0>
 823b890:	00001a06 	br	823b8fc <udp4_socksend+0x274>
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b894:	008209b4 	movhi	r2,2086
 823b898:	10ba7e04 	addi	r2,r2,-5640
 823b89c:	10800017 	ldw	r2,0(r2)
 823b8a0:	e0bff715 	stw	r2,-36(fp)
 823b8a4:	00000f06 	br	823b8e4 <udp4_socksend+0x25c>
        if ((ifp->n_flags & NF_BCAST) &&
 823b8a8:	e0bff717 	ldw	r2,-36(fp)
 823b8ac:	10802a17 	ldw	r2,168(r2)
 823b8b0:	1080004c 	andi	r2,r2,1
 823b8b4:	10000826 	beq	r2,zero,823b8d8 <udp4_socksend+0x250>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 823b8b8:	e0bff717 	ldw	r2,-36(fp)
 823b8bc:	10802717 	ldw	r2,156(r2)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if ((ifp->n_flags & NF_BCAST) &&
 823b8c0:	10000526 	beq	r2,zero,823b8d8 <udp4_socksend+0x250>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 823b8c4:	e0bff717 	ldw	r2,-36(fp)
 823b8c8:	10802717 	ldw	r2,156(r2)
 823b8cc:	10800617 	ldw	r2,24(r2)
 823b8d0:	10800058 	cmpnei	r2,r2,1
 823b8d4:	10000826 	beq	r2,zero,823b8f8 <udp4_socksend+0x270>
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b8d8:	e0bff717 	ldw	r2,-36(fp)
 823b8dc:	10800017 	ldw	r2,0(r2)
 823b8e0:	e0bff715 	stw	r2,-36(fp)
 823b8e4:	e0bff717 	ldw	r2,-36(fp)
 823b8e8:	103fef1e 	bne	r2,zero,823b8a8 <udp4_socksend+0x220>
 823b8ec:	00000306 	br	823b8fc <udp4_socksend+0x274>
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
 823b8f0:	0001883a 	nop
 823b8f4:	00000106 	br	823b8fc <udp4_socksend+0x274>
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if ((ifp->n_flags & NF_BCAST) &&
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
 823b8f8:	0001883a 	nop
    }
    if (ifp == NULL)
 823b8fc:	e0bff717 	ldw	r2,-36(fp)
 823b900:	1000181e 	bne	r2,zero,823b964 <udp4_socksend+0x2dc>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b904:	008209b4 	movhi	r2,2086
 823b908:	10ba7e04 	addi	r2,r2,-5640
 823b90c:	10800017 	ldw	r2,0(r2)
 823b910:	e0bff715 	stw	r2,-36(fp)
 823b914:	00000b06 	br	823b944 <udp4_socksend+0x2bc>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 823b918:	e0bff717 	ldw	r2,-36(fp)
 823b91c:	10802717 	ldw	r2,156(r2)
 823b920:	10000526 	beq	r2,zero,823b938 <udp4_socksend+0x2b0>
 823b924:	e0bff717 	ldw	r2,-36(fp)
 823b928:	10802717 	ldw	r2,156(r2)
 823b92c:	10800617 	ldw	r2,24(r2)
 823b930:	10800058 	cmpnei	r2,r2,1
 823b934:	10000626 	beq	r2,zero,823b950 <udp4_socksend+0x2c8>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
    }
    if (ifp == NULL)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b938:	e0bff717 	ldw	r2,-36(fp)
 823b93c:	10800017 	ldw	r2,0(r2)
 823b940:	e0bff715 	stw	r2,-36(fp)
 823b944:	e0bff717 	ldw	r2,-36(fp)
 823b948:	103ff31e 	bne	r2,zero,823b918 <udp4_socksend+0x290>
 823b94c:	00000106 	br	823b954 <udp4_socksend+0x2cc>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
          break;
 823b950:	0001883a 	nop
      if (ifp == NULL)
 823b954:	e0bff717 	ldw	r2,-36(fp)
 823b958:	1000021e 	bne	r2,zero,823b964 <udp4_socksend+0x2dc>
        return(EADDRNOTAVAIL);
 823b95c:	00801f44 	movi	r2,125
 823b960:	00002306 	br	823b9f0 <udp4_socksend+0x368>
    }
    pkt->net = ifp;
 823b964:	e0bffa17 	ldw	r2,-24(fp)
 823b968:	e0fff717 	ldw	r3,-36(fp)
 823b96c:	10c00615 	stw	r3,24(r2)
#ifdef IP_MULTICAST

  /* If the socket has an IP moptions structure for multicast options,
   * place a pointer to this structure in the PACKET structure.
   */
  if (so->inp_moptions)
 823b970:	e0bffc17 	ldw	r2,-16(fp)
 823b974:	10800317 	ldw	r2,12(r2)
 823b978:	10000426 	beq	r2,zero,823b98c <udp4_socksend+0x304>
     pkt->imo = so->inp_moptions;
 823b97c:	e0bffc17 	ldw	r2,-16(fp)
 823b980:	10c00317 	ldw	r3,12(r2)
 823b984:	e0bffa17 	ldw	r2,-24(fp)
 823b988:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

   /* have we set options? */
   if (so->so_optsPack)
 823b98c:	e0bffc17 	ldw	r2,-16(fp)
 823b990:	10801f17 	ldw	r2,124(r2)
 823b994:	10000426 	beq	r2,zero,823b9a8 <udp4_socksend+0x320>
	   pkt->soxopts = so->so_optsPack; /* yup - copy to pkt */
 823b998:	e0bffc17 	ldw	r2,-16(fp)
 823b99c:	10c01f17 	ldw	r3,124(r2)
 823b9a0:	e0bffa17 	ldw	r2,-24(fp)
 823b9a4:	10c00c15 	stw	r3,48(r2)

  /* unlock the net resource; UDP will immediately re-lock it */
  UNLOCK_NET_RESOURCE(NET_RESID);
 823b9a8:	0009883a 	mov	r4,zero
 823b9ac:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
  e = udp_send(fport, udpconn->u_lport, pkt);
 823b9b0:	e0fff50b 	ldhu	r3,-44(fp)
 823b9b4:	e0bff817 	ldw	r2,-32(fp)
 823b9b8:	1080018b 	ldhu	r2,6(r2)
 823b9bc:	10bfffcc 	andi	r2,r2,65535
 823b9c0:	e1bffa17 	ldw	r6,-24(fp)
 823b9c4:	100b883a 	mov	r5,r2
 823b9c8:	1809883a 	mov	r4,r3
 823b9cc:	82450080 	call	8245008 <udp_send>
 823b9d0:	e0bffb15 	stw	r2,-20(fp)
  LOCK_NET_RESOURCE(NET_RESID);
 823b9d4:	0009883a 	mov	r4,zero
 823b9d8:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
  if (e < 0) 
 823b9dc:	e0bffb17 	ldw	r2,-20(fp)
 823b9e0:	1000020e 	bge	r2,zero,823b9ec <udp4_socksend+0x364>
     return(e);
 823b9e4:	e0bffb17 	ldw	r2,-20(fp)
 823b9e8:	00000106 	br	823b9f0 <udp4_socksend+0x368>
  return 0;
 823b9ec:	0005883a 	mov	r2,zero
}
 823b9f0:	e6ffff04 	addi	sp,fp,-4
 823b9f4:	dfc00217 	ldw	ra,8(sp)
 823b9f8:	df000117 	ldw	fp,4(sp)
 823b9fc:	dc000017 	ldw	r16,0(sp)
 823ba00:	dec00304 	addi	sp,sp,12
 823ba04:	f800283a 	ret

0823ba08 <udp4_sockaddr>:

int udp4_sockaddr(struct socket *so, struct mbuf *nam , int req)
{
 823ba08:	defff904 	addi	sp,sp,-28
 823ba0c:	dfc00615 	stw	ra,24(sp)
 823ba10:	df000515 	stw	fp,20(sp)
 823ba14:	df000504 	addi	fp,sp,20
 823ba18:	e13ffd15 	stw	r4,-12(fp)
 823ba1c:	e17ffe15 	stw	r5,-8(fp)
 823ba20:	e1bfff15 	stw	r6,-4(fp)
  struct sockaddr_in * sin;
  UDPCONN udpconn;

  sin = mtod(nam, struct sockaddr_in *);
 823ba24:	e0bffe17 	ldw	r2,-8(fp)
 823ba28:	10800317 	ldw	r2,12(r2)
 823ba2c:	e0bffb15 	stw	r2,-20(fp)
  if (sin == NULL)
 823ba30:	e0bffb17 	ldw	r2,-20(fp)
 823ba34:	1000021e 	bne	r2,zero,823ba40 <udp4_sockaddr+0x38>
     return(EINVAL);
 823ba38:	00800584 	movi	r2,22
 823ba3c:	00003706 	br	823bb1c <udp4_sockaddr+0x114>
  udpconn = udp_lookup(so);
 823ba40:	e13ffd17 	ldw	r4,-12(fp)
 823ba44:	823af7c0 	call	823af7c <udp_lookup>
 823ba48:	e0bffc15 	stw	r2,-16(fp)
  if (!udpconn)
 823ba4c:	e0bffc17 	ldw	r2,-16(fp)
 823ba50:	1000021e 	bne	r2,zero,823ba5c <udp4_sockaddr+0x54>
     return(EINVAL);
 823ba54:	00800584 	movi	r2,22
 823ba58:	00003006 	br	823bb1c <udp4_sockaddr+0x114>
  nam->m_len = sizeof(*sin);
 823ba5c:	e0bffe17 	ldw	r2,-8(fp)
 823ba60:	00c00404 	movi	r3,16
 823ba64:	10c00215 	stw	r3,8(r2)
  if (req == PRU_SOCKADDR)
 823ba68:	e0bfff17 	ldw	r2,-4(fp)
 823ba6c:	108003d8 	cmpnei	r2,r2,15
 823ba70:	1000151e 	bne	r2,zero,823bac8 <udp4_sockaddr+0xc0>
  {
     sin->sin_family = AF_INET;
 823ba74:	e0bffb17 	ldw	r2,-20(fp)
 823ba78:	00c00084 	movi	r3,2
 823ba7c:	10c0000d 	sth	r3,0(r2)
     sin->sin_port = htons(udpconn->u_lport);
 823ba80:	e0bffc17 	ldw	r2,-16(fp)
 823ba84:	1080018b 	ldhu	r2,6(r2)
 823ba88:	10bfffcc 	andi	r2,r2,65535
 823ba8c:	1004d23a 	srli	r2,r2,8
 823ba90:	1007883a 	mov	r3,r2
 823ba94:	e0bffc17 	ldw	r2,-16(fp)
 823ba98:	1080018b 	ldhu	r2,6(r2)
 823ba9c:	10bfffcc 	andi	r2,r2,65535
 823baa0:	1004923a 	slli	r2,r2,8
 823baa4:	1884b03a 	or	r2,r3,r2
 823baa8:	1007883a 	mov	r3,r2
 823baac:	e0bffb17 	ldw	r2,-20(fp)
 823bab0:	10c0008d 	sth	r3,2(r2)
     sin->sin_addr.s_addr = udpconn->u_lhost;
 823bab4:	e0bffc17 	ldw	r2,-16(fp)
 823bab8:	10c00317 	ldw	r3,12(r2)
 823babc:	e0bffb17 	ldw	r2,-20(fp)
 823bac0:	10c00115 	stw	r3,4(r2)
 823bac4:	00001406 	br	823bb18 <udp4_sockaddr+0x110>
  }
  else /* PRU_PEERADDR */
  {
    sin->sin_family = AF_INET;
 823bac8:	e0bffb17 	ldw	r2,-20(fp)
 823bacc:	00c00084 	movi	r3,2
 823bad0:	10c0000d 	sth	r3,0(r2)
    sin->sin_port = htons(udpconn->u_fport);
 823bad4:	e0bffc17 	ldw	r2,-16(fp)
 823bad8:	1080020b 	ldhu	r2,8(r2)
 823badc:	10bfffcc 	andi	r2,r2,65535
 823bae0:	1004d23a 	srli	r2,r2,8
 823bae4:	1007883a 	mov	r3,r2
 823bae8:	e0bffc17 	ldw	r2,-16(fp)
 823baec:	1080020b 	ldhu	r2,8(r2)
 823baf0:	10bfffcc 	andi	r2,r2,65535
 823baf4:	1004923a 	slli	r2,r2,8
 823baf8:	1884b03a 	or	r2,r3,r2
 823bafc:	1007883a 	mov	r3,r2
 823bb00:	e0bffb17 	ldw	r2,-20(fp)
 823bb04:	10c0008d 	sth	r3,2(r2)
    sin->sin_addr.s_addr = udpconn->u_fhost;
 823bb08:	e0bffc17 	ldw	r2,-16(fp)
 823bb0c:	10c00417 	ldw	r3,16(r2)
 823bb10:	e0bffb17 	ldw	r2,-20(fp)
 823bb14:	10c00115 	stw	r3,4(r2)
  }
  return 0;
 823bb18:	0005883a 	mov	r2,zero
}
 823bb1c:	e037883a 	mov	sp,fp
 823bb20:	dfc00117 	ldw	ra,4(sp)
 823bb24:	df000017 	ldw	fp,0(sp)
 823bb28:	dec00204 	addi	sp,sp,8
 823bb2c:	f800283a 	ret

0823bb30 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 823bb30:	defff504 	addi	sp,sp,-44
 823bb34:	df000a15 	stw	fp,40(sp)
 823bb38:	df000a04 	addi	fp,sp,40
 823bb3c:	e13ffc15 	stw	r4,-16(fp)
 823bb40:	e17ffd15 	stw	r5,-12(fp)
 823bb44:	e1bffe15 	stw	r6,-8(fp)
 823bb48:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 823bb4c:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 823bb50:	d0a0b817 	ldw	r2,-32032(gp)
  
  if (alt_ticks_per_second ())
 823bb54:	10003c26 	beq	r2,zero,823bc48 <alt_alarm_start+0x118>
  {
    if (alarm)
 823bb58:	e0bffc17 	ldw	r2,-16(fp)
 823bb5c:	10003826 	beq	r2,zero,823bc40 <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
 823bb60:	e0bffc17 	ldw	r2,-16(fp)
 823bb64:	e0fffe17 	ldw	r3,-8(fp)
 823bb68:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 823bb6c:	e0bffc17 	ldw	r2,-16(fp)
 823bb70:	e0ffff17 	ldw	r3,-4(fp)
 823bb74:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823bb78:	0005303a 	rdctl	r2,status
 823bb7c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823bb80:	e0fff917 	ldw	r3,-28(fp)
 823bb84:	00bfff84 	movi	r2,-2
 823bb88:	1884703a 	and	r2,r3,r2
 823bb8c:	1001703a 	wrctl	status,r2
  
  return context;
 823bb90:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
 823bb94:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 823bb98:	d0a0b917 	ldw	r2,-32028(gp)
      
      current_nticks = alt_nticks();
 823bb9c:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 823bba0:	e0fffd17 	ldw	r3,-12(fp)
 823bba4:	e0bff617 	ldw	r2,-40(fp)
 823bba8:	1885883a 	add	r2,r3,r2
 823bbac:	10c00044 	addi	r3,r2,1
 823bbb0:	e0bffc17 	ldw	r2,-16(fp)
 823bbb4:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 823bbb8:	e0bffc17 	ldw	r2,-16(fp)
 823bbbc:	10c00217 	ldw	r3,8(r2)
 823bbc0:	e0bff617 	ldw	r2,-40(fp)
 823bbc4:	1880042e 	bgeu	r3,r2,823bbd8 <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
 823bbc8:	e0bffc17 	ldw	r2,-16(fp)
 823bbcc:	00c00044 	movi	r3,1
 823bbd0:	10c00405 	stb	r3,16(r2)
 823bbd4:	00000206 	br	823bbe0 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
 823bbd8:	e0bffc17 	ldw	r2,-16(fp)
 823bbdc:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 823bbe0:	e0bffc17 	ldw	r2,-16(fp)
 823bbe4:	d0e04904 	addi	r3,gp,-32476
 823bbe8:	e0fffa15 	stw	r3,-24(fp)
 823bbec:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 823bbf0:	e0bffb17 	ldw	r2,-20(fp)
 823bbf4:	e0fffa17 	ldw	r3,-24(fp)
 823bbf8:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 823bbfc:	e0bffa17 	ldw	r2,-24(fp)
 823bc00:	10c00017 	ldw	r3,0(r2)
 823bc04:	e0bffb17 	ldw	r2,-20(fp)
 823bc08:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 823bc0c:	e0bffa17 	ldw	r2,-24(fp)
 823bc10:	10800017 	ldw	r2,0(r2)
 823bc14:	e0fffb17 	ldw	r3,-20(fp)
 823bc18:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 823bc1c:	e0bffa17 	ldw	r2,-24(fp)
 823bc20:	e0fffb17 	ldw	r3,-20(fp)
 823bc24:	10c00015 	stw	r3,0(r2)
 823bc28:	e0bff817 	ldw	r2,-32(fp)
 823bc2c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823bc30:	e0bff717 	ldw	r2,-36(fp)
 823bc34:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 823bc38:	0005883a 	mov	r2,zero
 823bc3c:	00000306 	br	823bc4c <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
 823bc40:	00bffa84 	movi	r2,-22
 823bc44:	00000106 	br	823bc4c <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
 823bc48:	00bfde84 	movi	r2,-134
  }
}
 823bc4c:	e037883a 	mov	sp,fp
 823bc50:	df000017 	ldw	fp,0(sp)
 823bc54:	dec00104 	addi	sp,sp,4
 823bc58:	f800283a 	ret

0823bc5c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823bc5c:	defffe04 	addi	sp,sp,-8
 823bc60:	dfc00115 	stw	ra,4(sp)
 823bc64:	df000015 	stw	fp,0(sp)
 823bc68:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823bc6c:	d0a04717 	ldw	r2,-32484(gp)
 823bc70:	10000326 	beq	r2,zero,823bc80 <alt_get_errno+0x24>
 823bc74:	d0a04717 	ldw	r2,-32484(gp)
 823bc78:	103ee83a 	callr	r2
 823bc7c:	00000106 	br	823bc84 <alt_get_errno+0x28>
 823bc80:	d0a06304 	addi	r2,gp,-32372
}
 823bc84:	e037883a 	mov	sp,fp
 823bc88:	dfc00117 	ldw	ra,4(sp)
 823bc8c:	df000017 	ldw	fp,0(sp)
 823bc90:	dec00204 	addi	sp,sp,8
 823bc94:	f800283a 	ret

0823bc98 <alt_close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 823bc98:	defffb04 	addi	sp,sp,-20
 823bc9c:	dfc00415 	stw	ra,16(sp)
 823bca0:	df000315 	stw	fp,12(sp)
 823bca4:	df000304 	addi	fp,sp,12
 823bca8:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 823bcac:	e0bfff17 	ldw	r2,-4(fp)
 823bcb0:	10000616 	blt	r2,zero,823bccc <alt_close+0x34>
 823bcb4:	e0bfff17 	ldw	r2,-4(fp)
 823bcb8:	10c00324 	muli	r3,r2,12
 823bcbc:	00820974 	movhi	r2,2085
 823bcc0:	108ef504 	addi	r2,r2,15316
 823bcc4:	1885883a 	add	r2,r3,r2
 823bcc8:	00000106 	br	823bcd0 <alt_close+0x38>
 823bccc:	0005883a 	mov	r2,zero
 823bcd0:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
 823bcd4:	e0bffd17 	ldw	r2,-12(fp)
 823bcd8:	10001926 	beq	r2,zero,823bd40 <alt_close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 823bcdc:	e0bffd17 	ldw	r2,-12(fp)
 823bce0:	10800017 	ldw	r2,0(r2)
 823bce4:	10800417 	ldw	r2,16(r2)
 823bce8:	10000626 	beq	r2,zero,823bd04 <alt_close+0x6c>
 823bcec:	e0bffd17 	ldw	r2,-12(fp)
 823bcf0:	10800017 	ldw	r2,0(r2)
 823bcf4:	10800417 	ldw	r2,16(r2)
 823bcf8:	e13ffd17 	ldw	r4,-12(fp)
 823bcfc:	103ee83a 	callr	r2
 823bd00:	00000106 	br	823bd08 <alt_close+0x70>
 823bd04:	0005883a 	mov	r2,zero
 823bd08:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 823bd0c:	e13fff17 	ldw	r4,-4(fp)
 823bd10:	823c7a80 	call	823c7a8 <alt_release_fd>
    if (rval < 0)
 823bd14:	e0bffe17 	ldw	r2,-8(fp)
 823bd18:	1000070e 	bge	r2,zero,823bd38 <alt_close+0xa0>
    {
      ALT_ERRNO = -rval;
 823bd1c:	823bc5c0 	call	823bc5c <alt_get_errno>
 823bd20:	1007883a 	mov	r3,r2
 823bd24:	e0bffe17 	ldw	r2,-8(fp)
 823bd28:	0085c83a 	sub	r2,zero,r2
 823bd2c:	18800015 	stw	r2,0(r3)
      return -1;
 823bd30:	00bfffc4 	movi	r2,-1
 823bd34:	00000706 	br	823bd54 <alt_close+0xbc>
    }
    return 0;
 823bd38:	0005883a 	mov	r2,zero
 823bd3c:	00000506 	br	823bd54 <alt_close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 823bd40:	823bc5c0 	call	823bc5c <alt_get_errno>
 823bd44:	1007883a 	mov	r3,r2
 823bd48:	00801444 	movi	r2,81
 823bd4c:	18800015 	stw	r2,0(r3)
    return -1;
 823bd50:	00bfffc4 	movi	r2,-1
  }
}
 823bd54:	e037883a 	mov	sp,fp
 823bd58:	dfc00117 	ldw	ra,4(sp)
 823bd5c:	df000017 	ldw	fp,0(sp)
 823bd60:	dec00204 	addi	sp,sp,8
 823bd64:	f800283a 	ret

0823bd68 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
 823bd68:	defffb04 	addi	sp,sp,-20
 823bd6c:	df000415 	stw	fp,16(sp)
 823bd70:	df000404 	addi	fp,sp,16
 823bd74:	e13ffe15 	stw	r4,-8(fp)
 823bd78:	e17fff15 	stw	r5,-4(fp)
  {
    len = NIOS2_DCACHE_SIZE;
  }
  #endif

  end = ((char*) start) + len; 
 823bd7c:	e0fffe17 	ldw	r3,-8(fp)
 823bd80:	e0bfff17 	ldw	r2,-4(fp)
 823bd84:	1885883a 	add	r2,r3,r2
 823bd88:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 823bd8c:	e0bffe17 	ldw	r2,-8(fp)
 823bd90:	e0bffc15 	stw	r2,-16(fp)
 823bd94:	00000506 	br	823bdac <alt_dcache_flush+0x44>
  { 
    ALT_FLUSH_DATA(i); 
 823bd98:	e0bffc17 	ldw	r2,-16(fp)
 823bd9c:	1000001b 	flushda	0(r2)
  }
  #endif

  end = ((char*) start) + len; 

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 823bda0:	e0bffc17 	ldw	r2,-16(fp)
 823bda4:	10800804 	addi	r2,r2,32
 823bda8:	e0bffc15 	stw	r2,-16(fp)
 823bdac:	e0fffc17 	ldw	r3,-16(fp)
 823bdb0:	e0bffd17 	ldw	r2,-12(fp)
 823bdb4:	18bff836 	bltu	r3,r2,823bd98 <alt_dcache_flush+0x30>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_DCACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_DCACHE_LINE_SIZE - 1))
 823bdb8:	e0bffe17 	ldw	r2,-8(fp)
 823bdbc:	108007cc 	andi	r2,r2,31
 823bdc0:	10000226 	beq	r2,zero,823bdcc <alt_dcache_flush+0x64>
  {
    ALT_FLUSH_DATA(i);
 823bdc4:	e0bffc17 	ldw	r2,-16(fp)
 823bdc8:	1000001b 	flushda	0(r2)
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 823bdcc:	0001883a 	nop
 823bdd0:	e037883a 	mov	sp,fp
 823bdd4:	df000017 	ldw	fp,0(sp)
 823bdd8:	dec00104 	addi	sp,sp,4
 823bddc:	f800283a 	ret

0823bde0 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 823bde0:	defffc04 	addi	sp,sp,-16
 823bde4:	df000315 	stw	fp,12(sp)
 823bde8:	df000304 	addi	fp,sp,12
 823bdec:	e13ffd15 	stw	r4,-12(fp)
 823bdf0:	e17ffe15 	stw	r5,-8(fp)
 823bdf4:	e1bfff15 	stw	r6,-4(fp)
  return len;
 823bdf8:	e0bfff17 	ldw	r2,-4(fp)
}
 823bdfc:	e037883a 	mov	sp,fp
 823be00:	df000017 	ldw	fp,0(sp)
 823be04:	dec00104 	addi	sp,sp,4
 823be08:	f800283a 	ret

0823be0c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823be0c:	defffe04 	addi	sp,sp,-8
 823be10:	dfc00115 	stw	ra,4(sp)
 823be14:	df000015 	stw	fp,0(sp)
 823be18:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823be1c:	d0a04717 	ldw	r2,-32484(gp)
 823be20:	10000326 	beq	r2,zero,823be30 <alt_get_errno+0x24>
 823be24:	d0a04717 	ldw	r2,-32484(gp)
 823be28:	103ee83a 	callr	r2
 823be2c:	00000106 	br	823be34 <alt_get_errno+0x28>
 823be30:	d0a06304 	addi	r2,gp,-32372
}
 823be34:	e037883a 	mov	sp,fp
 823be38:	dfc00117 	ldw	ra,4(sp)
 823be3c:	df000017 	ldw	fp,0(sp)
 823be40:	dec00204 	addi	sp,sp,8
 823be44:	f800283a 	ret

0823be48 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 823be48:	defffa04 	addi	sp,sp,-24
 823be4c:	dfc00515 	stw	ra,20(sp)
 823be50:	df000415 	stw	fp,16(sp)
 823be54:	df000404 	addi	fp,sp,16
 823be58:	e13ffe15 	stw	r4,-8(fp)
 823be5c:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 823be60:	e0bffe17 	ldw	r2,-8(fp)
 823be64:	10000326 	beq	r2,zero,823be74 <alt_dev_llist_insert+0x2c>
 823be68:	e0bffe17 	ldw	r2,-8(fp)
 823be6c:	10800217 	ldw	r2,8(r2)
 823be70:	1000061e 	bne	r2,zero,823be8c <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 823be74:	823be0c0 	call	823be0c <alt_get_errno>
 823be78:	1007883a 	mov	r3,r2
 823be7c:	00800584 	movi	r2,22
 823be80:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 823be84:	00bffa84 	movi	r2,-22
 823be88:	00001306 	br	823bed8 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 823be8c:	e0bffe17 	ldw	r2,-8(fp)
 823be90:	e0ffff17 	ldw	r3,-4(fp)
 823be94:	e0fffc15 	stw	r3,-16(fp)
 823be98:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 823be9c:	e0bffd17 	ldw	r2,-12(fp)
 823bea0:	e0fffc17 	ldw	r3,-16(fp)
 823bea4:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 823bea8:	e0bffc17 	ldw	r2,-16(fp)
 823beac:	10c00017 	ldw	r3,0(r2)
 823beb0:	e0bffd17 	ldw	r2,-12(fp)
 823beb4:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 823beb8:	e0bffc17 	ldw	r2,-16(fp)
 823bebc:	10800017 	ldw	r2,0(r2)
 823bec0:	e0fffd17 	ldw	r3,-12(fp)
 823bec4:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 823bec8:	e0bffc17 	ldw	r2,-16(fp)
 823becc:	e0fffd17 	ldw	r3,-12(fp)
 823bed0:	10c00015 	stw	r3,0(r2)

  return 0;  
 823bed4:	0005883a 	mov	r2,zero
}
 823bed8:	e037883a 	mov	sp,fp
 823bedc:	dfc00117 	ldw	ra,4(sp)
 823bee0:	df000017 	ldw	fp,0(sp)
 823bee4:	dec00204 	addi	sp,sp,8
 823bee8:	f800283a 	ret

0823beec <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 823beec:	defffd04 	addi	sp,sp,-12
 823bef0:	dfc00215 	stw	ra,8(sp)
 823bef4:	df000115 	stw	fp,4(sp)
 823bef8:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 823befc:	00820974 	movhi	r2,2085
 823bf00:	10afcb04 	addi	r2,r2,-16596
 823bf04:	e0bfff15 	stw	r2,-4(fp)
 823bf08:	00000606 	br	823bf24 <_do_ctors+0x38>
        (*ctor) (); 
 823bf0c:	e0bfff17 	ldw	r2,-4(fp)
 823bf10:	10800017 	ldw	r2,0(r2)
 823bf14:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 823bf18:	e0bfff17 	ldw	r2,-4(fp)
 823bf1c:	10bfff04 	addi	r2,r2,-4
 823bf20:	e0bfff15 	stw	r2,-4(fp)
 823bf24:	e0ffff17 	ldw	r3,-4(fp)
 823bf28:	00820974 	movhi	r2,2085
 823bf2c:	10afcc04 	addi	r2,r2,-16592
 823bf30:	18bff62e 	bgeu	r3,r2,823bf0c <_do_ctors+0x20>
        (*ctor) (); 
}
 823bf34:	0001883a 	nop
 823bf38:	e037883a 	mov	sp,fp
 823bf3c:	dfc00117 	ldw	ra,4(sp)
 823bf40:	df000017 	ldw	fp,0(sp)
 823bf44:	dec00204 	addi	sp,sp,8
 823bf48:	f800283a 	ret

0823bf4c <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 823bf4c:	defffd04 	addi	sp,sp,-12
 823bf50:	dfc00215 	stw	ra,8(sp)
 823bf54:	df000115 	stw	fp,4(sp)
 823bf58:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 823bf5c:	00820974 	movhi	r2,2085
 823bf60:	10afcb04 	addi	r2,r2,-16596
 823bf64:	e0bfff15 	stw	r2,-4(fp)
 823bf68:	00000606 	br	823bf84 <_do_dtors+0x38>
        (*dtor) (); 
 823bf6c:	e0bfff17 	ldw	r2,-4(fp)
 823bf70:	10800017 	ldw	r2,0(r2)
 823bf74:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 823bf78:	e0bfff17 	ldw	r2,-4(fp)
 823bf7c:	10bfff04 	addi	r2,r2,-4
 823bf80:	e0bfff15 	stw	r2,-4(fp)
 823bf84:	e0ffff17 	ldw	r3,-4(fp)
 823bf88:	00820974 	movhi	r2,2085
 823bf8c:	10afcc04 	addi	r2,r2,-16592
 823bf90:	18bff62e 	bgeu	r3,r2,823bf6c <_do_dtors+0x20>
        (*dtor) (); 
}
 823bf94:	0001883a 	nop
 823bf98:	e037883a 	mov	sp,fp
 823bf9c:	dfc00117 	ldw	ra,4(sp)
 823bfa0:	df000017 	ldw	fp,0(sp)
 823bfa4:	dec00204 	addi	sp,sp,8
 823bfa8:	f800283a 	ret

0823bfac <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 823bfac:	defffa04 	addi	sp,sp,-24
 823bfb0:	dfc00515 	stw	ra,20(sp)
 823bfb4:	df000415 	stw	fp,16(sp)
 823bfb8:	df000404 	addi	fp,sp,16
 823bfbc:	e13ffe15 	stw	r4,-8(fp)
 823bfc0:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
 823bfc4:	e0bfff17 	ldw	r2,-4(fp)
 823bfc8:	10800017 	ldw	r2,0(r2)
 823bfcc:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 823bfd0:	e13ffe17 	ldw	r4,-8(fp)
 823bfd4:	8203fbc0 	call	8203fbc <strlen>
 823bfd8:	10800044 	addi	r2,r2,1
 823bfdc:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 823bfe0:	00000d06 	br	823c018 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 823bfe4:	e0bffc17 	ldw	r2,-16(fp)
 823bfe8:	10800217 	ldw	r2,8(r2)
 823bfec:	e0fffd17 	ldw	r3,-12(fp)
 823bff0:	180d883a 	mov	r6,r3
 823bff4:	e17ffe17 	ldw	r5,-8(fp)
 823bff8:	1009883a 	mov	r4,r2
 823bffc:	820c6380 	call	820c638 <memcmp>
 823c000:	1000021e 	bne	r2,zero,823c00c <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 823c004:	e0bffc17 	ldw	r2,-16(fp)
 823c008:	00000706 	br	823c028 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 823c00c:	e0bffc17 	ldw	r2,-16(fp)
 823c010:	10800017 	ldw	r2,0(r2)
 823c014:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 823c018:	e0fffc17 	ldw	r3,-16(fp)
 823c01c:	e0bfff17 	ldw	r2,-4(fp)
 823c020:	18bff01e 	bne	r3,r2,823bfe4 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 823c024:	0005883a 	mov	r2,zero
}
 823c028:	e037883a 	mov	sp,fp
 823c02c:	dfc00117 	ldw	ra,4(sp)
 823c030:	df000017 	ldw	fp,0(sp)
 823c034:	dec00204 	addi	sp,sp,8
 823c038:	f800283a 	ret

0823c03c <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 823c03c:	defff904 	addi	sp,sp,-28
 823c040:	dfc00615 	stw	ra,24(sp)
 823c044:	df000515 	stw	fp,20(sp)
 823c048:	df000504 	addi	fp,sp,20
 823c04c:	e13ffc15 	stw	r4,-16(fp)
 823c050:	e17ffd15 	stw	r5,-12(fp)
 823c054:	e1bffe15 	stw	r6,-8(fp)
 823c058:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 823c05c:	e0800217 	ldw	r2,8(fp)
 823c060:	d8800015 	stw	r2,0(sp)
 823c064:	e1ffff17 	ldw	r7,-4(fp)
 823c068:	e1bffe17 	ldw	r6,-8(fp)
 823c06c:	e17ffd17 	ldw	r5,-12(fp)
 823c070:	e13ffc17 	ldw	r4,-16(fp)
 823c074:	823c1ec0 	call	823c1ec <alt_iic_isr_register>
}  
 823c078:	e037883a 	mov	sp,fp
 823c07c:	dfc00117 	ldw	ra,4(sp)
 823c080:	df000017 	ldw	fp,0(sp)
 823c084:	dec00204 	addi	sp,sp,8
 823c088:	f800283a 	ret

0823c08c <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 823c08c:	defff904 	addi	sp,sp,-28
 823c090:	df000615 	stw	fp,24(sp)
 823c094:	df000604 	addi	fp,sp,24
 823c098:	e13ffe15 	stw	r4,-8(fp)
 823c09c:	e17fff15 	stw	r5,-4(fp)
 823c0a0:	e0bfff17 	ldw	r2,-4(fp)
 823c0a4:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823c0a8:	0005303a 	rdctl	r2,status
 823c0ac:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823c0b0:	e0fffb17 	ldw	r3,-20(fp)
 823c0b4:	00bfff84 	movi	r2,-2
 823c0b8:	1884703a 	and	r2,r3,r2
 823c0bc:	1001703a 	wrctl	status,r2
  
  return context;
 823c0c0:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 823c0c4:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
 823c0c8:	00c00044 	movi	r3,1
 823c0cc:	e0bffa17 	ldw	r2,-24(fp)
 823c0d0:	1884983a 	sll	r2,r3,r2
 823c0d4:	1007883a 	mov	r3,r2
 823c0d8:	d0a0b717 	ldw	r2,-32036(gp)
 823c0dc:	1884b03a 	or	r2,r3,r2
 823c0e0:	d0a0b715 	stw	r2,-32036(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 823c0e4:	d0a0b717 	ldw	r2,-32036(gp)
 823c0e8:	100170fa 	wrctl	ienable,r2
 823c0ec:	e0bffc17 	ldw	r2,-16(fp)
 823c0f0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823c0f4:	e0bffd17 	ldw	r2,-12(fp)
 823c0f8:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 823c0fc:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
 823c100:	0001883a 	nop
}
 823c104:	e037883a 	mov	sp,fp
 823c108:	df000017 	ldw	fp,0(sp)
 823c10c:	dec00104 	addi	sp,sp,4
 823c110:	f800283a 	ret

0823c114 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 823c114:	defff904 	addi	sp,sp,-28
 823c118:	df000615 	stw	fp,24(sp)
 823c11c:	df000604 	addi	fp,sp,24
 823c120:	e13ffe15 	stw	r4,-8(fp)
 823c124:	e17fff15 	stw	r5,-4(fp)
 823c128:	e0bfff17 	ldw	r2,-4(fp)
 823c12c:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823c130:	0005303a 	rdctl	r2,status
 823c134:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823c138:	e0fffb17 	ldw	r3,-20(fp)
 823c13c:	00bfff84 	movi	r2,-2
 823c140:	1884703a 	and	r2,r3,r2
 823c144:	1001703a 	wrctl	status,r2
  
  return context;
 823c148:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 823c14c:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
 823c150:	00c00044 	movi	r3,1
 823c154:	e0bffa17 	ldw	r2,-24(fp)
 823c158:	1884983a 	sll	r2,r3,r2
 823c15c:	0084303a 	nor	r2,zero,r2
 823c160:	1007883a 	mov	r3,r2
 823c164:	d0a0b717 	ldw	r2,-32036(gp)
 823c168:	1884703a 	and	r2,r3,r2
 823c16c:	d0a0b715 	stw	r2,-32036(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 823c170:	d0a0b717 	ldw	r2,-32036(gp)
 823c174:	100170fa 	wrctl	ienable,r2
 823c178:	e0bffc17 	ldw	r2,-16(fp)
 823c17c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823c180:	e0bffd17 	ldw	r2,-12(fp)
 823c184:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 823c188:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
 823c18c:	0001883a 	nop
}
 823c190:	e037883a 	mov	sp,fp
 823c194:	df000017 	ldw	fp,0(sp)
 823c198:	dec00104 	addi	sp,sp,4
 823c19c:	f800283a 	ret

0823c1a0 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 823c1a0:	defffc04 	addi	sp,sp,-16
 823c1a4:	df000315 	stw	fp,12(sp)
 823c1a8:	df000304 	addi	fp,sp,12
 823c1ac:	e13ffe15 	stw	r4,-8(fp)
 823c1b0:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 823c1b4:	000530fa 	rdctl	r2,ienable
 823c1b8:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 823c1bc:	00c00044 	movi	r3,1
 823c1c0:	e0bfff17 	ldw	r2,-4(fp)
 823c1c4:	1884983a 	sll	r2,r3,r2
 823c1c8:	1007883a 	mov	r3,r2
 823c1cc:	e0bffd17 	ldw	r2,-12(fp)
 823c1d0:	1884703a 	and	r2,r3,r2
 823c1d4:	1004c03a 	cmpne	r2,r2,zero
 823c1d8:	10803fcc 	andi	r2,r2,255
}
 823c1dc:	e037883a 	mov	sp,fp
 823c1e0:	df000017 	ldw	fp,0(sp)
 823c1e4:	dec00104 	addi	sp,sp,4
 823c1e8:	f800283a 	ret

0823c1ec <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 823c1ec:	defff504 	addi	sp,sp,-44
 823c1f0:	dfc00a15 	stw	ra,40(sp)
 823c1f4:	df000915 	stw	fp,36(sp)
 823c1f8:	df000904 	addi	fp,sp,36
 823c1fc:	e13ffc15 	stw	r4,-16(fp)
 823c200:	e17ffd15 	stw	r5,-12(fp)
 823c204:	e1bffe15 	stw	r6,-8(fp)
 823c208:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
 823c20c:	00bffa84 	movi	r2,-22
 823c210:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 823c214:	e0bffd17 	ldw	r2,-12(fp)
 823c218:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 823c21c:	e0bff817 	ldw	r2,-32(fp)
 823c220:	10800808 	cmpgei	r2,r2,32
 823c224:	1000271e 	bne	r2,zero,823c2c4 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823c228:	0005303a 	rdctl	r2,status
 823c22c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823c230:	e0fffb17 	ldw	r3,-20(fp)
 823c234:	00bfff84 	movi	r2,-2
 823c238:	1884703a 	and	r2,r3,r2
 823c23c:	1001703a 	wrctl	status,r2
  
  return context;
 823c240:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 823c244:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
 823c248:	008209b4 	movhi	r2,2086
 823c24c:	10b9e504 	addi	r2,r2,-6252
 823c250:	e0fff817 	ldw	r3,-32(fp)
 823c254:	180690fa 	slli	r3,r3,3
 823c258:	10c5883a 	add	r2,r2,r3
 823c25c:	e0fffe17 	ldw	r3,-8(fp)
 823c260:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
 823c264:	008209b4 	movhi	r2,2086
 823c268:	10b9e504 	addi	r2,r2,-6252
 823c26c:	e0fff817 	ldw	r3,-32(fp)
 823c270:	180690fa 	slli	r3,r3,3
 823c274:	10c5883a 	add	r2,r2,r3
 823c278:	10800104 	addi	r2,r2,4
 823c27c:	e0ffff17 	ldw	r3,-4(fp)
 823c280:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 823c284:	e0bffe17 	ldw	r2,-8(fp)
 823c288:	10000526 	beq	r2,zero,823c2a0 <alt_iic_isr_register+0xb4>
 823c28c:	e0bff817 	ldw	r2,-32(fp)
 823c290:	100b883a 	mov	r5,r2
 823c294:	e13ffc17 	ldw	r4,-16(fp)
 823c298:	823c08c0 	call	823c08c <alt_ic_irq_enable>
 823c29c:	00000406 	br	823c2b0 <alt_iic_isr_register+0xc4>
 823c2a0:	e0bff817 	ldw	r2,-32(fp)
 823c2a4:	100b883a 	mov	r5,r2
 823c2a8:	e13ffc17 	ldw	r4,-16(fp)
 823c2ac:	823c1140 	call	823c114 <alt_ic_irq_disable>
 823c2b0:	e0bff715 	stw	r2,-36(fp)
 823c2b4:	e0bffa17 	ldw	r2,-24(fp)
 823c2b8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823c2bc:	e0bff917 	ldw	r2,-28(fp)
 823c2c0:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 823c2c4:	e0bff717 	ldw	r2,-36(fp)
}
 823c2c8:	e037883a 	mov	sp,fp
 823c2cc:	dfc00117 	ldw	ra,4(sp)
 823c2d0:	df000017 	ldw	fp,0(sp)
 823c2d4:	dec00204 	addi	sp,sp,8
 823c2d8:	f800283a 	ret

0823c2dc <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 823c2dc:	defff904 	addi	sp,sp,-28
 823c2e0:	dfc00615 	stw	ra,24(sp)
 823c2e4:	df000515 	stw	fp,20(sp)
 823c2e8:	df000504 	addi	fp,sp,20
 823c2ec:	e13ffc15 	stw	r4,-16(fp)
 823c2f0:	e17ffd15 	stw	r5,-12(fp)
 823c2f4:	e1bffe15 	stw	r6,-8(fp)
 823c2f8:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 823c2fc:	e1bfff17 	ldw	r6,-4(fp)
 823c300:	e17ffe17 	ldw	r5,-8(fp)
 823c304:	e13ffd17 	ldw	r4,-12(fp)
 823c308:	823c51c0 	call	823c51c <open>
 823c30c:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 823c310:	e0bffb17 	ldw	r2,-20(fp)
 823c314:	10001c16 	blt	r2,zero,823c388 <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
 823c318:	00820974 	movhi	r2,2085
 823c31c:	108ef504 	addi	r2,r2,15316
 823c320:	e0fffb17 	ldw	r3,-20(fp)
 823c324:	18c00324 	muli	r3,r3,12
 823c328:	10c5883a 	add	r2,r2,r3
 823c32c:	10c00017 	ldw	r3,0(r2)
 823c330:	e0bffc17 	ldw	r2,-16(fp)
 823c334:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 823c338:	00820974 	movhi	r2,2085
 823c33c:	108ef504 	addi	r2,r2,15316
 823c340:	e0fffb17 	ldw	r3,-20(fp)
 823c344:	18c00324 	muli	r3,r3,12
 823c348:	10c5883a 	add	r2,r2,r3
 823c34c:	10800104 	addi	r2,r2,4
 823c350:	10c00017 	ldw	r3,0(r2)
 823c354:	e0bffc17 	ldw	r2,-16(fp)
 823c358:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 823c35c:	00820974 	movhi	r2,2085
 823c360:	108ef504 	addi	r2,r2,15316
 823c364:	e0fffb17 	ldw	r3,-20(fp)
 823c368:	18c00324 	muli	r3,r3,12
 823c36c:	10c5883a 	add	r2,r2,r3
 823c370:	10800204 	addi	r2,r2,8
 823c374:	10c00017 	ldw	r3,0(r2)
 823c378:	e0bffc17 	ldw	r2,-16(fp)
 823c37c:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 823c380:	e13ffb17 	ldw	r4,-20(fp)
 823c384:	823c7a80 	call	823c7a8 <alt_release_fd>
  }
} 
 823c388:	0001883a 	nop
 823c38c:	e037883a 	mov	sp,fp
 823c390:	dfc00117 	ldw	ra,4(sp)
 823c394:	df000017 	ldw	fp,0(sp)
 823c398:	dec00204 	addi	sp,sp,8
 823c39c:	f800283a 	ret

0823c3a0 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 823c3a0:	defffb04 	addi	sp,sp,-20
 823c3a4:	dfc00415 	stw	ra,16(sp)
 823c3a8:	df000315 	stw	fp,12(sp)
 823c3ac:	df000304 	addi	fp,sp,12
 823c3b0:	e13ffd15 	stw	r4,-12(fp)
 823c3b4:	e17ffe15 	stw	r5,-8(fp)
 823c3b8:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 823c3bc:	01c07fc4 	movi	r7,511
 823c3c0:	01800044 	movi	r6,1
 823c3c4:	e17ffd17 	ldw	r5,-12(fp)
 823c3c8:	01020974 	movhi	r4,2085
 823c3cc:	210ef804 	addi	r4,r4,15328
 823c3d0:	823c2dc0 	call	823c2dc <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 823c3d4:	01c07fc4 	movi	r7,511
 823c3d8:	000d883a 	mov	r6,zero
 823c3dc:	e17ffe17 	ldw	r5,-8(fp)
 823c3e0:	01020974 	movhi	r4,2085
 823c3e4:	210ef504 	addi	r4,r4,15316
 823c3e8:	823c2dc0 	call	823c2dc <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 823c3ec:	01c07fc4 	movi	r7,511
 823c3f0:	01800044 	movi	r6,1
 823c3f4:	e17fff17 	ldw	r5,-4(fp)
 823c3f8:	01020974 	movhi	r4,2085
 823c3fc:	210efb04 	addi	r4,r4,15340
 823c400:	823c2dc0 	call	823c2dc <alt_open_fd>
}  
 823c404:	0001883a 	nop
 823c408:	e037883a 	mov	sp,fp
 823c40c:	dfc00117 	ldw	ra,4(sp)
 823c410:	df000017 	ldw	fp,0(sp)
 823c414:	dec00204 	addi	sp,sp,8
 823c418:	f800283a 	ret

0823c41c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823c41c:	defffe04 	addi	sp,sp,-8
 823c420:	dfc00115 	stw	ra,4(sp)
 823c424:	df000015 	stw	fp,0(sp)
 823c428:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823c42c:	d0a04717 	ldw	r2,-32484(gp)
 823c430:	10000326 	beq	r2,zero,823c440 <alt_get_errno+0x24>
 823c434:	d0a04717 	ldw	r2,-32484(gp)
 823c438:	103ee83a 	callr	r2
 823c43c:	00000106 	br	823c444 <alt_get_errno+0x28>
 823c440:	d0a06304 	addi	r2,gp,-32372
}
 823c444:	e037883a 	mov	sp,fp
 823c448:	dfc00117 	ldw	ra,4(sp)
 823c44c:	df000017 	ldw	fp,0(sp)
 823c450:	dec00204 	addi	sp,sp,8
 823c454:	f800283a 	ret

0823c458 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 823c458:	defffd04 	addi	sp,sp,-12
 823c45c:	df000215 	stw	fp,8(sp)
 823c460:	df000204 	addi	fp,sp,8
 823c464:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 823c468:	e0bfff17 	ldw	r2,-4(fp)
 823c46c:	10800217 	ldw	r2,8(r2)
 823c470:	10d00034 	orhi	r3,r2,16384
 823c474:	e0bfff17 	ldw	r2,-4(fp)
 823c478:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 823c47c:	e03ffe15 	stw	zero,-8(fp)
 823c480:	00001d06 	br	823c4f8 <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 823c484:	00820974 	movhi	r2,2085
 823c488:	108ef504 	addi	r2,r2,15316
 823c48c:	e0fffe17 	ldw	r3,-8(fp)
 823c490:	18c00324 	muli	r3,r3,12
 823c494:	10c5883a 	add	r2,r2,r3
 823c498:	10c00017 	ldw	r3,0(r2)
 823c49c:	e0bfff17 	ldw	r2,-4(fp)
 823c4a0:	10800017 	ldw	r2,0(r2)
 823c4a4:	1880111e 	bne	r3,r2,823c4ec <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 823c4a8:	00820974 	movhi	r2,2085
 823c4ac:	108ef504 	addi	r2,r2,15316
 823c4b0:	e0fffe17 	ldw	r3,-8(fp)
 823c4b4:	18c00324 	muli	r3,r3,12
 823c4b8:	10c5883a 	add	r2,r2,r3
 823c4bc:	10800204 	addi	r2,r2,8
 823c4c0:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 823c4c4:	1000090e 	bge	r2,zero,823c4ec <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
 823c4c8:	e0bffe17 	ldw	r2,-8(fp)
 823c4cc:	10c00324 	muli	r3,r2,12
 823c4d0:	00820974 	movhi	r2,2085
 823c4d4:	108ef504 	addi	r2,r2,15316
 823c4d8:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 823c4dc:	e0bfff17 	ldw	r2,-4(fp)
 823c4e0:	18800226 	beq	r3,r2,823c4ec <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 823c4e4:	00bffcc4 	movi	r2,-13
 823c4e8:	00000806 	br	823c50c <alt_file_locked+0xb4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 823c4ec:	e0bffe17 	ldw	r2,-8(fp)
 823c4f0:	10800044 	addi	r2,r2,1
 823c4f4:	e0bffe15 	stw	r2,-8(fp)
 823c4f8:	d0a04617 	ldw	r2,-32488(gp)
 823c4fc:	1007883a 	mov	r3,r2
 823c500:	e0bffe17 	ldw	r2,-8(fp)
 823c504:	18bfdf2e 	bgeu	r3,r2,823c484 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 823c508:	0005883a 	mov	r2,zero
}
 823c50c:	e037883a 	mov	sp,fp
 823c510:	df000017 	ldw	fp,0(sp)
 823c514:	dec00104 	addi	sp,sp,4
 823c518:	f800283a 	ret

0823c51c <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 823c51c:	defff604 	addi	sp,sp,-40
 823c520:	dfc00915 	stw	ra,36(sp)
 823c524:	df000815 	stw	fp,32(sp)
 823c528:	df000804 	addi	fp,sp,32
 823c52c:	e13ffd15 	stw	r4,-12(fp)
 823c530:	e17ffe15 	stw	r5,-8(fp)
 823c534:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 823c538:	00bfffc4 	movi	r2,-1
 823c53c:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
 823c540:	00bffb44 	movi	r2,-19
 823c544:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
 823c548:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 823c54c:	d1604404 	addi	r5,gp,-32496
 823c550:	e13ffd17 	ldw	r4,-12(fp)
 823c554:	823bfac0 	call	823bfac <alt_find_dev>
 823c558:	e0bff815 	stw	r2,-32(fp)
 823c55c:	e0bff817 	ldw	r2,-32(fp)
 823c560:	1000051e 	bne	r2,zero,823c578 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 823c564:	e13ffd17 	ldw	r4,-12(fp)
 823c568:	824a2d80 	call	824a2d8 <alt_find_file>
 823c56c:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
 823c570:	00800044 	movi	r2,1
 823c574:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 823c578:	e0bff817 	ldw	r2,-32(fp)
 823c57c:	10002926 	beq	r2,zero,823c624 <open+0x108>
  {
    if ((index = alt_get_fd (dev)) < 0)
 823c580:	e13ff817 	ldw	r4,-32(fp)
 823c584:	824a3e00 	call	824a3e0 <alt_get_fd>
 823c588:	e0bff915 	stw	r2,-28(fp)
 823c58c:	e0bff917 	ldw	r2,-28(fp)
 823c590:	1000030e 	bge	r2,zero,823c5a0 <open+0x84>
    {
      status = index;
 823c594:	e0bff917 	ldw	r2,-28(fp)
 823c598:	e0bffa15 	stw	r2,-24(fp)
 823c59c:	00002306 	br	823c62c <open+0x110>
    }
    else
    {
      fd = &alt_fd_list[index];
 823c5a0:	e0bff917 	ldw	r2,-28(fp)
 823c5a4:	10c00324 	muli	r3,r2,12
 823c5a8:	00820974 	movhi	r2,2085
 823c5ac:	108ef504 	addi	r2,r2,15316
 823c5b0:	1885883a 	add	r2,r3,r2
 823c5b4:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 823c5b8:	e0fffe17 	ldw	r3,-8(fp)
 823c5bc:	00900034 	movhi	r2,16384
 823c5c0:	10bfffc4 	addi	r2,r2,-1
 823c5c4:	1886703a 	and	r3,r3,r2
 823c5c8:	e0bffc17 	ldw	r2,-16(fp)
 823c5cc:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 823c5d0:	e0bffb17 	ldw	r2,-20(fp)
 823c5d4:	1000051e 	bne	r2,zero,823c5ec <open+0xd0>
 823c5d8:	e13ffc17 	ldw	r4,-16(fp)
 823c5dc:	823c4580 	call	823c458 <alt_file_locked>
 823c5e0:	e0bffa15 	stw	r2,-24(fp)
 823c5e4:	e0bffa17 	ldw	r2,-24(fp)
 823c5e8:	10001016 	blt	r2,zero,823c62c <open+0x110>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 823c5ec:	e0bff817 	ldw	r2,-32(fp)
 823c5f0:	10800317 	ldw	r2,12(r2)
 823c5f4:	10000826 	beq	r2,zero,823c618 <open+0xfc>
 823c5f8:	e0bff817 	ldw	r2,-32(fp)
 823c5fc:	10800317 	ldw	r2,12(r2)
 823c600:	e1ffff17 	ldw	r7,-4(fp)
 823c604:	e1bffe17 	ldw	r6,-8(fp)
 823c608:	e17ffd17 	ldw	r5,-12(fp)
 823c60c:	e13ffc17 	ldw	r4,-16(fp)
 823c610:	103ee83a 	callr	r2
 823c614:	00000106 	br	823c61c <open+0x100>
 823c618:	0005883a 	mov	r2,zero
 823c61c:	e0bffa15 	stw	r2,-24(fp)
 823c620:	00000206 	br	823c62c <open+0x110>
      }
    }
  }
  else
  {
    status = -ENODEV;
 823c624:	00bffb44 	movi	r2,-19
 823c628:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 823c62c:	e0bffa17 	ldw	r2,-24(fp)
 823c630:	1000090e 	bge	r2,zero,823c658 <open+0x13c>
  {
    alt_release_fd (index);  
 823c634:	e13ff917 	ldw	r4,-28(fp)
 823c638:	823c7a80 	call	823c7a8 <alt_release_fd>
    ALT_ERRNO = -status;
 823c63c:	823c41c0 	call	823c41c <alt_get_errno>
 823c640:	1007883a 	mov	r3,r2
 823c644:	e0bffa17 	ldw	r2,-24(fp)
 823c648:	0085c83a 	sub	r2,zero,r2
 823c64c:	18800015 	stw	r2,0(r3)
    return -1;
 823c650:	00bfffc4 	movi	r2,-1
 823c654:	00000106 	br	823c65c <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
 823c658:	e0bff917 	ldw	r2,-28(fp)
}
 823c65c:	e037883a 	mov	sp,fp
 823c660:	dfc00117 	ldw	ra,4(sp)
 823c664:	df000017 	ldw	fp,0(sp)
 823c668:	dec00204 	addi	sp,sp,8
 823c66c:	f800283a 	ret

0823c670 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823c670:	defffe04 	addi	sp,sp,-8
 823c674:	dfc00115 	stw	ra,4(sp)
 823c678:	df000015 	stw	fp,0(sp)
 823c67c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823c680:	d0a04717 	ldw	r2,-32484(gp)
 823c684:	10000326 	beq	r2,zero,823c694 <alt_get_errno+0x24>
 823c688:	d0a04717 	ldw	r2,-32484(gp)
 823c68c:	103ee83a 	callr	r2
 823c690:	00000106 	br	823c698 <alt_get_errno+0x28>
 823c694:	d0a06304 	addi	r2,gp,-32372
}
 823c698:	e037883a 	mov	sp,fp
 823c69c:	dfc00117 	ldw	ra,4(sp)
 823c6a0:	df000017 	ldw	fp,0(sp)
 823c6a4:	dec00204 	addi	sp,sp,8
 823c6a8:	f800283a 	ret

0823c6ac <alt_read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 823c6ac:	defff904 	addi	sp,sp,-28
 823c6b0:	dfc00615 	stw	ra,24(sp)
 823c6b4:	df000515 	stw	fp,20(sp)
 823c6b8:	df000504 	addi	fp,sp,20
 823c6bc:	e13ffd15 	stw	r4,-12(fp)
 823c6c0:	e17ffe15 	stw	r5,-8(fp)
 823c6c4:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 823c6c8:	e0bffd17 	ldw	r2,-12(fp)
 823c6cc:	10000616 	blt	r2,zero,823c6e8 <alt_read+0x3c>
 823c6d0:	e0bffd17 	ldw	r2,-12(fp)
 823c6d4:	10c00324 	muli	r3,r2,12
 823c6d8:	00820974 	movhi	r2,2085
 823c6dc:	108ef504 	addi	r2,r2,15316
 823c6e0:	1885883a 	add	r2,r3,r2
 823c6e4:	00000106 	br	823c6ec <alt_read+0x40>
 823c6e8:	0005883a 	mov	r2,zero
 823c6ec:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 823c6f0:	e0bffb17 	ldw	r2,-20(fp)
 823c6f4:	10002226 	beq	r2,zero,823c780 <alt_read+0xd4>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 823c6f8:	e0bffb17 	ldw	r2,-20(fp)
 823c6fc:	10800217 	ldw	r2,8(r2)
 823c700:	108000cc 	andi	r2,r2,3
 823c704:	10800060 	cmpeqi	r2,r2,1
 823c708:	1000181e 	bne	r2,zero,823c76c <alt_read+0xc0>
        (fd->dev->read))
 823c70c:	e0bffb17 	ldw	r2,-20(fp)
 823c710:	10800017 	ldw	r2,0(r2)
 823c714:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 823c718:	10001426 	beq	r2,zero,823c76c <alt_read+0xc0>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 823c71c:	e0bffb17 	ldw	r2,-20(fp)
 823c720:	10800017 	ldw	r2,0(r2)
 823c724:	10800517 	ldw	r2,20(r2)
 823c728:	e0ffff17 	ldw	r3,-4(fp)
 823c72c:	180d883a 	mov	r6,r3
 823c730:	e17ffe17 	ldw	r5,-8(fp)
 823c734:	e13ffb17 	ldw	r4,-20(fp)
 823c738:	103ee83a 	callr	r2
 823c73c:	e0bffc15 	stw	r2,-16(fp)
 823c740:	e0bffc17 	ldw	r2,-16(fp)
 823c744:	1000070e 	bge	r2,zero,823c764 <alt_read+0xb8>
        {
          ALT_ERRNO = -rval;
 823c748:	823c6700 	call	823c670 <alt_get_errno>
 823c74c:	1007883a 	mov	r3,r2
 823c750:	e0bffc17 	ldw	r2,-16(fp)
 823c754:	0085c83a 	sub	r2,zero,r2
 823c758:	18800015 	stw	r2,0(r3)
          return -1;
 823c75c:	00bfffc4 	movi	r2,-1
 823c760:	00000c06 	br	823c794 <alt_read+0xe8>
        }
        return rval;
 823c764:	e0bffc17 	ldw	r2,-16(fp)
 823c768:	00000a06 	br	823c794 <alt_read+0xe8>
      }
      else
      {
        ALT_ERRNO = EACCES;
 823c76c:	823c6700 	call	823c670 <alt_get_errno>
 823c770:	1007883a 	mov	r3,r2
 823c774:	00800344 	movi	r2,13
 823c778:	18800015 	stw	r2,0(r3)
 823c77c:	00000406 	br	823c790 <alt_read+0xe4>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 823c780:	823c6700 	call	823c670 <alt_get_errno>
 823c784:	1007883a 	mov	r3,r2
 823c788:	00801444 	movi	r2,81
 823c78c:	18800015 	stw	r2,0(r3)
  }
  return -1;
 823c790:	00bfffc4 	movi	r2,-1
}
 823c794:	e037883a 	mov	sp,fp
 823c798:	dfc00117 	ldw	ra,4(sp)
 823c79c:	df000017 	ldw	fp,0(sp)
 823c7a0:	dec00204 	addi	sp,sp,8
 823c7a4:	f800283a 	ret

0823c7a8 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 823c7a8:	defffe04 	addi	sp,sp,-8
 823c7ac:	df000115 	stw	fp,4(sp)
 823c7b0:	df000104 	addi	fp,sp,4
 823c7b4:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 823c7b8:	e0bfff17 	ldw	r2,-4(fp)
 823c7bc:	108000d0 	cmplti	r2,r2,3
 823c7c0:	10000d1e 	bne	r2,zero,823c7f8 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 823c7c4:	00820974 	movhi	r2,2085
 823c7c8:	108ef504 	addi	r2,r2,15316
 823c7cc:	e0ffff17 	ldw	r3,-4(fp)
 823c7d0:	18c00324 	muli	r3,r3,12
 823c7d4:	10c5883a 	add	r2,r2,r3
 823c7d8:	10800204 	addi	r2,r2,8
 823c7dc:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 823c7e0:	00820974 	movhi	r2,2085
 823c7e4:	108ef504 	addi	r2,r2,15316
 823c7e8:	e0ffff17 	ldw	r3,-4(fp)
 823c7ec:	18c00324 	muli	r3,r3,12
 823c7f0:	10c5883a 	add	r2,r2,r3
 823c7f4:	10000015 	stw	zero,0(r2)
  }
}
 823c7f8:	0001883a 	nop
 823c7fc:	e037883a 	mov	sp,fp
 823c800:	df000017 	ldw	fp,0(sp)
 823c804:	dec00104 	addi	sp,sp,4
 823c808:	f800283a 	ret

0823c80c <alt_remap_cached>:
 * Convert a pointer to a block of uncached memory, into a block of
 * cached memory.
 */

void* alt_remap_cached (volatile void* ptr, alt_u32 len)
{
 823c80c:	defffd04 	addi	sp,sp,-12
 823c810:	df000215 	stw	fp,8(sp)
 823c814:	df000204 	addi	fp,sp,8
 823c818:	e13ffe15 	stw	r4,-8(fp)
 823c81c:	e17fff15 	stw	r5,-4(fp)
  return (void*) (((alt_u32) ptr) & ~BYPASS_DCACHE_MASK);
 823c820:	e0fffe17 	ldw	r3,-8(fp)
 823c824:	00a00034 	movhi	r2,32768
 823c828:	10bfffc4 	addi	r2,r2,-1
 823c82c:	1884703a 	and	r2,r3,r2
}
 823c830:	e037883a 	mov	sp,fp
 823c834:	df000017 	ldw	fp,0(sp)
 823c838:	dec00104 	addi	sp,sp,4
 823c83c:	f800283a 	ret

0823c840 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 823c840:	defffa04 	addi	sp,sp,-24
 823c844:	df000515 	stw	fp,20(sp)
 823c848:	df000504 	addi	fp,sp,20
 823c84c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823c850:	0005303a 	rdctl	r2,status
 823c854:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823c858:	e0fffc17 	ldw	r3,-16(fp)
 823c85c:	00bfff84 	movi	r2,-2
 823c860:	1884703a 	and	r2,r3,r2
 823c864:	1001703a 	wrctl	status,r2
  
  return context;
 823c868:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 823c86c:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
 823c870:	e0bfff17 	ldw	r2,-4(fp)
 823c874:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 823c878:	e0bffd17 	ldw	r2,-12(fp)
 823c87c:	10800017 	ldw	r2,0(r2)
 823c880:	e0fffd17 	ldw	r3,-12(fp)
 823c884:	18c00117 	ldw	r3,4(r3)
 823c888:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 823c88c:	e0bffd17 	ldw	r2,-12(fp)
 823c890:	10800117 	ldw	r2,4(r2)
 823c894:	e0fffd17 	ldw	r3,-12(fp)
 823c898:	18c00017 	ldw	r3,0(r3)
 823c89c:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 823c8a0:	e0bffd17 	ldw	r2,-12(fp)
 823c8a4:	e0fffd17 	ldw	r3,-12(fp)
 823c8a8:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 823c8ac:	e0bffd17 	ldw	r2,-12(fp)
 823c8b0:	e0fffd17 	ldw	r3,-12(fp)
 823c8b4:	10c00015 	stw	r3,0(r2)
 823c8b8:	e0bffb17 	ldw	r2,-20(fp)
 823c8bc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823c8c0:	e0bffe17 	ldw	r2,-8(fp)
 823c8c4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 823c8c8:	0001883a 	nop
 823c8cc:	e037883a 	mov	sp,fp
 823c8d0:	df000017 	ldw	fp,0(sp)
 823c8d4:	dec00104 	addi	sp,sp,4
 823c8d8:	f800283a 	ret

0823c8dc <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 823c8dc:	defffb04 	addi	sp,sp,-20
 823c8e0:	dfc00415 	stw	ra,16(sp)
 823c8e4:	df000315 	stw	fp,12(sp)
 823c8e8:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 823c8ec:	d0a04917 	ldw	r2,-32476(gp)
 823c8f0:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 823c8f4:	d0a0b917 	ldw	r2,-32028(gp)
 823c8f8:	10800044 	addi	r2,r2,1
 823c8fc:	d0a0b915 	stw	r2,-32028(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 823c900:	00002e06 	br	823c9bc <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 823c904:	e0bffd17 	ldw	r2,-12(fp)
 823c908:	10800017 	ldw	r2,0(r2)
 823c90c:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 823c910:	e0bffd17 	ldw	r2,-12(fp)
 823c914:	10800403 	ldbu	r2,16(r2)
 823c918:	10803fcc 	andi	r2,r2,255
 823c91c:	10000426 	beq	r2,zero,823c930 <alt_tick+0x54>
 823c920:	d0a0b917 	ldw	r2,-32028(gp)
 823c924:	1000021e 	bne	r2,zero,823c930 <alt_tick+0x54>
    {
      alarm->rollover = 0;
 823c928:	e0bffd17 	ldw	r2,-12(fp)
 823c92c:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 823c930:	e0bffd17 	ldw	r2,-12(fp)
 823c934:	10800217 	ldw	r2,8(r2)
 823c938:	d0e0b917 	ldw	r3,-32028(gp)
 823c93c:	18801d36 	bltu	r3,r2,823c9b4 <alt_tick+0xd8>
 823c940:	e0bffd17 	ldw	r2,-12(fp)
 823c944:	10800403 	ldbu	r2,16(r2)
 823c948:	10803fcc 	andi	r2,r2,255
 823c94c:	1000191e 	bne	r2,zero,823c9b4 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 823c950:	e0bffd17 	ldw	r2,-12(fp)
 823c954:	10800317 	ldw	r2,12(r2)
 823c958:	e0fffd17 	ldw	r3,-12(fp)
 823c95c:	18c00517 	ldw	r3,20(r3)
 823c960:	1809883a 	mov	r4,r3
 823c964:	103ee83a 	callr	r2
 823c968:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 823c96c:	e0bfff17 	ldw	r2,-4(fp)
 823c970:	1000031e 	bne	r2,zero,823c980 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 823c974:	e13ffd17 	ldw	r4,-12(fp)
 823c978:	823c8400 	call	823c840 <alt_alarm_stop>
 823c97c:	00000d06 	br	823c9b4 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 823c980:	e0bffd17 	ldw	r2,-12(fp)
 823c984:	10c00217 	ldw	r3,8(r2)
 823c988:	e0bfff17 	ldw	r2,-4(fp)
 823c98c:	1887883a 	add	r3,r3,r2
 823c990:	e0bffd17 	ldw	r2,-12(fp)
 823c994:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 823c998:	e0bffd17 	ldw	r2,-12(fp)
 823c99c:	10c00217 	ldw	r3,8(r2)
 823c9a0:	d0a0b917 	ldw	r2,-32028(gp)
 823c9a4:	1880032e 	bgeu	r3,r2,823c9b4 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 823c9a8:	e0bffd17 	ldw	r2,-12(fp)
 823c9ac:	00c00044 	movi	r3,1
 823c9b0:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 823c9b4:	e0bffe17 	ldw	r2,-8(fp)
 823c9b8:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 823c9bc:	e0fffd17 	ldw	r3,-12(fp)
 823c9c0:	d0a04904 	addi	r2,gp,-32476
 823c9c4:	18bfcf1e 	bne	r3,r2,823c904 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 823c9c8:	82158d40 	call	82158d4 <OSTimeTick>
}
 823c9cc:	0001883a 	nop
 823c9d0:	e037883a 	mov	sp,fp
 823c9d4:	dfc00117 	ldw	ra,4(sp)
 823c9d8:	df000017 	ldw	fp,0(sp)
 823c9dc:	dec00204 	addi	sp,sp,8
 823c9e0:	f800283a 	ret

0823c9e4 <alt_uncached_free>:
/*
 * Free a block of uncached memory.
 */

void alt_uncached_free (volatile void* ptr)
{
 823c9e4:	defffd04 	addi	sp,sp,-12
 823c9e8:	dfc00215 	stw	ra,8(sp)
 823c9ec:	df000115 	stw	fp,4(sp)
 823c9f0:	df000104 	addi	fp,sp,4
 823c9f4:	e13fff15 	stw	r4,-4(fp)
  free ((void*) (((alt_u32) ptr) & ~BYPASS_DCACHE_MASK));
 823c9f8:	e0ffff17 	ldw	r3,-4(fp)
 823c9fc:	00a00034 	movhi	r2,32768
 823ca00:	10bfffc4 	addi	r2,r2,-1
 823ca04:	1884703a 	and	r2,r3,r2
 823ca08:	1009883a 	mov	r4,r2
 823ca0c:	824b7000 	call	824b700 <free>
}
 823ca10:	0001883a 	nop
 823ca14:	e037883a 	mov	sp,fp
 823ca18:	dfc00117 	ldw	ra,4(sp)
 823ca1c:	df000017 	ldw	fp,0(sp)
 823ca20:	dec00204 	addi	sp,sp,8
 823ca24:	f800283a 	ret

0823ca28 <alt_uncached_malloc>:
/*
 * Allocate a block of uncached memory.
 */

volatile void* alt_uncached_malloc (size_t size)
{
 823ca28:	defffc04 	addi	sp,sp,-16
 823ca2c:	dfc00315 	stw	ra,12(sp)
 823ca30:	df000215 	stw	fp,8(sp)
 823ca34:	df000204 	addi	fp,sp,8
 823ca38:	e13fff15 	stw	r4,-4(fp)
  void* ptr;

  ptr = malloc (size);
 823ca3c:	e13fff17 	ldw	r4,-4(fp)
 823ca40:	824b6ec0 	call	824b6ec <malloc>
 823ca44:	e0bffe15 	stw	r2,-8(fp)

  alt_dcache_flush (ptr, size);
 823ca48:	e17fff17 	ldw	r5,-4(fp)
 823ca4c:	e13ffe17 	ldw	r4,-8(fp)
 823ca50:	823bd680 	call	823bd68 <alt_dcache_flush>

  return ptr ? (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK) : NULL;
 823ca54:	e0bffe17 	ldw	r2,-8(fp)
 823ca58:	10000326 	beq	r2,zero,823ca68 <alt_uncached_malloc+0x40>
 823ca5c:	e0bffe17 	ldw	r2,-8(fp)
 823ca60:	10a00034 	orhi	r2,r2,32768
 823ca64:	00000106 	br	823ca6c <alt_uncached_malloc+0x44>
 823ca68:	0005883a 	mov	r2,zero
}
 823ca6c:	e037883a 	mov	sp,fp
 823ca70:	dfc00117 	ldw	ra,4(sp)
 823ca74:	df000017 	ldw	fp,0(sp)
 823ca78:	dec00204 	addi	sp,sp,8
 823ca7c:	f800283a 	ret

0823ca80 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 823ca80:	defffb04 	addi	sp,sp,-20
 823ca84:	dfc00415 	stw	ra,16(sp)
 823ca88:	df000315 	stw	fp,12(sp)
 823ca8c:	df000304 	addi	fp,sp,12
 823ca90:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
 823ca94:	d0a06b43 	ldbu	r2,-32339(gp)
 823ca98:	10803fcc 	andi	r2,r2,255
 823ca9c:	1000031e 	bne	r2,zero,823caac <usleep+0x2c>
  {
    return alt_busy_sleep (us);
 823caa0:	e13fff17 	ldw	r4,-4(fp)
 823caa4:	824a0240 	call	824a024 <alt_busy_sleep>
 823caa8:	00003e06 	br	823cba4 <usleep+0x124>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 823caac:	d0a0b817 	ldw	r2,-32032(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
 823cab0:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
 823cab4:	e0ffff17 	ldw	r3,-4(fp)
 823cab8:	0090c734 	movhi	r2,17180
 823cabc:	10b7a0c4 	addi	r2,r2,-8573
 823cac0:	1888383a 	mulxuu	r4,r3,r2
 823cac4:	1885383a 	mul	r2,r3,r2
 823cac8:	1013883a 	mov	r9,r2
 823cacc:	2015883a 	mov	r10,r4
 823cad0:	5006d4ba 	srli	r3,r10,18
 823cad4:	e0bffe17 	ldw	r2,-8(fp)
 823cad8:	1893383a 	mul	r9,r3,r2
 823cadc:	e0ffff17 	ldw	r3,-4(fp)
 823cae0:	0090c734 	movhi	r2,17180
 823cae4:	10b7a0c4 	addi	r2,r2,-8573
 823cae8:	1888383a 	mulxuu	r4,r3,r2
 823caec:	1885383a 	mul	r2,r3,r2
 823caf0:	100f883a 	mov	r7,r2
 823caf4:	2011883a 	mov	r8,r4
 823caf8:	4004d4ba 	srli	r2,r8,18
 823cafc:	010003f4 	movhi	r4,15
 823cb00:	21109004 	addi	r4,r4,16960
 823cb04:	1105383a 	mul	r2,r2,r4
 823cb08:	1885c83a 	sub	r2,r3,r2
 823cb0c:	e0fffe17 	ldw	r3,-8(fp)
 823cb10:	10c7383a 	mul	r3,r2,r3
 823cb14:	0090c734 	movhi	r2,17180
 823cb18:	10b7a0c4 	addi	r2,r2,-8573
 823cb1c:	1888383a 	mulxuu	r4,r3,r2
 823cb20:	1885383a 	mul	r2,r3,r2
 823cb24:	100b883a 	mov	r5,r2
 823cb28:	200d883a 	mov	r6,r4
 823cb2c:	3004d4ba 	srli	r2,r6,18
 823cb30:	4885883a 	add	r2,r9,r2
 823cb34:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 823cb38:	00000706 	br	823cb58 <usleep+0xd8>
  {
    OSTimeDly(0xffff);
 823cb3c:	013fffd4 	movui	r4,65535
 823cb40:	821bf340 	call	821bf34 <OSTimeDly>
    ticks -= 0xffff;
 823cb44:	e0fffd17 	ldw	r3,-12(fp)
 823cb48:	00bffff4 	movhi	r2,65535
 823cb4c:	10800044 	addi	r2,r2,1
 823cb50:	1885883a 	add	r2,r3,r2
 823cb54:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 823cb58:	e0bffd17 	ldw	r2,-12(fp)
 823cb5c:	00ffffd4 	movui	r3,65535
 823cb60:	18bff636 	bltu	r3,r2,823cb3c <usleep+0xbc>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
 823cb64:	e0bffd17 	ldw	r2,-12(fp)
 823cb68:	10bfffcc 	andi	r2,r2,65535
 823cb6c:	1009883a 	mov	r4,r2
 823cb70:	821bf340 	call	821bf34 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
 823cb74:	e17ffe17 	ldw	r5,-8(fp)
 823cb78:	010003f4 	movhi	r4,15
 823cb7c:	21109004 	addi	r4,r4,16960
 823cb80:	8202c6c0 	call	8202c6c <__udivsi3>
 823cb84:	1007883a 	mov	r3,r2
 823cb88:	e0bfff17 	ldw	r2,-4(fp)
 823cb8c:	180b883a 	mov	r5,r3
 823cb90:	1009883a 	mov	r4,r2
 823cb94:	8202cd00 	call	8202cd0 <__umodsi3>
 823cb98:	1009883a 	mov	r4,r2
 823cb9c:	824a0240 	call	824a024 <alt_busy_sleep>

  return 0;  
 823cba0:	0005883a 	mov	r2,zero
}
 823cba4:	e037883a 	mov	sp,fp
 823cba8:	dfc00117 	ldw	ra,4(sp)
 823cbac:	df000017 	ldw	fp,0(sp)
 823cbb0:	dec00204 	addi	sp,sp,8
 823cbb4:	f800283a 	ret

0823cbb8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823cbb8:	defffe04 	addi	sp,sp,-8
 823cbbc:	dfc00115 	stw	ra,4(sp)
 823cbc0:	df000015 	stw	fp,0(sp)
 823cbc4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823cbc8:	d0a04717 	ldw	r2,-32484(gp)
 823cbcc:	10000326 	beq	r2,zero,823cbdc <alt_get_errno+0x24>
 823cbd0:	d0a04717 	ldw	r2,-32484(gp)
 823cbd4:	103ee83a 	callr	r2
 823cbd8:	00000106 	br	823cbe0 <alt_get_errno+0x28>
 823cbdc:	d0a06304 	addi	r2,gp,-32372
}
 823cbe0:	e037883a 	mov	sp,fp
 823cbe4:	dfc00117 	ldw	ra,4(sp)
 823cbe8:	df000017 	ldw	fp,0(sp)
 823cbec:	dec00204 	addi	sp,sp,8
 823cbf0:	f800283a 	ret

0823cbf4 <alt_write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 823cbf4:	defff904 	addi	sp,sp,-28
 823cbf8:	dfc00615 	stw	ra,24(sp)
 823cbfc:	df000515 	stw	fp,20(sp)
 823cc00:	df000504 	addi	fp,sp,20
 823cc04:	e13ffd15 	stw	r4,-12(fp)
 823cc08:	e17ffe15 	stw	r5,-8(fp)
 823cc0c:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 823cc10:	e0bffd17 	ldw	r2,-12(fp)
 823cc14:	10000616 	blt	r2,zero,823cc30 <alt_write+0x3c>
 823cc18:	e0bffd17 	ldw	r2,-12(fp)
 823cc1c:	10c00324 	muli	r3,r2,12
 823cc20:	00820974 	movhi	r2,2085
 823cc24:	108ef504 	addi	r2,r2,15316
 823cc28:	1885883a 	add	r2,r3,r2
 823cc2c:	00000106 	br	823cc34 <alt_write+0x40>
 823cc30:	0005883a 	mov	r2,zero
 823cc34:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 823cc38:	e0bffb17 	ldw	r2,-20(fp)
 823cc3c:	10002126 	beq	r2,zero,823ccc4 <alt_write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 823cc40:	e0bffb17 	ldw	r2,-20(fp)
 823cc44:	10800217 	ldw	r2,8(r2)
 823cc48:	108000cc 	andi	r2,r2,3
 823cc4c:	10001826 	beq	r2,zero,823ccb0 <alt_write+0xbc>
 823cc50:	e0bffb17 	ldw	r2,-20(fp)
 823cc54:	10800017 	ldw	r2,0(r2)
 823cc58:	10800617 	ldw	r2,24(r2)
 823cc5c:	10001426 	beq	r2,zero,823ccb0 <alt_write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 823cc60:	e0bffb17 	ldw	r2,-20(fp)
 823cc64:	10800017 	ldw	r2,0(r2)
 823cc68:	10800617 	ldw	r2,24(r2)
 823cc6c:	e0ffff17 	ldw	r3,-4(fp)
 823cc70:	180d883a 	mov	r6,r3
 823cc74:	e17ffe17 	ldw	r5,-8(fp)
 823cc78:	e13ffb17 	ldw	r4,-20(fp)
 823cc7c:	103ee83a 	callr	r2
 823cc80:	e0bffc15 	stw	r2,-16(fp)
 823cc84:	e0bffc17 	ldw	r2,-16(fp)
 823cc88:	1000070e 	bge	r2,zero,823cca8 <alt_write+0xb4>
      {
        ALT_ERRNO = -rval;
 823cc8c:	823cbb80 	call	823cbb8 <alt_get_errno>
 823cc90:	1007883a 	mov	r3,r2
 823cc94:	e0bffc17 	ldw	r2,-16(fp)
 823cc98:	0085c83a 	sub	r2,zero,r2
 823cc9c:	18800015 	stw	r2,0(r3)
        return -1;
 823cca0:	00bfffc4 	movi	r2,-1
 823cca4:	00000c06 	br	823ccd8 <alt_write+0xe4>
      }
      return rval;
 823cca8:	e0bffc17 	ldw	r2,-16(fp)
 823ccac:	00000a06 	br	823ccd8 <alt_write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
 823ccb0:	823cbb80 	call	823cbb8 <alt_get_errno>
 823ccb4:	1007883a 	mov	r3,r2
 823ccb8:	00800344 	movi	r2,13
 823ccbc:	18800015 	stw	r2,0(r3)
 823ccc0:	00000406 	br	823ccd4 <alt_write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 823ccc4:	823cbb80 	call	823cbb8 <alt_get_errno>
 823ccc8:	1007883a 	mov	r3,r2
 823cccc:	00801444 	movi	r2,81
 823ccd0:	18800015 	stw	r2,0(r3)
  }
  return -1;
 823ccd4:	00bfffc4 	movi	r2,-1
}
 823ccd8:	e037883a 	mov	sp,fp
 823ccdc:	dfc00117 	ldw	ra,4(sp)
 823cce0:	df000017 	ldw	fp,0(sp)
 823cce4:	dec00204 	addi	sp,sp,8
 823cce8:	f800283a 	ret

0823ccec <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
 823ccec:	deffff04 	addi	sp,sp,-4
 823ccf0:	df000015 	stw	fp,0(sp)
 823ccf4:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 823ccf8:	000170fa 	wrctl	ienable,zero
}
 823ccfc:	0001883a 	nop
 823cd00:	e037883a 	mov	sp,fp
 823cd04:	df000017 	ldw	fp,0(sp)
 823cd08:	dec00104 	addi	sp,sp,4
 823cd0c:	f800283a 	ret

0823cd10 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
 823cd10:	defff504 	addi	sp,sp,-44
      bltu  sp, et, .Lstack_overflow

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
 823cd14:	d0e00217 	ldw	r3,-32760(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
 823cd18:	d1207a17 	ldw	r4,-32280(gp)

      stw ra,  0(sp)
 823cd1c:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
 823cd20:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
 823cd24:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
 823cd28:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
 823cd2c:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
 823cd30:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
 823cd34:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
 823cd38:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
 823cd3c:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
 823cd40:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
 823cd44:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
 823cd48:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 823cd4c:	823cf840 	call	823cf84 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
 823cd50:	d1207517 	ldw	r4,-32300(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
 823cd54:	d1606d07 	ldb	r5,-32332(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
 823cd58:	d1207a15 	stw	r4,-32280(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
 823cd5c:	d1606d45 	stb	r5,-32331(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
 823cd60:	26c00017 	ldw	sp,0(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
 823cd64:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
 823cd68:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
 823cd6c:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
 823cd70:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
 823cd74:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
 823cd78:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
 823cd7c:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
 823cd80:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
 823cd84:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
 823cd88:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
 823cd8c:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
 823cd90:	d0e00215 	stw	r3,-32760(gp)

      stw et, %gprel(alt_stack_limit_value)(gp)

#endif

      addi sp, sp, 44
 823cd94:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
 823cd98:	f800283a 	ret

0823cd9c <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
 823cd9c:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
 823cda0:	047fff84 	movi	r17,-2
      and   r18, r18, r17
 823cda4:	9464703a 	and	r18,r18,r17
      wrctl status, r18
 823cda8:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 823cdac:	823cf840 	call	823cf84 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
 823cdb0:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
 823cdb4:	d4a06b45 	stb	r18,-32339(gp)

      /*
       * start execution of the new task.
       */

      br 9b
 823cdb8:	003fe506 	br	823cd50 <OSCtxSw+0x40>

0823cdbc <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
 823cdbc:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
 823cdc0:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
 823cdc4:	10800054 	ori	r2,r2,1
      wrctl status, r2
 823cdc8:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
 823cdcc:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
 823cdd0:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
 823cdd4:	dec00204 	addi	sp,sp,8

      callr r2
 823cdd8:	103ee83a 	callr	r2

      nop
 823cddc:	0001883a 	nop

0823cde0 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
 823cde0:	defff704 	addi	sp,sp,-36
 823cde4:	dfc00815 	stw	ra,32(sp)
 823cde8:	df000715 	stw	fp,28(sp)
 823cdec:	df000704 	addi	fp,sp,28
 823cdf0:	e13ffc15 	stw	r4,-16(fp)
 823cdf4:	e17ffd15 	stw	r5,-12(fp)
 823cdf8:	e1bffe15 	stw	r6,-8(fp)
 823cdfc:	3805883a 	mov	r2,r7
 823ce00:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
 823ce04:	e0fffe17 	ldw	r3,-8(fp)
 823ce08:	00bfff04 	movi	r2,-4
 823ce0c:	1884703a 	and	r2,r3,r2
 823ce10:	10bef704 	addi	r2,r2,-1060
 823ce14:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
 823ce18:	01810904 	movi	r6,1060
 823ce1c:	000b883a 	mov	r5,zero
 823ce20:	e13ff917 	ldw	r4,-28(fp)
 823ce24:	82032100 	call	8203210 <memset>
 823ce28:	e0bff917 	ldw	r2,-28(fp)
 823ce2c:	10c0bb04 	addi	r3,r2,748
 823ce30:	e0bff917 	ldw	r2,-28(fp)
 823ce34:	10c00115 	stw	r3,4(r2)
 823ce38:	e0bff917 	ldw	r2,-28(fp)
 823ce3c:	10c0d504 	addi	r3,r2,852
 823ce40:	e0bff917 	ldw	r2,-28(fp)
 823ce44:	10c00215 	stw	r3,8(r2)
 823ce48:	e0bff917 	ldw	r2,-28(fp)
 823ce4c:	10c0ef04 	addi	r3,r2,956
 823ce50:	e0bff917 	ldw	r2,-28(fp)
 823ce54:	10c00315 	stw	r3,12(r2)
 823ce58:	e0fff917 	ldw	r3,-28(fp)
 823ce5c:	00820974 	movhi	r2,2085
 823ce60:	1083eb04 	addi	r2,r2,4012
 823ce64:	18800d15 	stw	r2,52(r3)
 823ce68:	e0bff917 	ldw	r2,-28(fp)
 823ce6c:	00c00044 	movi	r3,1
 823ce70:	10c02915 	stw	r3,164(r2)
 823ce74:	10002a15 	stw	zero,168(r2)
 823ce78:	e0bff917 	ldw	r2,-28(fp)
 823ce7c:	00ccc384 	movi	r3,13070
 823ce80:	10c02b0d 	sth	r3,172(r2)
 823ce84:	e0bff917 	ldw	r2,-28(fp)
 823ce88:	00eaf344 	movi	r3,-21555
 823ce8c:	10c02b8d 	sth	r3,174(r2)
 823ce90:	e0bff917 	ldw	r2,-28(fp)
 823ce94:	00c48d04 	movi	r3,4660
 823ce98:	10c02c0d 	sth	r3,176(r2)
 823ce9c:	e0bff917 	ldw	r2,-28(fp)
 823cea0:	00f99b44 	movi	r3,-6547
 823cea4:	10c02c8d 	sth	r3,178(r2)
 823cea8:	e0bff917 	ldw	r2,-28(fp)
 823ceac:	00f7bb04 	movi	r3,-8468
 823ceb0:	10c02d0d 	sth	r3,180(r2)
 823ceb4:	e0bff917 	ldw	r2,-28(fp)
 823ceb8:	00c00144 	movi	r3,5
 823cebc:	10c02d8d 	sth	r3,182(r2)
 823cec0:	e0bff917 	ldw	r2,-28(fp)
 823cec4:	00c002c4 	movi	r3,11
 823cec8:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
 823cecc:	e0bff917 	ldw	r2,-28(fp)
 823ced0:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
 823ced4:	e0bffa17 	ldw	r2,-24(fp)
 823ced8:	10bff304 	addi	r2,r2,-52
 823cedc:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
 823cee0:	e0bffb17 	ldw	r2,-20(fp)
 823cee4:	10800c04 	addi	r2,r2,48
 823cee8:	e0fffc17 	ldw	r3,-16(fp)
 823ceec:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
 823cef0:	e0bffb17 	ldw	r2,-20(fp)
 823cef4:	10800b04 	addi	r2,r2,44
 823cef8:	e0fffd17 	ldw	r3,-12(fp)
 823cefc:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
 823cf00:	e0bffb17 	ldw	r2,-20(fp)
 823cf04:	10800a04 	addi	r2,r2,40
 823cf08:	e0fff917 	ldw	r3,-28(fp)
 823cf0c:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
 823cf10:	00820934 	movhi	r2,2084
 823cf14:	10b36f04 	addi	r2,r2,-12868
 823cf18:	10c00104 	addi	r3,r2,4
 823cf1c:	e0bffb17 	ldw	r2,-20(fp)
 823cf20:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
 823cf24:	e0bffb17 	ldw	r2,-20(fp)
}
 823cf28:	e037883a 	mov	sp,fp
 823cf2c:	dfc00117 	ldw	ra,4(sp)
 823cf30:	df000017 	ldw	fp,0(sp)
 823cf34:	dec00204 	addi	sp,sp,8
 823cf38:	f800283a 	ret

0823cf3c <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
 823cf3c:	defffe04 	addi	sp,sp,-8
 823cf40:	df000115 	stw	fp,4(sp)
 823cf44:	df000104 	addi	fp,sp,4
 823cf48:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
 823cf4c:	0001883a 	nop
 823cf50:	e037883a 	mov	sp,fp
 823cf54:	df000017 	ldw	fp,0(sp)
 823cf58:	dec00104 	addi	sp,sp,4
 823cf5c:	f800283a 	ret

0823cf60 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
 823cf60:	defffe04 	addi	sp,sp,-8
 823cf64:	df000115 	stw	fp,4(sp)
 823cf68:	df000104 	addi	fp,sp,4
 823cf6c:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
 823cf70:	0001883a 	nop
 823cf74:	e037883a 	mov	sp,fp
 823cf78:	df000017 	ldw	fp,0(sp)
 823cf7c:	dec00104 	addi	sp,sp,4
 823cf80:	f800283a 	ret

0823cf84 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
 823cf84:	deffff04 	addi	sp,sp,-4
 823cf88:	df000015 	stw	fp,0(sp)
 823cf8c:	d839883a 	mov	fp,sp
}
 823cf90:	0001883a 	nop
 823cf94:	e037883a 	mov	sp,fp
 823cf98:	df000017 	ldw	fp,0(sp)
 823cf9c:	dec00104 	addi	sp,sp,4
 823cfa0:	f800283a 	ret

0823cfa4 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
 823cfa4:	deffff04 	addi	sp,sp,-4
 823cfa8:	df000015 	stw	fp,0(sp)
 823cfac:	d839883a 	mov	fp,sp
}
 823cfb0:	0001883a 	nop
 823cfb4:	e037883a 	mov	sp,fp
 823cfb8:	df000017 	ldw	fp,0(sp)
 823cfbc:	dec00104 	addi	sp,sp,4
 823cfc0:	f800283a 	ret

0823cfc4 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
 823cfc4:	defffe04 	addi	sp,sp,-8
 823cfc8:	dfc00115 	stw	ra,4(sp)
 823cfcc:	df000015 	stw	fp,0(sp)
 823cfd0:	d839883a 	mov	fp,sp
    }
#endif  
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
 823cfd4:	822d76c0 	call	822d76c <cticks_hook>
#endif
}
 823cfd8:	0001883a 	nop
 823cfdc:	e037883a 	mov	sp,fp
 823cfe0:	dfc00117 	ldw	ra,4(sp)
 823cfe4:	df000017 	ldw	fp,0(sp)
 823cfe8:	dec00204 	addi	sp,sp,8
 823cfec:	f800283a 	ret

0823cff0 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
 823cff0:	deffff04 	addi	sp,sp,-4
 823cff4:	df000015 	stw	fp,0(sp)
 823cff8:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
#endif
}
 823cffc:	0001883a 	nop
 823d000:	e037883a 	mov	sp,fp
 823d004:	df000017 	ldw	fp,0(sp)
 823d008:	dec00104 	addi	sp,sp,4
 823d00c:	f800283a 	ret

0823d010 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
 823d010:	deffff04 	addi	sp,sp,-4
 823d014:	df000015 	stw	fp,0(sp)
 823d018:	d839883a 	mov	fp,sp
}
 823d01c:	0001883a 	nop
 823d020:	e037883a 	mov	sp,fp
 823d024:	df000017 	ldw	fp,0(sp)
 823d028:	dec00104 	addi	sp,sp,4
 823d02c:	f800283a 	ret

0823d030 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
 823d030:	deffff04 	addi	sp,sp,-4
 823d034:	df000015 	stw	fp,0(sp)
 823d038:	d839883a 	mov	fp,sp
}
 823d03c:	0001883a 	nop
 823d040:	e037883a 	mov	sp,fp
 823d044:	df000017 	ldw	fp,0(sp)
 823d048:	dec00104 	addi	sp,sp,4
 823d04c:	f800283a 	ret

0823d050 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
 823d050:	defffe04 	addi	sp,sp,-8
 823d054:	df000115 	stw	fp,4(sp)
 823d058:	df000104 	addi	fp,sp,4
 823d05c:	e13fff15 	stw	r4,-4(fp)
}
 823d060:	0001883a 	nop
 823d064:	e037883a 	mov	sp,fp
 823d068:	df000017 	ldw	fp,0(sp)
 823d06c:	dec00104 	addi	sp,sp,4
 823d070:	f800283a 	ret

0823d074 <netmain_init>:
 * RETURNS: 
 */

void 
netmain_init(void)
{
 823d074:	defffb04 	addi	sp,sp,-20
 823d078:	dfc00415 	stw	ra,16(sp)
 823d07c:	df000315 	stw	fp,12(sp)
 823d080:	dc000215 	stw	r16,8(sp)
 823d084:	df000304 	addi	fp,sp,12
   int   e = 0;
 823d088:	e03ffd15 	stw	zero,-12(fp)
   char *   msg;
#ifdef IP_V6
   ip6_addr host;
#endif

   printf("%s\n", name);
 823d08c:	d0a04b17 	ldw	r2,-32468(gp)
 823d090:	1009883a 	mov	r4,r2
 823d094:	82036800 	call	8203680 <puts>
   printf("Copyright 1996-2008 by InterNiche Technologies. All rights reserved. \n");
 823d098:	01020974 	movhi	r4,2085
 823d09c:	2103f704 	addi	r4,r4,4060
 823d0a0:	82036800 	call	8203680 <puts>
#ifdef IN_MENUS
   install_version("allports3.1");
#endif
#ifndef SUPERLOOP
   /* call this to do pre-task setup including intialization of port_prep */
   msg = pre_task_setup();
 823d0a4:	822df380 	call	822df38 <pre_task_setup>
 823d0a8:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 823d0ac:	e0bffe17 	ldw	r2,-8(fp)
 823d0b0:	10000226 	beq	r2,zero,823d0bc <netmain_init+0x48>
      panic(msg);
 823d0b4:	e13ffe17 	ldw	r4,-8(fp)
 823d0b8:	8228ca40 	call	8228ca4 <panic>
      printf("global_log_create() failed\n");
   }
   glog_with_type(LOG_TYPE_INFO, "INICHE LOG initialized", 1);
#endif

   msg = ip_startup();
 823d0bc:	82268e00 	call	82268e0 <ip_startup>
 823d0c0:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 823d0c4:	e0bffe17 	ldw	r2,-8(fp)
 823d0c8:	10000726 	beq	r2,zero,823d0e8 <netmain_init+0x74>
   {
      printf("inet startup error: %s\n", msg);
 823d0cc:	e17ffe17 	ldw	r5,-8(fp)
 823d0d0:	01020974 	movhi	r4,2085
 823d0d4:	21040904 	addi	r4,r4,4132
 823d0d8:	82033fc0 	call	82033fc <printf>
      panic("IP");
 823d0dc:	01020974 	movhi	r4,2085
 823d0e0:	21040f04 	addi	r4,r4,4156
 823d0e4:	8228ca40 	call	8228ca4 <panic>
   }

#if defined(MEMDEV_SIZE) && defined(VFS_FILES)
   init_memdev(); /* init the mem and null test devices */
 823d0e8:	82471c00 	call	82471c0 <init_memdev>
#endif

#ifdef IP_MULTICAST
#ifdef INCLUDE_TCP
   /* call the IP multicast test program */
   u_mctest_init();
 823d0ec:	82467600 	call	8246760 <u_mctest_init>

   /* clear debugging flags. Port can optionally turn them
    * back on in post_task_setup();
    * NDEBUG = UPCTRACE | IPTRACE | TPTRACE ;  
    */
   NDEBUG = 0;    
 823d0f0:	d0208315 	stw	zero,-32244(gp)

   /* print IP address of the first interface - for user's benefit */
   printf("IP address of %s : %s\n" , ((NET)(netlist.q_head))->name,
 823d0f4:	008209b4 	movhi	r2,2086
 823d0f8:	10ba7e04 	addi	r2,r2,-5640
 823d0fc:	10800017 	ldw	r2,0(r2)
 823d100:	14000104 	addi	r16,r2,4
      print_ipad(((NET)(netlist.q_head))->n_ipaddr));
 823d104:	008209b4 	movhi	r2,2086
 823d108:	10ba7e04 	addi	r2,r2,-5640
 823d10c:	10800017 	ldw	r2,0(r2)
    * NDEBUG = UPCTRACE | IPTRACE | TPTRACE ;  
    */
   NDEBUG = 0;    

   /* print IP address of the first interface - for user's benefit */
   printf("IP address of %s : %s\n" , ((NET)(netlist.q_head))->name,
 823d110:	10800a17 	ldw	r2,40(r2)
 823d114:	1009883a 	mov	r4,r2
 823d118:	8228a500 	call	8228a50 <print_ipad>
 823d11c:	100d883a 	mov	r6,r2
 823d120:	800b883a 	mov	r5,r16
 823d124:	01020974 	movhi	r4,2085
 823d128:	21041004 	addi	r4,r4,4160
 823d12c:	82033fc0 	call	82033fc <printf>
      print_ipad(((NET)(netlist.q_head))->n_ipaddr));
 
#ifndef SUPERLOOP
   /* call this per-target routine after basic tasks & net are up */
   msg = post_task_setup();
 823d130:	822df840 	call	822df84 <post_task_setup>
 823d134:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 823d138:	e0bffe17 	ldw	r2,-8(fp)
 823d13c:	10000226 	beq	r2,zero,823d148 <netmain_init+0xd4>
      panic(msg);
 823d140:	e13ffe17 	ldw	r4,-8(fp)
 823d144:	8228ca40 	call	8228ca4 <panic>
#ifdef USE_AUTOIP
   Upnp_init();      /* start Auto IP before DHCP client */
#endif   /* USE_AUTOIP */

#ifdef DHCP_CLIENT
   dhc_setup();   /* kick off any DHCP clients */
 823d148:	8246e480 	call	8246e48 <dhc_setup>
      panic("prep_modules");
   }
#endif
   USE_ARG(e);    /* Avoid compiler warnings */

} /* end of netmain_init() */
 823d14c:	0001883a 	nop
 823d150:	e6ffff04 	addi	sp,fp,-4
 823d154:	dfc00217 	ldw	ra,8(sp)
 823d158:	df000117 	ldw	fp,4(sp)
 823d15c:	dc000017 	ldw	r16,0(sp)
 823d160:	dec00304 	addi	sp,sp,12
 823d164:	f800283a 	ret

0823d168 <icmp_port_du>:
 * RETURNS: 
 */

void
icmp_port_du(PACKET p, struct destun * pdp)
{
 823d168:	defffb04 	addi	sp,sp,-20
 823d16c:	dfc00415 	stw	ra,16(sp)
 823d170:	df000315 	stw	fp,12(sp)
 823d174:	dc000215 	stw	r16,8(sp)
 823d178:	df000304 	addi	fp,sp,12
 823d17c:	e13ffd15 	stw	r4,-12(fp)
 823d180:	e17ffe15 	stw	r5,-8(fp)
   dprintf("got ICMP %s UNREACHABLE from %s\n", 
      icmpdu_types[(int)(pdp->dtype)], print_ipad(p->fhost) );
 823d184:	e0bffe17 	ldw	r2,-8(fp)
 823d188:	10800003 	ldbu	r2,0(r2)
 823d18c:	10c03fcc 	andi	r3,r2,255
 823d190:	18c0201c 	xori	r3,r3,128
 823d194:	18ffe004 	addi	r3,r3,-128
 */

void
icmp_port_du(PACKET p, struct destun * pdp)
{
   dprintf("got ICMP %s UNREACHABLE from %s\n", 
 823d198:	00820974 	movhi	r2,2085
 823d19c:	108f5504 	addi	r2,r2,15700
 823d1a0:	18c7883a 	add	r3,r3,r3
 823d1a4:	18c7883a 	add	r3,r3,r3
 823d1a8:	10c5883a 	add	r2,r2,r3
 823d1ac:	14000017 	ldw	r16,0(r2)
 823d1b0:	e0bffd17 	ldw	r2,-12(fp)
 823d1b4:	10800717 	ldw	r2,28(r2)
 823d1b8:	1009883a 	mov	r4,r2
 823d1bc:	8228a500 	call	8228a50 <print_ipad>
 823d1c0:	100d883a 	mov	r6,r2
 823d1c4:	800b883a 	mov	r5,r16
 823d1c8:	01020974 	movhi	r4,2085
 823d1cc:	21042004 	addi	r4,r4,4224
 823d1d0:	82033fc0 	call	82033fc <printf>
      icmpdu_types[(int)(pdp->dtype)], print_ipad(p->fhost) );
   dprintf(prompt);
 823d1d4:	d0a04c17 	ldw	r2,-32464(gp)
 823d1d8:	1009883a 	mov	r4,r2
 823d1dc:	82033fc0 	call	82033fc <printf>
}
 823d1e0:	0001883a 	nop
 823d1e4:	e6ffff04 	addi	sp,fp,-4
 823d1e8:	dfc00217 	ldw	ra,8(sp)
 823d1ec:	df000117 	ldw	fp,4(sp)
 823d1f0:	dc000017 	ldw	r16,0(sp)
 823d1f4:	dec00304 	addi	sp,sp,12
 823d1f8:	f800283a 	ret

0823d1fc <station_state>:
 * RETURNS: 
 */

int
station_state(void * pio)
{
 823d1fc:	defff904 	addi	sp,sp,-28
 823d200:	dfc00615 	stw	ra,24(sp)
 823d204:	df000515 	stw	fp,20(sp)
 823d208:	dc000415 	stw	r16,16(sp)
 823d20c:	df000504 	addi	fp,sp,20
 823d210:	e13ffe15 	stw	r4,-8(fp)
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 823d214:	e03ffc15 	stw	zero,-16(fp)
 823d218:	008209b4 	movhi	r2,2086
 823d21c:	10ba7e04 	addi	r2,r2,-5640
 823d220:	10800017 	ldw	r2,0(r2)
 823d224:	e0bffd15 	stw	r2,-12(fp)
 823d228:	00002506 	br	823d2c0 <station_state+0xc4>
   {
      ns_printf(pio, "iface %d-%s IP addr:%s  ", 
       i, ifp->name, print_ipad(ifp->n_ipaddr) );
 823d22c:	e0bffd17 	ldw	r2,-12(fp)
 823d230:	14000104 	addi	r16,r2,4
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
   {
      ns_printf(pio, "iface %d-%s IP addr:%s  ", 
 823d234:	e0bffd17 	ldw	r2,-12(fp)
 823d238:	10800a17 	ldw	r2,40(r2)
 823d23c:	1009883a 	mov	r4,r2
 823d240:	8228a500 	call	8228a50 <print_ipad>
 823d244:	d8800015 	stw	r2,0(sp)
 823d248:	800f883a 	mov	r7,r16
 823d24c:	e1bffc17 	ldw	r6,-16(fp)
 823d250:	01420974 	movhi	r5,2085
 823d254:	29442904 	addi	r5,r5,4260
 823d258:	e13ffe17 	ldw	r4,-8(fp)
 823d25c:	8228ebc0 	call	8228ebc <ns_printf>
       i, ifp->name, print_ipad(ifp->n_ipaddr) );
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
 823d260:	e0bffd17 	ldw	r2,-12(fp)
 823d264:	10800c17 	ldw	r2,48(r2)
 823d268:	1009883a 	mov	r4,r2
 823d26c:	8228a500 	call	8228a50 <print_ipad>
 823d270:	100d883a 	mov	r6,r2
 823d274:	01420974 	movhi	r5,2085
 823d278:	29443004 	addi	r5,r5,4288
 823d27c:	e13ffe17 	ldw	r4,-8(fp)
 823d280:	8228ebc0 	call	8228ebc <ns_printf>
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
 823d284:	e0bffd17 	ldw	r2,-12(fp)
 823d288:	10800d17 	ldw	r2,52(r2)
 823d28c:	1009883a 	mov	r4,r2
 823d290:	8228a500 	call	8228a50 <print_ipad>
 823d294:	100d883a 	mov	r6,r2
 823d298:	01420974 	movhi	r5,2085
 823d29c:	29443304 	addi	r5,r5,4300
 823d2a0:	e13ffe17 	ldw	r4,-8(fp)
 823d2a4:	8228ebc0 	call	8228ebc <ns_printf>
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 823d2a8:	e0bffd17 	ldw	r2,-12(fp)
 823d2ac:	10800017 	ldw	r2,0(r2)
 823d2b0:	e0bffd15 	stw	r2,-12(fp)
 823d2b4:	e0bffc17 	ldw	r2,-16(fp)
 823d2b8:	10800044 	addi	r2,r2,1
 823d2bc:	e0bffc15 	stw	r2,-16(fp)
 823d2c0:	e0bffd17 	ldw	r2,-12(fp)
 823d2c4:	103fd91e 	bne	r2,zero,823d22c <station_state+0x30>
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
   }
#endif   /* NO_INET_STACK */

   ns_printf(pio, "current tick count %lu\n", cticks);
 823d2c8:	d0a0a817 	ldw	r2,-32096(gp)
 823d2cc:	100d883a 	mov	r6,r2
 823d2d0:	01420974 	movhi	r5,2085
 823d2d4:	29443604 	addi	r5,r5,4312
 823d2d8:	e13ffe17 	ldw	r4,-8(fp)
 823d2dc:	8228ebc0 	call	8228ebc <ns_printf>

   ns_printf(pio, "common delay parameter:  %lu ticks (%lu ms).\n", pingdelay, (pingdelay * TIMEFOR1TICK));
 823d2e0:	d0e04d17 	ldw	r3,-32460(gp)
 823d2e4:	d0a04d17 	ldw	r2,-32460(gp)
 823d2e8:	108002a4 	muli	r2,r2,10
 823d2ec:	100f883a 	mov	r7,r2
 823d2f0:	180d883a 	mov	r6,r3
 823d2f4:	01420974 	movhi	r5,2085
 823d2f8:	29443c04 	addi	r5,r5,4336
 823d2fc:	e13ffe17 	ldw	r4,-8(fp)
 823d300:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf(pio, "common host parameter: %s\n", print_ipad(activehost));
 823d304:	d0a0ba17 	ldw	r2,-32024(gp)
 823d308:	1009883a 	mov	r4,r2
 823d30c:	8228a500 	call	8228a50 <print_ipad>
 823d310:	100d883a 	mov	r6,r2
 823d314:	01420974 	movhi	r5,2085
 823d318:	29444804 	addi	r5,r5,4384
 823d31c:	e13ffe17 	ldw	r4,-8(fp)
 823d320:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf(pio, "common length parameter: %d\n", deflength);
 823d324:	d0a04e17 	ldw	r2,-32456(gp)
 823d328:	100d883a 	mov	r6,r2
 823d32c:	01420974 	movhi	r5,2085
 823d330:	29444f04 	addi	r5,r5,4412
 823d334:	e13ffe17 	ldw	r4,-8(fp)
 823d338:	8228ebc0 	call	8228ebc <ns_printf>
#ifdef USE_PPP
   ns_printf(pio, "current dial-in user name is %s\n", pppcfg.username);
   ns_printf(pio, "current dial-in password is %s\n", pppcfg.password);
#endif   /* USE_PPP */

   task_stats(pio);
 823d33c:	e13ffe17 	ldw	r4,-8(fp)
 823d340:	823d8a00 	call	823d8a0 <task_stats>

   return 0;
 823d344:	0005883a 	mov	r2,zero
}
 823d348:	e6ffff04 	addi	sp,fp,-4
 823d34c:	dfc00217 	ldw	ra,8(sp)
 823d350:	df000117 	ldw	fp,4(sp)
 823d354:	dc000017 	ldw	r16,0(sp)
 823d358:	dec00304 	addi	sp,sp,12
 823d35c:	f800283a 	ret

0823d360 <sysuptime>:
 * RETURNS: 
 */

unsigned long
sysuptime()
{
 823d360:	deffff04 	addi	sp,sp,-4
 823d364:	df000015 	stw	fp,0(sp)
 823d368:	d839883a 	mov	fp,sp
   return ((cticks/TPS)*100);    /* 100ths of a sec since boot time */
 823d36c:	d160a817 	ldw	r5,-32096(gp)
 823d370:	00947b34 	movhi	r2,20972
 823d374:	10a147c4 	addi	r2,r2,-31457
 823d378:	288c383a 	mulxuu	r6,r5,r2
 823d37c:	2885383a 	mul	r2,r5,r2
 823d380:	1007883a 	mov	r3,r2
 823d384:	3009883a 	mov	r4,r6
 823d388:	2004d17a 	srli	r2,r4,5
 823d38c:	10801924 	muli	r2,r2,100
}
 823d390:	e037883a 	mov	sp,fp
 823d394:	df000017 	ldw	fp,0(sp)
 823d398:	dec00104 	addi	sp,sp,4
 823d39c:	f800283a 	ret

0823d3a0 <packet_check>:

static int inside_pktdemux = 0; 

void
packet_check(void)
{
 823d3a0:	defffe04 	addi	sp,sp,-8
 823d3a4:	dfc00115 	stw	ra,4(sp)
 823d3a8:	df000015 	stw	fp,0(sp)
 823d3ac:	d839883a 	mov	fp,sp
   if(inside_pktdemux != 0)   /* check re-entrancy flag */
 823d3b0:	d0a0bb17 	ldw	r2,-32020(gp)
 823d3b4:	1000081e 	bne	r2,zero,823d3d8 <packet_check+0x38>
      return;           /* do not re-enter pktdemux(), packet will wait... */
   inside_pktdemux++;   /* set re-entrany flag */
 823d3b8:	d0a0bb17 	ldw	r2,-32020(gp)
 823d3bc:	10800044 	addi	r2,r2,1
 823d3c0:	d0a0bb15 	stw	r2,-32020(gp)
   pktdemux();          /* process low level packet input */
 823d3c4:	82263200 	call	8226320 <pktdemux>
   inside_pktdemux--;   /* clear re-entrany flag */
 823d3c8:	d0a0bb17 	ldw	r2,-32020(gp)
 823d3cc:	10bfffc4 	addi	r2,r2,-1
 823d3d0:	d0a0bb15 	stw	r2,-32020(gp)
 823d3d4:	00000106 	br	823d3dc <packet_check+0x3c>

void
packet_check(void)
{
   if(inside_pktdemux != 0)   /* check re-entrancy flag */
      return;           /* do not re-enter pktdemux(), packet will wait... */
 823d3d8:	0001883a 	nop
   inside_pktdemux++;   /* set re-entrany flag */
   pktdemux();          /* process low level packet input */
   inside_pktdemux--;   /* clear re-entrany flag */
}
 823d3dc:	e037883a 	mov	sp,fp
 823d3e0:	dfc00117 	ldw	ra,4(sp)
 823d3e4:	df000017 	ldw	fp,0(sp)
 823d3e8:	dec00204 	addi	sp,sp,8
 823d3ec:	f800283a 	ret

0823d3f0 <mcastlist>:
 * RETURNS: 
 */

int
mcastlist(struct in_multi * multi_ptr)
{
 823d3f0:	defffe04 	addi	sp,sp,-8
 823d3f4:	df000115 	stw	fp,4(sp)
 823d3f8:	df000104 	addi	fp,sp,4
 823d3fc:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(multi_ptr);

   return 0;
 823d400:	0005883a 	mov	r2,zero
}
 823d404:	e037883a 	mov	sp,fp
 823d408:	df000017 	ldw	fp,0(sp)
 823d40c:	dec00104 	addi	sp,sp,4
 823d410:	f800283a 	ret

0823d414 <prep_modules>:
#ifdef USE_MODEM
extern   int   prep_modem(void);
#endif   /* USE_MODEM */

int prep_modules(void)
{
 823d414:	defffd04 	addi	sp,sp,-12
 823d418:	dfc00215 	stw	ra,8(sp)
 823d41c:	df000115 	stw	fp,4(sp)
 823d420:	df000104 	addi	fp,sp,4
#ifdef IP_V6
   ip6_addr host;
   int i;
#endif

int e = 0;
 823d424:	e03fff15 	stw	zero,-4(fp)
      panic("prep_modules");
   }
#endif   /* SMTP_ALERTS */

#ifdef VFS_FILES
   e = prep_vfs();
 823d428:	824a0000 	call	824a000 <prep_vfs>
 823d42c:	e0bfff15 	stw	r2,-4(fp)
   if (e != 0)
 823d430:	e0bfff17 	ldw	r2,-4(fp)
 823d434:	10000626 	beq	r2,zero,823d450 <prep_modules+0x3c>
   {
      dprintf("VFS Module prep failed\n");
 823d438:	01020974 	movhi	r4,2085
 823d43c:	21045704 	addi	r4,r4,4444
 823d440:	82036800 	call	8203680 <puts>
      panic("prep_modules");
 823d444:	01020974 	movhi	r4,2085
 823d448:	21045d04 	addi	r4,r4,4468
 823d44c:	8228ca40 	call	8228ca4 <panic>
   {
      dprintf("sslapp_init() failed\n");
      panic("prep_modules");
   }
#endif
   return 0;
 823d450:	0005883a 	mov	r2,zero
}
 823d454:	e037883a 	mov	sp,fp
 823d458:	dfc00117 	ldw	ra,4(sp)
 823d45c:	df000017 	ldw	fp,0(sp)
 823d460:	dec00204 	addi	sp,sp,8
 823d464:	f800283a 	ret

0823d468 <inet_timer>:
 * RETURNS: 
 */

void
inet_timer(void)
{
 823d468:	defffe04 	addi	sp,sp,-8
 823d46c:	dfc00115 	stw	ra,4(sp)
 823d470:	df000015 	stw	fp,0(sp)
 823d474:	d839883a 	mov	fp,sp
#ifdef IP_FRAGMENTS
   /* run thru' the IP reassembly queue (once every second) */
   if (ire_cticks < cticks)
 823d478:	d0e0c917 	ldw	r3,-31964(gp)
 823d47c:	d0a0a817 	ldw	r2,-32096(gp)
 823d480:	1880012e 	bgeu	r3,r2,823d488 <inet_timer+0x20>
      ip_reasm_process_timer_tick ();
 823d484:	82425280 	call	8242528 <ip_reasm_process_timer_tick>
#endif

#ifdef INCLUDE_TCP
   tcp_tick();          /* run TCP timers */
 823d488:	822fa540 	call	822fa54 <tcp_tick>
#endif

#ifdef INICHE_TIMERS    /* interval timers? */
   check_interval_timers();
 823d48c:	823d4f40 	call	823d4f4 <check_interval_timers>
#endif

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Call igmp timeout routine */
   if (igmp_cticks < cticks)  /* Call igmp timeout routine 5 times per sec */
 823d490:	d0e08717 	ldw	r3,-32228(gp)
 823d494:	d0a0a817 	ldw	r2,-32096(gp)
 823d498:	1880012e 	bgeu	r3,r2,823d4a0 <inet_timer+0x38>
      igmp_fasttimo();
 823d49c:	8226ecc0 	call	8226ecc <igmp_fasttimo>
#endif



   /* Some timer routines only need calling once a second: */
   if ((nextppp < cticks) ||  /* next call to PPP is due */
 823d4a0:	d0e0bc17 	ldw	r3,-32016(gp)
 823d4a4:	d0a0a817 	ldw	r2,-32096(gp)
 823d4a8:	18800436 	bltu	r3,r2,823d4bc <inet_timer+0x54>
       (nextppp > (cticks+(10*TPS))) )  /* for when cticks wraps */
 823d4ac:	d0a0a817 	ldw	r2,-32096(gp)
 823d4b0:	10c0fa04 	addi	r3,r2,1000
 823d4b4:	d0a0bc17 	ldw	r2,-32016(gp)
#endif



   /* Some timer routines only need calling once a second: */
   if ((nextppp < cticks) ||  /* next call to PPP is due */
 823d4b8:	1880082e 	bgeu	r3,r2,823d4dc <inet_timer+0x74>
       (nextppp > (cticks+(10*TPS))) )  /* for when cticks wraps */
   {
      nextppp = cticks + TPS;
 823d4bc:	d0a0a817 	ldw	r2,-32096(gp)
 823d4c0:	10801904 	addi	r2,r2,100
 823d4c4:	d0a0bc15 	stw	r2,-32016(gp)

      if (port_1s_callout != NULL)
 823d4c8:	d0a0bd17 	ldw	r2,-32012(gp)
 823d4cc:	10000226 	beq	r2,zero,823d4d8 <inet_timer+0x70>
         (*port_1s_callout)();
 823d4d0:	d0a0bd17 	ldw	r2,-32012(gp)
 823d4d4:	103ee83a 	callr	r2

#ifdef USE_PPP
      ppp_timeisup();
#endif
#ifdef DHCP_CLIENT
      dhc_second();
 823d4d8:	822bd6c0 	call	822bd6c <dhc_second>
#endif
#ifdef IPSEC
      IPSecTimer();
#endif
   }
}
 823d4dc:	0001883a 	nop
 823d4e0:	e037883a 	mov	sp,fp
 823d4e4:	dfc00117 	ldw	ra,4(sp)
 823d4e8:	df000017 	ldw	fp,0(sp)
 823d4ec:	dec00204 	addi	sp,sp,8
 823d4f0:	f800283a 	ret

0823d4f4 <check_interval_timers>:

static int numtimers = 0;     /* number of active timers */

static void
check_interval_timers(void)
{
 823d4f4:	defffc04 	addi	sp,sp,-16
 823d4f8:	dfc00315 	stw	ra,12(sp)
 823d4fc:	df000215 	stw	fp,8(sp)
 823d500:	df000204 	addi	fp,sp,8
   int   i;
   int   found = 0;  /* number of valid timers found */
 823d504:	e03fff15 	stw	zero,-4(fp)

   /* if no timers, just return */
   if (numtimers > 0)
 823d508:	d0a0be17 	ldw	r2,-32008(gp)
 823d50c:	0080560e 	bge	zero,r2,823d668 <check_interval_timers+0x174>
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 823d510:	e03ffe15 	stw	zero,-8(fp)
 823d514:	00004f06 	br	823d654 <check_interval_timers+0x160>
      {
         if (intimers[i].callback)   /* is this timer active? */
 823d518:	008209b4 	movhi	r2,2086
 823d51c:	10ba2504 	addi	r2,r2,-5996
 823d520:	e0fffe17 	ldw	r3,-8(fp)
 823d524:	18c00524 	muli	r3,r3,20
 823d528:	10c5883a 	add	r2,r2,r3
 823d52c:	10800017 	ldw	r2,0(r2)
 823d530:	10004526 	beq	r2,zero,823d648 <check_interval_timers+0x154>
	 {
            if ((intimers[i].tmo < cticks) && (!intimers[i].inuse))  /* timer ready fire? */
 823d534:	008209b4 	movhi	r2,2086
 823d538:	10ba2504 	addi	r2,r2,-5996
 823d53c:	e0fffe17 	ldw	r3,-8(fp)
 823d540:	18c00524 	muli	r3,r3,20
 823d544:	10c5883a 	add	r2,r2,r3
 823d548:	10800304 	addi	r2,r2,12
 823d54c:	10c00017 	ldw	r3,0(r2)
 823d550:	d0a0a817 	ldw	r2,-32096(gp)
 823d554:	1880362e 	bgeu	r3,r2,823d630 <check_interval_timers+0x13c>
 823d558:	008209b4 	movhi	r2,2086
 823d55c:	10ba2504 	addi	r2,r2,-5996
 823d560:	e0fffe17 	ldw	r3,-8(fp)
 823d564:	18c00524 	muli	r3,r3,20
 823d568:	10c5883a 	add	r2,r2,r3
 823d56c:	10800404 	addi	r2,r2,16
 823d570:	10800017 	ldw	r2,0(r2)
 823d574:	10002e1e 	bne	r2,zero,823d630 <check_interval_timers+0x13c>
            {
               intimers[i].tmo = intimers[i].interval + cticks;   /* set next tmo */
 823d578:	008209b4 	movhi	r2,2086
 823d57c:	10ba2504 	addi	r2,r2,-5996
 823d580:	e0fffe17 	ldw	r3,-8(fp)
 823d584:	18c00524 	muli	r3,r3,20
 823d588:	10c5883a 	add	r2,r2,r3
 823d58c:	10800204 	addi	r2,r2,8
 823d590:	10c00017 	ldw	r3,0(r2)
 823d594:	d0a0a817 	ldw	r2,-32096(gp)
 823d598:	1887883a 	add	r3,r3,r2
 823d59c:	008209b4 	movhi	r2,2086
 823d5a0:	10ba2504 	addi	r2,r2,-5996
 823d5a4:	e13ffe17 	ldw	r4,-8(fp)
 823d5a8:	21000524 	muli	r4,r4,20
 823d5ac:	1105883a 	add	r2,r2,r4
 823d5b0:	10800304 	addi	r2,r2,12
 823d5b4:	10c00015 	stw	r3,0(r2)
               intimers[i].inuse = TRUE;
 823d5b8:	008209b4 	movhi	r2,2086
 823d5bc:	10ba2504 	addi	r2,r2,-5996
 823d5c0:	e0fffe17 	ldw	r3,-8(fp)
 823d5c4:	18c00524 	muli	r3,r3,20
 823d5c8:	10c5883a 	add	r2,r2,r3
 823d5cc:	10800404 	addi	r2,r2,16
 823d5d0:	00c00044 	movi	r3,1
 823d5d4:	10c00015 	stw	r3,0(r2)
               intimers[i].callback(intimers[i].parm);      /* call user routine */
 823d5d8:	008209b4 	movhi	r2,2086
 823d5dc:	10ba2504 	addi	r2,r2,-5996
 823d5e0:	e0fffe17 	ldw	r3,-8(fp)
 823d5e4:	18c00524 	muli	r3,r3,20
 823d5e8:	10c5883a 	add	r2,r2,r3
 823d5ec:	10c00017 	ldw	r3,0(r2)
 823d5f0:	008209b4 	movhi	r2,2086
 823d5f4:	10ba2504 	addi	r2,r2,-5996
 823d5f8:	e13ffe17 	ldw	r4,-8(fp)
 823d5fc:	21000524 	muli	r4,r4,20
 823d600:	1105883a 	add	r2,r2,r4
 823d604:	10800104 	addi	r2,r2,4
 823d608:	10800017 	ldw	r2,0(r2)
 823d60c:	1009883a 	mov	r4,r2
 823d610:	183ee83a 	callr	r3
               intimers[i].inuse = FALSE;
 823d614:	008209b4 	movhi	r2,2086
 823d618:	10ba2504 	addi	r2,r2,-5996
 823d61c:	e0fffe17 	ldw	r3,-8(fp)
 823d620:	18c00524 	muli	r3,r3,20
 823d624:	10c5883a 	add	r2,r2,r3
 823d628:	10800404 	addi	r2,r2,16
 823d62c:	10000015 	stw	zero,0(r2)
            }
            /* If we've examined all the active timers, we're done */
            if (++found >= numtimers)
 823d630:	e0bfff17 	ldw	r2,-4(fp)
 823d634:	10800044 	addi	r2,r2,1
 823d638:	e0bfff15 	stw	r2,-4(fp)
 823d63c:	d0a0be17 	ldw	r2,-32008(gp)
 823d640:	e0ffff17 	ldw	r3,-4(fp)
 823d644:	1880070e 	bge	r3,r2,823d664 <check_interval_timers+0x170>

   /* if no timers, just return */
   if (numtimers > 0)
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 823d648:	e0bffe17 	ldw	r2,-8(fp)
 823d64c:	10800044 	addi	r2,r2,1
 823d650:	e0bffe15 	stw	r2,-8(fp)
 823d654:	e0bffe17 	ldw	r2,-8(fp)
 823d658:	10800150 	cmplti	r2,r2,5
 823d65c:	103fae1e 	bne	r2,zero,823d518 <check_interval_timers+0x24>
            if (++found >= numtimers)
               break;
         }
      }
   }
}
 823d660:	00000106 	br	823d668 <check_interval_timers+0x174>
               intimers[i].callback(intimers[i].parm);      /* call user routine */
               intimers[i].inuse = FALSE;
            }
            /* If we've examined all the active timers, we're done */
            if (++found >= numtimers)
               break;
 823d664:	0001883a 	nop
         }
      }
   }
}
 823d668:	0001883a 	nop
 823d66c:	e037883a 	mov	sp,fp
 823d670:	dfc00117 	ldw	ra,4(sp)
 823d674:	df000017 	ldw	fp,0(sp)
 823d678:	dec00204 	addi	sp,sp,8
 823d67c:	f800283a 	ret

0823d680 <in_timerset>:
 * RETURNS: timer ID if OK, else if table is full.
 */

long
in_timerset(void (*callback)(long), long msecs, long parm)
{
 823d680:	defffa04 	addi	sp,sp,-24
 823d684:	dfc00515 	stw	ra,20(sp)
 823d688:	df000415 	stw	fp,16(sp)
 823d68c:	df000404 	addi	fp,sp,16
 823d690:	e13ffd15 	stw	r4,-12(fp)
 823d694:	e17ffe15 	stw	r5,-8(fp)
 823d698:	e1bfff15 	stw	r6,-4(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 823d69c:	e03ffc15 	stw	zero,-16(fp)
 823d6a0:	00004606 	br	823d7bc <in_timerset+0x13c>
   {
      if(intimers[i].callback == NULL)
 823d6a4:	008209b4 	movhi	r2,2086
 823d6a8:	10ba2504 	addi	r2,r2,-5996
 823d6ac:	e0fffc17 	ldw	r3,-16(fp)
 823d6b0:	18c00524 	muli	r3,r3,20
 823d6b4:	10c5883a 	add	r2,r2,r3
 823d6b8:	10800017 	ldw	r2,0(r2)
 823d6bc:	10003c1e 	bne	r2,zero,823d7b0 <in_timerset+0x130>
      {
         /* found empty table entry, set up new timer */
         intimers[i].callback = callback;
 823d6c0:	008209b4 	movhi	r2,2086
 823d6c4:	10ba2504 	addi	r2,r2,-5996
 823d6c8:	e0fffc17 	ldw	r3,-16(fp)
 823d6cc:	18c00524 	muli	r3,r3,20
 823d6d0:	10c5883a 	add	r2,r2,r3
 823d6d4:	e0fffd17 	ldw	r3,-12(fp)
 823d6d8:	10c00015 	stw	r3,0(r2)
         intimers[i].parm = parm;
 823d6dc:	008209b4 	movhi	r2,2086
 823d6e0:	10ba2504 	addi	r2,r2,-5996
 823d6e4:	e0fffc17 	ldw	r3,-16(fp)
 823d6e8:	18c00524 	muli	r3,r3,20
 823d6ec:	10c5883a 	add	r2,r2,r3
 823d6f0:	10800104 	addi	r2,r2,4
 823d6f4:	e0ffff17 	ldw	r3,-4(fp)
 823d6f8:	10c00015 	stw	r3,0(r2)
         /* set interval, in TPS (cticks) units */
         intimers[i].interval = (msecs * TPS)/1000;
 823d6fc:	e0bffe17 	ldw	r2,-8(fp)
 823d700:	10801924 	muli	r2,r2,100
 823d704:	0140fa04 	movi	r5,1000
 823d708:	1009883a 	mov	r4,r2
 823d70c:	8202b740 	call	8202b74 <__divsi3>
 823d710:	1009883a 	mov	r4,r2
 823d714:	008209b4 	movhi	r2,2086
 823d718:	10ba2504 	addi	r2,r2,-5996
 823d71c:	e0fffc17 	ldw	r3,-16(fp)
 823d720:	18c00524 	muli	r3,r3,20
 823d724:	10c5883a 	add	r2,r2,r3
 823d728:	10800204 	addi	r2,r2,8
 823d72c:	11000015 	stw	r4,0(r2)
         intimers[i].tmo = intimers[i].interval + cticks;   /* first tmo */
 823d730:	008209b4 	movhi	r2,2086
 823d734:	10ba2504 	addi	r2,r2,-5996
 823d738:	e0fffc17 	ldw	r3,-16(fp)
 823d73c:	18c00524 	muli	r3,r3,20
 823d740:	10c5883a 	add	r2,r2,r3
 823d744:	10800204 	addi	r2,r2,8
 823d748:	10c00017 	ldw	r3,0(r2)
 823d74c:	d0a0a817 	ldw	r2,-32096(gp)
 823d750:	1887883a 	add	r3,r3,r2
 823d754:	008209b4 	movhi	r2,2086
 823d758:	10ba2504 	addi	r2,r2,-5996
 823d75c:	e13ffc17 	ldw	r4,-16(fp)
 823d760:	21000524 	muli	r4,r4,20
 823d764:	1105883a 	add	r2,r2,r4
 823d768:	10800304 	addi	r2,r2,12
 823d76c:	10c00015 	stw	r3,0(r2)
		 intimers[i].inuse = FALSE;
 823d770:	008209b4 	movhi	r2,2086
 823d774:	10ba2504 	addi	r2,r2,-5996
 823d778:	e0fffc17 	ldw	r3,-16(fp)
 823d77c:	18c00524 	muli	r3,r3,20
 823d780:	10c5883a 	add	r2,r2,r3
 823d784:	10800404 	addi	r2,r2,16
 823d788:	10000015 	stw	zero,0(r2)
         numtimers++;
 823d78c:	d0a0be17 	ldw	r2,-32008(gp)
 823d790:	10800044 	addi	r2,r2,1
 823d794:	d0a0be15 	stw	r2,-32008(gp)
         return (long)&intimers[i];
 823d798:	e0bffc17 	ldw	r2,-16(fp)
 823d79c:	10c00524 	muli	r3,r2,20
 823d7a0:	008209b4 	movhi	r2,2086
 823d7a4:	10ba2504 	addi	r2,r2,-5996
 823d7a8:	1885883a 	add	r2,r3,r2
 823d7ac:	00000706 	br	823d7cc <in_timerset+0x14c>
long
in_timerset(void (*callback)(long), long msecs, long parm)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 823d7b0:	e0bffc17 	ldw	r2,-16(fp)
 823d7b4:	10800044 	addi	r2,r2,1
 823d7b8:	e0bffc15 	stw	r2,-16(fp)
 823d7bc:	e0bffc17 	ldw	r2,-16(fp)
 823d7c0:	10800150 	cmplti	r2,r2,5
 823d7c4:	103fb71e 	bne	r2,zero,823d6a4 <in_timerset+0x24>
		 intimers[i].inuse = FALSE;
         numtimers++;
         return (long)&intimers[i];
      }
   }
   return 0;
 823d7c8:	0005883a 	mov	r2,zero
}
 823d7cc:	e037883a 	mov	sp,fp
 823d7d0:	dfc00117 	ldw	ra,4(sp)
 823d7d4:	df000017 	ldw	fp,0(sp)
 823d7d8:	dec00204 	addi	sp,sp,8
 823d7dc:	f800283a 	ret

0823d7e0 <in_timerkill>:
 */


int
in_timerkill(long timer)
{
 823d7e0:	defffc04 	addi	sp,sp,-16
 823d7e4:	dfc00315 	stw	ra,12(sp)
 823d7e8:	df000215 	stw	fp,8(sp)
 823d7ec:	df000204 	addi	fp,sp,8
 823d7f0:	e13fff15 	stw	r4,-4(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 823d7f4:	e03ffe15 	stw	zero,-8(fp)
 823d7f8:	00001606 	br	823d854 <in_timerkill+0x74>
   {
      if(timer == (long)&intimers[i])
 823d7fc:	e0bffe17 	ldw	r2,-8(fp)
 823d800:	10c00524 	muli	r3,r2,20
 823d804:	008209b4 	movhi	r2,2086
 823d808:	10ba2504 	addi	r2,r2,-5996
 823d80c:	1885883a 	add	r2,r3,r2
 823d810:	1007883a 	mov	r3,r2
 823d814:	e0bfff17 	ldw	r2,-4(fp)
 823d818:	18800b1e 	bne	r3,r2,823d848 <in_timerkill+0x68>
      {
         intimers[i].callback = NULL;
 823d81c:	008209b4 	movhi	r2,2086
 823d820:	10ba2504 	addi	r2,r2,-5996
 823d824:	e0fffe17 	ldw	r3,-8(fp)
 823d828:	18c00524 	muli	r3,r3,20
 823d82c:	10c5883a 	add	r2,r2,r3
 823d830:	10000015 	stw	zero,0(r2)
         numtimers--;
 823d834:	d0a0be17 	ldw	r2,-32008(gp)
 823d838:	10bfffc4 	addi	r2,r2,-1
 823d83c:	d0a0be15 	stw	r2,-32008(gp)
         return 0;      /* OK return */
 823d840:	0005883a 	mov	r2,zero
 823d844:	00000806 	br	823d868 <in_timerkill+0x88>
int
in_timerkill(long timer)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 823d848:	e0bffe17 	ldw	r2,-8(fp)
 823d84c:	10800044 	addi	r2,r2,1
 823d850:	e0bffe15 	stw	r2,-8(fp)
 823d854:	e0bffe17 	ldw	r2,-8(fp)
 823d858:	10800150 	cmplti	r2,r2,5
 823d85c:	103fe71e 	bne	r2,zero,823d7fc <in_timerkill+0x1c>
         intimers[i].callback = NULL;
         numtimers--;
         return 0;      /* OK return */
      }
   }
   dtrap();    /* timer to kill not found */
 823d860:	822d5f00 	call	822d5f0 <dtrap>
   return ENP_PARAM;
 823d864:	00bffd84 	movi	r2,-10
}
 823d868:	e037883a 	mov	sp,fp
 823d86c:	dfc00117 	ldw	ra,4(sp)
 823d870:	df000017 	ldw	fp,0(sp)
 823d874:	dec00204 	addi	sp,sp,8
 823d878:	f800283a 	ret

0823d87c <create_apptasks>:
#endif
/* per-application thread definitions */

int
create_apptasks(void)
{
 823d87c:	defffe04 	addi	sp,sp,-8
 823d880:	df000115 	stw	fp,4(sp)
 823d884:	df000104 	addi	fp,sp,4
int e = 0;
 823d888:	e03fff15 	stw	zero,-4(fp)
#endif
/* 
 * Altera Niche Stack Nios port modification:
 * return error code, if any 
 */
   return e;
 823d88c:	e0bfff17 	ldw	r2,-4(fp)
}
 823d890:	e037883a 	mov	sp,fp
 823d894:	df000017 	ldw	fp,0(sp)
 823d898:	dec00104 	addi	sp,sp,4
 823d89c:	f800283a 	ret

0823d8a0 <task_stats>:
 */


void
task_stats(void * pio)
{
 823d8a0:	defffd04 	addi	sp,sp,-12
 823d8a4:	dfc00215 	stw	ra,8(sp)
 823d8a8:	df000115 	stw	fp,4(sp)
 823d8ac:	df000104 	addi	fp,sp,4
 823d8b0:	e13fff15 	stw	r4,-4(fp)
   ns_printf(pio, "Task wakeups:");
 823d8b4:	01420974 	movhi	r5,2085
 823d8b8:	29446104 	addi	r5,r5,4484
 823d8bc:	e13fff17 	ldw	r4,-4(fp)
 823d8c0:	8228ebc0 	call	8228ebc <ns_printf>

#ifndef NO_INET_STACK
   ns_printf(pio, "netmain: %lu\n", netmain_wakes);
 823d8c4:	d0a08a17 	ldw	r2,-32216(gp)
 823d8c8:	100d883a 	mov	r6,r2
 823d8cc:	01420974 	movhi	r5,2085
 823d8d0:	29446504 	addi	r5,r5,4500
 823d8d4:	e13fff17 	ldw	r4,-4(fp)
 823d8d8:	8228ebc0 	call	8228ebc <ns_printf>
#endif
#ifndef NO_INET_TICK
   ns_printf(pio, "nettick: %lu\n", nettick_wakes);
 823d8dc:	d0a08b17 	ldw	r2,-32212(gp)
 823d8e0:	100d883a 	mov	r6,r2
 823d8e4:	01420974 	movhi	r5,2085
 823d8e8:	29446904 	addi	r5,r5,4516
 823d8ec:	e13fff17 	ldw	r4,-4(fp)
 823d8f0:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf(pio, "browtask: %lu  ", browtask_wakes);
#endif
#ifdef INCLUDE_SSLAPP
   ns_printf(pio, "INCLUDE_SSLAPP: %lu  ", sslapp_wakes);
#endif
   ns_printf(pio, "\n");
 823d8f4:	01420974 	movhi	r5,2085
 823d8f8:	29446d04 	addi	r5,r5,4532
 823d8fc:	e13fff17 	ldw	r4,-4(fp)
 823d900:	8228ebc0 	call	8228ebc <ns_printf>
}
 823d904:	0001883a 	nop
 823d908:	e037883a 	mov	sp,fp
 823d90c:	dfc00117 	ldw	ra,4(sp)
 823d910:	df000017 	ldw	fp,0(sp)
 823d914:	dec00204 	addi	sp,sp,8
 823d918:	f800283a 	ret

0823d91c <fcntl>:
 * (for files and device drivers) or calls the InterNiche bsd_ioctl for 
 * sockets.
 */
 
int fcntl (int file, int cmd, ...)
{
 823d91c:	defff804 	addi	sp,sp,-32
 823d920:	dfc00515 	stw	ra,20(sp)
 823d924:	df000415 	stw	fp,16(sp)
 823d928:	df000404 	addi	fp,sp,16
 823d92c:	e13ffe15 	stw	r4,-8(fp)
 823d930:	e17fff15 	stw	r5,-4(fp)
 823d934:	e1800215 	stw	r6,8(fp)
 823d938:	e1c00315 	stw	r7,12(fp)
  long     flags;
  va_list  argp;

  if (file < ALT_MAX_FD)
 823d93c:	e0bffe17 	ldw	r2,-8(fp)
 823d940:	10800808 	cmpgei	r2,r2,32
 823d944:	10000c1e 	bne	r2,zero,823d978 <fcntl+0x5c>
  {
    va_start(argp, cmd);
 823d948:	e0800204 	addi	r2,fp,8
 823d94c:	e0bffd15 	stw	r2,-12(fp)
    flags = va_arg(argp, long);
 823d950:	e0bffd17 	ldw	r2,-12(fp)
 823d954:	10c00104 	addi	r3,r2,4
 823d958:	e0fffd15 	stw	r3,-12(fp)
 823d95c:	10800017 	ldw	r2,0(r2)
 823d960:	e0bffc15 	stw	r2,-16(fp)
    va_end(argp);
    return alt_fcntl(file, cmd, flags);
 823d964:	e1bffc17 	ldw	r6,-16(fp)
 823d968:	e17fff17 	ldw	r5,-4(fp)
 823d96c:	e13ffe17 	ldw	r4,-8(fp)
 823d970:	824a1b80 	call	824a1b8 <alt_fcntl>
 823d974:	00000c06 	br	823d9a8 <fcntl+0x8c>
  }
  else
  {
    va_start(argp, cmd);
 823d978:	e0800204 	addi	r2,fp,8
 823d97c:	e0bffd15 	stw	r2,-12(fp)
    flags = va_arg(argp, long);
 823d980:	e0bffd17 	ldw	r2,-12(fp)
 823d984:	10c00104 	addi	r3,r2,4
 823d988:	e0fffd15 	stw	r3,-12(fp)
 823d98c:	10800017 	ldw	r2,0(r2)
 823d990:	e0bffc15 	stw	r2,-16(fp)
    va_end(argp);
    return bsd_ioctl(file, cmd, flags);
 823d994:	e0bfff17 	ldw	r2,-4(fp)
 823d998:	e1bffc17 	ldw	r6,-16(fp)
 823d99c:	100b883a 	mov	r5,r2
 823d9a0:	e13ffe17 	ldw	r4,-8(fp)
 823d9a4:	82282980 	call	8228298 <bsd_ioctl>
  }
}
 823d9a8:	e037883a 	mov	sp,fp
 823d9ac:	dfc00117 	ldw	ra,4(sp)
 823d9b0:	df000017 	ldw	fp,0(sp)
 823d9b4:	dec00404 	addi	sp,sp,16
 823d9b8:	f800283a 	ret

0823d9bc <etainit>:
 * RETURNS: int               0 if OK, else nonzero
 */

int
etainit(void)
{
 823d9bc:	defffe04 	addi	sp,sp,-8
 823d9c0:	dfc00115 	stw	ra,4(sp)
 823d9c4:	df000015 	stw	fp,0(sp)
 823d9c8:	d839883a 	mov	fp,sp
   /* register ARP type with the Net Driver */
   if (reg_type(ET_ARP) != 0)
 823d9cc:	01018204 	movi	r4,1544
 823d9d0:	823eee80 	call	823eee8 <reg_type>
 823d9d4:	10000526 	beq	r2,zero,823d9ec <etainit+0x30>
   {
#ifdef NPDEBUG
      dprintf("ARP: unable to register type with MAC Driver\n");
 823d9d8:	01020974 	movhi	r4,2085
 823d9dc:	21046e04 	addi	r4,r4,4536
 823d9e0:	82036800 	call	8203680 <puts>
#endif
      return (1);
 823d9e4:	00800044 	movi	r2,1
 823d9e8:	00000106 	br	823d9f0 <etainit+0x34>
   }
   return (0);
 823d9ec:	0005883a 	mov	r2,zero
}
 823d9f0:	e037883a 	mov	sp,fp
 823d9f4:	dfc00117 	ldw	ra,4(sp)
 823d9f8:	df000017 	ldw	fp,0(sp)
 823d9fc:	dec00204 	addi	sp,sp,8
 823da00:	f800283a 	ret

0823da04 <et_send>:
 * and MIB info in the packet header. 
 */

int
et_send(PACKET pkt, struct arptabent *tp)
{
 823da04:	defff904 	addi	sp,sp,-28
 823da08:	dfc00615 	stw	ra,24(sp)
 823da0c:	df000515 	stw	fp,20(sp)
 823da10:	df000504 	addi	fp,sp,20
 823da14:	e13ffe15 	stw	r4,-8(fp)
 823da18:	e17fff15 	stw	r5,-4(fp)
   char *ethhdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 823da1c:	e0bffe17 	ldw	r2,-8(fp)
 823da20:	10800617 	ldw	r2,24(r2)
 823da24:	10802717 	ldw	r2,156(r2)
 823da28:	e0bffc15 	stw	r2,-16(fp)
   int err;

   tp->lasttime = cticks;
 823da2c:	d0e0a817 	ldw	r3,-32096(gp)
 823da30:	e0bfff17 	ldw	r2,-4(fp)
 823da34:	10c00615 	stw	r3,24(r2)
   pkt->nb_prot -= ETHHDR_SIZE;  /* prepare for prepending ethernet header */
 823da38:	e0bffe17 	ldw	r2,-8(fp)
 823da3c:	10800317 	ldw	r2,12(r2)
 823da40:	10fffc04 	addi	r3,r2,-16
 823da44:	e0bffe17 	ldw	r2,-8(fp)
 823da48:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen += ETHHDR_SIZE;
 823da4c:	e0bffe17 	ldw	r2,-8(fp)
 823da50:	10800417 	ldw	r2,16(r2)
 823da54:	10c00404 	addi	r3,r2,16
 823da58:	e0bffe17 	ldw	r2,-8(fp)
 823da5c:	10c00415 	stw	r3,16(r2)
   ethhdr = pkt->nb_prot + ETHHDR_BIAS;
 823da60:	e0bffe17 	ldw	r2,-8(fp)
 823da64:	10800317 	ldw	r2,12(r2)
 823da68:	10800084 	addi	r2,r2,2
 823da6c:	e0bffd15 	stw	r2,-12(fp)
      MEMMOVE(snap, snapdata, 6);
      snap->type = ARPIP;
   }
#endif   /* IEEE_802_3 */

   if (ethhdr < pkt->nb_buff)   /* sanity check pointer */
 823da70:	e0bffe17 	ldw	r2,-8(fp)
 823da74:	10800117 	ldw	r2,4(r2)
 823da78:	e0fffd17 	ldw	r3,-12(fp)
 823da7c:	1880032e 	bgeu	r3,r2,823da8c <et_send+0x88>
      panic("et_send: prepend");
 823da80:	01020974 	movhi	r4,2085
 823da84:	21047a04 	addi	r4,r4,4584
 823da88:	8228ca40 	call	8228ca4 <panic>

   MEMMOVE(ethhdr + ET_DSTOFF, tp->t_phy_addr, 6);  /* set pkt's MAC dst addr */
 823da8c:	e0bfff17 	ldw	r2,-4(fp)
 823da90:	10800104 	addi	r2,r2,4
 823da94:	01800184 	movi	r6,6
 823da98:	100b883a 	mov	r5,r2
 823da9c:	e13ffd17 	ldw	r4,-12(fp)
 823daa0:	82030b40 	call	82030b4 <memmove>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);  /* MAC src */
 823daa4:	e0bffd17 	ldw	r2,-12(fp)
 823daa8:	10c00184 	addi	r3,r2,6
 823daac:	e0bffc17 	ldw	r2,-16(fp)
 823dab0:	10800517 	ldw	r2,20(r2)
 823dab4:	01800184 	movi	r6,6
 823dab8:	100b883a 	mov	r5,r2
 823dabc:	1809883a 	mov	r4,r3
 823dac0:	82030b40 	call	82030b4 <memmove>

   /* nice clean ethernet II header */
   if ((tp->flags & (ET_ETH2|ET_SNAP)) != ET_SNAP)
 823dac4:	e0bfff17 	ldw	r2,-4(fp)
 823dac8:	1080070b 	ldhu	r2,28(r2)
 823dacc:	10bfffcc 	andi	r2,r2,65535
 823dad0:	108000cc 	andi	r2,r2,3
 823dad4:	108000a0 	cmpeqi	r2,r2,2
 823dad8:	1000041e 	bne	r2,zero,823daec <et_send+0xe8>
      ET_TYPE_SET(ethhdr, ntohs(ARPIP));
 823dadc:	e0bffd17 	ldw	r2,-12(fp)
 823dae0:	10800304 	addi	r2,r2,12
 823dae4:	00c00204 	movi	r3,8
 823dae8:	10c00005 	stb	r3,0(r2)
 823daec:	e0bffd17 	ldw	r2,-12(fp)
 823daf0:	10800344 	addi	r2,r2,13
 823daf4:	10000005 	stb	zero,0(r2)
      ET_TYPE_SET(ethhdr, len8023);
   }
#endif   /* IEEE_802_3 */

   /* if a packet oriented send exists, use it: */
   if (pkt->net->pkt_send)
 823daf8:	e0bffe17 	ldw	r2,-8(fp)
 823dafc:	10800617 	ldw	r2,24(r2)
 823db00:	10800417 	ldw	r2,16(r2)
 823db04:	10000726 	beq	r2,zero,823db24 <et_send+0x120>
      err = pkt->net->pkt_send(pkt);   /* send packet to media */
 823db08:	e0bffe17 	ldw	r2,-8(fp)
 823db0c:	10800617 	ldw	r2,24(r2)
 823db10:	10800417 	ldw	r2,16(r2)
 823db14:	e13ffe17 	ldw	r4,-8(fp)
 823db18:	103ee83a 	callr	r2
 823db1c:	e0bffb15 	stw	r2,-20(fp)
 823db20:	00001206 	br	823db6c <et_send+0x168>
   else  /* else use older raw_send routine */
   {
      /* sent to media */
      err = pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 823db24:	e0bffe17 	ldw	r2,-8(fp)
 823db28:	10800617 	ldw	r2,24(r2)
 823db2c:	10800317 	ldw	r2,12(r2)
 823db30:	e0fffe17 	ldw	r3,-8(fp)
 823db34:	19000617 	ldw	r4,24(r3)
 823db38:	e0fffe17 	ldw	r3,-8(fp)
 823db3c:	19400317 	ldw	r5,12(r3)
 823db40:	e0fffe17 	ldw	r3,-8(fp)
 823db44:	18c00417 	ldw	r3,16(r3)
 823db48:	180d883a 	mov	r6,r3
 823db4c:	103ee83a 	callr	r2
 823db50:	e0bffb15 	stw	r2,-20(fp)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823db54:	01000084 	movi	r4,2
 823db58:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free(pkt);
 823db5c:	e13ffe17 	ldw	r4,-8(fp)
 823db60:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823db64:	01000084 	movi	r4,2
 823db68:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   }

   return (err);
 823db6c:	e0bffb17 	ldw	r2,-20(fp)
}
 823db70:	e037883a 	mov	sp,fp
 823db74:	dfc00117 	ldw	ra,4(sp)
 823db78:	df000017 	ldw	fp,0(sp)
 823db7c:	dec00204 	addi	sp,sp,8
 823db80:	f800283a 	ret

0823db84 <arp_free_pending>:
 * and mark the entry "unused".
 */

void
arp_free_pending(struct arptabent *entry)
{
 823db84:	defffb04 	addi	sp,sp,-20
 823db88:	dfc00415 	stw	ra,16(sp)
 823db8c:	df000315 	stw	fp,12(sp)
 823db90:	df000304 	addi	fp,sp,12
 823db94:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt;
   PACKET nextpkt;

   /* entry->pending has the linked list of all pending packets */
   tmppkt = entry->pending;
 823db98:	e0bfff17 	ldw	r2,-4(fp)
 823db9c:	10800417 	ldw	r2,16(r2)
 823dba0:	e0bffd15 	stw	r2,-12(fp)
   entry->pending = (PACKET)NULL;
 823dba4:	e0bfff17 	ldw	r2,-4(fp)
 823dba8:	10000415 	stw	zero,16(r2)

   LOCK_NET_RESOURCE(FREEQ_RESID);
 823dbac:	01000084 	movi	r4,2
 823dbb0:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>

   /* free all pending packets */
   while (tmppkt)
 823dbb4:	00000906 	br	823dbdc <arp_free_pending+0x58>
   {
      nextpkt = tmppkt->next;        /* save the next packet in list */
 823dbb8:	e0bffd17 	ldw	r2,-12(fp)
 823dbbc:	10800017 	ldw	r2,0(r2)
 823dbc0:	e0bffe15 	stw	r2,-8(fp)
      tmppkt->next = (PACKET)NULL;
 823dbc4:	e0bffd17 	ldw	r2,-12(fp)
 823dbc8:	10000015 	stw	zero,0(r2)
      pk_free(tmppkt);               /* free current packet */
 823dbcc:	e13ffd17 	ldw	r4,-12(fp)
 823dbd0:	822cd980 	call	822cd98 <pk_free>
      tmppkt = nextpkt;              /* process the next packet */
 823dbd4:	e0bffe17 	ldw	r2,-8(fp)
 823dbd8:	e0bffd15 	stw	r2,-12(fp)
   entry->pending = (PACKET)NULL;

   LOCK_NET_RESOURCE(FREEQ_RESID);

   /* free all pending packets */
   while (tmppkt)
 823dbdc:	e0bffd17 	ldw	r2,-12(fp)
 823dbe0:	103ff51e 	bne	r2,zero,823dbb8 <arp_free_pending+0x34>
      tmppkt->next = (PACKET)NULL;
      pk_free(tmppkt);               /* free current packet */
      tmppkt = nextpkt;              /* process the next packet */
   }

   entry->t_pro_addr = 0;     /* mark the entry "unused" */
 823dbe4:	e0bfff17 	ldw	r2,-4(fp)
 823dbe8:	10000015 	stw	zero,0(r2)

   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823dbec:	01000084 	movi	r4,2
 823dbf0:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
}
 823dbf4:	0001883a 	nop
 823dbf8:	e037883a 	mov	sp,fp
 823dbfc:	dfc00117 	ldw	ra,4(sp)
 823dc00:	df000017 	ldw	fp,0(sp)
 823dc04:	dec00204 	addi	sp,sp,8
 823dc08:	f800283a 	ret

0823dc0c <arp_send_pending>:
 * Clear the list (entry->pending) after sending the packets.
 */

void
arp_send_pending(struct arptabent *entry)
{
 823dc0c:	defffc04 	addi	sp,sp,-16
 823dc10:	dfc00315 	stw	ra,12(sp)
 823dc14:	df000215 	stw	fp,8(sp)
 823dc18:	df000204 	addi	fp,sp,8
 823dc1c:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt = entry->pending;
 823dc20:	e0bfff17 	ldw	r2,-4(fp)
 823dc24:	10800417 	ldw	r2,16(r2)
 823dc28:	e0bffe15 	stw	r2,-8(fp)

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 823dc2c:	00000906 	br	823dc54 <arp_send_pending+0x48>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
 823dc30:	e0bffe17 	ldw	r2,-8(fp)
 823dc34:	10c00017 	ldw	r3,0(r2)
 823dc38:	e0bfff17 	ldw	r2,-4(fp)
 823dc3c:	10c00415 	stw	r3,16(r2)
      tmppkt->next = (PACKET)NULL;
 823dc40:	e0bffe17 	ldw	r2,-8(fp)
 823dc44:	10000015 	stw	zero,0(r2)
      et_send(tmppkt, entry);          /* try send again */
 823dc48:	e17fff17 	ldw	r5,-4(fp)
 823dc4c:	e13ffe17 	ldw	r4,-8(fp)
 823dc50:	823da040 	call	823da04 <et_send>
   PACKET tmppkt = entry->pending;

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 823dc54:	e0bfff17 	ldw	r2,-4(fp)
 823dc58:	10800417 	ldw	r2,16(r2)
 823dc5c:	e0bffe15 	stw	r2,-8(fp)
 823dc60:	e0bffe17 	ldw	r2,-8(fp)
 823dc64:	103ff21e 	bne	r2,zero,823dc30 <arp_send_pending+0x24>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
      tmppkt->next = (PACKET)NULL;
      et_send(tmppkt, entry);          /* try send again */
   }
}
 823dc68:	0001883a 	nop
 823dc6c:	e037883a 	mov	sp,fp
 823dc70:	dfc00117 	ldw	ra,4(sp)
 823dc74:	df000017 	ldw	fp,0(sp)
 823dc78:	dec00204 	addi	sp,sp,8
 823dc7c:	f800283a 	ret

0823dc80 <send_arp>:
 * timeout will eventually free packet. 
 */

int
send_arp(PACKET pkt, ip_addr dest_ip)
{
 823dc80:	defff404 	addi	sp,sp,-48
 823dc84:	dfc00b15 	stw	ra,44(sp)
 823dc88:	df000a15 	stw	fp,40(sp)
 823dc8c:	df000a04 	addi	fp,sp,40
 823dc90:	e13ffe15 	stw	r4,-8(fp)
 823dc94:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *   oldest;
   char * ethhdr;
   NET net = pkt->net;
 823dc98:	e0bffe17 	ldw	r2,-8(fp)
 823dc9c:	10800617 	ldw	r2,24(r2)
 823dca0:	e0bff615 	stw	r2,-40(fp)
   struct arp_hdr *  arphdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 823dca4:	e0bffe17 	ldw	r2,-8(fp)
 823dca8:	10800617 	ldw	r2,24(r2)
 823dcac:	10802717 	ldw	r2,156(r2)
 823dcb0:	e0bff715 	stw	r2,-36(fp)
   } dest_ip_ptr;
#endif /* ETHMCAST */


   /* If we are broadcasting or multicasting ... */
   if ((dest_ip == 0xFFFFFFFF) ||  
 823dcb4:	e0bfff17 	ldw	r2,-4(fp)
 823dcb8:	10bfffe0 	cmpeqi	r2,r2,-1
 823dcbc:	1000191e 	bne	r2,zero,823dd24 <send_arp+0xa4>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask)))
 823dcc0:	e0bff617 	ldw	r2,-40(fp)
 823dcc4:	10800c17 	ldw	r2,48(r2)
 823dcc8:	0086303a 	nor	r3,zero,r2
 823dccc:	e0bfff17 	ldw	r2,-4(fp)
 823dcd0:	1886703a 	and	r3,r3,r2
 823dcd4:	e0bff617 	ldw	r2,-40(fp)
 823dcd8:	10800c17 	ldw	r2,48(r2)
 823dcdc:	0084303a 	nor	r2,zero,r2
   } dest_ip_ptr;
#endif /* ETHMCAST */


   /* If we are broadcasting or multicasting ... */
   if ((dest_ip == 0xFFFFFFFF) ||  
 823dce0:	18801026 	beq	r3,r2,823dd24 <send_arp+0xa4>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask)))
       || (IN_MULTICAST(ntohl(dest_ip)) ))
 823dce4:	e0bfff17 	ldw	r2,-4(fp)
 823dce8:	1006d63a 	srli	r3,r2,24
 823dcec:	e0bfff17 	ldw	r2,-4(fp)
 823dcf0:	1004d23a 	srli	r2,r2,8
 823dcf4:	10bfc00c 	andi	r2,r2,65280
 823dcf8:	1886b03a 	or	r3,r3,r2
 823dcfc:	e0bfff17 	ldw	r2,-4(fp)
 823dd00:	10bfc00c 	andi	r2,r2,65280
 823dd04:	1004923a 	slli	r2,r2,8
 823dd08:	1886b03a 	or	r3,r3,r2
 823dd0c:	e0bfff17 	ldw	r2,-4(fp)
 823dd10:	1004963a 	slli	r2,r2,24
 823dd14:	1884b03a 	or	r2,r3,r2
 823dd18:	10fc002c 	andhi	r3,r2,61440
 823dd1c:	00b80034 	movhi	r2,57344
 823dd20:	1880391e 	bne	r3,r2,823de08 <send_arp+0x188>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask))))

#endif /* IP_MULTICAST */
   {
      /* get unused or oldest entry in table */
      oldest = make_arp_entry(dest_ip, pkt->net);
 823dd24:	e0bffe17 	ldw	r2,-8(fp)
 823dd28:	10800617 	ldw	r2,24(r2)
 823dd2c:	100b883a 	mov	r5,r2
 823dd30:	e13fff17 	ldw	r4,-4(fp)
 823dd34:	823e2400 	call	823e240 <make_arp_entry>
 823dd38:	e0bff915 	stw	r2,-28(fp)

      /* set MAC destination to ethernet broadcast (all FFs) */
      MEMSET(oldest->t_phy_addr, 0xFF, 6);
 823dd3c:	e0bff917 	ldw	r2,-28(fp)
 823dd40:	10800104 	addi	r2,r2,4
 823dd44:	01800184 	movi	r6,6
 823dd48:	01403fc4 	movi	r5,255
 823dd4c:	1009883a 	mov	r4,r2
 823dd50:	82032100 	call	8203210 <memset>
#ifdef IP_MULTICAST
      /* If n_mcastlist routine is defined in the net structure,
         map IP mcast to Ether multicast  */

#ifdef ETHMCAST
      if ((pkt->net->n_mcastlist) && (IN_MULTICAST(ntohl(dest_ip))))
 823dd54:	e0bffe17 	ldw	r2,-8(fp)
 823dd58:	10800617 	ldw	r2,24(r2)
 823dd5c:	10802b17 	ldw	r2,172(r2)
 823dd60:	10002526 	beq	r2,zero,823ddf8 <send_arp+0x178>
 823dd64:	e0bfff17 	ldw	r2,-4(fp)
 823dd68:	1006d63a 	srli	r3,r2,24
 823dd6c:	e0bfff17 	ldw	r2,-4(fp)
 823dd70:	1004d23a 	srli	r2,r2,8
 823dd74:	10bfc00c 	andi	r2,r2,65280
 823dd78:	1886b03a 	or	r3,r3,r2
 823dd7c:	e0bfff17 	ldw	r2,-4(fp)
 823dd80:	10bfc00c 	andi	r2,r2,65280
 823dd84:	1004923a 	slli	r2,r2,8
 823dd88:	1886b03a 	or	r3,r3,r2
 823dd8c:	e0bfff17 	ldw	r2,-4(fp)
 823dd90:	1004963a 	slli	r2,r2,24
 823dd94:	1884b03a 	or	r2,r3,r2
 823dd98:	10fc002c 	andhi	r3,r2,61440
 823dd9c:	00b80034 	movhi	r2,57344
 823dda0:	1880151e 	bne	r3,r2,823ddf8 <send_arp+0x178>
      {
         /* If IP mcast to be mapped to Ethernet multicast */
         dest_ip_ptr.l = dest_ip;
 823dda4:	e0bfff17 	ldw	r2,-4(fp)
 823dda8:	e0bffd15 	stw	r2,-12(fp)
         oldest->t_phy_addr[0] = 0x01;
 823ddac:	e0bff917 	ldw	r2,-28(fp)
 823ddb0:	00c00044 	movi	r3,1
 823ddb4:	10c00105 	stb	r3,4(r2)
         oldest->t_phy_addr[1] = 0x00;
 823ddb8:	e0bff917 	ldw	r2,-28(fp)
 823ddbc:	10000145 	stb	zero,5(r2)
         oldest->t_phy_addr[2] = 0x5e;
 823ddc0:	e0bff917 	ldw	r2,-28(fp)
 823ddc4:	00c01784 	movi	r3,94
 823ddc8:	10c00185 	stb	r3,6(r2)
         oldest->t_phy_addr[3] = (u_char )(dest_ip_ptr.c[1] & 0x7f);
 823ddcc:	e0bffd43 	ldbu	r2,-11(fp)
 823ddd0:	10801fcc 	andi	r2,r2,127
 823ddd4:	1007883a 	mov	r3,r2
 823ddd8:	e0bff917 	ldw	r2,-28(fp)
 823dddc:	10c001c5 	stb	r3,7(r2)
         oldest->t_phy_addr[4] = (u_char )dest_ip_ptr.c[2];
 823dde0:	e0fffd83 	ldbu	r3,-10(fp)
 823dde4:	e0bff917 	ldw	r2,-28(fp)
 823dde8:	10c00205 	stb	r3,8(r2)
         oldest->t_phy_addr[5] = (u_char )dest_ip_ptr.c[3];
 823ddec:	e0fffdc3 	ldbu	r3,-9(fp)
 823ddf0:	e0bff917 	ldw	r2,-28(fp)
 823ddf4:	10c00245 	stb	r3,9(r2)
      }
#endif /* ETHMCAST */
#endif /* IP_MULTICAST */
      return (et_send(pkt, oldest));
 823ddf8:	e17ff917 	ldw	r5,-28(fp)
 823ddfc:	e13ffe17 	ldw	r4,-8(fp)
 823de00:	823da040 	call	823da04 <et_send>
 823de04:	0000ae06 	br	823e0c0 <send_arp+0x440>

   /* If packet is addressed to this Ethernet interface, and
    * it's not a loopback address, then don't send it on the wire. 
    * Instead, free the packet and return ENP_NO_ROUTE  
    */
   if ((pkt->fhost == pkt->net->n_ipaddr) &&
 823de08:	e0bffe17 	ldw	r2,-8(fp)
 823de0c:	10c00717 	ldw	r3,28(r2)
 823de10:	e0bffe17 	ldw	r2,-8(fp)
 823de14:	10800617 	ldw	r2,24(r2)
 823de18:	10800a17 	ldw	r2,40(r2)
 823de1c:	18800d1e 	bne	r3,r2,823de54 <send_arp+0x1d4>
      ((pkt->fhost & htonl(0xFF000000)) != htonl(0x7F000000)))
 823de20:	e0bffe17 	ldw	r2,-8(fp)
 823de24:	10800717 	ldw	r2,28(r2)
 823de28:	10803fcc 	andi	r2,r2,255

   /* If packet is addressed to this Ethernet interface, and
    * it's not a loopback address, then don't send it on the wire. 
    * Instead, free the packet and return ENP_NO_ROUTE  
    */
   if ((pkt->fhost == pkt->net->n_ipaddr) &&
 823de2c:	10801fe0 	cmpeqi	r2,r2,127
 823de30:	1000081e 	bne	r2,zero,823de54 <send_arp+0x1d4>
      ((pkt->fhost & htonl(0xFF000000)) != htonl(0x7F000000)))
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823de34:	01000084 	movi	r4,2
 823de38:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free(pkt);
 823de3c:	e13ffe17 	ldw	r4,-8(fp)
 823de40:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823de44:	01000084 	movi	r4,2
 823de48:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return ENP_NO_ROUTE;
 823de4c:	00bff7c4 	movi	r2,-33
 823de50:	00009b06 	br	823e0c0 <send_arp+0x440>
   }

   /* not broadcasting, so get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 823de54:	01000084 	movi	r4,2
 823de58:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 823de5c:	01000c04 	movi	r4,48
 823de60:	822ca480 	call	822ca48 <pk_alloc>
 823de64:	e0bff815 	stw	r2,-32(fp)
   if (!arppkt)
 823de68:	e0bff817 	ldw	r2,-32(fp)
 823de6c:	1000061e 	bne	r2,zero,823de88 <send_arp+0x208>
   {
      pk_free(pkt);
 823de70:	e13ffe17 	ldw	r4,-8(fp)
 823de74:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823de78:	01000084 	movi	r4,2
 823de7c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 823de80:	00bffa84 	movi	r2,-22
 823de84:	00008e06 	br	823e0c0 <send_arp+0x440>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823de88:	01000084 	movi	r4,2
 823de8c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 823de90:	e0bff817 	ldw	r2,-32(fp)
 823de94:	10c00117 	ldw	r3,4(r2)
 823de98:	e0bff817 	ldw	r2,-32(fp)
 823de9c:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 823dea0:	e0bff817 	ldw	r2,-32(fp)
 823dea4:	00c00c04 	movi	r3,48
 823dea8:	10c00415 	stw	r3,16(r2)
   arppkt->net = pkt->net;
 823deac:	e0bffe17 	ldw	r2,-8(fp)
 823deb0:	10c00617 	ldw	r3,24(r2)
 823deb4:	e0bff817 	ldw	r2,-32(fp)
 823deb8:	10c00615 	stw	r3,24(r2)

   /* get unused or oldest entry in table */
   oldest = make_arp_entry(dest_ip, pkt->net);
 823debc:	e0bffe17 	ldw	r2,-8(fp)
 823dec0:	10800617 	ldw	r2,24(r2)
 823dec4:	100b883a 	mov	r5,r2
 823dec8:	e13fff17 	ldw	r4,-4(fp)
 823decc:	823e2400 	call	823e240 <make_arp_entry>
 823ded0:	e0bff915 	stw	r2,-28(fp)

   oldest->pending = pkt;           /* packet is "pended", not pk_free()d */
 823ded4:	e0bff917 	ldw	r2,-28(fp)
 823ded8:	e0fffe17 	ldw	r3,-8(fp)
 823dedc:	10c00415 	stw	r3,16(r2)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 823dee0:	e0bff817 	ldw	r2,-32(fp)
 823dee4:	10800117 	ldw	r2,4(r2)
 823dee8:	10800084 	addi	r2,r2,2
 823deec:	e0bffa15 	stw	r2,-24(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 823def0:	e0bff817 	ldw	r2,-32(fp)
 823def4:	10800117 	ldw	r2,4(r2)
 823def8:	10800404 	addi	r2,r2,16
 823defc:	e0bffb15 	stw	r2,-20(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 823df00:	e0bffb17 	ldw	r2,-20(fp)
 823df04:	00c04004 	movi	r3,256
 823df08:	10c0000d 	sth	r3,0(r2)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 823df0c:	e0bffb17 	ldw	r2,-20(fp)
 823df10:	00c00204 	movi	r3,8
 823df14:	10c0008d 	sth	r3,2(r2)
   arphdr->ar_hln = 6;
 823df18:	e0bffb17 	ldw	r2,-20(fp)
 823df1c:	00c00184 	movi	r3,6
 823df20:	10c00105 	stb	r3,4(r2)
   arphdr->ar_pln = 4;
 823df24:	e0bffb17 	ldw	r2,-20(fp)
 823df28:	00c00104 	movi	r3,4
 823df2c:	10c00145 	stb	r3,5(r2)
   arphdr->ar_op = ARREQ;
 823df30:	e0bffb17 	ldw	r2,-20(fp)
 823df34:	00c04004 	movi	r3,256
 823df38:	10c0018d 	sth	r3,6(r2)
   arphdr->ar_tpa = dest_ip;        /* target's IP address */
 823df3c:	e0bffb17 	ldw	r2,-20(fp)
 823df40:	e0ffff17 	ldw	r3,-4(fp)
 823df44:	10c00715 	stw	r3,28(r2)
   arphdr->ar_spa = pkt->net->n_ipaddr;   /* my IP address */
 823df48:	e0bffe17 	ldw	r2,-8(fp)
 823df4c:	10800617 	ldw	r2,24(r2)
 823df50:	10c00a17 	ldw	r3,40(r2)
 823df54:	e0bffb17 	ldw	r2,-20(fp)
 823df58:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 823df5c:	e0bffb17 	ldw	r2,-20(fp)
 823df60:	10c00204 	addi	r3,r2,8
 823df64:	e0bff717 	ldw	r2,-36(fp)
 823df68:	10800517 	ldw	r2,20(r2)
 823df6c:	01800184 	movi	r6,6
 823df70:	100b883a 	mov	r5,r2
 823df74:	1809883a 	mov	r4,r3
 823df78:	82030b40 	call	82030b4 <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 823df7c:	01800184 	movi	r6,6
 823df80:	01403fc4 	movi	r5,255
 823df84:	e13ffa17 	ldw	r4,-24(fp)
 823df88:	82032100 	call	8203210 <memset>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 823df8c:	e0bffa17 	ldw	r2,-24(fp)
 823df90:	10c00184 	addi	r3,r2,6
 823df94:	e0bff717 	ldw	r2,-36(fp)
 823df98:	10800517 	ldw	r2,20(r2)
 823df9c:	01800184 	movi	r6,6
 823dfa0:	100b883a 	mov	r5,r2
 823dfa4:	1809883a 	mov	r4,r3
 823dfa8:	82030b40 	call	82030b4 <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 823dfac:	e0bffa17 	ldw	r2,-24(fp)
 823dfb0:	10800304 	addi	r2,r2,12
 823dfb4:	00c00204 	movi	r3,8
 823dfb8:	10c00005 	stb	r3,0(r2)
 823dfbc:	e0bffa17 	ldw	r2,-24(fp)
 823dfc0:	10800344 	addi	r2,r2,13
 823dfc4:	00c00184 	movi	r3,6
 823dfc8:	10c00005 	stb	r3,0(r2)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 823dfcc:	e0bffb17 	ldw	r2,-20(fp)
 823dfd0:	e0bffc15 	stw	r2,-16(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 823dfd4:	e0bffc17 	ldw	r2,-16(fp)
 823dfd8:	10c00204 	addi	r3,r2,8
 823dfdc:	e0bffb17 	ldw	r2,-20(fp)
 823dfe0:	10800204 	addi	r2,r2,8
 823dfe4:	01800184 	movi	r6,6
 823dfe8:	100b883a 	mov	r5,r2
 823dfec:	1809883a 	mov	r4,r3
 823dff0:	82030b40 	call	82030b4 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 823dff4:	e0bffc17 	ldw	r2,-16(fp)
 823dff8:	10c00384 	addi	r3,r2,14
 823dffc:	e0bffb17 	ldw	r2,-20(fp)
 823e000:	10800404 	addi	r2,r2,16
 823e004:	01800104 	movi	r6,4
 823e008:	100b883a 	mov	r5,r2
 823e00c:	1809883a 	mov	r4,r3
 823e010:	82030b40 	call	82030b4 <memmove>
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 823e014:	e0bffc17 	ldw	r2,-16(fp)
 823e018:	10c00484 	addi	r3,r2,18
 823e01c:	e0bffb17 	ldw	r2,-20(fp)
 823e020:	10800504 	addi	r2,r2,20
 823e024:	01800184 	movi	r6,6
 823e028:	100b883a 	mov	r5,r2
 823e02c:	1809883a 	mov	r4,r3
 823e030:	82030b40 	call	82030b4 <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 823e034:	e0bffc17 	ldw	r2,-16(fp)
 823e038:	10c00604 	addi	r3,r2,24
 823e03c:	e0bffb17 	ldw	r2,-20(fp)
 823e040:	10800704 	addi	r2,r2,28
 823e044:	01800104 	movi	r6,4
 823e048:	100b883a 	mov	r5,r2
 823e04c:	1809883a 	mov	r4,r3
 823e050:	82030b40 	call	82030b4 <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 823e054:	e0bff617 	ldw	r2,-40(fp)
 823e058:	10800417 	ldw	r2,16(r2)
 823e05c:	10000526 	beq	r2,zero,823e074 <send_arp+0x3f4>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 823e060:	e0bff617 	ldw	r2,-40(fp)
 823e064:	10800417 	ldw	r2,16(r2)
 823e068:	e13ff817 	ldw	r4,-32(fp)
 823e06c:	103ee83a 	callr	r2
 823e070:	00000f06 	br	823e0b0 <send_arp+0x430>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 823e074:	e0bff617 	ldw	r2,-40(fp)
 823e078:	10800317 	ldw	r2,12(r2)
 823e07c:	e0fff817 	ldw	r3,-32(fp)
 823e080:	19000617 	ldw	r4,24(r3)
 823e084:	e0fff817 	ldw	r3,-32(fp)
 823e088:	18c00117 	ldw	r3,4(r3)
 823e08c:	01800c04 	movi	r6,48
 823e090:	180b883a 	mov	r5,r3
 823e094:	103ee83a 	callr	r2
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823e098:	01000084 	movi	r4,2
 823e09c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 823e0a0:	e13ff817 	ldw	r4,-32(fp)
 823e0a4:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e0a8:	01000084 	movi	r4,2
 823e0ac:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 823e0b0:	d0a0c317 	ldw	r2,-31988(gp)
 823e0b4:	10800044 	addi	r2,r2,1
 823e0b8:	d0a0c315 	stw	r2,-31988(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 823e0bc:	00800044 	movi	r2,1
}
 823e0c0:	e037883a 	mov	sp,fp
 823e0c4:	dfc00117 	ldw	ra,4(sp)
 823e0c8:	df000017 	ldw	fp,0(sp)
 823e0cc:	dec00204 	addi	sp,sp,8
 823e0d0:	f800283a 	ret

0823e0d4 <find_oldest_arp>:
 * Old entries are removed from the table.
 */

struct arptabent * 
find_oldest_arp(ip_addr dest_ip)
{
 823e0d4:	defff804 	addi	sp,sp,-32
 823e0d8:	dfc00715 	stw	ra,28(sp)
 823e0dc:	df000615 	stw	fp,24(sp)
 823e0e0:	df000604 	addi	fp,sp,24
 823e0e4:	e13fff15 	stw	r4,-4(fp)
   struct arptabent *tp;
   struct arptabent *exact  = (struct arptabent *)NULL;
 823e0e8:	e03ffb15 	stw	zero,-20(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
 823e0ec:	e03ffc15 	stw	zero,-16(fp)
   struct arptabent *empty  = (struct arptabent *)NULL;
 823e0f0:	e03ffd15 	stw	zero,-12(fp)
   unsigned long lticks = cticks;
 823e0f4:	d0a0a817 	ldw	r2,-32096(gp)
 823e0f8:	e0bffe15 	stw	r2,-8(fp)

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823e0fc:	008209b4 	movhi	r2,2086
 823e100:	10ba3e04 	addi	r2,r2,-5896
 823e104:	e0bffa15 	stw	r2,-24(fp)
 823e108:	00003b06 	br	823e1f8 <find_oldest_arp+0x124>
   {
      /* age out old, pending entries */
      if (tp->pending)
 823e10c:	e0bffa17 	ldw	r2,-24(fp)
 823e110:	10800417 	ldw	r2,16(r2)
 823e114:	10000b26 	beq	r2,zero,823e144 <find_oldest_arp+0x70>
      {
         /* purge if pending for more than one second */
         if ((lticks - tp->createtime) > TPS)
 823e118:	e0bffa17 	ldw	r2,-24(fp)
 823e11c:	10800517 	ldw	r2,20(r2)
 823e120:	e0fffe17 	ldw	r3,-8(fp)
 823e124:	1885c83a 	sub	r2,r3,r2
 823e128:	10801970 	cmpltui	r2,r2,101
 823e12c:	1000171e 	bne	r2,zero,823e18c <find_oldest_arp+0xb8>
         {
            arp_free_pending(tp);   /* free pending packets */
 823e130:	e13ffa17 	ldw	r4,-24(fp)
 823e134:	823db840 	call	823db84 <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 823e138:	e0bffa17 	ldw	r2,-24(fp)
 823e13c:	10000015 	stw	zero,0(r2)
 823e140:	00001206 	br	823e18c <find_oldest_arp+0xb8>
         }
      }
      else if ((tp->t_pro_addr != 0) &&
 823e144:	e0bffa17 	ldw	r2,-24(fp)
 823e148:	10800017 	ldw	r2,0(r2)
 823e14c:	10000f26 	beq	r2,zero,823e18c <find_oldest_arp+0xb8>
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
 823e150:	e0bffa17 	ldw	r2,-24(fp)
 823e154:	10800517 	ldw	r2,20(r2)
 823e158:	e0fffe17 	ldw	r3,-8(fp)
 823e15c:	1885c83a 	sub	r2,r3,r2
 823e160:	1007883a 	mov	r3,r2
 823e164:	d0a04f17 	ldw	r2,-32452(gp)
         {
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
      }
      else if ((tp->t_pro_addr != 0) &&
 823e168:	18800816 	blt	r3,r2,823e18c <find_oldest_arp+0xb8>
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
               ((int)(lticks - tp->lasttime)   >= TPS))
 823e16c:	e0bffa17 	ldw	r2,-24(fp)
 823e170:	10800617 	ldw	r2,24(r2)
 823e174:	e0fffe17 	ldw	r3,-8(fp)
 823e178:	1885c83a 	sub	r2,r3,r2
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
      }
      else if ((tp->t_pro_addr != 0) &&
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
 823e17c:	10801910 	cmplti	r2,r2,100
 823e180:	1000021e 	bne	r2,zero,823e18c <find_oldest_arp+0xb8>
               ((int)(lticks - tp->lasttime)   >= TPS))
      {
         /* entry has "expired" and has not been reference in 1 sec. */
         tp->t_pro_addr = 0;     /* mark entry as "unused" */
 823e184:	e0bffa17 	ldw	r2,-24(fp)
 823e188:	10000015 	stw	zero,0(r2)
      }

      if (tp->t_pro_addr == dest_ip)   /* ip addr already has entry */
 823e18c:	e0bffa17 	ldw	r2,-24(fp)
 823e190:	10c00017 	ldw	r3,0(r2)
 823e194:	e0bfff17 	ldw	r2,-4(fp)
 823e198:	1880031e 	bne	r3,r2,823e1a8 <find_oldest_arp+0xd4>
      {
         exact = tp;
 823e19c:	e0bffa17 	ldw	r2,-24(fp)
 823e1a0:	e0bffb15 	stw	r2,-20(fp)
 823e1a4:	00001106 	br	823e1ec <find_oldest_arp+0x118>
      }
      else if (tp->t_pro_addr != 0)
 823e1a8:	e0bffa17 	ldw	r2,-24(fp)
 823e1ac:	10800017 	ldw	r2,0(r2)
 823e1b0:	10000a26 	beq	r2,zero,823e1dc <find_oldest_arp+0x108>
      {
         if (!oldest || (tp->lasttime < oldest->lasttime))
 823e1b4:	e0bffc17 	ldw	r2,-16(fp)
 823e1b8:	10000526 	beq	r2,zero,823e1d0 <find_oldest_arp+0xfc>
 823e1bc:	e0bffa17 	ldw	r2,-24(fp)
 823e1c0:	10c00617 	ldw	r3,24(r2)
 823e1c4:	e0bffc17 	ldw	r2,-16(fp)
 823e1c8:	10800617 	ldw	r2,24(r2)
 823e1cc:	1880072e 	bgeu	r3,r2,823e1ec <find_oldest_arp+0x118>
            oldest = tp;
 823e1d0:	e0bffa17 	ldw	r2,-24(fp)
 823e1d4:	e0bffc15 	stw	r2,-16(fp)
 823e1d8:	00000406 	br	823e1ec <find_oldest_arp+0x118>
      }
      else if (!empty)
 823e1dc:	e0bffd17 	ldw	r2,-12(fp)
 823e1e0:	1000021e 	bne	r2,zero,823e1ec <find_oldest_arp+0x118>
         empty = tp;          /* grab first empty slot */
 823e1e4:	e0bffa17 	ldw	r2,-24(fp)
 823e1e8:	e0bffd15 	stw	r2,-12(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
   struct arptabent *empty  = (struct arptabent *)NULL;
   unsigned long lticks = cticks;

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823e1ec:	e0bffa17 	ldw	r2,-24(fp)
 823e1f0:	10800804 	addi	r2,r2,32
 823e1f4:	e0bffa15 	stw	r2,-24(fp)
 823e1f8:	e0fffa17 	ldw	r3,-24(fp)
 823e1fc:	008209b4 	movhi	r2,2086
 823e200:	10ba7e04 	addi	r2,r2,-5640
 823e204:	18bfc136 	bltu	r3,r2,823e10c <find_oldest_arp+0x38>
      }
      else if (!empty)
         empty = tp;          /* grab first empty slot */
   }

   return ((exact) ? exact : ((empty) ? empty : oldest));
 823e208:	e0bffb17 	ldw	r2,-20(fp)
 823e20c:	1000061e 	bne	r2,zero,823e228 <find_oldest_arp+0x154>
 823e210:	e0bffd17 	ldw	r2,-12(fp)
 823e214:	10000226 	beq	r2,zero,823e220 <find_oldest_arp+0x14c>
 823e218:	e0bffd17 	ldw	r2,-12(fp)
 823e21c:	00000306 	br	823e22c <find_oldest_arp+0x158>
 823e220:	e0bffc17 	ldw	r2,-16(fp)
 823e224:	00000106 	br	823e22c <find_oldest_arp+0x158>
 823e228:	e0bffb17 	ldw	r2,-20(fp)
}
 823e22c:	e037883a 	mov	sp,fp
 823e230:	dfc00117 	ldw	ra,4(sp)
 823e234:	df000017 	ldw	fp,0(sp)
 823e238:	dec00204 	addi	sp,sp,8
 823e23c:	f800283a 	ret

0823e240 <make_arp_entry>:
 * active.
 */

struct arptabent *   
make_arp_entry(ip_addr dest_ip, NET net)
{
 823e240:	defffa04 	addi	sp,sp,-24
 823e244:	dfc00515 	stw	ra,20(sp)
 823e248:	df000415 	stw	fp,16(sp)
 823e24c:	df000404 	addi	fp,sp,16
 823e250:	e13ffe15 	stw	r4,-8(fp)
 823e254:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *oldest;
   unsigned long lticks = cticks;
 823e258:	d0a0a817 	ldw	r2,-32096(gp)
 823e25c:	e0bffc15 	stw	r2,-16(fp)

   /* find usable (or existing) ARP table entry */
   oldest = find_oldest_arp(dest_ip);
 823e260:	e13ffe17 	ldw	r4,-8(fp)
 823e264:	823e0d40 	call	823e0d4 <find_oldest_arp>
 823e268:	e0bffd15 	stw	r2,-12(fp)

   /* If recycling entry, don't leak packets which may be stuck here */
   if (oldest->pending && (oldest->t_pro_addr != dest_ip))
 823e26c:	e0bffd17 	ldw	r2,-12(fp)
 823e270:	10800417 	ldw	r2,16(r2)
 823e274:	10000626 	beq	r2,zero,823e290 <make_arp_entry+0x50>
 823e278:	e0bffd17 	ldw	r2,-12(fp)
 823e27c:	10c00017 	ldw	r3,0(r2)
 823e280:	e0bffe17 	ldw	r2,-8(fp)
 823e284:	18800226 	beq	r3,r2,823e290 <make_arp_entry+0x50>
   {
      arp_free_pending(oldest);
 823e288:	e13ffd17 	ldw	r4,-12(fp)
 823e28c:	823db840 	call	823db84 <arp_free_pending>
   }

   /* partially fill in arp entry */
   oldest->t_pro_addr = dest_ip;
 823e290:	e0bffd17 	ldw	r2,-12(fp)
 823e294:	e0fffe17 	ldw	r3,-8(fp)
 823e298:	10c00015 	stw	r3,0(r2)
   oldest->net = net;
 823e29c:	e0bffd17 	ldw	r2,-12(fp)
 823e2a0:	e0ffff17 	ldw	r3,-4(fp)
 823e2a4:	10c00315 	stw	r3,12(r2)
   oldest->flags = 0;
 823e2a8:	e0bffd17 	ldw	r2,-12(fp)
 823e2ac:	1000070d 	sth	zero,28(r2)
   MEMSET(oldest->t_phy_addr, '\0', 6);   /* clear mac address */
 823e2b0:	e0bffd17 	ldw	r2,-12(fp)
 823e2b4:	10800104 	addi	r2,r2,4
 823e2b8:	01800184 	movi	r6,6
 823e2bc:	000b883a 	mov	r5,zero
 823e2c0:	1009883a 	mov	r4,r2
 823e2c4:	82032100 	call	8203210 <memset>
   oldest->createtime = oldest->lasttime = lticks;
 823e2c8:	e0bffd17 	ldw	r2,-12(fp)
 823e2cc:	e0fffc17 	ldw	r3,-16(fp)
 823e2d0:	10c00615 	stw	r3,24(r2)
 823e2d4:	e0bffd17 	ldw	r2,-12(fp)
 823e2d8:	10c00617 	ldw	r3,24(r2)
 823e2dc:	e0bffd17 	ldw	r2,-12(fp)
 823e2e0:	10c00515 	stw	r3,20(r2)

   /* start a ARP timer if there isn't one already */
   /* update the timeout value if there is a timer */
   /* time is specified in milliseconds */
   if (arp_timer == 0)
 823e2e4:	d0a0bf17 	ldw	r2,-32004(gp)
 823e2e8:	1000071e 	bne	r2,zero,823e308 <make_arp_entry+0xc8>
   {
      arp_timer = in_timerset(&cb_arpent_tmo, ARPENT_TMO * 1000, 0);
 823e2ec:	000d883a 	mov	r6,zero
 823e2f0:	0149c404 	movi	r5,10000
 823e2f4:	01020934 	movhi	r4,2084
 823e2f8:	213a7804 	addi	r4,r4,-5664
 823e2fc:	823d6800 	call	823d680 <in_timerset>
 823e300:	d0a0bf15 	stw	r2,-32004(gp)
 823e304:	00000706 	br	823e324 <make_arp_entry+0xe4>
   }
   else
   {
      ((struct intimer *)arp_timer)->tmo =
 823e308:	d0a0bf17 	ldw	r2,-32004(gp)
 823e30c:	1009883a 	mov	r4,r2
              ((struct intimer *)arp_timer)->interval + lticks;
 823e310:	d0a0bf17 	ldw	r2,-32004(gp)
 823e314:	10c00217 	ldw	r3,8(r2)
 823e318:	e0bffc17 	ldw	r2,-16(fp)
 823e31c:	1885883a 	add	r2,r3,r2
   {
      arp_timer = in_timerset(&cb_arpent_tmo, ARPENT_TMO * 1000, 0);
   }
   else
   {
      ((struct intimer *)arp_timer)->tmo =
 823e320:	20800315 	stw	r2,12(r4)
              ((struct intimer *)arp_timer)->interval + lticks;
   }

   return oldest;
 823e324:	e0bffd17 	ldw	r2,-12(fp)
}
 823e328:	e037883a 	mov	sp,fp
 823e32c:	dfc00117 	ldw	ra,4(sp)
 823e330:	df000017 	ldw	fp,0(sp)
 823e334:	dec00204 	addi	sp,sp,8
 823e338:	f800283a 	ret

0823e33c <arpReply>:
 * must be freed (or reused) herein. 
 */

void
arpReply(PACKET pkt)
{
 823e33c:	defff704 	addi	sp,sp,-36
 823e340:	dfc00815 	stw	ra,32(sp)
 823e344:	df000715 	stw	fp,28(sp)
 823e348:	df000704 	addi	fp,sp,28
 823e34c:	e13fff15 	stw	r4,-4(fp)
   struct arp_hdr *in;
   struct arp_hdr *out;
   char *ethout;
   char *ethin;

   LOCK_NET_RESOURCE(FREEQ_RESID);
 823e350:	01000084 	movi	r4,2
 823e354:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   outpkt = pk_alloc(arpsize);
 823e358:	01000c04 	movi	r4,48
 823e35c:	822ca480 	call	822ca48 <pk_alloc>
 823e360:	e0bff915 	stw	r2,-28(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e364:	01000084 	movi	r4,2
 823e368:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>

   if (!outpkt)
 823e36c:	e0bff917 	ldw	r2,-28(fp)
 823e370:	1000021e 	bne	r2,zero,823e37c <arpReply+0x40>
   {
      dtrap();
 823e374:	822d5f00 	call	822d5f0 <dtrap>
      return;
 823e378:	00009b06 	br	823e5e8 <arpReply+0x2ac>
   }

   outpkt->net = pkt->net;    /* send back out the iface it came from */
 823e37c:	e0bfff17 	ldw	r2,-4(fp)
 823e380:	10c00617 	ldw	r3,24(r2)
 823e384:	e0bff917 	ldw	r2,-28(fp)
 823e388:	10c00615 	stw	r3,24(r2)

   ethin = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 823e38c:	e0bfff17 	ldw	r2,-4(fp)
 823e390:	10800317 	ldw	r2,12(r2)
 823e394:	10bffc84 	addi	r2,r2,-14
 823e398:	e0bffa15 	stw	r2,-24(fp)
   ethout = outpkt->nb_buff + ETHHDR_BIAS;
 823e39c:	e0bff917 	ldw	r2,-28(fp)
 823e3a0:	10800117 	ldw	r2,4(r2)
 823e3a4:	10800084 	addi	r2,r2,2
 823e3a8:	e0bffb15 	stw	r2,-20(fp)
      snap->type = ET_ARP;
   }
   else
#endif   /* IEEE_802_3 */
   {
      ET_TYPE_SET(ethout, ntohs(ET_ARP));   /* 0x0806 - ARP type on ethernet */
 823e3ac:	e0bffb17 	ldw	r2,-20(fp)
 823e3b0:	10800304 	addi	r2,r2,12
 823e3b4:	00c00204 	movi	r3,8
 823e3b8:	10c00005 	stb	r3,0(r2)
 823e3bc:	e0bffb17 	ldw	r2,-20(fp)
 823e3c0:	10800344 	addi	r2,r2,13
 823e3c4:	00c00184 	movi	r3,6
 823e3c8:	10c00005 	stb	r3,0(r2)
      in = (struct arp_hdr *)(pkt->nb_prot);
 823e3cc:	e0bfff17 	ldw	r2,-4(fp)
 823e3d0:	10800317 	ldw	r2,12(r2)
 823e3d4:	e0bffc15 	stw	r2,-16(fp)
      out = (struct arp_hdr *)(outpkt->nb_buff + ETHHDR_SIZE);
 823e3d8:	e0bff917 	ldw	r2,-28(fp)
 823e3dc:	10800117 	ldw	r2,4(r2)
 823e3e0:	10800404 	addi	r2,r2,16
 823e3e4:	e0bffd15 	stw	r2,-12(fp)
      outpkt->nb_plen = arpsize;
 823e3e8:	e0bff917 	ldw	r2,-28(fp)
 823e3ec:	00c00c04 	movi	r3,48
 823e3f0:	10c00415 	stw	r3,16(r2)

   /* prepare outgoing arp packet */
#ifdef IEEE_802_3
   out->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   out->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 823e3f4:	e0bffd17 	ldw	r2,-12(fp)
 823e3f8:	00c04004 	movi	r3,256
 823e3fc:	10c0000d 	sth	r3,0(r2)
#endif /* IEEE_802_3 */

   out->ar_pro = ARPIP;
 823e400:	e0bffd17 	ldw	r2,-12(fp)
 823e404:	00c00204 	movi	r3,8
 823e408:	10c0008d 	sth	r3,2(r2)
   out->ar_hln = 6;
 823e40c:	e0bffd17 	ldw	r2,-12(fp)
 823e410:	00c00184 	movi	r3,6
 823e414:	10c00105 	stb	r3,4(r2)
   out->ar_pln = 4;
 823e418:	e0bffd17 	ldw	r2,-12(fp)
 823e41c:	00c00104 	movi	r3,4
 823e420:	10c00145 	stb	r3,5(r2)
   out->ar_op = ARREP;
 823e424:	e0bffd17 	ldw	r2,-12(fp)
 823e428:	00c08004 	movi	r3,512
 823e42c:	10c0018d 	sth	r3,6(r2)
   out->ar_tpa = in->ar_spa;     /* swap IP addresses */
 823e430:	e0bffc17 	ldw	r2,-16(fp)
 823e434:	10c00417 	ldw	r3,16(r2)
 823e438:	e0bffd17 	ldw	r2,-12(fp)
 823e43c:	10c00715 	stw	r3,28(r2)
   out->ar_spa = in->ar_tpa;
 823e440:	e0bffc17 	ldw	r2,-16(fp)
 823e444:	10c00717 	ldw	r3,28(r2)
 823e448:	e0bffd17 	ldw	r2,-12(fp)
 823e44c:	10c00415 	stw	r3,16(r2)
   MEMMOVE(out->ar_tha, in->ar_sha, 6);    /* move his MAC address */
 823e450:	e0bffd17 	ldw	r2,-12(fp)
 823e454:	10c00504 	addi	r3,r2,20
 823e458:	e0bffc17 	ldw	r2,-16(fp)
 823e45c:	10800204 	addi	r2,r2,8
 823e460:	01800184 	movi	r6,6
 823e464:	100b883a 	mov	r5,r2
 823e468:	1809883a 	mov	r4,r3
 823e46c:	82030b40 	call	82030b4 <memmove>
   MEMMOVE(out->ar_sha, outpkt->net->n_mib->ifPhysAddress, 6);  /* fill in our mac address */
 823e470:	e0bffd17 	ldw	r2,-12(fp)
 823e474:	10c00204 	addi	r3,r2,8
 823e478:	e0bff917 	ldw	r2,-28(fp)
 823e47c:	10800617 	ldw	r2,24(r2)
 823e480:	10802717 	ldw	r2,156(r2)
 823e484:	10800517 	ldw	r2,20(r2)
 823e488:	01800184 	movi	r6,6
 823e48c:	100b883a 	mov	r5,r2
 823e490:	1809883a 	mov	r4,r3
 823e494:	82030b40 	call	82030b4 <memmove>

   /* prepend ethernet unicast header to arp reply */
   MEMMOVE(ethout + ET_DSTOFF, ethin + ET_SRCOFF, 6);
 823e498:	e0bffa17 	ldw	r2,-24(fp)
 823e49c:	10800184 	addi	r2,r2,6
 823e4a0:	01800184 	movi	r6,6
 823e4a4:	100b883a 	mov	r5,r2
 823e4a8:	e13ffb17 	ldw	r4,-20(fp)
 823e4ac:	82030b40 	call	82030b4 <memmove>
   MEMMOVE(ethout + ET_SRCOFF, outpkt->net->n_mib->ifPhysAddress, 6);
 823e4b0:	e0bffb17 	ldw	r2,-20(fp)
 823e4b4:	10c00184 	addi	r3,r2,6
 823e4b8:	e0bff917 	ldw	r2,-28(fp)
 823e4bc:	10800617 	ldw	r2,24(r2)
 823e4c0:	10802717 	ldw	r2,156(r2)
 823e4c4:	10800517 	ldw	r2,20(r2)
 823e4c8:	01800184 	movi	r6,6
 823e4cc:	100b883a 	mov	r5,r2
 823e4d0:	1809883a 	mov	r4,r3
 823e4d4:	82030b40 	call	82030b4 <memmove>

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)out;
 823e4d8:	e0bffd17 	ldw	r2,-12(fp)
 823e4dc:	e0bffe15 	stw	r2,-8(fp)
      MEMMOVE(&arwp->data[AR_SHA], out->ar_sha, 6);
 823e4e0:	e0bffe17 	ldw	r2,-8(fp)
 823e4e4:	10c00204 	addi	r3,r2,8
 823e4e8:	e0bffd17 	ldw	r2,-12(fp)
 823e4ec:	10800204 	addi	r2,r2,8
 823e4f0:	01800184 	movi	r6,6
 823e4f4:	100b883a 	mov	r5,r2
 823e4f8:	1809883a 	mov	r4,r3
 823e4fc:	82030b40 	call	82030b4 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &out->ar_spa, 4);
 823e500:	e0bffe17 	ldw	r2,-8(fp)
 823e504:	10c00384 	addi	r3,r2,14
 823e508:	e0bffd17 	ldw	r2,-12(fp)
 823e50c:	10800404 	addi	r2,r2,16
 823e510:	01800104 	movi	r6,4
 823e514:	100b883a 	mov	r5,r2
 823e518:	1809883a 	mov	r4,r3
 823e51c:	82030b40 	call	82030b4 <memmove>
      MEMMOVE(&arwp->data[AR_THA], out->ar_tha, 6);
 823e520:	e0bffe17 	ldw	r2,-8(fp)
 823e524:	10c00484 	addi	r3,r2,18
 823e528:	e0bffd17 	ldw	r2,-12(fp)
 823e52c:	10800504 	addi	r2,r2,20
 823e530:	01800184 	movi	r6,6
 823e534:	100b883a 	mov	r5,r2
 823e538:	1809883a 	mov	r4,r3
 823e53c:	82030b40 	call	82030b4 <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &out->ar_tpa, 4);
 823e540:	e0bffe17 	ldw	r2,-8(fp)
 823e544:	10c00604 	addi	r3,r2,24
 823e548:	e0bffd17 	ldw	r2,-12(fp)
 823e54c:	10800704 	addi	r2,r2,28
 823e550:	01800104 	movi	r6,4
 823e554:	100b883a 	mov	r5,r2
 823e558:	1809883a 	mov	r4,r3
 823e55c:	82030b40 	call	82030b4 <memmove>
   }
#endif   /* NO_CC_PACKING */

   /* if a packet oriented send exists, use it: */
   if (outpkt->net->pkt_send)
 823e560:	e0bff917 	ldw	r2,-28(fp)
 823e564:	10800617 	ldw	r2,24(r2)
 823e568:	10800417 	ldw	r2,16(r2)
 823e56c:	10000a26 	beq	r2,zero,823e598 <arpReply+0x25c>
   {
      outpkt->nb_prot = outpkt->nb_buff;
 823e570:	e0bff917 	ldw	r2,-28(fp)
 823e574:	10c00117 	ldw	r3,4(r2)
 823e578:	e0bff917 	ldw	r2,-28(fp)
 823e57c:	10c00315 	stw	r3,12(r2)
      outpkt->net->pkt_send(outpkt);
 823e580:	e0bff917 	ldw	r2,-28(fp)
 823e584:	10800617 	ldw	r2,24(r2)
 823e588:	10800417 	ldw	r2,16(r2)
 823e58c:	e13ff917 	ldw	r4,-28(fp)
 823e590:	103ee83a 	callr	r2
 823e594:	00001106 	br	823e5dc <arpReply+0x2a0>
   }
   else
   {
      outpkt->net->raw_send(pkt->net, outpkt->nb_buff, outpkt->nb_plen);
 823e598:	e0bff917 	ldw	r2,-28(fp)
 823e59c:	10800617 	ldw	r2,24(r2)
 823e5a0:	10800317 	ldw	r2,12(r2)
 823e5a4:	e0ffff17 	ldw	r3,-4(fp)
 823e5a8:	19000617 	ldw	r4,24(r3)
 823e5ac:	e0fff917 	ldw	r3,-28(fp)
 823e5b0:	19400117 	ldw	r5,4(r3)
 823e5b4:	e0fff917 	ldw	r3,-28(fp)
 823e5b8:	18c00417 	ldw	r3,16(r3)
 823e5bc:	180d883a 	mov	r6,r3
 823e5c0:	103ee83a 	callr	r2
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823e5c4:	01000084 	movi	r4,2
 823e5c8:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free(outpkt);
 823e5cc:	e13ff917 	ldw	r4,-28(fp)
 823e5d0:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e5d4:	01000084 	movi	r4,2
 823e5d8:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   }
   /* input 'pkt' will be freed by caller */
   arpRepsOut++;
 823e5dc:	d0a0c517 	ldw	r2,-31980(gp)
 823e5e0:	10800044 	addi	r2,r2,1
 823e5e4:	d0a0c515 	stw	r2,-31980(gp)
}
 823e5e8:	e037883a 	mov	sp,fp
 823e5ec:	dfc00117 	ldw	ra,4(sp)
 823e5f0:	df000017 	ldw	fp,0(sp)
 823e5f4:	dec00204 	addi	sp,sp,8
 823e5f8:	f800283a 	ret

0823e5fc <arprcv>:
 *                            else a negative error code. 
 */

int
arprcv(PACKET pkt)
{
 823e5fc:	defff904 	addi	sp,sp,-28
 823e600:	dfc00615 	stw	ra,24(sp)
 823e604:	df000515 	stw	fp,20(sp)
 823e608:	df000504 	addi	fp,sp,20
 823e60c:	e13fff15 	stw	r4,-4(fp)
   char *eth;
#ifdef IEEE_802_3
   int      ieee = FALSE;     /* TRUE if received packet is 802.3 */
#endif

   eth = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 823e610:	e0bfff17 	ldw	r2,-4(fp)
 823e614:	10800317 	ldw	r2,12(r2)
 823e618:	10bffc84 	addi	r2,r2,-14
 823e61c:	e0bffc15 	stw	r2,-16(fp)
   arphdr = (struct arp_hdr *)(pkt->nb_prot);
 823e620:	e0bfff17 	ldw	r2,-4(fp)
 823e624:	10800317 	ldw	r2,12(r2)
 823e628:	e0bffd15 	stw	r2,-12(fp)
#endif   /* IEEE_802_3_ONLY */
#endif   /* IEEE_802_3 */

#ifdef NO_CC_PACKING    /* force ARP fields to local CPU valid boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 823e62c:	e0bffd17 	ldw	r2,-12(fp)
 823e630:	e0bffe15 	stw	r2,-8(fp)
      MEMMOVE(&arphdr->ar_tpa, &arwp->data[AR_TPA], 4);
 823e634:	e0bffd17 	ldw	r2,-12(fp)
 823e638:	10c00704 	addi	r3,r2,28
 823e63c:	e0bffe17 	ldw	r2,-8(fp)
 823e640:	10800604 	addi	r2,r2,24
 823e644:	01800104 	movi	r6,4
 823e648:	100b883a 	mov	r5,r2
 823e64c:	1809883a 	mov	r4,r3
 823e650:	82030b40 	call	82030b4 <memmove>
      MEMMOVE(arphdr->ar_tha, &arwp->data[AR_THA], 6);
 823e654:	e0bffd17 	ldw	r2,-12(fp)
 823e658:	10c00504 	addi	r3,r2,20
 823e65c:	e0bffe17 	ldw	r2,-8(fp)
 823e660:	10800484 	addi	r2,r2,18
 823e664:	01800184 	movi	r6,6
 823e668:	100b883a 	mov	r5,r2
 823e66c:	1809883a 	mov	r4,r3
 823e670:	82030b40 	call	82030b4 <memmove>
      MEMMOVE(&arphdr->ar_spa, &arwp->data[AR_SPA], 4);
 823e674:	e0bffd17 	ldw	r2,-12(fp)
 823e678:	10c00404 	addi	r3,r2,16
 823e67c:	e0bffe17 	ldw	r2,-8(fp)
 823e680:	10800384 	addi	r2,r2,14
 823e684:	01800104 	movi	r6,4
 823e688:	100b883a 	mov	r5,r2
 823e68c:	1809883a 	mov	r4,r3
 823e690:	82030b40 	call	82030b4 <memmove>
      MEMMOVE(arphdr->ar_sha, &arwp->data[AR_SHA], 6);
 823e694:	e0bffd17 	ldw	r2,-12(fp)
 823e698:	10c00204 	addi	r3,r2,8
 823e69c:	e0bffe17 	ldw	r2,-8(fp)
 823e6a0:	10800204 	addi	r2,r2,8
 823e6a4:	01800184 	movi	r6,6
 823e6a8:	100b883a 	mov	r5,r2
 823e6ac:	1809883a 	mov	r4,r3
 823e6b0:	82030b40 	call	82030b4 <memmove>
#endif
   USE_ARG(eth);

   /* check ARP's target IP against our net's: */
#ifdef IP_MULTICAST
   if ((arphdr->ar_tpa != pkt->net->n_ipaddr) &&   /* if it's not for me.... */
 823e6b4:	e0bffd17 	ldw	r2,-12(fp)
 823e6b8:	10c00717 	ldw	r3,28(r2)
 823e6bc:	e0bfff17 	ldw	r2,-4(fp)
 823e6c0:	10800617 	ldw	r2,24(r2)
 823e6c4:	10800a17 	ldw	r2,40(r2)
 823e6c8:	18801c26 	beq	r3,r2,823e73c <arprcv+0x140>
     (!IN_MULTICAST(ntohl(arphdr->ar_tpa))))
 823e6cc:	e0bffd17 	ldw	r2,-12(fp)
 823e6d0:	10800717 	ldw	r2,28(r2)
 823e6d4:	1006d63a 	srli	r3,r2,24
 823e6d8:	e0bffd17 	ldw	r2,-12(fp)
 823e6dc:	10800717 	ldw	r2,28(r2)
 823e6e0:	1004d23a 	srli	r2,r2,8
 823e6e4:	10bfc00c 	andi	r2,r2,65280
 823e6e8:	1886b03a 	or	r3,r3,r2
 823e6ec:	e0bffd17 	ldw	r2,-12(fp)
 823e6f0:	10800717 	ldw	r2,28(r2)
 823e6f4:	10bfc00c 	andi	r2,r2,65280
 823e6f8:	1004923a 	slli	r2,r2,8
 823e6fc:	1886b03a 	or	r3,r3,r2
 823e700:	e0bffd17 	ldw	r2,-12(fp)
 823e704:	10800717 	ldw	r2,28(r2)
 823e708:	1004963a 	slli	r2,r2,24
 823e70c:	1884b03a 	or	r2,r3,r2
 823e710:	10fc002c 	andhi	r3,r2,61440
#endif
   USE_ARG(eth);

   /* check ARP's target IP against our net's: */
#ifdef IP_MULTICAST
   if ((arphdr->ar_tpa != pkt->net->n_ipaddr) &&   /* if it's not for me.... */
 823e714:	00b80034 	movhi	r2,57344
 823e718:	18800826 	beq	r3,r2,823e73c <arprcv+0x140>
     (!IN_MULTICAST(ntohl(arphdr->ar_tpa))))
#else
   if (arphdr->ar_tpa != pkt->net->n_ipaddr)
#endif /* IP_MULTICAST */
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823e71c:	01000084 	movi	r4,2
 823e720:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free(pkt);     /* not for us, dump & ret (proxy here later?) */
 823e724:	e13fff17 	ldw	r4,-4(fp)
 823e728:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e72c:	01000084 	movi	r4,2
 823e730:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return (ENP_NOT_MINE);
 823e734:	00800084 	movi	r2,2
 823e738:	00004406 	br	823e84c <arprcv+0x250>
   }

   if (arphdr->ar_op == ARREQ)   /* is it an arp request? */
 823e73c:	e0bffd17 	ldw	r2,-12(fp)
 823e740:	1080018b 	ldhu	r2,6(r2)
 823e744:	10bfffcc 	andi	r2,r2,65535
 823e748:	10804018 	cmpnei	r2,r2,256
 823e74c:	10000d1e 	bne	r2,zero,823e784 <arprcv+0x188>
   {
      arpReqsIn++;   /* count these */
 823e750:	d0a0c217 	ldw	r2,-31992(gp)
 823e754:	10800044 	addi	r2,r2,1
 823e758:	d0a0c215 	stw	r2,-31992(gp)
      arpReply(pkt); /* send arp reply */
 823e75c:	e13fff17 	ldw	r4,-4(fp)
 823e760:	823e33c0 	call	823e33c <arpReply>
      /* make partial ARP table entry */
      make_arp_entry(arphdr->ar_spa, pkt->net);
 823e764:	e0bffd17 	ldw	r2,-12(fp)
 823e768:	10c00417 	ldw	r3,16(r2)
 823e76c:	e0bfff17 	ldw	r2,-4(fp)
 823e770:	10800617 	ldw	r2,24(r2)
 823e774:	100b883a 	mov	r5,r2
 823e778:	1809883a 	mov	r4,r3
 823e77c:	823e2400 	call	823e240 <make_arp_entry>
 823e780:	00000306 	br	823e790 <arprcv+0x194>
      /* fall thru to arp reply logic to finish our table entry */
   }
   else     /* ARP reply, count and fall thru to logic to update table */
   {
      arpRepsIn++;
 823e784:	d0a0c417 	ldw	r2,-31984(gp)
 823e788:	10800044 	addi	r2,r2,1
 823e78c:	d0a0c415 	stw	r2,-31984(gp)
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823e790:	008209b4 	movhi	r2,2086
 823e794:	10ba3e04 	addi	r2,r2,-5896
 823e798:	e0bffb15 	stw	r2,-20(fp)
 823e79c:	00002006 	br	823e820 <arprcv+0x224>
   {
      if (tp->t_pro_addr == arphdr->ar_spa)     /* we found IP address, update entry */
 823e7a0:	e0bffb17 	ldw	r2,-20(fp)
 823e7a4:	10c00017 	ldw	r3,0(r2)
 823e7a8:	e0bffd17 	ldw	r2,-12(fp)
 823e7ac:	10800417 	ldw	r2,16(r2)
 823e7b0:	1880181e 	bne	r3,r2,823e814 <arprcv+0x218>
            tp->flags |= ET_SNAP;
         else
            tp->flags |= ET_ETH2;      /* else it's ethernet II */
#endif   /* IEEE_802_3 */

         MEMMOVE(tp->t_phy_addr, arphdr->ar_sha, 6);   /* update MAC adddress */
 823e7b4:	e0bffb17 	ldw	r2,-20(fp)
 823e7b8:	10c00104 	addi	r3,r2,4
 823e7bc:	e0bffd17 	ldw	r2,-12(fp)
 823e7c0:	10800204 	addi	r2,r2,8
 823e7c4:	01800184 	movi	r6,6
 823e7c8:	100b883a 	mov	r5,r2
 823e7cc:	1809883a 	mov	r4,r3
 823e7d0:	82030b40 	call	82030b4 <memmove>
         tp->lasttime = cticks;
 823e7d4:	d0e0a817 	ldw	r3,-32096(gp)
 823e7d8:	e0bffb17 	ldw	r2,-20(fp)
 823e7dc:	10c00615 	stw	r3,24(r2)
         if (tp->pending)     /* packet waiting for this IP entry? */
 823e7e0:	e0bffb17 	ldw	r2,-20(fp)
 823e7e4:	10800417 	ldw	r2,16(r2)
 823e7e8:	10000226 	beq	r2,zero,823e7f4 <arprcv+0x1f8>
         {
            arp_send_pending(tp);
 823e7ec:	e13ffb17 	ldw	r4,-20(fp)
 823e7f0:	823dc0c0 	call	823dc0c <arp_send_pending>
         }
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823e7f4:	01000084 	movi	r4,2
 823e7f8:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
         pk_free(pkt);
 823e7fc:	e13fff17 	ldw	r4,-4(fp)
 823e800:	822cd980 	call	822cd98 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e804:	01000084 	movi	r4,2
 823e808:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>

         return (0);
 823e80c:	0005883a 	mov	r2,zero
 823e810:	00000e06 	br	823e84c <arprcv+0x250>
      arpRepsIn++;
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823e814:	e0bffb17 	ldw	r2,-20(fp)
 823e818:	10800804 	addi	r2,r2,32
 823e81c:	e0bffb15 	stw	r2,-20(fp)
 823e820:	e0fffb17 	ldw	r3,-20(fp)
 823e824:	008209b4 	movhi	r2,2086
 823e828:	10ba7e04 	addi	r2,r2,-5640
 823e82c:	18bfdc36 	bltu	r3,r2,823e7a0 <arprcv+0x1a4>

#ifdef IEEE_802_3_ONLY
drop:
#endif /* IEEE_802_3_ONLY */
   /* fall to here if packet is not in table */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 823e830:	01000084 	movi	r4,2
 823e834:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   pk_free(pkt);
 823e838:	e13fff17 	ldw	r4,-4(fp)
 823e83c:	822cd980 	call	822cd98 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e840:	01000084 	movi	r4,2
 823e844:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>

   return ENP_NOT_MINE;
 823e848:	00800084 	movi	r2,2
}
 823e84c:	e037883a 	mov	sp,fp
 823e850:	dfc00117 	ldw	ra,4(sp)
 823e854:	df000017 	ldw	fp,0(sp)
 823e858:	dec00204 	addi	sp,sp,8
 823e85c:	f800283a 	ret

0823e860 <send_via_arp>:
 * change the PC's IP address. 
 */

int
send_via_arp(PACKET pkt, ip_addr dest_ip)
{
 823e860:	defff804 	addi	sp,sp,-32
 823e864:	dfc00715 	stw	ra,28(sp)
 823e868:	df000615 	stw	fp,24(sp)
 823e86c:	df000604 	addi	fp,sp,24
 823e870:	e13ffe15 	stw	r4,-8(fp)
 823e874:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *tp;
   unsigned long lticks = cticks;
 823e878:	d0a0a817 	ldw	r2,-32096(gp)
 823e87c:	e0bffd15 	stw	r2,-12(fp)
   int err;

   /* don't allow zero dest */
   if (dest_ip == 0)
 823e880:	e0bfff17 	ldw	r2,-4(fp)
 823e884:	1000081e 	bne	r2,zero,823e8a8 <send_via_arp+0x48>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823e888:	01000084 	movi	r4,2
 823e88c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free(pkt);
 823e890:	e13ffe17 	ldw	r4,-8(fp)
 823e894:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e898:	01000084 	movi	r4,2
 823e89c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return SEND_DROPPED; 
 823e8a0:	00bffa84 	movi	r2,-22
 823e8a4:	00004906 	br	823e9cc <send_via_arp+0x16c>
   }

   /* Force refresh of cache once a second */
   if ((lticks - cachetime) > TPS)
 823e8a8:	d0a0c117 	ldw	r2,-31996(gp)
 823e8ac:	e0fffd17 	ldw	r3,-12(fp)
 823e8b0:	1885c83a 	sub	r2,r3,r2
 823e8b4:	10801970 	cmpltui	r2,r2,101
 823e8b8:	1000011e 	bne	r2,zero,823e8c0 <send_via_arp+0x60>
      arpcache = (struct arptabent *)NULL;
 823e8bc:	d020c015 	stw	zero,-32000(gp)

   /* look at the last ARP entry used. Good chance it's ours: */
   if (arpcache && (arpcache->t_pro_addr == dest_ip))
 823e8c0:	d0a0c017 	ldw	r2,-32000(gp)
 823e8c4:	10000726 	beq	r2,zero,823e8e4 <send_via_arp+0x84>
 823e8c8:	d0a0c017 	ldw	r2,-32000(gp)
 823e8cc:	10c00017 	ldw	r3,0(r2)
 823e8d0:	e0bfff17 	ldw	r2,-4(fp)
 823e8d4:	1880031e 	bne	r3,r2,823e8e4 <send_via_arp+0x84>
      tp = arpcache;
 823e8d8:	d0a0c017 	ldw	r2,-32000(gp)
 823e8dc:	e0bffa15 	stw	r2,-24(fp)
 823e8e0:	00000306 	br	823e8f0 <send_via_arp+0x90>
   else
   {
      /* scan arp table for an existing entry */
      tp = find_oldest_arp(dest_ip);
 823e8e4:	e13fff17 	ldw	r4,-4(fp)
 823e8e8:	823e0d40 	call	823e0d4 <find_oldest_arp>
 823e8ec:	e0bffa15 	stw	r2,-24(fp)
   }

   if (tp->t_pro_addr == dest_ip)   /* we found our entry */
 823e8f0:	e0bffa17 	ldw	r2,-24(fp)
 823e8f4:	10c00017 	ldw	r3,0(r2)
 823e8f8:	e0bfff17 	ldw	r2,-4(fp)
 823e8fc:	18802e1e 	bne	r3,r2,823e9b8 <send_via_arp+0x158>
   {
      if (tp->pending)  /* arp already pending for this IP? */
 823e900:	e0bffa17 	ldw	r2,-24(fp)
 823e904:	10800417 	ldw	r2,16(r2)
 823e908:	10002226 	beq	r2,zero,823e994 <send_via_arp+0x134>
      {
         if (lilfreeq.q_len < 2)
 823e90c:	008209b4 	movhi	r2,2086
 823e910:	10b89f04 	addi	r2,r2,-7556
 823e914:	10800217 	ldw	r2,8(r2)
 823e918:	10800088 	cmpgei	r2,r2,2
 823e91c:	1000091e 	bne	r2,zero,823e944 <send_via_arp+0xe4>
         {
            /* system is depleted of resources - free the
             * pkt instead of queueing it - so that we are in a
             * position to receive an arp reply 
             */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 823e920:	01000084 	movi	r4,2
 823e924:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
            pk_free(pkt);  /* sorry, we have to dump this one.. */
 823e928:	e13ffe17 	ldw	r4,-8(fp)
 823e92c:	822cd980 	call	822cd98 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e930:	01000084 	movi	r4,2
 823e934:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
            err = SEND_DROPPED;    /* pkts already waiting for this IP entry */
 823e938:	00bffa84 	movi	r2,-22
 823e93c:	e0bffb15 	stw	r2,-20(fp)
 823e940:	00002106 	br	823e9c8 <send_via_arp+0x168>
         }
         else
         {
            PACKET tmppkt=tp->pending;
 823e944:	e0bffa17 	ldw	r2,-24(fp)
 823e948:	10800417 	ldw	r2,16(r2)
 823e94c:	e0bffc15 	stw	r2,-16(fp)

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 823e950:	00000306 	br	823e960 <send_via_arp+0x100>
               tmppkt = tmppkt->next;
 823e954:	e0bffc17 	ldw	r2,-16(fp)
 823e958:	10800017 	ldw	r2,0(r2)
 823e95c:	e0bffc15 	stw	r2,-16(fp)
         else
         {
            PACKET tmppkt=tp->pending;

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 823e960:	e0bffc17 	ldw	r2,-16(fp)
 823e964:	10800017 	ldw	r2,0(r2)
 823e968:	103ffa1e 	bne	r2,zero,823e954 <send_via_arp+0xf4>
               tmppkt = tmppkt->next;
            tmppkt->next = pkt;      /* add new pkt to end of list */
 823e96c:	e0bffc17 	ldw	r2,-16(fp)
 823e970:	e0fffe17 	ldw	r3,-8(fp)
 823e974:	10c00015 	stw	r3,0(r2)
            if (pkt->next)
 823e978:	e0bffe17 	ldw	r2,-8(fp)
 823e97c:	10800017 	ldw	r2,0(r2)
 823e980:	10000126 	beq	r2,zero,823e988 <send_via_arp+0x128>
            {
               dtrap();              /* chain of pkts to be sent ??? */
 823e984:	822d5f00 	call	822d5f0 <dtrap>
            }
            err = ENP_SEND_PENDING; /* packet queued pending ARP reply */
 823e988:	00800044 	movi	r2,1
 823e98c:	e0bffb15 	stw	r2,-20(fp)
 823e990:	00000d06 	br	823e9c8 <send_via_arp+0x168>
         }
      }
      else  /* just send it */
      {
         arpcache = tp;       /* cache this entry */
 823e994:	e0bffa17 	ldw	r2,-24(fp)
 823e998:	d0a0c015 	stw	r2,-32000(gp)
         cachetime = lticks;  /* mark time we cached */
 823e99c:	e0bffd17 	ldw	r2,-12(fp)
 823e9a0:	d0a0c115 	stw	r2,-31996(gp)
         err = et_send(pkt, tp);
 823e9a4:	e17ffa17 	ldw	r5,-24(fp)
 823e9a8:	e13ffe17 	ldw	r4,-8(fp)
 823e9ac:	823da040 	call	823da04 <et_send>
 823e9b0:	e0bffb15 	stw	r2,-20(fp)
 823e9b4:	00000406 	br	823e9c8 <send_via_arp+0x168>
      }
   }
   else
      /* start the ARP process for this IP address */
      err = send_arp(pkt, dest_ip);
 823e9b8:	e17fff17 	ldw	r5,-4(fp)
 823e9bc:	e13ffe17 	ldw	r4,-8(fp)
 823e9c0:	823dc800 	call	823dc80 <send_arp>
 823e9c4:	e0bffb15 	stw	r2,-20(fp)

   return (err);
 823e9c8:	e0bffb17 	ldw	r2,-20(fp)
}
 823e9cc:	e037883a 	mov	sp,fp
 823e9d0:	dfc00117 	ldw	ra,4(sp)
 823e9d4:	df000017 	ldw	fp,0(sp)
 823e9d8:	dec00204 	addi	sp,sp,8
 823e9dc:	f800283a 	ret

0823e9e0 <cb_arpent_tmo>:
 *
 * If there are no more unresolved entries, cancel the timer.
 */
void
cb_arpent_tmo(long arg)
{
 823e9e0:	defffa04 	addi	sp,sp,-24
 823e9e4:	dfc00515 	stw	ra,20(sp)
 823e9e8:	df000415 	stw	fp,16(sp)
 823e9ec:	df000404 	addi	fp,sp,16
 823e9f0:	e13fff15 	stw	r4,-4(fp)
   struct arptabent *tp;
   int arp_count = 0;
 823e9f4:	e03ffd15 	stw	zero,-12(fp)
   unsigned long lticks = cticks;
 823e9f8:	d0a0a817 	ldw	r2,-32096(gp)
 823e9fc:	e0bffe15 	stw	r2,-8(fp)

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823ea00:	008209b4 	movhi	r2,2086
 823ea04:	10ba3e04 	addi	r2,r2,-5896
 823ea08:	e0bffc15 	stw	r2,-16(fp)
 823ea0c:	00002706 	br	823eaac <cb_arpent_tmo+0xcc>
   {
      if (tp->t_pro_addr != 0)
 823ea10:	e0bffc17 	ldw	r2,-16(fp)
 823ea14:	10800017 	ldw	r2,0(r2)
 823ea18:	10002126 	beq	r2,zero,823eaa0 <cb_arpent_tmo+0xc0>
      {
         /* age out old, pending entries */
         if (tp->pending && ((lticks - tp->createtime) > TPS))
 823ea1c:	e0bffc17 	ldw	r2,-16(fp)
 823ea20:	10800417 	ldw	r2,16(r2)
 823ea24:	10000b26 	beq	r2,zero,823ea54 <cb_arpent_tmo+0x74>
 823ea28:	e0bffc17 	ldw	r2,-16(fp)
 823ea2c:	10800517 	ldw	r2,20(r2)
 823ea30:	e0fffe17 	ldw	r3,-8(fp)
 823ea34:	1885c83a 	sub	r2,r3,r2
 823ea38:	10801970 	cmpltui	r2,r2,101
 823ea3c:	1000051e 	bne	r2,zero,823ea54 <cb_arpent_tmo+0x74>
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
 823ea40:	e13ffc17 	ldw	r4,-16(fp)
 823ea44:	823db840 	call	823db84 <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 823ea48:	e0bffc17 	ldw	r2,-16(fp)
 823ea4c:	10000015 	stw	zero,0(r2)
 823ea50:	00001306 	br	823eaa0 <cb_arpent_tmo+0xc0>
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 823ea54:	e0bffc17 	ldw	r2,-16(fp)
 823ea58:	10800517 	ldw	r2,20(r2)
 823ea5c:	e0fffe17 	ldw	r3,-8(fp)
 823ea60:	1885c83a 	sub	r2,r3,r2
 823ea64:	1007883a 	mov	r3,r2
 823ea68:	d0a04f17 	ldw	r2,-32452(gp)
 823ea6c:	18800916 	blt	r3,r2,823ea94 <cb_arpent_tmo+0xb4>
                  ((int)(lticks - tp->lasttime)   >= TPS))
 823ea70:	e0bffc17 	ldw	r2,-16(fp)
 823ea74:	10800617 	ldw	r2,24(r2)
 823ea78:	e0fffe17 	ldw	r3,-8(fp)
 823ea7c:	1885c83a 	sub	r2,r3,r2
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 823ea80:	10801910 	cmplti	r2,r2,100
 823ea84:	1000031e 	bne	r2,zero,823ea94 <cb_arpent_tmo+0xb4>
                  ((int)(lticks - tp->lasttime)   >= TPS))
         {
            /* entry has "expired" and has not been reference in 1 sec. */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 823ea88:	e0bffc17 	ldw	r2,-16(fp)
 823ea8c:	10000015 	stw	zero,0(r2)
 823ea90:	00000306 	br	823eaa0 <cb_arpent_tmo+0xc0>
         }
         else
            arp_count++;
 823ea94:	e0bffd17 	ldw	r2,-12(fp)
 823ea98:	10800044 	addi	r2,r2,1
 823ea9c:	e0bffd15 	stw	r2,-12(fp)
{
   struct arptabent *tp;
   int arp_count = 0;
   unsigned long lticks = cticks;

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823eaa0:	e0bffc17 	ldw	r2,-16(fp)
 823eaa4:	10800804 	addi	r2,r2,32
 823eaa8:	e0bffc15 	stw	r2,-16(fp)
 823eaac:	e0fffc17 	ldw	r3,-16(fp)
 823eab0:	008209b4 	movhi	r2,2086
 823eab4:	10ba7e04 	addi	r2,r2,-5640
 823eab8:	18bfd536 	bltu	r3,r2,823ea10 <cb_arpent_tmo+0x30>
            arp_count++;
      }
   }

   /* if there are no more "pending" entries, kill the timer */
   if (arp_count == 0)
 823eabc:	e0bffd17 	ldw	r2,-12(fp)
 823eac0:	1000041e 	bne	r2,zero,823ead4 <cb_arpent_tmo+0xf4>
   {
      in_timerkill(arp_timer);
 823eac4:	d0a0bf17 	ldw	r2,-32004(gp)
 823eac8:	1009883a 	mov	r4,r2
 823eacc:	823d7e00 	call	823d7e0 <in_timerkill>
      arp_timer = 0;
 823ead0:	d020bf15 	stw	zero,-32004(gp)
   }
      
   USE_ARG(arg);
}
 823ead4:	0001883a 	nop
 823ead8:	e037883a 	mov	sp,fp
 823eadc:	dfc00117 	ldw	ra,4(sp)
 823eae0:	df000017 	ldw	fp,0(sp)
 823eae4:	dec00204 	addi	sp,sp,8
 823eae8:	f800283a 	ret

0823eaec <grat_arp>:
 * RETURNS: Returns 0 if OK, or the usual ENP_ errors 
 */

int
grat_arp(NET net, int flag)
{
 823eaec:	defff704 	addi	sp,sp,-36
 823eaf0:	dfc00815 	stw	ra,32(sp)
 823eaf4:	df000715 	stw	fp,28(sp)
 823eaf8:	df000704 	addi	fp,sp,28
 823eafc:	e13ffe15 	stw	r4,-8(fp)
 823eb00:	e17fff15 	stw	r5,-4(fp)
   char * ethhdr;
   struct arp_hdr *  arphdr;
   IFMIB etif = net->n_mib;    /* mib info for this ethernet interface */
 823eb04:	e0bffe17 	ldw	r2,-8(fp)
 823eb08:	10802717 	ldw	r2,156(r2)
 823eb0c:	e0bff915 	stw	r2,-28(fp)
   PACKET arppkt;

   /* get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 823eb10:	01000084 	movi	r4,2
 823eb14:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 823eb18:	01000c04 	movi	r4,48
 823eb1c:	822ca480 	call	822ca48 <pk_alloc>
 823eb20:	e0bffa15 	stw	r2,-24(fp)
   if (!arppkt)
 823eb24:	e0bffa17 	ldw	r2,-24(fp)
 823eb28:	1000041e 	bne	r2,zero,823eb3c <grat_arp+0x50>
   {
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823eb2c:	01000084 	movi	r4,2
 823eb30:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 823eb34:	00bffa84 	movi	r2,-22
 823eb38:	00009506 	br	823ed90 <grat_arp+0x2a4>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823eb3c:	01000084 	movi	r4,2
 823eb40:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 823eb44:	e0bffa17 	ldw	r2,-24(fp)
 823eb48:	10c00117 	ldw	r3,4(r2)
 823eb4c:	e0bffa17 	ldw	r2,-24(fp)
 823eb50:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 823eb54:	e0bffa17 	ldw	r2,-24(fp)
 823eb58:	00c00c04 	movi	r3,48
 823eb5c:	10c00415 	stw	r3,16(r2)
   arppkt->net = net;
 823eb60:	e0bffa17 	ldw	r2,-24(fp)
 823eb64:	e0fffe17 	ldw	r3,-8(fp)
 823eb68:	10c00615 	stw	r3,24(r2)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 823eb6c:	e0bffa17 	ldw	r2,-24(fp)
 823eb70:	10800117 	ldw	r2,4(r2)
 823eb74:	10800084 	addi	r2,r2,2
 823eb78:	e0bffb15 	stw	r2,-20(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 823eb7c:	e0bffa17 	ldw	r2,-24(fp)
 823eb80:	10800117 	ldw	r2,4(r2)
 823eb84:	10800404 	addi	r2,r2,16
 823eb88:	e0bffc15 	stw	r2,-16(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 823eb8c:	e0bffc17 	ldw	r2,-16(fp)
 823eb90:	00c04004 	movi	r3,256
 823eb94:	10c0000d 	sth	r3,0(r2)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 823eb98:	e0bffc17 	ldw	r2,-16(fp)
 823eb9c:	00c00204 	movi	r3,8
 823eba0:	10c0008d 	sth	r3,2(r2)
   arphdr->ar_hln = 6;
 823eba4:	e0bffc17 	ldw	r2,-16(fp)
 823eba8:	00c00184 	movi	r3,6
 823ebac:	10c00105 	stb	r3,4(r2)
   arphdr->ar_pln = 4;
 823ebb0:	e0bffc17 	ldw	r2,-16(fp)
 823ebb4:	00c00104 	movi	r3,4
 823ebb8:	10c00145 	stb	r3,5(r2)
   
   /* ARP req? */
   if (flag == 0)
 823ebbc:	e0bfff17 	ldw	r2,-4(fp)
 823ebc0:	1000041e 	bne	r2,zero,823ebd4 <grat_arp+0xe8>
      /* yup */
      arphdr->ar_op = ARREQ;
 823ebc4:	e0bffc17 	ldw	r2,-16(fp)
 823ebc8:	00c04004 	movi	r3,256
 823ebcc:	10c0018d 	sth	r3,6(r2)
 823ebd0:	00000306 	br	823ebe0 <grat_arp+0xf4>
   else
     /* nope */
      arphdr->ar_op = ARREP;
 823ebd4:	e0bffc17 	ldw	r2,-16(fp)
 823ebd8:	00c08004 	movi	r3,512
 823ebdc:	10c0018d 	sth	r3,6(r2)
      
   arphdr->ar_tpa = net->n_ipaddr;        /* target's IP address */
 823ebe0:	e0bffe17 	ldw	r2,-8(fp)
 823ebe4:	10c00a17 	ldw	r3,40(r2)
 823ebe8:	e0bffc17 	ldw	r2,-16(fp)
 823ebec:	10c00715 	stw	r3,28(r2)
   arphdr->ar_spa = net->n_ipaddr;   /* my IP address */
 823ebf0:	e0bffe17 	ldw	r2,-8(fp)
 823ebf4:	10c00a17 	ldw	r3,40(r2)
 823ebf8:	e0bffc17 	ldw	r2,-16(fp)
 823ebfc:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 823ec00:	e0bffc17 	ldw	r2,-16(fp)
 823ec04:	10c00204 	addi	r3,r2,8
 823ec08:	e0bff917 	ldw	r2,-28(fp)
 823ec0c:	10800517 	ldw	r2,20(r2)
 823ec10:	01800184 	movi	r6,6
 823ec14:	100b883a 	mov	r5,r2
 823ec18:	1809883a 	mov	r4,r3
 823ec1c:	82030b40 	call	82030b4 <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 823ec20:	01800184 	movi	r6,6
 823ec24:	01403fc4 	movi	r5,255
 823ec28:	e13ffb17 	ldw	r4,-20(fp)
 823ec2c:	82032100 	call	8203210 <memset>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 823ec30:	e0bffb17 	ldw	r2,-20(fp)
 823ec34:	10c00184 	addi	r3,r2,6
 823ec38:	e0bff917 	ldw	r2,-28(fp)
 823ec3c:	10800517 	ldw	r2,20(r2)
 823ec40:	01800184 	movi	r6,6
 823ec44:	100b883a 	mov	r5,r2
 823ec48:	1809883a 	mov	r4,r3
 823ec4c:	82030b40 	call	82030b4 <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 823ec50:	e0bffb17 	ldw	r2,-20(fp)
 823ec54:	10800304 	addi	r2,r2,12
 823ec58:	00c00204 	movi	r3,8
 823ec5c:	10c00005 	stb	r3,0(r2)
 823ec60:	e0bffb17 	ldw	r2,-20(fp)
 823ec64:	10800344 	addi	r2,r2,13
 823ec68:	00c00184 	movi	r3,6
 823ec6c:	10c00005 	stb	r3,0(r2)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 823ec70:	e0bffc17 	ldw	r2,-16(fp)
 823ec74:	e0bffd15 	stw	r2,-12(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 823ec78:	e0bffd17 	ldw	r2,-12(fp)
 823ec7c:	10c00204 	addi	r3,r2,8
 823ec80:	e0bffc17 	ldw	r2,-16(fp)
 823ec84:	10800204 	addi	r2,r2,8
 823ec88:	01800184 	movi	r6,6
 823ec8c:	100b883a 	mov	r5,r2
 823ec90:	1809883a 	mov	r4,r3
 823ec94:	82030b40 	call	82030b4 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 823ec98:	e0bffd17 	ldw	r2,-12(fp)
 823ec9c:	10c00384 	addi	r3,r2,14
 823eca0:	e0bffc17 	ldw	r2,-16(fp)
 823eca4:	10800404 	addi	r2,r2,16
 823eca8:	01800104 	movi	r6,4
 823ecac:	100b883a 	mov	r5,r2
 823ecb0:	1809883a 	mov	r4,r3
 823ecb4:	82030b40 	call	82030b4 <memmove>

   /* ARP req? */
   if (flag == 0)
 823ecb8:	e0bfff17 	ldw	r2,-4(fp)
 823ecbc:	1000091e 	bne	r2,zero,823ece4 <grat_arp+0x1f8>
      /* yup */      
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 823ecc0:	e0bffd17 	ldw	r2,-12(fp)
 823ecc4:	10c00484 	addi	r3,r2,18
 823ecc8:	e0bffc17 	ldw	r2,-16(fp)
 823eccc:	10800504 	addi	r2,r2,20
 823ecd0:	01800184 	movi	r6,6
 823ecd4:	100b883a 	mov	r5,r2
 823ecd8:	1809883a 	mov	r4,r3
 823ecdc:	82030b40 	call	82030b4 <memmove>
 823ece0:	00000806 	br	823ed04 <grat_arp+0x218>
   else
      /* nope */
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_sha, 6);
 823ece4:	e0bffd17 	ldw	r2,-12(fp)
 823ece8:	10c00484 	addi	r3,r2,18
 823ecec:	e0bffc17 	ldw	r2,-16(fp)
 823ecf0:	10800204 	addi	r2,r2,8
 823ecf4:	01800184 	movi	r6,6
 823ecf8:	100b883a 	mov	r5,r2
 823ecfc:	1809883a 	mov	r4,r3
 823ed00:	82030b40 	call	82030b4 <memmove>
      
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 823ed04:	e0bffd17 	ldw	r2,-12(fp)
 823ed08:	10c00604 	addi	r3,r2,24
 823ed0c:	e0bffc17 	ldw	r2,-16(fp)
 823ed10:	10800704 	addi	r2,r2,28
 823ed14:	01800104 	movi	r6,4
 823ed18:	100b883a 	mov	r5,r2
 823ed1c:	1809883a 	mov	r4,r3
 823ed20:	82030b40 	call	82030b4 <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 823ed24:	e0bffe17 	ldw	r2,-8(fp)
 823ed28:	10800417 	ldw	r2,16(r2)
 823ed2c:	10000526 	beq	r2,zero,823ed44 <grat_arp+0x258>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 823ed30:	e0bffe17 	ldw	r2,-8(fp)
 823ed34:	10800417 	ldw	r2,16(r2)
 823ed38:	e13ffa17 	ldw	r4,-24(fp)
 823ed3c:	103ee83a 	callr	r2
 823ed40:	00000f06 	br	823ed80 <grat_arp+0x294>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 823ed44:	e0bffe17 	ldw	r2,-8(fp)
 823ed48:	10800317 	ldw	r2,12(r2)
 823ed4c:	e0fffa17 	ldw	r3,-24(fp)
 823ed50:	19000617 	ldw	r4,24(r3)
 823ed54:	e0fffa17 	ldw	r3,-24(fp)
 823ed58:	18c00117 	ldw	r3,4(r3)
 823ed5c:	01800c04 	movi	r6,48
 823ed60:	180b883a 	mov	r5,r3
 823ed64:	103ee83a 	callr	r2
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823ed68:	01000084 	movi	r4,2
 823ed6c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 823ed70:	e13ffa17 	ldw	r4,-24(fp)
 823ed74:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823ed78:	01000084 	movi	r4,2
 823ed7c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 823ed80:	d0a0c317 	ldw	r2,-31988(gp)
 823ed84:	10800044 	addi	r2,r2,1
 823ed88:	d0a0c315 	stw	r2,-31988(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 823ed8c:	00800044 	movi	r2,1
}
 823ed90:	e037883a 	mov	sp,fp
 823ed94:	dfc00117 	ldw	ra,4(sp)
 823ed98:	df000017 	ldw	fp,0(sp)
 823ed9c:	dec00204 	addi	sp,sp,8
 823eda0:	f800283a 	ret

0823eda4 <if_getbynum>:
 * RETURNS: Returns NET pointer, or NULL if out of range
 */

NET
if_getbynum(int ifnum)
{
 823eda4:	defffc04 	addi	sp,sp,-16
 823eda8:	dfc00315 	stw	ra,12(sp)
 823edac:	df000215 	stw	fp,8(sp)
 823edb0:	df000204 	addi	fp,sp,8
 823edb4:	e13fff15 	stw	r4,-4(fp)
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823edb8:	008209b4 	movhi	r2,2086
 823edbc:	10ba7e04 	addi	r2,r2,-5640
 823edc0:	10800017 	ldw	r2,0(r2)
 823edc4:	e0bffe15 	stw	r2,-8(fp)
 823edc8:	00000906 	br	823edf0 <if_getbynum+0x4c>
   {
      if(ifnum-- == 0)
 823edcc:	e0bfff17 	ldw	r2,-4(fp)
 823edd0:	10ffffc4 	addi	r3,r2,-1
 823edd4:	e0ffff15 	stw	r3,-4(fp)
 823edd8:	1000021e 	bne	r2,zero,823ede4 <if_getbynum+0x40>
         return ifp;
 823eddc:	e0bffe17 	ldw	r2,-8(fp)
 823ede0:	00000706 	br	823ee00 <if_getbynum+0x5c>

NET
if_getbynum(int ifnum)
{
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823ede4:	e0bffe17 	ldw	r2,-8(fp)
 823ede8:	10800017 	ldw	r2,0(r2)
 823edec:	e0bffe15 	stw	r2,-8(fp)
 823edf0:	e0bffe17 	ldw	r2,-8(fp)
 823edf4:	103ff51e 	bne	r2,zero,823edcc <if_getbynum+0x28>
   {
      if(ifnum-- == 0)
         return ifp;
   }
   dtrap();
 823edf8:	822d5f00 	call	822d5f0 <dtrap>
   return NULL;   /* list is not long enough */
 823edfc:	0005883a 	mov	r2,zero
}
 823ee00:	e037883a 	mov	sp,fp
 823ee04:	dfc00117 	ldw	ra,4(sp)
 823ee08:	df000017 	ldw	fp,0(sp)
 823ee0c:	dec00204 	addi	sp,sp,8
 823ee10:	f800283a 	ret

0823ee14 <isbcast>:
 * RETURNS:  Returns TRUE if broadcast, else false. 
 */

int
isbcast(NET ifc, unsigned char * addr)
{
 823ee14:	defffd04 	addi	sp,sp,-12
 823ee18:	df000215 	stw	fp,8(sp)
 823ee1c:	df000204 	addi	fp,sp,8
 823ee20:	e13ffe15 	stw	r4,-8(fp)
 823ee24:	e17fff15 	stw	r5,-4(fp)
#if (ALIGN_TYPE > 2)
   /* On systems with 32bit alignment requirements we have to make
    * sure our tests are aligned. Specifically, this results in "data
    * abort" errors on the Samsung/ARM port. 
    */
   if((u_long)addr & (ALIGN_TYPE - 1))
 823ee28:	e0bfff17 	ldw	r2,-4(fp)
 823ee2c:	108000cc 	andi	r2,r2,3
 823ee30:	10000e26 	beq	r2,zero,823ee6c <isbcast+0x58>
   {
      /* check first two bytes */
      if ((u_short)*(u_short*)(addr) != 0xFFFF)
 823ee34:	e0bfff17 	ldw	r2,-4(fp)
 823ee38:	1080000b 	ldhu	r2,0(r2)
 823ee3c:	10ffffcc 	andi	r3,r2,65535
 823ee40:	00bfffd4 	movui	r2,65535
 823ee44:	18800226 	beq	r3,r2,823ee50 <isbcast+0x3c>
         return(FALSE);
 823ee48:	0005883a 	mov	r2,zero
 823ee4c:	00002206 	br	823eed8 <isbcast+0xc4>
      if ((u_long)(*(u_long*)(addr + 2)) != 0xFFFFFFFF)
 823ee50:	e0bfff17 	ldw	r2,-4(fp)
 823ee54:	10800084 	addi	r2,r2,2
 823ee58:	10800017 	ldw	r2,0(r2)
 823ee5c:	10bfffe0 	cmpeqi	r2,r2,-1
 823ee60:	1000101e 	bne	r2,zero,823eea4 <isbcast+0x90>
         return FALSE;
 823ee64:	0005883a 	mov	r2,zero
 823ee68:	00001b06 	br	823eed8 <isbcast+0xc4>
#endif /* ALIGN_TYPE > 4 */
   {
      /* check first four bytes for all ones. Since this is the fastest
       * test, do it first
       */
      if ((u_long)(*(u_long*)addr) != 0xFFFFFFFF)
 823ee6c:	e0bfff17 	ldw	r2,-4(fp)
 823ee70:	10800017 	ldw	r2,0(r2)
 823ee74:	10bfffe0 	cmpeqi	r2,r2,-1
 823ee78:	1000021e 	bne	r2,zero,823ee84 <isbcast+0x70>
         return FALSE;
 823ee7c:	0005883a 	mov	r2,zero
 823ee80:	00001506 	br	823eed8 <isbcast+0xc4>

      /* check last two bytes */
      if ((u_short)*(u_short*)(addr+4) != 0xFFFF)
 823ee84:	e0bfff17 	ldw	r2,-4(fp)
 823ee88:	10800104 	addi	r2,r2,4
 823ee8c:	1080000b 	ldhu	r2,0(r2)
 823ee90:	10ffffcc 	andi	r3,r2,65535
 823ee94:	00bfffd4 	movui	r2,65535
 823ee98:	18800226 	beq	r3,r2,823eea4 <isbcast+0x90>
         return(FALSE);
 823ee9c:	0005883a 	mov	r2,zero
 823eea0:	00000d06 	br	823eed8 <isbcast+0xc4>
   }
   
   /* now reject any line type packets which don't support broadcast */
   if ((ifc->n_mib->ifType == PPP) ||
 823eea4:	e0bffe17 	ldw	r2,-8(fp)
 823eea8:	10802717 	ldw	r2,156(r2)
 823eeac:	10800217 	ldw	r2,8(r2)
 823eeb0:	108005e0 	cmpeqi	r2,r2,23
 823eeb4:	1000051e 	bne	r2,zero,823eecc <isbcast+0xb8>
       (ifc->n_mib->ifType == SLIP))
 823eeb8:	e0bffe17 	ldw	r2,-8(fp)
 823eebc:	10802717 	ldw	r2,156(r2)
 823eec0:	10800217 	ldw	r2,8(r2)
      if ((u_short)*(u_short*)(addr+4) != 0xFFFF)
         return(FALSE);
   }
   
   /* now reject any line type packets which don't support broadcast */
   if ((ifc->n_mib->ifType == PPP) ||
 823eec4:	10800718 	cmpnei	r2,r2,28
 823eec8:	1000021e 	bne	r2,zero,823eed4 <isbcast+0xc0>
       (ifc->n_mib->ifType == SLIP))
   {
      return FALSE;
 823eecc:	0005883a 	mov	r2,zero
 823eed0:	00000106 	br	823eed8 <isbcast+0xc4>
   }

   /* passed all tests, must be broadcast */
   return(TRUE);
 823eed4:	00800044 	movi	r2,1
}
 823eed8:	e037883a 	mov	sp,fp
 823eedc:	df000017 	ldw	fp,0(sp)
 823eee0:	dec00104 	addi	sp,sp,4
 823eee4:	f800283a 	ret

0823eee8 <reg_type>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
reg_type(unshort type)
{
 823eee8:	defffb04 	addi	sp,sp,-20
 823eeec:	dfc00415 	stw	ra,16(sp)
 823eef0:	df000315 	stw	fp,12(sp)
 823eef4:	df000304 	addi	fp,sp,12
 823eef8:	2005883a 	mov	r2,r4
 823eefc:	e0bfff0d 	sth	r2,-4(fp)
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823ef00:	008209b4 	movhi	r2,2086
 823ef04:	10ba7e04 	addi	r2,r2,-5640
 823ef08:	10800017 	ldw	r2,0(r2)
 823ef0c:	e0bffd15 	stw	r2,-12(fp)
 823ef10:	00001106 	br	823ef58 <reg_type+0x70>
   {
      if (ifp->n_reg_type)    /* make sure call exists */
 823ef14:	e0bffd17 	ldw	r2,-12(fp)
 823ef18:	10800617 	ldw	r2,24(r2)
 823ef1c:	10000b26 	beq	r2,zero,823ef4c <reg_type+0x64>
      {
         e = (ifp->n_reg_type)(type, ifp);
 823ef20:	e0bffd17 	ldw	r2,-12(fp)
 823ef24:	10800617 	ldw	r2,24(r2)
 823ef28:	e0ffff0b 	ldhu	r3,-4(fp)
 823ef2c:	e17ffd17 	ldw	r5,-12(fp)
 823ef30:	1809883a 	mov	r4,r3
 823ef34:	103ee83a 	callr	r2
 823ef38:	e0bffe15 	stw	r2,-8(fp)
         if (e)
 823ef3c:	e0bffe17 	ldw	r2,-8(fp)
 823ef40:	10000226 	beq	r2,zero,823ef4c <reg_type+0x64>
            return e;   /* bails out if error */
 823ef44:	e0bffe17 	ldw	r2,-8(fp)
 823ef48:	00000606 	br	823ef64 <reg_type+0x7c>
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823ef4c:	e0bffd17 	ldw	r2,-12(fp)
 823ef50:	10800017 	ldw	r2,0(r2)
 823ef54:	e0bffd15 	stw	r2,-12(fp)
 823ef58:	e0bffd17 	ldw	r2,-12(fp)
 823ef5c:	103fed1e 	bne	r2,zero,823ef14 <reg_type+0x2c>
         e = (ifp->n_reg_type)(type, ifp);
         if (e)
            return e;   /* bails out if error */
      }
   }
   return 0;   /* OK code */
 823ef60:	0005883a 	mov	r2,zero
}
 823ef64:	e037883a 	mov	sp,fp
 823ef68:	dfc00117 	ldw	ra,4(sp)
 823ef6c:	df000017 	ldw	fp,0(sp)
 823ef70:	dec00204 	addi	sp,sp,8
 823ef74:	f800283a 	ret

0823ef78 <if_killsocks>:
 */

      /* kill this NETs sockets */
void
if_killsocks(NET ifp)
{
 823ef78:	defffa04 	addi	sp,sp,-24
 823ef7c:	dfc00515 	stw	ra,20(sp)
 823ef80:	df000415 	stw	fp,16(sp)
 823ef84:	df000404 	addi	fp,sp,16
 823ef88:	e13fff15 	stw	r4,-4(fp)
   struct socket * so;
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
 823ef8c:	008209b4 	movhi	r2,2086
 823ef90:	10b97a04 	addi	r2,r2,-6680
 823ef94:	10800017 	ldw	r2,0(r2)
 823ef98:	e0bffc15 	stw	r2,-16(fp)
   while(so)
 823ef9c:	00001306 	br	823efec <if_killsocks+0x74>
   {
      if(so->so_pcb)
 823efa0:	e0bffc17 	ldw	r2,-16(fp)
 823efa4:	10800117 	ldw	r2,4(r2)
 823efa8:	10000526 	beq	r2,zero,823efc0 <if_killsocks+0x48>
         so_ifp = so->so_pcb->ifp;
 823efac:	e0bffc17 	ldw	r2,-16(fp)
 823efb0:	10800117 	ldw	r2,4(r2)
 823efb4:	10800a17 	ldw	r2,40(r2)
 823efb8:	e0bffd15 	stw	r2,-12(fp)
 823efbc:	00000106 	br	823efc4 <if_killsocks+0x4c>
      else
         so_ifp = NULL;
 823efc0:	e03ffd15 	stw	zero,-12(fp)
      next = (struct socket *)so->next;
 823efc4:	e0bffc17 	ldw	r2,-16(fp)
 823efc8:	10800017 	ldw	r2,0(r2)
 823efcc:	e0bffe15 	stw	r2,-8(fp)
      if (so_ifp == ifp)
 823efd0:	e0fffd17 	ldw	r3,-12(fp)
 823efd4:	e0bfff17 	ldw	r2,-4(fp)
 823efd8:	1880021e 	bne	r3,r2,823efe4 <if_killsocks+0x6c>
      {
         /* this is a direct heavy-handed close. A reset is sent
          * and all data is lost. The user should really have closed
          * all the sockets gracfully first.... 
          */
         soabort(so);
 823efdc:	e13ffc17 	ldw	r4,-16(fp)
 823efe0:	82321300 	call	8232130 <soabort>
      }
      so = next;
 823efe4:	e0bffe17 	ldw	r2,-8(fp)
 823efe8:	e0bffc15 	stw	r2,-16(fp)
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
   while(so)
 823efec:	e0bffc17 	ldw	r2,-16(fp)
 823eff0:	103feb1e 	bne	r2,zero,823efa0 <if_killsocks+0x28>
          */
         soabort(so);
      }
      so = next;
   }
}
 823eff4:	0001883a 	nop
 823eff8:	e037883a 	mov	sp,fp
 823effc:	dfc00117 	ldw	ra,4(sp)
 823f000:	df000017 	ldw	fp,0(sp)
 823f004:	dec00204 	addi	sp,sp,8
 823f008:	f800283a 	ret

0823f00c <ip_init>:
 * OK, else returns a non-zero error code. 
 */

int
ip_init(void)
{
 823f00c:	defffe04 	addi	sp,sp,-8
 823f010:	dfc00115 	stw	ra,4(sp)
 823f014:	df000015 	stw	fp,0(sp)
 823f018:	d839883a 	mov	fp,sp

   /* register IP type with link layer drivers */
   if (reg_type(IP_TYPE) != 0)
 823f01c:	01000204 	movi	r4,8
 823f020:	823eee80 	call	823eee8 <reg_type>
 823f024:	10000526 	beq	r2,zero,823f03c <ip_init+0x30>
   {   
#ifdef NPDEBUG
      dprintf("IP_INIT: unable to register type with MAC driver\n");
 823f028:	01020974 	movhi	r4,2085
 823f02c:	21047f04 	addi	r4,r4,4604
 823f030:	82036800 	call	8203680 <puts>
#endif
      return(1);
 823f034:	00800044 	movi	r2,1
 823f038:	00002906 	br	823f0e0 <ip_init+0xd4>
   }

   /* initialize the IP mib */
   MEMSET(&ip_mib, 0, sizeof(ip_mib));
 823f03c:	01801404 	movi	r6,80
 823f040:	000b883a 	mov	r5,zero
 823f044:	010209b4 	movhi	r4,2086
 823f048:	213a8304 	addi	r4,r4,-5620
 823f04c:	82032100 	call	8203210 <memset>
   ip_mib.ipForwarding = 2;   /* default to host, not gateway (router) */
 823f050:	008209b4 	movhi	r2,2086
 823f054:	10ba8304 	addi	r2,r2,-5620
 823f058:	00c00084 	movi	r3,2
 823f05c:	10c00015 	stw	r3,0(r2)
   ip_mib.ipDefaultTTL = IP_TTL;
 823f060:	008209b4 	movhi	r2,2086
 823f064:	10ba8304 	addi	r2,r2,-5620
 823f068:	00c01004 	movi	r3,64
 823f06c:	10c00115 	stw	r3,4(r2)

#ifdef IP_ROUTING
   /* alloc space for the route table */
   rt_mib = (struct RtMib*)RT_ALLOC(ipRoutes * sizeof(struct RtMib));
 823f070:	d0a05117 	ldw	r2,-32444(gp)
 823f074:	10800f24 	muli	r2,r2,60
 823f078:	1009883a 	mov	r4,r2
 823f07c:	822e1c80 	call	822e1c8 <npalloc>
 823f080:	d0a0c615 	stw	r2,-31976(gp)
   if (!rt_mib)
 823f084:	d0a0c617 	ldw	r2,-31976(gp)
 823f088:	1000051e 	bne	r2,zero,823f0a0 <ip_init+0x94>
   {
#ifdef NPDEBUG
      dprintf("IP_INIT ERROR: can't alloc route table\n");
 823f08c:	01020974 	movhi	r4,2085
 823f090:	21048c04 	addi	r4,r4,4656
 823f094:	82036800 	call	8203680 <puts>
#endif   /* NPDEBUG */
      return(ENP_NOMEM);
 823f098:	00bffb04 	movi	r2,-20
 823f09c:	00001006 	br	823f0e0 <ip_init+0xd4>
   }

  MEMSET(rt_mib,0, ipRoutes * sizeof(struct RtMib)) ;
 823f0a0:	d0e0c617 	ldw	r3,-31976(gp)
 823f0a4:	d0a05117 	ldw	r2,-32444(gp)
 823f0a8:	10800f24 	muli	r2,r2,60
 823f0ac:	100d883a 	mov	r6,r2
 823f0b0:	000b883a 	mov	r5,zero
 823f0b4:	1809883a 	mov	r4,r3
 823f0b8:	82032100 	call	8203210 <memset>
  ip_mib.ipForwarding = 1;   /* override default, be gateway (router) */
 823f0bc:	008209b4 	movhi	r2,2086
 823f0c0:	10ba8304 	addi	r2,r2,-5620
 823f0c4:	00c00044 	movi	r3,1
 823f0c8:	10c00015 	stw	r3,0(r2)
#endif   /* IP_ROUTING */

   /* set IP reassembly timeout */
   ip_mib.ipReasmTimeout = IRE_TMO;
 823f0cc:	008209b4 	movhi	r2,2086
 823f0d0:	10ba8304 	addi	r2,r2,-5620
 823f0d4:	00c01e04 	movi	r3,120
 823f0d8:	10c00c15 	stw	r3,48(r2)
      return(1);
   }
#endif   /* IPSEC */

   /* everything opened OK return 0 */
   return(SUCCESS);
 823f0dc:	0005883a 	mov	r2,zero
}
 823f0e0:	e037883a 	mov	sp,fp
 823f0e4:	dfc00117 	ldw	ra,4(sp)
 823f0e8:	df000017 	ldw	fp,0(sp)
 823f0ec:	dec00204 	addi	sp,sp,8
 823f0f0:	f800283a 	ret

0823f0f4 <ip_bldhead>:
 * RETURNS: void
 */

void
ip_bldhead(PACKET p, unsigned pid, u_char prot, unshort fragword)
{
 823f0f4:	defff804 	addi	sp,sp,-32
 823f0f8:	dfc00715 	stw	ra,28(sp)
 823f0fc:	df000615 	stw	fp,24(sp)
 823f100:	df000604 	addi	fp,sp,24
 823f104:	e13ffc15 	stw	r4,-16(fp)
 823f108:	e17ffd15 	stw	r5,-12(fp)
 823f10c:	3007883a 	mov	r3,r6
 823f110:	3805883a 	mov	r2,r7
 823f114:	e0fffe05 	stb	r3,-8(fp)
 823f118:	e0bfff0d 	sth	r2,-4(fp)
   struct ip * pip;
   struct ip_socopts *sopts;

   /* prepend IP header to packet data */
   p->nb_prot -= sizeof(struct ip);       /* this assumes no send options! */
 823f11c:	e0bffc17 	ldw	r2,-16(fp)
 823f120:	10800317 	ldw	r2,12(r2)
 823f124:	10fffb04 	addi	r3,r2,-20
 823f128:	e0bffc17 	ldw	r2,-16(fp)
 823f12c:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 823f130:	e0bffc17 	ldw	r2,-16(fp)
 823f134:	10800417 	ldw	r2,16(r2)
 823f138:	10c00504 	addi	r3,r2,20
 823f13c:	e0bffc17 	ldw	r2,-16(fp)
 823f140:	10c00415 	stw	r3,16(r2)

   pip = (struct ip*)p->nb_prot;
 823f144:	e0bffc17 	ldw	r2,-16(fp)
 823f148:	10800317 	ldw	r2,12(r2)
 823f14c:	e0bffa15 	stw	r2,-24(fp)

   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 823f150:	e0bffa17 	ldw	r2,-24(fp)
 823f154:	00c01144 	movi	r3,69
 823f158:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = fragword; /* fragment flags and offset */
 823f15c:	e0bffa17 	ldw	r2,-24(fp)
 823f160:	e0ffff0b 	ldhu	r3,-4(fp)
 823f164:	10c0018d 	sth	r3,6(r2)
   pip->ip_id = htons((unshort)pid);   /* IP datagram ID */
 823f168:	e0bffd17 	ldw	r2,-12(fp)
 823f16c:	10bfffcc 	andi	r2,r2,65535
 823f170:	1005d23a 	srai	r2,r2,8
 823f174:	10803fcc 	andi	r2,r2,255
 823f178:	1007883a 	mov	r3,r2
 823f17c:	e0bffd17 	ldw	r2,-12(fp)
 823f180:	10bfffcc 	andi	r2,r2,65535
 823f184:	1004923a 	slli	r2,r2,8
 823f188:	1884b03a 	or	r2,r3,r2
 823f18c:	1007883a 	mov	r3,r2
 823f190:	e0bffa17 	ldw	r2,-24(fp)
 823f194:	10c0010d 	sth	r3,4(r2)
   pip->ip_len = htons((unshort)p->nb_plen);
 823f198:	e0bffc17 	ldw	r2,-16(fp)
 823f19c:	10800417 	ldw	r2,16(r2)
 823f1a0:	10bfffcc 	andi	r2,r2,65535
 823f1a4:	1005d23a 	srai	r2,r2,8
 823f1a8:	10803fcc 	andi	r2,r2,255
 823f1ac:	1007883a 	mov	r3,r2
 823f1b0:	e0bffc17 	ldw	r2,-16(fp)
 823f1b4:	10800417 	ldw	r2,16(r2)
 823f1b8:	10bfffcc 	andi	r2,r2,65535
 823f1bc:	1004923a 	slli	r2,r2,8
 823f1c0:	1884b03a 	or	r2,r3,r2
 823f1c4:	1007883a 	mov	r3,r2
 823f1c8:	e0bffa17 	ldw	r2,-24(fp)
 823f1cc:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;          /* install protocol ID (TCP, UDP, etc) */
 823f1d0:	e0bffa17 	ldw	r2,-24(fp)
 823f1d4:	e0fffe03 	ldbu	r3,-8(fp)
 823f1d8:	10c00245 	stb	r3,9(r2)

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 823f1dc:	e0bffc17 	ldw	r2,-16(fp)
 823f1e0:	10800c17 	ldw	r2,48(r2)
 823f1e4:	e0bffb15 	stw	r2,-20(fp)
 823f1e8:	e0bffb17 	ldw	r2,-20(fp)
 823f1ec:	10001126 	beq	r2,zero,823f234 <ip_bldhead+0x140>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 823f1f0:	e0bffb17 	ldw	r2,-20(fp)
 823f1f4:	10800043 	ldbu	r2,1(r2)
 823f1f8:	10803fcc 	andi	r2,r2,255
 823f1fc:	10000526 	beq	r2,zero,823f214 <ip_bldhead+0x120>
         pip->ip_time = sopts->ip_ttl;
 823f200:	e0bffb17 	ldw	r2,-20(fp)
 823f204:	10c00043 	ldbu	r3,1(r2)
 823f208:	e0bffa17 	ldw	r2,-24(fp)
 823f20c:	10c00205 	stb	r3,8(r2)
 823f210:	00000306 	br	823f220 <ip_bldhead+0x12c>
	  else
         pip->ip_time = (u_char)IP_TTL;     /* default number of hops, really */
 823f214:	e0bffa17 	ldw	r2,-24(fp)
 823f218:	00c01004 	movi	r3,64
 823f21c:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = sopts->ip_tos;
 823f220:	e0bffb17 	ldw	r2,-20(fp)
 823f224:	10c00003 	ldbu	r3,0(r2)
 823f228:	e0bffa17 	ldw	r2,-24(fp)
 823f22c:	10c00045 	stb	r3,1(r2)
 823f230:	00000506 	br	823f248 <ip_bldhead+0x154>
   }
   else
   {
	  /* nope */
      pip->ip_time = (u_char)IP_TTL;       /* default number of hops, really */
 823f234:	e0bffa17 	ldw	r2,-24(fp)
 823f238:	00c01004 	movi	r3,64
 823f23c:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 823f240:	e0bffa17 	ldw	r2,-24(fp)
 823f244:	10000045 	stb	zero,1(r2)
   }
   
   pip->ip_chksum = IPXSUM;      /* clear checksum field for summing */
 823f248:	e0bffa17 	ldw	r2,-24(fp)
 823f24c:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 823f250:	01400284 	movi	r5,10
 823f254:	e13ffa17 	ldw	r4,-24(fp)
 823f258:	82288100 	call	8228810 <cksum>
 823f25c:	0084303a 	nor	r2,zero,r2
 823f260:	1007883a 	mov	r3,r2
 823f264:	e0bffa17 	ldw	r2,-24(fp)
 823f268:	10c0028d 	sth	r3,10(r2)
}
 823f26c:	0001883a 	nop
 823f270:	e037883a 	mov	sp,fp
 823f274:	dfc00117 	ldw	ra,4(sp)
 823f278:	df000017 	ldw	fp,0(sp)
 823f27c:	dec00204 	addi	sp,sp,8
 823f280:	f800283a 	ret

0823f284 <ip_write_internal>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_write_internal(PACKET p)
{
 823f284:	defff004 	addi	sp,sp,-64
 823f288:	dfc00f15 	stw	ra,60(sp)
 823f28c:	df000e15 	stw	fp,56(sp)
 823f290:	df000e04 	addi	fp,sp,56
 823f294:	e13fff15 	stw	r4,-4(fp)
   PACKET newpkt;
   unsigned maxbuflen;

#ifdef IP_MULTICAST
   /* If destination address is multicast, process multicast options */
   if (IN_MULTICAST(ntohl(p->fhost)))
 823f298:	e0bfff17 	ldw	r2,-4(fp)
 823f29c:	10800717 	ldw	r2,28(r2)
 823f2a0:	1006d63a 	srli	r3,r2,24
 823f2a4:	e0bfff17 	ldw	r2,-4(fp)
 823f2a8:	10800717 	ldw	r2,28(r2)
 823f2ac:	1004d23a 	srli	r2,r2,8
 823f2b0:	10bfc00c 	andi	r2,r2,65280
 823f2b4:	1886b03a 	or	r3,r3,r2
 823f2b8:	e0bfff17 	ldw	r2,-4(fp)
 823f2bc:	10800717 	ldw	r2,28(r2)
 823f2c0:	10bfc00c 	andi	r2,r2,65280
 823f2c4:	1004923a 	slli	r2,r2,8
 823f2c8:	1886b03a 	or	r3,r3,r2
 823f2cc:	e0bfff17 	ldw	r2,-4(fp)
 823f2d0:	10800717 	ldw	r2,28(r2)
 823f2d4:	1004963a 	slli	r2,r2,24
 823f2d8:	1884b03a 	or	r2,r3,r2
 823f2dc:	10fc002c 	andhi	r3,r2,61440
 823f2e0:	00b80034 	movhi	r2,57344
 823f2e4:	1880a81e 	bne	r3,r2,823f588 <ip_write_internal+0x304>
   {
      if (p->imo != NULL)
 823f2e8:	e0bfff17 	ldw	r2,-4(fp)
 823f2ec:	10800b17 	ldw	r2,44(r2)
 823f2f0:	10001426 	beq	r2,zero,823f344 <ip_write_internal+0xc0>
         if (p->imo->imo_multicast_netp)
 823f2f4:	e0bfff17 	ldw	r2,-4(fp)
 823f2f8:	10800b17 	ldw	r2,44(r2)
 823f2fc:	10800017 	ldw	r2,0(r2)
 823f300:	10000626 	beq	r2,zero,823f31c <ip_write_internal+0x98>
            p->net = p->imo->imo_multicast_netp;
 823f304:	e0bfff17 	ldw	r2,-4(fp)
 823f308:	10800b17 	ldw	r2,44(r2)
 823f30c:	10c00017 	ldw	r3,0(r2)
 823f310:	e0bfff17 	ldw	r2,-4(fp)
 823f314:	10c00615 	stw	r3,24(r2)
 823f318:	00002506 	br	823f3b0 <ip_write_internal+0x12c>
         else
            p->net = iproute(p->fhost, &firsthop);
 823f31c:	e0bfff17 	ldw	r2,-4(fp)
 823f320:	10800717 	ldw	r2,28(r2)
 823f324:	e0fffe04 	addi	r3,fp,-8
 823f328:	180b883a 	mov	r5,r3
 823f32c:	1009883a 	mov	r4,r2
 823f330:	8240d440 	call	8240d44 <iproute>
 823f334:	1007883a 	mov	r3,r2
 823f338:	e0bfff17 	ldw	r2,-4(fp)
 823f33c:	10c00615 	stw	r3,24(r2)
 823f340:	00001b06 	br	823f3b0 <ip_write_internal+0x12c>
      else
      {
         for (i = 0; i < ifNumber; i++)
 823f344:	e03ff515 	stw	zero,-44(fp)
 823f348:	00001606 	br	823f3a4 <ip_write_internal+0x120>
            if (nets[i]->n_mcastlist)
 823f34c:	008209b4 	movhi	r2,2086
 823f350:	10b83d04 	addi	r2,r2,-7948
 823f354:	e0fff517 	ldw	r3,-44(fp)
 823f358:	18c7883a 	add	r3,r3,r3
 823f35c:	18c7883a 	add	r3,r3,r3
 823f360:	10c5883a 	add	r2,r2,r3
 823f364:	10800017 	ldw	r2,0(r2)
 823f368:	10802b17 	ldw	r2,172(r2)
 823f36c:	10000a26 	beq	r2,zero,823f398 <ip_write_internal+0x114>
            {
               p->net = nets[i];
 823f370:	008209b4 	movhi	r2,2086
 823f374:	10b83d04 	addi	r2,r2,-7948
 823f378:	e0fff517 	ldw	r3,-44(fp)
 823f37c:	18c7883a 	add	r3,r3,r3
 823f380:	18c7883a 	add	r3,r3,r3
 823f384:	10c5883a 	add	r2,r2,r3
 823f388:	10c00017 	ldw	r3,0(r2)
 823f38c:	e0bfff17 	ldw	r2,-4(fp)
 823f390:	10c00615 	stw	r3,24(r2)
               break;
 823f394:	00000606 	br	823f3b0 <ip_write_internal+0x12c>
            p->net = p->imo->imo_multicast_netp;
         else
            p->net = iproute(p->fhost, &firsthop);
      else
      {
         for (i = 0; i < ifNumber; i++)
 823f398:	e0bff517 	ldw	r2,-44(fp)
 823f39c:	10800044 	addi	r2,r2,1
 823f3a0:	e0bff515 	stw	r2,-44(fp)
 823f3a4:	d0a08417 	ldw	r2,-32240(gp)
 823f3a8:	e0fff517 	ldw	r3,-44(fp)
 823f3ac:	18bfe736 	bltu	r3,r2,823f34c <ip_write_internal+0xc8>
               break;
            }
      }

      /* Confirm that the outgoing interface supports multicast. */
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
 823f3b0:	e0bfff17 	ldw	r2,-4(fp)
 823f3b4:	10800617 	ldw	r2,24(r2)
 823f3b8:	10000426 	beq	r2,zero,823f3cc <ip_write_internal+0x148>
 823f3bc:	e0bfff17 	ldw	r2,-4(fp)
 823f3c0:	10800617 	ldw	r2,24(r2)
 823f3c4:	10802b17 	ldw	r2,172(r2)
 823f3c8:	10002c1e 	bne	r2,zero,823f47c <ip_write_internal+0x1f8>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 823f3cc:	d0a08317 	ldw	r2,-32244(gp)
 823f3d0:	1080840c 	andi	r2,r2,528
 823f3d4:	10001a26 	beq	r2,zero,823f440 <ip_write_internal+0x1bc>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f3d8:	e0bfff17 	ldw	r2,-4(fp)
 823f3dc:	11400417 	ldw	r5,16(r2)
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f3e0:	e0bfff17 	ldw	r2,-4(fp)
 823f3e4:	10800717 	ldw	r2,28(r2)
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f3e8:	11803fcc 	andi	r6,r2,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f3ec:	e0bfff17 	ldw	r2,-4(fp)
 823f3f0:	10800717 	ldw	r2,28(r2)
 823f3f4:	1004d23a 	srli	r2,r2,8
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f3f8:	10803fcc 	andi	r2,r2,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f3fc:	e0ffff17 	ldw	r3,-4(fp)
 823f400:	18c00717 	ldw	r3,28(r3)
 823f404:	1806d43a 	srli	r3,r3,16
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f408:	18c03fcc 	andi	r3,r3,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f40c:	e13fff17 	ldw	r4,-4(fp)
 823f410:	21000717 	ldw	r4,28(r4)
 823f414:	2008d63a 	srli	r4,r4,24
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f418:	d9000215 	stw	r4,8(sp)
 823f41c:	d8c00115 	stw	r3,4(sp)
 823f420:	d8800015 	stw	r2,0(sp)
 823f424:	300f883a 	mov	r7,r6
 823f428:	280d883a 	mov	r6,r5
 823f42c:	e17fff17 	ldw	r5,-4(fp)
 823f430:	01020974 	movhi	r4,2085
 823f434:	21049604 	addi	r4,r4,4696
 823f438:	82033fc0 	call	82033fc <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 823f43c:	822d5f00 	call	822d5f0 <dtrap>
         }
#endif
         ip_mib.ipOutNoRoutes++;
 823f440:	008209b4 	movhi	r2,2086
 823f444:	10ba8304 	addi	r2,r2,-5620
 823f448:	10800b17 	ldw	r2,44(r2)
 823f44c:	10c00044 	addi	r3,r2,1
 823f450:	008209b4 	movhi	r2,2086
 823f454:	10ba8304 	addi	r2,r2,-5620
 823f458:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f45c:	01000084 	movi	r4,2
 823f460:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
         pk_free(p);
 823f464:	e13fff17 	ldw	r4,-4(fp)
 823f468:	822cd980 	call	822cd98 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f46c:	01000084 	movi	r4,2
 823f470:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 823f474:	00bff7c4 	movi	r2,-33
 823f478:	00014606 	br	823f994 <ip_write_internal+0x710>
       * If we belong to the destination multicast group
       * on the outgoing interface, and the caller did not
       * forbid loopback, put a copy of the packet on the
       * received queue.
       */
      inm = lookup_mcast(p->fhost, p->net);
 823f47c:	e0bfff17 	ldw	r2,-4(fp)
 823f480:	10c00717 	ldw	r3,28(r2)
 823f484:	e0bfff17 	ldw	r2,-4(fp)
 823f488:	10800617 	ldw	r2,24(r2)
 823f48c:	100b883a 	mov	r5,r2
 823f490:	1809883a 	mov	r4,r3
 823f494:	8243c040 	call	8243c04 <lookup_mcast>
 823f498:	e0bff715 	stw	r2,-36(fp)
      if ((inm != NULL) &&
 823f49c:	e0bff717 	ldw	r2,-36(fp)
 823f4a0:	10001b26 	beq	r2,zero,823f510 <ip_write_internal+0x28c>
          ((p->imo == NULL) || p->imo->imo_multicast_loop)) 
 823f4a4:	e0bfff17 	ldw	r2,-4(fp)
 823f4a8:	10800b17 	ldw	r2,44(r2)
       * on the outgoing interface, and the caller did not
       * forbid loopback, put a copy of the packet on the
       * received queue.
       */
      inm = lookup_mcast(p->fhost, p->net);
      if ((inm != NULL) &&
 823f4ac:	10000526 	beq	r2,zero,823f4c4 <ip_write_internal+0x240>
          ((p->imo == NULL) || p->imo->imo_multicast_loop)) 
 823f4b0:	e0bfff17 	ldw	r2,-4(fp)
 823f4b4:	10800b17 	ldw	r2,44(r2)
 823f4b8:	10800143 	ldbu	r2,5(r2)
 823f4bc:	10803fcc 	andi	r2,r2,255
 823f4c0:	10001326 	beq	r2,zero,823f510 <ip_write_internal+0x28c>
      {
         p->type = IPTP;
 823f4c4:	e0bfff17 	ldw	r2,-4(fp)
 823f4c8:	00c00204 	movi	r3,8
 823f4cc:	10c0080d 	sth	r3,32(r2)
         pkt2 = ip_copypkt(p);
 823f4d0:	e13fff17 	ldw	r4,-4(fp)
 823f4d4:	8240f1c0 	call	8240f1c <ip_copypkt>
 823f4d8:	e0bff815 	stw	r2,-32(fp)
         if (pkt2)
 823f4dc:	e0bff817 	ldw	r2,-32(fp)
 823f4e0:	10000b26 	beq	r2,zero,823f510 <ip_write_internal+0x28c>
         {
            LOCK_NET_RESOURCE(RXQ_RESID);
 823f4e4:	01000044 	movi	r4,1
 823f4e8:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
            putq(&rcvdq, (q_elt)pkt2);
 823f4ec:	e17ff817 	ldw	r5,-32(fp)
 823f4f0:	010209b4 	movhi	r4,2086
 823f4f4:	21377804 	addi	r4,r4,-8736
 823f4f8:	822cfd80 	call	822cfd8 <putq>
            UNLOCK_NET_RESOURCE(RXQ_RESID);
 823f4fc:	01000044 	movi	r4,1
 823f500:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
            SignalPktDemux();
 823f504:	d0a0ab17 	ldw	r2,-32084(gp)
 823f508:	1009883a 	mov	r4,r2
 823f50c:	821a4a80 	call	821a4a8 <OSSemPost>
       * Also, multicasts addressed to the loopback interface
       * are not sent -- a copy will already have been looped
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
 823f510:	e0bfff17 	ldw	r2,-4(fp)
 823f514:	10800317 	ldw	r2,12(r2)
 823f518:	e0bff915 	stw	r2,-28(fp)
      if ((pip->ip_time == 0) || 
 823f51c:	e0bff917 	ldw	r2,-28(fp)
 823f520:	10800203 	ldbu	r2,8(r2)
 823f524:	10803fcc 	andi	r2,r2,255
 823f528:	10000b26 	beq	r2,zero,823f558 <ip_write_internal+0x2d4>
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
 823f52c:	e0bfff17 	ldw	r2,-4(fp)
 823f530:	10800717 	ldw	r2,28(r2)
 823f534:	10803fcc 	andi	r2,r2,255
       * are not sent -- a copy will already have been looped
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
      if ((pip->ip_time == 0) || 
 823f538:	10801fe0 	cmpeqi	r2,r2,127
 823f53c:	1000061e 	bne	r2,zero,823f558 <ip_write_internal+0x2d4>
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
          (p->fhost == p->net->n_ipaddr))
 823f540:	e0bfff17 	ldw	r2,-4(fp)
 823f544:	10c00717 	ldw	r3,28(r2)
 823f548:	e0bfff17 	ldw	r2,-4(fp)
 823f54c:	10800617 	ldw	r2,24(r2)
 823f550:	10800a17 	ldw	r2,40(r2)
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
      if ((pip->ip_time == 0) || 
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
 823f554:	1880081e 	bne	r3,r2,823f578 <ip_write_internal+0x2f4>
          (p->fhost == p->net->n_ipaddr))
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f558:	01000084 	movi	r4,2
 823f55c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
         pk_free(p);
 823f560:	e13fff17 	ldw	r4,-4(fp)
 823f564:	822cd980 	call	822cd98 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f568:	01000084 	movi	r4,2
 823f56c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return(SUCCESS);
 823f570:	0005883a 	mov	r2,zero
 823f574:	00010706 	br	823f994 <ip_write_internal+0x710>
      }

      firsthop = p->fhost;
 823f578:	e0bfff17 	ldw	r2,-4(fp)
 823f57c:	10800717 	ldw	r2,28(r2)
 823f580:	e0bffe15 	stw	r2,-8(fp)

      goto sendit;
 823f584:	00004006 	br	823f688 <ip_write_internal+0x404>
   }

#endif /* IP_MULTICAST */

   /* if this is a broadcast packet, use the caller-selected network */
   if (p->fhost == 0xFFFFFFFF)
 823f588:	e0bfff17 	ldw	r2,-4(fp)
 823f58c:	10800717 	ldw	r2,28(r2)
 823f590:	10bfffd8 	cmpnei	r2,r2,-1
 823f594:	1000041e 	bne	r2,zero,823f5a8 <ip_write_internal+0x324>
   {
      firsthop = p->fhost;
 823f598:	e0bfff17 	ldw	r2,-4(fp)
 823f59c:	10800717 	ldw	r2,28(r2)
 823f5a0:	e0bffe15 	stw	r2,-8(fp)
 823f5a4:	00003806 	br	823f688 <ip_write_internal+0x404>
   }
   else
   {
      p->net = iproute(p->fhost, &firsthop);
 823f5a8:	e0bfff17 	ldw	r2,-4(fp)
 823f5ac:	10800717 	ldw	r2,28(r2)
 823f5b0:	e0fffe04 	addi	r3,fp,-8
 823f5b4:	180b883a 	mov	r5,r3
 823f5b8:	1009883a 	mov	r4,r2
 823f5bc:	8240d440 	call	8240d44 <iproute>
 823f5c0:	1007883a 	mov	r3,r2
 823f5c4:	e0bfff17 	ldw	r2,-4(fp)
 823f5c8:	10c00615 	stw	r3,24(r2)
      if (p->net == NULL)
 823f5cc:	e0bfff17 	ldw	r2,-4(fp)
 823f5d0:	10800617 	ldw	r2,24(r2)
 823f5d4:	10002c1e 	bne	r2,zero,823f688 <ip_write_internal+0x404>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 823f5d8:	d0a08317 	ldw	r2,-32244(gp)
 823f5dc:	1080840c 	andi	r2,r2,528
 823f5e0:	10001a26 	beq	r2,zero,823f64c <ip_write_internal+0x3c8>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f5e4:	e0bfff17 	ldw	r2,-4(fp)
 823f5e8:	11400417 	ldw	r5,16(r2)
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f5ec:	e0bfff17 	ldw	r2,-4(fp)
 823f5f0:	10800717 	ldw	r2,28(r2)
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f5f4:	11803fcc 	andi	r6,r2,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f5f8:	e0bfff17 	ldw	r2,-4(fp)
 823f5fc:	10800717 	ldw	r2,28(r2)
 823f600:	1004d23a 	srli	r2,r2,8
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f604:	10803fcc 	andi	r2,r2,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f608:	e0ffff17 	ldw	r3,-4(fp)
 823f60c:	18c00717 	ldw	r3,28(r3)
 823f610:	1806d43a 	srli	r3,r3,16
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f614:	18c03fcc 	andi	r3,r3,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f618:	e13fff17 	ldw	r4,-4(fp)
 823f61c:	21000717 	ldw	r4,28(r4)
 823f620:	2008d63a 	srli	r4,r4,24
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f624:	d9000215 	stw	r4,8(sp)
 823f628:	d8c00115 	stw	r3,4(sp)
 823f62c:	d8800015 	stw	r2,0(sp)
 823f630:	300f883a 	mov	r7,r6
 823f634:	280d883a 	mov	r6,r5
 823f638:	e17fff17 	ldw	r5,-4(fp)
 823f63c:	01020974 	movhi	r4,2085
 823f640:	21049604 	addi	r4,r4,4696
 823f644:	82033fc0 	call	82033fc <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 823f648:	822d5f00 	call	822d5f0 <dtrap>
         }
#endif   /* NPDEBUG */
         ip_mib.ipOutNoRoutes++;
 823f64c:	008209b4 	movhi	r2,2086
 823f650:	10ba8304 	addi	r2,r2,-5620
 823f654:	10800b17 	ldw	r2,44(r2)
 823f658:	10c00044 	addi	r3,r2,1
 823f65c:	008209b4 	movhi	r2,2086
 823f660:	10ba8304 	addi	r2,r2,-5620
 823f664:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f668:	01000084 	movi	r4,2
 823f66c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
         pk_free(p);
 823f670:	e13fff17 	ldw	r4,-4(fp)
 823f674:	822cd980 	call	822cd98 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f678:	01000084 	movi	r4,2
 823f67c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 823f680:	00bff7c4 	movi	r2,-33
 823f684:	0000c306 	br	823f994 <ip_write_internal+0x710>
#ifdef   IP_MULTICAST
sendit:  /* label used for multicast packets to skip routing logic */
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
 823f688:	d0a08317 	ldw	r2,-32244(gp)
 823f68c:	1080800c 	andi	r2,r2,512
 823f690:	10002926 	beq	r2,zero,823f738 <ip_write_internal+0x4b4>
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f694:	e0bfff17 	ldw	r2,-4(fp)
 823f698:	11000417 	ldw	r4,16(r2)
       p->nb_plen, PUSH_IPADDR(p->fhost));
 823f69c:	e0bfff17 	ldw	r2,-4(fp)
 823f6a0:	10800717 	ldw	r2,28(r2)
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f6a4:	11403fcc 	andi	r5,r2,255
       p->nb_plen, PUSH_IPADDR(p->fhost));
 823f6a8:	e0bfff17 	ldw	r2,-4(fp)
 823f6ac:	10800717 	ldw	r2,28(r2)
 823f6b0:	1004d23a 	srli	r2,r2,8
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f6b4:	11803fcc 	andi	r6,r2,255
       p->nb_plen, PUSH_IPADDR(p->fhost));
 823f6b8:	e0bfff17 	ldw	r2,-4(fp)
 823f6bc:	10800717 	ldw	r2,28(r2)
 823f6c0:	1004d43a 	srli	r2,r2,16
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f6c4:	10803fcc 	andi	r2,r2,255
       p->nb_plen, PUSH_IPADDR(p->fhost));
 823f6c8:	e0ffff17 	ldw	r3,-4(fp)
 823f6cc:	18c00717 	ldw	r3,28(r3)
 823f6d0:	1806d63a 	srli	r3,r3,24
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f6d4:	d8c00115 	stw	r3,4(sp)
 823f6d8:	d8800015 	stw	r2,0(sp)
 823f6dc:	300f883a 	mov	r7,r6
 823f6e0:	280d883a 	mov	r6,r5
 823f6e4:	200b883a 	mov	r5,r4
 823f6e8:	01020974 	movhi	r4,2085
 823f6ec:	2104a604 	addi	r4,r4,4760
 823f6f0:	82033fc0 	call	82033fc <printf>
       p->nb_plen, PUSH_IPADDR(p->fhost));
      dprintf(" route %u.%u.%u.%u\n", PUSH_IPADDR(firsthop));
 823f6f4:	e0bffe17 	ldw	r2,-8(fp)
 823f6f8:	10c03fcc 	andi	r3,r2,255
 823f6fc:	e0bffe17 	ldw	r2,-8(fp)
 823f700:	1004d23a 	srli	r2,r2,8
 823f704:	11003fcc 	andi	r4,r2,255
 823f708:	e0bffe17 	ldw	r2,-8(fp)
 823f70c:	1004d43a 	srli	r2,r2,16
 823f710:	11403fcc 	andi	r5,r2,255
 823f714:	e0bffe17 	ldw	r2,-8(fp)
 823f718:	1004d63a 	srli	r2,r2,24
 823f71c:	d8800015 	stw	r2,0(sp)
 823f720:	280f883a 	mov	r7,r5
 823f724:	200d883a 	mov	r6,r4
 823f728:	180b883a 	mov	r5,r3
 823f72c:	01020974 	movhi	r4,2085
 823f730:	2104af04 	addi	r4,r4,4796
 823f734:	82033fc0 	call	82033fc <printf>
#endif   /* IPSEC */

   /* If the packet is being sent to the same interface it will be sent
    * from, short-cut things and just put it on the received queue.
    */
   if ((p->net->n_ipaddr == p->fhost) &&
 823f738:	e0bfff17 	ldw	r2,-4(fp)
 823f73c:	10800617 	ldw	r2,24(r2)
 823f740:	10c00a17 	ldw	r3,40(r2)
 823f744:	e0bfff17 	ldw	r2,-4(fp)
 823f748:	10800717 	ldw	r2,28(r2)
 823f74c:	1880271e 	bne	r3,r2,823f7ec <ip_write_internal+0x568>
       ((p->fhost & htonl(0xff000000)) != htonl(0x7f000000)))
 823f750:	e0bfff17 	ldw	r2,-4(fp)
 823f754:	10800717 	ldw	r2,28(r2)
 823f758:	10803fcc 	andi	r2,r2,255
#endif   /* IPSEC */

   /* If the packet is being sent to the same interface it will be sent
    * from, short-cut things and just put it on the received queue.
    */
   if ((p->net->n_ipaddr == p->fhost) &&
 823f75c:	10801fe0 	cmpeqi	r2,r2,127
 823f760:	1000221e 	bne	r2,zero,823f7ec <ip_write_internal+0x568>
       ((p->fhost & htonl(0xff000000)) != htonl(0x7f000000)))
   {
      if (!(p->net->n_flags & NF_NBPROT))
 823f764:	e0bfff17 	ldw	r2,-4(fp)
 823f768:	10800617 	ldw	r2,24(r2)
 823f76c:	10802a17 	ldw	r2,168(r2)
 823f770:	1080020c 	andi	r2,r2,8
 823f774:	1000091e 	bne	r2,zero,823f79c <ip_write_internal+0x518>
          * IP or ARP protocol header) and nb_type to the protocol
          * type, and set the NF_NBPROT flag in its interfaces'
          * n_flags fields.
          */
#ifdef NPDEBUG
         dtrap();
 823f778:	822d5f00 	call	822d5f0 <dtrap>
#endif
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f77c:	01000084 	movi	r4,2
 823f780:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
         pk_free(p);
 823f784:	e13fff17 	ldw	r4,-4(fp)
 823f788:	822cd980 	call	822cd98 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f78c:	01000084 	movi	r4,2
 823f790:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_LOGIC;
 823f794:	00bffd44 	movi	r2,-11
 823f798:	00007e06 	br	823f994 <ip_write_internal+0x710>
      }
      p->type = IPTP;
 823f79c:	e0bfff17 	ldw	r2,-4(fp)
 823f7a0:	00c00204 	movi	r3,8
 823f7a4:	10c0080d 	sth	r3,32(r2)
      UNLOCK_NET_RESOURCE(NET_RESID);
 823f7a8:	0009883a 	mov	r4,zero
 823f7ac:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(RXQ_RESID);
 823f7b0:	01000044 	movi	r4,1
 823f7b4:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      putq(&rcvdq, (q_elt)p);
 823f7b8:	e17fff17 	ldw	r5,-4(fp)
 823f7bc:	010209b4 	movhi	r4,2086
 823f7c0:	21377804 	addi	r4,r4,-8736
 823f7c4:	822cfd80 	call	822cfd8 <putq>
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 823f7c8:	01000044 	movi	r4,1
 823f7cc:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(NET_RESID);
 823f7d0:	0009883a 	mov	r4,zero
 823f7d4:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);

      SignalPktDemux();
 823f7d8:	d0a0ab17 	ldw	r2,-32084(gp)
 823f7dc:	1009883a 	mov	r4,r2
 823f7e0:	821a4a80 	call	821a4a8 <OSSemPost>

      return SUCCESS;
 823f7e4:	0005883a 	mov	r2,zero
 823f7e8:	00006a06 	br	823f994 <ip_write_internal+0x710>
   }

   /* determine if the buffer that needs to be transmitted is interrupt-safe */
   intrsafe_buf = ((p->flags & PKF_INTRUNSAFE) ? 0 : 1);
 823f7ec:	e0bfff17 	ldw	r2,-4(fp)
 823f7f0:	10800a17 	ldw	r2,40(r2)
 823f7f4:	1080040c 	andi	r2,r2,16
 823f7f8:	1005003a 	cmpeq	r2,r2,zero
 823f7fc:	e0bffa05 	stb	r2,-24(fp)
   /* obtain the length of the largest interrupt-safe buffer that can be 
    * allocated via pk_alloc () */
   maxbuflen = pk_get_max_intrsafe_buf_len ();
 823f800:	822ce440 	call	822ce44 <pk_get_max_intrsafe_buf_len>
 823f804:	e0bffb15 	stw	r2,-20(fp)
    * the original buffer is interrupt-safe, we just need to consider the
    * MTU of the egress interface.  If the original buffer is interrupt-
    * unsafe, we compute the MIN of the largest interrupt-safe buffer that
    * we can use and the MTU of the egress interface (since we must satisfy
    * both constraints) */
   if (!intrsafe_buf)
 823f808:	e0bffa03 	ldbu	r2,-24(fp)
 823f80c:	1000081e 	bne	r2,zero,823f830 <ip_write_internal+0x5ac>
       limit = MIN(maxbuflen,p->net->n_mtu);
 823f810:	e0bfff17 	ldw	r2,-4(fp)
 823f814:	10800617 	ldw	r2,24(r2)
 823f818:	10800917 	ldw	r2,36(r2)
 823f81c:	e0fffb17 	ldw	r3,-20(fp)
 823f820:	1880012e 	bgeu	r3,r2,823f828 <ip_write_internal+0x5a4>
 823f824:	1805883a 	mov	r2,r3
 823f828:	e0bff615 	stw	r2,-40(fp)
 823f82c:	00000406 	br	823f840 <ip_write_internal+0x5bc>
   else
       limit = p->net->n_mtu;
 823f830:	e0bfff17 	ldw	r2,-4(fp)
 823f834:	10800617 	ldw	r2,24(r2)
 823f838:	10800917 	ldw	r2,36(r2)
 823f83c:	e0bff615 	stw	r2,-40(fp)

   if ((p->nb_plen + p->net->n_lnh) > limit)
 823f840:	e0bfff17 	ldw	r2,-4(fp)
 823f844:	10800417 	ldw	r2,16(r2)
 823f848:	e0ffff17 	ldw	r3,-4(fp)
 823f84c:	18c00617 	ldw	r3,24(r3)
 823f850:	18c00817 	ldw	r3,32(r3)
 823f854:	10c5883a 	add	r2,r2,r3
 823f858:	e0fff617 	ldw	r3,-40(fp)
 823f85c:	1880072e 	bgeu	r3,r2,823f87c <ip_write_internal+0x5f8>
   {
#ifdef IP_FRAGMENTS
      int err;
      err = ip_fragment(p, firsthop);
 823f860:	e0bffe17 	ldw	r2,-8(fp)
 823f864:	100b883a 	mov	r5,r2
 823f868:	e13fff17 	ldw	r4,-4(fp)
 823f86c:	82404340 	call	8240434 <ip_fragment>
 823f870:	e0bffc15 	stw	r2,-16(fp)
      IN_PROFILER(PF_IP, PF_EXIT);
      return(err);
 823f874:	e0bffc17 	ldw	r2,-16(fp)
 823f878:	00004606 	br	823f994 <ip_write_internal+0x710>
   }
   else
   {
      /* fragmentation is not required; check to see if we need to copy out of
       * an interrupt-unsafe buffer */ 
      if (!intrsafe_buf)
 823f87c:	e0bffa03 	ldbu	r2,-24(fp)
 823f880:	1000401e 	bne	r2,zero,823f984 <ip_write_internal+0x700>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f884:	01000084 	movi	r4,2
 823f888:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
         newpkt = pk_alloc(p->nb_plen + p->net->n_lnh);
 823f88c:	e0bfff17 	ldw	r2,-4(fp)
 823f890:	10800417 	ldw	r2,16(r2)
 823f894:	e0ffff17 	ldw	r3,-4(fp)
 823f898:	18c00617 	ldw	r3,24(r3)
 823f89c:	18c00817 	ldw	r3,32(r3)
 823f8a0:	10c5883a 	add	r2,r2,r3
 823f8a4:	1009883a 	mov	r4,r2
 823f8a8:	822ca480 	call	822ca48 <pk_alloc>
 823f8ac:	e0bffd15 	stw	r2,-12(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f8b0:	01000084 	movi	r4,2
 823f8b4:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         if (newpkt == 0)
 823f8b8:	e0bffd17 	ldw	r2,-12(fp)
 823f8bc:	1000081e 	bne	r2,zero,823f8e0 <ip_write_internal+0x65c>
         {
            /* can't allocate interrupt-safe buffer, so free the packet that 
             * we are working with */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 823f8c0:	01000084 	movi	r4,2
 823f8c4:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
            pk_free(p);
 823f8c8:	e13fff17 	ldw	r4,-4(fp)
 823f8cc:	822cd980 	call	822cd98 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f8d0:	01000084 	movi	r4,2
 823f8d4:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NOBUFFER;
 823f8d8:	00bffac4 	movi	r2,-21
 823f8dc:	00002d06 	br	823f994 <ip_write_internal+0x710>
         }
         else
         {
            /* copy from interrupt-unsafe buffer into interrupt-safe buffer */
            newpkt->nb_prot = newpkt->nb_buff + p->net->n_lnh;
 823f8e0:	e0bffd17 	ldw	r2,-12(fp)
 823f8e4:	10800117 	ldw	r2,4(r2)
 823f8e8:	e0ffff17 	ldw	r3,-4(fp)
 823f8ec:	18c00617 	ldw	r3,24(r3)
 823f8f0:	18c00817 	ldw	r3,32(r3)
 823f8f4:	10c7883a 	add	r3,r2,r3
 823f8f8:	e0bffd17 	ldw	r2,-12(fp)
 823f8fc:	10c00315 	stw	r3,12(r2)
            MEMCPY(newpkt->nb_prot, p->nb_prot, p->nb_plen);
 823f900:	e0bffd17 	ldw	r2,-12(fp)
 823f904:	10c00317 	ldw	r3,12(r2)
 823f908:	e0bfff17 	ldw	r2,-4(fp)
 823f90c:	11000317 	ldw	r4,12(r2)
 823f910:	e0bfff17 	ldw	r2,-4(fp)
 823f914:	10800417 	ldw	r2,16(r2)
 823f918:	100d883a 	mov	r6,r2
 823f91c:	200b883a 	mov	r5,r4
 823f920:	1809883a 	mov	r4,r3
 823f924:	8202f6c0 	call	8202f6c <memcpy>
            /* setup various fields in the newly allocated PACKET structure */
            newpkt->nb_plen = p->nb_plen;
 823f928:	e0bfff17 	ldw	r2,-4(fp)
 823f92c:	10c00417 	ldw	r3,16(r2)
 823f930:	e0bffd17 	ldw	r2,-12(fp)
 823f934:	10c00415 	stw	r3,16(r2)
            newpkt->net = p->net;
 823f938:	e0bfff17 	ldw	r2,-4(fp)
 823f93c:	10c00617 	ldw	r3,24(r2)
 823f940:	e0bffd17 	ldw	r2,-12(fp)
 823f944:	10c00615 	stw	r3,24(r2)
            newpkt->fhost = p->fhost;
 823f948:	e0bfff17 	ldw	r2,-4(fp)
 823f94c:	10c00717 	ldw	r3,28(r2)
 823f950:	e0bffd17 	ldw	r2,-12(fp)
 823f954:	10c00715 	stw	r3,28(r2)
            /* free the original packet since it is no longer needed */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 823f958:	01000084 	movi	r4,2
 823f95c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
            pk_free(p);
 823f960:	e13fff17 	ldw	r4,-4(fp)
 823f964:	822cd980 	call	822cd98 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f968:	01000084 	movi	r4,2
 823f96c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            /* send packet to MAC layer. This will try to resolve MAC layer addressing 
             * and send packet. ip2mac() can return SUCCESS, PENDING, or error codes. 
             */
            return(ip2mac(newpkt, firsthop));
 823f970:	e0bffe17 	ldw	r2,-8(fp)
 823f974:	100b883a 	mov	r5,r2
 823f978:	e13ffd17 	ldw	r4,-12(fp)
 823f97c:	82267540 	call	8226754 <ip2mac>
 823f980:	00000406 	br	823f994 <ip_write_internal+0x710>
      else
      {
         /* since the packet is in an interrupt-safe buffer, it can be passed to 
          * ip2mac () without any additional work. */
         IN_PROFILER(PF_IP, PF_EXIT);
         return(ip2mac(p, firsthop));
 823f984:	e0bffe17 	ldw	r2,-8(fp)
 823f988:	100b883a 	mov	r5,r2
 823f98c:	e13fff17 	ldw	r4,-4(fp)
 823f990:	82267540 	call	8226754 <ip2mac>
      }
   }
}
 823f994:	e037883a 	mov	sp,fp
 823f998:	dfc00117 	ldw	ra,4(sp)
 823f99c:	df000017 	ldw	fp,0(sp)
 823f9a0:	dec00204 	addi	sp,sp,8
 823f9a4:	f800283a 	ret

0823f9a8 <ip_write>:

int
ip_write(
   u_char   prot,
   PACKET   p)
{
 823f9a8:	defff904 	addi	sp,sp,-28
 823f9ac:	dfc00615 	stw	ra,24(sp)
 823f9b0:	df000515 	stw	fp,20(sp)
 823f9b4:	df000504 	addi	fp,sp,20
 823f9b8:	2005883a 	mov	r2,r4
 823f9bc:	e17fff15 	stw	r5,-4(fp)
 823f9c0:	e0bffe05 	stb	r2,-8(fp)
   u_char ttl;
   struct ip_socopts *sopts;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 823f9c4:	008209b4 	movhi	r2,2086
 823f9c8:	10ba8304 	addi	r2,r2,-5620
 823f9cc:	10800917 	ldw	r2,36(r2)
 823f9d0:	10c00044 	addi	r3,r2,1
 823f9d4:	008209b4 	movhi	r2,2086
 823f9d8:	10ba8304 	addi	r2,r2,-5620
 823f9dc:	10c00915 	stw	r3,36(r2)

   /* make room for IP header, and form a pointer to it (pip) */
   p->nb_prot -= sizeof(struct ip);
 823f9e0:	e0bfff17 	ldw	r2,-4(fp)
 823f9e4:	10800317 	ldw	r2,12(r2)
 823f9e8:	10fffb04 	addi	r3,r2,-20
 823f9ec:	e0bfff17 	ldw	r2,-4(fp)
 823f9f0:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 823f9f4:	e0bfff17 	ldw	r2,-4(fp)
 823f9f8:	10800417 	ldw	r2,16(r2)
 823f9fc:	10c00504 	addi	r3,r2,20
 823fa00:	e0bfff17 	ldw	r2,-4(fp)
 823fa04:	10c00415 	stw	r3,16(r2)
   pip = (struct ip*)(p->nb_prot);
 823fa08:	e0bfff17 	ldw	r2,-4(fp)
 823fa0c:	10800317 	ldw	r2,12(r2)
 823fa10:	e0bffc15 	stw	r2,-16(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 823fa14:	e0bffc17 	ldw	r2,-16(fp)
 823fa18:	00c01144 	movi	r3,69
 823fa1c:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = 0;        /* clear fragmentation info field */
 823fa20:	e0bffc17 	ldw	r2,-16(fp)
 823fa24:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 823fa28:	d0a05017 	ldw	r2,-32448(gp)
 823fa2c:	10bfffcc 	andi	r2,r2,65535
 823fa30:	1005d23a 	srai	r2,r2,8
 823fa34:	10803fcc 	andi	r2,r2,255
 823fa38:	1007883a 	mov	r3,r2
 823fa3c:	d0a05017 	ldw	r2,-32448(gp)
 823fa40:	10bfffcc 	andi	r2,r2,65535
 823fa44:	1004923a 	slli	r2,r2,8
 823fa48:	1884b03a 	or	r2,r3,r2
 823fa4c:	1007883a 	mov	r3,r2
 823fa50:	e0bffc17 	ldw	r2,-16(fp)
 823fa54:	10c0010d 	sth	r3,4(r2)
   uid++;
 823fa58:	d0a05017 	ldw	r2,-32448(gp)
 823fa5c:	10800044 	addi	r2,r2,1
 823fa60:	d0a05015 	stw	r2,-32448(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 823fa64:	e0bfff17 	ldw	r2,-4(fp)
 823fa68:	10800417 	ldw	r2,16(r2)
 823fa6c:	10bfffcc 	andi	r2,r2,65535
 823fa70:	1005d23a 	srai	r2,r2,8
 823fa74:	10803fcc 	andi	r2,r2,255
 823fa78:	1007883a 	mov	r3,r2
 823fa7c:	e0bfff17 	ldw	r2,-4(fp)
 823fa80:	10800417 	ldw	r2,16(r2)
 823fa84:	10bfffcc 	andi	r2,r2,65535
 823fa88:	1004923a 	slli	r2,r2,8
 823fa8c:	1884b03a 	or	r2,r3,r2
 823fa90:	1007883a 	mov	r3,r2
 823fa94:	e0bffc17 	ldw	r2,-16(fp)
 823fa98:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 823fa9c:	e0bffc17 	ldw	r2,-16(fp)
 823faa0:	e0fffe03 	ldbu	r3,-8(fp)
 823faa4:	10c00245 	stb	r3,9(r2)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 823faa8:	e0bffc17 	ldw	r2,-16(fp)
 823faac:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 823fab0:	00801004 	movi	r2,64
 823fab4:	e0bffb05 	stb	r2,-20(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 823fab8:	e0bfff17 	ldw	r2,-4(fp)
 823fabc:	10800717 	ldw	r2,28(r2)
 823fac0:	1006d63a 	srli	r3,r2,24
 823fac4:	e0bfff17 	ldw	r2,-4(fp)
 823fac8:	10800717 	ldw	r2,28(r2)
 823facc:	1004d23a 	srli	r2,r2,8
 823fad0:	10bfc00c 	andi	r2,r2,65280
 823fad4:	1886b03a 	or	r3,r3,r2
 823fad8:	e0bfff17 	ldw	r2,-4(fp)
 823fadc:	10800717 	ldw	r2,28(r2)
 823fae0:	10bfc00c 	andi	r2,r2,65280
 823fae4:	1004923a 	slli	r2,r2,8
 823fae8:	1886b03a 	or	r3,r3,r2
 823faec:	e0bfff17 	ldw	r2,-4(fp)
 823faf0:	10800717 	ldw	r2,28(r2)
 823faf4:	1004963a 	slli	r2,r2,24
 823faf8:	1884b03a 	or	r2,r3,r2
 823fafc:	10fc002c 	andhi	r3,r2,61440
 823fb00:	00b80034 	movhi	r2,57344
 823fb04:	1880071e 	bne	r3,r2,823fb24 <ip_write+0x17c>
 823fb08:	e0bfff17 	ldw	r2,-4(fp)
 823fb0c:	10800b17 	ldw	r2,44(r2)
 823fb10:	10000426 	beq	r2,zero,823fb24 <ip_write+0x17c>
      ttl = p->imo->imo_multicast_ttl;
 823fb14:	e0bfff17 	ldw	r2,-4(fp)
 823fb18:	10800b17 	ldw	r2,44(r2)
 823fb1c:	10800103 	ldbu	r2,4(r2)
 823fb20:	e0bffb05 	stb	r2,-20(fp)
#endif /* IP_MULTICAST */

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 823fb24:	e0bfff17 	ldw	r2,-4(fp)
 823fb28:	10800c17 	ldw	r2,48(r2)
 823fb2c:	e0bffd15 	stw	r2,-12(fp)
 823fb30:	e0bffd17 	ldw	r2,-12(fp)
 823fb34:	10001126 	beq	r2,zero,823fb7c <ip_write+0x1d4>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 823fb38:	e0bffd17 	ldw	r2,-12(fp)
 823fb3c:	10800043 	ldbu	r2,1(r2)
 823fb40:	10803fcc 	andi	r2,r2,255
 823fb44:	10000526 	beq	r2,zero,823fb5c <ip_write+0x1b4>
         pip->ip_time = sopts->ip_ttl;
 823fb48:	e0bffd17 	ldw	r2,-12(fp)
 823fb4c:	10c00043 	ldbu	r3,1(r2)
 823fb50:	e0bffc17 	ldw	r2,-16(fp)
 823fb54:	10c00205 	stb	r3,8(r2)
 823fb58:	00000306 	br	823fb68 <ip_write+0x1c0>
	  else
         pip->ip_time = ttl;
 823fb5c:	e0bffc17 	ldw	r2,-16(fp)
 823fb60:	e0fffb03 	ldbu	r3,-20(fp)
 823fb64:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = sopts->ip_tos;
 823fb68:	e0bffd17 	ldw	r2,-12(fp)
 823fb6c:	10c00003 	ldbu	r3,0(r2)
 823fb70:	e0bffc17 	ldw	r2,-16(fp)
 823fb74:	10c00045 	stb	r3,1(r2)
 823fb78:	00000506 	br	823fb90 <ip_write+0x1e8>
   }
   else
   {
	  /* nope */
      pip->ip_time = ttl;
 823fb7c:	e0bffc17 	ldw	r2,-16(fp)
 823fb80:	e0fffb03 	ldbu	r3,-20(fp)
 823fb84:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 823fb88:	e0bffc17 	ldw	r2,-16(fp)
 823fb8c:	10000045 	stb	zero,1(r2)
   }
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum(pip, 10);
 823fb90:	01400284 	movi	r5,10
 823fb94:	e13ffc17 	ldw	r4,-16(fp)
 823fb98:	82288100 	call	8228810 <cksum>
 823fb9c:	0084303a 	nor	r2,zero,r2
 823fba0:	1007883a 	mov	r3,r2
 823fba4:	e0bffc17 	ldw	r2,-16(fp)
 823fba8:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 823fbac:	e13fff17 	ldw	r4,-4(fp)
 823fbb0:	823f2840 	call	823f284 <ip_write_internal>
}
 823fbb4:	e037883a 	mov	sp,fp
 823fbb8:	dfc00117 	ldw	ra,4(sp)
 823fbbc:	df000017 	ldw	fp,0(sp)
 823fbc0:	dec00204 	addi	sp,sp,8
 823fbc4:	f800283a 	ret

0823fbc8 <ip_write2>:
 * OUTPUT: This function returns the return code from 
 *         ip_write_internal ().
 */

int ip_write2 (u_char prot, PACKET p, u_char * optp)
{
 823fbc8:	defff604 	addi	sp,sp,-40
 823fbcc:	dfc00915 	stw	ra,36(sp)
 823fbd0:	df000815 	stw	fp,32(sp)
 823fbd4:	df000804 	addi	fp,sp,32
 823fbd8:	2005883a 	mov	r2,r4
 823fbdc:	e17ffe15 	stw	r5,-8(fp)
 823fbe0:	e1bfff15 	stw	r6,-4(fp)
 823fbe4:	e0bffd05 	stb	r2,-12(fp)
   struct ip * pip;
   u_char ttl;
   struct ip_socopts * sopts;
   u_char iphlen = sizeof (struct ip);
 823fbe8:	00800504 	movi	r2,20
 823fbec:	e0bff845 	stb	r2,-31(fp)
   u_char iphlen_pad;
   u_char i;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 823fbf0:	008209b4 	movhi	r2,2086
 823fbf4:	10ba8304 	addi	r2,r2,-5620
 823fbf8:	10800917 	ldw	r2,36(r2)
 823fbfc:	10c00044 	addi	r3,r2,1
 823fc00:	008209b4 	movhi	r2,2086
 823fc04:	10ba8304 	addi	r2,r2,-5620
 823fc08:	10c00915 	stw	r3,36(r2)

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 823fc0c:	e0bfff17 	ldw	r2,-4(fp)
 823fc10:	e0bff915 	stw	r2,-28(fp)
 823fc14:	00000d06 	br	823fc4c <ip_write2+0x84>
   {
      /* account for options, if any (caller has already created
       * adequate space for the requested option) */
      switch (*tmpp)
 823fc18:	e0bff917 	ldw	r2,-28(fp)
 823fc1c:	10800003 	ldbu	r2,0(r2)
 823fc20:	10803fcc 	andi	r2,r2,255
 823fc24:	10800520 	cmpeqi	r2,r2,20
 823fc28:	1000011e 	bne	r2,zero,823fc30 <ip_write2+0x68>
      {
         case IP_RTR_ALERT_OPT:
            iphlen += IP_RTR_ALERT_OPT_SIZE;
            break;
         default:
            break;
 823fc2c:	00000406 	br	823fc40 <ip_write2+0x78>
      /* account for options, if any (caller has already created
       * adequate space for the requested option) */
      switch (*tmpp)
      {
         case IP_RTR_ALERT_OPT:
            iphlen += IP_RTR_ALERT_OPT_SIZE;
 823fc30:	e0bff843 	ldbu	r2,-31(fp)
 823fc34:	10800104 	addi	r2,r2,4
 823fc38:	e0bff845 	stb	r2,-31(fp)
            break;
 823fc3c:	0001883a 	nop
   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 823fc40:	e0bff917 	ldw	r2,-28(fp)
 823fc44:	10800044 	addi	r2,r2,1
 823fc48:	e0bff915 	stw	r2,-28(fp)
 823fc4c:	e0bff917 	ldw	r2,-28(fp)
 823fc50:	10800003 	ldbu	r2,0(r2)
 823fc54:	10803fcc 	andi	r2,r2,255
 823fc58:	103fef1e 	bne	r2,zero,823fc18 <ip_write2+0x50>
   }

   /* compute the amount of padding required, if any (to ensure
    * that the IP header (including options) ends on a dword
    * (four byte) boundary */
   if (iphlen & 0x3)
 823fc5c:	e0bff843 	ldbu	r2,-31(fp)
 823fc60:	108000cc 	andi	r2,r2,3
 823fc64:	10000726 	beq	r2,zero,823fc84 <ip_write2+0xbc>
      iphlen_pad = 4 - (iphlen & 0x3);
 823fc68:	e0bff843 	ldbu	r2,-31(fp)
 823fc6c:	108000cc 	andi	r2,r2,3
 823fc70:	1007883a 	mov	r3,r2
 823fc74:	00800104 	movi	r2,4
 823fc78:	10c5c83a 	sub	r2,r2,r3
 823fc7c:	e0bffa05 	stb	r2,-24(fp)
 823fc80:	00000106 	br	823fc88 <ip_write2+0xc0>
   else iphlen_pad = 0; /* no header padding required */
 823fc84:	e03ffa05 	stb	zero,-24(fp)
   /* the packet passed to ip_write2 () has its nb_prot set to
    * point to start of the protocol's (e.g., IGMP) data, and 
    * nb_plen set to the length of that data.  locate start of 
    * the IP header (account for IP options), and form a pointer 
    * to it (pip) */
   p->nb_prot -= (iphlen + iphlen_pad);
 823fc88:	e0bffe17 	ldw	r2,-8(fp)
 823fc8c:	10c00317 	ldw	r3,12(r2)
 823fc90:	e13ff843 	ldbu	r4,-31(fp)
 823fc94:	e0bffa03 	ldbu	r2,-24(fp)
 823fc98:	2085883a 	add	r2,r4,r2
 823fc9c:	0085c83a 	sub	r2,zero,r2
 823fca0:	1887883a 	add	r3,r3,r2
 823fca4:	e0bffe17 	ldw	r2,-8(fp)
 823fca8:	10c00315 	stw	r3,12(r2)
   /* add padding length to the total length of the IP datagram */
   p->nb_plen += (iphlen + iphlen_pad);
 823fcac:	e0bffe17 	ldw	r2,-8(fp)
 823fcb0:	10800417 	ldw	r2,16(r2)
 823fcb4:	e13ff843 	ldbu	r4,-31(fp)
 823fcb8:	e0fffa03 	ldbu	r3,-24(fp)
 823fcbc:	20c7883a 	add	r3,r4,r3
 823fcc0:	10c7883a 	add	r3,r2,r3
 823fcc4:	e0bffe17 	ldw	r2,-8(fp)
 823fcc8:	10c00415 	stw	r3,16(r2)
   pip = (struct ip *) (p->nb_prot);
 823fccc:	e0bffe17 	ldw	r2,-8(fp)
 823fcd0:	10800317 	ldw	r2,12(r2)
 823fcd4:	e0bffb15 	stw	r2,-20(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = ((IP_VER << 4) | ((iphlen + iphlen_pad) >> 2));
 823fcd8:	e0fff843 	ldbu	r3,-31(fp)
 823fcdc:	e0bffa03 	ldbu	r2,-24(fp)
 823fce0:	1885883a 	add	r2,r3,r2
 823fce4:	1005d0ba 	srai	r2,r2,2
 823fce8:	10801014 	ori	r2,r2,64
 823fcec:	1007883a 	mov	r3,r2
 823fcf0:	e0bffb17 	ldw	r2,-20(fp)
 823fcf4:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = 0; /* clear fragmentation info field */
 823fcf8:	e0bffb17 	ldw	r2,-20(fp)
 823fcfc:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 823fd00:	d0a05017 	ldw	r2,-32448(gp)
 823fd04:	10bfffcc 	andi	r2,r2,65535
 823fd08:	1005d23a 	srai	r2,r2,8
 823fd0c:	10803fcc 	andi	r2,r2,255
 823fd10:	1007883a 	mov	r3,r2
 823fd14:	d0a05017 	ldw	r2,-32448(gp)
 823fd18:	10bfffcc 	andi	r2,r2,65535
 823fd1c:	1004923a 	slli	r2,r2,8
 823fd20:	1884b03a 	or	r2,r3,r2
 823fd24:	1007883a 	mov	r3,r2
 823fd28:	e0bffb17 	ldw	r2,-20(fp)
 823fd2c:	10c0010d 	sth	r3,4(r2)
   uid++;
 823fd30:	d0a05017 	ldw	r2,-32448(gp)
 823fd34:	10800044 	addi	r2,r2,1
 823fd38:	d0a05015 	stw	r2,-32448(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 823fd3c:	e0bffe17 	ldw	r2,-8(fp)
 823fd40:	10800417 	ldw	r2,16(r2)
 823fd44:	10bfffcc 	andi	r2,r2,65535
 823fd48:	1005d23a 	srai	r2,r2,8
 823fd4c:	10803fcc 	andi	r2,r2,255
 823fd50:	1007883a 	mov	r3,r2
 823fd54:	e0bffe17 	ldw	r2,-8(fp)
 823fd58:	10800417 	ldw	r2,16(r2)
 823fd5c:	10bfffcc 	andi	r2,r2,65535
 823fd60:	1004923a 	slli	r2,r2,8
 823fd64:	1884b03a 	or	r2,r3,r2
 823fd68:	1007883a 	mov	r3,r2
 823fd6c:	e0bffb17 	ldw	r2,-20(fp)
 823fd70:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 823fd74:	e0bffb17 	ldw	r2,-20(fp)
 823fd78:	e0fffd03 	ldbu	r3,-12(fp)
 823fd7c:	10c00245 	stb	r3,9(r2)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 823fd80:	e0bffb17 	ldw	r2,-20(fp)
 823fd84:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 823fd88:	00801004 	movi	r2,64
 823fd8c:	e0bff805 	stb	r2,-32(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 823fd90:	e0bffe17 	ldw	r2,-8(fp)
 823fd94:	10800717 	ldw	r2,28(r2)
 823fd98:	1006d63a 	srli	r3,r2,24
 823fd9c:	e0bffe17 	ldw	r2,-8(fp)
 823fda0:	10800717 	ldw	r2,28(r2)
 823fda4:	1004d23a 	srli	r2,r2,8
 823fda8:	10bfc00c 	andi	r2,r2,65280
 823fdac:	1886b03a 	or	r3,r3,r2
 823fdb0:	e0bffe17 	ldw	r2,-8(fp)
 823fdb4:	10800717 	ldw	r2,28(r2)
 823fdb8:	10bfc00c 	andi	r2,r2,65280
 823fdbc:	1004923a 	slli	r2,r2,8
 823fdc0:	1886b03a 	or	r3,r3,r2
 823fdc4:	e0bffe17 	ldw	r2,-8(fp)
 823fdc8:	10800717 	ldw	r2,28(r2)
 823fdcc:	1004963a 	slli	r2,r2,24
 823fdd0:	1884b03a 	or	r2,r3,r2
 823fdd4:	10fc002c 	andhi	r3,r2,61440
 823fdd8:	00b80034 	movhi	r2,57344
 823fddc:	1880071e 	bne	r3,r2,823fdfc <ip_write2+0x234>
 823fde0:	e0bffe17 	ldw	r2,-8(fp)
 823fde4:	10800b17 	ldw	r2,44(r2)
 823fde8:	10000426 	beq	r2,zero,823fdfc <ip_write2+0x234>
      ttl = p->imo->imo_multicast_ttl;
 823fdec:	e0bffe17 	ldw	r2,-8(fp)
 823fdf0:	10800b17 	ldw	r2,44(r2)
 823fdf4:	10800103 	ldbu	r2,4(r2)
 823fdf8:	e0bff805 	stb	r2,-32(fp)
#endif /* IP_MULTICAST */

   /* have TOS or TTL been set (via socket options)? */
   if ((sopts = p->soxopts))
 823fdfc:	e0bffe17 	ldw	r2,-8(fp)
 823fe00:	10800c17 	ldw	r2,48(r2)
 823fe04:	e0bffc15 	stw	r2,-16(fp)
 823fe08:	e0bffc17 	ldw	r2,-16(fp)
 823fe0c:	10001126 	beq	r2,zero,823fe54 <ip_write2+0x28c>
   {
      if (sopts->ip_ttl)
 823fe10:	e0bffc17 	ldw	r2,-16(fp)
 823fe14:	10800043 	ldbu	r2,1(r2)
 823fe18:	10803fcc 	andi	r2,r2,255
 823fe1c:	10000526 	beq	r2,zero,823fe34 <ip_write2+0x26c>
         pip->ip_time = sopts->ip_ttl;
 823fe20:	e0bffc17 	ldw	r2,-16(fp)
 823fe24:	10c00043 	ldbu	r3,1(r2)
 823fe28:	e0bffb17 	ldw	r2,-20(fp)
 823fe2c:	10c00205 	stb	r3,8(r2)
 823fe30:	00000306 	br	823fe40 <ip_write2+0x278>
      else
         pip->ip_time = ttl;
 823fe34:	e0bffb17 	ldw	r2,-20(fp)
 823fe38:	e0fff803 	ldbu	r3,-32(fp)
 823fe3c:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = sopts->ip_tos;
 823fe40:	e0bffc17 	ldw	r2,-16(fp)
 823fe44:	10c00003 	ldbu	r3,0(r2)
 823fe48:	e0bffb17 	ldw	r2,-20(fp)
 823fe4c:	10c00045 	stb	r3,1(r2)
 823fe50:	00000506 	br	823fe68 <ip_write2+0x2a0>
   }
   else
   {
      pip->ip_time = ttl;
 823fe54:	e0bffb17 	ldw	r2,-20(fp)
 823fe58:	e0fff803 	ldbu	r3,-32(fp)
 823fe5c:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 823fe60:	e0bffb17 	ldw	r2,-20(fp)
 823fe64:	10000045 	stb	zero,1(r2)
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 823fe68:	e0bffe17 	ldw	r2,-8(fp)
 823fe6c:	10800317 	ldw	r2,12(r2)
 823fe70:	10800504 	addi	r2,r2,20
 823fe74:	e0bff915 	stw	r2,-28(fp)
 823fe78:	00001006 	br	823febc <ip_write2+0x2f4>
   {
      /* caller has already provided adequate space for the requested options */
      switch (*optp)
 823fe7c:	e0bfff17 	ldw	r2,-4(fp)
 823fe80:	10800003 	ldbu	r2,0(r2)
 823fe84:	10803fcc 	andi	r2,r2,255
 823fe88:	10800520 	cmpeqi	r2,r2,20
 823fe8c:	1000011e 	bne	r2,zero,823fe94 <ip_write2+0x2cc>
            *((u_long *) tmpp) = htonl (IP_RTR_ALERT_OPT_DATA);
            /* this option is 4 bytes long */
            tmpp += IP_RTR_ALERT_OPT_SIZE;
            break;
         default:
            break;
 823fe90:	00000706 	br	823feb0 <ip_write2+0x2e8>
   {
      /* caller has already provided adequate space for the requested options */
      switch (*optp)
      {
         case IP_RTR_ALERT_OPT:
            *((u_long *) tmpp) = htonl (IP_RTR_ALERT_OPT_DATA);
 823fe94:	e0bff917 	ldw	r2,-28(fp)
 823fe98:	00c12504 	movi	r3,1172
 823fe9c:	10c00015 	stw	r3,0(r2)
            /* this option is 4 bytes long */
            tmpp += IP_RTR_ALERT_OPT_SIZE;
 823fea0:	e0bff917 	ldw	r2,-28(fp)
 823fea4:	10800104 	addi	r2,r2,4
 823fea8:	e0bff915 	stw	r2,-28(fp)
            break;
 823feac:	0001883a 	nop
      pip->ip_time = ttl;
      pip->ip_tos = IP_TOS_DEFVAL;
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 823feb0:	e0bfff17 	ldw	r2,-4(fp)
 823feb4:	10800044 	addi	r2,r2,1
 823feb8:	e0bfff15 	stw	r2,-4(fp)
 823febc:	e0bfff17 	ldw	r2,-4(fp)
 823fec0:	10800003 	ldbu	r2,0(r2)
 823fec4:	10803fcc 	andi	r2,r2,255
 823fec8:	103fec1e 	bne	r2,zero,823fe7c <ip_write2+0x2b4>
            break;
      }
   }

   /* add one (or more) one-byte long End of Option options (if required) */
   for (i = 0; i < iphlen_pad; ++i) *(tmpp + i) = 0;
 823fecc:	e03ffa45 	stb	zero,-23(fp)
 823fed0:	00000706 	br	823fef0 <ip_write2+0x328>
 823fed4:	e0bffa43 	ldbu	r2,-23(fp)
 823fed8:	e0fff917 	ldw	r3,-28(fp)
 823fedc:	1885883a 	add	r2,r3,r2
 823fee0:	10000005 	stb	zero,0(r2)
 823fee4:	e0bffa43 	ldbu	r2,-23(fp)
 823fee8:	10800044 	addi	r2,r2,1
 823feec:	e0bffa45 	stb	r2,-23(fp)
 823fef0:	e0fffa43 	ldbu	r3,-23(fp)
 823fef4:	e0bffa03 	ldbu	r2,-24(fp)
 823fef8:	18bff636 	bltu	r3,r2,823fed4 <ip_write2+0x30c>
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum (pip, ((iphlen + iphlen_pad)/2));
 823fefc:	e0fff843 	ldbu	r3,-31(fp)
 823ff00:	e0bffa03 	ldbu	r2,-24(fp)
 823ff04:	1885883a 	add	r2,r3,r2
 823ff08:	1006d7fa 	srli	r3,r2,31
 823ff0c:	1885883a 	add	r2,r3,r2
 823ff10:	1005d07a 	srai	r2,r2,1
 823ff14:	100b883a 	mov	r5,r2
 823ff18:	e13ffb17 	ldw	r4,-20(fp)
 823ff1c:	82288100 	call	8228810 <cksum>
 823ff20:	0084303a 	nor	r2,zero,r2
 823ff24:	1007883a 	mov	r3,r2
 823ff28:	e0bffb17 	ldw	r2,-20(fp)
 823ff2c:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal (p));
 823ff30:	e13ffe17 	ldw	r4,-8(fp)
 823ff34:	823f2840 	call	823f284 <ip_write_internal>
}
 823ff38:	e037883a 	mov	sp,fp
 823ff3c:	dfc00117 	ldw	ra,4(sp)
 823ff40:	df000017 	ldw	fp,0(sp)
 823ff44:	dec00204 	addi	sp,sp,8
 823ff48:	f800283a 	ret

0823ff4c <ip_raw_write>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_raw_write(PACKET p)
{
 823ff4c:	defffc04 	addi	sp,sp,-16
 823ff50:	dfc00315 	stw	ra,12(sp)
 823ff54:	df000215 	stw	fp,8(sp)
 823ff58:	df000204 	addi	fp,sp,8
 823ff5c:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 823ff60:	008209b4 	movhi	r2,2086
 823ff64:	10ba8304 	addi	r2,r2,-5620
 823ff68:	10800917 	ldw	r2,36(r2)
 823ff6c:	10c00044 	addi	r3,r2,1
 823ff70:	008209b4 	movhi	r2,2086
 823ff74:	10ba8304 	addi	r2,r2,-5620
 823ff78:	10c00915 	stw	r3,36(r2)

   /* form a pointer to IP header (pip) */
   pip = (struct ip*)(p->nb_prot);
 823ff7c:	e0bfff17 	ldw	r2,-4(fp)
 823ff80:	10800317 	ldw	r2,12(r2)
 823ff84:	e0bffe15 	stw	r2,-8(fp)
   
   /* if there's no IP id, give it one */
   if (pip->ip_id == 0)
 823ff88:	e0bffe17 	ldw	r2,-8(fp)
 823ff8c:	1080010b 	ldhu	r2,4(r2)
 823ff90:	10bfffcc 	andi	r2,r2,65535
 823ff94:	10000f1e 	bne	r2,zero,823ffd4 <ip_raw_write+0x88>
   {
      pip->ip_id = htons((unshort)uid);
 823ff98:	d0a05017 	ldw	r2,-32448(gp)
 823ff9c:	10bfffcc 	andi	r2,r2,65535
 823ffa0:	1005d23a 	srai	r2,r2,8
 823ffa4:	10803fcc 	andi	r2,r2,255
 823ffa8:	1007883a 	mov	r3,r2
 823ffac:	d0a05017 	ldw	r2,-32448(gp)
 823ffb0:	10bfffcc 	andi	r2,r2,65535
 823ffb4:	1004923a 	slli	r2,r2,8
 823ffb8:	1884b03a 	or	r2,r3,r2
 823ffbc:	1007883a 	mov	r3,r2
 823ffc0:	e0bffe17 	ldw	r2,-8(fp)
 823ffc4:	10c0010d 	sth	r3,4(r2)
      uid++;
 823ffc8:	d0a05017 	ldw	r2,-32448(gp)
 823ffcc:	10800044 	addi	r2,r2,1
 823ffd0:	d0a05015 	stw	r2,-32448(gp)
   }

   /* checksum the IP header */
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 823ffd4:	e0bffe17 	ldw	r2,-8(fp)
 823ffd8:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 823ffdc:	01400284 	movi	r5,10
 823ffe0:	e13ffe17 	ldw	r4,-8(fp)
 823ffe4:	82288100 	call	8228810 <cksum>
 823ffe8:	0084303a 	nor	r2,zero,r2
 823ffec:	1007883a 	mov	r3,r2
 823fff0:	e0bffe17 	ldw	r2,-8(fp)
 823fff4:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 823fff8:	e13fff17 	ldw	r4,-4(fp)
 823fffc:	823f2840 	call	823f284 <ip_write_internal>
}
 8240000:	e037883a 	mov	sp,fp
 8240004:	dfc00117 	ldw	ra,4(sp)
 8240008:	df000017 	ldw	fp,0(sp)
 824000c:	dec00204 	addi	sp,sp,8
 8240010:	f800283a 	ret

08240014 <ip_fragment_lc>:
 *              invocation of ip2mac () for the last generated fragment
 */

int
ip_fragment_lc(PACKET p, ip_addr firsthop)
{
 8240014:	defff104 	addi	sp,sp,-60
 8240018:	dfc00e15 	stw	ra,56(sp)
 824001c:	df000d15 	stw	fp,52(sp)
 8240020:	df000d04 	addi	fp,sp,52
 8240024:	e13ffe15 	stw	r4,-8(fp)
 8240028:	e17fff15 	stw	r5,-4(fp)
   int      e;
   struct ip * pip;
   int      iphlen;     /* IP header length */
   unshort  tmp_fraginfo   ;

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 824002c:	008209b4 	movhi	r2,2086
 8240030:	10ba8304 	addi	r2,r2,-5620
 8240034:	10801017 	ldw	r2,64(r2)
 8240038:	10c00044 	addi	r3,r2,1
 824003c:	008209b4 	movhi	r2,2086
 8240040:	10ba8304 	addi	r2,r2,-5620
 8240044:	10c01015 	stw	r3,64(r2)
   pip = (struct ip *)(p->nb_prot);          /* get ptr to IP header */
 8240048:	e0bffe17 	ldw	r2,-8(fp)
 824004c:	10800317 	ldw	r2,12(r2)
 8240050:	e0bff815 	stw	r2,-32(fp)
   iphlen = (pip->ip_ver_ihl & 0xf) << 2;    /* and its length */
 8240054:	e0bff817 	ldw	r2,-32(fp)
 8240058:	10800003 	ldbu	r2,0(r2)
 824005c:	10803fcc 	andi	r2,r2,255
 8240060:	108003cc 	andi	r2,r2,15
 8240064:	1085883a 	add	r2,r2,r2
 8240068:	1085883a 	add	r2,r2,r2
 824006c:	e0bff915 	stw	r2,-28(fp)
   left = (int)p->nb_plen - iphlen; /* bytes left to send in datagram */
 8240070:	e0bffe17 	ldw	r2,-8(fp)
 8240074:	10800417 	ldw	r2,16(r2)
 8240078:	1007883a 	mov	r3,r2
 824007c:	e0bff917 	ldw	r2,-28(fp)
 8240080:	1885c83a 	sub	r2,r3,r2
 8240084:	e0bff515 	stw	r2,-44(fp)
    * of fragments to get a fragment length that will result
    * in similarly-sized segments (remembering to round this
    * length up to a multiple of 8 because that's how the IP 
    * Fragment Offset field is scaled).
    */
   maxipsize = p->net->n_mtu - (iphlen + p->net->n_lnh + 8);   /* 8 == for rounding up */
 8240088:	e0bffe17 	ldw	r2,-8(fp)
 824008c:	10800617 	ldw	r2,24(r2)
 8240090:	10c00917 	ldw	r3,36(r2)
 8240094:	e0bffe17 	ldw	r2,-8(fp)
 8240098:	10800617 	ldw	r2,24(r2)
 824009c:	11000817 	ldw	r4,32(r2)
 82400a0:	e0bff917 	ldw	r2,-28(fp)
 82400a4:	2085883a 	add	r2,r4,r2
 82400a8:	10800204 	addi	r2,r2,8
 82400ac:	1885c83a 	sub	r2,r3,r2
 82400b0:	e0bffa15 	stw	r2,-24(fp)
   if (maxipsize < 64)  /* to small to use */
 82400b4:	e0bffa17 	ldw	r2,-24(fp)
 82400b8:	10801028 	cmpgeui	r2,r2,64
 82400bc:	1000031e 	bne	r2,zero,82400cc <ip_fragment_lc+0xb8>
   {
      dtrap();    /* probably bad programming */
 82400c0:	822d5f00 	call	822d5f0 <dtrap>
      return ENP_LOGIC;
 82400c4:	00bffd44 	movi	r2,-11
 82400c8:	0000d506 	br	8240420 <ip_fragment_lc+0x40c>
   }
   numfrags = (p->nb_plen/maxipsize) + 1;    /* number of fragments */
 82400cc:	e0bffe17 	ldw	r2,-8(fp)
 82400d0:	10800417 	ldw	r2,16(r2)
 82400d4:	e17ffa17 	ldw	r5,-24(fp)
 82400d8:	1009883a 	mov	r4,r2
 82400dc:	8202c6c0 	call	8202c6c <__udivsi3>
 82400e0:	10800044 	addi	r2,r2,1
 82400e4:	e0bffb15 	stw	r2,-20(fp)
   fragsize = (((p->nb_plen + (numfrags - 1)) / numfrags) + 7) & ~7; 
 82400e8:	e0bffe17 	ldw	r2,-8(fp)
 82400ec:	10c00417 	ldw	r3,16(r2)
 82400f0:	e0bffb17 	ldw	r2,-20(fp)
 82400f4:	1885883a 	add	r2,r3,r2
 82400f8:	10bfffc4 	addi	r2,r2,-1
 82400fc:	e17ffb17 	ldw	r5,-20(fp)
 8240100:	1009883a 	mov	r4,r2
 8240104:	8202c6c0 	call	8202c6c <__udivsi3>
 8240108:	10c001c4 	addi	r3,r2,7
 824010c:	00bffe04 	movi	r2,-8
 8240110:	1884703a 	and	r2,r3,r2
 8240114:	e0bffc15 	stw	r2,-16(fp)
   foffset = 0;
 8240118:	e03ff315 	stw	zero,-52(fp)

   /* Now update from any previous info */
   tmp_fraginfo = ntohs(pip->ip_flgs_foff);     /* get current frag info*/
 824011c:	e0bff817 	ldw	r2,-32(fp)
 8240120:	1080018b 	ldhu	r2,6(r2)
 8240124:	10bfffcc 	andi	r2,r2,65535
 8240128:	1004d23a 	srli	r2,r2,8
 824012c:	1007883a 	mov	r3,r2
 8240130:	e0bff817 	ldw	r2,-32(fp)
 8240134:	1080018b 	ldhu	r2,6(r2)
 8240138:	10bfffcc 	andi	r2,r2,65535
 824013c:	1004923a 	slli	r2,r2,8
 8240140:	1884b03a 	or	r2,r3,r2
 8240144:	e0bffd0d 	sth	r2,-12(fp)
   if ( tmp_fraginfo & (~IP_FLG_MASK) )
 8240148:	e0fffd0b 	ldhu	r3,-12(fp)
 824014c:	00bffff4 	movhi	r2,65535
 8240150:	1087ffc4 	addi	r2,r2,8191
 8240154:	1884703a 	and	r2,r3,r2
 8240158:	10000826 	beq	r2,zero,824017c <ip_fragment_lc+0x168>
   {
      /* When fragmenting an already fragmented packet, we need to
         add the initial offset */
      foffset = (tmp_fraginfo & (~IP_FLG_MASK))  ;
 824015c:	e0fffd0b 	ldhu	r3,-12(fp)
 8240160:	00bffff4 	movhi	r2,65535
 8240164:	1087ffc4 	addi	r2,r2,8191
 8240168:	1884703a 	and	r2,r3,r2
 824016c:	e0bff315 	stw	r2,-52(fp)
      foffset <<= 3;    /* Multiply by 8 to get "offset in num of bytes" */
 8240170:	e0bff317 	ldw	r2,-52(fp)
 8240174:	100490fa 	slli	r2,r2,3
 8240178:	e0bff315 	stw	r2,-52(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
 824017c:	e0bffe17 	ldw	r2,-8(fp)
 8240180:	e0bff615 	stw	r2,-40(fp)
   e = 0;
 8240184:	e03ff715 	stw	zero,-36(fp)
   while (left > 1)  /* more data left to send? */
 8240188:	0000a106 	br	8240410 <ip_fragment_lc+0x3fc>
   {
      p = pkt2;  /* move next fragment up */
 824018c:	e0bff617 	ldw	r2,-40(fp)
 8240190:	e0bffe15 	stw	r2,-8(fp)
      pip = (struct ip *)(p->nb_prot);
 8240194:	e0bffe17 	ldw	r2,-8(fp)
 8240198:	10800317 	ldw	r2,12(r2)
 824019c:	e0bff815 	stw	r2,-32(fp)
      p->nb_plen = min((int)fragsize, left) + iphlen; /* set size of fragment */
 82401a0:	e0bffc17 	ldw	r2,-16(fp)
 82401a4:	e0fff517 	ldw	r3,-44(fp)
 82401a8:	1880010e 	bge	r3,r2,82401b0 <ip_fragment_lc+0x19c>
 82401ac:	1805883a 	mov	r2,r3
 82401b0:	e0fff917 	ldw	r3,-28(fp)
 82401b4:	10c5883a 	add	r2,r2,r3
 82401b8:	1007883a 	mov	r3,r2
 82401bc:	e0bffe17 	ldw	r2,-8(fp)
 82401c0:	10c00415 	stw	r3,16(r2)
      left -= fragsize; /* decrement count of bytes left to send */
 82401c4:	e0fff517 	ldw	r3,-44(fp)
 82401c8:	e0bffc17 	ldw	r2,-16(fp)
 82401cc:	1885c83a 	sub	r2,r3,r2
 82401d0:	e0bff515 	stw	r2,-44(fp)

      /* set the IP datagram length */
      pip->ip_len = htons((unshort)p->nb_plen);
 82401d4:	e0bffe17 	ldw	r2,-8(fp)
 82401d8:	10800417 	ldw	r2,16(r2)
 82401dc:	10bfffcc 	andi	r2,r2,65535
 82401e0:	1005d23a 	srai	r2,r2,8
 82401e4:	10803fcc 	andi	r2,r2,255
 82401e8:	1007883a 	mov	r3,r2
 82401ec:	e0bffe17 	ldw	r2,-8(fp)
 82401f0:	10800417 	ldw	r2,16(r2)
 82401f4:	10bfffcc 	andi	r2,r2,65535
 82401f8:	1004923a 	slli	r2,r2,8
 82401fc:	1884b03a 	or	r2,r3,r2
 8240200:	1007883a 	mov	r3,r2
 8240204:	e0bff817 	ldw	r2,-32(fp)
 8240208:	10c0008d 	sth	r3,2(r2)

      /* build 16bit IP header field value for fragment flags & offset */
      fraginfo = (unshort)(foffset >> 3);    /* offset, in 8 byte chunks */
 824020c:	e0bff317 	ldw	r2,-52(fp)
 8240210:	1004d0fa 	srli	r2,r2,3
 8240214:	e0bff40d 	sth	r2,-48(fp)
      fraginfo |= ((left>1)?IP_FLG_MF:0);    /* OR in MoreFrags flag */
 8240218:	e0bff517 	ldw	r2,-44(fp)
 824021c:	10800090 	cmplti	r2,r2,2
 8240220:	1000021e 	bne	r2,zero,824022c <ip_fragment_lc+0x218>
 8240224:	00880004 	movi	r2,8192
 8240228:	00000106 	br	8240230 <ip_fragment_lc+0x21c>
 824022c:	0005883a 	mov	r2,zero
 8240230:	e0fff40b 	ldhu	r3,-48(fp)
 8240234:	10c4b03a 	or	r2,r2,r3
 8240238:	e0bff40d 	sth	r2,-48(fp)

      if ( tmp_fraginfo & IP_FLG_MF )             
 824023c:	e0bffd0b 	ldhu	r2,-12(fp)
 8240240:	1088000c 	andi	r2,r2,8192
 8240244:	10000326 	beq	r2,zero,8240254 <ip_fragment_lc+0x240>
      {
         /* As flag is set in main packet, it should be set in all
          * fragmented packets also 
          */
         fraginfo |= IP_FLG_MF;
 8240248:	e0bff40b 	ldhu	r2,-48(fp)
 824024c:	10880014 	ori	r2,r2,8192
 8240250:	e0bff40d 	sth	r2,-48(fp)
      }

      pip->ip_flgs_foff = htons(fraginfo);   /* do htons macro on separate line */
 8240254:	e0bff40b 	ldhu	r2,-48(fp)
 8240258:	1004d23a 	srli	r2,r2,8
 824025c:	1007883a 	mov	r3,r2
 8240260:	e0bff40b 	ldhu	r2,-48(fp)
 8240264:	1004923a 	slli	r2,r2,8
 8240268:	1884b03a 	or	r2,r3,r2
 824026c:	1007883a 	mov	r3,r2
 8240270:	e0bff817 	ldw	r2,-32(fp)
 8240274:	10c0018d 	sth	r3,6(r2)
      /* set up & save next fragment (pkt2) since ip2mac() will delete p */
      if (left > 1)
 8240278:	e0bff517 	ldw	r2,-44(fp)
 824027c:	10800090 	cmplti	r2,r2,2
 8240280:	10003e1e 	bne	r2,zero,824037c <ip_fragment_lc+0x368>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 8240284:	01000084 	movi	r4,2
 8240288:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
         pkt2 = pk_alloc(left + iphlen + MaxLnh);
 824028c:	e0fff517 	ldw	r3,-44(fp)
 8240290:	e0bff917 	ldw	r2,-28(fp)
 8240294:	1887883a 	add	r3,r3,r2
 8240298:	d0a08117 	ldw	r2,-32252(gp)
 824029c:	1885883a 	add	r2,r3,r2
 82402a0:	1009883a 	mov	r4,r2
 82402a4:	822ca480 	call	822ca48 <pk_alloc>
 82402a8:	e0bff615 	stw	r2,-40(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82402ac:	01000084 	movi	r4,2
 82402b0:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         if (!pkt2)
 82402b4:	e0bff617 	ldw	r2,-40(fp)
 82402b8:	1000101e 	bne	r2,zero,82402fc <ip_fragment_lc+0x2e8>
         {
            dtrap();
 82402bc:	822d5f00 	call	822d5f0 <dtrap>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 82402c0:	01000084 	movi	r4,2
 82402c4:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
            pk_free(p);
 82402c8:	e13ffe17 	ldw	r4,-8(fp)
 82402cc:	822cd980 	call	822cd98 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82402d0:	01000084 	movi	r4,2
 82402d4:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 82402d8:	008209b4 	movhi	r2,2086
 82402dc:	10ba8304 	addi	r2,r2,-5620
 82402e0:	10801117 	ldw	r2,68(r2)
 82402e4:	10c00044 	addi	r3,r2,1
 82402e8:	008209b4 	movhi	r2,2086
 82402ec:	10ba8304 	addi	r2,r2,-5620
 82402f0:	10c01115 	stw	r3,68(r2)
            return ENP_RESOURCE;
 82402f4:	00bffa84 	movi	r2,-22
 82402f8:	00004906 	br	8240420 <ip_fragment_lc+0x40c>
         }

         pkt2->net = p->net;       /* copy critical parms to new packet */
 82402fc:	e0bffe17 	ldw	r2,-8(fp)
 8240300:	10c00617 	ldw	r3,24(r2)
 8240304:	e0bff617 	ldw	r2,-40(fp)
 8240308:	10c00615 	stw	r3,24(r2)
         pkt2->fhost = p->fhost;
 824030c:	e0bffe17 	ldw	r2,-8(fp)
 8240310:	10c00717 	ldw	r3,28(r2)
 8240314:	e0bff617 	ldw	r2,-40(fp)
 8240318:	10c00715 	stw	r3,28(r2)
         /* Duplicate the IPHeader */
         MEMCPY(pkt2->nb_prot, p->nb_prot, iphlen);
 824031c:	e0bff617 	ldw	r2,-40(fp)
 8240320:	10c00317 	ldw	r3,12(r2)
 8240324:	e0bffe17 	ldw	r2,-8(fp)
 8240328:	10800317 	ldw	r2,12(r2)
 824032c:	e13ff917 	ldw	r4,-28(fp)
 8240330:	200d883a 	mov	r6,r4
 8240334:	100b883a 	mov	r5,r2
 8240338:	1809883a 	mov	r4,r3
 824033c:	8202f6c0 	call	8202f6c <memcpy>
         /* copy data for NEXT fragment from p to pkt2 */
         MEMCPY(pkt2->nb_prot + iphlen, p->nb_prot + iphlen + fragsize, left);
 8240340:	e0bff617 	ldw	r2,-40(fp)
 8240344:	10c00317 	ldw	r3,12(r2)
 8240348:	e0bff917 	ldw	r2,-28(fp)
 824034c:	188f883a 	add	r7,r3,r2
 8240350:	e0bffe17 	ldw	r2,-8(fp)
 8240354:	10c00317 	ldw	r3,12(r2)
 8240358:	e13ff917 	ldw	r4,-28(fp)
 824035c:	e0bffc17 	ldw	r2,-16(fp)
 8240360:	2085883a 	add	r2,r4,r2
 8240364:	1885883a 	add	r2,r3,r2
 8240368:	e0fff517 	ldw	r3,-44(fp)
 824036c:	180d883a 	mov	r6,r3
 8240370:	100b883a 	mov	r5,r2
 8240374:	3809883a 	mov	r4,r7
 8240378:	8202f6c0 	call	8202f6c <memcpy>
      }

      /* we've changed the IP header, so recalculate the checksum */
      pip->ip_chksum = IPXSUM;
 824037c:	e0bff817 	ldw	r2,-32(fp)
 8240380:	1000028d 	sth	zero,10(r2)
      pip->ip_chksum = ~cksum(pip, 10);
 8240384:	01400284 	movi	r5,10
 8240388:	e13ff817 	ldw	r4,-32(fp)
 824038c:	82288100 	call	8228810 <cksum>
 8240390:	0084303a 	nor	r2,zero,r2
 8240394:	1007883a 	mov	r3,r2
 8240398:	e0bff817 	ldw	r2,-32(fp)
 824039c:	10c0028d 	sth	r3,10(r2)

      /* ip_dump(p); */

      e = ip2mac(p, firsthop);   /* send fragment in p */
 82403a0:	e17fff17 	ldw	r5,-4(fp)
 82403a4:	e13ffe17 	ldw	r4,-8(fp)
 82403a8:	82267540 	call	8226754 <ip2mac>
 82403ac:	e0bff715 	stw	r2,-36(fp)
      ip_mib.ipFragCreates++;
 82403b0:	008209b4 	movhi	r2,2086
 82403b4:	10ba8304 	addi	r2,r2,-5620
 82403b8:	10801217 	ldw	r2,72(r2)
 82403bc:	10c00044 	addi	r3,r2,1
 82403c0:	008209b4 	movhi	r2,2086
 82403c4:	10ba8304 	addi	r2,r2,-5620
 82403c8:	10c01215 	stw	r3,72(r2)
      if (e < 0)
 82403cc:	e0bff717 	ldw	r2,-36(fp)
 82403d0:	10000b0e 	bge	r2,zero,8240400 <ip_fragment_lc+0x3ec>
      {
         if (left > 1) 
 82403d4:	e0bff517 	ldw	r2,-44(fp)
 82403d8:	10800090 	cmplti	r2,r2,2
 82403dc:	1000061e 	bne	r2,zero,82403f8 <ip_fragment_lc+0x3e4>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 82403e0:	01000084 	movi	r4,2
 82403e4:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
            pk_free(pkt2);
 82403e8:	e13ff617 	ldw	r4,-40(fp)
 82403ec:	822cd980 	call	822cd98 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82403f0:	01000084 	movi	r4,2
 82403f4:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         }
         return e;
 82403f8:	e0bff717 	ldw	r2,-36(fp)
 82403fc:	00000806 	br	8240420 <ip_fragment_lc+0x40c>
      }
      foffset += fragsize;    /* offset for next fragment */
 8240400:	e0fff317 	ldw	r3,-52(fp)
 8240404:	e0bffc17 	ldw	r2,-16(fp)
 8240408:	1885883a 	add	r2,r3,r2
 824040c:	e0bff315 	stw	r2,-52(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
   e = 0;
   while (left > 1)  /* more data left to send? */
 8240410:	e0bff517 	ldw	r2,-44(fp)
 8240414:	10800088 	cmpgei	r2,r2,2
 8240418:	103f5c1e 	bne	r2,zero,824018c <ip_fragment_lc+0x178>
         }
         return e;
      }
      foffset += fragsize;    /* offset for next fragment */
   }
   return e;
 824041c:	e0bff717 	ldw	r2,-36(fp)
}
 8240420:	e037883a 	mov	sp,fp
 8240424:	dfc00117 	ldw	ra,4(sp)
 8240428:	df000017 	ldw	fp,0(sp)
 824042c:	dec00204 	addi	sp,sp,8
 8240430:	f800283a 	ret

08240434 <ip_fragment>:
 *              generated fragment, if less than zero
 *          (5) 0, if everything went okay
 */

int ip_fragment(PACKET p, ip_addr firsthop)
{
 8240434:	defff004 	addi	sp,sp,-64
 8240438:	dfc00f15 	stw	ra,60(sp)
 824043c:	df000e15 	stw	fp,56(sp)
 8240440:	df000e04 	addi	fp,sp,56
 8240444:	e13ffe15 	stw	r4,-8(fp)
 8240448:	e17fff15 	stw	r5,-4(fp)
   u_short parent_mf;
   PACKET newpkt;
   struct ip * newpip;
   int e;

   pip = ip_head(p);
 824044c:	e0bffe17 	ldw	r2,-8(fp)
 8240450:	10800317 	ldw	r2,12(r2)
 8240454:	e0bff515 	stw	r2,-44(fp)
   if ((ntohs(pip->ip_flgs_foff)) & IP_FLG_DF)
 8240458:	e0bff517 	ldw	r2,-44(fp)
 824045c:	1080018b 	ldhu	r2,6(r2)
 8240460:	10bfffcc 	andi	r2,r2,65535
 8240464:	1004d23a 	srli	r2,r2,8
 8240468:	10bfffcc 	andi	r2,r2,65535
 824046c:	10c03fcc 	andi	r3,r2,255
 8240470:	e0bff517 	ldw	r2,-44(fp)
 8240474:	1080018b 	ldhu	r2,6(r2)
 8240478:	10bfffcc 	andi	r2,r2,65535
 824047c:	1004923a 	slli	r2,r2,8
 8240480:	10bfffcc 	andi	r2,r2,65535
 8240484:	1884b03a 	or	r2,r3,r2
 8240488:	1090000c 	andi	r2,r2,16384
 824048c:	10001c26 	beq	r2,zero,8240500 <ip_fragment+0xcc>
   {
      /* can't fragment a packet with the DF bit set */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 8240490:	01000084 	movi	r4,2
 8240494:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free(p);
 8240498:	e13ffe17 	ldw	r4,-8(fp)
 824049c:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82404a0:	01000084 	movi	r4,2
 82404a4:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      ip_mib.ipFragFails++;
 82404a8:	008209b4 	movhi	r2,2086
 82404ac:	10ba8304 	addi	r2,r2,-5620
 82404b0:	10801117 	ldw	r2,68(r2)
 82404b4:	10c00044 	addi	r3,r2,1
 82404b8:	008209b4 	movhi	r2,2086
 82404bc:	10ba8304 	addi	r2,r2,-5620
 82404c0:	10c01115 	stw	r3,68(r2)
#ifdef FULL_ICMP
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 82404c4:	e0bff517 	ldw	r2,-44(fp)
 82404c8:	10c00317 	ldw	r3,12(r2)
 82404cc:	e0bffe17 	ldw	r2,-8(fp)
 82404d0:	10800617 	ldw	r2,24(r2)
 82404d4:	11000a17 	ldw	r4,40(r2)
 82404d8:	e0bffe17 	ldw	r2,-8(fp)
 82404dc:	10800617 	ldw	r2,24(r2)
 82404e0:	d8800015 	stw	r2,0(sp)
 82404e4:	01c00104 	movi	r7,4
 82404e8:	e1bff517 	ldw	r6,-44(fp)
 82404ec:	200b883a 	mov	r5,r4
 82404f0:	1809883a 	mov	r4,r3
 82404f4:	824b0200 	call	824b020 <icmp_destun>
#endif   /* FULL_ICMP */
      return 0;
 82404f8:	0005883a 	mov	r2,zero
 82404fc:	00013906 	br	82409e4 <ip_fragment+0x5b0>
   }

   maxbuflen = pk_get_max_intrsafe_buf_len ();
 8240500:	822ce440 	call	822ce44 <pk_get_max_intrsafe_buf_len>
 8240504:	e0bff615 	stw	r2,-40(fp)

   /* the maximum amount of data that will be sent to ip2mac ().  Please note that
    * our definition of MTU is different from the traditional definition of that
    * parameter (which excludes the data link layer header). */
   maxl3_len = (unsigned short int) (MIN(maxbuflen, ((unsigned) p->net->n_mtu)));
 8240508:	e0bffe17 	ldw	r2,-8(fp)
 824050c:	10800617 	ldw	r2,24(r2)
 8240510:	10800917 	ldw	r2,36(r2)
 8240514:	1007883a 	mov	r3,r2
 8240518:	e0bff617 	ldw	r2,-40(fp)
 824051c:	10c0022e 	bgeu	r2,r3,8240528 <ip_fragment+0xf4>
 8240520:	e0bff617 	ldw	r2,-40(fp)
 8240524:	00000306 	br	8240534 <ip_fragment+0x100>
 8240528:	e0bffe17 	ldw	r2,-8(fp)
 824052c:	10800617 	ldw	r2,24(r2)
 8240530:	10800917 	ldw	r2,36(r2)
 8240534:	e0bff70d 	sth	r2,-36(fp)

   /* get the length of the IP header of the original, unfragmented datagram */
   iphlen = ip_hlen(pip);
 8240538:	e0bff517 	ldw	r2,-44(fp)
 824053c:	10800003 	ldbu	r2,0(r2)
 8240540:	108003cc 	andi	r2,r2,15
 8240544:	1085883a 	add	r2,r2,r2
 8240548:	1085883a 	add	r2,r2,r2
 824054c:	e0bff785 	stb	r2,-34(fp)

   /* obtain the useable payload length in an IP datagram (after accounting for the 
    * length of the IP and data link layer headers) */
   l2hdr_len = (u_char) p->net->n_lnh;
 8240550:	e0bffe17 	ldw	r2,-8(fp)
 8240554:	10800617 	ldw	r2,24(r2)
 8240558:	10800817 	ldw	r2,32(r2)
 824055c:	e0bff7c5 	stb	r2,-33(fp)
   useable_payload_len = maxl3_len - iphlen - l2hdr_len;
 8240560:	e0bff783 	ldbu	r2,-34(fp)
 8240564:	e0fff70b 	ldhu	r3,-36(fp)
 8240568:	1885c83a 	sub	r2,r3,r2
 824056c:	1007883a 	mov	r3,r2
 8240570:	e0bff7c3 	ldbu	r2,-33(fp)
 8240574:	1885c83a 	sub	r2,r3,r2
 8240578:	e0bff80d 	sth	r2,-32(fp)

   /* IP fragments must always have a length that is a multiple of 8 bytes, so we
    * need to round 'payload_len' down to the nearest multiple of 8 bytes. */
   useable_payload_len &= (~((unsigned short int) 0x07));
 824057c:	e0fff80b 	ldhu	r3,-32(fp)
 8240580:	00bffe04 	movi	r2,-8
 8240584:	1884703a 	and	r2,r3,r2
 8240588:	e0bff80d 	sth	r2,-32(fp)

   /* compute the number of packets that we need to send.  First compute the total
    * payload length of the "original" datagram (which could itself be a fragment). 
    */
   total_payload_len = (ntohs(pip->ip_len)) - iphlen;
 824058c:	e0bff517 	ldw	r2,-44(fp)
 8240590:	1080008b 	ldhu	r2,2(r2)
 8240594:	10bfffcc 	andi	r2,r2,65535
 8240598:	1004d23a 	srli	r2,r2,8
 824059c:	1007883a 	mov	r3,r2
 82405a0:	e0bff517 	ldw	r2,-44(fp)
 82405a4:	1080008b 	ldhu	r2,2(r2)
 82405a8:	10bfffcc 	andi	r2,r2,65535
 82405ac:	1004923a 	slli	r2,r2,8
 82405b0:	1884b03a 	or	r2,r3,r2
 82405b4:	1007883a 	mov	r3,r2
 82405b8:	e0bff783 	ldbu	r2,-34(fp)
 82405bc:	1885c83a 	sub	r2,r3,r2
 82405c0:	e0bff88d 	sth	r2,-30(fp)
   num_frags = (total_payload_len / useable_payload_len);
 82405c4:	e0bff88b 	ldhu	r2,-30(fp)
 82405c8:	e0fff80b 	ldhu	r3,-32(fp)
 82405cc:	180b883a 	mov	r5,r3
 82405d0:	1009883a 	mov	r4,r2
 82405d4:	8202c6c0 	call	8202c6c <__udivsi3>
 82405d8:	e0bff30d 	sth	r2,-52(fp)
   if ((last_payload_len = (total_payload_len % useable_payload_len)) != 0)
 82405dc:	e0bff88b 	ldhu	r2,-30(fp)
 82405e0:	e0fff80b 	ldhu	r3,-32(fp)
 82405e4:	180b883a 	mov	r5,r3
 82405e8:	1009883a 	mov	r4,r2
 82405ec:	8202cd00 	call	8202cd0 <__umodsi3>
 82405f0:	e0bff90d 	sth	r2,-28(fp)
 82405f4:	e0bff90b 	ldhu	r2,-28(fp)
 82405f8:	10000326 	beq	r2,zero,8240608 <ip_fragment+0x1d4>
   {
      /* we will have one additional (also last) fragment that is smaller than the 
       * other fragments */
      ++num_frags;
 82405fc:	e0bff30b 	ldhu	r2,-52(fp)
 8240600:	10800044 	addi	r2,r2,1
 8240604:	e0bff30d 	sth	r2,-52(fp)
    * the one passed to this function) is interrupt-safe, then we use 
    * ip_fragment_lc () for creating the child fragments.  This decreases the 
    * amount of copying that needs to be done in those cases (as compared to this 
    * function); however, for larger packets, ip_fragment () becomes more efficient 
    * (than ip_fragment_lc ()). */
   if ((num_frags <= FRAG_SCHEME_SWITCH_THRESHOLD) && (!(p->flags & PKF_INTRUNSAFE)))
 8240608:	e0bff30b 	ldhu	r2,-52(fp)
 824060c:	10800128 	cmpgeui	r2,r2,4
 8240610:	1000081e 	bne	r2,zero,8240634 <ip_fragment+0x200>
 8240614:	e0bffe17 	ldw	r2,-8(fp)
 8240618:	10800a17 	ldw	r2,40(r2)
 824061c:	1080040c 	andi	r2,r2,16
 8240620:	1000041e 	bne	r2,zero,8240634 <ip_fragment+0x200>
   {
      return (ip_fragment_lc (p, firsthop));
 8240624:	e17fff17 	ldw	r5,-4(fp)
 8240628:	e13ffe17 	ldw	r4,-8(fp)
 824062c:	82400140 	call	8240014 <ip_fragment_lc>
 8240630:	0000ec06 	br	82409e4 <ip_fragment+0x5b0>
   }

   parent_frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 8240634:	e0bff517 	ldw	r2,-44(fp)
 8240638:	1080018b 	ldhu	r2,6(r2)
 824063c:	10bfffcc 	andi	r2,r2,65535
 8240640:	1004d23a 	srli	r2,r2,8
 8240644:	10bfffcc 	andi	r2,r2,65535
 8240648:	10c03fcc 	andi	r3,r2,255
 824064c:	e0bff517 	ldw	r2,-44(fp)
 8240650:	1080018b 	ldhu	r2,6(r2)
 8240654:	10bfffcc 	andi	r2,r2,65535
 8240658:	1004923a 	slli	r2,r2,8
 824065c:	10bfffcc 	andi	r2,r2,65535
 8240660:	1884b03a 	or	r2,r3,r2
 8240664:	100490fa 	slli	r2,r2,3
 8240668:	e0bff98d 	sth	r2,-26(fp)
   parent_mf = ((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF);
 824066c:	e0bff517 	ldw	r2,-44(fp)
 8240670:	1080018b 	ldhu	r2,6(r2)
 8240674:	10bfffcc 	andi	r2,r2,65535
 8240678:	1004d23a 	srli	r2,r2,8
 824067c:	1007883a 	mov	r3,r2
 8240680:	e0bff517 	ldw	r2,-44(fp)
 8240684:	1080018b 	ldhu	r2,6(r2)
 8240688:	10bfffcc 	andi	r2,r2,65535
 824068c:	1004923a 	slli	r2,r2,8
 8240690:	1884b03a 	or	r2,r3,r2
 8240694:	1088000c 	andi	r2,r2,8192
 8240698:	e0bffa0d 	sth	r2,-24(fp)
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 824069c:	e03ff38d 	sth	zero,-50(fp)
 82406a0:	0000bf06 	br	82409a0 <ip_fragment+0x56c>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 82406a4:	01000084 	movi	r4,2
 82406a8:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      newpkt = pk_alloc (useable_payload_len + iphlen + l2hdr_len); 
 82406ac:	e0fff80b 	ldhu	r3,-32(fp)
 82406b0:	e0bff783 	ldbu	r2,-34(fp)
 82406b4:	1887883a 	add	r3,r3,r2
 82406b8:	e0bff7c3 	ldbu	r2,-33(fp)
 82406bc:	1885883a 	add	r2,r3,r2
 82406c0:	1009883a 	mov	r4,r2
 82406c4:	822ca480 	call	822ca48 <pk_alloc>
 82406c8:	e0bffb15 	stw	r2,-20(fp)
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82406cc:	01000084 	movi	r4,2
 82406d0:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>

      if (newpkt == 0)
 82406d4:	e0bffb17 	ldw	r2,-20(fp)
 82406d8:	10000f1e 	bne	r2,zero,8240718 <ip_fragment+0x2e4>
      {
         /* free the packet that we are working with */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 82406dc:	01000084 	movi	r4,2
 82406e0:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
         pk_free(p);
 82406e4:	e13ffe17 	ldw	r4,-8(fp)
 82406e8:	822cd980 	call	822cd98 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82406ec:	01000084 	movi	r4,2
 82406f0:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         ip_mib.ipFragFails++;
 82406f4:	008209b4 	movhi	r2,2086
 82406f8:	10ba8304 	addi	r2,r2,-5620
 82406fc:	10801117 	ldw	r2,68(r2)
 8240700:	10c00044 	addi	r3,r2,1
 8240704:	008209b4 	movhi	r2,2086
 8240708:	10ba8304 	addi	r2,r2,-5620
 824070c:	10c01115 	stw	r3,68(r2)
         return ENP_NOBUFFER;
 8240710:	00bffac4 	movi	r2,-21
 8240714:	0000b306 	br	82409e4 <ip_fragment+0x5b0>
      }
      else
      {
         /* copy the IP header from the original datagram into the fragment */
         MEMCPY((newpkt->nb_buff + l2hdr_len), p->nb_prot, iphlen);
 8240718:	e0bffb17 	ldw	r2,-20(fp)
 824071c:	10c00117 	ldw	r3,4(r2)
 8240720:	e0bff7c3 	ldbu	r2,-33(fp)
 8240724:	1887883a 	add	r3,r3,r2
 8240728:	e0bffe17 	ldw	r2,-8(fp)
 824072c:	10800317 	ldw	r2,12(r2)
 8240730:	e13ff783 	ldbu	r4,-34(fp)
 8240734:	200d883a 	mov	r6,r4
 8240738:	100b883a 	mov	r5,r2
 824073c:	1809883a 	mov	r4,r3
 8240740:	8202f6c0 	call	8202f6c <memcpy>

         /* compute the amount of payload that needs to be copied into each 
          * child fragment */
         if (i < (num_frags - 1))
 8240744:	e0fff38b 	ldhu	r3,-50(fp)
 8240748:	e0bff30b 	ldhu	r2,-52(fp)
 824074c:	10bfffc4 	addi	r2,r2,-1
 8240750:	1880030e 	bge	r3,r2,8240760 <ip_fragment+0x32c>
         {
            amt_to_copy = useable_payload_len;
 8240754:	e0bff80b 	ldhu	r2,-32(fp)
 8240758:	e0bff40d 	sth	r2,-48(fp)
 824075c:	00000606 	br	8240778 <ip_fragment+0x344>
         }
         else
         {
            amt_to_copy = ((last_payload_len == 0) ? useable_payload_len : last_payload_len);
 8240760:	e0bff90b 	ldhu	r2,-28(fp)
 8240764:	1000021e 	bne	r2,zero,8240770 <ip_fragment+0x33c>
 8240768:	e0bff80b 	ldhu	r2,-32(fp)
 824076c:	00000106 	br	8240774 <ip_fragment+0x340>
 8240770:	e0bff90b 	ldhu	r2,-28(fp)
 8240774:	e0bff40d 	sth	r2,-48(fp)
         }
         MEMCPY((newpkt->nb_buff + l2hdr_len + iphlen), p->nb_prot + iphlen + (useable_payload_len * i), amt_to_copy);
 8240778:	e0bffb17 	ldw	r2,-20(fp)
 824077c:	10c00117 	ldw	r3,4(r2)
 8240780:	e13ff7c3 	ldbu	r4,-33(fp)
 8240784:	e0bff783 	ldbu	r2,-34(fp)
 8240788:	2085883a 	add	r2,r4,r2
 824078c:	188f883a 	add	r7,r3,r2
 8240790:	e0bffe17 	ldw	r2,-8(fp)
 8240794:	10c00317 	ldw	r3,12(r2)
 8240798:	e0bff783 	ldbu	r2,-34(fp)
 824079c:	e17ff80b 	ldhu	r5,-32(fp)
 82407a0:	e13ff38b 	ldhu	r4,-50(fp)
 82407a4:	2909383a 	mul	r4,r5,r4
 82407a8:	1105883a 	add	r2,r2,r4
 82407ac:	1885883a 	add	r2,r3,r2
 82407b0:	e0fff40b 	ldhu	r3,-48(fp)
 82407b4:	180d883a 	mov	r6,r3
 82407b8:	100b883a 	mov	r5,r2
 82407bc:	3809883a 	mov	r4,r7
 82407c0:	8202f6c0 	call	8202f6c <memcpy>

         /* set up the various netbuf fields for the fragment */
         newpkt->nb_prot = newpkt->nb_buff + l2hdr_len;
 82407c4:	e0bffb17 	ldw	r2,-20(fp)
 82407c8:	10c00117 	ldw	r3,4(r2)
 82407cc:	e0bff7c3 	ldbu	r2,-33(fp)
 82407d0:	1887883a 	add	r3,r3,r2
 82407d4:	e0bffb17 	ldw	r2,-20(fp)
 82407d8:	10c00315 	stw	r3,12(r2)
         newpkt->nb_plen = iphlen + amt_to_copy;
 82407dc:	e0fff783 	ldbu	r3,-34(fp)
 82407e0:	e0bff40b 	ldhu	r2,-48(fp)
 82407e4:	1885883a 	add	r2,r3,r2
 82407e8:	1007883a 	mov	r3,r2
 82407ec:	e0bffb17 	ldw	r2,-20(fp)
 82407f0:	10c00415 	stw	r3,16(r2)
         newpkt->net = p->net;
 82407f4:	e0bffe17 	ldw	r2,-8(fp)
 82407f8:	10c00617 	ldw	r3,24(r2)
 82407fc:	e0bffb17 	ldw	r2,-20(fp)
 8240800:	10c00615 	stw	r3,24(r2)
         newpkt->fhost = p->fhost;
 8240804:	e0bffe17 	ldw	r2,-8(fp)
 8240808:	10c00717 	ldw	r3,28(r2)
 824080c:	e0bffb17 	ldw	r2,-20(fp)
 8240810:	10c00715 	stw	r3,28(r2)
         /* type and nb_tstamp fields are not used in the egress direction, but we set 'type' anyway */
         newpkt->type = htons(IPTP);
 8240814:	e0bffb17 	ldw	r2,-20(fp)
 8240818:	00c20004 	movi	r3,2048
 824081c:	10c0080d 	sth	r3,32(r2)

         /* now set the Total Length, Fragment Offset, and More Fragments fields */
         newpip = ip_head(newpkt);
 8240820:	e0bffb17 	ldw	r2,-20(fp)
 8240824:	10800317 	ldw	r2,12(r2)
 8240828:	e0bffc15 	stw	r2,-16(fp)
         newpip->ip_len = htons(newpkt->nb_plen);
 824082c:	e0bffb17 	ldw	r2,-20(fp)
 8240830:	10800417 	ldw	r2,16(r2)
 8240834:	1004d23a 	srli	r2,r2,8
 8240838:	10803fcc 	andi	r2,r2,255
 824083c:	1007883a 	mov	r3,r2
 8240840:	e0bffb17 	ldw	r2,-20(fp)
 8240844:	10800417 	ldw	r2,16(r2)
 8240848:	1004923a 	slli	r2,r2,8
 824084c:	1884b03a 	or	r2,r3,r2
 8240850:	1007883a 	mov	r3,r2
 8240854:	e0bffc17 	ldw	r2,-16(fp)
 8240858:	10c0008d 	sth	r3,2(r2)
         /* the following statement will reset DF and MF bits */
         newpip->ip_flgs_foff = htons((parent_frag_offset + (useable_payload_len * i)) >> 3);
 824085c:	e0fff98b 	ldhu	r3,-26(fp)
 8240860:	e13ff80b 	ldhu	r4,-32(fp)
 8240864:	e0bff38b 	ldhu	r2,-50(fp)
 8240868:	2085383a 	mul	r2,r4,r2
 824086c:	1885883a 	add	r2,r3,r2
 8240870:	1005d2fa 	srai	r2,r2,11
 8240874:	10803fcc 	andi	r2,r2,255
 8240878:	100b883a 	mov	r5,r2
 824087c:	e0fff98b 	ldhu	r3,-26(fp)
 8240880:	e13ff80b 	ldhu	r4,-32(fp)
 8240884:	e0bff38b 	ldhu	r2,-50(fp)
 8240888:	2085383a 	mul	r2,r4,r2
 824088c:	1885883a 	add	r2,r3,r2
 8240890:	1005d0fa 	srai	r2,r2,3
 8240894:	1004923a 	slli	r2,r2,8
 8240898:	2884b03a 	or	r2,r5,r2
 824089c:	1007883a 	mov	r3,r2
 82408a0:	e0bffc17 	ldw	r2,-16(fp)
 82408a4:	10c0018d 	sth	r3,6(r2)
          *     child fragments but the last will have the MF bit set)
          * (2) Parent fragment offset = x, MF = 1: first or middle fragment (FF or MF)
          *     (all child fragments will have the MF bit set)
          * (3) Parent fragment offset > 0, MF = 0: last fragment (LF) (all child fragments
          *     except the last will have the MF bit set) */
         if (i < (num_frags - 1))
 82408a8:	e0fff38b 	ldhu	r3,-50(fp)
 82408ac:	e0bff30b 	ldhu	r2,-52(fp)
 82408b0:	10bfffc4 	addi	r2,r2,-1
 82408b4:	1880070e 	bge	r3,r2,82408d4 <ip_fragment+0x4a0>
         {
            newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 82408b8:	e0bffc17 	ldw	r2,-16(fp)
 82408bc:	1080018b 	ldhu	r2,6(r2)
 82408c0:	10800814 	ori	r2,r2,32
 82408c4:	1007883a 	mov	r3,r2
 82408c8:	e0bffc17 	ldw	r2,-16(fp)
 82408cc:	10c0018d 	sth	r3,6(r2)
 82408d0:	00000806 	br	82408f4 <ip_fragment+0x4c0>
         }
         else
         {
            if (parent_mf)
 82408d4:	e0bffa0b 	ldhu	r2,-24(fp)
 82408d8:	10000626 	beq	r2,zero,82408f4 <ip_fragment+0x4c0>
            {
               newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 82408dc:	e0bffc17 	ldw	r2,-16(fp)
 82408e0:	1080018b 	ldhu	r2,6(r2)
 82408e4:	10800814 	ori	r2,r2,32
 82408e8:	1007883a 	mov	r3,r2
 82408ec:	e0bffc17 	ldw	r2,-16(fp)
 82408f0:	10c0018d 	sth	r3,6(r2)
            }
         }

         /* finally, update the checksum */
         newpip->ip_chksum = IPXSUM;
 82408f4:	e0bffc17 	ldw	r2,-16(fp)
 82408f8:	1000028d 	sth	zero,10(r2)
         newpip->ip_chksum = ~cksum(newpip, (iphlen/2));
 82408fc:	e0bff783 	ldbu	r2,-34(fp)
 8240900:	1004d07a 	srli	r2,r2,1
 8240904:	10803fcc 	andi	r2,r2,255
 8240908:	100b883a 	mov	r5,r2
 824090c:	e13ffc17 	ldw	r4,-16(fp)
 8240910:	82288100 	call	8228810 <cksum>
 8240914:	0084303a 	nor	r2,zero,r2
 8240918:	1007883a 	mov	r3,r2
 824091c:	e0bffc17 	ldw	r2,-16(fp)
 8240920:	10c0028d 	sth	r3,10(r2)

         ip_mib.ipFragCreates++;
 8240924:	008209b4 	movhi	r2,2086
 8240928:	10ba8304 	addi	r2,r2,-5620
 824092c:	10801217 	ldw	r2,72(r2)
 8240930:	10c00044 	addi	r3,r2,1
 8240934:	008209b4 	movhi	r2,2086
 8240938:	10ba8304 	addi	r2,r2,-5620
 824093c:	10c01215 	stw	r3,72(r2)

         /* we're done; hand the packet off to ip2mac () */
         e = ip2mac (newpkt, firsthop);
 8240940:	e17fff17 	ldw	r5,-4(fp)
 8240944:	e13ffb17 	ldw	r4,-20(fp)
 8240948:	82267540 	call	8226754 <ip2mac>
 824094c:	e0bffd15 	stw	r2,-12(fp)
         if (e < 0)
 8240950:	e0bffd17 	ldw	r2,-12(fp)
 8240954:	10000f0e 	bge	r2,zero,8240994 <ip_fragment+0x560>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 8240958:	01000084 	movi	r4,2
 824095c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
            pk_free(p);
 8240960:	e13ffe17 	ldw	r4,-8(fp)
 8240964:	822cd980 	call	822cd98 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8240968:	01000084 	movi	r4,2
 824096c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 8240970:	008209b4 	movhi	r2,2086
 8240974:	10ba8304 	addi	r2,r2,-5620
 8240978:	10801117 	ldw	r2,68(r2)
 824097c:	10c00044 	addi	r3,r2,1
 8240980:	008209b4 	movhi	r2,2086
 8240984:	10ba8304 	addi	r2,r2,-5620
 8240988:	10c01115 	stw	r3,68(r2)
            return e;
 824098c:	e0bffd17 	ldw	r2,-12(fp)
 8240990:	00001406 	br	82409e4 <ip_fragment+0x5b0>
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 8240994:	e0bff38b 	ldhu	r2,-50(fp)
 8240998:	10800044 	addi	r2,r2,1
 824099c:	e0bff38d 	sth	r2,-50(fp)
 82409a0:	e0fff38b 	ldhu	r3,-50(fp)
 82409a4:	e0bff30b 	ldhu	r2,-52(fp)
 82409a8:	18bf3e36 	bltu	r3,r2,82406a4 <ip_fragment+0x270>

   } /* end FOR (all child fragments) */

   /* free the parent buffer since all of the data from it have been copied 
    * out into the child fragments */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 82409ac:	01000084 	movi	r4,2
 82409b0:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   pk_free(p);
 82409b4:	e13ffe17 	ldw	r4,-8(fp)
 82409b8:	822cd980 	call	822cd98 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82409bc:	01000084 	movi	r4,2
 82409c0:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 82409c4:	008209b4 	movhi	r2,2086
 82409c8:	10ba8304 	addi	r2,r2,-5620
 82409cc:	10801017 	ldw	r2,64(r2)
 82409d0:	10c00044 	addi	r3,r2,1
 82409d4:	008209b4 	movhi	r2,2086
 82409d8:	10ba8304 	addi	r2,r2,-5620
 82409dc:	10c01015 	stw	r3,64(r2)

   return 0;
 82409e0:	0005883a 	mov	r2,zero
}
 82409e4:	e037883a 	mov	sp,fp
 82409e8:	dfc00117 	ldw	ra,4(sp)
 82409ec:	df000017 	ldw	fp,0(sp)
 82409f0:	dec00204 	addi	sp,sp,8
 82409f4:	f800283a 	ret

082409f8 <ip_mymach>:
 * certain foreign host. 
 */

ip_addr
ip_mymach(ip_addr host)
{
 82409f8:	defffa04 	addi	sp,sp,-24
 82409fc:	dfc00515 	stw	ra,20(sp)
 8240a00:	df000415 	stw	fp,16(sp)
 8240a04:	df000404 	addi	fp,sp,16
 8240a08:	e13fff15 	stw	r4,-4(fp)

#ifndef MULTI_HOMED /* single static interface */
   USE_ARG(host);
   return(nets[0]->n_ipaddr);   /* always use address from only net */
#else   /* MULTI_HOMED */
   tnet = iproute(host, &temp);
 8240a0c:	e0bffe04 	addi	r2,fp,-8
 8240a10:	100b883a 	mov	r5,r2
 8240a14:	e13fff17 	ldw	r4,-4(fp)
 8240a18:	8240d440 	call	8240d44 <iproute>
 8240a1c:	e0bffd15 	stw	r2,-12(fp)
   if (tnet == 0)
 8240a20:	e0bffd17 	ldw	r2,-12(fp)
 8240a24:	1000161e 	bne	r2,zero,8240a80 <ip_mymach+0x88>
   {
#ifdef   NPDEBUG
      if (NDEBUG & (PROTERR|INFOMSG))
 8240a28:	d0a08317 	ldw	r2,-32244(gp)
 8240a2c:	1080050c 	andi	r2,r2,20
 8240a30:	10001126 	beq	r2,zero,8240a78 <ip_mymach+0x80>
         dprintf("IP: Couldn't route to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 8240a34:	e0bfff17 	ldw	r2,-4(fp)
 8240a38:	10c03fcc 	andi	r3,r2,255
 8240a3c:	e0bfff17 	ldw	r2,-4(fp)
 8240a40:	1004d23a 	srli	r2,r2,8
 8240a44:	11003fcc 	andi	r4,r2,255
 8240a48:	e0bfff17 	ldw	r2,-4(fp)
 8240a4c:	1004d43a 	srli	r2,r2,16
 8240a50:	11403fcc 	andi	r5,r2,255
 8240a54:	e0bfff17 	ldw	r2,-4(fp)
 8240a58:	1004d63a 	srli	r2,r2,24
 8240a5c:	d8800015 	stw	r2,0(sp)
 8240a60:	280f883a 	mov	r7,r5
 8240a64:	200d883a 	mov	r6,r4
 8240a68:	180b883a 	mov	r5,r3
 8240a6c:	01020974 	movhi	r4,2085
 8240a70:	2104b404 	addi	r4,r4,4816
 8240a74:	82033fc0 	call	82033fc <printf>
#endif   /* NPDEBUG */
      return 0L;
 8240a78:	0005883a 	mov	r2,zero
 8240a7c:	00000206 	br	8240a88 <ip_mymach+0x90>
   }
   return tnet->n_ipaddr;
 8240a80:	e0bffd17 	ldw	r2,-12(fp)
 8240a84:	10800a17 	ldw	r2,40(r2)
#endif /* MULTI_HOMED */
}
 8240a88:	e037883a 	mov	sp,fp
 8240a8c:	dfc00117 	ldw	ra,4(sp)
 8240a90:	df000017 	ldw	fp,0(sp)
 8240a94:	dec00204 	addi	sp,sp,8
 8240a98:	f800283a 	ret

08240a9c <ip_dump>:
 * RETURNS: void
 */

void
ip_dump(PACKET p)
{
 8240a9c:	defff704 	addi	sp,sp,-36
 8240aa0:	dfc00815 	stw	ra,32(sp)
 8240aa4:	df000715 	stw	fp,28(sp)
 8240aa8:	df000704 	addi	fp,sp,28
 8240aac:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;
   unsigned char * cp;
   unsigned short xsum, osum;

   pip = ip_head(p);
 8240ab0:	e0bfff17 	ldw	r2,-4(fp)
 8240ab4:	10800317 	ldw	r2,12(r2)
 8240ab8:	e0bffc15 	stw	r2,-16(fp)
   osum = pip->ip_chksum;
 8240abc:	e0bffc17 	ldw	r2,-16(fp)
 8240ac0:	1080028b 	ldhu	r2,10(r2)
 8240ac4:	e0bffd0d 	sth	r2,-12(fp)
   pip->ip_chksum = 0;
 8240ac8:	e0bffc17 	ldw	r2,-16(fp)
 8240acc:	1000028d 	sth	zero,10(r2)
   xsum = ~cksum(pip, ip_hlen(pip) >> 1);
 8240ad0:	e0bffc17 	ldw	r2,-16(fp)
 8240ad4:	10800003 	ldbu	r2,0(r2)
 8240ad8:	10803fcc 	andi	r2,r2,255
 8240adc:	108003cc 	andi	r2,r2,15
 8240ae0:	1085883a 	add	r2,r2,r2
 8240ae4:	1085883a 	add	r2,r2,r2
 8240ae8:	1005d07a 	srai	r2,r2,1
 8240aec:	100b883a 	mov	r5,r2
 8240af0:	e13ffc17 	ldw	r4,-16(fp)
 8240af4:	82288100 	call	8228810 <cksum>
 8240af8:	0084303a 	nor	r2,zero,r2
 8240afc:	e0bffd8d 	sth	r2,-10(fp)

   if (osum != xsum)          /* trap here if checksum is wrong */
 8240b00:	e0fffd0b 	ldhu	r3,-12(fp)
 8240b04:	e0bffd8b 	ldhu	r2,-10(fp)
 8240b08:	18800126 	beq	r3,r2,8240b10 <ip_dump+0x74>
   {
      dtrap();
 8240b0c:	822d5f00 	call	822d5f0 <dtrap>
   /* dtrap() is fatal in the default Windows implementation, so
    * we comment it out */
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
 8240b10:	01420974 	movhi	r5,2085
 8240b14:	2944bd04 	addi	r5,r5,4852
 8240b18:	0009883a 	mov	r4,zero
 8240b1c:	8228ebc0 	call	8228ebc <ns_printf>
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
 8240b20:	e0bffc17 	ldw	r2,-16(fp)
 8240b24:	e0bffe15 	stw	r2,-8(fp)
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 8240b28:	e0bffe17 	ldw	r2,-8(fp)
 8240b2c:	10800003 	ldbu	r2,0(r2)
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 8240b30:	11403fcc 	andi	r5,r2,255
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 8240b34:	e0bffe17 	ldw	r2,-8(fp)
 8240b38:	10800044 	addi	r2,r2,1
 8240b3c:	10800003 	ldbu	r2,0(r2)
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 8240b40:	11803fcc 	andi	r6,r2,255
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 8240b44:	e0bffc17 	ldw	r2,-16(fp)
 8240b48:	1080008b 	ldhu	r2,2(r2)
 8240b4c:	10bfffcc 	andi	r2,r2,65535
 8240b50:	1004d23a 	srli	r2,r2,8
 8240b54:	10bfffcc 	andi	r2,r2,65535
 8240b58:	10c03fcc 	andi	r3,r2,255
 8240b5c:	e0bffc17 	ldw	r2,-16(fp)
 8240b60:	1080008b 	ldhu	r2,2(r2)
 8240b64:	10bfffcc 	andi	r2,r2,65535
 8240b68:	1004923a 	slli	r2,r2,8
 8240b6c:	10bfffcc 	andi	r2,r2,65535
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 8240b70:	1884b03a 	or	r2,r3,r2
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 8240b74:	e0fffc17 	ldw	r3,-16(fp)
 8240b78:	18c0010b 	ldhu	r3,4(r3)
 8240b7c:	18ffffcc 	andi	r3,r3,65535
 8240b80:	1806d23a 	srli	r3,r3,8
 8240b84:	18ffffcc 	andi	r3,r3,65535
 8240b88:	19003fcc 	andi	r4,r3,255
 8240b8c:	e0fffc17 	ldw	r3,-16(fp)
 8240b90:	18c0010b 	ldhu	r3,4(r3)
 8240b94:	18ffffcc 	andi	r3,r3,65535
 8240b98:	1806923a 	slli	r3,r3,8
 8240b9c:	18ffffcc 	andi	r3,r3,65535
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 8240ba0:	20c6b03a 	or	r3,r4,r3
 8240ba4:	d8c00115 	stw	r3,4(sp)
 8240ba8:	d8800015 	stw	r2,0(sp)
 8240bac:	300f883a 	mov	r7,r6
 8240bb0:	280d883a 	mov	r6,r5
 8240bb4:	01420974 	movhi	r5,2085
 8240bb8:	2944c204 	addi	r5,r5,4872
 8240bbc:	0009883a 	mov	r4,zero
 8240bc0:	8228ebc0 	call	8228ebc <ns_printf>
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
 8240bc4:	e0bffe17 	ldw	r2,-8(fp)
 8240bc8:	10800184 	addi	r2,r2,6
 8240bcc:	1080000b 	ldhu	r2,0(r2)
 8240bd0:	10bfffcc 	andi	r2,r2,65535
 8240bd4:	1004d23a 	srli	r2,r2,8
 8240bd8:	10bfffcc 	andi	r2,r2,65535
 8240bdc:	10c03fcc 	andi	r3,r2,255
 8240be0:	e0bffe17 	ldw	r2,-8(fp)
 8240be4:	10800184 	addi	r2,r2,6
 8240be8:	1080000b 	ldhu	r2,0(r2)
 8240bec:	10bfffcc 	andi	r2,r2,65535
 8240bf0:	1004923a 	slli	r2,r2,8
 8240bf4:	10bfffcc 	andi	r2,r2,65535

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 8240bf8:	188cb03a 	or	r6,r3,r2
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
 8240bfc:	e0bffc17 	ldw	r2,-16(fp)
 8240c00:	10800203 	ldbu	r2,8(r2)

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 8240c04:	11c03fcc 	andi	r7,r2,255
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
 8240c08:	e0bffc17 	ldw	r2,-16(fp)
 8240c0c:	10800243 	ldbu	r2,9(r2)

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 8240c10:	10c03fcc 	andi	r3,r2,255
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
    htons(osum), (osum==xsum)?"ok":"bad");
 8240c14:	e0bffd0b 	ldhu	r2,-12(fp)
 8240c18:	1004d23a 	srli	r2,r2,8
 8240c1c:	10bfffcc 	andi	r2,r2,65535
 8240c20:	11003fcc 	andi	r4,r2,255
 8240c24:	e0bffd0b 	ldhu	r2,-12(fp)
 8240c28:	1004923a 	slli	r2,r2,8
 8240c2c:	10bfffcc 	andi	r2,r2,65535

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 8240c30:	2088b03a 	or	r4,r4,r2
 8240c34:	e17ffd0b 	ldhu	r5,-12(fp)
 8240c38:	e0bffd8b 	ldhu	r2,-10(fp)
 8240c3c:	2880031e 	bne	r5,r2,8240c4c <ip_dump+0x1b0>
 8240c40:	00820974 	movhi	r2,2085
 8240c44:	1084ce04 	addi	r2,r2,4920
 8240c48:	00000206 	br	8240c54 <ip_dump+0x1b8>
 8240c4c:	00820974 	movhi	r2,2085
 8240c50:	1084cf04 	addi	r2,r2,4924
 8240c54:	d8800215 	stw	r2,8(sp)
 8240c58:	d9000115 	stw	r4,4(sp)
 8240c5c:	d8c00015 	stw	r3,0(sp)
 8240c60:	01420974 	movhi	r5,2085
 8240c64:	2944d004 	addi	r5,r5,4928
 8240c68:	0009883a 	mov	r4,zero
 8240c6c:	8228ebc0 	call	8228ebc <ns_printf>
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
    htons(osum), (osum==xsum)?"ok":"bad");
   ns_printf(NULL ,"src: %u.%u.%u.%u  ", PUSH_IPADDR(pip->ip_src));
 8240c70:	e0bffc17 	ldw	r2,-16(fp)
 8240c74:	10800317 	ldw	r2,12(r2)
 8240c78:	11003fcc 	andi	r4,r2,255
 8240c7c:	e0bffc17 	ldw	r2,-16(fp)
 8240c80:	10800317 	ldw	r2,12(r2)
 8240c84:	1004d23a 	srli	r2,r2,8
 8240c88:	11403fcc 	andi	r5,r2,255
 8240c8c:	e0bffc17 	ldw	r2,-16(fp)
 8240c90:	10800317 	ldw	r2,12(r2)
 8240c94:	1004d43a 	srli	r2,r2,16
 8240c98:	10803fcc 	andi	r2,r2,255
 8240c9c:	e0fffc17 	ldw	r3,-16(fp)
 8240ca0:	18c00317 	ldw	r3,12(r3)
 8240ca4:	1806d63a 	srli	r3,r3,24
 8240ca8:	d8c00115 	stw	r3,4(sp)
 8240cac:	d8800015 	stw	r2,0(sp)
 8240cb0:	280f883a 	mov	r7,r5
 8240cb4:	200d883a 	mov	r6,r4
 8240cb8:	01420974 	movhi	r5,2085
 8240cbc:	2944e004 	addi	r5,r5,4992
 8240cc0:	0009883a 	mov	r4,zero
 8240cc4:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf(NULL ,"dest: %u.%u.%u.%u\n", PUSH_IPADDR(pip->ip_dest));
 8240cc8:	e0bffc17 	ldw	r2,-16(fp)
 8240ccc:	10800417 	ldw	r2,16(r2)
 8240cd0:	11003fcc 	andi	r4,r2,255
 8240cd4:	e0bffc17 	ldw	r2,-16(fp)
 8240cd8:	10800417 	ldw	r2,16(r2)
 8240cdc:	1004d23a 	srli	r2,r2,8
 8240ce0:	11403fcc 	andi	r5,r2,255
 8240ce4:	e0bffc17 	ldw	r2,-16(fp)
 8240ce8:	10800417 	ldw	r2,16(r2)
 8240cec:	1004d43a 	srli	r2,r2,16
 8240cf0:	10803fcc 	andi	r2,r2,255
 8240cf4:	e0fffc17 	ldw	r3,-16(fp)
 8240cf8:	18c00417 	ldw	r3,16(r3)
 8240cfc:	1806d63a 	srli	r3,r3,24
 8240d00:	d8c00115 	stw	r3,4(sp)
 8240d04:	d8800015 	stw	r2,0(sp)
 8240d08:	280f883a 	mov	r7,r5
 8240d0c:	200d883a 	mov	r6,r4
 8240d10:	01420974 	movhi	r5,2085
 8240d14:	2944e504 	addi	r5,r5,5012
 8240d18:	0009883a 	mov	r4,zero
 8240d1c:	8228ebc0 	call	8228ebc <ns_printf>

   pip->ip_chksum = osum;     /* fix what we clobbered */
 8240d20:	e0bffc17 	ldw	r2,-16(fp)
 8240d24:	e0fffd0b 	ldhu	r3,-12(fp)
 8240d28:	10c0028d 	sth	r3,10(r2)
}
 8240d2c:	0001883a 	nop
 8240d30:	e037883a 	mov	sp,fp
 8240d34:	dfc00117 	ldw	ra,4(sp)
 8240d38:	df000017 	ldw	fp,0(sp)
 8240d3c:	dec00204 	addi	sp,sp,8
 8240d40:	f800283a 	ret

08240d44 <iproute>:
 * RETURNS: Returns NULL when unable to route, else returns a NET pointer.
 */

NET
iproute(ip_addr host, ip_addr * hop1)
{
 8240d44:	defff804 	addi	sp,sp,-32
 8240d48:	dfc00715 	stw	ra,28(sp)
 8240d4c:	df000615 	stw	fp,24(sp)
 8240d50:	df000604 	addi	fp,sp,24
 8240d54:	e13ffe15 	stw	r4,-8(fp)
 8240d58:	e17fff15 	stw	r5,-4(fp)
   NET      ifp;
#ifdef IP_ROUTING
   RTMIB    rtp;
#endif   /* IP_ROUTING */

   if (host == 0L)      /* Sanity check parameter. */
 8240d5c:	e0bffe17 	ldw	r2,-8(fp)
 8240d60:	1000021e 	bne	r2,zero,8240d6c <iproute+0x28>
      return NULL;
 8240d64:	0005883a 	mov	r2,zero
 8240d68:	00006706 	br	8240f08 <iproute+0x1c4>
    * stack has been initialized (tk_yield() gets called out of the 
    * dialer code as part of PPP initialization), one symptom of 
    * which is the routing table not being present yet. if this 
    * happens, quit. 
    */
   if (rt_mib == NULL)
 8240d6c:	d0a0c617 	ldw	r2,-31976(gp)
 8240d70:	1000021e 	bne	r2,zero,8240d7c <iproute+0x38>
      return NULL;
 8240d74:	0005883a 	mov	r2,zero
 8240d78:	00006306 	br	8240f08 <iproute+0x1c4>
#endif   /* BTREE_ROUTING */

   /* see if the host matches the cached route */
   if (cachedRoute)     /* don't test this if route is null  */
 8240d7c:	d0a0d017 	ldw	r2,-31936(gp)
 8240d80:	10000e26 	beq	r2,zero,8240dbc <iproute+0x78>
   {
      if (cachedRoute->ipRouteDest == host)    /* exact match */
 8240d84:	d0a0d017 	ldw	r2,-31936(gp)
 8240d88:	10c00017 	ldw	r3,0(r2)
 8240d8c:	e0bffe17 	ldw	r2,-8(fp)
 8240d90:	18800a1e 	bne	r3,r2,8240dbc <iproute+0x78>
      {
         *hop1 = cachedRoute->ipRouteNextHop;   /* fill in nexthop IP addr */
 8240d94:	d0a0d017 	ldw	r2,-31936(gp)
 8240d98:	10c00617 	ldw	r3,24(r2)
 8240d9c:	e0bfff17 	ldw	r2,-4(fp)
 8240da0:	10c00015 	stw	r3,0(r2)
         cachedRoute->ipRouteAge = cticks;      /* timestamp route entry */
 8240da4:	d0a0d017 	ldw	r2,-31936(gp)
 8240da8:	d0e0a817 	ldw	r3,-32096(gp)
 8240dac:	10c00915 	stw	r3,36(r2)
         return(cachedRoute->ifp); /* net to send on */
 8240db0:	d0a0d017 	ldw	r2,-31936(gp)
 8240db4:	10800e17 	ldw	r2,56(r2)
 8240db8:	00005306 	br	8240f08 <iproute+0x1c4>
      }
   }

   rtp = rt_lookup(host);
 8240dbc:	e13ffe17 	ldw	r4,-8(fp)
 8240dc0:	82442380 	call	8244238 <rt_lookup>
 8240dc4:	e0bffd15 	stw	r2,-12(fp)
   if(rtp)
 8240dc8:	e0bffd17 	ldw	r2,-12(fp)
 8240dcc:	10000926 	beq	r2,zero,8240df4 <iproute+0xb0>
   {
      cachedRoute = rtp;
 8240dd0:	e0bffd17 	ldw	r2,-12(fp)
 8240dd4:	d0a0d015 	stw	r2,-31936(gp)
      *hop1 = rtp->ipRouteNextHop;  /* fill in IP dest (next hop) */
 8240dd8:	e0bffd17 	ldw	r2,-12(fp)
 8240ddc:	10c00617 	ldw	r3,24(r2)
 8240de0:	e0bfff17 	ldw	r2,-4(fp)
 8240de4:	10c00015 	stw	r3,0(r2)
      return(rtp->ifp);             /* return pointer to net */
 8240de8:	e0bffd17 	ldw	r2,-12(fp)
 8240dec:	10800e17 	ldw	r2,56(r2)
 8240df0:	00004506 	br	8240f08 <iproute+0x1c4>
    * the initial state for the for loop that iterates through the
    * list), but only build the iterator for multi-homed systems
    * because single-homed systems are often memory-limited systems as
    * well.  
    */
   ifp = (NET)(netlist.q_head);
 8240df4:	008209b4 	movhi	r2,2086
 8240df8:	10ba7e04 	addi	r2,r2,-5640
 8240dfc:	10800017 	ldw	r2,0(r2)
 8240e00:	e0bffc15 	stw	r2,-16(fp)
   i = 0;
 8240e04:	e03ffb15 	stw	zero,-20(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 8240e08:	00002406 	br	8240e9c <iproute+0x158>
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
 8240e0c:	e0bffc17 	ldw	r2,-16(fp)
 8240e10:	10800c17 	ldw	r2,48(r2)
 8240e14:	10001b26 	beq	r2,zero,8240e84 <iproute+0x140>
         (ifp->n_ipaddr != 0) && 
 8240e18:	e0bffc17 	ldw	r2,-16(fp)
 8240e1c:	10800a17 	ldw	r2,40(r2)
   i = 0;
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
 8240e20:	10001826 	beq	r2,zero,8240e84 <iproute+0x140>
         (ifp->n_ipaddr != 0) && 
         ((ifp->n_ipaddr & ifp->snmask) == (host & ifp->snmask)))
 8240e24:	e0bffc17 	ldw	r2,-16(fp)
 8240e28:	10c00a17 	ldw	r3,40(r2)
 8240e2c:	e0bffe17 	ldw	r2,-8(fp)
 8240e30:	1886f03a 	xor	r3,r3,r2
 8240e34:	e0bffc17 	ldw	r2,-16(fp)
 8240e38:	10800c17 	ldw	r2,48(r2)
 8240e3c:	1884703a 	and	r2,r3,r2
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
         (ifp->n_ipaddr != 0) && 
 8240e40:	1000101e 	bne	r2,zero,8240e84 <iproute+0x140>
         ((ifp->n_ipaddr & ifp->snmask) == (host & ifp->snmask)))
      {
#ifdef IP_ROUTING
         /* make a cached Route entry for next time */
         cachedRoute = add_route(host, 0xFFFFFFFF, host, i, IPRP_OTHER);
 8240e44:	00800044 	movi	r2,1
 8240e48:	d8800015 	stw	r2,0(sp)
 8240e4c:	e1fffb17 	ldw	r7,-20(fp)
 8240e50:	e1bffe17 	ldw	r6,-8(fp)
 8240e54:	017fffc4 	movi	r5,-1
 8240e58:	e13ffe17 	ldw	r4,-8(fp)
 8240e5c:	824438c0 	call	824438c <add_route>
 8240e60:	d0a0d015 	stw	r2,-31936(gp)
#ifdef NPDEBUG
         if (cachedRoute == NULL)
 8240e64:	d0a0d017 	ldw	r2,-31936(gp)
 8240e68:	1000011e 	bne	r2,zero,8240e70 <iproute+0x12c>
            dtrap();
 8240e6c:	822d5f00 	call	822d5f0 <dtrap>
#endif   /* NPDEBUG */
#endif   /* IP_ROUTING */
         *hop1 = host;
 8240e70:	e0bfff17 	ldw	r2,-4(fp)
 8240e74:	e0fffe17 	ldw	r3,-8(fp)
 8240e78:	10c00015 	stw	r3,0(r2)
         return ifp;
 8240e7c:	e0bffc17 	ldw	r2,-16(fp)
 8240e80:	00002106 	br	8240f08 <iproute+0x1c4>
    * well.  
    */
   ifp = (NET)(netlist.q_head);
   i = 0;
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 8240e84:	e0bffc17 	ldw	r2,-16(fp)
 8240e88:	10800017 	ldw	r2,0(r2)
 8240e8c:	e0bffc15 	stw	r2,-16(fp)
 8240e90:	e0bffb17 	ldw	r2,-20(fp)
 8240e94:	10800044 	addi	r2,r2,1
 8240e98:	e0bffb15 	stw	r2,-20(fp)
 8240e9c:	e0bffc17 	ldw	r2,-16(fp)
 8240ea0:	103fda1e 	bne	r2,zero,8240e0c <iproute+0xc8>
#endif   /* IP_LOOPBACK */

   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
 8240ea4:	008209b4 	movhi	r2,2086
 8240ea8:	10ba7e04 	addi	r2,r2,-5640
 8240eac:	10800017 	ldw	r2,0(r2)
 8240eb0:	e0bffc15 	stw	r2,-16(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 8240eb4:	00000c06 	br	8240ee8 <iproute+0x1a4>
#endif   /* MULTI_HOMED */
   {
      /* Check if this net has a gateway */
      if(ifp->n_defgw)
 8240eb8:	e0bffc17 	ldw	r2,-16(fp)
 8240ebc:	10800d17 	ldw	r2,52(r2)
 8240ec0:	10000626 	beq	r2,zero,8240edc <iproute+0x198>
      {
         *hop1 = ifp->n_defgw;
 8240ec4:	e0bffc17 	ldw	r2,-16(fp)
 8240ec8:	10c00d17 	ldw	r3,52(r2)
 8240ecc:	e0bfff17 	ldw	r2,-4(fp)
 8240ed0:	10c00015 	stw	r3,0(r2)
         return ifp;
 8240ed4:	e0bffc17 	ldw	r2,-16(fp)
 8240ed8:	00000b06 	br	8240f08 <iproute+0x1c4>
   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 8240edc:	e0bffc17 	ldw	r2,-16(fp)
 8240ee0:	10800017 	ldw	r2,0(r2)
 8240ee4:	e0bffc15 	stw	r2,-16(fp)
 8240ee8:	e0bffc17 	ldw	r2,-16(fp)
 8240eec:	103ff21e 	bne	r2,zero,8240eb8 <iproute+0x174>
   /* if no gateway is set, then change the first hop address to the 
    * host we're trying to route to. this is just a kluge to make 
    * this work with arp routing. otherwise, we would try to return 
    * some sort of error indication. 
    */
   *hop1 = host;
 8240ef0:	e0bfff17 	ldw	r2,-4(fp)
 8240ef4:	e0fffe17 	ldw	r3,-8(fp)
 8240ef8:	10c00015 	stw	r3,0(r2)
   return((NET)(netlist.q_head));
 8240efc:	008209b4 	movhi	r2,2086
 8240f00:	10ba7e04 	addi	r2,r2,-5640
 8240f04:	10800017 	ldw	r2,0(r2)
#endif   /* STRICT_SUBNETTING */
}
 8240f08:	e037883a 	mov	sp,fp
 8240f0c:	dfc00117 	ldw	ra,4(sp)
 8240f10:	df000017 	ldw	fp,0(sp)
 8240f14:	dec00204 	addi	sp,sp,8
 8240f18:	f800283a 	ret

08240f1c <ip_copypkt>:
 * RETURNS: a pointer to the new copy of the packet,
 *          or NULL if no packet buffer could be allocated
 */
PACKET
ip_copypkt(PACKET p)
{
 8240f1c:	defffb04 	addi	sp,sp,-20
 8240f20:	dfc00415 	stw	ra,16(sp)
 8240f24:	df000315 	stw	fp,12(sp)
 8240f28:	df000304 	addi	fp,sp,12
 8240f2c:	e13fff15 	stw	r4,-4(fp)
   int len;

   /* figure out how much we need to copy from the packet, 
    * and allocate a new buffer to hold it 
    */
   len = p->nb_plen + (p->nb_prot - p->nb_buff);
 8240f30:	e0bfff17 	ldw	r2,-4(fp)
 8240f34:	10800417 	ldw	r2,16(r2)
 8240f38:	e0ffff17 	ldw	r3,-4(fp)
 8240f3c:	18c00317 	ldw	r3,12(r3)
 8240f40:	1809883a 	mov	r4,r3
 8240f44:	e0ffff17 	ldw	r3,-4(fp)
 8240f48:	18c00117 	ldw	r3,4(r3)
 8240f4c:	20c7c83a 	sub	r3,r4,r3
 8240f50:	10c5883a 	add	r2,r2,r3
 8240f54:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8240f58:	01000084 	movi	r4,2
 8240f5c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   np = pk_alloc(len);
 8240f60:	e0bffd17 	ldw	r2,-12(fp)
 8240f64:	1009883a 	mov	r4,r2
 8240f68:	822ca480 	call	822ca48 <pk_alloc>
 8240f6c:	e0bffe15 	stw	r2,-8(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8240f70:	01000084 	movi	r4,2
 8240f74:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   if (np == NULL)
 8240f78:	e0bffe17 	ldw	r2,-8(fp)
 8240f7c:	1000061e 	bne	r2,zero,8240f98 <ip_copypkt+0x7c>
   {
#ifdef NPDEBUG
      dprintf("ip_copypkt(): unable to obtain packet (len %d)\n", len);
 8240f80:	e17ffd17 	ldw	r5,-12(fp)
 8240f84:	01020974 	movhi	r4,2085
 8240f88:	2104ea04 	addi	r4,r4,5032
 8240f8c:	82033fc0 	call	82033fc <printf>
#endif
      return NULL;
 8240f90:	0005883a 	mov	r2,zero
 8240f94:	00002906 	br	824103c <ip_copypkt+0x120>
   }

   /* copy packet data into new buffer */
   MEMCPY(np->nb_buff, p->nb_buff, len);
 8240f98:	e0bffe17 	ldw	r2,-8(fp)
 8240f9c:	10c00117 	ldw	r3,4(r2)
 8240fa0:	e0bfff17 	ldw	r2,-4(fp)
 8240fa4:	10800117 	ldw	r2,4(r2)
 8240fa8:	e13ffd17 	ldw	r4,-12(fp)
 8240fac:	200d883a 	mov	r6,r4
 8240fb0:	100b883a 	mov	r5,r2
 8240fb4:	1809883a 	mov	r4,r3
 8240fb8:	8202f6c0 	call	8202f6c <memcpy>

   /* copy relevant packet fields */
   np->nb_prot = np->nb_buff + (p->nb_prot - p->nb_buff);
 8240fbc:	e0bffe17 	ldw	r2,-8(fp)
 8240fc0:	10800117 	ldw	r2,4(r2)
 8240fc4:	e0ffff17 	ldw	r3,-4(fp)
 8240fc8:	18c00317 	ldw	r3,12(r3)
 8240fcc:	1809883a 	mov	r4,r3
 8240fd0:	e0ffff17 	ldw	r3,-4(fp)
 8240fd4:	18c00117 	ldw	r3,4(r3)
 8240fd8:	20c7c83a 	sub	r3,r4,r3
 8240fdc:	10c7883a 	add	r3,r2,r3
 8240fe0:	e0bffe17 	ldw	r2,-8(fp)
 8240fe4:	10c00315 	stw	r3,12(r2)
   np->nb_plen = p->nb_plen;
 8240fe8:	e0bfff17 	ldw	r2,-4(fp)
 8240fec:	10c00417 	ldw	r3,16(r2)
 8240ff0:	e0bffe17 	ldw	r2,-8(fp)
 8240ff4:	10c00415 	stw	r3,16(r2)
   np->net = p->net;
 8240ff8:	e0bfff17 	ldw	r2,-4(fp)
 8240ffc:	10c00617 	ldw	r3,24(r2)
 8241000:	e0bffe17 	ldw	r2,-8(fp)
 8241004:	10c00615 	stw	r3,24(r2)
   np->fhost = p->fhost;
 8241008:	e0bfff17 	ldw	r2,-4(fp)
 824100c:	10c00717 	ldw	r3,28(r2)
 8241010:	e0bffe17 	ldw	r2,-8(fp)
 8241014:	10c00715 	stw	r3,28(r2)
   np->type = p->type;
 8241018:	e0bfff17 	ldw	r2,-4(fp)
 824101c:	10c0080b 	ldhu	r3,32(r2)
 8241020:	e0bffe17 	ldw	r2,-8(fp)
 8241024:	10c0080d 	sth	r3,32(r2)
   np->nb_tstamp = p->nb_tstamp;
 8241028:	e0bfff17 	ldw	r2,-4(fp)
 824102c:	10c00517 	ldw	r3,20(r2)
 8241030:	e0bffe17 	ldw	r2,-8(fp)
 8241034:	10c00515 	stw	r3,20(r2)

   /* return pointer to the copy */
   return np;
 8241038:	e0bffe17 	ldw	r2,-8(fp)
}
 824103c:	e037883a 	mov	sp,fp
 8241040:	dfc00117 	ldw	ra,4(sp)
 8241044:	df000017 	ldw	fp,0(sp)
 8241048:	dec00204 	addi	sp,sp,8
 824104c:	f800283a 	ret

08241050 <ip_reasm_match_frag_with_ire>:
packet being processed.  If no such entry is found, this function returns 
NULL.
*/

IREP ip_reasm_match_frag_with_ire (struct ip * pip)
{
 8241050:	defffa04 	addi	sp,sp,-24
 8241054:	df000515 	stw	fp,20(sp)
 8241058:	df000504 	addi	fp,sp,20
 824105c:	e13fff15 	stw	r4,-4(fp)
   ip_addr dest;
   u_char prot;
   u_short id;
   IREP tmpp;
 
   src = pip->ip_src;
 8241060:	e0bfff17 	ldw	r2,-4(fp)
 8241064:	10800317 	ldw	r2,12(r2)
 8241068:	e0bffc15 	stw	r2,-16(fp)
   dest = pip->ip_dest;
 824106c:	e0bfff17 	ldw	r2,-4(fp)
 8241070:	10800417 	ldw	r2,16(r2)
 8241074:	e0bffd15 	stw	r2,-12(fp)
   prot = pip->ip_prot;
 8241078:	e0bfff17 	ldw	r2,-4(fp)
 824107c:	10800243 	ldbu	r2,9(r2)
 8241080:	e0bffe05 	stb	r2,-8(fp)
   id = pip->ip_id;
 8241084:	e0bfff17 	ldw	r2,-4(fp)
 8241088:	1080010b 	ldhu	r2,4(r2)
 824108c:	e0bffe8d 	sth	r2,-6(fp)

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8241090:	d0a0c817 	ldw	r2,-31968(gp)
 8241094:	e0bffb15 	stw	r2,-20(fp)
 8241098:	00001706 	br	82410f8 <ip_reasm_match_frag_with_ire+0xa8>
      {
      if ((tmpp->src == src) && (tmpp->dest == dest) && 
 824109c:	e0bffb17 	ldw	r2,-20(fp)
 82410a0:	10c00117 	ldw	r3,4(r2)
 82410a4:	e0bffc17 	ldw	r2,-16(fp)
 82410a8:	1880101e 	bne	r3,r2,82410ec <ip_reasm_match_frag_with_ire+0x9c>
 82410ac:	e0bffb17 	ldw	r2,-20(fp)
 82410b0:	10c00217 	ldw	r3,8(r2)
 82410b4:	e0bffd17 	ldw	r2,-12(fp)
 82410b8:	18800c1e 	bne	r3,r2,82410ec <ip_reasm_match_frag_with_ire+0x9c>
          (tmpp->prot == prot) && (tmpp->id == id))
 82410bc:	e0bffb17 	ldw	r2,-20(fp)
 82410c0:	10800383 	ldbu	r2,14(r2)

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
      {
      if ((tmpp->src == src) && (tmpp->dest == dest) && 
 82410c4:	10c03fcc 	andi	r3,r2,255
 82410c8:	e0bffe03 	ldbu	r2,-8(fp)
 82410cc:	1880071e 	bne	r3,r2,82410ec <ip_reasm_match_frag_with_ire+0x9c>
          (tmpp->prot == prot) && (tmpp->id == id))
 82410d0:	e0bffb17 	ldw	r2,-20(fp)
 82410d4:	1080030b 	ldhu	r2,12(r2)
 82410d8:	10ffffcc 	andi	r3,r2,65535
 82410dc:	e0bffe8b 	ldhu	r2,-6(fp)
 82410e0:	1880021e 	bne	r3,r2,82410ec <ip_reasm_match_frag_with_ire+0x9c>
         {
         return tmpp; /* we've found a match */
 82410e4:	e0bffb17 	ldw	r2,-20(fp)
 82410e8:	00000606 	br	8241104 <ip_reasm_match_frag_with_ire+0xb4>
   prot = pip->ip_prot;
   id = pip->ip_id;

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 82410ec:	e0bffb17 	ldw	r2,-20(fp)
 82410f0:	10800017 	ldw	r2,0(r2)
 82410f4:	e0bffb15 	stw	r2,-20(fp)
 82410f8:	e0bffb17 	ldw	r2,-20(fp)
 82410fc:	103fe71e 	bne	r2,zero,824109c <ip_reasm_match_frag_with_ire+0x4c>
         return tmpp; /* we've found a match */
         }
      }

   /* no match found */
   return NULL;
 8241100:	0005883a 	mov	r2,zero
}
 8241104:	e037883a 	mov	sp,fp
 8241108:	df000017 	ldw	fp,0(sp)
 824110c:	dec00104 	addi	sp,sp,4
 8241110:	f800283a 	ret

08241114 <ip_reasm_determine_type_of_frag>:
OUTPUT: One of the various IP_FRAGTYPE values (IP_CP, IP_FF, IP_MF, 
or IP_LF)
*/

IP_FRAGTYPE ip_reasm_determine_type_of_frag (struct ip * pip)
{
 8241114:	defffc04 	addi	sp,sp,-16
 8241118:	df000315 	stw	fp,12(sp)
 824111c:	df000304 	addi	fp,sp,12
 8241120:	e13fff15 	stw	r4,-4(fp)
  u_short mf;
  u_short foff;
  IP_FRAGTYPE rc;

  mf = (((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF) >> 13);
 8241124:	e0bfff17 	ldw	r2,-4(fp)
 8241128:	1080018b 	ldhu	r2,6(r2)
 824112c:	10bfffcc 	andi	r2,r2,65535
 8241130:	1004d23a 	srli	r2,r2,8
 8241134:	10bfffcc 	andi	r2,r2,65535
 8241138:	10c03fcc 	andi	r3,r2,255
 824113c:	e0bfff17 	ldw	r2,-4(fp)
 8241140:	1080018b 	ldhu	r2,6(r2)
 8241144:	10bfffcc 	andi	r2,r2,65535
 8241148:	1004923a 	slli	r2,r2,8
 824114c:	10bfffcc 	andi	r2,r2,65535
 8241150:	1884b03a 	or	r2,r3,r2
 8241154:	1088000c 	andi	r2,r2,8192
 8241158:	1005d37a 	srai	r2,r2,13
 824115c:	e0bffe0d 	sth	r2,-8(fp)
  foff = ((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF);
 8241160:	e0bfff17 	ldw	r2,-4(fp)
 8241164:	1080018b 	ldhu	r2,6(r2)
 8241168:	10bfffcc 	andi	r2,r2,65535
 824116c:	1004d23a 	srli	r2,r2,8
 8241170:	1007883a 	mov	r3,r2
 8241174:	e0bfff17 	ldw	r2,-4(fp)
 8241178:	1080018b 	ldhu	r2,6(r2)
 824117c:	10bfffcc 	andi	r2,r2,65535
 8241180:	1004923a 	slli	r2,r2,8
 8241184:	1884b03a 	or	r2,r3,r2
 8241188:	1087ffcc 	andi	r2,r2,8191
 824118c:	e0bffe8d 	sth	r2,-6(fp)

  if (mf == 0)
 8241190:	e0bffe0b 	ldhu	r2,-8(fp)
 8241194:	1000071e 	bne	r2,zero,82411b4 <ip_reasm_determine_type_of_frag+0xa0>
     {
     if (foff == 0) {rc = IP_CP;}
 8241198:	e0bffe8b 	ldhu	r2,-6(fp)
 824119c:	1000021e 	bne	r2,zero,82411a8 <ip_reasm_determine_type_of_frag+0x94>
 82411a0:	e03ffd15 	stw	zero,-12(fp)
 82411a4:	00000a06 	br	82411d0 <ip_reasm_determine_type_of_frag+0xbc>
     else {rc = IP_LF;}
 82411a8:	00800144 	movi	r2,5
 82411ac:	e0bffd15 	stw	r2,-12(fp)
 82411b0:	00000706 	br	82411d0 <ip_reasm_determine_type_of_frag+0xbc>
     }
  else
     {
     if (foff == 0) {rc = IP_FF;}
 82411b4:	e0bffe8b 	ldhu	r2,-6(fp)
 82411b8:	1000031e 	bne	r2,zero,82411c8 <ip_reasm_determine_type_of_frag+0xb4>
 82411bc:	00800044 	movi	r2,1
 82411c0:	e0bffd15 	stw	r2,-12(fp)
 82411c4:	00000206 	br	82411d0 <ip_reasm_determine_type_of_frag+0xbc>
     else {rc = IP_MF;}
 82411c8:	008000c4 	movi	r2,3
 82411cc:	e0bffd15 	stw	r2,-12(fp)
     }

  return rc;
 82411d0:	e0bffd17 	ldw	r2,-12(fp)
}
 82411d4:	e037883a 	mov	sp,fp
 82411d8:	df000017 	ldw	fp,0(sp)
 82411dc:	dec00104 	addi	sp,sp,4
 82411e0:	f800283a 	ret

082411e4 <ip_reasm_check_mem_useage>:
OUTPUT: ENP_RESOURCE, if the increment request can't be allowed; 
otherwise it returns IPREASM_OK.
*/

int ip_reasm_check_mem_useage (u_short increment)
{
 82411e4:	defffe04 	addi	sp,sp,-8
 82411e8:	df000115 	stw	fp,4(sp)
 82411ec:	df000104 	addi	fp,sp,4
 82411f0:	2005883a 	mov	r2,r4
 82411f4:	e0bfff0d 	sth	r2,-4(fp)
   /* sanity check */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 82411f8:	d0a0c717 	ldw	r2,-31972(gp)
 82411fc:	00c001b4 	movhi	r3,6
 8241200:	1880072e 	bgeu	r3,r2,8241220 <ip_reasm_check_mem_useage+0x3c>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 8241204:	008209b4 	movhi	r2,2086
 8241208:	10ba9704 	addi	r2,r2,-5540
 824120c:	10800217 	ldw	r2,8(r2)
 8241210:	10c00044 	addi	r3,r2,1
 8241214:	008209b4 	movhi	r2,2086
 8241218:	10ba9704 	addi	r2,r2,-5540
 824121c:	10c00215 	stw	r3,8(r2)
   }

   /* check to see if we are already at limit OR if we may become over limit 
    * after accepting this new fragment */
   if ((ipr_curr_mem == IP_REASM_MAX_MEM) ||
 8241220:	d0e0c717 	ldw	r3,-31972(gp)
 8241224:	008001b4 	movhi	r2,6
 8241228:	18800526 	beq	r3,r2,8241240 <ip_reasm_check_mem_useage+0x5c>
       (ipr_curr_mem + increment > IP_REASM_MAX_MEM))
 824122c:	e0ffff0b 	ldhu	r3,-4(fp)
 8241230:	d0a0c717 	ldw	r2,-31972(gp)
 8241234:	1885883a 	add	r2,r3,r2
      ++ire_stats.bad_max_mem;
   }

   /* check to see if we are already at limit OR if we may become over limit 
    * after accepting this new fragment */
   if ((ipr_curr_mem == IP_REASM_MAX_MEM) ||
 8241238:	00c001b4 	movhi	r3,6
 824123c:	1880092e 	bgeu	r3,r2,8241264 <ip_reasm_check_mem_useage+0x80>
       (ipr_curr_mem + increment > IP_REASM_MAX_MEM))
   {
      /* return an error indication */
      ++ire_stats.mem_check_fail;
 8241240:	008209b4 	movhi	r2,2086
 8241244:	10ba9704 	addi	r2,r2,-5540
 8241248:	10800317 	ldw	r2,12(r2)
 824124c:	10c00044 	addi	r3,r2,1
 8241250:	008209b4 	movhi	r2,2086
 8241254:	10ba9704 	addi	r2,r2,-5540
 8241258:	10c00315 	stw	r3,12(r2)
      return ENP_RESOURCE;
 824125c:	00bffa84 	movi	r2,-22
 8241260:	00000106 	br	8241268 <ip_reasm_check_mem_useage+0x84>
   }

   /* memory limits will not be exceeded with this increment */
   return IPREASM_OK;
 8241264:	0005883a 	mov	r2,zero
}
 8241268:	e037883a 	mov	sp,fp
 824126c:	df000017 	ldw	fp,0(sp)
 8241270:	dec00104 	addi	sp,sp,4
 8241274:	f800283a 	ret

08241278 <ip_reasm_incr_mem_useage>:
system exceeding the maximum limit or if the system has already exceeded 
the prespecified limit for memory useage; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_incr_mem_useage (u_short increment)
{
 8241278:	defffe04 	addi	sp,sp,-8
 824127c:	df000115 	stw	fp,4(sp)
 8241280:	df000104 	addi	fp,sp,4
 8241284:	2005883a 	mov	r2,r4
 8241288:	e0bfff0d 	sth	r2,-4(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 824128c:	d0a0c717 	ldw	r2,-31972(gp)
 8241290:	00c001b4 	movhi	r3,6
 8241294:	1880092e 	bgeu	r3,r2,82412bc <ip_reasm_incr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 8241298:	008209b4 	movhi	r2,2086
 824129c:	10ba9704 	addi	r2,r2,-5540
 82412a0:	10800217 	ldw	r2,8(r2)
 82412a4:	10c00044 	addi	r3,r2,1
 82412a8:	008209b4 	movhi	r2,2086
 82412ac:	10ba9704 	addi	r2,r2,-5540
 82412b0:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 82412b4:	00bffa84 	movi	r2,-22
 82412b8:	00001306 	br	8241308 <ip_reasm_incr_mem_useage+0x90>
   }
   if (ipr_curr_mem + increment > IP_REASM_MAX_MEM)
 82412bc:	e0ffff0b 	ldhu	r3,-4(fp)
 82412c0:	d0a0c717 	ldw	r2,-31972(gp)
 82412c4:	1885883a 	add	r2,r3,r2
 82412c8:	00c001b4 	movhi	r3,6
 82412cc:	1880092e 	bgeu	r3,r2,82412f4 <ip_reasm_incr_mem_useage+0x7c>
   {
      /* this should never happen since caller should have 
       * checked prior to asking for the increment */
      ++ire_stats.mem_incr_fail;
 82412d0:	008209b4 	movhi	r2,2086
 82412d4:	10ba9704 	addi	r2,r2,-5540
 82412d8:	10800417 	ldw	r2,16(r2)
 82412dc:	10c00044 	addi	r3,r2,1
 82412e0:	008209b4 	movhi	r2,2086
 82412e4:	10ba9704 	addi	r2,r2,-5540
 82412e8:	10c00415 	stw	r3,16(r2)
      return ENP_RESOURCE;
 82412ec:	00bffa84 	movi	r2,-22
 82412f0:	00000506 	br	8241308 <ip_reasm_incr_mem_useage+0x90>
   }

   ipr_curr_mem += increment;
 82412f4:	e0ffff0b 	ldhu	r3,-4(fp)
 82412f8:	d0a0c717 	ldw	r2,-31972(gp)
 82412fc:	1885883a 	add	r2,r3,r2
 8241300:	d0a0c715 	stw	r2,-31972(gp)

   /* successfully incremented memory useage counter */
   return IPREASM_OK;
 8241304:	0005883a 	mov	r2,zero
}
 8241308:	e037883a 	mov	sp,fp
 824130c:	df000017 	ldw	fp,0(sp)
 8241310:	dec00104 	addi	sp,sp,4
 8241314:	f800283a 	ret

08241318 <ip_reasm_decr_mem_useage>:
exceeded the prespecified limit for memory useage; otherwise, it returns 
IPREASM_OK.
*/

int ip_reasm_decr_mem_useage (u_short decrement)
{
 8241318:	defffe04 	addi	sp,sp,-8
 824131c:	df000115 	stw	fp,4(sp)
 8241320:	df000104 	addi	fp,sp,4
 8241324:	2005883a 	mov	r2,r4
 8241328:	e0bfff0d 	sth	r2,-4(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 824132c:	d0a0c717 	ldw	r2,-31972(gp)
 8241330:	00c001b4 	movhi	r3,6
 8241334:	1880092e 	bgeu	r3,r2,824135c <ip_reasm_decr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 8241338:	008209b4 	movhi	r2,2086
 824133c:	10ba9704 	addi	r2,r2,-5540
 8241340:	10800217 	ldw	r2,8(r2)
 8241344:	10c00044 	addi	r3,r2,1
 8241348:	008209b4 	movhi	r2,2086
 824134c:	10ba9704 	addi	r2,r2,-5540
 8241350:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 8241354:	00bffa84 	movi	r2,-22
 8241358:	00001106 	br	82413a0 <ip_reasm_decr_mem_useage+0x88>
   }
   if (ipr_curr_mem < decrement)
 824135c:	e0bfff0b 	ldhu	r2,-4(fp)
 8241360:	d0e0c717 	ldw	r3,-31972(gp)
 8241364:	1880092e 	bgeu	r3,r2,824138c <ip_reasm_decr_mem_useage+0x74>
   {
      /* this should never happen since the current memory useage
       * counter must always be greater than or at least equal to
       * the allocation that is being "returned" */
      ++ire_stats.mem_decr_fail;
 8241368:	008209b4 	movhi	r2,2086
 824136c:	10ba9704 	addi	r2,r2,-5540
 8241370:	10800517 	ldw	r2,20(r2)
 8241374:	10c00044 	addi	r3,r2,1
 8241378:	008209b4 	movhi	r2,2086
 824137c:	10ba9704 	addi	r2,r2,-5540
 8241380:	10c00515 	stw	r3,20(r2)
      return ENP_RESOURCE;
 8241384:	00bffa84 	movi	r2,-22
 8241388:	00000506 	br	82413a0 <ip_reasm_decr_mem_useage+0x88>
   }

   ipr_curr_mem -= decrement;
 824138c:	d0e0c717 	ldw	r3,-31972(gp)
 8241390:	e0bfff0b 	ldhu	r2,-4(fp)
 8241394:	1885c83a 	sub	r2,r3,r2
 8241398:	d0a0c715 	stw	r2,-31972(gp)

   /* successfully decremented memory useage counter */
   return IPREASM_OK;
 824139c:	0005883a 	mov	r2,zero
}
 82413a0:	e037883a 	mov	sp,fp
 82413a4:	df000017 	ldw	fp,0(sp)
 82413a8:	dec00104 	addi	sp,sp,4
 82413ac:	f800283a 	ret

082413b0 <ip_reasm_process_first_fragment>:
OUTPUT: ENP_RESOURCE if the memory check (in ip_reasm_check_mem_useage ()) 
or the allocation for an IRE fails; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_process_first_fragment (PACKET p)
{
 82413b0:	defff704 	addi	sp,sp,-36
 82413b4:	dfc00815 	stw	ra,32(sp)
 82413b8:	df000715 	stw	fp,28(sp)
 82413bc:	df000704 	addi	fp,sp,28
 82413c0:	e13fff15 	stw	r4,-4(fp)
   u_short total_len;
   int rc;

   /* this is a fragment from a hitherto unknown fragment stream; 
    * check for resource limits before accepting it */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (IRE)))) != IPREASM_OK)
 82413c4:	e0bfff17 	ldw	r2,-4(fp)
 82413c8:	10800217 	ldw	r2,8(r2)
 82413cc:	10802204 	addi	r2,r2,136
 82413d0:	10bfffcc 	andi	r2,r2,65535
 82413d4:	1009883a 	mov	r4,r2
 82413d8:	82411e40 	call	82411e4 <ip_reasm_check_mem_useage>
 82413dc:	e0bff915 	stw	r2,-28(fp)
 82413e0:	e0bff917 	ldw	r2,-28(fp)
 82413e4:	10000f26 	beq	r2,zero,8241424 <ip_reasm_process_first_fragment+0x74>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 82413e8:	01000084 	movi	r4,2
 82413ec:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free (p);
 82413f0:	e13fff17 	ldw	r4,-4(fp)
 82413f4:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 82413f8:	01000084 	movi	r4,2
 82413fc:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 8241400:	008209b4 	movhi	r2,2086
 8241404:	10ba8304 	addi	r2,r2,-5620
 8241408:	10800f17 	ldw	r2,60(r2)
 824140c:	10c00044 	addi	r3,r2,1
 8241410:	008209b4 	movhi	r2,2086
 8241414:	10ba8304 	addi	r2,r2,-5620
 8241418:	10c00f15 	stw	r3,60(r2)
      return rc;
 824141c:	e0bff917 	ldw	r2,-28(fp)
 8241420:	00008c06 	br	8241654 <ip_reasm_process_first_fragment+0x2a4>
   }

   /* we are ok wrt memory limits; since this is the first fragment, we need 
    * to create an IRE entry */
   irep = (IREP) IPR_ALLOC(sizeof(IRE));
 8241424:	01002204 	movi	r4,136
 8241428:	822e1c80 	call	822e1c8 <npalloc>
 824142c:	e0bffa15 	stw	r2,-24(fp)
   if (irep == 0) 
 8241430:	e0bffa17 	ldw	r2,-24(fp)
 8241434:	10000f1e 	bne	r2,zero,8241474 <ip_reasm_process_first_fragment+0xc4>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 8241438:	01000084 	movi	r4,2
 824143c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free (p);
 8241440:	e13fff17 	ldw	r4,-4(fp)
 8241444:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241448:	01000084 	movi	r4,2
 824144c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 8241450:	008209b4 	movhi	r2,2086
 8241454:	10ba8304 	addi	r2,r2,-5620
 8241458:	10800f17 	ldw	r2,60(r2)
 824145c:	10c00044 	addi	r3,r2,1
 8241460:	008209b4 	movhi	r2,2086
 8241464:	10ba8304 	addi	r2,r2,-5620
 8241468:	10c00f15 	stw	r3,60(r2)
      return ENP_RESOURCE;
 824146c:	00bffa84 	movi	r2,-22
 8241470:	00007806 	br	8241654 <ip_reasm_process_first_fragment+0x2a4>
   }

   pip = ip_head(p);
 8241474:	e0bfff17 	ldw	r2,-4(fp)
 8241478:	10800317 	ldw	r2,12(r2)
 824147c:	e0bffb15 	stw	r2,-20(fp)
   iphlen = ip_hlen(pip);
 8241480:	e0bffb17 	ldw	r2,-20(fp)
 8241484:	10800003 	ldbu	r2,0(r2)
 8241488:	108003cc 	andi	r2,r2,15
 824148c:	1085883a 	add	r2,r2,r2
 8241490:	1085883a 	add	r2,r2,r2
 8241494:	e0bffc05 	stb	r2,-16(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 8241498:	e13ffb17 	ldw	r4,-20(fp)
 824149c:	82411140 	call	8241114 <ip_reasm_determine_type_of_frag>
 82414a0:	e0bffd15 	stw	r2,-12(fp)
   frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 82414a4:	e0bffb17 	ldw	r2,-20(fp)
 82414a8:	1080018b 	ldhu	r2,6(r2)
 82414ac:	10bfffcc 	andi	r2,r2,65535
 82414b0:	1004d23a 	srli	r2,r2,8
 82414b4:	10bfffcc 	andi	r2,r2,65535
 82414b8:	10c03fcc 	andi	r3,r2,255
 82414bc:	e0bffb17 	ldw	r2,-20(fp)
 82414c0:	1080018b 	ldhu	r2,6(r2)
 82414c4:	10bfffcc 	andi	r2,r2,65535
 82414c8:	1004923a 	slli	r2,r2,8
 82414cc:	10bfffcc 	andi	r2,r2,65535
 82414d0:	1884b03a 	or	r2,r3,r2
 82414d4:	100490fa 	slli	r2,r2,3
 82414d8:	e0bffe0d 	sth	r2,-8(fp)
   total_len = ntohs(pip->ip_len);
 82414dc:	e0bffb17 	ldw	r2,-20(fp)
 82414e0:	1080008b 	ldhu	r2,2(r2)
 82414e4:	10bfffcc 	andi	r2,r2,65535
 82414e8:	1004d23a 	srli	r2,r2,8
 82414ec:	1007883a 	mov	r3,r2
 82414f0:	e0bffb17 	ldw	r2,-20(fp)
 82414f4:	1080008b 	ldhu	r2,2(r2)
 82414f8:	10bfffcc 	andi	r2,r2,65535
 82414fc:	1004923a 	slli	r2,r2,8
 8241500:	1884b03a 	or	r2,r3,r2
 8241504:	e0bffe8d 	sth	r2,-6(fp)

   /* now setup various fields in the IRE entry (multi-byte fields stored in network 
    * byte order) */
   irep->src = pip->ip_src;
 8241508:	e0bffb17 	ldw	r2,-20(fp)
 824150c:	10c00317 	ldw	r3,12(r2)
 8241510:	e0bffa17 	ldw	r2,-24(fp)
 8241514:	10c00115 	stw	r3,4(r2)
   irep->dest = pip->ip_dest;
 8241518:	e0bffb17 	ldw	r2,-20(fp)
 824151c:	10c00417 	ldw	r3,16(r2)
 8241520:	e0bffa17 	ldw	r2,-24(fp)
 8241524:	10c00215 	stw	r3,8(r2)
   irep->prot = pip->ip_prot;
 8241528:	e0bffb17 	ldw	r2,-20(fp)
 824152c:	10c00243 	ldbu	r3,9(r2)
 8241530:	e0bffa17 	ldw	r2,-24(fp)
 8241534:	10c00385 	stb	r3,14(r2)
   irep->id = pip->ip_id;
 8241538:	e0bffb17 	ldw	r2,-20(fp)
 824153c:	10c0010b 	ldhu	r3,4(r2)
 8241540:	e0bffa17 	ldw	r2,-24(fp)
 8241544:	10c0030d 	sth	r3,12(r2)
   if (ftype == IP_LF)
 8241548:	e0bffd17 	ldw	r2,-12(fp)
 824154c:	10800158 	cmpnei	r2,r2,5
 8241550:	10000a1e 	bne	r2,zero,824157c <ip_reasm_process_first_fragment+0x1cc>
      {
      irep->length = frag_offset + (total_len - iphlen);
 8241554:	e0bffc03 	ldbu	r2,-16(fp)
 8241558:	e0fffe8b 	ldhu	r3,-6(fp)
 824155c:	1885c83a 	sub	r2,r3,r2
 8241560:	1007883a 	mov	r3,r2
 8241564:	e0bffe0b 	ldhu	r2,-8(fp)
 8241568:	1885883a 	add	r2,r3,r2
 824156c:	1007883a 	mov	r3,r2
 8241570:	e0bffa17 	ldw	r2,-24(fp)
 8241574:	10c0040d 	sth	r3,16(r2)
 8241578:	00000a06 	br	82415a4 <ip_reasm_process_first_fragment+0x1f4>
      }
   else if (ftype == IP_FF)
 824157c:	e0bffd17 	ldw	r2,-12(fp)
 8241580:	10800058 	cmpnei	r2,r2,1
 8241584:	1000071e 	bne	r2,zero,82415a4 <ip_reasm_process_first_fragment+0x1f4>
       * out, and results in the transmission of an ICMP Time Exceeded message (with the
       * code set to "fragment reassembly time exceeded").  Please note that the 'l2_hdr' 
       * as set below may not be the start address for the L2 header (but it is adequate 
       * for our use).  If the FF is never received, these fields stay at their initial
       * value of 0. */
      irep->l2_hdr = p->nb_buff;
 8241588:	e0bfff17 	ldw	r2,-4(fp)
 824158c:	10c00117 	ldw	r3,4(r2)
 8241590:	e0bffa17 	ldw	r2,-24(fp)
 8241594:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 8241598:	e0bffa17 	ldw	r2,-24(fp)
 824159c:	e0fffb17 	ldw	r3,-20(fp)
 82415a0:	10c02015 	stw	r3,128(r2)
      }

   /* note that the 'rcvd' and 'length' counters only keep track of the data part of 
    * the IP datagram */
   irep->rcvd = total_len - iphlen;
 82415a4:	e0bffc03 	ldbu	r2,-16(fp)
 82415a8:	e0fffe8b 	ldhu	r3,-6(fp)
 82415ac:	1885c83a 	sub	r2,r3,r2
 82415b0:	1007883a 	mov	r3,r2
 82415b4:	e0bffa17 	ldw	r2,-24(fp)
 82415b8:	10c0048d 	sth	r3,18(r2)
   irep->age = 0;
 82415bc:	e0bffa17 	ldw	r2,-24(fp)
 82415c0:	10000515 	stw	zero,20(r2)

   /* all RFQs are compact when created */
   irep->flags |= IPR_RFQ_COMPACT;
 82415c4:	e0bffa17 	ldw	r2,-24(fp)
 82415c8:	10802103 	ldbu	r2,132(r2)
 82415cc:	10800054 	ori	r2,r2,1
 82415d0:	1007883a 	mov	r3,r2
 82415d4:	e0bffa17 	ldw	r2,-24(fp)
 82415d8:	10c02105 	stb	r3,132(r2)

   /* store PACKET pointer in the first location of the first RFQ */
   irep->rfq.bufp[0] = p;
 82415dc:	e0bffa17 	ldw	r2,-24(fp)
 82415e0:	e0ffff17 	ldw	r3,-4(fp)
 82415e4:	10c00715 	stw	r3,28(r2)
   irep->rfq.frag_offset[0] = frag_offset;
 82415e8:	e0bffa17 	ldw	r2,-24(fp)
 82415ec:	e0fffe0b 	ldhu	r3,-8(fp)
 82415f0:	10c0170d 	sth	r3,92(r2)
   /* the next pointer in the RFQ is already 0 */

   p->nb_prot += iphlen;
 82415f4:	e0bfff17 	ldw	r2,-4(fp)
 82415f8:	10c00317 	ldw	r3,12(r2)
 82415fc:	e0bffc03 	ldbu	r2,-16(fp)
 8241600:	1887883a 	add	r3,r3,r2
 8241604:	e0bfff17 	ldw	r2,-4(fp)
 8241608:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 824160c:	e0bfff17 	ldw	r2,-4(fp)
 8241610:	10c00417 	ldw	r3,16(r2)
 8241614:	e0bffc03 	ldbu	r2,-16(fp)
 8241618:	1887c83a 	sub	r3,r3,r2
 824161c:	e0bfff17 	ldw	r2,-4(fp)
 8241620:	10c00415 	stw	r3,16(r2)

   /* insert at start of global IRE list */
   irep->next = h_ireq;
 8241624:	d0e0c817 	ldw	r3,-31968(gp)
 8241628:	e0bffa17 	ldw	r2,-24(fp)
 824162c:	10c00015 	stw	r3,0(r2)
   h_ireq = irep;
 8241630:	e0bffa17 	ldw	r2,-24(fp)
 8241634:	d0a0c815 	stw	r2,-31968(gp)

   /* increment the memory useage */
   ip_reasm_incr_mem_useage (p->nb_blen + (sizeof (IRE)));
 8241638:	e0bfff17 	ldw	r2,-4(fp)
 824163c:	10800217 	ldw	r2,8(r2)
 8241640:	10802204 	addi	r2,r2,136
 8241644:	10bfffcc 	andi	r2,r2,65535
 8241648:	1009883a 	mov	r4,r2
 824164c:	82412780 	call	8241278 <ip_reasm_incr_mem_useage>

   return IPREASM_OK;
 8241650:	0005883a 	mov	r2,zero
}
 8241654:	e037883a 	mov	sp,fp
 8241658:	dfc00117 	ldw	ra,4(sp)
 824165c:	df000017 	ldw	fp,0(sp)
 8241660:	dec00204 	addi	sp,sp,8
 8241664:	f800283a 	ret

08241668 <ip_reassm>:
merely passes their return code back to its caller.  Otherwise, it returns
IPREASM_OK indicating that the fragment was successfully processed.
*/

int ip_reassm (PACKET p)
{
 8241668:	defff904 	addi	sp,sp,-28
 824166c:	dfc00615 	stw	ra,24(sp)
 8241670:	df000515 	stw	fp,20(sp)
 8241674:	df000504 	addi	fp,sp,20
 8241678:	e13fff15 	stw	r4,-4(fp)
   IREP irep;
   struct ip * pip;
   int rc1, rc2;

   pip = ip_head(p);
 824167c:	e0bfff17 	ldw	r2,-4(fp)
 8241680:	10800317 	ldw	r2,12(r2)
 8241684:	e0bffb15 	stw	r2,-20(fp)

   /* we have just received a fragment, so let's start processing it.  First
    * check for a matching IRE entry. */
   irep = ip_reasm_match_frag_with_ire (pip);
 8241688:	e13ffb17 	ldw	r4,-20(fp)
 824168c:	82410500 	call	8241050 <ip_reasm_match_frag_with_ire>
 8241690:	e0bffc15 	stw	r2,-16(fp)

   if (!irep)
 8241694:	e0bffc17 	ldw	r2,-16(fp)
 8241698:	1000071e 	bne	r2,zero,82416b8 <ip_reassm+0x50>
   {
      /* this is the first packet for a "new" fragment stream */
      if ((rc1 = ip_reasm_process_first_fragment (p)) != IPREASM_OK)
 824169c:	e13fff17 	ldw	r4,-4(fp)
 82416a0:	82413b00 	call	82413b0 <ip_reasm_process_first_fragment>
 82416a4:	e0bffd15 	stw	r2,-12(fp)
 82416a8:	e0bffd17 	ldw	r2,-12(fp)
 82416ac:	10000a26 	beq	r2,zero,82416d8 <ip_reassm+0x70>
      {
         /* ip_reasm_process_first_fragment () will free the packet */
         return rc1;
 82416b0:	e0bffd17 	ldw	r2,-12(fp)
 82416b4:	00000906 	br	82416dc <ip_reassm+0x74>
      }
   }
   else
   {
      /* a matching IRE already exists for this fragment */
      if ((rc2 = ip_reasm_process_subsequent_fragments (p, irep)) != IPREASM_OK)
 82416b8:	e17ffc17 	ldw	r5,-16(fp)
 82416bc:	e13fff17 	ldw	r4,-4(fp)
 82416c0:	8241c540 	call	8241c54 <ip_reasm_process_subsequent_fragments>
 82416c4:	e0bffe15 	stw	r2,-8(fp)
 82416c8:	e0bffe17 	ldw	r2,-8(fp)
 82416cc:	10000226 	beq	r2,zero,82416d8 <ip_reassm+0x70>
      {
         /* ip_reasm_process_subsequent_fragments () has already deleted the IRE entry */
         return rc2;
 82416d0:	e0bffe17 	ldw	r2,-8(fp)
 82416d4:	00000106 	br	82416dc <ip_reassm+0x74>
      }
   }

   return IPREASM_OK;
 82416d8:	0005883a 	mov	r2,zero
}
 82416dc:	e037883a 	mov	sp,fp
 82416e0:	dfc00117 	ldw	ra,4(sp)
 82416e4:	df000017 	ldw	fp,0(sp)
 82416e8:	dec00204 	addi	sp,sp,8
 82416ec:	f800283a 	ret

082416f0 <ip_reasm_compute_overlap>:
            (i.e., contains "unique" data).
*/

IPREASM_RC ip_reasm_compute_overlap (PACKET p, IREP irep, u_short * indexp, 
 RFQP * last_rfqpp, u_short * frag_offsetp, u_char * hole_createdp)
{
 82416f0:	defff204 	addi	sp,sp,-56
 82416f4:	dfc00d15 	stw	ra,52(sp)
 82416f8:	df000c15 	stw	fp,48(sp)
 82416fc:	df000c04 	addi	fp,sp,48
 8241700:	e13ffc15 	stw	r4,-16(fp)
 8241704:	e17ffd15 	stw	r5,-12(fp)
 8241708:	e1bffe15 	stw	r6,-8(fp)
 824170c:	e1ffff15 	stw	r7,-4(fp)
   u_short currend;
   u_short drop_len;
   u_char iphlen;
   u_short i;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 8241710:	e13ffd17 	ldw	r4,-12(fp)
 8241714:	82421840 	call	8242184 <ip_reasm_find_ire>
 8241718:	10803fcc 	andi	r2,r2,255
 824171c:	10800060 	cmpeqi	r2,r2,1
 8241720:	10000f1e 	bne	r2,zero,8241760 <ip_reasm_compute_overlap+0x70>
      {
      ++ire_stats.bad_irep;
 8241724:	008209b4 	movhi	r2,2086
 8241728:	10ba9704 	addi	r2,r2,-5540
 824172c:	10800017 	ldw	r2,0(r2)
 8241730:	10c00044 	addi	r3,r2,1
 8241734:	008209b4 	movhi	r2,2086
 8241738:	10ba9704 	addi	r2,r2,-5540
 824173c:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 8241740:	01000084 	movi	r4,2
 8241744:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free (p);
 8241748:	e13ffc17 	ldw	r4,-16(fp)
 824174c:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241750:	01000084 	movi	r4,2
 8241754:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return IPREASM_DROP_FRAG_BAD_PARAM;
 8241758:	00800044 	movi	r2,1
 824175c:	00013806 	br	8241c40 <ip_reasm_compute_overlap+0x550>
      }

   jrip = ip_head(p);
 8241760:	e0bffc17 	ldw	r2,-16(fp)
 8241764:	10800317 	ldw	r2,12(r2)
 8241768:	e0bff715 	stw	r2,-36(fp)
   iphlen = ip_hlen (jrip);
 824176c:	e0bff717 	ldw	r2,-36(fp)
 8241770:	10800003 	ldbu	r2,0(r2)
 8241774:	108003cc 	andi	r2,r2,15
 8241778:	1085883a 	add	r2,r2,r2
 824177c:	1085883a 	add	r2,r2,r2
 8241780:	e0bff805 	stb	r2,-32(fp)
   jrstart = (((ntohs(jrip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 8241784:	e0bff717 	ldw	r2,-36(fp)
 8241788:	1080018b 	ldhu	r2,6(r2)
 824178c:	10bfffcc 	andi	r2,r2,65535
 8241790:	1004d23a 	srli	r2,r2,8
 8241794:	10bfffcc 	andi	r2,r2,65535
 8241798:	10c03fcc 	andi	r3,r2,255
 824179c:	e0bff717 	ldw	r2,-36(fp)
 82417a0:	1080018b 	ldhu	r2,6(r2)
 82417a4:	10bfffcc 	andi	r2,r2,65535
 82417a8:	1004923a 	slli	r2,r2,8
 82417ac:	10bfffcc 	andi	r2,r2,65535
 82417b0:	1884b03a 	or	r2,r3,r2
 82417b4:	100490fa 	slli	r2,r2,3
 82417b8:	e0bff50d 	sth	r2,-44(fp)
   jrend =   jrstart + ((ntohs(jrip->ip_len)) - iphlen) - 1;
 82417bc:	e0bff717 	ldw	r2,-36(fp)
 82417c0:	1080008b 	ldhu	r2,2(r2)
 82417c4:	10bfffcc 	andi	r2,r2,65535
 82417c8:	1004d23a 	srli	r2,r2,8
 82417cc:	1007883a 	mov	r3,r2
 82417d0:	e0bff717 	ldw	r2,-36(fp)
 82417d4:	1080008b 	ldhu	r2,2(r2)
 82417d8:	10bfffcc 	andi	r2,r2,65535
 82417dc:	1004923a 	slli	r2,r2,8
 82417e0:	1884b03a 	or	r2,r3,r2
 82417e4:	1007883a 	mov	r3,r2
 82417e8:	e0bff803 	ldbu	r2,-32(fp)
 82417ec:	1885c83a 	sub	r2,r3,r2
 82417f0:	1007883a 	mov	r3,r2
 82417f4:	e0bff50b 	ldhu	r2,-44(fp)
 82417f8:	1885883a 	add	r2,r3,r2
 82417fc:	10bfffc4 	addi	r2,r2,-1
 8241800:	e0bff58d 	sth	r2,-42(fp)
   /* skip past the IP header of the just received fragment as we get ready 
    * to compare for overlap between the just received fragment and the 
    * fragments that are currently queued in the IRE entry for this fragment 
    * chain */
   p->nb_prot += iphlen;
 8241804:	e0bffc17 	ldw	r2,-16(fp)
 8241808:	10c00317 	ldw	r3,12(r2)
 824180c:	e0bff803 	ldbu	r2,-32(fp)
 8241810:	1887883a 	add	r3,r3,r2
 8241814:	e0bffc17 	ldw	r2,-16(fp)
 8241818:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 824181c:	e0bffc17 	ldw	r2,-16(fp)
 8241820:	10c00417 	ldw	r3,16(r2)
 8241824:	e0bff803 	ldbu	r2,-32(fp)
 8241828:	1887c83a 	sub	r3,r3,r2
 824182c:	e0bffc17 	ldw	r2,-16(fp)
 8241830:	10c00415 	stw	r3,16(r2)

   *frag_offsetp = jrstart;
 8241834:	e0800217 	ldw	r2,8(fp)
 8241838:	e0fff50b 	ldhu	r3,-44(fp)
 824183c:	10c0000d 	sth	r3,0(r2)
   *indexp = INVALID_FRAG_INDEX;
 8241840:	e0bffe17 	ldw	r2,-8(fp)
 8241844:	00c00404 	movi	r3,16
 8241848:	10c0000d 	sth	r3,0(r2)
   *last_rfqpp = 0;
 824184c:	e0bfff17 	ldw	r2,-4(fp)
 8241850:	10000015 	stw	zero,0(r2)
   *hole_createdp = IPREASM_FALSE;
 8241854:	e0800317 	ldw	r2,12(fp)
 8241858:	10000005 	stb	zero,0(r2)

   rfqp = &(irep->rfq);
 824185c:	e0bffd17 	ldw	r2,-12(fp)
 8241860:	10800604 	addi	r2,r2,24
 8241864:	e0bff415 	stw	r2,-48(fp)

   while (rfqp)
 8241868:	0000ef06 	br	8241c28 <ip_reasm_compute_overlap+0x538>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 824186c:	e03ff60d 	sth	zero,-40(fp)
 8241870:	0000dd06 	br	8241be8 <ip_reasm_compute_overlap+0x4f8>
         {
         if ((currpkt = rfqp->bufp[i]) != 0)
 8241874:	e0bff60b 	ldhu	r2,-40(fp)
 8241878:	e0fff417 	ldw	r3,-48(fp)
 824187c:	10800044 	addi	r2,r2,1
 8241880:	1085883a 	add	r2,r2,r2
 8241884:	1085883a 	add	r2,r2,r2
 8241888:	1885883a 	add	r2,r3,r2
 824188c:	10800017 	ldw	r2,0(r2)
 8241890:	e0bff915 	stw	r2,-28(fp)
 8241894:	e0bff917 	ldw	r2,-28(fp)
 8241898:	1000c026 	beq	r2,zero,8241b9c <ip_reasm_compute_overlap+0x4ac>
            {
            currstart = rfqp->frag_offset[i];
 824189c:	e0bff60b 	ldhu	r2,-40(fp)
 82418a0:	e0fff417 	ldw	r3,-48(fp)
 82418a4:	10800884 	addi	r2,r2,34
 82418a8:	1085883a 	add	r2,r2,r2
 82418ac:	1885883a 	add	r2,r3,r2
 82418b0:	1080000b 	ldhu	r2,0(r2)
 82418b4:	e0bffa0d 	sth	r2,-24(fp)
            currend = currstart + currpkt->nb_plen - 1;
 82418b8:	e0bff917 	ldw	r2,-28(fp)
 82418bc:	10800417 	ldw	r2,16(r2)
 82418c0:	1007883a 	mov	r3,r2
 82418c4:	e0bffa0b 	ldhu	r2,-24(fp)
 82418c8:	1885883a 	add	r2,r3,r2
 82418cc:	10bfffc4 	addi	r2,r2,-1
 82418d0:	e0bffa8d 	sth	r2,-22(fp)

            if (currstart < jrstart)
 82418d4:	e0fffa0b 	ldhu	r3,-24(fp)
 82418d8:	e0bff50b 	ldhu	r2,-44(fp)
 82418dc:	18802b2e 	bgeu	r3,r2,824198c <ip_reasm_compute_overlap+0x29c>
               {
               if (currend < jrend) /* cases A1 and A2 */
 82418e0:	e0fffa8b 	ldhu	r3,-22(fp)
 82418e4:	e0bff58b 	ldhu	r2,-42(fp)
 82418e8:	1880202e 	bgeu	r3,r2,824196c <ip_reasm_compute_overlap+0x27c>
                  {
                  if (currend < jrstart) /* A1 */
 82418ec:	e0fffa8b 	ldhu	r3,-22(fp)
 82418f0:	e0bff50b 	ldhu	r2,-44(fp)
 82418f4:	1880b936 	bltu	r3,r2,8241bdc <ip_reasm_compute_overlap+0x4ec>
                     {
                     /* the just received fragment partially overlaps current 
                      * fragment on the latter's right; increment start 
                      * pointer and decrement length of just received fragment.
                      * Move on to the next fragment in the RFQ. */
                     drop_len = (currend - jrstart) + 1;
 82418f8:	e0fffa8b 	ldhu	r3,-22(fp)
 82418fc:	e0bff50b 	ldhu	r2,-44(fp)
 8241900:	1885c83a 	sub	r2,r3,r2
 8241904:	10800044 	addi	r2,r2,1
 8241908:	e0bffb0d 	sth	r2,-20(fp)
                     p->nb_prot += drop_len;
 824190c:	e0bffc17 	ldw	r2,-16(fp)
 8241910:	10c00317 	ldw	r3,12(r2)
 8241914:	e0bffb0b 	ldhu	r2,-20(fp)
 8241918:	1887883a 	add	r3,r3,r2
 824191c:	e0bffc17 	ldw	r2,-16(fp)
 8241920:	10c00315 	stw	r3,12(r2)
                     p->nb_plen -= drop_len;
 8241924:	e0bffc17 	ldw	r2,-16(fp)
 8241928:	10c00417 	ldw	r3,16(r2)
 824192c:	e0bffb0b 	ldhu	r2,-20(fp)
 8241930:	1887c83a 	sub	r3,r3,r2
 8241934:	e0bffc17 	ldw	r2,-16(fp)
 8241938:	10c00415 	stw	r3,16(r2)
                     jrstart += drop_len;
 824193c:	e0fff50b 	ldhu	r3,-44(fp)
 8241940:	e0bffb0b 	ldhu	r2,-20(fp)
 8241944:	1885883a 	add	r2,r3,r2
 8241948:	e0bff50d 	sth	r2,-44(fp)
                     jrend = jrstart + p->nb_plen - 1;
 824194c:	e0bffc17 	ldw	r2,-16(fp)
 8241950:	10800417 	ldw	r2,16(r2)
 8241954:	1007883a 	mov	r3,r2
 8241958:	e0bff50b 	ldhu	r2,-44(fp)
 824195c:	1885883a 	add	r2,r3,r2
 8241960:	10bfffc4 	addi	r2,r2,-1
 8241964:	e0bff58d 	sth	r2,-42(fp)
 8241968:	00009c06 	br	8241bdc <ip_reasm_compute_overlap+0x4ec>
               else
                  {
                  /* currend is greater than or equal to jrend (cases E1 and E2).
                   * The current fragment is a superset of the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 824196c:	01000084 	movi	r4,2
 8241970:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
                  pk_free (p);
 8241974:	e13ffc17 	ldw	r4,-16(fp)
 8241978:	822cd980 	call	822cd98 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 824197c:	01000084 	movi	r4,2
 8241980:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 8241984:	0005883a 	mov	r2,zero
 8241988:	0000ad06 	br	8241c40 <ip_reasm_compute_overlap+0x550>
                  }
               }
            else if (currstart > jrstart)
 824198c:	e0bffa0b 	ldhu	r2,-24(fp)
 8241990:	e0fff50b 	ldhu	r3,-44(fp)
 8241994:	18804e2e 	bgeu	r3,r2,8241ad0 <ip_reasm_compute_overlap+0x3e0>
               {
               if (currend > jrend) /* cases B1 and B2 */
 8241998:	e0bffa8b 	ldhu	r2,-22(fp)
 824199c:	e0fff58b 	ldhu	r3,-42(fp)
 82419a0:	1880112e 	bgeu	r3,r2,82419e8 <ip_reasm_compute_overlap+0x2f8>
                  {
                  if (currstart > jrend) /* B1 */
 82419a4:	e0bffa0b 	ldhu	r2,-24(fp)
 82419a8:	e0fff58b 	ldhu	r3,-42(fp)
 82419ac:	18808b36 	bltu	r3,r2,8241bdc <ip_reasm_compute_overlap+0x4ec>
                     {
                     /* just received fragment partially overlaps current 
                      * fragment on the latter's left; decrement length of 
                      * just received fragment.  Move on to the next fragment 
                      * in the RFQ. */
                     p->nb_plen = currstart - jrstart;
 82419b0:	e0fffa0b 	ldhu	r3,-24(fp)
 82419b4:	e0bff50b 	ldhu	r2,-44(fp)
 82419b8:	1885c83a 	sub	r2,r3,r2
 82419bc:	1007883a 	mov	r3,r2
 82419c0:	e0bffc17 	ldw	r2,-16(fp)
 82419c4:	10c00415 	stw	r3,16(r2)
                     /* start offset remains unchanged, but jrend must be updated */
                     jrend = jrstart + p->nb_plen - 1;
 82419c8:	e0bffc17 	ldw	r2,-16(fp)
 82419cc:	10800417 	ldw	r2,16(r2)
 82419d0:	1007883a 	mov	r3,r2
 82419d4:	e0bff50b 	ldhu	r2,-44(fp)
 82419d8:	1885883a 	add	r2,r3,r2
 82419dc:	10bfffc4 	addi	r2,r2,-1
 82419e0:	e0bff58d 	sth	r2,-42(fp)
 82419e4:	00007d06 	br	8241bdc <ip_reasm_compute_overlap+0x4ec>
                     }
                  }
               else if (currend == jrend) /* F1 */
 82419e8:	e0fffa8b 	ldhu	r3,-22(fp)
 82419ec:	e0bff58b 	ldhu	r2,-42(fp)
 82419f0:	18800e1e 	bne	r3,r2,8241a2c <ip_reasm_compute_overlap+0x33c>
                  {
                  /* current fragment is a subset of the just received fragment.  
                   * Decrement the length of the just received fragment.  Move
                   * on to the next fragment in the RFQ. */
                  p->nb_plen = currstart - jrstart;
 82419f4:	e0fffa0b 	ldhu	r3,-24(fp)
 82419f8:	e0bff50b 	ldhu	r2,-44(fp)
 82419fc:	1885c83a 	sub	r2,r3,r2
 8241a00:	1007883a 	mov	r3,r2
 8241a04:	e0bffc17 	ldw	r2,-16(fp)
 8241a08:	10c00415 	stw	r3,16(r2)
                  jrend = jrstart + p->nb_plen - 1;
 8241a0c:	e0bffc17 	ldw	r2,-16(fp)
 8241a10:	10800417 	ldw	r2,16(r2)
 8241a14:	1007883a 	mov	r3,r2
 8241a18:	e0bff50b 	ldhu	r2,-44(fp)
 8241a1c:	1885883a 	add	r2,r3,r2
 8241a20:	10bfffc4 	addi	r2,r2,-1
 8241a24:	e0bff58d 	sth	r2,-42(fp)
 8241a28:	00006c06 	br	8241bdc <ip_reasm_compute_overlap+0x4ec>
                  {
                  /* currend is less than jrend (case F2).  current fragment is 
                   * a subset of the just received fragment.  Drop current
                   * fragment.  Move on to the next fragment in the RFQ.  Decrement
                   * the amount of memory currently in use. */
                  ip_reasm_decr_mem_useage (currpkt->nb_blen);
 8241a2c:	e0bff917 	ldw	r2,-28(fp)
 8241a30:	10800217 	ldw	r2,8(r2)
 8241a34:	10bfffcc 	andi	r2,r2,65535
 8241a38:	1009883a 	mov	r4,r2
 8241a3c:	82413180 	call	8241318 <ip_reasm_decr_mem_useage>
                  irep->rcvd -= currpkt->nb_plen;
 8241a40:	e0bffd17 	ldw	r2,-12(fp)
 8241a44:	1080048b 	ldhu	r2,18(r2)
 8241a48:	e0fff917 	ldw	r3,-28(fp)
 8241a4c:	18c00417 	ldw	r3,16(r3)
 8241a50:	10c5c83a 	sub	r2,r2,r3
 8241a54:	1007883a 	mov	r3,r2
 8241a58:	e0bffd17 	ldw	r2,-12(fp)
 8241a5c:	10c0048d 	sth	r3,18(r2)
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 8241a60:	01000084 	movi	r4,2
 8241a64:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
                  pk_free (currpkt);
 8241a68:	e13ff917 	ldw	r4,-28(fp)
 8241a6c:	822cd980 	call	822cd98 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241a70:	01000084 	movi	r4,2
 8241a74:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
                  rfqp->bufp[i] = 0; /* mark slot as unused */
 8241a78:	e0bff60b 	ldhu	r2,-40(fp)
 8241a7c:	e0fff417 	ldw	r3,-48(fp)
 8241a80:	10800044 	addi	r2,r2,1
 8241a84:	1085883a 	add	r2,r2,r2
 8241a88:	1085883a 	add	r2,r2,r2
 8241a8c:	1885883a 	add	r2,r3,r2
 8241a90:	10000015 	stw	zero,0(r2)
                  /* save the location of the empty slot */
                  if ((*indexp) == INVALID_FRAG_INDEX) 
 8241a94:	e0bffe17 	ldw	r2,-8(fp)
 8241a98:	1080000b 	ldhu	r2,0(r2)
 8241a9c:	10bfffcc 	andi	r2,r2,65535
 8241aa0:	10800418 	cmpnei	r2,r2,16
 8241aa4:	1000061e 	bne	r2,zero,8241ac0 <ip_reasm_compute_overlap+0x3d0>
                     {
                     *indexp = i;
 8241aa8:	e0bffe17 	ldw	r2,-8(fp)
 8241aac:	e0fff60b 	ldhu	r3,-40(fp)
 8241ab0:	10c0000d 	sth	r3,0(r2)
                     *last_rfqpp = rfqp;
 8241ab4:	e0bfff17 	ldw	r2,-4(fp)
 8241ab8:	e0fff417 	ldw	r3,-48(fp)
 8241abc:	10c00015 	stw	r3,0(r2)
                     }
                  /* we've just created a hole; the array may no longer be "compact" */
                  *hole_createdp = IPREASM_TRUE;
 8241ac0:	e0800317 	ldw	r2,12(fp)
 8241ac4:	00c00044 	movi	r3,1
 8241ac8:	10c00005 	stb	r3,0(r2)
 8241acc:	00004306 	br	8241bdc <ip_reasm_compute_overlap+0x4ec>
                  }
               }
            else
               {
               /* currstart and jrstart are equal */
               if (currend == jrend) /* case C */
 8241ad0:	e0fffa8b 	ldhu	r3,-22(fp)
 8241ad4:	e0bff58b 	ldhu	r2,-42(fp)
 8241ad8:	1880081e 	bne	r3,r2,8241afc <ip_reasm_compute_overlap+0x40c>
                  {
                  /* the current fragment is identical to the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 8241adc:	01000084 	movi	r4,2
 8241ae0:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
                  pk_free (p);
 8241ae4:	e13ffc17 	ldw	r4,-16(fp)
 8241ae8:	822cd980 	call	822cd98 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241aec:	01000084 	movi	r4,2
 8241af0:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 8241af4:	0005883a 	mov	r2,zero
 8241af8:	00005106 	br	8241c40 <ip_reasm_compute_overlap+0x550>
                  }
               else if (currend > jrend) /* case D1 */
 8241afc:	e0bffa8b 	ldhu	r2,-22(fp)
 8241b00:	e0fff58b 	ldhu	r3,-42(fp)
 8241b04:	1880082e 	bgeu	r3,r2,8241b28 <ip_reasm_compute_overlap+0x438>
                  {
                  /* current fragment is a superset of just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 8241b08:	01000084 	movi	r4,2
 8241b0c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
                  pk_free (p);
 8241b10:	e13ffc17 	ldw	r4,-16(fp)
 8241b14:	822cd980 	call	822cd98 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241b18:	01000084 	movi	r4,2
 8241b1c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 8241b20:	0005883a 	mov	r2,zero
 8241b24:	00004606 	br	8241c40 <ip_reasm_compute_overlap+0x550>
                  /* currend is less than jrend (case D2).  current fragment 
                   * is a subset of the just received fragment.  Increment 
                   * the start pointer and decrement the length of the just
                   * received fragment.  Move on to the next fragment in 
                   * the RFQ. */
                  drop_len = (currend - jrstart) + 1;
 8241b28:	e0fffa8b 	ldhu	r3,-22(fp)
 8241b2c:	e0bff50b 	ldhu	r2,-44(fp)
 8241b30:	1885c83a 	sub	r2,r3,r2
 8241b34:	10800044 	addi	r2,r2,1
 8241b38:	e0bffb0d 	sth	r2,-20(fp)
                  p->nb_prot += drop_len;
 8241b3c:	e0bffc17 	ldw	r2,-16(fp)
 8241b40:	10c00317 	ldw	r3,12(r2)
 8241b44:	e0bffb0b 	ldhu	r2,-20(fp)
 8241b48:	1887883a 	add	r3,r3,r2
 8241b4c:	e0bffc17 	ldw	r2,-16(fp)
 8241b50:	10c00315 	stw	r3,12(r2)
                  p->nb_plen -= drop_len;
 8241b54:	e0bffc17 	ldw	r2,-16(fp)
 8241b58:	10c00417 	ldw	r3,16(r2)
 8241b5c:	e0bffb0b 	ldhu	r2,-20(fp)
 8241b60:	1887c83a 	sub	r3,r3,r2
 8241b64:	e0bffc17 	ldw	r2,-16(fp)
 8241b68:	10c00415 	stw	r3,16(r2)
                  jrstart += drop_len;
 8241b6c:	e0fff50b 	ldhu	r3,-44(fp)
 8241b70:	e0bffb0b 	ldhu	r2,-20(fp)
 8241b74:	1885883a 	add	r2,r3,r2
 8241b78:	e0bff50d 	sth	r2,-44(fp)
                  jrend = jrstart + p->nb_plen - 1;
 8241b7c:	e0bffc17 	ldw	r2,-16(fp)
 8241b80:	10800417 	ldw	r2,16(r2)
 8241b84:	1007883a 	mov	r3,r2
 8241b88:	e0bff50b 	ldhu	r2,-44(fp)
 8241b8c:	1885883a 	add	r2,r3,r2
 8241b90:	10bfffc4 	addi	r2,r2,-1
 8241b94:	e0bff58d 	sth	r2,-42(fp)
 8241b98:	00001006 	br	8241bdc <ip_reasm_compute_overlap+0x4ec>
                  }
               }
            } /* end if (PACKET buffer exists at this slot) */
         else
            {
            if ((*indexp) == INVALID_FRAG_INDEX)
 8241b9c:	e0bffe17 	ldw	r2,-8(fp)
 8241ba0:	1080000b 	ldhu	r2,0(r2)
 8241ba4:	10bfffcc 	andi	r2,r2,65535
 8241ba8:	10800418 	cmpnei	r2,r2,16
 8241bac:	1000061e 	bne	r2,zero,8241bc8 <ip_reasm_compute_overlap+0x4d8>
               {
               *indexp = i;
 8241bb0:	e0bffe17 	ldw	r2,-8(fp)
 8241bb4:	e0fff60b 	ldhu	r3,-40(fp)
 8241bb8:	10c0000d 	sth	r3,0(r2)
               *last_rfqpp = rfqp;               
 8241bbc:	e0bfff17 	ldw	r2,-4(fp)
 8241bc0:	e0fff417 	ldw	r3,-48(fp)
 8241bc4:	10c00015 	stw	r3,0(r2)
               }
            if (irep->flags & IPR_RFQ_COMPACT)
 8241bc8:	e0bffd17 	ldw	r2,-12(fp)
 8241bcc:	10802103 	ldbu	r2,132(r2)
 8241bd0:	10803fcc 	andi	r2,r2,255
 8241bd4:	1080004c 	andi	r2,r2,1
 8241bd8:	1000071e 	bne	r2,zero,8241bf8 <ip_reasm_compute_overlap+0x508>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8241bdc:	e0bff60b 	ldhu	r2,-40(fp)
 8241be0:	10800044 	addi	r2,r2,1
 8241be4:	e0bff60d 	sth	r2,-40(fp)
 8241be8:	e0bff60b 	ldhu	r2,-40(fp)
 8241bec:	10800430 	cmpltui	r2,r2,16
 8241bf0:	103f201e 	bne	r2,zero,8241874 <ip_reasm_compute_overlap+0x184>
 8241bf4:	00000106 	br	8241bfc <ip_reasm_compute_overlap+0x50c>
               *indexp = i;
               *last_rfqpp = rfqp;               
               }
            if (irep->flags & IPR_RFQ_COMPACT)
               {
               break;
 8241bf8:	0001883a 	nop
               }
            }
         } /* end FOR (0...(IPR_MAX_FRAGS - 1)) */

      /* skip saving RFQ pointer if we've already found an empty slot */
      if ((*indexp) == INVALID_FRAG_INDEX) 
 8241bfc:	e0bffe17 	ldw	r2,-8(fp)
 8241c00:	1080000b 	ldhu	r2,0(r2)
 8241c04:	10bfffcc 	andi	r2,r2,65535
 8241c08:	10800418 	cmpnei	r2,r2,16
 8241c0c:	1000031e 	bne	r2,zero,8241c1c <ip_reasm_compute_overlap+0x52c>
         {
         *last_rfqpp = rfqp;
 8241c10:	e0bfff17 	ldw	r2,-4(fp)
 8241c14:	e0fff417 	ldw	r3,-48(fp)
 8241c18:	10c00015 	stw	r3,0(r2)
         }
      rfqp = rfqp->next;
 8241c1c:	e0bff417 	ldw	r2,-48(fp)
 8241c20:	10800017 	ldw	r2,0(r2)
 8241c24:	e0bff415 	stw	r2,-48(fp)
   *last_rfqpp = 0;
   *hole_createdp = IPREASM_FALSE;

   rfqp = &(irep->rfq);

   while (rfqp)
 8241c28:	e0bff417 	ldw	r2,-48(fp)
 8241c2c:	103f0f1e 	bne	r2,zero,824186c <ip_reasm_compute_overlap+0x17c>
      } /* end while (rfqp) */

   /* if no empty slots were found, (*last_rfqpp) will contain a pointer 
    * to the last RFQ that we were working with */

   *frag_offsetp = jrstart; /* stored in host byte order */
 8241c30:	e0800217 	ldw	r2,8(fp)
 8241c34:	e0fff50b 	ldhu	r3,-44(fp)
 8241c38:	10c0000d 	sth	r3,0(r2)

   return IPREASM_ACCEPT_FRAG;
 8241c3c:	00800084 	movi	r2,2
}
 8241c40:	e037883a 	mov	sp,fp
 8241c44:	dfc00117 	ldw	ra,4(sp)
 8241c48:	df000017 	ldw	fp,0(sp)
 8241c4c:	dec00204 	addi	sp,sp,8
 8241c50:	f800283a 	ret

08241c54 <ip_reasm_process_subsequent_fragments>:
            queued fragments (and hence has been dropped), or if the fragment
            has been processed successfully.
*/

int ip_reasm_process_subsequent_fragments (PACKET p, IREP irep)
{
 8241c54:	defff104 	addi	sp,sp,-60
 8241c58:	dfc00e15 	stw	ra,56(sp)
 8241c5c:	df000d15 	stw	fp,52(sp)
 8241c60:	df000d04 	addi	fp,sp,52
 8241c64:	e13ffe15 	stw	r4,-8(fp)
 8241c68:	e17fff15 	stw	r5,-4(fp)
   PACKET reassy_pkt;
   struct ip * pip;
   RFQP new_rfqp = 0;
 8241c6c:	e03ff515 	stw	zero,-44(fp)
   u_short index;
   RFQP rfqp;
   u_short frag_offset;
   u_char hole_created;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 8241c70:	e13fff17 	ldw	r4,-4(fp)
 8241c74:	82421840 	call	8242184 <ip_reasm_find_ire>
 8241c78:	10803fcc 	andi	r2,r2,255
 8241c7c:	10800060 	cmpeqi	r2,r2,1
 8241c80:	1000161e 	bne	r2,zero,8241cdc <ip_reasm_process_subsequent_fragments+0x88>
      {
      ++ire_stats.bad_irep;
 8241c84:	008209b4 	movhi	r2,2086
 8241c88:	10ba9704 	addi	r2,r2,-5540
 8241c8c:	10800017 	ldw	r2,0(r2)
 8241c90:	10c00044 	addi	r3,r2,1
 8241c94:	008209b4 	movhi	r2,2086
 8241c98:	10ba9704 	addi	r2,r2,-5540
 8241c9c:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 8241ca0:	01000084 	movi	r4,2
 8241ca4:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free (p);
 8241ca8:	e13ffe17 	ldw	r4,-8(fp)
 8241cac:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241cb0:	01000084 	movi	r4,2
 8241cb4:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 8241cb8:	008209b4 	movhi	r2,2086
 8241cbc:	10ba8304 	addi	r2,r2,-5620
 8241cc0:	10800f17 	ldw	r2,60(r2)
 8241cc4:	10c00044 	addi	r3,r2,1
 8241cc8:	008209b4 	movhi	r2,2086
 8241ccc:	10ba8304 	addi	r2,r2,-5620
 8241cd0:	10c00f15 	stw	r3,60(r2)
      return ENP_PARAM;
 8241cd4:	00bffd84 	movi	r2,-10
 8241cd8:	00012506 	br	8242170 <ip_reasm_process_subsequent_fragments+0x51c>
      }

   pip = ip_head(p);
 8241cdc:	e0bffe17 	ldw	r2,-8(fp)
 8241ce0:	10800317 	ldw	r2,12(r2)
 8241ce4:	e0bff615 	stw	r2,-40(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 8241ce8:	e13ff617 	ldw	r4,-40(fp)
 8241cec:	82411140 	call	8241114 <ip_reasm_determine_type_of_frag>
 8241cf0:	e0bff715 	stw	r2,-36(fp)
   /* this fragment is a destined for an already queued fragment stream.
    * we update the 'length' field for LFs here because ip_reasm_compute_overlap ()
    * modifies the received fragment's nb_prot pointer (thereby making its IP header 
    * inaccessible) */
   if (ftype == IP_LF)
 8241cf4:	e0bff717 	ldw	r2,-36(fp)
 8241cf8:	10800158 	cmpnei	r2,r2,5
 8241cfc:	1000251e 	bne	r2,zero,8241d94 <ip_reasm_process_subsequent_fragments+0x140>
      {
      irep->length = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3) + ((ntohs(pip->ip_len)) - ip_hlen(pip));
 8241d00:	e0bff617 	ldw	r2,-40(fp)
 8241d04:	1080018b 	ldhu	r2,6(r2)
 8241d08:	10bfffcc 	andi	r2,r2,65535
 8241d0c:	1004d23a 	srli	r2,r2,8
 8241d10:	10bfffcc 	andi	r2,r2,65535
 8241d14:	10c03fcc 	andi	r3,r2,255
 8241d18:	e0bff617 	ldw	r2,-40(fp)
 8241d1c:	1080018b 	ldhu	r2,6(r2)
 8241d20:	10bfffcc 	andi	r2,r2,65535
 8241d24:	1004923a 	slli	r2,r2,8
 8241d28:	10bfffcc 	andi	r2,r2,65535
 8241d2c:	1884b03a 	or	r2,r3,r2
 8241d30:	100490fa 	slli	r2,r2,3
 8241d34:	1007883a 	mov	r3,r2
 8241d38:	e0bff617 	ldw	r2,-40(fp)
 8241d3c:	1080008b 	ldhu	r2,2(r2)
 8241d40:	10bfffcc 	andi	r2,r2,65535
 8241d44:	1004d23a 	srli	r2,r2,8
 8241d48:	1009883a 	mov	r4,r2
 8241d4c:	e0bff617 	ldw	r2,-40(fp)
 8241d50:	1080008b 	ldhu	r2,2(r2)
 8241d54:	10bfffcc 	andi	r2,r2,65535
 8241d58:	1004923a 	slli	r2,r2,8
 8241d5c:	2084b03a 	or	r2,r4,r2
 8241d60:	1009883a 	mov	r4,r2
 8241d64:	e0bff617 	ldw	r2,-40(fp)
 8241d68:	10800003 	ldbu	r2,0(r2)
 8241d6c:	10803fcc 	andi	r2,r2,255
 8241d70:	108003cc 	andi	r2,r2,15
 8241d74:	1085883a 	add	r2,r2,r2
 8241d78:	1085883a 	add	r2,r2,r2
 8241d7c:	2085c83a 	sub	r2,r4,r2
 8241d80:	1885883a 	add	r2,r3,r2
 8241d84:	1007883a 	mov	r3,r2
 8241d88:	e0bfff17 	ldw	r2,-4(fp)
 8241d8c:	10c0040d 	sth	r3,16(r2)
 8241d90:	00000a06 	br	8241dbc <ip_reasm_process_subsequent_fragments+0x168>
      }
   else if (ftype == IP_FF)
 8241d94:	e0bff717 	ldw	r2,-36(fp)
 8241d98:	10800058 	cmpnei	r2,r2,1
 8241d9c:	1000071e 	bne	r2,zero,8241dbc <ip_reasm_process_subsequent_fragments+0x168>
      {
      irep->l2_hdr = p->nb_buff;
 8241da0:	e0bffe17 	ldw	r2,-8(fp)
 8241da4:	10c00117 	ldw	r3,4(r2)
 8241da8:	e0bfff17 	ldw	r2,-4(fp)
 8241dac:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 8241db0:	e0bfff17 	ldw	r2,-4(fp)
 8241db4:	e0fff617 	ldw	r3,-40(fp)
 8241db8:	10c02015 	stw	r3,128(r2)
      }

   /* Check for overlap, and determine the increase in memory resource 
    * requirements from the newly arrived fragment */
   if ((rc2 = ip_reasm_compute_overlap (p, irep, &index, &rfqp, &frag_offset, &hole_created)) != IPREASM_ACCEPT_FRAG)
 8241dbc:	e13ffc04 	addi	r4,fp,-16
 8241dc0:	e0fffb04 	addi	r3,fp,-20
 8241dc4:	e0bffd84 	addi	r2,fp,-10
 8241dc8:	d8800115 	stw	r2,4(sp)
 8241dcc:	e0bffd04 	addi	r2,fp,-12
 8241dd0:	d8800015 	stw	r2,0(sp)
 8241dd4:	200f883a 	mov	r7,r4
 8241dd8:	180d883a 	mov	r6,r3
 8241ddc:	e17fff17 	ldw	r5,-4(fp)
 8241de0:	e13ffe17 	ldw	r4,-8(fp)
 8241de4:	82416f00 	call	82416f0 <ip_reasm_compute_overlap>
 8241de8:	e0bff815 	stw	r2,-32(fp)
 8241dec:	e0bff817 	ldw	r2,-32(fp)
 8241df0:	108000a0 	cmpeqi	r2,r2,2
 8241df4:	1000091e 	bne	r2,zero,8241e1c <ip_reasm_process_subsequent_fragments+0x1c8>
      {
      switch (rc2)
 8241df8:	e0bff817 	ldw	r2,-32(fp)
 8241dfc:	10c00060 	cmpeqi	r3,r2,1
 8241e00:	1800031e 	bne	r3,zero,8241e10 <ip_reasm_process_subsequent_fragments+0x1bc>
 8241e04:	00800436 	bltu	zero,r2,8241e18 <ip_reasm_process_subsequent_fragments+0x1c4>
         {
         case IPREASM_DROP_FRAG_DUPLICATE:
            /* this isn't really an error, since it indicates that the received 
             * fragment's information is a duplicate of what is present in the 
             * already queued fragments */
            return IPREASM_OK;
 8241e08:	0005883a 	mov	r2,zero
 8241e0c:	0000d806 	br	8242170 <ip_reasm_process_subsequent_fragments+0x51c>
         case IPREASM_DROP_FRAG_BAD_PARAM:
            /* this is a real error */
            return ENP_PARAM;
 8241e10:	00bffd84 	movi	r2,-10
 8241e14:	0000d606 	br	8242170 <ip_reasm_process_subsequent_fragments+0x51c>
          * Altera Niche Stack Nios port modification:
          * Handle IPREASM_ACCEPT_FRAG case (will never
          * get here per if() above) to remove build warning.
          */
         case IPREASM_ACCEPT_FRAG:
            while(0);
 8241e18:	0001883a 	nop
      }

   /* this is a fragment from an existing fragment stream; 
    * check for resource limits before accepting it.  For now
    * assume that an extra RFQ is not required. */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen)) != IPREASM_OK)
 8241e1c:	e0bffe17 	ldw	r2,-8(fp)
 8241e20:	10800217 	ldw	r2,8(r2)
 8241e24:	10bfffcc 	andi	r2,r2,65535
 8241e28:	1009883a 	mov	r4,r2
 8241e2c:	82411e40 	call	82411e4 <ip_reasm_check_mem_useage>
 8241e30:	e0bff915 	stw	r2,-28(fp)
 8241e34:	e0bff917 	ldw	r2,-28(fp)
 8241e38:	10001126 	beq	r2,zero,8241e80 <ip_reasm_process_subsequent_fragments+0x22c>
      {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 8241e3c:	01000084 	movi	r4,2
 8241e40:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free (p);
 8241e44:	e13ffe17 	ldw	r4,-8(fp)
 8241e48:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241e4c:	01000084 	movi	r4,2
 8241e50:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      ip_reasm_delete_ire (irep);
 8241e54:	e13fff17 	ldw	r4,-4(fp)
 8241e58:	82426000 	call	8242600 <ip_reasm_delete_ire>
      ++ip_mib.ipReasmFails;
 8241e5c:	008209b4 	movhi	r2,2086
 8241e60:	10ba8304 	addi	r2,r2,-5620
 8241e64:	10800f17 	ldw	r2,60(r2)
 8241e68:	10c00044 	addi	r3,r2,1
 8241e6c:	008209b4 	movhi	r2,2086
 8241e70:	10ba8304 	addi	r2,r2,-5620
 8241e74:	10c00f15 	stw	r3,60(r2)
      return rc;
 8241e78:	e0bff917 	ldw	r2,-28(fp)
 8241e7c:	0000bc06 	br	8242170 <ip_reasm_process_subsequent_fragments+0x51c>

   /* the two combinations of index and rfqp are as follows:
    * (1) index = INVALID_FRAG_INDEX, rfqp = non-zero: no empty slot found in RFQ(s),
    *     and rfqp points to the last RFQ that was processed
    * (2) index != INVALID_FRAG_INDEX, rfqp = non-zero: empty slot found in RFQ(s) */
   if (index != INVALID_FRAG_INDEX)
 8241e80:	e0bffb0b 	ldhu	r2,-20(fp)
 8241e84:	10bfffcc 	andi	r2,r2,65535
 8241e88:	10800420 	cmpeqi	r2,r2,16
 8241e8c:	1000121e 	bne	r2,zero,8241ed8 <ip_reasm_process_subsequent_fragments+0x284>
      {
      /* we have an empty slot in the PACKET array into which we can place 
       * the just received fragment */
      rfqp->bufp[index] = p;
 8241e90:	e0fffc17 	ldw	r3,-16(fp)
 8241e94:	e0bffb0b 	ldhu	r2,-20(fp)
 8241e98:	10bfffcc 	andi	r2,r2,65535
 8241e9c:	10800044 	addi	r2,r2,1
 8241ea0:	1085883a 	add	r2,r2,r2
 8241ea4:	1085883a 	add	r2,r2,r2
 8241ea8:	1885883a 	add	r2,r3,r2
 8241eac:	e0fffe17 	ldw	r3,-8(fp)
 8241eb0:	10c00015 	stw	r3,0(r2)
      rfqp->frag_offset[index] = frag_offset;
 8241eb4:	e13ffc17 	ldw	r4,-16(fp)
 8241eb8:	e0bffb0b 	ldhu	r2,-20(fp)
 8241ebc:	10bfffcc 	andi	r2,r2,65535
 8241ec0:	e0fffd0b 	ldhu	r3,-12(fp)
 8241ec4:	10800884 	addi	r2,r2,34
 8241ec8:	1085883a 	add	r2,r2,r2
 8241ecc:	2085883a 	add	r2,r4,r2
 8241ed0:	10c0000d 	sth	r3,0(r2)
 8241ed4:	00003906 	br	8241fbc <ip_reasm_process_subsequent_fragments+0x368>
      }
   else
      {
      /* since we need to allocate an extra RFQ, check for memory useage again... */
      if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (RFQ)))) != IPREASM_OK)
 8241ed8:	e0bffe17 	ldw	r2,-8(fp)
 8241edc:	10800217 	ldw	r2,8(r2)
 8241ee0:	10801904 	addi	r2,r2,100
 8241ee4:	10bfffcc 	andi	r2,r2,65535
 8241ee8:	1009883a 	mov	r4,r2
 8241eec:	82411e40 	call	82411e4 <ip_reasm_check_mem_useage>
 8241ef0:	e0bff915 	stw	r2,-28(fp)
 8241ef4:	e0bff917 	ldw	r2,-28(fp)
 8241ef8:	10001126 	beq	r2,zero,8241f40 <ip_reasm_process_subsequent_fragments+0x2ec>
         {
         LOCK_NET_RESOURCE (FREEQ_RESID);
 8241efc:	01000084 	movi	r4,2
 8241f00:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
         pk_free (p);
 8241f04:	e13ffe17 	ldw	r4,-8(fp)
 8241f08:	822cd980 	call	822cd98 <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241f0c:	01000084 	movi	r4,2
 8241f10:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 8241f14:	e13fff17 	ldw	r4,-4(fp)
 8241f18:	82426000 	call	8242600 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 8241f1c:	008209b4 	movhi	r2,2086
 8241f20:	10ba8304 	addi	r2,r2,-5620
 8241f24:	10800f17 	ldw	r2,60(r2)
 8241f28:	10c00044 	addi	r3,r2,1
 8241f2c:	008209b4 	movhi	r2,2086
 8241f30:	10ba8304 	addi	r2,r2,-5620
 8241f34:	10c00f15 	stw	r3,60(r2)
         return rc;
 8241f38:	e0bff917 	ldw	r2,-28(fp)
 8241f3c:	00008c06 	br	8242170 <ip_reasm_process_subsequent_fragments+0x51c>
         }

      /* no slots are available in the one (or more) existing RFQs; we 
       * need to create a new RFQ to store the just received fragment */
      new_rfqp = (RFQP) IPR_ALLOC (sizeof(RFQ));
 8241f40:	01001904 	movi	r4,100
 8241f44:	822e1c80 	call	822e1c8 <npalloc>
 8241f48:	e0bff515 	stw	r2,-44(fp)
      if (new_rfqp == 0)
 8241f4c:	e0bff517 	ldw	r2,-44(fp)
 8241f50:	1000111e 	bne	r2,zero,8241f98 <ip_reasm_process_subsequent_fragments+0x344>
         {
         /* can't store the existing fragment, so we'll drop it */
         LOCK_NET_RESOURCE (FREEQ_RESID);
 8241f54:	01000084 	movi	r4,2
 8241f58:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
         pk_free (p);
 8241f5c:	e13ffe17 	ldw	r4,-8(fp)
 8241f60:	822cd980 	call	822cd98 <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241f64:	01000084 	movi	r4,2
 8241f68:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 8241f6c:	e13fff17 	ldw	r4,-4(fp)
 8241f70:	82426000 	call	8242600 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 8241f74:	008209b4 	movhi	r2,2086
 8241f78:	10ba8304 	addi	r2,r2,-5620
 8241f7c:	10800f17 	ldw	r2,60(r2)
 8241f80:	10c00044 	addi	r3,r2,1
 8241f84:	008209b4 	movhi	r2,2086
 8241f88:	10ba8304 	addi	r2,r2,-5620
 8241f8c:	10c00f15 	stw	r3,60(r2)
         return ENP_RESOURCE;
 8241f90:	00bffa84 	movi	r2,-22
 8241f94:	00007606 	br	8242170 <ip_reasm_process_subsequent_fragments+0x51c>
         }
      else
         {
         new_rfqp->bufp[0] = p;
 8241f98:	e0bff517 	ldw	r2,-44(fp)
 8241f9c:	e0fffe17 	ldw	r3,-8(fp)
 8241fa0:	10c00115 	stw	r3,4(r2)
         new_rfqp->frag_offset[0] = frag_offset;
 8241fa4:	e0fffd0b 	ldhu	r3,-12(fp)
 8241fa8:	e0bff517 	ldw	r2,-44(fp)
 8241fac:	10c0110d 	sth	r3,68(r2)
         rfqp->next = new_rfqp;
 8241fb0:	e0bffc17 	ldw	r2,-16(fp)
 8241fb4:	e0fff517 	ldw	r3,-44(fp)
 8241fb8:	10c00015 	stw	r3,0(r2)
         }
      }
      
      /* check to see if the RFQ is still compact, but only if hole(s) were created 
       * in ip_reasm_compute_overlap () */
      if (hole_created)
 8241fbc:	e0bffd83 	ldbu	r2,-10(fp)
 8241fc0:	10803fcc 	andi	r2,r2,255
 8241fc4:	10001426 	beq	r2,zero,8242018 <ip_reasm_process_subsequent_fragments+0x3c4>
         {
         if ((rc = ip_reasm_mark_compact_rfq (irep)) != IPREASM_OK)
 8241fc8:	e13fff17 	ldw	r4,-4(fp)
 8241fcc:	82427b40 	call	82427b4 <ip_reasm_mark_compact_rfq>
 8241fd0:	e0bff915 	stw	r2,-28(fp)
 8241fd4:	e0bff917 	ldw	r2,-28(fp)
 8241fd8:	10000f26 	beq	r2,zero,8242018 <ip_reasm_process_subsequent_fragments+0x3c4>
            {
            /* an error return is due to a bad IRE pointer, which ip_reasm_mark_compact_rfq () logs */
            LOCK_NET_RESOURCE (FREEQ_RESID);
 8241fdc:	01000084 	movi	r4,2
 8241fe0:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
            pk_free (p);
 8241fe4:	e13ffe17 	ldw	r4,-8(fp)
 8241fe8:	822cd980 	call	822cd98 <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241fec:	01000084 	movi	r4,2
 8241ff0:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
            ++ip_mib.ipReasmFails;
 8241ff4:	008209b4 	movhi	r2,2086
 8241ff8:	10ba8304 	addi	r2,r2,-5620
 8241ffc:	10800f17 	ldw	r2,60(r2)
 8242000:	10c00044 	addi	r3,r2,1
 8242004:	008209b4 	movhi	r2,2086
 8242008:	10ba8304 	addi	r2,r2,-5620
 824200c:	10c00f15 	stw	r3,60(r2)
            return rc;
 8242010:	e0bff917 	ldw	r2,-28(fp)
 8242014:	00005606 	br	8242170 <ip_reasm_process_subsequent_fragments+0x51c>

   /* compute the total number of bytes queued in this IRE.  Note 
    * that the RHS has been updated to reflect the amount of "unique"
    * data in the just received fragment (the IP header has been dropped,
    * and perhaps additional duplicate data too (if present)) */
   irep->rcvd += (u_short) (p->nb_plen);
 8242018:	e0bfff17 	ldw	r2,-4(fp)
 824201c:	1080048b 	ldhu	r2,18(r2)
 8242020:	e0fffe17 	ldw	r3,-8(fp)
 8242024:	18c00417 	ldw	r3,16(r3)
 8242028:	10c5883a 	add	r2,r2,r3
 824202c:	1007883a 	mov	r3,r2
 8242030:	e0bfff17 	ldw	r2,-4(fp)
 8242034:	10c0048d 	sth	r3,18(r2)
   ip_reasm_incr_mem_useage (p->nb_blen + ((new_rfqp == 0) ? 0 : (sizeof(RFQ))));
 8242038:	e0bffe17 	ldw	r2,-8(fp)
 824203c:	10800217 	ldw	r2,8(r2)
 8242040:	1007883a 	mov	r3,r2
 8242044:	e0bff517 	ldw	r2,-44(fp)
 8242048:	1000021e 	bne	r2,zero,8242054 <ip_reasm_process_subsequent_fragments+0x400>
 824204c:	0005883a 	mov	r2,zero
 8242050:	00000106 	br	8242058 <ip_reasm_process_subsequent_fragments+0x404>
 8242054:	00801904 	movi	r2,100
 8242058:	1885883a 	add	r2,r3,r2
 824205c:	10bfffcc 	andi	r2,r2,65535
 8242060:	1009883a 	mov	r4,r2
 8242064:	82412780 	call	8241278 <ip_reasm_incr_mem_useage>

   if (irep->length != 0)
 8242068:	e0bfff17 	ldw	r2,-4(fp)
 824206c:	1080040b 	ldhu	r2,16(r2)
 8242070:	10bfffcc 	andi	r2,r2,65535
 8242074:	10003d26 	beq	r2,zero,824216c <ip_reasm_process_subsequent_fragments+0x518>
      {
      /* we know the total length of the original unfragmented datagram; 
       * let's check to see if we have all of the bytes... */
      if (irep->rcvd == irep->length)
 8242078:	e0bfff17 	ldw	r2,-4(fp)
 824207c:	10c0048b 	ldhu	r3,18(r2)
 8242080:	e0bfff17 	ldw	r2,-4(fp)
 8242084:	1080040b 	ldhu	r2,16(r2)
 8242088:	18ffffcc 	andi	r3,r3,65535
 824208c:	10bfffcc 	andi	r2,r2,65535
 8242090:	1880361e 	bne	r3,r2,824216c <ip_reasm_process_subsequent_fragments+0x518>
          * Ensure that we allocate space for the data link header, IP header, 
          * and the payload of the original, unfragmented datagram.  We pick 
          * the data link layer and IP headers from the First Fragment (FF), 
          * but we need to adjust some of the fields in the IP header after 
          * reassembly is complete. */
         pip = (struct ip *) irep->l3_hdr;
 8242094:	e0bfff17 	ldw	r2,-4(fp)
 8242098:	10802017 	ldw	r2,128(r2)
 824209c:	e0bff615 	stw	r2,-40(fp)
         LOCK_NET_RESOURCE (FREEQ_RESID);
 82420a0:	01000084 	movi	r4,2
 82420a4:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
         reassy_pkt = pk_alloc (irep->length + (irep->l3_hdr - irep->l2_hdr) + ip_hlen (pip));
 82420a8:	e0bfff17 	ldw	r2,-4(fp)
 82420ac:	1080040b 	ldhu	r2,16(r2)
 82420b0:	10ffffcc 	andi	r3,r2,65535
 82420b4:	e0bfff17 	ldw	r2,-4(fp)
 82420b8:	10802017 	ldw	r2,128(r2)
 82420bc:	1009883a 	mov	r4,r2
 82420c0:	e0bfff17 	ldw	r2,-4(fp)
 82420c4:	10801f17 	ldw	r2,124(r2)
 82420c8:	2085c83a 	sub	r2,r4,r2
 82420cc:	1887883a 	add	r3,r3,r2
 82420d0:	e0bff617 	ldw	r2,-40(fp)
 82420d4:	10800003 	ldbu	r2,0(r2)
 82420d8:	10803fcc 	andi	r2,r2,255
 82420dc:	108003cc 	andi	r2,r2,15
 82420e0:	1085883a 	add	r2,r2,r2
 82420e4:	1085883a 	add	r2,r2,r2
 82420e8:	1885883a 	add	r2,r3,r2
 82420ec:	1009883a 	mov	r4,r2
 82420f0:	822ca480 	call	822ca48 <pk_alloc>
 82420f4:	e0bffa15 	stw	r2,-24(fp)
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 82420f8:	01000084 	movi	r4,2
 82420fc:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         if (reassy_pkt == 0)
 8242100:	e0bffa17 	ldw	r2,-24(fp)
 8242104:	10000b1e 	bne	r2,zero,8242134 <ip_reasm_process_subsequent_fragments+0x4e0>
            {
            /* the following call will delete all queued fragments, including
             * the currently received one */
            ip_reasm_delete_ire (irep);
 8242108:	e13fff17 	ldw	r4,-4(fp)
 824210c:	82426000 	call	8242600 <ip_reasm_delete_ire>
            ++ip_mib.ipReasmFails;
 8242110:	008209b4 	movhi	r2,2086
 8242114:	10ba8304 	addi	r2,r2,-5620
 8242118:	10800f17 	ldw	r2,60(r2)
 824211c:	10c00044 	addi	r3,r2,1
 8242120:	008209b4 	movhi	r2,2086
 8242124:	10ba8304 	addi	r2,r2,-5620
 8242128:	10c00f15 	stw	r3,60(r2)
            return ENP_NOBUFFER;
 824212c:	00bffac4 	movi	r2,-21
 8242130:	00000f06 	br	8242170 <ip_reasm_process_subsequent_fragments+0x51c>
            }
         else
            {
            ip_reasm_copy_queued_fragments_into_reassy_buffer (reassy_pkt, irep);
 8242134:	e17fff17 	ldw	r5,-4(fp)
 8242138:	e13ffa17 	ldw	r4,-24(fp)
 824213c:	82421dc0 	call	82421dc <ip_reasm_copy_queued_fragments_into_reassy_buffer>
            /* free the IRE structure (and its constituent elements) */
            ip_reasm_delete_ire (irep);
 8242140:	e13fff17 	ldw	r4,-4(fp)
 8242144:	82426000 	call	8242600 <ip_reasm_delete_ire>
            /* at this point, 'irep' is no longer a valid pointer, and so should 
             * not be referenced.  We're done, and we now pass the packet for 
             * demux'ing to the appropriate entity (e.g., UDP, TCP, etc.).  Note
             * that ip_demux () expects 'nb_prot' to point to the beginning of 
             * the IP header. */
            ++ip_mib.ipReasmOKs;
 8242148:	008209b4 	movhi	r2,2086
 824214c:	10ba8304 	addi	r2,r2,-5620
 8242150:	10800e17 	ldw	r2,56(r2)
 8242154:	10c00044 	addi	r3,r2,1
 8242158:	008209b4 	movhi	r2,2086
 824215c:	10ba8304 	addi	r2,r2,-5620
 8242160:	10c00e15 	stw	r3,56(r2)
            ip_demux (reassy_pkt);
 8242164:	e13ffa17 	ldw	r4,-24(fp)
 8242168:	82435d80 	call	82435d8 <ip_demux>
      {
      /* we haven't received the LF (so we don't know the total amount of data in 
       * the original, unfragmented datagram), and therefore reassembly can't complete yet */
      }

   return IPREASM_OK;
 824216c:	0005883a 	mov	r2,zero
}
 8242170:	e037883a 	mov	sp,fp
 8242174:	dfc00117 	ldw	ra,4(sp)
 8242178:	df000017 	ldw	fp,0(sp)
 824217c:	dec00204 	addi	sp,sp,8
 8242180:	f800283a 	ret

08242184 <ip_reasm_find_ire>:
OUTPUT: This function returns a IPREASM_TRUE if the IRE exists in the master 
IRE list; otherwise, it returns a IPREASM_FALSE.
*/

u_char ip_reasm_find_ire (IREP irep)
{
 8242184:	defffd04 	addi	sp,sp,-12
 8242188:	df000215 	stw	fp,8(sp)
 824218c:	df000204 	addi	fp,sp,8
 8242190:	e13fff15 	stw	r4,-4(fp)
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8242194:	d0a0c817 	ldw	r2,-31968(gp)
 8242198:	e0bffe15 	stw	r2,-8(fp)
 824219c:	00000806 	br	82421c0 <ip_reasm_find_ire+0x3c>
      {
      if (tmpp == irep) 
 82421a0:	e0fffe17 	ldw	r3,-8(fp)
 82421a4:	e0bfff17 	ldw	r2,-4(fp)
 82421a8:	1880021e 	bne	r3,r2,82421b4 <ip_reasm_find_ire+0x30>
         {
         return IPREASM_TRUE;
 82421ac:	00800044 	movi	r2,1
 82421b0:	00000606 	br	82421cc <ip_reasm_find_ire+0x48>
u_char ip_reasm_find_ire (IREP irep)
{
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 82421b4:	e0bffe17 	ldw	r2,-8(fp)
 82421b8:	10800017 	ldw	r2,0(r2)
 82421bc:	e0bffe15 	stw	r2,-8(fp)
 82421c0:	e0bffe17 	ldw	r2,-8(fp)
 82421c4:	103ff61e 	bne	r2,zero,82421a0 <ip_reasm_find_ire+0x1c>
         {
         return IPREASM_TRUE;
         }
      }

   return IPREASM_FALSE;
 82421c8:	0005883a 	mov	r2,zero
}
 82421cc:	e037883a 	mov	sp,fp
 82421d0:	df000017 	ldw	fp,0(sp)
 82421d4:	dec00104 	addi	sp,sp,4
 82421d8:	f800283a 	ret

082421dc <ip_reasm_copy_queued_fragments_into_reassy_buffer>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_copy_queued_fragments_into_reassy_buffer (PACKET reassy_pkt, IREP irep)
{
 82421dc:	defff504 	addi	sp,sp,-44
 82421e0:	dfc00a15 	stw	ra,40(sp)
 82421e4:	df000915 	stw	fp,36(sp)
 82421e8:	df000904 	addi	fp,sp,36
 82421ec:	e13ffe15 	stw	r4,-8(fp)
 82421f0:	e17fff15 	stw	r5,-4(fp)
   RFQP rfqp;
   u_short i;
   PACKET p;
   u_char iphlen;
   char * writep;
   PACKET sav_pkt = 0;
 82421f4:	e03ff915 	stw	zero,-28(fp)

   pip = (struct ip *) irep->l3_hdr;
 82421f8:	e0bfff17 	ldw	r2,-4(fp)
 82421fc:	10802017 	ldw	r2,128(r2)
 8242200:	e0bffa15 	stw	r2,-24(fp)
   iphlen = ip_hlen (pip);
 8242204:	e0bffa17 	ldw	r2,-24(fp)
 8242208:	10800003 	ldbu	r2,0(r2)
 824220c:	108003cc 	andi	r2,r2,15
 8242210:	1085883a 	add	r2,r2,r2
 8242214:	1085883a 	add	r2,r2,r2
 8242218:	e0bffb05 	stb	r2,-20(fp)

   /* copy the data link and IP layer headers into place.  These headers are 
    * from the First Fragment (FF). */
   offset = (u_char) ((irep->l3_hdr - irep->l2_hdr) + iphlen);
 824221c:	e0bfff17 	ldw	r2,-4(fp)
 8242220:	10802017 	ldw	r2,128(r2)
 8242224:	1007883a 	mov	r3,r2
 8242228:	e0bfff17 	ldw	r2,-4(fp)
 824222c:	10801f17 	ldw	r2,124(r2)
 8242230:	1885c83a 	sub	r2,r3,r2
 8242234:	1007883a 	mov	r3,r2
 8242238:	e0bffb03 	ldbu	r2,-20(fp)
 824223c:	1885883a 	add	r2,r3,r2
 8242240:	e0bffb45 	stb	r2,-19(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);
 8242244:	e0bffe17 	ldw	r2,-8(fp)
 8242248:	10c00117 	ldw	r3,4(r2)
 824224c:	e0bfff17 	ldw	r2,-4(fp)
 8242250:	10801f17 	ldw	r2,124(r2)
 8242254:	e13ffb43 	ldbu	r4,-19(fp)
 8242258:	200d883a 	mov	r6,r4
 824225c:	100b883a 	mov	r5,r2
 8242260:	1809883a 	mov	r4,r3
 8242264:	8202f6c0 	call	8202f6c <memcpy>

   rfqp = &(irep->rfq);
 8242268:	e0bfff17 	ldw	r2,-4(fp)
 824226c:	10800604 	addi	r2,r2,24
 8242270:	e0bff715 	stw	r2,-36(fp)
   writep = reassy_pkt->nb_buff + offset;
 8242274:	e0bffe17 	ldw	r2,-8(fp)
 8242278:	10c00117 	ldw	r3,4(r2)
 824227c:	e0bffb43 	ldbu	r2,-19(fp)
 8242280:	1885883a 	add	r2,r3,r2
 8242284:	e0bffc15 	stw	r2,-16(fp)

   while (rfqp)
 8242288:	00004506 	br	82423a0 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1c4>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 824228c:	e03ff80d 	sth	zero,-32(fp)
 8242290:	00003b06 	br	8242380 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1a4>
         {
         if ((p = rfqp->bufp [i]) != 0)
 8242294:	e0bff80b 	ldhu	r2,-32(fp)
 8242298:	e0fff717 	ldw	r3,-36(fp)
 824229c:	10800044 	addi	r2,r2,1
 82422a0:	1085883a 	add	r2,r2,r2
 82422a4:	1085883a 	add	r2,r2,r2
 82422a8:	1885883a 	add	r2,r3,r2
 82422ac:	10800017 	ldw	r2,0(r2)
 82422b0:	e0bffd15 	stw	r2,-12(fp)
 82422b4:	e0bffd17 	ldw	r2,-12(fp)
 82422b8:	10002926 	beq	r2,zero,8242360 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x184>
            {
            /* note that rfqp->frag_offset[i] is the true value of the offset field, 
             * and does not require any scaling (like the Fragment Offset field in 
             * the IP header) */
            MEMCPY((writep + rfqp->frag_offset[i]), p->nb_prot, p->nb_plen);
 82422bc:	e0bff80b 	ldhu	r2,-32(fp)
 82422c0:	e0fff717 	ldw	r3,-36(fp)
 82422c4:	10800884 	addi	r2,r2,34
 82422c8:	1085883a 	add	r2,r2,r2
 82422cc:	1885883a 	add	r2,r3,r2
 82422d0:	1080000b 	ldhu	r2,0(r2)
 82422d4:	10bfffcc 	andi	r2,r2,65535
 82422d8:	e0fffc17 	ldw	r3,-16(fp)
 82422dc:	1887883a 	add	r3,r3,r2
 82422e0:	e0bffd17 	ldw	r2,-12(fp)
 82422e4:	11000317 	ldw	r4,12(r2)
 82422e8:	e0bffd17 	ldw	r2,-12(fp)
 82422ec:	10800417 	ldw	r2,16(r2)
 82422f0:	100d883a 	mov	r6,r2
 82422f4:	200b883a 	mov	r5,r4
 82422f8:	1809883a 	mov	r4,r3
 82422fc:	8202f6c0 	call	8202f6c <memcpy>
            /* free fragment after we've copied data out from it (unless we need to
             * save it so that we can copy some fields from it later (after exiting 
             * from the loop)) */
            if (!sav_pkt) sav_pkt = p;
 8242300:	e0bff917 	ldw	r2,-28(fp)
 8242304:	1000031e 	bne	r2,zero,8242314 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x138>
 8242308:	e0bffd17 	ldw	r2,-12(fp)
 824230c:	e0bff915 	stw	r2,-28(fp)
 8242310:	00000b06 	br	8242340 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x164>
            else
               {
               ip_reasm_decr_mem_useage (p->nb_blen);
 8242314:	e0bffd17 	ldw	r2,-12(fp)
 8242318:	10800217 	ldw	r2,8(r2)
 824231c:	10bfffcc 	andi	r2,r2,65535
 8242320:	1009883a 	mov	r4,r2
 8242324:	82413180 	call	8241318 <ip_reasm_decr_mem_useage>
               LOCK_NET_RESOURCE (FREEQ_RESID);
 8242328:	01000084 	movi	r4,2
 824232c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
               pk_free (p);
 8242330:	e13ffd17 	ldw	r4,-12(fp)
 8242334:	822cd980 	call	822cd98 <pk_free>
               UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8242338:	01000084 	movi	r4,2
 824233c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
               }
            /* since we're done with the packet, mark slot as unused */
            rfqp->bufp [i] = 0;
 8242340:	e0bff80b 	ldhu	r2,-32(fp)
 8242344:	e0fff717 	ldw	r3,-36(fp)
 8242348:	10800044 	addi	r2,r2,1
 824234c:	1085883a 	add	r2,r2,r2
 8242350:	1085883a 	add	r2,r2,r2
 8242354:	1885883a 	add	r2,r3,r2
 8242358:	10000015 	stw	zero,0(r2)
 824235c:	00000506 	br	8242374 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x198>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 8242360:	e0bfff17 	ldw	r2,-4(fp)
 8242364:	10802103 	ldbu	r2,132(r2)
 8242368:	10803fcc 	andi	r2,r2,255
 824236c:	1080004c 	andi	r2,r2,1
 8242370:	1000071e 	bne	r2,zero,8242390 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1b4>
   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8242374:	e0bff80b 	ldhu	r2,-32(fp)
 8242378:	10800044 	addi	r2,r2,1
 824237c:	e0bff80d 	sth	r2,-32(fp)
 8242380:	e0bff80b 	ldhu	r2,-32(fp)
 8242384:	10800430 	cmpltui	r2,r2,16
 8242388:	103fc21e 	bne	r2,zero,8242294 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xb8>
 824238c:	00000106 	br	8242394 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1b8>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
               {
               break;
 8242390:	0001883a 	nop
               }
            }
          }

      rfqp = rfqp->next;
 8242394:	e0bff717 	ldw	r2,-36(fp)
 8242398:	10800017 	ldw	r2,0(r2)
 824239c:	e0bff715 	stw	r2,-36(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);

   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
 82423a0:	e0bff717 	ldw	r2,-36(fp)
 82423a4:	103fb91e 	bne	r2,zero,824228c <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xb0>
      }

   /* update various fields in the reassembled packet.  Some fields will be 
    * picked from one of the constituent fragments (sav_pkt) which hasn't
    * been deleted yet. */
   reassy_pkt->nb_prot = reassy_pkt->nb_buff + (irep->l3_hdr - irep->l2_hdr);
 82423a8:	e0bffe17 	ldw	r2,-8(fp)
 82423ac:	10800117 	ldw	r2,4(r2)
 82423b0:	e0ffff17 	ldw	r3,-4(fp)
 82423b4:	18c02017 	ldw	r3,128(r3)
 82423b8:	1809883a 	mov	r4,r3
 82423bc:	e0ffff17 	ldw	r3,-4(fp)
 82423c0:	18c01f17 	ldw	r3,124(r3)
 82423c4:	20c7c83a 	sub	r3,r4,r3
 82423c8:	10c7883a 	add	r3,r2,r3
 82423cc:	e0bffe17 	ldw	r2,-8(fp)
 82423d0:	10c00315 	stw	r3,12(r2)
   reassy_pkt->nb_plen = irep->length + iphlen;
 82423d4:	e0bfff17 	ldw	r2,-4(fp)
 82423d8:	1080040b 	ldhu	r2,16(r2)
 82423dc:	10ffffcc 	andi	r3,r2,65535
 82423e0:	e0bffb03 	ldbu	r2,-20(fp)
 82423e4:	1885883a 	add	r2,r3,r2
 82423e8:	1007883a 	mov	r3,r2
 82423ec:	e0bffe17 	ldw	r2,-8(fp)
 82423f0:	10c00415 	stw	r3,16(r2)
   reassy_pkt->nb_tstamp = cticks;
 82423f4:	d0a0a817 	ldw	r2,-32096(gp)
 82423f8:	1007883a 	mov	r3,r2
 82423fc:	e0bffe17 	ldw	r2,-8(fp)
 8242400:	10c00515 	stw	r3,20(r2)
   reassy_pkt->flags |= ((sav_pkt->flags) & (PKF_BCAST | PKF_MCAST));
 8242404:	e0bffe17 	ldw	r2,-8(fp)
 8242408:	10c00a17 	ldw	r3,40(r2)
 824240c:	e0bff917 	ldw	r2,-28(fp)
 8242410:	10800a17 	ldw	r2,40(r2)
 8242414:	108000cc 	andi	r2,r2,3
 8242418:	1886b03a 	or	r3,r3,r2
 824241c:	e0bffe17 	ldw	r2,-8(fp)
 8242420:	10c00a15 	stw	r3,40(r2)
   reassy_pkt->net = sav_pkt->net;
 8242424:	e0bff917 	ldw	r2,-28(fp)
 8242428:	10c00617 	ldw	r3,24(r2)
 824242c:	e0bffe17 	ldw	r2,-8(fp)
 8242430:	10c00615 	stw	r3,24(r2)
   reassy_pkt->type = sav_pkt->type;
 8242434:	e0bff917 	ldw	r2,-28(fp)
 8242438:	10c0080b 	ldhu	r3,32(r2)
 824243c:	e0bffe17 	ldw	r2,-8(fp)
 8242440:	10c0080d 	sth	r3,32(r2)
   /* fhost is set by ip_demux () before handing off to the packet to its 
    * intended destination (protocol) */

   /* free the saved packet too, since we don't need it anymore */
   ip_reasm_decr_mem_useage (sav_pkt->nb_blen);
 8242444:	e0bff917 	ldw	r2,-28(fp)
 8242448:	10800217 	ldw	r2,8(r2)
 824244c:	10bfffcc 	andi	r2,r2,65535
 8242450:	1009883a 	mov	r4,r2
 8242454:	82413180 	call	8241318 <ip_reasm_decr_mem_useage>
   LOCK_NET_RESOURCE (FREEQ_RESID);
 8242458:	01000084 	movi	r4,2
 824245c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   pk_free (sav_pkt);
 8242460:	e13ff917 	ldw	r4,-28(fp)
 8242464:	822cd980 	call	822cd98 <pk_free>
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8242468:	01000084 	movi	r4,2
 824246c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>

   /* after the reassembly is complete, we update the following fields in
    * the IP header: Total Length, Flags/Fragment Offset, header checksum */
   pip = ip_head(reassy_pkt);
 8242470:	e0bffe17 	ldw	r2,-8(fp)
 8242474:	10800317 	ldw	r2,12(r2)
 8242478:	e0bffa15 	stw	r2,-24(fp)
   pip->ip_len = htons(reassy_pkt->nb_plen);
 824247c:	e0bffe17 	ldw	r2,-8(fp)
 8242480:	10800417 	ldw	r2,16(r2)
 8242484:	1004d23a 	srli	r2,r2,8
 8242488:	10803fcc 	andi	r2,r2,255
 824248c:	1007883a 	mov	r3,r2
 8242490:	e0bffe17 	ldw	r2,-8(fp)
 8242494:	10800417 	ldw	r2,16(r2)
 8242498:	1004923a 	slli	r2,r2,8
 824249c:	1884b03a 	or	r2,r3,r2
 82424a0:	1007883a 	mov	r3,r2
 82424a4:	e0bffa17 	ldw	r2,-24(fp)
 82424a8:	10c0008d 	sth	r3,2(r2)
   /* turn off More Fragments (MF) bit; the DF bit stays unchanged */
   pip->ip_flgs_foff &= htons(~((u_short) IP_FLG_MF));
 82424ac:	e0bffa17 	ldw	r2,-24(fp)
 82424b0:	10c0018b 	ldhu	r3,6(r2)
 82424b4:	00bff7c4 	movi	r2,-33
 82424b8:	1884703a 	and	r2,r3,r2
 82424bc:	1007883a 	mov	r3,r2
 82424c0:	e0bffa17 	ldw	r2,-24(fp)
 82424c4:	10c0018d 	sth	r3,6(r2)
   /* clear the Fragment Offset bits */
   pip->ip_flgs_foff &= htons(~((u_short) IP_EXTRACT_FOFF)); 
 82424c8:	e0bffa17 	ldw	r2,-24(fp)
 82424cc:	1080018b 	ldhu	r2,6(r2)
 82424d0:	1080380c 	andi	r2,r2,224
 82424d4:	1007883a 	mov	r3,r2
 82424d8:	e0bffa17 	ldw	r2,-24(fp)
 82424dc:	10c0018d 	sth	r3,6(r2)
   /* the following isn't really required, and can be removed */
   pip->ip_chksum = IPXSUM;
 82424e0:	e0bffa17 	ldw	r2,-24(fp)
 82424e4:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum (pip, (iphlen/2));
 82424e8:	e0bffb03 	ldbu	r2,-20(fp)
 82424ec:	1004d07a 	srli	r2,r2,1
 82424f0:	10803fcc 	andi	r2,r2,255
 82424f4:	100b883a 	mov	r5,r2
 82424f8:	e13ffa17 	ldw	r4,-24(fp)
 82424fc:	82288100 	call	8228810 <cksum>
 8242500:	0084303a 	nor	r2,zero,r2
 8242504:	1007883a 	mov	r3,r2
 8242508:	e0bffa17 	ldw	r2,-24(fp)
 824250c:	10c0028d 	sth	r3,10(r2)

   return IPREASM_OK;
 8242510:	0005883a 	mov	r2,zero
}
 8242514:	e037883a 	mov	sp,fp
 8242518:	dfc00117 	ldw	ra,4(sp)
 824251c:	df000017 	ldw	fp,0(sp)
 8242520:	dec00204 	addi	sp,sp,8
 8242524:	f800283a 	ret

08242528 <ip_reasm_process_timer_tick>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_process_timer_tick (void)
{
 8242528:	defffc04 	addi	sp,sp,-16
 824252c:	dfc00315 	stw	ra,12(sp)
 8242530:	df000215 	stw	fp,8(sp)
 8242534:	df000204 	addi	fp,sp,8
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 8242538:	0009883a 	mov	r4,zero
 824253c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 8242540:	d0a0c817 	ldw	r2,-31968(gp)
 8242544:	e0bffe15 	stw	r2,-8(fp)
 8242548:	00002006 	br	82425cc <ip_reasm_process_timer_tick+0xa4>
      {
      /* save the next pointer for the IRE that may be deleted */
      nxt_tmpp = tmpp->next;
 824254c:	e0bffe17 	ldw	r2,-8(fp)
 8242550:	10800017 	ldw	r2,0(r2)
 8242554:	e0bfff15 	stw	r2,-4(fp)
      ++tmpp->age;
 8242558:	e0bffe17 	ldw	r2,-8(fp)
 824255c:	10800517 	ldw	r2,20(r2)
 8242560:	10c00044 	addi	r3,r2,1
 8242564:	e0bffe17 	ldw	r2,-8(fp)
 8242568:	10c00515 	stw	r3,20(r2)
      /* check to see if this entry has reached its max age (expired)? */
      if (tmpp->age == IRE_TMO)
 824256c:	e0bffe17 	ldw	r2,-8(fp)
 8242570:	10800517 	ldw	r2,20(r2)
 8242574:	10801e18 	cmpnei	r2,r2,120
 8242578:	1000121e 	bne	r2,zero,82425c4 <ip_reasm_process_timer_tick+0x9c>
         {
         /* it has...and therefore must be deleted. */
         ++ire_stats.ire_timed_out;
 824257c:	008209b4 	movhi	r2,2086
 8242580:	10ba9704 	addi	r2,r2,-5540
 8242584:	10800117 	ldw	r2,4(r2)
 8242588:	10c00044 	addi	r3,r2,1
 824258c:	008209b4 	movhi	r2,2086
 8242590:	10ba9704 	addi	r2,r2,-5540
 8242594:	10c00115 	stw	r3,4(r2)
#ifdef FULL_ICMP
         /* send ICMP Time Exceeded message with code 1 ("fragment reassembly time exceeded") */
         ip_reasm_send_icmp_timex (tmpp);
 8242598:	e13ffe17 	ldw	r4,-8(fp)
 824259c:	8242c3c0 	call	8242c3c <ip_reasm_send_icmp_timex>
#endif
         ip_reasm_delete_ire (tmpp);
 82425a0:	e13ffe17 	ldw	r4,-8(fp)
 82425a4:	82426000 	call	8242600 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 82425a8:	008209b4 	movhi	r2,2086
 82425ac:	10ba8304 	addi	r2,r2,-5620
 82425b0:	10800f17 	ldw	r2,60(r2)
 82425b4:	10c00044 	addi	r3,r2,1
 82425b8:	008209b4 	movhi	r2,2086
 82425bc:	10ba8304 	addi	r2,r2,-5620
 82425c0:	10c00f15 	stw	r3,60(r2)
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 82425c4:	e0bfff17 	ldw	r2,-4(fp)
 82425c8:	e0bffe15 	stw	r2,-8(fp)
 82425cc:	e0bffe17 	ldw	r2,-8(fp)
 82425d0:	103fde1e 	bne	r2,zero,824254c <ip_reasm_process_timer_tick+0x24>
         ++ip_mib.ipReasmFails;
         }
      }

   /* set the time for the next invocation of this routine (one second later) */
   ire_cticks = cticks + TPS;
 82425d4:	d0a0a817 	ldw	r2,-32096(gp)
 82425d8:	10801904 	addi	r2,r2,100
 82425dc:	d0a0c915 	stw	r2,-31964(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 82425e0:	0009883a 	mov	r4,zero
 82425e4:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>

   return IPREASM_OK;
 82425e8:	0005883a 	mov	r2,zero
}
 82425ec:	e037883a 	mov	sp,fp
 82425f0:	dfc00117 	ldw	ra,4(sp)
 82425f4:	df000017 	ldw	fp,0(sp)
 82425f8:	dec00204 	addi	sp,sp,8
 82425fc:	f800283a 	ret

08242600 <ip_reasm_delete_ire>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in the 
master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_delete_ire (IREP irep)
{
 8242600:	defff604 	addi	sp,sp,-40
 8242604:	dfc00915 	stw	ra,36(sp)
 8242608:	df000815 	stw	fp,32(sp)
 824260c:	df000804 	addi	fp,sp,32
 8242610:	e13fff15 	stw	r4,-4(fp)
   RFQP rfqp, first_rfqp, prev_rfqp;
   u_short i;
   PACKET p;
   IREP tmpp;
   IREP prev_tmpp = 0;
 8242614:	e03ffb15 	stw	zero,-20(fp)

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8242618:	d0a0c817 	ldw	r2,-31968(gp)
 824261c:	e0bffa15 	stw	r2,-24(fp)
 8242620:	00001406 	br	8242674 <ip_reasm_delete_ire+0x74>
      {
      if (tmpp == irep) 
 8242624:	e0fffa17 	ldw	r3,-24(fp)
 8242628:	e0bfff17 	ldw	r2,-4(fp)
 824262c:	18800c1e 	bne	r3,r2,8242660 <ip_reasm_delete_ire+0x60>
         {
         /* update the head pointer to the list */
         if (tmpp == h_ireq) h_ireq = irep->next;
 8242630:	d0a0c817 	ldw	r2,-31968(gp)
 8242634:	e0fffa17 	ldw	r3,-24(fp)
 8242638:	1880041e 	bne	r3,r2,824264c <ip_reasm_delete_ire+0x4c>
 824263c:	e0bfff17 	ldw	r2,-4(fp)
 8242640:	10800017 	ldw	r2,0(r2)
 8242644:	d0a0c815 	stw	r2,-31968(gp)
         else prev_tmpp->next = irep->next;
         break;
 8242648:	00000c06 	br	824267c <ip_reasm_delete_ire+0x7c>
      {
      if (tmpp == irep) 
         {
         /* update the head pointer to the list */
         if (tmpp == h_ireq) h_ireq = irep->next;
         else prev_tmpp->next = irep->next;
 824264c:	e0bfff17 	ldw	r2,-4(fp)
 8242650:	10c00017 	ldw	r3,0(r2)
 8242654:	e0bffb17 	ldw	r2,-20(fp)
 8242658:	10c00015 	stw	r3,0(r2)
         break;
 824265c:	00000706 	br	824267c <ip_reasm_delete_ire+0x7c>
         }
      prev_tmpp = tmpp;
 8242660:	e0bffa17 	ldw	r2,-24(fp)
 8242664:	e0bffb15 	stw	r2,-20(fp)
   IREP tmpp;
   IREP prev_tmpp = 0;

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8242668:	e0bffa17 	ldw	r2,-24(fp)
 824266c:	10800017 	ldw	r2,0(r2)
 8242670:	e0bffa15 	stw	r2,-24(fp)
 8242674:	e0bffa17 	ldw	r2,-24(fp)
 8242678:	103fea1e 	bne	r2,zero,8242624 <ip_reasm_delete_ire+0x24>
      prev_tmpp = tmpp;
      }

   /* if the IRE entry does not exist in the master table, return an error 
    * to the caller */
   if (!tmpp)
 824267c:	e0bffa17 	ldw	r2,-24(fp)
 8242680:	1000091e 	bne	r2,zero,82426a8 <ip_reasm_delete_ire+0xa8>
      {
      ++ire_stats.bad_irep;
 8242684:	008209b4 	movhi	r2,2086
 8242688:	10ba9704 	addi	r2,r2,-5540
 824268c:	10800017 	ldw	r2,0(r2)
 8242690:	10c00044 	addi	r3,r2,1
 8242694:	008209b4 	movhi	r2,2086
 8242698:	10ba9704 	addi	r2,r2,-5540
 824269c:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 82426a0:	00bffd84 	movi	r2,-10
 82426a4:	00003e06 	br	82427a0 <ip_reasm_delete_ire+0x1a0>
      }

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);
 82426a8:	e0bfff17 	ldw	r2,-4(fp)
 82426ac:	10800604 	addi	r2,r2,24
 82426b0:	e0bffc15 	stw	r2,-16(fp)
 82426b4:	e0bffc17 	ldw	r2,-16(fp)
 82426b8:	e0bff815 	stw	r2,-32(fp)

   while (rfqp)
 82426bc:	00003106 	br	8242784 <ip_reasm_delete_ire+0x184>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 82426c0:	e03ff90d 	sth	zero,-28(fp)
 82426c4:	00001e06 	br	8242740 <ip_reasm_delete_ire+0x140>
         {
         if ((p = rfqp->bufp [i]) != 0)
 82426c8:	e0bff90b 	ldhu	r2,-28(fp)
 82426cc:	e0fff817 	ldw	r3,-32(fp)
 82426d0:	10800044 	addi	r2,r2,1
 82426d4:	1085883a 	add	r2,r2,r2
 82426d8:	1085883a 	add	r2,r2,r2
 82426dc:	1885883a 	add	r2,r3,r2
 82426e0:	10800017 	ldw	r2,0(r2)
 82426e4:	e0bffd15 	stw	r2,-12(fp)
 82426e8:	e0bffd17 	ldw	r2,-12(fp)
 82426ec:	10000c26 	beq	r2,zero,8242720 <ip_reasm_delete_ire+0x120>
            {
            ip_reasm_decr_mem_useage (p->nb_blen);
 82426f0:	e0bffd17 	ldw	r2,-12(fp)
 82426f4:	10800217 	ldw	r2,8(r2)
 82426f8:	10bfffcc 	andi	r2,r2,65535
 82426fc:	1009883a 	mov	r4,r2
 8242700:	82413180 	call	8241318 <ip_reasm_decr_mem_useage>
            LOCK_NET_RESOURCE (FREEQ_RESID);
 8242704:	01000084 	movi	r4,2
 8242708:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
            pk_free (p);
 824270c:	e13ffd17 	ldw	r4,-12(fp)
 8242710:	822cd980 	call	822cd98 <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);               
 8242714:	01000084 	movi	r4,2
 8242718:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
 824271c:	00000506 	br	8242734 <ip_reasm_delete_ire+0x134>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 8242720:	e0bfff17 	ldw	r2,-4(fp)
 8242724:	10802103 	ldbu	r2,132(r2)
 8242728:	10803fcc 	andi	r2,r2,255
 824272c:	1080004c 	andi	r2,r2,1
 8242730:	1000071e 	bne	r2,zero,8242750 <ip_reasm_delete_ire+0x150>
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8242734:	e0bff90b 	ldhu	r2,-28(fp)
 8242738:	10800044 	addi	r2,r2,1
 824273c:	e0bff90d 	sth	r2,-28(fp)
 8242740:	e0bff90b 	ldhu	r2,-28(fp)
 8242744:	10800430 	cmpltui	r2,r2,16
 8242748:	103fdf1e 	bne	r2,zero,82426c8 <ip_reasm_delete_ire+0xc8>
 824274c:	00000106 	br	8242754 <ip_reasm_delete_ire+0x154>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
               {
               break;
 8242750:	0001883a 	nop
               }
            }
          }

       prev_rfqp = rfqp;
 8242754:	e0bff817 	ldw	r2,-32(fp)
 8242758:	e0bffe15 	stw	r2,-8(fp)
       rfqp = rfqp->next;
 824275c:	e0bff817 	ldw	r2,-32(fp)
 8242760:	10800017 	ldw	r2,0(r2)
 8242764:	e0bff815 	stw	r2,-32(fp)
       /* the first RFQ is statically allocated, and cannot be freed */
       if (prev_rfqp != first_rfqp)
 8242768:	e0fffe17 	ldw	r3,-8(fp)
 824276c:	e0bffc17 	ldw	r2,-16(fp)
 8242770:	18800426 	beq	r3,r2,8242784 <ip_reasm_delete_ire+0x184>
          {
          ip_reasm_decr_mem_useage (sizeof(RFQ));
 8242774:	01001904 	movi	r4,100
 8242778:	82413180 	call	8241318 <ip_reasm_decr_mem_useage>
          IPR_FREE (prev_rfqp);
 824277c:	e13ffe17 	ldw	r4,-8(fp)
 8242780:	822e1fc0 	call	822e1fc <npfree>

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
 8242784:	e0bff817 	ldw	r2,-32(fp)
 8242788:	103fcd1e 	bne	r2,zero,82426c0 <ip_reasm_delete_ire+0xc0>
          IPR_FREE (prev_rfqp);
          }
      }

   /* now free the parent entity */
   ip_reasm_decr_mem_useage (sizeof(IRE));
 824278c:	01002204 	movi	r4,136
 8242790:	82413180 	call	8241318 <ip_reasm_decr_mem_useage>
   IPR_FREE (irep);
 8242794:	e13fff17 	ldw	r4,-4(fp)
 8242798:	822e1fc0 	call	822e1fc <npfree>

   return IPREASM_OK;
 824279c:	0005883a 	mov	r2,zero
}
 82427a0:	e037883a 	mov	sp,fp
 82427a4:	dfc00117 	ldw	ra,4(sp)
 82427a8:	df000017 	ldw	fp,0(sp)
 82427ac:	dec00204 	addi	sp,sp,8
 82427b0:	f800283a 	ret

082427b4 <ip_reasm_mark_compact_rfq>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in 
the master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_mark_compact_rfq (IREP irep)
{
 82427b4:	defffb04 	addi	sp,sp,-20
 82427b8:	dfc00415 	stw	ra,16(sp)
 82427bc:	df000315 	stw	fp,12(sp)
 82427c0:	df000304 	addi	fp,sp,12
 82427c4:	e13fff15 	stw	r4,-4(fp)
   RFQP rfqp;
   u_short i;
   u_char empty_slot_discovered = IPREASM_FALSE;
 82427c8:	e03ffe85 	stb	zero,-6(fp)
   u_char compact = IPREASM_TRUE;
 82427cc:	00800044 	movi	r2,1
 82427d0:	e0bffec5 	stb	r2,-5(fp)

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 82427d4:	e13fff17 	ldw	r4,-4(fp)
 82427d8:	82421840 	call	8242184 <ip_reasm_find_ire>
 82427dc:	10803fcc 	andi	r2,r2,255
 82427e0:	10800060 	cmpeqi	r2,r2,1
 82427e4:	1000091e 	bne	r2,zero,824280c <ip_reasm_mark_compact_rfq+0x58>
   {
      ++ire_stats.bad_irep;
 82427e8:	008209b4 	movhi	r2,2086
 82427ec:	10ba9704 	addi	r2,r2,-5540
 82427f0:	10800017 	ldw	r2,0(r2)
 82427f4:	10c00044 	addi	r3,r2,1
 82427f8:	008209b4 	movhi	r2,2086
 82427fc:	10ba9704 	addi	r2,r2,-5540
 8242800:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 8242804:	00bffd84 	movi	r2,-10
 8242808:	00003106 	br	82428d0 <ip_reasm_mark_compact_rfq+0x11c>
   }

   rfqp = &(irep->rfq);
 824280c:	e0bfff17 	ldw	r2,-4(fp)
 8242810:	10800604 	addi	r2,r2,24
 8242814:	e0bffd15 	stw	r2,-12(fp)

   while (rfqp)
 8242818:	00001a06 	br	8242884 <ip_reasm_mark_compact_rfq+0xd0>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 824281c:	e03ffe0d 	sth	zero,-8(fp)
 8242820:	00001206 	br	824286c <ip_reasm_mark_compact_rfq+0xb8>
         {
         if (rfqp->bufp [i] == 0)
 8242824:	e0bffe0b 	ldhu	r2,-8(fp)
 8242828:	e0fffd17 	ldw	r3,-12(fp)
 824282c:	10800044 	addi	r2,r2,1
 8242830:	1085883a 	add	r2,r2,r2
 8242834:	1085883a 	add	r2,r2,r2
 8242838:	1885883a 	add	r2,r3,r2
 824283c:	10800017 	ldw	r2,0(r2)
 8242840:	1000031e 	bne	r2,zero,8242850 <ip_reasm_mark_compact_rfq+0x9c>
            {            
            empty_slot_discovered = IPREASM_TRUE;
 8242844:	00800044 	movi	r2,1
 8242848:	e0bffe85 	stb	r2,-6(fp)
 824284c:	00000406 	br	8242860 <ip_reasm_mark_compact_rfq+0xac>
            }
         else
            {
            if (empty_slot_discovered) 
 8242850:	e0bffe83 	ldbu	r2,-6(fp)
 8242854:	10000226 	beq	r2,zero,8242860 <ip_reasm_mark_compact_rfq+0xac>
               {
               compact = IPREASM_FALSE;
 8242858:	e03ffec5 	stb	zero,-5(fp)
               break;
 824285c:	00000606 	br	8242878 <ip_reasm_mark_compact_rfq+0xc4>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8242860:	e0bffe0b 	ldhu	r2,-8(fp)
 8242864:	10800044 	addi	r2,r2,1
 8242868:	e0bffe0d 	sth	r2,-8(fp)
 824286c:	e0bffe0b 	ldhu	r2,-8(fp)
 8242870:	10800430 	cmpltui	r2,r2,16
 8242874:	103feb1e 	bne	r2,zero,8242824 <ip_reasm_mark_compact_rfq+0x70>
               compact = IPREASM_FALSE;
               break;
               }
            }
          }
       rfqp = rfqp->next;
 8242878:	e0bffd17 	ldw	r2,-12(fp)
 824287c:	10800017 	ldw	r2,0(r2)
 8242880:	e0bffd15 	stw	r2,-12(fp)
      return ENP_PARAM;
   }

   rfqp = &(irep->rfq);

   while (rfqp)
 8242884:	e0bffd17 	ldw	r2,-12(fp)
 8242888:	103fe41e 	bne	r2,zero,824281c <ip_reasm_mark_compact_rfq+0x68>
            }
          }
       rfqp = rfqp->next;
      }

   if (compact) 
 824288c:	e0bffec3 	ldbu	r2,-5(fp)
 8242890:	10000726 	beq	r2,zero,82428b0 <ip_reasm_mark_compact_rfq+0xfc>
      {
      irep->flags |= IPR_RFQ_COMPACT;
 8242894:	e0bfff17 	ldw	r2,-4(fp)
 8242898:	10802103 	ldbu	r2,132(r2)
 824289c:	10800054 	ori	r2,r2,1
 82428a0:	1007883a 	mov	r3,r2
 82428a4:	e0bfff17 	ldw	r2,-4(fp)
 82428a8:	10c02105 	stb	r3,132(r2)
 82428ac:	00000706 	br	82428cc <ip_reasm_mark_compact_rfq+0x118>
      }
   else 
      {
      irep->flags &= ~IPR_RFQ_COMPACT;
 82428b0:	e0bfff17 	ldw	r2,-4(fp)
 82428b4:	10c02103 	ldbu	r3,132(r2)
 82428b8:	00bfff84 	movi	r2,-2
 82428bc:	1884703a 	and	r2,r3,r2
 82428c0:	1007883a 	mov	r3,r2
 82428c4:	e0bfff17 	ldw	r2,-4(fp)
 82428c8:	10c02105 	stb	r3,132(r2)
      }

   return IPREASM_OK;
 82428cc:	0005883a 	mov	r2,zero
}
 82428d0:	e037883a 	mov	sp,fp
 82428d4:	dfc00117 	ldw	ra,4(sp)
 82428d8:	df000017 	ldw	fp,0(sp)
 82428dc:	dec00204 	addi	sp,sp,8
 82428e0:	f800283a 	ret

082428e4 <ipr_stats>:

OUTPUT: This function always returns IPREASM_OK.
*/

int ipr_stats(void * pio)
{
 82428e4:	deffeb04 	addi	sp,sp,-84
 82428e8:	dfc01415 	stw	ra,80(sp)
 82428ec:	df001315 	stw	fp,76(sp)
 82428f0:	dc401215 	stw	r17,72(sp)
 82428f4:	dc001115 	stw	r16,68(sp)
 82428f8:	df001304 	addi	fp,sp,76
 82428fc:	e13ffd15 	stw	r4,-12(fp)
   unsigned long ticks_elapsed = cticks;
 8242900:	d0a0a817 	ldw	r2,-32096(gp)
 8242904:	e0bffb15 	stw	r2,-20(fp)
   u_short size_ire = sizeof(IRE);
 8242908:	00802204 	movi	r2,136
 824290c:	e0bffc0d 	sth	r2,-16(fp)
   u_short size_rfq = sizeof(RFQ);
 8242910:	00801904 	movi	r2,100
 8242914:	e0bffc8d 	sth	r2,-14(fp)
   IREP tmpp;
   u_short count = 0;
 8242918:	e03ff80d 	sth	zero,-32(fp)
   RFQP rfqp;
   u_short frag_count = 0;
 824291c:	e03ffa0d 	sth	zero,-24(fp)
   u_short i;

   ns_printf(pio,"IP reassembly statistics:\n");
 8242920:	01420974 	movhi	r5,2085
 8242924:	2944f604 	addi	r5,r5,5080
 8242928:	e13ffd17 	ldw	r4,-12(fp)
 824292c:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
 8242930:	d160c717 	ldw	r5,-31972(gp)
 8242934:	e0fffb17 	ldw	r3,-20(fp)
 8242938:	00947b34 	movhi	r2,20972
 824293c:	10a147c4 	addi	r2,r2,-31457
 8242940:	1888383a 	mulxuu	r4,r3,r2
 8242944:	1885383a 	mul	r2,r3,r2
 8242948:	1021883a 	mov	r16,r2
 824294c:	2023883a 	mov	r17,r4
 8242950:	8804d17a 	srli	r2,r17,5
 8242954:	e0fffc0b 	ldhu	r3,-16(fp)
 8242958:	e13ffc8b 	ldhu	r4,-14(fp)
 824295c:	d9000215 	stw	r4,8(sp)
 8242960:	d8c00115 	stw	r3,4(sp)
 8242964:	d8800015 	stw	r2,0(sp)
 8242968:	e1fffb17 	ldw	r7,-20(fp)
 824296c:	280d883a 	mov	r6,r5
 8242970:	01420974 	movhi	r5,2085
 8242974:	2944fd04 	addi	r5,r5,5108
 8242978:	e13ffd17 	ldw	r4,-12(fp)
 824297c:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
 8242980:	008209b4 	movhi	r2,2086
 8242984:	10ba9704 	addi	r2,r2,-5540
 8242988:	11800117 	ldw	r6,4(r2)
 824298c:	008209b4 	movhi	r2,2086
 8242990:	10ba9704 	addi	r2,r2,-5540
 8242994:	11c00017 	ldw	r7,0(r2)
 8242998:	008209b4 	movhi	r2,2086
 824299c:	10ba9704 	addi	r2,r2,-5540
 82429a0:	10c00217 	ldw	r3,8(r2)
 82429a4:	008209b4 	movhi	r2,2086
 82429a8:	10ba9704 	addi	r2,r2,-5540
 82429ac:	11000317 	ldw	r4,12(r2)
 82429b0:	008209b4 	movhi	r2,2086
 82429b4:	10ba9704 	addi	r2,r2,-5540
 82429b8:	11400417 	ldw	r5,16(r2)
 82429bc:	008209b4 	movhi	r2,2086
 82429c0:	10ba9704 	addi	r2,r2,-5540
 82429c4:	10800517 	ldw	r2,20(r2)
 82429c8:	d8800315 	stw	r2,12(sp)
 82429cc:	d9400215 	stw	r5,8(sp)
 82429d0:	d9000115 	stw	r4,4(sp)
 82429d4:	d8c00015 	stw	r3,0(sp)
 82429d8:	01420974 	movhi	r5,2085
 82429dc:	29450d04 	addi	r5,r5,5172
 82429e0:	e13ffd17 	ldw	r4,-12(fp)
 82429e4:	8228ebc0 	call	8228ebc <ns_printf>
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
 82429e8:	d0a0c817 	ldw	r2,-31968(gp)
 82429ec:	100d883a 	mov	r6,r2
 82429f0:	01420974 	movhi	r5,2085
 82429f4:	29452204 	addi	r5,r5,5256
 82429f8:	e13ffd17 	ldw	r4,-12(fp)
 82429fc:	8228ebc0 	call	8228ebc <ns_printf>
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8242a00:	d0a0c817 	ldw	r2,-31968(gp)
 8242a04:	e0bff715 	stw	r2,-36(fp)
 8242a08:	00007c06 	br	8242bfc <ipr_stats+0x318>
      {
      ++count;
 8242a0c:	e0bff80b 	ldhu	r2,-32(fp)
 8242a10:	10800044 	addi	r2,r2,1
 8242a14:	e0bff80d 	sth	r2,-32(fp)
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
 8242a18:	e0bff717 	ldw	r2,-36(fp)
 8242a1c:	10800604 	addi	r2,r2,24
 8242a20:	e0bff915 	stw	r2,-28(fp)
      while (rfqp)
 8242a24:	00001e06 	br	8242aa0 <ipr_stats+0x1bc>
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8242a28:	e03ffa8d 	sth	zero,-22(fp)
 8242a2c:	00001406 	br	8242a80 <ipr_stats+0x19c>
            {
            if (rfqp->bufp [i] != 0)
 8242a30:	e0bffa8b 	ldhu	r2,-22(fp)
 8242a34:	e0fff917 	ldw	r3,-28(fp)
 8242a38:	10800044 	addi	r2,r2,1
 8242a3c:	1085883a 	add	r2,r2,r2
 8242a40:	1085883a 	add	r2,r2,r2
 8242a44:	1885883a 	add	r2,r3,r2
 8242a48:	10800017 	ldw	r2,0(r2)
 8242a4c:	10000426 	beq	r2,zero,8242a60 <ipr_stats+0x17c>
               {
               ++frag_count;            
 8242a50:	e0bffa0b 	ldhu	r2,-24(fp)
 8242a54:	10800044 	addi	r2,r2,1
 8242a58:	e0bffa0d 	sth	r2,-24(fp)
 8242a5c:	00000506 	br	8242a74 <ipr_stats+0x190>
               }
            else
               {
               if (tmpp->flags & IPR_RFQ_COMPACT)
 8242a60:	e0bff717 	ldw	r2,-36(fp)
 8242a64:	10802103 	ldbu	r2,132(r2)
 8242a68:	10803fcc 	andi	r2,r2,255
 8242a6c:	1080004c 	andi	r2,r2,1
 8242a70:	1000071e 	bne	r2,zero,8242a90 <ipr_stats+0x1ac>
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8242a74:	e0bffa8b 	ldhu	r2,-22(fp)
 8242a78:	10800044 	addi	r2,r2,1
 8242a7c:	e0bffa8d 	sth	r2,-22(fp)
 8242a80:	e0bffa8b 	ldhu	r2,-22(fp)
 8242a84:	10800430 	cmpltui	r2,r2,16
 8242a88:	103fe91e 	bne	r2,zero,8242a30 <ipr_stats+0x14c>
 8242a8c:	00000106 	br	8242a94 <ipr_stats+0x1b0>
               }
            else
               {
               if (tmpp->flags & IPR_RFQ_COMPACT)
                  {
                  break;
 8242a90:	0001883a 	nop
                  }
               }
            }
         rfqp = rfqp->next;
 8242a94:	e0bff917 	ldw	r2,-28(fp)
 8242a98:	10800017 	ldw	r2,0(r2)
 8242a9c:	e0bff915 	stw	r2,-28(fp)
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
      {
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
 8242aa0:	e0bff917 	ldw	r2,-28(fp)
 8242aa4:	103fe01e 	bne	r2,zero,8242a28 <ipr_stats+0x144>
                  }
               }
            }
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
 8242aa8:	e33ffa0b 	ldhu	r12,-24(fp)
 8242aac:	e0bff717 	ldw	r2,-36(fp)
 8242ab0:	10800117 	ldw	r2,4(r2)
 8242ab4:	1006d63a 	srli	r3,r2,24
 8242ab8:	e0bff717 	ldw	r2,-36(fp)
 8242abc:	10800117 	ldw	r2,4(r2)
 8242ac0:	1004d23a 	srli	r2,r2,8
 8242ac4:	10bfc00c 	andi	r2,r2,65280
 8242ac8:	1886b03a 	or	r3,r3,r2
 8242acc:	e0bff717 	ldw	r2,-36(fp)
 8242ad0:	10800117 	ldw	r2,4(r2)
 8242ad4:	10bfc00c 	andi	r2,r2,65280
 8242ad8:	1004923a 	slli	r2,r2,8
 8242adc:	1886b03a 	or	r3,r3,r2
 8242ae0:	e0bff717 	ldw	r2,-36(fp)
 8242ae4:	10800117 	ldw	r2,4(r2)
 8242ae8:	1004963a 	slli	r2,r2,24
 8242aec:	1884b03a 	or	r2,r3,r2
 8242af0:	e0fff717 	ldw	r3,-36(fp)
 8242af4:	18c00217 	ldw	r3,8(r3)
 8242af8:	1808d63a 	srli	r4,r3,24
 8242afc:	e0fff717 	ldw	r3,-36(fp)
 8242b00:	18c00217 	ldw	r3,8(r3)
 8242b04:	1806d23a 	srli	r3,r3,8
 8242b08:	18ffc00c 	andi	r3,r3,65280
 8242b0c:	20c8b03a 	or	r4,r4,r3
 8242b10:	e0fff717 	ldw	r3,-36(fp)
 8242b14:	18c00217 	ldw	r3,8(r3)
 8242b18:	18ffc00c 	andi	r3,r3,65280
 8242b1c:	1806923a 	slli	r3,r3,8
 8242b20:	20c8b03a 	or	r4,r4,r3
 8242b24:	e0fff717 	ldw	r3,-36(fp)
 8242b28:	18c00217 	ldw	r3,8(r3)
 8242b2c:	1806963a 	slli	r3,r3,24
 8242b30:	20c6b03a 	or	r3,r4,r3
 8242b34:	e13ff717 	ldw	r4,-36(fp)
 8242b38:	21000383 	ldbu	r4,14(r4)
 8242b3c:	21003fcc 	andi	r4,r4,255
 8242b40:	e17ff717 	ldw	r5,-36(fp)
 8242b44:	2940030b 	ldhu	r5,12(r5)
 8242b48:	297fffcc 	andi	r5,r5,65535
 8242b4c:	280ad23a 	srli	r5,r5,8
 8242b50:	297fffcc 	andi	r5,r5,65535
 8242b54:	29803fcc 	andi	r6,r5,255
 8242b58:	e17ff717 	ldw	r5,-36(fp)
 8242b5c:	2940030b 	ldhu	r5,12(r5)
 8242b60:	297fffcc 	andi	r5,r5,65535
 8242b64:	280a923a 	slli	r5,r5,8
 8242b68:	297fffcc 	andi	r5,r5,65535
 8242b6c:	314ab03a 	or	r5,r6,r5
 8242b70:	e1bff717 	ldw	r6,-36(fp)
 8242b74:	3180040b 	ldhu	r6,16(r6)
 8242b78:	31bfffcc 	andi	r6,r6,65535
 8242b7c:	e1fff717 	ldw	r7,-36(fp)
 8242b80:	39c0048b 	ldhu	r7,18(r7)
 8242b84:	39ffffcc 	andi	r7,r7,65535
 8242b88:	e23ff717 	ldw	r8,-36(fp)
 8242b8c:	42000517 	ldw	r8,20(r8)
 8242b90:	e27ff717 	ldw	r9,-36(fp)
 8242b94:	4a401f17 	ldw	r9,124(r9)
 8242b98:	e2bff717 	ldw	r10,-36(fp)
 8242b9c:	52802017 	ldw	r10,128(r10)
 8242ba0:	e2fff717 	ldw	r11,-36(fp)
 8242ba4:	5ac02103 	ldbu	r11,132(r11)
 8242ba8:	5ac03fcc 	andi	r11,r11,255
 8242bac:	5ac0004c 	andi	r11,r11,1
 8242bb0:	dac00915 	stw	r11,36(sp)
 8242bb4:	da800815 	stw	r10,32(sp)
 8242bb8:	da400715 	stw	r9,28(sp)
 8242bbc:	da000615 	stw	r8,24(sp)
 8242bc0:	d9c00515 	stw	r7,20(sp)
 8242bc4:	d9800415 	stw	r6,16(sp)
 8242bc8:	d9400315 	stw	r5,12(sp)
 8242bcc:	d9000215 	stw	r4,8(sp)
 8242bd0:	d8c00115 	stw	r3,4(sp)
 8242bd4:	d8800015 	stw	r2,0(sp)
 8242bd8:	600f883a 	mov	r7,r12
 8242bdc:	e1bff717 	ldw	r6,-36(fp)
 8242be0:	01420974 	movhi	r5,2085
 8242be4:	29452804 	addi	r5,r5,5280
 8242be8:	e13ffd17 	ldw	r4,-12(fp)
 8242bec:	8228ebc0 	call	8228ebc <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8242bf0:	e0bff717 	ldw	r2,-36(fp)
 8242bf4:	10800017 	ldw	r2,0(r2)
 8242bf8:	e0bff715 	stw	r2,-36(fp)
 8242bfc:	e0bff717 	ldw	r2,-36(fp)
 8242c00:	103f821e 	bne	r2,zero,8242a0c <ipr_stats+0x128>
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
      } /* end FOR (IRE linked list) */

   ns_printf(pio,"Found a total of %u IRE entries\n",count);
 8242c04:	e0bff80b 	ldhu	r2,-32(fp)
 8242c08:	100d883a 	mov	r6,r2
 8242c0c:	01420974 	movhi	r5,2085
 8242c10:	29454304 	addi	r5,r5,5388
 8242c14:	e13ffd17 	ldw	r4,-12(fp)
 8242c18:	8228ebc0 	call	8228ebc <ns_printf>

   return IPREASM_OK;
 8242c1c:	0005883a 	mov	r2,zero
}
 8242c20:	e6fffe04 	addi	sp,fp,-8
 8242c24:	dfc00317 	ldw	ra,12(sp)
 8242c28:	df000217 	ldw	fp,8(sp)
 8242c2c:	dc400117 	ldw	r17,4(sp)
 8242c30:	dc000017 	ldw	r16,0(sp)
 8242c34:	dec00404 	addi	sp,sp,16
 8242c38:	f800283a 	ret

08242c3c <ip_reasm_send_icmp_timex>:
OUTPUT: This function always returns IPREASM_OK.
*/

#ifdef FULL_ICMP
u_long ip_reasm_send_icmp_timex (IREP irep)
{
 8242c3c:	defffc04 	addi	sp,sp,-16
 8242c40:	dfc00315 	stw	ra,12(sp)
 8242c44:	df000215 	stw	fp,8(sp)
 8242c48:	df000204 	addi	fp,sp,8
 8242c4c:	e13fff15 	stw	r4,-4(fp)

   /* we can only send an ICMP Time Exceeded message with code 1 ("fragment reassembly 
    * time exceeded") if we have received the First Fragment (FF) of the original, 
    * unfragmented datagram.  This is indicated by a non-zero value for the l2_hdr and
    * l3_hdr fields in the IRE data structure. */
   if (irep->l2_hdr)
 8242c50:	e0bfff17 	ldw	r2,-4(fp)
 8242c54:	10801f17 	ldw	r2,124(r2)
 8242c58:	10000626 	beq	r2,zero,8242c74 <ip_reasm_send_icmp_timex+0x38>
      {
      pip = (struct ip *) irep->l3_hdr;
 8242c5c:	e0bfff17 	ldw	r2,-4(fp)
 8242c60:	10802017 	ldw	r2,128(r2)
 8242c64:	e0bffe15 	stw	r2,-8(fp)
      icmp_timex (pip, TIMEX_REASSY_FAILED);
 8242c68:	01400044 	movi	r5,1
 8242c6c:	e13ffe17 	ldw	r4,-8(fp)
 8242c70:	824b3200 	call	824b320 <icmp_timex>
      }

   return IPREASM_OK;
 8242c74:	0005883a 	mov	r2,zero
}
 8242c78:	e037883a 	mov	sp,fp
 8242c7c:	dfc00117 	ldw	ra,4(sp)
 8242c80:	df000017 	ldw	fp,0(sp)
 8242c84:	dec00204 	addi	sp,sp,8
 8242c88:	f800283a 	ret

08242c8c <ip_rcv>:
 * RETURNS: 
 */

int
ip_rcv(PACKET p)
{
 8242c8c:	defff404 	addi	sp,sp,-48
 8242c90:	dfc00b15 	stw	ra,44(sp)
 8242c94:	df000a15 	stw	fp,40(sp)
 8242c98:	dc000915 	stw	r16,36(sp)
 8242c9c:	df000a04 	addi	fp,sp,40
 8242ca0:	e13ffe15 	stw	r4,-8(fp)
   unsigned hdrlen;  /* length of IP header including options */
   unsigned len;     /* total length including IP header */
   unsigned short int num_pkts;
   PACKET * pktp;
   unsigned char i;
   int rcvrc = -1;
 8242ca4:	00bfffc4 	movi	r2,-1
 8242ca8:	e0bff715 	stw	r2,-36(fp)
   unsigned char rc_ret;
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8242cac:	d0a08317 	ldw	r2,-32244(gp)
 8242cb0:	1081000c 	andi	r2,r2,1024
 8242cb4:	10000e26 	beq	r2,zero,8242cf0 <ip_rcv+0x64>
 8242cb8:	d0a08317 	ldw	r2,-32244(gp)
 8242cbc:	1080800c 	andi	r2,r2,512
 8242cc0:	10000b26 	beq	r2,zero,8242cf0 <ip_rcv+0x64>
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
         p->nb_plen, net_num(p->net));
 8242cc4:	e0bffe17 	ldw	r2,-8(fp)
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
 8242cc8:	14000417 	ldw	r16,16(r2)
         p->nb_plen, net_num(p->net));
 8242ccc:	e0bffe17 	ldw	r2,-8(fp)
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
 8242cd0:	10800617 	ldw	r2,24(r2)
 8242cd4:	1009883a 	mov	r4,r2
 8242cd8:	8226cc40 	call	8226cc4 <if_netnumber>
 8242cdc:	100d883a 	mov	r6,r2
 8242ce0:	800b883a 	mov	r5,r16
 8242ce4:	01020974 	movhi	r4,2085
 8242ce8:	21054c04 	addi	r4,r4,5424
 8242cec:	82033fc0 	call	82033fc <printf>
         p->nb_plen, net_num(p->net));
#endif

   IN_PROFILER(PF_IP, PF_ENTRY);

   ip_mib.ipInReceives++;
 8242cf0:	008209b4 	movhi	r2,2086
 8242cf4:	10ba8304 	addi	r2,r2,-5620
 8242cf8:	10800217 	ldw	r2,8(r2)
 8242cfc:	10c00044 	addi	r3,r2,1
 8242d00:	008209b4 	movhi	r2,2086
 8242d04:	10ba8304 	addi	r2,r2,-5620
 8242d08:	10c00215 	stw	r3,8(r2)
   pip = ip_head(p);
 8242d0c:	e0bffe17 	ldw	r2,-8(fp)
 8242d10:	10800317 	ldw	r2,12(r2)
 8242d14:	e0bff815 	stw	r2,-32(fp)

   /* test received MAC len against IP header len */
   if (p->nb_plen < (unsigned)htons(pip->ip_len))
 8242d18:	e0bffe17 	ldw	r2,-8(fp)
 8242d1c:	10800417 	ldw	r2,16(r2)
 8242d20:	e0fff817 	ldw	r3,-32(fp)
 8242d24:	18c0008b 	ldhu	r3,2(r3)
 8242d28:	18ffffcc 	andi	r3,r3,65535
 8242d2c:	1806d23a 	srli	r3,r3,8
 8242d30:	18ffffcc 	andi	r3,r3,65535
 8242d34:	19003fcc 	andi	r4,r3,255
 8242d38:	e0fff817 	ldw	r3,-32(fp)
 8242d3c:	18c0008b 	ldhu	r3,2(r3)
 8242d40:	18ffffcc 	andi	r3,r3,65535
 8242d44:	1806923a 	slli	r3,r3,8
 8242d48:	18ffffcc 	andi	r3,r3,65535
 8242d4c:	20c6b03a 	or	r3,r4,r3
 8242d50:	10c01f2e 	bgeu	r2,r3,8242dd0 <ip_rcv+0x144>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8242d54:	d0a08317 	ldw	r2,-32244(gp)
 8242d58:	1081000c 	andi	r2,r2,1024
 8242d5c:	10000c26 	beq	r2,zero,8242d90 <ip_rcv+0x104>
 8242d60:	d0a08317 	ldw	r2,-32244(gp)
 8242d64:	1080800c 	andi	r2,r2,512
 8242d68:	10000926 	beq	r2,zero,8242d90 <ip_rcv+0x104>
      {
         dprintf("ip_rcv: bad pkt len\n");
 8242d6c:	01020974 	movhi	r4,2085
 8242d70:	21055504 	addi	r4,r4,5460
 8242d74:	82036800 	call	8203680 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 8242d78:	d0a08317 	ldw	r2,-32244(gp)
 8242d7c:	1080008c 	andi	r2,r2,2
 8242d80:	10000326 	beq	r2,zero,8242d90 <ip_rcv+0x104>
 8242d84:	e0bffe17 	ldw	r2,-8(fp)
 8242d88:	1009883a 	mov	r4,r2
 8242d8c:	8240a9c0 	call	8240a9c <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 8242d90:	008209b4 	movhi	r2,2086
 8242d94:	10ba8304 	addi	r2,r2,-5620
 8242d98:	10800317 	ldw	r2,12(r2)
 8242d9c:	10c00044 	addi	r3,r2,1
 8242da0:	008209b4 	movhi	r2,2086
 8242da4:	10ba8304 	addi	r2,r2,-5620
 8242da8:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 8242dac:	01000084 	movi	r4,2
 8242db0:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free(p);
 8242db4:	e0bffe17 	ldw	r2,-8(fp)
 8242db8:	1009883a 	mov	r4,r2
 8242dbc:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8242dc0:	01000084 	movi	r4,2
 8242dc4:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 8242dc8:	00bff804 	movi	r2,-32
 8242dcc:	00008906 	br	8242ff4 <ip_rcv+0x368>
   }

   /* use length from IP header; MAC value may be padded */
   len = htons(pip->ip_len);
 8242dd0:	e0bff817 	ldw	r2,-32(fp)
 8242dd4:	1080008b 	ldhu	r2,2(r2)
 8242dd8:	10bfffcc 	andi	r2,r2,65535
 8242ddc:	1004d23a 	srli	r2,r2,8
 8242de0:	10bfffcc 	andi	r2,r2,65535
 8242de4:	10c03fcc 	andi	r3,r2,255
 8242de8:	e0bff817 	ldw	r2,-32(fp)
 8242dec:	1080008b 	ldhu	r2,2(r2)
 8242df0:	10bfffcc 	andi	r2,r2,65535
 8242df4:	1004923a 	slli	r2,r2,8
 8242df8:	10bfffcc 	andi	r2,r2,65535
 8242dfc:	1884b03a 	or	r2,r3,r2
 8242e00:	e0bff915 	stw	r2,-28(fp)
   p->nb_plen = len;       /* fix pkt len */
 8242e04:	e0bffe17 	ldw	r2,-8(fp)
 8242e08:	e0fff917 	ldw	r3,-28(fp)
 8242e0c:	10c00415 	stw	r3,16(r2)

   if ( ((pip->ip_ver_ihl & 0xf0) >> 4) != IP_VER)
 8242e10:	e0bff817 	ldw	r2,-32(fp)
 8242e14:	10800003 	ldbu	r2,0(r2)
 8242e18:	10803fcc 	andi	r2,r2,255
 8242e1c:	1004d13a 	srli	r2,r2,4
 8242e20:	10803fcc 	andi	r2,r2,255
 8242e24:	10800120 	cmpeqi	r2,r2,4
 8242e28:	10001f1e 	bne	r2,zero,8242ea8 <ip_rcv+0x21c>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8242e2c:	d0a08317 	ldw	r2,-32244(gp)
 8242e30:	1081000c 	andi	r2,r2,1024
 8242e34:	10000c26 	beq	r2,zero,8242e68 <ip_rcv+0x1dc>
 8242e38:	d0a08317 	ldw	r2,-32244(gp)
 8242e3c:	1080800c 	andi	r2,r2,512
 8242e40:	10000926 	beq	r2,zero,8242e68 <ip_rcv+0x1dc>
      {
         dprintf("ip_rcv: bad version number\n");
 8242e44:	01020974 	movhi	r4,2085
 8242e48:	21055a04 	addi	r4,r4,5480
 8242e4c:	82036800 	call	8203680 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 8242e50:	d0a08317 	ldw	r2,-32244(gp)
 8242e54:	1080008c 	andi	r2,r2,2
 8242e58:	10000326 	beq	r2,zero,8242e68 <ip_rcv+0x1dc>
 8242e5c:	e0bffe17 	ldw	r2,-8(fp)
 8242e60:	1009883a 	mov	r4,r2
 8242e64:	8240a9c0 	call	8240a9c <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 8242e68:	008209b4 	movhi	r2,2086
 8242e6c:	10ba8304 	addi	r2,r2,-5620
 8242e70:	10800317 	ldw	r2,12(r2)
 8242e74:	10c00044 	addi	r3,r2,1
 8242e78:	008209b4 	movhi	r2,2086
 8242e7c:	10ba8304 	addi	r2,r2,-5620
 8242e80:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 8242e84:	01000084 	movi	r4,2
 8242e88:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free(p);
 8242e8c:	e0bffe17 	ldw	r2,-8(fp)
 8242e90:	1009883a 	mov	r4,r2
 8242e94:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8242e98:	01000084 	movi	r4,2
 8242e9c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 8242ea0:	00bff804 	movi	r2,-32
 8242ea4:	00005306 	br	8242ff4 <ip_rcv+0x368>
   }

   csum = pip->ip_chksum;
 8242ea8:	e0bff817 	ldw	r2,-32(fp)
 8242eac:	1080028b 	ldhu	r2,10(r2)
 8242eb0:	e0bffa0d 	sth	r2,-24(fp)
   pip->ip_chksum = 0;
 8242eb4:	e0bff817 	ldw	r2,-32(fp)
 8242eb8:	1000028d 	sth	zero,10(r2)
   hdrlen = ip_hlen(pip);
 8242ebc:	e0bff817 	ldw	r2,-32(fp)
 8242ec0:	10800003 	ldbu	r2,0(r2)
 8242ec4:	10803fcc 	andi	r2,r2,255
 8242ec8:	108003cc 	andi	r2,r2,15
 8242ecc:	1085883a 	add	r2,r2,r2
 8242ed0:	1085883a 	add	r2,r2,r2
 8242ed4:	e0bffb15 	stw	r2,-20(fp)
   tempsum = ~cksum(pip, hdrlen >> 1);
 8242ed8:	e0bffb17 	ldw	r2,-20(fp)
 8242edc:	1004d07a 	srli	r2,r2,1
 8242ee0:	100b883a 	mov	r5,r2
 8242ee4:	e13ff817 	ldw	r4,-32(fp)
 8242ee8:	82288100 	call	8228810 <cksum>
 8242eec:	0084303a 	nor	r2,zero,r2
 8242ef0:	e0bffc0d 	sth	r2,-16(fp)

   if (csum != tempsum)
 8242ef4:	e0fffa0b 	ldhu	r3,-24(fp)
 8242ef8:	e0bffc0b 	ldhu	r2,-16(fp)
 8242efc:	18802226 	beq	r3,r2,8242f88 <ip_rcv+0x2fc>
   {
      pip->ip_chksum = csum;
 8242f00:	e0bff817 	ldw	r2,-32(fp)
 8242f04:	e0fffa0b 	ldhu	r3,-24(fp)
 8242f08:	10c0028d 	sth	r3,10(r2)
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8242f0c:	d0a08317 	ldw	r2,-32244(gp)
 8242f10:	1081000c 	andi	r2,r2,1024
 8242f14:	10000c26 	beq	r2,zero,8242f48 <ip_rcv+0x2bc>
 8242f18:	d0a08317 	ldw	r2,-32244(gp)
 8242f1c:	1080800c 	andi	r2,r2,512
 8242f20:	10000926 	beq	r2,zero,8242f48 <ip_rcv+0x2bc>
      {
         dprintf("ip_rcv: bad xsum\n");
 8242f24:	01020974 	movhi	r4,2085
 8242f28:	21056104 	addi	r4,r4,5508
 8242f2c:	82036800 	call	8203680 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 8242f30:	d0a08317 	ldw	r2,-32244(gp)
 8242f34:	1080008c 	andi	r2,r2,2
 8242f38:	10000326 	beq	r2,zero,8242f48 <ip_rcv+0x2bc>
 8242f3c:	e0bffe17 	ldw	r2,-8(fp)
 8242f40:	1009883a 	mov	r4,r2
 8242f44:	8240a9c0 	call	8240a9c <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 8242f48:	008209b4 	movhi	r2,2086
 8242f4c:	10ba8304 	addi	r2,r2,-5620
 8242f50:	10800317 	ldw	r2,12(r2)
 8242f54:	10c00044 	addi	r3,r2,1
 8242f58:	008209b4 	movhi	r2,2086
 8242f5c:	10ba8304 	addi	r2,r2,-5620
 8242f60:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 8242f64:	01000084 	movi	r4,2
 8242f68:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free(p);
 8242f6c:	e0bffe17 	ldw	r2,-8(fp)
 8242f70:	1009883a 	mov	r4,r2
 8242f74:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8242f78:	01000084 	movi	r4,2
 8242f7c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 8242f80:	00bff804 	movi	r2,-32
 8242f84:	00001b06 	br	8242ff4 <ip_rcv+0x368>
   }

   pip->ip_chksum = csum;
 8242f88:	e0bff817 	ldw	r2,-32(fp)
 8242f8c:	e0fffa0b 	ldhu	r3,-24(fp)
 8242f90:	10c0028d 	sth	r3,10(r2)
#endif

    /* start off by assuming that we will only process the "current" packet;
     * these values may get overwritten by the NAT module if it returns
     * more than one packet back to this function (ip_rcv ()) */
    num_pkts = 1;
 8242f94:	00800044 	movi	r2,1
 8242f98:	e0bffc8d 	sth	r2,-14(fp)
    pktp = &p;
 8242f9c:	e0bffe04 	addi	r2,fp,-8
 8242fa0:	e0bffd15 	stw	r2,-12(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 8242fa4:	e03ff605 	stb	zero,-40(fp)
 8242fa8:	00000d06 	br	8242fe0 <ip_rcv+0x354>
   {
      rcvrc = ip_rcv_phase2 (*(pktp + i));
 8242fac:	e0bff603 	ldbu	r2,-40(fp)
 8242fb0:	1085883a 	add	r2,r2,r2
 8242fb4:	1085883a 	add	r2,r2,r2
 8242fb8:	1007883a 	mov	r3,r2
 8242fbc:	e0bffd17 	ldw	r2,-12(fp)
 8242fc0:	10c5883a 	add	r2,r2,r3
 8242fc4:	10800017 	ldw	r2,0(r2)
 8242fc8:	1009883a 	mov	r4,r2
 8242fcc:	824300c0 	call	824300c <ip_rcv_phase2>
 8242fd0:	e0bff715 	stw	r2,-36(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 8242fd4:	e0bff603 	ldbu	r2,-40(fp)
 8242fd8:	10800044 	addi	r2,r2,1
 8242fdc:	e0bff605 	stb	r2,-40(fp)
 8242fe0:	e0bff603 	ldbu	r2,-40(fp)
 8242fe4:	10ffffcc 	andi	r3,r2,65535
 8242fe8:	e0bffc8b 	ldhu	r2,-14(fp)
 8242fec:	18bfef36 	bltu	r3,r2,8242fac <ip_rcv+0x320>
   if (pktp != &p) nat_free (pktp);
#endif /* NATRT */

   /* when multiple packets are processed in the loop above, the return code
    * contains the return code for the last packet */
   return rcvrc;
 8242ff0:	e0bff717 	ldw	r2,-36(fp)
}
 8242ff4:	e6ffff04 	addi	sp,fp,-4
 8242ff8:	dfc00217 	ldw	ra,8(sp)
 8242ffc:	df000117 	ldw	fp,4(sp)
 8243000:	dc000017 	ldw	r16,0(sp)
 8243004:	dec00304 	addi	sp,sp,12
 8243008:	f800283a 	ret

0824300c <ip_rcv_phase2>:


int ip_rcv_phase2 (PACKET p)
{
 824300c:	defff504 	addi	sp,sp,-44
 8243010:	dfc00a15 	stw	ra,40(sp)
 8243014:	df000915 	stw	fp,36(sp)
 8243018:	df000904 	addi	fp,sp,36
 824301c:	e13fff15 	stw	r4,-4(fp)

   struct ip * pip;     /* the internet header */
   NET nt;
   unsigned short tempsum;

   pip = ip_head(p);
 8243020:	e0bfff17 	ldw	r2,-4(fp)
 8243024:	10800317 	ldw	r2,12(r2)
 8243028:	e0bff815 	stw	r2,-32(fp)
   nt = p->net;      /* which interface it came in on */
 824302c:	e0bfff17 	ldw	r2,-4(fp)
 8243030:	10800617 	ldw	r2,24(r2)
 8243034:	e0bff915 	stw	r2,-28(fp)

#ifdef IP_MULTICAST

   if (IN_MULTICAST(ntohl(pip->ip_dest))) 
 8243038:	e0bff817 	ldw	r2,-32(fp)
 824303c:	10800417 	ldw	r2,16(r2)
 8243040:	1006d63a 	srli	r3,r2,24
 8243044:	e0bff817 	ldw	r2,-32(fp)
 8243048:	10800417 	ldw	r2,16(r2)
 824304c:	1004d23a 	srli	r2,r2,8
 8243050:	10bfc00c 	andi	r2,r2,65280
 8243054:	1886b03a 	or	r3,r3,r2
 8243058:	e0bff817 	ldw	r2,-32(fp)
 824305c:	10800417 	ldw	r2,16(r2)
 8243060:	10bfc00c 	andi	r2,r2,65280
 8243064:	1004923a 	slli	r2,r2,8
 8243068:	1886b03a 	or	r3,r3,r2
 824306c:	e0bff817 	ldw	r2,-32(fp)
 8243070:	10800417 	ldw	r2,16(r2)
 8243074:	1004963a 	slli	r2,r2,24
 8243078:	1884b03a 	or	r2,r3,r2
 824307c:	10fc002c 	andhi	r3,r2,61440
 8243080:	00b80034 	movhi	r2,57344
 8243084:	1880171e 	bne	r3,r2,82430e4 <ip_rcv_phase2+0xd8>
      struct in_multi * inm;
      /*
       * See if we belong to the destination multicast group on the
       * arrival interface.
       */
      inm = lookup_mcast(pip->ip_dest, nt);
 8243088:	e0bff817 	ldw	r2,-32(fp)
 824308c:	10800417 	ldw	r2,16(r2)
 8243090:	e17ff917 	ldw	r5,-28(fp)
 8243094:	1009883a 	mov	r4,r2
 8243098:	8243c040 	call	8243c04 <lookup_mcast>
 824309c:	e0bffa15 	stw	r2,-24(fp)
      if (inm == NULL) 
 82430a0:	e0bffa17 	ldw	r2,-24(fp)
 82430a4:	1001081e 	bne	r2,zero,82434c8 <ip_rcv_phase2+0x4bc>
      {
         ip_mib.ipOutNoRoutes++;
 82430a8:	008209b4 	movhi	r2,2086
 82430ac:	10ba8304 	addi	r2,r2,-5620
 82430b0:	10800b17 	ldw	r2,44(r2)
 82430b4:	10c00044 	addi	r3,r2,1
 82430b8:	008209b4 	movhi	r2,2086
 82430bc:	10ba8304 	addi	r2,r2,-5620
 82430c0:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 82430c4:	01000084 	movi	r4,2
 82430c8:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
         pk_free(p);
 82430cc:	e13fff17 	ldw	r4,-4(fp)
 82430d0:	822cd980 	call	822cd98 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82430d4:	01000084 	movi	r4,2
 82430d8:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NOT_MINE);
 82430dc:	00800084 	movi	r2,2
 82430e0:	00013806 	br	82435c4 <ip_rcv_phase2+0x5b8>
      else
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
 82430e4:	e0bff817 	ldw	r2,-32(fp)
 82430e8:	10c00417 	ldw	r3,16(r2)
 82430ec:	e0bff917 	ldw	r2,-28(fp)
 82430f0:	10800a17 	ldw	r2,40(r2)
 82430f4:	1880f726 	beq	r3,r2,82434d4 <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 82430f8:	e0bff817 	ldw	r2,-32(fp)
 82430fc:	10800417 	ldw	r2,16(r2)
      else
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
 8243100:	10bfffe0 	cmpeqi	r2,r2,-1
 8243104:	1000f31e 	bne	r2,zero,82434d4 <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
 8243108:	e0bff817 	ldw	r2,-32(fp)
 824310c:	10c00417 	ldw	r3,16(r2)
 8243110:	e0bff917 	ldw	r2,-28(fp)
 8243114:	10800e17 	ldw	r2,56(r2)
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 8243118:	1880ee26 	beq	r3,r2,82434d4 <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
 824311c:	e0bff817 	ldw	r2,-32(fp)
 8243120:	10c00417 	ldw	r3,16(r2)
 8243124:	e0bff917 	ldw	r2,-28(fp)
 8243128:	10800f17 	ldw	r2,60(r2)
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
 824312c:	1880e926 	beq	r3,r2,82434d4 <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
 8243130:	e0bff817 	ldw	r2,-32(fp)
 8243134:	10c00417 	ldw	r3,16(r2)
 8243138:	e0bff917 	ldw	r2,-28(fp)
 824313c:	10801017 	ldw	r2,64(r2)
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
 8243140:	1880e426 	beq	r3,r2,82434d4 <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
 8243144:	e0bff917 	ldw	r2,-28(fp)
 8243148:	10c00a17 	ldw	r3,40(r2)
 824314c:	e0bff917 	ldw	r2,-28(fp)
 8243150:	10800c17 	ldw	r2,48(r2)
 8243154:	0084303a 	nor	r2,zero,r2
 8243158:	1884703a 	and	r2,r3,r2

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
 824315c:	1000dd26 	beq	r2,zero,82434d4 <ip_rcv_phase2+0x4c8>
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8243160:	d0a08317 	ldw	r2,-32244(gp)
 8243164:	1081000c 	andi	r2,r2,1024
 8243168:	10001826 	beq	r2,zero,82431cc <ip_rcv_phase2+0x1c0>
 824316c:	d0a08317 	ldw	r2,-32244(gp)
 8243170:	1080800c 	andi	r2,r2,512
 8243174:	10001526 	beq	r2,zero,82431cc <ip_rcv_phase2+0x1c0>
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
       PUSH_IPADDR(pip->ip_dest));
 8243178:	e0bff817 	ldw	r2,-32(fp)
 824317c:	10800417 	ldw	r2,16(r2)
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 8243180:	10c03fcc 	andi	r3,r2,255
       PUSH_IPADDR(pip->ip_dest));
 8243184:	e0bff817 	ldw	r2,-32(fp)
 8243188:	10800417 	ldw	r2,16(r2)
 824318c:	1004d23a 	srli	r2,r2,8
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 8243190:	11003fcc 	andi	r4,r2,255
       PUSH_IPADDR(pip->ip_dest));
 8243194:	e0bff817 	ldw	r2,-32(fp)
 8243198:	10800417 	ldw	r2,16(r2)
 824319c:	1004d43a 	srli	r2,r2,16
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 82431a0:	11403fcc 	andi	r5,r2,255
       PUSH_IPADDR(pip->ip_dest));
 82431a4:	e0bff817 	ldw	r2,-32(fp)
 82431a8:	10800417 	ldw	r2,16(r2)
 82431ac:	1004d63a 	srli	r2,r2,24
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 82431b0:	d8800015 	stw	r2,0(sp)
 82431b4:	280f883a 	mov	r7,r5
 82431b8:	200d883a 	mov	r6,r4
 82431bc:	180b883a 	mov	r5,r3
 82431c0:	01020974 	movhi	r4,2085
 82431c4:	21056604 	addi	r4,r4,5528
 82431c8:	82033fc0 	call	82033fc <printf>

#ifdef IP_ROUTING    /* if multi-homed router, try to route */
      /* Do routing only if ipForwarding is enabled in the IP MIB. This
       * is the switch for routing whether SNMP is used or not.
       */
      if (ip_mib.ipForwarding == 2)
 82431cc:	008209b4 	movhi	r2,2086
 82431d0:	10ba8304 	addi	r2,r2,-5620
 82431d4:	10800017 	ldw	r2,0(r2)
 82431d8:	10800098 	cmpnei	r2,r2,2
 82431dc:	10000f1e 	bne	r2,zero,824321c <ip_rcv_phase2+0x210>
      {
         ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 82431e0:	008209b4 	movhi	r2,2086
 82431e4:	10ba8304 	addi	r2,r2,-5620
 82431e8:	10800a17 	ldw	r2,40(r2)
 82431ec:	10c00044 	addi	r3,r2,1
 82431f0:	008209b4 	movhi	r2,2086
 82431f4:	10ba8304 	addi	r2,r2,-5620
 82431f8:	10c00a15 	stw	r3,40(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 82431fc:	01000084 	movi	r4,2
 8243200:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
         pk_free(p);
 8243204:	e13fff17 	ldw	r4,-4(fp)
 8243208:	822cd980 	call	822cd98 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824320c:	01000084 	movi	r4,2
 8243210:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_NO_ROUTE;
 8243214:	00bff7c4 	movi	r2,-33
 8243218:	0000ea06 	br	82435c4 <ip_rcv_phase2+0x5b8>
         NET outnet;
#ifdef IP_FRAGMENTS
         int err;
#endif

         ip_mib.ipForwDatagrams++;  /* Count MIB-2 route attempts here */
 824321c:	008209b4 	movhi	r2,2086
 8243220:	10ba8304 	addi	r2,r2,-5620
 8243224:	10800517 	ldw	r2,20(r2)
 8243228:	10c00044 	addi	r3,r2,1
 824322c:	008209b4 	movhi	r2,2086
 8243230:	10ba8304 	addi	r2,r2,-5620
 8243234:	10c00515 	stw	r3,20(r2)
         if (pip->ip_time <= 1)     /* Time to Live (hopcount) expired? */
 8243238:	e0bff817 	ldw	r2,-32(fp)
 824323c:	10800203 	ldbu	r2,8(r2)
 8243240:	10803fcc 	andi	r2,r2,255
 8243244:	108000a8 	cmpgeui	r2,r2,2
 8243248:	10001c1e 	bne	r2,zero,82432bc <ip_rcv_phase2+0x2b0>
         {
            ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 824324c:	008209b4 	movhi	r2,2086
 8243250:	10ba8304 	addi	r2,r2,-5620
 8243254:	10800a17 	ldw	r2,40(r2)
 8243258:	10c00044 	addi	r3,r2,1
 824325c:	008209b4 	movhi	r2,2086
 8243260:	10ba8304 	addi	r2,r2,-5620
 8243264:	10c00a15 	stw	r3,40(r2)
#ifdef FULL_ICMP
            icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, (TIMEX <<8), p->net);
 8243268:	e0bff817 	ldw	r2,-32(fp)
 824326c:	10c00317 	ldw	r3,12(r2)
 8243270:	e0bfff17 	ldw	r2,-4(fp)
 8243274:	10800617 	ldw	r2,24(r2)
 8243278:	11000a17 	ldw	r4,40(r2)
 824327c:	e0bfff17 	ldw	r2,-4(fp)
 8243280:	10800617 	ldw	r2,24(r2)
 8243284:	d8800015 	stw	r2,0(sp)
 8243288:	01c2c004 	movi	r7,2816
 824328c:	e1bff817 	ldw	r6,-32(fp)
 8243290:	200b883a 	mov	r5,r4
 8243294:	1809883a 	mov	r4,r3
 8243298:	824b0200 	call	824b020 <icmp_destun>
#endif   /* FULL_ICMP */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 824329c:	01000084 	movi	r4,2
 82432a0:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
            pk_free(p);
 82432a4:	e13fff17 	ldw	r4,-4(fp)
 82432a8:	822cd980 	call	822cd98 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82432ac:	01000084 	movi	r4,2
 82432b0:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 82432b4:	00bff7c4 	movi	r2,-33
 82432b8:	0000c206 	br	82435c4 <ip_rcv_phase2+0x5b8>
         }

         p->fhost = pip->ip_dest;   /* set packet's target IP in net endian */
 82432bc:	e0bff817 	ldw	r2,-32(fp)
 82432c0:	10c00417 	ldw	r3,16(r2)
 82432c4:	e0bfff17 	ldw	r2,-4(fp)
 82432c8:	10c00715 	stw	r3,28(r2)
         if ((outnet = iproute(p->fhost, &firsthop)) == NULL)  /* find route */
 82432cc:	e0bfff17 	ldw	r2,-4(fp)
 82432d0:	10800717 	ldw	r2,28(r2)
 82432d4:	e0fffe04 	addi	r3,fp,-8
 82432d8:	180b883a 	mov	r5,r3
 82432dc:	1009883a 	mov	r4,r2
 82432e0:	8240d440 	call	8240d44 <iproute>
 82432e4:	e0bffb15 	stw	r2,-20(fp)
 82432e8:	e0bffb17 	ldw	r2,-20(fp)
 82432ec:	10000f1e 	bne	r2,zero,824332c <ip_rcv_phase2+0x320>
         {
            ip_mib.ipOutNoRoutes++; /* count unroutable pkts */
 82432f0:	008209b4 	movhi	r2,2086
 82432f4:	10ba8304 	addi	r2,r2,-5620
 82432f8:	10800b17 	ldw	r2,44(r2)
 82432fc:	10c00044 	addi	r3,r2,1
 8243300:	008209b4 	movhi	r2,2086
 8243304:	10ba8304 	addi	r2,r2,-5620
 8243308:	10c00b15 	stw	r3,44(r2)
            LOCK_NET_RESOURCE(FREEQ_RESID);
 824330c:	01000084 	movi	r4,2
 8243310:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
            pk_free(p);
 8243314:	e13fff17 	ldw	r4,-4(fp)
 8243318:	822cd980 	call	822cd98 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824331c:	01000084 	movi	r4,2
 8243320:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 8243324:	00bff7c4 	movi	r2,-33
 8243328:	0000a606 	br	82435c4 <ip_rcv_phase2+0x5b8>
         /* Check to see if the packet was is addressed to one of our IP
          * addresses other than the interface it was received on. If so,
          * routing should have returned that interface and we can trap this
          * situation by checking the interfaces IP address.
          */
         if(pip->ip_dest == outnet->n_ipaddr)
 824332c:	e0bff817 	ldw	r2,-32(fp)
 8243330:	10c00417 	ldw	r3,16(r2)
 8243334:	e0bffb17 	ldw	r2,-20(fp)
 8243338:	10800a17 	ldw	r2,40(r2)
 824333c:	18806426 	beq	r3,r2,82434d0 <ip_rcv_phase2+0x4c4>
            goto ours;

         /* Make sure the packet is not a subnet broadcast for either the
          * source or destination network.
          */
         if((pip->ip_dest == outnet->n_netbr) ||
 8243340:	e0bff817 	ldw	r2,-32(fp)
 8243344:	10c00417 	ldw	r3,16(r2)
 8243348:	e0bffb17 	ldw	r2,-20(fp)
 824334c:	10800e17 	ldw	r2,56(r2)
 8243350:	18806026 	beq	r3,r2,82434d4 <ip_rcv_phase2+0x4c8>
            (pip->ip_dest == p->net->n_netbr))
 8243354:	e0bff817 	ldw	r2,-32(fp)
 8243358:	10c00417 	ldw	r3,16(r2)
 824335c:	e0bfff17 	ldw	r2,-4(fp)
 8243360:	10800617 	ldw	r2,24(r2)
 8243364:	10800e17 	ldw	r2,56(r2)
            goto ours;

         /* Make sure the packet is not a subnet broadcast for either the
          * source or destination network.
          */
         if((pip->ip_dest == outnet->n_netbr) ||
 8243368:	18805a26 	beq	r3,r2,82434d4 <ip_rcv_phase2+0x4c8>
         {
            goto ours;            
         }

         /* Routed OK, prepare to send */
         p->net = outnet;           /* set iface to send on */
 824336c:	e0bfff17 	ldw	r2,-4(fp)
 8243370:	e0fffb17 	ldw	r3,-20(fp)
 8243374:	10c00615 	stw	r3,24(r2)
            }
         }
#endif   /* IPSEC */

         /* see if packet is too big for media of dest net */
         if ((p->nb_plen + p->net->n_lnh) > (unsigned)outnet->n_mtu)
 8243378:	e0bfff17 	ldw	r2,-4(fp)
 824337c:	10800417 	ldw	r2,16(r2)
 8243380:	e0ffff17 	ldw	r3,-4(fp)
 8243384:	18c00617 	ldw	r3,24(r3)
 8243388:	18c00817 	ldw	r3,32(r3)
 824338c:	10c5883a 	add	r2,r2,r3
 8243390:	e0fffb17 	ldw	r3,-20(fp)
 8243394:	18c00917 	ldw	r3,36(r3)
 8243398:	1880372e 	bgeu	r3,r2,8243478 <ip_rcv_phase2+0x46c>
         {
#ifdef IP_FRAGMENTS
            /* see if we're not supposed to fragment it */
            if (ntohs(pip->ip_flgs_foff) & IP_FLG_DF)
 824339c:	e0bff817 	ldw	r2,-32(fp)
 82433a0:	1080018b 	ldhu	r2,6(r2)
 82433a4:	10bfffcc 	andi	r2,r2,65535
 82433a8:	1004d23a 	srli	r2,r2,8
 82433ac:	10bfffcc 	andi	r2,r2,65535
 82433b0:	10c03fcc 	andi	r3,r2,255
 82433b4:	e0bff817 	ldw	r2,-32(fp)
 82433b8:	1080018b 	ldhu	r2,6(r2)
 82433bc:	10bfffcc 	andi	r2,r2,65535
 82433c0:	1004923a 	slli	r2,r2,8
 82433c4:	10bfffcc 	andi	r2,r2,65535
 82433c8:	1884b03a 	or	r2,r3,r2
 82433cc:	1090000c 	andi	r2,r2,16384
 82433d0:	10001c26 	beq	r2,zero,8243444 <ip_rcv_phase2+0x438>
            {
#ifdef FULL_ICMP
               icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 82433d4:	e0bff817 	ldw	r2,-32(fp)
 82433d8:	10c00317 	ldw	r3,12(r2)
 82433dc:	e0bfff17 	ldw	r2,-4(fp)
 82433e0:	10800617 	ldw	r2,24(r2)
 82433e4:	11000a17 	ldw	r4,40(r2)
 82433e8:	e0bfff17 	ldw	r2,-4(fp)
 82433ec:	10800617 	ldw	r2,24(r2)
 82433f0:	d8800015 	stw	r2,0(sp)
 82433f4:	01c00104 	movi	r7,4
 82433f8:	e1bff817 	ldw	r6,-32(fp)
 82433fc:	200b883a 	mov	r5,r4
 8243400:	1809883a 	mov	r4,r3
 8243404:	824b0200 	call	824b020 <icmp_destun>
#endif   /* FULL_ICMP */
               ip_mib.ipFragFails++;
 8243408:	008209b4 	movhi	r2,2086
 824340c:	10ba8304 	addi	r2,r2,-5620
 8243410:	10801117 	ldw	r2,68(r2)
 8243414:	10c00044 	addi	r3,r2,1
 8243418:	008209b4 	movhi	r2,2086
 824341c:	10ba8304 	addi	r2,r2,-5620
 8243420:	10c01115 	stw	r3,68(r2)
               LOCK_NET_RESOURCE(FREEQ_RESID);
 8243424:	01000084 	movi	r4,2
 8243428:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
               pk_free(p);
 824342c:	e13fff17 	ldw	r4,-4(fp)
 8243430:	822cd980 	call	822cd98 <pk_free>
               UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8243434:	01000084 	movi	r4,2
 8243438:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
               IN_PROFILER(PF_IP, PF_EXIT);
               return ENP_LOGIC;
 824343c:	00bffd44 	movi	r2,-11
 8243440:	00006006 	br	82435c4 <ip_rcv_phase2+0x5b8>
            }

            /* fall to here if we're going to fragment it. */
            pip->ip_time--;            /* datagram's hop count */
 8243444:	e0bff817 	ldw	r2,-32(fp)
 8243448:	10800203 	ldbu	r2,8(r2)
 824344c:	10bfffc4 	addi	r2,r2,-1
 8243450:	1007883a 	mov	r3,r2
 8243454:	e0bff817 	ldw	r2,-32(fp)
 8243458:	10c00205 	stb	r3,8(r2)
            err = ip_fragment(p, firsthop);
 824345c:	e0bffe17 	ldw	r2,-8(fp)
 8243460:	100b883a 	mov	r5,r2
 8243464:	e13fff17 	ldw	r4,-4(fp)
 8243468:	82404340 	call	8240434 <ip_fragment>
 824346c:	e0bffc15 	stw	r2,-16(fp)
            IN_PROFILER(PF_IP, PF_EXIT);
            return(err);
 8243470:	e0bffc17 	ldw	r2,-16(fp)
 8243474:	00005306 	br	82435c4 <ip_rcv_phase2+0x5b8>
            pk_free(p);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
            return ENP_LOGIC;
#endif   /* IP_FRAGMENTS */
         }
         pip->ip_time--;            /* datagram's hop count */
 8243478:	e0bff817 	ldw	r2,-32(fp)
 824347c:	10800203 	ldbu	r2,8(r2)
 8243480:	10bfffc4 	addi	r2,r2,-1
 8243484:	1007883a 	mov	r3,r2
 8243488:	e0bff817 	ldw	r2,-32(fp)
 824348c:	10c00205 	stb	r3,8(r2)
         pip->ip_chksum = IPXSUM;   /* clear checksum field for summing */
 8243490:	e0bff817 	ldw	r2,-32(fp)
 8243494:	1000028d 	sth	zero,10(r2)
         pip->ip_chksum = ~cksum(pip, 10);   /* new xsum */
 8243498:	01400284 	movi	r5,10
 824349c:	e13ff817 	ldw	r4,-32(fp)
 82434a0:	82288100 	call	8228810 <cksum>
 82434a4:	0084303a 	nor	r2,zero,r2
 82434a8:	1007883a 	mov	r3,r2
 82434ac:	e0bff817 	ldw	r2,-32(fp)
 82434b0:	10c0028d 	sth	r3,10(r2)
         IN_PROFILER(PF_IP, PF_EXIT);
#ifdef RF_SIMULATION
         if(rfsim_routing)
            return(rfsim_send(p, firsthop));
#endif   /* RF_SIMULATION */
         return(ip2mac(p, firsthop));
 82434b4:	e0bffe17 	ldw	r2,-8(fp)
 82434b8:	100b883a 	mov	r5,r2
 82434bc:	e13fff17 	ldw	r4,-4(fp)
 82434c0:	82267540 	call	8226754 <ip2mac>
 82434c4:	00003f06 	br	82435c4 <ip_rcv_phase2+0x5b8>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NOT_MINE);
      }
      else
         goto ours;
 82434c8:	0001883a 	nop
 82434cc:	00000106 	br	82434d4 <ip_rcv_phase2+0x4c8>
          * addresses other than the interface it was received on. If so,
          * routing should have returned that interface and we can trap this
          * situation by checking the interfaces IP address.
          */
         if(pip->ip_dest == outnet->n_ipaddr)
            goto ours;
 82434d0:	0001883a 	nop
#if defined (IP_MULTICAST) || defined (IP_ROUTING)
ours:
#endif

   /* Test for fragment: */
   tempsum = htons(pip->ip_flgs_foff); /* borrow cksum variable */
 82434d4:	e0bff817 	ldw	r2,-32(fp)
 82434d8:	1080018b 	ldhu	r2,6(r2)
 82434dc:	10bfffcc 	andi	r2,r2,65535
 82434e0:	1004d23a 	srli	r2,r2,8
 82434e4:	1007883a 	mov	r3,r2
 82434e8:	e0bff817 	ldw	r2,-32(fp)
 82434ec:	1080018b 	ldhu	r2,6(r2)
 82434f0:	10bfffcc 	andi	r2,r2,65535
 82434f4:	1004923a 	slli	r2,r2,8
 82434f8:	1884b03a 	or	r2,r3,r2
 82434fc:	e0bffd0d 	sth	r2,-12(fp)
   if ((tempsum & IP_FLG_MF) ||  /* IP flag for "More Fragments" set? */
 8243500:	e0bffd0b 	ldhu	r2,-12(fp)
 8243504:	1088000c 	andi	r2,r2,8192
 8243508:	1000051e 	bne	r2,zero,8243520 <ip_rcv_phase2+0x514>
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
 824350c:	e0fffd0b 	ldhu	r3,-12(fp)
 8243510:	00bffff4 	movhi	r2,65535
 8243514:	1087ffc4 	addi	r2,r2,8191
 8243518:	1884703a 	and	r2,r3,r2
ours:
#endif

   /* Test for fragment: */
   tempsum = htons(pip->ip_flgs_foff); /* borrow cksum variable */
   if ((tempsum & IP_FLG_MF) ||  /* IP flag for "More Fragments" set? */
 824351c:	10002726 	beq	r2,zero,82435bc <ip_rcv_phase2+0x5b0>
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8243520:	d0a08317 	ldw	r2,-32244(gp)
 8243524:	1081000c 	andi	r2,r2,1024
 8243528:	10001a26 	beq	r2,zero,8243594 <ip_rcv_phase2+0x588>
 824352c:	d0a08317 	ldw	r2,-32244(gp)
 8243530:	1080800c 	andi	r2,r2,512
 8243534:	10001726 	beq	r2,zero,8243594 <ip_rcv_phase2+0x588>
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
          PUSH_IPADDR(pip->ip_src));
 8243538:	e0bff817 	ldw	r2,-32(fp)
 824353c:	10800317 	ldw	r2,12(r2)
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 8243540:	10c03fcc 	andi	r3,r2,255
          PUSH_IPADDR(pip->ip_src));
 8243544:	e0bff817 	ldw	r2,-32(fp)
 8243548:	10800317 	ldw	r2,12(r2)
 824354c:	1004d23a 	srli	r2,r2,8
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 8243550:	11003fcc 	andi	r4,r2,255
          PUSH_IPADDR(pip->ip_src));
 8243554:	e0bff817 	ldw	r2,-32(fp)
 8243558:	10800317 	ldw	r2,12(r2)
 824355c:	1004d43a 	srli	r2,r2,16
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 8243560:	11403fcc 	andi	r5,r2,255
          PUSH_IPADDR(pip->ip_src));
 8243564:	e0bff817 	ldw	r2,-32(fp)
 8243568:	10800317 	ldw	r2,12(r2)
 824356c:	1004d63a 	srli	r2,r2,24
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 8243570:	d8800015 	stw	r2,0(sp)
 8243574:	280f883a 	mov	r7,r5
 8243578:	200d883a 	mov	r6,r4
 824357c:	180b883a 	mov	r5,r3
 8243580:	01020974 	movhi	r4,2085
 8243584:	21057204 	addi	r4,r4,5576
 8243588:	82033fc0 	call	82033fc <printf>
          PUSH_IPADDR(pip->ip_src));
         ip_dump(p);
 824358c:	e13fff17 	ldw	r4,-4(fp)
 8243590:	8240a9c0 	call	8240a9c <ip_dump>
      }
#endif
      ip_mib.ipReasmReqds++;     /* got a reassemble request; ie a frag */
 8243594:	008209b4 	movhi	r2,2086
 8243598:	10ba8304 	addi	r2,r2,-5620
 824359c:	10800d17 	ldw	r2,52(r2)
 82435a0:	10c00044 	addi	r3,r2,1
 82435a4:	008209b4 	movhi	r2,2086
 82435a8:	10ba8304 	addi	r2,r2,-5620
 82435ac:	10c00d15 	stw	r3,52(r2)
#ifdef IP_FRAGMENTS
      return(ip_reassm(p));
 82435b0:	e13fff17 	ldw	r4,-4(fp)
 82435b4:	82416680 	call	8241668 <ip_reassm>
 82435b8:	00000206 	br	82435c4 <ip_rcv_phase2+0x5b8>
   {
      return ENP_LOGIC;
   }
#endif /* IPSEC */

   return(ip_demux(p));    /* demux to correct to upper layer */
 82435bc:	e13fff17 	ldw	r4,-4(fp)
 82435c0:	82435d80 	call	82435d8 <ip_demux>
}
 82435c4:	e037883a 	mov	sp,fp
 82435c8:	dfc00117 	ldw	ra,4(sp)
 82435cc:	df000017 	ldw	fp,0(sp)
 82435d0:	dec00204 	addi	sp,sp,8
 82435d4:	f800283a 	ret

082435d8 <ip_demux>:
 * RETURNS: Same return values as ip_rcv(). 
 */

int
ip_demux(PACKET p)
{
 82435d8:	defff904 	addi	sp,sp,-28
 82435dc:	dfc00615 	stw	ra,24(sp)
 82435e0:	df000515 	stw	fp,20(sp)
 82435e4:	df000504 	addi	fp,sp,20
 82435e8:	e13fff15 	stw	r4,-4(fp)
   int   err;

   /* The packet is verified; the header is correct. Now we have
    * to demultiplex it among our internet connections.
    */
   pip = (struct ip *)(p->nb_prot);
 82435ec:	e0bfff17 	ldw	r2,-4(fp)
 82435f0:	10800317 	ldw	r2,12(r2)
 82435f4:	e0bffe15 	stw	r2,-8(fp)

#ifdef NPDEBUG
   /* make sure the caller set p->nb_prot */
   if(pip->ip_ver_ihl != 0x45)
 82435f8:	e0bffe17 	ldw	r2,-8(fp)
 82435fc:	10800003 	ldbu	r2,0(r2)
 8243600:	10803fcc 	andi	r2,r2,255
 8243604:	10801160 	cmpeqi	r2,r2,69
 8243608:	1000131e 	bne	r2,zero,8243658 <ip_demux+0x80>
   {
      if((pip->ip_ver_ihl < 0x45) ||
 824360c:	e0bffe17 	ldw	r2,-8(fp)
 8243610:	10800003 	ldbu	r2,0(r2)
 8243614:	10803fcc 	andi	r2,r2,255
 8243618:	10801170 	cmpltui	r2,r2,69
 824361c:	1000051e 	bne	r2,zero,8243634 <ip_demux+0x5c>
         (pip->ip_ver_ihl > 0x47))
 8243620:	e0bffe17 	ldw	r2,-8(fp)
 8243624:	10800003 	ldbu	r2,0(r2)

#ifdef NPDEBUG
   /* make sure the caller set p->nb_prot */
   if(pip->ip_ver_ihl != 0x45)
   {
      if((pip->ip_ver_ihl < 0x45) ||
 8243628:	10803fcc 	andi	r2,r2,255
 824362c:	10801230 	cmpltui	r2,r2,72
 8243630:	1000091e 	bne	r2,zero,8243658 <ip_demux+0x80>
         (pip->ip_ver_ihl > 0x47))
      {
         dprintf("ip_demux: bad IP type 0x%x\n", pip->ip_ver_ihl);
 8243634:	e0bffe17 	ldw	r2,-8(fp)
 8243638:	10800003 	ldbu	r2,0(r2)
 824363c:	10803fcc 	andi	r2,r2,255
 8243640:	100b883a 	mov	r5,r2
 8243644:	01020974 	movhi	r4,2085
 8243648:	21057b04 	addi	r4,r4,5612
 824364c:	82033fc0 	call	82033fc <printf>
         return ENP_LOGIC;
 8243650:	00bffd44 	movi	r2,-11
 8243654:	0000d006 	br	8243998 <ip_demux+0x3c0>

   /* for profiling purposes count the upper layers (UDP, ICMP) in the IP
    * profile bucket. TCP will insert it's own nested profile calls 
    */
   IN_PROFILER(PF_IP, PF_ENTRY);
   p->fhost = pip->ip_src;
 8243658:	e0bffe17 	ldw	r2,-8(fp)
 824365c:	10c00317 	ldw	r3,12(r2)
 8243660:	e0bfff17 	ldw	r2,-4(fp)
 8243664:	10c00715 	stw	r3,28(r2)

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8243668:	d0a08317 	ldw	r2,-32244(gp)
 824366c:	1081000c 	andi	r2,r2,1024
 8243670:	10002126 	beq	r2,zero,82436f8 <ip_demux+0x120>
 8243674:	d0a08317 	ldw	r2,-32244(gp)
 8243678:	1080800c 	andi	r2,r2,512
 824367c:	10001e26 	beq	r2,zero,82436f8 <ip_demux+0x120>
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 8243680:	e0bffe17 	ldw	r2,-8(fp)
 8243684:	10800243 	ldbu	r2,9(r2)
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 8243688:	11003fcc 	andi	r4,r2,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 824368c:	e0bffe17 	ldw	r2,-8(fp)
 8243690:	10800317 	ldw	r2,12(r2)
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 8243694:	11403fcc 	andi	r5,r2,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 8243698:	e0bffe17 	ldw	r2,-8(fp)
 824369c:	10800317 	ldw	r2,12(r2)
 82436a0:	1004d23a 	srli	r2,r2,8
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 82436a4:	11803fcc 	andi	r6,r2,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 82436a8:	e0bffe17 	ldw	r2,-8(fp)
 82436ac:	10800317 	ldw	r2,12(r2)
 82436b0:	1004d43a 	srli	r2,r2,16
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 82436b4:	10803fcc 	andi	r2,r2,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 82436b8:	e0fffe17 	ldw	r3,-8(fp)
 82436bc:	18c00317 	ldw	r3,12(r3)
 82436c0:	1806d63a 	srli	r3,r3,24
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 82436c4:	d8c00115 	stw	r3,4(sp)
 82436c8:	d8800015 	stw	r2,0(sp)
 82436cc:	300f883a 	mov	r7,r6
 82436d0:	280d883a 	mov	r6,r5
 82436d4:	200b883a 	mov	r5,r4
 82436d8:	01020974 	movhi	r4,2085
 82436dc:	21058204 	addi	r4,r4,5640
 82436e0:	82033fc0 	call	82033fc <printf>
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
      if (NDEBUG & DUMP) ip_dump(p);
 82436e4:	d0a08317 	ldw	r2,-32244(gp)
 82436e8:	1080008c 	andi	r2,r2,2
 82436ec:	10000226 	beq	r2,zero,82436f8 <ip_demux+0x120>
 82436f0:	e13fff17 	ldw	r4,-4(fp)
 82436f4:	8240a9c0 	call	8240a9c <ip_dump>
   }
#endif

   switch (pip->ip_prot)
 82436f8:	e0bffe17 	ldw	r2,-8(fp)
 82436fc:	10800243 	ldbu	r2,9(r2)
 8243700:	10803fcc 	andi	r2,r2,255
 8243704:	10c000a0 	cmpeqi	r3,r2,2
 8243708:	18001f1e 	bne	r3,zero,8243788 <ip_demux+0x1b0>
 824370c:	10c000c8 	cmpgei	r3,r2,3
 8243710:	1800031e 	bne	r3,zero,8243720 <ip_demux+0x148>
 8243714:	10800060 	cmpeqi	r2,r2,1
 8243718:	1000101e 	bne	r2,zero,824375c <ip_demux+0x184>
 824371c:	00003006 	br	82437e0 <ip_demux+0x208>
 8243720:	10c001a0 	cmpeqi	r3,r2,6
 8243724:	1800231e 	bne	r3,zero,82437b4 <ip_demux+0x1dc>
 8243728:	10800460 	cmpeqi	r2,r2,17
 824372c:	10002c26 	beq	r2,zero,82437e0 <ip_demux+0x208>
   {
   case UDP_PROT:
      ip_mib.ipInDelivers++;
 8243730:	008209b4 	movhi	r2,2086
 8243734:	10ba8304 	addi	r2,r2,-5620
 8243738:	10800817 	ldw	r2,32(r2)
 824373c:	10c00044 	addi	r3,r2,1
 8243740:	008209b4 	movhi	r2,2086
 8243744:	10ba8304 	addi	r2,r2,-5620
 8243748:	10c00815 	stw	r3,32(r2)
      err = udpdemux(p);
 824374c:	e13fff17 	ldw	r4,-4(fp)
 8243750:	82448600 	call	8244860 <udpdemux>
 8243754:	e0bffd15 	stw	r2,-12(fp)
      break;
 8243758:	00002c06 	br	824380c <ip_demux+0x234>
   case ICMP_PROT:
      ip_mib.ipInDelivers++;
 824375c:	008209b4 	movhi	r2,2086
 8243760:	10ba8304 	addi	r2,r2,-5620
 8243764:	10800817 	ldw	r2,32(r2)
 8243768:	10c00044 	addi	r3,r2,1
 824376c:	008209b4 	movhi	r2,2086
 8243770:	10ba8304 	addi	r2,r2,-5620
 8243774:	10c00815 	stw	r3,32(r2)
      err = icmprcv(p);
 8243778:	e13fff17 	ldw	r4,-4(fp)
 824377c:	824a4bc0 	call	824a4bc <icmprcv>
 8243780:	e0bffd15 	stw	r2,-12(fp)
      break;
 8243784:	00002106 	br	824380c <ip_demux+0x234>
#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   case IGMP_PROT:
      ip_mib.ipInDelivers++;
 8243788:	008209b4 	movhi	r2,2086
 824378c:	10ba8304 	addi	r2,r2,-5620
 8243790:	10800817 	ldw	r2,32(r2)
 8243794:	10c00044 	addi	r3,r2,1
 8243798:	008209b4 	movhi	r2,2086
 824379c:	10ba8304 	addi	r2,r2,-5620
 82437a0:	10c00815 	stw	r3,32(r2)
      err = igmp_input(p);
 82437a4:	e13fff17 	ldw	r4,-4(fp)
 82437a8:	8226dec0 	call	8226dec <igmp_input>
 82437ac:	e0bffd15 	stw	r2,-12(fp)
      break;
 82437b0:	00001606 	br	824380c <ip_demux+0x234>
#endif   /* IP_MULTICAST and (IGMPv1 or IGMPv2) */
#ifdef INCLUDE_TCP
   case TCP_PROT:
      ip_mib.ipInDelivers++;
 82437b4:	008209b4 	movhi	r2,2086
 82437b8:	10ba8304 	addi	r2,r2,-5620
 82437bc:	10800817 	ldw	r2,32(r2)
 82437c0:	10c00044 	addi	r3,r2,1
 82437c4:	008209b4 	movhi	r2,2086
 82437c8:	10ba8304 	addi	r2,r2,-5620
 82437cc:	10c00815 	stw	r3,32(r2)
      err = tcp_rcv(p);
 82437d0:	e13fff17 	ldw	r4,-4(fp)
 82437d4:	822ee600 	call	822ee60 <tcp_rcv>
 82437d8:	e0bffd15 	stw	r2,-12(fp)
      break;
 82437dc:	00000b06 	br	824380c <ip_demux+0x234>
      err = v6t_rcv(p);
      break;
#endif /* IPV6_TUNNEL */
   default: /* unknown upper protocol */
#ifdef IP_RAW
      ip_mib.ipInDelivers++;
 82437e0:	008209b4 	movhi	r2,2086
 82437e4:	10ba8304 	addi	r2,r2,-5620
 82437e8:	10800817 	ldw	r2,32(r2)
 82437ec:	10c00044 	addi	r3,r2,1
 82437f0:	008209b4 	movhi	r2,2086
 82437f4:	10ba8304 	addi	r2,r2,-5620
 82437f8:	10c00815 	stw	r3,32(r2)
      err = ip_raw_input(p);
 82437fc:	e13fff17 	ldw	r4,-4(fp)
 8243800:	8243ed00 	call	8243ed0 <ip_raw_input>
 8243804:	e0bffd15 	stw	r2,-12(fp)
      break;
 8243808:	0001883a 	nop
#endif /* IP_RAW */
   }

   IN_PROFILER(PF_IP, PF_EXIT);

   if(err != ENP_PARAM)
 824380c:	e0bffd17 	ldw	r2,-12(fp)
 8243810:	10bffda0 	cmpeqi	r2,r2,-10
 8243814:	1000021e 	bne	r2,zero,8243820 <ip_demux+0x248>
   {
      return err;
 8243818:	e0bffd17 	ldw	r2,-12(fp)
 824381c:	00005e06 	br	8243998 <ip_demux+0x3c0>

#ifdef FULL_ICMP
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 8243820:	e0bffe17 	ldw	r2,-8(fp)
 8243824:	10800417 	ldw	r2,16(r2)
 8243828:	10bfffe0 	cmpeqi	r2,r2,-1
 824382c:	10004c1e 	bne	r2,zero,8243960 <ip_demux+0x388>
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
 8243830:	e0bffe17 	ldw	r2,-8(fp)
 8243834:	10800417 	ldw	r2,16(r2)
 8243838:	1006d63a 	srli	r3,r2,24
 824383c:	e0bffe17 	ldw	r2,-8(fp)
 8243840:	10800417 	ldw	r2,16(r2)
 8243844:	1004d23a 	srli	r2,r2,8
 8243848:	10bfc00c 	andi	r2,r2,65280
 824384c:	1886b03a 	or	r3,r3,r2
 8243850:	e0bffe17 	ldw	r2,-8(fp)
 8243854:	10800417 	ldw	r2,16(r2)
 8243858:	10bfc00c 	andi	r2,r2,65280
 824385c:	1004923a 	slli	r2,r2,8
 8243860:	1886b03a 	or	r3,r3,r2
 8243864:	e0bffe17 	ldw	r2,-8(fp)
 8243868:	10800417 	ldw	r2,16(r2)
 824386c:	1004963a 	slli	r2,r2,24
 8243870:	1884b03a 	or	r2,r3,r2
 8243874:	10fc002c 	andhi	r3,r2,61440

#ifdef FULL_ICMP
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 8243878:	00b80034 	movhi	r2,57344
 824387c:	18803826 	beq	r3,r2,8243960 <ip_demux+0x388>
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
 8243880:	e0bffe17 	ldw	r2,-8(fp)
 8243884:	10c00417 	ldw	r3,16(r2)
 8243888:	e0bfff17 	ldw	r2,-4(fp)
 824388c:	10800617 	ldw	r2,24(r2)
 8243890:	10800e17 	ldw	r2,56(r2)
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
 8243894:	18803226 	beq	r3,r2,8243960 <ip_demux+0x388>
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
 8243898:	e0bffe17 	ldw	r2,-8(fp)
 824389c:	10c00417 	ldw	r3,16(r2)
 82438a0:	e0bfff17 	ldw	r2,-4(fp)
 82438a4:	10800617 	ldw	r2,24(r2)
 82438a8:	10800f17 	ldw	r2,60(r2)
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
 82438ac:	18802c26 	beq	r3,r2,8243960 <ip_demux+0x388>
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
 82438b0:	e0bffe17 	ldw	r2,-8(fp)
 82438b4:	10c00417 	ldw	r3,16(r2)
 82438b8:	e0bfff17 	ldw	r2,-4(fp)
 82438bc:	10800617 	ldw	r2,24(r2)
 82438c0:	10801017 	ldw	r2,64(r2)
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
 82438c4:	18802626 	beq	r3,r2,8243960 <ip_demux+0x388>
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
       (p->net->n_ipaddr ^ p->net->n_subnetbr))  /* Know our own host address? */
 82438c8:	e0bfff17 	ldw	r2,-4(fp)
 82438cc:	10800617 	ldw	r2,24(r2)
 82438d0:	10c00a17 	ldw	r3,40(r2)
 82438d4:	e0bfff17 	ldw	r2,-4(fp)
 82438d8:	10800617 	ldw	r2,24(r2)
 82438dc:	10801017 	ldw	r2,64(r2)
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
 82438e0:	18801f26 	beq	r3,r2,8243960 <ip_demux+0x388>
       (p->net->n_ipaddr ^ p->net->n_subnetbr))  /* Know our own host address? */
   {

#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 82438e4:	d0a08317 	ldw	r2,-32244(gp)
 82438e8:	1081000c 	andi	r2,r2,1024
 82438ec:	10000f26 	beq	r2,zero,824392c <ip_demux+0x354>
 82438f0:	d0a08317 	ldw	r2,-32244(gp)
 82438f4:	1080800c 	andi	r2,r2,512
 82438f8:	10000c26 	beq	r2,zero,824392c <ip_demux+0x354>
      {
         dprintf("ip_demux: unhandled prot %u\n", pip->ip_prot);
 82438fc:	e0bffe17 	ldw	r2,-8(fp)
 8243900:	10800243 	ldbu	r2,9(r2)
 8243904:	10803fcc 	andi	r2,r2,255
 8243908:	100b883a 	mov	r5,r2
 824390c:	01020974 	movhi	r4,2085
 8243910:	21058c04 	addi	r4,r4,5680
 8243914:	82033fc0 	call	82033fc <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 8243918:	d0a08317 	ldw	r2,-32244(gp)
 824391c:	1080008c 	andi	r2,r2,2
 8243920:	10000226 	beq	r2,zero,824392c <ip_demux+0x354>
 8243924:	e13fff17 	ldw	r4,-4(fp)
 8243928:	8240a9c0 	call	8240a9c <ip_dump>
      }
#endif   /* NPDEBUG */
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTPROT, p->net);
 824392c:	e0bffe17 	ldw	r2,-8(fp)
 8243930:	10c00317 	ldw	r3,12(r2)
 8243934:	e0bfff17 	ldw	r2,-4(fp)
 8243938:	10800617 	ldw	r2,24(r2)
 824393c:	11000a17 	ldw	r4,40(r2)
 8243940:	e0bfff17 	ldw	r2,-4(fp)
 8243944:	10800617 	ldw	r2,24(r2)
 8243948:	d8800015 	stw	r2,0(sp)
 824394c:	01c00084 	movi	r7,2
 8243950:	e1bffe17 	ldw	r6,-8(fp)
 8243954:	200b883a 	mov	r5,r4
 8243958:	1809883a 	mov	r4,r3
 824395c:	824b0200 	call	824b020 <icmp_destun>
   }
#endif   /* FULL_ICMP */

   ip_mib.ipUnknownProtos++;
 8243960:	008209b4 	movhi	r2,2086
 8243964:	10ba8304 	addi	r2,r2,-5620
 8243968:	10800617 	ldw	r2,24(r2)
 824396c:	10c00044 	addi	r3,r2,1
 8243970:	008209b4 	movhi	r2,2086
 8243974:	10ba8304 	addi	r2,r2,-5620
 8243978:	10c00615 	stw	r3,24(r2)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 824397c:	01000084 	movi	r4,2
 8243980:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   pk_free(p);
 8243984:	e13fff17 	ldw	r4,-4(fp)
 8243988:	822cd980 	call	822cd98 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824398c:	01000084 	movi	r4,2
 8243990:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   return ENP_NOT_MINE;
 8243994:	00800084 	movi	r2,2
}
 8243998:	e037883a 	mov	sp,fp
 824399c:	dfc00117 	ldw	ra,4(sp)
 82439a0:	df000017 	ldw	fp,0(sp)
 82439a4:	dec00204 	addi	sp,sp,8
 82439a8:	f800283a 	ret

082439ac <in_addmulti>:
 * RETURNS: 
 */

struct in_multi * 
in_addmulti(ip_addr *ap, struct net *netp, int addrtype)
{
 82439ac:	defff904 	addi	sp,sp,-28
 82439b0:	dfc00615 	stw	ra,24(sp)
 82439b4:	df000515 	stw	fp,20(sp)
 82439b8:	df000504 	addi	fp,sp,20
 82439bc:	e13ffd15 	stw	r4,-12(fp)
 82439c0:	e17ffe15 	stw	r5,-8(fp)
 82439c4:	e1bfff15 	stw	r6,-4(fp)
   struct in_multi *inm = (struct in_multi *)NULL;
 82439c8:	e03ffb15 	stw	zero,-20(fp)
   int error;

   /* check for good addr. */
   if ((ap == (ip_addr *)NULL) || (*ap == 0))
 82439cc:	e0bffd17 	ldw	r2,-12(fp)
 82439d0:	10000326 	beq	r2,zero,82439e0 <in_addmulti+0x34>
 82439d4:	e0bffd17 	ldw	r2,-12(fp)
 82439d8:	10800017 	ldw	r2,0(r2)
 82439dc:	1000021e 	bne	r2,zero,82439e8 <in_addmulti+0x3c>
      return ((struct in_multi *)NULL);  
 82439e0:	0005883a 	mov	r2,zero
 82439e4:	00003f06 	br	8243ae4 <in_addmulti+0x138>

   ENTER_CRIT_SECTION(netp);
 82439e8:	822d7c80 	call	822d7c8 <irq_Mask>
#ifdef IP_V6
   if(addrtype == 6)
      inm = v6_lookup_mcast((ip6_addr*)ap, netp);
#endif
#ifdef IP_V4
   if(addrtype != 6)
 82439ec:	e0bfff17 	ldw	r2,-4(fp)
 82439f0:	108001a0 	cmpeqi	r2,r2,6
 82439f4:	1000061e 	bne	r2,zero,8243a10 <in_addmulti+0x64>
      inm = lookup_mcast(*ap, netp);
 82439f8:	e0bffd17 	ldw	r2,-12(fp)
 82439fc:	10800017 	ldw	r2,0(r2)
 8243a00:	e17ffe17 	ldw	r5,-8(fp)
 8243a04:	1009883a 	mov	r4,r2
 8243a08:	8243c040 	call	8243c04 <lookup_mcast>
 8243a0c:	e0bffb15 	stw	r2,-20(fp)
#endif

   if (inm != (struct in_multi *)NULL) 
 8243a10:	e0bffb17 	ldw	r2,-20(fp)
 8243a14:	10000626 	beq	r2,zero,8243a30 <in_addmulti+0x84>
   {
      /* Found it; just increment the reference count. */
      ++inm->inm_refcount;
 8243a18:	e0bffb17 	ldw	r2,-20(fp)
 8243a1c:	10800217 	ldw	r2,8(r2)
 8243a20:	10c00044 	addi	r3,r2,1
 8243a24:	e0bffb17 	ldw	r2,-20(fp)
 8243a28:	10c00215 	stw	r3,8(r2)
 8243a2c:	00002b06 	br	8243adc <in_addmulti+0x130>
   {
      /*
       * New address; allocate a new multicast record
       * and link it into the interface's multicast list.
       */
      inm = (struct in_multi *)INM_ALLOC(sizeof(*inm));
 8243a30:	01000604 	movi	r4,24
 8243a34:	822e1c80 	call	822e1c8 <npalloc>
 8243a38:	e0bffb15 	stw	r2,-20(fp)

      if (inm == (struct in_multi *)NULL) 
 8243a3c:	e0bffb17 	ldw	r2,-20(fp)
 8243a40:	1000031e 	bne	r2,zero,8243a50 <in_addmulti+0xa4>
      {
         EXIT_CRIT_SECTION(netp);
 8243a44:	822d8280 	call	822d828 <irq_Unmask>
         return ((struct in_multi *)NULL);
 8243a48:	0005883a 	mov	r2,zero
 8243a4c:	00002506 	br	8243ae4 <in_addmulti+0x138>
#ifdef IP_V6
      if(addrtype == 6)
         IP6CPY(&inm->ip6addr, (struct in6_addr *)ap);
#endif
#ifdef IP_V4
      if(addrtype != 6)
 8243a50:	e0bfff17 	ldw	r2,-4(fp)
 8243a54:	108001a0 	cmpeqi	r2,r2,6
 8243a58:	1000041e 	bne	r2,zero,8243a6c <in_addmulti+0xc0>
         inm->inm_addr = *ap;
 8243a5c:	e0bffd17 	ldw	r2,-12(fp)
 8243a60:	10c00017 	ldw	r3,0(r2)
 8243a64:	e0bffb17 	ldw	r2,-20(fp)
 8243a68:	10c00015 	stw	r3,0(r2)
#endif
      inm->inm_netp = netp;
 8243a6c:	e0bffb17 	ldw	r2,-20(fp)
 8243a70:	e0fffe17 	ldw	r3,-8(fp)
 8243a74:	10c00115 	stw	r3,4(r2)
      inm->inm_refcount = 1;
 8243a78:	e0bffb17 	ldw	r2,-20(fp)
 8243a7c:	00c00044 	movi	r3,1
 8243a80:	10c00215 	stw	r3,8(r2)
      inm->inm_next = netp->mc_list;
 8243a84:	e0bffe17 	ldw	r2,-8(fp)
 8243a88:	10c02c17 	ldw	r3,176(r2)
 8243a8c:	e0bffb17 	ldw	r2,-20(fp)
 8243a90:	10c00515 	stw	r3,20(r2)
      netp->mc_list = inm;
 8243a94:	e0bffe17 	ldw	r2,-8(fp)
 8243a98:	e0fffb17 	ldw	r3,-20(fp)
 8243a9c:	10c02c15 	stw	r3,176(r2)
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the new address.
       */
      if(netp->n_mcastlist)
 8243aa0:	e0bffe17 	ldw	r2,-8(fp)
 8243aa4:	10802b17 	ldw	r2,172(r2)
 8243aa8:	10000626 	beq	r2,zero,8243ac4 <in_addmulti+0x118>
         error = netp->n_mcastlist(inm);
 8243aac:	e0bffe17 	ldw	r2,-8(fp)
 8243ab0:	10802b17 	ldw	r2,172(r2)
 8243ab4:	e13ffb17 	ldw	r4,-20(fp)
 8243ab8:	103ee83a 	callr	r2
 8243abc:	e0bffc15 	stw	r2,-16(fp)
 8243ac0:	00000106 	br	8243ac8 <in_addmulti+0x11c>
      else
         error = 0;
 8243ac4:	e03ffc15 	stw	zero,-16(fp)
#if defined (IGMP_V1) || defined (IGMP_V2)
      /*
       * Let IGMP know that we have joined a new IP multicast group.
       */
      if (inm->inm_addr) igmp_joingroup(inm);
 8243ac8:	e0bffb17 	ldw	r2,-20(fp)
 8243acc:	10800017 	ldw	r2,0(r2)
 8243ad0:	10000226 	beq	r2,zero,8243adc <in_addmulti+0x130>
 8243ad4:	e13ffb17 	ldw	r4,-20(fp)
 8243ad8:	82272dc0 	call	82272dc <igmp_joingroup>
#endif      
   }

   EXIT_CRIT_SECTION(netp);
 8243adc:	822d8280 	call	822d828 <irq_Unmask>
   USE_ARG(error);

   return (inm);
 8243ae0:	e0bffb17 	ldw	r2,-20(fp)
}
 8243ae4:	e037883a 	mov	sp,fp
 8243ae8:	dfc00117 	ldw	ra,4(sp)
 8243aec:	df000017 	ldw	fp,0(sp)
 8243af0:	dec00204 	addi	sp,sp,8
 8243af4:	f800283a 	ret

08243af8 <in_delmulti>:
 * RETURNS: 
 */

void
in_delmulti(struct in_multi * inm)
{
 8243af8:	defffa04 	addi	sp,sp,-24
 8243afc:	dfc00515 	stw	ra,20(sp)
 8243b00:	df000415 	stw	fp,16(sp)
 8243b04:	df000404 	addi	fp,sp,16
 8243b08:	e13fff15 	stw	r4,-4(fp)
   struct in_multi * p;
   NET         netp = inm->inm_netp;
 8243b0c:	e0bfff17 	ldw	r2,-4(fp)
 8243b10:	10800117 	ldw	r2,4(r2)
 8243b14:	e0bffe15 	stw	r2,-8(fp)
   int error;

   ENTER_CRIT_SECTION(inm);
 8243b18:	822d7c80 	call	822d7c8 <irq_Mask>
   if (--inm->inm_refcount == 0) 
 8243b1c:	e0bfff17 	ldw	r2,-4(fp)
 8243b20:	10800217 	ldw	r2,8(r2)
 8243b24:	10ffffc4 	addi	r3,r2,-1
 8243b28:	e0bfff17 	ldw	r2,-4(fp)
 8243b2c:	10c00215 	stw	r3,8(r2)
 8243b30:	e0bfff17 	ldw	r2,-4(fp)
 8243b34:	10800217 	ldw	r2,8(r2)
 8243b38:	10002b1e 	bne	r2,zero,8243be8 <in_delmulti+0xf0>
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 8243b3c:	e0bffe17 	ldw	r2,-8(fp)
 8243b40:	10802c17 	ldw	r2,176(r2)
 8243b44:	e0bffc15 	stw	r2,-16(fp)
 8243b48:	00001406 	br	8243b9c <in_delmulti+0xa4>
      {
         if(p == inm)   /* inm is first in mc_list */
 8243b4c:	e0fffc17 	ldw	r3,-16(fp)
 8243b50:	e0bfff17 	ldw	r2,-4(fp)
 8243b54:	1880051e 	bne	r3,r2,8243b6c <in_delmulti+0x74>
         {
            netp->mc_list = p->inm_next;  /* unlink */
 8243b58:	e0bffc17 	ldw	r2,-16(fp)
 8243b5c:	10c00517 	ldw	r3,20(r2)
 8243b60:	e0bffe17 	ldw	r2,-8(fp)
 8243b64:	10c02c15 	stw	r3,176(r2)
            break;
 8243b68:	00000e06 	br	8243ba4 <in_delmulti+0xac>
         }
         else if(p->inm_next == inm)   /* inm is next */
 8243b6c:	e0bffc17 	ldw	r2,-16(fp)
 8243b70:	10c00517 	ldw	r3,20(r2)
 8243b74:	e0bfff17 	ldw	r2,-4(fp)
 8243b78:	1880051e 	bne	r3,r2,8243b90 <in_delmulti+0x98>
         {
            p->inm_next = inm->inm_next;  /* unlink */
 8243b7c:	e0bfff17 	ldw	r2,-4(fp)
 8243b80:	10c00517 	ldw	r3,20(r2)
 8243b84:	e0bffc17 	ldw	r2,-16(fp)
 8243b88:	10c00515 	stw	r3,20(r2)
            break;
 8243b8c:	00000506 	br	8243ba4 <in_delmulti+0xac>

   ENTER_CRIT_SECTION(inm);
   if (--inm->inm_refcount == 0) 
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 8243b90:	e0bffc17 	ldw	r2,-16(fp)
 8243b94:	10800517 	ldw	r2,20(r2)
 8243b98:	e0bffc15 	stw	r2,-16(fp)
 8243b9c:	e0bffc17 	ldw	r2,-16(fp)
 8243ba0:	103fea1e 	bne	r2,zero,8243b4c <in_delmulti+0x54>
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the deleted address.
       */
      if(netp->n_mcastlist)
 8243ba4:	e0bffe17 	ldw	r2,-8(fp)
 8243ba8:	10802b17 	ldw	r2,172(r2)
 8243bac:	10000626 	beq	r2,zero,8243bc8 <in_delmulti+0xd0>
         error = netp->n_mcastlist(inm);
 8243bb0:	e0bffe17 	ldw	r2,-8(fp)
 8243bb4:	10802b17 	ldw	r2,172(r2)
 8243bb8:	e13fff17 	ldw	r4,-4(fp)
 8243bbc:	103ee83a 	callr	r2
 8243bc0:	e0bffd15 	stw	r2,-12(fp)
 8243bc4:	00000106 	br	8243bcc <in_delmulti+0xd4>
      else
         error = 0;
 8243bc8:	e03ffd15 	stw	zero,-12(fp)
#if defined (IGMP_V2)
      /*
       * No remaining claims to this record; let IGMP know that
       * we are leaving the multicast group.
       */
      if (inm->inm_addr) igmp_leavegroup(inm);
 8243bcc:	e0bfff17 	ldw	r2,-4(fp)
 8243bd0:	10800017 	ldw	r2,0(r2)
 8243bd4:	10000226 	beq	r2,zero,8243be0 <in_delmulti+0xe8>
 8243bd8:	e13fff17 	ldw	r4,-4(fp)
 8243bdc:	82275300 	call	8227530 <igmp_leavegroup>
#endif      

      IM_FREE(inm);
 8243be0:	e13fff17 	ldw	r4,-4(fp)
 8243be4:	822e1fc0 	call	822e1fc <npfree>
   }

   EXIT_CRIT_SECTION(inm);
 8243be8:	822d8280 	call	822d828 <irq_Unmask>
   USE_ARG(error);
}
 8243bec:	0001883a 	nop
 8243bf0:	e037883a 	mov	sp,fp
 8243bf4:	dfc00117 	ldw	ra,4(sp)
 8243bf8:	df000017 	ldw	fp,0(sp)
 8243bfc:	dec00204 	addi	sp,sp,8
 8243c00:	f800283a 	ret

08243c04 <lookup_mcast>:
 * RETURNS: pointer to mcast addr structure, or NULL if not found.
 */

struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
 8243c04:	defffc04 	addi	sp,sp,-16
 8243c08:	df000315 	stw	fp,12(sp)
 8243c0c:	df000304 	addi	fp,sp,12
 8243c10:	e13ffe15 	stw	r4,-8(fp)
 8243c14:	e17fff15 	stw	r5,-4(fp)
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 8243c18:	e0bfff17 	ldw	r2,-4(fp)
 8243c1c:	10802c17 	ldw	r2,176(r2)
 8243c20:	e0bffd15 	stw	r2,-12(fp)
 8243c24:	00000906 	br	8243c4c <lookup_mcast+0x48>
   {
      if(imp->inm_addr == addr)
 8243c28:	e0bffd17 	ldw	r2,-12(fp)
 8243c2c:	10c00017 	ldw	r3,0(r2)
 8243c30:	e0bffe17 	ldw	r2,-8(fp)
 8243c34:	1880021e 	bne	r3,r2,8243c40 <lookup_mcast+0x3c>
         return imp;
 8243c38:	e0bffd17 	ldw	r2,-12(fp)
 8243c3c:	00000606 	br	8243c58 <lookup_mcast+0x54>
struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 8243c40:	e0bffd17 	ldw	r2,-12(fp)
 8243c44:	10800517 	ldw	r2,20(r2)
 8243c48:	e0bffd15 	stw	r2,-12(fp)
 8243c4c:	e0bffd17 	ldw	r2,-12(fp)
 8243c50:	103ff51e 	bne	r2,zero,8243c28 <lookup_mcast+0x24>
   {
      if(imp->inm_addr == addr)
         return imp;
   }
   return NULL;   /* addr not found in mcast list */
 8243c54:	0005883a 	mov	r2,zero
}
 8243c58:	e037883a 	mov	sp,fp
 8243c5c:	df000017 	ldw	fp,0(sp)
 8243c60:	dec00104 	addi	sp,sp,4
 8243c64:	f800283a 	ret

08243c68 <prep_ifaces>:
 * passed value. 
 */

int
prep_ifaces(int ifaces_found)
{
 8243c68:	defffd04 	addi	sp,sp,-12
 8243c6c:	dfc00215 	stw	ra,8(sp)
 8243c70:	df000115 	stw	fp,4(sp)
 8243c74:	df000104 	addi	fp,sp,4
 8243c78:	e13fff15 	stw	r4,-4(fp)
   if (port_prep)
 8243c7c:	d0a0ca17 	ldw	r2,-31960(gp)
 8243c80:	10000426 	beq	r2,zero,8243c94 <prep_ifaces+0x2c>
      ifaces_found = port_prep(ifaces_found);
 8243c84:	d0a0ca17 	ldw	r2,-31960(gp)
 8243c88:	e13fff17 	ldw	r4,-4(fp)
 8243c8c:	103ee83a 	callr	r2
 8243c90:	e0bfff15 	stw	r2,-4(fp)

#ifdef MAC_LOOPBACK
   ifaces_found = prep_lb(ifaces_found);
#endif   /* MAC_LOOPBACK */

   ifNumber = ifaces_found;   /* set global interface counter */
 8243c94:	e0bfff17 	ldw	r2,-4(fp)
 8243c98:	d0a08415 	stw	r2,-32240(gp)

   initmsg("prepped %u interface%s, initializing...\n", 
 8243c9c:	e0bfff17 	ldw	r2,-4(fp)
 8243ca0:	10800058 	cmpnei	r2,r2,1
 8243ca4:	1000031e 	bne	r2,zero,8243cb4 <prep_ifaces+0x4c>
 8243ca8:	00820974 	movhi	r2,2085
 8243cac:	10859404 	addi	r2,r2,5712
 8243cb0:	00000206 	br	8243cbc <prep_ifaces+0x54>
 8243cb4:	00820974 	movhi	r2,2085
 8243cb8:	10859504 	addi	r2,r2,5716
 8243cbc:	100d883a 	mov	r6,r2
 8243cc0:	e17fff17 	ldw	r5,-4(fp)
 8243cc4:	01020974 	movhi	r4,2085
 8243cc8:	21059604 	addi	r4,r4,5720
 8243ccc:	82033fc0 	call	82033fc <printf>
      ifaces_found, ifaces_found==1?"":"s");

   return ifaces_found;
 8243cd0:	e0bfff17 	ldw	r2,-4(fp)
}
 8243cd4:	e037883a 	mov	sp,fp
 8243cd8:	dfc00117 	ldw	ra,4(sp)
 8243cdc:	df000017 	ldw	fp,0(sp)
 8243ce0:	dec00204 	addi	sp,sp,8
 8243ce4:	f800283a 	ret

08243ce8 <netexit>:
 * RETURNS: SHould not return
 */

void
netexit(int err)      /* exit error level */
{
 8243ce8:	defffd04 	addi	sp,sp,-12
 8243cec:	dfc00215 	stw	ra,8(sp)
 8243cf0:	df000115 	stw	fp,4(sp)
 8243cf4:	df000104 	addi	fp,sp,4
 8243cf8:	e13fff15 	stw	r4,-4(fp)
   net_system_exit = TRUE; /* set flag for shutting down */
 8243cfc:	00800044 	movi	r2,1
 8243d00:	d0a0cb15 	stw	r2,-31956(gp)
   ip_exit();  /* do the exit_hook()ed stuff */
 8243d04:	8226bf40 	call	8226bf4 <ip_exit>

   PORT_EXIT_FUNC(err);    /* should not return! */
 8243d08:	e13fff17 	ldw	r4,-4(fp)
 8243d0c:	824b6b40 	call	824b6b4 <exit>

08243d10 <evtmap_setup>:
 * INPUT: None.
 * OUTPUT: None
 */
 
void evtmap_setup (void)
{
 8243d10:	deffff04 	addi	sp,sp,-4
 8243d14:	df000015 	stw	fp,0(sp)
 8243d18:	d839883a 	mov	fp,sp
#ifdef SOCK_MAP_EVENTS
   so_evtmap = TRUE;
   so_evtmap_create = evtmap_create;
   so_evtmap_delete = evtmap_delete;
#else
   so_evtmap = FALSE;
 8243d1c:	d020ce05 	stb	zero,-31944(gp)
   so_evtmap_create = 0;
 8243d20:	d020cc15 	stw	zero,-31952(gp)
   so_evtmap_delete = 0;
 8243d24:	d020cd15 	stw	zero,-31948(gp)
#endif   /* SOCK_MAP_EVENTS */ 

}
 8243d28:	0001883a 	nop
 8243d2c:	e037883a 	mov	sp,fp
 8243d30:	df000017 	ldw	fp,0(sp)
 8243d34:	dec00104 	addi	sp,sp,4
 8243d38:	f800283a 	ret

08243d3c <ip_raw_open>:
ip_raw_open(u_char prot,
            ip_addr laddr,
            ip_addr faddr,
            int (*handler)(PACKET, void *),
            void * data)
{
 8243d3c:	defff904 	addi	sp,sp,-28
 8243d40:	dfc00615 	stw	ra,24(sp)
 8243d44:	df000515 	stw	fp,20(sp)
 8243d48:	df000504 	addi	fp,sp,20
 8243d4c:	2005883a 	mov	r2,r4
 8243d50:	e17ffd15 	stw	r5,-12(fp)
 8243d54:	e1bffe15 	stw	r6,-8(fp)
 8243d58:	e1ffff15 	stw	r7,-4(fp)
 8243d5c:	e0bffc05 	stb	r2,-16(fp)
   struct ipraw_ep * ep;

   LOCK_NET_RESOURCE(NET_RESID);
 8243d60:	0009883a 	mov	r4,zero
 8243d64:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>

   /* allocate a structure for the endpoint */
   ep = (struct ipraw_ep *)IEP_ALLOC(sizeof(struct ipraw_ep));
 8243d68:	01000604 	movi	r4,24
 8243d6c:	822e1c80 	call	822e1c8 <npalloc>
 8243d70:	e0bffb15 	stw	r2,-20(fp)
   if (ep == NULL)
 8243d74:	e0bffb17 	ldw	r2,-20(fp)
 8243d78:	10000a1e 	bne	r2,zero,8243da4 <ip_raw_open+0x68>
   {
#ifdef NPDEBUG
      if (NDEBUG & INFOMSG)
 8243d7c:	d0a08317 	ldw	r2,-32244(gp)
 8243d80:	1080010c 	andi	r2,r2,4
 8243d84:	10000326 	beq	r2,zero,8243d94 <ip_raw_open+0x58>
         dprintf("IP: Couldn't allocate ep storage.\n");
 8243d88:	01020974 	movhi	r4,2085
 8243d8c:	2105a104 	addi	r4,r4,5764
 8243d90:	82036800 	call	8203680 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 8243d94:	0009883a 	mov	r4,zero
 8243d98:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return ep;
 8243d9c:	e0bffb17 	ldw	r2,-20(fp)
 8243da0:	00001706 	br	8243e00 <ip_raw_open+0xc4>
   }

   /* fill it in with the caller's requested binding */
   ep->ipr_laddr = laddr;
 8243da4:	e0bffb17 	ldw	r2,-20(fp)
 8243da8:	e0fffd17 	ldw	r3,-12(fp)
 8243dac:	10c00115 	stw	r3,4(r2)
   ep->ipr_faddr = faddr;
 8243db0:	e0bffb17 	ldw	r2,-20(fp)
 8243db4:	e0fffe17 	ldw	r3,-8(fp)
 8243db8:	10c00215 	stw	r3,8(r2)
   ep->ipr_prot = prot;
 8243dbc:	e0bffb17 	ldw	r2,-20(fp)
 8243dc0:	e0fffc03 	ldbu	r3,-16(fp)
 8243dc4:	10c00505 	stb	r3,20(r2)
   ep->ipr_rcv = handler;
 8243dc8:	e0bffb17 	ldw	r2,-20(fp)
 8243dcc:	e0ffff17 	ldw	r3,-4(fp)
 8243dd0:	10c00315 	stw	r3,12(r2)
   ep->ipr_data = data;
 8243dd4:	e0bffb17 	ldw	r2,-20(fp)
 8243dd8:	e0c00217 	ldw	r3,8(fp)
 8243ddc:	10c00415 	stw	r3,16(r2)

   /* link it into the list 
    * (at the head, because that's simple and fast) 
    */
   ep->ipr_next = ipraw_eps;
 8243de0:	d0e0cf17 	ldw	r3,-31940(gp)
 8243de4:	e0bffb17 	ldw	r2,-20(fp)
 8243de8:	10c00015 	stw	r3,0(r2)
   ipraw_eps = ep;
 8243dec:	e0bffb17 	ldw	r2,-20(fp)
 8243df0:	d0a0cf15 	stw	r2,-31940(gp)

   /* and return the pointer to the endpoint */
   UNLOCK_NET_RESOURCE(NET_RESID);
 8243df4:	0009883a 	mov	r4,zero
 8243df8:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   return ep;
 8243dfc:	e0bffb17 	ldw	r2,-20(fp)
}
 8243e00:	e037883a 	mov	sp,fp
 8243e04:	dfc00117 	ldw	ra,4(sp)
 8243e08:	df000017 	ldw	fp,0(sp)
 8243e0c:	dec00204 	addi	sp,sp,8
 8243e10:	f800283a 	ret

08243e14 <ip_raw_close>:
 *                               that is to be closed
 * RETURNS: void
 */
void
ip_raw_close(struct ipraw_ep * ep)
{
 8243e14:	defffb04 	addi	sp,sp,-20
 8243e18:	dfc00415 	stw	ra,16(sp)
 8243e1c:	df000315 	stw	fp,12(sp)
 8243e20:	df000304 	addi	fp,sp,12
 8243e24:	e13fff15 	stw	r4,-4(fp)
   struct ipraw_ep * prev_ep;
   struct ipraw_ep * curr_ep;

   LOCK_NET_RESOURCE(NET_RESID);
 8243e28:	0009883a 	mov	r4,zero
 8243e2c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
 8243e30:	e03ffd15 	stw	zero,-12(fp)
 8243e34:	d0a0cf17 	ldw	r2,-31940(gp)
 8243e38:	e0bffe15 	stw	r2,-8(fp)
 8243e3c:	00000806 	br	8243e60 <ip_raw_close+0x4c>
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
   {
      if (curr_ep == ep)
 8243e40:	e0fffe17 	ldw	r3,-8(fp)
 8243e44:	e0bfff17 	ldw	r2,-4(fp)
 8243e48:	18800826 	beq	r3,r2,8243e6c <ip_raw_close+0x58>
         break;
      prev_ep = curr_ep;
 8243e4c:	e0bffe17 	ldw	r2,-8(fp)
 8243e50:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
 8243e54:	e0bffe17 	ldw	r2,-8(fp)
 8243e58:	10800017 	ldw	r2,0(r2)
 8243e5c:	e0bffe15 	stw	r2,-8(fp)
   struct ipraw_ep * curr_ep;

   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
 8243e60:	e0bffe17 	ldw	r2,-8(fp)
 8243e64:	103ff61e 	bne	r2,zero,8243e40 <ip_raw_close+0x2c>
 8243e68:	00000106 	br	8243e70 <ip_raw_close+0x5c>
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
   {
      if (curr_ep == ep)
         break;
 8243e6c:	0001883a 	nop
      prev_ep = curr_ep;
   }

   /* if we didn't find it, we can't close it, so just return */
   if (curr_ep == NULL)
 8243e70:	e0bffe17 	ldw	r2,-8(fp)
 8243e74:	1000041e 	bne	r2,zero,8243e88 <ip_raw_close+0x74>
   {
#ifdef NPDEBUG
      /* caller passed pointer to endpoint not in list 
       * -- not fatal, but may be programming error
       */
      dtrap();
 8243e78:	822d5f00 	call	822d5f0 <dtrap>
#endif /* NPDEBUG */
      UNLOCK_NET_RESOURCE(NET_RESID);
 8243e7c:	0009883a 	mov	r4,zero
 8243e80:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return;
 8243e84:	00000d06 	br	8243ebc <ip_raw_close+0xa8>
   }

   /* unlink it from the list */
   if (prev_ep)
 8243e88:	e0bffd17 	ldw	r2,-12(fp)
 8243e8c:	10000426 	beq	r2,zero,8243ea0 <ip_raw_close+0x8c>
      prev_ep = curr_ep->ipr_next;
 8243e90:	e0bffe17 	ldw	r2,-8(fp)
 8243e94:	10800017 	ldw	r2,0(r2)
 8243e98:	e0bffd15 	stw	r2,-12(fp)
 8243e9c:	00000306 	br	8243eac <ip_raw_close+0x98>
   else
      ipraw_eps = curr_ep->ipr_next;
 8243ea0:	e0bffe17 	ldw	r2,-8(fp)
 8243ea4:	10800017 	ldw	r2,0(r2)
 8243ea8:	d0a0cf15 	stw	r2,-31940(gp)

   /* free its storage */
   IEP_FREE(curr_ep);
 8243eac:	e13ffe17 	ldw	r4,-8(fp)
 8243eb0:	822e1fc0 	call	822e1fc <npfree>

   /* and return */
   UNLOCK_NET_RESOURCE(NET_RESID);
 8243eb4:	0009883a 	mov	r4,zero
 8243eb8:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
}
 8243ebc:	e037883a 	mov	sp,fp
 8243ec0:	dfc00117 	ldw	ra,4(sp)
 8243ec4:	df000017 	ldw	fp,0(sp)
 8243ec8:	dec00204 	addi	sp,sp,8
 8243ecc:	f800283a 	ret

08243ed0 <ip_raw_input>:
 *          freed); else an error code indicating that the
 *          received packet was not accepted/processed
 */
int
ip_raw_input(PACKET p)
{
 8243ed0:	defff604 	addi	sp,sp,-40
 8243ed4:	dfc00915 	stw	ra,36(sp)
 8243ed8:	df000815 	stw	fp,32(sp)
 8243edc:	df000804 	addi	fp,sp,32
 8243ee0:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;              /* the internet header */
   struct ipraw_ep * ep;
   struct ipraw_ep * next_ep;
   struct ipraw_ep * matched_ep = NULL;
 8243ee4:	e03ff915 	stw	zero,-28(fp)
   int err;
   int delivered;

   /* start out expecting to not deliver the packet */
   delivered = 0;
 8243ee8:	e03ffb15 	stw	zero,-20(fp)

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);
 8243eec:	e0bfff17 	ldw	r2,-4(fp)
 8243ef0:	10800317 	ldw	r2,12(r2)
 8243ef4:	e0bffc15 	stw	r2,-16(fp)

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 8243ef8:	d0a0cf17 	ldw	r2,-31940(gp)
 8243efc:	e0bff815 	stw	r2,-32(fp)
 8243f00:	00004c06 	br	8244034 <ip_raw_input+0x164>
   {
      /* keep track of next endpoint -- defense against upcall
       * function closing its own endpoint
       */
      next_ep = ep->ipr_next;
 8243f04:	e0bff817 	ldw	r2,-32(fp)
 8243f08:	10800017 	ldw	r2,0(r2)
 8243f0c:	e0bffd15 	stw	r2,-12(fp)

      /* if this packet doesn't match the endpoint's filters (IP
       * protocol ID, locally-bound address, connected-peer address)
       * then skip ahead to next endpoint
       */
      if (ep->ipr_prot && ep->ipr_prot != pip->ip_prot)
 8243f10:	e0bff817 	ldw	r2,-32(fp)
 8243f14:	10800503 	ldbu	r2,20(r2)
 8243f18:	10803fcc 	andi	r2,r2,255
 8243f1c:	10000726 	beq	r2,zero,8243f3c <ip_raw_input+0x6c>
 8243f20:	e0bff817 	ldw	r2,-32(fp)
 8243f24:	10c00503 	ldbu	r3,20(r2)
 8243f28:	e0bffc17 	ldw	r2,-16(fp)
 8243f2c:	10800243 	ldbu	r2,9(r2)
 8243f30:	18c03fcc 	andi	r3,r3,255
 8243f34:	10803fcc 	andi	r2,r2,255
 8243f38:	1880371e 	bne	r3,r2,8244018 <ip_raw_input+0x148>
         continue;
      if (ep->ipr_laddr && ep->ipr_laddr != pip->ip_dest)
 8243f3c:	e0bff817 	ldw	r2,-32(fp)
 8243f40:	10800117 	ldw	r2,4(r2)
 8243f44:	10000526 	beq	r2,zero,8243f5c <ip_raw_input+0x8c>
 8243f48:	e0bff817 	ldw	r2,-32(fp)
 8243f4c:	10c00117 	ldw	r3,4(r2)
 8243f50:	e0bffc17 	ldw	r2,-16(fp)
 8243f54:	10800417 	ldw	r2,16(r2)
 8243f58:	1880311e 	bne	r3,r2,8244020 <ip_raw_input+0x150>
         continue;
      if (ep->ipr_faddr && ep->ipr_faddr != pip->ip_src)
 8243f5c:	e0bff817 	ldw	r2,-32(fp)
 8243f60:	10800217 	ldw	r2,8(r2)
 8243f64:	10000526 	beq	r2,zero,8243f7c <ip_raw_input+0xac>
 8243f68:	e0bff817 	ldw	r2,-32(fp)
 8243f6c:	10c00217 	ldw	r3,8(r2)
 8243f70:	e0bffc17 	ldw	r2,-16(fp)
 8243f74:	10800317 	ldw	r2,12(r2)
 8243f78:	18802b1e 	bne	r3,r2,8244028 <ip_raw_input+0x158>
         continue;

      /* if the endpoint has a receive upcall function, 
       * keep track of the endpoint
       */
      if (ep->ipr_rcv != NULL)
 8243f7c:	e0bff817 	ldw	r2,-32(fp)
 8243f80:	10800317 	ldw	r2,12(r2)
 8243f84:	10002926 	beq	r2,zero,824402c <ip_raw_input+0x15c>
          * copy the packet into a new buffer,
          * and pass the new copy to the previously matched 
          * endpoint's upcall function 
          * before we forget the previous endpoint
          */
         if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 8243f88:	e0bff917 	ldw	r2,-28(fp)
 8243f8c:	10001f26 	beq	r2,zero,824400c <ip_raw_input+0x13c>
 8243f90:	e0bff917 	ldw	r2,-28(fp)
 8243f94:	10800317 	ldw	r2,12(r2)
 8243f98:	10001c26 	beq	r2,zero,824400c <ip_raw_input+0x13c>
         {
            PACKET p2;

            p2 = ip_copypkt(p);
 8243f9c:	e13fff17 	ldw	r4,-4(fp)
 8243fa0:	8240f1c0 	call	8240f1c <ip_copypkt>
 8243fa4:	e0bffe15 	stw	r2,-8(fp)
            if (p2)
 8243fa8:	e0bffe17 	ldw	r2,-8(fp)
 8243fac:	10001726 	beq	r2,zero,824400c <ip_raw_input+0x13c>
            {
               UNLOCK_NET_RESOURCE(NET_RESID);
 8243fb0:	0009883a 	mov	r4,zero
 8243fb4:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
               err = ((*matched_ep->ipr_rcv)(p2, matched_ep->ipr_data));
 8243fb8:	e0bff917 	ldw	r2,-28(fp)
 8243fbc:	10800317 	ldw	r2,12(r2)
 8243fc0:	e0fff917 	ldw	r3,-28(fp)
 8243fc4:	18c00417 	ldw	r3,16(r3)
 8243fc8:	180b883a 	mov	r5,r3
 8243fcc:	e13ffe17 	ldw	r4,-8(fp)
 8243fd0:	103ee83a 	callr	r2
 8243fd4:	e0bffa15 	stw	r2,-24(fp)
               LOCK_NET_RESOURCE(NET_RESID);
 8243fd8:	0009883a 	mov	r4,zero
 8243fdc:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
               if (err)
 8243fe0:	e0bffa17 	ldw	r2,-24(fp)
 8243fe4:	10000726 	beq	r2,zero,8244004 <ip_raw_input+0x134>
               {
                  LOCK_NET_RESOURCE(FREEQ_RESID);
 8243fe8:	01000084 	movi	r4,2
 8243fec:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
                  pk_free(p2);
 8243ff0:	e13ffe17 	ldw	r4,-8(fp)
 8243ff4:	822cd980 	call	822cd98 <pk_free>
                  UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8243ff8:	01000084 	movi	r4,2
 8243ffc:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
 8244000:	00000206 	br	824400c <ip_raw_input+0x13c>
               }
               else
                  delivered = 1;
 8244004:	00800044 	movi	r2,1
 8244008:	e0bffb15 	stw	r2,-20(fp)
            }
         }
         matched_ep = ep;
 824400c:	e0bff817 	ldw	r2,-32(fp)
 8244010:	e0bff915 	stw	r2,-28(fp)
 8244014:	00000506 	br	824402c <ip_raw_input+0x15c>
      /* if this packet doesn't match the endpoint's filters (IP
       * protocol ID, locally-bound address, connected-peer address)
       * then skip ahead to next endpoint
       */
      if (ep->ipr_prot && ep->ipr_prot != pip->ip_prot)
         continue;
 8244018:	0001883a 	nop
 824401c:	00000306 	br	824402c <ip_raw_input+0x15c>
      if (ep->ipr_laddr && ep->ipr_laddr != pip->ip_dest)
         continue;
 8244020:	0001883a 	nop
 8244024:	00000106 	br	824402c <ip_raw_input+0x15c>
      if (ep->ipr_faddr && ep->ipr_faddr != pip->ip_src)
         continue;
 8244028:	0001883a 	nop

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 824402c:	e0bffd17 	ldw	r2,-12(fp)
 8244030:	e0bff815 	stw	r2,-32(fp)
 8244034:	e0bff817 	ldw	r2,-32(fp)
 8244038:	103fb21e 	bne	r2,zero,8243f04 <ip_raw_input+0x34>
   /* if we matched an endpoint, 
    * pass the packet to its upcall function
    * otherwise, return ENP_PARAM to indicate that the
    * packet was not processed and freed
    */
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 824403c:	e0bff917 	ldw	r2,-28(fp)
 8244040:	10001426 	beq	r2,zero,8244094 <ip_raw_input+0x1c4>
 8244044:	e0bff917 	ldw	r2,-28(fp)
 8244048:	10800317 	ldw	r2,12(r2)
 824404c:	10001126 	beq	r2,zero,8244094 <ip_raw_input+0x1c4>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 8244050:	0009883a 	mov	r4,zero
 8244054:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      err = ((*matched_ep->ipr_rcv)(p, matched_ep->ipr_data));
 8244058:	e0bff917 	ldw	r2,-28(fp)
 824405c:	10800317 	ldw	r2,12(r2)
 8244060:	e0fff917 	ldw	r3,-28(fp)
 8244064:	18c00417 	ldw	r3,16(r3)
 8244068:	180b883a 	mov	r5,r3
 824406c:	e13fff17 	ldw	r4,-4(fp)
 8244070:	103ee83a 	callr	r2
 8244074:	e0bffa15 	stw	r2,-24(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 8244078:	0009883a 	mov	r4,zero
 824407c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      if (err == 0)
 8244080:	e0bffa17 	ldw	r2,-24(fp)
 8244084:	10000c1e 	bne	r2,zero,82440b8 <ip_raw_input+0x1e8>
         delivered = 1;
 8244088:	00800044 	movi	r2,1
 824408c:	e0bffb15 	stw	r2,-20(fp)
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
      err = ((*matched_ep->ipr_rcv)(p, matched_ep->ipr_data));
      LOCK_NET_RESOURCE(NET_RESID);
      if (err == 0)
 8244090:	00000906 	br	82440b8 <ip_raw_input+0x1e8>
         delivered = 1;
   }
   else
   {
      err = ENP_PARAM;
 8244094:	00bffd84 	movi	r2,-10
 8244098:	e0bffa15 	stw	r2,-24(fp)
      ip_mib.ipUnknownProtos++;
 824409c:	008209b4 	movhi	r2,2086
 82440a0:	10ba8304 	addi	r2,r2,-5620
 82440a4:	10800617 	ldw	r2,24(r2)
 82440a8:	10c00044 	addi	r3,r2,1
 82440ac:	008209b4 	movhi	r2,2086
 82440b0:	10ba8304 	addi	r2,r2,-5620
 82440b4:	10c00615 	stw	r3,24(r2)
   }

   if (!delivered)
 82440b8:	e0bffb17 	ldw	r2,-20(fp)
 82440bc:	1000071e 	bne	r2,zero,82440dc <ip_raw_input+0x20c>
      ip_mib.ipInDelivers--;
 82440c0:	008209b4 	movhi	r2,2086
 82440c4:	10ba8304 	addi	r2,r2,-5620
 82440c8:	10800817 	ldw	r2,32(r2)
 82440cc:	10ffffc4 	addi	r3,r2,-1
 82440d0:	008209b4 	movhi	r2,2086
 82440d4:	10ba8304 	addi	r2,r2,-5620
 82440d8:	10c00815 	stw	r3,32(r2)

   return err;
 82440dc:	e0bffa17 	ldw	r2,-24(fp)
}
 82440e0:	e037883a 	mov	sp,fp
 82440e4:	dfc00117 	ldw	ra,4(sp)
 82440e8:	df000017 	ldw	fp,0(sp)
 82440ec:	dec00204 	addi	sp,sp,8
 82440f0:	f800283a 	ret

082440f4 <ip_raw_alloc>:
 *          inclhdr is zero.
 */

PACKET
ip_raw_alloc(int reqlen, int hdrincl)
{
 82440f4:	defffa04 	addi	sp,sp,-24
 82440f8:	dfc00515 	stw	ra,20(sp)
 82440fc:	df000415 	stw	fp,16(sp)
 8244100:	df000404 	addi	fp,sp,16
 8244104:	e13ffe15 	stw	r4,-8(fp)
 8244108:	e17fff15 	stw	r5,-4(fp)
   int len;
   PACKET p;

   len = (reqlen + 1) & ~1;
 824410c:	e0bffe17 	ldw	r2,-8(fp)
 8244110:	10c00044 	addi	r3,r2,1
 8244114:	00bfff84 	movi	r2,-2
 8244118:	1884703a 	and	r2,r3,r2
 824411c:	e0bffc15 	stw	r2,-16(fp)
   if (!hdrincl)
 8244120:	e0bfff17 	ldw	r2,-4(fp)
 8244124:	1000031e 	bne	r2,zero,8244134 <ip_raw_alloc+0x40>
      len += IPHSIZ;
 8244128:	e0bffc17 	ldw	r2,-16(fp)
 824412c:	10800504 	addi	r2,r2,20
 8244130:	e0bffc15 	stw	r2,-16(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8244134:	01000084 	movi	r4,2
 8244138:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   p = pk_alloc(len + MaxLnh);
 824413c:	d0e08117 	ldw	r3,-32252(gp)
 8244140:	e0bffc17 	ldw	r2,-16(fp)
 8244144:	1885883a 	add	r2,r3,r2
 8244148:	1009883a 	mov	r4,r2
 824414c:	822ca480 	call	822ca48 <pk_alloc>
 8244150:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8244154:	01000084 	movi	r4,2
 8244158:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   if (p)
 824415c:	e0bffd17 	ldw	r2,-12(fp)
 8244160:	10000c26 	beq	r2,zero,8244194 <ip_raw_alloc+0xa0>
   {
      if (!hdrincl)
 8244164:	e0bfff17 	ldw	r2,-4(fp)
 8244168:	10000a1e 	bne	r2,zero,8244194 <ip_raw_alloc+0xa0>
      {
         p->nb_prot += IPHSIZ;
 824416c:	e0bffd17 	ldw	r2,-12(fp)
 8244170:	10800317 	ldw	r2,12(r2)
 8244174:	10c00504 	addi	r3,r2,20
 8244178:	e0bffd17 	ldw	r2,-12(fp)
 824417c:	10c00315 	stw	r3,12(r2)
         p->nb_plen -= IPHSIZ;
 8244180:	e0bffd17 	ldw	r2,-12(fp)
 8244184:	10800417 	ldw	r2,16(r2)
 8244188:	10fffb04 	addi	r3,r2,-20
 824418c:	e0bffd17 	ldw	r2,-12(fp)
 8244190:	10c00415 	stw	r3,16(r2)
      }
   }
   return p;
 8244194:	e0bffd17 	ldw	r2,-12(fp)
}
 8244198:	e037883a 	mov	sp,fp
 824419c:	dfc00117 	ldw	ra,4(sp)
 82441a0:	df000017 	ldw	fp,0(sp)
 82441a4:	dec00204 	addi	sp,sp,8
 82441a8:	f800283a 	ret

082441ac <ip_raw_free>:
 * RETURNS: void
 */

void
ip_raw_free(PACKET p)
{
 82441ac:	defffd04 	addi	sp,sp,-12
 82441b0:	dfc00215 	stw	ra,8(sp)
 82441b4:	df000115 	stw	fp,4(sp)
 82441b8:	df000104 	addi	fp,sp,4
 82441bc:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 82441c0:	01000084 	movi	r4,2
 82441c4:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   pk_free(p);
 82441c8:	e13fff17 	ldw	r4,-4(fp)
 82441cc:	822cd980 	call	822cd98 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82441d0:	01000084 	movi	r4,2
 82441d4:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
}
 82441d8:	0001883a 	nop
 82441dc:	e037883a 	mov	sp,fp
 82441e0:	dfc00117 	ldw	ra,4(sp)
 82441e4:	df000017 	ldw	fp,0(sp)
 82441e8:	dec00204 	addi	sp,sp,8
 82441ec:	f800283a 	ret

082441f0 <ip_raw_maxalloc>:
 *          for 
 */

int
ip_raw_maxalloc(int hdrincl)
{
 82441f0:	defffd04 	addi	sp,sp,-12
 82441f4:	df000215 	stw	fp,8(sp)
 82441f8:	df000204 	addi	fp,sp,8
 82441fc:	e13fff15 	stw	r4,-4(fp)
   int len;

   len = bigbufsiz - MaxLnh;
 8244200:	d0a03917 	ldw	r2,-32540(gp)
 8244204:	d0e08117 	ldw	r3,-32252(gp)
 8244208:	10c5c83a 	sub	r2,r2,r3
 824420c:	e0bffe15 	stw	r2,-8(fp)
   if (!hdrincl)
 8244210:	e0bfff17 	ldw	r2,-4(fp)
 8244214:	1000031e 	bne	r2,zero,8244224 <ip_raw_maxalloc+0x34>
      len -= IPHSIZ;
 8244218:	e0bffe17 	ldw	r2,-8(fp)
 824421c:	10bffb04 	addi	r2,r2,-20
 8244220:	e0bffe15 	stw	r2,-8(fp)
   return len;
 8244224:	e0bffe17 	ldw	r2,-8(fp)
}
 8244228:	e037883a 	mov	sp,fp
 824422c:	df000017 	ldw	fp,0(sp)
 8244230:	dec00104 	addi	sp,sp,4
 8244234:	f800283a 	ret

08244238 <rt_lookup>:
 * entry was found.
 */

RTMIB
rt_lookup(ip_addr host)
{
 8244238:	defff804 	addi	sp,sp,-32
 824423c:	df000715 	stw	fp,28(sp)
 8244240:	df000704 	addi	fp,sp,28
 8244244:	e13fff15 	stw	r4,-4(fp)
   RTMIB    rtp;
   RTMIB    netmatch;
   unsigned char max_bits_matched = 0;
 8244248:	e03ffb05 	stb	zero,-20(fp)
   unsigned char curr_bits_matched;
   ip_addr  entry_mask;
   unsigned long int bitcount_mask;
   unsigned long int extracted_bit;

   netmatch = NULL;
 824424c:	e03ffa15 	stw	zero,-24(fp)

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 8244250:	d0a0c617 	ldw	r2,-31976(gp)
 8244254:	e0bff915 	stw	r2,-28(fp)
 8244258:	00003a06 	br	8244344 <rt_lookup+0x10c>
   {
      if (rtp->ipRouteNextHop == 0L)   /* skip over empty entries */
 824425c:	e0bff917 	ldw	r2,-28(fp)
 8244260:	10800617 	ldw	r2,24(r2)
 8244264:	10003326 	beq	r2,zero,8244334 <rt_lookup+0xfc>
#ifdef RIP_SUPPORT
      /* skip RIP private entries */
      if (rtp->ipRouteFlags & RIP_PRIVATE)
         continue;
#endif
      entry_mask = rtp->ipRouteMask;
 8244268:	e0bff917 	ldw	r2,-28(fp)
 824426c:	10800a17 	ldw	r2,40(r2)
 8244270:	e0bffd15 	stw	r2,-12(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
 8244274:	e0bff917 	ldw	r2,-28(fp)
 8244278:	10c00017 	ldw	r3,0(r2)
 824427c:	e0bfff17 	ldw	r2,-4(fp)
 8244280:	1886f03a 	xor	r3,r3,r2
 8244284:	e0bffd17 	ldw	r2,-12(fp)
 8244288:	1884703a 	and	r2,r3,r2
 824428c:	10002a1e 	bne	r2,zero,8244338 <rt_lookup+0x100>
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 8244290:	e03ffb45 	stb	zero,-19(fp)
 8244294:	00a00034 	movhi	r2,32768
 8244298:	e0bffc15 	stw	r2,-16(fp)
 824429c:	00001806 	br	8244300 <rt_lookup+0xc8>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
 82442a0:	e0bffd17 	ldw	r2,-12(fp)
 82442a4:	1006d63a 	srli	r3,r2,24
 82442a8:	e0bffd17 	ldw	r2,-12(fp)
 82442ac:	1004d23a 	srli	r2,r2,8
 82442b0:	10bfc00c 	andi	r2,r2,65280
 82442b4:	1886b03a 	or	r3,r3,r2
 82442b8:	e0bffd17 	ldw	r2,-12(fp)
 82442bc:	10bfc00c 	andi	r2,r2,65280
 82442c0:	1004923a 	slli	r2,r2,8
 82442c4:	1886b03a 	or	r3,r3,r2
 82442c8:	e0bffd17 	ldw	r2,-12(fp)
 82442cc:	1004963a 	slli	r2,r2,24
 82442d0:	1886b03a 	or	r3,r3,r2
 82442d4:	e0bffc17 	ldw	r2,-16(fp)
 82442d8:	1884703a 	and	r2,r3,r2
 82442dc:	e0bffe15 	stw	r2,-8(fp)
            if (extracted_bit) ++curr_bits_matched;
 82442e0:	e0bffe17 	ldw	r2,-8(fp)
 82442e4:	10000326 	beq	r2,zero,82442f4 <rt_lookup+0xbc>
 82442e8:	e0bffb43 	ldbu	r2,-19(fp)
 82442ec:	10800044 	addi	r2,r2,1
 82442f0:	e0bffb45 	stb	r2,-19(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 82442f4:	e0bffc17 	ldw	r2,-16(fp)
 82442f8:	1004d07a 	srli	r2,r2,1
 82442fc:	e0bffc15 	stw	r2,-16(fp)
 8244300:	e0bffc17 	ldw	r2,-16(fp)
 8244304:	103fe61e 	bne	r2,zero,82442a0 <rt_lookup+0x68>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
            if (extracted_bit) ++curr_bits_matched;
         }
         if (curr_bits_matched > max_bits_matched)
 8244308:	e0bffb43 	ldbu	r2,-19(fp)
 824430c:	e0fffb03 	ldbu	r3,-20(fp)
 8244310:	1880092e 	bgeu	r3,r2,8244338 <rt_lookup+0x100>
         {
            /* save a pointer to the best match */
            max_bits_matched = curr_bits_matched;
 8244314:	e0bffb43 	ldbu	r2,-19(fp)
 8244318:	e0bffb05 	stb	r2,-20(fp)
            netmatch = rtp;
 824431c:	e0bff917 	ldw	r2,-28(fp)
 8244320:	e0bffa15 	stw	r2,-24(fp)
            /* if all 32 bits match, stop searching the route table */
            if (max_bits_matched == 32)
 8244324:	e0bffb03 	ldbu	r2,-20(fp)
 8244328:	10800818 	cmpnei	r2,r2,32
 824432c:	10000c26 	beq	r2,zero,8244360 <rt_lookup+0x128>
 8244330:	00000106 	br	8244338 <rt_lookup+0x100>

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
   {
      if (rtp->ipRouteNextHop == 0L)   /* skip over empty entries */
         continue;
 8244334:	0001883a 	nop
   unsigned long int extracted_bit;

   netmatch = NULL;

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 8244338:	e0bff917 	ldw	r2,-28(fp)
 824433c:	10800f04 	addi	r2,r2,60
 8244340:	e0bff915 	stw	r2,-28(fp)
 8244344:	d0e0c617 	ldw	r3,-31976(gp)
 8244348:	d0a05117 	ldw	r2,-32444(gp)
 824434c:	10800f24 	muli	r2,r2,60
 8244350:	1885883a 	add	r2,r3,r2
 8244354:	e0fff917 	ldw	r3,-28(fp)
 8244358:	18bfc036 	bltu	r3,r2,824425c <rt_lookup+0x24>
 824435c:	00000106 	br	8244364 <rt_lookup+0x12c>
            /* save a pointer to the best match */
            max_bits_matched = curr_bits_matched;
            netmatch = rtp;
            /* if all 32 bits match, stop searching the route table */
            if (max_bits_matched == 32)
               break;
 8244360:	0001883a 	nop
         }
      }
   }

   if (netmatch)
 8244364:	e0bffa17 	ldw	r2,-24(fp)
 8244368:	10000326 	beq	r2,zero,8244378 <rt_lookup+0x140>
      netmatch->ipRouteAge = cticks;   /* timestamp entry we used */
 824436c:	d0e0a817 	ldw	r3,-32096(gp)
 8244370:	e0bffa17 	ldw	r2,-24(fp)
 8244374:	10c00915 	stw	r3,36(r2)

   return netmatch;
 8244378:	e0bffa17 	ldw	r2,-24(fp)
}
 824437c:	e037883a 	mov	sp,fp
 8244380:	df000017 	ldw	fp,0(sp)
 8244384:	dec00104 	addi	sp,sp,4
 8244388:	f800283a 	ret

0824438c <add_route>:
   ip_addr  dest,       /* ultimate destination */
   ip_addr  mask,       /* net mask, 0xFFFFFFFF if dest is host address */
   ip_addr  nexthop,    /* where to forward to */
   int      iface,      /* interface (net) for nexthop */
   int      prot)       /* how we know it: icmp, table, etc */
{
 824438c:	defff704 	addi	sp,sp,-36
 8244390:	dfc00815 	stw	ra,32(sp)
 8244394:	df000715 	stw	fp,28(sp)
 8244398:	df000704 	addi	fp,sp,28
 824439c:	e13ffc15 	stw	r4,-16(fp)
 82443a0:	e17ffd15 	stw	r5,-12(fp)
 82443a4:	e1bffe15 	stw	r6,-8(fp)
 82443a8:	e1ffff15 	stw	r7,-4(fp)
   RTMIB rtp;           /* scratch route table entrry pointer */
   RTMIB newrt;         /* best entry for new route */
   struct net * ifp;    /* interface (net) for nexthop */

   newrt = NULL;     /* may be replaced with empty or more expendable entry */
 82443ac:	e03ffa15 	stw	zero,-24(fp)
					 
   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   ifp = if_getbynum(iface);
 82443b0:	e13fff17 	ldw	r4,-4(fp)
 82443b4:	823eda40 	call	823eda4 <if_getbynum>
 82443b8:	e0bffb15 	stw	r2,-20(fp)
   if(!ifp)
 82443bc:	e0bffb17 	ldw	r2,-20(fp)
 82443c0:	1000021e 	bne	r2,zero,82443cc <add_route+0x40>
      return NULL;
 82443c4:	0005883a 	mov	r2,zero
 82443c8:	0000db06 	br	8244738 <add_route+0x3ac>

   if (rt_mib == NULL)
 82443cc:	d0a0c617 	ldw	r2,-31976(gp)
 82443d0:	1000021e 	bne	r2,zero,82443dc <add_route+0x50>
      return NULL;
 82443d4:	0005883a 	mov	r2,zero
 82443d8:	0000d706 	br	8244738 <add_route+0x3ac>

   /* Don't add null masks or IP addresses - they give false positives on
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
 82443dc:	e0bffc17 	ldw	r2,-16(fp)
 82443e0:	10000226 	beq	r2,zero,82443ec <add_route+0x60>
 82443e4:	e0bffd17 	ldw	r2,-12(fp)
 82443e8:	1000221e 	bne	r2,zero,8244474 <add_route+0xe8>
   {
      dtrap();    /* bad configuration? */
 82443ec:	822d5f00 	call	822d5f0 <dtrap>
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
	      htonl(dest), htonl(mask) );
 82443f0:	e0bffc17 	ldw	r2,-16(fp)
 82443f4:	1006d63a 	srli	r3,r2,24
 82443f8:	e0bffc17 	ldw	r2,-16(fp)
 82443fc:	1004d23a 	srli	r2,r2,8
 8244400:	10bfc00c 	andi	r2,r2,65280
 8244404:	1886b03a 	or	r3,r3,r2
 8244408:	e0bffc17 	ldw	r2,-16(fp)
 824440c:	10bfc00c 	andi	r2,r2,65280
 8244410:	1004923a 	slli	r2,r2,8
 8244414:	1886b03a 	or	r3,r3,r2
 8244418:	e0bffc17 	ldw	r2,-16(fp)
 824441c:	1004963a 	slli	r2,r2,24
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
   {
      dtrap();    /* bad configuration? */
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
 8244420:	1888b03a 	or	r4,r3,r2
	      htonl(dest), htonl(mask) );
 8244424:	e0bffd17 	ldw	r2,-12(fp)
 8244428:	1006d63a 	srli	r3,r2,24
 824442c:	e0bffd17 	ldw	r2,-12(fp)
 8244430:	1004d23a 	srli	r2,r2,8
 8244434:	10bfc00c 	andi	r2,r2,65280
 8244438:	1886b03a 	or	r3,r3,r2
 824443c:	e0bffd17 	ldw	r2,-12(fp)
 8244440:	10bfc00c 	andi	r2,r2,65280
 8244444:	1004923a 	slli	r2,r2,8
 8244448:	1886b03a 	or	r3,r3,r2
 824444c:	e0bffd17 	ldw	r2,-12(fp)
 8244450:	1004963a 	slli	r2,r2,24
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
   {
      dtrap();    /* bad configuration? */
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
 8244454:	1884b03a 	or	r2,r3,r2
 8244458:	100d883a 	mov	r6,r2
 824445c:	200b883a 	mov	r5,r4
 8244460:	01020974 	movhi	r4,2085
 8244464:	2105aa04 	addi	r4,r4,5800
 8244468:	82033fc0 	call	82033fc <printf>
	      htonl(dest), htonl(mask) );
      return NULL;
 824446c:	0005883a 	mov	r2,zero
 8244470:	0000b106 	br	8244738 <add_route+0x3ac>
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 8244474:	d0a0c617 	ldw	r2,-31976(gp)
 8244478:	e0bff915 	stw	r2,-28(fp)
 824447c:	00006a06 	br	8244628 <add_route+0x29c>
   {
      if (rtp->ipRouteDest == dest) /* found existing entry for target */
 8244480:	e0bff917 	ldw	r2,-28(fp)
 8244484:	10c00017 	ldw	r3,0(r2)
 8244488:	e0bffc17 	ldw	r2,-16(fp)
 824448c:	1880151e 	bne	r3,r2,82444e4 <add_route+0x158>
      {
         rtp->ipRouteNextHop = nexthop;      /* fix entry */
 8244490:	e0bff917 	ldw	r2,-28(fp)
 8244494:	e0fffe17 	ldw	r3,-8(fp)
 8244498:	10c00615 	stw	r3,24(r2)
         rtp->ipRouteAge = cticks;           /* timestamp it */
 824449c:	d0e0a817 	ldw	r3,-32096(gp)
 82444a0:	e0bff917 	ldw	r2,-28(fp)
 82444a4:	10c00915 	stw	r3,36(r2)
         /* set the rfc1213 1-based SNMP-ish interface index */
         rtp->ipRouteIfIndex = (long)(iface) + 1;
 82444a8:	e0bfff17 	ldw	r2,-4(fp)
 82444ac:	10c00044 	addi	r3,r2,1
 82444b0:	e0bff917 	ldw	r2,-28(fp)
 82444b4:	10c00115 	stw	r3,4(r2)
         rtp->ipRouteProto = prot;           /* icmp, or whatever */
 82444b8:	e0bff917 	ldw	r2,-28(fp)
 82444bc:	e0c00217 	ldw	r3,8(fp)
 82444c0:	10c00815 	stw	r3,32(r2)
         rtp->ipRouteMask = mask;
 82444c4:	e0bff917 	ldw	r2,-28(fp)
 82444c8:	e0fffd17 	ldw	r3,-12(fp)
 82444cc:	10c00a15 	stw	r3,40(r2)
         rtp->ifp = ifp;
 82444d0:	e0bff917 	ldw	r2,-28(fp)
 82444d4:	e0fffb17 	ldw	r3,-20(fp)
 82444d8:	10c00e15 	stw	r3,56(r2)
         return(rtp);   /* just update and exit */
 82444dc:	e0bff917 	ldw	r2,-28(fp)
 82444e0:	00009506 	br	8244738 <add_route+0x3ac>
      }
      /* if we didn't find empty slot yet, look for good slot to recycle */
      if (!newrt || (newrt->ipRouteProto != 0))
 82444e4:	e0bffa17 	ldw	r2,-24(fp)
 82444e8:	10000326 	beq	r2,zero,82444f8 <add_route+0x16c>
 82444ec:	e0bffa17 	ldw	r2,-24(fp)
 82444f0:	10800817 	ldw	r2,32(r2)
 82444f4:	10004926 	beq	r2,zero,824461c <add_route+0x290>
      {
         if (!rtp->ipRouteNextHop)  /* found empty slot for use */
 82444f8:	e0bff917 	ldw	r2,-28(fp)
 82444fc:	10800617 	ldw	r2,24(r2)
 8244500:	1000051e 	bne	r2,zero,8244518 <add_route+0x18c>
         {
            newrt = rtp;   /* record empty route for use */
 8244504:	e0bff917 	ldw	r2,-28(fp)
 8244508:	e0bffa15 	stw	r2,-24(fp)
            newrt->ipRouteProto = 0;
 824450c:	e0bffa17 	ldw	r2,-24(fp)
 8244510:	10000815 	stw	zero,32(r2)
            continue;
 8244514:	00004106 	br	824461c <add_route+0x290>
         }
         /* else see if the new route has higher priority than this slot: */
         if (rtp_priority[prot] >= rtp_priority[rtp->ipRouteProto])
 8244518:	00820974 	movhi	r2,2085
 824451c:	108f5b04 	addi	r2,r2,15724
 8244520:	e0c00217 	ldw	r3,8(fp)
 8244524:	10c5883a 	add	r2,r2,r3
 8244528:	11000003 	ldbu	r4,0(r2)
 824452c:	e0bff917 	ldw	r2,-28(fp)
 8244530:	10c00817 	ldw	r3,32(r2)
 8244534:	00820974 	movhi	r2,2085
 8244538:	108f5b04 	addi	r2,r2,15724
 824453c:	10c5883a 	add	r2,r2,r3
 8244540:	10800003 	ldbu	r2,0(r2)
 8244544:	20c03fcc 	andi	r3,r4,255
 8244548:	10803fcc 	andi	r2,r2,255
 824454c:	18803336 	bltu	r3,r2,824461c <add_route+0x290>
         {
            if (!newrt)
 8244550:	e0bffa17 	ldw	r2,-24(fp)
 8244554:	1000031e 	bne	r2,zero,8244564 <add_route+0x1d8>
            {
               newrt = rtp;
 8244558:	e0bff917 	ldw	r2,-28(fp)
 824455c:	e0bffa15 	stw	r2,-24(fp)
               continue;
 8244560:	00002e06 	br	824461c <add_route+0x290>
            }

            /* see if rtp is less important then newrtp */
            if (rtp_priority[rtp->ipRouteProto] < 
 8244564:	e0bff917 	ldw	r2,-28(fp)
 8244568:	10c00817 	ldw	r3,32(r2)
 824456c:	00820974 	movhi	r2,2085
 8244570:	108f5b04 	addi	r2,r2,15724
 8244574:	10c5883a 	add	r2,r2,r3
 8244578:	11000003 	ldbu	r4,0(r2)
                rtp_priority[newrt->ipRouteProto])
 824457c:	e0bffa17 	ldw	r2,-24(fp)
 8244580:	10c00817 	ldw	r3,32(r2)
 8244584:	00820974 	movhi	r2,2085
 8244588:	108f5b04 	addi	r2,r2,15724
 824458c:	10c5883a 	add	r2,r2,r3
 8244590:	10800003 	ldbu	r2,0(r2)
               newrt = rtp;
               continue;
            }

            /* see if rtp is less important then newrtp */
            if (rtp_priority[rtp->ipRouteProto] < 
 8244594:	20c03fcc 	andi	r3,r4,255
 8244598:	10803fcc 	andi	r2,r2,255
 824459c:	1880032e 	bgeu	r3,r2,82445ac <add_route+0x220>
                rtp_priority[newrt->ipRouteProto])
            {
               newrt = rtp;   /* save lower priority entry for recycle */
 82445a0:	e0bff917 	ldw	r2,-28(fp)
 82445a4:	e0bffa15 	stw	r2,-24(fp)
 82445a8:	00001c06 	br	824461c <add_route+0x290>
            }
            else if(rtp_priority[rtp->ipRouteProto] == 
 82445ac:	e0bff917 	ldw	r2,-28(fp)
 82445b0:	10c00817 	ldw	r3,32(r2)
 82445b4:	00820974 	movhi	r2,2085
 82445b8:	108f5b04 	addi	r2,r2,15724
 82445bc:	10c5883a 	add	r2,r2,r3
 82445c0:	11000003 	ldbu	r4,0(r2)
                rtp_priority[newrt->ipRouteProto])
 82445c4:	e0bffa17 	ldw	r2,-24(fp)
 82445c8:	10c00817 	ldw	r3,32(r2)
 82445cc:	00820974 	movhi	r2,2085
 82445d0:	108f5b04 	addi	r2,r2,15724
 82445d4:	10c5883a 	add	r2,r2,r3
 82445d8:	10800003 	ldbu	r2,0(r2)
            if (rtp_priority[rtp->ipRouteProto] < 
                rtp_priority[newrt->ipRouteProto])
            {
               newrt = rtp;   /* save lower priority entry for recycle */
            }
            else if(rtp_priority[rtp->ipRouteProto] == 
 82445dc:	20c03fcc 	andi	r3,r4,255
 82445e0:	10803fcc 	andi	r2,r2,255
 82445e4:	18800d1e 	bne	r3,r2,824461c <add_route+0x290>
                rtp_priority[newrt->ipRouteProto])
            {
               /* if equal priority, keep the older entry for deletion */
               if (c_older(rtp->ipRouteAge, newrt->ipRouteAge) == rtp->ipRouteAge)
 82445e8:	e0bff917 	ldw	r2,-28(fp)
 82445ec:	10c00917 	ldw	r3,36(r2)
 82445f0:	e0bffa17 	ldw	r2,-24(fp)
 82445f4:	10800917 	ldw	r2,36(r2)
 82445f8:	100b883a 	mov	r5,r2
 82445fc:	1809883a 	mov	r4,r3
 8244600:	82266c40 	call	82266c4 <c_older>
 8244604:	1007883a 	mov	r3,r2
 8244608:	e0bff917 	ldw	r2,-28(fp)
 824460c:	10800917 	ldw	r2,36(r2)
 8244610:	1880021e 	bne	r3,r2,824461c <add_route+0x290>
                  newrt = rtp;   /* got an older one */
 8244614:	e0bff917 	ldw	r2,-28(fp)
 8244618:	e0bffa15 	stw	r2,-24(fp)
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 824461c:	e0bff917 	ldw	r2,-28(fp)
 8244620:	10800f04 	addi	r2,r2,60
 8244624:	e0bff915 	stw	r2,-28(fp)
 8244628:	d0e0c617 	ldw	r3,-31976(gp)
 824462c:	d0a05117 	ldw	r2,-32444(gp)
 8244630:	10800f24 	muli	r2,r2,60
 8244634:	1885883a 	add	r2,r3,r2
 8244638:	e0fff917 	ldw	r3,-28(fp)
 824463c:	18bf9036 	bltu	r3,r2,8244480 <add_route+0xf4>
         }
      }
   }

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
 8244640:	e0bffa17 	ldw	r2,-24(fp)
 8244644:	10002926 	beq	r2,zero,82446ec <add_route+0x360>
      rtp = newrt;   /* create new entry in lowest priority slot */
 8244648:	e0bffa17 	ldw	r2,-24(fp)
 824464c:	e0bff915 	stw	r2,-28(fp)
   else  /* all slots have higher priority, new entry looses */
      return NULL;

   /* set default value in new route entry, caller can modiy further. */
   rtp->ifp = ifp;
 8244650:	e0bff917 	ldw	r2,-28(fp)
 8244654:	e0fffb17 	ldw	r3,-20(fp)
 8244658:	10c00e15 	stw	r3,56(r2)
   rtp->ipRouteDest = dest;
 824465c:	e0bff917 	ldw	r2,-28(fp)
 8244660:	e0fffc17 	ldw	r3,-16(fp)
 8244664:	10c00015 	stw	r3,0(r2)
   rtp->ipRouteIfIndex = (long)(if_netnumber(ifp)) + 1; /* set interface number */
 8244668:	e13ffb17 	ldw	r4,-20(fp)
 824466c:	8226cc40 	call	8226cc4 <if_netnumber>
 8244670:	10c00044 	addi	r3,r2,1
 8244674:	e0bff917 	ldw	r2,-28(fp)
 8244678:	10c00115 	stw	r3,4(r2)
   rtp->ipRouteMetric1 = ip_mib.ipDefaultTTL;
 824467c:	008209b4 	movhi	r2,2086
 8244680:	10ba8304 	addi	r2,r2,-5620
 8244684:	10800117 	ldw	r2,4(r2)
 8244688:	1007883a 	mov	r3,r2
 824468c:	e0bff917 	ldw	r2,-28(fp)
 8244690:	10c00215 	stw	r3,8(r2)
   rtp->ipRouteMetric2 = -1;
 8244694:	e0bff917 	ldw	r2,-28(fp)
 8244698:	00ffffc4 	movi	r3,-1
 824469c:	10c00315 	stw	r3,12(r2)
   rtp->ipRouteMetric3 = -1;
 82446a0:	e0bff917 	ldw	r2,-28(fp)
 82446a4:	00ffffc4 	movi	r3,-1
 82446a8:	10c00415 	stw	r3,16(r2)
   rtp->ipRouteMetric4 = -1;
 82446ac:	e0bff917 	ldw	r2,-28(fp)
 82446b0:	00ffffc4 	movi	r3,-1
 82446b4:	10c00515 	stw	r3,20(r2)
   rtp->ipRouteNextHop = nexthop;
 82446b8:	e0bff917 	ldw	r2,-28(fp)
 82446bc:	e0fffe17 	ldw	r3,-8(fp)
 82446c0:	10c00615 	stw	r3,24(r2)
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */
 82446c4:	e0bff917 	ldw	r2,-28(fp)
 82446c8:	e0c00217 	ldw	r3,8(fp)
 82446cc:	10c00815 	stw	r3,32(r2)

   if ((dest & mask) == (nexthop & mask))
 82446d0:	e0fffc17 	ldw	r3,-16(fp)
 82446d4:	e0bffe17 	ldw	r2,-8(fp)
 82446d8:	1886f03a 	xor	r3,r3,r2
 82446dc:	e0bffd17 	ldw	r2,-12(fp)
 82446e0:	1884703a 	and	r2,r3,r2
 82446e4:	1000071e 	bne	r2,zero,8244704 <add_route+0x378>
 82446e8:	00000206 	br	82446f4 <add_route+0x368>

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
      rtp = newrt;   /* create new entry in lowest priority slot */
   else  /* all slots have higher priority, new entry looses */
      return NULL;
 82446ec:	0005883a 	mov	r2,zero
 82446f0:	00001106 	br	8244738 <add_route+0x3ac>
   rtp->ipRouteMetric4 = -1;
   rtp->ipRouteNextHop = nexthop;
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */

   if ((dest & mask) == (nexthop & mask))
      rtp->ipRouteType = IPRT_DIRECT;
 82446f4:	e0bff917 	ldw	r2,-28(fp)
 82446f8:	00c000c4 	movi	r3,3
 82446fc:	10c00715 	stw	r3,28(r2)
 8244700:	00000306 	br	8244710 <add_route+0x384>
   else
      rtp->ipRouteType = IPRT_INDIRECT;
 8244704:	e0bff917 	ldw	r2,-28(fp)
 8244708:	00c00104 	movi	r3,4
 824470c:	10c00715 	stw	r3,28(r2)

   rtp->ipRouteAge = cticks;        /* timestamp it */
 8244710:	d0e0a817 	ldw	r3,-32096(gp)
 8244714:	e0bff917 	ldw	r2,-28(fp)
 8244718:	10c00915 	stw	r3,36(r2)
   rtp->ipRouteMask = mask;
 824471c:	e0bff917 	ldw	r2,-28(fp)
 8244720:	e0fffd17 	ldw	r3,-12(fp)
 8244724:	10c00a15 	stw	r3,40(r2)
   rtp->ipRouteMetric5 = -1;
 8244728:	e0bff917 	ldw	r2,-28(fp)
 824472c:	00ffffc4 	movi	r3,-1
 8244730:	10c00b15 	stw	r3,44(r2)
   return(rtp);
 8244734:	e0bff917 	ldw	r2,-28(fp)
}
 8244738:	e037883a 	mov	sp,fp
 824473c:	dfc00117 	ldw	ra,4(sp)
 8244740:	df000017 	ldw	fp,0(sp)
 8244744:	dec00204 	addi	sp,sp,8
 8244748:	f800283a 	ret

0824474c <del_route>:
 * RETURNS: Returns number of route table entries deleted. 
 */

int
del_route(ip_addr dest, ip_addr mask, int iface)
{
 824474c:	defff804 	addi	sp,sp,-32
 8244750:	dfc00715 	stw	ra,28(sp)
 8244754:	df000615 	stw	fp,24(sp)
 8244758:	df000604 	addi	fp,sp,24
 824475c:	e13ffd15 	stw	r4,-12(fp)
 8244760:	e17ffe15 	stw	r5,-8(fp)
 8244764:	e1bfff15 	stw	r6,-4(fp)
   RTMIB rtp;
   int   retval   =  0;
 8244768:	e03ffb15 	stw	zero,-20(fp)

   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   if(iface == -1)
 824476c:	e0bfff17 	ldw	r2,-4(fp)
 8244770:	10bfffd8 	cmpnei	r2,r2,-1
 8244774:	1000021e 	bne	r2,zero,8244780 <del_route+0x34>
      ifp = NULL;    /* wildcard */
 8244778:	e03ffc15 	stw	zero,-16(fp)
 824477c:	00000306 	br	824478c <del_route+0x40>
   else
      ifp = if_getbynum(iface);
 8244780:	e13fff17 	ldw	r4,-4(fp)
 8244784:	823eda40 	call	823eda4 <if_getbynum>
 8244788:	e0bffc15 	stw	r2,-16(fp)

   if (rt_mib == NULL)     /* Make sure we're up */
 824478c:	d0a0c617 	ldw	r2,-31976(gp)
 8244790:	1000021e 	bne	r2,zero,824479c <del_route+0x50>
      return 0;
 8244794:	0005883a 	mov	r2,zero
 8244798:	00002c06 	br	824484c <del_route+0x100>

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 824479c:	d0a0c617 	ldw	r2,-31976(gp)
 82447a0:	e0bffa15 	stw	r2,-24(fp)
 82447a4:	00002206 	br	8244830 <del_route+0xe4>
   {
      if (!rtp->ipRouteNextHop)  /* empty slot */
 82447a8:	e0bffa17 	ldw	r2,-24(fp)
 82447ac:	10800617 	ldw	r2,24(r2)
 82447b0:	10001926 	beq	r2,zero,8244818 <del_route+0xcc>
         continue;
      if(ifp != NULL && ifp != rtp->ifp)
 82447b4:	e0bffc17 	ldw	r2,-16(fp)
 82447b8:	10000426 	beq	r2,zero,82447cc <del_route+0x80>
 82447bc:	e0bffa17 	ldw	r2,-24(fp)
 82447c0:	10c00e17 	ldw	r3,56(r2)
 82447c4:	e0bffc17 	ldw	r2,-16(fp)
 82447c8:	1880151e 	bne	r3,r2,8244820 <del_route+0xd4>
         continue;   /* interface didn't match */
      if ((rtp->ipRouteDest & mask) == (dest & mask))
 82447cc:	e0bffa17 	ldw	r2,-24(fp)
 82447d0:	10c00017 	ldw	r3,0(r2)
 82447d4:	e0bffd17 	ldw	r2,-12(fp)
 82447d8:	1886f03a 	xor	r3,r3,r2
 82447dc:	e0bffe17 	ldw	r2,-8(fp)
 82447e0:	1884703a 	and	r2,r3,r2
 82447e4:	1000071e 	bne	r2,zero,8244804 <del_route+0xb8>
      {
         MEMSET(rtp, 0, sizeof(*rtp)); /* clear entry */
 82447e8:	01800f04 	movi	r6,60
 82447ec:	000b883a 	mov	r5,zero
 82447f0:	e13ffa17 	ldw	r4,-24(fp)
 82447f4:	82032100 	call	8203210 <memset>
         retval++;
 82447f8:	e0bffb17 	ldw	r2,-20(fp)
 82447fc:	10800044 	addi	r2,r2,1
 8244800:	e0bffb15 	stw	r2,-20(fp)
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
 8244804:	d0e0d017 	ldw	r3,-31936(gp)
 8244808:	e0bffa17 	ldw	r2,-24(fp)
 824480c:	1880051e 	bne	r3,r2,8244824 <del_route+0xd8>
         cachedRoute = NULL;
 8244810:	d020d015 	stw	zero,-31936(gp)
 8244814:	00000306 	br	8244824 <del_route+0xd8>
      return 0;

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
   {
      if (!rtp->ipRouteNextHop)  /* empty slot */
         continue;
 8244818:	0001883a 	nop
 824481c:	00000106 	br	8244824 <del_route+0xd8>
      if(ifp != NULL && ifp != rtp->ifp)
         continue;   /* interface didn't match */
 8244820:	0001883a 	nop
      ifp = if_getbynum(iface);

   if (rt_mib == NULL)     /* Make sure we're up */
      return 0;

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 8244824:	e0bffa17 	ldw	r2,-24(fp)
 8244828:	10800f04 	addi	r2,r2,60
 824482c:	e0bffa15 	stw	r2,-24(fp)
 8244830:	d0e0c617 	ldw	r3,-31976(gp)
 8244834:	d0a05117 	ldw	r2,-32444(gp)
 8244838:	10800f24 	muli	r2,r2,60
 824483c:	1885883a 	add	r2,r3,r2
 8244840:	e0fffa17 	ldw	r3,-24(fp)
 8244844:	18bfd836 	bltu	r3,r2,82447a8 <del_route+0x5c>
         retval++;
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
         cachedRoute = NULL;
   }
   return retval;
 8244848:	e0bffb17 	ldw	r2,-20(fp)
}
 824484c:	e037883a 	mov	sp,fp
 8244850:	dfc00117 	ldw	ra,4(sp)
 8244854:	df000017 	ldw	fp,0(sp)
 8244858:	dec00204 	addi	sp,sp,8
 824485c:	f800283a 	ret

08244860 <udpdemux>:
 * RETURNS: 0 if OK or ENP error code
 */

int
udpdemux(PACKET p)
{
 8244860:	deffec04 	addi	sp,sp,-80
 8244864:	dfc01315 	stw	ra,76(sp)
 8244868:	df001215 	stw	fp,72(sp)
 824486c:	df001204 	addi	fp,sp,72
 8244870:	e13fff15 	stw	r4,-4(fp)
   unsigned short osum, xsum; /* scratch checksum holders */
   unsigned plen; /* packet length */
   int   e;    /* general error holder */

   /* First let's verify that it's a valid UDP packet. */
   pip = ip_head(p);       /* we'll need IP header info */
 8244874:	e0bfff17 	ldw	r2,-4(fp)
 8244878:	10800317 	ldw	r2,12(r2)
 824487c:	e0bff615 	stw	r2,-40(fp)
   pup = (struct udp*)ip_data(pip);   /*  also need UDP header */
 8244880:	e0bff617 	ldw	r2,-40(fp)
 8244884:	10800003 	ldbu	r2,0(r2)
 8244888:	10803fcc 	andi	r2,r2,255
 824488c:	108003cc 	andi	r2,r2,15
 8244890:	1085883a 	add	r2,r2,r2
 8244894:	1085883a 	add	r2,r2,r2
 8244898:	1007883a 	mov	r3,r2
 824489c:	e0bff617 	ldw	r2,-40(fp)
 82448a0:	10c5883a 	add	r2,r2,r3
 82448a4:	e0bff715 	stw	r2,-36(fp)
   plen = htons(pup->ud_len);
 82448a8:	e0bff717 	ldw	r2,-36(fp)
 82448ac:	1080010b 	ldhu	r2,4(r2)
 82448b0:	10bfffcc 	andi	r2,r2,65535
 82448b4:	1004d23a 	srli	r2,r2,8
 82448b8:	10bfffcc 	andi	r2,r2,65535
 82448bc:	10c03fcc 	andi	r3,r2,255
 82448c0:	e0bff717 	ldw	r2,-36(fp)
 82448c4:	1080010b 	ldhu	r2,4(r2)
 82448c8:	10bfffcc 	andi	r2,r2,65535
 82448cc:	1004923a 	slli	r2,r2,8
 82448d0:	10bfffcc 	andi	r2,r2,65535
 82448d4:	1884b03a 	or	r2,r3,r2
 82448d8:	e0bff815 	stw	r2,-32(fp)

   if (plen > p->nb_plen)
 82448dc:	e0bfff17 	ldw	r2,-4(fp)
 82448e0:	10c00417 	ldw	r3,16(r2)
 82448e4:	e0bff817 	ldw	r2,-32(fp)
 82448e8:	1880252e 	bgeu	r3,r2,8244980 <udpdemux+0x120>
#ifdef   NPDEBUG
/* 
 * Altera Niche Stack Nios port modification:
 * cast arg to unsigned long to remove build warning
 */
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 82448ec:	d0a08317 	ldw	r2,-32244(gp)
 82448f0:	1081000c 	andi	r2,r2,1024
 82448f4:	10001726 	beq	r2,zero,8244954 <udpdemux+0xf4>
 82448f8:	d0a08317 	ldw	r2,-32244(gp)
 82448fc:	1080400c 	andi	r2,r2,256
 8244900:	10001426 	beq	r2,zero,8244954 <udpdemux+0xf4>
         dprintf("UDP: bad len pkt: rcvd: %u, hdr: %u.\n",
 8244904:	e0bfff17 	ldw	r2,-4(fp)
 8244908:	11000417 	ldw	r4,16(r2)
                 p->nb_plen, (unsigned int)(htons(pup->ud_len) + UDPLEN));
 824490c:	e0bff717 	ldw	r2,-36(fp)
 8244910:	1080010b 	ldhu	r2,4(r2)
 8244914:	10bfffcc 	andi	r2,r2,65535
 8244918:	1004d23a 	srli	r2,r2,8
 824491c:	10bfffcc 	andi	r2,r2,65535
 8244920:	10c03fcc 	andi	r3,r2,255
 8244924:	e0bff717 	ldw	r2,-36(fp)
 8244928:	1080010b 	ldhu	r2,4(r2)
 824492c:	10bfffcc 	andi	r2,r2,65535
 8244930:	1004923a 	slli	r2,r2,8
 8244934:	10bfffcc 	andi	r2,r2,65535
 8244938:	1884b03a 	or	r2,r3,r2
/* 
 * Altera Niche Stack Nios port modification:
 * cast arg to unsigned long to remove build warning
 */
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         dprintf("UDP: bad len pkt: rcvd: %u, hdr: %u.\n",
 824493c:	10800204 	addi	r2,r2,8
 8244940:	100d883a 	mov	r6,r2
 8244944:	200b883a 	mov	r5,r4
 8244948:	01020974 	movhi	r4,2085
 824494c:	2105b804 	addi	r4,r4,5856
 8244950:	82033fc0 	call	82033fc <printf>
                 p->nb_plen, (unsigned int)(htons(pup->ud_len) + UDPLEN));
#endif
      udp_mib.udpInErrors++;
 8244954:	008209b4 	movhi	r2,2086
 8244958:	10ba9d04 	addi	r2,r2,-5516
 824495c:	10800217 	ldw	r2,8(r2)
 8244960:	10c00044 	addi	r3,r2,1
 8244964:	008209b4 	movhi	r2,2086
 8244968:	10ba9d04 	addi	r2,r2,-5516
 824496c:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 8244970:	e13fff17 	ldw	r4,-4(fp)
 8244974:	82455240 	call	8245524 <udp_free>
      return ENP_BAD_HEADER;
 8244978:	00bff804 	movi	r2,-32
 824497c:	00019d06 	br	8244ff4 <udpdemux+0x794>
   }

   osum = pup->ud_cksum;
 8244980:	e0bff717 	ldw	r2,-36(fp)
 8244984:	1080018b 	ldhu	r2,6(r2)
 8244988:	e0bff90d 	sth	r2,-28(fp)
   /* did other guy use checksumming? */
   if (osum)
 824498c:	e0bff90b 	ldhu	r2,-28(fp)
 8244990:	10005826 	beq	r2,zero,8244af4 <udpdemux+0x294>
   {
      if (plen & 1) ((char *)pup)[plen] = 0;
 8244994:	e0bff817 	ldw	r2,-32(fp)
 8244998:	1080004c 	andi	r2,r2,1
 824499c:	10000426 	beq	r2,zero,82449b0 <udpdemux+0x150>
 82449a0:	e0fff717 	ldw	r3,-36(fp)
 82449a4:	e0bff817 	ldw	r2,-32(fp)
 82449a8:	1885883a 	add	r2,r3,r2
 82449ac:	10000005 	stb	zero,0(r2)
         php.ph_src = p->fhost;
 82449b0:	e0bfff17 	ldw	r2,-4(fp)
 82449b4:	10800717 	ldw	r2,28(r2)
 82449b8:	e0bffc15 	stw	r2,-16(fp)
      php.ph_dest = pip->ip_dest;
 82449bc:	e0bff617 	ldw	r2,-40(fp)
 82449c0:	10800417 	ldw	r2,16(r2)
 82449c4:	e0bffd15 	stw	r2,-12(fp)
      php.ph_zero = 0;
 82449c8:	e03ffe05 	stb	zero,-8(fp)
      php.ph_prot = UDP_PROT;
 82449cc:	00800444 	movi	r2,17
 82449d0:	e0bffe45 	stb	r2,-7(fp)
      php.ph_len  = pup->ud_len;
 82449d4:	e0bff717 	ldw	r2,-36(fp)
 82449d8:	1080010b 	ldhu	r2,4(r2)
 82449dc:	e0bffe8d 	sth	r2,-6(fp)

      pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 82449e0:	e0bffc04 	addi	r2,fp,-16
 82449e4:	01400184 	movi	r5,6
 82449e8:	1009883a 	mov	r4,r2
 82449ec:	82288100 	call	8228810 <cksum>
 82449f0:	1007883a 	mov	r3,r2
 82449f4:	e0bff717 	ldw	r2,-36(fp)
 82449f8:	10c0018d 	sth	r3,6(r2)
      xsum = ~cksum(pup, (plen+1)>>1);
 82449fc:	e0bff817 	ldw	r2,-32(fp)
 8244a00:	10800044 	addi	r2,r2,1
 8244a04:	1004d07a 	srli	r2,r2,1
 8244a08:	100b883a 	mov	r5,r2
 8244a0c:	e13ff717 	ldw	r4,-36(fp)
 8244a10:	82288100 	call	8228810 <cksum>
 8244a14:	0084303a 	nor	r2,zero,r2
 8244a18:	e0bff30d 	sth	r2,-52(fp)
      if (!xsum)
 8244a1c:	e0bff30b 	ldhu	r2,-52(fp)
 8244a20:	1000021e 	bne	r2,zero,8244a2c <udpdemux+0x1cc>
         xsum = 0xffff;
 8244a24:	00bfffc4 	movi	r2,-1
 8244a28:	e0bff30d 	sth	r2,-52(fp)
      pup->ud_cksum = osum;
 8244a2c:	e0bff717 	ldw	r2,-36(fp)
 8244a30:	e0fff90b 	ldhu	r3,-28(fp)
 8244a34:	10c0018d 	sth	r3,6(r2)
      if (xsum != osum)
 8244a38:	e0fff30b 	ldhu	r3,-52(fp)
 8244a3c:	e0bff90b 	ldhu	r2,-28(fp)
 8244a40:	18802c26 	beq	r3,r2,8244af4 <udpdemux+0x294>
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 8244a44:	d0a08317 	ldw	r2,-32244(gp)
 8244a48:	1081000c 	andi	r2,r2,1024
 8244a4c:	10001e26 	beq	r2,zero,8244ac8 <udpdemux+0x268>
 8244a50:	d0a08317 	ldw	r2,-32244(gp)
 8244a54:	1080400c 	andi	r2,r2,256
 8244a58:	10001b26 	beq	r2,zero,8244ac8 <udpdemux+0x268>
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 8244a5c:	e17ff90b 	ldhu	r5,-28(fp)
 8244a60:	e1bff30b 	ldhu	r6,-52(fp)
                    osum, xsum, PUSH_IPADDR(p->fhost));
 8244a64:	e0bfff17 	ldw	r2,-4(fp)
 8244a68:	10800717 	ldw	r2,28(r2)
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 8244a6c:	11c03fcc 	andi	r7,r2,255
                    osum, xsum, PUSH_IPADDR(p->fhost));
 8244a70:	e0bfff17 	ldw	r2,-4(fp)
 8244a74:	10800717 	ldw	r2,28(r2)
 8244a78:	1004d23a 	srli	r2,r2,8
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 8244a7c:	10803fcc 	andi	r2,r2,255
                    osum, xsum, PUSH_IPADDR(p->fhost));
 8244a80:	e0ffff17 	ldw	r3,-4(fp)
 8244a84:	18c00717 	ldw	r3,28(r3)
 8244a88:	1806d43a 	srli	r3,r3,16
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 8244a8c:	18c03fcc 	andi	r3,r3,255
                    osum, xsum, PUSH_IPADDR(p->fhost));
 8244a90:	e13fff17 	ldw	r4,-4(fp)
 8244a94:	21000717 	ldw	r4,28(r4)
 8244a98:	2008d63a 	srli	r4,r4,24
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 8244a9c:	d9000215 	stw	r4,8(sp)
 8244aa0:	d8c00115 	stw	r3,4(sp)
 8244aa4:	d8800015 	stw	r2,0(sp)
 8244aa8:	01020974 	movhi	r4,2085
 8244aac:	2105c204 	addi	r4,r4,5896
 8244ab0:	82033fc0 	call	82033fc <printf>
                    osum, xsum, PUSH_IPADDR(p->fhost));
            if (NDEBUG & DUMP)
 8244ab4:	d0a08317 	ldw	r2,-32244(gp)
 8244ab8:	1080008c 	andi	r2,r2,2
 8244abc:	10000226 	beq	r2,zero,8244ac8 <udpdemux+0x268>
               ip_dump(p);
 8244ac0:	e13fff17 	ldw	r4,-4(fp)
 8244ac4:	8240a9c0 	call	8240a9c <ip_dump>
         }
#endif
         udp_mib.udpInErrors++;
 8244ac8:	008209b4 	movhi	r2,2086
 8244acc:	10ba9d04 	addi	r2,r2,-5516
 8244ad0:	10800217 	ldw	r2,8(r2)
 8244ad4:	10c00044 	addi	r3,r2,1
 8244ad8:	008209b4 	movhi	r2,2086
 8244adc:	10ba9d04 	addi	r2,r2,-5516
 8244ae0:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 8244ae4:	e13fff17 	ldw	r4,-4(fp)
 8244ae8:	82455240 	call	8245524 <udp_free>
         return ENP_BAD_HEADER;
 8244aec:	00bff804 	movi	r2,-32
 8244af0:	00014006 	br	8244ff4 <udpdemux+0x794>
      }
   }

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 8244af4:	e13ff717 	ldw	r4,-36(fp)
 8244af8:	82452a00 	call	82452a0 <udpswap>
#endif

   /* Prior to upcall, adjust nb_prot for size of IP and UDP headers */
   e = (sizeof(struct udp) + ip_hlen(pip));
 8244afc:	e0bff617 	ldw	r2,-40(fp)
 8244b00:	10800003 	ldbu	r2,0(r2)
 8244b04:	10803fcc 	andi	r2,r2,255
 8244b08:	108003cc 	andi	r2,r2,15
 8244b0c:	1085883a 	add	r2,r2,r2
 8244b10:	1085883a 	add	r2,r2,r2
 8244b14:	10800204 	addi	r2,r2,8
 8244b18:	e0bff415 	stw	r2,-48(fp)
   p->nb_plen -= e;
 8244b1c:	e0bfff17 	ldw	r2,-4(fp)
 8244b20:	10c00417 	ldw	r3,16(r2)
 8244b24:	e0bff417 	ldw	r2,-48(fp)
 8244b28:	1887c83a 	sub	r3,r3,r2
 8244b2c:	e0bfff17 	ldw	r2,-4(fp)
 8244b30:	10c00415 	stw	r3,16(r2)
   p->nb_prot += e;
 8244b34:	e0bfff17 	ldw	r2,-4(fp)
 8244b38:	10c00317 	ldw	r3,12(r2)
 8244b3c:	e0bff417 	ldw	r2,-48(fp)
 8244b40:	1887883a 	add	r3,r3,r2
 8244b44:	e0bfff17 	ldw	r2,-4(fp)
 8244b48:	10c00315 	stw	r3,12(r2)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 8244b4c:	d0a08317 	ldw	r2,-32244(gp)
 8244b50:	1081000c 	andi	r2,r2,1024
 8244b54:	10001f26 	beq	r2,zero,8244bd4 <udpdemux+0x374>
 8244b58:	d0a08317 	ldw	r2,-32244(gp)
 8244b5c:	1080400c 	andi	r2,r2,256
 8244b60:	10001c26 	beq	r2,zero,8244bd4 <udpdemux+0x374>
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 8244b64:	e0bfff17 	ldw	r2,-4(fp)
 8244b68:	10800717 	ldw	r2,28(r2)
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 8244b6c:	11803fcc 	andi	r6,r2,255
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 8244b70:	e0bfff17 	ldw	r2,-4(fp)
 8244b74:	10800717 	ldw	r2,28(r2)
 8244b78:	1004d23a 	srli	r2,r2,8
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 8244b7c:	11c03fcc 	andi	r7,r2,255
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 8244b80:	e0bfff17 	ldw	r2,-4(fp)
 8244b84:	10800717 	ldw	r2,28(r2)
 8244b88:	1004d43a 	srli	r2,r2,16
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 8244b8c:	10803fcc 	andi	r2,r2,255
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 8244b90:	e0ffff17 	ldw	r3,-4(fp)
 8244b94:	18c00717 	ldw	r3,28(r3)
 8244b98:	1806d63a 	srli	r3,r3,24
 8244b9c:	e13ff717 	ldw	r4,-36(fp)
 8244ba0:	2100000b 	ldhu	r4,0(r4)
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 8244ba4:	213fffcc 	andi	r4,r4,65535
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 8244ba8:	e17ff717 	ldw	r5,-36(fp)
 8244bac:	2940008b 	ldhu	r5,2(r5)
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 8244bb0:	297fffcc 	andi	r5,r5,65535
 8244bb4:	d9400315 	stw	r5,12(sp)
 8244bb8:	d9000215 	stw	r4,8(sp)
 8244bbc:	d8c00115 	stw	r3,4(sp)
 8244bc0:	d8800015 	stw	r2,0(sp)
 8244bc4:	e17ff817 	ldw	r5,-32(fp)
 8244bc8:	01020974 	movhi	r4,2085
 8244bcc:	2105d004 	addi	r4,r4,5952
 8244bd0:	82033fc0 	call	82033fc <printf>
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 8244bd4:	d0a09c17 	ldw	r2,-32144(gp)
 8244bd8:	e0bff215 	stw	r2,-56(fp)
 8244bdc:	0000ae06 	br	8244e98 <udpdemux+0x638>
         continue;
#endif

      /* enforce all three aspects of tuple matching. Old code
      assumed lport was unique, which is not always so. */
      if (con->u_lport && (con->u_lport != pup->ud_dstp))
 8244be0:	e0bff217 	ldw	r2,-56(fp)
 8244be4:	1080018b 	ldhu	r2,6(r2)
 8244be8:	10bfffcc 	andi	r2,r2,65535
 8244bec:	10000726 	beq	r2,zero,8244c0c <udpdemux+0x3ac>
 8244bf0:	e0bff217 	ldw	r2,-56(fp)
 8244bf4:	10c0018b 	ldhu	r3,6(r2)
 8244bf8:	e0bff717 	ldw	r2,-36(fp)
 8244bfc:	1080008b 	ldhu	r2,2(r2)
 8244c00:	18ffffcc 	andi	r3,r3,65535
 8244c04:	10bfffcc 	andi	r2,r2,65535
 8244c08:	1880991e 	bne	r3,r2,8244e70 <udpdemux+0x610>
         continue;
      if (con->u_fport && (con->u_fport != pup->ud_srcp))
 8244c0c:	e0bff217 	ldw	r2,-56(fp)
 8244c10:	1080020b 	ldhu	r2,8(r2)
 8244c14:	10bfffcc 	andi	r2,r2,65535
 8244c18:	10000726 	beq	r2,zero,8244c38 <udpdemux+0x3d8>
 8244c1c:	e0bff217 	ldw	r2,-56(fp)
 8244c20:	10c0020b 	ldhu	r3,8(r2)
 8244c24:	e0bff717 	ldw	r2,-36(fp)
 8244c28:	1080000b 	ldhu	r2,0(r2)
 8244c2c:	18ffffcc 	andi	r3,r3,65535
 8244c30:	10bfffcc 	andi	r2,r2,65535
 8244c34:	1880901e 	bne	r3,r2,8244e78 <udpdemux+0x618>
         continue;
      if (con->u_fhost && (con->u_fhost != p->fhost))
 8244c38:	e0bff217 	ldw	r2,-56(fp)
 8244c3c:	10800417 	ldw	r2,16(r2)
 8244c40:	10000526 	beq	r2,zero,8244c58 <udpdemux+0x3f8>
 8244c44:	e0bff217 	ldw	r2,-56(fp)
 8244c48:	10c00417 	ldw	r3,16(r2)
 8244c4c:	e0bfff17 	ldw	r2,-4(fp)
 8244c50:	10800717 	ldw	r2,28(r2)
 8244c54:	18808a1e 	bne	r3,r2,8244e80 <udpdemux+0x620>
#ifdef IP_MULTICAST
      /* In the case of multicast, check if there is multicast membership
       * attached to this socket and if so, is the incoming packet
       * addressed to the multicast address
       */
      if (IN_MULTICAST(ntohl(pip->ip_dest)))
 8244c58:	e0bff617 	ldw	r2,-40(fp)
 8244c5c:	10800417 	ldw	r2,16(r2)
 8244c60:	1006d63a 	srli	r3,r2,24
 8244c64:	e0bff617 	ldw	r2,-40(fp)
 8244c68:	10800417 	ldw	r2,16(r2)
 8244c6c:	1004d23a 	srli	r2,r2,8
 8244c70:	10bfc00c 	andi	r2,r2,65280
 8244c74:	1886b03a 	or	r3,r3,r2
 8244c78:	e0bff617 	ldw	r2,-40(fp)
 8244c7c:	10800417 	ldw	r2,16(r2)
 8244c80:	10bfc00c 	andi	r2,r2,65280
 8244c84:	1004923a 	slli	r2,r2,8
 8244c88:	1886b03a 	or	r3,r3,r2
 8244c8c:	e0bff617 	ldw	r2,-40(fp)
 8244c90:	10800417 	ldw	r2,16(r2)
 8244c94:	1004963a 	slli	r2,r2,24
 8244c98:	1884b03a 	or	r2,r3,r2
 8244c9c:	10fc002c 	andhi	r3,r2,61440
 8244ca0:	00b80034 	movhi	r2,57344
 8244ca4:	1880301e 	bne	r3,r2,8244d68 <udpdemux+0x508>
      {
         struct socket *soptr = (struct socket *)con->u_data;
 8244ca8:	e0bff217 	ldw	r2,-56(fp)
 8244cac:	10800617 	ldw	r2,24(r2)
 8244cb0:	e0bffa15 	stw	r2,-24(fp)

         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
 8244cb4:	e0bff217 	ldw	r2,-56(fp)
 8244cb8:	10c00517 	ldw	r3,20(r2)
 8244cbc:	00820934 	movhi	r2,2084
 8244cc0:	10abf604 	addi	r2,r2,-20520
 8244cc4:	1880281e 	bne	r3,r2,8244d68 <udpdemux+0x508>
 8244cc8:	e0bffa17 	ldw	r2,-24(fp)
 8244ccc:	10800317 	ldw	r2,12(r2)
 8244cd0:	10002526 	beq	r2,zero,8244d68 <udpdemux+0x508>
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;
 8244cd4:	e0bffa17 	ldw	r2,-24(fp)
 8244cd8:	10800317 	ldw	r2,12(r2)
 8244cdc:	e0bffb15 	stw	r2,-20(fp)

            for (i = 0; i < imo->imo_num_memberships; ++i)
 8244ce0:	e03ff50d 	sth	zero,-44(fp)
 8244ce4:	00001906 	br	8244d4c <udpdemux+0x4ec>
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
 8244ce8:	e0bff50b 	ldhu	r2,-44(fp)
 8244cec:	e0fffb17 	ldw	r3,-20(fp)
 8244cf0:	10800084 	addi	r2,r2,2
 8244cf4:	1085883a 	add	r2,r2,r2
 8244cf8:	1085883a 	add	r2,r2,r2
 8244cfc:	1885883a 	add	r2,r3,r2
 8244d00:	10800017 	ldw	r2,0(r2)
 8244d04:	10c00117 	ldw	r3,4(r2)
 8244d08:	e0bfff17 	ldw	r2,-4(fp)
 8244d0c:	10800617 	ldw	r2,24(r2)
 8244d10:	18800b1e 	bne	r3,r2,8244d40 <udpdemux+0x4e0>
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
 8244d14:	e0bff50b 	ldhu	r2,-44(fp)
 8244d18:	e0fffb17 	ldw	r3,-20(fp)
 8244d1c:	10800084 	addi	r2,r2,2
 8244d20:	1085883a 	add	r2,r2,r2
 8244d24:	1085883a 	add	r2,r2,r2
 8244d28:	1885883a 	add	r2,r3,r2
 8244d2c:	10800017 	ldw	r2,0(r2)
 8244d30:	10c00017 	ldw	r3,0(r2)
 8244d34:	e0bff617 	ldw	r2,-40(fp)
 8244d38:	10800417 	ldw	r2,16(r2)
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;

            for (i = 0; i < imo->imo_num_memberships; ++i)
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
 8244d3c:	18800926 	beq	r3,r2,8244d64 <udpdemux+0x504>
         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;

            for (i = 0; i < imo->imo_num_memberships; ++i)
 8244d40:	e0bff50b 	ldhu	r2,-44(fp)
 8244d44:	10800044 	addi	r2,r2,1
 8244d48:	e0bff50d 	sth	r2,-44(fp)
 8244d4c:	e0bffb17 	ldw	r2,-20(fp)
 8244d50:	1080018b 	ldhu	r2,6(r2)
 8244d54:	10bfffcc 	andi	r2,r2,65535
 8244d58:	e0fff50b 	ldhu	r3,-44(fp)
 8244d5c:	18bfe236 	bltu	r3,r2,8244ce8 <udpdemux+0x488>
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
               {
                  goto found;
               }
            }
            continue;
 8244d60:	00004a06 	br	8244e8c <udpdemux+0x62c>
            for (i = 0; i < imo->imo_num_memberships; ++i)
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
               {
                  goto found;
 8244d64:	0001883a 	nop
#endif /* INCLUDE_TCP */

      /* if this endpoint has been bound to a local interface address,
       * make sure the packet was received on that interface address
       */
      if (!IN_MULTICAST(ntohl(pip->ip_dest)))
 8244d68:	e0bff617 	ldw	r2,-40(fp)
 8244d6c:	10800417 	ldw	r2,16(r2)
 8244d70:	1006d63a 	srli	r3,r2,24
 8244d74:	e0bff617 	ldw	r2,-40(fp)
 8244d78:	10800417 	ldw	r2,16(r2)
 8244d7c:	1004d23a 	srli	r2,r2,8
 8244d80:	10bfc00c 	andi	r2,r2,65280
 8244d84:	1886b03a 	or	r3,r3,r2
 8244d88:	e0bff617 	ldw	r2,-40(fp)
 8244d8c:	10800417 	ldw	r2,16(r2)
 8244d90:	10bfc00c 	andi	r2,r2,65280
 8244d94:	1004923a 	slli	r2,r2,8
 8244d98:	1886b03a 	or	r3,r3,r2
 8244d9c:	e0bff617 	ldw	r2,-40(fp)
 8244da0:	10800417 	ldw	r2,16(r2)
 8244da4:	1004963a 	slli	r2,r2,24
 8244da8:	1884b03a 	or	r2,r3,r2
 8244dac:	10fc002c 	andhi	r3,r2,61440
 8244db0:	00b80034 	movhi	r2,57344
 8244db4:	18800826 	beq	r3,r2,8244dd8 <udpdemux+0x578>
      {
         if ((con->u_lhost != 0) && (con->u_lhost != pip->ip_dest)) 
 8244db8:	e0bff217 	ldw	r2,-56(fp)
 8244dbc:	10800317 	ldw	r2,12(r2)
 8244dc0:	10000526 	beq	r2,zero,8244dd8 <udpdemux+0x578>
 8244dc4:	e0bff217 	ldw	r2,-56(fp)
 8244dc8:	10c00317 	ldw	r3,12(r2)
 8244dcc:	e0bff617 	ldw	r2,-40(fp)
 8244dd0:	10800417 	ldw	r2,16(r2)
 8244dd4:	18802c1e 	bne	r3,r2,8244e88 <udpdemux+0x628>
            continue;
      }

      /* fall to here if we found it */
      udp_mib.udpInDatagrams++;
 8244dd8:	008209b4 	movhi	r2,2086
 8244ddc:	10ba9d04 	addi	r2,r2,-5516
 8244de0:	10800017 	ldw	r2,0(r2)
 8244de4:	10c00044 	addi	r3,r2,1
 8244de8:	008209b4 	movhi	r2,2086
 8244dec:	10ba9d04 	addi	r2,r2,-5516
 8244df0:	10c00015 	stw	r3,0(r2)
      if (con->u_rcv)         /* if upcall address is set... */
 8244df4:	e0bff217 	ldw	r2,-56(fp)
 8244df8:	10800517 	ldw	r2,20(r2)
 8244dfc:	10000d26 	beq	r2,zero,8244e34 <udpdemux+0x5d4>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 8244e00:	0009883a 	mov	r4,zero
 8244e04:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         e = ((*con->u_rcv)(p, con->u_data));   /* upcall it */
 8244e08:	e0bff217 	ldw	r2,-56(fp)
 8244e0c:	10800517 	ldw	r2,20(r2)
 8244e10:	e0fff217 	ldw	r3,-56(fp)
 8244e14:	18c00617 	ldw	r3,24(r3)
 8244e18:	180b883a 	mov	r5,r3
 8244e1c:	e13fff17 	ldw	r4,-4(fp)
 8244e20:	103ee83a 	callr	r2
 8244e24:	e0bff415 	stw	r2,-48(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 8244e28:	0009883a 	mov	r4,zero
 8244e2c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
 8244e30:	00000206 	br	8244e3c <udpdemux+0x5dc>
      }
      else
         e = ENP_LOGIC;
 8244e34:	00bffd44 	movi	r2,-11
 8244e38:	e0bff415 	stw	r2,-48(fp)

      /* if error occurred in upcall or there was no upcall hander
         its up to this routine to free the packet buffer */
      if (e)
 8244e3c:	e0bff417 	ldw	r2,-48(fp)
 8244e40:	10000926 	beq	r2,zero,8244e68 <udpdemux+0x608>
      {
         udp_mib.udpInErrors++;
 8244e44:	008209b4 	movhi	r2,2086
 8244e48:	10ba9d04 	addi	r2,r2,-5516
 8244e4c:	10800217 	ldw	r2,8(r2)
 8244e50:	10c00044 	addi	r3,r2,1
 8244e54:	008209b4 	movhi	r2,2086
 8244e58:	10ba9d04 	addi	r2,r2,-5516
 8244e5c:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 8244e60:	e13fff17 	ldw	r4,-4(fp)
 8244e64:	82455240 	call	8245524 <udp_free>
      }

      return(e);
 8244e68:	e0bff417 	ldw	r2,-48(fp)
 8244e6c:	00006106 	br	8244ff4 <udpdemux+0x794>
#endif

      /* enforce all three aspects of tuple matching. Old code
      assumed lport was unique, which is not always so. */
      if (con->u_lport && (con->u_lport != pup->ud_dstp))
         continue;
 8244e70:	0001883a 	nop
 8244e74:	00000506 	br	8244e8c <udpdemux+0x62c>
      if (con->u_fport && (con->u_fport != pup->ud_srcp))
         continue;
 8244e78:	0001883a 	nop
 8244e7c:	00000306 	br	8244e8c <udpdemux+0x62c>
      if (con->u_fhost && (con->u_fhost != p->fhost))
         continue;
 8244e80:	0001883a 	nop
 8244e84:	00000106 	br	8244e8c <udpdemux+0x62c>
       * make sure the packet was received on that interface address
       */
      if (!IN_MULTICAST(ntohl(pip->ip_dest)))
      {
         if ((con->u_lhost != 0) && (con->u_lhost != pip->ip_dest)) 
            continue;
 8244e88:	0001883a 	nop
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 8244e8c:	e0bff217 	ldw	r2,-56(fp)
 8244e90:	10800017 	ldw	r2,0(r2)
 8244e94:	e0bff215 	stw	r2,-56(fp)
 8244e98:	e0bff217 	ldw	r2,-56(fp)
 8244e9c:	103f501e 	bne	r2,zero,8244be0 <udpdemux+0x380>

   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
 8244ea0:	e0bff617 	ldw	r2,-40(fp)
 8244ea4:	10800417 	ldw	r2,16(r2)
 8244ea8:	10bfffe0 	cmpeqi	r2,r2,-1
 8244eac:	1000121e 	bne	r2,zero,8244ef8 <udpdemux+0x698>
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
 8244eb0:	e0bff617 	ldw	r2,-40(fp)
 8244eb4:	10c00417 	ldw	r3,16(r2)
 8244eb8:	e0bfff17 	ldw	r2,-4(fp)
 8244ebc:	10800617 	ldw	r2,24(r2)
 8244ec0:	10800e17 	ldw	r2,56(r2)

   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
 8244ec4:	18800c26 	beq	r3,r2,8244ef8 <udpdemux+0x698>
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
 8244ec8:	e0bff617 	ldw	r2,-40(fp)
 8244ecc:	10c00417 	ldw	r3,16(r2)
 8244ed0:	e0bfff17 	ldw	r2,-4(fp)
 8244ed4:	10800617 	ldw	r2,24(r2)
 8244ed8:	10800f17 	ldw	r2,60(r2)
   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
 8244edc:	18800626 	beq	r3,r2,8244ef8 <udpdemux+0x698>
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
       (pip->ip_dest == p->net->n_subnetbr))  /* Our subnet broadcast */
 8244ee0:	e0bff617 	ldw	r2,-40(fp)
 8244ee4:	10c00417 	ldw	r3,16(r2)
 8244ee8:	e0bfff17 	ldw	r2,-4(fp)
 8244eec:	10800617 	ldw	r2,24(r2)
 8244ef0:	10801017 	ldw	r2,64(r2)
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
 8244ef4:	1880141e 	bne	r3,r2,8244f48 <udpdemux+0x6e8>
       (pip->ip_dest == p->net->n_subnetbr))  /* Our subnet broadcast */
   {
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 8244ef8:	d0a08317 	ldw	r2,-32244(gp)
 8244efc:	1081000c 	andi	r2,r2,1024
 8244f00:	10000626 	beq	r2,zero,8244f1c <udpdemux+0x6bc>
 8244f04:	d0a08317 	ldw	r2,-32244(gp)
 8244f08:	1080400c 	andi	r2,r2,256
 8244f0c:	10000326 	beq	r2,zero,8244f1c <udpdemux+0x6bc>
         dprintf("UDP: ignoring ip broadcast\n");
 8244f10:	01020974 	movhi	r4,2085
 8244f14:	2105da04 	addi	r4,r4,5992
 8244f18:	82036800 	call	8203680 <puts>
#endif
      udp_mib.udpInErrors++;
 8244f1c:	008209b4 	movhi	r2,2086
 8244f20:	10ba9d04 	addi	r2,r2,-5516
 8244f24:	10800217 	ldw	r2,8(r2)
 8244f28:	10c00044 	addi	r3,r2,1
 8244f2c:	008209b4 	movhi	r2,2086
 8244f30:	10ba9d04 	addi	r2,r2,-5516
 8244f34:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 8244f38:	e13fff17 	ldw	r4,-4(fp)
 8244f3c:	82455240 	call	8245524 <udp_free>
      return ENP_NOT_MINE;
 8244f40:	00800084 	movi	r2,2
 8244f44:	00002b06 	br	8244ff4 <udpdemux+0x794>
   }

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 8244f48:	d0a08317 	ldw	r2,-32244(gp)
 8244f4c:	1081000c 	andi	r2,r2,1024
 8244f50:	10000f26 	beq	r2,zero,8244f90 <udpdemux+0x730>
 8244f54:	d0a08317 	ldw	r2,-32244(gp)
 8244f58:	1080400c 	andi	r2,r2,256
 8244f5c:	10000c26 	beq	r2,zero,8244f90 <udpdemux+0x730>
   {
      dprintf("UDP: unexpected port %04x\n", pup->ud_dstp);
 8244f60:	e0bff717 	ldw	r2,-36(fp)
 8244f64:	1080008b 	ldhu	r2,2(r2)
 8244f68:	10bfffcc 	andi	r2,r2,65535
 8244f6c:	100b883a 	mov	r5,r2
 8244f70:	01020974 	movhi	r4,2085
 8244f74:	2105e104 	addi	r4,r4,6020
 8244f78:	82033fc0 	call	82033fc <printf>
      if (NDEBUG & DUMP) 
 8244f7c:	d0a08317 	ldw	r2,-32244(gp)
 8244f80:	1080008c 	andi	r2,r2,2
 8244f84:	10000226 	beq	r2,zero,8244f90 <udpdemux+0x730>
         ip_dump(p);
 8244f88:	e13fff17 	ldw	r4,-4(fp)
 8244f8c:	8240a9c0 	call	8240a9c <ip_dump>
#ifdef FULL_ICMP
   /* send destination unreachable.  Swap back all the swapped information */
   /* so that the destun packet format is correct */

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 8244f90:	e13ff717 	ldw	r4,-36(fp)
 8244f94:	82452a00 	call	82452a0 <udpswap>
#endif   /* BYTE_ORDER */
   
   icmp_destun(p->fhost, p->net->n_ipaddr, pip, DSTPORT, p->net);
 8244f98:	e0bfff17 	ldw	r2,-4(fp)
 8244f9c:	10c00717 	ldw	r3,28(r2)
 8244fa0:	e0bfff17 	ldw	r2,-4(fp)
 8244fa4:	10800617 	ldw	r2,24(r2)
 8244fa8:	11000a17 	ldw	r4,40(r2)
 8244fac:	e0bfff17 	ldw	r2,-4(fp)
 8244fb0:	10800617 	ldw	r2,24(r2)
 8244fb4:	d8800015 	stw	r2,0(sp)
 8244fb8:	01c000c4 	movi	r7,3
 8244fbc:	e1bff617 	ldw	r6,-40(fp)
 8244fc0:	200b883a 	mov	r5,r4
 8244fc4:	1809883a 	mov	r4,r3
 8244fc8:	824b0200 	call	824b020 <icmp_destun>
#endif   /* FULL_ICMP */

   udp_mib.udpNoPorts++;
 8244fcc:	008209b4 	movhi	r2,2086
 8244fd0:	10ba9d04 	addi	r2,r2,-5516
 8244fd4:	10800117 	ldw	r2,4(r2)
 8244fd8:	10c00044 	addi	r3,r2,1
 8244fdc:	008209b4 	movhi	r2,2086
 8244fe0:	10ba9d04 	addi	r2,r2,-5516
 8244fe4:	10c00115 	stw	r3,4(r2)
   udp_free(p);
 8244fe8:	e13fff17 	ldw	r4,-4(fp)
 8244fec:	82455240 	call	8245524 <udp_free>
   return ENP_NOT_MINE;
 8244ff0:	00800084 	movi	r2,2
}
 8244ff4:	e037883a 	mov	sp,fp
 8244ff8:	dfc00117 	ldw	ra,4(sp)
 8244ffc:	df000017 	ldw	fp,0(sp)
 8245000:	dec00204 	addi	sp,sp,8
 8245004:	f800283a 	ret

08245008 <udp_send>:
 * detected. 
 */

int
udp_send(unshort fport, unshort lport, PACKET p)
{
 8245008:	deffef04 	addi	sp,sp,-68
 824500c:	dfc01015 	stw	ra,64(sp)
 8245010:	df000f15 	stw	fp,60(sp)
 8245014:	df000f04 	addi	fp,sp,60
 8245018:	2007883a 	mov	r3,r4
 824501c:	2805883a 	mov	r2,r5
 8245020:	e1bfff15 	stw	r6,-4(fp)
 8245024:	e0fffd0d 	sth	r3,-12(fp)
 8245028:	e0bffe0d 	sth	r2,-8(fp)
   int         udplen;
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
 824502c:	d0a08317 	ldw	r2,-32244(gp)
 8245030:	1080410c 	andi	r2,r2,260
 8245034:	10001a26 	beq	r2,zero,82450a0 <udp_send+0x98>
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 8245038:	e0bfff17 	ldw	r2,-4(fp)
 824503c:	12000417 	ldw	r8,16(r2)
 8245040:	e1bffe0b 	ldhu	r6,-8(fp)
    PUSH_IPADDR(p->fhost), fport);
 8245044:	e0bfff17 	ldw	r2,-4(fp)
 8245048:	10800717 	ldw	r2,28(r2)
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 824504c:	11c03fcc 	andi	r7,r2,255
    PUSH_IPADDR(p->fhost), fport);
 8245050:	e0bfff17 	ldw	r2,-4(fp)
 8245054:	10800717 	ldw	r2,28(r2)
 8245058:	1004d23a 	srli	r2,r2,8
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 824505c:	10803fcc 	andi	r2,r2,255
    PUSH_IPADDR(p->fhost), fport);
 8245060:	e0ffff17 	ldw	r3,-4(fp)
 8245064:	18c00717 	ldw	r3,28(r3)
 8245068:	1806d43a 	srli	r3,r3,16
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 824506c:	18c03fcc 	andi	r3,r3,255
    PUSH_IPADDR(p->fhost), fport);
 8245070:	e13fff17 	ldw	r4,-4(fp)
 8245074:	21000717 	ldw	r4,28(r4)
 8245078:	2008d63a 	srli	r4,r4,24
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 824507c:	e17ffd0b 	ldhu	r5,-12(fp)
 8245080:	d9400315 	stw	r5,12(sp)
 8245084:	d9000215 	stw	r4,8(sp)
 8245088:	d8c00115 	stw	r3,4(sp)
 824508c:	d8800015 	stw	r2,0(sp)
 8245090:	400b883a 	mov	r5,r8
 8245094:	01020974 	movhi	r4,2085
 8245098:	2105e804 	addi	r4,r4,6048
 824509c:	82033fc0 	call	82033fc <printf>
    PUSH_IPADDR(p->fhost), fport);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 82450a0:	0009883a 	mov	r4,zero
 82450a4:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   /* prepend UDP header to upper layer's data */
   p->nb_prot -= sizeof(struct udp);
 82450a8:	e0bfff17 	ldw	r2,-4(fp)
 82450ac:	10800317 	ldw	r2,12(r2)
 82450b0:	10fffe04 	addi	r3,r2,-8
 82450b4:	e0bfff17 	ldw	r2,-4(fp)
 82450b8:	10c00315 	stw	r3,12(r2)
   pup = (struct udp*)p->nb_prot;
 82450bc:	e0bfff17 	ldw	r2,-4(fp)
 82450c0:	10800317 	ldw	r2,12(r2)
 82450c4:	e0bff615 	stw	r2,-40(fp)
   udplen = p->nb_plen + sizeof(struct udp);
 82450c8:	e0bfff17 	ldw	r2,-4(fp)
 82450cc:	10800417 	ldw	r2,16(r2)
 82450d0:	10800204 	addi	r2,r2,8
 82450d4:	e0bff715 	stw	r2,-36(fp)
   p->nb_plen = udplen;
 82450d8:	e0fff717 	ldw	r3,-36(fp)
 82450dc:	e0bfff17 	ldw	r2,-4(fp)
 82450e0:	10c00415 	stw	r3,16(r2)
   if (udplen & 1) ((char *)pup)[udplen] = 0;
 82450e4:	e0bff717 	ldw	r2,-36(fp)
 82450e8:	1080004c 	andi	r2,r2,1
 82450ec:	10000426 	beq	r2,zero,8245100 <udp_send+0xf8>
 82450f0:	e0bff717 	ldw	r2,-36(fp)
 82450f4:	e0fff617 	ldw	r3,-40(fp)
 82450f8:	1885883a 	add	r2,r3,r2
 82450fc:	10000005 	stb	zero,0(r2)

      pup->ud_len = (unshort)udplen;   /* fill in the UDP header */
 8245100:	e0bff717 	ldw	r2,-36(fp)
 8245104:	1007883a 	mov	r3,r2
 8245108:	e0bff617 	ldw	r2,-40(fp)
 824510c:	10c0010d 	sth	r3,4(r2)
   pup->ud_srcp = lport;
 8245110:	e0bff617 	ldw	r2,-40(fp)
 8245114:	e0fffe0b 	ldhu	r3,-8(fp)
 8245118:	10c0000d 	sth	r3,0(r2)
   pup->ud_dstp = fport;
 824511c:	e0bff617 	ldw	r2,-40(fp)
 8245120:	e0fffd0b 	ldhu	r3,-12(fp)
 8245124:	10c0008d 	sth	r3,2(r2)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 8245128:	e13ff617 	ldw	r4,-40(fp)
 824512c:	82452a00 	call	82452a0 <udpswap>
#endif   /* BYTE_ORDER */
   
#ifdef MULTI_HOMED
   /* getting the source IP address for a broadcast is a bit tricky: */
   if (p->fhost == 0xffffffff)
 8245130:	e0bfff17 	ldw	r2,-4(fp)
 8245134:	10800717 	ldw	r2,28(r2)
 8245138:	10bfffd8 	cmpnei	r2,r2,-1
 824513c:	10000f1e 	bne	r2,zero,824517c <udp_send+0x174>
   {
      if (!p->net)
 8245140:	e0bfff17 	ldw	r2,-4(fp)
 8245144:	10800617 	ldw	r2,24(r2)
 8245148:	1000071e 	bne	r2,zero,8245168 <udp_send+0x160>
      {
         dtrap();    /* programmer forgot to select iface */
 824514c:	822d5f00 	call	822d5f0 <dtrap>
         /* it would appear that the callers of udp_send() expect it
            to do cleanup on failure, so free the packet buffer here */
         udp_free(p);
 8245150:	e13fff17 	ldw	r4,-4(fp)
 8245154:	82455240 	call	8245524 <udp_free>
         UNLOCK_NET_RESOURCE(NET_RESID);
 8245158:	0009883a 	mov	r4,zero
 824515c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
         return ENP_NO_IFACE;
 8245160:	00bff784 	movi	r2,-34
 8245164:	00004906 	br	824528c <udp_send+0x284>
      }
      src_ip = p->net->n_ipaddr;
 8245168:	e0bfff17 	ldw	r2,-4(fp)
 824516c:	10800617 	ldw	r2,24(r2)
 8245170:	10800a17 	ldw	r2,40(r2)
 8245174:	e0bff515 	stw	r2,-44(fp)
 8245178:	00000506 	br	8245190 <udp_send+0x188>
   /* set the IP addresses in the IP header. The pseudo header used for
    * checksumming overlays the addresses on the IP header area in the
    * buffer, so setting them there (which we need to do for cksum
    * anyway) sets up for IP too.
    */
   src_ip = ip_mymach(p->fhost);
 824517c:	e0bfff17 	ldw	r2,-4(fp)
 8245180:	10800717 	ldw	r2,28(r2)
 8245184:	1009883a 	mov	r4,r2
 8245188:	82409f80 	call	82409f8 <ip_mymach>
 824518c:	e0bff515 	stw	r2,-44(fp)
   php.ph_src = src_ip;
 8245190:	e0bff517 	ldw	r2,-44(fp)
 8245194:	e0bffa15 	stw	r2,-24(fp)
   php.ph_dest = p->fhost;
 8245198:	e0bfff17 	ldw	r2,-4(fp)
 824519c:	10800717 	ldw	r2,28(r2)
 82451a0:	e0bffb15 	stw	r2,-20(fp)
#ifdef NO_UDP_CKSUM
   /* If no UDP checksum support, just zero the checksum field */
   pup->ud_cksum = 0;
#else
   /* finish filling in the pseudo header required for checksumming */
   php.ph_zero = 0;
 82451a4:	e03ffc05 	stb	zero,-16(fp)
   php.ph_prot = UDP_PROT;
 82451a8:	00800444 	movi	r2,17
 82451ac:	e0bffc45 	stb	r2,-15(fp)
   php.ph_len = pup->ud_len;
 82451b0:	e0bff617 	ldw	r2,-40(fp)
 82451b4:	1080010b 	ldhu	r2,4(r2)
 82451b8:	e0bffc8d 	sth	r2,-14(fp)
   pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 82451bc:	e0bffa04 	addi	r2,fp,-24
 82451c0:	01400184 	movi	r5,6
 82451c4:	1009883a 	mov	r4,r2
 82451c8:	82288100 	call	8228810 <cksum>
 82451cc:	1007883a 	mov	r3,r2
 82451d0:	e0bff617 	ldw	r2,-40(fp)
 82451d4:	10c0018d 	sth	r3,6(r2)
   pup->ud_cksum = ~cksum(pup, (udplen+1)>>1);
 82451d8:	e0bff717 	ldw	r2,-36(fp)
 82451dc:	10800044 	addi	r2,r2,1
 82451e0:	1005d07a 	srai	r2,r2,1
 82451e4:	100b883a 	mov	r5,r2
 82451e8:	e13ff617 	ldw	r4,-40(fp)
 82451ec:	82288100 	call	8228810 <cksum>
 82451f0:	0084303a 	nor	r2,zero,r2
 82451f4:	1007883a 	mov	r3,r2
 82451f8:	e0bff617 	ldw	r2,-40(fp)
 82451fc:	10c0018d 	sth	r3,6(r2)
   if (pup->ud_cksum == 0)
 8245200:	e0bff617 	ldw	r2,-40(fp)
 8245204:	1080018b 	ldhu	r2,6(r2)
 8245208:	10bfffcc 	andi	r2,r2,65535
 824520c:	1000031e 	bne	r2,zero,824521c <udp_send+0x214>
      pup->ud_cksum = 0xffff;
 8245210:	e0bff617 	ldw	r2,-40(fp)
 8245214:	00ffffc4 	movi	r3,-1
 8245218:	10c0018d 	sth	r3,6(r2)
#endif

   /* need to fill in IP addresses at this layer too */
   pip = (struct ip *)(p->nb_prot - sizeof(struct ip));
 824521c:	e0bfff17 	ldw	r2,-4(fp)
 8245220:	10800317 	ldw	r2,12(r2)
 8245224:	10bffb04 	addi	r2,r2,-20
 8245228:	e0bff815 	stw	r2,-32(fp)
   pip->ip_src = src_ip;
 824522c:	e0bff817 	ldw	r2,-32(fp)
 8245230:	e0fff517 	ldw	r3,-44(fp)
 8245234:	10c00315 	stw	r3,12(r2)
   pip->ip_dest = p->fhost;
 8245238:	e0bfff17 	ldw	r2,-4(fp)
 824523c:	10c00717 	ldw	r3,28(r2)
 8245240:	e0bff817 	ldw	r2,-32(fp)
 8245244:	10c00415 	stw	r3,16(r2)

   udp_mib.udpOutDatagrams++;
 8245248:	008209b4 	movhi	r2,2086
 824524c:	10ba9d04 	addi	r2,r2,-5516
 8245250:	10800317 	ldw	r2,12(r2)
 8245254:	10c00044 	addi	r3,r2,1
 8245258:	008209b4 	movhi	r2,2086
 824525c:	10ba9d04 	addi	r2,r2,-5516
 8245260:	10c00315 	stw	r3,12(r2)

   p->nb_plen = udplen;       /* nb_prot was adjusted above */
 8245264:	e0fff717 	ldw	r3,-36(fp)
 8245268:	e0bfff17 	ldw	r2,-4(fp)
 824526c:	10c00415 	stw	r3,16(r2)
   e = ip_write(UDP_PROT, p);
 8245270:	e17fff17 	ldw	r5,-4(fp)
 8245274:	01000444 	movi	r4,17
 8245278:	823f9a80 	call	823f9a8 <ip_write>
 824527c:	e0bff915 	stw	r2,-28(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 8245280:	0009883a 	mov	r4,zero
 8245284:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   return e;
 8245288:	e0bff917 	ldw	r2,-28(fp)
}
 824528c:	e037883a 	mov	sp,fp
 8245290:	dfc00117 	ldw	ra,4(sp)
 8245294:	df000017 	ldw	fp,0(sp)
 8245298:	dec00204 	addi	sp,sp,8
 824529c:	f800283a 	ret

082452a0 <udpswap>:
 */

#if (BYTE_ORDER == LITTLE_ENDIAN)
void
udpswap(struct udp *pup)
{
 82452a0:	defffe04 	addi	sp,sp,-8
 82452a4:	df000115 	stw	fp,4(sp)
 82452a8:	df000104 	addi	fp,sp,4
 82452ac:	e13fff15 	stw	r4,-4(fp)

   pup->ud_srcp = htons(pup->ud_srcp);
 82452b0:	e0bfff17 	ldw	r2,-4(fp)
 82452b4:	1080000b 	ldhu	r2,0(r2)
 82452b8:	10bfffcc 	andi	r2,r2,65535
 82452bc:	1004d23a 	srli	r2,r2,8
 82452c0:	1007883a 	mov	r3,r2
 82452c4:	e0bfff17 	ldw	r2,-4(fp)
 82452c8:	1080000b 	ldhu	r2,0(r2)
 82452cc:	10bfffcc 	andi	r2,r2,65535
 82452d0:	1004923a 	slli	r2,r2,8
 82452d4:	1884b03a 	or	r2,r3,r2
 82452d8:	1007883a 	mov	r3,r2
 82452dc:	e0bfff17 	ldw	r2,-4(fp)
 82452e0:	10c0000d 	sth	r3,0(r2)
   pup->ud_dstp = htons(pup->ud_dstp);
 82452e4:	e0bfff17 	ldw	r2,-4(fp)
 82452e8:	1080008b 	ldhu	r2,2(r2)
 82452ec:	10bfffcc 	andi	r2,r2,65535
 82452f0:	1004d23a 	srli	r2,r2,8
 82452f4:	1007883a 	mov	r3,r2
 82452f8:	e0bfff17 	ldw	r2,-4(fp)
 82452fc:	1080008b 	ldhu	r2,2(r2)
 8245300:	10bfffcc 	andi	r2,r2,65535
 8245304:	1004923a 	slli	r2,r2,8
 8245308:	1884b03a 	or	r2,r3,r2
 824530c:	1007883a 	mov	r3,r2
 8245310:	e0bfff17 	ldw	r2,-4(fp)
 8245314:	10c0008d 	sth	r3,2(r2)
   pup->ud_len = htons(pup->ud_len);
 8245318:	e0bfff17 	ldw	r2,-4(fp)
 824531c:	1080010b 	ldhu	r2,4(r2)
 8245320:	10bfffcc 	andi	r2,r2,65535
 8245324:	1004d23a 	srli	r2,r2,8
 8245328:	1007883a 	mov	r3,r2
 824532c:	e0bfff17 	ldw	r2,-4(fp)
 8245330:	1080010b 	ldhu	r2,4(r2)
 8245334:	10bfffcc 	andi	r2,r2,65535
 8245338:	1004923a 	slli	r2,r2,8
 824533c:	1884b03a 	or	r2,r3,r2
 8245340:	1007883a 	mov	r3,r2
 8245344:	e0bfff17 	ldw	r2,-4(fp)
 8245348:	10c0010d 	sth	r3,4(r2)
   pup->ud_cksum = htons(pup->ud_cksum);
 824534c:	e0bfff17 	ldw	r2,-4(fp)
 8245350:	1080018b 	ldhu	r2,6(r2)
 8245354:	10bfffcc 	andi	r2,r2,65535
 8245358:	1004d23a 	srli	r2,r2,8
 824535c:	1007883a 	mov	r3,r2
 8245360:	e0bfff17 	ldw	r2,-4(fp)
 8245364:	1080018b 	ldhu	r2,6(r2)
 8245368:	10bfffcc 	andi	r2,r2,65535
 824536c:	1004923a 	slli	r2,r2,8
 8245370:	1884b03a 	or	r2,r3,r2
 8245374:	1007883a 	mov	r3,r2
 8245378:	e0bfff17 	ldw	r2,-4(fp)
 824537c:	10c0018d 	sth	r3,6(r2)
}
 8245380:	0001883a 	nop
 8245384:	e037883a 	mov	sp,fp
 8245388:	df000017 	ldw	fp,0(sp)
 824538c:	dec00104 	addi	sp,sp,4
 8245390:	f800283a 	ret

08245394 <udp_socket>:
#define  MINSOCKET   1200
static unshort usocket = 0;   /* next socket to grab */

unshort
udp_socket(void)
{
 8245394:	defffe04 	addi	sp,sp,-8
 8245398:	df000115 	stw	fp,4(sp)
 824539c:	df000104 	addi	fp,sp,4
   UDPCONN tmp;

   if (usocket < MINSOCKET)
 82453a0:	d0a0d10b 	ldhu	r2,-31932(gp)
 82453a4:	10bfffcc 	andi	r2,r2,65535
 82453a8:	10812c28 	cmpgeui	r2,r2,1200
 82453ac:	10000a1e 	bne	r2,zero,82453d8 <udp_socket+0x44>
   {
      /* logic for for init and after wraps */
      usocket = (unshort)(cticks & 0x7fff);
 82453b0:	d0a0a817 	ldw	r2,-32096(gp)
 82453b4:	109fffcc 	andi	r2,r2,32767
 82453b8:	d0a0d10d 	sth	r2,-31932(gp)
      if (usocket < MINSOCKET)
 82453bc:	d0a0d10b 	ldhu	r2,-31932(gp)
 82453c0:	10bfffcc 	andi	r2,r2,65535
 82453c4:	10812c28 	cmpgeui	r2,r2,1200
 82453c8:	1000031e 	bne	r2,zero,82453d8 <udp_socket+0x44>
         usocket += MINSOCKET;
 82453cc:	d0a0d10b 	ldhu	r2,-31932(gp)
 82453d0:	10812c04 	addi	r2,r2,1200
 82453d4:	d0a0d10d 	sth	r2,-31932(gp)
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 82453d8:	d0a09c17 	ldw	r2,-32144(gp)
 82453dc:	e0bfff15 	stw	r2,-4(fp)
 82453e0:	00000f06 	br	8245420 <udp_socket+0x8c>
   {
      if (tmp->u_lport == usocket)
 82453e4:	e0bfff17 	ldw	r2,-4(fp)
 82453e8:	10c0018b 	ldhu	r3,6(r2)
 82453ec:	d0a0d10b 	ldhu	r2,-31932(gp)
 82453f0:	18ffffcc 	andi	r3,r3,65535
 82453f4:	10bfffcc 	andi	r2,r2,65535
 82453f8:	1880061e 	bne	r3,r2,8245414 <udp_socket+0x80>
      {
         usocket++;     /* bump socket number */
 82453fc:	d0a0d10b 	ldhu	r2,-31932(gp)
 8245400:	10800044 	addi	r2,r2,1
 8245404:	d0a0d10d 	sth	r2,-31932(gp)
         tmp = firstudp;   /* restart scan */
 8245408:	d0a09c17 	ldw	r2,-32144(gp)
 824540c:	e0bfff15 	stw	r2,-4(fp)
         continue;
 8245410:	0001883a 	nop
      usocket = (unshort)(cticks & 0x7fff);
      if (usocket < MINSOCKET)
         usocket += MINSOCKET;
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 8245414:	e0bfff17 	ldw	r2,-4(fp)
 8245418:	10800017 	ldw	r2,0(r2)
 824541c:	e0bfff15 	stw	r2,-4(fp)
 8245420:	e0bfff17 	ldw	r2,-4(fp)
 8245424:	103fef1e 	bne	r2,zero,82453e4 <udp_socket+0x50>
         usocket++;     /* bump socket number */
         tmp = firstudp;   /* restart scan */
         continue;
      }
   }
   return usocket++;
 8245428:	d0a0d10b 	ldhu	r2,-31932(gp)
 824542c:	10c00044 	addi	r3,r2,1
 8245430:	d0e0d10d 	sth	r3,-31932(gp)
}
 8245434:	e037883a 	mov	sp,fp
 8245438:	df000017 	ldw	fp,0(sp)
 824543c:	dec00104 	addi	sp,sp,4
 8245440:	f800283a 	ret

08245444 <udp_alloc>:
 * RETURNS:  Returns buffer, or NULL in no buffer was available. 
 */

PACKET
udp_alloc(int datalen, int optlen)
{
 8245444:	defffa04 	addi	sp,sp,-24
 8245448:	dfc00515 	stw	ra,20(sp)
 824544c:	df000415 	stw	fp,16(sp)
 8245450:	df000404 	addi	fp,sp,16
 8245454:	e13ffe15 	stw	r4,-8(fp)
 8245458:	e17fff15 	stw	r5,-4(fp)
   int   len;
   PACKET p;

   len = (datalen + sizeof(struct udp) + 1) & ~1;
 824545c:	e0bffe17 	ldw	r2,-8(fp)
 8245460:	10800244 	addi	r2,r2,9
 8245464:	1007883a 	mov	r3,r2
 8245468:	00bfff84 	movi	r2,-2
 824546c:	1884703a 	and	r2,r3,r2
 8245470:	e0bffc15 	stw	r2,-16(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8245474:	01000084 	movi	r4,2
 8245478:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   p = pk_alloc(len + UDPHDRSLEN + optlen);
 824547c:	e0bffc17 	ldw	r2,-16(fp)
 8245480:	10c00904 	addi	r3,r2,36
 8245484:	e0bfff17 	ldw	r2,-4(fp)
 8245488:	1885883a 	add	r2,r3,r2
 824548c:	1009883a 	mov	r4,r2
 8245490:	822ca480 	call	822ca48 <pk_alloc>
 8245494:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8245498:	01000084 	movi	r4,2
 824549c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>

   if (p != (PACKET)NULL)
 82454a0:	e0bffd17 	ldw	r2,-12(fp)
 82454a4:	10001026 	beq	r2,zero,82454e8 <udp_alloc+0xa4>
   {
      /* set prot pointers past end of UDP header  */
      len = sizeof(struct ip) + (optlen >> 2) + sizeof(struct udp);
 82454a8:	e0bfff17 	ldw	r2,-4(fp)
 82454ac:	1005d0ba 	srai	r2,r2,2
 82454b0:	10800704 	addi	r2,r2,28
 82454b4:	e0bffc15 	stw	r2,-16(fp)
      p->nb_prot += len;
 82454b8:	e0bffd17 	ldw	r2,-12(fp)
 82454bc:	10c00317 	ldw	r3,12(r2)
 82454c0:	e0bffc17 	ldw	r2,-16(fp)
 82454c4:	1887883a 	add	r3,r3,r2
 82454c8:	e0bffd17 	ldw	r2,-12(fp)
 82454cc:	10c00315 	stw	r3,12(r2)
      p->nb_plen -= len;
 82454d0:	e0bffd17 	ldw	r2,-12(fp)
 82454d4:	10c00417 	ldw	r3,16(r2)
 82454d8:	e0bffc17 	ldw	r2,-16(fp)
 82454dc:	1887c83a 	sub	r3,r3,r2
 82454e0:	e0bffd17 	ldw	r2,-12(fp)
 82454e4:	10c00415 	stw	r3,16(r2)
   }

   return (p);
 82454e8:	e0bffd17 	ldw	r2,-12(fp)
}
 82454ec:	e037883a 	mov	sp,fp
 82454f0:	dfc00117 	ldw	ra,4(sp)
 82454f4:	df000017 	ldw	fp,0(sp)
 82454f8:	dec00204 	addi	sp,sp,8
 82454fc:	f800283a 	ret

08245500 <udp_maxalloc>:
 *          returned value, the allocation will fail
 */

int
udp_maxalloc(void)
{
 8245500:	deffff04 	addi	sp,sp,-4
 8245504:	df000015 	stw	fp,0(sp)
 8245508:	d839883a 	mov	fp,sp
    * created is ((2^16 - 1) - (size of IP and UDP headers)) */
   return (0xFFFF - (sizeof (struct ip) + sizeof (struct udp)));
#else
   /* if heap buffers are not available, the largest size of a UDP datagram
    * is constrained by what will fit inside a big buffer */
   return (bigbufsiz - UDPHDRSLEN);
 824550c:	d0a03917 	ldw	r2,-32540(gp)
 8245510:	10bff704 	addi	r2,r2,-36
#endif
}
 8245514:	e037883a 	mov	sp,fp
 8245518:	df000017 	ldw	fp,0(sp)
 824551c:	dec00104 	addi	sp,sp,4
 8245520:	f800283a 	ret

08245524 <udp_free>:
 * RETURNS: void
 */

void
udp_free(PACKET p)
{
 8245524:	defffd04 	addi	sp,sp,-12
 8245528:	dfc00215 	stw	ra,8(sp)
 824552c:	df000115 	stw	fp,4(sp)
 8245530:	df000104 	addi	fp,sp,4
 8245534:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8245538:	01000084 	movi	r4,2
 824553c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   pk_free(p);
 8245540:	e13fff17 	ldw	r4,-4(fp)
 8245544:	822cd980 	call	822cd98 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8245548:	01000084 	movi	r4,2
 824554c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
}
 8245550:	0001883a 	nop
 8245554:	e037883a 	mov	sp,fp
 8245558:	dfc00117 	ldw	ra,4(sp)
 824555c:	df000017 	ldw	fp,0(sp)
 8245560:	dec00204 	addi	sp,sp,8
 8245564:	f800283a 	ret

08245568 <igmpv1_input>:
 * OUTPUT: This function returns IGMP_ERR if it is passed an "unknown"
 * packet type.  Otherwise, it returns IGMP_OK.
 */

int igmpv1_input(PACKET p)
{
 8245568:	defff804 	addi	sp,sp,-32
 824556c:	dfc00715 	stw	ra,28(sp)
 8245570:	df000615 	stw	fp,24(sp)
 8245574:	df000604 	addi	fp,sp,24
 8245578:	e13fff15 	stw	r4,-4(fp)
   struct igmp *  igmp;
   struct ip *    pip;
   struct in_multi * inm;
   NET netp  = p->net;
 824557c:	e0bfff17 	ldw	r2,-4(fp)
 8245580:	10800617 	ldw	r2,24(r2)
 8245584:	e0bffc15 	stw	r2,-16(fp)
   int rc;
         
   pip = ip_head (p);
 8245588:	e0bfff17 	ldw	r2,-4(fp)
 824558c:	10800317 	ldw	r2,12(r2)
 8245590:	e0bffd15 	stw	r2,-12(fp)
   igmp = (struct igmp *) (ip_data (pip));
 8245594:	e0bffd17 	ldw	r2,-12(fp)
 8245598:	10800003 	ldbu	r2,0(r2)
 824559c:	10803fcc 	andi	r2,r2,255
 82455a0:	108003cc 	andi	r2,r2,15
 82455a4:	1085883a 	add	r2,r2,r2
 82455a8:	1085883a 	add	r2,r2,r2
 82455ac:	1007883a 	mov	r3,r2
 82455b0:	e0bffd17 	ldw	r2,-12(fp)
 82455b4:	10c5883a 	add	r2,r2,r3
 82455b8:	e0bffe15 	stw	r2,-8(fp)

   switch (igmp->igmp_type) 
 82455bc:	e0bffe17 	ldw	r2,-8(fp)
 82455c0:	10800003 	ldbu	r2,0(r2)
 82455c4:	10803fcc 	andi	r2,r2,255
 82455c8:	10c00460 	cmpeqi	r3,r2,17
 82455cc:	1800031e 	bne	r3,zero,82455dc <igmpv1_input+0x74>
 82455d0:	108004a0 	cmpeqi	r2,r2,18
 82455d4:	1000571e 	bne	r2,zero,8245734 <igmpv1_input+0x1cc>
 82455d8:	00007606 	br	82457b4 <igmpv1_input+0x24c>
   {
   case IGMP_HOST_MEMBERSHIP_QUERY:
      ++igmpstats.igmpv1mode_v1_queries_rcvd;
 82455dc:	008209b4 	movhi	r2,2086
 82455e0:	10b84104 	addi	r2,r2,-7932
 82455e4:	10800117 	ldw	r2,4(r2)
 82455e8:	10c00044 	addi	r3,r2,1
 82455ec:	008209b4 	movhi	r2,2086
 82455f0:	10b84104 	addi	r2,r2,-7932
 82455f4:	10c00115 	stw	r3,4(r2)
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 82455f8:	e0bffc17 	ldw	r2,-16(fp)
 82455fc:	10802c17 	ldw	r2,176(r2)
 8245600:	e0bffa15 	stw	r2,-24(fp)
 8245604:	00004706 	br	8245724 <igmpv1_input+0x1bc>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (inm->inm_addr == 0)
 8245608:	e0bffa17 	ldw	r2,-24(fp)
 824560c:	10800017 	ldw	r2,0(r2)
 8245610:	10004026 	beq	r2,zero,8245714 <igmpv1_input+0x1ac>
            continue;
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 8245614:	e0bffa17 	ldw	r2,-24(fp)
 8245618:	10c00017 	ldw	r3,0(r2)
 824561c:	d0a08817 	ldw	r2,-32224(gp)
 8245620:	18803d26 	beq	r3,r2,8245718 <igmpv1_input+0x1b0>
         {
            if (inm->inm_timer == 0)
 8245624:	e0bffa17 	ldw	r2,-24(fp)
 8245628:	10800317 	ldw	r2,12(r2)
 824562c:	10003a1e 	bne	r2,zero,8245718 <igmpv1_input+0x1b0>
            {
               inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 8245630:	008209b4 	movhi	r2,2086
 8245634:	10ba8304 	addi	r2,r2,-5620
 8245638:	10c00217 	ldw	r3,8(r2)
 824563c:	008209b4 	movhi	r2,2086
 8245640:	10b83d04 	addi	r2,r2,-7948
 8245644:	10800017 	ldw	r2,0(r2)
 8245648:	10800a17 	ldw	r2,40(r2)
 824564c:	1008d63a 	srli	r4,r2,24
 8245650:	008209b4 	movhi	r2,2086
 8245654:	10b83d04 	addi	r2,r2,-7948
 8245658:	10800017 	ldw	r2,0(r2)
 824565c:	10800a17 	ldw	r2,40(r2)
 8245660:	1004d23a 	srli	r2,r2,8
 8245664:	10bfc00c 	andi	r2,r2,65280
 8245668:	2088b03a 	or	r4,r4,r2
 824566c:	008209b4 	movhi	r2,2086
 8245670:	10b83d04 	addi	r2,r2,-7948
 8245674:	10800017 	ldw	r2,0(r2)
 8245678:	10800a17 	ldw	r2,40(r2)
 824567c:	10bfc00c 	andi	r2,r2,65280
 8245680:	1004923a 	slli	r2,r2,8
 8245684:	2088b03a 	or	r4,r4,r2
 8245688:	008209b4 	movhi	r2,2086
 824568c:	10b83d04 	addi	r2,r2,-7948
 8245690:	10800017 	ldw	r2,0(r2)
 8245694:	10800a17 	ldw	r2,40(r2)
 8245698:	1004963a 	slli	r2,r2,24
 824569c:	2084b03a 	or	r2,r4,r2
 82456a0:	1887883a 	add	r3,r3,r2
 82456a4:	e0bffa17 	ldw	r2,-24(fp)
 82456a8:	10800017 	ldw	r2,0(r2)
 82456ac:	1008d63a 	srli	r4,r2,24
 82456b0:	e0bffa17 	ldw	r2,-24(fp)
 82456b4:	10800017 	ldw	r2,0(r2)
 82456b8:	1004d23a 	srli	r2,r2,8
 82456bc:	10bfc00c 	andi	r2,r2,65280
 82456c0:	2088b03a 	or	r4,r4,r2
 82456c4:	e0bffa17 	ldw	r2,-24(fp)
 82456c8:	10800017 	ldw	r2,0(r2)
 82456cc:	10bfc00c 	andi	r2,r2,65280
 82456d0:	1004923a 	slli	r2,r2,8
 82456d4:	2088b03a 	or	r4,r4,r2
 82456d8:	e0bffa17 	ldw	r2,-24(fp)
 82456dc:	10800017 	ldw	r2,0(r2)
 82456e0:	1004963a 	slli	r2,r2,24
 82456e4:	2084b03a 	or	r2,r4,r2
 82456e8:	1885883a 	add	r2,r3,r2
 82456ec:	01400c84 	movi	r5,50
 82456f0:	1009883a 	mov	r4,r2
 82456f4:	8202cd00 	call	8202cd0 <__umodsi3>
 82456f8:	10c00044 	addi	r3,r2,1
 82456fc:	e0bffa17 	ldw	r2,-24(fp)
 8245700:	10c00315 	stw	r3,12(r2)
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
 8245704:	d0a08617 	ldw	r2,-32232(gp)
 8245708:	10800044 	addi	r2,r2,1
 824570c:	d0a08615 	stw	r2,-32232(gp)
 8245710:	00000106 	br	8245718 <igmpv1_input+0x1b0>
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (inm->inm_addr == 0)
            continue;
 8245714:	0001883a 	nop
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 8245718:	e0bffa17 	ldw	r2,-24(fp)
 824571c:	10800517 	ldw	r2,20(r2)
 8245720:	e0bffa15 	stw	r2,-24(fp)
 8245724:	e0bffa17 	ldw	r2,-24(fp)
 8245728:	103fb71e 	bne	r2,zero,8245608 <igmpv1_input+0xa0>
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
            }   
         }
      }
      rc = IGMP_OK;
 824572c:	e03ffb15 	stw	zero,-20(fp)
      break;
 8245730:	00002a06 	br	82457dc <igmpv1_input+0x274>

   case IGMP_HOST_MEMBERSHIP_REPORT:
      ++igmpstats.igmpv1mode_v1_reports_rcvd;
 8245734:	008209b4 	movhi	r2,2086
 8245738:	10b84104 	addi	r2,r2,-7932
 824573c:	10800217 	ldw	r2,8(r2)
 8245740:	10c00044 	addi	r3,r2,1
 8245744:	008209b4 	movhi	r2,2086
 8245748:	10b84104 	addi	r2,r2,-7932
 824574c:	10c00215 	stw	r3,8(r2)
      /*
       * If we belong to the group being reported and have a 
       * running timer for that group, stop our timer for that 
       * group.
       */
      inm = lookup_mcast(igmp->igmp_group, netp);
 8245750:	e0bffe17 	ldw	r2,-8(fp)
 8245754:	10800117 	ldw	r2,4(r2)
 8245758:	e17ffc17 	ldw	r5,-16(fp)
 824575c:	1009883a 	mov	r4,r2
 8245760:	8243c040 	call	8243c04 <lookup_mcast>
 8245764:	e0bffa15 	stw	r2,-24(fp)
      if (inm != NULL) 
 8245768:	e0bffa17 	ldw	r2,-24(fp)
 824576c:	10000f26 	beq	r2,zero,82457ac <igmpv1_input+0x244>
      {
         if (inm->inm_timer > 0)
 8245770:	e0bffa17 	ldw	r2,-24(fp)
 8245774:	10800317 	ldw	r2,12(r2)
 8245778:	10000c26 	beq	r2,zero,82457ac <igmpv1_input+0x244>
         {
            inm->inm_timer = 0;
 824577c:	e0bffa17 	ldw	r2,-24(fp)
 8245780:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 8245784:	d0a08617 	ldw	r2,-32232(gp)
 8245788:	10bfffc4 	addi	r2,r2,-1
 824578c:	d0a08615 	stw	r2,-32232(gp)
            ++igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer;
 8245790:	008209b4 	movhi	r2,2086
 8245794:	10b84104 	addi	r2,r2,-7932
 8245798:	10800317 	ldw	r2,12(r2)
 824579c:	10c00044 	addi	r3,r2,1
 82457a0:	008209b4 	movhi	r2,2086
 82457a4:	10b84104 	addi	r2,r2,-7932
 82457a8:	10c00315 	stw	r3,12(r2)
         }
      }
      rc = IGMP_OK;
 82457ac:	e03ffb15 	stw	zero,-20(fp)
      break;
 82457b0:	00000a06 	br	82457dc <igmpv1_input+0x274>
      
   default:
      ++igmpstats.igmpv1mode_unknown_pkttype;
 82457b4:	008209b4 	movhi	r2,2086
 82457b8:	10b84104 	addi	r2,r2,-7932
 82457bc:	10801017 	ldw	r2,64(r2)
 82457c0:	10c00044 	addi	r3,r2,1
 82457c4:	008209b4 	movhi	r2,2086
 82457c8:	10b84104 	addi	r2,r2,-7932
 82457cc:	10c01015 	stw	r3,64(r2)
      rc = IGMP_ERR;
 82457d0:	00bfffc4 	movi	r2,-1
 82457d4:	e0bffb15 	stw	r2,-20(fp)
      break;   
 82457d8:	0001883a 	nop
   }

   /* we're done with the received packet; return packet buffer back 
    * to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 82457dc:	01000084 	movi	r4,2
 82457e0:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   pk_free(p);
 82457e4:	e13fff17 	ldw	r4,-4(fp)
 82457e8:	822cd980 	call	822cd98 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82457ec:	01000084 	movi	r4,2
 82457f0:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      
   return rc;
 82457f4:	e0bffb17 	ldw	r2,-20(fp)
}
 82457f8:	e037883a 	mov	sp,fp
 82457fc:	dfc00117 	ldw	ra,4(sp)
 8245800:	df000017 	ldw	fp,0(sp)
 8245804:	dec00204 	addi	sp,sp,8
 8245808:	f800283a 	ret

0824580c <igmpv2_input>:
 * from igmpv2_process_report (), IGMP_OK (for a received Leave Group
 * message only), or IGMP_ERR (for a message of an "unknown" type).
 */

int igmpv2_input (PACKET p)
{
 824580c:	defff904 	addi	sp,sp,-28
 8245810:	dfc00615 	stw	ra,24(sp)
 8245814:	df000515 	stw	fp,20(sp)
 8245818:	df000504 	addi	fp,sp,20
 824581c:	e13fff15 	stw	r4,-4(fp)
   struct igmp * igmp;
   struct ip * pip;
   u_char type;
   int rc;

   pip = ip_head (p);    
 8245820:	e0bfff17 	ldw	r2,-4(fp)
 8245824:	10800317 	ldw	r2,12(r2)
 8245828:	e0bffc15 	stw	r2,-16(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 824582c:	e0bffc17 	ldw	r2,-16(fp)
 8245830:	10800003 	ldbu	r2,0(r2)
 8245834:	10803fcc 	andi	r2,r2,255
 8245838:	108003cc 	andi	r2,r2,15
 824583c:	1085883a 	add	r2,r2,r2
 8245840:	1085883a 	add	r2,r2,r2
 8245844:	1007883a 	mov	r3,r2
 8245848:	e0bffc17 	ldw	r2,-16(fp)
 824584c:	10c5883a 	add	r2,r2,r3
 8245850:	e0bffd15 	stw	r2,-12(fp)
   /* extract the IGMP packet type from received packet */
   type = igmp->igmp_type;
 8245854:	e0bffd17 	ldw	r2,-12(fp)
 8245858:	10800003 	ldbu	r2,0(r2)
 824585c:	e0bffe05 	stb	r2,-8(fp)

   switch (type) 
 8245860:	e0bffe03 	ldbu	r2,-8(fp)
 8245864:	10c004a0 	cmpeqi	r3,r2,18
 8245868:	18000e1e 	bne	r3,zero,82458a4 <igmpv2_input+0x98>
 824586c:	10c004c8 	cmpgei	r3,r2,19
 8245870:	1800031e 	bne	r3,zero,8245880 <igmpv2_input+0x74>
 8245874:	10800460 	cmpeqi	r2,r2,17
 8245878:	1000061e 	bne	r2,zero,8245894 <igmpv2_input+0x88>
 824587c:	00001606 	br	82458d8 <igmpv2_input+0xcc>
 8245880:	10c005a0 	cmpeqi	r3,r2,22
 8245884:	1800071e 	bne	r3,zero,82458a4 <igmpv2_input+0x98>
 8245888:	108005e0 	cmpeqi	r2,r2,23
 824588c:	1000091e 	bne	r2,zero,82458b4 <igmpv2_input+0xa8>
 8245890:	00001106 	br	82458d8 <igmpv2_input+0xcc>
   {
      case IGMP_HOST_MEMBERSHIP_QUERY:
         rc = igmpv2_process_query (p);
 8245894:	e13fff17 	ldw	r4,-4(fp)
 8245898:	8245a640 	call	8245a64 <igmpv2_process_query>
 824589c:	e0bffb15 	stw	r2,-20(fp)
         break;
 82458a0:	00001706 	br	8245900 <igmpv2_input+0xf4>

      case IGMP_HOST_MEMBERSHIP_REPORT:
      case IGMPv2_MEMBERSHIP_REPORT:
         rc = igmpv2_process_report (p);
 82458a4:	e13fff17 	ldw	r4,-4(fp)
 82458a8:	82459300 	call	8245930 <igmpv2_process_report>
 82458ac:	e0bffb15 	stw	r2,-20(fp)
         break;
 82458b0:	00001306 	br	8245900 <igmpv2_input+0xf4>
          * expect to receive such messages.  However, according to
          * RFC 2236, some implementations of an older version of the 
          * IGMPv2 specification send leave messages to the group 
          * being left.  If we do receive such a message, we will 
          * drop it. */       
         ++igmpstats.igmpv2mode_v2_leave_msgs_rcvd;
 82458b4:	008209b4 	movhi	r2,2086
 82458b8:	10b84104 	addi	r2,r2,-7932
 82458bc:	10800917 	ldw	r2,36(r2)
 82458c0:	10c00044 	addi	r3,r2,1
 82458c4:	008209b4 	movhi	r2,2086
 82458c8:	10b84104 	addi	r2,r2,-7932
 82458cc:	10c00915 	stw	r3,36(r2)
         rc = IGMP_OK;
 82458d0:	e03ffb15 	stw	zero,-20(fp)
         break;               
 82458d4:	00000a06 	br	8245900 <igmpv2_input+0xf4>

      default:     
         ++igmpstats.igmpv2mode_unknown_pkttype;
 82458d8:	008209b4 	movhi	r2,2086
 82458dc:	10b84104 	addi	r2,r2,-7932
 82458e0:	10801517 	ldw	r2,84(r2)
 82458e4:	10c00044 	addi	r3,r2,1
 82458e8:	008209b4 	movhi	r2,2086
 82458ec:	10b84104 	addi	r2,r2,-7932
 82458f0:	10c01515 	stw	r3,84(r2)
         rc = IGMP_ERR;         
 82458f4:	00bfffc4 	movi	r2,-1
 82458f8:	e0bffb15 	stw	r2,-20(fp)
         break;
 82458fc:	0001883a 	nop
   } /* end SWITCH */

   /* we're done processing the received packet; return packet buffer 
    * back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8245900:	01000084 	movi	r4,2
 8245904:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   pk_free(p);
 8245908:	e13fff17 	ldw	r4,-4(fp)
 824590c:	822cd980 	call	822cd98 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8245910:	01000084 	movi	r4,2
 8245914:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
   
   return rc;
 8245918:	e0bffb17 	ldw	r2,-20(fp)
}
 824591c:	e037883a 	mov	sp,fp
 8245920:	dfc00117 	ldw	ra,4(sp)
 8245924:	df000017 	ldw	fp,0(sp)
 8245928:	dec00204 	addi	sp,sp,8
 824592c:	f800283a 	ret

08245930 <igmpv2_process_report>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_report (PACKET p)
{
 8245930:	defff904 	addi	sp,sp,-28
 8245934:	dfc00615 	stw	ra,24(sp)
 8245938:	df000515 	stw	fp,20(sp)
 824593c:	df000504 	addi	fp,sp,20
 8245940:	e13fff15 	stw	r4,-4(fp)
   struct igmp * igmp;
   struct ip * pip;
   NET netp;
   struct in_multi * inm;

   netp = p->net;
 8245944:	e0bfff17 	ldw	r2,-4(fp)
 8245948:	10800617 	ldw	r2,24(r2)
 824594c:	e0bffb15 	stw	r2,-20(fp)
   pip = ip_head (p);
 8245950:	e0bfff17 	ldw	r2,-4(fp)
 8245954:	10800317 	ldw	r2,12(r2)
 8245958:	e0bffc15 	stw	r2,-16(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 824595c:	e0bffc17 	ldw	r2,-16(fp)
 8245960:	10800003 	ldbu	r2,0(r2)
 8245964:	10803fcc 	andi	r2,r2,255
 8245968:	108003cc 	andi	r2,r2,15
 824596c:	1085883a 	add	r2,r2,r2
 8245970:	1085883a 	add	r2,r2,r2
 8245974:	1007883a 	mov	r3,r2
 8245978:	e0bffc17 	ldw	r2,-16(fp)
 824597c:	10c5883a 	add	r2,r2,r3
 8245980:	e0bffd15 	stw	r2,-12(fp)
    * processing IGMPv2 packets (it has "downgraded" itself because
    * there are IGMPv1 routers on that network); however, we do not
    * know that, and hence we don't cancel our timer (for the 
    * subsequent transmission of a IGMPv1 report).
    */
   inm = lookup_mcast(igmp->igmp_group, netp);
 8245984:	e0bffd17 	ldw	r2,-12(fp)
 8245988:	10800117 	ldw	r2,4(r2)
 824598c:	e17ffb17 	ldw	r5,-20(fp)
 8245990:	1009883a 	mov	r4,r2
 8245994:	8243c040 	call	8243c04 <lookup_mcast>
 8245998:	e0bffe15 	stw	r2,-8(fp)
   if (inm != NULL) 
 824599c:	e0bffe17 	ldw	r2,-8(fp)
 82459a0:	10002326 	beq	r2,zero,8245a30 <igmpv2_process_report+0x100>
   {
      if (inm->inm_timer != 0)
 82459a4:	e0bffe17 	ldw	r2,-8(fp)
 82459a8:	10800317 	ldw	r2,12(r2)
 82459ac:	10001826 	beq	r2,zero,8245a10 <igmpv2_process_report+0xe0>
      {
         /* we have a timer running */
         if (!(netp->igmpv1_rtr_present && 
 82459b0:	e0bffb17 	ldw	r2,-20(fp)
 82459b4:	10802d03 	ldbu	r2,180(r2)
 82459b8:	10803fcc 	andi	r2,r2,255
 82459bc:	10000526 	beq	r2,zero,82459d4 <igmpv2_process_report+0xa4>
             igmp->igmp_type == IGMPv2_MEMBERSHIP_REPORT))
 82459c0:	e0bffd17 	ldw	r2,-12(fp)
 82459c4:	10800003 	ldbu	r2,0(r2)
   if (inm != NULL) 
   {
      if (inm->inm_timer != 0)
      {
         /* we have a timer running */
         if (!(netp->igmpv1_rtr_present && 
 82459c8:	10803fcc 	andi	r2,r2,255
 82459cc:	108005a0 	cmpeqi	r2,r2,22
 82459d0:	10001e1e 	bne	r2,zero,8245a4c <igmpv2_process_report+0x11c>
             igmp->igmp_type == IGMPv2_MEMBERSHIP_REPORT))
         {
            /* cancel timer */
            inm->inm_timer = 0;
 82459d4:	e0bffe17 	ldw	r2,-8(fp)
 82459d8:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 82459dc:	d0a08617 	ldw	r2,-32232(gp)
 82459e0:	10bfffc4 	addi	r2,r2,-1
 82459e4:	d0a08615 	stw	r2,-32232(gp)
            /* indicate that we are not the last host to send a 
             * report for this group */
            inm->last2send_report = IGMP_FALSE;
 82459e8:	e0bffe17 	ldw	r2,-8(fp)
 82459ec:	10000405 	stb	zero,16(r2)
            ++igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer;
 82459f0:	008209b4 	movhi	r2,2086
 82459f4:	10b84104 	addi	r2,r2,-7932
 82459f8:	10800717 	ldw	r2,28(r2)
 82459fc:	10c00044 	addi	r3,r2,1
 8245a00:	008209b4 	movhi	r2,2086
 8245a04:	10b84104 	addi	r2,r2,-7932
 8245a08:	10c00715 	stw	r3,28(r2)
 8245a0c:	00000f06 	br	8245a4c <igmpv2_process_report+0x11c>
      else
      {
         /* we don't have a timer running; perhaps the source
          * host has just joined the group, and has sent an
          * unsolicited report */
         ++igmpstats.igmpv2mode_v12_reports_rcvd_no_timer;   
 8245a10:	008209b4 	movhi	r2,2086
 8245a14:	10b84104 	addi	r2,r2,-7932
 8245a18:	10800817 	ldw	r2,32(r2)
 8245a1c:	10c00044 	addi	r3,r2,1
 8245a20:	008209b4 	movhi	r2,2086
 8245a24:	10b84104 	addi	r2,r2,-7932
 8245a28:	10c00815 	stw	r3,32(r2)
 8245a2c:	00000706 	br	8245a4c <igmpv2_process_report+0x11c>
       * on that interface.  Even if imperfect filtering at the 
       * device level causes reports for unregistered groups to 
       * be passed up to the IP module, ip_rcv_phase2 () is 
       * responsible for dropping them, and so we should never
       * receive such packets. */
      ++igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd;
 8245a30:	008209b4 	movhi	r2,2086
 8245a34:	10b84104 	addi	r2,r2,-7932
 8245a38:	10801317 	ldw	r2,76(r2)
 8245a3c:	10c00044 	addi	r3,r2,1
 8245a40:	008209b4 	movhi	r2,2086
 8245a44:	10b84104 	addi	r2,r2,-7932
 8245a48:	10c01315 	stw	r3,76(r2)
   }
   
   return IGMP_OK;   
 8245a4c:	0005883a 	mov	r2,zero
}
 8245a50:	e037883a 	mov	sp,fp
 8245a54:	dfc00117 	ldw	ra,4(sp)
 8245a58:	df000017 	ldw	fp,0(sp)
 8245a5c:	dec00204 	addi	sp,sp,8
 8245a60:	f800283a 	ret

08245a64 <igmpv2_process_query>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_query (PACKET p)
{
 8245a64:	defff804 	addi	sp,sp,-32
 8245a68:	dfc00715 	stw	ra,28(sp)
 8245a6c:	df000615 	stw	fp,24(sp)
 8245a70:	df000604 	addi	fp,sp,24
 8245a74:	e13fff15 	stw	r4,-4(fp)
   NET netp;
   u_short max_resp_time;
   u_char process_all;
   struct in_multi * inm;

   netp = p->net;
 8245a78:	e0bfff17 	ldw	r2,-4(fp)
 8245a7c:	10800617 	ldw	r2,24(r2)
 8245a80:	e0bffc15 	stw	r2,-16(fp)
   pip = ip_head (p);
 8245a84:	e0bfff17 	ldw	r2,-4(fp)
 8245a88:	10800317 	ldw	r2,12(r2)
 8245a8c:	e0bffd15 	stw	r2,-12(fp)
   igmp = (struct igmp *) (ip_data (pip));
 8245a90:	e0bffd17 	ldw	r2,-12(fp)
 8245a94:	10800003 	ldbu	r2,0(r2)
 8245a98:	10803fcc 	andi	r2,r2,255
 8245a9c:	108003cc 	andi	r2,r2,15
 8245aa0:	1085883a 	add	r2,r2,r2
 8245aa4:	1085883a 	add	r2,r2,r2
 8245aa8:	1007883a 	mov	r3,r2
 8245aac:	e0bffd17 	ldw	r2,-12(fp)
 8245ab0:	10c5883a 	add	r2,r2,r3
 8245ab4:	e0bffe15 	stw	r2,-8(fp)

   if (igmp->igmp_code == 0)
 8245ab8:	e0bffe17 	ldw	r2,-8(fp)
 8245abc:	10800043 	ldbu	r2,1(r2)
 8245ac0:	10803fcc 	andi	r2,r2,255
 8245ac4:	1000121e 	bne	r2,zero,8245b10 <igmpv2_process_query+0xac>
   {
      /* this is a IGMPv1 Host Membership Query */
      netp->igmpv1_rtr_present = IGMP_TRUE;
 8245ac8:	e0bffc17 	ldw	r2,-16(fp)
 8245acc:	00c00044 	movi	r3,1
 8245ad0:	10c02d05 	stb	r3,180(r2)
      netp->igmpv1_query_rcvd_time = cticks;      
 8245ad4:	d0e0a817 	ldw	r3,-32096(gp)
 8245ad8:	e0bffc17 	ldw	r2,-16(fp)
 8245adc:	10c02e15 	stw	r3,184(r2)
      ++igmpstats.igmpv2mode_v1_queries_rcvd;
 8245ae0:	008209b4 	movhi	r2,2086
 8245ae4:	10b84104 	addi	r2,r2,-7932
 8245ae8:	10800417 	ldw	r2,16(r2)
 8245aec:	10c00044 	addi	r3,r2,1
 8245af0:	008209b4 	movhi	r2,2086
 8245af4:	10b84104 	addi	r2,r2,-7932
 8245af8:	10c00415 	stw	r3,16(r2)
      /* set maximum time to respond to the equivalent of 10 
       * seconds worth of "ticks" (the timeout routine is
       * intended to be invoked PR_FASTHZ (5) times a second,
       * so each tick is equal to 200 ms) */
      max_resp_time = IGMP_MAX_HOST_REPORT_DELAY * PR_FASTHZ;
 8245afc:	00800c84 	movi	r2,50
 8245b00:	e0bffa0d 	sth	r2,-24(fp)
      process_all = IGMP_TRUE;
 8245b04:	00800044 	movi	r2,1
 8245b08:	e0bffa85 	stb	r2,-22(fp)
 8245b0c:	00001d06 	br	8245b84 <igmpv2_process_query+0x120>
   }
   else
   {
      /* this is either a IGMPv2 General Query or 
       * a IGMPv2 Group-Specific Query */
      if (igmp->igmp_group == 0)
 8245b10:	e0bffe17 	ldw	r2,-8(fp)
 8245b14:	10800117 	ldw	r2,4(r2)
 8245b18:	10000a1e 	bne	r2,zero,8245b44 <igmpv2_process_query+0xe0>
      {
         /* this is a IGMPv2 General Query */
         ++igmpstats.igmpv2mode_v2_general_queries_rcvd;
 8245b1c:	008209b4 	movhi	r2,2086
 8245b20:	10b84104 	addi	r2,r2,-7932
 8245b24:	10800517 	ldw	r2,20(r2)
 8245b28:	10c00044 	addi	r3,r2,1
 8245b2c:	008209b4 	movhi	r2,2086
 8245b30:	10b84104 	addi	r2,r2,-7932
 8245b34:	10c00515 	stw	r3,20(r2)
         process_all = IGMP_TRUE;
 8245b38:	00800044 	movi	r2,1
 8245b3c:	e0bffa85 	stb	r2,-22(fp)
 8245b40:	00000806 	br	8245b64 <igmpv2_process_query+0x100>
      }
      else
      {
         /* this is a IGMPv2 Group-Specific Query */       
         ++igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd;
 8245b44:	008209b4 	movhi	r2,2086
 8245b48:	10b84104 	addi	r2,r2,-7932
 8245b4c:	10800617 	ldw	r2,24(r2)
 8245b50:	10c00044 	addi	r3,r2,1
 8245b54:	008209b4 	movhi	r2,2086
 8245b58:	10b84104 	addi	r2,r2,-7932
 8245b5c:	10c00615 	stw	r3,24(r2)
         process_all = IGMP_FALSE;
 8245b60:	e03ffa85 	stb	zero,-22(fp)
       * IGMPv2 General Query or a IGMPv2 Group-Specific Query,
       * set maximum time to respond to value extracted 
       * from received message. The value in the message
       * is in tenths of a second.  max_resp_time is in
       * units of ticks (where one tick is 200 ms) */
      max_resp_time = (igmp->igmp_code * PR_FASTHZ) / 10;
 8245b64:	e0bffe17 	ldw	r2,-8(fp)
 8245b68:	10800043 	ldbu	r2,1(r2)
 8245b6c:	10803fcc 	andi	r2,r2,255
 8245b70:	10800164 	muli	r2,r2,5
 8245b74:	01400284 	movi	r5,10
 8245b78:	1009883a 	mov	r4,r2
 8245b7c:	8202b740 	call	8202b74 <__divsi3>
 8245b80:	e0bffa0d 	sth	r2,-24(fp)
   
   /* process all entries in a link's multicast address linked
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
 8245b84:	e0bffa83 	ldbu	r2,-22(fp)
 8245b88:	10001726 	beq	r2,zero,8245be8 <igmpv2_process_query+0x184>
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 8245b8c:	e0bffc17 	ldw	r2,-16(fp)
 8245b90:	10802c17 	ldw	r2,176(r2)
 8245b94:	e0bffb15 	stw	r2,-20(fp)
 8245b98:	00001006 	br	8245bdc <igmpv2_process_query+0x178>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (!(inm->inm_addr)) continue;
 8245b9c:	e0bffb17 	ldw	r2,-20(fp)
 8245ba0:	10800017 	ldw	r2,0(r2)
 8245ba4:	10000926 	beq	r2,zero,8245bcc <igmpv2_process_query+0x168>
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 8245ba8:	e0bffb17 	ldw	r2,-20(fp)
 8245bac:	10c00017 	ldw	r3,0(r2)
 8245bb0:	d0a08817 	ldw	r2,-32224(gp)
 8245bb4:	18800626 	beq	r3,r2,8245bd0 <igmpv2_process_query+0x16c>
            igmpv2_chk_set_timer (inm, max_resp_time);
 8245bb8:	e0bffa0b 	ldhu	r2,-24(fp)
 8245bbc:	100b883a 	mov	r5,r2
 8245bc0:	e13ffb17 	ldw	r4,-20(fp)
 8245bc4:	8245c500 	call	8245c50 <igmpv2_chk_set_timer>
 8245bc8:	00000106 	br	8245bd0 <igmpv2_process_query+0x16c>
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (!(inm->inm_addr)) continue;
 8245bcc:	0001883a 	nop
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 8245bd0:	e0bffb17 	ldw	r2,-20(fp)
 8245bd4:	10800517 	ldw	r2,20(r2)
 8245bd8:	e0bffb15 	stw	r2,-20(fp)
 8245bdc:	e0bffb17 	ldw	r2,-20(fp)
 8245be0:	103fee1e 	bne	r2,zero,8245b9c <igmpv2_process_query+0x138>
 8245be4:	00001406 	br	8245c38 <igmpv2_process_query+0x1d4>
   {
      /* process one (for IGMPv2 Group-Specific Query) entry (the 
       * one that corresponds to the address listed in the received 
       * query) - it should be present in the link's multicast
       * address list */
      inm = lookup_mcast(igmp->igmp_group, netp);
 8245be8:	e0bffe17 	ldw	r2,-8(fp)
 8245bec:	10800117 	ldw	r2,4(r2)
 8245bf0:	e17ffc17 	ldw	r5,-16(fp)
 8245bf4:	1009883a 	mov	r4,r2
 8245bf8:	8243c040 	call	8243c04 <lookup_mcast>
 8245bfc:	e0bffb15 	stw	r2,-20(fp)
      if (inm != NULL)
 8245c00:	e0bffb17 	ldw	r2,-20(fp)
 8245c04:	10000526 	beq	r2,zero,8245c1c <igmpv2_process_query+0x1b8>
         igmpv2_chk_set_timer (inm, max_resp_time);
 8245c08:	e0bffa0b 	ldhu	r2,-24(fp)
 8245c0c:	100b883a 	mov	r5,r2
 8245c10:	e13ffb17 	ldw	r4,-20(fp)
 8245c14:	8245c500 	call	8245c50 <igmpv2_chk_set_timer>
 8245c18:	00000706 	br	8245c38 <igmpv2_process_query+0x1d4>
      else ++igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd;
 8245c1c:	008209b4 	movhi	r2,2086
 8245c20:	10b84104 	addi	r2,r2,-7932
 8245c24:	10801217 	ldw	r2,72(r2)
 8245c28:	10c00044 	addi	r3,r2,1
 8245c2c:	008209b4 	movhi	r2,2086
 8245c30:	10b84104 	addi	r2,r2,-7932
 8245c34:	10c01215 	stw	r3,72(r2)
   } /* end ELSE (process ALL) */
   
   /* return success; caller will the received packet back to the 
    * free pool */
   return IGMP_OK;
 8245c38:	0005883a 	mov	r2,zero
}
 8245c3c:	e037883a 	mov	sp,fp
 8245c40:	dfc00117 	ldw	ra,4(sp)
 8245c44:	df000017 	ldw	fp,0(sp)
 8245c48:	dec00204 	addi	sp,sp,8
 8245c4c:	f800283a 	ret

08245c50 <igmpv2_chk_set_timer>:
 *
 * OUTPUT: None.
 */

void igmpv2_chk_set_timer (struct in_multi * inm, u_short max_resp_time)
{  
 8245c50:	defffc04 	addi	sp,sp,-16
 8245c54:	dfc00315 	stw	ra,12(sp)
 8245c58:	df000215 	stw	fp,8(sp)
 8245c5c:	df000204 	addi	fp,sp,8
 8245c60:	e13ffe15 	stw	r4,-8(fp)
 8245c64:	2805883a 	mov	r2,r5
 8245c68:	e0bfff0d 	sth	r2,-4(fp)

    * Otherwise, the current timer for this group is scheduled 
    * to expire within the duration indicated in the Query 
    * message, so we let it continue. 
    */
   if ((inm->inm_timer > max_resp_time) ||
 8245c6c:	e0bffe17 	ldw	r2,-8(fp)
 8245c70:	10800317 	ldw	r2,12(r2)
 8245c74:	e0ffff0b 	ldhu	r3,-4(fp)
 8245c78:	18800336 	bltu	r3,r2,8245c88 <igmpv2_chk_set_timer+0x38>
       (inm->inm_timer == 0))
 8245c7c:	e0bffe17 	ldw	r2,-8(fp)
 8245c80:	10800317 	ldw	r2,12(r2)

    * Otherwise, the current timer for this group is scheduled 
    * to expire within the duration indicated in the Query 
    * message, so we let it continue. 
    */
   if ((inm->inm_timer > max_resp_time) ||
 8245c84:	10003d1e 	bne	r2,zero,8245d7c <igmpv2_chk_set_timer+0x12c>
       (inm->inm_timer == 0))
   {
      if (inm->inm_timer == 0) ++igmp_timers_are_running;
 8245c88:	e0bffe17 	ldw	r2,-8(fp)
 8245c8c:	10800317 	ldw	r2,12(r2)
 8245c90:	1000031e 	bne	r2,zero,8245ca0 <igmpv2_chk_set_timer+0x50>
 8245c94:	d0a08617 	ldw	r2,-32232(gp)
 8245c98:	10800044 	addi	r2,r2,1
 8245c9c:	d0a08615 	stw	r2,-32232(gp)
      inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY (max_resp_time, inm->inm_addr);                     
 8245ca0:	008209b4 	movhi	r2,2086
 8245ca4:	10ba8304 	addi	r2,r2,-5620
 8245ca8:	10c00217 	ldw	r3,8(r2)
 8245cac:	008209b4 	movhi	r2,2086
 8245cb0:	10b83d04 	addi	r2,r2,-7948
 8245cb4:	10800017 	ldw	r2,0(r2)
 8245cb8:	10800a17 	ldw	r2,40(r2)
 8245cbc:	1008d63a 	srli	r4,r2,24
 8245cc0:	008209b4 	movhi	r2,2086
 8245cc4:	10b83d04 	addi	r2,r2,-7948
 8245cc8:	10800017 	ldw	r2,0(r2)
 8245ccc:	10800a17 	ldw	r2,40(r2)
 8245cd0:	1004d23a 	srli	r2,r2,8
 8245cd4:	10bfc00c 	andi	r2,r2,65280
 8245cd8:	2088b03a 	or	r4,r4,r2
 8245cdc:	008209b4 	movhi	r2,2086
 8245ce0:	10b83d04 	addi	r2,r2,-7948
 8245ce4:	10800017 	ldw	r2,0(r2)
 8245ce8:	10800a17 	ldw	r2,40(r2)
 8245cec:	10bfc00c 	andi	r2,r2,65280
 8245cf0:	1004923a 	slli	r2,r2,8
 8245cf4:	2088b03a 	or	r4,r4,r2
 8245cf8:	008209b4 	movhi	r2,2086
 8245cfc:	10b83d04 	addi	r2,r2,-7948
 8245d00:	10800017 	ldw	r2,0(r2)
 8245d04:	10800a17 	ldw	r2,40(r2)
 8245d08:	1004963a 	slli	r2,r2,24
 8245d0c:	2084b03a 	or	r2,r4,r2
 8245d10:	1887883a 	add	r3,r3,r2
 8245d14:	e0bffe17 	ldw	r2,-8(fp)
 8245d18:	10800017 	ldw	r2,0(r2)
 8245d1c:	1008d63a 	srli	r4,r2,24
 8245d20:	e0bffe17 	ldw	r2,-8(fp)
 8245d24:	10800017 	ldw	r2,0(r2)
 8245d28:	1004d23a 	srli	r2,r2,8
 8245d2c:	10bfc00c 	andi	r2,r2,65280
 8245d30:	2088b03a 	or	r4,r4,r2
 8245d34:	e0bffe17 	ldw	r2,-8(fp)
 8245d38:	10800017 	ldw	r2,0(r2)
 8245d3c:	10bfc00c 	andi	r2,r2,65280
 8245d40:	1004923a 	slli	r2,r2,8
 8245d44:	2088b03a 	or	r4,r4,r2
 8245d48:	e0bffe17 	ldw	r2,-8(fp)
 8245d4c:	10800017 	ldw	r2,0(r2)
 8245d50:	1004963a 	slli	r2,r2,24
 8245d54:	2084b03a 	or	r2,r4,r2
 8245d58:	1885883a 	add	r2,r3,r2
 8245d5c:	e0ffff0b 	ldhu	r3,-4(fp)
 8245d60:	180b883a 	mov	r5,r3
 8245d64:	1009883a 	mov	r4,r2
 8245d68:	8202cd00 	call	8202cd0 <__umodsi3>
 8245d6c:	10c00044 	addi	r3,r2,1
 8245d70:	e0bffe17 	ldw	r2,-8(fp)
 8245d74:	10c00315 	stw	r3,12(r2)
   }

   return;
 8245d78:	0001883a 	nop
 8245d7c:	0001883a 	nop
}
 8245d80:	e037883a 	mov	sp,fp
 8245d84:	dfc00117 	ldw	ra,4(sp)
 8245d88:	df000017 	ldw	fp,0(sp)
 8245d8c:	dec00204 	addi	sp,sp,8
 8245d90:	f800283a 	ret

08245d94 <igmpv2_chk4_rtr_alert_opt>:
 *         the IP Router Alert option in the received
 *         packet, and IGMP_FALSE otherwise.
 */

u_char igmpv2_chk4_rtr_alert_opt (struct ip * pip)
{
 8245d94:	defffb04 	addi	sp,sp,-20
 8245d98:	df000415 	stw	fp,16(sp)
 8245d9c:	df000404 	addi	fp,sp,16
 8245da0:	e13fff15 	stw	r4,-4(fp)
   u_long * rtr_alert_optp;
   u_char total_optlen;
   u_char optlen;
   u_char optval;

   total_optlen = ip_hlen (pip) - sizeof (struct ip);
 8245da4:	e0bfff17 	ldw	r2,-4(fp)
 8245da8:	10800003 	ldbu	r2,0(r2)
 8245dac:	108003cc 	andi	r2,r2,15
 8245db0:	1085883a 	add	r2,r2,r2
 8245db4:	1085883a 	add	r2,r2,r2
 8245db8:	10bffb04 	addi	r2,r2,-20
 8245dbc:	e0bffd05 	stb	r2,-12(fp)

   if (total_optlen > 0)
 8245dc0:	e0bffd03 	ldbu	r2,-12(fp)
 8245dc4:	10003e26 	beq	r2,zero,8245ec0 <igmpv2_chk4_rtr_alert_opt+0x12c>
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
 8245dc8:	e0bfff17 	ldw	r2,-4(fp)
 8245dcc:	10800504 	addi	r2,r2,20
 8245dd0:	e0bffc15 	stw	r2,-16(fp)
  
      while (total_optlen > 0)
 8245dd4:	00003806 	br	8245eb8 <igmpv2_chk4_rtr_alert_opt+0x124>
      {
         /* only the lowermost 5 bits are significant */    
         optval = (*optp) & IPOPT_TYPE_MASK;
 8245dd8:	e0bffc17 	ldw	r2,-16(fp)
 8245ddc:	10800003 	ldbu	r2,0(r2)
 8245de0:	108007cc 	andi	r2,r2,31
 8245de4:	e0bffd85 	stb	r2,-10(fp)
         switch (optval)
 8245de8:	e0bffd83 	ldbu	r2,-10(fp)
 8245dec:	10c00060 	cmpeqi	r3,r2,1
 8245df0:	1800071e 	bne	r3,zero,8245e10 <igmpv2_chk4_rtr_alert_opt+0x7c>
 8245df4:	10c00520 	cmpeqi	r3,r2,20
 8245df8:	1800081e 	bne	r3,zero,8245e1c <igmpv2_chk4_rtr_alert_opt+0x88>
 8245dfc:	1000201e 	bne	r2,zero,8245e80 <igmpv2_chk4_rtr_alert_opt+0xec>
         {
            case EOL_OPT:
               /* we've encountered the End of Option List option, 
                * and so setting optlen isn't necessary */
               optlen = 1;
 8245e00:	00800044 	movi	r2,1
 8245e04:	e0bffd45 	stb	r2,-11(fp)
               /* we're done - we couldn't locate the IP Router Alert 
                * option in this IP header */
               return IGMP_FALSE;
 8245e08:	0005883a 	mov	r2,zero
 8245e0c:	00002d06 	br	8245ec4 <igmpv2_chk4_rtr_alert_opt+0x130>
         
            case NOOP_OPT:
               /* skip past the one byte of the No Operation option */
               optlen = 1;
 8245e10:	00800044 	movi	r2,1
 8245e14:	e0bffd45 	stb	r2,-11(fp)
               break;
 8245e18:	00001f06 	br	8245e98 <igmpv2_chk4_rtr_alert_opt+0x104>
         
            case IP_RTR_ALERT_OPT:
               rtr_alert_optp = (u_long *) optp; 
 8245e1c:	e0bffc17 	ldw	r2,-16(fp)
 8245e20:	e0bffe15 	stw	r2,-8(fp)
               if ((ntohl (*rtr_alert_optp)) == IP_RTR_ALERT_OPT_DATA)
 8245e24:	e0bffe17 	ldw	r2,-8(fp)
 8245e28:	10800017 	ldw	r2,0(r2)
 8245e2c:	1006d63a 	srli	r3,r2,24
 8245e30:	e0bffe17 	ldw	r2,-8(fp)
 8245e34:	10800017 	ldw	r2,0(r2)
 8245e38:	1004d23a 	srli	r2,r2,8
 8245e3c:	10bfc00c 	andi	r2,r2,65280
 8245e40:	1886b03a 	or	r3,r3,r2
 8245e44:	e0bffe17 	ldw	r2,-8(fp)
 8245e48:	10800017 	ldw	r2,0(r2)
 8245e4c:	10bfc00c 	andi	r2,r2,65280
 8245e50:	1004923a 	slli	r2,r2,8
 8245e54:	1886b03a 	or	r3,r3,r2
 8245e58:	e0bffe17 	ldw	r2,-8(fp)
 8245e5c:	10800017 	ldw	r2,0(r2)
 8245e60:	1004963a 	slli	r2,r2,24
 8245e64:	1886b03a 	or	r3,r3,r2
 8245e68:	00a50134 	movhi	r2,37892
 8245e6c:	1880021e 	bne	r3,r2,8245e78 <igmpv2_chk4_rtr_alert_opt+0xe4>
                  /* found the option, return success */
                  return IGMP_TRUE;
 8245e70:	00800044 	movi	r2,1
 8245e74:	00001306 	br	8245ec4 <igmpv2_chk4_rtr_alert_opt+0x130>
               else return IGMP_FALSE;
 8245e78:	0005883a 	mov	r2,zero
 8245e7c:	00001106 	br	8245ec4 <igmpv2_chk4_rtr_alert_opt+0x130>
          
            default:
               /* extract the length of the current option, and compute
                * the total length of this option */
               optlen = (*(optp + 1)) + 2;
 8245e80:	e0bffc17 	ldw	r2,-16(fp)
 8245e84:	10800044 	addi	r2,r2,1
 8245e88:	10800003 	ldbu	r2,0(r2)
 8245e8c:	10800084 	addi	r2,r2,2
 8245e90:	e0bffd45 	stb	r2,-11(fp)
               break;
 8245e94:	0001883a 	nop
         }
         
         /* skip past the bytes associated with the current option to 
          * point to the next option. */
         optp += optlen;
 8245e98:	e0bffd43 	ldbu	r2,-11(fp)
 8245e9c:	e0fffc17 	ldw	r3,-16(fp)
 8245ea0:	1885883a 	add	r2,r3,r2
 8245ea4:	e0bffc15 	stw	r2,-16(fp)
         total_optlen -= optlen;
 8245ea8:	e0fffd03 	ldbu	r3,-12(fp)
 8245eac:	e0bffd43 	ldbu	r2,-11(fp)
 8245eb0:	1885c83a 	sub	r2,r3,r2
 8245eb4:	e0bffd05 	stb	r2,-12(fp)
   if (total_optlen > 0)
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
  
      while (total_optlen > 0)
 8245eb8:	e0bffd03 	ldbu	r2,-12(fp)
 8245ebc:	103fc61e 	bne	r2,zero,8245dd8 <igmpv2_chk4_rtr_alert_opt+0x44>
         total_optlen -= optlen;
      } /* end WHILE */
   }

   /* didn't find IP Alert option in IP header of rcvd packet */
   return IGMP_FALSE;
 8245ec0:	0005883a 	mov	r2,zero
}
 8245ec4:	e037883a 	mov	sp,fp
 8245ec8:	df000017 	ldw	fp,0(sp)
 8245ecc:	dec00104 	addi	sp,sp,4
 8245ed0:	f800283a 	ret

08245ed4 <IPADDR_TO_NETP>:
 * RETURNS: 
 */

void
IPADDR_TO_NETP(ip_addr addr, NET* netp)
{
 8245ed4:	defffc04 	addi	sp,sp,-16
 8245ed8:	df000315 	stw	fp,12(sp)
 8245edc:	df000304 	addi	fp,sp,12
 8245ee0:	e13ffe15 	stw	r4,-8(fp)
 8245ee4:	e17fff15 	stw	r5,-4(fp)
   u_short  idx   =  0;
 8245ee8:	e03ffd0d 	sth	zero,-12(fp)
   *netp = nets[idx];
 8245eec:	e0fffd0b 	ldhu	r3,-12(fp)
 8245ef0:	008209b4 	movhi	r2,2086
 8245ef4:	10b83d04 	addi	r2,r2,-7948
 8245ef8:	18c7883a 	add	r3,r3,r3
 8245efc:	18c7883a 	add	r3,r3,r3
 8245f00:	10c5883a 	add	r2,r2,r3
 8245f04:	10c00017 	ldw	r3,0(r2)
 8245f08:	e0bfff17 	ldw	r2,-4(fp)
 8245f0c:	10c00015 	stw	r3,0(r2)
/*
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
 8245f10:	e0bffe17 	ldw	r2,-8(fp)
 8245f14:	10002e1e 	bne	r2,zero,8245fd0 <IPADDR_TO_NETP+0xfc>
   {
      for (idx = 0; idx < ifNumber; idx++)
 8245f18:	e03ffd0d 	sth	zero,-12(fp)
 8245f1c:	00001606 	br	8245f78 <IPADDR_TO_NETP+0xa4>
      {
         if (nets[idx]->n_mcastlist)
 8245f20:	e0fffd0b 	ldhu	r3,-12(fp)
 8245f24:	008209b4 	movhi	r2,2086
 8245f28:	10b83d04 	addi	r2,r2,-7948
 8245f2c:	18c7883a 	add	r3,r3,r3
 8245f30:	18c7883a 	add	r3,r3,r3
 8245f34:	10c5883a 	add	r2,r2,r3
 8245f38:	10800017 	ldw	r2,0(r2)
 8245f3c:	10802b17 	ldw	r2,172(r2)
 8245f40:	10000a26 	beq	r2,zero,8245f6c <IPADDR_TO_NETP+0x98>
         {
            *netp = nets[idx];
 8245f44:	e0fffd0b 	ldhu	r3,-12(fp)
 8245f48:	008209b4 	movhi	r2,2086
 8245f4c:	10b83d04 	addi	r2,r2,-7948
 8245f50:	18c7883a 	add	r3,r3,r3
 8245f54:	18c7883a 	add	r3,r3,r3
 8245f58:	10c5883a 	add	r2,r2,r3
 8245f5c:	10c00017 	ldw	r3,0(r2)
 8245f60:	e0bfff17 	ldw	r2,-4(fp)
 8245f64:	10c00015 	stw	r3,0(r2)
            break;
 8245f68:	00002206 	br	8245ff4 <IPADDR_TO_NETP+0x120>
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
   {
      for (idx = 0; idx < ifNumber; idx++)
 8245f6c:	e0bffd0b 	ldhu	r2,-12(fp)
 8245f70:	10800044 	addi	r2,r2,1
 8245f74:	e0bffd0d 	sth	r2,-12(fp)
 8245f78:	e0fffd0b 	ldhu	r3,-12(fp)
 8245f7c:	d0a08417 	ldw	r2,-32240(gp)
 8245f80:	18bfe736 	bltu	r3,r2,8245f20 <IPADDR_TO_NETP+0x4c>
         }
         else
            *netp = nets[idx];
      }
   }
}
 8245f84:	00001b06 	br	8245ff4 <IPADDR_TO_NETP+0x120>
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
      {
         idx++;
 8245f88:	e0bffd0b 	ldhu	r2,-12(fp)
 8245f8c:	10800044 	addi	r2,r2,1
 8245f90:	e0bffd0d 	sth	r2,-12(fp)
         if (idx >= ifNumber)
 8245f94:	e0fffd0b 	ldhu	r3,-12(fp)
 8245f98:	d0a08417 	ldw	r2,-32240(gp)
 8245f9c:	18800336 	bltu	r3,r2,8245fac <IPADDR_TO_NETP+0xd8>
         {
            *netp = NULL;
 8245fa0:	e0bfff17 	ldw	r2,-4(fp)
 8245fa4:	10000015 	stw	zero,0(r2)
            break;
 8245fa8:	00001206 	br	8245ff4 <IPADDR_TO_NETP+0x120>
         }
         else
            *netp = nets[idx];
 8245fac:	e0fffd0b 	ldhu	r3,-12(fp)
 8245fb0:	008209b4 	movhi	r2,2086
 8245fb4:	10b83d04 	addi	r2,r2,-7948
 8245fb8:	18c7883a 	add	r3,r3,r3
 8245fbc:	18c7883a 	add	r3,r3,r3
 8245fc0:	10c5883a 	add	r2,r2,r3
 8245fc4:	10c00017 	ldw	r3,0(r2)
 8245fc8:	e0bfff17 	ldw	r2,-4(fp)
 8245fcc:	10c00015 	stw	r3,0(r2)
         }
      }
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
 8245fd0:	e0bfff17 	ldw	r2,-4(fp)
 8245fd4:	10800017 	ldw	r2,0(r2)
 8245fd8:	10000626 	beq	r2,zero,8245ff4 <IPADDR_TO_NETP+0x120>
 8245fdc:	e0bfff17 	ldw	r2,-4(fp)
 8245fe0:	10800017 	ldw	r2,0(r2)
 8245fe4:	10c00a17 	ldw	r3,40(r2)
 8245fe8:	e0bffe17 	ldw	r2,-8(fp)
 8245fec:	18bfe61e 	bne	r3,r2,8245f88 <IPADDR_TO_NETP+0xb4>
         }
         else
            *netp = nets[idx];
      }
   }
}
 8245ff0:	00000006 	br	8245ff4 <IPADDR_TO_NETP+0x120>
 8245ff4:	0001883a 	nop
 8245ff8:	e037883a 	mov	sp,fp
 8245ffc:	df000017 	ldw	fp,0(sp)
 8246000:	dec00104 	addi	sp,sp,4
 8246004:	f800283a 	ret

08246008 <ip_setmoptions>:
 * RETURNS: 
 */

int
ip_setmoptions(int optname, struct socket * so, void * val)
{
 8246008:	defff304 	addi	sp,sp,-52
 824600c:	dfc00c15 	stw	ra,48(sp)
 8246010:	df000b15 	stw	fp,44(sp)
 8246014:	dc000a15 	stw	r16,40(sp)
 8246018:	df000b04 	addi	fp,sp,44
 824601c:	e13ffc15 	stw	r4,-16(fp)
 8246020:	e17ffd15 	stw	r5,-12(fp)
 8246024:	e1bffe15 	stw	r6,-8(fp)
   int   error =  0;
 8246028:	e03ff515 	stw	zero,-44(fp)
   u_short  i;
   struct ip_mreq *  mreq;
   struct net *   netp  =  NULL;
 824602c:	e03ffb15 	stw	zero,-20(fp)
   struct ip_moptions * imo   =  so->inp_moptions;
 8246030:	e0bffd17 	ldw	r2,-12(fp)
 8246034:	10800317 	ldw	r2,12(r2)
 8246038:	e0bff715 	stw	r2,-36(fp)
   struct ip_moptions **imop  =  &so->inp_moptions;
 824603c:	e0bffd17 	ldw	r2,-12(fp)
 8246040:	10800304 	addi	r2,r2,12
 8246044:	e0bff815 	stw	r2,-32(fp)
   ip_addr addr;


   if (imo == NULL) 
 8246048:	e0bff717 	ldw	r2,-36(fp)
 824604c:	1000141e 	bne	r2,zero,82460a0 <ip_setmoptions+0x98>
   {
   /*
    * No multicast option buffer attached to the pcb;
    * allocate one and initialize to default values.
    */
      imo = (struct ip_moptions*)IM_ALLOC(sizeof(*imo));
 8246050:	01001604 	movi	r4,88
 8246054:	822e1c80 	call	822e1c8 <npalloc>
 8246058:	e0bff715 	stw	r2,-36(fp)

      if (imo == NULL)
 824605c:	e0bff717 	ldw	r2,-36(fp)
 8246060:	1000021e 	bne	r2,zero,824606c <ip_setmoptions+0x64>
         return (ENOBUFS);
 8246064:	00801a44 	movi	r2,105
 8246068:	00015306 	br	82465b8 <ip_setmoptions+0x5b0>
      *imop = imo;
 824606c:	e0bff817 	ldw	r2,-32(fp)
 8246070:	e0fff717 	ldw	r3,-36(fp)
 8246074:	10c00015 	stw	r3,0(r2)
      imo->imo_multicast_netp = NULL;
 8246078:	e0bff717 	ldw	r2,-36(fp)
 824607c:	10000015 	stw	zero,0(r2)
      imo->imo_multicast_ttl = IP_DEFAULT_MULTICAST_TTL;
 8246080:	e0bff717 	ldw	r2,-36(fp)
 8246084:	00c00044 	movi	r3,1
 8246088:	10c00105 	stb	r3,4(r2)
      imo->imo_multicast_loop = IP_DEFAULT_MULTICAST_LOOP;
 824608c:	e0bff717 	ldw	r2,-36(fp)
 8246090:	00c00044 	movi	r3,1
 8246094:	10c00145 	stb	r3,5(r2)
      imo->imo_num_memberships = 0;
 8246098:	e0bff717 	ldw	r2,-36(fp)
 824609c:	1000018d 	sth	zero,6(r2)
   }

   switch (optname) 
 82460a0:	e0bffc17 	ldw	r2,-16(fp)
 82460a4:	10bffdc4 	addi	r2,r2,-9
 82460a8:	10c00168 	cmpgeui	r3,r2,5
 82460ac:	1801261e 	bne	r3,zero,8246548 <ip_setmoptions+0x540>
 82460b0:	100690ba 	slli	r3,r2,2
 82460b4:	00820934 	movhi	r2,2084
 82460b8:	10983204 	addi	r2,r2,24776
 82460bc:	1885883a 	add	r2,r3,r2
 82460c0:	10800017 	ldw	r2,0(r2)
 82460c4:	1000683a 	jmp	r2
 82460c8:	082460dc 	xori	zero,at,37251
 82460cc:	08246144 	addi	zero,at,-28283
 82460d0:	08246158 	cmpnei	zero,at,-28283
 82460d4:	0824618c 	andi	zero,at,37254
 82460d8:	08246360 	cmpeqi	zero,at,-28275

   case IP_MULTICAST_IF:
      /*
       * Select the interface for outgoing multicast packets.
       */
      addr = *(ip_addr *)val;
 82460dc:	e0bffe17 	ldw	r2,-8(fp)
 82460e0:	10800017 	ldw	r2,0(r2)
 82460e4:	e0bff915 	stw	r2,-28(fp)
         /*
          * AADDR is used to remove a previous selection.
          * When no interface is selected, a default one is
          * chosen every time a multicast packet is sent.
          */
      if (addr == AADDR) 
 82460e8:	e0bff917 	ldw	r2,-28(fp)
 82460ec:	1000031e 	bne	r2,zero,82460fc <ip_setmoptions+0xf4>
      {
         imo->imo_multicast_netp = NULL;
 82460f0:	e0bff717 	ldw	r2,-36(fp)
 82460f4:	10000015 	stw	zero,0(r2)
         break;
 82460f8:	00011706 	br	8246558 <ip_setmoptions+0x550>
         /*
          * The selected interface is identified by its local
          * IP address.  Find the interface and confirm that
          * it supports multicasting.
          */
      IPADDR_TO_NETP(addr, &netp);
 82460fc:	e0bffb04 	addi	r2,fp,-20
 8246100:	100b883a 	mov	r5,r2
 8246104:	e13ff917 	ldw	r4,-28(fp)
 8246108:	8245ed40 	call	8245ed4 <IPADDR_TO_NETP>
      if ((netp == NULL) || (netp->n_mcastlist) == NULL) 
 824610c:	e0bffb17 	ldw	r2,-20(fp)
 8246110:	10000326 	beq	r2,zero,8246120 <ip_setmoptions+0x118>
 8246114:	e0bffb17 	ldw	r2,-20(fp)
 8246118:	10802b17 	ldw	r2,172(r2)
 824611c:	1000031e 	bne	r2,zero,824612c <ip_setmoptions+0x124>
      {
         error = EADDRNOTAVAIL;
 8246120:	00801f44 	movi	r2,125
 8246124:	e0bff515 	stw	r2,-44(fp)
         break;
 8246128:	00010b06 	br	8246558 <ip_setmoptions+0x550>
      }
      if (addr != AADDR) 
 824612c:	e0bff917 	ldw	r2,-28(fp)
 8246130:	10010826 	beq	r2,zero,8246554 <ip_setmoptions+0x54c>
         imo->imo_multicast_netp = netp;
 8246134:	e0fffb17 	ldw	r3,-20(fp)
 8246138:	e0bff717 	ldw	r2,-36(fp)
 824613c:	10c00015 	stw	r3,0(r2)
      break;
 8246140:	00010406 	br	8246554 <ip_setmoptions+0x54c>

   case IP_MULTICAST_TTL:
      /*
       * Set the IP time-to-live for outgoing multicast packets.
       */
      imo->imo_multicast_ttl = *(u_char *)val;
 8246144:	e0bffe17 	ldw	r2,-8(fp)
 8246148:	10c00003 	ldbu	r3,0(r2)
 824614c:	e0bff717 	ldw	r2,-36(fp)
 8246150:	10c00105 	stb	r3,4(r2)
      break;
 8246154:	00010006 	br	8246558 <ip_setmoptions+0x550>
   case IP_MULTICAST_LOOP:
      /*
       * Set the loopback flag for outgoing multicast packets.
       * Must be zero or one.
       */
      if (*(u_char *)val > 1) 
 8246158:	e0bffe17 	ldw	r2,-8(fp)
 824615c:	10800003 	ldbu	r2,0(r2)
 8246160:	10803fcc 	andi	r2,r2,255
 8246164:	108000b0 	cmpltui	r2,r2,2
 8246168:	1000031e 	bne	r2,zero,8246178 <ip_setmoptions+0x170>
      {
         error = EINVAL;
 824616c:	00800584 	movi	r2,22
 8246170:	e0bff515 	stw	r2,-44(fp)
         break;
 8246174:	0000f806 	br	8246558 <ip_setmoptions+0x550>
      }
      imo->imo_multicast_loop = *(u_char *)(val);
 8246178:	e0bffe17 	ldw	r2,-8(fp)
 824617c:	10c00003 	ldbu	r3,0(r2)
 8246180:	e0bff717 	ldw	r2,-36(fp)
 8246184:	10c00145 	stb	r3,5(r2)
      break;
 8246188:	0000f306 	br	8246558 <ip_setmoptions+0x550>
   case IP_ADD_MEMBERSHIP:
      /*
       * Add a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 824618c:	e0bffe17 	ldw	r2,-8(fp)
 8246190:	e0bffa15 	stw	r2,-24(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 8246194:	e0bffa17 	ldw	r2,-24(fp)
 8246198:	10800017 	ldw	r2,0(r2)
 824619c:	1006d63a 	srli	r3,r2,24
 82461a0:	e0bffa17 	ldw	r2,-24(fp)
 82461a4:	10800017 	ldw	r2,0(r2)
 82461a8:	1004d23a 	srli	r2,r2,8
 82461ac:	10bfc00c 	andi	r2,r2,65280
 82461b0:	1886b03a 	or	r3,r3,r2
 82461b4:	e0bffa17 	ldw	r2,-24(fp)
 82461b8:	10800017 	ldw	r2,0(r2)
 82461bc:	10bfc00c 	andi	r2,r2,65280
 82461c0:	1004923a 	slli	r2,r2,8
 82461c4:	1886b03a 	or	r3,r3,r2
 82461c8:	e0bffa17 	ldw	r2,-24(fp)
 82461cc:	10800017 	ldw	r2,0(r2)
 82461d0:	1004963a 	slli	r2,r2,24
 82461d4:	1884b03a 	or	r2,r3,r2
 82461d8:	10fc002c 	andhi	r3,r2,61440
 82461dc:	00b80034 	movhi	r2,57344
 82461e0:	18800326 	beq	r3,r2,82461f0 <ip_setmoptions+0x1e8>
      {
         error = EINVAL;
 82461e4:	00800584 	movi	r2,22
 82461e8:	e0bff515 	stw	r2,-44(fp)
         break;
 82461ec:	0000da06 	br	8246558 <ip_setmoptions+0x550>
       * If no interface address was provided, use the interface of
       * the route to the given multicast address.
       * For the Iniche stack implementation, look for a default
       * interface that supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 82461f0:	e0bffa17 	ldw	r2,-24(fp)
 82461f4:	10800117 	ldw	r2,4(r2)
 82461f8:	e0fffb04 	addi	r3,fp,-20
 82461fc:	180b883a 	mov	r5,r3
 8246200:	1009883a 	mov	r4,r2
 8246204:	8245ed40 	call	8245ed4 <IPADDR_TO_NETP>
      /*
       * See if we found an interface, and confirm that it
       * supports multicast.
       */
      if (netp == NULL || (netp->n_mcastlist) == NULL) 
 8246208:	e0bffb17 	ldw	r2,-20(fp)
 824620c:	10000326 	beq	r2,zero,824621c <ip_setmoptions+0x214>
 8246210:	e0bffb17 	ldw	r2,-20(fp)
 8246214:	10802b17 	ldw	r2,172(r2)
 8246218:	1000031e 	bne	r2,zero,8246228 <ip_setmoptions+0x220>
      {
         error = EADDRNOTAVAIL;
 824621c:	00801f44 	movi	r2,125
 8246220:	e0bff515 	stw	r2,-44(fp)
         break;
 8246224:	0000cc06 	br	8246558 <ip_setmoptions+0x550>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 8246228:	e03ff60d 	sth	zero,-40(fp)
 824622c:	00001806 	br	8246290 <ip_setmoptions+0x288>
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
 8246230:	e0bff60b 	ldhu	r2,-40(fp)
 8246234:	e0fff717 	ldw	r3,-36(fp)
 8246238:	10800084 	addi	r2,r2,2
 824623c:	1085883a 	add	r2,r2,r2
 8246240:	1085883a 	add	r2,r2,r2
 8246244:	1885883a 	add	r2,r3,r2
 8246248:	10800017 	ldw	r2,0(r2)
 824624c:	10c00117 	ldw	r3,4(r2)
 8246250:	e0bffb17 	ldw	r2,-20(fp)
 8246254:	18800b1e 	bne	r3,r2,8246284 <ip_setmoptions+0x27c>
             imo->imo_membership[i]->inm_addr
 8246258:	e0bff60b 	ldhu	r2,-40(fp)
 824625c:	e0fff717 	ldw	r3,-36(fp)
 8246260:	10800084 	addi	r2,r2,2
 8246264:	1085883a 	add	r2,r2,r2
 8246268:	1085883a 	add	r2,r2,r2
 824626c:	1885883a 	add	r2,r3,r2
 8246270:	10800017 	ldw	r2,0(r2)
 8246274:	10c00017 	ldw	r3,0(r2)
             == mreq->imr_multiaddr)
 8246278:	e0bffa17 	ldw	r2,-24(fp)
 824627c:	10800017 	ldw	r2,0(r2)
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
 8246280:	18800926 	beq	r3,r2,82462a8 <ip_setmoptions+0x2a0>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 8246284:	e0bff60b 	ldhu	r2,-40(fp)
 8246288:	10800044 	addi	r2,r2,1
 824628c:	e0bff60d 	sth	r2,-40(fp)
 8246290:	e0bff717 	ldw	r2,-36(fp)
 8246294:	1080018b 	ldhu	r2,6(r2)
 8246298:	10bfffcc 	andi	r2,r2,65535
 824629c:	e0fff60b 	ldhu	r3,-40(fp)
 82462a0:	18bfe336 	bltu	r3,r2,8246230 <ip_setmoptions+0x228>
 82462a4:	00000106 	br	82462ac <ip_setmoptions+0x2a4>
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
             imo->imo_membership[i]->inm_addr
             == mreq->imr_multiaddr)
         {
            break;
 82462a8:	0001883a 	nop
         }
      }
      if (i < imo->imo_num_memberships) 
 82462ac:	e0bff717 	ldw	r2,-36(fp)
 82462b0:	1080018b 	ldhu	r2,6(r2)
 82462b4:	10bfffcc 	andi	r2,r2,65535
 82462b8:	e0fff60b 	ldhu	r3,-40(fp)
 82462bc:	1880032e 	bgeu	r3,r2,82462cc <ip_setmoptions+0x2c4>
      {
         error = EADDRINUSE;
 82462c0:	00801c04 	movi	r2,112
 82462c4:	e0bff515 	stw	r2,-44(fp)
         break;
 82462c8:	0000a306 	br	8246558 <ip_setmoptions+0x550>
      }
      if (i == IP_MAX_MEMBERSHIPS) 
 82462cc:	e0bff60b 	ldhu	r2,-40(fp)
 82462d0:	10800518 	cmpnei	r2,r2,20
 82462d4:	1000031e 	bne	r2,zero,82462e4 <ip_setmoptions+0x2dc>
      {
         error = ETOOMANYREFS;
 82462d8:	00802044 	movi	r2,129
 82462dc:	e0bff515 	stw	r2,-44(fp)
         break;
 82462e0:	00009d06 	br	8246558 <ip_setmoptions+0x550>
      }
      /*
       * Everything looks good; add a new record to the multicast
       * address list for the given interface.
       */
      if ((imo->imo_membership[i] =
 82462e4:	e43ff60b 	ldhu	r16,-40(fp)
          in_addmulti(&mreq->imr_multiaddr, netp, 4)) == NULL) 
 82462e8:	e0bffa17 	ldw	r2,-24(fp)
 82462ec:	e0fffb17 	ldw	r3,-20(fp)
 82462f0:	01800104 	movi	r6,4
 82462f4:	180b883a 	mov	r5,r3
 82462f8:	1009883a 	mov	r4,r2
 82462fc:	82439ac0 	call	82439ac <in_addmulti>
 8246300:	1009883a 	mov	r4,r2
      }
      /*
       * Everything looks good; add a new record to the multicast
       * address list for the given interface.
       */
      if ((imo->imo_membership[i] =
 8246304:	e0fff717 	ldw	r3,-36(fp)
 8246308:	80800084 	addi	r2,r16,2
 824630c:	1085883a 	add	r2,r2,r2
 8246310:	1085883a 	add	r2,r2,r2
 8246314:	1885883a 	add	r2,r3,r2
 8246318:	11000015 	stw	r4,0(r2)
 824631c:	e0fff717 	ldw	r3,-36(fp)
 8246320:	80800084 	addi	r2,r16,2
 8246324:	1085883a 	add	r2,r2,r2
 8246328:	1085883a 	add	r2,r2,r2
 824632c:	1885883a 	add	r2,r3,r2
 8246330:	10800017 	ldw	r2,0(r2)
 8246334:	1000031e 	bne	r2,zero,8246344 <ip_setmoptions+0x33c>
          in_addmulti(&mreq->imr_multiaddr, netp, 4)) == NULL) 
      {
         error = ENOBUFS;
 8246338:	00801a44 	movi	r2,105
 824633c:	e0bff515 	stw	r2,-44(fp)
         break;
 8246340:	00008506 	br	8246558 <ip_setmoptions+0x550>
      }
      ++imo->imo_num_memberships;
 8246344:	e0bff717 	ldw	r2,-36(fp)
 8246348:	1080018b 	ldhu	r2,6(r2)
 824634c:	10800044 	addi	r2,r2,1
 8246350:	1007883a 	mov	r3,r2
 8246354:	e0bff717 	ldw	r2,-36(fp)
 8246358:	10c0018d 	sth	r3,6(r2)
      break;
 824635c:	00007e06 	br	8246558 <ip_setmoptions+0x550>
   case IP_DROP_MEMBERSHIP:
      /*
       * Drop a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 8246360:	e0bffe17 	ldw	r2,-8(fp)
 8246364:	e0bffa15 	stw	r2,-24(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 8246368:	e0bffa17 	ldw	r2,-24(fp)
 824636c:	10800017 	ldw	r2,0(r2)
 8246370:	1006d63a 	srli	r3,r2,24
 8246374:	e0bffa17 	ldw	r2,-24(fp)
 8246378:	10800017 	ldw	r2,0(r2)
 824637c:	1004d23a 	srli	r2,r2,8
 8246380:	10bfc00c 	andi	r2,r2,65280
 8246384:	1886b03a 	or	r3,r3,r2
 8246388:	e0bffa17 	ldw	r2,-24(fp)
 824638c:	10800017 	ldw	r2,0(r2)
 8246390:	10bfc00c 	andi	r2,r2,65280
 8246394:	1004923a 	slli	r2,r2,8
 8246398:	1886b03a 	or	r3,r3,r2
 824639c:	e0bffa17 	ldw	r2,-24(fp)
 82463a0:	10800017 	ldw	r2,0(r2)
 82463a4:	1004963a 	slli	r2,r2,24
 82463a8:	1884b03a 	or	r2,r3,r2
 82463ac:	10fc002c 	andhi	r3,r2,61440
 82463b0:	00b80034 	movhi	r2,57344
 82463b4:	18800326 	beq	r3,r2,82463c4 <ip_setmoptions+0x3bc>
      {
         error = EINVAL;
 82463b8:	00800584 	movi	r2,22
 82463bc:	e0bff515 	stw	r2,-44(fp)
         break;
 82463c0:	00006506 	br	8246558 <ip_setmoptions+0x550>
       * If an interface address was specified, get a pointer
       * to its ifnet structure. If an interface address was not
       * specified, get a pointer to the first interface that
       * supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 82463c4:	e0bffa17 	ldw	r2,-24(fp)
 82463c8:	10800117 	ldw	r2,4(r2)
 82463cc:	e0fffb04 	addi	r3,fp,-20
 82463d0:	180b883a 	mov	r5,r3
 82463d4:	1009883a 	mov	r4,r2
 82463d8:	8245ed40 	call	8245ed4 <IPADDR_TO_NETP>
      if (netp == NULL) 
 82463dc:	e0bffb17 	ldw	r2,-20(fp)
 82463e0:	1000031e 	bne	r2,zero,82463f0 <ip_setmoptions+0x3e8>
      {
         error = EADDRNOTAVAIL;
 82463e4:	00801f44 	movi	r2,125
 82463e8:	e0bff515 	stw	r2,-44(fp)
         break;
 82463ec:	00005a06 	br	8246558 <ip_setmoptions+0x550>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 82463f0:	e03ff60d 	sth	zero,-40(fp)
 82463f4:	00001a06 	br	8246460 <ip_setmoptions+0x458>
      {
         if ((netp == NULL ||
 82463f8:	e0bffb17 	ldw	r2,-20(fp)
 82463fc:	10000a26 	beq	r2,zero,8246428 <ip_setmoptions+0x420>
             imo->imo_membership[i]->inm_netp == netp) &&
 8246400:	e0bff60b 	ldhu	r2,-40(fp)
 8246404:	e0fff717 	ldw	r3,-36(fp)
 8246408:	10800084 	addi	r2,r2,2
 824640c:	1085883a 	add	r2,r2,r2
 8246410:	1085883a 	add	r2,r2,r2
 8246414:	1885883a 	add	r2,r3,r2
 8246418:	10800017 	ldw	r2,0(r2)
 824641c:	10c00117 	ldw	r3,4(r2)
 8246420:	e0bffb17 	ldw	r2,-20(fp)
      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
      {
         if ((netp == NULL ||
 8246424:	18800b1e 	bne	r3,r2,8246454 <ip_setmoptions+0x44c>
             imo->imo_membership[i]->inm_netp == netp) &&
             imo->imo_membership[i]->inm_addr ==
 8246428:	e0bff60b 	ldhu	r2,-40(fp)
 824642c:	e0fff717 	ldw	r3,-36(fp)
 8246430:	10800084 	addi	r2,r2,2
 8246434:	1085883a 	add	r2,r2,r2
 8246438:	1085883a 	add	r2,r2,r2
 824643c:	1885883a 	add	r2,r3,r2
 8246440:	10800017 	ldw	r2,0(r2)
 8246444:	10c00017 	ldw	r3,0(r2)
             mreq->imr_multiaddr)
 8246448:	e0bffa17 	ldw	r2,-24(fp)
 824644c:	10800017 	ldw	r2,0(r2)
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
      {
         if ((netp == NULL ||
             imo->imo_membership[i]->inm_netp == netp) &&
 8246450:	18800926 	beq	r3,r2,8246478 <ip_setmoptions+0x470>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 8246454:	e0bff60b 	ldhu	r2,-40(fp)
 8246458:	10800044 	addi	r2,r2,1
 824645c:	e0bff60d 	sth	r2,-40(fp)
 8246460:	e0bff717 	ldw	r2,-36(fp)
 8246464:	1080018b 	ldhu	r2,6(r2)
 8246468:	10bfffcc 	andi	r2,r2,65535
 824646c:	e0fff60b 	ldhu	r3,-40(fp)
 8246470:	18bfe136 	bltu	r3,r2,82463f8 <ip_setmoptions+0x3f0>
 8246474:	00000106 	br	824647c <ip_setmoptions+0x474>
         if ((netp == NULL ||
             imo->imo_membership[i]->inm_netp == netp) &&
             imo->imo_membership[i]->inm_addr ==
             mreq->imr_multiaddr)
         {
            break;
 8246478:	0001883a 	nop
         }
      }
      if (i == imo->imo_num_memberships) 
 824647c:	e0bff717 	ldw	r2,-36(fp)
 8246480:	1080018b 	ldhu	r2,6(r2)
 8246484:	10ffffcc 	andi	r3,r2,65535
 8246488:	e0bff60b 	ldhu	r2,-40(fp)
 824648c:	1880031e 	bne	r3,r2,824649c <ip_setmoptions+0x494>
      {
         error = EADDRNOTAVAIL;
 8246490:	00801f44 	movi	r2,125
 8246494:	e0bff515 	stw	r2,-44(fp)
         break;
 8246498:	00002f06 	br	8246558 <ip_setmoptions+0x550>
      }
      /*
       * Give up the multicast address record to which the
       * membership points.
       */
      in_delmulti(imo->imo_membership[i]);
 824649c:	e0bff60b 	ldhu	r2,-40(fp)
 82464a0:	e0fff717 	ldw	r3,-36(fp)
 82464a4:	10800084 	addi	r2,r2,2
 82464a8:	1085883a 	add	r2,r2,r2
 82464ac:	1085883a 	add	r2,r2,r2
 82464b0:	1885883a 	add	r2,r3,r2
 82464b4:	10800017 	ldw	r2,0(r2)
 82464b8:	1009883a 	mov	r4,r2
 82464bc:	8243af80 	call	8243af8 <in_delmulti>
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 82464c0:	e0bff60b 	ldhu	r2,-40(fp)
 82464c4:	10800044 	addi	r2,r2,1
 82464c8:	e0bff60d 	sth	r2,-40(fp)
 82464cc:	00001206 	br	8246518 <ip_setmoptions+0x510>
         imo->imo_membership[i-1] = imo->imo_membership[i];
 82464d0:	e0bff60b 	ldhu	r2,-40(fp)
 82464d4:	117fffc4 	addi	r5,r2,-1
 82464d8:	e0bff60b 	ldhu	r2,-40(fp)
 82464dc:	e0fff717 	ldw	r3,-36(fp)
 82464e0:	10800084 	addi	r2,r2,2
 82464e4:	1085883a 	add	r2,r2,r2
 82464e8:	1085883a 	add	r2,r2,r2
 82464ec:	1885883a 	add	r2,r3,r2
 82464f0:	10c00017 	ldw	r3,0(r2)
 82464f4:	e13ff717 	ldw	r4,-36(fp)
 82464f8:	28800084 	addi	r2,r5,2
 82464fc:	1085883a 	add	r2,r2,r2
 8246500:	1085883a 	add	r2,r2,r2
 8246504:	2085883a 	add	r2,r4,r2
 8246508:	10c00015 	stw	r3,0(r2)
       */
      in_delmulti(imo->imo_membership[i]);
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 824650c:	e0bff60b 	ldhu	r2,-40(fp)
 8246510:	10800044 	addi	r2,r2,1
 8246514:	e0bff60d 	sth	r2,-40(fp)
 8246518:	e0bff717 	ldw	r2,-36(fp)
 824651c:	1080018b 	ldhu	r2,6(r2)
 8246520:	10bfffcc 	andi	r2,r2,65535
 8246524:	e0fff60b 	ldhu	r3,-40(fp)
 8246528:	18bfe936 	bltu	r3,r2,82464d0 <ip_setmoptions+0x4c8>
         imo->imo_membership[i-1] = imo->imo_membership[i];
      --imo->imo_num_memberships;
 824652c:	e0bff717 	ldw	r2,-36(fp)
 8246530:	1080018b 	ldhu	r2,6(r2)
 8246534:	10bfffc4 	addi	r2,r2,-1
 8246538:	1007883a 	mov	r3,r2
 824653c:	e0bff717 	ldw	r2,-36(fp)
 8246540:	10c0018d 	sth	r3,6(r2)
      break;
 8246544:	00000406 	br	8246558 <ip_setmoptions+0x550>

      default:
      error = EOPNOTSUPP;
 8246548:	008017c4 	movi	r2,95
 824654c:	e0bff515 	stw	r2,-44(fp)
      break;
 8246550:	00000106 	br	8246558 <ip_setmoptions+0x550>
         error = EADDRNOTAVAIL;
         break;
      }
      if (addr != AADDR) 
         imo->imo_multicast_netp = netp;
      break;
 8246554:	0001883a 	nop
   }

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
 8246558:	e0bff717 	ldw	r2,-36(fp)
 824655c:	10800017 	ldw	r2,0(r2)
 8246560:	1000141e 	bne	r2,zero,82465b4 <ip_setmoptions+0x5ac>
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
 8246564:	e0bff717 	ldw	r2,-36(fp)
 8246568:	10800103 	ldbu	r2,4(r2)
   }

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
 824656c:	10803fcc 	andi	r2,r2,255
 8246570:	10800058 	cmpnei	r2,r2,1
 8246574:	10000f1e 	bne	r2,zero,82465b4 <ip_setmoptions+0x5ac>
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
 8246578:	e0bff717 	ldw	r2,-36(fp)
 824657c:	10800143 	ldbu	r2,5(r2)

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
 8246580:	10803fcc 	andi	r2,r2,255
 8246584:	10800058 	cmpnei	r2,r2,1
 8246588:	10000a1e 	bne	r2,zero,82465b4 <ip_setmoptions+0x5ac>
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
       imo->imo_num_memberships == 0) 
 824658c:	e0bff717 	ldw	r2,-36(fp)
 8246590:	1080018b 	ldhu	r2,6(r2)
      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
 8246594:	10bfffcc 	andi	r2,r2,65535
 8246598:	1000061e 	bne	r2,zero,82465b4 <ip_setmoptions+0x5ac>
       imo->imo_num_memberships == 0) 
   {
      IM_FREE(*imop);
 824659c:	e0bff817 	ldw	r2,-32(fp)
 82465a0:	10800017 	ldw	r2,0(r2)
 82465a4:	1009883a 	mov	r4,r2
 82465a8:	822e1fc0 	call	822e1fc <npfree>
      *imop = NULL;
 82465ac:	e0bff817 	ldw	r2,-32(fp)
 82465b0:	10000015 	stw	zero,0(r2)
   }
   return (error);
 82465b4:	e0bff517 	ldw	r2,-44(fp)
}
 82465b8:	e6ffff04 	addi	sp,fp,-4
 82465bc:	dfc00217 	ldw	ra,8(sp)
 82465c0:	df000117 	ldw	fp,4(sp)
 82465c4:	dc000017 	ldw	r16,0(sp)
 82465c8:	dec00304 	addi	sp,sp,12
 82465cc:	f800283a 	ret

082465d0 <ip_getmoptions>:
 * RETURNS: 
 */

int
ip_getmoptions(int optname, struct socket * so, void * val)
{
 82465d0:	defff804 	addi	sp,sp,-32
 82465d4:	df000715 	stw	fp,28(sp)
 82465d8:	df000704 	addi	fp,sp,28
 82465dc:	e13ffd15 	stw	r4,-12(fp)
 82465e0:	e17ffe15 	stw	r5,-8(fp)
 82465e4:	e1bfff15 	stw	r6,-4(fp)
   u_char * ttl;
   u_char * loop;
   ip_addr *addr;
   struct ip_moptions*  imo   =  so->inp_moptions;
 82465e8:	e0bffe17 	ldw	r2,-8(fp)
 82465ec:	10800317 	ldw	r2,12(r2)
 82465f0:	e0bff915 	stw	r2,-28(fp)
   /* The following code will be commented out for Iniche stack.
    * Don't allocate a buffer here.
    *
    *        *mp = m_get(M_WAIT, MT_SOOPTS);
    */
   switch (optname) 
 82465f4:	e0bffd17 	ldw	r2,-12(fp)
 82465f8:	10c002a0 	cmpeqi	r3,r2,10
 82465fc:	1800151e 	bne	r3,zero,8246654 <ip_getmoptions+0x84>
 8246600:	10c002e0 	cmpeqi	r3,r2,11
 8246604:	1800211e 	bne	r3,zero,824668c <ip_getmoptions+0xbc>
 8246608:	10800260 	cmpeqi	r2,r2,9
 824660c:	10002d26 	beq	r2,zero,82466c4 <ip_getmoptions+0xf4>
   {

   case IP_MULTICAST_IF:
      addr = (ip_addr *)(val);
 8246610:	e0bfff17 	ldw	r2,-4(fp)
 8246614:	e0bffa15 	stw	r2,-24(fp)
      if (imo == NULL || imo->imo_multicast_netp == NULL)
 8246618:	e0bff917 	ldw	r2,-28(fp)
 824661c:	10000326 	beq	r2,zero,824662c <ip_getmoptions+0x5c>
 8246620:	e0bff917 	ldw	r2,-28(fp)
 8246624:	10800017 	ldw	r2,0(r2)
 8246628:	1000031e 	bne	r2,zero,8246638 <ip_getmoptions+0x68>
         *addr = AADDR;
 824662c:	e0bffa17 	ldw	r2,-24(fp)
 8246630:	10000015 	stw	zero,0(r2)
 8246634:	00000506 	br	824664c <ip_getmoptions+0x7c>
      else
         *addr = imo->imo_multicast_netp->n_ipaddr;
 8246638:	e0bff917 	ldw	r2,-28(fp)
 824663c:	10800017 	ldw	r2,0(r2)
 8246640:	10c00a17 	ldw	r3,40(r2)
 8246644:	e0bffa17 	ldw	r2,-24(fp)
 8246648:	10c00015 	stw	r3,0(r2)
      return (0);
 824664c:	0005883a 	mov	r2,zero
 8246650:	00001d06 	br	82466c8 <ip_getmoptions+0xf8>

   case IP_MULTICAST_TTL:
      ttl = (u_char *)val;
 8246654:	e0bfff17 	ldw	r2,-4(fp)
 8246658:	e0bffb15 	stw	r2,-20(fp)
      if (imo == NULL)
 824665c:	e0bff917 	ldw	r2,-28(fp)
 8246660:	1000041e 	bne	r2,zero,8246674 <ip_getmoptions+0xa4>
         *ttl = IP_DEFAULT_MULTICAST_TTL;
 8246664:	e0bffb17 	ldw	r2,-20(fp)
 8246668:	00c00044 	movi	r3,1
 824666c:	10c00005 	stb	r3,0(r2)
 8246670:	00000406 	br	8246684 <ip_getmoptions+0xb4>
      else
         *ttl = imo->imo_multicast_ttl;
 8246674:	e0bff917 	ldw	r2,-28(fp)
 8246678:	10c00103 	ldbu	r3,4(r2)
 824667c:	e0bffb17 	ldw	r2,-20(fp)
 8246680:	10c00005 	stb	r3,0(r2)
      return (0);
 8246684:	0005883a 	mov	r2,zero
 8246688:	00000f06 	br	82466c8 <ip_getmoptions+0xf8>

   case IP_MULTICAST_LOOP:
      loop = (u_char *)val;
 824668c:	e0bfff17 	ldw	r2,-4(fp)
 8246690:	e0bffc15 	stw	r2,-16(fp)
      if (imo == NULL)
 8246694:	e0bff917 	ldw	r2,-28(fp)
 8246698:	1000041e 	bne	r2,zero,82466ac <ip_getmoptions+0xdc>
         *loop = IP_DEFAULT_MULTICAST_LOOP;
 824669c:	e0bffc17 	ldw	r2,-16(fp)
 82466a0:	00c00044 	movi	r3,1
 82466a4:	10c00005 	stb	r3,0(r2)
 82466a8:	00000406 	br	82466bc <ip_getmoptions+0xec>
      else
         *loop = imo->imo_multicast_loop;
 82466ac:	e0bff917 	ldw	r2,-28(fp)
 82466b0:	10c00143 	ldbu	r3,5(r2)
 82466b4:	e0bffc17 	ldw	r2,-16(fp)
 82466b8:	10c00005 	stb	r3,0(r2)
      return (0);
 82466bc:	0005883a 	mov	r2,zero
 82466c0:	00000106 	br	82466c8 <ip_getmoptions+0xf8>

      default:
      return (EOPNOTSUPP);
 82466c4:	008017c4 	movi	r2,95
   }
}
 82466c8:	e037883a 	mov	sp,fp
 82466cc:	df000017 	ldw	fp,0(sp)
 82466d0:	dec00104 	addi	sp,sp,4
 82466d4:	f800283a 	ret

082466d8 <ip_freemoptions>:
 * RETURNS: 
 */

void
ip_freemoptions(struct ip_moptions * imo)
{
 82466d8:	defffc04 	addi	sp,sp,-16
 82466dc:	dfc00315 	stw	ra,12(sp)
 82466e0:	df000215 	stw	fp,8(sp)
 82466e4:	df000204 	addi	fp,sp,8
 82466e8:	e13fff15 	stw	r4,-4(fp)
   u_short  i;

   if (imo != NULL) 
 82466ec:	e0bfff17 	ldw	r2,-4(fp)
 82466f0:	10001526 	beq	r2,zero,8246748 <ip_freemoptions+0x70>
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 82466f4:	e03ffe0d 	sth	zero,-8(fp)
 82466f8:	00000c06 	br	824672c <ip_freemoptions+0x54>
         in_delmulti(imo->imo_membership[i]);
 82466fc:	e0bffe0b 	ldhu	r2,-8(fp)
 8246700:	e0ffff17 	ldw	r3,-4(fp)
 8246704:	10800084 	addi	r2,r2,2
 8246708:	1085883a 	add	r2,r2,r2
 824670c:	1085883a 	add	r2,r2,r2
 8246710:	1885883a 	add	r2,r3,r2
 8246714:	10800017 	ldw	r2,0(r2)
 8246718:	1009883a 	mov	r4,r2
 824671c:	8243af80 	call	8243af8 <in_delmulti>
{
   u_short  i;

   if (imo != NULL) 
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 8246720:	e0bffe0b 	ldhu	r2,-8(fp)
 8246724:	10800044 	addi	r2,r2,1
 8246728:	e0bffe0d 	sth	r2,-8(fp)
 824672c:	e0bfff17 	ldw	r2,-4(fp)
 8246730:	1080018b 	ldhu	r2,6(r2)
 8246734:	10bfffcc 	andi	r2,r2,65535
 8246738:	e0fffe0b 	ldhu	r3,-8(fp)
 824673c:	18bfef36 	bltu	r3,r2,82466fc <ip_freemoptions+0x24>
         in_delmulti(imo->imo_membership[i]);
      npfree(imo);
 8246740:	e13fff17 	ldw	r4,-4(fp)
 8246744:	822e1fc0 	call	822e1fc <npfree>
   }
}
 8246748:	0001883a 	nop
 824674c:	e037883a 	mov	sp,fp
 8246750:	dfc00117 	ldw	ra,4(sp)
 8246754:	df000017 	ldw	fp,0(sp)
 8246758:	dec00204 	addi	sp,sp,8
 824675c:	f800283a 	ret

08246760 <u_mctest_init>:
 *
 * RETURNS: 
 */

void u_mctest_init()
{
 8246760:	defffe04 	addi	sp,sp,-8
 8246764:	dfc00115 	stw	ra,4(sp)
 8246768:	df000015 	stw	fp,0(sp)
 824676c:	d839883a 	mov	fp,sp
   printf("mctest init called\n");
 8246770:	01020974 	movhi	r4,2085
 8246774:	2105f204 	addi	r4,r4,6088
 8246778:	82036800 	call	8203680 <puts>
// altera changes end (cadler@altera.com)
   install_menu(u_mctest_menu);
// altera changes begin (cadler@altera.com)
#endif //IN_MENUS
// altera changes end (cadler@altera.com)
}
 824677c:	0001883a 	nop
 8246780:	e037883a 	mov	sp,fp
 8246784:	dfc00117 	ldw	ra,4(sp)
 8246788:	df000017 	ldw	fp,0(sp)
 824678c:	dec00204 	addi	sp,sp,8
 8246790:	f800283a 	ret

08246794 <u_mctest_run>:
 *
 * RETURNS: 
 */

int u_mctest_run(void * pio)
{
 8246794:	defede04 	addi	sp,sp,-1160
 8246798:	dfc12115 	stw	ra,1156(sp)
 824679c:	df012015 	stw	fp,1152(sp)
 82467a0:	df012004 	addi	fp,sp,1152
 82467a4:	e13fff15 	stw	r4,-4(fp)
    struct sockaddr_in   stLocal, stTo, stFrom;
    char  achIn[BUFSIZE];
    char  achOut[] = "Message number:              ";
 82467a8:	009cdcf4 	movhi	r2,29555
 82467ac:	10995344 	addi	r2,r2,25933
 82467b0:	e0bff215 	stw	r2,-56(fp)
 82467b4:	00881974 	movhi	r2,8293
 82467b8:	1099d844 	addi	r2,r2,26465
 82467bc:	e0bff315 	stw	r2,-52(fp)
 82467c0:	00989b74 	movhi	r2,25197
 82467c4:	109d5b84 	addi	r2,r2,30062
 82467c8:	e0bff415 	stw	r2,-48(fp)
 82467cc:	00880eb4 	movhi	r2,8250
 82467d0:	109c9944 	addi	r2,r2,29285
 82467d4:	e0bff515 	stw	r2,-44(fp)
 82467d8:	00880834 	movhi	r2,8224
 82467dc:	10880804 	addi	r2,r2,8224
 82467e0:	e0bff615 	stw	r2,-40(fp)
 82467e4:	00880834 	movhi	r2,8224
 82467e8:	10880804 	addi	r2,r2,8224
 82467ec:	e0bff715 	stw	r2,-36(fp)
 82467f0:	00880834 	movhi	r2,8224
 82467f4:	10880804 	addi	r2,r2,8224
 82467f8:	e0bff815 	stw	r2,-32(fp)
 82467fc:	00800804 	movi	r2,32
 8246800:	e0bff90d 	sth	r2,-28(fp)
    struct ip_mreq stMreq;
    u_char cTmp;
    unsigned long endtime;

   /* get a datagram socket */
   s = t_socket(AF_INET,SOCK_DGRAM, 0);
 8246804:	000d883a 	mov	r6,zero
 8246808:	01400084 	movi	r5,2
 824680c:	01000084 	movi	r4,2
 8246810:	823048c0 	call	823048c <t_socket>
 8246814:	e0bee315 	stw	r2,-1140(fp)

   if (s == INVALID_SOCKET) 
 8246818:	e0bee317 	ldw	r2,-1140(fp)
 824681c:	10bfffd8 	cmpnei	r2,r2,-1
 8246820:	1000091e 	bne	r2,zero,8246848 <u_mctest_run+0xb4>
   {
      ns_printf (pio,"t_socket() failed, Err: %d\n", t_errno(s));
 8246824:	e13ee317 	ldw	r4,-1140(fp)
 8246828:	82319f80 	call	82319f8 <t_errno>
 824682c:	100d883a 	mov	r6,r2
 8246830:	01420974 	movhi	r5,2085
 8246834:	2945f704 	addi	r5,r5,6108
 8246838:	e13fff17 	ldw	r4,-4(fp)
 824683c:	8228ebc0 	call	8228ebc <ns_printf>
      exit(1);
 8246840:	01000044 	movi	r4,1
 8246844:	824b6b40 	call	824b6b4 <exit>
   }

   /* avoid EADDRINUSE error on bind() */ 
   iTmp = 1;
 8246848:	00800044 	movi	r2,1
 824684c:	e0bffa15 	stw	r2,-24(fp)
   iRet = t_setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *)&iTmp, sizeof(iTmp));
 8246850:	e0fffa04 	addi	r3,fp,-24
 8246854:	00800104 	movi	r2,4
 8246858:	d8800015 	stw	r2,0(sp)
 824685c:	180f883a 	mov	r7,r3
 8246860:	01800104 	movi	r6,4
 8246864:	017fffc4 	movi	r5,-1
 8246868:	e13ee317 	ldw	r4,-1140(fp)
 824686c:	8230e6c0 	call	8230e6c <t_setsockopt>
 8246870:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 8246874:	e0bee417 	ldw	r2,-1136(fp)
 8246878:	10bfffd8 	cmpnei	r2,r2,-1
 824687c:	1000071e 	bne	r2,zero,824689c <u_mctest_run+0x108>
   {
      ns_printf (pio,"t_setsockopt() SO_REUSEADDR failed, Err: %d\n",
 8246880:	e13ee317 	ldw	r4,-1140(fp)
 8246884:	82319f80 	call	82319f8 <t_errno>
 8246888:	100d883a 	mov	r6,r2
 824688c:	01420974 	movhi	r5,2085
 8246890:	2945fe04 	addi	r5,r5,6136
 8246894:	e13fff17 	ldw	r4,-4(fp)
 8246898:	8228ebc0 	call	8228ebc <ns_printf>
       t_errno(s));
   }

   /* name the socket */
   stLocal.sin_family =   AF_INET;
 824689c:	00800084 	movi	r2,2
 82468a0:	e0bee60d 	sth	r2,-1128(fp)
   stLocal.sin_addr.s_addr = htonl(INADDR_ANY);
 82468a4:	e03ee715 	stw	zero,-1124(fp)
   stLocal.sin_port =   htons(TEST_PORT);
 82468a8:	00a00344 	movi	r2,-32755
 82468ac:	e0bee68d 	sth	r2,-1126(fp)
   iRet = t_bind(s, (struct sockaddr*) &stLocal, sizeof(struct sockaddr_in));
 82468b0:	e0bee604 	addi	r2,fp,-1128
 82468b4:	01800404 	movi	r6,16
 82468b8:	100b883a 	mov	r5,r2
 82468bc:	e13ee317 	ldw	r4,-1140(fp)
 82468c0:	823050c0 	call	823050c <t_bind>
 82468c4:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 82468c8:	e0bee417 	ldw	r2,-1136(fp)
 82468cc:	10bfffd8 	cmpnei	r2,r2,-1
 82468d0:	1000061e 	bne	r2,zero,82468ec <u_mctest_run+0x158>
   {
      printf ("t_bind() failed, Err: %d\n",
 82468d4:	e13ee317 	ldw	r4,-1140(fp)
 82468d8:	82319f80 	call	82319f8 <t_errno>
 82468dc:	100b883a 	mov	r5,r2
 82468e0:	01020974 	movhi	r4,2085
 82468e4:	21060a04 	addi	r4,r4,6184
 82468e8:	82033fc0 	call	82033fc <printf>
       t_errno(s));
   }

   /* join the multicast group. TEST_ADDR */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR);
 82468ec:	01820974 	movhi	r6,2085
 82468f0:	31861104 	addi	r6,r6,6212
 82468f4:	01420974 	movhi	r5,2085
 82468f8:	29461404 	addi	r5,r5,6224
 82468fc:	e13fff17 	ldw	r4,-4(fp)
 8246900:	8228ebc0 	call	8228ebc <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 8246904:	01020974 	movhi	r4,2085
 8246908:	21061104 	addi	r4,r4,6212
 824690c:	82478700 	call	8247870 <inet_addr>
 8246910:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 8246914:	008209b4 	movhi	r2,2086
 8246918:	10b77d04 	addi	r2,r2,-8716
 824691c:	10800a17 	ldw	r2,40(r2)
 8246920:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP,
 8246924:	e0fffb04 	addi	r3,fp,-20
 8246928:	00800204 	movi	r2,8
 824692c:	d8800015 	stw	r2,0(sp)
 8246930:	180f883a 	mov	r7,r3
 8246934:	01800304 	movi	r6,12
 8246938:	000b883a 	mov	r5,zero
 824693c:	e13ee317 	ldw	r4,-1140(fp)
 8246940:	8230e6c0 	call	8230e6c <t_setsockopt>
 8246944:	e0bee415 	stw	r2,-1136(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 8246948:	e0bee417 	ldw	r2,-1136(fp)
 824694c:	10bfffd8 	cmpnei	r2,r2,-1
 8246950:	1000071e 	bne	r2,zero,8246970 <u_mctest_run+0x1dc>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 8246954:	e13ee317 	ldw	r4,-1140(fp)
 8246958:	82319f80 	call	82319f8 <t_errno>
 824695c:	100d883a 	mov	r6,r2
 8246960:	01420974 	movhi	r5,2085
 8246964:	29461c04 	addi	r5,r5,6256
 8246968:	e13fff17 	ldw	r4,-4(fp)
 824696c:	8228ebc0 	call	8228ebc <ns_printf>
                     t_errno(s));
   } 
   tk_yield();
 8246970:	82298680 	call	8229868 <tk_yield>

   /* join the multicast group. TEST_ADDR1 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR1);
 8246974:	01820974 	movhi	r6,2085
 8246978:	31862904 	addi	r6,r6,6308
 824697c:	01420974 	movhi	r5,2085
 8246980:	29461404 	addi	r5,r5,6224
 8246984:	e13fff17 	ldw	r4,-4(fp)
 8246988:	8228ebc0 	call	8228ebc <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR1);
 824698c:	01020974 	movhi	r4,2085
 8246990:	21062904 	addi	r4,r4,6308
 8246994:	82478700 	call	8247870 <inet_addr>
 8246998:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 824699c:	008209b4 	movhi	r2,2086
 82469a0:	10b77d04 	addi	r2,r2,-8716
 82469a4:	10800a17 	ldw	r2,40(r2)
 82469a8:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 82469ac:	e0fffb04 	addi	r3,fp,-20
 82469b0:	00800204 	movi	r2,8
 82469b4:	d8800015 	stw	r2,0(sp)
 82469b8:	180f883a 	mov	r7,r3
 82469bc:	01800304 	movi	r6,12
 82469c0:	000b883a 	mov	r5,zero
 82469c4:	e13ee317 	ldw	r4,-1140(fp)
 82469c8:	8230e6c0 	call	8230e6c <t_setsockopt>
 82469cc:	e0bee415 	stw	r2,-1136(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 82469d0:	e0bee417 	ldw	r2,-1136(fp)
 82469d4:	10bfffd8 	cmpnei	r2,r2,-1
 82469d8:	1000071e 	bne	r2,zero,82469f8 <u_mctest_run+0x264>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 82469dc:	e13ee317 	ldw	r4,-1140(fp)
 82469e0:	82319f80 	call	82319f8 <t_errno>
 82469e4:	100d883a 	mov	r6,r2
 82469e8:	01420974 	movhi	r5,2085
 82469ec:	29461c04 	addi	r5,r5,6256
 82469f0:	e13fff17 	ldw	r4,-4(fp)
 82469f4:	8228ebc0 	call	8228ebc <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 82469f8:	82298680 	call	8229868 <tk_yield>

   /* join the multicast group. TEST_ADDR2 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR2);
 82469fc:	01820974 	movhi	r6,2085
 8246a00:	31862c04 	addi	r6,r6,6320
 8246a04:	01420974 	movhi	r5,2085
 8246a08:	29461404 	addi	r5,r5,6224
 8246a0c:	e13fff17 	ldw	r4,-4(fp)
 8246a10:	8228ebc0 	call	8228ebc <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR2);
 8246a14:	01020974 	movhi	r4,2085
 8246a18:	21062c04 	addi	r4,r4,6320
 8246a1c:	82478700 	call	8247870 <inet_addr>
 8246a20:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 8246a24:	008209b4 	movhi	r2,2086
 8246a28:	10b77d04 	addi	r2,r2,-8716
 8246a2c:	10800a17 	ldw	r2,40(r2)
 8246a30:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 8246a34:	e0fffb04 	addi	r3,fp,-20
 8246a38:	00800204 	movi	r2,8
 8246a3c:	d8800015 	stw	r2,0(sp)
 8246a40:	180f883a 	mov	r7,r3
 8246a44:	01800304 	movi	r6,12
 8246a48:	000b883a 	mov	r5,zero
 8246a4c:	e13ee317 	ldw	r4,-1140(fp)
 8246a50:	8230e6c0 	call	8230e6c <t_setsockopt>
 8246a54:	e0bee415 	stw	r2,-1136(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 8246a58:	e0bee417 	ldw	r2,-1136(fp)
 8246a5c:	10bfffd8 	cmpnei	r2,r2,-1
 8246a60:	1000071e 	bne	r2,zero,8246a80 <u_mctest_run+0x2ec>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 8246a64:	e13ee317 	ldw	r4,-1140(fp)
 8246a68:	82319f80 	call	82319f8 <t_errno>
 8246a6c:	100d883a 	mov	r6,r2
 8246a70:	01420974 	movhi	r5,2085
 8246a74:	29461c04 	addi	r5,r5,6256
 8246a78:	e13fff17 	ldw	r4,-4(fp)
 8246a7c:	8228ebc0 	call	8228ebc <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 8246a80:	82298680 	call	8229868 <tk_yield>

   /* set TTL to traverse up to multiple routers */
   cTmp = TTL_VALUE;
 8246a84:	00800084 	movi	r2,2
 8246a88:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, (char *)&cTmp, sizeof(cTmp));
 8246a8c:	e0fffd04 	addi	r3,fp,-12
 8246a90:	00800044 	movi	r2,1
 8246a94:	d8800015 	stw	r2,0(sp)
 8246a98:	180f883a 	mov	r7,r3
 8246a9c:	01800284 	movi	r6,10
 8246aa0:	000b883a 	mov	r5,zero
 8246aa4:	e13ee317 	ldw	r4,-1140(fp)
 8246aa8:	8230e6c0 	call	8230e6c <t_setsockopt>
 8246aac:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 8246ab0:	e0bee417 	ldw	r2,-1136(fp)
 8246ab4:	10bfffd8 	cmpnei	r2,r2,-1
 8246ab8:	1000071e 	bne	r2,zero,8246ad8 <u_mctest_run+0x344>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_TTL failed, Err: %d\n",
 8246abc:	e13ee317 	ldw	r4,-1140(fp)
 8246ac0:	82319f80 	call	82319f8 <t_errno>
 8246ac4:	100d883a 	mov	r6,r2
 8246ac8:	01420974 	movhi	r5,2085
 8246acc:	29462f04 	addi	r5,r5,6332
 8246ad0:	e13fff17 	ldw	r4,-4(fp)
 8246ad4:	8228ebc0 	call	8228ebc <ns_printf>
                     t_errno(s));
   }

   /* enable loopback */
   cTmp = 1;
 8246ad8:	00800044 	movi	r2,1
 8246adc:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP, (char *)&cTmp, sizeof(cTmp));
 8246ae0:	e0fffd04 	addi	r3,fp,-12
 8246ae4:	00800044 	movi	r2,1
 8246ae8:	d8800015 	stw	r2,0(sp)
 8246aec:	180f883a 	mov	r7,r3
 8246af0:	018002c4 	movi	r6,11
 8246af4:	000b883a 	mov	r5,zero
 8246af8:	e13ee317 	ldw	r4,-1140(fp)
 8246afc:	8230e6c0 	call	8230e6c <t_setsockopt>
 8246b00:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 8246b04:	e0bee417 	ldw	r2,-1136(fp)
 8246b08:	10bfffd8 	cmpnei	r2,r2,-1
 8246b0c:	1000071e 	bne	r2,zero,8246b2c <u_mctest_run+0x398>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_LOOP failed, Err: %d\n",
 8246b10:	e13ee317 	ldw	r4,-1140(fp)
 8246b14:	82319f80 	call	82319f8 <t_errno>
 8246b18:	100d883a 	mov	r6,r2
 8246b1c:	01420974 	movhi	r5,2085
 8246b20:	29463c04 	addi	r5,r5,6384
 8246b24:	e13fff17 	ldw	r4,-4(fp)
 8246b28:	8228ebc0 	call	8228ebc <ns_printf>
                     t_errno(s));
   }

   /* assign our destination address */
   stTo.sin_family =      AF_INET;
 8246b2c:	00800084 	movi	r2,2
 8246b30:	e0beea0d 	sth	r2,-1112(fp)
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
 8246b34:	01020974 	movhi	r4,2085
 8246b38:	21062904 	addi	r4,r4,6308
 8246b3c:	82478700 	call	8247870 <inet_addr>
 8246b40:	e0beeb15 	stw	r2,-1108(fp)
   stTo.sin_port =        htons(TEST_PORT);
 8246b44:	00a00344 	movi	r2,-32755
 8246b48:	e0beea8d 	sth	r2,-1110(fp)
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
 8246b4c:	01820974 	movhi	r6,2085
 8246b50:	31862904 	addi	r6,r6,6308
 8246b54:	01420974 	movhi	r5,2085
 8246b58:	29464904 	addi	r5,r5,6436
 8246b5c:	e13fff17 	ldw	r4,-4(fp)
 8246b60:	8228ebc0 	call	8228ebc <ns_printf>
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 8246b64:	e03ee215 	stw	zero,-1144(fp)
 8246b68:	00008606 	br	8246d84 <u_mctest_run+0x5f0>
   {
      static int iCounter = 1;

      /* send to the multicast address */
      sprintf(&achOut[16], "%d", iCounter++);
 8246b6c:	d0a05217 	ldw	r2,-32440(gp)
 8246b70:	10c00044 	addi	r3,r2,1
 8246b74:	d0e05215 	stw	r3,-32440(gp)
 8246b78:	e0fff204 	addi	r3,fp,-56
 8246b7c:	18c00404 	addi	r3,r3,16
 8246b80:	100d883a 	mov	r6,r2
 8246b84:	01420974 	movhi	r5,2085
 8246b88:	29465804 	addi	r5,r5,6496
 8246b8c:	1809883a 	mov	r4,r3
 8246b90:	82037740 	call	8203774 <sprintf>
      iRet = t_sendto(s, achOut, sizeof(achOut), 0, (struct sockaddr*)&stTo,
 8246b94:	e0fff204 	addi	r3,fp,-56
 8246b98:	00800404 	movi	r2,16
 8246b9c:	d8800115 	stw	r2,4(sp)
 8246ba0:	e0beea04 	addi	r2,fp,-1112
 8246ba4:	d8800015 	stw	r2,0(sp)
 8246ba8:	000f883a 	mov	r7,zero
 8246bac:	01800784 	movi	r6,30
 8246bb0:	180b883a 	mov	r5,r3
 8246bb4:	e13ee317 	ldw	r4,-1140(fp)
 8246bb8:	82313d80 	call	82313d8 <t_sendto>
 8246bbc:	e0bee415 	stw	r2,-1136(fp)
                      sizeof(struct sockaddr_in));
      if (iRet < 0) 
 8246bc0:	e0bee417 	ldw	r2,-1136(fp)
 8246bc4:	1000080e 	bge	r2,zero,8246be8 <u_mctest_run+0x454>
      {
         /*      perror("sendto() failed\n"); */
         ns_printf (pio,"t_sendto() failed, Error: %d\n", t_errno(s));
 8246bc8:	e13ee317 	ldw	r4,-1140(fp)
 8246bcc:	82319f80 	call	82319f8 <t_errno>
 8246bd0:	100d883a 	mov	r6,r2
 8246bd4:	01420974 	movhi	r5,2085
 8246bd8:	29465904 	addi	r5,r5,6500
 8246bdc:	e13fff17 	ldw	r4,-4(fp)
 8246be0:	8228ebc0 	call	8228ebc <ns_printf>
         /*     exit(1); */
         goto exitloop;
 8246be4:	00006a06 	br	8246d90 <u_mctest_run+0x5fc>
      }

      /* make the socket non-blocking */
      iTmp = 1;
 8246be8:	00800044 	movi	r2,1
 8246bec:	e0bffa15 	stw	r2,-24(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&iTmp, sizeof(iTmp));
 8246bf0:	e0fffa04 	addi	r3,fp,-24
 8246bf4:	00800104 	movi	r2,4
 8246bf8:	d8800015 	stw	r2,0(sp)
 8246bfc:	180f883a 	mov	r7,r3
 8246c00:	01840584 	movi	r6,4118
 8246c04:	017fffc4 	movi	r5,-1
 8246c08:	e13ee317 	ldw	r4,-1140(fp)
 8246c0c:	8230e6c0 	call	8230e6c <t_setsockopt>
 8246c10:	e0bee415 	stw	r2,-1136(fp)
      if (iRet == SOCKET_ERROR) 
 8246c14:	e0bee417 	ldw	r2,-1136(fp)
 8246c18:	10bfffd8 	cmpnei	r2,r2,-1
 8246c1c:	1000071e 	bne	r2,zero,8246c3c <u_mctest_run+0x4a8>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (1) failed, Err: %d\n",
 8246c20:	e13ee317 	ldw	r4,-1140(fp)
 8246c24:	82319f80 	call	82319f8 <t_errno>
 8246c28:	100d883a 	mov	r6,r2
 8246c2c:	01420974 	movhi	r5,2085
 8246c30:	29466104 	addi	r5,r5,6532
 8246c34:	e13fff17 	ldw	r4,-4(fp)
 8246c38:	8228ebc0 	call	8228ebc <ns_printf>
                        t_errno(s));
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);
 8246c3c:	d0a0a817 	ldw	r2,-32096(gp)
 8246c40:	10807d04 	addi	r2,r2,500
 8246c44:	e0bee515 	stw	r2,-1132(fp)

      while (cticks < endtime)
 8246c48:	00003406 	br	8246d1c <u_mctest_run+0x588>
      {
         int sa_size = sizeof(struct sockaddr_in);
 8246c4c:	00800404 	movi	r2,16
 8246c50:	e0bffe15 	stw	r2,-8(fp)
         tk_yield();
 8246c54:	82298680 	call	8229868 <tk_yield>

         iRet = t_recvfrom(s, achIn, BUFSIZE, 0, (struct sockaddr*)&stFrom, &sa_size);
 8246c58:	e0fef204 	addi	r3,fp,-1080
 8246c5c:	e0bffe04 	addi	r2,fp,-8
 8246c60:	d8800115 	stw	r2,4(sp)
 8246c64:	e0beee04 	addi	r2,fp,-1096
 8246c68:	d8800015 	stw	r2,0(sp)
 8246c6c:	000f883a 	mov	r7,zero
 8246c70:	01810004 	movi	r6,1024
 8246c74:	180b883a 	mov	r5,r3
 8246c78:	e13ee317 	ldw	r4,-1140(fp)
 8246c7c:	82312980 	call	8231298 <t_recvfrom>
 8246c80:	e0bee415 	stw	r2,-1136(fp)
         if (iRet < 0) 
 8246c84:	e0bee417 	ldw	r2,-1136(fp)
 8246c88:	10000c0e 	bge	r2,zero,8246cbc <u_mctest_run+0x528>
         {
            if (t_errno(s) != EWOULDBLOCK)
 8246c8c:	e13ee317 	ldw	r4,-1140(fp)
 8246c90:	82319f80 	call	82319f8 <t_errno>
 8246c94:	108002e0 	cmpeqi	r2,r2,11
 8246c98:	1000081e 	bne	r2,zero,8246cbc <u_mctest_run+0x528>
            {
               /*      perror("recvfrom() failed\n"); */
               ns_printf (pio,"t_recvfrom() failed, Error: %d\n", t_errno(s));
 8246c9c:	e13ee317 	ldw	r4,-1140(fp)
 8246ca0:	82319f80 	call	82319f8 <t_errno>
 8246ca4:	100d883a 	mov	r6,r2
 8246ca8:	01420974 	movhi	r5,2085
 8246cac:	29466d04 	addi	r5,r5,6580
 8246cb0:	e13fff17 	ldw	r4,-4(fp)
 8246cb4:	8228ebc0 	call	8228ebc <ns_printf>
 8246cb8:	00003506 	br	8246d90 <u_mctest_run+0x5fc>
               /*     exit(1); */
               goto exitloop;
            }
         }
         if (iRet > 0)
 8246cbc:	e0bee417 	ldw	r2,-1136(fp)
 8246cc0:	0080160e 	bge	zero,r2,8246d1c <u_mctest_run+0x588>
         {
            ns_printf(pio,"From host:%s port:%d, %s\n",
 8246cc4:	e0beef17 	ldw	r2,-1092(fp)
 8246cc8:	1009883a 	mov	r4,r2
 8246ccc:	8228a500 	call	8228a50 <print_ipad>
 8246cd0:	1009883a 	mov	r4,r2
             print_ipad(stFrom.sin_addr.s_addr),
             ntohs(stFrom.sin_port), achIn);
 8246cd4:	e0beee8b 	ldhu	r2,-1094(fp)
 8246cd8:	10bfffcc 	andi	r2,r2,65535
 8246cdc:	1004d23a 	srli	r2,r2,8
 8246ce0:	10bfffcc 	andi	r2,r2,65535
 8246ce4:	10c03fcc 	andi	r3,r2,255
 8246ce8:	e0beee8b 	ldhu	r2,-1094(fp)
 8246cec:	10bfffcc 	andi	r2,r2,65535
 8246cf0:	1004923a 	slli	r2,r2,8
 8246cf4:	10bfffcc 	andi	r2,r2,65535
               goto exitloop;
            }
         }
         if (iRet > 0)
         {
            ns_printf(pio,"From host:%s port:%d, %s\n",
 8246cf8:	1886b03a 	or	r3,r3,r2
 8246cfc:	e0bef204 	addi	r2,fp,-1080
 8246d00:	d8800015 	stw	r2,0(sp)
 8246d04:	180f883a 	mov	r7,r3
 8246d08:	200d883a 	mov	r6,r4
 8246d0c:	01420974 	movhi	r5,2085
 8246d10:	29467504 	addi	r5,r5,6612
 8246d14:	e13fff17 	ldw	r4,-4(fp)
 8246d18:	8228ebc0 	call	8228ebc <ns_printf>
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);

      while (cticks < endtime)
 8246d1c:	d0e0a817 	ldw	r3,-32096(gp)
 8246d20:	e0bee517 	ldw	r2,-1132(fp)
 8246d24:	18bfc936 	bltu	r3,r2,8246c4c <u_mctest_run+0x4b8>
             ntohs(stFrom.sin_port), achIn);
         }
      }   /* end while (cticks...) */

      /* make the socket blocking */
      cTmp = 0;
 8246d28:	e03ffd05 	stb	zero,-12(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&cTmp, sizeof(cTmp));
 8246d2c:	e0fffd04 	addi	r3,fp,-12
 8246d30:	00800044 	movi	r2,1
 8246d34:	d8800015 	stw	r2,0(sp)
 8246d38:	180f883a 	mov	r7,r3
 8246d3c:	01840584 	movi	r6,4118
 8246d40:	017fffc4 	movi	r5,-1
 8246d44:	e13ee317 	ldw	r4,-1140(fp)
 8246d48:	8230e6c0 	call	8230e6c <t_setsockopt>
 8246d4c:	e0bee415 	stw	r2,-1136(fp)
      if (iRet == SOCKET_ERROR) 
 8246d50:	e0bee417 	ldw	r2,-1136(fp)
 8246d54:	10bfffd8 	cmpnei	r2,r2,-1
 8246d58:	1000071e 	bne	r2,zero,8246d78 <u_mctest_run+0x5e4>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (0) failed, Err: %d\n",
 8246d5c:	e13ee317 	ldw	r4,-1140(fp)
 8246d60:	82319f80 	call	82319f8 <t_errno>
 8246d64:	100d883a 	mov	r6,r2
 8246d68:	01420974 	movhi	r5,2085
 8246d6c:	29467c04 	addi	r5,r5,6640
 8246d70:	e13fff17 	ldw	r4,-4(fp)
 8246d74:	8228ebc0 	call	8228ebc <ns_printf>
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
   stTo.sin_port =        htons(TEST_PORT);
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 8246d78:	e0bee217 	ldw	r2,-1144(fp)
 8246d7c:	10800044 	addi	r2,r2,1
 8246d80:	e0bee215 	stw	r2,-1144(fp)
 8246d84:	e0bee217 	ldw	r2,-1144(fp)
 8246d88:	108000d0 	cmplti	r2,r2,3
 8246d8c:	103f771e 	bne	r2,zero,8246b6c <u_mctest_run+0x3d8>
      }
   }   /* end for(;;) */

exitloop:
   /* delete the multicast group. */
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 8246d90:	01020974 	movhi	r4,2085
 8246d94:	21061104 	addi	r4,r4,6212
 8246d98:	82478700 	call	8247870 <inet_addr>
 8246d9c:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 8246da0:	008209b4 	movhi	r2,2086
 8246da4:	10b77d04 	addi	r2,r2,-8716
 8246da8:	10800a17 	ldw	r2,40(r2)
 8246dac:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_DROP_MEMBERSHIP, (char *)&stMreq, sizeof(stMreq));
 8246db0:	e0fffb04 	addi	r3,fp,-20
 8246db4:	00800204 	movi	r2,8
 8246db8:	d8800015 	stw	r2,0(sp)
 8246dbc:	180f883a 	mov	r7,r3
 8246dc0:	01800344 	movi	r6,13
 8246dc4:	000b883a 	mov	r5,zero
 8246dc8:	e13ee317 	ldw	r4,-1140(fp)
 8246dcc:	8230e6c0 	call	8230e6c <t_setsockopt>
 8246dd0:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 8246dd4:	e0bee417 	ldw	r2,-1136(fp)
 8246dd8:	10bfffd8 	cmpnei	r2,r2,-1
 8246ddc:	1000071e 	bne	r2,zero,8246dfc <u_mctest_run+0x668>
   {
      ns_printf (pio,"t_setsockopt() IP_DROP_MEMBERSHIP failed, Err: %d\n",
 8246de0:	e13ee317 	ldw	r4,-1140(fp)
 8246de4:	82319f80 	call	82319f8 <t_errno>
 8246de8:	100d883a 	mov	r6,r2
 8246dec:	01420974 	movhi	r5,2085
 8246df0:	29468804 	addi	r5,r5,6688
 8246df4:	e13fff17 	ldw	r4,-4(fp)
 8246df8:	8228ebc0 	call	8228ebc <ns_printf>
   {
      ns_printf (pio,"t_shutdown failed.  Err: %d\n", t_errno(s));
   }
#endif

   iRet = t_socketclose(s);
 8246dfc:	e13ee317 	ldw	r4,-1140(fp)
 8246e00:	82318a80 	call	82318a8 <t_socketclose>
 8246e04:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 8246e08:	e0bee417 	ldw	r2,-1136(fp)
 8246e0c:	10bfffd8 	cmpnei	r2,r2,-1
 8246e10:	1000071e 	bne	r2,zero,8246e30 <u_mctest_run+0x69c>
   {
      ns_printf (pio,"t_socketclose() failed.  Err: %d\n", t_errno(s));
 8246e14:	e13ee317 	ldw	r4,-1140(fp)
 8246e18:	82319f80 	call	82319f8 <t_errno>
 8246e1c:	100d883a 	mov	r6,r2
 8246e20:	01420974 	movhi	r5,2085
 8246e24:	29469504 	addi	r5,r5,6740
 8246e28:	e13fff17 	ldw	r4,-4(fp)
 8246e2c:	8228ebc0 	call	8228ebc <ns_printf>
   }

   return(0);
 8246e30:	0005883a 	mov	r2,zero
}  /* end main() */  
 8246e34:	e037883a 	mov	sp,fp
 8246e38:	dfc00117 	ldw	ra,4(sp)
 8246e3c:	df000017 	ldw	fp,0(sp)
 8246e40:	dec00204 	addi	sp,sp,8
 8246e44:	f800283a 	ret

08246e48 <dhc_setup>:
 * RETURNS: void
 */

void
dhc_setup(void)
{  
 8246e48:	defff604 	addi	sp,sp,-40
 8246e4c:	dfc00915 	stw	ra,36(sp)
 8246e50:	df000815 	stw	fp,32(sp)
 8246e54:	df000804 	addi	fp,sp,32
   int      iface;
   ulong    dhcp_started;
   ip_addr  dhcp_saveaddr[STATIC_NETS];
   int      e;
   int      dhcnets = 0;   /* number of nets doing DHCP */
 8246e58:	e03ff915 	stw	zero,-28(fp)

   e = dhc_init();
 8246e5c:	8229b280 	call	8229b28 <dhc_init>
 8246e60:	e0bffa15 	stw	r2,-24(fp)

   if (e)
 8246e64:	e0bffa17 	ldw	r2,-24(fp)
 8246e68:	10000526 	beq	r2,zero,8246e80 <dhc_setup+0x38>
   {
      printf("Error starting DHCP client code.\n");
 8246e6c:	01020974 	movhi	r4,2085
 8246e70:	21069e04 	addi	r4,r4,6776
 8246e74:	82036800 	call	8203680 <puts>
      netexit(1);
 8246e78:	01000044 	movi	r4,1
 8246e7c:	8243ce80 	call	8243ce8 <netexit>
   }

   dhcp_started = cticks;  /* init timeout */
 8246e80:	d0a0a817 	ldw	r2,-32096(gp)
 8246e84:	e0bffb15 	stw	r2,-20(fp)

   for (iface = 0; iface < STATIC_NETS; iface++)
 8246e88:	e03ff815 	stw	zero,-32(fp)
 8246e8c:	00005006 	br	8246fd0 <dhc_setup+0x188>
   {
      if (!nets[iface])
 8246e90:	008209b4 	movhi	r2,2086
 8246e94:	10b83d04 	addi	r2,r2,-7948
 8246e98:	e0fff817 	ldw	r3,-32(fp)
 8246e9c:	18c7883a 	add	r3,r3,r3
 8246ea0:	18c7883a 	add	r3,r3,r3
 8246ea4:	10c5883a 	add	r2,r2,r3
 8246ea8:	10800017 	ldw	r2,0(r2)
 8246eac:	10004226 	beq	r2,zero,8246fb8 <dhc_setup+0x170>
#ifdef INCLUDE_NVPARMS
      if (inet_nvparms.ifs[iface].client_dhcp)
         nets[iface]->n_flags |= NF_DHCPC ; /* use DHCP Client on this iface */
#endif   /* INCLUDE_NVPARMS */

      if (!(nets[iface]->n_flags & NF_DHCPC))
 8246eb0:	008209b4 	movhi	r2,2086
 8246eb4:	10b83d04 	addi	r2,r2,-7948
 8246eb8:	e0fff817 	ldw	r3,-32(fp)
 8246ebc:	18c7883a 	add	r3,r3,r3
 8246ec0:	18c7883a 	add	r3,r3,r3
 8246ec4:	10c5883a 	add	r2,r2,r3
 8246ec8:	10800017 	ldw	r2,0(r2)
 8246ecc:	10802a17 	ldw	r2,168(r2)
 8246ed0:	1080400c 	andi	r2,r2,256
 8246ed4:	10003a26 	beq	r2,zero,8246fc0 <dhc_setup+0x178>
         continue;

      /* If callback is not already in use (by AutoIP) grab it for
       * our printf routine.
       */
      if(dhc_states[iface].callback == NULL)
 8246ed8:	008209b4 	movhi	r2,2086
 8246edc:	10b86304 	addi	r2,r2,-7796
 8246ee0:	e0fff817 	ldw	r3,-32(fp)
 8246ee4:	18c00f24 	muli	r3,r3,60
 8246ee8:	10c5883a 	add	r2,r2,r3
 8246eec:	10800e04 	addi	r2,r2,56
 8246ef0:	10800017 	ldw	r2,0(r2)
 8246ef4:	1000041e 	bne	r2,zero,8246f08 <dhc_setup+0xc0>
      {
         dhc_set_callback(iface, dhc_main_ipset);
 8246ef8:	01420934 	movhi	r5,2084
 8246efc:	295c2b04 	addi	r5,r5,28844
 8246f00:	e13ff817 	ldw	r4,-32(fp)
 8246f04:	8229bd80 	call	8229bd8 <dhc_set_callback>
      }

      /* start DHCP on the iface - first save the default address */
      dhcp_saveaddr[iface] = nets[iface]->n_ipaddr;
 8246f08:	008209b4 	movhi	r2,2086
 8246f0c:	10b83d04 	addi	r2,r2,-7948
 8246f10:	e0fff817 	ldw	r3,-32(fp)
 8246f14:	18c7883a 	add	r3,r3,r3
 8246f18:	18c7883a 	add	r3,r3,r3
 8246f1c:	10c5883a 	add	r2,r2,r3
 8246f20:	10800017 	ldw	r2,0(r2)
 8246f24:	10c00a17 	ldw	r3,40(r2)
 8246f28:	e0bff817 	ldw	r2,-32(fp)
 8246f2c:	1085883a 	add	r2,r2,r2
 8246f30:	1085883a 	add	r2,r2,r2
 8246f34:	e13ff804 	addi	r4,fp,-32
 8246f38:	2085883a 	add	r2,r4,r2
 8246f3c:	10800404 	addi	r2,r2,16
 8246f40:	10c00015 	stw	r3,0(r2)

      if (dhcp_saveaddr[iface] == 0L)  /* see if there is a default */
 8246f44:	e0bff817 	ldw	r2,-32(fp)
 8246f48:	1085883a 	add	r2,r2,r2
 8246f4c:	1085883a 	add	r2,r2,r2
 8246f50:	e0fff804 	addi	r3,fp,-32
 8246f54:	1885883a 	add	r2,r3,r2
 8246f58:	10800404 	addi	r2,r2,16
 8246f5c:	10800017 	ldw	r2,0(r2)
 8246f60:	1000041e 	bne	r2,zero,8246f74 <dhc_setup+0x12c>
         dhc_state_init(iface, TRUE);  /* Put DHCPClient in INIT state */
 8246f64:	01400044 	movi	r5,1
 8246f68:	e13ff817 	ldw	r4,-32(fp)
 8246f6c:	822c4f40 	call	822c4f4 <dhc_state_init>
 8246f70:	00000306 	br	8246f80 <dhc_setup+0x138>
      else
         dhc_state_init(iface, FALSE); /* Put DHCPClient in INIT-REBOOT state */
 8246f74:	000b883a 	mov	r5,zero
 8246f78:	e13ff817 	ldw	r4,-32(fp)
 8246f7c:	822c4f40 	call	822c4f4 <dhc_state_init>

      e=dhc_second();                  /* To send the DISCOVER/REQUEST pkt */
 8246f80:	822bd6c0 	call	822bd6c <dhc_second>
 8246f84:	e0bffa15 	stw	r2,-24(fp)
      if (e)
 8246f88:	e0bffa17 	ldw	r2,-24(fp)
 8246f8c:	10000626 	beq	r2,zero,8246fa8 <dhc_setup+0x160>
      {
         printf("Error sending DHCP packet on iface %d.\n", iface);
 8246f90:	e17ff817 	ldw	r5,-32(fp)
 8246f94:	01020974 	movhi	r4,2085
 8246f98:	2106a704 	addi	r4,r4,6812
 8246f9c:	82033fc0 	call	82033fc <printf>
         netexit(1);
 8246fa0:	01000044 	movi	r4,1
 8246fa4:	8243ce80 	call	8243ce8 <netexit>
      /* If we are not using Auto IP then we want to block below waiting
       * for DHCP completion. If we are using Auto IP then we want to
       * return and let the Auto IP code handle the DHCP completion.
       * "dhcnets" is a flag which allows this.
       */
      dhcnets++;
 8246fa8:	e0bff917 	ldw	r2,-28(fp)
 8246fac:	10800044 	addi	r2,r2,1
 8246fb0:	e0bff915 	stw	r2,-28(fp)
 8246fb4:	00000306 	br	8246fc4 <dhc_setup+0x17c>
   dhcp_started = cticks;  /* init timeout */

   for (iface = 0; iface < STATIC_NETS; iface++)
   {
      if (!nets[iface])
         continue; /* no valid iface for this network */
 8246fb8:	0001883a 	nop
 8246fbc:	00000106 	br	8246fc4 <dhc_setup+0x17c>
      if (inet_nvparms.ifs[iface].client_dhcp)
         nets[iface]->n_flags |= NF_DHCPC ; /* use DHCP Client on this iface */
#endif   /* INCLUDE_NVPARMS */

      if (!(nets[iface]->n_flags & NF_DHCPC))
         continue;
 8246fc0:	0001883a 	nop
      netexit(1);
   }

   dhcp_started = cticks;  /* init timeout */

   for (iface = 0; iface < STATIC_NETS; iface++)
 8246fc4:	e0bff817 	ldw	r2,-32(fp)
 8246fc8:	10800044 	addi	r2,r2,1
 8246fcc:	e0bff815 	stw	r2,-32(fp)
 8246fd0:	e0bff817 	ldw	r2,-32(fp)
 8246fd4:	10800110 	cmplti	r2,r2,4
 8246fd8:	103fad1e 	bne	r2,zero,8246e90 <dhc_setup+0x48>
       */
      dhcnets++;
#endif
   }

   if(dhcnets == 0)  /* no nets doing DHCP? */
 8246fdc:	e0bff917 	ldw	r2,-28(fp)
 8246fe0:	10002c26 	beq	r2,zero,8247094 <dhc_setup+0x24c>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 8246fe4:	00000206 	br	8246ff0 <dhc_setup+0x1a8>
   {
      /* let other tasks spin. This is required, since some systems
       * increment cticks in tasks, or use a polling task to receive
       * packets. Without this activity this loop will never exit.
       */
      tk_yield();
 8246fe8:	82298680 	call	8229868 <tk_yield>
      pktdemux();
 8246fec:	82263200 	call	8226320 <pktdemux>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 8246ff0:	d0e0a817 	ldw	r3,-32096(gp)
 8246ff4:	e0bffb17 	ldw	r2,-20(fp)
 8246ff8:	1885c83a 	sub	r2,r3,r2
 8246ffc:	108cb228 	cmpgeui	r2,r2,13000
 8247000:	1000021e 	bne	r2,zero,824700c <dhc_setup+0x1c4>
      (dhc_alldone() == FALSE))
 8247004:	822c54c0 	call	822c54c <dhc_alldone>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 8247008:	103ff726 	beq	r2,zero,8246fe8 <dhc_setup+0x1a0>
#ifdef SUPERLOOP
      dhc_second ();
#endif
   }

   if (dhc_alldone() == FALSE)   /* dhcp timed out? */
 824700c:	822c54c0 	call	822c54c <dhc_alldone>
 8247010:	1000211e 	bne	r2,zero,8247098 <dhc_setup+0x250>
   {
      dprintf("DHCP timed out, going back to default IP address(es)\n");
 8247014:	01020974 	movhi	r4,2085
 8247018:	2106b104 	addi	r4,r4,6852
 824701c:	82036800 	call	8203680 <puts>
      /* go back to defaults */
      for (iface = 0; iface < STATIC_NETS; iface++)
 8247020:	e03ff815 	stw	zero,-32(fp)
 8247024:	00001706 	br	8247084 <dhc_setup+0x23c>
      {
         if (dhc_ifacedone(iface) == FALSE)
 8247028:	e13ff817 	ldw	r4,-32(fp)
 824702c:	822c5d40 	call	822c5d4 <dhc_ifacedone>
 8247030:	1000111e 	bne	r2,zero,8247078 <dhc_setup+0x230>
         {
            dhc_halt(iface);
 8247034:	e13ff817 	ldw	r4,-32(fp)
 8247038:	822c2bc0 	call	822c2bc <dhc_halt>
            nets[iface]->n_ipaddr = dhcp_saveaddr[iface];
 824703c:	008209b4 	movhi	r2,2086
 8247040:	10b83d04 	addi	r2,r2,-7948
 8247044:	e0fff817 	ldw	r3,-32(fp)
 8247048:	18c7883a 	add	r3,r3,r3
 824704c:	18c7883a 	add	r3,r3,r3
 8247050:	10c5883a 	add	r2,r2,r3
 8247054:	10c00017 	ldw	r3,0(r2)
 8247058:	e0bff817 	ldw	r2,-32(fp)
 824705c:	1085883a 	add	r2,r2,r2
 8247060:	1085883a 	add	r2,r2,r2
 8247064:	e13ff804 	addi	r4,fp,-32
 8247068:	2085883a 	add	r2,r4,r2
 824706c:	10800404 	addi	r2,r2,16
 8247070:	10800017 	ldw	r2,0(r2)
 8247074:	18800a15 	stw	r2,40(r3)

   if (dhc_alldone() == FALSE)   /* dhcp timed out? */
   {
      dprintf("DHCP timed out, going back to default IP address(es)\n");
      /* go back to defaults */
      for (iface = 0; iface < STATIC_NETS; iface++)
 8247078:	e0bff817 	ldw	r2,-32(fp)
 824707c:	10800044 	addi	r2,r2,1
 8247080:	e0bff815 	stw	r2,-32(fp)
 8247084:	e0bff817 	ldw	r2,-32(fp)
 8247088:	10800110 	cmplti	r2,r2,4
 824708c:	103fe61e 	bne	r2,zero,8247028 <dhc_setup+0x1e0>
 8247090:	00000106 	br	8247098 <dhc_setup+0x250>
      dhcnets++;
#endif
   }

   if(dhcnets == 0)  /* no nets doing DHCP? */
      return;
 8247094:	0001883a 	nop
            dhc_halt(iface);
            nets[iface]->n_ipaddr = dhcp_saveaddr[iface];
         }
      }
   }
}
 8247098:	e037883a 	mov	sp,fp
 824709c:	dfc00117 	ldw	ra,4(sp)
 82470a0:	df000017 	ldw	fp,0(sp)
 82470a4:	dec00204 	addi	sp,sp,8
 82470a8:	f800283a 	ret

082470ac <dhc_main_ipset>:
 * RETURNS: 
 */

int
dhc_main_ipset(int iface, int state)
{
 82470ac:	defffc04 	addi	sp,sp,-16
 82470b0:	dfc00315 	stw	ra,12(sp)
 82470b4:	df000215 	stw	fp,8(sp)
 82470b8:	df000204 	addi	fp,sp,8
 82470bc:	e13ffe15 	stw	r4,-8(fp)
 82470c0:	e17fff15 	stw	r5,-4(fp)
   if ( state == DHCS_BOUND )
 82470c4:	e0bfff17 	ldw	r2,-4(fp)
 82470c8:	10800198 	cmpnei	r2,r2,6
 82470cc:	1000361e 	bne	r2,zero,82471a8 <dhc_main_ipset+0xfc>
   {
      /* print IP address acquired through DHCP Client - for user's benefit */
      printf("Acquired IP address via DHCP client for interface: %s\n",
              nets[iface]->name);
 82470d0:	008209b4 	movhi	r2,2086
 82470d4:	10b83d04 	addi	r2,r2,-7948
 82470d8:	e0fffe17 	ldw	r3,-8(fp)
 82470dc:	18c7883a 	add	r3,r3,r3
 82470e0:	18c7883a 	add	r3,r3,r3
 82470e4:	10c5883a 	add	r2,r2,r3
 82470e8:	10800017 	ldw	r2,0(r2)
 82470ec:	10800104 	addi	r2,r2,4
dhc_main_ipset(int iface, int state)
{
   if ( state == DHCS_BOUND )
   {
      /* print IP address acquired through DHCP Client - for user's benefit */
      printf("Acquired IP address via DHCP client for interface: %s\n",
 82470f0:	100b883a 	mov	r5,r2
 82470f4:	01020974 	movhi	r4,2085
 82470f8:	2106bf04 	addi	r4,r4,6908
 82470fc:	82033fc0 	call	82033fc <printf>
              nets[iface]->name);

      printf("IP address : %s\n", print_ipad(nets[iface]->n_ipaddr));
 8247100:	008209b4 	movhi	r2,2086
 8247104:	10b83d04 	addi	r2,r2,-7948
 8247108:	e0fffe17 	ldw	r3,-8(fp)
 824710c:	18c7883a 	add	r3,r3,r3
 8247110:	18c7883a 	add	r3,r3,r3
 8247114:	10c5883a 	add	r2,r2,r3
 8247118:	10800017 	ldw	r2,0(r2)
 824711c:	10800a17 	ldw	r2,40(r2)
 8247120:	1009883a 	mov	r4,r2
 8247124:	8228a500 	call	8228a50 <print_ipad>
 8247128:	100b883a 	mov	r5,r2
 824712c:	01020974 	movhi	r4,2085
 8247130:	2106cd04 	addi	r4,r4,6964
 8247134:	82033fc0 	call	82033fc <printf>
      printf("Subnet Mask: %s\n", print_ipad(nets[iface]->snmask));
 8247138:	008209b4 	movhi	r2,2086
 824713c:	10b83d04 	addi	r2,r2,-7948
 8247140:	e0fffe17 	ldw	r3,-8(fp)
 8247144:	18c7883a 	add	r3,r3,r3
 8247148:	18c7883a 	add	r3,r3,r3
 824714c:	10c5883a 	add	r2,r2,r3
 8247150:	10800017 	ldw	r2,0(r2)
 8247154:	10800c17 	ldw	r2,48(r2)
 8247158:	1009883a 	mov	r4,r2
 824715c:	8228a500 	call	8228a50 <print_ipad>
 8247160:	100b883a 	mov	r5,r2
 8247164:	01020974 	movhi	r4,2085
 8247168:	2106d204 	addi	r4,r4,6984
 824716c:	82033fc0 	call	82033fc <printf>
      printf("Gateway    : %s\n", print_ipad(nets[iface]->n_defgw));
 8247170:	008209b4 	movhi	r2,2086
 8247174:	10b83d04 	addi	r2,r2,-7948
 8247178:	e0fffe17 	ldw	r3,-8(fp)
 824717c:	18c7883a 	add	r3,r3,r3
 8247180:	18c7883a 	add	r3,r3,r3
 8247184:	10c5883a 	add	r2,r2,r3
 8247188:	10800017 	ldw	r2,0(r2)
 824718c:	10800d17 	ldw	r2,52(r2)
 8247190:	1009883a 	mov	r4,r2
 8247194:	8228a500 	call	8228a50 <print_ipad>
 8247198:	100b883a 	mov	r5,r2
 824719c:	01020974 	movhi	r4,2085
 82471a0:	2106d704 	addi	r4,r4,7004
 82471a4:	82033fc0 	call	82033fc <printf>
   }
   return 0;
 82471a8:	0005883a 	mov	r2,zero
}
 82471ac:	e037883a 	mov	sp,fp
 82471b0:	dfc00117 	ldw	ra,4(sp)
 82471b4:	df000017 	ldw	fp,0(sp)
 82471b8:	dec00204 	addi	sp,sp,8
 82471bc:	f800283a 	ret

082471c0 <init_memdev>:
 * RETURNS: 
 */

int
init_memdev(void)
{
 82471c0:	deffff04 	addi	sp,sp,-4
 82471c4:	df000015 	stw	fp,0(sp)
 82471c8:	d839883a 	mov	fp,sp
   /* add our IO pointer to master list */
   mdio.next = vfsystems;
 82471cc:	d0e0d417 	ldw	r3,-31920(gp)
 82471d0:	00820974 	movhi	r2,2085
 82471d4:	108f5e04 	addi	r2,r2,15736
 82471d8:	10c00015 	stw	r3,0(r2)
   vfsystems = &mdio;
 82471dc:	00820974 	movhi	r2,2085
 82471e0:	108f5e04 	addi	r2,r2,15736
 82471e4:	d0a0d415 	stw	r2,-31920(gp)

   /* add the memory device files to vfs list */
   mdlist[0].next = vfsfiles;
 82471e8:	d0e0d617 	ldw	r3,-31912(gp)
 82471ec:	00820974 	movhi	r2,2085
 82471f0:	108f6704 	addi	r2,r2,15772
 82471f4:	10c00015 	stw	r3,0(r2)
   vfsfiles = &mdlist[3];
 82471f8:	00820974 	movhi	r2,2085
 82471fc:	108f8804 	addi	r2,r2,15904
 8247200:	d0a0d615 	stw	r2,-31912(gp)

   return 0;
 8247204:	0005883a 	mov	r2,zero
}
 8247208:	e037883a 	mov	sp,fp
 824720c:	df000017 	ldw	fp,0(sp)
 8247210:	dec00104 	addi	sp,sp,4
 8247214:	f800283a 	ret

08247218 <md_fopen>:
 * RETURNS: 
 */

VFILE* 
md_fopen(char * name, char * mode)
{
 8247218:	defffd04 	addi	sp,sp,-12
 824721c:	df000215 	stw	fp,8(sp)
 8247220:	df000204 	addi	fp,sp,8
 8247224:	e13ffe15 	stw	r4,-8(fp)
 8247228:	e17fff15 	stw	r5,-4(fp)
   USE_ARG(mode);
   USE_ARG(name);
   return NULL;
 824722c:	0005883a 	mov	r2,zero
}
 8247230:	e037883a 	mov	sp,fp
 8247234:	df000017 	ldw	fp,0(sp)
 8247238:	dec00104 	addi	sp,sp,4
 824723c:	f800283a 	ret

08247240 <md_fclose>:
 * RETURNS: 
 */

void   
md_fclose(VFILE * vfd)
{
 8247240:	defffe04 	addi	sp,sp,-8
 8247244:	df000115 	stw	fp,4(sp)
 8247248:	df000104 	addi	fp,sp,4
 824724c:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);
}
 8247250:	0001883a 	nop
 8247254:	e037883a 	mov	sp,fp
 8247258:	df000017 	ldw	fp,0(sp)
 824725c:	dec00104 	addi	sp,sp,4
 8247260:	f800283a 	ret

08247264 <md_fread>:
 * RETURNS: 
 */

int    
md_fread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 8247264:	defff704 	addi	sp,sp,-36
 8247268:	dfc00815 	stw	ra,32(sp)
 824726c:	df000715 	stw	fp,28(sp)
 8247270:	df000704 	addi	fp,sp,28
 8247274:	e13ffc15 	stw	r4,-16(fp)
 8247278:	e17ffd15 	stw	r5,-12(fp)
 824727c:	e1bffe15 	stw	r6,-8(fp)
 8247280:	e1ffff15 	stw	r7,-4(fp)
   u_long   bcount;     /* number of bytes put in caller's buffer */
   u_long   location;   /* current offset into file */
   unsigned long file_size = MEMDEV_SIZE;
 8247284:	00800834 	movhi	r2,32
 8247288:	e0bffa15 	stw	r2,-24(fp)
   if(vfd && vfd->file)
 824728c:	e0bfff17 	ldw	r2,-4(fp)
 8247290:	10000726 	beq	r2,zero,82472b0 <md_fread+0x4c>
 8247294:	e0bfff17 	ldw	r2,-4(fp)
 8247298:	10800117 	ldw	r2,4(r2)
 824729c:	10000426 	beq	r2,zero,82472b0 <md_fread+0x4c>
   {
      file_size = vfd->file->real_size; 
 82472a0:	e0bfff17 	ldw	r2,-4(fp)
 82472a4:	10800117 	ldw	r2,4(r2)
 82472a8:	10800717 	ldw	r2,28(r2)
 82472ac:	e0bffa15 	stw	r2,-24(fp)
#ifdef SEG16_16   /* 16-bit x86 must include segment. */
   if(vfd->cmploc == (u_char*)0xFFFFFFFF)   /* at EOF */
      return 0;
   location = (u_long)(((char huge *)vfd->cmploc) - ((char huge *)vfd->file->data));
#else
   location = (u_long)(vfd->cmploc - vfd->file->data);
 82472b0:	e0bfff17 	ldw	r2,-4(fp)
 82472b4:	10800217 	ldw	r2,8(r2)
 82472b8:	1007883a 	mov	r3,r2
 82472bc:	e0bfff17 	ldw	r2,-4(fp)
 82472c0:	10800117 	ldw	r2,4(r2)
 82472c4:	10800617 	ldw	r2,24(r2)
 82472c8:	1885c83a 	sub	r2,r3,r2
 82472cc:	e0bffb15 	stw	r2,-20(fp)
#endif   /* SEG16_16 */

   bcount = (items * (u_long)size);     /* number of bytes to transfer */
 82472d0:	e0fffe17 	ldw	r3,-8(fp)
 82472d4:	e0bffd17 	ldw	r2,-12(fp)
 82472d8:	1885383a 	mul	r2,r3,r2
 82472dc:	e0bff915 	stw	r2,-28(fp)

   /* if near end of memory, trim read count accordingly */
   if ((location + bcount) > file_size)
 82472e0:	e0fffb17 	ldw	r3,-20(fp)
 82472e4:	e0bff917 	ldw	r2,-28(fp)
 82472e8:	1885883a 	add	r2,r3,r2
 82472ec:	e0fffa17 	ldw	r3,-24(fp)
 82472f0:	1880042e 	bgeu	r3,r2,8247304 <md_fread+0xa0>
      bcount = ((u_long)file_size - location);
 82472f4:	e0fffa17 	ldw	r3,-24(fp)
 82472f8:	e0bffb17 	ldw	r2,-20(fp)
 82472fc:	1885c83a 	sub	r2,r3,r2
 8247300:	e0bff915 	stw	r2,-28(fp)

   /* trap bogus size items and end-of-x86 memory conditions */
   if((location >= file_size) ||
 8247304:	e0fffb17 	ldw	r3,-20(fp)
 8247308:	e0bffa17 	ldw	r2,-24(fp)
 824730c:	1880052e 	bgeu	r3,r2,8247324 <md_fread+0xc0>
      (bcount  & 0xFFFF0000) ||
 8247310:	e0bff917 	ldw	r2,-28(fp)
 8247314:	10bfffec 	andhi	r2,r2,65535
   /* if near end of memory, trim read count accordingly */
   if ((location + bcount) > file_size)
      bcount = ((u_long)file_size - location);

   /* trap bogus size items and end-of-x86 memory conditions */
   if((location >= file_size) ||
 8247318:	1000021e 	bne	r2,zero,8247324 <md_fread+0xc0>
      (bcount  & 0xFFFF0000) ||
 824731c:	e0bff917 	ldw	r2,-28(fp)
 8247320:	1000021e 	bne	r2,zero,824732c <md_fread+0xc8>
      (bcount == 0))
   {
      return 0;
 8247324:	0005883a 	mov	r2,zero
 8247328:	00002006 	br	82473ac <md_fread+0x148>
   /* Use VF_NODATA if memory devices have a size, but no
      data. This can be used to measure file read speed
      without introducing an undefined data copy. */
   /* VF_NODATA is defined in ../h/vfsfiles.h */
   
   if (!(vfd->file->flags & VF_NODATA))
 824732c:	e0bfff17 	ldw	r2,-4(fp)
 8247330:	10800117 	ldw	r2,4(r2)
 8247334:	1080058b 	ldhu	r2,22(r2)
 8247338:	10bfffcc 	andi	r2,r2,65535
 824733c:	10a0001c 	xori	r2,r2,32768
 8247340:	10a00004 	addi	r2,r2,-32768
 8247344:	10001016 	blt	r2,zero,8247388 <md_fread+0x124>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 8247348:	e0bfff17 	ldw	r2,-4(fp)
 824734c:	10800117 	ldw	r2,4(r2)
 8247350:	10800103 	ldbu	r2,4(r2)
 8247354:	10803fcc 	andi	r2,r2,255
 8247358:	1080201c 	xori	r2,r2,128
 824735c:	10bfe004 	addi	r2,r2,-128
 8247360:	10801b58 	cmpnei	r2,r2,109
 8247364:	1000081e 	bne	r2,zero,8247388 <md_fread+0x124>
         MEMCPY(buf, vfd->cmploc + MEMDEV_BASE, (unsigned)bcount);
 8247368:	e0bfff17 	ldw	r2,-4(fp)
 824736c:	10c00217 	ldw	r3,8(r2)
 8247370:	00800834 	movhi	r2,32
 8247374:	1885883a 	add	r2,r3,r2
 8247378:	e1bff917 	ldw	r6,-28(fp)
 824737c:	100b883a 	mov	r5,r2
 8247380:	e13ffc17 	ldw	r4,-16(fp)
 8247384:	8202f6c0 	call	8202f6c <memcpy>
         vfd->cmploc = (u_char *)cp;
      else     /* read wrapped memory, set pointer to EOF value */
         vfd->cmploc = (u_char*)(0xFFFFFFFF);  /* EOF */
   }
#else
   vfd->cmploc += bcount;  /* adjust location */
 8247388:	e0bfff17 	ldw	r2,-4(fp)
 824738c:	10c00217 	ldw	r3,8(r2)
 8247390:	e0bff917 	ldw	r2,-28(fp)
 8247394:	1887883a 	add	r3,r3,r2
 8247398:	e0bfff17 	ldw	r2,-4(fp)
 824739c:	10c00215 	stw	r3,8(r2)
#endif
   
   return ((int)bcount/size);
 82473a0:	e17ffd17 	ldw	r5,-12(fp)
 82473a4:	e13ff917 	ldw	r4,-28(fp)
 82473a8:	8202c6c0 	call	8202c6c <__udivsi3>
}
 82473ac:	e037883a 	mov	sp,fp
 82473b0:	dfc00117 	ldw	ra,4(sp)
 82473b4:	df000017 	ldw	fp,0(sp)
 82473b8:	dec00204 	addi	sp,sp,8
 82473bc:	f800283a 	ret

082473c0 <md_fwrite>:
 * RETURNS: 
 */

int    
md_fwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 82473c0:	defffb04 	addi	sp,sp,-20
 82473c4:	df000415 	stw	fp,16(sp)
 82473c8:	df000404 	addi	fp,sp,16
 82473cc:	e13ffc15 	stw	r4,-16(fp)
 82473d0:	e17ffd15 	stw	r5,-12(fp)
 82473d4:	e1bffe15 	stw	r6,-8(fp)
 82473d8:	e1ffff15 	stw	r7,-4(fp)
   if (vfd->file->name[0] == 'm')   /* memory device */
 82473dc:	e0bfff17 	ldw	r2,-4(fp)
 82473e0:	10800117 	ldw	r2,4(r2)
 82473e4:	10800103 	ldbu	r2,4(r2)
 82473e8:	10803fcc 	andi	r2,r2,255
 82473ec:	1080201c 	xori	r2,r2,128
 82473f0:	10bfe004 	addi	r2,r2,-128
 82473f4:	10801b58 	cmpnei	r2,r2,109
 82473f8:	1000021e 	bne	r2,zero,8247404 <md_fwrite+0x44>
      return 0;   /* not writable device */
 82473fc:	0005883a 	mov	r2,zero
 8247400:	00000906 	br	8247428 <md_fwrite+0x68>

   vfd->cmploc += (items * size);   /* adjust location */
 8247404:	e0bfff17 	ldw	r2,-4(fp)
 8247408:	10c00217 	ldw	r3,8(r2)
 824740c:	e13ffe17 	ldw	r4,-8(fp)
 8247410:	e0bffd17 	ldw	r2,-12(fp)
 8247414:	2085383a 	mul	r2,r4,r2
 8247418:	1887883a 	add	r3,r3,r2
 824741c:	e0bfff17 	ldw	r2,-4(fp)
 8247420:	10c00215 	stw	r3,8(r2)

   USE_ARG(buf);     /* supress compiler warnings */

   return (items);
 8247424:	e0bffe17 	ldw	r2,-8(fp)
}
 8247428:	e037883a 	mov	sp,fp
 824742c:	df000017 	ldw	fp,0(sp)
 8247430:	dec00104 	addi	sp,sp,4
 8247434:	f800283a 	ret

08247438 <md_fseek>:
 * RETURNS: 
 */

int
md_fseek(VFILE * vfd, long offset, int mode)
{
 8247438:	defffc04 	addi	sp,sp,-16
 824743c:	df000315 	stw	fp,12(sp)
 8247440:	df000304 	addi	fp,sp,12
 8247444:	e13ffd15 	stw	r4,-12(fp)
 8247448:	e17ffe15 	stw	r5,-8(fp)
 824744c:	e1bfff15 	stw	r6,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   USE_ARG(offset);
   USE_ARG(mode);
   return 0;
 8247450:	0005883a 	mov	r2,zero
}
 8247454:	e037883a 	mov	sp,fp
 8247458:	df000017 	ldw	fp,0(sp)
 824745c:	dec00104 	addi	sp,sp,4
 8247460:	f800283a 	ret

08247464 <md_ftell>:
 * RETURNS: 
 */

long   
md_ftell(VFILE * vfd)
{
 8247464:	defffe04 	addi	sp,sp,-8
 8247468:	df000115 	stw	fp,4(sp)
 824746c:	df000104 	addi	fp,sp,4
 8247470:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   return MEMDEV_SIZE;
 8247474:	00800834 	movhi	r2,32
}
 8247478:	e037883a 	mov	sp,fp
 824747c:	df000017 	ldw	fp,0(sp)
 8247480:	dec00104 	addi	sp,sp,4
 8247484:	f800283a 	ret

08247488 <md_fgetc>:
 * RETURNS: 
 */

int    
md_fgetc(VFILE * vfd)
{
 8247488:	defffc04 	addi	sp,sp,-16
 824748c:	df000315 	stw	fp,12(sp)
 8247490:	df000304 	addi	fp,sp,12
 8247494:	e13fff15 	stw	r4,-4(fp)
   unsigned location;   /* current offset infile */
   int   retval   =  0;
 8247498:	e03ffd15 	stw	zero,-12(fp)

   location = vfd->cmploc - vfd->file->data;
 824749c:	e0bfff17 	ldw	r2,-4(fp)
 82474a0:	10800217 	ldw	r2,8(r2)
 82474a4:	1007883a 	mov	r3,r2
 82474a8:	e0bfff17 	ldw	r2,-4(fp)
 82474ac:	10800117 	ldw	r2,4(r2)
 82474b0:	10800617 	ldw	r2,24(r2)
 82474b4:	1885c83a 	sub	r2,r3,r2
 82474b8:	e0bffe15 	stw	r2,-8(fp)
   if (location >= vfd->file->real_size)     /* at end of file? */
 82474bc:	e0bfff17 	ldw	r2,-4(fp)
 82474c0:	10800117 	ldw	r2,4(r2)
 82474c4:	10800717 	ldw	r2,28(r2)
 82474c8:	e0fffe17 	ldw	r3,-8(fp)
 82474cc:	18800236 	bltu	r3,r2,82474d8 <md_fgetc+0x50>
      return EOF;
 82474d0:	00bfffc4 	movi	r2,-1
 82474d4:	00001a06 	br	8247540 <md_fgetc+0xb8>

   if (!(vfd->file->flags & VF_NODATA))
 82474d8:	e0bfff17 	ldw	r2,-4(fp)
 82474dc:	10800117 	ldw	r2,4(r2)
 82474e0:	1080058b 	ldhu	r2,22(r2)
 82474e4:	10bfffcc 	andi	r2,r2,65535
 82474e8:	10a0001c 	xori	r2,r2,32768
 82474ec:	10a00004 	addi	r2,r2,-32768
 82474f0:	10000d16 	blt	r2,zero,8247528 <md_fgetc+0xa0>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 82474f4:	e0bfff17 	ldw	r2,-4(fp)
 82474f8:	10800117 	ldw	r2,4(r2)
 82474fc:	10800103 	ldbu	r2,4(r2)
 8247500:	10803fcc 	andi	r2,r2,255
 8247504:	1080201c 	xori	r2,r2,128
 8247508:	10bfe004 	addi	r2,r2,-128
 824750c:	10801b58 	cmpnei	r2,r2,109
 8247510:	1000051e 	bne	r2,zero,8247528 <md_fgetc+0xa0>
         retval = (int)(*vfd->cmploc) & 0xFF ;
 8247514:	e0bfff17 	ldw	r2,-4(fp)
 8247518:	10800217 	ldw	r2,8(r2)
 824751c:	10800003 	ldbu	r2,0(r2)
 8247520:	10803fcc 	andi	r2,r2,255
 8247524:	e0bffd15 	stw	r2,-12(fp)
   }

   /* else for null device or files without data, 
      use whatever is in retval */

   vfd->cmploc++;    /* adjust location */
 8247528:	e0bfff17 	ldw	r2,-4(fp)
 824752c:	10800217 	ldw	r2,8(r2)
 8247530:	10c00044 	addi	r3,r2,1
 8247534:	e0bfff17 	ldw	r2,-4(fp)
 8247538:	10c00215 	stw	r3,8(r2)
   return retval;
 824753c:	e0bffd17 	ldw	r2,-12(fp)
}
 8247540:	e037883a 	mov	sp,fp
 8247544:	df000017 	ldw	fp,0(sp)
 8247548:	dec00104 	addi	sp,sp,4
 824754c:	f800283a 	ret

08247550 <md_unlink>:
 * RETURNS: 
 */

int    
md_unlink(char * filename)
{
 8247550:	defffe04 	addi	sp,sp,-8
 8247554:	df000115 	stw	fp,4(sp)
 8247558:	df000104 	addi	fp,sp,4
 824755c:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(filename);     /* supress compiler warnings */
   return 0;
 8247560:	0005883a 	mov	r2,zero
}
 8247564:	e037883a 	mov	sp,fp
 8247568:	df000017 	ldw	fp,0(sp)
 824756c:	dec00104 	addi	sp,sp,4
 8247570:	f800283a 	ret

08247574 <parse_ipad>:

char *   
parse_ipad(ip_addr * ipout,   /* pointer to IP address to set */
   unsigned *  sbits,      /* default subnet bit number */
   char *   stringin)      /* buffer with ascii to parse */
{
 8247574:	defff604 	addi	sp,sp,-40
 8247578:	dfc00915 	stw	ra,36(sp)
 824757c:	df000815 	stw	fp,32(sp)
 8247580:	df000804 	addi	fp,sp,32
 8247584:	e13ffd15 	stw	r4,-12(fp)
 8247588:	e17ffe15 	stw	r5,-8(fp)
 824758c:	e1bfff15 	stw	r6,-4(fp)
   char *   cp;
   int   dots  =  0; /* periods imbedded in input string */
 8247590:	e03ff915 	stw	zero,-28(fp)
   union   
   {
      u_char   c[4];
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";
 8247594:	00820974 	movhi	r2,2085
 8247598:	1086dc04 	addi	r2,r2,7024
 824759c:	e0bffa15 	stw	r2,-24(fp)

   cp = stringin;
 82475a0:	e0bfff17 	ldw	r2,-4(fp)
 82475a4:	e0bff815 	stw	r2,-32(fp)
   while (*cp)
 82475a8:	00002506 	br	8247640 <parse_ipad+0xcc>
   {
      if (*cp > '9' || *cp < '.' || *cp == '/')
 82475ac:	e0bff817 	ldw	r2,-32(fp)
 82475b0:	10800003 	ldbu	r2,0(r2)
 82475b4:	10803fcc 	andi	r2,r2,255
 82475b8:	1080201c 	xori	r2,r2,128
 82475bc:	10bfe004 	addi	r2,r2,-128
 82475c0:	10800e88 	cmpgei	r2,r2,58
 82475c4:	10000e1e 	bne	r2,zero,8247600 <parse_ipad+0x8c>
 82475c8:	e0bff817 	ldw	r2,-32(fp)
 82475cc:	10800003 	ldbu	r2,0(r2)
 82475d0:	10803fcc 	andi	r2,r2,255
 82475d4:	1080201c 	xori	r2,r2,128
 82475d8:	10bfe004 	addi	r2,r2,-128
 82475dc:	10800b90 	cmplti	r2,r2,46
 82475e0:	1000071e 	bne	r2,zero,8247600 <parse_ipad+0x8c>
 82475e4:	e0bff817 	ldw	r2,-32(fp)
 82475e8:	10800003 	ldbu	r2,0(r2)
 82475ec:	10803fcc 	andi	r2,r2,255
 82475f0:	1080201c 	xori	r2,r2,128
 82475f4:	10bfe004 	addi	r2,r2,-128
 82475f8:	10800bd8 	cmpnei	r2,r2,47
 82475fc:	1000031e 	bne	r2,zero,824760c <parse_ipad+0x98>
         return("all chars must be digits (0-9) or dots (.)");
 8247600:	00820974 	movhi	r2,2085
 8247604:	1086e504 	addi	r2,r2,7060
 8247608:	00009406 	br	824785c <parse_ipad+0x2e8>
      if (*cp == '.')dots++;
 824760c:	e0bff817 	ldw	r2,-32(fp)
 8247610:	10800003 	ldbu	r2,0(r2)
 8247614:	10803fcc 	andi	r2,r2,255
 8247618:	1080201c 	xori	r2,r2,128
 824761c:	10bfe004 	addi	r2,r2,-128
 8247620:	10800b98 	cmpnei	r2,r2,46
 8247624:	1000031e 	bne	r2,zero,8247634 <parse_ipad+0xc0>
 8247628:	e0bff917 	ldw	r2,-28(fp)
 824762c:	10800044 	addi	r2,r2,1
 8247630:	e0bff915 	stw	r2,-28(fp)
         cp++;
 8247634:	e0bff817 	ldw	r2,-32(fp)
 8247638:	10800044 	addi	r2,r2,1
 824763c:	e0bff815 	stw	r2,-32(fp)
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";

   cp = stringin;
   while (*cp)
 8247640:	e0bff817 	ldw	r2,-32(fp)
 8247644:	10800003 	ldbu	r2,0(r2)
 8247648:	10803fcc 	andi	r2,r2,255
 824764c:	1080201c 	xori	r2,r2,128
 8247650:	10bfe004 	addi	r2,r2,-128
 8247654:	103fd51e 	bne	r2,zero,82475ac <parse_ipad+0x38>
         return("all chars must be digits (0-9) or dots (.)");
      if (*cp == '.')dots++;
         cp++;
   }

   if ( dots < 1 || dots > 3 )
 8247658:	e0bff917 	ldw	r2,-28(fp)
 824765c:	0080030e 	bge	zero,r2,824766c <parse_ipad+0xf8>
 8247660:	e0bff917 	ldw	r2,-28(fp)
 8247664:	10800110 	cmplti	r2,r2,4
 8247668:	1000031e 	bne	r2,zero,8247678 <parse_ipad+0x104>
      return("string must contain 1 - 3 dots (.)");
 824766c:	00820974 	movhi	r2,2085
 8247670:	1086f004 	addi	r2,r2,7104
 8247674:	00007906 	br	824785c <parse_ipad+0x2e8>

   cp = stringin;
 8247678:	e0bfff17 	ldw	r2,-4(fp)
 824767c:	e0bff815 	stw	r2,-32(fp)
   if ((number = atoi(cp)) > 255)   /* set net number */
 8247680:	e13ff817 	ldw	r4,-32(fp)
 8247684:	824b69c0 	call	824b69c <atoi>
 8247688:	e0bffb15 	stw	r2,-20(fp)
 824768c:	e0bffb17 	ldw	r2,-20(fp)
 8247690:	10804010 	cmplti	r2,r2,256
 8247694:	1000021e 	bne	r2,zero,82476a0 <parse_ipad+0x12c>
      return(toobig);
 8247698:	e0bffa17 	ldw	r2,-24(fp)
 824769c:	00006f06 	br	824785c <parse_ipad+0x2e8>

   retval.c[0] = (u_char)number;
 82476a0:	e0bffb17 	ldw	r2,-20(fp)
 82476a4:	e0bffc05 	stb	r2,-16(fp)

   while (*cp != '.')cp++; /* find dot (end of number) */
 82476a8:	00000306 	br	82476b8 <parse_ipad+0x144>
 82476ac:	e0bff817 	ldw	r2,-32(fp)
 82476b0:	10800044 	addi	r2,r2,1
 82476b4:	e0bff815 	stw	r2,-32(fp)
 82476b8:	e0bff817 	ldw	r2,-32(fp)
 82476bc:	10800003 	ldbu	r2,0(r2)
 82476c0:	10803fcc 	andi	r2,r2,255
 82476c4:	1080201c 	xori	r2,r2,128
 82476c8:	10bfe004 	addi	r2,r2,-128
 82476cc:	10800b98 	cmpnei	r2,r2,46
 82476d0:	103ff61e 	bne	r2,zero,82476ac <parse_ipad+0x138>
      cp++;             /* point past dot */
 82476d4:	e0bff817 	ldw	r2,-32(fp)
 82476d8:	10800044 	addi	r2,r2,1
 82476dc:	e0bff815 	stw	r2,-32(fp)

   if (dots == 1 || dots == 2) retval.c[1] = 0;
 82476e0:	e0bff917 	ldw	r2,-28(fp)
 82476e4:	10800060 	cmpeqi	r2,r2,1
 82476e8:	1000031e 	bne	r2,zero,82476f8 <parse_ipad+0x184>
 82476ec:	e0bff917 	ldw	r2,-28(fp)
 82476f0:	10800098 	cmpnei	r2,r2,2
 82476f4:	1000021e 	bne	r2,zero,8247700 <parse_ipad+0x18c>
 82476f8:	e03ffc45 	stb	zero,-15(fp)
 82476fc:	00001806 	br	8247760 <parse_ipad+0x1ec>
      else
   {
      number = atoi(cp);
 8247700:	e13ff817 	ldw	r4,-32(fp)
 8247704:	824b69c0 	call	824b69c <atoi>
 8247708:	e0bffb15 	stw	r2,-20(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 824770c:	00000306 	br	824771c <parse_ipad+0x1a8>
 8247710:	e0bff817 	ldw	r2,-32(fp)
 8247714:	10800044 	addi	r2,r2,1
 8247718:	e0bff815 	stw	r2,-32(fp)
 824771c:	e0bff817 	ldw	r2,-32(fp)
 8247720:	10800003 	ldbu	r2,0(r2)
 8247724:	10803fcc 	andi	r2,r2,255
 8247728:	1080201c 	xori	r2,r2,128
 824772c:	10bfe004 	addi	r2,r2,-128
 8247730:	10800b98 	cmpnei	r2,r2,46
 8247734:	103ff61e 	bne	r2,zero,8247710 <parse_ipad+0x19c>
         cp++;             /* point past dot */
 8247738:	e0bff817 	ldw	r2,-32(fp)
 824773c:	10800044 	addi	r2,r2,1
 8247740:	e0bff815 	stw	r2,-32(fp)
      if (number > 255) return(toobig);
 8247744:	e0bffb17 	ldw	r2,-20(fp)
 8247748:	10804010 	cmplti	r2,r2,256
 824774c:	1000021e 	bne	r2,zero,8247758 <parse_ipad+0x1e4>
 8247750:	e0bffa17 	ldw	r2,-24(fp)
 8247754:	00004106 	br	824785c <parse_ipad+0x2e8>
         retval.c[1] = (u_char)number;
 8247758:	e0bffb17 	ldw	r2,-20(fp)
 824775c:	e0bffc45 	stb	r2,-15(fp)
   }

   if (dots == 1) retval.c[2] = 0;
 8247760:	e0bff917 	ldw	r2,-28(fp)
 8247764:	10800058 	cmpnei	r2,r2,1
 8247768:	1000021e 	bne	r2,zero,8247774 <parse_ipad+0x200>
 824776c:	e03ffc85 	stb	zero,-14(fp)
 8247770:	00001806 	br	82477d4 <parse_ipad+0x260>
      else
   {
      number = atoi(cp);
 8247774:	e13ff817 	ldw	r4,-32(fp)
 8247778:	824b69c0 	call	824b69c <atoi>
 824777c:	e0bffb15 	stw	r2,-20(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 8247780:	00000306 	br	8247790 <parse_ipad+0x21c>
 8247784:	e0bff817 	ldw	r2,-32(fp)
 8247788:	10800044 	addi	r2,r2,1
 824778c:	e0bff815 	stw	r2,-32(fp)
 8247790:	e0bff817 	ldw	r2,-32(fp)
 8247794:	10800003 	ldbu	r2,0(r2)
 8247798:	10803fcc 	andi	r2,r2,255
 824779c:	1080201c 	xori	r2,r2,128
 82477a0:	10bfe004 	addi	r2,r2,-128
 82477a4:	10800b98 	cmpnei	r2,r2,46
 82477a8:	103ff61e 	bne	r2,zero,8247784 <parse_ipad+0x210>
         cp++;             /* point past dot */
 82477ac:	e0bff817 	ldw	r2,-32(fp)
 82477b0:	10800044 	addi	r2,r2,1
 82477b4:	e0bff815 	stw	r2,-32(fp)
      if (number > 255) return(toobig);
 82477b8:	e0bffb17 	ldw	r2,-20(fp)
 82477bc:	10804010 	cmplti	r2,r2,256
 82477c0:	1000021e 	bne	r2,zero,82477cc <parse_ipad+0x258>
 82477c4:	e0bffa17 	ldw	r2,-24(fp)
 82477c8:	00002406 	br	824785c <parse_ipad+0x2e8>
         retval.c[2] = (u_char)number;
 82477cc:	e0bffb17 	ldw	r2,-20(fp)
 82477d0:	e0bffc85 	stb	r2,-14(fp)
   }

   if ((number = atoi(cp)) > 255)
 82477d4:	e13ff817 	ldw	r4,-32(fp)
 82477d8:	824b69c0 	call	824b69c <atoi>
 82477dc:	e0bffb15 	stw	r2,-20(fp)
 82477e0:	e0bffb17 	ldw	r2,-20(fp)
 82477e4:	10804010 	cmplti	r2,r2,256
 82477e8:	1000021e 	bne	r2,zero,82477f4 <parse_ipad+0x280>
      return(toobig);
 82477ec:	e0bffa17 	ldw	r2,-24(fp)
 82477f0:	00001a06 	br	824785c <parse_ipad+0x2e8>
   retval.c[3] = (u_char)number;
 82477f4:	e0bffb17 	ldw	r2,-20(fp)
 82477f8:	e0bffcc5 	stb	r2,-13(fp)

   if (retval.c[0] < 128) *sbits = 8;
 82477fc:	e0bffc03 	ldbu	r2,-16(fp)
 8247800:	10803fcc 	andi	r2,r2,255
 8247804:	1080201c 	xori	r2,r2,128
 8247808:	10bfe004 	addi	r2,r2,-128
 824780c:	10000416 	blt	r2,zero,8247820 <parse_ipad+0x2ac>
 8247810:	e0bffe17 	ldw	r2,-8(fp)
 8247814:	00c00204 	movi	r3,8
 8247818:	10c00015 	stw	r3,0(r2)
 824781c:	00000b06 	br	824784c <parse_ipad+0x2d8>
      else if(retval.c[0] < 192) *sbits = 16;
 8247820:	e0bffc03 	ldbu	r2,-16(fp)
 8247824:	10803fcc 	andi	r2,r2,255
 8247828:	10803028 	cmpgeui	r2,r2,192
 824782c:	1000041e 	bne	r2,zero,8247840 <parse_ipad+0x2cc>
 8247830:	e0bffe17 	ldw	r2,-8(fp)
 8247834:	00c00404 	movi	r3,16
 8247838:	10c00015 	stw	r3,0(r2)
 824783c:	00000306 	br	824784c <parse_ipad+0x2d8>
      else *sbits = 24;
 8247840:	e0bffe17 	ldw	r2,-8(fp)
 8247844:	00c00604 	movi	r3,24
 8247848:	10c00015 	stw	r3,0(r2)

      *ipout = retval.l;      /* everything went OK, return number */
 824784c:	e0fffc17 	ldw	r3,-16(fp)
 8247850:	e0bffd17 	ldw	r2,-12(fp)
 8247854:	10c00015 	stw	r3,0(r2)
   return(NULL);        /* return OK code (no error string) */
 8247858:	0005883a 	mov	r2,zero
}
 824785c:	e037883a 	mov	sp,fp
 8247860:	dfc00117 	ldw	ra,4(sp)
 8247864:	df000017 	ldw	fp,0(sp)
 8247868:	dec00204 	addi	sp,sp,8
 824786c:	f800283a 	ret

08247870 <inet_addr>:
 * RETURNS: u_long ipaddr
 */

u_long 
inet_addr(char FAR * str)
{
 8247870:	defffb04 	addi	sp,sp,-20
 8247874:	dfc00415 	stw	ra,16(sp)
 8247878:	df000315 	stw	fp,12(sp)
 824787c:	df000304 	addi	fp,sp,12
 8247880:	e13fff15 	stw	r4,-4(fp)
    * we need to make the conversion. Usually this function will be 
    * used for debugging, so I think we can bear the STRCPY overhead.
    */
   static char nearBuf[30];

   strcpy((char FAR *)nearBuf,str);
 8247884:	e17fff17 	ldw	r5,-4(fp)
 8247888:	01020974 	movhi	r4,2085
 824788c:	21123104 	addi	r4,r4,18628
 8247890:	824b7140 	call	824b714 <strcpy>
   if ( parse_ipad(&ipaddr,&bits,nearBuf) == NULL )
 8247894:	e0bffe04 	addi	r2,fp,-8
 8247898:	01820974 	movhi	r6,2085
 824789c:	31923104 	addi	r6,r6,18628
 82478a0:	100b883a 	mov	r5,r2
 82478a4:	e13ffd04 	addi	r4,fp,-12
 82478a8:	82475740 	call	8247574 <parse_ipad>
 82478ac:	1000021e 	bne	r2,zero,82478b8 <inet_addr+0x48>
   {
      return ipaddr ;
 82478b0:	e0bffd17 	ldw	r2,-12(fp)
 82478b4:	00000106 	br	82478bc <inet_addr+0x4c>
   }
   else
   {
      return (u_long)NULL ;
 82478b8:	0005883a 	mov	r2,zero
   }
}
 82478bc:	e037883a 	mov	sp,fp
 82478c0:	dfc00117 	ldw	ra,4(sp)
 82478c4:	df000017 	ldw	fp,0(sp)
 82478c8:	dec00204 	addi	sp,sp,8
 82478cc:	f800283a 	ret

082478d0 <hextoa>:
 * RETURNS: character 0-9 or A-F
 */

char
hextoa(int val)
{
 82478d0:	defffe04 	addi	sp,sp,-8
 82478d4:	df000115 	stw	fp,4(sp)
 82478d8:	df000104 	addi	fp,sp,4
 82478dc:	e13fff15 	stw	r4,-4(fp)
   val &= 0x0f;
 82478e0:	e0bfff17 	ldw	r2,-4(fp)
 82478e4:	108003cc 	andi	r2,r2,15
 82478e8:	e0bfff15 	stw	r2,-4(fp)
   if(val < 10)
 82478ec:	e0bfff17 	ldw	r2,-4(fp)
 82478f0:	10800288 	cmpgei	r2,r2,10
 82478f4:	1000031e 	bne	r2,zero,8247904 <hextoa+0x34>
      return (char)(val + '0');
 82478f8:	e0bfff17 	ldw	r2,-4(fp)
 82478fc:	10800c04 	addi	r2,r2,48
 8247900:	00000206 	br	824790c <hextoa+0x3c>
   else
      return (char)(val + 55);   /* converts 10-15 -> "A-F" */
 8247904:	e0bfff17 	ldw	r2,-4(fp)
 8247908:	10800dc4 	addi	r2,r2,55
}
 824790c:	e037883a 	mov	sp,fp
 8247910:	df000017 	ldw	fp,0(sp)
 8247914:	dec00104 	addi	sp,sp,4
 8247918:	f800283a 	ret

0824791c <inet_pton>:

char * pton_error = "";

int
inet_pton(int af, const char * src, void * dst)
{
 824791c:	defff804 	addi	sp,sp,-32
 8247920:	dfc00715 	stw	ra,28(sp)
 8247924:	df000615 	stw	fp,24(sp)
 8247928:	df000604 	addi	fp,sp,24
 824792c:	e13ffd15 	stw	r4,-12(fp)
 8247930:	e17ffe15 	stw	r5,-8(fp)
 8247934:	e1bfff15 	stw	r6,-4(fp)
   int            words;   /* count of words written to dest */
#endif

#if defined(IP_V4) || defined(MINI_IP)
   /* RFC 2133 wants us to support both types of address */
   if(af == AF_INET)    /* wants a v4 address */
 8247938:	e0bffd17 	ldw	r2,-12(fp)
 824793c:	10800098 	cmpnei	r2,r2,2
 8247940:	1000151e 	bne	r2,zero,8247998 <inet_pton+0x7c>
   {
      u_long ip4addr;
      unsigned sbits;
      char * err;
      
      err = parse_ipad(&ip4addr, &sbits, (char *) src);
 8247944:	e0fffc04 	addi	r3,fp,-16
 8247948:	e0bffb04 	addi	r2,fp,-20
 824794c:	e1bffe17 	ldw	r6,-8(fp)
 8247950:	180b883a 	mov	r5,r3
 8247954:	1009883a 	mov	r4,r2
 8247958:	82475740 	call	8247574 <parse_ipad>
 824795c:	e0bffa15 	stw	r2,-24(fp)
      if(err == NULL)
 8247960:	e0bffa17 	ldw	r2,-24(fp)
 8247964:	1000071e 	bne	r2,zero,8247984 <inet_pton+0x68>
      {
         /* copy the parsed address into caller's buffer, and 
          * return success
          */
         MEMCPY(dst, &ip4addr, sizeof (u_long));
 8247968:	e0bffb04 	addi	r2,fp,-20
 824796c:	01800104 	movi	r6,4
 8247970:	100b883a 	mov	r5,r2
 8247974:	e13fff17 	ldw	r4,-4(fp)
 8247978:	8202f6c0 	call	8202f6c <memcpy>
         return 0;
 824797c:	0005883a 	mov	r2,zero
 8247980:	00000606 	br	824799c <inet_pton+0x80>
      }
      else
      {
         /* return failure */
         pton_error = "IPv4 address parse failure";
 8247984:	00820974 	movhi	r2,2085
 8247988:	1086fa04 	addi	r2,r2,7144
 824798c:	d0a05415 	stw	r2,-32432(gp)
         return 1;
 8247990:	00800044 	movi	r2,1
 8247994:	00000106 	br	824799c <inet_pton+0x80>
      pton_error = "too short - missing colon?";
      return 1;
   }
   
#endif /* IP_V6 */   
   return 0;
 8247998:	0005883a 	mov	r2,zero
}
 824799c:	e037883a 	mov	sp,fp
 82479a0:	dfc00117 	ldw	ra,4(sp)
 82479a4:	df000017 	ldw	fp,0(sp)
 82479a8:	dec00204 	addi	sp,sp,8
 82479ac:	f800283a 	ret

082479b0 <inet_ntop>:
 * address output (40 bytes).
 */

const char *
inet_ntop(int af, const void *addr, char *str, size_t size)
{
 82479b0:	defff804 	addi	sp,sp,-32
 82479b4:	dfc00715 	stw	ra,28(sp)
 82479b8:	df000615 	stw	fp,24(sp)
 82479bc:	df000604 	addi	fp,sp,24
 82479c0:	e13ffc15 	stw	r4,-16(fp)
 82479c4:	e17ffd15 	stw	r5,-12(fp)
 82479c8:	e1bffe15 	stw	r6,-8(fp)
 82479cc:	e1ffff15 	stw	r7,-4(fp)
   char *cp;

#if defined(IP_V4) || defined(MINI_IP)
   if (af == AF_INET)
 82479d0:	e0bffc17 	ldw	r2,-16(fp)
 82479d4:	10800098 	cmpnei	r2,r2,2
 82479d8:	1000101e 	bne	r2,zero,8247a1c <inet_ntop+0x6c>
   {
      u_long   ip4addr;

      ip4addr = *(u_long*)addr;
 82479dc:	e0bffd17 	ldw	r2,-12(fp)
 82479e0:	10800017 	ldw	r2,0(r2)
 82479e4:	e0bffa15 	stw	r2,-24(fp)
      cp = print_ipad(ip4addr);
 82479e8:	e13ffa17 	ldw	r4,-24(fp)
 82479ec:	8228a500 	call	8228a50 <print_ipad>
 82479f0:	e0bffb15 	stw	r2,-20(fp)
      if (strlen(cp) < size)
 82479f4:	e13ffb17 	ldw	r4,-20(fp)
 82479f8:	8203fbc0 	call	8203fbc <strlen>
 82479fc:	1007883a 	mov	r3,r2
 8247a00:	e0bfff17 	ldw	r2,-4(fp)
 8247a04:	1880052e 	bgeu	r3,r2,8247a1c <inet_ntop+0x6c>
      {
         strcpy(str, cp);
 8247a08:	e17ffb17 	ldw	r5,-20(fp)
 8247a0c:	e13ffe17 	ldw	r4,-8(fp)
 8247a10:	824b7140 	call	824b714 <strcpy>
         return (str);
 8247a14:	e0bffe17 	ldw	r2,-8(fp)
 8247a18:	00000106 	br	8247a20 <inet_ntop+0x70>
         return (str);
      }
   }
#endif

   return ((const char *)NULL);
 8247a1c:	0005883a 	mov	r2,zero
}
 8247a20:	e037883a 	mov	sp,fp
 8247a24:	dfc00117 	ldw	ra,4(sp)
 8247a28:	df000017 	ldw	fp,0(sp)
 8247a2c:	dec00204 	addi	sp,sp,8
 8247a30:	f800283a 	ret

08247a34 <print46_addr>:
 *
 * RETURNS: Pointer to string with the address in readable format.
 */

char * print46_addr(struct sockaddr *ipaddr)
{
 8247a34:	defffc04 	addi	sp,sp,-16
 8247a38:	dfc00315 	stw	ra,12(sp)
 8247a3c:	df000215 	stw	fp,8(sp)
 8247a40:	df000204 	addi	fp,sp,8
 8247a44:	e13fff15 	stw	r4,-4(fp)
   if (ipaddr->sa_family == AF_INET)
 8247a48:	e0bfff17 	ldw	r2,-4(fp)
 8247a4c:	1080000b 	ldhu	r2,0(r2)
 8247a50:	10bfffcc 	andi	r2,r2,65535
 8247a54:	10800098 	cmpnei	r2,r2,2
 8247a58:	1000071e 	bne	r2,zero,8247a78 <print46_addr+0x44>
   {
      struct sockaddr_in * addr = (struct sockaddr_in *)ipaddr;
 8247a5c:	e0bfff17 	ldw	r2,-4(fp)
 8247a60:	e0bffe15 	stw	r2,-8(fp)
      return print_ipad(addr->sin_addr.s_addr);
 8247a64:	e0bffe17 	ldw	r2,-8(fp)
 8247a68:	10800117 	ldw	r2,4(r2)
 8247a6c:	1009883a 	mov	r4,r2
 8247a70:	8228a500 	call	8228a50 <print_ipad>
 8247a74:	00000106 	br	8247a7c <print46_addr+0x48>
      static char namebuf[46];  /* max len of IPv6 addr */
      return (char *)inet_ntop(AF_INET6,&addr->sin6_addr, namebuf, sizeof(namebuf));
   }
#endif

   return NULL;
 8247a78:	0005883a 	mov	r2,zero
}
 8247a7c:	e037883a 	mov	sp,fp
 8247a80:	dfc00117 	ldw	ra,4(sp)
 8247a84:	df000017 	ldw	fp,0(sp)
 8247a88:	dec00204 	addi	sp,sp,8
 8247a8c:	f800283a 	ret

08247a90 <inet46_addr>:
 *
 */

int 
inet46_addr(char * str, struct sockaddr *address)
{
 8247a90:	defffb04 	addi	sp,sp,-20
 8247a94:	dfc00415 	stw	ra,16(sp)
 8247a98:	df000315 	stw	fp,12(sp)
 8247a9c:	df000304 	addi	fp,sp,12
 8247aa0:	e13ffe15 	stw	r4,-8(fp)
 8247aa4:	e17fff15 	stw	r5,-4(fp)
   /* Read the IPv4/IPv6 address */
   address->sa_family = AF_INET; /* assume IPv4 address by default */
 8247aa8:	e0bfff17 	ldw	r2,-4(fp)
 8247aac:	00c00084 	movi	r3,2
 8247ab0:	10c0000d 	sth	r3,0(r2)

   if ((str[1] == '.') || (str[2] == '.') || (str[3] == '.'))
 8247ab4:	e0bffe17 	ldw	r2,-8(fp)
 8247ab8:	10800044 	addi	r2,r2,1
 8247abc:	10800003 	ldbu	r2,0(r2)
 8247ac0:	10803fcc 	andi	r2,r2,255
 8247ac4:	1080201c 	xori	r2,r2,128
 8247ac8:	10bfe004 	addi	r2,r2,-128
 8247acc:	10800ba0 	cmpeqi	r2,r2,46
 8247ad0:	1000101e 	bne	r2,zero,8247b14 <inet46_addr+0x84>
 8247ad4:	e0bffe17 	ldw	r2,-8(fp)
 8247ad8:	10800084 	addi	r2,r2,2
 8247adc:	10800003 	ldbu	r2,0(r2)
 8247ae0:	10803fcc 	andi	r2,r2,255
 8247ae4:	1080201c 	xori	r2,r2,128
 8247ae8:	10bfe004 	addi	r2,r2,-128
 8247aec:	10800ba0 	cmpeqi	r2,r2,46
 8247af0:	1000081e 	bne	r2,zero,8247b14 <inet46_addr+0x84>
 8247af4:	e0bffe17 	ldw	r2,-8(fp)
 8247af8:	108000c4 	addi	r2,r2,3
 8247afc:	10800003 	ldbu	r2,0(r2)
 8247b00:	10803fcc 	andi	r2,r2,255
 8247b04:	1080201c 	xori	r2,r2,128
 8247b08:	10bfe004 	addi	r2,r2,-128
 8247b0c:	10800b98 	cmpnei	r2,r2,46
 8247b10:	10000a1e 	bne	r2,zero,8247b3c <inet46_addr+0xac>
   {
      struct sockaddr_in *addr = (struct sockaddr_in *)address;
 8247b14:	e0bfff17 	ldw	r2,-4(fp)
 8247b18:	e0bffd15 	stw	r2,-12(fp)
      addr->sin_addr.s_addr = inet_addr(str);
 8247b1c:	e13ffe17 	ldw	r4,-8(fp)
 8247b20:	82478700 	call	8247870 <inet_addr>
 8247b24:	1007883a 	mov	r3,r2
 8247b28:	e0bffd17 	ldw	r2,-12(fp)
 8247b2c:	10c00115 	stw	r3,4(r2)
      addr->sin_family = AF_INET;
 8247b30:	e0bffd17 	ldw	r2,-12(fp)
 8247b34:	00c00084 	movi	r3,2
 8247b38:	10c0000d 	sth	r3,0(r2)
      inet_pton(AF_INET6, str, &addr->sin6_addr);
      addr->sin6_family = AF_INET6;
   }
#endif

   return 0;
 8247b3c:	0005883a 	mov	r2,zero
}
 8247b40:	e037883a 	mov	sp,fp
 8247b44:	dfc00117 	ldw	ra,4(sp)
 8247b48:	df000017 	ldw	fp,0(sp)
 8247b4c:	dec00204 	addi	sp,sp,8
 8247b50:	f800283a 	ret

08247b54 <inet_setport>:
 *
 * RETURNS: -
 */

void inet_setport(struct sockaddr *addr,int port) 
{
 8247b54:	defffc04 	addi	sp,sp,-16
 8247b58:	df000315 	stw	fp,12(sp)
 8247b5c:	df000304 	addi	fp,sp,12
 8247b60:	e13ffe15 	stw	r4,-8(fp)
 8247b64:	e17fff15 	stw	r5,-4(fp)
   if (addr->sa_family == AF_INET)
 8247b68:	e0bffe17 	ldw	r2,-8(fp)
 8247b6c:	1080000b 	ldhu	r2,0(r2)
 8247b70:	10bfffcc 	andi	r2,r2,65535
 8247b74:	10800098 	cmpnei	r2,r2,2
 8247b78:	10000c1e 	bne	r2,zero,8247bac <inet_setport+0x58>
   {
      struct sockaddr_in *si = (struct sockaddr_in *)addr;
 8247b7c:	e0bffe17 	ldw	r2,-8(fp)
 8247b80:	e0bffd15 	stw	r2,-12(fp)
      si->sin_port = htons(port);  
 8247b84:	e0bfff17 	ldw	r2,-4(fp)
 8247b88:	1005d23a 	srai	r2,r2,8
 8247b8c:	10803fcc 	andi	r2,r2,255
 8247b90:	1007883a 	mov	r3,r2
 8247b94:	e0bfff17 	ldw	r2,-4(fp)
 8247b98:	1004923a 	slli	r2,r2,8
 8247b9c:	1884b03a 	or	r2,r3,r2
 8247ba0:	1007883a 	mov	r3,r2
 8247ba4:	e0bffd17 	ldw	r2,-12(fp)
 8247ba8:	10c0008d 	sth	r3,2(r2)
      struct sockaddr_in6 *si = (struct sockaddr_in6 *)addr;
      si->sin6_port = htons(port);
   }
#endif

}
 8247bac:	0001883a 	nop
 8247bb0:	e037883a 	mov	sp,fp
 8247bb4:	df000017 	ldw	fp,0(sp)
 8247bb8:	dec00104 	addi	sp,sp,4
 8247bbc:	f800283a 	ret

08247bc0 <convert_ip>:
 *Returns:
 *
 */

unsigned long convert_ip(const char *p)
{
 8247bc0:	defff904 	addi	sp,sp,-28
 8247bc4:	df000615 	stw	fp,24(sp)
 8247bc8:	df000604 	addi	fp,sp,24
 8247bcc:	e13fff15 	stw	r4,-4(fp)
   const char *cp = p;
 8247bd0:	e0bfff17 	ldw	r2,-4(fp)
 8247bd4:	e0bffa15 	stw	r2,-24(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
 8247bd8:	e0bffe04 	addi	r2,fp,-8
 8247bdc:	e0bffd15 	stw	r2,-12(fp)
   int n = 0;
 8247be0:	e03ffb15 	stw	zero,-20(fp)
   unsigned short v = 0;
 8247be4:	e03ffc0d 	sth	zero,-16(fp)
   dw = 0;
 8247be8:	e03ffe15 	stw	zero,-8(fp)
   while(*cp)
 8247bec:	00003106 	br	8247cb4 <convert_ip+0xf4>
   {
      if( *cp == '.')
 8247bf0:	e0bffa17 	ldw	r2,-24(fp)
 8247bf4:	10800003 	ldbu	r2,0(r2)
 8247bf8:	10803fcc 	andi	r2,r2,255
 8247bfc:	1080201c 	xori	r2,r2,128
 8247c00:	10bfe004 	addi	r2,r2,-128
 8247c04:	10800b98 	cmpnei	r2,r2,46
 8247c08:	10000e1e 	bne	r2,zero,8247c44 <convert_ip+0x84>
      {
         lpb[n] = (unsigned char) v;
 8247c0c:	e0bffb17 	ldw	r2,-20(fp)
 8247c10:	e0fffd17 	ldw	r3,-12(fp)
 8247c14:	1885883a 	add	r2,r3,r2
 8247c18:	e0fffc0b 	ldhu	r3,-16(fp)
 8247c1c:	10c00005 	stb	r3,0(r2)
         v = 0;
 8247c20:	e03ffc0d 	sth	zero,-16(fp)
         n++;
 8247c24:	e0bffb17 	ldw	r2,-20(fp)
 8247c28:	10800044 	addi	r2,r2,1
 8247c2c:	e0bffb15 	stw	r2,-20(fp)
         if(n > 3)
 8247c30:	e0bffb17 	ldw	r2,-20(fp)
 8247c34:	10800110 	cmplti	r2,r2,4
 8247c38:	10001b1e 	bne	r2,zero,8247ca8 <convert_ip+0xe8>
         {
            return dw;
 8247c3c:	e0bffe17 	ldw	r2,-8(fp)
 8247c40:	00002806 	br	8247ce4 <convert_ip+0x124>
         }
      }
      else if(((*cp >= '0') && (*cp <= '9')))
 8247c44:	e0bffa17 	ldw	r2,-24(fp)
 8247c48:	10800003 	ldbu	r2,0(r2)
 8247c4c:	10803fcc 	andi	r2,r2,255
 8247c50:	1080201c 	xori	r2,r2,128
 8247c54:	10bfe004 	addi	r2,r2,-128
 8247c58:	10800c10 	cmplti	r2,r2,48
 8247c5c:	1000121e 	bne	r2,zero,8247ca8 <convert_ip+0xe8>
 8247c60:	e0bffa17 	ldw	r2,-24(fp)
 8247c64:	10800003 	ldbu	r2,0(r2)
 8247c68:	10803fcc 	andi	r2,r2,255
 8247c6c:	1080201c 	xori	r2,r2,128
 8247c70:	10bfe004 	addi	r2,r2,-128
 8247c74:	10800e88 	cmpgei	r2,r2,58
 8247c78:	10000b1e 	bne	r2,zero,8247ca8 <convert_ip+0xe8>
      {
         v = (v * 10) + (*cp - '0');
 8247c7c:	e0bffc0b 	ldhu	r2,-16(fp)
 8247c80:	108002a4 	muli	r2,r2,10
 8247c84:	1007883a 	mov	r3,r2
 8247c88:	e0bffa17 	ldw	r2,-24(fp)
 8247c8c:	10800003 	ldbu	r2,0(r2)
 8247c90:	10803fcc 	andi	r2,r2,255
 8247c94:	1080201c 	xori	r2,r2,128
 8247c98:	10bfe004 	addi	r2,r2,-128
 8247c9c:	1885883a 	add	r2,r3,r2
 8247ca0:	10bff404 	addi	r2,r2,-48
 8247ca4:	e0bffc0d 	sth	r2,-16(fp)
      }
      cp++;
 8247ca8:	e0bffa17 	ldw	r2,-24(fp)
 8247cac:	10800044 	addi	r2,r2,1
 8247cb0:	e0bffa15 	stw	r2,-24(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
   int n = 0;
   unsigned short v = 0;
   dw = 0;
   while(*cp)
 8247cb4:	e0bffa17 	ldw	r2,-24(fp)
 8247cb8:	10800003 	ldbu	r2,0(r2)
 8247cbc:	10803fcc 	andi	r2,r2,255
 8247cc0:	1080201c 	xori	r2,r2,128
 8247cc4:	10bfe004 	addi	r2,r2,-128
 8247cc8:	103fc91e 	bne	r2,zero,8247bf0 <convert_ip+0x30>
      {
         v = (v * 10) + (*cp - '0');
      }
      cp++;
   }
   lpb[n] = (unsigned char) v;
 8247ccc:	e0bffb17 	ldw	r2,-20(fp)
 8247cd0:	e0fffd17 	ldw	r3,-12(fp)
 8247cd4:	1885883a 	add	r2,r3,r2
 8247cd8:	e0fffc0b 	ldhu	r3,-16(fp)
 8247cdc:	10c00005 	stb	r3,0(r2)
   return dw;
 8247ce0:	e0bffe17 	ldw	r2,-8(fp)
}  /* convert_ip() */
 8247ce4:	e037883a 	mov	sp,fp
 8247ce8:	df000017 	ldw	fp,0(sp)
 8247cec:	dec00104 	addi	sp,sp,4
 8247cf0:	f800283a 	ret

08247cf4 <tcp_cksum>:
 * RETURNS: 
 */

unshort
tcp_cksum(struct ip * pip)
{
 8247cf4:	defff704 	addi	sp,sp,-36
 8247cf8:	dfc00815 	stw	ra,32(sp)
 8247cfc:	df000715 	stw	fp,28(sp)
 8247d00:	df000704 	addi	fp,sp,28
 8247d04:	e13fff15 	stw	r4,-4(fp)
   unshort  oldsum;
   unshort  newsum;
   struct tcphdr * tp;

#ifdef MUTE_WARNS    /* stifle compiler warnings */
   tcpdata = (char *)NULL;
 8247d08:	e03ffa15 	stw	zero,-24(fp)
#endif   /* MUTE_WARNS */

   IN_PROFILER(PF_TSUM, PF_ENTRY);

   oddchar = 0;
 8247d0c:	e03ffb05 	stb	zero,-20(fp)

   iphlen = (unshort)ip_hlen(pip);
 8247d10:	e0bfff17 	ldw	r2,-4(fp)
 8247d14:	10800003 	ldbu	r2,0(r2)
 8247d18:	10803fcc 	andi	r2,r2,255
 8247d1c:	108003cc 	andi	r2,r2,15
 8247d20:	1085883a 	add	r2,r2,r2
 8247d24:	1085883a 	add	r2,r2,r2
 8247d28:	e0bffc0d 	sth	r2,-16(fp)
   tcplen = htons(pip->ip_len) - iphlen;
 8247d2c:	e0bfff17 	ldw	r2,-4(fp)
 8247d30:	1080008b 	ldhu	r2,2(r2)
 8247d34:	10bfffcc 	andi	r2,r2,65535
 8247d38:	1004d23a 	srli	r2,r2,8
 8247d3c:	1007883a 	mov	r3,r2
 8247d40:	e0bfff17 	ldw	r2,-4(fp)
 8247d44:	1080008b 	ldhu	r2,2(r2)
 8247d48:	10bfffcc 	andi	r2,r2,65535
 8247d4c:	1004923a 	slli	r2,r2,8
 8247d50:	1884b03a 	or	r2,r3,r2
 8247d54:	1007883a 	mov	r3,r2
 8247d58:	e0bffc0b 	ldhu	r2,-16(fp)
 8247d5c:	1885c83a 	sub	r2,r3,r2
 8247d60:	e0bff90d 	sth	r2,-28(fp)

   tp = (struct tcphdr*)ip_data(pip);     /* get TCP header */
 8247d64:	e0bfff17 	ldw	r2,-4(fp)
 8247d68:	10800003 	ldbu	r2,0(r2)
 8247d6c:	10803fcc 	andi	r2,r2,255
 8247d70:	108003cc 	andi	r2,r2,15
 8247d74:	1085883a 	add	r2,r2,r2
 8247d78:	1085883a 	add	r2,r2,r2
 8247d7c:	1007883a 	mov	r3,r2
 8247d80:	e0bfff17 	ldw	r2,-4(fp)
 8247d84:	10c5883a 	add	r2,r2,r3
 8247d88:	e0bffd15 	stw	r2,-12(fp)
   oldsum = tp->th_sum;       /* Save passed checksum */
 8247d8c:	e0bffd17 	ldw	r2,-12(fp)
 8247d90:	1080040b 	ldhu	r2,16(r2)
 8247d94:	e0bffe0d 	sth	r2,-8(fp)
    * cannot overflow a 16 bit field) and put them in the cksum field. 
    * We include the IP addresses by passing them to the lower level 
    * fast sum routine. This results in their values being factored into 
    * the sum and the cksum field contributes zero.
    */
   tp->th_sum = htons(tcplen + 6);
 8247d98:	e0bff90b 	ldhu	r2,-28(fp)
 8247d9c:	10800184 	addi	r2,r2,6
 8247da0:	1005d23a 	srai	r2,r2,8
 8247da4:	10803fcc 	andi	r2,r2,255
 8247da8:	1007883a 	mov	r3,r2
 8247dac:	e0bff90b 	ldhu	r2,-28(fp)
 8247db0:	10800184 	addi	r2,r2,6
 8247db4:	1004923a 	slli	r2,r2,8
 8247db8:	1884b03a 	or	r2,r3,r2
 8247dbc:	1007883a 	mov	r3,r2
 8247dc0:	e0bffd17 	ldw	r2,-12(fp)
 8247dc4:	10c0040d 	sth	r3,16(r2)

   /* zero pad odd sized packets for checksumming */
   if (tcplen & 1)   
 8247dc8:	e0bff90b 	ldhu	r2,-28(fp)
 8247dcc:	1080004c 	andi	r2,r2,1
 8247dd0:	10000e26 	beq	r2,zero,8247e0c <tcp_cksum+0x118>
   {
      tcpdata = ((char*)pip) + iphlen + tcplen;    /* end of packet */
 8247dd4:	e0fffc0b 	ldhu	r3,-16(fp)
 8247dd8:	e0bff90b 	ldhu	r2,-28(fp)
 8247ddc:	1885883a 	add	r2,r3,r2
 8247de0:	e0ffff17 	ldw	r3,-4(fp)
 8247de4:	1885883a 	add	r2,r3,r2
 8247de8:	e0bffa15 	stw	r2,-24(fp)
      oddchar = *tcpdata;
 8247dec:	e0bffa17 	ldw	r2,-24(fp)
 8247df0:	10800003 	ldbu	r2,0(r2)
 8247df4:	e0bffb05 	stb	r2,-20(fp)
      *tcpdata = '\0';        /* zero out pad byte */
 8247df8:	e0bffa17 	ldw	r2,-24(fp)
 8247dfc:	10000005 	stb	zero,0(r2)
      tcplen++;               /* bump length to pass to cksum() */
 8247e00:	e0bff90b 	ldhu	r2,-28(fp)
 8247e04:	10800044 	addi	r2,r2,1
 8247e08:	e0bff90d 	sth	r2,-28(fp)

   /* Pass a pointer to the beginning of the IP address area into the IP header
    * the the low level sum routine. Add the size of these two IP addresses to
    * the length, and convert the length to 16 bit words.
    */
   newsum = ~cksum(((char*)tp) - 8, (tcplen + 8) >> 1);
 8247e0c:	e0bffd17 	ldw	r2,-12(fp)
 8247e10:	10fffe04 	addi	r3,r2,-8
 8247e14:	e0bff90b 	ldhu	r2,-28(fp)
 8247e18:	10800204 	addi	r2,r2,8
 8247e1c:	1005d07a 	srai	r2,r2,1
 8247e20:	100b883a 	mov	r5,r2
 8247e24:	1809883a 	mov	r4,r3
 8247e28:	82288100 	call	8228810 <cksum>
 8247e2c:	0084303a 	nor	r2,zero,r2
 8247e30:	e0bffb8d 	sth	r2,-18(fp)

   /* If the old checksum is 0xffff, but the actual checksum is 0x0000,
    * declare that to be a match.
    */
   if ((newsum != oldsum) && (oldsum == 0xffff) && (newsum == 0x0000))
 8247e34:	e0fffb8b 	ldhu	r3,-18(fp)
 8247e38:	e0bffe0b 	ldhu	r2,-8(fp)
 8247e3c:	18800726 	beq	r3,r2,8247e5c <tcp_cksum+0x168>
 8247e40:	e0fffe0b 	ldhu	r3,-8(fp)
 8247e44:	00bfffd4 	movui	r2,65535
 8247e48:	1880041e 	bne	r3,r2,8247e5c <tcp_cksum+0x168>
 8247e4c:	e0bffb8b 	ldhu	r2,-18(fp)
 8247e50:	1000021e 	bne	r2,zero,8247e5c <tcp_cksum+0x168>
      newsum = 0xffff;
 8247e54:	00bfffc4 	movi	r2,-1
 8247e58:	e0bffb8d 	sth	r2,-18(fp)

   /* restore what we clobbered */
   tp->th_sum = oldsum;       /* put back passed checksum */
 8247e5c:	e0bffd17 	ldw	r2,-12(fp)
 8247e60:	e0fffe0b 	ldhu	r3,-8(fp)
 8247e64:	10c0040d 	sth	r3,16(r2)
   if (oddchar)
 8247e68:	e0bffb07 	ldb	r2,-20(fp)
 8247e6c:	10000326 	beq	r2,zero,8247e7c <tcp_cksum+0x188>
      *tcpdata = oddchar;     /* restore odd byte if we zeroed it */
 8247e70:	e0bffa17 	ldw	r2,-24(fp)
 8247e74:	e0fffb03 	ldbu	r3,-20(fp)
 8247e78:	10c00005 	stb	r3,0(r2)

   IN_PROFILER(PF_TSUM, PF_EXIT);

   return newsum;
 8247e7c:	e0bffb8b 	ldhu	r2,-18(fp)
}
 8247e80:	e037883a 	mov	sp,fp
 8247e84:	dfc00117 	ldw	ra,4(sp)
 8247e88:	df000017 	ldw	fp,0(sp)
 8247e8c:	dec00204 	addi	sp,sp,8
 8247e90:	f800283a 	ret

08247e94 <in_pcballoc>:
 */

int
in_pcballoc(struct socket * so, 
   struct inpcb * head)
{
 8247e94:	defffb04 	addi	sp,sp,-20
 8247e98:	dfc00415 	stw	ra,16(sp)
 8247e9c:	df000315 	stw	fp,12(sp)
 8247ea0:	df000304 	addi	fp,sp,12
 8247ea4:	e13ffe15 	stw	r4,-8(fp)
 8247ea8:	e17fff15 	stw	r5,-4(fp)
   struct inpcb * inp;

   inp = INP_ALLOC (sizeof (*inp));
 8247eac:	01000b04 	movi	r4,44
 8247eb0:	822e1c80 	call	822e1c8 <npalloc>
 8247eb4:	e0bffd15 	stw	r2,-12(fp)
   if (inp == 0)
 8247eb8:	e0bffd17 	ldw	r2,-12(fp)
 8247ebc:	1000021e 	bne	r2,zero,8247ec8 <in_pcballoc+0x34>
      return ENOMEM;
 8247ec0:	00800304 	movi	r2,12
 8247ec4:	00001006 	br	8247f08 <in_pcballoc+0x74>
   inp->inp_head = head;
 8247ec8:	e0bffd17 	ldw	r2,-12(fp)
 8247ecc:	e0ffff17 	ldw	r3,-4(fp)
 8247ed0:	10c00215 	stw	r3,8(r2)
   inp->inp_socket = so;
 8247ed4:	e0bffd17 	ldw	r2,-12(fp)
 8247ed8:	e0fffe17 	ldw	r3,-8(fp)
 8247edc:	10c00815 	stw	r3,32(r2)

   /* Set Path MTU to a very small default. It should get expanded 
    * later by v4 or v6 specific SYN code. We don't want it zero 
    * in case it doesn't get expanded promptly.
    */
   inp->inp_pmtu = 512;
 8247ee0:	e0bffd17 	ldw	r2,-12(fp)
 8247ee4:	00c08004 	movi	r3,512
 8247ee8:	10c00615 	stw	r3,24(r2)
   insque(inp, head);
 8247eec:	e17fff17 	ldw	r5,-4(fp)
 8247ef0:	e13ffd17 	ldw	r4,-12(fp)
 8247ef4:	822ecec0 	call	822ecec <insque>
   so->so_pcb = inp;
 8247ef8:	e0bffe17 	ldw	r2,-8(fp)
 8247efc:	e0fffd17 	ldw	r3,-12(fp)
 8247f00:	10c00115 	stw	r3,4(r2)
   return 0;
 8247f04:	0005883a 	mov	r2,zero
}
 8247f08:	e037883a 	mov	sp,fp
 8247f0c:	dfc00117 	ldw	ra,4(sp)
 8247f10:	df000017 	ldw	fp,0(sp)
 8247f14:	dec00204 	addi	sp,sp,8
 8247f18:	f800283a 	ret

08247f1c <in_pcbdetach>:
 * RETURNS: 
 */

void
in_pcbdetach(struct inpcb * inp)
{
 8247f1c:	defffc04 	addi	sp,sp,-16
 8247f20:	dfc00315 	stw	ra,12(sp)
 8247f24:	df000215 	stw	fp,8(sp)
 8247f28:	df000204 	addi	fp,sp,8
 8247f2c:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  inp->inp_socket;
 8247f30:	e0bfff17 	ldw	r2,-4(fp)
 8247f34:	10800817 	ldw	r2,32(r2)
 8247f38:	e0bffe15 	stw	r2,-8(fp)

   so->so_pcb = 0;
 8247f3c:	e0bffe17 	ldw	r2,-8(fp)
 8247f40:	10000115 	stw	zero,4(r2)
   sofree(so);
 8247f44:	e13ffe17 	ldw	r4,-8(fp)
 8247f48:	8231d640 	call	8231d64 <sofree>
   remque(inp);
 8247f4c:	e13fff17 	ldw	r4,-4(fp)
 8247f50:	822ec7c0 	call	822ec7c <remque>
   INP_FREE (inp);
 8247f54:	e13fff17 	ldw	r4,-4(fp)
 8247f58:	822e1fc0 	call	822e1fc <npfree>
}
 8247f5c:	0001883a 	nop
 8247f60:	e037883a 	mov	sp,fp
 8247f64:	dfc00117 	ldw	ra,4(sp)
 8247f68:	df000017 	ldw	fp,0(sp)
 8247f6c:	dec00204 	addi	sp,sp,8
 8247f70:	f800283a 	ret

08247f74 <in_pcbbind>:

int
in_pcbbind(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 8247f74:	defff504 	addi	sp,sp,-44
 8247f78:	dfc00a15 	stw	ra,40(sp)
 8247f7c:	df000915 	stw	fp,36(sp)
 8247f80:	df000904 	addi	fp,sp,36
 8247f84:	e13ffe15 	stw	r4,-8(fp)
 8247f88:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so =  inp->inp_socket;
 8247f8c:	e0bffe17 	ldw	r2,-8(fp)
 8247f90:	10800817 	ldw	r2,32(r2)
 8247f94:	e0bffb15 	stw	r2,-20(fp)
   struct inpcb * head  =  inp->inp_head;
 8247f98:	e0bffe17 	ldw	r2,-8(fp)
 8247f9c:	10800217 	ldw	r2,8(r2)
 8247fa0:	e0bffc15 	stw	r2,-16(fp)
   struct sockaddr_in * sin;
   u_short  lport =  0;
 8247fa4:	e03ff90d 	sth	zero,-28(fp)


   if (inp->inp_lport || inp->inp_laddr.s_addr != INADDR_ANY)
 8247fa8:	e0bffe17 	ldw	r2,-8(fp)
 8247fac:	1080078b 	ldhu	r2,30(r2)
 8247fb0:	10bfffcc 	andi	r2,r2,65535
 8247fb4:	1000031e 	bne	r2,zero,8247fc4 <in_pcbbind+0x50>
 8247fb8:	e0bffe17 	ldw	r2,-8(fp)
 8247fbc:	10800417 	ldw	r2,16(r2)
 8247fc0:	10000226 	beq	r2,zero,8247fcc <in_pcbbind+0x58>
      return (EINVAL);
 8247fc4:	00800584 	movi	r2,22
 8247fc8:	00006906 	br	8248170 <in_pcbbind+0x1fc>
   if (nam == 0)
 8247fcc:	e0bfff17 	ldw	r2,-4(fp)
 8247fd0:	10003926 	beq	r2,zero,82480b8 <in_pcbbind+0x144>
      goto noname;
   sin = mtod(nam, struct sockaddr_in *);
 8247fd4:	e0bfff17 	ldw	r2,-4(fp)
 8247fd8:	10800317 	ldw	r2,12(r2)
 8247fdc:	e0bffd15 	stw	r2,-12(fp)
   /*
    * removed test here for "if (nam->m_len != sizeof (*sin))"
    * since it really complicatges supporting dual IPv4/v6, and 
    * the 2.0 stack now checks this in t_bind(). -JB-
    */
   if (sin->sin_addr.s_addr != INADDR_ANY) 
 8247fe0:	e0bffd17 	ldw	r2,-12(fp)
 8247fe4:	10800117 	ldw	r2,4(r2)
 8247fe8:	10000a26 	beq	r2,zero,8248014 <in_pcbbind+0xa0>
   {
      if (ip_mymach(sin->sin_addr.s_addr) != sin->sin_addr.s_addr)
 8247fec:	e0bffd17 	ldw	r2,-12(fp)
 8247ff0:	10800117 	ldw	r2,4(r2)
 8247ff4:	1009883a 	mov	r4,r2
 8247ff8:	82409f80 	call	82409f8 <ip_mymach>
 8247ffc:	1007883a 	mov	r3,r2
 8248000:	e0bffd17 	ldw	r2,-12(fp)
 8248004:	10800117 	ldw	r2,4(r2)
 8248008:	18800226 	beq	r3,r2,8248014 <in_pcbbind+0xa0>
      return (EADDRNOTAVAIL);
 824800c:	00801f44 	movi	r2,125
 8248010:	00005706 	br	8248170 <in_pcbbind+0x1fc>
   }
   lport = sin->sin_port;
 8248014:	e0bffd17 	ldw	r2,-12(fp)
 8248018:	1080008b 	ldhu	r2,2(r2)
 824801c:	e0bff90d 	sth	r2,-28(fp)
   if (lport) 
 8248020:	e0bff90b 	ldhu	r2,-28(fp)
 8248024:	10001f26 	beq	r2,zero,82480a4 <in_pcbbind+0x130>
   {
      int   wild  =  0;
 8248028:	e03ffa15 	stw	zero,-24(fp)

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
 824802c:	e0bffb17 	ldw	r2,-20(fp)
 8248030:	10800417 	ldw	r2,16(r2)
 8248034:	1080010c 	andi	r2,r2,4
 8248038:	10000c1e 	bne	r2,zero,824806c <in_pcbbind+0xf8>
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
 824803c:	e0bffb17 	ldw	r2,-20(fp)
 8248040:	10800217 	ldw	r2,8(r2)
 8248044:	1080010b 	ldhu	r2,4(r2)
 8248048:	10bfffcc 	andi	r2,r2,65535
 824804c:	1080010c 	andi	r2,r2,4
   if (lport) 
   {
      int   wild  =  0;

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
 8248050:	10000426 	beq	r2,zero,8248064 <in_pcbbind+0xf0>
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
          (so->so_options & SO_ACCEPTCONN) == 0))
 8248054:	e0bffb17 	ldw	r2,-20(fp)
 8248058:	10800417 	ldw	r2,16(r2)
 824805c:	1080008c 	andi	r2,r2,2
   {
      int   wild  =  0;

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
 8248060:	1000021e 	bne	r2,zero,824806c <in_pcbbind+0xf8>
          (so->so_options & SO_ACCEPTCONN) == 0))
      {
         wild = INPLOOKUP_WILDCARD;
 8248064:	00800044 	movi	r2,1
 8248068:	e0bffa15 	stw	r2,-24(fp)
      }
      if (in_pcblookup(head,
 824806c:	e0bffd17 	ldw	r2,-12(fp)
 8248070:	11000117 	ldw	r4,4(r2)
 8248074:	e0bff90b 	ldhu	r2,-28(fp)
 8248078:	e0fffa17 	ldw	r3,-24(fp)
 824807c:	d8c00115 	stw	r3,4(sp)
 8248080:	d8800015 	stw	r2,0(sp)
 8248084:	200f883a 	mov	r7,r4
 8248088:	000d883a 	mov	r6,zero
 824808c:	000b883a 	mov	r5,zero
 8248090:	e13ffc17 	ldw	r4,-16(fp)
 8248094:	82484c80 	call	82484c8 <in_pcblookup>
 8248098:	10000226 	beq	r2,zero,82480a4 <in_pcbbind+0x130>
          0L, 0, sin->sin_addr.s_addr, lport, wild))
      {
         return (EADDRINUSE);
 824809c:	00801c04 	movi	r2,112
 82480a0:	00003306 	br	8248170 <in_pcbbind+0x1fc>
      }
   }
   inp->inp_laddr = sin->sin_addr;
 82480a4:	e0bffe17 	ldw	r2,-8(fp)
 82480a8:	e0fffd17 	ldw	r3,-12(fp)
 82480ac:	18c00117 	ldw	r3,4(r3)
 82480b0:	10c00415 	stw	r3,16(r2)
 82480b4:	00000106 	br	82480bc <in_pcbbind+0x148>


   if (inp->inp_lport || inp->inp_laddr.s_addr != INADDR_ANY)
      return (EINVAL);
   if (nam == 0)
      goto noname;
 82480b8:	0001883a 	nop
         return (EADDRINUSE);
      }
   }
   inp->inp_laddr = sin->sin_addr;
noname:
   if (lport == 0)
 82480bc:	e0bff90b 	ldhu	r2,-28(fp)
 82480c0:	1000271e 	bne	r2,zero,8248160 <in_pcbbind+0x1ec>
   {
      do 
      {
         if (head->inp_lport++ < IPPORT_RESERVED ||
 82480c4:	e0bffc17 	ldw	r2,-16(fp)
 82480c8:	1080078b 	ldhu	r2,30(r2)
 82480cc:	10c00044 	addi	r3,r2,1
 82480d0:	1809883a 	mov	r4,r3
 82480d4:	e0fffc17 	ldw	r3,-16(fp)
 82480d8:	1900078d 	sth	r4,30(r3)
 82480dc:	10bfffcc 	andi	r2,r2,65535
 82480e0:	10810030 	cmpltui	r2,r2,1024
 82480e4:	1000051e 	bne	r2,zero,82480fc <in_pcbbind+0x188>
             head->inp_lport > IPPORT_USERRESERVED)
 82480e8:	e0bffc17 	ldw	r2,-16(fp)
 82480ec:	1080078b 	ldhu	r2,30(r2)
noname:
   if (lport == 0)
   {
      do 
      {
         if (head->inp_lport++ < IPPORT_RESERVED ||
 82480f0:	10bfffcc 	andi	r2,r2,65535
 82480f4:	1084e270 	cmpltui	r2,r2,5001
 82480f8:	1000031e 	bne	r2,zero,8248108 <in_pcbbind+0x194>
             head->inp_lport > IPPORT_USERRESERVED)
         {
            head->inp_lport = IPPORT_RESERVED;
 82480fc:	e0bffc17 	ldw	r2,-16(fp)
 8248100:	00c10004 	movi	r3,1024
 8248104:	10c0078d 	sth	r3,30(r2)
         }
         lport = htons(head->inp_lport);
 8248108:	e0bffc17 	ldw	r2,-16(fp)
 824810c:	1080078b 	ldhu	r2,30(r2)
 8248110:	10bfffcc 	andi	r2,r2,65535
 8248114:	1004d23a 	srli	r2,r2,8
 8248118:	1007883a 	mov	r3,r2
 824811c:	e0bffc17 	ldw	r2,-16(fp)
 8248120:	1080078b 	ldhu	r2,30(r2)
 8248124:	10bfffcc 	andi	r2,r2,65535
 8248128:	1004923a 	slli	r2,r2,8
 824812c:	1884b03a 	or	r2,r3,r2
 8248130:	e0bff90d 	sth	r2,-28(fp)
      } while(in_pcblookup(head, 0L, 0, inp->inp_laddr.s_addr, lport, 0));
 8248134:	e0bffe17 	ldw	r2,-8(fp)
 8248138:	10c00417 	ldw	r3,16(r2)
 824813c:	e0bff90b 	ldhu	r2,-28(fp)
 8248140:	d8000115 	stw	zero,4(sp)
 8248144:	d8800015 	stw	r2,0(sp)
 8248148:	180f883a 	mov	r7,r3
 824814c:	000d883a 	mov	r6,zero
 8248150:	000b883a 	mov	r5,zero
 8248154:	e13ffc17 	ldw	r4,-16(fp)
 8248158:	82484c80 	call	82484c8 <in_pcblookup>
 824815c:	103fd91e 	bne	r2,zero,82480c4 <in_pcbbind+0x150>
   }
   inp->inp_lport = lport;
 8248160:	e0bffe17 	ldw	r2,-8(fp)
 8248164:	e0fff90b 	ldhu	r3,-28(fp)
 8248168:	10c0078d 	sth	r3,30(r2)
   return (0);
 824816c:	0005883a 	mov	r2,zero
}
 8248170:	e037883a 	mov	sp,fp
 8248174:	dfc00117 	ldw	ra,4(sp)
 8248178:	df000017 	ldw	fp,0(sp)
 824817c:	dec00204 	addi	sp,sp,8
 8248180:	f800283a 	ret

08248184 <in_pcbconnect>:
 */

int
in_pcbconnect(struct inpcb * inp, 
   struct mbuf *  nam)
{
 8248184:	defff604 	addi	sp,sp,-40
 8248188:	dfc00915 	stw	ra,36(sp)
 824818c:	df000815 	stw	fp,32(sp)
 8248190:	df000804 	addi	fp,sp,32
 8248194:	e13ffe15 	stw	r4,-8(fp)
 8248198:	e17fff15 	stw	r5,-4(fp)
   unsigned long ifaddr;
   struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 824819c:	e0bfff17 	ldw	r2,-4(fp)
 82481a0:	10800317 	ldw	r2,12(r2)
 82481a4:	e0bffb15 	stw	r2,-20(fp)

   if (nam->m_len < sizeof (*sin))
 82481a8:	e0bfff17 	ldw	r2,-4(fp)
 82481ac:	10800217 	ldw	r2,8(r2)
 82481b0:	10800428 	cmpgeui	r2,r2,16
 82481b4:	1000021e 	bne	r2,zero,82481c0 <in_pcbconnect+0x3c>
      return (EINVAL);
 82481b8:	00800584 	movi	r2,22
 82481bc:	00006406 	br	8248350 <in_pcbconnect+0x1cc>
   if (sin->sin_family != AF_INET)
 82481c0:	e0bffb17 	ldw	r2,-20(fp)
 82481c4:	1080000b 	ldhu	r2,0(r2)
 82481c8:	10bfffcc 	andi	r2,r2,65535
 82481cc:	10a0001c 	xori	r2,r2,32768
 82481d0:	10a00004 	addi	r2,r2,-32768
 82481d4:	108000a0 	cmpeqi	r2,r2,2
 82481d8:	1000021e 	bne	r2,zero,82481e4 <in_pcbconnect+0x60>
      return (EAFNOSUPPORT);
 82481dc:	00801a84 	movi	r2,106
 82481e0:	00005b06 	br	8248350 <in_pcbconnect+0x1cc>
   if (sin->sin_port == 0)
 82481e4:	e0bffb17 	ldw	r2,-20(fp)
 82481e8:	1080008b 	ldhu	r2,2(r2)
 82481ec:	10bfffcc 	andi	r2,r2,65535
 82481f0:	1000021e 	bne	r2,zero,82481fc <in_pcbconnect+0x78>
      return (EADDRNOTAVAIL);
 82481f4:	00801f44 	movi	r2,125
 82481f8:	00005506 	br	8248350 <in_pcbconnect+0x1cc>
    * use the primary local address.
    * If the supplied address is INADDR_BROADCAST,
    * and the primary interface supports broadcast,
    * choose the broadcast address for that interface.
    */
   if (sin->sin_addr.s_addr == INADDR_ANY)
 82481fc:	e0bffb17 	ldw	r2,-20(fp)
 8248200:	10800117 	ldw	r2,4(r2)
 8248204:	10000d1e 	bne	r2,zero,824823c <in_pcbconnect+0xb8>
   {
      if (inp && inp->ifp)
 8248208:	e0bffe17 	ldw	r2,-8(fp)
 824820c:	10000926 	beq	r2,zero,8248234 <in_pcbconnect+0xb0>
 8248210:	e0bffe17 	ldw	r2,-8(fp)
 8248214:	10800a17 	ldw	r2,40(r2)
 8248218:	10000626 	beq	r2,zero,8248234 <in_pcbconnect+0xb0>
         sin->sin_addr.s_addr = inp->ifp->n_ipaddr;
 824821c:	e0bffe17 	ldw	r2,-8(fp)
 8248220:	10800a17 	ldw	r2,40(r2)
 8248224:	10c00a17 	ldw	r3,40(r2)
 8248228:	e0bffb17 	ldw	r2,-20(fp)
 824822c:	10c00115 	stw	r3,4(r2)
 8248230:	00000806 	br	8248254 <in_pcbconnect+0xd0>
      else
         return (EADDRNOTAVAIL);
 8248234:	00801f44 	movi	r2,125
 8248238:	00004506 	br	8248350 <in_pcbconnect+0x1cc>
   }
   else if (sin->sin_addr.s_addr == INADDR_BROADCAST)
 824823c:	e0bffb17 	ldw	r2,-20(fp)
 8248240:	10800117 	ldw	r2,4(r2)
 8248244:	10bfffd8 	cmpnei	r2,r2,-1
 8248248:	1000021e 	bne	r2,zero,8248254 <in_pcbconnect+0xd0>
      return (EADDRNOTAVAIL);
 824824c:	00801f44 	movi	r2,125
 8248250:	00003f06 	br	8248350 <in_pcbconnect+0x1cc>


   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 8248254:	e0bffe17 	ldw	r2,-8(fp)
 8248258:	10800417 	ldw	r2,16(r2)
 824825c:	10000f1e 	bne	r2,zero,824829c <in_pcbconnect+0x118>
   {
#ifdef MULTI_HOMED
      ip_addr hop1;     /* dummy for pass to iproute() */
      NET npnet;     /* the netport iface we can send on */
      /* call netport stack's IP routing */
      npnet = iproute(sin->sin_addr.s_addr, &hop1);
 8248260:	e0bffb17 	ldw	r2,-20(fp)
 8248264:	10800117 	ldw	r2,4(r2)
 8248268:	e0fffd04 	addi	r3,fp,-12
 824826c:	180b883a 	mov	r5,r3
 8248270:	1009883a 	mov	r4,r2
 8248274:	8240d440 	call	8240d44 <iproute>
 8248278:	e0bffc15 	stw	r2,-16(fp)
      if (!npnet)
 824827c:	e0bffc17 	ldw	r2,-16(fp)
 8248280:	1000021e 	bne	r2,zero,824828c <in_pcbconnect+0x108>
         return EADDRNOTAVAIL;
 8248284:	00801f44 	movi	r2,125
 8248288:	00003106 	br	8248350 <in_pcbconnect+0x1cc>
      ifaddr = npnet->n_ipaddr;  /* local address for this host */
 824828c:	e0bffc17 	ldw	r2,-16(fp)
 8248290:	10800a17 	ldw	r2,40(r2)
 8248294:	e0bffa15 	stw	r2,-24(fp)
 8248298:	00000306 	br	82482a8 <in_pcbconnect+0x124>
#else    /* not netport MULTI_HOMED, use 0th (only) iface */
      ifaddr = nets[0]->n_ipaddr;
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */
 824829c:	e0bffe17 	ldw	r2,-8(fp)
 82482a0:	10800417 	ldw	r2,16(r2)
 82482a4:	e0bffa15 	stw	r2,-24(fp)

   if (in_pcblookup(inp->inp_head,
 82482a8:	e0bffe17 	ldw	r2,-8(fp)
 82482ac:	10c00217 	ldw	r3,8(r2)
 82482b0:	e0bffb17 	ldw	r2,-20(fp)
 82482b4:	11000117 	ldw	r4,4(r2)
       sin->sin_addr.s_addr,
       sin->sin_port,
 82482b8:	e0bffb17 	ldw	r2,-20(fp)
 82482bc:	1080008b 	ldhu	r2,2(r2)
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */

   if (in_pcblookup(inp->inp_head,
 82482c0:	117fffcc 	andi	r5,r2,65535
       sin->sin_addr.s_addr,
       sin->sin_port,
       ifaddr,
       inp->inp_lport,
 82482c4:	e0bffe17 	ldw	r2,-8(fp)
 82482c8:	1080078b 	ldhu	r2,30(r2)
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */

   if (in_pcblookup(inp->inp_head,
 82482cc:	10bfffcc 	andi	r2,r2,65535
 82482d0:	d8000115 	stw	zero,4(sp)
 82482d4:	d8800015 	stw	r2,0(sp)
 82482d8:	e1fffa17 	ldw	r7,-24(fp)
 82482dc:	280d883a 	mov	r6,r5
 82482e0:	200b883a 	mov	r5,r4
 82482e4:	1809883a 	mov	r4,r3
 82482e8:	82484c80 	call	82484c8 <in_pcblookup>
 82482ec:	10000226 	beq	r2,zero,82482f8 <in_pcbconnect+0x174>
       sin->sin_port,
       ifaddr,
       inp->inp_lport,
       0))
   {
      return (EADDRINUSE);
 82482f0:	00801c04 	movi	r2,112
 82482f4:	00001606 	br	8248350 <in_pcbconnect+0x1cc>
   }
   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 82482f8:	e0bffe17 	ldw	r2,-8(fp)
 82482fc:	10800417 	ldw	r2,16(r2)
 8248300:	10000a1e 	bne	r2,zero,824832c <in_pcbconnect+0x1a8>
   {
      if (inp->inp_lport == 0)
 8248304:	e0bffe17 	ldw	r2,-8(fp)
 8248308:	1080078b 	ldhu	r2,30(r2)
 824830c:	10bfffcc 	andi	r2,r2,65535
 8248310:	1000031e 	bne	r2,zero,8248320 <in_pcbconnect+0x19c>
         (void)in_pcbbind(inp, (struct mbuf *)0);
 8248314:	000b883a 	mov	r5,zero
 8248318:	e13ffe17 	ldw	r4,-8(fp)
 824831c:	8247f740 	call	8247f74 <in_pcbbind>
      inp->inp_laddr.s_addr = ifaddr;
 8248320:	e0bffe17 	ldw	r2,-8(fp)
 8248324:	e0fffa17 	ldw	r3,-24(fp)
 8248328:	10c00415 	stw	r3,16(r2)
   }
   inp->inp_faddr = sin->sin_addr;
 824832c:	e0bffe17 	ldw	r2,-8(fp)
 8248330:	e0fffb17 	ldw	r3,-20(fp)
 8248334:	18c00117 	ldw	r3,4(r3)
 8248338:	10c00315 	stw	r3,12(r2)
   inp->inp_fport = sin->sin_port;
 824833c:	e0bffb17 	ldw	r2,-20(fp)
 8248340:	10c0008b 	ldhu	r3,2(r2)
 8248344:	e0bffe17 	ldw	r2,-8(fp)
 8248348:	10c0070d 	sth	r3,28(r2)
   return 0;
 824834c:	0005883a 	mov	r2,zero
}
 8248350:	e037883a 	mov	sp,fp
 8248354:	dfc00117 	ldw	ra,4(sp)
 8248358:	df000017 	ldw	fp,0(sp)
 824835c:	dec00204 	addi	sp,sp,8
 8248360:	f800283a 	ret

08248364 <in_pcbdisconnect>:
 * RETURNS: 
 */

void
in_pcbdisconnect(struct inpcb * inp)
{
 8248364:	defffd04 	addi	sp,sp,-12
 8248368:	dfc00215 	stw	ra,8(sp)
 824836c:	df000115 	stw	fp,4(sp)
 8248370:	df000104 	addi	fp,sp,4
 8248374:	e13fff15 	stw	r4,-4(fp)

   inp->inp_faddr.s_addr = INADDR_ANY;
 8248378:	e0bfff17 	ldw	r2,-4(fp)
 824837c:	10000315 	stw	zero,12(r2)
   inp->inp_fport = 0;
 8248380:	e0bfff17 	ldw	r2,-4(fp)
 8248384:	1000070d 	sth	zero,28(r2)
   if (inp->inp_socket->so_state & SS_NOFDREF)
 8248388:	e0bfff17 	ldw	r2,-4(fp)
 824838c:	10800817 	ldw	r2,32(r2)
 8248390:	1080088b 	ldhu	r2,34(r2)
 8248394:	10bfffcc 	andi	r2,r2,65535
 8248398:	1080004c 	andi	r2,r2,1
 824839c:	10000226 	beq	r2,zero,82483a8 <in_pcbdisconnect+0x44>
      in_pcbdetach (inp);
 82483a0:	e13fff17 	ldw	r4,-4(fp)
 82483a4:	8247f1c0 	call	8247f1c <in_pcbdetach>
}
 82483a8:	0001883a 	nop
 82483ac:	e037883a 	mov	sp,fp
 82483b0:	dfc00117 	ldw	ra,4(sp)
 82483b4:	df000017 	ldw	fp,0(sp)
 82483b8:	dec00204 	addi	sp,sp,8
 82483bc:	f800283a 	ret

082483c0 <in_setsockaddr>:
 */

void
in_setsockaddr(struct inpcb * inp, 
   struct mbuf *  nam)
{
 82483c0:	defffb04 	addi	sp,sp,-20
 82483c4:	dfc00415 	stw	ra,16(sp)
 82483c8:	df000315 	stw	fp,12(sp)
 82483cc:	df000304 	addi	fp,sp,12
 82483d0:	e13ffe15 	stw	r4,-8(fp)
 82483d4:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 82483d8:	e0bfff17 	ldw	r2,-4(fp)
 82483dc:	00c00404 	movi	r3,16
 82483e0:	10c00215 	stw	r3,8(r2)
   sin = mtod(nam, struct sockaddr_in *);
 82483e4:	e0bfff17 	ldw	r2,-4(fp)
 82483e8:	10800317 	ldw	r2,12(r2)
 82483ec:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 82483f0:	01800404 	movi	r6,16
 82483f4:	000b883a 	mov	r5,zero
 82483f8:	e13ffd17 	ldw	r4,-12(fp)
 82483fc:	82032100 	call	8203210 <memset>
   sin->sin_family = AF_INET;
 8248400:	e0bffd17 	ldw	r2,-12(fp)
 8248404:	00c00084 	movi	r3,2
 8248408:	10c0000d 	sth	r3,0(r2)
   sin->sin_port = inp->inp_lport;
 824840c:	e0bffe17 	ldw	r2,-8(fp)
 8248410:	10c0078b 	ldhu	r3,30(r2)
 8248414:	e0bffd17 	ldw	r2,-12(fp)
 8248418:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_laddr;
 824841c:	e0bffd17 	ldw	r2,-12(fp)
 8248420:	e0fffe17 	ldw	r3,-8(fp)
 8248424:	18c00417 	ldw	r3,16(r3)
 8248428:	10c00115 	stw	r3,4(r2)
}
 824842c:	0001883a 	nop
 8248430:	e037883a 	mov	sp,fp
 8248434:	dfc00117 	ldw	ra,4(sp)
 8248438:	df000017 	ldw	fp,0(sp)
 824843c:	dec00204 	addi	sp,sp,8
 8248440:	f800283a 	ret

08248444 <in_setpeeraddr>:

void
in_setpeeraddr(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 8248444:	defffb04 	addi	sp,sp,-20
 8248448:	dfc00415 	stw	ra,16(sp)
 824844c:	df000315 	stw	fp,12(sp)
 8248450:	df000304 	addi	fp,sp,12
 8248454:	e13ffe15 	stw	r4,-8(fp)
 8248458:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 824845c:	e0bfff17 	ldw	r2,-4(fp)
 8248460:	00c00404 	movi	r3,16
 8248464:	10c00215 	stw	r3,8(r2)
   sin = mtod(nam, struct sockaddr_in *);
 8248468:	e0bfff17 	ldw	r2,-4(fp)
 824846c:	10800317 	ldw	r2,12(r2)
 8248470:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 8248474:	01800404 	movi	r6,16
 8248478:	000b883a 	mov	r5,zero
 824847c:	e13ffd17 	ldw	r4,-12(fp)
 8248480:	82032100 	call	8203210 <memset>
   sin->sin_family = AF_INET;
 8248484:	e0bffd17 	ldw	r2,-12(fp)
 8248488:	00c00084 	movi	r3,2
 824848c:	10c0000d 	sth	r3,0(r2)
   sin->sin_port = inp->inp_fport;
 8248490:	e0bffe17 	ldw	r2,-8(fp)
 8248494:	10c0070b 	ldhu	r3,28(r2)
 8248498:	e0bffd17 	ldw	r2,-12(fp)
 824849c:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_faddr;
 82484a0:	e0bffd17 	ldw	r2,-12(fp)
 82484a4:	e0fffe17 	ldw	r3,-8(fp)
 82484a8:	18c00317 	ldw	r3,12(r3)
 82484ac:	10c00115 	stw	r3,4(r2)
}
 82484b0:	0001883a 	nop
 82484b4:	e037883a 	mov	sp,fp
 82484b8:	dfc00117 	ldw	ra,4(sp)
 82484bc:	df000017 	ldw	fp,0(sp)
 82484c0:	dec00204 	addi	sp,sp,8
 82484c4:	f800283a 	ret

082484c8 <in_pcblookup>:
   u_long   faddr, 
   unshort  xfport,
   u_long   laddr,
   unshort  xlport,
   int   flags)
{
 82484c8:	defff504 	addi	sp,sp,-44
 82484cc:	df000a15 	stw	fp,40(sp)
 82484d0:	df000a04 	addi	fp,sp,40
 82484d4:	e13ffb15 	stw	r4,-20(fp)
 82484d8:	e17ffc15 	stw	r5,-16(fp)
 82484dc:	3007883a 	mov	r3,r6
 82484e0:	e1fffe15 	stw	r7,-8(fp)
 82484e4:	e0800117 	ldw	r2,4(fp)
 82484e8:	e0fffd0d 	sth	r3,-12(fp)
 82484ec:	e0bfff0d 	sth	r2,-4(fp)
   struct inpcb * inp, *   match =  0;
 82484f0:	e03ff715 	stw	zero,-36(fp)
   unshort  fport =  xfport; 
 82484f4:	e0bffd0b 	ldhu	r2,-12(fp)
 82484f8:	e0bffa0d 	sth	r2,-24(fp)
   unshort  lport =  xlport;
 82484fc:	e0bfff0b 	ldhu	r2,-4(fp)
 8248500:	e0bffa8d 	sth	r2,-22(fp)
   int   matchwild   =  3;
 8248504:	008000c4 	movi	r2,3
 8248508:	e0bff815 	stw	r2,-32(fp)
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 824850c:	e0bffb17 	ldw	r2,-20(fp)
 8248510:	10800017 	ldw	r2,0(r2)
 8248514:	e0bff615 	stw	r2,-40(fp)
 8248518:	00004f06 	br	8248658 <in_pcblookup+0x190>
   {
      if (inp->inp_lport != lport)
 824851c:	e0bff617 	ldw	r2,-40(fp)
 8248520:	1080078b 	ldhu	r2,30(r2)
 8248524:	10ffffcc 	andi	r3,r2,65535
 8248528:	e0bffa8b 	ldhu	r2,-22(fp)
 824852c:	1880401e 	bne	r3,r2,8248630 <in_pcblookup+0x168>
         continue;

      /* Skip non IPv4 sockets */
      if(inp->inp_socket->so_domain != AF_INET)
 8248530:	e0bff617 	ldw	r2,-40(fp)
 8248534:	10800817 	ldw	r2,32(r2)
 8248538:	10800517 	ldw	r2,20(r2)
 824853c:	108000a0 	cmpeqi	r2,r2,2
 8248540:	10003d26 	beq	r2,zero,8248638 <in_pcblookup+0x170>
         continue;

      wildcard = 0;
 8248544:	e03ff915 	stw	zero,-28(fp)
      if (inp->inp_laddr.s_addr != INADDR_ANY) 
 8248548:	e0bff617 	ldw	r2,-40(fp)
 824854c:	10800417 	ldw	r2,16(r2)
 8248550:	10000b26 	beq	r2,zero,8248580 <in_pcblookup+0xb8>
      {
         if (laddr == INADDR_ANY)
 8248554:	e0bffe17 	ldw	r2,-8(fp)
 8248558:	1000041e 	bne	r2,zero,824856c <in_pcblookup+0xa4>
            wildcard++;
 824855c:	e0bff917 	ldw	r2,-28(fp)
 8248560:	10800044 	addi	r2,r2,1
 8248564:	e0bff915 	stw	r2,-28(fp)
 8248568:	00000a06 	br	8248594 <in_pcblookup+0xcc>
         else if (inp->inp_laddr.s_addr != laddr)
 824856c:	e0bff617 	ldw	r2,-40(fp)
 8248570:	10c00417 	ldw	r3,16(r2)
 8248574:	e0bffe17 	ldw	r2,-8(fp)
 8248578:	18800626 	beq	r3,r2,8248594 <in_pcblookup+0xcc>
            continue;
 824857c:	00003306 	br	824864c <in_pcblookup+0x184>
      }
      else 
      {
         if (laddr != INADDR_ANY)
 8248580:	e0bffe17 	ldw	r2,-8(fp)
 8248584:	10000326 	beq	r2,zero,8248594 <in_pcblookup+0xcc>
            wildcard++;
 8248588:	e0bff917 	ldw	r2,-28(fp)
 824858c:	10800044 	addi	r2,r2,1
 8248590:	e0bff915 	stw	r2,-28(fp)
      }
      if (inp->inp_faddr.s_addr != INADDR_ANY) 
 8248594:	e0bff617 	ldw	r2,-40(fp)
 8248598:	10800317 	ldw	r2,12(r2)
 824859c:	10001026 	beq	r2,zero,82485e0 <in_pcblookup+0x118>
      {
         if (faddr == INADDR_ANY)
 82485a0:	e0bffc17 	ldw	r2,-16(fp)
 82485a4:	1000041e 	bne	r2,zero,82485b8 <in_pcblookup+0xf0>
            wildcard++;
 82485a8:	e0bff917 	ldw	r2,-28(fp)
 82485ac:	10800044 	addi	r2,r2,1
 82485b0:	e0bff915 	stw	r2,-28(fp)
 82485b4:	00000f06 	br	82485f4 <in_pcblookup+0x12c>
         else if (inp->inp_faddr.s_addr != faddr ||
 82485b8:	e0bff617 	ldw	r2,-40(fp)
 82485bc:	10c00317 	ldw	r3,12(r2)
 82485c0:	e0bffc17 	ldw	r2,-16(fp)
 82485c4:	18801e1e 	bne	r3,r2,8248640 <in_pcblookup+0x178>
             inp->inp_fport != fport)
 82485c8:	e0bff617 	ldw	r2,-40(fp)
 82485cc:	1080070b 	ldhu	r2,28(r2)
      }
      if (inp->inp_faddr.s_addr != INADDR_ANY) 
      {
         if (faddr == INADDR_ANY)
            wildcard++;
         else if (inp->inp_faddr.s_addr != faddr ||
 82485d0:	10ffffcc 	andi	r3,r2,65535
 82485d4:	e0bffa0b 	ldhu	r2,-24(fp)
 82485d8:	18800626 	beq	r3,r2,82485f4 <in_pcblookup+0x12c>
             inp->inp_fport != fport)
         {
            continue;
 82485dc:	00001806 	br	8248640 <in_pcblookup+0x178>
         }
      } else 
      {
         if (faddr != INADDR_ANY)
 82485e0:	e0bffc17 	ldw	r2,-16(fp)
 82485e4:	10000326 	beq	r2,zero,82485f4 <in_pcblookup+0x12c>
            wildcard++;
 82485e8:	e0bff917 	ldw	r2,-28(fp)
 82485ec:	10800044 	addi	r2,r2,1
 82485f0:	e0bff915 	stw	r2,-28(fp)
      }
      if (wildcard && (flags & INPLOOKUP_WILDCARD) == 0)
 82485f4:	e0bff917 	ldw	r2,-28(fp)
 82485f8:	10000326 	beq	r2,zero,8248608 <in_pcblookup+0x140>
 82485fc:	e0800217 	ldw	r2,8(fp)
 8248600:	1080004c 	andi	r2,r2,1
 8248604:	10001026 	beq	r2,zero,8248648 <in_pcblookup+0x180>
         continue;
      if (wildcard < matchwild) 
 8248608:	e0fff917 	ldw	r3,-28(fp)
 824860c:	e0bff817 	ldw	r2,-32(fp)
 8248610:	18800e0e 	bge	r3,r2,824864c <in_pcblookup+0x184>
      {
         match = inp;
 8248614:	e0bff617 	ldw	r2,-40(fp)
 8248618:	e0bff715 	stw	r2,-36(fp)
         matchwild = wildcard;
 824861c:	e0bff917 	ldw	r2,-28(fp)
 8248620:	e0bff815 	stw	r2,-32(fp)
         if (matchwild == 0)
 8248624:	e0bff817 	ldw	r2,-32(fp)
 8248628:	10000f26 	beq	r2,zero,8248668 <in_pcblookup+0x1a0>
 824862c:	00000706 	br	824864c <in_pcblookup+0x184>
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
   {
      if (inp->inp_lport != lport)
         continue;
 8248630:	0001883a 	nop
 8248634:	00000506 	br	824864c <in_pcblookup+0x184>

      /* Skip non IPv4 sockets */
      if(inp->inp_socket->so_domain != AF_INET)
         continue;
 8248638:	0001883a 	nop
 824863c:	00000306 	br	824864c <in_pcblookup+0x184>
         if (faddr == INADDR_ANY)
            wildcard++;
         else if (inp->inp_faddr.s_addr != faddr ||
             inp->inp_fport != fport)
         {
            continue;
 8248640:	0001883a 	nop
 8248644:	00000106 	br	824864c <in_pcblookup+0x184>
      {
         if (faddr != INADDR_ANY)
            wildcard++;
      }
      if (wildcard && (flags & INPLOOKUP_WILDCARD) == 0)
         continue;
 8248648:	0001883a 	nop
   unshort  fport =  xfport; 
   unshort  lport =  xlport;
   int   matchwild   =  3;
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 824864c:	e0bff617 	ldw	r2,-40(fp)
 8248650:	10800017 	ldw	r2,0(r2)
 8248654:	e0bff615 	stw	r2,-40(fp)
 8248658:	e0fff617 	ldw	r3,-40(fp)
 824865c:	e0bffb17 	ldw	r2,-20(fp)
 8248660:	18bfae1e 	bne	r3,r2,824851c <in_pcblookup+0x54>
 8248664:	00000106 	br	824866c <in_pcblookup+0x1a4>
      if (wildcard < matchwild) 
      {
         match = inp;
         matchwild = wildcard;
         if (matchwild == 0)
            break;
 8248668:	0001883a 	nop
      }
   }
   if (match == NULL)
 824866c:	e0bff717 	ldw	r2,-36(fp)
 8248670:	1000021e 	bne	r2,zero,824867c <in_pcblookup+0x1b4>
      return match;
 8248674:	e0bff717 	ldw	r2,-36(fp)
 8248678:	00002406 	br	824870c <in_pcblookup+0x244>

   if (head->inp_next == match)  /* got cache hit? */
 824867c:	e0bffb17 	ldw	r2,-20(fp)
 8248680:	10c00017 	ldw	r3,0(r2)
 8248684:	e0bff717 	ldw	r2,-36(fp)
 8248688:	1880041e 	bne	r3,r2,824869c <in_pcblookup+0x1d4>
   {
      inpcb_cachehits++;
 824868c:	d0a0d217 	ldw	r2,-31928(gp)
 8248690:	10800044 	addi	r2,r2,1
 8248694:	d0a0d215 	stw	r2,-31928(gp)
 8248698:	00001b06 	br	8248708 <in_pcblookup+0x240>
   }
   else
   {
      inpcb_cachemiss++;
 824869c:	d0a0d317 	ldw	r2,-31924(gp)
 82486a0:	10800044 	addi	r2,r2,1
 82486a4:	d0a0d315 	stw	r2,-31924(gp)
      /* "cache" the match to be first checked next time. */
      match->inp_next->inp_prev = match->inp_prev; /*unlink match */
 82486a8:	e0bff717 	ldw	r2,-36(fp)
 82486ac:	10800017 	ldw	r2,0(r2)
 82486b0:	e0fff717 	ldw	r3,-36(fp)
 82486b4:	18c00117 	ldw	r3,4(r3)
 82486b8:	10c00115 	stw	r3,4(r2)
      match->inp_prev->inp_next = match->inp_next;
 82486bc:	e0bff717 	ldw	r2,-36(fp)
 82486c0:	10800117 	ldw	r2,4(r2)
 82486c4:	e0fff717 	ldw	r3,-36(fp)
 82486c8:	18c00017 	ldw	r3,0(r3)
 82486cc:	10c00015 	stw	r3,0(r2)

      /* relink match as head->inp_next */
      match->inp_next = head->inp_next;
 82486d0:	e0bffb17 	ldw	r2,-20(fp)
 82486d4:	10c00017 	ldw	r3,0(r2)
 82486d8:	e0bff717 	ldw	r2,-36(fp)
 82486dc:	10c00015 	stw	r3,0(r2)
      head->inp_next = match;
 82486e0:	e0bffb17 	ldw	r2,-20(fp)
 82486e4:	e0fff717 	ldw	r3,-36(fp)
 82486e8:	10c00015 	stw	r3,0(r2)
      match->inp_prev = head;
 82486ec:	e0bff717 	ldw	r2,-36(fp)
 82486f0:	e0fffb17 	ldw	r3,-20(fp)
 82486f4:	10c00115 	stw	r3,4(r2)
      match->inp_next->inp_prev = match;
 82486f8:	e0bff717 	ldw	r2,-36(fp)
 82486fc:	10800017 	ldw	r2,0(r2)
 8248700:	e0fff717 	ldw	r3,-36(fp)
 8248704:	10c00115 	stw	r3,4(r2)
   }
   return (match);
 8248708:	e0bff717 	ldw	r2,-36(fp)
}
 824870c:	e037883a 	mov	sp,fp
 8248710:	df000017 	ldw	fp,0(sp)
 8248714:	dec00104 	addi	sp,sp,4
 8248718:	f800283a 	ret

0824871c <set_vfopen_error>:
 *
 * RETURNS: 
 */

void set_vfopen_error(int error)
{
 824871c:	defffe04 	addi	sp,sp,-8
 8248720:	df000115 	stw	fp,4(sp)
 8248724:	df000104 	addi	fp,sp,4
 8248728:	e13fff15 	stw	r4,-4(fp)
   vfopen_error = error;
 824872c:	e0bfff17 	ldw	r2,-4(fp)
 8248730:	d0a0d715 	stw	r2,-31908(gp)
}
 8248734:	0001883a 	nop
 8248738:	e037883a 	mov	sp,fp
 824873c:	df000017 	ldw	fp,0(sp)
 8248740:	dec00104 	addi	sp,sp,4
 8248744:	f800283a 	ret

08248748 <get_vfopen_error>:
 *
 * RETURNS: 
 */

int get_vfopen_error()
{
 8248748:	deffff04 	addi	sp,sp,-4
 824874c:	df000015 	stw	fp,0(sp)
 8248750:	d839883a 	mov	fp,sp
   return vfopen_error;
 8248754:	d0a0d717 	ldw	r2,-31908(gp)
}
 8248758:	e037883a 	mov	sp,fp
 824875c:	df000017 	ldw	fp,0(sp)
 8248760:	dec00104 	addi	sp,sp,4
 8248764:	f800283a 	ret

08248768 <vf_alloc_and_link_vop>:
 *
 * RETURNS: 
 */

VFILE * vf_alloc_and_link_vop()
{
 8248768:	defffd04 	addi	sp,sp,-12
 824876c:	dfc00215 	stw	ra,8(sp)
 8248770:	df000115 	stw	fp,4(sp)
 8248774:	df000104 	addi	fp,sp,4
   struct vfs_open * vop;

   /* enforce maximum number of simultaneously open files */
   if (vfs_open_files >= VFS_MAX_OPEN_FILES)
 8248778:	d0a0d917 	ldw	r2,-31900(gp)
 824877c:	10803ff0 	cmpltui	r2,r2,255
 8248780:	1000021e 	bne	r2,zero,824878c <vf_alloc_and_link_vop+0x24>
   {
#ifdef VFS_VERBOSE
      dprintf("vfs_open_files too big (%ld) in vf_alloc_and_link_vop()\n",
       vfs_open_files);
#endif   /* VFS_VERBOSE */
      return NULL;
 8248784:	0005883a 	mov	r2,zero
 8248788:	00000e06 	br	82487c4 <vf_alloc_and_link_vop+0x5c>
   }

   /* allocate a structure to represent the open file */
   vop = VFS_VFS_OPEN_ALLOC();
 824878c:	01000504 	movi	r4,20
 8248790:	822e1c80 	call	822e1c8 <npalloc>
 8248794:	e0bfff15 	stw	r2,-4(fp)

   /* if the allocation succeeded */
   if (vop)
 8248798:	e0bfff17 	ldw	r2,-4(fp)
 824879c:	10000826 	beq	r2,zero,82487c0 <vf_alloc_and_link_vop+0x58>
   {
      /* add to the beginning of the list of open files */
      vop->next = vfiles;
 82487a0:	d0e0d517 	ldw	r3,-31916(gp)
 82487a4:	e0bfff17 	ldw	r2,-4(fp)
 82487a8:	10c00015 	stw	r3,0(r2)
      vfiles = vop;
 82487ac:	e0bfff17 	ldw	r2,-4(fp)
 82487b0:	d0a0d515 	stw	r2,-31916(gp)
      /* increment the count of open files */
      vfs_open_files++;
 82487b4:	d0a0d917 	ldw	r2,-31900(gp)
 82487b8:	10800044 	addi	r2,r2,1
 82487bc:	d0a0d915 	stw	r2,-31900(gp)
#ifdef VFS_VERBOSE
   else
      dprintf("VFS_VFS_OPEN_ALLOC() failed in vf_alloc_and_link_vop()\n");
#endif   /* VFS_VERBOSE */

   return vop;
 82487c0:	e0bfff17 	ldw	r2,-4(fp)
}
 82487c4:	e037883a 	mov	sp,fp
 82487c8:	dfc00117 	ldw	ra,4(sp)
 82487cc:	df000017 	ldw	fp,0(sp)
 82487d0:	dec00204 	addi	sp,sp,8
 82487d4:	f800283a 	ret

082487d8 <vf_alloc_buffer>:
 *
 * RETURNS: 
 */

unsigned char * vf_alloc_buffer(unsigned long size)
{
 82487d8:	defff904 	addi	sp,sp,-28
 82487dc:	dfc00615 	stw	ra,24(sp)
 82487e0:	df000515 	stw	fp,20(sp)
 82487e4:	df000504 	addi	fp,sp,20
 82487e8:	e13fff15 	stw	r4,-4(fp)
   unsigned int long_size,int_size;
#endif   /* MUTE_WARNS */

   /* make sure the requested allocation does not exceed the total
      memory space reserved for file buffers */
   if ((vfs_total_rw_space + size) > VFS_MAX_TOTAL_RW_SPACE)
 82487ec:	d0e0da17 	ldw	r3,-31896(gp)
 82487f0:	e0bfff17 	ldw	r2,-4(fp)
 82487f4:	1885883a 	add	r2,r3,r2
 82487f8:	00ffffd4 	movui	r3,65535
 82487fc:	1880022e 	bgeu	r3,r2,8248808 <vf_alloc_buffer+0x30>
      return NULL;
 8248800:	0005883a 	mov	r2,zero
 8248804:	00002106 	br	824888c <vf_alloc_buffer+0xb4>
    * any bigger than what will fit in an unsigned int 
    */
#ifdef MUTE_WARNS
   /* the idiotic hoops you got to jump through to suppress compiler
      warnings */
   long_size   =  sizeof(unsigned   long);
 8248808:	00800104 	movi	r2,4
 824880c:	e0bffb15 	stw	r2,-20(fp)
   int_size = sizeof(unsigned int);
 8248810:	00800104 	movi	r2,4
 8248814:	e0bffc15 	stw	r2,-16(fp)
   if (long_size > int_size)
 8248818:	e0bffb17 	ldw	r2,-20(fp)
 824881c:	e0fffc17 	ldw	r3,-16(fp)
 8248820:	1880102e 	bgeu	r3,r2,8248864 <vf_alloc_buffer+0x8c>
       * most systems where this "if" expression will evaluate to 
       * true (2 byte ints, 4 byte longs). if any of those upper bits 
       * are on in your requested size, you otta luck.
       */
#ifdef MUTE_WARNS
      switch (int_size)
 8248824:	e0bffc17 	ldw	r2,-16(fp)
 8248828:	108000a0 	cmpeqi	r2,r2,2
 824882c:	10000826 	beq	r2,zero,8248850 <vf_alloc_buffer+0x78>
#else
      switch (sizeof(unsigned int))
#endif   /* MUTE_WARNS */
      {
      case 2 :
         mem_mask = 0xffff0000;
 8248830:	00bffff4 	movhi	r2,65535
 8248834:	e0bffd15 	stw	r2,-12(fp)
         break;
 8248838:	0001883a 	nop
         default :
            dtrap();    /* you have a weird compiler */
         return NULL;
      }

      if (size & mem_mask)
 824883c:	e0ffff17 	ldw	r3,-4(fp)
 8248840:	e0bffd17 	ldw	r2,-12(fp)
 8248844:	1884703a 	and	r2,r3,r2
 8248848:	10000626 	beq	r2,zero,8248864 <vf_alloc_buffer+0x8c>
 824884c:	00000306 	br	824885c <vf_alloc_buffer+0x84>
      {
      case 2 :
         mem_mask = 0xffff0000;
         break;
         default :
            dtrap();    /* you have a weird compiler */
 8248850:	822d5f00 	call	822d5f0 <dtrap>
         return NULL;
 8248854:	0005883a 	mov	r2,zero
 8248858:	00000c06 	br	824888c <vf_alloc_buffer+0xb4>
      }

      if (size & mem_mask)
         return NULL;
 824885c:	0005883a 	mov	r2,zero
 8248860:	00000a06 	br	824888c <vf_alloc_buffer+0xb4>
   }

   /* try to allocate a buffer of the requested size */
   buffer = (unsigned char *) npalloc((unsigned int) size);
 8248864:	e13fff17 	ldw	r4,-4(fp)
 8248868:	822e1c80 	call	822e1c8 <npalloc>
 824886c:	e0bffe15 	stw	r2,-8(fp)

   /* if the allocation succeeded */
   if (buffer)
 8248870:	e0bffe17 	ldw	r2,-8(fp)
 8248874:	10000426 	beq	r2,zero,8248888 <vf_alloc_buffer+0xb0>
   {
      /* add size to the count of total buffer space allocated */
      vfs_total_rw_space += size;
 8248878:	d0e0da17 	ldw	r3,-31896(gp)
 824887c:	e0bfff17 	ldw	r2,-4(fp)
 8248880:	1885883a 	add	r2,r3,r2
 8248884:	d0a0da15 	stw	r2,-31896(gp)
   }

   return buffer;
 8248888:	e0bffe17 	ldw	r2,-8(fp)
}
 824888c:	e037883a 	mov	sp,fp
 8248890:	dfc00117 	ldw	ra,4(sp)
 8248894:	df000017 	ldw	fp,0(sp)
 8248898:	dec00204 	addi	sp,sp,8
 824889c:	f800283a 	ret

082488a0 <vf_free_buffer>:
 *
 * RETURNS: 
 */

void vf_free_buffer(unsigned char * buffer, unsigned long size)
{
 82488a0:	defffc04 	addi	sp,sp,-16
 82488a4:	dfc00315 	stw	ra,12(sp)
 82488a8:	df000215 	stw	fp,8(sp)
 82488ac:	df000204 	addi	fp,sp,8
 82488b0:	e13ffe15 	stw	r4,-8(fp)
 82488b4:	e17fff15 	stw	r5,-4(fp)
   /* free the buffer */
   if (buffer)
 82488b8:	e0bffe17 	ldw	r2,-8(fp)
 82488bc:	10000226 	beq	r2,zero,82488c8 <vf_free_buffer+0x28>
      npfree(buffer);
 82488c0:	e13ffe17 	ldw	r4,-8(fp)
 82488c4:	822e1fc0 	call	822e1fc <npfree>

   /* and subtract its size from the total buffer space count */
   vfs_total_rw_space -= size;
 82488c8:	d0e0da17 	ldw	r3,-31896(gp)
 82488cc:	e0bfff17 	ldw	r2,-4(fp)
 82488d0:	1885c83a 	sub	r2,r3,r2
 82488d4:	d0a0da15 	stw	r2,-31896(gp)
}
 82488d8:	0001883a 	nop
 82488dc:	e037883a 	mov	sp,fp
 82488e0:	dfc00117 	ldw	ra,4(sp)
 82488e4:	df000017 	ldw	fp,0(sp)
 82488e8:	dec00204 	addi	sp,sp,8
 82488ec:	f800283a 	ret

082488f0 <vfopen_locked>:
 * RETURNS: 
 */

VFILE *
vfopen_locked(char * name, char * mode)
{
 82488f0:	defff904 	addi	sp,sp,-28
 82488f4:	dfc00615 	stw	ra,24(sp)
 82488f8:	df000515 	stw	fp,20(sp)
 82488fc:	df000504 	addi	fp,sp,20
 8248900:	e13ffe15 	stw	r4,-8(fp)
 8248904:	e17fff15 	stw	r5,-4(fp)
   struct vfs_file * vfp;
   struct vfs_open * vop;

   /* clear any previous vfopen() error */
   set_vfopen_error(0);
 8248908:	0009883a 	mov	r4,zero
 824890c:	824871c0 	call	824871c <set_vfopen_error>

   /* the old code used to do special handling of '?' in files for 
    * the benefit of the web server. the web server should be doing 
    * this now. this is here to make sure that its doing it 
    */
   if (strchr(name,'?'))
 8248910:	01400fc4 	movi	r5,63
 8248914:	e13ffe17 	ldw	r4,-8(fp)
 8248918:	82037e00 	call	82037e0 <strchr>
 824891c:	10000326 	beq	r2,zero,824892c <vfopen_locked+0x3c>
   {
      dtrap();
 8248920:	822d5f00 	call	822d5f0 <dtrap>
      return NULL;
 8248924:	0005883a 	mov	r2,zero
 8248928:	0000ba06 	br	8248c14 <vfopen_locked+0x324>
   }

   /* determine if the file exists */
   /* if the directory exists, vfp will point to its directory entry
      structure else vfp will be NULL */
   vfp = vfslookup_locked(name);
 824892c:	e13ffe17 	ldw	r4,-8(fp)
 8248930:	8249b740 	call	8249b74 <vfslookup_locked>
 8248934:	e0bffc15 	stw	r2,-16(fp)

   /* if the file exists */
   if (vfp)
 8248938:	e0bffc17 	ldw	r2,-16(fp)
 824893c:	10004a26 	beq	r2,zero,8248a68 <vfopen_locked+0x178>

#ifdef HT_RWVFS

      /* if mode begins with 'w' we will truncate to end of file */
      /* make sure the file is writable before proceeding */
      if ((*mode == 'w') && !(vfp->flags & VF_WRITE))
 8248940:	e0bfff17 	ldw	r2,-4(fp)
 8248944:	10800003 	ldbu	r2,0(r2)
 8248948:	10803fcc 	andi	r2,r2,255
 824894c:	1080201c 	xori	r2,r2,128
 8248950:	10bfe004 	addi	r2,r2,-128
 8248954:	10801dd8 	cmpnei	r2,r2,119
 8248958:	1000091e 	bne	r2,zero,8248980 <vfopen_locked+0x90>
 824895c:	e0bffc17 	ldw	r2,-16(fp)
 8248960:	1080058b 	ldhu	r2,22(r2)
 8248964:	10bfffcc 	andi	r2,r2,65535
 8248968:	1080080c 	andi	r2,r2,32
 824896c:	1000041e 	bne	r2,zero,8248980 <vfopen_locked+0x90>
      {
         set_vfopen_error(ENP_FILEIO);
 8248970:	013ff984 	movi	r4,-26
 8248974:	824871c0 	call	824871c <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("mode w with no VF_WRITE\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 8248978:	0005883a 	mov	r2,zero
 824897c:	0000a506 	br	8248c14 <vfopen_locked+0x324>
      }

#endif   /* HT_RWVFS */

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 8248980:	82487680 	call	8248768 <vf_alloc_and_link_vop>
 8248984:	e0bffd15 	stw	r2,-12(fp)

      /* check for failure */
      if (!vop)
 8248988:	e0bffd17 	ldw	r2,-12(fp)
 824898c:	1000041e 	bne	r2,zero,82489a0 <vfopen_locked+0xb0>
      {
         set_vfopen_error(ENP_NOMEM);
 8248990:	013ffb04 	movi	r4,-20
 8248994:	824871c0 	call	824871c <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 1\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 8248998:	0005883a 	mov	r2,zero
 824899c:	00009d06 	br	8248c14 <vfopen_locked+0x324>
      }

      /* link to the file's directory entry structure */
      vop->file = vfp;
 82489a0:	e0bffd17 	ldw	r2,-12(fp)
 82489a4:	e0fffc17 	ldw	r3,-16(fp)
 82489a8:	10c00115 	stw	r3,4(r2)

      /* by default start at the beginning of the file */
      /* note that vfp->data could be NULL at this point since empty
         files might have no data buffer allocated to them */
      vop->cmploc = vfp->data;   /* start at beginning of file */
 82489ac:	e0bffc17 	ldw	r2,-16(fp)
 82489b0:	10c00617 	ldw	r3,24(r2)
 82489b4:	e0bffd17 	ldw	r2,-12(fp)
 82489b8:	10c00215 	stw	r3,8(r2)

#ifdef HT_RWVFS

      /* if mode begins with 'a', seek to end of file */
      if (*mode == 'a')
 82489bc:	e0bfff17 	ldw	r2,-4(fp)
 82489c0:	10800003 	ldbu	r2,0(r2)
 82489c4:	10803fcc 	andi	r2,r2,255
 82489c8:	1080201c 	xori	r2,r2,128
 82489cc:	10bfe004 	addi	r2,r2,-128
 82489d0:	10801858 	cmpnei	r2,r2,97
 82489d4:	10000a1e 	bne	r2,zero,8248a00 <vfopen_locked+0x110>
      {
         if (vfp->data)
 82489d8:	e0bffc17 	ldw	r2,-16(fp)
 82489dc:	10800617 	ldw	r2,24(r2)
 82489e0:	10000726 	beq	r2,zero,8248a00 <vfopen_locked+0x110>
         {
            vop->cmploc = vfp->data + vfp->comp_size;
 82489e4:	e0bffc17 	ldw	r2,-16(fp)
 82489e8:	10c00617 	ldw	r3,24(r2)
 82489ec:	e0bffc17 	ldw	r2,-16(fp)
 82489f0:	10800817 	ldw	r2,32(r2)
 82489f4:	1887883a 	add	r3,r3,r2
 82489f8:	e0bffd17 	ldw	r2,-12(fp)
 82489fc:	10c00215 	stw	r3,8(r2)
         }
      }

      /* if mode begins with 'w', truncate to end of file */
      if (*mode == 'w')
 8248a00:	e0bfff17 	ldw	r2,-4(fp)
 8248a04:	10800003 	ldbu	r2,0(r2)
 8248a08:	10803fcc 	andi	r2,r2,255
 8248a0c:	1080201c 	xori	r2,r2,128
 8248a10:	10bfe004 	addi	r2,r2,-128
 8248a14:	10801dd8 	cmpnei	r2,r2,119
 8248a18:	1000111e 	bne	r2,zero,8248a60 <vfopen_locked+0x170>
      {
         /* set the size of the file before compression to 0 */
         vfp->real_size = 0;
 8248a1c:	e0bffc17 	ldw	r2,-16(fp)
 8248a20:	10000715 	stw	zero,28(r2)
         /* set the size of the compressed data to 0 */
         vfp->comp_size = 0;
 8248a24:	e0bffc17 	ldw	r2,-16(fp)
 8248a28:	10000815 	stw	zero,32(r2)
         /* note we leave the pointer to the file buffer and its length
            alone since first writes will go to it */
         /* flag that the file has been modified */
         vfp->flags |= VF_STALE;
 8248a2c:	e0bffc17 	ldw	r2,-16(fp)
 8248a30:	1080058b 	ldhu	r2,22(r2)
 8248a34:	10808014 	ori	r2,r2,512
 8248a38:	1007883a 	mov	r3,r2
 8248a3c:	e0bffc17 	ldw	r2,-16(fp)
 8248a40:	10c0058d 	sth	r3,22(r2)

         /* turn off the compression flag */
         vfp->flags &= ~VF_HTMLCOMPRESSED;
 8248a44:	e0bffc17 	ldw	r2,-16(fp)
 8248a48:	10c0058b 	ldhu	r3,22(r2)
 8248a4c:	00bfff84 	movi	r2,-2
 8248a50:	1884703a 	and	r2,r3,r2
 8248a54:	1007883a 	mov	r3,r2
 8248a58:	e0bffc17 	ldw	r2,-16(fp)
 8248a5c:	10c0058d 	sth	r3,22(r2)
      }

#endif   /* HT_RWVFS */

      return vop;
 8248a60:	e0bffd17 	ldw	r2,-12(fp)
 8248a64:	00006b06 	br	8248c14 <vfopen_locked+0x324>

#ifdef HT_EXTDEV

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 8248a68:	e0bfff17 	ldw	r2,-4(fp)
 8248a6c:	10800003 	ldbu	r2,0(r2)
 8248a70:	10803fcc 	andi	r2,r2,255
 8248a74:	1080201c 	xori	r2,r2,128
 8248a78:	10bfe004 	addi	r2,r2,-128
 8248a7c:	10801ca0 	cmpeqi	r2,r2,114
 8248a80:	1000121e 	bne	r2,zero,8248acc <vfopen_locked+0x1dc>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 8248a84:	d0a0d417 	ldw	r2,-31920(gp)
 8248a88:	e0bffb15 	stw	r2,-20(fp)
 8248a8c:	00000d06 	br	8248ac4 <vfopen_locked+0x1d4>
      {
         if ((vop = vfs->r_fopen(name, mode)) != NULL)
 8248a90:	e0bffb17 	ldw	r2,-20(fp)
 8248a94:	10800117 	ldw	r2,4(r2)
 8248a98:	e17fff17 	ldw	r5,-4(fp)
 8248a9c:	e13ffe17 	ldw	r4,-8(fp)
 8248aa0:	103ee83a 	callr	r2
 8248aa4:	e0bffd15 	stw	r2,-12(fp)
 8248aa8:	e0bffd17 	ldw	r2,-12(fp)
 8248aac:	10000226 	beq	r2,zero,8248ab8 <vfopen_locked+0x1c8>
         {
            return vop;
 8248ab0:	e0bffd17 	ldw	r2,-12(fp)
 8248ab4:	00005706 	br	8248c14 <vfopen_locked+0x324>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 8248ab8:	e0bffb17 	ldw	r2,-20(fp)
 8248abc:	10800017 	ldw	r2,0(r2)
 8248ac0:	e0bffb15 	stw	r2,-20(fp)
 8248ac4:	e0bffb17 	ldw	r2,-20(fp)
 8248ac8:	103ff11e 	bne	r2,zero,8248a90 <vfopen_locked+0x1a0>

#ifdef HT_RWVFS

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 8248acc:	e0bfff17 	ldw	r2,-4(fp)
 8248ad0:	10800003 	ldbu	r2,0(r2)
 8248ad4:	10803fcc 	andi	r2,r2,255
 8248ad8:	1080201c 	xori	r2,r2,128
 8248adc:	10bfe004 	addi	r2,r2,-128
 8248ae0:	10801ca0 	cmpeqi	r2,r2,114
 8248ae4:	1000481e 	bne	r2,zero,8248c08 <vfopen_locked+0x318>
   {
      /* enforce maximum number of files */
      if (vfs_total_dyna_files >= VFS_MAX_DYNA_FILES)
 8248ae8:	d0a0db17 	ldw	r2,-31892(gp)
 8248aec:	10803ff0 	cmpltui	r2,r2,255
 8248af0:	1000041e 	bne	r2,zero,8248b04 <vfopen_locked+0x214>
      {
         set_vfopen_error(ENP_NOMEM);
 8248af4:	013ffb04 	movi	r4,-20
 8248af8:	824871c0 	call	824871c <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_total_dyna_files too big in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 8248afc:	0005883a 	mov	r2,zero
 8248b00:	00004406 	br	8248c14 <vfopen_locked+0x324>
      }

      /* make sure the file name is not too long for the VFS */
      if (strlen(name) > FILENAMEMAX)
 8248b04:	e13ffe17 	ldw	r4,-8(fp)
 8248b08:	8203fbc0 	call	8203fbc <strlen>
 8248b0c:	10800470 	cmpltui	r2,r2,17
 8248b10:	1000041e 	bne	r2,zero,8248b24 <vfopen_locked+0x234>
      {
         set_vfopen_error(ENP_PARAM);
 8248b14:	013ffd84 	movi	r4,-10
 8248b18:	824871c0 	call	824871c <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("file name too long in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 8248b1c:	0005883a 	mov	r2,zero
 8248b20:	00003c06 	br	8248c14 <vfopen_locked+0x324>
      }

      /* allocate a vfs_file structure to hold the new file entry in */
      vfp = VFS_VFS_FILE_ALLOC();
 8248b24:	01000b04 	movi	r4,44
 8248b28:	822e1c80 	call	822e1c8 <npalloc>
 8248b2c:	e0bffc15 	stw	r2,-16(fp)

      /* check for memory allocation failure */
      if (!vfp)
 8248b30:	e0bffc17 	ldw	r2,-16(fp)
 8248b34:	1000041e 	bne	r2,zero,8248b48 <vfopen_locked+0x258>
      {
         set_vfopen_error(ENP_NOMEM);
 8248b38:	013ffb04 	movi	r4,-20
 8248b3c:	824871c0 	call	824871c <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("VFS_VFS_FILE_ALLOC() failed in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 8248b40:	0005883a 	mov	r2,zero
 8248b44:	00003306 	br	8248c14 <vfopen_locked+0x324>
      }

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 8248b48:	82487680 	call	8248768 <vf_alloc_and_link_vop>
 8248b4c:	e0bffd15 	stw	r2,-12(fp)

      /* check for memory allocation failure */
      if (!vop)
 8248b50:	e0bffd17 	ldw	r2,-12(fp)
 8248b54:	1000061e 	bne	r2,zero,8248b70 <vfopen_locked+0x280>
      {
         VFS_VFS_FILE_FREE(vfp); /* free the allocated vfs_file entry */
 8248b58:	e13ffc17 	ldw	r4,-16(fp)
 8248b5c:	822e1fc0 	call	822e1fc <npfree>
         set_vfopen_error(ENP_NOMEM);
 8248b60:	013ffb04 	movi	r4,-20
 8248b64:	824871c0 	call	824871c <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 2\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 8248b68:	0005883a 	mov	r2,zero
 8248b6c:	00002906 	br	8248c14 <vfopen_locked+0x324>
      }

      /* add the vfs_file structure to the head of the list */

      vfp->next = vfsfiles;
 8248b70:	d0e0d617 	ldw	r3,-31912(gp)
 8248b74:	e0bffc17 	ldw	r2,-16(fp)
 8248b78:	10c00015 	stw	r3,0(r2)
      vfsfiles = vfp;
 8248b7c:	e0bffc17 	ldw	r2,-16(fp)
 8248b80:	d0a0d615 	stw	r2,-31912(gp)

      /* increment count of total files */
      vfs_total_dyna_files++;
 8248b84:	d0a0db17 	ldw	r2,-31892(gp)
 8248b88:	10800044 	addi	r2,r2,1
 8248b8c:	d0a0db15 	stw	r2,-31892(gp)

      /* remove leading directory separator before storing name */
      if (*name == '/' || *name == '\\')
 8248b90:	e0bffe17 	ldw	r2,-8(fp)
 8248b94:	10800003 	ldbu	r2,0(r2)
 8248b98:	10803fcc 	andi	r2,r2,255
 8248b9c:	1080201c 	xori	r2,r2,128
 8248ba0:	10bfe004 	addi	r2,r2,-128
 8248ba4:	10800be0 	cmpeqi	r2,r2,47
 8248ba8:	1000071e 	bne	r2,zero,8248bc8 <vfopen_locked+0x2d8>
 8248bac:	e0bffe17 	ldw	r2,-8(fp)
 8248bb0:	10800003 	ldbu	r2,0(r2)
 8248bb4:	10803fcc 	andi	r2,r2,255
 8248bb8:	1080201c 	xori	r2,r2,128
 8248bbc:	10bfe004 	addi	r2,r2,-128
 8248bc0:	10801718 	cmpnei	r2,r2,92
 8248bc4:	1000031e 	bne	r2,zero,8248bd4 <vfopen_locked+0x2e4>
         name++;
 8248bc8:	e0bffe17 	ldw	r2,-8(fp)
 8248bcc:	10800044 	addi	r2,r2,1
 8248bd0:	e0bffe15 	stw	r2,-8(fp)

      /* store the converted name in the directory entry structure */
      strcpy(vfp->name,name);
 8248bd4:	e0bffc17 	ldw	r2,-16(fp)
 8248bd8:	10800104 	addi	r2,r2,4
 8248bdc:	e17ffe17 	ldw	r5,-8(fp)
 8248be0:	1009883a 	mov	r4,r2
 8248be4:	824b7140 	call	824b714 <strcpy>

      /* set the flags */
      vfp->flags = VF_DYNAMICINFO   /* the directory entry was allocated */
 8248be8:	e0bffc17 	ldw	r2,-16(fp)
 8248bec:	00c0d804 	movi	r3,864
 8248bf0:	10c0058d 	sth	r3,22(r2)
       * note that this means the data pointer contains a null 
       * because we don't allocate any buffer to hold the data 
       * in until the first write 
       */
      /* link to the file's directory entry structure */
      vop->file = vfp;
 8248bf4:	e0bffd17 	ldw	r2,-12(fp)
 8248bf8:	e0fffc17 	ldw	r3,-16(fp)
 8248bfc:	10c00115 	stw	r3,4(r2)
      /* the cmploc and tag fields of the vop retain their NULLs from 
       * npalloc(). cmploc contains NULL because there is no data 
       * buffer to point to yet. tag contains NULL because no 
       * decompression operation has started yet
       */
      return vop;
 8248c00:	e0bffd17 	ldw	r2,-12(fp)
 8248c04:	00000306 	br	8248c14 <vfopen_locked+0x324>
   /* pass the open to the local file system */
   return (VFILE *) fopen(name,mode);

#else

   set_vfopen_error(ENP_NOFILE);
 8248c08:	013ff9c4 	movi	r4,-25
 8248c0c:	824871c0 	call	824871c <set_vfopen_error>
#ifdef VFS_VERBOSE
   dprintf("fell thru to end of vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
   return NULL;
 8248c10:	0005883a 	mov	r2,zero

#endif   /* HT_LOCALFS */
}
 8248c14:	e037883a 	mov	sp,fp
 8248c18:	dfc00117 	ldw	ra,4(sp)
 8248c1c:	df000017 	ldw	fp,0(sp)
 8248c20:	dec00204 	addi	sp,sp,8
 8248c24:	f800283a 	ret

08248c28 <vfopen>:
 * RETURNS: 
 */

VFILE *
vfopen(char * name, char * mode)
{
 8248c28:	defffb04 	addi	sp,sp,-20
 8248c2c:	dfc00415 	stw	ra,16(sp)
 8248c30:	df000315 	stw	fp,12(sp)
 8248c34:	df000304 	addi	fp,sp,12
 8248c38:	e13ffe15 	stw	r4,-8(fp)
 8248c3c:	e17fff15 	stw	r5,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfopen() passed >%s<,%s\n",name,mode);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 8248c40:	01000144 	movi	r4,5
 8248c44:	822dc040 	call	822dc04 <wait_app_sem>

   vfd = vfopen_locked(name,mode);
 8248c48:	e17fff17 	ldw	r5,-4(fp)
 8248c4c:	e13ffe17 	ldw	r4,-8(fp)
 8248c50:	82488f00 	call	82488f0 <vfopen_locked>
 8248c54:	e0bffd15 	stw	r2,-12(fp)

   vfs_unlock();
 8248c58:	01000144 	movi	r4,5
 8248c5c:	822dcc00 	call	822dcc0 <post_app_sem>

   return vfd;
 8248c60:	e0bffd17 	ldw	r2,-12(fp)
}
 8248c64:	e037883a 	mov	sp,fp
 8248c68:	dfc00117 	ldw	ra,4(sp)
 8248c6c:	df000017 	ldw	fp,0(sp)
 8248c70:	dec00204 	addi	sp,sp,8
 8248c74:	f800283a 	ret

08248c78 <vfclose_locked>:
 * RETURNS: 
 */

void 
vfclose_locked(VFILE * vfd)
{
 8248c78:	defff804 	addi	sp,sp,-32
 8248c7c:	dfc00715 	stw	ra,28(sp)
 8248c80:	df000615 	stw	fp,24(sp)
 8248c84:	df000604 	addi	fp,sp,24
 8248c88:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;
   VFILE * vlast;

   vlast = NULL;
 8248c8c:	e03ffb15 	stw	zero,-20(fp)

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
 8248c90:	d0a0d517 	ldw	r2,-31916(gp)
 8248c94:	e0bffa15 	stw	r2,-24(fp)
   while (vtmp)
 8248c98:	00000806 	br	8248cbc <vfclose_locked+0x44>
   {
      /* if this is the one we are looking for, exist search loop */
      if (vfd == vtmp)
 8248c9c:	e0ffff17 	ldw	r3,-4(fp)
 8248ca0:	e0bffa17 	ldw	r2,-24(fp)
 8248ca4:	18800826 	beq	r3,r2,8248cc8 <vfclose_locked+0x50>
         break;

      /* bump the next and previous pointers along to try the next one */
      vlast = vtmp;
 8248ca8:	e0bffa17 	ldw	r2,-24(fp)
 8248cac:	e0bffb15 	stw	r2,-20(fp)
      vtmp = vtmp->next;
 8248cb0:	e0bffa17 	ldw	r2,-24(fp)
 8248cb4:	10800017 	ldw	r2,0(r2)
 8248cb8:	e0bffa15 	stw	r2,-24(fp)
   vlast = NULL;

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
   while (vtmp)
 8248cbc:	e0bffa17 	ldw	r2,-24(fp)
 8248cc0:	103ff61e 	bne	r2,zero,8248c9c <vfclose_locked+0x24>
 8248cc4:	00000106 	br	8248ccc <vfclose_locked+0x54>
   {
      /* if this is the one we are looking for, exist search loop */
      if (vfd == vtmp)
         break;
 8248cc8:	0001883a 	nop
      vlast = vtmp;
      vtmp = vtmp->next;
   }

   /* if the passed in handle was not in the list we maintain */
   if (vfd != vtmp)
 8248ccc:	e0ffff17 	ldw	r3,-4(fp)
 8248cd0:	e0bffa17 	ldw	r2,-24(fp)
 8248cd4:	1880511e 	bne	r3,r2,8248e1c <vfclose_locked+0x1a4>

   /* this not really a forever loop. it exists so we can break easily
      and deal with all the ifdefs */
   while (1)
   {
      struct vfs_file * vfp   =  vfd->file;
 8248cd8:	e0bfff17 	ldw	r2,-4(fp)
 8248cdc:	10800117 	ldw	r2,4(r2)
 8248ce0:	e0bffc15 	stw	r2,-16(fp)
      /* vfd->file will be null if somebody unlinked the file after
       * this handle was created to point to it. if the file itself 
       * is gone there is nothing left to do, so break to list 
       * deletion code at bottom of loop
       */
      if (vfp == NULL)
 8248ce4:	e0bffc17 	ldw	r2,-16(fp)
 8248ce8:	10003826 	beq	r2,zero,8248dcc <vfclose_locked+0x154>
         break;
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 8248cec:	e0bffc17 	ldw	r2,-16(fp)
 8248cf0:	10800a17 	ldw	r2,40(r2)
 8248cf4:	10000826 	beq	r2,zero,8248d18 <vfclose_locked+0xa0>
      {
         /* call that file system's fclose() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)(vfp->method);
 8248cf8:	e0bffc17 	ldw	r2,-16(fp)
 8248cfc:	10800a17 	ldw	r2,40(r2)
 8248d00:	e0bffd15 	stw	r2,-12(fp)

         vfs->r_fclose(vfd);
 8248d04:	e0bffd17 	ldw	r2,-12(fp)
 8248d08:	10800217 	ldw	r2,8(r2)
 8248d0c:	e13fff17 	ldw	r4,-4(fp)
 8248d10:	103ee83a 	callr	r2
         break;   /* break to list deletion code after end of phoney loop */
 8248d14:	00003006 	br	8248dd8 <vfclose_locked+0x160>

      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
 8248d18:	e0bffc17 	ldw	r2,-16(fp)
 8248d1c:	1080058b 	ldhu	r2,22(r2)
 8248d20:	10bfffcc 	andi	r2,r2,65535
 8248d24:	1080200c 	andi	r2,r2,128
 8248d28:	10002a26 	beq	r2,zero,8248dd4 <vfclose_locked+0x15c>
          ((vfp->buf_size - vfp->comp_size) > VFS_CLOSE_FRAG_FLOOR) &&
 8248d2c:	e0bffc17 	ldw	r2,-16(fp)
 8248d30:	10c00917 	ldw	r3,36(r2)
 8248d34:	e0bffc17 	ldw	r2,-16(fp)
 8248d38:	10800817 	ldw	r2,32(r2)
 8248d3c:	1885c83a 	sub	r2,r3,r2

      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
 8248d40:	10804030 	cmpltui	r2,r2,256
 8248d44:	1000231e 	bne	r2,zero,8248dd4 <vfclose_locked+0x15c>
          ((vfp->buf_size - vfp->comp_size) > VFS_CLOSE_FRAG_FLOOR) &&
          vfp->data) /* this last test is a sanity check */
 8248d48:	e0bffc17 	ldw	r2,-16(fp)
 8248d4c:	10800617 	ldw	r2,24(r2)
      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
          ((vfp->buf_size - vfp->comp_size) > VFS_CLOSE_FRAG_FLOOR) &&
 8248d50:	10002026 	beq	r2,zero,8248dd4 <vfclose_locked+0x15c>
          vfp->data) /* this last test is a sanity check */
      {
         /* try to reclaim the unused data */

         /* allocate a new buffer just big enough for the data */
         new_buffer = vf_alloc_buffer(vfp->comp_size);
 8248d54:	e0bffc17 	ldw	r2,-16(fp)
 8248d58:	10800817 	ldw	r2,32(r2)
 8248d5c:	1009883a 	mov	r4,r2
 8248d60:	82487d80 	call	82487d8 <vf_alloc_buffer>
 8248d64:	e0bffe15 	stw	r2,-8(fp)

         /* if the allocation worked */
         if (new_buffer)
 8248d68:	e0bffe17 	ldw	r2,-8(fp)
 8248d6c:	10001926 	beq	r2,zero,8248dd4 <vfclose_locked+0x15c>
         {
            /* copy the old buffer to the new one */
            MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 8248d70:	e0bffc17 	ldw	r2,-16(fp)
 8248d74:	10c00617 	ldw	r3,24(r2)
 8248d78:	e0bffc17 	ldw	r2,-16(fp)
 8248d7c:	10800817 	ldw	r2,32(r2)
 8248d80:	100d883a 	mov	r6,r2
 8248d84:	180b883a 	mov	r5,r3
 8248d88:	e13ffe17 	ldw	r4,-8(fp)
 8248d8c:	8202f6c0 	call	8202f6c <memcpy>
            /* free the old buffer */
            vf_free_buffer(vfp->data,vfp->buf_size);
 8248d90:	e0bffc17 	ldw	r2,-16(fp)
 8248d94:	10c00617 	ldw	r3,24(r2)
 8248d98:	e0bffc17 	ldw	r2,-16(fp)
 8248d9c:	10800917 	ldw	r2,36(r2)
 8248da0:	100b883a 	mov	r5,r2
 8248da4:	1809883a 	mov	r4,r3
 8248da8:	82488a00 	call	82488a0 <vf_free_buffer>
            /* update the buffer pointer and size to reflect the
               just big enough buffer */
            vfp->data = new_buffer;
 8248dac:	e0bffc17 	ldw	r2,-16(fp)
 8248db0:	e0fffe17 	ldw	r3,-8(fp)
 8248db4:	10c00615 	stw	r3,24(r2)
            vfp->buf_size = vfp->comp_size;
 8248db8:	e0bffc17 	ldw	r2,-16(fp)
 8248dbc:	10c00817 	ldw	r3,32(r2)
 8248dc0:	e0bffc17 	ldw	r2,-16(fp)
 8248dc4:	10c00915 	stw	r3,36(r2)
#endif   /* VFS_AUTO_SYNC */

#endif   /* HT_RWVFS */

      /* break to list deletion code below */
      break;
 8248dc8:	00000206 	br	8248dd4 <vfclose_locked+0x15c>
       * this handle was created to point to it. if the file itself 
       * is gone there is nothing left to do, so break to list 
       * deletion code at bottom of loop
       */
      if (vfp == NULL)
         break;
 8248dcc:	0001883a 	nop
 8248dd0:	00000106 	br	8248dd8 <vfclose_locked+0x160>
#endif   /* VFS_AUTO_SYNC */

#endif   /* HT_RWVFS */

      /* break to list deletion code below */
      break;
 8248dd4:	0001883a 	nop

   }

   if (vlast)  /* unlink from list of open files */
 8248dd8:	e0bffb17 	ldw	r2,-20(fp)
 8248ddc:	10000526 	beq	r2,zero,8248df4 <vfclose_locked+0x17c>
      vlast->next = vtmp->next;
 8248de0:	e0bffa17 	ldw	r2,-24(fp)
 8248de4:	10c00017 	ldw	r3,0(r2)
 8248de8:	e0bffb17 	ldw	r2,-20(fp)
 8248dec:	10c00015 	stw	r3,0(r2)
 8248df0:	00000306 	br	8248e00 <vfclose_locked+0x188>
   else
      vfiles = vtmp->next;
 8248df4:	e0bffa17 	ldw	r2,-24(fp)
 8248df8:	10800017 	ldw	r2,0(r2)
 8248dfc:	d0a0d515 	stw	r2,-31916(gp)

   /* free structure addressed by open handle */
   VFS_VFS_OPEN_FREE(vtmp);
 8248e00:	e13ffa17 	ldw	r4,-24(fp)
 8248e04:	822e1fc0 	call	822e1fc <npfree>
   /* decrement the number of open files */
   vfs_open_files--;
 8248e08:	d0a0d917 	ldw	r2,-31900(gp)
 8248e0c:	10bfffc4 	addi	r2,r2,-1
 8248e10:	d0a0d915 	stw	r2,-31900(gp)
   return;
 8248e14:	0001883a 	nop
 8248e18:	00000106 	br	8248e20 <vfclose_locked+0x1a8>

#ifdef HT_LOCALFS
      /* default to call on local system */
      fclose((FILE*)vfd);
#endif   /* HT_LOCALFS */
      return;
 8248e1c:	0001883a 	nop
   /* free structure addressed by open handle */
   VFS_VFS_OPEN_FREE(vtmp);
   /* decrement the number of open files */
   vfs_open_files--;
   return;
}
 8248e20:	e037883a 	mov	sp,fp
 8248e24:	dfc00117 	ldw	ra,4(sp)
 8248e28:	df000017 	ldw	fp,0(sp)
 8248e2c:	dec00204 	addi	sp,sp,8
 8248e30:	f800283a 	ret

08248e34 <vfclose>:
 *
 * RETURNS: 
 */

void vfclose(VFILE * vfd)
{
 8248e34:	defffd04 	addi	sp,sp,-12
 8248e38:	dfc00215 	stw	ra,8(sp)
 8248e3c:	df000115 	stw	fp,4(sp)
 8248e40:	df000104 	addi	fp,sp,4
 8248e44:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 8248e48:	01000144 	movi	r4,5
 8248e4c:	822dc040 	call	822dc04 <wait_app_sem>

   vfclose_locked(vfd);
 8248e50:	e13fff17 	ldw	r4,-4(fp)
 8248e54:	8248c780 	call	8248c78 <vfclose_locked>

   vfs_unlock();
 8248e58:	01000144 	movi	r4,5
 8248e5c:	822dcc00 	call	822dcc0 <post_app_sem>
}
 8248e60:	0001883a 	nop
 8248e64:	e037883a 	mov	sp,fp
 8248e68:	dfc00117 	ldw	ra,4(sp)
 8248e6c:	df000017 	ldw	fp,0(sp)
 8248e70:	dec00204 	addi	sp,sp,8
 8248e74:	f800283a 	ret

08248e78 <vfflush>:
 *
 * RETURNS: 
 */

int vfflush(VFILE * vfd)
{
 8248e78:	defffd04 	addi	sp,sp,-12
 8248e7c:	dfc00215 	stw	ra,8(sp)
 8248e80:	df000115 	stw	fp,4(sp)
 8248e84:	df000104 	addi	fp,sp,4
 8248e88:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 8248e8c:	01000144 	movi	r4,5
 8248e90:	822dc040 	call	822dc04 <wait_app_sem>

   printf("vfflush(): This function needs to be implemented\n");
 8248e94:	01020974 	movhi	r4,2085
 8248e98:	21070104 	addi	r4,r4,7172
 8248e9c:	82036800 	call	8203680 <puts>

   vfs_unlock();
 8248ea0:	01000144 	movi	r4,5
 8248ea4:	822dcc00 	call	822dcc0 <post_app_sem>
   return(0);
 8248ea8:	0005883a 	mov	r2,zero
}
 8248eac:	e037883a 	mov	sp,fp
 8248eb0:	dfc00117 	ldw	ra,4(sp)
 8248eb4:	df000017 	ldw	fp,0(sp)
 8248eb8:	dec00204 	addi	sp,sp,8
 8248ebc:	f800283a 	ret

08248ec0 <vfgets>:

char * vfgets(char * s, int lim, VFILE * fp) 
{
 8248ec0:	defff904 	addi	sp,sp,-28
 8248ec4:	dfc00615 	stw	ra,24(sp)
 8248ec8:	df000515 	stw	fp,20(sp)
 8248ecc:	df000504 	addi	fp,sp,20
 8248ed0:	e13ffd15 	stw	r4,-12(fp)
 8248ed4:	e17ffe15 	stw	r5,-8(fp)
 8248ed8:	e1bfff15 	stw	r6,-4(fp)
   int   c   = EOF;
 8248edc:	00bfffc4 	movi	r2,-1
 8248ee0:	e0bffb15 	stw	r2,-20(fp)
   char* ret = s;
 8248ee4:	e0bffd17 	ldw	r2,-12(fp)
 8248ee8:	e0bffc15 	stw	r2,-16(fp)

   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 8248eec:	00000b06 	br	8248f1c <vfgets+0x5c>
      if (( *ret ++ = c) == '\n')
 8248ef0:	e0bffc17 	ldw	r2,-16(fp)
 8248ef4:	10c00044 	addi	r3,r2,1
 8248ef8:	e0fffc15 	stw	r3,-16(fp)
 8248efc:	e0fffb17 	ldw	r3,-20(fp)
 8248f00:	10c00005 	stb	r3,0(r2)
 8248f04:	10800003 	ldbu	r2,0(r2)
 8248f08:	10803fcc 	andi	r2,r2,255
 8248f0c:	1080201c 	xori	r2,r2,128
 8248f10:	10bfe004 	addi	r2,r2,-128
 8248f14:	10800298 	cmpnei	r2,r2,10
 8248f18:	10000c26 	beq	r2,zero,8248f4c <vfgets+0x8c>
char * vfgets(char * s, int lim, VFILE * fp) 
{
   int   c   = EOF;
   char* ret = s;

   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 8248f1c:	e0bffe17 	ldw	r2,-8(fp)
 8248f20:	10bfffc4 	addi	r2,r2,-1
 8248f24:	e0bffe15 	stw	r2,-8(fp)
 8248f28:	e0bffe17 	ldw	r2,-8(fp)
 8248f2c:	0080080e 	bge	zero,r2,8248f50 <vfgets+0x90>
 8248f30:	e13fff17 	ldw	r4,-4(fp)
 8248f34:	8249b2c0 	call	8249b2c <vgetc>
 8248f38:	e0bffb15 	stw	r2,-20(fp)
 8248f3c:	e0bffb17 	ldw	r2,-20(fp)
 8248f40:	10bfffd8 	cmpnei	r2,r2,-1
 8248f44:	103fea1e 	bne	r2,zero,8248ef0 <vfgets+0x30>
 8248f48:	00000106 	br	8248f50 <vfgets+0x90>
      if (( *ret ++ = c) == '\n')
         break;
 8248f4c:	0001883a 	nop
   *ret = '\0';
 8248f50:	e0bffc17 	ldw	r2,-16(fp)
 8248f54:	10000005 	stb	zero,0(r2)
   return ( c == EOF && ret == s) ? NULL : s;
 8248f58:	e0bffb17 	ldw	r2,-20(fp)
 8248f5c:	10bfffd8 	cmpnei	r2,r2,-1
 8248f60:	1000031e 	bne	r2,zero,8248f70 <vfgets+0xb0>
 8248f64:	e0fffc17 	ldw	r3,-16(fp)
 8248f68:	e0bffd17 	ldw	r2,-12(fp)
 8248f6c:	18800226 	beq	r3,r2,8248f78 <vfgets+0xb8>
 8248f70:	e0bffd17 	ldw	r2,-12(fp)
 8248f74:	00000106 	br	8248f7c <vfgets+0xbc>
 8248f78:	0005883a 	mov	r2,zero
}
 8248f7c:	e037883a 	mov	sp,fp
 8248f80:	dfc00117 	ldw	ra,4(sp)
 8248f84:	df000017 	ldw	fp,0(sp)
 8248f88:	dec00204 	addi	sp,sp,8
 8248f8c:	f800283a 	ret

08248f90 <vfeof>:
 *
 * RETURNS: 1 if the file pointer is at EOF, otherwise 0
 */
 
int vfeof(VFILE * vfd)
{
 8248f90:	defffc04 	addi	sp,sp,-16
 8248f94:	dfc00315 	stw	ra,12(sp)
 8248f98:	df000215 	stw	fp,8(sp)
 8248f9c:	df000204 	addi	fp,sp,8
 8248fa0:	e13fff15 	stw	r4,-4(fp)
   int c = 0;
 8248fa4:	e03ffe15 	stw	zero,-8(fp)

#ifdef HT_LOCALFS
   return(feof((FILE*)vfd));
#endif
   if ((c = vgetc(vfd)) == EOF )
 8248fa8:	e13fff17 	ldw	r4,-4(fp)
 8248fac:	8249b2c0 	call	8249b2c <vgetc>
 8248fb0:	e0bffe15 	stw	r2,-8(fp)
 8248fb4:	e0bffe17 	ldw	r2,-8(fp)
 8248fb8:	10bfffd8 	cmpnei	r2,r2,-1
 8248fbc:	1000021e 	bne	r2,zero,8248fc8 <vfeof+0x38>
   {
      return 1;
 8248fc0:	00800044 	movi	r2,1
 8248fc4:	00000106 	br	8248fcc <vfeof+0x3c>
   }   
   return 0;
 8248fc8:	0005883a 	mov	r2,zero
}
 8248fcc:	e037883a 	mov	sp,fp
 8248fd0:	dfc00117 	ldw	ra,4(sp)
 8248fd4:	df000017 	ldw	fp,0(sp)
 8248fd8:	dec00204 	addi	sp,sp,8
 8248fdc:	f800283a 	ret

08248fe0 <vunlink_flag_open_files>:
 *
 * RETURNS: 
 */

void vunlink_flag_open_files(struct vfs_file * vfp)
{
 8248fe0:	defffd04 	addi	sp,sp,-12
 8248fe4:	df000215 	stw	fp,8(sp)
 8248fe8:	df000204 	addi	fp,sp,8
 8248fec:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 8248ff0:	d0a0d517 	ldw	r2,-31916(gp)
 8248ff4:	e0bffe15 	stw	r2,-8(fp)
 8248ff8:	00000906 	br	8249020 <vunlink_flag_open_files+0x40>
   {
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
 8248ffc:	e0bffe17 	ldw	r2,-8(fp)
 8249000:	10c00117 	ldw	r3,4(r2)
 8249004:	e0bfff17 	ldw	r2,-4(fp)
 8249008:	1880021e 	bne	r3,r2,8249014 <vunlink_flag_open_files+0x34>
         vtmp->file = NULL;
 824900c:	e0bffe17 	ldw	r2,-8(fp)
 8249010:	10000115 	stw	zero,4(r2)
void vunlink_flag_open_files(struct vfs_file * vfp)
{
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 8249014:	e0bffe17 	ldw	r2,-8(fp)
 8249018:	10800017 	ldw	r2,0(r2)
 824901c:	e0bffe15 	stw	r2,-8(fp)
 8249020:	e0bffe17 	ldw	r2,-8(fp)
 8249024:	103ff51e 	bne	r2,zero,8248ffc <vunlink_flag_open_files+0x1c>
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
         vtmp->file = NULL;
   }
}
 8249028:	0001883a 	nop
 824902c:	e037883a 	mov	sp,fp
 8249030:	df000017 	ldw	fp,0(sp)
 8249034:	dec00104 	addi	sp,sp,4
 8249038:	f800283a 	ret

0824903c <vunlink>:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
int
vunlink(const char * const_name)
{
 824903c:	defff604 	addi	sp,sp,-40
 8249040:	dfc00915 	stw	ra,36(sp)
 8249044:	df000815 	stw	fp,32(sp)
 8249048:	df000804 	addi	fp,sp,32
 824904c:	e13fff15 	stw	r4,-4(fp)
   struct vfs_file * vfp;
   int   rc =  0;
 8249050:	e03ff815 	stw	zero,-32(fp)
/*
 * Altera Niche Stack Nios port modification:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
   char * name = malloc(strlen(const_name)+1);
 8249054:	e13fff17 	ldw	r4,-4(fp)
 8249058:	8203fbc0 	call	8203fbc <strlen>
 824905c:	10800044 	addi	r2,r2,1
 8249060:	1009883a 	mov	r4,r2
 8249064:	824b6ec0 	call	824b6ec <malloc>
 8249068:	e0bffb15 	stw	r2,-20(fp)
   strcpy(name, const_name);
 824906c:	e17fff17 	ldw	r5,-4(fp)
 8249070:	e13ffb17 	ldw	r4,-20(fp)
 8249074:	824b7140 	call	824b714 <strcpy>
   if (vfs_log_file_name)
      dprintf("vunlink() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 8249078:	01000144 	movi	r4,5
 824907c:	822dc040 	call	822dc04 <wait_app_sem>

   /* see if the converted name is one of the one's in our list */
   /* if it isn't */
   if ((vfp = vfslookup_locked(name)) == NULL)
 8249080:	e13ffb17 	ldw	r4,-20(fp)
 8249084:	8249b740 	call	8249b74 <vfslookup_locked>
 8249088:	e0bffc15 	stw	r2,-16(fp)
 824908c:	e0bffc17 	ldw	r2,-16(fp)
 8249090:	1000061e 	bne	r2,zero,82490ac <vunlink+0x70>
   {
      vfs_unlock();
 8249094:	01000144 	movi	r4,5
 8249098:	822dcc00 	call	822dcc0 <post_app_sem>
#ifdef HT_LOCALFS
      /* default to call on local system */
      return remove(name);
#else
      /* no local file system, so return error condition */
      free(name);
 824909c:	e13ffb17 	ldw	r4,-20(fp)
 82490a0:	824b7000 	call	824b700 <free>
      return -1;
 82490a4:	00bfffc4 	movi	r2,-1
 82490a8:	00005f06 	br	8249228 <vunlink+0x1ec>
#ifdef   HT_RWVFS
   /* save the next link pointer since in one path through the code, 
    * the vfs_file structure gets freed before its unlinked from the 
    * list
    */
   vfnext = vfp->next;
 82490ac:	e0bffc17 	ldw	r2,-16(fp)
 82490b0:	10800017 	ldw	r2,0(r2)
 82490b4:	e0bffd15 	stw	r2,-12(fp)

   /* search list of files to determine predecessor in list */
   vflast = NULL;
 82490b8:	e03ffa15 	stw	zero,-24(fp)
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 82490bc:	d0a0d617 	ldw	r2,-31912(gp)
 82490c0:	e0bff915 	stw	r2,-28(fp)
 82490c4:	00000806 	br	82490e8 <vunlink+0xac>
   {
      if (vtmp == vfp)
 82490c8:	e0fff917 	ldw	r3,-28(fp)
 82490cc:	e0bffc17 	ldw	r2,-16(fp)
 82490d0:	18800826 	beq	r3,r2,82490f4 <vunlink+0xb8>
         break;
      vflast = vtmp;
 82490d4:	e0bff917 	ldw	r2,-28(fp)
 82490d8:	e0bffa15 	stw	r2,-24(fp)
    */
   vfnext = vfp->next;

   /* search list of files to determine predecessor in list */
   vflast = NULL;
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 82490dc:	e0bff917 	ldw	r2,-28(fp)
 82490e0:	10800017 	ldw	r2,0(r2)
 82490e4:	e0bff915 	stw	r2,-28(fp)
 82490e8:	e0bff917 	ldw	r2,-28(fp)
 82490ec:	103ff61e 	bne	r2,zero,82490c8 <vunlink+0x8c>
 82490f0:	00000106 	br	82490f8 <vunlink+0xbc>
   {
      if (vtmp == vfp)
         break;
 82490f4:	0001883a 	nop
      vflast = vtmp;
   }

   /* this shouldn't happen since vfslookup_locked() already searched
      the list, but just in case */
   if (vtmp == NULL)
 82490f8:	e0bff917 	ldw	r2,-28(fp)
 82490fc:	1000071e 	bne	r2,zero,824911c <vunlink+0xe0>
   {
      dtrap();
 8249100:	822d5f00 	call	822d5f0 <dtrap>
      vfs_unlock();
 8249104:	01000144 	movi	r4,5
 8249108:	822dcc00 	call	822dcc0 <post_app_sem>
      free(name);
 824910c:	e13ffb17 	ldw	r4,-20(fp)
 8249110:	824b7000 	call	824b700 <free>
      return -1;
 8249114:	00bfffc4 	movi	r2,-1
 8249118:	00004306 	br	8249228 <vunlink+0x1ec>
   while (1)
   {

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 824911c:	e0bffc17 	ldw	r2,-16(fp)
 8249120:	10800a17 	ldw	r2,40(r2)
 8249124:	10000926 	beq	r2,zero,824914c <vunlink+0x110>
      {
         /* call that file system's unlink() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfp->method);
 8249128:	e0bffc17 	ldw	r2,-16(fp)
 824912c:	10800a17 	ldw	r2,40(r2)
 8249130:	e0bffe15 	stw	r2,-8(fp)

         rc = vfs->r_unlink(name);
 8249134:	e0bffe17 	ldw	r2,-8(fp)
 8249138:	10800817 	ldw	r2,32(r2)
 824913c:	e13ffb17 	ldw	r4,-20(fp)
 8249140:	103ee83a 	callr	r2
 8249144:	e0bff815 	stw	r2,-32(fp)
         break;   /* break to list deletion code after end of phoney loop */
 8249148:	00002606 	br	82491e4 <vunlink+0x1a8>
      }
#endif   /* HT_EXTDEV */

      /* if the file is not write enabled, return error condition */
      if (!(vfp->flags & VF_WRITE))
 824914c:	e0bffc17 	ldw	r2,-16(fp)
 8249150:	1080058b 	ldhu	r2,22(r2)
 8249154:	10bfffcc 	andi	r2,r2,65535
 8249158:	1080080c 	andi	r2,r2,32
 824915c:	1000061e 	bne	r2,zero,8249178 <vunlink+0x13c>
      {
         vfs_unlock();
 8249160:	01000144 	movi	r4,5
 8249164:	822dcc00 	call	822dcc0 <post_app_sem>
         free(name);
 8249168:	e13ffb17 	ldw	r4,-20(fp)
 824916c:	824b7000 	call	824b700 <free>
         return -1;
 8249170:	00bfffc4 	movi	r2,-1
 8249174:	00002c06 	br	8249228 <vunlink+0x1ec>
      }

      /* if the data buffer containing the file's data was dynamically
         allocated and is not null */
      if ((vfp->flags & VF_DYNAMICDATA) && (vfp->data))
 8249178:	e0bffc17 	ldw	r2,-16(fp)
 824917c:	1080058b 	ldhu	r2,22(r2)
 8249180:	10bfffcc 	andi	r2,r2,65535
 8249184:	1080200c 	andi	r2,r2,128
 8249188:	10000a26 	beq	r2,zero,82491b4 <vunlink+0x178>
 824918c:	e0bffc17 	ldw	r2,-16(fp)
 8249190:	10800617 	ldw	r2,24(r2)
 8249194:	10000726 	beq	r2,zero,82491b4 <vunlink+0x178>
      {
         /* free the buffer */
         vf_free_buffer(vfp->data,vfp->buf_size);
 8249198:	e0bffc17 	ldw	r2,-16(fp)
 824919c:	10c00617 	ldw	r3,24(r2)
 82491a0:	e0bffc17 	ldw	r2,-16(fp)
 82491a4:	10800917 	ldw	r2,36(r2)
 82491a8:	100b883a 	mov	r5,r2
 82491ac:	1809883a 	mov	r4,r3
 82491b0:	82488a00 	call	82488a0 <vf_free_buffer>
      }

      /* if the vfs_file structure itself was allocated dynamically */
      if (vfp->flags & VF_DYNAMICINFO)
 82491b4:	e0bffc17 	ldw	r2,-16(fp)
 82491b8:	1080058b 	ldhu	r2,22(r2)
 82491bc:	10bfffcc 	andi	r2,r2,65535
 82491c0:	1080100c 	andi	r2,r2,64
 82491c4:	10000526 	beq	r2,zero,82491dc <vunlink+0x1a0>
      {
         /* decrement count of total files */
         vfs_total_dyna_files--;
 82491c8:	d0a0db17 	ldw	r2,-31892(gp)
 82491cc:	10bfffc4 	addi	r2,r2,-1
 82491d0:	d0a0db15 	stw	r2,-31892(gp)

         /* free the vfs_file structure */
         VFS_VFS_FILE_FREE(vfp);
 82491d4:	e13ffc17 	ldw	r4,-16(fp)
 82491d8:	822e1fc0 	call	822e1fc <npfree>
         the vfs_file has been deleted from the list */
#ifdef VFS_AUTO_SYNC
      do_sync = 1;
#endif
      /* we were successful at our unlink */
      rc = 0;
 82491dc:	e03ff815 	stw	zero,-32(fp)

      break;
 82491e0:	0001883a 	nop
   }

   /* delete the vfs_file structure from the list headed by vfsfiles */
   if (vflast)
 82491e4:	e0bffa17 	ldw	r2,-24(fp)
 82491e8:	10000426 	beq	r2,zero,82491fc <vunlink+0x1c0>
      vflast->next = vfnext;
 82491ec:	e0bffa17 	ldw	r2,-24(fp)
 82491f0:	e0fffd17 	ldw	r3,-12(fp)
 82491f4:	10c00015 	stw	r3,0(r2)
 82491f8:	00000206 	br	8249204 <vunlink+0x1c8>
   else
      vfsfiles = vfnext;
 82491fc:	e0bffd17 	ldw	r2,-12(fp)
 8249200:	d0a0d615 	stw	r2,-31912(gp)

   /* fix up references to deleted file in list of currently open VFILEs */
   vunlink_flag_open_files(vfp);
 8249204:	e13ffc17 	ldw	r4,-16(fp)
 8249208:	8248fe00 	call	8248fe0 <vunlink_flag_open_files>

   /* flag that the directory is stale so vfs_sync() knows it has to do
      something */
   vfs_dir_stale = TRUE;
 824920c:	00800044 	movi	r2,1
 8249210:	d0a0d815 	stw	r2,-31904(gp)

   /* unlinks not allowed on read-only VFS */
   rc = -1;

#endif   /* HT_RWVFS */
   vfs_unlock();
 8249214:	01000144 	movi	r4,5
 8249218:	822dcc00 	call	822dcc0 <post_app_sem>
   free(name);
 824921c:	e13ffb17 	ldw	r4,-20(fp)
 8249220:	824b7000 	call	824b700 <free>
   return rc;
 8249224:	e0bff817 	ldw	r2,-32(fp)
}
 8249228:	e037883a 	mov	sp,fp
 824922c:	dfc00117 	ldw	ra,4(sp)
 8249230:	df000017 	ldw	fp,0(sp)
 8249234:	dec00204 	addi	sp,sp,8
 8249238:	f800283a 	ret

0824923c <vfread>:
 * RETURNS: 
 */

int 
vfread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 824923c:	defff604 	addi	sp,sp,-40
 8249240:	dfc00915 	stw	ra,36(sp)
 8249244:	df000815 	stw	fp,32(sp)
 8249248:	df000804 	addi	fp,sp,32
 824924c:	e13ffc15 	stw	r4,-16(fp)
 8249250:	e17ffd15 	stw	r5,-12(fp)
 8249254:	e1bffe15 	stw	r6,-8(fp)
 8249258:	e1ffff15 	stw	r7,-4(fp)
   unsigned bcount;  /* number of bytes put in caller's buffer */

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 824925c:	01000144 	movi	r4,5
 8249260:	822dc040 	call	822dc04 <wait_app_sem>

   /* if the file is in our list of open files */
   if (isvfile_locked(vfd))
 8249264:	e13fff17 	ldw	r4,-4(fp)
 8249268:	8249eac0 	call	8249eac <isvfile_locked>
 824926c:	10004e26 	beq	r2,zero,82493a8 <vfread+0x16c>
   {

#ifdef HT_RWVFS
      /* the caller is trying to read a handle to a file that's been
         deleted, so he gets 0 data back */
      if (vfd->file == NULL)
 8249270:	e0bfff17 	ldw	r2,-4(fp)
 8249274:	10800117 	ldw	r2,4(r2)
 8249278:	1000041e 	bne	r2,zero,824928c <vfread+0x50>
      {
         vfs_unlock();
 824927c:	01000144 	movi	r4,5
 8249280:	822dcc00 	call	822dcc0 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 8249284:	0005883a 	mov	r2,zero
 8249288:	00004a06 	br	82493b4 <vfread+0x178>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfd->file->method)
 824928c:	e0bfff17 	ldw	r2,-4(fp)
 8249290:	10800117 	ldw	r2,4(r2)
 8249294:	10800a17 	ldw	r2,40(r2)
 8249298:	10001026 	beq	r2,zero,82492dc <vfread+0xa0>
      {
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 824929c:	e0bfff17 	ldw	r2,-4(fp)
 82492a0:	10800117 	ldw	r2,4(r2)
 82492a4:	10800a17 	ldw	r2,40(r2)
 82492a8:	e0bff915 	stw	r2,-28(fp)
         int   rc;

         /* call that system's fread() */
         rc = vfs->r_fread(buf,size,items,vfd);
 82492ac:	e0bff917 	ldw	r2,-28(fp)
 82492b0:	10800317 	ldw	r2,12(r2)
 82492b4:	e1ffff17 	ldw	r7,-4(fp)
 82492b8:	e1bffe17 	ldw	r6,-8(fp)
 82492bc:	e17ffd17 	ldw	r5,-12(fp)
 82492c0:	e13ffc17 	ldw	r4,-16(fp)
 82492c4:	103ee83a 	callr	r2
 82492c8:	e0bffa15 	stw	r2,-24(fp)
         vfs_unlock();
 82492cc:	01000144 	movi	r4,5
 82492d0:	822dcc00 	call	822dcc0 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return rc;
 82492d4:	e0bffa17 	ldw	r2,-24(fp)
 82492d8:	00003606 	br	82493b4 <vfread+0x178>
#ifdef HT_RWVFS
      /* the data pointer can be NULL if somebody tries to read from 
       * a freshly created file, in which case there is no data in 
       * the file, so return 0
       */
      if (!(vfd->file->data))
 82492dc:	e0bfff17 	ldw	r2,-4(fp)
 82492e0:	10800117 	ldw	r2,4(r2)
 82492e4:	10800617 	ldw	r2,24(r2)
 82492e8:	1000041e 	bne	r2,zero,82492fc <vfread+0xc0>
      {
         vfs_unlock();
 82492ec:	01000144 	movi	r4,5
 82492f0:	822dcc00 	call	822dcc0 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 82492f4:	0005883a 	mov	r2,zero
 82492f8:	00002e06 	br	82493b4 <vfread+0x178>
      }
#endif   /* HT_RWVFS */

      bcount = items * size;  /* number of bytes to transfer */
 82492fc:	e0fffe17 	ldw	r3,-8(fp)
 8249300:	e0bffd17 	ldw	r2,-12(fp)
 8249304:	1885383a 	mul	r2,r3,r2
 8249308:	e0bff815 	stw	r2,-32(fp)
         return(items); /* filled user buffer, return # items copied */
      }
      else  /* else fall to faster non-compression code */
#endif   /* HTML_COMPRESSION */
      {  /* get here to do simple uncompressed data read */
         unsigned location = vfd->cmploc - vfd->file->data;
 824930c:	e0bfff17 	ldw	r2,-4(fp)
 8249310:	10800217 	ldw	r2,8(r2)
 8249314:	1007883a 	mov	r3,r2
 8249318:	e0bfff17 	ldw	r2,-4(fp)
 824931c:	10800117 	ldw	r2,4(r2)
 8249320:	10800617 	ldw	r2,24(r2)
 8249324:	1885c83a 	sub	r2,r3,r2
 8249328:	e0bffb15 	stw	r2,-20(fp)

         if (((unsigned long)location + bcount) > vfd->file->comp_size)
 824932c:	e0fffb17 	ldw	r3,-20(fp)
 8249330:	e0bff817 	ldw	r2,-32(fp)
 8249334:	1885883a 	add	r2,r3,r2
 8249338:	e0ffff17 	ldw	r3,-4(fp)
 824933c:	18c00117 	ldw	r3,4(r3)
 8249340:	18c00817 	ldw	r3,32(r3)
 8249344:	1880062e 	bgeu	r3,r2,8249360 <vfread+0x124>
            bcount = (unsigned)(vfd->file->comp_size - location);
 8249348:	e0bfff17 	ldw	r2,-4(fp)
 824934c:	10800117 	ldw	r2,4(r2)
 8249350:	10c00817 	ldw	r3,32(r2)
 8249354:	e0bffb17 	ldw	r2,-20(fp)
 8249358:	1885c83a 	sub	r2,r3,r2
 824935c:	e0bff815 	stw	r2,-32(fp)
         MEMCPY(buf, vfd->cmploc, bcount);
 8249360:	e0bfff17 	ldw	r2,-4(fp)
 8249364:	10800217 	ldw	r2,8(r2)
 8249368:	e1bff817 	ldw	r6,-32(fp)
 824936c:	100b883a 	mov	r5,r2
 8249370:	e13ffc17 	ldw	r4,-16(fp)
 8249374:	8202f6c0 	call	8202f6c <memcpy>
         vfd->cmploc += bcount;
 8249378:	e0bfff17 	ldw	r2,-4(fp)
 824937c:	10c00217 	ldw	r3,8(r2)
 8249380:	e0bff817 	ldw	r2,-32(fp)
 8249384:	1887883a 	add	r3,r3,r2
 8249388:	e0bfff17 	ldw	r2,-4(fp)
 824938c:	10c00215 	stw	r3,8(r2)
      }
      vfs_unlock();
 8249390:	01000144 	movi	r4,5
 8249394:	822dcc00 	call	822dcc0 <post_app_sem>
      IN_PROFILER(PF_FS, PF_EXIT);
      return (bcount/size);
 8249398:	e17ffd17 	ldw	r5,-12(fp)
 824939c:	e13ff817 	ldw	r4,-32(fp)
 82493a0:	8202c6c0 	call	8202c6c <__udivsi3>
 82493a4:	00000306 	br	82493b4 <vfread+0x178>
   }

   vfs_unlock();
 82493a8:	01000144 	movi	r4,5
 82493ac:	822dcc00 	call	822dcc0 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fread(buf, size, items, (FILE*)vfd));
#else
   return 0;
 82493b0:	0005883a 	mov	r2,zero
#endif   /* HT_LOCALFS */
}
 82493b4:	e037883a 	mov	sp,fp
 82493b8:	dfc00117 	ldw	ra,4(sp)
 82493bc:	df000017 	ldw	fp,0(sp)
 82493c0:	dec00204 	addi	sp,sp,8
 82493c4:	f800283a 	ret

082493c8 <vfwrite_locked>:
 * RETURNS: 
 */

int 
vfwrite_locked(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 82493c8:	defff204 	addi	sp,sp,-56
 82493cc:	dfc00d15 	stw	ra,52(sp)
 82493d0:	df000c15 	stw	fp,48(sp)
 82493d4:	df000c04 	addi	fp,sp,48
 82493d8:	e13ffc15 	stw	r4,-16(fp)
 82493dc:	e17ffd15 	stw	r5,-12(fp)
 82493e0:	e1bffe15 	stw	r6,-8(fp)
 82493e4:	e1ffff15 	stw	r7,-4(fp)
   unsigned long current_offset;
   struct vfs_file * vfp;
#endif   /* HT_RWVFS */

   /* if the file is not in our list of files */
   if (!isvfile_locked(vfd))
 82493e8:	e13fff17 	ldw	r4,-4(fp)
 82493ec:	8249eac0 	call	8249eac <isvfile_locked>
 82493f0:	1000021e 	bne	r2,zero,82493fc <vfwrite_locked+0x34>
   {
#ifdef HT_LOCALFS
      /* default to call on local system */
      return(fwrite(buf, size, items, (FILE*)vfd));
#else
      return EBADF;
 82493f4:	00800244 	movi	r2,9
 82493f8:	0000da06 	br	8249764 <vfwrite_locked+0x39c>
   }
   /* this file is in our list of files */

#ifdef HT_EXTDEV
   /* if the file was created by an external file system */
   if (vfd->file->method)
 82493fc:	e0bfff17 	ldw	r2,-4(fp)
 8249400:	10800117 	ldw	r2,4(r2)
 8249404:	10800a17 	ldw	r2,40(r2)
 8249408:	10000e26 	beq	r2,zero,8249444 <vfwrite_locked+0x7c>
   {
      struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 824940c:	e0bfff17 	ldw	r2,-4(fp)
 8249410:	10800117 	ldw	r2,4(r2)
 8249414:	10800a17 	ldw	r2,40(r2)
 8249418:	e0bff415 	stw	r2,-48(fp)
      int   rc;

      /* call that system's fwrite() */
      rc = vfs->r_fwrite(buf,size,items,vfd);
 824941c:	e0bff417 	ldw	r2,-48(fp)
 8249420:	10800417 	ldw	r2,16(r2)
 8249424:	e1ffff17 	ldw	r7,-4(fp)
 8249428:	e1bffe17 	ldw	r6,-8(fp)
 824942c:	e17ffd17 	ldw	r5,-12(fp)
 8249430:	e13ffc17 	ldw	r4,-16(fp)
 8249434:	103ee83a 	callr	r2
 8249438:	e0bff515 	stw	r2,-44(fp)
      return rc;
 824943c:	e0bff517 	ldw	r2,-44(fp)
 8249440:	0000c806 	br	8249764 <vfwrite_locked+0x39c>

#else    /* HT_RWVFS */

   /* the caller is trying to write to a file that's been deleted,
      so he writes 0 data */
   if (vfd->file == NULL)
 8249444:	e0bfff17 	ldw	r2,-4(fp)
 8249448:	10800117 	ldw	r2,4(r2)
 824944c:	1000021e 	bne	r2,zero,8249458 <vfwrite_locked+0x90>
   {
      return 0;
 8249450:	0005883a 	mov	r2,zero
 8249454:	0000c306 	br	8249764 <vfwrite_locked+0x39c>
   }

   vfp = vfd->file;
 8249458:	e0bfff17 	ldw	r2,-4(fp)
 824945c:	10800117 	ldw	r2,4(r2)
 8249460:	e0bff615 	stw	r2,-40(fp)

   /* if the file is not writable, return error condition */
   if (!(vfp->flags & VF_WRITE))
 8249464:	e0bff617 	ldw	r2,-40(fp)
 8249468:	1080058b 	ldhu	r2,22(r2)
 824946c:	10bfffcc 	andi	r2,r2,65535
 8249470:	1080080c 	andi	r2,r2,32
 8249474:	1000051e 	bne	r2,zero,824948c <vfwrite_locked+0xc4>
   {
      vfd->error = ENP_FILEIO;
 8249478:	e0bfff17 	ldw	r2,-4(fp)
 824947c:	00fff984 	movi	r3,-26
 8249480:	10c00415 	stw	r3,16(r2)
      return 0;
 8249484:	0005883a 	mov	r2,zero
 8249488:	0000b606 	br	8249764 <vfwrite_locked+0x39c>
   }

   /* compute number of bytes to write */
   bcount = size * items;
 824948c:	e0fffd17 	ldw	r3,-12(fp)
 8249490:	e0bffe17 	ldw	r2,-8(fp)
 8249494:	1885383a 	mul	r2,r3,r2
 8249498:	e0bff715 	stw	r2,-36(fp)

   /* get rid of this degenerate case up front */
   if (bcount == 0)
 824949c:	e0bff717 	ldw	r2,-36(fp)
 82494a0:	1000021e 	bne	r2,zero,82494ac <vfwrite_locked+0xe4>
   {
      return 0;
 82494a4:	0005883a 	mov	r2,zero
 82494a8:	0000ae06 	br	8249764 <vfwrite_locked+0x39c>
   }

   /* if the file currently has no data buffer */
   if (vfp->data == NULL)
 82494ac:	e0bff617 	ldw	r2,-40(fp)
 82494b0:	10800617 	ldw	r2,24(r2)
 82494b4:	10003d1e 	bne	r2,zero,82495ac <vfwrite_locked+0x1e4>
   {
      /* compute the size of the buffer to be created */
      /* we round up the size of the data to be written so we dont have
         the overhead of a memory allocation on every write */
      unsigned long buf_size = VFS_ROUND_UP((unsigned long)bcount);
 82494b8:	e0bff717 	ldw	r2,-36(fp)
 82494bc:	10bfffc4 	addi	r2,r2,-1
 82494c0:	1004d37a 	srli	r2,r2,13
 82494c4:	10800044 	addi	r2,r2,1
 82494c8:	1004937a 	slli	r2,r2,13
 82494cc:	e0bff815 	stw	r2,-32(fp)

      /* allocate a buffer of that size */
      vfp->data = vf_alloc_buffer(buf_size);
 82494d0:	e13ff817 	ldw	r4,-32(fp)
 82494d4:	82487d80 	call	82487d8 <vf_alloc_buffer>
 82494d8:	1007883a 	mov	r3,r2
 82494dc:	e0bff617 	ldw	r2,-40(fp)
 82494e0:	10c00615 	stw	r3,24(r2)

      /* if the allocation failed */
      if (!(vfp->data))
 82494e4:	e0bff617 	ldw	r2,-40(fp)
 82494e8:	10800617 	ldw	r2,24(r2)
 82494ec:	1000051e 	bne	r2,zero,8249504 <vfwrite_locked+0x13c>
      {
         vfd->error = ENP_NOMEM;
 82494f0:	e0bfff17 	ldw	r2,-4(fp)
 82494f4:	00fffb04 	movi	r3,-20
 82494f8:	10c00415 	stw	r3,16(r2)
         return 0;
 82494fc:	0005883a 	mov	r2,zero
 8249500:	00009806 	br	8249764 <vfwrite_locked+0x39c>
      }

      /* store the size of the allocated buffer */
      vfp->buf_size = buf_size;
 8249504:	e0bff617 	ldw	r2,-40(fp)
 8249508:	e0fff817 	ldw	r3,-32(fp)
 824950c:	10c00915 	stw	r3,36(r2)

      /* store the number of bytes written in the real and compressed
         file sizes */
      vfp->real_size = bcount;
 8249510:	e0bff617 	ldw	r2,-40(fp)
 8249514:	e0fff717 	ldw	r3,-36(fp)
 8249518:	10c00715 	stw	r3,28(r2)
      vfp->comp_size = bcount;
 824951c:	e0bff617 	ldw	r2,-40(fp)
 8249520:	e0fff717 	ldw	r3,-36(fp)
 8249524:	10c00815 	stw	r3,32(r2)

      /* set the file pointer to the first byte following the last
         byte written */
      vfd->cmploc = vfp->data + bcount;
 8249528:	e0bff617 	ldw	r2,-40(fp)
 824952c:	10c00617 	ldw	r3,24(r2)
 8249530:	e0bff717 	ldw	r2,-36(fp)
 8249534:	1887883a 	add	r3,r3,r2
 8249538:	e0bfff17 	ldw	r2,-4(fp)
 824953c:	10c00215 	stw	r3,8(r2)

      /* turn off the compression flag */
      vfp->flags &= ~VF_HTMLCOMPRESSED;
 8249540:	e0bff617 	ldw	r2,-40(fp)
 8249544:	10c0058b 	ldhu	r3,22(r2)
 8249548:	00bfff84 	movi	r2,-2
 824954c:	1884703a 	and	r2,r3,r2
 8249550:	1007883a 	mov	r3,r2
 8249554:	e0bff617 	ldw	r2,-40(fp)
 8249558:	10c0058d 	sth	r3,22(r2)

      /* the data in the file is stale */
      vfp->flags |= VF_STALE;
 824955c:	e0bff617 	ldw	r2,-40(fp)
 8249560:	1080058b 	ldhu	r2,22(r2)
 8249564:	10808014 	ori	r2,r2,512
 8249568:	1007883a 	mov	r3,r2
 824956c:	e0bff617 	ldw	r2,-40(fp)
 8249570:	10c0058d 	sth	r3,22(r2)

      /* the buffer data was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 8249574:	e0bff617 	ldw	r2,-40(fp)
 8249578:	1080058b 	ldhu	r2,22(r2)
 824957c:	10802014 	ori	r2,r2,128
 8249580:	1007883a 	mov	r3,r2
 8249584:	e0bff617 	ldw	r2,-40(fp)
 8249588:	10c0058d 	sth	r3,22(r2)

      /* copy the data to be written to the file buffer */
      MEMCPY(vfp->data,buf,bcount);
 824958c:	e0bff617 	ldw	r2,-40(fp)
 8249590:	10800617 	ldw	r2,24(r2)
 8249594:	e1bff717 	ldw	r6,-36(fp)
 8249598:	e17ffc17 	ldw	r5,-16(fp)
 824959c:	1009883a 	mov	r4,r2
 82495a0:	8202f6c0 	call	8202f6c <memcpy>

      /* return the number of "items" written */
      return items;
 82495a4:	e0bffe17 	ldw	r2,-8(fp)
 82495a8:	00006e06 	br	8249764 <vfwrite_locked+0x39c>
   }

   /* compute the current offset into the file */
   current_offset = vfd->cmploc - vfp->data;
 82495ac:	e0bfff17 	ldw	r2,-4(fp)
 82495b0:	10800217 	ldw	r2,8(r2)
 82495b4:	1007883a 	mov	r3,r2
 82495b8:	e0bff617 	ldw	r2,-40(fp)
 82495bc:	10800617 	ldw	r2,24(r2)
 82495c0:	1885c83a 	sub	r2,r3,r2
 82495c4:	e0bff915 	stw	r2,-28(fp)

   /* if the data to be written wont fit into the file buffer */
   if ((current_offset + bcount) > vfp->buf_size)
 82495c8:	e0fff917 	ldw	r3,-28(fp)
 82495cc:	e0bff717 	ldw	r2,-36(fp)
 82495d0:	1885883a 	add	r2,r3,r2
 82495d4:	e0fff617 	ldw	r3,-40(fp)
 82495d8:	18c00917 	ldw	r3,36(r3)
 82495dc:	1880382e 	bgeu	r3,r2,82496c0 <vfwrite_locked+0x2f8>
   {
      /* compute the size of a new buffer to hold the data */
      unsigned long new_buf_size = VFS_ROUND_UP(current_offset + bcount);
 82495e0:	e0fff917 	ldw	r3,-28(fp)
 82495e4:	e0bff717 	ldw	r2,-36(fp)
 82495e8:	1885883a 	add	r2,r3,r2
 82495ec:	10bfffc4 	addi	r2,r2,-1
 82495f0:	1004d37a 	srli	r2,r2,13
 82495f4:	10800044 	addi	r2,r2,1
 82495f8:	1004937a 	slli	r2,r2,13
 82495fc:	e0bffa15 	stw	r2,-24(fp)
      unsigned char *new_buffer;

      /* allocate a new buffer */
      new_buffer = vf_alloc_buffer(new_buf_size);
 8249600:	e13ffa17 	ldw	r4,-24(fp)
 8249604:	82487d80 	call	82487d8 <vf_alloc_buffer>
 8249608:	e0bffb15 	stw	r2,-20(fp)

      /* check for allocation failure */
      if (!new_buffer)
 824960c:	e0bffb17 	ldw	r2,-20(fp)
 8249610:	1000051e 	bne	r2,zero,8249628 <vfwrite_locked+0x260>
      {
         vfd->error = ENP_NOMEM;
 8249614:	e0bfff17 	ldw	r2,-4(fp)
 8249618:	00fffb04 	movi	r3,-20
 824961c:	10c00415 	stw	r3,16(r2)
         return 0;
 8249620:	0005883a 	mov	r2,zero
 8249624:	00004f06 	br	8249764 <vfwrite_locked+0x39c>
      }

      /* copy the old buffer contents to the new buffer */
      MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 8249628:	e0bff617 	ldw	r2,-40(fp)
 824962c:	10c00617 	ldw	r3,24(r2)
 8249630:	e0bff617 	ldw	r2,-40(fp)
 8249634:	10800817 	ldw	r2,32(r2)
 8249638:	100d883a 	mov	r6,r2
 824963c:	180b883a 	mov	r5,r3
 8249640:	e13ffb17 	ldw	r4,-20(fp)
 8249644:	8202f6c0 	call	8202f6c <memcpy>

      /* if the old buffer had been dynamically allocated */
      if (vfp->flags & VF_DYNAMICDATA)
 8249648:	e0bff617 	ldw	r2,-40(fp)
 824964c:	1080058b 	ldhu	r2,22(r2)
 8249650:	10bfffcc 	andi	r2,r2,65535
 8249654:	1080200c 	andi	r2,r2,128
 8249658:	10000726 	beq	r2,zero,8249678 <vfwrite_locked+0x2b0>
      {
         /* free it */
         vf_free_buffer(vfp->data,vfp->buf_size);
 824965c:	e0bff617 	ldw	r2,-40(fp)
 8249660:	10c00617 	ldw	r3,24(r2)
 8249664:	e0bff617 	ldw	r2,-40(fp)
 8249668:	10800917 	ldw	r2,36(r2)
 824966c:	100b883a 	mov	r5,r2
 8249670:	1809883a 	mov	r4,r3
 8249674:	82488a00 	call	82488a0 <vf_free_buffer>
      }

      /* store the new buffer in the file structure */
      vfp->data = new_buffer;
 8249678:	e0bff617 	ldw	r2,-40(fp)
 824967c:	e0fffb17 	ldw	r3,-20(fp)
 8249680:	10c00615 	stw	r3,24(r2)

      /* store the new buffer size in the file structure */
      vfp->buf_size = new_buf_size;
 8249684:	e0bff617 	ldw	r2,-40(fp)
 8249688:	e0fffa17 	ldw	r3,-24(fp)
 824968c:	10c00915 	stw	r3,36(r2)

      /* the new buffer was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 8249690:	e0bff617 	ldw	r2,-40(fp)
 8249694:	1080058b 	ldhu	r2,22(r2)
 8249698:	10802014 	ori	r2,r2,128
 824969c:	1007883a 	mov	r3,r2
 82496a0:	e0bff617 	ldw	r2,-40(fp)
 82496a4:	10c0058d 	sth	r3,22(r2)
       * buffer note that this means the VFS does not support 
       * simultaneous opens of the same file, since for that to work, 
       * all the other cmploc's that point to this file would 
       * have to be updated also 
       */
      vfd->cmploc = vfp->data + current_offset;
 82496a8:	e0bff617 	ldw	r2,-40(fp)
 82496ac:	10c00617 	ldw	r3,24(r2)
 82496b0:	e0bff917 	ldw	r2,-28(fp)
 82496b4:	1887883a 	add	r3,r3,r2
 82496b8:	e0bfff17 	ldw	r2,-4(fp)
 82496bc:	10c00215 	stw	r3,8(r2)
   }

   /* copy the data to the current file pointer */
   MEMCPY(vfd->cmploc,buf,bcount);
 82496c0:	e0bfff17 	ldw	r2,-4(fp)
 82496c4:	10800217 	ldw	r2,8(r2)
 82496c8:	e1bff717 	ldw	r6,-36(fp)
 82496cc:	e17ffc17 	ldw	r5,-16(fp)
 82496d0:	1009883a 	mov	r4,r2
 82496d4:	8202f6c0 	call	8202f6c <memcpy>

   /* update the current file pointer */
   vfd->cmploc += bcount;
 82496d8:	e0bfff17 	ldw	r2,-4(fp)
 82496dc:	10c00217 	ldw	r3,8(r2)
 82496e0:	e0bff717 	ldw	r2,-36(fp)
 82496e4:	1887883a 	add	r3,r3,r2
 82496e8:	e0bfff17 	ldw	r2,-4(fp)
 82496ec:	10c00215 	stw	r3,8(r2)

   /* if the resulting current offset is greater than the file size */
   if (current_offset + bcount > vfp->comp_size)
 82496f0:	e0fff917 	ldw	r3,-28(fp)
 82496f4:	e0bff717 	ldw	r2,-36(fp)
 82496f8:	1885883a 	add	r2,r3,r2
 82496fc:	e0fff617 	ldw	r3,-40(fp)
 8249700:	18c00817 	ldw	r3,32(r3)
 8249704:	1880052e 	bgeu	r3,r2,824971c <vfwrite_locked+0x354>
   {
      /* update the "compressed" file size */
      vfp->comp_size = current_offset + bcount;
 8249708:	e0fff917 	ldw	r3,-28(fp)
 824970c:	e0bff717 	ldw	r2,-36(fp)
 8249710:	1887883a 	add	r3,r3,r2
 8249714:	e0bff617 	ldw	r2,-40(fp)
 8249718:	10c00815 	stw	r3,32(r2)
   }

   /* since we turn off the compression bit below, the "real" size and
      the compressed size must be the same */
   vfp->real_size = vfp->comp_size;
 824971c:	e0bff617 	ldw	r2,-40(fp)
 8249720:	10c00817 	ldw	r3,32(r2)
 8249724:	e0bff617 	ldw	r2,-40(fp)
 8249728:	10c00715 	stw	r3,28(r2)

   /* turn off the compression flag */
   vfp->flags &= ~VF_HTMLCOMPRESSED;
 824972c:	e0bff617 	ldw	r2,-40(fp)
 8249730:	10c0058b 	ldhu	r3,22(r2)
 8249734:	00bfff84 	movi	r2,-2
 8249738:	1884703a 	and	r2,r3,r2
 824973c:	1007883a 	mov	r3,r2
 8249740:	e0bff617 	ldw	r2,-40(fp)
 8249744:	10c0058d 	sth	r3,22(r2)

   /* the data in the file is stale */
   vfp->flags |= VF_STALE;
 8249748:	e0bff617 	ldw	r2,-40(fp)
 824974c:	1080058b 	ldhu	r2,22(r2)
 8249750:	10808014 	ori	r2,r2,512
 8249754:	1007883a 	mov	r3,r2
 8249758:	e0bff617 	ldw	r2,-40(fp)
 824975c:	10c0058d 	sth	r3,22(r2)

   /* return the number of "items" written */
   return items;
 8249760:	e0bffe17 	ldw	r2,-8(fp)

#endif   /* HT_RWVFS */
}
 8249764:	e037883a 	mov	sp,fp
 8249768:	dfc00117 	ldw	ra,4(sp)
 824976c:	df000017 	ldw	fp,0(sp)
 8249770:	dec00204 	addi	sp,sp,8
 8249774:	f800283a 	ret

08249778 <vfwrite>:
 * RETURNS: 
 */

int
vfwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 8249778:	defff904 	addi	sp,sp,-28
 824977c:	dfc00615 	stw	ra,24(sp)
 8249780:	df000515 	stw	fp,20(sp)
 8249784:	df000504 	addi	fp,sp,20
 8249788:	e13ffc15 	stw	r4,-16(fp)
 824978c:	e17ffd15 	stw	r5,-12(fp)
 8249790:	e1bffe15 	stw	r6,-8(fp)
 8249794:	e1ffff15 	stw	r7,-4(fp)
   int   rc;

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 8249798:	01000144 	movi	r4,5
 824979c:	822dc040 	call	822dc04 <wait_app_sem>

   /* do the write */
   rc = vfwrite_locked(buf, size, items, vfd);
 82497a0:	e1ffff17 	ldw	r7,-4(fp)
 82497a4:	e1bffe17 	ldw	r6,-8(fp)
 82497a8:	e17ffd17 	ldw	r5,-12(fp)
 82497ac:	e13ffc17 	ldw	r4,-16(fp)
 82497b0:	82493c80 	call	82493c8 <vfwrite_locked>
 82497b4:	e0bffb15 	stw	r2,-20(fp)

   /* unlock the VFS */
   vfs_unlock();
 82497b8:	01000144 	movi	r4,5
 82497bc:	822dcc00 	call	822dcc0 <post_app_sem>

   IN_PROFILER(PF_FS, PF_EXIT);

   return rc;
 82497c0:	e0bffb17 	ldw	r2,-20(fp)
}
 82497c4:	e037883a 	mov	sp,fp
 82497c8:	dfc00117 	ldw	ra,4(sp)
 82497cc:	df000017 	ldw	fp,0(sp)
 82497d0:	dec00204 	addi	sp,sp,8
 82497d4:	f800283a 	ret

082497d8 <vfseek>:
 * RETURNS: 
 */

int 
vfseek(VFILE * vfd, long offset, int mode)
{
 82497d8:	defff904 	addi	sp,sp,-28
 82497dc:	dfc00615 	stw	ra,24(sp)
 82497e0:	df000515 	stw	fp,20(sp)
 82497e4:	df000504 	addi	fp,sp,20
 82497e8:	e13ffd15 	stw	r4,-12(fp)
 82497ec:	e17ffe15 	stw	r5,-8(fp)
 82497f0:	e1bfff15 	stw	r6,-4(fp)
   /* lock the VFS */
   vfs_lock();
 82497f4:	01000144 	movi	r4,5
 82497f8:	822dc040 	call	822dc04 <wait_app_sem>

   if (isvfile_locked(vfd))
 82497fc:	e13ffd17 	ldw	r4,-12(fp)
 8249800:	8249eac0 	call	8249eac <isvfile_locked>
 8249804:	10003f26 	beq	r2,zero,8249904 <vfseek+0x12c>
   {
#ifdef HT_RWVFS
      /* the caller is trying to seek a file that's been deleted,
         so return an error indication */
      if (vfd->file == NULL)
 8249808:	e0bffd17 	ldw	r2,-12(fp)
 824980c:	10800117 	ldw	r2,4(r2)
 8249810:	1000041e 	bne	r2,zero,8249824 <vfseek+0x4c>
      {
         vfs_unlock();
 8249814:	01000144 	movi	r4,5
 8249818:	822dcc00 	call	822dcc0 <post_app_sem>
         return -1;
 824981c:	00bfffc4 	movi	r2,-1
 8249820:	00003b06 	br	8249910 <vfseek+0x138>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 8249824:	e0bffd17 	ldw	r2,-12(fp)
 8249828:	10800117 	ldw	r2,4(r2)
 824982c:	10800a17 	ldw	r2,40(r2)
 8249830:	10000f26 	beq	r2,zero,8249870 <vfseek+0x98>
      {
         struct vfroutines *vfp = (struct vfroutines*)(vfd->file->method);
 8249834:	e0bffd17 	ldw	r2,-12(fp)
 8249838:	10800117 	ldw	r2,4(r2)
 824983c:	10800a17 	ldw	r2,40(r2)
 8249840:	e0bffb15 	stw	r2,-20(fp)
         int   rc;

         rc = vfp->r_fseek(vfd, offset, mode);
 8249844:	e0bffb17 	ldw	r2,-20(fp)
 8249848:	10800517 	ldw	r2,20(r2)
 824984c:	e1bfff17 	ldw	r6,-4(fp)
 8249850:	e17ffe17 	ldw	r5,-8(fp)
 8249854:	e13ffd17 	ldw	r4,-12(fp)
 8249858:	103ee83a 	callr	r2
 824985c:	e0bffc15 	stw	r2,-16(fp)
         vfs_unlock();
 8249860:	01000144 	movi	r4,5
 8249864:	822dcc00 	call	822dcc0 <post_app_sem>
         return rc;
 8249868:	e0bffc17 	ldw	r2,-16(fp)
 824986c:	00002806 	br	8249910 <vfseek+0x138>
      }
#endif   /* HT_EXTDEV */
      /* this vfseek() currently only supports seek to exact
         end or begining of file */
      switch (mode)
 8249870:	e0bfff17 	ldw	r2,-4(fp)
 8249874:	10c00060 	cmpeqi	r3,r2,1
 8249878:	18000b1e 	bne	r3,zero,82498a8 <vfseek+0xd0>
 824987c:	10c000a0 	cmpeqi	r3,r2,2
 8249880:	1800101e 	bne	r3,zero,82498c4 <vfseek+0xec>
 8249884:	10001b1e 	bne	r2,zero,82498f4 <vfseek+0x11c>
      {
      case SEEK_SET:
         vfd->cmploc = vfd->file->data + offset;
 8249888:	e0bffd17 	ldw	r2,-12(fp)
 824988c:	10800117 	ldw	r2,4(r2)
 8249890:	10c00617 	ldw	r3,24(r2)
 8249894:	e0bffe17 	ldw	r2,-8(fp)
 8249898:	1887883a 	add	r3,r3,r2
 824989c:	e0bffd17 	ldw	r2,-12(fp)
 82498a0:	10c00215 	stw	r3,8(r2)
         break;
 82498a4:	00001306 	br	82498f4 <vfseek+0x11c>
      case SEEK_CUR:
         /* If the file is compressed, then the following
          * adjustment is inaccurate. Currently we don't have
          * any scenario where this happens. - handle later */
         vfd->cmploc += offset; 
 82498a8:	e0bffd17 	ldw	r2,-12(fp)
 82498ac:	10c00217 	ldw	r3,8(r2)
 82498b0:	e0bffe17 	ldw	r2,-8(fp)
 82498b4:	1887883a 	add	r3,r3,r2
 82498b8:	e0bffd17 	ldw	r2,-12(fp)
 82498bc:	10c00215 	stw	r3,8(r2)
         break;
 82498c0:	00000c06 	br	82498f4 <vfseek+0x11c>
      case SEEK_END:
         vfd->cmploc = vfd->file->data + vfd->file->comp_size + offset;
 82498c4:	e0bffd17 	ldw	r2,-12(fp)
 82498c8:	10800117 	ldw	r2,4(r2)
 82498cc:	10c00617 	ldw	r3,24(r2)
 82498d0:	e0bffd17 	ldw	r2,-12(fp)
 82498d4:	10800117 	ldw	r2,4(r2)
 82498d8:	11000817 	ldw	r4,32(r2)
 82498dc:	e0bffe17 	ldw	r2,-8(fp)
 82498e0:	2085883a 	add	r2,r4,r2
 82498e4:	1887883a 	add	r3,r3,r2
 82498e8:	e0bffd17 	ldw	r2,-12(fp)
 82498ec:	10c00215 	stw	r3,8(r2)
         break;
 82498f0:	0001883a 	nop
      }
      vfs_unlock();
 82498f4:	01000144 	movi	r4,5
 82498f8:	822dcc00 	call	822dcc0 <post_app_sem>
      return(0);
 82498fc:	0005883a 	mov	r2,zero
 8249900:	00000306 	br	8249910 <vfseek+0x138>
   }

   vfs_unlock();
 8249904:	01000144 	movi	r4,5
 8249908:	822dcc00 	call	822dcc0 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fseek((FILE*)vfd, offset, mode));
#else
   return -1;
 824990c:	00bfffc4 	movi	r2,-1
#endif   /* HT_LOCALFS */
}
 8249910:	e037883a 	mov	sp,fp
 8249914:	dfc00117 	ldw	ra,4(sp)
 8249918:	df000017 	ldw	fp,0(sp)
 824991c:	dec00204 	addi	sp,sp,8
 8249920:	f800283a 	ret

08249924 <vftell>:
 * RETURNS: 
 */

long
vftell(VFILE * vfd)
{
 8249924:	defffb04 	addi	sp,sp,-20
 8249928:	dfc00415 	stw	ra,16(sp)
 824992c:	df000315 	stw	fp,12(sp)
 8249930:	df000304 	addi	fp,sp,12
 8249934:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 8249938:	01000144 	movi	r4,5
 824993c:	822dc040 	call	822dc04 <wait_app_sem>

   if (isvfile_locked(vfd))
 8249940:	e13fff17 	ldw	r4,-4(fp)
 8249944:	8249eac0 	call	8249eac <isvfile_locked>
 8249948:	10003226 	beq	r2,zero,8249a14 <vftell+0xf0>
   {
#ifdef HT_RWVFS
      /* the caller is trying to ftell a deleted file,
         so return an error condition */
      if (vfd->file == NULL)
 824994c:	e0bfff17 	ldw	r2,-4(fp)
 8249950:	10800117 	ldw	r2,4(r2)
 8249954:	1000041e 	bne	r2,zero,8249968 <vftell+0x44>
      {
         vfs_unlock();
 8249958:	01000144 	movi	r4,5
 824995c:	822dcc00 	call	822dcc0 <post_app_sem>
         return -1;
 8249960:	00bfffc4 	movi	r2,-1
 8249964:	00002e06 	br	8249a20 <vftell+0xfc>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 8249968:	e0bfff17 	ldw	r2,-4(fp)
 824996c:	10800117 	ldw	r2,4(r2)
 8249970:	10800a17 	ldw	r2,40(r2)
 8249974:	10000d26 	beq	r2,zero,82499ac <vftell+0x88>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 8249978:	e0bfff17 	ldw	r2,-4(fp)
 824997c:	10800117 	ldw	r2,4(r2)
 8249980:	10800a17 	ldw	r2,40(r2)
 8249984:	e0bffd15 	stw	r2,-12(fp)
         long  rc;

         rc = vfp->r_ftell(vfd);
 8249988:	e0bffd17 	ldw	r2,-12(fp)
 824998c:	10800617 	ldw	r2,24(r2)
 8249990:	e13fff17 	ldw	r4,-4(fp)
 8249994:	103ee83a 	callr	r2
 8249998:	e0bffe15 	stw	r2,-8(fp)
         vfs_unlock();
 824999c:	01000144 	movi	r4,5
 82499a0:	822dcc00 	call	822dcc0 <post_app_sem>
         return rc;
 82499a4:	e0bffe17 	ldw	r2,-8(fp)
 82499a8:	00001d06 	br	8249a20 <vftell+0xfc>
      }
#endif   /* HT_EXTDEV */
      /* if file has been fseeked to end, return uncompressed size.
         else return current location in compression stream */
      if (vfd->cmploc == vfd->file->data + vfd->file->comp_size)
 82499ac:	e0bfff17 	ldw	r2,-4(fp)
 82499b0:	10c00217 	ldw	r3,8(r2)
 82499b4:	e0bfff17 	ldw	r2,-4(fp)
 82499b8:	10800117 	ldw	r2,4(r2)
 82499bc:	11000617 	ldw	r4,24(r2)
 82499c0:	e0bfff17 	ldw	r2,-4(fp)
 82499c4:	10800117 	ldw	r2,4(r2)
 82499c8:	10800817 	ldw	r2,32(r2)
 82499cc:	2085883a 	add	r2,r4,r2
 82499d0:	1880061e 	bne	r3,r2,82499ec <vftell+0xc8>
      {
         vfs_unlock();
 82499d4:	01000144 	movi	r4,5
 82499d8:	822dcc00 	call	822dcc0 <post_app_sem>

         return vfd->file->comp_size;
 82499dc:	e0bfff17 	ldw	r2,-4(fp)
 82499e0:	10800117 	ldw	r2,4(r2)
 82499e4:	10800817 	ldw	r2,32(r2)
 82499e8:	00000d06 	br	8249a20 <vftell+0xfc>
      }
      else
      {
         vfs_unlock();
 82499ec:	01000144 	movi	r4,5
 82499f0:	822dcc00 	call	822dcc0 <post_app_sem>

         return (vfd->cmploc - vfd->file->data);
 82499f4:	e0bfff17 	ldw	r2,-4(fp)
 82499f8:	10800217 	ldw	r2,8(r2)
 82499fc:	1007883a 	mov	r3,r2
 8249a00:	e0bfff17 	ldw	r2,-4(fp)
 8249a04:	10800117 	ldw	r2,4(r2)
 8249a08:	10800617 	ldw	r2,24(r2)
 8249a0c:	1885c83a 	sub	r2,r3,r2
 8249a10:	00000306 	br	8249a20 <vftell+0xfc>
      }
   }

   vfs_unlock();
 8249a14:	01000144 	movi	r4,5
 8249a18:	822dcc00 	call	822dcc0 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(ftell((FILE*)vfd));
#else
   return EBADF;
 8249a1c:	00800244 	movi	r2,9
#endif   /* HT_LOCALFS */
}
 8249a20:	e037883a 	mov	sp,fp
 8249a24:	dfc00117 	ldw	ra,4(sp)
 8249a28:	df000017 	ldw	fp,0(sp)
 8249a2c:	dec00204 	addi	sp,sp,8
 8249a30:	f800283a 	ret

08249a34 <vgetc_locked>:
 * RETURNS: 
 */

int
vgetc_locked(VFILE * vfd)
{
 8249a34:	defffb04 	addi	sp,sp,-20
 8249a38:	dfc00415 	stw	ra,16(sp)
 8249a3c:	df000315 	stw	fp,12(sp)
 8249a40:	df000304 	addi	fp,sp,12
 8249a44:	e13fff15 	stw	r4,-4(fp)
   int   chr;

   if (isvfile_locked(vfd))
 8249a48:	e13fff17 	ldw	r4,-4(fp)
 8249a4c:	8249eac0 	call	8249eac <isvfile_locked>
 8249a50:	10002f26 	beq	r2,zero,8249b10 <vgetc_locked+0xdc>
   {
#ifdef HT_RWVFS
      /* the caller is trying to read a file that's been deleted,
         so return an error condition */
      if (vfd->file == NULL)
 8249a54:	e0bfff17 	ldw	r2,-4(fp)
 8249a58:	10800117 	ldw	r2,4(r2)
 8249a5c:	1000021e 	bne	r2,zero,8249a68 <vgetc_locked+0x34>
      {
         return EOF;
 8249a60:	00bfffc4 	movi	r2,-1
 8249a64:	00002c06 	br	8249b18 <vgetc_locked+0xe4>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 8249a68:	e0bfff17 	ldw	r2,-4(fp)
 8249a6c:	10800117 	ldw	r2,4(r2)
 8249a70:	10800a17 	ldw	r2,40(r2)
 8249a74:	10000926 	beq	r2,zero,8249a9c <vgetc_locked+0x68>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 8249a78:	e0bfff17 	ldw	r2,-4(fp)
 8249a7c:	10800117 	ldw	r2,4(r2)
 8249a80:	10800a17 	ldw	r2,40(r2)
 8249a84:	e0bffe15 	stw	r2,-8(fp)
         return (vfp->r_fgetc(vfd));
 8249a88:	e0bffe17 	ldw	r2,-8(fp)
 8249a8c:	10800717 	ldw	r2,28(r2)
 8249a90:	e13fff17 	ldw	r4,-4(fp)
 8249a94:	103ee83a 	callr	r2
 8249a98:	00001f06 	br	8249b18 <vgetc_locked+0xe4>
#endif   /* HT_EXTDEV */

#ifdef HT_RWVFS
      /* a freshly created file might not have a data buffer associated
         with it yet */
      if (vfd->file->data == NULL)
 8249a9c:	e0bfff17 	ldw	r2,-4(fp)
 8249aa0:	10800117 	ldw	r2,4(r2)
 8249aa4:	10800617 	ldw	r2,24(r2)
 8249aa8:	1000021e 	bne	r2,zero,8249ab4 <vgetc_locked+0x80>
         return EOF;
 8249aac:	00bfffc4 	movi	r2,-1
 8249ab0:	00001906 	br	8249b18 <vgetc_locked+0xe4>
      }
      else  /* HTML compression flag not set */
      {
#endif   /* HTML_COMPRESSION */
         /* Check to see if read has advanced to end of file */
         if (vfd->cmploc >= (vfd->file->data + vfd->file->comp_size))
 8249ab4:	e0bfff17 	ldw	r2,-4(fp)
 8249ab8:	10c00217 	ldw	r3,8(r2)
 8249abc:	e0bfff17 	ldw	r2,-4(fp)
 8249ac0:	10800117 	ldw	r2,4(r2)
 8249ac4:	11000617 	ldw	r4,24(r2)
 8249ac8:	e0bfff17 	ldw	r2,-4(fp)
 8249acc:	10800117 	ldw	r2,4(r2)
 8249ad0:	10800817 	ldw	r2,32(r2)
 8249ad4:	2085883a 	add	r2,r4,r2
 8249ad8:	18800336 	bltu	r3,r2,8249ae8 <vgetc_locked+0xb4>
            chr = EOF;
 8249adc:	00bfffc4 	movi	r2,-1
 8249ae0:	e0bffd15 	stw	r2,-12(fp)
 8249ae4:	00000806 	br	8249b08 <vgetc_locked+0xd4>
         else  /* else just get next char to return */
            chr = *(vfd->cmploc++);
 8249ae8:	e0bfff17 	ldw	r2,-4(fp)
 8249aec:	10800217 	ldw	r2,8(r2)
 8249af0:	11000044 	addi	r4,r2,1
 8249af4:	e0ffff17 	ldw	r3,-4(fp)
 8249af8:	19000215 	stw	r4,8(r3)
 8249afc:	10800003 	ldbu	r2,0(r2)
 8249b00:	10803fcc 	andi	r2,r2,255
 8249b04:	e0bffd15 	stw	r2,-12(fp)
#ifdef HTML_COMPRESSION
      }  /* need to close brace form if...else; */
#endif   /* HTML_COMPRESSION */

      return chr;
 8249b08:	e0bffd17 	ldw	r2,-12(fp)
 8249b0c:	00000206 	br	8249b18 <vgetc_locked+0xe4>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(getc((FILE*)vfd));
#else
   dtrap(); /* can this happen? */
 8249b10:	822d5f00 	call	822d5f0 <dtrap>
   return EOF;
 8249b14:	00bfffc4 	movi	r2,-1
#endif   /* HT_LOCALFS */
}
 8249b18:	e037883a 	mov	sp,fp
 8249b1c:	dfc00117 	ldw	ra,4(sp)
 8249b20:	df000017 	ldw	fp,0(sp)
 8249b24:	dec00204 	addi	sp,sp,8
 8249b28:	f800283a 	ret

08249b2c <vgetc>:
 * RETURNS: 
 */

int
vgetc(VFILE * vfd)
{
 8249b2c:	defffc04 	addi	sp,sp,-16
 8249b30:	dfc00315 	stw	ra,12(sp)
 8249b34:	df000215 	stw	fp,8(sp)
 8249b38:	df000204 	addi	fp,sp,8
 8249b3c:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 8249b40:	01000144 	movi	r4,5
 8249b44:	822dc040 	call	822dc04 <wait_app_sem>

   /* get the character */
   rc = vgetc_locked(vfd);
 8249b48:	e13fff17 	ldw	r4,-4(fp)
 8249b4c:	8249a340 	call	8249a34 <vgetc_locked>
 8249b50:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 8249b54:	01000144 	movi	r4,5
 8249b58:	822dcc00 	call	822dcc0 <post_app_sem>
   return rc;
 8249b5c:	e0bffe17 	ldw	r2,-8(fp)
}
 8249b60:	e037883a 	mov	sp,fp
 8249b64:	dfc00117 	ldw	ra,4(sp)
 8249b68:	df000017 	ldw	fp,0(sp)
 8249b6c:	dec00204 	addi	sp,sp,8
 8249b70:	f800283a 	ret

08249b74 <vfslookup_locked>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup_locked(char * name)
{
 8249b74:	defffb04 	addi	sp,sp,-20
 8249b78:	dfc00415 	stw	ra,16(sp)
 8249b7c:	df000315 	stw	fp,12(sp)
 8249b80:	df000304 	addi	fp,sp,12
 8249b84:	e13fff15 	stw	r4,-4(fp)

#ifdef VFS_STRIPPATH
   char *   cp;

   /* If root path is prepended to name, skip past it */
   if (*name == '/' || *name == '\\')
 8249b88:	e0bfff17 	ldw	r2,-4(fp)
 8249b8c:	10800003 	ldbu	r2,0(r2)
 8249b90:	10803fcc 	andi	r2,r2,255
 8249b94:	1080201c 	xori	r2,r2,128
 8249b98:	10bfe004 	addi	r2,r2,-128
 8249b9c:	10800be0 	cmpeqi	r2,r2,47
 8249ba0:	1000071e 	bne	r2,zero,8249bc0 <vfslookup_locked+0x4c>
 8249ba4:	e0bfff17 	ldw	r2,-4(fp)
 8249ba8:	10800003 	ldbu	r2,0(r2)
 8249bac:	10803fcc 	andi	r2,r2,255
 8249bb0:	1080201c 	xori	r2,r2,128
 8249bb4:	10bfe004 	addi	r2,r2,-128
 8249bb8:	10801718 	cmpnei	r2,r2,92
 8249bbc:	1000191e 	bne	r2,zero,8249c24 <vfslookup_locked+0xb0>
   {
      cp = strippath(name);
 8249bc0:	e13fff17 	ldw	r4,-4(fp)
 8249bc4:	8249ce00 	call	8249ce0 <strippath>
 8249bc8:	e0bffe15 	stw	r2,-8(fp)

      if (!cp) /* strippath coundn't match our path */
 8249bcc:	e0bffe17 	ldw	r2,-8(fp)
 8249bd0:	1000121e 	bne	r2,zero,8249c1c <vfslookup_locked+0xa8>
      {
         /* Files like "/hub47.gif" need to be taken care of */
         if (*name == '/' || *name == '\\')
 8249bd4:	e0bfff17 	ldw	r2,-4(fp)
 8249bd8:	10800003 	ldbu	r2,0(r2)
 8249bdc:	10803fcc 	andi	r2,r2,255
 8249be0:	1080201c 	xori	r2,r2,128
 8249be4:	10bfe004 	addi	r2,r2,-128
 8249be8:	10800be0 	cmpeqi	r2,r2,47
 8249bec:	1000071e 	bne	r2,zero,8249c0c <vfslookup_locked+0x98>
 8249bf0:	e0bfff17 	ldw	r2,-4(fp)
 8249bf4:	10800003 	ldbu	r2,0(r2)
 8249bf8:	10803fcc 	andi	r2,r2,255
 8249bfc:	1080201c 	xori	r2,r2,128
 8249c00:	10bfe004 	addi	r2,r2,-128
 8249c04:	10801718 	cmpnei	r2,r2,92
 8249c08:	1000061e 	bne	r2,zero,8249c24 <vfslookup_locked+0xb0>
            name++;
 8249c0c:	e0bfff17 	ldw	r2,-4(fp)
 8249c10:	10800044 	addi	r2,r2,1
 8249c14:	e0bfff15 	stw	r2,-4(fp)
 8249c18:	00000206 	br	8249c24 <vfslookup_locked+0xb0>
      }
      else
         name = cp ;
 8249c1c:	e0bffe17 	ldw	r2,-8(fp)
 8249c20:	e0bfff15 	stw	r2,-4(fp)
   }
#endif   /* VFS_STRIPPATH */

   /* see if there is a question mark in the file name */
   if (strchr(name,'?'))
 8249c24:	01400fc4 	movi	r5,63
 8249c28:	e13fff17 	ldw	r4,-4(fp)
 8249c2c:	82037e00 	call	82037e0 <strchr>
 8249c30:	10000326 	beq	r2,zero,8249c40 <vfslookup_locked+0xcc>
   {
      dtrap(); /* is this still allowed? */
 8249c34:	822d5f00 	call	822d5f0 <dtrap>
      return NULL;
 8249c38:	0005883a 	mov	r2,zero
 8249c3c:	00001106 	br	8249c84 <vfslookup_locked+0x110>
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 8249c40:	d0a0d617 	ldw	r2,-31912(gp)
 8249c44:	e0bffd15 	stw	r2,-12(fp)
 8249c48:	00000b06 	br	8249c78 <vfslookup_locked+0x104>
   {
      if (strcmp(name, vp->name) == 0)
 8249c4c:	e0bffd17 	ldw	r2,-12(fp)
 8249c50:	10800104 	addi	r2,r2,4
 8249c54:	100b883a 	mov	r5,r2
 8249c58:	e13fff17 	ldw	r4,-4(fp)
 8249c5c:	820e0080 	call	820e008 <strcmp>
 8249c60:	1000021e 	bne	r2,zero,8249c6c <vfslookup_locked+0xf8>
         return vp;
 8249c64:	e0bffd17 	ldw	r2,-12(fp)
 8249c68:	00000606 	br	8249c84 <vfslookup_locked+0x110>
   {
      dtrap(); /* is this still allowed? */
      return NULL;
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 8249c6c:	e0bffd17 	ldw	r2,-12(fp)
 8249c70:	10800017 	ldw	r2,0(r2)
 8249c74:	e0bffd15 	stw	r2,-12(fp)
 8249c78:	e0bffd17 	ldw	r2,-12(fp)
 8249c7c:	103ff31e 	bne	r2,zero,8249c4c <vfslookup_locked+0xd8>
   {
      if (strcmp(name, vp->name) == 0)
         return vp;
   }

   return NULL;   /* fall to here if not found in for loop */
 8249c80:	0005883a 	mov	r2,zero
}
 8249c84:	e037883a 	mov	sp,fp
 8249c88:	dfc00117 	ldw	ra,4(sp)
 8249c8c:	df000017 	ldw	fp,0(sp)
 8249c90:	dec00204 	addi	sp,sp,8
 8249c94:	f800283a 	ret

08249c98 <vfslookup>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup(char * name) 
{
 8249c98:	defffc04 	addi	sp,sp,-16
 8249c9c:	dfc00315 	stw	ra,12(sp)
 8249ca0:	df000215 	stw	fp,8(sp)
 8249ca4:	df000204 	addi	fp,sp,8
 8249ca8:	e13fff15 	stw	r4,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfslookup() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 8249cac:	01000144 	movi	r4,5
 8249cb0:	822dc040 	call	822dc04 <wait_app_sem>

   /* do the lookup */
   vp = vfslookup_locked(name);
 8249cb4:	e13fff17 	ldw	r4,-4(fp)
 8249cb8:	8249b740 	call	8249b74 <vfslookup_locked>
 8249cbc:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 8249cc0:	01000144 	movi	r4,5
 8249cc4:	822dcc00 	call	822dcc0 <post_app_sem>
   return vp;
 8249cc8:	e0bffe17 	ldw	r2,-8(fp)
}
 8249ccc:	e037883a 	mov	sp,fp
 8249cd0:	dfc00117 	ldw	ra,4(sp)
 8249cd4:	df000017 	ldw	fp,0(sp)
 8249cd8:	dec00204 	addi	sp,sp,8
 8249cdc:	f800283a 	ret

08249ce0 <strippath>:
 * have the http_root_path prepended; or on any error. 
 */

char * 
strippath(char * name)
{
 8249ce0:	defff904 	addi	sp,sp,-28
 8249ce4:	dfc00615 	stw	ra,24(sp)
 8249ce8:	df000515 	stw	fp,20(sp)
 8249cec:	df000504 	addi	fp,sp,20
 8249cf0:	e13fff15 	stw	r4,-4(fp)
   char *   path; /* pointer into system path */
   char *   ptmp; /* another pointer into path */
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
 8249cf4:	e13fff17 	ldw	r4,-4(fp)
 8249cf8:	8228e400 	call	8228e40 <uslash>
 8249cfc:	e0bffc15 	stw	r2,-16(fp)
   path = http_root_path; /* The servers root path, at least one UNIX slash */
 8249d00:	d0a05517 	ldw	r2,-32428(gp)
 8249d04:	e0bffb15 	stw	r2,-20(fp)
   while (*path && *ntmp)
 8249d08:	00003a06 	br	8249df4 <strippath+0x114>
   {
      while (*path == '/') path++;   /* strip leading slash */
 8249d0c:	e0bffb17 	ldw	r2,-20(fp)
 8249d10:	10800044 	addi	r2,r2,1
 8249d14:	e0bffb15 	stw	r2,-20(fp)
 8249d18:	e0bffb17 	ldw	r2,-20(fp)
 8249d1c:	10800003 	ldbu	r2,0(r2)
 8249d20:	10803fcc 	andi	r2,r2,255
 8249d24:	1080201c 	xori	r2,r2,128
 8249d28:	10bfe004 	addi	r2,r2,-128
 8249d2c:	10800be0 	cmpeqi	r2,r2,47
 8249d30:	103ff61e 	bne	r2,zero,8249d0c <strippath+0x2c>
         if (*path == 0)
 8249d34:	e0bffb17 	ldw	r2,-20(fp)
 8249d38:	10800003 	ldbu	r2,0(r2)
 8249d3c:	10803fcc 	andi	r2,r2,255
 8249d40:	1080201c 	xori	r2,r2,128
 8249d44:	10bfe004 	addi	r2,r2,-128
 8249d48:	10003726 	beq	r2,zero,8249e28 <strippath+0x148>
         break;
      /* find number of chars in this directory layer's name */
      ptmp = strchr(path, '/');   /* location of next slash in path */
 8249d4c:	01400bc4 	movi	r5,47
 8249d50:	e13ffb17 	ldw	r4,-20(fp)
 8249d54:	82037e00 	call	82037e0 <strchr>
 8249d58:	e0bffe15 	stw	r2,-8(fp)
      if (ptmp)
 8249d5c:	e0bffe17 	ldw	r2,-8(fp)
 8249d60:	10000526 	beq	r2,zero,8249d78 <strippath+0x98>
         dirlen = ptmp - path;
 8249d64:	e0fffe17 	ldw	r3,-8(fp)
 8249d68:	e0bffb17 	ldw	r2,-20(fp)
 8249d6c:	1885c83a 	sub	r2,r3,r2
 8249d70:	e0bffd15 	stw	r2,-12(fp)
 8249d74:	00000706 	br	8249d94 <strippath+0xb4>
      else
         dirlen = strlen(path);
 8249d78:	e13ffb17 	ldw	r4,-20(fp)
 8249d7c:	8203fbc0 	call	8203fbc <strlen>
 8249d80:	e0bffd15 	stw	r2,-12(fp)

      while (*ntmp == '/') ntmp++;   /* strip leading slash */
 8249d84:	00000306 	br	8249d94 <strippath+0xb4>
 8249d88:	e0bffc17 	ldw	r2,-16(fp)
 8249d8c:	10800044 	addi	r2,r2,1
 8249d90:	e0bffc15 	stw	r2,-16(fp)
 8249d94:	e0bffc17 	ldw	r2,-16(fp)
 8249d98:	10800003 	ldbu	r2,0(r2)
 8249d9c:	10803fcc 	andi	r2,r2,255
 8249da0:	1080201c 	xori	r2,r2,128
 8249da4:	10bfe004 	addi	r2,r2,-128
 8249da8:	10800be0 	cmpeqi	r2,r2,47
 8249dac:	103ff61e 	bne	r2,zero,8249d88 <strippath+0xa8>
         if (strncmp(ntmp, path, dirlen) == 0)
 8249db0:	e0bffd17 	ldw	r2,-12(fp)
 8249db4:	100d883a 	mov	r6,r2
 8249db8:	e17ffb17 	ldw	r5,-20(fp)
 8249dbc:	e13ffc17 	ldw	r4,-16(fp)
 8249dc0:	824b7a40 	call	824b7a4 <strncmp>
 8249dc4:	1000091e 	bne	r2,zero,8249dec <strippath+0x10c>
      {
         path += dirlen;
 8249dc8:	e0bffd17 	ldw	r2,-12(fp)
 8249dcc:	e0fffb17 	ldw	r3,-20(fp)
 8249dd0:	1885883a 	add	r2,r3,r2
 8249dd4:	e0bffb15 	stw	r2,-20(fp)
         ntmp += dirlen;
 8249dd8:	e0bffd17 	ldw	r2,-12(fp)
 8249ddc:	e0fffc17 	ldw	r3,-16(fp)
 8249de0:	1885883a 	add	r2,r3,r2
 8249de4:	e0bffc15 	stw	r2,-16(fp)
 8249de8:	00000206 	br	8249df4 <strippath+0x114>
      }
      else
         return NULL;   /* didn't match */
 8249dec:	0005883a 	mov	r2,zero
 8249df0:	00002906 	br	8249e98 <strippath+0x1b8>
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
   path = http_root_path; /* The servers root path, at least one UNIX slash */
   while (*path && *ntmp)
 8249df4:	e0bffb17 	ldw	r2,-20(fp)
 8249df8:	10800003 	ldbu	r2,0(r2)
 8249dfc:	10803fcc 	andi	r2,r2,255
 8249e00:	1080201c 	xori	r2,r2,128
 8249e04:	10bfe004 	addi	r2,r2,-128
 8249e08:	10000826 	beq	r2,zero,8249e2c <strippath+0x14c>
 8249e0c:	e0bffc17 	ldw	r2,-16(fp)
 8249e10:	10800003 	ldbu	r2,0(r2)
 8249e14:	10803fcc 	andi	r2,r2,255
 8249e18:	1080201c 	xori	r2,r2,128
 8249e1c:	10bfe004 	addi	r2,r2,-128
 8249e20:	103fbd1e 	bne	r2,zero,8249d18 <strippath+0x38>
 8249e24:	00000106 	br	8249e2c <strippath+0x14c>
   {
      while (*path == '/') path++;   /* strip leading slash */
         if (*path == 0)
         break;
 8249e28:	0001883a 	nop
         ntmp += dirlen;
      }
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
 8249e2c:	e0bffb17 	ldw	r2,-20(fp)
 8249e30:	10800003 	ldbu	r2,0(r2)
 8249e34:	10803fcc 	andi	r2,r2,255
 8249e38:	1080201c 	xori	r2,r2,128
 8249e3c:	10bfe004 	addi	r2,r2,-128
 8249e40:	1000141e 	bne	r2,zero,8249e94 <strippath+0x1b4>
   {
      while (*ntmp == '\\' || *ntmp == '/')
 8249e44:	00000306 	br	8249e54 <strippath+0x174>
         ntmp++;
 8249e48:	e0bffc17 	ldw	r2,-16(fp)
 8249e4c:	10800044 	addi	r2,r2,1
 8249e50:	e0bffc15 	stw	r2,-16(fp)
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
   {
      while (*ntmp == '\\' || *ntmp == '/')
 8249e54:	e0bffc17 	ldw	r2,-16(fp)
 8249e58:	10800003 	ldbu	r2,0(r2)
 8249e5c:	10803fcc 	andi	r2,r2,255
 8249e60:	1080201c 	xori	r2,r2,128
 8249e64:	10bfe004 	addi	r2,r2,-128
 8249e68:	10801720 	cmpeqi	r2,r2,92
 8249e6c:	103ff61e 	bne	r2,zero,8249e48 <strippath+0x168>
 8249e70:	e0bffc17 	ldw	r2,-16(fp)
 8249e74:	10800003 	ldbu	r2,0(r2)
 8249e78:	10803fcc 	andi	r2,r2,255
 8249e7c:	1080201c 	xori	r2,r2,128
 8249e80:	10bfe004 	addi	r2,r2,-128
 8249e84:	10800be0 	cmpeqi	r2,r2,47
 8249e88:	103fef1e 	bne	r2,zero,8249e48 <strippath+0x168>
         ntmp++;
      return ntmp;
 8249e8c:	e0bffc17 	ldw	r2,-16(fp)
 8249e90:	00000106 	br	8249e98 <strippath+0x1b8>
   }
   else
      return NULL;
 8249e94:	0005883a 	mov	r2,zero
}
 8249e98:	e037883a 	mov	sp,fp
 8249e9c:	dfc00117 	ldw	ra,4(sp)
 8249ea0:	df000017 	ldw	fp,0(sp)
 8249ea4:	dec00204 	addi	sp,sp,8
 8249ea8:	f800283a 	ret

08249eac <isvfile_locked>:
 * RETURNS: 
 */

int
isvfile_locked(VFILE * vfp)
{
 8249eac:	defffd04 	addi	sp,sp,-12
 8249eb0:	df000215 	stw	fp,8(sp)
 8249eb4:	df000204 	addi	fp,sp,8
 8249eb8:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 8249ebc:	d0a0d517 	ldw	r2,-31916(gp)
 8249ec0:	e0bffe15 	stw	r2,-8(fp)
 8249ec4:	00000806 	br	8249ee8 <isvfile_locked+0x3c>
      if (vtmp == vfp)
 8249ec8:	e0fffe17 	ldw	r3,-8(fp)
 8249ecc:	e0bfff17 	ldw	r2,-4(fp)
 8249ed0:	1880021e 	bne	r3,r2,8249edc <isvfile_locked+0x30>
      return TRUE;
 8249ed4:	00800044 	movi	r2,1
 8249ed8:	00000606 	br	8249ef4 <isvfile_locked+0x48>
int
isvfile_locked(VFILE * vfp)
{
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 8249edc:	e0bffe17 	ldw	r2,-8(fp)
 8249ee0:	10800017 	ldw	r2,0(r2)
 8249ee4:	e0bffe15 	stw	r2,-8(fp)
 8249ee8:	e0bffe17 	ldw	r2,-8(fp)
 8249eec:	103ff61e 	bne	r2,zero,8249ec8 <isvfile_locked+0x1c>
      if (vtmp == vfp)
      return TRUE;

   return FALSE;  /* passed pointer not found in list */
 8249ef0:	0005883a 	mov	r2,zero
}
 8249ef4:	e037883a 	mov	sp,fp
 8249ef8:	df000017 	ldw	fp,0(sp)
 8249efc:	dec00104 	addi	sp,sp,4
 8249f00:	f800283a 	ret

08249f04 <isvfile>:
 * RETURNS: 
 */

int
isvfile(VFILE * vfp)
{
 8249f04:	defffc04 	addi	sp,sp,-16
 8249f08:	dfc00315 	stw	ra,12(sp)
 8249f0c:	df000215 	stw	fp,8(sp)
 8249f10:	df000204 	addi	fp,sp,8
 8249f14:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 8249f18:	01000144 	movi	r4,5
 8249f1c:	822dc040 	call	822dc04 <wait_app_sem>

   /* do the lookup */
   rc = isvfile_locked(vfp);
 8249f20:	e13fff17 	ldw	r4,-4(fp)
 8249f24:	8249eac0 	call	8249eac <isvfile_locked>
 8249f28:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 8249f2c:	01000144 	movi	r4,5
 8249f30:	822dcc00 	call	822dcc0 <post_app_sem>
   return rc;
 8249f34:	e0bffe17 	ldw	r2,-8(fp)
}
 8249f38:	e037883a 	mov	sp,fp
 8249f3c:	dfc00117 	ldw	ra,4(sp)
 8249f40:	df000017 	ldw	fp,0(sp)
 8249f44:	dec00204 	addi	sp,sp,8
 8249f48:	f800283a 	ret

08249f4c <vferror>:
 * RETURNS: 
 */

int
vferror(VFILE * vfd)
{
 8249f4c:	defffd04 	addi	sp,sp,-12
 8249f50:	dfc00215 	stw	ra,8(sp)
 8249f54:	df000115 	stw	fp,4(sp)
 8249f58:	df000104 	addi	fp,sp,4
 8249f5c:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 8249f60:	01000144 	movi	r4,5
 8249f64:	822dc040 	call	822dc04 <wait_app_sem>

   if (isvfile_locked(vfd))
 8249f68:	e13fff17 	ldw	r4,-4(fp)
 8249f6c:	8249eac0 	call	8249eac <isvfile_locked>
 8249f70:	10000526 	beq	r2,zero,8249f88 <vferror+0x3c>
   {
      vfs_unlock();
 8249f74:	01000144 	movi	r4,5
 8249f78:	822dcc00 	call	822dcc0 <post_app_sem>

      return vfd->error;
 8249f7c:	e0bfff17 	ldw	r2,-4(fp)
 8249f80:	10800417 	ldw	r2,16(r2)
 8249f84:	00000306 	br	8249f94 <vferror+0x48>
   }

   vfs_unlock();
 8249f88:	01000144 	movi	r4,5
 8249f8c:	822dcc00 	call	822dcc0 <post_app_sem>

#ifdef HT_LOCALFS
   return(ferror((FILE*)vfd));
#else /* not a VFILE, and no local FS */
   return -1;  /* should this be an error? */
 8249f90:	00bfffc4 	movi	r2,-1
#endif   /* HT_LOCALFS */
}
 8249f94:	e037883a 	mov	sp,fp
 8249f98:	dfc00117 	ldw	ra,4(sp)
 8249f9c:	df000017 	ldw	fp,0(sp)
 8249fa0:	dec00204 	addi	sp,sp,8
 8249fa4:	f800283a 	ret

08249fa8 <vclearerr>:
 *
 * RETURNS: 
 */

void vclearerr(VFILE * vfd)
{
 8249fa8:	defffd04 	addi	sp,sp,-12
 8249fac:	dfc00215 	stw	ra,8(sp)
 8249fb0:	df000115 	stw	fp,4(sp)
 8249fb4:	df000104 	addi	fp,sp,4
 8249fb8:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 8249fbc:	01000144 	movi	r4,5
 8249fc0:	822dc040 	call	822dc04 <wait_app_sem>

   if (isvfile_locked(vfd))
 8249fc4:	e13fff17 	ldw	r4,-4(fp)
 8249fc8:	8249eac0 	call	8249eac <isvfile_locked>
 8249fcc:	10000526 	beq	r2,zero,8249fe4 <vclearerr+0x3c>
   {
      vfs_unlock();
 8249fd0:	01000144 	movi	r4,5
 8249fd4:	822dcc00 	call	822dcc0 <post_app_sem>

      vfd->error = 0;
 8249fd8:	e0bfff17 	ldw	r2,-4(fp)
 8249fdc:	10000415 	stw	zero,16(r2)
      return;
 8249fe0:	00000206 	br	8249fec <vclearerr+0x44>
   }

   vfs_unlock();
 8249fe4:	01000144 	movi	r4,5
 8249fe8:	822dcc00 	call	822dcc0 <post_app_sem>

#ifdef HT_LOCALFS
   clearerr((FILE *) vfd);
#endif   /* HT_LOCALFS */
}
 8249fec:	e037883a 	mov	sp,fp
 8249ff0:	dfc00117 	ldw	ra,4(sp)
 8249ff4:	df000017 	ldw	fp,0(sp)
 8249ff8:	dec00204 	addi	sp,sp,8
 8249ffc:	f800283a 	ret

0824a000 <prep_vfs>:
 * PARAMS: NONE
 *
 * RETURNS: Error Code or 0 for OK
 */
int prep_vfs(void)
{
 824a000:	defffe04 	addi	sp,sp,-8
 824a004:	df000115 	stw	fp,4(sp)
 824a008:	df000104 	addi	fp,sp,4
int e = 0;
 824a00c:	e03fff15 	stw	zero,-4(fp)
   {
      dprintf("unable to install VFS NVPARMS, reconfigure nv_formats[]\n");
      dtrap();
   }
#endif   /* INCLUDE_NVPARMS */
   return e;
 824a010:	e0bfff17 	ldw	r2,-4(fp)
}
 824a014:	e037883a 	mov	sp,fp
 824a018:	df000017 	ldw	fp,0(sp)
 824a01c:	dec00104 	addi	sp,sp,4
 824a020:	f800283a 	ret

0824a024 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 824a024:	defffa04 	addi	sp,sp,-24
 824a028:	dfc00515 	stw	ra,20(sp)
 824a02c:	df000415 	stw	fp,16(sp)
 824a030:	df000404 	addi	fp,sp,16
 824a034:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
 824a038:	008000c4 	movi	r2,3
 824a03c:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
 824a040:	e0fffd17 	ldw	r3,-12(fp)
 824a044:	008003f4 	movhi	r2,15
 824a048:	10909004 	addi	r2,r2,16960
 824a04c:	1885383a 	mul	r2,r3,r2
 824a050:	100b883a 	mov	r5,r2
 824a054:	0100bef4 	movhi	r4,763
 824a058:	213c2004 	addi	r4,r4,-3968
 824a05c:	8202c6c0 	call	8202c6c <__udivsi3>
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
 824a060:	100b883a 	mov	r5,r2
 824a064:	01200034 	movhi	r4,32768
 824a068:	213fffc4 	addi	r4,r4,-1
 824a06c:	8202c6c0 	call	8202c6c <__udivsi3>
 824a070:	100b883a 	mov	r5,r2
 824a074:	e13fff17 	ldw	r4,-4(fp)
 824a078:	8202c6c0 	call	8202c6c <__udivsi3>
 824a07c:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 824a080:	e0bffe17 	ldw	r2,-8(fp)
 824a084:	10002a26 	beq	r2,zero,824a130 <alt_busy_sleep+0x10c>
  {
    for(i=0;i<big_loops;i++)
 824a088:	e03ffc15 	stw	zero,-16(fp)
 824a08c:	00001706 	br	824a0ec <alt_busy_sleep+0xc8>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 824a090:	00a00034 	movhi	r2,32768
 824a094:	10bfffc4 	addi	r2,r2,-1
 824a098:	10bfffc4 	addi	r2,r2,-1
 824a09c:	103ffe1e 	bne	r2,zero,824a098 <alt_busy_sleep+0x74>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
 824a0a0:	e0fffd17 	ldw	r3,-12(fp)
 824a0a4:	008003f4 	movhi	r2,15
 824a0a8:	10909004 	addi	r2,r2,16960
 824a0ac:	1885383a 	mul	r2,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 824a0b0:	100b883a 	mov	r5,r2
 824a0b4:	0100bef4 	movhi	r4,763
 824a0b8:	213c2004 	addi	r4,r4,-3968
 824a0bc:	8202c6c0 	call	8202c6c <__udivsi3>
 824a0c0:	100b883a 	mov	r5,r2
 824a0c4:	01200034 	movhi	r4,32768
 824a0c8:	213fffc4 	addi	r4,r4,-1
 824a0cc:	8202c6c0 	call	8202c6c <__udivsi3>
 824a0d0:	1007883a 	mov	r3,r2
 824a0d4:	e0bfff17 	ldw	r2,-4(fp)
 824a0d8:	10c5c83a 	sub	r2,r2,r3
 824a0dc:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 824a0e0:	e0bffc17 	ldw	r2,-16(fp)
 824a0e4:	10800044 	addi	r2,r2,1
 824a0e8:	e0bffc15 	stw	r2,-16(fp)
 824a0ec:	e0fffc17 	ldw	r3,-16(fp)
 824a0f0:	e0bffe17 	ldw	r2,-8(fp)
 824a0f4:	18bfe616 	blt	r3,r2,824a090 <alt_busy_sleep+0x6c>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 824a0f8:	e0fffd17 	ldw	r3,-12(fp)
 824a0fc:	008003f4 	movhi	r2,15
 824a100:	10909004 	addi	r2,r2,16960
 824a104:	1885383a 	mul	r2,r3,r2
 824a108:	100b883a 	mov	r5,r2
 824a10c:	0100bef4 	movhi	r4,763
 824a110:	213c2004 	addi	r4,r4,-3968
 824a114:	8202c6c0 	call	8202c6c <__udivsi3>
 824a118:	1007883a 	mov	r3,r2
 824a11c:	e0bfff17 	ldw	r2,-4(fp)
 824a120:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 824a124:	10bfffc4 	addi	r2,r2,-1
 824a128:	103ffe1e 	bne	r2,zero,824a124 <alt_busy_sleep+0x100>
 824a12c:	00000d06 	br	824a164 <alt_busy_sleep+0x140>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 824a130:	e0fffd17 	ldw	r3,-12(fp)
 824a134:	008003f4 	movhi	r2,15
 824a138:	10909004 	addi	r2,r2,16960
 824a13c:	1885383a 	mul	r2,r3,r2
 824a140:	100b883a 	mov	r5,r2
 824a144:	0100bef4 	movhi	r4,763
 824a148:	213c2004 	addi	r4,r4,-3968
 824a14c:	8202c6c0 	call	8202c6c <__udivsi3>
 824a150:	1007883a 	mov	r3,r2
 824a154:	e0bfff17 	ldw	r2,-4(fp)
 824a158:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 824a15c:	10bfffc4 	addi	r2,r2,-1
 824a160:	00bffe16 	blt	zero,r2,824a15c <alt_busy_sleep+0x138>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 824a164:	0005883a 	mov	r2,zero
}
 824a168:	e037883a 	mov	sp,fp
 824a16c:	dfc00117 	ldw	ra,4(sp)
 824a170:	df000017 	ldw	fp,0(sp)
 824a174:	dec00204 	addi	sp,sp,8
 824a178:	f800283a 	ret

0824a17c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 824a17c:	defffe04 	addi	sp,sp,-8
 824a180:	dfc00115 	stw	ra,4(sp)
 824a184:	df000015 	stw	fp,0(sp)
 824a188:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 824a18c:	d0a04717 	ldw	r2,-32484(gp)
 824a190:	10000326 	beq	r2,zero,824a1a0 <alt_get_errno+0x24>
 824a194:	d0a04717 	ldw	r2,-32484(gp)
 824a198:	103ee83a 	callr	r2
 824a19c:	00000106 	br	824a1a4 <alt_get_errno+0x28>
 824a1a0:	d0a06304 	addi	r2,gp,-32372
}
 824a1a4:	e037883a 	mov	sp,fp
 824a1a8:	dfc00117 	ldw	ra,4(sp)
 824a1ac:	df000017 	ldw	fp,0(sp)
 824a1b0:	dec00204 	addi	sp,sp,8
 824a1b4:	f800283a 	ret

0824a1b8 <alt_fcntl>:
 *
 * ALT_FCNTL is mapped onto the fcntl() system call in alt_syscall.h
 */
 
int ALT_FCNTL (int file, int cmd, ...)
{ 
 824a1b8:	defff704 	addi	sp,sp,-36
 824a1bc:	dfc00615 	stw	ra,24(sp)
 824a1c0:	df000515 	stw	fp,20(sp)
 824a1c4:	df000504 	addi	fp,sp,20
 824a1c8:	e13ffe15 	stw	r4,-8(fp)
 824a1cc:	e17fff15 	stw	r5,-4(fp)
 824a1d0:	e1800215 	stw	r6,8(fp)
 824a1d4:	e1c00315 	stw	r7,12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 824a1d8:	e0bffe17 	ldw	r2,-8(fp)
 824a1dc:	10000616 	blt	r2,zero,824a1f8 <alt_fcntl+0x40>
 824a1e0:	e0bffe17 	ldw	r2,-8(fp)
 824a1e4:	10c00324 	muli	r3,r2,12
 824a1e8:	00820974 	movhi	r2,2085
 824a1ec:	108ef504 	addi	r2,r2,15316
 824a1f0:	1885883a 	add	r2,r3,r2
 824a1f4:	00000106 	br	824a1fc <alt_fcntl+0x44>
 824a1f8:	0005883a 	mov	r2,zero
 824a1fc:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 824a200:	e0bffb17 	ldw	r2,-20(fp)
 824a204:	10002a26 	beq	r2,zero,824a2b0 <alt_fcntl+0xf8>
  {
    switch (cmd)
 824a208:	e0bfff17 	ldw	r2,-4(fp)
 824a20c:	10c000e0 	cmpeqi	r3,r2,3
 824a210:	1800031e 	bne	r3,zero,824a220 <alt_fcntl+0x68>
 824a214:	10800120 	cmpeqi	r2,r2,4
 824a218:	1000071e 	bne	r2,zero,824a238 <alt_fcntl+0x80>
 824a21c:	00001e06 	br	824a298 <alt_fcntl+0xe0>
    {
    case F_GETFL:
      return fd->fd_flags & ~((alt_u32) ALT_FD_FLAGS_MASK);
 824a220:	e0bffb17 	ldw	r2,-20(fp)
 824a224:	10c00217 	ldw	r3,8(r2)
 824a228:	00900034 	movhi	r2,16384
 824a22c:	10bfffc4 	addi	r2,r2,-1
 824a230:	1884703a 	and	r2,r3,r2
 824a234:	00002306 	br	824a2c4 <alt_fcntl+0x10c>
    case F_SETFL:
      va_start(argp, cmd);
 824a238:	e0800204 	addi	r2,fp,8
 824a23c:	e0bffd15 	stw	r2,-12(fp)
      flags = va_arg(argp, long);
 824a240:	e0bffd17 	ldw	r2,-12(fp)
 824a244:	10c00104 	addi	r3,r2,4
 824a248:	e0fffd15 	stw	r3,-12(fp)
 824a24c:	10800017 	ldw	r2,0(r2)
 824a250:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags &= ~ALT_FCNTL_FLAGS_MASK;
 824a254:	e0bffb17 	ldw	r2,-20(fp)
 824a258:	10c00217 	ldw	r3,8(r2)
 824a25c:	00affdc4 	movi	r2,-16393
 824a260:	1886703a 	and	r3,r3,r2
 824a264:	e0bffb17 	ldw	r2,-20(fp)
 824a268:	10c00215 	stw	r3,8(r2)
      fd->fd_flags |= (flags & ALT_FCNTL_FLAGS_MASK);
 824a26c:	e0bffb17 	ldw	r2,-20(fp)
 824a270:	10800217 	ldw	r2,8(r2)
 824a274:	1007883a 	mov	r3,r2
 824a278:	e0bffc17 	ldw	r2,-16(fp)
 824a27c:	1090020c 	andi	r2,r2,16392
 824a280:	1884b03a 	or	r2,r3,r2
 824a284:	1007883a 	mov	r3,r2
 824a288:	e0bffb17 	ldw	r2,-20(fp)
 824a28c:	10c00215 	stw	r3,8(r2)
      va_end(argp);
      return 0;
 824a290:	0005883a 	mov	r2,zero
 824a294:	00000b06 	br	824a2c4 <alt_fcntl+0x10c>
    default:
      ALT_ERRNO = EINVAL;
 824a298:	824a17c0 	call	824a17c <alt_get_errno>
 824a29c:	1007883a 	mov	r3,r2
 824a2a0:	00800584 	movi	r2,22
 824a2a4:	18800015 	stw	r2,0(r3)
      return -1;
 824a2a8:	00bfffc4 	movi	r2,-1
 824a2ac:	00000506 	br	824a2c4 <alt_fcntl+0x10c>
    }
  }

  ALT_ERRNO = EBADFD;
 824a2b0:	824a17c0 	call	824a17c <alt_get_errno>
 824a2b4:	1007883a 	mov	r3,r2
 824a2b8:	00801444 	movi	r2,81
 824a2bc:	18800015 	stw	r2,0(r3)
  return -1;
 824a2c0:	00bfffc4 	movi	r2,-1
}
 824a2c4:	e037883a 	mov	sp,fp
 824a2c8:	dfc00117 	ldw	ra,4(sp)
 824a2cc:	df000017 	ldw	fp,0(sp)
 824a2d0:	dec00404 	addi	sp,sp,16
 824a2d4:	f800283a 	ret

0824a2d8 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 824a2d8:	defffb04 	addi	sp,sp,-20
 824a2dc:	dfc00415 	stw	ra,16(sp)
 824a2e0:	df000315 	stw	fp,12(sp)
 824a2e4:	df000304 	addi	fp,sp,12
 824a2e8:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 824a2ec:	d0a04217 	ldw	r2,-32504(gp)
 824a2f0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 824a2f4:	00003106 	br	824a3bc <alt_find_file+0xe4>
  {
    len = strlen(next->name);
 824a2f8:	e0bffd17 	ldw	r2,-12(fp)
 824a2fc:	10800217 	ldw	r2,8(r2)
 824a300:	1009883a 	mov	r4,r2
 824a304:	8203fbc0 	call	8203fbc <strlen>
 824a308:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 824a30c:	e0bffd17 	ldw	r2,-12(fp)
 824a310:	10c00217 	ldw	r3,8(r2)
 824a314:	e0bffe17 	ldw	r2,-8(fp)
 824a318:	10bfffc4 	addi	r2,r2,-1
 824a31c:	1885883a 	add	r2,r3,r2
 824a320:	10800003 	ldbu	r2,0(r2)
 824a324:	10803fcc 	andi	r2,r2,255
 824a328:	1080201c 	xori	r2,r2,128
 824a32c:	10bfe004 	addi	r2,r2,-128
 824a330:	10800bd8 	cmpnei	r2,r2,47
 824a334:	1000031e 	bne	r2,zero,824a344 <alt_find_file+0x6c>
    {
      len -= 1;
 824a338:	e0bffe17 	ldw	r2,-8(fp)
 824a33c:	10bfffc4 	addi	r2,r2,-1
 824a340:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 824a344:	e0bffe17 	ldw	r2,-8(fp)
 824a348:	e0ffff17 	ldw	r3,-4(fp)
 824a34c:	1885883a 	add	r2,r3,r2
 824a350:	10800003 	ldbu	r2,0(r2)
 824a354:	10803fcc 	andi	r2,r2,255
 824a358:	1080201c 	xori	r2,r2,128
 824a35c:	10bfe004 	addi	r2,r2,-128
 824a360:	10800be0 	cmpeqi	r2,r2,47
 824a364:	1000081e 	bne	r2,zero,824a388 <alt_find_file+0xb0>
 824a368:	e0bffe17 	ldw	r2,-8(fp)
 824a36c:	e0ffff17 	ldw	r3,-4(fp)
 824a370:	1885883a 	add	r2,r3,r2
 824a374:	10800003 	ldbu	r2,0(r2)
 824a378:	10803fcc 	andi	r2,r2,255
 824a37c:	1080201c 	xori	r2,r2,128
 824a380:	10bfe004 	addi	r2,r2,-128
 824a384:	10000a1e 	bne	r2,zero,824a3b0 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
 824a388:	e0bffd17 	ldw	r2,-12(fp)
 824a38c:	10800217 	ldw	r2,8(r2)
 824a390:	e0fffe17 	ldw	r3,-8(fp)
 824a394:	180d883a 	mov	r6,r3
 824a398:	e17fff17 	ldw	r5,-4(fp)
 824a39c:	1009883a 	mov	r4,r2
 824a3a0:	820c6380 	call	820c638 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 824a3a4:	1000021e 	bne	r2,zero,824a3b0 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 824a3a8:	e0bffd17 	ldw	r2,-12(fp)
 824a3ac:	00000706 	br	824a3cc <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
 824a3b0:	e0bffd17 	ldw	r2,-12(fp)
 824a3b4:	10800017 	ldw	r2,0(r2)
 824a3b8:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 824a3bc:	e0fffd17 	ldw	r3,-12(fp)
 824a3c0:	d0a04204 	addi	r2,gp,-32504
 824a3c4:	18bfcc1e 	bne	r3,r2,824a2f8 <alt_find_file+0x20>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 824a3c8:	0005883a 	mov	r2,zero
}
 824a3cc:	e037883a 	mov	sp,fp
 824a3d0:	dfc00117 	ldw	ra,4(sp)
 824a3d4:	df000017 	ldw	fp,0(sp)
 824a3d8:	dec00204 	addi	sp,sp,8
 824a3dc:	f800283a 	ret

0824a3e0 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 824a3e0:	defff904 	addi	sp,sp,-28
 824a3e4:	dfc00615 	stw	ra,24(sp)
 824a3e8:	df000515 	stw	fp,20(sp)
 824a3ec:	df000504 	addi	fp,sp,20
 824a3f0:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
 824a3f4:	00bffa04 	movi	r2,-24
 824a3f8:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
 824a3fc:	d0a0b617 	ldw	r2,-32040(gp)
 824a400:	e0bffd15 	stw	r2,-12(fp)
 824a404:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 824a408:	e0bffe0b 	ldhu	r2,-8(fp)
 824a40c:	e0fffe84 	addi	r3,fp,-6
 824a410:	180d883a 	mov	r6,r3
 824a414:	100b883a 	mov	r5,r2
 824a418:	e13ffd17 	ldw	r4,-12(fp)
 824a41c:	821a1300 	call	821a130 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 824a420:	e03ffb15 	stw	zero,-20(fp)
 824a424:	00001906 	br	824a48c <alt_get_fd+0xac>
  {
    if (!alt_fd_list[i].dev)
 824a428:	00820974 	movhi	r2,2085
 824a42c:	108ef504 	addi	r2,r2,15316
 824a430:	e0fffb17 	ldw	r3,-20(fp)
 824a434:	18c00324 	muli	r3,r3,12
 824a438:	10c5883a 	add	r2,r2,r3
 824a43c:	10800017 	ldw	r2,0(r2)
 824a440:	10000f1e 	bne	r2,zero,824a480 <alt_get_fd+0xa0>
    {
      alt_fd_list[i].dev = dev;
 824a444:	00820974 	movhi	r2,2085
 824a448:	108ef504 	addi	r2,r2,15316
 824a44c:	e0fffb17 	ldw	r3,-20(fp)
 824a450:	18c00324 	muli	r3,r3,12
 824a454:	10c5883a 	add	r2,r2,r3
 824a458:	e0ffff17 	ldw	r3,-4(fp)
 824a45c:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
 824a460:	d0e04617 	ldw	r3,-32488(gp)
 824a464:	e0bffb17 	ldw	r2,-20(fp)
 824a468:	1880020e 	bge	r3,r2,824a474 <alt_get_fd+0x94>
      {
        alt_max_fd = i;
 824a46c:	e0bffb17 	ldw	r2,-20(fp)
 824a470:	d0a04615 	stw	r2,-32488(gp)
      }
      rc = i;
 824a474:	e0bffb17 	ldw	r2,-20(fp)
 824a478:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
 824a47c:	00000606 	br	824a498 <alt_get_fd+0xb8>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 824a480:	e0bffb17 	ldw	r2,-20(fp)
 824a484:	10800044 	addi	r2,r2,1
 824a488:	e0bffb15 	stw	r2,-20(fp)
 824a48c:	e0bffb17 	ldw	r2,-20(fp)
 824a490:	10800810 	cmplti	r2,r2,32
 824a494:	103fe41e 	bne	r2,zero,824a428 <alt_get_fd+0x48>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
 824a498:	d0a0b617 	ldw	r2,-32040(gp)
 824a49c:	1009883a 	mov	r4,r2
 824a4a0:	821a4a80 	call	821a4a8 <OSSemPost>

  return rc;
 824a4a4:	e0bffc17 	ldw	r2,-16(fp)
}
 824a4a8:	e037883a 	mov	sp,fp
 824a4ac:	dfc00117 	ldw	ra,4(sp)
 824a4b0:	df000017 	ldw	fp,0(sp)
 824a4b4:	dec00204 	addi	sp,sp,8
 824a4b8:	f800283a 	ret

0824a4bc <icmprcv>:
};
#endif /* USER_PING_TSTAMP */

int
icmprcv(PACKET p)      /* the incoming packet */
{
 824a4bc:	deffef04 	addi	sp,sp,-68
 824a4c0:	dfc01015 	stw	ra,64(sp)
 824a4c4:	df000f15 	stw	fp,60(sp)
 824a4c8:	dc400e15 	stw	r17,56(sp)
 824a4cc:	dc000d15 	stw	r16,52(sp)
 824a4d0:	df000f04 	addi	fp,sp,60
 824a4d4:	e13ffd15 	stw	r4,-12(fp)
   unsigned short xsum;
#ifdef FULL_ICMP
   struct redirect * rd;
   struct destun *   pdp;
#endif   /* FULL_ICMP */
   char sav_ch = 0;
 824a4d8:	e03ff305 	stb	zero,-52(fp)
   int i;

   icmp_mib.icmpInMsgs++;                 /* received one more icmp */
 824a4dc:	008209b4 	movhi	r2,2086
 824a4e0:	10baa104 	addi	r2,r2,-5500
 824a4e4:	10800017 	ldw	r2,0(r2)
 824a4e8:	10c00044 	addi	r3,r2,1
 824a4ec:	008209b4 	movhi	r2,2086
 824a4f0:	10baa104 	addi	r2,r2,-5500
 824a4f4:	10c00015 	stw	r3,0(r2)

   pip = ip_head(p);                      /* find IP header */
 824a4f8:	e0bffd17 	ldw	r2,-12(fp)
 824a4fc:	10800317 	ldw	r2,12(r2)
 824a500:	e0bff415 	stw	r2,-48(fp)
   len = p->nb_plen - (ip_hlen(pip));     /* strip IP header length */
 824a504:	e0bffd17 	ldw	r2,-12(fp)
 824a508:	10c00417 	ldw	r3,16(r2)
 824a50c:	e0bff417 	ldw	r2,-48(fp)
 824a510:	10800003 	ldbu	r2,0(r2)
 824a514:	10803fcc 	andi	r2,r2,255
 824a518:	108003cc 	andi	r2,r2,15
 824a51c:	1085883a 	add	r2,r2,r2
 824a520:	1085883a 	add	r2,r2,r2
 824a524:	1885c83a 	sub	r2,r3,r2
 824a528:	e0bff515 	stw	r2,-44(fp)
   host = p->fhost;                       /* filled in by IP layer */
 824a52c:	e0bffd17 	ldw	r2,-12(fp)
 824a530:	10800717 	ldw	r2,28(r2)
 824a534:	e0bff615 	stw	r2,-40(fp)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 824a538:	d0a08317 	ldw	r2,-32244(gp)
 824a53c:	1081000c 	andi	r2,r2,1024
 824a540:	10001526 	beq	r2,zero,824a598 <icmprcv+0xdc>
 824a544:	d0a08317 	ldw	r2,-32244(gp)
 824a548:	1080800c 	andi	r2,r2,512
 824a54c:	10001226 	beq	r2,zero,824a598 <icmprcv+0xdc>
      dprintf("ICMP: p[%u] from %u.%u.%u.%u\n", len, PUSH_IPADDR(host));
 824a550:	e0bff617 	ldw	r2,-40(fp)
 824a554:	11003fcc 	andi	r4,r2,255
 824a558:	e0bff617 	ldw	r2,-40(fp)
 824a55c:	1004d23a 	srli	r2,r2,8
 824a560:	11403fcc 	andi	r5,r2,255
 824a564:	e0bff617 	ldw	r2,-40(fp)
 824a568:	1004d43a 	srli	r2,r2,16
 824a56c:	10803fcc 	andi	r2,r2,255
 824a570:	e0fff617 	ldw	r3,-40(fp)
 824a574:	1806d63a 	srli	r3,r3,24
 824a578:	d8c00115 	stw	r3,4(sp)
 824a57c:	d8800015 	stw	r2,0(sp)
 824a580:	280f883a 	mov	r7,r5
 824a584:	200d883a 	mov	r6,r4
 824a588:	e17ff517 	ldw	r5,-44(fp)
 824a58c:	01020974 	movhi	r4,2085
 824a590:	21070e04 	addi	r4,r4,7224
 824a594:	82033fc0 	call	82033fc <printf>
#endif

   e = (struct ping *)ip_data(pip);       /* finally, extract ICMP header */
 824a598:	e0bff417 	ldw	r2,-48(fp)
 824a59c:	10800003 	ldbu	r2,0(r2)
 824a5a0:	10803fcc 	andi	r2,r2,255
 824a5a4:	108003cc 	andi	r2,r2,15
 824a5a8:	1085883a 	add	r2,r2,r2
 824a5ac:	1085883a 	add	r2,r2,r2
 824a5b0:	1007883a 	mov	r3,r2
 824a5b4:	e0bff417 	ldw	r2,-48(fp)
 824a5b8:	10c5883a 	add	r2,r2,r3
 824a5bc:	e0bff715 	stw	r2,-36(fp)

   osum = e->pchksum;
 824a5c0:	e0bff717 	ldw	r2,-36(fp)
 824a5c4:	1080008b 	ldhu	r2,2(r2)
 824a5c8:	e0bff80d 	sth	r2,-32(fp)
   e->pchksum = 0;
 824a5cc:	e0bff717 	ldw	r2,-36(fp)
 824a5d0:	1000008d 	sth	zero,2(r2)

   if (len&1)
 824a5d4:	e0bff517 	ldw	r2,-44(fp)
 824a5d8:	1080004c 	andi	r2,r2,1
 824a5dc:	10000926 	beq	r2,zero,824a604 <icmprcv+0x148>
   {
      sav_ch = *(((char *) e) + len);
 824a5e0:	e0fff717 	ldw	r3,-36(fp)
 824a5e4:	e0bff517 	ldw	r2,-44(fp)
 824a5e8:	1885883a 	add	r2,r3,r2
 824a5ec:	10800003 	ldbu	r2,0(r2)
 824a5f0:	e0bff305 	stb	r2,-52(fp)
      ((char *)e)[len] = 0;
 824a5f4:	e0fff717 	ldw	r3,-36(fp)
 824a5f8:	e0bff517 	ldw	r2,-44(fp)
 824a5fc:	1885883a 	add	r2,r3,r2
 824a600:	10000005 	stb	zero,0(r2)
   }

   xsum = ~cksum(e, (len+1)>>1);
 824a604:	e0bff517 	ldw	r2,-44(fp)
 824a608:	10800044 	addi	r2,r2,1
 824a60c:	1004d07a 	srli	r2,r2,1
 824a610:	100b883a 	mov	r5,r2
 824a614:	e13ff717 	ldw	r4,-36(fp)
 824a618:	82288100 	call	8228810 <cksum>
 824a61c:	0084303a 	nor	r2,zero,r2
 824a620:	e0bff88d 	sth	r2,-30(fp)
   if (len&1) *(((char *) e) + len) = sav_ch;
 824a624:	e0bff517 	ldw	r2,-44(fp)
 824a628:	1080004c 	andi	r2,r2,1
 824a62c:	10000526 	beq	r2,zero,824a644 <icmprcv+0x188>
 824a630:	e0fff717 	ldw	r3,-36(fp)
 824a634:	e0bff517 	ldw	r2,-44(fp)
 824a638:	1885883a 	add	r2,r3,r2
 824a63c:	e0fff303 	ldbu	r3,-52(fp)
 824a640:	10c00005 	stb	r3,0(r2)
   if (xsum != osum)
 824a644:	e0fff88b 	ldhu	r3,-30(fp)
 824a648:	e0bff80b 	ldhu	r2,-32(fp)
 824a64c:	18802426 	beq	r3,r2,824a6e0 <icmprcv+0x224>
   {
      e->pchksum = osum;
 824a650:	e0bff717 	ldw	r2,-36(fp)
 824a654:	e0fff80b 	ldhu	r3,-32(fp)
 824a658:	10c0008d 	sth	r3,2(r2)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 824a65c:	d0a08317 	ldw	r2,-32244(gp)
 824a660:	1081000c 	andi	r2,r2,1024
 824a664:	10000f26 	beq	r2,zero,824a6a4 <icmprcv+0x1e8>
 824a668:	d0a08317 	ldw	r2,-32244(gp)
 824a66c:	1080800c 	andi	r2,r2,512
 824a670:	10000c26 	beq	r2,zero,824a6a4 <icmprcv+0x1e8>
      {
         dprintf("ICMP: Bad xsum %04x should have been %04x\n",
 824a674:	e0bff80b 	ldhu	r2,-32(fp)
 824a678:	e0fff88b 	ldhu	r3,-30(fp)
 824a67c:	180d883a 	mov	r6,r3
 824a680:	100b883a 	mov	r5,r2
 824a684:	01020974 	movhi	r4,2085
 824a688:	21071604 	addi	r4,r4,7256
 824a68c:	82033fc0 	call	82033fc <printf>
          osum, xsum);
         if (NDEBUG & DUMP) ip_dump(p);
 824a690:	d0a08317 	ldw	r2,-32244(gp)
 824a694:	1080008c 	andi	r2,r2,2
 824a698:	10000226 	beq	r2,zero,824a6a4 <icmprcv+0x1e8>
 824a69c:	e13ffd17 	ldw	r4,-12(fp)
 824a6a0:	8240a9c0 	call	8240a9c <ip_dump>
      }
#endif
      icmp_mib.icmpInErrors++;
 824a6a4:	008209b4 	movhi	r2,2086
 824a6a8:	10baa104 	addi	r2,r2,-5500
 824a6ac:	10800117 	ldw	r2,4(r2)
 824a6b0:	10c00044 	addi	r3,r2,1
 824a6b4:	008209b4 	movhi	r2,2086
 824a6b8:	10baa104 	addi	r2,r2,-5500
 824a6bc:	10c00115 	stw	r3,4(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824a6c0:	01000084 	movi	r4,2
 824a6c4:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free(p);
 824a6c8:	e13ffd17 	ldw	r4,-12(fp)
 824a6cc:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824a6d0:	01000084 	movi	r4,2
 824a6d4:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 824a6d8:	00bff804 	movi	r2,-32
 824a6dc:	00024906 	br	824b004 <icmprcv+0xb48>
   }

   e->pchksum = osum;
 824a6e0:	e0bff717 	ldw	r2,-36(fp)
 824a6e4:	e0fff80b 	ldhu	r3,-32(fp)
 824a6e8:	10c0008d 	sth	r3,2(r2)

   switch (e->ptype) 
 824a6ec:	e0bff717 	ldw	r2,-36(fp)
 824a6f0:	10800003 	ldbu	r2,0(r2)
 824a6f4:	10803fcc 	andi	r2,r2,255
 824a6f8:	1080201c 	xori	r2,r2,128
 824a6fc:	10bfe004 	addi	r2,r2,-128
 824a700:	10c00428 	cmpgeui	r3,r2,16
 824a704:	1802251e 	bne	r3,zero,824af9c <icmprcv+0xae0>
 824a708:	100690ba 	slli	r3,r2,2
 824a70c:	00820974 	movhi	r2,2085
 824a710:	10a9c804 	addi	r2,r2,-22752
 824a714:	1885883a 	add	r2,r3,r2
 824a718:	10800017 	ldw	r2,0(r2)
 824a71c:	1000683a 	jmp	r2
 824a720:	0824a9d4 	ori	zero,at,37543
 824a724:	0824af9c 	xori	zero,at,37566
 824a728:	0824af9c 	xori	zero,at,37566
 824a72c:	0824a9fc 	xorhi	zero,at,37543
 824a730:	0824aaf8 	rdprs	zero,at,-27989
 824a734:	0824ab94 	ori	zero,at,37550
 824a738:	0824af9c 	xori	zero,at,37566
 824a73c:	0824af9c 	xori	zero,at,37566
 824a740:	0824a760 	cmpeqi	zero,at,-28003
 824a744:	0824af9c 	xori	zero,at,37566
 824a748:	0824af9c 	xori	zero,at,37566
 824a74c:	0824acc8 	cmpgei	zero,at,-27981
 824a750:	0824add0 	cmplti	zero,at,-27977
 824a754:	0824ae34 	orhi	zero,at,37560
 824a758:	0824af9c 	xori	zero,at,37566
 824a75c:	0824af68 	cmpgeui	zero,at,37565
   {
   case ECHOREQ:  /* got ping request, send reply */
      icmp_mib.icmpInEchos++;
 824a760:	008209b4 	movhi	r2,2086
 824a764:	10baa104 	addi	r2,r2,-5500
 824a768:	10800717 	ldw	r2,28(r2)
 824a76c:	10c00044 	addi	r3,r2,1
 824a770:	008209b4 	movhi	r2,2086
 824a774:	10baa104 	addi	r2,r2,-5500
 824a778:	10c00715 	stw	r3,28(r2)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 824a77c:	d0a08317 	ldw	r2,-32244(gp)
 824a780:	1081000c 	andi	r2,r2,1024
 824a784:	10001426 	beq	r2,zero,824a7d8 <icmprcv+0x31c>
 824a788:	d0a08317 	ldw	r2,-32244(gp)
 824a78c:	1080800c 	andi	r2,r2,512
 824a790:	10001126 	beq	r2,zero,824a7d8 <icmprcv+0x31c>
         dprintf("ICMP: echo reply to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 824a794:	e0bff617 	ldw	r2,-40(fp)
 824a798:	10c03fcc 	andi	r3,r2,255
 824a79c:	e0bff617 	ldw	r2,-40(fp)
 824a7a0:	1004d23a 	srli	r2,r2,8
 824a7a4:	11003fcc 	andi	r4,r2,255
 824a7a8:	e0bff617 	ldw	r2,-40(fp)
 824a7ac:	1004d43a 	srli	r2,r2,16
 824a7b0:	11403fcc 	andi	r5,r2,255
 824a7b4:	e0bff617 	ldw	r2,-40(fp)
 824a7b8:	1004d63a 	srli	r2,r2,24
 824a7bc:	d8800015 	stw	r2,0(sp)
 824a7c0:	280f883a 	mov	r7,r5
 824a7c4:	200d883a 	mov	r6,r4
 824a7c8:	180b883a 	mov	r5,r3
 824a7cc:	01020974 	movhi	r4,2085
 824a7d0:	21072104 	addi	r4,r4,7300
 824a7d4:	82033fc0 	call	82033fc <printf>
#endif
      e->ptype = ECHOREP;
 824a7d8:	e0bff717 	ldw	r2,-36(fp)
 824a7dc:	10000005 	stb	zero,0(r2)
      e->pchksum = 0;
 824a7e0:	e0bff717 	ldw	r2,-36(fp)
 824a7e4:	1000008d 	sth	zero,2(r2)
      if (len&1)  /* pad odd length packets for checksum routine */
 824a7e8:	e0bff517 	ldw	r2,-44(fp)
 824a7ec:	1080004c 	andi	r2,r2,1
 824a7f0:	10000926 	beq	r2,zero,824a818 <icmprcv+0x35c>
      {
         sav_ch = *(((char *) e) + len);
 824a7f4:	e0fff717 	ldw	r3,-36(fp)
 824a7f8:	e0bff517 	ldw	r2,-44(fp)
 824a7fc:	1885883a 	add	r2,r3,r2
 824a800:	10800003 	ldbu	r2,0(r2)
 824a804:	e0bff305 	stb	r2,-52(fp)
         ((char *)e)[len] = 0;
 824a808:	e0fff717 	ldw	r3,-36(fp)
 824a80c:	e0bff517 	ldw	r2,-44(fp)
 824a810:	1885883a 	add	r2,r3,r2
 824a814:	10000005 	stb	zero,0(r2)
      }

      e->pchksum = ~cksum(e, (len+1)>>1);
 824a818:	e0bff517 	ldw	r2,-44(fp)
 824a81c:	10800044 	addi	r2,r2,1
 824a820:	1004d07a 	srli	r2,r2,1
 824a824:	100b883a 	mov	r5,r2
 824a828:	e13ff717 	ldw	r4,-36(fp)
 824a82c:	82288100 	call	8228810 <cksum>
 824a830:	0084303a 	nor	r2,zero,r2
 824a834:	1007883a 	mov	r3,r2
 824a838:	e0bff717 	ldw	r2,-36(fp)
 824a83c:	10c0008d 	sth	r3,2(r2)
      if (len&1) *(((char *) e) + len) = sav_ch;
 824a840:	e0bff517 	ldw	r2,-44(fp)
 824a844:	1080004c 	andi	r2,r2,1
 824a848:	10000526 	beq	r2,zero,824a860 <icmprcv+0x3a4>
 824a84c:	e0fff717 	ldw	r3,-36(fp)
 824a850:	e0bff517 	ldw	r2,-44(fp)
 824a854:	1885883a 	add	r2,r3,r2
 824a858:	e0fff303 	ldbu	r3,-52(fp)
 824a85c:	10c00005 	stb	r3,0(r2)
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 824a860:	e0bff417 	ldw	r2,-48(fp)
 824a864:	10800417 	ldw	r2,16(r2)
 824a868:	10bfffe0 	cmpeqi	r2,r2,-1
 824a86c:	10001f1e 	bne	r2,zero,824a8ec <icmprcv+0x430>
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
 824a870:	e0bff417 	ldw	r2,-48(fp)
 824a874:	10800417 	ldw	r2,16(r2)
 824a878:	1006d63a 	srli	r3,r2,24
 824a87c:	e0bff417 	ldw	r2,-48(fp)
 824a880:	10800417 	ldw	r2,16(r2)
 824a884:	1004d23a 	srli	r2,r2,8
 824a888:	10bfc00c 	andi	r2,r2,65280
 824a88c:	1886b03a 	or	r3,r3,r2
 824a890:	e0bff417 	ldw	r2,-48(fp)
 824a894:	10800417 	ldw	r2,16(r2)
 824a898:	10bfc00c 	andi	r2,r2,65280
 824a89c:	1004923a 	slli	r2,r2,8
 824a8a0:	1886b03a 	or	r3,r3,r2
 824a8a4:	e0bff417 	ldw	r2,-48(fp)
 824a8a8:	10800417 	ldw	r2,16(r2)
 824a8ac:	1004963a 	slli	r2,r2,24
 824a8b0:	1884b03a 	or	r2,r3,r2
 824a8b4:	10fc002c 	andhi	r3,r2,61440
      if (len&1) *(((char *) e) + len) = sav_ch;
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 824a8b8:	00b80034 	movhi	r2,57344
 824a8bc:	18800b26 	beq	r3,r2,824a8ec <icmprcv+0x430>
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
 824a8c0:	e0bff417 	ldw	r2,-48(fp)
 824a8c4:	10c00417 	ldw	r3,16(r2)
 824a8c8:	e0bffd17 	ldw	r2,-12(fp)
 824a8cc:	10800617 	ldw	r2,24(r2)
 824a8d0:	11000a17 	ldw	r4,40(r2)
 824a8d4:	e0bffd17 	ldw	r2,-12(fp)
 824a8d8:	10800617 	ldw	r2,24(r2)
 824a8dc:	10800c17 	ldw	r2,48(r2)
 824a8e0:	0084303a 	nor	r2,zero,r2
 824a8e4:	2084b03a 	or	r2,r4,r2
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
 824a8e8:	1880061e 	bne	r3,r2,824a904 <icmprcv+0x448>
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
      {
         pip->ip_src = p->net->n_ipaddr;
 824a8ec:	e0bffd17 	ldw	r2,-12(fp)
 824a8f0:	10800617 	ldw	r2,24(r2)
 824a8f4:	10c00a17 	ldw	r3,40(r2)
 824a8f8:	e0bff417 	ldw	r2,-48(fp)
 824a8fc:	10c00315 	stw	r3,12(r2)
 824a900:	00000406 	br	824a914 <icmprcv+0x458>
      }
      else pip->ip_src = pip->ip_dest;
 824a904:	e0bff417 	ldw	r2,-48(fp)
 824a908:	10c00417 	ldw	r3,16(r2)
 824a90c:	e0bff417 	ldw	r2,-48(fp)
 824a910:	10c00315 	stw	r3,12(r2)

      pip->ip_dest = host;
 824a914:	e0bff417 	ldw	r2,-48(fp)
 824a918:	e0fff617 	ldw	r3,-40(fp)
 824a91c:	10c00415 	stw	r3,16(r2)
      icmp_mib.icmpOutEchoReps++;
 824a920:	008209b4 	movhi	r2,2086
 824a924:	10baa104 	addi	r2,r2,-5500
 824a928:	10801517 	ldw	r2,84(r2)
 824a92c:	10c00044 	addi	r3,r2,1
 824a930:	008209b4 	movhi	r2,2086
 824a934:	10baa104 	addi	r2,r2,-5500
 824a938:	10c01515 	stw	r3,84(r2)
      icmp_mib.icmpOutMsgs++;
 824a93c:	008209b4 	movhi	r2,2086
 824a940:	10baa104 	addi	r2,r2,-5500
 824a944:	10800d17 	ldw	r2,52(r2)
 824a948:	10c00044 	addi	r3,r2,1
 824a94c:	008209b4 	movhi	r2,2086
 824a950:	10baa104 	addi	r2,r2,-5500
 824a954:	10c00d15 	stw	r3,52(r2)
      p->fhost = host;
 824a958:	e0bffd17 	ldw	r2,-12(fp)
 824a95c:	e0fff617 	ldw	r3,-40(fp)
 824a960:	10c00715 	stw	r3,28(r2)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 824a964:	e0bffd17 	ldw	r2,-12(fp)
 824a968:	10c00317 	ldw	r3,12(r2)
 824a96c:	e0bff417 	ldw	r2,-48(fp)
 824a970:	10800003 	ldbu	r2,0(r2)
 824a974:	10803fcc 	andi	r2,r2,255
 824a978:	108003cc 	andi	r2,r2,15
 824a97c:	1085883a 	add	r2,r2,r2
 824a980:	1085883a 	add	r2,r2,r2
 824a984:	1887883a 	add	r3,r3,r2
 824a988:	e0bffd17 	ldw	r2,-12(fp)
 824a98c:	10c00315 	stw	r3,12(r2)
      p->nb_plen = len;
 824a990:	e0bffd17 	ldw	r2,-12(fp)
 824a994:	e0fff517 	ldw	r3,-44(fp)
 824a998:	10c00415 	stw	r3,16(r2)

      i = ip_write(ICMP_PROT, p);
 824a99c:	e17ffd17 	ldw	r5,-12(fp)
 824a9a0:	01000044 	movi	r4,1
 824a9a4:	823f9a80 	call	823f9a8 <ip_write>
 824a9a8:	e0bff915 	stw	r2,-28(fp)
      if (i < 0)
 824a9ac:	e0bff917 	ldw	r2,-28(fp)
 824a9b0:	1000060e 	bge	r2,zero,824a9cc <icmprcv+0x510>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (UPCTRACE))
 824a9b4:	d0a08317 	ldw	r2,-32244(gp)
 824a9b8:	1081000c 	andi	r2,r2,1024
 824a9bc:	10000326 	beq	r2,zero,824a9cc <icmprcv+0x510>
            dprintf("icmp: reply failed\n");
 824a9c0:	01020974 	movhi	r4,2085
 824a9c4:	21072a04 	addi	r4,r4,7336
 824a9c8:	82036800 	call	8203680 <puts>
#endif
      }
      /* reused p will be freed by net->xxx_send() */
      return 0;
 824a9cc:	0005883a 	mov	r2,zero
 824a9d0:	00018c06 	br	824b004 <icmprcv+0xb48>
   case ECHOREP:
      icmp_mib.icmpInEchoReps++;
 824a9d4:	008209b4 	movhi	r2,2086
 824a9d8:	10baa104 	addi	r2,r2,-5500
 824a9dc:	10800817 	ldw	r2,32(r2)
 824a9e0:	10c00044 	addi	r3,r2,1
 824a9e4:	008209b4 	movhi	r2,2086
 824a9e8:	10baa104 	addi	r2,r2,-5500
 824a9ec:	10c00815 	stw	r3,32(r2)
      
/* 
 * Altera Niche Stack Nios port modification
 */
#if defined(ALT_INICHE) && !defined(PING_APP) && defined(IP_RAW)
      return(ip_raw_input(p));
 824a9f0:	e13ffd17 	ldw	r4,-12(fp)
 824a9f4:	8243ed00 	call	8243ed0 <ip_raw_input>
 824a9f8:	00018206 	br	824b004 <icmprcv+0xb48>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
      return(0);
#endif   /* PING_APP */
#ifdef FULL_ICMP
   case DESTIN:
      icmp_mib.icmpInDestUnreachs++;
 824a9fc:	008209b4 	movhi	r2,2086
 824aa00:	10baa104 	addi	r2,r2,-5500
 824aa04:	10800217 	ldw	r2,8(r2)
 824aa08:	10c00044 	addi	r3,r2,1
 824aa0c:	008209b4 	movhi	r2,2086
 824aa10:	10baa104 	addi	r2,r2,-5500
 824aa14:	10c00215 	stw	r3,8(r2)
      pdp = (struct destun *)e;
 824aa18:	e0bff717 	ldw	r2,-36(fp)
 824aa1c:	e0bffa15 	stw	r2,-24(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824aa20:	d0a08317 	ldw	r2,-32244(gp)
 824aa24:	1081000c 	andi	r2,r2,1024
 824aa28:	10002f26 	beq	r2,zero,824aae8 <icmprcv+0x62c>
      {
         dprintf("ICMP: got dest unreachable type ");
 824aa2c:	01020974 	movhi	r4,2085
 824aa30:	21072f04 	addi	r4,r4,7356
 824aa34:	82033fc0 	call	82033fc <printf>
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824aa38:	e0bffa17 	ldw	r2,-24(fp)
 824aa3c:	10800043 	ldbu	r2,1(r2)
 824aa40:	11003fcc 	andi	r4,r2,255
 824aa44:	2100201c 	xori	r4,r4,128
 824aa48:	213fe004 	addi	r4,r4,-128
          PUSH_IPADDR(pdp->dip.ip_dest));
 824aa4c:	e0bffa17 	ldw	r2,-24(fp)
 824aa50:	10800617 	ldw	r2,24(r2)
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824aa54:	11403fcc 	andi	r5,r2,255
          PUSH_IPADDR(pdp->dip.ip_dest));
 824aa58:	e0bffa17 	ldw	r2,-24(fp)
 824aa5c:	10800617 	ldw	r2,24(r2)
 824aa60:	1004d23a 	srli	r2,r2,8
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824aa64:	11803fcc 	andi	r6,r2,255
          PUSH_IPADDR(pdp->dip.ip_dest));
 824aa68:	e0bffa17 	ldw	r2,-24(fp)
 824aa6c:	10800617 	ldw	r2,24(r2)
 824aa70:	1004d43a 	srli	r2,r2,16
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824aa74:	10803fcc 	andi	r2,r2,255
          PUSH_IPADDR(pdp->dip.ip_dest));
 824aa78:	e0fffa17 	ldw	r3,-24(fp)
 824aa7c:	18c00617 	ldw	r3,24(r3)
 824aa80:	1806d63a 	srli	r3,r3,24
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824aa84:	d8c00115 	stw	r3,4(sp)
 824aa88:	d8800015 	stw	r2,0(sp)
 824aa8c:	300f883a 	mov	r7,r6
 824aa90:	280d883a 	mov	r6,r5
 824aa94:	200b883a 	mov	r5,r4
 824aa98:	01020974 	movhi	r4,2085
 824aa9c:	21073804 	addi	r4,r4,7392
 824aaa0:	82033fc0 	call	82033fc <printf>
          PUSH_IPADDR(pdp->dip.ip_dest));
         dprintf("from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 824aaa4:	e0bff617 	ldw	r2,-40(fp)
 824aaa8:	10c03fcc 	andi	r3,r2,255
 824aaac:	e0bff617 	ldw	r2,-40(fp)
 824aab0:	1004d23a 	srli	r2,r2,8
 824aab4:	11003fcc 	andi	r4,r2,255
 824aab8:	e0bff617 	ldw	r2,-40(fp)
 824aabc:	1004d43a 	srli	r2,r2,16
 824aac0:	11403fcc 	andi	r5,r2,255
 824aac4:	e0bff617 	ldw	r2,-40(fp)
 824aac8:	1004d63a 	srli	r2,r2,24
 824aacc:	d8800015 	stw	r2,0(sp)
 824aad0:	280f883a 	mov	r7,r5
 824aad4:	200d883a 	mov	r6,r4
 824aad8:	180b883a 	mov	r5,r3
 824aadc:	01020974 	movhi	r4,2085
 824aae0:	21073d04 	addi	r4,r4,7412
 824aae4:	82033fc0 	call	82033fc <printf>
      }
#endif   /* NPDEBUG */
      icmp_du(p, pdp);
 824aae8:	e17ffa17 	ldw	r5,-24(fp)
 824aaec:	e13ffd17 	ldw	r4,-12(fp)
 824aaf0:	824b6340 	call	824b634 <icmp_du>
      break;
 824aaf4:	00014206 	br	824b000 <icmprcv+0xb44>
   case SOURCEQ:
      icmp_mib.icmpInSrcQuenchs++;
 824aaf8:	008209b4 	movhi	r2,2086
 824aafc:	10baa104 	addi	r2,r2,-5500
 824ab00:	10800517 	ldw	r2,20(r2)
 824ab04:	10c00044 	addi	r3,r2,1
 824ab08:	008209b4 	movhi	r2,2086
 824ab0c:	10baa104 	addi	r2,r2,-5500
 824ab10:	10c00515 	stw	r3,20(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824ab14:	d0a08317 	ldw	r2,-32244(gp)
 824ab18:	1081000c 	andi	r2,r2,1024
 824ab1c:	10001626 	beq	r2,zero,824ab78 <icmprcv+0x6bc>
      {
         dprintf("ICMP: source quench from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 824ab20:	e0bff617 	ldw	r2,-40(fp)
 824ab24:	10c03fcc 	andi	r3,r2,255
 824ab28:	e0bff617 	ldw	r2,-40(fp)
 824ab2c:	1004d23a 	srli	r2,r2,8
 824ab30:	11003fcc 	andi	r4,r2,255
 824ab34:	e0bff617 	ldw	r2,-40(fp)
 824ab38:	1004d43a 	srli	r2,r2,16
 824ab3c:	11403fcc 	andi	r5,r2,255
 824ab40:	e0bff617 	ldw	r2,-40(fp)
 824ab44:	1004d63a 	srli	r2,r2,24
 824ab48:	d8800015 	stw	r2,0(sp)
 824ab4c:	280f883a 	mov	r7,r5
 824ab50:	200d883a 	mov	r6,r4
 824ab54:	180b883a 	mov	r5,r3
 824ab58:	01020974 	movhi	r4,2085
 824ab5c:	21074204 	addi	r4,r4,7432
 824ab60:	82033fc0 	call	82033fc <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 824ab64:	d0a08317 	ldw	r2,-32244(gp)
 824ab68:	1080008c 	andi	r2,r2,2
 824ab6c:	10000226 	beq	r2,zero,824ab78 <icmprcv+0x6bc>
 824ab70:	e13ffd17 	ldw	r4,-12(fp)
 824ab74:	8240a9c0 	call	8240a9c <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824ab78:	01000084 	movi	r4,2
 824ab7c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free(p);
 824ab80:	e13ffd17 	ldw	r4,-12(fp)
 824ab84:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824ab88:	01000084 	movi	r4,2
 824ab8c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      break;
 824ab90:	00011b06 	br	824b000 <icmprcv+0xb44>
   case REDIR:          /* got an icmp redirect */
      icmp_mib.icmpInRedirects++;
 824ab94:	008209b4 	movhi	r2,2086
 824ab98:	10baa104 	addi	r2,r2,-5500
 824ab9c:	10800617 	ldw	r2,24(r2)
 824aba0:	10c00044 	addi	r3,r2,1
 824aba4:	008209b4 	movhi	r2,2086
 824aba8:	10baa104 	addi	r2,r2,-5500
 824abac:	10c00615 	stw	r3,24(r2)
      rd = (struct redirect *)e;
 824abb0:	e0bff717 	ldw	r2,-36(fp)
 824abb4:	e0bffb15 	stw	r2,-20(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824abb8:	d0a08317 	ldw	r2,-32244(gp)
 824abbc:	1081000c 	andi	r2,r2,1024
 824abc0:	10002a26 	beq	r2,zero,824ac6c <icmprcv+0x7b0>
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
          PUSH_IPADDR(rd->rdip.ip_dest));
 824abc4:	e0bffb17 	ldw	r2,-20(fp)
 824abc8:	10800617 	ldw	r2,24(r2)
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 824abcc:	10c03fcc 	andi	r3,r2,255
          PUSH_IPADDR(rd->rdip.ip_dest));
 824abd0:	e0bffb17 	ldw	r2,-20(fp)
 824abd4:	10800617 	ldw	r2,24(r2)
 824abd8:	1004d23a 	srli	r2,r2,8
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 824abdc:	11003fcc 	andi	r4,r2,255
          PUSH_IPADDR(rd->rdip.ip_dest));
 824abe0:	e0bffb17 	ldw	r2,-20(fp)
 824abe4:	10800617 	ldw	r2,24(r2)
 824abe8:	1004d43a 	srli	r2,r2,16
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 824abec:	11403fcc 	andi	r5,r2,255
          PUSH_IPADDR(rd->rdip.ip_dest));
 824abf0:	e0bffb17 	ldw	r2,-20(fp)
 824abf4:	10800617 	ldw	r2,24(r2)
 824abf8:	1004d63a 	srli	r2,r2,24
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 824abfc:	d8800015 	stw	r2,0(sp)
 824ac00:	280f883a 	mov	r7,r5
 824ac04:	200d883a 	mov	r6,r4
 824ac08:	180b883a 	mov	r5,r3
 824ac0c:	01020974 	movhi	r4,2085
 824ac10:	21074c04 	addi	r4,r4,7472
 824ac14:	82033fc0 	call	82033fc <printf>
          PUSH_IPADDR(rd->rdip.ip_dest));
         dprintf("to %u.%u.%u.%u\n", PUSH_IPADDR(rd->rdgw));
 824ac18:	e0bffb17 	ldw	r2,-20(fp)
 824ac1c:	10800117 	ldw	r2,4(r2)
 824ac20:	10c03fcc 	andi	r3,r2,255
 824ac24:	e0bffb17 	ldw	r2,-20(fp)
 824ac28:	10800117 	ldw	r2,4(r2)
 824ac2c:	1004d23a 	srli	r2,r2,8
 824ac30:	11003fcc 	andi	r4,r2,255
 824ac34:	e0bffb17 	ldw	r2,-20(fp)
 824ac38:	10800117 	ldw	r2,4(r2)
 824ac3c:	1004d43a 	srli	r2,r2,16
 824ac40:	11403fcc 	andi	r5,r2,255
 824ac44:	e0bffb17 	ldw	r2,-20(fp)
 824ac48:	10800117 	ldw	r2,4(r2)
 824ac4c:	1004d63a 	srli	r2,r2,24
 824ac50:	d8800015 	stw	r2,0(sp)
 824ac54:	280f883a 	mov	r7,r5
 824ac58:	200d883a 	mov	r6,r4
 824ac5c:	180b883a 	mov	r5,r3
 824ac60:	01020974 	movhi	r4,2085
 824ac64:	21075604 	addi	r4,r4,7512
 824ac68:	82033fc0 	call	82033fc <printf>
      }
#endif   /* NPDEBUG */
#ifdef IP_ROUTING
      /* try to add/update route table */
      add_route(rd->rdip.ip_dest, 0xFFFFFFFF, rd->rdgw, 
 824ac6c:	e0bffb17 	ldw	r2,-20(fp)
 824ac70:	14000617 	ldw	r16,24(r2)
 824ac74:	e0bffb17 	ldw	r2,-20(fp)
 824ac78:	14400117 	ldw	r17,4(r2)
 824ac7c:	e0bffd17 	ldw	r2,-12(fp)
 824ac80:	10800617 	ldw	r2,24(r2)
 824ac84:	1009883a 	mov	r4,r2
 824ac88:	8226cc40 	call	8226cc4 <if_netnumber>
 824ac8c:	1007883a 	mov	r3,r2
 824ac90:	00800104 	movi	r2,4
 824ac94:	d8800015 	stw	r2,0(sp)
 824ac98:	180f883a 	mov	r7,r3
 824ac9c:	880d883a 	mov	r6,r17
 824aca0:	017fffc4 	movi	r5,-1
 824aca4:	8009883a 	mov	r4,r16
 824aca8:	824438c0 	call	824438c <add_route>
       net_num(p->net), IPRP_ICMP);
#endif   /* IP_ROUTING */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824acac:	01000084 	movi	r4,2
 824acb0:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free(p);
 824acb4:	e13ffd17 	ldw	r4,-12(fp)
 824acb8:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824acbc:	01000084 	movi	r4,2
 824acc0:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      break;
 824acc4:	0000ce06 	br	824b000 <icmprcv+0xb44>
   case TIMEX:
      icmp_mib.icmpInTimeExcds++;
 824acc8:	008209b4 	movhi	r2,2086
 824accc:	10baa104 	addi	r2,r2,-5500
 824acd0:	10800317 	ldw	r2,12(r2)
 824acd4:	10c00044 	addi	r3,r2,1
 824acd8:	008209b4 	movhi	r2,2086
 824acdc:	10baa104 	addi	r2,r2,-5500
 824ace0:	10c00315 	stw	r3,12(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824ace4:	d0a08317 	ldw	r2,-32244(gp)
 824ace8:	1081000c 	andi	r2,r2,1024
 824acec:	10003126 	beq	r2,zero,824adb4 <icmprcv+0x8f8>
      {
         struct timex * pt =  (struct  timex *)e;
 824acf0:	e0bff717 	ldw	r2,-36(fp)
 824acf4:	e0bffc15 	stw	r2,-16(fp)

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
          PUSH_IPADDR(p->fhost));
 824acf8:	e0bffd17 	ldw	r2,-12(fp)
 824acfc:	10800717 	ldw	r2,28(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 824ad00:	10c03fcc 	andi	r3,r2,255
          PUSH_IPADDR(p->fhost));
 824ad04:	e0bffd17 	ldw	r2,-12(fp)
 824ad08:	10800717 	ldw	r2,28(r2)
 824ad0c:	1004d23a 	srli	r2,r2,8
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 824ad10:	11003fcc 	andi	r4,r2,255
          PUSH_IPADDR(p->fhost));
 824ad14:	e0bffd17 	ldw	r2,-12(fp)
 824ad18:	10800717 	ldw	r2,28(r2)
 824ad1c:	1004d43a 	srli	r2,r2,16
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 824ad20:	11403fcc 	andi	r5,r2,255
          PUSH_IPADDR(p->fhost));
 824ad24:	e0bffd17 	ldw	r2,-12(fp)
 824ad28:	10800717 	ldw	r2,28(r2)
 824ad2c:	1004d63a 	srli	r2,r2,24
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 824ad30:	d8800015 	stw	r2,0(sp)
 824ad34:	280f883a 	mov	r7,r5
 824ad38:	200d883a 	mov	r6,r4
 824ad3c:	180b883a 	mov	r5,r3
 824ad40:	01020974 	movhi	r4,2085
 824ad44:	21075a04 	addi	r4,r4,7528
 824ad48:	82033fc0 	call	82033fc <printf>
          PUSH_IPADDR(p->fhost));
         dprintf(" about %u.%u.%u.%u\n", PUSH_IPADDR(pt->tip.ip_dest));
 824ad4c:	e0bffc17 	ldw	r2,-16(fp)
 824ad50:	10800617 	ldw	r2,24(r2)
 824ad54:	10c03fcc 	andi	r3,r2,255
 824ad58:	e0bffc17 	ldw	r2,-16(fp)
 824ad5c:	10800617 	ldw	r2,24(r2)
 824ad60:	1004d23a 	srli	r2,r2,8
 824ad64:	11003fcc 	andi	r4,r2,255
 824ad68:	e0bffc17 	ldw	r2,-16(fp)
 824ad6c:	10800617 	ldw	r2,24(r2)
 824ad70:	1004d43a 	srli	r2,r2,16
 824ad74:	11403fcc 	andi	r5,r2,255
 824ad78:	e0bffc17 	ldw	r2,-16(fp)
 824ad7c:	10800617 	ldw	r2,24(r2)
 824ad80:	1004d63a 	srli	r2,r2,24
 824ad84:	d8800015 	stw	r2,0(sp)
 824ad88:	280f883a 	mov	r7,r5
 824ad8c:	200d883a 	mov	r6,r4
 824ad90:	180b883a 	mov	r5,r3
 824ad94:	01020974 	movhi	r4,2085
 824ad98:	21076304 	addi	r4,r4,7564
 824ad9c:	82033fc0 	call	82033fc <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 824ada0:	d0a08317 	ldw	r2,-32244(gp)
 824ada4:	1080008c 	andi	r2,r2,2
 824ada8:	10000226 	beq	r2,zero,824adb4 <icmprcv+0x8f8>
 824adac:	e13ffd17 	ldw	r4,-12(fp)
 824adb0:	8240a9c0 	call	8240a9c <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824adb4:	01000084 	movi	r4,2
 824adb8:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free(p);
 824adbc:	e13ffd17 	ldw	r4,-12(fp)
 824adc0:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824adc4:	01000084 	movi	r4,2
 824adc8:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      break;
 824adcc:	00008c06 	br	824b000 <icmprcv+0xb44>
   case PARAM:
      icmp_mib.icmpInParmProbs++;
 824add0:	008209b4 	movhi	r2,2086
 824add4:	10baa104 	addi	r2,r2,-5500
 824add8:	10800417 	ldw	r2,16(r2)
 824addc:	10c00044 	addi	r3,r2,1
 824ade0:	008209b4 	movhi	r2,2086
 824ade4:	10baa104 	addi	r2,r2,-5500
 824ade8:	10c00415 	stw	r3,16(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824adec:	d0a08317 	ldw	r2,-32244(gp)
 824adf0:	1081000c 	andi	r2,r2,1024
 824adf4:	10000326 	beq	r2,zero,824ae04 <icmprcv+0x948>
         dprintf("ICMP: got param problem message\n");
 824adf8:	01020974 	movhi	r4,2085
 824adfc:	21076804 	addi	r4,r4,7584
 824ae00:	82036800 	call	8203680 <puts>
      if (NDEBUG & DUMP)
 824ae04:	d0a08317 	ldw	r2,-32244(gp)
 824ae08:	1080008c 	andi	r2,r2,2
 824ae0c:	10000226 	beq	r2,zero,824ae18 <icmprcv+0x95c>
      {
         ip_dump(p);
 824ae10:	e13ffd17 	ldw	r4,-12(fp)
 824ae14:	8240a9c0 	call	8240a9c <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824ae18:	01000084 	movi	r4,2
 824ae1c:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free(p);
 824ae20:	e13ffd17 	ldw	r4,-12(fp)
 824ae24:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824ae28:	01000084 	movi	r4,2
 824ae2c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      break;
 824ae30:	00007306 	br	824b000 <icmprcv+0xb44>
   case TIMEREQ:
      icmp_mib.icmpInTimestamps++;
 824ae34:	008209b4 	movhi	r2,2086
 824ae38:	10baa104 	addi	r2,r2,-5500
 824ae3c:	10800917 	ldw	r2,36(r2)
 824ae40:	10c00044 	addi	r3,r2,1
 824ae44:	008209b4 	movhi	r2,2086
 824ae48:	10baa104 	addi	r2,r2,-5500
 824ae4c:	10c00915 	stw	r3,36(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824ae50:	d0a08317 	ldw	r2,-32244(gp)
 824ae54:	1081000c 	andi	r2,r2,1024
 824ae58:	10000326 	beq	r2,zero,824ae68 <icmprcv+0x9ac>
         dprintf("ICMP: got timestamp request\n");
 824ae5c:	01020974 	movhi	r4,2085
 824ae60:	21077004 	addi	r4,r4,7616
 824ae64:	82036800 	call	8203680 <puts>
#endif   /* NPDEBUG */
      e->ptype = TIMEREP;
 824ae68:	e0bff717 	ldw	r2,-36(fp)
 824ae6c:	00c00384 	movi	r3,14
 824ae70:	10c00005 	stb	r3,0(r2)
      e->pchksum = 0;
 824ae74:	e0bff717 	ldw	r2,-36(fp)
 824ae78:	1000008d 	sth	zero,2(r2)
		   */
		  sstmp->dtstamp[1] = sstmp->dtstamp[2] = user_UTCtime();
	  }
#endif /* USER_PING_TSTAMP */

      e->pchksum = ~cksum(e, sizeof(struct tstamp)>>1);
 824ae7c:	01400284 	movi	r5,10
 824ae80:	e13ff717 	ldw	r4,-36(fp)
 824ae84:	82288100 	call	8228810 <cksum>
 824ae88:	0084303a 	nor	r2,zero,r2
 824ae8c:	1007883a 	mov	r3,r2
 824ae90:	e0bff717 	ldw	r2,-36(fp)
 824ae94:	10c0008d 	sth	r3,2(r2)
      pip->ip_src = pip->ip_dest;
 824ae98:	e0bff417 	ldw	r2,-48(fp)
 824ae9c:	10c00417 	ldw	r3,16(r2)
 824aea0:	e0bff417 	ldw	r2,-48(fp)
 824aea4:	10c00315 	stw	r3,12(r2)
      pip->ip_dest = host;
 824aea8:	e0bff417 	ldw	r2,-48(fp)
 824aeac:	e0fff617 	ldw	r3,-40(fp)
 824aeb0:	10c00415 	stw	r3,16(r2)
      icmp_mib.icmpOutMsgs++;
 824aeb4:	008209b4 	movhi	r2,2086
 824aeb8:	10baa104 	addi	r2,r2,-5500
 824aebc:	10800d17 	ldw	r2,52(r2)
 824aec0:	10c00044 	addi	r3,r2,1
 824aec4:	008209b4 	movhi	r2,2086
 824aec8:	10baa104 	addi	r2,r2,-5500
 824aecc:	10c00d15 	stw	r3,52(r2)
      icmp_mib.icmpOutTimestampReps++;
 824aed0:	008209b4 	movhi	r2,2086
 824aed4:	10baa104 	addi	r2,r2,-5500
 824aed8:	10801717 	ldw	r2,92(r2)
 824aedc:	10c00044 	addi	r3,r2,1
 824aee0:	008209b4 	movhi	r2,2086
 824aee4:	10baa104 	addi	r2,r2,-5500
 824aee8:	10c01715 	stw	r3,92(r2)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 824aeec:	e0bffd17 	ldw	r2,-12(fp)
 824aef0:	10c00317 	ldw	r3,12(r2)
 824aef4:	e0bff417 	ldw	r2,-48(fp)
 824aef8:	10800003 	ldbu	r2,0(r2)
 824aefc:	10803fcc 	andi	r2,r2,255
 824af00:	108003cc 	andi	r2,r2,15
 824af04:	1085883a 	add	r2,r2,r2
 824af08:	1085883a 	add	r2,r2,r2
 824af0c:	1887883a 	add	r3,r3,r2
 824af10:	e0bffd17 	ldw	r2,-12(fp)
 824af14:	10c00315 	stw	r3,12(r2)
      p->nb_plen = sizeof(struct tstamp);
 824af18:	e0bffd17 	ldw	r2,-12(fp)
 824af1c:	00c00504 	movi	r3,20
 824af20:	10c00415 	stw	r3,16(r2)
      p->fhost = host;
 824af24:	e0bffd17 	ldw	r2,-12(fp)
 824af28:	e0fff617 	ldw	r3,-40(fp)
 824af2c:	10c00715 	stw	r3,28(r2)
      i = ip_write(ICMP_PROT, p);
 824af30:	e17ffd17 	ldw	r5,-12(fp)
 824af34:	01000044 	movi	r4,1
 824af38:	823f9a80 	call	823f9a8 <ip_write>
 824af3c:	e0bff915 	stw	r2,-28(fp)
      if (i < 0)
 824af40:	e0bff917 	ldw	r2,-28(fp)
 824af44:	1000060e 	bge	r2,zero,824af60 <icmprcv+0xaa4>
      {
#ifdef   NPDEBUG
         if (NDEBUG & UPCTRACE)
 824af48:	d0a08317 	ldw	r2,-32244(gp)
 824af4c:	1081000c 	andi	r2,r2,1024
 824af50:	10000326 	beq	r2,zero,824af60 <icmprcv+0xaa4>
            dprintf("icmp: can't send timestamp reply\n");
 824af54:	01020974 	movhi	r4,2085
 824af58:	21077704 	addi	r4,r4,7644
 824af5c:	82036800 	call	8203680 <puts>
#endif   /* NPDEBUG */
      }
      /* re-used packet was pk_free()d by net->send() */
      return (0);
 824af60:	0005883a 	mov	r2,zero
 824af64:	00002706 	br	824b004 <icmprcv+0xb48>
   case INFO:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824af68:	d0a08317 	ldw	r2,-32244(gp)
 824af6c:	1081000c 	andi	r2,r2,1024
 824af70:	10000326 	beq	r2,zero,824af80 <icmprcv+0xac4>
         dprintf("icmp: got info request\n");
 824af74:	01020974 	movhi	r4,2085
 824af78:	21078004 	addi	r4,r4,7680
 824af7c:	82036800 	call	8203680 <puts>
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824af80:	01000084 	movi	r4,2
 824af84:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free(p);
 824af88:	e13ffd17 	ldw	r4,-12(fp)
 824af8c:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824af90:	01000084 	movi	r4,2
 824af94:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      break;
 824af98:	00001906 	br	824b000 <icmprcv+0xb44>
#endif   /* FULL_ICMP */
   default:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824af9c:	d0a08317 	ldw	r2,-32244(gp)
 824afa0:	1081000c 	andi	r2,r2,1024
 824afa4:	10000e26 	beq	r2,zero,824afe0 <icmprcv+0xb24>
      {
         dprintf("icmp: unhandled type %u\n", e->ptype);
 824afa8:	e0bff717 	ldw	r2,-36(fp)
 824afac:	10800003 	ldbu	r2,0(r2)
 824afb0:	10803fcc 	andi	r2,r2,255
 824afb4:	1080201c 	xori	r2,r2,128
 824afb8:	10bfe004 	addi	r2,r2,-128
 824afbc:	100b883a 	mov	r5,r2
 824afc0:	01020974 	movhi	r4,2085
 824afc4:	21078604 	addi	r4,r4,7704
 824afc8:	82033fc0 	call	82033fc <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 824afcc:	d0a08317 	ldw	r2,-32244(gp)
 824afd0:	1080008c 	andi	r2,r2,2
 824afd4:	10000226 	beq	r2,zero,824afe0 <icmprcv+0xb24>
 824afd8:	e13ffd17 	ldw	r4,-12(fp)
 824afdc:	8240a9c0 	call	8240a9c <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824afe0:	01000084 	movi	r4,2
 824afe4:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
      pk_free(p);
 824afe8:	e13ffd17 	ldw	r4,-12(fp)
 824afec:	822cd980 	call	822cd98 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824aff0:	01000084 	movi	r4,2
 824aff4:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>
      return ENP_NOT_MINE;
 824aff8:	00800084 	movi	r2,2
 824affc:	00000106 	br	824b004 <icmprcv+0xb48>
   }
#ifdef FULL_ICMP
   return ENP_NOT_MINE;
 824b000:	00800084 	movi	r2,2
#endif   /* FULL_ICMP */
}
 824b004:	e6fffe04 	addi	sp,fp,-8
 824b008:	dfc00317 	ldw	ra,12(sp)
 824b00c:	df000217 	ldw	fp,8(sp)
 824b010:	dc400117 	ldw	r17,4(sp)
 824b014:	dc000017 	ldw	r16,0(sp)
 824b018:	dec00404 	addi	sp,sp,16
 824b01c:	f800283a 	ret

0824b020 <icmp_destun>:
icmp_destun(ip_addr host,  /* host to complain to */
   ip_addr src_addr, /* source address for outgoing ICMP/IP packet header */
   struct ip * ip,   /* IP header of offending packet */
   unsigned typecode,    /* type & code of DU to send (PROT, PORT, HOST) */
   NET   net)        /* interface that this packet came in on */
{
 824b020:	defff404 	addi	sp,sp,-48
 824b024:	dfc00b15 	stw	ra,44(sp)
 824b028:	df000a15 	stw	fp,40(sp)
 824b02c:	df000a04 	addi	fp,sp,40
 824b030:	e13ffc15 	stw	r4,-16(fp)
 824b034:	e17ffd15 	stw	r5,-12(fp)
 824b038:	e1bffe15 	stw	r6,-8(fp)
 824b03c:	e1ffff15 	stw	r7,-4(fp)
   struct destun *   d;
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 824b040:	d0a08317 	ldw	r2,-32244(gp)
 824b044:	1080040c 	andi	r2,r2,16
 824b048:	10001a26 	beq	r2,zero,824b0b4 <icmp_destun+0x94>
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 824b04c:	e0bfff17 	ldw	r2,-4(fp)
 824b050:	10c03fcc 	andi	r3,r2,255
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 824b054:	00820974 	movhi	r2,2085
 824b058:	108fb304 	addi	r2,r2,16076
 824b05c:	18c7883a 	add	r3,r3,r3
 824b060:	18c7883a 	add	r3,r3,r3
 824b064:	10c5883a 	add	r2,r2,r3
 824b068:	11000017 	ldw	r4,0(r2)
 824b06c:	e0bffc17 	ldw	r2,-16(fp)
 824b070:	11403fcc 	andi	r5,r2,255
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 824b074:	e0bffc17 	ldw	r2,-16(fp)
 824b078:	1004d23a 	srli	r2,r2,8
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 824b07c:	11803fcc 	andi	r6,r2,255
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 824b080:	e0bffc17 	ldw	r2,-16(fp)
 824b084:	1004d43a 	srli	r2,r2,16
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 824b088:	10803fcc 	andi	r2,r2,255
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 824b08c:	e0fffc17 	ldw	r3,-16(fp)
 824b090:	1806d63a 	srli	r3,r3,24
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 824b094:	d8c00115 	stw	r3,4(sp)
 824b098:	d8800015 	stw	r2,0(sp)
 824b09c:	300f883a 	mov	r7,r6
 824b0a0:	280d883a 	mov	r6,r5
 824b0a4:	200b883a 	mov	r5,r4
 824b0a8:	01020974 	movhi	r4,2085
 824b0ac:	2107a004 	addi	r4,r4,7808
 824b0b0:	82033fc0 	call	82033fc <printf>
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(FREEQ_RESID);
 824b0b4:	01000084 	movi	r4,2
 824b0b8:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
   p = pk_alloc(512 + IPHSIZ);   /* get packet to send icmp dest unreachable */
 824b0bc:	01008504 	movi	r4,532
 824b0c0:	822ca480 	call	822ca48 <pk_alloc>
 824b0c4:	e0bff815 	stw	r2,-32(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824b0c8:	01000084 	movi	r4,2
 824b0cc:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 824b0d0:	e0bff817 	ldw	r2,-32(fp)
 824b0d4:	10000e1e 	bne	r2,zero,824b110 <icmp_destun+0xf0>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 824b0d8:	d0a08317 	ldw	r2,-32244(gp)
 824b0dc:	1080800c 	andi	r2,r2,512
 824b0e0:	10000326 	beq	r2,zero,824b0f0 <icmp_destun+0xd0>
         dprintf("icmp: can't alloc pkt\n");
 824b0e4:	01020974 	movhi	r4,2085
 824b0e8:	2107ad04 	addi	r4,r4,7860
 824b0ec:	82036800 	call	8203680 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 824b0f0:	008209b4 	movhi	r2,2086
 824b0f4:	10baa104 	addi	r2,r2,-5500
 824b0f8:	10800e17 	ldw	r2,56(r2)
 824b0fc:	10c00044 	addi	r3,r2,1
 824b100:	008209b4 	movhi	r2,2086
 824b104:	10baa104 	addi	r2,r2,-5500
 824b108:	10c00e15 	stw	r3,56(r2)
      return;
 824b10c:	00007f06 	br	824b30c <icmp_destun+0x2ec>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 824b110:	e0bff817 	ldw	r2,-32(fp)
 824b114:	10800317 	ldw	r2,12(r2)
 824b118:	e0bff915 	stw	r2,-28(fp)
   pip->ip_src = src_addr;
 824b11c:	e0bff917 	ldw	r2,-28(fp)
 824b120:	e0fffd17 	ldw	r3,-12(fp)
 824b124:	10c00315 	stw	r3,12(r2)
   pip->ip_dest = host;
 824b128:	e0bff917 	ldw	r2,-28(fp)
 824b12c:	e0fffc17 	ldw	r3,-16(fp)
 824b130:	10c00415 	stw	r3,16(r2)

   /* allow space for icmp header */
   p->nb_prot += sizeof(struct ip);
 824b134:	e0bff817 	ldw	r2,-32(fp)
 824b138:	10800317 	ldw	r2,12(r2)
 824b13c:	10c00504 	addi	r3,r2,20
 824b140:	e0bff817 	ldw	r2,-32(fp)
 824b144:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= sizeof(struct ip);
 824b148:	e0bff817 	ldw	r2,-32(fp)
 824b14c:	10800417 	ldw	r2,16(r2)
 824b150:	10fffb04 	addi	r3,r2,-20
 824b154:	e0bff817 	ldw	r2,-32(fp)
 824b158:	10c00415 	stw	r3,16(r2)
   p->net = net;     /* Put in the interface that this packet came in on */
 824b15c:	e0bff817 	ldw	r2,-32(fp)
 824b160:	e0c00217 	ldw	r3,8(fp)
 824b164:	10c00615 	stw	r3,24(r2)

   d = (struct destun *)p->nb_prot;
 824b168:	e0bff817 	ldw	r2,-32(fp)
 824b16c:	10800317 	ldw	r2,12(r2)
 824b170:	e0bffa15 	stw	r2,-24(fp)

   if (typecode & 0xFF00)               /* if the type was sent */
 824b174:	e0bfff17 	ldw	r2,-4(fp)
 824b178:	10bfc00c 	andi	r2,r2,65280
 824b17c:	10000626 	beq	r2,zero,824b198 <icmp_destun+0x178>
      d->dtype = (char)(typecode >>8);  /* then use it */
 824b180:	e0bfff17 	ldw	r2,-4(fp)
 824b184:	1004d23a 	srli	r2,r2,8
 824b188:	1007883a 	mov	r3,r2
 824b18c:	e0bffa17 	ldw	r2,-24(fp)
 824b190:	10c00005 	stb	r3,0(r2)
 824b194:	00000306 	br	824b1a4 <icmp_destun+0x184>
   else                                 /* else use default */
      d->dtype = DESTIN;
 824b198:	e0bffa17 	ldw	r2,-24(fp)
 824b19c:	00c000c4 	movi	r3,3
 824b1a0:	10c00005 	stb	r3,0(r2)
   d->dcode = (char)(typecode & 0xFF);
 824b1a4:	e0bfff17 	ldw	r2,-4(fp)
 824b1a8:	1007883a 	mov	r3,r2
 824b1ac:	e0bffa17 	ldw	r2,-24(fp)
 824b1b0:	10c00045 	stb	r3,1(r2)
   d->dno1 = d->dno2 = 0;
 824b1b4:	e0bffa17 	ldw	r2,-24(fp)
 824b1b8:	1000018d 	sth	zero,6(r2)
 824b1bc:	e0bffa17 	ldw	r2,-24(fp)
 824b1c0:	10c0018b 	ldhu	r3,6(r2)
 824b1c4:	e0bffa17 	ldw	r2,-24(fp)
 824b1c8:	10c0010d 	sth	r3,4(r2)
#ifndef ICMP_SUPPRESS_PMTU
   if ((typecode & 0xFF) == DSTFRAG)
 824b1cc:	e0bfff17 	ldw	r2,-4(fp)
 824b1d0:	10803fcc 	andi	r2,r2,255
 824b1d4:	10800118 	cmpnei	r2,r2,4
 824b1d8:	1000121e 	bne	r2,zero,824b224 <icmp_destun+0x204>
      d->dno2 = htons(net->n_mtu - net->n_lnh);
 824b1dc:	e0800217 	ldw	r2,8(fp)
 824b1e0:	10c00917 	ldw	r3,36(r2)
 824b1e4:	e0800217 	ldw	r2,8(fp)
 824b1e8:	10800817 	ldw	r2,32(r2)
 824b1ec:	1885c83a 	sub	r2,r3,r2
 824b1f0:	1005d23a 	srai	r2,r2,8
 824b1f4:	10803fcc 	andi	r2,r2,255
 824b1f8:	1009883a 	mov	r4,r2
 824b1fc:	e0800217 	ldw	r2,8(fp)
 824b200:	10c00917 	ldw	r3,36(r2)
 824b204:	e0800217 	ldw	r2,8(fp)
 824b208:	10800817 	ldw	r2,32(r2)
 824b20c:	1885c83a 	sub	r2,r3,r2
 824b210:	1004923a 	slli	r2,r2,8
 824b214:	2084b03a 	or	r2,r4,r2
 824b218:	1007883a 	mov	r3,r2
 824b21c:	e0bffa17 	ldw	r2,-24(fp)
 824b220:	10c0018d 	sth	r3,6(r2)
#endif    /* ICMP_SUPPRESS_PMTU */
   MEMCPY(&d->dip, ip, (sizeof(struct ip) + ICMPDUDATA));
 824b224:	e0bffa17 	ldw	r2,-24(fp)
 824b228:	10800204 	addi	r2,r2,8
 824b22c:	01800704 	movi	r6,28
 824b230:	e17ffe17 	ldw	r5,-8(fp)
 824b234:	1009883a 	mov	r4,r2
 824b238:	8202f6c0 	call	8202f6c <memcpy>

   d->dchksum = 0;
 824b23c:	e0bffa17 	ldw	r2,-24(fp)
 824b240:	1000008d 	sth	zero,2(r2)
   d->dchksum = ~cksum(d, sizeof(struct destun)>>1);
 824b244:	01400484 	movi	r5,18
 824b248:	e13ffa17 	ldw	r4,-24(fp)
 824b24c:	82288100 	call	8228810 <cksum>
 824b250:	0084303a 	nor	r2,zero,r2
 824b254:	1007883a 	mov	r3,r2
 824b258:	e0bffa17 	ldw	r2,-24(fp)
 824b25c:	10c0008d 	sth	r3,2(r2)

   p->nb_plen =  sizeof(struct destun);
 824b260:	e0bff817 	ldw	r2,-32(fp)
 824b264:	00c00904 	movi	r3,36
 824b268:	10c00415 	stw	r3,16(r2)
   p->fhost = host;
 824b26c:	e0bff817 	ldw	r2,-32(fp)
 824b270:	e0fffc17 	ldw	r3,-16(fp)
 824b274:	10c00715 	stw	r3,28(r2)
   i = ip_write(ICMP_PROT, p);
 824b278:	e17ff817 	ldw	r5,-32(fp)
 824b27c:	01000044 	movi	r4,1
 824b280:	823f9a80 	call	823f9a8 <ip_write>
 824b284:	e0bffb15 	stw	r2,-20(fp)
   if (i < 0)
 824b288:	e0bffb17 	ldw	r2,-20(fp)
 824b28c:	10000e0e 	bge	r2,zero,824b2c8 <icmp_destun+0x2a8>
   {
      icmp_mib.icmpOutErrors++;
 824b290:	008209b4 	movhi	r2,2086
 824b294:	10baa104 	addi	r2,r2,-5500
 824b298:	10800e17 	ldw	r2,56(r2)
 824b29c:	10c00044 	addi	r3,r2,1
 824b2a0:	008209b4 	movhi	r2,2086
 824b2a4:	10baa104 	addi	r2,r2,-5500
 824b2a8:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 824b2ac:	d0a08317 	ldw	r2,-32244(gp)
 824b2b0:	1080860c 	andi	r2,r2,536
 824b2b4:	10001426 	beq	r2,zero,824b308 <icmp_destun+0x2e8>
         dprintf("ICMP: Can't send dest unreachable\n");
 824b2b8:	01020974 	movhi	r4,2085
 824b2bc:	2107b304 	addi	r4,r4,7884
 824b2c0:	82036800 	call	8203680 <puts>
#endif   /* NPDEBUG  */
      return;
 824b2c4:	00001006 	br	824b308 <icmp_destun+0x2e8>
   }
   icmp_mib.icmpOutMsgs++;
 824b2c8:	008209b4 	movhi	r2,2086
 824b2cc:	10baa104 	addi	r2,r2,-5500
 824b2d0:	10800d17 	ldw	r2,52(r2)
 824b2d4:	10c00044 	addi	r3,r2,1
 824b2d8:	008209b4 	movhi	r2,2086
 824b2dc:	10baa104 	addi	r2,r2,-5500
 824b2e0:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutDestUnreachs++;
 824b2e4:	008209b4 	movhi	r2,2086
 824b2e8:	10baa104 	addi	r2,r2,-5500
 824b2ec:	10800f17 	ldw	r2,60(r2)
 824b2f0:	10c00044 	addi	r3,r2,1
 824b2f4:	008209b4 	movhi	r2,2086
 824b2f8:	10baa104 	addi	r2,r2,-5500
 824b2fc:	10c00f15 	stw	r3,60(r2)
   return;
 824b300:	0001883a 	nop
 824b304:	00000106 	br	824b30c <icmp_destun+0x2ec>
      icmp_mib.icmpOutErrors++;
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
         dprintf("ICMP: Can't send dest unreachable\n");
#endif   /* NPDEBUG  */
      return;
 824b308:	0001883a 	nop
   }
   icmp_mib.icmpOutMsgs++;
   icmp_mib.icmpOutDestUnreachs++;
   return;
}
 824b30c:	e037883a 	mov	sp,fp
 824b310:	dfc00117 	ldw	ra,4(sp)
 824b314:	df000017 	ldw	fp,0(sp)
 824b318:	dec00204 	addi	sp,sp,8
 824b31c:	f800283a 	ret

0824b320 <icmp_timex>:
 *
 * RETURNS: void
 */

void icmp_timex (struct ip * ip, char code) 
{
 824b320:	defff504 	addi	sp,sp,-44
 824b324:	dfc00a15 	stw	ra,40(sp)
 824b328:	df000915 	stw	fp,36(sp)
 824b32c:	df000904 	addi	fp,sp,36
 824b330:	e13ffe15 	stw	r4,-8(fp)
 824b334:	2805883a 	mov	r2,r5
 824b338:	e0bfff05 	stb	r2,-4(fp)
   struct ip * pip;
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 824b33c:	d0a08317 	ldw	r2,-32244(gp)
 824b340:	1080040c 	andi	r2,r2,16
 824b344:	10003026 	beq	r2,zero,824b408 <icmp_timex+0xe8>
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824b348:	e17fff07 	ldb	r5,-4(fp)
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 824b34c:	e0bffe17 	ldw	r2,-8(fp)
 824b350:	10800317 	ldw	r2,12(r2)
 824b354:	1004d23a 	srli	r2,r2,8
 824b358:	10c03fcc 	andi	r3,r2,255
 824b35c:	e0bffe17 	ldw	r2,-8(fp)
 824b360:	10800317 	ldw	r2,12(r2)
 824b364:	1004923a 	slli	r2,r2,8
 824b368:	10bfffcc 	andi	r2,r2,65535
 824b36c:	1884b03a 	or	r2,r3,r2
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824b370:	11803fcc 	andi	r6,r2,255
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 824b374:	e0bffe17 	ldw	r2,-8(fp)
 824b378:	10800317 	ldw	r2,12(r2)
 824b37c:	1004d23a 	srli	r2,r2,8
 824b380:	10c03fcc 	andi	r3,r2,255
 824b384:	e0bffe17 	ldw	r2,-8(fp)
 824b388:	10800317 	ldw	r2,12(r2)
 824b38c:	1004923a 	slli	r2,r2,8
 824b390:	10bfffcc 	andi	r2,r2,65535
 824b394:	1884b03a 	or	r2,r3,r2
 824b398:	1004d23a 	srli	r2,r2,8
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824b39c:	11c03fcc 	andi	r7,r2,255
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 824b3a0:	e0bffe17 	ldw	r2,-8(fp)
 824b3a4:	10800317 	ldw	r2,12(r2)
 824b3a8:	1004d23a 	srli	r2,r2,8
 824b3ac:	10c03fcc 	andi	r3,r2,255
 824b3b0:	e0bffe17 	ldw	r2,-8(fp)
 824b3b4:	10800317 	ldw	r2,12(r2)
 824b3b8:	1004923a 	slli	r2,r2,8
 824b3bc:	10bfffcc 	andi	r2,r2,65535
 824b3c0:	1884b03a 	or	r2,r3,r2
 824b3c4:	1004d43a 	srli	r2,r2,16
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824b3c8:	10803fcc 	andi	r2,r2,255
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 824b3cc:	e0fffe17 	ldw	r3,-8(fp)
 824b3d0:	18c00317 	ldw	r3,12(r3)
 824b3d4:	1806d23a 	srli	r3,r3,8
 824b3d8:	19003fcc 	andi	r4,r3,255
 824b3dc:	e0fffe17 	ldw	r3,-8(fp)
 824b3e0:	18c00317 	ldw	r3,12(r3)
 824b3e4:	1806923a 	slli	r3,r3,8
 824b3e8:	18ffffcc 	andi	r3,r3,65535
 824b3ec:	20c6b03a 	or	r3,r4,r3
 824b3f0:	1806d63a 	srli	r3,r3,24
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824b3f4:	d8c00115 	stw	r3,4(sp)
 824b3f8:	d8800015 	stw	r2,0(sp)
 824b3fc:	01020974 	movhi	r4,2085
 824b400:	2107bc04 	addi	r4,r4,7920
 824b404:	82033fc0 	call	82033fc <printf>
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
#endif   /* NPDEBUG */

   icmp_pkt_len = ICMPTIMEX_HDR_LEN + ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN;
 824b408:	e0bffe17 	ldw	r2,-8(fp)
 824b40c:	10800003 	ldbu	r2,0(r2)
 824b410:	108003cc 	andi	r2,r2,15
 824b414:	1085883a 	add	r2,r2,r2
 824b418:	1085883a 	add	r2,r2,r2
 824b41c:	10800404 	addi	r2,r2,16
 824b420:	e0bff905 	stb	r2,-28(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 824b424:	01000084 	movi	r4,2
 824b428:	822d86c0 	call	822d86c <LOCK_NET_RESOURCE>
    * length of the "outer" IP header, length of the ICMP header (ICMPTIMEX_HDR_LEN,
    * 8 bytes), length of the "inner" IP header, and length of "user" data 
    * (ICMPTIMEX_PAYLOAD_DATA_LEN, 8 bytes) (just past the "inner" IP header).  The 
    * latter two items are from the packet that the ICMP Time Exceeded message is 
    * being sent in response to. */
   p = pk_alloc(MaxLnh + IPHSIZ + icmp_pkt_len);
 824b42c:	e0bff903 	ldbu	r2,-28(fp)
 824b430:	d0e08117 	ldw	r3,-32252(gp)
 824b434:	10c5883a 	add	r2,r2,r3
 824b438:	10800504 	addi	r2,r2,20
 824b43c:	1009883a 	mov	r4,r2
 824b440:	822ca480 	call	822ca48 <pk_alloc>
 824b444:	e0bffa15 	stw	r2,-24(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824b448:	01000084 	movi	r4,2
 824b44c:	822d9300 	call	822d930 <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 824b450:	e0bffa17 	ldw	r2,-24(fp)
 824b454:	10000e1e 	bne	r2,zero,824b490 <icmp_timex+0x170>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 824b458:	d0a08317 	ldw	r2,-32244(gp)
 824b45c:	1080800c 	andi	r2,r2,512
 824b460:	10000326 	beq	r2,zero,824b470 <icmp_timex+0x150>
         dprintf("icmp: can't alloc pkt\n");
 824b464:	01020974 	movhi	r4,2085
 824b468:	2107ad04 	addi	r4,r4,7860
 824b46c:	82036800 	call	8203680 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 824b470:	008209b4 	movhi	r2,2086
 824b474:	10baa104 	addi	r2,r2,-5500
 824b478:	10800e17 	ldw	r2,56(r2)
 824b47c:	10c00044 	addi	r3,r2,1
 824b480:	008209b4 	movhi	r2,2086
 824b484:	10baa104 	addi	r2,r2,-5500
 824b488:	10c00e15 	stw	r3,56(r2)
      return;
 824b48c:	00006406 	br	824b620 <icmp_timex+0x300>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 824b490:	e0bffa17 	ldw	r2,-24(fp)
 824b494:	10800317 	ldw	r2,12(r2)
 824b498:	e0bffb15 	stw	r2,-20(fp)
   /* source IP address of packet is our address (i.e., destination IP address 
    * in the datagram whose reassembly timed out) */
   pip->ip_src = ip->ip_dest;
 824b49c:	e0bffe17 	ldw	r2,-8(fp)
 824b4a0:	10c00417 	ldw	r3,16(r2)
 824b4a4:	e0bffb17 	ldw	r2,-20(fp)
 824b4a8:	10c00315 	stw	r3,12(r2)
   /* the destination address is the same as the source IP address of the 
    * datagram whose reassembly timed out */
   pip->ip_dest = ip->ip_src;
 824b4ac:	e0bffe17 	ldw	r2,-8(fp)
 824b4b0:	10c00317 	ldw	r3,12(r2)
 824b4b4:	e0bffb17 	ldw	r2,-20(fp)
 824b4b8:	10c00415 	stw	r3,16(r2)

   /* move past space for IP header to get to start of ICMP header */
   p->nb_prot += sizeof(struct ip);
 824b4bc:	e0bffa17 	ldw	r2,-24(fp)
 824b4c0:	10800317 	ldw	r2,12(r2)
 824b4c4:	10c00504 	addi	r3,r2,20
 824b4c8:	e0bffa17 	ldw	r2,-24(fp)
 824b4cc:	10c00315 	stw	r3,12(r2)

   tx = (struct timex *) p->nb_prot;
 824b4d0:	e0bffa17 	ldw	r2,-24(fp)
 824b4d4:	10800317 	ldw	r2,12(r2)
 824b4d8:	e0bffc15 	stw	r2,-16(fp)

   tx->ttype = TIMEX;
 824b4dc:	e0bffc17 	ldw	r2,-16(fp)
 824b4e0:	00c002c4 	movi	r3,11
 824b4e4:	10c00005 	stb	r3,0(r2)
   tx->tcode = code;
 824b4e8:	e0bffc17 	ldw	r2,-16(fp)
 824b4ec:	e0ffff03 	ldbu	r3,-4(fp)
 824b4f0:	10c00045 	stb	r3,1(r2)
   tx->tno1 = tx->tno2 = 0;
 824b4f4:	e0bffc17 	ldw	r2,-16(fp)
 824b4f8:	1000018d 	sth	zero,6(r2)
 824b4fc:	e0bffc17 	ldw	r2,-16(fp)
 824b500:	10c0018b 	ldhu	r3,6(r2)
 824b504:	e0bffc17 	ldw	r2,-16(fp)
 824b508:	10c0010d 	sth	r3,4(r2)
   MEMCPY(&tx->tip, ip, (ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN));
 824b50c:	e0bffc17 	ldw	r2,-16(fp)
 824b510:	10c00204 	addi	r3,r2,8
 824b514:	e0bffe17 	ldw	r2,-8(fp)
 824b518:	10800003 	ldbu	r2,0(r2)
 824b51c:	10803fcc 	andi	r2,r2,255
 824b520:	108003cc 	andi	r2,r2,15
 824b524:	1085883a 	add	r2,r2,r2
 824b528:	1085883a 	add	r2,r2,r2
 824b52c:	10800204 	addi	r2,r2,8
 824b530:	100d883a 	mov	r6,r2
 824b534:	e17ffe17 	ldw	r5,-8(fp)
 824b538:	1809883a 	mov	r4,r3
 824b53c:	8202f6c0 	call	8202f6c <memcpy>

   tx->tchksum = 0;
 824b540:	e0bffc17 	ldw	r2,-16(fp)
 824b544:	1000008d 	sth	zero,2(r2)
   tx->tchksum = ~cksum(tx, (icmp_pkt_len>>1));
 824b548:	e0bff903 	ldbu	r2,-28(fp)
 824b54c:	1004d07a 	srli	r2,r2,1
 824b550:	10803fcc 	andi	r2,r2,255
 824b554:	100b883a 	mov	r5,r2
 824b558:	e13ffc17 	ldw	r4,-16(fp)
 824b55c:	82288100 	call	8228810 <cksum>
 824b560:	0084303a 	nor	r2,zero,r2
 824b564:	1007883a 	mov	r3,r2
 824b568:	e0bffc17 	ldw	r2,-16(fp)
 824b56c:	10c0008d 	sth	r3,2(r2)

   p->nb_plen = icmp_pkt_len;
 824b570:	e0fff903 	ldbu	r3,-28(fp)
 824b574:	e0bffa17 	ldw	r2,-24(fp)
 824b578:	10c00415 	stw	r3,16(r2)
   /* p->fhost is expected to be in network byte order */
   p->fhost = pip->ip_dest;
 824b57c:	e0bffb17 	ldw	r2,-20(fp)
 824b580:	10c00417 	ldw	r3,16(r2)
 824b584:	e0bffa17 	ldw	r2,-24(fp)
 824b588:	10c00715 	stw	r3,28(r2)
   i = ip_write(ICMP_PROT, p);
 824b58c:	e17ffa17 	ldw	r5,-24(fp)
 824b590:	01000044 	movi	r4,1
 824b594:	823f9a80 	call	823f9a8 <ip_write>
 824b598:	e0bffd15 	stw	r2,-12(fp)
   if (i < 0)
 824b59c:	e0bffd17 	ldw	r2,-12(fp)
 824b5a0:	10000e0e 	bge	r2,zero,824b5dc <icmp_timex+0x2bc>
   {
      icmp_mib.icmpOutErrors++;
 824b5a4:	008209b4 	movhi	r2,2086
 824b5a8:	10baa104 	addi	r2,r2,-5500
 824b5ac:	10800e17 	ldw	r2,56(r2)
 824b5b0:	10c00044 	addi	r3,r2,1
 824b5b4:	008209b4 	movhi	r2,2086
 824b5b8:	10baa104 	addi	r2,r2,-5500
 824b5bc:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 824b5c0:	d0a08317 	ldw	r2,-32244(gp)
 824b5c4:	1080860c 	andi	r2,r2,536
 824b5c8:	10001426 	beq	r2,zero,824b61c <icmp_timex+0x2fc>
         dprintf("ICMP: Can't send Time Exceeded\n");
 824b5cc:	01020974 	movhi	r4,2085
 824b5d0:	2107cc04 	addi	r4,r4,7984
 824b5d4:	82036800 	call	8203680 <puts>
#endif   /* NPDEBUG  */
      return;
 824b5d8:	00001006 	br	824b61c <icmp_timex+0x2fc>
   }
   icmp_mib.icmpOutMsgs++;
 824b5dc:	008209b4 	movhi	r2,2086
 824b5e0:	10baa104 	addi	r2,r2,-5500
 824b5e4:	10800d17 	ldw	r2,52(r2)
 824b5e8:	10c00044 	addi	r3,r2,1
 824b5ec:	008209b4 	movhi	r2,2086
 824b5f0:	10baa104 	addi	r2,r2,-5500
 824b5f4:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutTimeExcds++;
 824b5f8:	008209b4 	movhi	r2,2086
 824b5fc:	10baa104 	addi	r2,r2,-5500
 824b600:	10801017 	ldw	r2,64(r2)
 824b604:	10c00044 	addi	r3,r2,1
 824b608:	008209b4 	movhi	r2,2086
 824b60c:	10baa104 	addi	r2,r2,-5500
 824b610:	10c01015 	stw	r3,64(r2)
   return;
 824b614:	0001883a 	nop
 824b618:	00000106 	br	824b620 <icmp_timex+0x300>
      icmp_mib.icmpOutErrors++;
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
         dprintf("ICMP: Can't send Time Exceeded\n");
#endif   /* NPDEBUG  */
      return;
 824b61c:	0001883a 	nop
   }
   icmp_mib.icmpOutMsgs++;
   icmp_mib.icmpOutTimeExcds++;
   return;
}
 824b620:	e037883a 	mov	sp,fp
 824b624:	dfc00117 	ldw	ra,4(sp)
 824b628:	df000017 	ldw	fp,0(sp)
 824b62c:	dec00204 	addi	sp,sp,8
 824b630:	f800283a 	ret

0824b634 <icmp_du>:
 * RETURNS: void
 */

void  
icmp_du(PACKET p, struct destun * pdp)
{
 824b634:	defffc04 	addi	sp,sp,-16
 824b638:	dfc00315 	stw	ra,12(sp)
 824b63c:	df000215 	stw	fp,8(sp)
 824b640:	df000204 	addi	fp,sp,8
 824b644:	e13ffe15 	stw	r4,-8(fp)
 824b648:	e17fff15 	stw	r5,-4(fp)
   /* see if user app wants notification first */
   if (icmpdu_hook)
 824b64c:	d0a0dc17 	ldw	r2,-31888(gp)
 824b650:	10000426 	beq	r2,zero,824b664 <icmp_du+0x30>
      icmpdu_hook(p, pdp);
 824b654:	d0a0dc17 	ldw	r2,-31888(gp)
 824b658:	e17fff17 	ldw	r5,-4(fp)
 824b65c:	e13ffe17 	ldw	r4,-8(fp)
 824b660:	103ee83a 	callr	r2

#ifdef INCLUDE_TCP
   /* Tell the sockets layer so it can correct the problem. */
   so_icmpdu(p, pdp);   /* this call should free packet p */
 824b664:	e17fff17 	ldw	r5,-4(fp)
 824b668:	e13ffe17 	ldw	r4,-8(fp)
 824b66c:	822f70c0 	call	822f70c <so_icmpdu>
done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(p); /* else just free packet */
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif   /* INCLUDE_TCP */
}
 824b670:	0001883a 	nop
 824b674:	e037883a 	mov	sp,fp
 824b678:	dfc00117 	ldw	ra,4(sp)
 824b67c:	df000017 	ldw	fp,0(sp)
 824b680:	dec00204 	addi	sp,sp,8
 824b684:	f800283a 	ret

0824b688 <atexit>:
 824b688:	200b883a 	mov	r5,r4
 824b68c:	000f883a 	mov	r7,zero
 824b690:	000d883a 	mov	r6,zero
 824b694:	0009883a 	mov	r4,zero
 824b698:	824bc4c1 	jmpi	824bc4c <__register_exitproc>

0824b69c <atoi>:
 824b69c:	01800284 	movi	r6,10
 824b6a0:	000b883a 	mov	r5,zero
 824b6a4:	824bb981 	jmpi	824bb98 <strtol>

0824b6a8 <_atoi_r>:
 824b6a8:	01c00284 	movi	r7,10
 824b6ac:	000d883a 	mov	r6,zero
 824b6b0:	824b9601 	jmpi	824b960 <_strtol_r>

0824b6b4 <exit>:
 824b6b4:	defffe04 	addi	sp,sp,-8
 824b6b8:	000b883a 	mov	r5,zero
 824b6bc:	dc000015 	stw	r16,0(sp)
 824b6c0:	dfc00115 	stw	ra,4(sp)
 824b6c4:	2021883a 	mov	r16,r4
 824b6c8:	824bd640 	call	824bd64 <__call_exitprocs>
 824b6cc:	00820974 	movhi	r2,2085
 824b6d0:	108fba04 	addi	r2,r2,16104
 824b6d4:	11000017 	ldw	r4,0(r2)
 824b6d8:	20800f17 	ldw	r2,60(r4)
 824b6dc:	10000126 	beq	r2,zero,824b6e4 <exit+0x30>
 824b6e0:	103ee83a 	callr	r2
 824b6e4:	8009883a 	mov	r4,r16
 824b6e8:	824befc0 	call	824befc <_exit>

0824b6ec <malloc>:
 824b6ec:	00820974 	movhi	r2,2085
 824b6f0:	108fbb04 	addi	r2,r2,16108
 824b6f4:	200b883a 	mov	r5,r4
 824b6f8:	11000017 	ldw	r4,0(r2)
 824b6fc:	820bd481 	jmpi	820bd48 <_malloc_r>

0824b700 <free>:
 824b700:	00820974 	movhi	r2,2085
 824b704:	108fbb04 	addi	r2,r2,16108
 824b708:	200b883a 	mov	r5,r4
 824b70c:	11000017 	ldw	r4,0(r2)
 824b710:	820b15c1 	jmpi	820b15c <_free_r>

0824b714 <strcpy>:
 824b714:	2906b03a 	or	r3,r5,r4
 824b718:	18c000cc 	andi	r3,r3,3
 824b71c:	2005883a 	mov	r2,r4
 824b720:	1800161e 	bne	r3,zero,824b77c <strcpy+0x68>
 824b724:	29c00017 	ldw	r7,0(r5)
 824b728:	02ffbff4 	movhi	r11,65279
 824b72c:	5affbfc4 	addi	r11,r11,-257
 824b730:	02a02074 	movhi	r10,32897
 824b734:	01c6303a 	nor	r3,zero,r7
 824b738:	3ac9883a 	add	r4,r7,r11
 824b73c:	52a02004 	addi	r10,r10,-32640
 824b740:	20c6703a 	and	r3,r4,r3
 824b744:	1a86703a 	and	r3,r3,r10
 824b748:	18000c1e 	bne	r3,zero,824b77c <strcpy+0x68>
 824b74c:	1011883a 	mov	r8,r2
 824b750:	41c00015 	stw	r7,0(r8)
 824b754:	29400104 	addi	r5,r5,4
 824b758:	29c00017 	ldw	r7,0(r5)
 824b75c:	41800104 	addi	r6,r8,4
 824b760:	3011883a 	mov	r8,r6
 824b764:	3ad3883a 	add	r9,r7,r11
 824b768:	01c6303a 	nor	r3,zero,r7
 824b76c:	48c6703a 	and	r3,r9,r3
 824b770:	1a86703a 	and	r3,r3,r10
 824b774:	183ff626 	beq	r3,zero,824b750 <strcpy+0x3c>
 824b778:	00000106 	br	824b780 <strcpy+0x6c>
 824b77c:	100d883a 	mov	r6,r2
 824b780:	28c00003 	ldbu	r3,0(r5)
 824b784:	31800044 	addi	r6,r6,1
 824b788:	29400044 	addi	r5,r5,1
 824b78c:	30ffffc5 	stb	r3,-1(r6)
 824b790:	18c03fcc 	andi	r3,r3,255
 824b794:	18c0201c 	xori	r3,r3,128
 824b798:	18ffe004 	addi	r3,r3,-128
 824b79c:	183ff81e 	bne	r3,zero,824b780 <strcpy+0x6c>
 824b7a0:	f800283a 	ret

0824b7a4 <strncmp>:
 824b7a4:	30003126 	beq	r6,zero,824b86c <strncmp+0xc8>
 824b7a8:	2144b03a 	or	r2,r4,r5
 824b7ac:	108000cc 	andi	r2,r2,3
 824b7b0:	10001e1e 	bne	r2,zero,824b82c <strncmp+0x88>
 824b7b4:	024000c4 	movi	r9,3
 824b7b8:	49801c2e 	bgeu	r9,r6,824b82c <strncmp+0x88>
 824b7bc:	20800017 	ldw	r2,0(r4)
 824b7c0:	28c00017 	ldw	r3,0(r5)
 824b7c4:	10c0191e 	bne	r2,r3,824b82c <strncmp+0x88>
 824b7c8:	31bfff04 	addi	r6,r6,-4
 824b7cc:	30002726 	beq	r6,zero,824b86c <strncmp+0xc8>
 824b7d0:	02ffbff4 	movhi	r11,65279
 824b7d4:	5affbfc4 	addi	r11,r11,-257
 824b7d8:	0086303a 	nor	r3,zero,r2
 824b7dc:	02a02074 	movhi	r10,32897
 824b7e0:	12c5883a 	add	r2,r2,r11
 824b7e4:	52a02004 	addi	r10,r10,-32640
 824b7e8:	10c4703a 	and	r2,r2,r3
 824b7ec:	1284703a 	and	r2,r2,r10
 824b7f0:	10000b26 	beq	r2,zero,824b820 <strncmp+0x7c>
 824b7f4:	00001d06 	br	824b86c <strncmp+0xc8>
 824b7f8:	20c00017 	ldw	r3,0(r4)
 824b7fc:	29c00017 	ldw	r7,0(r5)
 824b800:	1ad1883a 	add	r8,r3,r11
 824b804:	00c4303a 	nor	r2,zero,r3
 824b808:	4084703a 	and	r2,r8,r2
 824b80c:	1284703a 	and	r2,r2,r10
 824b810:	19c0061e 	bne	r3,r7,824b82c <strncmp+0x88>
 824b814:	31bfff04 	addi	r6,r6,-4
 824b818:	30001426 	beq	r6,zero,824b86c <strncmp+0xc8>
 824b81c:	1000131e 	bne	r2,zero,824b86c <strncmp+0xc8>
 824b820:	21000104 	addi	r4,r4,4
 824b824:	29400104 	addi	r5,r5,4
 824b828:	49bff336 	bltu	r9,r6,824b7f8 <strncmp+0x54>
 824b82c:	28800007 	ldb	r2,0(r5)
 824b830:	20c00007 	ldb	r3,0(r4)
 824b834:	31bfffc4 	addi	r6,r6,-1
 824b838:	10c0081e 	bne	r2,r3,824b85c <strncmp+0xb8>
 824b83c:	30000b26 	beq	r6,zero,824b86c <strncmp+0xc8>
 824b840:	10000a26 	beq	r2,zero,824b86c <strncmp+0xc8>
 824b844:	21000044 	addi	r4,r4,1
 824b848:	29400044 	addi	r5,r5,1
 824b84c:	20800007 	ldb	r2,0(r4)
 824b850:	28c00007 	ldb	r3,0(r5)
 824b854:	31bfffc4 	addi	r6,r6,-1
 824b858:	10fff826 	beq	r2,r3,824b83c <strncmp+0x98>
 824b85c:	20800003 	ldbu	r2,0(r4)
 824b860:	28c00003 	ldbu	r3,0(r5)
 824b864:	10c5c83a 	sub	r2,r2,r3
 824b868:	f800283a 	ret
 824b86c:	0005883a 	mov	r2,zero
 824b870:	f800283a 	ret

0824b874 <strncpy>:
 824b874:	2906b03a 	or	r3,r5,r4
 824b878:	18c000cc 	andi	r3,r3,3
 824b87c:	2005883a 	mov	r2,r4
 824b880:	18002c1e 	bne	r3,zero,824b934 <strncpy+0xc0>
 824b884:	010000c4 	movi	r4,3
 824b888:	21802a2e 	bgeu	r4,r6,824b934 <strncpy+0xc0>
 824b88c:	033fbff4 	movhi	r12,65279
 824b890:	02e02074 	movhi	r11,32897
 824b894:	633fbfc4 	addi	r12,r12,-257
 824b898:	5ae02004 	addi	r11,r11,-32640
 824b89c:	100f883a 	mov	r7,r2
 824b8a0:	2a000017 	ldw	r8,0(r5)
 824b8a4:	3815883a 	mov	r10,r7
 824b8a8:	4313883a 	add	r9,r8,r12
 824b8ac:	0206303a 	nor	r3,zero,r8
 824b8b0:	48c6703a 	and	r3,r9,r3
 824b8b4:	1ac6703a 	and	r3,r3,r11
 824b8b8:	1800261e 	bne	r3,zero,824b954 <strncpy+0xe0>
 824b8bc:	39c00104 	addi	r7,r7,4
 824b8c0:	52000015 	stw	r8,0(r10)
 824b8c4:	31bfff04 	addi	r6,r6,-4
 824b8c8:	3811883a 	mov	r8,r7
 824b8cc:	29400104 	addi	r5,r5,4
 824b8d0:	21bff336 	bltu	r4,r6,824b8a0 <strncpy+0x2c>
 824b8d4:	30001e26 	beq	r6,zero,824b950 <strncpy+0xdc>
 824b8d8:	29c00003 	ldbu	r7,0(r5)
 824b8dc:	31bfffc4 	addi	r6,r6,-1
 824b8e0:	40c00044 	addi	r3,r8,1
 824b8e4:	41c00005 	stb	r7,0(r8)
 824b8e8:	39c03fcc 	andi	r7,r7,255
 824b8ec:	39c0201c 	xori	r7,r7,128
 824b8f0:	39ffe004 	addi	r7,r7,-128
 824b8f4:	29400044 	addi	r5,r5,1
 824b8f8:	38001026 	beq	r7,zero,824b93c <strncpy+0xc8>
 824b8fc:	1811883a 	mov	r8,r3
 824b900:	00000906 	br	824b928 <strncpy+0xb4>
 824b904:	29c00003 	ldbu	r7,0(r5)
 824b908:	31bfffc4 	addi	r6,r6,-1
 824b90c:	29400044 	addi	r5,r5,1
 824b910:	41c00005 	stb	r7,0(r8)
 824b914:	39c03fcc 	andi	r7,r7,255
 824b918:	39c0201c 	xori	r7,r7,128
 824b91c:	39ffe004 	addi	r7,r7,-128
 824b920:	1811883a 	mov	r8,r3
 824b924:	38000526 	beq	r7,zero,824b93c <strncpy+0xc8>
 824b928:	18c00044 	addi	r3,r3,1
 824b92c:	303ff51e 	bne	r6,zero,824b904 <strncpy+0x90>
 824b930:	f800283a 	ret
 824b934:	1011883a 	mov	r8,r2
 824b938:	003fe606 	br	824b8d4 <strncpy+0x60>
 824b93c:	30000726 	beq	r6,zero,824b95c <strncpy+0xe8>
 824b940:	198d883a 	add	r6,r3,r6
 824b944:	18000005 	stb	zero,0(r3)
 824b948:	18c00044 	addi	r3,r3,1
 824b94c:	19bffd1e 	bne	r3,r6,824b944 <strncpy+0xd0>
 824b950:	f800283a 	ret
 824b954:	3811883a 	mov	r8,r7
 824b958:	003fdf06 	br	824b8d8 <strncpy+0x64>
 824b95c:	f800283a 	ret

0824b960 <_strtol_r>:
 824b960:	00820974 	movhi	r2,2085
 824b964:	defff404 	addi	sp,sp,-48
 824b968:	108fb904 	addi	r2,r2,16100
 824b96c:	dd400715 	stw	r21,28(sp)
 824b970:	15400017 	ldw	r21,0(r2)
 824b974:	dd800815 	stw	r22,32(sp)
 824b978:	dd000615 	stw	r20,24(sp)
 824b97c:	dcc00515 	stw	r19,20(sp)
 824b980:	d9000015 	stw	r4,0(sp)
 824b984:	dfc00b15 	stw	ra,44(sp)
 824b988:	df000a15 	stw	fp,40(sp)
 824b98c:	ddc00915 	stw	r23,36(sp)
 824b990:	dc800415 	stw	r18,16(sp)
 824b994:	dc400315 	stw	r17,12(sp)
 824b998:	dc000215 	stw	r16,8(sp)
 824b99c:	2829883a 	mov	r20,r5
 824b9a0:	3027883a 	mov	r19,r6
 824b9a4:	382d883a 	mov	r22,r7
 824b9a8:	2809883a 	mov	r4,r5
 824b9ac:	24000003 	ldbu	r16,0(r4)
 824b9b0:	24400044 	addi	r17,r4,1
 824b9b4:	2007883a 	mov	r3,r4
 824b9b8:	ac05883a 	add	r2,r21,r16
 824b9bc:	10800043 	ldbu	r2,1(r2)
 824b9c0:	8809883a 	mov	r4,r17
 824b9c4:	1080020c 	andi	r2,r2,8
 824b9c8:	103ff81e 	bne	r2,zero,824b9ac <_strtol_r+0x4c>
 824b9cc:	00800b44 	movi	r2,45
 824b9d0:	80805826 	beq	r16,r2,824bb34 <_strtol_r+0x1d4>
 824b9d4:	00800ac4 	movi	r2,43
 824b9d8:	80805a26 	beq	r16,r2,824bb44 <_strtol_r+0x1e4>
 824b9dc:	0039883a 	mov	fp,zero
 824b9e0:	b0004426 	beq	r22,zero,824baf4 <_strtol_r+0x194>
 824b9e4:	00800404 	movi	r2,16
 824b9e8:	b0806026 	beq	r22,r2,824bb6c <_strtol_r+0x20c>
 824b9ec:	b02f883a 	mov	r23,r22
 824b9f0:	00a00034 	movhi	r2,32768
 824b9f4:	e025003a 	cmpeq	r18,fp,zero
 824b9f8:	14a5c83a 	sub	r18,r2,r18
 824b9fc:	b80b883a 	mov	r5,r23
 824ba00:	9009883a 	mov	r4,r18
 824ba04:	8202cd00 	call	8202cd0 <__umodsi3>
 824ba08:	b80b883a 	mov	r5,r23
 824ba0c:	9009883a 	mov	r4,r18
 824ba10:	d8800115 	stw	r2,4(sp)
 824ba14:	8202c6c0 	call	8202c6c <__udivsi3>
 824ba18:	ac07883a 	add	r3,r21,r16
 824ba1c:	18c00043 	ldbu	r3,1(r3)
 824ba20:	880b883a 	mov	r5,r17
 824ba24:	000d883a 	mov	r6,zero
 824ba28:	1a00010c 	andi	r8,r3,4
 824ba2c:	0009883a 	mov	r4,zero
 824ba30:	02800044 	movi	r10,1
 824ba34:	027fffc4 	movi	r9,-1
 824ba38:	d9c00117 	ldw	r7,4(sp)
 824ba3c:	40000e26 	beq	r8,zero,824ba78 <_strtol_r+0x118>
 824ba40:	843ff404 	addi	r16,r16,-48
 824ba44:	8580120e 	bge	r16,r22,824ba90 <_strtol_r+0x130>
 824ba48:	32400526 	beq	r6,r9,824ba60 <_strtol_r+0x100>
 824ba4c:	11002536 	bltu	r2,r4,824bae4 <_strtol_r+0x184>
 824ba50:	20802326 	beq	r4,r2,824bae0 <_strtol_r+0x180>
 824ba54:	25c9383a 	mul	r4,r4,r23
 824ba58:	01800044 	movi	r6,1
 824ba5c:	8109883a 	add	r4,r16,r4
 824ba60:	2c000003 	ldbu	r16,0(r5)
 824ba64:	29400044 	addi	r5,r5,1
 824ba68:	ac07883a 	add	r3,r21,r16
 824ba6c:	18c00043 	ldbu	r3,1(r3)
 824ba70:	1a00010c 	andi	r8,r3,4
 824ba74:	403ff21e 	bne	r8,zero,824ba40 <_strtol_r+0xe0>
 824ba78:	18c000cc 	andi	r3,r3,3
 824ba7c:	18000426 	beq	r3,zero,824ba90 <_strtol_r+0x130>
 824ba80:	1a801a26 	beq	r3,r10,824baec <_strtol_r+0x18c>
 824ba84:	00c015c4 	movi	r3,87
 824ba88:	80e1c83a 	sub	r16,r16,r3
 824ba8c:	85bfee16 	blt	r16,r22,824ba48 <_strtol_r+0xe8>
 824ba90:	00bfffc4 	movi	r2,-1
 824ba94:	30801e26 	beq	r6,r2,824bb10 <_strtol_r+0x1b0>
 824ba98:	e0001b1e 	bne	fp,zero,824bb08 <_strtol_r+0x1a8>
 824ba9c:	2005883a 	mov	r2,r4
 824baa0:	98000326 	beq	r19,zero,824bab0 <_strtol_r+0x150>
 824baa4:	3000211e 	bne	r6,zero,824bb2c <_strtol_r+0x1cc>
 824baa8:	a00b883a 	mov	r5,r20
 824baac:	99400015 	stw	r5,0(r19)
 824bab0:	dfc00b17 	ldw	ra,44(sp)
 824bab4:	df000a17 	ldw	fp,40(sp)
 824bab8:	ddc00917 	ldw	r23,36(sp)
 824babc:	dd800817 	ldw	r22,32(sp)
 824bac0:	dd400717 	ldw	r21,28(sp)
 824bac4:	dd000617 	ldw	r20,24(sp)
 824bac8:	dcc00517 	ldw	r19,20(sp)
 824bacc:	dc800417 	ldw	r18,16(sp)
 824bad0:	dc400317 	ldw	r17,12(sp)
 824bad4:	dc000217 	ldw	r16,8(sp)
 824bad8:	dec00c04 	addi	sp,sp,48
 824badc:	f800283a 	ret
 824bae0:	3c3fdc0e 	bge	r7,r16,824ba54 <_strtol_r+0xf4>
 824bae4:	01bfffc4 	movi	r6,-1
 824bae8:	003fdd06 	br	824ba60 <_strtol_r+0x100>
 824baec:	00c00dc4 	movi	r3,55
 824baf0:	003fe506 	br	824ba88 <_strtol_r+0x128>
 824baf4:	00800c04 	movi	r2,48
 824baf8:	80801626 	beq	r16,r2,824bb54 <_strtol_r+0x1f4>
 824bafc:	05800284 	movi	r22,10
 824bb00:	b02f883a 	mov	r23,r22
 824bb04:	003fba06 	br	824b9f0 <_strtol_r+0x90>
 824bb08:	0109c83a 	sub	r4,zero,r4
 824bb0c:	003fe306 	br	824ba9c <_strtol_r+0x13c>
 824bb10:	d9000017 	ldw	r4,0(sp)
 824bb14:	00c00884 	movi	r3,34
 824bb18:	e005003a 	cmpeq	r2,fp,zero
 824bb1c:	20c00015 	stw	r3,0(r4)
 824bb20:	00e00034 	movhi	r3,32768
 824bb24:	1885c83a 	sub	r2,r3,r2
 824bb28:	983fe126 	beq	r19,zero,824bab0 <_strtol_r+0x150>
 824bb2c:	297fffc4 	addi	r5,r5,-1
 824bb30:	003fde06 	br	824baac <_strtol_r+0x14c>
 824bb34:	1c400084 	addi	r17,r3,2
 824bb38:	1c000043 	ldbu	r16,1(r3)
 824bb3c:	07000044 	movi	fp,1
 824bb40:	003fa706 	br	824b9e0 <_strtol_r+0x80>
 824bb44:	1c400084 	addi	r17,r3,2
 824bb48:	1c000043 	ldbu	r16,1(r3)
 824bb4c:	0039883a 	mov	fp,zero
 824bb50:	003fa306 	br	824b9e0 <_strtol_r+0x80>
 824bb54:	88800003 	ldbu	r2,0(r17)
 824bb58:	00c01604 	movi	r3,88
 824bb5c:	108037cc 	andi	r2,r2,223
 824bb60:	10c00826 	beq	r2,r3,824bb84 <_strtol_r+0x224>
 824bb64:	05800204 	movi	r22,8
 824bb68:	003fa006 	br	824b9ec <_strtol_r+0x8c>
 824bb6c:	00800c04 	movi	r2,48
 824bb70:	80bf9e1e 	bne	r16,r2,824b9ec <_strtol_r+0x8c>
 824bb74:	88800003 	ldbu	r2,0(r17)
 824bb78:	00c01604 	movi	r3,88
 824bb7c:	108037cc 	andi	r2,r2,223
 824bb80:	10ff9a1e 	bne	r2,r3,824b9ec <_strtol_r+0x8c>
 824bb84:	05c00404 	movi	r23,16
 824bb88:	8c000043 	ldbu	r16,1(r17)
 824bb8c:	b82d883a 	mov	r22,r23
 824bb90:	8c400084 	addi	r17,r17,2
 824bb94:	003f9606 	br	824b9f0 <_strtol_r+0x90>

0824bb98 <strtol>:
 824bb98:	00820974 	movhi	r2,2085
 824bb9c:	108fbb04 	addi	r2,r2,16108
 824bba0:	300f883a 	mov	r7,r6
 824bba4:	280d883a 	mov	r6,r5
 824bba8:	200b883a 	mov	r5,r4
 824bbac:	11000017 	ldw	r4,0(r2)
 824bbb0:	824b9601 	jmpi	824b960 <_strtol_r>

0824bbb4 <vprintf>:
 824bbb4:	00820974 	movhi	r2,2085
 824bbb8:	108fbb04 	addi	r2,r2,16108
 824bbbc:	200d883a 	mov	r6,r4
 824bbc0:	11000017 	ldw	r4,0(r2)
 824bbc4:	280f883a 	mov	r7,r5
 824bbc8:	21400217 	ldw	r5,8(r4)
 824bbcc:	824bee41 	jmpi	824bee4 <_vfprintf_r>

0824bbd0 <_vprintf_r>:
 824bbd0:	300f883a 	mov	r7,r6
 824bbd4:	280d883a 	mov	r6,r5
 824bbd8:	21400217 	ldw	r5,8(r4)
 824bbdc:	824bee41 	jmpi	824bee4 <_vfprintf_r>

0824bbe0 <_vsprintf_r>:
 824bbe0:	00a00034 	movhi	r2,32768
 824bbe4:	deffe504 	addi	sp,sp,-108
 824bbe8:	10bfffc4 	addi	r2,r2,-1
 824bbec:	2807883a 	mov	r3,r5
 824bbf0:	02008204 	movi	r8,520
 824bbf4:	d8800215 	stw	r2,8(sp)
 824bbf8:	d8800515 	stw	r2,20(sp)
 824bbfc:	d80b883a 	mov	r5,sp
 824bc00:	00bfffc4 	movi	r2,-1
 824bc04:	d8c00015 	stw	r3,0(sp)
 824bc08:	d8c00415 	stw	r3,16(sp)
 824bc0c:	dfc01a15 	stw	ra,104(sp)
 824bc10:	da00030d 	sth	r8,12(sp)
 824bc14:	d880038d 	sth	r2,14(sp)
 824bc18:	82048b80 	call	82048b8 <___svfprintf_internal_r>
 824bc1c:	d8c00017 	ldw	r3,0(sp)
 824bc20:	18000005 	stb	zero,0(r3)
 824bc24:	dfc01a17 	ldw	ra,104(sp)
 824bc28:	dec01b04 	addi	sp,sp,108
 824bc2c:	f800283a 	ret

0824bc30 <vsprintf>:
 824bc30:	00820974 	movhi	r2,2085
 824bc34:	108fbb04 	addi	r2,r2,16108
 824bc38:	300f883a 	mov	r7,r6
 824bc3c:	280d883a 	mov	r6,r5
 824bc40:	200b883a 	mov	r5,r4
 824bc44:	11000017 	ldw	r4,0(r2)
 824bc48:	824bbe01 	jmpi	824bbe0 <_vsprintf_r>

0824bc4c <__register_exitproc>:
 824bc4c:	defffa04 	addi	sp,sp,-24
 824bc50:	dc000315 	stw	r16,12(sp)
 824bc54:	04020974 	movhi	r16,2085
 824bc58:	840fba04 	addi	r16,r16,16104
 824bc5c:	80c00017 	ldw	r3,0(r16)
 824bc60:	dc400415 	stw	r17,16(sp)
 824bc64:	dfc00515 	stw	ra,20(sp)
 824bc68:	18805217 	ldw	r2,328(r3)
 824bc6c:	2023883a 	mov	r17,r4
 824bc70:	10003726 	beq	r2,zero,824bd50 <__register_exitproc+0x104>
 824bc74:	10c00117 	ldw	r3,4(r2)
 824bc78:	010007c4 	movi	r4,31
 824bc7c:	20c00e16 	blt	r4,r3,824bcb8 <__register_exitproc+0x6c>
 824bc80:	1a000044 	addi	r8,r3,1
 824bc84:	8800221e 	bne	r17,zero,824bd10 <__register_exitproc+0xc4>
 824bc88:	18c00084 	addi	r3,r3,2
 824bc8c:	18c7883a 	add	r3,r3,r3
 824bc90:	18c7883a 	add	r3,r3,r3
 824bc94:	12000115 	stw	r8,4(r2)
 824bc98:	10c7883a 	add	r3,r2,r3
 824bc9c:	19400015 	stw	r5,0(r3)
 824bca0:	0005883a 	mov	r2,zero
 824bca4:	dfc00517 	ldw	ra,20(sp)
 824bca8:	dc400417 	ldw	r17,16(sp)
 824bcac:	dc000317 	ldw	r16,12(sp)
 824bcb0:	dec00604 	addi	sp,sp,24
 824bcb4:	f800283a 	ret
 824bcb8:	00820974 	movhi	r2,2085
 824bcbc:	10adbb04 	addi	r2,r2,-18708
 824bcc0:	10002626 	beq	r2,zero,824bd5c <__register_exitproc+0x110>
 824bcc4:	01006404 	movi	r4,400
 824bcc8:	d9400015 	stw	r5,0(sp)
 824bccc:	d9800115 	stw	r6,4(sp)
 824bcd0:	d9c00215 	stw	r7,8(sp)
 824bcd4:	824b6ec0 	call	824b6ec <malloc>
 824bcd8:	d9400017 	ldw	r5,0(sp)
 824bcdc:	d9800117 	ldw	r6,4(sp)
 824bce0:	d9c00217 	ldw	r7,8(sp)
 824bce4:	10001d26 	beq	r2,zero,824bd5c <__register_exitproc+0x110>
 824bce8:	81000017 	ldw	r4,0(r16)
 824bcec:	10000115 	stw	zero,4(r2)
 824bcf0:	02000044 	movi	r8,1
 824bcf4:	22405217 	ldw	r9,328(r4)
 824bcf8:	0007883a 	mov	r3,zero
 824bcfc:	12400015 	stw	r9,0(r2)
 824bd00:	20805215 	stw	r2,328(r4)
 824bd04:	10006215 	stw	zero,392(r2)
 824bd08:	10006315 	stw	zero,396(r2)
 824bd0c:	883fde26 	beq	r17,zero,824bc88 <__register_exitproc+0x3c>
 824bd10:	18c9883a 	add	r4,r3,r3
 824bd14:	2109883a 	add	r4,r4,r4
 824bd18:	1109883a 	add	r4,r2,r4
 824bd1c:	21802215 	stw	r6,136(r4)
 824bd20:	01800044 	movi	r6,1
 824bd24:	12406217 	ldw	r9,392(r2)
 824bd28:	30cc983a 	sll	r6,r6,r3
 824bd2c:	4992b03a 	or	r9,r9,r6
 824bd30:	12406215 	stw	r9,392(r2)
 824bd34:	21c04215 	stw	r7,264(r4)
 824bd38:	01000084 	movi	r4,2
 824bd3c:	893fd21e 	bne	r17,r4,824bc88 <__register_exitproc+0x3c>
 824bd40:	11006317 	ldw	r4,396(r2)
 824bd44:	218cb03a 	or	r6,r4,r6
 824bd48:	11806315 	stw	r6,396(r2)
 824bd4c:	003fce06 	br	824bc88 <__register_exitproc+0x3c>
 824bd50:	18805304 	addi	r2,r3,332
 824bd54:	18805215 	stw	r2,328(r3)
 824bd58:	003fc606 	br	824bc74 <__register_exitproc+0x28>
 824bd5c:	00bfffc4 	movi	r2,-1
 824bd60:	003fd006 	br	824bca4 <__register_exitproc+0x58>

0824bd64 <__call_exitprocs>:
 824bd64:	defff504 	addi	sp,sp,-44
 824bd68:	df000915 	stw	fp,36(sp)
 824bd6c:	dd400615 	stw	r21,24(sp)
 824bd70:	dc800315 	stw	r18,12(sp)
 824bd74:	dfc00a15 	stw	ra,40(sp)
 824bd78:	ddc00815 	stw	r23,32(sp)
 824bd7c:	dd800715 	stw	r22,28(sp)
 824bd80:	dd000515 	stw	r20,20(sp)
 824bd84:	dcc00415 	stw	r19,16(sp)
 824bd88:	dc400215 	stw	r17,8(sp)
 824bd8c:	dc000115 	stw	r16,4(sp)
 824bd90:	d9000015 	stw	r4,0(sp)
 824bd94:	2839883a 	mov	fp,r5
 824bd98:	04800044 	movi	r18,1
 824bd9c:	057fffc4 	movi	r21,-1
 824bda0:	00820974 	movhi	r2,2085
 824bda4:	108fba04 	addi	r2,r2,16104
 824bda8:	12000017 	ldw	r8,0(r2)
 824bdac:	45005217 	ldw	r20,328(r8)
 824bdb0:	44c05204 	addi	r19,r8,328
 824bdb4:	a0001c26 	beq	r20,zero,824be28 <__call_exitprocs+0xc4>
 824bdb8:	a0800117 	ldw	r2,4(r20)
 824bdbc:	15ffffc4 	addi	r23,r2,-1
 824bdc0:	b8000d16 	blt	r23,zero,824bdf8 <__call_exitprocs+0x94>
 824bdc4:	14000044 	addi	r16,r2,1
 824bdc8:	8421883a 	add	r16,r16,r16
 824bdcc:	8421883a 	add	r16,r16,r16
 824bdd0:	84402004 	addi	r17,r16,128
 824bdd4:	a463883a 	add	r17,r20,r17
 824bdd8:	a421883a 	add	r16,r20,r16
 824bddc:	e0001e26 	beq	fp,zero,824be58 <__call_exitprocs+0xf4>
 824bde0:	80804017 	ldw	r2,256(r16)
 824bde4:	e0801c26 	beq	fp,r2,824be58 <__call_exitprocs+0xf4>
 824bde8:	bdffffc4 	addi	r23,r23,-1
 824bdec:	843fff04 	addi	r16,r16,-4
 824bdf0:	8c7fff04 	addi	r17,r17,-4
 824bdf4:	bd7ff91e 	bne	r23,r21,824bddc <__call_exitprocs+0x78>
 824bdf8:	00820974 	movhi	r2,2085
 824bdfc:	10adc004 	addi	r2,r2,-18688
 824be00:	10000926 	beq	r2,zero,824be28 <__call_exitprocs+0xc4>
 824be04:	a0800117 	ldw	r2,4(r20)
 824be08:	1000301e 	bne	r2,zero,824becc <__call_exitprocs+0x168>
 824be0c:	a0800017 	ldw	r2,0(r20)
 824be10:	10003226 	beq	r2,zero,824bedc <__call_exitprocs+0x178>
 824be14:	a009883a 	mov	r4,r20
 824be18:	98800015 	stw	r2,0(r19)
 824be1c:	824b7000 	call	824b700 <free>
 824be20:	9d000017 	ldw	r20,0(r19)
 824be24:	a03fe41e 	bne	r20,zero,824bdb8 <__call_exitprocs+0x54>
 824be28:	dfc00a17 	ldw	ra,40(sp)
 824be2c:	df000917 	ldw	fp,36(sp)
 824be30:	ddc00817 	ldw	r23,32(sp)
 824be34:	dd800717 	ldw	r22,28(sp)
 824be38:	dd400617 	ldw	r21,24(sp)
 824be3c:	dd000517 	ldw	r20,20(sp)
 824be40:	dcc00417 	ldw	r19,16(sp)
 824be44:	dc800317 	ldw	r18,12(sp)
 824be48:	dc400217 	ldw	r17,8(sp)
 824be4c:	dc000117 	ldw	r16,4(sp)
 824be50:	dec00b04 	addi	sp,sp,44
 824be54:	f800283a 	ret
 824be58:	a0800117 	ldw	r2,4(r20)
 824be5c:	80c00017 	ldw	r3,0(r16)
 824be60:	10bfffc4 	addi	r2,r2,-1
 824be64:	15c01426 	beq	r2,r23,824beb8 <__call_exitprocs+0x154>
 824be68:	80000015 	stw	zero,0(r16)
 824be6c:	183fde26 	beq	r3,zero,824bde8 <__call_exitprocs+0x84>
 824be70:	95c8983a 	sll	r4,r18,r23
 824be74:	a0806217 	ldw	r2,392(r20)
 824be78:	a5800117 	ldw	r22,4(r20)
 824be7c:	2084703a 	and	r2,r4,r2
 824be80:	10000b26 	beq	r2,zero,824beb0 <__call_exitprocs+0x14c>
 824be84:	a0806317 	ldw	r2,396(r20)
 824be88:	2088703a 	and	r4,r4,r2
 824be8c:	20000c1e 	bne	r4,zero,824bec0 <__call_exitprocs+0x15c>
 824be90:	89400017 	ldw	r5,0(r17)
 824be94:	d9000017 	ldw	r4,0(sp)
 824be98:	183ee83a 	callr	r3
 824be9c:	a0800117 	ldw	r2,4(r20)
 824bea0:	15bfbf1e 	bne	r2,r22,824bda0 <__call_exitprocs+0x3c>
 824bea4:	98800017 	ldw	r2,0(r19)
 824bea8:	153fcf26 	beq	r2,r20,824bde8 <__call_exitprocs+0x84>
 824beac:	003fbc06 	br	824bda0 <__call_exitprocs+0x3c>
 824beb0:	183ee83a 	callr	r3
 824beb4:	003ff906 	br	824be9c <__call_exitprocs+0x138>
 824beb8:	a5c00115 	stw	r23,4(r20)
 824bebc:	003feb06 	br	824be6c <__call_exitprocs+0x108>
 824bec0:	89000017 	ldw	r4,0(r17)
 824bec4:	183ee83a 	callr	r3
 824bec8:	003ff406 	br	824be9c <__call_exitprocs+0x138>
 824becc:	a0800017 	ldw	r2,0(r20)
 824bed0:	a027883a 	mov	r19,r20
 824bed4:	1029883a 	mov	r20,r2
 824bed8:	003fb606 	br	824bdb4 <__call_exitprocs+0x50>
 824bedc:	0005883a 	mov	r2,zero
 824bee0:	003ffb06 	br	824bed0 <__call_exitprocs+0x16c>

0824bee4 <_vfprintf_r>:
 824bee4:	deffff04 	addi	sp,sp,-4
 824bee8:	dfc00015 	stw	ra,0(sp)
 824beec:	8206a980 	call	8206a98 <___vfprintf_internal_r>
 824bef0:	dfc00017 	ldw	ra,0(sp)
 824bef4:	dec00104 	addi	sp,sp,4
 824bef8:	f800283a 	ret

0824befc <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 824befc:	defffd04 	addi	sp,sp,-12
 824bf00:	df000215 	stw	fp,8(sp)
 824bf04:	df000204 	addi	fp,sp,8
 824bf08:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 824bf0c:	d0206b45 	stb	zero,-32339(gp)
 824bf10:	e0bfff17 	ldw	r2,-4(fp)
 824bf14:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 824bf18:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 824bf1c:	10000226 	beq	r2,zero,824bf28 <_exit+0x2c>
    ALT_SIM_FAIL();
 824bf20:	002af070 	cmpltui	zero,zero,43969
 824bf24:	00000106 	br	824bf2c <_exit+0x30>
  } else {
    ALT_SIM_PASS();
 824bf28:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 824bf2c:	003fff06 	br	824bf2c <_exit+0x30>
