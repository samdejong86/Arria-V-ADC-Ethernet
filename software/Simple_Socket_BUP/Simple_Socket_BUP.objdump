
Simple_Socket_BUP.elf:     file format elf32-littlenios2
Simple_Socket_BUP.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x08200200

Program Header:
    LOAD off    0x00001000 vaddr 0x04a80000 paddr 0x04a80000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x
    LOAD off    0x00001060 vaddr 0x08200060 paddr 0x08200060 align 2**12
         filesz 0x00053f54 memsz 0x0005ea04 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  04a80000  04a80000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   000001a0  08200060  08200060  00001060  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0004bcd4  08200200  08200200  00001200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00005ff4  0824bed4  0824bed4  0004ced4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000020ec  08251ec8  08251ec8  00052ec8  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0000aab0  08253fb4  08253fb4  00054fb4  2**2
                  ALLOC, SMALL_DATA
  6 .ext_flash    00000000  04a80020  04a80020  00054fb4  2**0
                  CONTENTS
  7 .descriptor_memory 00000000  08000000  08000000  00054fb4  2**0
                  CONTENTS
  8 .onchip_ram   00000000  0825ea64  0825ea64  00054fb4  2**0
                  CONTENTS
  9 .comment      00000023  00000000  00000000  00054fb4  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00001d18  00000000  00000000  00054fd8  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   00067021  00000000  00000000  00056cf0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00015607  00000000  00000000  000bdd11  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0001da9c  00000000  00000000  000d3318  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00008908  00000000  00000000  000f0db4  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    0000bace  00000000  00000000  000f96bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0001ef9a  00000000  00000000  0010518a  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_alt_sim_info 00000050  00000000  00000000  00124124  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00001e98  00000000  00000000  00124178  2**3
                  CONTENTS, READONLY, DEBUGGING
 19 .thread_model 00000006  00000000  00000000  00130802  2**0
                  CONTENTS, READONLY
 20 .cpu          00000003  00000000  00000000  00130808  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  0013080b  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  0013080c  2**0
                  CONTENTS, READONLY
 23 .sysid_hash   00000004  00000000  00000000  0013080d  2**0
                  CONTENTS, READONLY
 24 .sysid_base   00000004  00000000  00000000  00130811  2**0
                  CONTENTS, READONLY
 25 .sysid_time   00000004  00000000  00000000  00130815  2**0
                  CONTENTS, READONLY
 26 .stderr_dev   0000000b  00000000  00000000  00130819  2**0
                  CONTENTS, READONLY
 27 .stdin_dev    0000000b  00000000  00000000  00130824  2**0
                  CONTENTS, READONLY
 28 .stdout_dev   0000000b  00000000  00000000  0013082f  2**0
                  CONTENTS, READONLY
 29 .sopc_system_name 0000001a  00000000  00000000  0013083a  2**0
                  CONTENTS, READONLY
 30 .quartus_project_dir 00000023  00000000  00000000  00130854  2**0
                  CONTENTS, READONLY
 31 .jdi          00006f06  00000000  00000000  00130877  2**0
                  CONTENTS, READONLY
 32 .sopcinfo     000bd54f  00000000  00000000  0013777d  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
04a80000 l    d  .entry	00000000 .entry
08200060 l    d  .exceptions	00000000 .exceptions
08200200 l    d  .text	00000000 .text
0824bed4 l    d  .rodata	00000000 .rodata
08251ec8 l    d  .rwdata	00000000 .rwdata
08253fb4 l    d  .bss	00000000 .bss
04a80020 l    d  .ext_flash	00000000 .ext_flash
08000000 l    d  .descriptor_memory	00000000 .descriptor_memory
0825ea64 l    d  .onchip_ram	00000000 .onchip_ram
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simple_Socket_BUP_bsp//obj/HAL/src/crt0.o
08200244 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
082000d4 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_error_handler.c
00000000 l    df *ABS*	00000000 iniche_init.c
00000000 l    df *ABS*	00000000 led.c
00000000 l    df *ABS*	00000000 network_utilities.c
00000000 l    df *ABS*	00000000 simple_socket_server.c
08253fc0 l     O .bss	00000004 SSSCommand.4950
082541d0 l     O .bss	000005f0 conn.4980
00000000 l    df *ABS*	00000000 tse_my_system.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 ctype_.c
0824d25b l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 getc.c
00000000 l    df *ABS*	00000000 impure.c
08252000 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 perror.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 rget.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 strchr.c
00000000 l    df *ABS*	00000000 strerror.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strstr.c
08203ff8 l     F .text	00000104 critical_factorization
082040fc l     F .text	000003b0 two_way_long_needle
00000000 l    df *ABS*	00000000 vfprintf.c
0824db2a l     O .rodata	00000010 zeroes.4389
0824db3a l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 u_strerr.c
00000000 l    df *ABS*	00000000 vfprintf.c
0824db4a l     O .rodata	00000010 zeroes.4404
08208c50 l     F .text	000000bc __sbprintf
0824db5a l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 dtoa.c
08208fb8 l     F .text	00000200 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
0820aae8 l     F .text	00000008 __fp_unlock
0820aafc l     F .text	0000019c __sinit.part.1
0820ac98 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fputs.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 locale.c
08252444 l     O .rwdata	00000020 lc_ctype_charset
08252424 l     O .rwdata	00000020 lc_message_charset
08252464 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 mprec.c
0824db88 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 refill.c
0820dbb8 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 vfprintf.c
0824dcbc l     O .rodata	00000010 blanks.4332
0824dcac l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 vfprintf.c
0820f494 l     F .text	000000fc __sprint_r.part.0
0824dcdc l     O .rodata	00000010 blanks.4348
0824dccc l     O .rodata	00000010 zeroes.4349
08210a20 l     F .text	000000bc __sbprintf
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_fstat.c
0821448c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
08214578 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_lseek.c
08214658 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
08253e80 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_env_lock.c
08253e84 l     O .rwdata	00000004 lockid
08253ff8 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
08253e88 l     O .rwdata	00000004 lockid
08254000 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
082161d0 l     F .text	00000048 OS_InitMisc
08216218 l     F .text	0000006c OS_InitRdyList
08216384 l     F .text	000000e4 OS_InitTCBList
082160f0 l     F .text	000000e0 OS_InitEventList
08216284 l     F .text	00000080 OS_InitTaskIdle
08216304 l     F .text	00000080 OS_InitTaskStat
082165f4 l     F .text	00000074 OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
0821831c l     F .text	000000f4 OS_FlagTaskRdy
082180dc l     F .text	00000160 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
0821c3cc l     F .text	00000034 alt_dev_reg
082528a4 l     O .rwdata	0000106c jtag_uart_0
08253910 l     O .rwdata	00000124 lcd
08253a34 l     O .rwdata	00000030 sgdma_rx
08253a64 l     O .rwdata	00000030 sgdma_tx
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0821c91c l     F .text	000002a4 altera_avalon_jtag_uart_irq
0821cbc0 l     F .text	00000104 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207.c
08253f04 l     O .rwdata	00000004 colstart
0821d39c l     F .text	000000b8 lcd_write_command
0821d454 l     F .text	000000d8 lcd_write_data
0821d52c l     F .text	000000d0 lcd_clear_screen
0821d5fc l     F .text	000001ec lcd_repaint_screen
0821d7e8 l     F .text	000000cc lcd_scroll_up
0821d8b4 l     F .text	000002ac lcd_handle_escape
0821e070 l     F .text	000000ac alt_lcd_16207_timeout
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
0821e2fc l     F .text	0000003c alt_get_errno
0821ef2c l     F .text	000000bc alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
0821f090 l     F .text	00000078 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_tse.c
0825405a l     O .bss	00000001 tse_system_count.4813
0825405b l     O .bss	00000001 is_init.4895
00000000 l    df *ABS*	00000000 ins_tse_mac.c
00000000 l    df *ABS*	00000000 alt_iniche_close.c
00000000 l    df *ABS*	00000000 alt_iniche_dev.c
00000000 l    df *ABS*	00000000 alt_iniche_read.c
00000000 l    df *ABS*	00000000 alt_iniche_write.c
00000000 l    df *ABS*	00000000 ipnet.c
00000000 l    df *ABS*	00000000 ipstart.c
082547e8 l     O .bss	0000003c closers
08254070 l     O .bss	00000004 nclosers
00000000 l    df *ABS*	00000000 igmp_cmn.c
00000000 l    df *ABS*	00000000 bsdsock.c
00000000 l    df *ABS*	00000000 cksum.c
08253f20 l     O .rwdata	00000004 cksum_select
00000000 l    df *ABS*	00000000 in_utils.c
08254824 l     O .bss	00000018 tistring
00000000 l    df *ABS*	00000000 netmain.c
00000000 l    df *ABS*	00000000 tk_crnos.c
00000000 l    df *ABS*	00000000 dhcpclnt.c
0822b9f4 l     F .text	000000ac dh_getlong
00000000 l    df *ABS*	00000000 dhcputil.c
00000000 l    df *ABS*	00000000 pktalloc.c
00000000 l    df *ABS*	00000000 q.c
00000000 l    df *ABS*	00000000 udp_open.c
00000000 l    df *ABS*	00000000 asm_cksum.o
0822d590 l       .text	00000000 done
0822d420 l       .text	00000000 asm1
0822d54c l       .text	00000000 loop0
0822d448 l       .text	00000000 loop
0822d568 l       .text	00000000 fold
00000000 l    df *ABS*	00000000 brdutils.c
082540dc l     O .bss	00000004 kbd_init.4233
082540d8 l     O .bss	00000004 cpu_statusreg
00000000 l    df *ABS*	00000000 osportco.c
00000000 l    df *ABS*	00000000 targnios.c
00000000 l    df *ABS*	00000000 nptcp.c
08254110 l     O .bss	00000004 in_tcptick
00000000 l    df *ABS*	00000000 rawsock.c
00000000 l    df *ABS*	00000000 sockcall.c
08231910 l     F .text	0000008c sockargs
08230c34 l     F .text	000001dc t_getname
00000000 l    df *ABS*	00000000 socket.c
00000000 l    df *ABS*	00000000 socket2.c
00000000 l    df *ABS*	00000000 soselect.c
00000000 l    df *ABS*	00000000 tcp_in.c
00000000 l    df *ABS*	00000000 tcp_out.c
08239404 l     F .text	000000c8 bld_options
00000000 l    df *ABS*	00000000 tcp_subr.c
00000000 l    df *ABS*	00000000 tcp_timr.c
00000000 l    df *ABS*	00000000 tcp_usr.c
00000000 l    df *ABS*	00000000 tcpport.c
00000000 l    df *ABS*	00000000 udpsock.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
0823bc00 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dev.c
0823bd84 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0823bdb0 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0823c280 l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
0823c3c0 l     F .text	0000003c alt_get_errno
0823c3fc l     F .text	000000c4 alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
0823c614 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_remap_cached.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_uncached_free.c
00000000 l    df *ABS*	00000000 alt_uncached_malloc.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
0823cb5c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000040 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 allports.c
08254148 l     O .bss	00000004 inside_pktdemux
00000000 l    df *ABS*	00000000 timeouts.c
0823d498 l     F .text	0000018c check_interval_timers
08254154 l     O .bss	00000004 numtimers
00000000 l    df *ABS*	00000000 tk_misc.c
00000000 l    df *ABS*	00000000 alt_iniche_fcntl.c
00000000 l    df *ABS*	00000000 et_arp.c
08254158 l     O .bss	00000004 arp_timer
08254160 l     O .bss	00000004 cachetime
00000000 l    df *ABS*	00000000 iface.c
00000000 l    df *ABS*	00000000 ip.c
08253f9c l     O .rwdata	00000004 uid
00000000 l    df *ABS*	00000000 ip_reasm.c
00000000 l    df *ABS*	00000000 ipdemux.c
00000000 l    df *ABS*	00000000 ipmc.c
00000000 l    df *ABS*	00000000 ipport.c
00000000 l    df *ABS*	00000000 ipraw.c
00000000 l    df *ABS*	00000000 iproute.c
00000000 l    df *ABS*	00000000 udp.c
082541a0 l     O .bss	00000002 usocket
00000000 l    df *ABS*	00000000 igmp.c
00000000 l    df *ABS*	00000000 igmp2.c
00000000 l    df *ABS*	00000000 ipopt.c
00000000 l    df *ABS*	00000000 u_mctest.c
08253fa4 l     O .rwdata	00000004 iCounter.4951
00000000 l    df *ABS*	00000000 dhcsetup.c
00000000 l    df *ABS*	00000000 memdev.c
00000000 l    df *ABS*	00000000 parseip.c
0825483c l     O .bss	0000001e nearBuf.4578
00000000 l    df *ABS*	00000000 tcpcksum.c
00000000 l    df *ABS*	00000000 in_pcb.c
00000000 l    df *ABS*	00000000 vfsfiles.c
00000000 l    df *ABS*	00000000 vfsport.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_fcntl.c
0824a120 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 icmp.c
08253e44 l     O .rwdata	00000018 dsts
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vprintf.c
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 vfprintfr_1.c
00000000 l    df *ABS*	00000000 alt_exit.c
0820354c g     F .text	00000018 putchar
0825e560 g     O .bss	00000014 soq
0820d4dc g     F .text	00000074 _mprec_log10
082203fc g     F .text	000000d8 alt_tse_get_mac_info
08253ed6 g     O .rwdata	00000002 OSTaskNameSize
0820d5c8 g     F .text	0000008c __any_on
08210fbc g     F .text	00000054 _isatty_r
0824db94 g     O .rodata	00000028 __mprec_tinytens
0823f228 g     F .text	00000724 ip_write_internal
08214768 g     F .text	000000bc alt_main
0824b6b8 g     F .text	00000090 strcpy
0822cd3c g     F .text	000000ac pk_free
08203564 g     F .text	000000c0 _puts_r
0825e70c g     O .bss	00000100 alt_irq
08253ce4 g     O .rwdata	00000009 rtp_priority
08211010 g     F .text	00000060 _lseek_r
0824b2c4 g     F .text	00000314 icmp_timex
0822e638 g     F .text	00000044 m_freem
08249ad0 g     F .text	00000048 vgetc
0822d6f0 g     F .text	00000020 clock_c
08254128 g     O .bss	00000004 tcp_optionbuf
0823ed48 g     F .text	00000070 if_getbynum
08218b3c g     F .text	000000cc OS_MemInit
082540c8 g     O .bss	00000004 dsc_rlyerrs
082540b8 g     O .bss	00000004 dsc_releases
082297a0 g     F .text	0000006c TK_OSTaskQuery
0822d400 g       .text	00000000 asm_cksum
0822400c g     F .text	000000f0 marvell_cfg_rgmii
0821c36c g     F .text	00000060 OSTimeSet
082499d8 g     F .text	000000f8 vgetc_locked
0822df28 g     F .text	00000020 post_task_setup
08242888 g     F .text	00000358 ipr_stats
0823ac2c g     F .text	00000118 tcp_attach
08253f30 g     O .rwdata	00000004 reqlist_len
0822f9f8 g     F .text	00000078 tcp_tick
082289f4 g     F .text	0000007c print_ipad
082296a8 g     F .text	000000f8 tcp_wakeup
08212efc g     F .text	00000088 .hidden __eqdf2
08253fb8 g     O .bss	00000004 last_flash_sector_offset
08254074 g     O .bss	00000004 igmp_timers_are_running
08200d98 g     F .text	000000e4 led_bit_toggle
08237e38 g     F .text	0000012c tcp_pulloutofband
082215f8 g     F .text	00000210 alt_tse_phy_print_profile
08214e44 g     F .text	00000610 OSEventPendMulti
0825ea64 g       *ABS*	00000000 __alt_heap_start
0823cee0 g     F .text	00000024 OSTaskCreateHook
0822c578 g     F .text	00000068 dhc_ifacedone
08223dac g     F .text	00000098 marvell_phy_cfg
08242c30 g     F .text	00000380 ip_rcv
0824977c g     F .text	0000014c vfseek
08233fe4 g     F .text	00000108 soqremque
08244804 g     F .text	000007a8 udpdemux
08225734 g     F .text	00000104 tse_mac_close
082033a0 g     F .text	0000003c printf
08254174 g     O .bss	00000004 rt_mib
08253eae g     O .rwdata	00000002 OSMboxEn
0822c498 g     F .text	00000058 dhc_state_init
0824bbd4 g     F .text	0000001c vsprintf
0821e45c g     F .text	00000110 alt_avalon_sgdma_do_sync_transfer
082154ac g     F .text	0000004c OSIntEnter
082110d0 g     F .text	0000009c _wcrtomb_r
0820df48 g     F .text	0000005c __sseek
0820ae38 g     F .text	00000010 __sinit
08243a9c g     F .text	0000010c in_delmulti
08208d0c g     F .text	00000140 __swbuf_r
0825418c g     O .bss	00000004 so_evtmap_create
08253ebe g     O .rwdata	00000002 OSQEn
08247e38 g     F .text	00000088 in_pcballoc
08253f4c g     O .rwdata	00000002 socket_defaults
0820ba54 g     F .text	0000007c _setlocale_r
0823dc24 g     F .text	00000454 send_arp
0820aca0 g     F .text	00000068 __sfmoreglue
08248894 g     F .text	00000338 vfopen_locked
08253fc4 g     O .bss	00000004 SSSLEDCommandQ
08214b18 g     F .text	000000cc __malloc_unlock
0823cf48 g     F .text	00000020 OSTaskStatHook
0823d3b8 g     F .text	00000054 prep_modules
08227ff4 g     F .text	0000013c bsd_i_sockoptlen
08254008 g     O .bss	00000001 OSLockNesting
08253f28 g     O .rwdata	00000004 xids
08203f44 g     F .text	0000001c strerror
08220640 g     F .text	00000a88 getPHYSpeed
08248dd8 g     F .text	00000044 vfclose
0825e600 g     O .bss	0000002c tcb
08253efc g     O .rwdata	00000002 OSDataSize
0823c7b0 g     F .text	00000034 alt_remap_cached
08254009 g     O .bss	00000001 OSRunning
0823ea90 g     F .text	000002b8 grat_arp
08201118 g     F .text	0000005c get_ip_addr
082478c0 g     F .text	00000094 inet_pton
0823ee8c g     F .text	00000090 reg_type
0825e104 g     O .bss	000000f0 dhc_states
08226e70 g     F .text	00000174 igmp_fasttimo
08248f84 g     F .text	0000005c vunlink_flag_open_files
0822c260 g     F .text	00000080 dhc_halt
0821eb74 g     F .text	000003b8 alt_avalon_sgdma_construct_descriptor_burst
082540ac g     O .bss	00000004 dsc_acks
0825e62c g     O .bss	000000e0 tcpstat
08242180 g     F .text	0000034c ip_reasm_copy_queued_fragments_into_reassy_buffer
0822eb84 g     F .text	0000009c dtom
08239304 g     F .text	00000100 tcp_setpersist
08230fd0 g     F .text	0000018c t_getsockopt
08203058 g     F .text	0000015c memmove
082540bc g     O .bss	00000004 dsc_naks
0822efd4 g     F .text	000005b0 ip_output
0823cf94 g     F .text	00000020 OSInitHookBegin
0824b5d8 g     F .text	00000054 icmp_du
08253f24 g     O .rwdata	00000004 num_net_tasks
082541b0 g     O .bss	00000004 vfiles
08253ef4 g     O .rwdata	00000002 OSTmrSize
08247050 g     F .text	00000114 dhc_main_ipset
0820ae20 g     F .text	00000018 _cleanup
08241354 g     F .text	000002b8 ip_reasm_process_first_fragment
0820c658 g     F .text	000000a8 _Balloc
08201614 g     F .text	00000198 get_board_mac_addr
0825400c g     O .bss	00000004 OSIdleCtr
08253fc8 g     O .bss	00000004 SSSLEDLightshowSem
0822300c g     F .text	000001c4 alt_tse_phy_set_adv_1000
08253f10 g     O .rwdata	00000001 max_mac_system
08245fac g     F .text	000005c8 ip_setmoptions
0821f6b0 g     F .text	000009fc alt_tse_system_add_sys
08212f84 g     F .text	000000dc .hidden __gtdf2
082473dc g     F .text	0000002c md_fseek
0823cd60 g       .text	00000000 OSStartTsk
0821693c g     F .text	000002d4 OS_TCBInit
0824160c g     F .text	00000088 ip_reassm
0822c2e0 g     F .text	000001b8 dhc_reclaim
0825e9ec g     O .bss	00000010 udp_mib
04a80000 g     F .entry	00000000 __reset
08231774 g     F .text	000000d8 t_shutdown
08202774 g     F .text	000001f0 sss_handle_receive
0823123c g     F .text	00000140 t_recvfrom
08253efa g     O .rwdata	00000002 OSTmrWheelTblSize
08246738 g     F .text	000006b4 u_mctest_run
0821e6c4 g     F .text	00000078 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
08243c0c g     F .text	00000080 prep_ifaces
08254090 g     O .bss	00000001 to_netmain
0822c9ec g     F .text	000000c4 pk_alloc
08253e9a g     O .rwdata	00000002 OSEventSize
08200a10 g     F .text	00000298 alt_SSSErrorHandler
08254010 g     O .bss	00000001 OSPrioHighRdy
08210f60 g     F .text	0000005c _fstat_r
08251ee0 g     O .rwdata	00000120 tse_mac_device
08229448 g     F .text	00000048 tk_nettick
0823cf04 g     F .text	00000024 OSTaskDelHook
08253fe8 g     O .bss	00000004 errno
082036ac g     F .text	00000014 __srget
082351e8 g     F .text	000000c4 in_pcbnotify
0820dec4 g     F .text	00000008 __seofread
0823cd40 g       .text	00000000 OSStartHighRdy
0825e1f4 g     O .bss	00000014 lilfreeq
08200248 g     F .text	00000564 alt_uCOSIIErrorHandler
08243cb4 g     F .text	0000002c evtmap_setup
0821ae08 g     F .text	000001e4 OSTaskCreateExt
08254094 g     O .bss	00000004 tcp_sleep_timeout
082349ac g     F .text	000001b8 sbdrop
08254188 g     O .bss	00000004 net_system_exit
0825e9fc g     O .bss	00000068 icmp_mib
0820e258 g     F .text	0000123c ___svfiprintf_internal_r
08239d94 g     F .text	00000074 tcp_getseq
08244098 g     F .text	000000b8 ip_raw_alloc
082238f4 g     F .text	000004b8 alt_tse_phy_set_common_speed
08217c24 g     F .text	00000060 OSFlagPendGetFlagsRdy
08253eda g     O .rwdata	00000002 OSTaskStatStkSize
0825dbd8 g     O .bss	00000010 pmac_groups
0822ab08 g     F .text	00000a84 dhc_request
08232864 g     F .text	0000074c soreceive
08216da0 g     F .text	00000308 OSFlagAccept
08219174 g     F .text	000000b8 OSQFlush
08218c08 g     F .text	00000140 OSQAccept
08253ff0 g     O .bss	00000004 alt_argv
0825be5c g       *ABS*	00000000 _gp
08242be0 g     F .text	00000050 ip_reasm_send_icmp_timex
0823ca24 g     F .text	00000138 usleep
08248e1c g     F .text	00000048 vfflush
0825e508 g     O .bss	00000040 resid_semaphore
082288b0 g     F .text	00000144 hexdump
0824121c g     F .text	000000a0 ip_reasm_incr_mem_useage
082274d4 g     F .text	00000080 igmp_leavegroup
0821ac5c g     F .text	000001ac OSTaskCreate
0821a76c g     F .text	000004f0 OSTaskChangePrio
08254004 g     O .bss	00000004 alt_heapsem
08239be0 g     F .text	000000f0 tcp_close
08216c10 g     F .text	00000190 OSDebugInit
0821afec g     F .text	00000344 OSTaskDel
08249ef0 g     F .text	0000005c vferror
0823c9cc g     F .text	00000058 alt_uncached_malloc
0821f1b4 g     F .text	00000060 tse_mac_initTransInfo2
082453e8 g     F .text	000000bc udp_alloc
08253b4c g     O .rwdata	00000180 alt_fd_list
0825a8d4 g     O .bss	00000370 OSFlagTbl
08254114 g     O .bss	00000008 mbstat
08202e18 g     F .text	00000070 _getc_r
08202e88 g     F .text	00000088 getc
08203544 g     F .text	00000008 _putchar_r
08215ed0 g     F .text	000000b8 OS_EventTaskRemove
08245bf4 g     F .text	00000144 igmpv2_chk_set_timer
08229490 g     F .text	00000030 TK_OSTimeDly
0823bf50 g     F .text	00000090 alt_find_dev
08202f10 g     F .text	00000148 memcpy
0821f428 g     F .text	00000054 tse_mac_setMIImode
082540c4 g     O .bss	00000004 dsc_rebind
0823d844 g     F .text	0000007c task_stats
082303e0 g     F .text	00000050 DOMAIN_CHECK
0822f584 g     F .text	00000038 in_broadcast
08253ec4 g     O .rwdata	00000002 OSRdyTblSize
082210c8 g     F .text	00000048 alt_tse_phy_rd_mdio_addr
082541ac g     O .bss	00000004 vfsystems
08245338 g     F .text	000000b0 udp_socket
08254064 g     O .bss	00000004 MaxMtu
08234ec4 g     F .text	00000140 sock_selscan
0820aaf0 g     F .text	0000000c _cleanup_r
082141e8 g     F .text	000000dc .hidden __floatsidf
08240ff4 g     F .text	000000c4 ip_reasm_match_frag_with_ire
08234144 g     F .text	00000058 socantrcvmore
0821f214 g     F .text	000000e4 tse_mac_sTxWrite
08201e10 g     F .text	00000964 sss_exec_command
0820335c g     F .text	00000014 perror
0823c344 g     F .text	0000007c alt_io_redirect
08213060 g     F .text	000000f4 .hidden __ltdf2
082540f0 g     O .bss	00000004 netq_intmask
08247874 g     F .text	0000004c hextoa
0824bed4 g       *ABS*	00000000 __DTOR_END__
08231570 g     F .text	00000204 t_send
0823bc3c g     F .text	000000d0 alt_close
0825411c g     O .bss	00000002 select_wait
08203624 g     F .text	00000014 puts
08228fd0 g     F .text	00000044 std_out
0825dbf8 g     O .bss	00000030 tse_iniche_dev_driver_data
08249b18 g     F .text	00000124 vfslookup_locked
08232124 g     F .text	00000098 soaccept
08214be4 g     F .text	00000120 OSEventNameGet
08253ea8 g     O .rwdata	00000002 OSFlagMax
082038e8 g     F .text	0000065c _strerror_r
0825e574 g     O .bss	0000003c tcpmib
0823199c g     F .text	00000098 t_errno
08243ce0 g     F .text	000000d8 ip_raw_open
0820dda8 g     F .text	00000074 __fpclassifyd
0822b8ec g     F .text	00000108 dhc_decline
0820d438 g     F .text	000000a4 __ratio
082154f8 g     F .text	000000f8 OSIntExit
08253fa0 g     O .rwdata	00000004 ipRoutes
08248f34 g     F .text	00000050 vfeof
08210a04 g     F .text	0000001c __vfiprintf_internal
0823a078 g     F .text	00000060 tcp_canceltimers
0822a374 g     F .text	000001e4 dhc_buildheader
08253ee2 g     O .rwdata	00000002 OSTCBSize
0821e7bc g     F .text	0000008c alt_avalon_sgdma_construct_mem_to_stream_desc_burst
08254011 g     O .bss	00000001 OSPrioCur
0821ce1c g     F .text	000002bc altera_avalon_jtag_uart_read
0824b690 g     F .text	00000014 malloc
082541a8 g     O .bss	00000004 inpcb_cachemiss
08203370 g     F .text	00000030 _printf_r
08247a34 g     F .text	000000c4 inet46_addr
082541a4 g     O .bss	00000004 inpcb_cachehits
08202c10 g     F .text	00000064 .hidden __udivsi3
08253b0c g     O .rwdata	0000000b tcp_outflags
0825dc28 g     O .bss	00000130 tse
082145b4 g     F .text	000000a4 isatty
082200ac g     F .text	00000168 alt_tse_sys_enable_mdio_sharing
08253ec8 g     O .rwdata	00000002 OSStkWidth
0824dbe4 g     O .rodata	000000c8 __mprec_tens
0824870c g     F .text	00000070 vf_alloc_and_link_vop
08253ebc g     O .rwdata	00000002 OSPtrSize
08254178 g     O .bss	00000004 ipr_curr_mem
08226b28 g     F .text	00000070 exit_hook
08254078 g     O .bss	00000004 igmp_cticks
0822037c g     F .text	00000080 alt_tse_get_mac_info_index
08254104 g     O .bss	00000004 mheap_sem_ptr
082381c0 g     F .text	00000048 ip4_tcpmss
0820bad0 g     F .text	0000000c __locale_charset
08253e9c g     O .rwdata	00000002 OSEventTblSize
0825e970 g     O .bss	00000014 netlist
08232fb0 g     F .text	00000098 soshutdown
0823ccb4 g       .text	00000000 OSCtxSw
0823d344 g     F .text	00000050 packet_check
0822b58c g     F .text	0000027c dhc_setip
0825e5b0 g     O .bss	00000014 mbufq
082320d4 g     F .text	00000050 soabort
08253fe4 g     O .bss	00000004 __malloc_top_pad
08254014 g     O .bss	00000004 OSTCBList
0822d02c g     F .text	00000100 qdel
0823d1a0 g     F .text	00000164 station_state
082441dc g     F .text	00000154 rt_lookup
08254134 g     O .bss	00000004 alt_fd_list_lock
08253e68 g     O .rwdata	00000004 __mb_cur_max
08227554 g     F .text	00000318 igmp_validate
0820bb00 g     F .text	0000000c _localeconv_r
08226884 g     F .text	000002a4 ip_startup
082306ec g     F .text	00000254 t_accept
08233bdc g     F .text	00000098 soisdisconnecting
0820ca64 g     F .text	0000003c __i2b
0820b410 g     F .text	000004bc __sfvwrite_r
0821e8f4 g     F .text	0000005c alt_avalon_sgdma_stop
082262c4 g     F .text	000003a4 pktdemux
0825ac44 g     O .bss	00000c30 OSMemTbl
08254018 g     O .bss	00000001 OSTickStepState
08221168 g     F .text	00000128 alt_tse_phy_wr_mdio_reg
0822d5c8 g     F .text	00000094 kbhit
08230e10 g     F .text	000001c0 t_setsockopt
0820de1c g     F .text	00000054 _sbrk_r
08253ccc g     O .rwdata	00000018 icmpdu_types
08221808 g     F .text	000006a4 alt_tse_mac_group_init
08248fe0 g     F .text	00000200 vunlink
08224504 g     F .text	00000a60 tse_mac_init
08253ec0 g     O .rwdata	00000002 OSQMax
08228710 g     F .text	000000a4 ccksum
0824877c g     F .text	000000c8 vf_alloc_buffer
0825419c g     O .bss	00000004 cachedRoute
08253f34 g     O .rwdata	00000004 lilbufs
0825b874 g     O .bss	00000800 OSTaskStatStk
08247408 g     F .text	00000024 md_ftell
082287b4 g     F .text	00000054 cksum
08218778 g     F .text	000000f0 OSMemNameGet
08231d08 g     F .text	00000110 sofree
0825406c g     O .bss	00000004 ifNumber
08253ea0 g     O .rwdata	00000002 OSFlagEn
08211070 g     F .text	00000060 _read_r
08253ee6 g     O .rwdata	00000002 OSTimeTickHookEn
0823bd0c g     F .text	00000078 alt_dcache_flush
08219624 g     F .text	00000168 OSQPost
08218410 g     F .text	000000a4 OS_FlagUnlink
08253f74 g     O .rwdata	00000004 alt_max_fd
082164bc g     F .text	00000068 OS_MemCopy
08253f3c g     O .rwdata	00000004 bigbufs
0823ad44 g     F .text	000000cc tcp_disconnect
08216524 g     F .text	000000d0 OS_Sched
08210c54 g     F .text	000000f0 _fclose_r
08218688 g     F .text	000000f0 OSMemGet
0821b618 g     F .text	000001b4 OSTaskNameSet
0820aab8 g     F .text	00000030 fflush
08253fe0 g     O .bss	00000004 __malloc_max_sbrked_mem
0825401c g     O .bss	00000004 OSCtxSwCtr
0825e07c g     O .bss	00000064 igmpstats
0823cf68 g     F .text	0000002c OSTimeTickHook
0822aa24 g     F .text	000000e4 dhc_rx_offer
08228130 g     F .text	0000010c bsd_getsockopt
08253eaa g     O .rwdata	00000002 OSFlagNameSize
0825e9d4 g     O .bss	00000018 ire_stats
08200ef0 g     F .text	000001d4 LEDManagementTask
0823af7c g     F .text	000001a0 udp_soinput
0822cf7c g     F .text	000000b0 putq
08215f88 g     F .text	00000100 OS_EventTaskRemoveMulti
0825408c g     O .bss	00000004 iniche_net_ready
08211d68 g     F .text	000008ac .hidden __adddf3
08215d80 g     F .text	00000150 OS_EventTaskWaitMulti
08249ea8 g     F .text	00000048 isvfile
08233144 g     F .text	00000430 sosetopt
082292f0 g     F .text	000000e0 netmain
08238208 g     F .text	000000f8 tcp_mss
0820d1e0 g     F .text	0000010c __b2d
08247518 g     F .text	000002fc parse_ipad
082486ec g     F .text	00000020 get_vfopen_error
08253ec2 g     O .rwdata	00000002 OSQSize
08211830 g     F .text	00000538 .hidden __umoddi3
08214694 g     F .text	000000d4 lseek
0823d40c g     F .text	0000008c inet_timer
0821a0d4 g     F .text	0000020c OSSemPend
0822135c g     F .text	0000029c alt_tse_phy_add_profile_default
08222a74 g     F .text	00000598 alt_tse_phy_get_cap
08201abc g     F .text	0000028c sss_send_menu
08253e60 g     O .rwdata	00000004 _global_impure_ptr
08228c90 g     F .text	00000154 print_eth
08248bcc g     F .text	00000050 vfopen
0823c650 g     F .text	000000fc alt_read
0820d654 g     F .text	00000564 _realloc_r
082007ac g     F .text	00000264 alt_NetworkErrorHandler
08253eac g     O .rwdata	00000002 OSLowestPrio
0825ea64 g       *ABS*	00000000 __bss_end
0823c190 g     F .text	000000f0 alt_iic_isr_register
0821e338 g     F .text	00000124 alt_avalon_sgdma_do_async_transfer
0822e530 g     F .text	00000108 m_free
0823cff4 g     F .text	00000024 OSTCBInitHook
082256f4 g     F .text	00000040 tse_mac_stats
0822cab0 g     F .text	0000028c pk_validate
08253ef2 g     O .rwdata	00000002 OSTmrCfgTicksPerSec
0823c880 g     F .text	00000108 alt_tick
0824846c g     F .text	00000254 in_pcblookup
0822c690 g     F .text	000000c0 find_opt
082112b8 g     F .text	00000578 .hidden __udivdi3
0822e3a8 g     F .text	00000188 m_getnbuf
0822ce08 g     F .text	000000bc dump_buf_estats
08210ebc g     F .text	00000024 _fputwc_r
08222914 g     F .text	00000160 alt_tse_phy_check_link
08254170 g     O .bss	00000004 arpRepsOut
08253e94 g     O .rwdata	00000002 OSEventEn
0824dbbc g     O .rodata	00000028 __mprec_bigtens
0820c848 g     F .text	00000104 __s2b
08253eee g     O .rwdata	00000002 OSTmrCfgNameSize
082142c4 g     F .text	000000a8 .hidden __floatunsidf
0823d018 g     F .text	000000f4 netmain_init
08223f28 g     F .text	000000e4 marvell_cfg_sgmii
08222758 g     F .text	000001bc alt_tse_phy_restart_an
0820cf20 g     F .text	00000060 __mcmp
082540a8 g     O .bss	00000004 dsc_requests
08239628 g     F .text	00000400 tcp_respond
0823b358 g     F .text	000002d4 udp4_sockbind
082540f4 g     O .bss	00000004 old_mode
08227280 g     F .text	00000254 igmp_joingroup
0822f6b0 g     F .text	00000348 so_icmpdu
0820ae58 g     F .text	00000018 __fp_lock_all
082541bc g     O .bss	00000004 vfs_dir_stale
0823c144 g     F .text	0000004c alt_ic_irq_enabled
0825dbe8 g     O .bss	00000010 pphy_profiles
082424cc g     F .text	000000d8 ip_reasm_process_timer_tick
08249f4c g     F .text	00000058 vclearerr
08228630 g     F .text	000000e0 bsd_setsockopt
0822eb30 g     F .text	00000054 mbuf_len
0821823c g     F .text	000000e0 OS_FlagInit
0823c7e4 g     F .text	0000009c alt_alarm_stop
08249c84 g     F .text	000001cc strippath
08253f2c g     O .rwdata	00000004 reqlist
08229534 g     F .text	00000174 tcp_sleep
0824bb3c g     F .text	0000001c strtol
08229bc4 g     F .text	000007b0 dhc_upcall
0823ae10 g     F .text	000000d0 tcp_usrclosed
08000000 g       *ABS*	00000000 __alt_mem_descriptor_memory
082540e0 g     O .bss	00000004 cticks_factor
08253ed0 g     O .rwdata	00000002 OSTaskIdleStkSize
08247f18 g     F .text	00000210 in_pcbbind
08254138 g     O .bss	00000004 alt_irq_active
08219d0c g     F .text	000000b0 OSSemAccept
0821897c g     F .text	000000d8 OSMemPut
082184b4 g     F .text	000001d4 OSMemCreate
08254020 g     O .bss	00000004 OSIdleCtrMax
0820012c g     F .exceptions	000000d4 alt_irq_handler
08253b24 g     O .rwdata	00000028 alt_dev_null
08253f4e g     O .rwdata	00000001 tcprexmtthresh
08253ee4 g     O .rwdata	00000002 OSTicksPerSec
0823ef1c g     F .text	00000094 if_killsocks
0823f94c g     F .text	00000220 ip_write
08242fb0 g     F .text	000005cc ip_rcv_phase2
08230bf0 g     F .text	00000044 t_getsockname
08230940 g     F .text	0000026c t_connect
08253f48 g     O .rwdata	00000004 TCPTV_MSL
0825e208 g     O .bss	00000010 memestats
08222640 g     F .text	00000118 alt_tse_phy_init
0822d65c g     F .text	0000005c getch
08253dc4 g     O .rwdata	00000080 vfs_root_path
08230bac g     F .text	00000044 t_getpeername
0821e950 g     F .text	00000064 alt_avalon_sgdma_check_descriptor_status
082412bc g     F .text	00000098 ip_reasm_decr_mem_useage
082342d0 g     F .text	00000088 soreserve
0823ccb4 g       .text	00000000 OSIntCtxSw
0822e16c g     F .text	00000034 npalloc
0820c94c g     F .text	00000068 __hi0bits
08254198 g     O .bss	00000004 ipraw_eps
0822c750 g     F .text	0000029c pk_init
08247208 g     F .text	0000015c md_fread
08224f64 g     F .text	000002f8 tse_mac_raw_send
08214168 g     F .text	00000080 .hidden __fixdfsi
0825e80c g     O .bss	00000064 intimers
082343a8 g     F .text	0000004c sbrelease
0823532c g     F .text	000000f0 ifd_clr
08234c64 g     F .text	00000090 sbdroprecord
08228de4 g     F .text	0000007c uslash
0823cb98 g     F .text	000000f8 alt_write
0825416c g     O .bss	00000004 arpRepsIn
08229a44 g     F .text	00000088 dhc_get_srv_ipaddr
0823d624 g     F .text	00000160 in_timerset
08254024 g     O .bss	00000004 OSTCBFreeList
0821a2e0 g     F .text	0000016c OSSemPendAbort
08238300 g     F .text	00001004 tcp_output
08254144 g     O .bss	00000004 activehost
08253f6c g     O .rwdata	00000008 alt_dev_list
082290ec g     F .text	00000204 parse_args
082540f8 g     O .bss	00000004 global_TCPwakeup_setIndx
0820ae88 g     F .text	00000044 _fputc_r
08225a38 g     F .text	00000068 write
0821ea94 g     F .text	00000080 alt_avalon_sgdma_enable_desc_poll
0822e1a0 g     F .text	00000040 npfree
082033dc g     F .text	000000a0 _putc_r
0823e2e0 g     F .text	000002c0 arpReply
08228834 g     F .text	0000007c nextarg
08253ee8 g     O .rwdata	00000002 OSVersionNbr
08241bf8 g     F .text	00000530 ip_reasm_process_subsequent_fragments
08253fac g     O .rwdata	00000004 pton_error
0825409c g     O .bss	00000004 dsc_errors
0825485c g     O .bss	00002000 SSSInitialTaskStk
0825dd58 g     O .bss	00000014 rcvdq
082352ac g     F .text	00000080 tcp_notify
082144c8 g     F .text	000000b0 fstat
08202cf4 g     F .text	00000024 fprintf
082321bc g     F .text	000000b8 soconnect
08244194 g     F .text	00000048 ip_raw_maxalloc
08213060 g     F .text	000000f4 .hidden __ledf2
082240fc g     F .text	00000078 DP83848C_link_status_read
0822a558 g     F .text	000004cc dhc_discover
082018d8 g     F .text	000000a4 SSSCreateOSDataStructs
082483e8 g     F .text	00000084 in_setpeeraddr
08253e90 g     O .rwdata	00000004 OSEndiannessTest
0822d6b8 g     F .text	00000038 clock_init
08248e64 g     F .text	000000d0 vfgets
0823d9a8 g     F .text	00000180 et_send
0820cc98 g     F .text	00000140 __pow5mult
0820f5a8 g     F .text	0000145c ___vfiprintf_internal_r
08253fd8 g     O .bss	00000004 __nlocale_changed
08202c74 g     F .text	00000058 .hidden __umodsi3
08247814 g     F .text	00000060 inet_addr
08241188 g     F .text	00000094 ip_reasm_check_mem_useage
08233048 g     F .text	000000fc sorflush
0824bb58 g     F .text	0000001c vprintf
0825e31c g     O .bss	000000fc global_tcb_ext
0823ffb8 g     F .text	00000420 ip_fragment_lc
0825dd6c g     O .bss	00000300 netstatic
082304b0 g     F .text	00000164 t_bind
0821e73c g     F .text	00000080 alt_avalon_sgdma_construct_mem_to_stream_desc
08253ea2 g     O .rwdata	00000002 OSFlagGrpSize
0822d328 g     F .text	000000d8 udp_close
0821e848 g     F .text	00000054 alt_avalon_sgdma_register_callback
0822dce0 g     F .text	000001fc alt_iniche_init
0825ea64 g       *ABS*	00000000 end
0822d8d4 g     F .text	00000088 UNLOCK_NET_RESOURCE
082242ac g     F .text	00000258 prep_tse_mac
0823115c g     F .text	000000e0 t_recv
0821db60 g     F .text	00000510 altera_avalon_lcd_16207_write
082491e0 g     F .text	0000018c vfread
082261e0 g     F .text	000000e4 netclose
08202964 g     F .text	000001b4 SSSSimpleSocketServerTask
0824b64c g     F .text	0000000c _atoi_r
0821f4cc g     F .text	000001e4 alt_tse_phy_add_profile
08253f58 g     O .rwdata	00000004 tcp_keepintvl
0821c7d4 g     F .text	00000148 altera_avalon_jtag_uart_init
0821678c g     F .text	000000e4 OS_TaskStat
082540a0 g     O .bss	00000004 dsc_discovers
08253f00 g     O .rwdata	00000004 tse_mac_name
08253ac4 g     O .rwdata	00000018 tcp_protosw
0824bed4 g       *ABS*	00000000 __CTOR_LIST__
082541b8 g     O .bss	00000004 vfopen_error
08380000 g       *ABS*	00000000 __alt_stack_pointer
0825412c g     O .bss	00000004 tcp_maxidle
082540cc g     O .bss	00000004 firstudp
0821eb14 g     F .text	00000060 alt_avalon_sgdma_disable_desc_poll
0821f108 g     F .text	0000007c alt_avalon_timer_sc_init
0821436c g     F .text	00000064 .hidden __clzsi2
0821d0d8 g     F .text	000002c4 altera_avalon_jtag_uart_write
0821e56c g     F .text	00000074 alt_avalon_sgdma_construct_mem_to_mem_desc
0820ae48 g     F .text	00000004 __sfp_lock_acquire
0820c4f8 g     F .text	000000e4 memchr
08216468 g     F .text	00000054 OS_MemClr
08206a3c g     F .text	000021f8 ___vfprintf_internal_r
0823cd84 g     F .text	0000015c OSTaskStkInit
082036c0 g     F .text	00000058 _sprintf_r
0821e664 g     F .text	00000060 alt_avalon_sgdma_construct_stream_to_mem_desc
0820b100 g     F .text	00000310 _free_r
08245d38 g     F .text	00000140 igmpv2_chk4_rtr_alert_opt
0820badc g     F .text	00000010 __locale_mb_cur_max
0823184c g     F .text	000000c4 t_socketclose
0825685c g     O .bss	00002000 LED7SegLightshowTaskStk
08215ad8 g     F .text	00000198 OS_EventTaskRdy
0824bd08 g     F .text	00000180 __call_exitprocs
08203638 g     F .text	00000074 __srget_r
0822525c g     F .text	000000ac tse_sgdmaRx_isr
08254028 g     O .bss	00000001 OSCPUUsage
0825e06c g     O .bss	00000010 nets
0822d810 g     F .text	000000c4 LOCK_NET_RESOURCE
0822b808 g     F .text	000000e4 dhc_resetip
08253fd4 g     O .bss	00000004 __mlocale_changed
082254b4 g     F .text	00000240 tse_mac_rcv
08230430 g     F .text	00000080 t_socket
08253e6c g     O .rwdata	00000004 __malloc_sbrk_base
08200200 g     F .text	00000048 _start
0823d960 g     F .text	00000048 etainit
0825413c g     O .bss	00000004 _alt_tick_rate
0823d394 g     F .text	00000024 mcastlist
0821922c g     F .text	0000028c OSQPend
082044ac g     F .text	000003b0 strstr
0825e218 g     O .bss	000000f0 pktlog
082458d4 g     F .text	00000134 igmpv2_process_report
08235494 g     F .text	00000078 ifd_isset
082446f0 g     F .text	00000114 del_route
0821e9b4 g     F .text	00000054 alt_avalon_sgdma_open
08206a34 g     F .text	00000008 _user_strerror
0821bed8 g     F .text	00000104 OSTimeDly
082010c4 g     F .text	00000054 get_mac_addr
08231c38 g     F .text	000000d0 solisten
0820cdd8 g     F .text	00000148 __lshift
08254140 g     O .bss	00000004 _alt_nticks
08221290 g     F .text	000000cc alt_tse_phy_rd_mdio_reg
082259c8 g     F .text	00000070 read
0821c438 g     F .text	00000238 alt_sys_init
08239cd0 g     F .text	0000004c tcp_quench
0820e088 g     F .text	000001d0 __ssprint_r
08228e60 g     F .text	00000170 ns_printf
0823edb8 g     F .text	000000d4 isbcast
0822d95c g     F .text	0000024c TK_NEWTASK
0824bbf0 g     F .text	00000118 __register_exitproc
08254029 g     O .bss	00000001 OSTaskCtr
082410b8 g     F .text	000000d0 ip_reasm_determine_type_of_frag
08254058 g     O .bss	00000001 phy_profile_count
0824b748 g     F .text	000000d0 strncmp
08220308 g     F .text	00000074 alt_tse_get_mac_group_index
0821bfdc g     F .text	00000160 OSTimeDlyHMSM
08243db8 g     F .text	000000bc ip_raw_close
0820caa0 g     F .text	000001f8 __multiply
08253d14 g     O .rwdata	000000b0 mdlist
0821ccc4 g     F .text	00000068 altera_avalon_jtag_uart_close
08226d90 g     F .text	000000e0 igmp_input
0823fef0 g     F .text	000000c8 ip_raw_write
0824936c g     F .text	000003b0 vfwrite_locked
0824b818 g     F .text	000000ec strncpy
082540a4 g     O .bss	00000004 dsc_offers
082547c0 g     O .bss	00000028 __malloc_current_mallinfo
08253e96 g     O .rwdata	00000002 OSEventMax
08247af8 g     F .text	0000006c inet_setport
0820d2ec g     F .text	0000014c __d2b
0821a44c g     F .text	00000110 OSSemPost
08237cb0 g     F .text	00000188 tcp_dooptions
08253fcc g     O .bss	00000004 SSSLEDEventFlag
08233ad8 g     F .text	00000104 soisconnected
0821567c g     F .text	000000dc OSSchedUnlock
08243c8c g     F .text	00000028 netexit
08201174 g     F .text	000001bc get_serial_number
08254088 g     O .bss	00000004 nettick_wakes
08221110 g     F .text	00000058 alt_tse_phy_wr_mdio_addr
08254120 g     O .bss	00000001 tcpprintfs
0823d784 g     F .text	0000009c in_timerkill
082457b0 g     F .text	00000124 igmpv2_input
082540b4 g     O .bss	00000004 dsc_declines
0821c670 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
08228808 g     F .text	0000002c do_trap
0824a384 g     F .text	000000dc alt_get_fd
0822823c g     F .text	000000f4 bsd_ioctl
0825402c g     O .bss	00000004 OSMemFreeList
082157c8 g     F .text	000000b0 OSStatInit
0822ee04 g     F .text	000001d0 tcp_rcv
08228c48 g     F .text	00000048 panic
082541c0 g     O .bss	00000004 vfs_open_files
08249fc8 g     F .text	00000158 alt_busy_sleep
082266f8 g     F .text	0000018c ip2mac
08218018 g     F .text	000000c4 OSFlagQuery
08235004 g     F .text	000001e4 sock_select
08246dec g     F .text	00000264 dhc_setup
082394cc g     F .text	00000054 tcp_init
082540fc g     O .bss	00000004 cticks
08254091 g     O .bss	00000001 to_nettick
08253ecc g     O .rwdata	00000002 OSTaskCreateExtEn
08210b3c g     F .text	00000054 _close_r
08225aa0 g     F .text	000005e8 Netinit
0822df48 g     F .text	00000038 prep_armintcp
08243950 g     F .text	0000014c in_addmulti
08239520 g     F .text	00000108 tcp_template
082235cc g     F .text	00000328 alt_tse_phy_get_common_speed
0822ec20 g     F .text	00000070 remque
0824bb74 g     F .text	00000010 _vprintf_r
08235570 g     F .text	00000410 tcp_reass
08247c98 g     F .text	000001a0 tcp_cksum
0823b62c g     F .text	00000380 udp4_socksend
08248c1c g     F .text	000001bc vfclose_locked
0823541c g     F .text	00000078 ifd_set
0820c5dc g     F .text	0000007c memcmp
08215ab8 g     F .text	00000020 OS_Dummy
0821c730 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0822c5e0 g     F .text	000000b0 dhc_set_state
08254068 g     O .bss	00000004 NDEBUG
0825ea64 g       *ABS*	00000000 __alt_stack_base
08253fbc g     O .bss	00000004 last_flash_sector
0821c780 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
08234358 g     F .text	00000050 sbreserve
08254059 g     O .bss	00000001 mac_group_count
08243e74 g     F .text	00000224 ip_raw_input
08202d18 g     F .text	000000cc _fwrite_r
08253f38 g     O .rwdata	00000004 lilbufsiz
0823550c g     F .text	00000064 ifd_get
08234244 g     F .text	0000008c sbwakeup
08208e64 g     F .text	00000154 __swsetup_r
08224174 g     F .text	00000138 altera_eth_tse_init
0825c074 g     O .bss	000001e0 OSQTbl
08237f64 g     F .text	0000025c tcp_xmit_timer
08225308 g     F .text	000001ac tse_sgdma_read_init
08212614 g     F .text	000008e8 .hidden __divdf3
0820ad08 g     F .text	00000118 __sfp
082014d8 g     F .text	0000013c generate_mac_addr
0823f098 g     F .text	00000190 ip_bldhead
0820d550 g     F .text	00000078 __copybits
082343f4 g     F .text	000000a0 sbappend
0825249c g     O .rwdata	00000408 __malloc_av_
0820ae54 g     F .text	00000004 __sinit_lock_release
08254030 g     O .bss	00000004 OSTCBHighRdy
08213154 g     F .text	00000718 .hidden __muldf3
0823fb6c g     F .text	00000384 ip_write2
0820de70 g     F .text	00000054 __sread
08253f98 g     O .rwdata	00000004 arp_ageout
08254034 g     O .bss	00000004 OSQFreeList
08221eac g     F .text	00000424 alt_tse_mac_get_phy
0823efb0 g     F .text	000000e8 ip_init
0824a27c g     F .text	00000108 alt_find_file
08244150 g     F .text	00000044 ip_raw_free
0823e1e4 g     F .text	000000fc make_arp_entry
0823bdec g     F .text	000000a4 alt_dev_llist_insert
082149f8 g     F .text	00000120 __malloc_lock
08202ccc g     F .text	00000028 _fprintf_r
08214824 g     F .text	000000b0 sbrk
0823af20 g     F .text	0000005c udp_lookup
0820485c g     F .text	000021d8 ___svfprintf_internal_r
0821e89c g     F .text	00000058 alt_avalon_sgdma_start
08214d04 g     F .text	00000140 OSEventNameSet
0820aa5c g     F .text	0000005c _fflush_r
082205b4 g     F .text	0000008c alt_tse_mac_set_duplex
08210b90 g     F .text	000000c4 _calloc_r
0822e08c g     F .text	000000e0 npfree_base
08254038 g     O .bss	00000001 OSRdyGrp
082471bc g     F .text	00000028 md_fopen
08253adc g     O .rwdata	00000018 udp_protosw
08253e78 g     O .rwdata	00000008 alt_flash_dev_list
08248364 g     F .text	00000084 in_setsockaddr
08253fb4 g       *ABS*	00000000 __bss_start
08200e7c g     F .text	00000074 LED7SegLightshowTask
08234494 g     F .text	000000d8 sbappendrecord
0825e984 g     O .bss	00000050 ip_mib
082031b4 g     F .text	00000128 memset
08232274 g     F .text	00000098 sodisconnect
08200d18 g     F .text	00000080 main
08253ff4 g     O .bss	00000004 alt_envp
08253fdc g     O .bss	00000004 __malloc_max_total_mem
08201a4c g     F .text	00000070 sss_reset_connection
0822e970 g     F .text	000001c0 m_adj
0821c6d0 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
08208e4c g     F .text	00000018 __swbuf
0824742c g     F .text	000000c8 md_fgetc
0824de00 g     O .rodata	00000100 OSUnMapTbl
08240a40 g     F .text	000002a8 ip_dump
0822983c g     F .text	00000208 tk_stats
08253f14 g     O .rwdata	00000008 alt_iniche_dev_list
0825885c g     O .bss	00000078 SSSLEDCommandQTbl
0821e11c g     F .text	00000180 altera_avalon_lcd_16207_init
08253f08 g     O .rwdata	00000008 alt_sgdma_list
08253ec6 g     O .rwdata	00000002 OSSemEn
082540e4 g     O .bss	00000004 OS_TPS
0822fc94 g     F .text	0000074c rawip_usrreq
08217c84 g     F .text	00000394 OSFlagPost
0820dfa4 g     F .text	00000008 __sclose
082479d8 g     F .text	0000005c print46_addr
08380000 g       *ABS*	00000000 __alt_heap_limit
08210d44 g     F .text	00000014 fclose
08215c70 g     F .text	00000110 OS_EventTaskWait
0824b904 g     F .text	00000238 _strtol_r
08228a70 g     F .text	000001d8 print_uptime
08216870 g     F .text	000000cc OS_TaskStatStkChk
0821b330 g     F .text	00000150 OSTaskDelReq
082091b8 g     F .text	00001688 _dtoa_r
0820bcec g     F .text	0000080c _malloc_r
082474f4 g     F .text	00000024 md_unlink
0821f3a0 g     F .text	00000088 tse_mac_SwReset
0821122c g     F .text	00000030 __ascii_wctomb
08247ec0 g     F .text	00000058 in_pcbdetach
08253f78 g     O .rwdata	00000004 alt_errno
08253fa8 g     O .rwdata	00000004 mdlist_size
08215758 g     F .text	00000070 OSStart
08246704 g     F .text	00000034 u_mctest_init
08214998 g     F .text	00000060 __env_unlock
0820b8cc g     F .text	000000c4 _fwalk
0821b7cc g     F .text	000001d4 OSTaskResume
08218a54 g     F .text	000000e8 OSMemQuery
08247b64 g     F .text	00000134 convert_ip
0823e078 g     F .text	0000016c find_oldest_arp
08253ed8 g     O .rwdata	00000002 OSTaskStatEn
08254164 g     O .bss	00000004 arpReqsIn
08248844 g     F .text	00000050 vf_free_buffer
0824a15c g     F .text	00000120 alt_fcntl
08253eb2 g     O .rwdata	00000002 OSMemMax
0821978c g     F .text	00000170 OSQPostFront
0822d594 g     F .text	00000034 dtrap
08253f44 g     O .rwdata	00000004 kb_last
0820347c g     F .text	000000c8 putc
08202b18 g     F .text	00000084 .hidden __divsi3
08220254 g     F .text	00000048 alt_tse_mac_set_common_speed
08254039 g     O .bss	00000003 OSRdyTbl
08253e8c g     O .rwdata	00000002 OSDebugEn
0822df80 g     F .text	0000010c npalloc_base
08226b98 g     F .text	000000d0 ip_exit
0820afdc g     F .text	00000124 _malloc_trim_r
0824bed4 g       *ABS*	00000000 __CTOR_END__
08253ea4 g     O .rwdata	00000002 OSFlagNodeSize
08254098 g     O .bss	00000004 dhc_conn
0822d710 g     F .text	0000005c cticks_hook
08253eec g     O .rwdata	00000002 OSTmrCfgMax
0823d304 g     F .text	00000040 sysuptime
0820dfac g     F .text	000000dc strcmp
08201330 g     F .text	000001a8 generate_and_store_mac_addr
082425a4 g     F .text	000001b4 ip_reasm_delete_ire
08218d48 g     F .text	000001ac OSQCreate
0822d76c g     F .text	00000060 irq_Mask
0821b480 g     F .text	00000198 OSTaskNameGet
0825414c g     O .bss	00000004 nextppp
082540d4 g     O .bss	00000004 irq_level
08226088 g     F .text	00000158 fixup_subnet_mask
082198fc g     F .text	0000020c OSQPostOpt
08215878 g     F .text	00000220 OSTimeTick
08240ec0 g     F .text	00000134 ip_copypkt
0822c4f0 g     F .text	00000088 dhc_alldone
08253ed4 g     O .rwdata	00000002 OSTaskMax
0824bed4 g       *ABS*	00000000 __DTOR_LIST__
08219dbc g     F .text	000000d8 OSSemCreate
0825407c g     O .bss	00000004 igmp_all_hosts_group
08253ef8 g     O .rwdata	00000002 OSTmrWheelSize
0823419c g     F .text	0000003c sbselqueue
08254084 g     O .bss	00000004 netmain_wakes
0823e5a0 g     F .text	00000264 arprcv
082294c0 g     F .text	00000074 TK_OSTaskResume
0822786c g     F .text	0000041c igmp_print_stats
08212efc g     F .text	00000088 .hidden __nedf2
0822e254 g     F .text	00000090 pffindtype
08253ece g     O .rwdata	00000002 OSTaskDelEn
08253f5c g     O .rwdata	00000004 tcp_sendspace
082498c8 g     F .text	00000110 vftell
0825e0e0 g     O .bss	00000012 eth_prt_buf
0821a55c g     F .text	00000110 OSSemQuery
08218ef4 g     F .text	00000280 OSQDel
082194b8 g     F .text	0000016c OSQPendAbort
0821c400 g     F .text	00000038 alt_irq_init
08220214 g     F .text	00000040 alt_tse_mac_get_common_speed
0825e548 g     O .bss	00000018 app_semaphore
0823c74c g     F .text	00000064 alt_release_fd
0822dc64 g     F .text	0000007c post_app_sem
08226cec g     F .text	000000a4 igmp_init
08203718 g     F .text	0000006c sprintf
0824dcec g     O .rodata	00000100 .hidden __clz_tab
082540c0 g     O .bss	00000004 dsc_renew
08247364 g     F .text	00000078 md_fwrite
08253fd0 g     O .bss	00000004 _PathLocale
082540e8 g     O .bss	00000004 tcp_sleep_count
0822ec90 g     F .text	0000007c insque
0824b62c g     F .text	00000014 atexit
082541b4 g     O .bss	00000004 vfsfiles
08210adc g     F .text	00000060 _write_r
0824bb84 g     F .text	00000050 _vsprintf_r
08244fac g     F .text	00000298 udp_send
082155f0 g     F .text	0000008c OSSchedLock
08226fe4 g     F .text	0000029c igmp_send
0820bb0c g     F .text	00000018 setlocale
082170a8 g     F .text	00000108 OSFlagCreate
082588d4 g     O .bss	00002000 LEDManagementTaskStk
0822d7cc g     F .text	00000044 irq_Unmask
08230614 g     F .text	000000d8 t_listen
08253e64 g     O .rwdata	00000004 _impure_ptr
08251ec8 g     O .rwdata	00000018 ssstask
08253fec g     O .bss	00000004 alt_argc
0823a558 g     F .text	000006d4 tcp_usrreq
0823b11c g     F .text	0000023c udp_usrreq
0822e1e0 g     F .text	00000034 ncpalloc
0820a840 g     F .text	0000021c __sflush_r
0823bef0 g     F .text	00000060 _do_dtors
0820baf8 g     F .text	00000008 __locale_cjk_lang
08253e9e g     O .rwdata	00000002 OSEventMultiEn
08253f90 g     O .rwdata	00000004 pingdelay
0823dbb0 g     F .text	00000074 arp_send_pending
0825daf8 g     O .bss	000000e0 tse_mac_if
0824550c g     F .text	000002a4 igmpv1_input
0820dbd4 g     F .text	000001d4 __srefill_r
0822dedc g     F .text	0000004c pre_task_setup
08254108 g     O .bss	00000004 rcvdq_sem_ptr
08227ed0 g     F .text	00000124 bsd_getsockname
08242758 g     F .text	00000130 ip_reasm_mark_compact_rfq
082017ac g     F .text	0000012c FindLastFlashSectorOffset
082171b0 g     F .text	00000248 OSFlagDel
0825403c g     O .bss	00000004 OSEventFreeList
08229b7c g     F .text	00000048 dhc_set_callback
08200060 g       .exceptions	00000000 alt_irq_entry
0825415c g     O .bss	00000004 arpcache
0824afc4 g     F .text	00000300 icmp_destun
08243ba8 g     F .text	00000064 lookup_mcast
08249c3c g     F .text	00000048 vfslookup
0824357c g     F .text	000003d4 ip_demux
0820d17c g     F .text	00000064 __ulp
082540ec g     O .bss	00000004 tcp_wakeup_count
0821766c g     F .text	000005b8 OSFlagPend
08253eea g     O .rwdata	00000002 OSTmrEn
0820ae70 g     F .text	00000018 __fp_unlock_all
0822dba8 g     F .text	000000bc wait_app_sem
0821e29c g     F .text	00000060 altera_avalon_lcd_16207_write_fd
0820aecc g     F .text	0000005c fputc
08253f1c g     O .rwdata	00000004 ipmcfail_str
08254100 g     O .bss	00000004 memtrapsize
0822e67c g     F .text	000002f4 m_copy
08253f64 g     O .rwdata	00000008 alt_fs_list
0825e5c4 g     O .bss	00000014 mfreeq
08216668 g     F .text	00000074 OS_StrCopy
08231bdc g     F .text	0000005c sobind
08247164 g     F .text	00000058 init_memdev
08253fb4 g     O .bss	00000001 to_ssstask
0822ed0c g     F .text	000000f8 nptcp_init
08253eb4 g     O .rwdata	00000002 OSMemNameSize
0825e418 g     O .bss	000000f0 global_TCPwakeup_set
0823cfb4 g     F .text	00000020 OSInitHookEnd
08233c74 g     F .text	000000c4 soisdisconnected
0823db28 g     F .text	00000088 arp_free_pending
08253ee0 g     O .rwdata	00000002 OSTCBPrioTblMax
0820bb24 g     F .text	0000000c localeconv
08231e18 g     F .text	000002bc soclose
0825e308 g     O .bss	00000014 bigfreeq
08253edc g     O .rwdata	00000002 OSTaskStatStkChkEn
08253f8c g     O .rwdata	00000004 prompt
08253f54 g     O .rwdata	00000004 tcp_keepidle
08223424 g     F .text	000001a8 alt_tse_phy_set_adv_10
0822facc g     F .text	000001c8 rawip_soinput
0823bfe0 g     F .text	00000050 alt_ic_isr_register
0824971c g     F .text	00000060 vfwrite
08253eb0 g     O .rwdata	00000002 OSMemEn
08233f38 g     F .text	000000ac soqinsque
08254190 g     O .bss	00000004 so_evtmap_delete
08202de4 g     F .text	00000034 fwrite
08253eba g     O .rwdata	00000002 OSMutexEn
0825417c g     O .bss	00000004 h_ireq
08253fb4 g       *ABS*	00000000 _edata
082403d8 g     F .text	000005c4 ip_fragment
08225880 g     F .text	00000148 iniche_devices_init
0825e5d8 g     O .bss	00000028 tcp_saveti
08229014 g     F .text	000000d8 con_page
0825ea64 g       *ABS*	00000000 _end
08233574 g     F .text	000004a8 sogetopt
082143d0 g     F .text	00000068 alt_flash_open_dev
08254040 g     O .bss	00000001 OSIntNesting
082222d0 g     F .text	00000248 alt_tse_mac_associate_phy
08253a94 g     O .rwdata	00000030 nettasks
0822cde8 g     F .text	00000020 pk_get_max_intrsafe_buf_len
08210d58 g     F .text	00000164 __fputwc
08240ce8 g     F .text	000001d8 iproute
0822f5bc g     F .text	000000f4 np_stripoptions
08254194 g     O .bss	00000001 so_evtmap
0821cd2c g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
0820af28 g     F .text	0000009c _fputs_r
0821c13c g     F .text	000001d4 OSTimeDlyResume
0820197c g     F .text	000000d0 SSSCreateTasks
08244330 g     F .text	000003c0 add_route
08217520 g     F .text	0000014c OSFlagNameSet
08226668 g     F .text	00000090 c_older
08234928 g     F .text	00000084 sbflush
082471e4 g     F .text	00000024 md_fclose
0822980c g     F .text	00000030 tk_yield
08201d48 g     F .text	000000c8 sss_handle_accept
0821b9a0 g     F .text	000001c0 OSTaskStkChk
0823c0b8 g     F .text	0000008c alt_ic_irq_disable
0823230c g     F .text	00000558 sosend
08253eb6 g     O .rwdata	00000002 OSMemSize
0824099c g     F .text	000000a4 ip_mymach
0821ea08 g     F .text	0000008c alt_avalon_sgdma_construct_descriptor
0820decc g     F .text	0000007c __swrite
082540d0 g     O .bss	00000004 cticks_initialized
08253f94 g     O .rwdata	00000004 deflength
0823137c g     F .text	000001f4 t_sendto
08253e70 g     O .rwdata	00000004 __malloc_trim_threshold
082032dc g     F .text	00000080 _perror_r
0823cc90 g     F .text	00000024 altera_nios2_qsys_irq_init
0820baec g     F .text	0000000c __locale_msgcharset
08254044 g     O .bss	00000004 OSTCBCur
08231a34 g     F .text	000001a8 socreate
0824b658 g     F .text	00000038 exit
0825e870 g     O .bss	00000100 arp_table
082541cc g     O .bss	00000004 icmpdu_hook
08253eb8 g     O .rwdata	00000002 OSMemTblSize
0820b990 g     F .text	000000c4 _fwalk_reent
0823d820 g     F .text	00000024 create_apptasks
08253f50 g     O .rwdata	00000004 tcp_ttl
0820cf80 g     F .text	000001fc __mdiff
08214438 g     F .text	00000054 alt_flash_close_dev
0822e214 g     F .text	00000040 ncpfree
08202b9c g     F .text	00000074 .hidden __modsi3
08254060 g     O .bss	00000004 MaxLnh
08253e5c g     O .rwdata	00000004 __ctype_ptr__
0821f47c g     F .text	00000050 tse_mac_setGMIImode
08247954 g     F .text	00000084 inet_ntop
082454a4 g     F .text	00000024 udp_maxalloc
08223e44 g     F .text	000000e4 marvell_cfg_gmii
08380000 g       *ABS*	00000000 __alt_data_end
08200060 g     F .exceptions	00000000 alt_exception
0820ae4c g     F .text	00000004 __sfp_lock_release
08215454 g     F .text	00000058 OSInit
08222518 g     F .text	00000128 alt_tse_phy_cfg_pcs
0821bd44 g     F .text	00000124 OSTaskQuery
0823d10c g     F .text	00000094 icmp_port_du
08254130 g     O .bss	00000004 tcp_iss
08219c64 g     F .text	000000a8 OS_QInit
0824b640 g     F .text	0000000c atoi
08253f40 g     O .rwdata	00000004 bigbufsiz
082166dc g     F .text	00000054 OS_StrLen
08239d1c g     F .text	00000078 tcp_putseq
08218868 g     F .text	00000114 OSMemNameSet
0824d15a g     O .rodata	00000101 _ctype_
08200000 g       *ABS*	00000000 __alt_mem_onchip_ram
0823456c g     F .text	000001dc sbappendaddr
00000000 g       *ABS*	00000000 __alt_mem_ext_flash
082541c4 g     O .bss	00000004 vfs_total_rw_space
08246574 g     F .text	00000108 ip_getmoptions
08253ed2 g     O .rwdata	00000002 OSTaskProfileEn
08245244 g     F .text	000000f4 udpswap
08254048 g     O .bss	00000004 OSTime
0825410c g     O .bss	00000004 nextslow
08239e08 g     F .text	00000270 tcp_slowtimo
08239a28 g     F .text	0000010c tcp_newtcpcb
0823e804 g     F .text	00000180 send_via_arp
08229acc g     F .text	000000b0 dhc_init
08242128 g     F .text	00000058 ip_reasm_find_ire
0825c254 g     O .bss	00000800 OSTaskIdleStk
0824bea0 g     F .text	00000034 _exit
08249e50 g     F .text	00000058 isvfile_locked
082284ac g     F .text	00000184 bsd_select
0823bad4 g     F .text	0000012c alt_alarm_start
082173f8 g     F .text	00000128 OSFlagNameGet
082454c8 g     F .text	00000044 udp_free
0822cec4 g     F .text	000000b8 getq
08249fa4 g     F .text	00000024 prep_vfs
0821c310 g     F .text	0000005c OSTimeGet
08253f88 g     O .rwdata	00000004 name
08234b64 g     F .text	00000100 sbdropend
0820bb30 g     F .text	000001bc __smakebuf_r
0823e984 g     F .text	0000010c cb_arpent_tmo
08203f60 g     F .text	00000098 strlen
08245e78 g     F .text	00000134 IPADDR_TO_NETP
08228330 g     F .text	00000034 bsd_inet_ntoa
0823cf28 g     F .text	00000020 OSTaskSwHook
0823c4c0 g     F .text	00000154 open
0822d12c g     F .text	000001fc udp_open
0825ca54 g     O .bss	00000b40 OSEventTbl
082340ec g     F .text	00000058 socantsendmore
082541c8 g     O .bss	00000004 vfs_total_dyna_files
08212f84 g     F .text	000000dc .hidden __gedf2
0823c988 g     F .text	00000044 alt_uncached_free
0825d594 g     O .bss	00000510 OSTCBTbl
08254168 g     O .bss	00000004 arpReqsOut
0821a66c g     F .text	00000100 OSSemSet
08253fb0 g     O .rwdata	00000004 http_root_path
0822baa0 g     F .text	00000270 dhc_extract_opts
08241694 g     F .text	00000564 ip_reasm_compute_overlap
08253e74 g     O .rwdata	00000004 __wctomb
0820f590 g     F .text	00000018 __sprint_r
0821f2f8 g     F .text	000000a8 tse_mac_aRxRead
08203784 g     F .text	00000164 strchr
0825e0f2 g     O .bss	00000012 ipreturn
08254184 g     O .bss	00000004 port_prep
08253b17 g     O .rwdata	0000000d tcp_backoff
08233a68 g     F .text	00000070 soisconnecting
08200ca8 g     F .text	00000070 SSSInitialTask
0820afc4 g     F .text	00000018 fputs
08253f7c g     O .rwdata	00000004 alt_priority_mask
08245a08 g     F .text	000001ec igmpv2_process_query
08234cf4 g     F .text	000001d0 t_select
08219e94 g     F .text	00000240 OSSemDel
0823b9ac g     F .text	00000128 udp4_sockaddr
0825404c g     O .bss	00000004 OSFlagFreeList
08248128 g     F .text	000001e0 in_pcbconnect
08254124 g     O .bss	00000004 dropline
08254180 g     O .bss	00000004 ire_cticks
0823c030 g     F .text	00000088 alt_ic_irq_enable
08253e98 g     O .rwdata	00000002 OSEventNameSize
08208c34 g     F .text	0000001c __vfprintf_internal
082293d0 g     F .text	00000078 tk_netmain
08248308 g     F .text	0000005c in_pcbdisconnect
08254050 g     O .bss	00000001 OSStatRdy
0825daa4 g     O .bss	00000054 OSTCBPrioTbl
0821125c g     F .text	0000005c _wctomb_r
082148d4 g     F .text	000000c4 __env_lock
08253ede g     O .rwdata	00000002 OSTaskSwHookEn
08253cf0 g     O .rwdata	00000024 mdio
082204d4 g     F .text	000000e0 alt_tse_mac_set_speed
0821e5e0 g     F .text	00000084 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
08227c88 g     F .text	00000124 bsd_accept
08253f60 g     O .rwdata	00000004 tcp_recvspace
0821386c g     F .text	000008fc .hidden __subdf3
0824be88 g     F .text	00000018 _vfprintf_r
0823aee0 g     F .text	00000040 tcpinit
08254080 g     O .bss	00000004 igmp_all_rtrs_group
0822fa70 g     F .text	0000005c rawip_lookup
0823d8c0 g     F .text	000000a0 fcntl
0820c9b4 g     F .text	000000b0 __lo0bits
08234748 g     F .text	000001e0 sbcompress
08253f80 g     O .rwdata	00000008 alt_alarm_list
08239b34 g     F .text	000000ac tcp_drop
08253ea6 g     O .rwdata	00000002 OSFlagWidth
0823be90 g     F .text	00000060 _do_ctors
082231d0 g     F .text	00000254 alt_tse_phy_set_adv_100
0823a0d8 g     F .text	00000480 tcp_timers
08226c68 g     F .text	00000084 if_netnumber
0824667c g     F .text	00000088 ip_freemoptions
08233a1c g     F .text	0000004c sohasoutofband
0821116c g     F .text	000000c0 wcrtomb
08235980 g     F .text	00002330 tcp_input
08227dac g     F .text	00000124 bsd_getpeername
08228364 g     F .text	00000148 bsd_recvfrom
08225838 g     F .text	00000048 close
082540b0 g     O .bss	00000004 dsc_bpreplys
08253ffc g     O .bss	00000004 alt_envsem
08254054 g     O .bss	00000004 OSIdleCtrRun
08215a98 g     F .text	00000020 OSVersion
08253ef0 g     O .rwdata	00000002 OSTmrCfgWheelSize
0821be68 g     F .text	00000070 OS_TaskStkClr
082486c0 g     F .text	0000002c set_vfopen_error
08253eca g     O .rwdata	00000002 OSTaskCreateEn
0822029c g     F .text	0000006c alt_tse_get_system_index
08253af4 g     O .rwdata	00000018 rawip_protosw
082341d8 g     F .text	0000006c sbwait
08216088 g     F .text	00000068 OS_EventWaitListInit
0822bd10 g     F .text	00000550 dhc_second
0821efe8 g     F .text	000000a8 alt_avalon_sgdma_init
08254150 g     O .bss	00000004 port_1s_callout
08210ee0 g     F .text	00000080 fputwc
0823cfd4 g     F .text	00000020 OSTaskIdleHook
0824b6a4 g     F .text	00000014 free
0820ae50 g     F .text	00000004 __sinit_lock_acquire
0825405c g     O .bss	00000001 number_of_tse_mac
0820c728 g     F .text	00000120 __multadd
0821bb60 g     F .text	000001e4 OSTaskSuspend
0820c700 g     F .text	00000028 _Bfree
0821f184 g     F .text	00000030 no_printf
08233d38 g     F .text	00000200 sonewconn
0824a460 g     F .text	00000b64 icmprcv
0822e2e4 g     F .text	000000c4 pffindproto
08216730 g     F .text	0000005c OS_TaskIdle
08253ef6 g     O .rwdata	00000002 OSTmrTblSize
08219b08 g     F .text	0000015c OSQQuery



Disassembly of section .exceptions:

08200060 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
 8200060:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
 8200064:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
 8200068:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 820006c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 8200070:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 8200074:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 8200078:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 820007c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 8200080:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
 8200084:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
 8200088:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 820008c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 8200090:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 8200094:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 8200098:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 820009c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 82000a0:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 82000a4:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 82000a8:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 82000ac:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 82000b0:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 82000b4:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 82000b8:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 82000bc:	10000326 	beq	r2,zero,82000cc <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 82000c0:	20000226 	beq	r4,zero,82000cc <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 82000c4:	820012c0 	call	820012c <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 82000c8:	00000306 	br	82000d8 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
 82000cc:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
 82000d0:	e8bfff17 	ldw	r2,-4(ea)

082000d4 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
 82000d4:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 82000d8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 82000dc:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 82000e0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 82000e4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 82000e8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 82000ec:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 82000f0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 82000f4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 82000f8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 82000fc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 8200100:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
 8200104:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 8200108:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 820010c:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 8200110:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 8200114:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 8200118:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 820011c:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 8200120:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
 8200124:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 8200128:	ef80083a 	eret

0820012c <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 820012c:	defff904 	addi	sp,sp,-28
 8200130:	dfc00615 	stw	ra,24(sp)
 8200134:	df000515 	stw	fp,20(sp)
 8200138:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 820013c:	82154ac0 	call	82154ac <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 8200140:	0005313a 	rdctl	r2,ipending
 8200144:	e0bffe15 	stw	r2,-8(fp)

  return active;
 8200148:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 820014c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
 8200150:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 8200154:	00800044 	movi	r2,1
 8200158:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 820015c:	e0fffb17 	ldw	r3,-20(fp)
 8200160:	e0bffc17 	ldw	r2,-16(fp)
 8200164:	1884703a 	and	r2,r3,r2
 8200168:	10001426 	beq	r2,zero,82001bc <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 820016c:	008209b4 	movhi	r2,2086
 8200170:	10b9c304 	addi	r2,r2,-6388
 8200174:	e0fffd17 	ldw	r3,-12(fp)
 8200178:	180690fa 	slli	r3,r3,3
 820017c:	10c5883a 	add	r2,r2,r3
 8200180:	10c00017 	ldw	r3,0(r2)
 8200184:	008209b4 	movhi	r2,2086
 8200188:	10b9c304 	addi	r2,r2,-6388
 820018c:	e13ffd17 	ldw	r4,-12(fp)
 8200190:	200890fa 	slli	r4,r4,3
 8200194:	1105883a 	add	r2,r2,r4
 8200198:	10800104 	addi	r2,r2,4
 820019c:	10800017 	ldw	r2,0(r2)
 82001a0:	1009883a 	mov	r4,r2
 82001a4:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
 82001a8:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 82001ac:	0005313a 	rdctl	r2,ipending
 82001b0:	e0bfff15 	stw	r2,-4(fp)

  return active;
 82001b4:	e0bfff17 	ldw	r2,-4(fp)
 82001b8:	00000706 	br	82001d8 <alt_irq_handler+0xac>
      }
      mask <<= 1;
 82001bc:	e0bffc17 	ldw	r2,-16(fp)
 82001c0:	1085883a 	add	r2,r2,r2
 82001c4:	e0bffc15 	stw	r2,-16(fp)
      i++;
 82001c8:	e0bffd17 	ldw	r2,-12(fp)
 82001cc:	10800044 	addi	r2,r2,1
 82001d0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 82001d4:	003fe106 	br	820015c <alt_irq_handler+0x30>

    active = alt_irq_pending ();
 82001d8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
 82001dc:	e0bffb17 	ldw	r2,-20(fp)
 82001e0:	103fdb1e 	bne	r2,zero,8200150 <alt_irq_handler+0x24>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 82001e4:	82154f80 	call	82154f8 <OSIntExit>
}
 82001e8:	0001883a 	nop
 82001ec:	e037883a 	mov	sp,fp
 82001f0:	dfc00117 	ldw	ra,4(sp)
 82001f4:	df000017 	ldw	fp,0(sp)
 82001f8:	dec00204 	addi	sp,sp,8
 82001fc:	f800283a 	ret

Disassembly of section .text:

08200200 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 8200200:	00a00014 	movui	r2,32768
#endif

0:
    initd 0(r2)
 8200204:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 8200208:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
 820020c:	00bffd16 	blt	zero,r2,8200204 <_start+0x4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 8200210:	06c20e34 	movhi	sp,2104
    ori sp, sp, %lo(__alt_stack_pointer)
 8200214:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 8200218:	06820974 	movhi	gp,2085
    ori gp, gp, %lo(_gp)
 820021c:	d6af9714 	ori	gp,gp,48732
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 8200220:	00820974 	movhi	r2,2085
    ori r2, r2, %lo(__bss_start)
 8200224:	108fed14 	ori	r2,r2,16308

    movhi r3, %hi(__bss_end)
 8200228:	00c20974 	movhi	r3,2085
    ori r3, r3, %lo(__bss_end)
 820022c:	18fa9914 	ori	r3,r3,60004

    beq r2, r3, 1f
 8200230:	10c00326 	beq	r2,r3,8200240 <_start+0x40>

0:
    stw zero, (r2)
 8200234:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 8200238:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 820023c:	10fffd36 	bltu	r2,r3,8200234 <_start+0x34>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 8200240:	82147680 	call	8214768 <alt_main>

08200244 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 8200244:	003fff06 	br	8200244 <alt_after_alt_main>

08200248 <alt_uCOSIIErrorHandler>:
#include <errno.h>
#include "includes.h"
#include "alt_error_handler.h"
 
void alt_uCOSIIErrorHandler(INT8U error_code, void *expanded_diagnosis_ptr)
{
 8200248:	defffb04 	addi	sp,sp,-20
 820024c:	dfc00415 	stw	ra,16(sp)
 8200250:	df000315 	stw	fp,12(sp)
 8200254:	df000304 	addi	fp,sp,12
 8200258:	2005883a 	mov	r2,r4
 820025c:	e17fff15 	stw	r5,-4(fp)
 8200260:	e0bffe05 	stb	r2,-8(fp)
   FAULT_LEVEL fault_level;
   
   if(error_code == OS_NO_ERR)
 8200264:	e0bffe03 	ldbu	r2,-8(fp)
 8200268:	10014a26 	beq	r2,zero,8200794 <alt_uCOSIIErrorHandler+0x54c>
   {
      return;
   }
   
   fault_level = SYSTEM;  
 820026c:	00800084 	movi	r2,2
 8200270:	e0bffd15 	stw	r2,-12(fp)
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */
 8200274:	82155f00 	call	82155f0 <OSSchedLock>
      
   switch (error_code)
 8200278:	e0bffe03 	ldbu	r2,-8(fp)
 820027c:	10c00a20 	cmpeqi	r3,r2,40
 8200280:	1800261e 	bne	r3,zero,820031c <alt_uCOSIIErrorHandler+0xd4>
 8200284:	10c00a48 	cmpgei	r3,r2,41
 8200288:	1800121e 	bne	r3,zero,82002d4 <alt_uCOSIIErrorHandler+0x8c>
 820028c:	10c00120 	cmpeqi	r3,r2,4
 8200290:	1800601e 	bne	r3,zero,8200414 <alt_uCOSIIErrorHandler+0x1cc>
 8200294:	10c00148 	cmpgei	r3,r2,5
 8200298:	1800071e 	bne	r3,zero,82002b8 <alt_uCOSIIErrorHandler+0x70>
 820029c:	10c000a0 	cmpeqi	r3,r2,2
 82002a0:	18007a1e 	bne	r3,zero,820048c <alt_uCOSIIErrorHandler+0x244>
 82002a4:	10c000c8 	cmpgei	r3,r2,3
 82002a8:	1800631e 	bne	r3,zero,8200438 <alt_uCOSIIErrorHandler+0x1f0>
 82002ac:	10800060 	cmpeqi	r2,r2,1
 82002b0:	10004d1e 	bne	r2,zero,82003e8 <alt_uCOSIIErrorHandler+0x1a0>
 82002b4:	0000bc06 	br	82005a8 <alt_uCOSIIErrorHandler+0x360>
 82002b8:	10c00520 	cmpeqi	r3,r2,20
 82002bc:	1800401e 	bne	r3,zero,82003c0 <alt_uCOSIIErrorHandler+0x178>
 82002c0:	10c007a0 	cmpeqi	r3,r2,30
 82002c4:	1800961e 	bne	r3,zero,8200520 <alt_uCOSIIErrorHandler+0x2d8>
 82002c8:	108002a0 	cmpeqi	r2,r2,10
 82002cc:	1000651e 	bne	r2,zero,8200464 <alt_uCOSIIErrorHandler+0x21c>
 82002d0:	0000b506 	br	82005a8 <alt_uCOSIIErrorHandler+0x360>
 82002d4:	10c01020 	cmpeqi	r3,r2,64
 82002d8:	1800881e 	bne	r3,zero,82004fc <alt_uCOSIIErrorHandler+0x2b4>
 82002dc:	10c01048 	cmpgei	r3,r2,65
 82002e0:	1800071e 	bne	r3,zero,8200300 <alt_uCOSIIErrorHandler+0xb8>
 82002e4:	10c00f60 	cmpeqi	r3,r2,61
 82002e8:	18007a1e 	bne	r3,zero,82004d4 <alt_uCOSIIErrorHandler+0x28c>
 82002ec:	10c00fa0 	cmpeqi	r3,r2,62
 82002f0:	18006f1e 	bne	r3,zero,82004b0 <alt_uCOSIIErrorHandler+0x268>
 82002f4:	10800aa0 	cmpeqi	r2,r2,42
 82002f8:	1000111e 	bne	r2,zero,8200340 <alt_uCOSIIErrorHandler+0xf8>
 82002fc:	0000aa06 	br	82005a8 <alt_uCOSIIErrorHandler+0x360>
 8200300:	10c01920 	cmpeqi	r3,r2,100
 8200304:	1800901e 	bne	r3,zero,8200548 <alt_uCOSIIErrorHandler+0x300>
 8200308:	10c03fe0 	cmpeqi	r3,r2,255
 820030c:	1800991e 	bne	r3,zero,8200574 <alt_uCOSIIErrorHandler+0x32c>
 8200310:	108010a0 	cmpeqi	r2,r2,66
 8200314:	10001a1e 	bne	r2,zero,8200380 <alt_uCOSIIErrorHandler+0x138>
 8200318:	0000a306 	br	82005a8 <alt_uCOSIIErrorHandler+0x360>
   {  
      case OS_PRIO_EXIST:
         fprintf(stderr, "Attempted to assign task priority aready in use.\n");
 820031c:	d0a00217 	ldw	r2,-32760(gp)
 8200320:	10800317 	ldw	r2,12(r2)
 8200324:	100f883a 	mov	r7,r2
 8200328:	01800c44 	movi	r6,49
 820032c:	01400044 	movi	r5,1
 8200330:	01020974 	movhi	r4,2085
 8200334:	212fb504 	addi	r4,r4,-16684
 8200338:	8202de40 	call	8202de4 <fwrite>
         break;
 820033c:	0000b106 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_PRIO_INVALID:
         fprintf(stderr, "Specified task priority higher than allowed max.\n");
 8200340:	d0a00217 	ldw	r2,-32760(gp)
 8200344:	10800317 	ldw	r2,12(r2)
 8200348:	100f883a 	mov	r7,r2
 820034c:	01800c44 	movi	r6,49
 8200350:	01400044 	movi	r5,1
 8200354:	01020974 	movhi	r4,2085
 8200358:	212fc204 	addi	r4,r4,-16632
 820035c:	8202de40 	call	8202de4 <fwrite>
         fprintf(stderr, "Task can't be assigned a priority higher than %d\n",
 8200360:	d0a00217 	ldw	r2,-32760(gp)
 8200364:	10800317 	ldw	r2,12(r2)
 8200368:	01800504 	movi	r6,20
 820036c:	01420974 	movhi	r5,2085
 8200370:	296fcf04 	addi	r5,r5,-16580
 8200374:	1009883a 	mov	r4,r2
 8200378:	8202cf40 	call	8202cf4 <fprintf>
            OS_LOWEST_PRIO);
         break;
 820037c:	0000a106 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_NO_MORE_TCB:
         fprintf(stderr, "Task Control Blocks have been exhausted\n");
 8200380:	d0a00217 	ldw	r2,-32760(gp)
 8200384:	10800317 	ldw	r2,12(r2)
 8200388:	100f883a 	mov	r7,r2
 820038c:	01800a04 	movi	r6,40
 8200390:	01400044 	movi	r5,1
 8200394:	01020974 	movhi	r4,2085
 8200398:	212fdc04 	addi	r4,r4,-16528
 820039c:	8202de40 	call	8202de4 <fwrite>
         fprintf(stderr, "Current max number of tasks is %d\n",OS_MAX_TASKS);
 82003a0:	d0a00217 	ldw	r2,-32760(gp)
 82003a4:	10800317 	ldw	r2,12(r2)
 82003a8:	01800284 	movi	r6,10
 82003ac:	01420974 	movhi	r5,2085
 82003b0:	296fe704 	addi	r5,r5,-16484
 82003b4:	1009883a 	mov	r4,r2
 82003b8:	8202cf40 	call	8202cf4 <fprintf>
         break;
 82003bc:	00009106 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_MBOX_FULL:
         fault_level = NONE;
 82003c0:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Attempted Post to Mailbox already holding message\n");
 82003c4:	d0a00217 	ldw	r2,-32760(gp)
 82003c8:	10800317 	ldw	r2,12(r2)
 82003cc:	100f883a 	mov	r7,r2
 82003d0:	01800c84 	movi	r6,50
 82003d4:	01400044 	movi	r5,1
 82003d8:	01020974 	movhi	r4,2085
 82003dc:	212ff004 	addi	r4,r4,-16448
 82003e0:	8202de40 	call	8202de4 <fwrite>
         break;
 82003e4:	00008706 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_EVENT_TYPE:
         fault_level = TASK;
 82003e8:	00800044 	movi	r2,1
 82003ec:	e0bffd15 	stw	r2,-12(fp)
         fprintf(stderr, 
 82003f0:	d0a00217 	ldw	r2,-32760(gp)
 82003f4:	10800317 	ldw	r2,12(r2)
 82003f8:	100f883a 	mov	r7,r2
 82003fc:	01801244 	movi	r6,73
 8200400:	01400044 	movi	r5,1
 8200404:	01020974 	movhi	r4,2085
 8200408:	212ffd04 	addi	r4,r4,-16396
 820040c:	8202de40 	call	8202de4 <fwrite>
"Attempted to access a resource with no match for the required data type.\n");
         break;
 8200410:	00007c06 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_PEVENT_NULL:
         fprintf(stderr, "Attempting to access a resource pointing to NULL\n");
 8200414:	d0a00217 	ldw	r2,-32760(gp)
 8200418:	10800317 	ldw	r2,12(r2)
 820041c:	100f883a 	mov	r7,r2
 8200420:	01800c44 	movi	r6,49
 8200424:	01400044 	movi	r5,1
 8200428:	01020974 	movhi	r4,2085
 820042c:	21301004 	addi	r4,r4,-16320
 8200430:	8202de40 	call	8202de4 <fwrite>
         break;
 8200434:	00007306 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_POST_NULL_PTR:
         fault_level = TASK;
 8200438:	00800044 	movi	r2,1
 820043c:	e0bffd15 	stw	r2,-12(fp)
         fprintf(stderr, "Attempted to Post a NULL to a resource. \n");
 8200440:	d0a00217 	ldw	r2,-32760(gp)
 8200444:	10800317 	ldw	r2,12(r2)
 8200448:	100f883a 	mov	r7,r2
 820044c:	01800a44 	movi	r6,41
 8200450:	01400044 	movi	r5,1
 8200454:	01020974 	movhi	r4,2085
 8200458:	21301d04 	addi	r4,r4,-16268
 820045c:	8202de40 	call	8202de4 <fwrite>
         break;
 8200460:	00006806 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_TIMEOUT:
         fault_level = NONE;
 8200464:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Resource not received in specified time\n");
 8200468:	d0a00217 	ldw	r2,-32760(gp)
 820046c:	10800317 	ldw	r2,12(r2)
 8200470:	100f883a 	mov	r7,r2
 8200474:	01800a04 	movi	r6,40
 8200478:	01400044 	movi	r5,1
 820047c:	01020974 	movhi	r4,2085
 8200480:	21302804 	addi	r4,r4,-16224
 8200484:	8202de40 	call	8202de4 <fwrite>
         break;
 8200488:	00005e06 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_PEND_ISR:
         fprintf(stderr, "Attempting to pend for a resource in an ISR\n");
 820048c:	d0a00217 	ldw	r2,-32760(gp)
 8200490:	10800317 	ldw	r2,12(r2)
 8200494:	100f883a 	mov	r7,r2
 8200498:	01800b04 	movi	r6,44
 820049c:	01400044 	movi	r5,1
 82004a0:	01020974 	movhi	r4,2085
 82004a4:	21303304 	addi	r4,r4,-16180
 82004a8:	8202de40 	call	8202de4 <fwrite>
         break;
 82004ac:	00005506 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_TASK_DEL_IDLE:
         fprintf(stderr, "Attempted to delete the IDLE task\n");
 82004b0:	d0a00217 	ldw	r2,-32760(gp)
 82004b4:	10800317 	ldw	r2,12(r2)
 82004b8:	100f883a 	mov	r7,r2
 82004bc:	01800884 	movi	r6,34
 82004c0:	01400044 	movi	r5,1
 82004c4:	01020974 	movhi	r4,2085
 82004c8:	21303f04 	addi	r4,r4,-16132
 82004cc:	8202de40 	call	8202de4 <fwrite>
         break;
 82004d0:	00004c06 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_TASK_DEL_ERR:
         fault_level = NONE;
 82004d4:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Attempted to delete a task that does not exist\n");
 82004d8:	d0a00217 	ldw	r2,-32760(gp)
 82004dc:	10800317 	ldw	r2,12(r2)
 82004e0:	100f883a 	mov	r7,r2
 82004e4:	01800bc4 	movi	r6,47
 82004e8:	01400044 	movi	r5,1
 82004ec:	01020974 	movhi	r4,2085
 82004f0:	21304804 	addi	r4,r4,-16096
 82004f4:	8202de40 	call	8202de4 <fwrite>
         break;
 82004f8:	00004206 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_TASK_DEL_ISR:
         fprintf(stderr, "Attempted to delete a task from an ISR\n");
 82004fc:	d0a00217 	ldw	r2,-32760(gp)
 8200500:	10800317 	ldw	r2,12(r2)
 8200504:	100f883a 	mov	r7,r2
 8200508:	018009c4 	movi	r6,39
 820050c:	01400044 	movi	r5,1
 8200510:	01020974 	movhi	r4,2085
 8200514:	21305404 	addi	r4,r4,-16048
 8200518:	8202de40 	call	8202de4 <fwrite>
         break;
 820051c:	00003906 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_Q_FULL:
         fault_level = NONE;
 8200520:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Attempted to post to a full message queue\n");
 8200524:	d0a00217 	ldw	r2,-32760(gp)
 8200528:	10800317 	ldw	r2,12(r2)
 820052c:	100f883a 	mov	r7,r2
 8200530:	01800a84 	movi	r6,42
 8200534:	01400044 	movi	r5,1
 8200538:	01020974 	movhi	r4,2085
 820053c:	21305e04 	addi	r4,r4,-16008
 8200540:	8202de40 	call	8202de4 <fwrite>
         break;
 8200544:	00002f06 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_NOT_MUTEX_OWNER:
         fault_level = TASK;
 8200548:	00800044 	movi	r2,1
 820054c:	e0bffd15 	stw	r2,-12(fp)
         fprintf(stderr, "Attempted to post a mutex not owned by the task\n");
 8200550:	d0a00217 	ldw	r2,-32760(gp)
 8200554:	10800317 	ldw	r2,12(r2)
 8200558:	100f883a 	mov	r7,r2
 820055c:	01800c04 	movi	r6,48
 8200560:	01400044 	movi	r5,1
 8200564:	01020974 	movhi	r4,2085
 8200568:	21306904 	addi	r4,r4,-15964
 820056c:	8202de40 	call	8202de4 <fwrite>
         break;
 8200570:	00002406 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case EXPANDED_DIAGNOSIS_CODE:      
         fault_level = SYSTEM;
 8200574:	00800084 	movi	r2,2
 8200578:	e0bffd15 	stw	r2,-12(fp)
         printf(
 820057c:	01020974 	movhi	r4,2085
 8200580:	21307604 	addi	r4,r4,-15912
 8200584:	82033a00 	call	82033a0 <printf>
"\n[MicroC/OS-II]: See STDERR for expanded diagnosis translation.");    
         fprintf(stderr, "\n[MicroC/OS-II]: Expanded Diagnosis: %s.", 
 8200588:	d0a00217 	ldw	r2,-32760(gp)
 820058c:	10800317 	ldw	r2,12(r2)
 8200590:	e1bfff17 	ldw	r6,-4(fp)
 8200594:	01420974 	movhi	r5,2085
 8200598:	29708604 	addi	r5,r5,-15848
 820059c:	1009883a 	mov	r4,r2
 82005a0:	8202cf40 	call	8202cf4 <fprintf>
                 (char *)expanded_diagnosis_ptr);
         break;           
 82005a4:	00001706 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      default:
         printf("\n[MicroC/OS-II]: (Not a MicroC/OS-II error) See STDERR.\n");    
 82005a8:	01020974 	movhi	r4,2085
 82005ac:	21309104 	addi	r4,r4,-15804
 82005b0:	82036240 	call	8203624 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]:");
 82005b4:	d0a00217 	ldw	r2,-32760(gp)
 82005b8:	10800317 	ldw	r2,12(r2)
 82005bc:	100f883a 	mov	r7,r2
 82005c0:	01800404 	movi	r6,16
 82005c4:	01400044 	movi	r5,1
 82005c8:	01020974 	movhi	r4,2085
 82005cc:	21309f04 	addi	r4,r4,-15748
 82005d0:	8202de40 	call	8202de4 <fwrite>
         fprintf(stderr, "\nError_code %d.\n", error_code);
 82005d4:	d0a00217 	ldw	r2,-32760(gp)
 82005d8:	10800317 	ldw	r2,12(r2)
 82005dc:	e0fffe03 	ldbu	r3,-8(fp)
 82005e0:	180d883a 	mov	r6,r3
 82005e4:	01420974 	movhi	r5,2085
 82005e8:	2970a404 	addi	r5,r5,-15728
 82005ec:	1009883a 	mov	r4,r2
 82005f0:	8202cf40 	call	8202cf4 <fprintf>
         perror("\n[MicroC/OS-II]: (Not a MicroC/OS-II error), ERRNO: ");
 82005f4:	01020974 	movhi	r4,2085
 82005f8:	2130a904 	addi	r4,r4,-15708
 82005fc:	820335c0 	call	820335c <perror>
         break;
 8200600:	0001883a 	nop

   }

   /* Process the error based on the fault level, 
    * reenable scheduler if appropriate. */  
   switch (fault_level) {
 8200604:	e0bffd17 	ldw	r2,-12(fp)
 8200608:	10c00060 	cmpeqi	r3,r2,1
 820060c:	1800041e 	bne	r3,zero,8200620 <alt_uCOSIIErrorHandler+0x3d8>
 8200610:	00803a2e 	bgeu	zero,r2,82006fc <alt_uCOSIIErrorHandler+0x4b4>
 8200614:	108000a0 	cmpeqi	r2,r2,2
 8200618:	10001c1e 	bne	r2,zero,820068c <alt_uCOSIIErrorHandler+0x444>
 820061c:	00005106 	br	8200764 <alt_uCOSIIErrorHandler+0x51c>
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is TASK).");
 8200620:	01020974 	movhi	r4,2085
 8200624:	2130b704 	addi	r4,r4,-15652
 8200628:	82033a00 	call	82033a0 <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is TASK");
 820062c:	d0a00217 	ldw	r2,-32760(gp)
 8200630:	10800317 	ldw	r2,12(r2)
 8200634:	100f883a 	mov	r7,r2
 8200638:	01800904 	movi	r6,36
 820063c:	01400044 	movi	r5,1
 8200640:	01020974 	movhi	r4,2085
 8200644:	2130c404 	addi	r4,r4,-15600
 8200648:	8202de40 	call	8202de4 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Task is being deleted.\n");
 820064c:	d0a00217 	ldw	r2,-32760(gp)
 8200650:	10800317 	ldw	r2,12(r2)
 8200654:	100f883a 	mov	r7,r2
 8200658:	01800a04 	movi	r6,40
 820065c:	01400044 	movi	r5,1
 8200660:	01020974 	movhi	r4,2085
 8200664:	2130ce04 	addi	r4,r4,-15560
 8200668:	8202de40 	call	8202de4 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 820066c:	821567c0 	call	821567c <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 8200670:	01003fc4 	movi	r4,255
 8200674:	821afec0 	call	821afec <OSTaskDel>
         /* Reinvoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 8200678:	e0bffe03 	ldbu	r2,-8(fp)
 820067c:	000b883a 	mov	r5,zero
 8200680:	1009883a 	mov	r4,r2
 8200684:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
         break;
 8200688:	00004106 	br	8200790 <alt_uCOSIIErrorHandler+0x548>
      case SYSTEM:
         /* Total System Failure, Restart Required */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 820068c:	01020974 	movhi	r4,2085
 8200690:	2130d904 	addi	r4,r4,-15516
 8200694:	82033a00 	call	82033a0 <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is SYSTEM");
 8200698:	d0a00217 	ldw	r2,-32760(gp)
 820069c:	10800317 	ldw	r2,12(r2)
 82006a0:	100f883a 	mov	r7,r2
 82006a4:	01800984 	movi	r6,38
 82006a8:	01400044 	movi	r5,1
 82006ac:	01020974 	movhi	r4,2085
 82006b0:	2130e704 	addi	r4,r4,-15460
 82006b4:	8202de40 	call	8202de4 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: FATAL Error, Restart required.");
 82006b8:	d0a00217 	ldw	r2,-32760(gp)
 82006bc:	10800317 	ldw	r2,12(r2)
 82006c0:	100f883a 	mov	r7,r2
 82006c4:	01800bc4 	movi	r6,47
 82006c8:	01400044 	movi	r5,1
 82006cc:	01020974 	movhi	r4,2085
 82006d0:	2130f104 	addi	r4,r4,-15420
 82006d4:	8202de40 	call	8202de4 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Locking scheduler - endless loop.\n");
 82006d8:	d0a00217 	ldw	r2,-32760(gp)
 82006dc:	10800317 	ldw	r2,12(r2)
 82006e0:	100f883a 	mov	r7,r2
 82006e4:	01800cc4 	movi	r6,51
 82006e8:	01400044 	movi	r5,1
 82006ec:	01020974 	movhi	r4,2085
 82006f0:	2130fd04 	addi	r4,r4,-15372
 82006f4:	8202de40 	call	8202de4 <fwrite>
         while(1); /* Since scheduler is locked,loop halts all task activity.*/
 82006f8:	003fff06 	br	82006f8 <alt_uCOSIIErrorHandler+0x4b0>
         break;
      case NONE:
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is NONE");
 82006fc:	d0a00217 	ldw	r2,-32760(gp)
 8200700:	10800317 	ldw	r2,12(r2)
 8200704:	100f883a 	mov	r7,r2
 8200708:	01800904 	movi	r6,36
 820070c:	01400044 	movi	r5,1
 8200710:	01020974 	movhi	r4,2085
 8200714:	21310a04 	addi	r4,r4,-15320
 8200718:	8202de40 	call	8202de4 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Informational error only, control"); 
 820071c:	d0a00217 	ldw	r2,-32760(gp)
 8200720:	10800317 	ldw	r2,12(r2)
 8200724:	100f883a 	mov	r7,r2
 8200728:	01800c84 	movi	r6,50
 820072c:	01400044 	movi	r5,1
 8200730:	01020974 	movhi	r4,2085
 8200734:	21311404 	addi	r4,r4,-15280
 8200738:	8202de40 	call	8202de4 <fwrite>
         fprintf(stderr, 
 820073c:	d0a00217 	ldw	r2,-32760(gp)
 8200740:	10800317 	ldw	r2,12(r2)
 8200744:	100f883a 	mov	r7,r2
 8200748:	01800f84 	movi	r6,62
 820074c:	01400044 	movi	r5,1
 8200750:	01020974 	movhi	r4,2085
 8200754:	21312104 	addi	r4,r4,-15228
 8200758:	8202de40 	call	8202de4 <fwrite>
            "returned to task to complete processing at application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */
 820075c:	821567c0 	call	821567c <OSSchedUnlock>
         return;   
 8200760:	00000d06 	br	8200798 <alt_uCOSIIErrorHandler+0x550>
         break;      
      default:
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is Unknown).\n");
 8200764:	01020974 	movhi	r4,2085
 8200768:	21313104 	addi	r4,r4,-15164
 820076c:	82036240 	call	8203624 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is unknown!?!\n");
 8200770:	d0a00217 	ldw	r2,-32760(gp)
 8200774:	10800317 	ldw	r2,12(r2)
 8200778:	100f883a 	mov	r7,r2
 820077c:	01800ac4 	movi	r6,43
 8200780:	01400044 	movi	r5,1
 8200784:	01020974 	movhi	r4,2085
 8200788:	21313f04 	addi	r4,r4,-15108
 820078c:	8202de40 	call	8202de4 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 8200790:	003fff06 	br	8200790 <alt_uCOSIIErrorHandler+0x548>
{
   FAULT_LEVEL fault_level;
   
   if(error_code == OS_NO_ERR)
   {
      return;
 8200794:	0001883a 	nop
      default:
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is Unknown).\n");
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is unknown!?!\n");
   }
   while(1); /* Correct Program Flow never gets here. */
}
 8200798:	e037883a 	mov	sp,fp
 820079c:	dfc00117 	ldw	ra,4(sp)
 82007a0:	df000017 	ldw	fp,0(sp)
 82007a4:	dec00204 	addi	sp,sp,8
 82007a8:	f800283a 	ret

082007ac <alt_NetworkErrorHandler>:

void alt_NetworkErrorHandler(INT8U error_code, void *expanded_diagnosis_ptr)
{
 82007ac:	defffb04 	addi	sp,sp,-20
 82007b0:	dfc00415 	stw	ra,16(sp)
 82007b4:	df000315 	stw	fp,12(sp)
 82007b8:	df000304 	addi	fp,sp,12
 82007bc:	2005883a 	mov	r2,r4
 82007c0:	e17fff15 	stw	r5,-4(fp)
 82007c4:	e0bffe05 	stb	r2,-8(fp)
   FAULT_LEVEL fault_level;

   if(error_code == OS_NO_ERR)
 82007c8:	e0bffe03 	ldbu	r2,-8(fp)
 82007cc:	10008a26 	beq	r2,zero,82009f8 <alt_NetworkErrorHandler+0x24c>
   {
      return;
   }

   fault_level = SYSTEM;   
 82007d0:	00800084 	movi	r2,2
 82007d4:	e0bffd15 	stw	r2,-12(fp)
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */  
 82007d8:	82155f00 	call	82155f0 <OSSchedLock>

   if (error_code == EXPANDED_DIAGNOSIS_CODE) 
 82007dc:	e0bffe03 	ldbu	r2,-8(fp)
 82007e0:	10803fd8 	cmpnei	r2,r2,255
 82007e4:	1000101e 	bne	r2,zero,8200828 <alt_NetworkErrorHandler+0x7c>
   {
      fault_level = SYSTEM;
 82007e8:	00800084 	movi	r2,2
 82007ec:	e0bffd15 	stw	r2,-12(fp)
      printf("\n[Network]: See STDERR for expanded diagnosis translation.");    
 82007f0:	01020974 	movhi	r4,2085
 82007f4:	21314a04 	addi	r4,r4,-15064
 82007f8:	82033a00 	call	82033a0 <printf>
      fprintf(stderr, "\n[Network]: %s", (char *)expanded_diagnosis_ptr);
 82007fc:	d0a00217 	ldw	r2,-32760(gp)
 8200800:	10800317 	ldw	r2,12(r2)
 8200804:	e1bfff17 	ldw	r6,-4(fp)
 8200808:	01420974 	movhi	r5,2085
 820080c:	29715904 	addi	r5,r5,-15004
 8200810:	1009883a 	mov	r4,r2
 8200814:	8202cf40 	call	8202cf4 <fprintf>
      /* Check errno also in case it has been set. */
      perror("\n[Network]:  ERRNO: ");
 8200818:	01020974 	movhi	r4,2085
 820081c:	21315d04 	addi	r4,r4,-14988
 8200820:	820335c0 	call	820335c <perror>
 8200824:	00001006 	br	8200868 <alt_NetworkErrorHandler+0xbc>
   }
   else 
   {
      fault_level = TASK;
 8200828:	00800044 	movi	r2,1
 820082c:	e0bffd15 	stw	r2,-12(fp)
      printf("\n[Network]: See STDERR.\n");    
 8200830:	01020974 	movhi	r4,2085
 8200834:	21316304 	addi	r4,r4,-14964
 8200838:	82036240 	call	8203624 <puts>
      fprintf(stderr, "\n[Network]: Error_code %d!\n", error_code);        
 820083c:	d0a00217 	ldw	r2,-32760(gp)
 8200840:	10800317 	ldw	r2,12(r2)
 8200844:	e0fffe03 	ldbu	r3,-8(fp)
 8200848:	180d883a 	mov	r6,r3
 820084c:	01420974 	movhi	r5,2085
 8200850:	29716904 	addi	r5,r5,-14940
 8200854:	1009883a 	mov	r4,r2
 8200858:	8202cf40 	call	8202cf4 <fprintf>
      perror("\n[Network]:  ERRNO: ");
 820085c:	01020974 	movhi	r4,2085
 8200860:	21315d04 	addi	r4,r4,-14988
 8200864:	820335c0 	call	820335c <perror>
   }

   /* Process error based on fault level, reenable scheduler if appropriate. */     
   switch (fault_level) 
 8200868:	e0bffd17 	ldw	r2,-12(fp)
 820086c:	10c00060 	cmpeqi	r3,r2,1
 8200870:	1800041e 	bne	r3,zero,8200884 <alt_NetworkErrorHandler+0xd8>
 8200874:	00803a2e 	bgeu	zero,r2,8200960 <alt_NetworkErrorHandler+0x1b4>
 8200878:	108000a0 	cmpeqi	r2,r2,2
 820087c:	10001c1e 	bne	r2,zero,82008f0 <alt_NetworkErrorHandler+0x144>
 8200880:	00005106 	br	82009c8 <alt_NetworkErrorHandler+0x21c>
   {
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[Network]: See STDERR (FAULT_LEVEL is TASK).");
 8200884:	01020974 	movhi	r4,2085
 8200888:	21317004 	addi	r4,r4,-14912
 820088c:	82033a00 	call	82033a0 <printf>
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is TASK");
 8200890:	d0a00217 	ldw	r2,-32760(gp)
 8200894:	10800317 	ldw	r2,12(r2)
 8200898:	100f883a 	mov	r7,r2
 820089c:	018007c4 	movi	r6,31
 82008a0:	01400044 	movi	r5,1
 82008a4:	01020974 	movhi	r4,2085
 82008a8:	21317c04 	addi	r4,r4,-14864
 82008ac:	8202de40 	call	8202de4 <fwrite>
         fprintf(stderr, "\n[Network]: Task is being deleted.\n");
 82008b0:	d0a00217 	ldw	r2,-32760(gp)
 82008b4:	10800317 	ldw	r2,12(r2)
 82008b8:	100f883a 	mov	r7,r2
 82008bc:	018008c4 	movi	r6,35
 82008c0:	01400044 	movi	r5,1
 82008c4:	01020974 	movhi	r4,2085
 82008c8:	21318404 	addi	r4,r4,-14832
 82008cc:	8202de40 	call	8202de4 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 82008d0:	821567c0 	call	821567c <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 82008d4:	01003fc4 	movi	r4,255
 82008d8:	821afec0 	call	821afec <OSTaskDel>
         /* Reinvoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 82008dc:	e0bffe03 	ldbu	r2,-8(fp)
 82008e0:	000b883a 	mov	r5,zero
 82008e4:	1009883a 	mov	r4,r2
 82008e8:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
         break;
 82008ec:	00004106 	br	82009f4 <alt_NetworkErrorHandler+0x248>
      case SYSTEM:
         /* Total System Failure, Restart Required */
         printf("\n[Network]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 82008f0:	01020974 	movhi	r4,2085
 82008f4:	21318d04 	addi	r4,r4,-14796
 82008f8:	82033a00 	call	82033a0 <printf>
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is SYSTEM.");
 82008fc:	d0a00217 	ldw	r2,-32760(gp)
 8200900:	10800317 	ldw	r2,12(r2)
 8200904:	100f883a 	mov	r7,r2
 8200908:	01800884 	movi	r6,34
 820090c:	01400044 	movi	r5,1
 8200910:	01020974 	movhi	r4,2085
 8200914:	21319904 	addi	r4,r4,-14748
 8200918:	8202de40 	call	8202de4 <fwrite>
         fprintf(stderr, "\n[Network]: FATAL Error, Restart required.");
 820091c:	d0a00217 	ldw	r2,-32760(gp)
 8200920:	10800317 	ldw	r2,12(r2)
 8200924:	100f883a 	mov	r7,r2
 8200928:	01800a84 	movi	r6,42
 820092c:	01400044 	movi	r5,1
 8200930:	01020974 	movhi	r4,2085
 8200934:	2131a204 	addi	r4,r4,-14712
 8200938:	8202de40 	call	8202de4 <fwrite>
         fprintf(stderr, "\n[Network]: Locking scheduler - endless loop.\n");
 820093c:	d0a00217 	ldw	r2,-32760(gp)
 8200940:	10800317 	ldw	r2,12(r2)
 8200944:	100f883a 	mov	r7,r2
 8200948:	01800b84 	movi	r6,46
 820094c:	01400044 	movi	r5,1
 8200950:	01020974 	movhi	r4,2085
 8200954:	2131ad04 	addi	r4,r4,-14668
 8200958:	8202de40 	call	8202de4 <fwrite>
         while(1); /* Since scheduler is locked, loop halts all task activity.*/
 820095c:	003fff06 	br	820095c <alt_NetworkErrorHandler+0x1b0>
         break;
      case NONE:
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is NONE.");
 8200960:	d0a00217 	ldw	r2,-32760(gp)
 8200964:	10800317 	ldw	r2,12(r2)
 8200968:	100f883a 	mov	r7,r2
 820096c:	01800804 	movi	r6,32
 8200970:	01400044 	movi	r5,1
 8200974:	01020974 	movhi	r4,2085
 8200978:	2131b904 	addi	r4,r4,-14620
 820097c:	8202de40 	call	8202de4 <fwrite>
         fprintf(stderr, "\n[Network]: Informational "
 8200980:	d0a00217 	ldw	r2,-32760(gp)
 8200984:	10800317 	ldw	r2,12(r2)
 8200988:	100f883a 	mov	r7,r2
 820098c:	01800d84 	movi	r6,54
 8200990:	01400044 	movi	r5,1
 8200994:	01020974 	movhi	r4,2085
 8200998:	2131c204 	addi	r4,r4,-14584
 820099c:	8202de40 	call	8202de4 <fwrite>
                         "error only, control returned");
         fprintf(stderr, 
 82009a0:	d0a00217 	ldw	r2,-32760(gp)
 82009a4:	10800317 	ldw	r2,12(r2)
 82009a8:	100f883a 	mov	r7,r2
 82009ac:	01800e44 	movi	r6,57
 82009b0:	01400044 	movi	r5,1
 82009b4:	01020974 	movhi	r4,2085
 82009b8:	2131d004 	addi	r4,r4,-14528
 82009bc:	8202de40 	call	8202de4 <fwrite>
            "to task to complete processing at the application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */ 
 82009c0:	821567c0 	call	821567c <OSSchedUnlock>
         return;
 82009c4:	00000d06 	br	82009fc <alt_NetworkErrorHandler+0x250>
         break;         
      default:
         printf("\n[Network]: See STDERR (FAULT_LEVEL is unknown).\n");    
 82009c8:	01020974 	movhi	r4,2085
 82009cc:	2131df04 	addi	r4,r4,-14468
 82009d0:	82036240 	call	8203624 <puts>
         fprintf(stderr, "\n[Network] FAULT_LEVEL is unknown !?!\n");
 82009d4:	d0a00217 	ldw	r2,-32760(gp)
 82009d8:	10800317 	ldw	r2,12(r2)
 82009dc:	100f883a 	mov	r7,r2
 82009e0:	01800984 	movi	r6,38
 82009e4:	01400044 	movi	r5,1
 82009e8:	01020974 	movhi	r4,2085
 82009ec:	2131ec04 	addi	r4,r4,-14416
 82009f0:	8202de40 	call	8202de4 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 82009f4:	003fff06 	br	82009f4 <alt_NetworkErrorHandler+0x248>
{
   FAULT_LEVEL fault_level;

   if(error_code == OS_NO_ERR)
   {
      return;
 82009f8:	0001883a 	nop
      default:
         printf("\n[Network]: See STDERR (FAULT_LEVEL is unknown).\n");    
         fprintf(stderr, "\n[Network] FAULT_LEVEL is unknown !?!\n");
   }
   while(1); /* Correct Program Flow never gets here. */
}
 82009fc:	e037883a 	mov	sp,fp
 8200a00:	dfc00117 	ldw	ra,4(sp)
 8200a04:	df000017 	ldw	fp,0(sp)
 8200a08:	dec00204 	addi	sp,sp,8
 8200a0c:	f800283a 	ret

08200a10 <alt_SSSErrorHandler>:
   
   
void alt_SSSErrorHandler(INT8U error_code, 
                         void *expanded_diagnosis_ptr)
{
 8200a10:	defffb04 	addi	sp,sp,-20
 8200a14:	dfc00415 	stw	ra,16(sp)
 8200a18:	df000315 	stw	fp,12(sp)
 8200a1c:	df000304 	addi	fp,sp,12
 8200a20:	2005883a 	mov	r2,r4
 8200a24:	e17fff15 	stw	r5,-4(fp)
 8200a28:	e0bffe05 	stb	r2,-8(fp)
   FAULT_LEVEL fault_level;
   
   if   (error_code == OS_NO_ERR)
 8200a2c:	e0bffe03 	ldbu	r2,-8(fp)
 8200a30:	10009726 	beq	r2,zero,8200c90 <alt_SSSErrorHandler+0x280>
   {
      return;
   }

   fault_level = (error_code == OS_NO_ERR) ? NONE : SYSTEM;
 8200a34:	e0bffe03 	ldbu	r2,-8(fp)
 8200a38:	1000021e 	bne	r2,zero,8200a44 <alt_SSSErrorHandler+0x34>
 8200a3c:	0005883a 	mov	r2,zero
 8200a40:	00000106 	br	8200a48 <alt_SSSErrorHandler+0x38>
 8200a44:	00800084 	movi	r2,2
 8200a48:	e0bffd15 	stw	r2,-12(fp)
   
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */
 8200a4c:	82155f00 	call	82155f0 <OSSchedLock>
   switch (error_code)
 8200a50:	e0bffe03 	ldbu	r2,-8(fp)
 8200a54:	10c007a0 	cmpeqi	r3,r2,30
 8200a58:	18000f1e 	bne	r3,zero,8200a98 <alt_SSSErrorHandler+0x88>
 8200a5c:	10803fe0 	cmpeqi	r2,r2,255
 8200a60:	10001726 	beq	r2,zero,8200ac0 <alt_SSSErrorHandler+0xb0>
   {
      case EXPANDED_DIAGNOSIS_CODE:      
         fault_level = SYSTEM;
 8200a64:	00800084 	movi	r2,2
 8200a68:	e0bffd15 	stw	r2,-12(fp)
         printf("\n[SSS]: See STDERR for expanded diagnosis translation.");    
 8200a6c:	01020974 	movhi	r4,2085
 8200a70:	2131f604 	addi	r4,r4,-14376
 8200a74:	82033a00 	call	82033a0 <printf>
         fprintf(stderr, "\n[SSS]: %s", (char *)expanded_diagnosis_ptr);
 8200a78:	d0a00217 	ldw	r2,-32760(gp)
 8200a7c:	10800317 	ldw	r2,12(r2)
 8200a80:	e1bfff17 	ldw	r6,-4(fp)
 8200a84:	01420974 	movhi	r5,2085
 8200a88:	29720404 	addi	r5,r5,-14320
 8200a8c:	1009883a 	mov	r4,r2
 8200a90:	8202cf40 	call	8202cf4 <fprintf>
         break;
 8200a94:	00001a06 	br	8200b00 <alt_SSSErrorHandler+0xf0>
         
      case OS_Q_FULL:
         fault_level = NONE;
 8200a98:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr,"\n[SSS]: Attempted to post to a full message queue.");
 8200a9c:	d0a00217 	ldw	r2,-32760(gp)
 8200aa0:	10800317 	ldw	r2,12(r2)
 8200aa4:	100f883a 	mov	r7,r2
 8200aa8:	01800c84 	movi	r6,50
 8200aac:	01400044 	movi	r5,1
 8200ab0:	01020974 	movhi	r4,2085
 8200ab4:	21320704 	addi	r4,r4,-14308
 8200ab8:	8202de40 	call	8202de4 <fwrite>
         break;
 8200abc:	00001006 	br	8200b00 <alt_SSSErrorHandler+0xf0>
      
      default:
         fault_level = SYSTEM;
 8200ac0:	00800084 	movi	r2,2
 8200ac4:	e0bffd15 	stw	r2,-12(fp)
         printf("\n[SSS]: See STDERR.\n");    
 8200ac8:	01020974 	movhi	r4,2085
 8200acc:	21321404 	addi	r4,r4,-14256
 8200ad0:	82036240 	call	8203624 <puts>
         fprintf(stderr, "\n[SSS]: Error_code %d!", error_code);        
 8200ad4:	d0a00217 	ldw	r2,-32760(gp)
 8200ad8:	10800317 	ldw	r2,12(r2)
 8200adc:	e0fffe03 	ldbu	r3,-8(fp)
 8200ae0:	180d883a 	mov	r6,r3
 8200ae4:	01420974 	movhi	r5,2085
 8200ae8:	29721904 	addi	r5,r5,-14236
 8200aec:	1009883a 	mov	r4,r2
 8200af0:	8202cf40 	call	8202cf4 <fprintf>
         perror("\n[SSS]:  ERRNO: ");
 8200af4:	01020974 	movhi	r4,2085
 8200af8:	21321f04 	addi	r4,r4,-14212
 8200afc:	820335c0 	call	820335c <perror>
   }

   /* Process the error based on the fault level, 
    * reenable scheduler if appropriate. */     
   switch (fault_level) 
 8200b00:	e0bffd17 	ldw	r2,-12(fp)
 8200b04:	10c00060 	cmpeqi	r3,r2,1
 8200b08:	1800041e 	bne	r3,zero,8200b1c <alt_SSSErrorHandler+0x10c>
 8200b0c:	00803a2e 	bgeu	zero,r2,8200bf8 <alt_SSSErrorHandler+0x1e8>
 8200b10:	108000a0 	cmpeqi	r2,r2,2
 8200b14:	10001c1e 	bne	r2,zero,8200b88 <alt_SSSErrorHandler+0x178>
 8200b18:	00005106 	br	8200c60 <alt_SSSErrorHandler+0x250>
   {
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is TASK).");
 8200b1c:	01020974 	movhi	r4,2085
 8200b20:	21322404 	addi	r4,r4,-14192
 8200b24:	82033a00 	call	82033a0 <printf>
         fprintf(stderr, "\n[SSS]: FAULT_LEVEL is TASK");
 8200b28:	d0a00217 	ldw	r2,-32760(gp)
 8200b2c:	10800317 	ldw	r2,12(r2)
 8200b30:	100f883a 	mov	r7,r2
 8200b34:	018006c4 	movi	r6,27
 8200b38:	01400044 	movi	r5,1
 8200b3c:	01020974 	movhi	r4,2085
 8200b40:	21322f04 	addi	r4,r4,-14148
 8200b44:	8202de40 	call	8202de4 <fwrite>
         fprintf(stderr, "\n[SSS]: Task is being deleted.\n");
 8200b48:	d0a00217 	ldw	r2,-32760(gp)
 8200b4c:	10800317 	ldw	r2,12(r2)
 8200b50:	100f883a 	mov	r7,r2
 8200b54:	018007c4 	movi	r6,31
 8200b58:	01400044 	movi	r5,1
 8200b5c:	01020974 	movhi	r4,2085
 8200b60:	21323604 	addi	r4,r4,-14120
 8200b64:	8202de40 	call	8202de4 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 8200b68:	821567c0 	call	821567c <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 8200b6c:	01003fc4 	movi	r4,255
 8200b70:	821afec0 	call	821afec <OSTaskDel>
         /* Invoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 8200b74:	e0bffe03 	ldbu	r2,-8(fp)
 8200b78:	000b883a 	mov	r5,zero
 8200b7c:	1009883a 	mov	r4,r2
 8200b80:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
         break;
 8200b84:	00004106 	br	8200c8c <alt_SSSErrorHandler+0x27c>
      case SYSTEM:
          /* Total System Failure, Restart Required */
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 8200b88:	01020974 	movhi	r4,2085
 8200b8c:	21323e04 	addi	r4,r4,-14088
 8200b90:	82033a00 	call	82033a0 <printf>
         fprintf(stderr, "\n[SSS]: FAULT_LEVEL is SYSTEM.");
 8200b94:	d0a00217 	ldw	r2,-32760(gp)
 8200b98:	10800317 	ldw	r2,12(r2)
 8200b9c:	100f883a 	mov	r7,r2
 8200ba0:	01800784 	movi	r6,30
 8200ba4:	01400044 	movi	r5,1
 8200ba8:	01020974 	movhi	r4,2085
 8200bac:	21324904 	addi	r4,r4,-14044
 8200bb0:	8202de40 	call	8202de4 <fwrite>
         fprintf(stderr, "\n[SSS]: FATAL Error, Restart required.");
 8200bb4:	d0a00217 	ldw	r2,-32760(gp)
 8200bb8:	10800317 	ldw	r2,12(r2)
 8200bbc:	100f883a 	mov	r7,r2
 8200bc0:	01800984 	movi	r6,38
 8200bc4:	01400044 	movi	r5,1
 8200bc8:	01020974 	movhi	r4,2085
 8200bcc:	21325104 	addi	r4,r4,-14012
 8200bd0:	8202de40 	call	8202de4 <fwrite>
         fprintf(stderr, "\n[SSS]: Locking scheduler - endless loop.\n");
 8200bd4:	d0a00217 	ldw	r2,-32760(gp)
 8200bd8:	10800317 	ldw	r2,12(r2)
 8200bdc:	100f883a 	mov	r7,r2
 8200be0:	01800a84 	movi	r6,42
 8200be4:	01400044 	movi	r5,1
 8200be8:	01020974 	movhi	r4,2085
 8200bec:	21325b04 	addi	r4,r4,-13972
 8200bf0:	8202de40 	call	8202de4 <fwrite>
         while(1); /* Since scheduler is locked, loop halts all task activity.*/
 8200bf4:	003fff06 	br	8200bf4 <alt_SSSErrorHandler+0x1e4>
         break;
      case NONE:
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is NONE.");
 8200bf8:	d0a00217 	ldw	r2,-32760(gp)
 8200bfc:	10800317 	ldw	r2,12(r2)
 8200c00:	100f883a 	mov	r7,r2
 8200c04:	018006c4 	movi	r6,27
 8200c08:	01400044 	movi	r5,1
 8200c0c:	01020974 	movhi	r4,2085
 8200c10:	21326604 	addi	r4,r4,-13928
 8200c14:	8202de40 	call	8202de4 <fwrite>
         fprintf(stderr, 
 8200c18:	d0a00217 	ldw	r2,-32760(gp)
 8200c1c:	10800317 	ldw	r2,12(r2)
 8200c20:	100f883a 	mov	r7,r2
 8200c24:	01800f44 	movi	r6,61
 8200c28:	01400044 	movi	r5,1
 8200c2c:	01020974 	movhi	r4,2085
 8200c30:	21326d04 	addi	r4,r4,-13900
 8200c34:	8202de40 	call	8202de4 <fwrite>
            "\n[SSS] Informational error only, control returned to task to ");
         fprintf(stderr,
 8200c38:	d0a00217 	ldw	r2,-32760(gp)
 8200c3c:	10800317 	ldw	r2,12(r2)
 8200c40:	100f883a 	mov	r7,r2
 8200c44:	01800b84 	movi	r6,46
 8200c48:	01400044 	movi	r5,1
 8200c4c:	01020974 	movhi	r4,2085
 8200c50:	21327d04 	addi	r4,r4,-13836
 8200c54:	8202de40 	call	8202de4 <fwrite>
            "complete processing at the application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */ 
 8200c58:	821567c0 	call	821567c <OSSchedUnlock>
         return;         
 8200c5c:	00000d06 	br	8200c94 <alt_SSSErrorHandler+0x284>
         break;
      default:
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is Unknown).\n");
 8200c60:	01020974 	movhi	r4,2085
 8200c64:	21328904 	addi	r4,r4,-13788
 8200c68:	82036240 	call	8203624 <puts>
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is unknown!?!\n");
 8200c6c:	d0a00217 	ldw	r2,-32760(gp)
 8200c70:	10800317 	ldw	r2,12(r2)
 8200c74:	100f883a 	mov	r7,r2
 8200c78:	01800844 	movi	r6,33
 8200c7c:	01400044 	movi	r5,1
 8200c80:	01020974 	movhi	r4,2085
 8200c84:	21329504 	addi	r4,r4,-13740
 8200c88:	8202de40 	call	8202de4 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 8200c8c:	003fff06 	br	8200c8c <alt_SSSErrorHandler+0x27c>
{
   FAULT_LEVEL fault_level;
   
   if   (error_code == OS_NO_ERR)
   {
      return;
 8200c90:	0001883a 	nop
      default:
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is Unknown).\n");
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is unknown!?!\n");
   }
   while(1); /* Correct Program Flow never gets here. */
}
 8200c94:	e037883a 	mov	sp,fp
 8200c98:	dfc00117 	ldw	ra,4(sp)
 8200c9c:	df000017 	ldw	fp,0(sp)
 8200ca0:	dec00204 	addi	sp,sp,8
 8200ca4:	f800283a 	ret

08200ca8 <SSSInitialTask>:
/* SSSInitialTask will initialize the NicheStack
 * TCP/IP Stack and then initialize the rest of the Simple Socket Server example 
 * RTOS structures and tasks. 
 */
void SSSInitialTask(void *task_data)
{
 8200ca8:	defffc04 	addi	sp,sp,-16
 8200cac:	dfc00315 	stw	ra,12(sp)
 8200cb0:	df000215 	stw	fp,8(sp)
 8200cb4:	df000204 	addi	fp,sp,8
 8200cb8:	e13fff15 	stw	r4,-4(fp)
   * NicheStack is initialized from a task, so that RTOS will have started, and 
   * I/O drivers are available.  Two tasks are created:
   *    "Inet main"  task with priority 2
   *    "clock tick" task with priority 3
   */   
  alt_iniche_init();
 8200cbc:	822dce00 	call	822dce0 <alt_iniche_init>
  netmain(); 
 8200cc0:	82292f00 	call	82292f0 <netmain>

  /* Wait for the network stack to be ready before proceeding. 
   * iniche_net_ready indicates that TCP/IP stack is ready, and IP address is obtained.
   */
  while (!iniche_net_ready)
 8200cc4:	00000206 	br	8200cd0 <SSSInitialTask+0x28>
    TK_SLEEP(1);
 8200cc8:	01000084 	movi	r4,2
 8200ccc:	821bed80 	call	821bed8 <OSTimeDly>
  netmain(); 

  /* Wait for the network stack to be ready before proceeding. 
   * iniche_net_ready indicates that TCP/IP stack is ready, and IP address is obtained.
   */
  while (!iniche_net_ready)
 8200cd0:	d0a08c17 	ldw	r2,-32208(gp)
 8200cd4:	103ffc26 	beq	r2,zero,8200cc8 <SSSInitialTask+0x20>

  /* Now that the stack is running, perform the application initialization steps */
  
  /* Application Specific Task Launching Code Block Begin */

  printf("\nSimple Socket Server starting up\n");
 8200cd8:	01020974 	movhi	r4,2085
 8200cdc:	2132a404 	addi	r4,r4,-13680
 8200ce0:	82036240 	call	8203624 <puts>

  /* Create the main simple socket server task. */
  TK_NEWTASK(&ssstask);
 8200ce4:	01020974 	movhi	r4,2085
 8200ce8:	2107b204 	addi	r4,r4,7880
 8200cec:	822d95c0 	call	822d95c <TK_NEWTASK>
  
  /*create os data structures */
  SSSCreateOSDataStructs(); 
 8200cf0:	82018d80 	call	82018d8 <SSSCreateOSDataStructs>

  /* create the other tasks */
  SSSCreateTasks();
 8200cf4:	820197c0 	call	820197c <SSSCreateTasks>

  /* Application Specific Task Launching Code Block End */
  
  /*This task is deleted because there is no need for it to run again */
  error_code = OSTaskDel(OS_PRIO_SELF);
 8200cf8:	01003fc4 	movi	r4,255
 8200cfc:	821afec0 	call	821afec <OSTaskDel>
 8200d00:	e0bffe05 	stb	r2,-8(fp)
  alt_uCOSIIErrorHandler(error_code, 0);
 8200d04:	e0bffe03 	ldbu	r2,-8(fp)
 8200d08:	000b883a 	mov	r5,zero
 8200d0c:	1009883a 	mov	r4,r2
 8200d10:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  
  while (1); /* Correct Program Flow should never get here */
 8200d14:	003fff06 	br	8200d14 <SSSInitialTask+0x6c>

08200d18 <main>:

/* Main creates a single task, SSSInitialTask, and starts task scheduler.
 */

int main (int argc, char* argv[], char* envp[])
{
 8200d18:	defff504 	addi	sp,sp,-44
 8200d1c:	dfc00a15 	stw	ra,40(sp)
 8200d20:	df000915 	stw	fp,36(sp)
 8200d24:	df000904 	addi	fp,sp,36
 8200d28:	e13ffd15 	stw	r4,-12(fp)
 8200d2c:	e17ffe15 	stw	r5,-8(fp)
 8200d30:	e1bfff15 	stw	r6,-4(fp)
  
  INT8U error_code;

  /* Clear the RTOS timer */
  OSTimeSet(0);
 8200d34:	0009883a 	mov	r4,zero
 8200d38:	821c36c0 	call	821c36c <OSTimeSet>

  /* SSSInitialTask will initialize the NicheStack
   * TCP/IP Stack and then initialize the rest of the Simple Socket Server example 
   * RTOS structures and tasks. 
   */  
  error_code = OSTaskCreateExt(SSSInitialTask,
 8200d3c:	d8000415 	stw	zero,16(sp)
 8200d40:	d8000315 	stw	zero,12(sp)
 8200d44:	00820004 	movi	r2,2048
 8200d48:	d8800215 	stw	r2,8(sp)
 8200d4c:	00820974 	movhi	r2,2085
 8200d50:	10921704 	addi	r2,r2,18524
 8200d54:	d8800115 	stw	r2,4(sp)
 8200d58:	00800144 	movi	r2,5
 8200d5c:	d8800015 	stw	r2,0(sp)
 8200d60:	01c00144 	movi	r7,5
 8200d64:	01820974 	movhi	r6,2085
 8200d68:	319a1704 	addi	r6,r6,26716
 8200d6c:	000b883a 	mov	r5,zero
 8200d70:	01020834 	movhi	r4,2080
 8200d74:	21032a04 	addi	r4,r4,3240
 8200d78:	821ae080 	call	821ae08 <OSTaskCreateExt>
 8200d7c:	e0bffc05 	stb	r2,-16(fp)
                             SSS_INITIAL_TASK_PRIORITY,
                             SSSInitialTaskStk,
                             TASK_STACKSIZE,
                             NULL,
                             0);
  alt_uCOSIIErrorHandler(error_code, 0);
 8200d80:	e0bffc03 	ldbu	r2,-16(fp)
 8200d84:	000b883a 	mov	r5,zero
 8200d88:	1009883a 	mov	r4,r2
 8200d8c:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>

  /*
   * As with all MicroC/OS-II designs, once the initial thread(s) and 
   * associated RTOS resources are declared, we start the RTOS. That's it!
   */
  OSStart();
 8200d90:	82157580 	call	8215758 <OSStart>

  
  while(1); /* Correct Program Flow never gets here. */
 8200d94:	003fff06 	br	8200d94 <main+0x7c>

08200d98 <led_bit_toggle>:
 * Development Board which controls 8 LEDs, D0 - D7.
 * 
 */
 
void led_bit_toggle(OS_FLAGS bit)
{
 8200d98:	defffc04 	addi	sp,sp,-16
 8200d9c:	dfc00315 	stw	ra,12(sp)
 8200da0:	df000215 	stw	fp,8(sp)
 8200da4:	df000204 	addi	fp,sp,8
 8200da8:	2005883a 	mov	r2,r4
 8200dac:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS  led_8_val;
    INT8U error_code;
    
    led_8_val = OSFlagQuery(SSSLEDEventFlag, &error_code);
 8200db0:	d0a05c17 	ldw	r2,-32400(gp)
 8200db4:	e0fffe84 	addi	r3,fp,-6
 8200db8:	180b883a 	mov	r5,r3
 8200dbc:	1009883a 	mov	r4,r2
 8200dc0:	82180180 	call	8218018 <OSFlagQuery>
 8200dc4:	e0bffe0d 	sth	r2,-8(fp)
    alt_uCOSIIErrorHandler(error_code, 0);
 8200dc8:	e0bffe83 	ldbu	r2,-6(fp)
 8200dcc:	10803fcc 	andi	r2,r2,255
 8200dd0:	000b883a 	mov	r5,zero
 8200dd4:	1009883a 	mov	r4,r2
 8200dd8:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
    if (bit & led_8_val)
 8200ddc:	e0ffff0b 	ldhu	r3,-4(fp)
 8200de0:	e0bffe0b 	ldhu	r2,-8(fp)
 8200de4:	1884703a 	and	r2,r3,r2
 8200de8:	10bfffcc 	andi	r2,r2,65535
 8200dec:	10000f26 	beq	r2,zero,8200e2c <led_bit_toggle+0x94>
    {
       led_8_val = OSFlagPost(SSSLEDEventFlag, bit, OS_FLAG_CLR, &error_code);
 8200df0:	d0a05c17 	ldw	r2,-32400(gp)
 8200df4:	e0ffff0b 	ldhu	r3,-4(fp)
 8200df8:	e13ffe84 	addi	r4,fp,-6
 8200dfc:	200f883a 	mov	r7,r4
 8200e00:	000d883a 	mov	r6,zero
 8200e04:	180b883a 	mov	r5,r3
 8200e08:	1009883a 	mov	r4,r2
 8200e0c:	8217c840 	call	8217c84 <OSFlagPost>
 8200e10:	e0bffe0d 	sth	r2,-8(fp)
       alt_uCOSIIErrorHandler(error_code, 0);
 8200e14:	e0bffe83 	ldbu	r2,-6(fp)
 8200e18:	10803fcc 	andi	r2,r2,255
 8200e1c:	000b883a 	mov	r5,zero
 8200e20:	1009883a 	mov	r4,r2
 8200e24:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
    #ifdef LED_PIO_BASE
       IOWR_ALTERA_AVALON_PIO_DATA(LED_PIO_BASE, led_8_val);
       printf("Value for LED_PIO_BASE set to %d.\n", (INT8U)led_8_val);
    #endif
      
    return;
 8200e28:	00000f06 	br	8200e68 <led_bit_toggle+0xd0>
       led_8_val = OSFlagPost(SSSLEDEventFlag, bit, OS_FLAG_CLR, &error_code);
       alt_uCOSIIErrorHandler(error_code, 0);
    }
    else
    {
       led_8_val = OSFlagPost(SSSLEDEventFlag, bit, OS_FLAG_SET, &error_code);
 8200e2c:	d0a05c17 	ldw	r2,-32400(gp)
 8200e30:	e0ffff0b 	ldhu	r3,-4(fp)
 8200e34:	e13ffe84 	addi	r4,fp,-6
 8200e38:	200f883a 	mov	r7,r4
 8200e3c:	01800044 	movi	r6,1
 8200e40:	180b883a 	mov	r5,r3
 8200e44:	1009883a 	mov	r4,r2
 8200e48:	8217c840 	call	8217c84 <OSFlagPost>
 8200e4c:	e0bffe0d 	sth	r2,-8(fp)
       alt_uCOSIIErrorHandler(error_code, 0);
 8200e50:	e0bffe83 	ldbu	r2,-6(fp)
 8200e54:	10803fcc 	andi	r2,r2,255
 8200e58:	000b883a 	mov	r5,zero
 8200e5c:	1009883a 	mov	r4,r2
 8200e60:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
    #ifdef LED_PIO_BASE
       IOWR_ALTERA_AVALON_PIO_DATA(LED_PIO_BASE, led_8_val);
       printf("Value for LED_PIO_BASE set to %d.\n", (INT8U)led_8_val);
    #endif
      
    return;
 8200e64:	0001883a 	nop
}
 8200e68:	e037883a 	mov	sp,fp
 8200e6c:	dfc00117 	ldw	ra,4(sp)
 8200e70:	df000017 	ldw	fp,0(sp)
 8200e74:	dec00204 	addi	sp,sp,8
 8200e78:	f800283a 	ret

08200e7c <LED7SegLightshowTask>:
 * SSSLEDLightshowSem semaphore controlled in LEDManagementTask.
 * 
 */ 
 
void LED7SegLightshowTask()
{
 8200e7c:	defffd04 	addi	sp,sp,-12
 8200e80:	dfc00215 	stw	ra,8(sp)
 8200e84:	df000115 	stw	fp,4(sp)
 8200e88:	df000104 	addi	fp,sp,4
   {
    
      /* Wait 50 milliseconds between pattern updates, to make the pattern slow
       * enough for the human eye, and more impotantly, to give up control so
       * MicroC/OS-II can schedule other lower priority tasks. */ 
      OSTimeDlyHMSM(0,0,0,50);
 8200e8c:	01c00c84 	movi	r7,50
 8200e90:	000d883a 	mov	r6,zero
 8200e94:	000b883a 	mov	r5,zero
 8200e98:	0009883a 	mov	r4,zero
 8200e9c:	821bfdc0 	call	821bfdc <OSTimeDlyHMSM>
      
      /* Check that we still have the SSSLEDLightshowSem semaphore. If we don't,
       * then wait until the LEDManagement task gives it back to us. */
      OSSemPend(SSSLEDLightshowSem, 0, &error_code);
 8200ea0:	d0a05b17 	ldw	r2,-32404(gp)
 8200ea4:	e1bfff04 	addi	r6,fp,-4
 8200ea8:	000b883a 	mov	r5,zero
 8200eac:	1009883a 	mov	r4,r2
 8200eb0:	821a0d40 	call	821a0d4 <OSSemPend>
      alt_uCOSIIErrorHandler(error_code, 0);
 8200eb4:	e0bfff03 	ldbu	r2,-4(fp)
 8200eb8:	10803fcc 	andi	r2,r2,255
 8200ebc:	000b883a 	mov	r5,zero
 8200ec0:	1009883a 	mov	r4,r2
 8200ec4:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
      #if SEVEN_SEG_PIO_BASE
         led_7_seg_val = rand();
         IOWR_ALTERA_AVALON_PIO_DATA(SEVEN_SEG_PIO_BASE, led_7_seg_val);
      #endif
      
      error_code = OSSemPost(SSSLEDLightshowSem);
 8200ec8:	d0a05b17 	ldw	r2,-32404(gp)
 8200ecc:	1009883a 	mov	r4,r2
 8200ed0:	821a44c0 	call	821a44c <OSSemPost>
 8200ed4:	e0bfff05 	stb	r2,-4(fp)
      alt_uCOSIIErrorHandler(error_code, 0);
 8200ed8:	e0bfff03 	ldbu	r2,-4(fp)
 8200edc:	10803fcc 	andi	r2,r2,255
 8200ee0:	000b883a 	mov	r5,zero
 8200ee4:	1009883a 	mov	r4,r2
 8200ee8:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
      
   }
 8200eec:	003fe706 	br	8200e8c <LED7SegLightshowTask+0x10>

08200ef0 <LEDManagementTask>:
 * The task will read the SSSLedCommandQ for an 
 * in-coming message command from the SSSSimpleSocketServerTask. 
 */
 
void LEDManagementTask()
{
 8200ef0:	defffb04 	addi	sp,sp,-20
 8200ef4:	dfc00415 	stw	ra,16(sp)
 8200ef8:	df000315 	stw	fp,12(sp)
 8200efc:	df000304 	addi	fp,sp,12
  
  INT32U led_command; 
  BOOLEAN SSSLEDLightshowActive;
  INT8U error_code;
  
  SSSLEDLightshowActive = OS_TRUE;
 8200f00:	00800044 	movi	r2,1
 8200f04:	e0bffd05 	stb	r2,-12(fp)
  
  while(1)
  {
    led_command = (INT32U)OSQPend(SSSLEDCommandQ, 0, &error_code);
 8200f08:	d0a05a17 	ldw	r2,-32408(gp)
 8200f0c:	e0ffff04 	addi	r3,fp,-4
 8200f10:	180d883a 	mov	r6,r3
 8200f14:	000b883a 	mov	r5,zero
 8200f18:	1009883a 	mov	r4,r2
 8200f1c:	821922c0 	call	821922c <OSQPend>
 8200f20:	e0bffe15 	stw	r2,-8(fp)
   
    alt_uCOSIIErrorHandler(error_code, 0);
 8200f24:	e0bfff03 	ldbu	r2,-4(fp)
 8200f28:	10803fcc 	andi	r2,r2,255
 8200f2c:	000b883a 	mov	r5,zero
 8200f30:	1009883a 	mov	r4,r2
 8200f34:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
        
    switch (led_command) {
 8200f38:	e0bffe17 	ldw	r2,-8(fp)
 8200f3c:	10bff404 	addi	r2,r2,-48
 8200f40:	10c00928 	cmpgeui	r3,r2,36
 8200f44:	18005d1e 	bne	r3,zero,82010bc <LEDManagementTask+0x1cc>
 8200f48:	100690ba 	slli	r3,r2,2
 8200f4c:	00820834 	movhi	r2,2080
 8200f50:	1083d804 	addi	r2,r2,3936
 8200f54:	1885883a 	add	r2,r3,r2
 8200f58:	10800017 	ldw	r2,0(r2)
 8200f5c:	1000683a 	jmp	r2
 8200f60:	08200ff0 	cmpltui	zero,at,32831
 8200f64:	08200ffc 	xorhi	zero,at,32831
 8200f68:	08201008 	cmpgei	zero,at,-32704
 8200f6c:	08201014 	ori	zero,at,32832
 8200f70:	08201020 	cmpeqi	zero,at,-32704
 8200f74:	0820102c 	andhi	zero,at,32832
 8200f78:	08201038 	rdprs	zero,at,-32704
 8200f7c:	08201044 	addi	zero,at,-32703
 8200f80:	082010bc 	xorhi	zero,at,32834
 8200f84:	082010bc 	xorhi	zero,at,32834
 8200f88:	082010bc 	xorhi	zero,at,32834
 8200f8c:	082010bc 	xorhi	zero,at,32834
 8200f90:	082010bc 	xorhi	zero,at,32834
 8200f94:	082010bc 	xorhi	zero,at,32834
 8200f98:	082010bc 	xorhi	zero,at,32834
 8200f9c:	082010bc 	xorhi	zero,at,32834
 8200fa0:	082010bc 	xorhi	zero,at,32834
 8200fa4:	082010bc 	xorhi	zero,at,32834
 8200fa8:	082010bc 	xorhi	zero,at,32834
 8200fac:	082010bc 	xorhi	zero,at,32834
 8200fb0:	082010bc 	xorhi	zero,at,32834
 8200fb4:	082010bc 	xorhi	zero,at,32834
 8200fb8:	082010bc 	xorhi	zero,at,32834
 8200fbc:	082010bc 	xorhi	zero,at,32834
 8200fc0:	082010bc 	xorhi	zero,at,32834
 8200fc4:	082010bc 	xorhi	zero,at,32834
 8200fc8:	082010bc 	xorhi	zero,at,32834
 8200fcc:	082010bc 	xorhi	zero,at,32834
 8200fd0:	082010bc 	xorhi	zero,at,32834
 8200fd4:	082010bc 	xorhi	zero,at,32834
 8200fd8:	082010bc 	xorhi	zero,at,32834
 8200fdc:	082010bc 	xorhi	zero,at,32834
 8200fe0:	082010bc 	xorhi	zero,at,32834
 8200fe4:	082010bc 	xorhi	zero,at,32834
 8200fe8:	082010bc 	xorhi	zero,at,32834
 8200fec:	08201050 	cmplti	zero,at,-32703
      case CMD_LEDS_BIT_0_TOGGLE:
         led_bit_toggle(BIT_0);
 8200ff0:	01000044 	movi	r4,1
 8200ff4:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8200ff8:	00003106 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_1_TOGGLE:
         led_bit_toggle(BIT_1);
 8200ffc:	01000084 	movi	r4,2
 8201000:	8200d980 	call	8200d98 <led_bit_toggle>
         break;   
 8201004:	00002e06 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_2_TOGGLE:
         led_bit_toggle(BIT_2);
 8201008:	01000104 	movi	r4,4
 820100c:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8201010:	00002b06 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_3_TOGGLE:
         led_bit_toggle(BIT_3);
 8201014:	01000204 	movi	r4,8
 8201018:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 820101c:	00002806 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_4_TOGGLE:
         led_bit_toggle(BIT_4);
 8201020:	01000404 	movi	r4,16
 8201024:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8201028:	00002506 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_5_TOGGLE:
         led_bit_toggle(BIT_5);
 820102c:	01000804 	movi	r4,32
 8201030:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8201034:	00002206 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_6_TOGGLE:
         led_bit_toggle(BIT_6);
 8201038:	01001004 	movi	r4,64
 820103c:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8201040:	00001f06 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_7_TOGGLE:
         led_bit_toggle(BIT_7);
 8201044:	01002004 	movi	r4,128
 8201048:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 820104c:	00001c06 	br	82010c0 <LEDManagementTask+0x1d0>
         /* The SSSLEDLightshowSem semaphore is checked by LED7SegLightshowTask 
          * each time it updates 7 segment LED displays, U8 and U9.  Grab the 
          * semaphore (pend) away from the lightshow task to toggle the lightshow off, 
          * and give up the semaphore (post) to turn the lightshow back on.  
          */
         if (SSSLEDLightshowActive == OS_FALSE)
 8201050:	e0bffd03 	ldbu	r2,-12(fp)
 8201054:	10000c1e 	bne	r2,zero,8201088 <LEDManagementTask+0x198>
         {
             error_code = OSSemPost(SSSLEDLightshowSem);
 8201058:	d0a05b17 	ldw	r2,-32404(gp)
 820105c:	1009883a 	mov	r4,r2
 8201060:	821a44c0 	call	821a44c <OSSemPost>
 8201064:	e0bfff05 	stb	r2,-4(fp)
             alt_uCOSIIErrorHandler(error_code, 0);
 8201068:	e0bfff03 	ldbu	r2,-4(fp)
 820106c:	10803fcc 	andi	r2,r2,255
 8201070:	000b883a 	mov	r5,zero
 8201074:	1009883a 	mov	r4,r2
 8201078:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
             SSSLEDLightshowActive = OS_TRUE;
 820107c:	00800044 	movi	r2,1
 8201080:	e0bffd05 	stb	r2,-12(fp)
         {
             OSSemPend(SSSLEDLightshowSem, 0, &error_code);
             alt_uCOSIIErrorHandler(error_code, 0); 
             SSSLEDLightshowActive = OS_FALSE;
         }     
         break;
 8201084:	00000e06 	br	82010c0 <LEDManagementTask+0x1d0>
             alt_uCOSIIErrorHandler(error_code, 0);
             SSSLEDLightshowActive = OS_TRUE;
         }
         else
         {
             OSSemPend(SSSLEDLightshowSem, 0, &error_code);
 8201088:	d0a05b17 	ldw	r2,-32404(gp)
 820108c:	e0ffff04 	addi	r3,fp,-4
 8201090:	180d883a 	mov	r6,r3
 8201094:	000b883a 	mov	r5,zero
 8201098:	1009883a 	mov	r4,r2
 820109c:	821a0d40 	call	821a0d4 <OSSemPend>
             alt_uCOSIIErrorHandler(error_code, 0); 
 82010a0:	e0bfff03 	ldbu	r2,-4(fp)
 82010a4:	10803fcc 	andi	r2,r2,255
 82010a8:	000b883a 	mov	r5,zero
 82010ac:	1009883a 	mov	r4,r2
 82010b0:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
             SSSLEDLightshowActive = OS_FALSE;
 82010b4:	e03ffd05 	stb	zero,-12(fp)
         }     
         break;
 82010b8:	00000106 	br	82010c0 <LEDManagementTask+0x1d0>
      default:     
        /* Discard unknown LED commands. */
        break;
 82010bc:	0001883a 	nop
    } /* switch led_command */
  } /* while(1) */
 82010c0:	003f9106 	br	8200f08 <LEDManagementTask+0x18>

082010c4 <get_mac_addr>:
* Read the MAC address in a board specific way. Prompt user to enter serial 
* number to generate MAC address if failed to read from flash.
*
*/
int get_mac_addr(NET net, unsigned char mac_addr[6])
{
 82010c4:	defffb04 	addi	sp,sp,-20
 82010c8:	dfc00415 	stw	ra,16(sp)
 82010cc:	df000315 	stw	fp,12(sp)
 82010d0:	df000304 	addi	fp,sp,12
 82010d4:	e13ffe15 	stw	r4,-8(fp)
 82010d8:	e17fff15 	stw	r5,-4(fp)
    error_t error = 0;
 82010dc:	e03ffd15 	stw	zero,-12(fp)
    
    error = get_board_mac_addr(mac_addr);
 82010e0:	e13fff17 	ldw	r4,-4(fp)
 82010e4:	82016140 	call	8201614 <get_board_mac_addr>
 82010e8:	e0bffd15 	stw	r2,-12(fp)
    
    if(error)
 82010ec:	e0bffd17 	ldw	r2,-12(fp)
 82010f0:	10000326 	beq	r2,zero,8201100 <get_mac_addr+0x3c>
    {
        /* Failed read MAC address from flash, prompt user to enter serial 
           number to generate MAC address. */
        error = generate_mac_addr(mac_addr);
 82010f4:	e13fff17 	ldw	r4,-4(fp)
 82010f8:	82014d80 	call	82014d8 <generate_mac_addr>
 82010fc:	e0bffd15 	stw	r2,-12(fp)
    }
    return error;
 8201100:	e0bffd17 	ldw	r2,-12(fp)
}
 8201104:	e037883a 	mov	sp,fp
 8201108:	dfc00117 	ldw	ra,4(sp)
 820110c:	df000017 	ldw	fp,0(sp)
 8201110:	dec00204 	addi	sp,sp,8
 8201114:	f800283a 	ret

08201118 <get_ip_addr>:
int get_ip_addr(alt_iniche_dev *p_dev,
                ip_addr* ipaddr,
                ip_addr* netmask,
                ip_addr* gw,
                int* use_dhcp)
{
 8201118:	defffb04 	addi	sp,sp,-20
 820111c:	df000415 	stw	fp,16(sp)
 8201120:	df000404 	addi	fp,sp,16
 8201124:	e13ffc15 	stw	r4,-16(fp)
 8201128:	e17ffd15 	stw	r5,-12(fp)
 820112c:	e1bffe15 	stw	r6,-8(fp)
 8201130:	e1ffff15 	stw	r7,-4(fp)

    IP4_ADDR(*ipaddr, IPADDR0, IPADDR1, IPADDR2, IPADDR3);
 8201134:	e0bffd17 	ldw	r2,-12(fp)
 8201138:	10000015 	stw	zero,0(r2)
    IP4_ADDR(*gw, GWADDR0, GWADDR1, GWADDR2, GWADDR3);
 820113c:	e0bfff17 	ldw	r2,-4(fp)
 8201140:	10000015 	stw	zero,0(r2)
    IP4_ADDR(*netmask, MSKADDR0, MSKADDR1, MSKADDR2, MSKADDR3);
 8201144:	e0fffe17 	ldw	r3,-8(fp)
 8201148:	00804034 	movhi	r2,256
 820114c:	10bfffc4 	addi	r2,r2,-1
 8201150:	18800015 	stw	r2,0(r3)

#ifdef DHCP_CLIENT
    *use_dhcp = 1;
 8201154:	e0800117 	ldw	r2,4(fp)
 8201158:	00c00044 	movi	r3,1
 820115c:	10c00015 	stw	r3,0(r2)
        ip4_addr4(*ipaddr));
#endif /* not DHCP_CLIENT */


    /* Non-standard API: return 1 for success */
    return 1;
 8201160:	00800044 	movi	r2,1
}
 8201164:	e037883a 	mov	sp,fp
 8201168:	df000017 	ldw	fp,0(sp)
 820116c:	dec00104 	addi	sp,sp,4
 8201170:	f800283a 	ret

08201174 <get_serial_number>:
*
* Prompt user to enter 9-digit serial number. 
*
*/
alt_u32 get_serial_number (void)
{
 8201174:	defff904 	addi	sp,sp,-28
 8201178:	dfc00615 	stw	ra,24(sp)
 820117c:	df000515 	stw	fp,20(sp)
 8201180:	df000504 	addi	fp,sp,20
    alt_u32 ser_num = 0;
 8201184:	e03ffb15 	stw	zero,-20(fp)
    char serial_number[9];
    int i = 0;
 8201188:	e03ffc15 	stw	zero,-16(fp)
    
    while(!ser_num)
 820118c:	00006006 	br	8201310 <get_serial_number+0x19c>
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
 8201190:	01020974 	movhi	r4,2085
 8201194:	2132ad04 	addi	r4,r4,-13644
 8201198:	82036240 	call	8203624 <puts>
        printf("label under your Nios dev. board. The first 3 digits of the \n");
 820119c:	01020974 	movhi	r4,2085
 82011a0:	2132bd04 	addi	r4,r4,-13580
 82011a4:	82036240 	call	8203624 <puts>
        printf("label are ASJ and the serial number follows this.\n -->");
 82011a8:	01020974 	movhi	r4,2085
 82011ac:	2132cd04 	addi	r4,r4,-13516
 82011b0:	82033a00 	call	82033a0 <printf>
        
        for(i=0; i<9; i++)
 82011b4:	e03ffc15 	stw	zero,-16(fp)
 82011b8:	00002606 	br	8201254 <get_serial_number+0xe0>
        {
            serial_number[i] = getchar();
 82011bc:	d0a00217 	ldw	r2,-32760(gp)
 82011c0:	10800117 	ldw	r2,4(r2)
 82011c4:	1009883a 	mov	r4,r2
 82011c8:	8202e880 	call	8202e88 <getc>
 82011cc:	1009883a 	mov	r4,r2
 82011d0:	e0fffd04 	addi	r3,fp,-12
 82011d4:	e0bffc17 	ldw	r2,-16(fp)
 82011d8:	1885883a 	add	r2,r3,r2
 82011dc:	11000005 	stb	r4,0(r2)
            putchar(serial_number[i]);
 82011e0:	e0fffd04 	addi	r3,fp,-12
 82011e4:	e0bffc17 	ldw	r2,-16(fp)
 82011e8:	1885883a 	add	r2,r3,r2
 82011ec:	10800003 	ldbu	r2,0(r2)
 82011f0:	10c03fcc 	andi	r3,r2,255
 82011f4:	18c0201c 	xori	r3,r3,128
 82011f8:	18ffe004 	addi	r3,r3,-128
 82011fc:	d0a00217 	ldw	r2,-32760(gp)
 8201200:	10800217 	ldw	r2,8(r2)
 8201204:	100b883a 	mov	r5,r2
 8201208:	1809883a 	mov	r4,r3
 820120c:	820347c0 	call	820347c <putc>
            
            /* Handle backspaces.  How civilized. */
            if ((serial_number[i] == 0x08) && (i >= 0)) 
 8201210:	e0fffd04 	addi	r3,fp,-12
 8201214:	e0bffc17 	ldw	r2,-16(fp)
 8201218:	1885883a 	add	r2,r3,r2
 820121c:	10800003 	ldbu	r2,0(r2)
 8201220:	10803fcc 	andi	r2,r2,255
 8201224:	1080201c 	xori	r2,r2,128
 8201228:	10bfe004 	addi	r2,r2,-128
 820122c:	10800218 	cmpnei	r2,r2,8
 8201230:	1000051e 	bne	r2,zero,8201248 <get_serial_number+0xd4>
 8201234:	e0bffc17 	ldw	r2,-16(fp)
 8201238:	10000316 	blt	r2,zero,8201248 <get_serial_number+0xd4>
            {
                i--;
 820123c:	e0bffc17 	ldw	r2,-16(fp)
 8201240:	10bfffc4 	addi	r2,r2,-1
 8201244:	e0bffc15 	stw	r2,-16(fp)
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
        printf("label under your Nios dev. board. The first 3 digits of the \n");
        printf("label are ASJ and the serial number follows this.\n -->");
        
        for(i=0; i<9; i++)
 8201248:	e0bffc17 	ldw	r2,-16(fp)
 820124c:	10800044 	addi	r2,r2,1
 8201250:	e0bffc15 	stw	r2,-16(fp)
 8201254:	e0bffc17 	ldw	r2,-16(fp)
 8201258:	10800250 	cmplti	r2,r2,9
 820125c:	103fd71e 	bne	r2,zero,82011bc <get_serial_number+0x48>
            if ((serial_number[i] == 0x08) && (i >= 0)) 
            {
                i--;
            }
        }
        printf("\n");
 8201260:	01000284 	movi	r4,10
 8201264:	820354c0 	call	820354c <putchar>
                
        for(i=0; i<9; i++)
 8201268:	e03ffc15 	stw	zero,-16(fp)
 820126c:	00002506 	br	8201304 <get_serial_number+0x190>
        {
            if (isdigit(serial_number[i]))
 8201270:	d0e00017 	ldw	r3,-32768(gp)
 8201274:	e13ffd04 	addi	r4,fp,-12
 8201278:	e0bffc17 	ldw	r2,-16(fp)
 820127c:	2085883a 	add	r2,r4,r2
 8201280:	10800003 	ldbu	r2,0(r2)
 8201284:	10803fcc 	andi	r2,r2,255
 8201288:	1080201c 	xori	r2,r2,128
 820128c:	10bfe004 	addi	r2,r2,-128
 8201290:	10800044 	addi	r2,r2,1
 8201294:	1885883a 	add	r2,r3,r2
 8201298:	10800003 	ldbu	r2,0(r2)
 820129c:	10803fcc 	andi	r2,r2,255
 82012a0:	1080010c 	andi	r2,r2,4
 82012a4:	10000f26 	beq	r2,zero,82012e4 <get_serial_number+0x170>
            {
                ser_num *= 10;
 82012a8:	e0bffb17 	ldw	r2,-20(fp)
 82012ac:	108002a4 	muli	r2,r2,10
 82012b0:	e0bffb15 	stw	r2,-20(fp)
                ser_num += serial_number[i] - '0';
 82012b4:	e0fffd04 	addi	r3,fp,-12
 82012b8:	e0bffc17 	ldw	r2,-16(fp)
 82012bc:	1885883a 	add	r2,r3,r2
 82012c0:	10800003 	ldbu	r2,0(r2)
 82012c4:	10c03fcc 	andi	r3,r2,255
 82012c8:	18c0201c 	xori	r3,r3,128
 82012cc:	18ffe004 	addi	r3,r3,-128
 82012d0:	e0bffb17 	ldw	r2,-20(fp)
 82012d4:	1885883a 	add	r2,r3,r2
 82012d8:	10bff404 	addi	r2,r2,-48
 82012dc:	e0bffb15 	stw	r2,-20(fp)
 82012e0:	00000506 	br	82012f8 <get_serial_number+0x184>
            }
            else
            {
                ser_num = 0;
 82012e4:	e03ffb15 	stw	zero,-20(fp)
                printf("Serial number only contains decimal digits and is non-zero\n");
 82012e8:	01020974 	movhi	r4,2085
 82012ec:	2132db04 	addi	r4,r4,-13460
 82012f0:	82036240 	call	8203624 <puts>
                break;
 82012f4:	00000606 	br	8201310 <get_serial_number+0x19c>
                i--;
            }
        }
        printf("\n");
                
        for(i=0; i<9; i++)
 82012f8:	e0bffc17 	ldw	r2,-16(fp)
 82012fc:	10800044 	addi	r2,r2,1
 8201300:	e0bffc15 	stw	r2,-16(fp)
 8201304:	e0bffc17 	ldw	r2,-16(fp)
 8201308:	10800250 	cmplti	r2,r2,9
 820130c:	103fd81e 	bne	r2,zero,8201270 <get_serial_number+0xfc>
{
    alt_u32 ser_num = 0;
    char serial_number[9];
    int i = 0;
    
    while(!ser_num)
 8201310:	e0bffb17 	ldw	r2,-20(fp)
 8201314:	103f9e26 	beq	r2,zero,8201190 <get_serial_number+0x1c>
                break;
            }
        }
    }
    
    return ser_num;
 8201318:	e0bffb17 	ldw	r2,-20(fp)
}
 820131c:	e037883a 	mov	sp,fp
 8201320:	dfc00117 	ldw	ra,4(sp)
 8201324:	df000017 	ldw	fp,0(sp)
 8201328:	dec00204 	addi	sp,sp,8
 820132c:	f800283a 	ret

08201330 <generate_and_store_mac_addr>:
 * sections. These fail-safe static settings are compatible with previous
 * Nios Ethernet designs, and allow the "factory-safe" design to behave 
 * as expected if the last flash sector is erased.
 */
error_t generate_and_store_mac_addr()
{
 8201330:	deffef04 	addi	sp,sp,-68
 8201334:	dfc01015 	stw	ra,64(sp)
 8201338:	df000f15 	stw	fp,60(sp)
 820133c:	df000f04 	addi	fp,sp,60
    error_t error = -1;
 8201340:	00bfffc4 	movi	r2,-1
 8201344:	e0bff115 	stw	r2,-60(fp)
    alt_u32 ser_num = 0;
 8201348:	e03ff215 	stw	zero,-56(fp)
    char flash_content[32];
    alt_flash_fd* flash_handle;
    
    printf("Can't read the MAC address from your board (this probably means\n");
 820134c:	01020974 	movhi	r4,2085
 8201350:	2132ea04 	addi	r4,r4,-13400
 8201354:	82036240 	call	8203624 <puts>
    printf("that your flash was erased). We will assign you a MAC address and\n");
 8201358:	01020974 	movhi	r4,2085
 820135c:	2132fa04 	addi	r4,r4,-13336
 8201360:	82036240 	call	8203624 <puts>
    printf("static network settings\n\n");
 8201364:	01020974 	movhi	r4,2085
 8201368:	21330b04 	addi	r4,r4,-13268
 820136c:	82036240 	call	8203624 <puts>
    
    ser_num = 123456789;//get_serial_number();
 8201370:	0081d734 	movhi	r2,1884
 8201374:	10b34544 	addi	r2,r2,-13035
 8201378:	e0bff215 	stw	r2,-56(fp)
  
    if (ser_num)
 820137c:	e0bff217 	ldw	r2,-56(fp)
 8201380:	10004f26 	beq	r2,zero,82014c0 <generate_and_store_mac_addr+0x190>
    {
        /* This says the image is safe */
        flash_content[0] = 0xfe;
 8201384:	00bfff84 	movi	r2,-2
 8201388:	e0bff805 	stb	r2,-32(fp)
        flash_content[1] = 0x5a;
 820138c:	00801684 	movi	r2,90
 8201390:	e0bff845 	stb	r2,-31(fp)
        flash_content[2] = 0x0;
 8201394:	e03ff885 	stb	zero,-30(fp)
        flash_content[3] = 0x0;
 8201398:	e03ff8c5 	stb	zero,-29(fp)
        
        /* This is the Altera Vendor ID */
        flash_content[4] = 0x0;
 820139c:	e03ff905 	stb	zero,-28(fp)
        flash_content[5] = 0x7;
 82013a0:	008001c4 	movi	r2,7
 82013a4:	e0bff945 	stb	r2,-27(fp)
        flash_content[6] = 0xed;
 82013a8:	00bffb44 	movi	r2,-19
 82013ac:	e0bff985 	stb	r2,-26(fp)
        
        /* Reserverd Board identifier for erase boards */
        flash_content[7] = 0xFF;
 82013b0:	00bfffc4 	movi	r2,-1
 82013b4:	e0bff9c5 	stb	r2,-25(fp)
        flash_content[8] = (ser_num & 0xff00) >> 8;
 82013b8:	e0bff217 	ldw	r2,-56(fp)
 82013bc:	10bfc00c 	andi	r2,r2,65280
 82013c0:	1004d23a 	srli	r2,r2,8
 82013c4:	e0bffa05 	stb	r2,-24(fp)
        flash_content[9] = ser_num & 0xff;
 82013c8:	e0bff217 	ldw	r2,-56(fp)
 82013cc:	e0bffa45 	stb	r2,-23(fp)
        
        /* Then comes a 16-bit "flags" field */
        flash_content[10] = 0xFF;
 82013d0:	00bfffc4 	movi	r2,-1
 82013d4:	e0bffa85 	stb	r2,-22(fp)
        flash_content[11] = 0xFF;
 82013d8:	00bfffc4 	movi	r2,-1
 82013dc:	e0bffac5 	stb	r2,-21(fp)
        
        /* Then comes the static IP address */
        flash_content[12] = IPADDR0;
 82013e0:	e03ffb05 	stb	zero,-20(fp)
        flash_content[13] = IPADDR1;
 82013e4:	e03ffb45 	stb	zero,-19(fp)
        flash_content[14] = IPADDR2;
 82013e8:	e03ffb85 	stb	zero,-18(fp)
        flash_content[15] = IPADDR3;
 82013ec:	e03ffbc5 	stb	zero,-17(fp)
        
        /* Then comes the static nameserver address */
        flash_content[16] = 0xFF;
 82013f0:	00bfffc4 	movi	r2,-1
 82013f4:	e0bffc05 	stb	r2,-16(fp)
        flash_content[17] = 0xFF;
 82013f8:	00bfffc4 	movi	r2,-1
 82013fc:	e0bffc45 	stb	r2,-15(fp)
        flash_content[18] = 0xFF;
 8201400:	00bfffc4 	movi	r2,-1
 8201404:	e0bffc85 	stb	r2,-14(fp)
        flash_content[19] = 0xFF;
 8201408:	00bfffc4 	movi	r2,-1
 820140c:	e0bffcc5 	stb	r2,-13(fp)
        
        /* Then comes the static subnet mask */
        flash_content[20] = MSKADDR0;
 8201410:	00bfffc4 	movi	r2,-1
 8201414:	e0bffd05 	stb	r2,-12(fp)
        flash_content[21] = MSKADDR1;
 8201418:	00bfffc4 	movi	r2,-1
 820141c:	e0bffd45 	stb	r2,-11(fp)
        flash_content[22] = MSKADDR2;
 8201420:	00bfffc4 	movi	r2,-1
 8201424:	e0bffd85 	stb	r2,-10(fp)
        flash_content[23] = MSKADDR3;
 8201428:	e03ffdc5 	stb	zero,-9(fp)
        
        /* Then comes the static gateway address */
        flash_content[24] = GWADDR0;
 820142c:	e03ffe05 	stb	zero,-8(fp)
        flash_content[25] = GWADDR1;
 8201430:	e03ffe45 	stb	zero,-7(fp)
        flash_content[26] = GWADDR2;
 8201434:	e03ffe85 	stb	zero,-6(fp)
        flash_content[27] = GWADDR3;
 8201438:	e03ffec5 	stb	zero,-5(fp)
        
        /* And finally whether to use DHCP - set all bits to be safe */
        flash_content[28] = 0xFF;
 820143c:	00bfffc4 	movi	r2,-1
 8201440:	e0bfff05 	stb	r2,-4(fp)
        flash_content[29] = 0xFF;
 8201444:	00bfffc4 	movi	r2,-1
 8201448:	e0bfff45 	stb	r2,-3(fp)
        flash_content[30] = 0xFF;
 820144c:	00bfffc4 	movi	r2,-1
 8201450:	e0bfff85 	stb	r2,-2(fp)
        flash_content[31] = 0xFF;
 8201454:	00bfffc4 	movi	r2,-1
 8201458:	e0bfffc5 	stb	r2,-1(fp)
        
        /* Write the MAC address to flash */
        flash_handle = alt_flash_open_dev(EXT_FLASH_NAME);
 820145c:	01020974 	movhi	r4,2085
 8201460:	21331204 	addi	r4,r4,-13240
 8201464:	82143d00 	call	82143d0 <alt_flash_open_dev>
 8201468:	e0bff315 	stw	r2,-52(fp)
        if (flash_handle)
 820146c:	e0bff317 	ldw	r2,-52(fp)
 8201470:	10001326 	beq	r2,zero,82014c0 <generate_and_store_mac_addr+0x190>
        {
            alt_write_flash(flash_handle,
 8201474:	d0a05717 	ldw	r2,-32420(gp)
 8201478:	1007883a 	mov	r3,r2
 820147c:	e0bff317 	ldw	r2,-52(fp)
 8201480:	e0bff415 	stw	r2,-48(fp)
 8201484:	e0fff515 	stw	r3,-44(fp)
 8201488:	e0bff804 	addi	r2,fp,-32
 820148c:	e0bff615 	stw	r2,-40(fp)
 8201490:	00800804 	movi	r2,32
 8201494:	e0bff715 	stw	r2,-36(fp)
                                                           alt_flash_fd* fd, 
                                                           int offset, 
                                                           const void* src_addr, 
                                                           int length )
{
  return fd->write( fd, offset, src_addr, length );
 8201498:	e0bff417 	ldw	r2,-48(fp)
 820149c:	10800517 	ldw	r2,20(r2)
 82014a0:	e1fff717 	ldw	r7,-36(fp)
 82014a4:	e1bff617 	ldw	r6,-40(fp)
 82014a8:	e17ff517 	ldw	r5,-44(fp)
 82014ac:	e13ff417 	ldw	r4,-48(fp)
 82014b0:	103ee83a 	callr	r2
                            last_flash_sector_offset,
                            flash_content,
                            32);
            alt_flash_close_dev(flash_handle);
 82014b4:	e13ff317 	ldw	r4,-52(fp)
 82014b8:	82144380 	call	8214438 <alt_flash_close_dev>
            error = 0;
 82014bc:	e03ff115 	stw	zero,-60(fp)
        }
    }

    return error;    
 82014c0:	e0bff117 	ldw	r2,-60(fp)
}
 82014c4:	e037883a 	mov	sp,fp
 82014c8:	dfc00117 	ldw	ra,4(sp)
 82014cc:	df000017 	ldw	fp,0(sp)
 82014d0:	dec00204 	addi	sp,sp,8
 82014d4:	f800283a 	ret

082014d8 <generate_mac_addr>:
 * Development Board serial number is 040800017, the corresponding ethernet 
 * number generated will be 00:07:ED:FF:8F:11.
 * 
 */
error_t generate_mac_addr(unsigned char mac_addr[6])
{
 82014d8:	defff804 	addi	sp,sp,-32
 82014dc:	dfc00715 	stw	ra,28(sp)
 82014e0:	df000615 	stw	fp,24(sp)
 82014e4:	df000604 	addi	fp,sp,24
 82014e8:	e13fff15 	stw	r4,-4(fp)
    error_t error = -1;
 82014ec:	00bfffc4 	movi	r2,-1
 82014f0:	e0bffd15 	stw	r2,-12(fp)
    alt_u32 ser_num = 0;
 82014f4:	e03ffe15 	stw	zero,-8(fp)
    
    printf("\nCan't read the MAC address from your board. We will assign you\n");
 82014f8:	01020974 	movhi	r4,2085
 82014fc:	21331604 	addi	r4,r4,-13224
 8201500:	82036240 	call	8203624 <puts>
    printf("a MAC address.\n\n");
 8201504:	01020974 	movhi	r4,2085
 8201508:	21332604 	addi	r4,r4,-13160
 820150c:	82036240 	call	8203624 <puts>
    
    ser_num = 123456789;//get_serial_number();
 8201510:	0081d734 	movhi	r2,1884
 8201514:	10b34544 	addi	r2,r2,-13035
 8201518:	e0bffe15 	stw	r2,-8(fp)
  
    if (ser_num)
 820151c:	e0bffe17 	ldw	r2,-8(fp)
 8201520:	10003626 	beq	r2,zero,82015fc <generate_mac_addr+0x124>
    {
        /* This is the Altera Vendor ID */
        mac_addr[0] = 0x0;
 8201524:	e0bfff17 	ldw	r2,-4(fp)
 8201528:	10000005 	stb	zero,0(r2)
        mac_addr[1] = 0x7;
 820152c:	e0bfff17 	ldw	r2,-4(fp)
 8201530:	10800044 	addi	r2,r2,1
 8201534:	00c001c4 	movi	r3,7
 8201538:	10c00005 	stb	r3,0(r2)
        mac_addr[2] = 0xed;
 820153c:	e0bfff17 	ldw	r2,-4(fp)
 8201540:	10800084 	addi	r2,r2,2
 8201544:	00fffb44 	movi	r3,-19
 8201548:	10c00005 	stb	r3,0(r2)
        
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
 820154c:	e0bfff17 	ldw	r2,-4(fp)
 8201550:	108000c4 	addi	r2,r2,3
 8201554:	00ffffc4 	movi	r3,-1
 8201558:	10c00005 	stb	r3,0(r2)
        mac_addr[4] = (ser_num & 0xff00) >> 8;
 820155c:	e0bfff17 	ldw	r2,-4(fp)
 8201560:	10800104 	addi	r2,r2,4
 8201564:	e0fffe17 	ldw	r3,-8(fp)
 8201568:	18ffc00c 	andi	r3,r3,65280
 820156c:	1806d23a 	srli	r3,r3,8
 8201570:	10c00005 	stb	r3,0(r2)
        mac_addr[5] = ser_num & 0xff;
 8201574:	e0bfff17 	ldw	r2,-4(fp)
 8201578:	10800144 	addi	r2,r2,5
 820157c:	e0fffe17 	ldw	r3,-8(fp)
 8201580:	10c00005 	stb	r3,0(r2)
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
            mac_addr[0],
 8201584:	e0bfff17 	ldw	r2,-4(fp)
 8201588:	10800003 	ldbu	r2,0(r2)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 820158c:	11403fcc 	andi	r5,r2,255
            mac_addr[0],
            mac_addr[1],
 8201590:	e0bfff17 	ldw	r2,-4(fp)
 8201594:	10800044 	addi	r2,r2,1
 8201598:	10800003 	ldbu	r2,0(r2)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 820159c:	11803fcc 	andi	r6,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
 82015a0:	e0bfff17 	ldw	r2,-4(fp)
 82015a4:	10800084 	addi	r2,r2,2
 82015a8:	10800003 	ldbu	r2,0(r2)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 82015ac:	11c03fcc 	andi	r7,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
 82015b0:	e0bfff17 	ldw	r2,-4(fp)
 82015b4:	108000c4 	addi	r2,r2,3
 82015b8:	10800003 	ldbu	r2,0(r2)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 82015bc:	10803fcc 	andi	r2,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
 82015c0:	e0ffff17 	ldw	r3,-4(fp)
 82015c4:	18c00104 	addi	r3,r3,4
 82015c8:	18c00003 	ldbu	r3,0(r3)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 82015cc:	18c03fcc 	andi	r3,r3,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
 82015d0:	e13fff17 	ldw	r4,-4(fp)
 82015d4:	21000144 	addi	r4,r4,5
 82015d8:	21000003 	ldbu	r4,0(r4)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 82015dc:	21003fcc 	andi	r4,r4,255
 82015e0:	d9000215 	stw	r4,8(sp)
 82015e4:	d8c00115 	stw	r3,4(sp)
 82015e8:	d8800015 	stw	r2,0(sp)
 82015ec:	01020974 	movhi	r4,2085
 82015f0:	21332a04 	addi	r4,r4,-13144
 82015f4:	82033a00 	call	82033a0 <printf>
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
        
        error = 0;
 82015f8:	e03ffd15 	stw	zero,-12(fp)
    }
  
    return error;    
 82015fc:	e0bffd17 	ldw	r2,-12(fp)
}
 8201600:	e037883a 	mov	sp,fp
 8201604:	dfc00117 	ldw	ra,4(sp)
 8201608:	df000017 	ldw	fp,0(sp)
 820160c:	dec00204 	addi	sp,sp,8
 8201610:	f800283a 	ret

08201614 <get_board_mac_addr>:
*
* Read the MAC address in a board specific way
*
*/
error_t get_board_mac_addr(unsigned char mac_addr[6])
{
 8201614:	defff804 	addi	sp,sp,-32
 8201618:	dfc00715 	stw	ra,28(sp)
 820161c:	df000615 	stw	fp,24(sp)
 8201620:	df000604 	addi	fp,sp,24
 8201624:	e13fff15 	stw	r4,-4(fp)
    error_t error = 0;
 8201628:	e03ffd15 	stw	zero,-12(fp)
    alt_u32 signature;
    
    /* Get the flash sector with the MAC address. */
    error = FindLastFlashSectorOffset(&last_flash_sector_offset);
 820162c:	d1205704 	addi	r4,gp,-32420
 8201630:	82017ac0 	call	82017ac <FindLastFlashSectorOffset>
 8201634:	e0bffd15 	stw	r2,-12(fp)
    if (!error)
 8201638:	e0bffd17 	ldw	r2,-12(fp)
 820163c:	1000021e 	bne	r2,zero,8201648 <get_board_mac_addr+0x34>
        last_flash_sector = EXT_FLASH_BASE + last_flash_sector_offset;
 8201640:	d0a05717 	ldw	r2,-32420(gp)
 8201644:	d0a05815 	stw	r2,-32416(gp)
     * valid network settings are present, indicated by a signature of 0x00005afe at 
     * the first address of the last flash sector.  This hex value is chosen as the 
     * signature since it looks like the english word "SAFE", meaning that it is 
     * safe to use these network address values.  
    */
    if (!error)
 8201648:	e0bffd17 	ldw	r2,-12(fp)
 820164c:	1000081e 	bne	r2,zero,8201670 <get_board_mac_addr+0x5c>
    {
        signature = IORD_32DIRECT(last_flash_sector, 0);
 8201650:	d0a05817 	ldw	r2,-32416(gp)
 8201654:	10800037 	ldwio	r2,0(r2)
 8201658:	e0bffe15 	stw	r2,-8(fp)
        if (signature != 0x00005afe)
 820165c:	e0bffe17 	ldw	r2,-8(fp)
 8201660:	1096bfa0 	cmpeqi	r2,r2,23294
 8201664:	1000021e 	bne	r2,zero,8201670 <get_board_mac_addr+0x5c>
        {
          error = generate_and_store_mac_addr();
 8201668:	82013300 	call	8201330 <generate_and_store_mac_addr>
 820166c:	e0bffd15 	stw	r2,-12(fp)
        }
    }
  
    if (!error)
 8201670:	e0bffd17 	ldw	r2,-12(fp)
 8201674:	1000471e 	bne	r2,zero,8201794 <get_board_mac_addr+0x180>
    {
        mac_addr[0] = IORD_8DIRECT(last_flash_sector, 4);
 8201678:	d0a05817 	ldw	r2,-32416(gp)
 820167c:	10800104 	addi	r2,r2,4
 8201680:	10800023 	ldbuio	r2,0(r2)
 8201684:	10803fcc 	andi	r2,r2,255
 8201688:	1007883a 	mov	r3,r2
 820168c:	e0bfff17 	ldw	r2,-4(fp)
 8201690:	10c00005 	stb	r3,0(r2)
        mac_addr[1] = IORD_8DIRECT(last_flash_sector, 5);
 8201694:	e0bfff17 	ldw	r2,-4(fp)
 8201698:	10800044 	addi	r2,r2,1
 820169c:	d0e05817 	ldw	r3,-32416(gp)
 82016a0:	18c00144 	addi	r3,r3,5
 82016a4:	18c00023 	ldbuio	r3,0(r3)
 82016a8:	18c03fcc 	andi	r3,r3,255
 82016ac:	10c00005 	stb	r3,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
 82016b0:	e0bfff17 	ldw	r2,-4(fp)
 82016b4:	10800084 	addi	r2,r2,2
 82016b8:	d0e05817 	ldw	r3,-32416(gp)
 82016bc:	18c00184 	addi	r3,r3,6
 82016c0:	18c00023 	ldbuio	r3,0(r3)
 82016c4:	18c03fcc 	andi	r3,r3,255
 82016c8:	10c00005 	stb	r3,0(r2)
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
 82016cc:	e0bfff17 	ldw	r2,-4(fp)
 82016d0:	108000c4 	addi	r2,r2,3
 82016d4:	d0e05817 	ldw	r3,-32416(gp)
 82016d8:	18c001c4 	addi	r3,r3,7
 82016dc:	18c00023 	ldbuio	r3,0(r3)
 82016e0:	18c03fcc 	andi	r3,r3,255
 82016e4:	10c00005 	stb	r3,0(r2)
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
 82016e8:	e0bfff17 	ldw	r2,-4(fp)
 82016ec:	10800104 	addi	r2,r2,4
 82016f0:	d0e05817 	ldw	r3,-32416(gp)
 82016f4:	18c00204 	addi	r3,r3,8
 82016f8:	18c00023 	ldbuio	r3,0(r3)
 82016fc:	18c03fcc 	andi	r3,r3,255
 8201700:	10c00005 	stb	r3,0(r2)
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
 8201704:	e0bfff17 	ldw	r2,-4(fp)
 8201708:	10800144 	addi	r2,r2,5
 820170c:	d0e05817 	ldw	r3,-32416(gp)
 8201710:	18c00244 	addi	r3,r3,9
 8201714:	18c00023 	ldbuio	r3,0(r3)
 8201718:	18c03fcc 	andi	r3,r3,255
 820171c:	10c00005 	stb	r3,0(r2)
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
            mac_addr[0],
 8201720:	e0bfff17 	ldw	r2,-4(fp)
 8201724:	10800003 	ldbu	r2,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201728:	11403fcc 	andi	r5,r2,255
            mac_addr[0],
            mac_addr[1],
 820172c:	e0bfff17 	ldw	r2,-4(fp)
 8201730:	10800044 	addi	r2,r2,1
 8201734:	10800003 	ldbu	r2,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201738:	11803fcc 	andi	r6,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
 820173c:	e0bfff17 	ldw	r2,-4(fp)
 8201740:	10800084 	addi	r2,r2,2
 8201744:	10800003 	ldbu	r2,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201748:	11c03fcc 	andi	r7,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
 820174c:	e0bfff17 	ldw	r2,-4(fp)
 8201750:	108000c4 	addi	r2,r2,3
 8201754:	10800003 	ldbu	r2,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201758:	10803fcc 	andi	r2,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
 820175c:	e0ffff17 	ldw	r3,-4(fp)
 8201760:	18c00104 	addi	r3,r3,4
 8201764:	18c00003 	ldbu	r3,0(r3)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201768:	18c03fcc 	andi	r3,r3,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
 820176c:	e13fff17 	ldw	r4,-4(fp)
 8201770:	21000144 	addi	r4,r4,5
 8201774:	21000003 	ldbu	r4,0(r4)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201778:	21003fcc 	andi	r4,r4,255
 820177c:	d9000215 	stw	r4,8(sp)
 8201780:	d8c00115 	stw	r3,4(sp)
 8201784:	d8800015 	stw	r2,0(sp)
 8201788:	01020974 	movhi	r4,2085
 820178c:	21332a04 	addi	r4,r4,-13144
 8201790:	82033a00 	call	82033a0 <printf>
            mac_addr[4],
            mac_addr[5]);
    
    }
    
    return error;
 8201794:	e0bffd17 	ldw	r2,-12(fp)
}
 8201798:	e037883a 	mov	sp,fp
 820179c:	dfc00117 	ldw	ra,4(sp)
 82017a0:	df000017 	ldw	fp,0(sp)
 82017a4:	dec00204 	addi	sp,sp,8
 82017a8:	f800283a 	ret

082017ac <FindLastFlashSectorOffset>:
 * in pLastFlashSectorOffset.
 */

int FindLastFlashSectorOffset(
    alt_u32                     *pLastFlashSectorOffset)
{
 82017ac:	defff304 	addi	sp,sp,-52
 82017b0:	dfc00c15 	stw	ra,48(sp)
 82017b4:	df000b15 	stw	fp,44(sp)
 82017b8:	df000b04 	addi	fp,sp,44
 82017bc:	e13fff15 	stw	r4,-4(fp)
    flash_region                *regions;
    int                         numRegions;
    flash_region                *pLastRegion;
    int                         lastFlashSectorOffset;
    int                         n;
    int                         error = 0;
 82017c0:	e03ff815 	stw	zero,-32(fp)

    /* Open the flash device. */
    fd = alt_flash_open_dev(EXT_FLASH_NAME);
 82017c4:	01020974 	movhi	r4,2085
 82017c8:	21331204 	addi	r4,r4,-13240
 82017cc:	82143d00 	call	82143d0 <alt_flash_open_dev>
 82017d0:	e0bff915 	stw	r2,-28(fp)
    if (fd <= 0)
 82017d4:	e0bff917 	ldw	r2,-28(fp)
 82017d8:	1000021e 	bne	r2,zero,82017e4 <FindLastFlashSectorOffset+0x38>
        error = -1;
 82017dc:	00bfffc4 	movi	r2,-1
 82017e0:	e0bff815 	stw	r2,-32(fp)

    /* Get the flash info. */
    if (!error)
 82017e4:	e0bff817 	ldw	r2,-32(fp)
 82017e8:	10000d1e 	bne	r2,zero,8201820 <FindLastFlashSectorOffset+0x74>
 82017ec:	e0bff917 	ldw	r2,-28(fp)
 82017f0:	e0bffa15 	stw	r2,-24(fp)
 82017f4:	e0bffd04 	addi	r2,fp,-12
 82017f8:	e0bffb15 	stw	r2,-20(fp)
 82017fc:	e0bffe04 	addi	r2,fp,-8
 8201800:	e0bffc15 	stw	r2,-16(fp)
 */
static __inline__ int __attribute__ ((always_inline)) alt_get_flash_info( 
                                      alt_flash_fd* fd, flash_region** info, 
                                      int* number_of_regions)
{
  return fd->get_info( fd, info, number_of_regions);
 8201804:	e0bffa17 	ldw	r2,-24(fp)
 8201808:	10800717 	ldw	r2,28(r2)
 820180c:	e1bffc17 	ldw	r6,-16(fp)
 8201810:	e17ffb17 	ldw	r5,-20(fp)
 8201814:	e13ffa17 	ldw	r4,-24(fp)
 8201818:	103ee83a 	callr	r2
        error = alt_get_flash_info(fd, &regions, &numRegions);
 820181c:	e0bff815 	stw	r2,-32(fp)

    /* Find the last flash sector. */
    if (!error)
 8201820:	e0bff817 	ldw	r2,-32(fp)
 8201824:	1000211e 	bne	r2,zero,82018ac <FindLastFlashSectorOffset+0x100>
    {
        pLastRegion = &(regions[0]);
 8201828:	e0bffd17 	ldw	r2,-12(fp)
 820182c:	e0bff515 	stw	r2,-44(fp)
        for (n = 1; n < numRegions; n++)
 8201830:	00800044 	movi	r2,1
 8201834:	e0bff715 	stw	r2,-36(fp)
 8201838:	00001006 	br	820187c <FindLastFlashSectorOffset+0xd0>
        {
            if (regions[n].offset > pLastRegion->offset)
 820183c:	e0fffd17 	ldw	r3,-12(fp)
 8201840:	e0bff717 	ldw	r2,-36(fp)
 8201844:	1004913a 	slli	r2,r2,4
 8201848:	1885883a 	add	r2,r3,r2
 820184c:	10800017 	ldw	r2,0(r2)
 8201850:	e0fff517 	ldw	r3,-44(fp)
 8201854:	18c00017 	ldw	r3,0(r3)
 8201858:	1880050e 	bge	r3,r2,8201870 <FindLastFlashSectorOffset+0xc4>
                pLastRegion = &(regions[n]);
 820185c:	e0fffd17 	ldw	r3,-12(fp)
 8201860:	e0bff717 	ldw	r2,-36(fp)
 8201864:	1004913a 	slli	r2,r2,4
 8201868:	1885883a 	add	r2,r3,r2
 820186c:	e0bff515 	stw	r2,-44(fp)

    /* Find the last flash sector. */
    if (!error)
    {
        pLastRegion = &(regions[0]);
        for (n = 1; n < numRegions; n++)
 8201870:	e0bff717 	ldw	r2,-36(fp)
 8201874:	10800044 	addi	r2,r2,1
 8201878:	e0bff715 	stw	r2,-36(fp)
 820187c:	e0bffe17 	ldw	r2,-8(fp)
 8201880:	e0fff717 	ldw	r3,-36(fp)
 8201884:	18bfed16 	blt	r3,r2,820183c <FindLastFlashSectorOffset+0x90>
        {
            if (regions[n].offset > pLastRegion->offset)
                pLastRegion = &(regions[n]);
        }
        lastFlashSectorOffset =   pLastRegion->offset
 8201888:	e0bff517 	ldw	r2,-44(fp)
 820188c:	10c00017 	ldw	r3,0(r2)
                                + pLastRegion->region_size
 8201890:	e0bff517 	ldw	r2,-44(fp)
 8201894:	10800117 	ldw	r2,4(r2)
 8201898:	1887883a 	add	r3,r3,r2
                                - pLastRegion->block_size;
 820189c:	e0bff517 	ldw	r2,-44(fp)
 82018a0:	10800317 	ldw	r2,12(r2)
        for (n = 1; n < numRegions; n++)
        {
            if (regions[n].offset > pLastRegion->offset)
                pLastRegion = &(regions[n]);
        }
        lastFlashSectorOffset =   pLastRegion->offset
 82018a4:	1885c83a 	sub	r2,r3,r2
 82018a8:	e0bff615 	stw	r2,-40(fp)
                                + pLastRegion->region_size
                                - pLastRegion->block_size;
    }

    /* Return results. */
    if (!error)
 82018ac:	e0bff817 	ldw	r2,-32(fp)
 82018b0:	1000031e 	bne	r2,zero,82018c0 <FindLastFlashSectorOffset+0x114>
        *pLastFlashSectorOffset = lastFlashSectorOffset;
 82018b4:	e0fff617 	ldw	r3,-40(fp)
 82018b8:	e0bfff17 	ldw	r2,-4(fp)
 82018bc:	10c00015 	stw	r3,0(r2)

    return (error);
 82018c0:	e0bff817 	ldw	r2,-32(fp)
}
 82018c4:	e037883a 	mov	sp,fp
 82018c8:	dfc00117 	ldw	ra,4(sp)
 82018cc:	df000017 	ldw	fp,0(sp)
 82018d0:	dec00204 	addi	sp,sp,8
 82018d4:	f800283a 	ret

082018d8 <SSSCreateOSDataStructs>:
/*
 * Create our MicroC/OS-II resources. All of the resources beginning with 
 * "SSS" are declared in this file, and created in this function.
 */
void SSSCreateOSDataStructs(void)
{
 82018d8:	defffd04 	addi	sp,sp,-12
 82018dc:	dfc00215 	stw	ra,8(sp)
 82018e0:	df000115 	stw	fp,4(sp)
 82018e4:	df000104 	addi	fp,sp,4
  /*
  * Create the resource for our MicroC/OS-II Queue for sending commands 
  * received on the TCP/IP socket from the SSSSimpleSocketServerTask()
  * to the LEDManagementTask().
  */
  SSSLEDCommandQ = OSQCreate(&SSSLEDCommandQTbl[0], SSS_LED_COMMAND_Q_SIZE);
 82018e8:	01400784 	movi	r5,30
 82018ec:	010209b4 	movhi	r4,2086
 82018f0:	21221704 	addi	r4,r4,-30628
 82018f4:	8218d480 	call	8218d48 <OSQCreate>
 82018f8:	d0a05a15 	stw	r2,-32408(gp)
  if (!SSSLEDCommandQ)
 82018fc:	d0a05a17 	ldw	r2,-32408(gp)
 8201900:	1000041e 	bne	r2,zero,8201914 <SSSCreateOSDataStructs+0x3c>
  {
     alt_uCOSIIErrorHandler(EXPANDED_DIAGNOSIS_CODE, 
 8201904:	01420974 	movhi	r5,2085
 8201908:	29733904 	addi	r5,r5,-13084
 820190c:	01003fc4 	movi	r4,255
 8201910:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  * toggle the lightshow off, and gives up the semaphore to turn the lightshow
  * back on.  The LEDTask does this in response to the CMD_LEDS_LIGHTSHOW
  * command sent from the SSSSimpleSocketServerTask when the user sends the 
  * toggle lightshow command over the TCPIP socket.
  */
  SSSLEDLightshowSem = OSSemCreate(1);
 8201914:	01000044 	movi	r4,1
 8201918:	8219dbc0 	call	8219dbc <OSSemCreate>
 820191c:	d0a05b15 	stw	r2,-32404(gp)
  if (!SSSLEDLightshowSem)
 8201920:	d0a05b17 	ldw	r2,-32404(gp)
 8201924:	1000041e 	bne	r2,zero,8201938 <SSSCreateOSDataStructs+0x60>
  {
     alt_uCOSIIErrorHandler(EXPANDED_DIAGNOSIS_CODE, 
 8201928:	01420974 	movhi	r5,2085
 820192c:	29734204 	addi	r5,r5,-13048
 8201930:	01003fc4 	movi	r4,255
 8201934:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  
 /*
  * Create our MicroC/OS-II LED Event Flag.  Each flag corresponds to one of
  * the LEDs on the Nios Development board, D0 - D7. 
  */   
  SSSLEDEventFlag = OSFlagCreate(0, &error_code);
 8201938:	e17fff04 	addi	r5,fp,-4
 820193c:	0009883a 	mov	r4,zero
 8201940:	82170a80 	call	82170a8 <OSFlagCreate>
 8201944:	d0a05c15 	stw	r2,-32400(gp)
  if (!SSSLEDEventFlag)
 8201948:	d0a05c17 	ldw	r2,-32400(gp)
 820194c:	1000051e 	bne	r2,zero,8201964 <SSSCreateOSDataStructs+0x8c>
  {
     alt_uCOSIIErrorHandler(error_code, 0);
 8201950:	e0bfff03 	ldbu	r2,-4(fp)
 8201954:	10803fcc 	andi	r2,r2,255
 8201958:	000b883a 	mov	r5,zero
 820195c:	1009883a 	mov	r4,r2
 8201960:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  }
}
 8201964:	0001883a 	nop
 8201968:	e037883a 	mov	sp,fp
 820196c:	dfc00117 	ldw	ra,4(sp)
 8201970:	df000017 	ldw	fp,0(sp)
 8201974:	dec00204 	addi	sp,sp,8
 8201978:	f800283a 	ret

0820197c <SSSCreateTasks>:
/* This function creates tasks used in this example which do not use sockets.
 * Tasks which use Interniche sockets must be created with TK_NEWTASK.
 */
 
void SSSCreateTasks(void)
{
 820197c:	defff804 	addi	sp,sp,-32
 8201980:	dfc00715 	stw	ra,28(sp)
 8201984:	df000615 	stw	fp,24(sp)
 8201988:	df000604 	addi	fp,sp,24
   INT8U error_code;
  
   error_code = OSTaskCreateExt(LED7SegLightshowTask,
 820198c:	d8000415 	stw	zero,16(sp)
 8201990:	d8000315 	stw	zero,12(sp)
 8201994:	00820004 	movi	r2,2048
 8201998:	d8800215 	stw	r2,8(sp)
 820199c:	00820974 	movhi	r2,2085
 82019a0:	109a1704 	addi	r2,r2,26716
 82019a4:	d8800115 	stw	r2,4(sp)
 82019a8:	00800484 	movi	r2,18
 82019ac:	d8800015 	stw	r2,0(sp)
 82019b0:	01c00484 	movi	r7,18
 82019b4:	018209b4 	movhi	r6,2086
 82019b8:	31a21604 	addi	r6,r6,-30632
 82019bc:	000b883a 	mov	r5,zero
 82019c0:	01020834 	movhi	r4,2080
 82019c4:	21039f04 	addi	r4,r4,3708
 82019c8:	821ae080 	call	821ae08 <OSTaskCreateExt>
 82019cc:	e0bfff05 	stb	r2,-4(fp)
                             LED7SegLightshowTaskStk,
                             TASK_STACKSIZE,
                             NULL,
                             0);
   
   alt_uCOSIIErrorHandler(error_code, 0);
 82019d0:	e0bfff03 	ldbu	r2,-4(fp)
 82019d4:	000b883a 	mov	r5,zero
 82019d8:	1009883a 	mov	r4,r2
 82019dc:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  
   error_code = OSTaskCreateExt(LEDManagementTask,
 82019e0:	d8000415 	stw	zero,16(sp)
 82019e4:	d8000315 	stw	zero,12(sp)
 82019e8:	00820004 	movi	r2,2048
 82019ec:	d8800215 	stw	r2,8(sp)
 82019f0:	008209b4 	movhi	r2,2086
 82019f4:	10a23504 	addi	r2,r2,-30508
 82019f8:	d8800115 	stw	r2,4(sp)
 82019fc:	008001c4 	movi	r2,7
 8201a00:	d8800015 	stw	r2,0(sp)
 8201a04:	01c001c4 	movi	r7,7
 8201a08:	018209b4 	movhi	r6,2086
 8201a0c:	31aa3404 	addi	r6,r6,-22320
 8201a10:	000b883a 	mov	r5,zero
 8201a14:	01020834 	movhi	r4,2080
 8201a18:	2103bc04 	addi	r4,r4,3824
 8201a1c:	821ae080 	call	821ae08 <OSTaskCreateExt>
 8201a20:	e0bfff05 	stb	r2,-4(fp)
                              LEDManagementTaskStk,
                              TASK_STACKSIZE,
                              NULL,
                              0);

   alt_uCOSIIErrorHandler(error_code, 0);
 8201a24:	e0bfff03 	ldbu	r2,-4(fp)
 8201a28:	000b883a 	mov	r5,zero
 8201a2c:	1009883a 	mov	r4,r2
 8201a30:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>

}
 8201a34:	0001883a 	nop
 8201a38:	e037883a 	mov	sp,fp
 8201a3c:	dfc00117 	ldw	ra,4(sp)
 8201a40:	df000017 	ldw	fp,0(sp)
 8201a44:	dec00204 	addi	sp,sp,8
 8201a48:	f800283a 	ret

08201a4c <sss_reset_connection>:
 * to a reliable initial state. Note that we set our socket (FD) number to
 * -1 to easily determine whether the connection is in a "reset, ready to go" 
 * state.
 */
void sss_reset_connection(SSSConn* conn)
{
 8201a4c:	defffd04 	addi	sp,sp,-12
 8201a50:	dfc00215 	stw	ra,8(sp)
 8201a54:	df000115 	stw	fp,4(sp)
 8201a58:	df000104 	addi	fp,sp,4
 8201a5c:	e13fff15 	stw	r4,-4(fp)
  memset(conn, 0, sizeof(SSSConn));
 8201a60:	01817c04 	movi	r6,1520
 8201a64:	000b883a 	mov	r5,zero
 8201a68:	e13fff17 	ldw	r4,-4(fp)
 8201a6c:	82031b40 	call	82031b4 <memset>

  conn->fd = -1;
 8201a70:	e0bfff17 	ldw	r2,-4(fp)
 8201a74:	00ffffc4 	movi	r3,-1
 8201a78:	10c00115 	stw	r3,4(r2)
  conn->state = READY;
 8201a7c:	e0bfff17 	ldw	r2,-4(fp)
 8201a80:	10000015 	stw	zero,0(r2)
  conn->rx_wr_pos = conn->rx_buffer;
 8201a84:	e0bfff17 	ldw	r2,-4(fp)
 8201a88:	10c00304 	addi	r3,r2,12
 8201a8c:	e0bfff17 	ldw	r2,-4(fp)
 8201a90:	10c17b15 	stw	r3,1516(r2)
  conn->rx_rd_pos = conn->rx_buffer;
 8201a94:	e0bfff17 	ldw	r2,-4(fp)
 8201a98:	10c00304 	addi	r3,r2,12
 8201a9c:	e0bfff17 	ldw	r2,-4(fp)
 8201aa0:	10c17a15 	stw	r3,1512(r2)
  return;
 8201aa4:	0001883a 	nop
}
 8201aa8:	e037883a 	mov	sp,fp
 8201aac:	dfc00117 	ldw	ra,4(sp)
 8201ab0:	df000017 	ldw	fp,0(sp)
 8201ab4:	dec00204 	addi	sp,sp,8
 8201ab8:	f800283a 	ret

08201abc <sss_send_menu>:
 * sss_send_menu()
 * 
 * This routine will transmit the menu out to the telent client.
 */
void sss_send_menu(SSSConn* conn)
{
 8201abc:	defe8504 	addi	sp,sp,-1516
 8201ac0:	dfc17a15 	stw	ra,1512(sp)
 8201ac4:	df017915 	stw	fp,1508(sp)
 8201ac8:	df017904 	addi	fp,sp,1508
 8201acc:	e13fff15 	stw	r4,-4(fp)
  char  tx_buf[SSS_TX_BUF_SIZE];
  char *tx_wr_pos = tx_buf;
 8201ad0:	e0be8804 	addi	r2,fp,-1504
 8201ad4:	e0be8715 	stw	r2,-1508(fp)

  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 8201ad8:	e0fe8717 	ldw	r3,-1508(fp)
 8201adc:	00820974 	movhi	r2,2085
 8201ae0:	10b34c04 	addi	r2,r2,-13008
 8201ae4:	1009883a 	mov	r4,r2
 8201ae8:	00800904 	movi	r2,36
 8201aec:	100d883a 	mov	r6,r2
 8201af0:	200b883a 	mov	r5,r4
 8201af4:	1809883a 	mov	r4,r3
 8201af8:	8202f100 	call	8202f10 <memcpy>
 8201afc:	008008c4 	movi	r2,35
 8201b00:	1007883a 	mov	r3,r2
 8201b04:	e0be8717 	ldw	r2,-1508(fp)
 8201b08:	10c5883a 	add	r2,r2,r3
 8201b0c:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"ADC Socket Server Menu\n\r");
 8201b10:	e0fe8717 	ldw	r3,-1508(fp)
 8201b14:	00820974 	movhi	r2,2085
 8201b18:	10b35504 	addi	r2,r2,-12972
 8201b1c:	1009883a 	mov	r4,r2
 8201b20:	00800644 	movi	r2,25
 8201b24:	100d883a 	mov	r6,r2
 8201b28:	200b883a 	mov	r5,r4
 8201b2c:	1809883a 	mov	r4,r3
 8201b30:	8202f100 	call	8202f10 <memcpy>
 8201b34:	00800604 	movi	r2,24
 8201b38:	1007883a 	mov	r3,r2
 8201b3c:	e0be8717 	ldw	r2,-1508(fp)
 8201b40:	10c5883a 	add	r2,r2,r3
 8201b44:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 8201b48:	e0fe8717 	ldw	r3,-1508(fp)
 8201b4c:	00820974 	movhi	r2,2085
 8201b50:	10b34c04 	addi	r2,r2,-13008
 8201b54:	1009883a 	mov	r4,r2
 8201b58:	00800904 	movi	r2,36
 8201b5c:	100d883a 	mov	r6,r2
 8201b60:	200b883a 	mov	r5,r4
 8201b64:	1809883a 	mov	r4,r3
 8201b68:	8202f100 	call	8202f10 <memcpy>
 8201b6c:	008008c4 	movi	r2,35
 8201b70:	1007883a 	mov	r3,r2
 8201b74:	e0be8717 	ldw	r2,-1508(fp)
 8201b78:	10c5883a 	add	r2,r2,r3
 8201b7c:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"ACQUIRE      - output most recent trigger\n\r");
 8201b80:	e0fe8717 	ldw	r3,-1508(fp)
 8201b84:	00820974 	movhi	r2,2085
 8201b88:	10b35c04 	addi	r2,r2,-12944
 8201b8c:	1009883a 	mov	r4,r2
 8201b90:	00800b04 	movi	r2,44
 8201b94:	100d883a 	mov	r6,r2
 8201b98:	200b883a 	mov	r5,r4
 8201b9c:	1809883a 	mov	r4,r3
 8201ba0:	8202f100 	call	8202f10 <memcpy>
 8201ba4:	00800ac4 	movi	r2,43
 8201ba8:	1007883a 	mov	r3,r2
 8201bac:	e0be8717 	ldw	r2,-1508(fp)
 8201bb0:	10c5883a 	add	r2,r2,r3
 8201bb4:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"TRIG:SLOPE:  - Set trigger slope: POS or NEG\n\r");
 8201bb8:	e0fe8717 	ldw	r3,-1508(fp)
 8201bbc:	00820974 	movhi	r2,2085
 8201bc0:	10b36704 	addi	r2,r2,-12900
 8201bc4:	1009883a 	mov	r4,r2
 8201bc8:	00800bc4 	movi	r2,47
 8201bcc:	100d883a 	mov	r6,r2
 8201bd0:	200b883a 	mov	r5,r4
 8201bd4:	1809883a 	mov	r4,r3
 8201bd8:	8202f100 	call	8202f10 <memcpy>
 8201bdc:	00800b84 	movi	r2,46
 8201be0:	1007883a 	mov	r3,r2
 8201be4:	e0be8717 	ldw	r2,-1508(fp)
 8201be8:	10c5883a 	add	r2,r2,r3
 8201bec:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"TRIG:SOURCE: - Set trigger source: SELF or EXT\n\r");
 8201bf0:	e0fe8717 	ldw	r3,-1508(fp)
 8201bf4:	00820974 	movhi	r2,2085
 8201bf8:	10b37304 	addi	r2,r2,-12852
 8201bfc:	1009883a 	mov	r4,r2
 8201c00:	00800c44 	movi	r2,49
 8201c04:	100d883a 	mov	r6,r2
 8201c08:	200b883a 	mov	r5,r4
 8201c0c:	1809883a 	mov	r4,r3
 8201c10:	8202f100 	call	8202f10 <memcpy>
 8201c14:	00800c04 	movi	r2,48
 8201c18:	1007883a 	mov	r3,r2
 8201c1c:	e0be8717 	ldw	r2,-1508(fp)
 8201c20:	10c5883a 	add	r2,r2,r3
 8201c24:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"DELAY:       - Set delay: ON or OFF\n\r");
 8201c28:	e0fe8717 	ldw	r3,-1508(fp)
 8201c2c:	00820974 	movhi	r2,2085
 8201c30:	10b38004 	addi	r2,r2,-12800
 8201c34:	1009883a 	mov	r4,r2
 8201c38:	00800984 	movi	r2,38
 8201c3c:	100d883a 	mov	r6,r2
 8201c40:	200b883a 	mov	r5,r4
 8201c44:	1809883a 	mov	r4,r3
 8201c48:	8202f100 	call	8202f10 <memcpy>
 8201c4c:	00800944 	movi	r2,37
 8201c50:	1007883a 	mov	r3,r2
 8201c54:	e0be8717 	ldw	r2,-1508(fp)
 8201c58:	10c5883a 	add	r2,r2,r3
 8201c5c:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"QUIT         - quit \n\r");
 8201c60:	e0fe8717 	ldw	r3,-1508(fp)
 8201c64:	00820974 	movhi	r2,2085
 8201c68:	10b38a04 	addi	r2,r2,-12760
 8201c6c:	1009883a 	mov	r4,r2
 8201c70:	008005c4 	movi	r2,23
 8201c74:	100d883a 	mov	r6,r2
 8201c78:	200b883a 	mov	r5,r4
 8201c7c:	1809883a 	mov	r4,r3
 8201c80:	8202f100 	call	8202f10 <memcpy>
 8201c84:	00800584 	movi	r2,22
 8201c88:	1007883a 	mov	r3,r2
 8201c8c:	e0be8717 	ldw	r2,-1508(fp)
 8201c90:	10c5883a 	add	r2,r2,r3
 8201c94:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 8201c98:	e0fe8717 	ldw	r3,-1508(fp)
 8201c9c:	00820974 	movhi	r2,2085
 8201ca0:	10b34c04 	addi	r2,r2,-13008
 8201ca4:	1009883a 	mov	r4,r2
 8201ca8:	00800904 	movi	r2,36
 8201cac:	100d883a 	mov	r6,r2
 8201cb0:	200b883a 	mov	r5,r4
 8201cb4:	1809883a 	mov	r4,r3
 8201cb8:	8202f100 	call	8202f10 <memcpy>
 8201cbc:	008008c4 	movi	r2,35
 8201cc0:	1007883a 	mov	r3,r2
 8201cc4:	e0be8717 	ldw	r2,-1508(fp)
 8201cc8:	10c5883a 	add	r2,r2,r3
 8201ccc:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"Enter your choice & press return:\n\r");
 8201cd0:	e0fe8717 	ldw	r3,-1508(fp)
 8201cd4:	00820974 	movhi	r2,2085
 8201cd8:	10b39004 	addi	r2,r2,-12736
 8201cdc:	1009883a 	mov	r4,r2
 8201ce0:	00800904 	movi	r2,36
 8201ce4:	100d883a 	mov	r6,r2
 8201ce8:	200b883a 	mov	r5,r4
 8201cec:	1809883a 	mov	r4,r3
 8201cf0:	8202f100 	call	8202f10 <memcpy>
 8201cf4:	008008c4 	movi	r2,35
 8201cf8:	1007883a 	mov	r3,r2
 8201cfc:	e0be8717 	ldw	r2,-1508(fp)
 8201d00:	10c5883a 	add	r2,r2,r3
 8201d04:	e0be8715 	stw	r2,-1508(fp)

  send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);
 8201d08:	e0bfff17 	ldw	r2,-4(fp)
 8201d0c:	11000117 	ldw	r4,4(r2)
 8201d10:	e0fe8717 	ldw	r3,-1508(fp)
 8201d14:	e0be8804 	addi	r2,fp,-1504
 8201d18:	1887c83a 	sub	r3,r3,r2
 8201d1c:	e0be8804 	addi	r2,fp,-1504
 8201d20:	000f883a 	mov	r7,zero
 8201d24:	180d883a 	mov	r6,r3
 8201d28:	100b883a 	mov	r5,r2
 8201d2c:	82315700 	call	8231570 <t_send>
  
  return;
 8201d30:	0001883a 	nop
}
 8201d34:	e037883a 	mov	sp,fp
 8201d38:	dfc00117 	ldw	ra,4(sp)
 8201d3c:	df000017 	ldw	fp,0(sp)
 8201d40:	dec00204 	addi	sp,sp,8
 8201d44:	f800283a 	ret

08201d48 <sss_handle_accept>:
 * reject the incoming request by immediately closing the new socket.
 * 
 * We'll also print out the client's IP address.
 */
void sss_handle_accept(int listen_socket, SSSConn* conn)
{
 8201d48:	defff604 	addi	sp,sp,-40
 8201d4c:	dfc00915 	stw	ra,36(sp)
 8201d50:	df000815 	stw	fp,32(sp)
 8201d54:	df000804 	addi	fp,sp,32
 8201d58:	e13ffe15 	stw	r4,-8(fp)
 8201d5c:	e17fff15 	stw	r5,-4(fp)
  int                 socket, len;
  struct sockaddr_in  incoming_addr;

  len = sizeof(incoming_addr);
 8201d60:	00800404 	movi	r2,16
 8201d64:	e0bff915 	stw	r2,-28(fp)

  if ((conn)->fd == -1)
 8201d68:	e0bfff17 	ldw	r2,-4(fp)
 8201d6c:	10800117 	ldw	r2,4(r2)
 8201d70:	10bfffd8 	cmpnei	r2,r2,-1
 8201d74:	10001a1e 	bne	r2,zero,8201de0 <sss_handle_accept+0x98>
  {
     if((socket=accept(listen_socket,(struct sockaddr*)&incoming_addr,&len))<0)
 8201d78:	e0fff904 	addi	r3,fp,-28
 8201d7c:	e0bffa04 	addi	r2,fp,-24
 8201d80:	180d883a 	mov	r6,r3
 8201d84:	100b883a 	mov	r5,r2
 8201d88:	e13ffe17 	ldw	r4,-8(fp)
 8201d8c:	8227c880 	call	8227c88 <bsd_accept>
 8201d90:	e0bff815 	stw	r2,-32(fp)
 8201d94:	e0bff817 	ldw	r2,-32(fp)
 8201d98:	1000050e 	bge	r2,zero,8201db0 <sss_handle_accept+0x68>
     {
         alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,
 8201d9c:	01420974 	movhi	r5,2085
 8201da0:	29739904 	addi	r5,r5,-12700
 8201da4:	01003fc4 	movi	r4,255
 8201da8:	82007ac0 	call	82007ac <alt_NetworkErrorHandler>
  {
    printf("[sss_handle_accept] rejected connection request from %s\n",
           inet_ntoa(incoming_addr.sin_addr));
  }

  return;
 8201dac:	00001306 	br	8201dfc <sss_handle_accept+0xb4>
         alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,
                                 "[sss_handle_accept] accept failed");
     }
     else
     {
        (conn)->fd = socket;
 8201db0:	e0bfff17 	ldw	r2,-4(fp)
 8201db4:	e0fff817 	ldw	r3,-32(fp)
 8201db8:	10c00115 	stw	r3,4(r2)
        sss_send_menu(conn);
 8201dbc:	e13fff17 	ldw	r4,-4(fp)
 8201dc0:	8201abc0 	call	8201abc <sss_send_menu>
        printf("[sss_handle_accept] accepted connection request from %s\n",
 8201dc4:	e13ffb17 	ldw	r4,-20(fp)
 8201dc8:	82283300 	call	8228330 <bsd_inet_ntoa>
 8201dcc:	100b883a 	mov	r5,r2
 8201dd0:	01020974 	movhi	r4,2085
 8201dd4:	2133a204 	addi	r4,r4,-12664
 8201dd8:	82033a00 	call	82033a0 <printf>
  {
    printf("[sss_handle_accept] rejected connection request from %s\n",
           inet_ntoa(incoming_addr.sin_addr));
  }

  return;
 8201ddc:	00000706 	br	8201dfc <sss_handle_accept+0xb4>
               inet_ntoa(incoming_addr.sin_addr));
     }
  }
  else
  {
    printf("[sss_handle_accept] rejected connection request from %s\n",
 8201de0:	e13ffb17 	ldw	r4,-20(fp)
 8201de4:	82283300 	call	8228330 <bsd_inet_ntoa>
 8201de8:	100b883a 	mov	r5,r2
 8201dec:	01020974 	movhi	r4,2085
 8201df0:	2133b104 	addi	r4,r4,-12604
 8201df4:	82033a00 	call	82033a0 <printf>
           inet_ntoa(incoming_addr.sin_addr));
  }

  return;
 8201df8:	0001883a 	nop
}
 8201dfc:	e037883a 	mov	sp,fp
 8201e00:	dfc00117 	ldw	ra,4(sp)
 8201e04:	df000017 	ldw	fp,0(sp)
 8201e08:	dec00204 	addi	sp,sp,8
 8201e0c:	f800283a 	ret

08201e10 <sss_exec_command>:
 * If the user wishes to quit, we set the "close" member of our SSSConn
 * struct, which will be looked at back in sss_handle_receive() when it 
 * comes time to see whether to close the connection or not.
 */
void sss_exec_command(SSSConn* conn)
{
 8201e10:	defb9104 	addi	sp,sp,-4540
 8201e14:	dfc46e15 	stw	ra,4536(sp)
 8201e18:	df046d15 	stw	fp,4532(sp)
 8201e1c:	df046d04 	addi	fp,sp,4532
 8201e20:	e13fff15 	stw	r4,-4(fp)
   int bytes_to_process = conn->rx_wr_pos - conn->rx_rd_pos;
 8201e24:	e0bfff17 	ldw	r2,-4(fp)
 8201e28:	10817b17 	ldw	r2,1516(r2)
 8201e2c:	1007883a 	mov	r3,r2
 8201e30:	e0bfff17 	ldw	r2,-4(fp)
 8201e34:	10817a17 	ldw	r2,1512(r2)
 8201e38:	1885c83a 	sub	r2,r3,r2
 8201e3c:	e0bb9315 	stw	r2,-4532(fp)

   char  tx_buf[SSS_TX_BUF_SIZE];
   char *tx_wr_pos = tx_buf;
 8201e40:	e0bb9a04 	addi	r2,fp,-4504
 8201e44:	e0bb9415 	stw	r2,-4528(fp)

   char text_buf[SSS_TX_BUF_SIZE];
   char *text = text_buf;
 8201e48:	e0bd1104 	addi	r2,fp,-3004
 8201e4c:	e0bb9515 	stw	r2,-4524(fp)
    * SSSSimpleSocketServerTask, since the LEDManagementTask does not 
    * have access to the stack of the SSSSimpleSocketServerTask.
    */
   static INT32U SSSCommand;
   
   SSSCommand = CMD_LEDS_BIT_0_TOGGLE;
 8201e50:	00800c04 	movi	r2,48
 8201e54:	d0a05915 	stw	r2,-32412(gp)

   while(bytes_to_process--) {
 8201e58:	00002206 	br	8201ee4 <sss_exec_command+0xd4>
      SSSCommand = tolower(*(conn->rx_rd_pos++));
 8201e5c:	e0bfff17 	ldw	r2,-4(fp)
 8201e60:	10817a17 	ldw	r2,1512(r2)
 8201e64:	11000044 	addi	r4,r2,1
 8201e68:	e0ffff17 	ldw	r3,-4(fp)
 8201e6c:	19017a15 	stw	r4,1512(r3)
 8201e70:	10800003 	ldbu	r2,0(r2)
 8201e74:	e0bb9885 	stb	r2,-4510(fp)
 8201e78:	d0e00017 	ldw	r3,-32768(gp)
 8201e7c:	e0bb9883 	ldbu	r2,-4510(fp)
 8201e80:	10800044 	addi	r2,r2,1
 8201e84:	1885883a 	add	r2,r3,r2
 8201e88:	10800003 	ldbu	r2,0(r2)
 8201e8c:	10803fcc 	andi	r2,r2,255
 8201e90:	108000cc 	andi	r2,r2,3
 8201e94:	10800058 	cmpnei	r2,r2,1
 8201e98:	1000031e 	bne	r2,zero,8201ea8 <sss_exec_command+0x98>
 8201e9c:	e0bb9883 	ldbu	r2,-4510(fp)
 8201ea0:	10800804 	addi	r2,r2,32
 8201ea4:	00000106 	br	8201eac <sss_exec_command+0x9c>
 8201ea8:	e0bb9883 	ldbu	r2,-4510(fp)
 8201eac:	d0a05915 	stw	r2,-32412(gp)
	  text += sprintf(text,"%c",(char)SSSCommand);
 8201eb0:	d0a05917 	ldw	r2,-32412(gp)
 8201eb4:	10803fcc 	andi	r2,r2,255
 8201eb8:	1080201c 	xori	r2,r2,128
 8201ebc:	10bfe004 	addi	r2,r2,-128
 8201ec0:	100d883a 	mov	r6,r2
 8201ec4:	01420974 	movhi	r5,2085
 8201ec8:	2973c004 	addi	r5,r5,-12544
 8201ecc:	e13b9517 	ldw	r4,-4524(fp)
 8201ed0:	82037180 	call	8203718 <sprintf>
 8201ed4:	1007883a 	mov	r3,r2
 8201ed8:	e0bb9517 	ldw	r2,-4524(fp)
 8201edc:	10c5883a 	add	r2,r2,r3
 8201ee0:	e0bb9515 	stw	r2,-4524(fp)
    */
   static INT32U SSSCommand;
   
   SSSCommand = CMD_LEDS_BIT_0_TOGGLE;

   while(bytes_to_process--) {
 8201ee4:	e0bb9317 	ldw	r2,-4532(fp)
 8201ee8:	10ffffc4 	addi	r3,r2,-1
 8201eec:	e0fb9315 	stw	r3,-4532(fp)
 8201ef0:	103fda1e 	bne	r2,zero,8201e5c <sss_exec_command+0x4c>
      SSSCommand = tolower(*(conn->rx_rd_pos++));
	  text += sprintf(text,"%c",(char)SSSCommand);
   }

   alt_u8 startValue = IORD_ALTERA_AVALON_PIO_DATA(ADC_CONTROL_BASE);
 8201ef4:	00824034 	movhi	r2,2304
 8201ef8:	10801004 	addi	r2,r2,64
 8201efc:	10800037 	ldwio	r2,0(r2)
 8201f00:	e0bb98c5 	stb	r2,-4509(fp)

   alt_u8 endValue = startValue;
 8201f04:	e0bb98c3 	ldbu	r2,-4509(fp)
 8201f08:	e0bb9605 	stb	r2,-4520(fp)

   if(strstr(text_buf, "acquire") != NULL){
 8201f0c:	e0bd1104 	addi	r2,fp,-3004
 8201f10:	01420974 	movhi	r5,2085
 8201f14:	2973c104 	addi	r5,r5,-12540
 8201f18:	1009883a 	mov	r4,r2
 8201f1c:	82044ac0 	call	82044ac <strstr>
 8201f20:	10006b26 	beq	r2,zero,82020d0 <sss_exec_command+0x2c0>
	   endValue ^= (-1 ^ endValue) & (1 << 0);
 8201f24:	e0bb9603 	ldbu	r2,-4520(fp)
 8201f28:	1080004c 	andi	r2,r2,1
 8201f2c:	1005003a 	cmpeq	r2,r2,zero
 8201f30:	1007883a 	mov	r3,r2
 8201f34:	e0bb9603 	ldbu	r2,-4520(fp)
 8201f38:	1884f03a 	xor	r2,r3,r2
 8201f3c:	e0bb9605 	stb	r2,-4520(fp)


	   IOWR_ALTERA_AVALON_PIO_DATA(ADC_CONTROL_BASE, endValue);
 8201f40:	e0fb9603 	ldbu	r3,-4520(fp)
 8201f44:	00824034 	movhi	r2,2304
 8201f48:	10801004 	addi	r2,r2,64
 8201f4c:	10c00035 	stwio	r3,0(r2)


	   char  tx_buf_data[SSS_TX_BUF_SIZE];
	   char *tx_wr_pos_data = tx_buf_data;
 8201f50:	e0be8804 	addi	r2,fp,-1504
 8201f54:	e0bb9715 	stw	r2,-4516(fp)

	   //loop over the waveform
	   for(alt_u16 i=1; i<=1000; i++){
 8201f58:	00800044 	movi	r2,1
 8201f5c:	e0bb980d 	sth	r2,-4512(fp)
 8201f60:	00002c06 	br	8202014 <sss_exec_command+0x204>

		   //request the ith sample of the waveform
		   IOWR_ALTERA_AVALON_PIO_DATA(SAMPLENUM_BASE, i);
 8201f64:	e0fb980b 	ldhu	r3,-4512(fp)
 8201f68:	00824034 	movhi	r2,2304
 8201f6c:	10801804 	addi	r2,r2,96
 8201f70:	10c00035 	stwio	r3,0(r2)

		   //usleep(10);

		   alt_u16 sample = IORD_ALTERA_AVALON_PIO_DATA(WAVESAMPLE_BASE);
 8201f74:	00824034 	movhi	r2,2304
 8201f78:	10801404 	addi	r2,r2,80
 8201f7c:	10800037 	ldwio	r2,0(r2)
 8201f80:	e0bb990d 	sth	r2,-4508(fp)

		   //printf("%d\t", i);
		   //printf("%d\n", sample);

		   tx_wr_pos_data += sprintf(tx_wr_pos_data, "%d\n", sample);
 8201f84:	e0bb990b 	ldhu	r2,-4508(fp)
 8201f88:	100d883a 	mov	r6,r2
 8201f8c:	01420974 	movhi	r5,2085
 8201f90:	2973c304 	addi	r5,r5,-12532
 8201f94:	e13b9717 	ldw	r4,-4516(fp)
 8201f98:	82037180 	call	8203718 <sprintf>
 8201f9c:	1007883a 	mov	r3,r2
 8201fa0:	e0bb9717 	ldw	r2,-4516(fp)
 8201fa4:	10c5883a 	add	r2,r2,r3
 8201fa8:	e0bb9715 	stw	r2,-4516(fp)

		   //send data every 100 samples.
		   if(i%100==0){
 8201fac:	e0bb980b 	ldhu	r2,-4512(fp)
 8201fb0:	01401904 	movi	r5,100
 8201fb4:	1009883a 	mov	r4,r2
 8201fb8:	8202c740 	call	8202c74 <__umodsi3>
 8201fbc:	10bfffcc 	andi	r2,r2,65535
 8201fc0:	1000111e 	bne	r2,zero,8202008 <sss_exec_command+0x1f8>
			   send(conn->fd, tx_buf_data, tx_wr_pos_data - tx_buf_data, 0);
 8201fc4:	e0bfff17 	ldw	r2,-4(fp)
 8201fc8:	11000117 	ldw	r4,4(r2)
 8201fcc:	e0fb9717 	ldw	r3,-4516(fp)
 8201fd0:	e0be8804 	addi	r2,fp,-1504
 8201fd4:	1887c83a 	sub	r3,r3,r2
 8201fd8:	e0be8804 	addi	r2,fp,-1504
 8201fdc:	000f883a 	mov	r7,zero
 8201fe0:	180d883a 	mov	r6,r3
 8201fe4:	100b883a 	mov	r5,r2
 8201fe8:	82315700 	call	8231570 <t_send>

			   memset(tx_buf_data, 0, sizeof tx_buf_data);
 8201fec:	e0be8804 	addi	r2,fp,-1504
 8201ff0:	01817704 	movi	r6,1500
 8201ff4:	000b883a 	mov	r5,zero
 8201ff8:	1009883a 	mov	r4,r2
 8201ffc:	82031b40 	call	82031b4 <memset>
			   tx_wr_pos_data = tx_buf_data;
 8202000:	e0be8804 	addi	r2,fp,-1504
 8202004:	e0bb9715 	stw	r2,-4516(fp)

	   char  tx_buf_data[SSS_TX_BUF_SIZE];
	   char *tx_wr_pos_data = tx_buf_data;

	   //loop over the waveform
	   for(alt_u16 i=1; i<=1000; i++){
 8202008:	e0bb980b 	ldhu	r2,-4512(fp)
 820200c:	10800044 	addi	r2,r2,1
 8202010:	e0bb980d 	sth	r2,-4512(fp)
 8202014:	e0bb980b 	ldhu	r2,-4512(fp)
 8202018:	1080fa70 	cmpltui	r2,r2,1001
 820201c:	103fd11e 	bne	r2,zero,8201f64 <sss_exec_command+0x154>
			   tx_wr_pos_data = tx_buf_data;

		   }

	   }
	   IOWR_ALTERA_AVALON_PIO_DATA(SAMPLENUM_BASE, 1001);
 8202020:	00c0fa44 	movi	r3,1001
 8202024:	00824034 	movhi	r2,2304
 8202028:	10801804 	addi	r2,r2,96
 820202c:	10c00035 	stwio	r3,0(r2)
	   //usleep(10);
	   alt_u16 waveNum = IORD_ALTERA_AVALON_PIO_DATA(WAVESAMPLE_BASE);
 8202030:	00824034 	movhi	r2,2304
 8202034:	10801404 	addi	r2,r2,80
 8202038:	10800037 	ldwio	r2,0(r2)
 820203c:	e0bb998d 	sth	r2,-4506(fp)
	   //printf("%d\n", waveNum);


	   IOWR_ALTERA_AVALON_PIO_DATA(SAMPLENUM_BASE, 0);
 8202040:	0007883a 	mov	r3,zero
 8202044:	00824034 	movhi	r2,2304
 8202048:	10801804 	addi	r2,r2,96
 820204c:	10c00035 	stwio	r3,0(r2)

	   memset(tx_buf_data, 0, sizeof tx_buf_data);
 8202050:	e0be8804 	addi	r2,fp,-1504
 8202054:	01817704 	movi	r6,1500
 8202058:	000b883a 	mov	r5,zero
 820205c:	1009883a 	mov	r4,r2
 8202060:	82031b40 	call	82031b4 <memset>
	   tx_wr_pos_data = tx_buf_data;
 8202064:	e0be8804 	addi	r2,fp,-1504
 8202068:	e0bb9715 	stw	r2,-4516(fp)

	   tx_wr_pos_data += sprintf(tx_wr_pos_data, "%d\ncomplete\n",waveNum);
 820206c:	e0bb998b 	ldhu	r2,-4506(fp)
 8202070:	100d883a 	mov	r6,r2
 8202074:	01420974 	movhi	r5,2085
 8202078:	2973c404 	addi	r5,r5,-12528
 820207c:	e13b9717 	ldw	r4,-4516(fp)
 8202080:	82037180 	call	8203718 <sprintf>
 8202084:	1007883a 	mov	r3,r2
 8202088:	e0bb9717 	ldw	r2,-4516(fp)
 820208c:	10c5883a 	add	r2,r2,r3
 8202090:	e0bb9715 	stw	r2,-4516(fp)

	   send(conn->fd, tx_buf_data, tx_wr_pos_data - tx_buf_data, 0);
 8202094:	e0bfff17 	ldw	r2,-4(fp)
 8202098:	11000117 	ldw	r4,4(r2)
 820209c:	e0fb9717 	ldw	r3,-4516(fp)
 82020a0:	e0be8804 	addi	r2,fp,-1504
 82020a4:	1887c83a 	sub	r3,r3,r2
 82020a8:	e0be8804 	addi	r2,fp,-1504
 82020ac:	000f883a 	mov	r7,zero
 82020b0:	180d883a 	mov	r6,r3
 82020b4:	100b883a 	mov	r5,r2
 82020b8:	82315700 	call	8231570 <t_send>

	   //reset the control pio

	   endValue ^= (-0 ^ endValue) & (1 << 0);
 82020bc:	e0fb9603 	ldbu	r3,-4520(fp)
 82020c0:	00bfff84 	movi	r2,-2
 82020c4:	1884703a 	and	r2,r3,r2
 82020c8:	e0bb9605 	stb	r2,-4520(fp)
 82020cc:	00019506 	br	8202724 <sss_exec_command+0x914>
   } else if( strstr(text_buf, "delay")) {
 82020d0:	e0bd1104 	addi	r2,fp,-3004
 82020d4:	01420974 	movhi	r5,2085
 82020d8:	2973c804 	addi	r5,r5,-12512
 82020dc:	1009883a 	mov	r4,r2
 82020e0:	82044ac0 	call	82044ac <strstr>
 82020e4:	10003526 	beq	r2,zero,82021bc <sss_exec_command+0x3ac>
	   if ( strstr(text_buf, ":on")){
 82020e8:	e0bd1104 	addi	r2,fp,-3004
 82020ec:	01420974 	movhi	r5,2085
 82020f0:	2973ca04 	addi	r5,r5,-12504
 82020f4:	1009883a 	mov	r4,r2
 82020f8:	82044ac0 	call	82044ac <strstr>
 82020fc:	10001626 	beq	r2,zero,8202158 <sss_exec_command+0x348>
		   tx_wr_pos += sprintf(tx_wr_pos, "Enabling delay\n");
 8202100:	e0fb9417 	ldw	r3,-4528(fp)
 8202104:	00820974 	movhi	r2,2085
 8202108:	10b3cb04 	addi	r2,r2,-12500
 820210c:	1009883a 	mov	r4,r2
 8202110:	00800404 	movi	r2,16
 8202114:	100d883a 	mov	r6,r2
 8202118:	200b883a 	mov	r5,r4
 820211c:	1809883a 	mov	r4,r3
 8202120:	8202f100 	call	8202f10 <memcpy>
 8202124:	008003c4 	movi	r2,15
 8202128:	1007883a 	mov	r3,r2
 820212c:	e0bb9417 	ldw	r2,-4528(fp)
 8202130:	10c5883a 	add	r2,r2,r3
 8202134:	e0bb9415 	stw	r2,-4528(fp)
		   endValue ^= (-1 ^ endValue) & (1 << 3);
 8202138:	e0bb9603 	ldbu	r2,-4520(fp)
 820213c:	0084303a 	nor	r2,zero,r2
 8202140:	1080020c 	andi	r2,r2,8
 8202144:	1007883a 	mov	r3,r2
 8202148:	e0bb9603 	ldbu	r2,-4520(fp)
 820214c:	1884f03a 	xor	r2,r3,r2
 8202150:	e0bb9605 	stb	r2,-4520(fp)
 8202154:	00017306 	br	8202724 <sss_exec_command+0x914>

	   } else if ( strstr(text_buf, ":off")){
 8202158:	e0bd1104 	addi	r2,fp,-3004
 820215c:	01420974 	movhi	r5,2085
 8202160:	2973cf04 	addi	r5,r5,-12484
 8202164:	1009883a 	mov	r4,r2
 8202168:	82044ac0 	call	82044ac <strstr>
 820216c:	10016d26 	beq	r2,zero,8202724 <sss_exec_command+0x914>
		   tx_wr_pos += sprintf(tx_wr_pos, "Disabling delay\n");
 8202170:	e0fb9417 	ldw	r3,-4528(fp)
 8202174:	00820974 	movhi	r2,2085
 8202178:	10b3d104 	addi	r2,r2,-12476
 820217c:	1009883a 	mov	r4,r2
 8202180:	00800444 	movi	r2,17
 8202184:	100d883a 	mov	r6,r2
 8202188:	200b883a 	mov	r5,r4
 820218c:	1809883a 	mov	r4,r3
 8202190:	8202f100 	call	8202f10 <memcpy>
 8202194:	00800404 	movi	r2,16
 8202198:	1007883a 	mov	r3,r2
 820219c:	e0bb9417 	ldw	r2,-4528(fp)
 82021a0:	10c5883a 	add	r2,r2,r3
 82021a4:	e0bb9415 	stw	r2,-4528(fp)
		   endValue ^= (-0 ^ endValue) & (1 << 3);
 82021a8:	e0fb9603 	ldbu	r3,-4520(fp)
 82021ac:	00bffdc4 	movi	r2,-9
 82021b0:	1884703a 	and	r2,r3,r2
 82021b4:	e0bb9605 	stb	r2,-4520(fp)
 82021b8:	00015a06 	br	8202724 <sss_exec_command+0x914>
	   }
   } else if( strstr(text_buf, "trig")) {
 82021bc:	e0bd1104 	addi	r2,fp,-3004
 82021c0:	01420974 	movhi	r5,2085
 82021c4:	2973d604 	addi	r5,r5,-12456
 82021c8:	1009883a 	mov	r4,r2
 82021cc:	82044ac0 	call	82044ac <strstr>
 82021d0:	10008926 	beq	r2,zero,82023f8 <sss_exec_command+0x5e8>
	   if( strstr(text_buf, ":source")) {
 82021d4:	e0bd1104 	addi	r2,fp,-3004
 82021d8:	01420974 	movhi	r5,2085
 82021dc:	2973d804 	addi	r5,r5,-12448
 82021e0:	1009883a 	mov	r4,r2
 82021e4:	82044ac0 	call	82044ac <strstr>
 82021e8:	10004826 	beq	r2,zero,820230c <sss_exec_command+0x4fc>
	   	   if ( strstr(text_buf, ":self")){
 82021ec:	e0bd1104 	addi	r2,fp,-3004
 82021f0:	01420974 	movhi	r5,2085
 82021f4:	2973da04 	addi	r5,r5,-12440
 82021f8:	1009883a 	mov	r4,r2
 82021fc:	82044ac0 	call	82044ac <strstr>
 8202200:	10002926 	beq	r2,zero,82022a8 <sss_exec_command+0x498>
			   tx_wr_pos += sprintf(tx_wr_pos, "Self trigger\n");
 8202204:	e0bb9417 	ldw	r2,-4528(fp)
 8202208:	00c014c4 	movi	r3,83
 820220c:	10c00005 	stb	r3,0(r2)
 8202210:	00c01944 	movi	r3,101
 8202214:	10c00045 	stb	r3,1(r2)
 8202218:	00c01b04 	movi	r3,108
 820221c:	10c00085 	stb	r3,2(r2)
 8202220:	00c01984 	movi	r3,102
 8202224:	10c000c5 	stb	r3,3(r2)
 8202228:	00c00804 	movi	r3,32
 820222c:	10c00105 	stb	r3,4(r2)
 8202230:	00c01d04 	movi	r3,116
 8202234:	10c00145 	stb	r3,5(r2)
 8202238:	00c01c84 	movi	r3,114
 820223c:	10c00185 	stb	r3,6(r2)
 8202240:	00c01a44 	movi	r3,105
 8202244:	10c001c5 	stb	r3,7(r2)
 8202248:	00c019c4 	movi	r3,103
 820224c:	10c00205 	stb	r3,8(r2)
 8202250:	00c019c4 	movi	r3,103
 8202254:	10c00245 	stb	r3,9(r2)
 8202258:	00c01944 	movi	r3,101
 820225c:	10c00285 	stb	r3,10(r2)
 8202260:	00c01c84 	movi	r3,114
 8202264:	10c002c5 	stb	r3,11(r2)
 8202268:	00c00284 	movi	r3,10
 820226c:	10c00305 	stb	r3,12(r2)
 8202270:	10000345 	stb	zero,13(r2)
 8202274:	00800344 	movi	r2,13
 8202278:	1007883a 	mov	r3,r2
 820227c:	e0bb9417 	ldw	r2,-4528(fp)
 8202280:	10c5883a 	add	r2,r2,r3
 8202284:	e0bb9415 	stw	r2,-4528(fp)
	   		   endValue ^= (-1 ^ endValue) & (1 << 1);
 8202288:	e0bb9603 	ldbu	r2,-4520(fp)
 820228c:	0084303a 	nor	r2,zero,r2
 8202290:	1080008c 	andi	r2,r2,2
 8202294:	1007883a 	mov	r3,r2
 8202298:	e0bb9603 	ldbu	r2,-4520(fp)
 820229c:	1884f03a 	xor	r2,r3,r2
 82022a0:	e0bb9605 	stb	r2,-4520(fp)
 82022a4:	00011f06 	br	8202724 <sss_exec_command+0x914>

	   	   } else if ( strstr(text_buf, ":ext")){
 82022a8:	e0bd1104 	addi	r2,fp,-3004
 82022ac:	01420974 	movhi	r5,2085
 82022b0:	2973dc04 	addi	r5,r5,-12432
 82022b4:	1009883a 	mov	r4,r2
 82022b8:	82044ac0 	call	82044ac <strstr>
 82022bc:	10011926 	beq	r2,zero,8202724 <sss_exec_command+0x914>
			   tx_wr_pos += sprintf(tx_wr_pos, "External trigger\n");
 82022c0:	e0fb9417 	ldw	r3,-4528(fp)
 82022c4:	00820974 	movhi	r2,2085
 82022c8:	10b3de04 	addi	r2,r2,-12424
 82022cc:	1009883a 	mov	r4,r2
 82022d0:	00800484 	movi	r2,18
 82022d4:	100d883a 	mov	r6,r2
 82022d8:	200b883a 	mov	r5,r4
 82022dc:	1809883a 	mov	r4,r3
 82022e0:	8202f100 	call	8202f10 <memcpy>
 82022e4:	00800444 	movi	r2,17
 82022e8:	1007883a 	mov	r3,r2
 82022ec:	e0bb9417 	ldw	r2,-4528(fp)
 82022f0:	10c5883a 	add	r2,r2,r3
 82022f4:	e0bb9415 	stw	r2,-4528(fp)
	   		   endValue ^= (-0 ^ endValue) & (1 << 1);
 82022f8:	e0fb9603 	ldbu	r3,-4520(fp)
 82022fc:	00bfff44 	movi	r2,-3
 8202300:	1884703a 	and	r2,r3,r2
 8202304:	e0bb9605 	stb	r2,-4520(fp)
 8202308:	00010606 	br	8202724 <sss_exec_command+0x914>
	   	   }
	   } else if( strstr(text_buf, ":slope")) {
 820230c:	e0bd1104 	addi	r2,fp,-3004
 8202310:	01420974 	movhi	r5,2085
 8202314:	2973e304 	addi	r5,r5,-12404
 8202318:	1009883a 	mov	r4,r2
 820231c:	82044ac0 	call	82044ac <strstr>
 8202320:	10010026 	beq	r2,zero,8202724 <sss_exec_command+0x914>
		   if ( strstr(text_buf, ":pos")){
 8202324:	e0bd1104 	addi	r2,fp,-3004
 8202328:	01420974 	movhi	r5,2085
 820232c:	2973e504 	addi	r5,r5,-12396
 8202330:	1009883a 	mov	r4,r2
 8202334:	82044ac0 	call	82044ac <strstr>
 8202338:	10001626 	beq	r2,zero,8202394 <sss_exec_command+0x584>
			   tx_wr_pos += sprintf(tx_wr_pos, "Positive trigger\n");
 820233c:	e0fb9417 	ldw	r3,-4528(fp)
 8202340:	00820974 	movhi	r2,2085
 8202344:	10b3e704 	addi	r2,r2,-12388
 8202348:	1009883a 	mov	r4,r2
 820234c:	00800484 	movi	r2,18
 8202350:	100d883a 	mov	r6,r2
 8202354:	200b883a 	mov	r5,r4
 8202358:	1809883a 	mov	r4,r3
 820235c:	8202f100 	call	8202f10 <memcpy>
 8202360:	00800444 	movi	r2,17
 8202364:	1007883a 	mov	r3,r2
 8202368:	e0bb9417 	ldw	r2,-4528(fp)
 820236c:	10c5883a 	add	r2,r2,r3
 8202370:	e0bb9415 	stw	r2,-4528(fp)
			   endValue ^= (-1 ^ endValue) & (1 << 2);
 8202374:	e0bb9603 	ldbu	r2,-4520(fp)
 8202378:	0084303a 	nor	r2,zero,r2
 820237c:	1080010c 	andi	r2,r2,4
 8202380:	1007883a 	mov	r3,r2
 8202384:	e0bb9603 	ldbu	r2,-4520(fp)
 8202388:	1884f03a 	xor	r2,r3,r2
 820238c:	e0bb9605 	stb	r2,-4520(fp)
 8202390:	0000e406 	br	8202724 <sss_exec_command+0x914>

		   } else if ( strstr(text_buf, ":neg")){
 8202394:	e0bd1104 	addi	r2,fp,-3004
 8202398:	01420974 	movhi	r5,2085
 820239c:	2973ec04 	addi	r5,r5,-12368
 82023a0:	1009883a 	mov	r4,r2
 82023a4:	82044ac0 	call	82044ac <strstr>
 82023a8:	1000de26 	beq	r2,zero,8202724 <sss_exec_command+0x914>
			   tx_wr_pos += sprintf(tx_wr_pos, "negative trigger\n");
 82023ac:	e0fb9417 	ldw	r3,-4528(fp)
 82023b0:	00820974 	movhi	r2,2085
 82023b4:	10b3ee04 	addi	r2,r2,-12360
 82023b8:	1009883a 	mov	r4,r2
 82023bc:	00800484 	movi	r2,18
 82023c0:	100d883a 	mov	r6,r2
 82023c4:	200b883a 	mov	r5,r4
 82023c8:	1809883a 	mov	r4,r3
 82023cc:	8202f100 	call	8202f10 <memcpy>
 82023d0:	00800444 	movi	r2,17
 82023d4:	1007883a 	mov	r3,r2
 82023d8:	e0bb9417 	ldw	r2,-4528(fp)
 82023dc:	10c5883a 	add	r2,r2,r3
 82023e0:	e0bb9415 	stw	r2,-4528(fp)
			   endValue ^= (-0 ^ endValue) & (1 << 2);
 82023e4:	e0fb9603 	ldbu	r3,-4520(fp)
 82023e8:	00bffec4 	movi	r2,-5
 82023ec:	1884703a 	and	r2,r3,r2
 82023f0:	e0bb9605 	stb	r2,-4520(fp)
 82023f4:	0000cb06 	br	8202724 <sss_exec_command+0x914>
		   }
	   }
   } else if ( strstr(text_buf, "quit") != NULL){
 82023f8:	e0bd1104 	addi	r2,fp,-3004
 82023fc:	01420974 	movhi	r5,2085
 8202400:	2973f304 	addi	r5,r5,-12340
 8202404:	1009883a 	mov	r4,r2
 8202408:	82044ac0 	call	82044ac <strstr>
 820240c:	10001226 	beq	r2,zero,8202458 <sss_exec_command+0x648>
	   tx_wr_pos += sprintf(tx_wr_pos,"Terminating connection.\n\n\r");
 8202410:	e0fb9417 	ldw	r3,-4528(fp)
 8202414:	00820974 	movhi	r2,2085
 8202418:	10b3f504 	addi	r2,r2,-12332
 820241c:	1009883a 	mov	r4,r2
 8202420:	008006c4 	movi	r2,27
 8202424:	100d883a 	mov	r6,r2
 8202428:	200b883a 	mov	r5,r4
 820242c:	1809883a 	mov	r4,r3
 8202430:	8202f100 	call	8202f10 <memcpy>
 8202434:	00800684 	movi	r2,26
 8202438:	1007883a 	mov	r3,r2
 820243c:	e0bb9417 	ldw	r2,-4528(fp)
 8202440:	10c5883a 	add	r2,r2,r3
 8202444:	e0bb9415 	stw	r2,-4528(fp)
	   conn->close = 1;
 8202448:	e0bfff17 	ldw	r2,-4(fp)
 820244c:	00c00044 	movi	r3,1
 8202450:	10c00215 	stw	r3,8(r2)
 8202454:	0000b306 	br	8202724 <sss_exec_command+0x914>
   } else if ( strstr(text_buf, "*rst") != NULL){
 8202458:	e0bd1104 	addi	r2,fp,-3004
 820245c:	01420974 	movhi	r5,2085
 8202460:	2973fc04 	addi	r5,r5,-12304
 8202464:	1009883a 	mov	r4,r2
 8202468:	82044ac0 	call	82044ac <strstr>
 820246c:	10001d26 	beq	r2,zero,82024e4 <sss_exec_command+0x6d4>
	   tx_wr_pos += sprintf(tx_wr_pos, "Resetting\n");
 8202470:	e0bb9417 	ldw	r2,-4528(fp)
 8202474:	00c01484 	movi	r3,82
 8202478:	10c00005 	stb	r3,0(r2)
 820247c:	00c01944 	movi	r3,101
 8202480:	10c00045 	stb	r3,1(r2)
 8202484:	00c01cc4 	movi	r3,115
 8202488:	10c00085 	stb	r3,2(r2)
 820248c:	00c01944 	movi	r3,101
 8202490:	10c000c5 	stb	r3,3(r2)
 8202494:	00c01d04 	movi	r3,116
 8202498:	10c00105 	stb	r3,4(r2)
 820249c:	00c01d04 	movi	r3,116
 82024a0:	10c00145 	stb	r3,5(r2)
 82024a4:	00c01a44 	movi	r3,105
 82024a8:	10c00185 	stb	r3,6(r2)
 82024ac:	00c01b84 	movi	r3,110
 82024b0:	10c001c5 	stb	r3,7(r2)
 82024b4:	00c019c4 	movi	r3,103
 82024b8:	10c00205 	stb	r3,8(r2)
 82024bc:	00c00284 	movi	r3,10
 82024c0:	10c00245 	stb	r3,9(r2)
 82024c4:	10000285 	stb	zero,10(r2)
 82024c8:	00800284 	movi	r2,10
 82024cc:	1007883a 	mov	r3,r2
 82024d0:	e0bb9417 	ldw	r2,-4528(fp)
 82024d4:	10c5883a 	add	r2,r2,r3
 82024d8:	e0bb9415 	stw	r2,-4528(fp)
	   endValue=0;
 82024dc:	e03b9605 	stb	zero,-4520(fp)
 82024e0:	00009006 	br	8202724 <sss_exec_command+0x914>

   } else if ( strstr(text_buf, "status") != NULL){
 82024e4:	e0bd1104 	addi	r2,fp,-3004
 82024e8:	01420974 	movhi	r5,2085
 82024ec:	2973fe04 	addi	r5,r5,-12296
 82024f0:	1009883a 	mov	r4,r2
 82024f4:	82044ac0 	call	82044ac <strstr>
 82024f8:	10008a26 	beq	r2,zero,8202724 <sss_exec_command+0x914>
	   if((startValue >> 1) & 1){
 82024fc:	e0bb98c3 	ldbu	r2,-4509(fp)
 8202500:	1004d07a 	srli	r2,r2,1
 8202504:	10803fcc 	andi	r2,r2,255
 8202508:	1080004c 	andi	r2,r2,1
 820250c:	10002226 	beq	r2,zero,8202598 <sss_exec_command+0x788>
		   tx_wr_pos += sprintf(tx_wr_pos, "Self Trigger\n");
 8202510:	e0bb9417 	ldw	r2,-4528(fp)
 8202514:	00c014c4 	movi	r3,83
 8202518:	10c00005 	stb	r3,0(r2)
 820251c:	00c01944 	movi	r3,101
 8202520:	10c00045 	stb	r3,1(r2)
 8202524:	00c01b04 	movi	r3,108
 8202528:	10c00085 	stb	r3,2(r2)
 820252c:	00c01984 	movi	r3,102
 8202530:	10c000c5 	stb	r3,3(r2)
 8202534:	00c00804 	movi	r3,32
 8202538:	10c00105 	stb	r3,4(r2)
 820253c:	00c01504 	movi	r3,84
 8202540:	10c00145 	stb	r3,5(r2)
 8202544:	00c01c84 	movi	r3,114
 8202548:	10c00185 	stb	r3,6(r2)
 820254c:	00c01a44 	movi	r3,105
 8202550:	10c001c5 	stb	r3,7(r2)
 8202554:	00c019c4 	movi	r3,103
 8202558:	10c00205 	stb	r3,8(r2)
 820255c:	00c019c4 	movi	r3,103
 8202560:	10c00245 	stb	r3,9(r2)
 8202564:	00c01944 	movi	r3,101
 8202568:	10c00285 	stb	r3,10(r2)
 820256c:	00c01c84 	movi	r3,114
 8202570:	10c002c5 	stb	r3,11(r2)
 8202574:	00c00284 	movi	r3,10
 8202578:	10c00305 	stb	r3,12(r2)
 820257c:	10000345 	stb	zero,13(r2)
 8202580:	00800344 	movi	r2,13
 8202584:	1007883a 	mov	r3,r2
 8202588:	e0bb9417 	ldw	r2,-4528(fp)
 820258c:	10c5883a 	add	r2,r2,r3
 8202590:	e0bb9415 	stw	r2,-4528(fp)
 8202594:	00000e06 	br	82025d0 <sss_exec_command+0x7c0>
	   } else {
		   tx_wr_pos += sprintf(tx_wr_pos, "External Trigger\n");
 8202598:	e0fb9417 	ldw	r3,-4528(fp)
 820259c:	00820974 	movhi	r2,2085
 82025a0:	10b40004 	addi	r2,r2,-12288
 82025a4:	1009883a 	mov	r4,r2
 82025a8:	00800484 	movi	r2,18
 82025ac:	100d883a 	mov	r6,r2
 82025b0:	200b883a 	mov	r5,r4
 82025b4:	1809883a 	mov	r4,r3
 82025b8:	8202f100 	call	8202f10 <memcpy>
 82025bc:	00800444 	movi	r2,17
 82025c0:	1007883a 	mov	r3,r2
 82025c4:	e0bb9417 	ldw	r2,-4528(fp)
 82025c8:	10c5883a 	add	r2,r2,r3
 82025cc:	e0bb9415 	stw	r2,-4528(fp)
	   }

	   if((startValue >> 2) & 1){
 82025d0:	e0bb98c3 	ldbu	r2,-4509(fp)
 82025d4:	1004d0ba 	srli	r2,r2,2
 82025d8:	10803fcc 	andi	r2,r2,255
 82025dc:	1080004c 	andi	r2,r2,1
 82025e0:	10000f26 	beq	r2,zero,8202620 <sss_exec_command+0x810>
		   tx_wr_pos += sprintf(tx_wr_pos, "Positive Trigger\n");
 82025e4:	e0fb9417 	ldw	r3,-4528(fp)
 82025e8:	00820974 	movhi	r2,2085
 82025ec:	10b40504 	addi	r2,r2,-12268
 82025f0:	1009883a 	mov	r4,r2
 82025f4:	00800484 	movi	r2,18
 82025f8:	100d883a 	mov	r6,r2
 82025fc:	200b883a 	mov	r5,r4
 8202600:	1809883a 	mov	r4,r3
 8202604:	8202f100 	call	8202f10 <memcpy>
 8202608:	00800444 	movi	r2,17
 820260c:	1007883a 	mov	r3,r2
 8202610:	e0bb9417 	ldw	r2,-4528(fp)
 8202614:	10c5883a 	add	r2,r2,r3
 8202618:	e0bb9415 	stw	r2,-4528(fp)
 820261c:	00000e06 	br	8202658 <sss_exec_command+0x848>
	   } else {
		   tx_wr_pos += sprintf(tx_wr_pos, "Negative Trigger\n");
 8202620:	e0fb9417 	ldw	r3,-4528(fp)
 8202624:	00820974 	movhi	r2,2085
 8202628:	10b40a04 	addi	r2,r2,-12248
 820262c:	1009883a 	mov	r4,r2
 8202630:	00800484 	movi	r2,18
 8202634:	100d883a 	mov	r6,r2
 8202638:	200b883a 	mov	r5,r4
 820263c:	1809883a 	mov	r4,r3
 8202640:	8202f100 	call	8202f10 <memcpy>
 8202644:	00800444 	movi	r2,17
 8202648:	1007883a 	mov	r3,r2
 820264c:	e0bb9417 	ldw	r2,-4528(fp)
 8202650:	10c5883a 	add	r2,r2,r3
 8202654:	e0bb9415 	stw	r2,-4528(fp)
	   }

	   if((startValue >> 3) & 1){
 8202658:	e0bb98c3 	ldbu	r2,-4509(fp)
 820265c:	1004d0fa 	srli	r2,r2,3
 8202660:	10803fcc 	andi	r2,r2,255
 8202664:	1080004c 	andi	r2,r2,1
 8202668:	10000f26 	beq	r2,zero,82026a8 <sss_exec_command+0x898>
		   tx_wr_pos += sprintf(tx_wr_pos, "Delay enabled\n");
 820266c:	e0fb9417 	ldw	r3,-4528(fp)
 8202670:	00820974 	movhi	r2,2085
 8202674:	10b40f04 	addi	r2,r2,-12228
 8202678:	1009883a 	mov	r4,r2
 820267c:	008003c4 	movi	r2,15
 8202680:	100d883a 	mov	r6,r2
 8202684:	200b883a 	mov	r5,r4
 8202688:	1809883a 	mov	r4,r3
 820268c:	8202f100 	call	8202f10 <memcpy>
 8202690:	00800384 	movi	r2,14
 8202694:	1007883a 	mov	r3,r2
 8202698:	e0bb9417 	ldw	r2,-4528(fp)
 820269c:	10c5883a 	add	r2,r2,r3
 82026a0:	e0bb9415 	stw	r2,-4528(fp)
 82026a4:	00000e06 	br	82026e0 <sss_exec_command+0x8d0>
	   } else {
		   tx_wr_pos += sprintf(tx_wr_pos, "Delay disabled\n");
 82026a8:	e0fb9417 	ldw	r3,-4528(fp)
 82026ac:	00820974 	movhi	r2,2085
 82026b0:	10b41304 	addi	r2,r2,-12212
 82026b4:	1009883a 	mov	r4,r2
 82026b8:	00800404 	movi	r2,16
 82026bc:	100d883a 	mov	r6,r2
 82026c0:	200b883a 	mov	r5,r4
 82026c4:	1809883a 	mov	r4,r3
 82026c8:	8202f100 	call	8202f10 <memcpy>
 82026cc:	008003c4 	movi	r2,15
 82026d0:	1007883a 	mov	r3,r2
 82026d4:	e0bb9417 	ldw	r2,-4528(fp)
 82026d8:	10c5883a 	add	r2,r2,r3
 82026dc:	e0bb9415 	stw	r2,-4528(fp)
	   }

	   tx_wr_pos += sprintf(tx_wr_pos, "done\n");
 82026e0:	e0bb9417 	ldw	r2,-4528(fp)
 82026e4:	00c01904 	movi	r3,100
 82026e8:	10c00005 	stb	r3,0(r2)
 82026ec:	00c01bc4 	movi	r3,111
 82026f0:	10c00045 	stb	r3,1(r2)
 82026f4:	00c01b84 	movi	r3,110
 82026f8:	10c00085 	stb	r3,2(r2)
 82026fc:	00c01944 	movi	r3,101
 8202700:	10c000c5 	stb	r3,3(r2)
 8202704:	00c00284 	movi	r3,10
 8202708:	10c00105 	stb	r3,4(r2)
 820270c:	10000145 	stb	zero,5(r2)
 8202710:	00800144 	movi	r2,5
 8202714:	1007883a 	mov	r3,r2
 8202718:	e0bb9417 	ldw	r2,-4528(fp)
 820271c:	10c5883a 	add	r2,r2,r3
 8202720:	e0bb9415 	stw	r2,-4528(fp)

   }



  IOWR_ALTERA_AVALON_PIO_DATA(ADC_CONTROL_BASE, endValue);
 8202724:	e0fb9603 	ldbu	r3,-4520(fp)
 8202728:	00824034 	movhi	r2,2304
 820272c:	10801004 	addi	r2,r2,64
 8202730:	10c00035 	stwio	r3,0(r2)


  send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);  
 8202734:	e0bfff17 	ldw	r2,-4(fp)
 8202738:	11000117 	ldw	r4,4(r2)
 820273c:	e0fb9417 	ldw	r3,-4528(fp)
 8202740:	e0bb9a04 	addi	r2,fp,-4504
 8202744:	1887c83a 	sub	r3,r3,r2
 8202748:	e0bb9a04 	addi	r2,fp,-4504
 820274c:	000f883a 	mov	r7,zero
 8202750:	180d883a 	mov	r6,r3
 8202754:	100b883a 	mov	r5,r2
 8202758:	82315700 	call	8231570 <t_send>
  
  return;
 820275c:	0001883a 	nop
}
 8202760:	e037883a 	mov	sp,fp
 8202764:	dfc00117 	ldw	ra,4(sp)
 8202768:	df000017 	ldw	fp,0(sp)
 820276c:	dec00204 	addi	sp,sp,8
 8202770:	f800283a 	ret

08202774 <sss_handle_receive>:
 * sss_exec_command() routine. Aside from these, we must move incoming
 * (un-processed) data to buffer start as appropriate and keep track of 
 * associated pointers.
 */
void sss_handle_receive(SSSConn* conn)
{
 8202774:	defffa04 	addi	sp,sp,-24
 8202778:	dfc00515 	stw	ra,20(sp)
 820277c:	df000415 	stw	fp,16(sp)
 8202780:	df000404 	addi	fp,sp,16
 8202784:	e13fff15 	stw	r4,-4(fp)
  int data_used = 0, rx_code = 0;
 8202788:	e03ffc15 	stw	zero,-16(fp)
 820278c:	e03ffd15 	stw	zero,-12(fp)
  char *lf_addr; 
  
  conn->rx_rd_pos = conn->rx_buffer;
 8202790:	e0bfff17 	ldw	r2,-4(fp)
 8202794:	10c00304 	addi	r3,r2,12
 8202798:	e0bfff17 	ldw	r2,-4(fp)
 820279c:	10c17a15 	stw	r3,1512(r2)
  conn->rx_wr_pos = conn->rx_buffer;
 82027a0:	e0bfff17 	ldw	r2,-4(fp)
 82027a4:	10c00304 	addi	r3,r2,12
 82027a8:	e0bfff17 	ldw	r2,-4(fp)
 82027ac:	10c17b15 	stw	r3,1516(r2)
  
  printf("[sss_handle_receive] processing RX data\n");
 82027b0:	01020974 	movhi	r4,2085
 82027b4:	21341704 	addi	r4,r4,-12196
 82027b8:	82036240 	call	8203624 <puts>
  
  while(conn->state != CLOSE)
 82027bc:	00005606 	br	8202918 <sss_handle_receive+0x1a4>
  {
    /* Find the Carriage return which marks the end of the header */
    lf_addr = strchr((const char*)conn->rx_buffer, '\n');
 82027c0:	e0bfff17 	ldw	r2,-4(fp)
 82027c4:	10800304 	addi	r2,r2,12
 82027c8:	01400284 	movi	r5,10
 82027cc:	1009883a 	mov	r4,r2
 82027d0:	82037840 	call	8203784 <strchr>
 82027d4:	e0bffe15 	stw	r2,-8(fp)
      
    if(lf_addr)
 82027d8:	e0bffe17 	ldw	r2,-8(fp)
 82027dc:	10000326 	beq	r2,zero,82027ec <sss_handle_receive+0x78>
    {
      /* go off and do whatever the user wanted us to do */
      sss_exec_command(conn);
 82027e0:	e13fff17 	ldw	r4,-4(fp)
 82027e4:	8201e100 	call	8201e10 <sss_exec_command>
 82027e8:	00001c06 	br	820285c <sss_handle_receive+0xe8>
    }
    /* No newline received? Then ask the socket for data */
    else
    {
      rx_code = recv(conn->fd, (char*)conn->rx_wr_pos, 
 82027ec:	e0bfff17 	ldw	r2,-4(fp)
 82027f0:	11000117 	ldw	r4,4(r2)
 82027f4:	e0bfff17 	ldw	r2,-4(fp)
 82027f8:	11417b17 	ldw	r5,1516(r2)
 82027fc:	e0bfff17 	ldw	r2,-4(fp)
 8202800:	10817b17 	ldw	r2,1516(r2)
 8202804:	1007883a 	mov	r3,r2
 8202808:	e0bfff17 	ldw	r2,-4(fp)
 820280c:	10800304 	addi	r2,r2,12
 8202810:	1885c83a 	sub	r2,r3,r2
 8202814:	00c176c4 	movi	r3,1499
 8202818:	1885c83a 	sub	r2,r3,r2
 820281c:	000f883a 	mov	r7,zero
 8202820:	100d883a 	mov	r6,r2
 8202824:	823115c0 	call	823115c <t_recv>
 8202828:	e0bffd15 	stw	r2,-12(fp)
        SSS_RX_BUF_SIZE - (conn->rx_wr_pos - conn->rx_buffer) -1, 0);
          
     if(rx_code > 0)
 820282c:	e0bffd17 	ldw	r2,-12(fp)
 8202830:	00800a0e 	bge	zero,r2,820285c <sss_handle_receive+0xe8>
      {
        conn->rx_wr_pos += rx_code;
 8202834:	e0bfff17 	ldw	r2,-4(fp)
 8202838:	10c17b17 	ldw	r3,1516(r2)
 820283c:	e0bffd17 	ldw	r2,-12(fp)
 8202840:	1887883a 	add	r3,r3,r2
 8202844:	e0bfff17 	ldw	r2,-4(fp)
 8202848:	10c17b15 	stw	r3,1516(r2)
        
        /* Zero terminate so we can use string functions */
        *(conn->rx_wr_pos+1) = 0;
 820284c:	e0bfff17 	ldw	r2,-4(fp)
 8202850:	10817b17 	ldw	r2,1516(r2)
 8202854:	10800044 	addi	r2,r2,1
 8202858:	10000005 	stb	zero,0(r2)

    /* 
     * When the quit command is received, update our connection state so that
     * we can exit the while() loop and close the connection
     */
    conn->state = conn->close ? CLOSE : READY;
 820285c:	e0bfff17 	ldw	r2,-4(fp)
 8202860:	10800217 	ldw	r2,8(r2)
 8202864:	10000226 	beq	r2,zero,8202870 <sss_handle_receive+0xfc>
 8202868:	00800084 	movi	r2,2
 820286c:	00000106 	br	8202874 <sss_handle_receive+0x100>
 8202870:	0005883a 	mov	r2,zero
 8202874:	e0ffff17 	ldw	r3,-4(fp)
 8202878:	18800015 	stw	r2,0(r3)

    /* Manage buffer */
    data_used = conn->rx_rd_pos - conn->rx_buffer;
 820287c:	e0bfff17 	ldw	r2,-4(fp)
 8202880:	10817a17 	ldw	r2,1512(r2)
 8202884:	1007883a 	mov	r3,r2
 8202888:	e0bfff17 	ldw	r2,-4(fp)
 820288c:	10800304 	addi	r2,r2,12
 8202890:	1885c83a 	sub	r2,r3,r2
 8202894:	e0bffc15 	stw	r2,-16(fp)
    memmove(conn->rx_buffer, conn->rx_rd_pos, 
 8202898:	e0bfff17 	ldw	r2,-4(fp)
 820289c:	10c00304 	addi	r3,r2,12
 82028a0:	e0bfff17 	ldw	r2,-4(fp)
 82028a4:	11017a17 	ldw	r4,1512(r2)
       conn->rx_wr_pos - conn->rx_rd_pos);
 82028a8:	e0bfff17 	ldw	r2,-4(fp)
 82028ac:	10817b17 	ldw	r2,1516(r2)
 82028b0:	100b883a 	mov	r5,r2
 82028b4:	e0bfff17 	ldw	r2,-4(fp)
 82028b8:	10817a17 	ldw	r2,1512(r2)
 82028bc:	2885c83a 	sub	r2,r5,r2
     */
    conn->state = conn->close ? CLOSE : READY;

    /* Manage buffer */
    data_used = conn->rx_rd_pos - conn->rx_buffer;
    memmove(conn->rx_buffer, conn->rx_rd_pos, 
 82028c0:	100d883a 	mov	r6,r2
 82028c4:	200b883a 	mov	r5,r4
 82028c8:	1809883a 	mov	r4,r3
 82028cc:	82030580 	call	8203058 <memmove>
       conn->rx_wr_pos - conn->rx_rd_pos);
    conn->rx_rd_pos = conn->rx_buffer;
 82028d0:	e0bfff17 	ldw	r2,-4(fp)
 82028d4:	10c00304 	addi	r3,r2,12
 82028d8:	e0bfff17 	ldw	r2,-4(fp)
 82028dc:	10c17a15 	stw	r3,1512(r2)
    conn->rx_wr_pos -= data_used;
 82028e0:	e0bfff17 	ldw	r2,-4(fp)
 82028e4:	10c17b17 	ldw	r3,1516(r2)
 82028e8:	e0bffc17 	ldw	r2,-16(fp)
 82028ec:	0085c83a 	sub	r2,zero,r2
 82028f0:	1887883a 	add	r3,r3,r2
 82028f4:	e0bfff17 	ldw	r2,-4(fp)
 82028f8:	10c17b15 	stw	r3,1516(r2)
    memset(conn->rx_wr_pos, 0, data_used);
 82028fc:	e0bfff17 	ldw	r2,-4(fp)
 8202900:	10817b17 	ldw	r2,1516(r2)
 8202904:	e0fffc17 	ldw	r3,-16(fp)
 8202908:	180d883a 	mov	r6,r3
 820290c:	000b883a 	mov	r5,zero
 8202910:	1009883a 	mov	r4,r2
 8202914:	82031b40 	call	82031b4 <memset>
  conn->rx_rd_pos = conn->rx_buffer;
  conn->rx_wr_pos = conn->rx_buffer;
  
  printf("[sss_handle_receive] processing RX data\n");
  
  while(conn->state != CLOSE)
 8202918:	e0bfff17 	ldw	r2,-4(fp)
 820291c:	10800017 	ldw	r2,0(r2)
 8202920:	10800098 	cmpnei	r2,r2,2
 8202924:	103fa61e 	bne	r2,zero,82027c0 <sss_handle_receive+0x4c>
    conn->rx_rd_pos = conn->rx_buffer;
    conn->rx_wr_pos -= data_used;
    memset(conn->rx_wr_pos, 0, data_used);
  }

  printf("[sss_handle_receive] closing connection\n");
 8202928:	01020974 	movhi	r4,2085
 820292c:	21342104 	addi	r4,r4,-12156
 8202930:	82036240 	call	8203624 <puts>
  close(conn->fd);
 8202934:	e0bfff17 	ldw	r2,-4(fp)
 8202938:	10800117 	ldw	r2,4(r2)
 820293c:	1009883a 	mov	r4,r2
 8202940:	82258380 	call	8225838 <close>
  sss_reset_connection(conn);
 8202944:	e13fff17 	ldw	r4,-4(fp)
 8202948:	8201a4c0 	call	8201a4c <sss_reset_connection>
  
  return;
 820294c:	0001883a 	nop
}
 8202950:	e037883a 	mov	sp,fp
 8202954:	dfc00117 	ldw	ra,4(sp)
 8202958:	df000017 	ldw	fp,0(sp)
 820295c:	dec00204 	addi	sp,sp,8
 8202960:	f800283a 	ret

08202964 <SSSSimpleSocketServerTask>:
 * (if a connection is active), the sss data socket. When data arrives, 
 * the approrpriate routine is called to either accept/reject a connection 
 * request, or process incoming data.
 */
void SSSSimpleSocketServerTask()
{
 8202964:	deffb604 	addi	sp,sp,-296
 8202968:	dfc04915 	stw	ra,292(sp)
 820296c:	df004815 	stw	fp,288(sp)
 8202970:	df004804 	addi	fp,sp,288
   * protocol and address families respectively. However, there is usually only
   * 1 address per protocol family. Thus PF_INET and AF_INET can be interchanged.
   * In the case of NicheStack, only the use of AF_INET is supported.
   * PF_INET is not supported in NicheStack.
   */ 
  if ((fd_listen = socket(AF_INET, SOCK_STREAM, 0)) < 0)
 8202974:	000d883a 	mov	r6,zero
 8202978:	01400044 	movi	r5,1
 820297c:	01000084 	movi	r4,2
 8202980:	82304300 	call	8230430 <t_socket>
 8202984:	e0bfba15 	stw	r2,-280(fp)
 8202988:	e0bfba17 	ldw	r2,-280(fp)
 820298c:	1000040e 	bge	r2,zero,82029a0 <SSSSimpleSocketServerTask+0x3c>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Socket creation failed");
 8202990:	01420974 	movhi	r5,2085
 8202994:	29742b04 	addi	r5,r5,-12116
 8202998:	01003fc4 	movi	r4,255
 820299c:	82007ac0 	call	82007ac <alt_NetworkErrorHandler>
   * port and incoming address. In this case we're binding to SSS_PORT and to
   * INADDR_ANY address (allowing anyone to connect to us. Bind may fail for 
   * various reasons, but the most common is that some other socket is bound to
   * the port we're requesting. 
   */ 
  addr.sin_family = AF_INET;
 82029a0:	00800084 	movi	r2,2
 82029a4:	e0bfbb0d 	sth	r2,-276(fp)
  addr.sin_port = htons(SSS_PORT);
 82029a8:	00878004 	movi	r2,7680
 82029ac:	e0bfbb8d 	sth	r2,-274(fp)
  addr.sin_addr.s_addr = INADDR_ANY;
 82029b0:	e03fbc15 	stw	zero,-272(fp)
  
  if ((bind(fd_listen,(struct sockaddr *)&addr,sizeof(addr))) < 0)
 82029b4:	e0bfbb04 	addi	r2,fp,-276
 82029b8:	01800404 	movi	r6,16
 82029bc:	100b883a 	mov	r5,r2
 82029c0:	e13fba17 	ldw	r4,-280(fp)
 82029c4:	82304b00 	call	82304b0 <t_bind>
 82029c8:	1000040e 	bge	r2,zero,82029dc <SSSSimpleSocketServerTask+0x78>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Bind failed");
 82029cc:	01420974 	movhi	r5,2085
 82029d0:	29743404 	addi	r5,r5,-12080
 82029d4:	01003fc4 	movi	r4,255
 82029d8:	82007ac0 	call	82007ac <alt_NetworkErrorHandler>
   * Sockets primer, continued...
   * The listen socket is a socket which is waiting for incoming connections.
   * This call to listen will block (i.e. not return) until someone tries to 
   * connect to this port.
   */ 
  if ((listen(fd_listen,1)) < 0)
 82029dc:	01400044 	movi	r5,1
 82029e0:	e13fba17 	ldw	r4,-280(fp)
 82029e4:	82306140 	call	8230614 <t_listen>
 82029e8:	1000040e 	bge	r2,zero,82029fc <SSSSimpleSocketServerTask+0x98>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Listen failed");
 82029ec:	01420974 	movhi	r5,2085
 82029f0:	29743a04 	addi	r5,r5,-12056
 82029f4:	01003fc4 	movi	r4,255
 82029f8:	82007ac0 	call	82007ac <alt_NetworkErrorHandler>
  }

  /* At this point we have successfully created a socket which is listening
   * on SSS_PORT for connection requests from any remote address.
   */
  sss_reset_connection(&conn);
 82029fc:	01020974 	movhi	r4,2085
 8202a00:	21107404 	addi	r4,r4,16848
 8202a04:	8201a4c0 	call	8201a4c <sss_reset_connection>
  printf("[sss_task] Simple Socket Server listening on port %d\n", SSS_PORT);
 8202a08:	01400784 	movi	r5,30
 8202a0c:	01020974 	movhi	r4,2085
 8202a10:	21344104 	addi	r4,r4,-12028
 8202a14:	82033a00 	call	82033a0 <printf>
     * 
     *   FD_ZERO  - Zero's out the sockets we're interested in
     *   FD_SET   - Adds a socket to those we're interested in
     *   FD_ISSET - Tests whether the chosen socket is set 
     */
    FD_ZERO(&readfds);
 8202a18:	e03fbf15 	stw	zero,-260(fp)
    FD_SET(fd_listen, &readfds);
 8202a1c:	e0bfbf04 	addi	r2,fp,-260
 8202a20:	100b883a 	mov	r5,r2
 8202a24:	e13fba17 	ldw	r4,-280(fp)
 8202a28:	823541c0 	call	823541c <ifd_set>
    max_socket = fd_listen+1;
 8202a2c:	e0bfba17 	ldw	r2,-280(fp)
 8202a30:	10800044 	addi	r2,r2,1
 8202a34:	e0bfb915 	stw	r2,-284(fp)

    if (conn.fd != -1)
 8202a38:	00820974 	movhi	r2,2085
 8202a3c:	10907404 	addi	r2,r2,16848
 8202a40:	10800117 	ldw	r2,4(r2)
 8202a44:	10bfffe0 	cmpeqi	r2,r2,-1
 8202a48:	1000111e 	bne	r2,zero,8202a90 <SSSSimpleSocketServerTask+0x12c>
    {
      FD_SET(conn.fd, &readfds);
 8202a4c:	00820974 	movhi	r2,2085
 8202a50:	10907404 	addi	r2,r2,16848
 8202a54:	10800117 	ldw	r2,4(r2)
 8202a58:	e0ffbf04 	addi	r3,fp,-260
 8202a5c:	180b883a 	mov	r5,r3
 8202a60:	1009883a 	mov	r4,r2
 8202a64:	823541c0 	call	823541c <ifd_set>
      if (max_socket <= conn.fd)
 8202a68:	00820974 	movhi	r2,2085
 8202a6c:	10907404 	addi	r2,r2,16848
 8202a70:	10c00117 	ldw	r3,4(r2)
 8202a74:	e0bfb917 	ldw	r2,-284(fp)
 8202a78:	18800516 	blt	r3,r2,8202a90 <SSSSimpleSocketServerTask+0x12c>
      {
        max_socket = conn.fd+1;
 8202a7c:	00820974 	movhi	r2,2085
 8202a80:	10907404 	addi	r2,r2,16848
 8202a84:	10800117 	ldw	r2,4(r2)
 8202a88:	10800044 	addi	r2,r2,1
 8202a8c:	e0bfb915 	stw	r2,-284(fp)
      }
    }

    select(max_socket, &readfds, NULL, NULL, NULL);
 8202a90:	e0bfbf04 	addi	r2,fp,-260
 8202a94:	d8000015 	stw	zero,0(sp)
 8202a98:	000f883a 	mov	r7,zero
 8202a9c:	000d883a 	mov	r6,zero
 8202aa0:	100b883a 	mov	r5,r2
 8202aa4:	e13fb917 	ldw	r4,-284(fp)
 8202aa8:	82284ac0 	call	82284ac <bsd_select>
     * is "set" in readfs, then we have an incoming connection request. We'll
     * call a routine to explicitly accept or deny the incoming connection 
     * request (in this example, we accept a single connection and reject any
     * others that come in while the connection is open).
     */
    if (FD_ISSET(fd_listen, &readfds))
 8202aac:	e0bfbf04 	addi	r2,fp,-260
 8202ab0:	100b883a 	mov	r5,r2
 8202ab4:	e13fba17 	ldw	r4,-280(fp)
 8202ab8:	82354940 	call	8235494 <ifd_isset>
 8202abc:	10000526 	beq	r2,zero,8202ad4 <SSSSimpleSocketServerTask+0x170>
    {
      sss_handle_accept(fd_listen, &conn);
 8202ac0:	01420974 	movhi	r5,2085
 8202ac4:	29507404 	addi	r5,r5,16848
 8202ac8:	e13fba17 	ldw	r4,-280(fp)
 8202acc:	8201d480 	call	8201d48 <sss_handle_accept>
 8202ad0:	003fd106 	br	8202a18 <SSSSimpleSocketServerTask+0xb4>
     * incoming data for our sss server, and we call our receiver routine
     * to process it.
     */
    else
    {
      if ((conn.fd != -1) && FD_ISSET(conn.fd, &readfds))
 8202ad4:	00820974 	movhi	r2,2085
 8202ad8:	10907404 	addi	r2,r2,16848
 8202adc:	10800117 	ldw	r2,4(r2)
 8202ae0:	10bfffe0 	cmpeqi	r2,r2,-1
 8202ae4:	103fcc1e 	bne	r2,zero,8202a18 <SSSSimpleSocketServerTask+0xb4>
 8202ae8:	00820974 	movhi	r2,2085
 8202aec:	10907404 	addi	r2,r2,16848
 8202af0:	10800117 	ldw	r2,4(r2)
 8202af4:	e0ffbf04 	addi	r3,fp,-260
 8202af8:	180b883a 	mov	r5,r3
 8202afc:	1009883a 	mov	r4,r2
 8202b00:	82354940 	call	8235494 <ifd_isset>
 8202b04:	103fc426 	beq	r2,zero,8202a18 <SSSSimpleSocketServerTask+0xb4>
      {
        sss_handle_receive(&conn);
 8202b08:	01020974 	movhi	r4,2085
 8202b0c:	21107404 	addi	r4,r4,16848
 8202b10:	82027740 	call	8202774 <sss_handle_receive>
      }
    }
  } /* while(1) */
 8202b14:	003fc006 	br	8202a18 <SSSSimpleSocketServerTask+0xb4>

08202b18 <__divsi3>:
 8202b18:	20001b16 	blt	r4,zero,8202b88 <__divsi3+0x70>
 8202b1c:	000f883a 	mov	r7,zero
 8202b20:	28001616 	blt	r5,zero,8202b7c <__divsi3+0x64>
 8202b24:	200d883a 	mov	r6,r4
 8202b28:	29001a2e 	bgeu	r5,r4,8202b94 <__divsi3+0x7c>
 8202b2c:	00800804 	movi	r2,32
 8202b30:	00c00044 	movi	r3,1
 8202b34:	00000106 	br	8202b3c <__divsi3+0x24>
 8202b38:	10000d26 	beq	r2,zero,8202b70 <__divsi3+0x58>
 8202b3c:	294b883a 	add	r5,r5,r5
 8202b40:	10bfffc4 	addi	r2,r2,-1
 8202b44:	18c7883a 	add	r3,r3,r3
 8202b48:	293ffb36 	bltu	r5,r4,8202b38 <__divsi3+0x20>
 8202b4c:	0005883a 	mov	r2,zero
 8202b50:	18000726 	beq	r3,zero,8202b70 <__divsi3+0x58>
 8202b54:	0005883a 	mov	r2,zero
 8202b58:	31400236 	bltu	r6,r5,8202b64 <__divsi3+0x4c>
 8202b5c:	314dc83a 	sub	r6,r6,r5
 8202b60:	10c4b03a 	or	r2,r2,r3
 8202b64:	1806d07a 	srli	r3,r3,1
 8202b68:	280ad07a 	srli	r5,r5,1
 8202b6c:	183ffa1e 	bne	r3,zero,8202b58 <__divsi3+0x40>
 8202b70:	38000126 	beq	r7,zero,8202b78 <__divsi3+0x60>
 8202b74:	0085c83a 	sub	r2,zero,r2
 8202b78:	f800283a 	ret
 8202b7c:	014bc83a 	sub	r5,zero,r5
 8202b80:	39c0005c 	xori	r7,r7,1
 8202b84:	003fe706 	br	8202b24 <__divsi3+0xc>
 8202b88:	0109c83a 	sub	r4,zero,r4
 8202b8c:	01c00044 	movi	r7,1
 8202b90:	003fe306 	br	8202b20 <__divsi3+0x8>
 8202b94:	00c00044 	movi	r3,1
 8202b98:	003fee06 	br	8202b54 <__divsi3+0x3c>

08202b9c <__modsi3>:
 8202b9c:	20001716 	blt	r4,zero,8202bfc <__modsi3+0x60>
 8202ba0:	000f883a 	mov	r7,zero
 8202ba4:	2005883a 	mov	r2,r4
 8202ba8:	28001216 	blt	r5,zero,8202bf4 <__modsi3+0x58>
 8202bac:	2900162e 	bgeu	r5,r4,8202c08 <__modsi3+0x6c>
 8202bb0:	01800804 	movi	r6,32
 8202bb4:	00c00044 	movi	r3,1
 8202bb8:	00000106 	br	8202bc0 <__modsi3+0x24>
 8202bbc:	30000a26 	beq	r6,zero,8202be8 <__modsi3+0x4c>
 8202bc0:	294b883a 	add	r5,r5,r5
 8202bc4:	31bfffc4 	addi	r6,r6,-1
 8202bc8:	18c7883a 	add	r3,r3,r3
 8202bcc:	293ffb36 	bltu	r5,r4,8202bbc <__modsi3+0x20>
 8202bd0:	18000526 	beq	r3,zero,8202be8 <__modsi3+0x4c>
 8202bd4:	1806d07a 	srli	r3,r3,1
 8202bd8:	11400136 	bltu	r2,r5,8202be0 <__modsi3+0x44>
 8202bdc:	1145c83a 	sub	r2,r2,r5
 8202be0:	280ad07a 	srli	r5,r5,1
 8202be4:	183ffb1e 	bne	r3,zero,8202bd4 <__modsi3+0x38>
 8202be8:	38000126 	beq	r7,zero,8202bf0 <__modsi3+0x54>
 8202bec:	0085c83a 	sub	r2,zero,r2
 8202bf0:	f800283a 	ret
 8202bf4:	014bc83a 	sub	r5,zero,r5
 8202bf8:	003fec06 	br	8202bac <__modsi3+0x10>
 8202bfc:	0109c83a 	sub	r4,zero,r4
 8202c00:	01c00044 	movi	r7,1
 8202c04:	003fe706 	br	8202ba4 <__modsi3+0x8>
 8202c08:	00c00044 	movi	r3,1
 8202c0c:	003ff106 	br	8202bd4 <__modsi3+0x38>

08202c10 <__udivsi3>:
 8202c10:	200d883a 	mov	r6,r4
 8202c14:	2900152e 	bgeu	r5,r4,8202c6c <__udivsi3+0x5c>
 8202c18:	28001416 	blt	r5,zero,8202c6c <__udivsi3+0x5c>
 8202c1c:	00800804 	movi	r2,32
 8202c20:	00c00044 	movi	r3,1
 8202c24:	00000206 	br	8202c30 <__udivsi3+0x20>
 8202c28:	10000e26 	beq	r2,zero,8202c64 <__udivsi3+0x54>
 8202c2c:	28000516 	blt	r5,zero,8202c44 <__udivsi3+0x34>
 8202c30:	294b883a 	add	r5,r5,r5
 8202c34:	10bfffc4 	addi	r2,r2,-1
 8202c38:	18c7883a 	add	r3,r3,r3
 8202c3c:	293ffa36 	bltu	r5,r4,8202c28 <__udivsi3+0x18>
 8202c40:	18000826 	beq	r3,zero,8202c64 <__udivsi3+0x54>
 8202c44:	0005883a 	mov	r2,zero
 8202c48:	31400236 	bltu	r6,r5,8202c54 <__udivsi3+0x44>
 8202c4c:	314dc83a 	sub	r6,r6,r5
 8202c50:	10c4b03a 	or	r2,r2,r3
 8202c54:	1806d07a 	srli	r3,r3,1
 8202c58:	280ad07a 	srli	r5,r5,1
 8202c5c:	183ffa1e 	bne	r3,zero,8202c48 <__udivsi3+0x38>
 8202c60:	f800283a 	ret
 8202c64:	0005883a 	mov	r2,zero
 8202c68:	f800283a 	ret
 8202c6c:	00c00044 	movi	r3,1
 8202c70:	003ff406 	br	8202c44 <__udivsi3+0x34>

08202c74 <__umodsi3>:
 8202c74:	2005883a 	mov	r2,r4
 8202c78:	2900122e 	bgeu	r5,r4,8202cc4 <__umodsi3+0x50>
 8202c7c:	28001116 	blt	r5,zero,8202cc4 <__umodsi3+0x50>
 8202c80:	01800804 	movi	r6,32
 8202c84:	00c00044 	movi	r3,1
 8202c88:	00000206 	br	8202c94 <__umodsi3+0x20>
 8202c8c:	30000c26 	beq	r6,zero,8202cc0 <__umodsi3+0x4c>
 8202c90:	28000516 	blt	r5,zero,8202ca8 <__umodsi3+0x34>
 8202c94:	294b883a 	add	r5,r5,r5
 8202c98:	31bfffc4 	addi	r6,r6,-1
 8202c9c:	18c7883a 	add	r3,r3,r3
 8202ca0:	293ffa36 	bltu	r5,r4,8202c8c <__umodsi3+0x18>
 8202ca4:	18000626 	beq	r3,zero,8202cc0 <__umodsi3+0x4c>
 8202ca8:	1806d07a 	srli	r3,r3,1
 8202cac:	11400136 	bltu	r2,r5,8202cb4 <__umodsi3+0x40>
 8202cb0:	1145c83a 	sub	r2,r2,r5
 8202cb4:	280ad07a 	srli	r5,r5,1
 8202cb8:	183ffb1e 	bne	r3,zero,8202ca8 <__umodsi3+0x34>
 8202cbc:	f800283a 	ret
 8202cc0:	f800283a 	ret
 8202cc4:	00c00044 	movi	r3,1
 8202cc8:	003ff706 	br	8202ca8 <__umodsi3+0x34>

08202ccc <_fprintf_r>:
 8202ccc:	defffe04 	addi	sp,sp,-8
 8202cd0:	2809883a 	mov	r4,r5
 8202cd4:	300b883a 	mov	r5,r6
 8202cd8:	dfc00015 	stw	ra,0(sp)
 8202cdc:	d9c00115 	stw	r7,4(sp)
 8202ce0:	d9800104 	addi	r6,sp,4
 8202ce4:	8208c340 	call	8208c34 <__vfprintf_internal>
 8202ce8:	dfc00017 	ldw	ra,0(sp)
 8202cec:	dec00204 	addi	sp,sp,8
 8202cf0:	f800283a 	ret

08202cf4 <fprintf>:
 8202cf4:	defffd04 	addi	sp,sp,-12
 8202cf8:	dfc00015 	stw	ra,0(sp)
 8202cfc:	d9800115 	stw	r6,4(sp)
 8202d00:	d9c00215 	stw	r7,8(sp)
 8202d04:	d9800104 	addi	r6,sp,4
 8202d08:	8208c340 	call	8208c34 <__vfprintf_internal>
 8202d0c:	dfc00017 	ldw	ra,0(sp)
 8202d10:	dec00304 	addi	sp,sp,12
 8202d14:	f800283a 	ret

08202d18 <_fwrite_r>:
 8202d18:	defff504 	addi	sp,sp,-44
 8202d1c:	dc800815 	stw	r18,32(sp)
 8202d20:	39a5383a 	mul	r18,r7,r6
 8202d24:	d8800304 	addi	r2,sp,12
 8202d28:	d8800015 	stw	r2,0(sp)
 8202d2c:	00800044 	movi	r2,1
 8202d30:	dcc00915 	stw	r19,36(sp)
 8202d34:	dc400715 	stw	r17,28(sp)
 8202d38:	dc000615 	stw	r16,24(sp)
 8202d3c:	d9400315 	stw	r5,12(sp)
 8202d40:	dfc00a15 	stw	ra,40(sp)
 8202d44:	dc800415 	stw	r18,16(sp)
 8202d48:	dc800215 	stw	r18,8(sp)
 8202d4c:	d8800115 	stw	r2,4(sp)
 8202d50:	3027883a 	mov	r19,r6
 8202d54:	3821883a 	mov	r16,r7
 8202d58:	2023883a 	mov	r17,r4
 8202d5c:	d9400b17 	ldw	r5,44(sp)
 8202d60:	20000226 	beq	r4,zero,8202d6c <_fwrite_r+0x54>
 8202d64:	20800e17 	ldw	r2,56(r4)
 8202d68:	10001a26 	beq	r2,zero,8202dd4 <_fwrite_r+0xbc>
 8202d6c:	2880030b 	ldhu	r2,12(r5)
 8202d70:	10c8000c 	andi	r3,r2,8192
 8202d74:	1800061e 	bne	r3,zero,8202d90 <_fwrite_r+0x78>
 8202d78:	29001917 	ldw	r4,100(r5)
 8202d7c:	00f7ffc4 	movi	r3,-8193
 8202d80:	10880014 	ori	r2,r2,8192
 8202d84:	20c6703a 	and	r3,r4,r3
 8202d88:	2880030d 	sth	r2,12(r5)
 8202d8c:	28c01915 	stw	r3,100(r5)
 8202d90:	d80d883a 	mov	r6,sp
 8202d94:	8809883a 	mov	r4,r17
 8202d98:	820b4100 	call	820b410 <__sfvwrite_r>
 8202d9c:	10000b26 	beq	r2,zero,8202dcc <_fwrite_r+0xb4>
 8202da0:	d9000217 	ldw	r4,8(sp)
 8202da4:	980b883a 	mov	r5,r19
 8202da8:	9109c83a 	sub	r4,r18,r4
 8202dac:	8202c100 	call	8202c10 <__udivsi3>
 8202db0:	dfc00a17 	ldw	ra,40(sp)
 8202db4:	dcc00917 	ldw	r19,36(sp)
 8202db8:	dc800817 	ldw	r18,32(sp)
 8202dbc:	dc400717 	ldw	r17,28(sp)
 8202dc0:	dc000617 	ldw	r16,24(sp)
 8202dc4:	dec00b04 	addi	sp,sp,44
 8202dc8:	f800283a 	ret
 8202dcc:	8005883a 	mov	r2,r16
 8202dd0:	003ff706 	br	8202db0 <_fwrite_r+0x98>
 8202dd4:	d9400515 	stw	r5,20(sp)
 8202dd8:	820ae380 	call	820ae38 <__sinit>
 8202ddc:	d9400517 	ldw	r5,20(sp)
 8202de0:	003fe206 	br	8202d6c <_fwrite_r+0x54>

08202de4 <fwrite>:
 8202de4:	defffe04 	addi	sp,sp,-8
 8202de8:	00820974 	movhi	r2,2085
 8202dec:	d9c00015 	stw	r7,0(sp)
 8202df0:	108f9904 	addi	r2,r2,15972
 8202df4:	300f883a 	mov	r7,r6
 8202df8:	280d883a 	mov	r6,r5
 8202dfc:	200b883a 	mov	r5,r4
 8202e00:	11000017 	ldw	r4,0(r2)
 8202e04:	dfc00115 	stw	ra,4(sp)
 8202e08:	8202d180 	call	8202d18 <_fwrite_r>
 8202e0c:	dfc00117 	ldw	ra,4(sp)
 8202e10:	dec00204 	addi	sp,sp,8
 8202e14:	f800283a 	ret

08202e18 <_getc_r>:
 8202e18:	defffd04 	addi	sp,sp,-12
 8202e1c:	dc000115 	stw	r16,4(sp)
 8202e20:	dfc00215 	stw	ra,8(sp)
 8202e24:	2021883a 	mov	r16,r4
 8202e28:	20000226 	beq	r4,zero,8202e34 <_getc_r+0x1c>
 8202e2c:	20800e17 	ldw	r2,56(r4)
 8202e30:	10000c26 	beq	r2,zero,8202e64 <_getc_r+0x4c>
 8202e34:	28800117 	ldw	r2,4(r5)
 8202e38:	10bfffc4 	addi	r2,r2,-1
 8202e3c:	28800115 	stw	r2,4(r5)
 8202e40:	10000c16 	blt	r2,zero,8202e74 <_getc_r+0x5c>
 8202e44:	28800017 	ldw	r2,0(r5)
 8202e48:	10c00044 	addi	r3,r2,1
 8202e4c:	28c00015 	stw	r3,0(r5)
 8202e50:	10800003 	ldbu	r2,0(r2)
 8202e54:	dfc00217 	ldw	ra,8(sp)
 8202e58:	dc000117 	ldw	r16,4(sp)
 8202e5c:	dec00304 	addi	sp,sp,12
 8202e60:	f800283a 	ret
 8202e64:	d9400015 	stw	r5,0(sp)
 8202e68:	820ae380 	call	820ae38 <__sinit>
 8202e6c:	d9400017 	ldw	r5,0(sp)
 8202e70:	003ff006 	br	8202e34 <_getc_r+0x1c>
 8202e74:	8009883a 	mov	r4,r16
 8202e78:	dfc00217 	ldw	ra,8(sp)
 8202e7c:	dc000117 	ldw	r16,4(sp)
 8202e80:	dec00304 	addi	sp,sp,12
 8202e84:	82036381 	jmpi	8203638 <__srget_r>

08202e88 <getc>:
 8202e88:	00820974 	movhi	r2,2085
 8202e8c:	defffd04 	addi	sp,sp,-12
 8202e90:	108f9904 	addi	r2,r2,15972
 8202e94:	dc400115 	stw	r17,4(sp)
 8202e98:	14400017 	ldw	r17,0(r2)
 8202e9c:	dc000015 	stw	r16,0(sp)
 8202ea0:	dfc00215 	stw	ra,8(sp)
 8202ea4:	2021883a 	mov	r16,r4
 8202ea8:	88000226 	beq	r17,zero,8202eb4 <getc+0x2c>
 8202eac:	88800e17 	ldw	r2,56(r17)
 8202eb0:	10000d26 	beq	r2,zero,8202ee8 <getc+0x60>
 8202eb4:	80800117 	ldw	r2,4(r16)
 8202eb8:	10bfffc4 	addi	r2,r2,-1
 8202ebc:	80800115 	stw	r2,4(r16)
 8202ec0:	10000c16 	blt	r2,zero,8202ef4 <getc+0x6c>
 8202ec4:	80800017 	ldw	r2,0(r16)
 8202ec8:	10c00044 	addi	r3,r2,1
 8202ecc:	80c00015 	stw	r3,0(r16)
 8202ed0:	10800003 	ldbu	r2,0(r2)
 8202ed4:	dfc00217 	ldw	ra,8(sp)
 8202ed8:	dc400117 	ldw	r17,4(sp)
 8202edc:	dc000017 	ldw	r16,0(sp)
 8202ee0:	dec00304 	addi	sp,sp,12
 8202ee4:	f800283a 	ret
 8202ee8:	8809883a 	mov	r4,r17
 8202eec:	820ae380 	call	820ae38 <__sinit>
 8202ef0:	003ff006 	br	8202eb4 <getc+0x2c>
 8202ef4:	800b883a 	mov	r5,r16
 8202ef8:	8809883a 	mov	r4,r17
 8202efc:	dfc00217 	ldw	ra,8(sp)
 8202f00:	dc400117 	ldw	r17,4(sp)
 8202f04:	dc000017 	ldw	r16,0(sp)
 8202f08:	dec00304 	addi	sp,sp,12
 8202f0c:	82036381 	jmpi	8203638 <__srget_r>

08202f10 <memcpy>:
 8202f10:	defffd04 	addi	sp,sp,-12
 8202f14:	dfc00215 	stw	ra,8(sp)
 8202f18:	dc400115 	stw	r17,4(sp)
 8202f1c:	dc000015 	stw	r16,0(sp)
 8202f20:	00c003c4 	movi	r3,15
 8202f24:	2005883a 	mov	r2,r4
 8202f28:	1980452e 	bgeu	r3,r6,8203040 <memcpy+0x130>
 8202f2c:	2906b03a 	or	r3,r5,r4
 8202f30:	18c000cc 	andi	r3,r3,3
 8202f34:	1800441e 	bne	r3,zero,8203048 <memcpy+0x138>
 8202f38:	347ffc04 	addi	r17,r6,-16
 8202f3c:	8822d13a 	srli	r17,r17,4
 8202f40:	28c00104 	addi	r3,r5,4
 8202f44:	23400104 	addi	r13,r4,4
 8202f48:	8820913a 	slli	r16,r17,4
 8202f4c:	2b000204 	addi	r12,r5,8
 8202f50:	22c00204 	addi	r11,r4,8
 8202f54:	84000504 	addi	r16,r16,20
 8202f58:	2a800304 	addi	r10,r5,12
 8202f5c:	22400304 	addi	r9,r4,12
 8202f60:	2c21883a 	add	r16,r5,r16
 8202f64:	2811883a 	mov	r8,r5
 8202f68:	200f883a 	mov	r7,r4
 8202f6c:	41000017 	ldw	r4,0(r8)
 8202f70:	1fc00017 	ldw	ra,0(r3)
 8202f74:	63c00017 	ldw	r15,0(r12)
 8202f78:	39000015 	stw	r4,0(r7)
 8202f7c:	53800017 	ldw	r14,0(r10)
 8202f80:	6fc00015 	stw	ra,0(r13)
 8202f84:	5bc00015 	stw	r15,0(r11)
 8202f88:	4b800015 	stw	r14,0(r9)
 8202f8c:	18c00404 	addi	r3,r3,16
 8202f90:	39c00404 	addi	r7,r7,16
 8202f94:	42000404 	addi	r8,r8,16
 8202f98:	6b400404 	addi	r13,r13,16
 8202f9c:	63000404 	addi	r12,r12,16
 8202fa0:	5ac00404 	addi	r11,r11,16
 8202fa4:	52800404 	addi	r10,r10,16
 8202fa8:	4a400404 	addi	r9,r9,16
 8202fac:	1c3fef1e 	bne	r3,r16,8202f6c <memcpy+0x5c>
 8202fb0:	89c00044 	addi	r7,r17,1
 8202fb4:	380e913a 	slli	r7,r7,4
 8202fb8:	310003cc 	andi	r4,r6,15
 8202fbc:	02c000c4 	movi	r11,3
 8202fc0:	11c7883a 	add	r3,r2,r7
 8202fc4:	29cb883a 	add	r5,r5,r7
 8202fc8:	5900212e 	bgeu	r11,r4,8203050 <memcpy+0x140>
 8202fcc:	1813883a 	mov	r9,r3
 8202fd0:	2811883a 	mov	r8,r5
 8202fd4:	200f883a 	mov	r7,r4
 8202fd8:	42800017 	ldw	r10,0(r8)
 8202fdc:	4a400104 	addi	r9,r9,4
 8202fe0:	39ffff04 	addi	r7,r7,-4
 8202fe4:	4abfff15 	stw	r10,-4(r9)
 8202fe8:	42000104 	addi	r8,r8,4
 8202fec:	59fffa36 	bltu	r11,r7,8202fd8 <memcpy+0xc8>
 8202ff0:	213fff04 	addi	r4,r4,-4
 8202ff4:	2008d0ba 	srli	r4,r4,2
 8202ff8:	318000cc 	andi	r6,r6,3
 8202ffc:	21000044 	addi	r4,r4,1
 8203000:	2109883a 	add	r4,r4,r4
 8203004:	2109883a 	add	r4,r4,r4
 8203008:	1907883a 	add	r3,r3,r4
 820300c:	290b883a 	add	r5,r5,r4
 8203010:	30000626 	beq	r6,zero,820302c <memcpy+0x11c>
 8203014:	198d883a 	add	r6,r3,r6
 8203018:	29c00003 	ldbu	r7,0(r5)
 820301c:	18c00044 	addi	r3,r3,1
 8203020:	29400044 	addi	r5,r5,1
 8203024:	19ffffc5 	stb	r7,-1(r3)
 8203028:	19bffb1e 	bne	r3,r6,8203018 <memcpy+0x108>
 820302c:	dfc00217 	ldw	ra,8(sp)
 8203030:	dc400117 	ldw	r17,4(sp)
 8203034:	dc000017 	ldw	r16,0(sp)
 8203038:	dec00304 	addi	sp,sp,12
 820303c:	f800283a 	ret
 8203040:	2007883a 	mov	r3,r4
 8203044:	003ff206 	br	8203010 <memcpy+0x100>
 8203048:	2007883a 	mov	r3,r4
 820304c:	003ff106 	br	8203014 <memcpy+0x104>
 8203050:	200d883a 	mov	r6,r4
 8203054:	003fee06 	br	8203010 <memcpy+0x100>

08203058 <memmove>:
 8203058:	2005883a 	mov	r2,r4
 820305c:	29000b2e 	bgeu	r5,r4,820308c <memmove+0x34>
 8203060:	298f883a 	add	r7,r5,r6
 8203064:	21c0092e 	bgeu	r4,r7,820308c <memmove+0x34>
 8203068:	2187883a 	add	r3,r4,r6
 820306c:	198bc83a 	sub	r5,r3,r6
 8203070:	30004826 	beq	r6,zero,8203194 <memmove+0x13c>
 8203074:	39ffffc4 	addi	r7,r7,-1
 8203078:	39000003 	ldbu	r4,0(r7)
 820307c:	18ffffc4 	addi	r3,r3,-1
 8203080:	19000005 	stb	r4,0(r3)
 8203084:	28fffb1e 	bne	r5,r3,8203074 <memmove+0x1c>
 8203088:	f800283a 	ret
 820308c:	00c003c4 	movi	r3,15
 8203090:	1980412e 	bgeu	r3,r6,8203198 <memmove+0x140>
 8203094:	2886b03a 	or	r3,r5,r2
 8203098:	18c000cc 	andi	r3,r3,3
 820309c:	1800401e 	bne	r3,zero,82031a0 <memmove+0x148>
 82030a0:	33fffc04 	addi	r15,r6,-16
 82030a4:	781ed13a 	srli	r15,r15,4
 82030a8:	28c00104 	addi	r3,r5,4
 82030ac:	13400104 	addi	r13,r2,4
 82030b0:	781c913a 	slli	r14,r15,4
 82030b4:	2b000204 	addi	r12,r5,8
 82030b8:	12c00204 	addi	r11,r2,8
 82030bc:	73800504 	addi	r14,r14,20
 82030c0:	2a800304 	addi	r10,r5,12
 82030c4:	12400304 	addi	r9,r2,12
 82030c8:	2b9d883a 	add	r14,r5,r14
 82030cc:	2811883a 	mov	r8,r5
 82030d0:	100f883a 	mov	r7,r2
 82030d4:	41000017 	ldw	r4,0(r8)
 82030d8:	39c00404 	addi	r7,r7,16
 82030dc:	18c00404 	addi	r3,r3,16
 82030e0:	393ffc15 	stw	r4,-16(r7)
 82030e4:	193ffc17 	ldw	r4,-16(r3)
 82030e8:	6b400404 	addi	r13,r13,16
 82030ec:	5ac00404 	addi	r11,r11,16
 82030f0:	693ffc15 	stw	r4,-16(r13)
 82030f4:	61000017 	ldw	r4,0(r12)
 82030f8:	4a400404 	addi	r9,r9,16
 82030fc:	42000404 	addi	r8,r8,16
 8203100:	593ffc15 	stw	r4,-16(r11)
 8203104:	51000017 	ldw	r4,0(r10)
 8203108:	63000404 	addi	r12,r12,16
 820310c:	52800404 	addi	r10,r10,16
 8203110:	493ffc15 	stw	r4,-16(r9)
 8203114:	1bbfef1e 	bne	r3,r14,82030d4 <memmove+0x7c>
 8203118:	79000044 	addi	r4,r15,1
 820311c:	2008913a 	slli	r4,r4,4
 8203120:	328003cc 	andi	r10,r6,15
 8203124:	02c000c4 	movi	r11,3
 8203128:	1107883a 	add	r3,r2,r4
 820312c:	290b883a 	add	r5,r5,r4
 8203130:	5a801e2e 	bgeu	r11,r10,82031ac <memmove+0x154>
 8203134:	1813883a 	mov	r9,r3
 8203138:	2811883a 	mov	r8,r5
 820313c:	500f883a 	mov	r7,r10
 8203140:	41000017 	ldw	r4,0(r8)
 8203144:	4a400104 	addi	r9,r9,4
 8203148:	39ffff04 	addi	r7,r7,-4
 820314c:	493fff15 	stw	r4,-4(r9)
 8203150:	42000104 	addi	r8,r8,4
 8203154:	59fffa36 	bltu	r11,r7,8203140 <memmove+0xe8>
 8203158:	513fff04 	addi	r4,r10,-4
 820315c:	2008d0ba 	srli	r4,r4,2
 8203160:	318000cc 	andi	r6,r6,3
 8203164:	21000044 	addi	r4,r4,1
 8203168:	2109883a 	add	r4,r4,r4
 820316c:	2109883a 	add	r4,r4,r4
 8203170:	1907883a 	add	r3,r3,r4
 8203174:	290b883a 	add	r5,r5,r4
 8203178:	30000b26 	beq	r6,zero,82031a8 <memmove+0x150>
 820317c:	198d883a 	add	r6,r3,r6
 8203180:	29c00003 	ldbu	r7,0(r5)
 8203184:	18c00044 	addi	r3,r3,1
 8203188:	29400044 	addi	r5,r5,1
 820318c:	19ffffc5 	stb	r7,-1(r3)
 8203190:	19bffb1e 	bne	r3,r6,8203180 <memmove+0x128>
 8203194:	f800283a 	ret
 8203198:	1007883a 	mov	r3,r2
 820319c:	003ff606 	br	8203178 <memmove+0x120>
 82031a0:	1007883a 	mov	r3,r2
 82031a4:	003ff506 	br	820317c <memmove+0x124>
 82031a8:	f800283a 	ret
 82031ac:	500d883a 	mov	r6,r10
 82031b0:	003ff106 	br	8203178 <memmove+0x120>

082031b4 <memset>:
 82031b4:	20c000cc 	andi	r3,r4,3
 82031b8:	2005883a 	mov	r2,r4
 82031bc:	18004426 	beq	r3,zero,82032d0 <memset+0x11c>
 82031c0:	31ffffc4 	addi	r7,r6,-1
 82031c4:	30004026 	beq	r6,zero,82032c8 <memset+0x114>
 82031c8:	2813883a 	mov	r9,r5
 82031cc:	200d883a 	mov	r6,r4
 82031d0:	2007883a 	mov	r3,r4
 82031d4:	00000406 	br	82031e8 <memset+0x34>
 82031d8:	3a3fffc4 	addi	r8,r7,-1
 82031dc:	31800044 	addi	r6,r6,1
 82031e0:	38003926 	beq	r7,zero,82032c8 <memset+0x114>
 82031e4:	400f883a 	mov	r7,r8
 82031e8:	18c00044 	addi	r3,r3,1
 82031ec:	32400005 	stb	r9,0(r6)
 82031f0:	1a0000cc 	andi	r8,r3,3
 82031f4:	403ff81e 	bne	r8,zero,82031d8 <memset+0x24>
 82031f8:	010000c4 	movi	r4,3
 82031fc:	21c02d2e 	bgeu	r4,r7,82032b4 <memset+0x100>
 8203200:	29003fcc 	andi	r4,r5,255
 8203204:	200c923a 	slli	r6,r4,8
 8203208:	3108b03a 	or	r4,r6,r4
 820320c:	200c943a 	slli	r6,r4,16
 8203210:	218cb03a 	or	r6,r4,r6
 8203214:	010003c4 	movi	r4,15
 8203218:	21c0182e 	bgeu	r4,r7,820327c <memset+0xc8>
 820321c:	3b3ffc04 	addi	r12,r7,-16
 8203220:	6018d13a 	srli	r12,r12,4
 8203224:	1a000104 	addi	r8,r3,4
 8203228:	1ac00204 	addi	r11,r3,8
 820322c:	6008913a 	slli	r4,r12,4
 8203230:	1a800304 	addi	r10,r3,12
 8203234:	1813883a 	mov	r9,r3
 8203238:	21000504 	addi	r4,r4,20
 820323c:	1909883a 	add	r4,r3,r4
 8203240:	49800015 	stw	r6,0(r9)
 8203244:	41800015 	stw	r6,0(r8)
 8203248:	59800015 	stw	r6,0(r11)
 820324c:	51800015 	stw	r6,0(r10)
 8203250:	42000404 	addi	r8,r8,16
 8203254:	4a400404 	addi	r9,r9,16
 8203258:	5ac00404 	addi	r11,r11,16
 820325c:	52800404 	addi	r10,r10,16
 8203260:	413ff71e 	bne	r8,r4,8203240 <memset+0x8c>
 8203264:	63000044 	addi	r12,r12,1
 8203268:	6018913a 	slli	r12,r12,4
 820326c:	39c003cc 	andi	r7,r7,15
 8203270:	010000c4 	movi	r4,3
 8203274:	1b07883a 	add	r3,r3,r12
 8203278:	21c00e2e 	bgeu	r4,r7,82032b4 <memset+0x100>
 820327c:	1813883a 	mov	r9,r3
 8203280:	3811883a 	mov	r8,r7
 8203284:	010000c4 	movi	r4,3
 8203288:	49800015 	stw	r6,0(r9)
 820328c:	423fff04 	addi	r8,r8,-4
 8203290:	4a400104 	addi	r9,r9,4
 8203294:	223ffc36 	bltu	r4,r8,8203288 <memset+0xd4>
 8203298:	393fff04 	addi	r4,r7,-4
 820329c:	2008d0ba 	srli	r4,r4,2
 82032a0:	39c000cc 	andi	r7,r7,3
 82032a4:	21000044 	addi	r4,r4,1
 82032a8:	2109883a 	add	r4,r4,r4
 82032ac:	2109883a 	add	r4,r4,r4
 82032b0:	1907883a 	add	r3,r3,r4
 82032b4:	38000526 	beq	r7,zero,82032cc <memset+0x118>
 82032b8:	19cf883a 	add	r7,r3,r7
 82032bc:	19400005 	stb	r5,0(r3)
 82032c0:	18c00044 	addi	r3,r3,1
 82032c4:	38fffd1e 	bne	r7,r3,82032bc <memset+0x108>
 82032c8:	f800283a 	ret
 82032cc:	f800283a 	ret
 82032d0:	2007883a 	mov	r3,r4
 82032d4:	300f883a 	mov	r7,r6
 82032d8:	003fc706 	br	82031f8 <memset+0x44>

082032dc <_perror_r>:
 82032dc:	defffd04 	addi	sp,sp,-12
 82032e0:	dc000115 	stw	r16,4(sp)
 82032e4:	dfc00215 	stw	ra,8(sp)
 82032e8:	2021883a 	mov	r16,r4
 82032ec:	28000326 	beq	r5,zero,82032fc <_perror_r+0x20>
 82032f0:	28c00007 	ldb	r3,0(r5)
 82032f4:	2805883a 	mov	r2,r5
 82032f8:	1800101e 	bne	r3,zero,820333c <_perror_r+0x60>
 82032fc:	81400017 	ldw	r5,0(r16)
 8203300:	d80f883a 	mov	r7,sp
 8203304:	01800044 	movi	r6,1
 8203308:	8009883a 	mov	r4,r16
 820330c:	82038e80 	call	82038e8 <_strerror_r>
 8203310:	10000326 	beq	r2,zero,8203320 <_perror_r+0x44>
 8203314:	81400317 	ldw	r5,12(r16)
 8203318:	1009883a 	mov	r4,r2
 820331c:	820afc40 	call	820afc4 <fputs>
 8203320:	81400317 	ldw	r5,12(r16)
 8203324:	01000284 	movi	r4,10
 8203328:	820aecc0 	call	820aecc <fputc>
 820332c:	dfc00217 	ldw	ra,8(sp)
 8203330:	dc000117 	ldw	r16,4(sp)
 8203334:	dec00304 	addi	sp,sp,12
 8203338:	f800283a 	ret
 820333c:	21400317 	ldw	r5,12(r4)
 8203340:	1009883a 	mov	r4,r2
 8203344:	820afc40 	call	820afc4 <fputs>
 8203348:	81400317 	ldw	r5,12(r16)
 820334c:	01020974 	movhi	r4,2085
 8203350:	2134f804 	addi	r4,r4,-11296
 8203354:	820afc40 	call	820afc4 <fputs>
 8203358:	003fe806 	br	82032fc <_perror_r+0x20>

0820335c <perror>:
 820335c:	00820974 	movhi	r2,2085
 8203360:	108f9904 	addi	r2,r2,15972
 8203364:	200b883a 	mov	r5,r4
 8203368:	11000017 	ldw	r4,0(r2)
 820336c:	82032dc1 	jmpi	82032dc <_perror_r>

08203370 <_printf_r>:
 8203370:	defffd04 	addi	sp,sp,-12
 8203374:	2805883a 	mov	r2,r5
 8203378:	dfc00015 	stw	ra,0(sp)
 820337c:	d9800115 	stw	r6,4(sp)
 8203380:	d9c00215 	stw	r7,8(sp)
 8203384:	21400217 	ldw	r5,8(r4)
 8203388:	d9c00104 	addi	r7,sp,4
 820338c:	100d883a 	mov	r6,r2
 8203390:	8206a3c0 	call	8206a3c <___vfprintf_internal_r>
 8203394:	dfc00017 	ldw	ra,0(sp)
 8203398:	dec00304 	addi	sp,sp,12
 820339c:	f800283a 	ret

082033a0 <printf>:
 82033a0:	defffc04 	addi	sp,sp,-16
 82033a4:	dfc00015 	stw	ra,0(sp)
 82033a8:	d9400115 	stw	r5,4(sp)
 82033ac:	d9800215 	stw	r6,8(sp)
 82033b0:	d9c00315 	stw	r7,12(sp)
 82033b4:	00820974 	movhi	r2,2085
 82033b8:	108f9904 	addi	r2,r2,15972
 82033bc:	10800017 	ldw	r2,0(r2)
 82033c0:	200b883a 	mov	r5,r4
 82033c4:	d9800104 	addi	r6,sp,4
 82033c8:	11000217 	ldw	r4,8(r2)
 82033cc:	8208c340 	call	8208c34 <__vfprintf_internal>
 82033d0:	dfc00017 	ldw	ra,0(sp)
 82033d4:	dec00404 	addi	sp,sp,16
 82033d8:	f800283a 	ret

082033dc <_putc_r>:
 82033dc:	defffc04 	addi	sp,sp,-16
 82033e0:	dc000215 	stw	r16,8(sp)
 82033e4:	dfc00315 	stw	ra,12(sp)
 82033e8:	2021883a 	mov	r16,r4
 82033ec:	20000226 	beq	r4,zero,82033f8 <_putc_r+0x1c>
 82033f0:	20800e17 	ldw	r2,56(r4)
 82033f4:	10001b26 	beq	r2,zero,8203464 <_putc_r+0x88>
 82033f8:	30800217 	ldw	r2,8(r6)
 82033fc:	10bfffc4 	addi	r2,r2,-1
 8203400:	30800215 	stw	r2,8(r6)
 8203404:	10000a16 	blt	r2,zero,8203430 <_putc_r+0x54>
 8203408:	30800017 	ldw	r2,0(r6)
 820340c:	11400005 	stb	r5,0(r2)
 8203410:	30800017 	ldw	r2,0(r6)
 8203414:	10c00044 	addi	r3,r2,1
 8203418:	30c00015 	stw	r3,0(r6)
 820341c:	10800003 	ldbu	r2,0(r2)
 8203420:	dfc00317 	ldw	ra,12(sp)
 8203424:	dc000217 	ldw	r16,8(sp)
 8203428:	dec00404 	addi	sp,sp,16
 820342c:	f800283a 	ret
 8203430:	30c00617 	ldw	r3,24(r6)
 8203434:	10c00616 	blt	r2,r3,8203450 <_putc_r+0x74>
 8203438:	30800017 	ldw	r2,0(r6)
 820343c:	00c00284 	movi	r3,10
 8203440:	11400005 	stb	r5,0(r2)
 8203444:	30800017 	ldw	r2,0(r6)
 8203448:	11400003 	ldbu	r5,0(r2)
 820344c:	28fff11e 	bne	r5,r3,8203414 <_putc_r+0x38>
 8203450:	8009883a 	mov	r4,r16
 8203454:	dfc00317 	ldw	ra,12(sp)
 8203458:	dc000217 	ldw	r16,8(sp)
 820345c:	dec00404 	addi	sp,sp,16
 8203460:	8208d0c1 	jmpi	8208d0c <__swbuf_r>
 8203464:	d9400015 	stw	r5,0(sp)
 8203468:	d9800115 	stw	r6,4(sp)
 820346c:	820ae380 	call	820ae38 <__sinit>
 8203470:	d9800117 	ldw	r6,4(sp)
 8203474:	d9400017 	ldw	r5,0(sp)
 8203478:	003fdf06 	br	82033f8 <_putc_r+0x1c>

0820347c <putc>:
 820347c:	00820974 	movhi	r2,2085
 8203480:	defffc04 	addi	sp,sp,-16
 8203484:	108f9904 	addi	r2,r2,15972
 8203488:	dc000115 	stw	r16,4(sp)
 820348c:	14000017 	ldw	r16,0(r2)
 8203490:	dc400215 	stw	r17,8(sp)
 8203494:	dfc00315 	stw	ra,12(sp)
 8203498:	2023883a 	mov	r17,r4
 820349c:	80000226 	beq	r16,zero,82034a8 <putc+0x2c>
 82034a0:	80800e17 	ldw	r2,56(r16)
 82034a4:	10001a26 	beq	r2,zero,8203510 <putc+0x94>
 82034a8:	28800217 	ldw	r2,8(r5)
 82034ac:	10bfffc4 	addi	r2,r2,-1
 82034b0:	28800215 	stw	r2,8(r5)
 82034b4:	10000b16 	blt	r2,zero,82034e4 <putc+0x68>
 82034b8:	28800017 	ldw	r2,0(r5)
 82034bc:	14400005 	stb	r17,0(r2)
 82034c0:	28800017 	ldw	r2,0(r5)
 82034c4:	10c00044 	addi	r3,r2,1
 82034c8:	28c00015 	stw	r3,0(r5)
 82034cc:	10800003 	ldbu	r2,0(r2)
 82034d0:	dfc00317 	ldw	ra,12(sp)
 82034d4:	dc400217 	ldw	r17,8(sp)
 82034d8:	dc000117 	ldw	r16,4(sp)
 82034dc:	dec00404 	addi	sp,sp,16
 82034e0:	f800283a 	ret
 82034e4:	28c00617 	ldw	r3,24(r5)
 82034e8:	10c00e16 	blt	r2,r3,8203524 <putc+0xa8>
 82034ec:	28800017 	ldw	r2,0(r5)
 82034f0:	01000284 	movi	r4,10
 82034f4:	14400005 	stb	r17,0(r2)
 82034f8:	28800017 	ldw	r2,0(r5)
 82034fc:	10c00003 	ldbu	r3,0(r2)
 8203500:	193ff01e 	bne	r3,r4,82034c4 <putc+0x48>
 8203504:	280d883a 	mov	r6,r5
 8203508:	180b883a 	mov	r5,r3
 820350c:	00000706 	br	820352c <putc+0xb0>
 8203510:	8009883a 	mov	r4,r16
 8203514:	d9400015 	stw	r5,0(sp)
 8203518:	820ae380 	call	820ae38 <__sinit>
 820351c:	d9400017 	ldw	r5,0(sp)
 8203520:	003fe106 	br	82034a8 <putc+0x2c>
 8203524:	280d883a 	mov	r6,r5
 8203528:	880b883a 	mov	r5,r17
 820352c:	8009883a 	mov	r4,r16
 8203530:	dfc00317 	ldw	ra,12(sp)
 8203534:	dc400217 	ldw	r17,8(sp)
 8203538:	dc000117 	ldw	r16,4(sp)
 820353c:	dec00404 	addi	sp,sp,16
 8203540:	8208d0c1 	jmpi	8208d0c <__swbuf_r>

08203544 <_putchar_r>:
 8203544:	21800217 	ldw	r6,8(r4)
 8203548:	82033dc1 	jmpi	82033dc <_putc_r>

0820354c <putchar>:
 820354c:	00820974 	movhi	r2,2085
 8203550:	108f9904 	addi	r2,r2,15972
 8203554:	200b883a 	mov	r5,r4
 8203558:	11000017 	ldw	r4,0(r2)
 820355c:	21800217 	ldw	r6,8(r4)
 8203560:	82033dc1 	jmpi	82033dc <_putc_r>

08203564 <_puts_r>:
 8203564:	defff604 	addi	sp,sp,-40
 8203568:	dc000715 	stw	r16,28(sp)
 820356c:	2021883a 	mov	r16,r4
 8203570:	2809883a 	mov	r4,r5
 8203574:	dc400815 	stw	r17,32(sp)
 8203578:	dfc00915 	stw	ra,36(sp)
 820357c:	2823883a 	mov	r17,r5
 8203580:	8203f600 	call	8203f60 <strlen>
 8203584:	10c00044 	addi	r3,r2,1
 8203588:	d8800115 	stw	r2,4(sp)
 820358c:	00820974 	movhi	r2,2085
 8203590:	10b4f904 	addi	r2,r2,-11292
 8203594:	d8800215 	stw	r2,8(sp)
 8203598:	00800044 	movi	r2,1
 820359c:	d8800315 	stw	r2,12(sp)
 82035a0:	00800084 	movi	r2,2
 82035a4:	dc400015 	stw	r17,0(sp)
 82035a8:	d8c00615 	stw	r3,24(sp)
 82035ac:	dec00415 	stw	sp,16(sp)
 82035b0:	d8800515 	stw	r2,20(sp)
 82035b4:	80000226 	beq	r16,zero,82035c0 <_puts_r+0x5c>
 82035b8:	80800e17 	ldw	r2,56(r16)
 82035bc:	10001426 	beq	r2,zero,8203610 <_puts_r+0xac>
 82035c0:	81400217 	ldw	r5,8(r16)
 82035c4:	2880030b 	ldhu	r2,12(r5)
 82035c8:	10c8000c 	andi	r3,r2,8192
 82035cc:	1800061e 	bne	r3,zero,82035e8 <_puts_r+0x84>
 82035d0:	29001917 	ldw	r4,100(r5)
 82035d4:	00f7ffc4 	movi	r3,-8193
 82035d8:	10880014 	ori	r2,r2,8192
 82035dc:	20c6703a 	and	r3,r4,r3
 82035e0:	2880030d 	sth	r2,12(r5)
 82035e4:	28c01915 	stw	r3,100(r5)
 82035e8:	d9800404 	addi	r6,sp,16
 82035ec:	8009883a 	mov	r4,r16
 82035f0:	820b4100 	call	820b410 <__sfvwrite_r>
 82035f4:	1000091e 	bne	r2,zero,820361c <_puts_r+0xb8>
 82035f8:	00800284 	movi	r2,10
 82035fc:	dfc00917 	ldw	ra,36(sp)
 8203600:	dc400817 	ldw	r17,32(sp)
 8203604:	dc000717 	ldw	r16,28(sp)
 8203608:	dec00a04 	addi	sp,sp,40
 820360c:	f800283a 	ret
 8203610:	8009883a 	mov	r4,r16
 8203614:	820ae380 	call	820ae38 <__sinit>
 8203618:	003fe906 	br	82035c0 <_puts_r+0x5c>
 820361c:	00bfffc4 	movi	r2,-1
 8203620:	003ff606 	br	82035fc <_puts_r+0x98>

08203624 <puts>:
 8203624:	00820974 	movhi	r2,2085
 8203628:	108f9904 	addi	r2,r2,15972
 820362c:	200b883a 	mov	r5,r4
 8203630:	11000017 	ldw	r4,0(r2)
 8203634:	82035641 	jmpi	8203564 <_puts_r>

08203638 <__srget_r>:
 8203638:	defffd04 	addi	sp,sp,-12
 820363c:	dc400115 	stw	r17,4(sp)
 8203640:	dc000015 	stw	r16,0(sp)
 8203644:	dfc00215 	stw	ra,8(sp)
 8203648:	2023883a 	mov	r17,r4
 820364c:	2821883a 	mov	r16,r5
 8203650:	20000226 	beq	r4,zero,820365c <__srget_r+0x24>
 8203654:	20800e17 	ldw	r2,56(r4)
 8203658:	10001026 	beq	r2,zero,820369c <__srget_r+0x64>
 820365c:	800b883a 	mov	r5,r16
 8203660:	8809883a 	mov	r4,r17
 8203664:	820dbd40 	call	820dbd4 <__srefill_r>
 8203668:	10000e1e 	bne	r2,zero,82036a4 <__srget_r+0x6c>
 820366c:	80c00017 	ldw	r3,0(r16)
 8203670:	80800117 	ldw	r2,4(r16)
 8203674:	19000044 	addi	r4,r3,1
 8203678:	10bfffc4 	addi	r2,r2,-1
 820367c:	80800115 	stw	r2,4(r16)
 8203680:	81000015 	stw	r4,0(r16)
 8203684:	18800003 	ldbu	r2,0(r3)
 8203688:	dfc00217 	ldw	ra,8(sp)
 820368c:	dc400117 	ldw	r17,4(sp)
 8203690:	dc000017 	ldw	r16,0(sp)
 8203694:	dec00304 	addi	sp,sp,12
 8203698:	f800283a 	ret
 820369c:	820ae380 	call	820ae38 <__sinit>
 82036a0:	003fee06 	br	820365c <__srget_r+0x24>
 82036a4:	00bfffc4 	movi	r2,-1
 82036a8:	003ff706 	br	8203688 <__srget_r+0x50>

082036ac <__srget>:
 82036ac:	00820974 	movhi	r2,2085
 82036b0:	108f9904 	addi	r2,r2,15972
 82036b4:	200b883a 	mov	r5,r4
 82036b8:	11000017 	ldw	r4,0(r2)
 82036bc:	82036381 	jmpi	8203638 <__srget_r>

082036c0 <_sprintf_r>:
 82036c0:	deffe404 	addi	sp,sp,-112
 82036c4:	2807883a 	mov	r3,r5
 82036c8:	dfc01a15 	stw	ra,104(sp)
 82036cc:	d9c01b15 	stw	r7,108(sp)
 82036d0:	00a00034 	movhi	r2,32768
 82036d4:	10bfffc4 	addi	r2,r2,-1
 82036d8:	02008204 	movi	r8,520
 82036dc:	d8800215 	stw	r2,8(sp)
 82036e0:	d8800515 	stw	r2,20(sp)
 82036e4:	d9c01b04 	addi	r7,sp,108
 82036e8:	d80b883a 	mov	r5,sp
 82036ec:	00bfffc4 	movi	r2,-1
 82036f0:	d8c00015 	stw	r3,0(sp)
 82036f4:	d8c00415 	stw	r3,16(sp)
 82036f8:	da00030d 	sth	r8,12(sp)
 82036fc:	d880038d 	sth	r2,14(sp)
 8203700:	820485c0 	call	820485c <___svfprintf_internal_r>
 8203704:	d8c00017 	ldw	r3,0(sp)
 8203708:	18000005 	stb	zero,0(r3)
 820370c:	dfc01a17 	ldw	ra,104(sp)
 8203710:	dec01c04 	addi	sp,sp,112
 8203714:	f800283a 	ret

08203718 <sprintf>:
 8203718:	deffe304 	addi	sp,sp,-116
 820371c:	2007883a 	mov	r3,r4
 8203720:	dfc01a15 	stw	ra,104(sp)
 8203724:	d9801b15 	stw	r6,108(sp)
 8203728:	d9c01c15 	stw	r7,112(sp)
 820372c:	01020974 	movhi	r4,2085
 8203730:	210f9904 	addi	r4,r4,15972
 8203734:	21000017 	ldw	r4,0(r4)
 8203738:	00a00034 	movhi	r2,32768
 820373c:	10bfffc4 	addi	r2,r2,-1
 8203740:	280d883a 	mov	r6,r5
 8203744:	02008204 	movi	r8,520
 8203748:	d8800215 	stw	r2,8(sp)
 820374c:	d8800515 	stw	r2,20(sp)
 8203750:	d9c01b04 	addi	r7,sp,108
 8203754:	d80b883a 	mov	r5,sp
 8203758:	00bfffc4 	movi	r2,-1
 820375c:	d8c00015 	stw	r3,0(sp)
 8203760:	d8c00415 	stw	r3,16(sp)
 8203764:	da00030d 	sth	r8,12(sp)
 8203768:	d880038d 	sth	r2,14(sp)
 820376c:	820485c0 	call	820485c <___svfprintf_internal_r>
 8203770:	d8c00017 	ldw	r3,0(sp)
 8203774:	18000005 	stb	zero,0(r3)
 8203778:	dfc01a17 	ldw	ra,104(sp)
 820377c:	dec01d04 	addi	sp,sp,116
 8203780:	f800283a 	ret

08203784 <strchr>:
 8203784:	2ac03fcc 	andi	r11,r5,255
 8203788:	2813883a 	mov	r9,r5
 820378c:	208000cc 	andi	r2,r4,3
 8203790:	58003726 	beq	r11,zero,8203870 <strchr+0xec>
 8203794:	10000b26 	beq	r2,zero,82037c4 <strchr+0x40>
 8203798:	20800003 	ldbu	r2,0(r4)
 820379c:	10003226 	beq	r2,zero,8203868 <strchr+0xe4>
 82037a0:	28c03fcc 	andi	r3,r5,255
 82037a4:	5880041e 	bne	r11,r2,82037b8 <strchr+0x34>
 82037a8:	00004d06 	br	82038e0 <strchr+0x15c>
 82037ac:	20800003 	ldbu	r2,0(r4)
 82037b0:	10002d26 	beq	r2,zero,8203868 <strchr+0xe4>
 82037b4:	18804a26 	beq	r3,r2,82038e0 <strchr+0x15c>
 82037b8:	21000044 	addi	r4,r4,1
 82037bc:	208000cc 	andi	r2,r4,3
 82037c0:	103ffa1e 	bne	r2,zero,82037ac <strchr+0x28>
 82037c4:	29403fcc 	andi	r5,r5,255
 82037c8:	2814923a 	slli	r10,r5,8
 82037cc:	20800017 	ldw	r2,0(r4)
 82037d0:	01bfbff4 	movhi	r6,65279
 82037d4:	2a8ab03a 	or	r5,r5,r10
 82037d8:	2814943a 	slli	r10,r5,16
 82037dc:	31bfbfc4 	addi	r6,r6,-257
 82037e0:	119b883a 	add	r13,r2,r6
 82037e4:	5154b03a 	or	r10,r10,r5
 82037e8:	008e303a 	nor	r7,zero,r2
 82037ec:	5084f03a 	xor	r2,r10,r2
 82037f0:	1191883a 	add	r8,r2,r6
 82037f4:	0086303a 	nor	r3,zero,r2
 82037f8:	03202074 	movhi	r12,32897
 82037fc:	69ca703a 	and	r5,r13,r7
 8203800:	40c4703a 	and	r2,r8,r3
 8203804:	63202004 	addi	r12,r12,-32640
 8203808:	2884b03a 	or	r2,r5,r2
 820380c:	1304703a 	and	r2,r2,r12
 8203810:	10000c1e 	bne	r2,zero,8203844 <strchr+0xc0>
 8203814:	21000104 	addi	r4,r4,4
 8203818:	20c00017 	ldw	r3,0(r4)
 820381c:	50c4f03a 	xor	r2,r10,r3
 8203820:	1991883a 	add	r8,r3,r6
 8203824:	00ca303a 	nor	r5,zero,r3
 8203828:	118f883a 	add	r7,r2,r6
 820382c:	0086303a 	nor	r3,zero,r2
 8203830:	414a703a 	and	r5,r8,r5
 8203834:	38c4703a 	and	r2,r7,r3
 8203838:	2884b03a 	or	r2,r5,r2
 820383c:	1304703a 	and	r2,r2,r12
 8203840:	103ff426 	beq	r2,zero,8203814 <strchr+0x90>
 8203844:	20800003 	ldbu	r2,0(r4)
 8203848:	10000726 	beq	r2,zero,8203868 <strchr+0xe4>
 820384c:	58802426 	beq	r11,r2,82038e0 <strchr+0x15c>
 8203850:	48c03fcc 	andi	r3,r9,255
 8203854:	00000106 	br	820385c <strchr+0xd8>
 8203858:	18802126 	beq	r3,r2,82038e0 <strchr+0x15c>
 820385c:	21000044 	addi	r4,r4,1
 8203860:	20800003 	ldbu	r2,0(r4)
 8203864:	103ffc1e 	bne	r2,zero,8203858 <strchr+0xd4>
 8203868:	0005883a 	mov	r2,zero
 820386c:	f800283a 	ret
 8203870:	10000526 	beq	r2,zero,8203888 <strchr+0x104>
 8203874:	20800003 	ldbu	r2,0(r4)
 8203878:	10001926 	beq	r2,zero,82038e0 <strchr+0x15c>
 820387c:	21000044 	addi	r4,r4,1
 8203880:	208000cc 	andi	r2,r4,3
 8203884:	103ffb1e 	bne	r2,zero,8203874 <strchr+0xf0>
 8203888:	20800017 	ldw	r2,0(r4)
 820388c:	01bfbff4 	movhi	r6,65279
 8203890:	31bfbfc4 	addi	r6,r6,-257
 8203894:	0086303a 	nor	r3,zero,r2
 8203898:	01602074 	movhi	r5,32897
 820389c:	1185883a 	add	r2,r2,r6
 82038a0:	29602004 	addi	r5,r5,-32640
 82038a4:	10c4703a 	and	r2,r2,r3
 82038a8:	1144703a 	and	r2,r2,r5
 82038ac:	1000071e 	bne	r2,zero,82038cc <strchr+0x148>
 82038b0:	21000104 	addi	r4,r4,4
 82038b4:	20800017 	ldw	r2,0(r4)
 82038b8:	1187883a 	add	r3,r2,r6
 82038bc:	0084303a 	nor	r2,zero,r2
 82038c0:	1884703a 	and	r2,r3,r2
 82038c4:	1144703a 	and	r2,r2,r5
 82038c8:	103ff926 	beq	r2,zero,82038b0 <strchr+0x12c>
 82038cc:	20800003 	ldbu	r2,0(r4)
 82038d0:	10000326 	beq	r2,zero,82038e0 <strchr+0x15c>
 82038d4:	21000044 	addi	r4,r4,1
 82038d8:	20800003 	ldbu	r2,0(r4)
 82038dc:	103ffd1e 	bne	r2,zero,82038d4 <strchr+0x150>
 82038e0:	2005883a 	mov	r2,r4
 82038e4:	f800283a 	ret

082038e8 <_strerror_r>:
 82038e8:	deffff04 	addi	sp,sp,-4
 82038ec:	2807883a 	mov	r3,r5
 82038f0:	dfc00015 	stw	ra,0(sp)
 82038f4:	00802384 	movi	r2,142
 82038f8:	300b883a 	mov	r5,r6
 82038fc:	10c18736 	bltu	r2,r3,8203f1c <_strerror_r+0x634>
 8203900:	181090ba 	slli	r8,r3,2
 8203904:	00820834 	movhi	r2,2080
 8203908:	108e4604 	addi	r2,r2,14616
 820390c:	4085883a 	add	r2,r8,r2
 8203910:	10800017 	ldw	r2,0(r2)
 8203914:	1000683a 	jmp	r2
 8203918:	08203b54 	ori	zero,at,33005
 820391c:	08203f10 	cmplti	zero,at,-32516
 8203920:	08203f04 	addi	zero,at,-32516
 8203924:	08203ef8 	rdprs	zero,at,-32517
 8203928:	08203eec 	andhi	zero,at,33019
 820392c:	08203ee0 	cmpeqi	zero,at,-32517
 8203930:	08203ed4 	ori	zero,at,33019
 8203934:	08203ec8 	cmpgei	zero,at,-32517
 8203938:	08203ebc 	xorhi	zero,at,33018
 820393c:	08203eb0 	cmpltui	zero,at,33018
 8203940:	08203ea4 	muli	zero,at,-32518
 8203944:	08203e98 	cmpnei	zero,at,-32518
 8203948:	08203e8c 	andi	zero,at,33018
 820394c:	08203e80 	call	8203e8 <OSCtxSw_SWITCH_PC+0x8203a8>
 8203950:	08203e74 	orhi	zero,at,33017
 8203954:	08203f1c 	xori	zero,at,33020
 8203958:	08203e68 	cmpgeui	zero,at,33017
 820395c:	08203e5c 	xori	zero,at,33017
 8203960:	08203e50 	cmplti	zero,at,-32519
 8203964:	08203e44 	addi	zero,at,-32519
 8203968:	08203e38 	rdprs	zero,at,-32520
 820396c:	08203e2c 	andhi	zero,at,33016
 8203970:	08203e20 	cmpeqi	zero,at,-32520
 8203974:	08203e14 	ori	zero,at,33016
 8203978:	08203e08 	cmpgei	zero,at,-32520
 820397c:	08203dfc 	xorhi	zero,at,33015
 8203980:	08203df0 	cmpltui	zero,at,33015
 8203984:	08203de4 	muli	zero,at,-32521
 8203988:	08203dd8 	cmpnei	zero,at,-32521
 820398c:	08203dcc 	andi	zero,at,33015
 8203990:	08203dc0 	call	8203dc <OSCtxSw_SWITCH_PC+0x82039c>
 8203994:	08203db4 	orhi	zero,at,33014
 8203998:	08203da8 	cmpgeui	zero,at,33014
 820399c:	08203d9c 	xori	zero,at,33014
 82039a0:	08203d90 	cmplti	zero,at,-32522
 82039a4:	08203d84 	addi	zero,at,-32522
 82039a8:	08203d78 	rdprs	zero,at,-32523
 82039ac:	08203f1c 	xori	zero,at,33020
 82039b0:	08203f1c 	xori	zero,at,33020
 82039b4:	08203f1c 	xori	zero,at,33020
 82039b8:	08203f1c 	xori	zero,at,33020
 82039bc:	08203f1c 	xori	zero,at,33020
 82039c0:	08203f1c 	xori	zero,at,33020
 82039c4:	08203f1c 	xori	zero,at,33020
 82039c8:	08203f1c 	xori	zero,at,33020
 82039cc:	08203d6c 	andhi	zero,at,33013
 82039d0:	08203d60 	cmpeqi	zero,at,-32523
 82039d4:	08203f1c 	xori	zero,at,33020
 82039d8:	08203f1c 	xori	zero,at,33020
 82039dc:	08203f1c 	xori	zero,at,33020
 82039e0:	08203f1c 	xori	zero,at,33020
 82039e4:	08203f1c 	xori	zero,at,33020
 82039e8:	08203f1c 	xori	zero,at,33020
 82039ec:	08203f1c 	xori	zero,at,33020
 82039f0:	08203f1c 	xori	zero,at,33020
 82039f4:	08203f1c 	xori	zero,at,33020
 82039f8:	08203f1c 	xori	zero,at,33020
 82039fc:	08203f1c 	xori	zero,at,33020
 8203a00:	08203f1c 	xori	zero,at,33020
 8203a04:	08203f1c 	xori	zero,at,33020
 8203a08:	08203d54 	ori	zero,at,33013
 8203a0c:	08203d48 	cmpgei	zero,at,-32523
 8203a10:	08203d3c 	xorhi	zero,at,33012
 8203a14:	08203d30 	cmpltui	zero,at,33012
 8203a18:	08203f1c 	xori	zero,at,33020
 8203a1c:	08203f1c 	xori	zero,at,33020
 8203a20:	08203f1c 	xori	zero,at,33020
 8203a24:	08203d24 	muli	zero,at,-32524
 8203a28:	08203f1c 	xori	zero,at,33020
 8203a2c:	08203f1c 	xori	zero,at,33020
 8203a30:	08203f1c 	xori	zero,at,33020
 8203a34:	08203d18 	cmpnei	zero,at,-32524
 8203a38:	08203f1c 	xori	zero,at,33020
 8203a3c:	08203f1c 	xori	zero,at,33020
 8203a40:	08203d0c 	andi	zero,at,33012
 8203a44:	08203f1c 	xori	zero,at,33020
 8203a48:	08203f1c 	xori	zero,at,33020
 8203a4c:	08203d00 	call	8203d0 <OSCtxSw_SWITCH_PC+0x820390>
 8203a50:	08203f1c 	xori	zero,at,33020
 8203a54:	08203f1c 	xori	zero,at,33020
 8203a58:	08203f1c 	xori	zero,at,33020
 8203a5c:	08203f1c 	xori	zero,at,33020
 8203a60:	08203f1c 	xori	zero,at,33020
 8203a64:	08203f1c 	xori	zero,at,33020
 8203a68:	08203f1c 	xori	zero,at,33020
 8203a6c:	08203f1c 	xori	zero,at,33020
 8203a70:	08203f1c 	xori	zero,at,33020
 8203a74:	08203f1c 	xori	zero,at,33020
 8203a78:	08203cf4 	orhi	zero,at,33011
 8203a7c:	08203f1c 	xori	zero,at,33020
 8203a80:	08203ce8 	cmpgeui	zero,at,33011
 8203a84:	08203cdc 	xori	zero,at,33011
 8203a88:	08203cd0 	cmplti	zero,at,-32525
 8203a8c:	08203f1c 	xori	zero,at,33020
 8203a90:	08203f1c 	xori	zero,at,33020
 8203a94:	08203cc4 	addi	zero,at,-32525
 8203a98:	08203f1c 	xori	zero,at,33020
 8203a9c:	08203f1c 	xori	zero,at,33020
 8203aa0:	08203f1c 	xori	zero,at,33020
 8203aa4:	08203f1c 	xori	zero,at,33020
 8203aa8:	08203f1c 	xori	zero,at,33020
 8203aac:	08203f1c 	xori	zero,at,33020
 8203ab0:	08203f1c 	xori	zero,at,33020
 8203ab4:	08203f1c 	xori	zero,at,33020
 8203ab8:	08203cb8 	rdprs	zero,at,-32526
 8203abc:	08203cac 	andhi	zero,at,33010
 8203ac0:	08203ca0 	cmpeqi	zero,at,-32526
 8203ac4:	08203c94 	ori	zero,at,33010
 8203ac8:	08203c88 	cmpgei	zero,at,-32526
 8203acc:	08203c7c 	xorhi	zero,at,33009
 8203ad0:	08203f1c 	xori	zero,at,33020
 8203ad4:	08203c70 	cmpltui	zero,at,33009
 8203ad8:	08203c64 	muli	zero,at,-32527
 8203adc:	08203c58 	cmpnei	zero,at,-32527
 8203ae0:	08203c4c 	andi	zero,at,33009
 8203ae4:	08203c40 	call	8203c4 <OSCtxSw_SWITCH_PC+0x820384>
 8203ae8:	08203c34 	orhi	zero,at,33008
 8203aec:	08203c28 	cmpgeui	zero,at,33008
 8203af0:	08203c1c 	xori	zero,at,33008
 8203af4:	08203c10 	cmplti	zero,at,-32528
 8203af8:	08203c04 	addi	zero,at,-32528
 8203afc:	08203bf8 	rdprs	zero,at,-32529
 8203b00:	08203bec 	andhi	zero,at,33007
 8203b04:	08203be0 	cmpeqi	zero,at,-32529
 8203b08:	08203f1c 	xori	zero,at,33020
 8203b0c:	08203bd4 	ori	zero,at,33007
 8203b10:	08203bc8 	cmpgei	zero,at,-32529
 8203b14:	08203bbc 	xorhi	zero,at,33006
 8203b18:	08203bb0 	cmpltui	zero,at,33006
 8203b1c:	08203f1c 	xori	zero,at,33020
 8203b20:	08203f1c 	xori	zero,at,33020
 8203b24:	08203f1c 	xori	zero,at,33020
 8203b28:	08203f1c 	xori	zero,at,33020
 8203b2c:	08203f1c 	xori	zero,at,33020
 8203b30:	08203ba4 	muli	zero,at,-32530
 8203b34:	08203f1c 	xori	zero,at,33020
 8203b38:	08203f1c 	xori	zero,at,33020
 8203b3c:	08203f1c 	xori	zero,at,33020
 8203b40:	08203b98 	cmpnei	zero,at,-32530
 8203b44:	08203b8c 	andi	zero,at,33006
 8203b48:	08203b80 	call	8203b8 <OSCtxSw_SWITCH_PC+0x820378>
 8203b4c:	08203b74 	orhi	zero,at,33005
 8203b50:	08203b68 	cmpgeui	zero,at,33005
 8203b54:	00820974 	movhi	r2,2085
 8203b58:	10b4fa04 	addi	r2,r2,-11288
 8203b5c:	dfc00017 	ldw	ra,0(sp)
 8203b60:	dec00104 	addi	sp,sp,4
 8203b64:	f800283a 	ret
 8203b68:	00820974 	movhi	r2,2085
 8203b6c:	10b69704 	addi	r2,r2,-9636
 8203b70:	003ffa06 	br	8203b5c <_strerror_r+0x274>
 8203b74:	00820974 	movhi	r2,2085
 8203b78:	10b69104 	addi	r2,r2,-9660
 8203b7c:	003ff706 	br	8203b5c <_strerror_r+0x274>
 8203b80:	00820974 	movhi	r2,2085
 8203b84:	10b68c04 	addi	r2,r2,-9680
 8203b88:	003ff406 	br	8203b5c <_strerror_r+0x274>
 8203b8c:	00820974 	movhi	r2,2085
 8203b90:	10b6a504 	addi	r2,r2,-9580
 8203b94:	003ff106 	br	8203b5c <_strerror_r+0x274>
 8203b98:	00820974 	movhi	r2,2085
 8203b9c:	10b5e304 	addi	r2,r2,-10356
 8203ba0:	003fee06 	br	8203b5c <_strerror_r+0x274>
 8203ba4:	00820974 	movhi	r2,2085
 8203ba8:	10b5b104 	addi	r2,r2,-10556
 8203bac:	003feb06 	br	8203b5c <_strerror_r+0x274>
 8203bb0:	00820974 	movhi	r2,2085
 8203bb4:	10b67f04 	addi	r2,r2,-9732
 8203bb8:	003fe806 	br	8203b5c <_strerror_r+0x274>
 8203bbc:	00820974 	movhi	r2,2085
 8203bc0:	10b68504 	addi	r2,r2,-9708
 8203bc4:	003fe506 	br	8203b5c <_strerror_r+0x274>
 8203bc8:	00820974 	movhi	r2,2085
 8203bcc:	10b58004 	addi	r2,r2,-10752
 8203bd0:	003fe206 	br	8203b5c <_strerror_r+0x274>
 8203bd4:	00820974 	movhi	r2,2085
 8203bd8:	10b67004 	addi	r2,r2,-9792
 8203bdc:	003fdf06 	br	8203b5c <_strerror_r+0x274>
 8203be0:	00820974 	movhi	r2,2085
 8203be4:	10b60d04 	addi	r2,r2,-10188
 8203be8:	003fdc06 	br	8203b5c <_strerror_r+0x274>
 8203bec:	00820974 	movhi	r2,2085
 8203bf0:	10b6af04 	addi	r2,r2,-9540
 8203bf4:	003fd906 	br	8203b5c <_strerror_r+0x274>
 8203bf8:	00820974 	movhi	r2,2085
 8203bfc:	10b53204 	addi	r2,r2,-11064
 8203c00:	003fd606 	br	8203b5c <_strerror_r+0x274>
 8203c04:	00820974 	movhi	r2,2085
 8203c08:	10b52404 	addi	r2,r2,-11120
 8203c0c:	003fd306 	br	8203b5c <_strerror_r+0x274>
 8203c10:	00820974 	movhi	r2,2085
 8203c14:	10b56604 	addi	r2,r2,-10856
 8203c18:	003fd006 	br	8203b5c <_strerror_r+0x274>
 8203c1c:	00820974 	movhi	r2,2085
 8203c20:	10b5a604 	addi	r2,r2,-10600
 8203c24:	003fcd06 	br	8203b5c <_strerror_r+0x274>
 8203c28:	00820974 	movhi	r2,2085
 8203c2c:	10b56204 	addi	r2,r2,-10872
 8203c30:	003fca06 	br	8203b5c <_strerror_r+0x274>
 8203c34:	00820974 	movhi	r2,2085
 8203c38:	10b6b404 	addi	r2,r2,-9520
 8203c3c:	003fc706 	br	8203b5c <_strerror_r+0x274>
 8203c40:	00820974 	movhi	r2,2085
 8203c44:	10b57704 	addi	r2,r2,-10788
 8203c48:	003fc406 	br	8203b5c <_strerror_r+0x274>
 8203c4c:	00820974 	movhi	r2,2085
 8203c50:	10b5ec04 	addi	r2,r2,-10320
 8203c54:	003fc106 	br	8203b5c <_strerror_r+0x274>
 8203c58:	00820974 	movhi	r2,2085
 8203c5c:	10b67604 	addi	r2,r2,-9768
 8203c60:	003fbe06 	br	8203b5c <_strerror_r+0x274>
 8203c64:	00820974 	movhi	r2,2085
 8203c68:	10b66a04 	addi	r2,r2,-9816
 8203c6c:	003fbb06 	br	8203b5c <_strerror_r+0x274>
 8203c70:	00820974 	movhi	r2,2085
 8203c74:	10b65e04 	addi	r2,r2,-9864
 8203c78:	003fb806 	br	8203b5c <_strerror_r+0x274>
 8203c7c:	00820974 	movhi	r2,2085
 8203c80:	10b65804 	addi	r2,r2,-9888
 8203c84:	003fb506 	br	8203b5c <_strerror_r+0x274>
 8203c88:	00820974 	movhi	r2,2085
 8203c8c:	10b65004 	addi	r2,r2,-9920
 8203c90:	003fb206 	br	8203b5c <_strerror_r+0x274>
 8203c94:	00820974 	movhi	r2,2085
 8203c98:	10b64804 	addi	r2,r2,-9952
 8203c9c:	003faf06 	br	8203b5c <_strerror_r+0x274>
 8203ca0:	00820974 	movhi	r2,2085
 8203ca4:	10b63c04 	addi	r2,r2,-10000
 8203ca8:	003fac06 	br	8203b5c <_strerror_r+0x274>
 8203cac:	00820974 	movhi	r2,2085
 8203cb0:	10b63304 	addi	r2,r2,-10036
 8203cb4:	003fa906 	br	8203b5c <_strerror_r+0x274>
 8203cb8:	00820974 	movhi	r2,2085
 8203cbc:	10b66304 	addi	r2,r2,-9844
 8203cc0:	003fa606 	br	8203b5c <_strerror_r+0x274>
 8203cc4:	00820974 	movhi	r2,2085
 8203cc8:	10b69c04 	addi	r2,r2,-9616
 8203ccc:	003fa306 	br	8203b5c <_strerror_r+0x274>
 8203cd0:	00820974 	movhi	r2,2085
 8203cd4:	10b62d04 	addi	r2,r2,-10060
 8203cd8:	003fa006 	br	8203b5c <_strerror_r+0x274>
 8203cdc:	00820974 	movhi	r2,2085
 8203ce0:	10b62604 	addi	r2,r2,-10088
 8203ce4:	003f9d06 	br	8203b5c <_strerror_r+0x274>
 8203ce8:	00820974 	movhi	r2,2085
 8203cec:	10b62104 	addi	r2,r2,-10108
 8203cf0:	003f9a06 	br	8203b5c <_strerror_r+0x274>
 8203cf4:	00820974 	movhi	r2,2085
 8203cf8:	10b61a04 	addi	r2,r2,-10136
 8203cfc:	003f9706 	br	8203b5c <_strerror_r+0x274>
 8203d00:	00820974 	movhi	r2,2085
 8203d04:	10b61704 	addi	r2,r2,-10148
 8203d08:	003f9406 	br	8203b5c <_strerror_r+0x274>
 8203d0c:	00820974 	movhi	r2,2085
 8203d10:	10b61204 	addi	r2,r2,-10168
 8203d14:	003f9106 	br	8203b5c <_strerror_r+0x274>
 8203d18:	00820974 	movhi	r2,2085
 8203d1c:	10b60904 	addi	r2,r2,-10204
 8203d20:	003f8e06 	br	8203b5c <_strerror_r+0x274>
 8203d24:	00820974 	movhi	r2,2085
 8203d28:	10b60304 	addi	r2,r2,-10228
 8203d2c:	003f8b06 	br	8203b5c <_strerror_r+0x274>
 8203d30:	00820974 	movhi	r2,2085
 8203d34:	10b5fe04 	addi	r2,r2,-10248
 8203d38:	003f8806 	br	8203b5c <_strerror_r+0x274>
 8203d3c:	00820974 	movhi	r2,2085
 8203d40:	10b5f804 	addi	r2,r2,-10272
 8203d44:	003f8506 	br	8203b5c <_strerror_r+0x274>
 8203d48:	00820974 	movhi	r2,2085
 8203d4c:	10b63a04 	addi	r2,r2,-10008
 8203d50:	003f8206 	br	8203b5c <_strerror_r+0x274>
 8203d54:	00820974 	movhi	r2,2085
 8203d58:	10b5f404 	addi	r2,r2,-10288
 8203d5c:	003f7f06 	br	8203b5c <_strerror_r+0x274>
 8203d60:	00820974 	movhi	r2,2085
 8203d64:	10b5f204 	addi	r2,r2,-10296
 8203d68:	003f7c06 	br	8203b5c <_strerror_r+0x274>
 8203d6c:	00820974 	movhi	r2,2085
 8203d70:	10b5e904 	addi	r2,r2,-10332
 8203d74:	003f7906 	br	8203b5c <_strerror_r+0x274>
 8203d78:	00820974 	movhi	r2,2085
 8203d7c:	10b5de04 	addi	r2,r2,-10376
 8203d80:	003f7606 	br	8203b5c <_strerror_r+0x274>
 8203d84:	00820974 	movhi	r2,2085
 8203d88:	10b5d704 	addi	r2,r2,-10404
 8203d8c:	003f7306 	br	8203b5c <_strerror_r+0x274>
 8203d90:	00820974 	movhi	r2,2085
 8203d94:	10b5d204 	addi	r2,r2,-10424
 8203d98:	003f7006 	br	8203b5c <_strerror_r+0x274>
 8203d9c:	00820974 	movhi	r2,2085
 8203da0:	10b5c604 	addi	r2,r2,-10472
 8203da4:	003f6d06 	br	8203b5c <_strerror_r+0x274>
 8203da8:	00820974 	movhi	r2,2085
 8203dac:	10b5c304 	addi	r2,r2,-10484
 8203db0:	003f6a06 	br	8203b5c <_strerror_r+0x274>
 8203db4:	00820974 	movhi	r2,2085
 8203db8:	10b5bf04 	addi	r2,r2,-10500
 8203dbc:	003f6706 	br	8203b5c <_strerror_r+0x274>
 8203dc0:	00820974 	movhi	r2,2085
 8203dc4:	10b5b904 	addi	r2,r2,-10524
 8203dc8:	003f6406 	br	8203b5c <_strerror_r+0x274>
 8203dcc:	00820974 	movhi	r2,2085
 8203dd0:	10b5b504 	addi	r2,r2,-10540
 8203dd4:	003f6106 	br	8203b5c <_strerror_r+0x274>
 8203dd8:	00820974 	movhi	r2,2085
 8203ddc:	10b5ab04 	addi	r2,r2,-10580
 8203de0:	003f5e06 	br	8203b5c <_strerror_r+0x274>
 8203de4:	00820974 	movhi	r2,2085
 8203de8:	10b5a204 	addi	r2,r2,-10616
 8203dec:	003f5b06 	br	8203b5c <_strerror_r+0x274>
 8203df0:	00820974 	movhi	r2,2085
 8203df4:	10b59e04 	addi	r2,r2,-10632
 8203df8:	003f5806 	br	8203b5c <_strerror_r+0x274>
 8203dfc:	00820974 	movhi	r2,2085
 8203e00:	10b59804 	addi	r2,r2,-10656
 8203e04:	003f5506 	br	8203b5c <_strerror_r+0x274>
 8203e08:	00820974 	movhi	r2,2085
 8203e0c:	10b59004 	addi	r2,r2,-10688
 8203e10:	003f5206 	br	8203b5c <_strerror_r+0x274>
 8203e14:	00820974 	movhi	r2,2085
 8203e18:	10b58804 	addi	r2,r2,-10720
 8203e1c:	003f4f06 	br	8203b5c <_strerror_r+0x274>
 8203e20:	00820974 	movhi	r2,2085
 8203e24:	10b57204 	addi	r2,r2,-10808
 8203e28:	003f4c06 	br	8203b5c <_strerror_r+0x274>
 8203e2c:	00820974 	movhi	r2,2085
 8203e30:	10b56e04 	addi	r2,r2,-10824
 8203e34:	003f4906 	br	8203b5c <_strerror_r+0x274>
 8203e38:	00820974 	movhi	r2,2085
 8203e3c:	10b55e04 	addi	r2,r2,-10888
 8203e40:	003f4606 	br	8203b5c <_strerror_r+0x274>
 8203e44:	00820974 	movhi	r2,2085
 8203e48:	10b55a04 	addi	r2,r2,-10904
 8203e4c:	003f4306 	br	8203b5c <_strerror_r+0x274>
 8203e50:	00820974 	movhi	r2,2085
 8203e54:	10b55504 	addi	r2,r2,-10924
 8203e58:	003f4006 	br	8203b5c <_strerror_r+0x274>
 8203e5c:	00820974 	movhi	r2,2085
 8203e60:	10b55204 	addi	r2,r2,-10936
 8203e64:	003f3d06 	br	8203b5c <_strerror_r+0x274>
 8203e68:	00820974 	movhi	r2,2085
 8203e6c:	10b54c04 	addi	r2,r2,-10960
 8203e70:	003f3a06 	br	8203b5c <_strerror_r+0x274>
 8203e74:	00820974 	movhi	r2,2085
 8203e78:	10b54904 	addi	r2,r2,-10972
 8203e7c:	003f3706 	br	8203b5c <_strerror_r+0x274>
 8203e80:	00820974 	movhi	r2,2085
 8203e84:	10b54404 	addi	r2,r2,-10992
 8203e88:	003f3406 	br	8203b5c <_strerror_r+0x274>
 8203e8c:	00820974 	movhi	r2,2085
 8203e90:	10b53f04 	addi	r2,r2,-11012
 8203e94:	003f3106 	br	8203b5c <_strerror_r+0x274>
 8203e98:	00820974 	movhi	r2,2085
 8203e9c:	10b53a04 	addi	r2,r2,-11032
 8203ea0:	003f2e06 	br	8203b5c <_strerror_r+0x274>
 8203ea4:	00820974 	movhi	r2,2085
 8203ea8:	10b52f04 	addi	r2,r2,-11076
 8203eac:	003f2b06 	br	8203b5c <_strerror_r+0x274>
 8203eb0:	00820974 	movhi	r2,2085
 8203eb4:	10b52b04 	addi	r2,r2,-11092
 8203eb8:	003f2806 	br	8203b5c <_strerror_r+0x274>
 8203ebc:	00820974 	movhi	r2,2085
 8203ec0:	10b51f04 	addi	r2,r2,-11140
 8203ec4:	003f2506 	br	8203b5c <_strerror_r+0x274>
 8203ec8:	00820974 	movhi	r2,2085
 8203ecc:	10b51a04 	addi	r2,r2,-11160
 8203ed0:	003f2206 	br	8203b5c <_strerror_r+0x274>
 8203ed4:	00820974 	movhi	r2,2085
 8203ed8:	10b51304 	addi	r2,r2,-11188
 8203edc:	003f1f06 	br	8203b5c <_strerror_r+0x274>
 8203ee0:	00820974 	movhi	r2,2085
 8203ee4:	10b51004 	addi	r2,r2,-11200
 8203ee8:	003f1c06 	br	8203b5c <_strerror_r+0x274>
 8203eec:	00820974 	movhi	r2,2085
 8203ef0:	10b50a04 	addi	r2,r2,-11224
 8203ef4:	003f1906 	br	8203b5c <_strerror_r+0x274>
 8203ef8:	00820974 	movhi	r2,2085
 8203efc:	10b50604 	addi	r2,r2,-11240
 8203f00:	003f1606 	br	8203b5c <_strerror_r+0x274>
 8203f04:	00820974 	movhi	r2,2085
 8203f08:	10b4ff04 	addi	r2,r2,-11268
 8203f0c:	003f1306 	br	8203b5c <_strerror_r+0x274>
 8203f10:	00820974 	movhi	r2,2085
 8203f14:	10b4fc04 	addi	r2,r2,-11280
 8203f18:	003f1006 	br	8203b5c <_strerror_r+0x274>
 8203f1c:	38000726 	beq	r7,zero,8203f3c <_strerror_r+0x654>
 8203f20:	380d883a 	mov	r6,r7
 8203f24:	1809883a 	mov	r4,r3
 8203f28:	8206a340 	call	8206a34 <_user_strerror>
 8203f2c:	103f0b1e 	bne	r2,zero,8203b5c <_strerror_r+0x274>
 8203f30:	00820974 	movhi	r2,2085
 8203f34:	10b6c204 	addi	r2,r2,-9464
 8203f38:	003f0806 	br	8203b5c <_strerror_r+0x274>
 8203f3c:	200f883a 	mov	r7,r4
 8203f40:	003ff706 	br	8203f20 <_strerror_r+0x638>

08203f44 <strerror>:
 8203f44:	00820974 	movhi	r2,2085
 8203f48:	108f9904 	addi	r2,r2,15972
 8203f4c:	200b883a 	mov	r5,r4
 8203f50:	11000017 	ldw	r4,0(r2)
 8203f54:	000f883a 	mov	r7,zero
 8203f58:	000d883a 	mov	r6,zero
 8203f5c:	82038e81 	jmpi	82038e8 <_strerror_r>

08203f60 <strlen>:
 8203f60:	208000cc 	andi	r2,r4,3
 8203f64:	10002026 	beq	r2,zero,8203fe8 <strlen+0x88>
 8203f68:	20800007 	ldb	r2,0(r4)
 8203f6c:	10002026 	beq	r2,zero,8203ff0 <strlen+0x90>
 8203f70:	2005883a 	mov	r2,r4
 8203f74:	00000206 	br	8203f80 <strlen+0x20>
 8203f78:	10c00007 	ldb	r3,0(r2)
 8203f7c:	18001826 	beq	r3,zero,8203fe0 <strlen+0x80>
 8203f80:	10800044 	addi	r2,r2,1
 8203f84:	10c000cc 	andi	r3,r2,3
 8203f88:	183ffb1e 	bne	r3,zero,8203f78 <strlen+0x18>
 8203f8c:	10c00017 	ldw	r3,0(r2)
 8203f90:	01ffbff4 	movhi	r7,65279
 8203f94:	39ffbfc4 	addi	r7,r7,-257
 8203f98:	00ca303a 	nor	r5,zero,r3
 8203f9c:	01a02074 	movhi	r6,32897
 8203fa0:	19c7883a 	add	r3,r3,r7
 8203fa4:	31a02004 	addi	r6,r6,-32640
 8203fa8:	1946703a 	and	r3,r3,r5
 8203fac:	1986703a 	and	r3,r3,r6
 8203fb0:	1800091e 	bne	r3,zero,8203fd8 <strlen+0x78>
 8203fb4:	10800104 	addi	r2,r2,4
 8203fb8:	10c00017 	ldw	r3,0(r2)
 8203fbc:	19cb883a 	add	r5,r3,r7
 8203fc0:	00c6303a 	nor	r3,zero,r3
 8203fc4:	28c6703a 	and	r3,r5,r3
 8203fc8:	1986703a 	and	r3,r3,r6
 8203fcc:	183ff926 	beq	r3,zero,8203fb4 <strlen+0x54>
 8203fd0:	00000106 	br	8203fd8 <strlen+0x78>
 8203fd4:	10800044 	addi	r2,r2,1
 8203fd8:	10c00007 	ldb	r3,0(r2)
 8203fdc:	183ffd1e 	bne	r3,zero,8203fd4 <strlen+0x74>
 8203fe0:	1105c83a 	sub	r2,r2,r4
 8203fe4:	f800283a 	ret
 8203fe8:	2005883a 	mov	r2,r4
 8203fec:	003fe706 	br	8203f8c <strlen+0x2c>
 8203ff0:	0005883a 	mov	r2,zero
 8203ff4:	f800283a 	ret

08203ff8 <critical_factorization>:
 8203ff8:	02c00044 	movi	r11,1
 8203ffc:	5811883a 	mov	r8,r11
 8204000:	0013883a 	mov	r9,zero
 8204004:	00bfffc4 	movi	r2,-1
 8204008:	2087883a 	add	r3,r4,r2
 820400c:	1a0f883a 	add	r7,r3,r8
 8204010:	4a07883a 	add	r3,r9,r8
 8204014:	20d5883a 	add	r10,r4,r3
 8204018:	1940102e 	bgeu	r3,r5,820405c <critical_factorization+0x64>
 820401c:	52800003 	ldbu	r10,0(r10)
 8204020:	39c00003 	ldbu	r7,0(r7)
 8204024:	51c0042e 	bgeu	r10,r7,8204038 <critical_factorization+0x40>
 8204028:	1897c83a 	sub	r11,r3,r2
 820402c:	1813883a 	mov	r9,r3
 8204030:	02000044 	movi	r8,1
 8204034:	003ff406 	br	8204008 <critical_factorization+0x10>
 8204038:	51c00526 	beq	r10,r7,8204050 <critical_factorization+0x58>
 820403c:	02c00044 	movi	r11,1
 8204040:	4805883a 	mov	r2,r9
 8204044:	5811883a 	mov	r8,r11
 8204048:	4ad3883a 	add	r9,r9,r11
 820404c:	003fee06 	br	8204008 <critical_factorization+0x10>
 8204050:	42c02226 	beq	r8,r11,82040dc <critical_factorization+0xe4>
 8204054:	42000044 	addi	r8,r8,1
 8204058:	003feb06 	br	8204008 <critical_factorization+0x10>
 820405c:	03000044 	movi	r12,1
 8204060:	32c00015 	stw	r11,0(r6)
 8204064:	6011883a 	mov	r8,r12
 8204068:	0013883a 	mov	r9,zero
 820406c:	02ffffc4 	movi	r11,-1
 8204070:	22c7883a 	add	r3,r4,r11
 8204074:	1a0f883a 	add	r7,r3,r8
 8204078:	4a07883a 	add	r3,r9,r8
 820407c:	20d5883a 	add	r10,r4,r3
 8204080:	1940102e 	bgeu	r3,r5,82040c4 <critical_factorization+0xcc>
 8204084:	52800003 	ldbu	r10,0(r10)
 8204088:	39c00003 	ldbu	r7,0(r7)
 820408c:	3a80042e 	bgeu	r7,r10,82040a0 <critical_factorization+0xa8>
 8204090:	1ad9c83a 	sub	r12,r3,r11
 8204094:	1813883a 	mov	r9,r3
 8204098:	02000044 	movi	r8,1
 820409c:	003ff406 	br	8204070 <critical_factorization+0x78>
 82040a0:	51c00526 	beq	r10,r7,82040b8 <critical_factorization+0xc0>
 82040a4:	03000044 	movi	r12,1
 82040a8:	4817883a 	mov	r11,r9
 82040ac:	6011883a 	mov	r8,r12
 82040b0:	4b13883a 	add	r9,r9,r12
 82040b4:	003fee06 	br	8204070 <critical_factorization+0x78>
 82040b8:	43000c26 	beq	r8,r12,82040ec <critical_factorization+0xf4>
 82040bc:	42000044 	addi	r8,r8,1
 82040c0:	003feb06 	br	8204070 <critical_factorization+0x78>
 82040c4:	5ac00044 	addi	r11,r11,1
 82040c8:	10800044 	addi	r2,r2,1
 82040cc:	58800236 	bltu	r11,r2,82040d8 <critical_factorization+0xe0>
 82040d0:	33000015 	stw	r12,0(r6)
 82040d4:	5805883a 	mov	r2,r11
 82040d8:	f800283a 	ret
 82040dc:	4017883a 	mov	r11,r8
 82040e0:	1813883a 	mov	r9,r3
 82040e4:	02000044 	movi	r8,1
 82040e8:	003fc706 	br	8204008 <critical_factorization+0x10>
 82040ec:	4019883a 	mov	r12,r8
 82040f0:	1813883a 	mov	r9,r3
 82040f4:	02000044 	movi	r8,1
 82040f8:	003fdd06 	br	8204070 <critical_factorization+0x78>

082040fc <two_way_long_needle>:
 82040fc:	defef104 	addi	sp,sp,-1084
 8204100:	dc810715 	stw	r18,1052(sp)
 8204104:	dc410615 	stw	r17,1048(sp)
 8204108:	dc810004 	addi	r18,sp,1024
 820410c:	3023883a 	mov	r17,r6
 8204110:	2807883a 	mov	r3,r5
 8204114:	ddc10c15 	stw	r23,1072(sp)
 8204118:	900d883a 	mov	r6,r18
 820411c:	202f883a 	mov	r23,r4
 8204120:	380b883a 	mov	r5,r7
 8204124:	8809883a 	mov	r4,r17
 8204128:	dd810b15 	stw	r22,1068(sp)
 820412c:	dc010515 	stw	r16,1044(sp)
 8204130:	d8c10415 	stw	r3,1040(sp)
 8204134:	dfc10e15 	stw	ra,1080(sp)
 8204138:	df010d15 	stw	fp,1076(sp)
 820413c:	dd410a15 	stw	r21,1064(sp)
 8204140:	dd010915 	stw	r20,1060(sp)
 8204144:	dcc10815 	stw	r19,1056(sp)
 8204148:	382d883a 	mov	r22,r7
 820414c:	8203ff80 	call	8203ff8 <critical_factorization>
 8204150:	d8c10417 	ldw	r3,1040(sp)
 8204154:	1021883a 	mov	r16,r2
 8204158:	d805883a 	mov	r2,sp
 820415c:	15800015 	stw	r22,0(r2)
 8204160:	10800104 	addi	r2,r2,4
 8204164:	90bffd1e 	bne	r18,r2,820415c <two_way_long_needle+0x60>
 8204168:	b0000b26 	beq	r22,zero,8204198 <two_way_long_needle+0x9c>
 820416c:	b17fffc4 	addi	r5,r22,-1
 8204170:	8809883a 	mov	r4,r17
 8204174:	8d8d883a 	add	r6,r17,r22
 8204178:	20800003 	ldbu	r2,0(r4)
 820417c:	21000044 	addi	r4,r4,1
 8204180:	1085883a 	add	r2,r2,r2
 8204184:	1085883a 	add	r2,r2,r2
 8204188:	d885883a 	add	r2,sp,r2
 820418c:	11400015 	stw	r5,0(r2)
 8204190:	297fffc4 	addi	r5,r5,-1
 8204194:	21bff81e 	bne	r4,r6,8204178 <two_way_long_needle+0x7c>
 8204198:	d9410017 	ldw	r5,1024(sp)
 820419c:	800d883a 	mov	r6,r16
 82041a0:	8809883a 	mov	r4,r17
 82041a4:	894b883a 	add	r5,r17,r5
 82041a8:	d8c10415 	stw	r3,1040(sp)
 82041ac:	820c5dc0 	call	820c5dc <memcmp>
 82041b0:	d8c10417 	ldw	r3,1040(sp)
 82041b4:	10006a1e 	bne	r2,zero,8204360 <two_way_long_needle+0x264>
 82041b8:	84bfffc4 	addi	r18,r16,-1
 82041bc:	8c85883a 	add	r2,r17,r18
 82041c0:	d8810215 	stw	r2,1032(sp)
 82041c4:	00800044 	movi	r2,1
 82041c8:	813fff84 	addi	r4,r16,-2
 82041cc:	1405c83a 	sub	r2,r2,r16
 82041d0:	0029883a 	mov	r20,zero
 82041d4:	0039883a 	mov	fp,zero
 82041d8:	b57fffc4 	addi	r21,r22,-1
 82041dc:	d9010115 	stw	r4,1028(sp)
 82041e0:	d8810315 	stw	r2,1036(sp)
 82041e4:	00000706 	br	8204204 <two_way_long_needle+0x108>
 82041e8:	a0000326 	beq	r20,zero,82041f8 <two_way_long_needle+0xfc>
 82041ec:	d8c10017 	ldw	r3,1024(sp)
 82041f0:	10c0012e 	bgeu	r2,r3,82041f8 <two_way_long_needle+0xfc>
 82041f4:	b0c5c83a 	sub	r2,r22,r3
 82041f8:	e0b9883a 	add	fp,fp,r2
 82041fc:	0029883a 	mov	r20,zero
 8204200:	9807883a 	mov	r3,r19
 8204204:	e5a7883a 	add	r19,fp,r22
 8204208:	98cdc83a 	sub	r6,r19,r3
 820420c:	000b883a 	mov	r5,zero
 8204210:	b8c9883a 	add	r4,r23,r3
 8204214:	820c4f80 	call	820c4f8 <memchr>
 8204218:	1000441e 	bne	r2,zero,820432c <two_way_long_needle+0x230>
 820421c:	98004326 	beq	r19,zero,820432c <two_way_long_needle+0x230>
 8204220:	bcc5883a 	add	r2,r23,r19
 8204224:	10bfffc3 	ldbu	r2,-1(r2)
 8204228:	1085883a 	add	r2,r2,r2
 820422c:	1085883a 	add	r2,r2,r2
 8204230:	d885883a 	add	r2,sp,r2
 8204234:	10800017 	ldw	r2,0(r2)
 8204238:	103feb1e 	bne	r2,zero,82041e8 <two_way_long_needle+0xec>
 820423c:	a015883a 	mov	r10,r20
 8204240:	a400012e 	bgeu	r20,r16,8204248 <two_way_long_needle+0x14c>
 8204244:	8015883a 	mov	r10,r16
 8204248:	5540152e 	bgeu	r10,r21,82042a0 <two_way_long_needle+0x1a4>
 820424c:	bf05883a 	add	r2,r23,fp
 8204250:	8a87883a 	add	r3,r17,r10
 8204254:	1285883a 	add	r2,r2,r10
 8204258:	18c00003 	ldbu	r3,0(r3)
 820425c:	10800003 	ldbu	r2,0(r2)
 8204260:	18802d1e 	bne	r3,r2,8204318 <two_way_long_needle+0x21c>
 8204264:	e1400044 	addi	r5,fp,1
 8204268:	50800044 	addi	r2,r10,1
 820426c:	2a8b883a 	add	r5,r5,r10
 8204270:	888d883a 	add	r6,r17,r2
 8204274:	b94b883a 	add	r5,r23,r5
 8204278:	00000706 	br	8204298 <two_way_long_needle+0x19c>
 820427c:	31000003 	ldbu	r4,0(r6)
 8204280:	28c00003 	ldbu	r3,0(r5)
 8204284:	31800044 	addi	r6,r6,1
 8204288:	21003fcc 	andi	r4,r4,255
 820428c:	29400044 	addi	r5,r5,1
 8204290:	20c0211e 	bne	r4,r3,8204318 <two_way_long_needle+0x21c>
 8204294:	10800044 	addi	r2,r2,1
 8204298:	1015883a 	mov	r10,r2
 820429c:	157ff736 	bltu	r2,r21,820427c <two_way_long_needle+0x180>
 82042a0:	900d883a 	mov	r6,r18
 82042a4:	a4007d2e 	bgeu	r20,r16,820449c <two_way_long_needle+0x3a0>
 82042a8:	d9410217 	ldw	r5,1032(sp)
 82042ac:	bf05883a 	add	r2,r23,fp
 82042b0:	1485883a 	add	r2,r2,r18
 82042b4:	28c00003 	ldbu	r3,0(r5)
 82042b8:	10800003 	ldbu	r2,0(r2)
 82042bc:	1880771e 	bne	r3,r2,820449c <two_way_long_needle+0x3a0>
 82042c0:	d8c10117 	ldw	r3,1028(sp)
 82042c4:	a2ffffc4 	addi	r11,r20,-1
 82042c8:	8ad7883a 	add	r11,r17,r11
 82042cc:	e0cb883a 	add	r5,fp,r3
 82042d0:	88c5883a 	add	r2,r17,r3
 82042d4:	b94b883a 	add	r5,r23,r5
 82042d8:	00000706 	br	82042f8 <two_way_long_needle+0x1fc>
 82042dc:	11000003 	ldbu	r4,0(r2)
 82042e0:	28c00003 	ldbu	r3,0(r5)
 82042e4:	10bfffc4 	addi	r2,r2,-1
 82042e8:	21003fcc 	andi	r4,r4,255
 82042ec:	297fffc4 	addi	r5,r5,-1
 82042f0:	20c0031e 	bne	r4,r3,8204300 <two_way_long_needle+0x204>
 82042f4:	500d883a 	mov	r6,r10
 82042f8:	32bfffc4 	addi	r10,r6,-1
 82042fc:	58bff71e 	bne	r11,r2,82042dc <two_way_long_needle+0x1e0>
 8204300:	a2400044 	addi	r9,r20,1
 8204304:	32406736 	bltu	r6,r9,82044a4 <two_way_long_needle+0x3a8>
 8204308:	da410017 	ldw	r9,1024(sp)
 820430c:	e279883a 	add	fp,fp,r9
 8204310:	b269c83a 	sub	r20,r22,r9
 8204314:	003fba06 	br	8204200 <two_way_long_needle+0x104>
 8204318:	d8c10317 	ldw	r3,1036(sp)
 820431c:	0029883a 	mov	r20,zero
 8204320:	1f39883a 	add	fp,r3,fp
 8204324:	e2b9883a 	add	fp,fp,r10
 8204328:	003fb506 	br	8204200 <two_way_long_needle+0x104>
 820432c:	0005883a 	mov	r2,zero
 8204330:	dfc10e17 	ldw	ra,1080(sp)
 8204334:	df010d17 	ldw	fp,1076(sp)
 8204338:	ddc10c17 	ldw	r23,1072(sp)
 820433c:	dd810b17 	ldw	r22,1068(sp)
 8204340:	dd410a17 	ldw	r21,1064(sp)
 8204344:	dd010917 	ldw	r20,1060(sp)
 8204348:	dcc10817 	ldw	r19,1056(sp)
 820434c:	dc810717 	ldw	r18,1052(sp)
 8204350:	dc410617 	ldw	r17,1048(sp)
 8204354:	dc010517 	ldw	r16,1044(sp)
 8204358:	dec10f04 	addi	sp,sp,1084
 820435c:	f800283a 	ret
 8204360:	b405c83a 	sub	r2,r22,r16
 8204364:	14004b36 	bltu	r2,r16,8204494 <two_way_long_needle+0x398>
 8204368:	10800044 	addi	r2,r2,1
 820436c:	84bfffc4 	addi	r18,r16,-1
 8204370:	d8810015 	stw	r2,1024(sp)
 8204374:	00800044 	movi	r2,1
 8204378:	8c89883a 	add	r4,r17,r18
 820437c:	817fff84 	addi	r5,r16,-2
 8204380:	1405c83a 	sub	r2,r2,r16
 8204384:	0029883a 	mov	r20,zero
 8204388:	b73fffc4 	addi	fp,r22,-1
 820438c:	d9010215 	stw	r4,1032(sp)
 8204390:	d9410115 	stw	r5,1028(sp)
 8204394:	8d7fffc4 	addi	r21,r17,-1
 8204398:	d8810315 	stw	r2,1036(sp)
 820439c:	a5a7883a 	add	r19,r20,r22
 82043a0:	98cdc83a 	sub	r6,r19,r3
 82043a4:	000b883a 	mov	r5,zero
 82043a8:	b8c9883a 	add	r4,r23,r3
 82043ac:	820c4f80 	call	820c4f8 <memchr>
 82043b0:	103fde1e 	bne	r2,zero,820432c <two_way_long_needle+0x230>
 82043b4:	983fdd26 	beq	r19,zero,820432c <two_way_long_needle+0x230>
 82043b8:	bcc5883a 	add	r2,r23,r19
 82043bc:	10bfffc3 	ldbu	r2,-1(r2)
 82043c0:	1085883a 	add	r2,r2,r2
 82043c4:	1085883a 	add	r2,r2,r2
 82043c8:	d885883a 	add	r2,sp,r2
 82043cc:	10800017 	ldw	r2,0(r2)
 82043d0:	1000291e 	bne	r2,zero,8204478 <two_way_long_needle+0x37c>
 82043d4:	bd05883a 	add	r2,r23,r20
 82043d8:	8700142e 	bgeu	r16,fp,820442c <two_way_long_needle+0x330>
 82043dc:	8c07883a 	add	r3,r17,r16
 82043e0:	140b883a 	add	r5,r2,r16
 82043e4:	19000003 	ldbu	r4,0(r3)
 82043e8:	28c00003 	ldbu	r3,0(r5)
 82043ec:	800d883a 	mov	r6,r16
 82043f0:	20c0241e 	bne	r4,r3,8204484 <two_way_long_needle+0x388>
 82043f4:	81400044 	addi	r5,r16,1
 82043f8:	a155883a 	add	r10,r20,r5
 82043fc:	ba95883a 	add	r10,r23,r10
 8204400:	894b883a 	add	r5,r17,r5
 8204404:	800d883a 	mov	r6,r16
 8204408:	00000606 	br	8204424 <two_way_long_needle+0x328>
 820440c:	29000003 	ldbu	r4,0(r5)
 8204410:	50c00003 	ldbu	r3,0(r10)
 8204414:	29400044 	addi	r5,r5,1
 8204418:	21003fcc 	andi	r4,r4,255
 820441c:	52800044 	addi	r10,r10,1
 8204420:	20c0181e 	bne	r4,r3,8204484 <two_way_long_needle+0x388>
 8204424:	31800044 	addi	r6,r6,1
 8204428:	373ff836 	bltu	r6,fp,820440c <two_way_long_needle+0x310>
 820442c:	00ffffc4 	movi	r3,-1
 8204430:	90ffbf26 	beq	r18,r3,8204330 <two_way_long_needle+0x234>
 8204434:	d9410217 	ldw	r5,1032(sp)
 8204438:	1487883a 	add	r3,r2,r18
 820443c:	18c00003 	ldbu	r3,0(r3)
 8204440:	29000003 	ldbu	r4,0(r5)
 8204444:	20c00b1e 	bne	r4,r3,8204474 <two_way_long_needle+0x378>
 8204448:	d8c10117 	ldw	r3,1028(sp)
 820444c:	a0cd883a 	add	r6,r20,r3
 8204450:	b98d883a 	add	r6,r23,r6
 8204454:	88c7883a 	add	r3,r17,r3
 8204458:	1d7fb526 	beq	r3,r21,8204330 <two_way_long_needle+0x234>
 820445c:	19400003 	ldbu	r5,0(r3)
 8204460:	31000003 	ldbu	r4,0(r6)
 8204464:	18ffffc4 	addi	r3,r3,-1
 8204468:	29403fcc 	andi	r5,r5,255
 820446c:	31bfffc4 	addi	r6,r6,-1
 8204470:	293ff926 	beq	r5,r4,8204458 <two_way_long_needle+0x35c>
 8204474:	d8810017 	ldw	r2,1024(sp)
 8204478:	a0a9883a 	add	r20,r20,r2
 820447c:	9807883a 	mov	r3,r19
 8204480:	003fc606 	br	820439c <two_way_long_needle+0x2a0>
 8204484:	d8c10317 	ldw	r3,1036(sp)
 8204488:	1d11883a 	add	r8,r3,r20
 820448c:	41a9883a 	add	r20,r8,r6
 8204490:	003ffa06 	br	820447c <two_way_long_needle+0x380>
 8204494:	8005883a 	mov	r2,r16
 8204498:	003fb306 	br	8204368 <two_way_long_needle+0x26c>
 820449c:	800d883a 	mov	r6,r16
 82044a0:	003f9706 	br	8204300 <two_way_long_needle+0x204>
 82044a4:	bf05883a 	add	r2,r23,fp
 82044a8:	003fa106 	br	8204330 <two_way_long_needle+0x234>

082044ac <strstr>:
 82044ac:	21800007 	ldb	r6,0(r4)
 82044b0:	30009226 	beq	r6,zero,82046fc <strstr+0x250>
 82044b4:	28c00007 	ldb	r3,0(r5)
 82044b8:	18000f26 	beq	r3,zero,82044f8 <strstr+0x4c>
 82044bc:	280f883a 	mov	r7,r5
 82044c0:	2011883a 	mov	r8,r4
 82044c4:	02400044 	movi	r9,1
 82044c8:	00000206 	br	82044d4 <strstr+0x28>
 82044cc:	38c00007 	ldb	r3,0(r7)
 82044d0:	18000826 	beq	r3,zero,82044f4 <strstr+0x48>
 82044d4:	42000044 	addi	r8,r8,1
 82044d8:	1987003a 	cmpeq	r3,r3,r6
 82044dc:	41800007 	ldb	r6,0(r8)
 82044e0:	39c00044 	addi	r7,r7,1
 82044e4:	48d2703a 	and	r9,r9,r3
 82044e8:	303ff81e 	bne	r6,zero,82044cc <strstr+0x20>
 82044ec:	38800007 	ldb	r2,0(r7)
 82044f0:	1000841e 	bne	r2,zero,8204704 <strstr+0x258>
 82044f4:	48000226 	beq	r9,zero,8204500 <strstr+0x54>
 82044f8:	2005883a 	mov	r2,r4
 82044fc:	f800283a 	ret
 8204500:	defff104 	addi	sp,sp,-60
 8204504:	ddc00c15 	stw	r23,48(sp)
 8204508:	dd800b15 	stw	r22,44(sp)
 820450c:	dd400a15 	stw	r21,40(sp)
 8204510:	dc000515 	stw	r16,20(sp)
 8204514:	dfc00e15 	stw	ra,56(sp)
 8204518:	df000d15 	stw	fp,52(sp)
 820451c:	dd000915 	stw	r20,36(sp)
 8204520:	dcc00815 	stw	r19,32(sp)
 8204524:	dc800715 	stw	r18,28(sp)
 8204528:	dc400615 	stw	r17,24(sp)
 820452c:	282d883a 	mov	r22,r5
 8204530:	29400007 	ldb	r5,0(r5)
 8204534:	202b883a 	mov	r21,r4
 8204538:	21000044 	addi	r4,r4,1
 820453c:	3da1c83a 	sub	r16,r7,r22
 8204540:	82037840 	call	8203784 <strchr>
 8204544:	102f883a 	mov	r23,r2
 8204548:	10007526 	beq	r2,zero,8204720 <strstr+0x274>
 820454c:	00c00044 	movi	r3,1
 8204550:	80c00a26 	beq	r16,r3,820457c <strstr+0xd0>
 8204554:	ac09883a 	add	r4,r21,r16
 8204558:	20800136 	bltu	r4,r2,8204560 <strstr+0xb4>
 820455c:	2087c83a 	sub	r3,r4,r2
 8204560:	008007c4 	movi	r2,31
 8204564:	1400112e 	bgeu	r2,r16,82045ac <strstr+0x100>
 8204568:	800f883a 	mov	r7,r16
 820456c:	b00d883a 	mov	r6,r22
 8204570:	180b883a 	mov	r5,r3
 8204574:	b809883a 	mov	r4,r23
 8204578:	82040fc0 	call	82040fc <two_way_long_needle>
 820457c:	dfc00e17 	ldw	ra,56(sp)
 8204580:	df000d17 	ldw	fp,52(sp)
 8204584:	ddc00c17 	ldw	r23,48(sp)
 8204588:	dd800b17 	ldw	r22,44(sp)
 820458c:	dd400a17 	ldw	r21,40(sp)
 8204590:	dd000917 	ldw	r20,36(sp)
 8204594:	dcc00817 	ldw	r19,32(sp)
 8204598:	dc800717 	ldw	r18,28(sp)
 820459c:	dc400617 	ldw	r17,24(sp)
 82045a0:	dc000517 	ldw	r16,20(sp)
 82045a4:	dec00f04 	addi	sp,sp,60
 82045a8:	f800283a 	ret
 82045ac:	d80d883a 	mov	r6,sp
 82045b0:	800b883a 	mov	r5,r16
 82045b4:	b009883a 	mov	r4,r22
 82045b8:	d8c00415 	stw	r3,16(sp)
 82045bc:	8203ff80 	call	8203ff8 <critical_factorization>
 82045c0:	d9400017 	ldw	r5,0(sp)
 82045c4:	100d883a 	mov	r6,r2
 82045c8:	b009883a 	mov	r4,r22
 82045cc:	b14b883a 	add	r5,r22,r5
 82045d0:	1039883a 	mov	fp,r2
 82045d4:	820c5dc0 	call	820c5dc <memcmp>
 82045d8:	d8c00417 	ldw	r3,16(sp)
 82045dc:	1000521e 	bne	r2,zero,8204728 <strstr+0x27c>
 82045e0:	e47fffc4 	addi	r17,fp,-1
 82045e4:	04c00044 	movi	r19,1
 82045e8:	b445883a 	add	r2,r22,r17
 82045ec:	9f27c83a 	sub	r19,r19,fp
 82045f0:	0029883a 	mov	r20,zero
 82045f4:	002b883a 	mov	r21,zero
 82045f8:	d8800215 	stw	r2,8(sp)
 82045fc:	e4bfff84 	addi	r18,fp,-2
 8204600:	dcc00115 	stw	r19,4(sp)
 8204604:	8567883a 	add	r19,r16,r21
 8204608:	98cdc83a 	sub	r6,r19,r3
 820460c:	000b883a 	mov	r5,zero
 8204610:	b8c9883a 	add	r4,r23,r3
 8204614:	820c4f80 	call	820c4f8 <memchr>
 8204618:	1000411e 	bne	r2,zero,8204720 <strstr+0x274>
 820461c:	98004026 	beq	r19,zero,8204720 <strstr+0x274>
 8204620:	e00b883a 	mov	r5,fp
 8204624:	e500012e 	bgeu	fp,r20,820462c <strstr+0x180>
 8204628:	a00b883a 	mov	r5,r20
 820462c:	2c00152e 	bgeu	r5,r16,8204684 <strstr+0x1d8>
 8204630:	b947883a 	add	r3,r23,r5
 8204634:	1d47883a 	add	r3,r3,r21
 8204638:	b145883a 	add	r2,r22,r5
 820463c:	18c00003 	ldbu	r3,0(r3)
 8204640:	10800003 	ldbu	r2,0(r2)
 8204644:	1880311e 	bne	r3,r2,820470c <strstr+0x260>
 8204648:	a8800044 	addi	r2,r21,1
 820464c:	28c00044 	addi	r3,r5,1
 8204650:	1145883a 	add	r2,r2,r5
 8204654:	b0c9883a 	add	r4,r22,r3
 8204658:	b885883a 	add	r2,r23,r2
 820465c:	00000706 	br	820467c <strstr+0x1d0>
 8204660:	21c00003 	ldbu	r7,0(r4)
 8204664:	11800003 	ldbu	r6,0(r2)
 8204668:	21000044 	addi	r4,r4,1
 820466c:	39c03fcc 	andi	r7,r7,255
 8204670:	10800044 	addi	r2,r2,1
 8204674:	3980251e 	bne	r7,r6,820470c <strstr+0x260>
 8204678:	18c00044 	addi	r3,r3,1
 820467c:	180b883a 	mov	r5,r3
 8204680:	1c3ff736 	bltu	r3,r16,8204660 <strstr+0x1b4>
 8204684:	880d883a 	mov	r6,r17
 8204688:	a700702e 	bgeu	r20,fp,820484c <strstr+0x3a0>
 820468c:	d9000217 	ldw	r4,8(sp)
 8204690:	bd45883a 	add	r2,r23,r21
 8204694:	1445883a 	add	r2,r2,r17
 8204698:	20c00003 	ldbu	r3,0(r4)
 820469c:	10800003 	ldbu	r2,0(r2)
 82046a0:	18806a1e 	bne	r3,r2,820484c <strstr+0x3a0>
 82046a4:	954b883a 	add	r5,r18,r21
 82046a8:	a2bfffc4 	addi	r10,r20,-1
 82046ac:	b485883a 	add	r2,r22,r18
 82046b0:	b94b883a 	add	r5,r23,r5
 82046b4:	b295883a 	add	r10,r22,r10
 82046b8:	00000706 	br	82046d8 <strstr+0x22c>
 82046bc:	11000003 	ldbu	r4,0(r2)
 82046c0:	28c00003 	ldbu	r3,0(r5)
 82046c4:	10bfffc4 	addi	r2,r2,-1
 82046c8:	21003fcc 	andi	r4,r4,255
 82046cc:	297fffc4 	addi	r5,r5,-1
 82046d0:	20c0031e 	bne	r4,r3,82046e0 <strstr+0x234>
 82046d4:	380d883a 	mov	r6,r7
 82046d8:	31ffffc4 	addi	r7,r6,-1
 82046dc:	12bff71e 	bne	r2,r10,82046bc <strstr+0x210>
 82046e0:	a2000044 	addi	r8,r20,1
 82046e4:	32005b36 	bltu	r6,r8,8204854 <strstr+0x3a8>
 82046e8:	da000017 	ldw	r8,0(sp)
 82046ec:	aa2b883a 	add	r21,r21,r8
 82046f0:	8229c83a 	sub	r20,r16,r8
 82046f4:	9807883a 	mov	r3,r19
 82046f8:	003fc206 	br	8204604 <strstr+0x158>
 82046fc:	28800007 	ldb	r2,0(r5)
 8204700:	103f7d26 	beq	r2,zero,82044f8 <strstr+0x4c>
 8204704:	0005883a 	mov	r2,zero
 8204708:	f800283a 	ret
 820470c:	d8c00117 	ldw	r3,4(sp)
 8204710:	0029883a 	mov	r20,zero
 8204714:	1d6b883a 	add	r21,r3,r21
 8204718:	a96b883a 	add	r21,r21,r5
 820471c:	003ff506 	br	82046f4 <strstr+0x248>
 8204720:	0005883a 	mov	r2,zero
 8204724:	003f9506 	br	820457c <strstr+0xd0>
 8204728:	8705c83a 	sub	r2,r16,fp
 820472c:	1700012e 	bgeu	r2,fp,8204734 <strstr+0x288>
 8204730:	e005883a 	mov	r2,fp
 8204734:	10800044 	addi	r2,r2,1
 8204738:	e4bfffc4 	addi	r18,fp,-1
 820473c:	05000044 	movi	r20,1
 8204740:	a729c83a 	sub	r20,r20,fp
 8204744:	d8800015 	stw	r2,0(sp)
 8204748:	b48b883a 	add	r5,r22,r18
 820474c:	e0bfff84 	addi	r2,fp,-2
 8204750:	dd000215 	stw	r20,8(sp)
 8204754:	002b883a 	mov	r21,zero
 8204758:	e4400044 	addi	r17,fp,1
 820475c:	d9400315 	stw	r5,12(sp)
 8204760:	d8800115 	stw	r2,4(sp)
 8204764:	b53fffc4 	addi	r20,r22,-1
 8204768:	8567883a 	add	r19,r16,r21
 820476c:	98cdc83a 	sub	r6,r19,r3
 8204770:	000b883a 	mov	r5,zero
 8204774:	b8c9883a 	add	r4,r23,r3
 8204778:	820c4f80 	call	820c4f8 <memchr>
 820477c:	103fe81e 	bne	r2,zero,8204720 <strstr+0x274>
 8204780:	983fe726 	beq	r19,zero,8204720 <strstr+0x274>
 8204784:	e400132e 	bgeu	fp,r16,82047d4 <strstr+0x328>
 8204788:	bf07883a 	add	r3,r23,fp
 820478c:	1d47883a 	add	r3,r3,r21
 8204790:	b705883a 	add	r2,r22,fp
 8204794:	18c00003 	ldbu	r3,0(r3)
 8204798:	10800003 	ldbu	r2,0(r2)
 820479c:	1880241e 	bne	r3,r2,8204830 <strstr+0x384>
 82047a0:	ac45883a 	add	r2,r21,r17
 82047a4:	b44b883a 	add	r5,r22,r17
 82047a8:	b885883a 	add	r2,r23,r2
 82047ac:	e009883a 	mov	r4,fp
 82047b0:	00000606 	br	82047cc <strstr+0x320>
 82047b4:	29800003 	ldbu	r6,0(r5)
 82047b8:	10c00003 	ldbu	r3,0(r2)
 82047bc:	29400044 	addi	r5,r5,1
 82047c0:	31803fcc 	andi	r6,r6,255
 82047c4:	10800044 	addi	r2,r2,1
 82047c8:	30c01a1e 	bne	r6,r3,8204834 <strstr+0x388>
 82047cc:	21000044 	addi	r4,r4,1
 82047d0:	243ff836 	bltu	r4,r16,82047b4 <strstr+0x308>
 82047d4:	00bfffc4 	movi	r2,-1
 82047d8:	bd49883a 	add	r4,r23,r21
 82047dc:	90801926 	beq	r18,r2,8204844 <strstr+0x398>
 82047e0:	d9400317 	ldw	r5,12(sp)
 82047e4:	2485883a 	add	r2,r4,r18
 82047e8:	10800003 	ldbu	r2,0(r2)
 82047ec:	28c00003 	ldbu	r3,0(r5)
 82047f0:	18800b1e 	bne	r3,r2,8204820 <strstr+0x374>
 82047f4:	d8c00117 	ldw	r3,4(sp)
 82047f8:	a8c5883a 	add	r2,r21,r3
 82047fc:	b885883a 	add	r2,r23,r2
 8204800:	b0c7883a 	add	r3,r22,r3
 8204804:	1d000f26 	beq	r3,r20,8204844 <strstr+0x398>
 8204808:	19800003 	ldbu	r6,0(r3)
 820480c:	11400003 	ldbu	r5,0(r2)
 8204810:	18ffffc4 	addi	r3,r3,-1
 8204814:	31803fcc 	andi	r6,r6,255
 8204818:	10bfffc4 	addi	r2,r2,-1
 820481c:	317ff926 	beq	r6,r5,8204804 <strstr+0x358>
 8204820:	d8800017 	ldw	r2,0(sp)
 8204824:	a8ab883a 	add	r21,r21,r2
 8204828:	9807883a 	mov	r3,r19
 820482c:	003fce06 	br	8204768 <strstr+0x2bc>
 8204830:	e009883a 	mov	r4,fp
 8204834:	d8c00217 	ldw	r3,8(sp)
 8204838:	1d4f883a 	add	r7,r3,r21
 820483c:	392b883a 	add	r21,r7,r4
 8204840:	003ff906 	br	8204828 <strstr+0x37c>
 8204844:	2005883a 	mov	r2,r4
 8204848:	003f4c06 	br	820457c <strstr+0xd0>
 820484c:	e00d883a 	mov	r6,fp
 8204850:	003fa306 	br	82046e0 <strstr+0x234>
 8204854:	bd45883a 	add	r2,r23,r21
 8204858:	003f4806 	br	820457c <strstr+0xd0>

0820485c <___svfprintf_internal_r>:
 820485c:	deffb704 	addi	sp,sp,-292
 8204860:	dfc04815 	stw	ra,288(sp)
 8204864:	ddc04615 	stw	r23,280(sp)
 8204868:	d9402c15 	stw	r5,176(sp)
 820486c:	d9003915 	stw	r4,228(sp)
 8204870:	302f883a 	mov	r23,r6
 8204874:	d9c02d15 	stw	r7,180(sp)
 8204878:	df004715 	stw	fp,284(sp)
 820487c:	dd804515 	stw	r22,276(sp)
 8204880:	dd404415 	stw	r21,272(sp)
 8204884:	dd004315 	stw	r20,268(sp)
 8204888:	dcc04215 	stw	r19,264(sp)
 820488c:	dc804115 	stw	r18,260(sp)
 8204890:	dc404015 	stw	r17,256(sp)
 8204894:	dc003f15 	stw	r16,252(sp)
 8204898:	820bb000 	call	820bb00 <_localeconv_r>
 820489c:	10800017 	ldw	r2,0(r2)
 82048a0:	1009883a 	mov	r4,r2
 82048a4:	d8803415 	stw	r2,208(sp)
 82048a8:	8203f600 	call	8203f60 <strlen>
 82048ac:	d8c02c17 	ldw	r3,176(sp)
 82048b0:	d8803815 	stw	r2,224(sp)
 82048b4:	1880030b 	ldhu	r2,12(r3)
 82048b8:	1080200c 	andi	r2,r2,128
 82048bc:	10000226 	beq	r2,zero,82048c8 <___svfprintf_internal_r+0x6c>
 82048c0:	18800417 	ldw	r2,16(r3)
 82048c4:	10067f26 	beq	r2,zero,82062c4 <___svfprintf_internal_r+0x1a68>
 82048c8:	dcc03917 	ldw	r19,228(sp)
 82048cc:	d8c00404 	addi	r3,sp,16
 82048d0:	05420974 	movhi	r21,2085
 82048d4:	d9001e04 	addi	r4,sp,120
 82048d8:	ad76ca84 	addi	r21,r21,-9430
 82048dc:	d8c01e15 	stw	r3,120(sp)
 82048e0:	d8002015 	stw	zero,128(sp)
 82048e4:	d8001f15 	stw	zero,124(sp)
 82048e8:	d8003315 	stw	zero,204(sp)
 82048ec:	d8003615 	stw	zero,216(sp)
 82048f0:	d8003715 	stw	zero,220(sp)
 82048f4:	1811883a 	mov	r8,r3
 82048f8:	d8003a15 	stw	zero,232(sp)
 82048fc:	d8003b15 	stw	zero,236(sp)
 8204900:	d8002f15 	stw	zero,188(sp)
 8204904:	d9002815 	stw	r4,160(sp)
 8204908:	b8800007 	ldb	r2,0(r23)
 820490c:	10026726 	beq	r2,zero,82052ac <___svfprintf_internal_r+0xa50>
 8204910:	00c00944 	movi	r3,37
 8204914:	b821883a 	mov	r16,r23
 8204918:	10c0021e 	bne	r2,r3,8204924 <___svfprintf_internal_r+0xc8>
 820491c:	00001406 	br	8204970 <___svfprintf_internal_r+0x114>
 8204920:	10c00326 	beq	r2,r3,8204930 <___svfprintf_internal_r+0xd4>
 8204924:	84000044 	addi	r16,r16,1
 8204928:	80800007 	ldb	r2,0(r16)
 820492c:	103ffc1e 	bne	r2,zero,8204920 <___svfprintf_internal_r+0xc4>
 8204930:	85e3c83a 	sub	r17,r16,r23
 8204934:	88000e26 	beq	r17,zero,8204970 <___svfprintf_internal_r+0x114>
 8204938:	d8c02017 	ldw	r3,128(sp)
 820493c:	d8801f17 	ldw	r2,124(sp)
 8204940:	45c00015 	stw	r23,0(r8)
 8204944:	1c47883a 	add	r3,r3,r17
 8204948:	10800044 	addi	r2,r2,1
 820494c:	d8c02015 	stw	r3,128(sp)
 8204950:	44400115 	stw	r17,4(r8)
 8204954:	d8801f15 	stw	r2,124(sp)
 8204958:	00c001c4 	movi	r3,7
 820495c:	18809716 	blt	r3,r2,8204bbc <___svfprintf_internal_r+0x360>
 8204960:	42000204 	addi	r8,r8,8
 8204964:	d9402f17 	ldw	r5,188(sp)
 8204968:	2c4b883a 	add	r5,r5,r17
 820496c:	d9402f15 	stw	r5,188(sp)
 8204970:	80800007 	ldb	r2,0(r16)
 8204974:	10009826 	beq	r2,zero,8204bd8 <___svfprintf_internal_r+0x37c>
 8204978:	84400047 	ldb	r17,1(r16)
 820497c:	00bfffc4 	movi	r2,-1
 8204980:	85c00044 	addi	r23,r16,1
 8204984:	d8002785 	stb	zero,158(sp)
 8204988:	0007883a 	mov	r3,zero
 820498c:	000f883a 	mov	r7,zero
 8204990:	d8802915 	stw	r2,164(sp)
 8204994:	d8003115 	stw	zero,196(sp)
 8204998:	0025883a 	mov	r18,zero
 820499c:	01401604 	movi	r5,88
 82049a0:	01800244 	movi	r6,9
 82049a4:	02800a84 	movi	r10,42
 82049a8:	02401b04 	movi	r9,108
 82049ac:	bdc00044 	addi	r23,r23,1
 82049b0:	88bff804 	addi	r2,r17,-32
 82049b4:	2882f036 	bltu	r5,r2,8205578 <___svfprintf_internal_r+0xd1c>
 82049b8:	100490ba 	slli	r2,r2,2
 82049bc:	01020834 	movhi	r4,2080
 82049c0:	21127404 	addi	r4,r4,18896
 82049c4:	1105883a 	add	r2,r2,r4
 82049c8:	10800017 	ldw	r2,0(r2)
 82049cc:	1000683a 	jmp	r2
 82049d0:	082054e0 	cmpeqi	zero,at,-32429
 82049d4:	08205578 	rdprs	zero,at,-32427
 82049d8:	08205578 	rdprs	zero,at,-32427
 82049dc:	082054d4 	ori	zero,at,33107
 82049e0:	08205578 	rdprs	zero,at,-32427
 82049e4:	08205578 	rdprs	zero,at,-32427
 82049e8:	08205578 	rdprs	zero,at,-32427
 82049ec:	08205578 	rdprs	zero,at,-32427
 82049f0:	08205578 	rdprs	zero,at,-32427
 82049f4:	08205578 	rdprs	zero,at,-32427
 82049f8:	08204c34 	orhi	zero,at,33072
 82049fc:	08205410 	cmplti	zero,at,-32432
 8204a00:	08205578 	rdprs	zero,at,-32427
 8204a04:	08204b44 	addi	zero,at,-32467
 8204a08:	08204c5c 	xori	zero,at,33073
 8204a0c:	08205578 	rdprs	zero,at,-32427
 8204a10:	08204cd0 	cmplti	zero,at,-32461
 8204a14:	08204c9c 	xori	zero,at,33074
 8204a18:	08204c9c 	xori	zero,at,33074
 8204a1c:	08204c9c 	xori	zero,at,33074
 8204a20:	08204c9c 	xori	zero,at,33074
 8204a24:	08204c9c 	xori	zero,at,33074
 8204a28:	08204c9c 	xori	zero,at,33074
 8204a2c:	08204c9c 	xori	zero,at,33074
 8204a30:	08204c9c 	xori	zero,at,33074
 8204a34:	08204c9c 	xori	zero,at,33074
 8204a38:	08205578 	rdprs	zero,at,-32427
 8204a3c:	08205578 	rdprs	zero,at,-32427
 8204a40:	08205578 	rdprs	zero,at,-32427
 8204a44:	08205578 	rdprs	zero,at,-32427
 8204a48:	08205578 	rdprs	zero,at,-32427
 8204a4c:	08205578 	rdprs	zero,at,-32427
 8204a50:	08205578 	rdprs	zero,at,-32427
 8204a54:	08205578 	rdprs	zero,at,-32427
 8204a58:	08205578 	rdprs	zero,at,-32427
 8204a5c:	08205578 	rdprs	zero,at,-32427
 8204a60:	08204d88 	cmpgei	zero,at,-32458
 8204a64:	08204cdc 	xori	zero,at,33075
 8204a68:	08205578 	rdprs	zero,at,-32427
 8204a6c:	08204cdc 	xori	zero,at,33075
 8204a70:	08205578 	rdprs	zero,at,-32427
 8204a74:	08205578 	rdprs	zero,at,-32427
 8204a78:	08205578 	rdprs	zero,at,-32427
 8204a7c:	08205578 	rdprs	zero,at,-32427
 8204a80:	08204d7c 	xorhi	zero,at,33077
 8204a84:	08205578 	rdprs	zero,at,-32427
 8204a88:	08205578 	rdprs	zero,at,-32427
 8204a8c:	08204e44 	addi	zero,at,-32455
 8204a90:	08205578 	rdprs	zero,at,-32427
 8204a94:	08205578 	rdprs	zero,at,-32427
 8204a98:	08205578 	rdprs	zero,at,-32427
 8204a9c:	08205578 	rdprs	zero,at,-32427
 8204aa0:	08205578 	rdprs	zero,at,-32427
 8204aa4:	082052b4 	orhi	zero,at,33098
 8204aa8:	08205578 	rdprs	zero,at,-32427
 8204aac:	08205578 	rdprs	zero,at,-32427
 8204ab0:	08205314 	ori	zero,at,33100
 8204ab4:	08205578 	rdprs	zero,at,-32427
 8204ab8:	08205578 	rdprs	zero,at,-32427
 8204abc:	08205578 	rdprs	zero,at,-32427
 8204ac0:	08205578 	rdprs	zero,at,-32427
 8204ac4:	08205578 	rdprs	zero,at,-32427
 8204ac8:	08205578 	rdprs	zero,at,-32427
 8204acc:	08205578 	rdprs	zero,at,-32427
 8204ad0:	08205578 	rdprs	zero,at,-32427
 8204ad4:	08205578 	rdprs	zero,at,-32427
 8204ad8:	08205578 	rdprs	zero,at,-32427
 8204adc:	082053c4 	addi	zero,at,-32433
 8204ae0:	08205500 	call	820550 <OSCtxSw_SWITCH_PC+0x820510>
 8204ae4:	08204cdc 	xori	zero,at,33075
 8204ae8:	08204cdc 	xori	zero,at,33075
 8204aec:	08204cdc 	xori	zero,at,33075
 8204af0:	08205554 	ori	zero,at,33109
 8204af4:	08205500 	call	820550 <OSCtxSw_SWITCH_PC+0x820510>
 8204af8:	08205578 	rdprs	zero,at,-32427
 8204afc:	08205578 	rdprs	zero,at,-32427
 8204b00:	08205510 	cmplti	zero,at,-32428
 8204b04:	08205578 	rdprs	zero,at,-32427
 8204b08:	08205520 	cmpeqi	zero,at,-32428
 8204b0c:	08205400 	call	820540 <OSCtxSw_SWITCH_PC+0x820500>
 8204b10:	08204b50 	cmplti	zero,at,-32467
 8204b14:	08205420 	cmpeqi	zero,at,-32432
 8204b18:	08205578 	rdprs	zero,at,-32427
 8204b1c:	0820542c 	andhi	zero,at,33104
 8204b20:	08205578 	rdprs	zero,at,-32427
 8204b24:	08205488 	cmpgei	zero,at,-32430
 8204b28:	08205578 	rdprs	zero,at,-32427
 8204b2c:	08205578 	rdprs	zero,at,-32427
 8204b30:	08205498 	cmpnei	zero,at,-32430
 8204b34:	d9003117 	ldw	r4,196(sp)
 8204b38:	d8802d15 	stw	r2,180(sp)
 8204b3c:	0109c83a 	sub	r4,zero,r4
 8204b40:	d9003115 	stw	r4,196(sp)
 8204b44:	94800114 	ori	r18,r18,4
 8204b48:	bc400007 	ldb	r17,0(r23)
 8204b4c:	003f9706 	br	82049ac <___svfprintf_internal_r+0x150>
 8204b50:	00800c04 	movi	r2,48
 8204b54:	d9002d17 	ldw	r4,180(sp)
 8204b58:	d9402917 	ldw	r5,164(sp)
 8204b5c:	d8802705 	stb	r2,156(sp)
 8204b60:	00801e04 	movi	r2,120
 8204b64:	d8802745 	stb	r2,157(sp)
 8204b68:	d8002785 	stb	zero,158(sp)
 8204b6c:	20c00104 	addi	r3,r4,4
 8204b70:	25000017 	ldw	r20,0(r4)
 8204b74:	002d883a 	mov	r22,zero
 8204b78:	90800094 	ori	r2,r18,2
 8204b7c:	28028616 	blt	r5,zero,8205598 <___svfprintf_internal_r+0xd3c>
 8204b80:	00bfdfc4 	movi	r2,-129
 8204b84:	90a4703a 	and	r18,r18,r2
 8204b88:	d8c02d15 	stw	r3,180(sp)
 8204b8c:	94800094 	ori	r18,r18,2
 8204b90:	a002731e 	bne	r20,zero,8205560 <___svfprintf_internal_r+0xd04>
 8204b94:	00820974 	movhi	r2,2085
 8204b98:	10b6c304 	addi	r2,r2,-9460
 8204b9c:	d8803a15 	stw	r2,232(sp)
 8204ba0:	04401e04 	movi	r17,120
 8204ba4:	d8c02917 	ldw	r3,164(sp)
 8204ba8:	0039883a 	mov	fp,zero
 8204bac:	1801d526 	beq	r3,zero,8205304 <___svfprintf_internal_r+0xaa8>
 8204bb0:	0029883a 	mov	r20,zero
 8204bb4:	002d883a 	mov	r22,zero
 8204bb8:	0001f106 	br	8205380 <___svfprintf_internal_r+0xb24>
 8204bbc:	d9402c17 	ldw	r5,176(sp)
 8204bc0:	d9801e04 	addi	r6,sp,120
 8204bc4:	9809883a 	mov	r4,r19
 8204bc8:	820e0880 	call	820e088 <__ssprint_r>
 8204bcc:	1000081e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 8204bd0:	da000404 	addi	r8,sp,16
 8204bd4:	003f6306 	br	8204964 <___svfprintf_internal_r+0x108>
 8204bd8:	d8802017 	ldw	r2,128(sp)
 8204bdc:	10000426 	beq	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 8204be0:	d9402c17 	ldw	r5,176(sp)
 8204be4:	d9003917 	ldw	r4,228(sp)
 8204be8:	d9801e04 	addi	r6,sp,120
 8204bec:	820e0880 	call	820e088 <__ssprint_r>
 8204bf0:	d8802c17 	ldw	r2,176(sp)
 8204bf4:	10c0030b 	ldhu	r3,12(r2)
 8204bf8:	d8802f17 	ldw	r2,188(sp)
 8204bfc:	18c0100c 	andi	r3,r3,64
 8204c00:	1805f51e 	bne	r3,zero,82063d8 <___svfprintf_internal_r+0x1b7c>
 8204c04:	dfc04817 	ldw	ra,288(sp)
 8204c08:	df004717 	ldw	fp,284(sp)
 8204c0c:	ddc04617 	ldw	r23,280(sp)
 8204c10:	dd804517 	ldw	r22,276(sp)
 8204c14:	dd404417 	ldw	r21,272(sp)
 8204c18:	dd004317 	ldw	r20,268(sp)
 8204c1c:	dcc04217 	ldw	r19,264(sp)
 8204c20:	dc804117 	ldw	r18,260(sp)
 8204c24:	dc404017 	ldw	r17,256(sp)
 8204c28:	dc003f17 	ldw	r16,252(sp)
 8204c2c:	dec04904 	addi	sp,sp,292
 8204c30:	f800283a 	ret
 8204c34:	d8802d17 	ldw	r2,180(sp)
 8204c38:	d9002d17 	ldw	r4,180(sp)
 8204c3c:	10800017 	ldw	r2,0(r2)
 8204c40:	d8803115 	stw	r2,196(sp)
 8204c44:	20800104 	addi	r2,r4,4
 8204c48:	d9003117 	ldw	r4,196(sp)
 8204c4c:	203fb916 	blt	r4,zero,8204b34 <___svfprintf_internal_r+0x2d8>
 8204c50:	d8802d15 	stw	r2,180(sp)
 8204c54:	bc400007 	ldb	r17,0(r23)
 8204c58:	003f5406 	br	82049ac <___svfprintf_internal_r+0x150>
 8204c5c:	bc400007 	ldb	r17,0(r23)
 8204c60:	bac00044 	addi	r11,r23,1
 8204c64:	8a873926 	beq	r17,r10,820694c <___svfprintf_internal_r+0x20f0>
 8204c68:	88bff404 	addi	r2,r17,-48
 8204c6c:	0009883a 	mov	r4,zero
 8204c70:	30868836 	bltu	r6,r2,8206694 <___svfprintf_internal_r+0x1e38>
 8204c74:	5c400007 	ldb	r17,0(r11)
 8204c78:	210002a4 	muli	r4,r4,10
 8204c7c:	5dc00044 	addi	r23,r11,1
 8204c80:	b817883a 	mov	r11,r23
 8204c84:	2089883a 	add	r4,r4,r2
 8204c88:	88bff404 	addi	r2,r17,-48
 8204c8c:	30bff92e 	bgeu	r6,r2,8204c74 <___svfprintf_internal_r+0x418>
 8204c90:	2005d716 	blt	r4,zero,82063f0 <___svfprintf_internal_r+0x1b94>
 8204c94:	d9002915 	stw	r4,164(sp)
 8204c98:	003f4506 	br	82049b0 <___svfprintf_internal_r+0x154>
 8204c9c:	b809883a 	mov	r4,r23
 8204ca0:	d8003115 	stw	zero,196(sp)
 8204ca4:	88bff404 	addi	r2,r17,-48
 8204ca8:	0017883a 	mov	r11,zero
 8204cac:	24400007 	ldb	r17,0(r4)
 8204cb0:	5ac002a4 	muli	r11,r11,10
 8204cb4:	bdc00044 	addi	r23,r23,1
 8204cb8:	b809883a 	mov	r4,r23
 8204cbc:	12d7883a 	add	r11,r2,r11
 8204cc0:	88bff404 	addi	r2,r17,-48
 8204cc4:	30bff92e 	bgeu	r6,r2,8204cac <___svfprintf_internal_r+0x450>
 8204cc8:	dac03115 	stw	r11,196(sp)
 8204ccc:	003f3806 	br	82049b0 <___svfprintf_internal_r+0x154>
 8204cd0:	94802014 	ori	r18,r18,128
 8204cd4:	bc400007 	ldb	r17,0(r23)
 8204cd8:	003f3406 	br	82049ac <___svfprintf_internal_r+0x150>
 8204cdc:	18c03fcc 	andi	r3,r3,255
 8204ce0:	1807471e 	bne	r3,zero,8206a00 <___svfprintf_internal_r+0x21a4>
 8204ce4:	9080020c 	andi	r2,r18,8
 8204ce8:	10047d26 	beq	r2,zero,8205ee0 <___svfprintf_internal_r+0x1684>
 8204cec:	d8c02d17 	ldw	r3,180(sp)
 8204cf0:	d9002d17 	ldw	r4,180(sp)
 8204cf4:	d9402d17 	ldw	r5,180(sp)
 8204cf8:	18c00017 	ldw	r3,0(r3)
 8204cfc:	21000117 	ldw	r4,4(r4)
 8204d00:	29400204 	addi	r5,r5,8
 8204d04:	d8c03615 	stw	r3,216(sp)
 8204d08:	d9003715 	stw	r4,220(sp)
 8204d0c:	d9402d15 	stw	r5,180(sp)
 8204d10:	d9003617 	ldw	r4,216(sp)
 8204d14:	d9403717 	ldw	r5,220(sp)
 8204d18:	da003e15 	stw	r8,248(sp)
 8204d1c:	04000044 	movi	r16,1
 8204d20:	820dda80 	call	820dda8 <__fpclassifyd>
 8204d24:	da003e17 	ldw	r8,248(sp)
 8204d28:	14044b1e 	bne	r2,r16,8205e58 <___svfprintf_internal_r+0x15fc>
 8204d2c:	d9003617 	ldw	r4,216(sp)
 8204d30:	d9403717 	ldw	r5,220(sp)
 8204d34:	000d883a 	mov	r6,zero
 8204d38:	000f883a 	mov	r7,zero
 8204d3c:	82130600 	call	8213060 <__ledf2>
 8204d40:	da003e17 	ldw	r8,248(sp)
 8204d44:	1005f316 	blt	r2,zero,8206514 <___svfprintf_internal_r+0x1cb8>
 8204d48:	df002783 	ldbu	fp,158(sp)
 8204d4c:	008011c4 	movi	r2,71
 8204d50:	1445590e 	bge	r2,r17,82062b8 <___svfprintf_internal_r+0x1a5c>
 8204d54:	04020974 	movhi	r16,2085
 8204d58:	8436bb04 	addi	r16,r16,-9492
 8204d5c:	00c000c4 	movi	r3,3
 8204d60:	00bfdfc4 	movi	r2,-129
 8204d64:	d8c02a15 	stw	r3,168(sp)
 8204d68:	90a4703a 	and	r18,r18,r2
 8204d6c:	d8c02e15 	stw	r3,184(sp)
 8204d70:	d8002915 	stw	zero,164(sp)
 8204d74:	d8003215 	stw	zero,200(sp)
 8204d78:	00006606 	br	8204f14 <___svfprintf_internal_r+0x6b8>
 8204d7c:	94800214 	ori	r18,r18,8
 8204d80:	bc400007 	ldb	r17,0(r23)
 8204d84:	003f0906 	br	82049ac <___svfprintf_internal_r+0x150>
 8204d88:	18c03fcc 	andi	r3,r3,255
 8204d8c:	1807181e 	bne	r3,zero,82069f0 <___svfprintf_internal_r+0x2194>
 8204d90:	94800414 	ori	r18,r18,16
 8204d94:	9080080c 	andi	r2,r18,32
 8204d98:	10039626 	beq	r2,zero,8205bf4 <___svfprintf_internal_r+0x1398>
 8204d9c:	d9402d17 	ldw	r5,180(sp)
 8204da0:	28800117 	ldw	r2,4(r5)
 8204da4:	2d000017 	ldw	r20,0(r5)
 8204da8:	29400204 	addi	r5,r5,8
 8204dac:	d9402d15 	stw	r5,180(sp)
 8204db0:	102d883a 	mov	r22,r2
 8204db4:	10039816 	blt	r2,zero,8205c18 <___svfprintf_internal_r+0x13bc>
 8204db8:	d9402917 	ldw	r5,164(sp)
 8204dbc:	df002783 	ldbu	fp,158(sp)
 8204dc0:	2803ab16 	blt	r5,zero,8205c70 <___svfprintf_internal_r+0x1414>
 8204dc4:	00ffdfc4 	movi	r3,-129
 8204dc8:	a584b03a 	or	r2,r20,r22
 8204dcc:	90e4703a 	and	r18,r18,r3
 8204dd0:	10014a26 	beq	r2,zero,82052fc <___svfprintf_internal_r+0xaa0>
 8204dd4:	b0034b26 	beq	r22,zero,8205b04 <___svfprintf_internal_r+0x12a8>
 8204dd8:	dc402a15 	stw	r17,168(sp)
 8204ddc:	dc001e04 	addi	r16,sp,120
 8204de0:	b023883a 	mov	r17,r22
 8204de4:	402d883a 	mov	r22,r8
 8204de8:	a009883a 	mov	r4,r20
 8204dec:	880b883a 	mov	r5,r17
 8204df0:	01800284 	movi	r6,10
 8204df4:	000f883a 	mov	r7,zero
 8204df8:	82118300 	call	8211830 <__umoddi3>
 8204dfc:	10800c04 	addi	r2,r2,48
 8204e00:	843fffc4 	addi	r16,r16,-1
 8204e04:	a009883a 	mov	r4,r20
 8204e08:	880b883a 	mov	r5,r17
 8204e0c:	80800005 	stb	r2,0(r16)
 8204e10:	01800284 	movi	r6,10
 8204e14:	000f883a 	mov	r7,zero
 8204e18:	82112b80 	call	82112b8 <__udivdi3>
 8204e1c:	1029883a 	mov	r20,r2
 8204e20:	10c4b03a 	or	r2,r2,r3
 8204e24:	1823883a 	mov	r17,r3
 8204e28:	103fef1e 	bne	r2,zero,8204de8 <___svfprintf_internal_r+0x58c>
 8204e2c:	d8c02817 	ldw	r3,160(sp)
 8204e30:	dc402a17 	ldw	r17,168(sp)
 8204e34:	b011883a 	mov	r8,r22
 8204e38:	1c07c83a 	sub	r3,r3,r16
 8204e3c:	d8c02e15 	stw	r3,184(sp)
 8204e40:	00002e06 	br	8204efc <___svfprintf_internal_r+0x6a0>
 8204e44:	18c03fcc 	andi	r3,r3,255
 8204e48:	1806e71e 	bne	r3,zero,82069e8 <___svfprintf_internal_r+0x218c>
 8204e4c:	94800414 	ori	r18,r18,16
 8204e50:	9080080c 	andi	r2,r18,32
 8204e54:	1002d426 	beq	r2,zero,82059a8 <___svfprintf_internal_r+0x114c>
 8204e58:	d9402d17 	ldw	r5,180(sp)
 8204e5c:	d8c02917 	ldw	r3,164(sp)
 8204e60:	d8002785 	stb	zero,158(sp)
 8204e64:	28800204 	addi	r2,r5,8
 8204e68:	2d000017 	ldw	r20,0(r5)
 8204e6c:	2d800117 	ldw	r22,4(r5)
 8204e70:	18041516 	blt	r3,zero,8205ec8 <___svfprintf_internal_r+0x166c>
 8204e74:	013fdfc4 	movi	r4,-129
 8204e78:	a586b03a 	or	r3,r20,r22
 8204e7c:	d8802d15 	stw	r2,180(sp)
 8204e80:	9124703a 	and	r18,r18,r4
 8204e84:	1802d51e 	bne	r3,zero,82059dc <___svfprintf_internal_r+0x1180>
 8204e88:	d9402917 	ldw	r5,164(sp)
 8204e8c:	0039883a 	mov	fp,zero
 8204e90:	2806be26 	beq	r5,zero,820698c <___svfprintf_internal_r+0x2130>
 8204e94:	0029883a 	mov	r20,zero
 8204e98:	002d883a 	mov	r22,zero
 8204e9c:	dc001e04 	addi	r16,sp,120
 8204ea0:	a006d0fa 	srli	r3,r20,3
 8204ea4:	b008977a 	slli	r4,r22,29
 8204ea8:	b02cd0fa 	srli	r22,r22,3
 8204eac:	a50001cc 	andi	r20,r20,7
 8204eb0:	a0800c04 	addi	r2,r20,48
 8204eb4:	843fffc4 	addi	r16,r16,-1
 8204eb8:	20e8b03a 	or	r20,r4,r3
 8204ebc:	80800005 	stb	r2,0(r16)
 8204ec0:	a586b03a 	or	r3,r20,r22
 8204ec4:	183ff61e 	bne	r3,zero,8204ea0 <___svfprintf_internal_r+0x644>
 8204ec8:	90c0004c 	andi	r3,r18,1
 8204ecc:	18013926 	beq	r3,zero,82053b4 <___svfprintf_internal_r+0xb58>
 8204ed0:	10803fcc 	andi	r2,r2,255
 8204ed4:	1080201c 	xori	r2,r2,128
 8204ed8:	10bfe004 	addi	r2,r2,-128
 8204edc:	00c00c04 	movi	r3,48
 8204ee0:	10c13426 	beq	r2,r3,82053b4 <___svfprintf_internal_r+0xb58>
 8204ee4:	80ffffc5 	stb	r3,-1(r16)
 8204ee8:	d8c02817 	ldw	r3,160(sp)
 8204eec:	80bfffc4 	addi	r2,r16,-1
 8204ef0:	1021883a 	mov	r16,r2
 8204ef4:	1887c83a 	sub	r3,r3,r2
 8204ef8:	d8c02e15 	stw	r3,184(sp)
 8204efc:	d8802e17 	ldw	r2,184(sp)
 8204f00:	d9002917 	ldw	r4,164(sp)
 8204f04:	1100010e 	bge	r2,r4,8204f0c <___svfprintf_internal_r+0x6b0>
 8204f08:	2005883a 	mov	r2,r4
 8204f0c:	d8802a15 	stw	r2,168(sp)
 8204f10:	d8003215 	stw	zero,200(sp)
 8204f14:	e7003fcc 	andi	fp,fp,255
 8204f18:	e700201c 	xori	fp,fp,128
 8204f1c:	e73fe004 	addi	fp,fp,-128
 8204f20:	e0000326 	beq	fp,zero,8204f30 <___svfprintf_internal_r+0x6d4>
 8204f24:	d8c02a17 	ldw	r3,168(sp)
 8204f28:	18c00044 	addi	r3,r3,1
 8204f2c:	d8c02a15 	stw	r3,168(sp)
 8204f30:	90c0008c 	andi	r3,r18,2
 8204f34:	d8c02b15 	stw	r3,172(sp)
 8204f38:	18000326 	beq	r3,zero,8204f48 <___svfprintf_internal_r+0x6ec>
 8204f3c:	d8c02a17 	ldw	r3,168(sp)
 8204f40:	18c00084 	addi	r3,r3,2
 8204f44:	d8c02a15 	stw	r3,168(sp)
 8204f48:	90c0210c 	andi	r3,r18,132
 8204f4c:	d8c03015 	stw	r3,192(sp)
 8204f50:	1801a11e 	bne	r3,zero,82055d8 <___svfprintf_internal_r+0xd7c>
 8204f54:	d9003117 	ldw	r4,196(sp)
 8204f58:	d8c02a17 	ldw	r3,168(sp)
 8204f5c:	20e9c83a 	sub	r20,r4,r3
 8204f60:	05019d0e 	bge	zero,r20,82055d8 <___svfprintf_internal_r+0xd7c>
 8204f64:	02400404 	movi	r9,16
 8204f68:	d8c02017 	ldw	r3,128(sp)
 8204f6c:	d8801f17 	ldw	r2,124(sp)
 8204f70:	4d051b0e 	bge	r9,r20,82063e0 <___svfprintf_internal_r+0x1b84>
 8204f74:	01420974 	movhi	r5,2085
 8204f78:	2976ce84 	addi	r5,r5,-9414
 8204f7c:	dc403c15 	stw	r17,240(sp)
 8204f80:	d9403515 	stw	r5,212(sp)
 8204f84:	a023883a 	mov	r17,r20
 8204f88:	482d883a 	mov	r22,r9
 8204f8c:	9029883a 	mov	r20,r18
 8204f90:	070001c4 	movi	fp,7
 8204f94:	8025883a 	mov	r18,r16
 8204f98:	dc002c17 	ldw	r16,176(sp)
 8204f9c:	00000306 	br	8204fac <___svfprintf_internal_r+0x750>
 8204fa0:	8c7ffc04 	addi	r17,r17,-16
 8204fa4:	42000204 	addi	r8,r8,8
 8204fa8:	b440130e 	bge	r22,r17,8204ff8 <___svfprintf_internal_r+0x79c>
 8204fac:	01020974 	movhi	r4,2085
 8204fb0:	18c00404 	addi	r3,r3,16
 8204fb4:	10800044 	addi	r2,r2,1
 8204fb8:	2136ce84 	addi	r4,r4,-9414
 8204fbc:	41000015 	stw	r4,0(r8)
 8204fc0:	45800115 	stw	r22,4(r8)
 8204fc4:	d8c02015 	stw	r3,128(sp)
 8204fc8:	d8801f15 	stw	r2,124(sp)
 8204fcc:	e0bff40e 	bge	fp,r2,8204fa0 <___svfprintf_internal_r+0x744>
 8204fd0:	d9801e04 	addi	r6,sp,120
 8204fd4:	800b883a 	mov	r5,r16
 8204fd8:	9809883a 	mov	r4,r19
 8204fdc:	820e0880 	call	820e088 <__ssprint_r>
 8204fe0:	103f031e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 8204fe4:	8c7ffc04 	addi	r17,r17,-16
 8204fe8:	d8c02017 	ldw	r3,128(sp)
 8204fec:	d8801f17 	ldw	r2,124(sp)
 8204ff0:	da000404 	addi	r8,sp,16
 8204ff4:	b47fed16 	blt	r22,r17,8204fac <___svfprintf_internal_r+0x750>
 8204ff8:	9021883a 	mov	r16,r18
 8204ffc:	a025883a 	mov	r18,r20
 8205000:	8829883a 	mov	r20,r17
 8205004:	dc403c17 	ldw	r17,240(sp)
 8205008:	d9403517 	ldw	r5,212(sp)
 820500c:	a0c7883a 	add	r3,r20,r3
 8205010:	10800044 	addi	r2,r2,1
 8205014:	41400015 	stw	r5,0(r8)
 8205018:	45000115 	stw	r20,4(r8)
 820501c:	d8c02015 	stw	r3,128(sp)
 8205020:	d8801f15 	stw	r2,124(sp)
 8205024:	010001c4 	movi	r4,7
 8205028:	20829f16 	blt	r4,r2,8205aa8 <___svfprintf_internal_r+0x124c>
 820502c:	df002787 	ldb	fp,158(sp)
 8205030:	42000204 	addi	r8,r8,8
 8205034:	e0000c26 	beq	fp,zero,8205068 <___svfprintf_internal_r+0x80c>
 8205038:	d8801f17 	ldw	r2,124(sp)
 820503c:	d9002784 	addi	r4,sp,158
 8205040:	18c00044 	addi	r3,r3,1
 8205044:	10800044 	addi	r2,r2,1
 8205048:	41000015 	stw	r4,0(r8)
 820504c:	01000044 	movi	r4,1
 8205050:	41000115 	stw	r4,4(r8)
 8205054:	d8c02015 	stw	r3,128(sp)
 8205058:	d8801f15 	stw	r2,124(sp)
 820505c:	010001c4 	movi	r4,7
 8205060:	20823816 	blt	r4,r2,8205944 <___svfprintf_internal_r+0x10e8>
 8205064:	42000204 	addi	r8,r8,8
 8205068:	d8802b17 	ldw	r2,172(sp)
 820506c:	10000c26 	beq	r2,zero,82050a0 <___svfprintf_internal_r+0x844>
 8205070:	d8801f17 	ldw	r2,124(sp)
 8205074:	d9002704 	addi	r4,sp,156
 8205078:	18c00084 	addi	r3,r3,2
 820507c:	10800044 	addi	r2,r2,1
 8205080:	41000015 	stw	r4,0(r8)
 8205084:	01000084 	movi	r4,2
 8205088:	41000115 	stw	r4,4(r8)
 820508c:	d8c02015 	stw	r3,128(sp)
 8205090:	d8801f15 	stw	r2,124(sp)
 8205094:	010001c4 	movi	r4,7
 8205098:	20823216 	blt	r4,r2,8205964 <___svfprintf_internal_r+0x1108>
 820509c:	42000204 	addi	r8,r8,8
 82050a0:	d9003017 	ldw	r4,192(sp)
 82050a4:	00802004 	movi	r2,128
 82050a8:	20819726 	beq	r4,r2,8205708 <___svfprintf_internal_r+0xeac>
 82050ac:	d9402917 	ldw	r5,164(sp)
 82050b0:	d8802e17 	ldw	r2,184(sp)
 82050b4:	28adc83a 	sub	r22,r5,r2
 82050b8:	05802f0e 	bge	zero,r22,8205178 <___svfprintf_internal_r+0x91c>
 82050bc:	07000404 	movi	fp,16
 82050c0:	d8801f17 	ldw	r2,124(sp)
 82050c4:	e583c00e 	bge	fp,r22,8205fc8 <___svfprintf_internal_r+0x176c>
 82050c8:	01420974 	movhi	r5,2085
 82050cc:	2976ca84 	addi	r5,r5,-9430
 82050d0:	dc402915 	stw	r17,164(sp)
 82050d4:	d9402b15 	stw	r5,172(sp)
 82050d8:	b023883a 	mov	r17,r22
 82050dc:	050001c4 	movi	r20,7
 82050e0:	902d883a 	mov	r22,r18
 82050e4:	8025883a 	mov	r18,r16
 82050e8:	dc002c17 	ldw	r16,176(sp)
 82050ec:	00000306 	br	82050fc <___svfprintf_internal_r+0x8a0>
 82050f0:	8c7ffc04 	addi	r17,r17,-16
 82050f4:	42000204 	addi	r8,r8,8
 82050f8:	e440110e 	bge	fp,r17,8205140 <___svfprintf_internal_r+0x8e4>
 82050fc:	18c00404 	addi	r3,r3,16
 8205100:	10800044 	addi	r2,r2,1
 8205104:	45400015 	stw	r21,0(r8)
 8205108:	47000115 	stw	fp,4(r8)
 820510c:	d8c02015 	stw	r3,128(sp)
 8205110:	d8801f15 	stw	r2,124(sp)
 8205114:	a0bff60e 	bge	r20,r2,82050f0 <___svfprintf_internal_r+0x894>
 8205118:	d9801e04 	addi	r6,sp,120
 820511c:	800b883a 	mov	r5,r16
 8205120:	9809883a 	mov	r4,r19
 8205124:	820e0880 	call	820e088 <__ssprint_r>
 8205128:	103eb11e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 820512c:	8c7ffc04 	addi	r17,r17,-16
 8205130:	d8c02017 	ldw	r3,128(sp)
 8205134:	d8801f17 	ldw	r2,124(sp)
 8205138:	da000404 	addi	r8,sp,16
 820513c:	e47fef16 	blt	fp,r17,82050fc <___svfprintf_internal_r+0x8a0>
 8205140:	9021883a 	mov	r16,r18
 8205144:	b025883a 	mov	r18,r22
 8205148:	882d883a 	mov	r22,r17
 820514c:	dc402917 	ldw	r17,164(sp)
 8205150:	d9002b17 	ldw	r4,172(sp)
 8205154:	1d87883a 	add	r3,r3,r22
 8205158:	10800044 	addi	r2,r2,1
 820515c:	41000015 	stw	r4,0(r8)
 8205160:	45800115 	stw	r22,4(r8)
 8205164:	d8c02015 	stw	r3,128(sp)
 8205168:	d8801f15 	stw	r2,124(sp)
 820516c:	010001c4 	movi	r4,7
 8205170:	2081ec16 	blt	r4,r2,8205924 <___svfprintf_internal_r+0x10c8>
 8205174:	42000204 	addi	r8,r8,8
 8205178:	9080400c 	andi	r2,r18,256
 820517c:	1001181e 	bne	r2,zero,82055e0 <___svfprintf_internal_r+0xd84>
 8205180:	d9402e17 	ldw	r5,184(sp)
 8205184:	d8801f17 	ldw	r2,124(sp)
 8205188:	44000015 	stw	r16,0(r8)
 820518c:	1947883a 	add	r3,r3,r5
 8205190:	10800044 	addi	r2,r2,1
 8205194:	41400115 	stw	r5,4(r8)
 8205198:	d8c02015 	stw	r3,128(sp)
 820519c:	d8801f15 	stw	r2,124(sp)
 82051a0:	010001c4 	movi	r4,7
 82051a4:	2081d116 	blt	r4,r2,82058ec <___svfprintf_internal_r+0x1090>
 82051a8:	42000204 	addi	r8,r8,8
 82051ac:	9480010c 	andi	r18,r18,4
 82051b0:	90003226 	beq	r18,zero,820527c <___svfprintf_internal_r+0xa20>
 82051b4:	d9403117 	ldw	r5,196(sp)
 82051b8:	d8802a17 	ldw	r2,168(sp)
 82051bc:	28a1c83a 	sub	r16,r5,r2
 82051c0:	04002e0e 	bge	zero,r16,820527c <___svfprintf_internal_r+0xa20>
 82051c4:	04400404 	movi	r17,16
 82051c8:	d8801f17 	ldw	r2,124(sp)
 82051cc:	8c04b90e 	bge	r17,r16,82064b4 <___svfprintf_internal_r+0x1c58>
 82051d0:	01420974 	movhi	r5,2085
 82051d4:	2976ce84 	addi	r5,r5,-9414
 82051d8:	d9403515 	stw	r5,212(sp)
 82051dc:	048001c4 	movi	r18,7
 82051e0:	dd002c17 	ldw	r20,176(sp)
 82051e4:	00000306 	br	82051f4 <___svfprintf_internal_r+0x998>
 82051e8:	843ffc04 	addi	r16,r16,-16
 82051ec:	42000204 	addi	r8,r8,8
 82051f0:	8c00130e 	bge	r17,r16,8205240 <___svfprintf_internal_r+0x9e4>
 82051f4:	01020974 	movhi	r4,2085
 82051f8:	18c00404 	addi	r3,r3,16
 82051fc:	10800044 	addi	r2,r2,1
 8205200:	2136ce84 	addi	r4,r4,-9414
 8205204:	41000015 	stw	r4,0(r8)
 8205208:	44400115 	stw	r17,4(r8)
 820520c:	d8c02015 	stw	r3,128(sp)
 8205210:	d8801f15 	stw	r2,124(sp)
 8205214:	90bff40e 	bge	r18,r2,82051e8 <___svfprintf_internal_r+0x98c>
 8205218:	d9801e04 	addi	r6,sp,120
 820521c:	a00b883a 	mov	r5,r20
 8205220:	9809883a 	mov	r4,r19
 8205224:	820e0880 	call	820e088 <__ssprint_r>
 8205228:	103e711e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 820522c:	843ffc04 	addi	r16,r16,-16
 8205230:	d8c02017 	ldw	r3,128(sp)
 8205234:	d8801f17 	ldw	r2,124(sp)
 8205238:	da000404 	addi	r8,sp,16
 820523c:	8c3fed16 	blt	r17,r16,82051f4 <___svfprintf_internal_r+0x998>
 8205240:	d9403517 	ldw	r5,212(sp)
 8205244:	1c07883a 	add	r3,r3,r16
 8205248:	10800044 	addi	r2,r2,1
 820524c:	41400015 	stw	r5,0(r8)
 8205250:	44000115 	stw	r16,4(r8)
 8205254:	d8c02015 	stw	r3,128(sp)
 8205258:	d8801f15 	stw	r2,124(sp)
 820525c:	010001c4 	movi	r4,7
 8205260:	2080060e 	bge	r4,r2,820527c <___svfprintf_internal_r+0xa20>
 8205264:	d9402c17 	ldw	r5,176(sp)
 8205268:	d9801e04 	addi	r6,sp,120
 820526c:	9809883a 	mov	r4,r19
 8205270:	820e0880 	call	820e088 <__ssprint_r>
 8205274:	103e5e1e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 8205278:	d8c02017 	ldw	r3,128(sp)
 820527c:	d8803117 	ldw	r2,196(sp)
 8205280:	d9002a17 	ldw	r4,168(sp)
 8205284:	1100010e 	bge	r2,r4,820528c <___svfprintf_internal_r+0xa30>
 8205288:	2005883a 	mov	r2,r4
 820528c:	d9402f17 	ldw	r5,188(sp)
 8205290:	288b883a 	add	r5,r5,r2
 8205294:	d9402f15 	stw	r5,188(sp)
 8205298:	18019c1e 	bne	r3,zero,820590c <___svfprintf_internal_r+0x10b0>
 820529c:	b8800007 	ldb	r2,0(r23)
 82052a0:	d8001f15 	stw	zero,124(sp)
 82052a4:	da000404 	addi	r8,sp,16
 82052a8:	103d991e 	bne	r2,zero,8204910 <___svfprintf_internal_r+0xb4>
 82052ac:	b821883a 	mov	r16,r23
 82052b0:	003daf06 	br	8204970 <___svfprintf_internal_r+0x114>
 82052b4:	18c03fcc 	andi	r3,r3,255
 82052b8:	1805c71e 	bne	r3,zero,82069d8 <___svfprintf_internal_r+0x217c>
 82052bc:	94800414 	ori	r18,r18,16
 82052c0:	9080080c 	andi	r2,r18,32
 82052c4:	10020126 	beq	r2,zero,8205acc <___svfprintf_internal_r+0x1270>
 82052c8:	d8802d17 	ldw	r2,180(sp)
 82052cc:	d9002917 	ldw	r4,164(sp)
 82052d0:	d8002785 	stb	zero,158(sp)
 82052d4:	10c00204 	addi	r3,r2,8
 82052d8:	15000017 	ldw	r20,0(r2)
 82052dc:	15800117 	ldw	r22,4(r2)
 82052e0:	20038e16 	blt	r4,zero,820611c <___svfprintf_internal_r+0x18c0>
 82052e4:	013fdfc4 	movi	r4,-129
 82052e8:	a584b03a 	or	r2,r20,r22
 82052ec:	d8c02d15 	stw	r3,180(sp)
 82052f0:	9124703a 	and	r18,r18,r4
 82052f4:	0039883a 	mov	fp,zero
 82052f8:	103eb61e 	bne	r2,zero,8204dd4 <___svfprintf_internal_r+0x578>
 82052fc:	d8802917 	ldw	r2,164(sp)
 8205300:	1002c81e 	bne	r2,zero,8205e24 <___svfprintf_internal_r+0x15c8>
 8205304:	d8002915 	stw	zero,164(sp)
 8205308:	d8002e15 	stw	zero,184(sp)
 820530c:	dc001e04 	addi	r16,sp,120
 8205310:	003efa06 	br	8204efc <___svfprintf_internal_r+0x6a0>
 8205314:	18c03fcc 	andi	r3,r3,255
 8205318:	1805ad1e 	bne	r3,zero,82069d0 <___svfprintf_internal_r+0x2174>
 820531c:	01420974 	movhi	r5,2085
 8205320:	2976be04 	addi	r5,r5,-9480
 8205324:	d9403a15 	stw	r5,232(sp)
 8205328:	9080080c 	andi	r2,r18,32
 820532c:	10006126 	beq	r2,zero,82054b4 <___svfprintf_internal_r+0xc58>
 8205330:	d8802d17 	ldw	r2,180(sp)
 8205334:	15000017 	ldw	r20,0(r2)
 8205338:	15800117 	ldw	r22,4(r2)
 820533c:	10800204 	addi	r2,r2,8
 8205340:	d8802d15 	stw	r2,180(sp)
 8205344:	9080004c 	andi	r2,r18,1
 8205348:	10018e26 	beq	r2,zero,8205984 <___svfprintf_internal_r+0x1128>
 820534c:	a584b03a 	or	r2,r20,r22
 8205350:	10030926 	beq	r2,zero,8205f78 <___svfprintf_internal_r+0x171c>
 8205354:	d8c02917 	ldw	r3,164(sp)
 8205358:	00800c04 	movi	r2,48
 820535c:	d8802705 	stb	r2,156(sp)
 8205360:	dc402745 	stb	r17,157(sp)
 8205364:	d8002785 	stb	zero,158(sp)
 8205368:	90800094 	ori	r2,r18,2
 820536c:	18048716 	blt	r3,zero,820658c <___svfprintf_internal_r+0x1d30>
 8205370:	00bfdfc4 	movi	r2,-129
 8205374:	90a4703a 	and	r18,r18,r2
 8205378:	94800094 	ori	r18,r18,2
 820537c:	0039883a 	mov	fp,zero
 8205380:	d9003a17 	ldw	r4,232(sp)
 8205384:	dc001e04 	addi	r16,sp,120
 8205388:	a08003cc 	andi	r2,r20,15
 820538c:	b006973a 	slli	r3,r22,28
 8205390:	2085883a 	add	r2,r4,r2
 8205394:	a028d13a 	srli	r20,r20,4
 8205398:	10800003 	ldbu	r2,0(r2)
 820539c:	b02cd13a 	srli	r22,r22,4
 82053a0:	843fffc4 	addi	r16,r16,-1
 82053a4:	1d28b03a 	or	r20,r3,r20
 82053a8:	80800005 	stb	r2,0(r16)
 82053ac:	a584b03a 	or	r2,r20,r22
 82053b0:	103ff51e 	bne	r2,zero,8205388 <___svfprintf_internal_r+0xb2c>
 82053b4:	d8c02817 	ldw	r3,160(sp)
 82053b8:	1c07c83a 	sub	r3,r3,r16
 82053bc:	d8c02e15 	stw	r3,184(sp)
 82053c0:	003ece06 	br	8204efc <___svfprintf_internal_r+0x6a0>
 82053c4:	d8c02d17 	ldw	r3,180(sp)
 82053c8:	d9002d17 	ldw	r4,180(sp)
 82053cc:	d8002785 	stb	zero,158(sp)
 82053d0:	18800017 	ldw	r2,0(r3)
 82053d4:	21000104 	addi	r4,r4,4
 82053d8:	00c00044 	movi	r3,1
 82053dc:	d8c02a15 	stw	r3,168(sp)
 82053e0:	d8801405 	stb	r2,80(sp)
 82053e4:	d9002d15 	stw	r4,180(sp)
 82053e8:	d8c02e15 	stw	r3,184(sp)
 82053ec:	d8002915 	stw	zero,164(sp)
 82053f0:	d8003215 	stw	zero,200(sp)
 82053f4:	dc001404 	addi	r16,sp,80
 82053f8:	0039883a 	mov	fp,zero
 82053fc:	003ecc06 	br	8204f30 <___svfprintf_internal_r+0x6d4>
 8205400:	18c03fcc 	andi	r3,r3,255
 8205404:	183e9226 	beq	r3,zero,8204e50 <___svfprintf_internal_r+0x5f4>
 8205408:	d9c02785 	stb	r7,158(sp)
 820540c:	003e9006 	br	8204e50 <___svfprintf_internal_r+0x5f4>
 8205410:	00c00044 	movi	r3,1
 8205414:	01c00ac4 	movi	r7,43
 8205418:	bc400007 	ldb	r17,0(r23)
 820541c:	003d6306 	br	82049ac <___svfprintf_internal_r+0x150>
 8205420:	94800814 	ori	r18,r18,32
 8205424:	bc400007 	ldb	r17,0(r23)
 8205428:	003d6006 	br	82049ac <___svfprintf_internal_r+0x150>
 820542c:	d8c02d17 	ldw	r3,180(sp)
 8205430:	d8002785 	stb	zero,158(sp)
 8205434:	1c000017 	ldw	r16,0(r3)
 8205438:	1d000104 	addi	r20,r3,4
 820543c:	80040f26 	beq	r16,zero,820647c <___svfprintf_internal_r+0x1c20>
 8205440:	d9002917 	ldw	r4,164(sp)
 8205444:	2003dc16 	blt	r4,zero,82063b8 <___svfprintf_internal_r+0x1b5c>
 8205448:	200d883a 	mov	r6,r4
 820544c:	000b883a 	mov	r5,zero
 8205450:	8009883a 	mov	r4,r16
 8205454:	da003e15 	stw	r8,248(sp)
 8205458:	820c4f80 	call	820c4f8 <memchr>
 820545c:	da003e17 	ldw	r8,248(sp)
 8205460:	10045826 	beq	r2,zero,82065c4 <___svfprintf_internal_r+0x1d68>
 8205464:	1405c83a 	sub	r2,r2,r16
 8205468:	d8802e15 	stw	r2,184(sp)
 820546c:	1003d816 	blt	r2,zero,82063d0 <___svfprintf_internal_r+0x1b74>
 8205470:	df002783 	ldbu	fp,158(sp)
 8205474:	d8802a15 	stw	r2,168(sp)
 8205478:	dd002d15 	stw	r20,180(sp)
 820547c:	d8002915 	stw	zero,164(sp)
 8205480:	d8003215 	stw	zero,200(sp)
 8205484:	003ea306 	br	8204f14 <___svfprintf_internal_r+0x6b8>
 8205488:	18c03fcc 	andi	r3,r3,255
 820548c:	183f8c26 	beq	r3,zero,82052c0 <___svfprintf_internal_r+0xa64>
 8205490:	d9c02785 	stb	r7,158(sp)
 8205494:	003f8a06 	br	82052c0 <___svfprintf_internal_r+0xa64>
 8205498:	18c03fcc 	andi	r3,r3,255
 820549c:	1805631e 	bne	r3,zero,8206a2c <___svfprintf_internal_r+0x21d0>
 82054a0:	01420974 	movhi	r5,2085
 82054a4:	2976c304 	addi	r5,r5,-9460
 82054a8:	d9403a15 	stw	r5,232(sp)
 82054ac:	9080080c 	andi	r2,r18,32
 82054b0:	103f9f1e 	bne	r2,zero,8205330 <___svfprintf_internal_r+0xad4>
 82054b4:	9080040c 	andi	r2,r18,16
 82054b8:	10029c26 	beq	r2,zero,8205f2c <___svfprintf_internal_r+0x16d0>
 82054bc:	d8c02d17 	ldw	r3,180(sp)
 82054c0:	002d883a 	mov	r22,zero
 82054c4:	1d000017 	ldw	r20,0(r3)
 82054c8:	18c00104 	addi	r3,r3,4
 82054cc:	d8c02d15 	stw	r3,180(sp)
 82054d0:	003f9c06 	br	8205344 <___svfprintf_internal_r+0xae8>
 82054d4:	94800054 	ori	r18,r18,1
 82054d8:	bc400007 	ldb	r17,0(r23)
 82054dc:	003d3306 	br	82049ac <___svfprintf_internal_r+0x150>
 82054e0:	38803fcc 	andi	r2,r7,255
 82054e4:	1080201c 	xori	r2,r2,128
 82054e8:	10bfe004 	addi	r2,r2,-128
 82054ec:	1002971e 	bne	r2,zero,8205f4c <___svfprintf_internal_r+0x16f0>
 82054f0:	00c00044 	movi	r3,1
 82054f4:	01c00804 	movi	r7,32
 82054f8:	bc400007 	ldb	r17,0(r23)
 82054fc:	003d2b06 	br	82049ac <___svfprintf_internal_r+0x150>
 8205500:	18c03fcc 	andi	r3,r3,255
 8205504:	183e2326 	beq	r3,zero,8204d94 <___svfprintf_internal_r+0x538>
 8205508:	d9c02785 	stb	r7,158(sp)
 820550c:	003e2106 	br	8204d94 <___svfprintf_internal_r+0x538>
 8205510:	bc400007 	ldb	r17,0(r23)
 8205514:	8a430426 	beq	r17,r9,8206128 <___svfprintf_internal_r+0x18cc>
 8205518:	94800414 	ori	r18,r18,16
 820551c:	003d2306 	br	82049ac <___svfprintf_internal_r+0x150>
 8205520:	18c03fcc 	andi	r3,r3,255
 8205524:	18053f1e 	bne	r3,zero,8206a24 <___svfprintf_internal_r+0x21c8>
 8205528:	9080080c 	andi	r2,r18,32
 820552c:	10028926 	beq	r2,zero,8205f54 <___svfprintf_internal_r+0x16f8>
 8205530:	d9402d17 	ldw	r5,180(sp)
 8205534:	d9002f17 	ldw	r4,188(sp)
 8205538:	28800017 	ldw	r2,0(r5)
 820553c:	2007d7fa 	srai	r3,r4,31
 8205540:	29400104 	addi	r5,r5,4
 8205544:	d9402d15 	stw	r5,180(sp)
 8205548:	11000015 	stw	r4,0(r2)
 820554c:	10c00115 	stw	r3,4(r2)
 8205550:	003ced06 	br	8204908 <___svfprintf_internal_r+0xac>
 8205554:	94801014 	ori	r18,r18,64
 8205558:	bc400007 	ldb	r17,0(r23)
 820555c:	003d1306 	br	82049ac <___svfprintf_internal_r+0x150>
 8205560:	01020974 	movhi	r4,2085
 8205564:	2136c304 	addi	r4,r4,-9460
 8205568:	0039883a 	mov	fp,zero
 820556c:	d9003a15 	stw	r4,232(sp)
 8205570:	04401e04 	movi	r17,120
 8205574:	003f8206 	br	8205380 <___svfprintf_internal_r+0xb24>
 8205578:	18c03fcc 	andi	r3,r3,255
 820557c:	1805221e 	bne	r3,zero,8206a08 <___svfprintf_internal_r+0x21ac>
 8205580:	883d9526 	beq	r17,zero,8204bd8 <___svfprintf_internal_r+0x37c>
 8205584:	00c00044 	movi	r3,1
 8205588:	d8c02a15 	stw	r3,168(sp)
 820558c:	dc401405 	stb	r17,80(sp)
 8205590:	d8002785 	stb	zero,158(sp)
 8205594:	003f9406 	br	82053e8 <___svfprintf_internal_r+0xb8c>
 8205598:	01020974 	movhi	r4,2085
 820559c:	2136c304 	addi	r4,r4,-9460
 82055a0:	d9003a15 	stw	r4,232(sp)
 82055a4:	d8c02d15 	stw	r3,180(sp)
 82055a8:	1025883a 	mov	r18,r2
 82055ac:	04401e04 	movi	r17,120
 82055b0:	a584b03a 	or	r2,r20,r22
 82055b4:	1000fa1e 	bne	r2,zero,82059a0 <___svfprintf_internal_r+0x1144>
 82055b8:	0039883a 	mov	fp,zero
 82055bc:	00800084 	movi	r2,2
 82055c0:	10803fcc 	andi	r2,r2,255
 82055c4:	00c00044 	movi	r3,1
 82055c8:	10c21626 	beq	r2,r3,8205e24 <___svfprintf_internal_r+0x15c8>
 82055cc:	00c00084 	movi	r3,2
 82055d0:	10fe301e 	bne	r2,r3,8204e94 <___svfprintf_internal_r+0x638>
 82055d4:	003d7606 	br	8204bb0 <___svfprintf_internal_r+0x354>
 82055d8:	d8c02017 	ldw	r3,128(sp)
 82055dc:	003e9506 	br	8205034 <___svfprintf_internal_r+0x7d8>
 82055e0:	00801944 	movi	r2,101
 82055e4:	14407c0e 	bge	r2,r17,82057d8 <___svfprintf_internal_r+0xf7c>
 82055e8:	d9003617 	ldw	r4,216(sp)
 82055ec:	d9403717 	ldw	r5,220(sp)
 82055f0:	000d883a 	mov	r6,zero
 82055f4:	000f883a 	mov	r7,zero
 82055f8:	d8c03d15 	stw	r3,244(sp)
 82055fc:	da003e15 	stw	r8,248(sp)
 8205600:	8212efc0 	call	8212efc <__eqdf2>
 8205604:	d8c03d17 	ldw	r3,244(sp)
 8205608:	da003e17 	ldw	r8,248(sp)
 820560c:	1000f51e 	bne	r2,zero,82059e4 <___svfprintf_internal_r+0x1188>
 8205610:	d8801f17 	ldw	r2,124(sp)
 8205614:	01020974 	movhi	r4,2085
 8205618:	2136ca04 	addi	r4,r4,-9432
 820561c:	18c00044 	addi	r3,r3,1
 8205620:	10800044 	addi	r2,r2,1
 8205624:	41000015 	stw	r4,0(r8)
 8205628:	01000044 	movi	r4,1
 820562c:	41000115 	stw	r4,4(r8)
 8205630:	d8c02015 	stw	r3,128(sp)
 8205634:	d8801f15 	stw	r2,124(sp)
 8205638:	010001c4 	movi	r4,7
 820563c:	20826616 	blt	r4,r2,8205fd8 <___svfprintf_internal_r+0x177c>
 8205640:	42000204 	addi	r8,r8,8
 8205644:	d8802617 	ldw	r2,152(sp)
 8205648:	d9403317 	ldw	r5,204(sp)
 820564c:	11400216 	blt	r2,r5,8205658 <___svfprintf_internal_r+0xdfc>
 8205650:	9080004c 	andi	r2,r18,1
 8205654:	103ed526 	beq	r2,zero,82051ac <___svfprintf_internal_r+0x950>
 8205658:	d8803817 	ldw	r2,224(sp)
 820565c:	d9003417 	ldw	r4,208(sp)
 8205660:	d9403817 	ldw	r5,224(sp)
 8205664:	1887883a 	add	r3,r3,r2
 8205668:	d8801f17 	ldw	r2,124(sp)
 820566c:	41000015 	stw	r4,0(r8)
 8205670:	41400115 	stw	r5,4(r8)
 8205674:	10800044 	addi	r2,r2,1
 8205678:	d8c02015 	stw	r3,128(sp)
 820567c:	d8801f15 	stw	r2,124(sp)
 8205680:	010001c4 	movi	r4,7
 8205684:	2082af16 	blt	r4,r2,8206144 <___svfprintf_internal_r+0x18e8>
 8205688:	42000204 	addi	r8,r8,8
 820568c:	d8803317 	ldw	r2,204(sp)
 8205690:	143fffc4 	addi	r16,r2,-1
 8205694:	043ec50e 	bge	zero,r16,82051ac <___svfprintf_internal_r+0x950>
 8205698:	04400404 	movi	r17,16
 820569c:	d8801f17 	ldw	r2,124(sp)
 82056a0:	8c00860e 	bge	r17,r16,82058bc <___svfprintf_internal_r+0x1060>
 82056a4:	01420974 	movhi	r5,2085
 82056a8:	2976ca84 	addi	r5,r5,-9430
 82056ac:	d9402b15 	stw	r5,172(sp)
 82056b0:	058001c4 	movi	r22,7
 82056b4:	dd002c17 	ldw	r20,176(sp)
 82056b8:	00000306 	br	82056c8 <___svfprintf_internal_r+0xe6c>
 82056bc:	42000204 	addi	r8,r8,8
 82056c0:	843ffc04 	addi	r16,r16,-16
 82056c4:	8c00800e 	bge	r17,r16,82058c8 <___svfprintf_internal_r+0x106c>
 82056c8:	18c00404 	addi	r3,r3,16
 82056cc:	10800044 	addi	r2,r2,1
 82056d0:	45400015 	stw	r21,0(r8)
 82056d4:	44400115 	stw	r17,4(r8)
 82056d8:	d8c02015 	stw	r3,128(sp)
 82056dc:	d8801f15 	stw	r2,124(sp)
 82056e0:	b0bff60e 	bge	r22,r2,82056bc <___svfprintf_internal_r+0xe60>
 82056e4:	d9801e04 	addi	r6,sp,120
 82056e8:	a00b883a 	mov	r5,r20
 82056ec:	9809883a 	mov	r4,r19
 82056f0:	820e0880 	call	820e088 <__ssprint_r>
 82056f4:	103d3e1e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 82056f8:	d8c02017 	ldw	r3,128(sp)
 82056fc:	d8801f17 	ldw	r2,124(sp)
 8205700:	da000404 	addi	r8,sp,16
 8205704:	003fee06 	br	82056c0 <___svfprintf_internal_r+0xe64>
 8205708:	d9403117 	ldw	r5,196(sp)
 820570c:	d8802a17 	ldw	r2,168(sp)
 8205710:	28adc83a 	sub	r22,r5,r2
 8205714:	05be650e 	bge	zero,r22,82050ac <___svfprintf_internal_r+0x850>
 8205718:	07000404 	movi	fp,16
 820571c:	d8801f17 	ldw	r2,124(sp)
 8205720:	e583a20e 	bge	fp,r22,82065ac <___svfprintf_internal_r+0x1d50>
 8205724:	01420974 	movhi	r5,2085
 8205728:	2976ca84 	addi	r5,r5,-9430
 820572c:	dc403015 	stw	r17,192(sp)
 8205730:	d9402b15 	stw	r5,172(sp)
 8205734:	b023883a 	mov	r17,r22
 8205738:	050001c4 	movi	r20,7
 820573c:	902d883a 	mov	r22,r18
 8205740:	8025883a 	mov	r18,r16
 8205744:	dc002c17 	ldw	r16,176(sp)
 8205748:	00000306 	br	8205758 <___svfprintf_internal_r+0xefc>
 820574c:	8c7ffc04 	addi	r17,r17,-16
 8205750:	42000204 	addi	r8,r8,8
 8205754:	e440110e 	bge	fp,r17,820579c <___svfprintf_internal_r+0xf40>
 8205758:	18c00404 	addi	r3,r3,16
 820575c:	10800044 	addi	r2,r2,1
 8205760:	45400015 	stw	r21,0(r8)
 8205764:	47000115 	stw	fp,4(r8)
 8205768:	d8c02015 	stw	r3,128(sp)
 820576c:	d8801f15 	stw	r2,124(sp)
 8205770:	a0bff60e 	bge	r20,r2,820574c <___svfprintf_internal_r+0xef0>
 8205774:	d9801e04 	addi	r6,sp,120
 8205778:	800b883a 	mov	r5,r16
 820577c:	9809883a 	mov	r4,r19
 8205780:	820e0880 	call	820e088 <__ssprint_r>
 8205784:	103d1a1e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 8205788:	8c7ffc04 	addi	r17,r17,-16
 820578c:	d8c02017 	ldw	r3,128(sp)
 8205790:	d8801f17 	ldw	r2,124(sp)
 8205794:	da000404 	addi	r8,sp,16
 8205798:	e47fef16 	blt	fp,r17,8205758 <___svfprintf_internal_r+0xefc>
 820579c:	9021883a 	mov	r16,r18
 82057a0:	b025883a 	mov	r18,r22
 82057a4:	882d883a 	mov	r22,r17
 82057a8:	dc403017 	ldw	r17,192(sp)
 82057ac:	d9002b17 	ldw	r4,172(sp)
 82057b0:	1d87883a 	add	r3,r3,r22
 82057b4:	10800044 	addi	r2,r2,1
 82057b8:	41000015 	stw	r4,0(r8)
 82057bc:	45800115 	stw	r22,4(r8)
 82057c0:	d8c02015 	stw	r3,128(sp)
 82057c4:	d8801f15 	stw	r2,124(sp)
 82057c8:	010001c4 	movi	r4,7
 82057cc:	20819a16 	blt	r4,r2,8205e38 <___svfprintf_internal_r+0x15dc>
 82057d0:	42000204 	addi	r8,r8,8
 82057d4:	003e3506 	br	82050ac <___svfprintf_internal_r+0x850>
 82057d8:	d9403317 	ldw	r5,204(sp)
 82057dc:	00800044 	movi	r2,1
 82057e0:	18c00044 	addi	r3,r3,1
 82057e4:	1141710e 	bge	r2,r5,8205dac <___svfprintf_internal_r+0x1550>
 82057e8:	dc401f17 	ldw	r17,124(sp)
 82057ec:	00800044 	movi	r2,1
 82057f0:	40800115 	stw	r2,4(r8)
 82057f4:	8c400044 	addi	r17,r17,1
 82057f8:	44000015 	stw	r16,0(r8)
 82057fc:	d8c02015 	stw	r3,128(sp)
 8205800:	dc401f15 	stw	r17,124(sp)
 8205804:	008001c4 	movi	r2,7
 8205808:	14417416 	blt	r2,r17,8205ddc <___svfprintf_internal_r+0x1580>
 820580c:	42000204 	addi	r8,r8,8
 8205810:	d8803817 	ldw	r2,224(sp)
 8205814:	d9003417 	ldw	r4,208(sp)
 8205818:	8c400044 	addi	r17,r17,1
 820581c:	10c7883a 	add	r3,r2,r3
 8205820:	40800115 	stw	r2,4(r8)
 8205824:	41000015 	stw	r4,0(r8)
 8205828:	d8c02015 	stw	r3,128(sp)
 820582c:	dc401f15 	stw	r17,124(sp)
 8205830:	008001c4 	movi	r2,7
 8205834:	14417216 	blt	r2,r17,8205e00 <___svfprintf_internal_r+0x15a4>
 8205838:	45800204 	addi	r22,r8,8
 820583c:	d9003617 	ldw	r4,216(sp)
 8205840:	d9403717 	ldw	r5,220(sp)
 8205844:	000d883a 	mov	r6,zero
 8205848:	000f883a 	mov	r7,zero
 820584c:	d8c03d15 	stw	r3,244(sp)
 8205850:	8212efc0 	call	8212efc <__eqdf2>
 8205854:	d8c03d17 	ldw	r3,244(sp)
 8205858:	1000b326 	beq	r2,zero,8205b28 <___svfprintf_internal_r+0x12cc>
 820585c:	d9403317 	ldw	r5,204(sp)
 8205860:	84000044 	addi	r16,r16,1
 8205864:	8c400044 	addi	r17,r17,1
 8205868:	28bfffc4 	addi	r2,r5,-1
 820586c:	1887883a 	add	r3,r3,r2
 8205870:	b0800115 	stw	r2,4(r22)
 8205874:	b4000015 	stw	r16,0(r22)
 8205878:	d8c02015 	stw	r3,128(sp)
 820587c:	dc401f15 	stw	r17,124(sp)
 8205880:	008001c4 	movi	r2,7
 8205884:	1440d216 	blt	r2,r17,8205bd0 <___svfprintf_internal_r+0x1374>
 8205888:	b5800204 	addi	r22,r22,8
 820588c:	d9003b17 	ldw	r4,236(sp)
 8205890:	df0022c4 	addi	fp,sp,139
 8205894:	8c400044 	addi	r17,r17,1
 8205898:	20c7883a 	add	r3,r4,r3
 820589c:	b7000015 	stw	fp,0(r22)
 82058a0:	b1000115 	stw	r4,4(r22)
 82058a4:	d8c02015 	stw	r3,128(sp)
 82058a8:	dc401f15 	stw	r17,124(sp)
 82058ac:	008001c4 	movi	r2,7
 82058b0:	14400e16 	blt	r2,r17,82058ec <___svfprintf_internal_r+0x1090>
 82058b4:	b2000204 	addi	r8,r22,8
 82058b8:	003e3c06 	br	82051ac <___svfprintf_internal_r+0x950>
 82058bc:	01020974 	movhi	r4,2085
 82058c0:	2136ca84 	addi	r4,r4,-9430
 82058c4:	d9002b15 	stw	r4,172(sp)
 82058c8:	d9002b17 	ldw	r4,172(sp)
 82058cc:	1c07883a 	add	r3,r3,r16
 82058d0:	44000115 	stw	r16,4(r8)
 82058d4:	41000015 	stw	r4,0(r8)
 82058d8:	10800044 	addi	r2,r2,1
 82058dc:	d8c02015 	stw	r3,128(sp)
 82058e0:	d8801f15 	stw	r2,124(sp)
 82058e4:	010001c4 	movi	r4,7
 82058e8:	20be2f0e 	bge	r4,r2,82051a8 <___svfprintf_internal_r+0x94c>
 82058ec:	d9402c17 	ldw	r5,176(sp)
 82058f0:	d9801e04 	addi	r6,sp,120
 82058f4:	9809883a 	mov	r4,r19
 82058f8:	820e0880 	call	820e088 <__ssprint_r>
 82058fc:	103cbc1e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 8205900:	d8c02017 	ldw	r3,128(sp)
 8205904:	da000404 	addi	r8,sp,16
 8205908:	003e2806 	br	82051ac <___svfprintf_internal_r+0x950>
 820590c:	d9402c17 	ldw	r5,176(sp)
 8205910:	d9801e04 	addi	r6,sp,120
 8205914:	9809883a 	mov	r4,r19
 8205918:	820e0880 	call	820e088 <__ssprint_r>
 820591c:	103e5f26 	beq	r2,zero,820529c <___svfprintf_internal_r+0xa40>
 8205920:	003cb306 	br	8204bf0 <___svfprintf_internal_r+0x394>
 8205924:	d9402c17 	ldw	r5,176(sp)
 8205928:	d9801e04 	addi	r6,sp,120
 820592c:	9809883a 	mov	r4,r19
 8205930:	820e0880 	call	820e088 <__ssprint_r>
 8205934:	103cae1e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 8205938:	d8c02017 	ldw	r3,128(sp)
 820593c:	da000404 	addi	r8,sp,16
 8205940:	003e0d06 	br	8205178 <___svfprintf_internal_r+0x91c>
 8205944:	d9402c17 	ldw	r5,176(sp)
 8205948:	d9801e04 	addi	r6,sp,120
 820594c:	9809883a 	mov	r4,r19
 8205950:	820e0880 	call	820e088 <__ssprint_r>
 8205954:	103ca61e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 8205958:	d8c02017 	ldw	r3,128(sp)
 820595c:	da000404 	addi	r8,sp,16
 8205960:	003dc106 	br	8205068 <___svfprintf_internal_r+0x80c>
 8205964:	d9402c17 	ldw	r5,176(sp)
 8205968:	d9801e04 	addi	r6,sp,120
 820596c:	9809883a 	mov	r4,r19
 8205970:	820e0880 	call	820e088 <__ssprint_r>
 8205974:	103c9e1e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 8205978:	d8c02017 	ldw	r3,128(sp)
 820597c:	da000404 	addi	r8,sp,16
 8205980:	003dc706 	br	82050a0 <___svfprintf_internal_r+0x844>
 8205984:	d8802917 	ldw	r2,164(sp)
 8205988:	d8002785 	stb	zero,158(sp)
 820598c:	103f0816 	blt	r2,zero,82055b0 <___svfprintf_internal_r+0xd54>
 8205990:	00ffdfc4 	movi	r3,-129
 8205994:	a584b03a 	or	r2,r20,r22
 8205998:	90e4703a 	and	r18,r18,r3
 820599c:	103c8126 	beq	r2,zero,8204ba4 <___svfprintf_internal_r+0x348>
 82059a0:	0039883a 	mov	fp,zero
 82059a4:	003e7606 	br	8205380 <___svfprintf_internal_r+0xb24>
 82059a8:	9080040c 	andi	r2,r18,16
 82059ac:	10013d26 	beq	r2,zero,8205ea4 <___svfprintf_internal_r+0x1648>
 82059b0:	d9002d17 	ldw	r4,180(sp)
 82059b4:	d9402917 	ldw	r5,164(sp)
 82059b8:	d8002785 	stb	zero,158(sp)
 82059bc:	20800104 	addi	r2,r4,4
 82059c0:	25000017 	ldw	r20,0(r4)
 82059c4:	002d883a 	mov	r22,zero
 82059c8:	28013f16 	blt	r5,zero,8205ec8 <___svfprintf_internal_r+0x166c>
 82059cc:	00ffdfc4 	movi	r3,-129
 82059d0:	d8802d15 	stw	r2,180(sp)
 82059d4:	90e4703a 	and	r18,r18,r3
 82059d8:	a03d2b26 	beq	r20,zero,8204e88 <___svfprintf_internal_r+0x62c>
 82059dc:	0039883a 	mov	fp,zero
 82059e0:	003d2e06 	br	8204e9c <___svfprintf_internal_r+0x640>
 82059e4:	dc402617 	ldw	r17,152(sp)
 82059e8:	0441830e 	bge	zero,r17,8205ff8 <___svfprintf_internal_r+0x179c>
 82059ec:	dc403217 	ldw	r17,200(sp)
 82059f0:	d8803317 	ldw	r2,204(sp)
 82059f4:	1440010e 	bge	r2,r17,82059fc <___svfprintf_internal_r+0x11a0>
 82059f8:	1023883a 	mov	r17,r2
 82059fc:	04400a0e 	bge	zero,r17,8205a28 <___svfprintf_internal_r+0x11cc>
 8205a00:	d8801f17 	ldw	r2,124(sp)
 8205a04:	1c47883a 	add	r3,r3,r17
 8205a08:	44000015 	stw	r16,0(r8)
 8205a0c:	10800044 	addi	r2,r2,1
 8205a10:	44400115 	stw	r17,4(r8)
 8205a14:	d8c02015 	stw	r3,128(sp)
 8205a18:	d8801f15 	stw	r2,124(sp)
 8205a1c:	010001c4 	movi	r4,7
 8205a20:	20827516 	blt	r4,r2,82063f8 <___svfprintf_internal_r+0x1b9c>
 8205a24:	42000204 	addi	r8,r8,8
 8205a28:	88027b16 	blt	r17,zero,8206418 <___svfprintf_internal_r+0x1bbc>
 8205a2c:	d9003217 	ldw	r4,200(sp)
 8205a30:	2463c83a 	sub	r17,r4,r17
 8205a34:	0440990e 	bge	zero,r17,8205c9c <___svfprintf_internal_r+0x1440>
 8205a38:	05800404 	movi	r22,16
 8205a3c:	d8801f17 	ldw	r2,124(sp)
 8205a40:	b441530e 	bge	r22,r17,8205f90 <___svfprintf_internal_r+0x1734>
 8205a44:	01020974 	movhi	r4,2085
 8205a48:	2136ca84 	addi	r4,r4,-9430
 8205a4c:	d9002b15 	stw	r4,172(sp)
 8205a50:	070001c4 	movi	fp,7
 8205a54:	dd002c17 	ldw	r20,176(sp)
 8205a58:	00000306 	br	8205a68 <___svfprintf_internal_r+0x120c>
 8205a5c:	42000204 	addi	r8,r8,8
 8205a60:	8c7ffc04 	addi	r17,r17,-16
 8205a64:	b4414d0e 	bge	r22,r17,8205f9c <___svfprintf_internal_r+0x1740>
 8205a68:	18c00404 	addi	r3,r3,16
 8205a6c:	10800044 	addi	r2,r2,1
 8205a70:	45400015 	stw	r21,0(r8)
 8205a74:	45800115 	stw	r22,4(r8)
 8205a78:	d8c02015 	stw	r3,128(sp)
 8205a7c:	d8801f15 	stw	r2,124(sp)
 8205a80:	e0bff60e 	bge	fp,r2,8205a5c <___svfprintf_internal_r+0x1200>
 8205a84:	d9801e04 	addi	r6,sp,120
 8205a88:	a00b883a 	mov	r5,r20
 8205a8c:	9809883a 	mov	r4,r19
 8205a90:	820e0880 	call	820e088 <__ssprint_r>
 8205a94:	103c561e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 8205a98:	d8c02017 	ldw	r3,128(sp)
 8205a9c:	d8801f17 	ldw	r2,124(sp)
 8205aa0:	da000404 	addi	r8,sp,16
 8205aa4:	003fee06 	br	8205a60 <___svfprintf_internal_r+0x1204>
 8205aa8:	d9402c17 	ldw	r5,176(sp)
 8205aac:	d9801e04 	addi	r6,sp,120
 8205ab0:	9809883a 	mov	r4,r19
 8205ab4:	820e0880 	call	820e088 <__ssprint_r>
 8205ab8:	103c4d1e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 8205abc:	d8c02017 	ldw	r3,128(sp)
 8205ac0:	df002787 	ldb	fp,158(sp)
 8205ac4:	da000404 	addi	r8,sp,16
 8205ac8:	003d5a06 	br	8205034 <___svfprintf_internal_r+0x7d8>
 8205acc:	9080040c 	andi	r2,r18,16
 8205ad0:	10005c26 	beq	r2,zero,8205c44 <___svfprintf_internal_r+0x13e8>
 8205ad4:	d9402d17 	ldw	r5,180(sp)
 8205ad8:	d8c02917 	ldw	r3,164(sp)
 8205adc:	d8002785 	stb	zero,158(sp)
 8205ae0:	28800104 	addi	r2,r5,4
 8205ae4:	2d000017 	ldw	r20,0(r5)
 8205ae8:	002d883a 	mov	r22,zero
 8205aec:	18005e16 	blt	r3,zero,8205c68 <___svfprintf_internal_r+0x140c>
 8205af0:	00ffdfc4 	movi	r3,-129
 8205af4:	d8802d15 	stw	r2,180(sp)
 8205af8:	90e4703a 	and	r18,r18,r3
 8205afc:	0039883a 	mov	fp,zero
 8205b00:	a03dfe26 	beq	r20,zero,82052fc <___svfprintf_internal_r+0xaa0>
 8205b04:	00800244 	movi	r2,9
 8205b08:	153cb336 	bltu	r2,r20,8204dd8 <___svfprintf_internal_r+0x57c>
 8205b0c:	a5000c04 	addi	r20,r20,48
 8205b10:	dc001dc4 	addi	r16,sp,119
 8205b14:	dd001dc5 	stb	r20,119(sp)
 8205b18:	d8c02817 	ldw	r3,160(sp)
 8205b1c:	1c07c83a 	sub	r3,r3,r16
 8205b20:	d8c02e15 	stw	r3,184(sp)
 8205b24:	003cf506 	br	8204efc <___svfprintf_internal_r+0x6a0>
 8205b28:	d8803317 	ldw	r2,204(sp)
 8205b2c:	143fffc4 	addi	r16,r2,-1
 8205b30:	043f560e 	bge	zero,r16,820588c <___svfprintf_internal_r+0x1030>
 8205b34:	07000404 	movi	fp,16
 8205b38:	e403530e 	bge	fp,r16,8206888 <___svfprintf_internal_r+0x202c>
 8205b3c:	01420974 	movhi	r5,2085
 8205b40:	2976ca84 	addi	r5,r5,-9430
 8205b44:	d9402b15 	stw	r5,172(sp)
 8205b48:	01c001c4 	movi	r7,7
 8205b4c:	dd002c17 	ldw	r20,176(sp)
 8205b50:	00000306 	br	8205b60 <___svfprintf_internal_r+0x1304>
 8205b54:	843ffc04 	addi	r16,r16,-16
 8205b58:	b5800204 	addi	r22,r22,8
 8205b5c:	e400130e 	bge	fp,r16,8205bac <___svfprintf_internal_r+0x1350>
 8205b60:	18c00404 	addi	r3,r3,16
 8205b64:	8c400044 	addi	r17,r17,1
 8205b68:	b5400015 	stw	r21,0(r22)
 8205b6c:	b7000115 	stw	fp,4(r22)
 8205b70:	d8c02015 	stw	r3,128(sp)
 8205b74:	dc401f15 	stw	r17,124(sp)
 8205b78:	3c7ff60e 	bge	r7,r17,8205b54 <___svfprintf_internal_r+0x12f8>
 8205b7c:	d9801e04 	addi	r6,sp,120
 8205b80:	a00b883a 	mov	r5,r20
 8205b84:	9809883a 	mov	r4,r19
 8205b88:	d9c03d15 	stw	r7,244(sp)
 8205b8c:	820e0880 	call	820e088 <__ssprint_r>
 8205b90:	d9c03d17 	ldw	r7,244(sp)
 8205b94:	103c161e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 8205b98:	843ffc04 	addi	r16,r16,-16
 8205b9c:	d8c02017 	ldw	r3,128(sp)
 8205ba0:	dc401f17 	ldw	r17,124(sp)
 8205ba4:	dd800404 	addi	r22,sp,16
 8205ba8:	e43fed16 	blt	fp,r16,8205b60 <___svfprintf_internal_r+0x1304>
 8205bac:	d8802b17 	ldw	r2,172(sp)
 8205bb0:	1c07883a 	add	r3,r3,r16
 8205bb4:	8c400044 	addi	r17,r17,1
 8205bb8:	b0800015 	stw	r2,0(r22)
 8205bbc:	b4000115 	stw	r16,4(r22)
 8205bc0:	d8c02015 	stw	r3,128(sp)
 8205bc4:	dc401f15 	stw	r17,124(sp)
 8205bc8:	008001c4 	movi	r2,7
 8205bcc:	147f2e0e 	bge	r2,r17,8205888 <___svfprintf_internal_r+0x102c>
 8205bd0:	d9402c17 	ldw	r5,176(sp)
 8205bd4:	d9801e04 	addi	r6,sp,120
 8205bd8:	9809883a 	mov	r4,r19
 8205bdc:	820e0880 	call	820e088 <__ssprint_r>
 8205be0:	103c031e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 8205be4:	d8c02017 	ldw	r3,128(sp)
 8205be8:	dc401f17 	ldw	r17,124(sp)
 8205bec:	dd800404 	addi	r22,sp,16
 8205bf0:	003f2606 	br	820588c <___svfprintf_internal_r+0x1030>
 8205bf4:	9080040c 	andi	r2,r18,16
 8205bf8:	1000c326 	beq	r2,zero,8205f08 <___svfprintf_internal_r+0x16ac>
 8205bfc:	d8802d17 	ldw	r2,180(sp)
 8205c00:	15000017 	ldw	r20,0(r2)
 8205c04:	10800104 	addi	r2,r2,4
 8205c08:	d8802d15 	stw	r2,180(sp)
 8205c0c:	a02dd7fa 	srai	r22,r20,31
 8205c10:	b005883a 	mov	r2,r22
 8205c14:	103c680e 	bge	r2,zero,8204db8 <___svfprintf_internal_r+0x55c>
 8205c18:	0529c83a 	sub	r20,zero,r20
 8205c1c:	a004c03a 	cmpne	r2,r20,zero
 8205c20:	05adc83a 	sub	r22,zero,r22
 8205c24:	b0adc83a 	sub	r22,r22,r2
 8205c28:	d8802917 	ldw	r2,164(sp)
 8205c2c:	07000b44 	movi	fp,45
 8205c30:	df002785 	stb	fp,158(sp)
 8205c34:	10022e16 	blt	r2,zero,82064f0 <___svfprintf_internal_r+0x1c94>
 8205c38:	00bfdfc4 	movi	r2,-129
 8205c3c:	90a4703a 	and	r18,r18,r2
 8205c40:	003c6406 	br	8204dd4 <___svfprintf_internal_r+0x578>
 8205c44:	9080100c 	andi	r2,r18,64
 8205c48:	d8002785 	stb	zero,158(sp)
 8205c4c:	10012526 	beq	r2,zero,82060e4 <___svfprintf_internal_r+0x1888>
 8205c50:	d9002d17 	ldw	r4,180(sp)
 8205c54:	d9402917 	ldw	r5,164(sp)
 8205c58:	002d883a 	mov	r22,zero
 8205c5c:	20800104 	addi	r2,r4,4
 8205c60:	2500000b 	ldhu	r20,0(r4)
 8205c64:	283fa20e 	bge	r5,zero,8205af0 <___svfprintf_internal_r+0x1294>
 8205c68:	d8802d15 	stw	r2,180(sp)
 8205c6c:	0039883a 	mov	fp,zero
 8205c70:	a584b03a 	or	r2,r20,r22
 8205c74:	103c571e 	bne	r2,zero,8204dd4 <___svfprintf_internal_r+0x578>
 8205c78:	00800044 	movi	r2,1
 8205c7c:	003e5006 	br	82055c0 <___svfprintf_internal_r+0xd64>
 8205c80:	d9402c17 	ldw	r5,176(sp)
 8205c84:	d9801e04 	addi	r6,sp,120
 8205c88:	9809883a 	mov	r4,r19
 8205c8c:	820e0880 	call	820e088 <__ssprint_r>
 8205c90:	103bd71e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 8205c94:	d8c02017 	ldw	r3,128(sp)
 8205c98:	da000404 	addi	r8,sp,16
 8205c9c:	d9003217 	ldw	r4,200(sp)
 8205ca0:	d8802617 	ldw	r2,152(sp)
 8205ca4:	d9403317 	ldw	r5,204(sp)
 8205ca8:	8123883a 	add	r17,r16,r4
 8205cac:	11400216 	blt	r2,r5,8205cb8 <___svfprintf_internal_r+0x145c>
 8205cb0:	9100004c 	andi	r4,r18,1
 8205cb4:	20000d26 	beq	r4,zero,8205cec <___svfprintf_internal_r+0x1490>
 8205cb8:	d9003817 	ldw	r4,224(sp)
 8205cbc:	d9403417 	ldw	r5,208(sp)
 8205cc0:	1907883a 	add	r3,r3,r4
 8205cc4:	d9001f17 	ldw	r4,124(sp)
 8205cc8:	41400015 	stw	r5,0(r8)
 8205ccc:	d9403817 	ldw	r5,224(sp)
 8205cd0:	21000044 	addi	r4,r4,1
 8205cd4:	d8c02015 	stw	r3,128(sp)
 8205cd8:	41400115 	stw	r5,4(r8)
 8205cdc:	d9001f15 	stw	r4,124(sp)
 8205ce0:	014001c4 	movi	r5,7
 8205ce4:	2901dc16 	blt	r5,r4,8206458 <___svfprintf_internal_r+0x1bfc>
 8205ce8:	42000204 	addi	r8,r8,8
 8205cec:	d9003317 	ldw	r4,204(sp)
 8205cf0:	8121883a 	add	r16,r16,r4
 8205cf4:	2085c83a 	sub	r2,r4,r2
 8205cf8:	8461c83a 	sub	r16,r16,r17
 8205cfc:	1400010e 	bge	r2,r16,8205d04 <___svfprintf_internal_r+0x14a8>
 8205d00:	1021883a 	mov	r16,r2
 8205d04:	04000a0e 	bge	zero,r16,8205d30 <___svfprintf_internal_r+0x14d4>
 8205d08:	d9001f17 	ldw	r4,124(sp)
 8205d0c:	1c07883a 	add	r3,r3,r16
 8205d10:	44400015 	stw	r17,0(r8)
 8205d14:	21000044 	addi	r4,r4,1
 8205d18:	44000115 	stw	r16,4(r8)
 8205d1c:	d8c02015 	stw	r3,128(sp)
 8205d20:	d9001f15 	stw	r4,124(sp)
 8205d24:	014001c4 	movi	r5,7
 8205d28:	2901e616 	blt	r5,r4,82064c4 <___svfprintf_internal_r+0x1c68>
 8205d2c:	42000204 	addi	r8,r8,8
 8205d30:	8001f616 	blt	r16,zero,820650c <___svfprintf_internal_r+0x1cb0>
 8205d34:	1421c83a 	sub	r16,r2,r16
 8205d38:	043d1c0e 	bge	zero,r16,82051ac <___svfprintf_internal_r+0x950>
 8205d3c:	04400404 	movi	r17,16
 8205d40:	d8801f17 	ldw	r2,124(sp)
 8205d44:	8c3edd0e 	bge	r17,r16,82058bc <___svfprintf_internal_r+0x1060>
 8205d48:	01420974 	movhi	r5,2085
 8205d4c:	2976ca84 	addi	r5,r5,-9430
 8205d50:	d9402b15 	stw	r5,172(sp)
 8205d54:	058001c4 	movi	r22,7
 8205d58:	dd002c17 	ldw	r20,176(sp)
 8205d5c:	00000306 	br	8205d6c <___svfprintf_internal_r+0x1510>
 8205d60:	42000204 	addi	r8,r8,8
 8205d64:	843ffc04 	addi	r16,r16,-16
 8205d68:	8c3ed70e 	bge	r17,r16,82058c8 <___svfprintf_internal_r+0x106c>
 8205d6c:	18c00404 	addi	r3,r3,16
 8205d70:	10800044 	addi	r2,r2,1
 8205d74:	45400015 	stw	r21,0(r8)
 8205d78:	44400115 	stw	r17,4(r8)
 8205d7c:	d8c02015 	stw	r3,128(sp)
 8205d80:	d8801f15 	stw	r2,124(sp)
 8205d84:	b0bff60e 	bge	r22,r2,8205d60 <___svfprintf_internal_r+0x1504>
 8205d88:	d9801e04 	addi	r6,sp,120
 8205d8c:	a00b883a 	mov	r5,r20
 8205d90:	9809883a 	mov	r4,r19
 8205d94:	820e0880 	call	820e088 <__ssprint_r>
 8205d98:	103b951e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 8205d9c:	d8c02017 	ldw	r3,128(sp)
 8205da0:	d8801f17 	ldw	r2,124(sp)
 8205da4:	da000404 	addi	r8,sp,16
 8205da8:	003fee06 	br	8205d64 <___svfprintf_internal_r+0x1508>
 8205dac:	9088703a 	and	r4,r18,r2
 8205db0:	203e8d1e 	bne	r4,zero,82057e8 <___svfprintf_internal_r+0xf8c>
 8205db4:	dc401f17 	ldw	r17,124(sp)
 8205db8:	40800115 	stw	r2,4(r8)
 8205dbc:	44000015 	stw	r16,0(r8)
 8205dc0:	8c400044 	addi	r17,r17,1
 8205dc4:	d8c02015 	stw	r3,128(sp)
 8205dc8:	dc401f15 	stw	r17,124(sp)
 8205dcc:	008001c4 	movi	r2,7
 8205dd0:	147f7f16 	blt	r2,r17,8205bd0 <___svfprintf_internal_r+0x1374>
 8205dd4:	45800204 	addi	r22,r8,8
 8205dd8:	003eac06 	br	820588c <___svfprintf_internal_r+0x1030>
 8205ddc:	d9402c17 	ldw	r5,176(sp)
 8205de0:	d9801e04 	addi	r6,sp,120
 8205de4:	9809883a 	mov	r4,r19
 8205de8:	820e0880 	call	820e088 <__ssprint_r>
 8205dec:	103b801e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 8205df0:	d8c02017 	ldw	r3,128(sp)
 8205df4:	dc401f17 	ldw	r17,124(sp)
 8205df8:	da000404 	addi	r8,sp,16
 8205dfc:	003e8406 	br	8205810 <___svfprintf_internal_r+0xfb4>
 8205e00:	d9402c17 	ldw	r5,176(sp)
 8205e04:	d9801e04 	addi	r6,sp,120
 8205e08:	9809883a 	mov	r4,r19
 8205e0c:	820e0880 	call	820e088 <__ssprint_r>
 8205e10:	103b771e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 8205e14:	d8c02017 	ldw	r3,128(sp)
 8205e18:	dc401f17 	ldw	r17,124(sp)
 8205e1c:	dd800404 	addi	r22,sp,16
 8205e20:	003e8606 	br	820583c <___svfprintf_internal_r+0xfe0>
 8205e24:	0029883a 	mov	r20,zero
 8205e28:	a5000c04 	addi	r20,r20,48
 8205e2c:	dc001dc4 	addi	r16,sp,119
 8205e30:	dd001dc5 	stb	r20,119(sp)
 8205e34:	003f3806 	br	8205b18 <___svfprintf_internal_r+0x12bc>
 8205e38:	d9402c17 	ldw	r5,176(sp)
 8205e3c:	d9801e04 	addi	r6,sp,120
 8205e40:	9809883a 	mov	r4,r19
 8205e44:	820e0880 	call	820e088 <__ssprint_r>
 8205e48:	103b691e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 8205e4c:	d8c02017 	ldw	r3,128(sp)
 8205e50:	da000404 	addi	r8,sp,16
 8205e54:	003c9506 	br	82050ac <___svfprintf_internal_r+0x850>
 8205e58:	d9003617 	ldw	r4,216(sp)
 8205e5c:	d9403717 	ldw	r5,220(sp)
 8205e60:	da003e15 	stw	r8,248(sp)
 8205e64:	820dda80 	call	820dda8 <__fpclassifyd>
 8205e68:	da003e17 	ldw	r8,248(sp)
 8205e6c:	1000bd1e 	bne	r2,zero,8206164 <___svfprintf_internal_r+0x1908>
 8205e70:	008011c4 	movi	r2,71
 8205e74:	14411e0e 	bge	r2,r17,82062f0 <___svfprintf_internal_r+0x1a94>
 8205e78:	04020974 	movhi	r16,2085
 8205e7c:	8436bd04 	addi	r16,r16,-9484
 8205e80:	00c000c4 	movi	r3,3
 8205e84:	00bfdfc4 	movi	r2,-129
 8205e88:	d8c02a15 	stw	r3,168(sp)
 8205e8c:	90a4703a 	and	r18,r18,r2
 8205e90:	df002783 	ldbu	fp,158(sp)
 8205e94:	d8c02e15 	stw	r3,184(sp)
 8205e98:	d8002915 	stw	zero,164(sp)
 8205e9c:	d8003215 	stw	zero,200(sp)
 8205ea0:	003c1c06 	br	8204f14 <___svfprintf_internal_r+0x6b8>
 8205ea4:	9080100c 	andi	r2,r18,64
 8205ea8:	d8002785 	stb	zero,158(sp)
 8205eac:	10009426 	beq	r2,zero,8206100 <___svfprintf_internal_r+0x18a4>
 8205eb0:	d8c02d17 	ldw	r3,180(sp)
 8205eb4:	d9002917 	ldw	r4,164(sp)
 8205eb8:	002d883a 	mov	r22,zero
 8205ebc:	18800104 	addi	r2,r3,4
 8205ec0:	1d00000b 	ldhu	r20,0(r3)
 8205ec4:	203ec10e 	bge	r4,zero,82059cc <___svfprintf_internal_r+0x1170>
 8205ec8:	a586b03a 	or	r3,r20,r22
 8205ecc:	d8802d15 	stw	r2,180(sp)
 8205ed0:	183ec21e 	bne	r3,zero,82059dc <___svfprintf_internal_r+0x1180>
 8205ed4:	0039883a 	mov	fp,zero
 8205ed8:	0005883a 	mov	r2,zero
 8205edc:	003db806 	br	82055c0 <___svfprintf_internal_r+0xd64>
 8205ee0:	d8802d17 	ldw	r2,180(sp)
 8205ee4:	d8c02d17 	ldw	r3,180(sp)
 8205ee8:	d9002d17 	ldw	r4,180(sp)
 8205eec:	10800017 	ldw	r2,0(r2)
 8205ef0:	18c00117 	ldw	r3,4(r3)
 8205ef4:	21000204 	addi	r4,r4,8
 8205ef8:	d8803615 	stw	r2,216(sp)
 8205efc:	d8c03715 	stw	r3,220(sp)
 8205f00:	d9002d15 	stw	r4,180(sp)
 8205f04:	003b8206 	br	8204d10 <___svfprintf_internal_r+0x4b4>
 8205f08:	9080100c 	andi	r2,r18,64
 8205f0c:	10010726 	beq	r2,zero,820632c <___svfprintf_internal_r+0x1ad0>
 8205f10:	d8c02d17 	ldw	r3,180(sp)
 8205f14:	1d00000f 	ldh	r20,0(r3)
 8205f18:	18c00104 	addi	r3,r3,4
 8205f1c:	d8c02d15 	stw	r3,180(sp)
 8205f20:	a02dd7fa 	srai	r22,r20,31
 8205f24:	b005883a 	mov	r2,r22
 8205f28:	003ba206 	br	8204db4 <___svfprintf_internal_r+0x558>
 8205f2c:	9080100c 	andi	r2,r18,64
 8205f30:	10010526 	beq	r2,zero,8206348 <___svfprintf_internal_r+0x1aec>
 8205f34:	d9002d17 	ldw	r4,180(sp)
 8205f38:	002d883a 	mov	r22,zero
 8205f3c:	2500000b 	ldhu	r20,0(r4)
 8205f40:	21000104 	addi	r4,r4,4
 8205f44:	d9002d15 	stw	r4,180(sp)
 8205f48:	003cfe06 	br	8205344 <___svfprintf_internal_r+0xae8>
 8205f4c:	bc400007 	ldb	r17,0(r23)
 8205f50:	003a9606 	br	82049ac <___svfprintf_internal_r+0x150>
 8205f54:	9080040c 	andi	r2,r18,16
 8205f58:	10010126 	beq	r2,zero,8206360 <___svfprintf_internal_r+0x1b04>
 8205f5c:	d9402d17 	ldw	r5,180(sp)
 8205f60:	d8c02f17 	ldw	r3,188(sp)
 8205f64:	28800017 	ldw	r2,0(r5)
 8205f68:	29400104 	addi	r5,r5,4
 8205f6c:	d9402d15 	stw	r5,180(sp)
 8205f70:	10c00015 	stw	r3,0(r2)
 8205f74:	003a6406 	br	8204908 <___svfprintf_internal_r+0xac>
 8205f78:	d9002917 	ldw	r4,164(sp)
 8205f7c:	d8002785 	stb	zero,158(sp)
 8205f80:	203d8d16 	blt	r4,zero,82055b8 <___svfprintf_internal_r+0xd5c>
 8205f84:	00bfdfc4 	movi	r2,-129
 8205f88:	90a4703a 	and	r18,r18,r2
 8205f8c:	003b0506 	br	8204ba4 <___svfprintf_internal_r+0x348>
 8205f90:	01420974 	movhi	r5,2085
 8205f94:	2976ca84 	addi	r5,r5,-9430
 8205f98:	d9402b15 	stw	r5,172(sp)
 8205f9c:	d9402b17 	ldw	r5,172(sp)
 8205fa0:	1c47883a 	add	r3,r3,r17
 8205fa4:	10800044 	addi	r2,r2,1
 8205fa8:	41400015 	stw	r5,0(r8)
 8205fac:	44400115 	stw	r17,4(r8)
 8205fb0:	d8c02015 	stw	r3,128(sp)
 8205fb4:	d8801f15 	stw	r2,124(sp)
 8205fb8:	010001c4 	movi	r4,7
 8205fbc:	20bf3016 	blt	r4,r2,8205c80 <___svfprintf_internal_r+0x1424>
 8205fc0:	42000204 	addi	r8,r8,8
 8205fc4:	003f3506 	br	8205c9c <___svfprintf_internal_r+0x1440>
 8205fc8:	01020974 	movhi	r4,2085
 8205fcc:	2136ca84 	addi	r4,r4,-9430
 8205fd0:	d9002b15 	stw	r4,172(sp)
 8205fd4:	003c5e06 	br	8205150 <___svfprintf_internal_r+0x8f4>
 8205fd8:	d9402c17 	ldw	r5,176(sp)
 8205fdc:	d9801e04 	addi	r6,sp,120
 8205fe0:	9809883a 	mov	r4,r19
 8205fe4:	820e0880 	call	820e088 <__ssprint_r>
 8205fe8:	103b011e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 8205fec:	d8c02017 	ldw	r3,128(sp)
 8205ff0:	da000404 	addi	r8,sp,16
 8205ff4:	003d9306 	br	8205644 <___svfprintf_internal_r+0xde8>
 8205ff8:	d8801f17 	ldw	r2,124(sp)
 8205ffc:	01420974 	movhi	r5,2085
 8206000:	01000044 	movi	r4,1
 8206004:	18c00044 	addi	r3,r3,1
 8206008:	10800044 	addi	r2,r2,1
 820600c:	2976ca04 	addi	r5,r5,-9432
 8206010:	41000115 	stw	r4,4(r8)
 8206014:	41400015 	stw	r5,0(r8)
 8206018:	d8c02015 	stw	r3,128(sp)
 820601c:	d8801f15 	stw	r2,124(sp)
 8206020:	010001c4 	movi	r4,7
 8206024:	2080b516 	blt	r4,r2,82062fc <___svfprintf_internal_r+0x1aa0>
 8206028:	42000204 	addi	r8,r8,8
 820602c:	8800041e 	bne	r17,zero,8206040 <___svfprintf_internal_r+0x17e4>
 8206030:	d8803317 	ldw	r2,204(sp)
 8206034:	1000021e 	bne	r2,zero,8206040 <___svfprintf_internal_r+0x17e4>
 8206038:	9080004c 	andi	r2,r18,1
 820603c:	103c5b26 	beq	r2,zero,82051ac <___svfprintf_internal_r+0x950>
 8206040:	d9003817 	ldw	r4,224(sp)
 8206044:	d8801f17 	ldw	r2,124(sp)
 8206048:	d9403417 	ldw	r5,208(sp)
 820604c:	20c7883a 	add	r3,r4,r3
 8206050:	10800044 	addi	r2,r2,1
 8206054:	41000115 	stw	r4,4(r8)
 8206058:	41400015 	stw	r5,0(r8)
 820605c:	d8c02015 	stw	r3,128(sp)
 8206060:	d8801f15 	stw	r2,124(sp)
 8206064:	010001c4 	movi	r4,7
 8206068:	20818016 	blt	r4,r2,820666c <___svfprintf_internal_r+0x1e10>
 820606c:	42000204 	addi	r8,r8,8
 8206070:	0463c83a 	sub	r17,zero,r17
 8206074:	0440cb0e 	bge	zero,r17,82063a4 <___svfprintf_internal_r+0x1b48>
 8206078:	05800404 	movi	r22,16
 820607c:	b440e80e 	bge	r22,r17,8206420 <___svfprintf_internal_r+0x1bc4>
 8206080:	01420974 	movhi	r5,2085
 8206084:	2976ca84 	addi	r5,r5,-9430
 8206088:	d9402b15 	stw	r5,172(sp)
 820608c:	070001c4 	movi	fp,7
 8206090:	dd002c17 	ldw	r20,176(sp)
 8206094:	00000306 	br	82060a4 <___svfprintf_internal_r+0x1848>
 8206098:	42000204 	addi	r8,r8,8
 820609c:	8c7ffc04 	addi	r17,r17,-16
 82060a0:	b440e20e 	bge	r22,r17,820642c <___svfprintf_internal_r+0x1bd0>
 82060a4:	18c00404 	addi	r3,r3,16
 82060a8:	10800044 	addi	r2,r2,1
 82060ac:	45400015 	stw	r21,0(r8)
 82060b0:	45800115 	stw	r22,4(r8)
 82060b4:	d8c02015 	stw	r3,128(sp)
 82060b8:	d8801f15 	stw	r2,124(sp)
 82060bc:	e0bff60e 	bge	fp,r2,8206098 <___svfprintf_internal_r+0x183c>
 82060c0:	d9801e04 	addi	r6,sp,120
 82060c4:	a00b883a 	mov	r5,r20
 82060c8:	9809883a 	mov	r4,r19
 82060cc:	820e0880 	call	820e088 <__ssprint_r>
 82060d0:	103ac71e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 82060d4:	d8c02017 	ldw	r3,128(sp)
 82060d8:	d8801f17 	ldw	r2,124(sp)
 82060dc:	da000404 	addi	r8,sp,16
 82060e0:	003fee06 	br	820609c <___svfprintf_internal_r+0x1840>
 82060e4:	d8c02d17 	ldw	r3,180(sp)
 82060e8:	d9002917 	ldw	r4,164(sp)
 82060ec:	002d883a 	mov	r22,zero
 82060f0:	18800104 	addi	r2,r3,4
 82060f4:	1d000017 	ldw	r20,0(r3)
 82060f8:	203e7d0e 	bge	r4,zero,8205af0 <___svfprintf_internal_r+0x1294>
 82060fc:	003eda06 	br	8205c68 <___svfprintf_internal_r+0x140c>
 8206100:	d9402d17 	ldw	r5,180(sp)
 8206104:	d8c02917 	ldw	r3,164(sp)
 8206108:	002d883a 	mov	r22,zero
 820610c:	28800104 	addi	r2,r5,4
 8206110:	2d000017 	ldw	r20,0(r5)
 8206114:	183e2d0e 	bge	r3,zero,82059cc <___svfprintf_internal_r+0x1170>
 8206118:	003f6b06 	br	8205ec8 <___svfprintf_internal_r+0x166c>
 820611c:	d8c02d15 	stw	r3,180(sp)
 8206120:	0039883a 	mov	fp,zero
 8206124:	003ed206 	br	8205c70 <___svfprintf_internal_r+0x1414>
 8206128:	bc400043 	ldbu	r17,1(r23)
 820612c:	94800814 	ori	r18,r18,32
 8206130:	bdc00044 	addi	r23,r23,1
 8206134:	8c403fcc 	andi	r17,r17,255
 8206138:	8c40201c 	xori	r17,r17,128
 820613c:	8c7fe004 	addi	r17,r17,-128
 8206140:	003a1a06 	br	82049ac <___svfprintf_internal_r+0x150>
 8206144:	d9402c17 	ldw	r5,176(sp)
 8206148:	d9801e04 	addi	r6,sp,120
 820614c:	9809883a 	mov	r4,r19
 8206150:	820e0880 	call	820e088 <__ssprint_r>
 8206154:	103aa61e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 8206158:	d8c02017 	ldw	r3,128(sp)
 820615c:	da000404 	addi	r8,sp,16
 8206160:	003d4a06 	br	820568c <___svfprintf_internal_r+0xe30>
 8206164:	d9002917 	ldw	r4,164(sp)
 8206168:	05bff7c4 	movi	r22,-33
 820616c:	00bfffc4 	movi	r2,-1
 8206170:	8dac703a 	and	r22,r17,r22
 8206174:	20806a26 	beq	r4,r2,8206320 <___svfprintf_internal_r+0x1ac4>
 8206178:	008011c4 	movi	r2,71
 820617c:	b0813726 	beq	r22,r2,820665c <___svfprintf_internal_r+0x1e00>
 8206180:	d9003717 	ldw	r4,220(sp)
 8206184:	90c04014 	ori	r3,r18,256
 8206188:	d8c02b15 	stw	r3,172(sp)
 820618c:	20015d16 	blt	r4,zero,8206704 <___svfprintf_internal_r+0x1ea8>
 8206190:	dd003717 	ldw	r20,220(sp)
 8206194:	d8002a05 	stb	zero,168(sp)
 8206198:	00801984 	movi	r2,102
 820619c:	88814026 	beq	r17,r2,82066a0 <___svfprintf_internal_r+0x1e44>
 82061a0:	00801184 	movi	r2,70
 82061a4:	88817126 	beq	r17,r2,820676c <___svfprintf_internal_r+0x1f10>
 82061a8:	00801144 	movi	r2,69
 82061ac:	b0816226 	beq	r22,r2,8206738 <___svfprintf_internal_r+0x1edc>
 82061b0:	d8c02917 	ldw	r3,164(sp)
 82061b4:	d8802104 	addi	r2,sp,132
 82061b8:	d8800315 	stw	r2,12(sp)
 82061bc:	d9403617 	ldw	r5,216(sp)
 82061c0:	d8802504 	addi	r2,sp,148
 82061c4:	d8800215 	stw	r2,8(sp)
 82061c8:	d8802604 	addi	r2,sp,152
 82061cc:	d8c00015 	stw	r3,0(sp)
 82061d0:	d8800115 	stw	r2,4(sp)
 82061d4:	01c00084 	movi	r7,2
 82061d8:	a00d883a 	mov	r6,r20
 82061dc:	9809883a 	mov	r4,r19
 82061e0:	d8c03d15 	stw	r3,244(sp)
 82061e4:	da003e15 	stw	r8,248(sp)
 82061e8:	82091b80 	call	82091b8 <_dtoa_r>
 82061ec:	1021883a 	mov	r16,r2
 82061f0:	008019c4 	movi	r2,103
 82061f4:	d8c03d17 	ldw	r3,244(sp)
 82061f8:	da003e17 	ldw	r8,248(sp)
 82061fc:	8880e726 	beq	r17,r2,820659c <___svfprintf_internal_r+0x1d40>
 8206200:	008011c4 	movi	r2,71
 8206204:	8880d426 	beq	r17,r2,8206558 <___svfprintf_internal_r+0x1cfc>
 8206208:	80f9883a 	add	fp,r16,r3
 820620c:	d9003617 	ldw	r4,216(sp)
 8206210:	000d883a 	mov	r6,zero
 8206214:	000f883a 	mov	r7,zero
 8206218:	a00b883a 	mov	r5,r20
 820621c:	da003e15 	stw	r8,248(sp)
 8206220:	8212efc0 	call	8212efc <__eqdf2>
 8206224:	da003e17 	ldw	r8,248(sp)
 8206228:	1000e426 	beq	r2,zero,82065bc <___svfprintf_internal_r+0x1d60>
 820622c:	d8802117 	ldw	r2,132(sp)
 8206230:	1700062e 	bgeu	r2,fp,820624c <___svfprintf_internal_r+0x19f0>
 8206234:	01000c04 	movi	r4,48
 8206238:	10c00044 	addi	r3,r2,1
 820623c:	d8c02115 	stw	r3,132(sp)
 8206240:	11000005 	stb	r4,0(r2)
 8206244:	d8802117 	ldw	r2,132(sp)
 8206248:	173ffb36 	bltu	r2,fp,8206238 <___svfprintf_internal_r+0x19dc>
 820624c:	1405c83a 	sub	r2,r2,r16
 8206250:	d8803315 	stw	r2,204(sp)
 8206254:	008011c4 	movi	r2,71
 8206258:	b080c526 	beq	r22,r2,8206570 <___svfprintf_internal_r+0x1d14>
 820625c:	00801944 	movi	r2,101
 8206260:	1441d90e 	bge	r2,r17,82069c8 <___svfprintf_internal_r+0x216c>
 8206264:	d8c02617 	ldw	r3,152(sp)
 8206268:	00801984 	movi	r2,102
 820626c:	d8c03215 	stw	r3,200(sp)
 8206270:	88813426 	beq	r17,r2,8206744 <___svfprintf_internal_r+0x1ee8>
 8206274:	d8c03217 	ldw	r3,200(sp)
 8206278:	d9003317 	ldw	r4,204(sp)
 820627c:	19012516 	blt	r3,r4,8206714 <___svfprintf_internal_r+0x1eb8>
 8206280:	9480004c 	andi	r18,r18,1
 8206284:	9001841e 	bne	r18,zero,8206898 <___svfprintf_internal_r+0x203c>
 8206288:	1805883a 	mov	r2,r3
 820628c:	1801cc16 	blt	r3,zero,82069c0 <___svfprintf_internal_r+0x2164>
 8206290:	d8c03217 	ldw	r3,200(sp)
 8206294:	044019c4 	movi	r17,103
 8206298:	d8c02e15 	stw	r3,184(sp)
 820629c:	df002a07 	ldb	fp,168(sp)
 82062a0:	e000a61e 	bne	fp,zero,820653c <___svfprintf_internal_r+0x1ce0>
 82062a4:	df002783 	ldbu	fp,158(sp)
 82062a8:	d8802a15 	stw	r2,168(sp)
 82062ac:	dc802b17 	ldw	r18,172(sp)
 82062b0:	d8002915 	stw	zero,164(sp)
 82062b4:	003b1706 	br	8204f14 <___svfprintf_internal_r+0x6b8>
 82062b8:	04020974 	movhi	r16,2085
 82062bc:	8436ba04 	addi	r16,r16,-9496
 82062c0:	003aa606 	br	8204d5c <___svfprintf_internal_r+0x500>
 82062c4:	d9003917 	ldw	r4,228(sp)
 82062c8:	04001004 	movi	r16,64
 82062cc:	800b883a 	mov	r5,r16
 82062d0:	820bcec0 	call	820bcec <_malloc_r>
 82062d4:	d9002c17 	ldw	r4,176(sp)
 82062d8:	20800015 	stw	r2,0(r4)
 82062dc:	20800415 	stw	r2,16(r4)
 82062e0:	1001cb26 	beq	r2,zero,8206a10 <___svfprintf_internal_r+0x21b4>
 82062e4:	d8802c17 	ldw	r2,176(sp)
 82062e8:	14000515 	stw	r16,20(r2)
 82062ec:	00397606 	br	82048c8 <___svfprintf_internal_r+0x6c>
 82062f0:	04020974 	movhi	r16,2085
 82062f4:	8436bc04 	addi	r16,r16,-9488
 82062f8:	003ee106 	br	8205e80 <___svfprintf_internal_r+0x1624>
 82062fc:	d9402c17 	ldw	r5,176(sp)
 8206300:	d9801e04 	addi	r6,sp,120
 8206304:	9809883a 	mov	r4,r19
 8206308:	820e0880 	call	820e088 <__ssprint_r>
 820630c:	103a381e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 8206310:	dc402617 	ldw	r17,152(sp)
 8206314:	d8c02017 	ldw	r3,128(sp)
 8206318:	da000404 	addi	r8,sp,16
 820631c:	003f4306 	br	820602c <___svfprintf_internal_r+0x17d0>
 8206320:	01400184 	movi	r5,6
 8206324:	d9402915 	stw	r5,164(sp)
 8206328:	003f9506 	br	8206180 <___svfprintf_internal_r+0x1924>
 820632c:	d9002d17 	ldw	r4,180(sp)
 8206330:	25000017 	ldw	r20,0(r4)
 8206334:	21000104 	addi	r4,r4,4
 8206338:	d9002d15 	stw	r4,180(sp)
 820633c:	a02dd7fa 	srai	r22,r20,31
 8206340:	b005883a 	mov	r2,r22
 8206344:	003a9b06 	br	8204db4 <___svfprintf_internal_r+0x558>
 8206348:	d9402d17 	ldw	r5,180(sp)
 820634c:	002d883a 	mov	r22,zero
 8206350:	2d000017 	ldw	r20,0(r5)
 8206354:	29400104 	addi	r5,r5,4
 8206358:	d9402d15 	stw	r5,180(sp)
 820635c:	003bf906 	br	8205344 <___svfprintf_internal_r+0xae8>
 8206360:	9480100c 	andi	r18,r18,64
 8206364:	90006e26 	beq	r18,zero,8206520 <___svfprintf_internal_r+0x1cc4>
 8206368:	d9002d17 	ldw	r4,180(sp)
 820636c:	d9402f17 	ldw	r5,188(sp)
 8206370:	20800017 	ldw	r2,0(r4)
 8206374:	21000104 	addi	r4,r4,4
 8206378:	d9002d15 	stw	r4,180(sp)
 820637c:	1140000d 	sth	r5,0(r2)
 8206380:	00396106 	br	8204908 <___svfprintf_internal_r+0xac>
 8206384:	d9402c17 	ldw	r5,176(sp)
 8206388:	d9801e04 	addi	r6,sp,120
 820638c:	9809883a 	mov	r4,r19
 8206390:	820e0880 	call	820e088 <__ssprint_r>
 8206394:	103a161e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 8206398:	d8c02017 	ldw	r3,128(sp)
 820639c:	d8801f17 	ldw	r2,124(sp)
 82063a0:	da000404 	addi	r8,sp,16
 82063a4:	d9403317 	ldw	r5,204(sp)
 82063a8:	10800044 	addi	r2,r2,1
 82063ac:	44000015 	stw	r16,0(r8)
 82063b0:	28c7883a 	add	r3,r5,r3
 82063b4:	003b7706 	br	8205194 <___svfprintf_internal_r+0x938>
 82063b8:	8009883a 	mov	r4,r16
 82063bc:	da003e15 	stw	r8,248(sp)
 82063c0:	8203f600 	call	8203f60 <strlen>
 82063c4:	d8802e15 	stw	r2,184(sp)
 82063c8:	da003e17 	ldw	r8,248(sp)
 82063cc:	103c280e 	bge	r2,zero,8205470 <___svfprintf_internal_r+0xc14>
 82063d0:	0005883a 	mov	r2,zero
 82063d4:	003c2606 	br	8205470 <___svfprintf_internal_r+0xc14>
 82063d8:	00bfffc4 	movi	r2,-1
 82063dc:	003a0906 	br	8204c04 <___svfprintf_internal_r+0x3a8>
 82063e0:	01020974 	movhi	r4,2085
 82063e4:	2136ce84 	addi	r4,r4,-9414
 82063e8:	d9003515 	stw	r4,212(sp)
 82063ec:	003b0606 	br	8205008 <___svfprintf_internal_r+0x7ac>
 82063f0:	013fffc4 	movi	r4,-1
 82063f4:	003a2706 	br	8204c94 <___svfprintf_internal_r+0x438>
 82063f8:	d9402c17 	ldw	r5,176(sp)
 82063fc:	d9801e04 	addi	r6,sp,120
 8206400:	9809883a 	mov	r4,r19
 8206404:	820e0880 	call	820e088 <__ssprint_r>
 8206408:	1039f91e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 820640c:	d8c02017 	ldw	r3,128(sp)
 8206410:	da000404 	addi	r8,sp,16
 8206414:	003d8406 	br	8205a28 <___svfprintf_internal_r+0x11cc>
 8206418:	0023883a 	mov	r17,zero
 820641c:	003d8306 	br	8205a2c <___svfprintf_internal_r+0x11d0>
 8206420:	01020974 	movhi	r4,2085
 8206424:	2136ca84 	addi	r4,r4,-9430
 8206428:	d9002b15 	stw	r4,172(sp)
 820642c:	d9002b17 	ldw	r4,172(sp)
 8206430:	1c47883a 	add	r3,r3,r17
 8206434:	10800044 	addi	r2,r2,1
 8206438:	41000015 	stw	r4,0(r8)
 820643c:	44400115 	stw	r17,4(r8)
 8206440:	d8c02015 	stw	r3,128(sp)
 8206444:	d8801f15 	stw	r2,124(sp)
 8206448:	010001c4 	movi	r4,7
 820644c:	20bfcd16 	blt	r4,r2,8206384 <___svfprintf_internal_r+0x1b28>
 8206450:	42000204 	addi	r8,r8,8
 8206454:	003fd306 	br	82063a4 <___svfprintf_internal_r+0x1b48>
 8206458:	d9402c17 	ldw	r5,176(sp)
 820645c:	d9801e04 	addi	r6,sp,120
 8206460:	9809883a 	mov	r4,r19
 8206464:	820e0880 	call	820e088 <__ssprint_r>
 8206468:	1039e11e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 820646c:	d8802617 	ldw	r2,152(sp)
 8206470:	d8c02017 	ldw	r3,128(sp)
 8206474:	da000404 	addi	r8,sp,16
 8206478:	003e1c06 	br	8205cec <___svfprintf_internal_r+0x1490>
 820647c:	d8802917 	ldw	r2,164(sp)
 8206480:	00c00184 	movi	r3,6
 8206484:	1880012e 	bgeu	r3,r2,820648c <___svfprintf_internal_r+0x1c30>
 8206488:	1805883a 	mov	r2,r3
 820648c:	d8802e15 	stw	r2,184(sp)
 8206490:	1000f316 	blt	r2,zero,8206860 <___svfprintf_internal_r+0x2004>
 8206494:	04020974 	movhi	r16,2085
 8206498:	d8802a15 	stw	r2,168(sp)
 820649c:	dd002d15 	stw	r20,180(sp)
 82064a0:	d8002915 	stw	zero,164(sp)
 82064a4:	d8003215 	stw	zero,200(sp)
 82064a8:	8436c804 	addi	r16,r16,-9440
 82064ac:	0039883a 	mov	fp,zero
 82064b0:	003a9f06 	br	8204f30 <___svfprintf_internal_r+0x6d4>
 82064b4:	01020974 	movhi	r4,2085
 82064b8:	2136ce84 	addi	r4,r4,-9414
 82064bc:	d9003515 	stw	r4,212(sp)
 82064c0:	003b5f06 	br	8205240 <___svfprintf_internal_r+0x9e4>
 82064c4:	d9402c17 	ldw	r5,176(sp)
 82064c8:	d9801e04 	addi	r6,sp,120
 82064cc:	9809883a 	mov	r4,r19
 82064d0:	820e0880 	call	820e088 <__ssprint_r>
 82064d4:	1039c61e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 82064d8:	d8802617 	ldw	r2,152(sp)
 82064dc:	d9403317 	ldw	r5,204(sp)
 82064e0:	d8c02017 	ldw	r3,128(sp)
 82064e4:	da000404 	addi	r8,sp,16
 82064e8:	2885c83a 	sub	r2,r5,r2
 82064ec:	003e1006 	br	8205d30 <___svfprintf_internal_r+0x14d4>
 82064f0:	00800044 	movi	r2,1
 82064f4:	10803fcc 	andi	r2,r2,255
 82064f8:	00c00044 	movi	r3,1
 82064fc:	10fa3526 	beq	r2,r3,8204dd4 <___svfprintf_internal_r+0x578>
 8206500:	00c00084 	movi	r3,2
 8206504:	10fb9e26 	beq	r2,r3,8205380 <___svfprintf_internal_r+0xb24>
 8206508:	003a6406 	br	8204e9c <___svfprintf_internal_r+0x640>
 820650c:	0021883a 	mov	r16,zero
 8206510:	003e0806 	br	8205d34 <___svfprintf_internal_r+0x14d8>
 8206514:	07000b44 	movi	fp,45
 8206518:	df002785 	stb	fp,158(sp)
 820651c:	003a0b06 	br	8204d4c <___svfprintf_internal_r+0x4f0>
 8206520:	d8c02d17 	ldw	r3,180(sp)
 8206524:	d9002f17 	ldw	r4,188(sp)
 8206528:	18800017 	ldw	r2,0(r3)
 820652c:	18c00104 	addi	r3,r3,4
 8206530:	d8c02d15 	stw	r3,180(sp)
 8206534:	11000015 	stw	r4,0(r2)
 8206538:	0038f306 	br	8204908 <___svfprintf_internal_r+0xac>
 820653c:	00c00b44 	movi	r3,45
 8206540:	d8c02785 	stb	r3,158(sp)
 8206544:	d8802a15 	stw	r2,168(sp)
 8206548:	dc802b17 	ldw	r18,172(sp)
 820654c:	d8002915 	stw	zero,164(sp)
 8206550:	07000b44 	movi	fp,45
 8206554:	003a7306 	br	8204f24 <___svfprintf_internal_r+0x6c8>
 8206558:	9080004c 	andi	r2,r18,1
 820655c:	1000941e 	bne	r2,zero,82067b0 <___svfprintf_internal_r+0x1f54>
 8206560:	d8802117 	ldw	r2,132(sp)
 8206564:	1405c83a 	sub	r2,r2,r16
 8206568:	d8803315 	stw	r2,204(sp)
 820656c:	b441161e 	bne	r22,r17,82069c8 <___svfprintf_internal_r+0x216c>
 8206570:	dd802617 	ldw	r22,152(sp)
 8206574:	00bfff44 	movi	r2,-3
 8206578:	b0801a16 	blt	r22,r2,82065e4 <___svfprintf_internal_r+0x1d88>
 820657c:	d9402917 	ldw	r5,164(sp)
 8206580:	2d801816 	blt	r5,r22,82065e4 <___svfprintf_internal_r+0x1d88>
 8206584:	dd803215 	stw	r22,200(sp)
 8206588:	003f3a06 	br	8206274 <___svfprintf_internal_r+0x1a18>
 820658c:	1025883a 	mov	r18,r2
 8206590:	0039883a 	mov	fp,zero
 8206594:	00800084 	movi	r2,2
 8206598:	003fd606 	br	82064f4 <___svfprintf_internal_r+0x1c98>
 820659c:	9080004c 	andi	r2,r18,1
 82065a0:	103f191e 	bne	r2,zero,8206208 <___svfprintf_internal_r+0x19ac>
 82065a4:	d8802117 	ldw	r2,132(sp)
 82065a8:	003f2806 	br	820624c <___svfprintf_internal_r+0x19f0>
 82065ac:	01020974 	movhi	r4,2085
 82065b0:	2136ca84 	addi	r4,r4,-9430
 82065b4:	d9002b15 	stw	r4,172(sp)
 82065b8:	003c7c06 	br	82057ac <___svfprintf_internal_r+0xf50>
 82065bc:	e005883a 	mov	r2,fp
 82065c0:	003f2206 	br	820624c <___svfprintf_internal_r+0x19f0>
 82065c4:	d9402917 	ldw	r5,164(sp)
 82065c8:	df002783 	ldbu	fp,158(sp)
 82065cc:	dd002d15 	stw	r20,180(sp)
 82065d0:	d9402a15 	stw	r5,168(sp)
 82065d4:	d9402e15 	stw	r5,184(sp)
 82065d8:	d8002915 	stw	zero,164(sp)
 82065dc:	d8003215 	stw	zero,200(sp)
 82065e0:	003a4c06 	br	8204f14 <___svfprintf_internal_r+0x6b8>
 82065e4:	8c7fff84 	addi	r17,r17,-2
 82065e8:	b5bfffc4 	addi	r22,r22,-1
 82065ec:	dd802615 	stw	r22,152(sp)
 82065f0:	dc4022c5 	stb	r17,139(sp)
 82065f4:	b000c316 	blt	r22,zero,8206904 <___svfprintf_internal_r+0x20a8>
 82065f8:	00800ac4 	movi	r2,43
 82065fc:	d8802305 	stb	r2,140(sp)
 8206600:	00800244 	movi	r2,9
 8206604:	15806e16 	blt	r2,r22,82067c0 <___svfprintf_internal_r+0x1f64>
 8206608:	00800c04 	movi	r2,48
 820660c:	b5800c04 	addi	r22,r22,48
 8206610:	d8802345 	stb	r2,141(sp)
 8206614:	dd802385 	stb	r22,142(sp)
 8206618:	d88023c4 	addi	r2,sp,143
 820661c:	df0022c4 	addi	fp,sp,139
 8206620:	d8c03317 	ldw	r3,204(sp)
 8206624:	1739c83a 	sub	fp,r2,fp
 8206628:	d9003317 	ldw	r4,204(sp)
 820662c:	e0c7883a 	add	r3,fp,r3
 8206630:	df003b15 	stw	fp,236(sp)
 8206634:	d8c02e15 	stw	r3,184(sp)
 8206638:	00800044 	movi	r2,1
 820663c:	1100b70e 	bge	r2,r4,820691c <___svfprintf_internal_r+0x20c0>
 8206640:	d8c02e17 	ldw	r3,184(sp)
 8206644:	18c00044 	addi	r3,r3,1
 8206648:	d8c02e15 	stw	r3,184(sp)
 820664c:	1805883a 	mov	r2,r3
 8206650:	1800b016 	blt	r3,zero,8206914 <___svfprintf_internal_r+0x20b8>
 8206654:	d8003215 	stw	zero,200(sp)
 8206658:	003f1006 	br	820629c <___svfprintf_internal_r+0x1a40>
 820665c:	d8802917 	ldw	r2,164(sp)
 8206660:	103ec71e 	bne	r2,zero,8206180 <___svfprintf_internal_r+0x1924>
 8206664:	dc002915 	stw	r16,164(sp)
 8206668:	003ec506 	br	8206180 <___svfprintf_internal_r+0x1924>
 820666c:	d9402c17 	ldw	r5,176(sp)
 8206670:	d9801e04 	addi	r6,sp,120
 8206674:	9809883a 	mov	r4,r19
 8206678:	820e0880 	call	820e088 <__ssprint_r>
 820667c:	10395c1e 	bne	r2,zero,8204bf0 <___svfprintf_internal_r+0x394>
 8206680:	dc402617 	ldw	r17,152(sp)
 8206684:	d8c02017 	ldw	r3,128(sp)
 8206688:	d8801f17 	ldw	r2,124(sp)
 820668c:	da000404 	addi	r8,sp,16
 8206690:	003e7706 	br	8206070 <___svfprintf_internal_r+0x1814>
 8206694:	582f883a 	mov	r23,r11
 8206698:	d8002915 	stw	zero,164(sp)
 820669c:	0038c406 	br	82049b0 <___svfprintf_internal_r+0x154>
 82066a0:	d8c02917 	ldw	r3,164(sp)
 82066a4:	d8802104 	addi	r2,sp,132
 82066a8:	d8800315 	stw	r2,12(sp)
 82066ac:	d9403617 	ldw	r5,216(sp)
 82066b0:	d8802504 	addi	r2,sp,148
 82066b4:	d8800215 	stw	r2,8(sp)
 82066b8:	d8802604 	addi	r2,sp,152
 82066bc:	d8c00015 	stw	r3,0(sp)
 82066c0:	9809883a 	mov	r4,r19
 82066c4:	d8800115 	stw	r2,4(sp)
 82066c8:	01c000c4 	movi	r7,3
 82066cc:	a00d883a 	mov	r6,r20
 82066d0:	da003e15 	stw	r8,248(sp)
 82066d4:	82091b80 	call	82091b8 <_dtoa_r>
 82066d8:	d9002917 	ldw	r4,164(sp)
 82066dc:	da003e17 	ldw	r8,248(sp)
 82066e0:	1021883a 	mov	r16,r2
 82066e4:	1139883a 	add	fp,r2,r4
 82066e8:	2007883a 	mov	r3,r4
 82066ec:	81000007 	ldb	r4,0(r16)
 82066f0:	00800c04 	movi	r2,48
 82066f4:	20806f26 	beq	r4,r2,82068b4 <___svfprintf_internal_r+0x2058>
 82066f8:	d8c02617 	ldw	r3,152(sp)
 82066fc:	e0f9883a 	add	fp,fp,r3
 8206700:	003ec206 	br	820620c <___svfprintf_internal_r+0x19b0>
 8206704:	00c00b44 	movi	r3,45
 8206708:	2520003c 	xorhi	r20,r4,32768
 820670c:	d8c02a05 	stb	r3,168(sp)
 8206710:	003ea106 	br	8206198 <___svfprintf_internal_r+0x193c>
 8206714:	d8c03217 	ldw	r3,200(sp)
 8206718:	00c0890e 	bge	zero,r3,8206940 <___svfprintf_internal_r+0x20e4>
 820671c:	00800044 	movi	r2,1
 8206720:	d9003317 	ldw	r4,204(sp)
 8206724:	1105883a 	add	r2,r2,r4
 8206728:	d8802e15 	stw	r2,184(sp)
 820672c:	10005f16 	blt	r2,zero,82068ac <___svfprintf_internal_r+0x2050>
 8206730:	044019c4 	movi	r17,103
 8206734:	003ed906 	br	820629c <___svfprintf_internal_r+0x1a40>
 8206738:	d9002917 	ldw	r4,164(sp)
 820673c:	20c00044 	addi	r3,r4,1
 8206740:	003e9c06 	br	82061b4 <___svfprintf_internal_r+0x1958>
 8206744:	d9002917 	ldw	r4,164(sp)
 8206748:	00c0680e 	bge	zero,r3,82068ec <___svfprintf_internal_r+0x2090>
 820674c:	2000461e 	bne	r4,zero,8206868 <___svfprintf_internal_r+0x200c>
 8206750:	9480004c 	andi	r18,r18,1
 8206754:	9000441e 	bne	r18,zero,8206868 <___svfprintf_internal_r+0x200c>
 8206758:	1805883a 	mov	r2,r3
 820675c:	1800a016 	blt	r3,zero,82069e0 <___svfprintf_internal_r+0x2184>
 8206760:	d8c03217 	ldw	r3,200(sp)
 8206764:	d8c02e15 	stw	r3,184(sp)
 8206768:	003ecc06 	br	820629c <___svfprintf_internal_r+0x1a40>
 820676c:	d9402917 	ldw	r5,164(sp)
 8206770:	d8802104 	addi	r2,sp,132
 8206774:	d8800315 	stw	r2,12(sp)
 8206778:	d9400015 	stw	r5,0(sp)
 820677c:	d8802504 	addi	r2,sp,148
 8206780:	d9403617 	ldw	r5,216(sp)
 8206784:	d8800215 	stw	r2,8(sp)
 8206788:	d8802604 	addi	r2,sp,152
 820678c:	d8800115 	stw	r2,4(sp)
 8206790:	01c000c4 	movi	r7,3
 8206794:	a00d883a 	mov	r6,r20
 8206798:	9809883a 	mov	r4,r19
 820679c:	da003e15 	stw	r8,248(sp)
 82067a0:	82091b80 	call	82091b8 <_dtoa_r>
 82067a4:	d8c02917 	ldw	r3,164(sp)
 82067a8:	da003e17 	ldw	r8,248(sp)
 82067ac:	1021883a 	mov	r16,r2
 82067b0:	00801184 	movi	r2,70
 82067b4:	80f9883a 	add	fp,r16,r3
 82067b8:	88bfcc26 	beq	r17,r2,82066ec <___svfprintf_internal_r+0x1e90>
 82067bc:	003e9306 	br	820620c <___svfprintf_internal_r+0x19b0>
 82067c0:	df0022c4 	addi	fp,sp,139
 82067c4:	dc002915 	stw	r16,164(sp)
 82067c8:	9829883a 	mov	r20,r19
 82067cc:	e021883a 	mov	r16,fp
 82067d0:	4027883a 	mov	r19,r8
 82067d4:	b009883a 	mov	r4,r22
 82067d8:	01400284 	movi	r5,10
 82067dc:	8202b9c0 	call	8202b9c <__modsi3>
 82067e0:	10800c04 	addi	r2,r2,48
 82067e4:	843fffc4 	addi	r16,r16,-1
 82067e8:	b009883a 	mov	r4,r22
 82067ec:	01400284 	movi	r5,10
 82067f0:	80800005 	stb	r2,0(r16)
 82067f4:	8202b180 	call	8202b18 <__divsi3>
 82067f8:	102d883a 	mov	r22,r2
 82067fc:	00800244 	movi	r2,9
 8206800:	15bff416 	blt	r2,r22,82067d4 <___svfprintf_internal_r+0x1f78>
 8206804:	9811883a 	mov	r8,r19
 8206808:	b0800c04 	addi	r2,r22,48
 820680c:	a027883a 	mov	r19,r20
 8206810:	8029883a 	mov	r20,r16
 8206814:	a17fffc4 	addi	r5,r20,-1
 8206818:	a0bfffc5 	stb	r2,-1(r20)
 820681c:	dc002917 	ldw	r16,164(sp)
 8206820:	2f00752e 	bgeu	r5,fp,82069f8 <___svfprintf_internal_r+0x219c>
 8206824:	d9c02384 	addi	r7,sp,142
 8206828:	3d0fc83a 	sub	r7,r7,r20
 820682c:	d9002344 	addi	r4,sp,141
 8206830:	e1cf883a 	add	r7,fp,r7
 8206834:	00000106 	br	820683c <___svfprintf_internal_r+0x1fe0>
 8206838:	28800003 	ldbu	r2,0(r5)
 820683c:	20800005 	stb	r2,0(r4)
 8206840:	21000044 	addi	r4,r4,1
 8206844:	29400044 	addi	r5,r5,1
 8206848:	21fffb1e 	bne	r4,r7,8206838 <___svfprintf_internal_r+0x1fdc>
 820684c:	d8802304 	addi	r2,sp,140
 8206850:	1505c83a 	sub	r2,r2,r20
 8206854:	d8c02344 	addi	r3,sp,141
 8206858:	1885883a 	add	r2,r3,r2
 820685c:	003f7006 	br	8206620 <___svfprintf_internal_r+0x1dc4>
 8206860:	0005883a 	mov	r2,zero
 8206864:	003f0b06 	br	8206494 <___svfprintf_internal_r+0x1c38>
 8206868:	d9002917 	ldw	r4,164(sp)
 820686c:	d8c03217 	ldw	r3,200(sp)
 8206870:	20800044 	addi	r2,r4,1
 8206874:	1885883a 	add	r2,r3,r2
 8206878:	d8802e15 	stw	r2,184(sp)
 820687c:	103e870e 	bge	r2,zero,820629c <___svfprintf_internal_r+0x1a40>
 8206880:	0005883a 	mov	r2,zero
 8206884:	003e8506 	br	820629c <___svfprintf_internal_r+0x1a40>
 8206888:	01020974 	movhi	r4,2085
 820688c:	2136ca84 	addi	r4,r4,-9430
 8206890:	d9002b15 	stw	r4,172(sp)
 8206894:	003cc506 	br	8205bac <___svfprintf_internal_r+0x1350>
 8206898:	d8c03217 	ldw	r3,200(sp)
 820689c:	18c00044 	addi	r3,r3,1
 82068a0:	d8c02e15 	stw	r3,184(sp)
 82068a4:	1805883a 	mov	r2,r3
 82068a8:	183fa10e 	bge	r3,zero,8206730 <___svfprintf_internal_r+0x1ed4>
 82068ac:	0005883a 	mov	r2,zero
 82068b0:	003f9f06 	br	8206730 <___svfprintf_internal_r+0x1ed4>
 82068b4:	d9003617 	ldw	r4,216(sp)
 82068b8:	000d883a 	mov	r6,zero
 82068bc:	000f883a 	mov	r7,zero
 82068c0:	a00b883a 	mov	r5,r20
 82068c4:	d8c03d15 	stw	r3,244(sp)
 82068c8:	da003e15 	stw	r8,248(sp)
 82068cc:	8212efc0 	call	8212efc <__eqdf2>
 82068d0:	d8c03d17 	ldw	r3,244(sp)
 82068d4:	da003e17 	ldw	r8,248(sp)
 82068d8:	103f8726 	beq	r2,zero,82066f8 <___svfprintf_internal_r+0x1e9c>
 82068dc:	00800044 	movi	r2,1
 82068e0:	10c7c83a 	sub	r3,r2,r3
 82068e4:	d8c02615 	stw	r3,152(sp)
 82068e8:	003f8406 	br	82066fc <___svfprintf_internal_r+0x1ea0>
 82068ec:	20000e1e 	bne	r4,zero,8206928 <___svfprintf_internal_r+0x20cc>
 82068f0:	9480004c 	andi	r18,r18,1
 82068f4:	90000c1e 	bne	r18,zero,8206928 <___svfprintf_internal_r+0x20cc>
 82068f8:	00800044 	movi	r2,1
 82068fc:	d8802e15 	stw	r2,184(sp)
 8206900:	003e6606 	br	820629c <___svfprintf_internal_r+0x1a40>
 8206904:	00800b44 	movi	r2,45
 8206908:	05adc83a 	sub	r22,zero,r22
 820690c:	d8802305 	stb	r2,140(sp)
 8206910:	003f3b06 	br	8206600 <___svfprintf_internal_r+0x1da4>
 8206914:	0005883a 	mov	r2,zero
 8206918:	003f4e06 	br	8206654 <___svfprintf_internal_r+0x1df8>
 820691c:	90a4703a 	and	r18,r18,r2
 8206920:	903f4a26 	beq	r18,zero,820664c <___svfprintf_internal_r+0x1df0>
 8206924:	003f4606 	br	8206640 <___svfprintf_internal_r+0x1de4>
 8206928:	d8c02917 	ldw	r3,164(sp)
 820692c:	18c00084 	addi	r3,r3,2
 8206930:	d8c02e15 	stw	r3,184(sp)
 8206934:	1805883a 	mov	r2,r3
 8206938:	183e580e 	bge	r3,zero,820629c <___svfprintf_internal_r+0x1a40>
 820693c:	003fd006 	br	8206880 <___svfprintf_internal_r+0x2024>
 8206940:	00800084 	movi	r2,2
 8206944:	10c5c83a 	sub	r2,r2,r3
 8206948:	003f7506 	br	8206720 <___svfprintf_internal_r+0x1ec4>
 820694c:	d8802d17 	ldw	r2,180(sp)
 8206950:	d9002d17 	ldw	r4,180(sp)
 8206954:	bc400043 	ldbu	r17,1(r23)
 8206958:	10800017 	ldw	r2,0(r2)
 820695c:	582f883a 	mov	r23,r11
 8206960:	d8802915 	stw	r2,164(sp)
 8206964:	20800104 	addi	r2,r4,4
 8206968:	d9002917 	ldw	r4,164(sp)
 820696c:	d8802d15 	stw	r2,180(sp)
 8206970:	203df00e 	bge	r4,zero,8206134 <___svfprintf_internal_r+0x18d8>
 8206974:	8c403fcc 	andi	r17,r17,255
 8206978:	00bfffc4 	movi	r2,-1
 820697c:	8c40201c 	xori	r17,r17,128
 8206980:	d8802915 	stw	r2,164(sp)
 8206984:	8c7fe004 	addi	r17,r17,-128
 8206988:	00380806 	br	82049ac <___svfprintf_internal_r+0x150>
 820698c:	9080004c 	andi	r2,r18,1
 8206990:	0039883a 	mov	fp,zero
 8206994:	10000726 	beq	r2,zero,82069b4 <___svfprintf_internal_r+0x2158>
 8206998:	d8c02817 	ldw	r3,160(sp)
 820699c:	dc001dc4 	addi	r16,sp,119
 82069a0:	00800c04 	movi	r2,48
 82069a4:	1c07c83a 	sub	r3,r3,r16
 82069a8:	d8801dc5 	stb	r2,119(sp)
 82069ac:	d8c02e15 	stw	r3,184(sp)
 82069b0:	00395206 	br	8204efc <___svfprintf_internal_r+0x6a0>
 82069b4:	d8002e15 	stw	zero,184(sp)
 82069b8:	dc001e04 	addi	r16,sp,120
 82069bc:	00394f06 	br	8204efc <___svfprintf_internal_r+0x6a0>
 82069c0:	0005883a 	mov	r2,zero
 82069c4:	003e3206 	br	8206290 <___svfprintf_internal_r+0x1a34>
 82069c8:	dd802617 	ldw	r22,152(sp)
 82069cc:	003f0606 	br	82065e8 <___svfprintf_internal_r+0x1d8c>
 82069d0:	d9c02785 	stb	r7,158(sp)
 82069d4:	003a5106 	br	820531c <___svfprintf_internal_r+0xac0>
 82069d8:	d9c02785 	stb	r7,158(sp)
 82069dc:	003a3706 	br	82052bc <___svfprintf_internal_r+0xa60>
 82069e0:	0005883a 	mov	r2,zero
 82069e4:	003f5e06 	br	8206760 <___svfprintf_internal_r+0x1f04>
 82069e8:	d9c02785 	stb	r7,158(sp)
 82069ec:	00391706 	br	8204e4c <___svfprintf_internal_r+0x5f0>
 82069f0:	d9c02785 	stb	r7,158(sp)
 82069f4:	0038e606 	br	8204d90 <___svfprintf_internal_r+0x534>
 82069f8:	d8802344 	addi	r2,sp,141
 82069fc:	003f0806 	br	8206620 <___svfprintf_internal_r+0x1dc4>
 8206a00:	d9c02785 	stb	r7,158(sp)
 8206a04:	0038b706 	br	8204ce4 <___svfprintf_internal_r+0x488>
 8206a08:	d9c02785 	stb	r7,158(sp)
 8206a0c:	003adc06 	br	8205580 <___svfprintf_internal_r+0xd24>
 8206a10:	d9403917 	ldw	r5,228(sp)
 8206a14:	00800304 	movi	r2,12
 8206a18:	28800015 	stw	r2,0(r5)
 8206a1c:	00bfffc4 	movi	r2,-1
 8206a20:	00387806 	br	8204c04 <___svfprintf_internal_r+0x3a8>
 8206a24:	d9c02785 	stb	r7,158(sp)
 8206a28:	003abf06 	br	8205528 <___svfprintf_internal_r+0xccc>
 8206a2c:	d9c02785 	stb	r7,158(sp)
 8206a30:	003a9b06 	br	82054a0 <___svfprintf_internal_r+0xc44>

08206a34 <_user_strerror>:
 8206a34:	0005883a 	mov	r2,zero
 8206a38:	f800283a 	ret

08206a3c <___vfprintf_internal_r>:
 8206a3c:	deffb804 	addi	sp,sp,-288
 8206a40:	dfc04715 	stw	ra,284(sp)
 8206a44:	ddc04515 	stw	r23,276(sp)
 8206a48:	dd404315 	stw	r21,268(sp)
 8206a4c:	d9002c15 	stw	r4,176(sp)
 8206a50:	282f883a 	mov	r23,r5
 8206a54:	302b883a 	mov	r21,r6
 8206a58:	d9c02d15 	stw	r7,180(sp)
 8206a5c:	df004615 	stw	fp,280(sp)
 8206a60:	dd804415 	stw	r22,272(sp)
 8206a64:	dd004215 	stw	r20,264(sp)
 8206a68:	dcc04115 	stw	r19,260(sp)
 8206a6c:	dc804015 	stw	r18,256(sp)
 8206a70:	dc403f15 	stw	r17,252(sp)
 8206a74:	dc003e15 	stw	r16,248(sp)
 8206a78:	820bb000 	call	820bb00 <_localeconv_r>
 8206a7c:	10800017 	ldw	r2,0(r2)
 8206a80:	1009883a 	mov	r4,r2
 8206a84:	d8803415 	stw	r2,208(sp)
 8206a88:	8203f600 	call	8203f60 <strlen>
 8206a8c:	d8803715 	stw	r2,220(sp)
 8206a90:	d8802c17 	ldw	r2,176(sp)
 8206a94:	10000226 	beq	r2,zero,8206aa0 <___vfprintf_internal_r+0x64>
 8206a98:	10800e17 	ldw	r2,56(r2)
 8206a9c:	1000f926 	beq	r2,zero,8206e84 <___vfprintf_internal_r+0x448>
 8206aa0:	b880030b 	ldhu	r2,12(r23)
 8206aa4:	10c8000c 	andi	r3,r2,8192
 8206aa8:	1800061e 	bne	r3,zero,8206ac4 <___vfprintf_internal_r+0x88>
 8206aac:	b9001917 	ldw	r4,100(r23)
 8206ab0:	00f7ffc4 	movi	r3,-8193
 8206ab4:	10880014 	ori	r2,r2,8192
 8206ab8:	20c6703a 	and	r3,r4,r3
 8206abc:	b880030d 	sth	r2,12(r23)
 8206ac0:	b8c01915 	stw	r3,100(r23)
 8206ac4:	10c0020c 	andi	r3,r2,8
 8206ac8:	1800c126 	beq	r3,zero,8206dd0 <___vfprintf_internal_r+0x394>
 8206acc:	b8c00417 	ldw	r3,16(r23)
 8206ad0:	1800bf26 	beq	r3,zero,8206dd0 <___vfprintf_internal_r+0x394>
 8206ad4:	1080068c 	andi	r2,r2,26
 8206ad8:	00c00284 	movi	r3,10
 8206adc:	10c0c426 	beq	r2,r3,8206df0 <___vfprintf_internal_r+0x3b4>
 8206ae0:	d8c00404 	addi	r3,sp,16
 8206ae4:	05020974 	movhi	r20,2085
 8206ae8:	d9001e04 	addi	r4,sp,120
 8206aec:	a536d284 	addi	r20,r20,-9398
 8206af0:	d8c01e15 	stw	r3,120(sp)
 8206af4:	d8002015 	stw	zero,128(sp)
 8206af8:	d8001f15 	stw	zero,124(sp)
 8206afc:	d8003315 	stw	zero,204(sp)
 8206b00:	d8003615 	stw	zero,216(sp)
 8206b04:	d8003815 	stw	zero,224(sp)
 8206b08:	1811883a 	mov	r8,r3
 8206b0c:	d8003915 	stw	zero,228(sp)
 8206b10:	d8003a15 	stw	zero,232(sp)
 8206b14:	d8002f15 	stw	zero,188(sp)
 8206b18:	d9002815 	stw	r4,160(sp)
 8206b1c:	a8800007 	ldb	r2,0(r21)
 8206b20:	10027b26 	beq	r2,zero,8207510 <___vfprintf_internal_r+0xad4>
 8206b24:	00c00944 	movi	r3,37
 8206b28:	a821883a 	mov	r16,r21
 8206b2c:	10c0021e 	bne	r2,r3,8206b38 <___vfprintf_internal_r+0xfc>
 8206b30:	00001406 	br	8206b84 <___vfprintf_internal_r+0x148>
 8206b34:	10c00326 	beq	r2,r3,8206b44 <___vfprintf_internal_r+0x108>
 8206b38:	84000044 	addi	r16,r16,1
 8206b3c:	80800007 	ldb	r2,0(r16)
 8206b40:	103ffc1e 	bne	r2,zero,8206b34 <___vfprintf_internal_r+0xf8>
 8206b44:	8563c83a 	sub	r17,r16,r21
 8206b48:	88000e26 	beq	r17,zero,8206b84 <___vfprintf_internal_r+0x148>
 8206b4c:	d8c02017 	ldw	r3,128(sp)
 8206b50:	d8801f17 	ldw	r2,124(sp)
 8206b54:	45400015 	stw	r21,0(r8)
 8206b58:	1c47883a 	add	r3,r3,r17
 8206b5c:	10800044 	addi	r2,r2,1
 8206b60:	d8c02015 	stw	r3,128(sp)
 8206b64:	44400115 	stw	r17,4(r8)
 8206b68:	d8801f15 	stw	r2,124(sp)
 8206b6c:	00c001c4 	movi	r3,7
 8206b70:	1880a716 	blt	r3,r2,8206e10 <___vfprintf_internal_r+0x3d4>
 8206b74:	42000204 	addi	r8,r8,8
 8206b78:	d9402f17 	ldw	r5,188(sp)
 8206b7c:	2c4b883a 	add	r5,r5,r17
 8206b80:	d9402f15 	stw	r5,188(sp)
 8206b84:	80800007 	ldb	r2,0(r16)
 8206b88:	1000a826 	beq	r2,zero,8206e2c <___vfprintf_internal_r+0x3f0>
 8206b8c:	84400047 	ldb	r17,1(r16)
 8206b90:	00bfffc4 	movi	r2,-1
 8206b94:	85400044 	addi	r21,r16,1
 8206b98:	d8002785 	stb	zero,158(sp)
 8206b9c:	0007883a 	mov	r3,zero
 8206ba0:	000f883a 	mov	r7,zero
 8206ba4:	d8802915 	stw	r2,164(sp)
 8206ba8:	d8003115 	stw	zero,196(sp)
 8206bac:	0025883a 	mov	r18,zero
 8206bb0:	01401604 	movi	r5,88
 8206bb4:	01800244 	movi	r6,9
 8206bb8:	02800a84 	movi	r10,42
 8206bbc:	02401b04 	movi	r9,108
 8206bc0:	ad400044 	addi	r21,r21,1
 8206bc4:	88bff804 	addi	r2,r17,-32
 8206bc8:	28830436 	bltu	r5,r2,82077dc <___vfprintf_internal_r+0xda0>
 8206bcc:	100490ba 	slli	r2,r2,2
 8206bd0:	01020834 	movhi	r4,2080
 8206bd4:	211af904 	addi	r4,r4,27620
 8206bd8:	1105883a 	add	r2,r2,r4
 8206bdc:	10800017 	ldw	r2,0(r2)
 8206be0:	1000683a 	jmp	r2
 8206be4:	082076fc 	xorhi	zero,at,33243
 8206be8:	082077dc 	xori	zero,at,33247
 8206bec:	082077dc 	xori	zero,at,33247
 8206bf0:	0820771c 	xori	zero,at,33244
 8206bf4:	082077dc 	xori	zero,at,33247
 8206bf8:	082077dc 	xori	zero,at,33247
 8206bfc:	082077dc 	xori	zero,at,33247
 8206c00:	082077dc 	xori	zero,at,33247
 8206c04:	082077dc 	xori	zero,at,33247
 8206c08:	082077dc 	xori	zero,at,33247
 8206c0c:	08206e90 	cmplti	zero,at,-32326
 8206c10:	08207638 	rdprs	zero,at,-32296
 8206c14:	082077dc 	xori	zero,at,33247
 8206c18:	08206d58 	cmpnei	zero,at,-32331
 8206c1c:	08206eb8 	rdprs	zero,at,-32326
 8206c20:	082077dc 	xori	zero,at,33247
 8206c24:	08206ef8 	rdprs	zero,at,-32325
 8206c28:	08206f04 	addi	zero,at,-32324
 8206c2c:	08206f04 	addi	zero,at,-32324
 8206c30:	08206f04 	addi	zero,at,-32324
 8206c34:	08206f04 	addi	zero,at,-32324
 8206c38:	08206f04 	addi	zero,at,-32324
 8206c3c:	08206f04 	addi	zero,at,-32324
 8206c40:	08206f04 	addi	zero,at,-32324
 8206c44:	08206f04 	addi	zero,at,-32324
 8206c48:	08206f04 	addi	zero,at,-32324
 8206c4c:	082077dc 	xori	zero,at,33247
 8206c50:	082077dc 	xori	zero,at,33247
 8206c54:	082077dc 	xori	zero,at,33247
 8206c58:	082077dc 	xori	zero,at,33247
 8206c5c:	082077dc 	xori	zero,at,33247
 8206c60:	082077dc 	xori	zero,at,33247
 8206c64:	082077dc 	xori	zero,at,33247
 8206c68:	082077dc 	xori	zero,at,33247
 8206c6c:	082077dc 	xori	zero,at,33247
 8206c70:	082077dc 	xori	zero,at,33247
 8206c74:	08206f38 	rdprs	zero,at,-32324
 8206c78:	08206ff4 	orhi	zero,at,33215
 8206c7c:	082077dc 	xori	zero,at,33247
 8206c80:	08206ff4 	orhi	zero,at,33215
 8206c84:	082077dc 	xori	zero,at,33247
 8206c88:	082077dc 	xori	zero,at,33247
 8206c8c:	082077dc 	xori	zero,at,33247
 8206c90:	082077dc 	xori	zero,at,33247
 8206c94:	08207094 	ori	zero,at,33218
 8206c98:	082077dc 	xori	zero,at,33247
 8206c9c:	082077dc 	xori	zero,at,33247
 8206ca0:	082070a0 	cmpeqi	zero,at,-32318
 8206ca4:	082077dc 	xori	zero,at,33247
 8206ca8:	082077dc 	xori	zero,at,33247
 8206cac:	082077dc 	xori	zero,at,33247
 8206cb0:	082077dc 	xori	zero,at,33247
 8206cb4:	082077dc 	xori	zero,at,33247
 8206cb8:	08207518 	cmpnei	zero,at,-32300
 8206cbc:	082077dc 	xori	zero,at,33247
 8206cc0:	082077dc 	xori	zero,at,33247
 8206cc4:	08207578 	rdprs	zero,at,-32299
 8206cc8:	082077dc 	xori	zero,at,33247
 8206ccc:	082077dc 	xori	zero,at,33247
 8206cd0:	082077dc 	xori	zero,at,33247
 8206cd4:	082077dc 	xori	zero,at,33247
 8206cd8:	082077dc 	xori	zero,at,33247
 8206cdc:	082077dc 	xori	zero,at,33247
 8206ce0:	082077dc 	xori	zero,at,33247
 8206ce4:	082077dc 	xori	zero,at,33247
 8206ce8:	082077dc 	xori	zero,at,33247
 8206cec:	082077dc 	xori	zero,at,33247
 8206cf0:	08207788 	cmpgei	zero,at,-32290
 8206cf4:	08207728 	cmpgeui	zero,at,33244
 8206cf8:	08206ff4 	orhi	zero,at,33215
 8206cfc:	08206ff4 	orhi	zero,at,33215
 8206d00:	08206ff4 	orhi	zero,at,33215
 8206d04:	08207738 	rdprs	zero,at,-32292
 8206d08:	08207728 	cmpgeui	zero,at,33244
 8206d0c:	082077dc 	xori	zero,at,33247
 8206d10:	082077dc 	xori	zero,at,33247
 8206d14:	08207744 	addi	zero,at,-32291
 8206d18:	082077dc 	xori	zero,at,33247
 8206d1c:	08207754 	ori	zero,at,33245
 8206d20:	08207628 	cmpgeui	zero,at,33240
 8206d24:	08206d64 	muli	zero,at,-32331
 8206d28:	08207648 	cmpgei	zero,at,-32295
 8206d2c:	082077dc 	xori	zero,at,33247
 8206d30:	08207654 	ori	zero,at,33241
 8206d34:	082077dc 	xori	zero,at,33247
 8206d38:	082076b0 	cmpltui	zero,at,33242
 8206d3c:	082077dc 	xori	zero,at,33247
 8206d40:	082077dc 	xori	zero,at,33247
 8206d44:	082076c0 	call	82076c <OSCtxSw_SWITCH_PC+0x82072c>
 8206d48:	d9003117 	ldw	r4,196(sp)
 8206d4c:	d8802d15 	stw	r2,180(sp)
 8206d50:	0109c83a 	sub	r4,zero,r4
 8206d54:	d9003115 	stw	r4,196(sp)
 8206d58:	94800114 	ori	r18,r18,4
 8206d5c:	ac400007 	ldb	r17,0(r21)
 8206d60:	003f9706 	br	8206bc0 <___vfprintf_internal_r+0x184>
 8206d64:	00800c04 	movi	r2,48
 8206d68:	d9002d17 	ldw	r4,180(sp)
 8206d6c:	d9402917 	ldw	r5,164(sp)
 8206d70:	d8802705 	stb	r2,156(sp)
 8206d74:	00801e04 	movi	r2,120
 8206d78:	d8802745 	stb	r2,157(sp)
 8206d7c:	d8002785 	stb	zero,158(sp)
 8206d80:	20c00104 	addi	r3,r4,4
 8206d84:	24c00017 	ldw	r19,0(r4)
 8206d88:	002d883a 	mov	r22,zero
 8206d8c:	90800094 	ori	r2,r18,2
 8206d90:	28029a16 	blt	r5,zero,82077fc <___vfprintf_internal_r+0xdc0>
 8206d94:	00bfdfc4 	movi	r2,-129
 8206d98:	90a4703a 	and	r18,r18,r2
 8206d9c:	d8c02d15 	stw	r3,180(sp)
 8206da0:	94800094 	ori	r18,r18,2
 8206da4:	9802871e 	bne	r19,zero,82077c4 <___vfprintf_internal_r+0xd88>
 8206da8:	00820974 	movhi	r2,2085
 8206dac:	10b6c304 	addi	r2,r2,-9460
 8206db0:	d8803915 	stw	r2,228(sp)
 8206db4:	04401e04 	movi	r17,120
 8206db8:	d8802917 	ldw	r2,164(sp)
 8206dbc:	0039883a 	mov	fp,zero
 8206dc0:	1001e926 	beq	r2,zero,8207568 <___vfprintf_internal_r+0xb2c>
 8206dc4:	0027883a 	mov	r19,zero
 8206dc8:	002d883a 	mov	r22,zero
 8206dcc:	00020506 	br	82075e4 <___vfprintf_internal_r+0xba8>
 8206dd0:	d9002c17 	ldw	r4,176(sp)
 8206dd4:	b80b883a 	mov	r5,r23
 8206dd8:	8208e640 	call	8208e64 <__swsetup_r>
 8206ddc:	1005ac1e 	bne	r2,zero,8208490 <___vfprintf_internal_r+0x1a54>
 8206de0:	b880030b 	ldhu	r2,12(r23)
 8206de4:	00c00284 	movi	r3,10
 8206de8:	1080068c 	andi	r2,r2,26
 8206dec:	10ff3c1e 	bne	r2,r3,8206ae0 <___vfprintf_internal_r+0xa4>
 8206df0:	b880038f 	ldh	r2,14(r23)
 8206df4:	103f3a16 	blt	r2,zero,8206ae0 <___vfprintf_internal_r+0xa4>
 8206df8:	d9c02d17 	ldw	r7,180(sp)
 8206dfc:	d9002c17 	ldw	r4,176(sp)
 8206e00:	a80d883a 	mov	r6,r21
 8206e04:	b80b883a 	mov	r5,r23
 8206e08:	8208c500 	call	8208c50 <__sbprintf>
 8206e0c:	00001106 	br	8206e54 <___vfprintf_internal_r+0x418>
 8206e10:	d9002c17 	ldw	r4,176(sp)
 8206e14:	d9801e04 	addi	r6,sp,120
 8206e18:	b80b883a 	mov	r5,r23
 8206e1c:	820f5900 	call	820f590 <__sprint_r>
 8206e20:	1000081e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 8206e24:	da000404 	addi	r8,sp,16
 8206e28:	003f5306 	br	8206b78 <___vfprintf_internal_r+0x13c>
 8206e2c:	d8802017 	ldw	r2,128(sp)
 8206e30:	10000426 	beq	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 8206e34:	d9002c17 	ldw	r4,176(sp)
 8206e38:	d9801e04 	addi	r6,sp,120
 8206e3c:	b80b883a 	mov	r5,r23
 8206e40:	820f5900 	call	820f590 <__sprint_r>
 8206e44:	b880030b 	ldhu	r2,12(r23)
 8206e48:	1080100c 	andi	r2,r2,64
 8206e4c:	1005901e 	bne	r2,zero,8208490 <___vfprintf_internal_r+0x1a54>
 8206e50:	d8802f17 	ldw	r2,188(sp)
 8206e54:	dfc04717 	ldw	ra,284(sp)
 8206e58:	df004617 	ldw	fp,280(sp)
 8206e5c:	ddc04517 	ldw	r23,276(sp)
 8206e60:	dd804417 	ldw	r22,272(sp)
 8206e64:	dd404317 	ldw	r21,268(sp)
 8206e68:	dd004217 	ldw	r20,264(sp)
 8206e6c:	dcc04117 	ldw	r19,260(sp)
 8206e70:	dc804017 	ldw	r18,256(sp)
 8206e74:	dc403f17 	ldw	r17,252(sp)
 8206e78:	dc003e17 	ldw	r16,248(sp)
 8206e7c:	dec04804 	addi	sp,sp,288
 8206e80:	f800283a 	ret
 8206e84:	d9002c17 	ldw	r4,176(sp)
 8206e88:	820ae380 	call	820ae38 <__sinit>
 8206e8c:	003f0406 	br	8206aa0 <___vfprintf_internal_r+0x64>
 8206e90:	d8802d17 	ldw	r2,180(sp)
 8206e94:	d9002d17 	ldw	r4,180(sp)
 8206e98:	10800017 	ldw	r2,0(r2)
 8206e9c:	d8803115 	stw	r2,196(sp)
 8206ea0:	20800104 	addi	r2,r4,4
 8206ea4:	d9003117 	ldw	r4,196(sp)
 8206ea8:	203fa716 	blt	r4,zero,8206d48 <___vfprintf_internal_r+0x30c>
 8206eac:	d8802d15 	stw	r2,180(sp)
 8206eb0:	ac400007 	ldb	r17,0(r21)
 8206eb4:	003f4206 	br	8206bc0 <___vfprintf_internal_r+0x184>
 8206eb8:	ac400007 	ldb	r17,0(r21)
 8206ebc:	aac00044 	addi	r11,r21,1
 8206ec0:	8a872826 	beq	r17,r10,8208b64 <___vfprintf_internal_r+0x2128>
 8206ec4:	88bff404 	addi	r2,r17,-48
 8206ec8:	0009883a 	mov	r4,zero
 8206ecc:	30867d36 	bltu	r6,r2,82088c4 <___vfprintf_internal_r+0x1e88>
 8206ed0:	5c400007 	ldb	r17,0(r11)
 8206ed4:	210002a4 	muli	r4,r4,10
 8206ed8:	5d400044 	addi	r21,r11,1
 8206edc:	a817883a 	mov	r11,r21
 8206ee0:	2089883a 	add	r4,r4,r2
 8206ee4:	88bff404 	addi	r2,r17,-48
 8206ee8:	30bff92e 	bgeu	r6,r2,8206ed0 <___vfprintf_internal_r+0x494>
 8206eec:	2005c916 	blt	r4,zero,8208614 <___vfprintf_internal_r+0x1bd8>
 8206ef0:	d9002915 	stw	r4,164(sp)
 8206ef4:	003f3306 	br	8206bc4 <___vfprintf_internal_r+0x188>
 8206ef8:	94802014 	ori	r18,r18,128
 8206efc:	ac400007 	ldb	r17,0(r21)
 8206f00:	003f2f06 	br	8206bc0 <___vfprintf_internal_r+0x184>
 8206f04:	a809883a 	mov	r4,r21
 8206f08:	d8003115 	stw	zero,196(sp)
 8206f0c:	88bff404 	addi	r2,r17,-48
 8206f10:	0017883a 	mov	r11,zero
 8206f14:	24400007 	ldb	r17,0(r4)
 8206f18:	5ac002a4 	muli	r11,r11,10
 8206f1c:	ad400044 	addi	r21,r21,1
 8206f20:	a809883a 	mov	r4,r21
 8206f24:	12d7883a 	add	r11,r2,r11
 8206f28:	88bff404 	addi	r2,r17,-48
 8206f2c:	30bff92e 	bgeu	r6,r2,8206f14 <___vfprintf_internal_r+0x4d8>
 8206f30:	dac03115 	stw	r11,196(sp)
 8206f34:	003f2306 	br	8206bc4 <___vfprintf_internal_r+0x188>
 8206f38:	18c03fcc 	andi	r3,r3,255
 8206f3c:	18072b1e 	bne	r3,zero,8208bec <___vfprintf_internal_r+0x21b0>
 8206f40:	94800414 	ori	r18,r18,16
 8206f44:	9080080c 	andi	r2,r18,32
 8206f48:	10037b26 	beq	r2,zero,8207d38 <___vfprintf_internal_r+0x12fc>
 8206f4c:	d9402d17 	ldw	r5,180(sp)
 8206f50:	28800117 	ldw	r2,4(r5)
 8206f54:	2cc00017 	ldw	r19,0(r5)
 8206f58:	29400204 	addi	r5,r5,8
 8206f5c:	d9402d15 	stw	r5,180(sp)
 8206f60:	102d883a 	mov	r22,r2
 8206f64:	10044b16 	blt	r2,zero,8208094 <___vfprintf_internal_r+0x1658>
 8206f68:	d9402917 	ldw	r5,164(sp)
 8206f6c:	df002783 	ldbu	fp,158(sp)
 8206f70:	2803bc16 	blt	r5,zero,8207e64 <___vfprintf_internal_r+0x1428>
 8206f74:	00ffdfc4 	movi	r3,-129
 8206f78:	9d84b03a 	or	r2,r19,r22
 8206f7c:	90e4703a 	and	r18,r18,r3
 8206f80:	10017726 	beq	r2,zero,8207560 <___vfprintf_internal_r+0xb24>
 8206f84:	b0038326 	beq	r22,zero,8207d94 <___vfprintf_internal_r+0x1358>
 8206f88:	dc402a15 	stw	r17,168(sp)
 8206f8c:	dc001e04 	addi	r16,sp,120
 8206f90:	b023883a 	mov	r17,r22
 8206f94:	402d883a 	mov	r22,r8
 8206f98:	9809883a 	mov	r4,r19
 8206f9c:	880b883a 	mov	r5,r17
 8206fa0:	01800284 	movi	r6,10
 8206fa4:	000f883a 	mov	r7,zero
 8206fa8:	82118300 	call	8211830 <__umoddi3>
 8206fac:	10800c04 	addi	r2,r2,48
 8206fb0:	843fffc4 	addi	r16,r16,-1
 8206fb4:	9809883a 	mov	r4,r19
 8206fb8:	880b883a 	mov	r5,r17
 8206fbc:	80800005 	stb	r2,0(r16)
 8206fc0:	01800284 	movi	r6,10
 8206fc4:	000f883a 	mov	r7,zero
 8206fc8:	82112b80 	call	82112b8 <__udivdi3>
 8206fcc:	1027883a 	mov	r19,r2
 8206fd0:	10c4b03a 	or	r2,r2,r3
 8206fd4:	1823883a 	mov	r17,r3
 8206fd8:	103fef1e 	bne	r2,zero,8206f98 <___vfprintf_internal_r+0x55c>
 8206fdc:	d8c02817 	ldw	r3,160(sp)
 8206fe0:	dc402a17 	ldw	r17,168(sp)
 8206fe4:	b011883a 	mov	r8,r22
 8206fe8:	1c07c83a 	sub	r3,r3,r16
 8206fec:	d8c02e15 	stw	r3,184(sp)
 8206ff0:	00005906 	br	8207158 <___vfprintf_internal_r+0x71c>
 8206ff4:	18c03fcc 	andi	r3,r3,255
 8206ff8:	1806fa1e 	bne	r3,zero,8208be4 <___vfprintf_internal_r+0x21a8>
 8206ffc:	9080020c 	andi	r2,r18,8
 8207000:	10048a26 	beq	r2,zero,820822c <___vfprintf_internal_r+0x17f0>
 8207004:	d8c02d17 	ldw	r3,180(sp)
 8207008:	d9002d17 	ldw	r4,180(sp)
 820700c:	d9402d17 	ldw	r5,180(sp)
 8207010:	18c00017 	ldw	r3,0(r3)
 8207014:	21000117 	ldw	r4,4(r4)
 8207018:	29400204 	addi	r5,r5,8
 820701c:	d8c03615 	stw	r3,216(sp)
 8207020:	d9003815 	stw	r4,224(sp)
 8207024:	d9402d15 	stw	r5,180(sp)
 8207028:	d9003617 	ldw	r4,216(sp)
 820702c:	d9403817 	ldw	r5,224(sp)
 8207030:	da003d15 	stw	r8,244(sp)
 8207034:	04000044 	movi	r16,1
 8207038:	820dda80 	call	820dda8 <__fpclassifyd>
 820703c:	da003d17 	ldw	r8,244(sp)
 8207040:	14041f1e 	bne	r2,r16,82080c0 <___vfprintf_internal_r+0x1684>
 8207044:	d9003617 	ldw	r4,216(sp)
 8207048:	d9403817 	ldw	r5,224(sp)
 820704c:	000d883a 	mov	r6,zero
 8207050:	000f883a 	mov	r7,zero
 8207054:	82130600 	call	8213060 <__ledf2>
 8207058:	da003d17 	ldw	r8,244(sp)
 820705c:	1005be16 	blt	r2,zero,8208758 <___vfprintf_internal_r+0x1d1c>
 8207060:	df002783 	ldbu	fp,158(sp)
 8207064:	008011c4 	movi	r2,71
 8207068:	1445330e 	bge	r2,r17,8208538 <___vfprintf_internal_r+0x1afc>
 820706c:	04020974 	movhi	r16,2085
 8207070:	8436bb04 	addi	r16,r16,-9492
 8207074:	00c000c4 	movi	r3,3
 8207078:	00bfdfc4 	movi	r2,-129
 820707c:	d8c02a15 	stw	r3,168(sp)
 8207080:	90a4703a 	and	r18,r18,r2
 8207084:	d8c02e15 	stw	r3,184(sp)
 8207088:	d8002915 	stw	zero,164(sp)
 820708c:	d8003215 	stw	zero,200(sp)
 8207090:	00003706 	br	8207170 <___vfprintf_internal_r+0x734>
 8207094:	94800214 	ori	r18,r18,8
 8207098:	ac400007 	ldb	r17,0(r21)
 820709c:	003ec806 	br	8206bc0 <___vfprintf_internal_r+0x184>
 82070a0:	18c03fcc 	andi	r3,r3,255
 82070a4:	1806db1e 	bne	r3,zero,8208c14 <___vfprintf_internal_r+0x21d8>
 82070a8:	94800414 	ori	r18,r18,16
 82070ac:	9080080c 	andi	r2,r18,32
 82070b0:	1002d826 	beq	r2,zero,8207c14 <___vfprintf_internal_r+0x11d8>
 82070b4:	d9402d17 	ldw	r5,180(sp)
 82070b8:	d8c02917 	ldw	r3,164(sp)
 82070bc:	d8002785 	stb	zero,158(sp)
 82070c0:	28800204 	addi	r2,r5,8
 82070c4:	2cc00017 	ldw	r19,0(r5)
 82070c8:	2d800117 	ldw	r22,4(r5)
 82070cc:	18048f16 	blt	r3,zero,820830c <___vfprintf_internal_r+0x18d0>
 82070d0:	013fdfc4 	movi	r4,-129
 82070d4:	9d86b03a 	or	r3,r19,r22
 82070d8:	d8802d15 	stw	r2,180(sp)
 82070dc:	9124703a 	and	r18,r18,r4
 82070e0:	1802d91e 	bne	r3,zero,8207c48 <___vfprintf_internal_r+0x120c>
 82070e4:	d8c02917 	ldw	r3,164(sp)
 82070e8:	0039883a 	mov	fp,zero
 82070ec:	1805c326 	beq	r3,zero,82087fc <___vfprintf_internal_r+0x1dc0>
 82070f0:	0027883a 	mov	r19,zero
 82070f4:	002d883a 	mov	r22,zero
 82070f8:	dc001e04 	addi	r16,sp,120
 82070fc:	9806d0fa 	srli	r3,r19,3
 8207100:	b008977a 	slli	r4,r22,29
 8207104:	b02cd0fa 	srli	r22,r22,3
 8207108:	9cc001cc 	andi	r19,r19,7
 820710c:	98800c04 	addi	r2,r19,48
 8207110:	843fffc4 	addi	r16,r16,-1
 8207114:	20e6b03a 	or	r19,r4,r3
 8207118:	80800005 	stb	r2,0(r16)
 820711c:	9d86b03a 	or	r3,r19,r22
 8207120:	183ff61e 	bne	r3,zero,82070fc <___vfprintf_internal_r+0x6c0>
 8207124:	90c0004c 	andi	r3,r18,1
 8207128:	18013b26 	beq	r3,zero,8207618 <___vfprintf_internal_r+0xbdc>
 820712c:	10803fcc 	andi	r2,r2,255
 8207130:	1080201c 	xori	r2,r2,128
 8207134:	10bfe004 	addi	r2,r2,-128
 8207138:	00c00c04 	movi	r3,48
 820713c:	10c13626 	beq	r2,r3,8207618 <___vfprintf_internal_r+0xbdc>
 8207140:	80ffffc5 	stb	r3,-1(r16)
 8207144:	d8c02817 	ldw	r3,160(sp)
 8207148:	80bfffc4 	addi	r2,r16,-1
 820714c:	1021883a 	mov	r16,r2
 8207150:	1887c83a 	sub	r3,r3,r2
 8207154:	d8c02e15 	stw	r3,184(sp)
 8207158:	d8802e17 	ldw	r2,184(sp)
 820715c:	d9002917 	ldw	r4,164(sp)
 8207160:	1100010e 	bge	r2,r4,8207168 <___vfprintf_internal_r+0x72c>
 8207164:	2005883a 	mov	r2,r4
 8207168:	d8802a15 	stw	r2,168(sp)
 820716c:	d8003215 	stw	zero,200(sp)
 8207170:	e7003fcc 	andi	fp,fp,255
 8207174:	e700201c 	xori	fp,fp,128
 8207178:	e73fe004 	addi	fp,fp,-128
 820717c:	e0000326 	beq	fp,zero,820718c <___vfprintf_internal_r+0x750>
 8207180:	d8c02a17 	ldw	r3,168(sp)
 8207184:	18c00044 	addi	r3,r3,1
 8207188:	d8c02a15 	stw	r3,168(sp)
 820718c:	90c0008c 	andi	r3,r18,2
 8207190:	d8c02b15 	stw	r3,172(sp)
 8207194:	18000326 	beq	r3,zero,82071a4 <___vfprintf_internal_r+0x768>
 8207198:	d8c02a17 	ldw	r3,168(sp)
 820719c:	18c00084 	addi	r3,r3,2
 82071a0:	d8c02a15 	stw	r3,168(sp)
 82071a4:	90c0210c 	andi	r3,r18,132
 82071a8:	d8c03015 	stw	r3,192(sp)
 82071ac:	1801a31e 	bne	r3,zero,820783c <___vfprintf_internal_r+0xe00>
 82071b0:	d9003117 	ldw	r4,196(sp)
 82071b4:	d8c02a17 	ldw	r3,168(sp)
 82071b8:	20e7c83a 	sub	r19,r4,r3
 82071bc:	04c19f0e 	bge	zero,r19,820783c <___vfprintf_internal_r+0xe00>
 82071c0:	02400404 	movi	r9,16
 82071c4:	d8c02017 	ldw	r3,128(sp)
 82071c8:	d8801f17 	ldw	r2,124(sp)
 82071cc:	4cc50d0e 	bge	r9,r19,8208604 <___vfprintf_internal_r+0x1bc8>
 82071d0:	01420974 	movhi	r5,2085
 82071d4:	2976d684 	addi	r5,r5,-9382
 82071d8:	dc403b15 	stw	r17,236(sp)
 82071dc:	d9403515 	stw	r5,212(sp)
 82071e0:	9823883a 	mov	r17,r19
 82071e4:	482d883a 	mov	r22,r9
 82071e8:	9027883a 	mov	r19,r18
 82071ec:	070001c4 	movi	fp,7
 82071f0:	8025883a 	mov	r18,r16
 82071f4:	dc002c17 	ldw	r16,176(sp)
 82071f8:	00000306 	br	8207208 <___vfprintf_internal_r+0x7cc>
 82071fc:	8c7ffc04 	addi	r17,r17,-16
 8207200:	42000204 	addi	r8,r8,8
 8207204:	b440130e 	bge	r22,r17,8207254 <___vfprintf_internal_r+0x818>
 8207208:	01020974 	movhi	r4,2085
 820720c:	18c00404 	addi	r3,r3,16
 8207210:	10800044 	addi	r2,r2,1
 8207214:	2136d684 	addi	r4,r4,-9382
 8207218:	41000015 	stw	r4,0(r8)
 820721c:	45800115 	stw	r22,4(r8)
 8207220:	d8c02015 	stw	r3,128(sp)
 8207224:	d8801f15 	stw	r2,124(sp)
 8207228:	e0bff40e 	bge	fp,r2,82071fc <___vfprintf_internal_r+0x7c0>
 820722c:	d9801e04 	addi	r6,sp,120
 8207230:	b80b883a 	mov	r5,r23
 8207234:	8009883a 	mov	r4,r16
 8207238:	820f5900 	call	820f590 <__sprint_r>
 820723c:	103f011e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 8207240:	8c7ffc04 	addi	r17,r17,-16
 8207244:	d8c02017 	ldw	r3,128(sp)
 8207248:	d8801f17 	ldw	r2,124(sp)
 820724c:	da000404 	addi	r8,sp,16
 8207250:	b47fed16 	blt	r22,r17,8207208 <___vfprintf_internal_r+0x7cc>
 8207254:	9021883a 	mov	r16,r18
 8207258:	9825883a 	mov	r18,r19
 820725c:	8827883a 	mov	r19,r17
 8207260:	dc403b17 	ldw	r17,236(sp)
 8207264:	d9403517 	ldw	r5,212(sp)
 8207268:	98c7883a 	add	r3,r19,r3
 820726c:	10800044 	addi	r2,r2,1
 8207270:	41400015 	stw	r5,0(r8)
 8207274:	44c00115 	stw	r19,4(r8)
 8207278:	d8c02015 	stw	r3,128(sp)
 820727c:	d8801f15 	stw	r2,124(sp)
 8207280:	010001c4 	movi	r4,7
 8207284:	2082a316 	blt	r4,r2,8207d14 <___vfprintf_internal_r+0x12d8>
 8207288:	df002787 	ldb	fp,158(sp)
 820728c:	42000204 	addi	r8,r8,8
 8207290:	e0000c26 	beq	fp,zero,82072c4 <___vfprintf_internal_r+0x888>
 8207294:	d8801f17 	ldw	r2,124(sp)
 8207298:	d9002784 	addi	r4,sp,158
 820729c:	18c00044 	addi	r3,r3,1
 82072a0:	10800044 	addi	r2,r2,1
 82072a4:	41000015 	stw	r4,0(r8)
 82072a8:	01000044 	movi	r4,1
 82072ac:	41000115 	stw	r4,4(r8)
 82072b0:	d8c02015 	stw	r3,128(sp)
 82072b4:	d8801f15 	stw	r2,124(sp)
 82072b8:	010001c4 	movi	r4,7
 82072bc:	20823c16 	blt	r4,r2,8207bb0 <___vfprintf_internal_r+0x1174>
 82072c0:	42000204 	addi	r8,r8,8
 82072c4:	d8802b17 	ldw	r2,172(sp)
 82072c8:	10000c26 	beq	r2,zero,82072fc <___vfprintf_internal_r+0x8c0>
 82072cc:	d8801f17 	ldw	r2,124(sp)
 82072d0:	d9002704 	addi	r4,sp,156
 82072d4:	18c00084 	addi	r3,r3,2
 82072d8:	10800044 	addi	r2,r2,1
 82072dc:	41000015 	stw	r4,0(r8)
 82072e0:	01000084 	movi	r4,2
 82072e4:	41000115 	stw	r4,4(r8)
 82072e8:	d8c02015 	stw	r3,128(sp)
 82072ec:	d8801f15 	stw	r2,124(sp)
 82072f0:	010001c4 	movi	r4,7
 82072f4:	20823616 	blt	r4,r2,8207bd0 <___vfprintf_internal_r+0x1194>
 82072f8:	42000204 	addi	r8,r8,8
 82072fc:	d9003017 	ldw	r4,192(sp)
 8207300:	00802004 	movi	r2,128
 8207304:	20819926 	beq	r4,r2,820796c <___vfprintf_internal_r+0xf30>
 8207308:	d9402917 	ldw	r5,164(sp)
 820730c:	d8802e17 	ldw	r2,184(sp)
 8207310:	28adc83a 	sub	r22,r5,r2
 8207314:	0580310e 	bge	zero,r22,82073dc <___vfprintf_internal_r+0x9a0>
 8207318:	07000404 	movi	fp,16
 820731c:	d8801f17 	ldw	r2,124(sp)
 8207320:	e584140e 	bge	fp,r22,8208374 <___vfprintf_internal_r+0x1938>
 8207324:	01420974 	movhi	r5,2085
 8207328:	2976d284 	addi	r5,r5,-9398
 820732c:	dc402915 	stw	r17,164(sp)
 8207330:	d9402b15 	stw	r5,172(sp)
 8207334:	b023883a 	mov	r17,r22
 8207338:	04c001c4 	movi	r19,7
 820733c:	a82d883a 	mov	r22,r21
 8207340:	902b883a 	mov	r21,r18
 8207344:	8025883a 	mov	r18,r16
 8207348:	dc002c17 	ldw	r16,176(sp)
 820734c:	00000306 	br	820735c <___vfprintf_internal_r+0x920>
 8207350:	8c7ffc04 	addi	r17,r17,-16
 8207354:	42000204 	addi	r8,r8,8
 8207358:	e440110e 	bge	fp,r17,82073a0 <___vfprintf_internal_r+0x964>
 820735c:	18c00404 	addi	r3,r3,16
 8207360:	10800044 	addi	r2,r2,1
 8207364:	45000015 	stw	r20,0(r8)
 8207368:	47000115 	stw	fp,4(r8)
 820736c:	d8c02015 	stw	r3,128(sp)
 8207370:	d8801f15 	stw	r2,124(sp)
 8207374:	98bff60e 	bge	r19,r2,8207350 <___vfprintf_internal_r+0x914>
 8207378:	d9801e04 	addi	r6,sp,120
 820737c:	b80b883a 	mov	r5,r23
 8207380:	8009883a 	mov	r4,r16
 8207384:	820f5900 	call	820f590 <__sprint_r>
 8207388:	103eae1e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 820738c:	8c7ffc04 	addi	r17,r17,-16
 8207390:	d8c02017 	ldw	r3,128(sp)
 8207394:	d8801f17 	ldw	r2,124(sp)
 8207398:	da000404 	addi	r8,sp,16
 820739c:	e47fef16 	blt	fp,r17,820735c <___vfprintf_internal_r+0x920>
 82073a0:	9021883a 	mov	r16,r18
 82073a4:	a825883a 	mov	r18,r21
 82073a8:	b02b883a 	mov	r21,r22
 82073ac:	882d883a 	mov	r22,r17
 82073b0:	dc402917 	ldw	r17,164(sp)
 82073b4:	d9002b17 	ldw	r4,172(sp)
 82073b8:	1d87883a 	add	r3,r3,r22
 82073bc:	10800044 	addi	r2,r2,1
 82073c0:	41000015 	stw	r4,0(r8)
 82073c4:	45800115 	stw	r22,4(r8)
 82073c8:	d8c02015 	stw	r3,128(sp)
 82073cc:	d8801f15 	stw	r2,124(sp)
 82073d0:	010001c4 	movi	r4,7
 82073d4:	2081ee16 	blt	r4,r2,8207b90 <___vfprintf_internal_r+0x1154>
 82073d8:	42000204 	addi	r8,r8,8
 82073dc:	9080400c 	andi	r2,r18,256
 82073e0:	1001181e 	bne	r2,zero,8207844 <___vfprintf_internal_r+0xe08>
 82073e4:	d9402e17 	ldw	r5,184(sp)
 82073e8:	d8801f17 	ldw	r2,124(sp)
 82073ec:	44000015 	stw	r16,0(r8)
 82073f0:	1947883a 	add	r3,r3,r5
 82073f4:	10800044 	addi	r2,r2,1
 82073f8:	41400115 	stw	r5,4(r8)
 82073fc:	d8c02015 	stw	r3,128(sp)
 8207400:	d8801f15 	stw	r2,124(sp)
 8207404:	010001c4 	movi	r4,7
 8207408:	2081d316 	blt	r4,r2,8207b58 <___vfprintf_internal_r+0x111c>
 820740c:	42000204 	addi	r8,r8,8
 8207410:	9480010c 	andi	r18,r18,4
 8207414:	90003226 	beq	r18,zero,82074e0 <___vfprintf_internal_r+0xaa4>
 8207418:	d9403117 	ldw	r5,196(sp)
 820741c:	d8802a17 	ldw	r2,168(sp)
 8207420:	28a1c83a 	sub	r16,r5,r2
 8207424:	04002e0e 	bge	zero,r16,82074e0 <___vfprintf_internal_r+0xaa4>
 8207428:	04400404 	movi	r17,16
 820742c:	d8801f17 	ldw	r2,124(sp)
 8207430:	8c04a20e 	bge	r17,r16,82086bc <___vfprintf_internal_r+0x1c80>
 8207434:	01420974 	movhi	r5,2085
 8207438:	2976d684 	addi	r5,r5,-9382
 820743c:	d9403515 	stw	r5,212(sp)
 8207440:	048001c4 	movi	r18,7
 8207444:	dcc02c17 	ldw	r19,176(sp)
 8207448:	00000306 	br	8207458 <___vfprintf_internal_r+0xa1c>
 820744c:	843ffc04 	addi	r16,r16,-16
 8207450:	42000204 	addi	r8,r8,8
 8207454:	8c00130e 	bge	r17,r16,82074a4 <___vfprintf_internal_r+0xa68>
 8207458:	01020974 	movhi	r4,2085
 820745c:	18c00404 	addi	r3,r3,16
 8207460:	10800044 	addi	r2,r2,1
 8207464:	2136d684 	addi	r4,r4,-9382
 8207468:	41000015 	stw	r4,0(r8)
 820746c:	44400115 	stw	r17,4(r8)
 8207470:	d8c02015 	stw	r3,128(sp)
 8207474:	d8801f15 	stw	r2,124(sp)
 8207478:	90bff40e 	bge	r18,r2,820744c <___vfprintf_internal_r+0xa10>
 820747c:	d9801e04 	addi	r6,sp,120
 8207480:	b80b883a 	mov	r5,r23
 8207484:	9809883a 	mov	r4,r19
 8207488:	820f5900 	call	820f590 <__sprint_r>
 820748c:	103e6d1e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 8207490:	843ffc04 	addi	r16,r16,-16
 8207494:	d8c02017 	ldw	r3,128(sp)
 8207498:	d8801f17 	ldw	r2,124(sp)
 820749c:	da000404 	addi	r8,sp,16
 82074a0:	8c3fed16 	blt	r17,r16,8207458 <___vfprintf_internal_r+0xa1c>
 82074a4:	d9403517 	ldw	r5,212(sp)
 82074a8:	1c07883a 	add	r3,r3,r16
 82074ac:	10800044 	addi	r2,r2,1
 82074b0:	41400015 	stw	r5,0(r8)
 82074b4:	44000115 	stw	r16,4(r8)
 82074b8:	d8c02015 	stw	r3,128(sp)
 82074bc:	d8801f15 	stw	r2,124(sp)
 82074c0:	010001c4 	movi	r4,7
 82074c4:	2080060e 	bge	r4,r2,82074e0 <___vfprintf_internal_r+0xaa4>
 82074c8:	d9002c17 	ldw	r4,176(sp)
 82074cc:	d9801e04 	addi	r6,sp,120
 82074d0:	b80b883a 	mov	r5,r23
 82074d4:	820f5900 	call	820f590 <__sprint_r>
 82074d8:	103e5a1e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 82074dc:	d8c02017 	ldw	r3,128(sp)
 82074e0:	d8803117 	ldw	r2,196(sp)
 82074e4:	d9002a17 	ldw	r4,168(sp)
 82074e8:	1100010e 	bge	r2,r4,82074f0 <___vfprintf_internal_r+0xab4>
 82074ec:	2005883a 	mov	r2,r4
 82074f0:	d9402f17 	ldw	r5,188(sp)
 82074f4:	288b883a 	add	r5,r5,r2
 82074f8:	d9402f15 	stw	r5,188(sp)
 82074fc:	18019e1e 	bne	r3,zero,8207b78 <___vfprintf_internal_r+0x113c>
 8207500:	a8800007 	ldb	r2,0(r21)
 8207504:	d8001f15 	stw	zero,124(sp)
 8207508:	da000404 	addi	r8,sp,16
 820750c:	103d851e 	bne	r2,zero,8206b24 <___vfprintf_internal_r+0xe8>
 8207510:	a821883a 	mov	r16,r21
 8207514:	003d9b06 	br	8206b84 <___vfprintf_internal_r+0x148>
 8207518:	18c03fcc 	andi	r3,r3,255
 820751c:	1805c11e 	bne	r3,zero,8208c24 <___vfprintf_internal_r+0x21e8>
 8207520:	94800414 	ori	r18,r18,16
 8207524:	9080080c 	andi	r2,r18,32
 8207528:	10020c26 	beq	r2,zero,8207d5c <___vfprintf_internal_r+0x1320>
 820752c:	d8802d17 	ldw	r2,180(sp)
 8207530:	d9002917 	ldw	r4,164(sp)
 8207534:	d8002785 	stb	zero,158(sp)
 8207538:	10c00204 	addi	r3,r2,8
 820753c:	14c00017 	ldw	r19,0(r2)
 8207540:	15800117 	ldw	r22,4(r2)
 8207544:	20040f16 	blt	r4,zero,8208584 <___vfprintf_internal_r+0x1b48>
 8207548:	013fdfc4 	movi	r4,-129
 820754c:	9d84b03a 	or	r2,r19,r22
 8207550:	d8c02d15 	stw	r3,180(sp)
 8207554:	9124703a 	and	r18,r18,r4
 8207558:	0039883a 	mov	fp,zero
 820755c:	103e891e 	bne	r2,zero,8206f84 <___vfprintf_internal_r+0x548>
 8207560:	d9002917 	ldw	r4,164(sp)
 8207564:	2002c11e 	bne	r4,zero,820806c <___vfprintf_internal_r+0x1630>
 8207568:	d8002915 	stw	zero,164(sp)
 820756c:	d8002e15 	stw	zero,184(sp)
 8207570:	dc001e04 	addi	r16,sp,120
 8207574:	003ef806 	br	8207158 <___vfprintf_internal_r+0x71c>
 8207578:	18c03fcc 	andi	r3,r3,255
 820757c:	18059d1e 	bne	r3,zero,8208bf4 <___vfprintf_internal_r+0x21b8>
 8207580:	01420974 	movhi	r5,2085
 8207584:	2976be04 	addi	r5,r5,-9480
 8207588:	d9403915 	stw	r5,228(sp)
 820758c:	9080080c 	andi	r2,r18,32
 8207590:	10005226 	beq	r2,zero,82076dc <___vfprintf_internal_r+0xca0>
 8207594:	d8802d17 	ldw	r2,180(sp)
 8207598:	14c00017 	ldw	r19,0(r2)
 820759c:	15800117 	ldw	r22,4(r2)
 82075a0:	10800204 	addi	r2,r2,8
 82075a4:	d8802d15 	stw	r2,180(sp)
 82075a8:	9080004c 	andi	r2,r18,1
 82075ac:	10019026 	beq	r2,zero,8207bf0 <___vfprintf_internal_r+0x11b4>
 82075b0:	9d84b03a 	or	r2,r19,r22
 82075b4:	10036926 	beq	r2,zero,820835c <___vfprintf_internal_r+0x1920>
 82075b8:	d8c02917 	ldw	r3,164(sp)
 82075bc:	00800c04 	movi	r2,48
 82075c0:	d8802705 	stb	r2,156(sp)
 82075c4:	dc402745 	stb	r17,157(sp)
 82075c8:	d8002785 	stb	zero,158(sp)
 82075cc:	90800094 	ori	r2,r18,2
 82075d0:	18045d16 	blt	r3,zero,8208748 <___vfprintf_internal_r+0x1d0c>
 82075d4:	00bfdfc4 	movi	r2,-129
 82075d8:	90a4703a 	and	r18,r18,r2
 82075dc:	94800094 	ori	r18,r18,2
 82075e0:	0039883a 	mov	fp,zero
 82075e4:	d9003917 	ldw	r4,228(sp)
 82075e8:	dc001e04 	addi	r16,sp,120
 82075ec:	988003cc 	andi	r2,r19,15
 82075f0:	b006973a 	slli	r3,r22,28
 82075f4:	2085883a 	add	r2,r4,r2
 82075f8:	9826d13a 	srli	r19,r19,4
 82075fc:	10800003 	ldbu	r2,0(r2)
 8207600:	b02cd13a 	srli	r22,r22,4
 8207604:	843fffc4 	addi	r16,r16,-1
 8207608:	1ce6b03a 	or	r19,r3,r19
 820760c:	80800005 	stb	r2,0(r16)
 8207610:	9d84b03a 	or	r2,r19,r22
 8207614:	103ff51e 	bne	r2,zero,82075ec <___vfprintf_internal_r+0xbb0>
 8207618:	d8c02817 	ldw	r3,160(sp)
 820761c:	1c07c83a 	sub	r3,r3,r16
 8207620:	d8c02e15 	stw	r3,184(sp)
 8207624:	003ecc06 	br	8207158 <___vfprintf_internal_r+0x71c>
 8207628:	18c03fcc 	andi	r3,r3,255
 820762c:	183e9f26 	beq	r3,zero,82070ac <___vfprintf_internal_r+0x670>
 8207630:	d9c02785 	stb	r7,158(sp)
 8207634:	003e9d06 	br	82070ac <___vfprintf_internal_r+0x670>
 8207638:	00c00044 	movi	r3,1
 820763c:	01c00ac4 	movi	r7,43
 8207640:	ac400007 	ldb	r17,0(r21)
 8207644:	003d5e06 	br	8206bc0 <___vfprintf_internal_r+0x184>
 8207648:	94800814 	ori	r18,r18,32
 820764c:	ac400007 	ldb	r17,0(r21)
 8207650:	003d5b06 	br	8206bc0 <___vfprintf_internal_r+0x184>
 8207654:	d8c02d17 	ldw	r3,180(sp)
 8207658:	d8002785 	stb	zero,158(sp)
 820765c:	1c000017 	ldw	r16,0(r3)
 8207660:	1cc00104 	addi	r19,r3,4
 8207664:	80041926 	beq	r16,zero,82086cc <___vfprintf_internal_r+0x1c90>
 8207668:	d9002917 	ldw	r4,164(sp)
 820766c:	2003d016 	blt	r4,zero,82085b0 <___vfprintf_internal_r+0x1b74>
 8207670:	200d883a 	mov	r6,r4
 8207674:	000b883a 	mov	r5,zero
 8207678:	8009883a 	mov	r4,r16
 820767c:	da003d15 	stw	r8,244(sp)
 8207680:	820c4f80 	call	820c4f8 <memchr>
 8207684:	da003d17 	ldw	r8,244(sp)
 8207688:	10045426 	beq	r2,zero,82087dc <___vfprintf_internal_r+0x1da0>
 820768c:	1405c83a 	sub	r2,r2,r16
 8207690:	d8802e15 	stw	r2,184(sp)
 8207694:	1003cc16 	blt	r2,zero,82085c8 <___vfprintf_internal_r+0x1b8c>
 8207698:	df002783 	ldbu	fp,158(sp)
 820769c:	d8802a15 	stw	r2,168(sp)
 82076a0:	dcc02d15 	stw	r19,180(sp)
 82076a4:	d8002915 	stw	zero,164(sp)
 82076a8:	d8003215 	stw	zero,200(sp)
 82076ac:	003eb006 	br	8207170 <___vfprintf_internal_r+0x734>
 82076b0:	18c03fcc 	andi	r3,r3,255
 82076b4:	183f9b26 	beq	r3,zero,8207524 <___vfprintf_internal_r+0xae8>
 82076b8:	d9c02785 	stb	r7,158(sp)
 82076bc:	003f9906 	br	8207524 <___vfprintf_internal_r+0xae8>
 82076c0:	18c03fcc 	andi	r3,r3,255
 82076c4:	1805551e 	bne	r3,zero,8208c1c <___vfprintf_internal_r+0x21e0>
 82076c8:	01420974 	movhi	r5,2085
 82076cc:	2976c304 	addi	r5,r5,-9460
 82076d0:	d9403915 	stw	r5,228(sp)
 82076d4:	9080080c 	andi	r2,r18,32
 82076d8:	103fae1e 	bne	r2,zero,8207594 <___vfprintf_internal_r+0xb58>
 82076dc:	9080040c 	andi	r2,r18,16
 82076e0:	1002de26 	beq	r2,zero,820825c <___vfprintf_internal_r+0x1820>
 82076e4:	d8c02d17 	ldw	r3,180(sp)
 82076e8:	002d883a 	mov	r22,zero
 82076ec:	1cc00017 	ldw	r19,0(r3)
 82076f0:	18c00104 	addi	r3,r3,4
 82076f4:	d8c02d15 	stw	r3,180(sp)
 82076f8:	003fab06 	br	82075a8 <___vfprintf_internal_r+0xb6c>
 82076fc:	38803fcc 	andi	r2,r7,255
 8207700:	1080201c 	xori	r2,r2,128
 8207704:	10bfe004 	addi	r2,r2,-128
 8207708:	1002d21e 	bne	r2,zero,8208254 <___vfprintf_internal_r+0x1818>
 820770c:	00c00044 	movi	r3,1
 8207710:	01c00804 	movi	r7,32
 8207714:	ac400007 	ldb	r17,0(r21)
 8207718:	003d2906 	br	8206bc0 <___vfprintf_internal_r+0x184>
 820771c:	94800054 	ori	r18,r18,1
 8207720:	ac400007 	ldb	r17,0(r21)
 8207724:	003d2606 	br	8206bc0 <___vfprintf_internal_r+0x184>
 8207728:	18c03fcc 	andi	r3,r3,255
 820772c:	183e0526 	beq	r3,zero,8206f44 <___vfprintf_internal_r+0x508>
 8207730:	d9c02785 	stb	r7,158(sp)
 8207734:	003e0306 	br	8206f44 <___vfprintf_internal_r+0x508>
 8207738:	94801014 	ori	r18,r18,64
 820773c:	ac400007 	ldb	r17,0(r21)
 8207740:	003d1f06 	br	8206bc0 <___vfprintf_internal_r+0x184>
 8207744:	ac400007 	ldb	r17,0(r21)
 8207748:	8a438726 	beq	r17,r9,8208568 <___vfprintf_internal_r+0x1b2c>
 820774c:	94800414 	ori	r18,r18,16
 8207750:	003d1b06 	br	8206bc0 <___vfprintf_internal_r+0x184>
 8207754:	18c03fcc 	andi	r3,r3,255
 8207758:	1805341e 	bne	r3,zero,8208c2c <___vfprintf_internal_r+0x21f0>
 820775c:	9080080c 	andi	r2,r18,32
 8207760:	1002cd26 	beq	r2,zero,8208298 <___vfprintf_internal_r+0x185c>
 8207764:	d9402d17 	ldw	r5,180(sp)
 8207768:	d9002f17 	ldw	r4,188(sp)
 820776c:	28800017 	ldw	r2,0(r5)
 8207770:	2007d7fa 	srai	r3,r4,31
 8207774:	29400104 	addi	r5,r5,4
 8207778:	d9402d15 	stw	r5,180(sp)
 820777c:	11000015 	stw	r4,0(r2)
 8207780:	10c00115 	stw	r3,4(r2)
 8207784:	003ce506 	br	8206b1c <___vfprintf_internal_r+0xe0>
 8207788:	d8c02d17 	ldw	r3,180(sp)
 820778c:	d9002d17 	ldw	r4,180(sp)
 8207790:	d8002785 	stb	zero,158(sp)
 8207794:	18800017 	ldw	r2,0(r3)
 8207798:	21000104 	addi	r4,r4,4
 820779c:	00c00044 	movi	r3,1
 82077a0:	d8c02a15 	stw	r3,168(sp)
 82077a4:	d8801405 	stb	r2,80(sp)
 82077a8:	d9002d15 	stw	r4,180(sp)
 82077ac:	d8c02e15 	stw	r3,184(sp)
 82077b0:	d8002915 	stw	zero,164(sp)
 82077b4:	d8003215 	stw	zero,200(sp)
 82077b8:	dc001404 	addi	r16,sp,80
 82077bc:	0039883a 	mov	fp,zero
 82077c0:	003e7206 	br	820718c <___vfprintf_internal_r+0x750>
 82077c4:	01020974 	movhi	r4,2085
 82077c8:	2136c304 	addi	r4,r4,-9460
 82077cc:	0039883a 	mov	fp,zero
 82077d0:	d9003915 	stw	r4,228(sp)
 82077d4:	04401e04 	movi	r17,120
 82077d8:	003f8206 	br	82075e4 <___vfprintf_internal_r+0xba8>
 82077dc:	18c03fcc 	andi	r3,r3,255
 82077e0:	1805061e 	bne	r3,zero,8208bfc <___vfprintf_internal_r+0x21c0>
 82077e4:	883d9126 	beq	r17,zero,8206e2c <___vfprintf_internal_r+0x3f0>
 82077e8:	00c00044 	movi	r3,1
 82077ec:	d8c02a15 	stw	r3,168(sp)
 82077f0:	dc401405 	stb	r17,80(sp)
 82077f4:	d8002785 	stb	zero,158(sp)
 82077f8:	003fec06 	br	82077ac <___vfprintf_internal_r+0xd70>
 82077fc:	01420974 	movhi	r5,2085
 8207800:	2976c304 	addi	r5,r5,-9460
 8207804:	d9403915 	stw	r5,228(sp)
 8207808:	d8c02d15 	stw	r3,180(sp)
 820780c:	1025883a 	mov	r18,r2
 8207810:	04401e04 	movi	r17,120
 8207814:	9d84b03a 	or	r2,r19,r22
 8207818:	1000fc1e 	bne	r2,zero,8207c0c <___vfprintf_internal_r+0x11d0>
 820781c:	0039883a 	mov	fp,zero
 8207820:	00800084 	movi	r2,2
 8207824:	10803fcc 	andi	r2,r2,255
 8207828:	00c00044 	movi	r3,1
 820782c:	10c20f26 	beq	r2,r3,820806c <___vfprintf_internal_r+0x1630>
 8207830:	00c00084 	movi	r3,2
 8207834:	10fd6326 	beq	r2,r3,8206dc4 <___vfprintf_internal_r+0x388>
 8207838:	003e2d06 	br	82070f0 <___vfprintf_internal_r+0x6b4>
 820783c:	d8c02017 	ldw	r3,128(sp)
 8207840:	003e9306 	br	8207290 <___vfprintf_internal_r+0x854>
 8207844:	00801944 	movi	r2,101
 8207848:	14407e0e 	bge	r2,r17,8207a44 <___vfprintf_internal_r+0x1008>
 820784c:	d9003617 	ldw	r4,216(sp)
 8207850:	d9403817 	ldw	r5,224(sp)
 8207854:	000d883a 	mov	r6,zero
 8207858:	000f883a 	mov	r7,zero
 820785c:	d8c03c15 	stw	r3,240(sp)
 8207860:	da003d15 	stw	r8,244(sp)
 8207864:	8212efc0 	call	8212efc <__eqdf2>
 8207868:	d8c03c17 	ldw	r3,240(sp)
 820786c:	da003d17 	ldw	r8,244(sp)
 8207870:	1000f71e 	bne	r2,zero,8207c50 <___vfprintf_internal_r+0x1214>
 8207874:	d8801f17 	ldw	r2,124(sp)
 8207878:	01020974 	movhi	r4,2085
 820787c:	2136ca04 	addi	r4,r4,-9432
 8207880:	18c00044 	addi	r3,r3,1
 8207884:	10800044 	addi	r2,r2,1
 8207888:	41000015 	stw	r4,0(r8)
 820788c:	01000044 	movi	r4,1
 8207890:	41000115 	stw	r4,4(r8)
 8207894:	d8c02015 	stw	r3,128(sp)
 8207898:	d8801f15 	stw	r2,124(sp)
 820789c:	010001c4 	movi	r4,7
 82078a0:	2082b816 	blt	r4,r2,8208384 <___vfprintf_internal_r+0x1948>
 82078a4:	42000204 	addi	r8,r8,8
 82078a8:	d8802617 	ldw	r2,152(sp)
 82078ac:	d9403317 	ldw	r5,204(sp)
 82078b0:	11400216 	blt	r2,r5,82078bc <___vfprintf_internal_r+0xe80>
 82078b4:	9080004c 	andi	r2,r18,1
 82078b8:	103ed526 	beq	r2,zero,8207410 <___vfprintf_internal_r+0x9d4>
 82078bc:	d8803717 	ldw	r2,220(sp)
 82078c0:	d9003417 	ldw	r4,208(sp)
 82078c4:	d9403717 	ldw	r5,220(sp)
 82078c8:	1887883a 	add	r3,r3,r2
 82078cc:	d8801f17 	ldw	r2,124(sp)
 82078d0:	41000015 	stw	r4,0(r8)
 82078d4:	41400115 	stw	r5,4(r8)
 82078d8:	10800044 	addi	r2,r2,1
 82078dc:	d8c02015 	stw	r3,128(sp)
 82078e0:	d8801f15 	stw	r2,124(sp)
 82078e4:	010001c4 	movi	r4,7
 82078e8:	20832916 	blt	r4,r2,8208590 <___vfprintf_internal_r+0x1b54>
 82078ec:	42000204 	addi	r8,r8,8
 82078f0:	d8803317 	ldw	r2,204(sp)
 82078f4:	143fffc4 	addi	r16,r2,-1
 82078f8:	043ec50e 	bge	zero,r16,8207410 <___vfprintf_internal_r+0x9d4>
 82078fc:	04400404 	movi	r17,16
 8207900:	d8801f17 	ldw	r2,124(sp)
 8207904:	8c00880e 	bge	r17,r16,8207b28 <___vfprintf_internal_r+0x10ec>
 8207908:	01420974 	movhi	r5,2085
 820790c:	2976d284 	addi	r5,r5,-9398
 8207910:	d9402b15 	stw	r5,172(sp)
 8207914:	058001c4 	movi	r22,7
 8207918:	dcc02c17 	ldw	r19,176(sp)
 820791c:	00000306 	br	820792c <___vfprintf_internal_r+0xef0>
 8207920:	42000204 	addi	r8,r8,8
 8207924:	843ffc04 	addi	r16,r16,-16
 8207928:	8c00820e 	bge	r17,r16,8207b34 <___vfprintf_internal_r+0x10f8>
 820792c:	18c00404 	addi	r3,r3,16
 8207930:	10800044 	addi	r2,r2,1
 8207934:	45000015 	stw	r20,0(r8)
 8207938:	44400115 	stw	r17,4(r8)
 820793c:	d8c02015 	stw	r3,128(sp)
 8207940:	d8801f15 	stw	r2,124(sp)
 8207944:	b0bff60e 	bge	r22,r2,8207920 <___vfprintf_internal_r+0xee4>
 8207948:	d9801e04 	addi	r6,sp,120
 820794c:	b80b883a 	mov	r5,r23
 8207950:	9809883a 	mov	r4,r19
 8207954:	820f5900 	call	820f590 <__sprint_r>
 8207958:	103d3a1e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 820795c:	d8c02017 	ldw	r3,128(sp)
 8207960:	d8801f17 	ldw	r2,124(sp)
 8207964:	da000404 	addi	r8,sp,16
 8207968:	003fee06 	br	8207924 <___vfprintf_internal_r+0xee8>
 820796c:	d9403117 	ldw	r5,196(sp)
 8207970:	d8802a17 	ldw	r2,168(sp)
 8207974:	28adc83a 	sub	r22,r5,r2
 8207978:	05be630e 	bge	zero,r22,8207308 <___vfprintf_internal_r+0x8cc>
 820797c:	07000404 	movi	fp,16
 8207980:	d8801f17 	ldw	r2,124(sp)
 8207984:	e5838f0e 	bge	fp,r22,82087c4 <___vfprintf_internal_r+0x1d88>
 8207988:	01420974 	movhi	r5,2085
 820798c:	2976d284 	addi	r5,r5,-9398
 8207990:	dc403015 	stw	r17,192(sp)
 8207994:	d9402b15 	stw	r5,172(sp)
 8207998:	b023883a 	mov	r17,r22
 820799c:	04c001c4 	movi	r19,7
 82079a0:	a82d883a 	mov	r22,r21
 82079a4:	902b883a 	mov	r21,r18
 82079a8:	8025883a 	mov	r18,r16
 82079ac:	dc002c17 	ldw	r16,176(sp)
 82079b0:	00000306 	br	82079c0 <___vfprintf_internal_r+0xf84>
 82079b4:	8c7ffc04 	addi	r17,r17,-16
 82079b8:	42000204 	addi	r8,r8,8
 82079bc:	e440110e 	bge	fp,r17,8207a04 <___vfprintf_internal_r+0xfc8>
 82079c0:	18c00404 	addi	r3,r3,16
 82079c4:	10800044 	addi	r2,r2,1
 82079c8:	45000015 	stw	r20,0(r8)
 82079cc:	47000115 	stw	fp,4(r8)
 82079d0:	d8c02015 	stw	r3,128(sp)
 82079d4:	d8801f15 	stw	r2,124(sp)
 82079d8:	98bff60e 	bge	r19,r2,82079b4 <___vfprintf_internal_r+0xf78>
 82079dc:	d9801e04 	addi	r6,sp,120
 82079e0:	b80b883a 	mov	r5,r23
 82079e4:	8009883a 	mov	r4,r16
 82079e8:	820f5900 	call	820f590 <__sprint_r>
 82079ec:	103d151e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 82079f0:	8c7ffc04 	addi	r17,r17,-16
 82079f4:	d8c02017 	ldw	r3,128(sp)
 82079f8:	d8801f17 	ldw	r2,124(sp)
 82079fc:	da000404 	addi	r8,sp,16
 8207a00:	e47fef16 	blt	fp,r17,82079c0 <___vfprintf_internal_r+0xf84>
 8207a04:	9021883a 	mov	r16,r18
 8207a08:	a825883a 	mov	r18,r21
 8207a0c:	b02b883a 	mov	r21,r22
 8207a10:	882d883a 	mov	r22,r17
 8207a14:	dc403017 	ldw	r17,192(sp)
 8207a18:	d9002b17 	ldw	r4,172(sp)
 8207a1c:	1d87883a 	add	r3,r3,r22
 8207a20:	10800044 	addi	r2,r2,1
 8207a24:	41000015 	stw	r4,0(r8)
 8207a28:	45800115 	stw	r22,4(r8)
 8207a2c:	d8c02015 	stw	r3,128(sp)
 8207a30:	d8801f15 	stw	r2,124(sp)
 8207a34:	010001c4 	movi	r4,7
 8207a38:	20818e16 	blt	r4,r2,8208074 <___vfprintf_internal_r+0x1638>
 8207a3c:	42000204 	addi	r8,r8,8
 8207a40:	003e3106 	br	8207308 <___vfprintf_internal_r+0x8cc>
 8207a44:	d9403317 	ldw	r5,204(sp)
 8207a48:	00800044 	movi	r2,1
 8207a4c:	18c00044 	addi	r3,r3,1
 8207a50:	1141530e 	bge	r2,r5,8207fa0 <___vfprintf_internal_r+0x1564>
 8207a54:	dc401f17 	ldw	r17,124(sp)
 8207a58:	00800044 	movi	r2,1
 8207a5c:	40800115 	stw	r2,4(r8)
 8207a60:	8c400044 	addi	r17,r17,1
 8207a64:	44000015 	stw	r16,0(r8)
 8207a68:	d8c02015 	stw	r3,128(sp)
 8207a6c:	dc401f15 	stw	r17,124(sp)
 8207a70:	008001c4 	movi	r2,7
 8207a74:	14416b16 	blt	r2,r17,8208024 <___vfprintf_internal_r+0x15e8>
 8207a78:	42000204 	addi	r8,r8,8
 8207a7c:	d8803717 	ldw	r2,220(sp)
 8207a80:	d9003417 	ldw	r4,208(sp)
 8207a84:	8c400044 	addi	r17,r17,1
 8207a88:	10c7883a 	add	r3,r2,r3
 8207a8c:	40800115 	stw	r2,4(r8)
 8207a90:	41000015 	stw	r4,0(r8)
 8207a94:	d8c02015 	stw	r3,128(sp)
 8207a98:	dc401f15 	stw	r17,124(sp)
 8207a9c:	008001c4 	movi	r2,7
 8207aa0:	14416916 	blt	r2,r17,8208048 <___vfprintf_internal_r+0x160c>
 8207aa4:	45800204 	addi	r22,r8,8
 8207aa8:	d9003617 	ldw	r4,216(sp)
 8207aac:	d9403817 	ldw	r5,224(sp)
 8207ab0:	000d883a 	mov	r6,zero
 8207ab4:	000f883a 	mov	r7,zero
 8207ab8:	d8c03c15 	stw	r3,240(sp)
 8207abc:	8212efc0 	call	8212efc <__eqdf2>
 8207ac0:	d8c03c17 	ldw	r3,240(sp)
 8207ac4:	1000bc26 	beq	r2,zero,8207db8 <___vfprintf_internal_r+0x137c>
 8207ac8:	d9403317 	ldw	r5,204(sp)
 8207acc:	84000044 	addi	r16,r16,1
 8207ad0:	8c400044 	addi	r17,r17,1
 8207ad4:	28bfffc4 	addi	r2,r5,-1
 8207ad8:	1887883a 	add	r3,r3,r2
 8207adc:	b0800115 	stw	r2,4(r22)
 8207ae0:	b4000015 	stw	r16,0(r22)
 8207ae4:	d8c02015 	stw	r3,128(sp)
 8207ae8:	dc401f15 	stw	r17,124(sp)
 8207aec:	008001c4 	movi	r2,7
 8207af0:	14414316 	blt	r2,r17,8208000 <___vfprintf_internal_r+0x15c4>
 8207af4:	b5800204 	addi	r22,r22,8
 8207af8:	d9003a17 	ldw	r4,232(sp)
 8207afc:	df0022c4 	addi	fp,sp,139
 8207b00:	8c400044 	addi	r17,r17,1
 8207b04:	20c7883a 	add	r3,r4,r3
 8207b08:	b7000015 	stw	fp,0(r22)
 8207b0c:	b1000115 	stw	r4,4(r22)
 8207b10:	d8c02015 	stw	r3,128(sp)
 8207b14:	dc401f15 	stw	r17,124(sp)
 8207b18:	008001c4 	movi	r2,7
 8207b1c:	14400e16 	blt	r2,r17,8207b58 <___vfprintf_internal_r+0x111c>
 8207b20:	b2000204 	addi	r8,r22,8
 8207b24:	003e3a06 	br	8207410 <___vfprintf_internal_r+0x9d4>
 8207b28:	01020974 	movhi	r4,2085
 8207b2c:	2136d284 	addi	r4,r4,-9398
 8207b30:	d9002b15 	stw	r4,172(sp)
 8207b34:	d9002b17 	ldw	r4,172(sp)
 8207b38:	1c07883a 	add	r3,r3,r16
 8207b3c:	44000115 	stw	r16,4(r8)
 8207b40:	41000015 	stw	r4,0(r8)
 8207b44:	10800044 	addi	r2,r2,1
 8207b48:	d8c02015 	stw	r3,128(sp)
 8207b4c:	d8801f15 	stw	r2,124(sp)
 8207b50:	010001c4 	movi	r4,7
 8207b54:	20be2d0e 	bge	r4,r2,820740c <___vfprintf_internal_r+0x9d0>
 8207b58:	d9002c17 	ldw	r4,176(sp)
 8207b5c:	d9801e04 	addi	r6,sp,120
 8207b60:	b80b883a 	mov	r5,r23
 8207b64:	820f5900 	call	820f590 <__sprint_r>
 8207b68:	103cb61e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 8207b6c:	d8c02017 	ldw	r3,128(sp)
 8207b70:	da000404 	addi	r8,sp,16
 8207b74:	003e2606 	br	8207410 <___vfprintf_internal_r+0x9d4>
 8207b78:	d9002c17 	ldw	r4,176(sp)
 8207b7c:	d9801e04 	addi	r6,sp,120
 8207b80:	b80b883a 	mov	r5,r23
 8207b84:	820f5900 	call	820f590 <__sprint_r>
 8207b88:	103e5d26 	beq	r2,zero,8207500 <___vfprintf_internal_r+0xac4>
 8207b8c:	003cad06 	br	8206e44 <___vfprintf_internal_r+0x408>
 8207b90:	d9002c17 	ldw	r4,176(sp)
 8207b94:	d9801e04 	addi	r6,sp,120
 8207b98:	b80b883a 	mov	r5,r23
 8207b9c:	820f5900 	call	820f590 <__sprint_r>
 8207ba0:	103ca81e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 8207ba4:	d8c02017 	ldw	r3,128(sp)
 8207ba8:	da000404 	addi	r8,sp,16
 8207bac:	003e0b06 	br	82073dc <___vfprintf_internal_r+0x9a0>
 8207bb0:	d9002c17 	ldw	r4,176(sp)
 8207bb4:	d9801e04 	addi	r6,sp,120
 8207bb8:	b80b883a 	mov	r5,r23
 8207bbc:	820f5900 	call	820f590 <__sprint_r>
 8207bc0:	103ca01e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 8207bc4:	d8c02017 	ldw	r3,128(sp)
 8207bc8:	da000404 	addi	r8,sp,16
 8207bcc:	003dbd06 	br	82072c4 <___vfprintf_internal_r+0x888>
 8207bd0:	d9002c17 	ldw	r4,176(sp)
 8207bd4:	d9801e04 	addi	r6,sp,120
 8207bd8:	b80b883a 	mov	r5,r23
 8207bdc:	820f5900 	call	820f590 <__sprint_r>
 8207be0:	103c981e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 8207be4:	d8c02017 	ldw	r3,128(sp)
 8207be8:	da000404 	addi	r8,sp,16
 8207bec:	003dc306 	br	82072fc <___vfprintf_internal_r+0x8c0>
 8207bf0:	d8802917 	ldw	r2,164(sp)
 8207bf4:	d8002785 	stb	zero,158(sp)
 8207bf8:	103f0616 	blt	r2,zero,8207814 <___vfprintf_internal_r+0xdd8>
 8207bfc:	00ffdfc4 	movi	r3,-129
 8207c00:	9d84b03a 	or	r2,r19,r22
 8207c04:	90e4703a 	and	r18,r18,r3
 8207c08:	103c6b26 	beq	r2,zero,8206db8 <___vfprintf_internal_r+0x37c>
 8207c0c:	0039883a 	mov	fp,zero
 8207c10:	003e7406 	br	82075e4 <___vfprintf_internal_r+0xba8>
 8207c14:	9080040c 	andi	r2,r18,16
 8207c18:	1001b326 	beq	r2,zero,82082e8 <___vfprintf_internal_r+0x18ac>
 8207c1c:	d9002d17 	ldw	r4,180(sp)
 8207c20:	d9402917 	ldw	r5,164(sp)
 8207c24:	d8002785 	stb	zero,158(sp)
 8207c28:	20800104 	addi	r2,r4,4
 8207c2c:	24c00017 	ldw	r19,0(r4)
 8207c30:	002d883a 	mov	r22,zero
 8207c34:	2801b516 	blt	r5,zero,820830c <___vfprintf_internal_r+0x18d0>
 8207c38:	00ffdfc4 	movi	r3,-129
 8207c3c:	d8802d15 	stw	r2,180(sp)
 8207c40:	90e4703a 	and	r18,r18,r3
 8207c44:	983d2726 	beq	r19,zero,82070e4 <___vfprintf_internal_r+0x6a8>
 8207c48:	0039883a 	mov	fp,zero
 8207c4c:	003d2a06 	br	82070f8 <___vfprintf_internal_r+0x6bc>
 8207c50:	dc402617 	ldw	r17,152(sp)
 8207c54:	0441d30e 	bge	zero,r17,82083a4 <___vfprintf_internal_r+0x1968>
 8207c58:	dc403217 	ldw	r17,200(sp)
 8207c5c:	d8803317 	ldw	r2,204(sp)
 8207c60:	1440010e 	bge	r2,r17,8207c68 <___vfprintf_internal_r+0x122c>
 8207c64:	1023883a 	mov	r17,r2
 8207c68:	04400a0e 	bge	zero,r17,8207c94 <___vfprintf_internal_r+0x1258>
 8207c6c:	d8801f17 	ldw	r2,124(sp)
 8207c70:	1c47883a 	add	r3,r3,r17
 8207c74:	44000015 	stw	r16,0(r8)
 8207c78:	10800044 	addi	r2,r2,1
 8207c7c:	44400115 	stw	r17,4(r8)
 8207c80:	d8c02015 	stw	r3,128(sp)
 8207c84:	d8801f15 	stw	r2,124(sp)
 8207c88:	010001c4 	movi	r4,7
 8207c8c:	20826516 	blt	r4,r2,8208624 <___vfprintf_internal_r+0x1be8>
 8207c90:	42000204 	addi	r8,r8,8
 8207c94:	88026116 	blt	r17,zero,820861c <___vfprintf_internal_r+0x1be0>
 8207c98:	d9003217 	ldw	r4,200(sp)
 8207c9c:	2463c83a 	sub	r17,r4,r17
 8207ca0:	04407b0e 	bge	zero,r17,8207e90 <___vfprintf_internal_r+0x1454>
 8207ca4:	05800404 	movi	r22,16
 8207ca8:	d8801f17 	ldw	r2,124(sp)
 8207cac:	b4419d0e 	bge	r22,r17,8208324 <___vfprintf_internal_r+0x18e8>
 8207cb0:	01020974 	movhi	r4,2085
 8207cb4:	2136d284 	addi	r4,r4,-9398
 8207cb8:	d9002b15 	stw	r4,172(sp)
 8207cbc:	070001c4 	movi	fp,7
 8207cc0:	dcc02c17 	ldw	r19,176(sp)
 8207cc4:	00000306 	br	8207cd4 <___vfprintf_internal_r+0x1298>
 8207cc8:	42000204 	addi	r8,r8,8
 8207ccc:	8c7ffc04 	addi	r17,r17,-16
 8207cd0:	b441970e 	bge	r22,r17,8208330 <___vfprintf_internal_r+0x18f4>
 8207cd4:	18c00404 	addi	r3,r3,16
 8207cd8:	10800044 	addi	r2,r2,1
 8207cdc:	45000015 	stw	r20,0(r8)
 8207ce0:	45800115 	stw	r22,4(r8)
 8207ce4:	d8c02015 	stw	r3,128(sp)
 8207ce8:	d8801f15 	stw	r2,124(sp)
 8207cec:	e0bff60e 	bge	fp,r2,8207cc8 <___vfprintf_internal_r+0x128c>
 8207cf0:	d9801e04 	addi	r6,sp,120
 8207cf4:	b80b883a 	mov	r5,r23
 8207cf8:	9809883a 	mov	r4,r19
 8207cfc:	820f5900 	call	820f590 <__sprint_r>
 8207d00:	103c501e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 8207d04:	d8c02017 	ldw	r3,128(sp)
 8207d08:	d8801f17 	ldw	r2,124(sp)
 8207d0c:	da000404 	addi	r8,sp,16
 8207d10:	003fee06 	br	8207ccc <___vfprintf_internal_r+0x1290>
 8207d14:	d9002c17 	ldw	r4,176(sp)
 8207d18:	d9801e04 	addi	r6,sp,120
 8207d1c:	b80b883a 	mov	r5,r23
 8207d20:	820f5900 	call	820f590 <__sprint_r>
 8207d24:	103c471e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 8207d28:	d8c02017 	ldw	r3,128(sp)
 8207d2c:	df002787 	ldb	fp,158(sp)
 8207d30:	da000404 	addi	r8,sp,16
 8207d34:	003d5606 	br	8207290 <___vfprintf_internal_r+0x854>
 8207d38:	9080040c 	andi	r2,r18,16
 8207d3c:	10016126 	beq	r2,zero,82082c4 <___vfprintf_internal_r+0x1888>
 8207d40:	d8802d17 	ldw	r2,180(sp)
 8207d44:	14c00017 	ldw	r19,0(r2)
 8207d48:	10800104 	addi	r2,r2,4
 8207d4c:	d8802d15 	stw	r2,180(sp)
 8207d50:	982dd7fa 	srai	r22,r19,31
 8207d54:	b005883a 	mov	r2,r22
 8207d58:	003c8206 	br	8206f64 <___vfprintf_internal_r+0x528>
 8207d5c:	9080040c 	andi	r2,r18,16
 8207d60:	10003526 	beq	r2,zero,8207e38 <___vfprintf_internal_r+0x13fc>
 8207d64:	d9402d17 	ldw	r5,180(sp)
 8207d68:	d8c02917 	ldw	r3,164(sp)
 8207d6c:	d8002785 	stb	zero,158(sp)
 8207d70:	28800104 	addi	r2,r5,4
 8207d74:	2cc00017 	ldw	r19,0(r5)
 8207d78:	002d883a 	mov	r22,zero
 8207d7c:	18003716 	blt	r3,zero,8207e5c <___vfprintf_internal_r+0x1420>
 8207d80:	00ffdfc4 	movi	r3,-129
 8207d84:	d8802d15 	stw	r2,180(sp)
 8207d88:	90e4703a 	and	r18,r18,r3
 8207d8c:	0039883a 	mov	fp,zero
 8207d90:	983df326 	beq	r19,zero,8207560 <___vfprintf_internal_r+0xb24>
 8207d94:	00800244 	movi	r2,9
 8207d98:	14fc7b36 	bltu	r2,r19,8206f88 <___vfprintf_internal_r+0x54c>
 8207d9c:	d8c02817 	ldw	r3,160(sp)
 8207da0:	dc001dc4 	addi	r16,sp,119
 8207da4:	9cc00c04 	addi	r19,r19,48
 8207da8:	1c07c83a 	sub	r3,r3,r16
 8207dac:	dcc01dc5 	stb	r19,119(sp)
 8207db0:	d8c02e15 	stw	r3,184(sp)
 8207db4:	003ce806 	br	8207158 <___vfprintf_internal_r+0x71c>
 8207db8:	d8803317 	ldw	r2,204(sp)
 8207dbc:	143fffc4 	addi	r16,r2,-1
 8207dc0:	043f4d0e 	bge	zero,r16,8207af8 <___vfprintf_internal_r+0x10bc>
 8207dc4:	07000404 	movi	fp,16
 8207dc8:	e400810e 	bge	fp,r16,8207fd0 <___vfprintf_internal_r+0x1594>
 8207dcc:	01420974 	movhi	r5,2085
 8207dd0:	2976d284 	addi	r5,r5,-9398
 8207dd4:	d9402b15 	stw	r5,172(sp)
 8207dd8:	01c001c4 	movi	r7,7
 8207ddc:	dcc02c17 	ldw	r19,176(sp)
 8207de0:	00000306 	br	8207df0 <___vfprintf_internal_r+0x13b4>
 8207de4:	b5800204 	addi	r22,r22,8
 8207de8:	843ffc04 	addi	r16,r16,-16
 8207dec:	e4007b0e 	bge	fp,r16,8207fdc <___vfprintf_internal_r+0x15a0>
 8207df0:	18c00404 	addi	r3,r3,16
 8207df4:	8c400044 	addi	r17,r17,1
 8207df8:	b5000015 	stw	r20,0(r22)
 8207dfc:	b7000115 	stw	fp,4(r22)
 8207e00:	d8c02015 	stw	r3,128(sp)
 8207e04:	dc401f15 	stw	r17,124(sp)
 8207e08:	3c7ff60e 	bge	r7,r17,8207de4 <___vfprintf_internal_r+0x13a8>
 8207e0c:	d9801e04 	addi	r6,sp,120
 8207e10:	b80b883a 	mov	r5,r23
 8207e14:	9809883a 	mov	r4,r19
 8207e18:	d9c03c15 	stw	r7,240(sp)
 8207e1c:	820f5900 	call	820f590 <__sprint_r>
 8207e20:	d9c03c17 	ldw	r7,240(sp)
 8207e24:	103c071e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 8207e28:	d8c02017 	ldw	r3,128(sp)
 8207e2c:	dc401f17 	ldw	r17,124(sp)
 8207e30:	dd800404 	addi	r22,sp,16
 8207e34:	003fec06 	br	8207de8 <___vfprintf_internal_r+0x13ac>
 8207e38:	9080100c 	andi	r2,r18,64
 8207e3c:	d8002785 	stb	zero,158(sp)
 8207e40:	10010e26 	beq	r2,zero,820827c <___vfprintf_internal_r+0x1840>
 8207e44:	d9002d17 	ldw	r4,180(sp)
 8207e48:	d9402917 	ldw	r5,164(sp)
 8207e4c:	002d883a 	mov	r22,zero
 8207e50:	20800104 	addi	r2,r4,4
 8207e54:	24c0000b 	ldhu	r19,0(r4)
 8207e58:	283fc90e 	bge	r5,zero,8207d80 <___vfprintf_internal_r+0x1344>
 8207e5c:	d8802d15 	stw	r2,180(sp)
 8207e60:	0039883a 	mov	fp,zero
 8207e64:	9d84b03a 	or	r2,r19,r22
 8207e68:	103c461e 	bne	r2,zero,8206f84 <___vfprintf_internal_r+0x548>
 8207e6c:	00800044 	movi	r2,1
 8207e70:	003e6c06 	br	8207824 <___vfprintf_internal_r+0xde8>
 8207e74:	d9002c17 	ldw	r4,176(sp)
 8207e78:	d9801e04 	addi	r6,sp,120
 8207e7c:	b80b883a 	mov	r5,r23
 8207e80:	820f5900 	call	820f590 <__sprint_r>
 8207e84:	103bef1e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 8207e88:	d8c02017 	ldw	r3,128(sp)
 8207e8c:	da000404 	addi	r8,sp,16
 8207e90:	d9003217 	ldw	r4,200(sp)
 8207e94:	d8802617 	ldw	r2,152(sp)
 8207e98:	d9403317 	ldw	r5,204(sp)
 8207e9c:	8123883a 	add	r17,r16,r4
 8207ea0:	11400216 	blt	r2,r5,8207eac <___vfprintf_internal_r+0x1470>
 8207ea4:	9100004c 	andi	r4,r18,1
 8207ea8:	20000d26 	beq	r4,zero,8207ee0 <___vfprintf_internal_r+0x14a4>
 8207eac:	d9003717 	ldw	r4,220(sp)
 8207eb0:	d9403417 	ldw	r5,208(sp)
 8207eb4:	1907883a 	add	r3,r3,r4
 8207eb8:	d9001f17 	ldw	r4,124(sp)
 8207ebc:	41400015 	stw	r5,0(r8)
 8207ec0:	d9403717 	ldw	r5,220(sp)
 8207ec4:	21000044 	addi	r4,r4,1
 8207ec8:	d8c02015 	stw	r3,128(sp)
 8207ecc:	41400115 	stw	r5,4(r8)
 8207ed0:	d9001f15 	stw	r4,124(sp)
 8207ed4:	014001c4 	movi	r5,7
 8207ed8:	2901e816 	blt	r5,r4,820867c <___vfprintf_internal_r+0x1c40>
 8207edc:	42000204 	addi	r8,r8,8
 8207ee0:	d9003317 	ldw	r4,204(sp)
 8207ee4:	8121883a 	add	r16,r16,r4
 8207ee8:	2085c83a 	sub	r2,r4,r2
 8207eec:	8461c83a 	sub	r16,r16,r17
 8207ef0:	1400010e 	bge	r2,r16,8207ef8 <___vfprintf_internal_r+0x14bc>
 8207ef4:	1021883a 	mov	r16,r2
 8207ef8:	04000a0e 	bge	zero,r16,8207f24 <___vfprintf_internal_r+0x14e8>
 8207efc:	d9001f17 	ldw	r4,124(sp)
 8207f00:	1c07883a 	add	r3,r3,r16
 8207f04:	44400015 	stw	r17,0(r8)
 8207f08:	21000044 	addi	r4,r4,1
 8207f0c:	44000115 	stw	r16,4(r8)
 8207f10:	d8c02015 	stw	r3,128(sp)
 8207f14:	d9001f15 	stw	r4,124(sp)
 8207f18:	014001c4 	movi	r5,7
 8207f1c:	2901fb16 	blt	r5,r4,820870c <___vfprintf_internal_r+0x1cd0>
 8207f20:	42000204 	addi	r8,r8,8
 8207f24:	8001f716 	blt	r16,zero,8208704 <___vfprintf_internal_r+0x1cc8>
 8207f28:	1421c83a 	sub	r16,r2,r16
 8207f2c:	043d380e 	bge	zero,r16,8207410 <___vfprintf_internal_r+0x9d4>
 8207f30:	04400404 	movi	r17,16
 8207f34:	d8801f17 	ldw	r2,124(sp)
 8207f38:	8c3efb0e 	bge	r17,r16,8207b28 <___vfprintf_internal_r+0x10ec>
 8207f3c:	01420974 	movhi	r5,2085
 8207f40:	2976d284 	addi	r5,r5,-9398
 8207f44:	d9402b15 	stw	r5,172(sp)
 8207f48:	058001c4 	movi	r22,7
 8207f4c:	dcc02c17 	ldw	r19,176(sp)
 8207f50:	00000306 	br	8207f60 <___vfprintf_internal_r+0x1524>
 8207f54:	42000204 	addi	r8,r8,8
 8207f58:	843ffc04 	addi	r16,r16,-16
 8207f5c:	8c3ef50e 	bge	r17,r16,8207b34 <___vfprintf_internal_r+0x10f8>
 8207f60:	18c00404 	addi	r3,r3,16
 8207f64:	10800044 	addi	r2,r2,1
 8207f68:	45000015 	stw	r20,0(r8)
 8207f6c:	44400115 	stw	r17,4(r8)
 8207f70:	d8c02015 	stw	r3,128(sp)
 8207f74:	d8801f15 	stw	r2,124(sp)
 8207f78:	b0bff60e 	bge	r22,r2,8207f54 <___vfprintf_internal_r+0x1518>
 8207f7c:	d9801e04 	addi	r6,sp,120
 8207f80:	b80b883a 	mov	r5,r23
 8207f84:	9809883a 	mov	r4,r19
 8207f88:	820f5900 	call	820f590 <__sprint_r>
 8207f8c:	103bad1e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 8207f90:	d8c02017 	ldw	r3,128(sp)
 8207f94:	d8801f17 	ldw	r2,124(sp)
 8207f98:	da000404 	addi	r8,sp,16
 8207f9c:	003fee06 	br	8207f58 <___vfprintf_internal_r+0x151c>
 8207fa0:	9088703a 	and	r4,r18,r2
 8207fa4:	203eab1e 	bne	r4,zero,8207a54 <___vfprintf_internal_r+0x1018>
 8207fa8:	dc401f17 	ldw	r17,124(sp)
 8207fac:	40800115 	stw	r2,4(r8)
 8207fb0:	44000015 	stw	r16,0(r8)
 8207fb4:	8c400044 	addi	r17,r17,1
 8207fb8:	d8c02015 	stw	r3,128(sp)
 8207fbc:	dc401f15 	stw	r17,124(sp)
 8207fc0:	008001c4 	movi	r2,7
 8207fc4:	14400e16 	blt	r2,r17,8208000 <___vfprintf_internal_r+0x15c4>
 8207fc8:	45800204 	addi	r22,r8,8
 8207fcc:	003eca06 	br	8207af8 <___vfprintf_internal_r+0x10bc>
 8207fd0:	01020974 	movhi	r4,2085
 8207fd4:	2136d284 	addi	r4,r4,-9398
 8207fd8:	d9002b15 	stw	r4,172(sp)
 8207fdc:	d8802b17 	ldw	r2,172(sp)
 8207fe0:	1c07883a 	add	r3,r3,r16
 8207fe4:	8c400044 	addi	r17,r17,1
 8207fe8:	b0800015 	stw	r2,0(r22)
 8207fec:	b4000115 	stw	r16,4(r22)
 8207ff0:	d8c02015 	stw	r3,128(sp)
 8207ff4:	dc401f15 	stw	r17,124(sp)
 8207ff8:	008001c4 	movi	r2,7
 8207ffc:	147ebd0e 	bge	r2,r17,8207af4 <___vfprintf_internal_r+0x10b8>
 8208000:	d9002c17 	ldw	r4,176(sp)
 8208004:	d9801e04 	addi	r6,sp,120
 8208008:	b80b883a 	mov	r5,r23
 820800c:	820f5900 	call	820f590 <__sprint_r>
 8208010:	103b8c1e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 8208014:	d8c02017 	ldw	r3,128(sp)
 8208018:	dc401f17 	ldw	r17,124(sp)
 820801c:	dd800404 	addi	r22,sp,16
 8208020:	003eb506 	br	8207af8 <___vfprintf_internal_r+0x10bc>
 8208024:	d9002c17 	ldw	r4,176(sp)
 8208028:	d9801e04 	addi	r6,sp,120
 820802c:	b80b883a 	mov	r5,r23
 8208030:	820f5900 	call	820f590 <__sprint_r>
 8208034:	103b831e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 8208038:	d8c02017 	ldw	r3,128(sp)
 820803c:	dc401f17 	ldw	r17,124(sp)
 8208040:	da000404 	addi	r8,sp,16
 8208044:	003e8d06 	br	8207a7c <___vfprintf_internal_r+0x1040>
 8208048:	d9002c17 	ldw	r4,176(sp)
 820804c:	d9801e04 	addi	r6,sp,120
 8208050:	b80b883a 	mov	r5,r23
 8208054:	820f5900 	call	820f590 <__sprint_r>
 8208058:	103b7a1e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 820805c:	d8c02017 	ldw	r3,128(sp)
 8208060:	dc401f17 	ldw	r17,124(sp)
 8208064:	dd800404 	addi	r22,sp,16
 8208068:	003e8f06 	br	8207aa8 <___vfprintf_internal_r+0x106c>
 820806c:	0027883a 	mov	r19,zero
 8208070:	003f4a06 	br	8207d9c <___vfprintf_internal_r+0x1360>
 8208074:	d9002c17 	ldw	r4,176(sp)
 8208078:	d9801e04 	addi	r6,sp,120
 820807c:	b80b883a 	mov	r5,r23
 8208080:	820f5900 	call	820f590 <__sprint_r>
 8208084:	103b6f1e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 8208088:	d8c02017 	ldw	r3,128(sp)
 820808c:	da000404 	addi	r8,sp,16
 8208090:	003c9d06 	br	8207308 <___vfprintf_internal_r+0x8cc>
 8208094:	04e7c83a 	sub	r19,zero,r19
 8208098:	9804c03a 	cmpne	r2,r19,zero
 820809c:	05adc83a 	sub	r22,zero,r22
 82080a0:	b0adc83a 	sub	r22,r22,r2
 82080a4:	d8802917 	ldw	r2,164(sp)
 82080a8:	07000b44 	movi	fp,45
 82080ac:	df002785 	stb	fp,158(sp)
 82080b0:	10017b16 	blt	r2,zero,82086a0 <___vfprintf_internal_r+0x1c64>
 82080b4:	00bfdfc4 	movi	r2,-129
 82080b8:	90a4703a 	and	r18,r18,r2
 82080bc:	003bb106 	br	8206f84 <___vfprintf_internal_r+0x548>
 82080c0:	d9003617 	ldw	r4,216(sp)
 82080c4:	d9403817 	ldw	r5,224(sp)
 82080c8:	da003d15 	stw	r8,244(sp)
 82080cc:	820dda80 	call	820dda8 <__fpclassifyd>
 82080d0:	da003d17 	ldw	r8,244(sp)
 82080d4:	1000f026 	beq	r2,zero,8208498 <___vfprintf_internal_r+0x1a5c>
 82080d8:	d9002917 	ldw	r4,164(sp)
 82080dc:	05bff7c4 	movi	r22,-33
 82080e0:	00bfffc4 	movi	r2,-1
 82080e4:	8dac703a 	and	r22,r17,r22
 82080e8:	20820026 	beq	r4,r2,82088ec <___vfprintf_internal_r+0x1eb0>
 82080ec:	008011c4 	movi	r2,71
 82080f0:	b081f726 	beq	r22,r2,82088d0 <___vfprintf_internal_r+0x1e94>
 82080f4:	d9003817 	ldw	r4,224(sp)
 82080f8:	90c04014 	ori	r3,r18,256
 82080fc:	d8c02b15 	stw	r3,172(sp)
 8208100:	20021516 	blt	r4,zero,8208958 <___vfprintf_internal_r+0x1f1c>
 8208104:	dcc03817 	ldw	r19,224(sp)
 8208108:	d8002a05 	stb	zero,168(sp)
 820810c:	00801984 	movi	r2,102
 8208110:	8881f926 	beq	r17,r2,82088f8 <___vfprintf_internal_r+0x1ebc>
 8208114:	00801184 	movi	r2,70
 8208118:	88821c26 	beq	r17,r2,820898c <___vfprintf_internal_r+0x1f50>
 820811c:	00801144 	movi	r2,69
 8208120:	b081ef26 	beq	r22,r2,82088e0 <___vfprintf_internal_r+0x1ea4>
 8208124:	d8c02917 	ldw	r3,164(sp)
 8208128:	d8802104 	addi	r2,sp,132
 820812c:	d8800315 	stw	r2,12(sp)
 8208130:	d9403617 	ldw	r5,216(sp)
 8208134:	d8802504 	addi	r2,sp,148
 8208138:	d9002c17 	ldw	r4,176(sp)
 820813c:	d8800215 	stw	r2,8(sp)
 8208140:	d8802604 	addi	r2,sp,152
 8208144:	d8c00015 	stw	r3,0(sp)
 8208148:	d8800115 	stw	r2,4(sp)
 820814c:	01c00084 	movi	r7,2
 8208150:	980d883a 	mov	r6,r19
 8208154:	d8c03c15 	stw	r3,240(sp)
 8208158:	da003d15 	stw	r8,244(sp)
 820815c:	82091b80 	call	82091b8 <_dtoa_r>
 8208160:	1021883a 	mov	r16,r2
 8208164:	008019c4 	movi	r2,103
 8208168:	d8c03c17 	ldw	r3,240(sp)
 820816c:	da003d17 	ldw	r8,244(sp)
 8208170:	88817126 	beq	r17,r2,8208738 <___vfprintf_internal_r+0x1cfc>
 8208174:	008011c4 	movi	r2,71
 8208178:	88829226 	beq	r17,r2,8208bc4 <___vfprintf_internal_r+0x2188>
 820817c:	80f9883a 	add	fp,r16,r3
 8208180:	d9003617 	ldw	r4,216(sp)
 8208184:	000d883a 	mov	r6,zero
 8208188:	000f883a 	mov	r7,zero
 820818c:	980b883a 	mov	r5,r19
 8208190:	da003d15 	stw	r8,244(sp)
 8208194:	8212efc0 	call	8212efc <__eqdf2>
 8208198:	da003d17 	ldw	r8,244(sp)
 820819c:	10018d26 	beq	r2,zero,82087d4 <___vfprintf_internal_r+0x1d98>
 82081a0:	d8802117 	ldw	r2,132(sp)
 82081a4:	1700062e 	bgeu	r2,fp,82081c0 <___vfprintf_internal_r+0x1784>
 82081a8:	01000c04 	movi	r4,48
 82081ac:	10c00044 	addi	r3,r2,1
 82081b0:	d8c02115 	stw	r3,132(sp)
 82081b4:	11000005 	stb	r4,0(r2)
 82081b8:	d8802117 	ldw	r2,132(sp)
 82081bc:	173ffb36 	bltu	r2,fp,82081ac <___vfprintf_internal_r+0x1770>
 82081c0:	1405c83a 	sub	r2,r2,r16
 82081c4:	d8803315 	stw	r2,204(sp)
 82081c8:	008011c4 	movi	r2,71
 82081cc:	b0817626 	beq	r22,r2,82087a8 <___vfprintf_internal_r+0x1d6c>
 82081d0:	00801944 	movi	r2,101
 82081d4:	1442810e 	bge	r2,r17,8208bdc <___vfprintf_internal_r+0x21a0>
 82081d8:	d8c02617 	ldw	r3,152(sp)
 82081dc:	00801984 	movi	r2,102
 82081e0:	d8c03215 	stw	r3,200(sp)
 82081e4:	8881fe26 	beq	r17,r2,82089e0 <___vfprintf_internal_r+0x1fa4>
 82081e8:	d8c03217 	ldw	r3,200(sp)
 82081ec:	d9003317 	ldw	r4,204(sp)
 82081f0:	1901dd16 	blt	r3,r4,8208968 <___vfprintf_internal_r+0x1f2c>
 82081f4:	9480004c 	andi	r18,r18,1
 82081f8:	90022b1e 	bne	r18,zero,8208aa8 <___vfprintf_internal_r+0x206c>
 82081fc:	1805883a 	mov	r2,r3
 8208200:	18028016 	blt	r3,zero,8208c04 <___vfprintf_internal_r+0x21c8>
 8208204:	d8c03217 	ldw	r3,200(sp)
 8208208:	044019c4 	movi	r17,103
 820820c:	d8c02e15 	stw	r3,184(sp)
 8208210:	df002a07 	ldb	fp,168(sp)
 8208214:	e001531e 	bne	fp,zero,8208764 <___vfprintf_internal_r+0x1d28>
 8208218:	df002783 	ldbu	fp,158(sp)
 820821c:	d8802a15 	stw	r2,168(sp)
 8208220:	dc802b17 	ldw	r18,172(sp)
 8208224:	d8002915 	stw	zero,164(sp)
 8208228:	003bd106 	br	8207170 <___vfprintf_internal_r+0x734>
 820822c:	d8802d17 	ldw	r2,180(sp)
 8208230:	d8c02d17 	ldw	r3,180(sp)
 8208234:	d9002d17 	ldw	r4,180(sp)
 8208238:	10800017 	ldw	r2,0(r2)
 820823c:	18c00117 	ldw	r3,4(r3)
 8208240:	21000204 	addi	r4,r4,8
 8208244:	d8803615 	stw	r2,216(sp)
 8208248:	d8c03815 	stw	r3,224(sp)
 820824c:	d9002d15 	stw	r4,180(sp)
 8208250:	003b7506 	br	8207028 <___vfprintf_internal_r+0x5ec>
 8208254:	ac400007 	ldb	r17,0(r21)
 8208258:	003a5906 	br	8206bc0 <___vfprintf_internal_r+0x184>
 820825c:	9080100c 	andi	r2,r18,64
 8208260:	1000a826 	beq	r2,zero,8208504 <___vfprintf_internal_r+0x1ac8>
 8208264:	d9002d17 	ldw	r4,180(sp)
 8208268:	002d883a 	mov	r22,zero
 820826c:	24c0000b 	ldhu	r19,0(r4)
 8208270:	21000104 	addi	r4,r4,4
 8208274:	d9002d15 	stw	r4,180(sp)
 8208278:	003ccb06 	br	82075a8 <___vfprintf_internal_r+0xb6c>
 820827c:	d8c02d17 	ldw	r3,180(sp)
 8208280:	d9002917 	ldw	r4,164(sp)
 8208284:	002d883a 	mov	r22,zero
 8208288:	18800104 	addi	r2,r3,4
 820828c:	1cc00017 	ldw	r19,0(r3)
 8208290:	203ebb0e 	bge	r4,zero,8207d80 <___vfprintf_internal_r+0x1344>
 8208294:	003ef106 	br	8207e5c <___vfprintf_internal_r+0x1420>
 8208298:	9080040c 	andi	r2,r18,16
 820829c:	1000921e 	bne	r2,zero,82084e8 <___vfprintf_internal_r+0x1aac>
 82082a0:	9480100c 	andi	r18,r18,64
 82082a4:	90013926 	beq	r18,zero,820878c <___vfprintf_internal_r+0x1d50>
 82082a8:	d9002d17 	ldw	r4,180(sp)
 82082ac:	d9402f17 	ldw	r5,188(sp)
 82082b0:	20800017 	ldw	r2,0(r4)
 82082b4:	21000104 	addi	r4,r4,4
 82082b8:	d9002d15 	stw	r4,180(sp)
 82082bc:	1140000d 	sth	r5,0(r2)
 82082c0:	003a1606 	br	8206b1c <___vfprintf_internal_r+0xe0>
 82082c4:	9080100c 	andi	r2,r18,64
 82082c8:	10008026 	beq	r2,zero,82084cc <___vfprintf_internal_r+0x1a90>
 82082cc:	d8c02d17 	ldw	r3,180(sp)
 82082d0:	1cc0000f 	ldh	r19,0(r3)
 82082d4:	18c00104 	addi	r3,r3,4
 82082d8:	d8c02d15 	stw	r3,180(sp)
 82082dc:	982dd7fa 	srai	r22,r19,31
 82082e0:	b005883a 	mov	r2,r22
 82082e4:	003b1f06 	br	8206f64 <___vfprintf_internal_r+0x528>
 82082e8:	9080100c 	andi	r2,r18,64
 82082ec:	d8002785 	stb	zero,158(sp)
 82082f0:	10008a1e 	bne	r2,zero,820851c <___vfprintf_internal_r+0x1ae0>
 82082f4:	d9402d17 	ldw	r5,180(sp)
 82082f8:	d8c02917 	ldw	r3,164(sp)
 82082fc:	002d883a 	mov	r22,zero
 8208300:	28800104 	addi	r2,r5,4
 8208304:	2cc00017 	ldw	r19,0(r5)
 8208308:	183e4b0e 	bge	r3,zero,8207c38 <___vfprintf_internal_r+0x11fc>
 820830c:	9d86b03a 	or	r3,r19,r22
 8208310:	d8802d15 	stw	r2,180(sp)
 8208314:	183e4c1e 	bne	r3,zero,8207c48 <___vfprintf_internal_r+0x120c>
 8208318:	0039883a 	mov	fp,zero
 820831c:	0005883a 	mov	r2,zero
 8208320:	003d4006 	br	8207824 <___vfprintf_internal_r+0xde8>
 8208324:	01420974 	movhi	r5,2085
 8208328:	2976d284 	addi	r5,r5,-9398
 820832c:	d9402b15 	stw	r5,172(sp)
 8208330:	d9402b17 	ldw	r5,172(sp)
 8208334:	1c47883a 	add	r3,r3,r17
 8208338:	10800044 	addi	r2,r2,1
 820833c:	41400015 	stw	r5,0(r8)
 8208340:	44400115 	stw	r17,4(r8)
 8208344:	d8c02015 	stw	r3,128(sp)
 8208348:	d8801f15 	stw	r2,124(sp)
 820834c:	010001c4 	movi	r4,7
 8208350:	20bec816 	blt	r4,r2,8207e74 <___vfprintf_internal_r+0x1438>
 8208354:	42000204 	addi	r8,r8,8
 8208358:	003ecd06 	br	8207e90 <___vfprintf_internal_r+0x1454>
 820835c:	d9002917 	ldw	r4,164(sp)
 8208360:	d8002785 	stb	zero,158(sp)
 8208364:	203d2d16 	blt	r4,zero,820781c <___vfprintf_internal_r+0xde0>
 8208368:	00bfdfc4 	movi	r2,-129
 820836c:	90a4703a 	and	r18,r18,r2
 8208370:	003a9106 	br	8206db8 <___vfprintf_internal_r+0x37c>
 8208374:	01020974 	movhi	r4,2085
 8208378:	2136d284 	addi	r4,r4,-9398
 820837c:	d9002b15 	stw	r4,172(sp)
 8208380:	003c0c06 	br	82073b4 <___vfprintf_internal_r+0x978>
 8208384:	d9002c17 	ldw	r4,176(sp)
 8208388:	d9801e04 	addi	r6,sp,120
 820838c:	b80b883a 	mov	r5,r23
 8208390:	820f5900 	call	820f590 <__sprint_r>
 8208394:	103aab1e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 8208398:	d8c02017 	ldw	r3,128(sp)
 820839c:	da000404 	addi	r8,sp,16
 82083a0:	003d4106 	br	82078a8 <___vfprintf_internal_r+0xe6c>
 82083a4:	d8801f17 	ldw	r2,124(sp)
 82083a8:	01420974 	movhi	r5,2085
 82083ac:	01000044 	movi	r4,1
 82083b0:	18c00044 	addi	r3,r3,1
 82083b4:	10800044 	addi	r2,r2,1
 82083b8:	2976ca04 	addi	r5,r5,-9432
 82083bc:	41000115 	stw	r4,4(r8)
 82083c0:	41400015 	stw	r5,0(r8)
 82083c4:	d8c02015 	stw	r3,128(sp)
 82083c8:	d8801f15 	stw	r2,124(sp)
 82083cc:	010001c4 	movi	r4,7
 82083d0:	20805c16 	blt	r4,r2,8208544 <___vfprintf_internal_r+0x1b08>
 82083d4:	42000204 	addi	r8,r8,8
 82083d8:	8800041e 	bne	r17,zero,82083ec <___vfprintf_internal_r+0x19b0>
 82083dc:	d8803317 	ldw	r2,204(sp)
 82083e0:	1000021e 	bne	r2,zero,82083ec <___vfprintf_internal_r+0x19b0>
 82083e4:	9080004c 	andi	r2,r18,1
 82083e8:	103c0926 	beq	r2,zero,8207410 <___vfprintf_internal_r+0x9d4>
 82083ec:	d9003717 	ldw	r4,220(sp)
 82083f0:	d8801f17 	ldw	r2,124(sp)
 82083f4:	d9403417 	ldw	r5,208(sp)
 82083f8:	20c7883a 	add	r3,r4,r3
 82083fc:	10800044 	addi	r2,r2,1
 8208400:	41000115 	stw	r4,4(r8)
 8208404:	41400015 	stw	r5,0(r8)
 8208408:	d8c02015 	stw	r3,128(sp)
 820840c:	d8801f15 	stw	r2,124(sp)
 8208410:	010001c4 	movi	r4,7
 8208414:	20812116 	blt	r4,r2,820889c <___vfprintf_internal_r+0x1e60>
 8208418:	42000204 	addi	r8,r8,8
 820841c:	0463c83a 	sub	r17,zero,r17
 8208420:	0440730e 	bge	zero,r17,82085f0 <___vfprintf_internal_r+0x1bb4>
 8208424:	05800404 	movi	r22,16
 8208428:	b440860e 	bge	r22,r17,8208644 <___vfprintf_internal_r+0x1c08>
 820842c:	01420974 	movhi	r5,2085
 8208430:	2976d284 	addi	r5,r5,-9398
 8208434:	d9402b15 	stw	r5,172(sp)
 8208438:	070001c4 	movi	fp,7
 820843c:	dcc02c17 	ldw	r19,176(sp)
 8208440:	00000306 	br	8208450 <___vfprintf_internal_r+0x1a14>
 8208444:	42000204 	addi	r8,r8,8
 8208448:	8c7ffc04 	addi	r17,r17,-16
 820844c:	b440800e 	bge	r22,r17,8208650 <___vfprintf_internal_r+0x1c14>
 8208450:	18c00404 	addi	r3,r3,16
 8208454:	10800044 	addi	r2,r2,1
 8208458:	45000015 	stw	r20,0(r8)
 820845c:	45800115 	stw	r22,4(r8)
 8208460:	d8c02015 	stw	r3,128(sp)
 8208464:	d8801f15 	stw	r2,124(sp)
 8208468:	e0bff60e 	bge	fp,r2,8208444 <___vfprintf_internal_r+0x1a08>
 820846c:	d9801e04 	addi	r6,sp,120
 8208470:	b80b883a 	mov	r5,r23
 8208474:	9809883a 	mov	r4,r19
 8208478:	820f5900 	call	820f590 <__sprint_r>
 820847c:	103a711e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 8208480:	d8c02017 	ldw	r3,128(sp)
 8208484:	d8801f17 	ldw	r2,124(sp)
 8208488:	da000404 	addi	r8,sp,16
 820848c:	003fee06 	br	8208448 <___vfprintf_internal_r+0x1a0c>
 8208490:	00bfffc4 	movi	r2,-1
 8208494:	003a6f06 	br	8206e54 <___vfprintf_internal_r+0x418>
 8208498:	008011c4 	movi	r2,71
 820849c:	1440b816 	blt	r2,r17,8208780 <___vfprintf_internal_r+0x1d44>
 82084a0:	04020974 	movhi	r16,2085
 82084a4:	8436bc04 	addi	r16,r16,-9488
 82084a8:	00c000c4 	movi	r3,3
 82084ac:	00bfdfc4 	movi	r2,-129
 82084b0:	d8c02a15 	stw	r3,168(sp)
 82084b4:	90a4703a 	and	r18,r18,r2
 82084b8:	df002783 	ldbu	fp,158(sp)
 82084bc:	d8c02e15 	stw	r3,184(sp)
 82084c0:	d8002915 	stw	zero,164(sp)
 82084c4:	d8003215 	stw	zero,200(sp)
 82084c8:	003b2906 	br	8207170 <___vfprintf_internal_r+0x734>
 82084cc:	d9002d17 	ldw	r4,180(sp)
 82084d0:	24c00017 	ldw	r19,0(r4)
 82084d4:	21000104 	addi	r4,r4,4
 82084d8:	d9002d15 	stw	r4,180(sp)
 82084dc:	982dd7fa 	srai	r22,r19,31
 82084e0:	b005883a 	mov	r2,r22
 82084e4:	003a9f06 	br	8206f64 <___vfprintf_internal_r+0x528>
 82084e8:	d9402d17 	ldw	r5,180(sp)
 82084ec:	d8c02f17 	ldw	r3,188(sp)
 82084f0:	28800017 	ldw	r2,0(r5)
 82084f4:	29400104 	addi	r5,r5,4
 82084f8:	d9402d15 	stw	r5,180(sp)
 82084fc:	10c00015 	stw	r3,0(r2)
 8208500:	00398606 	br	8206b1c <___vfprintf_internal_r+0xe0>
 8208504:	d9402d17 	ldw	r5,180(sp)
 8208508:	002d883a 	mov	r22,zero
 820850c:	2cc00017 	ldw	r19,0(r5)
 8208510:	29400104 	addi	r5,r5,4
 8208514:	d9402d15 	stw	r5,180(sp)
 8208518:	003c2306 	br	82075a8 <___vfprintf_internal_r+0xb6c>
 820851c:	d8c02d17 	ldw	r3,180(sp)
 8208520:	d9002917 	ldw	r4,164(sp)
 8208524:	002d883a 	mov	r22,zero
 8208528:	18800104 	addi	r2,r3,4
 820852c:	1cc0000b 	ldhu	r19,0(r3)
 8208530:	203dc10e 	bge	r4,zero,8207c38 <___vfprintf_internal_r+0x11fc>
 8208534:	003f7506 	br	820830c <___vfprintf_internal_r+0x18d0>
 8208538:	04020974 	movhi	r16,2085
 820853c:	8436ba04 	addi	r16,r16,-9496
 8208540:	003acc06 	br	8207074 <___vfprintf_internal_r+0x638>
 8208544:	d9002c17 	ldw	r4,176(sp)
 8208548:	d9801e04 	addi	r6,sp,120
 820854c:	b80b883a 	mov	r5,r23
 8208550:	820f5900 	call	820f590 <__sprint_r>
 8208554:	103a3b1e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 8208558:	dc402617 	ldw	r17,152(sp)
 820855c:	d8c02017 	ldw	r3,128(sp)
 8208560:	da000404 	addi	r8,sp,16
 8208564:	003f9c06 	br	82083d8 <___vfprintf_internal_r+0x199c>
 8208568:	ac400043 	ldbu	r17,1(r21)
 820856c:	94800814 	ori	r18,r18,32
 8208570:	ad400044 	addi	r21,r21,1
 8208574:	8c403fcc 	andi	r17,r17,255
 8208578:	8c40201c 	xori	r17,r17,128
 820857c:	8c7fe004 	addi	r17,r17,-128
 8208580:	00398f06 	br	8206bc0 <___vfprintf_internal_r+0x184>
 8208584:	d8c02d15 	stw	r3,180(sp)
 8208588:	0039883a 	mov	fp,zero
 820858c:	003e3506 	br	8207e64 <___vfprintf_internal_r+0x1428>
 8208590:	d9002c17 	ldw	r4,176(sp)
 8208594:	d9801e04 	addi	r6,sp,120
 8208598:	b80b883a 	mov	r5,r23
 820859c:	820f5900 	call	820f590 <__sprint_r>
 82085a0:	103a281e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 82085a4:	d8c02017 	ldw	r3,128(sp)
 82085a8:	da000404 	addi	r8,sp,16
 82085ac:	003cd006 	br	82078f0 <___vfprintf_internal_r+0xeb4>
 82085b0:	8009883a 	mov	r4,r16
 82085b4:	da003d15 	stw	r8,244(sp)
 82085b8:	8203f600 	call	8203f60 <strlen>
 82085bc:	d8802e15 	stw	r2,184(sp)
 82085c0:	da003d17 	ldw	r8,244(sp)
 82085c4:	103c340e 	bge	r2,zero,8207698 <___vfprintf_internal_r+0xc5c>
 82085c8:	0005883a 	mov	r2,zero
 82085cc:	003c3206 	br	8207698 <___vfprintf_internal_r+0xc5c>
 82085d0:	d9002c17 	ldw	r4,176(sp)
 82085d4:	d9801e04 	addi	r6,sp,120
 82085d8:	b80b883a 	mov	r5,r23
 82085dc:	820f5900 	call	820f590 <__sprint_r>
 82085e0:	103a181e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 82085e4:	d8c02017 	ldw	r3,128(sp)
 82085e8:	d8801f17 	ldw	r2,124(sp)
 82085ec:	da000404 	addi	r8,sp,16
 82085f0:	d9403317 	ldw	r5,204(sp)
 82085f4:	10800044 	addi	r2,r2,1
 82085f8:	44000015 	stw	r16,0(r8)
 82085fc:	28c7883a 	add	r3,r5,r3
 8208600:	003b7d06 	br	82073f8 <___vfprintf_internal_r+0x9bc>
 8208604:	01020974 	movhi	r4,2085
 8208608:	2136d684 	addi	r4,r4,-9382
 820860c:	d9003515 	stw	r4,212(sp)
 8208610:	003b1406 	br	8207264 <___vfprintf_internal_r+0x828>
 8208614:	013fffc4 	movi	r4,-1
 8208618:	003a3506 	br	8206ef0 <___vfprintf_internal_r+0x4b4>
 820861c:	0023883a 	mov	r17,zero
 8208620:	003d9d06 	br	8207c98 <___vfprintf_internal_r+0x125c>
 8208624:	d9002c17 	ldw	r4,176(sp)
 8208628:	d9801e04 	addi	r6,sp,120
 820862c:	b80b883a 	mov	r5,r23
 8208630:	820f5900 	call	820f590 <__sprint_r>
 8208634:	103a031e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 8208638:	d8c02017 	ldw	r3,128(sp)
 820863c:	da000404 	addi	r8,sp,16
 8208640:	003d9406 	br	8207c94 <___vfprintf_internal_r+0x1258>
 8208644:	01020974 	movhi	r4,2085
 8208648:	2136d284 	addi	r4,r4,-9398
 820864c:	d9002b15 	stw	r4,172(sp)
 8208650:	d9002b17 	ldw	r4,172(sp)
 8208654:	1c47883a 	add	r3,r3,r17
 8208658:	10800044 	addi	r2,r2,1
 820865c:	41000015 	stw	r4,0(r8)
 8208660:	44400115 	stw	r17,4(r8)
 8208664:	d8c02015 	stw	r3,128(sp)
 8208668:	d8801f15 	stw	r2,124(sp)
 820866c:	010001c4 	movi	r4,7
 8208670:	20bfd716 	blt	r4,r2,82085d0 <___vfprintf_internal_r+0x1b94>
 8208674:	42000204 	addi	r8,r8,8
 8208678:	003fdd06 	br	82085f0 <___vfprintf_internal_r+0x1bb4>
 820867c:	d9002c17 	ldw	r4,176(sp)
 8208680:	d9801e04 	addi	r6,sp,120
 8208684:	b80b883a 	mov	r5,r23
 8208688:	820f5900 	call	820f590 <__sprint_r>
 820868c:	1039ed1e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 8208690:	d8802617 	ldw	r2,152(sp)
 8208694:	d8c02017 	ldw	r3,128(sp)
 8208698:	da000404 	addi	r8,sp,16
 820869c:	003e1006 	br	8207ee0 <___vfprintf_internal_r+0x14a4>
 82086a0:	00800044 	movi	r2,1
 82086a4:	10803fcc 	andi	r2,r2,255
 82086a8:	00c00044 	movi	r3,1
 82086ac:	10fa3526 	beq	r2,r3,8206f84 <___vfprintf_internal_r+0x548>
 82086b0:	00c00084 	movi	r3,2
 82086b4:	10fbcb26 	beq	r2,r3,82075e4 <___vfprintf_internal_r+0xba8>
 82086b8:	003a8f06 	br	82070f8 <___vfprintf_internal_r+0x6bc>
 82086bc:	01020974 	movhi	r4,2085
 82086c0:	2136d684 	addi	r4,r4,-9382
 82086c4:	d9003515 	stw	r4,212(sp)
 82086c8:	003b7606 	br	82074a4 <___vfprintf_internal_r+0xa68>
 82086cc:	d8802917 	ldw	r2,164(sp)
 82086d0:	00c00184 	movi	r3,6
 82086d4:	1880012e 	bgeu	r3,r2,82086dc <___vfprintf_internal_r+0x1ca0>
 82086d8:	1805883a 	mov	r2,r3
 82086dc:	d8802e15 	stw	r2,184(sp)
 82086e0:	1000ef16 	blt	r2,zero,8208aa0 <___vfprintf_internal_r+0x2064>
 82086e4:	04020974 	movhi	r16,2085
 82086e8:	d8802a15 	stw	r2,168(sp)
 82086ec:	dcc02d15 	stw	r19,180(sp)
 82086f0:	d8002915 	stw	zero,164(sp)
 82086f4:	d8003215 	stw	zero,200(sp)
 82086f8:	8436c804 	addi	r16,r16,-9440
 82086fc:	0039883a 	mov	fp,zero
 8208700:	003aa206 	br	820718c <___vfprintf_internal_r+0x750>
 8208704:	0021883a 	mov	r16,zero
 8208708:	003e0706 	br	8207f28 <___vfprintf_internal_r+0x14ec>
 820870c:	d9002c17 	ldw	r4,176(sp)
 8208710:	d9801e04 	addi	r6,sp,120
 8208714:	b80b883a 	mov	r5,r23
 8208718:	820f5900 	call	820f590 <__sprint_r>
 820871c:	1039c91e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 8208720:	d8802617 	ldw	r2,152(sp)
 8208724:	d9403317 	ldw	r5,204(sp)
 8208728:	d8c02017 	ldw	r3,128(sp)
 820872c:	da000404 	addi	r8,sp,16
 8208730:	2885c83a 	sub	r2,r5,r2
 8208734:	003dfb06 	br	8207f24 <___vfprintf_internal_r+0x14e8>
 8208738:	9080004c 	andi	r2,r18,1
 820873c:	103e8f1e 	bne	r2,zero,820817c <___vfprintf_internal_r+0x1740>
 8208740:	d8802117 	ldw	r2,132(sp)
 8208744:	003e9e06 	br	82081c0 <___vfprintf_internal_r+0x1784>
 8208748:	1025883a 	mov	r18,r2
 820874c:	0039883a 	mov	fp,zero
 8208750:	00800084 	movi	r2,2
 8208754:	003fd306 	br	82086a4 <___vfprintf_internal_r+0x1c68>
 8208758:	07000b44 	movi	fp,45
 820875c:	df002785 	stb	fp,158(sp)
 8208760:	003a4006 	br	8207064 <___vfprintf_internal_r+0x628>
 8208764:	00c00b44 	movi	r3,45
 8208768:	d8c02785 	stb	r3,158(sp)
 820876c:	d8802a15 	stw	r2,168(sp)
 8208770:	dc802b17 	ldw	r18,172(sp)
 8208774:	d8002915 	stw	zero,164(sp)
 8208778:	07000b44 	movi	fp,45
 820877c:	003a8006 	br	8207180 <___vfprintf_internal_r+0x744>
 8208780:	04020974 	movhi	r16,2085
 8208784:	8436bd04 	addi	r16,r16,-9484
 8208788:	003f4706 	br	82084a8 <___vfprintf_internal_r+0x1a6c>
 820878c:	d8c02d17 	ldw	r3,180(sp)
 8208790:	d9002f17 	ldw	r4,188(sp)
 8208794:	18800017 	ldw	r2,0(r3)
 8208798:	18c00104 	addi	r3,r3,4
 820879c:	d8c02d15 	stw	r3,180(sp)
 82087a0:	11000015 	stw	r4,0(r2)
 82087a4:	0038dd06 	br	8206b1c <___vfprintf_internal_r+0xe0>
 82087a8:	dd802617 	ldw	r22,152(sp)
 82087ac:	00bfff44 	movi	r2,-3
 82087b0:	b0801c16 	blt	r22,r2,8208824 <___vfprintf_internal_r+0x1de8>
 82087b4:	d9402917 	ldw	r5,164(sp)
 82087b8:	2d801a16 	blt	r5,r22,8208824 <___vfprintf_internal_r+0x1de8>
 82087bc:	dd803215 	stw	r22,200(sp)
 82087c0:	003e8906 	br	82081e8 <___vfprintf_internal_r+0x17ac>
 82087c4:	01020974 	movhi	r4,2085
 82087c8:	2136d284 	addi	r4,r4,-9398
 82087cc:	d9002b15 	stw	r4,172(sp)
 82087d0:	003c9106 	br	8207a18 <___vfprintf_internal_r+0xfdc>
 82087d4:	e005883a 	mov	r2,fp
 82087d8:	003e7906 	br	82081c0 <___vfprintf_internal_r+0x1784>
 82087dc:	d9402917 	ldw	r5,164(sp)
 82087e0:	df002783 	ldbu	fp,158(sp)
 82087e4:	dcc02d15 	stw	r19,180(sp)
 82087e8:	d9402a15 	stw	r5,168(sp)
 82087ec:	d9402e15 	stw	r5,184(sp)
 82087f0:	d8002915 	stw	zero,164(sp)
 82087f4:	d8003215 	stw	zero,200(sp)
 82087f8:	003a5d06 	br	8207170 <___vfprintf_internal_r+0x734>
 82087fc:	9080004c 	andi	r2,r18,1
 8208800:	0039883a 	mov	fp,zero
 8208804:	10000426 	beq	r2,zero,8208818 <___vfprintf_internal_r+0x1ddc>
 8208808:	00800c04 	movi	r2,48
 820880c:	dc001dc4 	addi	r16,sp,119
 8208810:	d8801dc5 	stb	r2,119(sp)
 8208814:	003b8006 	br	8207618 <___vfprintf_internal_r+0xbdc>
 8208818:	d8002e15 	stw	zero,184(sp)
 820881c:	dc001e04 	addi	r16,sp,120
 8208820:	003a4d06 	br	8207158 <___vfprintf_internal_r+0x71c>
 8208824:	8c7fff84 	addi	r17,r17,-2
 8208828:	b5bfffc4 	addi	r22,r22,-1
 820882c:	dd802615 	stw	r22,152(sp)
 8208830:	dc4022c5 	stb	r17,139(sp)
 8208834:	b000bf16 	blt	r22,zero,8208b34 <___vfprintf_internal_r+0x20f8>
 8208838:	00800ac4 	movi	r2,43
 820883c:	d8802305 	stb	r2,140(sp)
 8208840:	00800244 	movi	r2,9
 8208844:	15807016 	blt	r2,r22,8208a08 <___vfprintf_internal_r+0x1fcc>
 8208848:	00800c04 	movi	r2,48
 820884c:	b5800c04 	addi	r22,r22,48
 8208850:	d8802345 	stb	r2,141(sp)
 8208854:	dd802385 	stb	r22,142(sp)
 8208858:	d88023c4 	addi	r2,sp,143
 820885c:	df0022c4 	addi	fp,sp,139
 8208860:	d8c03317 	ldw	r3,204(sp)
 8208864:	1739c83a 	sub	fp,r2,fp
 8208868:	d9003317 	ldw	r4,204(sp)
 820886c:	e0c7883a 	add	r3,fp,r3
 8208870:	df003a15 	stw	fp,232(sp)
 8208874:	d8c02e15 	stw	r3,184(sp)
 8208878:	00800044 	movi	r2,1
 820887c:	1100b30e 	bge	r2,r4,8208b4c <___vfprintf_internal_r+0x2110>
 8208880:	d8c02e17 	ldw	r3,184(sp)
 8208884:	18c00044 	addi	r3,r3,1
 8208888:	d8c02e15 	stw	r3,184(sp)
 820888c:	1805883a 	mov	r2,r3
 8208890:	1800ac16 	blt	r3,zero,8208b44 <___vfprintf_internal_r+0x2108>
 8208894:	d8003215 	stw	zero,200(sp)
 8208898:	003e5d06 	br	8208210 <___vfprintf_internal_r+0x17d4>
 820889c:	d9002c17 	ldw	r4,176(sp)
 82088a0:	d9801e04 	addi	r6,sp,120
 82088a4:	b80b883a 	mov	r5,r23
 82088a8:	820f5900 	call	820f590 <__sprint_r>
 82088ac:	1039651e 	bne	r2,zero,8206e44 <___vfprintf_internal_r+0x408>
 82088b0:	dc402617 	ldw	r17,152(sp)
 82088b4:	d8c02017 	ldw	r3,128(sp)
 82088b8:	d8801f17 	ldw	r2,124(sp)
 82088bc:	da000404 	addi	r8,sp,16
 82088c0:	003ed606 	br	820841c <___vfprintf_internal_r+0x19e0>
 82088c4:	582b883a 	mov	r21,r11
 82088c8:	d8002915 	stw	zero,164(sp)
 82088cc:	0038bd06 	br	8206bc4 <___vfprintf_internal_r+0x188>
 82088d0:	d8802917 	ldw	r2,164(sp)
 82088d4:	103e071e 	bne	r2,zero,82080f4 <___vfprintf_internal_r+0x16b8>
 82088d8:	dc002915 	stw	r16,164(sp)
 82088dc:	003e0506 	br	82080f4 <___vfprintf_internal_r+0x16b8>
 82088e0:	d9002917 	ldw	r4,164(sp)
 82088e4:	20c00044 	addi	r3,r4,1
 82088e8:	003e0f06 	br	8208128 <___vfprintf_internal_r+0x16ec>
 82088ec:	01400184 	movi	r5,6
 82088f0:	d9402915 	stw	r5,164(sp)
 82088f4:	003dff06 	br	82080f4 <___vfprintf_internal_r+0x16b8>
 82088f8:	d8802104 	addi	r2,sp,132
 82088fc:	d8800315 	stw	r2,12(sp)
 8208900:	d8802504 	addi	r2,sp,148
 8208904:	d8800215 	stw	r2,8(sp)
 8208908:	d8802604 	addi	r2,sp,152
 820890c:	d8800115 	stw	r2,4(sp)
 8208910:	d8802917 	ldw	r2,164(sp)
 8208914:	d9403617 	ldw	r5,216(sp)
 8208918:	d9002c17 	ldw	r4,176(sp)
 820891c:	d8800015 	stw	r2,0(sp)
 8208920:	01c000c4 	movi	r7,3
 8208924:	980d883a 	mov	r6,r19
 8208928:	da003d15 	stw	r8,244(sp)
 820892c:	82091b80 	call	82091b8 <_dtoa_r>
 8208930:	d8c02917 	ldw	r3,164(sp)
 8208934:	da003d17 	ldw	r8,244(sp)
 8208938:	1021883a 	mov	r16,r2
 820893c:	10f9883a 	add	fp,r2,r3
 8208940:	81000007 	ldb	r4,0(r16)
 8208944:	00800c04 	movi	r2,48
 8208948:	20805e26 	beq	r4,r2,8208ac4 <___vfprintf_internal_r+0x2088>
 820894c:	d8c02617 	ldw	r3,152(sp)
 8208950:	e0f9883a 	add	fp,fp,r3
 8208954:	003e0a06 	br	8208180 <___vfprintf_internal_r+0x1744>
 8208958:	00c00b44 	movi	r3,45
 820895c:	24e0003c 	xorhi	r19,r4,32768
 8208960:	d8c02a05 	stb	r3,168(sp)
 8208964:	003de906 	br	820810c <___vfprintf_internal_r+0x16d0>
 8208968:	d8c03217 	ldw	r3,200(sp)
 820896c:	00c07a0e 	bge	zero,r3,8208b58 <___vfprintf_internal_r+0x211c>
 8208970:	00800044 	movi	r2,1
 8208974:	d9003317 	ldw	r4,204(sp)
 8208978:	1105883a 	add	r2,r2,r4
 820897c:	d8802e15 	stw	r2,184(sp)
 8208980:	10004e16 	blt	r2,zero,8208abc <___vfprintf_internal_r+0x2080>
 8208984:	044019c4 	movi	r17,103
 8208988:	003e2106 	br	8208210 <___vfprintf_internal_r+0x17d4>
 820898c:	d9002917 	ldw	r4,164(sp)
 8208990:	d8802104 	addi	r2,sp,132
 8208994:	d8800315 	stw	r2,12(sp)
 8208998:	d9000015 	stw	r4,0(sp)
 820899c:	d8802504 	addi	r2,sp,148
 82089a0:	d9403617 	ldw	r5,216(sp)
 82089a4:	d9002c17 	ldw	r4,176(sp)
 82089a8:	d8800215 	stw	r2,8(sp)
 82089ac:	d8802604 	addi	r2,sp,152
 82089b0:	d8800115 	stw	r2,4(sp)
 82089b4:	01c000c4 	movi	r7,3
 82089b8:	980d883a 	mov	r6,r19
 82089bc:	da003d15 	stw	r8,244(sp)
 82089c0:	82091b80 	call	82091b8 <_dtoa_r>
 82089c4:	d8c02917 	ldw	r3,164(sp)
 82089c8:	da003d17 	ldw	r8,244(sp)
 82089cc:	1021883a 	mov	r16,r2
 82089d0:	00801184 	movi	r2,70
 82089d4:	80f9883a 	add	fp,r16,r3
 82089d8:	88bfd926 	beq	r17,r2,8208940 <___vfprintf_internal_r+0x1f04>
 82089dc:	003de806 	br	8208180 <___vfprintf_internal_r+0x1744>
 82089e0:	d9002917 	ldw	r4,164(sp)
 82089e4:	00c04d0e 	bge	zero,r3,8208b1c <___vfprintf_internal_r+0x20e0>
 82089e8:	2000441e 	bne	r4,zero,8208afc <___vfprintf_internal_r+0x20c0>
 82089ec:	9480004c 	andi	r18,r18,1
 82089f0:	9000421e 	bne	r18,zero,8208afc <___vfprintf_internal_r+0x20c0>
 82089f4:	1805883a 	mov	r2,r3
 82089f8:	18007016 	blt	r3,zero,8208bbc <___vfprintf_internal_r+0x2180>
 82089fc:	d8c03217 	ldw	r3,200(sp)
 8208a00:	d8c02e15 	stw	r3,184(sp)
 8208a04:	003e0206 	br	8208210 <___vfprintf_internal_r+0x17d4>
 8208a08:	df0022c4 	addi	fp,sp,139
 8208a0c:	dc002915 	stw	r16,164(sp)
 8208a10:	4027883a 	mov	r19,r8
 8208a14:	e021883a 	mov	r16,fp
 8208a18:	b009883a 	mov	r4,r22
 8208a1c:	01400284 	movi	r5,10
 8208a20:	8202b9c0 	call	8202b9c <__modsi3>
 8208a24:	10800c04 	addi	r2,r2,48
 8208a28:	843fffc4 	addi	r16,r16,-1
 8208a2c:	b009883a 	mov	r4,r22
 8208a30:	01400284 	movi	r5,10
 8208a34:	80800005 	stb	r2,0(r16)
 8208a38:	8202b180 	call	8202b18 <__divsi3>
 8208a3c:	102d883a 	mov	r22,r2
 8208a40:	00800244 	movi	r2,9
 8208a44:	15bff416 	blt	r2,r22,8208a18 <___vfprintf_internal_r+0x1fdc>
 8208a48:	9811883a 	mov	r8,r19
 8208a4c:	b0800c04 	addi	r2,r22,48
 8208a50:	8027883a 	mov	r19,r16
 8208a54:	997fffc4 	addi	r5,r19,-1
 8208a58:	98bfffc5 	stb	r2,-1(r19)
 8208a5c:	dc002917 	ldw	r16,164(sp)
 8208a60:	2f006a2e 	bgeu	r5,fp,8208c0c <___vfprintf_internal_r+0x21d0>
 8208a64:	d9c02384 	addi	r7,sp,142
 8208a68:	3ccfc83a 	sub	r7,r7,r19
 8208a6c:	d9002344 	addi	r4,sp,141
 8208a70:	e1cf883a 	add	r7,fp,r7
 8208a74:	00000106 	br	8208a7c <___vfprintf_internal_r+0x2040>
 8208a78:	28800003 	ldbu	r2,0(r5)
 8208a7c:	20800005 	stb	r2,0(r4)
 8208a80:	21000044 	addi	r4,r4,1
 8208a84:	29400044 	addi	r5,r5,1
 8208a88:	393ffb1e 	bne	r7,r4,8208a78 <___vfprintf_internal_r+0x203c>
 8208a8c:	d8802304 	addi	r2,sp,140
 8208a90:	14c5c83a 	sub	r2,r2,r19
 8208a94:	d8c02344 	addi	r3,sp,141
 8208a98:	1885883a 	add	r2,r3,r2
 8208a9c:	003f7006 	br	8208860 <___vfprintf_internal_r+0x1e24>
 8208aa0:	0005883a 	mov	r2,zero
 8208aa4:	003f0f06 	br	82086e4 <___vfprintf_internal_r+0x1ca8>
 8208aa8:	d8c03217 	ldw	r3,200(sp)
 8208aac:	18c00044 	addi	r3,r3,1
 8208ab0:	d8c02e15 	stw	r3,184(sp)
 8208ab4:	1805883a 	mov	r2,r3
 8208ab8:	183fb20e 	bge	r3,zero,8208984 <___vfprintf_internal_r+0x1f48>
 8208abc:	0005883a 	mov	r2,zero
 8208ac0:	003fb006 	br	8208984 <___vfprintf_internal_r+0x1f48>
 8208ac4:	d9003617 	ldw	r4,216(sp)
 8208ac8:	000d883a 	mov	r6,zero
 8208acc:	000f883a 	mov	r7,zero
 8208ad0:	980b883a 	mov	r5,r19
 8208ad4:	d8c03c15 	stw	r3,240(sp)
 8208ad8:	da003d15 	stw	r8,244(sp)
 8208adc:	8212efc0 	call	8212efc <__eqdf2>
 8208ae0:	d8c03c17 	ldw	r3,240(sp)
 8208ae4:	da003d17 	ldw	r8,244(sp)
 8208ae8:	103f9826 	beq	r2,zero,820894c <___vfprintf_internal_r+0x1f10>
 8208aec:	00800044 	movi	r2,1
 8208af0:	10c7c83a 	sub	r3,r2,r3
 8208af4:	d8c02615 	stw	r3,152(sp)
 8208af8:	003f9506 	br	8208950 <___vfprintf_internal_r+0x1f14>
 8208afc:	d9002917 	ldw	r4,164(sp)
 8208b00:	d8c03217 	ldw	r3,200(sp)
 8208b04:	20800044 	addi	r2,r4,1
 8208b08:	1885883a 	add	r2,r3,r2
 8208b0c:	d8802e15 	stw	r2,184(sp)
 8208b10:	103dbf0e 	bge	r2,zero,8208210 <___vfprintf_internal_r+0x17d4>
 8208b14:	0005883a 	mov	r2,zero
 8208b18:	003dbd06 	br	8208210 <___vfprintf_internal_r+0x17d4>
 8208b1c:	2000211e 	bne	r4,zero,8208ba4 <___vfprintf_internal_r+0x2168>
 8208b20:	9480004c 	andi	r18,r18,1
 8208b24:	90001f1e 	bne	r18,zero,8208ba4 <___vfprintf_internal_r+0x2168>
 8208b28:	00800044 	movi	r2,1
 8208b2c:	d8802e15 	stw	r2,184(sp)
 8208b30:	003db706 	br	8208210 <___vfprintf_internal_r+0x17d4>
 8208b34:	00800b44 	movi	r2,45
 8208b38:	05adc83a 	sub	r22,zero,r22
 8208b3c:	d8802305 	stb	r2,140(sp)
 8208b40:	003f3f06 	br	8208840 <___vfprintf_internal_r+0x1e04>
 8208b44:	0005883a 	mov	r2,zero
 8208b48:	003f5206 	br	8208894 <___vfprintf_internal_r+0x1e58>
 8208b4c:	90a4703a 	and	r18,r18,r2
 8208b50:	903f4e26 	beq	r18,zero,820888c <___vfprintf_internal_r+0x1e50>
 8208b54:	003f4a06 	br	8208880 <___vfprintf_internal_r+0x1e44>
 8208b58:	00800084 	movi	r2,2
 8208b5c:	10c5c83a 	sub	r2,r2,r3
 8208b60:	003f8406 	br	8208974 <___vfprintf_internal_r+0x1f38>
 8208b64:	d8802d17 	ldw	r2,180(sp)
 8208b68:	d9002d17 	ldw	r4,180(sp)
 8208b6c:	ac400043 	ldbu	r17,1(r21)
 8208b70:	10800017 	ldw	r2,0(r2)
 8208b74:	582b883a 	mov	r21,r11
 8208b78:	d8802915 	stw	r2,164(sp)
 8208b7c:	20800104 	addi	r2,r4,4
 8208b80:	d9002917 	ldw	r4,164(sp)
 8208b84:	d8802d15 	stw	r2,180(sp)
 8208b88:	203e7a0e 	bge	r4,zero,8208574 <___vfprintf_internal_r+0x1b38>
 8208b8c:	8c403fcc 	andi	r17,r17,255
 8208b90:	00bfffc4 	movi	r2,-1
 8208b94:	8c40201c 	xori	r17,r17,128
 8208b98:	d8802915 	stw	r2,164(sp)
 8208b9c:	8c7fe004 	addi	r17,r17,-128
 8208ba0:	00380706 	br	8206bc0 <___vfprintf_internal_r+0x184>
 8208ba4:	d8c02917 	ldw	r3,164(sp)
 8208ba8:	18c00084 	addi	r3,r3,2
 8208bac:	d8c02e15 	stw	r3,184(sp)
 8208bb0:	1805883a 	mov	r2,r3
 8208bb4:	183d960e 	bge	r3,zero,8208210 <___vfprintf_internal_r+0x17d4>
 8208bb8:	003fd606 	br	8208b14 <___vfprintf_internal_r+0x20d8>
 8208bbc:	0005883a 	mov	r2,zero
 8208bc0:	003f8e06 	br	82089fc <___vfprintf_internal_r+0x1fc0>
 8208bc4:	9080004c 	andi	r2,r18,1
 8208bc8:	103f811e 	bne	r2,zero,82089d0 <___vfprintf_internal_r+0x1f94>
 8208bcc:	d8802117 	ldw	r2,132(sp)
 8208bd0:	1405c83a 	sub	r2,r2,r16
 8208bd4:	d8803315 	stw	r2,204(sp)
 8208bd8:	b47ef326 	beq	r22,r17,82087a8 <___vfprintf_internal_r+0x1d6c>
 8208bdc:	dd802617 	ldw	r22,152(sp)
 8208be0:	003f1106 	br	8208828 <___vfprintf_internal_r+0x1dec>
 8208be4:	d9c02785 	stb	r7,158(sp)
 8208be8:	00390406 	br	8206ffc <___vfprintf_internal_r+0x5c0>
 8208bec:	d9c02785 	stb	r7,158(sp)
 8208bf0:	0038d306 	br	8206f40 <___vfprintf_internal_r+0x504>
 8208bf4:	d9c02785 	stb	r7,158(sp)
 8208bf8:	003a6106 	br	8207580 <___vfprintf_internal_r+0xb44>
 8208bfc:	d9c02785 	stb	r7,158(sp)
 8208c00:	003af806 	br	82077e4 <___vfprintf_internal_r+0xda8>
 8208c04:	0005883a 	mov	r2,zero
 8208c08:	003d7e06 	br	8208204 <___vfprintf_internal_r+0x17c8>
 8208c0c:	d8802344 	addi	r2,sp,141
 8208c10:	003f1306 	br	8208860 <___vfprintf_internal_r+0x1e24>
 8208c14:	d9c02785 	stb	r7,158(sp)
 8208c18:	00392306 	br	82070a8 <___vfprintf_internal_r+0x66c>
 8208c1c:	d9c02785 	stb	r7,158(sp)
 8208c20:	003aa906 	br	82076c8 <___vfprintf_internal_r+0xc8c>
 8208c24:	d9c02785 	stb	r7,158(sp)
 8208c28:	003a3d06 	br	8207520 <___vfprintf_internal_r+0xae4>
 8208c2c:	d9c02785 	stb	r7,158(sp)
 8208c30:	003aca06 	br	820775c <___vfprintf_internal_r+0xd20>

08208c34 <__vfprintf_internal>:
 8208c34:	00820974 	movhi	r2,2085
 8208c38:	108f9904 	addi	r2,r2,15972
 8208c3c:	300f883a 	mov	r7,r6
 8208c40:	280d883a 	mov	r6,r5
 8208c44:	200b883a 	mov	r5,r4
 8208c48:	11000017 	ldw	r4,0(r2)
 8208c4c:	8206a3c1 	jmpi	8206a3c <___vfprintf_internal_r>

08208c50 <__sbprintf>:
 8208c50:	2880030b 	ldhu	r2,12(r5)
 8208c54:	2ac01917 	ldw	r11,100(r5)
 8208c58:	2a80038b 	ldhu	r10,14(r5)
 8208c5c:	2a400717 	ldw	r9,28(r5)
 8208c60:	2a000917 	ldw	r8,36(r5)
 8208c64:	defee204 	addi	sp,sp,-1144
 8208c68:	00c10004 	movi	r3,1024
 8208c6c:	dc011a15 	stw	r16,1128(sp)
 8208c70:	10bfff4c 	andi	r2,r2,65533
 8208c74:	2821883a 	mov	r16,r5
 8208c78:	d8cb883a 	add	r5,sp,r3
 8208c7c:	dc811c15 	stw	r18,1136(sp)
 8208c80:	dc411b15 	stw	r17,1132(sp)
 8208c84:	dfc11d15 	stw	ra,1140(sp)
 8208c88:	2025883a 	mov	r18,r4
 8208c8c:	d881030d 	sth	r2,1036(sp)
 8208c90:	dac11915 	stw	r11,1124(sp)
 8208c94:	da81038d 	sth	r10,1038(sp)
 8208c98:	da410715 	stw	r9,1052(sp)
 8208c9c:	da010915 	stw	r8,1060(sp)
 8208ca0:	dec10015 	stw	sp,1024(sp)
 8208ca4:	dec10415 	stw	sp,1040(sp)
 8208ca8:	d8c10215 	stw	r3,1032(sp)
 8208cac:	d8c10515 	stw	r3,1044(sp)
 8208cb0:	d8010615 	stw	zero,1048(sp)
 8208cb4:	8206a3c0 	call	8206a3c <___vfprintf_internal_r>
 8208cb8:	1023883a 	mov	r17,r2
 8208cbc:	10000416 	blt	r2,zero,8208cd0 <__sbprintf+0x80>
 8208cc0:	d9410004 	addi	r5,sp,1024
 8208cc4:	9009883a 	mov	r4,r18
 8208cc8:	820aa5c0 	call	820aa5c <_fflush_r>
 8208ccc:	10000d1e 	bne	r2,zero,8208d04 <__sbprintf+0xb4>
 8208cd0:	d881030b 	ldhu	r2,1036(sp)
 8208cd4:	1080100c 	andi	r2,r2,64
 8208cd8:	10000326 	beq	r2,zero,8208ce8 <__sbprintf+0x98>
 8208cdc:	8080030b 	ldhu	r2,12(r16)
 8208ce0:	10801014 	ori	r2,r2,64
 8208ce4:	8080030d 	sth	r2,12(r16)
 8208ce8:	8805883a 	mov	r2,r17
 8208cec:	dfc11d17 	ldw	ra,1140(sp)
 8208cf0:	dc811c17 	ldw	r18,1136(sp)
 8208cf4:	dc411b17 	ldw	r17,1132(sp)
 8208cf8:	dc011a17 	ldw	r16,1128(sp)
 8208cfc:	dec11e04 	addi	sp,sp,1144
 8208d00:	f800283a 	ret
 8208d04:	047fffc4 	movi	r17,-1
 8208d08:	003ff106 	br	8208cd0 <__sbprintf+0x80>

08208d0c <__swbuf_r>:
 8208d0c:	defffb04 	addi	sp,sp,-20
 8208d10:	dcc00315 	stw	r19,12(sp)
 8208d14:	dc800215 	stw	r18,8(sp)
 8208d18:	dc000015 	stw	r16,0(sp)
 8208d1c:	dfc00415 	stw	ra,16(sp)
 8208d20:	dc400115 	stw	r17,4(sp)
 8208d24:	2025883a 	mov	r18,r4
 8208d28:	2827883a 	mov	r19,r5
 8208d2c:	3021883a 	mov	r16,r6
 8208d30:	20000226 	beq	r4,zero,8208d3c <__swbuf_r+0x30>
 8208d34:	20800e17 	ldw	r2,56(r4)
 8208d38:	10004226 	beq	r2,zero,8208e44 <__swbuf_r+0x138>
 8208d3c:	80800617 	ldw	r2,24(r16)
 8208d40:	8100030b 	ldhu	r4,12(r16)
 8208d44:	80800215 	stw	r2,8(r16)
 8208d48:	2080020c 	andi	r2,r4,8
 8208d4c:	10003626 	beq	r2,zero,8208e28 <__swbuf_r+0x11c>
 8208d50:	80c00417 	ldw	r3,16(r16)
 8208d54:	18003426 	beq	r3,zero,8208e28 <__swbuf_r+0x11c>
 8208d58:	2088000c 	andi	r2,r4,8192
 8208d5c:	9c403fcc 	andi	r17,r19,255
 8208d60:	10001a26 	beq	r2,zero,8208dcc <__swbuf_r+0xc0>
 8208d64:	80800017 	ldw	r2,0(r16)
 8208d68:	81000517 	ldw	r4,20(r16)
 8208d6c:	10c7c83a 	sub	r3,r2,r3
 8208d70:	1900200e 	bge	r3,r4,8208df4 <__swbuf_r+0xe8>
 8208d74:	18c00044 	addi	r3,r3,1
 8208d78:	81000217 	ldw	r4,8(r16)
 8208d7c:	11400044 	addi	r5,r2,1
 8208d80:	81400015 	stw	r5,0(r16)
 8208d84:	213fffc4 	addi	r4,r4,-1
 8208d88:	81000215 	stw	r4,8(r16)
 8208d8c:	14c00005 	stb	r19,0(r2)
 8208d90:	80800517 	ldw	r2,20(r16)
 8208d94:	10c01e26 	beq	r2,r3,8208e10 <__swbuf_r+0x104>
 8208d98:	8080030b 	ldhu	r2,12(r16)
 8208d9c:	1080004c 	andi	r2,r2,1
 8208da0:	10000226 	beq	r2,zero,8208dac <__swbuf_r+0xa0>
 8208da4:	00800284 	movi	r2,10
 8208da8:	88801926 	beq	r17,r2,8208e10 <__swbuf_r+0x104>
 8208dac:	8805883a 	mov	r2,r17
 8208db0:	dfc00417 	ldw	ra,16(sp)
 8208db4:	dcc00317 	ldw	r19,12(sp)
 8208db8:	dc800217 	ldw	r18,8(sp)
 8208dbc:	dc400117 	ldw	r17,4(sp)
 8208dc0:	dc000017 	ldw	r16,0(sp)
 8208dc4:	dec00504 	addi	sp,sp,20
 8208dc8:	f800283a 	ret
 8208dcc:	81401917 	ldw	r5,100(r16)
 8208dd0:	00b7ffc4 	movi	r2,-8193
 8208dd4:	21080014 	ori	r4,r4,8192
 8208dd8:	2884703a 	and	r2,r5,r2
 8208ddc:	80801915 	stw	r2,100(r16)
 8208de0:	80800017 	ldw	r2,0(r16)
 8208de4:	8100030d 	sth	r4,12(r16)
 8208de8:	81000517 	ldw	r4,20(r16)
 8208dec:	10c7c83a 	sub	r3,r2,r3
 8208df0:	193fe016 	blt	r3,r4,8208d74 <__swbuf_r+0x68>
 8208df4:	800b883a 	mov	r5,r16
 8208df8:	9009883a 	mov	r4,r18
 8208dfc:	820aa5c0 	call	820aa5c <_fflush_r>
 8208e00:	1000071e 	bne	r2,zero,8208e20 <__swbuf_r+0x114>
 8208e04:	80800017 	ldw	r2,0(r16)
 8208e08:	00c00044 	movi	r3,1
 8208e0c:	003fda06 	br	8208d78 <__swbuf_r+0x6c>
 8208e10:	800b883a 	mov	r5,r16
 8208e14:	9009883a 	mov	r4,r18
 8208e18:	820aa5c0 	call	820aa5c <_fflush_r>
 8208e1c:	103fe326 	beq	r2,zero,8208dac <__swbuf_r+0xa0>
 8208e20:	00bfffc4 	movi	r2,-1
 8208e24:	003fe206 	br	8208db0 <__swbuf_r+0xa4>
 8208e28:	800b883a 	mov	r5,r16
 8208e2c:	9009883a 	mov	r4,r18
 8208e30:	8208e640 	call	8208e64 <__swsetup_r>
 8208e34:	103ffa1e 	bne	r2,zero,8208e20 <__swbuf_r+0x114>
 8208e38:	8100030b 	ldhu	r4,12(r16)
 8208e3c:	80c00417 	ldw	r3,16(r16)
 8208e40:	003fc506 	br	8208d58 <__swbuf_r+0x4c>
 8208e44:	820ae380 	call	820ae38 <__sinit>
 8208e48:	003fbc06 	br	8208d3c <__swbuf_r+0x30>

08208e4c <__swbuf>:
 8208e4c:	00820974 	movhi	r2,2085
 8208e50:	108f9904 	addi	r2,r2,15972
 8208e54:	280d883a 	mov	r6,r5
 8208e58:	200b883a 	mov	r5,r4
 8208e5c:	11000017 	ldw	r4,0(r2)
 8208e60:	8208d0c1 	jmpi	8208d0c <__swbuf_r>

08208e64 <__swsetup_r>:
 8208e64:	00820974 	movhi	r2,2085
 8208e68:	defffd04 	addi	sp,sp,-12
 8208e6c:	108f9904 	addi	r2,r2,15972
 8208e70:	dc400115 	stw	r17,4(sp)
 8208e74:	2023883a 	mov	r17,r4
 8208e78:	11000017 	ldw	r4,0(r2)
 8208e7c:	dc000015 	stw	r16,0(sp)
 8208e80:	dfc00215 	stw	ra,8(sp)
 8208e84:	2821883a 	mov	r16,r5
 8208e88:	20000226 	beq	r4,zero,8208e94 <__swsetup_r+0x30>
 8208e8c:	20800e17 	ldw	r2,56(r4)
 8208e90:	10003126 	beq	r2,zero,8208f58 <__swsetup_r+0xf4>
 8208e94:	8080030b 	ldhu	r2,12(r16)
 8208e98:	10c0020c 	andi	r3,r2,8
 8208e9c:	1009883a 	mov	r4,r2
 8208ea0:	18000f26 	beq	r3,zero,8208ee0 <__swsetup_r+0x7c>
 8208ea4:	80c00417 	ldw	r3,16(r16)
 8208ea8:	18001526 	beq	r3,zero,8208f00 <__swsetup_r+0x9c>
 8208eac:	1100004c 	andi	r4,r2,1
 8208eb0:	20001c1e 	bne	r4,zero,8208f24 <__swsetup_r+0xc0>
 8208eb4:	1080008c 	andi	r2,r2,2
 8208eb8:	1000291e 	bne	r2,zero,8208f60 <__swsetup_r+0xfc>
 8208ebc:	80800517 	ldw	r2,20(r16)
 8208ec0:	80800215 	stw	r2,8(r16)
 8208ec4:	18001c26 	beq	r3,zero,8208f38 <__swsetup_r+0xd4>
 8208ec8:	0005883a 	mov	r2,zero
 8208ecc:	dfc00217 	ldw	ra,8(sp)
 8208ed0:	dc400117 	ldw	r17,4(sp)
 8208ed4:	dc000017 	ldw	r16,0(sp)
 8208ed8:	dec00304 	addi	sp,sp,12
 8208edc:	f800283a 	ret
 8208ee0:	2080040c 	andi	r2,r4,16
 8208ee4:	10002e26 	beq	r2,zero,8208fa0 <__swsetup_r+0x13c>
 8208ee8:	2080010c 	andi	r2,r4,4
 8208eec:	10001e1e 	bne	r2,zero,8208f68 <__swsetup_r+0x104>
 8208ef0:	80c00417 	ldw	r3,16(r16)
 8208ef4:	20800214 	ori	r2,r4,8
 8208ef8:	8080030d 	sth	r2,12(r16)
 8208efc:	183feb1e 	bne	r3,zero,8208eac <__swsetup_r+0x48>
 8208f00:	1100a00c 	andi	r4,r2,640
 8208f04:	01408004 	movi	r5,512
 8208f08:	217fe826 	beq	r4,r5,8208eac <__swsetup_r+0x48>
 8208f0c:	800b883a 	mov	r5,r16
 8208f10:	8809883a 	mov	r4,r17
 8208f14:	820bb300 	call	820bb30 <__smakebuf_r>
 8208f18:	8080030b 	ldhu	r2,12(r16)
 8208f1c:	80c00417 	ldw	r3,16(r16)
 8208f20:	003fe206 	br	8208eac <__swsetup_r+0x48>
 8208f24:	80800517 	ldw	r2,20(r16)
 8208f28:	80000215 	stw	zero,8(r16)
 8208f2c:	0085c83a 	sub	r2,zero,r2
 8208f30:	80800615 	stw	r2,24(r16)
 8208f34:	183fe41e 	bne	r3,zero,8208ec8 <__swsetup_r+0x64>
 8208f38:	80c0030b 	ldhu	r3,12(r16)
 8208f3c:	0005883a 	mov	r2,zero
 8208f40:	1900200c 	andi	r4,r3,128
 8208f44:	203fe126 	beq	r4,zero,8208ecc <__swsetup_r+0x68>
 8208f48:	18c01014 	ori	r3,r3,64
 8208f4c:	80c0030d 	sth	r3,12(r16)
 8208f50:	00bfffc4 	movi	r2,-1
 8208f54:	003fdd06 	br	8208ecc <__swsetup_r+0x68>
 8208f58:	820ae380 	call	820ae38 <__sinit>
 8208f5c:	003fcd06 	br	8208e94 <__swsetup_r+0x30>
 8208f60:	0005883a 	mov	r2,zero
 8208f64:	003fd606 	br	8208ec0 <__swsetup_r+0x5c>
 8208f68:	81400c17 	ldw	r5,48(r16)
 8208f6c:	28000626 	beq	r5,zero,8208f88 <__swsetup_r+0x124>
 8208f70:	80801004 	addi	r2,r16,64
 8208f74:	28800326 	beq	r5,r2,8208f84 <__swsetup_r+0x120>
 8208f78:	8809883a 	mov	r4,r17
 8208f7c:	820b1000 	call	820b100 <_free_r>
 8208f80:	8100030b 	ldhu	r4,12(r16)
 8208f84:	80000c15 	stw	zero,48(r16)
 8208f88:	80c00417 	ldw	r3,16(r16)
 8208f8c:	00bff6c4 	movi	r2,-37
 8208f90:	1108703a 	and	r4,r2,r4
 8208f94:	80000115 	stw	zero,4(r16)
 8208f98:	80c00015 	stw	r3,0(r16)
 8208f9c:	003fd506 	br	8208ef4 <__swsetup_r+0x90>
 8208fa0:	00800244 	movi	r2,9
 8208fa4:	88800015 	stw	r2,0(r17)
 8208fa8:	20801014 	ori	r2,r4,64
 8208fac:	8080030d 	sth	r2,12(r16)
 8208fb0:	00bfffc4 	movi	r2,-1
 8208fb4:	003fc506 	br	8208ecc <__swsetup_r+0x68>

08208fb8 <quorem>:
 8208fb8:	defff704 	addi	sp,sp,-36
 8208fbc:	dc800215 	stw	r18,8(sp)
 8208fc0:	20800417 	ldw	r2,16(r4)
 8208fc4:	2c800417 	ldw	r18,16(r5)
 8208fc8:	dfc00815 	stw	ra,32(sp)
 8208fcc:	ddc00715 	stw	r23,28(sp)
 8208fd0:	dd800615 	stw	r22,24(sp)
 8208fd4:	dd400515 	stw	r21,20(sp)
 8208fd8:	dd000415 	stw	r20,16(sp)
 8208fdc:	dcc00315 	stw	r19,12(sp)
 8208fe0:	dc400115 	stw	r17,4(sp)
 8208fe4:	dc000015 	stw	r16,0(sp)
 8208fe8:	14807116 	blt	r2,r18,82091b0 <quorem+0x1f8>
 8208fec:	94bfffc4 	addi	r18,r18,-1
 8208ff0:	94ad883a 	add	r22,r18,r18
 8208ff4:	b5ad883a 	add	r22,r22,r22
 8208ff8:	2c400504 	addi	r17,r5,20
 8208ffc:	8da9883a 	add	r20,r17,r22
 8209000:	25400504 	addi	r21,r4,20
 8209004:	282f883a 	mov	r23,r5
 8209008:	adad883a 	add	r22,r21,r22
 820900c:	a1400017 	ldw	r5,0(r20)
 8209010:	2021883a 	mov	r16,r4
 8209014:	b1000017 	ldw	r4,0(r22)
 8209018:	29400044 	addi	r5,r5,1
 820901c:	8202c100 	call	8202c10 <__udivsi3>
 8209020:	1027883a 	mov	r19,r2
 8209024:	10002c26 	beq	r2,zero,82090d8 <quorem+0x120>
 8209028:	a813883a 	mov	r9,r21
 820902c:	880b883a 	mov	r5,r17
 8209030:	0009883a 	mov	r4,zero
 8209034:	000d883a 	mov	r6,zero
 8209038:	2a000017 	ldw	r8,0(r5)
 820903c:	49c00017 	ldw	r7,0(r9)
 8209040:	29400104 	addi	r5,r5,4
 8209044:	40bfffcc 	andi	r2,r8,65535
 8209048:	14c5383a 	mul	r2,r2,r19
 820904c:	4010d43a 	srli	r8,r8,16
 8209050:	38ffffcc 	andi	r3,r7,65535
 8209054:	1105883a 	add	r2,r2,r4
 8209058:	1008d43a 	srli	r4,r2,16
 820905c:	44d1383a 	mul	r8,r8,r19
 8209060:	198d883a 	add	r6,r3,r6
 8209064:	10ffffcc 	andi	r3,r2,65535
 8209068:	30c7c83a 	sub	r3,r6,r3
 820906c:	380ed43a 	srli	r7,r7,16
 8209070:	4105883a 	add	r2,r8,r4
 8209074:	180dd43a 	srai	r6,r3,16
 8209078:	113fffcc 	andi	r4,r2,65535
 820907c:	390fc83a 	sub	r7,r7,r4
 8209080:	398d883a 	add	r6,r7,r6
 8209084:	300e943a 	slli	r7,r6,16
 8209088:	18ffffcc 	andi	r3,r3,65535
 820908c:	1008d43a 	srli	r4,r2,16
 8209090:	38ceb03a 	or	r7,r7,r3
 8209094:	49c00015 	stw	r7,0(r9)
 8209098:	300dd43a 	srai	r6,r6,16
 820909c:	4a400104 	addi	r9,r9,4
 82090a0:	a17fe52e 	bgeu	r20,r5,8209038 <quorem+0x80>
 82090a4:	b0800017 	ldw	r2,0(r22)
 82090a8:	10000b1e 	bne	r2,zero,82090d8 <quorem+0x120>
 82090ac:	b0bfff04 	addi	r2,r22,-4
 82090b0:	a880082e 	bgeu	r21,r2,82090d4 <quorem+0x11c>
 82090b4:	b0ffff17 	ldw	r3,-4(r22)
 82090b8:	18000326 	beq	r3,zero,82090c8 <quorem+0x110>
 82090bc:	00000506 	br	82090d4 <quorem+0x11c>
 82090c0:	10c00017 	ldw	r3,0(r2)
 82090c4:	1800031e 	bne	r3,zero,82090d4 <quorem+0x11c>
 82090c8:	10bfff04 	addi	r2,r2,-4
 82090cc:	94bfffc4 	addi	r18,r18,-1
 82090d0:	a8bffb36 	bltu	r21,r2,82090c0 <quorem+0x108>
 82090d4:	84800415 	stw	r18,16(r16)
 82090d8:	b80b883a 	mov	r5,r23
 82090dc:	8009883a 	mov	r4,r16
 82090e0:	820cf200 	call	820cf20 <__mcmp>
 82090e4:	10002616 	blt	r2,zero,8209180 <quorem+0x1c8>
 82090e8:	9cc00044 	addi	r19,r19,1
 82090ec:	a805883a 	mov	r2,r21
 82090f0:	000b883a 	mov	r5,zero
 82090f4:	11000017 	ldw	r4,0(r2)
 82090f8:	89800017 	ldw	r6,0(r17)
 82090fc:	10800104 	addi	r2,r2,4
 8209100:	20ffffcc 	andi	r3,r4,65535
 8209104:	194b883a 	add	r5,r3,r5
 8209108:	30ffffcc 	andi	r3,r6,65535
 820910c:	28c7c83a 	sub	r3,r5,r3
 8209110:	300cd43a 	srli	r6,r6,16
 8209114:	2008d43a 	srli	r4,r4,16
 8209118:	180bd43a 	srai	r5,r3,16
 820911c:	18ffffcc 	andi	r3,r3,65535
 8209120:	2189c83a 	sub	r4,r4,r6
 8209124:	2149883a 	add	r4,r4,r5
 8209128:	200c943a 	slli	r6,r4,16
 820912c:	8c400104 	addi	r17,r17,4
 8209130:	200bd43a 	srai	r5,r4,16
 8209134:	30c6b03a 	or	r3,r6,r3
 8209138:	10ffff15 	stw	r3,-4(r2)
 820913c:	a47fed2e 	bgeu	r20,r17,82090f4 <quorem+0x13c>
 8209140:	9485883a 	add	r2,r18,r18
 8209144:	1085883a 	add	r2,r2,r2
 8209148:	a887883a 	add	r3,r21,r2
 820914c:	18800017 	ldw	r2,0(r3)
 8209150:	10000b1e 	bne	r2,zero,8209180 <quorem+0x1c8>
 8209154:	18bfff04 	addi	r2,r3,-4
 8209158:	a880082e 	bgeu	r21,r2,820917c <quorem+0x1c4>
 820915c:	18ffff17 	ldw	r3,-4(r3)
 8209160:	18000326 	beq	r3,zero,8209170 <quorem+0x1b8>
 8209164:	00000506 	br	820917c <quorem+0x1c4>
 8209168:	10c00017 	ldw	r3,0(r2)
 820916c:	1800031e 	bne	r3,zero,820917c <quorem+0x1c4>
 8209170:	10bfff04 	addi	r2,r2,-4
 8209174:	94bfffc4 	addi	r18,r18,-1
 8209178:	a8bffb36 	bltu	r21,r2,8209168 <quorem+0x1b0>
 820917c:	84800415 	stw	r18,16(r16)
 8209180:	9805883a 	mov	r2,r19
 8209184:	dfc00817 	ldw	ra,32(sp)
 8209188:	ddc00717 	ldw	r23,28(sp)
 820918c:	dd800617 	ldw	r22,24(sp)
 8209190:	dd400517 	ldw	r21,20(sp)
 8209194:	dd000417 	ldw	r20,16(sp)
 8209198:	dcc00317 	ldw	r19,12(sp)
 820919c:	dc800217 	ldw	r18,8(sp)
 82091a0:	dc400117 	ldw	r17,4(sp)
 82091a4:	dc000017 	ldw	r16,0(sp)
 82091a8:	dec00904 	addi	sp,sp,36
 82091ac:	f800283a 	ret
 82091b0:	0005883a 	mov	r2,zero
 82091b4:	003ff306 	br	8209184 <quorem+0x1cc>

082091b8 <_dtoa_r>:
 82091b8:	20801017 	ldw	r2,64(r4)
 82091bc:	deffde04 	addi	sp,sp,-136
 82091c0:	df002015 	stw	fp,128(sp)
 82091c4:	dcc01b15 	stw	r19,108(sp)
 82091c8:	dc801a15 	stw	r18,104(sp)
 82091cc:	dc401915 	stw	r17,100(sp)
 82091d0:	dc001815 	stw	r16,96(sp)
 82091d4:	dfc02115 	stw	ra,132(sp)
 82091d8:	ddc01f15 	stw	r23,124(sp)
 82091dc:	dd801e15 	stw	r22,120(sp)
 82091e0:	dd401d15 	stw	r21,116(sp)
 82091e4:	dd001c15 	stw	r20,112(sp)
 82091e8:	d9c00315 	stw	r7,12(sp)
 82091ec:	2039883a 	mov	fp,r4
 82091f0:	3023883a 	mov	r17,r6
 82091f4:	2825883a 	mov	r18,r5
 82091f8:	dc002417 	ldw	r16,144(sp)
 82091fc:	3027883a 	mov	r19,r6
 8209200:	10000826 	beq	r2,zero,8209224 <_dtoa_r+0x6c>
 8209204:	21801117 	ldw	r6,68(r4)
 8209208:	00c00044 	movi	r3,1
 820920c:	100b883a 	mov	r5,r2
 8209210:	1986983a 	sll	r3,r3,r6
 8209214:	11800115 	stw	r6,4(r2)
 8209218:	10c00215 	stw	r3,8(r2)
 820921c:	820c7000 	call	820c700 <_Bfree>
 8209220:	e0001015 	stw	zero,64(fp)
 8209224:	88002e16 	blt	r17,zero,82092e0 <_dtoa_r+0x128>
 8209228:	80000015 	stw	zero,0(r16)
 820922c:	889ffc2c 	andhi	r2,r17,32752
 8209230:	00dffc34 	movhi	r3,32752
 8209234:	10c01c26 	beq	r2,r3,82092a8 <_dtoa_r+0xf0>
 8209238:	000d883a 	mov	r6,zero
 820923c:	000f883a 	mov	r7,zero
 8209240:	9009883a 	mov	r4,r18
 8209244:	980b883a 	mov	r5,r19
 8209248:	8212efc0 	call	8212efc <__eqdf2>
 820924c:	10002b1e 	bne	r2,zero,82092fc <_dtoa_r+0x144>
 8209250:	d9c02317 	ldw	r7,140(sp)
 8209254:	00800044 	movi	r2,1
 8209258:	38800015 	stw	r2,0(r7)
 820925c:	d8802517 	ldw	r2,148(sp)
 8209260:	10019e26 	beq	r2,zero,82098dc <_dtoa_r+0x724>
 8209264:	d8c02517 	ldw	r3,148(sp)
 8209268:	00820974 	movhi	r2,2085
 820926c:	10b6ca44 	addi	r2,r2,-9431
 8209270:	18800015 	stw	r2,0(r3)
 8209274:	10bfffc4 	addi	r2,r2,-1
 8209278:	dfc02117 	ldw	ra,132(sp)
 820927c:	df002017 	ldw	fp,128(sp)
 8209280:	ddc01f17 	ldw	r23,124(sp)
 8209284:	dd801e17 	ldw	r22,120(sp)
 8209288:	dd401d17 	ldw	r21,116(sp)
 820928c:	dd001c17 	ldw	r20,112(sp)
 8209290:	dcc01b17 	ldw	r19,108(sp)
 8209294:	dc801a17 	ldw	r18,104(sp)
 8209298:	dc401917 	ldw	r17,100(sp)
 820929c:	dc001817 	ldw	r16,96(sp)
 82092a0:	dec02204 	addi	sp,sp,136
 82092a4:	f800283a 	ret
 82092a8:	d8c02317 	ldw	r3,140(sp)
 82092ac:	0089c3c4 	movi	r2,9999
 82092b0:	18800015 	stw	r2,0(r3)
 82092b4:	90017726 	beq	r18,zero,8209894 <_dtoa_r+0x6dc>
 82092b8:	00820974 	movhi	r2,2085
 82092bc:	10b6de04 	addi	r2,r2,-9352
 82092c0:	d9002517 	ldw	r4,148(sp)
 82092c4:	203fec26 	beq	r4,zero,8209278 <_dtoa_r+0xc0>
 82092c8:	10c000c7 	ldb	r3,3(r2)
 82092cc:	1801781e 	bne	r3,zero,82098b0 <_dtoa_r+0x6f8>
 82092d0:	10c000c4 	addi	r3,r2,3
 82092d4:	d9802517 	ldw	r6,148(sp)
 82092d8:	30c00015 	stw	r3,0(r6)
 82092dc:	003fe606 	br	8209278 <_dtoa_r+0xc0>
 82092e0:	04e00034 	movhi	r19,32768
 82092e4:	9cffffc4 	addi	r19,r19,-1
 82092e8:	00800044 	movi	r2,1
 82092ec:	8ce6703a 	and	r19,r17,r19
 82092f0:	80800015 	stw	r2,0(r16)
 82092f4:	9823883a 	mov	r17,r19
 82092f8:	003fcc06 	br	820922c <_dtoa_r+0x74>
 82092fc:	d8800204 	addi	r2,sp,8
 8209300:	d8800015 	stw	r2,0(sp)
 8209304:	d9c00104 	addi	r7,sp,4
 8209308:	900b883a 	mov	r5,r18
 820930c:	980d883a 	mov	r6,r19
 8209310:	e009883a 	mov	r4,fp
 8209314:	8820d53a 	srli	r16,r17,20
 8209318:	820d2ec0 	call	820d2ec <__d2b>
 820931c:	d8800915 	stw	r2,36(sp)
 8209320:	8001651e 	bne	r16,zero,82098b8 <_dtoa_r+0x700>
 8209324:	dd800217 	ldw	r22,8(sp)
 8209328:	dc000117 	ldw	r16,4(sp)
 820932c:	00800804 	movi	r2,32
 8209330:	b421883a 	add	r16,r22,r16
 8209334:	80c10c84 	addi	r3,r16,1074
 8209338:	10c2d10e 	bge	r2,r3,8209e80 <_dtoa_r+0xcc8>
 820933c:	00801004 	movi	r2,64
 8209340:	81010484 	addi	r4,r16,1042
 8209344:	10c7c83a 	sub	r3,r2,r3
 8209348:	9108d83a 	srl	r4,r18,r4
 820934c:	88e2983a 	sll	r17,r17,r3
 8209350:	2448b03a 	or	r4,r4,r17
 8209354:	82142c40 	call	82142c4 <__floatunsidf>
 8209358:	017f8434 	movhi	r5,65040
 820935c:	01800044 	movi	r6,1
 8209360:	1009883a 	mov	r4,r2
 8209364:	194b883a 	add	r5,r3,r5
 8209368:	843fffc4 	addi	r16,r16,-1
 820936c:	d9801115 	stw	r6,68(sp)
 8209370:	000d883a 	mov	r6,zero
 8209374:	01cffe34 	movhi	r7,16376
 8209378:	821386c0 	call	821386c <__subdf3>
 820937c:	0198dbf4 	movhi	r6,25455
 8209380:	01cff4f4 	movhi	r7,16339
 8209384:	3190d844 	addi	r6,r6,17249
 8209388:	39e1e9c4 	addi	r7,r7,-30809
 820938c:	1009883a 	mov	r4,r2
 8209390:	180b883a 	mov	r5,r3
 8209394:	82131540 	call	8213154 <__muldf3>
 8209398:	01a2d874 	movhi	r6,35681
 820939c:	01cff1f4 	movhi	r7,16327
 82093a0:	31b22cc4 	addi	r6,r6,-14157
 82093a4:	39e28a04 	addi	r7,r7,-30168
 82093a8:	180b883a 	mov	r5,r3
 82093ac:	1009883a 	mov	r4,r2
 82093b0:	8211d680 	call	8211d68 <__adddf3>
 82093b4:	8009883a 	mov	r4,r16
 82093b8:	1029883a 	mov	r20,r2
 82093bc:	1823883a 	mov	r17,r3
 82093c0:	82141e80 	call	82141e8 <__floatsidf>
 82093c4:	019427f4 	movhi	r6,20639
 82093c8:	01cff4f4 	movhi	r7,16339
 82093cc:	319e7ec4 	addi	r6,r6,31227
 82093d0:	39d104c4 	addi	r7,r7,17427
 82093d4:	1009883a 	mov	r4,r2
 82093d8:	180b883a 	mov	r5,r3
 82093dc:	82131540 	call	8213154 <__muldf3>
 82093e0:	100d883a 	mov	r6,r2
 82093e4:	180f883a 	mov	r7,r3
 82093e8:	a009883a 	mov	r4,r20
 82093ec:	880b883a 	mov	r5,r17
 82093f0:	8211d680 	call	8211d68 <__adddf3>
 82093f4:	1009883a 	mov	r4,r2
 82093f8:	180b883a 	mov	r5,r3
 82093fc:	1029883a 	mov	r20,r2
 8209400:	1823883a 	mov	r17,r3
 8209404:	82141680 	call	8214168 <__fixdfsi>
 8209408:	000d883a 	mov	r6,zero
 820940c:	000f883a 	mov	r7,zero
 8209410:	a009883a 	mov	r4,r20
 8209414:	880b883a 	mov	r5,r17
 8209418:	d8800515 	stw	r2,20(sp)
 820941c:	82130600 	call	8213060 <__ledf2>
 8209420:	10028716 	blt	r2,zero,8209e40 <_dtoa_r+0xc88>
 8209424:	d8c00517 	ldw	r3,20(sp)
 8209428:	00800584 	movi	r2,22
 820942c:	10c27536 	bltu	r2,r3,8209e04 <_dtoa_r+0xc4c>
 8209430:	180490fa 	slli	r2,r3,3
 8209434:	00c20974 	movhi	r3,2085
 8209438:	18f6f904 	addi	r3,r3,-9244
 820943c:	1885883a 	add	r2,r3,r2
 8209440:	11000017 	ldw	r4,0(r2)
 8209444:	11400117 	ldw	r5,4(r2)
 8209448:	900d883a 	mov	r6,r18
 820944c:	980f883a 	mov	r7,r19
 8209450:	8212f840 	call	8212f84 <__gedf2>
 8209454:	00828d0e 	bge	zero,r2,8209e8c <_dtoa_r+0xcd4>
 8209458:	d9000517 	ldw	r4,20(sp)
 820945c:	d8000e15 	stw	zero,56(sp)
 8209460:	213fffc4 	addi	r4,r4,-1
 8209464:	d9000515 	stw	r4,20(sp)
 8209468:	b42dc83a 	sub	r22,r22,r16
 820946c:	b5bfffc4 	addi	r22,r22,-1
 8209470:	b0026f16 	blt	r22,zero,8209e30 <_dtoa_r+0xc78>
 8209474:	d8000815 	stw	zero,32(sp)
 8209478:	d9c00517 	ldw	r7,20(sp)
 820947c:	38026416 	blt	r7,zero,8209e10 <_dtoa_r+0xc58>
 8209480:	b1ed883a 	add	r22,r22,r7
 8209484:	d9c00d15 	stw	r7,52(sp)
 8209488:	d8000a15 	stw	zero,40(sp)
 820948c:	d9800317 	ldw	r6,12(sp)
 8209490:	00800244 	movi	r2,9
 8209494:	11811436 	bltu	r2,r6,82098e8 <_dtoa_r+0x730>
 8209498:	00800144 	movi	r2,5
 820949c:	1184e10e 	bge	r2,r6,820a824 <_dtoa_r+0x166c>
 82094a0:	31bfff04 	addi	r6,r6,-4
 82094a4:	d9800315 	stw	r6,12(sp)
 82094a8:	0023883a 	mov	r17,zero
 82094ac:	d9800317 	ldw	r6,12(sp)
 82094b0:	008000c4 	movi	r2,3
 82094b4:	30836726 	beq	r6,r2,820a254 <_dtoa_r+0x109c>
 82094b8:	1183410e 	bge	r2,r6,820a1c0 <_dtoa_r+0x1008>
 82094bc:	d9c00317 	ldw	r7,12(sp)
 82094c0:	00800104 	movi	r2,4
 82094c4:	38827c26 	beq	r7,r2,8209eb8 <_dtoa_r+0xd00>
 82094c8:	00800144 	movi	r2,5
 82094cc:	3884c41e 	bne	r7,r2,820a7e0 <_dtoa_r+0x1628>
 82094d0:	00800044 	movi	r2,1
 82094d4:	d8800b15 	stw	r2,44(sp)
 82094d8:	d8c00517 	ldw	r3,20(sp)
 82094dc:	d9002217 	ldw	r4,136(sp)
 82094e0:	1907883a 	add	r3,r3,r4
 82094e4:	19800044 	addi	r6,r3,1
 82094e8:	d8c00c15 	stw	r3,48(sp)
 82094ec:	d9800615 	stw	r6,24(sp)
 82094f0:	0183a40e 	bge	zero,r6,820a384 <_dtoa_r+0x11cc>
 82094f4:	d9800617 	ldw	r6,24(sp)
 82094f8:	3021883a 	mov	r16,r6
 82094fc:	e0001115 	stw	zero,68(fp)
 8209500:	008005c4 	movi	r2,23
 8209504:	1184c92e 	bgeu	r2,r6,820a82c <_dtoa_r+0x1674>
 8209508:	00c00044 	movi	r3,1
 820950c:	00800104 	movi	r2,4
 8209510:	1085883a 	add	r2,r2,r2
 8209514:	11000504 	addi	r4,r2,20
 8209518:	180b883a 	mov	r5,r3
 820951c:	18c00044 	addi	r3,r3,1
 8209520:	313ffb2e 	bgeu	r6,r4,8209510 <_dtoa_r+0x358>
 8209524:	e1401115 	stw	r5,68(fp)
 8209528:	e009883a 	mov	r4,fp
 820952c:	820c6580 	call	820c658 <_Balloc>
 8209530:	d8800715 	stw	r2,28(sp)
 8209534:	e0801015 	stw	r2,64(fp)
 8209538:	00800384 	movi	r2,14
 820953c:	1400f736 	bltu	r2,r16,820991c <_dtoa_r+0x764>
 8209540:	8800f626 	beq	r17,zero,820991c <_dtoa_r+0x764>
 8209544:	d9c00517 	ldw	r7,20(sp)
 8209548:	01c39a0e 	bge	zero,r7,820a3b4 <_dtoa_r+0x11fc>
 820954c:	388003cc 	andi	r2,r7,15
 8209550:	100490fa 	slli	r2,r2,3
 8209554:	382bd13a 	srai	r21,r7,4
 8209558:	00c20974 	movhi	r3,2085
 820955c:	18f6f904 	addi	r3,r3,-9244
 8209560:	1885883a 	add	r2,r3,r2
 8209564:	a8c0040c 	andi	r3,r21,16
 8209568:	12400017 	ldw	r9,0(r2)
 820956c:	12000117 	ldw	r8,4(r2)
 8209570:	18037926 	beq	r3,zero,820a358 <_dtoa_r+0x11a0>
 8209574:	00820974 	movhi	r2,2085
 8209578:	10b6ef04 	addi	r2,r2,-9284
 820957c:	11800817 	ldw	r6,32(r2)
 8209580:	11c00917 	ldw	r7,36(r2)
 8209584:	9009883a 	mov	r4,r18
 8209588:	980b883a 	mov	r5,r19
 820958c:	da001715 	stw	r8,92(sp)
 8209590:	da401615 	stw	r9,88(sp)
 8209594:	82126140 	call	8212614 <__divdf3>
 8209598:	da001717 	ldw	r8,92(sp)
 820959c:	da401617 	ldw	r9,88(sp)
 82095a0:	ad4003cc 	andi	r21,r21,15
 82095a4:	040000c4 	movi	r16,3
 82095a8:	1023883a 	mov	r17,r2
 82095ac:	1829883a 	mov	r20,r3
 82095b0:	a8001126 	beq	r21,zero,82095f8 <_dtoa_r+0x440>
 82095b4:	05c20974 	movhi	r23,2085
 82095b8:	bdf6ef04 	addi	r23,r23,-9284
 82095bc:	4805883a 	mov	r2,r9
 82095c0:	4007883a 	mov	r3,r8
 82095c4:	a980004c 	andi	r6,r21,1
 82095c8:	1009883a 	mov	r4,r2
 82095cc:	a82bd07a 	srai	r21,r21,1
 82095d0:	180b883a 	mov	r5,r3
 82095d4:	30000426 	beq	r6,zero,82095e8 <_dtoa_r+0x430>
 82095d8:	b9800017 	ldw	r6,0(r23)
 82095dc:	b9c00117 	ldw	r7,4(r23)
 82095e0:	84000044 	addi	r16,r16,1
 82095e4:	82131540 	call	8213154 <__muldf3>
 82095e8:	bdc00204 	addi	r23,r23,8
 82095ec:	a83ff51e 	bne	r21,zero,82095c4 <_dtoa_r+0x40c>
 82095f0:	1013883a 	mov	r9,r2
 82095f4:	1811883a 	mov	r8,r3
 82095f8:	480d883a 	mov	r6,r9
 82095fc:	400f883a 	mov	r7,r8
 8209600:	8809883a 	mov	r4,r17
 8209604:	a00b883a 	mov	r5,r20
 8209608:	82126140 	call	8212614 <__divdf3>
 820960c:	d8800f15 	stw	r2,60(sp)
 8209610:	d8c01015 	stw	r3,64(sp)
 8209614:	d8c00e17 	ldw	r3,56(sp)
 8209618:	18000626 	beq	r3,zero,8209634 <_dtoa_r+0x47c>
 820961c:	d9000f17 	ldw	r4,60(sp)
 8209620:	d9401017 	ldw	r5,64(sp)
 8209624:	000d883a 	mov	r6,zero
 8209628:	01cffc34 	movhi	r7,16368
 820962c:	82130600 	call	8213060 <__ledf2>
 8209630:	10040b16 	blt	r2,zero,820a660 <_dtoa_r+0x14a8>
 8209634:	8009883a 	mov	r4,r16
 8209638:	82141e80 	call	82141e8 <__floatsidf>
 820963c:	d9800f17 	ldw	r6,60(sp)
 8209640:	d9c01017 	ldw	r7,64(sp)
 8209644:	1009883a 	mov	r4,r2
 8209648:	180b883a 	mov	r5,r3
 820964c:	82131540 	call	8213154 <__muldf3>
 8209650:	000d883a 	mov	r6,zero
 8209654:	01d00734 	movhi	r7,16412
 8209658:	1009883a 	mov	r4,r2
 820965c:	180b883a 	mov	r5,r3
 8209660:	8211d680 	call	8211d68 <__adddf3>
 8209664:	1021883a 	mov	r16,r2
 8209668:	d8800617 	ldw	r2,24(sp)
 820966c:	047f3034 	movhi	r17,64704
 8209670:	1c63883a 	add	r17,r3,r17
 8209674:	10031826 	beq	r2,zero,820a2d8 <_dtoa_r+0x1120>
 8209678:	d8c00517 	ldw	r3,20(sp)
 820967c:	db000617 	ldw	r12,24(sp)
 8209680:	d8c01315 	stw	r3,76(sp)
 8209684:	d9000b17 	ldw	r4,44(sp)
 8209688:	20038f26 	beq	r4,zero,820a4c8 <_dtoa_r+0x1310>
 820968c:	60bfffc4 	addi	r2,r12,-1
 8209690:	100490fa 	slli	r2,r2,3
 8209694:	00c20974 	movhi	r3,2085
 8209698:	18f6f904 	addi	r3,r3,-9244
 820969c:	1885883a 	add	r2,r3,r2
 82096a0:	11800017 	ldw	r6,0(r2)
 82096a4:	11c00117 	ldw	r7,4(r2)
 82096a8:	d8800717 	ldw	r2,28(sp)
 82096ac:	0009883a 	mov	r4,zero
 82096b0:	014ff834 	movhi	r5,16352
 82096b4:	db001615 	stw	r12,88(sp)
 82096b8:	15c00044 	addi	r23,r2,1
 82096bc:	82126140 	call	8212614 <__divdf3>
 82096c0:	800d883a 	mov	r6,r16
 82096c4:	880f883a 	mov	r7,r17
 82096c8:	1009883a 	mov	r4,r2
 82096cc:	180b883a 	mov	r5,r3
 82096d0:	821386c0 	call	821386c <__subdf3>
 82096d4:	d9401017 	ldw	r5,64(sp)
 82096d8:	d9000f17 	ldw	r4,60(sp)
 82096dc:	102b883a 	mov	r21,r2
 82096e0:	d8c01215 	stw	r3,72(sp)
 82096e4:	82141680 	call	8214168 <__fixdfsi>
 82096e8:	1009883a 	mov	r4,r2
 82096ec:	1029883a 	mov	r20,r2
 82096f0:	82141e80 	call	82141e8 <__floatsidf>
 82096f4:	d9000f17 	ldw	r4,60(sp)
 82096f8:	d9401017 	ldw	r5,64(sp)
 82096fc:	100d883a 	mov	r6,r2
 8209700:	180f883a 	mov	r7,r3
 8209704:	821386c0 	call	821386c <__subdf3>
 8209708:	1823883a 	mov	r17,r3
 820970c:	d8c00717 	ldw	r3,28(sp)
 8209710:	d9401217 	ldw	r5,72(sp)
 8209714:	a2000c04 	addi	r8,r20,48
 8209718:	1021883a 	mov	r16,r2
 820971c:	1a000005 	stb	r8,0(r3)
 8209720:	800d883a 	mov	r6,r16
 8209724:	880f883a 	mov	r7,r17
 8209728:	a809883a 	mov	r4,r21
 820972c:	4029883a 	mov	r20,r8
 8209730:	8212f840 	call	8212f84 <__gedf2>
 8209734:	00841d16 	blt	zero,r2,820a7ac <_dtoa_r+0x15f4>
 8209738:	800d883a 	mov	r6,r16
 820973c:	880f883a 	mov	r7,r17
 8209740:	0009883a 	mov	r4,zero
 8209744:	014ffc34 	movhi	r5,16368
 8209748:	821386c0 	call	821386c <__subdf3>
 820974c:	d9401217 	ldw	r5,72(sp)
 8209750:	100d883a 	mov	r6,r2
 8209754:	180f883a 	mov	r7,r3
 8209758:	a809883a 	mov	r4,r21
 820975c:	8212f840 	call	8212f84 <__gedf2>
 8209760:	db001617 	ldw	r12,88(sp)
 8209764:	00840e16 	blt	zero,r2,820a7a0 <_dtoa_r+0x15e8>
 8209768:	00800044 	movi	r2,1
 820976c:	13006b0e 	bge	r2,r12,820991c <_dtoa_r+0x764>
 8209770:	d9000717 	ldw	r4,28(sp)
 8209774:	dd800f15 	stw	r22,60(sp)
 8209778:	dcc01015 	stw	r19,64(sp)
 820977c:	2319883a 	add	r12,r4,r12
 8209780:	dcc01217 	ldw	r19,72(sp)
 8209784:	602d883a 	mov	r22,r12
 8209788:	dc801215 	stw	r18,72(sp)
 820978c:	b825883a 	mov	r18,r23
 8209790:	00000906 	br	82097b8 <_dtoa_r+0x600>
 8209794:	821386c0 	call	821386c <__subdf3>
 8209798:	a80d883a 	mov	r6,r21
 820979c:	980f883a 	mov	r7,r19
 82097a0:	1009883a 	mov	r4,r2
 82097a4:	180b883a 	mov	r5,r3
 82097a8:	82130600 	call	8213060 <__ledf2>
 82097ac:	1003e816 	blt	r2,zero,820a750 <_dtoa_r+0x1598>
 82097b0:	b825883a 	mov	r18,r23
 82097b4:	bd83e926 	beq	r23,r22,820a75c <_dtoa_r+0x15a4>
 82097b8:	a809883a 	mov	r4,r21
 82097bc:	980b883a 	mov	r5,r19
 82097c0:	000d883a 	mov	r6,zero
 82097c4:	01d00934 	movhi	r7,16420
 82097c8:	82131540 	call	8213154 <__muldf3>
 82097cc:	000d883a 	mov	r6,zero
 82097d0:	01d00934 	movhi	r7,16420
 82097d4:	8009883a 	mov	r4,r16
 82097d8:	880b883a 	mov	r5,r17
 82097dc:	102b883a 	mov	r21,r2
 82097e0:	1827883a 	mov	r19,r3
 82097e4:	82131540 	call	8213154 <__muldf3>
 82097e8:	180b883a 	mov	r5,r3
 82097ec:	1009883a 	mov	r4,r2
 82097f0:	1821883a 	mov	r16,r3
 82097f4:	1023883a 	mov	r17,r2
 82097f8:	82141680 	call	8214168 <__fixdfsi>
 82097fc:	1009883a 	mov	r4,r2
 8209800:	1029883a 	mov	r20,r2
 8209804:	82141e80 	call	82141e8 <__floatsidf>
 8209808:	8809883a 	mov	r4,r17
 820980c:	800b883a 	mov	r5,r16
 8209810:	100d883a 	mov	r6,r2
 8209814:	180f883a 	mov	r7,r3
 8209818:	821386c0 	call	821386c <__subdf3>
 820981c:	a5000c04 	addi	r20,r20,48
 8209820:	a80d883a 	mov	r6,r21
 8209824:	980f883a 	mov	r7,r19
 8209828:	1009883a 	mov	r4,r2
 820982c:	180b883a 	mov	r5,r3
 8209830:	95000005 	stb	r20,0(r18)
 8209834:	1021883a 	mov	r16,r2
 8209838:	1823883a 	mov	r17,r3
 820983c:	82130600 	call	8213060 <__ledf2>
 8209840:	bdc00044 	addi	r23,r23,1
 8209844:	800d883a 	mov	r6,r16
 8209848:	880f883a 	mov	r7,r17
 820984c:	0009883a 	mov	r4,zero
 8209850:	014ffc34 	movhi	r5,16368
 8209854:	103fcf0e 	bge	r2,zero,8209794 <_dtoa_r+0x5dc>
 8209858:	d8c01317 	ldw	r3,76(sp)
 820985c:	d8c00515 	stw	r3,20(sp)
 8209860:	d9400917 	ldw	r5,36(sp)
 8209864:	e009883a 	mov	r4,fp
 8209868:	820c7000 	call	820c700 <_Bfree>
 820986c:	d9000517 	ldw	r4,20(sp)
 8209870:	d9802317 	ldw	r6,140(sp)
 8209874:	d9c02517 	ldw	r7,148(sp)
 8209878:	b8000005 	stb	zero,0(r23)
 820987c:	20800044 	addi	r2,r4,1
 8209880:	30800015 	stw	r2,0(r6)
 8209884:	3802aa26 	beq	r7,zero,820a330 <_dtoa_r+0x1178>
 8209888:	3dc00015 	stw	r23,0(r7)
 820988c:	d8800717 	ldw	r2,28(sp)
 8209890:	003e7906 	br	8209278 <_dtoa_r+0xc0>
 8209894:	00800434 	movhi	r2,16
 8209898:	10bfffc4 	addi	r2,r2,-1
 820989c:	88a2703a 	and	r17,r17,r2
 82098a0:	883e851e 	bne	r17,zero,82092b8 <_dtoa_r+0x100>
 82098a4:	00820974 	movhi	r2,2085
 82098a8:	10b6db04 	addi	r2,r2,-9364
 82098ac:	003e8406 	br	82092c0 <_dtoa_r+0x108>
 82098b0:	10c00204 	addi	r3,r2,8
 82098b4:	003e8706 	br	82092d4 <_dtoa_r+0x11c>
 82098b8:	01400434 	movhi	r5,16
 82098bc:	297fffc4 	addi	r5,r5,-1
 82098c0:	994a703a 	and	r5,r19,r5
 82098c4:	9009883a 	mov	r4,r18
 82098c8:	843f0044 	addi	r16,r16,-1023
 82098cc:	294ffc34 	orhi	r5,r5,16368
 82098d0:	dd800217 	ldw	r22,8(sp)
 82098d4:	d8001115 	stw	zero,68(sp)
 82098d8:	003ea506 	br	8209370 <_dtoa_r+0x1b8>
 82098dc:	00820974 	movhi	r2,2085
 82098e0:	10b6ca04 	addi	r2,r2,-9432
 82098e4:	003e6406 	br	8209278 <_dtoa_r+0xc0>
 82098e8:	e0001115 	stw	zero,68(fp)
 82098ec:	000b883a 	mov	r5,zero
 82098f0:	e009883a 	mov	r4,fp
 82098f4:	820c6580 	call	820c658 <_Balloc>
 82098f8:	01bfffc4 	movi	r6,-1
 82098fc:	01c00044 	movi	r7,1
 8209900:	d8800715 	stw	r2,28(sp)
 8209904:	d9800c15 	stw	r6,48(sp)
 8209908:	e0801015 	stw	r2,64(fp)
 820990c:	d8000315 	stw	zero,12(sp)
 8209910:	d9c00b15 	stw	r7,44(sp)
 8209914:	d9800615 	stw	r6,24(sp)
 8209918:	d8002215 	stw	zero,136(sp)
 820991c:	d8800117 	ldw	r2,4(sp)
 8209920:	10008916 	blt	r2,zero,8209b48 <_dtoa_r+0x990>
 8209924:	d9000517 	ldw	r4,20(sp)
 8209928:	00c00384 	movi	r3,14
 820992c:	19008616 	blt	r3,r4,8209b48 <_dtoa_r+0x990>
 8209930:	200490fa 	slli	r2,r4,3
 8209934:	00c20974 	movhi	r3,2085
 8209938:	d9802217 	ldw	r6,136(sp)
 820993c:	18f6f904 	addi	r3,r3,-9244
 8209940:	1885883a 	add	r2,r3,r2
 8209944:	14000017 	ldw	r16,0(r2)
 8209948:	14400117 	ldw	r17,4(r2)
 820994c:	30016316 	blt	r6,zero,8209edc <_dtoa_r+0xd24>
 8209950:	800d883a 	mov	r6,r16
 8209954:	880f883a 	mov	r7,r17
 8209958:	9009883a 	mov	r4,r18
 820995c:	980b883a 	mov	r5,r19
 8209960:	82126140 	call	8212614 <__divdf3>
 8209964:	180b883a 	mov	r5,r3
 8209968:	1009883a 	mov	r4,r2
 820996c:	82141680 	call	8214168 <__fixdfsi>
 8209970:	1009883a 	mov	r4,r2
 8209974:	102b883a 	mov	r21,r2
 8209978:	82141e80 	call	82141e8 <__floatsidf>
 820997c:	800d883a 	mov	r6,r16
 8209980:	880f883a 	mov	r7,r17
 8209984:	1009883a 	mov	r4,r2
 8209988:	180b883a 	mov	r5,r3
 820998c:	82131540 	call	8213154 <__muldf3>
 8209990:	100d883a 	mov	r6,r2
 8209994:	180f883a 	mov	r7,r3
 8209998:	9009883a 	mov	r4,r18
 820999c:	980b883a 	mov	r5,r19
 82099a0:	821386c0 	call	821386c <__subdf3>
 82099a4:	d9c00717 	ldw	r7,28(sp)
 82099a8:	1009883a 	mov	r4,r2
 82099ac:	a8800c04 	addi	r2,r21,48
 82099b0:	38800005 	stb	r2,0(r7)
 82099b4:	3dc00044 	addi	r23,r7,1
 82099b8:	d9c00617 	ldw	r7,24(sp)
 82099bc:	01800044 	movi	r6,1
 82099c0:	180b883a 	mov	r5,r3
 82099c4:	2005883a 	mov	r2,r4
 82099c8:	39803826 	beq	r7,r6,8209aac <_dtoa_r+0x8f4>
 82099cc:	000d883a 	mov	r6,zero
 82099d0:	01d00934 	movhi	r7,16420
 82099d4:	82131540 	call	8213154 <__muldf3>
 82099d8:	000d883a 	mov	r6,zero
 82099dc:	000f883a 	mov	r7,zero
 82099e0:	1009883a 	mov	r4,r2
 82099e4:	180b883a 	mov	r5,r3
 82099e8:	1025883a 	mov	r18,r2
 82099ec:	1827883a 	mov	r19,r3
 82099f0:	8212efc0 	call	8212efc <__eqdf2>
 82099f4:	103f9a26 	beq	r2,zero,8209860 <_dtoa_r+0x6a8>
 82099f8:	d9c00617 	ldw	r7,24(sp)
 82099fc:	d8c00717 	ldw	r3,28(sp)
 8209a00:	b829883a 	mov	r20,r23
 8209a04:	38bfffc4 	addi	r2,r7,-1
 8209a08:	18ad883a 	add	r22,r3,r2
 8209a0c:	00000a06 	br	8209a38 <_dtoa_r+0x880>
 8209a10:	82131540 	call	8213154 <__muldf3>
 8209a14:	000d883a 	mov	r6,zero
 8209a18:	000f883a 	mov	r7,zero
 8209a1c:	1009883a 	mov	r4,r2
 8209a20:	180b883a 	mov	r5,r3
 8209a24:	1025883a 	mov	r18,r2
 8209a28:	1827883a 	mov	r19,r3
 8209a2c:	b829883a 	mov	r20,r23
 8209a30:	8212efc0 	call	8212efc <__eqdf2>
 8209a34:	103f8a26 	beq	r2,zero,8209860 <_dtoa_r+0x6a8>
 8209a38:	800d883a 	mov	r6,r16
 8209a3c:	880f883a 	mov	r7,r17
 8209a40:	9009883a 	mov	r4,r18
 8209a44:	980b883a 	mov	r5,r19
 8209a48:	82126140 	call	8212614 <__divdf3>
 8209a4c:	180b883a 	mov	r5,r3
 8209a50:	1009883a 	mov	r4,r2
 8209a54:	82141680 	call	8214168 <__fixdfsi>
 8209a58:	1009883a 	mov	r4,r2
 8209a5c:	102b883a 	mov	r21,r2
 8209a60:	82141e80 	call	82141e8 <__floatsidf>
 8209a64:	800d883a 	mov	r6,r16
 8209a68:	880f883a 	mov	r7,r17
 8209a6c:	1009883a 	mov	r4,r2
 8209a70:	180b883a 	mov	r5,r3
 8209a74:	82131540 	call	8213154 <__muldf3>
 8209a78:	100d883a 	mov	r6,r2
 8209a7c:	180f883a 	mov	r7,r3
 8209a80:	9009883a 	mov	r4,r18
 8209a84:	980b883a 	mov	r5,r19
 8209a88:	821386c0 	call	821386c <__subdf3>
 8209a8c:	aa000c04 	addi	r8,r21,48
 8209a90:	a2000005 	stb	r8,0(r20)
 8209a94:	000d883a 	mov	r6,zero
 8209a98:	01d00934 	movhi	r7,16420
 8209a9c:	1009883a 	mov	r4,r2
 8209aa0:	180b883a 	mov	r5,r3
 8209aa4:	a5c00044 	addi	r23,r20,1
 8209aa8:	b53fd91e 	bne	r22,r20,8209a10 <_dtoa_r+0x858>
 8209aac:	100d883a 	mov	r6,r2
 8209ab0:	180f883a 	mov	r7,r3
 8209ab4:	1009883a 	mov	r4,r2
 8209ab8:	180b883a 	mov	r5,r3
 8209abc:	8211d680 	call	8211d68 <__adddf3>
 8209ac0:	100d883a 	mov	r6,r2
 8209ac4:	180f883a 	mov	r7,r3
 8209ac8:	8009883a 	mov	r4,r16
 8209acc:	880b883a 	mov	r5,r17
 8209ad0:	1027883a 	mov	r19,r2
 8209ad4:	1825883a 	mov	r18,r3
 8209ad8:	82130600 	call	8213060 <__ledf2>
 8209adc:	10000816 	blt	r2,zero,8209b00 <_dtoa_r+0x948>
 8209ae0:	980d883a 	mov	r6,r19
 8209ae4:	900f883a 	mov	r7,r18
 8209ae8:	8009883a 	mov	r4,r16
 8209aec:	880b883a 	mov	r5,r17
 8209af0:	8212efc0 	call	8212efc <__eqdf2>
 8209af4:	103f5a1e 	bne	r2,zero,8209860 <_dtoa_r+0x6a8>
 8209af8:	ad40004c 	andi	r21,r21,1
 8209afc:	a83f5826 	beq	r21,zero,8209860 <_dtoa_r+0x6a8>
 8209b00:	bd3fffc3 	ldbu	r20,-1(r23)
 8209b04:	b8bfffc4 	addi	r2,r23,-1
 8209b08:	1007883a 	mov	r3,r2
 8209b0c:	01400e44 	movi	r5,57
 8209b10:	d9800717 	ldw	r6,28(sp)
 8209b14:	00000506 	br	8209b2c <_dtoa_r+0x974>
 8209b18:	18ffffc4 	addi	r3,r3,-1
 8209b1c:	11824726 	beq	r2,r6,820a43c <_dtoa_r+0x1284>
 8209b20:	1d000003 	ldbu	r20,0(r3)
 8209b24:	102f883a 	mov	r23,r2
 8209b28:	10bfffc4 	addi	r2,r2,-1
 8209b2c:	a1003fcc 	andi	r4,r20,255
 8209b30:	2100201c 	xori	r4,r4,128
 8209b34:	213fe004 	addi	r4,r4,-128
 8209b38:	217ff726 	beq	r4,r5,8209b18 <_dtoa_r+0x960>
 8209b3c:	a2000044 	addi	r8,r20,1
 8209b40:	12000005 	stb	r8,0(r2)
 8209b44:	003f4606 	br	8209860 <_dtoa_r+0x6a8>
 8209b48:	d9000b17 	ldw	r4,44(sp)
 8209b4c:	2000c826 	beq	r4,zero,8209e70 <_dtoa_r+0xcb8>
 8209b50:	d9800317 	ldw	r6,12(sp)
 8209b54:	00c00044 	movi	r3,1
 8209b58:	1980f90e 	bge	r3,r6,8209f40 <_dtoa_r+0xd88>
 8209b5c:	d8800617 	ldw	r2,24(sp)
 8209b60:	d8c00a17 	ldw	r3,40(sp)
 8209b64:	157fffc4 	addi	r21,r2,-1
 8209b68:	1d41f316 	blt	r3,r21,820a338 <_dtoa_r+0x1180>
 8209b6c:	1d6bc83a 	sub	r21,r3,r21
 8209b70:	d9c00617 	ldw	r7,24(sp)
 8209b74:	3802aa16 	blt	r7,zero,820a620 <_dtoa_r+0x1468>
 8209b78:	dd000817 	ldw	r20,32(sp)
 8209b7c:	d8800617 	ldw	r2,24(sp)
 8209b80:	d8c00817 	ldw	r3,32(sp)
 8209b84:	01400044 	movi	r5,1
 8209b88:	e009883a 	mov	r4,fp
 8209b8c:	1887883a 	add	r3,r3,r2
 8209b90:	d8c00815 	stw	r3,32(sp)
 8209b94:	b0ad883a 	add	r22,r22,r2
 8209b98:	820ca640 	call	820ca64 <__i2b>
 8209b9c:	1023883a 	mov	r17,r2
 8209ba0:	a0000826 	beq	r20,zero,8209bc4 <_dtoa_r+0xa0c>
 8209ba4:	0580070e 	bge	zero,r22,8209bc4 <_dtoa_r+0xa0c>
 8209ba8:	a005883a 	mov	r2,r20
 8209bac:	b500b916 	blt	r22,r20,8209e94 <_dtoa_r+0xcdc>
 8209bb0:	d9000817 	ldw	r4,32(sp)
 8209bb4:	a0a9c83a 	sub	r20,r20,r2
 8209bb8:	b0adc83a 	sub	r22,r22,r2
 8209bbc:	2089c83a 	sub	r4,r4,r2
 8209bc0:	d9000815 	stw	r4,32(sp)
 8209bc4:	d9800a17 	ldw	r6,40(sp)
 8209bc8:	0181810e 	bge	zero,r6,820a1d0 <_dtoa_r+0x1018>
 8209bcc:	d9c00b17 	ldw	r7,44(sp)
 8209bd0:	3800b326 	beq	r7,zero,8209ea0 <_dtoa_r+0xce8>
 8209bd4:	a800b226 	beq	r21,zero,8209ea0 <_dtoa_r+0xce8>
 8209bd8:	880b883a 	mov	r5,r17
 8209bdc:	a80d883a 	mov	r6,r21
 8209be0:	e009883a 	mov	r4,fp
 8209be4:	820cc980 	call	820cc98 <__pow5mult>
 8209be8:	d9800917 	ldw	r6,36(sp)
 8209bec:	100b883a 	mov	r5,r2
 8209bf0:	e009883a 	mov	r4,fp
 8209bf4:	1023883a 	mov	r17,r2
 8209bf8:	820caa00 	call	820caa0 <__multiply>
 8209bfc:	1021883a 	mov	r16,r2
 8209c00:	d8800a17 	ldw	r2,40(sp)
 8209c04:	d9400917 	ldw	r5,36(sp)
 8209c08:	e009883a 	mov	r4,fp
 8209c0c:	1545c83a 	sub	r2,r2,r21
 8209c10:	d8800a15 	stw	r2,40(sp)
 8209c14:	820c7000 	call	820c700 <_Bfree>
 8209c18:	d8c00a17 	ldw	r3,40(sp)
 8209c1c:	18009f1e 	bne	r3,zero,8209e9c <_dtoa_r+0xce4>
 8209c20:	05c00044 	movi	r23,1
 8209c24:	e009883a 	mov	r4,fp
 8209c28:	b80b883a 	mov	r5,r23
 8209c2c:	820ca640 	call	820ca64 <__i2b>
 8209c30:	d9000d17 	ldw	r4,52(sp)
 8209c34:	102b883a 	mov	r21,r2
 8209c38:	2000ce26 	beq	r4,zero,8209f74 <_dtoa_r+0xdbc>
 8209c3c:	200d883a 	mov	r6,r4
 8209c40:	100b883a 	mov	r5,r2
 8209c44:	e009883a 	mov	r4,fp
 8209c48:	820cc980 	call	820cc98 <__pow5mult>
 8209c4c:	d9800317 	ldw	r6,12(sp)
 8209c50:	102b883a 	mov	r21,r2
 8209c54:	b981810e 	bge	r23,r6,820a25c <_dtoa_r+0x10a4>
 8209c58:	0027883a 	mov	r19,zero
 8209c5c:	a8800417 	ldw	r2,16(r21)
 8209c60:	05c00804 	movi	r23,32
 8209c64:	10800104 	addi	r2,r2,4
 8209c68:	1085883a 	add	r2,r2,r2
 8209c6c:	1085883a 	add	r2,r2,r2
 8209c70:	a885883a 	add	r2,r21,r2
 8209c74:	11000017 	ldw	r4,0(r2)
 8209c78:	820c94c0 	call	820c94c <__hi0bits>
 8209c7c:	b885c83a 	sub	r2,r23,r2
 8209c80:	1585883a 	add	r2,r2,r22
 8209c84:	108007cc 	andi	r2,r2,31
 8209c88:	1000b326 	beq	r2,zero,8209f58 <_dtoa_r+0xda0>
 8209c8c:	00c00804 	movi	r3,32
 8209c90:	1887c83a 	sub	r3,r3,r2
 8209c94:	01000104 	movi	r4,4
 8209c98:	20c2cd0e 	bge	r4,r3,820a7d0 <_dtoa_r+0x1618>
 8209c9c:	00c00704 	movi	r3,28
 8209ca0:	1885c83a 	sub	r2,r3,r2
 8209ca4:	d8c00817 	ldw	r3,32(sp)
 8209ca8:	a0a9883a 	add	r20,r20,r2
 8209cac:	b0ad883a 	add	r22,r22,r2
 8209cb0:	1887883a 	add	r3,r3,r2
 8209cb4:	d8c00815 	stw	r3,32(sp)
 8209cb8:	d9800817 	ldw	r6,32(sp)
 8209cbc:	0180040e 	bge	zero,r6,8209cd0 <_dtoa_r+0xb18>
 8209cc0:	800b883a 	mov	r5,r16
 8209cc4:	e009883a 	mov	r4,fp
 8209cc8:	820cdd80 	call	820cdd8 <__lshift>
 8209ccc:	1021883a 	mov	r16,r2
 8209cd0:	0580050e 	bge	zero,r22,8209ce8 <_dtoa_r+0xb30>
 8209cd4:	a80b883a 	mov	r5,r21
 8209cd8:	b00d883a 	mov	r6,r22
 8209cdc:	e009883a 	mov	r4,fp
 8209ce0:	820cdd80 	call	820cdd8 <__lshift>
 8209ce4:	102b883a 	mov	r21,r2
 8209ce8:	d9c00e17 	ldw	r7,56(sp)
 8209cec:	3801211e 	bne	r7,zero,820a174 <_dtoa_r+0xfbc>
 8209cf0:	d9800617 	ldw	r6,24(sp)
 8209cf4:	0181380e 	bge	zero,r6,820a1d8 <_dtoa_r+0x1020>
 8209cf8:	d8c00b17 	ldw	r3,44(sp)
 8209cfc:	1800ab1e 	bne	r3,zero,8209fac <_dtoa_r+0xdf4>
 8209d00:	dc800717 	ldw	r18,28(sp)
 8209d04:	dcc00617 	ldw	r19,24(sp)
 8209d08:	9029883a 	mov	r20,r18
 8209d0c:	00000206 	br	8209d18 <_dtoa_r+0xb60>
 8209d10:	820c7280 	call	820c728 <__multadd>
 8209d14:	1021883a 	mov	r16,r2
 8209d18:	a80b883a 	mov	r5,r21
 8209d1c:	8009883a 	mov	r4,r16
 8209d20:	8208fb80 	call	8208fb8 <quorem>
 8209d24:	10800c04 	addi	r2,r2,48
 8209d28:	90800005 	stb	r2,0(r18)
 8209d2c:	94800044 	addi	r18,r18,1
 8209d30:	9507c83a 	sub	r3,r18,r20
 8209d34:	000f883a 	mov	r7,zero
 8209d38:	01800284 	movi	r6,10
 8209d3c:	800b883a 	mov	r5,r16
 8209d40:	e009883a 	mov	r4,fp
 8209d44:	1cfff216 	blt	r3,r19,8209d10 <_dtoa_r+0xb58>
 8209d48:	1011883a 	mov	r8,r2
 8209d4c:	d8800617 	ldw	r2,24(sp)
 8209d50:	0082370e 	bge	zero,r2,820a630 <_dtoa_r+0x1478>
 8209d54:	d9000717 	ldw	r4,28(sp)
 8209d58:	0025883a 	mov	r18,zero
 8209d5c:	20af883a 	add	r23,r4,r2
 8209d60:	01800044 	movi	r6,1
 8209d64:	800b883a 	mov	r5,r16
 8209d68:	e009883a 	mov	r4,fp
 8209d6c:	da001715 	stw	r8,92(sp)
 8209d70:	820cdd80 	call	820cdd8 <__lshift>
 8209d74:	a80b883a 	mov	r5,r21
 8209d78:	1009883a 	mov	r4,r2
 8209d7c:	d8800915 	stw	r2,36(sp)
 8209d80:	820cf200 	call	820cf20 <__mcmp>
 8209d84:	da001717 	ldw	r8,92(sp)
 8209d88:	0081800e 	bge	zero,r2,820a38c <_dtoa_r+0x11d4>
 8209d8c:	b93fffc3 	ldbu	r4,-1(r23)
 8209d90:	b8bfffc4 	addi	r2,r23,-1
 8209d94:	1007883a 	mov	r3,r2
 8209d98:	01800e44 	movi	r6,57
 8209d9c:	d9c00717 	ldw	r7,28(sp)
 8209da0:	00000506 	br	8209db8 <_dtoa_r+0xc00>
 8209da4:	18ffffc4 	addi	r3,r3,-1
 8209da8:	11c12326 	beq	r2,r7,820a238 <_dtoa_r+0x1080>
 8209dac:	19000003 	ldbu	r4,0(r3)
 8209db0:	102f883a 	mov	r23,r2
 8209db4:	10bfffc4 	addi	r2,r2,-1
 8209db8:	21403fcc 	andi	r5,r4,255
 8209dbc:	2940201c 	xori	r5,r5,128
 8209dc0:	297fe004 	addi	r5,r5,-128
 8209dc4:	29bff726 	beq	r5,r6,8209da4 <_dtoa_r+0xbec>
 8209dc8:	21000044 	addi	r4,r4,1
 8209dcc:	11000005 	stb	r4,0(r2)
 8209dd0:	a80b883a 	mov	r5,r21
 8209dd4:	e009883a 	mov	r4,fp
 8209dd8:	820c7000 	call	820c700 <_Bfree>
 8209ddc:	883ea026 	beq	r17,zero,8209860 <_dtoa_r+0x6a8>
 8209de0:	90000426 	beq	r18,zero,8209df4 <_dtoa_r+0xc3c>
 8209de4:	94400326 	beq	r18,r17,8209df4 <_dtoa_r+0xc3c>
 8209de8:	900b883a 	mov	r5,r18
 8209dec:	e009883a 	mov	r4,fp
 8209df0:	820c7000 	call	820c700 <_Bfree>
 8209df4:	880b883a 	mov	r5,r17
 8209df8:	e009883a 	mov	r4,fp
 8209dfc:	820c7000 	call	820c700 <_Bfree>
 8209e00:	003e9706 	br	8209860 <_dtoa_r+0x6a8>
 8209e04:	01800044 	movi	r6,1
 8209e08:	d9800e15 	stw	r6,56(sp)
 8209e0c:	003d9606 	br	8209468 <_dtoa_r+0x2b0>
 8209e10:	d8800817 	ldw	r2,32(sp)
 8209e14:	d8c00517 	ldw	r3,20(sp)
 8209e18:	d8000d15 	stw	zero,52(sp)
 8209e1c:	10c5c83a 	sub	r2,r2,r3
 8209e20:	00c9c83a 	sub	r4,zero,r3
 8209e24:	d8800815 	stw	r2,32(sp)
 8209e28:	d9000a15 	stw	r4,40(sp)
 8209e2c:	003d9706 	br	820948c <_dtoa_r+0x2d4>
 8209e30:	05adc83a 	sub	r22,zero,r22
 8209e34:	dd800815 	stw	r22,32(sp)
 8209e38:	002d883a 	mov	r22,zero
 8209e3c:	003d8e06 	br	8209478 <_dtoa_r+0x2c0>
 8209e40:	d9000517 	ldw	r4,20(sp)
 8209e44:	82141e80 	call	82141e8 <__floatsidf>
 8209e48:	100d883a 	mov	r6,r2
 8209e4c:	180f883a 	mov	r7,r3
 8209e50:	a009883a 	mov	r4,r20
 8209e54:	880b883a 	mov	r5,r17
 8209e58:	8212efc0 	call	8212efc <__eqdf2>
 8209e5c:	103d7126 	beq	r2,zero,8209424 <_dtoa_r+0x26c>
 8209e60:	d9c00517 	ldw	r7,20(sp)
 8209e64:	39ffffc4 	addi	r7,r7,-1
 8209e68:	d9c00515 	stw	r7,20(sp)
 8209e6c:	003d6d06 	br	8209424 <_dtoa_r+0x26c>
 8209e70:	dd400a17 	ldw	r21,40(sp)
 8209e74:	dd000817 	ldw	r20,32(sp)
 8209e78:	0023883a 	mov	r17,zero
 8209e7c:	003f4806 	br	8209ba0 <_dtoa_r+0x9e8>
 8209e80:	10e3c83a 	sub	r17,r2,r3
 8209e84:	9448983a 	sll	r4,r18,r17
 8209e88:	003d3206 	br	8209354 <_dtoa_r+0x19c>
 8209e8c:	d8000e15 	stw	zero,56(sp)
 8209e90:	003d7506 	br	8209468 <_dtoa_r+0x2b0>
 8209e94:	b005883a 	mov	r2,r22
 8209e98:	003f4506 	br	8209bb0 <_dtoa_r+0x9f8>
 8209e9c:	dc000915 	stw	r16,36(sp)
 8209ea0:	d9800a17 	ldw	r6,40(sp)
 8209ea4:	d9400917 	ldw	r5,36(sp)
 8209ea8:	e009883a 	mov	r4,fp
 8209eac:	820cc980 	call	820cc98 <__pow5mult>
 8209eb0:	1021883a 	mov	r16,r2
 8209eb4:	003f5a06 	br	8209c20 <_dtoa_r+0xa68>
 8209eb8:	01c00044 	movi	r7,1
 8209ebc:	d9c00b15 	stw	r7,44(sp)
 8209ec0:	d8802217 	ldw	r2,136(sp)
 8209ec4:	0081280e 	bge	zero,r2,820a368 <_dtoa_r+0x11b0>
 8209ec8:	100d883a 	mov	r6,r2
 8209ecc:	1021883a 	mov	r16,r2
 8209ed0:	d8800c15 	stw	r2,48(sp)
 8209ed4:	d8800615 	stw	r2,24(sp)
 8209ed8:	003d8806 	br	82094fc <_dtoa_r+0x344>
 8209edc:	d8800617 	ldw	r2,24(sp)
 8209ee0:	00be9b16 	blt	zero,r2,8209950 <_dtoa_r+0x798>
 8209ee4:	10010f1e 	bne	r2,zero,820a324 <_dtoa_r+0x116c>
 8209ee8:	880b883a 	mov	r5,r17
 8209eec:	000d883a 	mov	r6,zero
 8209ef0:	01d00534 	movhi	r7,16404
 8209ef4:	8009883a 	mov	r4,r16
 8209ef8:	82131540 	call	8213154 <__muldf3>
 8209efc:	900d883a 	mov	r6,r18
 8209f00:	980f883a 	mov	r7,r19
 8209f04:	1009883a 	mov	r4,r2
 8209f08:	180b883a 	mov	r5,r3
 8209f0c:	8212f840 	call	8212f84 <__gedf2>
 8209f10:	002b883a 	mov	r21,zero
 8209f14:	0023883a 	mov	r17,zero
 8209f18:	1000bf16 	blt	r2,zero,820a218 <_dtoa_r+0x1060>
 8209f1c:	d9802217 	ldw	r6,136(sp)
 8209f20:	ddc00717 	ldw	r23,28(sp)
 8209f24:	018c303a 	nor	r6,zero,r6
 8209f28:	d9800515 	stw	r6,20(sp)
 8209f2c:	a80b883a 	mov	r5,r21
 8209f30:	e009883a 	mov	r4,fp
 8209f34:	820c7000 	call	820c700 <_Bfree>
 8209f38:	883e4926 	beq	r17,zero,8209860 <_dtoa_r+0x6a8>
 8209f3c:	003fad06 	br	8209df4 <_dtoa_r+0xc3c>
 8209f40:	d9c01117 	ldw	r7,68(sp)
 8209f44:	3801bc26 	beq	r7,zero,820a638 <_dtoa_r+0x1480>
 8209f48:	10810cc4 	addi	r2,r2,1075
 8209f4c:	dd400a17 	ldw	r21,40(sp)
 8209f50:	dd000817 	ldw	r20,32(sp)
 8209f54:	003f0a06 	br	8209b80 <_dtoa_r+0x9c8>
 8209f58:	00800704 	movi	r2,28
 8209f5c:	d9000817 	ldw	r4,32(sp)
 8209f60:	a0a9883a 	add	r20,r20,r2
 8209f64:	b0ad883a 	add	r22,r22,r2
 8209f68:	2089883a 	add	r4,r4,r2
 8209f6c:	d9000815 	stw	r4,32(sp)
 8209f70:	003f5106 	br	8209cb8 <_dtoa_r+0xb00>
 8209f74:	d8c00317 	ldw	r3,12(sp)
 8209f78:	b8c1fc0e 	bge	r23,r3,820a76c <_dtoa_r+0x15b4>
 8209f7c:	0027883a 	mov	r19,zero
 8209f80:	b805883a 	mov	r2,r23
 8209f84:	003f3e06 	br	8209c80 <_dtoa_r+0xac8>
 8209f88:	880b883a 	mov	r5,r17
 8209f8c:	e009883a 	mov	r4,fp
 8209f90:	000f883a 	mov	r7,zero
 8209f94:	01800284 	movi	r6,10
 8209f98:	820c7280 	call	820c728 <__multadd>
 8209f9c:	d9000c17 	ldw	r4,48(sp)
 8209fa0:	1023883a 	mov	r17,r2
 8209fa4:	0102040e 	bge	zero,r4,820a7b8 <_dtoa_r+0x1600>
 8209fa8:	d9000615 	stw	r4,24(sp)
 8209fac:	0500050e 	bge	zero,r20,8209fc4 <_dtoa_r+0xe0c>
 8209fb0:	880b883a 	mov	r5,r17
 8209fb4:	a00d883a 	mov	r6,r20
 8209fb8:	e009883a 	mov	r4,fp
 8209fbc:	820cdd80 	call	820cdd8 <__lshift>
 8209fc0:	1023883a 	mov	r17,r2
 8209fc4:	9801241e 	bne	r19,zero,820a458 <_dtoa_r+0x12a0>
 8209fc8:	8829883a 	mov	r20,r17
 8209fcc:	d9000617 	ldw	r4,24(sp)
 8209fd0:	dcc00717 	ldw	r19,28(sp)
 8209fd4:	9480004c 	andi	r18,r18,1
 8209fd8:	20bfffc4 	addi	r2,r4,-1
 8209fdc:	9885883a 	add	r2,r19,r2
 8209fe0:	d8800415 	stw	r2,16(sp)
 8209fe4:	dc800615 	stw	r18,24(sp)
 8209fe8:	a80b883a 	mov	r5,r21
 8209fec:	8009883a 	mov	r4,r16
 8209ff0:	8208fb80 	call	8208fb8 <quorem>
 8209ff4:	880b883a 	mov	r5,r17
 8209ff8:	8009883a 	mov	r4,r16
 8209ffc:	102f883a 	mov	r23,r2
 820a000:	820cf200 	call	820cf20 <__mcmp>
 820a004:	a80b883a 	mov	r5,r21
 820a008:	a00d883a 	mov	r6,r20
 820a00c:	e009883a 	mov	r4,fp
 820a010:	102d883a 	mov	r22,r2
 820a014:	820cf800 	call	820cf80 <__mdiff>
 820a018:	1007883a 	mov	r3,r2
 820a01c:	10800317 	ldw	r2,12(r2)
 820a020:	bc800c04 	addi	r18,r23,48
 820a024:	180b883a 	mov	r5,r3
 820a028:	10004e1e 	bne	r2,zero,820a164 <_dtoa_r+0xfac>
 820a02c:	8009883a 	mov	r4,r16
 820a030:	d8c01615 	stw	r3,88(sp)
 820a034:	820cf200 	call	820cf20 <__mcmp>
 820a038:	d8c01617 	ldw	r3,88(sp)
 820a03c:	e009883a 	mov	r4,fp
 820a040:	d8801615 	stw	r2,88(sp)
 820a044:	180b883a 	mov	r5,r3
 820a048:	820c7000 	call	820c700 <_Bfree>
 820a04c:	d8801617 	ldw	r2,88(sp)
 820a050:	1000041e 	bne	r2,zero,820a064 <_dtoa_r+0xeac>
 820a054:	d9800317 	ldw	r6,12(sp)
 820a058:	3000021e 	bne	r6,zero,820a064 <_dtoa_r+0xeac>
 820a05c:	d8c00617 	ldw	r3,24(sp)
 820a060:	18003726 	beq	r3,zero,820a140 <_dtoa_r+0xf88>
 820a064:	b0002016 	blt	r22,zero,820a0e8 <_dtoa_r+0xf30>
 820a068:	b000041e 	bne	r22,zero,820a07c <_dtoa_r+0xec4>
 820a06c:	d9000317 	ldw	r4,12(sp)
 820a070:	2000021e 	bne	r4,zero,820a07c <_dtoa_r+0xec4>
 820a074:	d8c00617 	ldw	r3,24(sp)
 820a078:	18001b26 	beq	r3,zero,820a0e8 <_dtoa_r+0xf30>
 820a07c:	00810716 	blt	zero,r2,820a49c <_dtoa_r+0x12e4>
 820a080:	d8c00417 	ldw	r3,16(sp)
 820a084:	9d800044 	addi	r22,r19,1
 820a088:	9c800005 	stb	r18,0(r19)
 820a08c:	b02f883a 	mov	r23,r22
 820a090:	98c10626 	beq	r19,r3,820a4ac <_dtoa_r+0x12f4>
 820a094:	800b883a 	mov	r5,r16
 820a098:	000f883a 	mov	r7,zero
 820a09c:	01800284 	movi	r6,10
 820a0a0:	e009883a 	mov	r4,fp
 820a0a4:	820c7280 	call	820c728 <__multadd>
 820a0a8:	1021883a 	mov	r16,r2
 820a0ac:	000f883a 	mov	r7,zero
 820a0b0:	01800284 	movi	r6,10
 820a0b4:	880b883a 	mov	r5,r17
 820a0b8:	e009883a 	mov	r4,fp
 820a0bc:	8d002526 	beq	r17,r20,820a154 <_dtoa_r+0xf9c>
 820a0c0:	820c7280 	call	820c728 <__multadd>
 820a0c4:	a00b883a 	mov	r5,r20
 820a0c8:	000f883a 	mov	r7,zero
 820a0cc:	01800284 	movi	r6,10
 820a0d0:	e009883a 	mov	r4,fp
 820a0d4:	1023883a 	mov	r17,r2
 820a0d8:	820c7280 	call	820c728 <__multadd>
 820a0dc:	1029883a 	mov	r20,r2
 820a0e0:	b027883a 	mov	r19,r22
 820a0e4:	003fc006 	br	8209fe8 <_dtoa_r+0xe30>
 820a0e8:	9011883a 	mov	r8,r18
 820a0ec:	00800e0e 	bge	zero,r2,820a128 <_dtoa_r+0xf70>
 820a0f0:	800b883a 	mov	r5,r16
 820a0f4:	01800044 	movi	r6,1
 820a0f8:	e009883a 	mov	r4,fp
 820a0fc:	da001715 	stw	r8,92(sp)
 820a100:	820cdd80 	call	820cdd8 <__lshift>
 820a104:	a80b883a 	mov	r5,r21
 820a108:	1009883a 	mov	r4,r2
 820a10c:	1021883a 	mov	r16,r2
 820a110:	820cf200 	call	820cf20 <__mcmp>
 820a114:	da001717 	ldw	r8,92(sp)
 820a118:	0081960e 	bge	zero,r2,820a774 <_dtoa_r+0x15bc>
 820a11c:	00800e44 	movi	r2,57
 820a120:	40817026 	beq	r8,r2,820a6e4 <_dtoa_r+0x152c>
 820a124:	ba000c44 	addi	r8,r23,49
 820a128:	8825883a 	mov	r18,r17
 820a12c:	9dc00044 	addi	r23,r19,1
 820a130:	9a000005 	stb	r8,0(r19)
 820a134:	a023883a 	mov	r17,r20
 820a138:	dc000915 	stw	r16,36(sp)
 820a13c:	003f2406 	br	8209dd0 <_dtoa_r+0xc18>
 820a140:	00800e44 	movi	r2,57
 820a144:	9011883a 	mov	r8,r18
 820a148:	90816626 	beq	r18,r2,820a6e4 <_dtoa_r+0x152c>
 820a14c:	05bff516 	blt	zero,r22,820a124 <_dtoa_r+0xf6c>
 820a150:	003ff506 	br	820a128 <_dtoa_r+0xf70>
 820a154:	820c7280 	call	820c728 <__multadd>
 820a158:	1023883a 	mov	r17,r2
 820a15c:	1029883a 	mov	r20,r2
 820a160:	003fdf06 	br	820a0e0 <_dtoa_r+0xf28>
 820a164:	e009883a 	mov	r4,fp
 820a168:	820c7000 	call	820c700 <_Bfree>
 820a16c:	00800044 	movi	r2,1
 820a170:	003fbc06 	br	820a064 <_dtoa_r+0xeac>
 820a174:	a80b883a 	mov	r5,r21
 820a178:	8009883a 	mov	r4,r16
 820a17c:	820cf200 	call	820cf20 <__mcmp>
 820a180:	103edb0e 	bge	r2,zero,8209cf0 <_dtoa_r+0xb38>
 820a184:	800b883a 	mov	r5,r16
 820a188:	000f883a 	mov	r7,zero
 820a18c:	01800284 	movi	r6,10
 820a190:	e009883a 	mov	r4,fp
 820a194:	820c7280 	call	820c728 <__multadd>
 820a198:	1021883a 	mov	r16,r2
 820a19c:	d8800517 	ldw	r2,20(sp)
 820a1a0:	d8c00b17 	ldw	r3,44(sp)
 820a1a4:	10bfffc4 	addi	r2,r2,-1
 820a1a8:	d8800515 	stw	r2,20(sp)
 820a1ac:	183f761e 	bne	r3,zero,8209f88 <_dtoa_r+0xdd0>
 820a1b0:	d9000c17 	ldw	r4,48(sp)
 820a1b4:	0101730e 	bge	zero,r4,820a784 <_dtoa_r+0x15cc>
 820a1b8:	d9000615 	stw	r4,24(sp)
 820a1bc:	003ed006 	br	8209d00 <_dtoa_r+0xb48>
 820a1c0:	00800084 	movi	r2,2
 820a1c4:	3081861e 	bne	r6,r2,820a7e0 <_dtoa_r+0x1628>
 820a1c8:	d8000b15 	stw	zero,44(sp)
 820a1cc:	003f3c06 	br	8209ec0 <_dtoa_r+0xd08>
 820a1d0:	dc000917 	ldw	r16,36(sp)
 820a1d4:	003e9206 	br	8209c20 <_dtoa_r+0xa68>
 820a1d8:	d9c00317 	ldw	r7,12(sp)
 820a1dc:	00800084 	movi	r2,2
 820a1e0:	11fec50e 	bge	r2,r7,8209cf8 <_dtoa_r+0xb40>
 820a1e4:	d9000617 	ldw	r4,24(sp)
 820a1e8:	20013c1e 	bne	r4,zero,820a6dc <_dtoa_r+0x1524>
 820a1ec:	a80b883a 	mov	r5,r21
 820a1f0:	000f883a 	mov	r7,zero
 820a1f4:	01800144 	movi	r6,5
 820a1f8:	e009883a 	mov	r4,fp
 820a1fc:	820c7280 	call	820c728 <__multadd>
 820a200:	100b883a 	mov	r5,r2
 820a204:	8009883a 	mov	r4,r16
 820a208:	102b883a 	mov	r21,r2
 820a20c:	820cf200 	call	820cf20 <__mcmp>
 820a210:	dc000915 	stw	r16,36(sp)
 820a214:	00bf410e 	bge	zero,r2,8209f1c <_dtoa_r+0xd64>
 820a218:	d9c00717 	ldw	r7,28(sp)
 820a21c:	00800c44 	movi	r2,49
 820a220:	38800005 	stb	r2,0(r7)
 820a224:	d8800517 	ldw	r2,20(sp)
 820a228:	3dc00044 	addi	r23,r7,1
 820a22c:	10800044 	addi	r2,r2,1
 820a230:	d8800515 	stw	r2,20(sp)
 820a234:	003f3d06 	br	8209f2c <_dtoa_r+0xd74>
 820a238:	d9800517 	ldw	r6,20(sp)
 820a23c:	d9c00717 	ldw	r7,28(sp)
 820a240:	00800c44 	movi	r2,49
 820a244:	31800044 	addi	r6,r6,1
 820a248:	d9800515 	stw	r6,20(sp)
 820a24c:	38800005 	stb	r2,0(r7)
 820a250:	003edf06 	br	8209dd0 <_dtoa_r+0xc18>
 820a254:	d8000b15 	stw	zero,44(sp)
 820a258:	003c9f06 	br	82094d8 <_dtoa_r+0x320>
 820a25c:	903e7e1e 	bne	r18,zero,8209c58 <_dtoa_r+0xaa0>
 820a260:	00800434 	movhi	r2,16
 820a264:	10bfffc4 	addi	r2,r2,-1
 820a268:	9884703a 	and	r2,r19,r2
 820a26c:	1000ea1e 	bne	r2,zero,820a618 <_dtoa_r+0x1460>
 820a270:	9cdffc2c 	andhi	r19,r19,32752
 820a274:	9800e826 	beq	r19,zero,820a618 <_dtoa_r+0x1460>
 820a278:	d9c00817 	ldw	r7,32(sp)
 820a27c:	b5800044 	addi	r22,r22,1
 820a280:	04c00044 	movi	r19,1
 820a284:	39c00044 	addi	r7,r7,1
 820a288:	d9c00815 	stw	r7,32(sp)
 820a28c:	d8800d17 	ldw	r2,52(sp)
 820a290:	103e721e 	bne	r2,zero,8209c5c <_dtoa_r+0xaa4>
 820a294:	00800044 	movi	r2,1
 820a298:	003e7906 	br	8209c80 <_dtoa_r+0xac8>
 820a29c:	8009883a 	mov	r4,r16
 820a2a0:	82141e80 	call	82141e8 <__floatsidf>
 820a2a4:	d9800f17 	ldw	r6,60(sp)
 820a2a8:	d9c01017 	ldw	r7,64(sp)
 820a2ac:	1009883a 	mov	r4,r2
 820a2b0:	180b883a 	mov	r5,r3
 820a2b4:	82131540 	call	8213154 <__muldf3>
 820a2b8:	000d883a 	mov	r6,zero
 820a2bc:	01d00734 	movhi	r7,16412
 820a2c0:	1009883a 	mov	r4,r2
 820a2c4:	180b883a 	mov	r5,r3
 820a2c8:	8211d680 	call	8211d68 <__adddf3>
 820a2cc:	047f3034 	movhi	r17,64704
 820a2d0:	1021883a 	mov	r16,r2
 820a2d4:	1c63883a 	add	r17,r3,r17
 820a2d8:	d9000f17 	ldw	r4,60(sp)
 820a2dc:	d9401017 	ldw	r5,64(sp)
 820a2e0:	000d883a 	mov	r6,zero
 820a2e4:	01d00534 	movhi	r7,16404
 820a2e8:	821386c0 	call	821386c <__subdf3>
 820a2ec:	800d883a 	mov	r6,r16
 820a2f0:	880f883a 	mov	r7,r17
 820a2f4:	1009883a 	mov	r4,r2
 820a2f8:	180b883a 	mov	r5,r3
 820a2fc:	102b883a 	mov	r21,r2
 820a300:	1829883a 	mov	r20,r3
 820a304:	8212f840 	call	8212f84 <__gedf2>
 820a308:	00806c16 	blt	zero,r2,820a4bc <_dtoa_r+0x1304>
 820a30c:	89e0003c 	xorhi	r7,r17,32768
 820a310:	800d883a 	mov	r6,r16
 820a314:	a809883a 	mov	r4,r21
 820a318:	a00b883a 	mov	r5,r20
 820a31c:	82130600 	call	8213060 <__ledf2>
 820a320:	103d7e0e 	bge	r2,zero,820991c <_dtoa_r+0x764>
 820a324:	002b883a 	mov	r21,zero
 820a328:	0023883a 	mov	r17,zero
 820a32c:	003efb06 	br	8209f1c <_dtoa_r+0xd64>
 820a330:	d8800717 	ldw	r2,28(sp)
 820a334:	003bd006 	br	8209278 <_dtoa_r+0xc0>
 820a338:	d9000a17 	ldw	r4,40(sp)
 820a33c:	d9800d17 	ldw	r6,52(sp)
 820a340:	dd400a15 	stw	r21,40(sp)
 820a344:	a905c83a 	sub	r2,r21,r4
 820a348:	308d883a 	add	r6,r6,r2
 820a34c:	d9800d15 	stw	r6,52(sp)
 820a350:	002b883a 	mov	r21,zero
 820a354:	003e0606 	br	8209b70 <_dtoa_r+0x9b8>
 820a358:	9023883a 	mov	r17,r18
 820a35c:	9829883a 	mov	r20,r19
 820a360:	04000084 	movi	r16,2
 820a364:	003c9206 	br	82095b0 <_dtoa_r+0x3f8>
 820a368:	04000044 	movi	r16,1
 820a36c:	dc000c15 	stw	r16,48(sp)
 820a370:	dc000615 	stw	r16,24(sp)
 820a374:	dc002215 	stw	r16,136(sp)
 820a378:	e0001115 	stw	zero,68(fp)
 820a37c:	000b883a 	mov	r5,zero
 820a380:	003c6906 	br	8209528 <_dtoa_r+0x370>
 820a384:	3021883a 	mov	r16,r6
 820a388:	003ffb06 	br	820a378 <_dtoa_r+0x11c0>
 820a38c:	1000021e 	bne	r2,zero,820a398 <_dtoa_r+0x11e0>
 820a390:	4200004c 	andi	r8,r8,1
 820a394:	403e7d1e 	bne	r8,zero,8209d8c <_dtoa_r+0xbd4>
 820a398:	01000c04 	movi	r4,48
 820a39c:	00000106 	br	820a3a4 <_dtoa_r+0x11ec>
 820a3a0:	102f883a 	mov	r23,r2
 820a3a4:	b8bfffc4 	addi	r2,r23,-1
 820a3a8:	10c00007 	ldb	r3,0(r2)
 820a3ac:	193ffc26 	beq	r3,r4,820a3a0 <_dtoa_r+0x11e8>
 820a3b0:	003e8706 	br	8209dd0 <_dtoa_r+0xc18>
 820a3b4:	d8800517 	ldw	r2,20(sp)
 820a3b8:	00a3c83a 	sub	r17,zero,r2
 820a3bc:	8800a426 	beq	r17,zero,820a650 <_dtoa_r+0x1498>
 820a3c0:	888003cc 	andi	r2,r17,15
 820a3c4:	100490fa 	slli	r2,r2,3
 820a3c8:	00c20974 	movhi	r3,2085
 820a3cc:	18f6f904 	addi	r3,r3,-9244
 820a3d0:	1885883a 	add	r2,r3,r2
 820a3d4:	11800017 	ldw	r6,0(r2)
 820a3d8:	11c00117 	ldw	r7,4(r2)
 820a3dc:	9009883a 	mov	r4,r18
 820a3e0:	980b883a 	mov	r5,r19
 820a3e4:	8823d13a 	srai	r17,r17,4
 820a3e8:	82131540 	call	8213154 <__muldf3>
 820a3ec:	d8800f15 	stw	r2,60(sp)
 820a3f0:	d8c01015 	stw	r3,64(sp)
 820a3f4:	8800e826 	beq	r17,zero,820a798 <_dtoa_r+0x15e0>
 820a3f8:	05020974 	movhi	r20,2085
 820a3fc:	a536ef04 	addi	r20,r20,-9284
 820a400:	04000084 	movi	r16,2
 820a404:	8980004c 	andi	r6,r17,1
 820a408:	1009883a 	mov	r4,r2
 820a40c:	8823d07a 	srai	r17,r17,1
 820a410:	180b883a 	mov	r5,r3
 820a414:	30000426 	beq	r6,zero,820a428 <_dtoa_r+0x1270>
 820a418:	a1800017 	ldw	r6,0(r20)
 820a41c:	a1c00117 	ldw	r7,4(r20)
 820a420:	84000044 	addi	r16,r16,1
 820a424:	82131540 	call	8213154 <__muldf3>
 820a428:	a5000204 	addi	r20,r20,8
 820a42c:	883ff51e 	bne	r17,zero,820a404 <_dtoa_r+0x124c>
 820a430:	d8800f15 	stw	r2,60(sp)
 820a434:	d8c01015 	stw	r3,64(sp)
 820a438:	003c7606 	br	8209614 <_dtoa_r+0x45c>
 820a43c:	00c00c04 	movi	r3,48
 820a440:	10c00005 	stb	r3,0(r2)
 820a444:	d8c00517 	ldw	r3,20(sp)
 820a448:	bd3fffc3 	ldbu	r20,-1(r23)
 820a44c:	18c00044 	addi	r3,r3,1
 820a450:	d8c00515 	stw	r3,20(sp)
 820a454:	003db906 	br	8209b3c <_dtoa_r+0x984>
 820a458:	89400117 	ldw	r5,4(r17)
 820a45c:	e009883a 	mov	r4,fp
 820a460:	820c6580 	call	820c658 <_Balloc>
 820a464:	89800417 	ldw	r6,16(r17)
 820a468:	89400304 	addi	r5,r17,12
 820a46c:	11000304 	addi	r4,r2,12
 820a470:	31800084 	addi	r6,r6,2
 820a474:	318d883a 	add	r6,r6,r6
 820a478:	318d883a 	add	r6,r6,r6
 820a47c:	1027883a 	mov	r19,r2
 820a480:	8202f100 	call	8202f10 <memcpy>
 820a484:	01800044 	movi	r6,1
 820a488:	980b883a 	mov	r5,r19
 820a48c:	e009883a 	mov	r4,fp
 820a490:	820cdd80 	call	820cdd8 <__lshift>
 820a494:	1029883a 	mov	r20,r2
 820a498:	003ecc06 	br	8209fcc <_dtoa_r+0xe14>
 820a49c:	00800e44 	movi	r2,57
 820a4a0:	90809026 	beq	r18,r2,820a6e4 <_dtoa_r+0x152c>
 820a4a4:	92000044 	addi	r8,r18,1
 820a4a8:	003f1f06 	br	820a128 <_dtoa_r+0xf70>
 820a4ac:	9011883a 	mov	r8,r18
 820a4b0:	8825883a 	mov	r18,r17
 820a4b4:	a023883a 	mov	r17,r20
 820a4b8:	003e2906 	br	8209d60 <_dtoa_r+0xba8>
 820a4bc:	002b883a 	mov	r21,zero
 820a4c0:	0023883a 	mov	r17,zero
 820a4c4:	003f5406 	br	820a218 <_dtoa_r+0x1060>
 820a4c8:	61bfffc4 	addi	r6,r12,-1
 820a4cc:	300490fa 	slli	r2,r6,3
 820a4d0:	00c20974 	movhi	r3,2085
 820a4d4:	18f6f904 	addi	r3,r3,-9244
 820a4d8:	1885883a 	add	r2,r3,r2
 820a4dc:	11000017 	ldw	r4,0(r2)
 820a4e0:	11400117 	ldw	r5,4(r2)
 820a4e4:	d8800717 	ldw	r2,28(sp)
 820a4e8:	880f883a 	mov	r7,r17
 820a4ec:	d9801215 	stw	r6,72(sp)
 820a4f0:	800d883a 	mov	r6,r16
 820a4f4:	db001615 	stw	r12,88(sp)
 820a4f8:	15c00044 	addi	r23,r2,1
 820a4fc:	82131540 	call	8213154 <__muldf3>
 820a500:	d9401017 	ldw	r5,64(sp)
 820a504:	d9000f17 	ldw	r4,60(sp)
 820a508:	d8c01515 	stw	r3,84(sp)
 820a50c:	d8801415 	stw	r2,80(sp)
 820a510:	82141680 	call	8214168 <__fixdfsi>
 820a514:	1009883a 	mov	r4,r2
 820a518:	1021883a 	mov	r16,r2
 820a51c:	82141e80 	call	82141e8 <__floatsidf>
 820a520:	d9000f17 	ldw	r4,60(sp)
 820a524:	d9401017 	ldw	r5,64(sp)
 820a528:	100d883a 	mov	r6,r2
 820a52c:	180f883a 	mov	r7,r3
 820a530:	821386c0 	call	821386c <__subdf3>
 820a534:	1829883a 	mov	r20,r3
 820a538:	d8c00717 	ldw	r3,28(sp)
 820a53c:	84000c04 	addi	r16,r16,48
 820a540:	1023883a 	mov	r17,r2
 820a544:	1c000005 	stb	r16,0(r3)
 820a548:	db001617 	ldw	r12,88(sp)
 820a54c:	00800044 	movi	r2,1
 820a550:	60802226 	beq	r12,r2,820a5dc <_dtoa_r+0x1424>
 820a554:	d9c00717 	ldw	r7,28(sp)
 820a558:	8805883a 	mov	r2,r17
 820a55c:	b82b883a 	mov	r21,r23
 820a560:	3b19883a 	add	r12,r7,r12
 820a564:	6023883a 	mov	r17,r12
 820a568:	a007883a 	mov	r3,r20
 820a56c:	dc800f15 	stw	r18,60(sp)
 820a570:	000d883a 	mov	r6,zero
 820a574:	01d00934 	movhi	r7,16420
 820a578:	1009883a 	mov	r4,r2
 820a57c:	180b883a 	mov	r5,r3
 820a580:	82131540 	call	8213154 <__muldf3>
 820a584:	180b883a 	mov	r5,r3
 820a588:	1009883a 	mov	r4,r2
 820a58c:	1829883a 	mov	r20,r3
 820a590:	1025883a 	mov	r18,r2
 820a594:	82141680 	call	8214168 <__fixdfsi>
 820a598:	1009883a 	mov	r4,r2
 820a59c:	1021883a 	mov	r16,r2
 820a5a0:	82141e80 	call	82141e8 <__floatsidf>
 820a5a4:	100d883a 	mov	r6,r2
 820a5a8:	180f883a 	mov	r7,r3
 820a5ac:	9009883a 	mov	r4,r18
 820a5b0:	a00b883a 	mov	r5,r20
 820a5b4:	84000c04 	addi	r16,r16,48
 820a5b8:	821386c0 	call	821386c <__subdf3>
 820a5bc:	ad400044 	addi	r21,r21,1
 820a5c0:	ac3fffc5 	stb	r16,-1(r21)
 820a5c4:	ac7fea1e 	bne	r21,r17,820a570 <_dtoa_r+0x13b8>
 820a5c8:	1023883a 	mov	r17,r2
 820a5cc:	d8801217 	ldw	r2,72(sp)
 820a5d0:	dc800f17 	ldw	r18,60(sp)
 820a5d4:	1829883a 	mov	r20,r3
 820a5d8:	b8af883a 	add	r23,r23,r2
 820a5dc:	d9001417 	ldw	r4,80(sp)
 820a5e0:	d9401517 	ldw	r5,84(sp)
 820a5e4:	000d883a 	mov	r6,zero
 820a5e8:	01cff834 	movhi	r7,16352
 820a5ec:	8211d680 	call	8211d68 <__adddf3>
 820a5f0:	880d883a 	mov	r6,r17
 820a5f4:	a00f883a 	mov	r7,r20
 820a5f8:	1009883a 	mov	r4,r2
 820a5fc:	180b883a 	mov	r5,r3
 820a600:	82130600 	call	8213060 <__ledf2>
 820a604:	10003e0e 	bge	r2,zero,820a700 <_dtoa_r+0x1548>
 820a608:	d9001317 	ldw	r4,76(sp)
 820a60c:	bd3fffc3 	ldbu	r20,-1(r23)
 820a610:	d9000515 	stw	r4,20(sp)
 820a614:	003d3b06 	br	8209b04 <_dtoa_r+0x94c>
 820a618:	0027883a 	mov	r19,zero
 820a61c:	003f1b06 	br	820a28c <_dtoa_r+0x10d4>
 820a620:	d8800817 	ldw	r2,32(sp)
 820a624:	11e9c83a 	sub	r20,r2,r7
 820a628:	0005883a 	mov	r2,zero
 820a62c:	003d5406 	br	8209b80 <_dtoa_r+0x9c8>
 820a630:	00800044 	movi	r2,1
 820a634:	003dc706 	br	8209d54 <_dtoa_r+0xb9c>
 820a638:	d8c00217 	ldw	r3,8(sp)
 820a63c:	00800d84 	movi	r2,54
 820a640:	dd400a17 	ldw	r21,40(sp)
 820a644:	10c5c83a 	sub	r2,r2,r3
 820a648:	dd000817 	ldw	r20,32(sp)
 820a64c:	003d4c06 	br	8209b80 <_dtoa_r+0x9c8>
 820a650:	dc800f15 	stw	r18,60(sp)
 820a654:	dcc01015 	stw	r19,64(sp)
 820a658:	04000084 	movi	r16,2
 820a65c:	003bed06 	br	8209614 <_dtoa_r+0x45c>
 820a660:	d9000617 	ldw	r4,24(sp)
 820a664:	203f0d26 	beq	r4,zero,820a29c <_dtoa_r+0x10e4>
 820a668:	d9800c17 	ldw	r6,48(sp)
 820a66c:	01bcab0e 	bge	zero,r6,820991c <_dtoa_r+0x764>
 820a670:	d9401017 	ldw	r5,64(sp)
 820a674:	d9000f17 	ldw	r4,60(sp)
 820a678:	000d883a 	mov	r6,zero
 820a67c:	01d00934 	movhi	r7,16420
 820a680:	82131540 	call	8213154 <__muldf3>
 820a684:	81000044 	addi	r4,r16,1
 820a688:	d8800f15 	stw	r2,60(sp)
 820a68c:	d8c01015 	stw	r3,64(sp)
 820a690:	82141e80 	call	82141e8 <__floatsidf>
 820a694:	d9800f17 	ldw	r6,60(sp)
 820a698:	d9c01017 	ldw	r7,64(sp)
 820a69c:	1009883a 	mov	r4,r2
 820a6a0:	180b883a 	mov	r5,r3
 820a6a4:	82131540 	call	8213154 <__muldf3>
 820a6a8:	01d00734 	movhi	r7,16412
 820a6ac:	000d883a 	mov	r6,zero
 820a6b0:	1009883a 	mov	r4,r2
 820a6b4:	180b883a 	mov	r5,r3
 820a6b8:	8211d680 	call	8211d68 <__adddf3>
 820a6bc:	d9c00517 	ldw	r7,20(sp)
 820a6c0:	047f3034 	movhi	r17,64704
 820a6c4:	1021883a 	mov	r16,r2
 820a6c8:	39ffffc4 	addi	r7,r7,-1
 820a6cc:	d9c01315 	stw	r7,76(sp)
 820a6d0:	1c63883a 	add	r17,r3,r17
 820a6d4:	db000c17 	ldw	r12,48(sp)
 820a6d8:	003bea06 	br	8209684 <_dtoa_r+0x4cc>
 820a6dc:	dc000915 	stw	r16,36(sp)
 820a6e0:	003e0e06 	br	8209f1c <_dtoa_r+0xd64>
 820a6e4:	01000e44 	movi	r4,57
 820a6e8:	8825883a 	mov	r18,r17
 820a6ec:	9dc00044 	addi	r23,r19,1
 820a6f0:	99000005 	stb	r4,0(r19)
 820a6f4:	a023883a 	mov	r17,r20
 820a6f8:	dc000915 	stw	r16,36(sp)
 820a6fc:	003da406 	br	8209d90 <_dtoa_r+0xbd8>
 820a700:	d9801417 	ldw	r6,80(sp)
 820a704:	d9c01517 	ldw	r7,84(sp)
 820a708:	0009883a 	mov	r4,zero
 820a70c:	014ff834 	movhi	r5,16352
 820a710:	821386c0 	call	821386c <__subdf3>
 820a714:	880d883a 	mov	r6,r17
 820a718:	a00f883a 	mov	r7,r20
 820a71c:	1009883a 	mov	r4,r2
 820a720:	180b883a 	mov	r5,r3
 820a724:	8212f840 	call	8212f84 <__gedf2>
 820a728:	00bc7c0e 	bge	zero,r2,820991c <_dtoa_r+0x764>
 820a72c:	01000c04 	movi	r4,48
 820a730:	00000106 	br	820a738 <_dtoa_r+0x1580>
 820a734:	102f883a 	mov	r23,r2
 820a738:	b8bfffc4 	addi	r2,r23,-1
 820a73c:	10c00007 	ldb	r3,0(r2)
 820a740:	193ffc26 	beq	r3,r4,820a734 <_dtoa_r+0x157c>
 820a744:	d9801317 	ldw	r6,76(sp)
 820a748:	d9800515 	stw	r6,20(sp)
 820a74c:	003c4406 	br	8209860 <_dtoa_r+0x6a8>
 820a750:	d9801317 	ldw	r6,76(sp)
 820a754:	d9800515 	stw	r6,20(sp)
 820a758:	003cea06 	br	8209b04 <_dtoa_r+0x94c>
 820a75c:	dd800f17 	ldw	r22,60(sp)
 820a760:	dcc01017 	ldw	r19,64(sp)
 820a764:	dc801217 	ldw	r18,72(sp)
 820a768:	003c6c06 	br	820991c <_dtoa_r+0x764>
 820a76c:	903e031e 	bne	r18,zero,8209f7c <_dtoa_r+0xdc4>
 820a770:	003ebb06 	br	820a260 <_dtoa_r+0x10a8>
 820a774:	103e6c1e 	bne	r2,zero,820a128 <_dtoa_r+0xf70>
 820a778:	4080004c 	andi	r2,r8,1
 820a77c:	103e6a26 	beq	r2,zero,820a128 <_dtoa_r+0xf70>
 820a780:	003e6606 	br	820a11c <_dtoa_r+0xf64>
 820a784:	d8c00317 	ldw	r3,12(sp)
 820a788:	00800084 	movi	r2,2
 820a78c:	10c02916 	blt	r2,r3,820a834 <_dtoa_r+0x167c>
 820a790:	d9000c17 	ldw	r4,48(sp)
 820a794:	003e8806 	br	820a1b8 <_dtoa_r+0x1000>
 820a798:	04000084 	movi	r16,2
 820a79c:	003b9d06 	br	8209614 <_dtoa_r+0x45c>
 820a7a0:	d9001317 	ldw	r4,76(sp)
 820a7a4:	d9000515 	stw	r4,20(sp)
 820a7a8:	003cd606 	br	8209b04 <_dtoa_r+0x94c>
 820a7ac:	d8801317 	ldw	r2,76(sp)
 820a7b0:	d8800515 	stw	r2,20(sp)
 820a7b4:	003c2a06 	br	8209860 <_dtoa_r+0x6a8>
 820a7b8:	d9800317 	ldw	r6,12(sp)
 820a7bc:	00800084 	movi	r2,2
 820a7c0:	11801516 	blt	r2,r6,820a818 <_dtoa_r+0x1660>
 820a7c4:	d9c00c17 	ldw	r7,48(sp)
 820a7c8:	d9c00615 	stw	r7,24(sp)
 820a7cc:	003df706 	br	8209fac <_dtoa_r+0xdf4>
 820a7d0:	193d3926 	beq	r3,r4,8209cb8 <_dtoa_r+0xb00>
 820a7d4:	00c00f04 	movi	r3,60
 820a7d8:	1885c83a 	sub	r2,r3,r2
 820a7dc:	003ddf06 	br	8209f5c <_dtoa_r+0xda4>
 820a7e0:	e009883a 	mov	r4,fp
 820a7e4:	e0001115 	stw	zero,68(fp)
 820a7e8:	000b883a 	mov	r5,zero
 820a7ec:	820c6580 	call	820c658 <_Balloc>
 820a7f0:	d8800715 	stw	r2,28(sp)
 820a7f4:	d8c00717 	ldw	r3,28(sp)
 820a7f8:	00bfffc4 	movi	r2,-1
 820a7fc:	01000044 	movi	r4,1
 820a800:	d8800c15 	stw	r2,48(sp)
 820a804:	e0c01015 	stw	r3,64(fp)
 820a808:	d9000b15 	stw	r4,44(sp)
 820a80c:	d8800615 	stw	r2,24(sp)
 820a810:	d8002215 	stw	zero,136(sp)
 820a814:	003c4106 	br	820991c <_dtoa_r+0x764>
 820a818:	d8c00c17 	ldw	r3,48(sp)
 820a81c:	d8c00615 	stw	r3,24(sp)
 820a820:	003e7006 	br	820a1e4 <_dtoa_r+0x102c>
 820a824:	04400044 	movi	r17,1
 820a828:	003b2006 	br	82094ac <_dtoa_r+0x2f4>
 820a82c:	000b883a 	mov	r5,zero
 820a830:	003b3d06 	br	8209528 <_dtoa_r+0x370>
 820a834:	d8800c17 	ldw	r2,48(sp)
 820a838:	d8800615 	stw	r2,24(sp)
 820a83c:	003e6906 	br	820a1e4 <_dtoa_r+0x102c>

0820a840 <__sflush_r>:
 820a840:	2880030b 	ldhu	r2,12(r5)
 820a844:	defffb04 	addi	sp,sp,-20
 820a848:	dcc00315 	stw	r19,12(sp)
 820a84c:	dc400115 	stw	r17,4(sp)
 820a850:	dfc00415 	stw	ra,16(sp)
 820a854:	dc800215 	stw	r18,8(sp)
 820a858:	dc000015 	stw	r16,0(sp)
 820a85c:	10c0020c 	andi	r3,r2,8
 820a860:	2823883a 	mov	r17,r5
 820a864:	2027883a 	mov	r19,r4
 820a868:	1800311e 	bne	r3,zero,820a930 <__sflush_r+0xf0>
 820a86c:	28c00117 	ldw	r3,4(r5)
 820a870:	10820014 	ori	r2,r2,2048
 820a874:	2880030d 	sth	r2,12(r5)
 820a878:	00c04b0e 	bge	zero,r3,820a9a8 <__sflush_r+0x168>
 820a87c:	8a000a17 	ldw	r8,40(r17)
 820a880:	40002326 	beq	r8,zero,820a910 <__sflush_r+0xd0>
 820a884:	9c000017 	ldw	r16,0(r19)
 820a888:	10c4000c 	andi	r3,r2,4096
 820a88c:	98000015 	stw	zero,0(r19)
 820a890:	18004826 	beq	r3,zero,820a9b4 <__sflush_r+0x174>
 820a894:	89801417 	ldw	r6,80(r17)
 820a898:	10c0010c 	andi	r3,r2,4
 820a89c:	18000626 	beq	r3,zero,820a8b8 <__sflush_r+0x78>
 820a8a0:	88c00117 	ldw	r3,4(r17)
 820a8a4:	88800c17 	ldw	r2,48(r17)
 820a8a8:	30cdc83a 	sub	r6,r6,r3
 820a8ac:	10000226 	beq	r2,zero,820a8b8 <__sflush_r+0x78>
 820a8b0:	88800f17 	ldw	r2,60(r17)
 820a8b4:	308dc83a 	sub	r6,r6,r2
 820a8b8:	89400717 	ldw	r5,28(r17)
 820a8bc:	000f883a 	mov	r7,zero
 820a8c0:	9809883a 	mov	r4,r19
 820a8c4:	403ee83a 	callr	r8
 820a8c8:	00ffffc4 	movi	r3,-1
 820a8cc:	10c04426 	beq	r2,r3,820a9e0 <__sflush_r+0x1a0>
 820a8d0:	88c0030b 	ldhu	r3,12(r17)
 820a8d4:	89000417 	ldw	r4,16(r17)
 820a8d8:	88000115 	stw	zero,4(r17)
 820a8dc:	197dffcc 	andi	r5,r3,63487
 820a8e0:	8940030d 	sth	r5,12(r17)
 820a8e4:	89000015 	stw	r4,0(r17)
 820a8e8:	18c4000c 	andi	r3,r3,4096
 820a8ec:	18002c1e 	bne	r3,zero,820a9a0 <__sflush_r+0x160>
 820a8f0:	89400c17 	ldw	r5,48(r17)
 820a8f4:	9c000015 	stw	r16,0(r19)
 820a8f8:	28000526 	beq	r5,zero,820a910 <__sflush_r+0xd0>
 820a8fc:	88801004 	addi	r2,r17,64
 820a900:	28800226 	beq	r5,r2,820a90c <__sflush_r+0xcc>
 820a904:	9809883a 	mov	r4,r19
 820a908:	820b1000 	call	820b100 <_free_r>
 820a90c:	88000c15 	stw	zero,48(r17)
 820a910:	0005883a 	mov	r2,zero
 820a914:	dfc00417 	ldw	ra,16(sp)
 820a918:	dcc00317 	ldw	r19,12(sp)
 820a91c:	dc800217 	ldw	r18,8(sp)
 820a920:	dc400117 	ldw	r17,4(sp)
 820a924:	dc000017 	ldw	r16,0(sp)
 820a928:	dec00504 	addi	sp,sp,20
 820a92c:	f800283a 	ret
 820a930:	2c800417 	ldw	r18,16(r5)
 820a934:	903ff626 	beq	r18,zero,820a910 <__sflush_r+0xd0>
 820a938:	2c000017 	ldw	r16,0(r5)
 820a93c:	108000cc 	andi	r2,r2,3
 820a940:	2c800015 	stw	r18,0(r5)
 820a944:	84a1c83a 	sub	r16,r16,r18
 820a948:	1000131e 	bne	r2,zero,820a998 <__sflush_r+0x158>
 820a94c:	28800517 	ldw	r2,20(r5)
 820a950:	88800215 	stw	r2,8(r17)
 820a954:	04000316 	blt	zero,r16,820a964 <__sflush_r+0x124>
 820a958:	003fed06 	br	820a910 <__sflush_r+0xd0>
 820a95c:	90a5883a 	add	r18,r18,r2
 820a960:	043feb0e 	bge	zero,r16,820a910 <__sflush_r+0xd0>
 820a964:	88800917 	ldw	r2,36(r17)
 820a968:	89400717 	ldw	r5,28(r17)
 820a96c:	800f883a 	mov	r7,r16
 820a970:	900d883a 	mov	r6,r18
 820a974:	9809883a 	mov	r4,r19
 820a978:	103ee83a 	callr	r2
 820a97c:	80a1c83a 	sub	r16,r16,r2
 820a980:	00bff616 	blt	zero,r2,820a95c <__sflush_r+0x11c>
 820a984:	88c0030b 	ldhu	r3,12(r17)
 820a988:	00bfffc4 	movi	r2,-1
 820a98c:	18c01014 	ori	r3,r3,64
 820a990:	88c0030d 	sth	r3,12(r17)
 820a994:	003fdf06 	br	820a914 <__sflush_r+0xd4>
 820a998:	0005883a 	mov	r2,zero
 820a99c:	003fec06 	br	820a950 <__sflush_r+0x110>
 820a9a0:	88801415 	stw	r2,80(r17)
 820a9a4:	003fd206 	br	820a8f0 <__sflush_r+0xb0>
 820a9a8:	28c00f17 	ldw	r3,60(r5)
 820a9ac:	00ffb316 	blt	zero,r3,820a87c <__sflush_r+0x3c>
 820a9b0:	003fd706 	br	820a910 <__sflush_r+0xd0>
 820a9b4:	89400717 	ldw	r5,28(r17)
 820a9b8:	000d883a 	mov	r6,zero
 820a9bc:	01c00044 	movi	r7,1
 820a9c0:	9809883a 	mov	r4,r19
 820a9c4:	403ee83a 	callr	r8
 820a9c8:	100d883a 	mov	r6,r2
 820a9cc:	00bfffc4 	movi	r2,-1
 820a9d0:	30801426 	beq	r6,r2,820aa24 <__sflush_r+0x1e4>
 820a9d4:	8880030b 	ldhu	r2,12(r17)
 820a9d8:	8a000a17 	ldw	r8,40(r17)
 820a9dc:	003fae06 	br	820a898 <__sflush_r+0x58>
 820a9e0:	98c00017 	ldw	r3,0(r19)
 820a9e4:	183fba26 	beq	r3,zero,820a8d0 <__sflush_r+0x90>
 820a9e8:	01000744 	movi	r4,29
 820a9ec:	19000626 	beq	r3,r4,820aa08 <__sflush_r+0x1c8>
 820a9f0:	01000584 	movi	r4,22
 820a9f4:	19000426 	beq	r3,r4,820aa08 <__sflush_r+0x1c8>
 820a9f8:	88c0030b 	ldhu	r3,12(r17)
 820a9fc:	18c01014 	ori	r3,r3,64
 820aa00:	88c0030d 	sth	r3,12(r17)
 820aa04:	003fc306 	br	820a914 <__sflush_r+0xd4>
 820aa08:	8880030b 	ldhu	r2,12(r17)
 820aa0c:	88c00417 	ldw	r3,16(r17)
 820aa10:	88000115 	stw	zero,4(r17)
 820aa14:	10bdffcc 	andi	r2,r2,63487
 820aa18:	8880030d 	sth	r2,12(r17)
 820aa1c:	88c00015 	stw	r3,0(r17)
 820aa20:	003fb306 	br	820a8f0 <__sflush_r+0xb0>
 820aa24:	98800017 	ldw	r2,0(r19)
 820aa28:	103fea26 	beq	r2,zero,820a9d4 <__sflush_r+0x194>
 820aa2c:	00c00744 	movi	r3,29
 820aa30:	10c00226 	beq	r2,r3,820aa3c <__sflush_r+0x1fc>
 820aa34:	00c00584 	movi	r3,22
 820aa38:	10c0031e 	bne	r2,r3,820aa48 <__sflush_r+0x208>
 820aa3c:	9c000015 	stw	r16,0(r19)
 820aa40:	0005883a 	mov	r2,zero
 820aa44:	003fb306 	br	820a914 <__sflush_r+0xd4>
 820aa48:	88c0030b 	ldhu	r3,12(r17)
 820aa4c:	3005883a 	mov	r2,r6
 820aa50:	18c01014 	ori	r3,r3,64
 820aa54:	88c0030d 	sth	r3,12(r17)
 820aa58:	003fae06 	br	820a914 <__sflush_r+0xd4>

0820aa5c <_fflush_r>:
 820aa5c:	defffd04 	addi	sp,sp,-12
 820aa60:	dc000115 	stw	r16,4(sp)
 820aa64:	dfc00215 	stw	ra,8(sp)
 820aa68:	2021883a 	mov	r16,r4
 820aa6c:	20000226 	beq	r4,zero,820aa78 <_fflush_r+0x1c>
 820aa70:	20800e17 	ldw	r2,56(r4)
 820aa74:	10000c26 	beq	r2,zero,820aaa8 <_fflush_r+0x4c>
 820aa78:	2880030f 	ldh	r2,12(r5)
 820aa7c:	1000051e 	bne	r2,zero,820aa94 <_fflush_r+0x38>
 820aa80:	0005883a 	mov	r2,zero
 820aa84:	dfc00217 	ldw	ra,8(sp)
 820aa88:	dc000117 	ldw	r16,4(sp)
 820aa8c:	dec00304 	addi	sp,sp,12
 820aa90:	f800283a 	ret
 820aa94:	8009883a 	mov	r4,r16
 820aa98:	dfc00217 	ldw	ra,8(sp)
 820aa9c:	dc000117 	ldw	r16,4(sp)
 820aaa0:	dec00304 	addi	sp,sp,12
 820aaa4:	820a8401 	jmpi	820a840 <__sflush_r>
 820aaa8:	d9400015 	stw	r5,0(sp)
 820aaac:	820ae380 	call	820ae38 <__sinit>
 820aab0:	d9400017 	ldw	r5,0(sp)
 820aab4:	003ff006 	br	820aa78 <_fflush_r+0x1c>

0820aab8 <fflush>:
 820aab8:	20000526 	beq	r4,zero,820aad0 <fflush+0x18>
 820aabc:	00820974 	movhi	r2,2085
 820aac0:	108f9904 	addi	r2,r2,15972
 820aac4:	200b883a 	mov	r5,r4
 820aac8:	11000017 	ldw	r4,0(r2)
 820aacc:	820aa5c1 	jmpi	820aa5c <_fflush_r>
 820aad0:	00820974 	movhi	r2,2085
 820aad4:	108f9804 	addi	r2,r2,15968
 820aad8:	11000017 	ldw	r4,0(r2)
 820aadc:	01420874 	movhi	r5,2081
 820aae0:	296a9704 	addi	r5,r5,-21924
 820aae4:	820b9901 	jmpi	820b990 <_fwalk_reent>

0820aae8 <__fp_unlock>:
 820aae8:	0005883a 	mov	r2,zero
 820aaec:	f800283a 	ret

0820aaf0 <_cleanup_r>:
 820aaf0:	01420874 	movhi	r5,2081
 820aaf4:	29431504 	addi	r5,r5,3156
 820aaf8:	820b9901 	jmpi	820b990 <_fwalk_reent>

0820aafc <__sinit.part.1>:
 820aafc:	defff704 	addi	sp,sp,-36
 820ab00:	00c20874 	movhi	r3,2081
 820ab04:	dfc00815 	stw	ra,32(sp)
 820ab08:	ddc00715 	stw	r23,28(sp)
 820ab0c:	dd800615 	stw	r22,24(sp)
 820ab10:	dd400515 	stw	r21,20(sp)
 820ab14:	dd000415 	stw	r20,16(sp)
 820ab18:	dcc00315 	stw	r19,12(sp)
 820ab1c:	dc800215 	stw	r18,8(sp)
 820ab20:	dc400115 	stw	r17,4(sp)
 820ab24:	dc000015 	stw	r16,0(sp)
 820ab28:	18eabc04 	addi	r3,r3,-21776
 820ab2c:	24000117 	ldw	r16,4(r4)
 820ab30:	20c00f15 	stw	r3,60(r4)
 820ab34:	2080bb04 	addi	r2,r4,748
 820ab38:	00c000c4 	movi	r3,3
 820ab3c:	20c0b915 	stw	r3,740(r4)
 820ab40:	2080ba15 	stw	r2,744(r4)
 820ab44:	2000b815 	stw	zero,736(r4)
 820ab48:	05c00204 	movi	r23,8
 820ab4c:	00800104 	movi	r2,4
 820ab50:	2025883a 	mov	r18,r4
 820ab54:	b80d883a 	mov	r6,r23
 820ab58:	81001704 	addi	r4,r16,92
 820ab5c:	000b883a 	mov	r5,zero
 820ab60:	80000015 	stw	zero,0(r16)
 820ab64:	80000115 	stw	zero,4(r16)
 820ab68:	80000215 	stw	zero,8(r16)
 820ab6c:	8080030d 	sth	r2,12(r16)
 820ab70:	80001915 	stw	zero,100(r16)
 820ab74:	8000038d 	sth	zero,14(r16)
 820ab78:	80000415 	stw	zero,16(r16)
 820ab7c:	80000515 	stw	zero,20(r16)
 820ab80:	80000615 	stw	zero,24(r16)
 820ab84:	82031b40 	call	82031b4 <memset>
 820ab88:	05820874 	movhi	r22,2081
 820ab8c:	94400217 	ldw	r17,8(r18)
 820ab90:	05420874 	movhi	r21,2081
 820ab94:	05020874 	movhi	r20,2081
 820ab98:	04c20874 	movhi	r19,2081
 820ab9c:	b5b79c04 	addi	r22,r22,-8592
 820aba0:	ad77b304 	addi	r21,r21,-8500
 820aba4:	a537d204 	addi	r20,r20,-8376
 820aba8:	9cf7e904 	addi	r19,r19,-8284
 820abac:	85800815 	stw	r22,32(r16)
 820abb0:	85400915 	stw	r21,36(r16)
 820abb4:	85000a15 	stw	r20,40(r16)
 820abb8:	84c00b15 	stw	r19,44(r16)
 820abbc:	84000715 	stw	r16,28(r16)
 820abc0:	00800284 	movi	r2,10
 820abc4:	8880030d 	sth	r2,12(r17)
 820abc8:	00800044 	movi	r2,1
 820abcc:	b80d883a 	mov	r6,r23
 820abd0:	89001704 	addi	r4,r17,92
 820abd4:	000b883a 	mov	r5,zero
 820abd8:	88000015 	stw	zero,0(r17)
 820abdc:	88000115 	stw	zero,4(r17)
 820abe0:	88000215 	stw	zero,8(r17)
 820abe4:	88001915 	stw	zero,100(r17)
 820abe8:	8880038d 	sth	r2,14(r17)
 820abec:	88000415 	stw	zero,16(r17)
 820abf0:	88000515 	stw	zero,20(r17)
 820abf4:	88000615 	stw	zero,24(r17)
 820abf8:	82031b40 	call	82031b4 <memset>
 820abfc:	94000317 	ldw	r16,12(r18)
 820ac00:	00800484 	movi	r2,18
 820ac04:	8c400715 	stw	r17,28(r17)
 820ac08:	8d800815 	stw	r22,32(r17)
 820ac0c:	8d400915 	stw	r21,36(r17)
 820ac10:	8d000a15 	stw	r20,40(r17)
 820ac14:	8cc00b15 	stw	r19,44(r17)
 820ac18:	8080030d 	sth	r2,12(r16)
 820ac1c:	00800084 	movi	r2,2
 820ac20:	80000015 	stw	zero,0(r16)
 820ac24:	80000115 	stw	zero,4(r16)
 820ac28:	80000215 	stw	zero,8(r16)
 820ac2c:	80001915 	stw	zero,100(r16)
 820ac30:	8080038d 	sth	r2,14(r16)
 820ac34:	80000415 	stw	zero,16(r16)
 820ac38:	80000515 	stw	zero,20(r16)
 820ac3c:	80000615 	stw	zero,24(r16)
 820ac40:	b80d883a 	mov	r6,r23
 820ac44:	000b883a 	mov	r5,zero
 820ac48:	81001704 	addi	r4,r16,92
 820ac4c:	82031b40 	call	82031b4 <memset>
 820ac50:	00800044 	movi	r2,1
 820ac54:	84000715 	stw	r16,28(r16)
 820ac58:	85800815 	stw	r22,32(r16)
 820ac5c:	85400915 	stw	r21,36(r16)
 820ac60:	85000a15 	stw	r20,40(r16)
 820ac64:	84c00b15 	stw	r19,44(r16)
 820ac68:	90800e15 	stw	r2,56(r18)
 820ac6c:	dfc00817 	ldw	ra,32(sp)
 820ac70:	ddc00717 	ldw	r23,28(sp)
 820ac74:	dd800617 	ldw	r22,24(sp)
 820ac78:	dd400517 	ldw	r21,20(sp)
 820ac7c:	dd000417 	ldw	r20,16(sp)
 820ac80:	dcc00317 	ldw	r19,12(sp)
 820ac84:	dc800217 	ldw	r18,8(sp)
 820ac88:	dc400117 	ldw	r17,4(sp)
 820ac8c:	dc000017 	ldw	r16,0(sp)
 820ac90:	dec00904 	addi	sp,sp,36
 820ac94:	f800283a 	ret

0820ac98 <__fp_lock>:
 820ac98:	0005883a 	mov	r2,zero
 820ac9c:	f800283a 	ret

0820aca0 <__sfmoreglue>:
 820aca0:	defffc04 	addi	sp,sp,-16
 820aca4:	dc400115 	stw	r17,4(sp)
 820aca8:	2c7fffc4 	addi	r17,r5,-1
 820acac:	8c401a24 	muli	r17,r17,104
 820acb0:	dc800215 	stw	r18,8(sp)
 820acb4:	2825883a 	mov	r18,r5
 820acb8:	89401d04 	addi	r5,r17,116
 820acbc:	dc000015 	stw	r16,0(sp)
 820acc0:	dfc00315 	stw	ra,12(sp)
 820acc4:	820bcec0 	call	820bcec <_malloc_r>
 820acc8:	1021883a 	mov	r16,r2
 820accc:	10000726 	beq	r2,zero,820acec <__sfmoreglue+0x4c>
 820acd0:	11000304 	addi	r4,r2,12
 820acd4:	10000015 	stw	zero,0(r2)
 820acd8:	14800115 	stw	r18,4(r2)
 820acdc:	11000215 	stw	r4,8(r2)
 820ace0:	89801a04 	addi	r6,r17,104
 820ace4:	000b883a 	mov	r5,zero
 820ace8:	82031b40 	call	82031b4 <memset>
 820acec:	8005883a 	mov	r2,r16
 820acf0:	dfc00317 	ldw	ra,12(sp)
 820acf4:	dc800217 	ldw	r18,8(sp)
 820acf8:	dc400117 	ldw	r17,4(sp)
 820acfc:	dc000017 	ldw	r16,0(sp)
 820ad00:	dec00404 	addi	sp,sp,16
 820ad04:	f800283a 	ret

0820ad08 <__sfp>:
 820ad08:	defffb04 	addi	sp,sp,-20
 820ad0c:	dc000015 	stw	r16,0(sp)
 820ad10:	04020974 	movhi	r16,2085
 820ad14:	840f9804 	addi	r16,r16,15968
 820ad18:	dcc00315 	stw	r19,12(sp)
 820ad1c:	2027883a 	mov	r19,r4
 820ad20:	81000017 	ldw	r4,0(r16)
 820ad24:	dfc00415 	stw	ra,16(sp)
 820ad28:	dc800215 	stw	r18,8(sp)
 820ad2c:	20800e17 	ldw	r2,56(r4)
 820ad30:	dc400115 	stw	r17,4(sp)
 820ad34:	1000021e 	bne	r2,zero,820ad40 <__sfp+0x38>
 820ad38:	820aafc0 	call	820aafc <__sinit.part.1>
 820ad3c:	81000017 	ldw	r4,0(r16)
 820ad40:	2480b804 	addi	r18,r4,736
 820ad44:	047fffc4 	movi	r17,-1
 820ad48:	91000117 	ldw	r4,4(r18)
 820ad4c:	94000217 	ldw	r16,8(r18)
 820ad50:	213fffc4 	addi	r4,r4,-1
 820ad54:	20000a16 	blt	r4,zero,820ad80 <__sfp+0x78>
 820ad58:	8080030f 	ldh	r2,12(r16)
 820ad5c:	10000c26 	beq	r2,zero,820ad90 <__sfp+0x88>
 820ad60:	80c01d04 	addi	r3,r16,116
 820ad64:	00000206 	br	820ad70 <__sfp+0x68>
 820ad68:	18bfe60f 	ldh	r2,-104(r3)
 820ad6c:	10000826 	beq	r2,zero,820ad90 <__sfp+0x88>
 820ad70:	213fffc4 	addi	r4,r4,-1
 820ad74:	1c3ffd04 	addi	r16,r3,-12
 820ad78:	18c01a04 	addi	r3,r3,104
 820ad7c:	247ffa1e 	bne	r4,r17,820ad68 <__sfp+0x60>
 820ad80:	90800017 	ldw	r2,0(r18)
 820ad84:	10001d26 	beq	r2,zero,820adfc <__sfp+0xf4>
 820ad88:	1025883a 	mov	r18,r2
 820ad8c:	003fee06 	br	820ad48 <__sfp+0x40>
 820ad90:	00bfffc4 	movi	r2,-1
 820ad94:	8080038d 	sth	r2,14(r16)
 820ad98:	00800044 	movi	r2,1
 820ad9c:	8080030d 	sth	r2,12(r16)
 820ada0:	80001915 	stw	zero,100(r16)
 820ada4:	80000015 	stw	zero,0(r16)
 820ada8:	80000215 	stw	zero,8(r16)
 820adac:	80000115 	stw	zero,4(r16)
 820adb0:	80000415 	stw	zero,16(r16)
 820adb4:	80000515 	stw	zero,20(r16)
 820adb8:	80000615 	stw	zero,24(r16)
 820adbc:	01800204 	movi	r6,8
 820adc0:	000b883a 	mov	r5,zero
 820adc4:	81001704 	addi	r4,r16,92
 820adc8:	82031b40 	call	82031b4 <memset>
 820adcc:	8005883a 	mov	r2,r16
 820add0:	80000c15 	stw	zero,48(r16)
 820add4:	80000d15 	stw	zero,52(r16)
 820add8:	80001115 	stw	zero,68(r16)
 820addc:	80001215 	stw	zero,72(r16)
 820ade0:	dfc00417 	ldw	ra,16(sp)
 820ade4:	dcc00317 	ldw	r19,12(sp)
 820ade8:	dc800217 	ldw	r18,8(sp)
 820adec:	dc400117 	ldw	r17,4(sp)
 820adf0:	dc000017 	ldw	r16,0(sp)
 820adf4:	dec00504 	addi	sp,sp,20
 820adf8:	f800283a 	ret
 820adfc:	01400104 	movi	r5,4
 820ae00:	9809883a 	mov	r4,r19
 820ae04:	820aca00 	call	820aca0 <__sfmoreglue>
 820ae08:	90800015 	stw	r2,0(r18)
 820ae0c:	103fde1e 	bne	r2,zero,820ad88 <__sfp+0x80>
 820ae10:	00800304 	movi	r2,12
 820ae14:	98800015 	stw	r2,0(r19)
 820ae18:	0005883a 	mov	r2,zero
 820ae1c:	003ff006 	br	820ade0 <__sfp+0xd8>

0820ae20 <_cleanup>:
 820ae20:	00820974 	movhi	r2,2085
 820ae24:	108f9804 	addi	r2,r2,15968
 820ae28:	11000017 	ldw	r4,0(r2)
 820ae2c:	01420874 	movhi	r5,2081
 820ae30:	29431504 	addi	r5,r5,3156
 820ae34:	820b9901 	jmpi	820b990 <_fwalk_reent>

0820ae38 <__sinit>:
 820ae38:	20800e17 	ldw	r2,56(r4)
 820ae3c:	10000126 	beq	r2,zero,820ae44 <__sinit+0xc>
 820ae40:	f800283a 	ret
 820ae44:	820aafc1 	jmpi	820aafc <__sinit.part.1>

0820ae48 <__sfp_lock_acquire>:
 820ae48:	f800283a 	ret

0820ae4c <__sfp_lock_release>:
 820ae4c:	f800283a 	ret

0820ae50 <__sinit_lock_acquire>:
 820ae50:	f800283a 	ret

0820ae54 <__sinit_lock_release>:
 820ae54:	f800283a 	ret

0820ae58 <__fp_lock_all>:
 820ae58:	00820974 	movhi	r2,2085
 820ae5c:	108f9904 	addi	r2,r2,15972
 820ae60:	11000017 	ldw	r4,0(r2)
 820ae64:	01420874 	movhi	r5,2081
 820ae68:	296b2604 	addi	r5,r5,-21352
 820ae6c:	820b8cc1 	jmpi	820b8cc <_fwalk>

0820ae70 <__fp_unlock_all>:
 820ae70:	00820974 	movhi	r2,2085
 820ae74:	108f9904 	addi	r2,r2,15972
 820ae78:	11000017 	ldw	r4,0(r2)
 820ae7c:	01420874 	movhi	r5,2081
 820ae80:	296aba04 	addi	r5,r5,-21784
 820ae84:	820b8cc1 	jmpi	820b8cc <_fwalk>

0820ae88 <_fputc_r>:
 820ae88:	defffc04 	addi	sp,sp,-16
 820ae8c:	dc000215 	stw	r16,8(sp)
 820ae90:	dfc00315 	stw	ra,12(sp)
 820ae94:	2021883a 	mov	r16,r4
 820ae98:	20000726 	beq	r4,zero,820aeb8 <_fputc_r+0x30>
 820ae9c:	20800e17 	ldw	r2,56(r4)
 820aea0:	1000051e 	bne	r2,zero,820aeb8 <_fputc_r+0x30>
 820aea4:	d9400015 	stw	r5,0(sp)
 820aea8:	d9800115 	stw	r6,4(sp)
 820aeac:	820ae380 	call	820ae38 <__sinit>
 820aeb0:	d9800117 	ldw	r6,4(sp)
 820aeb4:	d9400017 	ldw	r5,0(sp)
 820aeb8:	8009883a 	mov	r4,r16
 820aebc:	dfc00317 	ldw	ra,12(sp)
 820aec0:	dc000217 	ldw	r16,8(sp)
 820aec4:	dec00404 	addi	sp,sp,16
 820aec8:	82033dc1 	jmpi	82033dc <_putc_r>

0820aecc <fputc>:
 820aecc:	00820974 	movhi	r2,2085
 820aed0:	defffc04 	addi	sp,sp,-16
 820aed4:	108f9904 	addi	r2,r2,15972
 820aed8:	dc000115 	stw	r16,4(sp)
 820aedc:	14000017 	ldw	r16,0(r2)
 820aee0:	dc400215 	stw	r17,8(sp)
 820aee4:	dfc00315 	stw	ra,12(sp)
 820aee8:	2023883a 	mov	r17,r4
 820aeec:	80000626 	beq	r16,zero,820af08 <fputc+0x3c>
 820aef0:	80800e17 	ldw	r2,56(r16)
 820aef4:	1000041e 	bne	r2,zero,820af08 <fputc+0x3c>
 820aef8:	8009883a 	mov	r4,r16
 820aefc:	d9400015 	stw	r5,0(sp)
 820af00:	820ae380 	call	820ae38 <__sinit>
 820af04:	d9400017 	ldw	r5,0(sp)
 820af08:	280d883a 	mov	r6,r5
 820af0c:	8009883a 	mov	r4,r16
 820af10:	880b883a 	mov	r5,r17
 820af14:	dfc00317 	ldw	ra,12(sp)
 820af18:	dc400217 	ldw	r17,8(sp)
 820af1c:	dc000117 	ldw	r16,4(sp)
 820af20:	dec00404 	addi	sp,sp,16
 820af24:	82033dc1 	jmpi	82033dc <_putc_r>

0820af28 <_fputs_r>:
 820af28:	defff804 	addi	sp,sp,-32
 820af2c:	dc400615 	stw	r17,24(sp)
 820af30:	2023883a 	mov	r17,r4
 820af34:	2809883a 	mov	r4,r5
 820af38:	dc000515 	stw	r16,20(sp)
 820af3c:	dfc00715 	stw	ra,28(sp)
 820af40:	3021883a 	mov	r16,r6
 820af44:	d9400315 	stw	r5,12(sp)
 820af48:	8203f600 	call	8203f60 <strlen>
 820af4c:	d8800215 	stw	r2,8(sp)
 820af50:	d8800415 	stw	r2,16(sp)
 820af54:	d8800304 	addi	r2,sp,12
 820af58:	d8800015 	stw	r2,0(sp)
 820af5c:	00800044 	movi	r2,1
 820af60:	d8800115 	stw	r2,4(sp)
 820af64:	88000226 	beq	r17,zero,820af70 <_fputs_r+0x48>
 820af68:	88800e17 	ldw	r2,56(r17)
 820af6c:	10001226 	beq	r2,zero,820afb8 <_fputs_r+0x90>
 820af70:	8080030b 	ldhu	r2,12(r16)
 820af74:	10c8000c 	andi	r3,r2,8192
 820af78:	1800061e 	bne	r3,zero,820af94 <_fputs_r+0x6c>
 820af7c:	81001917 	ldw	r4,100(r16)
 820af80:	00f7ffc4 	movi	r3,-8193
 820af84:	10880014 	ori	r2,r2,8192
 820af88:	20c6703a 	and	r3,r4,r3
 820af8c:	8080030d 	sth	r2,12(r16)
 820af90:	80c01915 	stw	r3,100(r16)
 820af94:	d80d883a 	mov	r6,sp
 820af98:	800b883a 	mov	r5,r16
 820af9c:	8809883a 	mov	r4,r17
 820afa0:	820b4100 	call	820b410 <__sfvwrite_r>
 820afa4:	dfc00717 	ldw	ra,28(sp)
 820afa8:	dc400617 	ldw	r17,24(sp)
 820afac:	dc000517 	ldw	r16,20(sp)
 820afb0:	dec00804 	addi	sp,sp,32
 820afb4:	f800283a 	ret
 820afb8:	8809883a 	mov	r4,r17
 820afbc:	820ae380 	call	820ae38 <__sinit>
 820afc0:	003feb06 	br	820af70 <_fputs_r+0x48>

0820afc4 <fputs>:
 820afc4:	00820974 	movhi	r2,2085
 820afc8:	108f9904 	addi	r2,r2,15972
 820afcc:	280d883a 	mov	r6,r5
 820afd0:	200b883a 	mov	r5,r4
 820afd4:	11000017 	ldw	r4,0(r2)
 820afd8:	820af281 	jmpi	820af28 <_fputs_r>

0820afdc <_malloc_trim_r>:
 820afdc:	defffb04 	addi	sp,sp,-20
 820afe0:	dcc00315 	stw	r19,12(sp)
 820afe4:	04c20974 	movhi	r19,2085
 820afe8:	dc800215 	stw	r18,8(sp)
 820afec:	dc400115 	stw	r17,4(sp)
 820aff0:	dc000015 	stw	r16,0(sp)
 820aff4:	dfc00415 	stw	ra,16(sp)
 820aff8:	2821883a 	mov	r16,r5
 820affc:	9cc92704 	addi	r19,r19,9372
 820b000:	2025883a 	mov	r18,r4
 820b004:	82149f80 	call	82149f8 <__malloc_lock>
 820b008:	98800217 	ldw	r2,8(r19)
 820b00c:	14400117 	ldw	r17,4(r2)
 820b010:	00bfff04 	movi	r2,-4
 820b014:	88a2703a 	and	r17,r17,r2
 820b018:	8c21c83a 	sub	r16,r17,r16
 820b01c:	8403fbc4 	addi	r16,r16,4079
 820b020:	8020d33a 	srli	r16,r16,12
 820b024:	0083ffc4 	movi	r2,4095
 820b028:	843fffc4 	addi	r16,r16,-1
 820b02c:	8020933a 	slli	r16,r16,12
 820b030:	1400060e 	bge	r2,r16,820b04c <_malloc_trim_r+0x70>
 820b034:	000b883a 	mov	r5,zero
 820b038:	9009883a 	mov	r4,r18
 820b03c:	820de1c0 	call	820de1c <_sbrk_r>
 820b040:	98c00217 	ldw	r3,8(r19)
 820b044:	1c47883a 	add	r3,r3,r17
 820b048:	10c00a26 	beq	r2,r3,820b074 <_malloc_trim_r+0x98>
 820b04c:	9009883a 	mov	r4,r18
 820b050:	8214b180 	call	8214b18 <__malloc_unlock>
 820b054:	0005883a 	mov	r2,zero
 820b058:	dfc00417 	ldw	ra,16(sp)
 820b05c:	dcc00317 	ldw	r19,12(sp)
 820b060:	dc800217 	ldw	r18,8(sp)
 820b064:	dc400117 	ldw	r17,4(sp)
 820b068:	dc000017 	ldw	r16,0(sp)
 820b06c:	dec00504 	addi	sp,sp,20
 820b070:	f800283a 	ret
 820b074:	040bc83a 	sub	r5,zero,r16
 820b078:	9009883a 	mov	r4,r18
 820b07c:	820de1c0 	call	820de1c <_sbrk_r>
 820b080:	00ffffc4 	movi	r3,-1
 820b084:	10c00d26 	beq	r2,r3,820b0bc <_malloc_trim_r+0xe0>
 820b088:	00c20974 	movhi	r3,2085
 820b08c:	18d1f004 	addi	r3,r3,18368
 820b090:	18800017 	ldw	r2,0(r3)
 820b094:	99000217 	ldw	r4,8(r19)
 820b098:	8c23c83a 	sub	r17,r17,r16
 820b09c:	8c400054 	ori	r17,r17,1
 820b0a0:	1421c83a 	sub	r16,r2,r16
 820b0a4:	24400115 	stw	r17,4(r4)
 820b0a8:	9009883a 	mov	r4,r18
 820b0ac:	1c000015 	stw	r16,0(r3)
 820b0b0:	8214b180 	call	8214b18 <__malloc_unlock>
 820b0b4:	00800044 	movi	r2,1
 820b0b8:	003fe706 	br	820b058 <_malloc_trim_r+0x7c>
 820b0bc:	000b883a 	mov	r5,zero
 820b0c0:	9009883a 	mov	r4,r18
 820b0c4:	820de1c0 	call	820de1c <_sbrk_r>
 820b0c8:	99000217 	ldw	r4,8(r19)
 820b0cc:	014003c4 	movi	r5,15
 820b0d0:	1107c83a 	sub	r3,r2,r4
 820b0d4:	28ffdd0e 	bge	r5,r3,820b04c <_malloc_trim_r+0x70>
 820b0d8:	01420974 	movhi	r5,2085
 820b0dc:	294f9b04 	addi	r5,r5,15980
 820b0e0:	29400017 	ldw	r5,0(r5)
 820b0e4:	18c00054 	ori	r3,r3,1
 820b0e8:	20c00115 	stw	r3,4(r4)
 820b0ec:	00c20974 	movhi	r3,2085
 820b0f0:	1145c83a 	sub	r2,r2,r5
 820b0f4:	18d1f004 	addi	r3,r3,18368
 820b0f8:	18800015 	stw	r2,0(r3)
 820b0fc:	003fd306 	br	820b04c <_malloc_trim_r+0x70>

0820b100 <_free_r>:
 820b100:	28004126 	beq	r5,zero,820b208 <_free_r+0x108>
 820b104:	defffd04 	addi	sp,sp,-12
 820b108:	dc400115 	stw	r17,4(sp)
 820b10c:	dc000015 	stw	r16,0(sp)
 820b110:	2023883a 	mov	r17,r4
 820b114:	2821883a 	mov	r16,r5
 820b118:	dfc00215 	stw	ra,8(sp)
 820b11c:	82149f80 	call	82149f8 <__malloc_lock>
 820b120:	81ffff17 	ldw	r7,-4(r16)
 820b124:	00bfff84 	movi	r2,-2
 820b128:	01020974 	movhi	r4,2085
 820b12c:	81bffe04 	addi	r6,r16,-8
 820b130:	3884703a 	and	r2,r7,r2
 820b134:	21092704 	addi	r4,r4,9372
 820b138:	308b883a 	add	r5,r6,r2
 820b13c:	2a400117 	ldw	r9,4(r5)
 820b140:	22000217 	ldw	r8,8(r4)
 820b144:	00ffff04 	movi	r3,-4
 820b148:	48c6703a 	and	r3,r9,r3
 820b14c:	2a005726 	beq	r5,r8,820b2ac <_free_r+0x1ac>
 820b150:	28c00115 	stw	r3,4(r5)
 820b154:	39c0004c 	andi	r7,r7,1
 820b158:	3800091e 	bne	r7,zero,820b180 <_free_r+0x80>
 820b15c:	823ffe17 	ldw	r8,-8(r16)
 820b160:	22400204 	addi	r9,r4,8
 820b164:	320dc83a 	sub	r6,r6,r8
 820b168:	31c00217 	ldw	r7,8(r6)
 820b16c:	1205883a 	add	r2,r2,r8
 820b170:	3a406526 	beq	r7,r9,820b308 <_free_r+0x208>
 820b174:	32000317 	ldw	r8,12(r6)
 820b178:	3a000315 	stw	r8,12(r7)
 820b17c:	41c00215 	stw	r7,8(r8)
 820b180:	28cf883a 	add	r7,r5,r3
 820b184:	39c00117 	ldw	r7,4(r7)
 820b188:	39c0004c 	andi	r7,r7,1
 820b18c:	38003a26 	beq	r7,zero,820b278 <_free_r+0x178>
 820b190:	10c00054 	ori	r3,r2,1
 820b194:	30c00115 	stw	r3,4(r6)
 820b198:	3087883a 	add	r3,r6,r2
 820b19c:	18800015 	stw	r2,0(r3)
 820b1a0:	00c07fc4 	movi	r3,511
 820b1a4:	18801936 	bltu	r3,r2,820b20c <_free_r+0x10c>
 820b1a8:	1004d0fa 	srli	r2,r2,3
 820b1ac:	01c00044 	movi	r7,1
 820b1b0:	21400117 	ldw	r5,4(r4)
 820b1b4:	10c00044 	addi	r3,r2,1
 820b1b8:	18c7883a 	add	r3,r3,r3
 820b1bc:	1005d0ba 	srai	r2,r2,2
 820b1c0:	18c7883a 	add	r3,r3,r3
 820b1c4:	18c7883a 	add	r3,r3,r3
 820b1c8:	1907883a 	add	r3,r3,r4
 820b1cc:	3884983a 	sll	r2,r7,r2
 820b1d0:	19c00017 	ldw	r7,0(r3)
 820b1d4:	1a3ffe04 	addi	r8,r3,-8
 820b1d8:	1144b03a 	or	r2,r2,r5
 820b1dc:	32000315 	stw	r8,12(r6)
 820b1e0:	31c00215 	stw	r7,8(r6)
 820b1e4:	20800115 	stw	r2,4(r4)
 820b1e8:	19800015 	stw	r6,0(r3)
 820b1ec:	39800315 	stw	r6,12(r7)
 820b1f0:	8809883a 	mov	r4,r17
 820b1f4:	dfc00217 	ldw	ra,8(sp)
 820b1f8:	dc400117 	ldw	r17,4(sp)
 820b1fc:	dc000017 	ldw	r16,0(sp)
 820b200:	dec00304 	addi	sp,sp,12
 820b204:	8214b181 	jmpi	8214b18 <__malloc_unlock>
 820b208:	f800283a 	ret
 820b20c:	100ad27a 	srli	r5,r2,9
 820b210:	00c00104 	movi	r3,4
 820b214:	19404a36 	bltu	r3,r5,820b340 <_free_r+0x240>
 820b218:	100ad1ba 	srli	r5,r2,6
 820b21c:	28c00e44 	addi	r3,r5,57
 820b220:	18c7883a 	add	r3,r3,r3
 820b224:	29400e04 	addi	r5,r5,56
 820b228:	18c7883a 	add	r3,r3,r3
 820b22c:	18c7883a 	add	r3,r3,r3
 820b230:	1909883a 	add	r4,r3,r4
 820b234:	20c00017 	ldw	r3,0(r4)
 820b238:	01c20974 	movhi	r7,2085
 820b23c:	213ffe04 	addi	r4,r4,-8
 820b240:	39c92704 	addi	r7,r7,9372
 820b244:	20c04426 	beq	r4,r3,820b358 <_free_r+0x258>
 820b248:	01ffff04 	movi	r7,-4
 820b24c:	19400117 	ldw	r5,4(r3)
 820b250:	29ca703a 	and	r5,r5,r7
 820b254:	1140022e 	bgeu	r2,r5,820b260 <_free_r+0x160>
 820b258:	18c00217 	ldw	r3,8(r3)
 820b25c:	20fffb1e 	bne	r4,r3,820b24c <_free_r+0x14c>
 820b260:	19000317 	ldw	r4,12(r3)
 820b264:	31000315 	stw	r4,12(r6)
 820b268:	30c00215 	stw	r3,8(r6)
 820b26c:	21800215 	stw	r6,8(r4)
 820b270:	19800315 	stw	r6,12(r3)
 820b274:	003fde06 	br	820b1f0 <_free_r+0xf0>
 820b278:	29c00217 	ldw	r7,8(r5)
 820b27c:	10c5883a 	add	r2,r2,r3
 820b280:	00c20974 	movhi	r3,2085
 820b284:	18c92904 	addi	r3,r3,9380
 820b288:	38c03b26 	beq	r7,r3,820b378 <_free_r+0x278>
 820b28c:	2a000317 	ldw	r8,12(r5)
 820b290:	11400054 	ori	r5,r2,1
 820b294:	3087883a 	add	r3,r6,r2
 820b298:	3a000315 	stw	r8,12(r7)
 820b29c:	41c00215 	stw	r7,8(r8)
 820b2a0:	31400115 	stw	r5,4(r6)
 820b2a4:	18800015 	stw	r2,0(r3)
 820b2a8:	003fbd06 	br	820b1a0 <_free_r+0xa0>
 820b2ac:	39c0004c 	andi	r7,r7,1
 820b2b0:	10c5883a 	add	r2,r2,r3
 820b2b4:	3800071e 	bne	r7,zero,820b2d4 <_free_r+0x1d4>
 820b2b8:	81fffe17 	ldw	r7,-8(r16)
 820b2bc:	31cdc83a 	sub	r6,r6,r7
 820b2c0:	30c00317 	ldw	r3,12(r6)
 820b2c4:	31400217 	ldw	r5,8(r6)
 820b2c8:	11c5883a 	add	r2,r2,r7
 820b2cc:	28c00315 	stw	r3,12(r5)
 820b2d0:	19400215 	stw	r5,8(r3)
 820b2d4:	10c00054 	ori	r3,r2,1
 820b2d8:	30c00115 	stw	r3,4(r6)
 820b2dc:	00c20974 	movhi	r3,2085
 820b2e0:	18cf9c04 	addi	r3,r3,15984
 820b2e4:	18c00017 	ldw	r3,0(r3)
 820b2e8:	21800215 	stw	r6,8(r4)
 820b2ec:	10ffc036 	bltu	r2,r3,820b1f0 <_free_r+0xf0>
 820b2f0:	00820974 	movhi	r2,2085
 820b2f4:	108ff904 	addi	r2,r2,16356
 820b2f8:	11400017 	ldw	r5,0(r2)
 820b2fc:	8809883a 	mov	r4,r17
 820b300:	820afdc0 	call	820afdc <_malloc_trim_r>
 820b304:	003fba06 	br	820b1f0 <_free_r+0xf0>
 820b308:	28c9883a 	add	r4,r5,r3
 820b30c:	21000117 	ldw	r4,4(r4)
 820b310:	2100004c 	andi	r4,r4,1
 820b314:	2000391e 	bne	r4,zero,820b3fc <_free_r+0x2fc>
 820b318:	29c00217 	ldw	r7,8(r5)
 820b31c:	29000317 	ldw	r4,12(r5)
 820b320:	1885883a 	add	r2,r3,r2
 820b324:	10c00054 	ori	r3,r2,1
 820b328:	39000315 	stw	r4,12(r7)
 820b32c:	21c00215 	stw	r7,8(r4)
 820b330:	30c00115 	stw	r3,4(r6)
 820b334:	308d883a 	add	r6,r6,r2
 820b338:	30800015 	stw	r2,0(r6)
 820b33c:	003fac06 	br	820b1f0 <_free_r+0xf0>
 820b340:	00c00504 	movi	r3,20
 820b344:	19401536 	bltu	r3,r5,820b39c <_free_r+0x29c>
 820b348:	28c01704 	addi	r3,r5,92
 820b34c:	18c7883a 	add	r3,r3,r3
 820b350:	294016c4 	addi	r5,r5,91
 820b354:	003fb406 	br	820b228 <_free_r+0x128>
 820b358:	280bd0ba 	srai	r5,r5,2
 820b35c:	00c00044 	movi	r3,1
 820b360:	38800117 	ldw	r2,4(r7)
 820b364:	194a983a 	sll	r5,r3,r5
 820b368:	2007883a 	mov	r3,r4
 820b36c:	2884b03a 	or	r2,r5,r2
 820b370:	38800115 	stw	r2,4(r7)
 820b374:	003fbb06 	br	820b264 <_free_r+0x164>
 820b378:	21800515 	stw	r6,20(r4)
 820b37c:	21800415 	stw	r6,16(r4)
 820b380:	10c00054 	ori	r3,r2,1
 820b384:	31c00315 	stw	r7,12(r6)
 820b388:	31c00215 	stw	r7,8(r6)
 820b38c:	30c00115 	stw	r3,4(r6)
 820b390:	308d883a 	add	r6,r6,r2
 820b394:	30800015 	stw	r2,0(r6)
 820b398:	003f9506 	br	820b1f0 <_free_r+0xf0>
 820b39c:	00c01504 	movi	r3,84
 820b3a0:	19400536 	bltu	r3,r5,820b3b8 <_free_r+0x2b8>
 820b3a4:	100ad33a 	srli	r5,r2,12
 820b3a8:	28c01bc4 	addi	r3,r5,111
 820b3ac:	18c7883a 	add	r3,r3,r3
 820b3b0:	29401b84 	addi	r5,r5,110
 820b3b4:	003f9c06 	br	820b228 <_free_r+0x128>
 820b3b8:	00c05504 	movi	r3,340
 820b3bc:	19400536 	bltu	r3,r5,820b3d4 <_free_r+0x2d4>
 820b3c0:	100ad3fa 	srli	r5,r2,15
 820b3c4:	28c01e04 	addi	r3,r5,120
 820b3c8:	18c7883a 	add	r3,r3,r3
 820b3cc:	29401dc4 	addi	r5,r5,119
 820b3d0:	003f9506 	br	820b228 <_free_r+0x128>
 820b3d4:	00c15504 	movi	r3,1364
 820b3d8:	19400536 	bltu	r3,r5,820b3f0 <_free_r+0x2f0>
 820b3dc:	100ad4ba 	srli	r5,r2,18
 820b3e0:	28c01f44 	addi	r3,r5,125
 820b3e4:	18c7883a 	add	r3,r3,r3
 820b3e8:	29401f04 	addi	r5,r5,124
 820b3ec:	003f8e06 	br	820b228 <_free_r+0x128>
 820b3f0:	00c03f84 	movi	r3,254
 820b3f4:	01401f84 	movi	r5,126
 820b3f8:	003f8b06 	br	820b228 <_free_r+0x128>
 820b3fc:	10c00054 	ori	r3,r2,1
 820b400:	30c00115 	stw	r3,4(r6)
 820b404:	308d883a 	add	r6,r6,r2
 820b408:	30800015 	stw	r2,0(r6)
 820b40c:	003f7806 	br	820b1f0 <_free_r+0xf0>

0820b410 <__sfvwrite_r>:
 820b410:	30800217 	ldw	r2,8(r6)
 820b414:	10006726 	beq	r2,zero,820b5b4 <__sfvwrite_r+0x1a4>
 820b418:	28c0030b 	ldhu	r3,12(r5)
 820b41c:	defff404 	addi	sp,sp,-48
 820b420:	dd400715 	stw	r21,28(sp)
 820b424:	dd000615 	stw	r20,24(sp)
 820b428:	dc000215 	stw	r16,8(sp)
 820b42c:	dfc00b15 	stw	ra,44(sp)
 820b430:	df000a15 	stw	fp,40(sp)
 820b434:	ddc00915 	stw	r23,36(sp)
 820b438:	dd800815 	stw	r22,32(sp)
 820b43c:	dcc00515 	stw	r19,20(sp)
 820b440:	dc800415 	stw	r18,16(sp)
 820b444:	dc400315 	stw	r17,12(sp)
 820b448:	1880020c 	andi	r2,r3,8
 820b44c:	2821883a 	mov	r16,r5
 820b450:	202b883a 	mov	r21,r4
 820b454:	3029883a 	mov	r20,r6
 820b458:	10002726 	beq	r2,zero,820b4f8 <__sfvwrite_r+0xe8>
 820b45c:	28800417 	ldw	r2,16(r5)
 820b460:	10002526 	beq	r2,zero,820b4f8 <__sfvwrite_r+0xe8>
 820b464:	1880008c 	andi	r2,r3,2
 820b468:	a4400017 	ldw	r17,0(r20)
 820b46c:	10002a26 	beq	r2,zero,820b518 <__sfvwrite_r+0x108>
 820b470:	05a00034 	movhi	r22,32768
 820b474:	0027883a 	mov	r19,zero
 820b478:	0025883a 	mov	r18,zero
 820b47c:	b5bf0004 	addi	r22,r22,-1024
 820b480:	980d883a 	mov	r6,r19
 820b484:	a809883a 	mov	r4,r21
 820b488:	90004626 	beq	r18,zero,820b5a4 <__sfvwrite_r+0x194>
 820b48c:	900f883a 	mov	r7,r18
 820b490:	b480022e 	bgeu	r22,r18,820b49c <__sfvwrite_r+0x8c>
 820b494:	01e00034 	movhi	r7,32768
 820b498:	39ff0004 	addi	r7,r7,-1024
 820b49c:	80800917 	ldw	r2,36(r16)
 820b4a0:	81400717 	ldw	r5,28(r16)
 820b4a4:	103ee83a 	callr	r2
 820b4a8:	0080570e 	bge	zero,r2,820b608 <__sfvwrite_r+0x1f8>
 820b4ac:	a0c00217 	ldw	r3,8(r20)
 820b4b0:	98a7883a 	add	r19,r19,r2
 820b4b4:	90a5c83a 	sub	r18,r18,r2
 820b4b8:	1885c83a 	sub	r2,r3,r2
 820b4bc:	a0800215 	stw	r2,8(r20)
 820b4c0:	103fef1e 	bne	r2,zero,820b480 <__sfvwrite_r+0x70>
 820b4c4:	0005883a 	mov	r2,zero
 820b4c8:	dfc00b17 	ldw	ra,44(sp)
 820b4cc:	df000a17 	ldw	fp,40(sp)
 820b4d0:	ddc00917 	ldw	r23,36(sp)
 820b4d4:	dd800817 	ldw	r22,32(sp)
 820b4d8:	dd400717 	ldw	r21,28(sp)
 820b4dc:	dd000617 	ldw	r20,24(sp)
 820b4e0:	dcc00517 	ldw	r19,20(sp)
 820b4e4:	dc800417 	ldw	r18,16(sp)
 820b4e8:	dc400317 	ldw	r17,12(sp)
 820b4ec:	dc000217 	ldw	r16,8(sp)
 820b4f0:	dec00c04 	addi	sp,sp,48
 820b4f4:	f800283a 	ret
 820b4f8:	800b883a 	mov	r5,r16
 820b4fc:	a809883a 	mov	r4,r21
 820b500:	8208e640 	call	8208e64 <__swsetup_r>
 820b504:	1000eb1e 	bne	r2,zero,820b8b4 <__sfvwrite_r+0x4a4>
 820b508:	80c0030b 	ldhu	r3,12(r16)
 820b50c:	a4400017 	ldw	r17,0(r20)
 820b510:	1880008c 	andi	r2,r3,2
 820b514:	103fd61e 	bne	r2,zero,820b470 <__sfvwrite_r+0x60>
 820b518:	1880004c 	andi	r2,r3,1
 820b51c:	10003f1e 	bne	r2,zero,820b61c <__sfvwrite_r+0x20c>
 820b520:	0039883a 	mov	fp,zero
 820b524:	0025883a 	mov	r18,zero
 820b528:	90001a26 	beq	r18,zero,820b594 <__sfvwrite_r+0x184>
 820b52c:	1880800c 	andi	r2,r3,512
 820b530:	84c00217 	ldw	r19,8(r16)
 820b534:	10002126 	beq	r2,zero,820b5bc <__sfvwrite_r+0x1ac>
 820b538:	982f883a 	mov	r23,r19
 820b53c:	94c09336 	bltu	r18,r19,820b78c <__sfvwrite_r+0x37c>
 820b540:	1881200c 	andi	r2,r3,1152
 820b544:	10009e1e 	bne	r2,zero,820b7c0 <__sfvwrite_r+0x3b0>
 820b548:	81000017 	ldw	r4,0(r16)
 820b54c:	b80d883a 	mov	r6,r23
 820b550:	e00b883a 	mov	r5,fp
 820b554:	82030580 	call	8203058 <memmove>
 820b558:	80c00217 	ldw	r3,8(r16)
 820b55c:	81000017 	ldw	r4,0(r16)
 820b560:	9005883a 	mov	r2,r18
 820b564:	1ce7c83a 	sub	r19,r3,r19
 820b568:	25cf883a 	add	r7,r4,r23
 820b56c:	84c00215 	stw	r19,8(r16)
 820b570:	81c00015 	stw	r7,0(r16)
 820b574:	a0c00217 	ldw	r3,8(r20)
 820b578:	e0b9883a 	add	fp,fp,r2
 820b57c:	90a5c83a 	sub	r18,r18,r2
 820b580:	18a7c83a 	sub	r19,r3,r2
 820b584:	a4c00215 	stw	r19,8(r20)
 820b588:	983fce26 	beq	r19,zero,820b4c4 <__sfvwrite_r+0xb4>
 820b58c:	80c0030b 	ldhu	r3,12(r16)
 820b590:	903fe61e 	bne	r18,zero,820b52c <__sfvwrite_r+0x11c>
 820b594:	8f000017 	ldw	fp,0(r17)
 820b598:	8c800117 	ldw	r18,4(r17)
 820b59c:	8c400204 	addi	r17,r17,8
 820b5a0:	003fe106 	br	820b528 <__sfvwrite_r+0x118>
 820b5a4:	8cc00017 	ldw	r19,0(r17)
 820b5a8:	8c800117 	ldw	r18,4(r17)
 820b5ac:	8c400204 	addi	r17,r17,8
 820b5b0:	003fb306 	br	820b480 <__sfvwrite_r+0x70>
 820b5b4:	0005883a 	mov	r2,zero
 820b5b8:	f800283a 	ret
 820b5bc:	81000017 	ldw	r4,0(r16)
 820b5c0:	80800417 	ldw	r2,16(r16)
 820b5c4:	11005736 	bltu	r2,r4,820b724 <__sfvwrite_r+0x314>
 820b5c8:	85c00517 	ldw	r23,20(r16)
 820b5cc:	95c05536 	bltu	r18,r23,820b724 <__sfvwrite_r+0x314>
 820b5d0:	00a00034 	movhi	r2,32768
 820b5d4:	10bfffc4 	addi	r2,r2,-1
 820b5d8:	9009883a 	mov	r4,r18
 820b5dc:	1480012e 	bgeu	r2,r18,820b5e4 <__sfvwrite_r+0x1d4>
 820b5e0:	1009883a 	mov	r4,r2
 820b5e4:	b80b883a 	mov	r5,r23
 820b5e8:	8202b180 	call	8202b18 <__divsi3>
 820b5ec:	15cf383a 	mul	r7,r2,r23
 820b5f0:	81400717 	ldw	r5,28(r16)
 820b5f4:	80800917 	ldw	r2,36(r16)
 820b5f8:	e00d883a 	mov	r6,fp
 820b5fc:	a809883a 	mov	r4,r21
 820b600:	103ee83a 	callr	r2
 820b604:	00bfdb16 	blt	zero,r2,820b574 <__sfvwrite_r+0x164>
 820b608:	8080030b 	ldhu	r2,12(r16)
 820b60c:	10801014 	ori	r2,r2,64
 820b610:	8080030d 	sth	r2,12(r16)
 820b614:	00bfffc4 	movi	r2,-1
 820b618:	003fab06 	br	820b4c8 <__sfvwrite_r+0xb8>
 820b61c:	0027883a 	mov	r19,zero
 820b620:	0011883a 	mov	r8,zero
 820b624:	0039883a 	mov	fp,zero
 820b628:	0025883a 	mov	r18,zero
 820b62c:	90001f26 	beq	r18,zero,820b6ac <__sfvwrite_r+0x29c>
 820b630:	40005a26 	beq	r8,zero,820b79c <__sfvwrite_r+0x38c>
 820b634:	982d883a 	mov	r22,r19
 820b638:	94c0012e 	bgeu	r18,r19,820b640 <__sfvwrite_r+0x230>
 820b63c:	902d883a 	mov	r22,r18
 820b640:	81000017 	ldw	r4,0(r16)
 820b644:	80800417 	ldw	r2,16(r16)
 820b648:	b02f883a 	mov	r23,r22
 820b64c:	81c00517 	ldw	r7,20(r16)
 820b650:	1100032e 	bgeu	r2,r4,820b660 <__sfvwrite_r+0x250>
 820b654:	80c00217 	ldw	r3,8(r16)
 820b658:	38c7883a 	add	r3,r7,r3
 820b65c:	1d801816 	blt	r3,r22,820b6c0 <__sfvwrite_r+0x2b0>
 820b660:	b1c03e16 	blt	r22,r7,820b75c <__sfvwrite_r+0x34c>
 820b664:	80800917 	ldw	r2,36(r16)
 820b668:	81400717 	ldw	r5,28(r16)
 820b66c:	e00d883a 	mov	r6,fp
 820b670:	da000115 	stw	r8,4(sp)
 820b674:	a809883a 	mov	r4,r21
 820b678:	103ee83a 	callr	r2
 820b67c:	102f883a 	mov	r23,r2
 820b680:	da000117 	ldw	r8,4(sp)
 820b684:	00bfe00e 	bge	zero,r2,820b608 <__sfvwrite_r+0x1f8>
 820b688:	9de7c83a 	sub	r19,r19,r23
 820b68c:	98001f26 	beq	r19,zero,820b70c <__sfvwrite_r+0x2fc>
 820b690:	a0800217 	ldw	r2,8(r20)
 820b694:	e5f9883a 	add	fp,fp,r23
 820b698:	95e5c83a 	sub	r18,r18,r23
 820b69c:	15efc83a 	sub	r23,r2,r23
 820b6a0:	a5c00215 	stw	r23,8(r20)
 820b6a4:	b83f8726 	beq	r23,zero,820b4c4 <__sfvwrite_r+0xb4>
 820b6a8:	903fe11e 	bne	r18,zero,820b630 <__sfvwrite_r+0x220>
 820b6ac:	8f000017 	ldw	fp,0(r17)
 820b6b0:	8c800117 	ldw	r18,4(r17)
 820b6b4:	0011883a 	mov	r8,zero
 820b6b8:	8c400204 	addi	r17,r17,8
 820b6bc:	003fdb06 	br	820b62c <__sfvwrite_r+0x21c>
 820b6c0:	180d883a 	mov	r6,r3
 820b6c4:	e00b883a 	mov	r5,fp
 820b6c8:	da000115 	stw	r8,4(sp)
 820b6cc:	d8c00015 	stw	r3,0(sp)
 820b6d0:	82030580 	call	8203058 <memmove>
 820b6d4:	d8c00017 	ldw	r3,0(sp)
 820b6d8:	80800017 	ldw	r2,0(r16)
 820b6dc:	800b883a 	mov	r5,r16
 820b6e0:	a809883a 	mov	r4,r21
 820b6e4:	10c5883a 	add	r2,r2,r3
 820b6e8:	80800015 	stw	r2,0(r16)
 820b6ec:	d8c00015 	stw	r3,0(sp)
 820b6f0:	820aa5c0 	call	820aa5c <_fflush_r>
 820b6f4:	d8c00017 	ldw	r3,0(sp)
 820b6f8:	da000117 	ldw	r8,4(sp)
 820b6fc:	103fc21e 	bne	r2,zero,820b608 <__sfvwrite_r+0x1f8>
 820b700:	182f883a 	mov	r23,r3
 820b704:	9de7c83a 	sub	r19,r19,r23
 820b708:	983fe11e 	bne	r19,zero,820b690 <__sfvwrite_r+0x280>
 820b70c:	800b883a 	mov	r5,r16
 820b710:	a809883a 	mov	r4,r21
 820b714:	820aa5c0 	call	820aa5c <_fflush_r>
 820b718:	103fbb1e 	bne	r2,zero,820b608 <__sfvwrite_r+0x1f8>
 820b71c:	0011883a 	mov	r8,zero
 820b720:	003fdb06 	br	820b690 <__sfvwrite_r+0x280>
 820b724:	94c0012e 	bgeu	r18,r19,820b72c <__sfvwrite_r+0x31c>
 820b728:	9027883a 	mov	r19,r18
 820b72c:	980d883a 	mov	r6,r19
 820b730:	e00b883a 	mov	r5,fp
 820b734:	82030580 	call	8203058 <memmove>
 820b738:	80800217 	ldw	r2,8(r16)
 820b73c:	80c00017 	ldw	r3,0(r16)
 820b740:	14c5c83a 	sub	r2,r2,r19
 820b744:	1cc7883a 	add	r3,r3,r19
 820b748:	80800215 	stw	r2,8(r16)
 820b74c:	80c00015 	stw	r3,0(r16)
 820b750:	10004326 	beq	r2,zero,820b860 <__sfvwrite_r+0x450>
 820b754:	9805883a 	mov	r2,r19
 820b758:	003f8606 	br	820b574 <__sfvwrite_r+0x164>
 820b75c:	b00d883a 	mov	r6,r22
 820b760:	e00b883a 	mov	r5,fp
 820b764:	da000115 	stw	r8,4(sp)
 820b768:	82030580 	call	8203058 <memmove>
 820b76c:	80800217 	ldw	r2,8(r16)
 820b770:	80c00017 	ldw	r3,0(r16)
 820b774:	da000117 	ldw	r8,4(sp)
 820b778:	1585c83a 	sub	r2,r2,r22
 820b77c:	1dad883a 	add	r22,r3,r22
 820b780:	80800215 	stw	r2,8(r16)
 820b784:	85800015 	stw	r22,0(r16)
 820b788:	003fbf06 	br	820b688 <__sfvwrite_r+0x278>
 820b78c:	81000017 	ldw	r4,0(r16)
 820b790:	9027883a 	mov	r19,r18
 820b794:	902f883a 	mov	r23,r18
 820b798:	003f6c06 	br	820b54c <__sfvwrite_r+0x13c>
 820b79c:	900d883a 	mov	r6,r18
 820b7a0:	01400284 	movi	r5,10
 820b7a4:	e009883a 	mov	r4,fp
 820b7a8:	820c4f80 	call	820c4f8 <memchr>
 820b7ac:	10003e26 	beq	r2,zero,820b8a8 <__sfvwrite_r+0x498>
 820b7b0:	10800044 	addi	r2,r2,1
 820b7b4:	1727c83a 	sub	r19,r2,fp
 820b7b8:	02000044 	movi	r8,1
 820b7bc:	003f9d06 	br	820b634 <__sfvwrite_r+0x224>
 820b7c0:	80800517 	ldw	r2,20(r16)
 820b7c4:	81400417 	ldw	r5,16(r16)
 820b7c8:	81c00017 	ldw	r7,0(r16)
 820b7cc:	10a7883a 	add	r19,r2,r2
 820b7d0:	9885883a 	add	r2,r19,r2
 820b7d4:	1026d7fa 	srli	r19,r2,31
 820b7d8:	396dc83a 	sub	r22,r7,r5
 820b7dc:	b1000044 	addi	r4,r22,1
 820b7e0:	9885883a 	add	r2,r19,r2
 820b7e4:	1027d07a 	srai	r19,r2,1
 820b7e8:	2485883a 	add	r2,r4,r18
 820b7ec:	980d883a 	mov	r6,r19
 820b7f0:	9880022e 	bgeu	r19,r2,820b7fc <__sfvwrite_r+0x3ec>
 820b7f4:	1027883a 	mov	r19,r2
 820b7f8:	100d883a 	mov	r6,r2
 820b7fc:	18c1000c 	andi	r3,r3,1024
 820b800:	18001c26 	beq	r3,zero,820b874 <__sfvwrite_r+0x464>
 820b804:	300b883a 	mov	r5,r6
 820b808:	a809883a 	mov	r4,r21
 820b80c:	820bcec0 	call	820bcec <_malloc_r>
 820b810:	102f883a 	mov	r23,r2
 820b814:	10002926 	beq	r2,zero,820b8bc <__sfvwrite_r+0x4ac>
 820b818:	81400417 	ldw	r5,16(r16)
 820b81c:	b00d883a 	mov	r6,r22
 820b820:	1009883a 	mov	r4,r2
 820b824:	8202f100 	call	8202f10 <memcpy>
 820b828:	8080030b 	ldhu	r2,12(r16)
 820b82c:	00fedfc4 	movi	r3,-1153
 820b830:	10c4703a 	and	r2,r2,r3
 820b834:	10802014 	ori	r2,r2,128
 820b838:	8080030d 	sth	r2,12(r16)
 820b83c:	bd89883a 	add	r4,r23,r22
 820b840:	9d8fc83a 	sub	r7,r19,r22
 820b844:	85c00415 	stw	r23,16(r16)
 820b848:	84c00515 	stw	r19,20(r16)
 820b84c:	81000015 	stw	r4,0(r16)
 820b850:	9027883a 	mov	r19,r18
 820b854:	81c00215 	stw	r7,8(r16)
 820b858:	902f883a 	mov	r23,r18
 820b85c:	003f3b06 	br	820b54c <__sfvwrite_r+0x13c>
 820b860:	800b883a 	mov	r5,r16
 820b864:	a809883a 	mov	r4,r21
 820b868:	820aa5c0 	call	820aa5c <_fflush_r>
 820b86c:	103fb926 	beq	r2,zero,820b754 <__sfvwrite_r+0x344>
 820b870:	003f6506 	br	820b608 <__sfvwrite_r+0x1f8>
 820b874:	a809883a 	mov	r4,r21
 820b878:	820d6540 	call	820d654 <_realloc_r>
 820b87c:	102f883a 	mov	r23,r2
 820b880:	103fee1e 	bne	r2,zero,820b83c <__sfvwrite_r+0x42c>
 820b884:	81400417 	ldw	r5,16(r16)
 820b888:	a809883a 	mov	r4,r21
 820b88c:	820b1000 	call	820b100 <_free_r>
 820b890:	8080030b 	ldhu	r2,12(r16)
 820b894:	00ffdfc4 	movi	r3,-129
 820b898:	1884703a 	and	r2,r3,r2
 820b89c:	00c00304 	movi	r3,12
 820b8a0:	a8c00015 	stw	r3,0(r21)
 820b8a4:	003f5906 	br	820b60c <__sfvwrite_r+0x1fc>
 820b8a8:	94c00044 	addi	r19,r18,1
 820b8ac:	02000044 	movi	r8,1
 820b8b0:	003f6006 	br	820b634 <__sfvwrite_r+0x224>
 820b8b4:	00bfffc4 	movi	r2,-1
 820b8b8:	003f0306 	br	820b4c8 <__sfvwrite_r+0xb8>
 820b8bc:	00800304 	movi	r2,12
 820b8c0:	a8800015 	stw	r2,0(r21)
 820b8c4:	8080030b 	ldhu	r2,12(r16)
 820b8c8:	003f5006 	br	820b60c <__sfvwrite_r+0x1fc>

0820b8cc <_fwalk>:
 820b8cc:	defff704 	addi	sp,sp,-36
 820b8d0:	dd000415 	stw	r20,16(sp)
 820b8d4:	dfc00815 	stw	ra,32(sp)
 820b8d8:	ddc00715 	stw	r23,28(sp)
 820b8dc:	dd800615 	stw	r22,24(sp)
 820b8e0:	dd400515 	stw	r21,20(sp)
 820b8e4:	dcc00315 	stw	r19,12(sp)
 820b8e8:	dc800215 	stw	r18,8(sp)
 820b8ec:	dc400115 	stw	r17,4(sp)
 820b8f0:	dc000015 	stw	r16,0(sp)
 820b8f4:	2500b804 	addi	r20,r4,736
 820b8f8:	a0002326 	beq	r20,zero,820b988 <_fwalk+0xbc>
 820b8fc:	282b883a 	mov	r21,r5
 820b900:	002f883a 	mov	r23,zero
 820b904:	05800044 	movi	r22,1
 820b908:	04ffffc4 	movi	r19,-1
 820b90c:	a4400117 	ldw	r17,4(r20)
 820b910:	a4800217 	ldw	r18,8(r20)
 820b914:	8c7fffc4 	addi	r17,r17,-1
 820b918:	88000d16 	blt	r17,zero,820b950 <_fwalk+0x84>
 820b91c:	94000304 	addi	r16,r18,12
 820b920:	94800384 	addi	r18,r18,14
 820b924:	8080000b 	ldhu	r2,0(r16)
 820b928:	8c7fffc4 	addi	r17,r17,-1
 820b92c:	813ffd04 	addi	r4,r16,-12
 820b930:	b080042e 	bgeu	r22,r2,820b944 <_fwalk+0x78>
 820b934:	9080000f 	ldh	r2,0(r18)
 820b938:	14c00226 	beq	r2,r19,820b944 <_fwalk+0x78>
 820b93c:	a83ee83a 	callr	r21
 820b940:	b8aeb03a 	or	r23,r23,r2
 820b944:	84001a04 	addi	r16,r16,104
 820b948:	94801a04 	addi	r18,r18,104
 820b94c:	8cfff51e 	bne	r17,r19,820b924 <_fwalk+0x58>
 820b950:	a5000017 	ldw	r20,0(r20)
 820b954:	a03fed1e 	bne	r20,zero,820b90c <_fwalk+0x40>
 820b958:	b805883a 	mov	r2,r23
 820b95c:	dfc00817 	ldw	ra,32(sp)
 820b960:	ddc00717 	ldw	r23,28(sp)
 820b964:	dd800617 	ldw	r22,24(sp)
 820b968:	dd400517 	ldw	r21,20(sp)
 820b96c:	dd000417 	ldw	r20,16(sp)
 820b970:	dcc00317 	ldw	r19,12(sp)
 820b974:	dc800217 	ldw	r18,8(sp)
 820b978:	dc400117 	ldw	r17,4(sp)
 820b97c:	dc000017 	ldw	r16,0(sp)
 820b980:	dec00904 	addi	sp,sp,36
 820b984:	f800283a 	ret
 820b988:	002f883a 	mov	r23,zero
 820b98c:	003ff206 	br	820b958 <_fwalk+0x8c>

0820b990 <_fwalk_reent>:
 820b990:	defff704 	addi	sp,sp,-36
 820b994:	dd000415 	stw	r20,16(sp)
 820b998:	dfc00815 	stw	ra,32(sp)
 820b99c:	ddc00715 	stw	r23,28(sp)
 820b9a0:	dd800615 	stw	r22,24(sp)
 820b9a4:	dd400515 	stw	r21,20(sp)
 820b9a8:	dcc00315 	stw	r19,12(sp)
 820b9ac:	dc800215 	stw	r18,8(sp)
 820b9b0:	dc400115 	stw	r17,4(sp)
 820b9b4:	dc000015 	stw	r16,0(sp)
 820b9b8:	2500b804 	addi	r20,r4,736
 820b9bc:	a0002326 	beq	r20,zero,820ba4c <_fwalk_reent+0xbc>
 820b9c0:	282b883a 	mov	r21,r5
 820b9c4:	2027883a 	mov	r19,r4
 820b9c8:	002f883a 	mov	r23,zero
 820b9cc:	05800044 	movi	r22,1
 820b9d0:	04bfffc4 	movi	r18,-1
 820b9d4:	a4400117 	ldw	r17,4(r20)
 820b9d8:	a4000217 	ldw	r16,8(r20)
 820b9dc:	8c7fffc4 	addi	r17,r17,-1
 820b9e0:	88000c16 	blt	r17,zero,820ba14 <_fwalk_reent+0x84>
 820b9e4:	84000304 	addi	r16,r16,12
 820b9e8:	8080000b 	ldhu	r2,0(r16)
 820b9ec:	8c7fffc4 	addi	r17,r17,-1
 820b9f0:	817ffd04 	addi	r5,r16,-12
 820b9f4:	b080052e 	bgeu	r22,r2,820ba0c <_fwalk_reent+0x7c>
 820b9f8:	8080008f 	ldh	r2,2(r16)
 820b9fc:	9809883a 	mov	r4,r19
 820ba00:	14800226 	beq	r2,r18,820ba0c <_fwalk_reent+0x7c>
 820ba04:	a83ee83a 	callr	r21
 820ba08:	b8aeb03a 	or	r23,r23,r2
 820ba0c:	84001a04 	addi	r16,r16,104
 820ba10:	8cbff51e 	bne	r17,r18,820b9e8 <_fwalk_reent+0x58>
 820ba14:	a5000017 	ldw	r20,0(r20)
 820ba18:	a03fee1e 	bne	r20,zero,820b9d4 <_fwalk_reent+0x44>
 820ba1c:	b805883a 	mov	r2,r23
 820ba20:	dfc00817 	ldw	ra,32(sp)
 820ba24:	ddc00717 	ldw	r23,28(sp)
 820ba28:	dd800617 	ldw	r22,24(sp)
 820ba2c:	dd400517 	ldw	r21,20(sp)
 820ba30:	dd000417 	ldw	r20,16(sp)
 820ba34:	dcc00317 	ldw	r19,12(sp)
 820ba38:	dc800217 	ldw	r18,8(sp)
 820ba3c:	dc400117 	ldw	r17,4(sp)
 820ba40:	dc000017 	ldw	r16,0(sp)
 820ba44:	dec00904 	addi	sp,sp,36
 820ba48:	f800283a 	ret
 820ba4c:	002f883a 	mov	r23,zero
 820ba50:	003ff206 	br	820ba1c <_fwalk_reent+0x8c>

0820ba54 <_setlocale_r>:
 820ba54:	30001b26 	beq	r6,zero,820bac4 <_setlocale_r+0x70>
 820ba58:	01420974 	movhi	r5,2085
 820ba5c:	defffe04 	addi	sp,sp,-8
 820ba60:	2976df04 	addi	r5,r5,-9348
 820ba64:	3009883a 	mov	r4,r6
 820ba68:	dc000015 	stw	r16,0(sp)
 820ba6c:	dfc00115 	stw	ra,4(sp)
 820ba70:	3021883a 	mov	r16,r6
 820ba74:	820dfac0 	call	820dfac <strcmp>
 820ba78:	1000061e 	bne	r2,zero,820ba94 <_setlocale_r+0x40>
 820ba7c:	00820974 	movhi	r2,2085
 820ba80:	10b4f704 	addi	r2,r2,-11300
 820ba84:	dfc00117 	ldw	ra,4(sp)
 820ba88:	dc000017 	ldw	r16,0(sp)
 820ba8c:	dec00204 	addi	sp,sp,8
 820ba90:	f800283a 	ret
 820ba94:	01420974 	movhi	r5,2085
 820ba98:	2974f704 	addi	r5,r5,-11300
 820ba9c:	8009883a 	mov	r4,r16
 820baa0:	820dfac0 	call	820dfac <strcmp>
 820baa4:	103ff526 	beq	r2,zero,820ba7c <_setlocale_r+0x28>
 820baa8:	01420974 	movhi	r5,2085
 820baac:	2976c204 	addi	r5,r5,-9464
 820bab0:	8009883a 	mov	r4,r16
 820bab4:	820dfac0 	call	820dfac <strcmp>
 820bab8:	103ff026 	beq	r2,zero,820ba7c <_setlocale_r+0x28>
 820babc:	0005883a 	mov	r2,zero
 820bac0:	003ff006 	br	820ba84 <_setlocale_r+0x30>
 820bac4:	00820974 	movhi	r2,2085
 820bac8:	10b4f704 	addi	r2,r2,-11300
 820bacc:	f800283a 	ret

0820bad0 <__locale_charset>:
 820bad0:	00820974 	movhi	r2,2085
 820bad4:	10891104 	addi	r2,r2,9284
 820bad8:	f800283a 	ret

0820badc <__locale_mb_cur_max>:
 820badc:	00820974 	movhi	r2,2085
 820bae0:	108f9a04 	addi	r2,r2,15976
 820bae4:	10800017 	ldw	r2,0(r2)
 820bae8:	f800283a 	ret

0820baec <__locale_msgcharset>:
 820baec:	00820974 	movhi	r2,2085
 820baf0:	10890904 	addi	r2,r2,9252
 820baf4:	f800283a 	ret

0820baf8 <__locale_cjk_lang>:
 820baf8:	0005883a 	mov	r2,zero
 820bafc:	f800283a 	ret

0820bb00 <_localeconv_r>:
 820bb00:	00820974 	movhi	r2,2085
 820bb04:	10891904 	addi	r2,r2,9316
 820bb08:	f800283a 	ret

0820bb0c <setlocale>:
 820bb0c:	00820974 	movhi	r2,2085
 820bb10:	108f9904 	addi	r2,r2,15972
 820bb14:	280d883a 	mov	r6,r5
 820bb18:	200b883a 	mov	r5,r4
 820bb1c:	11000017 	ldw	r4,0(r2)
 820bb20:	820ba541 	jmpi	820ba54 <_setlocale_r>

0820bb24 <localeconv>:
 820bb24:	00820974 	movhi	r2,2085
 820bb28:	10891904 	addi	r2,r2,9316
 820bb2c:	f800283a 	ret

0820bb30 <__smakebuf_r>:
 820bb30:	2880030b 	ldhu	r2,12(r5)
 820bb34:	10c0008c 	andi	r3,r2,2
 820bb38:	1800411e 	bne	r3,zero,820bc40 <__smakebuf_r+0x110>
 820bb3c:	deffec04 	addi	sp,sp,-80
 820bb40:	dc000f15 	stw	r16,60(sp)
 820bb44:	2821883a 	mov	r16,r5
 820bb48:	2940038f 	ldh	r5,14(r5)
 820bb4c:	dc401015 	stw	r17,64(sp)
 820bb50:	dfc01315 	stw	ra,76(sp)
 820bb54:	dcc01215 	stw	r19,72(sp)
 820bb58:	dc801115 	stw	r18,68(sp)
 820bb5c:	2023883a 	mov	r17,r4
 820bb60:	28001c16 	blt	r5,zero,820bbd4 <__smakebuf_r+0xa4>
 820bb64:	d80d883a 	mov	r6,sp
 820bb68:	8210f600 	call	8210f60 <_fstat_r>
 820bb6c:	10001816 	blt	r2,zero,820bbd0 <__smakebuf_r+0xa0>
 820bb70:	d8800117 	ldw	r2,4(sp)
 820bb74:	00e00014 	movui	r3,32768
 820bb78:	10bc000c 	andi	r2,r2,61440
 820bb7c:	14c80020 	cmpeqi	r19,r2,8192
 820bb80:	10c03726 	beq	r2,r3,820bc60 <__smakebuf_r+0x130>
 820bb84:	80c0030b 	ldhu	r3,12(r16)
 820bb88:	18c20014 	ori	r3,r3,2048
 820bb8c:	80c0030d 	sth	r3,12(r16)
 820bb90:	00c80004 	movi	r3,8192
 820bb94:	10c0521e 	bne	r2,r3,820bce0 <__smakebuf_r+0x1b0>
 820bb98:	8140038f 	ldh	r5,14(r16)
 820bb9c:	8809883a 	mov	r4,r17
 820bba0:	8210fbc0 	call	8210fbc <_isatty_r>
 820bba4:	10004c26 	beq	r2,zero,820bcd8 <__smakebuf_r+0x1a8>
 820bba8:	8080030b 	ldhu	r2,12(r16)
 820bbac:	80c010c4 	addi	r3,r16,67
 820bbb0:	80c00015 	stw	r3,0(r16)
 820bbb4:	10800054 	ori	r2,r2,1
 820bbb8:	8080030d 	sth	r2,12(r16)
 820bbbc:	00800044 	movi	r2,1
 820bbc0:	80c00415 	stw	r3,16(r16)
 820bbc4:	80800515 	stw	r2,20(r16)
 820bbc8:	04810004 	movi	r18,1024
 820bbcc:	00000706 	br	820bbec <__smakebuf_r+0xbc>
 820bbd0:	8080030b 	ldhu	r2,12(r16)
 820bbd4:	10c0200c 	andi	r3,r2,128
 820bbd8:	18001f1e 	bne	r3,zero,820bc58 <__smakebuf_r+0x128>
 820bbdc:	04810004 	movi	r18,1024
 820bbe0:	10820014 	ori	r2,r2,2048
 820bbe4:	8080030d 	sth	r2,12(r16)
 820bbe8:	0027883a 	mov	r19,zero
 820bbec:	900b883a 	mov	r5,r18
 820bbf0:	8809883a 	mov	r4,r17
 820bbf4:	820bcec0 	call	820bcec <_malloc_r>
 820bbf8:	10002c26 	beq	r2,zero,820bcac <__smakebuf_r+0x17c>
 820bbfc:	80c0030b 	ldhu	r3,12(r16)
 820bc00:	01020874 	movhi	r4,2081
 820bc04:	212abc04 	addi	r4,r4,-21776
 820bc08:	89000f15 	stw	r4,60(r17)
 820bc0c:	18c02014 	ori	r3,r3,128
 820bc10:	80c0030d 	sth	r3,12(r16)
 820bc14:	80800015 	stw	r2,0(r16)
 820bc18:	80800415 	stw	r2,16(r16)
 820bc1c:	84800515 	stw	r18,20(r16)
 820bc20:	98001a1e 	bne	r19,zero,820bc8c <__smakebuf_r+0x15c>
 820bc24:	dfc01317 	ldw	ra,76(sp)
 820bc28:	dcc01217 	ldw	r19,72(sp)
 820bc2c:	dc801117 	ldw	r18,68(sp)
 820bc30:	dc401017 	ldw	r17,64(sp)
 820bc34:	dc000f17 	ldw	r16,60(sp)
 820bc38:	dec01404 	addi	sp,sp,80
 820bc3c:	f800283a 	ret
 820bc40:	288010c4 	addi	r2,r5,67
 820bc44:	28800015 	stw	r2,0(r5)
 820bc48:	28800415 	stw	r2,16(r5)
 820bc4c:	00800044 	movi	r2,1
 820bc50:	28800515 	stw	r2,20(r5)
 820bc54:	f800283a 	ret
 820bc58:	04801004 	movi	r18,64
 820bc5c:	003fe006 	br	820bbe0 <__smakebuf_r+0xb0>
 820bc60:	81000a17 	ldw	r4,40(r16)
 820bc64:	00c20874 	movhi	r3,2081
 820bc68:	18f7d204 	addi	r3,r3,-8376
 820bc6c:	20ffc51e 	bne	r4,r3,820bb84 <__smakebuf_r+0x54>
 820bc70:	8080030b 	ldhu	r2,12(r16)
 820bc74:	04810004 	movi	r18,1024
 820bc78:	84801315 	stw	r18,76(r16)
 820bc7c:	1484b03a 	or	r2,r2,r18
 820bc80:	8080030d 	sth	r2,12(r16)
 820bc84:	0027883a 	mov	r19,zero
 820bc88:	003fd806 	br	820bbec <__smakebuf_r+0xbc>
 820bc8c:	8140038f 	ldh	r5,14(r16)
 820bc90:	8809883a 	mov	r4,r17
 820bc94:	8210fbc0 	call	8210fbc <_isatty_r>
 820bc98:	103fe226 	beq	r2,zero,820bc24 <__smakebuf_r+0xf4>
 820bc9c:	8080030b 	ldhu	r2,12(r16)
 820bca0:	10800054 	ori	r2,r2,1
 820bca4:	8080030d 	sth	r2,12(r16)
 820bca8:	003fde06 	br	820bc24 <__smakebuf_r+0xf4>
 820bcac:	8080030b 	ldhu	r2,12(r16)
 820bcb0:	10c0800c 	andi	r3,r2,512
 820bcb4:	183fdb1e 	bne	r3,zero,820bc24 <__smakebuf_r+0xf4>
 820bcb8:	10800094 	ori	r2,r2,2
 820bcbc:	80c010c4 	addi	r3,r16,67
 820bcc0:	8080030d 	sth	r2,12(r16)
 820bcc4:	00800044 	movi	r2,1
 820bcc8:	80c00015 	stw	r3,0(r16)
 820bccc:	80c00415 	stw	r3,16(r16)
 820bcd0:	80800515 	stw	r2,20(r16)
 820bcd4:	003fd306 	br	820bc24 <__smakebuf_r+0xf4>
 820bcd8:	04810004 	movi	r18,1024
 820bcdc:	003fc306 	br	820bbec <__smakebuf_r+0xbc>
 820bce0:	0027883a 	mov	r19,zero
 820bce4:	04810004 	movi	r18,1024
 820bce8:	003fc006 	br	820bbec <__smakebuf_r+0xbc>

0820bcec <_malloc_r>:
 820bcec:	defff504 	addi	sp,sp,-44
 820bcf0:	dc800315 	stw	r18,12(sp)
 820bcf4:	dfc00a15 	stw	ra,40(sp)
 820bcf8:	df000915 	stw	fp,36(sp)
 820bcfc:	ddc00815 	stw	r23,32(sp)
 820bd00:	dd800715 	stw	r22,28(sp)
 820bd04:	dd400615 	stw	r21,24(sp)
 820bd08:	dd000515 	stw	r20,20(sp)
 820bd0c:	dcc00415 	stw	r19,16(sp)
 820bd10:	dc400215 	stw	r17,8(sp)
 820bd14:	dc000115 	stw	r16,4(sp)
 820bd18:	288002c4 	addi	r2,r5,11
 820bd1c:	00c00584 	movi	r3,22
 820bd20:	2025883a 	mov	r18,r4
 820bd24:	18807f2e 	bgeu	r3,r2,820bf24 <_malloc_r+0x238>
 820bd28:	047ffe04 	movi	r17,-8
 820bd2c:	1462703a 	and	r17,r2,r17
 820bd30:	8800a316 	blt	r17,zero,820bfc0 <_malloc_r+0x2d4>
 820bd34:	8940a236 	bltu	r17,r5,820bfc0 <_malloc_r+0x2d4>
 820bd38:	82149f80 	call	82149f8 <__malloc_lock>
 820bd3c:	00807dc4 	movi	r2,503
 820bd40:	1441e92e 	bgeu	r2,r17,820c4e8 <_malloc_r+0x7fc>
 820bd44:	8804d27a 	srli	r2,r17,9
 820bd48:	1000a126 	beq	r2,zero,820bfd0 <_malloc_r+0x2e4>
 820bd4c:	00c00104 	movi	r3,4
 820bd50:	18811e36 	bltu	r3,r2,820c1cc <_malloc_r+0x4e0>
 820bd54:	8804d1ba 	srli	r2,r17,6
 820bd58:	12000e44 	addi	r8,r2,57
 820bd5c:	11c00e04 	addi	r7,r2,56
 820bd60:	4209883a 	add	r4,r8,r8
 820bd64:	04c20974 	movhi	r19,2085
 820bd68:	2109883a 	add	r4,r4,r4
 820bd6c:	9cc92704 	addi	r19,r19,9372
 820bd70:	2109883a 	add	r4,r4,r4
 820bd74:	9909883a 	add	r4,r19,r4
 820bd78:	24000117 	ldw	r16,4(r4)
 820bd7c:	213ffe04 	addi	r4,r4,-8
 820bd80:	24009726 	beq	r4,r16,820bfe0 <_malloc_r+0x2f4>
 820bd84:	80800117 	ldw	r2,4(r16)
 820bd88:	01bfff04 	movi	r6,-4
 820bd8c:	014003c4 	movi	r5,15
 820bd90:	1184703a 	and	r2,r2,r6
 820bd94:	1447c83a 	sub	r3,r2,r17
 820bd98:	28c00716 	blt	r5,r3,820bdb8 <_malloc_r+0xcc>
 820bd9c:	1800920e 	bge	r3,zero,820bfe8 <_malloc_r+0x2fc>
 820bda0:	84000317 	ldw	r16,12(r16)
 820bda4:	24008e26 	beq	r4,r16,820bfe0 <_malloc_r+0x2f4>
 820bda8:	80800117 	ldw	r2,4(r16)
 820bdac:	1184703a 	and	r2,r2,r6
 820bdb0:	1447c83a 	sub	r3,r2,r17
 820bdb4:	28fff90e 	bge	r5,r3,820bd9c <_malloc_r+0xb0>
 820bdb8:	3809883a 	mov	r4,r7
 820bdbc:	01820974 	movhi	r6,2085
 820bdc0:	9c000417 	ldw	r16,16(r19)
 820bdc4:	31892704 	addi	r6,r6,9372
 820bdc8:	32000204 	addi	r8,r6,8
 820bdcc:	82013426 	beq	r16,r8,820c2a0 <_malloc_r+0x5b4>
 820bdd0:	80c00117 	ldw	r3,4(r16)
 820bdd4:	00bfff04 	movi	r2,-4
 820bdd8:	188e703a 	and	r7,r3,r2
 820bddc:	3c45c83a 	sub	r2,r7,r17
 820bde0:	00c003c4 	movi	r3,15
 820bde4:	18811f16 	blt	r3,r2,820c264 <_malloc_r+0x578>
 820bde8:	32000515 	stw	r8,20(r6)
 820bdec:	32000415 	stw	r8,16(r6)
 820bdf0:	10007f0e 	bge	r2,zero,820bff0 <_malloc_r+0x304>
 820bdf4:	00807fc4 	movi	r2,511
 820bdf8:	11c0fd36 	bltu	r2,r7,820c1f0 <_malloc_r+0x504>
 820bdfc:	3806d0fa 	srli	r3,r7,3
 820be00:	01c00044 	movi	r7,1
 820be04:	30800117 	ldw	r2,4(r6)
 820be08:	19400044 	addi	r5,r3,1
 820be0c:	294b883a 	add	r5,r5,r5
 820be10:	1807d0ba 	srai	r3,r3,2
 820be14:	294b883a 	add	r5,r5,r5
 820be18:	294b883a 	add	r5,r5,r5
 820be1c:	298b883a 	add	r5,r5,r6
 820be20:	38c6983a 	sll	r3,r7,r3
 820be24:	29c00017 	ldw	r7,0(r5)
 820be28:	2a7ffe04 	addi	r9,r5,-8
 820be2c:	1886b03a 	or	r3,r3,r2
 820be30:	82400315 	stw	r9,12(r16)
 820be34:	81c00215 	stw	r7,8(r16)
 820be38:	30c00115 	stw	r3,4(r6)
 820be3c:	2c000015 	stw	r16,0(r5)
 820be40:	3c000315 	stw	r16,12(r7)
 820be44:	2005d0ba 	srai	r2,r4,2
 820be48:	01400044 	movi	r5,1
 820be4c:	288a983a 	sll	r5,r5,r2
 820be50:	19406f36 	bltu	r3,r5,820c010 <_malloc_r+0x324>
 820be54:	28c4703a 	and	r2,r5,r3
 820be58:	10000a1e 	bne	r2,zero,820be84 <_malloc_r+0x198>
 820be5c:	00bfff04 	movi	r2,-4
 820be60:	294b883a 	add	r5,r5,r5
 820be64:	2088703a 	and	r4,r4,r2
 820be68:	28c4703a 	and	r2,r5,r3
 820be6c:	21000104 	addi	r4,r4,4
 820be70:	1000041e 	bne	r2,zero,820be84 <_malloc_r+0x198>
 820be74:	294b883a 	add	r5,r5,r5
 820be78:	28c4703a 	and	r2,r5,r3
 820be7c:	21000104 	addi	r4,r4,4
 820be80:	103ffc26 	beq	r2,zero,820be74 <_malloc_r+0x188>
 820be84:	02bfff04 	movi	r10,-4
 820be88:	024003c4 	movi	r9,15
 820be8c:	21800044 	addi	r6,r4,1
 820be90:	318d883a 	add	r6,r6,r6
 820be94:	318d883a 	add	r6,r6,r6
 820be98:	318d883a 	add	r6,r6,r6
 820be9c:	998d883a 	add	r6,r19,r6
 820bea0:	333ffe04 	addi	r12,r6,-8
 820bea4:	2017883a 	mov	r11,r4
 820bea8:	31800104 	addi	r6,r6,4
 820beac:	34000017 	ldw	r16,0(r6)
 820beb0:	31fffd04 	addi	r7,r6,-12
 820beb4:	81c0041e 	bne	r16,r7,820bec8 <_malloc_r+0x1dc>
 820beb8:	0000fb06 	br	820c2a8 <_malloc_r+0x5bc>
 820bebc:	1801030e 	bge	r3,zero,820c2cc <_malloc_r+0x5e0>
 820bec0:	84000317 	ldw	r16,12(r16)
 820bec4:	81c0f826 	beq	r16,r7,820c2a8 <_malloc_r+0x5bc>
 820bec8:	80800117 	ldw	r2,4(r16)
 820becc:	1284703a 	and	r2,r2,r10
 820bed0:	1447c83a 	sub	r3,r2,r17
 820bed4:	48fff90e 	bge	r9,r3,820bebc <_malloc_r+0x1d0>
 820bed8:	80800317 	ldw	r2,12(r16)
 820bedc:	81000217 	ldw	r4,8(r16)
 820bee0:	89400054 	ori	r5,r17,1
 820bee4:	81400115 	stw	r5,4(r16)
 820bee8:	20800315 	stw	r2,12(r4)
 820beec:	11000215 	stw	r4,8(r2)
 820bef0:	8463883a 	add	r17,r16,r17
 820bef4:	9c400515 	stw	r17,20(r19)
 820bef8:	9c400415 	stw	r17,16(r19)
 820befc:	18800054 	ori	r2,r3,1
 820bf00:	88800115 	stw	r2,4(r17)
 820bf04:	8a000315 	stw	r8,12(r17)
 820bf08:	8a000215 	stw	r8,8(r17)
 820bf0c:	88e3883a 	add	r17,r17,r3
 820bf10:	88c00015 	stw	r3,0(r17)
 820bf14:	9009883a 	mov	r4,r18
 820bf18:	8214b180 	call	8214b18 <__malloc_unlock>
 820bf1c:	80800204 	addi	r2,r16,8
 820bf20:	00001b06 	br	820bf90 <_malloc_r+0x2a4>
 820bf24:	04400404 	movi	r17,16
 820bf28:	89402536 	bltu	r17,r5,820bfc0 <_malloc_r+0x2d4>
 820bf2c:	82149f80 	call	82149f8 <__malloc_lock>
 820bf30:	00800184 	movi	r2,6
 820bf34:	01000084 	movi	r4,2
 820bf38:	04c20974 	movhi	r19,2085
 820bf3c:	1085883a 	add	r2,r2,r2
 820bf40:	9cc92704 	addi	r19,r19,9372
 820bf44:	1085883a 	add	r2,r2,r2
 820bf48:	9885883a 	add	r2,r19,r2
 820bf4c:	14000117 	ldw	r16,4(r2)
 820bf50:	10fffe04 	addi	r3,r2,-8
 820bf54:	80c0d926 	beq	r16,r3,820c2bc <_malloc_r+0x5d0>
 820bf58:	80c00117 	ldw	r3,4(r16)
 820bf5c:	81000317 	ldw	r4,12(r16)
 820bf60:	00bfff04 	movi	r2,-4
 820bf64:	1884703a 	and	r2,r3,r2
 820bf68:	81400217 	ldw	r5,8(r16)
 820bf6c:	8085883a 	add	r2,r16,r2
 820bf70:	10c00117 	ldw	r3,4(r2)
 820bf74:	29000315 	stw	r4,12(r5)
 820bf78:	21400215 	stw	r5,8(r4)
 820bf7c:	18c00054 	ori	r3,r3,1
 820bf80:	10c00115 	stw	r3,4(r2)
 820bf84:	9009883a 	mov	r4,r18
 820bf88:	8214b180 	call	8214b18 <__malloc_unlock>
 820bf8c:	80800204 	addi	r2,r16,8
 820bf90:	dfc00a17 	ldw	ra,40(sp)
 820bf94:	df000917 	ldw	fp,36(sp)
 820bf98:	ddc00817 	ldw	r23,32(sp)
 820bf9c:	dd800717 	ldw	r22,28(sp)
 820bfa0:	dd400617 	ldw	r21,24(sp)
 820bfa4:	dd000517 	ldw	r20,20(sp)
 820bfa8:	dcc00417 	ldw	r19,16(sp)
 820bfac:	dc800317 	ldw	r18,12(sp)
 820bfb0:	dc400217 	ldw	r17,8(sp)
 820bfb4:	dc000117 	ldw	r16,4(sp)
 820bfb8:	dec00b04 	addi	sp,sp,44
 820bfbc:	f800283a 	ret
 820bfc0:	00800304 	movi	r2,12
 820bfc4:	90800015 	stw	r2,0(r18)
 820bfc8:	0005883a 	mov	r2,zero
 820bfcc:	003ff006 	br	820bf90 <_malloc_r+0x2a4>
 820bfd0:	01002004 	movi	r4,128
 820bfd4:	02001004 	movi	r8,64
 820bfd8:	01c00fc4 	movi	r7,63
 820bfdc:	003f6106 	br	820bd64 <_malloc_r+0x78>
 820bfe0:	4009883a 	mov	r4,r8
 820bfe4:	003f7506 	br	820bdbc <_malloc_r+0xd0>
 820bfe8:	81000317 	ldw	r4,12(r16)
 820bfec:	003fde06 	br	820bf68 <_malloc_r+0x27c>
 820bff0:	81c5883a 	add	r2,r16,r7
 820bff4:	11400117 	ldw	r5,4(r2)
 820bff8:	9009883a 	mov	r4,r18
 820bffc:	29400054 	ori	r5,r5,1
 820c000:	11400115 	stw	r5,4(r2)
 820c004:	8214b180 	call	8214b18 <__malloc_unlock>
 820c008:	80800204 	addi	r2,r16,8
 820c00c:	003fe006 	br	820bf90 <_malloc_r+0x2a4>
 820c010:	9c000217 	ldw	r16,8(r19)
 820c014:	00bfff04 	movi	r2,-4
 820c018:	85800117 	ldw	r22,4(r16)
 820c01c:	b0ac703a 	and	r22,r22,r2
 820c020:	b4400336 	bltu	r22,r17,820c030 <_malloc_r+0x344>
 820c024:	b445c83a 	sub	r2,r22,r17
 820c028:	00c003c4 	movi	r3,15
 820c02c:	18805d16 	blt	r3,r2,820c1a4 <_malloc_r+0x4b8>
 820c030:	05c20974 	movhi	r23,2085
 820c034:	00820974 	movhi	r2,2085
 820c038:	108ff904 	addi	r2,r2,16356
 820c03c:	bdcf9b04 	addi	r23,r23,15980
 820c040:	15400017 	ldw	r21,0(r2)
 820c044:	b8c00017 	ldw	r3,0(r23)
 820c048:	00bfffc4 	movi	r2,-1
 820c04c:	858d883a 	add	r6,r16,r22
 820c050:	8d6b883a 	add	r21,r17,r21
 820c054:	1880ea26 	beq	r3,r2,820c400 <_malloc_r+0x714>
 820c058:	ad4403c4 	addi	r21,r21,4111
 820c05c:	00bc0004 	movi	r2,-4096
 820c060:	a8aa703a 	and	r21,r21,r2
 820c064:	a80b883a 	mov	r5,r21
 820c068:	9009883a 	mov	r4,r18
 820c06c:	d9800015 	stw	r6,0(sp)
 820c070:	820de1c0 	call	820de1c <_sbrk_r>
 820c074:	1029883a 	mov	r20,r2
 820c078:	00bfffc4 	movi	r2,-1
 820c07c:	d9800017 	ldw	r6,0(sp)
 820c080:	a080e826 	beq	r20,r2,820c424 <_malloc_r+0x738>
 820c084:	a180a636 	bltu	r20,r6,820c320 <_malloc_r+0x634>
 820c088:	07020974 	movhi	fp,2085
 820c08c:	e711f004 	addi	fp,fp,18368
 820c090:	e0800017 	ldw	r2,0(fp)
 820c094:	a887883a 	add	r3,r21,r2
 820c098:	e0c00015 	stw	r3,0(fp)
 820c09c:	3500e626 	beq	r6,r20,820c438 <_malloc_r+0x74c>
 820c0a0:	b9000017 	ldw	r4,0(r23)
 820c0a4:	00bfffc4 	movi	r2,-1
 820c0a8:	2080ee26 	beq	r4,r2,820c464 <_malloc_r+0x778>
 820c0ac:	a185c83a 	sub	r2,r20,r6
 820c0b0:	10c5883a 	add	r2,r2,r3
 820c0b4:	e0800015 	stw	r2,0(fp)
 820c0b8:	a0c001cc 	andi	r3,r20,7
 820c0bc:	1800bc26 	beq	r3,zero,820c3b0 <_malloc_r+0x6c4>
 820c0c0:	a0e9c83a 	sub	r20,r20,r3
 820c0c4:	00840204 	movi	r2,4104
 820c0c8:	a5000204 	addi	r20,r20,8
 820c0cc:	10c7c83a 	sub	r3,r2,r3
 820c0d0:	a545883a 	add	r2,r20,r21
 820c0d4:	1083ffcc 	andi	r2,r2,4095
 820c0d8:	18abc83a 	sub	r21,r3,r2
 820c0dc:	a80b883a 	mov	r5,r21
 820c0e0:	9009883a 	mov	r4,r18
 820c0e4:	820de1c0 	call	820de1c <_sbrk_r>
 820c0e8:	00ffffc4 	movi	r3,-1
 820c0ec:	10c0e126 	beq	r2,r3,820c474 <_malloc_r+0x788>
 820c0f0:	1505c83a 	sub	r2,r2,r20
 820c0f4:	1545883a 	add	r2,r2,r21
 820c0f8:	10800054 	ori	r2,r2,1
 820c0fc:	e0c00017 	ldw	r3,0(fp)
 820c100:	9d000215 	stw	r20,8(r19)
 820c104:	a0800115 	stw	r2,4(r20)
 820c108:	a8c7883a 	add	r3,r21,r3
 820c10c:	e0c00015 	stw	r3,0(fp)
 820c110:	84c00e26 	beq	r16,r19,820c14c <_malloc_r+0x460>
 820c114:	018003c4 	movi	r6,15
 820c118:	3580a72e 	bgeu	r6,r22,820c3b8 <_malloc_r+0x6cc>
 820c11c:	81400117 	ldw	r5,4(r16)
 820c120:	013ffe04 	movi	r4,-8
 820c124:	b0bffd04 	addi	r2,r22,-12
 820c128:	1104703a 	and	r2,r2,r4
 820c12c:	2900004c 	andi	r4,r5,1
 820c130:	2088b03a 	or	r4,r4,r2
 820c134:	81000115 	stw	r4,4(r16)
 820c138:	01400144 	movi	r5,5
 820c13c:	8089883a 	add	r4,r16,r2
 820c140:	21400115 	stw	r5,4(r4)
 820c144:	21400215 	stw	r5,8(r4)
 820c148:	3080cd36 	bltu	r6,r2,820c480 <_malloc_r+0x794>
 820c14c:	00820974 	movhi	r2,2085
 820c150:	108ff804 	addi	r2,r2,16352
 820c154:	11000017 	ldw	r4,0(r2)
 820c158:	20c0012e 	bgeu	r4,r3,820c160 <_malloc_r+0x474>
 820c15c:	10c00015 	stw	r3,0(r2)
 820c160:	00820974 	movhi	r2,2085
 820c164:	108ff704 	addi	r2,r2,16348
 820c168:	11000017 	ldw	r4,0(r2)
 820c16c:	9c000217 	ldw	r16,8(r19)
 820c170:	20c0012e 	bgeu	r4,r3,820c178 <_malloc_r+0x48c>
 820c174:	10c00015 	stw	r3,0(r2)
 820c178:	80c00117 	ldw	r3,4(r16)
 820c17c:	00bfff04 	movi	r2,-4
 820c180:	1886703a 	and	r3,r3,r2
 820c184:	1c45c83a 	sub	r2,r3,r17
 820c188:	1c400236 	bltu	r3,r17,820c194 <_malloc_r+0x4a8>
 820c18c:	00c003c4 	movi	r3,15
 820c190:	18800416 	blt	r3,r2,820c1a4 <_malloc_r+0x4b8>
 820c194:	9009883a 	mov	r4,r18
 820c198:	8214b180 	call	8214b18 <__malloc_unlock>
 820c19c:	0005883a 	mov	r2,zero
 820c1a0:	003f7b06 	br	820bf90 <_malloc_r+0x2a4>
 820c1a4:	88c00054 	ori	r3,r17,1
 820c1a8:	80c00115 	stw	r3,4(r16)
 820c1ac:	8463883a 	add	r17,r16,r17
 820c1b0:	10800054 	ori	r2,r2,1
 820c1b4:	9c400215 	stw	r17,8(r19)
 820c1b8:	88800115 	stw	r2,4(r17)
 820c1bc:	9009883a 	mov	r4,r18
 820c1c0:	8214b180 	call	8214b18 <__malloc_unlock>
 820c1c4:	80800204 	addi	r2,r16,8
 820c1c8:	003f7106 	br	820bf90 <_malloc_r+0x2a4>
 820c1cc:	00c00504 	movi	r3,20
 820c1d0:	18804a2e 	bgeu	r3,r2,820c2fc <_malloc_r+0x610>
 820c1d4:	00c01504 	movi	r3,84
 820c1d8:	18806e36 	bltu	r3,r2,820c394 <_malloc_r+0x6a8>
 820c1dc:	8804d33a 	srli	r2,r17,12
 820c1e0:	12001bc4 	addi	r8,r2,111
 820c1e4:	11c01b84 	addi	r7,r2,110
 820c1e8:	4209883a 	add	r4,r8,r8
 820c1ec:	003edd06 	br	820bd64 <_malloc_r+0x78>
 820c1f0:	3804d27a 	srli	r2,r7,9
 820c1f4:	00c00104 	movi	r3,4
 820c1f8:	1880442e 	bgeu	r3,r2,820c30c <_malloc_r+0x620>
 820c1fc:	00c00504 	movi	r3,20
 820c200:	18808136 	bltu	r3,r2,820c408 <_malloc_r+0x71c>
 820c204:	11401704 	addi	r5,r2,92
 820c208:	10c016c4 	addi	r3,r2,91
 820c20c:	294b883a 	add	r5,r5,r5
 820c210:	294b883a 	add	r5,r5,r5
 820c214:	294b883a 	add	r5,r5,r5
 820c218:	994b883a 	add	r5,r19,r5
 820c21c:	28800017 	ldw	r2,0(r5)
 820c220:	01820974 	movhi	r6,2085
 820c224:	297ffe04 	addi	r5,r5,-8
 820c228:	31892704 	addi	r6,r6,9372
 820c22c:	28806526 	beq	r5,r2,820c3c4 <_malloc_r+0x6d8>
 820c230:	01bfff04 	movi	r6,-4
 820c234:	10c00117 	ldw	r3,4(r2)
 820c238:	1986703a 	and	r3,r3,r6
 820c23c:	38c0022e 	bgeu	r7,r3,820c248 <_malloc_r+0x55c>
 820c240:	10800217 	ldw	r2,8(r2)
 820c244:	28bffb1e 	bne	r5,r2,820c234 <_malloc_r+0x548>
 820c248:	11400317 	ldw	r5,12(r2)
 820c24c:	98c00117 	ldw	r3,4(r19)
 820c250:	81400315 	stw	r5,12(r16)
 820c254:	80800215 	stw	r2,8(r16)
 820c258:	2c000215 	stw	r16,8(r5)
 820c25c:	14000315 	stw	r16,12(r2)
 820c260:	003ef806 	br	820be44 <_malloc_r+0x158>
 820c264:	88c00054 	ori	r3,r17,1
 820c268:	80c00115 	stw	r3,4(r16)
 820c26c:	8463883a 	add	r17,r16,r17
 820c270:	34400515 	stw	r17,20(r6)
 820c274:	34400415 	stw	r17,16(r6)
 820c278:	10c00054 	ori	r3,r2,1
 820c27c:	8a000315 	stw	r8,12(r17)
 820c280:	8a000215 	stw	r8,8(r17)
 820c284:	88c00115 	stw	r3,4(r17)
 820c288:	88a3883a 	add	r17,r17,r2
 820c28c:	88800015 	stw	r2,0(r17)
 820c290:	9009883a 	mov	r4,r18
 820c294:	8214b180 	call	8214b18 <__malloc_unlock>
 820c298:	80800204 	addi	r2,r16,8
 820c29c:	003f3c06 	br	820bf90 <_malloc_r+0x2a4>
 820c2a0:	30c00117 	ldw	r3,4(r6)
 820c2a4:	003ee706 	br	820be44 <_malloc_r+0x158>
 820c2a8:	5ac00044 	addi	r11,r11,1
 820c2ac:	588000cc 	andi	r2,r11,3
 820c2b0:	31800204 	addi	r6,r6,8
 820c2b4:	103efd1e 	bne	r2,zero,820beac <_malloc_r+0x1c0>
 820c2b8:	00002406 	br	820c34c <_malloc_r+0x660>
 820c2bc:	14000317 	ldw	r16,12(r2)
 820c2c0:	143f251e 	bne	r2,r16,820bf58 <_malloc_r+0x26c>
 820c2c4:	21000084 	addi	r4,r4,2
 820c2c8:	003ebc06 	br	820bdbc <_malloc_r+0xd0>
 820c2cc:	8085883a 	add	r2,r16,r2
 820c2d0:	10c00117 	ldw	r3,4(r2)
 820c2d4:	81000317 	ldw	r4,12(r16)
 820c2d8:	81400217 	ldw	r5,8(r16)
 820c2dc:	18c00054 	ori	r3,r3,1
 820c2e0:	10c00115 	stw	r3,4(r2)
 820c2e4:	29000315 	stw	r4,12(r5)
 820c2e8:	21400215 	stw	r5,8(r4)
 820c2ec:	9009883a 	mov	r4,r18
 820c2f0:	8214b180 	call	8214b18 <__malloc_unlock>
 820c2f4:	80800204 	addi	r2,r16,8
 820c2f8:	003f2506 	br	820bf90 <_malloc_r+0x2a4>
 820c2fc:	12001704 	addi	r8,r2,92
 820c300:	11c016c4 	addi	r7,r2,91
 820c304:	4209883a 	add	r4,r8,r8
 820c308:	003e9606 	br	820bd64 <_malloc_r+0x78>
 820c30c:	3804d1ba 	srli	r2,r7,6
 820c310:	11400e44 	addi	r5,r2,57
 820c314:	10c00e04 	addi	r3,r2,56
 820c318:	294b883a 	add	r5,r5,r5
 820c31c:	003fbc06 	br	820c210 <_malloc_r+0x524>
 820c320:	84ff5926 	beq	r16,r19,820c088 <_malloc_r+0x39c>
 820c324:	00820974 	movhi	r2,2085
 820c328:	10892704 	addi	r2,r2,9372
 820c32c:	14000217 	ldw	r16,8(r2)
 820c330:	00bfff04 	movi	r2,-4
 820c334:	80c00117 	ldw	r3,4(r16)
 820c338:	1886703a 	and	r3,r3,r2
 820c33c:	003f9106 	br	820c184 <_malloc_r+0x498>
 820c340:	60800217 	ldw	r2,8(r12)
 820c344:	213fffc4 	addi	r4,r4,-1
 820c348:	1300651e 	bne	r2,r12,820c4e0 <_malloc_r+0x7f4>
 820c34c:	208000cc 	andi	r2,r4,3
 820c350:	633ffe04 	addi	r12,r12,-8
 820c354:	103ffa1e 	bne	r2,zero,820c340 <_malloc_r+0x654>
 820c358:	98800117 	ldw	r2,4(r19)
 820c35c:	0146303a 	nor	r3,zero,r5
 820c360:	1884703a 	and	r2,r3,r2
 820c364:	98800115 	stw	r2,4(r19)
 820c368:	294b883a 	add	r5,r5,r5
 820c36c:	117f2836 	bltu	r2,r5,820c010 <_malloc_r+0x324>
 820c370:	283f2726 	beq	r5,zero,820c010 <_malloc_r+0x324>
 820c374:	2886703a 	and	r3,r5,r2
 820c378:	5809883a 	mov	r4,r11
 820c37c:	183ec31e 	bne	r3,zero,820be8c <_malloc_r+0x1a0>
 820c380:	294b883a 	add	r5,r5,r5
 820c384:	2886703a 	and	r3,r5,r2
 820c388:	21000104 	addi	r4,r4,4
 820c38c:	183ffc26 	beq	r3,zero,820c380 <_malloc_r+0x694>
 820c390:	003ebe06 	br	820be8c <_malloc_r+0x1a0>
 820c394:	00c05504 	movi	r3,340
 820c398:	18801236 	bltu	r3,r2,820c3e4 <_malloc_r+0x6f8>
 820c39c:	8804d3fa 	srli	r2,r17,15
 820c3a0:	12001e04 	addi	r8,r2,120
 820c3a4:	11c01dc4 	addi	r7,r2,119
 820c3a8:	4209883a 	add	r4,r8,r8
 820c3ac:	003e6d06 	br	820bd64 <_malloc_r+0x78>
 820c3b0:	00c40004 	movi	r3,4096
 820c3b4:	003f4606 	br	820c0d0 <_malloc_r+0x3e4>
 820c3b8:	00800044 	movi	r2,1
 820c3bc:	a0800115 	stw	r2,4(r20)
 820c3c0:	003f7406 	br	820c194 <_malloc_r+0x4a8>
 820c3c4:	1805d0ba 	srai	r2,r3,2
 820c3c8:	01c00044 	movi	r7,1
 820c3cc:	30c00117 	ldw	r3,4(r6)
 820c3d0:	388e983a 	sll	r7,r7,r2
 820c3d4:	2805883a 	mov	r2,r5
 820c3d8:	38c6b03a 	or	r3,r7,r3
 820c3dc:	30c00115 	stw	r3,4(r6)
 820c3e0:	003f9b06 	br	820c250 <_malloc_r+0x564>
 820c3e4:	00c15504 	movi	r3,1364
 820c3e8:	18801a36 	bltu	r3,r2,820c454 <_malloc_r+0x768>
 820c3ec:	8804d4ba 	srli	r2,r17,18
 820c3f0:	12001f44 	addi	r8,r2,125
 820c3f4:	11c01f04 	addi	r7,r2,124
 820c3f8:	4209883a 	add	r4,r8,r8
 820c3fc:	003e5906 	br	820bd64 <_malloc_r+0x78>
 820c400:	ad400404 	addi	r21,r21,16
 820c404:	003f1706 	br	820c064 <_malloc_r+0x378>
 820c408:	00c01504 	movi	r3,84
 820c40c:	18802336 	bltu	r3,r2,820c49c <_malloc_r+0x7b0>
 820c410:	3804d33a 	srli	r2,r7,12
 820c414:	11401bc4 	addi	r5,r2,111
 820c418:	10c01b84 	addi	r3,r2,110
 820c41c:	294b883a 	add	r5,r5,r5
 820c420:	003f7b06 	br	820c210 <_malloc_r+0x524>
 820c424:	9c000217 	ldw	r16,8(r19)
 820c428:	00bfff04 	movi	r2,-4
 820c42c:	80c00117 	ldw	r3,4(r16)
 820c430:	1886703a 	and	r3,r3,r2
 820c434:	003f5306 	br	820c184 <_malloc_r+0x498>
 820c438:	3083ffcc 	andi	r2,r6,4095
 820c43c:	103f181e 	bne	r2,zero,820c0a0 <_malloc_r+0x3b4>
 820c440:	99000217 	ldw	r4,8(r19)
 820c444:	b545883a 	add	r2,r22,r21
 820c448:	10800054 	ori	r2,r2,1
 820c44c:	20800115 	stw	r2,4(r4)
 820c450:	003f3e06 	br	820c14c <_malloc_r+0x460>
 820c454:	01003f84 	movi	r4,254
 820c458:	02001fc4 	movi	r8,127
 820c45c:	01c01f84 	movi	r7,126
 820c460:	003e4006 	br	820bd64 <_malloc_r+0x78>
 820c464:	00820974 	movhi	r2,2085
 820c468:	108f9b04 	addi	r2,r2,15980
 820c46c:	15000015 	stw	r20,0(r2)
 820c470:	003f1106 	br	820c0b8 <_malloc_r+0x3cc>
 820c474:	00800044 	movi	r2,1
 820c478:	002b883a 	mov	r21,zero
 820c47c:	003f1f06 	br	820c0fc <_malloc_r+0x410>
 820c480:	81400204 	addi	r5,r16,8
 820c484:	9009883a 	mov	r4,r18
 820c488:	820b1000 	call	820b100 <_free_r>
 820c48c:	00820974 	movhi	r2,2085
 820c490:	1091f004 	addi	r2,r2,18368
 820c494:	10c00017 	ldw	r3,0(r2)
 820c498:	003f2c06 	br	820c14c <_malloc_r+0x460>
 820c49c:	00c05504 	movi	r3,340
 820c4a0:	18800536 	bltu	r3,r2,820c4b8 <_malloc_r+0x7cc>
 820c4a4:	3804d3fa 	srli	r2,r7,15
 820c4a8:	11401e04 	addi	r5,r2,120
 820c4ac:	10c01dc4 	addi	r3,r2,119
 820c4b0:	294b883a 	add	r5,r5,r5
 820c4b4:	003f5606 	br	820c210 <_malloc_r+0x524>
 820c4b8:	00c15504 	movi	r3,1364
 820c4bc:	18800536 	bltu	r3,r2,820c4d4 <_malloc_r+0x7e8>
 820c4c0:	3804d4ba 	srli	r2,r7,18
 820c4c4:	11401f44 	addi	r5,r2,125
 820c4c8:	10c01f04 	addi	r3,r2,124
 820c4cc:	294b883a 	add	r5,r5,r5
 820c4d0:	003f4f06 	br	820c210 <_malloc_r+0x524>
 820c4d4:	01403f84 	movi	r5,254
 820c4d8:	00c01f84 	movi	r3,126
 820c4dc:	003f4c06 	br	820c210 <_malloc_r+0x524>
 820c4e0:	98800117 	ldw	r2,4(r19)
 820c4e4:	003fa006 	br	820c368 <_malloc_r+0x67c>
 820c4e8:	8808d0fa 	srli	r4,r17,3
 820c4ec:	20800044 	addi	r2,r4,1
 820c4f0:	1085883a 	add	r2,r2,r2
 820c4f4:	003e9006 	br	820bf38 <_malloc_r+0x24c>

0820c4f8 <memchr>:
 820c4f8:	208000cc 	andi	r2,r4,3
 820c4fc:	280f883a 	mov	r7,r5
 820c500:	10003426 	beq	r2,zero,820c5d4 <memchr+0xdc>
 820c504:	30bfffc4 	addi	r2,r6,-1
 820c508:	30001a26 	beq	r6,zero,820c574 <memchr+0x7c>
 820c50c:	20c00003 	ldbu	r3,0(r4)
 820c510:	29803fcc 	andi	r6,r5,255
 820c514:	30c0051e 	bne	r6,r3,820c52c <memchr+0x34>
 820c518:	00001806 	br	820c57c <memchr+0x84>
 820c51c:	10001526 	beq	r2,zero,820c574 <memchr+0x7c>
 820c520:	20c00003 	ldbu	r3,0(r4)
 820c524:	10bfffc4 	addi	r2,r2,-1
 820c528:	30c01426 	beq	r6,r3,820c57c <memchr+0x84>
 820c52c:	21000044 	addi	r4,r4,1
 820c530:	20c000cc 	andi	r3,r4,3
 820c534:	183ff91e 	bne	r3,zero,820c51c <memchr+0x24>
 820c538:	020000c4 	movi	r8,3
 820c53c:	40801136 	bltu	r8,r2,820c584 <memchr+0x8c>
 820c540:	10000c26 	beq	r2,zero,820c574 <memchr+0x7c>
 820c544:	20c00003 	ldbu	r3,0(r4)
 820c548:	29403fcc 	andi	r5,r5,255
 820c54c:	28c00b26 	beq	r5,r3,820c57c <memchr+0x84>
 820c550:	20c00044 	addi	r3,r4,1
 820c554:	39803fcc 	andi	r6,r7,255
 820c558:	2089883a 	add	r4,r4,r2
 820c55c:	00000306 	br	820c56c <memchr+0x74>
 820c560:	18c00044 	addi	r3,r3,1
 820c564:	197fffc3 	ldbu	r5,-1(r3)
 820c568:	31400526 	beq	r6,r5,820c580 <memchr+0x88>
 820c56c:	1805883a 	mov	r2,r3
 820c570:	20fffb1e 	bne	r4,r3,820c560 <memchr+0x68>
 820c574:	0005883a 	mov	r2,zero
 820c578:	f800283a 	ret
 820c57c:	2005883a 	mov	r2,r4
 820c580:	f800283a 	ret
 820c584:	28c03fcc 	andi	r3,r5,255
 820c588:	1812923a 	slli	r9,r3,8
 820c58c:	02ffbff4 	movhi	r11,65279
 820c590:	02a02074 	movhi	r10,32897
 820c594:	48d2b03a 	or	r9,r9,r3
 820c598:	4806943a 	slli	r3,r9,16
 820c59c:	5affbfc4 	addi	r11,r11,-257
 820c5a0:	52a02004 	addi	r10,r10,-32640
 820c5a4:	48d2b03a 	or	r9,r9,r3
 820c5a8:	20c00017 	ldw	r3,0(r4)
 820c5ac:	48c6f03a 	xor	r3,r9,r3
 820c5b0:	1acd883a 	add	r6,r3,r11
 820c5b4:	00c6303a 	nor	r3,zero,r3
 820c5b8:	30c6703a 	and	r3,r6,r3
 820c5bc:	1a86703a 	and	r3,r3,r10
 820c5c0:	183fe01e 	bne	r3,zero,820c544 <memchr+0x4c>
 820c5c4:	10bfff04 	addi	r2,r2,-4
 820c5c8:	21000104 	addi	r4,r4,4
 820c5cc:	40bff636 	bltu	r8,r2,820c5a8 <memchr+0xb0>
 820c5d0:	003fdb06 	br	820c540 <memchr+0x48>
 820c5d4:	3005883a 	mov	r2,r6
 820c5d8:	003fd706 	br	820c538 <memchr+0x40>

0820c5dc <memcmp>:
 820c5dc:	01c000c4 	movi	r7,3
 820c5e0:	3980192e 	bgeu	r7,r6,820c648 <memcmp+0x6c>
 820c5e4:	2144b03a 	or	r2,r4,r5
 820c5e8:	11c4703a 	and	r2,r2,r7
 820c5ec:	10000f26 	beq	r2,zero,820c62c <memcmp+0x50>
 820c5f0:	20800003 	ldbu	r2,0(r4)
 820c5f4:	28c00003 	ldbu	r3,0(r5)
 820c5f8:	10c0151e 	bne	r2,r3,820c650 <memcmp+0x74>
 820c5fc:	31bfff84 	addi	r6,r6,-2
 820c600:	01ffffc4 	movi	r7,-1
 820c604:	00000406 	br	820c618 <memcmp+0x3c>
 820c608:	20800003 	ldbu	r2,0(r4)
 820c60c:	28c00003 	ldbu	r3,0(r5)
 820c610:	31bfffc4 	addi	r6,r6,-1
 820c614:	10c00e1e 	bne	r2,r3,820c650 <memcmp+0x74>
 820c618:	21000044 	addi	r4,r4,1
 820c61c:	29400044 	addi	r5,r5,1
 820c620:	31fff91e 	bne	r6,r7,820c608 <memcmp+0x2c>
 820c624:	0005883a 	mov	r2,zero
 820c628:	f800283a 	ret
 820c62c:	20c00017 	ldw	r3,0(r4)
 820c630:	28800017 	ldw	r2,0(r5)
 820c634:	18bfee1e 	bne	r3,r2,820c5f0 <memcmp+0x14>
 820c638:	31bfff04 	addi	r6,r6,-4
 820c63c:	21000104 	addi	r4,r4,4
 820c640:	29400104 	addi	r5,r5,4
 820c644:	39bff936 	bltu	r7,r6,820c62c <memcmp+0x50>
 820c648:	303fe91e 	bne	r6,zero,820c5f0 <memcmp+0x14>
 820c64c:	003ff506 	br	820c624 <memcmp+0x48>
 820c650:	10c5c83a 	sub	r2,r2,r3
 820c654:	f800283a 	ret

0820c658 <_Balloc>:
 820c658:	20801317 	ldw	r2,76(r4)
 820c65c:	defffc04 	addi	sp,sp,-16
 820c660:	dc400115 	stw	r17,4(sp)
 820c664:	dc000015 	stw	r16,0(sp)
 820c668:	dfc00315 	stw	ra,12(sp)
 820c66c:	dc800215 	stw	r18,8(sp)
 820c670:	2023883a 	mov	r17,r4
 820c674:	2821883a 	mov	r16,r5
 820c678:	10000f26 	beq	r2,zero,820c6b8 <_Balloc+0x60>
 820c67c:	8407883a 	add	r3,r16,r16
 820c680:	18c7883a 	add	r3,r3,r3
 820c684:	10c7883a 	add	r3,r2,r3
 820c688:	18800017 	ldw	r2,0(r3)
 820c68c:	10001126 	beq	r2,zero,820c6d4 <_Balloc+0x7c>
 820c690:	11000017 	ldw	r4,0(r2)
 820c694:	19000015 	stw	r4,0(r3)
 820c698:	10000415 	stw	zero,16(r2)
 820c69c:	10000315 	stw	zero,12(r2)
 820c6a0:	dfc00317 	ldw	ra,12(sp)
 820c6a4:	dc800217 	ldw	r18,8(sp)
 820c6a8:	dc400117 	ldw	r17,4(sp)
 820c6ac:	dc000017 	ldw	r16,0(sp)
 820c6b0:	dec00404 	addi	sp,sp,16
 820c6b4:	f800283a 	ret
 820c6b8:	01800844 	movi	r6,33
 820c6bc:	01400104 	movi	r5,4
 820c6c0:	8210b900 	call	8210b90 <_calloc_r>
 820c6c4:	88801315 	stw	r2,76(r17)
 820c6c8:	103fec1e 	bne	r2,zero,820c67c <_Balloc+0x24>
 820c6cc:	0005883a 	mov	r2,zero
 820c6d0:	003ff306 	br	820c6a0 <_Balloc+0x48>
 820c6d4:	01400044 	movi	r5,1
 820c6d8:	2c24983a 	sll	r18,r5,r16
 820c6dc:	8809883a 	mov	r4,r17
 820c6e0:	91800144 	addi	r6,r18,5
 820c6e4:	318d883a 	add	r6,r6,r6
 820c6e8:	318d883a 	add	r6,r6,r6
 820c6ec:	8210b900 	call	8210b90 <_calloc_r>
 820c6f0:	103ff626 	beq	r2,zero,820c6cc <_Balloc+0x74>
 820c6f4:	14000115 	stw	r16,4(r2)
 820c6f8:	14800215 	stw	r18,8(r2)
 820c6fc:	003fe606 	br	820c698 <_Balloc+0x40>

0820c700 <_Bfree>:
 820c700:	28000826 	beq	r5,zero,820c724 <_Bfree+0x24>
 820c704:	28c00117 	ldw	r3,4(r5)
 820c708:	20801317 	ldw	r2,76(r4)
 820c70c:	18c7883a 	add	r3,r3,r3
 820c710:	18c7883a 	add	r3,r3,r3
 820c714:	10c5883a 	add	r2,r2,r3
 820c718:	10c00017 	ldw	r3,0(r2)
 820c71c:	28c00015 	stw	r3,0(r5)
 820c720:	11400015 	stw	r5,0(r2)
 820c724:	f800283a 	ret

0820c728 <__multadd>:
 820c728:	defffa04 	addi	sp,sp,-24
 820c72c:	dc800315 	stw	r18,12(sp)
 820c730:	dc400215 	stw	r17,8(sp)
 820c734:	dc000115 	stw	r16,4(sp)
 820c738:	2823883a 	mov	r17,r5
 820c73c:	2c000417 	ldw	r16,16(r5)
 820c740:	dfc00515 	stw	ra,20(sp)
 820c744:	dcc00415 	stw	r19,16(sp)
 820c748:	2025883a 	mov	r18,r4
 820c74c:	29400504 	addi	r5,r5,20
 820c750:	0011883a 	mov	r8,zero
 820c754:	28c00017 	ldw	r3,0(r5)
 820c758:	29400104 	addi	r5,r5,4
 820c75c:	42000044 	addi	r8,r8,1
 820c760:	18bfffcc 	andi	r2,r3,65535
 820c764:	1185383a 	mul	r2,r2,r6
 820c768:	1806d43a 	srli	r3,r3,16
 820c76c:	11cf883a 	add	r7,r2,r7
 820c770:	3808d43a 	srli	r4,r7,16
 820c774:	1987383a 	mul	r3,r3,r6
 820c778:	38bfffcc 	andi	r2,r7,65535
 820c77c:	1907883a 	add	r3,r3,r4
 820c780:	1808943a 	slli	r4,r3,16
 820c784:	180ed43a 	srli	r7,r3,16
 820c788:	2085883a 	add	r2,r4,r2
 820c78c:	28bfff15 	stw	r2,-4(r5)
 820c790:	443ff016 	blt	r8,r16,820c754 <__multadd+0x2c>
 820c794:	38000926 	beq	r7,zero,820c7bc <__multadd+0x94>
 820c798:	88800217 	ldw	r2,8(r17)
 820c79c:	80800f0e 	bge	r16,r2,820c7dc <__multadd+0xb4>
 820c7a0:	80800144 	addi	r2,r16,5
 820c7a4:	1085883a 	add	r2,r2,r2
 820c7a8:	1085883a 	add	r2,r2,r2
 820c7ac:	8885883a 	add	r2,r17,r2
 820c7b0:	11c00015 	stw	r7,0(r2)
 820c7b4:	84000044 	addi	r16,r16,1
 820c7b8:	8c000415 	stw	r16,16(r17)
 820c7bc:	8805883a 	mov	r2,r17
 820c7c0:	dfc00517 	ldw	ra,20(sp)
 820c7c4:	dcc00417 	ldw	r19,16(sp)
 820c7c8:	dc800317 	ldw	r18,12(sp)
 820c7cc:	dc400217 	ldw	r17,8(sp)
 820c7d0:	dc000117 	ldw	r16,4(sp)
 820c7d4:	dec00604 	addi	sp,sp,24
 820c7d8:	f800283a 	ret
 820c7dc:	89400117 	ldw	r5,4(r17)
 820c7e0:	9009883a 	mov	r4,r18
 820c7e4:	d9c00015 	stw	r7,0(sp)
 820c7e8:	29400044 	addi	r5,r5,1
 820c7ec:	820c6580 	call	820c658 <_Balloc>
 820c7f0:	89800417 	ldw	r6,16(r17)
 820c7f4:	89400304 	addi	r5,r17,12
 820c7f8:	11000304 	addi	r4,r2,12
 820c7fc:	31800084 	addi	r6,r6,2
 820c800:	318d883a 	add	r6,r6,r6
 820c804:	318d883a 	add	r6,r6,r6
 820c808:	1027883a 	mov	r19,r2
 820c80c:	8202f100 	call	8202f10 <memcpy>
 820c810:	d9c00017 	ldw	r7,0(sp)
 820c814:	88000a26 	beq	r17,zero,820c840 <__multadd+0x118>
 820c818:	88c00117 	ldw	r3,4(r17)
 820c81c:	90801317 	ldw	r2,76(r18)
 820c820:	18c7883a 	add	r3,r3,r3
 820c824:	18c7883a 	add	r3,r3,r3
 820c828:	10c5883a 	add	r2,r2,r3
 820c82c:	10c00017 	ldw	r3,0(r2)
 820c830:	88c00015 	stw	r3,0(r17)
 820c834:	14400015 	stw	r17,0(r2)
 820c838:	9823883a 	mov	r17,r19
 820c83c:	003fd806 	br	820c7a0 <__multadd+0x78>
 820c840:	9823883a 	mov	r17,r19
 820c844:	003fd606 	br	820c7a0 <__multadd+0x78>

0820c848 <__s2b>:
 820c848:	defff904 	addi	sp,sp,-28
 820c84c:	dc400115 	stw	r17,4(sp)
 820c850:	dc000015 	stw	r16,0(sp)
 820c854:	2023883a 	mov	r17,r4
 820c858:	2821883a 	mov	r16,r5
 820c85c:	39000204 	addi	r4,r7,8
 820c860:	01400244 	movi	r5,9
 820c864:	dcc00315 	stw	r19,12(sp)
 820c868:	dc800215 	stw	r18,8(sp)
 820c86c:	dfc00615 	stw	ra,24(sp)
 820c870:	dd400515 	stw	r21,20(sp)
 820c874:	dd000415 	stw	r20,16(sp)
 820c878:	3825883a 	mov	r18,r7
 820c87c:	3027883a 	mov	r19,r6
 820c880:	8202b180 	call	8202b18 <__divsi3>
 820c884:	00c00044 	movi	r3,1
 820c888:	000b883a 	mov	r5,zero
 820c88c:	1880030e 	bge	r3,r2,820c89c <__s2b+0x54>
 820c890:	18c7883a 	add	r3,r3,r3
 820c894:	29400044 	addi	r5,r5,1
 820c898:	18bffd16 	blt	r3,r2,820c890 <__s2b+0x48>
 820c89c:	8809883a 	mov	r4,r17
 820c8a0:	820c6580 	call	820c658 <_Balloc>
 820c8a4:	d8c00717 	ldw	r3,28(sp)
 820c8a8:	10c00515 	stw	r3,20(r2)
 820c8ac:	00c00044 	movi	r3,1
 820c8b0:	10c00415 	stw	r3,16(r2)
 820c8b4:	00c00244 	movi	r3,9
 820c8b8:	1cc0210e 	bge	r3,r19,820c940 <__s2b+0xf8>
 820c8bc:	80eb883a 	add	r21,r16,r3
 820c8c0:	a829883a 	mov	r20,r21
 820c8c4:	84e1883a 	add	r16,r16,r19
 820c8c8:	a1c00007 	ldb	r7,0(r20)
 820c8cc:	01800284 	movi	r6,10
 820c8d0:	a5000044 	addi	r20,r20,1
 820c8d4:	100b883a 	mov	r5,r2
 820c8d8:	39fff404 	addi	r7,r7,-48
 820c8dc:	8809883a 	mov	r4,r17
 820c8e0:	820c7280 	call	820c728 <__multadd>
 820c8e4:	a43ff81e 	bne	r20,r16,820c8c8 <__s2b+0x80>
 820c8e8:	ace1883a 	add	r16,r21,r19
 820c8ec:	843ffe04 	addi	r16,r16,-8
 820c8f0:	9c800a0e 	bge	r19,r18,820c91c <__s2b+0xd4>
 820c8f4:	94e5c83a 	sub	r18,r18,r19
 820c8f8:	84a5883a 	add	r18,r16,r18
 820c8fc:	81c00007 	ldb	r7,0(r16)
 820c900:	01800284 	movi	r6,10
 820c904:	84000044 	addi	r16,r16,1
 820c908:	100b883a 	mov	r5,r2
 820c90c:	39fff404 	addi	r7,r7,-48
 820c910:	8809883a 	mov	r4,r17
 820c914:	820c7280 	call	820c728 <__multadd>
 820c918:	84bff81e 	bne	r16,r18,820c8fc <__s2b+0xb4>
 820c91c:	dfc00617 	ldw	ra,24(sp)
 820c920:	dd400517 	ldw	r21,20(sp)
 820c924:	dd000417 	ldw	r20,16(sp)
 820c928:	dcc00317 	ldw	r19,12(sp)
 820c92c:	dc800217 	ldw	r18,8(sp)
 820c930:	dc400117 	ldw	r17,4(sp)
 820c934:	dc000017 	ldw	r16,0(sp)
 820c938:	dec00704 	addi	sp,sp,28
 820c93c:	f800283a 	ret
 820c940:	84000284 	addi	r16,r16,10
 820c944:	1827883a 	mov	r19,r3
 820c948:	003fe906 	br	820c8f0 <__s2b+0xa8>

0820c94c <__hi0bits>:
 820c94c:	20bfffec 	andhi	r2,r4,65535
 820c950:	1000141e 	bne	r2,zero,820c9a4 <__hi0bits+0x58>
 820c954:	2008943a 	slli	r4,r4,16
 820c958:	00800404 	movi	r2,16
 820c95c:	20ffc02c 	andhi	r3,r4,65280
 820c960:	1800021e 	bne	r3,zero,820c96c <__hi0bits+0x20>
 820c964:	2008923a 	slli	r4,r4,8
 820c968:	10800204 	addi	r2,r2,8
 820c96c:	20fc002c 	andhi	r3,r4,61440
 820c970:	1800021e 	bne	r3,zero,820c97c <__hi0bits+0x30>
 820c974:	2008913a 	slli	r4,r4,4
 820c978:	10800104 	addi	r2,r2,4
 820c97c:	20f0002c 	andhi	r3,r4,49152
 820c980:	1800031e 	bne	r3,zero,820c990 <__hi0bits+0x44>
 820c984:	2109883a 	add	r4,r4,r4
 820c988:	10800084 	addi	r2,r2,2
 820c98c:	2109883a 	add	r4,r4,r4
 820c990:	20000316 	blt	r4,zero,820c9a0 <__hi0bits+0x54>
 820c994:	2110002c 	andhi	r4,r4,16384
 820c998:	2000041e 	bne	r4,zero,820c9ac <__hi0bits+0x60>
 820c99c:	00800804 	movi	r2,32
 820c9a0:	f800283a 	ret
 820c9a4:	0005883a 	mov	r2,zero
 820c9a8:	003fec06 	br	820c95c <__hi0bits+0x10>
 820c9ac:	10800044 	addi	r2,r2,1
 820c9b0:	f800283a 	ret

0820c9b4 <__lo0bits>:
 820c9b4:	20c00017 	ldw	r3,0(r4)
 820c9b8:	188001cc 	andi	r2,r3,7
 820c9bc:	10000826 	beq	r2,zero,820c9e0 <__lo0bits+0x2c>
 820c9c0:	1880004c 	andi	r2,r3,1
 820c9c4:	1000211e 	bne	r2,zero,820ca4c <__lo0bits+0x98>
 820c9c8:	1880008c 	andi	r2,r3,2
 820c9cc:	1000211e 	bne	r2,zero,820ca54 <__lo0bits+0xa0>
 820c9d0:	1806d0ba 	srli	r3,r3,2
 820c9d4:	00800084 	movi	r2,2
 820c9d8:	20c00015 	stw	r3,0(r4)
 820c9dc:	f800283a 	ret
 820c9e0:	18bfffcc 	andi	r2,r3,65535
 820c9e4:	10001326 	beq	r2,zero,820ca34 <__lo0bits+0x80>
 820c9e8:	0005883a 	mov	r2,zero
 820c9ec:	19403fcc 	andi	r5,r3,255
 820c9f0:	2800021e 	bne	r5,zero,820c9fc <__lo0bits+0x48>
 820c9f4:	1806d23a 	srli	r3,r3,8
 820c9f8:	10800204 	addi	r2,r2,8
 820c9fc:	194003cc 	andi	r5,r3,15
 820ca00:	2800021e 	bne	r5,zero,820ca0c <__lo0bits+0x58>
 820ca04:	1806d13a 	srli	r3,r3,4
 820ca08:	10800104 	addi	r2,r2,4
 820ca0c:	194000cc 	andi	r5,r3,3
 820ca10:	2800021e 	bne	r5,zero,820ca1c <__lo0bits+0x68>
 820ca14:	1806d0ba 	srli	r3,r3,2
 820ca18:	10800084 	addi	r2,r2,2
 820ca1c:	1940004c 	andi	r5,r3,1
 820ca20:	2800081e 	bne	r5,zero,820ca44 <__lo0bits+0x90>
 820ca24:	1806d07a 	srli	r3,r3,1
 820ca28:	1800051e 	bne	r3,zero,820ca40 <__lo0bits+0x8c>
 820ca2c:	00800804 	movi	r2,32
 820ca30:	f800283a 	ret
 820ca34:	1806d43a 	srli	r3,r3,16
 820ca38:	00800404 	movi	r2,16
 820ca3c:	003feb06 	br	820c9ec <__lo0bits+0x38>
 820ca40:	10800044 	addi	r2,r2,1
 820ca44:	20c00015 	stw	r3,0(r4)
 820ca48:	f800283a 	ret
 820ca4c:	0005883a 	mov	r2,zero
 820ca50:	f800283a 	ret
 820ca54:	1806d07a 	srli	r3,r3,1
 820ca58:	00800044 	movi	r2,1
 820ca5c:	20c00015 	stw	r3,0(r4)
 820ca60:	f800283a 	ret

0820ca64 <__i2b>:
 820ca64:	defffd04 	addi	sp,sp,-12
 820ca68:	dc000015 	stw	r16,0(sp)
 820ca6c:	04000044 	movi	r16,1
 820ca70:	dc400115 	stw	r17,4(sp)
 820ca74:	2823883a 	mov	r17,r5
 820ca78:	800b883a 	mov	r5,r16
 820ca7c:	dfc00215 	stw	ra,8(sp)
 820ca80:	820c6580 	call	820c658 <_Balloc>
 820ca84:	14400515 	stw	r17,20(r2)
 820ca88:	14000415 	stw	r16,16(r2)
 820ca8c:	dfc00217 	ldw	ra,8(sp)
 820ca90:	dc400117 	ldw	r17,4(sp)
 820ca94:	dc000017 	ldw	r16,0(sp)
 820ca98:	dec00304 	addi	sp,sp,12
 820ca9c:	f800283a 	ret

0820caa0 <__multiply>:
 820caa0:	defffa04 	addi	sp,sp,-24
 820caa4:	dcc00315 	stw	r19,12(sp)
 820caa8:	dc800215 	stw	r18,8(sp)
 820caac:	34c00417 	ldw	r19,16(r6)
 820cab0:	2c800417 	ldw	r18,16(r5)
 820cab4:	dd000415 	stw	r20,16(sp)
 820cab8:	dc400115 	stw	r17,4(sp)
 820cabc:	dfc00515 	stw	ra,20(sp)
 820cac0:	dc000015 	stw	r16,0(sp)
 820cac4:	2829883a 	mov	r20,r5
 820cac8:	3023883a 	mov	r17,r6
 820cacc:	94c0050e 	bge	r18,r19,820cae4 <__multiply+0x44>
 820cad0:	9007883a 	mov	r3,r18
 820cad4:	3029883a 	mov	r20,r6
 820cad8:	9825883a 	mov	r18,r19
 820cadc:	2823883a 	mov	r17,r5
 820cae0:	1827883a 	mov	r19,r3
 820cae4:	a0800217 	ldw	r2,8(r20)
 820cae8:	94e1883a 	add	r16,r18,r19
 820caec:	a1400117 	ldw	r5,4(r20)
 820caf0:	1400010e 	bge	r2,r16,820caf8 <__multiply+0x58>
 820caf4:	29400044 	addi	r5,r5,1
 820caf8:	820c6580 	call	820c658 <_Balloc>
 820cafc:	8415883a 	add	r10,r16,r16
 820cb00:	12c00504 	addi	r11,r2,20
 820cb04:	5295883a 	add	r10,r10,r10
 820cb08:	5a95883a 	add	r10,r11,r10
 820cb0c:	5807883a 	mov	r3,r11
 820cb10:	5a80032e 	bgeu	r11,r10,820cb20 <__multiply+0x80>
 820cb14:	18000015 	stw	zero,0(r3)
 820cb18:	18c00104 	addi	r3,r3,4
 820cb1c:	1abffd36 	bltu	r3,r10,820cb14 <__multiply+0x74>
 820cb20:	9ce7883a 	add	r19,r19,r19
 820cb24:	94a5883a 	add	r18,r18,r18
 820cb28:	89800504 	addi	r6,r17,20
 820cb2c:	9ce7883a 	add	r19,r19,r19
 820cb30:	a3400504 	addi	r13,r20,20
 820cb34:	94a5883a 	add	r18,r18,r18
 820cb38:	34d9883a 	add	r12,r6,r19
 820cb3c:	6c93883a 	add	r9,r13,r18
 820cb40:	3300422e 	bgeu	r6,r12,820cc4c <__multiply+0x1ac>
 820cb44:	37c00017 	ldw	ra,0(r6)
 820cb48:	fbffffcc 	andi	r15,ra,65535
 820cb4c:	78001b26 	beq	r15,zero,820cbbc <__multiply+0x11c>
 820cb50:	5811883a 	mov	r8,r11
 820cb54:	681d883a 	mov	r14,r13
 820cb58:	000f883a 	mov	r7,zero
 820cb5c:	71000017 	ldw	r4,0(r14)
 820cb60:	40c00017 	ldw	r3,0(r8)
 820cb64:	73800104 	addi	r14,r14,4
 820cb68:	217fffcc 	andi	r5,r4,65535
 820cb6c:	2bcb383a 	mul	r5,r5,r15
 820cb70:	2008d43a 	srli	r4,r4,16
 820cb74:	1c7fffcc 	andi	r17,r3,65535
 820cb78:	2c4b883a 	add	r5,r5,r17
 820cb7c:	29cb883a 	add	r5,r5,r7
 820cb80:	23c9383a 	mul	r4,r4,r15
 820cb84:	1806d43a 	srli	r3,r3,16
 820cb88:	280ed43a 	srli	r7,r5,16
 820cb8c:	297fffcc 	andi	r5,r5,65535
 820cb90:	20c7883a 	add	r3,r4,r3
 820cb94:	19c7883a 	add	r3,r3,r7
 820cb98:	1808943a 	slli	r4,r3,16
 820cb9c:	4023883a 	mov	r17,r8
 820cba0:	180ed43a 	srli	r7,r3,16
 820cba4:	214ab03a 	or	r5,r4,r5
 820cba8:	41400015 	stw	r5,0(r8)
 820cbac:	42000104 	addi	r8,r8,4
 820cbb0:	727fea36 	bltu	r14,r9,820cb5c <__multiply+0xbc>
 820cbb4:	89c00115 	stw	r7,4(r17)
 820cbb8:	37c00017 	ldw	ra,0(r6)
 820cbbc:	f83ed43a 	srli	ra,ra,16
 820cbc0:	f8001f26 	beq	ra,zero,820cc40 <__multiply+0x1a0>
 820cbc4:	58c00017 	ldw	r3,0(r11)
 820cbc8:	681d883a 	mov	r14,r13
 820cbcc:	581f883a 	mov	r15,r11
 820cbd0:	1811883a 	mov	r8,r3
 820cbd4:	5825883a 	mov	r18,r11
 820cbd8:	000f883a 	mov	r7,zero
 820cbdc:	00000106 	br	820cbe4 <__multiply+0x144>
 820cbe0:	8825883a 	mov	r18,r17
 820cbe4:	7140000b 	ldhu	r5,0(r14)
 820cbe8:	4010d43a 	srli	r8,r8,16
 820cbec:	193fffcc 	andi	r4,r3,65535
 820cbf0:	2fcb383a 	mul	r5,r5,ra
 820cbf4:	7bc00104 	addi	r15,r15,4
 820cbf8:	73800104 	addi	r14,r14,4
 820cbfc:	2a0b883a 	add	r5,r5,r8
 820cc00:	29cb883a 	add	r5,r5,r7
 820cc04:	2806943a 	slli	r3,r5,16
 820cc08:	94400104 	addi	r17,r18,4
 820cc0c:	280ad43a 	srli	r5,r5,16
 820cc10:	1908b03a 	or	r4,r3,r4
 820cc14:	793fff15 	stw	r4,-4(r15)
 820cc18:	70ffff17 	ldw	r3,-4(r14)
 820cc1c:	8a000017 	ldw	r8,0(r17)
 820cc20:	1806d43a 	srli	r3,r3,16
 820cc24:	413fffcc 	andi	r4,r8,65535
 820cc28:	1fc7383a 	mul	r3,r3,ra
 820cc2c:	1907883a 	add	r3,r3,r4
 820cc30:	1947883a 	add	r3,r3,r5
 820cc34:	180ed43a 	srli	r7,r3,16
 820cc38:	727fe936 	bltu	r14,r9,820cbe0 <__multiply+0x140>
 820cc3c:	90c00115 	stw	r3,4(r18)
 820cc40:	31800104 	addi	r6,r6,4
 820cc44:	5ac00104 	addi	r11,r11,4
 820cc48:	333fbe36 	bltu	r6,r12,820cb44 <__multiply+0xa4>
 820cc4c:	0400090e 	bge	zero,r16,820cc74 <__multiply+0x1d4>
 820cc50:	50ffff17 	ldw	r3,-4(r10)
 820cc54:	52bfff04 	addi	r10,r10,-4
 820cc58:	18000326 	beq	r3,zero,820cc68 <__multiply+0x1c8>
 820cc5c:	00000506 	br	820cc74 <__multiply+0x1d4>
 820cc60:	50c00017 	ldw	r3,0(r10)
 820cc64:	1800031e 	bne	r3,zero,820cc74 <__multiply+0x1d4>
 820cc68:	843fffc4 	addi	r16,r16,-1
 820cc6c:	52bfff04 	addi	r10,r10,-4
 820cc70:	803ffb1e 	bne	r16,zero,820cc60 <__multiply+0x1c0>
 820cc74:	14000415 	stw	r16,16(r2)
 820cc78:	dfc00517 	ldw	ra,20(sp)
 820cc7c:	dd000417 	ldw	r20,16(sp)
 820cc80:	dcc00317 	ldw	r19,12(sp)
 820cc84:	dc800217 	ldw	r18,8(sp)
 820cc88:	dc400117 	ldw	r17,4(sp)
 820cc8c:	dc000017 	ldw	r16,0(sp)
 820cc90:	dec00604 	addi	sp,sp,24
 820cc94:	f800283a 	ret

0820cc98 <__pow5mult>:
 820cc98:	defffa04 	addi	sp,sp,-24
 820cc9c:	dcc00315 	stw	r19,12(sp)
 820cca0:	dc000015 	stw	r16,0(sp)
 820cca4:	dfc00515 	stw	ra,20(sp)
 820cca8:	dd000415 	stw	r20,16(sp)
 820ccac:	dc800215 	stw	r18,8(sp)
 820ccb0:	dc400115 	stw	r17,4(sp)
 820ccb4:	308000cc 	andi	r2,r6,3
 820ccb8:	3021883a 	mov	r16,r6
 820ccbc:	2027883a 	mov	r19,r4
 820ccc0:	10002f1e 	bne	r2,zero,820cd80 <__pow5mult+0xe8>
 820ccc4:	2825883a 	mov	r18,r5
 820ccc8:	8021d0ba 	srai	r16,r16,2
 820cccc:	80001a26 	beq	r16,zero,820cd38 <__pow5mult+0xa0>
 820ccd0:	9c401217 	ldw	r17,72(r19)
 820ccd4:	8800061e 	bne	r17,zero,820ccf0 <__pow5mult+0x58>
 820ccd8:	00003406 	br	820cdac <__pow5mult+0x114>
 820ccdc:	8021d07a 	srai	r16,r16,1
 820cce0:	80001526 	beq	r16,zero,820cd38 <__pow5mult+0xa0>
 820cce4:	88800017 	ldw	r2,0(r17)
 820cce8:	10001c26 	beq	r2,zero,820cd5c <__pow5mult+0xc4>
 820ccec:	1023883a 	mov	r17,r2
 820ccf0:	8080004c 	andi	r2,r16,1
 820ccf4:	103ff926 	beq	r2,zero,820ccdc <__pow5mult+0x44>
 820ccf8:	880d883a 	mov	r6,r17
 820ccfc:	900b883a 	mov	r5,r18
 820cd00:	9809883a 	mov	r4,r19
 820cd04:	820caa00 	call	820caa0 <__multiply>
 820cd08:	90001b26 	beq	r18,zero,820cd78 <__pow5mult+0xe0>
 820cd0c:	91000117 	ldw	r4,4(r18)
 820cd10:	98c01317 	ldw	r3,76(r19)
 820cd14:	8021d07a 	srai	r16,r16,1
 820cd18:	2109883a 	add	r4,r4,r4
 820cd1c:	2109883a 	add	r4,r4,r4
 820cd20:	1907883a 	add	r3,r3,r4
 820cd24:	19000017 	ldw	r4,0(r3)
 820cd28:	91000015 	stw	r4,0(r18)
 820cd2c:	1c800015 	stw	r18,0(r3)
 820cd30:	1025883a 	mov	r18,r2
 820cd34:	803feb1e 	bne	r16,zero,820cce4 <__pow5mult+0x4c>
 820cd38:	9005883a 	mov	r2,r18
 820cd3c:	dfc00517 	ldw	ra,20(sp)
 820cd40:	dd000417 	ldw	r20,16(sp)
 820cd44:	dcc00317 	ldw	r19,12(sp)
 820cd48:	dc800217 	ldw	r18,8(sp)
 820cd4c:	dc400117 	ldw	r17,4(sp)
 820cd50:	dc000017 	ldw	r16,0(sp)
 820cd54:	dec00604 	addi	sp,sp,24
 820cd58:	f800283a 	ret
 820cd5c:	880d883a 	mov	r6,r17
 820cd60:	880b883a 	mov	r5,r17
 820cd64:	9809883a 	mov	r4,r19
 820cd68:	820caa00 	call	820caa0 <__multiply>
 820cd6c:	88800015 	stw	r2,0(r17)
 820cd70:	10000015 	stw	zero,0(r2)
 820cd74:	003fdd06 	br	820ccec <__pow5mult+0x54>
 820cd78:	1025883a 	mov	r18,r2
 820cd7c:	003fd706 	br	820ccdc <__pow5mult+0x44>
 820cd80:	10bfffc4 	addi	r2,r2,-1
 820cd84:	1085883a 	add	r2,r2,r2
 820cd88:	00c20974 	movhi	r3,2085
 820cd8c:	18f6e204 	addi	r3,r3,-9336
 820cd90:	1085883a 	add	r2,r2,r2
 820cd94:	1885883a 	add	r2,r3,r2
 820cd98:	11800017 	ldw	r6,0(r2)
 820cd9c:	000f883a 	mov	r7,zero
 820cda0:	820c7280 	call	820c728 <__multadd>
 820cda4:	1025883a 	mov	r18,r2
 820cda8:	003fc706 	br	820ccc8 <__pow5mult+0x30>
 820cdac:	05000044 	movi	r20,1
 820cdb0:	a00b883a 	mov	r5,r20
 820cdb4:	9809883a 	mov	r4,r19
 820cdb8:	820c6580 	call	820c658 <_Balloc>
 820cdbc:	1023883a 	mov	r17,r2
 820cdc0:	00809c44 	movi	r2,625
 820cdc4:	88800515 	stw	r2,20(r17)
 820cdc8:	8d000415 	stw	r20,16(r17)
 820cdcc:	9c401215 	stw	r17,72(r19)
 820cdd0:	88000015 	stw	zero,0(r17)
 820cdd4:	003fc606 	br	820ccf0 <__pow5mult+0x58>

0820cdd8 <__lshift>:
 820cdd8:	defff904 	addi	sp,sp,-28
 820cddc:	dd400515 	stw	r21,20(sp)
 820cde0:	dcc00315 	stw	r19,12(sp)
 820cde4:	302bd17a 	srai	r21,r6,5
 820cde8:	2cc00417 	ldw	r19,16(r5)
 820cdec:	28800217 	ldw	r2,8(r5)
 820cdf0:	dd000415 	stw	r20,16(sp)
 820cdf4:	ace7883a 	add	r19,r21,r19
 820cdf8:	dc800215 	stw	r18,8(sp)
 820cdfc:	dc400115 	stw	r17,4(sp)
 820ce00:	dc000015 	stw	r16,0(sp)
 820ce04:	dfc00615 	stw	ra,24(sp)
 820ce08:	9c000044 	addi	r16,r19,1
 820ce0c:	2823883a 	mov	r17,r5
 820ce10:	3029883a 	mov	r20,r6
 820ce14:	2025883a 	mov	r18,r4
 820ce18:	29400117 	ldw	r5,4(r5)
 820ce1c:	1400030e 	bge	r2,r16,820ce2c <__lshift+0x54>
 820ce20:	1085883a 	add	r2,r2,r2
 820ce24:	29400044 	addi	r5,r5,1
 820ce28:	143ffd16 	blt	r2,r16,820ce20 <__lshift+0x48>
 820ce2c:	9009883a 	mov	r4,r18
 820ce30:	820c6580 	call	820c658 <_Balloc>
 820ce34:	10c00504 	addi	r3,r2,20
 820ce38:	0540070e 	bge	zero,r21,820ce58 <__lshift+0x80>
 820ce3c:	ad6b883a 	add	r21,r21,r21
 820ce40:	ad6b883a 	add	r21,r21,r21
 820ce44:	1809883a 	mov	r4,r3
 820ce48:	1d47883a 	add	r3,r3,r21
 820ce4c:	20000015 	stw	zero,0(r4)
 820ce50:	21000104 	addi	r4,r4,4
 820ce54:	193ffd1e 	bne	r3,r4,820ce4c <__lshift+0x74>
 820ce58:	8a000417 	ldw	r8,16(r17)
 820ce5c:	89000504 	addi	r4,r17,20
 820ce60:	a18007cc 	andi	r6,r20,31
 820ce64:	4211883a 	add	r8,r8,r8
 820ce68:	4211883a 	add	r8,r8,r8
 820ce6c:	2211883a 	add	r8,r4,r8
 820ce70:	30002326 	beq	r6,zero,820cf00 <__lshift+0x128>
 820ce74:	02400804 	movi	r9,32
 820ce78:	4993c83a 	sub	r9,r9,r6
 820ce7c:	000b883a 	mov	r5,zero
 820ce80:	21c00017 	ldw	r7,0(r4)
 820ce84:	1815883a 	mov	r10,r3
 820ce88:	18c00104 	addi	r3,r3,4
 820ce8c:	398e983a 	sll	r7,r7,r6
 820ce90:	21000104 	addi	r4,r4,4
 820ce94:	394ab03a 	or	r5,r7,r5
 820ce98:	197fff15 	stw	r5,-4(r3)
 820ce9c:	217fff17 	ldw	r5,-4(r4)
 820cea0:	2a4ad83a 	srl	r5,r5,r9
 820cea4:	223ff636 	bltu	r4,r8,820ce80 <__lshift+0xa8>
 820cea8:	51400115 	stw	r5,4(r10)
 820ceac:	28001a1e 	bne	r5,zero,820cf18 <__lshift+0x140>
 820ceb0:	843fffc4 	addi	r16,r16,-1
 820ceb4:	14000415 	stw	r16,16(r2)
 820ceb8:	88000826 	beq	r17,zero,820cedc <__lshift+0x104>
 820cebc:	89000117 	ldw	r4,4(r17)
 820cec0:	90c01317 	ldw	r3,76(r18)
 820cec4:	2109883a 	add	r4,r4,r4
 820cec8:	2109883a 	add	r4,r4,r4
 820cecc:	1907883a 	add	r3,r3,r4
 820ced0:	19000017 	ldw	r4,0(r3)
 820ced4:	89000015 	stw	r4,0(r17)
 820ced8:	1c400015 	stw	r17,0(r3)
 820cedc:	dfc00617 	ldw	ra,24(sp)
 820cee0:	dd400517 	ldw	r21,20(sp)
 820cee4:	dd000417 	ldw	r20,16(sp)
 820cee8:	dcc00317 	ldw	r19,12(sp)
 820ceec:	dc800217 	ldw	r18,8(sp)
 820cef0:	dc400117 	ldw	r17,4(sp)
 820cef4:	dc000017 	ldw	r16,0(sp)
 820cef8:	dec00704 	addi	sp,sp,28
 820cefc:	f800283a 	ret
 820cf00:	21400017 	ldw	r5,0(r4)
 820cf04:	18c00104 	addi	r3,r3,4
 820cf08:	21000104 	addi	r4,r4,4
 820cf0c:	197fff15 	stw	r5,-4(r3)
 820cf10:	223ffb36 	bltu	r4,r8,820cf00 <__lshift+0x128>
 820cf14:	003fe606 	br	820ceb0 <__lshift+0xd8>
 820cf18:	9c000084 	addi	r16,r19,2
 820cf1c:	003fe406 	br	820ceb0 <__lshift+0xd8>

0820cf20 <__mcmp>:
 820cf20:	20800417 	ldw	r2,16(r4)
 820cf24:	28c00417 	ldw	r3,16(r5)
 820cf28:	10c5c83a 	sub	r2,r2,r3
 820cf2c:	1000111e 	bne	r2,zero,820cf74 <__mcmp+0x54>
 820cf30:	18c7883a 	add	r3,r3,r3
 820cf34:	18c7883a 	add	r3,r3,r3
 820cf38:	21000504 	addi	r4,r4,20
 820cf3c:	29400504 	addi	r5,r5,20
 820cf40:	20c5883a 	add	r2,r4,r3
 820cf44:	28cb883a 	add	r5,r5,r3
 820cf48:	00000106 	br	820cf50 <__mcmp+0x30>
 820cf4c:	20800a2e 	bgeu	r4,r2,820cf78 <__mcmp+0x58>
 820cf50:	10bfff04 	addi	r2,r2,-4
 820cf54:	297fff04 	addi	r5,r5,-4
 820cf58:	11800017 	ldw	r6,0(r2)
 820cf5c:	28c00017 	ldw	r3,0(r5)
 820cf60:	30fffa26 	beq	r6,r3,820cf4c <__mcmp+0x2c>
 820cf64:	30c00236 	bltu	r6,r3,820cf70 <__mcmp+0x50>
 820cf68:	00800044 	movi	r2,1
 820cf6c:	f800283a 	ret
 820cf70:	00bfffc4 	movi	r2,-1
 820cf74:	f800283a 	ret
 820cf78:	0005883a 	mov	r2,zero
 820cf7c:	f800283a 	ret

0820cf80 <__mdiff>:
 820cf80:	28c00417 	ldw	r3,16(r5)
 820cf84:	30800417 	ldw	r2,16(r6)
 820cf88:	defffa04 	addi	sp,sp,-24
 820cf8c:	dcc00315 	stw	r19,12(sp)
 820cf90:	dc800215 	stw	r18,8(sp)
 820cf94:	dfc00515 	stw	ra,20(sp)
 820cf98:	dd000415 	stw	r20,16(sp)
 820cf9c:	dc400115 	stw	r17,4(sp)
 820cfa0:	dc000015 	stw	r16,0(sp)
 820cfa4:	1887c83a 	sub	r3,r3,r2
 820cfa8:	2825883a 	mov	r18,r5
 820cfac:	3027883a 	mov	r19,r6
 820cfb0:	1800141e 	bne	r3,zero,820d004 <__mdiff+0x84>
 820cfb4:	1085883a 	add	r2,r2,r2
 820cfb8:	1085883a 	add	r2,r2,r2
 820cfbc:	2a000504 	addi	r8,r5,20
 820cfc0:	34000504 	addi	r16,r6,20
 820cfc4:	4087883a 	add	r3,r8,r2
 820cfc8:	8085883a 	add	r2,r16,r2
 820cfcc:	00000106 	br	820cfd4 <__mdiff+0x54>
 820cfd0:	40c0592e 	bgeu	r8,r3,820d138 <__mdiff+0x1b8>
 820cfd4:	18ffff04 	addi	r3,r3,-4
 820cfd8:	10bfff04 	addi	r2,r2,-4
 820cfdc:	19c00017 	ldw	r7,0(r3)
 820cfe0:	11400017 	ldw	r5,0(r2)
 820cfe4:	397ffa26 	beq	r7,r5,820cfd0 <__mdiff+0x50>
 820cfe8:	3940592e 	bgeu	r7,r5,820d150 <__mdiff+0x1d0>
 820cfec:	9005883a 	mov	r2,r18
 820cff0:	4023883a 	mov	r17,r8
 820cff4:	9825883a 	mov	r18,r19
 820cff8:	05000044 	movi	r20,1
 820cffc:	1027883a 	mov	r19,r2
 820d000:	00000406 	br	820d014 <__mdiff+0x94>
 820d004:	18005616 	blt	r3,zero,820d160 <__mdiff+0x1e0>
 820d008:	34400504 	addi	r17,r6,20
 820d00c:	2c000504 	addi	r16,r5,20
 820d010:	0029883a 	mov	r20,zero
 820d014:	91400117 	ldw	r5,4(r18)
 820d018:	820c6580 	call	820c658 <_Balloc>
 820d01c:	92400417 	ldw	r9,16(r18)
 820d020:	9b000417 	ldw	r12,16(r19)
 820d024:	12c00504 	addi	r11,r2,20
 820d028:	4a51883a 	add	r8,r9,r9
 820d02c:	6319883a 	add	r12,r12,r12
 820d030:	4211883a 	add	r8,r8,r8
 820d034:	6319883a 	add	r12,r12,r12
 820d038:	15000315 	stw	r20,12(r2)
 820d03c:	8211883a 	add	r8,r16,r8
 820d040:	8b19883a 	add	r12,r17,r12
 820d044:	0007883a 	mov	r3,zero
 820d048:	81400017 	ldw	r5,0(r16)
 820d04c:	89c00017 	ldw	r7,0(r17)
 820d050:	59800104 	addi	r6,r11,4
 820d054:	293fffcc 	andi	r4,r5,65535
 820d058:	20c7883a 	add	r3,r4,r3
 820d05c:	393fffcc 	andi	r4,r7,65535
 820d060:	1909c83a 	sub	r4,r3,r4
 820d064:	280ad43a 	srli	r5,r5,16
 820d068:	380ed43a 	srli	r7,r7,16
 820d06c:	2007d43a 	srai	r3,r4,16
 820d070:	213fffcc 	andi	r4,r4,65535
 820d074:	29cbc83a 	sub	r5,r5,r7
 820d078:	28c7883a 	add	r3,r5,r3
 820d07c:	180a943a 	slli	r5,r3,16
 820d080:	8c400104 	addi	r17,r17,4
 820d084:	84000104 	addi	r16,r16,4
 820d088:	2908b03a 	or	r4,r5,r4
 820d08c:	59000015 	stw	r4,0(r11)
 820d090:	1807d43a 	srai	r3,r3,16
 820d094:	3015883a 	mov	r10,r6
 820d098:	3017883a 	mov	r11,r6
 820d09c:	8b3fea36 	bltu	r17,r12,820d048 <__mdiff+0xc8>
 820d0a0:	8200162e 	bgeu	r16,r8,820d0fc <__mdiff+0x17c>
 820d0a4:	8017883a 	mov	r11,r16
 820d0a8:	59400017 	ldw	r5,0(r11)
 820d0ac:	31800104 	addi	r6,r6,4
 820d0b0:	5ac00104 	addi	r11,r11,4
 820d0b4:	293fffcc 	andi	r4,r5,65535
 820d0b8:	20c7883a 	add	r3,r4,r3
 820d0bc:	280ed43a 	srli	r7,r5,16
 820d0c0:	180bd43a 	srai	r5,r3,16
 820d0c4:	193fffcc 	andi	r4,r3,65535
 820d0c8:	3947883a 	add	r3,r7,r5
 820d0cc:	180a943a 	slli	r5,r3,16
 820d0d0:	1807d43a 	srai	r3,r3,16
 820d0d4:	2908b03a 	or	r4,r5,r4
 820d0d8:	313fff15 	stw	r4,-4(r6)
 820d0dc:	5a3ff236 	bltu	r11,r8,820d0a8 <__mdiff+0x128>
 820d0e0:	0406303a 	nor	r3,zero,r16
 820d0e4:	1a07883a 	add	r3,r3,r8
 820d0e8:	1806d0ba 	srli	r3,r3,2
 820d0ec:	18c00044 	addi	r3,r3,1
 820d0f0:	18c7883a 	add	r3,r3,r3
 820d0f4:	18c7883a 	add	r3,r3,r3
 820d0f8:	50d5883a 	add	r10,r10,r3
 820d0fc:	50ffff04 	addi	r3,r10,-4
 820d100:	2000041e 	bne	r4,zero,820d114 <__mdiff+0x194>
 820d104:	18ffff04 	addi	r3,r3,-4
 820d108:	19000017 	ldw	r4,0(r3)
 820d10c:	4a7fffc4 	addi	r9,r9,-1
 820d110:	203ffc26 	beq	r4,zero,820d104 <__mdiff+0x184>
 820d114:	12400415 	stw	r9,16(r2)
 820d118:	dfc00517 	ldw	ra,20(sp)
 820d11c:	dd000417 	ldw	r20,16(sp)
 820d120:	dcc00317 	ldw	r19,12(sp)
 820d124:	dc800217 	ldw	r18,8(sp)
 820d128:	dc400117 	ldw	r17,4(sp)
 820d12c:	dc000017 	ldw	r16,0(sp)
 820d130:	dec00604 	addi	sp,sp,24
 820d134:	f800283a 	ret
 820d138:	000b883a 	mov	r5,zero
 820d13c:	820c6580 	call	820c658 <_Balloc>
 820d140:	00c00044 	movi	r3,1
 820d144:	10c00415 	stw	r3,16(r2)
 820d148:	10000515 	stw	zero,20(r2)
 820d14c:	003ff206 	br	820d118 <__mdiff+0x198>
 820d150:	8023883a 	mov	r17,r16
 820d154:	0029883a 	mov	r20,zero
 820d158:	4021883a 	mov	r16,r8
 820d15c:	003fad06 	br	820d014 <__mdiff+0x94>
 820d160:	9005883a 	mov	r2,r18
 820d164:	94400504 	addi	r17,r18,20
 820d168:	9c000504 	addi	r16,r19,20
 820d16c:	9825883a 	mov	r18,r19
 820d170:	05000044 	movi	r20,1
 820d174:	1027883a 	mov	r19,r2
 820d178:	003fa606 	br	820d014 <__mdiff+0x94>

0820d17c <__ulp>:
 820d17c:	295ffc2c 	andhi	r5,r5,32752
 820d180:	00bf3034 	movhi	r2,64704
 820d184:	2887883a 	add	r3,r5,r2
 820d188:	00c0020e 	bge	zero,r3,820d194 <__ulp+0x18>
 820d18c:	0005883a 	mov	r2,zero
 820d190:	f800283a 	ret
 820d194:	00c7c83a 	sub	r3,zero,r3
 820d198:	1807d53a 	srai	r3,r3,20
 820d19c:	008004c4 	movi	r2,19
 820d1a0:	10c00b0e 	bge	r2,r3,820d1d0 <__ulp+0x54>
 820d1a4:	18bffb04 	addi	r2,r3,-20
 820d1a8:	01000784 	movi	r4,30
 820d1ac:	0007883a 	mov	r3,zero
 820d1b0:	20800516 	blt	r4,r2,820d1c8 <__ulp+0x4c>
 820d1b4:	010007c4 	movi	r4,31
 820d1b8:	2089c83a 	sub	r4,r4,r2
 820d1bc:	00800044 	movi	r2,1
 820d1c0:	1104983a 	sll	r2,r2,r4
 820d1c4:	f800283a 	ret
 820d1c8:	00800044 	movi	r2,1
 820d1cc:	f800283a 	ret
 820d1d0:	01400234 	movhi	r5,8
 820d1d4:	28c7d83a 	sra	r3,r5,r3
 820d1d8:	0005883a 	mov	r2,zero
 820d1dc:	f800283a 	ret

0820d1e0 <__b2d>:
 820d1e0:	defffa04 	addi	sp,sp,-24
 820d1e4:	dc000015 	stw	r16,0(sp)
 820d1e8:	24000417 	ldw	r16,16(r4)
 820d1ec:	dc400115 	stw	r17,4(sp)
 820d1f0:	24400504 	addi	r17,r4,20
 820d1f4:	8421883a 	add	r16,r16,r16
 820d1f8:	8421883a 	add	r16,r16,r16
 820d1fc:	8c21883a 	add	r16,r17,r16
 820d200:	dc800215 	stw	r18,8(sp)
 820d204:	84bfff17 	ldw	r18,-4(r16)
 820d208:	dd000415 	stw	r20,16(sp)
 820d20c:	dcc00315 	stw	r19,12(sp)
 820d210:	9009883a 	mov	r4,r18
 820d214:	2829883a 	mov	r20,r5
 820d218:	dfc00515 	stw	ra,20(sp)
 820d21c:	820c94c0 	call	820c94c <__hi0bits>
 820d220:	00c00804 	movi	r3,32
 820d224:	1889c83a 	sub	r4,r3,r2
 820d228:	a1000015 	stw	r4,0(r20)
 820d22c:	01000284 	movi	r4,10
 820d230:	84ffff04 	addi	r19,r16,-4
 820d234:	20801216 	blt	r4,r2,820d280 <__b2d+0xa0>
 820d238:	018002c4 	movi	r6,11
 820d23c:	308dc83a 	sub	r6,r6,r2
 820d240:	9186d83a 	srl	r3,r18,r6
 820d244:	18cffc34 	orhi	r3,r3,16368
 820d248:	8cc0212e 	bgeu	r17,r19,820d2d0 <__b2d+0xf0>
 820d24c:	813ffe17 	ldw	r4,-8(r16)
 820d250:	218cd83a 	srl	r6,r4,r6
 820d254:	10800544 	addi	r2,r2,21
 820d258:	9084983a 	sll	r2,r18,r2
 820d25c:	1184b03a 	or	r2,r2,r6
 820d260:	dfc00517 	ldw	ra,20(sp)
 820d264:	dd000417 	ldw	r20,16(sp)
 820d268:	dcc00317 	ldw	r19,12(sp)
 820d26c:	dc800217 	ldw	r18,8(sp)
 820d270:	dc400117 	ldw	r17,4(sp)
 820d274:	dc000017 	ldw	r16,0(sp)
 820d278:	dec00604 	addi	sp,sp,24
 820d27c:	f800283a 	ret
 820d280:	8cc00f2e 	bgeu	r17,r19,820d2c0 <__b2d+0xe0>
 820d284:	117ffd44 	addi	r5,r2,-11
 820d288:	80bffe17 	ldw	r2,-8(r16)
 820d28c:	28000e26 	beq	r5,zero,820d2c8 <__b2d+0xe8>
 820d290:	1949c83a 	sub	r4,r3,r5
 820d294:	9164983a 	sll	r18,r18,r5
 820d298:	1106d83a 	srl	r3,r2,r4
 820d29c:	81bffe04 	addi	r6,r16,-8
 820d2a0:	948ffc34 	orhi	r18,r18,16368
 820d2a4:	90c6b03a 	or	r3,r18,r3
 820d2a8:	89800e2e 	bgeu	r17,r6,820d2e4 <__b2d+0x104>
 820d2ac:	81bffd17 	ldw	r6,-12(r16)
 820d2b0:	1144983a 	sll	r2,r2,r5
 820d2b4:	310ad83a 	srl	r5,r6,r4
 820d2b8:	2884b03a 	or	r2,r5,r2
 820d2bc:	003fe806 	br	820d260 <__b2d+0x80>
 820d2c0:	10bffd44 	addi	r2,r2,-11
 820d2c4:	1000041e 	bne	r2,zero,820d2d8 <__b2d+0xf8>
 820d2c8:	90cffc34 	orhi	r3,r18,16368
 820d2cc:	003fe406 	br	820d260 <__b2d+0x80>
 820d2d0:	000d883a 	mov	r6,zero
 820d2d4:	003fdf06 	br	820d254 <__b2d+0x74>
 820d2d8:	90a4983a 	sll	r18,r18,r2
 820d2dc:	0005883a 	mov	r2,zero
 820d2e0:	003ff906 	br	820d2c8 <__b2d+0xe8>
 820d2e4:	1144983a 	sll	r2,r2,r5
 820d2e8:	003fdd06 	br	820d260 <__b2d+0x80>

0820d2ec <__d2b>:
 820d2ec:	defff804 	addi	sp,sp,-32
 820d2f0:	dc000215 	stw	r16,8(sp)
 820d2f4:	3021883a 	mov	r16,r6
 820d2f8:	dc400315 	stw	r17,12(sp)
 820d2fc:	8022907a 	slli	r17,r16,1
 820d300:	dd000615 	stw	r20,24(sp)
 820d304:	2829883a 	mov	r20,r5
 820d308:	01400044 	movi	r5,1
 820d30c:	dcc00515 	stw	r19,20(sp)
 820d310:	dc800415 	stw	r18,16(sp)
 820d314:	dfc00715 	stw	ra,28(sp)
 820d318:	3825883a 	mov	r18,r7
 820d31c:	8822d57a 	srli	r17,r17,21
 820d320:	820c6580 	call	820c658 <_Balloc>
 820d324:	1027883a 	mov	r19,r2
 820d328:	00800434 	movhi	r2,16
 820d32c:	10bfffc4 	addi	r2,r2,-1
 820d330:	808c703a 	and	r6,r16,r2
 820d334:	88000126 	beq	r17,zero,820d33c <__d2b+0x50>
 820d338:	31800434 	orhi	r6,r6,16
 820d33c:	d9800015 	stw	r6,0(sp)
 820d340:	a0002426 	beq	r20,zero,820d3d4 <__d2b+0xe8>
 820d344:	d9000104 	addi	r4,sp,4
 820d348:	dd000115 	stw	r20,4(sp)
 820d34c:	820c9b40 	call	820c9b4 <__lo0bits>
 820d350:	d8c00017 	ldw	r3,0(sp)
 820d354:	10002f1e 	bne	r2,zero,820d414 <__d2b+0x128>
 820d358:	d9000117 	ldw	r4,4(sp)
 820d35c:	99000515 	stw	r4,20(r19)
 820d360:	1821003a 	cmpeq	r16,r3,zero
 820d364:	01000084 	movi	r4,2
 820d368:	2421c83a 	sub	r16,r4,r16
 820d36c:	98c00615 	stw	r3,24(r19)
 820d370:	9c000415 	stw	r16,16(r19)
 820d374:	88001f1e 	bne	r17,zero,820d3f4 <__d2b+0x108>
 820d378:	10bef384 	addi	r2,r2,-1074
 820d37c:	90800015 	stw	r2,0(r18)
 820d380:	00900034 	movhi	r2,16384
 820d384:	10bfffc4 	addi	r2,r2,-1
 820d388:	8085883a 	add	r2,r16,r2
 820d38c:	1085883a 	add	r2,r2,r2
 820d390:	1085883a 	add	r2,r2,r2
 820d394:	9885883a 	add	r2,r19,r2
 820d398:	11000517 	ldw	r4,20(r2)
 820d39c:	8020917a 	slli	r16,r16,5
 820d3a0:	820c94c0 	call	820c94c <__hi0bits>
 820d3a4:	d8c00817 	ldw	r3,32(sp)
 820d3a8:	8085c83a 	sub	r2,r16,r2
 820d3ac:	18800015 	stw	r2,0(r3)
 820d3b0:	9805883a 	mov	r2,r19
 820d3b4:	dfc00717 	ldw	ra,28(sp)
 820d3b8:	dd000617 	ldw	r20,24(sp)
 820d3bc:	dcc00517 	ldw	r19,20(sp)
 820d3c0:	dc800417 	ldw	r18,16(sp)
 820d3c4:	dc400317 	ldw	r17,12(sp)
 820d3c8:	dc000217 	ldw	r16,8(sp)
 820d3cc:	dec00804 	addi	sp,sp,32
 820d3d0:	f800283a 	ret
 820d3d4:	d809883a 	mov	r4,sp
 820d3d8:	820c9b40 	call	820c9b4 <__lo0bits>
 820d3dc:	d8c00017 	ldw	r3,0(sp)
 820d3e0:	04000044 	movi	r16,1
 820d3e4:	9c000415 	stw	r16,16(r19)
 820d3e8:	98c00515 	stw	r3,20(r19)
 820d3ec:	10800804 	addi	r2,r2,32
 820d3f0:	883fe126 	beq	r17,zero,820d378 <__d2b+0x8c>
 820d3f4:	00c00d44 	movi	r3,53
 820d3f8:	8c7ef344 	addi	r17,r17,-1075
 820d3fc:	88a3883a 	add	r17,r17,r2
 820d400:	1885c83a 	sub	r2,r3,r2
 820d404:	d8c00817 	ldw	r3,32(sp)
 820d408:	94400015 	stw	r17,0(r18)
 820d40c:	18800015 	stw	r2,0(r3)
 820d410:	003fe706 	br	820d3b0 <__d2b+0xc4>
 820d414:	01000804 	movi	r4,32
 820d418:	2089c83a 	sub	r4,r4,r2
 820d41c:	1908983a 	sll	r4,r3,r4
 820d420:	d9400117 	ldw	r5,4(sp)
 820d424:	1886d83a 	srl	r3,r3,r2
 820d428:	2148b03a 	or	r4,r4,r5
 820d42c:	99000515 	stw	r4,20(r19)
 820d430:	d8c00015 	stw	r3,0(sp)
 820d434:	003fca06 	br	820d360 <__d2b+0x74>

0820d438 <__ratio>:
 820d438:	defff904 	addi	sp,sp,-28
 820d43c:	dc400315 	stw	r17,12(sp)
 820d440:	2823883a 	mov	r17,r5
 820d444:	d9400104 	addi	r5,sp,4
 820d448:	dfc00615 	stw	ra,24(sp)
 820d44c:	dcc00515 	stw	r19,20(sp)
 820d450:	dc800415 	stw	r18,16(sp)
 820d454:	2027883a 	mov	r19,r4
 820d458:	dc000215 	stw	r16,8(sp)
 820d45c:	820d1e00 	call	820d1e0 <__b2d>
 820d460:	d80b883a 	mov	r5,sp
 820d464:	8809883a 	mov	r4,r17
 820d468:	1025883a 	mov	r18,r2
 820d46c:	1821883a 	mov	r16,r3
 820d470:	820d1e00 	call	820d1e0 <__b2d>
 820d474:	8a000417 	ldw	r8,16(r17)
 820d478:	99000417 	ldw	r4,16(r19)
 820d47c:	d9400117 	ldw	r5,4(sp)
 820d480:	2209c83a 	sub	r4,r4,r8
 820d484:	2010917a 	slli	r8,r4,5
 820d488:	d9000017 	ldw	r4,0(sp)
 820d48c:	2909c83a 	sub	r4,r5,r4
 820d490:	4109883a 	add	r4,r8,r4
 820d494:	01000e0e 	bge	zero,r4,820d4d0 <__ratio+0x98>
 820d498:	2008953a 	slli	r4,r4,20
 820d49c:	2421883a 	add	r16,r4,r16
 820d4a0:	100d883a 	mov	r6,r2
 820d4a4:	180f883a 	mov	r7,r3
 820d4a8:	9009883a 	mov	r4,r18
 820d4ac:	800b883a 	mov	r5,r16
 820d4b0:	82126140 	call	8212614 <__divdf3>
 820d4b4:	dfc00617 	ldw	ra,24(sp)
 820d4b8:	dcc00517 	ldw	r19,20(sp)
 820d4bc:	dc800417 	ldw	r18,16(sp)
 820d4c0:	dc400317 	ldw	r17,12(sp)
 820d4c4:	dc000217 	ldw	r16,8(sp)
 820d4c8:	dec00704 	addi	sp,sp,28
 820d4cc:	f800283a 	ret
 820d4d0:	2008953a 	slli	r4,r4,20
 820d4d4:	1907c83a 	sub	r3,r3,r4
 820d4d8:	003ff106 	br	820d4a0 <__ratio+0x68>

0820d4dc <_mprec_log10>:
 820d4dc:	defffe04 	addi	sp,sp,-8
 820d4e0:	dc000015 	stw	r16,0(sp)
 820d4e4:	dfc00115 	stw	ra,4(sp)
 820d4e8:	008005c4 	movi	r2,23
 820d4ec:	2021883a 	mov	r16,r4
 820d4f0:	11000d0e 	bge	r2,r4,820d528 <_mprec_log10+0x4c>
 820d4f4:	0005883a 	mov	r2,zero
 820d4f8:	00cffc34 	movhi	r3,16368
 820d4fc:	843fffc4 	addi	r16,r16,-1
 820d500:	000d883a 	mov	r6,zero
 820d504:	01d00934 	movhi	r7,16420
 820d508:	1009883a 	mov	r4,r2
 820d50c:	180b883a 	mov	r5,r3
 820d510:	82131540 	call	8213154 <__muldf3>
 820d514:	803ff91e 	bne	r16,zero,820d4fc <_mprec_log10+0x20>
 820d518:	dfc00117 	ldw	ra,4(sp)
 820d51c:	dc000017 	ldw	r16,0(sp)
 820d520:	dec00204 	addi	sp,sp,8
 820d524:	f800283a 	ret
 820d528:	202090fa 	slli	r16,r4,3
 820d52c:	00820974 	movhi	r2,2085
 820d530:	10b6f904 	addi	r2,r2,-9244
 820d534:	1421883a 	add	r16,r2,r16
 820d538:	80800017 	ldw	r2,0(r16)
 820d53c:	80c00117 	ldw	r3,4(r16)
 820d540:	dfc00117 	ldw	ra,4(sp)
 820d544:	dc000017 	ldw	r16,0(sp)
 820d548:	dec00204 	addi	sp,sp,8
 820d54c:	f800283a 	ret

0820d550 <__copybits>:
 820d550:	297fffc4 	addi	r5,r5,-1
 820d554:	280fd17a 	srai	r7,r5,5
 820d558:	30c00417 	ldw	r3,16(r6)
 820d55c:	30800504 	addi	r2,r6,20
 820d560:	39c00044 	addi	r7,r7,1
 820d564:	18c7883a 	add	r3,r3,r3
 820d568:	39cf883a 	add	r7,r7,r7
 820d56c:	18c7883a 	add	r3,r3,r3
 820d570:	39cf883a 	add	r7,r7,r7
 820d574:	10c7883a 	add	r3,r2,r3
 820d578:	21cf883a 	add	r7,r4,r7
 820d57c:	10c00d2e 	bgeu	r2,r3,820d5b4 <__copybits+0x64>
 820d580:	200b883a 	mov	r5,r4
 820d584:	12000017 	ldw	r8,0(r2)
 820d588:	29400104 	addi	r5,r5,4
 820d58c:	10800104 	addi	r2,r2,4
 820d590:	2a3fff15 	stw	r8,-4(r5)
 820d594:	10fffb36 	bltu	r2,r3,820d584 <__copybits+0x34>
 820d598:	1985c83a 	sub	r2,r3,r6
 820d59c:	10bffac4 	addi	r2,r2,-21
 820d5a0:	1004d0ba 	srli	r2,r2,2
 820d5a4:	10800044 	addi	r2,r2,1
 820d5a8:	1085883a 	add	r2,r2,r2
 820d5ac:	1085883a 	add	r2,r2,r2
 820d5b0:	2089883a 	add	r4,r4,r2
 820d5b4:	21c0032e 	bgeu	r4,r7,820d5c4 <__copybits+0x74>
 820d5b8:	20000015 	stw	zero,0(r4)
 820d5bc:	21000104 	addi	r4,r4,4
 820d5c0:	21fffd36 	bltu	r4,r7,820d5b8 <__copybits+0x68>
 820d5c4:	f800283a 	ret

0820d5c8 <__any_on>:
 820d5c8:	20c00417 	ldw	r3,16(r4)
 820d5cc:	2805d17a 	srai	r2,r5,5
 820d5d0:	21000504 	addi	r4,r4,20
 820d5d4:	18800d0e 	bge	r3,r2,820d60c <__any_on+0x44>
 820d5d8:	18c7883a 	add	r3,r3,r3
 820d5dc:	18c7883a 	add	r3,r3,r3
 820d5e0:	20c7883a 	add	r3,r4,r3
 820d5e4:	20c0192e 	bgeu	r4,r3,820d64c <__any_on+0x84>
 820d5e8:	18bfff17 	ldw	r2,-4(r3)
 820d5ec:	18ffff04 	addi	r3,r3,-4
 820d5f0:	1000041e 	bne	r2,zero,820d604 <__any_on+0x3c>
 820d5f4:	20c0142e 	bgeu	r4,r3,820d648 <__any_on+0x80>
 820d5f8:	18ffff04 	addi	r3,r3,-4
 820d5fc:	19400017 	ldw	r5,0(r3)
 820d600:	283ffc26 	beq	r5,zero,820d5f4 <__any_on+0x2c>
 820d604:	00800044 	movi	r2,1
 820d608:	f800283a 	ret
 820d60c:	10c00a0e 	bge	r2,r3,820d638 <__any_on+0x70>
 820d610:	1085883a 	add	r2,r2,r2
 820d614:	1085883a 	add	r2,r2,r2
 820d618:	294007cc 	andi	r5,r5,31
 820d61c:	2087883a 	add	r3,r4,r2
 820d620:	283ff026 	beq	r5,zero,820d5e4 <__any_on+0x1c>
 820d624:	19800017 	ldw	r6,0(r3)
 820d628:	3144d83a 	srl	r2,r6,r5
 820d62c:	114a983a 	sll	r5,r2,r5
 820d630:	317ff41e 	bne	r6,r5,820d604 <__any_on+0x3c>
 820d634:	003feb06 	br	820d5e4 <__any_on+0x1c>
 820d638:	1085883a 	add	r2,r2,r2
 820d63c:	1085883a 	add	r2,r2,r2
 820d640:	2087883a 	add	r3,r4,r2
 820d644:	003fe706 	br	820d5e4 <__any_on+0x1c>
 820d648:	f800283a 	ret
 820d64c:	0005883a 	mov	r2,zero
 820d650:	f800283a 	ret

0820d654 <_realloc_r>:
 820d654:	defff604 	addi	sp,sp,-40
 820d658:	dc800215 	stw	r18,8(sp)
 820d65c:	dfc00915 	stw	ra,36(sp)
 820d660:	df000815 	stw	fp,32(sp)
 820d664:	ddc00715 	stw	r23,28(sp)
 820d668:	dd800615 	stw	r22,24(sp)
 820d66c:	dd400515 	stw	r21,20(sp)
 820d670:	dd000415 	stw	r20,16(sp)
 820d674:	dcc00315 	stw	r19,12(sp)
 820d678:	dc400115 	stw	r17,4(sp)
 820d67c:	dc000015 	stw	r16,0(sp)
 820d680:	3025883a 	mov	r18,r6
 820d684:	2800b726 	beq	r5,zero,820d964 <_realloc_r+0x310>
 820d688:	282b883a 	mov	r21,r5
 820d68c:	2029883a 	mov	r20,r4
 820d690:	82149f80 	call	82149f8 <__malloc_lock>
 820d694:	a8bfff17 	ldw	r2,-4(r21)
 820d698:	043fff04 	movi	r16,-4
 820d69c:	90c002c4 	addi	r3,r18,11
 820d6a0:	01000584 	movi	r4,22
 820d6a4:	acfffe04 	addi	r19,r21,-8
 820d6a8:	1420703a 	and	r16,r2,r16
 820d6ac:	20c0332e 	bgeu	r4,r3,820d77c <_realloc_r+0x128>
 820d6b0:	047ffe04 	movi	r17,-8
 820d6b4:	1c62703a 	and	r17,r3,r17
 820d6b8:	8807883a 	mov	r3,r17
 820d6bc:	88005816 	blt	r17,zero,820d820 <_realloc_r+0x1cc>
 820d6c0:	8c805736 	bltu	r17,r18,820d820 <_realloc_r+0x1cc>
 820d6c4:	80c0300e 	bge	r16,r3,820d788 <_realloc_r+0x134>
 820d6c8:	07020974 	movhi	fp,2085
 820d6cc:	e7092704 	addi	fp,fp,9372
 820d6d0:	e1c00217 	ldw	r7,8(fp)
 820d6d4:	9c09883a 	add	r4,r19,r16
 820d6d8:	22000117 	ldw	r8,4(r4)
 820d6dc:	21c06326 	beq	r4,r7,820d86c <_realloc_r+0x218>
 820d6e0:	017fff84 	movi	r5,-2
 820d6e4:	414a703a 	and	r5,r8,r5
 820d6e8:	214b883a 	add	r5,r4,r5
 820d6ec:	29800117 	ldw	r6,4(r5)
 820d6f0:	3180004c 	andi	r6,r6,1
 820d6f4:	30003f26 	beq	r6,zero,820d7f4 <_realloc_r+0x1a0>
 820d6f8:	1080004c 	andi	r2,r2,1
 820d6fc:	10008326 	beq	r2,zero,820d90c <_realloc_r+0x2b8>
 820d700:	900b883a 	mov	r5,r18
 820d704:	a009883a 	mov	r4,r20
 820d708:	820bcec0 	call	820bcec <_malloc_r>
 820d70c:	1025883a 	mov	r18,r2
 820d710:	10011e26 	beq	r2,zero,820db8c <_realloc_r+0x538>
 820d714:	a93fff17 	ldw	r4,-4(r21)
 820d718:	10fffe04 	addi	r3,r2,-8
 820d71c:	00bfff84 	movi	r2,-2
 820d720:	2084703a 	and	r2,r4,r2
 820d724:	9885883a 	add	r2,r19,r2
 820d728:	1880ee26 	beq	r3,r2,820dae4 <_realloc_r+0x490>
 820d72c:	81bfff04 	addi	r6,r16,-4
 820d730:	00800904 	movi	r2,36
 820d734:	1180b836 	bltu	r2,r6,820da18 <_realloc_r+0x3c4>
 820d738:	00c004c4 	movi	r3,19
 820d73c:	19809636 	bltu	r3,r6,820d998 <_realloc_r+0x344>
 820d740:	9005883a 	mov	r2,r18
 820d744:	a807883a 	mov	r3,r21
 820d748:	19000017 	ldw	r4,0(r3)
 820d74c:	11000015 	stw	r4,0(r2)
 820d750:	19000117 	ldw	r4,4(r3)
 820d754:	11000115 	stw	r4,4(r2)
 820d758:	18c00217 	ldw	r3,8(r3)
 820d75c:	10c00215 	stw	r3,8(r2)
 820d760:	a80b883a 	mov	r5,r21
 820d764:	a009883a 	mov	r4,r20
 820d768:	820b1000 	call	820b100 <_free_r>
 820d76c:	a009883a 	mov	r4,r20
 820d770:	8214b180 	call	8214b18 <__malloc_unlock>
 820d774:	9005883a 	mov	r2,r18
 820d778:	00001206 	br	820d7c4 <_realloc_r+0x170>
 820d77c:	00c00404 	movi	r3,16
 820d780:	1823883a 	mov	r17,r3
 820d784:	003fce06 	br	820d6c0 <_realloc_r+0x6c>
 820d788:	a825883a 	mov	r18,r21
 820d78c:	8445c83a 	sub	r2,r16,r17
 820d790:	00c003c4 	movi	r3,15
 820d794:	18802636 	bltu	r3,r2,820d830 <_realloc_r+0x1dc>
 820d798:	99800117 	ldw	r6,4(r19)
 820d79c:	9c07883a 	add	r3,r19,r16
 820d7a0:	3180004c 	andi	r6,r6,1
 820d7a4:	3420b03a 	or	r16,r6,r16
 820d7a8:	9c000115 	stw	r16,4(r19)
 820d7ac:	18800117 	ldw	r2,4(r3)
 820d7b0:	10800054 	ori	r2,r2,1
 820d7b4:	18800115 	stw	r2,4(r3)
 820d7b8:	a009883a 	mov	r4,r20
 820d7bc:	8214b180 	call	8214b18 <__malloc_unlock>
 820d7c0:	9005883a 	mov	r2,r18
 820d7c4:	dfc00917 	ldw	ra,36(sp)
 820d7c8:	df000817 	ldw	fp,32(sp)
 820d7cc:	ddc00717 	ldw	r23,28(sp)
 820d7d0:	dd800617 	ldw	r22,24(sp)
 820d7d4:	dd400517 	ldw	r21,20(sp)
 820d7d8:	dd000417 	ldw	r20,16(sp)
 820d7dc:	dcc00317 	ldw	r19,12(sp)
 820d7e0:	dc800217 	ldw	r18,8(sp)
 820d7e4:	dc400117 	ldw	r17,4(sp)
 820d7e8:	dc000017 	ldw	r16,0(sp)
 820d7ec:	dec00a04 	addi	sp,sp,40
 820d7f0:	f800283a 	ret
 820d7f4:	017fff04 	movi	r5,-4
 820d7f8:	414a703a 	and	r5,r8,r5
 820d7fc:	814d883a 	add	r6,r16,r5
 820d800:	30c01f16 	blt	r6,r3,820d880 <_realloc_r+0x22c>
 820d804:	20800317 	ldw	r2,12(r4)
 820d808:	20c00217 	ldw	r3,8(r4)
 820d80c:	a825883a 	mov	r18,r21
 820d810:	3021883a 	mov	r16,r6
 820d814:	18800315 	stw	r2,12(r3)
 820d818:	10c00215 	stw	r3,8(r2)
 820d81c:	003fdb06 	br	820d78c <_realloc_r+0x138>
 820d820:	00800304 	movi	r2,12
 820d824:	a0800015 	stw	r2,0(r20)
 820d828:	0005883a 	mov	r2,zero
 820d82c:	003fe506 	br	820d7c4 <_realloc_r+0x170>
 820d830:	98c00117 	ldw	r3,4(r19)
 820d834:	9c4b883a 	add	r5,r19,r17
 820d838:	11000054 	ori	r4,r2,1
 820d83c:	18c0004c 	andi	r3,r3,1
 820d840:	1c62b03a 	or	r17,r3,r17
 820d844:	9c400115 	stw	r17,4(r19)
 820d848:	29000115 	stw	r4,4(r5)
 820d84c:	2885883a 	add	r2,r5,r2
 820d850:	10c00117 	ldw	r3,4(r2)
 820d854:	29400204 	addi	r5,r5,8
 820d858:	a009883a 	mov	r4,r20
 820d85c:	18c00054 	ori	r3,r3,1
 820d860:	10c00115 	stw	r3,4(r2)
 820d864:	820b1000 	call	820b100 <_free_r>
 820d868:	003fd306 	br	820d7b8 <_realloc_r+0x164>
 820d86c:	017fff04 	movi	r5,-4
 820d870:	414a703a 	and	r5,r8,r5
 820d874:	89800404 	addi	r6,r17,16
 820d878:	8151883a 	add	r8,r16,r5
 820d87c:	4180590e 	bge	r8,r6,820d9e4 <_realloc_r+0x390>
 820d880:	1080004c 	andi	r2,r2,1
 820d884:	103f9e1e 	bne	r2,zero,820d700 <_realloc_r+0xac>
 820d888:	adbffe17 	ldw	r22,-8(r21)
 820d88c:	00bfff04 	movi	r2,-4
 820d890:	9dadc83a 	sub	r22,r19,r22
 820d894:	b1800117 	ldw	r6,4(r22)
 820d898:	3084703a 	and	r2,r6,r2
 820d89c:	20002026 	beq	r4,zero,820d920 <_realloc_r+0x2cc>
 820d8a0:	80af883a 	add	r23,r16,r2
 820d8a4:	b96f883a 	add	r23,r23,r5
 820d8a8:	21c05f26 	beq	r4,r7,820da28 <_realloc_r+0x3d4>
 820d8ac:	b8c01c16 	blt	r23,r3,820d920 <_realloc_r+0x2cc>
 820d8b0:	20800317 	ldw	r2,12(r4)
 820d8b4:	20c00217 	ldw	r3,8(r4)
 820d8b8:	81bfff04 	addi	r6,r16,-4
 820d8bc:	01000904 	movi	r4,36
 820d8c0:	18800315 	stw	r2,12(r3)
 820d8c4:	10c00215 	stw	r3,8(r2)
 820d8c8:	b0c00217 	ldw	r3,8(r22)
 820d8cc:	b0800317 	ldw	r2,12(r22)
 820d8d0:	b4800204 	addi	r18,r22,8
 820d8d4:	18800315 	stw	r2,12(r3)
 820d8d8:	10c00215 	stw	r3,8(r2)
 820d8dc:	21801b36 	bltu	r4,r6,820d94c <_realloc_r+0x2f8>
 820d8e0:	008004c4 	movi	r2,19
 820d8e4:	1180352e 	bgeu	r2,r6,820d9bc <_realloc_r+0x368>
 820d8e8:	a8800017 	ldw	r2,0(r21)
 820d8ec:	b0800215 	stw	r2,8(r22)
 820d8f0:	a8800117 	ldw	r2,4(r21)
 820d8f4:	b0800315 	stw	r2,12(r22)
 820d8f8:	008006c4 	movi	r2,27
 820d8fc:	11807f36 	bltu	r2,r6,820dafc <_realloc_r+0x4a8>
 820d900:	b0800404 	addi	r2,r22,16
 820d904:	ad400204 	addi	r21,r21,8
 820d908:	00002d06 	br	820d9c0 <_realloc_r+0x36c>
 820d90c:	adbffe17 	ldw	r22,-8(r21)
 820d910:	00bfff04 	movi	r2,-4
 820d914:	9dadc83a 	sub	r22,r19,r22
 820d918:	b1000117 	ldw	r4,4(r22)
 820d91c:	2084703a 	and	r2,r4,r2
 820d920:	b03f7726 	beq	r22,zero,820d700 <_realloc_r+0xac>
 820d924:	80af883a 	add	r23,r16,r2
 820d928:	b8ff7516 	blt	r23,r3,820d700 <_realloc_r+0xac>
 820d92c:	b0800317 	ldw	r2,12(r22)
 820d930:	b0c00217 	ldw	r3,8(r22)
 820d934:	81bfff04 	addi	r6,r16,-4
 820d938:	01000904 	movi	r4,36
 820d93c:	18800315 	stw	r2,12(r3)
 820d940:	10c00215 	stw	r3,8(r2)
 820d944:	b4800204 	addi	r18,r22,8
 820d948:	21bfe52e 	bgeu	r4,r6,820d8e0 <_realloc_r+0x28c>
 820d94c:	a80b883a 	mov	r5,r21
 820d950:	9009883a 	mov	r4,r18
 820d954:	82030580 	call	8203058 <memmove>
 820d958:	b821883a 	mov	r16,r23
 820d95c:	b027883a 	mov	r19,r22
 820d960:	003f8a06 	br	820d78c <_realloc_r+0x138>
 820d964:	300b883a 	mov	r5,r6
 820d968:	dfc00917 	ldw	ra,36(sp)
 820d96c:	df000817 	ldw	fp,32(sp)
 820d970:	ddc00717 	ldw	r23,28(sp)
 820d974:	dd800617 	ldw	r22,24(sp)
 820d978:	dd400517 	ldw	r21,20(sp)
 820d97c:	dd000417 	ldw	r20,16(sp)
 820d980:	dcc00317 	ldw	r19,12(sp)
 820d984:	dc800217 	ldw	r18,8(sp)
 820d988:	dc400117 	ldw	r17,4(sp)
 820d98c:	dc000017 	ldw	r16,0(sp)
 820d990:	dec00a04 	addi	sp,sp,40
 820d994:	820bcec1 	jmpi	820bcec <_malloc_r>
 820d998:	a8c00017 	ldw	r3,0(r21)
 820d99c:	90c00015 	stw	r3,0(r18)
 820d9a0:	a8c00117 	ldw	r3,4(r21)
 820d9a4:	90c00115 	stw	r3,4(r18)
 820d9a8:	00c006c4 	movi	r3,27
 820d9ac:	19804536 	bltu	r3,r6,820dac4 <_realloc_r+0x470>
 820d9b0:	90800204 	addi	r2,r18,8
 820d9b4:	a8c00204 	addi	r3,r21,8
 820d9b8:	003f6306 	br	820d748 <_realloc_r+0xf4>
 820d9bc:	9005883a 	mov	r2,r18
 820d9c0:	a8c00017 	ldw	r3,0(r21)
 820d9c4:	b821883a 	mov	r16,r23
 820d9c8:	b027883a 	mov	r19,r22
 820d9cc:	10c00015 	stw	r3,0(r2)
 820d9d0:	a8c00117 	ldw	r3,4(r21)
 820d9d4:	10c00115 	stw	r3,4(r2)
 820d9d8:	a8c00217 	ldw	r3,8(r21)
 820d9dc:	10c00215 	stw	r3,8(r2)
 820d9e0:	003f6a06 	br	820d78c <_realloc_r+0x138>
 820d9e4:	9c67883a 	add	r19,r19,r17
 820d9e8:	4445c83a 	sub	r2,r8,r17
 820d9ec:	e4c00215 	stw	r19,8(fp)
 820d9f0:	10800054 	ori	r2,r2,1
 820d9f4:	98800115 	stw	r2,4(r19)
 820d9f8:	a8bfff17 	ldw	r2,-4(r21)
 820d9fc:	a009883a 	mov	r4,r20
 820da00:	1080004c 	andi	r2,r2,1
 820da04:	1462b03a 	or	r17,r2,r17
 820da08:	ac7fff15 	stw	r17,-4(r21)
 820da0c:	8214b180 	call	8214b18 <__malloc_unlock>
 820da10:	a805883a 	mov	r2,r21
 820da14:	003f6b06 	br	820d7c4 <_realloc_r+0x170>
 820da18:	a80b883a 	mov	r5,r21
 820da1c:	9009883a 	mov	r4,r18
 820da20:	82030580 	call	8203058 <memmove>
 820da24:	003f4e06 	br	820d760 <_realloc_r+0x10c>
 820da28:	89000404 	addi	r4,r17,16
 820da2c:	b93fbc16 	blt	r23,r4,820d920 <_realloc_r+0x2cc>
 820da30:	b0800317 	ldw	r2,12(r22)
 820da34:	b0c00217 	ldw	r3,8(r22)
 820da38:	81bfff04 	addi	r6,r16,-4
 820da3c:	01000904 	movi	r4,36
 820da40:	18800315 	stw	r2,12(r3)
 820da44:	10c00215 	stw	r3,8(r2)
 820da48:	b4800204 	addi	r18,r22,8
 820da4c:	21804336 	bltu	r4,r6,820db5c <_realloc_r+0x508>
 820da50:	008004c4 	movi	r2,19
 820da54:	11803f2e 	bgeu	r2,r6,820db54 <_realloc_r+0x500>
 820da58:	a8800017 	ldw	r2,0(r21)
 820da5c:	b0800215 	stw	r2,8(r22)
 820da60:	a8800117 	ldw	r2,4(r21)
 820da64:	b0800315 	stw	r2,12(r22)
 820da68:	008006c4 	movi	r2,27
 820da6c:	11803f36 	bltu	r2,r6,820db6c <_realloc_r+0x518>
 820da70:	b0800404 	addi	r2,r22,16
 820da74:	ad400204 	addi	r21,r21,8
 820da78:	a8c00017 	ldw	r3,0(r21)
 820da7c:	10c00015 	stw	r3,0(r2)
 820da80:	a8c00117 	ldw	r3,4(r21)
 820da84:	10c00115 	stw	r3,4(r2)
 820da88:	a8c00217 	ldw	r3,8(r21)
 820da8c:	10c00215 	stw	r3,8(r2)
 820da90:	b447883a 	add	r3,r22,r17
 820da94:	bc45c83a 	sub	r2,r23,r17
 820da98:	e0c00215 	stw	r3,8(fp)
 820da9c:	10800054 	ori	r2,r2,1
 820daa0:	18800115 	stw	r2,4(r3)
 820daa4:	b0800117 	ldw	r2,4(r22)
 820daa8:	a009883a 	mov	r4,r20
 820daac:	1080004c 	andi	r2,r2,1
 820dab0:	1462b03a 	or	r17,r2,r17
 820dab4:	b4400115 	stw	r17,4(r22)
 820dab8:	8214b180 	call	8214b18 <__malloc_unlock>
 820dabc:	9005883a 	mov	r2,r18
 820dac0:	003f4006 	br	820d7c4 <_realloc_r+0x170>
 820dac4:	a8c00217 	ldw	r3,8(r21)
 820dac8:	90c00215 	stw	r3,8(r18)
 820dacc:	a8c00317 	ldw	r3,12(r21)
 820dad0:	90c00315 	stw	r3,12(r18)
 820dad4:	30801126 	beq	r6,r2,820db1c <_realloc_r+0x4c8>
 820dad8:	90800404 	addi	r2,r18,16
 820dadc:	a8c00404 	addi	r3,r21,16
 820dae0:	003f1906 	br	820d748 <_realloc_r+0xf4>
 820dae4:	90ffff17 	ldw	r3,-4(r18)
 820dae8:	00bfff04 	movi	r2,-4
 820daec:	a825883a 	mov	r18,r21
 820daf0:	1884703a 	and	r2,r3,r2
 820daf4:	80a1883a 	add	r16,r16,r2
 820daf8:	003f2406 	br	820d78c <_realloc_r+0x138>
 820dafc:	a8800217 	ldw	r2,8(r21)
 820db00:	b0800415 	stw	r2,16(r22)
 820db04:	a8800317 	ldw	r2,12(r21)
 820db08:	b0800515 	stw	r2,20(r22)
 820db0c:	31000a26 	beq	r6,r4,820db38 <_realloc_r+0x4e4>
 820db10:	b0800604 	addi	r2,r22,24
 820db14:	ad400404 	addi	r21,r21,16
 820db18:	003fa906 	br	820d9c0 <_realloc_r+0x36c>
 820db1c:	a9000417 	ldw	r4,16(r21)
 820db20:	90800604 	addi	r2,r18,24
 820db24:	a8c00604 	addi	r3,r21,24
 820db28:	91000415 	stw	r4,16(r18)
 820db2c:	a9000517 	ldw	r4,20(r21)
 820db30:	91000515 	stw	r4,20(r18)
 820db34:	003f0406 	br	820d748 <_realloc_r+0xf4>
 820db38:	a8c00417 	ldw	r3,16(r21)
 820db3c:	ad400604 	addi	r21,r21,24
 820db40:	b0800804 	addi	r2,r22,32
 820db44:	b0c00615 	stw	r3,24(r22)
 820db48:	a8ffff17 	ldw	r3,-4(r21)
 820db4c:	b0c00715 	stw	r3,28(r22)
 820db50:	003f9b06 	br	820d9c0 <_realloc_r+0x36c>
 820db54:	9005883a 	mov	r2,r18
 820db58:	003fc706 	br	820da78 <_realloc_r+0x424>
 820db5c:	a80b883a 	mov	r5,r21
 820db60:	9009883a 	mov	r4,r18
 820db64:	82030580 	call	8203058 <memmove>
 820db68:	003fc906 	br	820da90 <_realloc_r+0x43c>
 820db6c:	a8800217 	ldw	r2,8(r21)
 820db70:	b0800415 	stw	r2,16(r22)
 820db74:	a8800317 	ldw	r2,12(r21)
 820db78:	b0800515 	stw	r2,20(r22)
 820db7c:	31000726 	beq	r6,r4,820db9c <_realloc_r+0x548>
 820db80:	b0800604 	addi	r2,r22,24
 820db84:	ad400404 	addi	r21,r21,16
 820db88:	003fbb06 	br	820da78 <_realloc_r+0x424>
 820db8c:	a009883a 	mov	r4,r20
 820db90:	8214b180 	call	8214b18 <__malloc_unlock>
 820db94:	0005883a 	mov	r2,zero
 820db98:	003f0a06 	br	820d7c4 <_realloc_r+0x170>
 820db9c:	a8c00417 	ldw	r3,16(r21)
 820dba0:	ad400604 	addi	r21,r21,24
 820dba4:	b0800804 	addi	r2,r22,32
 820dba8:	b0c00615 	stw	r3,24(r22)
 820dbac:	a8ffff17 	ldw	r3,-4(r21)
 820dbb0:	b0c00715 	stw	r3,28(r22)
 820dbb4:	003fb006 	br	820da78 <_realloc_r+0x424>

0820dbb8 <lflush>:
 820dbb8:	2080030b 	ldhu	r2,12(r4)
 820dbbc:	00c00244 	movi	r3,9
 820dbc0:	1080024c 	andi	r2,r2,9
 820dbc4:	10c00226 	beq	r2,r3,820dbd0 <lflush+0x18>
 820dbc8:	0005883a 	mov	r2,zero
 820dbcc:	f800283a 	ret
 820dbd0:	820aab81 	jmpi	820aab8 <fflush>

0820dbd4 <__srefill_r>:
 820dbd4:	defffc04 	addi	sp,sp,-16
 820dbd8:	dc400115 	stw	r17,4(sp)
 820dbdc:	dc000015 	stw	r16,0(sp)
 820dbe0:	dfc00315 	stw	ra,12(sp)
 820dbe4:	dc800215 	stw	r18,8(sp)
 820dbe8:	2023883a 	mov	r17,r4
 820dbec:	2821883a 	mov	r16,r5
 820dbf0:	20000226 	beq	r4,zero,820dbfc <__srefill_r+0x28>
 820dbf4:	20800e17 	ldw	r2,56(r4)
 820dbf8:	10003c26 	beq	r2,zero,820dcec <__srefill_r+0x118>
 820dbfc:	80c0030b 	ldhu	r3,12(r16)
 820dc00:	1908000c 	andi	r4,r3,8192
 820dc04:	1805883a 	mov	r2,r3
 820dc08:	2000071e 	bne	r4,zero,820dc28 <__srefill_r+0x54>
 820dc0c:	81001917 	ldw	r4,100(r16)
 820dc10:	18880014 	ori	r2,r3,8192
 820dc14:	00f7ffc4 	movi	r3,-8193
 820dc18:	20c8703a 	and	r4,r4,r3
 820dc1c:	8080030d 	sth	r2,12(r16)
 820dc20:	1007883a 	mov	r3,r2
 820dc24:	81001915 	stw	r4,100(r16)
 820dc28:	80000115 	stw	zero,4(r16)
 820dc2c:	1100080c 	andi	r4,r2,32
 820dc30:	2000571e 	bne	r4,zero,820dd90 <__srefill_r+0x1bc>
 820dc34:	1100010c 	andi	r4,r2,4
 820dc38:	20001f26 	beq	r4,zero,820dcb8 <__srefill_r+0xe4>
 820dc3c:	81400c17 	ldw	r5,48(r16)
 820dc40:	28000826 	beq	r5,zero,820dc64 <__srefill_r+0x90>
 820dc44:	80801004 	addi	r2,r16,64
 820dc48:	28800226 	beq	r5,r2,820dc54 <__srefill_r+0x80>
 820dc4c:	8809883a 	mov	r4,r17
 820dc50:	820b1000 	call	820b100 <_free_r>
 820dc54:	80800f17 	ldw	r2,60(r16)
 820dc58:	80000c15 	stw	zero,48(r16)
 820dc5c:	80800115 	stw	r2,4(r16)
 820dc60:	1000391e 	bne	r2,zero,820dd48 <__srefill_r+0x174>
 820dc64:	80800417 	ldw	r2,16(r16)
 820dc68:	10004b26 	beq	r2,zero,820dd98 <__srefill_r+0x1c4>
 820dc6c:	8480030b 	ldhu	r18,12(r16)
 820dc70:	908000cc 	andi	r2,r18,3
 820dc74:	10001f1e 	bne	r2,zero,820dcf4 <__srefill_r+0x120>
 820dc78:	81800417 	ldw	r6,16(r16)
 820dc7c:	80800817 	ldw	r2,32(r16)
 820dc80:	81c00517 	ldw	r7,20(r16)
 820dc84:	81400717 	ldw	r5,28(r16)
 820dc88:	81800015 	stw	r6,0(r16)
 820dc8c:	8809883a 	mov	r4,r17
 820dc90:	103ee83a 	callr	r2
 820dc94:	80800115 	stw	r2,4(r16)
 820dc98:	00800e0e 	bge	zero,r2,820dcd4 <__srefill_r+0x100>
 820dc9c:	0005883a 	mov	r2,zero
 820dca0:	dfc00317 	ldw	ra,12(sp)
 820dca4:	dc800217 	ldw	r18,8(sp)
 820dca8:	dc400117 	ldw	r17,4(sp)
 820dcac:	dc000017 	ldw	r16,0(sp)
 820dcb0:	dec00404 	addi	sp,sp,16
 820dcb4:	f800283a 	ret
 820dcb8:	1100040c 	andi	r4,r2,16
 820dcbc:	20003026 	beq	r4,zero,820dd80 <__srefill_r+0x1ac>
 820dcc0:	1080020c 	andi	r2,r2,8
 820dcc4:	1000241e 	bne	r2,zero,820dd58 <__srefill_r+0x184>
 820dcc8:	18c00114 	ori	r3,r3,4
 820dccc:	80c0030d 	sth	r3,12(r16)
 820dcd0:	003fe406 	br	820dc64 <__srefill_r+0x90>
 820dcd4:	80c0030b 	ldhu	r3,12(r16)
 820dcd8:	1000161e 	bne	r2,zero,820dd34 <__srefill_r+0x160>
 820dcdc:	18c00814 	ori	r3,r3,32
 820dce0:	00bfffc4 	movi	r2,-1
 820dce4:	80c0030d 	sth	r3,12(r16)
 820dce8:	003fed06 	br	820dca0 <__srefill_r+0xcc>
 820dcec:	820ae380 	call	820ae38 <__sinit>
 820dcf0:	003fc206 	br	820dbfc <__srefill_r+0x28>
 820dcf4:	00820974 	movhi	r2,2085
 820dcf8:	108f9804 	addi	r2,r2,15968
 820dcfc:	11000017 	ldw	r4,0(r2)
 820dd00:	01420874 	movhi	r5,2081
 820dd04:	00800044 	movi	r2,1
 820dd08:	2976ee04 	addi	r5,r5,-9288
 820dd0c:	8080030d 	sth	r2,12(r16)
 820dd10:	820b8cc0 	call	820b8cc <_fwalk>
 820dd14:	00800244 	movi	r2,9
 820dd18:	8480030d 	sth	r18,12(r16)
 820dd1c:	9480024c 	andi	r18,r18,9
 820dd20:	90bfd51e 	bne	r18,r2,820dc78 <__srefill_r+0xa4>
 820dd24:	800b883a 	mov	r5,r16
 820dd28:	8809883a 	mov	r4,r17
 820dd2c:	820a8400 	call	820a840 <__sflush_r>
 820dd30:	003fd106 	br	820dc78 <__srefill_r+0xa4>
 820dd34:	18c01014 	ori	r3,r3,64
 820dd38:	80000115 	stw	zero,4(r16)
 820dd3c:	00bfffc4 	movi	r2,-1
 820dd40:	80c0030d 	sth	r3,12(r16)
 820dd44:	003fd606 	br	820dca0 <__srefill_r+0xcc>
 820dd48:	80c00e17 	ldw	r3,56(r16)
 820dd4c:	0005883a 	mov	r2,zero
 820dd50:	80c00015 	stw	r3,0(r16)
 820dd54:	003fd206 	br	820dca0 <__srefill_r+0xcc>
 820dd58:	800b883a 	mov	r5,r16
 820dd5c:	8809883a 	mov	r4,r17
 820dd60:	820aa5c0 	call	820aa5c <_fflush_r>
 820dd64:	10000a1e 	bne	r2,zero,820dd90 <__srefill_r+0x1bc>
 820dd68:	8080030b 	ldhu	r2,12(r16)
 820dd6c:	00fffdc4 	movi	r3,-9
 820dd70:	80000215 	stw	zero,8(r16)
 820dd74:	1886703a 	and	r3,r3,r2
 820dd78:	80000615 	stw	zero,24(r16)
 820dd7c:	003fd206 	br	820dcc8 <__srefill_r+0xf4>
 820dd80:	00800244 	movi	r2,9
 820dd84:	88800015 	stw	r2,0(r17)
 820dd88:	18c01014 	ori	r3,r3,64
 820dd8c:	80c0030d 	sth	r3,12(r16)
 820dd90:	00bfffc4 	movi	r2,-1
 820dd94:	003fc206 	br	820dca0 <__srefill_r+0xcc>
 820dd98:	800b883a 	mov	r5,r16
 820dd9c:	8809883a 	mov	r4,r17
 820dda0:	820bb300 	call	820bb30 <__smakebuf_r>
 820dda4:	003fb106 	br	820dc6c <__srefill_r+0x98>

0820dda8 <__fpclassifyd>:
 820dda8:	00a00034 	movhi	r2,32768
 820ddac:	10bfffc4 	addi	r2,r2,-1
 820ddb0:	2884703a 	and	r2,r5,r2
 820ddb4:	10000726 	beq	r2,zero,820ddd4 <__fpclassifyd+0x2c>
 820ddb8:	00fffc34 	movhi	r3,65520
 820ddbc:	019ff834 	movhi	r6,32736
 820ddc0:	28c7883a 	add	r3,r5,r3
 820ddc4:	31bfffc4 	addi	r6,r6,-1
 820ddc8:	30c00536 	bltu	r6,r3,820dde0 <__fpclassifyd+0x38>
 820ddcc:	00800104 	movi	r2,4
 820ddd0:	f800283a 	ret
 820ddd4:	2000021e 	bne	r4,zero,820dde0 <__fpclassifyd+0x38>
 820ddd8:	00800084 	movi	r2,2
 820dddc:	f800283a 	ret
 820dde0:	00dffc34 	movhi	r3,32752
 820dde4:	019ff834 	movhi	r6,32736
 820dde8:	28cb883a 	add	r5,r5,r3
 820ddec:	31bfffc4 	addi	r6,r6,-1
 820ddf0:	317ff62e 	bgeu	r6,r5,820ddcc <__fpclassifyd+0x24>
 820ddf4:	01400434 	movhi	r5,16
 820ddf8:	297fffc4 	addi	r5,r5,-1
 820ddfc:	28800236 	bltu	r5,r2,820de08 <__fpclassifyd+0x60>
 820de00:	008000c4 	movi	r2,3
 820de04:	f800283a 	ret
 820de08:	10c00226 	beq	r2,r3,820de14 <__fpclassifyd+0x6c>
 820de0c:	0005883a 	mov	r2,zero
 820de10:	f800283a 	ret
 820de14:	2005003a 	cmpeq	r2,r4,zero
 820de18:	f800283a 	ret

0820de1c <_sbrk_r>:
 820de1c:	defffd04 	addi	sp,sp,-12
 820de20:	dc000015 	stw	r16,0(sp)
 820de24:	04020974 	movhi	r16,2085
 820de28:	dc400115 	stw	r17,4(sp)
 820de2c:	840ffa04 	addi	r16,r16,16360
 820de30:	2023883a 	mov	r17,r4
 820de34:	2809883a 	mov	r4,r5
 820de38:	dfc00215 	stw	ra,8(sp)
 820de3c:	80000015 	stw	zero,0(r16)
 820de40:	82148240 	call	8214824 <sbrk>
 820de44:	00ffffc4 	movi	r3,-1
 820de48:	10c00526 	beq	r2,r3,820de60 <_sbrk_r+0x44>
 820de4c:	dfc00217 	ldw	ra,8(sp)
 820de50:	dc400117 	ldw	r17,4(sp)
 820de54:	dc000017 	ldw	r16,0(sp)
 820de58:	dec00304 	addi	sp,sp,12
 820de5c:	f800283a 	ret
 820de60:	80c00017 	ldw	r3,0(r16)
 820de64:	183ff926 	beq	r3,zero,820de4c <_sbrk_r+0x30>
 820de68:	88c00015 	stw	r3,0(r17)
 820de6c:	003ff706 	br	820de4c <_sbrk_r+0x30>

0820de70 <__sread>:
 820de70:	defffe04 	addi	sp,sp,-8
 820de74:	dc000015 	stw	r16,0(sp)
 820de78:	2821883a 	mov	r16,r5
 820de7c:	2940038f 	ldh	r5,14(r5)
 820de80:	dfc00115 	stw	ra,4(sp)
 820de84:	82110700 	call	8211070 <_read_r>
 820de88:	10000716 	blt	r2,zero,820dea8 <__sread+0x38>
 820de8c:	80c01417 	ldw	r3,80(r16)
 820de90:	1887883a 	add	r3,r3,r2
 820de94:	80c01415 	stw	r3,80(r16)
 820de98:	dfc00117 	ldw	ra,4(sp)
 820de9c:	dc000017 	ldw	r16,0(sp)
 820dea0:	dec00204 	addi	sp,sp,8
 820dea4:	f800283a 	ret
 820dea8:	80c0030b 	ldhu	r3,12(r16)
 820deac:	18fbffcc 	andi	r3,r3,61439
 820deb0:	80c0030d 	sth	r3,12(r16)
 820deb4:	dfc00117 	ldw	ra,4(sp)
 820deb8:	dc000017 	ldw	r16,0(sp)
 820debc:	dec00204 	addi	sp,sp,8
 820dec0:	f800283a 	ret

0820dec4 <__seofread>:
 820dec4:	0005883a 	mov	r2,zero
 820dec8:	f800283a 	ret

0820decc <__swrite>:
 820decc:	2880030b 	ldhu	r2,12(r5)
 820ded0:	defffb04 	addi	sp,sp,-20
 820ded4:	dcc00315 	stw	r19,12(sp)
 820ded8:	dc800215 	stw	r18,8(sp)
 820dedc:	dc400115 	stw	r17,4(sp)
 820dee0:	dc000015 	stw	r16,0(sp)
 820dee4:	dfc00415 	stw	ra,16(sp)
 820dee8:	10c0400c 	andi	r3,r2,256
 820deec:	2821883a 	mov	r16,r5
 820def0:	2023883a 	mov	r17,r4
 820def4:	3025883a 	mov	r18,r6
 820def8:	3827883a 	mov	r19,r7
 820defc:	18000526 	beq	r3,zero,820df14 <__swrite+0x48>
 820df00:	2940038f 	ldh	r5,14(r5)
 820df04:	01c00084 	movi	r7,2
 820df08:	000d883a 	mov	r6,zero
 820df0c:	82110100 	call	8211010 <_lseek_r>
 820df10:	8080030b 	ldhu	r2,12(r16)
 820df14:	8140038f 	ldh	r5,14(r16)
 820df18:	10bbffcc 	andi	r2,r2,61439
 820df1c:	980f883a 	mov	r7,r19
 820df20:	900d883a 	mov	r6,r18
 820df24:	8809883a 	mov	r4,r17
 820df28:	8080030d 	sth	r2,12(r16)
 820df2c:	dfc00417 	ldw	ra,16(sp)
 820df30:	dcc00317 	ldw	r19,12(sp)
 820df34:	dc800217 	ldw	r18,8(sp)
 820df38:	dc400117 	ldw	r17,4(sp)
 820df3c:	dc000017 	ldw	r16,0(sp)
 820df40:	dec00504 	addi	sp,sp,20
 820df44:	8210adc1 	jmpi	8210adc <_write_r>

0820df48 <__sseek>:
 820df48:	defffe04 	addi	sp,sp,-8
 820df4c:	dc000015 	stw	r16,0(sp)
 820df50:	2821883a 	mov	r16,r5
 820df54:	2940038f 	ldh	r5,14(r5)
 820df58:	dfc00115 	stw	ra,4(sp)
 820df5c:	82110100 	call	8211010 <_lseek_r>
 820df60:	00ffffc4 	movi	r3,-1
 820df64:	10c00826 	beq	r2,r3,820df88 <__sseek+0x40>
 820df68:	80c0030b 	ldhu	r3,12(r16)
 820df6c:	80801415 	stw	r2,80(r16)
 820df70:	18c40014 	ori	r3,r3,4096
 820df74:	80c0030d 	sth	r3,12(r16)
 820df78:	dfc00117 	ldw	ra,4(sp)
 820df7c:	dc000017 	ldw	r16,0(sp)
 820df80:	dec00204 	addi	sp,sp,8
 820df84:	f800283a 	ret
 820df88:	80c0030b 	ldhu	r3,12(r16)
 820df8c:	18fbffcc 	andi	r3,r3,61439
 820df90:	80c0030d 	sth	r3,12(r16)
 820df94:	dfc00117 	ldw	ra,4(sp)
 820df98:	dc000017 	ldw	r16,0(sp)
 820df9c:	dec00204 	addi	sp,sp,8
 820dfa0:	f800283a 	ret

0820dfa4 <__sclose>:
 820dfa4:	2940038f 	ldh	r5,14(r5)
 820dfa8:	8210b3c1 	jmpi	8210b3c <_close_r>

0820dfac <strcmp>:
 820dfac:	2144b03a 	or	r2,r4,r5
 820dfb0:	108000cc 	andi	r2,r2,3
 820dfb4:	1000171e 	bne	r2,zero,820e014 <strcmp+0x68>
 820dfb8:	20800017 	ldw	r2,0(r4)
 820dfbc:	28c00017 	ldw	r3,0(r5)
 820dfc0:	10c0141e 	bne	r2,r3,820e014 <strcmp+0x68>
 820dfc4:	027fbff4 	movhi	r9,65279
 820dfc8:	4a7fbfc4 	addi	r9,r9,-257
 820dfcc:	0086303a 	nor	r3,zero,r2
 820dfd0:	02202074 	movhi	r8,32897
 820dfd4:	1245883a 	add	r2,r2,r9
 820dfd8:	42202004 	addi	r8,r8,-32640
 820dfdc:	10c4703a 	and	r2,r2,r3
 820dfe0:	1204703a 	and	r2,r2,r8
 820dfe4:	10000226 	beq	r2,zero,820dff0 <strcmp+0x44>
 820dfe8:	00002306 	br	820e078 <strcmp+0xcc>
 820dfec:	1000221e 	bne	r2,zero,820e078 <strcmp+0xcc>
 820dff0:	21000104 	addi	r4,r4,4
 820dff4:	20c00017 	ldw	r3,0(r4)
 820dff8:	29400104 	addi	r5,r5,4
 820dffc:	29800017 	ldw	r6,0(r5)
 820e000:	1a4f883a 	add	r7,r3,r9
 820e004:	00c4303a 	nor	r2,zero,r3
 820e008:	3884703a 	and	r2,r7,r2
 820e00c:	1204703a 	and	r2,r2,r8
 820e010:	19bff626 	beq	r3,r6,820dfec <strcmp+0x40>
 820e014:	20800003 	ldbu	r2,0(r4)
 820e018:	10c03fcc 	andi	r3,r2,255
 820e01c:	18c0201c 	xori	r3,r3,128
 820e020:	18ffe004 	addi	r3,r3,-128
 820e024:	18000c26 	beq	r3,zero,820e058 <strcmp+0xac>
 820e028:	29800007 	ldb	r6,0(r5)
 820e02c:	19800326 	beq	r3,r6,820e03c <strcmp+0x90>
 820e030:	00001306 	br	820e080 <strcmp+0xd4>
 820e034:	29800007 	ldb	r6,0(r5)
 820e038:	11800b1e 	bne	r2,r6,820e068 <strcmp+0xbc>
 820e03c:	21000044 	addi	r4,r4,1
 820e040:	20c00003 	ldbu	r3,0(r4)
 820e044:	29400044 	addi	r5,r5,1
 820e048:	18803fcc 	andi	r2,r3,255
 820e04c:	1080201c 	xori	r2,r2,128
 820e050:	10bfe004 	addi	r2,r2,-128
 820e054:	103ff71e 	bne	r2,zero,820e034 <strcmp+0x88>
 820e058:	0007883a 	mov	r3,zero
 820e05c:	28800003 	ldbu	r2,0(r5)
 820e060:	1885c83a 	sub	r2,r3,r2
 820e064:	f800283a 	ret
 820e068:	28800003 	ldbu	r2,0(r5)
 820e06c:	18c03fcc 	andi	r3,r3,255
 820e070:	1885c83a 	sub	r2,r3,r2
 820e074:	f800283a 	ret
 820e078:	0005883a 	mov	r2,zero
 820e07c:	f800283a 	ret
 820e080:	10c03fcc 	andi	r3,r2,255
 820e084:	003ff506 	br	820e05c <strcmp+0xb0>

0820e088 <__ssprint_r>:
 820e088:	30800217 	ldw	r2,8(r6)
 820e08c:	defff604 	addi	sp,sp,-40
 820e090:	dc800215 	stw	r18,8(sp)
 820e094:	dfc00915 	stw	ra,36(sp)
 820e098:	df000815 	stw	fp,32(sp)
 820e09c:	ddc00715 	stw	r23,28(sp)
 820e0a0:	dd800615 	stw	r22,24(sp)
 820e0a4:	dd400515 	stw	r21,20(sp)
 820e0a8:	dd000415 	stw	r20,16(sp)
 820e0ac:	dcc00315 	stw	r19,12(sp)
 820e0b0:	dc400115 	stw	r17,4(sp)
 820e0b4:	dc000015 	stw	r16,0(sp)
 820e0b8:	3025883a 	mov	r18,r6
 820e0bc:	10005826 	beq	r2,zero,820e220 <__ssprint_r+0x198>
 820e0c0:	2027883a 	mov	r19,r4
 820e0c4:	35c00017 	ldw	r23,0(r6)
 820e0c8:	29000017 	ldw	r4,0(r5)
 820e0cc:	28800217 	ldw	r2,8(r5)
 820e0d0:	2823883a 	mov	r17,r5
 820e0d4:	0039883a 	mov	fp,zero
 820e0d8:	0021883a 	mov	r16,zero
 820e0dc:	80003926 	beq	r16,zero,820e1c4 <__ssprint_r+0x13c>
 820e0e0:	102b883a 	mov	r21,r2
 820e0e4:	102d883a 	mov	r22,r2
 820e0e8:	80803a36 	bltu	r16,r2,820e1d4 <__ssprint_r+0x14c>
 820e0ec:	88c0030b 	ldhu	r3,12(r17)
 820e0f0:	1881200c 	andi	r2,r3,1152
 820e0f4:	10002626 	beq	r2,zero,820e190 <__ssprint_r+0x108>
 820e0f8:	88800517 	ldw	r2,20(r17)
 820e0fc:	89400417 	ldw	r5,16(r17)
 820e100:	81800044 	addi	r6,r16,1
 820e104:	108f883a 	add	r7,r2,r2
 820e108:	3885883a 	add	r2,r7,r2
 820e10c:	100ed7fa 	srli	r7,r2,31
 820e110:	216dc83a 	sub	r22,r4,r5
 820e114:	3589883a 	add	r4,r6,r22
 820e118:	3885883a 	add	r2,r7,r2
 820e11c:	102bd07a 	srai	r21,r2,1
 820e120:	a80d883a 	mov	r6,r21
 820e124:	a900022e 	bgeu	r21,r4,820e130 <__ssprint_r+0xa8>
 820e128:	202b883a 	mov	r21,r4
 820e12c:	200d883a 	mov	r6,r4
 820e130:	18c1000c 	andi	r3,r3,1024
 820e134:	18002a26 	beq	r3,zero,820e1e0 <__ssprint_r+0x158>
 820e138:	300b883a 	mov	r5,r6
 820e13c:	9809883a 	mov	r4,r19
 820e140:	820bcec0 	call	820bcec <_malloc_r>
 820e144:	1029883a 	mov	r20,r2
 820e148:	10002c26 	beq	r2,zero,820e1fc <__ssprint_r+0x174>
 820e14c:	89400417 	ldw	r5,16(r17)
 820e150:	b00d883a 	mov	r6,r22
 820e154:	1009883a 	mov	r4,r2
 820e158:	8202f100 	call	8202f10 <memcpy>
 820e15c:	8880030b 	ldhu	r2,12(r17)
 820e160:	00fedfc4 	movi	r3,-1153
 820e164:	10c4703a 	and	r2,r2,r3
 820e168:	10802014 	ori	r2,r2,128
 820e16c:	8880030d 	sth	r2,12(r17)
 820e170:	a589883a 	add	r4,r20,r22
 820e174:	adadc83a 	sub	r22,r21,r22
 820e178:	8d400515 	stw	r21,20(r17)
 820e17c:	8d800215 	stw	r22,8(r17)
 820e180:	8d000415 	stw	r20,16(r17)
 820e184:	89000015 	stw	r4,0(r17)
 820e188:	802b883a 	mov	r21,r16
 820e18c:	802d883a 	mov	r22,r16
 820e190:	b00d883a 	mov	r6,r22
 820e194:	e00b883a 	mov	r5,fp
 820e198:	82030580 	call	8203058 <memmove>
 820e19c:	88800217 	ldw	r2,8(r17)
 820e1a0:	89000017 	ldw	r4,0(r17)
 820e1a4:	90c00217 	ldw	r3,8(r18)
 820e1a8:	1545c83a 	sub	r2,r2,r21
 820e1ac:	2589883a 	add	r4,r4,r22
 820e1b0:	88800215 	stw	r2,8(r17)
 820e1b4:	89000015 	stw	r4,0(r17)
 820e1b8:	1c21c83a 	sub	r16,r3,r16
 820e1bc:	94000215 	stw	r16,8(r18)
 820e1c0:	80001726 	beq	r16,zero,820e220 <__ssprint_r+0x198>
 820e1c4:	bf000017 	ldw	fp,0(r23)
 820e1c8:	bc000117 	ldw	r16,4(r23)
 820e1cc:	bdc00204 	addi	r23,r23,8
 820e1d0:	003fc206 	br	820e0dc <__ssprint_r+0x54>
 820e1d4:	802b883a 	mov	r21,r16
 820e1d8:	802d883a 	mov	r22,r16
 820e1dc:	003fec06 	br	820e190 <__ssprint_r+0x108>
 820e1e0:	9809883a 	mov	r4,r19
 820e1e4:	820d6540 	call	820d654 <_realloc_r>
 820e1e8:	1029883a 	mov	r20,r2
 820e1ec:	103fe01e 	bne	r2,zero,820e170 <__ssprint_r+0xe8>
 820e1f0:	89400417 	ldw	r5,16(r17)
 820e1f4:	9809883a 	mov	r4,r19
 820e1f8:	820b1000 	call	820b100 <_free_r>
 820e1fc:	88c0030b 	ldhu	r3,12(r17)
 820e200:	00800304 	movi	r2,12
 820e204:	98800015 	stw	r2,0(r19)
 820e208:	18c01014 	ori	r3,r3,64
 820e20c:	88c0030d 	sth	r3,12(r17)
 820e210:	00bfffc4 	movi	r2,-1
 820e214:	90000215 	stw	zero,8(r18)
 820e218:	90000115 	stw	zero,4(r18)
 820e21c:	00000206 	br	820e228 <__ssprint_r+0x1a0>
 820e220:	90000115 	stw	zero,4(r18)
 820e224:	0005883a 	mov	r2,zero
 820e228:	dfc00917 	ldw	ra,36(sp)
 820e22c:	df000817 	ldw	fp,32(sp)
 820e230:	ddc00717 	ldw	r23,28(sp)
 820e234:	dd800617 	ldw	r22,24(sp)
 820e238:	dd400517 	ldw	r21,20(sp)
 820e23c:	dd000417 	ldw	r20,16(sp)
 820e240:	dcc00317 	ldw	r19,12(sp)
 820e244:	dc800217 	ldw	r18,8(sp)
 820e248:	dc400117 	ldw	r17,4(sp)
 820e24c:	dc000017 	ldw	r16,0(sp)
 820e250:	dec00a04 	addi	sp,sp,40
 820e254:	f800283a 	ret

0820e258 <___svfiprintf_internal_r>:
 820e258:	2880030b 	ldhu	r2,12(r5)
 820e25c:	deffc804 	addi	sp,sp,-224
 820e260:	dcc03115 	stw	r19,196(sp)
 820e264:	dfc03715 	stw	ra,220(sp)
 820e268:	df003615 	stw	fp,216(sp)
 820e26c:	ddc03515 	stw	r23,212(sp)
 820e270:	dd803415 	stw	r22,208(sp)
 820e274:	dd403315 	stw	r21,204(sp)
 820e278:	dd003215 	stw	r20,200(sp)
 820e27c:	dc803015 	stw	r18,192(sp)
 820e280:	dc402f15 	stw	r17,188(sp)
 820e284:	dc002e15 	stw	r16,184(sp)
 820e288:	d9402715 	stw	r5,156(sp)
 820e28c:	d9002a15 	stw	r4,168(sp)
 820e290:	1080200c 	andi	r2,r2,128
 820e294:	d9c02315 	stw	r7,140(sp)
 820e298:	3027883a 	mov	r19,r6
 820e29c:	10000226 	beq	r2,zero,820e2a8 <___svfiprintf_internal_r+0x50>
 820e2a0:	28800417 	ldw	r2,16(r5)
 820e2a4:	10041d26 	beq	r2,zero,820f31c <___svfiprintf_internal_r+0x10c4>
 820e2a8:	dac01a04 	addi	r11,sp,104
 820e2ac:	dac01e15 	stw	r11,120(sp)
 820e2b0:	d8801e17 	ldw	r2,120(sp)
 820e2b4:	dac019c4 	addi	r11,sp,103
 820e2b8:	dd402a17 	ldw	r21,168(sp)
 820e2bc:	ddc02717 	ldw	r23,156(sp)
 820e2c0:	05820974 	movhi	r22,2085
 820e2c4:	05020974 	movhi	r20,2085
 820e2c8:	dac01f15 	stw	r11,124(sp)
 820e2cc:	12d7c83a 	sub	r11,r2,r11
 820e2d0:	b5b72f04 	addi	r22,r22,-9028
 820e2d4:	a5372b04 	addi	r20,r20,-9044
 820e2d8:	dec01a15 	stw	sp,104(sp)
 820e2dc:	d8001c15 	stw	zero,112(sp)
 820e2e0:	d8001b15 	stw	zero,108(sp)
 820e2e4:	d811883a 	mov	r8,sp
 820e2e8:	d8002915 	stw	zero,164(sp)
 820e2ec:	d8002515 	stw	zero,148(sp)
 820e2f0:	dac02b15 	stw	r11,172(sp)
 820e2f4:	98800007 	ldb	r2,0(r19)
 820e2f8:	1002dd26 	beq	r2,zero,820ee70 <___svfiprintf_internal_r+0xc18>
 820e2fc:	00c00944 	movi	r3,37
 820e300:	9823883a 	mov	r17,r19
 820e304:	10c0021e 	bne	r2,r3,820e310 <___svfiprintf_internal_r+0xb8>
 820e308:	00001406 	br	820e35c <___svfiprintf_internal_r+0x104>
 820e30c:	10c00326 	beq	r2,r3,820e31c <___svfiprintf_internal_r+0xc4>
 820e310:	8c400044 	addi	r17,r17,1
 820e314:	88800007 	ldb	r2,0(r17)
 820e318:	103ffc1e 	bne	r2,zero,820e30c <___svfiprintf_internal_r+0xb4>
 820e31c:	8ce1c83a 	sub	r16,r17,r19
 820e320:	80000e26 	beq	r16,zero,820e35c <___svfiprintf_internal_r+0x104>
 820e324:	d8c01c17 	ldw	r3,112(sp)
 820e328:	d8801b17 	ldw	r2,108(sp)
 820e32c:	44c00015 	stw	r19,0(r8)
 820e330:	1c07883a 	add	r3,r3,r16
 820e334:	10800044 	addi	r2,r2,1
 820e338:	d8c01c15 	stw	r3,112(sp)
 820e33c:	44000115 	stw	r16,4(r8)
 820e340:	d8801b15 	stw	r2,108(sp)
 820e344:	00c001c4 	movi	r3,7
 820e348:	18831e16 	blt	r3,r2,820efc4 <___svfiprintf_internal_r+0xd6c>
 820e34c:	42000204 	addi	r8,r8,8
 820e350:	dac02517 	ldw	r11,148(sp)
 820e354:	5c17883a 	add	r11,r11,r16
 820e358:	dac02515 	stw	r11,148(sp)
 820e35c:	88800007 	ldb	r2,0(r17)
 820e360:	1002c526 	beq	r2,zero,820ee78 <___svfiprintf_internal_r+0xc20>
 820e364:	88c00047 	ldb	r3,1(r17)
 820e368:	8cc00044 	addi	r19,r17,1
 820e36c:	d8001d85 	stb	zero,118(sp)
 820e370:	0009883a 	mov	r4,zero
 820e374:	000f883a 	mov	r7,zero
 820e378:	043fffc4 	movi	r16,-1
 820e37c:	d8002415 	stw	zero,144(sp)
 820e380:	0025883a 	mov	r18,zero
 820e384:	01401604 	movi	r5,88
 820e388:	01800244 	movi	r6,9
 820e38c:	02800a84 	movi	r10,42
 820e390:	02401b04 	movi	r9,108
 820e394:	9cc00044 	addi	r19,r19,1
 820e398:	18bff804 	addi	r2,r3,-32
 820e39c:	2881dd36 	bltu	r5,r2,820eb14 <___svfiprintf_internal_r+0x8bc>
 820e3a0:	100490ba 	slli	r2,r2,2
 820e3a4:	02c20874 	movhi	r11,2081
 820e3a8:	5af8ee04 	addi	r11,r11,-7240
 820e3ac:	12c5883a 	add	r2,r2,r11
 820e3b0:	10800017 	ldw	r2,0(r2)
 820e3b4:	1000683a 	jmp	r2
 820e3b8:	0820e5b4 	orhi	zero,at,33686
 820e3bc:	0820eb14 	ori	zero,at,33708
 820e3c0:	0820eb14 	ori	zero,at,33708
 820e3c4:	0820e5a8 	cmpgeui	zero,at,33686
 820e3c8:	0820eb14 	ori	zero,at,33708
 820e3cc:	0820eb14 	ori	zero,at,33708
 820e3d0:	0820eb14 	ori	zero,at,33708
 820e3d4:	0820eb14 	ori	zero,at,33708
 820e3d8:	0820eb14 	ori	zero,at,33708
 820e3dc:	0820eb14 	ori	zero,at,33708
 820e3e0:	0820e51c 	xori	zero,at,33684
 820e3e4:	0820e6f8 	rdprs	zero,at,-31845
 820e3e8:	0820eb14 	ori	zero,at,33708
 820e3ec:	0820e548 	cmpgei	zero,at,-31851
 820e3f0:	0820eb48 	cmpgei	zero,at,-31827
 820e3f4:	0820eb14 	ori	zero,at,33708
 820e3f8:	0820eb3c 	xorhi	zero,at,33708
 820e3fc:	0820eadc 	xori	zero,at,33707
 820e400:	0820eadc 	xori	zero,at,33707
 820e404:	0820eadc 	xori	zero,at,33707
 820e408:	0820eadc 	xori	zero,at,33707
 820e40c:	0820eadc 	xori	zero,at,33707
 820e410:	0820eadc 	xori	zero,at,33707
 820e414:	0820eadc 	xori	zero,at,33707
 820e418:	0820eadc 	xori	zero,at,33707
 820e41c:	0820eadc 	xori	zero,at,33707
 820e420:	0820eb14 	ori	zero,at,33708
 820e424:	0820eb14 	ori	zero,at,33708
 820e428:	0820eb14 	ori	zero,at,33708
 820e42c:	0820eb14 	ori	zero,at,33708
 820e430:	0820eb14 	ori	zero,at,33708
 820e434:	0820eb14 	ori	zero,at,33708
 820e438:	0820eb14 	ori	zero,at,33708
 820e43c:	0820eb14 	ori	zero,at,33708
 820e440:	0820eb14 	ori	zero,at,33708
 820e444:	0820eb14 	ori	zero,at,33708
 820e448:	0820ea78 	rdprs	zero,at,-31831
 820e44c:	0820eb14 	ori	zero,at,33708
 820e450:	0820eb14 	ori	zero,at,33708
 820e454:	0820eb14 	ori	zero,at,33708
 820e458:	0820eb14 	ori	zero,at,33708
 820e45c:	0820eb14 	ori	zero,at,33708
 820e460:	0820eb14 	ori	zero,at,33708
 820e464:	0820eb14 	ori	zero,at,33708
 820e468:	0820eb14 	ori	zero,at,33708
 820e46c:	0820eb14 	ori	zero,at,33708
 820e470:	0820eb14 	ori	zero,at,33708
 820e474:	0820ebf0 	cmpltui	zero,at,33711
 820e478:	0820eb14 	ori	zero,at,33708
 820e47c:	0820eb14 	ori	zero,at,33708
 820e480:	0820eb14 	ori	zero,at,33708
 820e484:	0820eb14 	ori	zero,at,33708
 820e488:	0820eb14 	ori	zero,at,33708
 820e48c:	0820eb88 	cmpgei	zero,at,-31826
 820e490:	0820eb14 	ori	zero,at,33708
 820e494:	0820eb14 	ori	zero,at,33708
 820e498:	0820e8bc 	xorhi	zero,at,33698
 820e49c:	0820eb14 	ori	zero,at,33708
 820e4a0:	0820eb14 	ori	zero,at,33708
 820e4a4:	0820eb14 	ori	zero,at,33708
 820e4a8:	0820eb14 	ori	zero,at,33708
 820e4ac:	0820eb14 	ori	zero,at,33708
 820e4b0:	0820eb14 	ori	zero,at,33708
 820e4b4:	0820eb14 	ori	zero,at,33708
 820e4b8:	0820eb14 	ori	zero,at,33708
 820e4bc:	0820eb14 	ori	zero,at,33708
 820e4c0:	0820eb14 	ori	zero,at,33708
 820e4c4:	0820e7ac 	andhi	zero,at,33694
 820e4c8:	0820e958 	cmpnei	zero,at,-31835
 820e4cc:	0820eb14 	ori	zero,at,33708
 820e4d0:	0820eb14 	ori	zero,at,33708
 820e4d4:	0820eb14 	ori	zero,at,33708
 820e4d8:	0820e94c 	andi	zero,at,33701
 820e4dc:	0820e958 	cmpnei	zero,at,-31835
 820e4e0:	0820eb14 	ori	zero,at,33708
 820e4e4:	0820eb14 	ori	zero,at,33708
 820e4e8:	0820e93c 	xorhi	zero,at,33700
 820e4ec:	0820eb14 	ori	zero,at,33708
 820e4f0:	0820e900 	call	820e90 <OSCtxSw_SWITCH_PC+0x820e50>
 820e4f4:	0820e708 	cmpgei	zero,at,-31844
 820e4f8:	0820e554 	ori	zero,at,33685
 820e4fc:	0820ea6c 	andhi	zero,at,33705
 820e500:	0820eb14 	ori	zero,at,33708
 820e504:	0820ea20 	cmpeqi	zero,at,-31832
 820e508:	0820eb14 	ori	zero,at,33708
 820e50c:	0820e678 	rdprs	zero,at,-31847
 820e510:	0820eb14 	ori	zero,at,33708
 820e514:	0820eb14 	ori	zero,at,33708
 820e518:	0820e5d4 	ori	zero,at,33687
 820e51c:	dac02317 	ldw	r11,140(sp)
 820e520:	5ac00017 	ldw	r11,0(r11)
 820e524:	dac02415 	stw	r11,144(sp)
 820e528:	dac02317 	ldw	r11,140(sp)
 820e52c:	58800104 	addi	r2,r11,4
 820e530:	dac02417 	ldw	r11,144(sp)
 820e534:	5802e90e 	bge	r11,zero,820f0dc <___svfiprintf_internal_r+0xe84>
 820e538:	dac02417 	ldw	r11,144(sp)
 820e53c:	d8802315 	stw	r2,140(sp)
 820e540:	02d7c83a 	sub	r11,zero,r11
 820e544:	dac02415 	stw	r11,144(sp)
 820e548:	94800114 	ori	r18,r18,4
 820e54c:	98c00007 	ldb	r3,0(r19)
 820e550:	003f9006 	br	820e394 <___svfiprintf_internal_r+0x13c>
 820e554:	00800c04 	movi	r2,48
 820e558:	dac02317 	ldw	r11,140(sp)
 820e55c:	d8801d05 	stb	r2,116(sp)
 820e560:	00801e04 	movi	r2,120
 820e564:	d8801d45 	stb	r2,117(sp)
 820e568:	d8001d85 	stb	zero,118(sp)
 820e56c:	58c00104 	addi	r3,r11,4
 820e570:	5f000017 	ldw	fp,0(r11)
 820e574:	0013883a 	mov	r9,zero
 820e578:	90800094 	ori	r2,r18,2
 820e57c:	80032b16 	blt	r16,zero,820f22c <___svfiprintf_internal_r+0xfd4>
 820e580:	00bfdfc4 	movi	r2,-129
 820e584:	90a4703a 	and	r18,r18,r2
 820e588:	d8c02315 	stw	r3,140(sp)
 820e58c:	94800094 	ori	r18,r18,2
 820e590:	e002dc26 	beq	fp,zero,820f104 <___svfiprintf_internal_r+0xeac>
 820e594:	01020974 	movhi	r4,2085
 820e598:	2136c304 	addi	r4,r4,-9460
 820e59c:	0015883a 	mov	r10,zero
 820e5a0:	d9002915 	stw	r4,164(sp)
 820e5a4:	00002306 	br	820e634 <___svfiprintf_internal_r+0x3dc>
 820e5a8:	94800054 	ori	r18,r18,1
 820e5ac:	98c00007 	ldb	r3,0(r19)
 820e5b0:	003f7806 	br	820e394 <___svfiprintf_internal_r+0x13c>
 820e5b4:	38803fcc 	andi	r2,r7,255
 820e5b8:	1080201c 	xori	r2,r2,128
 820e5bc:	10bfe004 	addi	r2,r2,-128
 820e5c0:	1002f31e 	bne	r2,zero,820f190 <___svfiprintf_internal_r+0xf38>
 820e5c4:	01000044 	movi	r4,1
 820e5c8:	01c00804 	movi	r7,32
 820e5cc:	98c00007 	ldb	r3,0(r19)
 820e5d0:	003f7006 	br	820e394 <___svfiprintf_internal_r+0x13c>
 820e5d4:	21003fcc 	andi	r4,r4,255
 820e5d8:	2003aa1e 	bne	r4,zero,820f484 <___svfiprintf_internal_r+0x122c>
 820e5dc:	00820974 	movhi	r2,2085
 820e5e0:	10b6c304 	addi	r2,r2,-9460
 820e5e4:	d8802915 	stw	r2,164(sp)
 820e5e8:	9080080c 	andi	r2,r18,32
 820e5ec:	1000ba26 	beq	r2,zero,820e8d8 <___svfiprintf_internal_r+0x680>
 820e5f0:	dac02317 	ldw	r11,140(sp)
 820e5f4:	5f000017 	ldw	fp,0(r11)
 820e5f8:	5a400117 	ldw	r9,4(r11)
 820e5fc:	5ac00204 	addi	r11,r11,8
 820e600:	dac02315 	stw	r11,140(sp)
 820e604:	9080004c 	andi	r2,r18,1
 820e608:	10029026 	beq	r2,zero,820f04c <___svfiprintf_internal_r+0xdf4>
 820e60c:	e244b03a 	or	r2,fp,r9
 820e610:	1002d41e 	bne	r2,zero,820f164 <___svfiprintf_internal_r+0xf0c>
 820e614:	d8001d85 	stb	zero,118(sp)
 820e618:	80030b16 	blt	r16,zero,820f248 <___svfiprintf_internal_r+0xff0>
 820e61c:	00bfdfc4 	movi	r2,-129
 820e620:	90a4703a 	and	r18,r18,r2
 820e624:	0015883a 	mov	r10,zero
 820e628:	80002426 	beq	r16,zero,820e6bc <___svfiprintf_internal_r+0x464>
 820e62c:	0039883a 	mov	fp,zero
 820e630:	0013883a 	mov	r9,zero
 820e634:	d9002917 	ldw	r4,164(sp)
 820e638:	dc401a04 	addi	r17,sp,104
 820e63c:	e08003cc 	andi	r2,fp,15
 820e640:	4806973a 	slli	r3,r9,28
 820e644:	2085883a 	add	r2,r4,r2
 820e648:	e038d13a 	srli	fp,fp,4
 820e64c:	10800003 	ldbu	r2,0(r2)
 820e650:	4812d13a 	srli	r9,r9,4
 820e654:	8c7fffc4 	addi	r17,r17,-1
 820e658:	1f38b03a 	or	fp,r3,fp
 820e65c:	88800005 	stb	r2,0(r17)
 820e660:	e244b03a 	or	r2,fp,r9
 820e664:	103ff51e 	bne	r2,zero,820e63c <___svfiprintf_internal_r+0x3e4>
 820e668:	dac01e17 	ldw	r11,120(sp)
 820e66c:	5c57c83a 	sub	r11,r11,r17
 820e670:	dac02115 	stw	r11,132(sp)
 820e674:	00001406 	br	820e6c8 <___svfiprintf_internal_r+0x470>
 820e678:	21003fcc 	andi	r4,r4,255
 820e67c:	2003741e 	bne	r4,zero,820f450 <___svfiprintf_internal_r+0x11f8>
 820e680:	9080080c 	andi	r2,r18,32
 820e684:	10014526 	beq	r2,zero,820eb9c <___svfiprintf_internal_r+0x944>
 820e688:	dac02317 	ldw	r11,140(sp)
 820e68c:	d8001d85 	stb	zero,118(sp)
 820e690:	58c00204 	addi	r3,r11,8
 820e694:	5f000017 	ldw	fp,0(r11)
 820e698:	5a400117 	ldw	r9,4(r11)
 820e69c:	8002d916 	blt	r16,zero,820f204 <___svfiprintf_internal_r+0xfac>
 820e6a0:	013fdfc4 	movi	r4,-129
 820e6a4:	e244b03a 	or	r2,fp,r9
 820e6a8:	d8c02315 	stw	r3,140(sp)
 820e6ac:	9124703a 	and	r18,r18,r4
 820e6b0:	0015883a 	mov	r10,zero
 820e6b4:	1000b91e 	bne	r2,zero,820e99c <___svfiprintf_internal_r+0x744>
 820e6b8:	8002e61e 	bne	r16,zero,820f254 <___svfiprintf_internal_r+0xffc>
 820e6bc:	0021883a 	mov	r16,zero
 820e6c0:	d8002115 	stw	zero,132(sp)
 820e6c4:	dc401a04 	addi	r17,sp,104
 820e6c8:	d8c02117 	ldw	r3,132(sp)
 820e6cc:	dc002015 	stw	r16,128(sp)
 820e6d0:	80c0010e 	bge	r16,r3,820e6d8 <___svfiprintf_internal_r+0x480>
 820e6d4:	d8c02015 	stw	r3,128(sp)
 820e6d8:	52803fcc 	andi	r10,r10,255
 820e6dc:	5280201c 	xori	r10,r10,128
 820e6e0:	52bfe004 	addi	r10,r10,-128
 820e6e4:	50003c26 	beq	r10,zero,820e7d8 <___svfiprintf_internal_r+0x580>
 820e6e8:	dac02017 	ldw	r11,128(sp)
 820e6ec:	5ac00044 	addi	r11,r11,1
 820e6f0:	dac02015 	stw	r11,128(sp)
 820e6f4:	00003806 	br	820e7d8 <___svfiprintf_internal_r+0x580>
 820e6f8:	01000044 	movi	r4,1
 820e6fc:	01c00ac4 	movi	r7,43
 820e700:	98c00007 	ldb	r3,0(r19)
 820e704:	003f2306 	br	820e394 <___svfiprintf_internal_r+0x13c>
 820e708:	21003fcc 	andi	r4,r4,255
 820e70c:	2003481e 	bne	r4,zero,820f430 <___svfiprintf_internal_r+0x11d8>
 820e710:	9080080c 	andi	r2,r18,32
 820e714:	10013b26 	beq	r2,zero,820ec04 <___svfiprintf_internal_r+0x9ac>
 820e718:	dac02317 	ldw	r11,140(sp)
 820e71c:	d8001d85 	stb	zero,118(sp)
 820e720:	58800204 	addi	r2,r11,8
 820e724:	5f000017 	ldw	fp,0(r11)
 820e728:	5a400117 	ldw	r9,4(r11)
 820e72c:	8002a816 	blt	r16,zero,820f1d0 <___svfiprintf_internal_r+0xf78>
 820e730:	013fdfc4 	movi	r4,-129
 820e734:	e246b03a 	or	r3,fp,r9
 820e738:	d8802315 	stw	r2,140(sp)
 820e73c:	9124703a 	and	r18,r18,r4
 820e740:	18013c26 	beq	r3,zero,820ec34 <___svfiprintf_internal_r+0x9dc>
 820e744:	0015883a 	mov	r10,zero
 820e748:	dc401a04 	addi	r17,sp,104
 820e74c:	e006d0fa 	srli	r3,fp,3
 820e750:	4808977a 	slli	r4,r9,29
 820e754:	4812d0fa 	srli	r9,r9,3
 820e758:	e70001cc 	andi	fp,fp,7
 820e75c:	e0800c04 	addi	r2,fp,48
 820e760:	8c7fffc4 	addi	r17,r17,-1
 820e764:	20f8b03a 	or	fp,r4,r3
 820e768:	88800005 	stb	r2,0(r17)
 820e76c:	e246b03a 	or	r3,fp,r9
 820e770:	183ff61e 	bne	r3,zero,820e74c <___svfiprintf_internal_r+0x4f4>
 820e774:	90c0004c 	andi	r3,r18,1
 820e778:	1800a526 	beq	r3,zero,820ea10 <___svfiprintf_internal_r+0x7b8>
 820e77c:	10803fcc 	andi	r2,r2,255
 820e780:	1080201c 	xori	r2,r2,128
 820e784:	10bfe004 	addi	r2,r2,-128
 820e788:	00c00c04 	movi	r3,48
 820e78c:	10ffb626 	beq	r2,r3,820e668 <___svfiprintf_internal_r+0x410>
 820e790:	88ffffc5 	stb	r3,-1(r17)
 820e794:	d8c01e17 	ldw	r3,120(sp)
 820e798:	88bfffc4 	addi	r2,r17,-1
 820e79c:	1023883a 	mov	r17,r2
 820e7a0:	1887c83a 	sub	r3,r3,r2
 820e7a4:	d8c02115 	stw	r3,132(sp)
 820e7a8:	003fc706 	br	820e6c8 <___svfiprintf_internal_r+0x470>
 820e7ac:	dac02317 	ldw	r11,140(sp)
 820e7b0:	00c00044 	movi	r3,1
 820e7b4:	d8c02015 	stw	r3,128(sp)
 820e7b8:	58800017 	ldw	r2,0(r11)
 820e7bc:	5ac00104 	addi	r11,r11,4
 820e7c0:	d8001d85 	stb	zero,118(sp)
 820e7c4:	d8801005 	stb	r2,64(sp)
 820e7c8:	dac02315 	stw	r11,140(sp)
 820e7cc:	d8c02115 	stw	r3,132(sp)
 820e7d0:	dc401004 	addi	r17,sp,64
 820e7d4:	0021883a 	mov	r16,zero
 820e7d8:	90c0008c 	andi	r3,r18,2
 820e7dc:	d8c02215 	stw	r3,136(sp)
 820e7e0:	18000326 	beq	r3,zero,820e7f0 <___svfiprintf_internal_r+0x598>
 820e7e4:	dac02017 	ldw	r11,128(sp)
 820e7e8:	5ac00084 	addi	r11,r11,2
 820e7ec:	dac02015 	stw	r11,128(sp)
 820e7f0:	90c0210c 	andi	r3,r18,132
 820e7f4:	d8c02615 	stw	r3,152(sp)
 820e7f8:	1801131e 	bne	r3,zero,820ec48 <___svfiprintf_internal_r+0x9f0>
 820e7fc:	dac02417 	ldw	r11,144(sp)
 820e800:	d8c02017 	ldw	r3,128(sp)
 820e804:	58f9c83a 	sub	fp,r11,r3
 820e808:	07010f0e 	bge	zero,fp,820ec48 <___svfiprintf_internal_r+0x9f0>
 820e80c:	02400404 	movi	r9,16
 820e810:	d8c01c17 	ldw	r3,112(sp)
 820e814:	d8801b17 	ldw	r2,108(sp)
 820e818:	4f02d60e 	bge	r9,fp,820f374 <___svfiprintf_internal_r+0x111c>
 820e81c:	01420974 	movhi	r5,2085
 820e820:	29772f04 	addi	r5,r5,-9028
 820e824:	d9402815 	stw	r5,160(sp)
 820e828:	028001c4 	movi	r10,7
 820e82c:	00000306 	br	820e83c <___svfiprintf_internal_r+0x5e4>
 820e830:	e73ffc04 	addi	fp,fp,-16
 820e834:	42000204 	addi	r8,r8,8
 820e838:	4f00150e 	bge	r9,fp,820e890 <___svfiprintf_internal_r+0x638>
 820e83c:	18c00404 	addi	r3,r3,16
 820e840:	10800044 	addi	r2,r2,1
 820e844:	45800015 	stw	r22,0(r8)
 820e848:	42400115 	stw	r9,4(r8)
 820e84c:	d8c01c15 	stw	r3,112(sp)
 820e850:	d8801b15 	stw	r2,108(sp)
 820e854:	50bff60e 	bge	r10,r2,820e830 <___svfiprintf_internal_r+0x5d8>
 820e858:	d9801a04 	addi	r6,sp,104
 820e85c:	b80b883a 	mov	r5,r23
 820e860:	a809883a 	mov	r4,r21
 820e864:	da402c15 	stw	r9,176(sp)
 820e868:	da802d15 	stw	r10,180(sp)
 820e86c:	820e0880 	call	820e088 <__ssprint_r>
 820e870:	da402c17 	ldw	r9,176(sp)
 820e874:	da802d17 	ldw	r10,180(sp)
 820e878:	1001851e 	bne	r2,zero,820ee90 <___svfiprintf_internal_r+0xc38>
 820e87c:	e73ffc04 	addi	fp,fp,-16
 820e880:	d8c01c17 	ldw	r3,112(sp)
 820e884:	d8801b17 	ldw	r2,108(sp)
 820e888:	d811883a 	mov	r8,sp
 820e88c:	4f3feb16 	blt	r9,fp,820e83c <___svfiprintf_internal_r+0x5e4>
 820e890:	dac02817 	ldw	r11,160(sp)
 820e894:	e0c7883a 	add	r3,fp,r3
 820e898:	10800044 	addi	r2,r2,1
 820e89c:	42c00015 	stw	r11,0(r8)
 820e8a0:	47000115 	stw	fp,4(r8)
 820e8a4:	d8c01c15 	stw	r3,112(sp)
 820e8a8:	d8801b15 	stw	r2,108(sp)
 820e8ac:	010001c4 	movi	r4,7
 820e8b0:	2081ee16 	blt	r4,r2,820f06c <___svfiprintf_internal_r+0xe14>
 820e8b4:	42000204 	addi	r8,r8,8
 820e8b8:	0000e506 	br	820ec50 <___svfiprintf_internal_r+0x9f8>
 820e8bc:	21003fcc 	andi	r4,r4,255
 820e8c0:	2002dd1e 	bne	r4,zero,820f438 <___svfiprintf_internal_r+0x11e0>
 820e8c4:	00820974 	movhi	r2,2085
 820e8c8:	10b6be04 	addi	r2,r2,-9480
 820e8cc:	d8802915 	stw	r2,164(sp)
 820e8d0:	9080080c 	andi	r2,r18,32
 820e8d4:	103f461e 	bne	r2,zero,820e5f0 <___svfiprintf_internal_r+0x398>
 820e8d8:	9080040c 	andi	r2,r18,16
 820e8dc:	10022e1e 	bne	r2,zero,820f198 <___svfiprintf_internal_r+0xf40>
 820e8e0:	9080100c 	andi	r2,r18,64
 820e8e4:	dac02317 	ldw	r11,140(sp)
 820e8e8:	10027326 	beq	r2,zero,820f2b8 <___svfiprintf_internal_r+0x1060>
 820e8ec:	5f00000b 	ldhu	fp,0(r11)
 820e8f0:	5ac00104 	addi	r11,r11,4
 820e8f4:	0013883a 	mov	r9,zero
 820e8f8:	dac02315 	stw	r11,140(sp)
 820e8fc:	003f4106 	br	820e604 <___svfiprintf_internal_r+0x3ac>
 820e900:	21003fcc 	andi	r4,r4,255
 820e904:	2002e11e 	bne	r4,zero,820f48c <___svfiprintf_internal_r+0x1234>
 820e908:	9080080c 	andi	r2,r18,32
 820e90c:	1002011e 	bne	r2,zero,820f114 <___svfiprintf_internal_r+0xebc>
 820e910:	9080040c 	andi	r2,r18,16
 820e914:	10023e1e 	bne	r2,zero,820f210 <___svfiprintf_internal_r+0xfb8>
 820e918:	9480100c 	andi	r18,r18,64
 820e91c:	90023c26 	beq	r18,zero,820f210 <___svfiprintf_internal_r+0xfb8>
 820e920:	dac02317 	ldw	r11,140(sp)
 820e924:	58800017 	ldw	r2,0(r11)
 820e928:	5ac00104 	addi	r11,r11,4
 820e92c:	dac02315 	stw	r11,140(sp)
 820e930:	dac02517 	ldw	r11,148(sp)
 820e934:	12c0000d 	sth	r11,0(r2)
 820e938:	003e6e06 	br	820e2f4 <___svfiprintf_internal_r+0x9c>
 820e93c:	98c00007 	ldb	r3,0(r19)
 820e940:	1a422926 	beq	r3,r9,820f1e8 <___svfiprintf_internal_r+0xf90>
 820e944:	94800414 	ori	r18,r18,16
 820e948:	003e9206 	br	820e394 <___svfiprintf_internal_r+0x13c>
 820e94c:	94801014 	ori	r18,r18,64
 820e950:	98c00007 	ldb	r3,0(r19)
 820e954:	003e8f06 	br	820e394 <___svfiprintf_internal_r+0x13c>
 820e958:	21003fcc 	andi	r4,r4,255
 820e95c:	2002c71e 	bne	r4,zero,820f47c <___svfiprintf_internal_r+0x1224>
 820e960:	9080080c 	andi	r2,r18,32
 820e964:	10004926 	beq	r2,zero,820ea8c <___svfiprintf_internal_r+0x834>
 820e968:	dac02317 	ldw	r11,140(sp)
 820e96c:	58800117 	ldw	r2,4(r11)
 820e970:	5f000017 	ldw	fp,0(r11)
 820e974:	5ac00204 	addi	r11,r11,8
 820e978:	dac02315 	stw	r11,140(sp)
 820e97c:	1013883a 	mov	r9,r2
 820e980:	10004b16 	blt	r2,zero,820eab0 <___svfiprintf_internal_r+0x858>
 820e984:	da801d83 	ldbu	r10,118(sp)
 820e988:	8001cb16 	blt	r16,zero,820f0b8 <___svfiprintf_internal_r+0xe60>
 820e98c:	00ffdfc4 	movi	r3,-129
 820e990:	e244b03a 	or	r2,fp,r9
 820e994:	90e4703a 	and	r18,r18,r3
 820e998:	103f4726 	beq	r2,zero,820e6b8 <___svfiprintf_internal_r+0x460>
 820e99c:	48008c26 	beq	r9,zero,820ebd0 <___svfiprintf_internal_r+0x978>
 820e9a0:	dc802015 	stw	r18,128(sp)
 820e9a4:	dc002115 	stw	r16,132(sp)
 820e9a8:	dc401a04 	addi	r17,sp,104
 820e9ac:	e021883a 	mov	r16,fp
 820e9b0:	da002215 	stw	r8,136(sp)
 820e9b4:	5039883a 	mov	fp,r10
 820e9b8:	4825883a 	mov	r18,r9
 820e9bc:	8009883a 	mov	r4,r16
 820e9c0:	900b883a 	mov	r5,r18
 820e9c4:	01800284 	movi	r6,10
 820e9c8:	000f883a 	mov	r7,zero
 820e9cc:	82118300 	call	8211830 <__umoddi3>
 820e9d0:	10800c04 	addi	r2,r2,48
 820e9d4:	8c7fffc4 	addi	r17,r17,-1
 820e9d8:	8009883a 	mov	r4,r16
 820e9dc:	900b883a 	mov	r5,r18
 820e9e0:	88800005 	stb	r2,0(r17)
 820e9e4:	01800284 	movi	r6,10
 820e9e8:	000f883a 	mov	r7,zero
 820e9ec:	82112b80 	call	82112b8 <__udivdi3>
 820e9f0:	1021883a 	mov	r16,r2
 820e9f4:	10c4b03a 	or	r2,r2,r3
 820e9f8:	1825883a 	mov	r18,r3
 820e9fc:	103fef1e 	bne	r2,zero,820e9bc <___svfiprintf_internal_r+0x764>
 820ea00:	dc802017 	ldw	r18,128(sp)
 820ea04:	dc002117 	ldw	r16,132(sp)
 820ea08:	da002217 	ldw	r8,136(sp)
 820ea0c:	e015883a 	mov	r10,fp
 820ea10:	d8c01e17 	ldw	r3,120(sp)
 820ea14:	1c47c83a 	sub	r3,r3,r17
 820ea18:	d8c02115 	stw	r3,132(sp)
 820ea1c:	003f2a06 	br	820e6c8 <___svfiprintf_internal_r+0x470>
 820ea20:	dac02317 	ldw	r11,140(sp)
 820ea24:	d8001d85 	stb	zero,118(sp)
 820ea28:	5c400017 	ldw	r17,0(r11)
 820ea2c:	5f000104 	addi	fp,r11,4
 820ea30:	88022f26 	beq	r17,zero,820f2f0 <___svfiprintf_internal_r+0x1098>
 820ea34:	80022516 	blt	r16,zero,820f2cc <___svfiprintf_internal_r+0x1074>
 820ea38:	800d883a 	mov	r6,r16
 820ea3c:	000b883a 	mov	r5,zero
 820ea40:	8809883a 	mov	r4,r17
 820ea44:	da002c15 	stw	r8,176(sp)
 820ea48:	820c4f80 	call	820c4f8 <memchr>
 820ea4c:	da002c17 	ldw	r8,176(sp)
 820ea50:	10026426 	beq	r2,zero,820f3e4 <___svfiprintf_internal_r+0x118c>
 820ea54:	1445c83a 	sub	r2,r2,r17
 820ea58:	d8802115 	stw	r2,132(sp)
 820ea5c:	da801d83 	ldbu	r10,118(sp)
 820ea60:	df002315 	stw	fp,140(sp)
 820ea64:	0021883a 	mov	r16,zero
 820ea68:	003f1706 	br	820e6c8 <___svfiprintf_internal_r+0x470>
 820ea6c:	94800814 	ori	r18,r18,32
 820ea70:	98c00007 	ldb	r3,0(r19)
 820ea74:	003e4706 	br	820e394 <___svfiprintf_internal_r+0x13c>
 820ea78:	21003fcc 	andi	r4,r4,255
 820ea7c:	2002701e 	bne	r4,zero,820f440 <___svfiprintf_internal_r+0x11e8>
 820ea80:	94800414 	ori	r18,r18,16
 820ea84:	9080080c 	andi	r2,r18,32
 820ea88:	103fb71e 	bne	r2,zero,820e968 <___svfiprintf_internal_r+0x710>
 820ea8c:	9080040c 	andi	r2,r18,16
 820ea90:	1001ab26 	beq	r2,zero,820f140 <___svfiprintf_internal_r+0xee8>
 820ea94:	dac02317 	ldw	r11,140(sp)
 820ea98:	5f000017 	ldw	fp,0(r11)
 820ea9c:	5ac00104 	addi	r11,r11,4
 820eaa0:	dac02315 	stw	r11,140(sp)
 820eaa4:	e013d7fa 	srai	r9,fp,31
 820eaa8:	4805883a 	mov	r2,r9
 820eaac:	103fb50e 	bge	r2,zero,820e984 <___svfiprintf_internal_r+0x72c>
 820eab0:	0739c83a 	sub	fp,zero,fp
 820eab4:	02800b44 	movi	r10,45
 820eab8:	e004c03a 	cmpne	r2,fp,zero
 820eabc:	0253c83a 	sub	r9,zero,r9
 820eac0:	da801d85 	stb	r10,118(sp)
 820eac4:	4893c83a 	sub	r9,r9,r2
 820eac8:	80023016 	blt	r16,zero,820f38c <___svfiprintf_internal_r+0x1134>
 820eacc:	00bfdfc4 	movi	r2,-129
 820ead0:	90a4703a 	and	r18,r18,r2
 820ead4:	483fb21e 	bne	r9,zero,820e9a0 <___svfiprintf_internal_r+0x748>
 820ead8:	00003d06 	br	820ebd0 <___svfiprintf_internal_r+0x978>
 820eadc:	9817883a 	mov	r11,r19
 820eae0:	d8002415 	stw	zero,144(sp)
 820eae4:	18bff404 	addi	r2,r3,-48
 820eae8:	0019883a 	mov	r12,zero
 820eaec:	58c00007 	ldb	r3,0(r11)
 820eaf0:	630002a4 	muli	r12,r12,10
 820eaf4:	9cc00044 	addi	r19,r19,1
 820eaf8:	9817883a 	mov	r11,r19
 820eafc:	1319883a 	add	r12,r2,r12
 820eb00:	18bff404 	addi	r2,r3,-48
 820eb04:	30bff92e 	bgeu	r6,r2,820eaec <___svfiprintf_internal_r+0x894>
 820eb08:	db002415 	stw	r12,144(sp)
 820eb0c:	18bff804 	addi	r2,r3,-32
 820eb10:	28be232e 	bgeu	r5,r2,820e3a0 <___svfiprintf_internal_r+0x148>
 820eb14:	21003fcc 	andi	r4,r4,255
 820eb18:	20024b1e 	bne	r4,zero,820f448 <___svfiprintf_internal_r+0x11f0>
 820eb1c:	1800d626 	beq	r3,zero,820ee78 <___svfiprintf_internal_r+0xc20>
 820eb20:	02c00044 	movi	r11,1
 820eb24:	dac02015 	stw	r11,128(sp)
 820eb28:	d8c01005 	stb	r3,64(sp)
 820eb2c:	d8001d85 	stb	zero,118(sp)
 820eb30:	dac02115 	stw	r11,132(sp)
 820eb34:	dc401004 	addi	r17,sp,64
 820eb38:	003f2606 	br	820e7d4 <___svfiprintf_internal_r+0x57c>
 820eb3c:	94802014 	ori	r18,r18,128
 820eb40:	98c00007 	ldb	r3,0(r19)
 820eb44:	003e1306 	br	820e394 <___svfiprintf_internal_r+0x13c>
 820eb48:	98c00007 	ldb	r3,0(r19)
 820eb4c:	9ac00044 	addi	r11,r19,1
 820eb50:	1a822b26 	beq	r3,r10,820f400 <___svfiprintf_internal_r+0x11a8>
 820eb54:	18bff404 	addi	r2,r3,-48
 820eb58:	0021883a 	mov	r16,zero
 820eb5c:	30821e36 	bltu	r6,r2,820f3d8 <___svfiprintf_internal_r+0x1180>
 820eb60:	58c00007 	ldb	r3,0(r11)
 820eb64:	840002a4 	muli	r16,r16,10
 820eb68:	5cc00044 	addi	r19,r11,1
 820eb6c:	9817883a 	mov	r11,r19
 820eb70:	80a1883a 	add	r16,r16,r2
 820eb74:	18bff404 	addi	r2,r3,-48
 820eb78:	30bff92e 	bgeu	r6,r2,820eb60 <___svfiprintf_internal_r+0x908>
 820eb7c:	803e060e 	bge	r16,zero,820e398 <___svfiprintf_internal_r+0x140>
 820eb80:	043fffc4 	movi	r16,-1
 820eb84:	003e0406 	br	820e398 <___svfiprintf_internal_r+0x140>
 820eb88:	21003fcc 	andi	r4,r4,255
 820eb8c:	2002371e 	bne	r4,zero,820f46c <___svfiprintf_internal_r+0x1214>
 820eb90:	94800414 	ori	r18,r18,16
 820eb94:	9080080c 	andi	r2,r18,32
 820eb98:	103ebb1e 	bne	r2,zero,820e688 <___svfiprintf_internal_r+0x430>
 820eb9c:	9080040c 	andi	r2,r18,16
 820eba0:	10013b26 	beq	r2,zero,820f090 <___svfiprintf_internal_r+0xe38>
 820eba4:	dac02317 	ldw	r11,140(sp)
 820eba8:	d8001d85 	stb	zero,118(sp)
 820ebac:	0013883a 	mov	r9,zero
 820ebb0:	58800104 	addi	r2,r11,4
 820ebb4:	5f000017 	ldw	fp,0(r11)
 820ebb8:	80013d16 	blt	r16,zero,820f0b0 <___svfiprintf_internal_r+0xe58>
 820ebbc:	00ffdfc4 	movi	r3,-129
 820ebc0:	d8802315 	stw	r2,140(sp)
 820ebc4:	90e4703a 	and	r18,r18,r3
 820ebc8:	0015883a 	mov	r10,zero
 820ebcc:	e03eba26 	beq	fp,zero,820e6b8 <___svfiprintf_internal_r+0x460>
 820ebd0:	00800244 	movi	r2,9
 820ebd4:	173f7236 	bltu	r2,fp,820e9a0 <___svfiprintf_internal_r+0x748>
 820ebd8:	dac02b17 	ldw	r11,172(sp)
 820ebdc:	e7000c04 	addi	fp,fp,48
 820ebe0:	df0019c5 	stb	fp,103(sp)
 820ebe4:	dac02115 	stw	r11,132(sp)
 820ebe8:	dc4019c4 	addi	r17,sp,103
 820ebec:	003eb606 	br	820e6c8 <___svfiprintf_internal_r+0x470>
 820ebf0:	21003fcc 	andi	r4,r4,255
 820ebf4:	20021f1e 	bne	r4,zero,820f474 <___svfiprintf_internal_r+0x121c>
 820ebf8:	94800414 	ori	r18,r18,16
 820ebfc:	9080080c 	andi	r2,r18,32
 820ec00:	103ec51e 	bne	r2,zero,820e718 <___svfiprintf_internal_r+0x4c0>
 820ec04:	9080040c 	andi	r2,r18,16
 820ec08:	10016926 	beq	r2,zero,820f1b0 <___svfiprintf_internal_r+0xf58>
 820ec0c:	dac02317 	ldw	r11,140(sp)
 820ec10:	d8001d85 	stb	zero,118(sp)
 820ec14:	0013883a 	mov	r9,zero
 820ec18:	58800104 	addi	r2,r11,4
 820ec1c:	5f000017 	ldw	fp,0(r11)
 820ec20:	80016b16 	blt	r16,zero,820f1d0 <___svfiprintf_internal_r+0xf78>
 820ec24:	00ffdfc4 	movi	r3,-129
 820ec28:	d8802315 	stw	r2,140(sp)
 820ec2c:	90e4703a 	and	r18,r18,r3
 820ec30:	e03ec41e 	bne	fp,zero,820e744 <___svfiprintf_internal_r+0x4ec>
 820ec34:	0015883a 	mov	r10,zero
 820ec38:	8001c226 	beq	r16,zero,820f344 <___svfiprintf_internal_r+0x10ec>
 820ec3c:	0039883a 	mov	fp,zero
 820ec40:	0013883a 	mov	r9,zero
 820ec44:	003ec006 	br	820e748 <___svfiprintf_internal_r+0x4f0>
 820ec48:	d8c01c17 	ldw	r3,112(sp)
 820ec4c:	d8801b17 	ldw	r2,108(sp)
 820ec50:	d9001d87 	ldb	r4,118(sp)
 820ec54:	20000b26 	beq	r4,zero,820ec84 <___svfiprintf_internal_r+0xa2c>
 820ec58:	d9001d84 	addi	r4,sp,118
 820ec5c:	18c00044 	addi	r3,r3,1
 820ec60:	10800044 	addi	r2,r2,1
 820ec64:	41000015 	stw	r4,0(r8)
 820ec68:	01000044 	movi	r4,1
 820ec6c:	41000115 	stw	r4,4(r8)
 820ec70:	d8c01c15 	stw	r3,112(sp)
 820ec74:	d8801b15 	stw	r2,108(sp)
 820ec78:	010001c4 	movi	r4,7
 820ec7c:	2080e116 	blt	r4,r2,820f004 <___svfiprintf_internal_r+0xdac>
 820ec80:	42000204 	addi	r8,r8,8
 820ec84:	dac02217 	ldw	r11,136(sp)
 820ec88:	58000b26 	beq	r11,zero,820ecb8 <___svfiprintf_internal_r+0xa60>
 820ec8c:	d9001d04 	addi	r4,sp,116
 820ec90:	18c00084 	addi	r3,r3,2
 820ec94:	10800044 	addi	r2,r2,1
 820ec98:	41000015 	stw	r4,0(r8)
 820ec9c:	01000084 	movi	r4,2
 820eca0:	41000115 	stw	r4,4(r8)
 820eca4:	d8c01c15 	stw	r3,112(sp)
 820eca8:	d8801b15 	stw	r2,108(sp)
 820ecac:	010001c4 	movi	r4,7
 820ecb0:	2080dd16 	blt	r4,r2,820f028 <___svfiprintf_internal_r+0xdd0>
 820ecb4:	42000204 	addi	r8,r8,8
 820ecb8:	dac02617 	ldw	r11,152(sp)
 820ecbc:	01002004 	movi	r4,128
 820ecc0:	59008426 	beq	r11,r4,820eed4 <___svfiprintf_internal_r+0xc7c>
 820ecc4:	dac02117 	ldw	r11,132(sp)
 820ecc8:	82e1c83a 	sub	r16,r16,r11
 820eccc:	0400270e 	bge	zero,r16,820ed6c <___svfiprintf_internal_r+0xb14>
 820ecd0:	01c00404 	movi	r7,16
 820ecd4:	3c016a0e 	bge	r7,r16,820f280 <___svfiprintf_internal_r+0x1028>
 820ecd8:	01420974 	movhi	r5,2085
 820ecdc:	29772b04 	addi	r5,r5,-9044
 820ece0:	d9402215 	stw	r5,136(sp)
 820ece4:	070001c4 	movi	fp,7
 820ece8:	00000306 	br	820ecf8 <___svfiprintf_internal_r+0xaa0>
 820ecec:	843ffc04 	addi	r16,r16,-16
 820ecf0:	42000204 	addi	r8,r8,8
 820ecf4:	3c00130e 	bge	r7,r16,820ed44 <___svfiprintf_internal_r+0xaec>
 820ecf8:	18c00404 	addi	r3,r3,16
 820ecfc:	10800044 	addi	r2,r2,1
 820ed00:	45000015 	stw	r20,0(r8)
 820ed04:	41c00115 	stw	r7,4(r8)
 820ed08:	d8c01c15 	stw	r3,112(sp)
 820ed0c:	d8801b15 	stw	r2,108(sp)
 820ed10:	e0bff60e 	bge	fp,r2,820ecec <___svfiprintf_internal_r+0xa94>
 820ed14:	d9801a04 	addi	r6,sp,104
 820ed18:	b80b883a 	mov	r5,r23
 820ed1c:	a809883a 	mov	r4,r21
 820ed20:	d9c02c15 	stw	r7,176(sp)
 820ed24:	820e0880 	call	820e088 <__ssprint_r>
 820ed28:	d9c02c17 	ldw	r7,176(sp)
 820ed2c:	1000581e 	bne	r2,zero,820ee90 <___svfiprintf_internal_r+0xc38>
 820ed30:	843ffc04 	addi	r16,r16,-16
 820ed34:	d8c01c17 	ldw	r3,112(sp)
 820ed38:	d8801b17 	ldw	r2,108(sp)
 820ed3c:	d811883a 	mov	r8,sp
 820ed40:	3c3fed16 	blt	r7,r16,820ecf8 <___svfiprintf_internal_r+0xaa0>
 820ed44:	dac02217 	ldw	r11,136(sp)
 820ed48:	1c07883a 	add	r3,r3,r16
 820ed4c:	10800044 	addi	r2,r2,1
 820ed50:	42c00015 	stw	r11,0(r8)
 820ed54:	44000115 	stw	r16,4(r8)
 820ed58:	d8c01c15 	stw	r3,112(sp)
 820ed5c:	d8801b15 	stw	r2,108(sp)
 820ed60:	010001c4 	movi	r4,7
 820ed64:	20809e16 	blt	r4,r2,820efe0 <___svfiprintf_internal_r+0xd88>
 820ed68:	42000204 	addi	r8,r8,8
 820ed6c:	dac02117 	ldw	r11,132(sp)
 820ed70:	10800044 	addi	r2,r2,1
 820ed74:	44400015 	stw	r17,0(r8)
 820ed78:	58c7883a 	add	r3,r11,r3
 820ed7c:	42c00115 	stw	r11,4(r8)
 820ed80:	d8c01c15 	stw	r3,112(sp)
 820ed84:	d8801b15 	stw	r2,108(sp)
 820ed88:	010001c4 	movi	r4,7
 820ed8c:	20807f16 	blt	r4,r2,820ef8c <___svfiprintf_internal_r+0xd34>
 820ed90:	42000204 	addi	r8,r8,8
 820ed94:	9480010c 	andi	r18,r18,4
 820ed98:	90002926 	beq	r18,zero,820ee40 <___svfiprintf_internal_r+0xbe8>
 820ed9c:	dac02417 	ldw	r11,144(sp)
 820eda0:	d8802017 	ldw	r2,128(sp)
 820eda4:	58a1c83a 	sub	r16,r11,r2
 820eda8:	0400250e 	bge	zero,r16,820ee40 <___svfiprintf_internal_r+0xbe8>
 820edac:	04400404 	movi	r17,16
 820edb0:	d8801b17 	ldw	r2,108(sp)
 820edb4:	8c017c0e 	bge	r17,r16,820f3a8 <___svfiprintf_internal_r+0x1150>
 820edb8:	01420974 	movhi	r5,2085
 820edbc:	29772f04 	addi	r5,r5,-9028
 820edc0:	d9402815 	stw	r5,160(sp)
 820edc4:	048001c4 	movi	r18,7
 820edc8:	00000306 	br	820edd8 <___svfiprintf_internal_r+0xb80>
 820edcc:	843ffc04 	addi	r16,r16,-16
 820edd0:	42000204 	addi	r8,r8,8
 820edd4:	8c00110e 	bge	r17,r16,820ee1c <___svfiprintf_internal_r+0xbc4>
 820edd8:	18c00404 	addi	r3,r3,16
 820eddc:	10800044 	addi	r2,r2,1
 820ede0:	45800015 	stw	r22,0(r8)
 820ede4:	44400115 	stw	r17,4(r8)
 820ede8:	d8c01c15 	stw	r3,112(sp)
 820edec:	d8801b15 	stw	r2,108(sp)
 820edf0:	90bff60e 	bge	r18,r2,820edcc <___svfiprintf_internal_r+0xb74>
 820edf4:	d9801a04 	addi	r6,sp,104
 820edf8:	b80b883a 	mov	r5,r23
 820edfc:	a809883a 	mov	r4,r21
 820ee00:	820e0880 	call	820e088 <__ssprint_r>
 820ee04:	1000221e 	bne	r2,zero,820ee90 <___svfiprintf_internal_r+0xc38>
 820ee08:	843ffc04 	addi	r16,r16,-16
 820ee0c:	d8c01c17 	ldw	r3,112(sp)
 820ee10:	d8801b17 	ldw	r2,108(sp)
 820ee14:	d811883a 	mov	r8,sp
 820ee18:	8c3fef16 	blt	r17,r16,820edd8 <___svfiprintf_internal_r+0xb80>
 820ee1c:	dac02817 	ldw	r11,160(sp)
 820ee20:	1c07883a 	add	r3,r3,r16
 820ee24:	10800044 	addi	r2,r2,1
 820ee28:	42c00015 	stw	r11,0(r8)
 820ee2c:	44000115 	stw	r16,4(r8)
 820ee30:	d8c01c15 	stw	r3,112(sp)
 820ee34:	d8801b15 	stw	r2,108(sp)
 820ee38:	010001c4 	movi	r4,7
 820ee3c:	2080aa16 	blt	r4,r2,820f0e8 <___svfiprintf_internal_r+0xe90>
 820ee40:	d8802417 	ldw	r2,144(sp)
 820ee44:	dac02017 	ldw	r11,128(sp)
 820ee48:	12c0010e 	bge	r2,r11,820ee50 <___svfiprintf_internal_r+0xbf8>
 820ee4c:	5805883a 	mov	r2,r11
 820ee50:	dac02517 	ldw	r11,148(sp)
 820ee54:	5897883a 	add	r11,r11,r2
 820ee58:	dac02515 	stw	r11,148(sp)
 820ee5c:	1800531e 	bne	r3,zero,820efac <___svfiprintf_internal_r+0xd54>
 820ee60:	98800007 	ldb	r2,0(r19)
 820ee64:	d8001b15 	stw	zero,108(sp)
 820ee68:	d811883a 	mov	r8,sp
 820ee6c:	103d231e 	bne	r2,zero,820e2fc <___svfiprintf_internal_r+0xa4>
 820ee70:	9823883a 	mov	r17,r19
 820ee74:	003d3906 	br	820e35c <___svfiprintf_internal_r+0x104>
 820ee78:	d8801c17 	ldw	r2,112(sp)
 820ee7c:	10000426 	beq	r2,zero,820ee90 <___svfiprintf_internal_r+0xc38>
 820ee80:	d9402717 	ldw	r5,156(sp)
 820ee84:	d9002a17 	ldw	r4,168(sp)
 820ee88:	d9801a04 	addi	r6,sp,104
 820ee8c:	820e0880 	call	820e088 <__ssprint_r>
 820ee90:	dac02717 	ldw	r11,156(sp)
 820ee94:	d8802517 	ldw	r2,148(sp)
 820ee98:	58c0030b 	ldhu	r3,12(r11)
 820ee9c:	18c0100c 	andi	r3,r3,64
 820eea0:	1801381e 	bne	r3,zero,820f384 <___svfiprintf_internal_r+0x112c>
 820eea4:	dfc03717 	ldw	ra,220(sp)
 820eea8:	df003617 	ldw	fp,216(sp)
 820eeac:	ddc03517 	ldw	r23,212(sp)
 820eeb0:	dd803417 	ldw	r22,208(sp)
 820eeb4:	dd403317 	ldw	r21,204(sp)
 820eeb8:	dd003217 	ldw	r20,200(sp)
 820eebc:	dcc03117 	ldw	r19,196(sp)
 820eec0:	dc803017 	ldw	r18,192(sp)
 820eec4:	dc402f17 	ldw	r17,188(sp)
 820eec8:	dc002e17 	ldw	r16,184(sp)
 820eecc:	dec03804 	addi	sp,sp,224
 820eed0:	f800283a 	ret
 820eed4:	dac02417 	ldw	r11,144(sp)
 820eed8:	d9002017 	ldw	r4,128(sp)
 820eedc:	5939c83a 	sub	fp,r11,r4
 820eee0:	073f780e 	bge	zero,fp,820ecc4 <___svfiprintf_internal_r+0xa6c>
 820eee4:	02400404 	movi	r9,16
 820eee8:	4f01370e 	bge	r9,fp,820f3c8 <___svfiprintf_internal_r+0x1170>
 820eeec:	02c20974 	movhi	r11,2085
 820eef0:	5af72b04 	addi	r11,r11,-9044
 820eef4:	dac02215 	stw	r11,136(sp)
 820eef8:	028001c4 	movi	r10,7
 820eefc:	00000306 	br	820ef0c <___svfiprintf_internal_r+0xcb4>
 820ef00:	e73ffc04 	addi	fp,fp,-16
 820ef04:	42000204 	addi	r8,r8,8
 820ef08:	4f00150e 	bge	r9,fp,820ef60 <___svfiprintf_internal_r+0xd08>
 820ef0c:	18c00404 	addi	r3,r3,16
 820ef10:	10800044 	addi	r2,r2,1
 820ef14:	45000015 	stw	r20,0(r8)
 820ef18:	42400115 	stw	r9,4(r8)
 820ef1c:	d8c01c15 	stw	r3,112(sp)
 820ef20:	d8801b15 	stw	r2,108(sp)
 820ef24:	50bff60e 	bge	r10,r2,820ef00 <___svfiprintf_internal_r+0xca8>
 820ef28:	d9801a04 	addi	r6,sp,104
 820ef2c:	b80b883a 	mov	r5,r23
 820ef30:	a809883a 	mov	r4,r21
 820ef34:	da402c15 	stw	r9,176(sp)
 820ef38:	da802d15 	stw	r10,180(sp)
 820ef3c:	820e0880 	call	820e088 <__ssprint_r>
 820ef40:	da402c17 	ldw	r9,176(sp)
 820ef44:	da802d17 	ldw	r10,180(sp)
 820ef48:	103fd11e 	bne	r2,zero,820ee90 <___svfiprintf_internal_r+0xc38>
 820ef4c:	e73ffc04 	addi	fp,fp,-16
 820ef50:	d8c01c17 	ldw	r3,112(sp)
 820ef54:	d8801b17 	ldw	r2,108(sp)
 820ef58:	d811883a 	mov	r8,sp
 820ef5c:	4f3feb16 	blt	r9,fp,820ef0c <___svfiprintf_internal_r+0xcb4>
 820ef60:	dac02217 	ldw	r11,136(sp)
 820ef64:	1f07883a 	add	r3,r3,fp
 820ef68:	10800044 	addi	r2,r2,1
 820ef6c:	42c00015 	stw	r11,0(r8)
 820ef70:	47000115 	stw	fp,4(r8)
 820ef74:	d8c01c15 	stw	r3,112(sp)
 820ef78:	d8801b15 	stw	r2,108(sp)
 820ef7c:	010001c4 	movi	r4,7
 820ef80:	2080b616 	blt	r4,r2,820f25c <___svfiprintf_internal_r+0x1004>
 820ef84:	42000204 	addi	r8,r8,8
 820ef88:	003f4e06 	br	820ecc4 <___svfiprintf_internal_r+0xa6c>
 820ef8c:	d9801a04 	addi	r6,sp,104
 820ef90:	b80b883a 	mov	r5,r23
 820ef94:	a809883a 	mov	r4,r21
 820ef98:	820e0880 	call	820e088 <__ssprint_r>
 820ef9c:	103fbc1e 	bne	r2,zero,820ee90 <___svfiprintf_internal_r+0xc38>
 820efa0:	d8c01c17 	ldw	r3,112(sp)
 820efa4:	d811883a 	mov	r8,sp
 820efa8:	003f7a06 	br	820ed94 <___svfiprintf_internal_r+0xb3c>
 820efac:	d9801a04 	addi	r6,sp,104
 820efb0:	b80b883a 	mov	r5,r23
 820efb4:	a809883a 	mov	r4,r21
 820efb8:	820e0880 	call	820e088 <__ssprint_r>
 820efbc:	103fa826 	beq	r2,zero,820ee60 <___svfiprintf_internal_r+0xc08>
 820efc0:	003fb306 	br	820ee90 <___svfiprintf_internal_r+0xc38>
 820efc4:	d9801a04 	addi	r6,sp,104
 820efc8:	b80b883a 	mov	r5,r23
 820efcc:	a809883a 	mov	r4,r21
 820efd0:	820e0880 	call	820e088 <__ssprint_r>
 820efd4:	103fae1e 	bne	r2,zero,820ee90 <___svfiprintf_internal_r+0xc38>
 820efd8:	d811883a 	mov	r8,sp
 820efdc:	003cdc06 	br	820e350 <___svfiprintf_internal_r+0xf8>
 820efe0:	d9801a04 	addi	r6,sp,104
 820efe4:	b80b883a 	mov	r5,r23
 820efe8:	a809883a 	mov	r4,r21
 820efec:	820e0880 	call	820e088 <__ssprint_r>
 820eff0:	103fa71e 	bne	r2,zero,820ee90 <___svfiprintf_internal_r+0xc38>
 820eff4:	d8c01c17 	ldw	r3,112(sp)
 820eff8:	d8801b17 	ldw	r2,108(sp)
 820effc:	d811883a 	mov	r8,sp
 820f000:	003f5a06 	br	820ed6c <___svfiprintf_internal_r+0xb14>
 820f004:	d9801a04 	addi	r6,sp,104
 820f008:	b80b883a 	mov	r5,r23
 820f00c:	a809883a 	mov	r4,r21
 820f010:	820e0880 	call	820e088 <__ssprint_r>
 820f014:	103f9e1e 	bne	r2,zero,820ee90 <___svfiprintf_internal_r+0xc38>
 820f018:	d8c01c17 	ldw	r3,112(sp)
 820f01c:	d8801b17 	ldw	r2,108(sp)
 820f020:	d811883a 	mov	r8,sp
 820f024:	003f1706 	br	820ec84 <___svfiprintf_internal_r+0xa2c>
 820f028:	d9801a04 	addi	r6,sp,104
 820f02c:	b80b883a 	mov	r5,r23
 820f030:	a809883a 	mov	r4,r21
 820f034:	820e0880 	call	820e088 <__ssprint_r>
 820f038:	103f951e 	bne	r2,zero,820ee90 <___svfiprintf_internal_r+0xc38>
 820f03c:	d8c01c17 	ldw	r3,112(sp)
 820f040:	d8801b17 	ldw	r2,108(sp)
 820f044:	d811883a 	mov	r8,sp
 820f048:	003f1b06 	br	820ecb8 <___svfiprintf_internal_r+0xa60>
 820f04c:	d8001d85 	stb	zero,118(sp)
 820f050:	80007b16 	blt	r16,zero,820f240 <___svfiprintf_internal_r+0xfe8>
 820f054:	00ffdfc4 	movi	r3,-129
 820f058:	e244b03a 	or	r2,fp,r9
 820f05c:	90e4703a 	and	r18,r18,r3
 820f060:	103d7026 	beq	r2,zero,820e624 <___svfiprintf_internal_r+0x3cc>
 820f064:	0015883a 	mov	r10,zero
 820f068:	003d7206 	br	820e634 <___svfiprintf_internal_r+0x3dc>
 820f06c:	d9801a04 	addi	r6,sp,104
 820f070:	b80b883a 	mov	r5,r23
 820f074:	a809883a 	mov	r4,r21
 820f078:	820e0880 	call	820e088 <__ssprint_r>
 820f07c:	103f841e 	bne	r2,zero,820ee90 <___svfiprintf_internal_r+0xc38>
 820f080:	d8c01c17 	ldw	r3,112(sp)
 820f084:	d8801b17 	ldw	r2,108(sp)
 820f088:	d811883a 	mov	r8,sp
 820f08c:	003ef006 	br	820ec50 <___svfiprintf_internal_r+0x9f8>
 820f090:	9080100c 	andi	r2,r18,64
 820f094:	d8001d85 	stb	zero,118(sp)
 820f098:	dac02317 	ldw	r11,140(sp)
 820f09c:	10008126 	beq	r2,zero,820f2a4 <___svfiprintf_internal_r+0x104c>
 820f0a0:	58800104 	addi	r2,r11,4
 820f0a4:	5f00000b 	ldhu	fp,0(r11)
 820f0a8:	0013883a 	mov	r9,zero
 820f0ac:	803ec30e 	bge	r16,zero,820ebbc <___svfiprintf_internal_r+0x964>
 820f0b0:	d8802315 	stw	r2,140(sp)
 820f0b4:	0015883a 	mov	r10,zero
 820f0b8:	e244b03a 	or	r2,fp,r9
 820f0bc:	103e371e 	bne	r2,zero,820e99c <___svfiprintf_internal_r+0x744>
 820f0c0:	00800044 	movi	r2,1
 820f0c4:	10803fcc 	andi	r2,r2,255
 820f0c8:	00c00044 	movi	r3,1
 820f0cc:	10c06126 	beq	r2,r3,820f254 <___svfiprintf_internal_r+0xffc>
 820f0d0:	00c00084 	movi	r3,2
 820f0d4:	10fd5526 	beq	r2,r3,820e62c <___svfiprintf_internal_r+0x3d4>
 820f0d8:	003ed806 	br	820ec3c <___svfiprintf_internal_r+0x9e4>
 820f0dc:	d8802315 	stw	r2,140(sp)
 820f0e0:	98c00007 	ldb	r3,0(r19)
 820f0e4:	003cab06 	br	820e394 <___svfiprintf_internal_r+0x13c>
 820f0e8:	d9801a04 	addi	r6,sp,104
 820f0ec:	b80b883a 	mov	r5,r23
 820f0f0:	a809883a 	mov	r4,r21
 820f0f4:	820e0880 	call	820e088 <__ssprint_r>
 820f0f8:	103f651e 	bne	r2,zero,820ee90 <___svfiprintf_internal_r+0xc38>
 820f0fc:	d8c01c17 	ldw	r3,112(sp)
 820f100:	003f4f06 	br	820ee40 <___svfiprintf_internal_r+0xbe8>
 820f104:	00820974 	movhi	r2,2085
 820f108:	10b6c304 	addi	r2,r2,-9460
 820f10c:	d8802915 	stw	r2,164(sp)
 820f110:	003d4406 	br	820e624 <___svfiprintf_internal_r+0x3cc>
 820f114:	dac02317 	ldw	r11,140(sp)
 820f118:	58800017 	ldw	r2,0(r11)
 820f11c:	dac02517 	ldw	r11,148(sp)
 820f120:	5807d7fa 	srai	r3,r11,31
 820f124:	dac02317 	ldw	r11,140(sp)
 820f128:	10c00115 	stw	r3,4(r2)
 820f12c:	5ac00104 	addi	r11,r11,4
 820f130:	dac02315 	stw	r11,140(sp)
 820f134:	dac02517 	ldw	r11,148(sp)
 820f138:	12c00015 	stw	r11,0(r2)
 820f13c:	003c6d06 	br	820e2f4 <___svfiprintf_internal_r+0x9c>
 820f140:	9080100c 	andi	r2,r18,64
 820f144:	dac02317 	ldw	r11,140(sp)
 820f148:	103e5326 	beq	r2,zero,820ea98 <___svfiprintf_internal_r+0x840>
 820f14c:	5f00000f 	ldh	fp,0(r11)
 820f150:	5ac00104 	addi	r11,r11,4
 820f154:	dac02315 	stw	r11,140(sp)
 820f158:	e013d7fa 	srai	r9,fp,31
 820f15c:	4805883a 	mov	r2,r9
 820f160:	003e0706 	br	820e980 <___svfiprintf_internal_r+0x728>
 820f164:	00800c04 	movi	r2,48
 820f168:	d8801d05 	stb	r2,116(sp)
 820f16c:	d8c01d45 	stb	r3,117(sp)
 820f170:	d8001d85 	stb	zero,118(sp)
 820f174:	90800094 	ori	r2,r18,2
 820f178:	80008f16 	blt	r16,zero,820f3b8 <___svfiprintf_internal_r+0x1160>
 820f17c:	00bfdfc4 	movi	r2,-129
 820f180:	90a4703a 	and	r18,r18,r2
 820f184:	94800094 	ori	r18,r18,2
 820f188:	0015883a 	mov	r10,zero
 820f18c:	003d2906 	br	820e634 <___svfiprintf_internal_r+0x3dc>
 820f190:	98c00007 	ldb	r3,0(r19)
 820f194:	003c7f06 	br	820e394 <___svfiprintf_internal_r+0x13c>
 820f198:	dac02317 	ldw	r11,140(sp)
 820f19c:	0013883a 	mov	r9,zero
 820f1a0:	5f000017 	ldw	fp,0(r11)
 820f1a4:	5ac00104 	addi	r11,r11,4
 820f1a8:	dac02315 	stw	r11,140(sp)
 820f1ac:	003d1506 	br	820e604 <___svfiprintf_internal_r+0x3ac>
 820f1b0:	9080100c 	andi	r2,r18,64
 820f1b4:	d8001d85 	stb	zero,118(sp)
 820f1b8:	dac02317 	ldw	r11,140(sp)
 820f1bc:	10003426 	beq	r2,zero,820f290 <___svfiprintf_internal_r+0x1038>
 820f1c0:	58800104 	addi	r2,r11,4
 820f1c4:	5f00000b 	ldhu	fp,0(r11)
 820f1c8:	0013883a 	mov	r9,zero
 820f1cc:	803e950e 	bge	r16,zero,820ec24 <___svfiprintf_internal_r+0x9cc>
 820f1d0:	e246b03a 	or	r3,fp,r9
 820f1d4:	d8802315 	stw	r2,140(sp)
 820f1d8:	183d5a1e 	bne	r3,zero,820e744 <___svfiprintf_internal_r+0x4ec>
 820f1dc:	0015883a 	mov	r10,zero
 820f1e0:	0005883a 	mov	r2,zero
 820f1e4:	003fb706 	br	820f0c4 <___svfiprintf_internal_r+0xe6c>
 820f1e8:	98c00043 	ldbu	r3,1(r19)
 820f1ec:	94800814 	ori	r18,r18,32
 820f1f0:	9cc00044 	addi	r19,r19,1
 820f1f4:	18c03fcc 	andi	r3,r3,255
 820f1f8:	18c0201c 	xori	r3,r3,128
 820f1fc:	18ffe004 	addi	r3,r3,-128
 820f200:	003c6406 	br	820e394 <___svfiprintf_internal_r+0x13c>
 820f204:	d8c02315 	stw	r3,140(sp)
 820f208:	0015883a 	mov	r10,zero
 820f20c:	003faa06 	br	820f0b8 <___svfiprintf_internal_r+0xe60>
 820f210:	dac02317 	ldw	r11,140(sp)
 820f214:	58800017 	ldw	r2,0(r11)
 820f218:	5ac00104 	addi	r11,r11,4
 820f21c:	dac02315 	stw	r11,140(sp)
 820f220:	dac02517 	ldw	r11,148(sp)
 820f224:	12c00015 	stw	r11,0(r2)
 820f228:	003c3206 	br	820e2f4 <___svfiprintf_internal_r+0x9c>
 820f22c:	01020974 	movhi	r4,2085
 820f230:	2136c304 	addi	r4,r4,-9460
 820f234:	d9002915 	stw	r4,164(sp)
 820f238:	d8c02315 	stw	r3,140(sp)
 820f23c:	1025883a 	mov	r18,r2
 820f240:	e244b03a 	or	r2,fp,r9
 820f244:	103f871e 	bne	r2,zero,820f064 <___svfiprintf_internal_r+0xe0c>
 820f248:	0015883a 	mov	r10,zero
 820f24c:	00800084 	movi	r2,2
 820f250:	003f9c06 	br	820f0c4 <___svfiprintf_internal_r+0xe6c>
 820f254:	0039883a 	mov	fp,zero
 820f258:	003e5f06 	br	820ebd8 <___svfiprintf_internal_r+0x980>
 820f25c:	d9801a04 	addi	r6,sp,104
 820f260:	b80b883a 	mov	r5,r23
 820f264:	a809883a 	mov	r4,r21
 820f268:	820e0880 	call	820e088 <__ssprint_r>
 820f26c:	103f081e 	bne	r2,zero,820ee90 <___svfiprintf_internal_r+0xc38>
 820f270:	d8c01c17 	ldw	r3,112(sp)
 820f274:	d8801b17 	ldw	r2,108(sp)
 820f278:	d811883a 	mov	r8,sp
 820f27c:	003e9106 	br	820ecc4 <___svfiprintf_internal_r+0xa6c>
 820f280:	01020974 	movhi	r4,2085
 820f284:	21372b04 	addi	r4,r4,-9044
 820f288:	d9002215 	stw	r4,136(sp)
 820f28c:	003ead06 	br	820ed44 <___svfiprintf_internal_r+0xaec>
 820f290:	58800104 	addi	r2,r11,4
 820f294:	5f000017 	ldw	fp,0(r11)
 820f298:	0013883a 	mov	r9,zero
 820f29c:	803e610e 	bge	r16,zero,820ec24 <___svfiprintf_internal_r+0x9cc>
 820f2a0:	003fcb06 	br	820f1d0 <___svfiprintf_internal_r+0xf78>
 820f2a4:	58800104 	addi	r2,r11,4
 820f2a8:	5f000017 	ldw	fp,0(r11)
 820f2ac:	0013883a 	mov	r9,zero
 820f2b0:	803e420e 	bge	r16,zero,820ebbc <___svfiprintf_internal_r+0x964>
 820f2b4:	003f7e06 	br	820f0b0 <___svfiprintf_internal_r+0xe58>
 820f2b8:	5f000017 	ldw	fp,0(r11)
 820f2bc:	5ac00104 	addi	r11,r11,4
 820f2c0:	0013883a 	mov	r9,zero
 820f2c4:	dac02315 	stw	r11,140(sp)
 820f2c8:	003cce06 	br	820e604 <___svfiprintf_internal_r+0x3ac>
 820f2cc:	8809883a 	mov	r4,r17
 820f2d0:	da002c15 	stw	r8,176(sp)
 820f2d4:	8203f600 	call	8203f60 <strlen>
 820f2d8:	d8802115 	stw	r2,132(sp)
 820f2dc:	da801d83 	ldbu	r10,118(sp)
 820f2e0:	df002315 	stw	fp,140(sp)
 820f2e4:	0021883a 	mov	r16,zero
 820f2e8:	da002c17 	ldw	r8,176(sp)
 820f2ec:	003cf606 	br	820e6c8 <___svfiprintf_internal_r+0x470>
 820f2f0:	00800184 	movi	r2,6
 820f2f4:	1400012e 	bgeu	r2,r16,820f2fc <___svfiprintf_internal_r+0x10a4>
 820f2f8:	1021883a 	mov	r16,r2
 820f2fc:	dc002115 	stw	r16,132(sp)
 820f300:	8005883a 	mov	r2,r16
 820f304:	80003c16 	blt	r16,zero,820f3f8 <___svfiprintf_internal_r+0x11a0>
 820f308:	04420974 	movhi	r17,2085
 820f30c:	d8802015 	stw	r2,128(sp)
 820f310:	df002315 	stw	fp,140(sp)
 820f314:	8c76c804 	addi	r17,r17,-9440
 820f318:	003d2e06 	br	820e7d4 <___svfiprintf_internal_r+0x57c>
 820f31c:	04001004 	movi	r16,64
 820f320:	800b883a 	mov	r5,r16
 820f324:	820bcec0 	call	820bcec <_malloc_r>
 820f328:	dac02717 	ldw	r11,156(sp)
 820f32c:	58800015 	stw	r2,0(r11)
 820f330:	58800415 	stw	r2,16(r11)
 820f334:	10004826 	beq	r2,zero,820f458 <___svfiprintf_internal_r+0x1200>
 820f338:	dac02717 	ldw	r11,156(sp)
 820f33c:	5c000515 	stw	r16,20(r11)
 820f340:	003bd906 	br	820e2a8 <___svfiprintf_internal_r+0x50>
 820f344:	9080004c 	andi	r2,r18,1
 820f348:	0015883a 	mov	r10,zero
 820f34c:	10000626 	beq	r2,zero,820f368 <___svfiprintf_internal_r+0x1110>
 820f350:	dac02b17 	ldw	r11,172(sp)
 820f354:	00800c04 	movi	r2,48
 820f358:	d88019c5 	stb	r2,103(sp)
 820f35c:	dac02115 	stw	r11,132(sp)
 820f360:	dc4019c4 	addi	r17,sp,103
 820f364:	003cd806 	br	820e6c8 <___svfiprintf_internal_r+0x470>
 820f368:	d8002115 	stw	zero,132(sp)
 820f36c:	dc401a04 	addi	r17,sp,104
 820f370:	003cd506 	br	820e6c8 <___svfiprintf_internal_r+0x470>
 820f374:	01020974 	movhi	r4,2085
 820f378:	21372f04 	addi	r4,r4,-9028
 820f37c:	d9002815 	stw	r4,160(sp)
 820f380:	003d4306 	br	820e890 <___svfiprintf_internal_r+0x638>
 820f384:	00bfffc4 	movi	r2,-1
 820f388:	003ec606 	br	820eea4 <___svfiprintf_internal_r+0xc4c>
 820f38c:	00800044 	movi	r2,1
 820f390:	10803fcc 	andi	r2,r2,255
 820f394:	00c00044 	movi	r3,1
 820f398:	10fd8026 	beq	r2,r3,820e99c <___svfiprintf_internal_r+0x744>
 820f39c:	00c00084 	movi	r3,2
 820f3a0:	10fca426 	beq	r2,r3,820e634 <___svfiprintf_internal_r+0x3dc>
 820f3a4:	003ce806 	br	820e748 <___svfiprintf_internal_r+0x4f0>
 820f3a8:	01020974 	movhi	r4,2085
 820f3ac:	21372f04 	addi	r4,r4,-9028
 820f3b0:	d9002815 	stw	r4,160(sp)
 820f3b4:	003e9906 	br	820ee1c <___svfiprintf_internal_r+0xbc4>
 820f3b8:	1025883a 	mov	r18,r2
 820f3bc:	0015883a 	mov	r10,zero
 820f3c0:	00800084 	movi	r2,2
 820f3c4:	003ff206 	br	820f390 <___svfiprintf_internal_r+0x1138>
 820f3c8:	01420974 	movhi	r5,2085
 820f3cc:	29772b04 	addi	r5,r5,-9044
 820f3d0:	d9402215 	stw	r5,136(sp)
 820f3d4:	003ee206 	br	820ef60 <___svfiprintf_internal_r+0xd08>
 820f3d8:	5827883a 	mov	r19,r11
 820f3dc:	0021883a 	mov	r16,zero
 820f3e0:	003bed06 	br	820e398 <___svfiprintf_internal_r+0x140>
 820f3e4:	dc002115 	stw	r16,132(sp)
 820f3e8:	da801d83 	ldbu	r10,118(sp)
 820f3ec:	df002315 	stw	fp,140(sp)
 820f3f0:	0021883a 	mov	r16,zero
 820f3f4:	003cb406 	br	820e6c8 <___svfiprintf_internal_r+0x470>
 820f3f8:	0005883a 	mov	r2,zero
 820f3fc:	003fc206 	br	820f308 <___svfiprintf_internal_r+0x10b0>
 820f400:	d8802317 	ldw	r2,140(sp)
 820f404:	98c00043 	ldbu	r3,1(r19)
 820f408:	5827883a 	mov	r19,r11
 820f40c:	14000017 	ldw	r16,0(r2)
 820f410:	10800104 	addi	r2,r2,4
 820f414:	d8802315 	stw	r2,140(sp)
 820f418:	803f760e 	bge	r16,zero,820f1f4 <___svfiprintf_internal_r+0xf9c>
 820f41c:	18c03fcc 	andi	r3,r3,255
 820f420:	18c0201c 	xori	r3,r3,128
 820f424:	043fffc4 	movi	r16,-1
 820f428:	18ffe004 	addi	r3,r3,-128
 820f42c:	003bd906 	br	820e394 <___svfiprintf_internal_r+0x13c>
 820f430:	d9c01d85 	stb	r7,118(sp)
 820f434:	003cb606 	br	820e710 <___svfiprintf_internal_r+0x4b8>
 820f438:	d9c01d85 	stb	r7,118(sp)
 820f43c:	003d2106 	br	820e8c4 <___svfiprintf_internal_r+0x66c>
 820f440:	d9c01d85 	stb	r7,118(sp)
 820f444:	003d8e06 	br	820ea80 <___svfiprintf_internal_r+0x828>
 820f448:	d9c01d85 	stb	r7,118(sp)
 820f44c:	003db306 	br	820eb1c <___svfiprintf_internal_r+0x8c4>
 820f450:	d9c01d85 	stb	r7,118(sp)
 820f454:	003c8a06 	br	820e680 <___svfiprintf_internal_r+0x428>
 820f458:	dac02a17 	ldw	r11,168(sp)
 820f45c:	00800304 	movi	r2,12
 820f460:	58800015 	stw	r2,0(r11)
 820f464:	00bfffc4 	movi	r2,-1
 820f468:	003e8e06 	br	820eea4 <___svfiprintf_internal_r+0xc4c>
 820f46c:	d9c01d85 	stb	r7,118(sp)
 820f470:	003dc706 	br	820eb90 <___svfiprintf_internal_r+0x938>
 820f474:	d9c01d85 	stb	r7,118(sp)
 820f478:	003ddf06 	br	820ebf8 <___svfiprintf_internal_r+0x9a0>
 820f47c:	d9c01d85 	stb	r7,118(sp)
 820f480:	003d3706 	br	820e960 <___svfiprintf_internal_r+0x708>
 820f484:	d9c01d85 	stb	r7,118(sp)
 820f488:	003c5406 	br	820e5dc <___svfiprintf_internal_r+0x384>
 820f48c:	d9c01d85 	stb	r7,118(sp)
 820f490:	003d1d06 	br	820e908 <___svfiprintf_internal_r+0x6b0>

0820f494 <__sprint_r.part.0>:
 820f494:	28801917 	ldw	r2,100(r5)
 820f498:	defff604 	addi	sp,sp,-40
 820f49c:	dd400515 	stw	r21,20(sp)
 820f4a0:	dfc00915 	stw	ra,36(sp)
 820f4a4:	df000815 	stw	fp,32(sp)
 820f4a8:	ddc00715 	stw	r23,28(sp)
 820f4ac:	dd800615 	stw	r22,24(sp)
 820f4b0:	dd000415 	stw	r20,16(sp)
 820f4b4:	dcc00315 	stw	r19,12(sp)
 820f4b8:	dc800215 	stw	r18,8(sp)
 820f4bc:	dc400115 	stw	r17,4(sp)
 820f4c0:	dc000015 	stw	r16,0(sp)
 820f4c4:	1088000c 	andi	r2,r2,8192
 820f4c8:	302b883a 	mov	r21,r6
 820f4cc:	10002e26 	beq	r2,zero,820f588 <__sprint_r.part.0+0xf4>
 820f4d0:	30800217 	ldw	r2,8(r6)
 820f4d4:	35800017 	ldw	r22,0(r6)
 820f4d8:	10002926 	beq	r2,zero,820f580 <__sprint_r.part.0+0xec>
 820f4dc:	2827883a 	mov	r19,r5
 820f4e0:	2029883a 	mov	r20,r4
 820f4e4:	b5c00104 	addi	r23,r22,4
 820f4e8:	04bfffc4 	movi	r18,-1
 820f4ec:	bc400017 	ldw	r17,0(r23)
 820f4f0:	b4000017 	ldw	r16,0(r22)
 820f4f4:	0039883a 	mov	fp,zero
 820f4f8:	8822d0ba 	srli	r17,r17,2
 820f4fc:	8800031e 	bne	r17,zero,820f50c <__sprint_r.part.0+0x78>
 820f500:	00001806 	br	820f564 <__sprint_r.part.0+0xd0>
 820f504:	84000104 	addi	r16,r16,4
 820f508:	8f001526 	beq	r17,fp,820f560 <__sprint_r.part.0+0xcc>
 820f50c:	81400017 	ldw	r5,0(r16)
 820f510:	980d883a 	mov	r6,r19
 820f514:	a009883a 	mov	r4,r20
 820f518:	8210ebc0 	call	8210ebc <_fputwc_r>
 820f51c:	e7000044 	addi	fp,fp,1
 820f520:	14bff81e 	bne	r2,r18,820f504 <__sprint_r.part.0+0x70>
 820f524:	9005883a 	mov	r2,r18
 820f528:	a8000215 	stw	zero,8(r21)
 820f52c:	a8000115 	stw	zero,4(r21)
 820f530:	dfc00917 	ldw	ra,36(sp)
 820f534:	df000817 	ldw	fp,32(sp)
 820f538:	ddc00717 	ldw	r23,28(sp)
 820f53c:	dd800617 	ldw	r22,24(sp)
 820f540:	dd400517 	ldw	r21,20(sp)
 820f544:	dd000417 	ldw	r20,16(sp)
 820f548:	dcc00317 	ldw	r19,12(sp)
 820f54c:	dc800217 	ldw	r18,8(sp)
 820f550:	dc400117 	ldw	r17,4(sp)
 820f554:	dc000017 	ldw	r16,0(sp)
 820f558:	dec00a04 	addi	sp,sp,40
 820f55c:	f800283a 	ret
 820f560:	a8800217 	ldw	r2,8(r21)
 820f564:	8c63883a 	add	r17,r17,r17
 820f568:	8c63883a 	add	r17,r17,r17
 820f56c:	1445c83a 	sub	r2,r2,r17
 820f570:	a8800215 	stw	r2,8(r21)
 820f574:	b5800204 	addi	r22,r22,8
 820f578:	bdc00204 	addi	r23,r23,8
 820f57c:	103fdb1e 	bne	r2,zero,820f4ec <__sprint_r.part.0+0x58>
 820f580:	0005883a 	mov	r2,zero
 820f584:	003fe806 	br	820f528 <__sprint_r.part.0+0x94>
 820f588:	820b4100 	call	820b410 <__sfvwrite_r>
 820f58c:	003fe606 	br	820f528 <__sprint_r.part.0+0x94>

0820f590 <__sprint_r>:
 820f590:	30c00217 	ldw	r3,8(r6)
 820f594:	18000126 	beq	r3,zero,820f59c <__sprint_r+0xc>
 820f598:	820f4941 	jmpi	820f494 <__sprint_r.part.0>
 820f59c:	30000115 	stw	zero,4(r6)
 820f5a0:	0005883a 	mov	r2,zero
 820f5a4:	f800283a 	ret

0820f5a8 <___vfiprintf_internal_r>:
 820f5a8:	deffc904 	addi	sp,sp,-220
 820f5ac:	df003515 	stw	fp,212(sp)
 820f5b0:	dd003115 	stw	r20,196(sp)
 820f5b4:	dfc03615 	stw	ra,216(sp)
 820f5b8:	ddc03415 	stw	r23,208(sp)
 820f5bc:	dd803315 	stw	r22,204(sp)
 820f5c0:	dd403215 	stw	r21,200(sp)
 820f5c4:	dcc03015 	stw	r19,192(sp)
 820f5c8:	dc802f15 	stw	r18,188(sp)
 820f5cc:	dc402e15 	stw	r17,184(sp)
 820f5d0:	dc002d15 	stw	r16,180(sp)
 820f5d4:	d9002015 	stw	r4,128(sp)
 820f5d8:	d9c02215 	stw	r7,136(sp)
 820f5dc:	2829883a 	mov	r20,r5
 820f5e0:	3039883a 	mov	fp,r6
 820f5e4:	20000226 	beq	r4,zero,820f5f0 <___vfiprintf_internal_r+0x48>
 820f5e8:	20800e17 	ldw	r2,56(r4)
 820f5ec:	1000cf26 	beq	r2,zero,820f92c <___vfiprintf_internal_r+0x384>
 820f5f0:	a080030b 	ldhu	r2,12(r20)
 820f5f4:	10c8000c 	andi	r3,r2,8192
 820f5f8:	1800061e 	bne	r3,zero,820f614 <___vfiprintf_internal_r+0x6c>
 820f5fc:	a1001917 	ldw	r4,100(r20)
 820f600:	00f7ffc4 	movi	r3,-8193
 820f604:	10880014 	ori	r2,r2,8192
 820f608:	20c6703a 	and	r3,r4,r3
 820f60c:	a080030d 	sth	r2,12(r20)
 820f610:	a0c01915 	stw	r3,100(r20)
 820f614:	10c0020c 	andi	r3,r2,8
 820f618:	1800a926 	beq	r3,zero,820f8c0 <___vfiprintf_internal_r+0x318>
 820f61c:	a0c00417 	ldw	r3,16(r20)
 820f620:	1800a726 	beq	r3,zero,820f8c0 <___vfiprintf_internal_r+0x318>
 820f624:	1080068c 	andi	r2,r2,26
 820f628:	00c00284 	movi	r3,10
 820f62c:	10c0ac26 	beq	r2,r3,820f8e0 <___vfiprintf_internal_r+0x338>
 820f630:	da801a04 	addi	r10,sp,104
 820f634:	da801e15 	stw	r10,120(sp)
 820f638:	d8801e17 	ldw	r2,120(sp)
 820f63c:	da8019c4 	addi	r10,sp,103
 820f640:	05820974 	movhi	r22,2085
 820f644:	05c20974 	movhi	r23,2085
 820f648:	da801f15 	stw	r10,124(sp)
 820f64c:	1295c83a 	sub	r10,r2,r10
 820f650:	b5b73704 	addi	r22,r22,-8996
 820f654:	bdf73304 	addi	r23,r23,-9012
 820f658:	dec01a15 	stw	sp,104(sp)
 820f65c:	d8001c15 	stw	zero,112(sp)
 820f660:	d8001b15 	stw	zero,108(sp)
 820f664:	d8002615 	stw	zero,152(sp)
 820f668:	d8002315 	stw	zero,140(sp)
 820f66c:	da802715 	stw	r10,156(sp)
 820f670:	d811883a 	mov	r8,sp
 820f674:	dd002115 	stw	r20,132(sp)
 820f678:	e021883a 	mov	r16,fp
 820f67c:	80800007 	ldb	r2,0(r16)
 820f680:	1003ea26 	beq	r2,zero,821062c <___vfiprintf_internal_r+0x1084>
 820f684:	00c00944 	movi	r3,37
 820f688:	8025883a 	mov	r18,r16
 820f68c:	10c0021e 	bne	r2,r3,820f698 <___vfiprintf_internal_r+0xf0>
 820f690:	00001606 	br	820f6ec <___vfiprintf_internal_r+0x144>
 820f694:	10c00326 	beq	r2,r3,820f6a4 <___vfiprintf_internal_r+0xfc>
 820f698:	94800044 	addi	r18,r18,1
 820f69c:	90800007 	ldb	r2,0(r18)
 820f6a0:	103ffc1e 	bne	r2,zero,820f694 <___vfiprintf_internal_r+0xec>
 820f6a4:	9423c83a 	sub	r17,r18,r16
 820f6a8:	88001026 	beq	r17,zero,820f6ec <___vfiprintf_internal_r+0x144>
 820f6ac:	d8c01c17 	ldw	r3,112(sp)
 820f6b0:	d8801b17 	ldw	r2,108(sp)
 820f6b4:	44000015 	stw	r16,0(r8)
 820f6b8:	88c7883a 	add	r3,r17,r3
 820f6bc:	10800044 	addi	r2,r2,1
 820f6c0:	44400115 	stw	r17,4(r8)
 820f6c4:	d8c01c15 	stw	r3,112(sp)
 820f6c8:	d8801b15 	stw	r2,108(sp)
 820f6cc:	010001c4 	movi	r4,7
 820f6d0:	2080760e 	bge	r4,r2,820f8ac <___vfiprintf_internal_r+0x304>
 820f6d4:	1803821e 	bne	r3,zero,82104e0 <___vfiprintf_internal_r+0xf38>
 820f6d8:	da802317 	ldw	r10,140(sp)
 820f6dc:	d8001b15 	stw	zero,108(sp)
 820f6e0:	d811883a 	mov	r8,sp
 820f6e4:	5455883a 	add	r10,r10,r17
 820f6e8:	da802315 	stw	r10,140(sp)
 820f6ec:	90800007 	ldb	r2,0(r18)
 820f6f0:	10044626 	beq	r2,zero,821080c <___vfiprintf_internal_r+0x1264>
 820f6f4:	90c00047 	ldb	r3,1(r18)
 820f6f8:	94000044 	addi	r16,r18,1
 820f6fc:	d8001d85 	stb	zero,118(sp)
 820f700:	0009883a 	mov	r4,zero
 820f704:	000f883a 	mov	r7,zero
 820f708:	027fffc4 	movi	r9,-1
 820f70c:	0023883a 	mov	r17,zero
 820f710:	0029883a 	mov	r20,zero
 820f714:	01401604 	movi	r5,88
 820f718:	01800244 	movi	r6,9
 820f71c:	03400a84 	movi	r13,42
 820f720:	03001b04 	movi	r12,108
 820f724:	84000044 	addi	r16,r16,1
 820f728:	18bff804 	addi	r2,r3,-32
 820f72c:	28827336 	bltu	r5,r2,82100fc <___vfiprintf_internal_r+0xb54>
 820f730:	100490ba 	slli	r2,r2,2
 820f734:	02820874 	movhi	r10,2081
 820f738:	52bdd204 	addi	r10,r10,-2232
 820f73c:	1285883a 	add	r2,r2,r10
 820f740:	10800017 	ldw	r2,0(r2)
 820f744:	1000683a 	jmp	r2
 820f748:	0820fe30 	cmpltui	zero,at,33784
 820f74c:	082100fc 	xorhi	zero,at,33795
 820f750:	082100fc 	xorhi	zero,at,33795
 820f754:	0820fe50 	cmplti	zero,at,-31751
 820f758:	082100fc 	xorhi	zero,at,33795
 820f75c:	082100fc 	xorhi	zero,at,33795
 820f760:	082100fc 	xorhi	zero,at,33795
 820f764:	082100fc 	xorhi	zero,at,33795
 820f768:	082100fc 	xorhi	zero,at,33795
 820f76c:	082100fc 	xorhi	zero,at,33795
 820f770:	08210038 	rdprs	zero,at,-31744
 820f774:	08210054 	ori	zero,at,33793
 820f778:	082100fc 	xorhi	zero,at,33795
 820f77c:	0820f93c 	xorhi	zero,at,33764
 820f780:	08210064 	muli	zero,at,-31743
 820f784:	082100fc 	xorhi	zero,at,33795
 820f788:	0820fe5c 	xori	zero,at,33785
 820f78c:	0820fe68 	cmpgeui	zero,at,33785
 820f790:	0820fe68 	cmpgeui	zero,at,33785
 820f794:	0820fe68 	cmpgeui	zero,at,33785
 820f798:	0820fe68 	cmpgeui	zero,at,33785
 820f79c:	0820fe68 	cmpgeui	zero,at,33785
 820f7a0:	0820fe68 	cmpgeui	zero,at,33785
 820f7a4:	0820fe68 	cmpgeui	zero,at,33785
 820f7a8:	0820fe68 	cmpgeui	zero,at,33785
 820f7ac:	0820fe68 	cmpgeui	zero,at,33785
 820f7b0:	082100fc 	xorhi	zero,at,33795
 820f7b4:	082100fc 	xorhi	zero,at,33795
 820f7b8:	082100fc 	xorhi	zero,at,33795
 820f7bc:	082100fc 	xorhi	zero,at,33795
 820f7c0:	082100fc 	xorhi	zero,at,33795
 820f7c4:	082100fc 	xorhi	zero,at,33795
 820f7c8:	082100fc 	xorhi	zero,at,33795
 820f7cc:	082100fc 	xorhi	zero,at,33795
 820f7d0:	082100fc 	xorhi	zero,at,33795
 820f7d4:	082100fc 	xorhi	zero,at,33795
 820f7d8:	0820fe94 	ori	zero,at,33786
 820f7dc:	082100fc 	xorhi	zero,at,33795
 820f7e0:	082100fc 	xorhi	zero,at,33795
 820f7e4:	082100fc 	xorhi	zero,at,33795
 820f7e8:	082100fc 	xorhi	zero,at,33795
 820f7ec:	082100fc 	xorhi	zero,at,33795
 820f7f0:	082100fc 	xorhi	zero,at,33795
 820f7f4:	082100fc 	xorhi	zero,at,33795
 820f7f8:	082100fc 	xorhi	zero,at,33795
 820f7fc:	082100fc 	xorhi	zero,at,33795
 820f800:	082100fc 	xorhi	zero,at,33795
 820f804:	0820fecc 	andi	zero,at,33787
 820f808:	082100fc 	xorhi	zero,at,33795
 820f80c:	082100fc 	xorhi	zero,at,33795
 820f810:	082100fc 	xorhi	zero,at,33795
 820f814:	082100fc 	xorhi	zero,at,33795
 820f818:	082100fc 	xorhi	zero,at,33795
 820f81c:	0820ff24 	muli	zero,at,-31748
 820f820:	082100fc 	xorhi	zero,at,33795
 820f824:	082100fc 	xorhi	zero,at,33795
 820f828:	0820ff94 	ori	zero,at,33790
 820f82c:	082100fc 	xorhi	zero,at,33795
 820f830:	082100fc 	xorhi	zero,at,33795
 820f834:	082100fc 	xorhi	zero,at,33795
 820f838:	082100fc 	xorhi	zero,at,33795
 820f83c:	082100fc 	xorhi	zero,at,33795
 820f840:	082100fc 	xorhi	zero,at,33795
 820f844:	082100fc 	xorhi	zero,at,33795
 820f848:	082100fc 	xorhi	zero,at,33795
 820f84c:	082100fc 	xorhi	zero,at,33795
 820f850:	082100fc 	xorhi	zero,at,33795
 820f854:	0820fd40 	call	820fd4 <OSCtxSw_SWITCH_PC+0x820f94>
 820f858:	0820fd6c 	andhi	zero,at,33781
 820f85c:	082100fc 	xorhi	zero,at,33795
 820f860:	082100fc 	xorhi	zero,at,33795
 820f864:	082100fc 	xorhi	zero,at,33795
 820f868:	082100a4 	muli	zero,at,-31742
 820f86c:	0820fd6c 	andhi	zero,at,33781
 820f870:	082100fc 	xorhi	zero,at,33795
 820f874:	082100fc 	xorhi	zero,at,33795
 820f878:	0820fc00 	call	820fc0 <OSCtxSw_SWITCH_PC+0x820f80>
 820f87c:	082100fc 	xorhi	zero,at,33795
 820f880:	0820fc10 	cmplti	zero,at,-31760
 820f884:	0820fc4c 	andi	zero,at,33777
 820f888:	0820f948 	cmpgei	zero,at,-31771
 820f88c:	0820fbf4 	orhi	zero,at,33775
 820f890:	082100fc 	xorhi	zero,at,33795
 820f894:	0820ffd0 	cmplti	zero,at,-31745
 820f898:	082100fc 	xorhi	zero,at,33795
 820f89c:	08210028 	cmpgeui	zero,at,33792
 820f8a0:	082100fc 	xorhi	zero,at,33795
 820f8a4:	082100fc 	xorhi	zero,at,33795
 820f8a8:	0820fcec 	andhi	zero,at,33779
 820f8ac:	42000204 	addi	r8,r8,8
 820f8b0:	da802317 	ldw	r10,140(sp)
 820f8b4:	5455883a 	add	r10,r10,r17
 820f8b8:	da802315 	stw	r10,140(sp)
 820f8bc:	003f8b06 	br	820f6ec <___vfiprintf_internal_r+0x144>
 820f8c0:	d9002017 	ldw	r4,128(sp)
 820f8c4:	a00b883a 	mov	r5,r20
 820f8c8:	8208e640 	call	8208e64 <__swsetup_r>
 820f8cc:	1003b11e 	bne	r2,zero,8210794 <___vfiprintf_internal_r+0x11ec>
 820f8d0:	a080030b 	ldhu	r2,12(r20)
 820f8d4:	00c00284 	movi	r3,10
 820f8d8:	1080068c 	andi	r2,r2,26
 820f8dc:	10ff541e 	bne	r2,r3,820f630 <___vfiprintf_internal_r+0x88>
 820f8e0:	a080038f 	ldh	r2,14(r20)
 820f8e4:	103f5216 	blt	r2,zero,820f630 <___vfiprintf_internal_r+0x88>
 820f8e8:	d9c02217 	ldw	r7,136(sp)
 820f8ec:	d9002017 	ldw	r4,128(sp)
 820f8f0:	e00d883a 	mov	r6,fp
 820f8f4:	a00b883a 	mov	r5,r20
 820f8f8:	8210a200 	call	8210a20 <__sbprintf>
 820f8fc:	dfc03617 	ldw	ra,216(sp)
 820f900:	df003517 	ldw	fp,212(sp)
 820f904:	ddc03417 	ldw	r23,208(sp)
 820f908:	dd803317 	ldw	r22,204(sp)
 820f90c:	dd403217 	ldw	r21,200(sp)
 820f910:	dd003117 	ldw	r20,196(sp)
 820f914:	dcc03017 	ldw	r19,192(sp)
 820f918:	dc802f17 	ldw	r18,188(sp)
 820f91c:	dc402e17 	ldw	r17,184(sp)
 820f920:	dc002d17 	ldw	r16,180(sp)
 820f924:	dec03704 	addi	sp,sp,220
 820f928:	f800283a 	ret
 820f92c:	820ae380 	call	820ae38 <__sinit>
 820f930:	003f2f06 	br	820f5f0 <___vfiprintf_internal_r+0x48>
 820f934:	0463c83a 	sub	r17,zero,r17
 820f938:	d8802215 	stw	r2,136(sp)
 820f93c:	a5000114 	ori	r20,r20,4
 820f940:	80c00007 	ldb	r3,0(r16)
 820f944:	003f7706 	br	820f724 <___vfiprintf_internal_r+0x17c>
 820f948:	00800c04 	movi	r2,48
 820f94c:	da802217 	ldw	r10,136(sp)
 820f950:	d8801d05 	stb	r2,116(sp)
 820f954:	00801e04 	movi	r2,120
 820f958:	d8801d45 	stb	r2,117(sp)
 820f95c:	d8001d85 	stb	zero,118(sp)
 820f960:	50c00104 	addi	r3,r10,4
 820f964:	54800017 	ldw	r18,0(r10)
 820f968:	0027883a 	mov	r19,zero
 820f96c:	a0800094 	ori	r2,r20,2
 820f970:	48030b16 	blt	r9,zero,82105a0 <___vfiprintf_internal_r+0xff8>
 820f974:	00bfdfc4 	movi	r2,-129
 820f978:	a096703a 	and	r11,r20,r2
 820f97c:	d8c02215 	stw	r3,136(sp)
 820f980:	5d000094 	ori	r20,r11,2
 820f984:	90032b1e 	bne	r18,zero,8210634 <___vfiprintf_internal_r+0x108c>
 820f988:	00820974 	movhi	r2,2085
 820f98c:	10b6c304 	addi	r2,r2,-9460
 820f990:	d8802615 	stw	r2,152(sp)
 820f994:	0039883a 	mov	fp,zero
 820f998:	48017b1e 	bne	r9,zero,820ff88 <___vfiprintf_internal_r+0x9e0>
 820f99c:	0013883a 	mov	r9,zero
 820f9a0:	0027883a 	mov	r19,zero
 820f9a4:	dd401a04 	addi	r21,sp,104
 820f9a8:	4825883a 	mov	r18,r9
 820f9ac:	4cc0010e 	bge	r9,r19,820f9b4 <___vfiprintf_internal_r+0x40c>
 820f9b0:	9825883a 	mov	r18,r19
 820f9b4:	e7003fcc 	andi	fp,fp,255
 820f9b8:	e700201c 	xori	fp,fp,128
 820f9bc:	e73fe004 	addi	fp,fp,-128
 820f9c0:	e0000126 	beq	fp,zero,820f9c8 <___vfiprintf_internal_r+0x420>
 820f9c4:	94800044 	addi	r18,r18,1
 820f9c8:	a380008c 	andi	r14,r20,2
 820f9cc:	70000126 	beq	r14,zero,820f9d4 <___vfiprintf_internal_r+0x42c>
 820f9d0:	94800084 	addi	r18,r18,2
 820f9d4:	a700210c 	andi	fp,r20,132
 820f9d8:	e001df1e 	bne	fp,zero,8210158 <___vfiprintf_internal_r+0xbb0>
 820f9dc:	8c87c83a 	sub	r3,r17,r18
 820f9e0:	00c1dd0e 	bge	zero,r3,8210158 <___vfiprintf_internal_r+0xbb0>
 820f9e4:	01c00404 	movi	r7,16
 820f9e8:	d8801c17 	ldw	r2,112(sp)
 820f9ec:	38c3ad0e 	bge	r7,r3,82108a4 <___vfiprintf_internal_r+0x12fc>
 820f9f0:	02820974 	movhi	r10,2085
 820f9f4:	52b73704 	addi	r10,r10,-8996
 820f9f8:	dc002915 	stw	r16,164(sp)
 820f9fc:	d9801b17 	ldw	r6,108(sp)
 820fa00:	da802415 	stw	r10,144(sp)
 820fa04:	03c001c4 	movi	r15,7
 820fa08:	da402515 	stw	r9,148(sp)
 820fa0c:	db802815 	stw	r14,160(sp)
 820fa10:	1821883a 	mov	r16,r3
 820fa14:	00000506 	br	820fa2c <___vfiprintf_internal_r+0x484>
 820fa18:	31400084 	addi	r5,r6,2
 820fa1c:	42000204 	addi	r8,r8,8
 820fa20:	200d883a 	mov	r6,r4
 820fa24:	843ffc04 	addi	r16,r16,-16
 820fa28:	3c000d0e 	bge	r7,r16,820fa60 <___vfiprintf_internal_r+0x4b8>
 820fa2c:	10800404 	addi	r2,r2,16
 820fa30:	31000044 	addi	r4,r6,1
 820fa34:	45800015 	stw	r22,0(r8)
 820fa38:	41c00115 	stw	r7,4(r8)
 820fa3c:	d8801c15 	stw	r2,112(sp)
 820fa40:	d9001b15 	stw	r4,108(sp)
 820fa44:	793ff40e 	bge	r15,r4,820fa18 <___vfiprintf_internal_r+0x470>
 820fa48:	1001b51e 	bne	r2,zero,8210120 <___vfiprintf_internal_r+0xb78>
 820fa4c:	843ffc04 	addi	r16,r16,-16
 820fa50:	000d883a 	mov	r6,zero
 820fa54:	01400044 	movi	r5,1
 820fa58:	d811883a 	mov	r8,sp
 820fa5c:	3c3ff316 	blt	r7,r16,820fa2c <___vfiprintf_internal_r+0x484>
 820fa60:	8007883a 	mov	r3,r16
 820fa64:	da402517 	ldw	r9,148(sp)
 820fa68:	db802817 	ldw	r14,160(sp)
 820fa6c:	dc002917 	ldw	r16,164(sp)
 820fa70:	da802417 	ldw	r10,144(sp)
 820fa74:	1885883a 	add	r2,r3,r2
 820fa78:	40c00115 	stw	r3,4(r8)
 820fa7c:	42800015 	stw	r10,0(r8)
 820fa80:	d8801c15 	stw	r2,112(sp)
 820fa84:	d9401b15 	stw	r5,108(sp)
 820fa88:	00c001c4 	movi	r3,7
 820fa8c:	19426016 	blt	r3,r5,8210410 <___vfiprintf_internal_r+0xe68>
 820fa90:	d8c01d87 	ldb	r3,118(sp)
 820fa94:	42000204 	addi	r8,r8,8
 820fa98:	29000044 	addi	r4,r5,1
 820fa9c:	1801b31e 	bne	r3,zero,821016c <___vfiprintf_internal_r+0xbc4>
 820faa0:	7001c026 	beq	r14,zero,82101a4 <___vfiprintf_internal_r+0xbfc>
 820faa4:	d8c01d04 	addi	r3,sp,116
 820faa8:	10800084 	addi	r2,r2,2
 820faac:	40c00015 	stw	r3,0(r8)
 820fab0:	00c00084 	movi	r3,2
 820fab4:	40c00115 	stw	r3,4(r8)
 820fab8:	d8801c15 	stw	r2,112(sp)
 820fabc:	d9001b15 	stw	r4,108(sp)
 820fac0:	00c001c4 	movi	r3,7
 820fac4:	1902650e 	bge	r3,r4,821045c <___vfiprintf_internal_r+0xeb4>
 820fac8:	10029a1e 	bne	r2,zero,8210534 <___vfiprintf_internal_r+0xf8c>
 820facc:	00c02004 	movi	r3,128
 820fad0:	01000044 	movi	r4,1
 820fad4:	000b883a 	mov	r5,zero
 820fad8:	d811883a 	mov	r8,sp
 820fadc:	e0c1b31e 	bne	fp,r3,82101ac <___vfiprintf_internal_r+0xc04>
 820fae0:	8cb9c83a 	sub	fp,r17,r18
 820fae4:	0701b10e 	bge	zero,fp,82101ac <___vfiprintf_internal_r+0xc04>
 820fae8:	01c00404 	movi	r7,16
 820faec:	3f03890e 	bge	r7,fp,8210914 <___vfiprintf_internal_r+0x136c>
 820faf0:	00c20974 	movhi	r3,2085
 820faf4:	18f73304 	addi	r3,r3,-9012
 820faf8:	d8c02415 	stw	r3,144(sp)
 820fafc:	8007883a 	mov	r3,r16
 820fb00:	034001c4 	movi	r13,7
 820fb04:	e021883a 	mov	r16,fp
 820fb08:	da402515 	stw	r9,148(sp)
 820fb0c:	1839883a 	mov	fp,r3
 820fb10:	00000506 	br	820fb28 <___vfiprintf_internal_r+0x580>
 820fb14:	29800084 	addi	r6,r5,2
 820fb18:	42000204 	addi	r8,r8,8
 820fb1c:	180b883a 	mov	r5,r3
 820fb20:	843ffc04 	addi	r16,r16,-16
 820fb24:	3c000d0e 	bge	r7,r16,820fb5c <___vfiprintf_internal_r+0x5b4>
 820fb28:	10800404 	addi	r2,r2,16
 820fb2c:	28c00044 	addi	r3,r5,1
 820fb30:	45c00015 	stw	r23,0(r8)
 820fb34:	41c00115 	stw	r7,4(r8)
 820fb38:	d8801c15 	stw	r2,112(sp)
 820fb3c:	d8c01b15 	stw	r3,108(sp)
 820fb40:	68fff40e 	bge	r13,r3,820fb14 <___vfiprintf_internal_r+0x56c>
 820fb44:	1002241e 	bne	r2,zero,82103d8 <___vfiprintf_internal_r+0xe30>
 820fb48:	843ffc04 	addi	r16,r16,-16
 820fb4c:	01800044 	movi	r6,1
 820fb50:	000b883a 	mov	r5,zero
 820fb54:	d811883a 	mov	r8,sp
 820fb58:	3c3ff316 	blt	r7,r16,820fb28 <___vfiprintf_internal_r+0x580>
 820fb5c:	da402517 	ldw	r9,148(sp)
 820fb60:	e007883a 	mov	r3,fp
 820fb64:	8039883a 	mov	fp,r16
 820fb68:	1821883a 	mov	r16,r3
 820fb6c:	d8c02417 	ldw	r3,144(sp)
 820fb70:	1705883a 	add	r2,r2,fp
 820fb74:	47000115 	stw	fp,4(r8)
 820fb78:	40c00015 	stw	r3,0(r8)
 820fb7c:	d8801c15 	stw	r2,112(sp)
 820fb80:	d9801b15 	stw	r6,108(sp)
 820fb84:	00c001c4 	movi	r3,7
 820fb88:	19827616 	blt	r3,r6,8210564 <___vfiprintf_internal_r+0xfbc>
 820fb8c:	4cf9c83a 	sub	fp,r9,r19
 820fb90:	42000204 	addi	r8,r8,8
 820fb94:	31000044 	addi	r4,r6,1
 820fb98:	300b883a 	mov	r5,r6
 820fb9c:	07018516 	blt	zero,fp,82101b4 <___vfiprintf_internal_r+0xc0c>
 820fba0:	9885883a 	add	r2,r19,r2
 820fba4:	45400015 	stw	r21,0(r8)
 820fba8:	44c00115 	stw	r19,4(r8)
 820fbac:	d8801c15 	stw	r2,112(sp)
 820fbb0:	d9001b15 	stw	r4,108(sp)
 820fbb4:	00c001c4 	movi	r3,7
 820fbb8:	1901dd0e 	bge	r3,r4,8210330 <___vfiprintf_internal_r+0xd88>
 820fbbc:	1002401e 	bne	r2,zero,82104c0 <___vfiprintf_internal_r+0xf18>
 820fbc0:	d8001b15 	stw	zero,108(sp)
 820fbc4:	a2c0010c 	andi	r11,r20,4
 820fbc8:	58000226 	beq	r11,zero,820fbd4 <___vfiprintf_internal_r+0x62c>
 820fbcc:	8ca7c83a 	sub	r19,r17,r18
 820fbd0:	04c2f216 	blt	zero,r19,821079c <___vfiprintf_internal_r+0x11f4>
 820fbd4:	8c80010e 	bge	r17,r18,820fbdc <___vfiprintf_internal_r+0x634>
 820fbd8:	9023883a 	mov	r17,r18
 820fbdc:	da802317 	ldw	r10,140(sp)
 820fbe0:	5455883a 	add	r10,r10,r17
 820fbe4:	da802315 	stw	r10,140(sp)
 820fbe8:	d8001b15 	stw	zero,108(sp)
 820fbec:	d811883a 	mov	r8,sp
 820fbf0:	003ea206 	br	820f67c <___vfiprintf_internal_r+0xd4>
 820fbf4:	a5000814 	ori	r20,r20,32
 820fbf8:	80c00007 	ldb	r3,0(r16)
 820fbfc:	003ec906 	br	820f724 <___vfiprintf_internal_r+0x17c>
 820fc00:	80c00007 	ldb	r3,0(r16)
 820fc04:	1b030926 	beq	r3,r12,821082c <___vfiprintf_internal_r+0x1284>
 820fc08:	a5000414 	ori	r20,r20,16
 820fc0c:	003ec506 	br	820f724 <___vfiprintf_internal_r+0x17c>
 820fc10:	21003fcc 	andi	r4,r4,255
 820fc14:	20035e1e 	bne	r4,zero,8210990 <___vfiprintf_internal_r+0x13e8>
 820fc18:	a080080c 	andi	r2,r20,32
 820fc1c:	1002a526 	beq	r2,zero,82106b4 <___vfiprintf_internal_r+0x110c>
 820fc20:	da802217 	ldw	r10,136(sp)
 820fc24:	50800017 	ldw	r2,0(r10)
 820fc28:	da802317 	ldw	r10,140(sp)
 820fc2c:	5007d7fa 	srai	r3,r10,31
 820fc30:	da802217 	ldw	r10,136(sp)
 820fc34:	10c00115 	stw	r3,4(r2)
 820fc38:	52800104 	addi	r10,r10,4
 820fc3c:	da802215 	stw	r10,136(sp)
 820fc40:	da802317 	ldw	r10,140(sp)
 820fc44:	12800015 	stw	r10,0(r2)
 820fc48:	003e8c06 	br	820f67c <___vfiprintf_internal_r+0xd4>
 820fc4c:	21003fcc 	andi	r4,r4,255
 820fc50:	2003511e 	bne	r4,zero,8210998 <___vfiprintf_internal_r+0x13f0>
 820fc54:	a080080c 	andi	r2,r20,32
 820fc58:	1000a126 	beq	r2,zero,820fee0 <___vfiprintf_internal_r+0x938>
 820fc5c:	da802217 	ldw	r10,136(sp)
 820fc60:	d8001d85 	stb	zero,118(sp)
 820fc64:	50800204 	addi	r2,r10,8
 820fc68:	54800017 	ldw	r18,0(r10)
 820fc6c:	54c00117 	ldw	r19,4(r10)
 820fc70:	4802b416 	blt	r9,zero,8210744 <___vfiprintf_internal_r+0x119c>
 820fc74:	013fdfc4 	movi	r4,-129
 820fc78:	94c6b03a 	or	r3,r18,r19
 820fc7c:	d8802215 	stw	r2,136(sp)
 820fc80:	a128703a 	and	r20,r20,r4
 820fc84:	1800a226 	beq	r3,zero,820ff10 <___vfiprintf_internal_r+0x968>
 820fc88:	0039883a 	mov	fp,zero
 820fc8c:	dd401a04 	addi	r21,sp,104
 820fc90:	9006d0fa 	srli	r3,r18,3
 820fc94:	9808977a 	slli	r4,r19,29
 820fc98:	9826d0fa 	srli	r19,r19,3
 820fc9c:	948001cc 	andi	r18,r18,7
 820fca0:	90800c04 	addi	r2,r18,48
 820fca4:	ad7fffc4 	addi	r21,r21,-1
 820fca8:	20e4b03a 	or	r18,r4,r3
 820fcac:	a8800005 	stb	r2,0(r21)
 820fcb0:	94c6b03a 	or	r3,r18,r19
 820fcb4:	183ff61e 	bne	r3,zero,820fc90 <___vfiprintf_internal_r+0x6e8>
 820fcb8:	a0c0004c 	andi	r3,r20,1
 820fcbc:	18005926 	beq	r3,zero,820fe24 <___vfiprintf_internal_r+0x87c>
 820fcc0:	10803fcc 	andi	r2,r2,255
 820fcc4:	1080201c 	xori	r2,r2,128
 820fcc8:	10bfe004 	addi	r2,r2,-128
 820fccc:	00c00c04 	movi	r3,48
 820fcd0:	10c05426 	beq	r2,r3,820fe24 <___vfiprintf_internal_r+0x87c>
 820fcd4:	da801e17 	ldw	r10,120(sp)
 820fcd8:	a8bfffc4 	addi	r2,r21,-1
 820fcdc:	a8ffffc5 	stb	r3,-1(r21)
 820fce0:	50a7c83a 	sub	r19,r10,r2
 820fce4:	102b883a 	mov	r21,r2
 820fce8:	003f2f06 	br	820f9a8 <___vfiprintf_internal_r+0x400>
 820fcec:	21003fcc 	andi	r4,r4,255
 820fcf0:	2003421e 	bne	r4,zero,82109fc <___vfiprintf_internal_r+0x1454>
 820fcf4:	00820974 	movhi	r2,2085
 820fcf8:	10b6c304 	addi	r2,r2,-9460
 820fcfc:	d8802615 	stw	r2,152(sp)
 820fd00:	a080080c 	andi	r2,r20,32
 820fd04:	1000aa26 	beq	r2,zero,820ffb0 <___vfiprintf_internal_r+0xa08>
 820fd08:	da802217 	ldw	r10,136(sp)
 820fd0c:	54800017 	ldw	r18,0(r10)
 820fd10:	54c00117 	ldw	r19,4(r10)
 820fd14:	52800204 	addi	r10,r10,8
 820fd18:	da802215 	stw	r10,136(sp)
 820fd1c:	a080004c 	andi	r2,r20,1
 820fd20:	1001d226 	beq	r2,zero,821046c <___vfiprintf_internal_r+0xec4>
 820fd24:	94c4b03a 	or	r2,r18,r19
 820fd28:	1002351e 	bne	r2,zero,8210600 <___vfiprintf_internal_r+0x1058>
 820fd2c:	d8001d85 	stb	zero,118(sp)
 820fd30:	48022216 	blt	r9,zero,82105bc <___vfiprintf_internal_r+0x1014>
 820fd34:	00bfdfc4 	movi	r2,-129
 820fd38:	a0a8703a 	and	r20,r20,r2
 820fd3c:	003f1506 	br	820f994 <___vfiprintf_internal_r+0x3ec>
 820fd40:	da802217 	ldw	r10,136(sp)
 820fd44:	04800044 	movi	r18,1
 820fd48:	d8001d85 	stb	zero,118(sp)
 820fd4c:	50800017 	ldw	r2,0(r10)
 820fd50:	52800104 	addi	r10,r10,4
 820fd54:	da802215 	stw	r10,136(sp)
 820fd58:	d8801005 	stb	r2,64(sp)
 820fd5c:	9027883a 	mov	r19,r18
 820fd60:	dd401004 	addi	r21,sp,64
 820fd64:	0013883a 	mov	r9,zero
 820fd68:	003f1706 	br	820f9c8 <___vfiprintf_internal_r+0x420>
 820fd6c:	21003fcc 	andi	r4,r4,255
 820fd70:	2003201e 	bne	r4,zero,82109f4 <___vfiprintf_internal_r+0x144c>
 820fd74:	a080080c 	andi	r2,r20,32
 820fd78:	10004b26 	beq	r2,zero,820fea8 <___vfiprintf_internal_r+0x900>
 820fd7c:	da802217 	ldw	r10,136(sp)
 820fd80:	50800117 	ldw	r2,4(r10)
 820fd84:	54800017 	ldw	r18,0(r10)
 820fd88:	52800204 	addi	r10,r10,8
 820fd8c:	da802215 	stw	r10,136(sp)
 820fd90:	1027883a 	mov	r19,r2
 820fd94:	10022c16 	blt	r2,zero,8210648 <___vfiprintf_internal_r+0x10a0>
 820fd98:	df001d83 	ldbu	fp,118(sp)
 820fd9c:	48007216 	blt	r9,zero,820ff68 <___vfiprintf_internal_r+0x9c0>
 820fda0:	00ffdfc4 	movi	r3,-129
 820fda4:	94c4b03a 	or	r2,r18,r19
 820fda8:	a0e8703a 	and	r20,r20,r3
 820fdac:	1000cc26 	beq	r2,zero,82100e0 <___vfiprintf_internal_r+0xb38>
 820fdb0:	98021026 	beq	r19,zero,82105f4 <___vfiprintf_internal_r+0x104c>
 820fdb4:	dc402415 	stw	r17,144(sp)
 820fdb8:	dc002515 	stw	r16,148(sp)
 820fdbc:	9823883a 	mov	r17,r19
 820fdc0:	9021883a 	mov	r16,r18
 820fdc4:	dd401a04 	addi	r21,sp,104
 820fdc8:	4825883a 	mov	r18,r9
 820fdcc:	4027883a 	mov	r19,r8
 820fdd0:	8009883a 	mov	r4,r16
 820fdd4:	880b883a 	mov	r5,r17
 820fdd8:	01800284 	movi	r6,10
 820fddc:	000f883a 	mov	r7,zero
 820fde0:	82118300 	call	8211830 <__umoddi3>
 820fde4:	10800c04 	addi	r2,r2,48
 820fde8:	ad7fffc4 	addi	r21,r21,-1
 820fdec:	8009883a 	mov	r4,r16
 820fdf0:	880b883a 	mov	r5,r17
 820fdf4:	a8800005 	stb	r2,0(r21)
 820fdf8:	01800284 	movi	r6,10
 820fdfc:	000f883a 	mov	r7,zero
 820fe00:	82112b80 	call	82112b8 <__udivdi3>
 820fe04:	1021883a 	mov	r16,r2
 820fe08:	10c4b03a 	or	r2,r2,r3
 820fe0c:	1823883a 	mov	r17,r3
 820fe10:	103fef1e 	bne	r2,zero,820fdd0 <___vfiprintf_internal_r+0x828>
 820fe14:	dc402417 	ldw	r17,144(sp)
 820fe18:	dc002517 	ldw	r16,148(sp)
 820fe1c:	9013883a 	mov	r9,r18
 820fe20:	9811883a 	mov	r8,r19
 820fe24:	da801e17 	ldw	r10,120(sp)
 820fe28:	5567c83a 	sub	r19,r10,r21
 820fe2c:	003ede06 	br	820f9a8 <___vfiprintf_internal_r+0x400>
 820fe30:	38803fcc 	andi	r2,r7,255
 820fe34:	1080201c 	xori	r2,r2,128
 820fe38:	10bfe004 	addi	r2,r2,-128
 820fe3c:	1002371e 	bne	r2,zero,821071c <___vfiprintf_internal_r+0x1174>
 820fe40:	01000044 	movi	r4,1
 820fe44:	01c00804 	movi	r7,32
 820fe48:	80c00007 	ldb	r3,0(r16)
 820fe4c:	003e3506 	br	820f724 <___vfiprintf_internal_r+0x17c>
 820fe50:	a5000054 	ori	r20,r20,1
 820fe54:	80c00007 	ldb	r3,0(r16)
 820fe58:	003e3206 	br	820f724 <___vfiprintf_internal_r+0x17c>
 820fe5c:	a5002014 	ori	r20,r20,128
 820fe60:	80c00007 	ldb	r3,0(r16)
 820fe64:	003e2f06 	br	820f724 <___vfiprintf_internal_r+0x17c>
 820fe68:	8015883a 	mov	r10,r16
 820fe6c:	0023883a 	mov	r17,zero
 820fe70:	18bff404 	addi	r2,r3,-48
 820fe74:	50c00007 	ldb	r3,0(r10)
 820fe78:	8c4002a4 	muli	r17,r17,10
 820fe7c:	84000044 	addi	r16,r16,1
 820fe80:	8015883a 	mov	r10,r16
 820fe84:	1463883a 	add	r17,r2,r17
 820fe88:	18bff404 	addi	r2,r3,-48
 820fe8c:	30bff92e 	bgeu	r6,r2,820fe74 <___vfiprintf_internal_r+0x8cc>
 820fe90:	003e2506 	br	820f728 <___vfiprintf_internal_r+0x180>
 820fe94:	21003fcc 	andi	r4,r4,255
 820fe98:	2002d41e 	bne	r4,zero,82109ec <___vfiprintf_internal_r+0x1444>
 820fe9c:	a5000414 	ori	r20,r20,16
 820fea0:	a080080c 	andi	r2,r20,32
 820fea4:	103fb51e 	bne	r2,zero,820fd7c <___vfiprintf_internal_r+0x7d4>
 820fea8:	a080040c 	andi	r2,r20,16
 820feac:	1001f826 	beq	r2,zero,8210690 <___vfiprintf_internal_r+0x10e8>
 820feb0:	da802217 	ldw	r10,136(sp)
 820feb4:	54800017 	ldw	r18,0(r10)
 820feb8:	52800104 	addi	r10,r10,4
 820febc:	da802215 	stw	r10,136(sp)
 820fec0:	9027d7fa 	srai	r19,r18,31
 820fec4:	9805883a 	mov	r2,r19
 820fec8:	003fb206 	br	820fd94 <___vfiprintf_internal_r+0x7ec>
 820fecc:	21003fcc 	andi	r4,r4,255
 820fed0:	2002c41e 	bne	r4,zero,82109e4 <___vfiprintf_internal_r+0x143c>
 820fed4:	a5000414 	ori	r20,r20,16
 820fed8:	a080080c 	andi	r2,r20,32
 820fedc:	103f5f1e 	bne	r2,zero,820fc5c <___vfiprintf_internal_r+0x6b4>
 820fee0:	a080040c 	andi	r2,r20,16
 820fee4:	10020f26 	beq	r2,zero,8210724 <___vfiprintf_internal_r+0x117c>
 820fee8:	da802217 	ldw	r10,136(sp)
 820feec:	d8001d85 	stb	zero,118(sp)
 820fef0:	0027883a 	mov	r19,zero
 820fef4:	50800104 	addi	r2,r10,4
 820fef8:	54800017 	ldw	r18,0(r10)
 820fefc:	48021116 	blt	r9,zero,8210744 <___vfiprintf_internal_r+0x119c>
 820ff00:	00ffdfc4 	movi	r3,-129
 820ff04:	d8802215 	stw	r2,136(sp)
 820ff08:	a0e8703a 	and	r20,r20,r3
 820ff0c:	903f5e1e 	bne	r18,zero,820fc88 <___vfiprintf_internal_r+0x6e0>
 820ff10:	0039883a 	mov	fp,zero
 820ff14:	4802a626 	beq	r9,zero,82109b0 <___vfiprintf_internal_r+0x1408>
 820ff18:	0025883a 	mov	r18,zero
 820ff1c:	0027883a 	mov	r19,zero
 820ff20:	003f5a06 	br	820fc8c <___vfiprintf_internal_r+0x6e4>
 820ff24:	21003fcc 	andi	r4,r4,255
 820ff28:	20029f1e 	bne	r4,zero,82109a8 <___vfiprintf_internal_r+0x1400>
 820ff2c:	a5000414 	ori	r20,r20,16
 820ff30:	a080080c 	andi	r2,r20,32
 820ff34:	10005e1e 	bne	r2,zero,82100b0 <___vfiprintf_internal_r+0xb08>
 820ff38:	a080040c 	andi	r2,r20,16
 820ff3c:	1001a21e 	bne	r2,zero,82105c8 <___vfiprintf_internal_r+0x1020>
 820ff40:	a080100c 	andi	r2,r20,64
 820ff44:	d8001d85 	stb	zero,118(sp)
 820ff48:	da802217 	ldw	r10,136(sp)
 820ff4c:	1002231e 	bne	r2,zero,82107dc <___vfiprintf_internal_r+0x1234>
 820ff50:	50800104 	addi	r2,r10,4
 820ff54:	54800017 	ldw	r18,0(r10)
 820ff58:	0027883a 	mov	r19,zero
 820ff5c:	4801a00e 	bge	r9,zero,82105e0 <___vfiprintf_internal_r+0x1038>
 820ff60:	d8802215 	stw	r2,136(sp)
 820ff64:	0039883a 	mov	fp,zero
 820ff68:	94c4b03a 	or	r2,r18,r19
 820ff6c:	103f901e 	bne	r2,zero,820fdb0 <___vfiprintf_internal_r+0x808>
 820ff70:	00800044 	movi	r2,1
 820ff74:	10803fcc 	andi	r2,r2,255
 820ff78:	00c00044 	movi	r3,1
 820ff7c:	10c05926 	beq	r2,r3,82100e4 <___vfiprintf_internal_r+0xb3c>
 820ff80:	00c00084 	movi	r3,2
 820ff84:	10ffe41e 	bne	r2,r3,820ff18 <___vfiprintf_internal_r+0x970>
 820ff88:	0025883a 	mov	r18,zero
 820ff8c:	0027883a 	mov	r19,zero
 820ff90:	00013d06 	br	8210488 <___vfiprintf_internal_r+0xee0>
 820ff94:	21003fcc 	andi	r4,r4,255
 820ff98:	2002811e 	bne	r4,zero,82109a0 <___vfiprintf_internal_r+0x13f8>
 820ff9c:	00820974 	movhi	r2,2085
 820ffa0:	10b6be04 	addi	r2,r2,-9480
 820ffa4:	d8802615 	stw	r2,152(sp)
 820ffa8:	a080080c 	andi	r2,r20,32
 820ffac:	103f561e 	bne	r2,zero,820fd08 <___vfiprintf_internal_r+0x760>
 820ffb0:	a080040c 	andi	r2,r20,16
 820ffb4:	1001d126 	beq	r2,zero,82106fc <___vfiprintf_internal_r+0x1154>
 820ffb8:	da802217 	ldw	r10,136(sp)
 820ffbc:	0027883a 	mov	r19,zero
 820ffc0:	54800017 	ldw	r18,0(r10)
 820ffc4:	52800104 	addi	r10,r10,4
 820ffc8:	da802215 	stw	r10,136(sp)
 820ffcc:	003f5306 	br	820fd1c <___vfiprintf_internal_r+0x774>
 820ffd0:	da802217 	ldw	r10,136(sp)
 820ffd4:	d8001d85 	stb	zero,118(sp)
 820ffd8:	55400017 	ldw	r21,0(r10)
 820ffdc:	50c00104 	addi	r3,r10,4
 820ffe0:	a8024226 	beq	r21,zero,82108ec <___vfiprintf_internal_r+0x1344>
 820ffe4:	48021816 	blt	r9,zero,8210848 <___vfiprintf_internal_r+0x12a0>
 820ffe8:	480d883a 	mov	r6,r9
 820ffec:	000b883a 	mov	r5,zero
 820fff0:	a809883a 	mov	r4,r21
 820fff4:	d8c02a15 	stw	r3,168(sp)
 820fff8:	da002b15 	stw	r8,172(sp)
 820fffc:	da402c15 	stw	r9,176(sp)
 8210000:	820c4f80 	call	820c4f8 <memchr>
 8210004:	d8c02a17 	ldw	r3,168(sp)
 8210008:	da002b17 	ldw	r8,172(sp)
 821000c:	da402c17 	ldw	r9,176(sp)
 8210010:	10024826 	beq	r2,zero,8210934 <___vfiprintf_internal_r+0x138c>
 8210014:	1567c83a 	sub	r19,r2,r21
 8210018:	df001d83 	ldbu	fp,118(sp)
 821001c:	d8c02215 	stw	r3,136(sp)
 8210020:	0013883a 	mov	r9,zero
 8210024:	003e6006 	br	820f9a8 <___vfiprintf_internal_r+0x400>
 8210028:	21003fcc 	andi	r4,r4,255
 821002c:	203fc026 	beq	r4,zero,820ff30 <___vfiprintf_internal_r+0x988>
 8210030:	d9c01d85 	stb	r7,118(sp)
 8210034:	003fbe06 	br	820ff30 <___vfiprintf_internal_r+0x988>
 8210038:	da802217 	ldw	r10,136(sp)
 821003c:	54400017 	ldw	r17,0(r10)
 8210040:	50800104 	addi	r2,r10,4
 8210044:	883e3b16 	blt	r17,zero,820f934 <___vfiprintf_internal_r+0x38c>
 8210048:	d8802215 	stw	r2,136(sp)
 821004c:	80c00007 	ldb	r3,0(r16)
 8210050:	003db406 	br	820f724 <___vfiprintf_internal_r+0x17c>
 8210054:	01000044 	movi	r4,1
 8210058:	01c00ac4 	movi	r7,43
 821005c:	80c00007 	ldb	r3,0(r16)
 8210060:	003db006 	br	820f724 <___vfiprintf_internal_r+0x17c>
 8210064:	80c00007 	ldb	r3,0(r16)
 8210068:	82800044 	addi	r10,r16,1
 821006c:	1b423c26 	beq	r3,r13,8210960 <___vfiprintf_internal_r+0x13b8>
 8210070:	18bff404 	addi	r2,r3,-48
 8210074:	0013883a 	mov	r9,zero
 8210078:	30822b36 	bltu	r6,r2,8210928 <___vfiprintf_internal_r+0x1380>
 821007c:	50c00007 	ldb	r3,0(r10)
 8210080:	4a4002a4 	muli	r9,r9,10
 8210084:	54000044 	addi	r16,r10,1
 8210088:	8015883a 	mov	r10,r16
 821008c:	4893883a 	add	r9,r9,r2
 8210090:	18bff404 	addi	r2,r3,-48
 8210094:	30bff92e 	bgeu	r6,r2,821007c <___vfiprintf_internal_r+0xad4>
 8210098:	483da30e 	bge	r9,zero,820f728 <___vfiprintf_internal_r+0x180>
 821009c:	027fffc4 	movi	r9,-1
 82100a0:	003da106 	br	820f728 <___vfiprintf_internal_r+0x180>
 82100a4:	a5001014 	ori	r20,r20,64
 82100a8:	80c00007 	ldb	r3,0(r16)
 82100ac:	003d9d06 	br	820f724 <___vfiprintf_internal_r+0x17c>
 82100b0:	da802217 	ldw	r10,136(sp)
 82100b4:	d8001d85 	stb	zero,118(sp)
 82100b8:	50c00204 	addi	r3,r10,8
 82100bc:	54800017 	ldw	r18,0(r10)
 82100c0:	54c00117 	ldw	r19,4(r10)
 82100c4:	4801ca16 	blt	r9,zero,82107f0 <___vfiprintf_internal_r+0x1248>
 82100c8:	013fdfc4 	movi	r4,-129
 82100cc:	94c4b03a 	or	r2,r18,r19
 82100d0:	d8c02215 	stw	r3,136(sp)
 82100d4:	a128703a 	and	r20,r20,r4
 82100d8:	0039883a 	mov	fp,zero
 82100dc:	103f341e 	bne	r2,zero,820fdb0 <___vfiprintf_internal_r+0x808>
 82100e0:	483e2e26 	beq	r9,zero,820f99c <___vfiprintf_internal_r+0x3f4>
 82100e4:	0025883a 	mov	r18,zero
 82100e8:	94800c04 	addi	r18,r18,48
 82100ec:	dc8019c5 	stb	r18,103(sp)
 82100f0:	dcc02717 	ldw	r19,156(sp)
 82100f4:	dd4019c4 	addi	r21,sp,103
 82100f8:	003e2b06 	br	820f9a8 <___vfiprintf_internal_r+0x400>
 82100fc:	21003fcc 	andi	r4,r4,255
 8210100:	2002361e 	bne	r4,zero,82109dc <___vfiprintf_internal_r+0x1434>
 8210104:	1801c126 	beq	r3,zero,821080c <___vfiprintf_internal_r+0x1264>
 8210108:	04800044 	movi	r18,1
 821010c:	d8c01005 	stb	r3,64(sp)
 8210110:	d8001d85 	stb	zero,118(sp)
 8210114:	9027883a 	mov	r19,r18
 8210118:	dd401004 	addi	r21,sp,64
 821011c:	003f1106 	br	820fd64 <___vfiprintf_internal_r+0x7bc>
 8210120:	d9402117 	ldw	r5,132(sp)
 8210124:	d9002017 	ldw	r4,128(sp)
 8210128:	d9801a04 	addi	r6,sp,104
 821012c:	d9c02b15 	stw	r7,172(sp)
 8210130:	dbc02a15 	stw	r15,168(sp)
 8210134:	820f4940 	call	820f494 <__sprint_r.part.0>
 8210138:	d9c02b17 	ldw	r7,172(sp)
 821013c:	dbc02a17 	ldw	r15,168(sp)
 8210140:	10006d1e 	bne	r2,zero,82102f8 <___vfiprintf_internal_r+0xd50>
 8210144:	d9801b17 	ldw	r6,108(sp)
 8210148:	d8801c17 	ldw	r2,112(sp)
 821014c:	d811883a 	mov	r8,sp
 8210150:	31400044 	addi	r5,r6,1
 8210154:	003e3306 	br	820fa24 <___vfiprintf_internal_r+0x47c>
 8210158:	d9401b17 	ldw	r5,108(sp)
 821015c:	d8801c17 	ldw	r2,112(sp)
 8210160:	29000044 	addi	r4,r5,1
 8210164:	d8c01d87 	ldb	r3,118(sp)
 8210168:	183e4d26 	beq	r3,zero,820faa0 <___vfiprintf_internal_r+0x4f8>
 821016c:	00c00044 	movi	r3,1
 8210170:	d9401d84 	addi	r5,sp,118
 8210174:	10c5883a 	add	r2,r2,r3
 8210178:	41400015 	stw	r5,0(r8)
 821017c:	40c00115 	stw	r3,4(r8)
 8210180:	d8801c15 	stw	r2,112(sp)
 8210184:	d9001b15 	stw	r4,108(sp)
 8210188:	014001c4 	movi	r5,7
 821018c:	2900a90e 	bge	r5,r4,8210434 <___vfiprintf_internal_r+0xe8c>
 8210190:	1000da1e 	bne	r2,zero,82104fc <___vfiprintf_internal_r+0xf54>
 8210194:	7000ab1e 	bne	r14,zero,8210444 <___vfiprintf_internal_r+0xe9c>
 8210198:	000b883a 	mov	r5,zero
 821019c:	1809883a 	mov	r4,r3
 82101a0:	d811883a 	mov	r8,sp
 82101a4:	00c02004 	movi	r3,128
 82101a8:	e0fe4d26 	beq	fp,r3,820fae0 <___vfiprintf_internal_r+0x538>
 82101ac:	4cf9c83a 	sub	fp,r9,r19
 82101b0:	073e7b0e 	bge	zero,fp,820fba0 <___vfiprintf_internal_r+0x5f8>
 82101b4:	01c00404 	movi	r7,16
 82101b8:	3f01900e 	bge	r7,fp,82107fc <___vfiprintf_internal_r+0x1254>
 82101bc:	00c20974 	movhi	r3,2085
 82101c0:	18f73304 	addi	r3,r3,-9012
 82101c4:	d8c02415 	stw	r3,144(sp)
 82101c8:	034001c4 	movi	r13,7
 82101cc:	00000506 	br	82101e4 <___vfiprintf_internal_r+0xc3c>
 82101d0:	29000084 	addi	r4,r5,2
 82101d4:	42000204 	addi	r8,r8,8
 82101d8:	180b883a 	mov	r5,r3
 82101dc:	e73ffc04 	addi	fp,fp,-16
 82101e0:	3f000d0e 	bge	r7,fp,8210218 <___vfiprintf_internal_r+0xc70>
 82101e4:	10800404 	addi	r2,r2,16
 82101e8:	28c00044 	addi	r3,r5,1
 82101ec:	45c00015 	stw	r23,0(r8)
 82101f0:	41c00115 	stw	r7,4(r8)
 82101f4:	d8801c15 	stw	r2,112(sp)
 82101f8:	d8c01b15 	stw	r3,108(sp)
 82101fc:	68fff40e 	bge	r13,r3,82101d0 <___vfiprintf_internal_r+0xc28>
 8210200:	1000101e 	bne	r2,zero,8210244 <___vfiprintf_internal_r+0xc9c>
 8210204:	e73ffc04 	addi	fp,fp,-16
 8210208:	01000044 	movi	r4,1
 821020c:	000b883a 	mov	r5,zero
 8210210:	d811883a 	mov	r8,sp
 8210214:	3f3ff316 	blt	r7,fp,82101e4 <___vfiprintf_internal_r+0xc3c>
 8210218:	da802417 	ldw	r10,144(sp)
 821021c:	1705883a 	add	r2,r2,fp
 8210220:	47000115 	stw	fp,4(r8)
 8210224:	42800015 	stw	r10,0(r8)
 8210228:	d8801c15 	stw	r2,112(sp)
 821022c:	d9001b15 	stw	r4,108(sp)
 8210230:	00c001c4 	movi	r3,7
 8210234:	19003616 	blt	r3,r4,8210310 <___vfiprintf_internal_r+0xd68>
 8210238:	42000204 	addi	r8,r8,8
 821023c:	21000044 	addi	r4,r4,1
 8210240:	003e5706 	br	820fba0 <___vfiprintf_internal_r+0x5f8>
 8210244:	d9402117 	ldw	r5,132(sp)
 8210248:	d9002017 	ldw	r4,128(sp)
 821024c:	d9801a04 	addi	r6,sp,104
 8210250:	d9c02b15 	stw	r7,172(sp)
 8210254:	db402a15 	stw	r13,168(sp)
 8210258:	820f4940 	call	820f494 <__sprint_r.part.0>
 821025c:	d9c02b17 	ldw	r7,172(sp)
 8210260:	db402a17 	ldw	r13,168(sp)
 8210264:	1000241e 	bne	r2,zero,82102f8 <___vfiprintf_internal_r+0xd50>
 8210268:	d9401b17 	ldw	r5,108(sp)
 821026c:	d8801c17 	ldw	r2,112(sp)
 8210270:	d811883a 	mov	r8,sp
 8210274:	29000044 	addi	r4,r5,1
 8210278:	003fd806 	br	82101dc <___vfiprintf_internal_r+0xc34>
 821027c:	d9401b17 	ldw	r5,108(sp)
 8210280:	00c20974 	movhi	r3,2085
 8210284:	18f73704 	addi	r3,r3,-8996
 8210288:	d8c02415 	stw	r3,144(sp)
 821028c:	29400044 	addi	r5,r5,1
 8210290:	d8c02417 	ldw	r3,144(sp)
 8210294:	14c5883a 	add	r2,r2,r19
 8210298:	44c00115 	stw	r19,4(r8)
 821029c:	40c00015 	stw	r3,0(r8)
 82102a0:	d8801c15 	stw	r2,112(sp)
 82102a4:	d9401b15 	stw	r5,108(sp)
 82102a8:	00c001c4 	movi	r3,7
 82102ac:	1940070e 	bge	r3,r5,82102cc <___vfiprintf_internal_r+0xd24>
 82102b0:	103e4826 	beq	r2,zero,820fbd4 <___vfiprintf_internal_r+0x62c>
 82102b4:	d9402117 	ldw	r5,132(sp)
 82102b8:	d9002017 	ldw	r4,128(sp)
 82102bc:	d9801a04 	addi	r6,sp,104
 82102c0:	820f4940 	call	820f494 <__sprint_r.part.0>
 82102c4:	10000c1e 	bne	r2,zero,82102f8 <___vfiprintf_internal_r+0xd50>
 82102c8:	d8801c17 	ldw	r2,112(sp)
 82102cc:	8c80010e 	bge	r17,r18,82102d4 <___vfiprintf_internal_r+0xd2c>
 82102d0:	9023883a 	mov	r17,r18
 82102d4:	da802317 	ldw	r10,140(sp)
 82102d8:	5455883a 	add	r10,r10,r17
 82102dc:	da802315 	stw	r10,140(sp)
 82102e0:	103e4126 	beq	r2,zero,820fbe8 <___vfiprintf_internal_r+0x640>
 82102e4:	d9402117 	ldw	r5,132(sp)
 82102e8:	d9002017 	ldw	r4,128(sp)
 82102ec:	d9801a04 	addi	r6,sp,104
 82102f0:	820f4940 	call	820f494 <__sprint_r.part.0>
 82102f4:	103e3c26 	beq	r2,zero,820fbe8 <___vfiprintf_internal_r+0x640>
 82102f8:	dd002117 	ldw	r20,132(sp)
 82102fc:	a080030b 	ldhu	r2,12(r20)
 8210300:	1080100c 	andi	r2,r2,64
 8210304:	1001231e 	bne	r2,zero,8210794 <___vfiprintf_internal_r+0x11ec>
 8210308:	d8802317 	ldw	r2,140(sp)
 821030c:	003d7b06 	br	820f8fc <___vfiprintf_internal_r+0x354>
 8210310:	1000991e 	bne	r2,zero,8210578 <___vfiprintf_internal_r+0xfd0>
 8210314:	00c00044 	movi	r3,1
 8210318:	9805883a 	mov	r2,r19
 821031c:	dd400015 	stw	r21,0(sp)
 8210320:	dcc00115 	stw	r19,4(sp)
 8210324:	dcc01c15 	stw	r19,112(sp)
 8210328:	d8c01b15 	stw	r3,108(sp)
 821032c:	d811883a 	mov	r8,sp
 8210330:	42000204 	addi	r8,r8,8
 8210334:	a2c0010c 	andi	r11,r20,4
 8210338:	583fe426 	beq	r11,zero,82102cc <___vfiprintf_internal_r+0xd24>
 821033c:	8ca7c83a 	sub	r19,r17,r18
 8210340:	04ffe20e 	bge	zero,r19,82102cc <___vfiprintf_internal_r+0xd24>
 8210344:	01c00404 	movi	r7,16
 8210348:	3cffcc0e 	bge	r7,r19,821027c <___vfiprintf_internal_r+0xcd4>
 821034c:	02820974 	movhi	r10,2085
 8210350:	52b73704 	addi	r10,r10,-8996
 8210354:	d9001b17 	ldw	r4,108(sp)
 8210358:	da802415 	stw	r10,144(sp)
 821035c:	382b883a 	mov	r21,r7
 8210360:	050001c4 	movi	r20,7
 8210364:	df002017 	ldw	fp,128(sp)
 8210368:	00000506 	br	8210380 <___vfiprintf_internal_r+0xdd8>
 821036c:	21400084 	addi	r5,r4,2
 8210370:	42000204 	addi	r8,r8,8
 8210374:	1809883a 	mov	r4,r3
 8210378:	9cfffc04 	addi	r19,r19,-16
 821037c:	acffc40e 	bge	r21,r19,8210290 <___vfiprintf_internal_r+0xce8>
 8210380:	10800404 	addi	r2,r2,16
 8210384:	20c00044 	addi	r3,r4,1
 8210388:	45800015 	stw	r22,0(r8)
 821038c:	45400115 	stw	r21,4(r8)
 8210390:	d8801c15 	stw	r2,112(sp)
 8210394:	d8c01b15 	stw	r3,108(sp)
 8210398:	a0fff40e 	bge	r20,r3,821036c <___vfiprintf_internal_r+0xdc4>
 821039c:	1000041e 	bne	r2,zero,82103b0 <___vfiprintf_internal_r+0xe08>
 82103a0:	01400044 	movi	r5,1
 82103a4:	0009883a 	mov	r4,zero
 82103a8:	d811883a 	mov	r8,sp
 82103ac:	003ff206 	br	8210378 <___vfiprintf_internal_r+0xdd0>
 82103b0:	d9402117 	ldw	r5,132(sp)
 82103b4:	d9801a04 	addi	r6,sp,104
 82103b8:	e009883a 	mov	r4,fp
 82103bc:	820f4940 	call	820f494 <__sprint_r.part.0>
 82103c0:	103fcd1e 	bne	r2,zero,82102f8 <___vfiprintf_internal_r+0xd50>
 82103c4:	d9001b17 	ldw	r4,108(sp)
 82103c8:	d8801c17 	ldw	r2,112(sp)
 82103cc:	d811883a 	mov	r8,sp
 82103d0:	21400044 	addi	r5,r4,1
 82103d4:	003fe806 	br	8210378 <___vfiprintf_internal_r+0xdd0>
 82103d8:	d9402117 	ldw	r5,132(sp)
 82103dc:	d9002017 	ldw	r4,128(sp)
 82103e0:	d9801a04 	addi	r6,sp,104
 82103e4:	d9c02b15 	stw	r7,172(sp)
 82103e8:	db402a15 	stw	r13,168(sp)
 82103ec:	820f4940 	call	820f494 <__sprint_r.part.0>
 82103f0:	d9c02b17 	ldw	r7,172(sp)
 82103f4:	db402a17 	ldw	r13,168(sp)
 82103f8:	103fbf1e 	bne	r2,zero,82102f8 <___vfiprintf_internal_r+0xd50>
 82103fc:	d9401b17 	ldw	r5,108(sp)
 8210400:	d8801c17 	ldw	r2,112(sp)
 8210404:	d811883a 	mov	r8,sp
 8210408:	29800044 	addi	r6,r5,1
 821040c:	003dc406 	br	820fb20 <___vfiprintf_internal_r+0x578>
 8210410:	1000d21e 	bne	r2,zero,821075c <___vfiprintf_internal_r+0x11b4>
 8210414:	d8c01d87 	ldb	r3,118(sp)
 8210418:	18009526 	beq	r3,zero,8210670 <___vfiprintf_internal_r+0x10c8>
 821041c:	00800044 	movi	r2,1
 8210420:	d8c01d84 	addi	r3,sp,118
 8210424:	1009883a 	mov	r4,r2
 8210428:	d8c00015 	stw	r3,0(sp)
 821042c:	d8800115 	stw	r2,4(sp)
 8210430:	d811883a 	mov	r8,sp
 8210434:	200b883a 	mov	r5,r4
 8210438:	42000204 	addi	r8,r8,8
 821043c:	21000044 	addi	r4,r4,1
 8210440:	003d9706 	br	820faa0 <___vfiprintf_internal_r+0x4f8>
 8210444:	d9001d04 	addi	r4,sp,116
 8210448:	00800084 	movi	r2,2
 821044c:	d9000015 	stw	r4,0(sp)
 8210450:	d8800115 	stw	r2,4(sp)
 8210454:	1809883a 	mov	r4,r3
 8210458:	d811883a 	mov	r8,sp
 821045c:	200b883a 	mov	r5,r4
 8210460:	42000204 	addi	r8,r8,8
 8210464:	21000044 	addi	r4,r4,1
 8210468:	003f4e06 	br	82101a4 <___vfiprintf_internal_r+0xbfc>
 821046c:	d8001d85 	stb	zero,118(sp)
 8210470:	48005016 	blt	r9,zero,82105b4 <___vfiprintf_internal_r+0x100c>
 8210474:	00ffdfc4 	movi	r3,-129
 8210478:	94c4b03a 	or	r2,r18,r19
 821047c:	a0e8703a 	and	r20,r20,r3
 8210480:	103d4426 	beq	r2,zero,820f994 <___vfiprintf_internal_r+0x3ec>
 8210484:	0039883a 	mov	fp,zero
 8210488:	d9002617 	ldw	r4,152(sp)
 821048c:	dd401a04 	addi	r21,sp,104
 8210490:	908003cc 	andi	r2,r18,15
 8210494:	9806973a 	slli	r3,r19,28
 8210498:	2085883a 	add	r2,r4,r2
 821049c:	9024d13a 	srli	r18,r18,4
 82104a0:	10800003 	ldbu	r2,0(r2)
 82104a4:	9826d13a 	srli	r19,r19,4
 82104a8:	ad7fffc4 	addi	r21,r21,-1
 82104ac:	1ca4b03a 	or	r18,r3,r18
 82104b0:	a8800005 	stb	r2,0(r21)
 82104b4:	94c4b03a 	or	r2,r18,r19
 82104b8:	103ff51e 	bne	r2,zero,8210490 <___vfiprintf_internal_r+0xee8>
 82104bc:	003e5906 	br	820fe24 <___vfiprintf_internal_r+0x87c>
 82104c0:	d9402117 	ldw	r5,132(sp)
 82104c4:	d9002017 	ldw	r4,128(sp)
 82104c8:	d9801a04 	addi	r6,sp,104
 82104cc:	820f4940 	call	820f494 <__sprint_r.part.0>
 82104d0:	103f891e 	bne	r2,zero,82102f8 <___vfiprintf_internal_r+0xd50>
 82104d4:	d8801c17 	ldw	r2,112(sp)
 82104d8:	d811883a 	mov	r8,sp
 82104dc:	003f9506 	br	8210334 <___vfiprintf_internal_r+0xd8c>
 82104e0:	d9402117 	ldw	r5,132(sp)
 82104e4:	d9002017 	ldw	r4,128(sp)
 82104e8:	d9801a04 	addi	r6,sp,104
 82104ec:	820f4940 	call	820f494 <__sprint_r.part.0>
 82104f0:	103f811e 	bne	r2,zero,82102f8 <___vfiprintf_internal_r+0xd50>
 82104f4:	d811883a 	mov	r8,sp
 82104f8:	003ced06 	br	820f8b0 <___vfiprintf_internal_r+0x308>
 82104fc:	d9402117 	ldw	r5,132(sp)
 8210500:	d9002017 	ldw	r4,128(sp)
 8210504:	d9801a04 	addi	r6,sp,104
 8210508:	da402c15 	stw	r9,176(sp)
 821050c:	db802a15 	stw	r14,168(sp)
 8210510:	820f4940 	call	820f494 <__sprint_r.part.0>
 8210514:	da402c17 	ldw	r9,176(sp)
 8210518:	db802a17 	ldw	r14,168(sp)
 821051c:	103f761e 	bne	r2,zero,82102f8 <___vfiprintf_internal_r+0xd50>
 8210520:	d9401b17 	ldw	r5,108(sp)
 8210524:	d8801c17 	ldw	r2,112(sp)
 8210528:	d811883a 	mov	r8,sp
 821052c:	29000044 	addi	r4,r5,1
 8210530:	003d5b06 	br	820faa0 <___vfiprintf_internal_r+0x4f8>
 8210534:	d9402117 	ldw	r5,132(sp)
 8210538:	d9002017 	ldw	r4,128(sp)
 821053c:	d9801a04 	addi	r6,sp,104
 8210540:	da402c15 	stw	r9,176(sp)
 8210544:	820f4940 	call	820f494 <__sprint_r.part.0>
 8210548:	da402c17 	ldw	r9,176(sp)
 821054c:	103f6a1e 	bne	r2,zero,82102f8 <___vfiprintf_internal_r+0xd50>
 8210550:	d9401b17 	ldw	r5,108(sp)
 8210554:	d8801c17 	ldw	r2,112(sp)
 8210558:	d811883a 	mov	r8,sp
 821055c:	29000044 	addi	r4,r5,1
 8210560:	003f1006 	br	82101a4 <___vfiprintf_internal_r+0xbfc>
 8210564:	1000c31e 	bne	r2,zero,8210874 <___vfiprintf_internal_r+0x12cc>
 8210568:	01000044 	movi	r4,1
 821056c:	000b883a 	mov	r5,zero
 8210570:	d811883a 	mov	r8,sp
 8210574:	003f0d06 	br	82101ac <___vfiprintf_internal_r+0xc04>
 8210578:	d9402117 	ldw	r5,132(sp)
 821057c:	d9002017 	ldw	r4,128(sp)
 8210580:	d9801a04 	addi	r6,sp,104
 8210584:	820f4940 	call	820f494 <__sprint_r.part.0>
 8210588:	103f5b1e 	bne	r2,zero,82102f8 <___vfiprintf_internal_r+0xd50>
 821058c:	d9001b17 	ldw	r4,108(sp)
 8210590:	d8801c17 	ldw	r2,112(sp)
 8210594:	d811883a 	mov	r8,sp
 8210598:	21000044 	addi	r4,r4,1
 821059c:	003d8006 	br	820fba0 <___vfiprintf_internal_r+0x5f8>
 82105a0:	01020974 	movhi	r4,2085
 82105a4:	2136c304 	addi	r4,r4,-9460
 82105a8:	d9002615 	stw	r4,152(sp)
 82105ac:	d8c02215 	stw	r3,136(sp)
 82105b0:	1029883a 	mov	r20,r2
 82105b4:	94c4b03a 	or	r2,r18,r19
 82105b8:	103fb21e 	bne	r2,zero,8210484 <___vfiprintf_internal_r+0xedc>
 82105bc:	0039883a 	mov	fp,zero
 82105c0:	00800084 	movi	r2,2
 82105c4:	003e6b06 	br	820ff74 <___vfiprintf_internal_r+0x9cc>
 82105c8:	da802217 	ldw	r10,136(sp)
 82105cc:	d8001d85 	stb	zero,118(sp)
 82105d0:	0027883a 	mov	r19,zero
 82105d4:	50800104 	addi	r2,r10,4
 82105d8:	54800017 	ldw	r18,0(r10)
 82105dc:	483e6016 	blt	r9,zero,820ff60 <___vfiprintf_internal_r+0x9b8>
 82105e0:	00ffdfc4 	movi	r3,-129
 82105e4:	d8802215 	stw	r2,136(sp)
 82105e8:	a0e8703a 	and	r20,r20,r3
 82105ec:	0039883a 	mov	fp,zero
 82105f0:	903ebb26 	beq	r18,zero,82100e0 <___vfiprintf_internal_r+0xb38>
 82105f4:	00800244 	movi	r2,9
 82105f8:	14bdee36 	bltu	r2,r18,820fdb4 <___vfiprintf_internal_r+0x80c>
 82105fc:	003eba06 	br	82100e8 <___vfiprintf_internal_r+0xb40>
 8210600:	00800c04 	movi	r2,48
 8210604:	d8c01d45 	stb	r3,117(sp)
 8210608:	d8801d05 	stb	r2,116(sp)
 821060c:	d8001d85 	stb	zero,118(sp)
 8210610:	a0c00094 	ori	r3,r20,2
 8210614:	4800a916 	blt	r9,zero,82108bc <___vfiprintf_internal_r+0x1314>
 8210618:	00bfdfc4 	movi	r2,-129
 821061c:	a096703a 	and	r11,r20,r2
 8210620:	5d000094 	ori	r20,r11,2
 8210624:	0039883a 	mov	fp,zero
 8210628:	003f9706 	br	8210488 <___vfiprintf_internal_r+0xee0>
 821062c:	8025883a 	mov	r18,r16
 8210630:	003c2e06 	br	820f6ec <___vfiprintf_internal_r+0x144>
 8210634:	00820974 	movhi	r2,2085
 8210638:	10b6c304 	addi	r2,r2,-9460
 821063c:	0039883a 	mov	fp,zero
 8210640:	d8802615 	stw	r2,152(sp)
 8210644:	003f9006 	br	8210488 <___vfiprintf_internal_r+0xee0>
 8210648:	04a5c83a 	sub	r18,zero,r18
 821064c:	07000b44 	movi	fp,45
 8210650:	9004c03a 	cmpne	r2,r18,zero
 8210654:	04e7c83a 	sub	r19,zero,r19
 8210658:	df001d85 	stb	fp,118(sp)
 821065c:	98a7c83a 	sub	r19,r19,r2
 8210660:	48009f16 	blt	r9,zero,82108e0 <___vfiprintf_internal_r+0x1338>
 8210664:	00bfdfc4 	movi	r2,-129
 8210668:	a0a8703a 	and	r20,r20,r2
 821066c:	003dd006 	br	820fdb0 <___vfiprintf_internal_r+0x808>
 8210670:	70004c26 	beq	r14,zero,82107a4 <___vfiprintf_internal_r+0x11fc>
 8210674:	00800084 	movi	r2,2
 8210678:	d8c01d04 	addi	r3,sp,116
 821067c:	d8c00015 	stw	r3,0(sp)
 8210680:	d8800115 	stw	r2,4(sp)
 8210684:	01000044 	movi	r4,1
 8210688:	d811883a 	mov	r8,sp
 821068c:	003f7306 	br	821045c <___vfiprintf_internal_r+0xeb4>
 8210690:	a080100c 	andi	r2,r20,64
 8210694:	da802217 	ldw	r10,136(sp)
 8210698:	103e0626 	beq	r2,zero,820feb4 <___vfiprintf_internal_r+0x90c>
 821069c:	5480000f 	ldh	r18,0(r10)
 82106a0:	52800104 	addi	r10,r10,4
 82106a4:	da802215 	stw	r10,136(sp)
 82106a8:	9027d7fa 	srai	r19,r18,31
 82106ac:	9805883a 	mov	r2,r19
 82106b0:	003db806 	br	820fd94 <___vfiprintf_internal_r+0x7ec>
 82106b4:	a080040c 	andi	r2,r20,16
 82106b8:	1000091e 	bne	r2,zero,82106e0 <___vfiprintf_internal_r+0x1138>
 82106bc:	a2c0100c 	andi	r11,r20,64
 82106c0:	58000726 	beq	r11,zero,82106e0 <___vfiprintf_internal_r+0x1138>
 82106c4:	da802217 	ldw	r10,136(sp)
 82106c8:	50800017 	ldw	r2,0(r10)
 82106cc:	52800104 	addi	r10,r10,4
 82106d0:	da802215 	stw	r10,136(sp)
 82106d4:	da802317 	ldw	r10,140(sp)
 82106d8:	1280000d 	sth	r10,0(r2)
 82106dc:	003be706 	br	820f67c <___vfiprintf_internal_r+0xd4>
 82106e0:	da802217 	ldw	r10,136(sp)
 82106e4:	50800017 	ldw	r2,0(r10)
 82106e8:	52800104 	addi	r10,r10,4
 82106ec:	da802215 	stw	r10,136(sp)
 82106f0:	da802317 	ldw	r10,140(sp)
 82106f4:	12800015 	stw	r10,0(r2)
 82106f8:	003be006 	br	820f67c <___vfiprintf_internal_r+0xd4>
 82106fc:	a080100c 	andi	r2,r20,64
 8210700:	da802217 	ldw	r10,136(sp)
 8210704:	10003026 	beq	r2,zero,82107c8 <___vfiprintf_internal_r+0x1220>
 8210708:	5480000b 	ldhu	r18,0(r10)
 821070c:	52800104 	addi	r10,r10,4
 8210710:	0027883a 	mov	r19,zero
 8210714:	da802215 	stw	r10,136(sp)
 8210718:	003d8006 	br	820fd1c <___vfiprintf_internal_r+0x774>
 821071c:	80c00007 	ldb	r3,0(r16)
 8210720:	003c0006 	br	820f724 <___vfiprintf_internal_r+0x17c>
 8210724:	a080100c 	andi	r2,r20,64
 8210728:	d8001d85 	stb	zero,118(sp)
 821072c:	da802217 	ldw	r10,136(sp)
 8210730:	1000201e 	bne	r2,zero,82107b4 <___vfiprintf_internal_r+0x120c>
 8210734:	50800104 	addi	r2,r10,4
 8210738:	54800017 	ldw	r18,0(r10)
 821073c:	0027883a 	mov	r19,zero
 8210740:	483def0e 	bge	r9,zero,820ff00 <___vfiprintf_internal_r+0x958>
 8210744:	94c6b03a 	or	r3,r18,r19
 8210748:	d8802215 	stw	r2,136(sp)
 821074c:	183d4e1e 	bne	r3,zero,820fc88 <___vfiprintf_internal_r+0x6e0>
 8210750:	0039883a 	mov	fp,zero
 8210754:	0005883a 	mov	r2,zero
 8210758:	003e0606 	br	820ff74 <___vfiprintf_internal_r+0x9cc>
 821075c:	d9402117 	ldw	r5,132(sp)
 8210760:	d9002017 	ldw	r4,128(sp)
 8210764:	d9801a04 	addi	r6,sp,104
 8210768:	da402c15 	stw	r9,176(sp)
 821076c:	db802a15 	stw	r14,168(sp)
 8210770:	820f4940 	call	820f494 <__sprint_r.part.0>
 8210774:	da402c17 	ldw	r9,176(sp)
 8210778:	db802a17 	ldw	r14,168(sp)
 821077c:	103ede1e 	bne	r2,zero,82102f8 <___vfiprintf_internal_r+0xd50>
 8210780:	d9401b17 	ldw	r5,108(sp)
 8210784:	d8801c17 	ldw	r2,112(sp)
 8210788:	d811883a 	mov	r8,sp
 821078c:	29000044 	addi	r4,r5,1
 8210790:	003e7406 	br	8210164 <___vfiprintf_internal_r+0xbbc>
 8210794:	00bfffc4 	movi	r2,-1
 8210798:	003c5806 	br	820f8fc <___vfiprintf_internal_r+0x354>
 821079c:	d811883a 	mov	r8,sp
 82107a0:	003ee806 	br	8210344 <___vfiprintf_internal_r+0xd9c>
 82107a4:	000b883a 	mov	r5,zero
 82107a8:	01000044 	movi	r4,1
 82107ac:	d811883a 	mov	r8,sp
 82107b0:	003e7c06 	br	82101a4 <___vfiprintf_internal_r+0xbfc>
 82107b4:	50800104 	addi	r2,r10,4
 82107b8:	5480000b 	ldhu	r18,0(r10)
 82107bc:	0027883a 	mov	r19,zero
 82107c0:	483dcf0e 	bge	r9,zero,820ff00 <___vfiprintf_internal_r+0x958>
 82107c4:	003fdf06 	br	8210744 <___vfiprintf_internal_r+0x119c>
 82107c8:	54800017 	ldw	r18,0(r10)
 82107cc:	52800104 	addi	r10,r10,4
 82107d0:	0027883a 	mov	r19,zero
 82107d4:	da802215 	stw	r10,136(sp)
 82107d8:	003d5006 	br	820fd1c <___vfiprintf_internal_r+0x774>
 82107dc:	50800104 	addi	r2,r10,4
 82107e0:	5480000b 	ldhu	r18,0(r10)
 82107e4:	0027883a 	mov	r19,zero
 82107e8:	483f7d0e 	bge	r9,zero,82105e0 <___vfiprintf_internal_r+0x1038>
 82107ec:	003ddc06 	br	820ff60 <___vfiprintf_internal_r+0x9b8>
 82107f0:	d8c02215 	stw	r3,136(sp)
 82107f4:	0039883a 	mov	fp,zero
 82107f8:	003ddb06 	br	820ff68 <___vfiprintf_internal_r+0x9c0>
 82107fc:	02820974 	movhi	r10,2085
 8210800:	52b73304 	addi	r10,r10,-9012
 8210804:	da802415 	stw	r10,144(sp)
 8210808:	003e8306 	br	8210218 <___vfiprintf_internal_r+0xc70>
 821080c:	d8801c17 	ldw	r2,112(sp)
 8210810:	dd002117 	ldw	r20,132(sp)
 8210814:	103eb926 	beq	r2,zero,82102fc <___vfiprintf_internal_r+0xd54>
 8210818:	d9002017 	ldw	r4,128(sp)
 821081c:	d9801a04 	addi	r6,sp,104
 8210820:	a00b883a 	mov	r5,r20
 8210824:	820f4940 	call	820f494 <__sprint_r.part.0>
 8210828:	003eb406 	br	82102fc <___vfiprintf_internal_r+0xd54>
 821082c:	80c00043 	ldbu	r3,1(r16)
 8210830:	a5000814 	ori	r20,r20,32
 8210834:	84000044 	addi	r16,r16,1
 8210838:	18c03fcc 	andi	r3,r3,255
 821083c:	18c0201c 	xori	r3,r3,128
 8210840:	18ffe004 	addi	r3,r3,-128
 8210844:	003bb706 	br	820f724 <___vfiprintf_internal_r+0x17c>
 8210848:	a809883a 	mov	r4,r21
 821084c:	d8c02a15 	stw	r3,168(sp)
 8210850:	da002b15 	stw	r8,172(sp)
 8210854:	8203f600 	call	8203f60 <strlen>
 8210858:	d8c02a17 	ldw	r3,168(sp)
 821085c:	1027883a 	mov	r19,r2
 8210860:	df001d83 	ldbu	fp,118(sp)
 8210864:	d8c02215 	stw	r3,136(sp)
 8210868:	0013883a 	mov	r9,zero
 821086c:	da002b17 	ldw	r8,172(sp)
 8210870:	003c4d06 	br	820f9a8 <___vfiprintf_internal_r+0x400>
 8210874:	d9402117 	ldw	r5,132(sp)
 8210878:	d9002017 	ldw	r4,128(sp)
 821087c:	d9801a04 	addi	r6,sp,104
 8210880:	da402c15 	stw	r9,176(sp)
 8210884:	820f4940 	call	820f494 <__sprint_r.part.0>
 8210888:	da402c17 	ldw	r9,176(sp)
 821088c:	103e9a1e 	bne	r2,zero,82102f8 <___vfiprintf_internal_r+0xd50>
 8210890:	d9401b17 	ldw	r5,108(sp)
 8210894:	d8801c17 	ldw	r2,112(sp)
 8210898:	d811883a 	mov	r8,sp
 821089c:	29000044 	addi	r4,r5,1
 82108a0:	003e4206 	br	82101ac <___vfiprintf_internal_r+0xc04>
 82108a4:	d9401b17 	ldw	r5,108(sp)
 82108a8:	01020974 	movhi	r4,2085
 82108ac:	21373704 	addi	r4,r4,-8996
 82108b0:	d9002415 	stw	r4,144(sp)
 82108b4:	29400044 	addi	r5,r5,1
 82108b8:	003c6d06 	br	820fa70 <___vfiprintf_internal_r+0x4c8>
 82108bc:	0039883a 	mov	fp,zero
 82108c0:	00800084 	movi	r2,2
 82108c4:	10803fcc 	andi	r2,r2,255
 82108c8:	01000044 	movi	r4,1
 82108cc:	11001e26 	beq	r2,r4,8210948 <___vfiprintf_internal_r+0x13a0>
 82108d0:	01000084 	movi	r4,2
 82108d4:	11001e1e 	bne	r2,r4,8210950 <___vfiprintf_internal_r+0x13a8>
 82108d8:	1829883a 	mov	r20,r3
 82108dc:	003eea06 	br	8210488 <___vfiprintf_internal_r+0xee0>
 82108e0:	a007883a 	mov	r3,r20
 82108e4:	00800044 	movi	r2,1
 82108e8:	003ff606 	br	82108c4 <___vfiprintf_internal_r+0x131c>
 82108ec:	00800184 	movi	r2,6
 82108f0:	1240012e 	bgeu	r2,r9,82108f8 <___vfiprintf_internal_r+0x1350>
 82108f4:	1013883a 	mov	r9,r2
 82108f8:	4827883a 	mov	r19,r9
 82108fc:	4825883a 	mov	r18,r9
 8210900:	48001516 	blt	r9,zero,8210958 <___vfiprintf_internal_r+0x13b0>
 8210904:	05420974 	movhi	r21,2085
 8210908:	d8c02215 	stw	r3,136(sp)
 821090c:	ad76c804 	addi	r21,r21,-9440
 8210910:	003d1406 	br	820fd64 <___vfiprintf_internal_r+0x7bc>
 8210914:	02820974 	movhi	r10,2085
 8210918:	52b73304 	addi	r10,r10,-9012
 821091c:	da802415 	stw	r10,144(sp)
 8210920:	200d883a 	mov	r6,r4
 8210924:	003c9106 	br	820fb6c <___vfiprintf_internal_r+0x5c4>
 8210928:	5021883a 	mov	r16,r10
 821092c:	0013883a 	mov	r9,zero
 8210930:	003b7d06 	br	820f728 <___vfiprintf_internal_r+0x180>
 8210934:	4827883a 	mov	r19,r9
 8210938:	df001d83 	ldbu	fp,118(sp)
 821093c:	d8c02215 	stw	r3,136(sp)
 8210940:	0013883a 	mov	r9,zero
 8210944:	003c1806 	br	820f9a8 <___vfiprintf_internal_r+0x400>
 8210948:	1829883a 	mov	r20,r3
 821094c:	003d1806 	br	820fdb0 <___vfiprintf_internal_r+0x808>
 8210950:	1829883a 	mov	r20,r3
 8210954:	003ccd06 	br	820fc8c <___vfiprintf_internal_r+0x6e4>
 8210958:	0025883a 	mov	r18,zero
 821095c:	003fe906 	br	8210904 <___vfiprintf_internal_r+0x135c>
 8210960:	d8802217 	ldw	r2,136(sp)
 8210964:	80c00043 	ldbu	r3,1(r16)
 8210968:	5021883a 	mov	r16,r10
 821096c:	12400017 	ldw	r9,0(r2)
 8210970:	10800104 	addi	r2,r2,4
 8210974:	d8802215 	stw	r2,136(sp)
 8210978:	483faf0e 	bge	r9,zero,8210838 <___vfiprintf_internal_r+0x1290>
 821097c:	18c03fcc 	andi	r3,r3,255
 8210980:	18c0201c 	xori	r3,r3,128
 8210984:	027fffc4 	movi	r9,-1
 8210988:	18ffe004 	addi	r3,r3,-128
 821098c:	003b6506 	br	820f724 <___vfiprintf_internal_r+0x17c>
 8210990:	d9c01d85 	stb	r7,118(sp)
 8210994:	003ca006 	br	820fc18 <___vfiprintf_internal_r+0x670>
 8210998:	d9c01d85 	stb	r7,118(sp)
 821099c:	003cad06 	br	820fc54 <___vfiprintf_internal_r+0x6ac>
 82109a0:	d9c01d85 	stb	r7,118(sp)
 82109a4:	003d7d06 	br	820ff9c <___vfiprintf_internal_r+0x9f4>
 82109a8:	d9c01d85 	stb	r7,118(sp)
 82109ac:	003d5f06 	br	820ff2c <___vfiprintf_internal_r+0x984>
 82109b0:	a080004c 	andi	r2,r20,1
 82109b4:	0039883a 	mov	fp,zero
 82109b8:	10000526 	beq	r2,zero,82109d0 <___vfiprintf_internal_r+0x1428>
 82109bc:	00800c04 	movi	r2,48
 82109c0:	d88019c5 	stb	r2,103(sp)
 82109c4:	dcc02717 	ldw	r19,156(sp)
 82109c8:	dd4019c4 	addi	r21,sp,103
 82109cc:	003bf606 	br	820f9a8 <___vfiprintf_internal_r+0x400>
 82109d0:	0027883a 	mov	r19,zero
 82109d4:	dd401a04 	addi	r21,sp,104
 82109d8:	003bf306 	br	820f9a8 <___vfiprintf_internal_r+0x400>
 82109dc:	d9c01d85 	stb	r7,118(sp)
 82109e0:	003dc806 	br	8210104 <___vfiprintf_internal_r+0xb5c>
 82109e4:	d9c01d85 	stb	r7,118(sp)
 82109e8:	003d3a06 	br	820fed4 <___vfiprintf_internal_r+0x92c>
 82109ec:	d9c01d85 	stb	r7,118(sp)
 82109f0:	003d2a06 	br	820fe9c <___vfiprintf_internal_r+0x8f4>
 82109f4:	d9c01d85 	stb	r7,118(sp)
 82109f8:	003cde06 	br	820fd74 <___vfiprintf_internal_r+0x7cc>
 82109fc:	d9c01d85 	stb	r7,118(sp)
 8210a00:	003cbc06 	br	820fcf4 <___vfiprintf_internal_r+0x74c>

08210a04 <__vfiprintf_internal>:
 8210a04:	00820974 	movhi	r2,2085
 8210a08:	108f9904 	addi	r2,r2,15972
 8210a0c:	300f883a 	mov	r7,r6
 8210a10:	280d883a 	mov	r6,r5
 8210a14:	200b883a 	mov	r5,r4
 8210a18:	11000017 	ldw	r4,0(r2)
 8210a1c:	820f5a81 	jmpi	820f5a8 <___vfiprintf_internal_r>

08210a20 <__sbprintf>:
 8210a20:	2880030b 	ldhu	r2,12(r5)
 8210a24:	2ac01917 	ldw	r11,100(r5)
 8210a28:	2a80038b 	ldhu	r10,14(r5)
 8210a2c:	2a400717 	ldw	r9,28(r5)
 8210a30:	2a000917 	ldw	r8,36(r5)
 8210a34:	defee204 	addi	sp,sp,-1144
 8210a38:	00c10004 	movi	r3,1024
 8210a3c:	dc011a15 	stw	r16,1128(sp)
 8210a40:	10bfff4c 	andi	r2,r2,65533
 8210a44:	2821883a 	mov	r16,r5
 8210a48:	d8cb883a 	add	r5,sp,r3
 8210a4c:	dc811c15 	stw	r18,1136(sp)
 8210a50:	dc411b15 	stw	r17,1132(sp)
 8210a54:	dfc11d15 	stw	ra,1140(sp)
 8210a58:	2025883a 	mov	r18,r4
 8210a5c:	d881030d 	sth	r2,1036(sp)
 8210a60:	dac11915 	stw	r11,1124(sp)
 8210a64:	da81038d 	sth	r10,1038(sp)
 8210a68:	da410715 	stw	r9,1052(sp)
 8210a6c:	da010915 	stw	r8,1060(sp)
 8210a70:	dec10015 	stw	sp,1024(sp)
 8210a74:	dec10415 	stw	sp,1040(sp)
 8210a78:	d8c10215 	stw	r3,1032(sp)
 8210a7c:	d8c10515 	stw	r3,1044(sp)
 8210a80:	d8010615 	stw	zero,1048(sp)
 8210a84:	820f5a80 	call	820f5a8 <___vfiprintf_internal_r>
 8210a88:	1023883a 	mov	r17,r2
 8210a8c:	10000416 	blt	r2,zero,8210aa0 <__sbprintf+0x80>
 8210a90:	d9410004 	addi	r5,sp,1024
 8210a94:	9009883a 	mov	r4,r18
 8210a98:	820aa5c0 	call	820aa5c <_fflush_r>
 8210a9c:	10000d1e 	bne	r2,zero,8210ad4 <__sbprintf+0xb4>
 8210aa0:	d881030b 	ldhu	r2,1036(sp)
 8210aa4:	1080100c 	andi	r2,r2,64
 8210aa8:	10000326 	beq	r2,zero,8210ab8 <__sbprintf+0x98>
 8210aac:	8080030b 	ldhu	r2,12(r16)
 8210ab0:	10801014 	ori	r2,r2,64
 8210ab4:	8080030d 	sth	r2,12(r16)
 8210ab8:	8805883a 	mov	r2,r17
 8210abc:	dfc11d17 	ldw	ra,1140(sp)
 8210ac0:	dc811c17 	ldw	r18,1136(sp)
 8210ac4:	dc411b17 	ldw	r17,1132(sp)
 8210ac8:	dc011a17 	ldw	r16,1128(sp)
 8210acc:	dec11e04 	addi	sp,sp,1144
 8210ad0:	f800283a 	ret
 8210ad4:	047fffc4 	movi	r17,-1
 8210ad8:	003ff106 	br	8210aa0 <__sbprintf+0x80>

08210adc <_write_r>:
 8210adc:	defffd04 	addi	sp,sp,-12
 8210ae0:	2805883a 	mov	r2,r5
 8210ae4:	dc000015 	stw	r16,0(sp)
 8210ae8:	04020974 	movhi	r16,2085
 8210aec:	dc400115 	stw	r17,4(sp)
 8210af0:	300b883a 	mov	r5,r6
 8210af4:	840ffa04 	addi	r16,r16,16360
 8210af8:	2023883a 	mov	r17,r4
 8210afc:	380d883a 	mov	r6,r7
 8210b00:	1009883a 	mov	r4,r2
 8210b04:	dfc00215 	stw	ra,8(sp)
 8210b08:	80000015 	stw	zero,0(r16)
 8210b0c:	8225a380 	call	8225a38 <write>
 8210b10:	00ffffc4 	movi	r3,-1
 8210b14:	10c00526 	beq	r2,r3,8210b2c <_write_r+0x50>
 8210b18:	dfc00217 	ldw	ra,8(sp)
 8210b1c:	dc400117 	ldw	r17,4(sp)
 8210b20:	dc000017 	ldw	r16,0(sp)
 8210b24:	dec00304 	addi	sp,sp,12
 8210b28:	f800283a 	ret
 8210b2c:	80c00017 	ldw	r3,0(r16)
 8210b30:	183ff926 	beq	r3,zero,8210b18 <_write_r+0x3c>
 8210b34:	88c00015 	stw	r3,0(r17)
 8210b38:	003ff706 	br	8210b18 <_write_r+0x3c>

08210b3c <_close_r>:
 8210b3c:	defffd04 	addi	sp,sp,-12
 8210b40:	dc000015 	stw	r16,0(sp)
 8210b44:	04020974 	movhi	r16,2085
 8210b48:	dc400115 	stw	r17,4(sp)
 8210b4c:	840ffa04 	addi	r16,r16,16360
 8210b50:	2023883a 	mov	r17,r4
 8210b54:	2809883a 	mov	r4,r5
 8210b58:	dfc00215 	stw	ra,8(sp)
 8210b5c:	80000015 	stw	zero,0(r16)
 8210b60:	82258380 	call	8225838 <close>
 8210b64:	00ffffc4 	movi	r3,-1
 8210b68:	10c00526 	beq	r2,r3,8210b80 <_close_r+0x44>
 8210b6c:	dfc00217 	ldw	ra,8(sp)
 8210b70:	dc400117 	ldw	r17,4(sp)
 8210b74:	dc000017 	ldw	r16,0(sp)
 8210b78:	dec00304 	addi	sp,sp,12
 8210b7c:	f800283a 	ret
 8210b80:	80c00017 	ldw	r3,0(r16)
 8210b84:	183ff926 	beq	r3,zero,8210b6c <_close_r+0x30>
 8210b88:	88c00015 	stw	r3,0(r17)
 8210b8c:	003ff706 	br	8210b6c <_close_r+0x30>

08210b90 <_calloc_r>:
 8210b90:	298b383a 	mul	r5,r5,r6
 8210b94:	defffe04 	addi	sp,sp,-8
 8210b98:	dfc00115 	stw	ra,4(sp)
 8210b9c:	dc000015 	stw	r16,0(sp)
 8210ba0:	820bcec0 	call	820bcec <_malloc_r>
 8210ba4:	10002926 	beq	r2,zero,8210c4c <_calloc_r+0xbc>
 8210ba8:	11bfff17 	ldw	r6,-4(r2)
 8210bac:	1021883a 	mov	r16,r2
 8210bb0:	00bfff04 	movi	r2,-4
 8210bb4:	308c703a 	and	r6,r6,r2
 8210bb8:	00c00904 	movi	r3,36
 8210bbc:	308d883a 	add	r6,r6,r2
 8210bc0:	19801636 	bltu	r3,r6,8210c1c <_calloc_r+0x8c>
 8210bc4:	008004c4 	movi	r2,19
 8210bc8:	11800b2e 	bgeu	r2,r6,8210bf8 <_calloc_r+0x68>
 8210bcc:	80000015 	stw	zero,0(r16)
 8210bd0:	80000115 	stw	zero,4(r16)
 8210bd4:	008006c4 	movi	r2,27
 8210bd8:	11801a2e 	bgeu	r2,r6,8210c44 <_calloc_r+0xb4>
 8210bdc:	80000215 	stw	zero,8(r16)
 8210be0:	80000315 	stw	zero,12(r16)
 8210be4:	30c0151e 	bne	r6,r3,8210c3c <_calloc_r+0xac>
 8210be8:	80000415 	stw	zero,16(r16)
 8210bec:	80800604 	addi	r2,r16,24
 8210bf0:	80000515 	stw	zero,20(r16)
 8210bf4:	00000106 	br	8210bfc <_calloc_r+0x6c>
 8210bf8:	8005883a 	mov	r2,r16
 8210bfc:	10000015 	stw	zero,0(r2)
 8210c00:	10000115 	stw	zero,4(r2)
 8210c04:	10000215 	stw	zero,8(r2)
 8210c08:	8005883a 	mov	r2,r16
 8210c0c:	dfc00117 	ldw	ra,4(sp)
 8210c10:	dc000017 	ldw	r16,0(sp)
 8210c14:	dec00204 	addi	sp,sp,8
 8210c18:	f800283a 	ret
 8210c1c:	000b883a 	mov	r5,zero
 8210c20:	8009883a 	mov	r4,r16
 8210c24:	82031b40 	call	82031b4 <memset>
 8210c28:	8005883a 	mov	r2,r16
 8210c2c:	dfc00117 	ldw	ra,4(sp)
 8210c30:	dc000017 	ldw	r16,0(sp)
 8210c34:	dec00204 	addi	sp,sp,8
 8210c38:	f800283a 	ret
 8210c3c:	80800404 	addi	r2,r16,16
 8210c40:	003fee06 	br	8210bfc <_calloc_r+0x6c>
 8210c44:	80800204 	addi	r2,r16,8
 8210c48:	003fec06 	br	8210bfc <_calloc_r+0x6c>
 8210c4c:	0005883a 	mov	r2,zero
 8210c50:	003fee06 	br	8210c0c <_calloc_r+0x7c>

08210c54 <_fclose_r>:
 8210c54:	28003926 	beq	r5,zero,8210d3c <_fclose_r+0xe8>
 8210c58:	defffc04 	addi	sp,sp,-16
 8210c5c:	dc400115 	stw	r17,4(sp)
 8210c60:	dc000015 	stw	r16,0(sp)
 8210c64:	dfc00315 	stw	ra,12(sp)
 8210c68:	dc800215 	stw	r18,8(sp)
 8210c6c:	2023883a 	mov	r17,r4
 8210c70:	2821883a 	mov	r16,r5
 8210c74:	20000226 	beq	r4,zero,8210c80 <_fclose_r+0x2c>
 8210c78:	20800e17 	ldw	r2,56(r4)
 8210c7c:	10002726 	beq	r2,zero,8210d1c <_fclose_r+0xc8>
 8210c80:	8080030f 	ldh	r2,12(r16)
 8210c84:	1000071e 	bne	r2,zero,8210ca4 <_fclose_r+0x50>
 8210c88:	0005883a 	mov	r2,zero
 8210c8c:	dfc00317 	ldw	ra,12(sp)
 8210c90:	dc800217 	ldw	r18,8(sp)
 8210c94:	dc400117 	ldw	r17,4(sp)
 8210c98:	dc000017 	ldw	r16,0(sp)
 8210c9c:	dec00404 	addi	sp,sp,16
 8210ca0:	f800283a 	ret
 8210ca4:	800b883a 	mov	r5,r16
 8210ca8:	8809883a 	mov	r4,r17
 8210cac:	820a8400 	call	820a840 <__sflush_r>
 8210cb0:	1025883a 	mov	r18,r2
 8210cb4:	80800b17 	ldw	r2,44(r16)
 8210cb8:	10000426 	beq	r2,zero,8210ccc <_fclose_r+0x78>
 8210cbc:	81400717 	ldw	r5,28(r16)
 8210cc0:	8809883a 	mov	r4,r17
 8210cc4:	103ee83a 	callr	r2
 8210cc8:	10001616 	blt	r2,zero,8210d24 <_fclose_r+0xd0>
 8210ccc:	8080030b 	ldhu	r2,12(r16)
 8210cd0:	1080200c 	andi	r2,r2,128
 8210cd4:	1000151e 	bne	r2,zero,8210d2c <_fclose_r+0xd8>
 8210cd8:	81400c17 	ldw	r5,48(r16)
 8210cdc:	28000526 	beq	r5,zero,8210cf4 <_fclose_r+0xa0>
 8210ce0:	80801004 	addi	r2,r16,64
 8210ce4:	28800226 	beq	r5,r2,8210cf0 <_fclose_r+0x9c>
 8210ce8:	8809883a 	mov	r4,r17
 8210cec:	820b1000 	call	820b100 <_free_r>
 8210cf0:	80000c15 	stw	zero,48(r16)
 8210cf4:	81401117 	ldw	r5,68(r16)
 8210cf8:	28000326 	beq	r5,zero,8210d08 <_fclose_r+0xb4>
 8210cfc:	8809883a 	mov	r4,r17
 8210d00:	820b1000 	call	820b100 <_free_r>
 8210d04:	80001115 	stw	zero,68(r16)
 8210d08:	820ae480 	call	820ae48 <__sfp_lock_acquire>
 8210d0c:	8000030d 	sth	zero,12(r16)
 8210d10:	820ae4c0 	call	820ae4c <__sfp_lock_release>
 8210d14:	9005883a 	mov	r2,r18
 8210d18:	003fdc06 	br	8210c8c <_fclose_r+0x38>
 8210d1c:	820ae380 	call	820ae38 <__sinit>
 8210d20:	003fd706 	br	8210c80 <_fclose_r+0x2c>
 8210d24:	04bfffc4 	movi	r18,-1
 8210d28:	003fe806 	br	8210ccc <_fclose_r+0x78>
 8210d2c:	81400417 	ldw	r5,16(r16)
 8210d30:	8809883a 	mov	r4,r17
 8210d34:	820b1000 	call	820b100 <_free_r>
 8210d38:	003fe706 	br	8210cd8 <_fclose_r+0x84>
 8210d3c:	0005883a 	mov	r2,zero
 8210d40:	f800283a 	ret

08210d44 <fclose>:
 8210d44:	00820974 	movhi	r2,2085
 8210d48:	108f9904 	addi	r2,r2,15972
 8210d4c:	200b883a 	mov	r5,r4
 8210d50:	11000017 	ldw	r4,0(r2)
 8210d54:	8210c541 	jmpi	8210c54 <_fclose_r>

08210d58 <__fputwc>:
 8210d58:	defff804 	addi	sp,sp,-32
 8210d5c:	dcc00415 	stw	r19,16(sp)
 8210d60:	dc800315 	stw	r18,12(sp)
 8210d64:	dc000115 	stw	r16,4(sp)
 8210d68:	dfc00715 	stw	ra,28(sp)
 8210d6c:	dd400615 	stw	r21,24(sp)
 8210d70:	dd000515 	stw	r20,20(sp)
 8210d74:	dc400215 	stw	r17,8(sp)
 8210d78:	2027883a 	mov	r19,r4
 8210d7c:	2825883a 	mov	r18,r5
 8210d80:	3021883a 	mov	r16,r6
 8210d84:	820badc0 	call	820badc <__locale_mb_cur_max>
 8210d88:	00c00044 	movi	r3,1
 8210d8c:	10c03e26 	beq	r2,r3,8210e88 <__fputwc+0x130>
 8210d90:	81c01704 	addi	r7,r16,92
 8210d94:	900d883a 	mov	r6,r18
 8210d98:	d80b883a 	mov	r5,sp
 8210d9c:	9809883a 	mov	r4,r19
 8210da0:	82110d00 	call	82110d0 <_wcrtomb_r>
 8210da4:	1029883a 	mov	r20,r2
 8210da8:	00bfffc4 	movi	r2,-1
 8210dac:	a0802026 	beq	r20,r2,8210e30 <__fputwc+0xd8>
 8210db0:	d9400003 	ldbu	r5,0(sp)
 8210db4:	a0001c26 	beq	r20,zero,8210e28 <__fputwc+0xd0>
 8210db8:	0023883a 	mov	r17,zero
 8210dbc:	05400284 	movi	r21,10
 8210dc0:	00000906 	br	8210de8 <__fputwc+0x90>
 8210dc4:	80800017 	ldw	r2,0(r16)
 8210dc8:	11400005 	stb	r5,0(r2)
 8210dcc:	80c00017 	ldw	r3,0(r16)
 8210dd0:	18c00044 	addi	r3,r3,1
 8210dd4:	80c00015 	stw	r3,0(r16)
 8210dd8:	8c400044 	addi	r17,r17,1
 8210ddc:	dc45883a 	add	r2,sp,r17
 8210de0:	8d00112e 	bgeu	r17,r20,8210e28 <__fputwc+0xd0>
 8210de4:	11400003 	ldbu	r5,0(r2)
 8210de8:	80c00217 	ldw	r3,8(r16)
 8210dec:	18ffffc4 	addi	r3,r3,-1
 8210df0:	80c00215 	stw	r3,8(r16)
 8210df4:	183ff30e 	bge	r3,zero,8210dc4 <__fputwc+0x6c>
 8210df8:	80800617 	ldw	r2,24(r16)
 8210dfc:	18801916 	blt	r3,r2,8210e64 <__fputwc+0x10c>
 8210e00:	80800017 	ldw	r2,0(r16)
 8210e04:	11400005 	stb	r5,0(r2)
 8210e08:	80800017 	ldw	r2,0(r16)
 8210e0c:	10c00003 	ldbu	r3,0(r2)
 8210e10:	10800044 	addi	r2,r2,1
 8210e14:	1d402326 	beq	r3,r21,8210ea4 <__fputwc+0x14c>
 8210e18:	80800015 	stw	r2,0(r16)
 8210e1c:	8c400044 	addi	r17,r17,1
 8210e20:	dc45883a 	add	r2,sp,r17
 8210e24:	8d3fef36 	bltu	r17,r20,8210de4 <__fputwc+0x8c>
 8210e28:	9005883a 	mov	r2,r18
 8210e2c:	00000406 	br	8210e40 <__fputwc+0xe8>
 8210e30:	80c0030b 	ldhu	r3,12(r16)
 8210e34:	a005883a 	mov	r2,r20
 8210e38:	18c01014 	ori	r3,r3,64
 8210e3c:	80c0030d 	sth	r3,12(r16)
 8210e40:	dfc00717 	ldw	ra,28(sp)
 8210e44:	dd400617 	ldw	r21,24(sp)
 8210e48:	dd000517 	ldw	r20,20(sp)
 8210e4c:	dcc00417 	ldw	r19,16(sp)
 8210e50:	dc800317 	ldw	r18,12(sp)
 8210e54:	dc400217 	ldw	r17,8(sp)
 8210e58:	dc000117 	ldw	r16,4(sp)
 8210e5c:	dec00804 	addi	sp,sp,32
 8210e60:	f800283a 	ret
 8210e64:	800d883a 	mov	r6,r16
 8210e68:	29403fcc 	andi	r5,r5,255
 8210e6c:	9809883a 	mov	r4,r19
 8210e70:	8208d0c0 	call	8208d0c <__swbuf_r>
 8210e74:	10bfffe0 	cmpeqi	r2,r2,-1
 8210e78:	10803fcc 	andi	r2,r2,255
 8210e7c:	103fd626 	beq	r2,zero,8210dd8 <__fputwc+0x80>
 8210e80:	00bfffc4 	movi	r2,-1
 8210e84:	003fee06 	br	8210e40 <__fputwc+0xe8>
 8210e88:	90ffffc4 	addi	r3,r18,-1
 8210e8c:	01003f84 	movi	r4,254
 8210e90:	20ffbf36 	bltu	r4,r3,8210d90 <__fputwc+0x38>
 8210e94:	900b883a 	mov	r5,r18
 8210e98:	dc800005 	stb	r18,0(sp)
 8210e9c:	1029883a 	mov	r20,r2
 8210ea0:	003fc506 	br	8210db8 <__fputwc+0x60>
 8210ea4:	800d883a 	mov	r6,r16
 8210ea8:	a80b883a 	mov	r5,r21
 8210eac:	9809883a 	mov	r4,r19
 8210eb0:	8208d0c0 	call	8208d0c <__swbuf_r>
 8210eb4:	10bfffe0 	cmpeqi	r2,r2,-1
 8210eb8:	003fef06 	br	8210e78 <__fputwc+0x120>

08210ebc <_fputwc_r>:
 8210ebc:	3080030b 	ldhu	r2,12(r6)
 8210ec0:	10c8000c 	andi	r3,r2,8192
 8210ec4:	1800051e 	bne	r3,zero,8210edc <_fputwc_r+0x20>
 8210ec8:	30c01917 	ldw	r3,100(r6)
 8210ecc:	10880014 	ori	r2,r2,8192
 8210ed0:	3080030d 	sth	r2,12(r6)
 8210ed4:	18880014 	ori	r2,r3,8192
 8210ed8:	30801915 	stw	r2,100(r6)
 8210edc:	8210d581 	jmpi	8210d58 <__fputwc>

08210ee0 <fputwc>:
 8210ee0:	00820974 	movhi	r2,2085
 8210ee4:	defffc04 	addi	sp,sp,-16
 8210ee8:	108f9904 	addi	r2,r2,15972
 8210eec:	dc000115 	stw	r16,4(sp)
 8210ef0:	14000017 	ldw	r16,0(r2)
 8210ef4:	dc400215 	stw	r17,8(sp)
 8210ef8:	dfc00315 	stw	ra,12(sp)
 8210efc:	2023883a 	mov	r17,r4
 8210f00:	80000226 	beq	r16,zero,8210f0c <fputwc+0x2c>
 8210f04:	80800e17 	ldw	r2,56(r16)
 8210f08:	10001026 	beq	r2,zero,8210f4c <fputwc+0x6c>
 8210f0c:	2880030b 	ldhu	r2,12(r5)
 8210f10:	10c8000c 	andi	r3,r2,8192
 8210f14:	1800051e 	bne	r3,zero,8210f2c <fputwc+0x4c>
 8210f18:	28c01917 	ldw	r3,100(r5)
 8210f1c:	10880014 	ori	r2,r2,8192
 8210f20:	2880030d 	sth	r2,12(r5)
 8210f24:	18880014 	ori	r2,r3,8192
 8210f28:	28801915 	stw	r2,100(r5)
 8210f2c:	280d883a 	mov	r6,r5
 8210f30:	8009883a 	mov	r4,r16
 8210f34:	880b883a 	mov	r5,r17
 8210f38:	dfc00317 	ldw	ra,12(sp)
 8210f3c:	dc400217 	ldw	r17,8(sp)
 8210f40:	dc000117 	ldw	r16,4(sp)
 8210f44:	dec00404 	addi	sp,sp,16
 8210f48:	8210d581 	jmpi	8210d58 <__fputwc>
 8210f4c:	8009883a 	mov	r4,r16
 8210f50:	d9400015 	stw	r5,0(sp)
 8210f54:	820ae380 	call	820ae38 <__sinit>
 8210f58:	d9400017 	ldw	r5,0(sp)
 8210f5c:	003feb06 	br	8210f0c <fputwc+0x2c>

08210f60 <_fstat_r>:
 8210f60:	defffd04 	addi	sp,sp,-12
 8210f64:	2805883a 	mov	r2,r5
 8210f68:	dc000015 	stw	r16,0(sp)
 8210f6c:	04020974 	movhi	r16,2085
 8210f70:	dc400115 	stw	r17,4(sp)
 8210f74:	840ffa04 	addi	r16,r16,16360
 8210f78:	2023883a 	mov	r17,r4
 8210f7c:	300b883a 	mov	r5,r6
 8210f80:	1009883a 	mov	r4,r2
 8210f84:	dfc00215 	stw	ra,8(sp)
 8210f88:	80000015 	stw	zero,0(r16)
 8210f8c:	82144c80 	call	82144c8 <fstat>
 8210f90:	00ffffc4 	movi	r3,-1
 8210f94:	10c00526 	beq	r2,r3,8210fac <_fstat_r+0x4c>
 8210f98:	dfc00217 	ldw	ra,8(sp)
 8210f9c:	dc400117 	ldw	r17,4(sp)
 8210fa0:	dc000017 	ldw	r16,0(sp)
 8210fa4:	dec00304 	addi	sp,sp,12
 8210fa8:	f800283a 	ret
 8210fac:	80c00017 	ldw	r3,0(r16)
 8210fb0:	183ff926 	beq	r3,zero,8210f98 <_fstat_r+0x38>
 8210fb4:	88c00015 	stw	r3,0(r17)
 8210fb8:	003ff706 	br	8210f98 <_fstat_r+0x38>

08210fbc <_isatty_r>:
 8210fbc:	defffd04 	addi	sp,sp,-12
 8210fc0:	dc000015 	stw	r16,0(sp)
 8210fc4:	04020974 	movhi	r16,2085
 8210fc8:	dc400115 	stw	r17,4(sp)
 8210fcc:	840ffa04 	addi	r16,r16,16360
 8210fd0:	2023883a 	mov	r17,r4
 8210fd4:	2809883a 	mov	r4,r5
 8210fd8:	dfc00215 	stw	ra,8(sp)
 8210fdc:	80000015 	stw	zero,0(r16)
 8210fe0:	82145b40 	call	82145b4 <isatty>
 8210fe4:	00ffffc4 	movi	r3,-1
 8210fe8:	10c00526 	beq	r2,r3,8211000 <_isatty_r+0x44>
 8210fec:	dfc00217 	ldw	ra,8(sp)
 8210ff0:	dc400117 	ldw	r17,4(sp)
 8210ff4:	dc000017 	ldw	r16,0(sp)
 8210ff8:	dec00304 	addi	sp,sp,12
 8210ffc:	f800283a 	ret
 8211000:	80c00017 	ldw	r3,0(r16)
 8211004:	183ff926 	beq	r3,zero,8210fec <_isatty_r+0x30>
 8211008:	88c00015 	stw	r3,0(r17)
 821100c:	003ff706 	br	8210fec <_isatty_r+0x30>

08211010 <_lseek_r>:
 8211010:	defffd04 	addi	sp,sp,-12
 8211014:	2805883a 	mov	r2,r5
 8211018:	dc000015 	stw	r16,0(sp)
 821101c:	04020974 	movhi	r16,2085
 8211020:	dc400115 	stw	r17,4(sp)
 8211024:	300b883a 	mov	r5,r6
 8211028:	840ffa04 	addi	r16,r16,16360
 821102c:	2023883a 	mov	r17,r4
 8211030:	380d883a 	mov	r6,r7
 8211034:	1009883a 	mov	r4,r2
 8211038:	dfc00215 	stw	ra,8(sp)
 821103c:	80000015 	stw	zero,0(r16)
 8211040:	82146940 	call	8214694 <lseek>
 8211044:	00ffffc4 	movi	r3,-1
 8211048:	10c00526 	beq	r2,r3,8211060 <_lseek_r+0x50>
 821104c:	dfc00217 	ldw	ra,8(sp)
 8211050:	dc400117 	ldw	r17,4(sp)
 8211054:	dc000017 	ldw	r16,0(sp)
 8211058:	dec00304 	addi	sp,sp,12
 821105c:	f800283a 	ret
 8211060:	80c00017 	ldw	r3,0(r16)
 8211064:	183ff926 	beq	r3,zero,821104c <_lseek_r+0x3c>
 8211068:	88c00015 	stw	r3,0(r17)
 821106c:	003ff706 	br	821104c <_lseek_r+0x3c>

08211070 <_read_r>:
 8211070:	defffd04 	addi	sp,sp,-12
 8211074:	2805883a 	mov	r2,r5
 8211078:	dc000015 	stw	r16,0(sp)
 821107c:	04020974 	movhi	r16,2085
 8211080:	dc400115 	stw	r17,4(sp)
 8211084:	300b883a 	mov	r5,r6
 8211088:	840ffa04 	addi	r16,r16,16360
 821108c:	2023883a 	mov	r17,r4
 8211090:	380d883a 	mov	r6,r7
 8211094:	1009883a 	mov	r4,r2
 8211098:	dfc00215 	stw	ra,8(sp)
 821109c:	80000015 	stw	zero,0(r16)
 82110a0:	82259c80 	call	82259c8 <read>
 82110a4:	00ffffc4 	movi	r3,-1
 82110a8:	10c00526 	beq	r2,r3,82110c0 <_read_r+0x50>
 82110ac:	dfc00217 	ldw	ra,8(sp)
 82110b0:	dc400117 	ldw	r17,4(sp)
 82110b4:	dc000017 	ldw	r16,0(sp)
 82110b8:	dec00304 	addi	sp,sp,12
 82110bc:	f800283a 	ret
 82110c0:	80c00017 	ldw	r3,0(r16)
 82110c4:	183ff926 	beq	r3,zero,82110ac <_read_r+0x3c>
 82110c8:	88c00015 	stw	r3,0(r17)
 82110cc:	003ff706 	br	82110ac <_read_r+0x3c>

082110d0 <_wcrtomb_r>:
 82110d0:	defff604 	addi	sp,sp,-40
 82110d4:	00820974 	movhi	r2,2085
 82110d8:	dc800815 	stw	r18,32(sp)
 82110dc:	dc400715 	stw	r17,28(sp)
 82110e0:	dc000615 	stw	r16,24(sp)
 82110e4:	108f9d04 	addi	r2,r2,15988
 82110e8:	dfc00915 	stw	ra,36(sp)
 82110ec:	2021883a 	mov	r16,r4
 82110f0:	3823883a 	mov	r17,r7
 82110f4:	14800017 	ldw	r18,0(r2)
 82110f8:	28001426 	beq	r5,zero,821114c <_wcrtomb_r+0x7c>
 82110fc:	d9400415 	stw	r5,16(sp)
 8211100:	d9800515 	stw	r6,20(sp)
 8211104:	820bad00 	call	820bad0 <__locale_charset>
 8211108:	d9800517 	ldw	r6,20(sp)
 821110c:	d9400417 	ldw	r5,16(sp)
 8211110:	100f883a 	mov	r7,r2
 8211114:	dc400015 	stw	r17,0(sp)
 8211118:	8009883a 	mov	r4,r16
 821111c:	903ee83a 	callr	r18
 8211120:	00ffffc4 	movi	r3,-1
 8211124:	10c0031e 	bne	r2,r3,8211134 <_wcrtomb_r+0x64>
 8211128:	88000015 	stw	zero,0(r17)
 821112c:	00c02284 	movi	r3,138
 8211130:	80c00015 	stw	r3,0(r16)
 8211134:	dfc00917 	ldw	ra,36(sp)
 8211138:	dc800817 	ldw	r18,32(sp)
 821113c:	dc400717 	ldw	r17,28(sp)
 8211140:	dc000617 	ldw	r16,24(sp)
 8211144:	dec00a04 	addi	sp,sp,40
 8211148:	f800283a 	ret
 821114c:	820bad00 	call	820bad0 <__locale_charset>
 8211150:	100f883a 	mov	r7,r2
 8211154:	dc400015 	stw	r17,0(sp)
 8211158:	000d883a 	mov	r6,zero
 821115c:	d9400104 	addi	r5,sp,4
 8211160:	8009883a 	mov	r4,r16
 8211164:	903ee83a 	callr	r18
 8211168:	003fed06 	br	8211120 <_wcrtomb_r+0x50>

0821116c <wcrtomb>:
 821116c:	defff604 	addi	sp,sp,-40
 8211170:	00820974 	movhi	r2,2085
 8211174:	dc800615 	stw	r18,24(sp)
 8211178:	dc400515 	stw	r17,20(sp)
 821117c:	108f9904 	addi	r2,r2,15972
 8211180:	dfc00915 	stw	ra,36(sp)
 8211184:	dd000815 	stw	r20,32(sp)
 8211188:	dcc00715 	stw	r19,28(sp)
 821118c:	dc000415 	stw	r16,16(sp)
 8211190:	3025883a 	mov	r18,r6
 8211194:	14400017 	ldw	r17,0(r2)
 8211198:	20001926 	beq	r4,zero,8211200 <wcrtomb+0x94>
 821119c:	00820974 	movhi	r2,2085
 82111a0:	108f9d04 	addi	r2,r2,15988
 82111a4:	15000017 	ldw	r20,0(r2)
 82111a8:	2021883a 	mov	r16,r4
 82111ac:	2827883a 	mov	r19,r5
 82111b0:	820bad00 	call	820bad0 <__locale_charset>
 82111b4:	100f883a 	mov	r7,r2
 82111b8:	dc800015 	stw	r18,0(sp)
 82111bc:	980d883a 	mov	r6,r19
 82111c0:	800b883a 	mov	r5,r16
 82111c4:	8809883a 	mov	r4,r17
 82111c8:	a03ee83a 	callr	r20
 82111cc:	00ffffc4 	movi	r3,-1
 82111d0:	10c0031e 	bne	r2,r3,82111e0 <wcrtomb+0x74>
 82111d4:	90000015 	stw	zero,0(r18)
 82111d8:	00c02284 	movi	r3,138
 82111dc:	88c00015 	stw	r3,0(r17)
 82111e0:	dfc00917 	ldw	ra,36(sp)
 82111e4:	dd000817 	ldw	r20,32(sp)
 82111e8:	dcc00717 	ldw	r19,28(sp)
 82111ec:	dc800617 	ldw	r18,24(sp)
 82111f0:	dc400517 	ldw	r17,20(sp)
 82111f4:	dc000417 	ldw	r16,16(sp)
 82111f8:	dec00a04 	addi	sp,sp,40
 82111fc:	f800283a 	ret
 8211200:	00820974 	movhi	r2,2085
 8211204:	108f9d04 	addi	r2,r2,15988
 8211208:	14000017 	ldw	r16,0(r2)
 821120c:	820bad00 	call	820bad0 <__locale_charset>
 8211210:	100f883a 	mov	r7,r2
 8211214:	dc800015 	stw	r18,0(sp)
 8211218:	000d883a 	mov	r6,zero
 821121c:	d9400104 	addi	r5,sp,4
 8211220:	8809883a 	mov	r4,r17
 8211224:	803ee83a 	callr	r16
 8211228:	003fe806 	br	82111cc <wcrtomb+0x60>

0821122c <__ascii_wctomb>:
 821122c:	28000526 	beq	r5,zero,8211244 <__ascii_wctomb+0x18>
 8211230:	00803fc4 	movi	r2,255
 8211234:	11800536 	bltu	r2,r6,821124c <__ascii_wctomb+0x20>
 8211238:	29800005 	stb	r6,0(r5)
 821123c:	00800044 	movi	r2,1
 8211240:	f800283a 	ret
 8211244:	0005883a 	mov	r2,zero
 8211248:	f800283a 	ret
 821124c:	00802284 	movi	r2,138
 8211250:	20800015 	stw	r2,0(r4)
 8211254:	00bfffc4 	movi	r2,-1
 8211258:	f800283a 	ret

0821125c <_wctomb_r>:
 821125c:	00820974 	movhi	r2,2085
 8211260:	defff904 	addi	sp,sp,-28
 8211264:	108f9d04 	addi	r2,r2,15988
 8211268:	dfc00615 	stw	ra,24(sp)
 821126c:	dc400515 	stw	r17,20(sp)
 8211270:	dc000415 	stw	r16,16(sp)
 8211274:	3823883a 	mov	r17,r7
 8211278:	14000017 	ldw	r16,0(r2)
 821127c:	d9000115 	stw	r4,4(sp)
 8211280:	d9400215 	stw	r5,8(sp)
 8211284:	d9800315 	stw	r6,12(sp)
 8211288:	820bad00 	call	820bad0 <__locale_charset>
 821128c:	d9800317 	ldw	r6,12(sp)
 8211290:	d9400217 	ldw	r5,8(sp)
 8211294:	d9000117 	ldw	r4,4(sp)
 8211298:	100f883a 	mov	r7,r2
 821129c:	dc400015 	stw	r17,0(sp)
 82112a0:	803ee83a 	callr	r16
 82112a4:	dfc00617 	ldw	ra,24(sp)
 82112a8:	dc400517 	ldw	r17,20(sp)
 82112ac:	dc000417 	ldw	r16,16(sp)
 82112b0:	dec00704 	addi	sp,sp,28
 82112b4:	f800283a 	ret

082112b8 <__udivdi3>:
 82112b8:	defff504 	addi	sp,sp,-44
 82112bc:	dcc00415 	stw	r19,16(sp)
 82112c0:	dc000115 	stw	r16,4(sp)
 82112c4:	dfc00a15 	stw	ra,40(sp)
 82112c8:	df000915 	stw	fp,36(sp)
 82112cc:	ddc00815 	stw	r23,32(sp)
 82112d0:	dd800715 	stw	r22,28(sp)
 82112d4:	dd400615 	stw	r21,24(sp)
 82112d8:	dd000515 	stw	r20,20(sp)
 82112dc:	dc800315 	stw	r18,12(sp)
 82112e0:	dc400215 	stw	r17,8(sp)
 82112e4:	2027883a 	mov	r19,r4
 82112e8:	2821883a 	mov	r16,r5
 82112ec:	3800411e 	bne	r7,zero,82113f4 <__udivdi3+0x13c>
 82112f0:	3023883a 	mov	r17,r6
 82112f4:	2025883a 	mov	r18,r4
 82112f8:	2980522e 	bgeu	r5,r6,8211444 <__udivdi3+0x18c>
 82112fc:	00bfffd4 	movui	r2,65535
 8211300:	282d883a 	mov	r22,r5
 8211304:	1180a836 	bltu	r2,r6,82115a8 <__udivdi3+0x2f0>
 8211308:	00803fc4 	movi	r2,255
 821130c:	1185803a 	cmpltu	r2,r2,r6
 8211310:	100490fa 	slli	r2,r2,3
 8211314:	3086d83a 	srl	r3,r6,r2
 8211318:	01020974 	movhi	r4,2085
 821131c:	21373b04 	addi	r4,r4,-8980
 8211320:	20c7883a 	add	r3,r4,r3
 8211324:	18c00003 	ldbu	r3,0(r3)
 8211328:	1885883a 	add	r2,r3,r2
 821132c:	00c00804 	movi	r3,32
 8211330:	1887c83a 	sub	r3,r3,r2
 8211334:	18000526 	beq	r3,zero,821134c <__udivdi3+0x94>
 8211338:	80e0983a 	sll	r16,r16,r3
 821133c:	9884d83a 	srl	r2,r19,r2
 8211340:	30e2983a 	sll	r17,r6,r3
 8211344:	98e4983a 	sll	r18,r19,r3
 8211348:	142cb03a 	or	r22,r2,r16
 821134c:	882ad43a 	srli	r21,r17,16
 8211350:	b009883a 	mov	r4,r22
 8211354:	8d3fffcc 	andi	r20,r17,65535
 8211358:	a80b883a 	mov	r5,r21
 821135c:	8202c740 	call	8202c74 <__umodsi3>
 8211360:	b009883a 	mov	r4,r22
 8211364:	a80b883a 	mov	r5,r21
 8211368:	1027883a 	mov	r19,r2
 821136c:	8202c100 	call	8202c10 <__udivsi3>
 8211370:	102d883a 	mov	r22,r2
 8211374:	9826943a 	slli	r19,r19,16
 8211378:	9004d43a 	srli	r2,r18,16
 821137c:	a5a1383a 	mul	r16,r20,r22
 8211380:	14c4b03a 	or	r2,r2,r19
 8211384:	1400052e 	bgeu	r2,r16,821139c <__udivdi3+0xe4>
 8211388:	1445883a 	add	r2,r2,r17
 821138c:	b0ffffc4 	addi	r3,r22,-1
 8211390:	14400136 	bltu	r2,r17,8211398 <__udivdi3+0xe0>
 8211394:	14012336 	bltu	r2,r16,8211824 <__udivdi3+0x56c>
 8211398:	182d883a 	mov	r22,r3
 821139c:	1421c83a 	sub	r16,r2,r16
 82113a0:	a80b883a 	mov	r5,r21
 82113a4:	8009883a 	mov	r4,r16
 82113a8:	8202c740 	call	8202c74 <__umodsi3>
 82113ac:	1027883a 	mov	r19,r2
 82113b0:	a80b883a 	mov	r5,r21
 82113b4:	8009883a 	mov	r4,r16
 82113b8:	8202c100 	call	8202c10 <__udivsi3>
 82113bc:	9826943a 	slli	r19,r19,16
 82113c0:	a0a9383a 	mul	r20,r20,r2
 82113c4:	94bfffcc 	andi	r18,r18,65535
 82113c8:	94e4b03a 	or	r18,r18,r19
 82113cc:	9500052e 	bgeu	r18,r20,82113e4 <__udivdi3+0x12c>
 82113d0:	8ca5883a 	add	r18,r17,r18
 82113d4:	10ffffc4 	addi	r3,r2,-1
 82113d8:	9440f136 	bltu	r18,r17,82117a0 <__udivdi3+0x4e8>
 82113dc:	9500f02e 	bgeu	r18,r20,82117a0 <__udivdi3+0x4e8>
 82113e0:	10bfff84 	addi	r2,r2,-2
 82113e4:	b00c943a 	slli	r6,r22,16
 82113e8:	0007883a 	mov	r3,zero
 82113ec:	3084b03a 	or	r2,r6,r2
 82113f0:	00005906 	br	8211558 <__udivdi3+0x2a0>
 82113f4:	29c05636 	bltu	r5,r7,8211550 <__udivdi3+0x298>
 82113f8:	00bfffd4 	movui	r2,65535
 82113fc:	11c0622e 	bgeu	r2,r7,8211588 <__udivdi3+0x2d0>
 8211400:	00804034 	movhi	r2,256
 8211404:	10bfffc4 	addi	r2,r2,-1
 8211408:	11c0ee36 	bltu	r2,r7,82117c4 <__udivdi3+0x50c>
 821140c:	00800404 	movi	r2,16
 8211410:	3886d83a 	srl	r3,r7,r2
 8211414:	01020974 	movhi	r4,2085
 8211418:	21373b04 	addi	r4,r4,-8980
 821141c:	20c7883a 	add	r3,r4,r3
 8211420:	18c00003 	ldbu	r3,0(r3)
 8211424:	05400804 	movi	r21,32
 8211428:	1885883a 	add	r2,r3,r2
 821142c:	a8abc83a 	sub	r21,r21,r2
 8211430:	a800621e 	bne	r21,zero,82115bc <__udivdi3+0x304>
 8211434:	3c00e936 	bltu	r7,r16,82117dc <__udivdi3+0x524>
 8211438:	9985403a 	cmpgeu	r2,r19,r6
 821143c:	0007883a 	mov	r3,zero
 8211440:	00004506 	br	8211558 <__udivdi3+0x2a0>
 8211444:	3000041e 	bne	r6,zero,8211458 <__udivdi3+0x1a0>
 8211448:	000b883a 	mov	r5,zero
 821144c:	01000044 	movi	r4,1
 8211450:	8202c100 	call	8202c10 <__udivsi3>
 8211454:	1023883a 	mov	r17,r2
 8211458:	00bfffd4 	movui	r2,65535
 821145c:	14404e2e 	bgeu	r2,r17,8211598 <__udivdi3+0x2e0>
 8211460:	00804034 	movhi	r2,256
 8211464:	10bfffc4 	addi	r2,r2,-1
 8211468:	1440d836 	bltu	r2,r17,82117cc <__udivdi3+0x514>
 821146c:	00800404 	movi	r2,16
 8211470:	8886d83a 	srl	r3,r17,r2
 8211474:	01020974 	movhi	r4,2085
 8211478:	21373b04 	addi	r4,r4,-8980
 821147c:	20c7883a 	add	r3,r4,r3
 8211480:	18c00003 	ldbu	r3,0(r3)
 8211484:	1885883a 	add	r2,r3,r2
 8211488:	00c00804 	movi	r3,32
 821148c:	1887c83a 	sub	r3,r3,r2
 8211490:	18008f1e 	bne	r3,zero,82116d0 <__udivdi3+0x418>
 8211494:	882ad43a 	srli	r21,r17,16
 8211498:	8461c83a 	sub	r16,r16,r17
 821149c:	8d3fffcc 	andi	r20,r17,65535
 82114a0:	00c00044 	movi	r3,1
 82114a4:	8009883a 	mov	r4,r16
 82114a8:	a80b883a 	mov	r5,r21
 82114ac:	d8c00015 	stw	r3,0(sp)
 82114b0:	8202c740 	call	8202c74 <__umodsi3>
 82114b4:	8009883a 	mov	r4,r16
 82114b8:	a80b883a 	mov	r5,r21
 82114bc:	1027883a 	mov	r19,r2
 82114c0:	8202c100 	call	8202c10 <__udivsi3>
 82114c4:	9826943a 	slli	r19,r19,16
 82114c8:	9008d43a 	srli	r4,r18,16
 82114cc:	1521383a 	mul	r16,r2,r20
 82114d0:	102d883a 	mov	r22,r2
 82114d4:	24c8b03a 	or	r4,r4,r19
 82114d8:	d8c00017 	ldw	r3,0(sp)
 82114dc:	2400052e 	bgeu	r4,r16,82114f4 <__udivdi3+0x23c>
 82114e0:	2449883a 	add	r4,r4,r17
 82114e4:	b0bfffc4 	addi	r2,r22,-1
 82114e8:	24400136 	bltu	r4,r17,82114f0 <__udivdi3+0x238>
 82114ec:	2400ca36 	bltu	r4,r16,8211818 <__udivdi3+0x560>
 82114f0:	102d883a 	mov	r22,r2
 82114f4:	2421c83a 	sub	r16,r4,r16
 82114f8:	a80b883a 	mov	r5,r21
 82114fc:	8009883a 	mov	r4,r16
 8211500:	d8c00015 	stw	r3,0(sp)
 8211504:	8202c740 	call	8202c74 <__umodsi3>
 8211508:	1027883a 	mov	r19,r2
 821150c:	a80b883a 	mov	r5,r21
 8211510:	8009883a 	mov	r4,r16
 8211514:	8202c100 	call	8202c10 <__udivsi3>
 8211518:	9826943a 	slli	r19,r19,16
 821151c:	1529383a 	mul	r20,r2,r20
 8211520:	94bfffcc 	andi	r18,r18,65535
 8211524:	94e4b03a 	or	r18,r18,r19
 8211528:	d8c00017 	ldw	r3,0(sp)
 821152c:	9500052e 	bgeu	r18,r20,8211544 <__udivdi3+0x28c>
 8211530:	8ca5883a 	add	r18,r17,r18
 8211534:	113fffc4 	addi	r4,r2,-1
 8211538:	94409736 	bltu	r18,r17,8211798 <__udivdi3+0x4e0>
 821153c:	9500962e 	bgeu	r18,r20,8211798 <__udivdi3+0x4e0>
 8211540:	10bfff84 	addi	r2,r2,-2
 8211544:	b00c943a 	slli	r6,r22,16
 8211548:	3084b03a 	or	r2,r6,r2
 821154c:	00000206 	br	8211558 <__udivdi3+0x2a0>
 8211550:	0007883a 	mov	r3,zero
 8211554:	0005883a 	mov	r2,zero
 8211558:	dfc00a17 	ldw	ra,40(sp)
 821155c:	df000917 	ldw	fp,36(sp)
 8211560:	ddc00817 	ldw	r23,32(sp)
 8211564:	dd800717 	ldw	r22,28(sp)
 8211568:	dd400617 	ldw	r21,24(sp)
 821156c:	dd000517 	ldw	r20,20(sp)
 8211570:	dcc00417 	ldw	r19,16(sp)
 8211574:	dc800317 	ldw	r18,12(sp)
 8211578:	dc400217 	ldw	r17,8(sp)
 821157c:	dc000117 	ldw	r16,4(sp)
 8211580:	dec00b04 	addi	sp,sp,44
 8211584:	f800283a 	ret
 8211588:	00803fc4 	movi	r2,255
 821158c:	11c5803a 	cmpltu	r2,r2,r7
 8211590:	100490fa 	slli	r2,r2,3
 8211594:	003f9e06 	br	8211410 <__udivdi3+0x158>
 8211598:	00803fc4 	movi	r2,255
 821159c:	1445803a 	cmpltu	r2,r2,r17
 82115a0:	100490fa 	slli	r2,r2,3
 82115a4:	003fb206 	br	8211470 <__udivdi3+0x1b8>
 82115a8:	00804034 	movhi	r2,256
 82115ac:	10bfffc4 	addi	r2,r2,-1
 82115b0:	11808836 	bltu	r2,r6,82117d4 <__udivdi3+0x51c>
 82115b4:	00800404 	movi	r2,16
 82115b8:	003f5606 	br	8211314 <__udivdi3+0x5c>
 82115bc:	30aed83a 	srl	r23,r6,r2
 82115c0:	3d4e983a 	sll	r7,r7,r21
 82115c4:	80acd83a 	srl	r22,r16,r2
 82115c8:	9884d83a 	srl	r2,r19,r2
 82115cc:	3deeb03a 	or	r23,r7,r23
 82115d0:	b824d43a 	srli	r18,r23,16
 82115d4:	8560983a 	sll	r16,r16,r21
 82115d8:	b009883a 	mov	r4,r22
 82115dc:	900b883a 	mov	r5,r18
 82115e0:	3568983a 	sll	r20,r6,r21
 82115e4:	1420b03a 	or	r16,r2,r16
 82115e8:	8202c740 	call	8202c74 <__umodsi3>
 82115ec:	b009883a 	mov	r4,r22
 82115f0:	900b883a 	mov	r5,r18
 82115f4:	1023883a 	mov	r17,r2
 82115f8:	8202c100 	call	8202c10 <__udivsi3>
 82115fc:	8808943a 	slli	r4,r17,16
 8211600:	bf3fffcc 	andi	fp,r23,65535
 8211604:	8006d43a 	srli	r3,r16,16
 8211608:	e0a3383a 	mul	r17,fp,r2
 821160c:	100d883a 	mov	r6,r2
 8211610:	1906b03a 	or	r3,r3,r4
 8211614:	1c40042e 	bgeu	r3,r17,8211628 <__udivdi3+0x370>
 8211618:	1dc7883a 	add	r3,r3,r23
 821161c:	10bfffc4 	addi	r2,r2,-1
 8211620:	1dc0752e 	bgeu	r3,r23,82117f8 <__udivdi3+0x540>
 8211624:	100d883a 	mov	r6,r2
 8211628:	1c63c83a 	sub	r17,r3,r17
 821162c:	900b883a 	mov	r5,r18
 8211630:	8809883a 	mov	r4,r17
 8211634:	d9800015 	stw	r6,0(sp)
 8211638:	8202c740 	call	8202c74 <__umodsi3>
 821163c:	102d883a 	mov	r22,r2
 8211640:	8809883a 	mov	r4,r17
 8211644:	900b883a 	mov	r5,r18
 8211648:	8202c100 	call	8202c10 <__udivsi3>
 821164c:	b02c943a 	slli	r22,r22,16
 8211650:	e089383a 	mul	r4,fp,r2
 8211654:	843fffcc 	andi	r16,r16,65535
 8211658:	85a0b03a 	or	r16,r16,r22
 821165c:	d9800017 	ldw	r6,0(sp)
 8211660:	8100042e 	bgeu	r16,r4,8211674 <__udivdi3+0x3bc>
 8211664:	85e1883a 	add	r16,r16,r23
 8211668:	10ffffc4 	addi	r3,r2,-1
 821166c:	85c05e2e 	bgeu	r16,r23,82117e8 <__udivdi3+0x530>
 8211670:	1805883a 	mov	r2,r3
 8211674:	300c943a 	slli	r6,r6,16
 8211678:	a17fffcc 	andi	r5,r20,65535
 821167c:	a028d43a 	srli	r20,r20,16
 8211680:	3084b03a 	or	r2,r6,r2
 8211684:	10ffffcc 	andi	r3,r2,65535
 8211688:	100cd43a 	srli	r6,r2,16
 821168c:	194f383a 	mul	r7,r3,r5
 8211690:	1d07383a 	mul	r3,r3,r20
 8211694:	314b383a 	mul	r5,r6,r5
 8211698:	3810d43a 	srli	r8,r7,16
 821169c:	8121c83a 	sub	r16,r16,r4
 82116a0:	1947883a 	add	r3,r3,r5
 82116a4:	40c7883a 	add	r3,r8,r3
 82116a8:	350d383a 	mul	r6,r6,r20
 82116ac:	1940022e 	bgeu	r3,r5,82116b8 <__udivdi3+0x400>
 82116b0:	01000074 	movhi	r4,1
 82116b4:	310d883a 	add	r6,r6,r4
 82116b8:	1828d43a 	srli	r20,r3,16
 82116bc:	a18d883a 	add	r6,r20,r6
 82116c0:	81803e36 	bltu	r16,r6,82117bc <__udivdi3+0x504>
 82116c4:	81803826 	beq	r16,r6,82117a8 <__udivdi3+0x4f0>
 82116c8:	0007883a 	mov	r3,zero
 82116cc:	003fa206 	br	8211558 <__udivdi3+0x2a0>
 82116d0:	88e2983a 	sll	r17,r17,r3
 82116d4:	80a8d83a 	srl	r20,r16,r2
 82116d8:	80e0983a 	sll	r16,r16,r3
 82116dc:	882ad43a 	srli	r21,r17,16
 82116e0:	9884d83a 	srl	r2,r19,r2
 82116e4:	a009883a 	mov	r4,r20
 82116e8:	a80b883a 	mov	r5,r21
 82116ec:	142eb03a 	or	r23,r2,r16
 82116f0:	98e4983a 	sll	r18,r19,r3
 82116f4:	8202c740 	call	8202c74 <__umodsi3>
 82116f8:	a009883a 	mov	r4,r20
 82116fc:	a80b883a 	mov	r5,r21
 8211700:	1021883a 	mov	r16,r2
 8211704:	8202c100 	call	8202c10 <__udivsi3>
 8211708:	1039883a 	mov	fp,r2
 821170c:	8d3fffcc 	andi	r20,r17,65535
 8211710:	8020943a 	slli	r16,r16,16
 8211714:	b804d43a 	srli	r2,r23,16
 8211718:	a72d383a 	mul	r22,r20,fp
 821171c:	1404b03a 	or	r2,r2,r16
 8211720:	1580062e 	bgeu	r2,r22,821173c <__udivdi3+0x484>
 8211724:	1445883a 	add	r2,r2,r17
 8211728:	e0ffffc4 	addi	r3,fp,-1
 821172c:	14403836 	bltu	r2,r17,8211810 <__udivdi3+0x558>
 8211730:	1580372e 	bgeu	r2,r22,8211810 <__udivdi3+0x558>
 8211734:	e73fff84 	addi	fp,fp,-2
 8211738:	1445883a 	add	r2,r2,r17
 821173c:	15adc83a 	sub	r22,r2,r22
 8211740:	a80b883a 	mov	r5,r21
 8211744:	b009883a 	mov	r4,r22
 8211748:	8202c740 	call	8202c74 <__umodsi3>
 821174c:	1027883a 	mov	r19,r2
 8211750:	b009883a 	mov	r4,r22
 8211754:	a80b883a 	mov	r5,r21
 8211758:	8202c100 	call	8202c10 <__udivsi3>
 821175c:	9826943a 	slli	r19,r19,16
 8211760:	a0a1383a 	mul	r16,r20,r2
 8211764:	b93fffcc 	andi	r4,r23,65535
 8211768:	24c8b03a 	or	r4,r4,r19
 821176c:	2400062e 	bgeu	r4,r16,8211788 <__udivdi3+0x4d0>
 8211770:	2449883a 	add	r4,r4,r17
 8211774:	10ffffc4 	addi	r3,r2,-1
 8211778:	24402336 	bltu	r4,r17,8211808 <__udivdi3+0x550>
 821177c:	2400222e 	bgeu	r4,r16,8211808 <__udivdi3+0x550>
 8211780:	10bfff84 	addi	r2,r2,-2
 8211784:	2449883a 	add	r4,r4,r17
 8211788:	e038943a 	slli	fp,fp,16
 821178c:	2421c83a 	sub	r16,r4,r16
 8211790:	e086b03a 	or	r3,fp,r2
 8211794:	003f4306 	br	82114a4 <__udivdi3+0x1ec>
 8211798:	2005883a 	mov	r2,r4
 821179c:	003f6906 	br	8211544 <__udivdi3+0x28c>
 82117a0:	1805883a 	mov	r2,r3
 82117a4:	003f0f06 	br	82113e4 <__udivdi3+0x12c>
 82117a8:	1806943a 	slli	r3,r3,16
 82117ac:	9d66983a 	sll	r19,r19,r21
 82117b0:	39ffffcc 	andi	r7,r7,65535
 82117b4:	19c7883a 	add	r3,r3,r7
 82117b8:	98ffc32e 	bgeu	r19,r3,82116c8 <__udivdi3+0x410>
 82117bc:	10bfffc4 	addi	r2,r2,-1
 82117c0:	003fc106 	br	82116c8 <__udivdi3+0x410>
 82117c4:	00800604 	movi	r2,24
 82117c8:	003f1106 	br	8211410 <__udivdi3+0x158>
 82117cc:	00800604 	movi	r2,24
 82117d0:	003f2706 	br	8211470 <__udivdi3+0x1b8>
 82117d4:	00800604 	movi	r2,24
 82117d8:	003ece06 	br	8211314 <__udivdi3+0x5c>
 82117dc:	0007883a 	mov	r3,zero
 82117e0:	00800044 	movi	r2,1
 82117e4:	003f5c06 	br	8211558 <__udivdi3+0x2a0>
 82117e8:	813fa12e 	bgeu	r16,r4,8211670 <__udivdi3+0x3b8>
 82117ec:	10bfff84 	addi	r2,r2,-2
 82117f0:	85e1883a 	add	r16,r16,r23
 82117f4:	003f9f06 	br	8211674 <__udivdi3+0x3bc>
 82117f8:	1c7f8a2e 	bgeu	r3,r17,8211624 <__udivdi3+0x36c>
 82117fc:	31bfff84 	addi	r6,r6,-2
 8211800:	1dc7883a 	add	r3,r3,r23
 8211804:	003f8806 	br	8211628 <__udivdi3+0x370>
 8211808:	1805883a 	mov	r2,r3
 821180c:	003fde06 	br	8211788 <__udivdi3+0x4d0>
 8211810:	1839883a 	mov	fp,r3
 8211814:	003fc906 	br	821173c <__udivdi3+0x484>
 8211818:	b5bfff84 	addi	r22,r22,-2
 821181c:	2449883a 	add	r4,r4,r17
 8211820:	003f3406 	br	82114f4 <__udivdi3+0x23c>
 8211824:	b5bfff84 	addi	r22,r22,-2
 8211828:	1445883a 	add	r2,r2,r17
 821182c:	003edb06 	br	821139c <__udivdi3+0xe4>

08211830 <__umoddi3>:
 8211830:	defff404 	addi	sp,sp,-48
 8211834:	df000a15 	stw	fp,40(sp)
 8211838:	dc400315 	stw	r17,12(sp)
 821183c:	dc000215 	stw	r16,8(sp)
 8211840:	dfc00b15 	stw	ra,44(sp)
 8211844:	ddc00915 	stw	r23,36(sp)
 8211848:	dd800815 	stw	r22,32(sp)
 821184c:	dd400715 	stw	r21,28(sp)
 8211850:	dd000615 	stw	r20,24(sp)
 8211854:	dcc00515 	stw	r19,20(sp)
 8211858:	dc800415 	stw	r18,16(sp)
 821185c:	2021883a 	mov	r16,r4
 8211860:	2823883a 	mov	r17,r5
 8211864:	2839883a 	mov	fp,r5
 8211868:	38003c1e 	bne	r7,zero,821195c <__umoddi3+0x12c>
 821186c:	3027883a 	mov	r19,r6
 8211870:	2029883a 	mov	r20,r4
 8211874:	2980512e 	bgeu	r5,r6,82119bc <__umoddi3+0x18c>
 8211878:	00bfffd4 	movui	r2,65535
 821187c:	11809a36 	bltu	r2,r6,8211ae8 <__umoddi3+0x2b8>
 8211880:	01003fc4 	movi	r4,255
 8211884:	2189803a 	cmpltu	r4,r4,r6
 8211888:	200890fa 	slli	r4,r4,3
 821188c:	3104d83a 	srl	r2,r6,r4
 8211890:	00c20974 	movhi	r3,2085
 8211894:	18f73b04 	addi	r3,r3,-8980
 8211898:	1885883a 	add	r2,r3,r2
 821189c:	10c00003 	ldbu	r3,0(r2)
 82118a0:	00800804 	movi	r2,32
 82118a4:	1909883a 	add	r4,r3,r4
 82118a8:	1125c83a 	sub	r18,r2,r4
 82118ac:	90000526 	beq	r18,zero,82118c4 <__umoddi3+0x94>
 82118b0:	8ca2983a 	sll	r17,r17,r18
 82118b4:	8108d83a 	srl	r4,r16,r4
 82118b8:	34a6983a 	sll	r19,r6,r18
 82118bc:	84a8983a 	sll	r20,r16,r18
 82118c0:	2478b03a 	or	fp,r4,r17
 82118c4:	982ed43a 	srli	r23,r19,16
 82118c8:	e009883a 	mov	r4,fp
 82118cc:	9dbfffcc 	andi	r22,r19,65535
 82118d0:	b80b883a 	mov	r5,r23
 82118d4:	8202c740 	call	8202c74 <__umodsi3>
 82118d8:	e009883a 	mov	r4,fp
 82118dc:	b80b883a 	mov	r5,r23
 82118e0:	102b883a 	mov	r21,r2
 82118e4:	8202c100 	call	8202c10 <__udivsi3>
 82118e8:	a806943a 	slli	r3,r21,16
 82118ec:	a008d43a 	srli	r4,r20,16
 82118f0:	b085383a 	mul	r2,r22,r2
 82118f4:	20c8b03a 	or	r4,r4,r3
 82118f8:	2080032e 	bgeu	r4,r2,8211908 <__umoddi3+0xd8>
 82118fc:	24c9883a 	add	r4,r4,r19
 8211900:	24c00136 	bltu	r4,r19,8211908 <__umoddi3+0xd8>
 8211904:	20811036 	bltu	r4,r2,8211d48 <__umoddi3+0x518>
 8211908:	20abc83a 	sub	r21,r4,r2
 821190c:	b80b883a 	mov	r5,r23
 8211910:	a809883a 	mov	r4,r21
 8211914:	8202c740 	call	8202c74 <__umodsi3>
 8211918:	1023883a 	mov	r17,r2
 821191c:	b80b883a 	mov	r5,r23
 8211920:	a809883a 	mov	r4,r21
 8211924:	8202c100 	call	8202c10 <__udivsi3>
 8211928:	8822943a 	slli	r17,r17,16
 821192c:	b085383a 	mul	r2,r22,r2
 8211930:	a0ffffcc 	andi	r3,r20,65535
 8211934:	1c46b03a 	or	r3,r3,r17
 8211938:	1880042e 	bgeu	r3,r2,821194c <__umoddi3+0x11c>
 821193c:	1cc7883a 	add	r3,r3,r19
 8211940:	1cc00236 	bltu	r3,r19,821194c <__umoddi3+0x11c>
 8211944:	1880012e 	bgeu	r3,r2,821194c <__umoddi3+0x11c>
 8211948:	1cc7883a 	add	r3,r3,r19
 821194c:	1885c83a 	sub	r2,r3,r2
 8211950:	1484d83a 	srl	r2,r2,r18
 8211954:	0007883a 	mov	r3,zero
 8211958:	00004f06 	br	8211a98 <__umoddi3+0x268>
 821195c:	29c04c36 	bltu	r5,r7,8211a90 <__umoddi3+0x260>
 8211960:	00bfffd4 	movui	r2,65535
 8211964:	11c0582e 	bgeu	r2,r7,8211ac8 <__umoddi3+0x298>
 8211968:	00804034 	movhi	r2,256
 821196c:	10bfffc4 	addi	r2,r2,-1
 8211970:	11c0e736 	bltu	r2,r7,8211d10 <__umoddi3+0x4e0>
 8211974:	01000404 	movi	r4,16
 8211978:	3904d83a 	srl	r2,r7,r4
 821197c:	00c20974 	movhi	r3,2085
 8211980:	18f73b04 	addi	r3,r3,-8980
 8211984:	1885883a 	add	r2,r3,r2
 8211988:	14c00003 	ldbu	r19,0(r2)
 821198c:	00c00804 	movi	r3,32
 8211990:	9927883a 	add	r19,r19,r4
 8211994:	1ce9c83a 	sub	r20,r3,r19
 8211998:	a000581e 	bne	r20,zero,8211afc <__umoddi3+0x2cc>
 821199c:	3c400136 	bltu	r7,r17,82119a4 <__umoddi3+0x174>
 82119a0:	8180eb36 	bltu	r16,r6,8211d50 <__umoddi3+0x520>
 82119a4:	8185c83a 	sub	r2,r16,r6
 82119a8:	89e3c83a 	sub	r17,r17,r7
 82119ac:	8089803a 	cmpltu	r4,r16,r2
 82119b0:	8939c83a 	sub	fp,r17,r4
 82119b4:	e007883a 	mov	r3,fp
 82119b8:	00003706 	br	8211a98 <__umoddi3+0x268>
 82119bc:	3000041e 	bne	r6,zero,82119d0 <__umoddi3+0x1a0>
 82119c0:	000b883a 	mov	r5,zero
 82119c4:	01000044 	movi	r4,1
 82119c8:	8202c100 	call	8202c10 <__udivsi3>
 82119cc:	1027883a 	mov	r19,r2
 82119d0:	00bfffd4 	movui	r2,65535
 82119d4:	14c0402e 	bgeu	r2,r19,8211ad8 <__umoddi3+0x2a8>
 82119d8:	00804034 	movhi	r2,256
 82119dc:	10bfffc4 	addi	r2,r2,-1
 82119e0:	14c0cd36 	bltu	r2,r19,8211d18 <__umoddi3+0x4e8>
 82119e4:	00800404 	movi	r2,16
 82119e8:	9886d83a 	srl	r3,r19,r2
 82119ec:	01020974 	movhi	r4,2085
 82119f0:	21373b04 	addi	r4,r4,-8980
 82119f4:	20c7883a 	add	r3,r4,r3
 82119f8:	18c00003 	ldbu	r3,0(r3)
 82119fc:	1887883a 	add	r3,r3,r2
 8211a00:	00800804 	movi	r2,32
 8211a04:	10e5c83a 	sub	r18,r2,r3
 8211a08:	9000901e 	bne	r18,zero,8211c4c <__umoddi3+0x41c>
 8211a0c:	982cd43a 	srli	r22,r19,16
 8211a10:	8ce3c83a 	sub	r17,r17,r19
 8211a14:	9d7fffcc 	andi	r21,r19,65535
 8211a18:	b00b883a 	mov	r5,r22
 8211a1c:	8809883a 	mov	r4,r17
 8211a20:	8202c740 	call	8202c74 <__umodsi3>
 8211a24:	8809883a 	mov	r4,r17
 8211a28:	b00b883a 	mov	r5,r22
 8211a2c:	1021883a 	mov	r16,r2
 8211a30:	8202c100 	call	8202c10 <__udivsi3>
 8211a34:	8006943a 	slli	r3,r16,16
 8211a38:	a008d43a 	srli	r4,r20,16
 8211a3c:	1545383a 	mul	r2,r2,r21
 8211a40:	20c8b03a 	or	r4,r4,r3
 8211a44:	2080042e 	bgeu	r4,r2,8211a58 <__umoddi3+0x228>
 8211a48:	24c9883a 	add	r4,r4,r19
 8211a4c:	24c00236 	bltu	r4,r19,8211a58 <__umoddi3+0x228>
 8211a50:	2080012e 	bgeu	r4,r2,8211a58 <__umoddi3+0x228>
 8211a54:	24c9883a 	add	r4,r4,r19
 8211a58:	20a1c83a 	sub	r16,r4,r2
 8211a5c:	b00b883a 	mov	r5,r22
 8211a60:	8009883a 	mov	r4,r16
 8211a64:	8202c740 	call	8202c74 <__umodsi3>
 8211a68:	1023883a 	mov	r17,r2
 8211a6c:	b00b883a 	mov	r5,r22
 8211a70:	8009883a 	mov	r4,r16
 8211a74:	8202c100 	call	8202c10 <__udivsi3>
 8211a78:	8822943a 	slli	r17,r17,16
 8211a7c:	1545383a 	mul	r2,r2,r21
 8211a80:	a53fffcc 	andi	r20,r20,65535
 8211a84:	a446b03a 	or	r3,r20,r17
 8211a88:	18bfb02e 	bgeu	r3,r2,821194c <__umoddi3+0x11c>
 8211a8c:	003fab06 	br	821193c <__umoddi3+0x10c>
 8211a90:	2005883a 	mov	r2,r4
 8211a94:	2807883a 	mov	r3,r5
 8211a98:	dfc00b17 	ldw	ra,44(sp)
 8211a9c:	df000a17 	ldw	fp,40(sp)
 8211aa0:	ddc00917 	ldw	r23,36(sp)
 8211aa4:	dd800817 	ldw	r22,32(sp)
 8211aa8:	dd400717 	ldw	r21,28(sp)
 8211aac:	dd000617 	ldw	r20,24(sp)
 8211ab0:	dcc00517 	ldw	r19,20(sp)
 8211ab4:	dc800417 	ldw	r18,16(sp)
 8211ab8:	dc400317 	ldw	r17,12(sp)
 8211abc:	dc000217 	ldw	r16,8(sp)
 8211ac0:	dec00c04 	addi	sp,sp,48
 8211ac4:	f800283a 	ret
 8211ac8:	04c03fc4 	movi	r19,255
 8211acc:	99c9803a 	cmpltu	r4,r19,r7
 8211ad0:	200890fa 	slli	r4,r4,3
 8211ad4:	003fa806 	br	8211978 <__umoddi3+0x148>
 8211ad8:	00803fc4 	movi	r2,255
 8211adc:	14c5803a 	cmpltu	r2,r2,r19
 8211ae0:	100490fa 	slli	r2,r2,3
 8211ae4:	003fc006 	br	82119e8 <__umoddi3+0x1b8>
 8211ae8:	00804034 	movhi	r2,256
 8211aec:	10bfffc4 	addi	r2,r2,-1
 8211af0:	11808b36 	bltu	r2,r6,8211d20 <__umoddi3+0x4f0>
 8211af4:	01000404 	movi	r4,16
 8211af8:	003f6406 	br	821188c <__umoddi3+0x5c>
 8211afc:	34c4d83a 	srl	r2,r6,r19
 8211b00:	3d0e983a 	sll	r7,r7,r20
 8211b04:	8cf8d83a 	srl	fp,r17,r19
 8211b08:	8d10983a 	sll	r8,r17,r20
 8211b0c:	38aab03a 	or	r21,r7,r2
 8211b10:	a82cd43a 	srli	r22,r21,16
 8211b14:	84e2d83a 	srl	r17,r16,r19
 8211b18:	e009883a 	mov	r4,fp
 8211b1c:	b00b883a 	mov	r5,r22
 8211b20:	8a22b03a 	or	r17,r17,r8
 8211b24:	3524983a 	sll	r18,r6,r20
 8211b28:	8202c740 	call	8202c74 <__umodsi3>
 8211b2c:	e009883a 	mov	r4,fp
 8211b30:	b00b883a 	mov	r5,r22
 8211b34:	102f883a 	mov	r23,r2
 8211b38:	8202c100 	call	8202c10 <__udivsi3>
 8211b3c:	100d883a 	mov	r6,r2
 8211b40:	b808943a 	slli	r4,r23,16
 8211b44:	aa3fffcc 	andi	r8,r21,65535
 8211b48:	8804d43a 	srli	r2,r17,16
 8211b4c:	41af383a 	mul	r23,r8,r6
 8211b50:	8520983a 	sll	r16,r16,r20
 8211b54:	1104b03a 	or	r2,r2,r4
 8211b58:	15c0042e 	bgeu	r2,r23,8211b6c <__umoddi3+0x33c>
 8211b5c:	1545883a 	add	r2,r2,r21
 8211b60:	30ffffc4 	addi	r3,r6,-1
 8211b64:	1540742e 	bgeu	r2,r21,8211d38 <__umoddi3+0x508>
 8211b68:	180d883a 	mov	r6,r3
 8211b6c:	15efc83a 	sub	r23,r2,r23
 8211b70:	b00b883a 	mov	r5,r22
 8211b74:	b809883a 	mov	r4,r23
 8211b78:	d9800115 	stw	r6,4(sp)
 8211b7c:	da000015 	stw	r8,0(sp)
 8211b80:	8202c740 	call	8202c74 <__umodsi3>
 8211b84:	b00b883a 	mov	r5,r22
 8211b88:	b809883a 	mov	r4,r23
 8211b8c:	1039883a 	mov	fp,r2
 8211b90:	8202c100 	call	8202c10 <__udivsi3>
 8211b94:	da000017 	ldw	r8,0(sp)
 8211b98:	e038943a 	slli	fp,fp,16
 8211b9c:	100b883a 	mov	r5,r2
 8211ba0:	4089383a 	mul	r4,r8,r2
 8211ba4:	8a3fffcc 	andi	r8,r17,65535
 8211ba8:	4710b03a 	or	r8,r8,fp
 8211bac:	d9800117 	ldw	r6,4(sp)
 8211bb0:	4100042e 	bgeu	r8,r4,8211bc4 <__umoddi3+0x394>
 8211bb4:	4551883a 	add	r8,r8,r21
 8211bb8:	10bfffc4 	addi	r2,r2,-1
 8211bbc:	45405a2e 	bgeu	r8,r21,8211d28 <__umoddi3+0x4f8>
 8211bc0:	100b883a 	mov	r5,r2
 8211bc4:	300c943a 	slli	r6,r6,16
 8211bc8:	91ffffcc 	andi	r7,r18,65535
 8211bcc:	9004d43a 	srli	r2,r18,16
 8211bd0:	314cb03a 	or	r6,r6,r5
 8211bd4:	317fffcc 	andi	r5,r6,65535
 8211bd8:	300cd43a 	srli	r6,r6,16
 8211bdc:	29d3383a 	mul	r9,r5,r7
 8211be0:	288b383a 	mul	r5,r5,r2
 8211be4:	31cf383a 	mul	r7,r6,r7
 8211be8:	4806d43a 	srli	r3,r9,16
 8211bec:	4111c83a 	sub	r8,r8,r4
 8211bf0:	29cb883a 	add	r5,r5,r7
 8211bf4:	194b883a 	add	r5,r3,r5
 8211bf8:	3085383a 	mul	r2,r6,r2
 8211bfc:	29c0022e 	bgeu	r5,r7,8211c08 <__umoddi3+0x3d8>
 8211c00:	00c00074 	movhi	r3,1
 8211c04:	10c5883a 	add	r2,r2,r3
 8211c08:	2808d43a 	srli	r4,r5,16
 8211c0c:	280a943a 	slli	r5,r5,16
 8211c10:	4a7fffcc 	andi	r9,r9,65535
 8211c14:	2085883a 	add	r2,r4,r2
 8211c18:	2a4b883a 	add	r5,r5,r9
 8211c1c:	40803636 	bltu	r8,r2,8211cf8 <__umoddi3+0x4c8>
 8211c20:	40804d26 	beq	r8,r2,8211d58 <__umoddi3+0x528>
 8211c24:	4089c83a 	sub	r4,r8,r2
 8211c28:	280f883a 	mov	r7,r5
 8211c2c:	81cfc83a 	sub	r7,r16,r7
 8211c30:	81c7803a 	cmpltu	r3,r16,r7
 8211c34:	20c7c83a 	sub	r3,r4,r3
 8211c38:	1cc4983a 	sll	r2,r3,r19
 8211c3c:	3d0ed83a 	srl	r7,r7,r20
 8211c40:	1d06d83a 	srl	r3,r3,r20
 8211c44:	11c4b03a 	or	r2,r2,r7
 8211c48:	003f9306 	br	8211a98 <__umoddi3+0x268>
 8211c4c:	9ca6983a 	sll	r19,r19,r18
 8211c50:	88e8d83a 	srl	r20,r17,r3
 8211c54:	80c4d83a 	srl	r2,r16,r3
 8211c58:	982cd43a 	srli	r22,r19,16
 8211c5c:	8ca2983a 	sll	r17,r17,r18
 8211c60:	a009883a 	mov	r4,r20
 8211c64:	b00b883a 	mov	r5,r22
 8211c68:	1478b03a 	or	fp,r2,r17
 8211c6c:	8202c740 	call	8202c74 <__umodsi3>
 8211c70:	a009883a 	mov	r4,r20
 8211c74:	b00b883a 	mov	r5,r22
 8211c78:	1023883a 	mov	r17,r2
 8211c7c:	8202c100 	call	8202c10 <__udivsi3>
 8211c80:	9d7fffcc 	andi	r21,r19,65535
 8211c84:	880a943a 	slli	r5,r17,16
 8211c88:	e008d43a 	srli	r4,fp,16
 8211c8c:	a885383a 	mul	r2,r21,r2
 8211c90:	84a8983a 	sll	r20,r16,r18
 8211c94:	2148b03a 	or	r4,r4,r5
 8211c98:	2080042e 	bgeu	r4,r2,8211cac <__umoddi3+0x47c>
 8211c9c:	24c9883a 	add	r4,r4,r19
 8211ca0:	24c00236 	bltu	r4,r19,8211cac <__umoddi3+0x47c>
 8211ca4:	2080012e 	bgeu	r4,r2,8211cac <__umoddi3+0x47c>
 8211ca8:	24c9883a 	add	r4,r4,r19
 8211cac:	20a3c83a 	sub	r17,r4,r2
 8211cb0:	b00b883a 	mov	r5,r22
 8211cb4:	8809883a 	mov	r4,r17
 8211cb8:	8202c740 	call	8202c74 <__umodsi3>
 8211cbc:	102f883a 	mov	r23,r2
 8211cc0:	8809883a 	mov	r4,r17
 8211cc4:	b00b883a 	mov	r5,r22
 8211cc8:	8202c100 	call	8202c10 <__udivsi3>
 8211ccc:	b82e943a 	slli	r23,r23,16
 8211cd0:	a885383a 	mul	r2,r21,r2
 8211cd4:	e13fffcc 	andi	r4,fp,65535
 8211cd8:	25c8b03a 	or	r4,r4,r23
 8211cdc:	2080042e 	bgeu	r4,r2,8211cf0 <__umoddi3+0x4c0>
 8211ce0:	24c9883a 	add	r4,r4,r19
 8211ce4:	24c00236 	bltu	r4,r19,8211cf0 <__umoddi3+0x4c0>
 8211ce8:	2080012e 	bgeu	r4,r2,8211cf0 <__umoddi3+0x4c0>
 8211cec:	24c9883a 	add	r4,r4,r19
 8211cf0:	20a3c83a 	sub	r17,r4,r2
 8211cf4:	003f4806 	br	8211a18 <__umoddi3+0x1e8>
 8211cf8:	2c8fc83a 	sub	r7,r5,r18
 8211cfc:	1545c83a 	sub	r2,r2,r21
 8211d00:	29cb803a 	cmpltu	r5,r5,r7
 8211d04:	1145c83a 	sub	r2,r2,r5
 8211d08:	4089c83a 	sub	r4,r8,r2
 8211d0c:	003fc706 	br	8211c2c <__umoddi3+0x3fc>
 8211d10:	01000604 	movi	r4,24
 8211d14:	003f1806 	br	8211978 <__umoddi3+0x148>
 8211d18:	00800604 	movi	r2,24
 8211d1c:	003f3206 	br	82119e8 <__umoddi3+0x1b8>
 8211d20:	01000604 	movi	r4,24
 8211d24:	003ed906 	br	821188c <__umoddi3+0x5c>
 8211d28:	413fa52e 	bgeu	r8,r4,8211bc0 <__umoddi3+0x390>
 8211d2c:	297fff84 	addi	r5,r5,-2
 8211d30:	4551883a 	add	r8,r8,r21
 8211d34:	003fa306 	br	8211bc4 <__umoddi3+0x394>
 8211d38:	15ff8b2e 	bgeu	r2,r23,8211b68 <__umoddi3+0x338>
 8211d3c:	31bfff84 	addi	r6,r6,-2
 8211d40:	1545883a 	add	r2,r2,r21
 8211d44:	003f8906 	br	8211b6c <__umoddi3+0x33c>
 8211d48:	24c9883a 	add	r4,r4,r19
 8211d4c:	003eee06 	br	8211908 <__umoddi3+0xd8>
 8211d50:	8005883a 	mov	r2,r16
 8211d54:	003f1706 	br	82119b4 <__umoddi3+0x184>
 8211d58:	817fe736 	bltu	r16,r5,8211cf8 <__umoddi3+0x4c8>
 8211d5c:	280f883a 	mov	r7,r5
 8211d60:	0009883a 	mov	r4,zero
 8211d64:	003fb106 	br	8211c2c <__umoddi3+0x3fc>

08211d68 <__adddf3>:
 8211d68:	02c00434 	movhi	r11,16
 8211d6c:	5affffc4 	addi	r11,r11,-1
 8211d70:	2806d7fa 	srli	r3,r5,31
 8211d74:	2ad4703a 	and	r10,r5,r11
 8211d78:	3ad2703a 	and	r9,r7,r11
 8211d7c:	3804d53a 	srli	r2,r7,20
 8211d80:	3018d77a 	srli	r12,r6,29
 8211d84:	280ad53a 	srli	r5,r5,20
 8211d88:	501490fa 	slli	r10,r10,3
 8211d8c:	2010d77a 	srli	r8,r4,29
 8211d90:	481290fa 	slli	r9,r9,3
 8211d94:	380ed7fa 	srli	r7,r7,31
 8211d98:	defffb04 	addi	sp,sp,-20
 8211d9c:	dc800215 	stw	r18,8(sp)
 8211da0:	dc400115 	stw	r17,4(sp)
 8211da4:	dc000015 	stw	r16,0(sp)
 8211da8:	dfc00415 	stw	ra,16(sp)
 8211dac:	dcc00315 	stw	r19,12(sp)
 8211db0:	1c803fcc 	andi	r18,r3,255
 8211db4:	2c01ffcc 	andi	r16,r5,2047
 8211db8:	5210b03a 	or	r8,r10,r8
 8211dbc:	202290fa 	slli	r17,r4,3
 8211dc0:	1081ffcc 	andi	r2,r2,2047
 8211dc4:	4b12b03a 	or	r9,r9,r12
 8211dc8:	300c90fa 	slli	r6,r6,3
 8211dcc:	91c07526 	beq	r18,r7,8211fa4 <__adddf3+0x23c>
 8211dd0:	8087c83a 	sub	r3,r16,r2
 8211dd4:	00c0ab0e 	bge	zero,r3,8212084 <__adddf3+0x31c>
 8211dd8:	10002a1e 	bne	r2,zero,8211e84 <__adddf3+0x11c>
 8211ddc:	4984b03a 	or	r2,r9,r6
 8211de0:	1000961e 	bne	r2,zero,821203c <__adddf3+0x2d4>
 8211de4:	888001cc 	andi	r2,r17,7
 8211de8:	10000726 	beq	r2,zero,8211e08 <__adddf3+0xa0>
 8211dec:	888003cc 	andi	r2,r17,15
 8211df0:	00c00104 	movi	r3,4
 8211df4:	10c00426 	beq	r2,r3,8211e08 <__adddf3+0xa0>
 8211df8:	88c7883a 	add	r3,r17,r3
 8211dfc:	1c63803a 	cmpltu	r17,r3,r17
 8211e00:	4451883a 	add	r8,r8,r17
 8211e04:	1823883a 	mov	r17,r3
 8211e08:	4080202c 	andhi	r2,r8,128
 8211e0c:	10005926 	beq	r2,zero,8211f74 <__adddf3+0x20c>
 8211e10:	84000044 	addi	r16,r16,1
 8211e14:	0081ffc4 	movi	r2,2047
 8211e18:	8080ba26 	beq	r16,r2,8212104 <__adddf3+0x39c>
 8211e1c:	00bfe034 	movhi	r2,65408
 8211e20:	10bfffc4 	addi	r2,r2,-1
 8211e24:	4090703a 	and	r8,r8,r2
 8211e28:	4004977a 	slli	r2,r8,29
 8211e2c:	4010927a 	slli	r8,r8,9
 8211e30:	8822d0fa 	srli	r17,r17,3
 8211e34:	8401ffcc 	andi	r16,r16,2047
 8211e38:	4010d33a 	srli	r8,r8,12
 8211e3c:	9007883a 	mov	r3,r18
 8211e40:	1444b03a 	or	r2,r2,r17
 8211e44:	8401ffcc 	andi	r16,r16,2047
 8211e48:	8020953a 	slli	r16,r16,20
 8211e4c:	18c03fcc 	andi	r3,r3,255
 8211e50:	01000434 	movhi	r4,16
 8211e54:	213fffc4 	addi	r4,r4,-1
 8211e58:	180697fa 	slli	r3,r3,31
 8211e5c:	4110703a 	and	r8,r8,r4
 8211e60:	4410b03a 	or	r8,r8,r16
 8211e64:	40c6b03a 	or	r3,r8,r3
 8211e68:	dfc00417 	ldw	ra,16(sp)
 8211e6c:	dcc00317 	ldw	r19,12(sp)
 8211e70:	dc800217 	ldw	r18,8(sp)
 8211e74:	dc400117 	ldw	r17,4(sp)
 8211e78:	dc000017 	ldw	r16,0(sp)
 8211e7c:	dec00504 	addi	sp,sp,20
 8211e80:	f800283a 	ret
 8211e84:	0081ffc4 	movi	r2,2047
 8211e88:	80bfd626 	beq	r16,r2,8211de4 <__adddf3+0x7c>
 8211e8c:	4a402034 	orhi	r9,r9,128
 8211e90:	00800e04 	movi	r2,56
 8211e94:	10c09f16 	blt	r2,r3,8212114 <__adddf3+0x3ac>
 8211e98:	008007c4 	movi	r2,31
 8211e9c:	10c0c216 	blt	r2,r3,82121a8 <__adddf3+0x440>
 8211ea0:	00800804 	movi	r2,32
 8211ea4:	10c5c83a 	sub	r2,r2,r3
 8211ea8:	488a983a 	sll	r5,r9,r2
 8211eac:	30c8d83a 	srl	r4,r6,r3
 8211eb0:	3084983a 	sll	r2,r6,r2
 8211eb4:	48c6d83a 	srl	r3,r9,r3
 8211eb8:	290cb03a 	or	r6,r5,r4
 8211ebc:	1004c03a 	cmpne	r2,r2,zero
 8211ec0:	308cb03a 	or	r6,r6,r2
 8211ec4:	898dc83a 	sub	r6,r17,r6
 8211ec8:	89a3803a 	cmpltu	r17,r17,r6
 8211ecc:	40d1c83a 	sub	r8,r8,r3
 8211ed0:	4451c83a 	sub	r8,r8,r17
 8211ed4:	3023883a 	mov	r17,r6
 8211ed8:	4080202c 	andhi	r2,r8,128
 8211edc:	10002326 	beq	r2,zero,8211f6c <__adddf3+0x204>
 8211ee0:	04c02034 	movhi	r19,128
 8211ee4:	9cffffc4 	addi	r19,r19,-1
 8211ee8:	44e6703a 	and	r19,r8,r19
 8211eec:	98007626 	beq	r19,zero,82120c8 <__adddf3+0x360>
 8211ef0:	9809883a 	mov	r4,r19
 8211ef4:	821436c0 	call	821436c <__clzsi2>
 8211ef8:	10fffe04 	addi	r3,r2,-8
 8211efc:	010007c4 	movi	r4,31
 8211f00:	20c07716 	blt	r4,r3,82120e0 <__adddf3+0x378>
 8211f04:	00800804 	movi	r2,32
 8211f08:	10c5c83a 	sub	r2,r2,r3
 8211f0c:	8884d83a 	srl	r2,r17,r2
 8211f10:	98d0983a 	sll	r8,r19,r3
 8211f14:	88e2983a 	sll	r17,r17,r3
 8211f18:	1204b03a 	or	r2,r2,r8
 8211f1c:	1c007416 	blt	r3,r16,82120f0 <__adddf3+0x388>
 8211f20:	1c21c83a 	sub	r16,r3,r16
 8211f24:	82000044 	addi	r8,r16,1
 8211f28:	00c007c4 	movi	r3,31
 8211f2c:	1a009116 	blt	r3,r8,8212174 <__adddf3+0x40c>
 8211f30:	00c00804 	movi	r3,32
 8211f34:	1a07c83a 	sub	r3,r3,r8
 8211f38:	8a08d83a 	srl	r4,r17,r8
 8211f3c:	88e2983a 	sll	r17,r17,r3
 8211f40:	10c6983a 	sll	r3,r2,r3
 8211f44:	1210d83a 	srl	r8,r2,r8
 8211f48:	8804c03a 	cmpne	r2,r17,zero
 8211f4c:	1906b03a 	or	r3,r3,r4
 8211f50:	18a2b03a 	or	r17,r3,r2
 8211f54:	0021883a 	mov	r16,zero
 8211f58:	003fa206 	br	8211de4 <__adddf3+0x7c>
 8211f5c:	1890b03a 	or	r8,r3,r2
 8211f60:	40017d26 	beq	r8,zero,8212558 <__adddf3+0x7f0>
 8211f64:	1011883a 	mov	r8,r2
 8211f68:	1823883a 	mov	r17,r3
 8211f6c:	888001cc 	andi	r2,r17,7
 8211f70:	103f9e1e 	bne	r2,zero,8211dec <__adddf3+0x84>
 8211f74:	4004977a 	slli	r2,r8,29
 8211f78:	8822d0fa 	srli	r17,r17,3
 8211f7c:	4010d0fa 	srli	r8,r8,3
 8211f80:	9007883a 	mov	r3,r18
 8211f84:	1444b03a 	or	r2,r2,r17
 8211f88:	0101ffc4 	movi	r4,2047
 8211f8c:	81002426 	beq	r16,r4,8212020 <__adddf3+0x2b8>
 8211f90:	8120703a 	and	r16,r16,r4
 8211f94:	01000434 	movhi	r4,16
 8211f98:	213fffc4 	addi	r4,r4,-1
 8211f9c:	4110703a 	and	r8,r8,r4
 8211fa0:	003fa806 	br	8211e44 <__adddf3+0xdc>
 8211fa4:	8089c83a 	sub	r4,r16,r2
 8211fa8:	01005e0e 	bge	zero,r4,8212124 <__adddf3+0x3bc>
 8211fac:	10002b26 	beq	r2,zero,821205c <__adddf3+0x2f4>
 8211fb0:	0081ffc4 	movi	r2,2047
 8211fb4:	80bf8b26 	beq	r16,r2,8211de4 <__adddf3+0x7c>
 8211fb8:	4a402034 	orhi	r9,r9,128
 8211fbc:	00800e04 	movi	r2,56
 8211fc0:	1100a40e 	bge	r2,r4,8212254 <__adddf3+0x4ec>
 8211fc4:	498cb03a 	or	r6,r9,r6
 8211fc8:	300ac03a 	cmpne	r5,r6,zero
 8211fcc:	0013883a 	mov	r9,zero
 8211fd0:	2c4b883a 	add	r5,r5,r17
 8211fd4:	2c63803a 	cmpltu	r17,r5,r17
 8211fd8:	4a11883a 	add	r8,r9,r8
 8211fdc:	8a11883a 	add	r8,r17,r8
 8211fe0:	2823883a 	mov	r17,r5
 8211fe4:	4080202c 	andhi	r2,r8,128
 8211fe8:	103fe026 	beq	r2,zero,8211f6c <__adddf3+0x204>
 8211fec:	84000044 	addi	r16,r16,1
 8211ff0:	0081ffc4 	movi	r2,2047
 8211ff4:	8080d226 	beq	r16,r2,8212340 <__adddf3+0x5d8>
 8211ff8:	00bfe034 	movhi	r2,65408
 8211ffc:	10bfffc4 	addi	r2,r2,-1
 8212000:	4090703a 	and	r8,r8,r2
 8212004:	880ad07a 	srli	r5,r17,1
 8212008:	400897fa 	slli	r4,r8,31
 821200c:	88c0004c 	andi	r3,r17,1
 8212010:	28e2b03a 	or	r17,r5,r3
 8212014:	4010d07a 	srli	r8,r8,1
 8212018:	2462b03a 	or	r17,r4,r17
 821201c:	003f7106 	br	8211de4 <__adddf3+0x7c>
 8212020:	4088b03a 	or	r4,r8,r2
 8212024:	20014526 	beq	r4,zero,821253c <__adddf3+0x7d4>
 8212028:	01000434 	movhi	r4,16
 821202c:	42000234 	orhi	r8,r8,8
 8212030:	213fffc4 	addi	r4,r4,-1
 8212034:	4110703a 	and	r8,r8,r4
 8212038:	003f8206 	br	8211e44 <__adddf3+0xdc>
 821203c:	18ffffc4 	addi	r3,r3,-1
 8212040:	1800491e 	bne	r3,zero,8212168 <__adddf3+0x400>
 8212044:	898bc83a 	sub	r5,r17,r6
 8212048:	8963803a 	cmpltu	r17,r17,r5
 821204c:	4251c83a 	sub	r8,r8,r9
 8212050:	4451c83a 	sub	r8,r8,r17
 8212054:	2823883a 	mov	r17,r5
 8212058:	003f9f06 	br	8211ed8 <__adddf3+0x170>
 821205c:	4984b03a 	or	r2,r9,r6
 8212060:	103f6026 	beq	r2,zero,8211de4 <__adddf3+0x7c>
 8212064:	213fffc4 	addi	r4,r4,-1
 8212068:	2000931e 	bne	r4,zero,82122b8 <__adddf3+0x550>
 821206c:	898d883a 	add	r6,r17,r6
 8212070:	3463803a 	cmpltu	r17,r6,r17
 8212074:	4251883a 	add	r8,r8,r9
 8212078:	8a11883a 	add	r8,r17,r8
 821207c:	3023883a 	mov	r17,r6
 8212080:	003fd806 	br	8211fe4 <__adddf3+0x27c>
 8212084:	1800541e 	bne	r3,zero,82121d8 <__adddf3+0x470>
 8212088:	80800044 	addi	r2,r16,1
 821208c:	1081ffcc 	andi	r2,r2,2047
 8212090:	00c00044 	movi	r3,1
 8212094:	1880a00e 	bge	r3,r2,8212318 <__adddf3+0x5b0>
 8212098:	8989c83a 	sub	r4,r17,r6
 821209c:	8905803a 	cmpltu	r2,r17,r4
 82120a0:	4267c83a 	sub	r19,r8,r9
 82120a4:	98a7c83a 	sub	r19,r19,r2
 82120a8:	9880202c 	andhi	r2,r19,128
 82120ac:	10006326 	beq	r2,zero,821223c <__adddf3+0x4d4>
 82120b0:	3463c83a 	sub	r17,r6,r17
 82120b4:	4a07c83a 	sub	r3,r9,r8
 82120b8:	344d803a 	cmpltu	r6,r6,r17
 82120bc:	19a7c83a 	sub	r19,r3,r6
 82120c0:	3825883a 	mov	r18,r7
 82120c4:	983f8a1e 	bne	r19,zero,8211ef0 <__adddf3+0x188>
 82120c8:	8809883a 	mov	r4,r17
 82120cc:	821436c0 	call	821436c <__clzsi2>
 82120d0:	10800804 	addi	r2,r2,32
 82120d4:	10fffe04 	addi	r3,r2,-8
 82120d8:	010007c4 	movi	r4,31
 82120dc:	20ff890e 	bge	r4,r3,8211f04 <__adddf3+0x19c>
 82120e0:	10bff604 	addi	r2,r2,-40
 82120e4:	8884983a 	sll	r2,r17,r2
 82120e8:	0023883a 	mov	r17,zero
 82120ec:	1c3f8c0e 	bge	r3,r16,8211f20 <__adddf3+0x1b8>
 82120f0:	023fe034 	movhi	r8,65408
 82120f4:	423fffc4 	addi	r8,r8,-1
 82120f8:	80e1c83a 	sub	r16,r16,r3
 82120fc:	1210703a 	and	r8,r2,r8
 8212100:	003f3806 	br	8211de4 <__adddf3+0x7c>
 8212104:	9007883a 	mov	r3,r18
 8212108:	0011883a 	mov	r8,zero
 821210c:	0005883a 	mov	r2,zero
 8212110:	003f4c06 	br	8211e44 <__adddf3+0xdc>
 8212114:	498cb03a 	or	r6,r9,r6
 8212118:	300cc03a 	cmpne	r6,r6,zero
 821211c:	0007883a 	mov	r3,zero
 8212120:	003f6806 	br	8211ec4 <__adddf3+0x15c>
 8212124:	20009c1e 	bne	r4,zero,8212398 <__adddf3+0x630>
 8212128:	80800044 	addi	r2,r16,1
 821212c:	1141ffcc 	andi	r5,r2,2047
 8212130:	01000044 	movi	r4,1
 8212134:	2140670e 	bge	r4,r5,82122d4 <__adddf3+0x56c>
 8212138:	0101ffc4 	movi	r4,2047
 821213c:	11007f26 	beq	r2,r4,821233c <__adddf3+0x5d4>
 8212140:	898d883a 	add	r6,r17,r6
 8212144:	4247883a 	add	r3,r8,r9
 8212148:	3451803a 	cmpltu	r8,r6,r17
 821214c:	40d1883a 	add	r8,r8,r3
 8212150:	402297fa 	slli	r17,r8,31
 8212154:	300cd07a 	srli	r6,r6,1
 8212158:	4010d07a 	srli	r8,r8,1
 821215c:	1021883a 	mov	r16,r2
 8212160:	89a2b03a 	or	r17,r17,r6
 8212164:	003f1f06 	br	8211de4 <__adddf3+0x7c>
 8212168:	0081ffc4 	movi	r2,2047
 821216c:	80bf481e 	bne	r16,r2,8211e90 <__adddf3+0x128>
 8212170:	003f1c06 	br	8211de4 <__adddf3+0x7c>
 8212174:	843ff844 	addi	r16,r16,-31
 8212178:	01000804 	movi	r4,32
 821217c:	1406d83a 	srl	r3,r2,r16
 8212180:	41005026 	beq	r8,r4,82122c4 <__adddf3+0x55c>
 8212184:	01001004 	movi	r4,64
 8212188:	2211c83a 	sub	r8,r4,r8
 821218c:	1204983a 	sll	r2,r2,r8
 8212190:	88a2b03a 	or	r17,r17,r2
 8212194:	8822c03a 	cmpne	r17,r17,zero
 8212198:	1c62b03a 	or	r17,r3,r17
 821219c:	0011883a 	mov	r8,zero
 82121a0:	0021883a 	mov	r16,zero
 82121a4:	003f7106 	br	8211f6c <__adddf3+0x204>
 82121a8:	193ff804 	addi	r4,r3,-32
 82121ac:	00800804 	movi	r2,32
 82121b0:	4908d83a 	srl	r4,r9,r4
 82121b4:	18804526 	beq	r3,r2,82122cc <__adddf3+0x564>
 82121b8:	00801004 	movi	r2,64
 82121bc:	10c5c83a 	sub	r2,r2,r3
 82121c0:	4886983a 	sll	r3,r9,r2
 82121c4:	198cb03a 	or	r6,r3,r6
 82121c8:	300cc03a 	cmpne	r6,r6,zero
 82121cc:	218cb03a 	or	r6,r4,r6
 82121d0:	0007883a 	mov	r3,zero
 82121d4:	003f3b06 	br	8211ec4 <__adddf3+0x15c>
 82121d8:	80002a26 	beq	r16,zero,8212284 <__adddf3+0x51c>
 82121dc:	0101ffc4 	movi	r4,2047
 82121e0:	11006826 	beq	r2,r4,8212384 <__adddf3+0x61c>
 82121e4:	00c7c83a 	sub	r3,zero,r3
 82121e8:	42002034 	orhi	r8,r8,128
 82121ec:	01000e04 	movi	r4,56
 82121f0:	20c07c16 	blt	r4,r3,82123e4 <__adddf3+0x67c>
 82121f4:	010007c4 	movi	r4,31
 82121f8:	20c0da16 	blt	r4,r3,8212564 <__adddf3+0x7fc>
 82121fc:	01000804 	movi	r4,32
 8212200:	20c9c83a 	sub	r4,r4,r3
 8212204:	4114983a 	sll	r10,r8,r4
 8212208:	88cad83a 	srl	r5,r17,r3
 821220c:	8908983a 	sll	r4,r17,r4
 8212210:	40c6d83a 	srl	r3,r8,r3
 8212214:	5162b03a 	or	r17,r10,r5
 8212218:	2008c03a 	cmpne	r4,r4,zero
 821221c:	8922b03a 	or	r17,r17,r4
 8212220:	3463c83a 	sub	r17,r6,r17
 8212224:	48c7c83a 	sub	r3,r9,r3
 8212228:	344d803a 	cmpltu	r6,r6,r17
 821222c:	1991c83a 	sub	r8,r3,r6
 8212230:	1021883a 	mov	r16,r2
 8212234:	3825883a 	mov	r18,r7
 8212238:	003f2706 	br	8211ed8 <__adddf3+0x170>
 821223c:	24d0b03a 	or	r8,r4,r19
 8212240:	40001b1e 	bne	r8,zero,82122b0 <__adddf3+0x548>
 8212244:	0005883a 	mov	r2,zero
 8212248:	0007883a 	mov	r3,zero
 821224c:	0021883a 	mov	r16,zero
 8212250:	003f4d06 	br	8211f88 <__adddf3+0x220>
 8212254:	008007c4 	movi	r2,31
 8212258:	11003c16 	blt	r2,r4,821234c <__adddf3+0x5e4>
 821225c:	00800804 	movi	r2,32
 8212260:	1105c83a 	sub	r2,r2,r4
 8212264:	488e983a 	sll	r7,r9,r2
 8212268:	310ad83a 	srl	r5,r6,r4
 821226c:	3084983a 	sll	r2,r6,r2
 8212270:	4912d83a 	srl	r9,r9,r4
 8212274:	394ab03a 	or	r5,r7,r5
 8212278:	1004c03a 	cmpne	r2,r2,zero
 821227c:	288ab03a 	or	r5,r5,r2
 8212280:	003f5306 	br	8211fd0 <__adddf3+0x268>
 8212284:	4448b03a 	or	r4,r8,r17
 8212288:	20003e26 	beq	r4,zero,8212384 <__adddf3+0x61c>
 821228c:	00c6303a 	nor	r3,zero,r3
 8212290:	18003a1e 	bne	r3,zero,821237c <__adddf3+0x614>
 8212294:	3463c83a 	sub	r17,r6,r17
 8212298:	4a07c83a 	sub	r3,r9,r8
 821229c:	344d803a 	cmpltu	r6,r6,r17
 82122a0:	1991c83a 	sub	r8,r3,r6
 82122a4:	1021883a 	mov	r16,r2
 82122a8:	3825883a 	mov	r18,r7
 82122ac:	003f0a06 	br	8211ed8 <__adddf3+0x170>
 82122b0:	2023883a 	mov	r17,r4
 82122b4:	003f0d06 	br	8211eec <__adddf3+0x184>
 82122b8:	0081ffc4 	movi	r2,2047
 82122bc:	80bf3f1e 	bne	r16,r2,8211fbc <__adddf3+0x254>
 82122c0:	003ec806 	br	8211de4 <__adddf3+0x7c>
 82122c4:	0005883a 	mov	r2,zero
 82122c8:	003fb106 	br	8212190 <__adddf3+0x428>
 82122cc:	0007883a 	mov	r3,zero
 82122d0:	003fbc06 	br	82121c4 <__adddf3+0x45c>
 82122d4:	4444b03a 	or	r2,r8,r17
 82122d8:	8000871e 	bne	r16,zero,82124f8 <__adddf3+0x790>
 82122dc:	1000ba26 	beq	r2,zero,82125c8 <__adddf3+0x860>
 82122e0:	4984b03a 	or	r2,r9,r6
 82122e4:	103ebf26 	beq	r2,zero,8211de4 <__adddf3+0x7c>
 82122e8:	8985883a 	add	r2,r17,r6
 82122ec:	4247883a 	add	r3,r8,r9
 82122f0:	1451803a 	cmpltu	r8,r2,r17
 82122f4:	40d1883a 	add	r8,r8,r3
 82122f8:	40c0202c 	andhi	r3,r8,128
 82122fc:	1023883a 	mov	r17,r2
 8212300:	183f1a26 	beq	r3,zero,8211f6c <__adddf3+0x204>
 8212304:	00bfe034 	movhi	r2,65408
 8212308:	10bfffc4 	addi	r2,r2,-1
 821230c:	2021883a 	mov	r16,r4
 8212310:	4090703a 	and	r8,r8,r2
 8212314:	003eb306 	br	8211de4 <__adddf3+0x7c>
 8212318:	4444b03a 	or	r2,r8,r17
 821231c:	8000291e 	bne	r16,zero,82123c4 <__adddf3+0x65c>
 8212320:	10004b1e 	bne	r2,zero,8212450 <__adddf3+0x6e8>
 8212324:	4990b03a 	or	r8,r9,r6
 8212328:	40008b26 	beq	r8,zero,8212558 <__adddf3+0x7f0>
 821232c:	4811883a 	mov	r8,r9
 8212330:	3023883a 	mov	r17,r6
 8212334:	3825883a 	mov	r18,r7
 8212338:	003eaa06 	br	8211de4 <__adddf3+0x7c>
 821233c:	1021883a 	mov	r16,r2
 8212340:	0011883a 	mov	r8,zero
 8212344:	0005883a 	mov	r2,zero
 8212348:	003f0f06 	br	8211f88 <__adddf3+0x220>
 821234c:	217ff804 	addi	r5,r4,-32
 8212350:	00800804 	movi	r2,32
 8212354:	494ad83a 	srl	r5,r9,r5
 8212358:	20807d26 	beq	r4,r2,8212550 <__adddf3+0x7e8>
 821235c:	00801004 	movi	r2,64
 8212360:	1109c83a 	sub	r4,r2,r4
 8212364:	4912983a 	sll	r9,r9,r4
 8212368:	498cb03a 	or	r6,r9,r6
 821236c:	300cc03a 	cmpne	r6,r6,zero
 8212370:	298ab03a 	or	r5,r5,r6
 8212374:	0013883a 	mov	r9,zero
 8212378:	003f1506 	br	8211fd0 <__adddf3+0x268>
 821237c:	0101ffc4 	movi	r4,2047
 8212380:	113f9a1e 	bne	r2,r4,82121ec <__adddf3+0x484>
 8212384:	4811883a 	mov	r8,r9
 8212388:	3023883a 	mov	r17,r6
 821238c:	1021883a 	mov	r16,r2
 8212390:	3825883a 	mov	r18,r7
 8212394:	003e9306 	br	8211de4 <__adddf3+0x7c>
 8212398:	8000161e 	bne	r16,zero,82123f4 <__adddf3+0x68c>
 821239c:	444ab03a 	or	r5,r8,r17
 82123a0:	28005126 	beq	r5,zero,82124e8 <__adddf3+0x780>
 82123a4:	0108303a 	nor	r4,zero,r4
 82123a8:	20004d1e 	bne	r4,zero,82124e0 <__adddf3+0x778>
 82123ac:	89a3883a 	add	r17,r17,r6
 82123b0:	4253883a 	add	r9,r8,r9
 82123b4:	898d803a 	cmpltu	r6,r17,r6
 82123b8:	3251883a 	add	r8,r6,r9
 82123bc:	1021883a 	mov	r16,r2
 82123c0:	003f0806 	br	8211fe4 <__adddf3+0x27c>
 82123c4:	1000301e 	bne	r2,zero,8212488 <__adddf3+0x720>
 82123c8:	4984b03a 	or	r2,r9,r6
 82123cc:	10007126 	beq	r2,zero,8212594 <__adddf3+0x82c>
 82123d0:	4811883a 	mov	r8,r9
 82123d4:	3023883a 	mov	r17,r6
 82123d8:	3825883a 	mov	r18,r7
 82123dc:	0401ffc4 	movi	r16,2047
 82123e0:	003e8006 	br	8211de4 <__adddf3+0x7c>
 82123e4:	4462b03a 	or	r17,r8,r17
 82123e8:	8822c03a 	cmpne	r17,r17,zero
 82123ec:	0007883a 	mov	r3,zero
 82123f0:	003f8b06 	br	8212220 <__adddf3+0x4b8>
 82123f4:	0141ffc4 	movi	r5,2047
 82123f8:	11403b26 	beq	r2,r5,82124e8 <__adddf3+0x780>
 82123fc:	0109c83a 	sub	r4,zero,r4
 8212400:	42002034 	orhi	r8,r8,128
 8212404:	01400e04 	movi	r5,56
 8212408:	29006716 	blt	r5,r4,82125a8 <__adddf3+0x840>
 821240c:	014007c4 	movi	r5,31
 8212410:	29007016 	blt	r5,r4,82125d4 <__adddf3+0x86c>
 8212414:	01400804 	movi	r5,32
 8212418:	290bc83a 	sub	r5,r5,r4
 821241c:	4154983a 	sll	r10,r8,r5
 8212420:	890ed83a 	srl	r7,r17,r4
 8212424:	894a983a 	sll	r5,r17,r5
 8212428:	4108d83a 	srl	r4,r8,r4
 821242c:	51e2b03a 	or	r17,r10,r7
 8212430:	280ac03a 	cmpne	r5,r5,zero
 8212434:	8962b03a 	or	r17,r17,r5
 8212438:	89a3883a 	add	r17,r17,r6
 821243c:	2253883a 	add	r9,r4,r9
 8212440:	898d803a 	cmpltu	r6,r17,r6
 8212444:	3251883a 	add	r8,r6,r9
 8212448:	1021883a 	mov	r16,r2
 821244c:	003ee506 	br	8211fe4 <__adddf3+0x27c>
 8212450:	4984b03a 	or	r2,r9,r6
 8212454:	103e6326 	beq	r2,zero,8211de4 <__adddf3+0x7c>
 8212458:	8987c83a 	sub	r3,r17,r6
 821245c:	88c9803a 	cmpltu	r4,r17,r3
 8212460:	4245c83a 	sub	r2,r8,r9
 8212464:	1105c83a 	sub	r2,r2,r4
 8212468:	1100202c 	andhi	r4,r2,128
 821246c:	203ebb26 	beq	r4,zero,8211f5c <__adddf3+0x1f4>
 8212470:	3463c83a 	sub	r17,r6,r17
 8212474:	4a07c83a 	sub	r3,r9,r8
 8212478:	344d803a 	cmpltu	r6,r6,r17
 821247c:	1991c83a 	sub	r8,r3,r6
 8212480:	3825883a 	mov	r18,r7
 8212484:	003e5706 	br	8211de4 <__adddf3+0x7c>
 8212488:	4984b03a 	or	r2,r9,r6
 821248c:	10002e26 	beq	r2,zero,8212548 <__adddf3+0x7e0>
 8212490:	4004d0fa 	srli	r2,r8,3
 8212494:	8822d0fa 	srli	r17,r17,3
 8212498:	4010977a 	slli	r8,r8,29
 821249c:	10c0022c 	andhi	r3,r2,8
 82124a0:	4462b03a 	or	r17,r8,r17
 82124a4:	18000826 	beq	r3,zero,82124c8 <__adddf3+0x760>
 82124a8:	4808d0fa 	srli	r4,r9,3
 82124ac:	20c0022c 	andhi	r3,r4,8
 82124b0:	1800051e 	bne	r3,zero,82124c8 <__adddf3+0x760>
 82124b4:	300cd0fa 	srli	r6,r6,3
 82124b8:	4806977a 	slli	r3,r9,29
 82124bc:	2005883a 	mov	r2,r4
 82124c0:	3825883a 	mov	r18,r7
 82124c4:	19a2b03a 	or	r17,r3,r6
 82124c8:	8810d77a 	srli	r8,r17,29
 82124cc:	100490fa 	slli	r2,r2,3
 82124d0:	882290fa 	slli	r17,r17,3
 82124d4:	0401ffc4 	movi	r16,2047
 82124d8:	4090b03a 	or	r8,r8,r2
 82124dc:	003e4106 	br	8211de4 <__adddf3+0x7c>
 82124e0:	0141ffc4 	movi	r5,2047
 82124e4:	117fc71e 	bne	r2,r5,8212404 <__adddf3+0x69c>
 82124e8:	4811883a 	mov	r8,r9
 82124ec:	3023883a 	mov	r17,r6
 82124f0:	1021883a 	mov	r16,r2
 82124f4:	003e3b06 	br	8211de4 <__adddf3+0x7c>
 82124f8:	10002f26 	beq	r2,zero,82125b8 <__adddf3+0x850>
 82124fc:	4984b03a 	or	r2,r9,r6
 8212500:	10001126 	beq	r2,zero,8212548 <__adddf3+0x7e0>
 8212504:	4004d0fa 	srli	r2,r8,3
 8212508:	8822d0fa 	srli	r17,r17,3
 821250c:	4010977a 	slli	r8,r8,29
 8212510:	10c0022c 	andhi	r3,r2,8
 8212514:	4462b03a 	or	r17,r8,r17
 8212518:	183feb26 	beq	r3,zero,82124c8 <__adddf3+0x760>
 821251c:	4808d0fa 	srli	r4,r9,3
 8212520:	20c0022c 	andhi	r3,r4,8
 8212524:	183fe81e 	bne	r3,zero,82124c8 <__adddf3+0x760>
 8212528:	300cd0fa 	srli	r6,r6,3
 821252c:	4806977a 	slli	r3,r9,29
 8212530:	2005883a 	mov	r2,r4
 8212534:	19a2b03a 	or	r17,r3,r6
 8212538:	003fe306 	br	82124c8 <__adddf3+0x760>
 821253c:	0011883a 	mov	r8,zero
 8212540:	0005883a 	mov	r2,zero
 8212544:	003e3f06 	br	8211e44 <__adddf3+0xdc>
 8212548:	0401ffc4 	movi	r16,2047
 821254c:	003e2506 	br	8211de4 <__adddf3+0x7c>
 8212550:	0013883a 	mov	r9,zero
 8212554:	003f8406 	br	8212368 <__adddf3+0x600>
 8212558:	0005883a 	mov	r2,zero
 821255c:	0007883a 	mov	r3,zero
 8212560:	003e8906 	br	8211f88 <__adddf3+0x220>
 8212564:	197ff804 	addi	r5,r3,-32
 8212568:	01000804 	movi	r4,32
 821256c:	414ad83a 	srl	r5,r8,r5
 8212570:	19002426 	beq	r3,r4,8212604 <__adddf3+0x89c>
 8212574:	01001004 	movi	r4,64
 8212578:	20c7c83a 	sub	r3,r4,r3
 821257c:	40c6983a 	sll	r3,r8,r3
 8212580:	1c46b03a 	or	r3,r3,r17
 8212584:	1806c03a 	cmpne	r3,r3,zero
 8212588:	28e2b03a 	or	r17,r5,r3
 821258c:	0007883a 	mov	r3,zero
 8212590:	003f2306 	br	8212220 <__adddf3+0x4b8>
 8212594:	0007883a 	mov	r3,zero
 8212598:	5811883a 	mov	r8,r11
 821259c:	00bfffc4 	movi	r2,-1
 82125a0:	0401ffc4 	movi	r16,2047
 82125a4:	003e7806 	br	8211f88 <__adddf3+0x220>
 82125a8:	4462b03a 	or	r17,r8,r17
 82125ac:	8822c03a 	cmpne	r17,r17,zero
 82125b0:	0009883a 	mov	r4,zero
 82125b4:	003fa006 	br	8212438 <__adddf3+0x6d0>
 82125b8:	4811883a 	mov	r8,r9
 82125bc:	3023883a 	mov	r17,r6
 82125c0:	0401ffc4 	movi	r16,2047
 82125c4:	003e0706 	br	8211de4 <__adddf3+0x7c>
 82125c8:	4811883a 	mov	r8,r9
 82125cc:	3023883a 	mov	r17,r6
 82125d0:	003e0406 	br	8211de4 <__adddf3+0x7c>
 82125d4:	21fff804 	addi	r7,r4,-32
 82125d8:	01400804 	movi	r5,32
 82125dc:	41ced83a 	srl	r7,r8,r7
 82125e0:	21400a26 	beq	r4,r5,821260c <__adddf3+0x8a4>
 82125e4:	01401004 	movi	r5,64
 82125e8:	2909c83a 	sub	r4,r5,r4
 82125ec:	4108983a 	sll	r4,r8,r4
 82125f0:	2448b03a 	or	r4,r4,r17
 82125f4:	2008c03a 	cmpne	r4,r4,zero
 82125f8:	3922b03a 	or	r17,r7,r4
 82125fc:	0009883a 	mov	r4,zero
 8212600:	003f8d06 	br	8212438 <__adddf3+0x6d0>
 8212604:	0007883a 	mov	r3,zero
 8212608:	003fdd06 	br	8212580 <__adddf3+0x818>
 821260c:	0009883a 	mov	r4,zero
 8212610:	003ff706 	br	82125f0 <__adddf3+0x888>

08212614 <__divdf3>:
 8212614:	defff204 	addi	sp,sp,-56
 8212618:	dd400915 	stw	r21,36(sp)
 821261c:	282ad53a 	srli	r21,r5,20
 8212620:	dd000815 	stw	r20,32(sp)
 8212624:	2828d7fa 	srli	r20,r5,31
 8212628:	dc000415 	stw	r16,16(sp)
 821262c:	04000434 	movhi	r16,16
 8212630:	df000c15 	stw	fp,48(sp)
 8212634:	843fffc4 	addi	r16,r16,-1
 8212638:	dfc00d15 	stw	ra,52(sp)
 821263c:	ddc00b15 	stw	r23,44(sp)
 8212640:	dd800a15 	stw	r22,40(sp)
 8212644:	dcc00715 	stw	r19,28(sp)
 8212648:	dc800615 	stw	r18,24(sp)
 821264c:	dc400515 	stw	r17,20(sp)
 8212650:	ad41ffcc 	andi	r21,r21,2047
 8212654:	2c20703a 	and	r16,r5,r16
 8212658:	a7003fcc 	andi	fp,r20,255
 821265c:	a8006126 	beq	r21,zero,82127e4 <__divdf3+0x1d0>
 8212660:	0081ffc4 	movi	r2,2047
 8212664:	2025883a 	mov	r18,r4
 8212668:	a8803726 	beq	r21,r2,8212748 <__divdf3+0x134>
 821266c:	80800434 	orhi	r2,r16,16
 8212670:	100490fa 	slli	r2,r2,3
 8212674:	2020d77a 	srli	r16,r4,29
 8212678:	202490fa 	slli	r18,r4,3
 821267c:	ad7f0044 	addi	r21,r21,-1023
 8212680:	80a0b03a 	or	r16,r16,r2
 8212684:	0027883a 	mov	r19,zero
 8212688:	0013883a 	mov	r9,zero
 821268c:	3804d53a 	srli	r2,r7,20
 8212690:	382cd7fa 	srli	r22,r7,31
 8212694:	04400434 	movhi	r17,16
 8212698:	8c7fffc4 	addi	r17,r17,-1
 821269c:	1081ffcc 	andi	r2,r2,2047
 82126a0:	3011883a 	mov	r8,r6
 82126a4:	3c62703a 	and	r17,r7,r17
 82126a8:	b5c03fcc 	andi	r23,r22,255
 82126ac:	10006c26 	beq	r2,zero,8212860 <__divdf3+0x24c>
 82126b0:	00c1ffc4 	movi	r3,2047
 82126b4:	10c06426 	beq	r2,r3,8212848 <__divdf3+0x234>
 82126b8:	88c00434 	orhi	r3,r17,16
 82126bc:	180690fa 	slli	r3,r3,3
 82126c0:	3022d77a 	srli	r17,r6,29
 82126c4:	301090fa 	slli	r8,r6,3
 82126c8:	10bf0044 	addi	r2,r2,-1023
 82126cc:	88e2b03a 	or	r17,r17,r3
 82126d0:	000f883a 	mov	r7,zero
 82126d4:	a58cf03a 	xor	r6,r20,r22
 82126d8:	3cc8b03a 	or	r4,r7,r19
 82126dc:	a8abc83a 	sub	r21,r21,r2
 82126e0:	008003c4 	movi	r2,15
 82126e4:	3007883a 	mov	r3,r6
 82126e8:	34c03fcc 	andi	r19,r6,255
 82126ec:	11009036 	bltu	r2,r4,8212930 <__divdf3+0x31c>
 82126f0:	200890ba 	slli	r4,r4,2
 82126f4:	00820874 	movhi	r2,2081
 82126f8:	1089c204 	addi	r2,r2,9992
 82126fc:	2089883a 	add	r4,r4,r2
 8212700:	20800017 	ldw	r2,0(r4)
 8212704:	1000683a 	jmp	r2
 8212708:	08212930 	cmpltui	zero,at,33956
 821270c:	08212780 	call	821278 <OSCtxSw_SWITCH_PC+0x821238>
 8212710:	08212920 	cmpeqi	zero,at,-31580
 8212714:	08212774 	orhi	zero,at,33949
 8212718:	08212920 	cmpeqi	zero,at,-31580
 821271c:	082128f4 	orhi	zero,at,33955
 8212720:	08212920 	cmpeqi	zero,at,-31580
 8212724:	08212774 	orhi	zero,at,33949
 8212728:	08212780 	call	821278 <OSCtxSw_SWITCH_PC+0x821238>
 821272c:	08212780 	call	821278 <OSCtxSw_SWITCH_PC+0x821238>
 8212730:	082128f4 	orhi	zero,at,33955
 8212734:	08212774 	orhi	zero,at,33949
 8212738:	08212764 	muli	zero,at,-31587
 821273c:	08212764 	muli	zero,at,-31587
 8212740:	08212764 	muli	zero,at,-31587
 8212744:	08212c14 	ori	zero,at,33968
 8212748:	2404b03a 	or	r2,r4,r16
 821274c:	1000661e 	bne	r2,zero,82128e8 <__divdf3+0x2d4>
 8212750:	04c00204 	movi	r19,8
 8212754:	0021883a 	mov	r16,zero
 8212758:	0025883a 	mov	r18,zero
 821275c:	02400084 	movi	r9,2
 8212760:	003fca06 	br	821268c <__divdf3+0x78>
 8212764:	8023883a 	mov	r17,r16
 8212768:	9011883a 	mov	r8,r18
 821276c:	e02f883a 	mov	r23,fp
 8212770:	480f883a 	mov	r7,r9
 8212774:	00800084 	movi	r2,2
 8212778:	3881311e 	bne	r7,r2,8212c40 <__divdf3+0x62c>
 821277c:	b827883a 	mov	r19,r23
 8212780:	98c0004c 	andi	r3,r19,1
 8212784:	0081ffc4 	movi	r2,2047
 8212788:	000b883a 	mov	r5,zero
 821278c:	0025883a 	mov	r18,zero
 8212790:	1004953a 	slli	r2,r2,20
 8212794:	18c03fcc 	andi	r3,r3,255
 8212798:	04400434 	movhi	r17,16
 821279c:	8c7fffc4 	addi	r17,r17,-1
 82127a0:	180697fa 	slli	r3,r3,31
 82127a4:	2c4a703a 	and	r5,r5,r17
 82127a8:	288ab03a 	or	r5,r5,r2
 82127ac:	28c6b03a 	or	r3,r5,r3
 82127b0:	9005883a 	mov	r2,r18
 82127b4:	dfc00d17 	ldw	ra,52(sp)
 82127b8:	df000c17 	ldw	fp,48(sp)
 82127bc:	ddc00b17 	ldw	r23,44(sp)
 82127c0:	dd800a17 	ldw	r22,40(sp)
 82127c4:	dd400917 	ldw	r21,36(sp)
 82127c8:	dd000817 	ldw	r20,32(sp)
 82127cc:	dcc00717 	ldw	r19,28(sp)
 82127d0:	dc800617 	ldw	r18,24(sp)
 82127d4:	dc400517 	ldw	r17,20(sp)
 82127d8:	dc000417 	ldw	r16,16(sp)
 82127dc:	dec00e04 	addi	sp,sp,56
 82127e0:	f800283a 	ret
 82127e4:	2404b03a 	or	r2,r4,r16
 82127e8:	2027883a 	mov	r19,r4
 82127ec:	10003926 	beq	r2,zero,82128d4 <__divdf3+0x2c0>
 82127f0:	80012e26 	beq	r16,zero,8212cac <__divdf3+0x698>
 82127f4:	8009883a 	mov	r4,r16
 82127f8:	d9800315 	stw	r6,12(sp)
 82127fc:	d9c00215 	stw	r7,8(sp)
 8212800:	821436c0 	call	821436c <__clzsi2>
 8212804:	d9800317 	ldw	r6,12(sp)
 8212808:	d9c00217 	ldw	r7,8(sp)
 821280c:	113ffd44 	addi	r4,r2,-11
 8212810:	00c00704 	movi	r3,28
 8212814:	19012116 	blt	r3,r4,8212c9c <__divdf3+0x688>
 8212818:	00c00744 	movi	r3,29
 821281c:	147ffe04 	addi	r17,r2,-8
 8212820:	1907c83a 	sub	r3,r3,r4
 8212824:	8460983a 	sll	r16,r16,r17
 8212828:	98c6d83a 	srl	r3,r19,r3
 821282c:	9c64983a 	sll	r18,r19,r17
 8212830:	1c20b03a 	or	r16,r3,r16
 8212834:	1080fcc4 	addi	r2,r2,1011
 8212838:	00abc83a 	sub	r21,zero,r2
 821283c:	0027883a 	mov	r19,zero
 8212840:	0013883a 	mov	r9,zero
 8212844:	003f9106 	br	821268c <__divdf3+0x78>
 8212848:	3446b03a 	or	r3,r6,r17
 821284c:	18001f1e 	bne	r3,zero,82128cc <__divdf3+0x2b8>
 8212850:	0023883a 	mov	r17,zero
 8212854:	0011883a 	mov	r8,zero
 8212858:	01c00084 	movi	r7,2
 821285c:	003f9d06 	br	82126d4 <__divdf3+0xc0>
 8212860:	3446b03a 	or	r3,r6,r17
 8212864:	18001526 	beq	r3,zero,82128bc <__divdf3+0x2a8>
 8212868:	88011b26 	beq	r17,zero,8212cd8 <__divdf3+0x6c4>
 821286c:	8809883a 	mov	r4,r17
 8212870:	d9800315 	stw	r6,12(sp)
 8212874:	da400115 	stw	r9,4(sp)
 8212878:	821436c0 	call	821436c <__clzsi2>
 821287c:	d9800317 	ldw	r6,12(sp)
 8212880:	da400117 	ldw	r9,4(sp)
 8212884:	113ffd44 	addi	r4,r2,-11
 8212888:	00c00704 	movi	r3,28
 821288c:	19010e16 	blt	r3,r4,8212cc8 <__divdf3+0x6b4>
 8212890:	00c00744 	movi	r3,29
 8212894:	123ffe04 	addi	r8,r2,-8
 8212898:	1907c83a 	sub	r3,r3,r4
 821289c:	8a22983a 	sll	r17,r17,r8
 82128a0:	30c6d83a 	srl	r3,r6,r3
 82128a4:	3210983a 	sll	r8,r6,r8
 82128a8:	1c62b03a 	or	r17,r3,r17
 82128ac:	1080fcc4 	addi	r2,r2,1011
 82128b0:	0085c83a 	sub	r2,zero,r2
 82128b4:	000f883a 	mov	r7,zero
 82128b8:	003f8606 	br	82126d4 <__divdf3+0xc0>
 82128bc:	0023883a 	mov	r17,zero
 82128c0:	0011883a 	mov	r8,zero
 82128c4:	01c00044 	movi	r7,1
 82128c8:	003f8206 	br	82126d4 <__divdf3+0xc0>
 82128cc:	01c000c4 	movi	r7,3
 82128d0:	003f8006 	br	82126d4 <__divdf3+0xc0>
 82128d4:	04c00104 	movi	r19,4
 82128d8:	0021883a 	mov	r16,zero
 82128dc:	0025883a 	mov	r18,zero
 82128e0:	02400044 	movi	r9,1
 82128e4:	003f6906 	br	821268c <__divdf3+0x78>
 82128e8:	04c00304 	movi	r19,12
 82128ec:	024000c4 	movi	r9,3
 82128f0:	003f6606 	br	821268c <__divdf3+0x78>
 82128f4:	01400434 	movhi	r5,16
 82128f8:	0007883a 	mov	r3,zero
 82128fc:	297fffc4 	addi	r5,r5,-1
 8212900:	04bfffc4 	movi	r18,-1
 8212904:	0081ffc4 	movi	r2,2047
 8212908:	003fa106 	br	8212790 <__divdf3+0x17c>
 821290c:	00c00044 	movi	r3,1
 8212910:	1887c83a 	sub	r3,r3,r2
 8212914:	01000e04 	movi	r4,56
 8212918:	20c1210e 	bge	r4,r3,8212da0 <__divdf3+0x78c>
 821291c:	98c0004c 	andi	r3,r19,1
 8212920:	0005883a 	mov	r2,zero
 8212924:	000b883a 	mov	r5,zero
 8212928:	0025883a 	mov	r18,zero
 821292c:	003f9806 	br	8212790 <__divdf3+0x17c>
 8212930:	8c00fd36 	bltu	r17,r16,8212d28 <__divdf3+0x714>
 8212934:	8440fb26 	beq	r16,r17,8212d24 <__divdf3+0x710>
 8212938:	8007883a 	mov	r3,r16
 821293c:	ad7fffc4 	addi	r21,r21,-1
 8212940:	0021883a 	mov	r16,zero
 8212944:	4004d63a 	srli	r2,r8,24
 8212948:	8822923a 	slli	r17,r17,8
 821294c:	1809883a 	mov	r4,r3
 8212950:	402c923a 	slli	r22,r8,8
 8212954:	88b8b03a 	or	fp,r17,r2
 8212958:	e028d43a 	srli	r20,fp,16
 821295c:	d8c00015 	stw	r3,0(sp)
 8212960:	e5ffffcc 	andi	r23,fp,65535
 8212964:	a00b883a 	mov	r5,r20
 8212968:	8202c100 	call	8202c10 <__udivsi3>
 821296c:	d8c00017 	ldw	r3,0(sp)
 8212970:	a00b883a 	mov	r5,r20
 8212974:	d8800315 	stw	r2,12(sp)
 8212978:	1809883a 	mov	r4,r3
 821297c:	8202c740 	call	8202c74 <__umodsi3>
 8212980:	d9800317 	ldw	r6,12(sp)
 8212984:	1006943a 	slli	r3,r2,16
 8212988:	9004d43a 	srli	r2,r18,16
 821298c:	b9a3383a 	mul	r17,r23,r6
 8212990:	10c4b03a 	or	r2,r2,r3
 8212994:	1440062e 	bgeu	r2,r17,82129b0 <__divdf3+0x39c>
 8212998:	1705883a 	add	r2,r2,fp
 821299c:	30ffffc4 	addi	r3,r6,-1
 82129a0:	1700ee36 	bltu	r2,fp,8212d5c <__divdf3+0x748>
 82129a4:	1440ed2e 	bgeu	r2,r17,8212d5c <__divdf3+0x748>
 82129a8:	31bfff84 	addi	r6,r6,-2
 82129ac:	1705883a 	add	r2,r2,fp
 82129b0:	1463c83a 	sub	r17,r2,r17
 82129b4:	a00b883a 	mov	r5,r20
 82129b8:	8809883a 	mov	r4,r17
 82129bc:	d9800315 	stw	r6,12(sp)
 82129c0:	8202c100 	call	8202c10 <__udivsi3>
 82129c4:	a00b883a 	mov	r5,r20
 82129c8:	8809883a 	mov	r4,r17
 82129cc:	d8800215 	stw	r2,8(sp)
 82129d0:	8202c740 	call	8202c74 <__umodsi3>
 82129d4:	d9c00217 	ldw	r7,8(sp)
 82129d8:	1004943a 	slli	r2,r2,16
 82129dc:	94bfffcc 	andi	r18,r18,65535
 82129e0:	b9d1383a 	mul	r8,r23,r7
 82129e4:	90a4b03a 	or	r18,r18,r2
 82129e8:	d9800317 	ldw	r6,12(sp)
 82129ec:	9200062e 	bgeu	r18,r8,8212a08 <__divdf3+0x3f4>
 82129f0:	9725883a 	add	r18,r18,fp
 82129f4:	38bfffc4 	addi	r2,r7,-1
 82129f8:	9700d636 	bltu	r18,fp,8212d54 <__divdf3+0x740>
 82129fc:	9200d52e 	bgeu	r18,r8,8212d54 <__divdf3+0x740>
 8212a00:	39ffff84 	addi	r7,r7,-2
 8212a04:	9725883a 	add	r18,r18,fp
 8212a08:	3004943a 	slli	r2,r6,16
 8212a0c:	b012d43a 	srli	r9,r22,16
 8212a10:	b1bfffcc 	andi	r6,r22,65535
 8212a14:	11e2b03a 	or	r17,r2,r7
 8212a18:	8806d43a 	srli	r3,r17,16
 8212a1c:	893fffcc 	andi	r4,r17,65535
 8212a20:	218b383a 	mul	r5,r4,r6
 8212a24:	30c5383a 	mul	r2,r6,r3
 8212a28:	2249383a 	mul	r4,r4,r9
 8212a2c:	280ed43a 	srli	r7,r5,16
 8212a30:	9225c83a 	sub	r18,r18,r8
 8212a34:	2089883a 	add	r4,r4,r2
 8212a38:	3909883a 	add	r4,r7,r4
 8212a3c:	1a47383a 	mul	r3,r3,r9
 8212a40:	2080022e 	bgeu	r4,r2,8212a4c <__divdf3+0x438>
 8212a44:	00800074 	movhi	r2,1
 8212a48:	1887883a 	add	r3,r3,r2
 8212a4c:	2004d43a 	srli	r2,r4,16
 8212a50:	2008943a 	slli	r4,r4,16
 8212a54:	297fffcc 	andi	r5,r5,65535
 8212a58:	10c7883a 	add	r3,r2,r3
 8212a5c:	2149883a 	add	r4,r4,r5
 8212a60:	90c0a536 	bltu	r18,r3,8212cf8 <__divdf3+0x6e4>
 8212a64:	90c0bf26 	beq	r18,r3,8212d64 <__divdf3+0x750>
 8212a68:	90c7c83a 	sub	r3,r18,r3
 8212a6c:	810fc83a 	sub	r7,r16,r4
 8212a70:	81e5803a 	cmpltu	r18,r16,r7
 8212a74:	1ca5c83a 	sub	r18,r3,r18
 8212a78:	e480c126 	beq	fp,r18,8212d80 <__divdf3+0x76c>
 8212a7c:	a00b883a 	mov	r5,r20
 8212a80:	9009883a 	mov	r4,r18
 8212a84:	d9800315 	stw	r6,12(sp)
 8212a88:	d9c00215 	stw	r7,8(sp)
 8212a8c:	da400115 	stw	r9,4(sp)
 8212a90:	8202c100 	call	8202c10 <__udivsi3>
 8212a94:	a00b883a 	mov	r5,r20
 8212a98:	9009883a 	mov	r4,r18
 8212a9c:	d8800015 	stw	r2,0(sp)
 8212aa0:	8202c740 	call	8202c74 <__umodsi3>
 8212aa4:	d9c00217 	ldw	r7,8(sp)
 8212aa8:	da000017 	ldw	r8,0(sp)
 8212aac:	1006943a 	slli	r3,r2,16
 8212ab0:	3804d43a 	srli	r2,r7,16
 8212ab4:	ba21383a 	mul	r16,r23,r8
 8212ab8:	d9800317 	ldw	r6,12(sp)
 8212abc:	10c4b03a 	or	r2,r2,r3
 8212ac0:	da400117 	ldw	r9,4(sp)
 8212ac4:	1400062e 	bgeu	r2,r16,8212ae0 <__divdf3+0x4cc>
 8212ac8:	1705883a 	add	r2,r2,fp
 8212acc:	40ffffc4 	addi	r3,r8,-1
 8212ad0:	1700ad36 	bltu	r2,fp,8212d88 <__divdf3+0x774>
 8212ad4:	1400ac2e 	bgeu	r2,r16,8212d88 <__divdf3+0x774>
 8212ad8:	423fff84 	addi	r8,r8,-2
 8212adc:	1705883a 	add	r2,r2,fp
 8212ae0:	1421c83a 	sub	r16,r2,r16
 8212ae4:	a00b883a 	mov	r5,r20
 8212ae8:	8009883a 	mov	r4,r16
 8212aec:	d9800315 	stw	r6,12(sp)
 8212af0:	d9c00215 	stw	r7,8(sp)
 8212af4:	da000015 	stw	r8,0(sp)
 8212af8:	da400115 	stw	r9,4(sp)
 8212afc:	8202c100 	call	8202c10 <__udivsi3>
 8212b00:	8009883a 	mov	r4,r16
 8212b04:	a00b883a 	mov	r5,r20
 8212b08:	1025883a 	mov	r18,r2
 8212b0c:	8202c740 	call	8202c74 <__umodsi3>
 8212b10:	d9c00217 	ldw	r7,8(sp)
 8212b14:	1004943a 	slli	r2,r2,16
 8212b18:	bcaf383a 	mul	r23,r23,r18
 8212b1c:	393fffcc 	andi	r4,r7,65535
 8212b20:	2088b03a 	or	r4,r4,r2
 8212b24:	d9800317 	ldw	r6,12(sp)
 8212b28:	da000017 	ldw	r8,0(sp)
 8212b2c:	da400117 	ldw	r9,4(sp)
 8212b30:	25c0062e 	bgeu	r4,r23,8212b4c <__divdf3+0x538>
 8212b34:	2709883a 	add	r4,r4,fp
 8212b38:	90bfffc4 	addi	r2,r18,-1
 8212b3c:	27009436 	bltu	r4,fp,8212d90 <__divdf3+0x77c>
 8212b40:	25c0932e 	bgeu	r4,r23,8212d90 <__divdf3+0x77c>
 8212b44:	94bfff84 	addi	r18,r18,-2
 8212b48:	2709883a 	add	r4,r4,fp
 8212b4c:	4004943a 	slli	r2,r8,16
 8212b50:	25efc83a 	sub	r23,r4,r23
 8212b54:	1490b03a 	or	r8,r2,r18
 8212b58:	4008d43a 	srli	r4,r8,16
 8212b5c:	40ffffcc 	andi	r3,r8,65535
 8212b60:	30c5383a 	mul	r2,r6,r3
 8212b64:	1a47383a 	mul	r3,r3,r9
 8212b68:	310d383a 	mul	r6,r6,r4
 8212b6c:	100ad43a 	srli	r5,r2,16
 8212b70:	4913383a 	mul	r9,r9,r4
 8212b74:	1987883a 	add	r3,r3,r6
 8212b78:	28c7883a 	add	r3,r5,r3
 8212b7c:	1980022e 	bgeu	r3,r6,8212b88 <__divdf3+0x574>
 8212b80:	01000074 	movhi	r4,1
 8212b84:	4913883a 	add	r9,r9,r4
 8212b88:	1808d43a 	srli	r4,r3,16
 8212b8c:	1806943a 	slli	r3,r3,16
 8212b90:	10bfffcc 	andi	r2,r2,65535
 8212b94:	2253883a 	add	r9,r4,r9
 8212b98:	1887883a 	add	r3,r3,r2
 8212b9c:	ba403836 	bltu	r23,r9,8212c80 <__divdf3+0x66c>
 8212ba0:	ba403626 	beq	r23,r9,8212c7c <__divdf3+0x668>
 8212ba4:	42000054 	ori	r8,r8,1
 8212ba8:	a880ffc4 	addi	r2,r21,1023
 8212bac:	00bf570e 	bge	zero,r2,821290c <__divdf3+0x2f8>
 8212bb0:	40c001cc 	andi	r3,r8,7
 8212bb4:	18000726 	beq	r3,zero,8212bd4 <__divdf3+0x5c0>
 8212bb8:	40c003cc 	andi	r3,r8,15
 8212bbc:	01000104 	movi	r4,4
 8212bc0:	19000426 	beq	r3,r4,8212bd4 <__divdf3+0x5c0>
 8212bc4:	4107883a 	add	r3,r8,r4
 8212bc8:	1a11803a 	cmpltu	r8,r3,r8
 8212bcc:	8a23883a 	add	r17,r17,r8
 8212bd0:	1811883a 	mov	r8,r3
 8212bd4:	88c0402c 	andhi	r3,r17,256
 8212bd8:	18000426 	beq	r3,zero,8212bec <__divdf3+0x5d8>
 8212bdc:	00ffc034 	movhi	r3,65280
 8212be0:	18ffffc4 	addi	r3,r3,-1
 8212be4:	a8810004 	addi	r2,r21,1024
 8212be8:	88e2703a 	and	r17,r17,r3
 8212bec:	00c1ff84 	movi	r3,2046
 8212bf0:	18bee316 	blt	r3,r2,8212780 <__divdf3+0x16c>
 8212bf4:	8824977a 	slli	r18,r17,29
 8212bf8:	4010d0fa 	srli	r8,r8,3
 8212bfc:	8822927a 	slli	r17,r17,9
 8212c00:	1081ffcc 	andi	r2,r2,2047
 8212c04:	9224b03a 	or	r18,r18,r8
 8212c08:	880ad33a 	srli	r5,r17,12
 8212c0c:	98c0004c 	andi	r3,r19,1
 8212c10:	003edf06 	br	8212790 <__divdf3+0x17c>
 8212c14:	8080022c 	andhi	r2,r16,8
 8212c18:	10001226 	beq	r2,zero,8212c64 <__divdf3+0x650>
 8212c1c:	8880022c 	andhi	r2,r17,8
 8212c20:	1000101e 	bne	r2,zero,8212c64 <__divdf3+0x650>
 8212c24:	00800434 	movhi	r2,16
 8212c28:	89400234 	orhi	r5,r17,8
 8212c2c:	10bfffc4 	addi	r2,r2,-1
 8212c30:	b007883a 	mov	r3,r22
 8212c34:	288a703a 	and	r5,r5,r2
 8212c38:	4025883a 	mov	r18,r8
 8212c3c:	003f3106 	br	8212904 <__divdf3+0x2f0>
 8212c40:	008000c4 	movi	r2,3
 8212c44:	3880a626 	beq	r7,r2,8212ee0 <__divdf3+0x8cc>
 8212c48:	00800044 	movi	r2,1
 8212c4c:	3880521e 	bne	r7,r2,8212d98 <__divdf3+0x784>
 8212c50:	b807883a 	mov	r3,r23
 8212c54:	0005883a 	mov	r2,zero
 8212c58:	000b883a 	mov	r5,zero
 8212c5c:	0025883a 	mov	r18,zero
 8212c60:	003ecb06 	br	8212790 <__divdf3+0x17c>
 8212c64:	00800434 	movhi	r2,16
 8212c68:	81400234 	orhi	r5,r16,8
 8212c6c:	10bfffc4 	addi	r2,r2,-1
 8212c70:	a007883a 	mov	r3,r20
 8212c74:	288a703a 	and	r5,r5,r2
 8212c78:	003f2206 	br	8212904 <__divdf3+0x2f0>
 8212c7c:	183fca26 	beq	r3,zero,8212ba8 <__divdf3+0x594>
 8212c80:	e5ef883a 	add	r23,fp,r23
 8212c84:	40bfffc4 	addi	r2,r8,-1
 8212c88:	bf00392e 	bgeu	r23,fp,8212d70 <__divdf3+0x75c>
 8212c8c:	1011883a 	mov	r8,r2
 8212c90:	ba7fc41e 	bne	r23,r9,8212ba4 <__divdf3+0x590>
 8212c94:	b0ffc31e 	bne	r22,r3,8212ba4 <__divdf3+0x590>
 8212c98:	003fc306 	br	8212ba8 <__divdf3+0x594>
 8212c9c:	143ff604 	addi	r16,r2,-40
 8212ca0:	9c20983a 	sll	r16,r19,r16
 8212ca4:	0025883a 	mov	r18,zero
 8212ca8:	003ee206 	br	8212834 <__divdf3+0x220>
 8212cac:	d9800315 	stw	r6,12(sp)
 8212cb0:	d9c00215 	stw	r7,8(sp)
 8212cb4:	821436c0 	call	821436c <__clzsi2>
 8212cb8:	10800804 	addi	r2,r2,32
 8212cbc:	d9c00217 	ldw	r7,8(sp)
 8212cc0:	d9800317 	ldw	r6,12(sp)
 8212cc4:	003ed106 	br	821280c <__divdf3+0x1f8>
 8212cc8:	147ff604 	addi	r17,r2,-40
 8212ccc:	3462983a 	sll	r17,r6,r17
 8212cd0:	0011883a 	mov	r8,zero
 8212cd4:	003ef506 	br	82128ac <__divdf3+0x298>
 8212cd8:	3009883a 	mov	r4,r6
 8212cdc:	d9800315 	stw	r6,12(sp)
 8212ce0:	da400115 	stw	r9,4(sp)
 8212ce4:	821436c0 	call	821436c <__clzsi2>
 8212ce8:	10800804 	addi	r2,r2,32
 8212cec:	da400117 	ldw	r9,4(sp)
 8212cf0:	d9800317 	ldw	r6,12(sp)
 8212cf4:	003ee306 	br	8212884 <__divdf3+0x270>
 8212cf8:	85a1883a 	add	r16,r16,r22
 8212cfc:	8585803a 	cmpltu	r2,r16,r22
 8212d00:	1705883a 	add	r2,r2,fp
 8212d04:	14a5883a 	add	r18,r2,r18
 8212d08:	88bfffc4 	addi	r2,r17,-1
 8212d0c:	e4800c2e 	bgeu	fp,r18,8212d40 <__divdf3+0x72c>
 8212d10:	90c03e36 	bltu	r18,r3,8212e0c <__divdf3+0x7f8>
 8212d14:	1c806926 	beq	r3,r18,8212ebc <__divdf3+0x8a8>
 8212d18:	90c7c83a 	sub	r3,r18,r3
 8212d1c:	1023883a 	mov	r17,r2
 8212d20:	003f5206 	br	8212a6c <__divdf3+0x458>
 8212d24:	923f0436 	bltu	r18,r8,8212938 <__divdf3+0x324>
 8212d28:	800897fa 	slli	r4,r16,31
 8212d2c:	9004d07a 	srli	r2,r18,1
 8212d30:	8006d07a 	srli	r3,r16,1
 8212d34:	902097fa 	slli	r16,r18,31
 8212d38:	20a4b03a 	or	r18,r4,r2
 8212d3c:	003f0106 	br	8212944 <__divdf3+0x330>
 8212d40:	e4bff51e 	bne	fp,r18,8212d18 <__divdf3+0x704>
 8212d44:	85bff22e 	bgeu	r16,r22,8212d10 <__divdf3+0x6fc>
 8212d48:	e0c7c83a 	sub	r3,fp,r3
 8212d4c:	1023883a 	mov	r17,r2
 8212d50:	003f4606 	br	8212a6c <__divdf3+0x458>
 8212d54:	100f883a 	mov	r7,r2
 8212d58:	003f2b06 	br	8212a08 <__divdf3+0x3f4>
 8212d5c:	180d883a 	mov	r6,r3
 8212d60:	003f1306 	br	82129b0 <__divdf3+0x39c>
 8212d64:	813fe436 	bltu	r16,r4,8212cf8 <__divdf3+0x6e4>
 8212d68:	0007883a 	mov	r3,zero
 8212d6c:	003f3f06 	br	8212a6c <__divdf3+0x458>
 8212d70:	ba402c36 	bltu	r23,r9,8212e24 <__divdf3+0x810>
 8212d74:	4dc05426 	beq	r9,r23,8212ec8 <__divdf3+0x8b4>
 8212d78:	1011883a 	mov	r8,r2
 8212d7c:	003f8906 	br	8212ba4 <__divdf3+0x590>
 8212d80:	023fffc4 	movi	r8,-1
 8212d84:	003f8806 	br	8212ba8 <__divdf3+0x594>
 8212d88:	1811883a 	mov	r8,r3
 8212d8c:	003f5406 	br	8212ae0 <__divdf3+0x4cc>
 8212d90:	1025883a 	mov	r18,r2
 8212d94:	003f6d06 	br	8212b4c <__divdf3+0x538>
 8212d98:	b827883a 	mov	r19,r23
 8212d9c:	003f8206 	br	8212ba8 <__divdf3+0x594>
 8212da0:	010007c4 	movi	r4,31
 8212da4:	20c02616 	blt	r4,r3,8212e40 <__divdf3+0x82c>
 8212da8:	00800804 	movi	r2,32
 8212dac:	10c5c83a 	sub	r2,r2,r3
 8212db0:	888a983a 	sll	r5,r17,r2
 8212db4:	40c8d83a 	srl	r4,r8,r3
 8212db8:	4084983a 	sll	r2,r8,r2
 8212dbc:	88e2d83a 	srl	r17,r17,r3
 8212dc0:	2906b03a 	or	r3,r5,r4
 8212dc4:	1004c03a 	cmpne	r2,r2,zero
 8212dc8:	1886b03a 	or	r3,r3,r2
 8212dcc:	188001cc 	andi	r2,r3,7
 8212dd0:	10000726 	beq	r2,zero,8212df0 <__divdf3+0x7dc>
 8212dd4:	188003cc 	andi	r2,r3,15
 8212dd8:	01000104 	movi	r4,4
 8212ddc:	11000426 	beq	r2,r4,8212df0 <__divdf3+0x7dc>
 8212de0:	1805883a 	mov	r2,r3
 8212de4:	10c00104 	addi	r3,r2,4
 8212de8:	1885803a 	cmpltu	r2,r3,r2
 8212dec:	88a3883a 	add	r17,r17,r2
 8212df0:	8880202c 	andhi	r2,r17,128
 8212df4:	10002726 	beq	r2,zero,8212e94 <__divdf3+0x880>
 8212df8:	98c0004c 	andi	r3,r19,1
 8212dfc:	00800044 	movi	r2,1
 8212e00:	000b883a 	mov	r5,zero
 8212e04:	0025883a 	mov	r18,zero
 8212e08:	003e6106 	br	8212790 <__divdf3+0x17c>
 8212e0c:	85a1883a 	add	r16,r16,r22
 8212e10:	8585803a 	cmpltu	r2,r16,r22
 8212e14:	1705883a 	add	r2,r2,fp
 8212e18:	14a5883a 	add	r18,r2,r18
 8212e1c:	8c7fff84 	addi	r17,r17,-2
 8212e20:	003f1106 	br	8212a68 <__divdf3+0x454>
 8212e24:	b589883a 	add	r4,r22,r22
 8212e28:	25ad803a 	cmpltu	r22,r4,r22
 8212e2c:	b739883a 	add	fp,r22,fp
 8212e30:	40bfff84 	addi	r2,r8,-2
 8212e34:	bf2f883a 	add	r23,r23,fp
 8212e38:	202d883a 	mov	r22,r4
 8212e3c:	003f9306 	br	8212c8c <__divdf3+0x678>
 8212e40:	013ff844 	movi	r4,-31
 8212e44:	2085c83a 	sub	r2,r4,r2
 8212e48:	8888d83a 	srl	r4,r17,r2
 8212e4c:	00800804 	movi	r2,32
 8212e50:	18802126 	beq	r3,r2,8212ed8 <__divdf3+0x8c4>
 8212e54:	00801004 	movi	r2,64
 8212e58:	10c5c83a 	sub	r2,r2,r3
 8212e5c:	8884983a 	sll	r2,r17,r2
 8212e60:	1204b03a 	or	r2,r2,r8
 8212e64:	1004c03a 	cmpne	r2,r2,zero
 8212e68:	2084b03a 	or	r2,r4,r2
 8212e6c:	144001cc 	andi	r17,r2,7
 8212e70:	88000d1e 	bne	r17,zero,8212ea8 <__divdf3+0x894>
 8212e74:	000b883a 	mov	r5,zero
 8212e78:	1024d0fa 	srli	r18,r2,3
 8212e7c:	98c0004c 	andi	r3,r19,1
 8212e80:	0005883a 	mov	r2,zero
 8212e84:	9464b03a 	or	r18,r18,r17
 8212e88:	003e4106 	br	8212790 <__divdf3+0x17c>
 8212e8c:	1007883a 	mov	r3,r2
 8212e90:	0023883a 	mov	r17,zero
 8212e94:	880a927a 	slli	r5,r17,9
 8212e98:	1805883a 	mov	r2,r3
 8212e9c:	8822977a 	slli	r17,r17,29
 8212ea0:	280ad33a 	srli	r5,r5,12
 8212ea4:	003ff406 	br	8212e78 <__divdf3+0x864>
 8212ea8:	10c003cc 	andi	r3,r2,15
 8212eac:	01000104 	movi	r4,4
 8212eb0:	193ff626 	beq	r3,r4,8212e8c <__divdf3+0x878>
 8212eb4:	0023883a 	mov	r17,zero
 8212eb8:	003fca06 	br	8212de4 <__divdf3+0x7d0>
 8212ebc:	813fd336 	bltu	r16,r4,8212e0c <__divdf3+0x7f8>
 8212ec0:	1023883a 	mov	r17,r2
 8212ec4:	003fa806 	br	8212d68 <__divdf3+0x754>
 8212ec8:	b0ffd636 	bltu	r22,r3,8212e24 <__divdf3+0x810>
 8212ecc:	1011883a 	mov	r8,r2
 8212ed0:	b0ff341e 	bne	r22,r3,8212ba4 <__divdf3+0x590>
 8212ed4:	003f3406 	br	8212ba8 <__divdf3+0x594>
 8212ed8:	0005883a 	mov	r2,zero
 8212edc:	003fe006 	br	8212e60 <__divdf3+0x84c>
 8212ee0:	00800434 	movhi	r2,16
 8212ee4:	89400234 	orhi	r5,r17,8
 8212ee8:	10bfffc4 	addi	r2,r2,-1
 8212eec:	b807883a 	mov	r3,r23
 8212ef0:	288a703a 	and	r5,r5,r2
 8212ef4:	4025883a 	mov	r18,r8
 8212ef8:	003e8206 	br	8212904 <__divdf3+0x2f0>

08212efc <__eqdf2>:
 8212efc:	2804d53a 	srli	r2,r5,20
 8212f00:	3806d53a 	srli	r3,r7,20
 8212f04:	02000434 	movhi	r8,16
 8212f08:	423fffc4 	addi	r8,r8,-1
 8212f0c:	1081ffcc 	andi	r2,r2,2047
 8212f10:	0281ffc4 	movi	r10,2047
 8212f14:	2a12703a 	and	r9,r5,r8
 8212f18:	18c1ffcc 	andi	r3,r3,2047
 8212f1c:	3a10703a 	and	r8,r7,r8
 8212f20:	280ad7fa 	srli	r5,r5,31
 8212f24:	380ed7fa 	srli	r7,r7,31
 8212f28:	12801026 	beq	r2,r10,8212f6c <__eqdf2+0x70>
 8212f2c:	0281ffc4 	movi	r10,2047
 8212f30:	1a800a26 	beq	r3,r10,8212f5c <__eqdf2+0x60>
 8212f34:	10c00226 	beq	r2,r3,8212f40 <__eqdf2+0x44>
 8212f38:	00800044 	movi	r2,1
 8212f3c:	f800283a 	ret
 8212f40:	4a3ffd1e 	bne	r9,r8,8212f38 <__eqdf2+0x3c>
 8212f44:	21bffc1e 	bne	r4,r6,8212f38 <__eqdf2+0x3c>
 8212f48:	29c00c26 	beq	r5,r7,8212f7c <__eqdf2+0x80>
 8212f4c:	103ffa1e 	bne	r2,zero,8212f38 <__eqdf2+0x3c>
 8212f50:	2244b03a 	or	r2,r4,r9
 8212f54:	1004c03a 	cmpne	r2,r2,zero
 8212f58:	f800283a 	ret
 8212f5c:	3214b03a 	or	r10,r6,r8
 8212f60:	503ff426 	beq	r10,zero,8212f34 <__eqdf2+0x38>
 8212f64:	00800044 	movi	r2,1
 8212f68:	f800283a 	ret
 8212f6c:	2254b03a 	or	r10,r4,r9
 8212f70:	503fee26 	beq	r10,zero,8212f2c <__eqdf2+0x30>
 8212f74:	00800044 	movi	r2,1
 8212f78:	f800283a 	ret
 8212f7c:	0005883a 	mov	r2,zero
 8212f80:	f800283a 	ret

08212f84 <__gedf2>:
 8212f84:	2804d53a 	srli	r2,r5,20
 8212f88:	3806d53a 	srli	r3,r7,20
 8212f8c:	02000434 	movhi	r8,16
 8212f90:	423fffc4 	addi	r8,r8,-1
 8212f94:	1081ffcc 	andi	r2,r2,2047
 8212f98:	0241ffc4 	movi	r9,2047
 8212f9c:	2a14703a 	and	r10,r5,r8
 8212fa0:	18c1ffcc 	andi	r3,r3,2047
 8212fa4:	3a10703a 	and	r8,r7,r8
 8212fa8:	280ad7fa 	srli	r5,r5,31
 8212fac:	380ed7fa 	srli	r7,r7,31
 8212fb0:	12401d26 	beq	r2,r9,8213028 <__gedf2+0xa4>
 8212fb4:	0241ffc4 	movi	r9,2047
 8212fb8:	1a401226 	beq	r3,r9,8213004 <__gedf2+0x80>
 8212fbc:	1000081e 	bne	r2,zero,8212fe0 <__gedf2+0x5c>
 8212fc0:	2296b03a 	or	r11,r4,r10
 8212fc4:	5813003a 	cmpeq	r9,r11,zero
 8212fc8:	1800091e 	bne	r3,zero,8212ff0 <__gedf2+0x6c>
 8212fcc:	3218b03a 	or	r12,r6,r8
 8212fd0:	6000071e 	bne	r12,zero,8212ff0 <__gedf2+0x6c>
 8212fd4:	0005883a 	mov	r2,zero
 8212fd8:	5800101e 	bne	r11,zero,821301c <__gedf2+0x98>
 8212fdc:	f800283a 	ret
 8212fe0:	18000c1e 	bne	r3,zero,8213014 <__gedf2+0x90>
 8212fe4:	3212b03a 	or	r9,r6,r8
 8212fe8:	48000c26 	beq	r9,zero,821301c <__gedf2+0x98>
 8212fec:	0013883a 	mov	r9,zero
 8212ff0:	39c03fcc 	andi	r7,r7,255
 8212ff4:	48000826 	beq	r9,zero,8213018 <__gedf2+0x94>
 8212ff8:	38000926 	beq	r7,zero,8213020 <__gedf2+0x9c>
 8212ffc:	00800044 	movi	r2,1
 8213000:	f800283a 	ret
 8213004:	3212b03a 	or	r9,r6,r8
 8213008:	483fec26 	beq	r9,zero,8212fbc <__gedf2+0x38>
 821300c:	00bfff84 	movi	r2,-2
 8213010:	f800283a 	ret
 8213014:	39c03fcc 	andi	r7,r7,255
 8213018:	29c00626 	beq	r5,r7,8213034 <__gedf2+0xb0>
 821301c:	283ff726 	beq	r5,zero,8212ffc <__gedf2+0x78>
 8213020:	00bfffc4 	movi	r2,-1
 8213024:	f800283a 	ret
 8213028:	2292b03a 	or	r9,r4,r10
 821302c:	483fe126 	beq	r9,zero,8212fb4 <__gedf2+0x30>
 8213030:	003ff606 	br	821300c <__gedf2+0x88>
 8213034:	18bff916 	blt	r3,r2,821301c <__gedf2+0x98>
 8213038:	10c00316 	blt	r2,r3,8213048 <__gedf2+0xc4>
 821303c:	42bff736 	bltu	r8,r10,821301c <__gedf2+0x98>
 8213040:	52000326 	beq	r10,r8,8213050 <__gedf2+0xcc>
 8213044:	5200042e 	bgeu	r10,r8,8213058 <__gedf2+0xd4>
 8213048:	283fec1e 	bne	r5,zero,8212ffc <__gedf2+0x78>
 821304c:	003ff406 	br	8213020 <__gedf2+0x9c>
 8213050:	313ff236 	bltu	r6,r4,821301c <__gedf2+0x98>
 8213054:	21bffc36 	bltu	r4,r6,8213048 <__gedf2+0xc4>
 8213058:	0005883a 	mov	r2,zero
 821305c:	f800283a 	ret

08213060 <__ledf2>:
 8213060:	2804d53a 	srli	r2,r5,20
 8213064:	3810d53a 	srli	r8,r7,20
 8213068:	00c00434 	movhi	r3,16
 821306c:	18ffffc4 	addi	r3,r3,-1
 8213070:	1081ffcc 	andi	r2,r2,2047
 8213074:	0241ffc4 	movi	r9,2047
 8213078:	28d4703a 	and	r10,r5,r3
 821307c:	4201ffcc 	andi	r8,r8,2047
 8213080:	38c6703a 	and	r3,r7,r3
 8213084:	280ad7fa 	srli	r5,r5,31
 8213088:	380ed7fa 	srli	r7,r7,31
 821308c:	12401f26 	beq	r2,r9,821310c <__ledf2+0xac>
 8213090:	0241ffc4 	movi	r9,2047
 8213094:	42401426 	beq	r8,r9,82130e8 <__ledf2+0x88>
 8213098:	1000091e 	bne	r2,zero,82130c0 <__ledf2+0x60>
 821309c:	2296b03a 	or	r11,r4,r10
 82130a0:	5813003a 	cmpeq	r9,r11,zero
 82130a4:	29403fcc 	andi	r5,r5,255
 82130a8:	40000a1e 	bne	r8,zero,82130d4 <__ledf2+0x74>
 82130ac:	30d8b03a 	or	r12,r6,r3
 82130b0:	6000081e 	bne	r12,zero,82130d4 <__ledf2+0x74>
 82130b4:	0005883a 	mov	r2,zero
 82130b8:	5800111e 	bne	r11,zero,8213100 <__ledf2+0xa0>
 82130bc:	f800283a 	ret
 82130c0:	29403fcc 	andi	r5,r5,255
 82130c4:	40000c1e 	bne	r8,zero,82130f8 <__ledf2+0x98>
 82130c8:	30d2b03a 	or	r9,r6,r3
 82130cc:	48000c26 	beq	r9,zero,8213100 <__ledf2+0xa0>
 82130d0:	0013883a 	mov	r9,zero
 82130d4:	39c03fcc 	andi	r7,r7,255
 82130d8:	48000826 	beq	r9,zero,82130fc <__ledf2+0x9c>
 82130dc:	38001126 	beq	r7,zero,8213124 <__ledf2+0xc4>
 82130e0:	00800044 	movi	r2,1
 82130e4:	f800283a 	ret
 82130e8:	30d2b03a 	or	r9,r6,r3
 82130ec:	483fea26 	beq	r9,zero,8213098 <__ledf2+0x38>
 82130f0:	00800084 	movi	r2,2
 82130f4:	f800283a 	ret
 82130f8:	39c03fcc 	andi	r7,r7,255
 82130fc:	39400726 	beq	r7,r5,821311c <__ledf2+0xbc>
 8213100:	2800081e 	bne	r5,zero,8213124 <__ledf2+0xc4>
 8213104:	00800044 	movi	r2,1
 8213108:	f800283a 	ret
 821310c:	2292b03a 	or	r9,r4,r10
 8213110:	483fdf26 	beq	r9,zero,8213090 <__ledf2+0x30>
 8213114:	00800084 	movi	r2,2
 8213118:	f800283a 	ret
 821311c:	4080030e 	bge	r8,r2,821312c <__ledf2+0xcc>
 8213120:	383fef26 	beq	r7,zero,82130e0 <__ledf2+0x80>
 8213124:	00bfffc4 	movi	r2,-1
 8213128:	f800283a 	ret
 821312c:	123feb16 	blt	r2,r8,82130dc <__ledf2+0x7c>
 8213130:	1abff336 	bltu	r3,r10,8213100 <__ledf2+0xa0>
 8213134:	50c00326 	beq	r10,r3,8213144 <__ledf2+0xe4>
 8213138:	50c0042e 	bgeu	r10,r3,821314c <__ledf2+0xec>
 821313c:	283fe81e 	bne	r5,zero,82130e0 <__ledf2+0x80>
 8213140:	003ff806 	br	8213124 <__ledf2+0xc4>
 8213144:	313fee36 	bltu	r6,r4,8213100 <__ledf2+0xa0>
 8213148:	21bffc36 	bltu	r4,r6,821313c <__ledf2+0xdc>
 821314c:	0005883a 	mov	r2,zero
 8213150:	f800283a 	ret

08213154 <__muldf3>:
 8213154:	defff304 	addi	sp,sp,-52
 8213158:	2804d53a 	srli	r2,r5,20
 821315c:	dd800915 	stw	r22,36(sp)
 8213160:	282cd7fa 	srli	r22,r5,31
 8213164:	dc000315 	stw	r16,12(sp)
 8213168:	04000434 	movhi	r16,16
 821316c:	dd400815 	stw	r21,32(sp)
 8213170:	dc800515 	stw	r18,20(sp)
 8213174:	843fffc4 	addi	r16,r16,-1
 8213178:	dfc00c15 	stw	ra,48(sp)
 821317c:	df000b15 	stw	fp,44(sp)
 8213180:	ddc00a15 	stw	r23,40(sp)
 8213184:	dd000715 	stw	r20,28(sp)
 8213188:	dcc00615 	stw	r19,24(sp)
 821318c:	dc400415 	stw	r17,16(sp)
 8213190:	1481ffcc 	andi	r18,r2,2047
 8213194:	2c20703a 	and	r16,r5,r16
 8213198:	b02b883a 	mov	r21,r22
 821319c:	b2403fcc 	andi	r9,r22,255
 82131a0:	90006026 	beq	r18,zero,8213324 <__muldf3+0x1d0>
 82131a4:	0081ffc4 	movi	r2,2047
 82131a8:	2029883a 	mov	r20,r4
 82131ac:	90803626 	beq	r18,r2,8213288 <__muldf3+0x134>
 82131b0:	80800434 	orhi	r2,r16,16
 82131b4:	100490fa 	slli	r2,r2,3
 82131b8:	2020d77a 	srli	r16,r4,29
 82131bc:	202890fa 	slli	r20,r4,3
 82131c0:	94bf0044 	addi	r18,r18,-1023
 82131c4:	80a0b03a 	or	r16,r16,r2
 82131c8:	0027883a 	mov	r19,zero
 82131cc:	0039883a 	mov	fp,zero
 82131d0:	3804d53a 	srli	r2,r7,20
 82131d4:	382ed7fa 	srli	r23,r7,31
 82131d8:	04400434 	movhi	r17,16
 82131dc:	8c7fffc4 	addi	r17,r17,-1
 82131e0:	1081ffcc 	andi	r2,r2,2047
 82131e4:	3011883a 	mov	r8,r6
 82131e8:	3c62703a 	and	r17,r7,r17
 82131ec:	ba803fcc 	andi	r10,r23,255
 82131f0:	10006d26 	beq	r2,zero,82133a8 <__muldf3+0x254>
 82131f4:	00c1ffc4 	movi	r3,2047
 82131f8:	10c06526 	beq	r2,r3,8213390 <__muldf3+0x23c>
 82131fc:	88c00434 	orhi	r3,r17,16
 8213200:	180690fa 	slli	r3,r3,3
 8213204:	3022d77a 	srli	r17,r6,29
 8213208:	301090fa 	slli	r8,r6,3
 821320c:	10bf0044 	addi	r2,r2,-1023
 8213210:	88e2b03a 	or	r17,r17,r3
 8213214:	000b883a 	mov	r5,zero
 8213218:	9085883a 	add	r2,r18,r2
 821321c:	2cc8b03a 	or	r4,r5,r19
 8213220:	00c003c4 	movi	r3,15
 8213224:	bdacf03a 	xor	r22,r23,r22
 8213228:	12c00044 	addi	r11,r2,1
 821322c:	19009936 	bltu	r3,r4,8213494 <__muldf3+0x340>
 8213230:	200890ba 	slli	r4,r4,2
 8213234:	00c20874 	movhi	r3,2081
 8213238:	18cc9204 	addi	r3,r3,12872
 821323c:	20c9883a 	add	r4,r4,r3
 8213240:	20c00017 	ldw	r3,0(r4)
 8213244:	1800683a 	jmp	r3
 8213248:	08213494 	ori	zero,at,34002
 821324c:	082132a8 	cmpgeui	zero,at,33994
 8213250:	082132a8 	cmpgeui	zero,at,33994
 8213254:	082132a4 	muli	zero,at,-31542
 8213258:	08213470 	cmpltui	zero,at,34001
 821325c:	08213470 	cmpltui	zero,at,34001
 8213260:	08213458 	cmpnei	zero,at,-31535
 8213264:	082132a4 	muli	zero,at,-31542
 8213268:	08213470 	cmpltui	zero,at,34001
 821326c:	08213458 	cmpnei	zero,at,-31535
 8213270:	08213470 	cmpltui	zero,at,34001
 8213274:	082132a4 	muli	zero,at,-31542
 8213278:	08213480 	call	821348 <OSCtxSw_SWITCH_PC+0x821308>
 821327c:	08213480 	call	821348 <OSCtxSw_SWITCH_PC+0x821308>
 8213280:	08213480 	call	821348 <OSCtxSw_SWITCH_PC+0x821308>
 8213284:	0821369c 	xori	zero,at,34010
 8213288:	2404b03a 	or	r2,r4,r16
 821328c:	10006f1e 	bne	r2,zero,821344c <__muldf3+0x2f8>
 8213290:	04c00204 	movi	r19,8
 8213294:	0021883a 	mov	r16,zero
 8213298:	0029883a 	mov	r20,zero
 821329c:	07000084 	movi	fp,2
 82132a0:	003fcb06 	br	82131d0 <__muldf3+0x7c>
 82132a4:	502d883a 	mov	r22,r10
 82132a8:	00800084 	movi	r2,2
 82132ac:	28805726 	beq	r5,r2,821340c <__muldf3+0x2b8>
 82132b0:	008000c4 	movi	r2,3
 82132b4:	28816626 	beq	r5,r2,8213850 <__muldf3+0x6fc>
 82132b8:	00800044 	movi	r2,1
 82132bc:	2881411e 	bne	r5,r2,82137c4 <__muldf3+0x670>
 82132c0:	b02b883a 	mov	r21,r22
 82132c4:	0005883a 	mov	r2,zero
 82132c8:	000b883a 	mov	r5,zero
 82132cc:	0029883a 	mov	r20,zero
 82132d0:	1004953a 	slli	r2,r2,20
 82132d4:	a8c03fcc 	andi	r3,r21,255
 82132d8:	04400434 	movhi	r17,16
 82132dc:	8c7fffc4 	addi	r17,r17,-1
 82132e0:	180697fa 	slli	r3,r3,31
 82132e4:	2c4a703a 	and	r5,r5,r17
 82132e8:	288ab03a 	or	r5,r5,r2
 82132ec:	28c6b03a 	or	r3,r5,r3
 82132f0:	a005883a 	mov	r2,r20
 82132f4:	dfc00c17 	ldw	ra,48(sp)
 82132f8:	df000b17 	ldw	fp,44(sp)
 82132fc:	ddc00a17 	ldw	r23,40(sp)
 8213300:	dd800917 	ldw	r22,36(sp)
 8213304:	dd400817 	ldw	r21,32(sp)
 8213308:	dd000717 	ldw	r20,28(sp)
 821330c:	dcc00617 	ldw	r19,24(sp)
 8213310:	dc800517 	ldw	r18,20(sp)
 8213314:	dc400417 	ldw	r17,16(sp)
 8213318:	dc000317 	ldw	r16,12(sp)
 821331c:	dec00d04 	addi	sp,sp,52
 8213320:	f800283a 	ret
 8213324:	2404b03a 	or	r2,r4,r16
 8213328:	2027883a 	mov	r19,r4
 821332c:	10004226 	beq	r2,zero,8213438 <__muldf3+0x2e4>
 8213330:	8000fc26 	beq	r16,zero,8213724 <__muldf3+0x5d0>
 8213334:	8009883a 	mov	r4,r16
 8213338:	d9800215 	stw	r6,8(sp)
 821333c:	d9c00015 	stw	r7,0(sp)
 8213340:	da400115 	stw	r9,4(sp)
 8213344:	821436c0 	call	821436c <__clzsi2>
 8213348:	d9800217 	ldw	r6,8(sp)
 821334c:	d9c00017 	ldw	r7,0(sp)
 8213350:	da400117 	ldw	r9,4(sp)
 8213354:	113ffd44 	addi	r4,r2,-11
 8213358:	00c00704 	movi	r3,28
 821335c:	1900ed16 	blt	r3,r4,8213714 <__muldf3+0x5c0>
 8213360:	00c00744 	movi	r3,29
 8213364:	147ffe04 	addi	r17,r2,-8
 8213368:	1907c83a 	sub	r3,r3,r4
 821336c:	8460983a 	sll	r16,r16,r17
 8213370:	98c6d83a 	srl	r3,r19,r3
 8213374:	9c68983a 	sll	r20,r19,r17
 8213378:	1c20b03a 	or	r16,r3,r16
 821337c:	1080fcc4 	addi	r2,r2,1011
 8213380:	00a5c83a 	sub	r18,zero,r2
 8213384:	0027883a 	mov	r19,zero
 8213388:	0039883a 	mov	fp,zero
 821338c:	003f9006 	br	82131d0 <__muldf3+0x7c>
 8213390:	3446b03a 	or	r3,r6,r17
 8213394:	1800261e 	bne	r3,zero,8213430 <__muldf3+0x2dc>
 8213398:	0023883a 	mov	r17,zero
 821339c:	0011883a 	mov	r8,zero
 82133a0:	01400084 	movi	r5,2
 82133a4:	003f9c06 	br	8213218 <__muldf3+0xc4>
 82133a8:	3446b03a 	or	r3,r6,r17
 82133ac:	18001c26 	beq	r3,zero,8213420 <__muldf3+0x2cc>
 82133b0:	8800ce26 	beq	r17,zero,82136ec <__muldf3+0x598>
 82133b4:	8809883a 	mov	r4,r17
 82133b8:	d9800215 	stw	r6,8(sp)
 82133bc:	da400115 	stw	r9,4(sp)
 82133c0:	da800015 	stw	r10,0(sp)
 82133c4:	821436c0 	call	821436c <__clzsi2>
 82133c8:	d9800217 	ldw	r6,8(sp)
 82133cc:	da400117 	ldw	r9,4(sp)
 82133d0:	da800017 	ldw	r10,0(sp)
 82133d4:	113ffd44 	addi	r4,r2,-11
 82133d8:	00c00704 	movi	r3,28
 82133dc:	1900bf16 	blt	r3,r4,82136dc <__muldf3+0x588>
 82133e0:	00c00744 	movi	r3,29
 82133e4:	123ffe04 	addi	r8,r2,-8
 82133e8:	1907c83a 	sub	r3,r3,r4
 82133ec:	8a22983a 	sll	r17,r17,r8
 82133f0:	30c6d83a 	srl	r3,r6,r3
 82133f4:	3210983a 	sll	r8,r6,r8
 82133f8:	1c62b03a 	or	r17,r3,r17
 82133fc:	1080fcc4 	addi	r2,r2,1011
 8213400:	0085c83a 	sub	r2,zero,r2
 8213404:	000b883a 	mov	r5,zero
 8213408:	003f8306 	br	8213218 <__muldf3+0xc4>
 821340c:	b02b883a 	mov	r21,r22
 8213410:	0081ffc4 	movi	r2,2047
 8213414:	000b883a 	mov	r5,zero
 8213418:	0029883a 	mov	r20,zero
 821341c:	003fac06 	br	82132d0 <__muldf3+0x17c>
 8213420:	0023883a 	mov	r17,zero
 8213424:	0011883a 	mov	r8,zero
 8213428:	01400044 	movi	r5,1
 821342c:	003f7a06 	br	8213218 <__muldf3+0xc4>
 8213430:	014000c4 	movi	r5,3
 8213434:	003f7806 	br	8213218 <__muldf3+0xc4>
 8213438:	04c00104 	movi	r19,4
 821343c:	0021883a 	mov	r16,zero
 8213440:	0029883a 	mov	r20,zero
 8213444:	07000044 	movi	fp,1
 8213448:	003f6106 	br	82131d0 <__muldf3+0x7c>
 821344c:	04c00304 	movi	r19,12
 8213450:	070000c4 	movi	fp,3
 8213454:	003f5e06 	br	82131d0 <__muldf3+0x7c>
 8213458:	01400434 	movhi	r5,16
 821345c:	002b883a 	mov	r21,zero
 8213460:	297fffc4 	addi	r5,r5,-1
 8213464:	053fffc4 	movi	r20,-1
 8213468:	0081ffc4 	movi	r2,2047
 821346c:	003f9806 	br	82132d0 <__muldf3+0x17c>
 8213470:	8023883a 	mov	r17,r16
 8213474:	a011883a 	mov	r8,r20
 8213478:	e00b883a 	mov	r5,fp
 821347c:	003f8a06 	br	82132a8 <__muldf3+0x154>
 8213480:	8023883a 	mov	r17,r16
 8213484:	a011883a 	mov	r8,r20
 8213488:	482d883a 	mov	r22,r9
 821348c:	e00b883a 	mov	r5,fp
 8213490:	003f8506 	br	82132a8 <__muldf3+0x154>
 8213494:	a00ad43a 	srli	r5,r20,16
 8213498:	401ad43a 	srli	r13,r8,16
 821349c:	a53fffcc 	andi	r20,r20,65535
 82134a0:	423fffcc 	andi	r8,r8,65535
 82134a4:	4519383a 	mul	r12,r8,r20
 82134a8:	4147383a 	mul	r3,r8,r5
 82134ac:	6d09383a 	mul	r4,r13,r20
 82134b0:	600cd43a 	srli	r6,r12,16
 82134b4:	2b5d383a 	mul	r14,r5,r13
 82134b8:	20c9883a 	add	r4,r4,r3
 82134bc:	310d883a 	add	r6,r6,r4
 82134c0:	30c0022e 	bgeu	r6,r3,82134cc <__muldf3+0x378>
 82134c4:	00c00074 	movhi	r3,1
 82134c8:	70dd883a 	add	r14,r14,r3
 82134cc:	8826d43a 	srli	r19,r17,16
 82134d0:	8bffffcc 	andi	r15,r17,65535
 82134d4:	7d23383a 	mul	r17,r15,r20
 82134d8:	7949383a 	mul	r4,r15,r5
 82134dc:	9d29383a 	mul	r20,r19,r20
 82134e0:	8814d43a 	srli	r10,r17,16
 82134e4:	3012943a 	slli	r9,r6,16
 82134e8:	a129883a 	add	r20,r20,r4
 82134ec:	633fffcc 	andi	r12,r12,65535
 82134f0:	5515883a 	add	r10,r10,r20
 82134f4:	3006d43a 	srli	r3,r6,16
 82134f8:	4b13883a 	add	r9,r9,r12
 82134fc:	2ccb383a 	mul	r5,r5,r19
 8213500:	5100022e 	bgeu	r10,r4,821350c <__muldf3+0x3b8>
 8213504:	01000074 	movhi	r4,1
 8213508:	290b883a 	add	r5,r5,r4
 821350c:	802ad43a 	srli	r21,r16,16
 8213510:	843fffcc 	andi	r16,r16,65535
 8213514:	440d383a 	mul	r6,r8,r16
 8213518:	4565383a 	mul	r18,r8,r21
 821351c:	8349383a 	mul	r4,r16,r13
 8213520:	500e943a 	slli	r7,r10,16
 8213524:	3010d43a 	srli	r8,r6,16
 8213528:	5028d43a 	srli	r20,r10,16
 821352c:	2489883a 	add	r4,r4,r18
 8213530:	8abfffcc 	andi	r10,r17,65535
 8213534:	3a95883a 	add	r10,r7,r10
 8213538:	4119883a 	add	r12,r8,r4
 821353c:	a169883a 	add	r20,r20,r5
 8213540:	1a87883a 	add	r3,r3,r10
 8213544:	6d5b383a 	mul	r13,r13,r21
 8213548:	6480022e 	bgeu	r12,r18,8213554 <__muldf3+0x400>
 821354c:	01000074 	movhi	r4,1
 8213550:	691b883a 	add	r13,r13,r4
 8213554:	7c25383a 	mul	r18,r15,r16
 8213558:	7d4b383a 	mul	r5,r15,r21
 821355c:	84cf383a 	mul	r7,r16,r19
 8213560:	901ed43a 	srli	r15,r18,16
 8213564:	6008d43a 	srli	r4,r12,16
 8213568:	6010943a 	slli	r8,r12,16
 821356c:	394f883a 	add	r7,r7,r5
 8213570:	333fffcc 	andi	r12,r6,65535
 8213574:	79df883a 	add	r15,r15,r7
 8213578:	235b883a 	add	r13,r4,r13
 821357c:	9d63383a 	mul	r17,r19,r21
 8213580:	4309883a 	add	r4,r8,r12
 8213584:	7940022e 	bgeu	r15,r5,8213590 <__muldf3+0x43c>
 8213588:	01400074 	movhi	r5,1
 821358c:	8963883a 	add	r17,r17,r5
 8213590:	780a943a 	slli	r5,r15,16
 8213594:	91bfffcc 	andi	r6,r18,65535
 8213598:	70c7883a 	add	r3,r14,r3
 821359c:	298d883a 	add	r6,r5,r6
 82135a0:	1a8f803a 	cmpltu	r7,r3,r10
 82135a4:	350b883a 	add	r5,r6,r20
 82135a8:	20c7883a 	add	r3,r4,r3
 82135ac:	3955883a 	add	r10,r7,r5
 82135b0:	1909803a 	cmpltu	r4,r3,r4
 82135b4:	6a91883a 	add	r8,r13,r10
 82135b8:	780cd43a 	srli	r6,r15,16
 82135bc:	2219883a 	add	r12,r4,r8
 82135c0:	2d0b803a 	cmpltu	r5,r5,r20
 82135c4:	51cf803a 	cmpltu	r7,r10,r7
 82135c8:	29ceb03a 	or	r7,r5,r7
 82135cc:	4351803a 	cmpltu	r8,r8,r13
 82135d0:	610b803a 	cmpltu	r5,r12,r4
 82135d4:	4148b03a 	or	r4,r8,r5
 82135d8:	398f883a 	add	r7,r7,r6
 82135dc:	3909883a 	add	r4,r7,r4
 82135e0:	1810927a 	slli	r8,r3,9
 82135e4:	2449883a 	add	r4,r4,r17
 82135e8:	2008927a 	slli	r4,r4,9
 82135ec:	6022d5fa 	srli	r17,r12,23
 82135f0:	1806d5fa 	srli	r3,r3,23
 82135f4:	4252b03a 	or	r9,r8,r9
 82135f8:	600a927a 	slli	r5,r12,9
 82135fc:	4810c03a 	cmpne	r8,r9,zero
 8213600:	2462b03a 	or	r17,r4,r17
 8213604:	40c6b03a 	or	r3,r8,r3
 8213608:	8900402c 	andhi	r4,r17,256
 821360c:	1950b03a 	or	r8,r3,r5
 8213610:	20000726 	beq	r4,zero,8213630 <__muldf3+0x4dc>
 8213614:	4006d07a 	srli	r3,r8,1
 8213618:	880497fa 	slli	r2,r17,31
 821361c:	4200004c 	andi	r8,r8,1
 8213620:	8822d07a 	srli	r17,r17,1
 8213624:	1a10b03a 	or	r8,r3,r8
 8213628:	1210b03a 	or	r8,r2,r8
 821362c:	5805883a 	mov	r2,r11
 8213630:	1140ffc4 	addi	r5,r2,1023
 8213634:	0140440e 	bge	zero,r5,8213748 <__muldf3+0x5f4>
 8213638:	40c001cc 	andi	r3,r8,7
 821363c:	18000726 	beq	r3,zero,821365c <__muldf3+0x508>
 8213640:	40c003cc 	andi	r3,r8,15
 8213644:	01000104 	movi	r4,4
 8213648:	19000426 	beq	r3,r4,821365c <__muldf3+0x508>
 821364c:	4107883a 	add	r3,r8,r4
 8213650:	1a11803a 	cmpltu	r8,r3,r8
 8213654:	8a23883a 	add	r17,r17,r8
 8213658:	1811883a 	mov	r8,r3
 821365c:	88c0402c 	andhi	r3,r17,256
 8213660:	18000426 	beq	r3,zero,8213674 <__muldf3+0x520>
 8213664:	11410004 	addi	r5,r2,1024
 8213668:	00bfc034 	movhi	r2,65280
 821366c:	10bfffc4 	addi	r2,r2,-1
 8213670:	88a2703a 	and	r17,r17,r2
 8213674:	0081ff84 	movi	r2,2046
 8213678:	117f6416 	blt	r2,r5,821340c <__muldf3+0x2b8>
 821367c:	8828977a 	slli	r20,r17,29
 8213680:	4010d0fa 	srli	r8,r8,3
 8213684:	8822927a 	slli	r17,r17,9
 8213688:	2881ffcc 	andi	r2,r5,2047
 821368c:	a228b03a 	or	r20,r20,r8
 8213690:	880ad33a 	srli	r5,r17,12
 8213694:	b02b883a 	mov	r21,r22
 8213698:	003f0d06 	br	82132d0 <__muldf3+0x17c>
 821369c:	8080022c 	andhi	r2,r16,8
 82136a0:	10000926 	beq	r2,zero,82136c8 <__muldf3+0x574>
 82136a4:	8880022c 	andhi	r2,r17,8
 82136a8:	1000071e 	bne	r2,zero,82136c8 <__muldf3+0x574>
 82136ac:	00800434 	movhi	r2,16
 82136b0:	89400234 	orhi	r5,r17,8
 82136b4:	10bfffc4 	addi	r2,r2,-1
 82136b8:	b82b883a 	mov	r21,r23
 82136bc:	288a703a 	and	r5,r5,r2
 82136c0:	4029883a 	mov	r20,r8
 82136c4:	003f6806 	br	8213468 <__muldf3+0x314>
 82136c8:	00800434 	movhi	r2,16
 82136cc:	81400234 	orhi	r5,r16,8
 82136d0:	10bfffc4 	addi	r2,r2,-1
 82136d4:	288a703a 	and	r5,r5,r2
 82136d8:	003f6306 	br	8213468 <__muldf3+0x314>
 82136dc:	147ff604 	addi	r17,r2,-40
 82136e0:	3462983a 	sll	r17,r6,r17
 82136e4:	0011883a 	mov	r8,zero
 82136e8:	003f4406 	br	82133fc <__muldf3+0x2a8>
 82136ec:	3009883a 	mov	r4,r6
 82136f0:	d9800215 	stw	r6,8(sp)
 82136f4:	da400115 	stw	r9,4(sp)
 82136f8:	da800015 	stw	r10,0(sp)
 82136fc:	821436c0 	call	821436c <__clzsi2>
 8213700:	10800804 	addi	r2,r2,32
 8213704:	da800017 	ldw	r10,0(sp)
 8213708:	da400117 	ldw	r9,4(sp)
 821370c:	d9800217 	ldw	r6,8(sp)
 8213710:	003f3006 	br	82133d4 <__muldf3+0x280>
 8213714:	143ff604 	addi	r16,r2,-40
 8213718:	9c20983a 	sll	r16,r19,r16
 821371c:	0029883a 	mov	r20,zero
 8213720:	003f1606 	br	821337c <__muldf3+0x228>
 8213724:	d9800215 	stw	r6,8(sp)
 8213728:	d9c00015 	stw	r7,0(sp)
 821372c:	da400115 	stw	r9,4(sp)
 8213730:	821436c0 	call	821436c <__clzsi2>
 8213734:	10800804 	addi	r2,r2,32
 8213738:	da400117 	ldw	r9,4(sp)
 821373c:	d9c00017 	ldw	r7,0(sp)
 8213740:	d9800217 	ldw	r6,8(sp)
 8213744:	003f0306 	br	8213354 <__muldf3+0x200>
 8213748:	00c00044 	movi	r3,1
 821374c:	1947c83a 	sub	r3,r3,r5
 8213750:	00800e04 	movi	r2,56
 8213754:	10feda16 	blt	r2,r3,82132c0 <__muldf3+0x16c>
 8213758:	008007c4 	movi	r2,31
 821375c:	10c01b16 	blt	r2,r3,82137cc <__muldf3+0x678>
 8213760:	00800804 	movi	r2,32
 8213764:	10c5c83a 	sub	r2,r2,r3
 8213768:	888a983a 	sll	r5,r17,r2
 821376c:	40c8d83a 	srl	r4,r8,r3
 8213770:	4084983a 	sll	r2,r8,r2
 8213774:	88e2d83a 	srl	r17,r17,r3
 8213778:	2906b03a 	or	r3,r5,r4
 821377c:	1004c03a 	cmpne	r2,r2,zero
 8213780:	1886b03a 	or	r3,r3,r2
 8213784:	188001cc 	andi	r2,r3,7
 8213788:	10000726 	beq	r2,zero,82137a8 <__muldf3+0x654>
 821378c:	188003cc 	andi	r2,r3,15
 8213790:	01000104 	movi	r4,4
 8213794:	11000426 	beq	r2,r4,82137a8 <__muldf3+0x654>
 8213798:	1805883a 	mov	r2,r3
 821379c:	10c00104 	addi	r3,r2,4
 82137a0:	1885803a 	cmpltu	r2,r3,r2
 82137a4:	88a3883a 	add	r17,r17,r2
 82137a8:	8880202c 	andhi	r2,r17,128
 82137ac:	10001c26 	beq	r2,zero,8213820 <__muldf3+0x6cc>
 82137b0:	b02b883a 	mov	r21,r22
 82137b4:	00800044 	movi	r2,1
 82137b8:	000b883a 	mov	r5,zero
 82137bc:	0029883a 	mov	r20,zero
 82137c0:	003ec306 	br	82132d0 <__muldf3+0x17c>
 82137c4:	5805883a 	mov	r2,r11
 82137c8:	003f9906 	br	8213630 <__muldf3+0x4dc>
 82137cc:	00bff844 	movi	r2,-31
 82137d0:	1145c83a 	sub	r2,r2,r5
 82137d4:	8888d83a 	srl	r4,r17,r2
 82137d8:	00800804 	movi	r2,32
 82137dc:	18801a26 	beq	r3,r2,8213848 <__muldf3+0x6f4>
 82137e0:	00801004 	movi	r2,64
 82137e4:	10c5c83a 	sub	r2,r2,r3
 82137e8:	8884983a 	sll	r2,r17,r2
 82137ec:	1204b03a 	or	r2,r2,r8
 82137f0:	1004c03a 	cmpne	r2,r2,zero
 82137f4:	2084b03a 	or	r2,r4,r2
 82137f8:	144001cc 	andi	r17,r2,7
 82137fc:	88000d1e 	bne	r17,zero,8213834 <__muldf3+0x6e0>
 8213800:	000b883a 	mov	r5,zero
 8213804:	1028d0fa 	srli	r20,r2,3
 8213808:	b02b883a 	mov	r21,r22
 821380c:	0005883a 	mov	r2,zero
 8213810:	a468b03a 	or	r20,r20,r17
 8213814:	003eae06 	br	82132d0 <__muldf3+0x17c>
 8213818:	1007883a 	mov	r3,r2
 821381c:	0023883a 	mov	r17,zero
 8213820:	880a927a 	slli	r5,r17,9
 8213824:	1805883a 	mov	r2,r3
 8213828:	8822977a 	slli	r17,r17,29
 821382c:	280ad33a 	srli	r5,r5,12
 8213830:	003ff406 	br	8213804 <__muldf3+0x6b0>
 8213834:	10c003cc 	andi	r3,r2,15
 8213838:	01000104 	movi	r4,4
 821383c:	193ff626 	beq	r3,r4,8213818 <__muldf3+0x6c4>
 8213840:	0023883a 	mov	r17,zero
 8213844:	003fd506 	br	821379c <__muldf3+0x648>
 8213848:	0005883a 	mov	r2,zero
 821384c:	003fe706 	br	82137ec <__muldf3+0x698>
 8213850:	00800434 	movhi	r2,16
 8213854:	89400234 	orhi	r5,r17,8
 8213858:	10bfffc4 	addi	r2,r2,-1
 821385c:	b02b883a 	mov	r21,r22
 8213860:	288a703a 	and	r5,r5,r2
 8213864:	4029883a 	mov	r20,r8
 8213868:	003eff06 	br	8213468 <__muldf3+0x314>

0821386c <__subdf3>:
 821386c:	02000434 	movhi	r8,16
 8213870:	423fffc4 	addi	r8,r8,-1
 8213874:	defffb04 	addi	sp,sp,-20
 8213878:	2a14703a 	and	r10,r5,r8
 821387c:	3812d53a 	srli	r9,r7,20
 8213880:	3a10703a 	and	r8,r7,r8
 8213884:	2006d77a 	srli	r3,r4,29
 8213888:	3004d77a 	srli	r2,r6,29
 821388c:	dc000015 	stw	r16,0(sp)
 8213890:	501490fa 	slli	r10,r10,3
 8213894:	2820d53a 	srli	r16,r5,20
 8213898:	401090fa 	slli	r8,r8,3
 821389c:	dc800215 	stw	r18,8(sp)
 82138a0:	dc400115 	stw	r17,4(sp)
 82138a4:	dfc00415 	stw	ra,16(sp)
 82138a8:	202290fa 	slli	r17,r4,3
 82138ac:	dcc00315 	stw	r19,12(sp)
 82138b0:	4a41ffcc 	andi	r9,r9,2047
 82138b4:	0101ffc4 	movi	r4,2047
 82138b8:	2824d7fa 	srli	r18,r5,31
 82138bc:	8401ffcc 	andi	r16,r16,2047
 82138c0:	50c6b03a 	or	r3,r10,r3
 82138c4:	380ed7fa 	srli	r7,r7,31
 82138c8:	408ab03a 	or	r5,r8,r2
 82138cc:	300c90fa 	slli	r6,r6,3
 82138d0:	49009626 	beq	r9,r4,8213b2c <__subdf3+0x2c0>
 82138d4:	39c0005c 	xori	r7,r7,1
 82138d8:	8245c83a 	sub	r2,r16,r9
 82138dc:	3c807426 	beq	r7,r18,8213ab0 <__subdf3+0x244>
 82138e0:	0080af0e 	bge	zero,r2,8213ba0 <__subdf3+0x334>
 82138e4:	48002a1e 	bne	r9,zero,8213990 <__subdf3+0x124>
 82138e8:	2988b03a 	or	r4,r5,r6
 82138ec:	20009a1e 	bne	r4,zero,8213b58 <__subdf3+0x2ec>
 82138f0:	888001cc 	andi	r2,r17,7
 82138f4:	10000726 	beq	r2,zero,8213914 <__subdf3+0xa8>
 82138f8:	888003cc 	andi	r2,r17,15
 82138fc:	01000104 	movi	r4,4
 8213900:	11000426 	beq	r2,r4,8213914 <__subdf3+0xa8>
 8213904:	890b883a 	add	r5,r17,r4
 8213908:	2c63803a 	cmpltu	r17,r5,r17
 821390c:	1c47883a 	add	r3,r3,r17
 8213910:	2823883a 	mov	r17,r5
 8213914:	1880202c 	andhi	r2,r3,128
 8213918:	10005926 	beq	r2,zero,8213a80 <__subdf3+0x214>
 821391c:	84000044 	addi	r16,r16,1
 8213920:	0081ffc4 	movi	r2,2047
 8213924:	8080be26 	beq	r16,r2,8213c20 <__subdf3+0x3b4>
 8213928:	017fe034 	movhi	r5,65408
 821392c:	297fffc4 	addi	r5,r5,-1
 8213930:	1946703a 	and	r3,r3,r5
 8213934:	1804977a 	slli	r2,r3,29
 8213938:	1806927a 	slli	r3,r3,9
 821393c:	8822d0fa 	srli	r17,r17,3
 8213940:	8401ffcc 	andi	r16,r16,2047
 8213944:	180ad33a 	srli	r5,r3,12
 8213948:	9100004c 	andi	r4,r18,1
 821394c:	1444b03a 	or	r2,r2,r17
 8213950:	80c1ffcc 	andi	r3,r16,2047
 8213954:	1820953a 	slli	r16,r3,20
 8213958:	20c03fcc 	andi	r3,r4,255
 821395c:	180897fa 	slli	r4,r3,31
 8213960:	00c00434 	movhi	r3,16
 8213964:	18ffffc4 	addi	r3,r3,-1
 8213968:	28c6703a 	and	r3,r5,r3
 821396c:	1c06b03a 	or	r3,r3,r16
 8213970:	1906b03a 	or	r3,r3,r4
 8213974:	dfc00417 	ldw	ra,16(sp)
 8213978:	dcc00317 	ldw	r19,12(sp)
 821397c:	dc800217 	ldw	r18,8(sp)
 8213980:	dc400117 	ldw	r17,4(sp)
 8213984:	dc000017 	ldw	r16,0(sp)
 8213988:	dec00504 	addi	sp,sp,20
 821398c:	f800283a 	ret
 8213990:	0101ffc4 	movi	r4,2047
 8213994:	813fd626 	beq	r16,r4,82138f0 <__subdf3+0x84>
 8213998:	29402034 	orhi	r5,r5,128
 821399c:	01000e04 	movi	r4,56
 82139a0:	2080a316 	blt	r4,r2,8213c30 <__subdf3+0x3c4>
 82139a4:	010007c4 	movi	r4,31
 82139a8:	2080c616 	blt	r4,r2,8213cc4 <__subdf3+0x458>
 82139ac:	01000804 	movi	r4,32
 82139b0:	2089c83a 	sub	r4,r4,r2
 82139b4:	2910983a 	sll	r8,r5,r4
 82139b8:	308ed83a 	srl	r7,r6,r2
 82139bc:	3108983a 	sll	r4,r6,r4
 82139c0:	2884d83a 	srl	r2,r5,r2
 82139c4:	41ccb03a 	or	r6,r8,r7
 82139c8:	2008c03a 	cmpne	r4,r4,zero
 82139cc:	310cb03a 	or	r6,r6,r4
 82139d0:	898dc83a 	sub	r6,r17,r6
 82139d4:	89a3803a 	cmpltu	r17,r17,r6
 82139d8:	1887c83a 	sub	r3,r3,r2
 82139dc:	1c47c83a 	sub	r3,r3,r17
 82139e0:	3023883a 	mov	r17,r6
 82139e4:	1880202c 	andhi	r2,r3,128
 82139e8:	10002326 	beq	r2,zero,8213a78 <__subdf3+0x20c>
 82139ec:	04c02034 	movhi	r19,128
 82139f0:	9cffffc4 	addi	r19,r19,-1
 82139f4:	1ce6703a 	and	r19,r3,r19
 82139f8:	98007a26 	beq	r19,zero,8213be4 <__subdf3+0x378>
 82139fc:	9809883a 	mov	r4,r19
 8213a00:	821436c0 	call	821436c <__clzsi2>
 8213a04:	113ffe04 	addi	r4,r2,-8
 8213a08:	00c007c4 	movi	r3,31
 8213a0c:	19007b16 	blt	r3,r4,8213bfc <__subdf3+0x390>
 8213a10:	00800804 	movi	r2,32
 8213a14:	1105c83a 	sub	r2,r2,r4
 8213a18:	8884d83a 	srl	r2,r17,r2
 8213a1c:	9906983a 	sll	r3,r19,r4
 8213a20:	8922983a 	sll	r17,r17,r4
 8213a24:	10c4b03a 	or	r2,r2,r3
 8213a28:	24007816 	blt	r4,r16,8213c0c <__subdf3+0x3a0>
 8213a2c:	2421c83a 	sub	r16,r4,r16
 8213a30:	80c00044 	addi	r3,r16,1
 8213a34:	010007c4 	movi	r4,31
 8213a38:	20c09516 	blt	r4,r3,8213c90 <__subdf3+0x424>
 8213a3c:	01400804 	movi	r5,32
 8213a40:	28cbc83a 	sub	r5,r5,r3
 8213a44:	88c8d83a 	srl	r4,r17,r3
 8213a48:	8962983a 	sll	r17,r17,r5
 8213a4c:	114a983a 	sll	r5,r2,r5
 8213a50:	10c6d83a 	srl	r3,r2,r3
 8213a54:	8804c03a 	cmpne	r2,r17,zero
 8213a58:	290ab03a 	or	r5,r5,r4
 8213a5c:	28a2b03a 	or	r17,r5,r2
 8213a60:	0021883a 	mov	r16,zero
 8213a64:	003fa206 	br	82138f0 <__subdf3+0x84>
 8213a68:	2090b03a 	or	r8,r4,r2
 8213a6c:	40018e26 	beq	r8,zero,82140a8 <__subdf3+0x83c>
 8213a70:	1007883a 	mov	r3,r2
 8213a74:	2023883a 	mov	r17,r4
 8213a78:	888001cc 	andi	r2,r17,7
 8213a7c:	103f9e1e 	bne	r2,zero,82138f8 <__subdf3+0x8c>
 8213a80:	1804977a 	slli	r2,r3,29
 8213a84:	8822d0fa 	srli	r17,r17,3
 8213a88:	1810d0fa 	srli	r8,r3,3
 8213a8c:	9100004c 	andi	r4,r18,1
 8213a90:	1444b03a 	or	r2,r2,r17
 8213a94:	00c1ffc4 	movi	r3,2047
 8213a98:	80c02826 	beq	r16,r3,8213b3c <__subdf3+0x2d0>
 8213a9c:	01400434 	movhi	r5,16
 8213aa0:	297fffc4 	addi	r5,r5,-1
 8213aa4:	80e0703a 	and	r16,r16,r3
 8213aa8:	414a703a 	and	r5,r8,r5
 8213aac:	003fa806 	br	8213950 <__subdf3+0xe4>
 8213ab0:	0080630e 	bge	zero,r2,8213c40 <__subdf3+0x3d4>
 8213ab4:	48003026 	beq	r9,zero,8213b78 <__subdf3+0x30c>
 8213ab8:	0101ffc4 	movi	r4,2047
 8213abc:	813f8c26 	beq	r16,r4,82138f0 <__subdf3+0x84>
 8213ac0:	29402034 	orhi	r5,r5,128
 8213ac4:	01000e04 	movi	r4,56
 8213ac8:	2080a90e 	bge	r4,r2,8213d70 <__subdf3+0x504>
 8213acc:	298cb03a 	or	r6,r5,r6
 8213ad0:	3012c03a 	cmpne	r9,r6,zero
 8213ad4:	0005883a 	mov	r2,zero
 8213ad8:	4c53883a 	add	r9,r9,r17
 8213adc:	4c63803a 	cmpltu	r17,r9,r17
 8213ae0:	10c7883a 	add	r3,r2,r3
 8213ae4:	88c7883a 	add	r3,r17,r3
 8213ae8:	4823883a 	mov	r17,r9
 8213aec:	1880202c 	andhi	r2,r3,128
 8213af0:	1000d026 	beq	r2,zero,8213e34 <__subdf3+0x5c8>
 8213af4:	84000044 	addi	r16,r16,1
 8213af8:	0081ffc4 	movi	r2,2047
 8213afc:	8080fe26 	beq	r16,r2,8213ef8 <__subdf3+0x68c>
 8213b00:	00bfe034 	movhi	r2,65408
 8213b04:	10bfffc4 	addi	r2,r2,-1
 8213b08:	1886703a 	and	r3,r3,r2
 8213b0c:	880ad07a 	srli	r5,r17,1
 8213b10:	180497fa 	slli	r2,r3,31
 8213b14:	8900004c 	andi	r4,r17,1
 8213b18:	2922b03a 	or	r17,r5,r4
 8213b1c:	1806d07a 	srli	r3,r3,1
 8213b20:	1462b03a 	or	r17,r2,r17
 8213b24:	3825883a 	mov	r18,r7
 8213b28:	003f7106 	br	82138f0 <__subdf3+0x84>
 8213b2c:	2984b03a 	or	r2,r5,r6
 8213b30:	103f6826 	beq	r2,zero,82138d4 <__subdf3+0x68>
 8213b34:	39c03fcc 	andi	r7,r7,255
 8213b38:	003f6706 	br	82138d8 <__subdf3+0x6c>
 8213b3c:	4086b03a 	or	r3,r8,r2
 8213b40:	18015226 	beq	r3,zero,821408c <__subdf3+0x820>
 8213b44:	00c00434 	movhi	r3,16
 8213b48:	41400234 	orhi	r5,r8,8
 8213b4c:	18ffffc4 	addi	r3,r3,-1
 8213b50:	28ca703a 	and	r5,r5,r3
 8213b54:	003f7e06 	br	8213950 <__subdf3+0xe4>
 8213b58:	10bfffc4 	addi	r2,r2,-1
 8213b5c:	1000491e 	bne	r2,zero,8213c84 <__subdf3+0x418>
 8213b60:	898fc83a 	sub	r7,r17,r6
 8213b64:	89e3803a 	cmpltu	r17,r17,r7
 8213b68:	1947c83a 	sub	r3,r3,r5
 8213b6c:	1c47c83a 	sub	r3,r3,r17
 8213b70:	3823883a 	mov	r17,r7
 8213b74:	003f9b06 	br	82139e4 <__subdf3+0x178>
 8213b78:	2988b03a 	or	r4,r5,r6
 8213b7c:	203f5c26 	beq	r4,zero,82138f0 <__subdf3+0x84>
 8213b80:	10bfffc4 	addi	r2,r2,-1
 8213b84:	1000931e 	bne	r2,zero,8213dd4 <__subdf3+0x568>
 8213b88:	898d883a 	add	r6,r17,r6
 8213b8c:	3463803a 	cmpltu	r17,r6,r17
 8213b90:	1947883a 	add	r3,r3,r5
 8213b94:	88c7883a 	add	r3,r17,r3
 8213b98:	3023883a 	mov	r17,r6
 8213b9c:	003fd306 	br	8213aec <__subdf3+0x280>
 8213ba0:	1000541e 	bne	r2,zero,8213cf4 <__subdf3+0x488>
 8213ba4:	80800044 	addi	r2,r16,1
 8213ba8:	1081ffcc 	andi	r2,r2,2047
 8213bac:	01000044 	movi	r4,1
 8213bb0:	2080a20e 	bge	r4,r2,8213e3c <__subdf3+0x5d0>
 8213bb4:	8989c83a 	sub	r4,r17,r6
 8213bb8:	8905803a 	cmpltu	r2,r17,r4
 8213bbc:	1967c83a 	sub	r19,r3,r5
 8213bc0:	98a7c83a 	sub	r19,r19,r2
 8213bc4:	9880202c 	andhi	r2,r19,128
 8213bc8:	10006326 	beq	r2,zero,8213d58 <__subdf3+0x4ec>
 8213bcc:	3463c83a 	sub	r17,r6,r17
 8213bd0:	28c7c83a 	sub	r3,r5,r3
 8213bd4:	344d803a 	cmpltu	r6,r6,r17
 8213bd8:	19a7c83a 	sub	r19,r3,r6
 8213bdc:	3825883a 	mov	r18,r7
 8213be0:	983f861e 	bne	r19,zero,82139fc <__subdf3+0x190>
 8213be4:	8809883a 	mov	r4,r17
 8213be8:	821436c0 	call	821436c <__clzsi2>
 8213bec:	10800804 	addi	r2,r2,32
 8213bf0:	113ffe04 	addi	r4,r2,-8
 8213bf4:	00c007c4 	movi	r3,31
 8213bf8:	193f850e 	bge	r3,r4,8213a10 <__subdf3+0x1a4>
 8213bfc:	10bff604 	addi	r2,r2,-40
 8213c00:	8884983a 	sll	r2,r17,r2
 8213c04:	0023883a 	mov	r17,zero
 8213c08:	243f880e 	bge	r4,r16,8213a2c <__subdf3+0x1c0>
 8213c0c:	00ffe034 	movhi	r3,65408
 8213c10:	18ffffc4 	addi	r3,r3,-1
 8213c14:	8121c83a 	sub	r16,r16,r4
 8213c18:	10c6703a 	and	r3,r2,r3
 8213c1c:	003f3406 	br	82138f0 <__subdf3+0x84>
 8213c20:	9100004c 	andi	r4,r18,1
 8213c24:	000b883a 	mov	r5,zero
 8213c28:	0005883a 	mov	r2,zero
 8213c2c:	003f4806 	br	8213950 <__subdf3+0xe4>
 8213c30:	298cb03a 	or	r6,r5,r6
 8213c34:	300cc03a 	cmpne	r6,r6,zero
 8213c38:	0005883a 	mov	r2,zero
 8213c3c:	003f6406 	br	82139d0 <__subdf3+0x164>
 8213c40:	10009a1e 	bne	r2,zero,8213eac <__subdf3+0x640>
 8213c44:	82400044 	addi	r9,r16,1
 8213c48:	4881ffcc 	andi	r2,r9,2047
 8213c4c:	02800044 	movi	r10,1
 8213c50:	5080670e 	bge	r10,r2,8213df0 <__subdf3+0x584>
 8213c54:	0081ffc4 	movi	r2,2047
 8213c58:	4880af26 	beq	r9,r2,8213f18 <__subdf3+0x6ac>
 8213c5c:	898d883a 	add	r6,r17,r6
 8213c60:	1945883a 	add	r2,r3,r5
 8213c64:	3447803a 	cmpltu	r3,r6,r17
 8213c68:	1887883a 	add	r3,r3,r2
 8213c6c:	182297fa 	slli	r17,r3,31
 8213c70:	300cd07a 	srli	r6,r6,1
 8213c74:	1806d07a 	srli	r3,r3,1
 8213c78:	4821883a 	mov	r16,r9
 8213c7c:	89a2b03a 	or	r17,r17,r6
 8213c80:	003f1b06 	br	82138f0 <__subdf3+0x84>
 8213c84:	0101ffc4 	movi	r4,2047
 8213c88:	813f441e 	bne	r16,r4,821399c <__subdf3+0x130>
 8213c8c:	003f1806 	br	82138f0 <__subdf3+0x84>
 8213c90:	843ff844 	addi	r16,r16,-31
 8213c94:	01400804 	movi	r5,32
 8213c98:	1408d83a 	srl	r4,r2,r16
 8213c9c:	19405026 	beq	r3,r5,8213de0 <__subdf3+0x574>
 8213ca0:	01401004 	movi	r5,64
 8213ca4:	28c7c83a 	sub	r3,r5,r3
 8213ca8:	10c4983a 	sll	r2,r2,r3
 8213cac:	88a2b03a 	or	r17,r17,r2
 8213cb0:	8822c03a 	cmpne	r17,r17,zero
 8213cb4:	2462b03a 	or	r17,r4,r17
 8213cb8:	0007883a 	mov	r3,zero
 8213cbc:	0021883a 	mov	r16,zero
 8213cc0:	003f6d06 	br	8213a78 <__subdf3+0x20c>
 8213cc4:	11fff804 	addi	r7,r2,-32
 8213cc8:	01000804 	movi	r4,32
 8213ccc:	29ced83a 	srl	r7,r5,r7
 8213cd0:	11004526 	beq	r2,r4,8213de8 <__subdf3+0x57c>
 8213cd4:	01001004 	movi	r4,64
 8213cd8:	2089c83a 	sub	r4,r4,r2
 8213cdc:	2904983a 	sll	r2,r5,r4
 8213ce0:	118cb03a 	or	r6,r2,r6
 8213ce4:	300cc03a 	cmpne	r6,r6,zero
 8213ce8:	398cb03a 	or	r6,r7,r6
 8213cec:	0005883a 	mov	r2,zero
 8213cf0:	003f3706 	br	82139d0 <__subdf3+0x164>
 8213cf4:	80002a26 	beq	r16,zero,8213da0 <__subdf3+0x534>
 8213cf8:	0101ffc4 	movi	r4,2047
 8213cfc:	49006626 	beq	r9,r4,8213e98 <__subdf3+0x62c>
 8213d00:	0085c83a 	sub	r2,zero,r2
 8213d04:	18c02034 	orhi	r3,r3,128
 8213d08:	01000e04 	movi	r4,56
 8213d0c:	20807e16 	blt	r4,r2,8213f08 <__subdf3+0x69c>
 8213d10:	010007c4 	movi	r4,31
 8213d14:	2080e716 	blt	r4,r2,82140b4 <__subdf3+0x848>
 8213d18:	01000804 	movi	r4,32
 8213d1c:	2089c83a 	sub	r4,r4,r2
 8213d20:	1914983a 	sll	r10,r3,r4
 8213d24:	8890d83a 	srl	r8,r17,r2
 8213d28:	8908983a 	sll	r4,r17,r4
 8213d2c:	1884d83a 	srl	r2,r3,r2
 8213d30:	5222b03a 	or	r17,r10,r8
 8213d34:	2006c03a 	cmpne	r3,r4,zero
 8213d38:	88e2b03a 	or	r17,r17,r3
 8213d3c:	3463c83a 	sub	r17,r6,r17
 8213d40:	2885c83a 	sub	r2,r5,r2
 8213d44:	344d803a 	cmpltu	r6,r6,r17
 8213d48:	1187c83a 	sub	r3,r2,r6
 8213d4c:	4821883a 	mov	r16,r9
 8213d50:	3825883a 	mov	r18,r7
 8213d54:	003f2306 	br	82139e4 <__subdf3+0x178>
 8213d58:	24d0b03a 	or	r8,r4,r19
 8213d5c:	40001b1e 	bne	r8,zero,8213dcc <__subdf3+0x560>
 8213d60:	0005883a 	mov	r2,zero
 8213d64:	0009883a 	mov	r4,zero
 8213d68:	0021883a 	mov	r16,zero
 8213d6c:	003f4906 	br	8213a94 <__subdf3+0x228>
 8213d70:	010007c4 	movi	r4,31
 8213d74:	20803a16 	blt	r4,r2,8213e60 <__subdf3+0x5f4>
 8213d78:	01000804 	movi	r4,32
 8213d7c:	2089c83a 	sub	r4,r4,r2
 8213d80:	2912983a 	sll	r9,r5,r4
 8213d84:	3090d83a 	srl	r8,r6,r2
 8213d88:	3108983a 	sll	r4,r6,r4
 8213d8c:	2884d83a 	srl	r2,r5,r2
 8213d90:	4a12b03a 	or	r9,r9,r8
 8213d94:	2008c03a 	cmpne	r4,r4,zero
 8213d98:	4912b03a 	or	r9,r9,r4
 8213d9c:	003f4e06 	br	8213ad8 <__subdf3+0x26c>
 8213da0:	1c48b03a 	or	r4,r3,r17
 8213da4:	20003c26 	beq	r4,zero,8213e98 <__subdf3+0x62c>
 8213da8:	0084303a 	nor	r2,zero,r2
 8213dac:	1000381e 	bne	r2,zero,8213e90 <__subdf3+0x624>
 8213db0:	3463c83a 	sub	r17,r6,r17
 8213db4:	28c5c83a 	sub	r2,r5,r3
 8213db8:	344d803a 	cmpltu	r6,r6,r17
 8213dbc:	1187c83a 	sub	r3,r2,r6
 8213dc0:	4821883a 	mov	r16,r9
 8213dc4:	3825883a 	mov	r18,r7
 8213dc8:	003f0606 	br	82139e4 <__subdf3+0x178>
 8213dcc:	2023883a 	mov	r17,r4
 8213dd0:	003f0906 	br	82139f8 <__subdf3+0x18c>
 8213dd4:	0101ffc4 	movi	r4,2047
 8213dd8:	813f3a1e 	bne	r16,r4,8213ac4 <__subdf3+0x258>
 8213ddc:	003ec406 	br	82138f0 <__subdf3+0x84>
 8213de0:	0005883a 	mov	r2,zero
 8213de4:	003fb106 	br	8213cac <__subdf3+0x440>
 8213de8:	0005883a 	mov	r2,zero
 8213dec:	003fbc06 	br	8213ce0 <__subdf3+0x474>
 8213df0:	1c44b03a 	or	r2,r3,r17
 8213df4:	80008e1e 	bne	r16,zero,8214030 <__subdf3+0x7c4>
 8213df8:	1000c826 	beq	r2,zero,821411c <__subdf3+0x8b0>
 8213dfc:	2984b03a 	or	r2,r5,r6
 8213e00:	103ebb26 	beq	r2,zero,82138f0 <__subdf3+0x84>
 8213e04:	8989883a 	add	r4,r17,r6
 8213e08:	1945883a 	add	r2,r3,r5
 8213e0c:	2447803a 	cmpltu	r3,r4,r17
 8213e10:	1887883a 	add	r3,r3,r2
 8213e14:	1880202c 	andhi	r2,r3,128
 8213e18:	2023883a 	mov	r17,r4
 8213e1c:	103f1626 	beq	r2,zero,8213a78 <__subdf3+0x20c>
 8213e20:	00bfe034 	movhi	r2,65408
 8213e24:	10bfffc4 	addi	r2,r2,-1
 8213e28:	5021883a 	mov	r16,r10
 8213e2c:	1886703a 	and	r3,r3,r2
 8213e30:	003eaf06 	br	82138f0 <__subdf3+0x84>
 8213e34:	3825883a 	mov	r18,r7
 8213e38:	003f0f06 	br	8213a78 <__subdf3+0x20c>
 8213e3c:	1c44b03a 	or	r2,r3,r17
 8213e40:	8000251e 	bne	r16,zero,8213ed8 <__subdf3+0x66c>
 8213e44:	1000661e 	bne	r2,zero,8213fe0 <__subdf3+0x774>
 8213e48:	2990b03a 	or	r8,r5,r6
 8213e4c:	40009626 	beq	r8,zero,82140a8 <__subdf3+0x83c>
 8213e50:	2807883a 	mov	r3,r5
 8213e54:	3023883a 	mov	r17,r6
 8213e58:	3825883a 	mov	r18,r7
 8213e5c:	003ea406 	br	82138f0 <__subdf3+0x84>
 8213e60:	127ff804 	addi	r9,r2,-32
 8213e64:	01000804 	movi	r4,32
 8213e68:	2a52d83a 	srl	r9,r5,r9
 8213e6c:	11008c26 	beq	r2,r4,82140a0 <__subdf3+0x834>
 8213e70:	01001004 	movi	r4,64
 8213e74:	2085c83a 	sub	r2,r4,r2
 8213e78:	2884983a 	sll	r2,r5,r2
 8213e7c:	118cb03a 	or	r6,r2,r6
 8213e80:	300cc03a 	cmpne	r6,r6,zero
 8213e84:	4992b03a 	or	r9,r9,r6
 8213e88:	0005883a 	mov	r2,zero
 8213e8c:	003f1206 	br	8213ad8 <__subdf3+0x26c>
 8213e90:	0101ffc4 	movi	r4,2047
 8213e94:	493f9c1e 	bne	r9,r4,8213d08 <__subdf3+0x49c>
 8213e98:	2807883a 	mov	r3,r5
 8213e9c:	3023883a 	mov	r17,r6
 8213ea0:	4821883a 	mov	r16,r9
 8213ea4:	3825883a 	mov	r18,r7
 8213ea8:	003e9106 	br	82138f0 <__subdf3+0x84>
 8213eac:	80001f1e 	bne	r16,zero,8213f2c <__subdf3+0x6c0>
 8213eb0:	1c48b03a 	or	r4,r3,r17
 8213eb4:	20005a26 	beq	r4,zero,8214020 <__subdf3+0x7b4>
 8213eb8:	0084303a 	nor	r2,zero,r2
 8213ebc:	1000561e 	bne	r2,zero,8214018 <__subdf3+0x7ac>
 8213ec0:	89a3883a 	add	r17,r17,r6
 8213ec4:	1945883a 	add	r2,r3,r5
 8213ec8:	898d803a 	cmpltu	r6,r17,r6
 8213ecc:	3087883a 	add	r3,r6,r2
 8213ed0:	4821883a 	mov	r16,r9
 8213ed4:	003f0506 	br	8213aec <__subdf3+0x280>
 8213ed8:	10002b1e 	bne	r2,zero,8213f88 <__subdf3+0x71c>
 8213edc:	2984b03a 	or	r2,r5,r6
 8213ee0:	10008026 	beq	r2,zero,82140e4 <__subdf3+0x878>
 8213ee4:	2807883a 	mov	r3,r5
 8213ee8:	3023883a 	mov	r17,r6
 8213eec:	3825883a 	mov	r18,r7
 8213ef0:	0401ffc4 	movi	r16,2047
 8213ef4:	003e7e06 	br	82138f0 <__subdf3+0x84>
 8213ef8:	3809883a 	mov	r4,r7
 8213efc:	0011883a 	mov	r8,zero
 8213f00:	0005883a 	mov	r2,zero
 8213f04:	003ee306 	br	8213a94 <__subdf3+0x228>
 8213f08:	1c62b03a 	or	r17,r3,r17
 8213f0c:	8822c03a 	cmpne	r17,r17,zero
 8213f10:	0005883a 	mov	r2,zero
 8213f14:	003f8906 	br	8213d3c <__subdf3+0x4d0>
 8213f18:	3809883a 	mov	r4,r7
 8213f1c:	4821883a 	mov	r16,r9
 8213f20:	0011883a 	mov	r8,zero
 8213f24:	0005883a 	mov	r2,zero
 8213f28:	003eda06 	br	8213a94 <__subdf3+0x228>
 8213f2c:	0101ffc4 	movi	r4,2047
 8213f30:	49003b26 	beq	r9,r4,8214020 <__subdf3+0x7b4>
 8213f34:	0085c83a 	sub	r2,zero,r2
 8213f38:	18c02034 	orhi	r3,r3,128
 8213f3c:	01000e04 	movi	r4,56
 8213f40:	20806e16 	blt	r4,r2,82140fc <__subdf3+0x890>
 8213f44:	010007c4 	movi	r4,31
 8213f48:	20807716 	blt	r4,r2,8214128 <__subdf3+0x8bc>
 8213f4c:	01000804 	movi	r4,32
 8213f50:	2089c83a 	sub	r4,r4,r2
 8213f54:	1914983a 	sll	r10,r3,r4
 8213f58:	8890d83a 	srl	r8,r17,r2
 8213f5c:	8908983a 	sll	r4,r17,r4
 8213f60:	1884d83a 	srl	r2,r3,r2
 8213f64:	5222b03a 	or	r17,r10,r8
 8213f68:	2006c03a 	cmpne	r3,r4,zero
 8213f6c:	88e2b03a 	or	r17,r17,r3
 8213f70:	89a3883a 	add	r17,r17,r6
 8213f74:	1145883a 	add	r2,r2,r5
 8213f78:	898d803a 	cmpltu	r6,r17,r6
 8213f7c:	3087883a 	add	r3,r6,r2
 8213f80:	4821883a 	mov	r16,r9
 8213f84:	003ed906 	br	8213aec <__subdf3+0x280>
 8213f88:	2984b03a 	or	r2,r5,r6
 8213f8c:	10004226 	beq	r2,zero,8214098 <__subdf3+0x82c>
 8213f90:	1808d0fa 	srli	r4,r3,3
 8213f94:	8822d0fa 	srli	r17,r17,3
 8213f98:	1806977a 	slli	r3,r3,29
 8213f9c:	2080022c 	andhi	r2,r4,8
 8213fa0:	1c62b03a 	or	r17,r3,r17
 8213fa4:	10000826 	beq	r2,zero,8213fc8 <__subdf3+0x75c>
 8213fa8:	2812d0fa 	srli	r9,r5,3
 8213fac:	4880022c 	andhi	r2,r9,8
 8213fb0:	1000051e 	bne	r2,zero,8213fc8 <__subdf3+0x75c>
 8213fb4:	300cd0fa 	srli	r6,r6,3
 8213fb8:	2804977a 	slli	r2,r5,29
 8213fbc:	4809883a 	mov	r4,r9
 8213fc0:	3825883a 	mov	r18,r7
 8213fc4:	11a2b03a 	or	r17,r2,r6
 8213fc8:	8806d77a 	srli	r3,r17,29
 8213fcc:	200890fa 	slli	r4,r4,3
 8213fd0:	882290fa 	slli	r17,r17,3
 8213fd4:	0401ffc4 	movi	r16,2047
 8213fd8:	1906b03a 	or	r3,r3,r4
 8213fdc:	003e4406 	br	82138f0 <__subdf3+0x84>
 8213fe0:	2984b03a 	or	r2,r5,r6
 8213fe4:	103e4226 	beq	r2,zero,82138f0 <__subdf3+0x84>
 8213fe8:	8989c83a 	sub	r4,r17,r6
 8213fec:	8911803a 	cmpltu	r8,r17,r4
 8213ff0:	1945c83a 	sub	r2,r3,r5
 8213ff4:	1205c83a 	sub	r2,r2,r8
 8213ff8:	1200202c 	andhi	r8,r2,128
 8213ffc:	403e9a26 	beq	r8,zero,8213a68 <__subdf3+0x1fc>
 8214000:	3463c83a 	sub	r17,r6,r17
 8214004:	28c5c83a 	sub	r2,r5,r3
 8214008:	344d803a 	cmpltu	r6,r6,r17
 821400c:	1187c83a 	sub	r3,r2,r6
 8214010:	3825883a 	mov	r18,r7
 8214014:	003e3606 	br	82138f0 <__subdf3+0x84>
 8214018:	0101ffc4 	movi	r4,2047
 821401c:	493fc71e 	bne	r9,r4,8213f3c <__subdf3+0x6d0>
 8214020:	2807883a 	mov	r3,r5
 8214024:	3023883a 	mov	r17,r6
 8214028:	4821883a 	mov	r16,r9
 821402c:	003e3006 	br	82138f0 <__subdf3+0x84>
 8214030:	10003626 	beq	r2,zero,821410c <__subdf3+0x8a0>
 8214034:	2984b03a 	or	r2,r5,r6
 8214038:	10001726 	beq	r2,zero,8214098 <__subdf3+0x82c>
 821403c:	1808d0fa 	srli	r4,r3,3
 8214040:	8822d0fa 	srli	r17,r17,3
 8214044:	1806977a 	slli	r3,r3,29
 8214048:	2080022c 	andhi	r2,r4,8
 821404c:	1c62b03a 	or	r17,r3,r17
 8214050:	10000726 	beq	r2,zero,8214070 <__subdf3+0x804>
 8214054:	2812d0fa 	srli	r9,r5,3
 8214058:	4880022c 	andhi	r2,r9,8
 821405c:	1000041e 	bne	r2,zero,8214070 <__subdf3+0x804>
 8214060:	300cd0fa 	srli	r6,r6,3
 8214064:	2804977a 	slli	r2,r5,29
 8214068:	4809883a 	mov	r4,r9
 821406c:	11a2b03a 	or	r17,r2,r6
 8214070:	8806d77a 	srli	r3,r17,29
 8214074:	200890fa 	slli	r4,r4,3
 8214078:	882290fa 	slli	r17,r17,3
 821407c:	3825883a 	mov	r18,r7
 8214080:	1906b03a 	or	r3,r3,r4
 8214084:	0401ffc4 	movi	r16,2047
 8214088:	003e1906 	br	82138f0 <__subdf3+0x84>
 821408c:	000b883a 	mov	r5,zero
 8214090:	0005883a 	mov	r2,zero
 8214094:	003e2e06 	br	8213950 <__subdf3+0xe4>
 8214098:	0401ffc4 	movi	r16,2047
 821409c:	003e1406 	br	82138f0 <__subdf3+0x84>
 82140a0:	0005883a 	mov	r2,zero
 82140a4:	003f7506 	br	8213e7c <__subdf3+0x610>
 82140a8:	0005883a 	mov	r2,zero
 82140ac:	0009883a 	mov	r4,zero
 82140b0:	003e7806 	br	8213a94 <__subdf3+0x228>
 82140b4:	123ff804 	addi	r8,r2,-32
 82140b8:	01000804 	movi	r4,32
 82140bc:	1a10d83a 	srl	r8,r3,r8
 82140c0:	11002526 	beq	r2,r4,8214158 <__subdf3+0x8ec>
 82140c4:	01001004 	movi	r4,64
 82140c8:	2085c83a 	sub	r2,r4,r2
 82140cc:	1884983a 	sll	r2,r3,r2
 82140d0:	1444b03a 	or	r2,r2,r17
 82140d4:	1004c03a 	cmpne	r2,r2,zero
 82140d8:	40a2b03a 	or	r17,r8,r2
 82140dc:	0005883a 	mov	r2,zero
 82140e0:	003f1606 	br	8213d3c <__subdf3+0x4d0>
 82140e4:	02000434 	movhi	r8,16
 82140e8:	0009883a 	mov	r4,zero
 82140ec:	423fffc4 	addi	r8,r8,-1
 82140f0:	00bfffc4 	movi	r2,-1
 82140f4:	0401ffc4 	movi	r16,2047
 82140f8:	003e6606 	br	8213a94 <__subdf3+0x228>
 82140fc:	1c62b03a 	or	r17,r3,r17
 8214100:	8822c03a 	cmpne	r17,r17,zero
 8214104:	0005883a 	mov	r2,zero
 8214108:	003f9906 	br	8213f70 <__subdf3+0x704>
 821410c:	2807883a 	mov	r3,r5
 8214110:	3023883a 	mov	r17,r6
 8214114:	0401ffc4 	movi	r16,2047
 8214118:	003df506 	br	82138f0 <__subdf3+0x84>
 821411c:	2807883a 	mov	r3,r5
 8214120:	3023883a 	mov	r17,r6
 8214124:	003df206 	br	82138f0 <__subdf3+0x84>
 8214128:	123ff804 	addi	r8,r2,-32
 821412c:	01000804 	movi	r4,32
 8214130:	1a10d83a 	srl	r8,r3,r8
 8214134:	11000a26 	beq	r2,r4,8214160 <__subdf3+0x8f4>
 8214138:	01001004 	movi	r4,64
 821413c:	2085c83a 	sub	r2,r4,r2
 8214140:	1884983a 	sll	r2,r3,r2
 8214144:	1444b03a 	or	r2,r2,r17
 8214148:	1004c03a 	cmpne	r2,r2,zero
 821414c:	40a2b03a 	or	r17,r8,r2
 8214150:	0005883a 	mov	r2,zero
 8214154:	003f8606 	br	8213f70 <__subdf3+0x704>
 8214158:	0005883a 	mov	r2,zero
 821415c:	003fdc06 	br	82140d0 <__subdf3+0x864>
 8214160:	0005883a 	mov	r2,zero
 8214164:	003ff706 	br	8214144 <__subdf3+0x8d8>

08214168 <__fixdfsi>:
 8214168:	280cd53a 	srli	r6,r5,20
 821416c:	00c00434 	movhi	r3,16
 8214170:	18ffffc4 	addi	r3,r3,-1
 8214174:	3181ffcc 	andi	r6,r6,2047
 8214178:	01c0ff84 	movi	r7,1022
 821417c:	28c6703a 	and	r3,r5,r3
 8214180:	280ad7fa 	srli	r5,r5,31
 8214184:	3980120e 	bge	r7,r6,82141d0 <__fixdfsi+0x68>
 8214188:	00810744 	movi	r2,1053
 821418c:	11800c16 	blt	r2,r6,82141c0 <__fixdfsi+0x58>
 8214190:	00810cc4 	movi	r2,1075
 8214194:	1185c83a 	sub	r2,r2,r6
 8214198:	01c007c4 	movi	r7,31
 821419c:	18c00434 	orhi	r3,r3,16
 82141a0:	38800d16 	blt	r7,r2,82141d8 <__fixdfsi+0x70>
 82141a4:	31befb44 	addi	r6,r6,-1043
 82141a8:	2084d83a 	srl	r2,r4,r2
 82141ac:	1986983a 	sll	r3,r3,r6
 82141b0:	1884b03a 	or	r2,r3,r2
 82141b4:	28000726 	beq	r5,zero,82141d4 <__fixdfsi+0x6c>
 82141b8:	0085c83a 	sub	r2,zero,r2
 82141bc:	f800283a 	ret
 82141c0:	00a00034 	movhi	r2,32768
 82141c4:	10bfffc4 	addi	r2,r2,-1
 82141c8:	2885883a 	add	r2,r5,r2
 82141cc:	f800283a 	ret
 82141d0:	0005883a 	mov	r2,zero
 82141d4:	f800283a 	ret
 82141d8:	008104c4 	movi	r2,1043
 82141dc:	1185c83a 	sub	r2,r2,r6
 82141e0:	1884d83a 	srl	r2,r3,r2
 82141e4:	003ff306 	br	82141b4 <__fixdfsi+0x4c>

082141e8 <__floatsidf>:
 82141e8:	defffd04 	addi	sp,sp,-12
 82141ec:	dfc00215 	stw	ra,8(sp)
 82141f0:	dc400115 	stw	r17,4(sp)
 82141f4:	dc000015 	stw	r16,0(sp)
 82141f8:	20002b26 	beq	r4,zero,82142a8 <__floatsidf+0xc0>
 82141fc:	2023883a 	mov	r17,r4
 8214200:	2020d7fa 	srli	r16,r4,31
 8214204:	20002d16 	blt	r4,zero,82142bc <__floatsidf+0xd4>
 8214208:	8809883a 	mov	r4,r17
 821420c:	821436c0 	call	821436c <__clzsi2>
 8214210:	01410784 	movi	r5,1054
 8214214:	288bc83a 	sub	r5,r5,r2
 8214218:	01010cc4 	movi	r4,1075
 821421c:	2149c83a 	sub	r4,r4,r5
 8214220:	00c007c4 	movi	r3,31
 8214224:	1900160e 	bge	r3,r4,8214280 <__floatsidf+0x98>
 8214228:	00c104c4 	movi	r3,1043
 821422c:	1947c83a 	sub	r3,r3,r5
 8214230:	88c6983a 	sll	r3,r17,r3
 8214234:	00800434 	movhi	r2,16
 8214238:	10bfffc4 	addi	r2,r2,-1
 821423c:	1886703a 	and	r3,r3,r2
 8214240:	2941ffcc 	andi	r5,r5,2047
 8214244:	800d883a 	mov	r6,r16
 8214248:	0005883a 	mov	r2,zero
 821424c:	280a953a 	slli	r5,r5,20
 8214250:	31803fcc 	andi	r6,r6,255
 8214254:	01000434 	movhi	r4,16
 8214258:	300c97fa 	slli	r6,r6,31
 821425c:	213fffc4 	addi	r4,r4,-1
 8214260:	1906703a 	and	r3,r3,r4
 8214264:	1946b03a 	or	r3,r3,r5
 8214268:	1986b03a 	or	r3,r3,r6
 821426c:	dfc00217 	ldw	ra,8(sp)
 8214270:	dc400117 	ldw	r17,4(sp)
 8214274:	dc000017 	ldw	r16,0(sp)
 8214278:	dec00304 	addi	sp,sp,12
 821427c:	f800283a 	ret
 8214280:	00c002c4 	movi	r3,11
 8214284:	1887c83a 	sub	r3,r3,r2
 8214288:	88c6d83a 	srl	r3,r17,r3
 821428c:	8904983a 	sll	r2,r17,r4
 8214290:	01000434 	movhi	r4,16
 8214294:	213fffc4 	addi	r4,r4,-1
 8214298:	2941ffcc 	andi	r5,r5,2047
 821429c:	1906703a 	and	r3,r3,r4
 82142a0:	800d883a 	mov	r6,r16
 82142a4:	003fe906 	br	821424c <__floatsidf+0x64>
 82142a8:	000d883a 	mov	r6,zero
 82142ac:	000b883a 	mov	r5,zero
 82142b0:	0007883a 	mov	r3,zero
 82142b4:	0005883a 	mov	r2,zero
 82142b8:	003fe406 	br	821424c <__floatsidf+0x64>
 82142bc:	0123c83a 	sub	r17,zero,r4
 82142c0:	003fd106 	br	8214208 <__floatsidf+0x20>

082142c4 <__floatunsidf>:
 82142c4:	defffe04 	addi	sp,sp,-8
 82142c8:	dc000015 	stw	r16,0(sp)
 82142cc:	dfc00115 	stw	ra,4(sp)
 82142d0:	2021883a 	mov	r16,r4
 82142d4:	20002226 	beq	r4,zero,8214360 <__floatunsidf+0x9c>
 82142d8:	821436c0 	call	821436c <__clzsi2>
 82142dc:	01010784 	movi	r4,1054
 82142e0:	2089c83a 	sub	r4,r4,r2
 82142e4:	01810cc4 	movi	r6,1075
 82142e8:	310dc83a 	sub	r6,r6,r4
 82142ec:	00c007c4 	movi	r3,31
 82142f0:	1980120e 	bge	r3,r6,821433c <__floatunsidf+0x78>
 82142f4:	00c104c4 	movi	r3,1043
 82142f8:	1907c83a 	sub	r3,r3,r4
 82142fc:	80ca983a 	sll	r5,r16,r3
 8214300:	00800434 	movhi	r2,16
 8214304:	10bfffc4 	addi	r2,r2,-1
 8214308:	2101ffcc 	andi	r4,r4,2047
 821430c:	0021883a 	mov	r16,zero
 8214310:	288a703a 	and	r5,r5,r2
 8214314:	2008953a 	slli	r4,r4,20
 8214318:	00c00434 	movhi	r3,16
 821431c:	18ffffc4 	addi	r3,r3,-1
 8214320:	28c6703a 	and	r3,r5,r3
 8214324:	8005883a 	mov	r2,r16
 8214328:	1906b03a 	or	r3,r3,r4
 821432c:	dfc00117 	ldw	ra,4(sp)
 8214330:	dc000017 	ldw	r16,0(sp)
 8214334:	dec00204 	addi	sp,sp,8
 8214338:	f800283a 	ret
 821433c:	00c002c4 	movi	r3,11
 8214340:	188bc83a 	sub	r5,r3,r2
 8214344:	814ad83a 	srl	r5,r16,r5
 8214348:	00c00434 	movhi	r3,16
 821434c:	18ffffc4 	addi	r3,r3,-1
 8214350:	81a0983a 	sll	r16,r16,r6
 8214354:	2101ffcc 	andi	r4,r4,2047
 8214358:	28ca703a 	and	r5,r5,r3
 821435c:	003fed06 	br	8214314 <__floatunsidf+0x50>
 8214360:	0009883a 	mov	r4,zero
 8214364:	000b883a 	mov	r5,zero
 8214368:	003fea06 	br	8214314 <__floatunsidf+0x50>

0821436c <__clzsi2>:
 821436c:	00bfffd4 	movui	r2,65535
 8214370:	11000536 	bltu	r2,r4,8214388 <__clzsi2+0x1c>
 8214374:	00803fc4 	movi	r2,255
 8214378:	11000f36 	bltu	r2,r4,82143b8 <__clzsi2+0x4c>
 821437c:	00800804 	movi	r2,32
 8214380:	0007883a 	mov	r3,zero
 8214384:	00000506 	br	821439c <__clzsi2+0x30>
 8214388:	00804034 	movhi	r2,256
 821438c:	10bfffc4 	addi	r2,r2,-1
 8214390:	11000c2e 	bgeu	r2,r4,82143c4 <__clzsi2+0x58>
 8214394:	00800204 	movi	r2,8
 8214398:	00c00604 	movi	r3,24
 821439c:	20c8d83a 	srl	r4,r4,r3
 82143a0:	00c20974 	movhi	r3,2085
 82143a4:	18f73b04 	addi	r3,r3,-8980
 82143a8:	1909883a 	add	r4,r3,r4
 82143ac:	20c00003 	ldbu	r3,0(r4)
 82143b0:	10c5c83a 	sub	r2,r2,r3
 82143b4:	f800283a 	ret
 82143b8:	00800604 	movi	r2,24
 82143bc:	00c00204 	movi	r3,8
 82143c0:	003ff606 	br	821439c <__clzsi2+0x30>
 82143c4:	00800404 	movi	r2,16
 82143c8:	1007883a 	mov	r3,r2
 82143cc:	003ff306 	br	821439c <__clzsi2+0x30>

082143d0 <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
 82143d0:	defffc04 	addi	sp,sp,-16
 82143d4:	dfc00315 	stw	ra,12(sp)
 82143d8:	df000215 	stw	fp,8(sp)
 82143dc:	df000204 	addi	fp,sp,8
 82143e0:	e13fff15 	stw	r4,-4(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
 82143e4:	d1600704 	addi	r5,gp,-32740
 82143e8:	e13fff17 	ldw	r4,-4(fp)
 82143ec:	823bf500 	call	823bf50 <alt_find_dev>
 82143f0:	e0bffe15 	stw	r2,-8(fp)

  if ((dev) && dev->open)
 82143f4:	e0bffe17 	ldw	r2,-8(fp)
 82143f8:	10000926 	beq	r2,zero,8214420 <alt_flash_open_dev+0x50>
 82143fc:	e0bffe17 	ldw	r2,-8(fp)
 8214400:	10800317 	ldw	r2,12(r2)
 8214404:	10000626 	beq	r2,zero,8214420 <alt_flash_open_dev+0x50>
  {
    return dev->open(dev, name);
 8214408:	e0bffe17 	ldw	r2,-8(fp)
 821440c:	10800317 	ldw	r2,12(r2)
 8214410:	e17fff17 	ldw	r5,-4(fp)
 8214414:	e13ffe17 	ldw	r4,-8(fp)
 8214418:	103ee83a 	callr	r2
 821441c:	00000106 	br	8214424 <alt_flash_open_dev+0x54>
  }

  return dev;
 8214420:	e0bffe17 	ldw	r2,-8(fp)
}
 8214424:	e037883a 	mov	sp,fp
 8214428:	dfc00117 	ldw	ra,4(sp)
 821442c:	df000017 	ldw	fp,0(sp)
 8214430:	dec00204 	addi	sp,sp,8
 8214434:	f800283a 	ret

08214438 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
 8214438:	defffd04 	addi	sp,sp,-12
 821443c:	dfc00215 	stw	ra,8(sp)
 8214440:	df000115 	stw	fp,4(sp)
 8214444:	df000104 	addi	fp,sp,4
 8214448:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
 821444c:	e0bfff17 	ldw	r2,-4(fp)
 8214450:	10000826 	beq	r2,zero,8214474 <alt_flash_close_dev+0x3c>
 8214454:	e0bfff17 	ldw	r2,-4(fp)
 8214458:	10800417 	ldw	r2,16(r2)
 821445c:	10000526 	beq	r2,zero,8214474 <alt_flash_close_dev+0x3c>
  {
    fd->close(fd);
 8214460:	e0bfff17 	ldw	r2,-4(fp)
 8214464:	10800417 	ldw	r2,16(r2)
 8214468:	e13fff17 	ldw	r4,-4(fp)
 821446c:	103ee83a 	callr	r2
  }
  return;
 8214470:	0001883a 	nop
 8214474:	0001883a 	nop
}
 8214478:	e037883a 	mov	sp,fp
 821447c:	dfc00117 	ldw	ra,4(sp)
 8214480:	df000017 	ldw	fp,0(sp)
 8214484:	dec00204 	addi	sp,sp,8
 8214488:	f800283a 	ret

0821448c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 821448c:	defffe04 	addi	sp,sp,-8
 8214490:	dfc00115 	stw	ra,4(sp)
 8214494:	df000015 	stw	fp,0(sp)
 8214498:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 821449c:	d0a04717 	ldw	r2,-32484(gp)
 82144a0:	10000326 	beq	r2,zero,82144b0 <alt_get_errno+0x24>
 82144a4:	d0a04717 	ldw	r2,-32484(gp)
 82144a8:	103ee83a 	callr	r2
 82144ac:	00000106 	br	82144b4 <alt_get_errno+0x28>
 82144b0:	d0a06304 	addi	r2,gp,-32372
}
 82144b4:	e037883a 	mov	sp,fp
 82144b8:	dfc00117 	ldw	ra,4(sp)
 82144bc:	df000017 	ldw	fp,0(sp)
 82144c0:	dec00204 	addi	sp,sp,8
 82144c4:	f800283a 	ret

082144c8 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 82144c8:	defffb04 	addi	sp,sp,-20
 82144cc:	dfc00415 	stw	ra,16(sp)
 82144d0:	df000315 	stw	fp,12(sp)
 82144d4:	df000304 	addi	fp,sp,12
 82144d8:	e13ffe15 	stw	r4,-8(fp)
 82144dc:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 82144e0:	e0bffe17 	ldw	r2,-8(fp)
 82144e4:	10000616 	blt	r2,zero,8214500 <fstat+0x38>
 82144e8:	e0bffe17 	ldw	r2,-8(fp)
 82144ec:	10c00324 	muli	r3,r2,12
 82144f0:	00820974 	movhi	r2,2085
 82144f4:	108ed304 	addi	r2,r2,15180
 82144f8:	1885883a 	add	r2,r3,r2
 82144fc:	00000106 	br	8214504 <fstat+0x3c>
 8214500:	0005883a 	mov	r2,zero
 8214504:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
 8214508:	e0bffd17 	ldw	r2,-12(fp)
 821450c:	10001026 	beq	r2,zero,8214550 <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 8214510:	e0bffd17 	ldw	r2,-12(fp)
 8214514:	10800017 	ldw	r2,0(r2)
 8214518:	10800817 	ldw	r2,32(r2)
 821451c:	10000726 	beq	r2,zero,821453c <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
 8214520:	e0bffd17 	ldw	r2,-12(fp)
 8214524:	10800017 	ldw	r2,0(r2)
 8214528:	10800817 	ldw	r2,32(r2)
 821452c:	e17fff17 	ldw	r5,-4(fp)
 8214530:	e13ffd17 	ldw	r4,-12(fp)
 8214534:	103ee83a 	callr	r2
 8214538:	00000a06 	br	8214564 <fstat+0x9c>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 821453c:	e0bfff17 	ldw	r2,-4(fp)
 8214540:	00c80004 	movi	r3,8192
 8214544:	10c00115 	stw	r3,4(r2)
      return 0;
 8214548:	0005883a 	mov	r2,zero
 821454c:	00000506 	br	8214564 <fstat+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 8214550:	821448c0 	call	821448c <alt_get_errno>
 8214554:	1007883a 	mov	r3,r2
 8214558:	00801444 	movi	r2,81
 821455c:	18800015 	stw	r2,0(r3)
    return -1;
 8214560:	00bfffc4 	movi	r2,-1
  }
}
 8214564:	e037883a 	mov	sp,fp
 8214568:	dfc00117 	ldw	ra,4(sp)
 821456c:	df000017 	ldw	fp,0(sp)
 8214570:	dec00204 	addi	sp,sp,8
 8214574:	f800283a 	ret

08214578 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 8214578:	defffe04 	addi	sp,sp,-8
 821457c:	dfc00115 	stw	ra,4(sp)
 8214580:	df000015 	stw	fp,0(sp)
 8214584:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 8214588:	d0a04717 	ldw	r2,-32484(gp)
 821458c:	10000326 	beq	r2,zero,821459c <alt_get_errno+0x24>
 8214590:	d0a04717 	ldw	r2,-32484(gp)
 8214594:	103ee83a 	callr	r2
 8214598:	00000106 	br	82145a0 <alt_get_errno+0x28>
 821459c:	d0a06304 	addi	r2,gp,-32372
}
 82145a0:	e037883a 	mov	sp,fp
 82145a4:	dfc00117 	ldw	ra,4(sp)
 82145a8:	df000017 	ldw	fp,0(sp)
 82145ac:	dec00204 	addi	sp,sp,8
 82145b0:	f800283a 	ret

082145b4 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 82145b4:	deffed04 	addi	sp,sp,-76
 82145b8:	dfc01215 	stw	ra,72(sp)
 82145bc:	df001115 	stw	fp,68(sp)
 82145c0:	df001104 	addi	fp,sp,68
 82145c4:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 82145c8:	e0bfff17 	ldw	r2,-4(fp)
 82145cc:	10000616 	blt	r2,zero,82145e8 <isatty+0x34>
 82145d0:	e0bfff17 	ldw	r2,-4(fp)
 82145d4:	10c00324 	muli	r3,r2,12
 82145d8:	00820974 	movhi	r2,2085
 82145dc:	108ed304 	addi	r2,r2,15180
 82145e0:	1885883a 	add	r2,r3,r2
 82145e4:	00000106 	br	82145ec <isatty+0x38>
 82145e8:	0005883a 	mov	r2,zero
 82145ec:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
 82145f0:	e0bfef17 	ldw	r2,-68(fp)
 82145f4:	10000e26 	beq	r2,zero,8214630 <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 82145f8:	e0bfef17 	ldw	r2,-68(fp)
 82145fc:	10800017 	ldw	r2,0(r2)
 8214600:	10800817 	ldw	r2,32(r2)
 8214604:	1000021e 	bne	r2,zero,8214610 <isatty+0x5c>
    {
      return 1;
 8214608:	00800044 	movi	r2,1
 821460c:	00000d06 	br	8214644 <isatty+0x90>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 8214610:	e0bff004 	addi	r2,fp,-64
 8214614:	100b883a 	mov	r5,r2
 8214618:	e13fff17 	ldw	r4,-4(fp)
 821461c:	82144c80 	call	82144c8 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 8214620:	e0bff117 	ldw	r2,-60(fp)
 8214624:	10880020 	cmpeqi	r2,r2,8192
 8214628:	10803fcc 	andi	r2,r2,255
 821462c:	00000506 	br	8214644 <isatty+0x90>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 8214630:	82145780 	call	8214578 <alt_get_errno>
 8214634:	1007883a 	mov	r3,r2
 8214638:	00801444 	movi	r2,81
 821463c:	18800015 	stw	r2,0(r3)
    return 0;
 8214640:	0005883a 	mov	r2,zero
  }
}
 8214644:	e037883a 	mov	sp,fp
 8214648:	dfc00117 	ldw	ra,4(sp)
 821464c:	df000017 	ldw	fp,0(sp)
 8214650:	dec00204 	addi	sp,sp,8
 8214654:	f800283a 	ret

08214658 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 8214658:	defffe04 	addi	sp,sp,-8
 821465c:	dfc00115 	stw	ra,4(sp)
 8214660:	df000015 	stw	fp,0(sp)
 8214664:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 8214668:	d0a04717 	ldw	r2,-32484(gp)
 821466c:	10000326 	beq	r2,zero,821467c <alt_get_errno+0x24>
 8214670:	d0a04717 	ldw	r2,-32484(gp)
 8214674:	103ee83a 	callr	r2
 8214678:	00000106 	br	8214680 <alt_get_errno+0x28>
 821467c:	d0a06304 	addi	r2,gp,-32372
}
 8214680:	e037883a 	mov	sp,fp
 8214684:	dfc00117 	ldw	ra,4(sp)
 8214688:	df000017 	ldw	fp,0(sp)
 821468c:	dec00204 	addi	sp,sp,8
 8214690:	f800283a 	ret

08214694 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 8214694:	defff904 	addi	sp,sp,-28
 8214698:	dfc00615 	stw	ra,24(sp)
 821469c:	df000515 	stw	fp,20(sp)
 82146a0:	df000504 	addi	fp,sp,20
 82146a4:	e13ffd15 	stw	r4,-12(fp)
 82146a8:	e17ffe15 	stw	r5,-8(fp)
 82146ac:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 82146b0:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 82146b4:	e0bffd17 	ldw	r2,-12(fp)
 82146b8:	10000616 	blt	r2,zero,82146d4 <lseek+0x40>
 82146bc:	e0bffd17 	ldw	r2,-12(fp)
 82146c0:	10c00324 	muli	r3,r2,12
 82146c4:	00820974 	movhi	r2,2085
 82146c8:	108ed304 	addi	r2,r2,15180
 82146cc:	1885883a 	add	r2,r3,r2
 82146d0:	00000106 	br	82146d8 <lseek+0x44>
 82146d4:	0005883a 	mov	r2,zero
 82146d8:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
 82146dc:	e0bffc17 	ldw	r2,-16(fp)
 82146e0:	10001026 	beq	r2,zero,8214724 <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 82146e4:	e0bffc17 	ldw	r2,-16(fp)
 82146e8:	10800017 	ldw	r2,0(r2)
 82146ec:	10800717 	ldw	r2,28(r2)
 82146f0:	10000926 	beq	r2,zero,8214718 <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 82146f4:	e0bffc17 	ldw	r2,-16(fp)
 82146f8:	10800017 	ldw	r2,0(r2)
 82146fc:	10800717 	ldw	r2,28(r2)
 8214700:	e1bfff17 	ldw	r6,-4(fp)
 8214704:	e17ffe17 	ldw	r5,-8(fp)
 8214708:	e13ffc17 	ldw	r4,-16(fp)
 821470c:	103ee83a 	callr	r2
 8214710:	e0bffb15 	stw	r2,-20(fp)
 8214714:	00000506 	br	821472c <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 8214718:	00bfde84 	movi	r2,-134
 821471c:	e0bffb15 	stw	r2,-20(fp)
 8214720:	00000206 	br	821472c <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
 8214724:	00bfebc4 	movi	r2,-81
 8214728:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
 821472c:	e0bffb17 	ldw	r2,-20(fp)
 8214730:	1000070e 	bge	r2,zero,8214750 <lseek+0xbc>
  {
    ALT_ERRNO = -rc;
 8214734:	82146580 	call	8214658 <alt_get_errno>
 8214738:	1007883a 	mov	r3,r2
 821473c:	e0bffb17 	ldw	r2,-20(fp)
 8214740:	0085c83a 	sub	r2,zero,r2
 8214744:	18800015 	stw	r2,0(r3)
    rc = -1;
 8214748:	00bfffc4 	movi	r2,-1
 821474c:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
 8214750:	e0bffb17 	ldw	r2,-20(fp)
}
 8214754:	e037883a 	mov	sp,fp
 8214758:	dfc00117 	ldw	ra,4(sp)
 821475c:	df000017 	ldw	fp,0(sp)
 8214760:	dec00204 	addi	sp,sp,8
 8214764:	f800283a 	ret

08214768 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 8214768:	defff904 	addi	sp,sp,-28
 821476c:	dfc00615 	stw	ra,24(sp)
 8214770:	df000515 	stw	fp,20(sp)
 8214774:	df000504 	addi	fp,sp,20
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 8214778:	0009883a 	mov	r4,zero
 821477c:	821c4000 	call	821c400 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 8214780:	82154540 	call	8215454 <OSInit>
 8214784:	01000044 	movi	r4,1
 8214788:	8219dbc0 	call	8219dbc <OSSemCreate>
 821478c:	d0a06815 	stw	r2,-32352(gp)
 8214790:	01000044 	movi	r4,1
 8214794:	8219dbc0 	call	8219dbc <OSSemCreate>
 8214798:	d0a06a15 	stw	r2,-32344(gp)
 821479c:	d0a0b604 	addi	r2,gp,-32040
 82147a0:	e0bffc15 	stw	r2,-16(fp)
 82147a4:	00800044 	movi	r2,1
 82147a8:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 82147ac:	e0bffd0b 	ldhu	r2,-12(fp)
 82147b0:	1009883a 	mov	r4,r2
 82147b4:	8219dbc0 	call	8219dbc <OSSemCreate>
 82147b8:	1007883a 	mov	r3,r2
 82147bc:	e0bffc17 	ldw	r2,-16(fp)
 82147c0:	10c00015 	stw	r3,0(r2)
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 82147c4:	821c4380 	call	821c438 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 82147c8:	01820974 	movhi	r6,2085
 82147cc:	31b77b04 	addi	r6,r6,-8724
 82147d0:	01420974 	movhi	r5,2085
 82147d4:	29777b04 	addi	r5,r5,-8724
 82147d8:	01020974 	movhi	r4,2085
 82147dc:	21377b04 	addi	r4,r4,-8724
 82147e0:	823c3440 	call	823c344 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 82147e4:	823be900 	call	823be90 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 82147e8:	01020934 	movhi	r4,2084
 82147ec:	212fbc04 	addi	r4,r4,-16656
 82147f0:	824b62c0 	call	824b62c <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 82147f4:	d0a06417 	ldw	r2,-32368(gp)
 82147f8:	d0e06517 	ldw	r3,-32364(gp)
 82147fc:	d1206617 	ldw	r4,-32360(gp)
 8214800:	200d883a 	mov	r6,r4
 8214804:	180b883a 	mov	r5,r3
 8214808:	1009883a 	mov	r4,r2
 821480c:	8200d180 	call	8200d18 <main>
 8214810:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
 8214814:	01000044 	movi	r4,1
 8214818:	82258380 	call	8225838 <close>
  exit (result);
 821481c:	e13ffb17 	ldw	r4,-20(fp)
 8214820:	824b6580 	call	824b658 <exit>

08214824 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 8214824:	defff904 	addi	sp,sp,-28
 8214828:	df000615 	stw	fp,24(sp)
 821482c:	df000604 	addi	fp,sp,24
 8214830:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214834:	0005303a 	rdctl	r2,status
 8214838:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821483c:	e0fffe17 	ldw	r3,-8(fp)
 8214840:	00bfff84 	movi	r2,-2
 8214844:	1884703a 	and	r2,r3,r2
 8214848:	1001703a 	wrctl	status,r2
  
  return context;
 821484c:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 8214850:	e0bffb15 	stw	r2,-20(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 8214854:	d0a00917 	ldw	r2,-32732(gp)
 8214858:	10c000c4 	addi	r3,r2,3
 821485c:	00bfff04 	movi	r2,-4
 8214860:	1884703a 	and	r2,r3,r2
 8214864:	d0a00915 	stw	r2,-32732(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 8214868:	d0e00917 	ldw	r3,-32732(gp)
 821486c:	e0bfff17 	ldw	r2,-4(fp)
 8214870:	1887883a 	add	r3,r3,r2
 8214874:	00820e34 	movhi	r2,2104
 8214878:	10800004 	addi	r2,r2,0
 821487c:	10c0062e 	bgeu	r2,r3,8214898 <sbrk+0x74>
 8214880:	e0bffb17 	ldw	r2,-20(fp)
 8214884:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8214888:	e0bffa17 	ldw	r2,-24(fp)
 821488c:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 8214890:	00bfffc4 	movi	r2,-1
 8214894:	00000b06 	br	82148c4 <sbrk+0xa0>
  }
#endif

  prev_heap_end = heap_end; 
 8214898:	d0a00917 	ldw	r2,-32732(gp)
 821489c:	e0bffd15 	stw	r2,-12(fp)
  heap_end += incr; 
 82148a0:	d0e00917 	ldw	r3,-32732(gp)
 82148a4:	e0bfff17 	ldw	r2,-4(fp)
 82148a8:	1885883a 	add	r2,r3,r2
 82148ac:	d0a00915 	stw	r2,-32732(gp)
 82148b0:	e0bffb17 	ldw	r2,-20(fp)
 82148b4:	e0bffc15 	stw	r2,-16(fp)
 82148b8:	e0bffc17 	ldw	r2,-16(fp)
 82148bc:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 82148c0:	e0bffd17 	ldw	r2,-12(fp)
} 
 82148c4:	e037883a 	mov	sp,fp
 82148c8:	df000017 	ldw	fp,0(sp)
 82148cc:	dec00104 	addi	sp,sp,4
 82148d0:	f800283a 	ret

082148d4 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
 82148d4:	deffdf04 	addi	sp,sp,-132
 82148d8:	dfc02015 	stw	ra,128(sp)
 82148dc:	df001f15 	stw	fp,124(sp)
 82148e0:	df001f04 	addi	fp,sp,124
 82148e4:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 82148e8:	e0bfe204 	addi	r2,fp,-120
 82148ec:	100b883a 	mov	r5,r2
 82148f0:	01003fc4 	movi	r4,255
 82148f4:	821bd440 	call	821bd44 <OSTaskQuery>
 82148f8:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 82148fc:	e0bffe83 	ldbu	r2,-6(fp)
 8214900:	10803fcc 	andi	r2,r2,255
 8214904:	10001e1e 	bne	r2,zero,8214980 <__env_lock+0xac>
    return;

  id = tcb.OSTCBPrio;
 8214908:	e0bfee83 	ldbu	r2,-70(fp)
 821490c:	10803fcc 	andi	r2,r2,255
 8214910:	e0bfe115 	stw	r2,-124(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
 8214914:	d0a06817 	ldw	r2,-32352(gp)
 8214918:	e0fffd04 	addi	r3,fp,-12
 821491c:	180b883a 	mov	r5,r3
 8214920:	1009883a 	mov	r4,r2
 8214924:	821a55c0 	call	821a55c <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
 8214928:	e0bffe43 	ldbu	r2,-7(fp)
 821492c:	10803fcc 	andi	r2,r2,255
 8214930:	10000726 	beq	r2,zero,8214950 <__env_lock+0x7c>
 8214934:	d0a00a17 	ldw	r2,-32728(gp)
 8214938:	e0ffe117 	ldw	r3,-124(fp)
 821493c:	1880041e 	bne	r3,r2,8214950 <__env_lock+0x7c>
  {
    /* we do; just count the recursion */

    locks++;
 8214940:	d0a06717 	ldw	r2,-32356(gp)
 8214944:	10800044 	addi	r2,r2,1
 8214948:	d0a06715 	stw	r2,-32356(gp)
 821494c:	00000a06 	br	8214978 <__env_lock+0xa4>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
 8214950:	d0a06817 	ldw	r2,-32352(gp)
 8214954:	e0fffe84 	addi	r3,fp,-6
 8214958:	180d883a 	mov	r6,r3
 821495c:	000b883a 	mov	r5,zero
 8214960:	1009883a 	mov	r4,r2
 8214964:	821a0d40 	call	821a0d4 <OSSemPend>
    locks  = 1;
 8214968:	00800044 	movi	r2,1
 821496c:	d0a06715 	stw	r2,-32356(gp)
    lockid = id;
 8214970:	e0bfe117 	ldw	r2,-124(fp)
 8214974:	d0a00a15 	stw	r2,-32728(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
 8214978:	0001883a 	nop
 821497c:	00000106 	br	8214984 <__env_lock+0xb0>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
 8214980:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 8214984:	e037883a 	mov	sp,fp
 8214988:	dfc00117 	ldw	ra,4(sp)
 821498c:	df000017 	ldw	fp,0(sp)
 8214990:	dec00204 	addi	sp,sp,8
 8214994:	f800283a 	ret

08214998 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
 8214998:	defffd04 	addi	sp,sp,-12
 821499c:	dfc00215 	stw	ra,8(sp)
 82149a0:	df000115 	stw	fp,4(sp)
 82149a4:	df000104 	addi	fp,sp,4
 82149a8:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
 82149ac:	d0a06717 	ldw	r2,-32356(gp)
 82149b0:	10000b26 	beq	r2,zero,82149e0 <__env_unlock+0x48>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
 82149b4:	d0a06717 	ldw	r2,-32356(gp)
 82149b8:	10bfffc4 	addi	r2,r2,-1
 82149bc:	d0a06715 	stw	r2,-32356(gp)
 82149c0:	d0a06717 	ldw	r2,-32356(gp)
 82149c4:	1000071e 	bne	r2,zero,82149e4 <__env_unlock+0x4c>
  {
    lockid = -1;
 82149c8:	00bfffc4 	movi	r2,-1
 82149cc:	d0a00a15 	stw	r2,-32728(gp)
    OSSemPost( alt_envsem );
 82149d0:	d0a06817 	ldw	r2,-32352(gp)
 82149d4:	1009883a 	mov	r4,r2
 82149d8:	821a44c0 	call	821a44c <OSSemPost>
 82149dc:	00000106 	br	82149e4 <__env_unlock+0x4c>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
 82149e0:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 82149e4:	e037883a 	mov	sp,fp
 82149e8:	dfc00117 	ldw	ra,4(sp)
 82149ec:	df000017 	ldw	fp,0(sp)
 82149f0:	dec00204 	addi	sp,sp,8
 82149f4:	f800283a 	ret

082149f8 <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
 82149f8:	deffdb04 	addi	sp,sp,-148
 82149fc:	dfc02415 	stw	ra,144(sp)
 8214a00:	df002315 	stw	fp,140(sp)
 8214a04:	df002304 	addi	fp,sp,140
 8214a08:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8214a0c:	e03fdd15 	stw	zero,-140(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
 8214a10:	d0a06b43 	ldbu	r2,-32339(gp)
 8214a14:	10803fcc 	andi	r2,r2,255
 8214a18:	10800060 	cmpeqi	r2,r2,1
 8214a1c:	10003626 	beq	r2,zero,8214af8 <__malloc_lock+0x100>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 8214a20:	e0bfe204 	addi	r2,fp,-120
 8214a24:	100b883a 	mov	r5,r2
 8214a28:	01003fc4 	movi	r4,255
 8214a2c:	821bd440 	call	821bd44 <OSTaskQuery>
 8214a30:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 8214a34:	e0bffe83 	ldbu	r2,-6(fp)
 8214a38:	10803fcc 	andi	r2,r2,255
 8214a3c:	1000301e 	bne	r2,zero,8214b00 <__malloc_lock+0x108>
    return;

  id = tcb.OSTCBPrio;
 8214a40:	e0bfee83 	ldbu	r2,-70(fp)
 8214a44:	10803fcc 	andi	r2,r2,255
 8214a48:	e0bfde15 	stw	r2,-136(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
 8214a4c:	d0a06a17 	ldw	r2,-32344(gp)
 8214a50:	e0fffd04 	addi	r3,fp,-12
 8214a54:	180b883a 	mov	r5,r3
 8214a58:	1009883a 	mov	r4,r2
 8214a5c:	821a55c0 	call	821a55c <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214a60:	0005303a 	rdctl	r2,status
 8214a64:	e0bfe115 	stw	r2,-124(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8214a68:	e0ffe117 	ldw	r3,-124(fp)
 8214a6c:	00bfff84 	movi	r2,-2
 8214a70:	1884703a 	and	r2,r3,r2
 8214a74:	1001703a 	wrctl	status,r2
  
  return context;
 8214a78:	e0bfe117 	ldw	r2,-124(fp)
  
  OS_ENTER_CRITICAL();
 8214a7c:	e0bfdd15 	stw	r2,-140(fp)

  if( !semdata.OSCnt && id == lockid ) 
 8214a80:	e0bffd0b 	ldhu	r2,-12(fp)
 8214a84:	10bfffcc 	andi	r2,r2,65535
 8214a88:	10000b1e 	bne	r2,zero,8214ab8 <__malloc_lock+0xc0>
 8214a8c:	d0a00b17 	ldw	r2,-32724(gp)
 8214a90:	e0ffde17 	ldw	r3,-136(fp)
 8214a94:	1880081e 	bne	r3,r2,8214ab8 <__malloc_lock+0xc0>
  {
    /* we do; just count the recursion */
    locks++;
 8214a98:	d0a06917 	ldw	r2,-32348(gp)
 8214a9c:	10800044 	addi	r2,r2,1
 8214aa0:	d0a06915 	stw	r2,-32348(gp)
 8214aa4:	e0bfdd17 	ldw	r2,-140(fp)
 8214aa8:	e0bfdf15 	stw	r2,-132(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8214aac:	e0bfdf17 	ldw	r2,-132(fp)
 8214ab0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
 8214ab4:	00000e06 	br	8214af0 <__malloc_lock+0xf8>
 8214ab8:	e0bfdd17 	ldw	r2,-140(fp)
 8214abc:	e0bfe015 	stw	r2,-128(fp)
 8214ac0:	e0bfe017 	ldw	r2,-128(fp)
 8214ac4:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
 8214ac8:	d0a06a17 	ldw	r2,-32344(gp)
 8214acc:	e0fffe84 	addi	r3,fp,-6
 8214ad0:	180d883a 	mov	r6,r3
 8214ad4:	000b883a 	mov	r5,zero
 8214ad8:	1009883a 	mov	r4,r2
 8214adc:	821a0d40 	call	821a0d4 <OSSemPend>
    locks  = 1;
 8214ae0:	00800044 	movi	r2,1
 8214ae4:	d0a06915 	stw	r2,-32348(gp)
    lockid = id;
 8214ae8:	e0bfde17 	ldw	r2,-136(fp)
 8214aec:	d0a00b15 	stw	r2,-32724(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
 8214af0:	0001883a 	nop
 8214af4:	00000306 	br	8214b04 <__malloc_lock+0x10c>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
 8214af8:	0001883a 	nop
 8214afc:	00000106 	br	8214b04 <__malloc_lock+0x10c>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
 8214b00:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 8214b04:	e037883a 	mov	sp,fp
 8214b08:	dfc00117 	ldw	ra,4(sp)
 8214b0c:	df000017 	ldw	fp,0(sp)
 8214b10:	dec00204 	addi	sp,sp,8
 8214b14:	f800283a 	ret

08214b18 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 8214b18:	defff804 	addi	sp,sp,-32
 8214b1c:	dfc00715 	stw	ra,28(sp)
 8214b20:	df000615 	stw	fp,24(sp)
 8214b24:	df000604 	addi	fp,sp,24
 8214b28:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8214b2c:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
 8214b30:	d0a06b43 	ldbu	r2,-32339(gp)
 8214b34:	10803fcc 	andi	r2,r2,255
 8214b38:	10800060 	cmpeqi	r2,r2,1
 8214b3c:	10002326 	beq	r2,zero,8214bcc <__malloc_unlock+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214b40:	0005303a 	rdctl	r2,status
 8214b44:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8214b48:	e0fffe17 	ldw	r3,-8(fp)
 8214b4c:	00bfff84 	movi	r2,-2
 8214b50:	1884703a 	and	r2,r3,r2
 8214b54:	1001703a 	wrctl	status,r2
  
  return context;
 8214b58:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
 8214b5c:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
 8214b60:	d0a06917 	ldw	r2,-32348(gp)
 8214b64:	1000051e 	bne	r2,zero,8214b7c <__malloc_unlock+0x64>
 8214b68:	e0bffa17 	ldw	r2,-24(fp)
 8214b6c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8214b70:	e0bffb17 	ldw	r2,-20(fp)
 8214b74:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
 8214b78:	00001506 	br	8214bd0 <__malloc_unlock+0xb8>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
 8214b7c:	d0a06917 	ldw	r2,-32348(gp)
 8214b80:	10bfffc4 	addi	r2,r2,-1
 8214b84:	d0a06915 	stw	r2,-32348(gp)
 8214b88:	d0a06917 	ldw	r2,-32348(gp)
 8214b8c:	10000a1e 	bne	r2,zero,8214bb8 <__malloc_unlock+0xa0>
  {
    lockid = -1;
 8214b90:	00bfffc4 	movi	r2,-1
 8214b94:	d0a00b15 	stw	r2,-32724(gp)
 8214b98:	e0bffa17 	ldw	r2,-24(fp)
 8214b9c:	e0bffc15 	stw	r2,-16(fp)
 8214ba0:	e0bffc17 	ldw	r2,-16(fp)
 8214ba4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
 8214ba8:	d0a06a17 	ldw	r2,-32344(gp)
 8214bac:	1009883a 	mov	r4,r2
 8214bb0:	821a44c0 	call	821a44c <OSSemPost>
 8214bb4:	00000606 	br	8214bd0 <__malloc_unlock+0xb8>
 8214bb8:	e0bffa17 	ldw	r2,-24(fp)
 8214bbc:	e0bffd15 	stw	r2,-12(fp)
 8214bc0:	e0bffd17 	ldw	r2,-12(fp)
 8214bc4:	1001703a 	wrctl	status,r2
 8214bc8:	00000106 	br	8214bd0 <__malloc_unlock+0xb8>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
 8214bcc:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 8214bd0:	e037883a 	mov	sp,fp
 8214bd4:	dfc00117 	ldw	ra,4(sp)
 8214bd8:	df000017 	ldw	fp,0(sp)
 8214bdc:	dec00204 	addi	sp,sp,8
 8214be0:	f800283a 	ret

08214be4 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 8214be4:	defff704 	addi	sp,sp,-36
 8214be8:	dfc00815 	stw	ra,32(sp)
 8214bec:	df000715 	stw	fp,28(sp)
 8214bf0:	df000704 	addi	fp,sp,28
 8214bf4:	e13ffd15 	stw	r4,-12(fp)
 8214bf8:	e17ffe15 	stw	r5,-8(fp)
 8214bfc:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8214c00:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8214c04:	e0bfff17 	ldw	r2,-4(fp)
 8214c08:	1000021e 	bne	r2,zero,8214c14 <OSEventNameGet+0x30>
        return (0);
 8214c0c:	0005883a 	mov	r2,zero
 8214c10:	00003706 	br	8214cf0 <OSEventNameGet+0x10c>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 8214c14:	e0bffd17 	ldw	r2,-12(fp)
 8214c18:	1000051e 	bne	r2,zero,8214c30 <OSEventNameGet+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
 8214c1c:	e0bfff17 	ldw	r2,-4(fp)
 8214c20:	00c00104 	movi	r3,4
 8214c24:	10c00005 	stb	r3,0(r2)
        return (0);
 8214c28:	0005883a 	mov	r2,zero
 8214c2c:	00003006 	br	8214cf0 <OSEventNameGet+0x10c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 8214c30:	e0bffe17 	ldw	r2,-8(fp)
 8214c34:	1000051e 	bne	r2,zero,8214c4c <OSEventNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
 8214c38:	e0bfff17 	ldw	r2,-4(fp)
 8214c3c:	00c00304 	movi	r3,12
 8214c40:	10c00005 	stb	r3,0(r2)
        return (0);
 8214c44:	0005883a 	mov	r2,zero
 8214c48:	00002906 	br	8214cf0 <OSEventNameGet+0x10c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 8214c4c:	d0a07903 	ldbu	r2,-32284(gp)
 8214c50:	10803fcc 	andi	r2,r2,255
 8214c54:	10000526 	beq	r2,zero,8214c6c <OSEventNameGet+0x88>
        *perr  = OS_ERR_NAME_GET_ISR;
 8214c58:	e0bfff17 	ldw	r2,-4(fp)
 8214c5c:	00c00444 	movi	r3,17
 8214c60:	10c00005 	stb	r3,0(r2)
        return (0);
 8214c64:	0005883a 	mov	r2,zero
 8214c68:	00002106 	br	8214cf0 <OSEventNameGet+0x10c>
    }
    switch (pevent->OSEventType) {
 8214c6c:	e0bffd17 	ldw	r2,-12(fp)
 8214c70:	10800003 	ldbu	r2,0(r2)
 8214c74:	10803fcc 	andi	r2,r2,255
 8214c78:	10bfffc4 	addi	r2,r2,-1
 8214c7c:	10800128 	cmpgeui	r2,r2,4
 8214c80:	10000526 	beq	r2,zero,8214c98 <OSEventNameGet+0xb4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 8214c84:	e0bfff17 	ldw	r2,-4(fp)
 8214c88:	00c00044 	movi	r3,1
 8214c8c:	10c00005 	stb	r3,0(r2)
             return (0);
 8214c90:	0005883a 	mov	r2,zero
 8214c94:	00001606 	br	8214cf0 <OSEventNameGet+0x10c>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
 8214c98:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214c9c:	0005303a 	rdctl	r2,status
 8214ca0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8214ca4:	e0fffb17 	ldw	r3,-20(fp)
 8214ca8:	00bfff84 	movi	r2,-2
 8214cac:	1884703a 	and	r2,r3,r2
 8214cb0:	1001703a 	wrctl	status,r2
  
  return context;
 8214cb4:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
 8214cb8:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
 8214cbc:	e0bffd17 	ldw	r2,-12(fp)
 8214cc0:	10800384 	addi	r2,r2,14
 8214cc4:	100b883a 	mov	r5,r2
 8214cc8:	e13ffe17 	ldw	r4,-8(fp)
 8214ccc:	82166680 	call	8216668 <OS_StrCopy>
 8214cd0:	e0bffa05 	stb	r2,-24(fp)
 8214cd4:	e0bff917 	ldw	r2,-28(fp)
 8214cd8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8214cdc:	e0bffc17 	ldw	r2,-16(fp)
 8214ce0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8214ce4:	e0bfff17 	ldw	r2,-4(fp)
 8214ce8:	10000005 	stb	zero,0(r2)
    return (len);
 8214cec:	e0bffa03 	ldbu	r2,-24(fp)
}
 8214cf0:	e037883a 	mov	sp,fp
 8214cf4:	dfc00117 	ldw	ra,4(sp)
 8214cf8:	df000017 	ldw	fp,0(sp)
 8214cfc:	dec00204 	addi	sp,sp,8
 8214d00:	f800283a 	ret

08214d04 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 8214d04:	defff604 	addi	sp,sp,-40
 8214d08:	dfc00915 	stw	ra,36(sp)
 8214d0c:	df000815 	stw	fp,32(sp)
 8214d10:	df000804 	addi	fp,sp,32
 8214d14:	e13ffd15 	stw	r4,-12(fp)
 8214d18:	e17ffe15 	stw	r5,-8(fp)
 8214d1c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8214d20:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8214d24:	e0bfff17 	ldw	r2,-4(fp)
 8214d28:	10004026 	beq	r2,zero,8214e2c <OSEventNameSet+0x128>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 8214d2c:	e0bffd17 	ldw	r2,-12(fp)
 8214d30:	1000041e 	bne	r2,zero,8214d44 <OSEventNameSet+0x40>
        *perr = OS_ERR_PEVENT_NULL;
 8214d34:	e0bfff17 	ldw	r2,-4(fp)
 8214d38:	00c00104 	movi	r3,4
 8214d3c:	10c00005 	stb	r3,0(r2)
        return;
 8214d40:	00003b06 	br	8214e30 <OSEventNameSet+0x12c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 8214d44:	e0bffe17 	ldw	r2,-8(fp)
 8214d48:	1000041e 	bne	r2,zero,8214d5c <OSEventNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
 8214d4c:	e0bfff17 	ldw	r2,-4(fp)
 8214d50:	00c00304 	movi	r3,12
 8214d54:	10c00005 	stb	r3,0(r2)
        return;
 8214d58:	00003506 	br	8214e30 <OSEventNameSet+0x12c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 8214d5c:	d0a07903 	ldbu	r2,-32284(gp)
 8214d60:	10803fcc 	andi	r2,r2,255
 8214d64:	10000426 	beq	r2,zero,8214d78 <OSEventNameSet+0x74>
        *perr = OS_ERR_NAME_SET_ISR;
 8214d68:	e0bfff17 	ldw	r2,-4(fp)
 8214d6c:	00c00484 	movi	r3,18
 8214d70:	10c00005 	stb	r3,0(r2)
        return;
 8214d74:	00002e06 	br	8214e30 <OSEventNameSet+0x12c>
    }
    switch (pevent->OSEventType) {
 8214d78:	e0bffd17 	ldw	r2,-12(fp)
 8214d7c:	10800003 	ldbu	r2,0(r2)
 8214d80:	10803fcc 	andi	r2,r2,255
 8214d84:	10bfffc4 	addi	r2,r2,-1
 8214d88:	10800128 	cmpgeui	r2,r2,4
 8214d8c:	10000426 	beq	r2,zero,8214da0 <OSEventNameSet+0x9c>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 8214d90:	e0bfff17 	ldw	r2,-4(fp)
 8214d94:	00c00044 	movi	r3,1
 8214d98:	10c00005 	stb	r3,0(r2)
             return;
 8214d9c:	00002406 	br	8214e30 <OSEventNameSet+0x12c>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
 8214da0:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214da4:	0005303a 	rdctl	r2,status
 8214da8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8214dac:	e0fffc17 	ldw	r3,-16(fp)
 8214db0:	00bfff84 	movi	r2,-2
 8214db4:	1884703a 	and	r2,r3,r2
 8214db8:	1001703a 	wrctl	status,r2
  
  return context;
 8214dbc:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
 8214dc0:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
 8214dc4:	e13ffe17 	ldw	r4,-8(fp)
 8214dc8:	82166dc0 	call	82166dc <OS_StrLen>
 8214dcc:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
 8214dd0:	e0bffa03 	ldbu	r2,-24(fp)
 8214dd4:	10800830 	cmpltui	r2,r2,32
 8214dd8:	1000081e 	bne	r2,zero,8214dfc <OSEventNameSet+0xf8>
 8214ddc:	e0bff817 	ldw	r2,-32(fp)
 8214de0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8214de4:	e0bff917 	ldw	r2,-28(fp)
 8214de8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
 8214dec:	e0bfff17 	ldw	r2,-4(fp)
 8214df0:	00c002c4 	movi	r3,11
 8214df4:	10c00005 	stb	r3,0(r2)
        return;
 8214df8:	00000d06 	br	8214e30 <OSEventNameSet+0x12c>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
 8214dfc:	e0bffd17 	ldw	r2,-12(fp)
 8214e00:	10800384 	addi	r2,r2,14
 8214e04:	e17ffe17 	ldw	r5,-8(fp)
 8214e08:	1009883a 	mov	r4,r2
 8214e0c:	82166680 	call	8216668 <OS_StrCopy>
 8214e10:	e0bff817 	ldw	r2,-32(fp)
 8214e14:	e0bffb15 	stw	r2,-20(fp)
 8214e18:	e0bffb17 	ldw	r2,-20(fp)
 8214e1c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8214e20:	e0bfff17 	ldw	r2,-4(fp)
 8214e24:	10000005 	stb	zero,0(r2)
 8214e28:	00000106 	br	8214e30 <OSEventNameSet+0x12c>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
 8214e2c:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
 8214e30:	e037883a 	mov	sp,fp
 8214e34:	dfc00117 	ldw	ra,4(sp)
 8214e38:	df000017 	ldw	fp,0(sp)
 8214e3c:	dec00204 	addi	sp,sp,8
 8214e40:	f800283a 	ret

08214e44 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
 8214e44:	deffed04 	addi	sp,sp,-76
 8214e48:	dfc01215 	stw	ra,72(sp)
 8214e4c:	df001115 	stw	fp,68(sp)
 8214e50:	df001104 	addi	fp,sp,68
 8214e54:	e13ffc15 	stw	r4,-16(fp)
 8214e58:	e17ffd15 	stw	r5,-12(fp)
 8214e5c:	e1bffe15 	stw	r6,-8(fp)
 8214e60:	3805883a 	mov	r2,r7
 8214e64:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
 8214e68:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
 8214e6c:	e0800217 	ldw	r2,8(fp)
 8214e70:	1000021e 	bne	r2,zero,8214e7c <OSEventPendMulti+0x38>
        return (0);
 8214e74:	0005883a 	mov	r2,zero
 8214e78:	00017106 	br	8215440 <OSEventPendMulti+0x5fc>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
 8214e7c:	e0bffc17 	ldw	r2,-16(fp)
 8214e80:	1000051e 	bne	r2,zero,8214e98 <OSEventPendMulti+0x54>
       *perr =  OS_ERR_PEVENT_NULL;
 8214e84:	e0800217 	ldw	r2,8(fp)
 8214e88:	00c00104 	movi	r3,4
 8214e8c:	10c00005 	stb	r3,0(r2)
        return (0);
 8214e90:	0005883a 	mov	r2,zero
 8214e94:	00016a06 	br	8215440 <OSEventPendMulti+0x5fc>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
 8214e98:	e0bffd17 	ldw	r2,-12(fp)
 8214e9c:	1000051e 	bne	r2,zero,8214eb4 <OSEventPendMulti+0x70>
       *perr =  OS_ERR_PEVENT_NULL;
 8214ea0:	e0800217 	ldw	r2,8(fp)
 8214ea4:	00c00104 	movi	r3,4
 8214ea8:	10c00005 	stb	r3,0(r2)
        return (0);
 8214eac:	0005883a 	mov	r2,zero
 8214eb0:	00016306 	br	8215440 <OSEventPendMulti+0x5fc>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
 8214eb4:	e0bffe17 	ldw	r2,-8(fp)
 8214eb8:	1000051e 	bne	r2,zero,8214ed0 <OSEventPendMulti+0x8c>
       *perr =  OS_ERR_PEVENT_NULL;
 8214ebc:	e0800217 	ldw	r2,8(fp)
 8214ec0:	00c00104 	movi	r3,4
 8214ec4:	10c00005 	stb	r3,0(r2)
        return (0);
 8214ec8:	0005883a 	mov	r2,zero
 8214ecc:	00015c06 	br	8215440 <OSEventPendMulti+0x5fc>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
 8214ed0:	e0bffd17 	ldw	r2,-12(fp)
 8214ed4:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
 8214ed8:	e0bffc17 	ldw	r2,-16(fp)
 8214edc:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
 8214ee0:	e0bfef17 	ldw	r2,-68(fp)
 8214ee4:	10800017 	ldw	r2,0(r2)
 8214ee8:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
 8214eec:	00001906 	br	8214f54 <OSEventPendMulti+0x110>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
 8214ef0:	e0bff017 	ldw	r2,-64(fp)
 8214ef4:	10800003 	ldbu	r2,0(r2)
 8214ef8:	10803fcc 	andi	r2,r2,255
 8214efc:	10c000a0 	cmpeqi	r3,r2,2
 8214f00:	1800091e 	bne	r3,zero,8214f28 <OSEventPendMulti+0xe4>
 8214f04:	10c000e0 	cmpeqi	r3,r2,3
 8214f08:	1800091e 	bne	r3,zero,8214f30 <OSEventPendMulti+0xec>
 8214f0c:	10800060 	cmpeqi	r2,r2,1
 8214f10:	1000091e 	bne	r2,zero,8214f38 <OSEventPendMulti+0xf4>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
 8214f14:	e0800217 	ldw	r2,8(fp)
 8214f18:	00c00044 	movi	r3,1
 8214f1c:	10c00005 	stb	r3,0(r2)
                 return (0);
 8214f20:	0005883a 	mov	r2,zero
 8214f24:	00014606 	br	8215440 <OSEventPendMulti+0x5fc>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
 8214f28:	0001883a 	nop
 8214f2c:	00000306 	br	8214f3c <OSEventPendMulti+0xf8>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
 8214f30:	0001883a 	nop
 8214f34:	00000106 	br	8214f3c <OSEventPendMulti+0xf8>
#endif
#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 break;
 8214f38:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
 8214f3c:	e0bfef17 	ldw	r2,-68(fp)
 8214f40:	10800104 	addi	r2,r2,4
 8214f44:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
 8214f48:	e0bfef17 	ldw	r2,-68(fp)
 8214f4c:	10800017 	ldw	r2,0(r2)
 8214f50:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
 8214f54:	e0bff017 	ldw	r2,-64(fp)
 8214f58:	103fe51e 	bne	r2,zero,8214ef0 <OSEventPendMulti+0xac>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
 8214f5c:	d0a07903 	ldbu	r2,-32284(gp)
 8214f60:	10803fcc 	andi	r2,r2,255
 8214f64:	10000526 	beq	r2,zero,8214f7c <OSEventPendMulti+0x138>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
 8214f68:	e0800217 	ldw	r2,8(fp)
 8214f6c:	00c00084 	movi	r3,2
 8214f70:	10c00005 	stb	r3,0(r2)
        return (0);
 8214f74:	0005883a 	mov	r2,zero
 8214f78:	00013106 	br	8215440 <OSEventPendMulti+0x5fc>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
 8214f7c:	d0a06b03 	ldbu	r2,-32340(gp)
 8214f80:	10803fcc 	andi	r2,r2,255
 8214f84:	10000526 	beq	r2,zero,8214f9c <OSEventPendMulti+0x158>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
 8214f88:	e0800217 	ldw	r2,8(fp)
 8214f8c:	00c00344 	movi	r3,13
 8214f90:	10c00005 	stb	r3,0(r2)
        return (0);
 8214f94:	0005883a 	mov	r2,zero
 8214f98:	00012906 	br	8215440 <OSEventPendMulti+0x5fc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214f9c:	0005303a 	rdctl	r2,status
 8214fa0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8214fa4:	e0fffb17 	ldw	r3,-20(fp)
 8214fa8:	00bfff84 	movi	r2,-2
 8214fac:	1884703a 	and	r2,r3,r2
 8214fb0:	1001703a 	wrctl	status,r2
  
  return context;
 8214fb4:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
 8214fb8:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
 8214fbc:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
 8214fc0:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
 8214fc4:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
 8214fc8:	e0bffc17 	ldw	r2,-16(fp)
 8214fcc:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
 8214fd0:	e0bfef17 	ldw	r2,-68(fp)
 8214fd4:	10800017 	ldw	r2,0(r2)
 8214fd8:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 8214fdc:	00008106 	br	82151e4 <OSEventPendMulti+0x3a0>
        switch (pevent->OSEventType) {
 8214fe0:	e0bff017 	ldw	r2,-64(fp)
 8214fe4:	10800003 	ldbu	r2,0(r2)
 8214fe8:	10803fcc 	andi	r2,r2,255
 8214fec:	10c000a0 	cmpeqi	r3,r2,2
 8214ff0:	18003c1e 	bne	r3,zero,82150e4 <OSEventPendMulti+0x2a0>
 8214ff4:	10c000e0 	cmpeqi	r3,r2,3
 8214ff8:	1800031e 	bne	r3,zero,8215008 <OSEventPendMulti+0x1c4>
 8214ffc:	10800060 	cmpeqi	r2,r2,1
 8215000:	10001e1e 	bne	r2,zero,821507c <OSEventPendMulti+0x238>
 8215004:	00006606 	br	82151a0 <OSEventPendMulti+0x35c>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
 8215008:	e0bff017 	ldw	r2,-64(fp)
 821500c:	1080020b 	ldhu	r2,8(r2)
 8215010:	10bfffcc 	andi	r2,r2,65535
 8215014:	10001526 	beq	r2,zero,821506c <OSEventPendMulti+0x228>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
 8215018:	e0bff017 	ldw	r2,-64(fp)
 821501c:	1080020b 	ldhu	r2,8(r2)
 8215020:	10bfffc4 	addi	r2,r2,-1
 8215024:	1007883a 	mov	r3,r2
 8215028:	e0bff017 	ldw	r2,-64(fp)
 821502c:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
 8215030:	e0bffd17 	ldw	r2,-12(fp)
 8215034:	10c00104 	addi	r3,r2,4
 8215038:	e0fffd15 	stw	r3,-12(fp)
 821503c:	e0fff017 	ldw	r3,-64(fp)
 8215040:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
 8215044:	00800044 	movi	r2,1
 8215048:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
 821504c:	e0bffe17 	ldw	r2,-8(fp)
 8215050:	10c00104 	addi	r3,r2,4
 8215054:	e0fffe15 	stw	r3,-8(fp)
 8215058:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
 821505c:	e0bff18b 	ldhu	r2,-58(fp)
 8215060:	10800044 	addi	r2,r2,1
 8215064:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
 8215068:	00005806 	br	82151cc <OSEventPendMulti+0x388>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
 821506c:	e0bff203 	ldbu	r2,-56(fp)
 8215070:	10800054 	ori	r2,r2,1
 8215074:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
 8215078:	00005406 	br	82151cc <OSEventPendMulti+0x388>
#endif

#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
 821507c:	e0bff017 	ldw	r2,-64(fp)
 8215080:	10800117 	ldw	r2,4(r2)
 8215084:	10001326 	beq	r2,zero,82150d4 <OSEventPendMulti+0x290>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
 8215088:	e0bffe17 	ldw	r2,-8(fp)
 821508c:	10c00104 	addi	r3,r2,4
 8215090:	e0fffe15 	stw	r3,-8(fp)
 8215094:	e0fff017 	ldw	r3,-64(fp)
 8215098:	18c00117 	ldw	r3,4(r3)
 821509c:	10c00015 	stw	r3,0(r2)
                     pevent->OSEventPtr  = (void *)0;
 82150a0:	e0bff017 	ldw	r2,-64(fp)
 82150a4:	10000115 	stw	zero,4(r2)
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
 82150a8:	e0bffd17 	ldw	r2,-12(fp)
 82150ac:	10c00104 	addi	r3,r2,4
 82150b0:	e0fffd15 	stw	r3,-12(fp)
 82150b4:	e0fff017 	ldw	r3,-64(fp)
 82150b8:	10c00015 	stw	r3,0(r2)
                      events_rdy         =  OS_TRUE;
 82150bc:	00800044 	movi	r2,1
 82150c0:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
 82150c4:	e0bff18b 	ldhu	r2,-58(fp)
 82150c8:	10800044 	addi	r2,r2,1
 82150cc:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
                 }
                 break;
 82150d0:	00003e06 	br	82151cc <OSEventPendMulti+0x388>
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
                      events_rdy         =  OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
 82150d4:	e0bff203 	ldbu	r2,-56(fp)
 82150d8:	10800094 	ori	r2,r2,2
 82150dc:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
 82150e0:	00003a06 	br	82151cc <OSEventPendMulti+0x388>
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
 82150e4:	e0bff017 	ldw	r2,-64(fp)
 82150e8:	10800117 	ldw	r2,4(r2)
 82150ec:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
 82150f0:	e0bff517 	ldw	r2,-44(fp)
 82150f4:	1080058b 	ldhu	r2,22(r2)
 82150f8:	10bfffcc 	andi	r2,r2,65535
 82150fc:	10002426 	beq	r2,zero,8215190 <OSEventPendMulti+0x34c>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
 8215100:	e0bffe17 	ldw	r2,-8(fp)
 8215104:	10c00104 	addi	r3,r2,4
 8215108:	e0fffe15 	stw	r3,-8(fp)
 821510c:	e0fff517 	ldw	r3,-44(fp)
 8215110:	18c00417 	ldw	r3,16(r3)
 8215114:	19400104 	addi	r5,r3,4
 8215118:	e13ff517 	ldw	r4,-44(fp)
 821511c:	21400415 	stw	r5,16(r4)
 8215120:	18c00017 	ldw	r3,0(r3)
 8215124:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
 8215128:	e0bff517 	ldw	r2,-44(fp)
 821512c:	10c00417 	ldw	r3,16(r2)
 8215130:	e0bff517 	ldw	r2,-44(fp)
 8215134:	10800217 	ldw	r2,8(r2)
 8215138:	1880041e 	bne	r3,r2,821514c <OSEventPendMulti+0x308>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
 821513c:	e0bff517 	ldw	r2,-44(fp)
 8215140:	10c00117 	ldw	r3,4(r2)
 8215144:	e0bff517 	ldw	r2,-44(fp)
 8215148:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
 821514c:	e0bff517 	ldw	r2,-44(fp)
 8215150:	1080058b 	ldhu	r2,22(r2)
 8215154:	10bfffc4 	addi	r2,r2,-1
 8215158:	1007883a 	mov	r3,r2
 821515c:	e0bff517 	ldw	r2,-44(fp)
 8215160:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
 8215164:	e0bffd17 	ldw	r2,-12(fp)
 8215168:	10c00104 	addi	r3,r2,4
 821516c:	e0fffd15 	stw	r3,-12(fp)
 8215170:	e0fff017 	ldw	r3,-64(fp)
 8215174:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
 8215178:	00800044 	movi	r2,1
 821517c:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
 8215180:	e0bff18b 	ldhu	r2,-58(fp)
 8215184:	10800044 	addi	r2,r2,1
 8215188:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
 821518c:	00000f06 	br	82151cc <OSEventPendMulti+0x388>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
 8215190:	e0bff203 	ldbu	r2,-56(fp)
 8215194:	10800114 	ori	r2,r2,4
 8215198:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
 821519c:	00000b06 	br	82151cc <OSEventPendMulti+0x388>
 82151a0:	e0bff317 	ldw	r2,-52(fp)
 82151a4:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82151a8:	e0bff417 	ldw	r2,-48(fp)
 82151ac:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
 82151b0:	e0bffd17 	ldw	r2,-12(fp)
 82151b4:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
 82151b8:	e0800217 	ldw	r2,8(fp)
 82151bc:	00c00044 	movi	r3,1
 82151c0:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
 82151c4:	e0bff18b 	ldhu	r2,-58(fp)
 82151c8:	00009d06 	br	8215440 <OSEventPendMulti+0x5fc>
        }
        pevents++;
 82151cc:	e0bfef17 	ldw	r2,-68(fp)
 82151d0:	10800104 	addi	r2,r2,4
 82151d4:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
 82151d8:	e0bfef17 	ldw	r2,-68(fp)
 82151dc:	10800017 	ldw	r2,0(r2)
 82151e0:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 82151e4:	e0bff017 	ldw	r2,-64(fp)
 82151e8:	103f7d1e 	bne	r2,zero,8214fe0 <OSEventPendMulti+0x19c>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
 82151ec:	e0bff103 	ldbu	r2,-60(fp)
 82151f0:	10800058 	cmpnei	r2,r2,1
 82151f4:	10000a1e 	bne	r2,zero,8215220 <OSEventPendMulti+0x3dc>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
 82151f8:	e0bffd17 	ldw	r2,-12(fp)
 82151fc:	10000015 	stw	zero,0(r2)
 8215200:	e0bff317 	ldw	r2,-52(fp)
 8215204:	e0bff615 	stw	r2,-40(fp)
 8215208:	e0bff617 	ldw	r2,-40(fp)
 821520c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
 8215210:	e0800217 	ldw	r2,8(fp)
 8215214:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
 8215218:	e0bff18b 	ldhu	r2,-58(fp)
 821521c:	00008806 	br	8215440 <OSEventPendMulti+0x5fc>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
 8215220:	d0a07a17 	ldw	r2,-32280(gp)
 8215224:	d0e07a17 	ldw	r3,-32280(gp)
 8215228:	19000c03 	ldbu	r4,48(r3)
 821522c:	e0fff203 	ldbu	r3,-56(fp)
 8215230:	20c6b03a 	or	r3,r4,r3
 8215234:	1809883a 	mov	r4,r3
 8215238:	00ffe004 	movi	r3,-128
 821523c:	20c6b03a 	or	r3,r4,r3
 8215240:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 8215244:	d0a07a17 	ldw	r2,-32280(gp)
 8215248:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
 821524c:	d0a07a17 	ldw	r2,-32280(gp)
 8215250:	e0ffff0b 	ldhu	r3,-4(fp)
 8215254:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
 8215258:	e13ffc17 	ldw	r4,-16(fp)
 821525c:	8215d800 	call	8215d80 <OS_EventTaskWaitMulti>
 8215260:	e0bff317 	ldw	r2,-52(fp)
 8215264:	e0bff915 	stw	r2,-28(fp)
 8215268:	e0bff917 	ldw	r2,-28(fp)
 821526c:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
 8215270:	82165240 	call	8216524 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8215274:	0005303a 	rdctl	r2,status
 8215278:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821527c:	e0fff717 	ldw	r3,-36(fp)
 8215280:	00bfff84 	movi	r2,-2
 8215284:	1884703a 	and	r2,r3,r2
 8215288:	1001703a 	wrctl	status,r2
  
  return context;
 821528c:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 8215290:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
 8215294:	d0a07a17 	ldw	r2,-32280(gp)
 8215298:	10800c43 	ldbu	r2,49(r2)
 821529c:	10803fcc 	andi	r2,r2,255
 82152a0:	10000226 	beq	r2,zero,82152ac <OSEventPendMulti+0x468>
 82152a4:	108000a0 	cmpeqi	r2,r2,2
 82152a8:	10001826 	beq	r2,zero,821530c <OSEventPendMulti+0x4c8>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
 82152ac:	d0a07a17 	ldw	r2,-32280(gp)
 82152b0:	10800717 	ldw	r2,28(r2)
 82152b4:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
 82152b8:	e0bff017 	ldw	r2,-64(fp)
 82152bc:	10000b26 	beq	r2,zero,82152ec <OSEventPendMulti+0x4a8>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
 82152c0:	e0bffd17 	ldw	r2,-12(fp)
 82152c4:	10c00104 	addi	r3,r2,4
 82152c8:	e0fffd15 	stw	r3,-12(fp)
 82152cc:	e0fff017 	ldw	r3,-64(fp)
 82152d0:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
 82152d4:	e0bffd17 	ldw	r2,-12(fp)
 82152d8:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
 82152dc:	e0bff18b 	ldhu	r2,-58(fp)
 82152e0:	10800044 	addi	r2,r2,1
 82152e4:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
 82152e8:	00000d06 	br	8215320 <OSEventPendMulti+0x4dc>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
 82152ec:	d0a07a17 	ldw	r2,-32280(gp)
 82152f0:	00c00044 	movi	r3,1
 82152f4:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 82152f8:	d0a07a17 	ldw	r2,-32280(gp)
 82152fc:	e17ffc17 	ldw	r5,-16(fp)
 8215300:	1009883a 	mov	r4,r2
 8215304:	8215f880 	call	8215f88 <OS_EventTaskRemoveMulti>
             }
			 break;
 8215308:	00000506 	br	8215320 <OSEventPendMulti+0x4dc>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 821530c:	d0a07a17 	ldw	r2,-32280(gp)
 8215310:	e17ffc17 	ldw	r5,-16(fp)
 8215314:	1009883a 	mov	r4,r2
 8215318:	8215f880 	call	8215f88 <OS_EventTaskRemoveMulti>
             break;
 821531c:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
 8215320:	d0a07a17 	ldw	r2,-32280(gp)
 8215324:	10800c43 	ldbu	r2,49(r2)
 8215328:	10803fcc 	andi	r2,r2,255
 821532c:	10000326 	beq	r2,zero,821533c <OSEventPendMulti+0x4f8>
 8215330:	108000a0 	cmpeqi	r2,r2,2
 8215334:	1000231e 	bne	r2,zero,82153c4 <OSEventPendMulti+0x580>
 8215338:	00002a06 	br	82153e4 <OSEventPendMulti+0x5a0>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
 821533c:	e0bff017 	ldw	r2,-64(fp)
 8215340:	10800003 	ldbu	r2,0(r2)
 8215344:	10803fcc 	andi	r2,r2,255
 8215348:	0080100e 	bge	zero,r2,821538c <OSEventPendMulti+0x548>
 821534c:	10c000d0 	cmplti	r3,r2,3
 8215350:	1800071e 	bne	r3,zero,8215370 <OSEventPendMulti+0x52c>
 8215354:	108000e0 	cmpeqi	r2,r2,3
 8215358:	10000c26 	beq	r2,zero,821538c <OSEventPendMulti+0x548>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
 821535c:	e0bffe17 	ldw	r2,-8(fp)
 8215360:	10c00104 	addi	r3,r2,4
 8215364:	e0fffe15 	stw	r3,-8(fp)
 8215368:	10000015 	stw	zero,0(r2)
                      break;
 821536c:	00001206 	br	82153b8 <OSEventPendMulti+0x574>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
 8215370:	e0bffe17 	ldw	r2,-8(fp)
 8215374:	10c00104 	addi	r3,r2,4
 8215378:	e0fffe15 	stw	r3,-8(fp)
 821537c:	d0e07a17 	ldw	r3,-32280(gp)
 8215380:	18c00917 	ldw	r3,36(r3)
 8215384:	10c00015 	stw	r3,0(r2)
                      break;
 8215388:	00000b06 	br	82153b8 <OSEventPendMulti+0x574>
 821538c:	e0bff317 	ldw	r2,-52(fp)
 8215390:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8215394:	e0bff817 	ldw	r2,-32(fp)
 8215398:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
 821539c:	e0bffd17 	ldw	r2,-12(fp)
 82153a0:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
 82153a4:	e0800217 	ldw	r2,8(fp)
 82153a8:	00c00044 	movi	r3,1
 82153ac:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
 82153b0:	e0bff18b 	ldhu	r2,-58(fp)
 82153b4:	00002206 	br	8215440 <OSEventPendMulti+0x5fc>
             }
            *perr = OS_ERR_NONE;
 82153b8:	e0800217 	ldw	r2,8(fp)
 82153bc:	10000005 	stb	zero,0(r2)
             break;
 82153c0:	00001006 	br	8215404 <OSEventPendMulti+0x5c0>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
 82153c4:	e0bffe17 	ldw	r2,-8(fp)
 82153c8:	10c00104 	addi	r3,r2,4
 82153cc:	e0fffe15 	stw	r3,-8(fp)
 82153d0:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
 82153d4:	e0800217 	ldw	r2,8(fp)
 82153d8:	00c00384 	movi	r3,14
 82153dc:	10c00005 	stb	r3,0(r2)
             break;
 82153e0:	00000806 	br	8215404 <OSEventPendMulti+0x5c0>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
 82153e4:	e0bffe17 	ldw	r2,-8(fp)
 82153e8:	10c00104 	addi	r3,r2,4
 82153ec:	e0fffe15 	stw	r3,-8(fp)
 82153f0:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
 82153f4:	e0800217 	ldw	r2,8(fp)
 82153f8:	00c00284 	movi	r3,10
 82153fc:	10c00005 	stb	r3,0(r2)
             break;
 8215400:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
 8215404:	d0a07a17 	ldw	r2,-32280(gp)
 8215408:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
 821540c:	d0a07a17 	ldw	r2,-32280(gp)
 8215410:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
 8215414:	d0a07a17 	ldw	r2,-32280(gp)
 8215418:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 821541c:	d0a07a17 	ldw	r2,-32280(gp)
 8215420:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
 8215424:	d0a07a17 	ldw	r2,-32280(gp)
 8215428:	10000915 	stw	zero,36(r2)
 821542c:	e0bff317 	ldw	r2,-52(fp)
 8215430:	e0bffa15 	stw	r2,-24(fp)
 8215434:	e0bffa17 	ldw	r2,-24(fp)
 8215438:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
 821543c:	e0bff18b 	ldhu	r2,-58(fp)
}
 8215440:	e037883a 	mov	sp,fp
 8215444:	dfc00117 	ldw	ra,4(sp)
 8215448:	df000017 	ldw	fp,0(sp)
 821544c:	dec00204 	addi	sp,sp,8
 8215450:	f800283a 	ret

08215454 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
 8215454:	defffe04 	addi	sp,sp,-8
 8215458:	dfc00115 	stw	ra,4(sp)
 821545c:	df000015 	stw	fp,0(sp)
 8215460:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
 8215464:	823cf940 	call	823cf94 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
 8215468:	82161d00 	call	82161d0 <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
 821546c:	82162180 	call	8216218 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
 8215470:	82163840 	call	8216384 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
 8215474:	82160f00 	call	82160f0 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
 8215478:	821823c0 	call	821823c <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
 821547c:	8218b3c0 	call	8218b3c <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
 8215480:	8219c640 	call	8219c64 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
 8215484:	82162840 	call	8216284 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
 8215488:	82163040 	call	8216304 <OS_InitTaskStat>

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
 821548c:	823cfb40 	call	823cfb4 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
 8215490:	8216c100 	call	8216c10 <OSDebugInit>
#endif
}
 8215494:	0001883a 	nop
 8215498:	e037883a 	mov	sp,fp
 821549c:	dfc00117 	ldw	ra,4(sp)
 82154a0:	df000017 	ldw	fp,0(sp)
 82154a4:	dec00204 	addi	sp,sp,8
 82154a8:	f800283a 	ret

082154ac <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
 82154ac:	deffff04 	addi	sp,sp,-4
 82154b0:	df000015 	stw	fp,0(sp)
 82154b4:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
 82154b8:	d0a06b43 	ldbu	r2,-32339(gp)
 82154bc:	10803fcc 	andi	r2,r2,255
 82154c0:	10800058 	cmpnei	r2,r2,1
 82154c4:	1000071e 	bne	r2,zero,82154e4 <OSIntEnter+0x38>
        if (OSIntNesting < 255u) {
 82154c8:	d0a07903 	ldbu	r2,-32284(gp)
 82154cc:	10803fcc 	andi	r2,r2,255
 82154d0:	10803fe0 	cmpeqi	r2,r2,255
 82154d4:	1000031e 	bne	r2,zero,82154e4 <OSIntEnter+0x38>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
 82154d8:	d0a07903 	ldbu	r2,-32284(gp)
 82154dc:	10800044 	addi	r2,r2,1
 82154e0:	d0a07905 	stb	r2,-32284(gp)
        }
    }
}
 82154e4:	0001883a 	nop
 82154e8:	e037883a 	mov	sp,fp
 82154ec:	df000017 	ldw	fp,0(sp)
 82154f0:	dec00104 	addi	sp,sp,4
 82154f4:	f800283a 	ret

082154f8 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
 82154f8:	defffb04 	addi	sp,sp,-20
 82154fc:	dfc00415 	stw	ra,16(sp)
 8215500:	df000315 	stw	fp,12(sp)
 8215504:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 8215508:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
 821550c:	d0a06b43 	ldbu	r2,-32339(gp)
 8215510:	10803fcc 	andi	r2,r2,255
 8215514:	10800058 	cmpnei	r2,r2,1
 8215518:	10002f1e 	bne	r2,zero,82155d8 <OSIntExit+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821551c:	0005303a 	rdctl	r2,status
 8215520:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8215524:	e0ffff17 	ldw	r3,-4(fp)
 8215528:	00bfff84 	movi	r2,-2
 821552c:	1884703a 	and	r2,r3,r2
 8215530:	1001703a 	wrctl	status,r2
  
  return context;
 8215534:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
 8215538:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
 821553c:	d0a07903 	ldbu	r2,-32284(gp)
 8215540:	10803fcc 	andi	r2,r2,255
 8215544:	10000326 	beq	r2,zero,8215554 <OSIntExit+0x5c>
            OSIntNesting--;
 8215548:	d0a07903 	ldbu	r2,-32284(gp)
 821554c:	10bfffc4 	addi	r2,r2,-1
 8215550:	d0a07905 	stb	r2,-32284(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
 8215554:	d0a07903 	ldbu	r2,-32284(gp)
 8215558:	10803fcc 	andi	r2,r2,255
 821555c:	10001a1e 	bne	r2,zero,82155c8 <OSIntExit+0xd0>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
 8215560:	d0a06b03 	ldbu	r2,-32340(gp)
 8215564:	10803fcc 	andi	r2,r2,255
 8215568:	1000171e 	bne	r2,zero,82155c8 <OSIntExit+0xd0>
                OS_SchedNew();
 821556c:	82165f40 	call	82165f4 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
 8215570:	d0e06d03 	ldbu	r3,-32332(gp)
 8215574:	d0a06d43 	ldbu	r2,-32331(gp)
 8215578:	18c03fcc 	andi	r3,r3,255
 821557c:	10803fcc 	andi	r2,r2,255
 8215580:	18801126 	beq	r3,r2,82155c8 <OSIntExit+0xd0>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
 8215584:	d0a06d03 	ldbu	r2,-32332(gp)
 8215588:	10c03fcc 	andi	r3,r2,255
 821558c:	008209b4 	movhi	r2,2086
 8215590:	10b6a904 	addi	r2,r2,-9564
 8215594:	18c7883a 	add	r3,r3,r3
 8215598:	18c7883a 	add	r3,r3,r3
 821559c:	10c5883a 	add	r2,r2,r3
 82155a0:	10800017 	ldw	r2,0(r2)
 82155a4:	d0a07515 	stw	r2,-32300(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
 82155a8:	d0a07517 	ldw	r2,-32300(gp)
 82155ac:	10c00e17 	ldw	r3,56(r2)
 82155b0:	18c00044 	addi	r3,r3,1
 82155b4:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
 82155b8:	d0a07017 	ldw	r2,-32320(gp)
 82155bc:	10800044 	addi	r2,r2,1
 82155c0:	d0a07015 	stw	r2,-32320(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
 82155c4:	823ccb40 	call	823ccb4 <OSCtxSw>
 82155c8:	e0bffd17 	ldw	r2,-12(fp)
 82155cc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82155d0:	e0bffe17 	ldw	r2,-8(fp)
 82155d4:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 82155d8:	0001883a 	nop
 82155dc:	e037883a 	mov	sp,fp
 82155e0:	dfc00117 	ldw	ra,4(sp)
 82155e4:	df000017 	ldw	fp,0(sp)
 82155e8:	dec00204 	addi	sp,sp,8
 82155ec:	f800283a 	ret

082155f0 <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
 82155f0:	defffc04 	addi	sp,sp,-16
 82155f4:	df000315 	stw	fp,12(sp)
 82155f8:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82155fc:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
 8215600:	d0a06b43 	ldbu	r2,-32339(gp)
 8215604:	10803fcc 	andi	r2,r2,255
 8215608:	10800058 	cmpnei	r2,r2,1
 821560c:	1000161e 	bne	r2,zero,8215668 <OSSchedLock+0x78>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8215610:	0005303a 	rdctl	r2,status
 8215614:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8215618:	e0ffff17 	ldw	r3,-4(fp)
 821561c:	00bfff84 	movi	r2,-2
 8215620:	1884703a 	and	r2,r3,r2
 8215624:	1001703a 	wrctl	status,r2
  
  return context;
 8215628:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
 821562c:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
 8215630:	d0a07903 	ldbu	r2,-32284(gp)
 8215634:	10803fcc 	andi	r2,r2,255
 8215638:	1000071e 	bne	r2,zero,8215658 <OSSchedLock+0x68>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
 821563c:	d0a06b03 	ldbu	r2,-32340(gp)
 8215640:	10803fcc 	andi	r2,r2,255
 8215644:	10803fe0 	cmpeqi	r2,r2,255
 8215648:	1000031e 	bne	r2,zero,8215658 <OSSchedLock+0x68>
                OSLockNesting++;                 /* Increment lock nesting level                       */
 821564c:	d0a06b03 	ldbu	r2,-32340(gp)
 8215650:	10800044 	addi	r2,r2,1
 8215654:	d0a06b05 	stb	r2,-32340(gp)
 8215658:	e0bffd17 	ldw	r2,-12(fp)
 821565c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8215660:	e0bffe17 	ldw	r2,-8(fp)
 8215664:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 8215668:	0001883a 	nop
 821566c:	e037883a 	mov	sp,fp
 8215670:	df000017 	ldw	fp,0(sp)
 8215674:	dec00104 	addi	sp,sp,4
 8215678:	f800283a 	ret

0821567c <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
 821567c:	defff804 	addi	sp,sp,-32
 8215680:	dfc00715 	stw	ra,28(sp)
 8215684:	df000615 	stw	fp,24(sp)
 8215688:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 821568c:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
 8215690:	d0a06b43 	ldbu	r2,-32339(gp)
 8215694:	10803fcc 	andi	r2,r2,255
 8215698:	10800058 	cmpnei	r2,r2,1
 821569c:	1000281e 	bne	r2,zero,8215740 <OSSchedUnlock+0xc4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82156a0:	0005303a 	rdctl	r2,status
 82156a4:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82156a8:	e0ffff17 	ldw	r3,-4(fp)
 82156ac:	00bfff84 	movi	r2,-2
 82156b0:	1884703a 	and	r2,r3,r2
 82156b4:	1001703a 	wrctl	status,r2
  
  return context;
 82156b8:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
 82156bc:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
 82156c0:	d0a06b03 	ldbu	r2,-32340(gp)
 82156c4:	10803fcc 	andi	r2,r2,255
 82156c8:	10001926 	beq	r2,zero,8215730 <OSSchedUnlock+0xb4>
            OSLockNesting--;                               /* Decrement lock nesting level             */
 82156cc:	d0a06b03 	ldbu	r2,-32340(gp)
 82156d0:	10bfffc4 	addi	r2,r2,-1
 82156d4:	d0a06b05 	stb	r2,-32340(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
 82156d8:	d0a06b03 	ldbu	r2,-32340(gp)
 82156dc:	10803fcc 	andi	r2,r2,255
 82156e0:	10000e1e 	bne	r2,zero,821571c <OSSchedUnlock+0xa0>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
 82156e4:	d0a07903 	ldbu	r2,-32284(gp)
 82156e8:	10803fcc 	andi	r2,r2,255
 82156ec:	1000061e 	bne	r2,zero,8215708 <OSSchedUnlock+0x8c>
 82156f0:	e0bffa17 	ldw	r2,-24(fp)
 82156f4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82156f8:	e0bffb17 	ldw	r2,-20(fp)
 82156fc:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
 8215700:	82165240 	call	8216524 <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
 8215704:	00000e06 	br	8215740 <OSSchedUnlock+0xc4>
 8215708:	e0bffa17 	ldw	r2,-24(fp)
 821570c:	e0bffc15 	stw	r2,-16(fp)
 8215710:	e0bffc17 	ldw	r2,-16(fp)
 8215714:	1001703a 	wrctl	status,r2
 8215718:	00000906 	br	8215740 <OSSchedUnlock+0xc4>
 821571c:	e0bffa17 	ldw	r2,-24(fp)
 8215720:	e0bffd15 	stw	r2,-12(fp)
 8215724:	e0bffd17 	ldw	r2,-12(fp)
 8215728:	1001703a 	wrctl	status,r2
 821572c:	00000406 	br	8215740 <OSSchedUnlock+0xc4>
 8215730:	e0bffa17 	ldw	r2,-24(fp)
 8215734:	e0bffe15 	stw	r2,-8(fp)
 8215738:	e0bffe17 	ldw	r2,-8(fp)
 821573c:	1001703a 	wrctl	status,r2
 8215740:	0001883a 	nop
 8215744:	e037883a 	mov	sp,fp
 8215748:	dfc00117 	ldw	ra,4(sp)
 821574c:	df000017 	ldw	fp,0(sp)
 8215750:	dec00204 	addi	sp,sp,8
 8215754:	f800283a 	ret

08215758 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
 8215758:	defffe04 	addi	sp,sp,-8
 821575c:	dfc00115 	stw	ra,4(sp)
 8215760:	df000015 	stw	fp,0(sp)
 8215764:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
 8215768:	d0a06b43 	ldbu	r2,-32339(gp)
 821576c:	10803fcc 	andi	r2,r2,255
 8215770:	10000f1e 	bne	r2,zero,82157b0 <OSStart+0x58>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
 8215774:	82165f40 	call	82165f4 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
 8215778:	d0a06d03 	ldbu	r2,-32332(gp)
 821577c:	d0a06d45 	stb	r2,-32331(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
 8215780:	d0a06d03 	ldbu	r2,-32332(gp)
 8215784:	10c03fcc 	andi	r3,r2,255
 8215788:	008209b4 	movhi	r2,2086
 821578c:	10b6a904 	addi	r2,r2,-9564
 8215790:	18c7883a 	add	r3,r3,r3
 8215794:	18c7883a 	add	r3,r3,r3
 8215798:	10c5883a 	add	r2,r2,r3
 821579c:	10800017 	ldw	r2,0(r2)
 82157a0:	d0a07515 	stw	r2,-32300(gp)
        OSTCBCur      = OSTCBHighRdy;
 82157a4:	d0a07517 	ldw	r2,-32300(gp)
 82157a8:	d0a07a15 	stw	r2,-32280(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
 82157ac:	823cd400 	call	823cd40 <OSStartHighRdy>
    }
}
 82157b0:	0001883a 	nop
 82157b4:	e037883a 	mov	sp,fp
 82157b8:	dfc00117 	ldw	ra,4(sp)
 82157bc:	df000017 	ldw	fp,0(sp)
 82157c0:	dec00204 	addi	sp,sp,8
 82157c4:	f800283a 	ret

082157c8 <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
 82157c8:	defff904 	addi	sp,sp,-28
 82157cc:	dfc00615 	stw	ra,24(sp)
 82157d0:	df000515 	stw	fp,20(sp)
 82157d4:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82157d8:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
 82157dc:	01000084 	movi	r4,2
 82157e0:	821bed80 	call	821bed8 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82157e4:	0005303a 	rdctl	r2,status
 82157e8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82157ec:	e0fffc17 	ldw	r3,-16(fp)
 82157f0:	00bfff84 	movi	r2,-2
 82157f4:	1884703a 	and	r2,r3,r2
 82157f8:	1001703a 	wrctl	status,r2
  
  return context;
 82157fc:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
 8215800:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
 8215804:	d0206c15 	stw	zero,-32336(gp)
 8215808:	e0bffb17 	ldw	r2,-20(fp)
 821580c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8215810:	e0bffd17 	ldw	r2,-12(fp)
 8215814:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
 8215818:	01000284 	movi	r4,10
 821581c:	821bed80 	call	821bed8 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8215820:	0005303a 	rdctl	r2,status
 8215824:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8215828:	e0fffe17 	ldw	r3,-8(fp)
 821582c:	00bfff84 	movi	r2,-2
 8215830:	1884703a 	and	r2,r3,r2
 8215834:	1001703a 	wrctl	status,r2
  
  return context;
 8215838:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
 821583c:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
 8215840:	d0a06c17 	ldw	r2,-32336(gp)
 8215844:	d0a07115 	stw	r2,-32316(gp)
    OSStatRdy    = OS_TRUE;
 8215848:	00800044 	movi	r2,1
 821584c:	d0a07d05 	stb	r2,-32268(gp)
 8215850:	e0bffb17 	ldw	r2,-20(fp)
 8215854:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8215858:	e0bfff17 	ldw	r2,-4(fp)
 821585c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 8215860:	0001883a 	nop
 8215864:	e037883a 	mov	sp,fp
 8215868:	dfc00117 	ldw	ra,4(sp)
 821586c:	df000017 	ldw	fp,0(sp)
 8215870:	dec00204 	addi	sp,sp,8
 8215874:	f800283a 	ret

08215878 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
 8215878:	defff704 	addi	sp,sp,-36
 821587c:	dfc00815 	stw	ra,32(sp)
 8215880:	df000715 	stw	fp,28(sp)
 8215884:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 8215888:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
 821588c:	823cf680 	call	823cf68 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8215890:	0005303a 	rdctl	r2,status
 8215894:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8215898:	e0fffd17 	ldw	r3,-12(fp)
 821589c:	00bfff84 	movi	r2,-2
 82158a0:	1884703a 	and	r2,r3,r2
 82158a4:	1001703a 	wrctl	status,r2
  
  return context;
 82158a8:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
 82158ac:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
 82158b0:	d0a07b17 	ldw	r2,-32276(gp)
 82158b4:	10800044 	addi	r2,r2,1
 82158b8:	d0a07b15 	stw	r2,-32276(gp)
 82158bc:	e0bffb17 	ldw	r2,-20(fp)
 82158c0:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82158c4:	e0bfff17 	ldw	r2,-4(fp)
 82158c8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
 82158cc:	d0a06b43 	ldbu	r2,-32339(gp)
 82158d0:	10803fcc 	andi	r2,r2,255
 82158d4:	10800058 	cmpnei	r2,r2,1
 82158d8:	10006a1e 	bne	r2,zero,8215a84 <OSTimeTick+0x20c>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
 82158dc:	d0a06f03 	ldbu	r2,-32324(gp)
 82158e0:	10803fcc 	andi	r2,r2,255
 82158e4:	10c00060 	cmpeqi	r3,r2,1
 82158e8:	1800061e 	bne	r3,zero,8215904 <OSTimeTick+0x8c>
 82158ec:	10c000a0 	cmpeqi	r3,r2,2
 82158f0:	1800061e 	bne	r3,zero,821590c <OSTimeTick+0x94>
 82158f4:	10000a1e 	bne	r2,zero,8215920 <OSTimeTick+0xa8>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
 82158f8:	00800044 	movi	r2,1
 82158fc:	e0bffa05 	stb	r2,-24(fp)
                 break;
 8215900:	00000b06 	br	8215930 <OSTimeTick+0xb8>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
 8215904:	e03ffa05 	stb	zero,-24(fp)
                 break;
 8215908:	00000906 	br	8215930 <OSTimeTick+0xb8>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
 821590c:	00800044 	movi	r2,1
 8215910:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
 8215914:	00800044 	movi	r2,1
 8215918:	d0a06f05 	stb	r2,-32324(gp)
                 break;
 821591c:	00000406 	br	8215930 <OSTimeTick+0xb8>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
 8215920:	00800044 	movi	r2,1
 8215924:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
 8215928:	d0206f05 	stb	zero,-32324(gp)
                 break;
 821592c:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
 8215930:	e0bffa03 	ldbu	r2,-24(fp)
 8215934:	10005226 	beq	r2,zero,8215a80 <OSTimeTick+0x208>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
 8215938:	d0a06e17 	ldw	r2,-32328(gp)
 821593c:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 8215940:	00004906 	br	8215a68 <OSTimeTick+0x1f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8215944:	0005303a 	rdctl	r2,status
 8215948:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821594c:	e0fffc17 	ldw	r3,-16(fp)
 8215950:	00bfff84 	movi	r2,-2
 8215954:	1884703a 	and	r2,r3,r2
 8215958:	1001703a 	wrctl	status,r2
  
  return context;
 821595c:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
 8215960:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
 8215964:	e0bff917 	ldw	r2,-28(fp)
 8215968:	10800b8b 	ldhu	r2,46(r2)
 821596c:	10bfffcc 	andi	r2,r2,65535
 8215970:	10003626 	beq	r2,zero,8215a4c <OSTimeTick+0x1d4>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
 8215974:	e0bff917 	ldw	r2,-28(fp)
 8215978:	10800b8b 	ldhu	r2,46(r2)
 821597c:	10bfffc4 	addi	r2,r2,-1
 8215980:	1007883a 	mov	r3,r2
 8215984:	e0bff917 	ldw	r2,-28(fp)
 8215988:	10c00b8d 	sth	r3,46(r2)
 821598c:	e0bff917 	ldw	r2,-28(fp)
 8215990:	10800b8b 	ldhu	r2,46(r2)
 8215994:	10bfffcc 	andi	r2,r2,65535
 8215998:	10002c1e 	bne	r2,zero,8215a4c <OSTimeTick+0x1d4>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 821599c:	e0bff917 	ldw	r2,-28(fp)
 82159a0:	10800c03 	ldbu	r2,48(r2)
 82159a4:	10803fcc 	andi	r2,r2,255
 82159a8:	10800dcc 	andi	r2,r2,55
 82159ac:	10000b26 	beq	r2,zero,82159dc <OSTimeTick+0x164>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
 82159b0:	e0bff917 	ldw	r2,-28(fp)
 82159b4:	10c00c03 	ldbu	r3,48(r2)
 82159b8:	00bff204 	movi	r2,-56
 82159bc:	1884703a 	and	r2,r3,r2
 82159c0:	1007883a 	mov	r3,r2
 82159c4:	e0bff917 	ldw	r2,-28(fp)
 82159c8:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
 82159cc:	e0bff917 	ldw	r2,-28(fp)
 82159d0:	00c00044 	movi	r3,1
 82159d4:	10c00c45 	stb	r3,49(r2)
 82159d8:	00000206 	br	82159e4 <OSTimeTick+0x16c>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 82159dc:	e0bff917 	ldw	r2,-28(fp)
 82159e0:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
 82159e4:	e0bff917 	ldw	r2,-28(fp)
 82159e8:	10800c03 	ldbu	r2,48(r2)
 82159ec:	10803fcc 	andi	r2,r2,255
 82159f0:	1080020c 	andi	r2,r2,8
 82159f4:	1000151e 	bne	r2,zero,8215a4c <OSTimeTick+0x1d4>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
 82159f8:	e0bff917 	ldw	r2,-28(fp)
 82159fc:	10c00d83 	ldbu	r3,54(r2)
 8215a00:	d0a07703 	ldbu	r2,-32292(gp)
 8215a04:	1884b03a 	or	r2,r3,r2
 8215a08:	d0a07705 	stb	r2,-32292(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 8215a0c:	e0bff917 	ldw	r2,-28(fp)
 8215a10:	10800d03 	ldbu	r2,52(r2)
 8215a14:	10c03fcc 	andi	r3,r2,255
 8215a18:	e0bff917 	ldw	r2,-28(fp)
 8215a1c:	10800d03 	ldbu	r2,52(r2)
 8215a20:	11003fcc 	andi	r4,r2,255
 8215a24:	d0a07744 	addi	r2,gp,-32291
 8215a28:	2085883a 	add	r2,r4,r2
 8215a2c:	11000003 	ldbu	r4,0(r2)
 8215a30:	e0bff917 	ldw	r2,-28(fp)
 8215a34:	10800d43 	ldbu	r2,53(r2)
 8215a38:	2084b03a 	or	r2,r4,r2
 8215a3c:	1009883a 	mov	r4,r2
 8215a40:	d0a07744 	addi	r2,gp,-32291
 8215a44:	1885883a 	add	r2,r3,r2
 8215a48:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
 8215a4c:	e0bff917 	ldw	r2,-28(fp)
 8215a50:	10800517 	ldw	r2,20(r2)
 8215a54:	e0bff915 	stw	r2,-28(fp)
 8215a58:	e0bffb17 	ldw	r2,-20(fp)
 8215a5c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8215a60:	e0bffe17 	ldw	r2,-8(fp)
 8215a64:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 8215a68:	e0bff917 	ldw	r2,-28(fp)
 8215a6c:	10800c83 	ldbu	r2,50(r2)
 8215a70:	10803fcc 	andi	r2,r2,255
 8215a74:	10800518 	cmpnei	r2,r2,20
 8215a78:	103fb21e 	bne	r2,zero,8215944 <OSTimeTick+0xcc>
 8215a7c:	00000106 	br	8215a84 <OSTimeTick+0x20c>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
 8215a80:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
 8215a84:	e037883a 	mov	sp,fp
 8215a88:	dfc00117 	ldw	ra,4(sp)
 8215a8c:	df000017 	ldw	fp,0(sp)
 8215a90:	dec00204 	addi	sp,sp,8
 8215a94:	f800283a 	ret

08215a98 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
 8215a98:	deffff04 	addi	sp,sp,-4
 8215a9c:	df000015 	stw	fp,0(sp)
 8215aa0:	d839883a 	mov	fp,sp
    return (OS_VERSION);
 8215aa4:	00804784 	movi	r2,286
}
 8215aa8:	e037883a 	mov	sp,fp
 8215aac:	df000017 	ldw	fp,0(sp)
 8215ab0:	dec00104 	addi	sp,sp,4
 8215ab4:	f800283a 	ret

08215ab8 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
 8215ab8:	deffff04 	addi	sp,sp,-4
 8215abc:	df000015 	stw	fp,0(sp)
 8215ac0:	d839883a 	mov	fp,sp
}
 8215ac4:	0001883a 	nop
 8215ac8:	e037883a 	mov	sp,fp
 8215acc:	df000017 	ldw	fp,0(sp)
 8215ad0:	dec00104 	addi	sp,sp,4
 8215ad4:	f800283a 	ret

08215ad8 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
 8215ad8:	defff804 	addi	sp,sp,-32
 8215adc:	dfc00715 	stw	ra,28(sp)
 8215ae0:	df000615 	stw	fp,24(sp)
 8215ae4:	df000604 	addi	fp,sp,24
 8215ae8:	e13ffc15 	stw	r4,-16(fp)
 8215aec:	e17ffd15 	stw	r5,-12(fp)
 8215af0:	3007883a 	mov	r3,r6
 8215af4:	3805883a 	mov	r2,r7
 8215af8:	e0fffe05 	stb	r3,-8(fp)
 8215afc:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
 8215b00:	e0bffc17 	ldw	r2,-16(fp)
 8215b04:	10800283 	ldbu	r2,10(r2)
 8215b08:	10c03fcc 	andi	r3,r2,255
 8215b0c:	00820974 	movhi	r2,2085
 8215b10:	10b78004 	addi	r2,r2,-8704
 8215b14:	10c5883a 	add	r2,r2,r3
 8215b18:	10800003 	ldbu	r2,0(r2)
 8215b1c:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
 8215b20:	e0bffa03 	ldbu	r2,-24(fp)
 8215b24:	e0fffc17 	ldw	r3,-16(fp)
 8215b28:	1885883a 	add	r2,r3,r2
 8215b2c:	108002c4 	addi	r2,r2,11
 8215b30:	10800003 	ldbu	r2,0(r2)
 8215b34:	10c03fcc 	andi	r3,r2,255
 8215b38:	00820974 	movhi	r2,2085
 8215b3c:	10b78004 	addi	r2,r2,-8704
 8215b40:	10c5883a 	add	r2,r2,r3
 8215b44:	10800003 	ldbu	r2,0(r2)
 8215b48:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
 8215b4c:	e0bffa03 	ldbu	r2,-24(fp)
 8215b50:	100490fa 	slli	r2,r2,3
 8215b54:	1007883a 	mov	r3,r2
 8215b58:	e0bffa43 	ldbu	r2,-23(fp)
 8215b5c:	1885883a 	add	r2,r3,r2
 8215b60:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
 8215b64:	e0fffa83 	ldbu	r3,-22(fp)
 8215b68:	008209b4 	movhi	r2,2086
 8215b6c:	10b6a904 	addi	r2,r2,-9564
 8215b70:	18c7883a 	add	r3,r3,r3
 8215b74:	18c7883a 	add	r3,r3,r3
 8215b78:	10c5883a 	add	r2,r2,r3
 8215b7c:	10800017 	ldw	r2,0(r2)
 8215b80:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
 8215b84:	e0bffb17 	ldw	r2,-20(fp)
 8215b88:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
 8215b8c:	e0bffb17 	ldw	r2,-20(fp)
 8215b90:	e0fffd17 	ldw	r3,-12(fp)
 8215b94:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
 8215b98:	e0bffb17 	ldw	r2,-20(fp)
 8215b9c:	10800c03 	ldbu	r2,48(r2)
 8215ba0:	1007883a 	mov	r3,r2
 8215ba4:	e0bffe03 	ldbu	r2,-8(fp)
 8215ba8:	0084303a 	nor	r2,zero,r2
 8215bac:	1884703a 	and	r2,r3,r2
 8215bb0:	1007883a 	mov	r3,r2
 8215bb4:	e0bffb17 	ldw	r2,-20(fp)
 8215bb8:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
 8215bbc:	e0bffb17 	ldw	r2,-20(fp)
 8215bc0:	e0ffff03 	ldbu	r3,-4(fp)
 8215bc4:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
 8215bc8:	e0bffb17 	ldw	r2,-20(fp)
 8215bcc:	10800c03 	ldbu	r2,48(r2)
 8215bd0:	10803fcc 	andi	r2,r2,255
 8215bd4:	1080020c 	andi	r2,r2,8
 8215bd8:	1000111e 	bne	r2,zero,8215c20 <OS_EventTaskRdy+0x148>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
 8215bdc:	e0bffb17 	ldw	r2,-20(fp)
 8215be0:	10c00d83 	ldbu	r3,54(r2)
 8215be4:	d0a07703 	ldbu	r2,-32292(gp)
 8215be8:	1884b03a 	or	r2,r3,r2
 8215bec:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
 8215bf0:	e0fffa03 	ldbu	r3,-24(fp)
 8215bf4:	e13ffa03 	ldbu	r4,-24(fp)
 8215bf8:	d0a07744 	addi	r2,gp,-32291
 8215bfc:	2085883a 	add	r2,r4,r2
 8215c00:	11000003 	ldbu	r4,0(r2)
 8215c04:	e0bffb17 	ldw	r2,-20(fp)
 8215c08:	10800d43 	ldbu	r2,53(r2)
 8215c0c:	2084b03a 	or	r2,r4,r2
 8215c10:	1009883a 	mov	r4,r2
 8215c14:	d0a07744 	addi	r2,gp,-32291
 8215c18:	1885883a 	add	r2,r3,r2
 8215c1c:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
 8215c20:	e17ffc17 	ldw	r5,-16(fp)
 8215c24:	e13ffb17 	ldw	r4,-20(fp)
 8215c28:	8215ed00 	call	8215ed0 <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
 8215c2c:	e0bffb17 	ldw	r2,-20(fp)
 8215c30:	10800817 	ldw	r2,32(r2)
 8215c34:	10000826 	beq	r2,zero,8215c58 <OS_EventTaskRdy+0x180>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 8215c38:	e0bffb17 	ldw	r2,-20(fp)
 8215c3c:	10800817 	ldw	r2,32(r2)
 8215c40:	100b883a 	mov	r5,r2
 8215c44:	e13ffb17 	ldw	r4,-20(fp)
 8215c48:	8215f880 	call	8215f88 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
 8215c4c:	e0bffb17 	ldw	r2,-20(fp)
 8215c50:	e0fffc17 	ldw	r3,-16(fp)
 8215c54:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
 8215c58:	e0bffa83 	ldbu	r2,-22(fp)
}
 8215c5c:	e037883a 	mov	sp,fp
 8215c60:	dfc00117 	ldw	ra,4(sp)
 8215c64:	df000017 	ldw	fp,0(sp)
 8215c68:	dec00204 	addi	sp,sp,8
 8215c6c:	f800283a 	ret

08215c70 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
 8215c70:	defffd04 	addi	sp,sp,-12
 8215c74:	df000215 	stw	fp,8(sp)
 8215c78:	df000204 	addi	fp,sp,8
 8215c7c:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
 8215c80:	d0a07a17 	ldw	r2,-32280(gp)
 8215c84:	e0ffff17 	ldw	r3,-4(fp)
 8215c88:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
 8215c8c:	d0a07a17 	ldw	r2,-32280(gp)
 8215c90:	10800d03 	ldbu	r2,52(r2)
 8215c94:	10803fcc 	andi	r2,r2,255
 8215c98:	d0e07a17 	ldw	r3,-32280(gp)
 8215c9c:	18c00d03 	ldbu	r3,52(r3)
 8215ca0:	18c03fcc 	andi	r3,r3,255
 8215ca4:	e13fff17 	ldw	r4,-4(fp)
 8215ca8:	20c7883a 	add	r3,r4,r3
 8215cac:	18c002c4 	addi	r3,r3,11
 8215cb0:	19000003 	ldbu	r4,0(r3)
 8215cb4:	d0e07a17 	ldw	r3,-32280(gp)
 8215cb8:	18c00d43 	ldbu	r3,53(r3)
 8215cbc:	20c6b03a 	or	r3,r4,r3
 8215cc0:	1809883a 	mov	r4,r3
 8215cc4:	e0ffff17 	ldw	r3,-4(fp)
 8215cc8:	1885883a 	add	r2,r3,r2
 8215ccc:	108002c4 	addi	r2,r2,11
 8215cd0:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 8215cd4:	e0bfff17 	ldw	r2,-4(fp)
 8215cd8:	10c00283 	ldbu	r3,10(r2)
 8215cdc:	d0a07a17 	ldw	r2,-32280(gp)
 8215ce0:	10800d83 	ldbu	r2,54(r2)
 8215ce4:	1884b03a 	or	r2,r3,r2
 8215ce8:	1007883a 	mov	r3,r2
 8215cec:	e0bfff17 	ldw	r2,-4(fp)
 8215cf0:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 8215cf4:	d0a07a17 	ldw	r2,-32280(gp)
 8215cf8:	10800d03 	ldbu	r2,52(r2)
 8215cfc:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 8215d00:	e0fffe03 	ldbu	r3,-8(fp)
 8215d04:	e13ffe03 	ldbu	r4,-8(fp)
 8215d08:	d0a07744 	addi	r2,gp,-32291
 8215d0c:	2085883a 	add	r2,r4,r2
 8215d10:	10800003 	ldbu	r2,0(r2)
 8215d14:	1009883a 	mov	r4,r2
 8215d18:	d0a07a17 	ldw	r2,-32280(gp)
 8215d1c:	10800d43 	ldbu	r2,53(r2)
 8215d20:	0084303a 	nor	r2,zero,r2
 8215d24:	2084703a 	and	r2,r4,r2
 8215d28:	1009883a 	mov	r4,r2
 8215d2c:	d0a07744 	addi	r2,gp,-32291
 8215d30:	1885883a 	add	r2,r3,r2
 8215d34:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
 8215d38:	e0fffe03 	ldbu	r3,-8(fp)
 8215d3c:	d0a07744 	addi	r2,gp,-32291
 8215d40:	1885883a 	add	r2,r3,r2
 8215d44:	10800003 	ldbu	r2,0(r2)
 8215d48:	10803fcc 	andi	r2,r2,255
 8215d4c:	1000071e 	bne	r2,zero,8215d6c <OS_EventTaskWait+0xfc>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 8215d50:	d0a07a17 	ldw	r2,-32280(gp)
 8215d54:	10800d83 	ldbu	r2,54(r2)
 8215d58:	0084303a 	nor	r2,zero,r2
 8215d5c:	1007883a 	mov	r3,r2
 8215d60:	d0a07703 	ldbu	r2,-32292(gp)
 8215d64:	1884703a 	and	r2,r3,r2
 8215d68:	d0a07705 	stb	r2,-32292(gp)
    }
}
 8215d6c:	0001883a 	nop
 8215d70:	e037883a 	mov	sp,fp
 8215d74:	df000017 	ldw	fp,0(sp)
 8215d78:	dec00104 	addi	sp,sp,4
 8215d7c:	f800283a 	ret

08215d80 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
 8215d80:	defffb04 	addi	sp,sp,-20
 8215d84:	df000415 	stw	fp,16(sp)
 8215d88:	df000404 	addi	fp,sp,16
 8215d8c:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
 8215d90:	d0a07a17 	ldw	r2,-32280(gp)
 8215d94:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
 8215d98:	d0a07a17 	ldw	r2,-32280(gp)
 8215d9c:	e0ffff17 	ldw	r3,-4(fp)
 8215da0:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
 8215da4:	e0bfff17 	ldw	r2,-4(fp)
 8215da8:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
 8215dac:	e0bffc17 	ldw	r2,-16(fp)
 8215db0:	10800017 	ldw	r2,0(r2)
 8215db4:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 8215db8:	00002006 	br	8215e3c <OS_EventTaskWaitMulti+0xbc>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
 8215dbc:	d0a07a17 	ldw	r2,-32280(gp)
 8215dc0:	10800d03 	ldbu	r2,52(r2)
 8215dc4:	10803fcc 	andi	r2,r2,255
 8215dc8:	d0e07a17 	ldw	r3,-32280(gp)
 8215dcc:	18c00d03 	ldbu	r3,52(r3)
 8215dd0:	18c03fcc 	andi	r3,r3,255
 8215dd4:	e13ffd17 	ldw	r4,-12(fp)
 8215dd8:	20c7883a 	add	r3,r4,r3
 8215ddc:	18c002c4 	addi	r3,r3,11
 8215de0:	19000003 	ldbu	r4,0(r3)
 8215de4:	d0e07a17 	ldw	r3,-32280(gp)
 8215de8:	18c00d43 	ldbu	r3,53(r3)
 8215dec:	20c6b03a 	or	r3,r4,r3
 8215df0:	1809883a 	mov	r4,r3
 8215df4:	e0fffd17 	ldw	r3,-12(fp)
 8215df8:	1885883a 	add	r2,r3,r2
 8215dfc:	108002c4 	addi	r2,r2,11
 8215e00:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 8215e04:	e0bffd17 	ldw	r2,-12(fp)
 8215e08:	10c00283 	ldbu	r3,10(r2)
 8215e0c:	d0a07a17 	ldw	r2,-32280(gp)
 8215e10:	10800d83 	ldbu	r2,54(r2)
 8215e14:	1884b03a 	or	r2,r3,r2
 8215e18:	1007883a 	mov	r3,r2
 8215e1c:	e0bffd17 	ldw	r2,-12(fp)
 8215e20:	10c00285 	stb	r3,10(r2)
        pevents++;
 8215e24:	e0bffc17 	ldw	r2,-16(fp)
 8215e28:	10800104 	addi	r2,r2,4
 8215e2c:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
 8215e30:	e0bffc17 	ldw	r2,-16(fp)
 8215e34:	10800017 	ldw	r2,0(r2)
 8215e38:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 8215e3c:	e0bffd17 	ldw	r2,-12(fp)
 8215e40:	103fde1e 	bne	r2,zero,8215dbc <OS_EventTaskWaitMulti+0x3c>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 8215e44:	d0a07a17 	ldw	r2,-32280(gp)
 8215e48:	10800d03 	ldbu	r2,52(r2)
 8215e4c:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 8215e50:	e0fffe03 	ldbu	r3,-8(fp)
 8215e54:	e13ffe03 	ldbu	r4,-8(fp)
 8215e58:	d0a07744 	addi	r2,gp,-32291
 8215e5c:	2085883a 	add	r2,r4,r2
 8215e60:	10800003 	ldbu	r2,0(r2)
 8215e64:	1009883a 	mov	r4,r2
 8215e68:	d0a07a17 	ldw	r2,-32280(gp)
 8215e6c:	10800d43 	ldbu	r2,53(r2)
 8215e70:	0084303a 	nor	r2,zero,r2
 8215e74:	2084703a 	and	r2,r4,r2
 8215e78:	1009883a 	mov	r4,r2
 8215e7c:	d0a07744 	addi	r2,gp,-32291
 8215e80:	1885883a 	add	r2,r3,r2
 8215e84:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
 8215e88:	e0fffe03 	ldbu	r3,-8(fp)
 8215e8c:	d0a07744 	addi	r2,gp,-32291
 8215e90:	1885883a 	add	r2,r3,r2
 8215e94:	10800003 	ldbu	r2,0(r2)
 8215e98:	10803fcc 	andi	r2,r2,255
 8215e9c:	1000071e 	bne	r2,zero,8215ebc <OS_EventTaskWaitMulti+0x13c>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 8215ea0:	d0a07a17 	ldw	r2,-32280(gp)
 8215ea4:	10800d83 	ldbu	r2,54(r2)
 8215ea8:	0084303a 	nor	r2,zero,r2
 8215eac:	1007883a 	mov	r3,r2
 8215eb0:	d0a07703 	ldbu	r2,-32292(gp)
 8215eb4:	1884703a 	and	r2,r3,r2
 8215eb8:	d0a07705 	stb	r2,-32292(gp)
    }
}
 8215ebc:	0001883a 	nop
 8215ec0:	e037883a 	mov	sp,fp
 8215ec4:	df000017 	ldw	fp,0(sp)
 8215ec8:	dec00104 	addi	sp,sp,4
 8215ecc:	f800283a 	ret

08215ed0 <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
 8215ed0:	defffc04 	addi	sp,sp,-16
 8215ed4:	df000315 	stw	fp,12(sp)
 8215ed8:	df000304 	addi	fp,sp,12
 8215edc:	e13ffe15 	stw	r4,-8(fp)
 8215ee0:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
 8215ee4:	e0bffe17 	ldw	r2,-8(fp)
 8215ee8:	10800d03 	ldbu	r2,52(r2)
 8215eec:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
 8215ef0:	e0bffd03 	ldbu	r2,-12(fp)
 8215ef4:	e0fffd03 	ldbu	r3,-12(fp)
 8215ef8:	e13fff17 	ldw	r4,-4(fp)
 8215efc:	20c7883a 	add	r3,r4,r3
 8215f00:	18c002c4 	addi	r3,r3,11
 8215f04:	18c00003 	ldbu	r3,0(r3)
 8215f08:	1809883a 	mov	r4,r3
 8215f0c:	e0fffe17 	ldw	r3,-8(fp)
 8215f10:	18c00d43 	ldbu	r3,53(r3)
 8215f14:	00c6303a 	nor	r3,zero,r3
 8215f18:	20c6703a 	and	r3,r4,r3
 8215f1c:	1809883a 	mov	r4,r3
 8215f20:	e0ffff17 	ldw	r3,-4(fp)
 8215f24:	1885883a 	add	r2,r3,r2
 8215f28:	108002c4 	addi	r2,r2,11
 8215f2c:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
 8215f30:	e0bffd03 	ldbu	r2,-12(fp)
 8215f34:	e0ffff17 	ldw	r3,-4(fp)
 8215f38:	1885883a 	add	r2,r3,r2
 8215f3c:	108002c4 	addi	r2,r2,11
 8215f40:	10800003 	ldbu	r2,0(r2)
 8215f44:	10803fcc 	andi	r2,r2,255
 8215f48:	10000a1e 	bne	r2,zero,8215f74 <OS_EventTaskRemove+0xa4>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
 8215f4c:	e0bfff17 	ldw	r2,-4(fp)
 8215f50:	10800283 	ldbu	r2,10(r2)
 8215f54:	1007883a 	mov	r3,r2
 8215f58:	e0bffe17 	ldw	r2,-8(fp)
 8215f5c:	10800d83 	ldbu	r2,54(r2)
 8215f60:	0084303a 	nor	r2,zero,r2
 8215f64:	1884703a 	and	r2,r3,r2
 8215f68:	1007883a 	mov	r3,r2
 8215f6c:	e0bfff17 	ldw	r2,-4(fp)
 8215f70:	10c00285 	stb	r3,10(r2)
    }
}
 8215f74:	0001883a 	nop
 8215f78:	e037883a 	mov	sp,fp
 8215f7c:	df000017 	ldw	fp,0(sp)
 8215f80:	dec00104 	addi	sp,sp,4
 8215f84:	f800283a 	ret

08215f88 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
 8215f88:	defffa04 	addi	sp,sp,-24
 8215f8c:	df000515 	stw	fp,20(sp)
 8215f90:	df000504 	addi	fp,sp,20
 8215f94:	e13ffe15 	stw	r4,-8(fp)
 8215f98:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
 8215f9c:	e0bffe17 	ldw	r2,-8(fp)
 8215fa0:	10800d03 	ldbu	r2,52(r2)
 8215fa4:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
 8215fa8:	e0bffe17 	ldw	r2,-8(fp)
 8215fac:	10800d83 	ldbu	r2,54(r2)
 8215fb0:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
 8215fb4:	e0bffe17 	ldw	r2,-8(fp)
 8215fb8:	10800d43 	ldbu	r2,53(r2)
 8215fbc:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
 8215fc0:	e0bfff17 	ldw	r2,-4(fp)
 8215fc4:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
 8215fc8:	e0bffb17 	ldw	r2,-20(fp)
 8215fcc:	10800017 	ldw	r2,0(r2)
 8215fd0:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 8215fd4:	00002506 	br	821606c <OS_EventTaskRemoveMulti+0xe4>
        pevent->OSEventTbl[y]  &= ~bitx;
 8215fd8:	e0bffd03 	ldbu	r2,-12(fp)
 8215fdc:	e0fffd03 	ldbu	r3,-12(fp)
 8215fe0:	e13ffc17 	ldw	r4,-16(fp)
 8215fe4:	20c7883a 	add	r3,r4,r3
 8215fe8:	18c002c4 	addi	r3,r3,11
 8215fec:	18c00003 	ldbu	r3,0(r3)
 8215ff0:	1809883a 	mov	r4,r3
 8215ff4:	e0fffd83 	ldbu	r3,-10(fp)
 8215ff8:	00c6303a 	nor	r3,zero,r3
 8215ffc:	20c6703a 	and	r3,r4,r3
 8216000:	1809883a 	mov	r4,r3
 8216004:	e0fffc17 	ldw	r3,-16(fp)
 8216008:	1885883a 	add	r2,r3,r2
 821600c:	108002c4 	addi	r2,r2,11
 8216010:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
 8216014:	e0bffd03 	ldbu	r2,-12(fp)
 8216018:	e0fffc17 	ldw	r3,-16(fp)
 821601c:	1885883a 	add	r2,r3,r2
 8216020:	108002c4 	addi	r2,r2,11
 8216024:	10800003 	ldbu	r2,0(r2)
 8216028:	10803fcc 	andi	r2,r2,255
 821602c:	1000091e 	bne	r2,zero,8216054 <OS_EventTaskRemoveMulti+0xcc>
            pevent->OSEventGrp &= ~bity;
 8216030:	e0bffc17 	ldw	r2,-16(fp)
 8216034:	10800283 	ldbu	r2,10(r2)
 8216038:	1007883a 	mov	r3,r2
 821603c:	e0bffd43 	ldbu	r2,-11(fp)
 8216040:	0084303a 	nor	r2,zero,r2
 8216044:	1884703a 	and	r2,r3,r2
 8216048:	1007883a 	mov	r3,r2
 821604c:	e0bffc17 	ldw	r2,-16(fp)
 8216050:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
 8216054:	e0bffb17 	ldw	r2,-20(fp)
 8216058:	10800104 	addi	r2,r2,4
 821605c:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
 8216060:	e0bffb17 	ldw	r2,-20(fp)
 8216064:	10800017 	ldw	r2,0(r2)
 8216068:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 821606c:	e0bffc17 	ldw	r2,-16(fp)
 8216070:	103fd91e 	bne	r2,zero,8215fd8 <OS_EventTaskRemoveMulti+0x50>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
 8216074:	0001883a 	nop
 8216078:	e037883a 	mov	sp,fp
 821607c:	df000017 	ldw	fp,0(sp)
 8216080:	dec00104 	addi	sp,sp,4
 8216084:	f800283a 	ret

08216088 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
 8216088:	defffc04 	addi	sp,sp,-16
 821608c:	df000315 	stw	fp,12(sp)
 8216090:	df000304 	addi	fp,sp,12
 8216094:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
 8216098:	e0bfff17 	ldw	r2,-4(fp)
 821609c:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
 82160a0:	e0bfff17 	ldw	r2,-4(fp)
 82160a4:	108002c4 	addi	r2,r2,11
 82160a8:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 82160ac:	e03ffe05 	stb	zero,-8(fp)
 82160b0:	00000706 	br	82160d0 <OS_EventWaitListInit+0x48>
        *ptbl++ = 0;
 82160b4:	e0bffd17 	ldw	r2,-12(fp)
 82160b8:	10c00044 	addi	r3,r2,1
 82160bc:	e0fffd15 	stw	r3,-12(fp)
 82160c0:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 82160c4:	e0bffe03 	ldbu	r2,-8(fp)
 82160c8:	10800044 	addi	r2,r2,1
 82160cc:	e0bffe05 	stb	r2,-8(fp)
 82160d0:	e0bffe03 	ldbu	r2,-8(fp)
 82160d4:	108000f0 	cmpltui	r2,r2,3
 82160d8:	103ff61e 	bne	r2,zero,82160b4 <OS_EventWaitListInit+0x2c>
        *ptbl++ = 0;
    }
}
 82160dc:	0001883a 	nop
 82160e0:	e037883a 	mov	sp,fp
 82160e4:	df000017 	ldw	fp,0(sp)
 82160e8:	dec00104 	addi	sp,sp,4
 82160ec:	f800283a 	ret

082160f0 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
 82160f0:	defffb04 	addi	sp,sp,-20
 82160f4:	dfc00415 	stw	ra,16(sp)
 82160f8:	df000315 	stw	fp,12(sp)
 82160fc:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
 8216100:	0142d004 	movi	r5,2880
 8216104:	010209b4 	movhi	r4,2086
 8216108:	21329504 	addi	r4,r4,-13740
 821610c:	82164680 	call	8216468 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
 8216110:	008209b4 	movhi	r2,2086
 8216114:	10b29504 	addi	r2,r2,-13740
 8216118:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
 821611c:	008209b4 	movhi	r2,2086
 8216120:	10b2a104 	addi	r2,r2,-13692
 8216124:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 8216128:	e03ffd0d 	sth	zero,-12(fp)
 821612c:	00001306 	br	821617c <OS_InitEventList+0x8c>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
 8216130:	e0bffe17 	ldw	r2,-8(fp)
 8216134:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
 8216138:	e0bffe17 	ldw	r2,-8(fp)
 821613c:	e0ffff17 	ldw	r3,-4(fp)
 8216140:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
 8216144:	e0bffe17 	ldw	r2,-8(fp)
 8216148:	00c00fc4 	movi	r3,63
 821614c:	10c00385 	stb	r3,14(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
 8216150:	e0bffe17 	ldw	r2,-8(fp)
 8216154:	100003c5 	stb	zero,15(r2)
#endif
        pevent1++;
 8216158:	e0bffe17 	ldw	r2,-8(fp)
 821615c:	10800c04 	addi	r2,r2,48
 8216160:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
 8216164:	e0bfff17 	ldw	r2,-4(fp)
 8216168:	10800c04 	addi	r2,r2,48
 821616c:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 8216170:	e0bffd0b 	ldhu	r2,-12(fp)
 8216174:	10800044 	addi	r2,r2,1
 8216178:	e0bffd0d 	sth	r2,-12(fp)
 821617c:	e0bffd0b 	ldhu	r2,-12(fp)
 8216180:	10800ef0 	cmpltui	r2,r2,59
 8216184:	103fea1e 	bne	r2,zero,8216130 <OS_InitEventList+0x40>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
 8216188:	e0bffe17 	ldw	r2,-8(fp)
 821618c:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
 8216190:	e0bffe17 	ldw	r2,-8(fp)
 8216194:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
 8216198:	e0bffe17 	ldw	r2,-8(fp)
 821619c:	00c00fc4 	movi	r3,63
 82161a0:	10c00385 	stb	r3,14(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
 82161a4:	e0bffe17 	ldw	r2,-8(fp)
 82161a8:	100003c5 	stb	zero,15(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
 82161ac:	008209b4 	movhi	r2,2086
 82161b0:	10b29504 	addi	r2,r2,-13740
 82161b4:	d0a07815 	stw	r2,-32288(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
 82161b8:	0001883a 	nop
 82161bc:	e037883a 	mov	sp,fp
 82161c0:	dfc00117 	ldw	ra,4(sp)
 82161c4:	df000017 	ldw	fp,0(sp)
 82161c8:	dec00204 	addi	sp,sp,8
 82161cc:	f800283a 	ret

082161d0 <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
 82161d0:	deffff04 	addi	sp,sp,-4
 82161d4:	df000015 	stw	fp,0(sp)
 82161d8:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
 82161dc:	d0207b15 	stw	zero,-32276(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
 82161e0:	d0207905 	stb	zero,-32284(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
 82161e4:	d0206b05 	stb	zero,-32340(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
 82161e8:	d0207345 	stb	zero,-32307(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
 82161ec:	d0206b45 	stb	zero,-32339(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
 82161f0:	d0207015 	stw	zero,-32320(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
 82161f4:	d0206c15 	stw	zero,-32336(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
 82161f8:	d0207e15 	stw	zero,-32264(gp)
    OSIdleCtrMax  = 0L;
 82161fc:	d0207115 	stw	zero,-32316(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
 8216200:	d0207d05 	stb	zero,-32268(gp)
#endif
}
 8216204:	0001883a 	nop
 8216208:	e037883a 	mov	sp,fp
 821620c:	df000017 	ldw	fp,0(sp)
 8216210:	dec00104 	addi	sp,sp,4
 8216214:	f800283a 	ret

08216218 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
 8216218:	defffd04 	addi	sp,sp,-12
 821621c:	df000215 	stw	fp,8(sp)
 8216220:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
 8216224:	d0207705 	stb	zero,-32292(gp)
    prdytbl       = &OSRdyTbl[0];
 8216228:	d0a07744 	addi	r2,gp,-32291
 821622c:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 8216230:	e03ffe05 	stb	zero,-8(fp)
 8216234:	00000706 	br	8216254 <OS_InitRdyList+0x3c>
        *prdytbl++ = 0;
 8216238:	e0bfff17 	ldw	r2,-4(fp)
 821623c:	10c00044 	addi	r3,r2,1
 8216240:	e0ffff15 	stw	r3,-4(fp)
 8216244:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 8216248:	e0bffe03 	ldbu	r2,-8(fp)
 821624c:	10800044 	addi	r2,r2,1
 8216250:	e0bffe05 	stb	r2,-8(fp)
 8216254:	e0bffe03 	ldbu	r2,-8(fp)
 8216258:	108000f0 	cmpltui	r2,r2,3
 821625c:	103ff61e 	bne	r2,zero,8216238 <OS_InitRdyList+0x20>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
 8216260:	d0206d45 	stb	zero,-32331(gp)
    OSPrioHighRdy = 0;
 8216264:	d0206d05 	stb	zero,-32332(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
 8216268:	d0207515 	stw	zero,-32300(gp)
    OSTCBCur      = (OS_TCB *)0;
 821626c:	d0207a15 	stw	zero,-32280(gp)
}
 8216270:	0001883a 	nop
 8216274:	e037883a 	mov	sp,fp
 8216278:	df000017 	ldw	fp,0(sp)
 821627c:	dec00104 	addi	sp,sp,4
 8216280:	f800283a 	ret

08216284 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
 8216284:	defff804 	addi	sp,sp,-32
 8216288:	dfc00715 	stw	ra,28(sp)
 821628c:	df000615 	stw	fp,24(sp)
 8216290:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
 8216294:	008000c4 	movi	r2,3
 8216298:	d8800415 	stw	r2,16(sp)
 821629c:	d8000315 	stw	zero,12(sp)
 82162a0:	00808004 	movi	r2,512
 82162a4:	d8800215 	stw	r2,8(sp)
 82162a8:	008209b4 	movhi	r2,2086
 82162ac:	10b09504 	addi	r2,r2,-15788
 82162b0:	d8800115 	stw	r2,4(sp)
 82162b4:	00bfffd4 	movui	r2,65535
 82162b8:	d8800015 	stw	r2,0(sp)
 82162bc:	01c00504 	movi	r7,20
 82162c0:	018209b4 	movhi	r6,2086
 82162c4:	31b29404 	addi	r6,r6,-13744
 82162c8:	000b883a 	mov	r5,zero
 82162cc:	01020874 	movhi	r4,2081
 82162d0:	2119cc04 	addi	r4,r4,26416
 82162d4:	821ae080 	call	821ae08 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
 82162d8:	e1bfff04 	addi	r6,fp,-4
 82162dc:	01420974 	movhi	r5,2085
 82162e0:	2977c004 	addi	r5,r5,-8448
 82162e4:	01000504 	movi	r4,20
 82162e8:	821b6180 	call	821b618 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
 82162ec:	0001883a 	nop
 82162f0:	e037883a 	mov	sp,fp
 82162f4:	dfc00117 	ldw	ra,4(sp)
 82162f8:	df000017 	ldw	fp,0(sp)
 82162fc:	dec00204 	addi	sp,sp,8
 8216300:	f800283a 	ret

08216304 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
 8216304:	defff804 	addi	sp,sp,-32
 8216308:	dfc00715 	stw	ra,28(sp)
 821630c:	df000615 	stw	fp,24(sp)
 8216310:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
 8216314:	008000c4 	movi	r2,3
 8216318:	d8800415 	stw	r2,16(sp)
 821631c:	d8000315 	stw	zero,12(sp)
 8216320:	00808004 	movi	r2,512
 8216324:	d8800215 	stw	r2,8(sp)
 8216328:	008209b4 	movhi	r2,2086
 821632c:	10ae1d04 	addi	r2,r2,-18316
 8216330:	d8800115 	stw	r2,4(sp)
 8216334:	00bfff94 	movui	r2,65534
 8216338:	d8800015 	stw	r2,0(sp)
 821633c:	01c004c4 	movi	r7,19
 8216340:	018209b4 	movhi	r6,2086
 8216344:	31b01c04 	addi	r6,r6,-16272
 8216348:	000b883a 	mov	r5,zero
 821634c:	01020874 	movhi	r4,2081
 8216350:	2119e304 	addi	r4,r4,26508
 8216354:	821ae080 	call	821ae08 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
 8216358:	e1bfff04 	addi	r6,fp,-4
 821635c:	01420974 	movhi	r5,2085
 8216360:	2977c404 	addi	r5,r5,-8432
 8216364:	010004c4 	movi	r4,19
 8216368:	821b6180 	call	821b618 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
 821636c:	0001883a 	nop
 8216370:	e037883a 	mov	sp,fp
 8216374:	dfc00117 	ldw	ra,4(sp)
 8216378:	df000017 	ldw	fp,0(sp)
 821637c:	dec00204 	addi	sp,sp,8
 8216380:	f800283a 	ret

08216384 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
 8216384:	defffb04 	addi	sp,sp,-20
 8216388:	dfc00415 	stw	ra,16(sp)
 821638c:	df000315 	stw	fp,12(sp)
 8216390:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
 8216394:	01414404 	movi	r5,1296
 8216398:	010209b4 	movhi	r4,2086
 821639c:	21356504 	addi	r4,r4,-10860
 82163a0:	82164680 	call	8216468 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
 82163a4:	01401504 	movi	r5,84
 82163a8:	010209b4 	movhi	r4,2086
 82163ac:	2136a904 	addi	r4,r4,-9564
 82163b0:	82164680 	call	8216468 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
 82163b4:	008209b4 	movhi	r2,2086
 82163b8:	10b56504 	addi	r2,r2,-10860
 82163bc:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
 82163c0:	008209b4 	movhi	r2,2086
 82163c4:	10b58004 	addi	r2,r2,-10752
 82163c8:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 82163cc:	e03ffd05 	stb	zero,-12(fp)
 82163d0:	00001106 	br	8216418 <OS_InitTCBList+0x94>
        ptcb1->OSTCBNext = ptcb2;
 82163d4:	e0bffe17 	ldw	r2,-8(fp)
 82163d8:	e0ffff17 	ldw	r3,-4(fp)
 82163dc:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
 82163e0:	e0bffe17 	ldw	r2,-8(fp)
 82163e4:	00c00fc4 	movi	r3,63
 82163e8:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 82163ec:	e0bffe17 	ldw	r2,-8(fp)
 82163f0:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
 82163f4:	e0bffe17 	ldw	r2,-8(fp)
 82163f8:	10801b04 	addi	r2,r2,108
 82163fc:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
 8216400:	e0bfff17 	ldw	r2,-4(fp)
 8216404:	10801b04 	addi	r2,r2,108
 8216408:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 821640c:	e0bffd03 	ldbu	r2,-12(fp)
 8216410:	10800044 	addi	r2,r2,1
 8216414:	e0bffd05 	stb	r2,-12(fp)
 8216418:	e0bffd03 	ldbu	r2,-12(fp)
 821641c:	108002f0 	cmpltui	r2,r2,11
 8216420:	103fec1e 	bne	r2,zero,82163d4 <OS_InitTCBList+0x50>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
 8216424:	e0bffe17 	ldw	r2,-8(fp)
 8216428:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
 821642c:	e0bffe17 	ldw	r2,-8(fp)
 8216430:	00c00fc4 	movi	r3,63
 8216434:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 8216438:	e0bffe17 	ldw	r2,-8(fp)
 821643c:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
 8216440:	d0206e15 	stw	zero,-32328(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
 8216444:	008209b4 	movhi	r2,2086
 8216448:	10b56504 	addi	r2,r2,-10860
 821644c:	d0a07215 	stw	r2,-32312(gp)
}
 8216450:	0001883a 	nop
 8216454:	e037883a 	mov	sp,fp
 8216458:	dfc00117 	ldw	ra,4(sp)
 821645c:	df000017 	ldw	fp,0(sp)
 8216460:	dec00204 	addi	sp,sp,8
 8216464:	f800283a 	ret

08216468 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
 8216468:	defffd04 	addi	sp,sp,-12
 821646c:	df000215 	stw	fp,8(sp)
 8216470:	df000204 	addi	fp,sp,8
 8216474:	e13ffe15 	stw	r4,-8(fp)
 8216478:	2805883a 	mov	r2,r5
 821647c:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
 8216480:	00000706 	br	82164a0 <OS_MemClr+0x38>
        *pdest++ = (INT8U)0;
 8216484:	e0bffe17 	ldw	r2,-8(fp)
 8216488:	10c00044 	addi	r3,r2,1
 821648c:	e0fffe15 	stw	r3,-8(fp)
 8216490:	10000005 	stb	zero,0(r2)
        size--;
 8216494:	e0bfff0b 	ldhu	r2,-4(fp)
 8216498:	10bfffc4 	addi	r2,r2,-1
 821649c:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
 82164a0:	e0bfff0b 	ldhu	r2,-4(fp)
 82164a4:	103ff71e 	bne	r2,zero,8216484 <OS_MemClr+0x1c>
        *pdest++ = (INT8U)0;
        size--;
    }
}
 82164a8:	0001883a 	nop
 82164ac:	e037883a 	mov	sp,fp
 82164b0:	df000017 	ldw	fp,0(sp)
 82164b4:	dec00104 	addi	sp,sp,4
 82164b8:	f800283a 	ret

082164bc <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
 82164bc:	defffc04 	addi	sp,sp,-16
 82164c0:	df000315 	stw	fp,12(sp)
 82164c4:	df000304 	addi	fp,sp,12
 82164c8:	e13ffd15 	stw	r4,-12(fp)
 82164cc:	e17ffe15 	stw	r5,-8(fp)
 82164d0:	3005883a 	mov	r2,r6
 82164d4:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
 82164d8:	00000b06 	br	8216508 <OS_MemCopy+0x4c>
        *pdest++ = *psrc++;
 82164dc:	e0bffd17 	ldw	r2,-12(fp)
 82164e0:	10c00044 	addi	r3,r2,1
 82164e4:	e0fffd15 	stw	r3,-12(fp)
 82164e8:	e0fffe17 	ldw	r3,-8(fp)
 82164ec:	19000044 	addi	r4,r3,1
 82164f0:	e13ffe15 	stw	r4,-8(fp)
 82164f4:	18c00003 	ldbu	r3,0(r3)
 82164f8:	10c00005 	stb	r3,0(r2)
        size--;
 82164fc:	e0bfff0b 	ldhu	r2,-4(fp)
 8216500:	10bfffc4 	addi	r2,r2,-1
 8216504:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
 8216508:	e0bfff0b 	ldhu	r2,-4(fp)
 821650c:	103ff31e 	bne	r2,zero,82164dc <OS_MemCopy+0x20>
        *pdest++ = *psrc++;
        size--;
    }
}
 8216510:	0001883a 	nop
 8216514:	e037883a 	mov	sp,fp
 8216518:	df000017 	ldw	fp,0(sp)
 821651c:	dec00104 	addi	sp,sp,4
 8216520:	f800283a 	ret

08216524 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
 8216524:	defffb04 	addi	sp,sp,-20
 8216528:	dfc00415 	stw	ra,16(sp)
 821652c:	df000315 	stw	fp,12(sp)
 8216530:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 8216534:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8216538:	0005303a 	rdctl	r2,status
 821653c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8216540:	e0ffff17 	ldw	r3,-4(fp)
 8216544:	00bfff84 	movi	r2,-2
 8216548:	1884703a 	and	r2,r3,r2
 821654c:	1001703a 	wrctl	status,r2
  
  return context;
 8216550:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
 8216554:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
 8216558:	d0a07903 	ldbu	r2,-32284(gp)
 821655c:	10803fcc 	andi	r2,r2,255
 8216560:	10001a1e 	bne	r2,zero,82165cc <OS_Sched+0xa8>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
 8216564:	d0a06b03 	ldbu	r2,-32340(gp)
 8216568:	10803fcc 	andi	r2,r2,255
 821656c:	1000171e 	bne	r2,zero,82165cc <OS_Sched+0xa8>
            OS_SchedNew();
 8216570:	82165f40 	call	82165f4 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
 8216574:	d0e06d03 	ldbu	r3,-32332(gp)
 8216578:	d0a06d43 	ldbu	r2,-32331(gp)
 821657c:	18c03fcc 	andi	r3,r3,255
 8216580:	10803fcc 	andi	r2,r2,255
 8216584:	18801126 	beq	r3,r2,82165cc <OS_Sched+0xa8>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
 8216588:	d0a06d03 	ldbu	r2,-32332(gp)
 821658c:	10c03fcc 	andi	r3,r2,255
 8216590:	008209b4 	movhi	r2,2086
 8216594:	10b6a904 	addi	r2,r2,-9564
 8216598:	18c7883a 	add	r3,r3,r3
 821659c:	18c7883a 	add	r3,r3,r3
 82165a0:	10c5883a 	add	r2,r2,r3
 82165a4:	10800017 	ldw	r2,0(r2)
 82165a8:	d0a07515 	stw	r2,-32300(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
 82165ac:	d0a07517 	ldw	r2,-32300(gp)
 82165b0:	10c00e17 	ldw	r3,56(r2)
 82165b4:	18c00044 	addi	r3,r3,1
 82165b8:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
 82165bc:	d0a07017 	ldw	r2,-32320(gp)
 82165c0:	10800044 	addi	r2,r2,1
 82165c4:	d0a07015 	stw	r2,-32320(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
 82165c8:	823ccb40 	call	823ccb4 <OSCtxSw>
 82165cc:	e0bffd17 	ldw	r2,-12(fp)
 82165d0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82165d4:	e0bffe17 	ldw	r2,-8(fp)
 82165d8:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
 82165dc:	0001883a 	nop
 82165e0:	e037883a 	mov	sp,fp
 82165e4:	dfc00117 	ldw	ra,4(sp)
 82165e8:	df000017 	ldw	fp,0(sp)
 82165ec:	dec00204 	addi	sp,sp,8
 82165f0:	f800283a 	ret

082165f4 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
 82165f4:	defffe04 	addi	sp,sp,-8
 82165f8:	df000115 	stw	fp,4(sp)
 82165fc:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
 8216600:	d0a07703 	ldbu	r2,-32292(gp)
 8216604:	10c03fcc 	andi	r3,r2,255
 8216608:	00820974 	movhi	r2,2085
 821660c:	10b78004 	addi	r2,r2,-8704
 8216610:	10c5883a 	add	r2,r2,r3
 8216614:	10800003 	ldbu	r2,0(r2)
 8216618:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
 821661c:	e0bfff03 	ldbu	r2,-4(fp)
 8216620:	100490fa 	slli	r2,r2,3
 8216624:	1009883a 	mov	r4,r2
 8216628:	e0ffff03 	ldbu	r3,-4(fp)
 821662c:	d0a07744 	addi	r2,gp,-32291
 8216630:	1885883a 	add	r2,r3,r2
 8216634:	10800003 	ldbu	r2,0(r2)
 8216638:	10c03fcc 	andi	r3,r2,255
 821663c:	00820974 	movhi	r2,2085
 8216640:	10b78004 	addi	r2,r2,-8704
 8216644:	10c5883a 	add	r2,r2,r3
 8216648:	10800003 	ldbu	r2,0(r2)
 821664c:	2085883a 	add	r2,r4,r2
 8216650:	d0a06d05 	stb	r2,-32332(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
 8216654:	0001883a 	nop
 8216658:	e037883a 	mov	sp,fp
 821665c:	df000017 	ldw	fp,0(sp)
 8216660:	dec00104 	addi	sp,sp,4
 8216664:	f800283a 	ret

08216668 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
 8216668:	defffc04 	addi	sp,sp,-16
 821666c:	df000315 	stw	fp,12(sp)
 8216670:	df000304 	addi	fp,sp,12
 8216674:	e13ffe15 	stw	r4,-8(fp)
 8216678:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
 821667c:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
 8216680:	00000b06 	br	82166b0 <OS_StrCopy+0x48>
        *pdest++ = *psrc++;
 8216684:	e0bffe17 	ldw	r2,-8(fp)
 8216688:	10c00044 	addi	r3,r2,1
 821668c:	e0fffe15 	stw	r3,-8(fp)
 8216690:	e0ffff17 	ldw	r3,-4(fp)
 8216694:	19000044 	addi	r4,r3,1
 8216698:	e13fff15 	stw	r4,-4(fp)
 821669c:	18c00003 	ldbu	r3,0(r3)
 82166a0:	10c00005 	stb	r3,0(r2)
        len++;
 82166a4:	e0bffd03 	ldbu	r2,-12(fp)
 82166a8:	10800044 	addi	r2,r2,1
 82166ac:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 82166b0:	e0bfff17 	ldw	r2,-4(fp)
 82166b4:	10800003 	ldbu	r2,0(r2)
 82166b8:	10803fcc 	andi	r2,r2,255
 82166bc:	103ff11e 	bne	r2,zero,8216684 <OS_StrCopy+0x1c>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
 82166c0:	e0bffe17 	ldw	r2,-8(fp)
 82166c4:	10000005 	stb	zero,0(r2)
    return (len);
 82166c8:	e0bffd03 	ldbu	r2,-12(fp)
}
 82166cc:	e037883a 	mov	sp,fp
 82166d0:	df000017 	ldw	fp,0(sp)
 82166d4:	dec00104 	addi	sp,sp,4
 82166d8:	f800283a 	ret

082166dc <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
 82166dc:	defffd04 	addi	sp,sp,-12
 82166e0:	df000215 	stw	fp,8(sp)
 82166e4:	df000204 	addi	fp,sp,8
 82166e8:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
 82166ec:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
 82166f0:	00000606 	br	821670c <OS_StrLen+0x30>
        psrc++;
 82166f4:	e0bfff17 	ldw	r2,-4(fp)
 82166f8:	10800044 	addi	r2,r2,1
 82166fc:	e0bfff15 	stw	r2,-4(fp)
        len++;
 8216700:	e0bffe03 	ldbu	r2,-8(fp)
 8216704:	10800044 	addi	r2,r2,1
 8216708:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 821670c:	e0bfff17 	ldw	r2,-4(fp)
 8216710:	10800003 	ldbu	r2,0(r2)
 8216714:	10803fcc 	andi	r2,r2,255
 8216718:	103ff61e 	bne	r2,zero,82166f4 <OS_StrLen+0x18>
        psrc++;
        len++;
    }
    return (len);
 821671c:	e0bffe03 	ldbu	r2,-8(fp)
}
 8216720:	e037883a 	mov	sp,fp
 8216724:	df000017 	ldw	fp,0(sp)
 8216728:	dec00104 	addi	sp,sp,4
 821672c:	f800283a 	ret

08216730 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
 8216730:	defffa04 	addi	sp,sp,-24
 8216734:	dfc00515 	stw	ra,20(sp)
 8216738:	df000415 	stw	fp,16(sp)
 821673c:	df000404 	addi	fp,sp,16
 8216740:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8216744:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8216748:	0005303a 	rdctl	r2,status
 821674c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8216750:	e0fffd17 	ldw	r3,-12(fp)
 8216754:	00bfff84 	movi	r2,-2
 8216758:	1884703a 	and	r2,r3,r2
 821675c:	1001703a 	wrctl	status,r2
  
  return context;
 8216760:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
 8216764:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
 8216768:	d0a06c17 	ldw	r2,-32336(gp)
 821676c:	10800044 	addi	r2,r2,1
 8216770:	d0a06c15 	stw	r2,-32336(gp)
 8216774:	e0bffc17 	ldw	r2,-16(fp)
 8216778:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821677c:	e0bffe17 	ldw	r2,-8(fp)
 8216780:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
 8216784:	823cfd40 	call	823cfd4 <OSTaskIdleHook>
    }
 8216788:	003fef06 	br	8216748 <OS_TaskIdle+0x18>

0821678c <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
 821678c:	defff804 	addi	sp,sp,-32
 8216790:	dfc00715 	stw	ra,28(sp)
 8216794:	df000615 	stw	fp,24(sp)
 8216798:	dc400515 	stw	r17,20(sp)
 821679c:	dc000415 	stw	r16,16(sp)
 82167a0:	df000604 	addi	fp,sp,24
 82167a4:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82167a8:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 82167ac:	00000206 	br	82167b8 <OS_TaskStat+0x2c>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
 82167b0:	01000504 	movi	r4,20
 82167b4:	821bed80 	call	821bed8 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 82167b8:	d0a07d03 	ldbu	r2,-32268(gp)
 82167bc:	10803fcc 	andi	r2,r2,255
 82167c0:	103ffb26 	beq	r2,zero,82167b0 <OS_TaskStat+0x24>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
 82167c4:	d0e07117 	ldw	r3,-32316(gp)
 82167c8:	00947b34 	movhi	r2,20972
 82167cc:	10a147c4 	addi	r2,r2,-31457
 82167d0:	1888383a 	mulxuu	r4,r3,r2
 82167d4:	1885383a 	mul	r2,r3,r2
 82167d8:	1021883a 	mov	r16,r2
 82167dc:	2023883a 	mov	r17,r4
 82167e0:	8804d17a 	srli	r2,r17,5
 82167e4:	d0a07115 	stw	r2,-32316(gp)
    if (OSIdleCtrMax == 0L) {
 82167e8:	d0a07117 	ldw	r2,-32316(gp)
 82167ec:	1000031e 	bne	r2,zero,82167fc <OS_TaskStat+0x70>
        OSCPUUsage = 0;
 82167f0:	d0207305 	stb	zero,-32308(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
 82167f4:	01003fc4 	movi	r4,255
 82167f8:	821bb600 	call	821bb60 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82167fc:	0005303a 	rdctl	r2,status
 8216800:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8216804:	e0fffb17 	ldw	r3,-20(fp)
 8216808:	00bfff84 	movi	r2,-2
 821680c:	1884703a 	and	r2,r3,r2
 8216810:	1001703a 	wrctl	status,r2
  
  return context;
 8216814:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
 8216818:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
 821681c:	d0a06c17 	ldw	r2,-32336(gp)
 8216820:	d0a07e15 	stw	r2,-32264(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
 8216824:	d0206c15 	stw	zero,-32336(gp)
 8216828:	e0bffa17 	ldw	r2,-24(fp)
 821682c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8216830:	e0bffc17 	ldw	r2,-16(fp)
 8216834:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
 8216838:	d0a07e17 	ldw	r2,-32264(gp)
 821683c:	d0e07117 	ldw	r3,-32316(gp)
 8216840:	180b883a 	mov	r5,r3
 8216844:	1009883a 	mov	r4,r2
 8216848:	8202c100 	call	8202c10 <__udivsi3>
 821684c:	1007883a 	mov	r3,r2
 8216850:	00801904 	movi	r2,100
 8216854:	10c5c83a 	sub	r2,r2,r3
 8216858:	d0a07305 	stb	r2,-32308(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
 821685c:	823cf480 	call	823cf48 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
 8216860:	82168700 	call	8216870 <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
 8216864:	01000284 	movi	r4,10
 8216868:	821bed80 	call	821bed8 <OSTimeDly>
    }
 821686c:	003fe306 	br	82167fc <OS_TaskStat+0x70>

08216870 <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
 8216870:	defffa04 	addi	sp,sp,-24
 8216874:	dfc00515 	stw	ra,20(sp)
 8216878:	df000415 	stw	fp,16(sp)
 821687c:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 8216880:	e03ffc05 	stb	zero,-16(fp)
 8216884:	00002406 	br	8216918 <OS_TaskStatStkChk+0xa8>
        err = OSTaskStkChk(prio, &stk_data);
 8216888:	e0bffc03 	ldbu	r2,-16(fp)
 821688c:	e0fffe04 	addi	r3,fp,-8
 8216890:	180b883a 	mov	r5,r3
 8216894:	1009883a 	mov	r4,r2
 8216898:	821b9a00 	call	821b9a0 <OSTaskStkChk>
 821689c:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
 82168a0:	e0bffc43 	ldbu	r2,-15(fp)
 82168a4:	1000191e 	bne	r2,zero,821690c <OS_TaskStatStkChk+0x9c>
            ptcb = OSTCBPrioTbl[prio];
 82168a8:	e0fffc03 	ldbu	r3,-16(fp)
 82168ac:	008209b4 	movhi	r2,2086
 82168b0:	10b6a904 	addi	r2,r2,-9564
 82168b4:	18c7883a 	add	r3,r3,r3
 82168b8:	18c7883a 	add	r3,r3,r3
 82168bc:	10c5883a 	add	r2,r2,r3
 82168c0:	10800017 	ldw	r2,0(r2)
 82168c4:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
 82168c8:	e0bffd17 	ldw	r2,-12(fp)
 82168cc:	10000f26 	beq	r2,zero,821690c <OS_TaskStatStkChk+0x9c>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
 82168d0:	e0bffd17 	ldw	r2,-12(fp)
 82168d4:	10800060 	cmpeqi	r2,r2,1
 82168d8:	10000c1e 	bne	r2,zero,821690c <OS_TaskStatStkChk+0x9c>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
 82168dc:	e0bffd17 	ldw	r2,-12(fp)
 82168e0:	10c00217 	ldw	r3,8(r2)
 82168e4:	e0bffd17 	ldw	r2,-12(fp)
 82168e8:	10800317 	ldw	r2,12(r2)
 82168ec:	1085883a 	add	r2,r2,r2
 82168f0:	1085883a 	add	r2,r2,r2
 82168f4:	1887883a 	add	r3,r3,r2
 82168f8:	e0bffd17 	ldw	r2,-12(fp)
 82168fc:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
 8216900:	e0ffff17 	ldw	r3,-4(fp)
 8216904:	e0bffd17 	ldw	r2,-12(fp)
 8216908:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 821690c:	e0bffc03 	ldbu	r2,-16(fp)
 8216910:	10800044 	addi	r2,r2,1
 8216914:	e0bffc05 	stb	r2,-16(fp)
 8216918:	e0bffc03 	ldbu	r2,-16(fp)
 821691c:	10800570 	cmpltui	r2,r2,21
 8216920:	103fd91e 	bne	r2,zero,8216888 <OS_TaskStatStkChk+0x18>
#endif
                }
            }
        }
    }
}
 8216924:	0001883a 	nop
 8216928:	e037883a 	mov	sp,fp
 821692c:	dfc00117 	ldw	ra,4(sp)
 8216930:	df000017 	ldw	fp,0(sp)
 8216934:	dec00204 	addi	sp,sp,8
 8216938:	f800283a 	ret

0821693c <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
 821693c:	defff204 	addi	sp,sp,-56
 8216940:	dfc00d15 	stw	ra,52(sp)
 8216944:	df000c15 	stw	fp,48(sp)
 8216948:	df000c04 	addi	fp,sp,48
 821694c:	e17ffc15 	stw	r5,-16(fp)
 8216950:	e1bffd15 	stw	r6,-12(fp)
 8216954:	3807883a 	mov	r3,r7
 8216958:	e0800417 	ldw	r2,16(fp)
 821695c:	e13ffb05 	stb	r4,-20(fp)
 8216960:	e0fffe0d 	sth	r3,-8(fp)
 8216964:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 8216968:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821696c:	0005303a 	rdctl	r2,status
 8216970:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8216974:	e0fffa17 	ldw	r3,-24(fp)
 8216978:	00bfff84 	movi	r2,-2
 821697c:	1884703a 	and	r2,r3,r2
 8216980:	1001703a 	wrctl	status,r2
  
  return context;
 8216984:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
 8216988:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
 821698c:	d0a07217 	ldw	r2,-32312(gp)
 8216990:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
 8216994:	e0bff617 	ldw	r2,-40(fp)
 8216998:	10009326 	beq	r2,zero,8216be8 <OS_TCBInit+0x2ac>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
 821699c:	e0bff617 	ldw	r2,-40(fp)
 82169a0:	10800517 	ldw	r2,20(r2)
 82169a4:	d0a07215 	stw	r2,-32312(gp)
 82169a8:	e0bff417 	ldw	r2,-48(fp)
 82169ac:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82169b0:	e0bff817 	ldw	r2,-32(fp)
 82169b4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
 82169b8:	e0bff617 	ldw	r2,-40(fp)
 82169bc:	e0fffc17 	ldw	r3,-16(fp)
 82169c0:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
 82169c4:	e0bff617 	ldw	r2,-40(fp)
 82169c8:	e0fffb03 	ldbu	r3,-20(fp)
 82169cc:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
 82169d0:	e0bff617 	ldw	r2,-40(fp)
 82169d4:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
 82169d8:	e0bff617 	ldw	r2,-40(fp)
 82169dc:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
 82169e0:	e0bff617 	ldw	r2,-40(fp)
 82169e4:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
 82169e8:	e0bff617 	ldw	r2,-40(fp)
 82169ec:	e0c00317 	ldw	r3,12(fp)
 82169f0:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
 82169f4:	e0bff617 	ldw	r2,-40(fp)
 82169f8:	e0c00217 	ldw	r3,8(fp)
 82169fc:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
 8216a00:	e0bff617 	ldw	r2,-40(fp)
 8216a04:	e0fffd17 	ldw	r3,-12(fp)
 8216a08:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
 8216a0c:	e0bff617 	ldw	r2,-40(fp)
 8216a10:	e0ffff0b 	ldhu	r3,-4(fp)
 8216a14:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
 8216a18:	e0bff617 	ldw	r2,-40(fp)
 8216a1c:	e0fffe0b 	ldhu	r3,-8(fp)
 8216a20:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
 8216a24:	e0bff617 	ldw	r2,-40(fp)
 8216a28:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
 8216a2c:	e0bffb03 	ldbu	r2,-20(fp)
 8216a30:	1004d0fa 	srli	r2,r2,3
 8216a34:	1007883a 	mov	r3,r2
 8216a38:	e0bff617 	ldw	r2,-40(fp)
 8216a3c:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
 8216a40:	e0bffb03 	ldbu	r2,-20(fp)
 8216a44:	108001cc 	andi	r2,r2,7
 8216a48:	1007883a 	mov	r3,r2
 8216a4c:	e0bff617 	ldw	r2,-40(fp)
 8216a50:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
 8216a54:	e0bff617 	ldw	r2,-40(fp)
 8216a58:	10800d03 	ldbu	r2,52(r2)
 8216a5c:	10803fcc 	andi	r2,r2,255
 8216a60:	00c00044 	movi	r3,1
 8216a64:	1884983a 	sll	r2,r3,r2
 8216a68:	1007883a 	mov	r3,r2
 8216a6c:	e0bff617 	ldw	r2,-40(fp)
 8216a70:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
 8216a74:	e0bff617 	ldw	r2,-40(fp)
 8216a78:	10800cc3 	ldbu	r2,51(r2)
 8216a7c:	10803fcc 	andi	r2,r2,255
 8216a80:	00c00044 	movi	r3,1
 8216a84:	1884983a 	sll	r2,r3,r2
 8216a88:	1007883a 	mov	r3,r2
 8216a8c:	e0bff617 	ldw	r2,-40(fp)
 8216a90:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
 8216a94:	e0bff617 	ldw	r2,-40(fp)
 8216a98:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
 8216a9c:	e0bff617 	ldw	r2,-40(fp)
 8216aa0:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
 8216aa4:	e0bff617 	ldw	r2,-40(fp)
 8216aa8:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
 8216aac:	e0bff617 	ldw	r2,-40(fp)
 8216ab0:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
 8216ab4:	e0bff617 	ldw	r2,-40(fp)
 8216ab8:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
 8216abc:	e0bff617 	ldw	r2,-40(fp)
 8216ac0:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
 8216ac4:	e0bff617 	ldw	r2,-40(fp)
 8216ac8:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
 8216acc:	e0bff617 	ldw	r2,-40(fp)
 8216ad0:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
 8216ad4:	e0bff617 	ldw	r2,-40(fp)
 8216ad8:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
 8216adc:	e0bff617 	ldw	r2,-40(fp)
 8216ae0:	00c00fc4 	movi	r3,63
 8216ae4:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 8216ae8:	e0bff617 	ldw	r2,-40(fp)
 8216aec:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
 8216af0:	e13ff617 	ldw	r4,-40(fp)
 8216af4:	823cff40 	call	823cff4 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
 8216af8:	e13ff617 	ldw	r4,-40(fp)
 8216afc:	823cee00 	call	823cee0 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8216b00:	0005303a 	rdctl	r2,status
 8216b04:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8216b08:	e0fff517 	ldw	r3,-44(fp)
 8216b0c:	00bfff84 	movi	r2,-2
 8216b10:	1884703a 	and	r2,r3,r2
 8216b14:	1001703a 	wrctl	status,r2
  
  return context;
 8216b18:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
 8216b1c:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
 8216b20:	e0fffb03 	ldbu	r3,-20(fp)
 8216b24:	008209b4 	movhi	r2,2086
 8216b28:	10b6a904 	addi	r2,r2,-9564
 8216b2c:	18c7883a 	add	r3,r3,r3
 8216b30:	18c7883a 	add	r3,r3,r3
 8216b34:	10c5883a 	add	r2,r2,r3
 8216b38:	e0fff617 	ldw	r3,-40(fp)
 8216b3c:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
 8216b40:	d0e06e17 	ldw	r3,-32328(gp)
 8216b44:	e0bff617 	ldw	r2,-40(fp)
 8216b48:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
 8216b4c:	e0bff617 	ldw	r2,-40(fp)
 8216b50:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
 8216b54:	d0a06e17 	ldw	r2,-32328(gp)
 8216b58:	10000326 	beq	r2,zero,8216b68 <OS_TCBInit+0x22c>
            OSTCBList->OSTCBPrev = ptcb;
 8216b5c:	d0a06e17 	ldw	r2,-32328(gp)
 8216b60:	e0fff617 	ldw	r3,-40(fp)
 8216b64:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
 8216b68:	e0bff617 	ldw	r2,-40(fp)
 8216b6c:	d0a06e15 	stw	r2,-32328(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
 8216b70:	e0bff617 	ldw	r2,-40(fp)
 8216b74:	10c00d83 	ldbu	r3,54(r2)
 8216b78:	d0a07703 	ldbu	r2,-32292(gp)
 8216b7c:	1884b03a 	or	r2,r3,r2
 8216b80:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 8216b84:	e0bff617 	ldw	r2,-40(fp)
 8216b88:	10800d03 	ldbu	r2,52(r2)
 8216b8c:	10c03fcc 	andi	r3,r2,255
 8216b90:	e0bff617 	ldw	r2,-40(fp)
 8216b94:	10800d03 	ldbu	r2,52(r2)
 8216b98:	11003fcc 	andi	r4,r2,255
 8216b9c:	d0a07744 	addi	r2,gp,-32291
 8216ba0:	2085883a 	add	r2,r4,r2
 8216ba4:	11000003 	ldbu	r4,0(r2)
 8216ba8:	e0bff617 	ldw	r2,-40(fp)
 8216bac:	10800d43 	ldbu	r2,53(r2)
 8216bb0:	2084b03a 	or	r2,r4,r2
 8216bb4:	1009883a 	mov	r4,r2
 8216bb8:	d0a07744 	addi	r2,gp,-32291
 8216bbc:	1885883a 	add	r2,r3,r2
 8216bc0:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
 8216bc4:	d0a07343 	ldbu	r2,-32307(gp)
 8216bc8:	10800044 	addi	r2,r2,1
 8216bcc:	d0a07345 	stb	r2,-32307(gp)
 8216bd0:	e0bff417 	ldw	r2,-48(fp)
 8216bd4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8216bd8:	e0bff717 	ldw	r2,-36(fp)
 8216bdc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 8216be0:	0005883a 	mov	r2,zero
 8216be4:	00000506 	br	8216bfc <OS_TCBInit+0x2c0>
 8216be8:	e0bff417 	ldw	r2,-48(fp)
 8216bec:	e0bff915 	stw	r2,-28(fp)
 8216bf0:	e0bff917 	ldw	r2,-28(fp)
 8216bf4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
 8216bf8:	00801084 	movi	r2,66
}
 8216bfc:	e037883a 	mov	sp,fp
 8216c00:	dfc00117 	ldw	ra,4(sp)
 8216c04:	df000017 	ldw	fp,0(sp)
 8216c08:	dec00204 	addi	sp,sp,8
 8216c0c:	f800283a 	ret

08216c10 <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
 8216c10:	defffe04 	addi	sp,sp,-8
 8216c14:	df000115 	stw	fp,4(sp)
 8216c18:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
 8216c1c:	d0a00c04 	addi	r2,gp,-32720
 8216c20:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
 8216c24:	d0a00d04 	addi	r2,gp,-32716
 8216c28:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
 8216c2c:	d0a00e84 	addi	r2,gp,-32710
 8216c30:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
 8216c34:	d0a00f04 	addi	r2,gp,-32708
 8216c38:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
 8216c3c:	d0a00e04 	addi	r2,gp,-32712
 8216c40:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
 8216c44:	d0a00f84 	addi	r2,gp,-32706
 8216c48:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
 8216c4c:	d0a01004 	addi	r2,gp,-32704
 8216c50:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
 8216c54:	d0a01084 	addi	r2,gp,-32702
 8216c58:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
 8216c5c:	d0a01104 	addi	r2,gp,-32700
 8216c60:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
 8216c64:	d0a01184 	addi	r2,gp,-32698
 8216c68:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
 8216c6c:	d0a01204 	addi	r2,gp,-32696
 8216c70:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
 8216c74:	d0a01284 	addi	r2,gp,-32694
 8216c78:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
 8216c7c:	d0a01304 	addi	r2,gp,-32692
 8216c80:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
 8216c84:	d0a01384 	addi	r2,gp,-32690
 8216c88:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
 8216c8c:	d0a01404 	addi	r2,gp,-32688
 8216c90:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
 8216c94:	d0a01484 	addi	r2,gp,-32686
 8216c98:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
 8216c9c:	d0a01504 	addi	r2,gp,-32684
 8216ca0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
 8216ca4:	d0a01584 	addi	r2,gp,-32682
 8216ca8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
 8216cac:	d0a01604 	addi	r2,gp,-32680
 8216cb0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
 8216cb4:	d0a01684 	addi	r2,gp,-32678
 8216cb8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
 8216cbc:	d0a01704 	addi	r2,gp,-32676
 8216cc0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
 8216cc4:	d0a01784 	addi	r2,gp,-32674
 8216cc8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
 8216ccc:	d0a01804 	addi	r2,gp,-32672
 8216cd0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
 8216cd4:	d0a01884 	addi	r2,gp,-32670
 8216cd8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
 8216cdc:	d0a01904 	addi	r2,gp,-32668
 8216ce0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
 8216ce4:	d0a01984 	addi	r2,gp,-32666
 8216ce8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
 8216cec:	d0a01a04 	addi	r2,gp,-32664
 8216cf0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
 8216cf4:	d0a01a84 	addi	r2,gp,-32662
 8216cf8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
 8216cfc:	d0a01b04 	addi	r2,gp,-32660
 8216d00:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
 8216d04:	d0a01b84 	addi	r2,gp,-32658
 8216d08:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
 8216d0c:	d0a01c04 	addi	r2,gp,-32656
 8216d10:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
 8216d14:	d0a01c84 	addi	r2,gp,-32654
 8216d18:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
 8216d1c:	d0a01d04 	addi	r2,gp,-32652
 8216d20:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
 8216d24:	d0a01d84 	addi	r2,gp,-32650
 8216d28:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
 8216d2c:	d0a01e04 	addi	r2,gp,-32648
 8216d30:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
 8216d34:	d0a01e84 	addi	r2,gp,-32646
 8216d38:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
 8216d3c:	d0a01f04 	addi	r2,gp,-32644
 8216d40:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
 8216d44:	d0a01f84 	addi	r2,gp,-32642
 8216d48:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
 8216d4c:	d0a02004 	addi	r2,gp,-32640
 8216d50:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
 8216d54:	d0a02084 	addi	r2,gp,-32638
 8216d58:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
 8216d5c:	d0a02104 	addi	r2,gp,-32636
 8216d60:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
 8216d64:	d0a02184 	addi	r2,gp,-32634
 8216d68:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
 8216d6c:	d0a02204 	addi	r2,gp,-32632
 8216d70:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
 8216d74:	d0a02284 	addi	r2,gp,-32630
 8216d78:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
    ptemp = (void *)&OSTmrWheelTblSize;
#endif

    ptemp = (void *)&OSVersionNbr;
 8216d7c:	d0a02304 	addi	r2,gp,-32628
 8216d80:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
 8216d84:	d0a02804 	addi	r2,gp,-32608
 8216d88:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
 8216d8c:	0001883a 	nop
 8216d90:	e037883a 	mov	sp,fp
 8216d94:	df000017 	ldw	fp,0(sp)
 8216d98:	dec00104 	addi	sp,sp,4
 8216d9c:	f800283a 	ret

08216da0 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
 8216da0:	defff204 	addi	sp,sp,-56
 8216da4:	df000d15 	stw	fp,52(sp)
 8216da8:	df000d04 	addi	fp,sp,52
 8216dac:	e13ffc15 	stw	r4,-16(fp)
 8216db0:	2807883a 	mov	r3,r5
 8216db4:	3005883a 	mov	r2,r6
 8216db8:	e1ffff15 	stw	r7,-4(fp)
 8216dbc:	e0fffd0d 	sth	r3,-12(fp)
 8216dc0:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 8216dc4:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 8216dc8:	e0bfff17 	ldw	r2,-4(fp)
 8216dcc:	1000021e 	bne	r2,zero,8216dd8 <OSFlagAccept+0x38>
        return ((OS_FLAGS)0);
 8216dd0:	0005883a 	mov	r2,zero
 8216dd4:	0000b006 	br	8217098 <OSFlagAccept+0x2f8>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 8216dd8:	e0bffc17 	ldw	r2,-16(fp)
 8216ddc:	1000051e 	bne	r2,zero,8216df4 <OSFlagAccept+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8216de0:	e0bfff17 	ldw	r2,-4(fp)
 8216de4:	00c01b84 	movi	r3,110
 8216de8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8216dec:	0005883a 	mov	r2,zero
 8216df0:	0000a906 	br	8217098 <OSFlagAccept+0x2f8>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 8216df4:	e0bffc17 	ldw	r2,-16(fp)
 8216df8:	10800003 	ldbu	r2,0(r2)
 8216dfc:	10803fcc 	andi	r2,r2,255
 8216e00:	10800160 	cmpeqi	r2,r2,5
 8216e04:	1000051e 	bne	r2,zero,8216e1c <OSFlagAccept+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 8216e08:	e0bfff17 	ldw	r2,-4(fp)
 8216e0c:	00c00044 	movi	r3,1
 8216e10:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8216e14:	0005883a 	mov	r2,zero
 8216e18:	00009f06 	br	8217098 <OSFlagAccept+0x2f8>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 8216e1c:	e0fffe03 	ldbu	r3,-8(fp)
 8216e20:	00bfe004 	movi	r2,-128
 8216e24:	1884703a 	and	r2,r3,r2
 8216e28:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
 8216e2c:	e0bff503 	ldbu	r2,-44(fp)
 8216e30:	10000626 	beq	r2,zero,8216e4c <OSFlagAccept+0xac>
        wait_type &= ~OS_FLAG_CONSUME;
 8216e34:	e0bffe03 	ldbu	r2,-8(fp)
 8216e38:	10801fcc 	andi	r2,r2,127
 8216e3c:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
 8216e40:	00800044 	movi	r2,1
 8216e44:	e0bff385 	stb	r2,-50(fp)
 8216e48:	00000106 	br	8216e50 <OSFlagAccept+0xb0>
    } else {
        consume    = OS_FALSE;
 8216e4c:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
 8216e50:	e0bfff17 	ldw	r2,-4(fp)
 8216e54:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8216e58:	0005303a 	rdctl	r2,status
 8216e5c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8216e60:	e0fffb17 	ldw	r3,-20(fp)
 8216e64:	00bfff84 	movi	r2,-2
 8216e68:	1884703a 	and	r2,r3,r2
 8216e6c:	1001703a 	wrctl	status,r2
  
  return context;
 8216e70:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
 8216e74:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
 8216e78:	e0bffe03 	ldbu	r2,-8(fp)
 8216e7c:	10c00060 	cmpeqi	r3,r2,1
 8216e80:	18005f1e 	bne	r3,zero,8217000 <OSFlagAccept+0x260>
 8216e84:	10c00088 	cmpgei	r3,r2,2
 8216e88:	1800021e 	bne	r3,zero,8216e94 <OSFlagAccept+0xf4>
 8216e8c:	10003f26 	beq	r2,zero,8216f8c <OSFlagAccept+0x1ec>
 8216e90:	00007706 	br	8217070 <OSFlagAccept+0x2d0>
 8216e94:	10c000a0 	cmpeqi	r3,r2,2
 8216e98:	1800031e 	bne	r3,zero,8216ea8 <OSFlagAccept+0x108>
 8216e9c:	108000e0 	cmpeqi	r2,r2,3
 8216ea0:	10001e1e 	bne	r2,zero,8216f1c <OSFlagAccept+0x17c>
 8216ea4:	00007206 	br	8217070 <OSFlagAccept+0x2d0>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 8216ea8:	e0bffc17 	ldw	r2,-16(fp)
 8216eac:	10c0020b 	ldhu	r3,8(r2)
 8216eb0:	e0bffd0b 	ldhu	r2,-12(fp)
 8216eb4:	1884703a 	and	r2,r3,r2
 8216eb8:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 8216ebc:	e0fff30b 	ldhu	r3,-52(fp)
 8216ec0:	e0bffd0b 	ldhu	r2,-12(fp)
 8216ec4:	18800d1e 	bne	r3,r2,8216efc <OSFlagAccept+0x15c>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8216ec8:	e0bff383 	ldbu	r2,-50(fp)
 8216ecc:	10800058 	cmpnei	r2,r2,1
 8216ed0:	10000d1e 	bne	r2,zero,8216f08 <OSFlagAccept+0x168>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 8216ed4:	e0bffc17 	ldw	r2,-16(fp)
 8216ed8:	1080020b 	ldhu	r2,8(r2)
 8216edc:	1007883a 	mov	r3,r2
 8216ee0:	e0bff30b 	ldhu	r2,-52(fp)
 8216ee4:	0084303a 	nor	r2,zero,r2
 8216ee8:	1884703a 	and	r2,r3,r2
 8216eec:	1007883a 	mov	r3,r2
 8216ef0:	e0bffc17 	ldw	r2,-16(fp)
 8216ef4:	10c0020d 	sth	r3,8(r2)
 8216ef8:	00000306 	br	8216f08 <OSFlagAccept+0x168>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 8216efc:	e0bfff17 	ldw	r2,-4(fp)
 8216f00:	00c01c04 	movi	r3,112
 8216f04:	10c00005 	stb	r3,0(r2)
 8216f08:	e0bff417 	ldw	r2,-48(fp)
 8216f0c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8216f10:	e0bff617 	ldw	r2,-40(fp)
 8216f14:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 8216f18:	00005e06 	br	8217094 <OSFlagAccept+0x2f4>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 8216f1c:	e0bffc17 	ldw	r2,-16(fp)
 8216f20:	10c0020b 	ldhu	r3,8(r2)
 8216f24:	e0bffd0b 	ldhu	r2,-12(fp)
 8216f28:	1884703a 	and	r2,r3,r2
 8216f2c:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 8216f30:	e0bff30b 	ldhu	r2,-52(fp)
 8216f34:	10000d26 	beq	r2,zero,8216f6c <OSFlagAccept+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8216f38:	e0bff383 	ldbu	r2,-50(fp)
 8216f3c:	10800058 	cmpnei	r2,r2,1
 8216f40:	10000d1e 	bne	r2,zero,8216f78 <OSFlagAccept+0x1d8>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 8216f44:	e0bffc17 	ldw	r2,-16(fp)
 8216f48:	1080020b 	ldhu	r2,8(r2)
 8216f4c:	1007883a 	mov	r3,r2
 8216f50:	e0bff30b 	ldhu	r2,-52(fp)
 8216f54:	0084303a 	nor	r2,zero,r2
 8216f58:	1884703a 	and	r2,r3,r2
 8216f5c:	1007883a 	mov	r3,r2
 8216f60:	e0bffc17 	ldw	r2,-16(fp)
 8216f64:	10c0020d 	sth	r3,8(r2)
 8216f68:	00000306 	br	8216f78 <OSFlagAccept+0x1d8>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 8216f6c:	e0bfff17 	ldw	r2,-4(fp)
 8216f70:	00c01c04 	movi	r3,112
 8216f74:	10c00005 	stb	r3,0(r2)
 8216f78:	e0bff417 	ldw	r2,-48(fp)
 8216f7c:	e0bff715 	stw	r2,-36(fp)
 8216f80:	e0bff717 	ldw	r2,-36(fp)
 8216f84:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 8216f88:	00004206 	br	8217094 <OSFlagAccept+0x2f4>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 8216f8c:	e0bffc17 	ldw	r2,-16(fp)
 8216f90:	1080020b 	ldhu	r2,8(r2)
 8216f94:	0084303a 	nor	r2,zero,r2
 8216f98:	1007883a 	mov	r3,r2
 8216f9c:	e0bffd0b 	ldhu	r2,-12(fp)
 8216fa0:	1884703a 	and	r2,r3,r2
 8216fa4:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 8216fa8:	e0fff30b 	ldhu	r3,-52(fp)
 8216fac:	e0bffd0b 	ldhu	r2,-12(fp)
 8216fb0:	18800b1e 	bne	r3,r2,8216fe0 <OSFlagAccept+0x240>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8216fb4:	e0bff383 	ldbu	r2,-50(fp)
 8216fb8:	10800058 	cmpnei	r2,r2,1
 8216fbc:	10000b1e 	bne	r2,zero,8216fec <OSFlagAccept+0x24c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 8216fc0:	e0bffc17 	ldw	r2,-16(fp)
 8216fc4:	10c0020b 	ldhu	r3,8(r2)
 8216fc8:	e0bff30b 	ldhu	r2,-52(fp)
 8216fcc:	1884b03a 	or	r2,r3,r2
 8216fd0:	1007883a 	mov	r3,r2
 8216fd4:	e0bffc17 	ldw	r2,-16(fp)
 8216fd8:	10c0020d 	sth	r3,8(r2)
 8216fdc:	00000306 	br	8216fec <OSFlagAccept+0x24c>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 8216fe0:	e0bfff17 	ldw	r2,-4(fp)
 8216fe4:	00c01c04 	movi	r3,112
 8216fe8:	10c00005 	stb	r3,0(r2)
 8216fec:	e0bff417 	ldw	r2,-48(fp)
 8216ff0:	e0bff815 	stw	r2,-32(fp)
 8216ff4:	e0bff817 	ldw	r2,-32(fp)
 8216ff8:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 8216ffc:	00002506 	br	8217094 <OSFlagAccept+0x2f4>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 8217000:	e0bffc17 	ldw	r2,-16(fp)
 8217004:	1080020b 	ldhu	r2,8(r2)
 8217008:	0084303a 	nor	r2,zero,r2
 821700c:	1007883a 	mov	r3,r2
 8217010:	e0bffd0b 	ldhu	r2,-12(fp)
 8217014:	1884703a 	and	r2,r3,r2
 8217018:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 821701c:	e0bff30b 	ldhu	r2,-52(fp)
 8217020:	10000b26 	beq	r2,zero,8217050 <OSFlagAccept+0x2b0>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8217024:	e0bff383 	ldbu	r2,-50(fp)
 8217028:	10800058 	cmpnei	r2,r2,1
 821702c:	10000b1e 	bne	r2,zero,821705c <OSFlagAccept+0x2bc>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 8217030:	e0bffc17 	ldw	r2,-16(fp)
 8217034:	10c0020b 	ldhu	r3,8(r2)
 8217038:	e0bff30b 	ldhu	r2,-52(fp)
 821703c:	1884b03a 	or	r2,r3,r2
 8217040:	1007883a 	mov	r3,r2
 8217044:	e0bffc17 	ldw	r2,-16(fp)
 8217048:	10c0020d 	sth	r3,8(r2)
 821704c:	00000306 	br	821705c <OSFlagAccept+0x2bc>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 8217050:	e0bfff17 	ldw	r2,-4(fp)
 8217054:	00c01c04 	movi	r3,112
 8217058:	10c00005 	stb	r3,0(r2)
 821705c:	e0bff417 	ldw	r2,-48(fp)
 8217060:	e0bff915 	stw	r2,-28(fp)
 8217064:	e0bff917 	ldw	r2,-28(fp)
 8217068:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 821706c:	00000906 	br	8217094 <OSFlagAccept+0x2f4>
 8217070:	e0bff417 	ldw	r2,-48(fp)
 8217074:	e0bffa15 	stw	r2,-24(fp)
 8217078:	e0bffa17 	ldw	r2,-24(fp)
 821707c:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 8217080:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
 8217084:	e0bfff17 	ldw	r2,-4(fp)
 8217088:	00c01bc4 	movi	r3,111
 821708c:	10c00005 	stb	r3,0(r2)
             break;
 8217090:	0001883a 	nop
    }
    return (flags_rdy);
 8217094:	e0bff30b 	ldhu	r2,-52(fp)
}
 8217098:	e037883a 	mov	sp,fp
 821709c:	df000017 	ldw	fp,0(sp)
 82170a0:	dec00104 	addi	sp,sp,4
 82170a4:	f800283a 	ret

082170a8 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
 82170a8:	defff804 	addi	sp,sp,-32
 82170ac:	df000715 	stw	fp,28(sp)
 82170b0:	df000704 	addi	fp,sp,28
 82170b4:	2005883a 	mov	r2,r4
 82170b8:	e17fff15 	stw	r5,-4(fp)
 82170bc:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
 82170c0:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
 82170c4:	e0bfff17 	ldw	r2,-4(fp)
 82170c8:	1000021e 	bne	r2,zero,82170d4 <OSFlagCreate+0x2c>
        return ((OS_FLAG_GRP *)0);
 82170cc:	0005883a 	mov	r2,zero
 82170d0:	00003306 	br	82171a0 <OSFlagCreate+0xf8>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
 82170d4:	d0a07903 	ldbu	r2,-32284(gp)
 82170d8:	10803fcc 	andi	r2,r2,255
 82170dc:	10000526 	beq	r2,zero,82170f4 <OSFlagCreate+0x4c>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
 82170e0:	e0bfff17 	ldw	r2,-4(fp)
 82170e4:	00c00404 	movi	r3,16
 82170e8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
 82170ec:	0005883a 	mov	r2,zero
 82170f0:	00002b06 	br	82171a0 <OSFlagCreate+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82170f4:	0005303a 	rdctl	r2,status
 82170f8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82170fc:	e0fffd17 	ldw	r3,-12(fp)
 8217100:	00bfff84 	movi	r2,-2
 8217104:	1884703a 	and	r2,r3,r2
 8217108:	1001703a 	wrctl	status,r2
  
  return context;
 821710c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 8217110:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
 8217114:	d0a07c17 	ldw	r2,-32272(gp)
 8217118:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
 821711c:	e0bffb17 	ldw	r2,-20(fp)
 8217120:	10001726 	beq	r2,zero,8217180 <OSFlagCreate+0xd8>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
 8217124:	d0a07c17 	ldw	r2,-32272(gp)
 8217128:	10800117 	ldw	r2,4(r2)
 821712c:	d0a07c15 	stw	r2,-32272(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
 8217130:	e0bffb17 	ldw	r2,-20(fp)
 8217134:	00c00144 	movi	r3,5
 8217138:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
 821713c:	e0bffb17 	ldw	r2,-20(fp)
 8217140:	e0fffe0b 	ldhu	r3,-8(fp)
 8217144:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
 8217148:	e0bffb17 	ldw	r2,-20(fp)
 821714c:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
 8217150:	e0bffb17 	ldw	r2,-20(fp)
 8217154:	00c00fc4 	movi	r3,63
 8217158:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 821715c:	e0bffb17 	ldw	r2,-20(fp)
 8217160:	100002c5 	stb	zero,11(r2)
 8217164:	e0bff917 	ldw	r2,-28(fp)
 8217168:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821716c:	e0bffa17 	ldw	r2,-24(fp)
 8217170:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
 8217174:	e0bfff17 	ldw	r2,-4(fp)
 8217178:	10000005 	stb	zero,0(r2)
 821717c:	00000706 	br	821719c <OSFlagCreate+0xf4>
 8217180:	e0bff917 	ldw	r2,-28(fp)
 8217184:	e0bffc15 	stw	r2,-16(fp)
 8217188:	e0bffc17 	ldw	r2,-16(fp)
 821718c:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
 8217190:	e0bfff17 	ldw	r2,-4(fp)
 8217194:	00c01c84 	movi	r3,114
 8217198:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
 821719c:	e0bffb17 	ldw	r2,-20(fp)
}
 82171a0:	e037883a 	mov	sp,fp
 82171a4:	df000017 	ldw	fp,0(sp)
 82171a8:	dec00104 	addi	sp,sp,4
 82171ac:	f800283a 	ret

082171b0 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
 82171b0:	defff204 	addi	sp,sp,-56
 82171b4:	dfc00d15 	stw	ra,52(sp)
 82171b8:	df000c15 	stw	fp,48(sp)
 82171bc:	df000c04 	addi	fp,sp,48
 82171c0:	e13ffd15 	stw	r4,-12(fp)
 82171c4:	2805883a 	mov	r2,r5
 82171c8:	e1bfff15 	stw	r6,-4(fp)
 82171cc:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 82171d0:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 82171d4:	e0bfff17 	ldw	r2,-4(fp)
 82171d8:	1000021e 	bne	r2,zero,82171e4 <OSFlagDel+0x34>
        return (pgrp);
 82171dc:	e0bffd17 	ldw	r2,-12(fp)
 82171e0:	00008006 	br	82173e4 <OSFlagDel+0x234>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 82171e4:	e0bffd17 	ldw	r2,-12(fp)
 82171e8:	1000051e 	bne	r2,zero,8217200 <OSFlagDel+0x50>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 82171ec:	e0bfff17 	ldw	r2,-4(fp)
 82171f0:	00c01b84 	movi	r3,110
 82171f4:	10c00005 	stb	r3,0(r2)
        return (pgrp);
 82171f8:	e0bffd17 	ldw	r2,-12(fp)
 82171fc:	00007906 	br	82173e4 <OSFlagDel+0x234>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 8217200:	d0a07903 	ldbu	r2,-32284(gp)
 8217204:	10803fcc 	andi	r2,r2,255
 8217208:	10000526 	beq	r2,zero,8217220 <OSFlagDel+0x70>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 821720c:	e0bfff17 	ldw	r2,-4(fp)
 8217210:	00c003c4 	movi	r3,15
 8217214:	10c00005 	stb	r3,0(r2)
        return (pgrp);
 8217218:	e0bffd17 	ldw	r2,-12(fp)
 821721c:	00007106 	br	82173e4 <OSFlagDel+0x234>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
 8217220:	e0bffd17 	ldw	r2,-12(fp)
 8217224:	10800003 	ldbu	r2,0(r2)
 8217228:	10803fcc 	andi	r2,r2,255
 821722c:	10800160 	cmpeqi	r2,r2,5
 8217230:	1000051e 	bne	r2,zero,8217248 <OSFlagDel+0x98>
        *perr = OS_ERR_EVENT_TYPE;
 8217234:	e0bfff17 	ldw	r2,-4(fp)
 8217238:	00c00044 	movi	r3,1
 821723c:	10c00005 	stb	r3,0(r2)
        return (pgrp);
 8217240:	e0bffd17 	ldw	r2,-12(fp)
 8217244:	00006706 	br	82173e4 <OSFlagDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217248:	0005303a 	rdctl	r2,status
 821724c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217250:	e0fffc17 	ldw	r3,-16(fp)
 8217254:	00bfff84 	movi	r2,-2
 8217258:	1884703a 	and	r2,r3,r2
 821725c:	1001703a 	wrctl	status,r2
  
  return context;
 8217260:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8217264:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
 8217268:	e0bffd17 	ldw	r2,-12(fp)
 821726c:	10800117 	ldw	r2,4(r2)
 8217270:	10000326 	beq	r2,zero,8217280 <OSFlagDel+0xd0>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 8217274:	00800044 	movi	r2,1
 8217278:	e0bff405 	stb	r2,-48(fp)
 821727c:	00000106 	br	8217284 <OSFlagDel+0xd4>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 8217280:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
 8217284:	e0bffe03 	ldbu	r2,-8(fp)
 8217288:	10000326 	beq	r2,zero,8217298 <OSFlagDel+0xe8>
 821728c:	10800060 	cmpeqi	r2,r2,1
 8217290:	1000231e 	bne	r2,zero,8217320 <OSFlagDel+0x170>
 8217294:	00004806 	br	82173b8 <OSFlagDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
 8217298:	e0bff403 	ldbu	r2,-48(fp)
 821729c:	1000161e 	bne	r2,zero,82172f8 <OSFlagDel+0x148>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
 82172a0:	e0bffd17 	ldw	r2,-12(fp)
 82172a4:	00c00fc4 	movi	r3,63
 82172a8:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 82172ac:	e0bffd17 	ldw	r2,-12(fp)
 82172b0:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 82172b4:	e0bffd17 	ldw	r2,-12(fp)
 82172b8:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
 82172bc:	d0e07c17 	ldw	r3,-32272(gp)
 82172c0:	e0bffd17 	ldw	r2,-12(fp)
 82172c4:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
 82172c8:	e0bffd17 	ldw	r2,-12(fp)
 82172cc:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
 82172d0:	e0bffd17 	ldw	r2,-12(fp)
 82172d4:	d0a07c15 	stw	r2,-32272(gp)
 82172d8:	e0bff717 	ldw	r2,-36(fp)
 82172dc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82172e0:	e0bff817 	ldw	r2,-32(fp)
 82172e4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
 82172e8:	e0bfff17 	ldw	r2,-4(fp)
 82172ec:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
 82172f0:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
 82172f4:	00003a06 	br	82173e0 <OSFlagDel+0x230>
 82172f8:	e0bff717 	ldw	r2,-36(fp)
 82172fc:	e0bff915 	stw	r2,-28(fp)
 8217300:	e0bff917 	ldw	r2,-28(fp)
 8217304:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
 8217308:	e0bfff17 	ldw	r2,-4(fp)
 821730c:	00c01244 	movi	r3,73
 8217310:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
 8217314:	e0bffd17 	ldw	r2,-12(fp)
 8217318:	e0bff615 	stw	r2,-40(fp)
             }
             break;
 821731c:	00003006 	br	82173e0 <OSFlagDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 8217320:	e0bffd17 	ldw	r2,-12(fp)
 8217324:	10800117 	ldw	r2,4(r2)
 8217328:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 821732c:	00000606 	br	8217348 <OSFlagDel+0x198>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
 8217330:	000b883a 	mov	r5,zero
 8217334:	e13ff517 	ldw	r4,-44(fp)
 8217338:	821831c0 	call	821831c <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 821733c:	e0bff517 	ldw	r2,-44(fp)
 8217340:	10800017 	ldw	r2,0(r2)
 8217344:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 8217348:	e0bff517 	ldw	r2,-44(fp)
 821734c:	103ff81e 	bne	r2,zero,8217330 <OSFlagDel+0x180>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
 8217350:	e0bffd17 	ldw	r2,-12(fp)
 8217354:	00c00fc4 	movi	r3,63
 8217358:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 821735c:	e0bffd17 	ldw	r2,-12(fp)
 8217360:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 8217364:	e0bffd17 	ldw	r2,-12(fp)
 8217368:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
 821736c:	d0e07c17 	ldw	r3,-32272(gp)
 8217370:	e0bffd17 	ldw	r2,-12(fp)
 8217374:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
 8217378:	e0bffd17 	ldw	r2,-12(fp)
 821737c:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
 8217380:	e0bffd17 	ldw	r2,-12(fp)
 8217384:	d0a07c15 	stw	r2,-32272(gp)
 8217388:	e0bff717 	ldw	r2,-36(fp)
 821738c:	e0bffa15 	stw	r2,-24(fp)
 8217390:	e0bffa17 	ldw	r2,-24(fp)
 8217394:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 8217398:	e0bff403 	ldbu	r2,-48(fp)
 821739c:	10800058 	cmpnei	r2,r2,1
 82173a0:	1000011e 	bne	r2,zero,82173a8 <OSFlagDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 82173a4:	82165240 	call	8216524 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
 82173a8:	e0bfff17 	ldw	r2,-4(fp)
 82173ac:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
 82173b0:	e03ff615 	stw	zero,-40(fp)
             break;
 82173b4:	00000a06 	br	82173e0 <OSFlagDel+0x230>
 82173b8:	e0bff717 	ldw	r2,-36(fp)
 82173bc:	e0bffb15 	stw	r2,-20(fp)
 82173c0:	e0bffb17 	ldw	r2,-20(fp)
 82173c4:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
 82173c8:	e0bfff17 	ldw	r2,-4(fp)
 82173cc:	00c001c4 	movi	r3,7
 82173d0:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
 82173d4:	e0bffd17 	ldw	r2,-12(fp)
 82173d8:	e0bff615 	stw	r2,-40(fp)
             break;
 82173dc:	0001883a 	nop
    }
    return (pgrp_return);
 82173e0:	e0bff617 	ldw	r2,-40(fp)
}
 82173e4:	e037883a 	mov	sp,fp
 82173e8:	dfc00117 	ldw	ra,4(sp)
 82173ec:	df000017 	ldw	fp,0(sp)
 82173f0:	dec00204 	addi	sp,sp,8
 82173f4:	f800283a 	ret

082173f8 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 82173f8:	defff604 	addi	sp,sp,-40
 82173fc:	dfc00915 	stw	ra,36(sp)
 8217400:	df000815 	stw	fp,32(sp)
 8217404:	df000804 	addi	fp,sp,32
 8217408:	e13ffd15 	stw	r4,-12(fp)
 821740c:	e17ffe15 	stw	r5,-8(fp)
 8217410:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8217414:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8217418:	e0bfff17 	ldw	r2,-4(fp)
 821741c:	1000021e 	bne	r2,zero,8217428 <OSFlagNameGet+0x30>
        return (0);
 8217420:	0005883a 	mov	r2,zero
 8217424:	00003906 	br	821750c <OSFlagNameGet+0x114>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 8217428:	e0bffd17 	ldw	r2,-12(fp)
 821742c:	1000051e 	bne	r2,zero,8217444 <OSFlagNameGet+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8217430:	e0bfff17 	ldw	r2,-4(fp)
 8217434:	00c01b84 	movi	r3,110
 8217438:	10c00005 	stb	r3,0(r2)
        return (0);
 821743c:	0005883a 	mov	r2,zero
 8217440:	00003206 	br	821750c <OSFlagNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 8217444:	e0bffe17 	ldw	r2,-8(fp)
 8217448:	1000051e 	bne	r2,zero,8217460 <OSFlagNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
 821744c:	e0bfff17 	ldw	r2,-4(fp)
 8217450:	00c00304 	movi	r3,12
 8217454:	10c00005 	stb	r3,0(r2)
        return (0);
 8217458:	0005883a 	mov	r2,zero
 821745c:	00002b06 	br	821750c <OSFlagNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 8217460:	d0a07903 	ldbu	r2,-32284(gp)
 8217464:	10803fcc 	andi	r2,r2,255
 8217468:	10000526 	beq	r2,zero,8217480 <OSFlagNameGet+0x88>
        *perr = OS_ERR_NAME_GET_ISR;
 821746c:	e0bfff17 	ldw	r2,-4(fp)
 8217470:	00c00444 	movi	r3,17
 8217474:	10c00005 	stb	r3,0(r2)
        return (0);
 8217478:	0005883a 	mov	r2,zero
 821747c:	00002306 	br	821750c <OSFlagNameGet+0x114>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217480:	0005303a 	rdctl	r2,status
 8217484:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217488:	e0fffc17 	ldw	r3,-16(fp)
 821748c:	00bfff84 	movi	r2,-2
 8217490:	1884703a 	and	r2,r3,r2
 8217494:	1001703a 	wrctl	status,r2
  
  return context;
 8217498:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821749c:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 82174a0:	e0bffd17 	ldw	r2,-12(fp)
 82174a4:	10800003 	ldbu	r2,0(r2)
 82174a8:	10803fcc 	andi	r2,r2,255
 82174ac:	10800160 	cmpeqi	r2,r2,5
 82174b0:	1000091e 	bne	r2,zero,82174d8 <OSFlagNameGet+0xe0>
 82174b4:	e0bff817 	ldw	r2,-32(fp)
 82174b8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82174bc:	e0bff917 	ldw	r2,-28(fp)
 82174c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 82174c4:	e0bfff17 	ldw	r2,-4(fp)
 82174c8:	00c00044 	movi	r3,1
 82174cc:	10c00005 	stb	r3,0(r2)
        return (0);
 82174d0:	0005883a 	mov	r2,zero
 82174d4:	00000d06 	br	821750c <OSFlagNameGet+0x114>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
 82174d8:	e0bffd17 	ldw	r2,-12(fp)
 82174dc:	10800284 	addi	r2,r2,10
 82174e0:	100b883a 	mov	r5,r2
 82174e4:	e13ffe17 	ldw	r4,-8(fp)
 82174e8:	82166680 	call	8216668 <OS_StrCopy>
 82174ec:	e0bffb05 	stb	r2,-20(fp)
 82174f0:	e0bff817 	ldw	r2,-32(fp)
 82174f4:	e0bffa15 	stw	r2,-24(fp)
 82174f8:	e0bffa17 	ldw	r2,-24(fp)
 82174fc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8217500:	e0bfff17 	ldw	r2,-4(fp)
 8217504:	10000005 	stb	zero,0(r2)
    return (len);
 8217508:	e0bffb03 	ldbu	r2,-20(fp)
}
 821750c:	e037883a 	mov	sp,fp
 8217510:	dfc00117 	ldw	ra,4(sp)
 8217514:	df000017 	ldw	fp,0(sp)
 8217518:	dec00204 	addi	sp,sp,8
 821751c:	f800283a 	ret

08217520 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 8217520:	defff504 	addi	sp,sp,-44
 8217524:	dfc00a15 	stw	ra,40(sp)
 8217528:	df000915 	stw	fp,36(sp)
 821752c:	df000904 	addi	fp,sp,36
 8217530:	e13ffd15 	stw	r4,-12(fp)
 8217534:	e17ffe15 	stw	r5,-8(fp)
 8217538:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821753c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8217540:	e0bfff17 	ldw	r2,-4(fp)
 8217544:	10004326 	beq	r2,zero,8217654 <OSFlagNameSet+0x134>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 8217548:	e0bffd17 	ldw	r2,-12(fp)
 821754c:	1000041e 	bne	r2,zero,8217560 <OSFlagNameSet+0x40>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8217550:	e0bfff17 	ldw	r2,-4(fp)
 8217554:	00c01b84 	movi	r3,110
 8217558:	10c00005 	stb	r3,0(r2)
        return;
 821755c:	00003e06 	br	8217658 <OSFlagNameSet+0x138>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 8217560:	e0bffe17 	ldw	r2,-8(fp)
 8217564:	1000041e 	bne	r2,zero,8217578 <OSFlagNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
 8217568:	e0bfff17 	ldw	r2,-4(fp)
 821756c:	00c00304 	movi	r3,12
 8217570:	10c00005 	stb	r3,0(r2)
        return;
 8217574:	00003806 	br	8217658 <OSFlagNameSet+0x138>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 8217578:	d0a07903 	ldbu	r2,-32284(gp)
 821757c:	10803fcc 	andi	r2,r2,255
 8217580:	10000426 	beq	r2,zero,8217594 <OSFlagNameSet+0x74>
        *perr = OS_ERR_NAME_SET_ISR;
 8217584:	e0bfff17 	ldw	r2,-4(fp)
 8217588:	00c00484 	movi	r3,18
 821758c:	10c00005 	stb	r3,0(r2)
        return;
 8217590:	00003106 	br	8217658 <OSFlagNameSet+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217594:	0005303a 	rdctl	r2,status
 8217598:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821759c:	e0fffc17 	ldw	r3,-16(fp)
 82175a0:	00bfff84 	movi	r2,-2
 82175a4:	1884703a 	and	r2,r3,r2
 82175a8:	1001703a 	wrctl	status,r2
  
  return context;
 82175ac:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 82175b0:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 82175b4:	e0bffd17 	ldw	r2,-12(fp)
 82175b8:	10800003 	ldbu	r2,0(r2)
 82175bc:	10803fcc 	andi	r2,r2,255
 82175c0:	10800160 	cmpeqi	r2,r2,5
 82175c4:	1000081e 	bne	r2,zero,82175e8 <OSFlagNameSet+0xc8>
 82175c8:	e0bff717 	ldw	r2,-36(fp)
 82175cc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82175d0:	e0bff817 	ldw	r2,-32(fp)
 82175d4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 82175d8:	e0bfff17 	ldw	r2,-4(fp)
 82175dc:	00c00044 	movi	r3,1
 82175e0:	10c00005 	stb	r3,0(r2)
        return;
 82175e4:	00001c06 	br	8217658 <OSFlagNameSet+0x138>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 82175e8:	e13ffe17 	ldw	r4,-8(fp)
 82175ec:	82166dc0 	call	82166dc <OS_StrLen>
 82175f0:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
 82175f4:	e0bffa03 	ldbu	r2,-24(fp)
 82175f8:	10800830 	cmpltui	r2,r2,32
 82175fc:	1000081e 	bne	r2,zero,8217620 <OSFlagNameSet+0x100>
 8217600:	e0bff717 	ldw	r2,-36(fp)
 8217604:	e0bff915 	stw	r2,-28(fp)
 8217608:	e0bff917 	ldw	r2,-28(fp)
 821760c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
 8217610:	e0bfff17 	ldw	r2,-4(fp)
 8217614:	00c01cc4 	movi	r3,115
 8217618:	10c00005 	stb	r3,0(r2)
        return;
 821761c:	00000e06 	br	8217658 <OSFlagNameSet+0x138>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
 8217620:	e0bffd17 	ldw	r2,-12(fp)
 8217624:	10800284 	addi	r2,r2,10
 8217628:	e17ffe17 	ldw	r5,-8(fp)
 821762c:	1009883a 	mov	r4,r2
 8217630:	82166680 	call	8216668 <OS_StrCopy>
 8217634:	e0bff717 	ldw	r2,-36(fp)
 8217638:	e0bffb15 	stw	r2,-20(fp)
 821763c:	e0bffb17 	ldw	r2,-20(fp)
 8217640:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8217644:	e0bfff17 	ldw	r2,-4(fp)
 8217648:	10000005 	stb	zero,0(r2)
    return;
 821764c:	0001883a 	nop
 8217650:	00000106 	br	8217658 <OSFlagNameSet+0x138>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
 8217654:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
 8217658:	e037883a 	mov	sp,fp
 821765c:	dfc00117 	ldw	ra,4(sp)
 8217660:	df000017 	ldw	fp,0(sp)
 8217664:	dec00204 	addi	sp,sp,8
 8217668:	f800283a 	ret

0821766c <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
 821766c:	deffe104 	addi	sp,sp,-124
 8217670:	dfc01e15 	stw	ra,120(sp)
 8217674:	df001d15 	stw	fp,116(sp)
 8217678:	df001d04 	addi	fp,sp,116
 821767c:	e13ffc15 	stw	r4,-16(fp)
 8217680:	2809883a 	mov	r4,r5
 8217684:	3007883a 	mov	r3,r6
 8217688:	3805883a 	mov	r2,r7
 821768c:	e13ffd0d 	sth	r4,-12(fp)
 8217690:	e0fffe05 	stb	r3,-8(fp)
 8217694:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 8217698:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 821769c:	e0800217 	ldw	r2,8(fp)
 82176a0:	1000021e 	bne	r2,zero,82176ac <OSFlagPend+0x40>
        return ((OS_FLAGS)0);
 82176a4:	0005883a 	mov	r2,zero
 82176a8:	00015906 	br	8217c10 <OSFlagPend+0x5a4>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 82176ac:	e0bffc17 	ldw	r2,-16(fp)
 82176b0:	1000051e 	bne	r2,zero,82176c8 <OSFlagPend+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 82176b4:	e0800217 	ldw	r2,8(fp)
 82176b8:	00c01b84 	movi	r3,110
 82176bc:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 82176c0:	0005883a 	mov	r2,zero
 82176c4:	00015206 	br	8217c10 <OSFlagPend+0x5a4>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 82176c8:	d0a07903 	ldbu	r2,-32284(gp)
 82176cc:	10803fcc 	andi	r2,r2,255
 82176d0:	10000526 	beq	r2,zero,82176e8 <OSFlagPend+0x7c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
 82176d4:	e0800217 	ldw	r2,8(fp)
 82176d8:	00c00084 	movi	r3,2
 82176dc:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 82176e0:	0005883a 	mov	r2,zero
 82176e4:	00014a06 	br	8217c10 <OSFlagPend+0x5a4>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
 82176e8:	d0a06b03 	ldbu	r2,-32340(gp)
 82176ec:	10803fcc 	andi	r2,r2,255
 82176f0:	10000526 	beq	r2,zero,8217708 <OSFlagPend+0x9c>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
 82176f4:	e0800217 	ldw	r2,8(fp)
 82176f8:	00c00344 	movi	r3,13
 82176fc:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217700:	0005883a 	mov	r2,zero
 8217704:	00014206 	br	8217c10 <OSFlagPend+0x5a4>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 8217708:	e0bffc17 	ldw	r2,-16(fp)
 821770c:	10800003 	ldbu	r2,0(r2)
 8217710:	10803fcc 	andi	r2,r2,255
 8217714:	10800160 	cmpeqi	r2,r2,5
 8217718:	1000051e 	bne	r2,zero,8217730 <OSFlagPend+0xc4>
        *perr = OS_ERR_EVENT_TYPE;
 821771c:	e0800217 	ldw	r2,8(fp)
 8217720:	00c00044 	movi	r3,1
 8217724:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217728:	0005883a 	mov	r2,zero
 821772c:	00013806 	br	8217c10 <OSFlagPend+0x5a4>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 8217730:	e0fffe03 	ldbu	r3,-8(fp)
 8217734:	00bfe004 	movi	r2,-128
 8217738:	1884703a 	and	r2,r3,r2
 821773c:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
 8217740:	e0bfe603 	ldbu	r2,-104(fp)
 8217744:	10000626 	beq	r2,zero,8217760 <OSFlagPend+0xf4>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
 8217748:	e0bffe03 	ldbu	r2,-8(fp)
 821774c:	10801fcc 	andi	r2,r2,127
 8217750:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
 8217754:	00800044 	movi	r2,1
 8217758:	e0bfe405 	stb	r2,-112(fp)
 821775c:	00000106 	br	8217764 <OSFlagPend+0xf8>
    } else {
        consume    = OS_FALSE;
 8217760:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217764:	0005303a 	rdctl	r2,status
 8217768:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821776c:	e0fff617 	ldw	r3,-40(fp)
 8217770:	00bfff84 	movi	r2,-2
 8217774:	1884703a 	and	r2,r3,r2
 8217778:	1001703a 	wrctl	status,r2
  
  return context;
 821777c:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 8217780:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
 8217784:	e0bffe03 	ldbu	r2,-8(fp)
 8217788:	10c00060 	cmpeqi	r3,r2,1
 821778c:	1800921e 	bne	r3,zero,82179d8 <OSFlagPend+0x36c>
 8217790:	10c00088 	cmpgei	r3,r2,2
 8217794:	1800021e 	bne	r3,zero,82177a0 <OSFlagPend+0x134>
 8217798:	10006126 	beq	r2,zero,8217920 <OSFlagPend+0x2b4>
 821779c:	0000bb06 	br	8217a8c <OSFlagPend+0x420>
 82177a0:	10c000a0 	cmpeqi	r3,r2,2
 82177a4:	1800031e 	bne	r3,zero,82177b4 <OSFlagPend+0x148>
 82177a8:	108000e0 	cmpeqi	r2,r2,3
 82177ac:	10002f1e 	bne	r2,zero,821786c <OSFlagPend+0x200>
 82177b0:	0000b606 	br	8217a8c <OSFlagPend+0x420>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
 82177b4:	e0bffc17 	ldw	r2,-16(fp)
 82177b8:	10c0020b 	ldhu	r3,8(r2)
 82177bc:	e0bffd0b 	ldhu	r2,-12(fp)
 82177c0:	1884703a 	and	r2,r3,r2
 82177c4:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 82177c8:	e0ffe80b 	ldhu	r3,-96(fp)
 82177cc:	e0bffd0b 	ldhu	r2,-12(fp)
 82177d0:	1880171e 	bne	r3,r2,8217830 <OSFlagPend+0x1c4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 82177d4:	e0bfe403 	ldbu	r2,-112(fp)
 82177d8:	10800058 	cmpnei	r2,r2,1
 82177dc:	1000091e 	bne	r2,zero,8217804 <OSFlagPend+0x198>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 82177e0:	e0bffc17 	ldw	r2,-16(fp)
 82177e4:	1080020b 	ldhu	r2,8(r2)
 82177e8:	1007883a 	mov	r3,r2
 82177ec:	e0bfe80b 	ldhu	r2,-96(fp)
 82177f0:	0084303a 	nor	r2,zero,r2
 82177f4:	1884703a 	and	r2,r3,r2
 82177f8:	1007883a 	mov	r3,r2
 82177fc:	e0bffc17 	ldw	r2,-16(fp)
 8217800:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 8217804:	d0a07a17 	ldw	r2,-32280(gp)
 8217808:	e0ffe80b 	ldhu	r3,-96(fp)
 821780c:	10c00b0d 	sth	r3,44(r2)
 8217810:	e0bfe517 	ldw	r2,-108(fp)
 8217814:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217818:	e0bfe717 	ldw	r2,-100(fp)
 821781c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 8217820:	e0800217 	ldw	r2,8(fp)
 8217824:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 8217828:	e0bfe80b 	ldhu	r2,-96(fp)
 821782c:	0000f806 	br	8217c10 <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 8217830:	e13ffd0b 	ldhu	r4,-12(fp)
 8217834:	e17ffe03 	ldbu	r5,-8(fp)
 8217838:	e0bfff0b 	ldhu	r2,-4(fp)
 821783c:	e0fff704 	addi	r3,fp,-36
 8217840:	d8800015 	stw	r2,0(sp)
 8217844:	280f883a 	mov	r7,r5
 8217848:	200d883a 	mov	r6,r4
 821784c:	180b883a 	mov	r5,r3
 8217850:	e13ffc17 	ldw	r4,-16(fp)
 8217854:	82180dc0 	call	82180dc <OS_FlagBlock>
 8217858:	e0bfe517 	ldw	r2,-108(fp)
 821785c:	e0bfe915 	stw	r2,-92(fp)
 8217860:	e0bfe917 	ldw	r2,-92(fp)
 8217864:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 8217868:	00009206 	br	8217ab4 <OSFlagPend+0x448>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
 821786c:	e0bffc17 	ldw	r2,-16(fp)
 8217870:	10c0020b 	ldhu	r3,8(r2)
 8217874:	e0bffd0b 	ldhu	r2,-12(fp)
 8217878:	1884703a 	and	r2,r3,r2
 821787c:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 8217880:	e0bfe80b 	ldhu	r2,-96(fp)
 8217884:	10001726 	beq	r2,zero,82178e4 <OSFlagPend+0x278>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8217888:	e0bfe403 	ldbu	r2,-112(fp)
 821788c:	10800058 	cmpnei	r2,r2,1
 8217890:	1000091e 	bne	r2,zero,82178b8 <OSFlagPend+0x24c>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 8217894:	e0bffc17 	ldw	r2,-16(fp)
 8217898:	1080020b 	ldhu	r2,8(r2)
 821789c:	1007883a 	mov	r3,r2
 82178a0:	e0bfe80b 	ldhu	r2,-96(fp)
 82178a4:	0084303a 	nor	r2,zero,r2
 82178a8:	1884703a 	and	r2,r3,r2
 82178ac:	1007883a 	mov	r3,r2
 82178b0:	e0bffc17 	ldw	r2,-16(fp)
 82178b4:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 82178b8:	d0a07a17 	ldw	r2,-32280(gp)
 82178bc:	e0ffe80b 	ldhu	r3,-96(fp)
 82178c0:	10c00b0d 	sth	r3,44(r2)
 82178c4:	e0bfe517 	ldw	r2,-108(fp)
 82178c8:	e0bfea15 	stw	r2,-88(fp)
 82178cc:	e0bfea17 	ldw	r2,-88(fp)
 82178d0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 82178d4:	e0800217 	ldw	r2,8(fp)
 82178d8:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 82178dc:	e0bfe80b 	ldhu	r2,-96(fp)
 82178e0:	0000cb06 	br	8217c10 <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 82178e4:	e13ffd0b 	ldhu	r4,-12(fp)
 82178e8:	e17ffe03 	ldbu	r5,-8(fp)
 82178ec:	e0bfff0b 	ldhu	r2,-4(fp)
 82178f0:	e0fff704 	addi	r3,fp,-36
 82178f4:	d8800015 	stw	r2,0(sp)
 82178f8:	280f883a 	mov	r7,r5
 82178fc:	200d883a 	mov	r6,r4
 8217900:	180b883a 	mov	r5,r3
 8217904:	e13ffc17 	ldw	r4,-16(fp)
 8217908:	82180dc0 	call	82180dc <OS_FlagBlock>
 821790c:	e0bfe517 	ldw	r2,-108(fp)
 8217910:	e0bfeb15 	stw	r2,-84(fp)
 8217914:	e0bfeb17 	ldw	r2,-84(fp)
 8217918:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 821791c:	00006506 	br	8217ab4 <OSFlagPend+0x448>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 8217920:	e0bffc17 	ldw	r2,-16(fp)
 8217924:	1080020b 	ldhu	r2,8(r2)
 8217928:	0084303a 	nor	r2,zero,r2
 821792c:	1007883a 	mov	r3,r2
 8217930:	e0bffd0b 	ldhu	r2,-12(fp)
 8217934:	1884703a 	and	r2,r3,r2
 8217938:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 821793c:	e0ffe80b 	ldhu	r3,-96(fp)
 8217940:	e0bffd0b 	ldhu	r2,-12(fp)
 8217944:	1880151e 	bne	r3,r2,821799c <OSFlagPend+0x330>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8217948:	e0bfe403 	ldbu	r2,-112(fp)
 821794c:	10800058 	cmpnei	r2,r2,1
 8217950:	1000071e 	bne	r2,zero,8217970 <OSFlagPend+0x304>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 8217954:	e0bffc17 	ldw	r2,-16(fp)
 8217958:	10c0020b 	ldhu	r3,8(r2)
 821795c:	e0bfe80b 	ldhu	r2,-96(fp)
 8217960:	1884b03a 	or	r2,r3,r2
 8217964:	1007883a 	mov	r3,r2
 8217968:	e0bffc17 	ldw	r2,-16(fp)
 821796c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 8217970:	d0a07a17 	ldw	r2,-32280(gp)
 8217974:	e0ffe80b 	ldhu	r3,-96(fp)
 8217978:	10c00b0d 	sth	r3,44(r2)
 821797c:	e0bfe517 	ldw	r2,-108(fp)
 8217980:	e0bfec15 	stw	r2,-80(fp)
 8217984:	e0bfec17 	ldw	r2,-80(fp)
 8217988:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 821798c:	e0800217 	ldw	r2,8(fp)
 8217990:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 8217994:	e0bfe80b 	ldhu	r2,-96(fp)
 8217998:	00009d06 	br	8217c10 <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 821799c:	e13ffd0b 	ldhu	r4,-12(fp)
 82179a0:	e17ffe03 	ldbu	r5,-8(fp)
 82179a4:	e0bfff0b 	ldhu	r2,-4(fp)
 82179a8:	e0fff704 	addi	r3,fp,-36
 82179ac:	d8800015 	stw	r2,0(sp)
 82179b0:	280f883a 	mov	r7,r5
 82179b4:	200d883a 	mov	r6,r4
 82179b8:	180b883a 	mov	r5,r3
 82179bc:	e13ffc17 	ldw	r4,-16(fp)
 82179c0:	82180dc0 	call	82180dc <OS_FlagBlock>
 82179c4:	e0bfe517 	ldw	r2,-108(fp)
 82179c8:	e0bfed15 	stw	r2,-76(fp)
 82179cc:	e0bfed17 	ldw	r2,-76(fp)
 82179d0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 82179d4:	00003706 	br	8217ab4 <OSFlagPend+0x448>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 82179d8:	e0bffc17 	ldw	r2,-16(fp)
 82179dc:	1080020b 	ldhu	r2,8(r2)
 82179e0:	0084303a 	nor	r2,zero,r2
 82179e4:	1007883a 	mov	r3,r2
 82179e8:	e0bffd0b 	ldhu	r2,-12(fp)
 82179ec:	1884703a 	and	r2,r3,r2
 82179f0:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 82179f4:	e0bfe80b 	ldhu	r2,-96(fp)
 82179f8:	10001526 	beq	r2,zero,8217a50 <OSFlagPend+0x3e4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 82179fc:	e0bfe403 	ldbu	r2,-112(fp)
 8217a00:	10800058 	cmpnei	r2,r2,1
 8217a04:	1000071e 	bne	r2,zero,8217a24 <OSFlagPend+0x3b8>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 8217a08:	e0bffc17 	ldw	r2,-16(fp)
 8217a0c:	10c0020b 	ldhu	r3,8(r2)
 8217a10:	e0bfe80b 	ldhu	r2,-96(fp)
 8217a14:	1884b03a 	or	r2,r3,r2
 8217a18:	1007883a 	mov	r3,r2
 8217a1c:	e0bffc17 	ldw	r2,-16(fp)
 8217a20:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 8217a24:	d0a07a17 	ldw	r2,-32280(gp)
 8217a28:	e0ffe80b 	ldhu	r3,-96(fp)
 8217a2c:	10c00b0d 	sth	r3,44(r2)
 8217a30:	e0bfe517 	ldw	r2,-108(fp)
 8217a34:	e0bfee15 	stw	r2,-72(fp)
 8217a38:	e0bfee17 	ldw	r2,-72(fp)
 8217a3c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 8217a40:	e0800217 	ldw	r2,8(fp)
 8217a44:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 8217a48:	e0bfe80b 	ldhu	r2,-96(fp)
 8217a4c:	00007006 	br	8217c10 <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 8217a50:	e13ffd0b 	ldhu	r4,-12(fp)
 8217a54:	e17ffe03 	ldbu	r5,-8(fp)
 8217a58:	e0bfff0b 	ldhu	r2,-4(fp)
 8217a5c:	e0fff704 	addi	r3,fp,-36
 8217a60:	d8800015 	stw	r2,0(sp)
 8217a64:	280f883a 	mov	r7,r5
 8217a68:	200d883a 	mov	r6,r4
 8217a6c:	180b883a 	mov	r5,r3
 8217a70:	e13ffc17 	ldw	r4,-16(fp)
 8217a74:	82180dc0 	call	82180dc <OS_FlagBlock>
 8217a78:	e0bfe517 	ldw	r2,-108(fp)
 8217a7c:	e0bfef15 	stw	r2,-68(fp)
 8217a80:	e0bfef17 	ldw	r2,-68(fp)
 8217a84:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 8217a88:	00000a06 	br	8217ab4 <OSFlagPend+0x448>
 8217a8c:	e0bfe517 	ldw	r2,-108(fp)
 8217a90:	e0bff015 	stw	r2,-64(fp)
 8217a94:	e0bff017 	ldw	r2,-64(fp)
 8217a98:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 8217a9c:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
 8217aa0:	e0800217 	ldw	r2,8(fp)
 8217aa4:	00c01bc4 	movi	r3,111
 8217aa8:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
 8217aac:	e0bfe80b 	ldhu	r2,-96(fp)
 8217ab0:	00005706 	br	8217c10 <OSFlagPend+0x5a4>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
 8217ab4:	82165240 	call	8216524 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217ab8:	0005303a 	rdctl	r2,status
 8217abc:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217ac0:	e0fff117 	ldw	r3,-60(fp)
 8217ac4:	00bfff84 	movi	r2,-2
 8217ac8:	1884703a 	and	r2,r3,r2
 8217acc:	1001703a 	wrctl	status,r2
  
  return context;
 8217ad0:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
 8217ad4:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
 8217ad8:	d0a07a17 	ldw	r2,-32280(gp)
 8217adc:	10800c43 	ldbu	r2,49(r2)
 8217ae0:	10803fcc 	andi	r2,r2,255
 8217ae4:	10001c26 	beq	r2,zero,8217b58 <OSFlagPend+0x4ec>
        pend_stat                = OSTCBCur->OSTCBStatPend;
 8217ae8:	d0a07a17 	ldw	r2,-32280(gp)
 8217aec:	10800c43 	ldbu	r2,49(r2)
 8217af0:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 8217af4:	d0a07a17 	ldw	r2,-32280(gp)
 8217af8:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
 8217afc:	e0bff704 	addi	r2,fp,-36
 8217b00:	1009883a 	mov	r4,r2
 8217b04:	82184100 	call	8218410 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
 8217b08:	d0a07a17 	ldw	r2,-32280(gp)
 8217b0c:	10000c05 	stb	zero,48(r2)
 8217b10:	e0bfe517 	ldw	r2,-108(fp)
 8217b14:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217b18:	e0bff217 	ldw	r2,-56(fp)
 8217b1c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
 8217b20:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
 8217b24:	e0bff303 	ldbu	r2,-52(fp)
 8217b28:	108000a0 	cmpeqi	r2,r2,2
 8217b2c:	10000426 	beq	r2,zero,8217b40 <OSFlagPend+0x4d4>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
 8217b30:	e0800217 	ldw	r2,8(fp)
 8217b34:	00c00384 	movi	r3,14
 8217b38:	10c00005 	stb	r3,0(r2)
                 break;
 8217b3c:	00000406 	br	8217b50 <OSFlagPend+0x4e4>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
 8217b40:	e0800217 	ldw	r2,8(fp)
 8217b44:	00c00284 	movi	r3,10
 8217b48:	10c00005 	stb	r3,0(r2)
                 break;
 8217b4c:	0001883a 	nop
        }
        return (flags_rdy);
 8217b50:	e0bfe80b 	ldhu	r2,-96(fp)
 8217b54:	00002e06 	br	8217c10 <OSFlagPend+0x5a4>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
 8217b58:	d0a07a17 	ldw	r2,-32280(gp)
 8217b5c:	10800b0b 	ldhu	r2,44(r2)
 8217b60:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
 8217b64:	e0bfe403 	ldbu	r2,-112(fp)
 8217b68:	10800058 	cmpnei	r2,r2,1
 8217b6c:	1000211e 	bne	r2,zero,8217bf4 <OSFlagPend+0x588>
        switch (wait_type) {
 8217b70:	e0bffe03 	ldbu	r2,-8(fp)
 8217b74:	10001616 	blt	r2,zero,8217bd0 <OSFlagPend+0x564>
 8217b78:	10c00090 	cmplti	r3,r2,2
 8217b7c:	18000c1e 	bne	r3,zero,8217bb0 <OSFlagPend+0x544>
 8217b80:	10800108 	cmpgei	r2,r2,4
 8217b84:	1000121e 	bne	r2,zero,8217bd0 <OSFlagPend+0x564>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
 8217b88:	e0bffc17 	ldw	r2,-16(fp)
 8217b8c:	1080020b 	ldhu	r2,8(r2)
 8217b90:	1007883a 	mov	r3,r2
 8217b94:	e0bfe80b 	ldhu	r2,-96(fp)
 8217b98:	0084303a 	nor	r2,zero,r2
 8217b9c:	1884703a 	and	r2,r3,r2
 8217ba0:	1007883a 	mov	r3,r2
 8217ba4:	e0bffc17 	ldw	r2,-16(fp)
 8217ba8:	10c0020d 	sth	r3,8(r2)
                 break;
 8217bac:	00001106 	br	8217bf4 <OSFlagPend+0x588>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
 8217bb0:	e0bffc17 	ldw	r2,-16(fp)
 8217bb4:	10c0020b 	ldhu	r3,8(r2)
 8217bb8:	e0bfe80b 	ldhu	r2,-96(fp)
 8217bbc:	1884b03a 	or	r2,r3,r2
 8217bc0:	1007883a 	mov	r3,r2
 8217bc4:	e0bffc17 	ldw	r2,-16(fp)
 8217bc8:	10c0020d 	sth	r3,8(r2)
                 break;
 8217bcc:	00000906 	br	8217bf4 <OSFlagPend+0x588>
 8217bd0:	e0bfe517 	ldw	r2,-108(fp)
 8217bd4:	e0bff415 	stw	r2,-48(fp)
 8217bd8:	e0bff417 	ldw	r2,-48(fp)
 8217bdc:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 8217be0:	e0800217 	ldw	r2,8(fp)
 8217be4:	00c01bc4 	movi	r3,111
 8217be8:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
 8217bec:	0005883a 	mov	r2,zero
 8217bf0:	00000706 	br	8217c10 <OSFlagPend+0x5a4>
 8217bf4:	e0bfe517 	ldw	r2,-108(fp)
 8217bf8:	e0bff515 	stw	r2,-44(fp)
 8217bfc:	e0bff517 	ldw	r2,-44(fp)
 8217c00:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
 8217c04:	e0800217 	ldw	r2,8(fp)
 8217c08:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
 8217c0c:	e0bfe80b 	ldhu	r2,-96(fp)
}
 8217c10:	e037883a 	mov	sp,fp
 8217c14:	dfc00117 	ldw	ra,4(sp)
 8217c18:	df000017 	ldw	fp,0(sp)
 8217c1c:	dec00204 	addi	sp,sp,8
 8217c20:	f800283a 	ret

08217c24 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
 8217c24:	defffb04 	addi	sp,sp,-20
 8217c28:	df000415 	stw	fp,16(sp)
 8217c2c:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 8217c30:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217c34:	0005303a 	rdctl	r2,status
 8217c38:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217c3c:	e0fffe17 	ldw	r3,-8(fp)
 8217c40:	00bfff84 	movi	r2,-2
 8217c44:	1884703a 	and	r2,r3,r2
 8217c48:	1001703a 	wrctl	status,r2
  
  return context;
 8217c4c:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
 8217c50:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
 8217c54:	d0a07a17 	ldw	r2,-32280(gp)
 8217c58:	10800b0b 	ldhu	r2,44(r2)
 8217c5c:	e0bffd0d 	sth	r2,-12(fp)
 8217c60:	e0bffc17 	ldw	r2,-16(fp)
 8217c64:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217c68:	e0bfff17 	ldw	r2,-4(fp)
 8217c6c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
 8217c70:	e0bffd0b 	ldhu	r2,-12(fp)
}
 8217c74:	e037883a 	mov	sp,fp
 8217c78:	df000017 	ldw	fp,0(sp)
 8217c7c:	dec00104 	addi	sp,sp,4
 8217c80:	f800283a 	ret

08217c84 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
 8217c84:	deffef04 	addi	sp,sp,-68
 8217c88:	dfc01015 	stw	ra,64(sp)
 8217c8c:	df000f15 	stw	fp,60(sp)
 8217c90:	df000f04 	addi	fp,sp,60
 8217c94:	e13ffc15 	stw	r4,-16(fp)
 8217c98:	2807883a 	mov	r3,r5
 8217c9c:	3005883a 	mov	r2,r6
 8217ca0:	e1ffff15 	stw	r7,-4(fp)
 8217ca4:	e0fffd0d 	sth	r3,-12(fp)
 8217ca8:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
 8217cac:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 8217cb0:	e0bfff17 	ldw	r2,-4(fp)
 8217cb4:	1000021e 	bne	r2,zero,8217cc0 <OSFlagPost+0x3c>
        return ((OS_FLAGS)0);
 8217cb8:	0005883a 	mov	r2,zero
 8217cbc:	0000d106 	br	8218004 <OSFlagPost+0x380>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
 8217cc0:	e0bffc17 	ldw	r2,-16(fp)
 8217cc4:	1000051e 	bne	r2,zero,8217cdc <OSFlagPost+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8217cc8:	e0bfff17 	ldw	r2,-4(fp)
 8217ccc:	00c01b84 	movi	r3,110
 8217cd0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217cd4:	0005883a 	mov	r2,zero
 8217cd8:	0000ca06 	br	8218004 <OSFlagPost+0x380>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
 8217cdc:	e0bffc17 	ldw	r2,-16(fp)
 8217ce0:	10800003 	ldbu	r2,0(r2)
 8217ce4:	10803fcc 	andi	r2,r2,255
 8217ce8:	10800160 	cmpeqi	r2,r2,5
 8217cec:	1000051e 	bne	r2,zero,8217d04 <OSFlagPost+0x80>
        *perr = OS_ERR_EVENT_TYPE;
 8217cf0:	e0bfff17 	ldw	r2,-4(fp)
 8217cf4:	00c00044 	movi	r3,1
 8217cf8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217cfc:	0005883a 	mov	r2,zero
 8217d00:	0000c006 	br	8218004 <OSFlagPost+0x380>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217d04:	0005303a 	rdctl	r2,status
 8217d08:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217d0c:	e0fffb17 	ldw	r3,-20(fp)
 8217d10:	00bfff84 	movi	r2,-2
 8217d14:	1884703a 	and	r2,r3,r2
 8217d18:	1001703a 	wrctl	status,r2
  
  return context;
 8217d1c:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 8217d20:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
 8217d24:	e0bffe03 	ldbu	r2,-8(fp)
 8217d28:	10000326 	beq	r2,zero,8217d38 <OSFlagPost+0xb4>
 8217d2c:	10800060 	cmpeqi	r2,r2,1
 8217d30:	10000b1e 	bne	r2,zero,8217d60 <OSFlagPost+0xdc>
 8217d34:	00001206 	br	8217d80 <OSFlagPost+0xfc>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
 8217d38:	e0bffc17 	ldw	r2,-16(fp)
 8217d3c:	1080020b 	ldhu	r2,8(r2)
 8217d40:	1007883a 	mov	r3,r2
 8217d44:	e0bffd0b 	ldhu	r2,-12(fp)
 8217d48:	0084303a 	nor	r2,zero,r2
 8217d4c:	1884703a 	and	r2,r3,r2
 8217d50:	1007883a 	mov	r3,r2
 8217d54:	e0bffc17 	ldw	r2,-16(fp)
 8217d58:	10c0020d 	sth	r3,8(r2)
             break;
 8217d5c:	00001106 	br	8217da4 <OSFlagPost+0x120>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
 8217d60:	e0bffc17 	ldw	r2,-16(fp)
 8217d64:	10c0020b 	ldhu	r3,8(r2)
 8217d68:	e0bffd0b 	ldhu	r2,-12(fp)
 8217d6c:	1884b03a 	or	r2,r3,r2
 8217d70:	1007883a 	mov	r3,r2
 8217d74:	e0bffc17 	ldw	r2,-16(fp)
 8217d78:	10c0020d 	sth	r3,8(r2)
             break;
 8217d7c:	00000906 	br	8217da4 <OSFlagPost+0x120>
 8217d80:	e0bff317 	ldw	r2,-52(fp)
 8217d84:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217d88:	e0bff417 	ldw	r2,-48(fp)
 8217d8c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
 8217d90:	e0bfff17 	ldw	r2,-4(fp)
 8217d94:	00c01c44 	movi	r3,113
 8217d98:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
 8217d9c:	0005883a 	mov	r2,zero
 8217da0:	00009806 	br	8218004 <OSFlagPost+0x380>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
 8217da4:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 8217da8:	e0bffc17 	ldw	r2,-16(fp)
 8217dac:	10800117 	ldw	r2,4(r2)
 8217db0:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 8217db4:	00007706 	br	8217f94 <OSFlagPost+0x310>
        switch (pnode->OSFlagNodeWaitType) {
 8217db8:	e0bff117 	ldw	r2,-60(fp)
 8217dbc:	10800483 	ldbu	r2,18(r2)
 8217dc0:	10803fcc 	andi	r2,r2,255
 8217dc4:	10c00060 	cmpeqi	r3,r2,1
 8217dc8:	18004a1e 	bne	r3,zero,8217ef4 <OSFlagPost+0x270>
 8217dcc:	10c00088 	cmpgei	r3,r2,2
 8217dd0:	1800021e 	bne	r3,zero,8217ddc <OSFlagPost+0x158>
 8217dd4:	10002f26 	beq	r2,zero,8217e94 <OSFlagPost+0x210>
 8217dd8:	00005b06 	br	8217f48 <OSFlagPost+0x2c4>
 8217ddc:	10c000a0 	cmpeqi	r3,r2,2
 8217de0:	1800031e 	bne	r3,zero,8217df0 <OSFlagPost+0x16c>
 8217de4:	108000e0 	cmpeqi	r2,r2,3
 8217de8:	1000171e 	bne	r2,zero,8217e48 <OSFlagPost+0x1c4>
 8217dec:	00005606 	br	8217f48 <OSFlagPost+0x2c4>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 8217df0:	e0bffc17 	ldw	r2,-16(fp)
 8217df4:	10c0020b 	ldhu	r3,8(r2)
 8217df8:	e0bff117 	ldw	r2,-60(fp)
 8217dfc:	1080040b 	ldhu	r2,16(r2)
 8217e00:	1884703a 	and	r2,r3,r2
 8217e04:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 8217e08:	e0bff117 	ldw	r2,-60(fp)
 8217e0c:	1080040b 	ldhu	r2,16(r2)
 8217e10:	10ffffcc 	andi	r3,r2,65535
 8217e14:	e0bff60b 	ldhu	r2,-40(fp)
 8217e18:	1880541e 	bne	r3,r2,8217f6c <OSFlagPost+0x2e8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 8217e1c:	e0bff60b 	ldhu	r2,-40(fp)
 8217e20:	100b883a 	mov	r5,r2
 8217e24:	e13ff117 	ldw	r4,-60(fp)
 8217e28:	821831c0 	call	821831c <OS_FlagTaskRdy>
 8217e2c:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 8217e30:	e0bff683 	ldbu	r2,-38(fp)
 8217e34:	10800058 	cmpnei	r2,r2,1
 8217e38:	10004c1e 	bne	r2,zero,8217f6c <OSFlagPost+0x2e8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 8217e3c:	00800044 	movi	r2,1
 8217e40:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 8217e44:	00004906 	br	8217f6c <OSFlagPost+0x2e8>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 8217e48:	e0bffc17 	ldw	r2,-16(fp)
 8217e4c:	10c0020b 	ldhu	r3,8(r2)
 8217e50:	e0bff117 	ldw	r2,-60(fp)
 8217e54:	1080040b 	ldhu	r2,16(r2)
 8217e58:	1884703a 	and	r2,r3,r2
 8217e5c:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 8217e60:	e0bff60b 	ldhu	r2,-40(fp)
 8217e64:	10004326 	beq	r2,zero,8217f74 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 8217e68:	e0bff60b 	ldhu	r2,-40(fp)
 8217e6c:	100b883a 	mov	r5,r2
 8217e70:	e13ff117 	ldw	r4,-60(fp)
 8217e74:	821831c0 	call	821831c <OS_FlagTaskRdy>
 8217e78:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 8217e7c:	e0bff683 	ldbu	r2,-38(fp)
 8217e80:	10800058 	cmpnei	r2,r2,1
 8217e84:	10003b1e 	bne	r2,zero,8217f74 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 8217e88:	00800044 	movi	r2,1
 8217e8c:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 8217e90:	00003806 	br	8217f74 <OSFlagPost+0x2f0>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 8217e94:	e0bffc17 	ldw	r2,-16(fp)
 8217e98:	1080020b 	ldhu	r2,8(r2)
 8217e9c:	0084303a 	nor	r2,zero,r2
 8217ea0:	1007883a 	mov	r3,r2
 8217ea4:	e0bff117 	ldw	r2,-60(fp)
 8217ea8:	1080040b 	ldhu	r2,16(r2)
 8217eac:	1884703a 	and	r2,r3,r2
 8217eb0:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 8217eb4:	e0bff117 	ldw	r2,-60(fp)
 8217eb8:	1080040b 	ldhu	r2,16(r2)
 8217ebc:	10ffffcc 	andi	r3,r2,65535
 8217ec0:	e0bff60b 	ldhu	r2,-40(fp)
 8217ec4:	18802d1e 	bne	r3,r2,8217f7c <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 8217ec8:	e0bff60b 	ldhu	r2,-40(fp)
 8217ecc:	100b883a 	mov	r5,r2
 8217ed0:	e13ff117 	ldw	r4,-60(fp)
 8217ed4:	821831c0 	call	821831c <OS_FlagTaskRdy>
 8217ed8:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 8217edc:	e0bff683 	ldbu	r2,-38(fp)
 8217ee0:	10800058 	cmpnei	r2,r2,1
 8217ee4:	1000251e 	bne	r2,zero,8217f7c <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 8217ee8:	00800044 	movi	r2,1
 8217eec:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 8217ef0:	00002206 	br	8217f7c <OSFlagPost+0x2f8>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 8217ef4:	e0bffc17 	ldw	r2,-16(fp)
 8217ef8:	1080020b 	ldhu	r2,8(r2)
 8217efc:	0084303a 	nor	r2,zero,r2
 8217f00:	1007883a 	mov	r3,r2
 8217f04:	e0bff117 	ldw	r2,-60(fp)
 8217f08:	1080040b 	ldhu	r2,16(r2)
 8217f0c:	1884703a 	and	r2,r3,r2
 8217f10:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 8217f14:	e0bff60b 	ldhu	r2,-40(fp)
 8217f18:	10001a26 	beq	r2,zero,8217f84 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 8217f1c:	e0bff60b 	ldhu	r2,-40(fp)
 8217f20:	100b883a 	mov	r5,r2
 8217f24:	e13ff117 	ldw	r4,-60(fp)
 8217f28:	821831c0 	call	821831c <OS_FlagTaskRdy>
 8217f2c:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 8217f30:	e0bff683 	ldbu	r2,-38(fp)
 8217f34:	10800058 	cmpnei	r2,r2,1
 8217f38:	1000121e 	bne	r2,zero,8217f84 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 8217f3c:	00800044 	movi	r2,1
 8217f40:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 8217f44:	00000f06 	br	8217f84 <OSFlagPost+0x300>
 8217f48:	e0bff317 	ldw	r2,-52(fp)
 8217f4c:	e0bff515 	stw	r2,-44(fp)
 8217f50:	e0bff517 	ldw	r2,-44(fp)
 8217f54:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 8217f58:	e0bfff17 	ldw	r2,-4(fp)
 8217f5c:	00c01bc4 	movi	r3,111
 8217f60:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
 8217f64:	0005883a 	mov	r2,zero
 8217f68:	00002606 	br	8218004 <OSFlagPost+0x380>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 8217f6c:	0001883a 	nop
 8217f70:	00000506 	br	8217f88 <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 8217f74:	0001883a 	nop
 8217f78:	00000306 	br	8217f88 <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 8217f7c:	0001883a 	nop
 8217f80:	00000106 	br	8217f88 <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 8217f84:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
 8217f88:	e0bff117 	ldw	r2,-60(fp)
 8217f8c:	10800017 	ldw	r2,0(r2)
 8217f90:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 8217f94:	e0bff117 	ldw	r2,-60(fp)
 8217f98:	103f871e 	bne	r2,zero,8217db8 <OSFlagPost+0x134>
 8217f9c:	e0bff317 	ldw	r2,-52(fp)
 8217fa0:	e0bff715 	stw	r2,-36(fp)
 8217fa4:	e0bff717 	ldw	r2,-36(fp)
 8217fa8:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
 8217fac:	e0bff203 	ldbu	r2,-56(fp)
 8217fb0:	10800058 	cmpnei	r2,r2,1
 8217fb4:	1000011e 	bne	r2,zero,8217fbc <OSFlagPost+0x338>
        OS_Sched();
 8217fb8:	82165240 	call	8216524 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217fbc:	0005303a 	rdctl	r2,status
 8217fc0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217fc4:	e0fffa17 	ldw	r3,-24(fp)
 8217fc8:	00bfff84 	movi	r2,-2
 8217fcc:	1884703a 	and	r2,r3,r2
 8217fd0:	1001703a 	wrctl	status,r2
  
  return context;
 8217fd4:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 8217fd8:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
 8217fdc:	e0bffc17 	ldw	r2,-16(fp)
 8217fe0:	1080020b 	ldhu	r2,8(r2)
 8217fe4:	e0bff90d 	sth	r2,-28(fp)
 8217fe8:	e0bff317 	ldw	r2,-52(fp)
 8217fec:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217ff0:	e0bff817 	ldw	r2,-32(fp)
 8217ff4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
 8217ff8:	e0bfff17 	ldw	r2,-4(fp)
 8217ffc:	10000005 	stb	zero,0(r2)
    return (flags_cur);
 8218000:	e0bff90b 	ldhu	r2,-28(fp)
}
 8218004:	e037883a 	mov	sp,fp
 8218008:	dfc00117 	ldw	ra,4(sp)
 821800c:	df000017 	ldw	fp,0(sp)
 8218010:	dec00204 	addi	sp,sp,8
 8218014:	f800283a 	ret

08218018 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
 8218018:	defff904 	addi	sp,sp,-28
 821801c:	df000615 	stw	fp,24(sp)
 8218020:	df000604 	addi	fp,sp,24
 8218024:	e13ffe15 	stw	r4,-8(fp)
 8218028:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
 821802c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
 8218030:	e0bfff17 	ldw	r2,-4(fp)
 8218034:	1000021e 	bne	r2,zero,8218040 <OSFlagQuery+0x28>
        return ((OS_FLAGS)0);
 8218038:	0005883a 	mov	r2,zero
 821803c:	00002306 	br	82180cc <OSFlagQuery+0xb4>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
 8218040:	e0bffe17 	ldw	r2,-8(fp)
 8218044:	1000051e 	bne	r2,zero,821805c <OSFlagQuery+0x44>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8218048:	e0bfff17 	ldw	r2,-4(fp)
 821804c:	00c01b84 	movi	r3,110
 8218050:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8218054:	0005883a 	mov	r2,zero
 8218058:	00001c06 	br	82180cc <OSFlagQuery+0xb4>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
 821805c:	e0bffe17 	ldw	r2,-8(fp)
 8218060:	10800003 	ldbu	r2,0(r2)
 8218064:	10803fcc 	andi	r2,r2,255
 8218068:	10800160 	cmpeqi	r2,r2,5
 821806c:	1000051e 	bne	r2,zero,8218084 <OSFlagQuery+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
 8218070:	e0bfff17 	ldw	r2,-4(fp)
 8218074:	00c00044 	movi	r3,1
 8218078:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 821807c:	0005883a 	mov	r2,zero
 8218080:	00001206 	br	82180cc <OSFlagQuery+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218084:	0005303a 	rdctl	r2,status
 8218088:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821808c:	e0fffc17 	ldw	r3,-16(fp)
 8218090:	00bfff84 	movi	r2,-2
 8218094:	1884703a 	and	r2,r3,r2
 8218098:	1001703a 	wrctl	status,r2
  
  return context;
 821809c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 82180a0:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
 82180a4:	e0bffe17 	ldw	r2,-8(fp)
 82180a8:	1080020b 	ldhu	r2,8(r2)
 82180ac:	e0bffb0d 	sth	r2,-20(fp)
 82180b0:	e0bffa17 	ldw	r2,-24(fp)
 82180b4:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82180b8:	e0bffd17 	ldw	r2,-12(fp)
 82180bc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 82180c0:	e0bfff17 	ldw	r2,-4(fp)
 82180c4:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
 82180c8:	e0bffb0b 	ldhu	r2,-20(fp)
}
 82180cc:	e037883a 	mov	sp,fp
 82180d0:	df000017 	ldw	fp,0(sp)
 82180d4:	dec00104 	addi	sp,sp,4
 82180d8:	f800283a 	ret

082180dc <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
 82180dc:	defff804 	addi	sp,sp,-32
 82180e0:	df000715 	stw	fp,28(sp)
 82180e4:	df000704 	addi	fp,sp,28
 82180e8:	e13ffb15 	stw	r4,-20(fp)
 82180ec:	e17ffc15 	stw	r5,-16(fp)
 82180f0:	3009883a 	mov	r4,r6
 82180f4:	3807883a 	mov	r3,r7
 82180f8:	e0800117 	ldw	r2,4(fp)
 82180fc:	e13ffd0d 	sth	r4,-12(fp)
 8218100:	e0fffe05 	stb	r3,-8(fp)
 8218104:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
 8218108:	d0a07a17 	ldw	r2,-32280(gp)
 821810c:	d0e07a17 	ldw	r3,-32280(gp)
 8218110:	18c00c03 	ldbu	r3,48(r3)
 8218114:	18c00814 	ori	r3,r3,32
 8218118:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
 821811c:	d0a07a17 	ldw	r2,-32280(gp)
 8218120:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
 8218124:	d0a07a17 	ldw	r2,-32280(gp)
 8218128:	e0ffff0b 	ldhu	r3,-4(fp)
 821812c:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
 8218130:	d0a07a17 	ldw	r2,-32280(gp)
 8218134:	e0fffc17 	ldw	r3,-16(fp)
 8218138:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
 821813c:	e0bffc17 	ldw	r2,-16(fp)
 8218140:	e0fffd0b 	ldhu	r3,-12(fp)
 8218144:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
 8218148:	e0bffc17 	ldw	r2,-16(fp)
 821814c:	e0fffe03 	ldbu	r3,-8(fp)
 8218150:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
 8218154:	d0e07a17 	ldw	r3,-32280(gp)
 8218158:	e0bffc17 	ldw	r2,-16(fp)
 821815c:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
 8218160:	e0bffb17 	ldw	r2,-20(fp)
 8218164:	10c00117 	ldw	r3,4(r2)
 8218168:	e0bffc17 	ldw	r2,-16(fp)
 821816c:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
 8218170:	e0bffc17 	ldw	r2,-16(fp)
 8218174:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
 8218178:	e0bffc17 	ldw	r2,-16(fp)
 821817c:	e0fffb17 	ldw	r3,-20(fp)
 8218180:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 8218184:	e0bffb17 	ldw	r2,-20(fp)
 8218188:	10800117 	ldw	r2,4(r2)
 821818c:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
 8218190:	e0bff917 	ldw	r2,-28(fp)
 8218194:	10000326 	beq	r2,zero,82181a4 <OS_FlagBlock+0xc8>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
 8218198:	e0bff917 	ldw	r2,-28(fp)
 821819c:	e0fffc17 	ldw	r3,-16(fp)
 82181a0:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
 82181a4:	e0bffb17 	ldw	r2,-20(fp)
 82181a8:	e0fffc17 	ldw	r3,-16(fp)
 82181ac:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
 82181b0:	d0a07a17 	ldw	r2,-32280(gp)
 82181b4:	10800d03 	ldbu	r2,52(r2)
 82181b8:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 82181bc:	e0fffa03 	ldbu	r3,-24(fp)
 82181c0:	e13ffa03 	ldbu	r4,-24(fp)
 82181c4:	d0a07744 	addi	r2,gp,-32291
 82181c8:	2085883a 	add	r2,r4,r2
 82181cc:	10800003 	ldbu	r2,0(r2)
 82181d0:	1009883a 	mov	r4,r2
 82181d4:	d0a07a17 	ldw	r2,-32280(gp)
 82181d8:	10800d43 	ldbu	r2,53(r2)
 82181dc:	0084303a 	nor	r2,zero,r2
 82181e0:	2084703a 	and	r2,r4,r2
 82181e4:	1009883a 	mov	r4,r2
 82181e8:	d0a07744 	addi	r2,gp,-32291
 82181ec:	1885883a 	add	r2,r3,r2
 82181f0:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
 82181f4:	e0fffa03 	ldbu	r3,-24(fp)
 82181f8:	d0a07744 	addi	r2,gp,-32291
 82181fc:	1885883a 	add	r2,r3,r2
 8218200:	10800003 	ldbu	r2,0(r2)
 8218204:	10803fcc 	andi	r2,r2,255
 8218208:	1000071e 	bne	r2,zero,8218228 <OS_FlagBlock+0x14c>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 821820c:	d0a07a17 	ldw	r2,-32280(gp)
 8218210:	10800d83 	ldbu	r2,54(r2)
 8218214:	0084303a 	nor	r2,zero,r2
 8218218:	1007883a 	mov	r3,r2
 821821c:	d0a07703 	ldbu	r2,-32292(gp)
 8218220:	1884703a 	and	r2,r3,r2
 8218224:	d0a07705 	stb	r2,-32292(gp)
    }
}
 8218228:	0001883a 	nop
 821822c:	e037883a 	mov	sp,fp
 8218230:	df000017 	ldw	fp,0(sp)
 8218234:	dec00104 	addi	sp,sp,4
 8218238:	f800283a 	ret

0821823c <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
 821823c:	defffb04 	addi	sp,sp,-20
 8218240:	dfc00415 	stw	ra,16(sp)
 8218244:	df000315 	stw	fp,12(sp)
 8218248:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
 821824c:	0140dc04 	movi	r5,880
 8218250:	010209b4 	movhi	r4,2086
 8218254:	212a3504 	addi	r4,r4,-22316
 8218258:	82164680 	call	8216468 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
 821825c:	008209b4 	movhi	r2,2086
 8218260:	10aa3504 	addi	r2,r2,-22316
 8218264:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
 8218268:	008209b4 	movhi	r2,2086
 821826c:	10aa4004 	addi	r2,r2,-22272
 8218270:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 8218274:	e03ffd0d 	sth	zero,-12(fp)
 8218278:	00001306 	br	82182c8 <OS_FlagInit+0x8c>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 821827c:	e0bffe17 	ldw	r2,-8(fp)
 8218280:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
 8218284:	e0bffe17 	ldw	r2,-8(fp)
 8218288:	e0ffff17 	ldw	r3,-4(fp)
 821828c:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
 8218290:	e0bffe17 	ldw	r2,-8(fp)
 8218294:	00c00fc4 	movi	r3,63
 8218298:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 821829c:	e0bffe17 	ldw	r2,-8(fp)
 82182a0:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
 82182a4:	e0bffe17 	ldw	r2,-8(fp)
 82182a8:	10800b04 	addi	r2,r2,44
 82182ac:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
 82182b0:	e0bfff17 	ldw	r2,-4(fp)
 82182b4:	10800b04 	addi	r2,r2,44
 82182b8:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 82182bc:	e0bffd0b 	ldhu	r2,-12(fp)
 82182c0:	10800044 	addi	r2,r2,1
 82182c4:	e0bffd0d 	sth	r2,-12(fp)
 82182c8:	e0bffd0b 	ldhu	r2,-12(fp)
 82182cc:	108004f0 	cmpltui	r2,r2,19
 82182d0:	103fea1e 	bne	r2,zero,821827c <OS_FlagInit+0x40>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 82182d4:	e0bffe17 	ldw	r2,-8(fp)
 82182d8:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
 82182dc:	e0bffe17 	ldw	r2,-8(fp)
 82182e0:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
 82182e4:	e0bffe17 	ldw	r2,-8(fp)
 82182e8:	00c00fc4 	movi	r3,63
 82182ec:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 82182f0:	e0bffe17 	ldw	r2,-8(fp)
 82182f4:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
 82182f8:	008209b4 	movhi	r2,2086
 82182fc:	10aa3504 	addi	r2,r2,-22316
 8218300:	d0a07c15 	stw	r2,-32272(gp)
#endif
}
 8218304:	0001883a 	nop
 8218308:	e037883a 	mov	sp,fp
 821830c:	dfc00117 	ldw	ra,4(sp)
 8218310:	df000017 	ldw	fp,0(sp)
 8218314:	dec00204 	addi	sp,sp,8
 8218318:	f800283a 	ret

0821831c <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
 821831c:	defffa04 	addi	sp,sp,-24
 8218320:	dfc00515 	stw	ra,20(sp)
 8218324:	df000415 	stw	fp,16(sp)
 8218328:	df000404 	addi	fp,sp,16
 821832c:	e13ffe15 	stw	r4,-8(fp)
 8218330:	2805883a 	mov	r2,r5
 8218334:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
 8218338:	e0bffe17 	ldw	r2,-8(fp)
 821833c:	10800217 	ldw	r2,8(r2)
 8218340:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
 8218344:	e0bffd17 	ldw	r2,-12(fp)
 8218348:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
 821834c:	e0bffd17 	ldw	r2,-12(fp)
 8218350:	e0ffff0b 	ldhu	r3,-4(fp)
 8218354:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
 8218358:	e0bffd17 	ldw	r2,-12(fp)
 821835c:	10c00c03 	ldbu	r3,48(r2)
 8218360:	00bff7c4 	movi	r2,-33
 8218364:	1884703a 	and	r2,r3,r2
 8218368:	1007883a 	mov	r3,r2
 821836c:	e0bffd17 	ldw	r2,-12(fp)
 8218370:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
 8218374:	e0bffd17 	ldw	r2,-12(fp)
 8218378:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
 821837c:	e0bffd17 	ldw	r2,-12(fp)
 8218380:	10800c03 	ldbu	r2,48(r2)
 8218384:	10803fcc 	andi	r2,r2,255
 8218388:	1000181e 	bne	r2,zero,82183ec <OS_FlagTaskRdy+0xd0>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
 821838c:	e0bffd17 	ldw	r2,-12(fp)
 8218390:	10c00d83 	ldbu	r3,54(r2)
 8218394:	d0a07703 	ldbu	r2,-32292(gp)
 8218398:	1884b03a 	or	r2,r3,r2
 821839c:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 82183a0:	e0bffd17 	ldw	r2,-12(fp)
 82183a4:	10800d03 	ldbu	r2,52(r2)
 82183a8:	10c03fcc 	andi	r3,r2,255
 82183ac:	e0bffd17 	ldw	r2,-12(fp)
 82183b0:	10800d03 	ldbu	r2,52(r2)
 82183b4:	11003fcc 	andi	r4,r2,255
 82183b8:	d0a07744 	addi	r2,gp,-32291
 82183bc:	2085883a 	add	r2,r4,r2
 82183c0:	11000003 	ldbu	r4,0(r2)
 82183c4:	e0bffd17 	ldw	r2,-12(fp)
 82183c8:	10800d43 	ldbu	r2,53(r2)
 82183cc:	2084b03a 	or	r2,r4,r2
 82183d0:	1009883a 	mov	r4,r2
 82183d4:	d0a07744 	addi	r2,gp,-32291
 82183d8:	1885883a 	add	r2,r3,r2
 82183dc:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
 82183e0:	00800044 	movi	r2,1
 82183e4:	e0bffc05 	stb	r2,-16(fp)
 82183e8:	00000106 	br	82183f0 <OS_FlagTaskRdy+0xd4>
    } else {
        sched                   = OS_FALSE;
 82183ec:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
 82183f0:	e13ffe17 	ldw	r4,-8(fp)
 82183f4:	82184100 	call	8218410 <OS_FlagUnlink>
    return (sched);
 82183f8:	e0bffc03 	ldbu	r2,-16(fp)
}
 82183fc:	e037883a 	mov	sp,fp
 8218400:	dfc00117 	ldw	ra,4(sp)
 8218404:	df000017 	ldw	fp,0(sp)
 8218408:	dec00204 	addi	sp,sp,8
 821840c:	f800283a 	ret

08218410 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
 8218410:	defffa04 	addi	sp,sp,-24
 8218414:	df000515 	stw	fp,20(sp)
 8218418:	df000504 	addi	fp,sp,20
 821841c:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
 8218420:	e0bfff17 	ldw	r2,-4(fp)
 8218424:	10800117 	ldw	r2,4(r2)
 8218428:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 821842c:	e0bfff17 	ldw	r2,-4(fp)
 8218430:	10800017 	ldw	r2,0(r2)
 8218434:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
 8218438:	e0bffb17 	ldw	r2,-20(fp)
 821843c:	10000b1e 	bne	r2,zero,821846c <OS_FlagUnlink+0x5c>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
 8218440:	e0bfff17 	ldw	r2,-4(fp)
 8218444:	10800317 	ldw	r2,12(r2)
 8218448:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
 821844c:	e0bffd17 	ldw	r2,-12(fp)
 8218450:	e0fffc17 	ldw	r3,-16(fp)
 8218454:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
 8218458:	e0bffc17 	ldw	r2,-16(fp)
 821845c:	10000b26 	beq	r2,zero,821848c <OS_FlagUnlink+0x7c>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
 8218460:	e0bffc17 	ldw	r2,-16(fp)
 8218464:	10000115 	stw	zero,4(r2)
 8218468:	00000806 	br	821848c <OS_FlagUnlink+0x7c>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
 821846c:	e0bffb17 	ldw	r2,-20(fp)
 8218470:	e0fffc17 	ldw	r3,-16(fp)
 8218474:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
 8218478:	e0bffc17 	ldw	r2,-16(fp)
 821847c:	10000326 	beq	r2,zero,821848c <OS_FlagUnlink+0x7c>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
 8218480:	e0bffc17 	ldw	r2,-16(fp)
 8218484:	e0fffb17 	ldw	r3,-20(fp)
 8218488:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
 821848c:	e0bfff17 	ldw	r2,-4(fp)
 8218490:	10800217 	ldw	r2,8(r2)
 8218494:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
 8218498:	e0bffe17 	ldw	r2,-8(fp)
 821849c:	10000a15 	stw	zero,40(r2)
#endif
}
 82184a0:	0001883a 	nop
 82184a4:	e037883a 	mov	sp,fp
 82184a8:	df000017 	ldw	fp,0(sp)
 82184ac:	dec00104 	addi	sp,sp,4
 82184b0:	f800283a 	ret

082184b4 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
 82184b4:	defff404 	addi	sp,sp,-48
 82184b8:	df000b15 	stw	fp,44(sp)
 82184bc:	df000b04 	addi	fp,sp,44
 82184c0:	e13ffc15 	stw	r4,-16(fp)
 82184c4:	e17ffd15 	stw	r5,-12(fp)
 82184c8:	e1bffe15 	stw	r6,-8(fp)
 82184cc:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 82184d0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 82184d4:	e0bfff17 	ldw	r2,-4(fp)
 82184d8:	1000021e 	bne	r2,zero,82184e4 <OSMemCreate+0x30>
        return ((OS_MEM *)0);
 82184dc:	0005883a 	mov	r2,zero
 82184e0:	00006506 	br	8218678 <OSMemCreate+0x1c4>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
 82184e4:	e0bffc17 	ldw	r2,-16(fp)
 82184e8:	1000051e 	bne	r2,zero,8218500 <OSMemCreate+0x4c>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 82184ec:	e0bfff17 	ldw	r2,-4(fp)
 82184f0:	00c01884 	movi	r3,98
 82184f4:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 82184f8:	0005883a 	mov	r2,zero
 82184fc:	00005e06 	br	8218678 <OSMemCreate+0x1c4>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
 8218500:	e0bffc17 	ldw	r2,-16(fp)
 8218504:	108000cc 	andi	r2,r2,3
 8218508:	10000526 	beq	r2,zero,8218520 <OSMemCreate+0x6c>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 821850c:	e0bfff17 	ldw	r2,-4(fp)
 8218510:	00c01884 	movi	r3,98
 8218514:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 8218518:	0005883a 	mov	r2,zero
 821851c:	00005606 	br	8218678 <OSMemCreate+0x1c4>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
 8218520:	e0bffd17 	ldw	r2,-12(fp)
 8218524:	108000a8 	cmpgeui	r2,r2,2
 8218528:	1000051e 	bne	r2,zero,8218540 <OSMemCreate+0x8c>
        *perr = OS_ERR_MEM_INVALID_BLKS;
 821852c:	e0bfff17 	ldw	r2,-4(fp)
 8218530:	00c016c4 	movi	r3,91
 8218534:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 8218538:	0005883a 	mov	r2,zero
 821853c:	00004e06 	br	8218678 <OSMemCreate+0x1c4>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
 8218540:	e0bffe17 	ldw	r2,-8(fp)
 8218544:	10800128 	cmpgeui	r2,r2,4
 8218548:	1000051e 	bne	r2,zero,8218560 <OSMemCreate+0xac>
        *perr = OS_ERR_MEM_INVALID_SIZE;
 821854c:	e0bfff17 	ldw	r2,-4(fp)
 8218550:	00c01704 	movi	r3,92
 8218554:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 8218558:	0005883a 	mov	r2,zero
 821855c:	00004606 	br	8218678 <OSMemCreate+0x1c4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218560:	0005303a 	rdctl	r2,status
 8218564:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218568:	e0fffb17 	ldw	r3,-20(fp)
 821856c:	00bfff84 	movi	r2,-2
 8218570:	1884703a 	and	r2,r3,r2
 8218574:	1001703a 	wrctl	status,r2
  
  return context;
 8218578:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821857c:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
 8218580:	d0a07417 	ldw	r2,-32304(gp)
 8218584:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
 8218588:	d0a07417 	ldw	r2,-32304(gp)
 821858c:	10000326 	beq	r2,zero,821859c <OSMemCreate+0xe8>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
 8218590:	d0a07417 	ldw	r2,-32304(gp)
 8218594:	10800117 	ldw	r2,4(r2)
 8218598:	d0a07415 	stw	r2,-32304(gp)
 821859c:	e0bff817 	ldw	r2,-32(fp)
 82185a0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82185a4:	e0bff917 	ldw	r2,-28(fp)
 82185a8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
 82185ac:	e0bffa17 	ldw	r2,-24(fp)
 82185b0:	1000051e 	bne	r2,zero,82185c8 <OSMemCreate+0x114>
        *perr = OS_ERR_MEM_INVALID_PART;
 82185b4:	e0bfff17 	ldw	r2,-4(fp)
 82185b8:	00c01684 	movi	r3,90
 82185bc:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 82185c0:	0005883a 	mov	r2,zero
 82185c4:	00002c06 	br	8218678 <OSMemCreate+0x1c4>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
 82185c8:	e0bffc17 	ldw	r2,-16(fp)
 82185cc:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
 82185d0:	e0fffc17 	ldw	r3,-16(fp)
 82185d4:	e0bffe17 	ldw	r2,-8(fp)
 82185d8:	1885883a 	add	r2,r3,r2
 82185dc:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
 82185e0:	e03ff715 	stw	zero,-36(fp)
 82185e4:	00000c06 	br	8218618 <OSMemCreate+0x164>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
 82185e8:	e0bff617 	ldw	r2,-40(fp)
 82185ec:	e0fff517 	ldw	r3,-44(fp)
 82185f0:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
 82185f4:	e0bff517 	ldw	r2,-44(fp)
 82185f8:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
 82185fc:	e0fff517 	ldw	r3,-44(fp)
 8218600:	e0bffe17 	ldw	r2,-8(fp)
 8218604:	1885883a 	add	r2,r3,r2
 8218608:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
 821860c:	e0bff717 	ldw	r2,-36(fp)
 8218610:	10800044 	addi	r2,r2,1
 8218614:	e0bff715 	stw	r2,-36(fp)
 8218618:	e0bffd17 	ldw	r2,-12(fp)
 821861c:	10bfffc4 	addi	r2,r2,-1
 8218620:	e0fff717 	ldw	r3,-36(fp)
 8218624:	18bff036 	bltu	r3,r2,82185e8 <OSMemCreate+0x134>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
 8218628:	e0bff617 	ldw	r2,-40(fp)
 821862c:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
 8218630:	e0bffa17 	ldw	r2,-24(fp)
 8218634:	e0fffc17 	ldw	r3,-16(fp)
 8218638:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
 821863c:	e0bffa17 	ldw	r2,-24(fp)
 8218640:	e0fffc17 	ldw	r3,-16(fp)
 8218644:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
 8218648:	e0bffa17 	ldw	r2,-24(fp)
 821864c:	e0fffd17 	ldw	r3,-12(fp)
 8218650:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
 8218654:	e0bffa17 	ldw	r2,-24(fp)
 8218658:	e0fffd17 	ldw	r3,-12(fp)
 821865c:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
 8218660:	e0bffa17 	ldw	r2,-24(fp)
 8218664:	e0fffe17 	ldw	r3,-8(fp)
 8218668:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
 821866c:	e0bfff17 	ldw	r2,-4(fp)
 8218670:	10000005 	stb	zero,0(r2)
    return (pmem);
 8218674:	e0bffa17 	ldw	r2,-24(fp)
}
 8218678:	e037883a 	mov	sp,fp
 821867c:	df000017 	ldw	fp,0(sp)
 8218680:	dec00104 	addi	sp,sp,4
 8218684:	f800283a 	ret

08218688 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
 8218688:	defff804 	addi	sp,sp,-32
 821868c:	df000715 	stw	fp,28(sp)
 8218690:	df000704 	addi	fp,sp,28
 8218694:	e13ffe15 	stw	r4,-8(fp)
 8218698:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821869c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 82186a0:	e0bfff17 	ldw	r2,-4(fp)
 82186a4:	1000021e 	bne	r2,zero,82186b0 <OSMemGet+0x28>
        return ((void *)0);
 82186a8:	0005883a 	mov	r2,zero
 82186ac:	00002e06 	br	8218768 <OSMemGet+0xe0>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
 82186b0:	e0bffe17 	ldw	r2,-8(fp)
 82186b4:	1000051e 	bne	r2,zero,82186cc <OSMemGet+0x44>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 82186b8:	e0bfff17 	ldw	r2,-4(fp)
 82186bc:	00c01804 	movi	r3,96
 82186c0:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 82186c4:	0005883a 	mov	r2,zero
 82186c8:	00002706 	br	8218768 <OSMemGet+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82186cc:	0005303a 	rdctl	r2,status
 82186d0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82186d4:	e0fffd17 	ldw	r3,-12(fp)
 82186d8:	00bfff84 	movi	r2,-2
 82186dc:	1884703a 	and	r2,r3,r2
 82186e0:	1001703a 	wrctl	status,r2
  
  return context;
 82186e4:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 82186e8:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
 82186ec:	e0bffe17 	ldw	r2,-8(fp)
 82186f0:	10800417 	ldw	r2,16(r2)
 82186f4:	10001426 	beq	r2,zero,8218748 <OSMemGet+0xc0>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
 82186f8:	e0bffe17 	ldw	r2,-8(fp)
 82186fc:	10800117 	ldw	r2,4(r2)
 8218700:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
 8218704:	e0bffb17 	ldw	r2,-20(fp)
 8218708:	10c00017 	ldw	r3,0(r2)
 821870c:	e0bffe17 	ldw	r2,-8(fp)
 8218710:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
 8218714:	e0bffe17 	ldw	r2,-8(fp)
 8218718:	10800417 	ldw	r2,16(r2)
 821871c:	10ffffc4 	addi	r3,r2,-1
 8218720:	e0bffe17 	ldw	r2,-8(fp)
 8218724:	10c00415 	stw	r3,16(r2)
 8218728:	e0bff917 	ldw	r2,-28(fp)
 821872c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218730:	e0bffa17 	ldw	r2,-24(fp)
 8218734:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
 8218738:	e0bfff17 	ldw	r2,-4(fp)
 821873c:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
 8218740:	e0bffb17 	ldw	r2,-20(fp)
 8218744:	00000806 	br	8218768 <OSMemGet+0xe0>
 8218748:	e0bff917 	ldw	r2,-28(fp)
 821874c:	e0bffc15 	stw	r2,-16(fp)
 8218750:	e0bffc17 	ldw	r2,-16(fp)
 8218754:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
 8218758:	e0bfff17 	ldw	r2,-4(fp)
 821875c:	00c01744 	movi	r3,93
 8218760:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
 8218764:	0005883a 	mov	r2,zero
}
 8218768:	e037883a 	mov	sp,fp
 821876c:	df000017 	ldw	fp,0(sp)
 8218770:	dec00104 	addi	sp,sp,4
 8218774:	f800283a 	ret

08218778 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 8218778:	defff704 	addi	sp,sp,-36
 821877c:	dfc00815 	stw	ra,32(sp)
 8218780:	df000715 	stw	fp,28(sp)
 8218784:	df000704 	addi	fp,sp,28
 8218788:	e13ffd15 	stw	r4,-12(fp)
 821878c:	e17ffe15 	stw	r5,-8(fp)
 8218790:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8218794:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8218798:	e0bfff17 	ldw	r2,-4(fp)
 821879c:	1000021e 	bne	r2,zero,82187a8 <OSMemNameGet+0x30>
        return (0);
 82187a0:	0005883a 	mov	r2,zero
 82187a4:	00002b06 	br	8218854 <OSMemNameGet+0xdc>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 82187a8:	e0bffd17 	ldw	r2,-12(fp)
 82187ac:	1000051e 	bne	r2,zero,82187c4 <OSMemNameGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 82187b0:	e0bfff17 	ldw	r2,-4(fp)
 82187b4:	00c01804 	movi	r3,96
 82187b8:	10c00005 	stb	r3,0(r2)
        return (0);
 82187bc:	0005883a 	mov	r2,zero
 82187c0:	00002406 	br	8218854 <OSMemNameGet+0xdc>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 82187c4:	e0bffe17 	ldw	r2,-8(fp)
 82187c8:	1000051e 	bne	r2,zero,82187e0 <OSMemNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
 82187cc:	e0bfff17 	ldw	r2,-4(fp)
 82187d0:	00c00304 	movi	r3,12
 82187d4:	10c00005 	stb	r3,0(r2)
        return (0);
 82187d8:	0005883a 	mov	r2,zero
 82187dc:	00001d06 	br	8218854 <OSMemNameGet+0xdc>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 82187e0:	d0a07903 	ldbu	r2,-32284(gp)
 82187e4:	10803fcc 	andi	r2,r2,255
 82187e8:	10000526 	beq	r2,zero,8218800 <OSMemNameGet+0x88>
        *perr = OS_ERR_NAME_GET_ISR;
 82187ec:	e0bfff17 	ldw	r2,-4(fp)
 82187f0:	00c00444 	movi	r3,17
 82187f4:	10c00005 	stb	r3,0(r2)
        return (0);
 82187f8:	0005883a 	mov	r2,zero
 82187fc:	00001506 	br	8218854 <OSMemNameGet+0xdc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218800:	0005303a 	rdctl	r2,status
 8218804:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218808:	e0fffb17 	ldw	r3,-20(fp)
 821880c:	00bfff84 	movi	r2,-2
 8218810:	1884703a 	and	r2,r3,r2
 8218814:	1001703a 	wrctl	status,r2
  
  return context;
 8218818:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 821881c:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
 8218820:	e0bffd17 	ldw	r2,-12(fp)
 8218824:	10800504 	addi	r2,r2,20
 8218828:	100b883a 	mov	r5,r2
 821882c:	e13ffe17 	ldw	r4,-8(fp)
 8218830:	82166680 	call	8216668 <OS_StrCopy>
 8218834:	e0bffa05 	stb	r2,-24(fp)
 8218838:	e0bff917 	ldw	r2,-28(fp)
 821883c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218840:	e0bffc17 	ldw	r2,-16(fp)
 8218844:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8218848:	e0bfff17 	ldw	r2,-4(fp)
 821884c:	10000005 	stb	zero,0(r2)
    return (len);
 8218850:	e0bffa03 	ldbu	r2,-24(fp)
}
 8218854:	e037883a 	mov	sp,fp
 8218858:	dfc00117 	ldw	ra,4(sp)
 821885c:	df000017 	ldw	fp,0(sp)
 8218860:	dec00204 	addi	sp,sp,8
 8218864:	f800283a 	ret

08218868 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 8218868:	defff604 	addi	sp,sp,-40
 821886c:	dfc00915 	stw	ra,36(sp)
 8218870:	df000815 	stw	fp,32(sp)
 8218874:	df000804 	addi	fp,sp,32
 8218878:	e13ffd15 	stw	r4,-12(fp)
 821887c:	e17ffe15 	stw	r5,-8(fp)
 8218880:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8218884:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8218888:	e0bfff17 	ldw	r2,-4(fp)
 821888c:	10003526 	beq	r2,zero,8218964 <OSMemNameSet+0xfc>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 8218890:	e0bffd17 	ldw	r2,-12(fp)
 8218894:	1000041e 	bne	r2,zero,82188a8 <OSMemNameSet+0x40>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 8218898:	e0bfff17 	ldw	r2,-4(fp)
 821889c:	00c01804 	movi	r3,96
 82188a0:	10c00005 	stb	r3,0(r2)
        return;
 82188a4:	00003006 	br	8218968 <OSMemNameSet+0x100>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 82188a8:	e0bffe17 	ldw	r2,-8(fp)
 82188ac:	1000041e 	bne	r2,zero,82188c0 <OSMemNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
 82188b0:	e0bfff17 	ldw	r2,-4(fp)
 82188b4:	00c00304 	movi	r3,12
 82188b8:	10c00005 	stb	r3,0(r2)
        return;
 82188bc:	00002a06 	br	8218968 <OSMemNameSet+0x100>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 82188c0:	d0a07903 	ldbu	r2,-32284(gp)
 82188c4:	10803fcc 	andi	r2,r2,255
 82188c8:	10000426 	beq	r2,zero,82188dc <OSMemNameSet+0x74>
        *perr = OS_ERR_NAME_SET_ISR;
 82188cc:	e0bfff17 	ldw	r2,-4(fp)
 82188d0:	00c00484 	movi	r3,18
 82188d4:	10c00005 	stb	r3,0(r2)
        return;
 82188d8:	00002306 	br	8218968 <OSMemNameSet+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82188dc:	0005303a 	rdctl	r2,status
 82188e0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82188e4:	e0fffc17 	ldw	r3,-16(fp)
 82188e8:	00bfff84 	movi	r2,-2
 82188ec:	1884703a 	and	r2,r3,r2
 82188f0:	1001703a 	wrctl	status,r2
  
  return context;
 82188f4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 82188f8:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 82188fc:	e13ffe17 	ldw	r4,-8(fp)
 8218900:	82166dc0 	call	82166dc <OS_StrLen>
 8218904:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
 8218908:	e0bffa03 	ldbu	r2,-24(fp)
 821890c:	10800830 	cmpltui	r2,r2,32
 8218910:	1000081e 	bne	r2,zero,8218934 <OSMemNameSet+0xcc>
 8218914:	e0bff817 	ldw	r2,-32(fp)
 8218918:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821891c:	e0bff917 	ldw	r2,-28(fp)
 8218920:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
 8218924:	e0bfff17 	ldw	r2,-4(fp)
 8218928:	00c018c4 	movi	r3,99
 821892c:	10c00005 	stb	r3,0(r2)
        return;
 8218930:	00000d06 	br	8218968 <OSMemNameSet+0x100>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
 8218934:	e0bffd17 	ldw	r2,-12(fp)
 8218938:	10800504 	addi	r2,r2,20
 821893c:	e17ffe17 	ldw	r5,-8(fp)
 8218940:	1009883a 	mov	r4,r2
 8218944:	82166680 	call	8216668 <OS_StrCopy>
 8218948:	e0bff817 	ldw	r2,-32(fp)
 821894c:	e0bffb15 	stw	r2,-20(fp)
 8218950:	e0bffb17 	ldw	r2,-20(fp)
 8218954:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8218958:	e0bfff17 	ldw	r2,-4(fp)
 821895c:	10000005 	stb	zero,0(r2)
 8218960:	00000106 	br	8218968 <OSMemNameSet+0x100>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
 8218964:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
 8218968:	e037883a 	mov	sp,fp
 821896c:	dfc00117 	ldw	ra,4(sp)
 8218970:	df000017 	ldw	fp,0(sp)
 8218974:	dec00204 	addi	sp,sp,8
 8218978:	f800283a 	ret

0821897c <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
 821897c:	defff904 	addi	sp,sp,-28
 8218980:	df000615 	stw	fp,24(sp)
 8218984:	df000604 	addi	fp,sp,24
 8218988:	e13ffe15 	stw	r4,-8(fp)
 821898c:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8218990:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 8218994:	e0bffe17 	ldw	r2,-8(fp)
 8218998:	1000021e 	bne	r2,zero,82189a4 <OSMemPut+0x28>
        return (OS_ERR_MEM_INVALID_PMEM);
 821899c:	00801804 	movi	r2,96
 82189a0:	00002806 	br	8218a44 <OSMemPut+0xc8>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
 82189a4:	e0bfff17 	ldw	r2,-4(fp)
 82189a8:	1000021e 	bne	r2,zero,82189b4 <OSMemPut+0x38>
        return (OS_ERR_MEM_INVALID_PBLK);
 82189ac:	008017c4 	movi	r2,95
 82189b0:	00002406 	br	8218a44 <OSMemPut+0xc8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82189b4:	0005303a 	rdctl	r2,status
 82189b8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82189bc:	e0fffd17 	ldw	r3,-12(fp)
 82189c0:	00bfff84 	movi	r2,-2
 82189c4:	1884703a 	and	r2,r3,r2
 82189c8:	1001703a 	wrctl	status,r2
  
  return context;
 82189cc:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 82189d0:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
 82189d4:	e0bffe17 	ldw	r2,-8(fp)
 82189d8:	10c00417 	ldw	r3,16(r2)
 82189dc:	e0bffe17 	ldw	r2,-8(fp)
 82189e0:	10800317 	ldw	r2,12(r2)
 82189e4:	18800636 	bltu	r3,r2,8218a00 <OSMemPut+0x84>
 82189e8:	e0bffa17 	ldw	r2,-24(fp)
 82189ec:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82189f0:	e0bffb17 	ldw	r2,-20(fp)
 82189f4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
 82189f8:	00801784 	movi	r2,94
 82189fc:	00001106 	br	8218a44 <OSMemPut+0xc8>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
 8218a00:	e0bffe17 	ldw	r2,-8(fp)
 8218a04:	10c00117 	ldw	r3,4(r2)
 8218a08:	e0bfff17 	ldw	r2,-4(fp)
 8218a0c:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
 8218a10:	e0bffe17 	ldw	r2,-8(fp)
 8218a14:	e0ffff17 	ldw	r3,-4(fp)
 8218a18:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
 8218a1c:	e0bffe17 	ldw	r2,-8(fp)
 8218a20:	10800417 	ldw	r2,16(r2)
 8218a24:	10c00044 	addi	r3,r2,1
 8218a28:	e0bffe17 	ldw	r2,-8(fp)
 8218a2c:	10c00415 	stw	r3,16(r2)
 8218a30:	e0bffa17 	ldw	r2,-24(fp)
 8218a34:	e0bffc15 	stw	r2,-16(fp)
 8218a38:	e0bffc17 	ldw	r2,-16(fp)
 8218a3c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
 8218a40:	0005883a 	mov	r2,zero
}
 8218a44:	e037883a 	mov	sp,fp
 8218a48:	df000017 	ldw	fp,0(sp)
 8218a4c:	dec00104 	addi	sp,sp,4
 8218a50:	f800283a 	ret

08218a54 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
 8218a54:	defffa04 	addi	sp,sp,-24
 8218a58:	df000515 	stw	fp,20(sp)
 8218a5c:	df000504 	addi	fp,sp,20
 8218a60:	e13ffe15 	stw	r4,-8(fp)
 8218a64:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8218a68:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 8218a6c:	e0bffe17 	ldw	r2,-8(fp)
 8218a70:	1000021e 	bne	r2,zero,8218a7c <OSMemQuery+0x28>
        return (OS_ERR_MEM_INVALID_PMEM);
 8218a74:	00801804 	movi	r2,96
 8218a78:	00002c06 	br	8218b2c <OSMemQuery+0xd8>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
 8218a7c:	e0bfff17 	ldw	r2,-4(fp)
 8218a80:	1000021e 	bne	r2,zero,8218a8c <OSMemQuery+0x38>
        return (OS_ERR_MEM_INVALID_PDATA);
 8218a84:	00801844 	movi	r2,97
 8218a88:	00002806 	br	8218b2c <OSMemQuery+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218a8c:	0005303a 	rdctl	r2,status
 8218a90:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218a94:	e0fffc17 	ldw	r3,-16(fp)
 8218a98:	00bfff84 	movi	r2,-2
 8218a9c:	1884703a 	and	r2,r3,r2
 8218aa0:	1001703a 	wrctl	status,r2
  
  return context;
 8218aa4:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 8218aa8:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
 8218aac:	e0bffe17 	ldw	r2,-8(fp)
 8218ab0:	10c00017 	ldw	r3,0(r2)
 8218ab4:	e0bfff17 	ldw	r2,-4(fp)
 8218ab8:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
 8218abc:	e0bffe17 	ldw	r2,-8(fp)
 8218ac0:	10c00117 	ldw	r3,4(r2)
 8218ac4:	e0bfff17 	ldw	r2,-4(fp)
 8218ac8:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
 8218acc:	e0bffe17 	ldw	r2,-8(fp)
 8218ad0:	10c00217 	ldw	r3,8(r2)
 8218ad4:	e0bfff17 	ldw	r2,-4(fp)
 8218ad8:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
 8218adc:	e0bffe17 	ldw	r2,-8(fp)
 8218ae0:	10c00317 	ldw	r3,12(r2)
 8218ae4:	e0bfff17 	ldw	r2,-4(fp)
 8218ae8:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
 8218aec:	e0bffe17 	ldw	r2,-8(fp)
 8218af0:	10c00417 	ldw	r3,16(r2)
 8218af4:	e0bfff17 	ldw	r2,-4(fp)
 8218af8:	10c00415 	stw	r3,16(r2)
 8218afc:	e0bffb17 	ldw	r2,-20(fp)
 8218b00:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218b04:	e0bffd17 	ldw	r2,-12(fp)
 8218b08:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
 8218b0c:	e0bfff17 	ldw	r2,-4(fp)
 8218b10:	10c00317 	ldw	r3,12(r2)
 8218b14:	e0bfff17 	ldw	r2,-4(fp)
 8218b18:	10800417 	ldw	r2,16(r2)
 8218b1c:	1887c83a 	sub	r3,r3,r2
 8218b20:	e0bfff17 	ldw	r2,-4(fp)
 8218b24:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
 8218b28:	0005883a 	mov	r2,zero
}
 8218b2c:	e037883a 	mov	sp,fp
 8218b30:	df000017 	ldw	fp,0(sp)
 8218b34:	dec00104 	addi	sp,sp,4
 8218b38:	f800283a 	ret

08218b3c <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
 8218b3c:	defffc04 	addi	sp,sp,-16
 8218b40:	dfc00315 	stw	ra,12(sp)
 8218b44:	df000215 	stw	fp,8(sp)
 8218b48:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
 8218b4c:	01430c04 	movi	r5,3120
 8218b50:	010209b4 	movhi	r4,2086
 8218b54:	212b1104 	addi	r4,r4,-21436
 8218b58:	82164680 	call	8216468 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
 8218b5c:	008209b4 	movhi	r2,2086
 8218b60:	10ab1104 	addi	r2,r2,-21436
 8218b64:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 8218b68:	e03fff0d 	sth	zero,-4(fp)
 8218b6c:	00001306 	br	8218bbc <OS_MemInit+0x80>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
 8218b70:	e0bfff0b 	ldhu	r2,-4(fp)
 8218b74:	10800044 	addi	r2,r2,1
 8218b78:	10c00d24 	muli	r3,r2,52
 8218b7c:	008209b4 	movhi	r2,2086
 8218b80:	10ab1104 	addi	r2,r2,-21436
 8218b84:	1887883a 	add	r3,r3,r2
 8218b88:	e0bffe17 	ldw	r2,-8(fp)
 8218b8c:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
 8218b90:	e0bffe17 	ldw	r2,-8(fp)
 8218b94:	00c00fc4 	movi	r3,63
 8218b98:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
 8218b9c:	e0bffe17 	ldw	r2,-8(fp)
 8218ba0:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
 8218ba4:	e0bffe17 	ldw	r2,-8(fp)
 8218ba8:	10800d04 	addi	r2,r2,52
 8218bac:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 8218bb0:	e0bfff0b 	ldhu	r2,-4(fp)
 8218bb4:	10800044 	addi	r2,r2,1
 8218bb8:	e0bfff0d 	sth	r2,-4(fp)
 8218bbc:	e0bfff0b 	ldhu	r2,-4(fp)
 8218bc0:	10800ef0 	cmpltui	r2,r2,59
 8218bc4:	103fea1e 	bne	r2,zero,8218b70 <OS_MemInit+0x34>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
 8218bc8:	e0bffe17 	ldw	r2,-8(fp)
 8218bcc:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
 8218bd0:	e0bffe17 	ldw	r2,-8(fp)
 8218bd4:	00c00fc4 	movi	r3,63
 8218bd8:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
 8218bdc:	e0bffe17 	ldw	r2,-8(fp)
 8218be0:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
 8218be4:	008209b4 	movhi	r2,2086
 8218be8:	10ab1104 	addi	r2,r2,-21436
 8218bec:	d0a07415 	stw	r2,-32304(gp)
#endif
}
 8218bf0:	0001883a 	nop
 8218bf4:	e037883a 	mov	sp,fp
 8218bf8:	dfc00117 	ldw	ra,4(sp)
 8218bfc:	df000017 	ldw	fp,0(sp)
 8218c00:	dec00204 	addi	sp,sp,8
 8218c04:	f800283a 	ret

08218c08 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
 8218c08:	defff804 	addi	sp,sp,-32
 8218c0c:	df000715 	stw	fp,28(sp)
 8218c10:	df000704 	addi	fp,sp,28
 8218c14:	e13ffe15 	stw	r4,-8(fp)
 8218c18:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8218c1c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8218c20:	e0bfff17 	ldw	r2,-4(fp)
 8218c24:	1000021e 	bne	r2,zero,8218c30 <OSQAccept+0x28>
        return ((void *)0);
 8218c28:	0005883a 	mov	r2,zero
 8218c2c:	00004206 	br	8218d38 <OSQAccept+0x130>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 8218c30:	e0bffe17 	ldw	r2,-8(fp)
 8218c34:	1000051e 	bne	r2,zero,8218c4c <OSQAccept+0x44>
        *perr = OS_ERR_PEVENT_NULL;
 8218c38:	e0bfff17 	ldw	r2,-4(fp)
 8218c3c:	00c00104 	movi	r3,4
 8218c40:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8218c44:	0005883a 	mov	r2,zero
 8218c48:	00003b06 	br	8218d38 <OSQAccept+0x130>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 8218c4c:	e0bffe17 	ldw	r2,-8(fp)
 8218c50:	10800003 	ldbu	r2,0(r2)
 8218c54:	10803fcc 	andi	r2,r2,255
 8218c58:	108000a0 	cmpeqi	r2,r2,2
 8218c5c:	1000051e 	bne	r2,zero,8218c74 <OSQAccept+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
 8218c60:	e0bfff17 	ldw	r2,-4(fp)
 8218c64:	00c00044 	movi	r3,1
 8218c68:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8218c6c:	0005883a 	mov	r2,zero
 8218c70:	00003106 	br	8218d38 <OSQAccept+0x130>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218c74:	0005303a 	rdctl	r2,status
 8218c78:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218c7c:	e0fffd17 	ldw	r3,-12(fp)
 8218c80:	00bfff84 	movi	r2,-2
 8218c84:	1884703a 	and	r2,r3,r2
 8218c88:	1001703a 	wrctl	status,r2
  
  return context;
 8218c8c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 8218c90:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 8218c94:	e0bffe17 	ldw	r2,-8(fp)
 8218c98:	10800117 	ldw	r2,4(r2)
 8218c9c:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 8218ca0:	e0bffc17 	ldw	r2,-16(fp)
 8218ca4:	1080058b 	ldhu	r2,22(r2)
 8218ca8:	10bfffcc 	andi	r2,r2,65535
 8218cac:	10001926 	beq	r2,zero,8218d14 <OSQAccept+0x10c>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 8218cb0:	e0bffc17 	ldw	r2,-16(fp)
 8218cb4:	10800417 	ldw	r2,16(r2)
 8218cb8:	11000104 	addi	r4,r2,4
 8218cbc:	e0fffc17 	ldw	r3,-16(fp)
 8218cc0:	19000415 	stw	r4,16(r3)
 8218cc4:	10800017 	ldw	r2,0(r2)
 8218cc8:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 8218ccc:	e0bffc17 	ldw	r2,-16(fp)
 8218cd0:	1080058b 	ldhu	r2,22(r2)
 8218cd4:	10bfffc4 	addi	r2,r2,-1
 8218cd8:	1007883a 	mov	r3,r2
 8218cdc:	e0bffc17 	ldw	r2,-16(fp)
 8218ce0:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 8218ce4:	e0bffc17 	ldw	r2,-16(fp)
 8218ce8:	10c00417 	ldw	r3,16(r2)
 8218cec:	e0bffc17 	ldw	r2,-16(fp)
 8218cf0:	10800217 	ldw	r2,8(r2)
 8218cf4:	1880041e 	bne	r3,r2,8218d08 <OSQAccept+0x100>
            pq->OSQOut = pq->OSQStart;
 8218cf8:	e0bffc17 	ldw	r2,-16(fp)
 8218cfc:	10c00117 	ldw	r3,4(r2)
 8218d00:	e0bffc17 	ldw	r2,-16(fp)
 8218d04:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
 8218d08:	e0bfff17 	ldw	r2,-4(fp)
 8218d0c:	10000005 	stb	zero,0(r2)
 8218d10:	00000406 	br	8218d24 <OSQAccept+0x11c>
    } else {
        *perr = OS_ERR_Q_EMPTY;
 8218d14:	e0bfff17 	ldw	r2,-4(fp)
 8218d18:	00c007c4 	movi	r3,31
 8218d1c:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
 8218d20:	e03ff915 	stw	zero,-28(fp)
 8218d24:	e0bffa17 	ldw	r2,-24(fp)
 8218d28:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218d2c:	e0bffb17 	ldw	r2,-20(fp)
 8218d30:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
 8218d34:	e0bff917 	ldw	r2,-28(fp)
}
 8218d38:	e037883a 	mov	sp,fp
 8218d3c:	df000017 	ldw	fp,0(sp)
 8218d40:	dec00104 	addi	sp,sp,4
 8218d44:	f800283a 	ret

08218d48 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
 8218d48:	defff404 	addi	sp,sp,-48
 8218d4c:	dfc00b15 	stw	ra,44(sp)
 8218d50:	df000a15 	stw	fp,40(sp)
 8218d54:	df000a04 	addi	fp,sp,40
 8218d58:	e13ffe15 	stw	r4,-8(fp)
 8218d5c:	2805883a 	mov	r2,r5
 8218d60:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8218d64:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 8218d68:	d0a07903 	ldbu	r2,-32284(gp)
 8218d6c:	10803fcc 	andi	r2,r2,255
 8218d70:	10000226 	beq	r2,zero,8218d7c <OSQCreate+0x34>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
 8218d74:	0005883a 	mov	r2,zero
 8218d78:	00005906 	br	8218ee0 <OSQCreate+0x198>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218d7c:	0005303a 	rdctl	r2,status
 8218d80:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218d84:	e0fffd17 	ldw	r3,-12(fp)
 8218d88:	00bfff84 	movi	r2,-2
 8218d8c:	1884703a 	and	r2,r3,r2
 8218d90:	1001703a 	wrctl	status,r2
  
  return context;
 8218d94:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 8218d98:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
 8218d9c:	d0a07817 	ldw	r2,-32288(gp)
 8218da0:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
 8218da4:	d0a07817 	ldw	r2,-32288(gp)
 8218da8:	10000326 	beq	r2,zero,8218db8 <OSQCreate+0x70>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 8218dac:	d0a07817 	ldw	r2,-32288(gp)
 8218db0:	10800117 	ldw	r2,4(r2)
 8218db4:	d0a07815 	stw	r2,-32288(gp)
 8218db8:	e0bff717 	ldw	r2,-36(fp)
 8218dbc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218dc0:	e0bff817 	ldw	r2,-32(fp)
 8218dc4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
 8218dc8:	e0bff617 	ldw	r2,-40(fp)
 8218dcc:	10004326 	beq	r2,zero,8218edc <OSQCreate+0x194>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218dd0:	0005303a 	rdctl	r2,status
 8218dd4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218dd8:	e0fff917 	ldw	r3,-28(fp)
 8218ddc:	00bfff84 	movi	r2,-2
 8218de0:	1884703a 	and	r2,r3,r2
 8218de4:	1001703a 	wrctl	status,r2
  
  return context;
 8218de8:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
 8218dec:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
 8218df0:	d0a07617 	ldw	r2,-32296(gp)
 8218df4:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
 8218df8:	e0bffb17 	ldw	r2,-20(fp)
 8218dfc:	10002d26 	beq	r2,zero,8218eb4 <OSQCreate+0x16c>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
 8218e00:	d0a07617 	ldw	r2,-32296(gp)
 8218e04:	10800017 	ldw	r2,0(r2)
 8218e08:	d0a07615 	stw	r2,-32296(gp)
 8218e0c:	e0bff717 	ldw	r2,-36(fp)
 8218e10:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218e14:	e0bffa17 	ldw	r2,-24(fp)
 8218e18:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
 8218e1c:	e0bffb17 	ldw	r2,-20(fp)
 8218e20:	e0fffe17 	ldw	r3,-8(fp)
 8218e24:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
 8218e28:	e0bfff0b 	ldhu	r2,-4(fp)
 8218e2c:	1085883a 	add	r2,r2,r2
 8218e30:	1085883a 	add	r2,r2,r2
 8218e34:	1007883a 	mov	r3,r2
 8218e38:	e0bffe17 	ldw	r2,-8(fp)
 8218e3c:	10c7883a 	add	r3,r2,r3
 8218e40:	e0bffb17 	ldw	r2,-20(fp)
 8218e44:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
 8218e48:	e0bffb17 	ldw	r2,-20(fp)
 8218e4c:	e0fffe17 	ldw	r3,-8(fp)
 8218e50:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
 8218e54:	e0bffb17 	ldw	r2,-20(fp)
 8218e58:	e0fffe17 	ldw	r3,-8(fp)
 8218e5c:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
 8218e60:	e0bffb17 	ldw	r2,-20(fp)
 8218e64:	e0ffff0b 	ldhu	r3,-4(fp)
 8218e68:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
 8218e6c:	e0bffb17 	ldw	r2,-20(fp)
 8218e70:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
 8218e74:	e0bff617 	ldw	r2,-40(fp)
 8218e78:	00c00084 	movi	r3,2
 8218e7c:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
 8218e80:	e0bff617 	ldw	r2,-40(fp)
 8218e84:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
 8218e88:	e0bff617 	ldw	r2,-40(fp)
 8218e8c:	e0fffb17 	ldw	r3,-20(fp)
 8218e90:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
 8218e94:	e0bff617 	ldw	r2,-40(fp)
 8218e98:	00c00fc4 	movi	r3,63
 8218e9c:	10c00385 	stb	r3,14(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
 8218ea0:	e0bff617 	ldw	r2,-40(fp)
 8218ea4:	100003c5 	stb	zero,15(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
 8218ea8:	e13ff617 	ldw	r4,-40(fp)
 8218eac:	82160880 	call	8216088 <OS_EventWaitListInit>
 8218eb0:	00000a06 	br	8218edc <OSQCreate+0x194>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
 8218eb4:	d0e07817 	ldw	r3,-32288(gp)
 8218eb8:	e0bff617 	ldw	r2,-40(fp)
 8218ebc:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
 8218ec0:	e0bff617 	ldw	r2,-40(fp)
 8218ec4:	d0a07815 	stw	r2,-32288(gp)
 8218ec8:	e0bff717 	ldw	r2,-36(fp)
 8218ecc:	e0bffc15 	stw	r2,-16(fp)
 8218ed0:	e0bffc17 	ldw	r2,-16(fp)
 8218ed4:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
 8218ed8:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
 8218edc:	e0bff617 	ldw	r2,-40(fp)
}
 8218ee0:	e037883a 	mov	sp,fp
 8218ee4:	dfc00117 	ldw	ra,4(sp)
 8218ee8:	df000017 	ldw	fp,0(sp)
 8218eec:	dec00204 	addi	sp,sp,8
 8218ef0:	f800283a 	ret

08218ef4 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 8218ef4:	defff204 	addi	sp,sp,-56
 8218ef8:	dfc00d15 	stw	ra,52(sp)
 8218efc:	df000c15 	stw	fp,48(sp)
 8218f00:	df000c04 	addi	fp,sp,48
 8218f04:	e13ffd15 	stw	r4,-12(fp)
 8218f08:	2805883a 	mov	r2,r5
 8218f0c:	e1bfff15 	stw	r6,-4(fp)
 8218f10:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 8218f14:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 8218f18:	e0bfff17 	ldw	r2,-4(fp)
 8218f1c:	1000021e 	bne	r2,zero,8218f28 <OSQDel+0x34>
        return (pevent);
 8218f20:	e0bffd17 	ldw	r2,-12(fp)
 8218f24:	00008e06 	br	8219160 <OSQDel+0x26c>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 8218f28:	e0bffd17 	ldw	r2,-12(fp)
 8218f2c:	1000051e 	bne	r2,zero,8218f44 <OSQDel+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 8218f30:	e0bfff17 	ldw	r2,-4(fp)
 8218f34:	00c00104 	movi	r3,4
 8218f38:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8218f3c:	e0bffd17 	ldw	r2,-12(fp)
 8218f40:	00008706 	br	8219160 <OSQDel+0x26c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 8218f44:	e0bffd17 	ldw	r2,-12(fp)
 8218f48:	10800003 	ldbu	r2,0(r2)
 8218f4c:	10803fcc 	andi	r2,r2,255
 8218f50:	108000a0 	cmpeqi	r2,r2,2
 8218f54:	1000051e 	bne	r2,zero,8218f6c <OSQDel+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 8218f58:	e0bfff17 	ldw	r2,-4(fp)
 8218f5c:	00c00044 	movi	r3,1
 8218f60:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8218f64:	e0bffd17 	ldw	r2,-12(fp)
 8218f68:	00007d06 	br	8219160 <OSQDel+0x26c>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 8218f6c:	d0a07903 	ldbu	r2,-32284(gp)
 8218f70:	10803fcc 	andi	r2,r2,255
 8218f74:	10000526 	beq	r2,zero,8218f8c <OSQDel+0x98>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 8218f78:	e0bfff17 	ldw	r2,-4(fp)
 8218f7c:	00c003c4 	movi	r3,15
 8218f80:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8218f84:	e0bffd17 	ldw	r2,-12(fp)
 8218f88:	00007506 	br	8219160 <OSQDel+0x26c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218f8c:	0005303a 	rdctl	r2,status
 8218f90:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218f94:	e0fffc17 	ldw	r3,-16(fp)
 8218f98:	00bfff84 	movi	r2,-2
 8218f9c:	1884703a 	and	r2,r3,r2
 8218fa0:	1001703a 	wrctl	status,r2
  
  return context;
 8218fa4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8218fa8:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
 8218fac:	e0bffd17 	ldw	r2,-12(fp)
 8218fb0:	10800283 	ldbu	r2,10(r2)
 8218fb4:	10803fcc 	andi	r2,r2,255
 8218fb8:	10000326 	beq	r2,zero,8218fc8 <OSQDel+0xd4>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 8218fbc:	00800044 	movi	r2,1
 8218fc0:	e0bff405 	stb	r2,-48(fp)
 8218fc4:	00000106 	br	8218fcc <OSQDel+0xd8>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 8218fc8:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
 8218fcc:	e0bffe03 	ldbu	r2,-8(fp)
 8218fd0:	10000326 	beq	r2,zero,8218fe0 <OSQDel+0xec>
 8218fd4:	10800060 	cmpeqi	r2,r2,1
 8218fd8:	1000301e 	bne	r2,zero,821909c <OSQDel+0x1a8>
 8218fdc:	00005506 	br	8219134 <OSQDel+0x240>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
 8218fe0:	e0bff403 	ldbu	r2,-48(fp)
 8218fe4:	10001e1e 	bne	r2,zero,8219060 <OSQDel+0x16c>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 8218fe8:	e0bffd17 	ldw	r2,-12(fp)
 8218fec:	00c00fc4 	movi	r3,63
 8218ff0:	10c00385 	stb	r3,14(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 8218ff4:	e0bffd17 	ldw	r2,-12(fp)
 8218ff8:	100003c5 	stb	zero,15(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
 8218ffc:	e0bffd17 	ldw	r2,-12(fp)
 8219000:	10800117 	ldw	r2,4(r2)
 8219004:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
 8219008:	d0e07617 	ldw	r3,-32296(gp)
 821900c:	e0bff817 	ldw	r2,-32(fp)
 8219010:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
 8219014:	e0bff817 	ldw	r2,-32(fp)
 8219018:	d0a07615 	stw	r2,-32296(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 821901c:	e0bffd17 	ldw	r2,-12(fp)
 8219020:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 8219024:	d0e07817 	ldw	r3,-32288(gp)
 8219028:	e0bffd17 	ldw	r2,-12(fp)
 821902c:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 8219030:	e0bffd17 	ldw	r2,-12(fp)
 8219034:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 8219038:	e0bffd17 	ldw	r2,-12(fp)
 821903c:	d0a07815 	stw	r2,-32288(gp)
 8219040:	e0bff617 	ldw	r2,-40(fp)
 8219044:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219048:	e0bff717 	ldw	r2,-36(fp)
 821904c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 8219050:	e0bfff17 	ldw	r2,-4(fp)
 8219054:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
 8219058:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
 821905c:	00003f06 	br	821915c <OSQDel+0x268>
 8219060:	e0bff617 	ldw	r2,-40(fp)
 8219064:	e0bff915 	stw	r2,-28(fp)
 8219068:	e0bff917 	ldw	r2,-28(fp)
 821906c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 8219070:	e0bfff17 	ldw	r2,-4(fp)
 8219074:	00c01244 	movi	r3,73
 8219078:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
 821907c:	e0bffd17 	ldw	r2,-12(fp)
 8219080:	e0bff515 	stw	r2,-44(fp)
             }
             break;
 8219084:	00003506 	br	821915c <OSQDel+0x268>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
 8219088:	000f883a 	mov	r7,zero
 821908c:	01800104 	movi	r6,4
 8219090:	000b883a 	mov	r5,zero
 8219094:	e13ffd17 	ldw	r4,-12(fp)
 8219098:	8215ad80 	call	8215ad8 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
 821909c:	e0bffd17 	ldw	r2,-12(fp)
 82190a0:	10800283 	ldbu	r2,10(r2)
 82190a4:	10803fcc 	andi	r2,r2,255
 82190a8:	103ff71e 	bne	r2,zero,8219088 <OSQDel+0x194>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 82190ac:	e0bffd17 	ldw	r2,-12(fp)
 82190b0:	00c00fc4 	movi	r3,63
 82190b4:	10c00385 	stb	r3,14(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 82190b8:	e0bffd17 	ldw	r2,-12(fp)
 82190bc:	100003c5 	stb	zero,15(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
 82190c0:	e0bffd17 	ldw	r2,-12(fp)
 82190c4:	10800117 	ldw	r2,4(r2)
 82190c8:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
 82190cc:	d0e07617 	ldw	r3,-32296(gp)
 82190d0:	e0bff817 	ldw	r2,-32(fp)
 82190d4:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
 82190d8:	e0bff817 	ldw	r2,-32(fp)
 82190dc:	d0a07615 	stw	r2,-32296(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 82190e0:	e0bffd17 	ldw	r2,-12(fp)
 82190e4:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 82190e8:	d0e07817 	ldw	r3,-32288(gp)
 82190ec:	e0bffd17 	ldw	r2,-12(fp)
 82190f0:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 82190f4:	e0bffd17 	ldw	r2,-12(fp)
 82190f8:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 82190fc:	e0bffd17 	ldw	r2,-12(fp)
 8219100:	d0a07815 	stw	r2,-32288(gp)
 8219104:	e0bff617 	ldw	r2,-40(fp)
 8219108:	e0bffa15 	stw	r2,-24(fp)
 821910c:	e0bffa17 	ldw	r2,-24(fp)
 8219110:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 8219114:	e0bff403 	ldbu	r2,-48(fp)
 8219118:	10800058 	cmpnei	r2,r2,1
 821911c:	1000011e 	bne	r2,zero,8219124 <OSQDel+0x230>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 8219120:	82165240 	call	8216524 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 8219124:	e0bfff17 	ldw	r2,-4(fp)
 8219128:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
 821912c:	e03ff515 	stw	zero,-44(fp)
             break;
 8219130:	00000a06 	br	821915c <OSQDel+0x268>
 8219134:	e0bff617 	ldw	r2,-40(fp)
 8219138:	e0bffb15 	stw	r2,-20(fp)
 821913c:	e0bffb17 	ldw	r2,-20(fp)
 8219140:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 8219144:	e0bfff17 	ldw	r2,-4(fp)
 8219148:	00c001c4 	movi	r3,7
 821914c:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
 8219150:	e0bffd17 	ldw	r2,-12(fp)
 8219154:	e0bff515 	stw	r2,-44(fp)
             break;
 8219158:	0001883a 	nop
    }
    return (pevent_return);
 821915c:	e0bff517 	ldw	r2,-44(fp)
}
 8219160:	e037883a 	mov	sp,fp
 8219164:	dfc00117 	ldw	ra,4(sp)
 8219168:	df000017 	ldw	fp,0(sp)
 821916c:	dec00204 	addi	sp,sp,8
 8219170:	f800283a 	ret

08219174 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
 8219174:	defffa04 	addi	sp,sp,-24
 8219178:	df000515 	stw	fp,20(sp)
 821917c:	df000504 	addi	fp,sp,20
 8219180:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 8219184:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 8219188:	e0bfff17 	ldw	r2,-4(fp)
 821918c:	1000021e 	bne	r2,zero,8219198 <OSQFlush+0x24>
        return (OS_ERR_PEVENT_NULL);
 8219190:	00800104 	movi	r2,4
 8219194:	00002106 	br	821921c <OSQFlush+0xa8>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 8219198:	e0bfff17 	ldw	r2,-4(fp)
 821919c:	10800003 	ldbu	r2,0(r2)
 82191a0:	10803fcc 	andi	r2,r2,255
 82191a4:	108000a0 	cmpeqi	r2,r2,2
 82191a8:	1000021e 	bne	r2,zero,82191b4 <OSQFlush+0x40>
        return (OS_ERR_EVENT_TYPE);
 82191ac:	00800044 	movi	r2,1
 82191b0:	00001a06 	br	821921c <OSQFlush+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82191b4:	0005303a 	rdctl	r2,status
 82191b8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82191bc:	e0fffd17 	ldw	r3,-12(fp)
 82191c0:	00bfff84 	movi	r2,-2
 82191c4:	1884703a 	and	r2,r3,r2
 82191c8:	1001703a 	wrctl	status,r2
  
  return context;
 82191cc:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 82191d0:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
 82191d4:	e0bfff17 	ldw	r2,-4(fp)
 82191d8:	10800117 	ldw	r2,4(r2)
 82191dc:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
 82191e0:	e0bffc17 	ldw	r2,-16(fp)
 82191e4:	10c00117 	ldw	r3,4(r2)
 82191e8:	e0bffc17 	ldw	r2,-16(fp)
 82191ec:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
 82191f0:	e0bffc17 	ldw	r2,-16(fp)
 82191f4:	10c00117 	ldw	r3,4(r2)
 82191f8:	e0bffc17 	ldw	r2,-16(fp)
 82191fc:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
 8219200:	e0bffc17 	ldw	r2,-16(fp)
 8219204:	1000058d 	sth	zero,22(r2)
 8219208:	e0bffb17 	ldw	r2,-20(fp)
 821920c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219210:	e0bffe17 	ldw	r2,-8(fp)
 8219214:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 8219218:	0005883a 	mov	r2,zero
}
 821921c:	e037883a 	mov	sp,fp
 8219220:	df000017 	ldw	fp,0(sp)
 8219224:	dec00104 	addi	sp,sp,4
 8219228:	f800283a 	ret

0821922c <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 821922c:	defff304 	addi	sp,sp,-52
 8219230:	dfc00c15 	stw	ra,48(sp)
 8219234:	df000b15 	stw	fp,44(sp)
 8219238:	df000b04 	addi	fp,sp,44
 821923c:	e13ffd15 	stw	r4,-12(fp)
 8219240:	2805883a 	mov	r2,r5
 8219244:	e1bfff15 	stw	r6,-4(fp)
 8219248:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821924c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8219250:	e0bfff17 	ldw	r2,-4(fp)
 8219254:	1000021e 	bne	r2,zero,8219260 <OSQPend+0x34>
        return ((void *)0);
 8219258:	0005883a 	mov	r2,zero
 821925c:	00009106 	br	82194a4 <OSQPend+0x278>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 8219260:	e0bffd17 	ldw	r2,-12(fp)
 8219264:	1000051e 	bne	r2,zero,821927c <OSQPend+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 8219268:	e0bfff17 	ldw	r2,-4(fp)
 821926c:	00c00104 	movi	r3,4
 8219270:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8219274:	0005883a 	mov	r2,zero
 8219278:	00008a06 	br	82194a4 <OSQPend+0x278>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 821927c:	e0bffd17 	ldw	r2,-12(fp)
 8219280:	10800003 	ldbu	r2,0(r2)
 8219284:	10803fcc 	andi	r2,r2,255
 8219288:	108000a0 	cmpeqi	r2,r2,2
 821928c:	1000051e 	bne	r2,zero,82192a4 <OSQPend+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 8219290:	e0bfff17 	ldw	r2,-4(fp)
 8219294:	00c00044 	movi	r3,1
 8219298:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 821929c:	0005883a 	mov	r2,zero
 82192a0:	00008006 	br	82194a4 <OSQPend+0x278>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 82192a4:	d0a07903 	ldbu	r2,-32284(gp)
 82192a8:	10803fcc 	andi	r2,r2,255
 82192ac:	10000526 	beq	r2,zero,82192c4 <OSQPend+0x98>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
 82192b0:	e0bfff17 	ldw	r2,-4(fp)
 82192b4:	00c00084 	movi	r3,2
 82192b8:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 82192bc:	0005883a 	mov	r2,zero
 82192c0:	00007806 	br	82194a4 <OSQPend+0x278>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
 82192c4:	d0a06b03 	ldbu	r2,-32340(gp)
 82192c8:	10803fcc 	andi	r2,r2,255
 82192cc:	10000526 	beq	r2,zero,82192e4 <OSQPend+0xb8>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
 82192d0:	e0bfff17 	ldw	r2,-4(fp)
 82192d4:	00c00344 	movi	r3,13
 82192d8:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 82192dc:	0005883a 	mov	r2,zero
 82192e0:	00007006 	br	82194a4 <OSQPend+0x278>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82192e4:	0005303a 	rdctl	r2,status
 82192e8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82192ec:	e0fffc17 	ldw	r3,-16(fp)
 82192f0:	00bfff84 	movi	r2,-2
 82192f4:	1884703a 	and	r2,r3,r2
 82192f8:	1001703a 	wrctl	status,r2
  
  return context;
 82192fc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8219300:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 8219304:	e0bffd17 	ldw	r2,-12(fp)
 8219308:	10800117 	ldw	r2,4(r2)
 821930c:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 8219310:	e0bff817 	ldw	r2,-32(fp)
 8219314:	1080058b 	ldhu	r2,22(r2)
 8219318:	10bfffcc 	andi	r2,r2,65535
 821931c:	10001e26 	beq	r2,zero,8219398 <OSQPend+0x16c>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 8219320:	e0bff817 	ldw	r2,-32(fp)
 8219324:	10800417 	ldw	r2,16(r2)
 8219328:	11000104 	addi	r4,r2,4
 821932c:	e0fff817 	ldw	r3,-32(fp)
 8219330:	19000415 	stw	r4,16(r3)
 8219334:	10800017 	ldw	r2,0(r2)
 8219338:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 821933c:	e0bff817 	ldw	r2,-32(fp)
 8219340:	1080058b 	ldhu	r2,22(r2)
 8219344:	10bfffc4 	addi	r2,r2,-1
 8219348:	1007883a 	mov	r3,r2
 821934c:	e0bff817 	ldw	r2,-32(fp)
 8219350:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 8219354:	e0bff817 	ldw	r2,-32(fp)
 8219358:	10c00417 	ldw	r3,16(r2)
 821935c:	e0bff817 	ldw	r2,-32(fp)
 8219360:	10800217 	ldw	r2,8(r2)
 8219364:	1880041e 	bne	r3,r2,8219378 <OSQPend+0x14c>
            pq->OSQOut = pq->OSQStart;
 8219368:	e0bff817 	ldw	r2,-32(fp)
 821936c:	10c00117 	ldw	r3,4(r2)
 8219370:	e0bff817 	ldw	r2,-32(fp)
 8219374:	10c00415 	stw	r3,16(r2)
 8219378:	e0bff617 	ldw	r2,-40(fp)
 821937c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219380:	e0bff717 	ldw	r2,-36(fp)
 8219384:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 8219388:	e0bfff17 	ldw	r2,-4(fp)
 821938c:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
 8219390:	e0bff517 	ldw	r2,-44(fp)
 8219394:	00004306 	br	82194a4 <OSQPend+0x278>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
 8219398:	d0a07a17 	ldw	r2,-32280(gp)
 821939c:	d0e07a17 	ldw	r3,-32280(gp)
 82193a0:	18c00c03 	ldbu	r3,48(r3)
 82193a4:	18c00114 	ori	r3,r3,4
 82193a8:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 82193ac:	d0a07a17 	ldw	r2,-32280(gp)
 82193b0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
 82193b4:	d0a07a17 	ldw	r2,-32280(gp)
 82193b8:	e0fffe0b 	ldhu	r3,-8(fp)
 82193bc:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
 82193c0:	e13ffd17 	ldw	r4,-12(fp)
 82193c4:	8215c700 	call	8215c70 <OS_EventTaskWait>
 82193c8:	e0bff617 	ldw	r2,-40(fp)
 82193cc:	e0bffb15 	stw	r2,-20(fp)
 82193d0:	e0bffb17 	ldw	r2,-20(fp)
 82193d4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
 82193d8:	82165240 	call	8216524 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82193dc:	0005303a 	rdctl	r2,status
 82193e0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82193e4:	e0fff917 	ldw	r3,-28(fp)
 82193e8:	00bfff84 	movi	r2,-2
 82193ec:	1884703a 	and	r2,r3,r2
 82193f0:	1001703a 	wrctl	status,r2
  
  return context;
 82193f4:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
 82193f8:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 82193fc:	d0a07a17 	ldw	r2,-32280(gp)
 8219400:	10800c43 	ldbu	r2,49(r2)
 8219404:	10803fcc 	andi	r2,r2,255
 8219408:	10000326 	beq	r2,zero,8219418 <OSQPend+0x1ec>
 821940c:	108000a0 	cmpeqi	r2,r2,2
 8219410:	1000071e 	bne	r2,zero,8219430 <OSQPend+0x204>
 8219414:	00000b06 	br	8219444 <OSQPend+0x218>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
 8219418:	d0a07a17 	ldw	r2,-32280(gp)
 821941c:	10800917 	ldw	r2,36(r2)
 8219420:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
 8219424:	e0bfff17 	ldw	r2,-4(fp)
 8219428:	10000005 	stb	zero,0(r2)
             break;
 821942c:	00000e06 	br	8219468 <OSQPend+0x23c>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
 8219430:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 8219434:	e0bfff17 	ldw	r2,-4(fp)
 8219438:	00c00384 	movi	r3,14
 821943c:	10c00005 	stb	r3,0(r2)
             break;
 8219440:	00000906 	br	8219468 <OSQPend+0x23c>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
 8219444:	d0a07a17 	ldw	r2,-32280(gp)
 8219448:	e17ffd17 	ldw	r5,-12(fp)
 821944c:	1009883a 	mov	r4,r2
 8219450:	8215ed00 	call	8215ed0 <OS_EventTaskRemove>
             pmsg = (void *)0;
 8219454:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 8219458:	e0bfff17 	ldw	r2,-4(fp)
 821945c:	00c00284 	movi	r3,10
 8219460:	10c00005 	stb	r3,0(r2)
             break;
 8219464:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 8219468:	d0a07a17 	ldw	r2,-32280(gp)
 821946c:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 8219470:	d0a07a17 	ldw	r2,-32280(gp)
 8219474:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 8219478:	d0a07a17 	ldw	r2,-32280(gp)
 821947c:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 8219480:	d0a07a17 	ldw	r2,-32280(gp)
 8219484:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
 8219488:	d0a07a17 	ldw	r2,-32280(gp)
 821948c:	10000915 	stw	zero,36(r2)
 8219490:	e0bff617 	ldw	r2,-40(fp)
 8219494:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219498:	e0bffa17 	ldw	r2,-24(fp)
 821949c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
 82194a0:	e0bff517 	ldw	r2,-44(fp)
}
 82194a4:	e037883a 	mov	sp,fp
 82194a8:	dfc00117 	ldw	ra,4(sp)
 82194ac:	df000017 	ldw	fp,0(sp)
 82194b0:	dec00204 	addi	sp,sp,8
 82194b4:	f800283a 	ret

082194b8 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 82194b8:	defff604 	addi	sp,sp,-40
 82194bc:	dfc00915 	stw	ra,36(sp)
 82194c0:	df000815 	stw	fp,32(sp)
 82194c4:	df000804 	addi	fp,sp,32
 82194c8:	e13ffd15 	stw	r4,-12(fp)
 82194cc:	2805883a 	mov	r2,r5
 82194d0:	e1bfff15 	stw	r6,-4(fp)
 82194d4:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 82194d8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 82194dc:	e0bfff17 	ldw	r2,-4(fp)
 82194e0:	1000021e 	bne	r2,zero,82194ec <OSQPendAbort+0x34>
        return (0);
 82194e4:	0005883a 	mov	r2,zero
 82194e8:	00004906 	br	8219610 <OSQPendAbort+0x158>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 82194ec:	e0bffd17 	ldw	r2,-12(fp)
 82194f0:	1000051e 	bne	r2,zero,8219508 <OSQPendAbort+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 82194f4:	e0bfff17 	ldw	r2,-4(fp)
 82194f8:	00c00104 	movi	r3,4
 82194fc:	10c00005 	stb	r3,0(r2)
        return (0);
 8219500:	0005883a 	mov	r2,zero
 8219504:	00004206 	br	8219610 <OSQPendAbort+0x158>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 8219508:	e0bffd17 	ldw	r2,-12(fp)
 821950c:	10800003 	ldbu	r2,0(r2)
 8219510:	10803fcc 	andi	r2,r2,255
 8219514:	108000a0 	cmpeqi	r2,r2,2
 8219518:	1000051e 	bne	r2,zero,8219530 <OSQPendAbort+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 821951c:	e0bfff17 	ldw	r2,-4(fp)
 8219520:	00c00044 	movi	r3,1
 8219524:	10c00005 	stb	r3,0(r2)
        return (0);
 8219528:	0005883a 	mov	r2,zero
 821952c:	00003806 	br	8219610 <OSQPendAbort+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219530:	0005303a 	rdctl	r2,status
 8219534:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219538:	e0fffc17 	ldw	r3,-16(fp)
 821953c:	00bfff84 	movi	r2,-2
 8219540:	1884703a 	and	r2,r3,r2
 8219544:	1001703a 	wrctl	status,r2
  
  return context;
 8219548:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821954c:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
 8219550:	e0bffd17 	ldw	r2,-12(fp)
 8219554:	10800283 	ldbu	r2,10(r2)
 8219558:	10803fcc 	andi	r2,r2,255
 821955c:	10002526 	beq	r2,zero,82195f4 <OSQPendAbort+0x13c>
        nbr_tasks = 0;
 8219560:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
 8219564:	e0bffe03 	ldbu	r2,-8(fp)
 8219568:	10800060 	cmpeqi	r2,r2,1
 821956c:	10000e26 	beq	r2,zero,82195a8 <OSQPendAbort+0xf0>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
 8219570:	00000806 	br	8219594 <OSQPendAbort+0xdc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 8219574:	01c00084 	movi	r7,2
 8219578:	01800104 	movi	r6,4
 821957c:	000b883a 	mov	r5,zero
 8219580:	e13ffd17 	ldw	r4,-12(fp)
 8219584:	8215ad80 	call	8215ad8 <OS_EventTaskRdy>
                     nbr_tasks++;
 8219588:	e0bff803 	ldbu	r2,-32(fp)
 821958c:	10800044 	addi	r2,r2,1
 8219590:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
 8219594:	e0bffd17 	ldw	r2,-12(fp)
 8219598:	10800283 	ldbu	r2,10(r2)
 821959c:	10803fcc 	andi	r2,r2,255
 82195a0:	103ff41e 	bne	r2,zero,8219574 <OSQPendAbort+0xbc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 82195a4:	00000906 	br	82195cc <OSQPendAbort+0x114>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 82195a8:	01c00084 	movi	r7,2
 82195ac:	01800104 	movi	r6,4
 82195b0:	000b883a 	mov	r5,zero
 82195b4:	e13ffd17 	ldw	r4,-12(fp)
 82195b8:	8215ad80 	call	8215ad8 <OS_EventTaskRdy>
                 nbr_tasks++;
 82195bc:	e0bff803 	ldbu	r2,-32(fp)
 82195c0:	10800044 	addi	r2,r2,1
 82195c4:	e0bff805 	stb	r2,-32(fp)
                 break;
 82195c8:	0001883a 	nop
 82195cc:	e0bff917 	ldw	r2,-28(fp)
 82195d0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82195d4:	e0bffa17 	ldw	r2,-24(fp)
 82195d8:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
 82195dc:	82165240 	call	8216524 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 82195e0:	e0bfff17 	ldw	r2,-4(fp)
 82195e4:	00c00384 	movi	r3,14
 82195e8:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
 82195ec:	e0bff803 	ldbu	r2,-32(fp)
 82195f0:	00000706 	br	8219610 <OSQPendAbort+0x158>
 82195f4:	e0bff917 	ldw	r2,-28(fp)
 82195f8:	e0bffb15 	stw	r2,-20(fp)
 82195fc:	e0bffb17 	ldw	r2,-20(fp)
 8219600:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8219604:	e0bfff17 	ldw	r2,-4(fp)
 8219608:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
 821960c:	0005883a 	mov	r2,zero
}
 8219610:	e037883a 	mov	sp,fp
 8219614:	dfc00117 	ldw	ra,4(sp)
 8219618:	df000017 	ldw	fp,0(sp)
 821961c:	dec00204 	addi	sp,sp,8
 8219620:	f800283a 	ret

08219624 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
 8219624:	defff604 	addi	sp,sp,-40
 8219628:	dfc00915 	stw	ra,36(sp)
 821962c:	df000815 	stw	fp,32(sp)
 8219630:	df000804 	addi	fp,sp,32
 8219634:	e13ffe15 	stw	r4,-8(fp)
 8219638:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 821963c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 8219640:	e0bffe17 	ldw	r2,-8(fp)
 8219644:	1000021e 	bne	r2,zero,8219650 <OSQPost+0x2c>
        return (OS_ERR_PEVENT_NULL);
 8219648:	00800104 	movi	r2,4
 821964c:	00004a06 	br	8219778 <OSQPost+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 8219650:	e0bffe17 	ldw	r2,-8(fp)
 8219654:	10800003 	ldbu	r2,0(r2)
 8219658:	10803fcc 	andi	r2,r2,255
 821965c:	108000a0 	cmpeqi	r2,r2,2
 8219660:	1000021e 	bne	r2,zero,821966c <OSQPost+0x48>
        return (OS_ERR_EVENT_TYPE);
 8219664:	00800044 	movi	r2,1
 8219668:	00004306 	br	8219778 <OSQPost+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821966c:	0005303a 	rdctl	r2,status
 8219670:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219674:	e0fffd17 	ldw	r3,-12(fp)
 8219678:	00bfff84 	movi	r2,-2
 821967c:	1884703a 	and	r2,r3,r2
 8219680:	1001703a 	wrctl	status,r2
  
  return context;
 8219684:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 8219688:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
 821968c:	e0bffe17 	ldw	r2,-8(fp)
 8219690:	10800283 	ldbu	r2,10(r2)
 8219694:	10803fcc 	andi	r2,r2,255
 8219698:	10000c26 	beq	r2,zero,82196cc <OSQPost+0xa8>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 821969c:	000f883a 	mov	r7,zero
 82196a0:	01800104 	movi	r6,4
 82196a4:	e17fff17 	ldw	r5,-4(fp)
 82196a8:	e13ffe17 	ldw	r4,-8(fp)
 82196ac:	8215ad80 	call	8215ad8 <OS_EventTaskRdy>
 82196b0:	e0bff817 	ldw	r2,-32(fp)
 82196b4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82196b8:	e0bff917 	ldw	r2,-28(fp)
 82196bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
 82196c0:	82165240 	call	8216524 <OS_Sched>
        return (OS_ERR_NONE);
 82196c4:	0005883a 	mov	r2,zero
 82196c8:	00002b06 	br	8219778 <OSQPost+0x154>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
 82196cc:	e0bffe17 	ldw	r2,-8(fp)
 82196d0:	10800117 	ldw	r2,4(r2)
 82196d4:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
 82196d8:	e0bffb17 	ldw	r2,-20(fp)
 82196dc:	10c0058b 	ldhu	r3,22(r2)
 82196e0:	e0bffb17 	ldw	r2,-20(fp)
 82196e4:	1080050b 	ldhu	r2,20(r2)
 82196e8:	18ffffcc 	andi	r3,r3,65535
 82196ec:	10bfffcc 	andi	r2,r2,65535
 82196f0:	18800636 	bltu	r3,r2,821970c <OSQPost+0xe8>
 82196f4:	e0bff817 	ldw	r2,-32(fp)
 82196f8:	e0bffa15 	stw	r2,-24(fp)
 82196fc:	e0bffa17 	ldw	r2,-24(fp)
 8219700:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 8219704:	00800784 	movi	r2,30
 8219708:	00001b06 	br	8219778 <OSQPost+0x154>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
 821970c:	e0bffb17 	ldw	r2,-20(fp)
 8219710:	10800317 	ldw	r2,12(r2)
 8219714:	11000104 	addi	r4,r2,4
 8219718:	e0fffb17 	ldw	r3,-20(fp)
 821971c:	19000315 	stw	r4,12(r3)
 8219720:	e0ffff17 	ldw	r3,-4(fp)
 8219724:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
 8219728:	e0bffb17 	ldw	r2,-20(fp)
 821972c:	1080058b 	ldhu	r2,22(r2)
 8219730:	10800044 	addi	r2,r2,1
 8219734:	1007883a 	mov	r3,r2
 8219738:	e0bffb17 	ldw	r2,-20(fp)
 821973c:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
 8219740:	e0bffb17 	ldw	r2,-20(fp)
 8219744:	10c00317 	ldw	r3,12(r2)
 8219748:	e0bffb17 	ldw	r2,-20(fp)
 821974c:	10800217 	ldw	r2,8(r2)
 8219750:	1880041e 	bne	r3,r2,8219764 <OSQPost+0x140>
        pq->OSQIn = pq->OSQStart;
 8219754:	e0bffb17 	ldw	r2,-20(fp)
 8219758:	10c00117 	ldw	r3,4(r2)
 821975c:	e0bffb17 	ldw	r2,-20(fp)
 8219760:	10c00315 	stw	r3,12(r2)
 8219764:	e0bff817 	ldw	r2,-32(fp)
 8219768:	e0bffc15 	stw	r2,-16(fp)
 821976c:	e0bffc17 	ldw	r2,-16(fp)
 8219770:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 8219774:	0005883a 	mov	r2,zero
}
 8219778:	e037883a 	mov	sp,fp
 821977c:	dfc00117 	ldw	ra,4(sp)
 8219780:	df000017 	ldw	fp,0(sp)
 8219784:	dec00204 	addi	sp,sp,8
 8219788:	f800283a 	ret

0821978c <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
 821978c:	defff604 	addi	sp,sp,-40
 8219790:	dfc00915 	stw	ra,36(sp)
 8219794:	df000815 	stw	fp,32(sp)
 8219798:	df000804 	addi	fp,sp,32
 821979c:	e13ffe15 	stw	r4,-8(fp)
 82197a0:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 82197a4:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 82197a8:	e0bffe17 	ldw	r2,-8(fp)
 82197ac:	1000021e 	bne	r2,zero,82197b8 <OSQPostFront+0x2c>
        return (OS_ERR_PEVENT_NULL);
 82197b0:	00800104 	movi	r2,4
 82197b4:	00004c06 	br	82198e8 <OSQPostFront+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 82197b8:	e0bffe17 	ldw	r2,-8(fp)
 82197bc:	10800003 	ldbu	r2,0(r2)
 82197c0:	10803fcc 	andi	r2,r2,255
 82197c4:	108000a0 	cmpeqi	r2,r2,2
 82197c8:	1000021e 	bne	r2,zero,82197d4 <OSQPostFront+0x48>
        return (OS_ERR_EVENT_TYPE);
 82197cc:	00800044 	movi	r2,1
 82197d0:	00004506 	br	82198e8 <OSQPostFront+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82197d4:	0005303a 	rdctl	r2,status
 82197d8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82197dc:	e0fffd17 	ldw	r3,-12(fp)
 82197e0:	00bfff84 	movi	r2,-2
 82197e4:	1884703a 	and	r2,r3,r2
 82197e8:	1001703a 	wrctl	status,r2
  
  return context;
 82197ec:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 82197f0:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
 82197f4:	e0bffe17 	ldw	r2,-8(fp)
 82197f8:	10800283 	ldbu	r2,10(r2)
 82197fc:	10803fcc 	andi	r2,r2,255
 8219800:	10000c26 	beq	r2,zero,8219834 <OSQPostFront+0xa8>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 8219804:	000f883a 	mov	r7,zero
 8219808:	01800104 	movi	r6,4
 821980c:	e17fff17 	ldw	r5,-4(fp)
 8219810:	e13ffe17 	ldw	r4,-8(fp)
 8219814:	8215ad80 	call	8215ad8 <OS_EventTaskRdy>
 8219818:	e0bff817 	ldw	r2,-32(fp)
 821981c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219820:	e0bff917 	ldw	r2,-28(fp)
 8219824:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
 8219828:	82165240 	call	8216524 <OS_Sched>
        return (OS_ERR_NONE);
 821982c:	0005883a 	mov	r2,zero
 8219830:	00002d06 	br	82198e8 <OSQPostFront+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 8219834:	e0bffe17 	ldw	r2,-8(fp)
 8219838:	10800117 	ldw	r2,4(r2)
 821983c:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 8219840:	e0bffb17 	ldw	r2,-20(fp)
 8219844:	10c0058b 	ldhu	r3,22(r2)
 8219848:	e0bffb17 	ldw	r2,-20(fp)
 821984c:	1080050b 	ldhu	r2,20(r2)
 8219850:	18ffffcc 	andi	r3,r3,65535
 8219854:	10bfffcc 	andi	r2,r2,65535
 8219858:	18800636 	bltu	r3,r2,8219874 <OSQPostFront+0xe8>
 821985c:	e0bff817 	ldw	r2,-32(fp)
 8219860:	e0bffa15 	stw	r2,-24(fp)
 8219864:	e0bffa17 	ldw	r2,-24(fp)
 8219868:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 821986c:	00800784 	movi	r2,30
 8219870:	00001d06 	br	82198e8 <OSQPostFront+0x15c>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
 8219874:	e0bffb17 	ldw	r2,-20(fp)
 8219878:	10c00417 	ldw	r3,16(r2)
 821987c:	e0bffb17 	ldw	r2,-20(fp)
 8219880:	10800117 	ldw	r2,4(r2)
 8219884:	1880041e 	bne	r3,r2,8219898 <OSQPostFront+0x10c>
        pq->OSQOut = pq->OSQEnd;
 8219888:	e0bffb17 	ldw	r2,-20(fp)
 821988c:	10c00217 	ldw	r3,8(r2)
 8219890:	e0bffb17 	ldw	r2,-20(fp)
 8219894:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
 8219898:	e0bffb17 	ldw	r2,-20(fp)
 821989c:	10800417 	ldw	r2,16(r2)
 82198a0:	10ffff04 	addi	r3,r2,-4
 82198a4:	e0bffb17 	ldw	r2,-20(fp)
 82198a8:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
 82198ac:	e0bffb17 	ldw	r2,-20(fp)
 82198b0:	10800417 	ldw	r2,16(r2)
 82198b4:	e0ffff17 	ldw	r3,-4(fp)
 82198b8:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 82198bc:	e0bffb17 	ldw	r2,-20(fp)
 82198c0:	1080058b 	ldhu	r2,22(r2)
 82198c4:	10800044 	addi	r2,r2,1
 82198c8:	1007883a 	mov	r3,r2
 82198cc:	e0bffb17 	ldw	r2,-20(fp)
 82198d0:	10c0058d 	sth	r3,22(r2)
 82198d4:	e0bff817 	ldw	r2,-32(fp)
 82198d8:	e0bffc15 	stw	r2,-16(fp)
 82198dc:	e0bffc17 	ldw	r2,-16(fp)
 82198e0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 82198e4:	0005883a 	mov	r2,zero
}
 82198e8:	e037883a 	mov	sp,fp
 82198ec:	dfc00117 	ldw	ra,4(sp)
 82198f0:	df000017 	ldw	fp,0(sp)
 82198f4:	dec00204 	addi	sp,sp,8
 82198f8:	f800283a 	ret

082198fc <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
 82198fc:	defff504 	addi	sp,sp,-44
 8219900:	dfc00a15 	stw	ra,40(sp)
 8219904:	df000915 	stw	fp,36(sp)
 8219908:	df000904 	addi	fp,sp,36
 821990c:	e13ffd15 	stw	r4,-12(fp)
 8219910:	e17ffe15 	stw	r5,-8(fp)
 8219914:	3005883a 	mov	r2,r6
 8219918:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821991c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 8219920:	e0bffd17 	ldw	r2,-12(fp)
 8219924:	1000021e 	bne	r2,zero,8219930 <OSQPostOpt+0x34>
        return (OS_ERR_PEVENT_NULL);
 8219928:	00800104 	movi	r2,4
 821992c:	00007106 	br	8219af4 <OSQPostOpt+0x1f8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 8219930:	e0bffd17 	ldw	r2,-12(fp)
 8219934:	10800003 	ldbu	r2,0(r2)
 8219938:	10803fcc 	andi	r2,r2,255
 821993c:	108000a0 	cmpeqi	r2,r2,2
 8219940:	1000021e 	bne	r2,zero,821994c <OSQPostOpt+0x50>
        return (OS_ERR_EVENT_TYPE);
 8219944:	00800044 	movi	r2,1
 8219948:	00006a06 	br	8219af4 <OSQPostOpt+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821994c:	0005303a 	rdctl	r2,status
 8219950:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219954:	e0fffc17 	ldw	r3,-16(fp)
 8219958:	00bfff84 	movi	r2,-2
 821995c:	1884703a 	and	r2,r3,r2
 8219960:	1001703a 	wrctl	status,r2
  
  return context;
 8219964:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8219968:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
 821996c:	e0bffd17 	ldw	r2,-12(fp)
 8219970:	10800283 	ldbu	r2,10(r2)
 8219974:	10803fcc 	andi	r2,r2,255
 8219978:	10001d26 	beq	r2,zero,82199f0 <OSQPostOpt+0xf4>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
 821997c:	e0bfff03 	ldbu	r2,-4(fp)
 8219980:	1080004c 	andi	r2,r2,1
 8219984:	10000b26 	beq	r2,zero,82199b4 <OSQPostOpt+0xb8>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 8219988:	00000506 	br	82199a0 <OSQPostOpt+0xa4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 821998c:	000f883a 	mov	r7,zero
 8219990:	01800104 	movi	r6,4
 8219994:	e17ffe17 	ldw	r5,-8(fp)
 8219998:	e13ffd17 	ldw	r4,-12(fp)
 821999c:	8215ad80 	call	8215ad8 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 82199a0:	e0bffd17 	ldw	r2,-12(fp)
 82199a4:	10800283 	ldbu	r2,10(r2)
 82199a8:	10803fcc 	andi	r2,r2,255
 82199ac:	103ff71e 	bne	r2,zero,821998c <OSQPostOpt+0x90>
 82199b0:	00000506 	br	82199c8 <OSQPostOpt+0xcc>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 82199b4:	000f883a 	mov	r7,zero
 82199b8:	01800104 	movi	r6,4
 82199bc:	e17ffe17 	ldw	r5,-8(fp)
 82199c0:	e13ffd17 	ldw	r4,-12(fp)
 82199c4:	8215ad80 	call	8215ad8 <OS_EventTaskRdy>
 82199c8:	e0bff717 	ldw	r2,-36(fp)
 82199cc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82199d0:	e0bff817 	ldw	r2,-32(fp)
 82199d4:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
 82199d8:	e0bfff03 	ldbu	r2,-4(fp)
 82199dc:	1080010c 	andi	r2,r2,4
 82199e0:	1000011e 	bne	r2,zero,82199e8 <OSQPostOpt+0xec>
            OS_Sched();                               /* Find highest priority task ready to run       */
 82199e4:	82165240 	call	8216524 <OS_Sched>
        }
        return (OS_ERR_NONE);
 82199e8:	0005883a 	mov	r2,zero
 82199ec:	00004106 	br	8219af4 <OSQPostOpt+0x1f8>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 82199f0:	e0bffd17 	ldw	r2,-12(fp)
 82199f4:	10800117 	ldw	r2,4(r2)
 82199f8:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 82199fc:	e0bffa17 	ldw	r2,-24(fp)
 8219a00:	10c0058b 	ldhu	r3,22(r2)
 8219a04:	e0bffa17 	ldw	r2,-24(fp)
 8219a08:	1080050b 	ldhu	r2,20(r2)
 8219a0c:	18ffffcc 	andi	r3,r3,65535
 8219a10:	10bfffcc 	andi	r2,r2,65535
 8219a14:	18800636 	bltu	r3,r2,8219a30 <OSQPostOpt+0x134>
 8219a18:	e0bff717 	ldw	r2,-36(fp)
 8219a1c:	e0bff915 	stw	r2,-28(fp)
 8219a20:	e0bff917 	ldw	r2,-28(fp)
 8219a24:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 8219a28:	00800784 	movi	r2,30
 8219a2c:	00003106 	br	8219af4 <OSQPostOpt+0x1f8>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
 8219a30:	e0bfff03 	ldbu	r2,-4(fp)
 8219a34:	1080008c 	andi	r2,r2,2
 8219a38:	10001326 	beq	r2,zero,8219a88 <OSQPostOpt+0x18c>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
 8219a3c:	e0bffa17 	ldw	r2,-24(fp)
 8219a40:	10c00417 	ldw	r3,16(r2)
 8219a44:	e0bffa17 	ldw	r2,-24(fp)
 8219a48:	10800117 	ldw	r2,4(r2)
 8219a4c:	1880041e 	bne	r3,r2,8219a60 <OSQPostOpt+0x164>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
 8219a50:	e0bffa17 	ldw	r2,-24(fp)
 8219a54:	10c00217 	ldw	r3,8(r2)
 8219a58:	e0bffa17 	ldw	r2,-24(fp)
 8219a5c:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
 8219a60:	e0bffa17 	ldw	r2,-24(fp)
 8219a64:	10800417 	ldw	r2,16(r2)
 8219a68:	10ffff04 	addi	r3,r2,-4
 8219a6c:	e0bffa17 	ldw	r2,-24(fp)
 8219a70:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
 8219a74:	e0bffa17 	ldw	r2,-24(fp)
 8219a78:	10800417 	ldw	r2,16(r2)
 8219a7c:	e0fffe17 	ldw	r3,-8(fp)
 8219a80:	10c00015 	stw	r3,0(r2)
 8219a84:	00001006 	br	8219ac8 <OSQPostOpt+0x1cc>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
 8219a88:	e0bffa17 	ldw	r2,-24(fp)
 8219a8c:	10800317 	ldw	r2,12(r2)
 8219a90:	11000104 	addi	r4,r2,4
 8219a94:	e0fffa17 	ldw	r3,-24(fp)
 8219a98:	19000315 	stw	r4,12(r3)
 8219a9c:	e0fffe17 	ldw	r3,-8(fp)
 8219aa0:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
 8219aa4:	e0bffa17 	ldw	r2,-24(fp)
 8219aa8:	10c00317 	ldw	r3,12(r2)
 8219aac:	e0bffa17 	ldw	r2,-24(fp)
 8219ab0:	10800217 	ldw	r2,8(r2)
 8219ab4:	1880041e 	bne	r3,r2,8219ac8 <OSQPostOpt+0x1cc>
            pq->OSQIn = pq->OSQStart;
 8219ab8:	e0bffa17 	ldw	r2,-24(fp)
 8219abc:	10c00117 	ldw	r3,4(r2)
 8219ac0:	e0bffa17 	ldw	r2,-24(fp)
 8219ac4:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 8219ac8:	e0bffa17 	ldw	r2,-24(fp)
 8219acc:	1080058b 	ldhu	r2,22(r2)
 8219ad0:	10800044 	addi	r2,r2,1
 8219ad4:	1007883a 	mov	r3,r2
 8219ad8:	e0bffa17 	ldw	r2,-24(fp)
 8219adc:	10c0058d 	sth	r3,22(r2)
 8219ae0:	e0bff717 	ldw	r2,-36(fp)
 8219ae4:	e0bffb15 	stw	r2,-20(fp)
 8219ae8:	e0bffb17 	ldw	r2,-20(fp)
 8219aec:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 8219af0:	0005883a 	mov	r2,zero
}
 8219af4:	e037883a 	mov	sp,fp
 8219af8:	dfc00117 	ldw	ra,4(sp)
 8219afc:	df000017 	ldw	fp,0(sp)
 8219b00:	dec00204 	addi	sp,sp,8
 8219b04:	f800283a 	ret

08219b08 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
 8219b08:	defff604 	addi	sp,sp,-40
 8219b0c:	df000915 	stw	fp,36(sp)
 8219b10:	df000904 	addi	fp,sp,36
 8219b14:	e13ffe15 	stw	r4,-8(fp)
 8219b18:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 8219b1c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 8219b20:	e0bffe17 	ldw	r2,-8(fp)
 8219b24:	1000021e 	bne	r2,zero,8219b30 <OSQQuery+0x28>
        return (OS_ERR_PEVENT_NULL);
 8219b28:	00800104 	movi	r2,4
 8219b2c:	00004906 	br	8219c54 <OSQQuery+0x14c>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
 8219b30:	e0bfff17 	ldw	r2,-4(fp)
 8219b34:	1000021e 	bne	r2,zero,8219b40 <OSQQuery+0x38>
        return (OS_ERR_PDATA_NULL);
 8219b38:	00800244 	movi	r2,9
 8219b3c:	00004506 	br	8219c54 <OSQQuery+0x14c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 8219b40:	e0bffe17 	ldw	r2,-8(fp)
 8219b44:	10800003 	ldbu	r2,0(r2)
 8219b48:	10803fcc 	andi	r2,r2,255
 8219b4c:	108000a0 	cmpeqi	r2,r2,2
 8219b50:	1000021e 	bne	r2,zero,8219b5c <OSQQuery+0x54>
        return (OS_ERR_EVENT_TYPE);
 8219b54:	00800044 	movi	r2,1
 8219b58:	00003e06 	br	8219c54 <OSQQuery+0x14c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219b5c:	0005303a 	rdctl	r2,status
 8219b60:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219b64:	e0fffd17 	ldw	r3,-12(fp)
 8219b68:	00bfff84 	movi	r2,-2
 8219b6c:	1884703a 	and	r2,r3,r2
 8219b70:	1001703a 	wrctl	status,r2
  
  return context;
 8219b74:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 8219b78:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
 8219b7c:	e0bffe17 	ldw	r2,-8(fp)
 8219b80:	10c00283 	ldbu	r3,10(r2)
 8219b84:	e0bfff17 	ldw	r2,-4(fp)
 8219b88:	10c002c5 	stb	r3,11(r2)
    psrc                 = &pevent->OSEventTbl[0];
 8219b8c:	e0bffe17 	ldw	r2,-8(fp)
 8219b90:	108002c4 	addi	r2,r2,11
 8219b94:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
 8219b98:	e0bfff17 	ldw	r2,-4(fp)
 8219b9c:	10800204 	addi	r2,r2,8
 8219ba0:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 8219ba4:	e03ff705 	stb	zero,-36(fp)
 8219ba8:	00000b06 	br	8219bd8 <OSQQuery+0xd0>
        *pdest++ = *psrc++;
 8219bac:	e0bff917 	ldw	r2,-28(fp)
 8219bb0:	10c00044 	addi	r3,r2,1
 8219bb4:	e0fff915 	stw	r3,-28(fp)
 8219bb8:	e0fff817 	ldw	r3,-32(fp)
 8219bbc:	19000044 	addi	r4,r3,1
 8219bc0:	e13ff815 	stw	r4,-32(fp)
 8219bc4:	18c00003 	ldbu	r3,0(r3)
 8219bc8:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 8219bcc:	e0bff703 	ldbu	r2,-36(fp)
 8219bd0:	10800044 	addi	r2,r2,1
 8219bd4:	e0bff705 	stb	r2,-36(fp)
 8219bd8:	e0bff703 	ldbu	r2,-36(fp)
 8219bdc:	108000f0 	cmpltui	r2,r2,3
 8219be0:	103ff21e 	bne	r2,zero,8219bac <OSQQuery+0xa4>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
 8219be4:	e0bffe17 	ldw	r2,-8(fp)
 8219be8:	10800117 	ldw	r2,4(r2)
 8219bec:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
 8219bf0:	e0bffc17 	ldw	r2,-16(fp)
 8219bf4:	1080058b 	ldhu	r2,22(r2)
 8219bf8:	10bfffcc 	andi	r2,r2,65535
 8219bfc:	10000626 	beq	r2,zero,8219c18 <OSQQuery+0x110>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
 8219c00:	e0bffc17 	ldw	r2,-16(fp)
 8219c04:	10800417 	ldw	r2,16(r2)
 8219c08:	10c00017 	ldw	r3,0(r2)
 8219c0c:	e0bfff17 	ldw	r2,-4(fp)
 8219c10:	10c00015 	stw	r3,0(r2)
 8219c14:	00000206 	br	8219c20 <OSQQuery+0x118>
    } else {
        p_q_data->OSMsg = (void *)0;
 8219c18:	e0bfff17 	ldw	r2,-4(fp)
 8219c1c:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
 8219c20:	e0bffc17 	ldw	r2,-16(fp)
 8219c24:	10c0058b 	ldhu	r3,22(r2)
 8219c28:	e0bfff17 	ldw	r2,-4(fp)
 8219c2c:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
 8219c30:	e0bffc17 	ldw	r2,-16(fp)
 8219c34:	10c0050b 	ldhu	r3,20(r2)
 8219c38:	e0bfff17 	ldw	r2,-4(fp)
 8219c3c:	10c0018d 	sth	r3,6(r2)
 8219c40:	e0bffa17 	ldw	r2,-24(fp)
 8219c44:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219c48:	e0bffb17 	ldw	r2,-20(fp)
 8219c4c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 8219c50:	0005883a 	mov	r2,zero
}
 8219c54:	e037883a 	mov	sp,fp
 8219c58:	df000017 	ldw	fp,0(sp)
 8219c5c:	dec00104 	addi	sp,sp,4
 8219c60:	f800283a 	ret

08219c64 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
 8219c64:	defffb04 	addi	sp,sp,-20
 8219c68:	dfc00415 	stw	ra,16(sp)
 8219c6c:	df000315 	stw	fp,12(sp)
 8219c70:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
 8219c74:	01407804 	movi	r5,480
 8219c78:	010209b4 	movhi	r4,2086
 8219c7c:	21301d04 	addi	r4,r4,-16268
 8219c80:	82164680 	call	8216468 <OS_MemClr>
    pq1 = &OSQTbl[0];
 8219c84:	008209b4 	movhi	r2,2086
 8219c88:	10b01d04 	addi	r2,r2,-16268
 8219c8c:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
 8219c90:	008209b4 	movhi	r2,2086
 8219c94:	10b02304 	addi	r2,r2,-16244
 8219c98:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 8219c9c:	e03ffd0d 	sth	zero,-12(fp)
 8219ca0:	00000c06 	br	8219cd4 <OS_QInit+0x70>
        pq1->OSQPtr = pq2;
 8219ca4:	e0bffe17 	ldw	r2,-8(fp)
 8219ca8:	e0ffff17 	ldw	r3,-4(fp)
 8219cac:	10c00015 	stw	r3,0(r2)
        pq1++;
 8219cb0:	e0bffe17 	ldw	r2,-8(fp)
 8219cb4:	10800604 	addi	r2,r2,24
 8219cb8:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
 8219cbc:	e0bfff17 	ldw	r2,-4(fp)
 8219cc0:	10800604 	addi	r2,r2,24
 8219cc4:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 8219cc8:	e0bffd0b 	ldhu	r2,-12(fp)
 8219ccc:	10800044 	addi	r2,r2,1
 8219cd0:	e0bffd0d 	sth	r2,-12(fp)
 8219cd4:	e0bffd0b 	ldhu	r2,-12(fp)
 8219cd8:	108004f0 	cmpltui	r2,r2,19
 8219cdc:	103ff11e 	bne	r2,zero,8219ca4 <OS_QInit+0x40>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
 8219ce0:	e0bffe17 	ldw	r2,-8(fp)
 8219ce4:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
 8219ce8:	008209b4 	movhi	r2,2086
 8219cec:	10b01d04 	addi	r2,r2,-16268
 8219cf0:	d0a07615 	stw	r2,-32296(gp)
#endif
}
 8219cf4:	0001883a 	nop
 8219cf8:	e037883a 	mov	sp,fp
 8219cfc:	dfc00117 	ldw	ra,4(sp)
 8219d00:	df000017 	ldw	fp,0(sp)
 8219d04:	dec00204 	addi	sp,sp,8
 8219d08:	f800283a 	ret

08219d0c <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
 8219d0c:	defffa04 	addi	sp,sp,-24
 8219d10:	df000515 	stw	fp,20(sp)
 8219d14:	df000504 	addi	fp,sp,20
 8219d18:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 8219d1c:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 8219d20:	e0bfff17 	ldw	r2,-4(fp)
 8219d24:	1000021e 	bne	r2,zero,8219d30 <OSSemAccept+0x24>
        return (0);
 8219d28:	0005883a 	mov	r2,zero
 8219d2c:	00001f06 	br	8219dac <OSSemAccept+0xa0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 8219d30:	e0bfff17 	ldw	r2,-4(fp)
 8219d34:	10800003 	ldbu	r2,0(r2)
 8219d38:	10803fcc 	andi	r2,r2,255
 8219d3c:	108000e0 	cmpeqi	r2,r2,3
 8219d40:	1000021e 	bne	r2,zero,8219d4c <OSSemAccept+0x40>
        return (0);
 8219d44:	0005883a 	mov	r2,zero
 8219d48:	00001806 	br	8219dac <OSSemAccept+0xa0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219d4c:	0005303a 	rdctl	r2,status
 8219d50:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219d54:	e0fffe17 	ldw	r3,-8(fp)
 8219d58:	00bfff84 	movi	r2,-2
 8219d5c:	1884703a 	and	r2,r3,r2
 8219d60:	1001703a 	wrctl	status,r2
  
  return context;
 8219d64:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 8219d68:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
 8219d6c:	e0bfff17 	ldw	r2,-4(fp)
 8219d70:	1080020b 	ldhu	r2,8(r2)
 8219d74:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
 8219d78:	e0bffd0b 	ldhu	r2,-12(fp)
 8219d7c:	10000626 	beq	r2,zero,8219d98 <OSSemAccept+0x8c>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
 8219d80:	e0bfff17 	ldw	r2,-4(fp)
 8219d84:	1080020b 	ldhu	r2,8(r2)
 8219d88:	10bfffc4 	addi	r2,r2,-1
 8219d8c:	1007883a 	mov	r3,r2
 8219d90:	e0bfff17 	ldw	r2,-4(fp)
 8219d94:	10c0020d 	sth	r3,8(r2)
 8219d98:	e0bffb17 	ldw	r2,-20(fp)
 8219d9c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219da0:	e0bffc17 	ldw	r2,-16(fp)
 8219da4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
 8219da8:	e0bffd0b 	ldhu	r2,-12(fp)
}
 8219dac:	e037883a 	mov	sp,fp
 8219db0:	df000017 	ldw	fp,0(sp)
 8219db4:	dec00104 	addi	sp,sp,4
 8219db8:	f800283a 	ret

08219dbc <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
 8219dbc:	defff904 	addi	sp,sp,-28
 8219dc0:	dfc00615 	stw	ra,24(sp)
 8219dc4:	df000515 	stw	fp,20(sp)
 8219dc8:	df000504 	addi	fp,sp,20
 8219dcc:	2005883a 	mov	r2,r4
 8219dd0:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 8219dd4:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 8219dd8:	d0a07903 	ldbu	r2,-32284(gp)
 8219ddc:	10803fcc 	andi	r2,r2,255
 8219de0:	10000226 	beq	r2,zero,8219dec <OSSemCreate+0x30>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
 8219de4:	0005883a 	mov	r2,zero
 8219de8:	00002506 	br	8219e80 <OSSemCreate+0xc4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219dec:	0005303a 	rdctl	r2,status
 8219df0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219df4:	e0fffe17 	ldw	r3,-8(fp)
 8219df8:	00bfff84 	movi	r2,-2
 8219dfc:	1884703a 	and	r2,r3,r2
 8219e00:	1001703a 	wrctl	status,r2
  
  return context;
 8219e04:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 8219e08:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
 8219e0c:	d0a07817 	ldw	r2,-32288(gp)
 8219e10:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
 8219e14:	d0a07817 	ldw	r2,-32288(gp)
 8219e18:	10000326 	beq	r2,zero,8219e28 <OSSemCreate+0x6c>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 8219e1c:	d0a07817 	ldw	r2,-32288(gp)
 8219e20:	10800117 	ldw	r2,4(r2)
 8219e24:	d0a07815 	stw	r2,-32288(gp)
 8219e28:	e0bffb17 	ldw	r2,-20(fp)
 8219e2c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219e30:	e0bffc17 	ldw	r2,-16(fp)
 8219e34:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
 8219e38:	e0bffd17 	ldw	r2,-12(fp)
 8219e3c:	10000f26 	beq	r2,zero,8219e7c <OSSemCreate+0xc0>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
 8219e40:	e0bffd17 	ldw	r2,-12(fp)
 8219e44:	00c000c4 	movi	r3,3
 8219e48:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
 8219e4c:	e0bffd17 	ldw	r2,-12(fp)
 8219e50:	e0ffff0b 	ldhu	r3,-4(fp)
 8219e54:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
 8219e58:	e0bffd17 	ldw	r2,-12(fp)
 8219e5c:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
 8219e60:	e0bffd17 	ldw	r2,-12(fp)
 8219e64:	00c00fc4 	movi	r3,63
 8219e68:	10c00385 	stb	r3,14(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
 8219e6c:	e0bffd17 	ldw	r2,-12(fp)
 8219e70:	100003c5 	stb	zero,15(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
 8219e74:	e13ffd17 	ldw	r4,-12(fp)
 8219e78:	82160880 	call	8216088 <OS_EventWaitListInit>
    }
    return (pevent);
 8219e7c:	e0bffd17 	ldw	r2,-12(fp)
}
 8219e80:	e037883a 	mov	sp,fp
 8219e84:	dfc00117 	ldw	ra,4(sp)
 8219e88:	df000017 	ldw	fp,0(sp)
 8219e8c:	dec00204 	addi	sp,sp,8
 8219e90:	f800283a 	ret

08219e94 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 8219e94:	defff304 	addi	sp,sp,-52
 8219e98:	dfc00c15 	stw	ra,48(sp)
 8219e9c:	df000b15 	stw	fp,44(sp)
 8219ea0:	df000b04 	addi	fp,sp,44
 8219ea4:	e13ffd15 	stw	r4,-12(fp)
 8219ea8:	2805883a 	mov	r2,r5
 8219eac:	e1bfff15 	stw	r6,-4(fp)
 8219eb0:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 8219eb4:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 8219eb8:	e0bfff17 	ldw	r2,-4(fp)
 8219ebc:	1000021e 	bne	r2,zero,8219ec8 <OSSemDel+0x34>
        return (pevent);
 8219ec0:	e0bffd17 	ldw	r2,-12(fp)
 8219ec4:	00007e06 	br	821a0c0 <OSSemDel+0x22c>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 8219ec8:	e0bffd17 	ldw	r2,-12(fp)
 8219ecc:	1000051e 	bne	r2,zero,8219ee4 <OSSemDel+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 8219ed0:	e0bfff17 	ldw	r2,-4(fp)
 8219ed4:	00c00104 	movi	r3,4
 8219ed8:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8219edc:	e0bffd17 	ldw	r2,-12(fp)
 8219ee0:	00007706 	br	821a0c0 <OSSemDel+0x22c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 8219ee4:	e0bffd17 	ldw	r2,-12(fp)
 8219ee8:	10800003 	ldbu	r2,0(r2)
 8219eec:	10803fcc 	andi	r2,r2,255
 8219ef0:	108000e0 	cmpeqi	r2,r2,3
 8219ef4:	1000051e 	bne	r2,zero,8219f0c <OSSemDel+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 8219ef8:	e0bfff17 	ldw	r2,-4(fp)
 8219efc:	00c00044 	movi	r3,1
 8219f00:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8219f04:	e0bffd17 	ldw	r2,-12(fp)
 8219f08:	00006d06 	br	821a0c0 <OSSemDel+0x22c>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 8219f0c:	d0a07903 	ldbu	r2,-32284(gp)
 8219f10:	10803fcc 	andi	r2,r2,255
 8219f14:	10000526 	beq	r2,zero,8219f2c <OSSemDel+0x98>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
 8219f18:	e0bfff17 	ldw	r2,-4(fp)
 8219f1c:	00c003c4 	movi	r3,15
 8219f20:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8219f24:	e0bffd17 	ldw	r2,-12(fp)
 8219f28:	00006506 	br	821a0c0 <OSSemDel+0x22c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219f2c:	0005303a 	rdctl	r2,status
 8219f30:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219f34:	e0fffc17 	ldw	r3,-16(fp)
 8219f38:	00bfff84 	movi	r2,-2
 8219f3c:	1884703a 	and	r2,r3,r2
 8219f40:	1001703a 	wrctl	status,r2
  
  return context;
 8219f44:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8219f48:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
 8219f4c:	e0bffd17 	ldw	r2,-12(fp)
 8219f50:	10800283 	ldbu	r2,10(r2)
 8219f54:	10803fcc 	andi	r2,r2,255
 8219f58:	10000326 	beq	r2,zero,8219f68 <OSSemDel+0xd4>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 8219f5c:	00800044 	movi	r2,1
 8219f60:	e0bff505 	stb	r2,-44(fp)
 8219f64:	00000106 	br	8219f6c <OSSemDel+0xd8>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 8219f68:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
 8219f6c:	e0bffe03 	ldbu	r2,-8(fp)
 8219f70:	10000326 	beq	r2,zero,8219f80 <OSSemDel+0xec>
 8219f74:	10800060 	cmpeqi	r2,r2,1
 8219f78:	1000281e 	bne	r2,zero,821a01c <OSSemDel+0x188>
 8219f7c:	00004506 	br	821a094 <OSSemDel+0x200>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
 8219f80:	e0bff503 	ldbu	r2,-44(fp)
 8219f84:	1000161e 	bne	r2,zero,8219fe0 <OSSemDel+0x14c>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 8219f88:	e0bffd17 	ldw	r2,-12(fp)
 8219f8c:	00c00fc4 	movi	r3,63
 8219f90:	10c00385 	stb	r3,14(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 8219f94:	e0bffd17 	ldw	r2,-12(fp)
 8219f98:	100003c5 	stb	zero,15(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 8219f9c:	e0bffd17 	ldw	r2,-12(fp)
 8219fa0:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 8219fa4:	d0e07817 	ldw	r3,-32288(gp)
 8219fa8:	e0bffd17 	ldw	r2,-12(fp)
 8219fac:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 8219fb0:	e0bffd17 	ldw	r2,-12(fp)
 8219fb4:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 8219fb8:	e0bffd17 	ldw	r2,-12(fp)
 8219fbc:	d0a07815 	stw	r2,-32288(gp)
 8219fc0:	e0bff717 	ldw	r2,-36(fp)
 8219fc4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219fc8:	e0bff817 	ldw	r2,-32(fp)
 8219fcc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 8219fd0:	e0bfff17 	ldw	r2,-4(fp)
 8219fd4:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
 8219fd8:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
 8219fdc:	00003706 	br	821a0bc <OSSemDel+0x228>
 8219fe0:	e0bff717 	ldw	r2,-36(fp)
 8219fe4:	e0bff915 	stw	r2,-28(fp)
 8219fe8:	e0bff917 	ldw	r2,-28(fp)
 8219fec:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 8219ff0:	e0bfff17 	ldw	r2,-4(fp)
 8219ff4:	00c01244 	movi	r3,73
 8219ff8:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
 8219ffc:	e0bffd17 	ldw	r2,-12(fp)
 821a000:	e0bff615 	stw	r2,-40(fp)
             }
             break;
 821a004:	00002d06 	br	821a0bc <OSSemDel+0x228>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 821a008:	000f883a 	mov	r7,zero
 821a00c:	01800044 	movi	r6,1
 821a010:	000b883a 	mov	r5,zero
 821a014:	e13ffd17 	ldw	r4,-12(fp)
 821a018:	8215ad80 	call	8215ad8 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
 821a01c:	e0bffd17 	ldw	r2,-12(fp)
 821a020:	10800283 	ldbu	r2,10(r2)
 821a024:	10803fcc 	andi	r2,r2,255
 821a028:	103ff71e 	bne	r2,zero,821a008 <OSSemDel+0x174>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 821a02c:	e0bffd17 	ldw	r2,-12(fp)
 821a030:	00c00fc4 	movi	r3,63
 821a034:	10c00385 	stb	r3,14(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 821a038:	e0bffd17 	ldw	r2,-12(fp)
 821a03c:	100003c5 	stb	zero,15(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 821a040:	e0bffd17 	ldw	r2,-12(fp)
 821a044:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 821a048:	d0e07817 	ldw	r3,-32288(gp)
 821a04c:	e0bffd17 	ldw	r2,-12(fp)
 821a050:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 821a054:	e0bffd17 	ldw	r2,-12(fp)
 821a058:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 821a05c:	e0bffd17 	ldw	r2,-12(fp)
 821a060:	d0a07815 	stw	r2,-32288(gp)
 821a064:	e0bff717 	ldw	r2,-36(fp)
 821a068:	e0bffa15 	stw	r2,-24(fp)
 821a06c:	e0bffa17 	ldw	r2,-24(fp)
 821a070:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 821a074:	e0bff503 	ldbu	r2,-44(fp)
 821a078:	10800058 	cmpnei	r2,r2,1
 821a07c:	1000011e 	bne	r2,zero,821a084 <OSSemDel+0x1f0>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 821a080:	82165240 	call	8216524 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 821a084:	e0bfff17 	ldw	r2,-4(fp)
 821a088:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
 821a08c:	e03ff615 	stw	zero,-40(fp)
             break;
 821a090:	00000a06 	br	821a0bc <OSSemDel+0x228>
 821a094:	e0bff717 	ldw	r2,-36(fp)
 821a098:	e0bffb15 	stw	r2,-20(fp)
 821a09c:	e0bffb17 	ldw	r2,-20(fp)
 821a0a0:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 821a0a4:	e0bfff17 	ldw	r2,-4(fp)
 821a0a8:	00c001c4 	movi	r3,7
 821a0ac:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
 821a0b0:	e0bffd17 	ldw	r2,-12(fp)
 821a0b4:	e0bff615 	stw	r2,-40(fp)
             break;
 821a0b8:	0001883a 	nop
    }
    return (pevent_return);
 821a0bc:	e0bff617 	ldw	r2,-40(fp)
}
 821a0c0:	e037883a 	mov	sp,fp
 821a0c4:	dfc00117 	ldw	ra,4(sp)
 821a0c8:	df000017 	ldw	fp,0(sp)
 821a0cc:	dec00204 	addi	sp,sp,8
 821a0d0:	f800283a 	ret

0821a0d4 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 821a0d4:	defff504 	addi	sp,sp,-44
 821a0d8:	dfc00a15 	stw	ra,40(sp)
 821a0dc:	df000915 	stw	fp,36(sp)
 821a0e0:	df000904 	addi	fp,sp,36
 821a0e4:	e13ffd15 	stw	r4,-12(fp)
 821a0e8:	2805883a 	mov	r2,r5
 821a0ec:	e1bfff15 	stw	r6,-4(fp)
 821a0f0:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821a0f4:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 821a0f8:	e0bfff17 	ldw	r2,-4(fp)
 821a0fc:	10007226 	beq	r2,zero,821a2c8 <OSSemPend+0x1f4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 821a100:	e0bffd17 	ldw	r2,-12(fp)
 821a104:	1000041e 	bne	r2,zero,821a118 <OSSemPend+0x44>
        *perr = OS_ERR_PEVENT_NULL;
 821a108:	e0bfff17 	ldw	r2,-4(fp)
 821a10c:	00c00104 	movi	r3,4
 821a110:	10c00005 	stb	r3,0(r2)
        return;
 821a114:	00006d06 	br	821a2cc <OSSemPend+0x1f8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 821a118:	e0bffd17 	ldw	r2,-12(fp)
 821a11c:	10800003 	ldbu	r2,0(r2)
 821a120:	10803fcc 	andi	r2,r2,255
 821a124:	108000e0 	cmpeqi	r2,r2,3
 821a128:	1000041e 	bne	r2,zero,821a13c <OSSemPend+0x68>
        *perr = OS_ERR_EVENT_TYPE;
 821a12c:	e0bfff17 	ldw	r2,-4(fp)
 821a130:	00c00044 	movi	r3,1
 821a134:	10c00005 	stb	r3,0(r2)
        return;
 821a138:	00006406 	br	821a2cc <OSSemPend+0x1f8>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
 821a13c:	d0a07903 	ldbu	r2,-32284(gp)
 821a140:	10803fcc 	andi	r2,r2,255
 821a144:	10000426 	beq	r2,zero,821a158 <OSSemPend+0x84>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
 821a148:	e0bfff17 	ldw	r2,-4(fp)
 821a14c:	00c00084 	movi	r3,2
 821a150:	10c00005 	stb	r3,0(r2)
        return;
 821a154:	00005d06 	br	821a2cc <OSSemPend+0x1f8>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
 821a158:	d0a06b03 	ldbu	r2,-32340(gp)
 821a15c:	10803fcc 	andi	r2,r2,255
 821a160:	10000426 	beq	r2,zero,821a174 <OSSemPend+0xa0>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
 821a164:	e0bfff17 	ldw	r2,-4(fp)
 821a168:	00c00344 	movi	r3,13
 821a16c:	10c00005 	stb	r3,0(r2)
        return;
 821a170:	00005606 	br	821a2cc <OSSemPend+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a174:	0005303a 	rdctl	r2,status
 821a178:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a17c:	e0fffc17 	ldw	r3,-16(fp)
 821a180:	00bfff84 	movi	r2,-2
 821a184:	1884703a 	and	r2,r3,r2
 821a188:	1001703a 	wrctl	status,r2
  
  return context;
 821a18c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821a190:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
 821a194:	e0bffd17 	ldw	r2,-12(fp)
 821a198:	1080020b 	ldhu	r2,8(r2)
 821a19c:	10bfffcc 	andi	r2,r2,65535
 821a1a0:	10000d26 	beq	r2,zero,821a1d8 <OSSemPend+0x104>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
 821a1a4:	e0bffd17 	ldw	r2,-12(fp)
 821a1a8:	1080020b 	ldhu	r2,8(r2)
 821a1ac:	10bfffc4 	addi	r2,r2,-1
 821a1b0:	1007883a 	mov	r3,r2
 821a1b4:	e0bffd17 	ldw	r2,-12(fp)
 821a1b8:	10c0020d 	sth	r3,8(r2)
 821a1bc:	e0bff717 	ldw	r2,-36(fp)
 821a1c0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a1c4:	e0bff817 	ldw	r2,-32(fp)
 821a1c8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 821a1cc:	e0bfff17 	ldw	r2,-4(fp)
 821a1d0:	10000005 	stb	zero,0(r2)
        return;
 821a1d4:	00003d06 	br	821a2cc <OSSemPend+0x1f8>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
 821a1d8:	d0a07a17 	ldw	r2,-32280(gp)
 821a1dc:	d0e07a17 	ldw	r3,-32280(gp)
 821a1e0:	18c00c03 	ldbu	r3,48(r3)
 821a1e4:	18c00054 	ori	r3,r3,1
 821a1e8:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 821a1ec:	d0a07a17 	ldw	r2,-32280(gp)
 821a1f0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
 821a1f4:	d0a07a17 	ldw	r2,-32280(gp)
 821a1f8:	e0fffe0b 	ldhu	r3,-8(fp)
 821a1fc:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
 821a200:	e13ffd17 	ldw	r4,-12(fp)
 821a204:	8215c700 	call	8215c70 <OS_EventTaskWait>
 821a208:	e0bff717 	ldw	r2,-36(fp)
 821a20c:	e0bffb15 	stw	r2,-20(fp)
 821a210:	e0bffb17 	ldw	r2,-20(fp)
 821a214:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
 821a218:	82165240 	call	8216524 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a21c:	0005303a 	rdctl	r2,status
 821a220:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a224:	e0fff917 	ldw	r3,-28(fp)
 821a228:	00bfff84 	movi	r2,-2
 821a22c:	1884703a 	and	r2,r3,r2
 821a230:	1001703a 	wrctl	status,r2
  
  return context;
 821a234:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
 821a238:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 821a23c:	d0a07a17 	ldw	r2,-32280(gp)
 821a240:	10800c43 	ldbu	r2,49(r2)
 821a244:	10803fcc 	andi	r2,r2,255
 821a248:	10000326 	beq	r2,zero,821a258 <OSSemPend+0x184>
 821a24c:	108000a0 	cmpeqi	r2,r2,2
 821a250:	1000041e 	bne	r2,zero,821a264 <OSSemPend+0x190>
 821a254:	00000706 	br	821a274 <OSSemPend+0x1a0>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
 821a258:	e0bfff17 	ldw	r2,-4(fp)
 821a25c:	10000005 	stb	zero,0(r2)
             break;
 821a260:	00000c06 	br	821a294 <OSSemPend+0x1c0>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 821a264:	e0bfff17 	ldw	r2,-4(fp)
 821a268:	00c00384 	movi	r3,14
 821a26c:	10c00005 	stb	r3,0(r2)
             break;
 821a270:	00000806 	br	821a294 <OSSemPend+0x1c0>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
 821a274:	d0a07a17 	ldw	r2,-32280(gp)
 821a278:	e17ffd17 	ldw	r5,-12(fp)
 821a27c:	1009883a 	mov	r4,r2
 821a280:	8215ed00 	call	8215ed0 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 821a284:	e0bfff17 	ldw	r2,-4(fp)
 821a288:	00c00284 	movi	r3,10
 821a28c:	10c00005 	stb	r3,0(r2)
             break;
 821a290:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 821a294:	d0a07a17 	ldw	r2,-32280(gp)
 821a298:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 821a29c:	d0a07a17 	ldw	r2,-32280(gp)
 821a2a0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 821a2a4:	d0a07a17 	ldw	r2,-32280(gp)
 821a2a8:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 821a2ac:	d0a07a17 	ldw	r2,-32280(gp)
 821a2b0:	10000815 	stw	zero,32(r2)
 821a2b4:	e0bff717 	ldw	r2,-36(fp)
 821a2b8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a2bc:	e0bffa17 	ldw	r2,-24(fp)
 821a2c0:	1001703a 	wrctl	status,r2
 821a2c4:	00000106 	br	821a2cc <OSSemPend+0x1f8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
 821a2c8:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
 821a2cc:	e037883a 	mov	sp,fp
 821a2d0:	dfc00117 	ldw	ra,4(sp)
 821a2d4:	df000017 	ldw	fp,0(sp)
 821a2d8:	dec00204 	addi	sp,sp,8
 821a2dc:	f800283a 	ret

0821a2e0 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 821a2e0:	defff604 	addi	sp,sp,-40
 821a2e4:	dfc00915 	stw	ra,36(sp)
 821a2e8:	df000815 	stw	fp,32(sp)
 821a2ec:	df000804 	addi	fp,sp,32
 821a2f0:	e13ffd15 	stw	r4,-12(fp)
 821a2f4:	2805883a 	mov	r2,r5
 821a2f8:	e1bfff15 	stw	r6,-4(fp)
 821a2fc:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821a300:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 821a304:	e0bfff17 	ldw	r2,-4(fp)
 821a308:	1000021e 	bne	r2,zero,821a314 <OSSemPendAbort+0x34>
        return (0);
 821a30c:	0005883a 	mov	r2,zero
 821a310:	00004906 	br	821a438 <OSSemPendAbort+0x158>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 821a314:	e0bffd17 	ldw	r2,-12(fp)
 821a318:	1000051e 	bne	r2,zero,821a330 <OSSemPendAbort+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 821a31c:	e0bfff17 	ldw	r2,-4(fp)
 821a320:	00c00104 	movi	r3,4
 821a324:	10c00005 	stb	r3,0(r2)
        return (0);
 821a328:	0005883a 	mov	r2,zero
 821a32c:	00004206 	br	821a438 <OSSemPendAbort+0x158>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 821a330:	e0bffd17 	ldw	r2,-12(fp)
 821a334:	10800003 	ldbu	r2,0(r2)
 821a338:	10803fcc 	andi	r2,r2,255
 821a33c:	108000e0 	cmpeqi	r2,r2,3
 821a340:	1000051e 	bne	r2,zero,821a358 <OSSemPendAbort+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 821a344:	e0bfff17 	ldw	r2,-4(fp)
 821a348:	00c00044 	movi	r3,1
 821a34c:	10c00005 	stb	r3,0(r2)
        return (0);
 821a350:	0005883a 	mov	r2,zero
 821a354:	00003806 	br	821a438 <OSSemPendAbort+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a358:	0005303a 	rdctl	r2,status
 821a35c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a360:	e0fffc17 	ldw	r3,-16(fp)
 821a364:	00bfff84 	movi	r2,-2
 821a368:	1884703a 	and	r2,r3,r2
 821a36c:	1001703a 	wrctl	status,r2
  
  return context;
 821a370:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821a374:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
 821a378:	e0bffd17 	ldw	r2,-12(fp)
 821a37c:	10800283 	ldbu	r2,10(r2)
 821a380:	10803fcc 	andi	r2,r2,255
 821a384:	10002526 	beq	r2,zero,821a41c <OSSemPendAbort+0x13c>
        nbr_tasks = 0;
 821a388:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
 821a38c:	e0bffe03 	ldbu	r2,-8(fp)
 821a390:	10800060 	cmpeqi	r2,r2,1
 821a394:	10000e26 	beq	r2,zero,821a3d0 <OSSemPendAbort+0xf0>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
 821a398:	00000806 	br	821a3bc <OSSemPendAbort+0xdc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 821a39c:	01c00084 	movi	r7,2
 821a3a0:	01800044 	movi	r6,1
 821a3a4:	000b883a 	mov	r5,zero
 821a3a8:	e13ffd17 	ldw	r4,-12(fp)
 821a3ac:	8215ad80 	call	8215ad8 <OS_EventTaskRdy>
                     nbr_tasks++;
 821a3b0:	e0bff803 	ldbu	r2,-32(fp)
 821a3b4:	10800044 	addi	r2,r2,1
 821a3b8:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
 821a3bc:	e0bffd17 	ldw	r2,-12(fp)
 821a3c0:	10800283 	ldbu	r2,10(r2)
 821a3c4:	10803fcc 	andi	r2,r2,255
 821a3c8:	103ff41e 	bne	r2,zero,821a39c <OSSemPendAbort+0xbc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 821a3cc:	00000906 	br	821a3f4 <OSSemPendAbort+0x114>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 821a3d0:	01c00084 	movi	r7,2
 821a3d4:	01800044 	movi	r6,1
 821a3d8:	000b883a 	mov	r5,zero
 821a3dc:	e13ffd17 	ldw	r4,-12(fp)
 821a3e0:	8215ad80 	call	8215ad8 <OS_EventTaskRdy>
                 nbr_tasks++;
 821a3e4:	e0bff803 	ldbu	r2,-32(fp)
 821a3e8:	10800044 	addi	r2,r2,1
 821a3ec:	e0bff805 	stb	r2,-32(fp)
                 break;
 821a3f0:	0001883a 	nop
 821a3f4:	e0bff917 	ldw	r2,-28(fp)
 821a3f8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a3fc:	e0bffa17 	ldw	r2,-24(fp)
 821a400:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 821a404:	82165240 	call	8216524 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 821a408:	e0bfff17 	ldw	r2,-4(fp)
 821a40c:	00c00384 	movi	r3,14
 821a410:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
 821a414:	e0bff803 	ldbu	r2,-32(fp)
 821a418:	00000706 	br	821a438 <OSSemPendAbort+0x158>
 821a41c:	e0bff917 	ldw	r2,-28(fp)
 821a420:	e0bffb15 	stw	r2,-20(fp)
 821a424:	e0bffb17 	ldw	r2,-20(fp)
 821a428:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 821a42c:	e0bfff17 	ldw	r2,-4(fp)
 821a430:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
 821a434:	0005883a 	mov	r2,zero
}
 821a438:	e037883a 	mov	sp,fp
 821a43c:	dfc00117 	ldw	ra,4(sp)
 821a440:	df000017 	ldw	fp,0(sp)
 821a444:	dec00204 	addi	sp,sp,8
 821a448:	f800283a 	ret

0821a44c <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
 821a44c:	defff804 	addi	sp,sp,-32
 821a450:	dfc00715 	stw	ra,28(sp)
 821a454:	df000615 	stw	fp,24(sp)
 821a458:	df000604 	addi	fp,sp,24
 821a45c:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821a460:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 821a464:	e0bfff17 	ldw	r2,-4(fp)
 821a468:	1000021e 	bne	r2,zero,821a474 <OSSemPost+0x28>
        return (OS_ERR_PEVENT_NULL);
 821a46c:	00800104 	movi	r2,4
 821a470:	00003506 	br	821a548 <OSSemPost+0xfc>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 821a474:	e0bfff17 	ldw	r2,-4(fp)
 821a478:	10800003 	ldbu	r2,0(r2)
 821a47c:	10803fcc 	andi	r2,r2,255
 821a480:	108000e0 	cmpeqi	r2,r2,3
 821a484:	1000021e 	bne	r2,zero,821a490 <OSSemPost+0x44>
        return (OS_ERR_EVENT_TYPE);
 821a488:	00800044 	movi	r2,1
 821a48c:	00002e06 	br	821a548 <OSSemPost+0xfc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a490:	0005303a 	rdctl	r2,status
 821a494:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a498:	e0fffe17 	ldw	r3,-8(fp)
 821a49c:	00bfff84 	movi	r2,-2
 821a4a0:	1884703a 	and	r2,r3,r2
 821a4a4:	1001703a 	wrctl	status,r2
  
  return context;
 821a4a8:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 821a4ac:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
 821a4b0:	e0bfff17 	ldw	r2,-4(fp)
 821a4b4:	10800283 	ldbu	r2,10(r2)
 821a4b8:	10803fcc 	andi	r2,r2,255
 821a4bc:	10000c26 	beq	r2,zero,821a4f0 <OSSemPost+0xa4>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 821a4c0:	000f883a 	mov	r7,zero
 821a4c4:	01800044 	movi	r6,1
 821a4c8:	000b883a 	mov	r5,zero
 821a4cc:	e13fff17 	ldw	r4,-4(fp)
 821a4d0:	8215ad80 	call	8215ad8 <OS_EventTaskRdy>
 821a4d4:	e0bffa17 	ldw	r2,-24(fp)
 821a4d8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a4dc:	e0bffb17 	ldw	r2,-20(fp)
 821a4e0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 821a4e4:	82165240 	call	8216524 <OS_Sched>
        return (OS_ERR_NONE);
 821a4e8:	0005883a 	mov	r2,zero
 821a4ec:	00001606 	br	821a548 <OSSemPost+0xfc>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
 821a4f0:	e0bfff17 	ldw	r2,-4(fp)
 821a4f4:	1080020b 	ldhu	r2,8(r2)
 821a4f8:	10ffffcc 	andi	r3,r2,65535
 821a4fc:	00bfffd4 	movui	r2,65535
 821a500:	18800c26 	beq	r3,r2,821a534 <OSSemPost+0xe8>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
 821a504:	e0bfff17 	ldw	r2,-4(fp)
 821a508:	1080020b 	ldhu	r2,8(r2)
 821a50c:	10800044 	addi	r2,r2,1
 821a510:	1007883a 	mov	r3,r2
 821a514:	e0bfff17 	ldw	r2,-4(fp)
 821a518:	10c0020d 	sth	r3,8(r2)
 821a51c:	e0bffa17 	ldw	r2,-24(fp)
 821a520:	e0bffc15 	stw	r2,-16(fp)
 821a524:	e0bffc17 	ldw	r2,-16(fp)
 821a528:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 821a52c:	0005883a 	mov	r2,zero
 821a530:	00000506 	br	821a548 <OSSemPost+0xfc>
 821a534:	e0bffa17 	ldw	r2,-24(fp)
 821a538:	e0bffd15 	stw	r2,-12(fp)
 821a53c:	e0bffd17 	ldw	r2,-12(fp)
 821a540:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
 821a544:	00800c84 	movi	r2,50
}
 821a548:	e037883a 	mov	sp,fp
 821a54c:	dfc00117 	ldw	ra,4(sp)
 821a550:	df000017 	ldw	fp,0(sp)
 821a554:	dec00204 	addi	sp,sp,8
 821a558:	f800283a 	ret

0821a55c <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
 821a55c:	defff704 	addi	sp,sp,-36
 821a560:	df000815 	stw	fp,32(sp)
 821a564:	df000804 	addi	fp,sp,32
 821a568:	e13ffe15 	stw	r4,-8(fp)
 821a56c:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 821a570:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 821a574:	e0bffe17 	ldw	r2,-8(fp)
 821a578:	1000021e 	bne	r2,zero,821a584 <OSSemQuery+0x28>
        return (OS_ERR_PEVENT_NULL);
 821a57c:	00800104 	movi	r2,4
 821a580:	00003606 	br	821a65c <OSSemQuery+0x100>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
 821a584:	e0bfff17 	ldw	r2,-4(fp)
 821a588:	1000021e 	bne	r2,zero,821a594 <OSSemQuery+0x38>
        return (OS_ERR_PDATA_NULL);
 821a58c:	00800244 	movi	r2,9
 821a590:	00003206 	br	821a65c <OSSemQuery+0x100>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 821a594:	e0bffe17 	ldw	r2,-8(fp)
 821a598:	10800003 	ldbu	r2,0(r2)
 821a59c:	10803fcc 	andi	r2,r2,255
 821a5a0:	108000e0 	cmpeqi	r2,r2,3
 821a5a4:	1000021e 	bne	r2,zero,821a5b0 <OSSemQuery+0x54>
        return (OS_ERR_EVENT_TYPE);
 821a5a8:	00800044 	movi	r2,1
 821a5ac:	00002b06 	br	821a65c <OSSemQuery+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a5b0:	0005303a 	rdctl	r2,status
 821a5b4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a5b8:	e0fffd17 	ldw	r3,-12(fp)
 821a5bc:	00bfff84 	movi	r2,-2
 821a5c0:	1884703a 	and	r2,r3,r2
 821a5c4:	1001703a 	wrctl	status,r2
  
  return context;
 821a5c8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 821a5cc:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
 821a5d0:	e0bffe17 	ldw	r2,-8(fp)
 821a5d4:	10c00283 	ldbu	r3,10(r2)
 821a5d8:	e0bfff17 	ldw	r2,-4(fp)
 821a5dc:	10c00145 	stb	r3,5(r2)
    psrc                   = &pevent->OSEventTbl[0];
 821a5e0:	e0bffe17 	ldw	r2,-8(fp)
 821a5e4:	108002c4 	addi	r2,r2,11
 821a5e8:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
 821a5ec:	e0bfff17 	ldw	r2,-4(fp)
 821a5f0:	10800084 	addi	r2,r2,2
 821a5f4:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 821a5f8:	e03ffa05 	stb	zero,-24(fp)
 821a5fc:	00000b06 	br	821a62c <OSSemQuery+0xd0>
        *pdest++ = *psrc++;
 821a600:	e0bff917 	ldw	r2,-28(fp)
 821a604:	10c00044 	addi	r3,r2,1
 821a608:	e0fff915 	stw	r3,-28(fp)
 821a60c:	e0fff817 	ldw	r3,-32(fp)
 821a610:	19000044 	addi	r4,r3,1
 821a614:	e13ff815 	stw	r4,-32(fp)
 821a618:	18c00003 	ldbu	r3,0(r3)
 821a61c:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 821a620:	e0bffa03 	ldbu	r2,-24(fp)
 821a624:	10800044 	addi	r2,r2,1
 821a628:	e0bffa05 	stb	r2,-24(fp)
 821a62c:	e0bffa03 	ldbu	r2,-24(fp)
 821a630:	108000f0 	cmpltui	r2,r2,3
 821a634:	103ff21e 	bne	r2,zero,821a600 <OSSemQuery+0xa4>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
 821a638:	e0bffe17 	ldw	r2,-8(fp)
 821a63c:	10c0020b 	ldhu	r3,8(r2)
 821a640:	e0bfff17 	ldw	r2,-4(fp)
 821a644:	10c0000d 	sth	r3,0(r2)
 821a648:	e0bffb17 	ldw	r2,-20(fp)
 821a64c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a650:	e0bffc17 	ldw	r2,-16(fp)
 821a654:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 821a658:	0005883a 	mov	r2,zero
}
 821a65c:	e037883a 	mov	sp,fp
 821a660:	df000017 	ldw	fp,0(sp)
 821a664:	dec00104 	addi	sp,sp,4
 821a668:	f800283a 	ret

0821a66c <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
 821a66c:	defff904 	addi	sp,sp,-28
 821a670:	df000615 	stw	fp,24(sp)
 821a674:	df000604 	addi	fp,sp,24
 821a678:	e13ffd15 	stw	r4,-12(fp)
 821a67c:	2805883a 	mov	r2,r5
 821a680:	e1bfff15 	stw	r6,-4(fp)
 821a684:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821a688:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 821a68c:	e0bfff17 	ldw	r2,-4(fp)
 821a690:	10003126 	beq	r2,zero,821a758 <OSSemSet+0xec>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 821a694:	e0bffd17 	ldw	r2,-12(fp)
 821a698:	1000041e 	bne	r2,zero,821a6ac <OSSemSet+0x40>
        *perr = OS_ERR_PEVENT_NULL;
 821a69c:	e0bfff17 	ldw	r2,-4(fp)
 821a6a0:	00c00104 	movi	r3,4
 821a6a4:	10c00005 	stb	r3,0(r2)
        return;
 821a6a8:	00002c06 	br	821a75c <OSSemSet+0xf0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 821a6ac:	e0bffd17 	ldw	r2,-12(fp)
 821a6b0:	10800003 	ldbu	r2,0(r2)
 821a6b4:	10803fcc 	andi	r2,r2,255
 821a6b8:	108000e0 	cmpeqi	r2,r2,3
 821a6bc:	1000041e 	bne	r2,zero,821a6d0 <OSSemSet+0x64>
        *perr = OS_ERR_EVENT_TYPE;
 821a6c0:	e0bfff17 	ldw	r2,-4(fp)
 821a6c4:	00c00044 	movi	r3,1
 821a6c8:	10c00005 	stb	r3,0(r2)
        return;
 821a6cc:	00002306 	br	821a75c <OSSemSet+0xf0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a6d0:	0005303a 	rdctl	r2,status
 821a6d4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a6d8:	e0fffc17 	ldw	r3,-16(fp)
 821a6dc:	00bfff84 	movi	r2,-2
 821a6e0:	1884703a 	and	r2,r3,r2
 821a6e4:	1001703a 	wrctl	status,r2
  
  return context;
 821a6e8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821a6ec:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
 821a6f0:	e0bfff17 	ldw	r2,-4(fp)
 821a6f4:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
 821a6f8:	e0bffd17 	ldw	r2,-12(fp)
 821a6fc:	1080020b 	ldhu	r2,8(r2)
 821a700:	10bfffcc 	andi	r2,r2,65535
 821a704:	10000426 	beq	r2,zero,821a718 <OSSemSet+0xac>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
 821a708:	e0bffd17 	ldw	r2,-12(fp)
 821a70c:	e0fffe0b 	ldhu	r3,-8(fp)
 821a710:	10c0020d 	sth	r3,8(r2)
 821a714:	00000b06 	br	821a744 <OSSemSet+0xd8>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
 821a718:	e0bffd17 	ldw	r2,-12(fp)
 821a71c:	10800283 	ldbu	r2,10(r2)
 821a720:	10803fcc 	andi	r2,r2,255
 821a724:	1000041e 	bne	r2,zero,821a738 <OSSemSet+0xcc>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
 821a728:	e0bffd17 	ldw	r2,-12(fp)
 821a72c:	e0fffe0b 	ldhu	r3,-8(fp)
 821a730:	10c0020d 	sth	r3,8(r2)
 821a734:	00000306 	br	821a744 <OSSemSet+0xd8>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
 821a738:	e0bfff17 	ldw	r2,-4(fp)
 821a73c:	00c01244 	movi	r3,73
 821a740:	10c00005 	stb	r3,0(r2)
 821a744:	e0bffa17 	ldw	r2,-24(fp)
 821a748:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a74c:	e0bffb17 	ldw	r2,-20(fp)
 821a750:	1001703a 	wrctl	status,r2
 821a754:	00000106 	br	821a75c <OSSemSet+0xf0>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
 821a758:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
 821a75c:	e037883a 	mov	sp,fp
 821a760:	df000017 	ldw	fp,0(sp)
 821a764:	dec00104 	addi	sp,sp,4
 821a768:	f800283a 	ret

0821a76c <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
 821a76c:	defff104 	addi	sp,sp,-60
 821a770:	dfc00e15 	stw	ra,56(sp)
 821a774:	df000d15 	stw	fp,52(sp)
 821a778:	df000d04 	addi	fp,sp,52
 821a77c:	2007883a 	mov	r3,r4
 821a780:	2805883a 	mov	r2,r5
 821a784:	e0fffe05 	stb	r3,-8(fp)
 821a788:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
 821a78c:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
 821a790:	e0bffe03 	ldbu	r2,-8(fp)
 821a794:	10800530 	cmpltui	r2,r2,20
 821a798:	1000051e 	bne	r2,zero,821a7b0 <OSTaskChangePrio+0x44>
        if (oldprio != OS_PRIO_SELF) {
 821a79c:	e0bffe03 	ldbu	r2,-8(fp)
 821a7a0:	10803fe0 	cmpeqi	r2,r2,255
 821a7a4:	1000021e 	bne	r2,zero,821a7b0 <OSTaskChangePrio+0x44>
            return (OS_ERR_PRIO_INVALID);
 821a7a8:	00800a84 	movi	r2,42
 821a7ac:	00012606 	br	821ac48 <OSTaskChangePrio+0x4dc>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
 821a7b0:	e0bfff03 	ldbu	r2,-4(fp)
 821a7b4:	10800530 	cmpltui	r2,r2,20
 821a7b8:	1000021e 	bne	r2,zero,821a7c4 <OSTaskChangePrio+0x58>
        return (OS_ERR_PRIO_INVALID);
 821a7bc:	00800a84 	movi	r2,42
 821a7c0:	00012106 	br	821ac48 <OSTaskChangePrio+0x4dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a7c4:	0005303a 	rdctl	r2,status
 821a7c8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a7cc:	e0fffd17 	ldw	r3,-12(fp)
 821a7d0:	00bfff84 	movi	r2,-2
 821a7d4:	1884703a 	and	r2,r3,r2
 821a7d8:	1001703a 	wrctl	status,r2
  
  return context;
 821a7dc:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821a7e0:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
 821a7e4:	e0ffff03 	ldbu	r3,-4(fp)
 821a7e8:	008209b4 	movhi	r2,2086
 821a7ec:	10b6a904 	addi	r2,r2,-9564
 821a7f0:	18c7883a 	add	r3,r3,r3
 821a7f4:	18c7883a 	add	r3,r3,r3
 821a7f8:	10c5883a 	add	r2,r2,r3
 821a7fc:	10800017 	ldw	r2,0(r2)
 821a800:	10000626 	beq	r2,zero,821a81c <OSTaskChangePrio+0xb0>
 821a804:	e0bff517 	ldw	r2,-44(fp)
 821a808:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a80c:	e0bff617 	ldw	r2,-40(fp)
 821a810:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
 821a814:	00800a04 	movi	r2,40
 821a818:	00010b06 	br	821ac48 <OSTaskChangePrio+0x4dc>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
 821a81c:	e0bffe03 	ldbu	r2,-8(fp)
 821a820:	10803fd8 	cmpnei	r2,r2,255
 821a824:	1000031e 	bne	r2,zero,821a834 <OSTaskChangePrio+0xc8>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
 821a828:	d0a07a17 	ldw	r2,-32280(gp)
 821a82c:	10800c83 	ldbu	r2,50(r2)
 821a830:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
 821a834:	e0fffe03 	ldbu	r3,-8(fp)
 821a838:	008209b4 	movhi	r2,2086
 821a83c:	10b6a904 	addi	r2,r2,-9564
 821a840:	18c7883a 	add	r3,r3,r3
 821a844:	18c7883a 	add	r3,r3,r3
 821a848:	10c5883a 	add	r2,r2,r3
 821a84c:	10800017 	ldw	r2,0(r2)
 821a850:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
 821a854:	e0bff817 	ldw	r2,-32(fp)
 821a858:	1000061e 	bne	r2,zero,821a874 <OSTaskChangePrio+0x108>
 821a85c:	e0bff517 	ldw	r2,-44(fp)
 821a860:	e0bff715 	stw	r2,-36(fp)
 821a864:	e0bff717 	ldw	r2,-36(fp)
 821a868:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
 821a86c:	00800a44 	movi	r2,41
 821a870:	0000f506 	br	821ac48 <OSTaskChangePrio+0x4dc>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
 821a874:	e0bff817 	ldw	r2,-32(fp)
 821a878:	10800058 	cmpnei	r2,r2,1
 821a87c:	1000061e 	bne	r2,zero,821a898 <OSTaskChangePrio+0x12c>
 821a880:	e0bff517 	ldw	r2,-44(fp)
 821a884:	e0bff915 	stw	r2,-28(fp)
 821a888:	e0bff917 	ldw	r2,-28(fp)
 821a88c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
 821a890:	008010c4 	movi	r2,67
 821a894:	0000ec06 	br	821ac48 <OSTaskChangePrio+0x4dc>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
 821a898:	e0bfff03 	ldbu	r2,-4(fp)
 821a89c:	1004d0fa 	srli	r2,r2,3
 821a8a0:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
 821a8a4:	e0bfff03 	ldbu	r2,-4(fp)
 821a8a8:	108001cc 	andi	r2,r2,7
 821a8ac:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
 821a8b0:	e0bffb03 	ldbu	r2,-20(fp)
 821a8b4:	00c00044 	movi	r3,1
 821a8b8:	1884983a 	sll	r2,r3,r2
 821a8bc:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
 821a8c0:	e0bffb43 	ldbu	r2,-19(fp)
 821a8c4:	00c00044 	movi	r3,1
 821a8c8:	1884983a 	sll	r2,r3,r2
 821a8cc:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
 821a8d0:	e0fffe03 	ldbu	r3,-8(fp)
 821a8d4:	008209b4 	movhi	r2,2086
 821a8d8:	10b6a904 	addi	r2,r2,-9564
 821a8dc:	18c7883a 	add	r3,r3,r3
 821a8e0:	18c7883a 	add	r3,r3,r3
 821a8e4:	10c5883a 	add	r2,r2,r3
 821a8e8:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
 821a8ec:	e0ffff03 	ldbu	r3,-4(fp)
 821a8f0:	008209b4 	movhi	r2,2086
 821a8f4:	10b6a904 	addi	r2,r2,-9564
 821a8f8:	18c7883a 	add	r3,r3,r3
 821a8fc:	18c7883a 	add	r3,r3,r3
 821a900:	10c5883a 	add	r2,r2,r3
 821a904:	e0fff817 	ldw	r3,-32(fp)
 821a908:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
 821a90c:	e0bff817 	ldw	r2,-32(fp)
 821a910:	10800d03 	ldbu	r2,52(r2)
 821a914:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
 821a918:	e0bff817 	ldw	r2,-32(fp)
 821a91c:	10800d83 	ldbu	r2,54(r2)
 821a920:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
 821a924:	e0bff817 	ldw	r2,-32(fp)
 821a928:	10800d43 	ldbu	r2,53(r2)
 821a92c:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
 821a930:	e0fffc03 	ldbu	r3,-16(fp)
 821a934:	d0a07744 	addi	r2,gp,-32291
 821a938:	1885883a 	add	r2,r3,r2
 821a93c:	10c00003 	ldbu	r3,0(r2)
 821a940:	e0bffc83 	ldbu	r2,-14(fp)
 821a944:	1884703a 	and	r2,r3,r2
 821a948:	10803fcc 	andi	r2,r2,255
 821a94c:	10002826 	beq	r2,zero,821a9f0 <OSTaskChangePrio+0x284>
         OSRdyTbl[y_old] &= ~bitx_old;
 821a950:	e0fffc03 	ldbu	r3,-16(fp)
 821a954:	e13ffc03 	ldbu	r4,-16(fp)
 821a958:	d0a07744 	addi	r2,gp,-32291
 821a95c:	2085883a 	add	r2,r4,r2
 821a960:	10800003 	ldbu	r2,0(r2)
 821a964:	1009883a 	mov	r4,r2
 821a968:	e0bffc83 	ldbu	r2,-14(fp)
 821a96c:	0084303a 	nor	r2,zero,r2
 821a970:	2084703a 	and	r2,r4,r2
 821a974:	1009883a 	mov	r4,r2
 821a978:	d0a07744 	addi	r2,gp,-32291
 821a97c:	1885883a 	add	r2,r3,r2
 821a980:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
 821a984:	e0fffc03 	ldbu	r3,-16(fp)
 821a988:	d0a07744 	addi	r2,gp,-32291
 821a98c:	1885883a 	add	r2,r3,r2
 821a990:	10800003 	ldbu	r2,0(r2)
 821a994:	10803fcc 	andi	r2,r2,255
 821a998:	1000061e 	bne	r2,zero,821a9b4 <OSTaskChangePrio+0x248>
             OSRdyGrp &= ~bity_old;
 821a99c:	e0bffc43 	ldbu	r2,-15(fp)
 821a9a0:	0084303a 	nor	r2,zero,r2
 821a9a4:	1007883a 	mov	r3,r2
 821a9a8:	d0a07703 	ldbu	r2,-32292(gp)
 821a9ac:	1884703a 	and	r2,r3,r2
 821a9b0:	d0a07705 	stb	r2,-32292(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
 821a9b4:	d0e07703 	ldbu	r3,-32292(gp)
 821a9b8:	e0bffb83 	ldbu	r2,-18(fp)
 821a9bc:	1884b03a 	or	r2,r3,r2
 821a9c0:	d0a07705 	stb	r2,-32292(gp)
         OSRdyTbl[y_new] |= bitx_new;
 821a9c4:	e0fffb03 	ldbu	r3,-20(fp)
 821a9c8:	e13ffb03 	ldbu	r4,-20(fp)
 821a9cc:	d0a07744 	addi	r2,gp,-32291
 821a9d0:	2085883a 	add	r2,r4,r2
 821a9d4:	11000003 	ldbu	r4,0(r2)
 821a9d8:	e0bffbc3 	ldbu	r2,-17(fp)
 821a9dc:	2084b03a 	or	r2,r4,r2
 821a9e0:	1009883a 	mov	r4,r2
 821a9e4:	d0a07744 	addi	r2,gp,-32291
 821a9e8:	1885883a 	add	r2,r3,r2
 821a9ec:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
 821a9f0:	e0bff817 	ldw	r2,-32(fp)
 821a9f4:	10800717 	ldw	r2,28(r2)
 821a9f8:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
 821a9fc:	e0bff317 	ldw	r2,-52(fp)
 821aa00:	10003326 	beq	r2,zero,821aad0 <OSTaskChangePrio+0x364>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
 821aa04:	e0bffc03 	ldbu	r2,-16(fp)
 821aa08:	e0fffc03 	ldbu	r3,-16(fp)
 821aa0c:	e13ff317 	ldw	r4,-52(fp)
 821aa10:	20c7883a 	add	r3,r4,r3
 821aa14:	18c002c4 	addi	r3,r3,11
 821aa18:	18c00003 	ldbu	r3,0(r3)
 821aa1c:	1809883a 	mov	r4,r3
 821aa20:	e0fffc83 	ldbu	r3,-14(fp)
 821aa24:	00c6303a 	nor	r3,zero,r3
 821aa28:	20c6703a 	and	r3,r4,r3
 821aa2c:	1809883a 	mov	r4,r3
 821aa30:	e0fff317 	ldw	r3,-52(fp)
 821aa34:	1885883a 	add	r2,r3,r2
 821aa38:	108002c4 	addi	r2,r2,11
 821aa3c:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
 821aa40:	e0bffc03 	ldbu	r2,-16(fp)
 821aa44:	e0fff317 	ldw	r3,-52(fp)
 821aa48:	1885883a 	add	r2,r3,r2
 821aa4c:	108002c4 	addi	r2,r2,11
 821aa50:	10800003 	ldbu	r2,0(r2)
 821aa54:	10803fcc 	andi	r2,r2,255
 821aa58:	1000091e 	bne	r2,zero,821aa80 <OSTaskChangePrio+0x314>
            pevent->OSEventGrp    &= ~bity_old;
 821aa5c:	e0bff317 	ldw	r2,-52(fp)
 821aa60:	10800283 	ldbu	r2,10(r2)
 821aa64:	1007883a 	mov	r3,r2
 821aa68:	e0bffc43 	ldbu	r2,-15(fp)
 821aa6c:	0084303a 	nor	r2,zero,r2
 821aa70:	1884703a 	and	r2,r3,r2
 821aa74:	1007883a 	mov	r3,r2
 821aa78:	e0bff317 	ldw	r2,-52(fp)
 821aa7c:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
 821aa80:	e0bff317 	ldw	r2,-52(fp)
 821aa84:	10c00283 	ldbu	r3,10(r2)
 821aa88:	e0bffb83 	ldbu	r2,-18(fp)
 821aa8c:	1884b03a 	or	r2,r3,r2
 821aa90:	1007883a 	mov	r3,r2
 821aa94:	e0bff317 	ldw	r2,-52(fp)
 821aa98:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
 821aa9c:	e0bffb03 	ldbu	r2,-20(fp)
 821aaa0:	e0fffb03 	ldbu	r3,-20(fp)
 821aaa4:	e13ff317 	ldw	r4,-52(fp)
 821aaa8:	20c7883a 	add	r3,r4,r3
 821aaac:	18c002c4 	addi	r3,r3,11
 821aab0:	19000003 	ldbu	r4,0(r3)
 821aab4:	e0fffbc3 	ldbu	r3,-17(fp)
 821aab8:	20c6b03a 	or	r3,r4,r3
 821aabc:	1809883a 	mov	r4,r3
 821aac0:	e0fff317 	ldw	r3,-52(fp)
 821aac4:	1885883a 	add	r2,r3,r2
 821aac8:	108002c4 	addi	r2,r2,11
 821aacc:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
 821aad0:	e0bff817 	ldw	r2,-32(fp)
 821aad4:	10800817 	ldw	r2,32(r2)
 821aad8:	10004226 	beq	r2,zero,821abe4 <OSTaskChangePrio+0x478>
        pevents =  ptcb->OSTCBEventMultiPtr;
 821aadc:	e0bff817 	ldw	r2,-32(fp)
 821aae0:	10800817 	ldw	r2,32(r2)
 821aae4:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
 821aae8:	e0bff417 	ldw	r2,-48(fp)
 821aaec:	10800017 	ldw	r2,0(r2)
 821aaf0:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
 821aaf4:	00003906 	br	821abdc <OSTaskChangePrio+0x470>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
 821aaf8:	e0bffc03 	ldbu	r2,-16(fp)
 821aafc:	e0fffc03 	ldbu	r3,-16(fp)
 821ab00:	e13ff317 	ldw	r4,-52(fp)
 821ab04:	20c7883a 	add	r3,r4,r3
 821ab08:	18c002c4 	addi	r3,r3,11
 821ab0c:	18c00003 	ldbu	r3,0(r3)
 821ab10:	1809883a 	mov	r4,r3
 821ab14:	e0fffc83 	ldbu	r3,-14(fp)
 821ab18:	00c6303a 	nor	r3,zero,r3
 821ab1c:	20c6703a 	and	r3,r4,r3
 821ab20:	1809883a 	mov	r4,r3
 821ab24:	e0fff317 	ldw	r3,-52(fp)
 821ab28:	1885883a 	add	r2,r3,r2
 821ab2c:	108002c4 	addi	r2,r2,11
 821ab30:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
 821ab34:	e0bffc03 	ldbu	r2,-16(fp)
 821ab38:	e0fff317 	ldw	r3,-52(fp)
 821ab3c:	1885883a 	add	r2,r3,r2
 821ab40:	108002c4 	addi	r2,r2,11
 821ab44:	10800003 	ldbu	r2,0(r2)
 821ab48:	10803fcc 	andi	r2,r2,255
 821ab4c:	1000091e 	bne	r2,zero,821ab74 <OSTaskChangePrio+0x408>
                pevent->OSEventGrp    &= ~bity_old;
 821ab50:	e0bff317 	ldw	r2,-52(fp)
 821ab54:	10800283 	ldbu	r2,10(r2)
 821ab58:	1007883a 	mov	r3,r2
 821ab5c:	e0bffc43 	ldbu	r2,-15(fp)
 821ab60:	0084303a 	nor	r2,zero,r2
 821ab64:	1884703a 	and	r2,r3,r2
 821ab68:	1007883a 	mov	r3,r2
 821ab6c:	e0bff317 	ldw	r2,-52(fp)
 821ab70:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
 821ab74:	e0bff317 	ldw	r2,-52(fp)
 821ab78:	10c00283 	ldbu	r3,10(r2)
 821ab7c:	e0bffb83 	ldbu	r2,-18(fp)
 821ab80:	1884b03a 	or	r2,r3,r2
 821ab84:	1007883a 	mov	r3,r2
 821ab88:	e0bff317 	ldw	r2,-52(fp)
 821ab8c:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
 821ab90:	e0bffb03 	ldbu	r2,-20(fp)
 821ab94:	e0fffb03 	ldbu	r3,-20(fp)
 821ab98:	e13ff317 	ldw	r4,-52(fp)
 821ab9c:	20c7883a 	add	r3,r4,r3
 821aba0:	18c002c4 	addi	r3,r3,11
 821aba4:	19000003 	ldbu	r4,0(r3)
 821aba8:	e0fffbc3 	ldbu	r3,-17(fp)
 821abac:	20c6b03a 	or	r3,r4,r3
 821abb0:	1809883a 	mov	r4,r3
 821abb4:	e0fff317 	ldw	r3,-52(fp)
 821abb8:	1885883a 	add	r2,r3,r2
 821abbc:	108002c4 	addi	r2,r2,11
 821abc0:	11000005 	stb	r4,0(r2)
            pevents++;
 821abc4:	e0bff417 	ldw	r2,-48(fp)
 821abc8:	10800104 	addi	r2,r2,4
 821abcc:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
 821abd0:	e0bff417 	ldw	r2,-48(fp)
 821abd4:	10800017 	ldw	r2,0(r2)
 821abd8:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
 821abdc:	e0bff317 	ldw	r2,-52(fp)
 821abe0:	103fc51e 	bne	r2,zero,821aaf8 <OSTaskChangePrio+0x38c>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
 821abe4:	e0bff817 	ldw	r2,-32(fp)
 821abe8:	e0ffff03 	ldbu	r3,-4(fp)
 821abec:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
 821abf0:	e0bff817 	ldw	r2,-32(fp)
 821abf4:	e0fffb03 	ldbu	r3,-20(fp)
 821abf8:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
 821abfc:	e0bff817 	ldw	r2,-32(fp)
 821ac00:	e0fffb43 	ldbu	r3,-19(fp)
 821ac04:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
 821ac08:	e0bff817 	ldw	r2,-32(fp)
 821ac0c:	e0fffb83 	ldbu	r3,-18(fp)
 821ac10:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
 821ac14:	e0bff817 	ldw	r2,-32(fp)
 821ac18:	e0fffbc3 	ldbu	r3,-17(fp)
 821ac1c:	10c00d45 	stb	r3,53(r2)
 821ac20:	e0bff517 	ldw	r2,-44(fp)
 821ac24:	e0bffa15 	stw	r2,-24(fp)
 821ac28:	e0bffa17 	ldw	r2,-24(fp)
 821ac2c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 821ac30:	d0a06b43 	ldbu	r2,-32339(gp)
 821ac34:	10803fcc 	andi	r2,r2,255
 821ac38:	10800058 	cmpnei	r2,r2,1
 821ac3c:	1000011e 	bne	r2,zero,821ac44 <OSTaskChangePrio+0x4d8>
        OS_Sched();                                         /* Find new highest priority task          */
 821ac40:	82165240 	call	8216524 <OS_Sched>
    }
    return (OS_ERR_NONE);
 821ac44:	0005883a 	mov	r2,zero
}
 821ac48:	e037883a 	mov	sp,fp
 821ac4c:	dfc00117 	ldw	ra,4(sp)
 821ac50:	df000017 	ldw	fp,0(sp)
 821ac54:	dec00204 	addi	sp,sp,8
 821ac58:	f800283a 	ret

0821ac5c <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
 821ac5c:	deffee04 	addi	sp,sp,-72
 821ac60:	dfc01115 	stw	ra,68(sp)
 821ac64:	df001015 	stw	fp,64(sp)
 821ac68:	df001004 	addi	fp,sp,64
 821ac6c:	e13ffc15 	stw	r4,-16(fp)
 821ac70:	e17ffd15 	stw	r5,-12(fp)
 821ac74:	e1bffe15 	stw	r6,-8(fp)
 821ac78:	3805883a 	mov	r2,r7
 821ac7c:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 821ac80:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 821ac84:	e0bfff03 	ldbu	r2,-4(fp)
 821ac88:	10800570 	cmpltui	r2,r2,21
 821ac8c:	1000021e 	bne	r2,zero,821ac98 <OSTaskCreate+0x3c>
        return (OS_ERR_PRIO_INVALID);
 821ac90:	00800a84 	movi	r2,42
 821ac94:	00005706 	br	821adf4 <OSTaskCreate+0x198>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821ac98:	0005303a 	rdctl	r2,status
 821ac9c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821aca0:	e0fffb17 	ldw	r3,-20(fp)
 821aca4:	00bfff84 	movi	r2,-2
 821aca8:	1884703a 	and	r2,r3,r2
 821acac:	1001703a 	wrctl	status,r2
  
  return context;
 821acb0:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821acb4:	e0bff315 	stw	r2,-52(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 821acb8:	d0a07903 	ldbu	r2,-32284(gp)
 821acbc:	10803fcc 	andi	r2,r2,255
 821acc0:	10000626 	beq	r2,zero,821acdc <OSTaskCreate+0x80>
 821acc4:	e0bff317 	ldw	r2,-52(fp)
 821acc8:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821accc:	e0bff417 	ldw	r2,-48(fp)
 821acd0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 821acd4:	00800f04 	movi	r2,60
 821acd8:	00004606 	br	821adf4 <OSTaskCreate+0x198>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 821acdc:	e0ffff03 	ldbu	r3,-4(fp)
 821ace0:	008209b4 	movhi	r2,2086
 821ace4:	10b6a904 	addi	r2,r2,-9564
 821ace8:	18c7883a 	add	r3,r3,r3
 821acec:	18c7883a 	add	r3,r3,r3
 821acf0:	10c5883a 	add	r2,r2,r3
 821acf4:	10800017 	ldw	r2,0(r2)
 821acf8:	1000391e 	bne	r2,zero,821ade0 <OSTaskCreate+0x184>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 821acfc:	e0ffff03 	ldbu	r3,-4(fp)
 821ad00:	008209b4 	movhi	r2,2086
 821ad04:	10b6a904 	addi	r2,r2,-9564
 821ad08:	18c7883a 	add	r3,r3,r3
 821ad0c:	18c7883a 	add	r3,r3,r3
 821ad10:	10c5883a 	add	r2,r2,r3
 821ad14:	00c00044 	movi	r3,1
 821ad18:	10c00015 	stw	r3,0(r2)
 821ad1c:	e0bff317 	ldw	r2,-52(fp)
 821ad20:	e0bff515 	stw	r2,-44(fp)
 821ad24:	e0bff517 	ldw	r2,-44(fp)
 821ad28:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
 821ad2c:	000f883a 	mov	r7,zero
 821ad30:	e1bffe17 	ldw	r6,-8(fp)
 821ad34:	e17ffd17 	ldw	r5,-12(fp)
 821ad38:	e13ffc17 	ldw	r4,-16(fp)
 821ad3c:	823cd840 	call	823cd84 <OSTaskStkInit>
 821ad40:	e0bff715 	stw	r2,-36(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
 821ad44:	e0bfff03 	ldbu	r2,-4(fp)
 821ad48:	d8000215 	stw	zero,8(sp)
 821ad4c:	d8000115 	stw	zero,4(sp)
 821ad50:	d8000015 	stw	zero,0(sp)
 821ad54:	000f883a 	mov	r7,zero
 821ad58:	000d883a 	mov	r6,zero
 821ad5c:	e17ff717 	ldw	r5,-36(fp)
 821ad60:	1009883a 	mov	r4,r2
 821ad64:	821693c0 	call	821693c <OS_TCBInit>
 821ad68:	e0bff805 	stb	r2,-32(fp)
        if (err == OS_ERR_NONE) {
 821ad6c:	e0bff803 	ldbu	r2,-32(fp)
 821ad70:	1000061e 	bne	r2,zero,821ad8c <OSTaskCreate+0x130>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
 821ad74:	d0a06b43 	ldbu	r2,-32339(gp)
 821ad78:	10803fcc 	andi	r2,r2,255
 821ad7c:	10800058 	cmpnei	r2,r2,1
 821ad80:	1000151e 	bne	r2,zero,821add8 <OSTaskCreate+0x17c>
                OS_Sched();
 821ad84:	82165240 	call	8216524 <OS_Sched>
 821ad88:	00001306 	br	821add8 <OSTaskCreate+0x17c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821ad8c:	0005303a 	rdctl	r2,status
 821ad90:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821ad94:	e0fffa17 	ldw	r3,-24(fp)
 821ad98:	00bfff84 	movi	r2,-2
 821ad9c:	1884703a 	and	r2,r3,r2
 821ada0:	1001703a 	wrctl	status,r2
  
  return context;
 821ada4:	e0bffa17 	ldw	r2,-24(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 821ada8:	e0bff315 	stw	r2,-52(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
 821adac:	e0ffff03 	ldbu	r3,-4(fp)
 821adb0:	008209b4 	movhi	r2,2086
 821adb4:	10b6a904 	addi	r2,r2,-9564
 821adb8:	18c7883a 	add	r3,r3,r3
 821adbc:	18c7883a 	add	r3,r3,r3
 821adc0:	10c5883a 	add	r2,r2,r3
 821adc4:	10000015 	stw	zero,0(r2)
 821adc8:	e0bff317 	ldw	r2,-52(fp)
 821adcc:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821add0:	e0bff617 	ldw	r2,-40(fp)
 821add4:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 821add8:	e0bff803 	ldbu	r2,-32(fp)
 821addc:	00000506 	br	821adf4 <OSTaskCreate+0x198>
 821ade0:	e0bff317 	ldw	r2,-52(fp)
 821ade4:	e0bff915 	stw	r2,-28(fp)
 821ade8:	e0bff917 	ldw	r2,-28(fp)
 821adec:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 821adf0:	00800a04 	movi	r2,40
}
 821adf4:	e037883a 	mov	sp,fp
 821adf8:	dfc00117 	ldw	ra,4(sp)
 821adfc:	df000017 	ldw	fp,0(sp)
 821ae00:	dec00204 	addi	sp,sp,8
 821ae04:	f800283a 	ret

0821ae08 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
 821ae08:	deffec04 	addi	sp,sp,-80
 821ae0c:	dfc01315 	stw	ra,76(sp)
 821ae10:	df001215 	stw	fp,72(sp)
 821ae14:	df001204 	addi	fp,sp,72
 821ae18:	e13ffa15 	stw	r4,-24(fp)
 821ae1c:	e17ffb15 	stw	r5,-20(fp)
 821ae20:	e1bffc15 	stw	r6,-16(fp)
 821ae24:	3809883a 	mov	r4,r7
 821ae28:	e0c00217 	ldw	r3,8(fp)
 821ae2c:	e0800617 	ldw	r2,24(fp)
 821ae30:	e13ffd05 	stb	r4,-12(fp)
 821ae34:	e0fffe0d 	sth	r3,-8(fp)
 821ae38:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 821ae3c:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 821ae40:	e0bffd03 	ldbu	r2,-12(fp)
 821ae44:	10800570 	cmpltui	r2,r2,21
 821ae48:	1000021e 	bne	r2,zero,821ae54 <OSTaskCreateExt+0x4c>
        return (OS_ERR_PRIO_INVALID);
 821ae4c:	00800a84 	movi	r2,42
 821ae50:	00006106 	br	821afd8 <OSTaskCreateExt+0x1d0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821ae54:	0005303a 	rdctl	r2,status
 821ae58:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821ae5c:	e0fff917 	ldw	r3,-28(fp)
 821ae60:	00bfff84 	movi	r2,-2
 821ae64:	1884703a 	and	r2,r3,r2
 821ae68:	1001703a 	wrctl	status,r2
  
  return context;
 821ae6c:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821ae70:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 821ae74:	d0a07903 	ldbu	r2,-32284(gp)
 821ae78:	10803fcc 	andi	r2,r2,255
 821ae7c:	10000626 	beq	r2,zero,821ae98 <OSTaskCreateExt+0x90>
 821ae80:	e0bff117 	ldw	r2,-60(fp)
 821ae84:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821ae88:	e0bff217 	ldw	r2,-56(fp)
 821ae8c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 821ae90:	00800f04 	movi	r2,60
 821ae94:	00005006 	br	821afd8 <OSTaskCreateExt+0x1d0>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 821ae98:	e0fffd03 	ldbu	r3,-12(fp)
 821ae9c:	008209b4 	movhi	r2,2086
 821aea0:	10b6a904 	addi	r2,r2,-9564
 821aea4:	18c7883a 	add	r3,r3,r3
 821aea8:	18c7883a 	add	r3,r3,r3
 821aeac:	10c5883a 	add	r2,r2,r3
 821aeb0:	10800017 	ldw	r2,0(r2)
 821aeb4:	1000431e 	bne	r2,zero,821afc4 <OSTaskCreateExt+0x1bc>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 821aeb8:	e0fffd03 	ldbu	r3,-12(fp)
 821aebc:	008209b4 	movhi	r2,2086
 821aec0:	10b6a904 	addi	r2,r2,-9564
 821aec4:	18c7883a 	add	r3,r3,r3
 821aec8:	18c7883a 	add	r3,r3,r3
 821aecc:	10c5883a 	add	r2,r2,r3
 821aed0:	00c00044 	movi	r3,1
 821aed4:	10c00015 	stw	r3,0(r2)
 821aed8:	e0bff117 	ldw	r2,-60(fp)
 821aedc:	e0bff315 	stw	r2,-52(fp)
 821aee0:	e0bff317 	ldw	r2,-52(fp)
 821aee4:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
 821aee8:	e0bfff0b 	ldhu	r2,-4(fp)
 821aeec:	100d883a 	mov	r6,r2
 821aef0:	e1400417 	ldw	r5,16(fp)
 821aef4:	e1000317 	ldw	r4,12(fp)
 821aef8:	821be680 	call	821be68 <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
 821aefc:	e0bfff0b 	ldhu	r2,-4(fp)
 821af00:	100f883a 	mov	r7,r2
 821af04:	e1bffc17 	ldw	r6,-16(fp)
 821af08:	e17ffb17 	ldw	r5,-20(fp)
 821af0c:	e13ffa17 	ldw	r4,-24(fp)
 821af10:	823cd840 	call	823cd84 <OSTaskStkInit>
 821af14:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
 821af18:	e0fffd03 	ldbu	r3,-12(fp)
 821af1c:	e13ffe0b 	ldhu	r4,-8(fp)
 821af20:	e0bfff0b 	ldhu	r2,-4(fp)
 821af24:	d8800215 	stw	r2,8(sp)
 821af28:	e0800517 	ldw	r2,20(fp)
 821af2c:	d8800115 	stw	r2,4(sp)
 821af30:	e0800417 	ldw	r2,16(fp)
 821af34:	d8800015 	stw	r2,0(sp)
 821af38:	200f883a 	mov	r7,r4
 821af3c:	e1800317 	ldw	r6,12(fp)
 821af40:	e17ff517 	ldw	r5,-44(fp)
 821af44:	1809883a 	mov	r4,r3
 821af48:	821693c0 	call	821693c <OS_TCBInit>
 821af4c:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
 821af50:	e0bff603 	ldbu	r2,-40(fp)
 821af54:	1000061e 	bne	r2,zero,821af70 <OSTaskCreateExt+0x168>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
 821af58:	d0a06b43 	ldbu	r2,-32339(gp)
 821af5c:	10803fcc 	andi	r2,r2,255
 821af60:	10800058 	cmpnei	r2,r2,1
 821af64:	1000151e 	bne	r2,zero,821afbc <OSTaskCreateExt+0x1b4>
                OS_Sched();
 821af68:	82165240 	call	8216524 <OS_Sched>
 821af6c:	00001306 	br	821afbc <OSTaskCreateExt+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821af70:	0005303a 	rdctl	r2,status
 821af74:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821af78:	e0fff817 	ldw	r3,-32(fp)
 821af7c:	00bfff84 	movi	r2,-2
 821af80:	1884703a 	and	r2,r3,r2
 821af84:	1001703a 	wrctl	status,r2
  
  return context;
 821af88:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 821af8c:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
 821af90:	e0fffd03 	ldbu	r3,-12(fp)
 821af94:	008209b4 	movhi	r2,2086
 821af98:	10b6a904 	addi	r2,r2,-9564
 821af9c:	18c7883a 	add	r3,r3,r3
 821afa0:	18c7883a 	add	r3,r3,r3
 821afa4:	10c5883a 	add	r2,r2,r3
 821afa8:	10000015 	stw	zero,0(r2)
 821afac:	e0bff117 	ldw	r2,-60(fp)
 821afb0:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821afb4:	e0bff417 	ldw	r2,-48(fp)
 821afb8:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 821afbc:	e0bff603 	ldbu	r2,-40(fp)
 821afc0:	00000506 	br	821afd8 <OSTaskCreateExt+0x1d0>
 821afc4:	e0bff117 	ldw	r2,-60(fp)
 821afc8:	e0bff715 	stw	r2,-36(fp)
 821afcc:	e0bff717 	ldw	r2,-36(fp)
 821afd0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 821afd4:	00800a04 	movi	r2,40
}
 821afd8:	e037883a 	mov	sp,fp
 821afdc:	dfc00117 	ldw	ra,4(sp)
 821afe0:	df000017 	ldw	fp,0(sp)
 821afe4:	dec00204 	addi	sp,sp,8
 821afe8:	f800283a 	ret

0821afec <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
 821afec:	defff404 	addi	sp,sp,-48
 821aff0:	dfc00b15 	stw	ra,44(sp)
 821aff4:	df000a15 	stw	fp,40(sp)
 821aff8:	df000a04 	addi	fp,sp,40
 821affc:	2005883a 	mov	r2,r4
 821b000:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
 821b004:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
 821b008:	d0a07903 	ldbu	r2,-32284(gp)
 821b00c:	10803fcc 	andi	r2,r2,255
 821b010:	10000226 	beq	r2,zero,821b01c <OSTaskDel+0x30>
        return (OS_ERR_TASK_DEL_ISR);
 821b014:	00801004 	movi	r2,64
 821b018:	0000c006 	br	821b31c <OSTaskDel+0x330>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
 821b01c:	e0bfff03 	ldbu	r2,-4(fp)
 821b020:	10800518 	cmpnei	r2,r2,20
 821b024:	1000021e 	bne	r2,zero,821b030 <OSTaskDel+0x44>
        return (OS_ERR_TASK_DEL_IDLE);
 821b028:	00800f84 	movi	r2,62
 821b02c:	0000bb06 	br	821b31c <OSTaskDel+0x330>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
 821b030:	e0bfff03 	ldbu	r2,-4(fp)
 821b034:	10800530 	cmpltui	r2,r2,20
 821b038:	1000051e 	bne	r2,zero,821b050 <OSTaskDel+0x64>
        if (prio != OS_PRIO_SELF) {
 821b03c:	e0bfff03 	ldbu	r2,-4(fp)
 821b040:	10803fe0 	cmpeqi	r2,r2,255
 821b044:	1000021e 	bne	r2,zero,821b050 <OSTaskDel+0x64>
            return (OS_ERR_PRIO_INVALID);
 821b048:	00800a84 	movi	r2,42
 821b04c:	0000b306 	br	821b31c <OSTaskDel+0x330>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b050:	0005303a 	rdctl	r2,status
 821b054:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b058:	e0fffe17 	ldw	r3,-8(fp)
 821b05c:	00bfff84 	movi	r2,-2
 821b060:	1884703a 	and	r2,r3,r2
 821b064:	1001703a 	wrctl	status,r2
  
  return context;
 821b068:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
 821b06c:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
 821b070:	e0bfff03 	ldbu	r2,-4(fp)
 821b074:	10803fd8 	cmpnei	r2,r2,255
 821b078:	1000031e 	bne	r2,zero,821b088 <OSTaskDel+0x9c>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
 821b07c:	d0a07a17 	ldw	r2,-32280(gp)
 821b080:	10800c83 	ldbu	r2,50(r2)
 821b084:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821b088:	e0ffff03 	ldbu	r3,-4(fp)
 821b08c:	008209b4 	movhi	r2,2086
 821b090:	10b6a904 	addi	r2,r2,-9564
 821b094:	18c7883a 	add	r3,r3,r3
 821b098:	18c7883a 	add	r3,r3,r3
 821b09c:	10c5883a 	add	r2,r2,r3
 821b0a0:	10800017 	ldw	r2,0(r2)
 821b0a4:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
 821b0a8:	e0bff817 	ldw	r2,-32(fp)
 821b0ac:	1000061e 	bne	r2,zero,821b0c8 <OSTaskDel+0xdc>
 821b0b0:	e0bff617 	ldw	r2,-40(fp)
 821b0b4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b0b8:	e0bff717 	ldw	r2,-36(fp)
 821b0bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821b0c0:	008010c4 	movi	r2,67
 821b0c4:	00009506 	br	821b31c <OSTaskDel+0x330>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
 821b0c8:	e0bff817 	ldw	r2,-32(fp)
 821b0cc:	10800058 	cmpnei	r2,r2,1
 821b0d0:	1000061e 	bne	r2,zero,821b0ec <OSTaskDel+0x100>
 821b0d4:	e0bff617 	ldw	r2,-40(fp)
 821b0d8:	e0bff915 	stw	r2,-28(fp)
 821b0dc:	e0bff917 	ldw	r2,-28(fp)
 821b0e0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 821b0e4:	00800f44 	movi	r2,61
 821b0e8:	00008c06 	br	821b31c <OSTaskDel+0x330>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
 821b0ec:	e0bff817 	ldw	r2,-32(fp)
 821b0f0:	10800d03 	ldbu	r2,52(r2)
 821b0f4:	10c03fcc 	andi	r3,r2,255
 821b0f8:	e0bff817 	ldw	r2,-32(fp)
 821b0fc:	10800d03 	ldbu	r2,52(r2)
 821b100:	11003fcc 	andi	r4,r2,255
 821b104:	d0a07744 	addi	r2,gp,-32291
 821b108:	2085883a 	add	r2,r4,r2
 821b10c:	10800003 	ldbu	r2,0(r2)
 821b110:	1009883a 	mov	r4,r2
 821b114:	e0bff817 	ldw	r2,-32(fp)
 821b118:	10800d43 	ldbu	r2,53(r2)
 821b11c:	0084303a 	nor	r2,zero,r2
 821b120:	2084703a 	and	r2,r4,r2
 821b124:	1009883a 	mov	r4,r2
 821b128:	d0a07744 	addi	r2,gp,-32291
 821b12c:	1885883a 	add	r2,r3,r2
 821b130:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
 821b134:	e0bff817 	ldw	r2,-32(fp)
 821b138:	10800d03 	ldbu	r2,52(r2)
 821b13c:	10c03fcc 	andi	r3,r2,255
 821b140:	d0a07744 	addi	r2,gp,-32291
 821b144:	1885883a 	add	r2,r3,r2
 821b148:	10800003 	ldbu	r2,0(r2)
 821b14c:	10803fcc 	andi	r2,r2,255
 821b150:	1000071e 	bne	r2,zero,821b170 <OSTaskDel+0x184>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
 821b154:	e0bff817 	ldw	r2,-32(fp)
 821b158:	10800d83 	ldbu	r2,54(r2)
 821b15c:	0084303a 	nor	r2,zero,r2
 821b160:	1007883a 	mov	r3,r2
 821b164:	d0a07703 	ldbu	r2,-32292(gp)
 821b168:	1884703a 	and	r2,r3,r2
 821b16c:	d0a07705 	stb	r2,-32292(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
 821b170:	e0bff817 	ldw	r2,-32(fp)
 821b174:	10800717 	ldw	r2,28(r2)
 821b178:	10000526 	beq	r2,zero,821b190 <OSTaskDel+0x1a4>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
 821b17c:	e0bff817 	ldw	r2,-32(fp)
 821b180:	10800717 	ldw	r2,28(r2)
 821b184:	100b883a 	mov	r5,r2
 821b188:	e13ff817 	ldw	r4,-32(fp)
 821b18c:	8215ed00 	call	8215ed0 <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
 821b190:	e0bff817 	ldw	r2,-32(fp)
 821b194:	10800817 	ldw	r2,32(r2)
 821b198:	10000526 	beq	r2,zero,821b1b0 <OSTaskDel+0x1c4>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 821b19c:	e0bff817 	ldw	r2,-32(fp)
 821b1a0:	10800817 	ldw	r2,32(r2)
 821b1a4:	100b883a 	mov	r5,r2
 821b1a8:	e13ff817 	ldw	r4,-32(fp)
 821b1ac:	8215f880 	call	8215f88 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
 821b1b0:	e0bff817 	ldw	r2,-32(fp)
 821b1b4:	10800a17 	ldw	r2,40(r2)
 821b1b8:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
 821b1bc:	e0bffb17 	ldw	r2,-20(fp)
 821b1c0:	10000226 	beq	r2,zero,821b1cc <OSTaskDel+0x1e0>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
 821b1c4:	e13ffb17 	ldw	r4,-20(fp)
 821b1c8:	82184100 	call	8218410 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
 821b1cc:	e0bff817 	ldw	r2,-32(fp)
 821b1d0:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
 821b1d4:	e0bff817 	ldw	r2,-32(fp)
 821b1d8:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 821b1dc:	e0bff817 	ldw	r2,-32(fp)
 821b1e0:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
 821b1e4:	d0a06b03 	ldbu	r2,-32340(gp)
 821b1e8:	10803fcc 	andi	r2,r2,255
 821b1ec:	10803fe0 	cmpeqi	r2,r2,255
 821b1f0:	1000031e 	bne	r2,zero,821b200 <OSTaskDel+0x214>
        OSLockNesting++;
 821b1f4:	d0a06b03 	ldbu	r2,-32340(gp)
 821b1f8:	10800044 	addi	r2,r2,1
 821b1fc:	d0a06b05 	stb	r2,-32340(gp)
 821b200:	e0bff617 	ldw	r2,-40(fp)
 821b204:	e0bffd15 	stw	r2,-12(fp)
 821b208:	e0bffd17 	ldw	r2,-12(fp)
 821b20c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
 821b210:	8215ab80 	call	8215ab8 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b214:	0005303a 	rdctl	r2,status
 821b218:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b21c:	e0fffa17 	ldw	r3,-24(fp)
 821b220:	00bfff84 	movi	r2,-2
 821b224:	1884703a 	and	r2,r3,r2
 821b228:	1001703a 	wrctl	status,r2
  
  return context;
 821b22c:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
 821b230:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
 821b234:	d0a06b03 	ldbu	r2,-32340(gp)
 821b238:	10803fcc 	andi	r2,r2,255
 821b23c:	10000326 	beq	r2,zero,821b24c <OSTaskDel+0x260>
        OSLockNesting--;
 821b240:	d0a06b03 	ldbu	r2,-32340(gp)
 821b244:	10bfffc4 	addi	r2,r2,-1
 821b248:	d0a06b05 	stb	r2,-32340(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
 821b24c:	e13ff817 	ldw	r4,-32(fp)
 821b250:	823cf040 	call	823cf04 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
 821b254:	d0a07343 	ldbu	r2,-32307(gp)
 821b258:	10bfffc4 	addi	r2,r2,-1
 821b25c:	d0a07345 	stb	r2,-32307(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
 821b260:	e0ffff03 	ldbu	r3,-4(fp)
 821b264:	008209b4 	movhi	r2,2086
 821b268:	10b6a904 	addi	r2,r2,-9564
 821b26c:	18c7883a 	add	r3,r3,r3
 821b270:	18c7883a 	add	r3,r3,r3
 821b274:	10c5883a 	add	r2,r2,r3
 821b278:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
 821b27c:	e0bff817 	ldw	r2,-32(fp)
 821b280:	10800617 	ldw	r2,24(r2)
 821b284:	1000071e 	bne	r2,zero,821b2a4 <OSTaskDel+0x2b8>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
 821b288:	e0bff817 	ldw	r2,-32(fp)
 821b28c:	10800517 	ldw	r2,20(r2)
 821b290:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
 821b294:	e0bff817 	ldw	r2,-32(fp)
 821b298:	10800517 	ldw	r2,20(r2)
 821b29c:	d0a06e15 	stw	r2,-32328(gp)
 821b2a0:	00000a06 	br	821b2cc <OSTaskDel+0x2e0>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
 821b2a4:	e0bff817 	ldw	r2,-32(fp)
 821b2a8:	10800617 	ldw	r2,24(r2)
 821b2ac:	e0fff817 	ldw	r3,-32(fp)
 821b2b0:	18c00517 	ldw	r3,20(r3)
 821b2b4:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
 821b2b8:	e0bff817 	ldw	r2,-32(fp)
 821b2bc:	10800517 	ldw	r2,20(r2)
 821b2c0:	e0fff817 	ldw	r3,-32(fp)
 821b2c4:	18c00617 	ldw	r3,24(r3)
 821b2c8:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
 821b2cc:	d0e07217 	ldw	r3,-32312(gp)
 821b2d0:	e0bff817 	ldw	r2,-32(fp)
 821b2d4:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
 821b2d8:	e0bff817 	ldw	r2,-32(fp)
 821b2dc:	d0a07215 	stw	r2,-32312(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
 821b2e0:	e0bff817 	ldw	r2,-32(fp)
 821b2e4:	00c00fc4 	movi	r3,63
 821b2e8:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 821b2ec:	e0bff817 	ldw	r2,-32(fp)
 821b2f0:	10001345 	stb	zero,77(r2)
 821b2f4:	e0bff617 	ldw	r2,-40(fp)
 821b2f8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b2fc:	e0bffc17 	ldw	r2,-16(fp)
 821b300:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 821b304:	d0a06b43 	ldbu	r2,-32339(gp)
 821b308:	10803fcc 	andi	r2,r2,255
 821b30c:	10800058 	cmpnei	r2,r2,1
 821b310:	1000011e 	bne	r2,zero,821b318 <OSTaskDel+0x32c>
        OS_Sched();                                     /* Find new highest priority task              */
 821b314:	82165240 	call	8216524 <OS_Sched>
    }
    return (OS_ERR_NONE);
 821b318:	0005883a 	mov	r2,zero
}
 821b31c:	e037883a 	mov	sp,fp
 821b320:	dfc00117 	ldw	ra,4(sp)
 821b324:	df000017 	ldw	fp,0(sp)
 821b328:	dec00204 	addi	sp,sp,8
 821b32c:	f800283a 	ret

0821b330 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
 821b330:	defff504 	addi	sp,sp,-44
 821b334:	df000a15 	stw	fp,40(sp)
 821b338:	df000a04 	addi	fp,sp,40
 821b33c:	2005883a 	mov	r2,r4
 821b340:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821b344:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
 821b348:	e0bfff03 	ldbu	r2,-4(fp)
 821b34c:	10800518 	cmpnei	r2,r2,20
 821b350:	1000021e 	bne	r2,zero,821b35c <OSTaskDelReq+0x2c>
        return (OS_ERR_TASK_DEL_IDLE);
 821b354:	00800f84 	movi	r2,62
 821b358:	00004506 	br	821b470 <OSTaskDelReq+0x140>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 821b35c:	e0bfff03 	ldbu	r2,-4(fp)
 821b360:	10800530 	cmpltui	r2,r2,20
 821b364:	1000051e 	bne	r2,zero,821b37c <OSTaskDelReq+0x4c>
        if (prio != OS_PRIO_SELF) {
 821b368:	e0bfff03 	ldbu	r2,-4(fp)
 821b36c:	10803fe0 	cmpeqi	r2,r2,255
 821b370:	1000021e 	bne	r2,zero,821b37c <OSTaskDelReq+0x4c>
            return (OS_ERR_PRIO_INVALID);
 821b374:	00800a84 	movi	r2,42
 821b378:	00003d06 	br	821b470 <OSTaskDelReq+0x140>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
 821b37c:	e0bfff03 	ldbu	r2,-4(fp)
 821b380:	10803fd8 	cmpnei	r2,r2,255
 821b384:	1000111e 	bne	r2,zero,821b3cc <OSTaskDelReq+0x9c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b388:	0005303a 	rdctl	r2,status
 821b38c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b390:	e0fff917 	ldw	r3,-28(fp)
 821b394:	00bfff84 	movi	r2,-2
 821b398:	1884703a 	and	r2,r3,r2
 821b39c:	1001703a 	wrctl	status,r2
  
  return context;
 821b3a0:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
 821b3a4:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
 821b3a8:	d0a07a17 	ldw	r2,-32280(gp)
 821b3ac:	10800dc3 	ldbu	r2,55(r2)
 821b3b0:	e0bff805 	stb	r2,-32(fp)
 821b3b4:	e0bff617 	ldw	r2,-40(fp)
 821b3b8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b3bc:	e0bffe17 	ldw	r2,-8(fp)
 821b3c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
 821b3c4:	e0bff803 	ldbu	r2,-32(fp)
 821b3c8:	00002906 	br	821b470 <OSTaskDelReq+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b3cc:	0005303a 	rdctl	r2,status
 821b3d0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b3d4:	e0fff717 	ldw	r3,-36(fp)
 821b3d8:	00bfff84 	movi	r2,-2
 821b3dc:	1884703a 	and	r2,r3,r2
 821b3e0:	1001703a 	wrctl	status,r2
  
  return context;
 821b3e4:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 821b3e8:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
 821b3ec:	e0ffff03 	ldbu	r3,-4(fp)
 821b3f0:	008209b4 	movhi	r2,2086
 821b3f4:	10b6a904 	addi	r2,r2,-9564
 821b3f8:	18c7883a 	add	r3,r3,r3
 821b3fc:	18c7883a 	add	r3,r3,r3
 821b400:	10c5883a 	add	r2,r2,r3
 821b404:	10800017 	ldw	r2,0(r2)
 821b408:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
 821b40c:	e0bffb17 	ldw	r2,-20(fp)
 821b410:	1000061e 	bne	r2,zero,821b42c <OSTaskDelReq+0xfc>
 821b414:	e0bff617 	ldw	r2,-40(fp)
 821b418:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b41c:	e0bffa17 	ldw	r2,-24(fp)
 821b420:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
 821b424:	008010c4 	movi	r2,67
 821b428:	00001106 	br	821b470 <OSTaskDelReq+0x140>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
 821b42c:	e0bffb17 	ldw	r2,-20(fp)
 821b430:	10800058 	cmpnei	r2,r2,1
 821b434:	1000061e 	bne	r2,zero,821b450 <OSTaskDelReq+0x120>
 821b438:	e0bff617 	ldw	r2,-40(fp)
 821b43c:	e0bffc15 	stw	r2,-16(fp)
 821b440:	e0bffc17 	ldw	r2,-16(fp)
 821b444:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 821b448:	00800f44 	movi	r2,61
 821b44c:	00000806 	br	821b470 <OSTaskDelReq+0x140>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
 821b450:	e0bffb17 	ldw	r2,-20(fp)
 821b454:	00c00fc4 	movi	r3,63
 821b458:	10c00dc5 	stb	r3,55(r2)
 821b45c:	e0bff617 	ldw	r2,-40(fp)
 821b460:	e0bffd15 	stw	r2,-12(fp)
 821b464:	e0bffd17 	ldw	r2,-12(fp)
 821b468:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 821b46c:	0005883a 	mov	r2,zero
}
 821b470:	e037883a 	mov	sp,fp
 821b474:	df000017 	ldw	fp,0(sp)
 821b478:	dec00104 	addi	sp,sp,4
 821b47c:	f800283a 	ret

0821b480 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
 821b480:	defff404 	addi	sp,sp,-48
 821b484:	dfc00b15 	stw	ra,44(sp)
 821b488:	df000a15 	stw	fp,40(sp)
 821b48c:	df000a04 	addi	fp,sp,40
 821b490:	2005883a 	mov	r2,r4
 821b494:	e17ffe15 	stw	r5,-8(fp)
 821b498:	e1bfff15 	stw	r6,-4(fp)
 821b49c:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
 821b4a0:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
 821b4a4:	e0bfff17 	ldw	r2,-4(fp)
 821b4a8:	1000021e 	bne	r2,zero,821b4b4 <OSTaskNameGet+0x34>
        return (0);
 821b4ac:	0005883a 	mov	r2,zero
 821b4b0:	00005406 	br	821b604 <OSTaskNameGet+0x184>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
 821b4b4:	e0bffd03 	ldbu	r2,-12(fp)
 821b4b8:	10800570 	cmpltui	r2,r2,21
 821b4bc:	1000081e 	bne	r2,zero,821b4e0 <OSTaskNameGet+0x60>
        if (prio != OS_PRIO_SELF) {
 821b4c0:	e0bffd03 	ldbu	r2,-12(fp)
 821b4c4:	10803fe0 	cmpeqi	r2,r2,255
 821b4c8:	1000051e 	bne	r2,zero,821b4e0 <OSTaskNameGet+0x60>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
 821b4cc:	e0bfff17 	ldw	r2,-4(fp)
 821b4d0:	00c00a84 	movi	r3,42
 821b4d4:	10c00005 	stb	r3,0(r2)
            return (0);
 821b4d8:	0005883a 	mov	r2,zero
 821b4dc:	00004906 	br	821b604 <OSTaskNameGet+0x184>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
 821b4e0:	e0bffe17 	ldw	r2,-8(fp)
 821b4e4:	1000051e 	bne	r2,zero,821b4fc <OSTaskNameGet+0x7c>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
 821b4e8:	e0bfff17 	ldw	r2,-4(fp)
 821b4ec:	00c00304 	movi	r3,12
 821b4f0:	10c00005 	stb	r3,0(r2)
        return (0);
 821b4f4:	0005883a 	mov	r2,zero
 821b4f8:	00004206 	br	821b604 <OSTaskNameGet+0x184>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
 821b4fc:	d0a07903 	ldbu	r2,-32284(gp)
 821b500:	10803fcc 	andi	r2,r2,255
 821b504:	10000526 	beq	r2,zero,821b51c <OSTaskNameGet+0x9c>
        *perr = OS_ERR_NAME_GET_ISR;
 821b508:	e0bfff17 	ldw	r2,-4(fp)
 821b50c:	00c00444 	movi	r3,17
 821b510:	10c00005 	stb	r3,0(r2)
        return (0);
 821b514:	0005883a 	mov	r2,zero
 821b518:	00003a06 	br	821b604 <OSTaskNameGet+0x184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b51c:	0005303a 	rdctl	r2,status
 821b520:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b524:	e0fffc17 	ldw	r3,-16(fp)
 821b528:	00bfff84 	movi	r2,-2
 821b52c:	1884703a 	and	r2,r3,r2
 821b530:	1001703a 	wrctl	status,r2
  
  return context;
 821b534:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821b538:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
 821b53c:	e0bffd03 	ldbu	r2,-12(fp)
 821b540:	10803fd8 	cmpnei	r2,r2,255
 821b544:	1000031e 	bne	r2,zero,821b554 <OSTaskNameGet+0xd4>
        prio = OSTCBCur->OSTCBPrio;
 821b548:	d0a07a17 	ldw	r2,-32280(gp)
 821b54c:	10800c83 	ldbu	r2,50(r2)
 821b550:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821b554:	e0fffd03 	ldbu	r3,-12(fp)
 821b558:	008209b4 	movhi	r2,2086
 821b55c:	10b6a904 	addi	r2,r2,-9564
 821b560:	18c7883a 	add	r3,r3,r3
 821b564:	18c7883a 	add	r3,r3,r3
 821b568:	10c5883a 	add	r2,r2,r3
 821b56c:	10800017 	ldw	r2,0(r2)
 821b570:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
 821b574:	e0bff817 	ldw	r2,-32(fp)
 821b578:	1000091e 	bne	r2,zero,821b5a0 <OSTaskNameGet+0x120>
 821b57c:	e0bff617 	ldw	r2,-40(fp)
 821b580:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b584:	e0bff717 	ldw	r2,-36(fp)
 821b588:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
 821b58c:	e0bfff17 	ldw	r2,-4(fp)
 821b590:	00c010c4 	movi	r3,67
 821b594:	10c00005 	stb	r3,0(r2)
        return (0);
 821b598:	0005883a 	mov	r2,zero
 821b59c:	00001906 	br	821b604 <OSTaskNameGet+0x184>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
 821b5a0:	e0bff817 	ldw	r2,-32(fp)
 821b5a4:	10800058 	cmpnei	r2,r2,1
 821b5a8:	1000091e 	bne	r2,zero,821b5d0 <OSTaskNameGet+0x150>
 821b5ac:	e0bff617 	ldw	r2,-40(fp)
 821b5b0:	e0bff915 	stw	r2,-28(fp)
 821b5b4:	e0bff917 	ldw	r2,-28(fp)
 821b5b8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
 821b5bc:	e0bfff17 	ldw	r2,-4(fp)
 821b5c0:	00c010c4 	movi	r3,67
 821b5c4:	10c00005 	stb	r3,0(r2)
        return (0);
 821b5c8:	0005883a 	mov	r2,zero
 821b5cc:	00000d06 	br	821b604 <OSTaskNameGet+0x184>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
 821b5d0:	e0bff817 	ldw	r2,-32(fp)
 821b5d4:	10801304 	addi	r2,r2,76
 821b5d8:	100b883a 	mov	r5,r2
 821b5dc:	e13ffe17 	ldw	r4,-8(fp)
 821b5e0:	82166680 	call	8216668 <OS_StrCopy>
 821b5e4:	e0bffb05 	stb	r2,-20(fp)
 821b5e8:	e0bff617 	ldw	r2,-40(fp)
 821b5ec:	e0bffa15 	stw	r2,-24(fp)
 821b5f0:	e0bffa17 	ldw	r2,-24(fp)
 821b5f4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 821b5f8:	e0bfff17 	ldw	r2,-4(fp)
 821b5fc:	10000005 	stb	zero,0(r2)
    return (len);
 821b600:	e0bffb03 	ldbu	r2,-20(fp)
}
 821b604:	e037883a 	mov	sp,fp
 821b608:	dfc00117 	ldw	ra,4(sp)
 821b60c:	df000017 	ldw	fp,0(sp)
 821b610:	dec00204 	addi	sp,sp,8
 821b614:	f800283a 	ret

0821b618 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
 821b618:	defff304 	addi	sp,sp,-52
 821b61c:	dfc00c15 	stw	ra,48(sp)
 821b620:	df000b15 	stw	fp,44(sp)
 821b624:	df000b04 	addi	fp,sp,44
 821b628:	2005883a 	mov	r2,r4
 821b62c:	e17ffe15 	stw	r5,-8(fp)
 821b630:	e1bfff15 	stw	r6,-4(fp)
 821b634:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 821b638:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 821b63c:	e0bfff17 	ldw	r2,-4(fp)
 821b640:	10005c26 	beq	r2,zero,821b7b4 <OSTaskNameSet+0x19c>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
 821b644:	e0bffd03 	ldbu	r2,-12(fp)
 821b648:	10800570 	cmpltui	r2,r2,21
 821b64c:	1000071e 	bne	r2,zero,821b66c <OSTaskNameSet+0x54>
        if (prio != OS_PRIO_SELF) {
 821b650:	e0bffd03 	ldbu	r2,-12(fp)
 821b654:	10803fe0 	cmpeqi	r2,r2,255
 821b658:	1000041e 	bne	r2,zero,821b66c <OSTaskNameSet+0x54>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
 821b65c:	e0bfff17 	ldw	r2,-4(fp)
 821b660:	00c00a84 	movi	r3,42
 821b664:	10c00005 	stb	r3,0(r2)
            return;
 821b668:	00005306 	br	821b7b8 <OSTaskNameSet+0x1a0>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
 821b66c:	e0bffe17 	ldw	r2,-8(fp)
 821b670:	1000041e 	bne	r2,zero,821b684 <OSTaskNameSet+0x6c>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
 821b674:	e0bfff17 	ldw	r2,-4(fp)
 821b678:	00c00304 	movi	r3,12
 821b67c:	10c00005 	stb	r3,0(r2)
        return;
 821b680:	00004d06 	br	821b7b8 <OSTaskNameSet+0x1a0>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
 821b684:	d0a07903 	ldbu	r2,-32284(gp)
 821b688:	10803fcc 	andi	r2,r2,255
 821b68c:	10000426 	beq	r2,zero,821b6a0 <OSTaskNameSet+0x88>
        *perr = OS_ERR_NAME_SET_ISR;
 821b690:	e0bfff17 	ldw	r2,-4(fp)
 821b694:	00c00484 	movi	r3,18
 821b698:	10c00005 	stb	r3,0(r2)
        return;
 821b69c:	00004606 	br	821b7b8 <OSTaskNameSet+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b6a0:	0005303a 	rdctl	r2,status
 821b6a4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b6a8:	e0fffc17 	ldw	r3,-16(fp)
 821b6ac:	00bfff84 	movi	r2,-2
 821b6b0:	1884703a 	and	r2,r3,r2
 821b6b4:	1001703a 	wrctl	status,r2
  
  return context;
 821b6b8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821b6bc:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
 821b6c0:	e0bffd03 	ldbu	r2,-12(fp)
 821b6c4:	10803fd8 	cmpnei	r2,r2,255
 821b6c8:	1000031e 	bne	r2,zero,821b6d8 <OSTaskNameSet+0xc0>
        prio = OSTCBCur->OSTCBPrio;
 821b6cc:	d0a07a17 	ldw	r2,-32280(gp)
 821b6d0:	10800c83 	ldbu	r2,50(r2)
 821b6d4:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821b6d8:	e0fffd03 	ldbu	r3,-12(fp)
 821b6dc:	008209b4 	movhi	r2,2086
 821b6e0:	10b6a904 	addi	r2,r2,-9564
 821b6e4:	18c7883a 	add	r3,r3,r3
 821b6e8:	18c7883a 	add	r3,r3,r3
 821b6ec:	10c5883a 	add	r2,r2,r3
 821b6f0:	10800017 	ldw	r2,0(r2)
 821b6f4:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
 821b6f8:	e0bff717 	ldw	r2,-36(fp)
 821b6fc:	1000081e 	bne	r2,zero,821b720 <OSTaskNameSet+0x108>
 821b700:	e0bff517 	ldw	r2,-44(fp)
 821b704:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b708:	e0bff617 	ldw	r2,-40(fp)
 821b70c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
 821b710:	e0bfff17 	ldw	r2,-4(fp)
 821b714:	00c010c4 	movi	r3,67
 821b718:	10c00005 	stb	r3,0(r2)
        return;
 821b71c:	00002606 	br	821b7b8 <OSTaskNameSet+0x1a0>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
 821b720:	e0bff717 	ldw	r2,-36(fp)
 821b724:	10800058 	cmpnei	r2,r2,1
 821b728:	1000081e 	bne	r2,zero,821b74c <OSTaskNameSet+0x134>
 821b72c:	e0bff517 	ldw	r2,-44(fp)
 821b730:	e0bff815 	stw	r2,-32(fp)
 821b734:	e0bff817 	ldw	r2,-32(fp)
 821b738:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
 821b73c:	e0bfff17 	ldw	r2,-4(fp)
 821b740:	00c010c4 	movi	r3,67
 821b744:	10c00005 	stb	r3,0(r2)
        return;
 821b748:	00001b06 	br	821b7b8 <OSTaskNameSet+0x1a0>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
 821b74c:	e13ffe17 	ldw	r4,-8(fp)
 821b750:	82166dc0 	call	82166dc <OS_StrLen>
 821b754:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
 821b758:	e0bffa03 	ldbu	r2,-24(fp)
 821b75c:	10800830 	cmpltui	r2,r2,32
 821b760:	1000081e 	bne	r2,zero,821b784 <OSTaskNameSet+0x16c>
 821b764:	e0bff517 	ldw	r2,-44(fp)
 821b768:	e0bff915 	stw	r2,-28(fp)
 821b76c:	e0bff917 	ldw	r2,-28(fp)
 821b770:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
 821b774:	e0bfff17 	ldw	r2,-4(fp)
 821b778:	00c01044 	movi	r3,65
 821b77c:	10c00005 	stb	r3,0(r2)
        return;
 821b780:	00000d06 	br	821b7b8 <OSTaskNameSet+0x1a0>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
 821b784:	e0bff717 	ldw	r2,-36(fp)
 821b788:	10801304 	addi	r2,r2,76
 821b78c:	e17ffe17 	ldw	r5,-8(fp)
 821b790:	1009883a 	mov	r4,r2
 821b794:	82166680 	call	8216668 <OS_StrCopy>
 821b798:	e0bff517 	ldw	r2,-44(fp)
 821b79c:	e0bffb15 	stw	r2,-20(fp)
 821b7a0:	e0bffb17 	ldw	r2,-20(fp)
 821b7a4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 821b7a8:	e0bfff17 	ldw	r2,-4(fp)
 821b7ac:	10000005 	stb	zero,0(r2)
 821b7b0:	00000106 	br	821b7b8 <OSTaskNameSet+0x1a0>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
 821b7b4:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
 821b7b8:	e037883a 	mov	sp,fp
 821b7bc:	dfc00117 	ldw	ra,4(sp)
 821b7c0:	df000017 	ldw	fp,0(sp)
 821b7c4:	dec00204 	addi	sp,sp,8
 821b7c8:	f800283a 	ret

0821b7cc <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
 821b7cc:	defff404 	addi	sp,sp,-48
 821b7d0:	dfc00b15 	stw	ra,44(sp)
 821b7d4:	df000a15 	stw	fp,40(sp)
 821b7d8:	df000a04 	addi	fp,sp,40
 821b7dc:	2005883a 	mov	r2,r4
 821b7e0:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 821b7e4:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
 821b7e8:	e0bfff03 	ldbu	r2,-4(fp)
 821b7ec:	10800530 	cmpltui	r2,r2,20
 821b7f0:	1000021e 	bne	r2,zero,821b7fc <OSTaskResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 821b7f4:	00800a84 	movi	r2,42
 821b7f8:	00006406 	br	821b98c <OSTaskResume+0x1c0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b7fc:	0005303a 	rdctl	r2,status
 821b800:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b804:	e0fffe17 	ldw	r3,-8(fp)
 821b808:	00bfff84 	movi	r2,-2
 821b80c:	1884703a 	and	r2,r3,r2
 821b810:	1001703a 	wrctl	status,r2
  
  return context;
 821b814:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821b818:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
 821b81c:	e0ffff03 	ldbu	r3,-4(fp)
 821b820:	008209b4 	movhi	r2,2086
 821b824:	10b6a904 	addi	r2,r2,-9564
 821b828:	18c7883a 	add	r3,r3,r3
 821b82c:	18c7883a 	add	r3,r3,r3
 821b830:	10c5883a 	add	r2,r2,r3
 821b834:	10800017 	ldw	r2,0(r2)
 821b838:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
 821b83c:	e0bff817 	ldw	r2,-32(fp)
 821b840:	1000061e 	bne	r2,zero,821b85c <OSTaskResume+0x90>
 821b844:	e0bff617 	ldw	r2,-40(fp)
 821b848:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b84c:	e0bff717 	ldw	r2,-36(fp)
 821b850:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
 821b854:	00801184 	movi	r2,70
 821b858:	00004c06 	br	821b98c <OSTaskResume+0x1c0>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
 821b85c:	e0bff817 	ldw	r2,-32(fp)
 821b860:	10800058 	cmpnei	r2,r2,1
 821b864:	1000061e 	bne	r2,zero,821b880 <OSTaskResume+0xb4>
 821b868:	e0bff617 	ldw	r2,-40(fp)
 821b86c:	e0bff915 	stw	r2,-28(fp)
 821b870:	e0bff917 	ldw	r2,-28(fp)
 821b874:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821b878:	008010c4 	movi	r2,67
 821b87c:	00004306 	br	821b98c <OSTaskResume+0x1c0>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
 821b880:	e0bff817 	ldw	r2,-32(fp)
 821b884:	10800c03 	ldbu	r2,48(r2)
 821b888:	10803fcc 	andi	r2,r2,255
 821b88c:	1080020c 	andi	r2,r2,8
 821b890:	10003926 	beq	r2,zero,821b978 <OSTaskResume+0x1ac>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
 821b894:	e0bff817 	ldw	r2,-32(fp)
 821b898:	10c00c03 	ldbu	r3,48(r2)
 821b89c:	00bffdc4 	movi	r2,-9
 821b8a0:	1884703a 	and	r2,r3,r2
 821b8a4:	1007883a 	mov	r3,r2
 821b8a8:	e0bff817 	ldw	r2,-32(fp)
 821b8ac:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
 821b8b0:	e0bff817 	ldw	r2,-32(fp)
 821b8b4:	10800c03 	ldbu	r2,48(r2)
 821b8b8:	10803fcc 	andi	r2,r2,255
 821b8bc:	1000281e 	bne	r2,zero,821b960 <OSTaskResume+0x194>
            if (ptcb->OSTCBDly == 0) {
 821b8c0:	e0bff817 	ldw	r2,-32(fp)
 821b8c4:	10800b8b 	ldhu	r2,46(r2)
 821b8c8:	10bfffcc 	andi	r2,r2,65535
 821b8cc:	10001f1e 	bne	r2,zero,821b94c <OSTaskResume+0x180>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
 821b8d0:	e0bff817 	ldw	r2,-32(fp)
 821b8d4:	10c00d83 	ldbu	r3,54(r2)
 821b8d8:	d0a07703 	ldbu	r2,-32292(gp)
 821b8dc:	1884b03a 	or	r2,r3,r2
 821b8e0:	d0a07705 	stb	r2,-32292(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 821b8e4:	e0bff817 	ldw	r2,-32(fp)
 821b8e8:	10800d03 	ldbu	r2,52(r2)
 821b8ec:	10c03fcc 	andi	r3,r2,255
 821b8f0:	e0bff817 	ldw	r2,-32(fp)
 821b8f4:	10800d03 	ldbu	r2,52(r2)
 821b8f8:	11003fcc 	andi	r4,r2,255
 821b8fc:	d0a07744 	addi	r2,gp,-32291
 821b900:	2085883a 	add	r2,r4,r2
 821b904:	11000003 	ldbu	r4,0(r2)
 821b908:	e0bff817 	ldw	r2,-32(fp)
 821b90c:	10800d43 	ldbu	r2,53(r2)
 821b910:	2084b03a 	or	r2,r4,r2
 821b914:	1009883a 	mov	r4,r2
 821b918:	d0a07744 	addi	r2,gp,-32291
 821b91c:	1885883a 	add	r2,r3,r2
 821b920:	11000005 	stb	r4,0(r2)
 821b924:	e0bff617 	ldw	r2,-40(fp)
 821b928:	e0bffa15 	stw	r2,-24(fp)
 821b92c:	e0bffa17 	ldw	r2,-24(fp)
 821b930:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
 821b934:	d0a06b43 	ldbu	r2,-32339(gp)
 821b938:	10803fcc 	andi	r2,r2,255
 821b93c:	10800058 	cmpnei	r2,r2,1
 821b940:	10000b1e 	bne	r2,zero,821b970 <OSTaskResume+0x1a4>
                    OS_Sched();                               /* Find new highest priority task        */
 821b944:	82165240 	call	8216524 <OS_Sched>
 821b948:	00000906 	br	821b970 <OSTaskResume+0x1a4>
 821b94c:	e0bff617 	ldw	r2,-40(fp)
 821b950:	e0bffb15 	stw	r2,-20(fp)
 821b954:	e0bffb17 	ldw	r2,-20(fp)
 821b958:	1001703a 	wrctl	status,r2
 821b95c:	00000406 	br	821b970 <OSTaskResume+0x1a4>
 821b960:	e0bff617 	ldw	r2,-40(fp)
 821b964:	e0bffc15 	stw	r2,-16(fp)
 821b968:	e0bffc17 	ldw	r2,-16(fp)
 821b96c:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
 821b970:	0005883a 	mov	r2,zero
 821b974:	00000506 	br	821b98c <OSTaskResume+0x1c0>
 821b978:	e0bff617 	ldw	r2,-40(fp)
 821b97c:	e0bffd15 	stw	r2,-12(fp)
 821b980:	e0bffd17 	ldw	r2,-12(fp)
 821b984:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
 821b988:	00801104 	movi	r2,68
}
 821b98c:	e037883a 	mov	sp,fp
 821b990:	dfc00117 	ldw	ra,4(sp)
 821b994:	df000017 	ldw	fp,0(sp)
 821b998:	dec00204 	addi	sp,sp,8
 821b99c:	f800283a 	ret

0821b9a0 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
 821b9a0:	defff304 	addi	sp,sp,-52
 821b9a4:	df000c15 	stw	fp,48(sp)
 821b9a8:	df000c04 	addi	fp,sp,48
 821b9ac:	2005883a 	mov	r2,r4
 821b9b0:	e17fff15 	stw	r5,-4(fp)
 821b9b4:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 821b9b8:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
 821b9bc:	e0bffe03 	ldbu	r2,-8(fp)
 821b9c0:	10800570 	cmpltui	r2,r2,21
 821b9c4:	1000051e 	bne	r2,zero,821b9dc <OSTaskStkChk+0x3c>
        if (prio != OS_PRIO_SELF) {
 821b9c8:	e0bffe03 	ldbu	r2,-8(fp)
 821b9cc:	10803fe0 	cmpeqi	r2,r2,255
 821b9d0:	1000021e 	bne	r2,zero,821b9dc <OSTaskStkChk+0x3c>
            return (OS_ERR_PRIO_INVALID);
 821b9d4:	00800a84 	movi	r2,42
 821b9d8:	00005d06 	br	821bb50 <OSTaskStkChk+0x1b0>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
 821b9dc:	e0bfff17 	ldw	r2,-4(fp)
 821b9e0:	1000021e 	bne	r2,zero,821b9ec <OSTaskStkChk+0x4c>
        return (OS_ERR_PDATA_NULL);
 821b9e4:	00800244 	movi	r2,9
 821b9e8:	00005906 	br	821bb50 <OSTaskStkChk+0x1b0>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
 821b9ec:	e0bfff17 	ldw	r2,-4(fp)
 821b9f0:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
 821b9f4:	e0bfff17 	ldw	r2,-4(fp)
 821b9f8:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b9fc:	0005303a 	rdctl	r2,status
 821ba00:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821ba04:	e0fffd17 	ldw	r3,-12(fp)
 821ba08:	00bfff84 	movi	r2,-2
 821ba0c:	1884703a 	and	r2,r3,r2
 821ba10:	1001703a 	wrctl	status,r2
  
  return context;
 821ba14:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
 821ba18:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
 821ba1c:	e0bffe03 	ldbu	r2,-8(fp)
 821ba20:	10803fd8 	cmpnei	r2,r2,255
 821ba24:	1000031e 	bne	r2,zero,821ba34 <OSTaskStkChk+0x94>
        prio = OSTCBCur->OSTCBPrio;
 821ba28:	d0a07a17 	ldw	r2,-32280(gp)
 821ba2c:	10800c83 	ldbu	r2,50(r2)
 821ba30:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821ba34:	e0fffe03 	ldbu	r3,-8(fp)
 821ba38:	008209b4 	movhi	r2,2086
 821ba3c:	10b6a904 	addi	r2,r2,-9564
 821ba40:	18c7883a 	add	r3,r3,r3
 821ba44:	18c7883a 	add	r3,r3,r3
 821ba48:	10c5883a 	add	r2,r2,r3
 821ba4c:	10800017 	ldw	r2,0(r2)
 821ba50:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
 821ba54:	e0bff817 	ldw	r2,-32(fp)
 821ba58:	1000061e 	bne	r2,zero,821ba74 <OSTaskStkChk+0xd4>
 821ba5c:	e0bff617 	ldw	r2,-40(fp)
 821ba60:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821ba64:	e0bff717 	ldw	r2,-36(fp)
 821ba68:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821ba6c:	008010c4 	movi	r2,67
 821ba70:	00003706 	br	821bb50 <OSTaskStkChk+0x1b0>
    }
    if (ptcb == OS_TCB_RESERVED) {
 821ba74:	e0bff817 	ldw	r2,-32(fp)
 821ba78:	10800058 	cmpnei	r2,r2,1
 821ba7c:	1000061e 	bne	r2,zero,821ba98 <OSTaskStkChk+0xf8>
 821ba80:	e0bff617 	ldw	r2,-40(fp)
 821ba84:	e0bff915 	stw	r2,-28(fp)
 821ba88:	e0bff917 	ldw	r2,-28(fp)
 821ba8c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821ba90:	008010c4 	movi	r2,67
 821ba94:	00002e06 	br	821bb50 <OSTaskStkChk+0x1b0>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
 821ba98:	e0bff817 	ldw	r2,-32(fp)
 821ba9c:	1080040b 	ldhu	r2,16(r2)
 821baa0:	10bfffcc 	andi	r2,r2,65535
 821baa4:	1080004c 	andi	r2,r2,1
 821baa8:	1000061e 	bne	r2,zero,821bac4 <OSTaskStkChk+0x124>
 821baac:	e0bff617 	ldw	r2,-40(fp)
 821bab0:	e0bffa15 	stw	r2,-24(fp)
 821bab4:	e0bffa17 	ldw	r2,-24(fp)
 821bab8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
 821babc:	00801144 	movi	r2,69
 821bac0:	00002306 	br	821bb50 <OSTaskStkChk+0x1b0>
    }
    nfree = 0;
 821bac4:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
 821bac8:	e0bff817 	ldw	r2,-32(fp)
 821bacc:	10800317 	ldw	r2,12(r2)
 821bad0:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
 821bad4:	e0bff817 	ldw	r2,-32(fp)
 821bad8:	10800217 	ldw	r2,8(r2)
 821badc:	e0bff415 	stw	r2,-48(fp)
 821bae0:	e0bff617 	ldw	r2,-40(fp)
 821bae4:	e0bffb15 	stw	r2,-20(fp)
 821bae8:	e0bffb17 	ldw	r2,-20(fp)
 821baec:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 821baf0:	00000306 	br	821bb00 <OSTaskStkChk+0x160>
        nfree++;
 821baf4:	e0bff517 	ldw	r2,-44(fp)
 821baf8:	10800044 	addi	r2,r2,1
 821bafc:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 821bb00:	e0bff417 	ldw	r2,-48(fp)
 821bb04:	10c00104 	addi	r3,r2,4
 821bb08:	e0fff415 	stw	r3,-48(fp)
 821bb0c:	10800017 	ldw	r2,0(r2)
 821bb10:	103ff826 	beq	r2,zero,821baf4 <OSTaskStkChk+0x154>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
 821bb14:	e0bff517 	ldw	r2,-44(fp)
 821bb18:	1085883a 	add	r2,r2,r2
 821bb1c:	1085883a 	add	r2,r2,r2
 821bb20:	1007883a 	mov	r3,r2
 821bb24:	e0bfff17 	ldw	r2,-4(fp)
 821bb28:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
 821bb2c:	e0fffc17 	ldw	r3,-16(fp)
 821bb30:	e0bff517 	ldw	r2,-44(fp)
 821bb34:	1885c83a 	sub	r2,r3,r2
 821bb38:	1085883a 	add	r2,r2,r2
 821bb3c:	1085883a 	add	r2,r2,r2
 821bb40:	1007883a 	mov	r3,r2
 821bb44:	e0bfff17 	ldw	r2,-4(fp)
 821bb48:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
 821bb4c:	0005883a 	mov	r2,zero
}
 821bb50:	e037883a 	mov	sp,fp
 821bb54:	df000017 	ldw	fp,0(sp)
 821bb58:	dec00104 	addi	sp,sp,4
 821bb5c:	f800283a 	ret

0821bb60 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
 821bb60:	defff504 	addi	sp,sp,-44
 821bb64:	dfc00a15 	stw	ra,40(sp)
 821bb68:	df000915 	stw	fp,36(sp)
 821bb6c:	df000904 	addi	fp,sp,36
 821bb70:	2005883a 	mov	r2,r4
 821bb74:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821bb78:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
 821bb7c:	e0bfff03 	ldbu	r2,-4(fp)
 821bb80:	10800518 	cmpnei	r2,r2,20
 821bb84:	1000021e 	bne	r2,zero,821bb90 <OSTaskSuspend+0x30>
        return (OS_ERR_TASK_SUSPEND_IDLE);
 821bb88:	008011c4 	movi	r2,71
 821bb8c:	00006806 	br	821bd30 <OSTaskSuspend+0x1d0>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 821bb90:	e0bfff03 	ldbu	r2,-4(fp)
 821bb94:	10800530 	cmpltui	r2,r2,20
 821bb98:	1000051e 	bne	r2,zero,821bbb0 <OSTaskSuspend+0x50>
        if (prio != OS_PRIO_SELF) {
 821bb9c:	e0bfff03 	ldbu	r2,-4(fp)
 821bba0:	10803fe0 	cmpeqi	r2,r2,255
 821bba4:	1000021e 	bne	r2,zero,821bbb0 <OSTaskSuspend+0x50>
            return (OS_ERR_PRIO_INVALID);
 821bba8:	00800a84 	movi	r2,42
 821bbac:	00006006 	br	821bd30 <OSTaskSuspend+0x1d0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821bbb0:	0005303a 	rdctl	r2,status
 821bbb4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821bbb8:	e0fffe17 	ldw	r3,-8(fp)
 821bbbc:	00bfff84 	movi	r2,-2
 821bbc0:	1884703a 	and	r2,r3,r2
 821bbc4:	1001703a 	wrctl	status,r2
  
  return context;
 821bbc8:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
 821bbcc:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
 821bbd0:	e0bfff03 	ldbu	r2,-4(fp)
 821bbd4:	10803fd8 	cmpnei	r2,r2,255
 821bbd8:	1000061e 	bne	r2,zero,821bbf4 <OSTaskSuspend+0x94>
        prio = OSTCBCur->OSTCBPrio;
 821bbdc:	d0a07a17 	ldw	r2,-32280(gp)
 821bbe0:	10800c83 	ldbu	r2,50(r2)
 821bbe4:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
 821bbe8:	00800044 	movi	r2,1
 821bbec:	e0bff705 	stb	r2,-36(fp)
 821bbf0:	00000906 	br	821bc18 <OSTaskSuspend+0xb8>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
 821bbf4:	d0a07a17 	ldw	r2,-32280(gp)
 821bbf8:	10800c83 	ldbu	r2,50(r2)
 821bbfc:	10c03fcc 	andi	r3,r2,255
 821bc00:	e0bfff03 	ldbu	r2,-4(fp)
 821bc04:	1880031e 	bne	r3,r2,821bc14 <OSTaskSuspend+0xb4>
        self = OS_TRUE;
 821bc08:	00800044 	movi	r2,1
 821bc0c:	e0bff705 	stb	r2,-36(fp)
 821bc10:	00000106 	br	821bc18 <OSTaskSuspend+0xb8>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
 821bc14:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821bc18:	e0ffff03 	ldbu	r3,-4(fp)
 821bc1c:	008209b4 	movhi	r2,2086
 821bc20:	10b6a904 	addi	r2,r2,-9564
 821bc24:	18c7883a 	add	r3,r3,r3
 821bc28:	18c7883a 	add	r3,r3,r3
 821bc2c:	10c5883a 	add	r2,r2,r3
 821bc30:	10800017 	ldw	r2,0(r2)
 821bc34:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
 821bc38:	e0bffa17 	ldw	r2,-24(fp)
 821bc3c:	1000061e 	bne	r2,zero,821bc58 <OSTaskSuspend+0xf8>
 821bc40:	e0bff817 	ldw	r2,-32(fp)
 821bc44:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821bc48:	e0bff917 	ldw	r2,-28(fp)
 821bc4c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
 821bc50:	00801204 	movi	r2,72
 821bc54:	00003606 	br	821bd30 <OSTaskSuspend+0x1d0>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
 821bc58:	e0bffa17 	ldw	r2,-24(fp)
 821bc5c:	10800058 	cmpnei	r2,r2,1
 821bc60:	1000061e 	bne	r2,zero,821bc7c <OSTaskSuspend+0x11c>
 821bc64:	e0bff817 	ldw	r2,-32(fp)
 821bc68:	e0bffb15 	stw	r2,-20(fp)
 821bc6c:	e0bffb17 	ldw	r2,-20(fp)
 821bc70:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821bc74:	008010c4 	movi	r2,67
 821bc78:	00002d06 	br	821bd30 <OSTaskSuspend+0x1d0>
    }
    y            = ptcb->OSTCBY;
 821bc7c:	e0bffa17 	ldw	r2,-24(fp)
 821bc80:	10800d03 	ldbu	r2,52(r2)
 821bc84:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
 821bc88:	e0fffd03 	ldbu	r3,-12(fp)
 821bc8c:	e13ffd03 	ldbu	r4,-12(fp)
 821bc90:	d0a07744 	addi	r2,gp,-32291
 821bc94:	2085883a 	add	r2,r4,r2
 821bc98:	10800003 	ldbu	r2,0(r2)
 821bc9c:	1009883a 	mov	r4,r2
 821bca0:	e0bffa17 	ldw	r2,-24(fp)
 821bca4:	10800d43 	ldbu	r2,53(r2)
 821bca8:	0084303a 	nor	r2,zero,r2
 821bcac:	2084703a 	and	r2,r4,r2
 821bcb0:	1009883a 	mov	r4,r2
 821bcb4:	d0a07744 	addi	r2,gp,-32291
 821bcb8:	1885883a 	add	r2,r3,r2
 821bcbc:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
 821bcc0:	e0fffd03 	ldbu	r3,-12(fp)
 821bcc4:	d0a07744 	addi	r2,gp,-32291
 821bcc8:	1885883a 	add	r2,r3,r2
 821bccc:	10800003 	ldbu	r2,0(r2)
 821bcd0:	10803fcc 	andi	r2,r2,255
 821bcd4:	1000071e 	bne	r2,zero,821bcf4 <OSTaskSuspend+0x194>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
 821bcd8:	e0bffa17 	ldw	r2,-24(fp)
 821bcdc:	10800d83 	ldbu	r2,54(r2)
 821bce0:	0084303a 	nor	r2,zero,r2
 821bce4:	1007883a 	mov	r3,r2
 821bce8:	d0a07703 	ldbu	r2,-32292(gp)
 821bcec:	1884703a 	and	r2,r3,r2
 821bcf0:	d0a07705 	stb	r2,-32292(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
 821bcf4:	e0bffa17 	ldw	r2,-24(fp)
 821bcf8:	10800c03 	ldbu	r2,48(r2)
 821bcfc:	10800214 	ori	r2,r2,8
 821bd00:	1007883a 	mov	r3,r2
 821bd04:	e0bffa17 	ldw	r2,-24(fp)
 821bd08:	10c00c05 	stb	r3,48(r2)
 821bd0c:	e0bff817 	ldw	r2,-32(fp)
 821bd10:	e0bffc15 	stw	r2,-16(fp)
 821bd14:	e0bffc17 	ldw	r2,-16(fp)
 821bd18:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
 821bd1c:	e0bff703 	ldbu	r2,-36(fp)
 821bd20:	10800058 	cmpnei	r2,r2,1
 821bd24:	1000011e 	bne	r2,zero,821bd2c <OSTaskSuspend+0x1cc>
        OS_Sched();                                             /* Find new highest priority task      */
 821bd28:	82165240 	call	8216524 <OS_Sched>
    }
    return (OS_ERR_NONE);
 821bd2c:	0005883a 	mov	r2,zero
}
 821bd30:	e037883a 	mov	sp,fp
 821bd34:	dfc00117 	ldw	ra,4(sp)
 821bd38:	df000017 	ldw	fp,0(sp)
 821bd3c:	dec00204 	addi	sp,sp,8
 821bd40:	f800283a 	ret

0821bd44 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
 821bd44:	defff604 	addi	sp,sp,-40
 821bd48:	dfc00915 	stw	ra,36(sp)
 821bd4c:	df000815 	stw	fp,32(sp)
 821bd50:	df000804 	addi	fp,sp,32
 821bd54:	2005883a 	mov	r2,r4
 821bd58:	e17fff15 	stw	r5,-4(fp)
 821bd5c:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821bd60:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
 821bd64:	e0bffe03 	ldbu	r2,-8(fp)
 821bd68:	10800570 	cmpltui	r2,r2,21
 821bd6c:	1000051e 	bne	r2,zero,821bd84 <OSTaskQuery+0x40>
        if (prio != OS_PRIO_SELF) {
 821bd70:	e0bffe03 	ldbu	r2,-8(fp)
 821bd74:	10803fe0 	cmpeqi	r2,r2,255
 821bd78:	1000021e 	bne	r2,zero,821bd84 <OSTaskQuery+0x40>
            return (OS_ERR_PRIO_INVALID);
 821bd7c:	00800a84 	movi	r2,42
 821bd80:	00003406 	br	821be54 <OSTaskQuery+0x110>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
 821bd84:	e0bfff17 	ldw	r2,-4(fp)
 821bd88:	1000021e 	bne	r2,zero,821bd94 <OSTaskQuery+0x50>
        return (OS_ERR_PDATA_NULL);
 821bd8c:	00800244 	movi	r2,9
 821bd90:	00003006 	br	821be54 <OSTaskQuery+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821bd94:	0005303a 	rdctl	r2,status
 821bd98:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821bd9c:	e0fffd17 	ldw	r3,-12(fp)
 821bda0:	00bfff84 	movi	r2,-2
 821bda4:	1884703a 	and	r2,r3,r2
 821bda8:	1001703a 	wrctl	status,r2
  
  return context;
 821bdac:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821bdb0:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
 821bdb4:	e0bffe03 	ldbu	r2,-8(fp)
 821bdb8:	10803fd8 	cmpnei	r2,r2,255
 821bdbc:	1000031e 	bne	r2,zero,821bdcc <OSTaskQuery+0x88>
        prio = OSTCBCur->OSTCBPrio;
 821bdc0:	d0a07a17 	ldw	r2,-32280(gp)
 821bdc4:	10800c83 	ldbu	r2,50(r2)
 821bdc8:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821bdcc:	e0fffe03 	ldbu	r3,-8(fp)
 821bdd0:	008209b4 	movhi	r2,2086
 821bdd4:	10b6a904 	addi	r2,r2,-9564
 821bdd8:	18c7883a 	add	r3,r3,r3
 821bddc:	18c7883a 	add	r3,r3,r3
 821bde0:	10c5883a 	add	r2,r2,r3
 821bde4:	10800017 	ldw	r2,0(r2)
 821bde8:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
 821bdec:	e0bffa17 	ldw	r2,-24(fp)
 821bdf0:	1000061e 	bne	r2,zero,821be0c <OSTaskQuery+0xc8>
 821bdf4:	e0bff817 	ldw	r2,-32(fp)
 821bdf8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821bdfc:	e0bff917 	ldw	r2,-28(fp)
 821be00:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
 821be04:	00800a44 	movi	r2,41
 821be08:	00001206 	br	821be54 <OSTaskQuery+0x110>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
 821be0c:	e0bffa17 	ldw	r2,-24(fp)
 821be10:	10800058 	cmpnei	r2,r2,1
 821be14:	1000061e 	bne	r2,zero,821be30 <OSTaskQuery+0xec>
 821be18:	e0bff817 	ldw	r2,-32(fp)
 821be1c:	e0bffb15 	stw	r2,-20(fp)
 821be20:	e0bffb17 	ldw	r2,-20(fp)
 821be24:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821be28:	008010c4 	movi	r2,67
 821be2c:	00000906 	br	821be54 <OSTaskQuery+0x110>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
 821be30:	01801b04 	movi	r6,108
 821be34:	e17ffa17 	ldw	r5,-24(fp)
 821be38:	e13fff17 	ldw	r4,-4(fp)
 821be3c:	82164bc0 	call	82164bc <OS_MemCopy>
 821be40:	e0bff817 	ldw	r2,-32(fp)
 821be44:	e0bffc15 	stw	r2,-16(fp)
 821be48:	e0bffc17 	ldw	r2,-16(fp)
 821be4c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 821be50:	0005883a 	mov	r2,zero
}
 821be54:	e037883a 	mov	sp,fp
 821be58:	dfc00117 	ldw	ra,4(sp)
 821be5c:	df000017 	ldw	fp,0(sp)
 821be60:	dec00204 	addi	sp,sp,8
 821be64:	f800283a 	ret

0821be68 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
 821be68:	defffc04 	addi	sp,sp,-16
 821be6c:	df000315 	stw	fp,12(sp)
 821be70:	df000304 	addi	fp,sp,12
 821be74:	e13ffd15 	stw	r4,-12(fp)
 821be78:	e17ffe15 	stw	r5,-8(fp)
 821be7c:	3005883a 	mov	r2,r6
 821be80:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
 821be84:	e0bfff0b 	ldhu	r2,-4(fp)
 821be88:	1080004c 	andi	r2,r2,1
 821be8c:	10000d26 	beq	r2,zero,821bec4 <OS_TaskStkClr+0x5c>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
 821be90:	e0bfff0b 	ldhu	r2,-4(fp)
 821be94:	1080008c 	andi	r2,r2,2
 821be98:	10000a26 	beq	r2,zero,821bec4 <OS_TaskStkClr+0x5c>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 821be9c:	00000706 	br	821bebc <OS_TaskStkClr+0x54>
                size--;
 821bea0:	e0bffe17 	ldw	r2,-8(fp)
 821bea4:	10bfffc4 	addi	r2,r2,-1
 821bea8:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
 821beac:	e0bffd17 	ldw	r2,-12(fp)
 821beb0:	10c00104 	addi	r3,r2,4
 821beb4:	e0fffd15 	stw	r3,-12(fp)
 821beb8:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 821bebc:	e0bffe17 	ldw	r2,-8(fp)
 821bec0:	103ff71e 	bne	r2,zero,821bea0 <OS_TaskStkClr+0x38>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
 821bec4:	0001883a 	nop
 821bec8:	e037883a 	mov	sp,fp
 821becc:	df000017 	ldw	fp,0(sp)
 821bed0:	dec00104 	addi	sp,sp,4
 821bed4:	f800283a 	ret

0821bed8 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
 821bed8:	defff904 	addi	sp,sp,-28
 821bedc:	dfc00615 	stw	ra,24(sp)
 821bee0:	df000515 	stw	fp,20(sp)
 821bee4:	df000504 	addi	fp,sp,20
 821bee8:	2005883a 	mov	r2,r4
 821beec:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821bef0:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 821bef4:	d0a07903 	ldbu	r2,-32284(gp)
 821bef8:	10803fcc 	andi	r2,r2,255
 821befc:	1000311e 	bne	r2,zero,821bfc4 <OSTimeDly+0xec>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
 821bf00:	e0bfff0b 	ldhu	r2,-4(fp)
 821bf04:	10003026 	beq	r2,zero,821bfc8 <OSTimeDly+0xf0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821bf08:	0005303a 	rdctl	r2,status
 821bf0c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821bf10:	e0fffe17 	ldw	r3,-8(fp)
 821bf14:	00bfff84 	movi	r2,-2
 821bf18:	1884703a 	and	r2,r3,r2
 821bf1c:	1001703a 	wrctl	status,r2
  
  return context;
 821bf20:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 821bf24:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
 821bf28:	d0a07a17 	ldw	r2,-32280(gp)
 821bf2c:	10800d03 	ldbu	r2,52(r2)
 821bf30:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 821bf34:	e0fffd03 	ldbu	r3,-12(fp)
 821bf38:	e13ffd03 	ldbu	r4,-12(fp)
 821bf3c:	d0a07744 	addi	r2,gp,-32291
 821bf40:	2085883a 	add	r2,r4,r2
 821bf44:	10800003 	ldbu	r2,0(r2)
 821bf48:	1009883a 	mov	r4,r2
 821bf4c:	d0a07a17 	ldw	r2,-32280(gp)
 821bf50:	10800d43 	ldbu	r2,53(r2)
 821bf54:	0084303a 	nor	r2,zero,r2
 821bf58:	2084703a 	and	r2,r4,r2
 821bf5c:	1009883a 	mov	r4,r2
 821bf60:	d0a07744 	addi	r2,gp,-32291
 821bf64:	1885883a 	add	r2,r3,r2
 821bf68:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
 821bf6c:	e0fffd03 	ldbu	r3,-12(fp)
 821bf70:	d0a07744 	addi	r2,gp,-32291
 821bf74:	1885883a 	add	r2,r3,r2
 821bf78:	10800003 	ldbu	r2,0(r2)
 821bf7c:	10803fcc 	andi	r2,r2,255
 821bf80:	1000071e 	bne	r2,zero,821bfa0 <OSTimeDly+0xc8>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 821bf84:	d0a07a17 	ldw	r2,-32280(gp)
 821bf88:	10800d83 	ldbu	r2,54(r2)
 821bf8c:	0084303a 	nor	r2,zero,r2
 821bf90:	1007883a 	mov	r3,r2
 821bf94:	d0a07703 	ldbu	r2,-32292(gp)
 821bf98:	1884703a 	and	r2,r3,r2
 821bf9c:	d0a07705 	stb	r2,-32292(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
 821bfa0:	d0a07a17 	ldw	r2,-32280(gp)
 821bfa4:	e0ffff0b 	ldhu	r3,-4(fp)
 821bfa8:	10c00b8d 	sth	r3,46(r2)
 821bfac:	e0bffb17 	ldw	r2,-20(fp)
 821bfb0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821bfb4:	e0bffc17 	ldw	r2,-16(fp)
 821bfb8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
 821bfbc:	82165240 	call	8216524 <OS_Sched>
 821bfc0:	00000106 	br	821bfc8 <OSTimeDly+0xf0>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
 821bfc4:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
 821bfc8:	e037883a 	mov	sp,fp
 821bfcc:	dfc00117 	ldw	ra,4(sp)
 821bfd0:	df000017 	ldw	fp,0(sp)
 821bfd4:	dec00204 	addi	sp,sp,8
 821bfd8:	f800283a 	ret

0821bfdc <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
 821bfdc:	defff804 	addi	sp,sp,-32
 821bfe0:	dfc00715 	stw	ra,28(sp)
 821bfe4:	df000615 	stw	fp,24(sp)
 821bfe8:	df000604 	addi	fp,sp,24
 821bfec:	2015883a 	mov	r10,r4
 821bff0:	2809883a 	mov	r4,r5
 821bff4:	3007883a 	mov	r3,r6
 821bff8:	3805883a 	mov	r2,r7
 821bffc:	e2bffc05 	stb	r10,-16(fp)
 821c000:	e13ffd05 	stb	r4,-12(fp)
 821c004:	e0fffe05 	stb	r3,-8(fp)
 821c008:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 821c00c:	d0a07903 	ldbu	r2,-32284(gp)
 821c010:	10803fcc 	andi	r2,r2,255
 821c014:	10000226 	beq	r2,zero,821c020 <OSTimeDlyHMSM+0x44>
        return (OS_ERR_TIME_DLY_ISR);
 821c018:	00801544 	movi	r2,85
 821c01c:	00004206 	br	821c128 <OSTimeDlyHMSM+0x14c>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
 821c020:	e0bffc03 	ldbu	r2,-16(fp)
 821c024:	1000081e 	bne	r2,zero,821c048 <OSTimeDlyHMSM+0x6c>
        if (minutes == 0) {
 821c028:	e0bffd03 	ldbu	r2,-12(fp)
 821c02c:	1000061e 	bne	r2,zero,821c048 <OSTimeDlyHMSM+0x6c>
            if (seconds == 0) {
 821c030:	e0bffe03 	ldbu	r2,-8(fp)
 821c034:	1000041e 	bne	r2,zero,821c048 <OSTimeDlyHMSM+0x6c>
                if (ms == 0) {
 821c038:	e0bfff0b 	ldhu	r2,-4(fp)
 821c03c:	1000021e 	bne	r2,zero,821c048 <OSTimeDlyHMSM+0x6c>
                    return (OS_ERR_TIME_ZERO_DLY);
 821c040:	00801504 	movi	r2,84
 821c044:	00003806 	br	821c128 <OSTimeDlyHMSM+0x14c>
                }
            }
        }
    }
    if (minutes > 59) {
 821c048:	e0bffd03 	ldbu	r2,-12(fp)
 821c04c:	10800f30 	cmpltui	r2,r2,60
 821c050:	1000021e 	bne	r2,zero,821c05c <OSTimeDlyHMSM+0x80>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
 821c054:	00801444 	movi	r2,81
 821c058:	00003306 	br	821c128 <OSTimeDlyHMSM+0x14c>
    }
    if (seconds > 59) {
 821c05c:	e0bffe03 	ldbu	r2,-8(fp)
 821c060:	10800f30 	cmpltui	r2,r2,60
 821c064:	1000021e 	bne	r2,zero,821c070 <OSTimeDlyHMSM+0x94>
        return (OS_ERR_TIME_INVALID_SECONDS);
 821c068:	00801484 	movi	r2,82
 821c06c:	00002e06 	br	821c128 <OSTimeDlyHMSM+0x14c>
    }
    if (ms > 999) {
 821c070:	e0bfff0b 	ldhu	r2,-4(fp)
 821c074:	1080fa30 	cmpltui	r2,r2,1000
 821c078:	1000021e 	bne	r2,zero,821c084 <OSTimeDlyHMSM+0xa8>
        return (OS_ERR_TIME_INVALID_MS);
 821c07c:	008014c4 	movi	r2,83
 821c080:	00002906 	br	821c128 <OSTimeDlyHMSM+0x14c>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
 821c084:	e0bffc03 	ldbu	r2,-16(fp)
 821c088:	10c38424 	muli	r3,r2,3600
 821c08c:	e0bffd03 	ldbu	r2,-12(fp)
 821c090:	10800f24 	muli	r2,r2,60
 821c094:	1887883a 	add	r3,r3,r2
 821c098:	e0bffe03 	ldbu	r2,-8(fp)
 821c09c:	1885883a 	add	r2,r3,r2
 821c0a0:	11001924 	muli	r4,r2,100
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
 821c0a4:	e0bfff0b 	ldhu	r2,-4(fp)
 821c0a8:	10801924 	muli	r2,r2,100
 821c0ac:	10c07d04 	addi	r3,r2,500
 821c0b0:	008418b4 	movhi	r2,4194
 821c0b4:	109374c4 	addi	r2,r2,19923
 821c0b8:	188a383a 	mulxuu	r5,r3,r2
 821c0bc:	1885383a 	mul	r2,r3,r2
 821c0c0:	1011883a 	mov	r8,r2
 821c0c4:	2813883a 	mov	r9,r5
 821c0c8:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
 821c0cc:	2085883a 	add	r2,r4,r2
 821c0d0:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
 821c0d4:	e0bffb17 	ldw	r2,-20(fp)
 821c0d8:	1004d43a 	srli	r2,r2,16
 821c0dc:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
 821c0e0:	e0bffb17 	ldw	r2,-20(fp)
 821c0e4:	10bfffcc 	andi	r2,r2,65535
 821c0e8:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
 821c0ec:	e0bffb17 	ldw	r2,-20(fp)
 821c0f0:	10bfffcc 	andi	r2,r2,65535
 821c0f4:	1009883a 	mov	r4,r2
 821c0f8:	821bed80 	call	821bed8 <OSTimeDly>
    while (loops > 0) {
 821c0fc:	00000706 	br	821c11c <OSTimeDlyHMSM+0x140>
        OSTimeDly((INT16U)32768u);
 821c100:	01200014 	movui	r4,32768
 821c104:	821bed80 	call	821bed8 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
 821c108:	01200014 	movui	r4,32768
 821c10c:	821bed80 	call	821bed8 <OSTimeDly>
        loops--;
 821c110:	e0bffa0b 	ldhu	r2,-24(fp)
 821c114:	10bfffc4 	addi	r2,r2,-1
 821c118:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
 821c11c:	e0bffa0b 	ldhu	r2,-24(fp)
 821c120:	103ff71e 	bne	r2,zero,821c100 <OSTimeDlyHMSM+0x124>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
 821c124:	0005883a 	mov	r2,zero
}
 821c128:	e037883a 	mov	sp,fp
 821c12c:	dfc00117 	ldw	ra,4(sp)
 821c130:	df000017 	ldw	fp,0(sp)
 821c134:	dec00204 	addi	sp,sp,8
 821c138:	f800283a 	ret

0821c13c <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
 821c13c:	defff504 	addi	sp,sp,-44
 821c140:	dfc00a15 	stw	ra,40(sp)
 821c144:	df000915 	stw	fp,36(sp)
 821c148:	df000904 	addi	fp,sp,36
 821c14c:	2005883a 	mov	r2,r4
 821c150:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821c154:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
 821c158:	e0bfff03 	ldbu	r2,-4(fp)
 821c15c:	10800530 	cmpltui	r2,r2,20
 821c160:	1000021e 	bne	r2,zero,821c16c <OSTimeDlyResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 821c164:	00800a84 	movi	r2,42
 821c168:	00006406 	br	821c2fc <OSTimeDlyResume+0x1c0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821c16c:	0005303a 	rdctl	r2,status
 821c170:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821c174:	e0fffe17 	ldw	r3,-8(fp)
 821c178:	00bfff84 	movi	r2,-2
 821c17c:	1884703a 	and	r2,r3,r2
 821c180:	1001703a 	wrctl	status,r2
  
  return context;
 821c184:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 821c188:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
 821c18c:	e0ffff03 	ldbu	r3,-4(fp)
 821c190:	008209b4 	movhi	r2,2086
 821c194:	10b6a904 	addi	r2,r2,-9564
 821c198:	18c7883a 	add	r3,r3,r3
 821c19c:	18c7883a 	add	r3,r3,r3
 821c1a0:	10c5883a 	add	r2,r2,r3
 821c1a4:	10800017 	ldw	r2,0(r2)
 821c1a8:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
 821c1ac:	e0bff917 	ldw	r2,-28(fp)
 821c1b0:	1000061e 	bne	r2,zero,821c1cc <OSTimeDlyResume+0x90>
 821c1b4:	e0bff717 	ldw	r2,-36(fp)
 821c1b8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821c1bc:	e0bff817 	ldw	r2,-32(fp)
 821c1c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 821c1c4:	008010c4 	movi	r2,67
 821c1c8:	00004c06 	br	821c2fc <OSTimeDlyResume+0x1c0>
    }
    if (ptcb == OS_TCB_RESERVED) {
 821c1cc:	e0bff917 	ldw	r2,-28(fp)
 821c1d0:	10800058 	cmpnei	r2,r2,1
 821c1d4:	1000061e 	bne	r2,zero,821c1f0 <OSTimeDlyResume+0xb4>
 821c1d8:	e0bff717 	ldw	r2,-36(fp)
 821c1dc:	e0bffa15 	stw	r2,-24(fp)
 821c1e0:	e0bffa17 	ldw	r2,-24(fp)
 821c1e4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 821c1e8:	008010c4 	movi	r2,67
 821c1ec:	00004306 	br	821c2fc <OSTimeDlyResume+0x1c0>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
 821c1f0:	e0bff917 	ldw	r2,-28(fp)
 821c1f4:	10800b8b 	ldhu	r2,46(r2)
 821c1f8:	10bfffcc 	andi	r2,r2,65535
 821c1fc:	1000061e 	bne	r2,zero,821c218 <OSTimeDlyResume+0xdc>
 821c200:	e0bff717 	ldw	r2,-36(fp)
 821c204:	e0bffb15 	stw	r2,-20(fp)
 821c208:	e0bffb17 	ldw	r2,-20(fp)
 821c20c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
 821c210:	00801404 	movi	r2,80
 821c214:	00003906 	br	821c2fc <OSTimeDlyResume+0x1c0>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
 821c218:	e0bff917 	ldw	r2,-28(fp)
 821c21c:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 821c220:	e0bff917 	ldw	r2,-28(fp)
 821c224:	10800c03 	ldbu	r2,48(r2)
 821c228:	10803fcc 	andi	r2,r2,255
 821c22c:	10800dcc 	andi	r2,r2,55
 821c230:	10000b26 	beq	r2,zero,821c260 <OSTimeDlyResume+0x124>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
 821c234:	e0bff917 	ldw	r2,-28(fp)
 821c238:	10c00c03 	ldbu	r3,48(r2)
 821c23c:	00bff204 	movi	r2,-56
 821c240:	1884703a 	and	r2,r3,r2
 821c244:	1007883a 	mov	r3,r2
 821c248:	e0bff917 	ldw	r2,-28(fp)
 821c24c:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
 821c250:	e0bff917 	ldw	r2,-28(fp)
 821c254:	00c00044 	movi	r3,1
 821c258:	10c00c45 	stb	r3,49(r2)
 821c25c:	00000206 	br	821c268 <OSTimeDlyResume+0x12c>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
 821c260:	e0bff917 	ldw	r2,-28(fp)
 821c264:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
 821c268:	e0bff917 	ldw	r2,-28(fp)
 821c26c:	10800c03 	ldbu	r2,48(r2)
 821c270:	10803fcc 	andi	r2,r2,255
 821c274:	1080020c 	andi	r2,r2,8
 821c278:	10001b1e 	bne	r2,zero,821c2e8 <OSTimeDlyResume+0x1ac>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
 821c27c:	e0bff917 	ldw	r2,-28(fp)
 821c280:	10c00d83 	ldbu	r3,54(r2)
 821c284:	d0a07703 	ldbu	r2,-32292(gp)
 821c288:	1884b03a 	or	r2,r3,r2
 821c28c:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 821c290:	e0bff917 	ldw	r2,-28(fp)
 821c294:	10800d03 	ldbu	r2,52(r2)
 821c298:	10c03fcc 	andi	r3,r2,255
 821c29c:	e0bff917 	ldw	r2,-28(fp)
 821c2a0:	10800d03 	ldbu	r2,52(r2)
 821c2a4:	11003fcc 	andi	r4,r2,255
 821c2a8:	d0a07744 	addi	r2,gp,-32291
 821c2ac:	2085883a 	add	r2,r4,r2
 821c2b0:	11000003 	ldbu	r4,0(r2)
 821c2b4:	e0bff917 	ldw	r2,-28(fp)
 821c2b8:	10800d43 	ldbu	r2,53(r2)
 821c2bc:	2084b03a 	or	r2,r4,r2
 821c2c0:	1009883a 	mov	r4,r2
 821c2c4:	d0a07744 	addi	r2,gp,-32291
 821c2c8:	1885883a 	add	r2,r3,r2
 821c2cc:	11000005 	stb	r4,0(r2)
 821c2d0:	e0bff717 	ldw	r2,-36(fp)
 821c2d4:	e0bffc15 	stw	r2,-16(fp)
 821c2d8:	e0bffc17 	ldw	r2,-16(fp)
 821c2dc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
 821c2e0:	82165240 	call	8216524 <OS_Sched>
 821c2e4:	00000406 	br	821c2f8 <OSTimeDlyResume+0x1bc>
 821c2e8:	e0bff717 	ldw	r2,-36(fp)
 821c2ec:	e0bffd15 	stw	r2,-12(fp)
 821c2f0:	e0bffd17 	ldw	r2,-12(fp)
 821c2f4:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
 821c2f8:	0005883a 	mov	r2,zero
}
 821c2fc:	e037883a 	mov	sp,fp
 821c300:	dfc00117 	ldw	ra,4(sp)
 821c304:	df000017 	ldw	fp,0(sp)
 821c308:	dec00204 	addi	sp,sp,8
 821c30c:	f800283a 	ret

0821c310 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
 821c310:	defffb04 	addi	sp,sp,-20
 821c314:	df000415 	stw	fp,16(sp)
 821c318:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821c31c:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821c320:	0005303a 	rdctl	r2,status
 821c324:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821c328:	e0fffe17 	ldw	r3,-8(fp)
 821c32c:	00bfff84 	movi	r2,-2
 821c330:	1884703a 	and	r2,r3,r2
 821c334:	1001703a 	wrctl	status,r2
  
  return context;
 821c338:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
 821c33c:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
 821c340:	d0a07b17 	ldw	r2,-32276(gp)
 821c344:	e0bffd15 	stw	r2,-12(fp)
 821c348:	e0bffc17 	ldw	r2,-16(fp)
 821c34c:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821c350:	e0bfff17 	ldw	r2,-4(fp)
 821c354:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
 821c358:	e0bffd17 	ldw	r2,-12(fp)
}
 821c35c:	e037883a 	mov	sp,fp
 821c360:	df000017 	ldw	fp,0(sp)
 821c364:	dec00104 	addi	sp,sp,4
 821c368:	f800283a 	ret

0821c36c <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
 821c36c:	defffb04 	addi	sp,sp,-20
 821c370:	df000415 	stw	fp,16(sp)
 821c374:	df000404 	addi	fp,sp,16
 821c378:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821c37c:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821c380:	0005303a 	rdctl	r2,status
 821c384:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821c388:	e0fffd17 	ldw	r3,-12(fp)
 821c38c:	00bfff84 	movi	r2,-2
 821c390:	1884703a 	and	r2,r3,r2
 821c394:	1001703a 	wrctl	status,r2
  
  return context;
 821c398:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 821c39c:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
 821c3a0:	e0bfff17 	ldw	r2,-4(fp)
 821c3a4:	d0a07b15 	stw	r2,-32276(gp)
 821c3a8:	e0bffc17 	ldw	r2,-16(fp)
 821c3ac:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821c3b0:	e0bffe17 	ldw	r2,-8(fp)
 821c3b4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 821c3b8:	0001883a 	nop
 821c3bc:	e037883a 	mov	sp,fp
 821c3c0:	df000017 	ldw	fp,0(sp)
 821c3c4:	dec00104 	addi	sp,sp,4
 821c3c8:	f800283a 	ret

0821c3cc <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 821c3cc:	defffd04 	addi	sp,sp,-12
 821c3d0:	dfc00215 	stw	ra,8(sp)
 821c3d4:	df000115 	stw	fp,4(sp)
 821c3d8:	df000104 	addi	fp,sp,4
 821c3dc:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 821c3e0:	d1604404 	addi	r5,gp,-32496
 821c3e4:	e13fff17 	ldw	r4,-4(fp)
 821c3e8:	823bdec0 	call	823bdec <alt_dev_llist_insert>
}
 821c3ec:	e037883a 	mov	sp,fp
 821c3f0:	dfc00117 	ldw	ra,4(sp)
 821c3f4:	df000017 	ldw	fp,0(sp)
 821c3f8:	dec00204 	addi	sp,sp,8
 821c3fc:	f800283a 	ret

0821c400 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 821c400:	defffd04 	addi	sp,sp,-12
 821c404:	dfc00215 	stw	ra,8(sp)
 821c408:	df000115 	stw	fp,4(sp)
 821c40c:	df000104 	addi	fp,sp,4
 821c410:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( CPU, cpu);
 821c414:	823cc900 	call	823cc90 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 821c418:	00800044 	movi	r2,1
 821c41c:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 821c420:	0001883a 	nop
 821c424:	e037883a 	mov	sp,fp
 821c428:	dfc00117 	ldw	ra,4(sp)
 821c42c:	df000017 	ldw	fp,0(sp)
 821c430:	dec00204 	addi	sp,sp,8
 821c434:	f800283a 	ret

0821c438 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 821c438:	defffa04 	addi	sp,sp,-24
 821c43c:	dfc00515 	stw	ra,20(sp)
 821c440:	df000415 	stw	fp,16(sp)
 821c444:	df000404 	addi	fp,sp,16
    ALTERA_AVALON_TIMER_INIT ( HIGH_RES_TIMER, high_res_timer);
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER, sys_clk_timer);
 821c448:	01c01904 	movi	r7,100
 821c44c:	000d883a 	mov	r6,zero
 821c450:	000b883a 	mov	r5,zero
 821c454:	01024034 	movhi	r4,2304
 821c458:	821f1080 	call	821f108 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
 821c45c:	01800044 	movi	r6,1
 821c460:	000b883a 	mov	r5,zero
 821c464:	01020974 	movhi	r4,2085
 821c468:	210a3304 	addi	r4,r4,10444
 821c46c:	821c7d40 	call	821c7d4 <altera_avalon_jtag_uart_init>
 821c470:	01020974 	movhi	r4,2085
 821c474:	210a2904 	addi	r4,r4,10404
 821c478:	821c3cc0 	call	821c3cc <alt_dev_reg>
    ALTERA_AVALON_LCD_16207_INIT ( LCD, lcd);
 821c47c:	01020974 	movhi	r4,2085
 821c480:	210e4e04 	addi	r4,r4,14648
 821c484:	821e11c0 	call	821e11c <altera_avalon_lcd_16207_init>
 821c488:	01020974 	movhi	r4,2085
 821c48c:	210e4404 	addi	r4,r4,14608
 821c490:	821c3cc0 	call	821c3cc <alt_dev_reg>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
 821c494:	01800084 	movi	r6,2
 821c498:	000b883a 	mov	r5,zero
 821c49c:	01020974 	movhi	r4,2085
 821c4a0:	210e8d04 	addi	r4,r4,14900
 821c4a4:	821efe80 	call	821efe8 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
 821c4a8:	018000c4 	movi	r6,3
 821c4ac:	000b883a 	mov	r5,zero
 821c4b0:	01020974 	movhi	r4,2085
 821c4b4:	210e9904 	addi	r4,r4,14948
 821c4b8:	821efe80 	call	821efe8 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
 821c4bc:	0001883a 	nop
    ALTERA_ETH_TSE_INIT ( TSE_MAC, tse_mac);
 821c4c0:	e03ffc15 	stw	zero,-16(fp)
 821c4c4:	00800044 	movi	r2,1
 821c4c8:	e0bffd15 	stw	r2,-12(fp)
 821c4cc:	e0bffd17 	ldw	r2,-12(fp)
 821c4d0:	00800216 	blt	zero,r2,821c4dc <alt_sys_init+0xa4>
 821c4d4:	00800044 	movi	r2,1
 821c4d8:	e0bffd15 	stw	r2,-12(fp)
 821c4dc:	e03ffc15 	stw	zero,-16(fp)
 821c4e0:	00005a06 	br	821c64c <alt_sys_init+0x214>
 821c4e4:	008209b4 	movhi	r2,2086
 821c4e8:	10b6be04 	addi	r2,r2,-9480
 821c4ec:	e0fffc17 	ldw	r3,-16(fp)
 821c4f0:	18c00724 	muli	r3,r3,28
 821c4f4:	10c5883a 	add	r2,r2,r3
 821c4f8:	10000015 	stw	zero,0(r2)
 821c4fc:	008209b4 	movhi	r2,2086
 821c500:	10b6be04 	addi	r2,r2,-9480
 821c504:	e0fffc17 	ldw	r3,-16(fp)
 821c508:	18c00724 	muli	r3,r3,28
 821c50c:	10c5883a 	add	r2,r2,r3
 821c510:	10800104 	addi	r2,r2,4
 821c514:	10000015 	stw	zero,0(r2)
 821c518:	d0e02917 	ldw	r3,-32604(gp)
 821c51c:	008209b4 	movhi	r2,2086
 821c520:	10b6be04 	addi	r2,r2,-9480
 821c524:	e13ffc17 	ldw	r4,-16(fp)
 821c528:	21000724 	muli	r4,r4,28
 821c52c:	1105883a 	add	r2,r2,r4
 821c530:	10800204 	addi	r2,r2,8
 821c534:	10c00015 	stw	r3,0(r2)
 821c538:	008209b4 	movhi	r2,2086
 821c53c:	10b6be04 	addi	r2,r2,-9480
 821c540:	e0fffc17 	ldw	r3,-16(fp)
 821c544:	18c00724 	muli	r3,r3,28
 821c548:	10c5883a 	add	r2,r2,r3
 821c54c:	10c00304 	addi	r3,r2,12
 821c550:	008208b4 	movhi	r2,2082
 821c554:	10905d04 	addi	r2,r2,16756
 821c558:	18800015 	stw	r2,0(r3)
 821c55c:	e0bffc17 	ldw	r2,-16(fp)
 821c560:	10c00724 	muli	r3,r2,28
 821c564:	008209b4 	movhi	r2,2086
 821c568:	10b6be04 	addi	r2,r2,-9480
 821c56c:	1885883a 	add	r2,r3,r2
 821c570:	d0e02e04 	addi	r3,gp,-32584
 821c574:	e0fffe15 	stw	r3,-8(fp)
 821c578:	e0bfff15 	stw	r2,-4(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 821c57c:	e0bfff17 	ldw	r2,-4(fp)
 821c580:	e0fffe17 	ldw	r3,-8(fp)
 821c584:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 821c588:	e0bffe17 	ldw	r2,-8(fp)
 821c58c:	10c00017 	ldw	r3,0(r2)
 821c590:	e0bfff17 	ldw	r2,-4(fp)
 821c594:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 821c598:	e0bffe17 	ldw	r2,-8(fp)
 821c59c:	10800017 	ldw	r2,0(r2)
 821c5a0:	e0ffff17 	ldw	r3,-4(fp)
 821c5a4:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 821c5a8:	e0bffe17 	ldw	r2,-8(fp)
 821c5ac:	e0ffff17 	ldw	r3,-4(fp)
 821c5b0:	10c00015 	stw	r3,0(r2)
 821c5b4:	d0a08003 	ldbu	r2,-32256(gp)
 821c5b8:	11003fcc 	andi	r4,r2,255
 821c5bc:	e0bffc17 	ldw	r2,-16(fp)
 821c5c0:	10c00724 	muli	r3,r2,28
 821c5c4:	008209b4 	movhi	r2,2086
 821c5c8:	10b6be04 	addi	r2,r2,-9480
 821c5cc:	1887883a 	add	r3,r3,r2
 821c5d0:	008209b4 	movhi	r2,2086
 821c5d4:	10b6fe04 	addi	r2,r2,-9224
 821c5d8:	21000324 	muli	r4,r4,12
 821c5dc:	1105883a 	add	r2,r2,r4
 821c5e0:	10c00015 	stw	r3,0(r2)
 821c5e4:	d0a08003 	ldbu	r2,-32256(gp)
 821c5e8:	10c03fcc 	andi	r3,r2,255
 821c5ec:	008209b4 	movhi	r2,2086
 821c5f0:	10b6fe04 	addi	r2,r2,-9224
 821c5f4:	18c00324 	muli	r3,r3,12
 821c5f8:	10c5883a 	add	r2,r2,r3
 821c5fc:	10c00104 	addi	r3,r2,4
 821c600:	00820034 	movhi	r2,2048
 821c604:	108c0004 	addi	r2,r2,12288
 821c608:	18800015 	stw	r2,0(r3)
 821c60c:	d0a08003 	ldbu	r2,-32256(gp)
 821c610:	10c03fcc 	andi	r3,r2,255
 821c614:	e0bffc17 	ldw	r2,-16(fp)
 821c618:	1009883a 	mov	r4,r2
 821c61c:	008209b4 	movhi	r2,2086
 821c620:	10b6fe04 	addi	r2,r2,-9224
 821c624:	18c00324 	muli	r3,r3,12
 821c628:	10c5883a 	add	r2,r2,r3
 821c62c:	10800204 	addi	r2,r2,8
 821c630:	11000005 	stb	r4,0(r2)
 821c634:	d0a08003 	ldbu	r2,-32256(gp)
 821c638:	10800044 	addi	r2,r2,1
 821c63c:	d0a08005 	stb	r2,-32256(gp)
 821c640:	e0bffc17 	ldw	r2,-16(fp)
 821c644:	10800044 	addi	r2,r2,1
 821c648:	e0bffc15 	stw	r2,-16(fp)
 821c64c:	e0fffc17 	ldw	r3,-16(fp)
 821c650:	e0bffd17 	ldw	r2,-12(fp)
 821c654:	18bfa316 	blt	r3,r2,821c4e4 <alt_sys_init+0xac>
}
 821c658:	0001883a 	nop
 821c65c:	e037883a 	mov	sp,fp
 821c660:	dfc00117 	ldw	ra,4(sp)
 821c664:	df000017 	ldw	fp,0(sp)
 821c668:	dec00204 	addi	sp,sp,8
 821c66c:	f800283a 	ret

0821c670 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 821c670:	defffa04 	addi	sp,sp,-24
 821c674:	dfc00515 	stw	ra,20(sp)
 821c678:	df000415 	stw	fp,16(sp)
 821c67c:	df000404 	addi	fp,sp,16
 821c680:	e13ffd15 	stw	r4,-12(fp)
 821c684:	e17ffe15 	stw	r5,-8(fp)
 821c688:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 821c68c:	e0bffd17 	ldw	r2,-12(fp)
 821c690:	10800017 	ldw	r2,0(r2)
 821c694:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 821c698:	e0bffc17 	ldw	r2,-16(fp)
 821c69c:	10c00a04 	addi	r3,r2,40
 821c6a0:	e0bffd17 	ldw	r2,-12(fp)
 821c6a4:	10800217 	ldw	r2,8(r2)
 821c6a8:	100f883a 	mov	r7,r2
 821c6ac:	e1bfff17 	ldw	r6,-4(fp)
 821c6b0:	e17ffe17 	ldw	r5,-8(fp)
 821c6b4:	1809883a 	mov	r4,r3
 821c6b8:	821ce1c0 	call	821ce1c <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 821c6bc:	e037883a 	mov	sp,fp
 821c6c0:	dfc00117 	ldw	ra,4(sp)
 821c6c4:	df000017 	ldw	fp,0(sp)
 821c6c8:	dec00204 	addi	sp,sp,8
 821c6cc:	f800283a 	ret

0821c6d0 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 821c6d0:	defffa04 	addi	sp,sp,-24
 821c6d4:	dfc00515 	stw	ra,20(sp)
 821c6d8:	df000415 	stw	fp,16(sp)
 821c6dc:	df000404 	addi	fp,sp,16
 821c6e0:	e13ffd15 	stw	r4,-12(fp)
 821c6e4:	e17ffe15 	stw	r5,-8(fp)
 821c6e8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 821c6ec:	e0bffd17 	ldw	r2,-12(fp)
 821c6f0:	10800017 	ldw	r2,0(r2)
 821c6f4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 821c6f8:	e0bffc17 	ldw	r2,-16(fp)
 821c6fc:	10c00a04 	addi	r3,r2,40
 821c700:	e0bffd17 	ldw	r2,-12(fp)
 821c704:	10800217 	ldw	r2,8(r2)
 821c708:	100f883a 	mov	r7,r2
 821c70c:	e1bfff17 	ldw	r6,-4(fp)
 821c710:	e17ffe17 	ldw	r5,-8(fp)
 821c714:	1809883a 	mov	r4,r3
 821c718:	821d0d80 	call	821d0d8 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 821c71c:	e037883a 	mov	sp,fp
 821c720:	dfc00117 	ldw	ra,4(sp)
 821c724:	df000017 	ldw	fp,0(sp)
 821c728:	dec00204 	addi	sp,sp,8
 821c72c:	f800283a 	ret

0821c730 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 821c730:	defffc04 	addi	sp,sp,-16
 821c734:	dfc00315 	stw	ra,12(sp)
 821c738:	df000215 	stw	fp,8(sp)
 821c73c:	df000204 	addi	fp,sp,8
 821c740:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 821c744:	e0bfff17 	ldw	r2,-4(fp)
 821c748:	10800017 	ldw	r2,0(r2)
 821c74c:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 821c750:	e0bffe17 	ldw	r2,-8(fp)
 821c754:	10c00a04 	addi	r3,r2,40
 821c758:	e0bfff17 	ldw	r2,-4(fp)
 821c75c:	10800217 	ldw	r2,8(r2)
 821c760:	100b883a 	mov	r5,r2
 821c764:	1809883a 	mov	r4,r3
 821c768:	821ccc40 	call	821ccc4 <altera_avalon_jtag_uart_close>
}
 821c76c:	e037883a 	mov	sp,fp
 821c770:	dfc00117 	ldw	ra,4(sp)
 821c774:	df000017 	ldw	fp,0(sp)
 821c778:	dec00204 	addi	sp,sp,8
 821c77c:	f800283a 	ret

0821c780 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 821c780:	defffa04 	addi	sp,sp,-24
 821c784:	dfc00515 	stw	ra,20(sp)
 821c788:	df000415 	stw	fp,16(sp)
 821c78c:	df000404 	addi	fp,sp,16
 821c790:	e13ffd15 	stw	r4,-12(fp)
 821c794:	e17ffe15 	stw	r5,-8(fp)
 821c798:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 821c79c:	e0bffd17 	ldw	r2,-12(fp)
 821c7a0:	10800017 	ldw	r2,0(r2)
 821c7a4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 821c7a8:	e0bffc17 	ldw	r2,-16(fp)
 821c7ac:	10800a04 	addi	r2,r2,40
 821c7b0:	e1bfff17 	ldw	r6,-4(fp)
 821c7b4:	e17ffe17 	ldw	r5,-8(fp)
 821c7b8:	1009883a 	mov	r4,r2
 821c7bc:	821cd2c0 	call	821cd2c <altera_avalon_jtag_uart_ioctl>
}
 821c7c0:	e037883a 	mov	sp,fp
 821c7c4:	dfc00117 	ldw	ra,4(sp)
 821c7c8:	df000017 	ldw	fp,0(sp)
 821c7cc:	dec00204 	addi	sp,sp,8
 821c7d0:	f800283a 	ret

0821c7d4 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 821c7d4:	defff104 	addi	sp,sp,-60
 821c7d8:	dfc00e15 	stw	ra,56(sp)
 821c7dc:	df000d15 	stw	fp,52(sp)
 821c7e0:	df000d04 	addi	fp,sp,52
 821c7e4:	e13ff915 	stw	r4,-28(fp)
 821c7e8:	e17ffa15 	stw	r5,-24(fp)
 821c7ec:	e1bffb15 	stw	r6,-20(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
 821c7f0:	e0bff917 	ldw	r2,-28(fp)
 821c7f4:	10800c04 	addi	r2,r2,48
 821c7f8:	e0bff415 	stw	r2,-48(fp)
 821c7fc:	e03ff80d 	sth	zero,-32(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
 821c800:	e0bff80b 	ldhu	r2,-32(fp)
 821c804:	e0fff884 	addi	r3,fp,-30
 821c808:	180b883a 	mov	r5,r3
 821c80c:	1009883a 	mov	r4,r2
 821c810:	82170a80 	call	82170a8 <OSFlagCreate>
 821c814:	1007883a 	mov	r3,r2
 821c818:	e0bff417 	ldw	r2,-48(fp)
 821c81c:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
 821c820:	e0bff917 	ldw	r2,-28(fp)
 821c824:	10800a04 	addi	r2,r2,40
 821c828:	e0bff515 	stw	r2,-44(fp)
 821c82c:	00800044 	movi	r2,1
 821c830:	e0bff78d 	sth	r2,-34(fp)
 821c834:	e0bff78b 	ldhu	r2,-34(fp)
 821c838:	1009883a 	mov	r4,r2
 821c83c:	8219dbc0 	call	8219dbc <OSSemCreate>
 821c840:	1007883a 	mov	r3,r2
 821c844:	e0bff517 	ldw	r2,-44(fp)
 821c848:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
 821c84c:	e0bff917 	ldw	r2,-28(fp)
 821c850:	10800b04 	addi	r2,r2,44
 821c854:	e0bff615 	stw	r2,-40(fp)
 821c858:	00800044 	movi	r2,1
 821c85c:	e0bff70d 	sth	r2,-36(fp)
 821c860:	e0bff70b 	ldhu	r2,-36(fp)
 821c864:	1009883a 	mov	r4,r2
 821c868:	8219dbc0 	call	8219dbc <OSSemCreate>
 821c86c:	1007883a 	mov	r3,r2
 821c870:	e0bff617 	ldw	r2,-40(fp)
 821c874:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 821c878:	e0bff917 	ldw	r2,-28(fp)
 821c87c:	00c00044 	movi	r3,1
 821c880:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 821c884:	e0bff917 	ldw	r2,-28(fp)
 821c888:	10800017 	ldw	r2,0(r2)
 821c88c:	10800104 	addi	r2,r2,4
 821c890:	1007883a 	mov	r3,r2
 821c894:	e0bff917 	ldw	r2,-28(fp)
 821c898:	10800817 	ldw	r2,32(r2)
 821c89c:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 821c8a0:	e0bffa17 	ldw	r2,-24(fp)
 821c8a4:	e0fffb17 	ldw	r3,-20(fp)
 821c8a8:	d8000015 	stw	zero,0(sp)
 821c8ac:	e1fff917 	ldw	r7,-28(fp)
 821c8b0:	018208b4 	movhi	r6,2082
 821c8b4:	31b24704 	addi	r6,r6,-14052
 821c8b8:	180b883a 	mov	r5,r3
 821c8bc:	1009883a 	mov	r4,r2
 821c8c0:	823bfe00 	call	823bfe0 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 821c8c4:	e0bff917 	ldw	r2,-28(fp)
 821c8c8:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 821c8cc:	e0bff917 	ldw	r2,-28(fp)
 821c8d0:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 821c8d4:	d0e0b817 	ldw	r3,-32032(gp)
 821c8d8:	e1fff917 	ldw	r7,-28(fp)
 821c8dc:	018208b4 	movhi	r6,2082
 821c8e0:	31b2f004 	addi	r6,r6,-13376
 821c8e4:	180b883a 	mov	r5,r3
 821c8e8:	1009883a 	mov	r4,r2
 821c8ec:	823bad40 	call	823bad4 <alt_alarm_start>
 821c8f0:	1000040e 	bge	r2,zero,821c904 <altera_avalon_jtag_uart_init+0x130>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 821c8f4:	e0fff917 	ldw	r3,-28(fp)
 821c8f8:	00a00034 	movhi	r2,32768
 821c8fc:	10bfffc4 	addi	r2,r2,-1
 821c900:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 821c904:	0001883a 	nop
 821c908:	e037883a 	mov	sp,fp
 821c90c:	dfc00117 	ldw	ra,4(sp)
 821c910:	df000017 	ldw	fp,0(sp)
 821c914:	dec00204 	addi	sp,sp,8
 821c918:	f800283a 	ret

0821c91c <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 821c91c:	defff204 	addi	sp,sp,-56
 821c920:	dfc00d15 	stw	ra,52(sp)
 821c924:	df000c15 	stw	fp,48(sp)
 821c928:	df000c04 	addi	fp,sp,48
 821c92c:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 821c930:	e0bfff17 	ldw	r2,-4(fp)
 821c934:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
 821c938:	e0bff617 	ldw	r2,-40(fp)
 821c93c:	10800017 	ldw	r2,0(r2)
 821c940:	e0bff715 	stw	r2,-36(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 821c944:	e0bff717 	ldw	r2,-36(fp)
 821c948:	10800104 	addi	r2,r2,4
 821c94c:	10800037 	ldwio	r2,0(r2)
 821c950:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 821c954:	e0bff817 	ldw	r2,-32(fp)
 821c958:	1080c00c 	andi	r2,r2,768
 821c95c:	10009126 	beq	r2,zero,821cba4 <altera_avalon_jtag_uart_irq+0x288>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 821c960:	e0bff817 	ldw	r2,-32(fp)
 821c964:	1080400c 	andi	r2,r2,256
 821c968:	10004726 	beq	r2,zero,821ca88 <altera_avalon_jtag_uart_irq+0x16c>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 821c96c:	00800074 	movhi	r2,1
 821c970:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821c974:	e0bff617 	ldw	r2,-40(fp)
 821c978:	10800d17 	ldw	r2,52(r2)
 821c97c:	10800044 	addi	r2,r2,1
 821c980:	1081ffcc 	andi	r2,r2,2047
 821c984:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
 821c988:	e0bff617 	ldw	r2,-40(fp)
 821c98c:	10c00e17 	ldw	r3,56(r2)
 821c990:	e0bff917 	ldw	r2,-28(fp)
 821c994:	18802726 	beq	r3,r2,821ca34 <altera_avalon_jtag_uart_irq+0x118>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 821c998:	e0bff717 	ldw	r2,-36(fp)
 821c99c:	10800037 	ldwio	r2,0(r2)
 821c9a0:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 821c9a4:	e0bff417 	ldw	r2,-48(fp)
 821c9a8:	10a0000c 	andi	r2,r2,32768
 821c9ac:	10002326 	beq	r2,zero,821ca3c <altera_avalon_jtag_uart_irq+0x120>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 821c9b0:	e0bff617 	ldw	r2,-40(fp)
 821c9b4:	10800d17 	ldw	r2,52(r2)
 821c9b8:	e0fff417 	ldw	r3,-48(fp)
 821c9bc:	1809883a 	mov	r4,r3
 821c9c0:	e0fff617 	ldw	r3,-40(fp)
 821c9c4:	1885883a 	add	r2,r3,r2
 821c9c8:	10801104 	addi	r2,r2,68
 821c9cc:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821c9d0:	e0bff617 	ldw	r2,-40(fp)
 821c9d4:	10800d17 	ldw	r2,52(r2)
 821c9d8:	10800044 	addi	r2,r2,1
 821c9dc:	10c1ffcc 	andi	r3,r2,2047
 821c9e0:	e0bff617 	ldw	r2,-40(fp)
 821c9e4:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
 821c9e8:	e0bff617 	ldw	r2,-40(fp)
 821c9ec:	10800c17 	ldw	r2,48(r2)
 821c9f0:	e0bffb15 	stw	r2,-20(fp)
 821c9f4:	00800044 	movi	r2,1
 821c9f8:	e0bffc0d 	sth	r2,-16(fp)
 821c9fc:	00800044 	movi	r2,1
 821ca00:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 821ca04:	d0a06b43 	ldbu	r2,-32339(gp)
 821ca08:	10803fcc 	andi	r2,r2,255
 821ca0c:	103fd926 	beq	r2,zero,821c974 <altera_avalon_jtag_uart_irq+0x58>
  {
    OSFlagPost (group, flags, opt, &err);
 821ca10:	e0bffc0b 	ldhu	r2,-16(fp)
 821ca14:	e0fffc83 	ldbu	r3,-14(fp)
 821ca18:	e13ffdc4 	addi	r4,fp,-9
 821ca1c:	200f883a 	mov	r7,r4
 821ca20:	180d883a 	mov	r6,r3
 821ca24:	100b883a 	mov	r5,r2
 821ca28:	e13ffb17 	ldw	r4,-20(fp)
 821ca2c:	8217c840 	call	8217c84 <OSFlagPost>
      }
 821ca30:	003fd006 	br	821c974 <altera_avalon_jtag_uart_irq+0x58>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
 821ca34:	0001883a 	nop
 821ca38:	00000106 	br	821ca40 <altera_avalon_jtag_uart_irq+0x124>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
 821ca3c:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 821ca40:	e0bff417 	ldw	r2,-48(fp)
 821ca44:	10bfffec 	andhi	r2,r2,65535
 821ca48:	10000f26 	beq	r2,zero,821ca88 <altera_avalon_jtag_uart_irq+0x16c>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 821ca4c:	e0bff617 	ldw	r2,-40(fp)
 821ca50:	10c00817 	ldw	r3,32(r2)
 821ca54:	00bfff84 	movi	r2,-2
 821ca58:	1886703a 	and	r3,r3,r2
 821ca5c:	e0bff617 	ldw	r2,-40(fp)
 821ca60:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 821ca64:	e0bff717 	ldw	r2,-36(fp)
 821ca68:	10800104 	addi	r2,r2,4
 821ca6c:	1007883a 	mov	r3,r2
 821ca70:	e0bff617 	ldw	r2,-40(fp)
 821ca74:	10800817 	ldw	r2,32(r2)
 821ca78:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 821ca7c:	e0bff717 	ldw	r2,-36(fp)
 821ca80:	10800104 	addi	r2,r2,4
 821ca84:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 821ca88:	e0bff817 	ldw	r2,-32(fp)
 821ca8c:	1080800c 	andi	r2,r2,512
 821ca90:	103fac26 	beq	r2,zero,821c944 <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 821ca94:	e0bff817 	ldw	r2,-32(fp)
 821ca98:	1004d43a 	srli	r2,r2,16
 821ca9c:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 821caa0:	00002606 	br	821cb3c <altera_avalon_jtag_uart_irq+0x220>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 821caa4:	e0bff717 	ldw	r2,-36(fp)
 821caa8:	e0fff617 	ldw	r3,-40(fp)
 821caac:	18c01017 	ldw	r3,64(r3)
 821cab0:	e13ff617 	ldw	r4,-40(fp)
 821cab4:	20c7883a 	add	r3,r4,r3
 821cab8:	18c21104 	addi	r3,r3,2116
 821cabc:	18c00003 	ldbu	r3,0(r3)
 821cac0:	18c03fcc 	andi	r3,r3,255
 821cac4:	18c0201c 	xori	r3,r3,128
 821cac8:	18ffe004 	addi	r3,r3,-128
 821cacc:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821cad0:	e0bff617 	ldw	r2,-40(fp)
 821cad4:	10801017 	ldw	r2,64(r2)
 821cad8:	10800044 	addi	r2,r2,1
 821cadc:	10c1ffcc 	andi	r3,r2,2047
 821cae0:	e0bff617 	ldw	r2,-40(fp)
 821cae4:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
 821cae8:	e0bff617 	ldw	r2,-40(fp)
 821caec:	10800c17 	ldw	r2,48(r2)
 821caf0:	e0bffa15 	stw	r2,-24(fp)
 821caf4:	00800084 	movi	r2,2
 821caf8:	e0bffd0d 	sth	r2,-12(fp)
 821cafc:	00800044 	movi	r2,1
 821cb00:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 821cb04:	d0a06b43 	ldbu	r2,-32339(gp)
 821cb08:	10803fcc 	andi	r2,r2,255
 821cb0c:	10000826 	beq	r2,zero,821cb30 <altera_avalon_jtag_uart_irq+0x214>
  {
    OSFlagPost (group, flags, opt, &err);
 821cb10:	e0bffd0b 	ldhu	r2,-12(fp)
 821cb14:	e0fffd83 	ldbu	r3,-10(fp)
 821cb18:	e13ffe04 	addi	r4,fp,-8
 821cb1c:	200f883a 	mov	r7,r4
 821cb20:	180d883a 	mov	r6,r3
 821cb24:	100b883a 	mov	r5,r2
 821cb28:	e13ffa17 	ldw	r4,-24(fp)
 821cb2c:	8217c840 	call	8217c84 <OSFlagPost>

        space--;
 821cb30:	e0bff517 	ldw	r2,-44(fp)
 821cb34:	10bfffc4 	addi	r2,r2,-1
 821cb38:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 821cb3c:	e0bff517 	ldw	r2,-44(fp)
 821cb40:	10000526 	beq	r2,zero,821cb58 <altera_avalon_jtag_uart_irq+0x23c>
 821cb44:	e0bff617 	ldw	r2,-40(fp)
 821cb48:	10c01017 	ldw	r3,64(r2)
 821cb4c:	e0bff617 	ldw	r2,-40(fp)
 821cb50:	10800f17 	ldw	r2,60(r2)
 821cb54:	18bfd31e 	bne	r3,r2,821caa4 <altera_avalon_jtag_uart_irq+0x188>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 821cb58:	e0bff517 	ldw	r2,-44(fp)
 821cb5c:	103f7926 	beq	r2,zero,821c944 <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 821cb60:	e0bff617 	ldw	r2,-40(fp)
 821cb64:	10c00817 	ldw	r3,32(r2)
 821cb68:	00bfff44 	movi	r2,-3
 821cb6c:	1886703a 	and	r3,r3,r2
 821cb70:	e0bff617 	ldw	r2,-40(fp)
 821cb74:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 821cb78:	e0bff617 	ldw	r2,-40(fp)
 821cb7c:	10800017 	ldw	r2,0(r2)
 821cb80:	10800104 	addi	r2,r2,4
 821cb84:	1007883a 	mov	r3,r2
 821cb88:	e0bff617 	ldw	r2,-40(fp)
 821cb8c:	10800817 	ldw	r2,32(r2)
 821cb90:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 821cb94:	e0bff717 	ldw	r2,-36(fp)
 821cb98:	10800104 	addi	r2,r2,4
 821cb9c:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 821cba0:	003f6806 	br	821c944 <altera_avalon_jtag_uart_irq+0x28>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
 821cba4:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
 821cba8:	0001883a 	nop
 821cbac:	e037883a 	mov	sp,fp
 821cbb0:	dfc00117 	ldw	ra,4(sp)
 821cbb4:	df000017 	ldw	fp,0(sp)
 821cbb8:	dec00204 	addi	sp,sp,8
 821cbbc:	f800283a 	ret

0821cbc0 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 821cbc0:	defff904 	addi	sp,sp,-28
 821cbc4:	dfc00615 	stw	ra,24(sp)
 821cbc8:	df000515 	stw	fp,20(sp)
 821cbcc:	df000504 	addi	fp,sp,20
 821cbd0:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 821cbd4:	e0bfff17 	ldw	r2,-4(fp)
 821cbd8:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 821cbdc:	e0bffb17 	ldw	r2,-20(fp)
 821cbe0:	10800017 	ldw	r2,0(r2)
 821cbe4:	10800104 	addi	r2,r2,4
 821cbe8:	10800037 	ldwio	r2,0(r2)
 821cbec:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 821cbf0:	e0bffc17 	ldw	r2,-16(fp)
 821cbf4:	1081000c 	andi	r2,r2,1024
 821cbf8:	10000b26 	beq	r2,zero,821cc28 <altera_avalon_jtag_uart_timeout+0x68>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 821cbfc:	e0bffb17 	ldw	r2,-20(fp)
 821cc00:	10800017 	ldw	r2,0(r2)
 821cc04:	10800104 	addi	r2,r2,4
 821cc08:	1007883a 	mov	r3,r2
 821cc0c:	e0bffb17 	ldw	r2,-20(fp)
 821cc10:	10800817 	ldw	r2,32(r2)
 821cc14:	10810014 	ori	r2,r2,1024
 821cc18:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 821cc1c:	e0bffb17 	ldw	r2,-20(fp)
 821cc20:	10000915 	stw	zero,36(r2)
 821cc24:	00002106 	br	821ccac <altera_avalon_jtag_uart_timeout+0xec>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 821cc28:	e0bffb17 	ldw	r2,-20(fp)
 821cc2c:	10c00917 	ldw	r3,36(r2)
 821cc30:	00a00034 	movhi	r2,32768
 821cc34:	10bfff04 	addi	r2,r2,-4
 821cc38:	10c01c36 	bltu	r2,r3,821ccac <altera_avalon_jtag_uart_timeout+0xec>
    sp->host_inactive++;
 821cc3c:	e0bffb17 	ldw	r2,-20(fp)
 821cc40:	10800917 	ldw	r2,36(r2)
 821cc44:	10c00044 	addi	r3,r2,1
 821cc48:	e0bffb17 	ldw	r2,-20(fp)
 821cc4c:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
 821cc50:	e0bffb17 	ldw	r2,-20(fp)
 821cc54:	10c00917 	ldw	r3,36(r2)
 821cc58:	e0bffb17 	ldw	r2,-20(fp)
 821cc5c:	10800117 	ldw	r2,4(r2)
 821cc60:	18801236 	bltu	r3,r2,821ccac <altera_avalon_jtag_uart_timeout+0xec>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
 821cc64:	e0bffb17 	ldw	r2,-20(fp)
 821cc68:	10800c17 	ldw	r2,48(r2)
 821cc6c:	e0bffd15 	stw	r2,-12(fp)
 821cc70:	00800104 	movi	r2,4
 821cc74:	e0bffe0d 	sth	r2,-8(fp)
 821cc78:	00800044 	movi	r2,1
 821cc7c:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 821cc80:	d0a06b43 	ldbu	r2,-32339(gp)
 821cc84:	10803fcc 	andi	r2,r2,255
 821cc88:	10000826 	beq	r2,zero,821ccac <altera_avalon_jtag_uart_timeout+0xec>
  {
    OSFlagPost (group, flags, opt, &err);
 821cc8c:	e0bffe0b 	ldhu	r2,-8(fp)
 821cc90:	e0fffe83 	ldbu	r3,-6(fp)
 821cc94:	e13ffec4 	addi	r4,fp,-5
 821cc98:	200f883a 	mov	r7,r4
 821cc9c:	180d883a 	mov	r6,r3
 821cca0:	100b883a 	mov	r5,r2
 821cca4:	e13ffd17 	ldw	r4,-12(fp)
 821cca8:	8217c840 	call	8217c84 <OSFlagPost>
 821ccac:	d0a0b817 	ldw	r2,-32032(gp)
    }
  }

  return alt_ticks_per_second();
}
 821ccb0:	e037883a 	mov	sp,fp
 821ccb4:	dfc00117 	ldw	ra,4(sp)
 821ccb8:	df000017 	ldw	fp,0(sp)
 821ccbc:	dec00204 	addi	sp,sp,8
 821ccc0:	f800283a 	ret

0821ccc4 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 821ccc4:	defffd04 	addi	sp,sp,-12
 821ccc8:	df000215 	stw	fp,8(sp)
 821cccc:	df000204 	addi	fp,sp,8
 821ccd0:	e13ffe15 	stw	r4,-8(fp)
 821ccd4:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 821ccd8:	00000506 	br	821ccf0 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 821ccdc:	e0bfff17 	ldw	r2,-4(fp)
 821cce0:	1090000c 	andi	r2,r2,16384
 821cce4:	10000226 	beq	r2,zero,821ccf0 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 821cce8:	00bffd44 	movi	r2,-11
 821ccec:	00000b06 	br	821cd1c <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 821ccf0:	e0bffe17 	ldw	r2,-8(fp)
 821ccf4:	10c01017 	ldw	r3,64(r2)
 821ccf8:	e0bffe17 	ldw	r2,-8(fp)
 821ccfc:	10800f17 	ldw	r2,60(r2)
 821cd00:	18800526 	beq	r3,r2,821cd18 <altera_avalon_jtag_uart_close+0x54>
 821cd04:	e0bffe17 	ldw	r2,-8(fp)
 821cd08:	10c00917 	ldw	r3,36(r2)
 821cd0c:	e0bffe17 	ldw	r2,-8(fp)
 821cd10:	10800117 	ldw	r2,4(r2)
 821cd14:	18bff136 	bltu	r3,r2,821ccdc <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 821cd18:	0005883a 	mov	r2,zero
}
 821cd1c:	e037883a 	mov	sp,fp
 821cd20:	df000017 	ldw	fp,0(sp)
 821cd24:	dec00104 	addi	sp,sp,4
 821cd28:	f800283a 	ret

0821cd2c <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 821cd2c:	defffa04 	addi	sp,sp,-24
 821cd30:	df000515 	stw	fp,20(sp)
 821cd34:	df000504 	addi	fp,sp,20
 821cd38:	e13ffd15 	stw	r4,-12(fp)
 821cd3c:	e17ffe15 	stw	r5,-8(fp)
 821cd40:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
 821cd44:	00bff9c4 	movi	r2,-25
 821cd48:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
 821cd4c:	e0bffe17 	ldw	r2,-8(fp)
 821cd50:	10da8060 	cmpeqi	r3,r2,27137
 821cd54:	1800031e 	bne	r3,zero,821cd64 <altera_avalon_jtag_uart_ioctl+0x38>
 821cd58:	109a80a0 	cmpeqi	r2,r2,27138
 821cd5c:	1000181e 	bne	r2,zero,821cdc0 <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
 821cd60:	00002906 	br	821ce08 <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 821cd64:	e0bffd17 	ldw	r2,-12(fp)
 821cd68:	10c00117 	ldw	r3,4(r2)
 821cd6c:	00a00034 	movhi	r2,32768
 821cd70:	10bfffc4 	addi	r2,r2,-1
 821cd74:	18802126 	beq	r3,r2,821cdfc <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
 821cd78:	e0bfff17 	ldw	r2,-4(fp)
 821cd7c:	10800017 	ldw	r2,0(r2)
 821cd80:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 821cd84:	e0bffc17 	ldw	r2,-16(fp)
 821cd88:	10800090 	cmplti	r2,r2,2
 821cd8c:	1000061e 	bne	r2,zero,821cda8 <altera_avalon_jtag_uart_ioctl+0x7c>
 821cd90:	e0fffc17 	ldw	r3,-16(fp)
 821cd94:	00a00034 	movhi	r2,32768
 821cd98:	10bfffc4 	addi	r2,r2,-1
 821cd9c:	18800226 	beq	r3,r2,821cda8 <altera_avalon_jtag_uart_ioctl+0x7c>
 821cda0:	e0bffc17 	ldw	r2,-16(fp)
 821cda4:	00000206 	br	821cdb0 <altera_avalon_jtag_uart_ioctl+0x84>
 821cda8:	00a00034 	movhi	r2,32768
 821cdac:	10bfff84 	addi	r2,r2,-2
 821cdb0:	e0fffd17 	ldw	r3,-12(fp)
 821cdb4:	18800115 	stw	r2,4(r3)
      rc = 0;
 821cdb8:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 821cdbc:	00000f06 	br	821cdfc <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 821cdc0:	e0bffd17 	ldw	r2,-12(fp)
 821cdc4:	10c00117 	ldw	r3,4(r2)
 821cdc8:	00a00034 	movhi	r2,32768
 821cdcc:	10bfffc4 	addi	r2,r2,-1
 821cdd0:	18800c26 	beq	r3,r2,821ce04 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 821cdd4:	e0bffd17 	ldw	r2,-12(fp)
 821cdd8:	10c00917 	ldw	r3,36(r2)
 821cddc:	e0bffd17 	ldw	r2,-12(fp)
 821cde0:	10800117 	ldw	r2,4(r2)
 821cde4:	1885803a 	cmpltu	r2,r3,r2
 821cde8:	10c03fcc 	andi	r3,r2,255
 821cdec:	e0bfff17 	ldw	r2,-4(fp)
 821cdf0:	10c00015 	stw	r3,0(r2)
      rc = 0;
 821cdf4:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 821cdf8:	00000206 	br	821ce04 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
 821cdfc:	0001883a 	nop
 821ce00:	00000106 	br	821ce08 <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
 821ce04:	0001883a 	nop

  default:
    break;
  }

  return rc;
 821ce08:	e0bffb17 	ldw	r2,-20(fp)
}
 821ce0c:	e037883a 	mov	sp,fp
 821ce10:	df000017 	ldw	fp,0(sp)
 821ce14:	dec00104 	addi	sp,sp,4
 821ce18:	f800283a 	ret

0821ce1c <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 821ce1c:	deffed04 	addi	sp,sp,-76
 821ce20:	dfc01215 	stw	ra,72(sp)
 821ce24:	df001115 	stw	fp,68(sp)
 821ce28:	df001104 	addi	fp,sp,68
 821ce2c:	e13ffc15 	stw	r4,-16(fp)
 821ce30:	e17ffd15 	stw	r5,-12(fp)
 821ce34:	e1bffe15 	stw	r6,-8(fp)
 821ce38:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
 821ce3c:	e0bffd17 	ldw	r2,-12(fp)
 821ce40:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
 821ce44:	e0bffc17 	ldw	r2,-16(fp)
 821ce48:	10800a17 	ldw	r2,40(r2)
 821ce4c:	e0bff815 	stw	r2,-32(fp)
 821ce50:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 821ce54:	e0bff90b 	ldhu	r2,-28(fp)
 821ce58:	e0fffb04 	addi	r3,fp,-20
 821ce5c:	180d883a 	mov	r6,r3
 821ce60:	100b883a 	mov	r5,r2
 821ce64:	e13ff817 	ldw	r4,-32(fp)
 821ce68:	821a0d40 	call	821a0d4 <OSSemPend>

  while (space > 0)
 821ce6c:	00006106 	br	821cff4 <altera_avalon_jtag_uart_read+0x1d8>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 821ce70:	e0bffc17 	ldw	r2,-16(fp)
 821ce74:	10800d17 	ldw	r2,52(r2)
 821ce78:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
 821ce7c:	e0bffc17 	ldw	r2,-16(fp)
 821ce80:	10800e17 	ldw	r2,56(r2)
 821ce84:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
 821ce88:	e0fff317 	ldw	r3,-52(fp)
 821ce8c:	e0bff417 	ldw	r2,-48(fp)
 821ce90:	18800536 	bltu	r3,r2,821cea8 <altera_avalon_jtag_uart_read+0x8c>
        n = in - out;
 821ce94:	e0fff317 	ldw	r3,-52(fp)
 821ce98:	e0bff417 	ldw	r2,-48(fp)
 821ce9c:	1885c83a 	sub	r2,r3,r2
 821cea0:	e0bff115 	stw	r2,-60(fp)
 821cea4:	00000406 	br	821ceb8 <altera_avalon_jtag_uart_read+0x9c>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 821cea8:	00c20004 	movi	r3,2048
 821ceac:	e0bff417 	ldw	r2,-48(fp)
 821ceb0:	1885c83a 	sub	r2,r3,r2
 821ceb4:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
 821ceb8:	e0bff117 	ldw	r2,-60(fp)
 821cebc:	10001e26 	beq	r2,zero,821cf38 <altera_avalon_jtag_uart_read+0x11c>
        break; /* No more data available */

      if (n > space)
 821cec0:	e0fffe17 	ldw	r3,-8(fp)
 821cec4:	e0bff117 	ldw	r2,-60(fp)
 821cec8:	1880022e 	bgeu	r3,r2,821ced4 <altera_avalon_jtag_uart_read+0xb8>
        n = space;
 821cecc:	e0bffe17 	ldw	r2,-8(fp)
 821ced0:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 821ced4:	e0bffc17 	ldw	r2,-16(fp)
 821ced8:	10c01104 	addi	r3,r2,68
 821cedc:	e0bff417 	ldw	r2,-48(fp)
 821cee0:	1885883a 	add	r2,r3,r2
 821cee4:	e1bff117 	ldw	r6,-60(fp)
 821cee8:	100b883a 	mov	r5,r2
 821ceec:	e13ff017 	ldw	r4,-64(fp)
 821cef0:	8202f100 	call	8202f10 <memcpy>
      ptr   += n;
 821cef4:	e0fff017 	ldw	r3,-64(fp)
 821cef8:	e0bff117 	ldw	r2,-60(fp)
 821cefc:	1885883a 	add	r2,r3,r2
 821cf00:	e0bff015 	stw	r2,-64(fp)
      space -= n;
 821cf04:	e0fffe17 	ldw	r3,-8(fp)
 821cf08:	e0bff117 	ldw	r2,-60(fp)
 821cf0c:	1885c83a 	sub	r2,r3,r2
 821cf10:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821cf14:	e0fff417 	ldw	r3,-48(fp)
 821cf18:	e0bff117 	ldw	r2,-60(fp)
 821cf1c:	1885883a 	add	r2,r3,r2
 821cf20:	10c1ffcc 	andi	r3,r2,2047
 821cf24:	e0bffc17 	ldw	r2,-16(fp)
 821cf28:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
 821cf2c:	e0bffe17 	ldw	r2,-8(fp)
 821cf30:	00bfcf16 	blt	zero,r2,821ce70 <altera_avalon_jtag_uart_read+0x54>
 821cf34:	00000106 	br	821cf3c <altera_avalon_jtag_uart_read+0x120>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
 821cf38:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
 821cf3c:	e0fff017 	ldw	r3,-64(fp)
 821cf40:	e0bffd17 	ldw	r2,-12(fp)
 821cf44:	18802e1e 	bne	r3,r2,821d000 <altera_avalon_jtag_uart_read+0x1e4>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 821cf48:	e0bfff17 	ldw	r2,-4(fp)
 821cf4c:	1090000c 	andi	r2,r2,16384
 821cf50:	10002d1e 	bne	r2,zero,821d008 <altera_avalon_jtag_uart_read+0x1ec>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
 821cf54:	d0a06b43 	ldbu	r2,-32339(gp)
 821cf58:	10803fcc 	andi	r2,r2,255
 821cf5c:	10800058 	cmpnei	r2,r2,1
 821cf60:	1000161e 	bne	r2,zero,821cfbc <altera_avalon_jtag_uart_read+0x1a0>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
 821cf64:	e0bffc17 	ldw	r2,-16(fp)
 821cf68:	10800c17 	ldw	r2,48(r2)
 821cf6c:	e0bff215 	stw	r2,-56(fp)
 821cf70:	00800144 	movi	r2,5
 821cf74:	e0bff98d 	sth	r2,-26(fp)
 821cf78:	00bfe0c4 	movi	r2,-125
 821cf7c:	e0bffa05 	stb	r2,-24(fp)
 821cf80:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 821cf84:	d0a06b43 	ldbu	r2,-32339(gp)
 821cf88:	10803fcc 	andi	r2,r2,255
 821cf8c:	10001526 	beq	r2,zero,821cfe4 <altera_avalon_jtag_uart_read+0x1c8>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 821cf90:	e0fff98b 	ldhu	r3,-26(fp)
 821cf94:	e13ffa03 	ldbu	r4,-24(fp)
 821cf98:	e17ffa8b 	ldhu	r5,-22(fp)
 821cf9c:	e0bffb44 	addi	r2,fp,-19
 821cfa0:	d8800015 	stw	r2,0(sp)
 821cfa4:	280f883a 	mov	r7,r5
 821cfa8:	200d883a 	mov	r6,r4
 821cfac:	180b883a 	mov	r5,r3
 821cfb0:	e13ff217 	ldw	r4,-56(fp)
 821cfb4:	821766c0 	call	821766c <OSFlagPend>
 821cfb8:	00000a06 	br	821cfe4 <altera_avalon_jtag_uart_read+0x1c8>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 821cfbc:	0001883a 	nop
 821cfc0:	e0bffc17 	ldw	r2,-16(fp)
 821cfc4:	10c00d17 	ldw	r3,52(r2)
 821cfc8:	e0bff317 	ldw	r2,-52(fp)
 821cfcc:	1880051e 	bne	r3,r2,821cfe4 <altera_avalon_jtag_uart_read+0x1c8>
 821cfd0:	e0bffc17 	ldw	r2,-16(fp)
 821cfd4:	10c00917 	ldw	r3,36(r2)
 821cfd8:	e0bffc17 	ldw	r2,-16(fp)
 821cfdc:	10800117 	ldw	r2,4(r2)
 821cfe0:	18bff736 	bltu	r3,r2,821cfc0 <altera_avalon_jtag_uart_read+0x1a4>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 821cfe4:	e0bffc17 	ldw	r2,-16(fp)
 821cfe8:	10c00d17 	ldw	r3,52(r2)
 821cfec:	e0bff317 	ldw	r2,-52(fp)
 821cff0:	18800726 	beq	r3,r2,821d010 <altera_avalon_jtag_uart_read+0x1f4>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 821cff4:	e0bffe17 	ldw	r2,-8(fp)
 821cff8:	00bf9d16 	blt	zero,r2,821ce70 <altera_avalon_jtag_uart_read+0x54>
 821cffc:	00000506 	br	821d014 <altera_avalon_jtag_uart_read+0x1f8>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
 821d000:	0001883a 	nop
 821d004:	00000306 	br	821d014 <altera_avalon_jtag_uart_read+0x1f8>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
 821d008:	0001883a 	nop
 821d00c:	00000106 	br	821d014 <altera_avalon_jtag_uart_read+0x1f8>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
 821d010:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
 821d014:	e0bffc17 	ldw	r2,-16(fp)
 821d018:	10800a17 	ldw	r2,40(r2)
 821d01c:	1009883a 	mov	r4,r2
 821d020:	821a44c0 	call	821a44c <OSSemPost>

  if (ptr != buffer)
 821d024:	e0fff017 	ldw	r3,-64(fp)
 821d028:	e0bffd17 	ldw	r2,-12(fp)
 821d02c:	18801826 	beq	r3,r2,821d090 <altera_avalon_jtag_uart_read+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821d030:	0005303a 	rdctl	r2,status
 821d034:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821d038:	e0fff717 	ldw	r3,-36(fp)
 821d03c:	00bfff84 	movi	r2,-2
 821d040:	1884703a 	and	r2,r3,r2
 821d044:	1001703a 	wrctl	status,r2
  
  return context;
 821d048:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 821d04c:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 821d050:	e0bffc17 	ldw	r2,-16(fp)
 821d054:	10800817 	ldw	r2,32(r2)
 821d058:	10c00054 	ori	r3,r2,1
 821d05c:	e0bffc17 	ldw	r2,-16(fp)
 821d060:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 821d064:	e0bffc17 	ldw	r2,-16(fp)
 821d068:	10800017 	ldw	r2,0(r2)
 821d06c:	10800104 	addi	r2,r2,4
 821d070:	1007883a 	mov	r3,r2
 821d074:	e0bffc17 	ldw	r2,-16(fp)
 821d078:	10800817 	ldw	r2,32(r2)
 821d07c:	18800035 	stwio	r2,0(r3)
 821d080:	e0bff617 	ldw	r2,-40(fp)
 821d084:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821d088:	e0bff517 	ldw	r2,-44(fp)
 821d08c:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 821d090:	e0fff017 	ldw	r3,-64(fp)
 821d094:	e0bffd17 	ldw	r2,-12(fp)
 821d098:	18800426 	beq	r3,r2,821d0ac <altera_avalon_jtag_uart_read+0x290>
    return ptr - buffer;
 821d09c:	e0fff017 	ldw	r3,-64(fp)
 821d0a0:	e0bffd17 	ldw	r2,-12(fp)
 821d0a4:	1885c83a 	sub	r2,r3,r2
 821d0a8:	00000606 	br	821d0c4 <altera_avalon_jtag_uart_read+0x2a8>
  else if (flags & O_NONBLOCK)
 821d0ac:	e0bfff17 	ldw	r2,-4(fp)
 821d0b0:	1090000c 	andi	r2,r2,16384
 821d0b4:	10000226 	beq	r2,zero,821d0c0 <altera_avalon_jtag_uart_read+0x2a4>
    return -EWOULDBLOCK;
 821d0b8:	00bffd44 	movi	r2,-11
 821d0bc:	00000106 	br	821d0c4 <altera_avalon_jtag_uart_read+0x2a8>
  else
    return -EIO;
 821d0c0:	00bffec4 	movi	r2,-5
}
 821d0c4:	e037883a 	mov	sp,fp
 821d0c8:	dfc00117 	ldw	ra,4(sp)
 821d0cc:	df000017 	ldw	fp,0(sp)
 821d0d0:	dec00204 	addi	sp,sp,8
 821d0d4:	f800283a 	ret

0821d0d8 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 821d0d8:	deffed04 	addi	sp,sp,-76
 821d0dc:	dfc01215 	stw	ra,72(sp)
 821d0e0:	df001115 	stw	fp,68(sp)
 821d0e4:	df001104 	addi	fp,sp,68
 821d0e8:	e13ffc15 	stw	r4,-16(fp)
 821d0ec:	e17ffd15 	stw	r5,-12(fp)
 821d0f0:	e1bffe15 	stw	r6,-8(fp)
 821d0f4:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 821d0f8:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 821d0fc:	e0bffd17 	ldw	r2,-12(fp)
 821d100:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
 821d104:	e0bffc17 	ldw	r2,-16(fp)
 821d108:	10800b17 	ldw	r2,44(r2)
 821d10c:	e0bff815 	stw	r2,-32(fp)
 821d110:	e03ff90d 	sth	zero,-28(fp)
 821d114:	e0bff90b 	ldhu	r2,-28(fp)
 821d118:	e0fffb44 	addi	r3,fp,-19
 821d11c:	180d883a 	mov	r6,r3
 821d120:	100b883a 	mov	r5,r2
 821d124:	e13ff817 	ldw	r4,-32(fp)
 821d128:	821a0d40 	call	821a0d4 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 821d12c:	00003706 	br	821d20c <altera_avalon_jtag_uart_write+0x134>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 821d130:	e0bffc17 	ldw	r2,-16(fp)
 821d134:	10800f17 	ldw	r2,60(r2)
 821d138:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
 821d13c:	e0bffc17 	ldw	r2,-16(fp)
 821d140:	10801017 	ldw	r2,64(r2)
 821d144:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
 821d148:	e0fff417 	ldw	r3,-48(fp)
 821d14c:	e0bff017 	ldw	r2,-64(fp)
 821d150:	1880062e 	bgeu	r3,r2,821d16c <altera_avalon_jtag_uart_write+0x94>
        n = out - 1 - in;
 821d154:	e0fff017 	ldw	r3,-64(fp)
 821d158:	e0bff417 	ldw	r2,-48(fp)
 821d15c:	1885c83a 	sub	r2,r3,r2
 821d160:	10bfffc4 	addi	r2,r2,-1
 821d164:	e0bff115 	stw	r2,-60(fp)
 821d168:	00000b06 	br	821d198 <altera_avalon_jtag_uart_write+0xc0>
      else if (out > 0)
 821d16c:	e0bff017 	ldw	r2,-64(fp)
 821d170:	10000526 	beq	r2,zero,821d188 <altera_avalon_jtag_uart_write+0xb0>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 821d174:	00c20004 	movi	r3,2048
 821d178:	e0bff417 	ldw	r2,-48(fp)
 821d17c:	1885c83a 	sub	r2,r3,r2
 821d180:	e0bff115 	stw	r2,-60(fp)
 821d184:	00000406 	br	821d198 <altera_avalon_jtag_uart_write+0xc0>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 821d188:	00c1ffc4 	movi	r3,2047
 821d18c:	e0bff417 	ldw	r2,-48(fp)
 821d190:	1885c83a 	sub	r2,r3,r2
 821d194:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
 821d198:	e0bff117 	ldw	r2,-60(fp)
 821d19c:	10001e26 	beq	r2,zero,821d218 <altera_avalon_jtag_uart_write+0x140>
        break;

      if (n > count)
 821d1a0:	e0fffe17 	ldw	r3,-8(fp)
 821d1a4:	e0bff117 	ldw	r2,-60(fp)
 821d1a8:	1880022e 	bgeu	r3,r2,821d1b4 <altera_avalon_jtag_uart_write+0xdc>
        n = count;
 821d1ac:	e0bffe17 	ldw	r2,-8(fp)
 821d1b0:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 821d1b4:	e0bffc17 	ldw	r2,-16(fp)
 821d1b8:	10c21104 	addi	r3,r2,2116
 821d1bc:	e0bff417 	ldw	r2,-48(fp)
 821d1c0:	1885883a 	add	r2,r3,r2
 821d1c4:	e1bff117 	ldw	r6,-60(fp)
 821d1c8:	e17ffd17 	ldw	r5,-12(fp)
 821d1cc:	1009883a 	mov	r4,r2
 821d1d0:	8202f100 	call	8202f10 <memcpy>
      ptr   += n;
 821d1d4:	e0fffd17 	ldw	r3,-12(fp)
 821d1d8:	e0bff117 	ldw	r2,-60(fp)
 821d1dc:	1885883a 	add	r2,r3,r2
 821d1e0:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
 821d1e4:	e0fffe17 	ldw	r3,-8(fp)
 821d1e8:	e0bff117 	ldw	r2,-60(fp)
 821d1ec:	1885c83a 	sub	r2,r3,r2
 821d1f0:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821d1f4:	e0fff417 	ldw	r3,-48(fp)
 821d1f8:	e0bff117 	ldw	r2,-60(fp)
 821d1fc:	1885883a 	add	r2,r3,r2
 821d200:	10c1ffcc 	andi	r3,r2,2047
 821d204:	e0bffc17 	ldw	r2,-16(fp)
 821d208:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 821d20c:	e0bffe17 	ldw	r2,-8(fp)
 821d210:	00bfc716 	blt	zero,r2,821d130 <altera_avalon_jtag_uart_write+0x58>
 821d214:	00000106 	br	821d21c <altera_avalon_jtag_uart_write+0x144>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
 821d218:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821d21c:	0005303a 	rdctl	r2,status
 821d220:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821d224:	e0fff717 	ldw	r3,-36(fp)
 821d228:	00bfff84 	movi	r2,-2
 821d22c:	1884703a 	and	r2,r3,r2
 821d230:	1001703a 	wrctl	status,r2
  
  return context;
 821d234:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 821d238:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 821d23c:	e0bffc17 	ldw	r2,-16(fp)
 821d240:	10800817 	ldw	r2,32(r2)
 821d244:	10c00094 	ori	r3,r2,2
 821d248:	e0bffc17 	ldw	r2,-16(fp)
 821d24c:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 821d250:	e0bffc17 	ldw	r2,-16(fp)
 821d254:	10800017 	ldw	r2,0(r2)
 821d258:	10800104 	addi	r2,r2,4
 821d25c:	1007883a 	mov	r3,r2
 821d260:	e0bffc17 	ldw	r2,-16(fp)
 821d264:	10800817 	ldw	r2,32(r2)
 821d268:	18800035 	stwio	r2,0(r3)
 821d26c:	e0bff617 	ldw	r2,-40(fp)
 821d270:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821d274:	e0bff317 	ldw	r2,-52(fp)
 821d278:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 821d27c:	e0bffe17 	ldw	r2,-8(fp)
 821d280:	00802a0e 	bge	zero,r2,821d32c <altera_avalon_jtag_uart_write+0x254>
    {
      if (flags & O_NONBLOCK)
 821d284:	e0bfff17 	ldw	r2,-4(fp)
 821d288:	1090000c 	andi	r2,r2,16384
 821d28c:	10002a1e 	bne	r2,zero,821d338 <altera_avalon_jtag_uart_write+0x260>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
 821d290:	d0a06b43 	ldbu	r2,-32339(gp)
 821d294:	10803fcc 	andi	r2,r2,255
 821d298:	10800058 	cmpnei	r2,r2,1
 821d29c:	1000161e 	bne	r2,zero,821d2f8 <altera_avalon_jtag_uart_write+0x220>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
 821d2a0:	e0bffc17 	ldw	r2,-16(fp)
 821d2a4:	10800c17 	ldw	r2,48(r2)
 821d2a8:	e0bff515 	stw	r2,-44(fp)
 821d2ac:	00800184 	movi	r2,6
 821d2b0:	e0bff98d 	sth	r2,-26(fp)
 821d2b4:	00bfe0c4 	movi	r2,-125
 821d2b8:	e0bffa05 	stb	r2,-24(fp)
 821d2bc:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 821d2c0:	d0a06b43 	ldbu	r2,-32339(gp)
 821d2c4:	10803fcc 	andi	r2,r2,255
 821d2c8:	10001526 	beq	r2,zero,821d320 <altera_avalon_jtag_uart_write+0x248>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 821d2cc:	e0fff98b 	ldhu	r3,-26(fp)
 821d2d0:	e13ffa03 	ldbu	r4,-24(fp)
 821d2d4:	e17ffa8b 	ldhu	r5,-22(fp)
 821d2d8:	e0bffb04 	addi	r2,fp,-20
 821d2dc:	d8800015 	stw	r2,0(sp)
 821d2e0:	280f883a 	mov	r7,r5
 821d2e4:	200d883a 	mov	r6,r4
 821d2e8:	180b883a 	mov	r5,r3
 821d2ec:	e13ff517 	ldw	r4,-44(fp)
 821d2f0:	821766c0 	call	821766c <OSFlagPend>
 821d2f4:	00000a06 	br	821d320 <altera_avalon_jtag_uart_write+0x248>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 821d2f8:	0001883a 	nop
 821d2fc:	e0bffc17 	ldw	r2,-16(fp)
 821d300:	10c01017 	ldw	r3,64(r2)
 821d304:	e0bff017 	ldw	r2,-64(fp)
 821d308:	1880051e 	bne	r3,r2,821d320 <altera_avalon_jtag_uart_write+0x248>
 821d30c:	e0bffc17 	ldw	r2,-16(fp)
 821d310:	10c00917 	ldw	r3,36(r2)
 821d314:	e0bffc17 	ldw	r2,-16(fp)
 821d318:	10800117 	ldw	r2,4(r2)
 821d31c:	18bff736 	bltu	r3,r2,821d2fc <altera_avalon_jtag_uart_write+0x224>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 821d320:	e0bffc17 	ldw	r2,-16(fp)
 821d324:	10800917 	ldw	r2,36(r2)
 821d328:	1000051e 	bne	r2,zero,821d340 <altera_avalon_jtag_uart_write+0x268>
         break;
    }
  }
  while (count > 0);
 821d32c:	e0bffe17 	ldw	r2,-8(fp)
 821d330:	00bfb616 	blt	zero,r2,821d20c <altera_avalon_jtag_uart_write+0x134>
 821d334:	00000306 	br	821d344 <altera_avalon_jtag_uart_write+0x26c>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
 821d338:	0001883a 	nop
 821d33c:	00000106 	br	821d344 <altera_avalon_jtag_uart_write+0x26c>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
 821d340:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
 821d344:	e0bffc17 	ldw	r2,-16(fp)
 821d348:	10800b17 	ldw	r2,44(r2)
 821d34c:	1009883a 	mov	r4,r2
 821d350:	821a44c0 	call	821a44c <OSSemPost>

  if (ptr != start)
 821d354:	e0fffd17 	ldw	r3,-12(fp)
 821d358:	e0bff217 	ldw	r2,-56(fp)
 821d35c:	18800426 	beq	r3,r2,821d370 <altera_avalon_jtag_uart_write+0x298>
    return ptr - start;
 821d360:	e0fffd17 	ldw	r3,-12(fp)
 821d364:	e0bff217 	ldw	r2,-56(fp)
 821d368:	1885c83a 	sub	r2,r3,r2
 821d36c:	00000606 	br	821d388 <altera_avalon_jtag_uart_write+0x2b0>
  else if (flags & O_NONBLOCK)
 821d370:	e0bfff17 	ldw	r2,-4(fp)
 821d374:	1090000c 	andi	r2,r2,16384
 821d378:	10000226 	beq	r2,zero,821d384 <altera_avalon_jtag_uart_write+0x2ac>
    return -EWOULDBLOCK;
 821d37c:	00bffd44 	movi	r2,-11
 821d380:	00000106 	br	821d388 <altera_avalon_jtag_uart_write+0x2b0>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 821d384:	00bffec4 	movi	r2,-5
}
 821d388:	e037883a 	mov	sp,fp
 821d38c:	dfc00117 	ldw	ra,4(sp)
 821d390:	df000017 	ldw	fp,0(sp)
 821d394:	dec00204 	addi	sp,sp,8
 821d398:	f800283a 	ret

0821d39c <lcd_write_command>:

/* --------------------------------------------------------------------- */

static void lcd_write_command(altera_avalon_lcd_16207_state* sp, 
  unsigned char command)
{
 821d39c:	defffa04 	addi	sp,sp,-24
 821d3a0:	dfc00515 	stw	ra,20(sp)
 821d3a4:	df000415 	stw	fp,16(sp)
 821d3a8:	df000404 	addi	fp,sp,16
 821d3ac:	e13ffe15 	stw	r4,-8(fp)
 821d3b0:	2805883a 	mov	r2,r5
 821d3b4:	e0bfff05 	stb	r2,-4(fp)
  unsigned int base = sp->base;
 821d3b8:	e0bffe17 	ldw	r2,-8(fp)
 821d3bc:	10800017 	ldw	r2,0(r2)
 821d3c0:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 821d3c4:	008003f4 	movhi	r2,15
 821d3c8:	10909004 	addi	r2,r2,16960
 821d3cc:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 821d3d0:	e0bffe17 	ldw	r2,-8(fp)
 821d3d4:	10800803 	ldbu	r2,32(r2)
 821d3d8:	10803fcc 	andi	r2,r2,255
 821d3dc:	1080201c 	xori	r2,r2,128
 821d3e0:	10bfe004 	addi	r2,r2,-128
 821d3e4:	1000151e 	bne	r2,zero,821d43c <lcd_write_command+0xa0>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 821d3e8:	00000906 	br	821d410 <lcd_write_command+0x74>
    if (--i == 0)
 821d3ec:	e0bffc17 	ldw	r2,-16(fp)
 821d3f0:	10bfffc4 	addi	r2,r2,-1
 821d3f4:	e0bffc15 	stw	r2,-16(fp)
 821d3f8:	e0bffc17 	ldw	r2,-16(fp)
 821d3fc:	1000041e 	bne	r2,zero,821d410 <lcd_write_command+0x74>
    {
      sp->broken = 1;
 821d400:	e0bffe17 	ldw	r2,-8(fp)
 821d404:	00c00044 	movi	r3,1
 821d408:	10c00805 	stb	r3,32(r2)
      return;
 821d40c:	00000c06 	br	821d440 <lcd_write_command+0xa4>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 821d410:	e0bffd17 	ldw	r2,-12(fp)
 821d414:	10800104 	addi	r2,r2,4
 821d418:	10800037 	ldwio	r2,0(r2)
 821d41c:	1080200c 	andi	r2,r2,128
 821d420:	103ff21e 	bne	r2,zero,821d3ec <lcd_write_command+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 821d424:	01001904 	movi	r4,100
 821d428:	823ca240 	call	823ca24 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, command);
 821d42c:	e0bffd17 	ldw	r2,-12(fp)
 821d430:	e0ffff03 	ldbu	r3,-4(fp)
 821d434:	10c00035 	stwio	r3,0(r2)
 821d438:	00000106 	br	821d440 <lcd_write_command+0xa4>
   */
  int i = 1000000;

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;
 821d43c:	0001883a 	nop
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);

  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, command);
}
 821d440:	e037883a 	mov	sp,fp
 821d444:	dfc00117 	ldw	ra,4(sp)
 821d448:	df000017 	ldw	fp,0(sp)
 821d44c:	dec00204 	addi	sp,sp,8
 821d450:	f800283a 	ret

0821d454 <lcd_write_data>:

/* --------------------------------------------------------------------- */

static void lcd_write_data(altera_avalon_lcd_16207_state* sp, 
  unsigned char data)
{
 821d454:	defffa04 	addi	sp,sp,-24
 821d458:	dfc00515 	stw	ra,20(sp)
 821d45c:	df000415 	stw	fp,16(sp)
 821d460:	df000404 	addi	fp,sp,16
 821d464:	e13ffe15 	stw	r4,-8(fp)
 821d468:	2805883a 	mov	r2,r5
 821d46c:	e0bfff05 	stb	r2,-4(fp)
  unsigned int base = sp->base;
 821d470:	e0bffe17 	ldw	r2,-8(fp)
 821d474:	10800017 	ldw	r2,0(r2)
 821d478:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 821d47c:	008003f4 	movhi	r2,15
 821d480:	10909004 	addi	r2,r2,16960
 821d484:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 821d488:	e0bffe17 	ldw	r2,-8(fp)
 821d48c:	10800803 	ldbu	r2,32(r2)
 821d490:	10803fcc 	andi	r2,r2,255
 821d494:	1080201c 	xori	r2,r2,128
 821d498:	10bfe004 	addi	r2,r2,-128
 821d49c:	10001d1e 	bne	r2,zero,821d514 <lcd_write_data+0xc0>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 821d4a0:	00000906 	br	821d4c8 <lcd_write_data+0x74>
    if (--i == 0)
 821d4a4:	e0bffc17 	ldw	r2,-16(fp)
 821d4a8:	10bfffc4 	addi	r2,r2,-1
 821d4ac:	e0bffc15 	stw	r2,-16(fp)
 821d4b0:	e0bffc17 	ldw	r2,-16(fp)
 821d4b4:	1000041e 	bne	r2,zero,821d4c8 <lcd_write_data+0x74>
    {
      sp->broken = 1;
 821d4b8:	e0bffe17 	ldw	r2,-8(fp)
 821d4bc:	00c00044 	movi	r3,1
 821d4c0:	10c00805 	stb	r3,32(r2)
      return;
 821d4c4:	00001406 	br	821d518 <lcd_write_data+0xc4>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 821d4c8:	e0bffd17 	ldw	r2,-12(fp)
 821d4cc:	10800104 	addi	r2,r2,4
 821d4d0:	10800037 	ldwio	r2,0(r2)
 821d4d4:	1080200c 	andi	r2,r2,128
 821d4d8:	103ff21e 	bne	r2,zero,821d4a4 <lcd_write_data+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 821d4dc:	01001904 	movi	r4,100
 821d4e0:	823ca240 	call	823ca24 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_DATA(base, data);
 821d4e4:	e0bffd17 	ldw	r2,-12(fp)
 821d4e8:	10800204 	addi	r2,r2,8
 821d4ec:	1007883a 	mov	r3,r2
 821d4f0:	e0bfff03 	ldbu	r2,-4(fp)
 821d4f4:	18800035 	stwio	r2,0(r3)

  sp->address++;
 821d4f8:	e0bffe17 	ldw	r2,-8(fp)
 821d4fc:	108008c3 	ldbu	r2,35(r2)
 821d500:	10800044 	addi	r2,r2,1
 821d504:	1007883a 	mov	r3,r2
 821d508:	e0bffe17 	ldw	r2,-8(fp)
 821d50c:	10c008c5 	stb	r3,35(r2)
 821d510:	00000106 	br	821d518 <lcd_write_data+0xc4>
   */
  int i = 1000000;

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;
 821d514:	0001883a 	nop
  usleep(100);

  IOWR_ALTERA_AVALON_LCD_16207_DATA(base, data);

  sp->address++;
}
 821d518:	e037883a 	mov	sp,fp
 821d51c:	dfc00117 	ldw	ra,4(sp)
 821d520:	df000017 	ldw	fp,0(sp)
 821d524:	dec00204 	addi	sp,sp,8
 821d528:	f800283a 	ret

0821d52c <lcd_clear_screen>:

/* --------------------------------------------------------------------- */

static void lcd_clear_screen(altera_avalon_lcd_16207_state* sp)
{
 821d52c:	defffc04 	addi	sp,sp,-16
 821d530:	dfc00315 	stw	ra,12(sp)
 821d534:	df000215 	stw	fp,8(sp)
 821d538:	df000204 	addi	fp,sp,8
 821d53c:	e13fff15 	stw	r4,-4(fp)
  int y;

  lcd_write_command(sp, LCD_CMD_CLEAR);
 821d540:	01400044 	movi	r5,1
 821d544:	e13fff17 	ldw	r4,-4(fp)
 821d548:	821d39c0 	call	821d39c <lcd_write_command>

  sp->x = 0;
 821d54c:	e0bfff17 	ldw	r2,-4(fp)
 821d550:	10000845 	stb	zero,33(r2)
  sp->y = 0;
 821d554:	e0bfff17 	ldw	r2,-4(fp)
 821d558:	10000885 	stb	zero,34(r2)
  sp->address = 0;
 821d55c:	e0bfff17 	ldw	r2,-4(fp)
 821d560:	100008c5 	stb	zero,35(r2)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d564:	e03ffe15 	stw	zero,-8(fp)
 821d568:	00001b06 	br	821d5d8 <lcd_clear_screen+0xac>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
 821d56c:	e0bffe17 	ldw	r2,-8(fp)
 821d570:	108018e4 	muli	r2,r2,99
 821d574:	10801004 	addi	r2,r2,64
 821d578:	e0ffff17 	ldw	r3,-4(fp)
 821d57c:	1885883a 	add	r2,r3,r2
 821d580:	01801444 	movi	r6,81
 821d584:	01400804 	movi	r5,32
 821d588:	1009883a 	mov	r4,r2
 821d58c:	82031b40 	call	82031b4 <memset>
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
 821d590:	e0bffe17 	ldw	r2,-8(fp)
 821d594:	108018e4 	muli	r2,r2,99
 821d598:	10800c04 	addi	r2,r2,48
 821d59c:	e0ffff17 	ldw	r3,-4(fp)
 821d5a0:	1885883a 	add	r2,r3,r2
 821d5a4:	01800404 	movi	r6,16
 821d5a8:	01400804 	movi	r5,32
 821d5ac:	1009883a 	mov	r4,r2
 821d5b0:	82031b40 	call	82031b4 <memset>
    sp->line[y].width = 0;
 821d5b4:	e0ffff17 	ldw	r3,-4(fp)
 821d5b8:	e0bffe17 	ldw	r2,-8(fp)
 821d5bc:	108018e4 	muli	r2,r2,99
 821d5c0:	1885883a 	add	r2,r3,r2
 821d5c4:	10802444 	addi	r2,r2,145
 821d5c8:	10000005 	stb	zero,0(r2)

  sp->x = 0;
  sp->y = 0;
  sp->address = 0;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d5cc:	e0bffe17 	ldw	r2,-8(fp)
 821d5d0:	10800044 	addi	r2,r2,1
 821d5d4:	e0bffe15 	stw	r2,-8(fp)
 821d5d8:	e0bffe17 	ldw	r2,-8(fp)
 821d5dc:	10800090 	cmplti	r2,r2,2
 821d5e0:	103fe21e 	bne	r2,zero,821d56c <lcd_clear_screen+0x40>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
    sp->line[y].width = 0;
  }
}
 821d5e4:	0001883a 	nop
 821d5e8:	e037883a 	mov	sp,fp
 821d5ec:	dfc00117 	ldw	ra,4(sp)
 821d5f0:	df000017 	ldw	fp,0(sp)
 821d5f4:	dec00204 	addi	sp,sp,8
 821d5f8:	f800283a 	ret

0821d5fc <lcd_repaint_screen>:

/* --------------------------------------------------------------------- */

static void lcd_repaint_screen(altera_avalon_lcd_16207_state* sp)
{
 821d5fc:	defff704 	addi	sp,sp,-36
 821d600:	dfc00815 	stw	ra,32(sp)
 821d604:	df000715 	stw	fp,28(sp)
 821d608:	df000704 	addi	fp,sp,28
 821d60c:	e13fff15 	stw	r4,-4(fp)
  /* scrollpos controls how much the lines have scrolled round.  The speed
   * each line scrolls at is controlled by its speed variable - while
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;
 821d610:	e0bfff17 	ldw	r2,-4(fp)
 821d614:	10800943 	ldbu	r2,37(r2)
 821d618:	10803fcc 	andi	r2,r2,255
 821d61c:	e0bffc15 	stw	r2,-16(fp)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d620:	e03ff915 	stw	zero,-28(fp)
 821d624:	00006706 	br	821d7c4 <lcd_repaint_screen+0x1c8>
  {
    int width  = sp->line[y].width;
 821d628:	e0ffff17 	ldw	r3,-4(fp)
 821d62c:	e0bff917 	ldw	r2,-28(fp)
 821d630:	108018e4 	muli	r2,r2,99
 821d634:	1885883a 	add	r2,r3,r2
 821d638:	10802444 	addi	r2,r2,145
 821d63c:	10800003 	ldbu	r2,0(r2)
 821d640:	10803fcc 	andi	r2,r2,255
 821d644:	1080201c 	xori	r2,r2,128
 821d648:	10bfe004 	addi	r2,r2,-128
 821d64c:	e0bffd15 	stw	r2,-12(fp)
    int offset = (scrollpos * sp->line[y].speed) >> 8;
 821d650:	e0ffff17 	ldw	r3,-4(fp)
 821d654:	e0bff917 	ldw	r2,-28(fp)
 821d658:	108018e4 	muli	r2,r2,99
 821d65c:	1885883a 	add	r2,r3,r2
 821d660:	10802484 	addi	r2,r2,146
 821d664:	10800003 	ldbu	r2,0(r2)
 821d668:	10c03fcc 	andi	r3,r2,255
 821d66c:	e0bffc17 	ldw	r2,-16(fp)
 821d670:	1885383a 	mul	r2,r3,r2
 821d674:	1005d23a 	srai	r2,r2,8
 821d678:	e0bffb15 	stw	r2,-20(fp)
    if (offset >= width)
 821d67c:	e0fffb17 	ldw	r3,-20(fp)
 821d680:	e0bffd17 	ldw	r2,-12(fp)
 821d684:	18800116 	blt	r3,r2,821d68c <lcd_repaint_screen+0x90>
      offset = 0;
 821d688:	e03ffb15 	stw	zero,-20(fp)

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 821d68c:	e03ffa15 	stw	zero,-24(fp)
 821d690:	00004606 	br	821d7ac <lcd_repaint_screen+0x1b0>
    {
      char c = sp->line[y].data[(x + offset) % width];
 821d694:	e0fffa17 	ldw	r3,-24(fp)
 821d698:	e0bffb17 	ldw	r2,-20(fp)
 821d69c:	1885883a 	add	r2,r3,r2
 821d6a0:	e17ffd17 	ldw	r5,-12(fp)
 821d6a4:	1009883a 	mov	r4,r2
 821d6a8:	8202b9c0 	call	8202b9c <__modsi3>
 821d6ac:	1009883a 	mov	r4,r2
 821d6b0:	e0ffff17 	ldw	r3,-4(fp)
 821d6b4:	e0bff917 	ldw	r2,-28(fp)
 821d6b8:	108018e4 	muli	r2,r2,99
 821d6bc:	1885883a 	add	r2,r3,r2
 821d6c0:	1105883a 	add	r2,r2,r4
 821d6c4:	10801004 	addi	r2,r2,64
 821d6c8:	10800003 	ldbu	r2,0(r2)
 821d6cc:	e0bffe05 	stb	r2,-8(fp)

      /* Writing data takes 40us, so don't do it unless required */
      if (sp->line[y].visible[x] != c)
 821d6d0:	e0ffff17 	ldw	r3,-4(fp)
 821d6d4:	e0bff917 	ldw	r2,-28(fp)
 821d6d8:	108018e4 	muli	r2,r2,99
 821d6dc:	1887883a 	add	r3,r3,r2
 821d6e0:	e0bffa17 	ldw	r2,-24(fp)
 821d6e4:	1885883a 	add	r2,r3,r2
 821d6e8:	10800c04 	addi	r2,r2,48
 821d6ec:	10800003 	ldbu	r2,0(r2)
 821d6f0:	10c03fcc 	andi	r3,r2,255
 821d6f4:	18c0201c 	xori	r3,r3,128
 821d6f8:	18ffe004 	addi	r3,r3,-128
 821d6fc:	e0bffe07 	ldb	r2,-8(fp)
 821d700:	18802726 	beq	r3,r2,821d7a0 <lcd_repaint_screen+0x1a4>
      {
        unsigned char address = x + colstart[y];
 821d704:	e0fff917 	ldw	r3,-28(fp)
 821d708:	d0a02a04 	addi	r2,gp,-32600
 821d70c:	1885883a 	add	r2,r3,r2
 821d710:	10800003 	ldbu	r2,0(r2)
 821d714:	1007883a 	mov	r3,r2
 821d718:	e0bffa17 	ldw	r2,-24(fp)
 821d71c:	1885883a 	add	r2,r3,r2
 821d720:	e0bffe45 	stb	r2,-7(fp)

        if (address != sp->address)
 821d724:	e0fffe43 	ldbu	r3,-7(fp)
 821d728:	e0bfff17 	ldw	r2,-4(fp)
 821d72c:	108008c3 	ldbu	r2,35(r2)
 821d730:	10803fcc 	andi	r2,r2,255
 821d734:	1080201c 	xori	r2,r2,128
 821d738:	10bfe004 	addi	r2,r2,-128
 821d73c:	18800a26 	beq	r3,r2,821d768 <lcd_repaint_screen+0x16c>
        {
          lcd_write_command(sp, LCD_CMD_WRITE_DATA | address);
 821d740:	e0fffe43 	ldbu	r3,-7(fp)
 821d744:	00bfe004 	movi	r2,-128
 821d748:	1884b03a 	or	r2,r3,r2
 821d74c:	10803fcc 	andi	r2,r2,255
 821d750:	100b883a 	mov	r5,r2
 821d754:	e13fff17 	ldw	r4,-4(fp)
 821d758:	821d39c0 	call	821d39c <lcd_write_command>
          sp->address = address;
 821d75c:	e0fffe43 	ldbu	r3,-7(fp)
 821d760:	e0bfff17 	ldw	r2,-4(fp)
 821d764:	10c008c5 	stb	r3,35(r2)
        }

        lcd_write_data(sp, c);
 821d768:	e0bffe03 	ldbu	r2,-8(fp)
 821d76c:	10803fcc 	andi	r2,r2,255
 821d770:	100b883a 	mov	r5,r2
 821d774:	e13fff17 	ldw	r4,-4(fp)
 821d778:	821d4540 	call	821d454 <lcd_write_data>
        sp->line[y].visible[x] = c;
 821d77c:	e0ffff17 	ldw	r3,-4(fp)
 821d780:	e0bff917 	ldw	r2,-28(fp)
 821d784:	108018e4 	muli	r2,r2,99
 821d788:	1887883a 	add	r3,r3,r2
 821d78c:	e0bffa17 	ldw	r2,-24(fp)
 821d790:	1885883a 	add	r2,r3,r2
 821d794:	10800c04 	addi	r2,r2,48
 821d798:	e0fffe03 	ldbu	r3,-8(fp)
 821d79c:	10c00005 	stb	r3,0(r2)
    int width  = sp->line[y].width;
    int offset = (scrollpos * sp->line[y].speed) >> 8;
    if (offset >= width)
      offset = 0;

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 821d7a0:	e0bffa17 	ldw	r2,-24(fp)
 821d7a4:	10800044 	addi	r2,r2,1
 821d7a8:	e0bffa15 	stw	r2,-24(fp)
 821d7ac:	e0bffa17 	ldw	r2,-24(fp)
 821d7b0:	10800410 	cmplti	r2,r2,16
 821d7b4:	103fb71e 	bne	r2,zero,821d694 <lcd_repaint_screen+0x98>
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d7b8:	e0bff917 	ldw	r2,-28(fp)
 821d7bc:	10800044 	addi	r2,r2,1
 821d7c0:	e0bff915 	stw	r2,-28(fp)
 821d7c4:	e0bff917 	ldw	r2,-28(fp)
 821d7c8:	10800090 	cmplti	r2,r2,2
 821d7cc:	103f961e 	bne	r2,zero,821d628 <lcd_repaint_screen+0x2c>
        lcd_write_data(sp, c);
        sp->line[y].visible[x] = c;
      }
    }
  }
}
 821d7d0:	0001883a 	nop
 821d7d4:	e037883a 	mov	sp,fp
 821d7d8:	dfc00117 	ldw	ra,4(sp)
 821d7dc:	df000017 	ldw	fp,0(sp)
 821d7e0:	dec00204 	addi	sp,sp,8
 821d7e4:	f800283a 	ret

0821d7e8 <lcd_scroll_up>:

/* --------------------------------------------------------------------- */

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
 821d7e8:	defffc04 	addi	sp,sp,-16
 821d7ec:	dfc00315 	stw	ra,12(sp)
 821d7f0:	df000215 	stw	fp,8(sp)
 821d7f4:	df000204 	addi	fp,sp,8
 821d7f8:	e13fff15 	stw	r4,-4(fp)
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d7fc:	e03ffe15 	stw	zero,-8(fp)
 821d800:	00001d06 	br	821d878 <lcd_scroll_up+0x90>
  {
    if (y < ALT_LCD_HEIGHT-1)
 821d804:	e0bffe17 	ldw	r2,-8(fp)
 821d808:	00800f16 	blt	zero,r2,821d848 <lcd_scroll_up+0x60>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
 821d80c:	e0bffe17 	ldw	r2,-8(fp)
 821d810:	108018e4 	muli	r2,r2,99
 821d814:	10801004 	addi	r2,r2,64
 821d818:	e0ffff17 	ldw	r3,-4(fp)
 821d81c:	1889883a 	add	r4,r3,r2
 821d820:	e0bffe17 	ldw	r2,-8(fp)
 821d824:	10800044 	addi	r2,r2,1
 821d828:	108018e4 	muli	r2,r2,99
 821d82c:	10801004 	addi	r2,r2,64
 821d830:	e0ffff17 	ldw	r3,-4(fp)
 821d834:	1885883a 	add	r2,r3,r2
 821d838:	01801404 	movi	r6,80
 821d83c:	100b883a 	mov	r5,r2
 821d840:	8202f100 	call	8202f10 <memcpy>
 821d844:	00000906 	br	821d86c <lcd_scroll_up+0x84>
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
 821d848:	e0bffe17 	ldw	r2,-8(fp)
 821d84c:	108018e4 	muli	r2,r2,99
 821d850:	10801004 	addi	r2,r2,64
 821d854:	e0ffff17 	ldw	r3,-4(fp)
 821d858:	1885883a 	add	r2,r3,r2
 821d85c:	01801404 	movi	r6,80
 821d860:	01400804 	movi	r5,32
 821d864:	1009883a 	mov	r4,r2
 821d868:	82031b40 	call	82031b4 <memset>

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d86c:	e0bffe17 	ldw	r2,-8(fp)
 821d870:	10800044 	addi	r2,r2,1
 821d874:	e0bffe15 	stw	r2,-8(fp)
 821d878:	e0bffe17 	ldw	r2,-8(fp)
 821d87c:	10800090 	cmplti	r2,r2,2
 821d880:	103fe01e 	bne	r2,zero,821d804 <lcd_scroll_up+0x1c>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
  }

  sp->y--;
 821d884:	e0bfff17 	ldw	r2,-4(fp)
 821d888:	10800883 	ldbu	r2,34(r2)
 821d88c:	10bfffc4 	addi	r2,r2,-1
 821d890:	1007883a 	mov	r3,r2
 821d894:	e0bfff17 	ldw	r2,-4(fp)
 821d898:	10c00885 	stb	r3,34(r2)
}
 821d89c:	0001883a 	nop
 821d8a0:	e037883a 	mov	sp,fp
 821d8a4:	dfc00117 	ldw	ra,4(sp)
 821d8a8:	df000017 	ldw	fp,0(sp)
 821d8ac:	dec00204 	addi	sp,sp,8
 821d8b0:	f800283a 	ret

0821d8b4 <lcd_handle_escape>:

/* --------------------------------------------------------------------- */

static void lcd_handle_escape(altera_avalon_lcd_16207_state* sp, char c)
{
 821d8b4:	defff904 	addi	sp,sp,-28
 821d8b8:	dfc00615 	stw	ra,24(sp)
 821d8bc:	df000515 	stw	fp,20(sp)
 821d8c0:	df000504 	addi	fp,sp,20
 821d8c4:	e13ffe15 	stw	r4,-8(fp)
 821d8c8:	2805883a 	mov	r2,r5
 821d8cc:	e0bfff05 	stb	r2,-4(fp)
  int parm1 = 0, parm2 = 0;
 821d8d0:	e03ffb15 	stw	zero,-20(fp)
 821d8d4:	e03ffc15 	stw	zero,-16(fp)

  if (sp->escape[0] == '[')
 821d8d8:	e0bffe17 	ldw	r2,-8(fp)
 821d8dc:	10800a03 	ldbu	r2,40(r2)
 821d8e0:	10803fcc 	andi	r2,r2,255
 821d8e4:	1080201c 	xori	r2,r2,128
 821d8e8:	10bfe004 	addi	r2,r2,-128
 821d8ec:	108016d8 	cmpnei	r2,r2,91
 821d8f0:	1000411e 	bne	r2,zero,821d9f8 <lcd_handle_escape+0x144>
  {
    char * ptr = sp->escape+1;
 821d8f4:	e0bffe17 	ldw	r2,-8(fp)
 821d8f8:	10800a04 	addi	r2,r2,40
 821d8fc:	10800044 	addi	r2,r2,1
 821d900:	e0bffd15 	stw	r2,-12(fp)
    while (isdigit(*ptr))
 821d904:	00000c06 	br	821d938 <lcd_handle_escape+0x84>
      parm1 = (parm1 * 10) + (*ptr++ - '0');
 821d908:	e0bffb17 	ldw	r2,-20(fp)
 821d90c:	10c002a4 	muli	r3,r2,10
 821d910:	e0bffd17 	ldw	r2,-12(fp)
 821d914:	11000044 	addi	r4,r2,1
 821d918:	e13ffd15 	stw	r4,-12(fp)
 821d91c:	10800003 	ldbu	r2,0(r2)
 821d920:	10803fcc 	andi	r2,r2,255
 821d924:	1080201c 	xori	r2,r2,128
 821d928:	10bfe004 	addi	r2,r2,-128
 821d92c:	10bff404 	addi	r2,r2,-48
 821d930:	1885883a 	add	r2,r3,r2
 821d934:	e0bffb15 	stw	r2,-20(fp)
  int parm1 = 0, parm2 = 0;

  if (sp->escape[0] == '[')
  {
    char * ptr = sp->escape+1;
    while (isdigit(*ptr))
 821d938:	d0e00017 	ldw	r3,-32768(gp)
 821d93c:	e0bffd17 	ldw	r2,-12(fp)
 821d940:	10800003 	ldbu	r2,0(r2)
 821d944:	10803fcc 	andi	r2,r2,255
 821d948:	1080201c 	xori	r2,r2,128
 821d94c:	10bfe004 	addi	r2,r2,-128
 821d950:	10800044 	addi	r2,r2,1
 821d954:	1885883a 	add	r2,r3,r2
 821d958:	10800003 	ldbu	r2,0(r2)
 821d95c:	10803fcc 	andi	r2,r2,255
 821d960:	1080010c 	andi	r2,r2,4
 821d964:	103fe81e 	bne	r2,zero,821d908 <lcd_handle_escape+0x54>
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
 821d968:	e0bffd17 	ldw	r2,-12(fp)
 821d96c:	10800003 	ldbu	r2,0(r2)
 821d970:	10803fcc 	andi	r2,r2,255
 821d974:	1080201c 	xori	r2,r2,128
 821d978:	10bfe004 	addi	r2,r2,-128
 821d97c:	10800ed8 	cmpnei	r2,r2,59
 821d980:	10001f1e 	bne	r2,zero,821da00 <lcd_handle_escape+0x14c>
    {
      ptr++;
 821d984:	e0bffd17 	ldw	r2,-12(fp)
 821d988:	10800044 	addi	r2,r2,1
 821d98c:	e0bffd15 	stw	r2,-12(fp)
      while (isdigit(*ptr))
 821d990:	00000c06 	br	821d9c4 <lcd_handle_escape+0x110>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
 821d994:	e0bffc17 	ldw	r2,-16(fp)
 821d998:	10c002a4 	muli	r3,r2,10
 821d99c:	e0bffd17 	ldw	r2,-12(fp)
 821d9a0:	11000044 	addi	r4,r2,1
 821d9a4:	e13ffd15 	stw	r4,-12(fp)
 821d9a8:	10800003 	ldbu	r2,0(r2)
 821d9ac:	10803fcc 	andi	r2,r2,255
 821d9b0:	1080201c 	xori	r2,r2,128
 821d9b4:	10bfe004 	addi	r2,r2,-128
 821d9b8:	10bff404 	addi	r2,r2,-48
 821d9bc:	1885883a 	add	r2,r3,r2
 821d9c0:	e0bffc15 	stw	r2,-16(fp)
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
    {
      ptr++;
      while (isdigit(*ptr))
 821d9c4:	d0e00017 	ldw	r3,-32768(gp)
 821d9c8:	e0bffd17 	ldw	r2,-12(fp)
 821d9cc:	10800003 	ldbu	r2,0(r2)
 821d9d0:	10803fcc 	andi	r2,r2,255
 821d9d4:	1080201c 	xori	r2,r2,128
 821d9d8:	10bfe004 	addi	r2,r2,-128
 821d9dc:	10800044 	addi	r2,r2,1
 821d9e0:	1885883a 	add	r2,r3,r2
 821d9e4:	10800003 	ldbu	r2,0(r2)
 821d9e8:	10803fcc 	andi	r2,r2,255
 821d9ec:	1080010c 	andi	r2,r2,4
 821d9f0:	103fe81e 	bne	r2,zero,821d994 <lcd_handle_escape+0xe0>
 821d9f4:	00000206 	br	821da00 <lcd_handle_escape+0x14c>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
    }
  }
  else
    parm1 = -1;
 821d9f8:	00bfffc4 	movi	r2,-1
 821d9fc:	e0bffb15 	stw	r2,-20(fp)

  switch (c)
 821da00:	e0bfff07 	ldb	r2,-4(fp)
 821da04:	10c012a0 	cmpeqi	r3,r2,74
 821da08:	1800291e 	bne	r3,zero,821dab0 <lcd_handle_escape+0x1fc>
 821da0c:	10c012c8 	cmpgei	r3,r2,75
 821da10:	1800031e 	bne	r3,zero,821da20 <lcd_handle_escape+0x16c>
 821da14:	10801220 	cmpeqi	r2,r2,72
 821da18:	1000061e 	bne	r2,zero,821da34 <lcd_handle_escape+0x180>
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
    }
    break;
  }
}
 821da1c:	00004a06 	br	821db48 <lcd_handle_escape+0x294>
    }
  }
  else
    parm1 = -1;

  switch (c)
 821da20:	10c012e0 	cmpeqi	r3,r2,75
 821da24:	1800281e 	bne	r3,zero,821dac8 <lcd_handle_escape+0x214>
 821da28:	108019a0 	cmpeqi	r2,r2,102
 821da2c:	1000011e 	bne	r2,zero,821da34 <lcd_handle_escape+0x180>
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
    }
    break;
  }
}
 821da30:	00004506 	br	821db48 <lcd_handle_escape+0x294>

  switch (c)
  {
  case 'H': /* ESC '[' <y> ';' <x> 'H'  : Move cursor to location */
  case 'f': /* Same as above */
    if (parm2 > 0)
 821da34:	e0bffc17 	ldw	r2,-16(fp)
 821da38:	0080050e 	bge	zero,r2,821da50 <lcd_handle_escape+0x19c>
      sp->x = parm2 - 1;
 821da3c:	e0bffc17 	ldw	r2,-16(fp)
 821da40:	10bfffc4 	addi	r2,r2,-1
 821da44:	1007883a 	mov	r3,r2
 821da48:	e0bffe17 	ldw	r2,-8(fp)
 821da4c:	10c00845 	stb	r3,33(r2)
    if (parm1 > 0)
 821da50:	e0bffb17 	ldw	r2,-20(fp)
 821da54:	0080370e 	bge	zero,r2,821db34 <lcd_handle_escape+0x280>
    {
      sp->y = parm1 - 1;
 821da58:	e0bffb17 	ldw	r2,-20(fp)
 821da5c:	10bfffc4 	addi	r2,r2,-1
 821da60:	1007883a 	mov	r3,r2
 821da64:	e0bffe17 	ldw	r2,-8(fp)
 821da68:	10c00885 	stb	r3,34(r2)
      if (sp->y > ALT_LCD_HEIGHT * 2)
 821da6c:	e0bffe17 	ldw	r2,-8(fp)
 821da70:	10800883 	ldbu	r2,34(r2)
 821da74:	10803fcc 	andi	r2,r2,255
 821da78:	10800170 	cmpltui	r2,r2,5
 821da7c:	1000061e 	bne	r2,zero,821da98 <lcd_handle_escape+0x1e4>
        sp->y = ALT_LCD_HEIGHT * 2;
 821da80:	e0bffe17 	ldw	r2,-8(fp)
 821da84:	00c00104 	movi	r3,4
 821da88:	10c00885 	stb	r3,34(r2)
      while (sp->y > ALT_LCD_HEIGHT)
 821da8c:	00000206 	br	821da98 <lcd_handle_escape+0x1e4>
        lcd_scroll_up(sp);
 821da90:	e13ffe17 	ldw	r4,-8(fp)
 821da94:	821d7e80 	call	821d7e8 <lcd_scroll_up>
    if (parm1 > 0)
    {
      sp->y = parm1 - 1;
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
 821da98:	e0bffe17 	ldw	r2,-8(fp)
 821da9c:	10800883 	ldbu	r2,34(r2)
 821daa0:	10803fcc 	andi	r2,r2,255
 821daa4:	108000e8 	cmpgeui	r2,r2,3
 821daa8:	103ff91e 	bne	r2,zero,821da90 <lcd_handle_escape+0x1dc>
        lcd_scroll_up(sp);
    }
    break;
 821daac:	00002106 	br	821db34 <lcd_handle_escape+0x280>
    /*   ESC J      is clear to beginning of line    [unimplemented]
     *   ESC [ 0 J  is clear to bottom of screen     [unimplemented]
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
 821dab0:	e0bffb17 	ldw	r2,-20(fp)
 821dab4:	10800098 	cmpnei	r2,r2,2
 821dab8:	1000201e 	bne	r2,zero,821db3c <lcd_handle_escape+0x288>
      lcd_clear_screen(sp);
 821dabc:	e13ffe17 	ldw	r4,-8(fp)
 821dac0:	821d52c0 	call	821d52c <lcd_clear_screen>
    break;
 821dac4:	00001d06 	br	821db3c <lcd_handle_escape+0x288>
    /*   ESC K      is clear to end of line
     *   ESC [ 0 K  is clear to end of line
     *   ESC [ 1 K  is clear to beginning of line    [unimplemented]
     *   ESC [ 2 K  is clear line                    [unimplemented]
     */
    if (parm1 < 1)
 821dac8:	e0bffb17 	ldw	r2,-20(fp)
 821dacc:	00801d16 	blt	zero,r2,821db44 <lcd_handle_escape+0x290>
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 821dad0:	e0bffe17 	ldw	r2,-8(fp)
 821dad4:	10800843 	ldbu	r2,33(r2)
 821dad8:	10803fcc 	andi	r2,r2,255
 821dadc:	10801428 	cmpgeui	r2,r2,80
 821dae0:	1000181e 	bne	r2,zero,821db44 <lcd_handle_escape+0x290>
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
 821dae4:	e0bffe17 	ldw	r2,-8(fp)
 821dae8:	10800883 	ldbu	r2,34(r2)
 821daec:	10803fcc 	andi	r2,r2,255
 821daf0:	108018e4 	muli	r2,r2,99
 821daf4:	10801004 	addi	r2,r2,64
 821daf8:	e0fffe17 	ldw	r3,-8(fp)
 821dafc:	1887883a 	add	r3,r3,r2
 821db00:	e0bffe17 	ldw	r2,-8(fp)
 821db04:	10800843 	ldbu	r2,33(r2)
 821db08:	10803fcc 	andi	r2,r2,255
 821db0c:	1889883a 	add	r4,r3,r2
 821db10:	e0bffe17 	ldw	r2,-8(fp)
 821db14:	10800843 	ldbu	r2,33(r2)
 821db18:	10803fcc 	andi	r2,r2,255
 821db1c:	00c01404 	movi	r3,80
 821db20:	1885c83a 	sub	r2,r3,r2
 821db24:	100d883a 	mov	r6,r2
 821db28:	01400804 	movi	r5,32
 821db2c:	82031b40 	call	82031b4 <memset>
    }
    break;
 821db30:	00000406 	br	821db44 <lcd_handle_escape+0x290>
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
        lcd_scroll_up(sp);
    }
    break;
 821db34:	0001883a 	nop
 821db38:	00000306 	br	821db48 <lcd_handle_escape+0x294>
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
      lcd_clear_screen(sp);
    break;
 821db3c:	0001883a 	nop
 821db40:	00000106 	br	821db48 <lcd_handle_escape+0x294>
    if (parm1 < 1)
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
    }
    break;
 821db44:	0001883a 	nop
  }
}
 821db48:	0001883a 	nop
 821db4c:	e037883a 	mov	sp,fp
 821db50:	dfc00117 	ldw	ra,4(sp)
 821db54:	df000017 	ldw	fp,0(sp)
 821db58:	dec00204 	addi	sp,sp,8
 821db5c:	f800283a 	ret

0821db60 <altera_avalon_lcd_16207_write>:

/* --------------------------------------------------------------------- */

int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp, 
  const char* ptr, int len, int flags)
{
 821db60:	defff104 	addi	sp,sp,-60
 821db64:	dfc00e15 	stw	ra,56(sp)
 821db68:	df000d15 	stw	fp,52(sp)
 821db6c:	df000d04 	addi	fp,sp,52
 821db70:	e13ffc15 	stw	r4,-16(fp)
 821db74:	e17ffd15 	stw	r5,-12(fp)
 821db78:	e1bffe15 	stw	r6,-8(fp)
 821db7c:	e1ffff15 	stw	r7,-4(fp)
  const char* end = ptr + len;
 821db80:	e0bffe17 	ldw	r2,-8(fp)
 821db84:	e0fffd17 	ldw	r3,-12(fp)
 821db88:	1885883a 	add	r2,r3,r2
 821db8c:	e0bff615 	stw	r2,-40(fp)

  /* When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
 821db90:	e0bffc17 	ldw	r2,-16(fp)
 821db94:	10803e17 	ldw	r2,248(r2)
 821db98:	e0bffa15 	stw	r2,-24(fp)
 821db9c:	e03ffb0d 	sth	zero,-20(fp)
 821dba0:	e0bffb0b 	ldhu	r2,-20(fp)
 821dba4:	e0fffb84 	addi	r3,fp,-18
 821dba8:	180d883a 	mov	r6,r3
 821dbac:	100b883a 	mov	r5,r2
 821dbb0:	e13ffa17 	ldw	r4,-24(fp)
 821dbb4:	821a0d40 	call	821a0d4 <OSSemPend>

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;
 821dbb8:	e0bffc17 	ldw	r2,-16(fp)
 821dbbc:	00c00044 	movi	r3,1
 821dbc0:	10c009c5 	stb	r3,39(r2)

  for ( ; ptr < end ; ptr++)
 821dbc4:	00009906 	br	821de2c <altera_avalon_lcd_16207_write+0x2cc>
  {
    char c = *ptr;
 821dbc8:	e0bffd17 	ldw	r2,-12(fp)
 821dbcc:	10800003 	ldbu	r2,0(r2)
 821dbd0:	e0bff705 	stb	r2,-36(fp)

    if (sp->esccount >= 0)
 821dbd4:	e0bffc17 	ldw	r2,-16(fp)
 821dbd8:	10800903 	ldbu	r2,36(r2)
 821dbdc:	10803fcc 	andi	r2,r2,255
 821dbe0:	1080201c 	xori	r2,r2,128
 821dbe4:	10bfe004 	addi	r2,r2,-128
 821dbe8:	10003716 	blt	r2,zero,821dcc8 <altera_avalon_lcd_16207_write+0x168>
    {
      unsigned int esccount = sp->esccount;
 821dbec:	e0bffc17 	ldw	r2,-16(fp)
 821dbf0:	10800903 	ldbu	r2,36(r2)
 821dbf4:	10803fcc 	andi	r2,r2,255
 821dbf8:	1080201c 	xori	r2,r2,128
 821dbfc:	10bfe004 	addi	r2,r2,-128
 821dc00:	e0bff815 	stw	r2,-32(fp)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
 821dc04:	e0bff817 	ldw	r2,-32(fp)
 821dc08:	1000031e 	bne	r2,zero,821dc18 <altera_avalon_lcd_16207_write+0xb8>
 821dc0c:	e0bff707 	ldb	r2,-36(fp)
 821dc10:	108016d8 	cmpnei	r2,r2,91
 821dc14:	10000d1e 	bne	r2,zero,821dc4c <altera_avalon_lcd_16207_write+0xec>
 821dc18:	e0bff817 	ldw	r2,-32(fp)
 821dc1c:	10001826 	beq	r2,zero,821dc80 <altera_avalon_lcd_16207_write+0x120>
          (esccount > 0 && !isdigit(c) && c != ';'))
 821dc20:	d0e00017 	ldw	r3,-32768(gp)
 821dc24:	e0bff707 	ldb	r2,-36(fp)
 821dc28:	10800044 	addi	r2,r2,1
 821dc2c:	1885883a 	add	r2,r3,r2
 821dc30:	10800003 	ldbu	r2,0(r2)
 821dc34:	10803fcc 	andi	r2,r2,255
 821dc38:	1080010c 	andi	r2,r2,4
 821dc3c:	1000101e 	bne	r2,zero,821dc80 <altera_avalon_lcd_16207_write+0x120>
 821dc40:	e0bff707 	ldb	r2,-36(fp)
 821dc44:	10800ee0 	cmpeqi	r2,r2,59
 821dc48:	10000d1e 	bne	r2,zero,821dc80 <altera_avalon_lcd_16207_write+0x120>
      {
        sp->escape[esccount] = 0;
 821dc4c:	e0fffc17 	ldw	r3,-16(fp)
 821dc50:	e0bff817 	ldw	r2,-32(fp)
 821dc54:	1885883a 	add	r2,r3,r2
 821dc58:	10800a04 	addi	r2,r2,40
 821dc5c:	10000005 	stb	zero,0(r2)

        lcd_handle_escape(sp, c);
 821dc60:	e0bff707 	ldb	r2,-36(fp)
 821dc64:	100b883a 	mov	r5,r2
 821dc68:	e13ffc17 	ldw	r4,-16(fp)
 821dc6c:	821d8b40 	call	821d8b4 <lcd_handle_escape>

        sp->esccount = -1;
 821dc70:	e0bffc17 	ldw	r2,-16(fp)
 821dc74:	00ffffc4 	movi	r3,-1
 821dc78:	10c00905 	stb	r3,36(r2)
 821dc7c:	00006806 	br	821de20 <altera_avalon_lcd_16207_write+0x2c0>
      }
      else if (sp->esccount < sizeof(sp->escape)-1)
 821dc80:	e0bffc17 	ldw	r2,-16(fp)
 821dc84:	10800903 	ldbu	r2,36(r2)
 821dc88:	10803fcc 	andi	r2,r2,255
 821dc8c:	108001e8 	cmpgeui	r2,r2,7
 821dc90:	1000631e 	bne	r2,zero,821de20 <altera_avalon_lcd_16207_write+0x2c0>
      {
        sp->escape[esccount] = c;
 821dc94:	e0fffc17 	ldw	r3,-16(fp)
 821dc98:	e0bff817 	ldw	r2,-32(fp)
 821dc9c:	1885883a 	add	r2,r3,r2
 821dca0:	10800a04 	addi	r2,r2,40
 821dca4:	e0fff703 	ldbu	r3,-36(fp)
 821dca8:	10c00005 	stb	r3,0(r2)
        sp->esccount++;
 821dcac:	e0bffc17 	ldw	r2,-16(fp)
 821dcb0:	10800903 	ldbu	r2,36(r2)
 821dcb4:	10800044 	addi	r2,r2,1
 821dcb8:	1007883a 	mov	r3,r2
 821dcbc:	e0bffc17 	ldw	r2,-16(fp)
 821dcc0:	10c00905 	stb	r3,36(r2)
 821dcc4:	00005606 	br	821de20 <altera_avalon_lcd_16207_write+0x2c0>
      }
    }
    else if (c == 27) /* ESC */
 821dcc8:	e0bff707 	ldb	r2,-36(fp)
 821dccc:	108006d8 	cmpnei	r2,r2,27
 821dcd0:	1000031e 	bne	r2,zero,821dce0 <altera_avalon_lcd_16207_write+0x180>
    {
      sp->esccount = 0;
 821dcd4:	e0bffc17 	ldw	r2,-16(fp)
 821dcd8:	10000905 	stb	zero,36(r2)
 821dcdc:	00005006 	br	821de20 <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (c == '\r')
 821dce0:	e0bff707 	ldb	r2,-36(fp)
 821dce4:	10800358 	cmpnei	r2,r2,13
 821dce8:	1000031e 	bne	r2,zero,821dcf8 <altera_avalon_lcd_16207_write+0x198>
    {
      sp->x = 0;
 821dcec:	e0bffc17 	ldw	r2,-16(fp)
 821dcf0:	10000845 	stb	zero,33(r2)
 821dcf4:	00004a06 	br	821de20 <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (c == '\n')
 821dcf8:	e0bff707 	ldb	r2,-36(fp)
 821dcfc:	10800298 	cmpnei	r2,r2,10
 821dd00:	1000101e 	bne	r2,zero,821dd44 <altera_avalon_lcd_16207_write+0x1e4>
    {
      sp->x = 0;
 821dd04:	e0bffc17 	ldw	r2,-16(fp)
 821dd08:	10000845 	stb	zero,33(r2)
      sp->y++;
 821dd0c:	e0bffc17 	ldw	r2,-16(fp)
 821dd10:	10800883 	ldbu	r2,34(r2)
 821dd14:	10800044 	addi	r2,r2,1
 821dd18:	1007883a 	mov	r3,r2
 821dd1c:	e0bffc17 	ldw	r2,-16(fp)
 821dd20:	10c00885 	stb	r3,34(r2)

      /* Let the cursor sit at X=0, Y=HEIGHT without scrolling so the user
       * can print two lines of data without losing one.
       */
      if (sp->y > ALT_LCD_HEIGHT)
 821dd24:	e0bffc17 	ldw	r2,-16(fp)
 821dd28:	10800883 	ldbu	r2,34(r2)
 821dd2c:	10803fcc 	andi	r2,r2,255
 821dd30:	108000f0 	cmpltui	r2,r2,3
 821dd34:	10003a1e 	bne	r2,zero,821de20 <altera_avalon_lcd_16207_write+0x2c0>
        lcd_scroll_up(sp);
 821dd38:	e13ffc17 	ldw	r4,-16(fp)
 821dd3c:	821d7e80 	call	821d7e8 <lcd_scroll_up>
 821dd40:	00003706 	br	821de20 <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (c == '\b')
 821dd44:	e0bff707 	ldb	r2,-36(fp)
 821dd48:	10800218 	cmpnei	r2,r2,8
 821dd4c:	10000b1e 	bne	r2,zero,821dd7c <altera_avalon_lcd_16207_write+0x21c>
    {
      if (sp->x > 0)
 821dd50:	e0bffc17 	ldw	r2,-16(fp)
 821dd54:	10800843 	ldbu	r2,33(r2)
 821dd58:	10803fcc 	andi	r2,r2,255
 821dd5c:	10003026 	beq	r2,zero,821de20 <altera_avalon_lcd_16207_write+0x2c0>
        sp->x--;
 821dd60:	e0bffc17 	ldw	r2,-16(fp)
 821dd64:	10800843 	ldbu	r2,33(r2)
 821dd68:	10bfffc4 	addi	r2,r2,-1
 821dd6c:	1007883a 	mov	r3,r2
 821dd70:	e0bffc17 	ldw	r2,-16(fp)
 821dd74:	10c00845 	stb	r3,33(r2)
 821dd78:	00002906 	br	821de20 <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (isprint(c))
 821dd7c:	d0e00017 	ldw	r3,-32768(gp)
 821dd80:	e0bff707 	ldb	r2,-36(fp)
 821dd84:	10800044 	addi	r2,r2,1
 821dd88:	1885883a 	add	r2,r3,r2
 821dd8c:	10800003 	ldbu	r2,0(r2)
 821dd90:	10803fcc 	andi	r2,r2,255
 821dd94:	1080201c 	xori	r2,r2,128
 821dd98:	10bfe004 	addi	r2,r2,-128
 821dd9c:	108025cc 	andi	r2,r2,151
 821dda0:	10001f26 	beq	r2,zero,821de20 <altera_avalon_lcd_16207_write+0x2c0>
    {
      /* If we didn't scroll on the last linefeed then we might need to do
       * it now. */
      if (sp->y >= ALT_LCD_HEIGHT)
 821dda4:	e0bffc17 	ldw	r2,-16(fp)
 821dda8:	10800883 	ldbu	r2,34(r2)
 821ddac:	10803fcc 	andi	r2,r2,255
 821ddb0:	108000b0 	cmpltui	r2,r2,2
 821ddb4:	1000021e 	bne	r2,zero,821ddc0 <altera_avalon_lcd_16207_write+0x260>
        lcd_scroll_up(sp);
 821ddb8:	e13ffc17 	ldw	r4,-16(fp)
 821ddbc:	821d7e80 	call	821d7e8 <lcd_scroll_up>

      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 821ddc0:	e0bffc17 	ldw	r2,-16(fp)
 821ddc4:	10800843 	ldbu	r2,33(r2)
 821ddc8:	10803fcc 	andi	r2,r2,255
 821ddcc:	10801428 	cmpgeui	r2,r2,80
 821ddd0:	10000d1e 	bne	r2,zero,821de08 <altera_avalon_lcd_16207_write+0x2a8>
        sp->line[sp->y].data[sp->x] = c;
 821ddd4:	e0bffc17 	ldw	r2,-16(fp)
 821ddd8:	10800883 	ldbu	r2,34(r2)
 821dddc:	10c03fcc 	andi	r3,r2,255
 821dde0:	e0bffc17 	ldw	r2,-16(fp)
 821dde4:	10800843 	ldbu	r2,33(r2)
 821dde8:	10803fcc 	andi	r2,r2,255
 821ddec:	e13ffc17 	ldw	r4,-16(fp)
 821ddf0:	18c018e4 	muli	r3,r3,99
 821ddf4:	20c7883a 	add	r3,r4,r3
 821ddf8:	1885883a 	add	r2,r3,r2
 821ddfc:	10801004 	addi	r2,r2,64
 821de00:	e0fff703 	ldbu	r3,-36(fp)
 821de04:	10c00005 	stb	r3,0(r2)

      sp->x++;
 821de08:	e0bffc17 	ldw	r2,-16(fp)
 821de0c:	10800843 	ldbu	r2,33(r2)
 821de10:	10800044 	addi	r2,r2,1
 821de14:	1007883a 	mov	r3,r2
 821de18:	e0bffc17 	ldw	r2,-16(fp)
 821de1c:	10c00845 	stb	r3,33(r2)

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;

  for ( ; ptr < end ; ptr++)
 821de20:	e0bffd17 	ldw	r2,-12(fp)
 821de24:	10800044 	addi	r2,r2,1
 821de28:	e0bffd15 	stw	r2,-12(fp)
 821de2c:	e0fffd17 	ldw	r3,-12(fp)
 821de30:	e0bff617 	ldw	r2,-40(fp)
 821de34:	18bf6436 	bltu	r3,r2,821dbc8 <altera_avalon_lcd_16207_write+0x68>
      sp->x++;
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
 821de38:	00800404 	movi	r2,16
 821de3c:	e0bff415 	stw	r2,-48(fp)
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821de40:	e03ff315 	stw	zero,-52(fp)
 821de44:	00003706 	br	821df24 <altera_avalon_lcd_16207_write+0x3c4>
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 821de48:	00801404 	movi	r2,80
 821de4c:	e0bff515 	stw	r2,-44(fp)
 821de50:	00001106 	br	821de98 <altera_avalon_lcd_16207_write+0x338>
      if (sp->line[y].data[width-1] != ' ')
 821de54:	e0bff517 	ldw	r2,-44(fp)
 821de58:	10bfffc4 	addi	r2,r2,-1
 821de5c:	e13ffc17 	ldw	r4,-16(fp)
 821de60:	e0fff317 	ldw	r3,-52(fp)
 821de64:	18c018e4 	muli	r3,r3,99
 821de68:	20c7883a 	add	r3,r4,r3
 821de6c:	1885883a 	add	r2,r3,r2
 821de70:	10801004 	addi	r2,r2,64
 821de74:	10800003 	ldbu	r2,0(r2)
 821de78:	10803fcc 	andi	r2,r2,255
 821de7c:	1080201c 	xori	r2,r2,128
 821de80:	10bfe004 	addi	r2,r2,-128
 821de84:	10800820 	cmpeqi	r2,r2,32
 821de88:	10000626 	beq	r2,zero,821dea4 <altera_avalon_lcd_16207_write+0x344>
  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 821de8c:	e0bff517 	ldw	r2,-44(fp)
 821de90:	10bfffc4 	addi	r2,r2,-1
 821de94:	e0bff515 	stw	r2,-44(fp)
 821de98:	e0bff517 	ldw	r2,-44(fp)
 821de9c:	00bfed16 	blt	zero,r2,821de54 <altera_avalon_lcd_16207_write+0x2f4>
 821dea0:	00000106 	br	821dea8 <altera_avalon_lcd_16207_write+0x348>
      if (sp->line[y].data[width-1] != ' ')
        break;
 821dea4:	0001883a 	nop

    /* The minimum width is the size of the LCD panel.  If the real width
     * is long enough to require scrolling then add an extra space so the
     * end of the message doesn't run into the beginning of it.
     */
    if (width <= ALT_LCD_WIDTH)
 821dea8:	e0bff517 	ldw	r2,-44(fp)
 821deac:	10800448 	cmpgei	r2,r2,17
 821deb0:	1000031e 	bne	r2,zero,821dec0 <altera_avalon_lcd_16207_write+0x360>
      width = ALT_LCD_WIDTH;
 821deb4:	00800404 	movi	r2,16
 821deb8:	e0bff515 	stw	r2,-44(fp)
 821debc:	00000306 	br	821decc <altera_avalon_lcd_16207_write+0x36c>
    else
      width++;
 821dec0:	e0bff517 	ldw	r2,-44(fp)
 821dec4:	10800044 	addi	r2,r2,1
 821dec8:	e0bff515 	stw	r2,-44(fp)

    sp->line[y].width = width;
 821decc:	e0bff517 	ldw	r2,-44(fp)
 821ded0:	1009883a 	mov	r4,r2
 821ded4:	e0fffc17 	ldw	r3,-16(fp)
 821ded8:	e0bff317 	ldw	r2,-52(fp)
 821dedc:	108018e4 	muli	r2,r2,99
 821dee0:	1885883a 	add	r2,r3,r2
 821dee4:	10802444 	addi	r2,r2,145
 821dee8:	11000005 	stb	r4,0(r2)
    if (widthmax < width)
 821deec:	e0fff417 	ldw	r3,-48(fp)
 821def0:	e0bff517 	ldw	r2,-44(fp)
 821def4:	1880020e 	bge	r3,r2,821df00 <altera_avalon_lcd_16207_write+0x3a0>
      widthmax = width;
 821def8:	e0bff517 	ldw	r2,-44(fp)
 821defc:	e0bff415 	stw	r2,-48(fp)
    sp->line[y].speed = 0; /* By default lines don't scroll */
 821df00:	e0fffc17 	ldw	r3,-16(fp)
 821df04:	e0bff317 	ldw	r2,-52(fp)
 821df08:	108018e4 	muli	r2,r2,99
 821df0c:	1885883a 	add	r2,r3,r2
 821df10:	10802484 	addi	r2,r2,146
 821df14:	10000005 	stb	zero,0(r2)
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821df18:	e0bff317 	ldw	r2,-52(fp)
 821df1c:	10800044 	addi	r2,r2,1
 821df20:	e0bff315 	stw	r2,-52(fp)
 821df24:	e0bff317 	ldw	r2,-52(fp)
 821df28:	10800090 	cmplti	r2,r2,2
 821df2c:	103fc61e 	bne	r2,zero,821de48 <altera_avalon_lcd_16207_write+0x2e8>
    if (widthmax < width)
      widthmax = width;
    sp->line[y].speed = 0; /* By default lines don't scroll */
  }

  if (widthmax <= ALT_LCD_WIDTH)
 821df30:	e0bff417 	ldw	r2,-48(fp)
 821df34:	10800448 	cmpgei	r2,r2,17
 821df38:	1000031e 	bne	r2,zero,821df48 <altera_avalon_lcd_16207_write+0x3e8>
    sp->scrollmax = 0;
 821df3c:	e0bffc17 	ldw	r2,-16(fp)
 821df40:	10000985 	stb	zero,38(r2)
 821df44:	00002e06 	br	821e000 <altera_avalon_lcd_16207_write+0x4a0>
  else
  {
    widthmax *= 2;
 821df48:	e0bff417 	ldw	r2,-48(fp)
 821df4c:	1085883a 	add	r2,r2,r2
 821df50:	e0bff415 	stw	r2,-48(fp)
    sp->scrollmax = widthmax;
 821df54:	e0bff417 	ldw	r2,-48(fp)
 821df58:	1007883a 	mov	r3,r2
 821df5c:	e0bffc17 	ldw	r2,-16(fp)
 821df60:	10c00985 	stb	r3,38(r2)

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821df64:	e03ff315 	stw	zero,-52(fp)
 821df68:	00002206 	br	821dff4 <altera_avalon_lcd_16207_write+0x494>
      if (sp->line[y].width > ALT_LCD_WIDTH)
 821df6c:	e0fffc17 	ldw	r3,-16(fp)
 821df70:	e0bff317 	ldw	r2,-52(fp)
 821df74:	108018e4 	muli	r2,r2,99
 821df78:	1885883a 	add	r2,r3,r2
 821df7c:	10802444 	addi	r2,r2,145
 821df80:	10800003 	ldbu	r2,0(r2)
 821df84:	10803fcc 	andi	r2,r2,255
 821df88:	1080201c 	xori	r2,r2,128
 821df8c:	10bfe004 	addi	r2,r2,-128
 821df90:	10800450 	cmplti	r2,r2,17
 821df94:	1000141e 	bne	r2,zero,821dfe8 <altera_avalon_lcd_16207_write+0x488>
         */
#if 1
        /* This option makes all the lines scroll round at different speeds
         * which are chosen so that all the scrolls finish at the same time.
         */
        sp->line[y].speed = 256 * sp->line[y].width / widthmax;
 821df98:	e0fffc17 	ldw	r3,-16(fp)
 821df9c:	e0bff317 	ldw	r2,-52(fp)
 821dfa0:	108018e4 	muli	r2,r2,99
 821dfa4:	1885883a 	add	r2,r3,r2
 821dfa8:	10802444 	addi	r2,r2,145
 821dfac:	10800003 	ldbu	r2,0(r2)
 821dfb0:	10803fcc 	andi	r2,r2,255
 821dfb4:	1080201c 	xori	r2,r2,128
 821dfb8:	10bfe004 	addi	r2,r2,-128
 821dfbc:	1004923a 	slli	r2,r2,8
 821dfc0:	e17ff417 	ldw	r5,-48(fp)
 821dfc4:	1009883a 	mov	r4,r2
 821dfc8:	8202b180 	call	8202b18 <__divsi3>
 821dfcc:	1009883a 	mov	r4,r2
 821dfd0:	e0fffc17 	ldw	r3,-16(fp)
 821dfd4:	e0bff317 	ldw	r2,-52(fp)
 821dfd8:	108018e4 	muli	r2,r2,99
 821dfdc:	1885883a 	add	r2,r3,r2
 821dfe0:	10802484 	addi	r2,r2,146
 821dfe4:	11000005 	stb	r4,0(r2)
  {
    widthmax *= 2;
    sp->scrollmax = widthmax;

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821dfe8:	e0bff317 	ldw	r2,-52(fp)
 821dfec:	10800044 	addi	r2,r2,1
 821dff0:	e0bff315 	stw	r2,-52(fp)
 821dff4:	e0bff317 	ldw	r2,-52(fp)
 821dff8:	10800090 	cmplti	r2,r2,2
 821dffc:	103fdb1e 	bne	r2,zero,821df6c <altera_avalon_lcd_16207_write+0x40c>
   * (because active was set when the timer interrupt occurred).  If there
   * has been a missed repaint then paint again.  And again.  etc.
   */
  for ( ; ; )
  {
    int old_scrollpos = sp->scrollpos;
 821e000:	e0bffc17 	ldw	r2,-16(fp)
 821e004:	10800943 	ldbu	r2,37(r2)
 821e008:	10803fcc 	andi	r2,r2,255
 821e00c:	e0bff915 	stw	r2,-28(fp)

    lcd_repaint_screen(sp);
 821e010:	e13ffc17 	ldw	r4,-16(fp)
 821e014:	821d5fc0 	call	821d5fc <lcd_repaint_screen>

    /* Let the timer routines repaint the display again */
    sp->active = 0;
 821e018:	e0bffc17 	ldw	r2,-16(fp)
 821e01c:	100009c5 	stb	zero,39(r2)

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
 821e020:	e0bffc17 	ldw	r2,-16(fp)
 821e024:	10800943 	ldbu	r2,37(r2)
 821e028:	10c03fcc 	andi	r3,r2,255
 821e02c:	e0bff917 	ldw	r2,-28(fp)
 821e030:	18800426 	beq	r3,r2,821e044 <altera_avalon_lcd_16207_write+0x4e4>
      break;

    /* We need to repaint again since the display scrolled while we were
     * painting last time */
    sp->active = 1;
 821e034:	e0bffc17 	ldw	r2,-16(fp)
 821e038:	00c00044 	movi	r3,1
 821e03c:	10c009c5 	stb	r3,39(r2)
  }
 821e040:	003fef06 	br	821e000 <altera_avalon_lcd_16207_write+0x4a0>
    sp->active = 0;

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
      break;
 821e044:	0001883a 	nop

  /* Now that access to the display is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
 821e048:	e0bffc17 	ldw	r2,-16(fp)
 821e04c:	10803e17 	ldw	r2,248(r2)
 821e050:	1009883a 	mov	r4,r2
 821e054:	821a44c0 	call	821a44c <OSSemPost>

  return len;
 821e058:	e0bffe17 	ldw	r2,-8(fp)
}
 821e05c:	e037883a 	mov	sp,fp
 821e060:	dfc00117 	ldw	ra,4(sp)
 821e064:	df000017 	ldw	fp,0(sp)
 821e068:	dec00204 	addi	sp,sp,8
 821e06c:	f800283a 	ret

0821e070 <alt_lcd_16207_timeout>:
/*
 * Timeout routine is called every second
 */

static alt_u32 alt_lcd_16207_timeout(void* context) 
{
 821e070:	defffc04 	addi	sp,sp,-16
 821e074:	dfc00315 	stw	ra,12(sp)
 821e078:	df000215 	stw	fp,8(sp)
 821e07c:	df000204 	addi	fp,sp,8
 821e080:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_lcd_16207_state* sp = (altera_avalon_lcd_16207_state*)context;
 821e084:	e0bfff17 	ldw	r2,-4(fp)
 821e088:	e0bffe15 	stw	r2,-8(fp)

  /* Update the scrolling position */
  if (sp->scrollpos + 1 >= sp->scrollmax)
 821e08c:	e0bffe17 	ldw	r2,-8(fp)
 821e090:	10800943 	ldbu	r2,37(r2)
 821e094:	10803fcc 	andi	r2,r2,255
 821e098:	10c00044 	addi	r3,r2,1
 821e09c:	e0bffe17 	ldw	r2,-8(fp)
 821e0a0:	10800983 	ldbu	r2,38(r2)
 821e0a4:	10803fcc 	andi	r2,r2,255
 821e0a8:	18800316 	blt	r3,r2,821e0b8 <alt_lcd_16207_timeout+0x48>
    sp->scrollpos = 0;
 821e0ac:	e0bffe17 	ldw	r2,-8(fp)
 821e0b0:	10000945 	stb	zero,37(r2)
 821e0b4:	00000606 	br	821e0d0 <alt_lcd_16207_timeout+0x60>
  else
    sp->scrollpos = sp->scrollpos + 1;
 821e0b8:	e0bffe17 	ldw	r2,-8(fp)
 821e0bc:	10800943 	ldbu	r2,37(r2)
 821e0c0:	10800044 	addi	r2,r2,1
 821e0c4:	1007883a 	mov	r3,r2
 821e0c8:	e0bffe17 	ldw	r2,-8(fp)
 821e0cc:	10c00945 	stb	r3,37(r2)

  /* Repaint the panel unless the foreground will do it again soon */
  if (sp->scrollmax > 0 && !sp->active)
 821e0d0:	e0bffe17 	ldw	r2,-8(fp)
 821e0d4:	10800983 	ldbu	r2,38(r2)
 821e0d8:	10803fcc 	andi	r2,r2,255
 821e0dc:	10000826 	beq	r2,zero,821e100 <alt_lcd_16207_timeout+0x90>
 821e0e0:	e0bffe17 	ldw	r2,-8(fp)
 821e0e4:	108009c3 	ldbu	r2,39(r2)
 821e0e8:	10803fcc 	andi	r2,r2,255
 821e0ec:	1080201c 	xori	r2,r2,128
 821e0f0:	10bfe004 	addi	r2,r2,-128
 821e0f4:	1000021e 	bne	r2,zero,821e100 <alt_lcd_16207_timeout+0x90>
    lcd_repaint_screen(sp);
 821e0f8:	e13ffe17 	ldw	r4,-8(fp)
 821e0fc:	821d5fc0 	call	821d5fc <lcd_repaint_screen>

  return sp->period;
 821e100:	e0bffe17 	ldw	r2,-8(fp)
 821e104:	10800717 	ldw	r2,28(r2)
}
 821e108:	e037883a 	mov	sp,fp
 821e10c:	dfc00117 	ldw	ra,4(sp)
 821e110:	df000017 	ldw	fp,0(sp)
 821e114:	dec00204 	addi	sp,sp,8
 821e118:	f800283a 	ret

0821e11c <altera_avalon_lcd_16207_init>:

/*
 * Called at boot time to initialise the LCD driver
 */
void altera_avalon_lcd_16207_init(altera_avalon_lcd_16207_state* sp)
{
 821e11c:	defff604 	addi	sp,sp,-40
 821e120:	dfc00915 	stw	ra,36(sp)
 821e124:	df000815 	stw	fp,32(sp)
 821e128:	dc400715 	stw	r17,28(sp)
 821e12c:	dc000615 	stw	r16,24(sp)
 821e130:	df000804 	addi	fp,sp,32
 821e134:	e13ffb15 	stw	r4,-20(fp)
  unsigned int base = sp->base;
 821e138:	e0bffb17 	ldw	r2,-20(fp)
 821e13c:	10800017 	ldw	r2,0(r2)
 821e140:	e0bff815 	stw	r2,-32(fp)

  /* Mark the device as functional */
  sp->broken = 0;
 821e144:	e0bffb17 	ldw	r2,-20(fp)
 821e148:	10000805 	stb	zero,32(r2)

  ALT_SEM_CREATE (&sp->write_lock, 1);
 821e14c:	e0bffb17 	ldw	r2,-20(fp)
 821e150:	10803e04 	addi	r2,r2,248
 821e154:	e0bff915 	stw	r2,-28(fp)
 821e158:	00800044 	movi	r2,1
 821e15c:	e0bffa0d 	sth	r2,-24(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 821e160:	e0bffa0b 	ldhu	r2,-24(fp)
 821e164:	1009883a 	mov	r4,r2
 821e168:	8219dbc0 	call	8219dbc <OSSemCreate>
 821e16c:	1007883a 	mov	r3,r2
 821e170:	e0bff917 	ldw	r2,-28(fp)
 821e174:	10c00015 	stw	r3,0(r2)
   * the BUSY bit in the status register doesn't work until the display
   * has been reset three times.
   */

  /* Wait for 15 ms then reset */
  usleep(15000);
 821e178:	010ea604 	movi	r4,15000
 821e17c:	823ca240 	call	823ca24 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 821e180:	e0bff817 	ldw	r2,-32(fp)
 821e184:	00c00c04 	movi	r3,48
 821e188:	10c00035 	stwio	r3,0(r2)

  /* Wait for another 4.1ms and reset again */
  usleep(4100);  
 821e18c:	01040104 	movi	r4,4100
 821e190:	823ca240 	call	823ca24 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 821e194:	e0bff817 	ldw	r2,-32(fp)
 821e198:	00c00c04 	movi	r3,48
 821e19c:	10c00035 	stwio	r3,0(r2)

  /* Wait a further 1 ms and reset a third time */
  usleep(1000);
 821e1a0:	0100fa04 	movi	r4,1000
 821e1a4:	823ca240 	call	823ca24 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 821e1a8:	e0bff817 	ldw	r2,-32(fp)
 821e1ac:	00c00c04 	movi	r3,48
 821e1b0:	10c00035 	stwio	r3,0(r2)

  /* Setup interface parameters: 8 bit bus, 2 rows, 5x7 font */
  lcd_write_command(sp, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT | LCD_CMD_TWO_LINE);
 821e1b4:	01400e04 	movi	r5,56
 821e1b8:	e13ffb17 	ldw	r4,-20(fp)
 821e1bc:	821d39c0 	call	821d39c <lcd_write_command>
  
  /* Turn display off */
  lcd_write_command(sp, LCD_CMD_ONOFF);
 821e1c0:	01400204 	movi	r5,8
 821e1c4:	e13ffb17 	ldw	r4,-20(fp)
 821e1c8:	821d39c0 	call	821d39c <lcd_write_command>

  /* Clear display */
  lcd_clear_screen(sp);
 821e1cc:	e13ffb17 	ldw	r4,-20(fp)
 821e1d0:	821d52c0 	call	821d52c <lcd_clear_screen>
  
  /* Set mode: increment after writing, don't shift display */
  lcd_write_command(sp, LCD_CMD_MODES | LCD_CMD_MODE_INC);
 821e1d4:	01400184 	movi	r5,6
 821e1d8:	e13ffb17 	ldw	r4,-20(fp)
 821e1dc:	821d39c0 	call	821d39c <lcd_write_command>

  /* Turn display on */
  lcd_write_command(sp, LCD_CMD_ONOFF | LCD_CMD_ENABLE_DISP);
 821e1e0:	01400304 	movi	r5,12
 821e1e4:	e13ffb17 	ldw	r4,-20(fp)
 821e1e8:	821d39c0 	call	821d39c <lcd_write_command>

  sp->esccount = -1;
 821e1ec:	e0bffb17 	ldw	r2,-20(fp)
 821e1f0:	00ffffc4 	movi	r3,-1
 821e1f4:	10c00905 	stb	r3,36(r2)
  memset(sp->escape, 0, sizeof(sp->escape));
 821e1f8:	e0bffb17 	ldw	r2,-20(fp)
 821e1fc:	10800a04 	addi	r2,r2,40
 821e200:	01800204 	movi	r6,8
 821e204:	000b883a 	mov	r5,zero
 821e208:	1009883a 	mov	r4,r2
 821e20c:	82031b40 	call	82031b4 <memset>

  sp->scrollpos = 0;
 821e210:	e0bffb17 	ldw	r2,-20(fp)
 821e214:	10000945 	stb	zero,37(r2)
  sp->scrollmax = 0;
 821e218:	e0bffb17 	ldw	r2,-20(fp)
 821e21c:	10000985 	stb	zero,38(r2)
  sp->active = 0;
 821e220:	e0bffb17 	ldw	r2,-20(fp)
 821e224:	100009c5 	stb	zero,39(r2)
 821e228:	d0e0b817 	ldw	r3,-32032(gp)

  sp->period = alt_ticks_per_second() / 10; /* Call every 100ms */
 821e22c:	00b33374 	movhi	r2,52429
 821e230:	10b33344 	addi	r2,r2,-13107
 821e234:	1888383a 	mulxuu	r4,r3,r2
 821e238:	1885383a 	mul	r2,r3,r2
 821e23c:	1021883a 	mov	r16,r2
 821e240:	2023883a 	mov	r17,r4
 821e244:	8804d0fa 	srli	r2,r17,3
 821e248:	1007883a 	mov	r3,r2
 821e24c:	e0bffb17 	ldw	r2,-20(fp)
 821e250:	10c00715 	stw	r3,28(r2)

  alt_alarm_start(&sp->alarm, sp->period, &alt_lcd_16207_timeout, sp);
 821e254:	e0bffb17 	ldw	r2,-20(fp)
 821e258:	10c00104 	addi	r3,r2,4
 821e25c:	e0bffb17 	ldw	r2,-20(fp)
 821e260:	10800717 	ldw	r2,28(r2)
 821e264:	e1fffb17 	ldw	r7,-20(fp)
 821e268:	018208b4 	movhi	r6,2082
 821e26c:	31b81c04 	addi	r6,r6,-8080
 821e270:	100b883a 	mov	r5,r2
 821e274:	1809883a 	mov	r4,r3
 821e278:	823bad40 	call	823bad4 <alt_alarm_start>
}
 821e27c:	0001883a 	nop
 821e280:	e6fffe04 	addi	sp,fp,-8
 821e284:	dfc00317 	ldw	ra,12(sp)
 821e288:	df000217 	ldw	fp,8(sp)
 821e28c:	dc400117 	ldw	r17,4(sp)
 821e290:	dc000017 	ldw	r16,0(sp)
 821e294:	dec00404 	addi	sp,sp,16
 821e298:	f800283a 	ret

0821e29c <altera_avalon_lcd_16207_write_fd>:
extern int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp,
  const char* ptr, int count, int flags);

int 
altera_avalon_lcd_16207_write_fd(alt_fd* fd, const char* buffer, int space)
{
 821e29c:	defffa04 	addi	sp,sp,-24
 821e2a0:	dfc00515 	stw	ra,20(sp)
 821e2a4:	df000415 	stw	fp,16(sp)
 821e2a8:	df000404 	addi	fp,sp,16
 821e2ac:	e13ffd15 	stw	r4,-12(fp)
 821e2b0:	e17ffe15 	stw	r5,-8(fp)
 821e2b4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_lcd_16207_dev* dev = (altera_avalon_lcd_16207_dev*) fd->dev; 
 821e2b8:	e0bffd17 	ldw	r2,-12(fp)
 821e2bc:	10800017 	ldw	r2,0(r2)
 821e2c0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_lcd_16207_write(&dev->state, buffer, space,
 821e2c4:	e0bffc17 	ldw	r2,-16(fp)
 821e2c8:	10c00a04 	addi	r3,r2,40
 821e2cc:	e0bffd17 	ldw	r2,-12(fp)
 821e2d0:	10800217 	ldw	r2,8(r2)
 821e2d4:	100f883a 	mov	r7,r2
 821e2d8:	e1bfff17 	ldw	r6,-4(fp)
 821e2dc:	e17ffe17 	ldw	r5,-8(fp)
 821e2e0:	1809883a 	mov	r4,r3
 821e2e4:	821db600 	call	821db60 <altera_avalon_lcd_16207_write>
      fd->fd_flags);
}
 821e2e8:	e037883a 	mov	sp,fp
 821e2ec:	dfc00117 	ldw	ra,4(sp)
 821e2f0:	df000017 	ldw	fp,0(sp)
 821e2f4:	dec00204 	addi	sp,sp,8
 821e2f8:	f800283a 	ret

0821e2fc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 821e2fc:	defffe04 	addi	sp,sp,-8
 821e300:	dfc00115 	stw	ra,4(sp)
 821e304:	df000015 	stw	fp,0(sp)
 821e308:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 821e30c:	d0a04717 	ldw	r2,-32484(gp)
 821e310:	10000326 	beq	r2,zero,821e320 <alt_get_errno+0x24>
 821e314:	d0a04717 	ldw	r2,-32484(gp)
 821e318:	103ee83a 	callr	r2
 821e31c:	00000106 	br	821e324 <alt_get_errno+0x28>
 821e320:	d0a06304 	addi	r2,gp,-32372
}
 821e324:	e037883a 	mov	sp,fp
 821e328:	dfc00117 	ldw	ra,4(sp)
 821e32c:	df000017 	ldw	fp,0(sp)
 821e330:	dec00204 	addi	sp,sp,8
 821e334:	f800283a 	ret

0821e338 <alt_avalon_sgdma_do_async_transfer>:
 * - 0 for success, or various errors defined in <errno.h>
 */
int alt_avalon_sgdma_do_async_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 821e338:	defffc04 	addi	sp,sp,-16
 821e33c:	df000315 	stw	fp,12(sp)
 821e340:	df000304 	addi	fp,sp,12
 821e344:	e13ffe15 	stw	r4,-8(fp)
 821e348:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 821e34c:	e0bffe17 	ldw	r2,-8(fp)
 821e350:	10800317 	ldw	r2,12(r2)
 821e354:	10800037 	ldwio	r2,0(r2)
 821e358:	1080040c 	andi	r2,r2,16
 821e35c:	10000226 	beq	r2,zero,821e368 <alt_avalon_sgdma_do_async_transfer+0x30>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
 821e360:	00bffc04 	movi	r2,-16
 821e364:	00003906 	br	821e44c <alt_avalon_sgdma_do_async_transfer+0x114>
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821e368:	e0bffe17 	ldw	r2,-8(fp)
 821e36c:	10800317 	ldw	r2,12(r2)
 821e370:	10800404 	addi	r2,r2,16
 821e374:	e0fffe17 	ldw	r3,-8(fp)
 821e378:	18c00317 	ldw	r3,12(r3)
 821e37c:	18c00404 	addi	r3,r3,16
 821e380:	19000037 	ldwio	r4,0(r3)
 821e384:	00fff7c4 	movi	r3,-33
 821e388:	20c6703a 	and	r3,r4,r3
 821e38c:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 821e390:	e0bffe17 	ldw	r2,-8(fp)
 821e394:	10800317 	ldw	r2,12(r2)
 821e398:	00c03fc4 	movi	r3,255
 821e39c:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 821e3a0:	e0bffe17 	ldw	r2,-8(fp)
 821e3a4:	10800317 	ldw	r2,12(r2)
 821e3a8:	10800804 	addi	r2,r2,32
 821e3ac:	e0ffff17 	ldw	r3,-4(fp)
 821e3b0:	10c00035 	stwio	r3,0(r2)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
 821e3b4:	e0bffe17 	ldw	r2,-8(fp)
 821e3b8:	10800917 	ldw	r2,36(r2)
 821e3bc:	10001126 	beq	r2,zero,821e404 <alt_avalon_sgdma_do_async_transfer+0xcc>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e3c0:	e0bffe17 	ldw	r2,-8(fp)
 821e3c4:	10800317 	ldw	r2,12(r2)
 821e3c8:	10800404 	addi	r2,r2,16
 821e3cc:	10800037 	ldwio	r2,0(r2)
 821e3d0:	e0bffd15 	stw	r2,-12(fp)

    control |= (dev->chain_control                          |
 821e3d4:	e0bffe17 	ldw	r2,-8(fp)
 821e3d8:	10c00b17 	ldw	r3,44(r2)
 821e3dc:	e0bffd17 	ldw	r2,-12(fp)
 821e3e0:	1884b03a 	or	r2,r3,r2
 821e3e4:	10801814 	ori	r2,r2,96
 821e3e8:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e3ec:	e0bffe17 	ldw	r2,-8(fp)
 821e3f0:	10800317 	ldw	r2,12(r2)
 821e3f4:	10800404 	addi	r2,r2,16
 821e3f8:	e0fffd17 	ldw	r3,-12(fp)
 821e3fc:	10c00035 	stwio	r3,0(r2)
 821e400:	00001106 	br	821e448 <alt_avalon_sgdma_do_async_transfer+0x110>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e404:	e0bffe17 	ldw	r2,-8(fp)
 821e408:	10800317 	ldw	r2,12(r2)
 821e40c:	10800404 	addi	r2,r2,16
 821e410:	10800037 	ldwio	r2,0(r2)
 821e414:	e0bffd15 	stw	r2,-12(fp)

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
 821e418:	e0bffd17 	ldw	r2,-12(fp)
 821e41c:	10801814 	ori	r2,r2,96
 821e420:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;
 821e424:	e0fffd17 	ldw	r3,-12(fp)
 821e428:	00bffbc4 	movi	r2,-17
 821e42c:	1884703a 	and	r2,r3,r2
 821e430:	e0bffd15 	stw	r2,-12(fp)

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e434:	e0bffe17 	ldw	r2,-8(fp)
 821e438:	10800317 	ldw	r2,12(r2)
 821e43c:	10800404 	addi	r2,r2,16
 821e440:	e0fffd17 	ldw	r3,-12(fp)
 821e444:	10c00035 	stwio	r3,0(r2)

  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
 821e448:	0005883a 	mov	r2,zero
}
 821e44c:	e037883a 	mov	sp,fp
 821e450:	df000017 	ldw	fp,0(sp)
 821e454:	dec00104 	addi	sp,sp,4
 821e458:	f800283a 	ret

0821e45c <alt_avalon_sgdma_do_sync_transfer>:
 * - status: Content of SGDMA status register.
 */
alt_u8 alt_avalon_sgdma_do_sync_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 821e45c:	defffc04 	addi	sp,sp,-16
 821e460:	df000315 	stw	fp,12(sp)
 821e464:	df000304 	addi	fp,sp,12
 821e468:	e13ffe15 	stw	r4,-8(fp)
 821e46c:	e17fff15 	stw	r5,-4(fp)
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 821e470:	0001883a 	nop
 821e474:	e0bffe17 	ldw	r2,-8(fp)
 821e478:	10800317 	ldw	r2,12(r2)
 821e47c:	10800037 	ldwio	r2,0(r2)
 821e480:	1080040c 	andi	r2,r2,16
 821e484:	103ffb1e 	bne	r2,zero,821e474 <alt_avalon_sgdma_do_sync_transfer+0x18>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821e488:	e0bffe17 	ldw	r2,-8(fp)
 821e48c:	10800317 	ldw	r2,12(r2)
 821e490:	10800404 	addi	r2,r2,16
 821e494:	e0fffe17 	ldw	r3,-8(fp)
 821e498:	18c00317 	ldw	r3,12(r3)
 821e49c:	18c00404 	addi	r3,r3,16
 821e4a0:	19000037 	ldwio	r4,0(r3)
 821e4a4:	00fff7c4 	movi	r3,-33
 821e4a8:	20c6703a 	and	r3,r4,r3
 821e4ac:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 821e4b0:	e0bffe17 	ldw	r2,-8(fp)
 821e4b4:	10800317 	ldw	r2,12(r2)
 821e4b8:	00c03fc4 	movi	r3,255
 821e4bc:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 821e4c0:	e0bffe17 	ldw	r2,-8(fp)
 821e4c4:	10800317 	ldw	r2,12(r2)
 821e4c8:	10800804 	addi	r2,r2,32
 821e4cc:	e0ffff17 	ldw	r3,-4(fp)
 821e4d0:	10c00035 	stwio	r3,0(r2)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821e4d4:	e0bffe17 	ldw	r2,-8(fp)
 821e4d8:	10800317 	ldw	r2,12(r2)
 821e4dc:	10800404 	addi	r2,r2,16
 821e4e0:	e0fffe17 	ldw	r3,-8(fp)
 821e4e4:	18c00317 	ldw	r3,12(r3)
 821e4e8:	18c00404 	addi	r3,r3,16
 821e4ec:	18c00037 	ldwio	r3,0(r3)
 821e4f0:	18c01814 	ori	r3,r3,96
 821e4f4:	10c00035 	stwio	r3,0(r2)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 821e4f8:	0001883a 	nop
 821e4fc:	e0bffe17 	ldw	r2,-8(fp)
 821e500:	10800317 	ldw	r2,12(r2)
 821e504:	10800037 	ldwio	r2,0(r2)
 821e508:	1080040c 	andi	r2,r2,16
 821e50c:	103ffb1e 	bne	r2,zero,821e4fc <alt_avalon_sgdma_do_sync_transfer+0xa0>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 821e510:	e0bffe17 	ldw	r2,-8(fp)
 821e514:	10800317 	ldw	r2,12(r2)
 821e518:	10800404 	addi	r2,r2,16
 821e51c:	e0fffe17 	ldw	r3,-8(fp)
 821e520:	18c00317 	ldw	r3,12(r3)
 821e524:	18c00404 	addi	r3,r3,16
 821e528:	19000037 	ldwio	r4,0(r3)
 821e52c:	00fff7c4 	movi	r3,-33
 821e530:	20c6703a 	and	r3,r4,r3
 821e534:	10c00035 	stwio	r3,0(r2)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
 821e538:	e0bffe17 	ldw	r2,-8(fp)
 821e53c:	10800317 	ldw	r2,12(r2)
 821e540:	10800037 	ldwio	r2,0(r2)
 821e544:	e0bffd05 	stb	r2,-12(fp)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 821e548:	e0bffe17 	ldw	r2,-8(fp)
 821e54c:	10800317 	ldw	r2,12(r2)
 821e550:	00c03fc4 	movi	r3,255
 821e554:	10c00035 	stwio	r3,0(r2)

  return status;
 821e558:	e0bffd03 	ldbu	r2,-12(fp)
}
 821e55c:	e037883a 	mov	sp,fp
 821e560:	df000017 	ldw	fp,0(sp)
 821e564:	dec00104 	addi	sp,sp,4
 821e568:	f800283a 	ret

0821e56c <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
 821e56c:	defff404 	addi	sp,sp,-48
 821e570:	dfc00b15 	stw	ra,44(sp)
 821e574:	df000a15 	stw	fp,40(sp)
 821e578:	df000a04 	addi	fp,sp,40
 821e57c:	e13ffb15 	stw	r4,-20(fp)
 821e580:	e17ffc15 	stw	r5,-16(fp)
 821e584:	e1bffd15 	stw	r6,-12(fp)
 821e588:	e1fffe15 	stw	r7,-8(fp)
 821e58c:	e0800217 	ldw	r2,8(fp)
 821e590:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
 821e594:	e0bfff0b 	ldhu	r2,-4(fp)
 821e598:	d8000415 	stw	zero,16(sp)
 821e59c:	d8000315 	stw	zero,12(sp)
 821e5a0:	e0c00417 	ldw	r3,16(fp)
 821e5a4:	d8c00215 	stw	r3,8(sp)
 821e5a8:	e0c00317 	ldw	r3,12(fp)
 821e5ac:	d8c00115 	stw	r3,4(sp)
 821e5b0:	d8800015 	stw	r2,0(sp)
 821e5b4:	e1fffe17 	ldw	r7,-8(fp)
 821e5b8:	e1bffd17 	ldw	r6,-12(fp)
 821e5bc:	e17ffc17 	ldw	r5,-16(fp)
 821e5c0:	e13ffb17 	ldw	r4,-20(fp)
 821e5c4:	821e5e00 	call	821e5e0 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
 821e5c8:	0001883a 	nop
 821e5cc:	e037883a 	mov	sp,fp
 821e5d0:	dfc00117 	ldw	ra,4(sp)
 821e5d4:	df000017 	ldw	fp,0(sp)
 821e5d8:	dec00204 	addi	sp,sp,8
 821e5dc:	f800283a 	ret

0821e5e0 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
 821e5e0:	defff204 	addi	sp,sp,-56
 821e5e4:	dfc00d15 	stw	ra,52(sp)
 821e5e8:	df000c15 	stw	fp,48(sp)
 821e5ec:	df000c04 	addi	fp,sp,48
 821e5f0:	e13ffb15 	stw	r4,-20(fp)
 821e5f4:	e17ffc15 	stw	r5,-16(fp)
 821e5f8:	e1bffd15 	stw	r6,-12(fp)
 821e5fc:	e1fffe15 	stw	r7,-8(fp)
 821e600:	e0800217 	ldw	r2,8(fp)
 821e604:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 821e608:	e0bfff0b 	ldhu	r2,-4(fp)
 821e60c:	d8000615 	stw	zero,24(sp)
 821e610:	e0c00617 	ldw	r3,24(fp)
 821e614:	d8c00515 	stw	r3,20(sp)
 821e618:	e0c00517 	ldw	r3,20(fp)
 821e61c:	d8c00415 	stw	r3,16(sp)
 821e620:	e0c00417 	ldw	r3,16(fp)
 821e624:	d8c00315 	stw	r3,12(sp)
 821e628:	e0c00317 	ldw	r3,12(fp)
 821e62c:	d8c00215 	stw	r3,8(sp)
 821e630:	d8000115 	stw	zero,4(sp)
 821e634:	d8800015 	stw	r2,0(sp)
 821e638:	e1fffe17 	ldw	r7,-8(fp)
 821e63c:	e1bffd17 	ldw	r6,-12(fp)
 821e640:	e17ffc17 	ldw	r5,-16(fp)
 821e644:	e13ffb17 	ldw	r4,-20(fp)
 821e648:	821eb740 	call	821eb74 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
 821e64c:	0001883a 	nop
 821e650:	e037883a 	mov	sp,fp
 821e654:	dfc00117 	ldw	ra,4(sp)
 821e658:	df000017 	ldw	fp,0(sp)
 821e65c:	dec00204 	addi	sp,sp,8
 821e660:	f800283a 	ret

0821e664 <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
 821e664:	defff804 	addi	sp,sp,-32
 821e668:	dfc00715 	stw	ra,28(sp)
 821e66c:	df000615 	stw	fp,24(sp)
 821e670:	df000604 	addi	fp,sp,24
 821e674:	e13ffc15 	stw	r4,-16(fp)
 821e678:	e17ffd15 	stw	r5,-12(fp)
 821e67c:	e1bffe15 	stw	r6,-8(fp)
 821e680:	3805883a 	mov	r2,r7
 821e684:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
 821e688:	e0ffff0b 	ldhu	r3,-4(fp)
 821e68c:	d8000115 	stw	zero,4(sp)
 821e690:	e0800217 	ldw	r2,8(fp)
 821e694:	d8800015 	stw	r2,0(sp)
 821e698:	180f883a 	mov	r7,r3
 821e69c:	e1bffe17 	ldw	r6,-8(fp)
 821e6a0:	e17ffd17 	ldw	r5,-12(fp)
 821e6a4:	e13ffc17 	ldw	r4,-16(fp)
 821e6a8:	821e6c40 	call	821e6c4 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
 821e6ac:	0001883a 	nop
 821e6b0:	e037883a 	mov	sp,fp
 821e6b4:	dfc00117 	ldw	ra,4(sp)
 821e6b8:	df000017 	ldw	fp,0(sp)
 821e6bc:	dec00204 	addi	sp,sp,8
 821e6c0:	f800283a 	ret

0821e6c4 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
 821e6c4:	defff304 	addi	sp,sp,-52
 821e6c8:	dfc00c15 	stw	ra,48(sp)
 821e6cc:	df000b15 	stw	fp,44(sp)
 821e6d0:	df000b04 	addi	fp,sp,44
 821e6d4:	e13ffc15 	stw	r4,-16(fp)
 821e6d8:	e17ffd15 	stw	r5,-12(fp)
 821e6dc:	e1bffe15 	stw	r6,-8(fp)
 821e6e0:	3805883a 	mov	r2,r7
 821e6e4:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 821e6e8:	e0bfff0b 	ldhu	r2,-4(fp)
 821e6ec:	d8000615 	stw	zero,24(sp)
 821e6f0:	e0c00317 	ldw	r3,12(fp)
 821e6f4:	d8c00515 	stw	r3,20(sp)
 821e6f8:	d8000415 	stw	zero,16(sp)
 821e6fc:	e0c00217 	ldw	r3,8(fp)
 821e700:	d8c00315 	stw	r3,12(sp)
 821e704:	d8000215 	stw	zero,8(sp)
 821e708:	d8000115 	stw	zero,4(sp)
 821e70c:	d8800015 	stw	r2,0(sp)
 821e710:	e1fffe17 	ldw	r7,-8(fp)
 821e714:	000d883a 	mov	r6,zero
 821e718:	e17ffd17 	ldw	r5,-12(fp)
 821e71c:	e13ffc17 	ldw	r4,-16(fp)
 821e720:	821eb740 	call	821eb74 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
 821e724:	0001883a 	nop
 821e728:	e037883a 	mov	sp,fp
 821e72c:	dfc00117 	ldw	ra,4(sp)
 821e730:	df000017 	ldw	fp,0(sp)
 821e734:	dec00204 	addi	sp,sp,8
 821e738:	f800283a 	ret

0821e73c <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
 821e73c:	defff404 	addi	sp,sp,-48
 821e740:	dfc00b15 	stw	ra,44(sp)
 821e744:	df000a15 	stw	fp,40(sp)
 821e748:	df000a04 	addi	fp,sp,40
 821e74c:	e13ffb15 	stw	r4,-20(fp)
 821e750:	e17ffc15 	stw	r5,-16(fp)
 821e754:	e1bffd15 	stw	r6,-12(fp)
 821e758:	3807883a 	mov	r3,r7
 821e75c:	e0800517 	ldw	r2,20(fp)
 821e760:	e0fffe0d 	sth	r3,-8(fp)
 821e764:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
 821e768:	e0fffe0b 	ldhu	r3,-8(fp)
 821e76c:	e0bfff03 	ldbu	r2,-4(fp)
 821e770:	d8800415 	stw	r2,16(sp)
 821e774:	d8000315 	stw	zero,12(sp)
 821e778:	e0800417 	ldw	r2,16(fp)
 821e77c:	d8800215 	stw	r2,8(sp)
 821e780:	e0800317 	ldw	r2,12(fp)
 821e784:	d8800115 	stw	r2,4(sp)
 821e788:	e0800217 	ldw	r2,8(fp)
 821e78c:	d8800015 	stw	r2,0(sp)
 821e790:	180f883a 	mov	r7,r3
 821e794:	e1bffd17 	ldw	r6,-12(fp)
 821e798:	e17ffc17 	ldw	r5,-16(fp)
 821e79c:	e13ffb17 	ldw	r4,-20(fp)
 821e7a0:	821e7bc0 	call	821e7bc <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
 821e7a4:	0001883a 	nop
 821e7a8:	e037883a 	mov	sp,fp
 821e7ac:	dfc00117 	ldw	ra,4(sp)
 821e7b0:	df000017 	ldw	fp,0(sp)
 821e7b4:	dec00204 	addi	sp,sp,8
 821e7b8:	f800283a 	ret

0821e7bc <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
 821e7bc:	defff204 	addi	sp,sp,-56
 821e7c0:	dfc00d15 	stw	ra,52(sp)
 821e7c4:	df000c15 	stw	fp,48(sp)
 821e7c8:	df000c04 	addi	fp,sp,48
 821e7cc:	e13ffb15 	stw	r4,-20(fp)
 821e7d0:	e17ffc15 	stw	r5,-16(fp)
 821e7d4:	e1bffd15 	stw	r6,-12(fp)
 821e7d8:	3807883a 	mov	r3,r7
 821e7dc:	e0800617 	ldw	r2,24(fp)
 821e7e0:	e0fffe0d 	sth	r3,-8(fp)
 821e7e4:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 821e7e8:	e0bffe0b 	ldhu	r2,-8(fp)
 821e7ec:	e0ffff03 	ldbu	r3,-4(fp)
 821e7f0:	d8c00615 	stw	r3,24(sp)
 821e7f4:	d8000515 	stw	zero,20(sp)
 821e7f8:	e0c00517 	ldw	r3,20(fp)
 821e7fc:	d8c00415 	stw	r3,16(sp)
 821e800:	e0c00317 	ldw	r3,12(fp)
 821e804:	d8c00315 	stw	r3,12(sp)
 821e808:	e0c00217 	ldw	r3,8(fp)
 821e80c:	d8c00215 	stw	r3,8(sp)
 821e810:	e0c00417 	ldw	r3,16(fp)
 821e814:	d8c00115 	stw	r3,4(sp)
 821e818:	d8800015 	stw	r2,0(sp)
 821e81c:	000f883a 	mov	r7,zero
 821e820:	e1bffd17 	ldw	r6,-12(fp)
 821e824:	e17ffc17 	ldw	r5,-16(fp)
 821e828:	e13ffb17 	ldw	r4,-20(fp)
 821e82c:	821eb740 	call	821eb74 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
 821e830:	0001883a 	nop
 821e834:	e037883a 	mov	sp,fp
 821e838:	dfc00117 	ldw	ra,4(sp)
 821e83c:	df000017 	ldw	fp,0(sp)
 821e840:	dec00204 	addi	sp,sp,8
 821e844:	f800283a 	ret

0821e848 <alt_avalon_sgdma_register_callback>:
void alt_avalon_sgdma_register_callback(
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
 821e848:	defffb04 	addi	sp,sp,-20
 821e84c:	df000415 	stw	fp,16(sp)
 821e850:	df000404 	addi	fp,sp,16
 821e854:	e13ffc15 	stw	r4,-16(fp)
 821e858:	e17ffd15 	stw	r5,-12(fp)
 821e85c:	e1bffe15 	stw	r6,-8(fp)
 821e860:	e1ffff15 	stw	r7,-4(fp)
  dev->callback         = callback;
 821e864:	e0bffc17 	ldw	r2,-16(fp)
 821e868:	e0fffd17 	ldw	r3,-12(fp)
 821e86c:	10c00915 	stw	r3,36(r2)
  dev->callback_context = context;
 821e870:	e0bffc17 	ldw	r2,-16(fp)
 821e874:	e0ffff17 	ldw	r3,-4(fp)
 821e878:	10c00a15 	stw	r3,40(r2)
  dev->chain_control    = chain_control;
 821e87c:	e0bffc17 	ldw	r2,-16(fp)
 821e880:	e0fffe17 	ldw	r3,-8(fp)
 821e884:	10c00b15 	stw	r3,44(r2)
}
 821e888:	0001883a 	nop
 821e88c:	e037883a 	mov	sp,fp
 821e890:	df000017 	ldw	fp,0(sp)
 821e894:	dec00104 	addi	sp,sp,4
 821e898:	f800283a 	ret

0821e89c <alt_avalon_sgdma_start>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct.
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
 821e89c:	defffd04 	addi	sp,sp,-12
 821e8a0:	df000215 	stw	fp,8(sp)
 821e8a4:	df000204 	addi	fp,sp,8
 821e8a8:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e8ac:	e0bfff17 	ldw	r2,-4(fp)
 821e8b0:	10800317 	ldw	r2,12(r2)
 821e8b4:	10800404 	addi	r2,r2,16
 821e8b8:	10800037 	ldwio	r2,0(r2)
 821e8bc:	e0bffe15 	stw	r2,-8(fp)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 821e8c0:	e0bffe17 	ldw	r2,-8(fp)
 821e8c4:	10800814 	ori	r2,r2,32
 821e8c8:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e8cc:	e0bfff17 	ldw	r2,-4(fp)
 821e8d0:	10800317 	ldw	r2,12(r2)
 821e8d4:	10800404 	addi	r2,r2,16
 821e8d8:	e0fffe17 	ldw	r3,-8(fp)
 821e8dc:	10c00035 	stwio	r3,0(r2)
}
 821e8e0:	0001883a 	nop
 821e8e4:	e037883a 	mov	sp,fp
 821e8e8:	df000017 	ldw	fp,0(sp)
 821e8ec:	dec00104 	addi	sp,sp,4
 821e8f0:	f800283a 	ret

0821e8f4 <alt_avalon_sgdma_stop>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
 821e8f4:	defffd04 	addi	sp,sp,-12
 821e8f8:	df000215 	stw	fp,8(sp)
 821e8fc:	df000204 	addi	fp,sp,8
 821e900:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e904:	e0bfff17 	ldw	r2,-4(fp)
 821e908:	10800317 	ldw	r2,12(r2)
 821e90c:	10800404 	addi	r2,r2,16
 821e910:	10800037 	ldwio	r2,0(r2)
 821e914:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 821e918:	e0fffe17 	ldw	r3,-8(fp)
 821e91c:	00bff7c4 	movi	r2,-33
 821e920:	1884703a 	and	r2,r3,r2
 821e924:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e928:	e0bfff17 	ldw	r2,-4(fp)
 821e92c:	10800317 	ldw	r2,12(r2)
 821e930:	10800404 	addi	r2,r2,16
 821e934:	e0fffe17 	ldw	r3,-8(fp)
 821e938:	10c00035 	stwio	r3,0(r2)
}
 821e93c:	0001883a 	nop
 821e940:	e037883a 	mov	sp,fp
 821e944:	df000017 	ldw	fp,0(sp)
 821e948:	dec00104 	addi	sp,sp,4
 821e94c:	f800283a 	ret

0821e950 <alt_avalon_sgdma_check_descriptor_status>:
 * - 0 if the descriptor is error-free, not "owned by hardware", or
 *   a previously requested transfer has appeared to have completed
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
 821e950:	defffe04 	addi	sp,sp,-8
 821e954:	df000115 	stw	fp,4(sp)
 821e958:	df000104 	addi	fp,sp,4
 821e95c:	e13fff15 	stw	r4,-4(fp)
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
 821e960:	e0bfff17 	ldw	r2,-4(fp)
 821e964:	10800784 	addi	r2,r2,30
 821e968:	10800023 	ldbuio	r2,0(r2)
 821e96c:	10803fcc 	andi	r2,r2,255
 821e970:	10801fcc 	andi	r2,r2,127
 821e974:	10000226 	beq	r2,zero,821e980 <alt_avalon_sgdma_check_descriptor_status+0x30>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
 821e978:	00bffec4 	movi	r2,-5
 821e97c:	00000906 	br	821e9a4 <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

  if( IORD_8DIRECT(&desc->control, 0) &
 821e980:	e0bfff17 	ldw	r2,-4(fp)
 821e984:	108007c4 	addi	r2,r2,31
 821e988:	10800023 	ldbuio	r2,0(r2)
 821e98c:	10803fcc 	andi	r2,r2,255
 821e990:	1080200c 	andi	r2,r2,128
 821e994:	10000226 	beq	r2,zero,821e9a0 <alt_avalon_sgdma_check_descriptor_status+0x50>
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
 821e998:	00bfe244 	movi	r2,-119
 821e99c:	00000106 	br	821e9a4 <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

    return 0;
 821e9a0:	0005883a 	mov	r2,zero
}
 821e9a4:	e037883a 	mov	sp,fp
 821e9a8:	df000017 	ldw	fp,0(sp)
 821e9ac:	dec00104 	addi	sp,sp,4
 821e9b0:	f800283a 	ret

0821e9b4 <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
 821e9b4:	defffc04 	addi	sp,sp,-16
 821e9b8:	dfc00315 	stw	ra,12(sp)
 821e9bc:	df000215 	stw	fp,8(sp)
 821e9c0:	df000204 	addi	fp,sp,8
 821e9c4:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
 821e9c8:	d1602b04 	addi	r5,gp,-32596
 821e9cc:	e13fff17 	ldw	r4,-4(fp)
 821e9d0:	823bf500 	call	823bf50 <alt_find_dev>
 821e9d4:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev) {
 821e9d8:	e0bffe17 	ldw	r2,-8(fp)
 821e9dc:	1000041e 	bne	r2,zero,821e9f0 <alt_avalon_sgdma_open+0x3c>
    ALT_ERRNO = ENODEV;
 821e9e0:	821e2fc0 	call	821e2fc <alt_get_errno>
 821e9e4:	1007883a 	mov	r3,r2
 821e9e8:	008004c4 	movi	r2,19
 821e9ec:	18800015 	stw	r2,0(r3)
  }

  return dev;
 821e9f0:	e0bffe17 	ldw	r2,-8(fp)
}
 821e9f4:	e037883a 	mov	sp,fp
 821e9f8:	dfc00117 	ldw	ra,4(sp)
 821e9fc:	df000017 	ldw	fp,0(sp)
 821ea00:	dec00204 	addi	sp,sp,8
 821ea04:	f800283a 	ret

0821ea08 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
 821ea08:	defff104 	addi	sp,sp,-60
 821ea0c:	dfc00e15 	stw	ra,56(sp)
 821ea10:	df000d15 	stw	fp,52(sp)
 821ea14:	df000d04 	addi	fp,sp,52
 821ea18:	e13ffa15 	stw	r4,-24(fp)
 821ea1c:	e17ffb15 	stw	r5,-20(fp)
 821ea20:	e1bffc15 	stw	r6,-16(fp)
 821ea24:	e1fffd15 	stw	r7,-12(fp)
 821ea28:	e0c00217 	ldw	r3,8(fp)
 821ea2c:	e0800617 	ldw	r2,24(fp)
 821ea30:	e0fffe0d 	sth	r3,-8(fp)
 821ea34:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
 821ea38:	e0bffe0b 	ldhu	r2,-8(fp)
 821ea3c:	e0ffff03 	ldbu	r3,-4(fp)
 821ea40:	d8c00615 	stw	r3,24(sp)
 821ea44:	d8000515 	stw	zero,20(sp)
 821ea48:	d8000415 	stw	zero,16(sp)
 821ea4c:	e0c00517 	ldw	r3,20(fp)
 821ea50:	d8c00315 	stw	r3,12(sp)
 821ea54:	e0c00417 	ldw	r3,16(fp)
 821ea58:	d8c00215 	stw	r3,8(sp)
 821ea5c:	e0c00317 	ldw	r3,12(fp)
 821ea60:	d8c00115 	stw	r3,4(sp)
 821ea64:	d8800015 	stw	r2,0(sp)
 821ea68:	e1fffd17 	ldw	r7,-12(fp)
 821ea6c:	e1bffc17 	ldw	r6,-16(fp)
 821ea70:	e17ffb17 	ldw	r5,-20(fp)
 821ea74:	e13ffa17 	ldw	r4,-24(fp)
 821ea78:	821eb740 	call	821eb74 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
 821ea7c:	0001883a 	nop
 821ea80:	e037883a 	mov	sp,fp
 821ea84:	dfc00117 	ldw	ra,4(sp)
 821ea88:	df000017 	ldw	fp,0(sp)
 821ea8c:	dec00204 	addi	sp,sp,8
 821ea90:	f800283a 	ret

0821ea94 <alt_avalon_sgdma_enable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
 821ea94:	defffc04 	addi	sp,sp,-16
 821ea98:	df000315 	stw	fp,12(sp)
 821ea9c:	df000304 	addi	fp,sp,12
 821eaa0:	e13ffe15 	stw	r4,-8(fp)
 821eaa4:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821eaa8:	e0bffe17 	ldw	r2,-8(fp)
 821eaac:	10800317 	ldw	r2,12(r2)
 821eab0:	10800404 	addi	r2,r2,16
 821eab4:	10800037 	ldwio	r2,0(r2)
 821eab8:	e0bffd15 	stw	r2,-12(fp)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
 821eabc:	e0fffd17 	ldw	r3,-12(fp)
 821eac0:	00a00434 	movhi	r2,32784
 821eac4:	10bfffc4 	addi	r2,r2,-1
 821eac8:	1884703a 	and	r2,r3,r2
 821eacc:	e0bffd15 	stw	r2,-12(fp)
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
 821ead0:	e0bfff17 	ldw	r2,-4(fp)
 821ead4:	1004953a 	slli	r2,r2,20
 821ead8:	10dffc2c 	andhi	r3,r2,32752

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
 821eadc:	e0bffd17 	ldw	r2,-12(fp)
 821eae0:	1884b03a 	or	r2,r3,r2
 821eae4:	10800134 	orhi	r2,r2,4
 821eae8:	e0bffd15 	stw	r2,-12(fp)
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821eaec:	e0bffe17 	ldw	r2,-8(fp)
 821eaf0:	10800317 	ldw	r2,12(r2)
 821eaf4:	10800404 	addi	r2,r2,16
 821eaf8:	e0fffd17 	ldw	r3,-12(fp)
 821eafc:	10c00035 	stwio	r3,0(r2)
  
  return;
 821eb00:	0001883a 	nop
}
 821eb04:	e037883a 	mov	sp,fp
 821eb08:	df000017 	ldw	fp,0(sp)
 821eb0c:	dec00104 	addi	sp,sp,4
 821eb10:	f800283a 	ret

0821eb14 <alt_avalon_sgdma_disable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
 821eb14:	defffd04 	addi	sp,sp,-12
 821eb18:	df000215 	stw	fp,8(sp)
 821eb1c:	df000204 	addi	fp,sp,8
 821eb20:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821eb24:	e0bfff17 	ldw	r2,-4(fp)
 821eb28:	10800317 	ldw	r2,12(r2)
 821eb2c:	10800404 	addi	r2,r2,16
 821eb30:	10800037 	ldwio	r2,0(r2)
 821eb34:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;
 821eb38:	e0fffe17 	ldw	r3,-8(fp)
 821eb3c:	00bfff34 	movhi	r2,65532
 821eb40:	10bfffc4 	addi	r2,r2,-1
 821eb44:	1884703a 	and	r2,r3,r2
 821eb48:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821eb4c:	e0bfff17 	ldw	r2,-4(fp)
 821eb50:	10800317 	ldw	r2,12(r2)
 821eb54:	10800404 	addi	r2,r2,16
 821eb58:	e0fffe17 	ldw	r3,-8(fp)
 821eb5c:	10c00035 	stwio	r3,0(r2)
  
  return;
 821eb60:	0001883a 	nop
}
 821eb64:	e037883a 	mov	sp,fp
 821eb68:	df000017 	ldw	fp,0(sp)
 821eb6c:	dec00104 	addi	sp,sp,4
 821eb70:	f800283a 	ret

0821eb74 <alt_avalon_sgdma_construct_descriptor_burst>:
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
 821eb74:	defff804 	addi	sp,sp,-32
 821eb78:	dfc00715 	stw	ra,28(sp)
 821eb7c:	df000615 	stw	fp,24(sp)
 821eb80:	df000604 	addi	fp,sp,24
 821eb84:	e13ffa15 	stw	r4,-24(fp)
 821eb88:	e17ffb15 	stw	r5,-20(fp)
 821eb8c:	e1bffc15 	stw	r6,-16(fp)
 821eb90:	e1fffd15 	stw	r7,-12(fp)
 821eb94:	e0c00217 	ldw	r3,8(fp)
 821eb98:	e0800817 	ldw	r2,32(fp)
 821eb9c:	e0fffe0d 	sth	r3,-8(fp)
 821eba0:	e0bfff05 	stb	r2,-4(fp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
 821eba4:	e0bffb17 	ldw	r2,-20(fp)
 821eba8:	108007c4 	addi	r2,r2,31
 821ebac:	e0fffb17 	ldw	r3,-20(fp)
 821ebb0:	18c007c3 	ldbu	r3,31(r3)
 821ebb4:	19003fcc 	andi	r4,r3,255
 821ebb8:	00ffdfc4 	movi	r3,-129
 821ebbc:	20c6703a 	and	r3,r4,r3
 821ebc0:	10c00025 	stbio	r3,0(r2)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
 821ebc4:	e0bffa17 	ldw	r2,-24(fp)
 821ebc8:	e0fffc17 	ldw	r3,-16(fp)
 821ebcc:	19403fcc 	andi	r5,r3,255
 821ebd0:	10c00003 	ldbu	r3,0(r2)
 821ebd4:	1806703a 	and	r3,r3,zero
 821ebd8:	1809883a 	mov	r4,r3
 821ebdc:	2807883a 	mov	r3,r5
 821ebe0:	20c6b03a 	or	r3,r4,r3
 821ebe4:	10c00005 	stb	r3,0(r2)
 821ebe8:	e0fffc17 	ldw	r3,-16(fp)
 821ebec:	1806d23a 	srli	r3,r3,8
 821ebf0:	19403fcc 	andi	r5,r3,255
 821ebf4:	10c00043 	ldbu	r3,1(r2)
 821ebf8:	1806703a 	and	r3,r3,zero
 821ebfc:	1809883a 	mov	r4,r3
 821ec00:	2807883a 	mov	r3,r5
 821ec04:	20c6b03a 	or	r3,r4,r3
 821ec08:	10c00045 	stb	r3,1(r2)
 821ec0c:	e0fffc17 	ldw	r3,-16(fp)
 821ec10:	1806d43a 	srli	r3,r3,16
 821ec14:	19403fcc 	andi	r5,r3,255
 821ec18:	10c00083 	ldbu	r3,2(r2)
 821ec1c:	1806703a 	and	r3,r3,zero
 821ec20:	1809883a 	mov	r4,r3
 821ec24:	2807883a 	mov	r3,r5
 821ec28:	20c6b03a 	or	r3,r4,r3
 821ec2c:	10c00085 	stb	r3,2(r2)
 821ec30:	e0fffc17 	ldw	r3,-16(fp)
 821ec34:	180ad63a 	srli	r5,r3,24
 821ec38:	10c000c3 	ldbu	r3,3(r2)
 821ec3c:	1806703a 	and	r3,r3,zero
 821ec40:	1809883a 	mov	r4,r3
 821ec44:	2807883a 	mov	r3,r5
 821ec48:	20c6b03a 	or	r3,r4,r3
 821ec4c:	10c000c5 	stb	r3,3(r2)
  desc->write_addr               = write_addr;
 821ec50:	e0bffa17 	ldw	r2,-24(fp)
 821ec54:	e0fffd17 	ldw	r3,-12(fp)
 821ec58:	19403fcc 	andi	r5,r3,255
 821ec5c:	10c00203 	ldbu	r3,8(r2)
 821ec60:	1806703a 	and	r3,r3,zero
 821ec64:	1809883a 	mov	r4,r3
 821ec68:	2807883a 	mov	r3,r5
 821ec6c:	20c6b03a 	or	r3,r4,r3
 821ec70:	10c00205 	stb	r3,8(r2)
 821ec74:	e0fffd17 	ldw	r3,-12(fp)
 821ec78:	1806d23a 	srli	r3,r3,8
 821ec7c:	19403fcc 	andi	r5,r3,255
 821ec80:	10c00243 	ldbu	r3,9(r2)
 821ec84:	1806703a 	and	r3,r3,zero
 821ec88:	1809883a 	mov	r4,r3
 821ec8c:	2807883a 	mov	r3,r5
 821ec90:	20c6b03a 	or	r3,r4,r3
 821ec94:	10c00245 	stb	r3,9(r2)
 821ec98:	e0fffd17 	ldw	r3,-12(fp)
 821ec9c:	1806d43a 	srli	r3,r3,16
 821eca0:	19403fcc 	andi	r5,r3,255
 821eca4:	10c00283 	ldbu	r3,10(r2)
 821eca8:	1806703a 	and	r3,r3,zero
 821ecac:	1809883a 	mov	r4,r3
 821ecb0:	2807883a 	mov	r3,r5
 821ecb4:	20c6b03a 	or	r3,r4,r3
 821ecb8:	10c00285 	stb	r3,10(r2)
 821ecbc:	e0fffd17 	ldw	r3,-12(fp)
 821ecc0:	180ad63a 	srli	r5,r3,24
 821ecc4:	10c002c3 	ldbu	r3,11(r2)
 821ecc8:	1806703a 	and	r3,r3,zero
 821eccc:	1809883a 	mov	r4,r3
 821ecd0:	2807883a 	mov	r3,r5
 821ecd4:	20c6b03a 	or	r3,r4,r3
 821ecd8:	10c002c5 	stb	r3,11(r2)
  desc->next                     = (alt_u32 *) next;
 821ecdc:	e0bffa17 	ldw	r2,-24(fp)
 821ece0:	e0fffb17 	ldw	r3,-20(fp)
 821ece4:	19403fcc 	andi	r5,r3,255
 821ece8:	10c00403 	ldbu	r3,16(r2)
 821ecec:	1806703a 	and	r3,r3,zero
 821ecf0:	1809883a 	mov	r4,r3
 821ecf4:	2807883a 	mov	r3,r5
 821ecf8:	20c6b03a 	or	r3,r4,r3
 821ecfc:	10c00405 	stb	r3,16(r2)
 821ed00:	e0fffb17 	ldw	r3,-20(fp)
 821ed04:	1806d23a 	srli	r3,r3,8
 821ed08:	19403fcc 	andi	r5,r3,255
 821ed0c:	10c00443 	ldbu	r3,17(r2)
 821ed10:	1806703a 	and	r3,r3,zero
 821ed14:	1809883a 	mov	r4,r3
 821ed18:	2807883a 	mov	r3,r5
 821ed1c:	20c6b03a 	or	r3,r4,r3
 821ed20:	10c00445 	stb	r3,17(r2)
 821ed24:	e0fffb17 	ldw	r3,-20(fp)
 821ed28:	1806d43a 	srli	r3,r3,16
 821ed2c:	19403fcc 	andi	r5,r3,255
 821ed30:	10c00483 	ldbu	r3,18(r2)
 821ed34:	1806703a 	and	r3,r3,zero
 821ed38:	1809883a 	mov	r4,r3
 821ed3c:	2807883a 	mov	r3,r5
 821ed40:	20c6b03a 	or	r3,r4,r3
 821ed44:	10c00485 	stb	r3,18(r2)
 821ed48:	e0fffb17 	ldw	r3,-20(fp)
 821ed4c:	180ad63a 	srli	r5,r3,24
 821ed50:	10c004c3 	ldbu	r3,19(r2)
 821ed54:	1806703a 	and	r3,r3,zero
 821ed58:	1809883a 	mov	r4,r3
 821ed5c:	2807883a 	mov	r3,r5
 821ed60:	20c6b03a 	or	r3,r4,r3
 821ed64:	10c004c5 	stb	r3,19(r2)
  desc->read_addr_pad            = 0x0;
 821ed68:	e0bffa17 	ldw	r2,-24(fp)
 821ed6c:	10c00103 	ldbu	r3,4(r2)
 821ed70:	1806703a 	and	r3,r3,zero
 821ed74:	10c00105 	stb	r3,4(r2)
 821ed78:	10c00143 	ldbu	r3,5(r2)
 821ed7c:	1806703a 	and	r3,r3,zero
 821ed80:	10c00145 	stb	r3,5(r2)
 821ed84:	10c00183 	ldbu	r3,6(r2)
 821ed88:	1806703a 	and	r3,r3,zero
 821ed8c:	10c00185 	stb	r3,6(r2)
 821ed90:	10c001c3 	ldbu	r3,7(r2)
 821ed94:	1806703a 	and	r3,r3,zero
 821ed98:	10c001c5 	stb	r3,7(r2)
  desc->write_addr_pad           = 0x0;
 821ed9c:	e0bffa17 	ldw	r2,-24(fp)
 821eda0:	10c00303 	ldbu	r3,12(r2)
 821eda4:	1806703a 	and	r3,r3,zero
 821eda8:	10c00305 	stb	r3,12(r2)
 821edac:	10c00343 	ldbu	r3,13(r2)
 821edb0:	1806703a 	and	r3,r3,zero
 821edb4:	10c00345 	stb	r3,13(r2)
 821edb8:	10c00383 	ldbu	r3,14(r2)
 821edbc:	1806703a 	and	r3,r3,zero
 821edc0:	10c00385 	stb	r3,14(r2)
 821edc4:	10c003c3 	ldbu	r3,15(r2)
 821edc8:	1806703a 	and	r3,r3,zero
 821edcc:	10c003c5 	stb	r3,15(r2)
  desc->next_pad                 = 0x0;
 821edd0:	e0bffa17 	ldw	r2,-24(fp)
 821edd4:	10c00503 	ldbu	r3,20(r2)
 821edd8:	1806703a 	and	r3,r3,zero
 821eddc:	10c00505 	stb	r3,20(r2)
 821ede0:	10c00543 	ldbu	r3,21(r2)
 821ede4:	1806703a 	and	r3,r3,zero
 821ede8:	10c00545 	stb	r3,21(r2)
 821edec:	10c00583 	ldbu	r3,22(r2)
 821edf0:	1806703a 	and	r3,r3,zero
 821edf4:	10c00585 	stb	r3,22(r2)
 821edf8:	10c005c3 	ldbu	r3,23(r2)
 821edfc:	1806703a 	and	r3,r3,zero
 821ee00:	10c005c5 	stb	r3,23(r2)
  desc->bytes_to_transfer        = length_or_eop;
 821ee04:	e0bffa17 	ldw	r2,-24(fp)
 821ee08:	e0fffe17 	ldw	r3,-8(fp)
 821ee0c:	19403fcc 	andi	r5,r3,255
 821ee10:	10c00603 	ldbu	r3,24(r2)
 821ee14:	1806703a 	and	r3,r3,zero
 821ee18:	1809883a 	mov	r4,r3
 821ee1c:	2807883a 	mov	r3,r5
 821ee20:	20c6b03a 	or	r3,r4,r3
 821ee24:	10c00605 	stb	r3,24(r2)
 821ee28:	e0fffe17 	ldw	r3,-8(fp)
 821ee2c:	1806d23a 	srli	r3,r3,8
 821ee30:	19403fcc 	andi	r5,r3,255
 821ee34:	10c00643 	ldbu	r3,25(r2)
 821ee38:	1806703a 	and	r3,r3,zero
 821ee3c:	1809883a 	mov	r4,r3
 821ee40:	2807883a 	mov	r3,r5
 821ee44:	20c6b03a 	or	r3,r4,r3
 821ee48:	10c00645 	stb	r3,25(r2)
  desc->actual_bytes_transferred = 0;
 821ee4c:	e0bffa17 	ldw	r2,-24(fp)
 821ee50:	10c00703 	ldbu	r3,28(r2)
 821ee54:	1806703a 	and	r3,r3,zero
 821ee58:	10c00705 	stb	r3,28(r2)
 821ee5c:	10c00743 	ldbu	r3,29(r2)
 821ee60:	1806703a 	and	r3,r3,zero
 821ee64:	10c00745 	stb	r3,29(r2)
  desc->status                   = 0x0;
 821ee68:	e0bffa17 	ldw	r2,-24(fp)
 821ee6c:	10000785 	stb	zero,30(r2)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
 821ee70:	e0800617 	ldw	r2,24(fp)
 821ee74:	1007883a 	mov	r3,r2
 821ee78:	e0bffa17 	ldw	r2,-24(fp)
 821ee7c:	10c00685 	stb	r3,26(r2)
  desc->write_burst              = write_burst;
 821ee80:	e0800717 	ldw	r2,28(fp)
 821ee84:	1007883a 	mov	r3,r2
 821ee88:	e0bffa17 	ldw	r2,-24(fp)
 821ee8c:	10c006c5 	stb	r3,27(r2)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
 821ee90:	e0800317 	ldw	r2,12(fp)
 821ee94:	10000226 	beq	r2,zero,821eea0 <alt_avalon_sgdma_construct_descriptor_burst+0x32c>
 821ee98:	00bfe044 	movi	r2,-127
 821ee9c:	00000106 	br	821eea4 <alt_avalon_sgdma_construct_descriptor_burst+0x330>
 821eea0:	00bfe004 	movi	r2,-128
 821eea4:	e0c00417 	ldw	r3,16(fp)
 821eea8:	18000226 	beq	r3,zero,821eeb4 <alt_avalon_sgdma_construct_descriptor_burst+0x340>
 821eeac:	00c00084 	movi	r3,2
 821eeb0:	00000106 	br	821eeb8 <alt_avalon_sgdma_construct_descriptor_burst+0x344>
 821eeb4:	0007883a 	mov	r3,zero
 821eeb8:	10c4b03a 	or	r2,r2,r3
 821eebc:	1007883a 	mov	r3,r2
 821eec0:	e0800517 	ldw	r2,20(fp)
 821eec4:	10000226 	beq	r2,zero,821eed0 <alt_avalon_sgdma_construct_descriptor_burst+0x35c>
 821eec8:	00800104 	movi	r2,4
 821eecc:	00000106 	br	821eed4 <alt_avalon_sgdma_construct_descriptor_burst+0x360>
 821eed0:	0005883a 	mov	r2,zero
 821eed4:	1884b03a 	or	r2,r3,r2
 821eed8:	1007883a 	mov	r3,r2
 821eedc:	e0bfff03 	ldbu	r2,-4(fp)
 821eee0:	10000426 	beq	r2,zero,821eef4 <alt_avalon_sgdma_construct_descriptor_burst+0x380>
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_GENERATE_EOP_MSK : 0x0)        |
    (read_fixed ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_READ_FIXED_ADDRESS_MSK : 0x0)  |
    (write_fixed_or_sop ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_WRITE_FIXED_ADDRESS_MSK : 0x0) |
    (atlantic_channel ? ( (atlantic_channel & 0x0F) << 3) : 0)
 821eee4:	e0bfff03 	ldbu	r2,-4(fp)
 821eee8:	108003cc 	andi	r2,r2,15
 821eeec:	100490fa 	slli	r2,r2,3
 821eef0:	00000106 	br	821eef8 <alt_avalon_sgdma_construct_descriptor_burst+0x384>
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
 821eef4:	0005883a 	mov	r2,zero
 821eef8:	1884b03a 	or	r2,r3,r2
 821eefc:	1007883a 	mov	r3,r2
 821ef00:	e0bffa17 	ldw	r2,-24(fp)
 821ef04:	10c007c5 	stb	r3,31(r2)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
 821ef08:	01400804 	movi	r5,32
 821ef0c:	e13ffa17 	ldw	r4,-24(fp)
 821ef10:	823bd0c0 	call	823bd0c <alt_dcache_flush>
}
 821ef14:	0001883a 	nop
 821ef18:	e037883a 	mov	sp,fp
 821ef1c:	dfc00117 	ldw	ra,4(sp)
 821ef20:	df000017 	ldw	fp,0(sp)
 821ef24:	dec00204 	addi	sp,sp,8
 821ef28:	f800283a 	ret

0821ef2c <alt_avalon_sgdma_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
 821ef2c:	defff904 	addi	sp,sp,-28
 821ef30:	dfc00615 	stw	ra,24(sp)
 821ef34:	df000515 	stw	fp,20(sp)
 821ef38:	df000504 	addi	fp,sp,20
 821ef3c:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev *dev = (alt_sgdma_dev *) context;
 821ef40:	e0bfff17 	ldw	r2,-4(fp)
 821ef44:	e0bffb15 	stw	r2,-20(fp)
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 821ef48:	e0bffb17 	ldw	r2,-20(fp)
 821ef4c:	10800317 	ldw	r2,12(r2)
 821ef50:	10800404 	addi	r2,r2,16
 821ef54:	e0fffb17 	ldw	r3,-20(fp)
 821ef58:	18c00317 	ldw	r3,12(r3)
 821ef5c:	18c00404 	addi	r3,r3,16
 821ef60:	18c00037 	ldwio	r3,0(r3)
 821ef64:	18e00034 	orhi	r3,r3,32768
 821ef68:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821ef6c:	e0bffb17 	ldw	r2,-20(fp)
 821ef70:	10800317 	ldw	r2,12(r2)
 821ef74:	10800404 	addi	r2,r2,16
 821ef78:	10800037 	ldwio	r2,0(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
 821ef7c:	e0bffb17 	ldw	r2,-20(fp)
 821ef80:	10800917 	ldw	r2,36(r2)
 821ef84:	10001226 	beq	r2,zero,821efd0 <alt_avalon_sgdma_irq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821ef88:	0005303a 	rdctl	r2,status
 821ef8c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821ef90:	e0fffd17 	ldw	r3,-12(fp)
 821ef94:	00bfff84 	movi	r2,-2
 821ef98:	1884703a 	and	r2,r3,r2
 821ef9c:	1001703a 	wrctl	status,r2
  
  return context;
 821efa0:	e0bffd17 	ldw	r2,-12(fp)
    cpu_sr = alt_irq_disable_all();
 821efa4:	e0bffc15 	stw	r2,-16(fp)
    (dev->callback)(dev->callback_context);
 821efa8:	e0bffb17 	ldw	r2,-20(fp)
 821efac:	10800917 	ldw	r2,36(r2)
 821efb0:	e0fffb17 	ldw	r3,-20(fp)
 821efb4:	18c00a17 	ldw	r3,40(r3)
 821efb8:	1809883a 	mov	r4,r3
 821efbc:	103ee83a 	callr	r2
 821efc0:	e0bffc17 	ldw	r2,-16(fp)
 821efc4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821efc8:	e0bffe17 	ldw	r2,-8(fp)
 821efcc:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
  }
}
 821efd0:	0001883a 	nop
 821efd4:	e037883a 	mov	sp,fp
 821efd8:	dfc00117 	ldw	ra,4(sp)
 821efdc:	df000017 	ldw	fp,0(sp)
 821efe0:	dec00204 	addi	sp,sp,8
 821efe4:	f800283a 	ret

0821efe8 <alt_avalon_sgdma_init>:
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
 821efe8:	defffa04 	addi	sp,sp,-24
 821efec:	dfc00515 	stw	ra,20(sp)
 821eff0:	df000415 	stw	fp,16(sp)
 821eff4:	df000404 	addi	fp,sp,16
 821eff8:	e13ffd15 	stw	r4,-12(fp)
 821effc:	e17ffe15 	stw	r5,-8(fp)
 821f000:	e1bfff15 	stw	r6,-4(fp)

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821f004:	e0bffd17 	ldw	r2,-12(fp)
 821f008:	10800317 	ldw	r2,12(r2)
 821f00c:	10800404 	addi	r2,r2,16
 821f010:	00c00074 	movhi	r3,1
 821f014:	10c00035 	stwio	r3,0(r2)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821f018:	e0bffd17 	ldw	r2,-12(fp)
 821f01c:	10800317 	ldw	r2,12(r2)
 821f020:	10800404 	addi	r2,r2,16
 821f024:	00c00074 	movhi	r3,1
 821f028:	10c00035 	stwio	r3,0(r2)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
 821f02c:	e0bffd17 	ldw	r2,-12(fp)
 821f030:	10800317 	ldw	r2,12(r2)
 821f034:	10800404 	addi	r2,r2,16
 821f038:	0007883a 	mov	r3,zero
 821f03c:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 821f040:	e0bffd17 	ldw	r2,-12(fp)
 821f044:	10800317 	ldw	r2,12(r2)
 821f048:	00c03fc4 	movi	r3,255
 821f04c:	10c00035 	stwio	r3,0(r2)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
 821f050:	d1602b04 	addi	r5,gp,-32596
 821f054:	e13ffd17 	ldw	r4,-12(fp)
 821f058:	823bdec0 	call	823bdec <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
 821f05c:	d8000015 	stw	zero,0(sp)
 821f060:	e1fffd17 	ldw	r7,-12(fp)
 821f064:	018208b4 	movhi	r6,2082
 821f068:	31bbcb04 	addi	r6,r6,-4308
 821f06c:	e17fff17 	ldw	r5,-4(fp)
 821f070:	e13ffe17 	ldw	r4,-8(fp)
 821f074:	823bfe00 	call	823bfe0 <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
 821f078:	0001883a 	nop
 821f07c:	e037883a 	mov	sp,fp
 821f080:	dfc00117 	ldw	ra,4(sp)
 821f084:	df000017 	ldw	fp,0(sp)
 821f088:	dec00204 	addi	sp,sp,8
 821f08c:	f800283a 	ret

0821f090 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 821f090:	defffa04 	addi	sp,sp,-24
 821f094:	dfc00515 	stw	ra,20(sp)
 821f098:	df000415 	stw	fp,16(sp)
 821f09c:	df000404 	addi	fp,sp,16
 821f0a0:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 821f0a4:	0007883a 	mov	r3,zero
 821f0a8:	e0bfff17 	ldw	r2,-4(fp)
 821f0ac:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 821f0b0:	e0bfff17 	ldw	r2,-4(fp)
 821f0b4:	10800104 	addi	r2,r2,4
 821f0b8:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821f0bc:	0005303a 	rdctl	r2,status
 821f0c0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821f0c4:	e0fffd17 	ldw	r3,-12(fp)
 821f0c8:	00bfff84 	movi	r2,-2
 821f0cc:	1884703a 	and	r2,r3,r2
 821f0d0:	1001703a 	wrctl	status,r2
  
  return context;
 821f0d4:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 821f0d8:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
 821f0dc:	823c8800 	call	823c880 <alt_tick>
 821f0e0:	e0bffc17 	ldw	r2,-16(fp)
 821f0e4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821f0e8:	e0bffe17 	ldw	r2,-8(fp)
 821f0ec:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 821f0f0:	0001883a 	nop
 821f0f4:	e037883a 	mov	sp,fp
 821f0f8:	dfc00117 	ldw	ra,4(sp)
 821f0fc:	df000017 	ldw	fp,0(sp)
 821f100:	dec00204 	addi	sp,sp,8
 821f104:	f800283a 	ret

0821f108 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 821f108:	defff804 	addi	sp,sp,-32
 821f10c:	dfc00715 	stw	ra,28(sp)
 821f110:	df000615 	stw	fp,24(sp)
 821f114:	df000604 	addi	fp,sp,24
 821f118:	e13ffc15 	stw	r4,-16(fp)
 821f11c:	e17ffd15 	stw	r5,-12(fp)
 821f120:	e1bffe15 	stw	r6,-8(fp)
 821f124:	e1ffff15 	stw	r7,-4(fp)
 821f128:	e0bfff17 	ldw	r2,-4(fp)
 821f12c:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 821f130:	d0a0b817 	ldw	r2,-32032(gp)
 821f134:	1000021e 	bne	r2,zero,821f140 <alt_avalon_timer_sc_init+0x38>
  {
    _alt_tick_rate = nticks;
 821f138:	e0bffb17 	ldw	r2,-20(fp)
 821f13c:	d0a0b815 	stw	r2,-32032(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 821f140:	e0bffc17 	ldw	r2,-16(fp)
 821f144:	10800104 	addi	r2,r2,4
 821f148:	00c001c4 	movi	r3,7
 821f14c:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 821f150:	d8000015 	stw	zero,0(sp)
 821f154:	e1fffc17 	ldw	r7,-16(fp)
 821f158:	018208b4 	movhi	r6,2082
 821f15c:	31bc2404 	addi	r6,r6,-3952
 821f160:	e17ffe17 	ldw	r5,-8(fp)
 821f164:	e13ffd17 	ldw	r4,-12(fp)
 821f168:	823bfe00 	call	823bfe0 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 821f16c:	0001883a 	nop
 821f170:	e037883a 	mov	sp,fp
 821f174:	dfc00117 	ldw	ra,4(sp)
 821f178:	df000017 	ldw	fp,0(sp)
 821f17c:	dec00204 	addi	sp,sp,8
 821f180:	f800283a 	ret

0821f184 <no_printf>:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void no_printf (char *fmt, ...) {}
 821f184:	defffb04 	addi	sp,sp,-20
 821f188:	df000115 	stw	fp,4(sp)
 821f18c:	df000104 	addi	fp,sp,4
 821f190:	e13fff15 	stw	r4,-4(fp)
 821f194:	e1400115 	stw	r5,4(fp)
 821f198:	e1800215 	stw	r6,8(fp)
 821f19c:	e1c00315 	stw	r7,12(fp)
 821f1a0:	0001883a 	nop
 821f1a4:	e037883a 	mov	sp,fp
 821f1a8:	df000017 	ldw	fp,0(sp)
 821f1ac:	dec00404 	addi	sp,sp,16
 821f1b0:	f800283a 	ret

0821f1b4 <tse_mac_initTransInfo2>:

alt_32 tse_mac_initTransInfo2( tse_mac_trans_info *mi,
                                        alt_u32 mac_base,
                                        alt_32 tx_sgdma,
                                        alt_32 rx_sgdma,
                                        alt_32 cfgflags) {
 821f1b4:	defffb04 	addi	sp,sp,-20
 821f1b8:	df000415 	stw	fp,16(sp)
 821f1bc:	df000404 	addi	fp,sp,16
 821f1c0:	e13ffc15 	stw	r4,-16(fp)
 821f1c4:	e17ffd15 	stw	r5,-12(fp)
 821f1c8:	e1bffe15 	stw	r6,-8(fp)
 821f1cc:	e1ffff15 	stw	r7,-4(fp)
                                              
        mi->base     = (np_tse_mac*)mac_base;
 821f1d0:	e0fffd17 	ldw	r3,-12(fp)
 821f1d4:	e0bffc17 	ldw	r2,-16(fp)
 821f1d8:	10c00015 	stw	r3,0(r2)
        mi->tx_sgdma = (alt_sgdma_dev *)tx_sgdma;
 821f1dc:	e0fffe17 	ldw	r3,-8(fp)
 821f1e0:	e0bffc17 	ldw	r2,-16(fp)
 821f1e4:	10c00115 	stw	r3,4(r2)
        mi->rx_sgdma = (alt_sgdma_dev *)rx_sgdma;
 821f1e8:	e0ffff17 	ldw	r3,-4(fp)
 821f1ec:	e0bffc17 	ldw	r2,-16(fp)
 821f1f0:	10c00215 	stw	r3,8(r2)
        mi->cfgflags = cfgflags;     
 821f1f4:	e0c00117 	ldw	r3,4(fp)
 821f1f8:	e0bffc17 	ldw	r2,-16(fp)
 821f1fc:	10c00415 	stw	r3,16(r2)
        return SUCCESS;
 821f200:	0005883a 	mov	r2,zero
}
 821f204:	e037883a 	mov	sp,fp
 821f208:	df000017 	ldw	fp,0(sp)
 821f20c:	dec00104 	addi	sp,sp,4
 821f210:	f800283a 	ret

0821f214 <tse_mac_sTxWrite>:
  * @param txDesc           Pointer to the transmit SGDMA descriptor
  * @return actual bytes transferred if ok, else error (-1)
  */
alt_32 tse_mac_sTxWrite( tse_mac_trans_info *mi, 
                       alt_sgdma_descriptor *txDesc)   
{ 
 821f214:	defffa04 	addi	sp,sp,-24
 821f218:	dfc00515 	stw	ra,20(sp)
 821f21c:	df000415 	stw	fp,16(sp)
 821f220:	df000404 	addi	fp,sp,16
 821f224:	e13ffe15 	stw	r4,-8(fp)
 821f228:	e17fff15 	stw	r5,-4(fp)

  alt_32 timeout;
  alt_u8 result = 0;
 821f22c:	e03ffd05 	stb	zero,-12(fp)
  alt_u16 actualBytesTransferred;
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
 821f230:	e03ffc15 	stw	zero,-16(fp)
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 821f234:	00000b06 	br	821f264 <tse_mac_sTxWrite+0x50>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
           if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 821f238:	e0fffc17 	ldw	r3,-16(fp)
 821f23c:	18800044 	addi	r2,r3,1
 821f240:	e0bffc15 	stw	r2,-16(fp)
 821f244:	008003f4 	movhi	r2,15
 821f248:	10909004 	addi	r2,r2,16960
 821f24c:	1880051e 	bne	r3,r2,821f264 <tse_mac_sTxWrite+0x50>
            tse_dprintf(4, "WARNING : TX SGDMA Timeout\n");
 821f250:	01020974 	movhi	r4,2085
 821f254:	2137dc04 	addi	r4,r4,-8336
 821f258:	82036240 	call	8203624 <puts>
            return ENP_RESOURCE;  // avoid being stuck here
 821f25c:	00bffa84 	movi	r2,-22
 821f260:	00002006 	br	821f2e4 <tse_mac_sTxWrite+0xd0>
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 821f264:	e0bffe17 	ldw	r2,-8(fp)
 821f268:	10800117 	ldw	r2,4(r2)
 821f26c:	10800317 	ldw	r2,12(r2)
 821f270:	10800037 	ldwio	r2,0(r2)
 821f274:	1080040c 	andi	r2,r2,16
 821f278:	103fef1e 	bne	r2,zero,821f238 <tse_mac_sTxWrite+0x24>
           }
  }

  // Set up the SGDMA
  // Clear the status and control bits of the SGDMA descriptor
  IOWR_ALTERA_AVALON_SGDMA_CONTROL (mi->tx_sgdma->base, 0);
 821f27c:	e0bffe17 	ldw	r2,-8(fp)
 821f280:	10800117 	ldw	r2,4(r2)
 821f284:	10800317 	ldw	r2,12(r2)
 821f288:	10800404 	addi	r2,r2,16
 821f28c:	0007883a 	mov	r3,zero
 821f290:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS (mi->tx_sgdma->base, 0xFF);
 821f294:	e0bffe17 	ldw	r2,-8(fp)
 821f298:	10800117 	ldw	r2,4(r2)
 821f29c:	10800317 	ldw	r2,12(r2)
 821f2a0:	00c03fc4 	movi	r3,255
 821f2a4:	10c00035 	stwio	r3,0(r2)
  
  // Start SGDMA (blocking call)
  result = alt_avalon_sgdma_do_sync_transfer(
 821f2a8:	e0bffe17 	ldw	r2,-8(fp)
 821f2ac:	10800117 	ldw	r2,4(r2)
 821f2b0:	e17fff17 	ldw	r5,-4(fp)
 821f2b4:	1009883a 	mov	r4,r2
 821f2b8:	821e45c0 	call	821e45c <alt_avalon_sgdma_do_sync_transfer>
 821f2bc:	e0bffd05 	stb	r2,-12(fp)
                mi->tx_sgdma, 
                (alt_sgdma_descriptor *) &txDesc[0]);
  
  if (result != 0)
 821f2c0:	e0bffd03 	ldbu	r2,-12(fp)
 821f2c4:	10000226 	beq	r2,zero,821f2d0 <tse_mac_sTxWrite+0xbc>
    return -1;
 821f2c8:	00bfffc4 	movi	r2,-1
 821f2cc:	00000506 	br	821f2e4 <tse_mac_sTxWrite+0xd0>
  
  /* perform cache save read to obtain actual bytes transferred for current sgdma descriptor */
  actualBytesTransferred = IORD_ALTERA_TSE_SGDMA_DESC_ACTUAL_BYTES_TRANSFERRED(&txDesc[0]);
 821f2d0:	e0bfff17 	ldw	r2,-4(fp)
 821f2d4:	10800704 	addi	r2,r2,28
 821f2d8:	10800037 	ldwio	r2,0(r2)
 821f2dc:	e0bffd8d 	sth	r2,-10(fp)

  return actualBytesTransferred;
 821f2e0:	e0bffd8b 	ldhu	r2,-10(fp)
}
 821f2e4:	e037883a 	mov	sp,fp
 821f2e8:	dfc00117 	ldw	ra,4(sp)
 821f2ec:	df000017 	ldw	fp,0(sp)
 821f2f0:	dec00204 	addi	sp,sp,8
 821f2f4:	f800283a 	ret

0821f2f8 <tse_mac_aRxRead>:
  *        the actual bytes transferred for current descriptor
  */
alt_32 tse_mac_aRxRead( 
  tse_mac_trans_info *mi,       
  alt_sgdma_descriptor *rxDesc)  
{
 821f2f8:	defffa04 	addi	sp,sp,-24
 821f2fc:	dfc00515 	stw	ra,20(sp)
 821f300:	df000415 	stw	fp,16(sp)
 821f304:	df000404 	addi	fp,sp,16
 821f308:	e13ffe15 	stw	r4,-8(fp)
 821f30c:	e17fff15 	stw	r5,-4(fp)
  alt_32 timeout;
  
  alt_u8 result = 0;
 821f310:	e03ffd05 	stb	zero,-12(fp)
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
 821f314:	e03ffc15 	stw	zero,-16(fp)
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 821f318:	00000b06 	br	821f348 <tse_mac_aRxRead+0x50>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 821f31c:	e0fffc17 	ldw	r3,-16(fp)
 821f320:	18800044 	addi	r2,r3,1
 821f324:	e0bffc15 	stw	r2,-16(fp)
 821f328:	008003f4 	movhi	r2,15
 821f32c:	10909004 	addi	r2,r2,16960
 821f330:	1880051e 	bne	r3,r2,821f348 <tse_mac_aRxRead+0x50>
        tse_dprintf(4, "WARNING : RX SGDMA Timeout\n");
 821f334:	01020974 	movhi	r4,2085
 821f338:	2137e304 	addi	r4,r4,-8308
 821f33c:	82036240 	call	8203624 <puts>
        return ENP_RESOURCE;  // avoid being stuck here
 821f340:	00bffa84 	movi	r2,-22
 821f344:	00001106 	br	821f38c <tse_mac_aRxRead+0x94>
  alt_u8 result = 0;
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 821f348:	e0bffe17 	ldw	r2,-8(fp)
 821f34c:	10800217 	ldw	r2,8(r2)
 821f350:	10800317 	ldw	r2,12(r2)
 821f354:	10800037 	ldwio	r2,0(r2)
 821f358:	1080040c 	andi	r2,r2,16
 821f35c:	103fef1e 	bne	r2,zero,821f31c <tse_mac_aRxRead+0x24>
    }
  }

 
  // SGDMA operation invoked for RX (non-blocking call)
  result = alt_avalon_sgdma_do_async_transfer(
 821f360:	e0bffe17 	ldw	r2,-8(fp)
 821f364:	10800217 	ldw	r2,8(r2)
 821f368:	e17fff17 	ldw	r5,-4(fp)
 821f36c:	1009883a 	mov	r4,r2
 821f370:	821e3380 	call	821e338 <alt_avalon_sgdma_do_async_transfer>
 821f374:	e0bffd05 	stb	r2,-12(fp)
                mi->rx_sgdma, 
                (alt_sgdma_descriptor *) &rxDesc[0]);
  
  if (result != 0)
 821f378:	e0bffd03 	ldbu	r2,-12(fp)
 821f37c:	10000226 	beq	r2,zero,821f388 <tse_mac_aRxRead+0x90>
    return -1;
 821f380:	00bfffc4 	movi	r2,-1
 821f384:	00000106 	br	821f38c <tse_mac_aRxRead+0x94>
 
  return SUCCESS;
 821f388:	0005883a 	mov	r2,zero
}
 821f38c:	e037883a 	mov	sp,fp
 821f390:	dfc00117 	ldw	ra,4(sp)
 821f394:	df000017 	ldw	fp,0(sp)
 821f398:	dec00204 	addi	sp,sp,8
 821f39c:	f800283a 	ret

0821f3a0 <tse_mac_SwReset>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_SwReset(np_tse_mac *pmac) 
{
 821f3a0:	defffc04 	addi	sp,sp,-16
 821f3a4:	df000315 	stw	fp,12(sp)
 821f3a8:	df000304 	addi	fp,sp,12
 821f3ac:	e13fff15 	stw	r4,-4(fp)
	alt_32 timeout;
	alt_32 cc;
        
    cc = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 821f3b0:	e0bfff17 	ldw	r2,-4(fp)
 821f3b4:	10800204 	addi	r2,r2,8
 821f3b8:	10800037 	ldwio	r2,0(r2)
 821f3bc:	e0bffe15 	stw	r2,-8(fp)
    
    // set reset and Gig-Speed bits to make sure we have an incoming clock on
    // tx side. If there is a 10/100 PHY, we will still have a valid clock on
    // tx_clk no matter what setting we have here, but on a Gig phy the
    // MII clock may be missing.
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,(ALTERA_TSEMAC_CMD_SW_RESET_MSK | ALTERA_TSEMAC_CMD_ETH_SPEED_MSK));
 821f3c0:	e0bfff17 	ldw	r2,-4(fp)
 821f3c4:	10800204 	addi	r2,r2,8
 821f3c8:	00c80204 	movi	r3,8200
 821f3cc:	10c00035 	stwio	r3,0(r2)

    
    // wait for completion with fallback in case there is no PHY or it is
    // not connected and hence might not provide any clocks at all.
    timeout=0;
 821f3d0:	e03ffd15 	stw	zero,-12(fp)
    while( (IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac) & ALTERA_TSEMAC_CMD_SW_RESET_MSK) != 0 && timeout < ALTERA_TSE_SW_RESET_TIME_OUT_CNT) timeout++;
 821f3d4:	00000306 	br	821f3e4 <tse_mac_SwReset+0x44>
 821f3d8:	e0bffd17 	ldw	r2,-12(fp)
 821f3dc:	10800044 	addi	r2,r2,1
 821f3e0:	e0bffd15 	stw	r2,-12(fp)
 821f3e4:	e0bfff17 	ldw	r2,-4(fp)
 821f3e8:	10800204 	addi	r2,r2,8
 821f3ec:	10800037 	ldwio	r2,0(r2)
 821f3f0:	1088000c 	andi	r2,r2,8192
 821f3f4:	10000326 	beq	r2,zero,821f404 <tse_mac_SwReset+0x64>
 821f3f8:	e0bffd17 	ldw	r2,-12(fp)
 821f3fc:	1089c410 	cmplti	r2,r2,10000
 821f400:	103ff51e 	bne	r2,zero,821f3d8 <tse_mac_SwReset+0x38>
   
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,cc); // Restore
 821f404:	e0bfff17 	ldw	r2,-4(fp)
 821f408:	10800204 	addi	r2,r2,8
 821f40c:	e0fffe17 	ldw	r3,-8(fp)
 821f410:	10c00035 	stwio	r3,0(r2)
    return SUCCESS;
 821f414:	0005883a 	mov	r2,zero
}
 821f418:	e037883a 	mov	sp,fp
 821f41c:	df000017 	ldw	fp,0(sp)
 821f420:	dec00104 	addi	sp,sp,4
 821f424:	f800283a 	ret

0821f428 <tse_mac_setMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_setMIImode(np_tse_mac *pmac)
{
 821f428:	defffd04 	addi	sp,sp,-12
 821f42c:	df000215 	stw	fp,8(sp)
 821f430:	df000204 	addi	fp,sp,8
 821f434:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 821f438:	e0bfff17 	ldw	r2,-4(fp)
 821f43c:	10800204 	addi	r2,r2,8
 821f440:	10800037 	ldwio	r2,0(r2)
 821f444:	e0bffe15 	stw	r2,-8(fp)
  helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK; 
 821f448:	e0fffe17 	ldw	r3,-8(fp)
 821f44c:	00bffdc4 	movi	r2,-9
 821f450:	1884703a 	and	r2,r3,r2
 821f454:	e0bffe15 	stw	r2,-8(fp)
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 821f458:	e0bfff17 	ldw	r2,-4(fp)
 821f45c:	10800204 	addi	r2,r2,8
 821f460:	e0fffe17 	ldw	r3,-8(fp)
 821f464:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 821f468:	0005883a 	mov	r2,zero
}
 821f46c:	e037883a 	mov	sp,fp
 821f470:	df000017 	ldw	fp,0(sp)
 821f474:	dec00104 	addi	sp,sp,4
 821f478:	f800283a 	ret

0821f47c <tse_mac_setGMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
 */
alt_32 tse_mac_setGMIImode(np_tse_mac *pmac)
{
 821f47c:	defffd04 	addi	sp,sp,-12
 821f480:	df000215 	stw	fp,8(sp)
 821f484:	df000204 	addi	fp,sp,8
 821f488:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 821f48c:	e0bfff17 	ldw	r2,-4(fp)
 821f490:	10800204 	addi	r2,r2,8
 821f494:	10800037 	ldwio	r2,0(r2)
 821f498:	e0bffe15 	stw	r2,-8(fp)
  helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 821f49c:	e0bffe17 	ldw	r2,-8(fp)
 821f4a0:	10800214 	ori	r2,r2,8
 821f4a4:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 821f4a8:	e0bfff17 	ldw	r2,-4(fp)
 821f4ac:	10800204 	addi	r2,r2,8
 821f4b0:	e0fffe17 	ldw	r3,-8(fp)
 821f4b4:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 821f4b8:	0005883a 	mov	r2,zero
}
 821f4bc:	e037883a 	mov	sp,fp
 821f4c0:	df000017 	ldw	fp,0(sp)
 821f4c4:	dec00104 	addi	sp,sp,4
 821f4c8:	f800283a 	ret

0821f4cc <alt_tse_phy_add_profile>:
 * @param  phy  pointer to alt_tse_phy_profile structure describing PHY registers
 * @return      index of PHY added in PHY profile on success, else return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 * PHY which are currently supported by default :  Marvell 88E1111, Marvell Quad PHY 88E1145, National DP83865, and National DP83848C
 */
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
 821f4cc:	defffb04 	addi	sp,sp,-20
 821f4d0:	dfc00415 	stw	ra,16(sp)
 821f4d4:	df000315 	stw	fp,12(sp)
 821f4d8:	dc000215 	stw	r16,8(sp)
 821f4dc:	df000304 	addi	fp,sp,12
 821f4e0:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 821f4e4:	e03ffd15 	stw	zero,-12(fp)
 821f4e8:	00002906 	br	821f590 <alt_tse_phy_add_profile+0xc4>
    {
        if(pphy_profiles[i]->oui == phy->oui && pphy_profiles[i]->model_number == phy->model_number)
 821f4ec:	008209b4 	movhi	r2,2086
 821f4f0:	10b6fa04 	addi	r2,r2,-9240
 821f4f4:	e0fffd17 	ldw	r3,-12(fp)
 821f4f8:	18c7883a 	add	r3,r3,r3
 821f4fc:	18c7883a 	add	r3,r3,r3
 821f500:	10c5883a 	add	r2,r2,r3
 821f504:	10800017 	ldw	r2,0(r2)
 821f508:	10c01417 	ldw	r3,80(r2)
 821f50c:	e0bffe17 	ldw	r2,-8(fp)
 821f510:	10801417 	ldw	r2,80(r2)
 821f514:	18801b1e 	bne	r3,r2,821f584 <alt_tse_phy_add_profile+0xb8>
 821f518:	008209b4 	movhi	r2,2086
 821f51c:	10b6fa04 	addi	r2,r2,-9240
 821f520:	e0fffd17 	ldw	r3,-12(fp)
 821f524:	18c7883a 	add	r3,r3,r3
 821f528:	18c7883a 	add	r3,r3,r3
 821f52c:	10c5883a 	add	r2,r2,r3
 821f530:	10800017 	ldw	r2,0(r2)
 821f534:	10c01503 	ldbu	r3,84(r2)
 821f538:	e0bffe17 	ldw	r2,-8(fp)
 821f53c:	10801503 	ldbu	r2,84(r2)
 821f540:	18c03fcc 	andi	r3,r3,255
 821f544:	10803fcc 	andi	r2,r2,255
 821f548:	18800e1e 	bne	r3,r2,821f584 <alt_tse_phy_add_profile+0xb8>
        {
            tse_dprintf(4, "WARNING : PHY OUI 0x%06x, PHY Model Number 0x%02x already exist in PHY profile\n", (int) phy->oui, phy->model_number);
 821f54c:	e0bffe17 	ldw	r2,-8(fp)
 821f550:	10801417 	ldw	r2,80(r2)
 821f554:	1007883a 	mov	r3,r2
 821f558:	e0bffe17 	ldw	r2,-8(fp)
 821f55c:	10801503 	ldbu	r2,84(r2)
 821f560:	10803fcc 	andi	r2,r2,255
 821f564:	100d883a 	mov	r6,r2
 821f568:	180b883a 	mov	r5,r3
 821f56c:	01020974 	movhi	r4,2085
 821f570:	2137ea04 	addi	r4,r4,-8280
 821f574:	82033a00 	call	82033a0 <printf>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
 821f578:	01020974 	movhi	r4,2085
 821f57c:	2137fe04 	addi	r4,r4,-8200
 821f580:	82036240 	call	8203624 <puts>
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 821f584:	e0bffd17 	ldw	r2,-12(fp)
 821f588:	10800044 	addi	r2,r2,1
 821f58c:	e0bffd15 	stw	r2,-12(fp)
 821f590:	d0a07f03 	ldbu	r2,-32260(gp)
 821f594:	10803fcc 	andi	r2,r2,255
 821f598:	e0fffd17 	ldw	r3,-12(fp)
 821f59c:	18bfd316 	blt	r3,r2,821f4ec <alt_tse_phy_add_profile+0x20>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
        }
    }

    /* Allocate memory space to store the profile */    
    pphy_profiles[phy_profile_count] = (alt_tse_phy_profile *) malloc(sizeof(alt_tse_phy_profile));
 821f5a0:	d0a07f03 	ldbu	r2,-32260(gp)
 821f5a4:	14003fcc 	andi	r16,r2,255
 821f5a8:	01001904 	movi	r4,100
 821f5ac:	824b6900 	call	824b690 <malloc>
 821f5b0:	1009883a 	mov	r4,r2
 821f5b4:	008209b4 	movhi	r2,2086
 821f5b8:	10b6fa04 	addi	r2,r2,-9240
 821f5bc:	8407883a 	add	r3,r16,r16
 821f5c0:	18c7883a 	add	r3,r3,r3
 821f5c4:	10c5883a 	add	r2,r2,r3
 821f5c8:	11000015 	stw	r4,0(r2)
    if(!pphy_profiles[phy_profile_count]) {
 821f5cc:	d0a07f03 	ldbu	r2,-32260(gp)
 821f5d0:	10c03fcc 	andi	r3,r2,255
 821f5d4:	008209b4 	movhi	r2,2086
 821f5d8:	10b6fa04 	addi	r2,r2,-9240
 821f5dc:	18c7883a 	add	r3,r3,r3
 821f5e0:	18c7883a 	add	r3,r3,r3
 821f5e4:	10c5883a 	add	r2,r2,r3
 821f5e8:	10800017 	ldw	r2,0(r2)
 821f5ec:	1000081e 	bne	r2,zero,821f610 <alt_tse_phy_add_profile+0x144>
        tse_dprintf(1, "ERROR   : Unable to allocate memory for pphy_profile[%d]\n", phy_profile_count);
 821f5f0:	d0a07f03 	ldbu	r2,-32260(gp)
 821f5f4:	10803fcc 	andi	r2,r2,255
 821f5f8:	100b883a 	mov	r5,r2
 821f5fc:	01020974 	movhi	r4,2085
 821f600:	21381604 	addi	r4,r4,-8104
 821f604:	82033a00 	call	82033a0 <printf>
        return ALTERA_TSE_MALLOC_FAILED;
 821f608:	00bfffc4 	movi	r2,-1
 821f60c:	00002206 	br	821f698 <alt_tse_phy_add_profile+0x1cc>
    }

    /* Store PHY information */
    *pphy_profiles[phy_profile_count] = *phy;
 821f610:	d0a07f03 	ldbu	r2,-32260(gp)
 821f614:	10c03fcc 	andi	r3,r2,255
 821f618:	008209b4 	movhi	r2,2086
 821f61c:	10b6fa04 	addi	r2,r2,-9240
 821f620:	18c7883a 	add	r3,r3,r3
 821f624:	18c7883a 	add	r3,r3,r3
 821f628:	10c5883a 	add	r2,r2,r3
 821f62c:	10c00017 	ldw	r3,0(r2)
 821f630:	e0bffe17 	ldw	r2,-8(fp)
 821f634:	1009883a 	mov	r4,r2
 821f638:	00801904 	movi	r2,100
 821f63c:	100d883a 	mov	r6,r2
 821f640:	200b883a 	mov	r5,r4
 821f644:	1809883a 	mov	r4,r3
 821f648:	8202f100 	call	8202f10 <memcpy>
    strcpy(pphy_profiles[phy_profile_count]->name, phy->name);
 821f64c:	d0a07f03 	ldbu	r2,-32260(gp)
 821f650:	10c03fcc 	andi	r3,r2,255
 821f654:	008209b4 	movhi	r2,2086
 821f658:	10b6fa04 	addi	r2,r2,-9240
 821f65c:	18c7883a 	add	r3,r3,r3
 821f660:	18c7883a 	add	r3,r3,r3
 821f664:	10c5883a 	add	r2,r2,r3
 821f668:	10800017 	ldw	r2,0(r2)
 821f66c:	1007883a 	mov	r3,r2
 821f670:	e0bffe17 	ldw	r2,-8(fp)
 821f674:	100b883a 	mov	r5,r2
 821f678:	1809883a 	mov	r4,r3
 821f67c:	824b6b80 	call	824b6b8 <strcpy>
    
    phy_profile_count++;
 821f680:	d0a07f03 	ldbu	r2,-32260(gp)
 821f684:	10800044 	addi	r2,r2,1
 821f688:	d0a07f05 	stb	r2,-32260(gp)
    
    return phy_profile_count - 1;
 821f68c:	d0a07f03 	ldbu	r2,-32260(gp)
 821f690:	10803fcc 	andi	r2,r2,255
 821f694:	10bfffc4 	addi	r2,r2,-1
}
 821f698:	e6ffff04 	addi	sp,fp,-4
 821f69c:	dfc00217 	ldw	ra,8(sp)
 821f6a0:	df000117 	ldw	fp,4(sp)
 821f6a4:	dc000017 	ldw	r16,0(sp)
 821f6a8:	dec00304 	addi	sp,sp,12
 821f6ac:	f800283a 	ret

0821f6b0 <alt_tse_system_add_sys>:
alt_32 alt_tse_system_add_sys(
	alt_tse_system_mac					*psys_mac,
	alt_tse_system_sgdma				*psys_sgdma,
	alt_tse_system_desc_mem				*psys_mem,
	alt_tse_system_shared_fifo			*psys_shared_fifo,
	alt_tse_system_phy 					*psys_phy ) {
 821f6b0:	defff204 	addi	sp,sp,-56
 821f6b4:	dfc00d15 	stw	ra,52(sp)
 821f6b8:	df000c15 	stw	fp,48(sp)
 821f6bc:	dc000b15 	stw	r16,44(sp)
 821f6c0:	df000c04 	addi	fp,sp,48
 821f6c4:	e13ffb15 	stw	r4,-20(fp)
 821f6c8:	e17ffc15 	stw	r5,-16(fp)
 821f6cc:	e1bffd15 	stw	r6,-12(fp)
 821f6d0:	e1fffe15 	stw	r7,-8(fp)

	int i;
	int loop_end;
	
	alt_tse_system_mac					*pmac	= psys_mac;
 821f6d4:	e0bffb17 	ldw	r2,-20(fp)
 821f6d8:	e0bffa15 	stw	r2,-24(fp)
	alt_tse_system_sgdma				*psgdma	= psys_sgdma;
 821f6dc:	e0bffc17 	ldw	r2,-16(fp)
 821f6e0:	e0bff615 	stw	r2,-40(fp)
	alt_tse_system_desc_mem				*pmem	= psys_mem;
 821f6e4:	e0bffd17 	ldw	r2,-12(fp)
 821f6e8:	e0bff715 	stw	r2,-36(fp)
	alt_tse_system_shared_fifo			*pfifo	= psys_shared_fifo;
 821f6ec:	e0bffe17 	ldw	r2,-8(fp)
 821f6f0:	e0bff815 	stw	r2,-32(fp)
	alt_tse_system_phy 					*pphy	= psys_phy;
 821f6f4:	e0800217 	ldw	r2,8(fp)
 821f6f8:	e0bff915 	stw	r2,-28(fp)
	
	static alt_8 tse_system_count = 0;
	
	/* Determine number of loop */
	/* Run at least one for non-multi-channel MAC */
	if(pmac->tse_num_of_channel == 0) {
 821f6fc:	e0bffa17 	ldw	r2,-24(fp)
 821f700:	10800303 	ldbu	r2,12(r2)
 821f704:	10803fcc 	andi	r2,r2,255
 821f708:	1000031e 	bne	r2,zero,821f718 <alt_tse_system_add_sys+0x68>
		loop_end = 1;
 821f70c:	00800044 	movi	r2,1
 821f710:	e0bff515 	stw	r2,-44(fp)
 821f714:	00000e06 	br	821f750 <alt_tse_system_add_sys+0xa0>
	}
	else if(pmac->tse_num_of_channel > 0) {
 821f718:	e0bffa17 	ldw	r2,-24(fp)
 821f71c:	10800303 	ldbu	r2,12(r2)
 821f720:	10803fcc 	andi	r2,r2,255
 821f724:	10000526 	beq	r2,zero,821f73c <alt_tse_system_add_sys+0x8c>
		loop_end = pmac->tse_num_of_channel; 
 821f728:	e0bffa17 	ldw	r2,-24(fp)
 821f72c:	10800303 	ldbu	r2,12(r2)
 821f730:	10803fcc 	andi	r2,r2,255
 821f734:	e0bff515 	stw	r2,-44(fp)
 821f738:	00000506 	br	821f750 <alt_tse_system_add_sys+0xa0>
	}
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
 821f73c:	01020974 	movhi	r4,2085
 821f740:	21382504 	addi	r4,r4,-8044
 821f744:	82036240 	call	8203624 <puts>
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
 821f748:	00bfffc4 	movi	r2,-1
 821f74c:	00025106 	br	8220094 <alt_tse_system_add_sys+0x9e4>
	}

	for(i = 0; i < loop_end; i++) {
 821f750:	e03ff415 	stw	zero,-48(fp)
 821f754:	00024b06 	br	8220084 <alt_tse_system_add_sys+0x9d4>
		
		/* Make sure the boundary of array is not exceeded */
		if(tse_system_count >= MAXNETS) {
 821f758:	d0a07f83 	ldbu	r2,-32258(gp)
 821f75c:	10803fcc 	andi	r2,r2,255
 821f760:	1080201c 	xori	r2,r2,128
 821f764:	10bfe004 	addi	r2,r2,-128
 821f768:	10800110 	cmplti	r2,r2,4
 821f76c:	10000c1e 	bne	r2,zero,821f7a0 <alt_tse_system_add_sys+0xf0>
			tse_dprintf(2, "ERROR   : Number of TSE System added exceed the size of array!\n");
 821f770:	01020974 	movhi	r4,2085
 821f774:	21383104 	addi	r4,r4,-7996
 821f778:	82036240 	call	8203624 <puts>
			tse_dprintf(2, "ERROR   : Size of array = %d, Number of TSE System = %d\n", MAXNETS, tse_system_count);
 821f77c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f780:	10803fcc 	andi	r2,r2,255
 821f784:	1080201c 	xori	r2,r2,128
 821f788:	10bfe004 	addi	r2,r2,-128
 821f78c:	100d883a 	mov	r6,r2
 821f790:	01400104 	movi	r5,4
 821f794:	01020974 	movhi	r4,2085
 821f798:	21384104 	addi	r4,r4,-7932
 821f79c:	82033a00 	call	82033a0 <printf>
		}

		/* Add MAC info to alt_tse_system_info structure */
		if(pmac == 0) {
 821f7a0:	e0bffa17 	ldw	r2,-24(fp)
 821f7a4:	1000081e 	bne	r2,zero,821f7c8 <alt_tse_system_add_sys+0x118>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 821f7a8:	01020974 	movhi	r4,2085
 821f7ac:	21385004 	addi	r4,r4,-7872
 821f7b0:	82036240 	call	8203624 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys()\n");
 821f7b4:	01020974 	movhi	r4,2085
 821f7b8:	21385a04 	addi	r4,r4,-7832
 821f7bc:	82036240 	call	8203624 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 821f7c0:	00bfffc4 	movi	r2,-1
 821f7c4:	00023306 	br	8220094 <alt_tse_system_add_sys+0x9e4>
		}		
		
		tse_mac_device[tse_system_count].tse_mac_base 					= pmac->tse_mac_base + (i * 0x400);
 821f7c8:	d0a07f83 	ldbu	r2,-32258(gp)
 821f7cc:	11003fcc 	andi	r4,r2,255
 821f7d0:	2100201c 	xori	r4,r4,128
 821f7d4:	213fe004 	addi	r4,r4,-128
 821f7d8:	e0bffa17 	ldw	r2,-24(fp)
 821f7dc:	10800017 	ldw	r2,0(r2)
 821f7e0:	e0fff417 	ldw	r3,-48(fp)
 821f7e4:	180692ba 	slli	r3,r3,10
 821f7e8:	10c7883a 	add	r3,r2,r3
 821f7ec:	00820974 	movhi	r2,2085
 821f7f0:	1087b804 	addi	r2,r2,7904
 821f7f4:	21001224 	muli	r4,r4,72
 821f7f8:	1105883a 	add	r2,r2,r4
 821f7fc:	10c00015 	stw	r3,0(r2)
		tse_mac_device[tse_system_count].tse_tx_depth 					= pmac->tse_tx_depth;
 821f800:	d0a07f83 	ldbu	r2,-32258(gp)
 821f804:	11003fcc 	andi	r4,r2,255
 821f808:	2100201c 	xori	r4,r4,128
 821f80c:	213fe004 	addi	r4,r4,-128
 821f810:	e0bffa17 	ldw	r2,-24(fp)
 821f814:	10c0010b 	ldhu	r3,4(r2)
 821f818:	00820974 	movhi	r2,2085
 821f81c:	1087b804 	addi	r2,r2,7904
 821f820:	21001224 	muli	r4,r4,72
 821f824:	1105883a 	add	r2,r2,r4
 821f828:	10800104 	addi	r2,r2,4
 821f82c:	10c0000d 	sth	r3,0(r2)
		tse_mac_device[tse_system_count].tse_rx_depth 					= pmac->tse_rx_depth;
 821f830:	d0a07f83 	ldbu	r2,-32258(gp)
 821f834:	11003fcc 	andi	r4,r2,255
 821f838:	2100201c 	xori	r4,r4,128
 821f83c:	213fe004 	addi	r4,r4,-128
 821f840:	e0bffa17 	ldw	r2,-24(fp)
 821f844:	10c0018b 	ldhu	r3,6(r2)
 821f848:	00820974 	movhi	r2,2085
 821f84c:	1087b804 	addi	r2,r2,7904
 821f850:	21001224 	muli	r4,r4,72
 821f854:	1105883a 	add	r2,r2,r4
 821f858:	10800184 	addi	r2,r2,6
 821f85c:	10c0000d 	sth	r3,0(r2)
		tse_mac_device[tse_system_count].tse_use_mdio 					= pmac->tse_use_mdio;
 821f860:	d0a07f83 	ldbu	r2,-32258(gp)
 821f864:	11003fcc 	andi	r4,r2,255
 821f868:	2100201c 	xori	r4,r4,128
 821f86c:	213fe004 	addi	r4,r4,-128
 821f870:	e0bffa17 	ldw	r2,-24(fp)
 821f874:	10c00203 	ldbu	r3,8(r2)
 821f878:	00820974 	movhi	r2,2085
 821f87c:	1087b804 	addi	r2,r2,7904
 821f880:	21001224 	muli	r4,r4,72
 821f884:	1105883a 	add	r2,r2,r4
 821f888:	10800204 	addi	r2,r2,8
 821f88c:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_en_maclite 				= pmac->tse_en_maclite;
 821f890:	d0a07f83 	ldbu	r2,-32258(gp)
 821f894:	11003fcc 	andi	r4,r2,255
 821f898:	2100201c 	xori	r4,r4,128
 821f89c:	213fe004 	addi	r4,r4,-128
 821f8a0:	e0bffa17 	ldw	r2,-24(fp)
 821f8a4:	10c00243 	ldbu	r3,9(r2)
 821f8a8:	00820974 	movhi	r2,2085
 821f8ac:	1087b804 	addi	r2,r2,7904
 821f8b0:	21001224 	muli	r4,r4,72
 821f8b4:	1105883a 	add	r2,r2,r4
 821f8b8:	10800244 	addi	r2,r2,9
 821f8bc:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_maclite_gige 				= pmac->tse_maclite_gige;
 821f8c0:	d0a07f83 	ldbu	r2,-32258(gp)
 821f8c4:	11003fcc 	andi	r4,r2,255
 821f8c8:	2100201c 	xori	r4,r4,128
 821f8cc:	213fe004 	addi	r4,r4,-128
 821f8d0:	e0bffa17 	ldw	r2,-24(fp)
 821f8d4:	10c00283 	ldbu	r3,10(r2)
 821f8d8:	00820974 	movhi	r2,2085
 821f8dc:	1087b804 	addi	r2,r2,7904
 821f8e0:	21001224 	muli	r4,r4,72
 821f8e4:	1105883a 	add	r2,r2,r4
 821f8e8:	10800284 	addi	r2,r2,10
 821f8ec:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_multichannel_mac 			= pmac->tse_multichannel_mac;
 821f8f0:	d0a07f83 	ldbu	r2,-32258(gp)
 821f8f4:	11003fcc 	andi	r4,r2,255
 821f8f8:	2100201c 	xori	r4,r4,128
 821f8fc:	213fe004 	addi	r4,r4,-128
 821f900:	e0bffa17 	ldw	r2,-24(fp)
 821f904:	10c002c3 	ldbu	r3,11(r2)
 821f908:	00820974 	movhi	r2,2085
 821f90c:	1087b804 	addi	r2,r2,7904
 821f910:	21001224 	muli	r4,r4,72
 821f914:	1105883a 	add	r2,r2,r4
 821f918:	108002c4 	addi	r2,r2,11
 821f91c:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_num_of_channel 			= pmac->tse_num_of_channel;
 821f920:	d0a07f83 	ldbu	r2,-32258(gp)
 821f924:	11003fcc 	andi	r4,r2,255
 821f928:	2100201c 	xori	r4,r4,128
 821f92c:	213fe004 	addi	r4,r4,-128
 821f930:	e0bffa17 	ldw	r2,-24(fp)
 821f934:	10c00303 	ldbu	r3,12(r2)
 821f938:	00820974 	movhi	r2,2085
 821f93c:	1087b804 	addi	r2,r2,7904
 821f940:	21001224 	muli	r4,r4,72
 821f944:	1105883a 	add	r2,r2,r4
 821f948:	10800304 	addi	r2,r2,12
 821f94c:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_mdio_shared 				= pmac->tse_mdio_shared;
 821f950:	d0a07f83 	ldbu	r2,-32258(gp)
 821f954:	11003fcc 	andi	r4,r2,255
 821f958:	2100201c 	xori	r4,r4,128
 821f95c:	213fe004 	addi	r4,r4,-128
 821f960:	e0bffa17 	ldw	r2,-24(fp)
 821f964:	10c00343 	ldbu	r3,13(r2)
 821f968:	00820974 	movhi	r2,2085
 821f96c:	1087b804 	addi	r2,r2,7904
 821f970:	21001224 	muli	r4,r4,72
 821f974:	1105883a 	add	r2,r2,r4
 821f978:	10800344 	addi	r2,r2,13
 821f97c:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_number_of_mac_mdio_shared	= pmac->tse_number_of_mac_mdio_shared;
 821f980:	d0a07f83 	ldbu	r2,-32258(gp)
 821f984:	11003fcc 	andi	r4,r2,255
 821f988:	2100201c 	xori	r4,r4,128
 821f98c:	213fe004 	addi	r4,r4,-128
 821f990:	e0bffa17 	ldw	r2,-24(fp)
 821f994:	10c00383 	ldbu	r3,14(r2)
 821f998:	00820974 	movhi	r2,2085
 821f99c:	1087b804 	addi	r2,r2,7904
 821f9a0:	21001224 	muli	r4,r4,72
 821f9a4:	1105883a 	add	r2,r2,r4
 821f9a8:	10800384 	addi	r2,r2,14
 821f9ac:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_pcs_ena 					= pmac->tse_pcs_ena;
 821f9b0:	d0a07f83 	ldbu	r2,-32258(gp)
 821f9b4:	11003fcc 	andi	r4,r2,255
 821f9b8:	2100201c 	xori	r4,r4,128
 821f9bc:	213fe004 	addi	r4,r4,-128
 821f9c0:	e0bffa17 	ldw	r2,-24(fp)
 821f9c4:	10c003c3 	ldbu	r3,15(r2)
 821f9c8:	00820974 	movhi	r2,2085
 821f9cc:	1087b804 	addi	r2,r2,7904
 821f9d0:	21001224 	muli	r4,r4,72
 821f9d4:	1105883a 	add	r2,r2,r4
 821f9d8:	108003c4 	addi	r2,r2,15
 821f9dc:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_pcs_sgmii 					= pmac->tse_pcs_sgmii;
 821f9e0:	d0a07f83 	ldbu	r2,-32258(gp)
 821f9e4:	11003fcc 	andi	r4,r2,255
 821f9e8:	2100201c 	xori	r4,r4,128
 821f9ec:	213fe004 	addi	r4,r4,-128
 821f9f0:	e0bffa17 	ldw	r2,-24(fp)
 821f9f4:	10c00403 	ldbu	r3,16(r2)
 821f9f8:	00820974 	movhi	r2,2085
 821f9fc:	1087b804 	addi	r2,r2,7904
 821fa00:	21001224 	muli	r4,r4,72
 821fa04:	1105883a 	add	r2,r2,r4
 821fa08:	10800404 	addi	r2,r2,16
 821fa0c:	10c00005 	stb	r3,0(r2)
		
		/* Add SGDMA info to alt_tse_system_info structure */
		if(psgdma == 0) {
 821fa10:	e0bff617 	ldw	r2,-40(fp)
 821fa14:	10000d1e 	bne	r2,zero,821fa4c <alt_tse_system_add_sys+0x39c>
			tse_dprintf(2, "ERROR   : SGDMA system structure == NULL\n");
 821fa18:	01020974 	movhi	r4,2085
 821fa1c:	21386c04 	addi	r4,r4,-7760
 821fa20:	82036240 	call	8203624 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys() for tse_mac_device[%d]\n", tse_system_count);
 821fa24:	d0a07f83 	ldbu	r2,-32258(gp)
 821fa28:	10803fcc 	andi	r2,r2,255
 821fa2c:	1080201c 	xori	r2,r2,128
 821fa30:	10bfe004 	addi	r2,r2,-128
 821fa34:	100b883a 	mov	r5,r2
 821fa38:	01020974 	movhi	r4,2085
 821fa3c:	21387704 	addi	r4,r4,-7716
 821fa40:	82033a00 	call	82033a0 <printf>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 821fa44:	00bfffc4 	movi	r2,-1
 821fa48:	00019206 	br	8220094 <alt_tse_system_add_sys+0x9e4>
		}
		
		tse_mac_device[tse_system_count].tse_sgdma_tx = (char *) malloc(strlen(psgdma->tse_sgdma_tx) + 1);
 821fa4c:	d0a07f83 	ldbu	r2,-32258(gp)
 821fa50:	14003fcc 	andi	r16,r2,255
 821fa54:	8400201c 	xori	r16,r16,128
 821fa58:	843fe004 	addi	r16,r16,-128
 821fa5c:	e0bff617 	ldw	r2,-40(fp)
 821fa60:	10800017 	ldw	r2,0(r2)
 821fa64:	1009883a 	mov	r4,r2
 821fa68:	8203f600 	call	8203f60 <strlen>
 821fa6c:	10800044 	addi	r2,r2,1
 821fa70:	1009883a 	mov	r4,r2
 821fa74:	824b6900 	call	824b690 <malloc>
 821fa78:	1009883a 	mov	r4,r2
 821fa7c:	00820974 	movhi	r2,2085
 821fa80:	1087b804 	addi	r2,r2,7904
 821fa84:	80c01224 	muli	r3,r16,72
 821fa88:	10c5883a 	add	r2,r2,r3
 821fa8c:	10800504 	addi	r2,r2,20
 821fa90:	11000015 	stw	r4,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_tx) {
 821fa94:	d0a07f83 	ldbu	r2,-32258(gp)
 821fa98:	10c03fcc 	andi	r3,r2,255
 821fa9c:	18c0201c 	xori	r3,r3,128
 821faa0:	18ffe004 	addi	r3,r3,-128
 821faa4:	00820974 	movhi	r2,2085
 821faa8:	1087b804 	addi	r2,r2,7904
 821faac:	18c01224 	muli	r3,r3,72
 821fab0:	10c5883a 	add	r2,r2,r3
 821fab4:	10800504 	addi	r2,r2,20
 821fab8:	10800017 	ldw	r2,0(r2)
 821fabc:	10000a1e 	bne	r2,zero,821fae8 <alt_tse_system_add_sys+0x438>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_tx\n", tse_system_count);
 821fac0:	d0a07f83 	ldbu	r2,-32258(gp)
 821fac4:	10803fcc 	andi	r2,r2,255
 821fac8:	1080201c 	xori	r2,r2,128
 821facc:	10bfe004 	addi	r2,r2,-128
 821fad0:	100b883a 	mov	r5,r2
 821fad4:	01020974 	movhi	r4,2085
 821fad8:	21388f04 	addi	r4,r4,-7620
 821fadc:	82033a00 	call	82033a0 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 821fae0:	00bfffc4 	movi	r2,-1
 821fae4:	00016b06 	br	8220094 <alt_tse_system_add_sys+0x9e4>
	    }   
		strcpy(tse_mac_device[tse_system_count].tse_sgdma_tx, psgdma->tse_sgdma_tx);
 821fae8:	d0a07f83 	ldbu	r2,-32258(gp)
 821faec:	10c03fcc 	andi	r3,r2,255
 821faf0:	18c0201c 	xori	r3,r3,128
 821faf4:	18ffe004 	addi	r3,r3,-128
 821faf8:	00820974 	movhi	r2,2085
 821fafc:	1087b804 	addi	r2,r2,7904
 821fb00:	18c01224 	muli	r3,r3,72
 821fb04:	10c5883a 	add	r2,r2,r3
 821fb08:	10800504 	addi	r2,r2,20
 821fb0c:	10c00017 	ldw	r3,0(r2)
 821fb10:	e0bff617 	ldw	r2,-40(fp)
 821fb14:	10800017 	ldw	r2,0(r2)
 821fb18:	100b883a 	mov	r5,r2
 821fb1c:	1809883a 	mov	r4,r3
 821fb20:	824b6b80 	call	824b6b8 <strcpy>
		
		tse_mac_device[tse_system_count].tse_sgdma_rx = (char *) malloc(strlen(psgdma->tse_sgdma_rx) + 1);
 821fb24:	d0a07f83 	ldbu	r2,-32258(gp)
 821fb28:	14003fcc 	andi	r16,r2,255
 821fb2c:	8400201c 	xori	r16,r16,128
 821fb30:	843fe004 	addi	r16,r16,-128
 821fb34:	e0bff617 	ldw	r2,-40(fp)
 821fb38:	10800117 	ldw	r2,4(r2)
 821fb3c:	1009883a 	mov	r4,r2
 821fb40:	8203f600 	call	8203f60 <strlen>
 821fb44:	10800044 	addi	r2,r2,1
 821fb48:	1009883a 	mov	r4,r2
 821fb4c:	824b6900 	call	824b690 <malloc>
 821fb50:	1009883a 	mov	r4,r2
 821fb54:	00820974 	movhi	r2,2085
 821fb58:	1087b804 	addi	r2,r2,7904
 821fb5c:	80c01224 	muli	r3,r16,72
 821fb60:	10c5883a 	add	r2,r2,r3
 821fb64:	10800604 	addi	r2,r2,24
 821fb68:	11000015 	stw	r4,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_rx) {
 821fb6c:	d0a07f83 	ldbu	r2,-32258(gp)
 821fb70:	10c03fcc 	andi	r3,r2,255
 821fb74:	18c0201c 	xori	r3,r3,128
 821fb78:	18ffe004 	addi	r3,r3,-128
 821fb7c:	00820974 	movhi	r2,2085
 821fb80:	1087b804 	addi	r2,r2,7904
 821fb84:	18c01224 	muli	r3,r3,72
 821fb88:	10c5883a 	add	r2,r2,r3
 821fb8c:	10800604 	addi	r2,r2,24
 821fb90:	10800017 	ldw	r2,0(r2)
 821fb94:	10000a1e 	bne	r2,zero,821fbc0 <alt_tse_system_add_sys+0x510>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_rx\n", tse_system_count);
 821fb98:	d0a07f83 	ldbu	r2,-32258(gp)
 821fb9c:	10803fcc 	andi	r2,r2,255
 821fba0:	1080201c 	xori	r2,r2,128
 821fba4:	10bfe004 	addi	r2,r2,-128
 821fba8:	100b883a 	mov	r5,r2
 821fbac:	01020974 	movhi	r4,2085
 821fbb0:	2138a204 	addi	r4,r4,-7544
 821fbb4:	82033a00 	call	82033a0 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 821fbb8:	00bfffc4 	movi	r2,-1
 821fbbc:	00013506 	br	8220094 <alt_tse_system_add_sys+0x9e4>
	    }
	    strcpy(tse_mac_device[tse_system_count].tse_sgdma_rx, psgdma->tse_sgdma_rx);
 821fbc0:	d0a07f83 	ldbu	r2,-32258(gp)
 821fbc4:	10c03fcc 	andi	r3,r2,255
 821fbc8:	18c0201c 	xori	r3,r3,128
 821fbcc:	18ffe004 	addi	r3,r3,-128
 821fbd0:	00820974 	movhi	r2,2085
 821fbd4:	1087b804 	addi	r2,r2,7904
 821fbd8:	18c01224 	muli	r3,r3,72
 821fbdc:	10c5883a 	add	r2,r2,r3
 821fbe0:	10800604 	addi	r2,r2,24
 821fbe4:	10c00017 	ldw	r3,0(r2)
 821fbe8:	e0bff617 	ldw	r2,-40(fp)
 821fbec:	10800117 	ldw	r2,4(r2)
 821fbf0:	100b883a 	mov	r5,r2
 821fbf4:	1809883a 	mov	r4,r3
 821fbf8:	824b6b80 	call	824b6b8 <strcpy>
	    
		tse_mac_device[tse_system_count].tse_sgdma_rx_irq = psgdma->tse_sgdma_rx_irq;
 821fbfc:	d0a07f83 	ldbu	r2,-32258(gp)
 821fc00:	11003fcc 	andi	r4,r2,255
 821fc04:	2100201c 	xori	r4,r4,128
 821fc08:	213fe004 	addi	r4,r4,-128
 821fc0c:	e0bff617 	ldw	r2,-40(fp)
 821fc10:	10c0020b 	ldhu	r3,8(r2)
 821fc14:	00820974 	movhi	r2,2085
 821fc18:	1087b804 	addi	r2,r2,7904
 821fc1c:	21001224 	muli	r4,r4,72
 821fc20:	1105883a 	add	r2,r2,r4
 821fc24:	10800704 	addi	r2,r2,28
 821fc28:	10c0000d 	sth	r3,0(r2)
		
		/* Add descriptor memory info to alt_tse_system_info structure */
		if(pmem == 0) {
 821fc2c:	e0bff717 	ldw	r2,-36(fp)
 821fc30:	1000151e 	bne	r2,zero,821fc88 <alt_tse_system_add_sys+0x5d8>
			tse_mac_device[tse_system_count].ext_desc_mem	= TSE_INT_DESC_MEM;
 821fc34:	d0a07f83 	ldbu	r2,-32258(gp)
 821fc38:	10c03fcc 	andi	r3,r2,255
 821fc3c:	18c0201c 	xori	r3,r3,128
 821fc40:	18ffe004 	addi	r3,r3,-128
 821fc44:	00820974 	movhi	r2,2085
 821fc48:	1087b804 	addi	r2,r2,7904
 821fc4c:	18c01224 	muli	r3,r3,72
 821fc50:	10c5883a 	add	r2,r2,r3
 821fc54:	10800784 	addi	r2,r2,30
 821fc58:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= TSE_INT_DESC_MEM;
 821fc5c:	d0a07f83 	ldbu	r2,-32258(gp)
 821fc60:	10c03fcc 	andi	r3,r2,255
 821fc64:	18c0201c 	xori	r3,r3,128
 821fc68:	18ffe004 	addi	r3,r3,-128
 821fc6c:	00820974 	movhi	r2,2085
 821fc70:	1087b804 	addi	r2,r2,7904
 821fc74:	18c01224 	muli	r3,r3,72
 821fc78:	10c5883a 	add	r2,r2,r3
 821fc7c:	10800804 	addi	r2,r2,32
 821fc80:	10000015 	stw	zero,0(r2)
 821fc84:	00001806 	br	821fce8 <alt_tse_system_add_sys+0x638>
		}
		else {
			tse_mac_device[tse_system_count].ext_desc_mem	= pmem->ext_desc_mem;
 821fc88:	d0a07f83 	ldbu	r2,-32258(gp)
 821fc8c:	11003fcc 	andi	r4,r2,255
 821fc90:	2100201c 	xori	r4,r4,128
 821fc94:	213fe004 	addi	r4,r4,-128
 821fc98:	e0bff717 	ldw	r2,-36(fp)
 821fc9c:	10c00003 	ldbu	r3,0(r2)
 821fca0:	00820974 	movhi	r2,2085
 821fca4:	1087b804 	addi	r2,r2,7904
 821fca8:	21001224 	muli	r4,r4,72
 821fcac:	1105883a 	add	r2,r2,r4
 821fcb0:	10800784 	addi	r2,r2,30
 821fcb4:	10c00005 	stb	r3,0(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= pmem->desc_mem_base;
 821fcb8:	d0a07f83 	ldbu	r2,-32258(gp)
 821fcbc:	11003fcc 	andi	r4,r2,255
 821fcc0:	2100201c 	xori	r4,r4,128
 821fcc4:	213fe004 	addi	r4,r4,-128
 821fcc8:	e0bff717 	ldw	r2,-36(fp)
 821fccc:	10c00117 	ldw	r3,4(r2)
 821fcd0:	00820974 	movhi	r2,2085
 821fcd4:	1087b804 	addi	r2,r2,7904
 821fcd8:	21001224 	muli	r4,r4,72
 821fcdc:	1105883a 	add	r2,r2,r4
 821fce0:	10800804 	addi	r2,r2,32
 821fce4:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add shared fifo info to alt_tse_system_info structure */
		if(pfifo == 0) {
 821fce8:	e0bff817 	ldw	r2,-32(fp)
 821fcec:	1000471e 	bne	r2,zero,821fe0c <alt_tse_system_add_sys+0x75c>
			tse_mac_device[tse_system_count].use_shared_fifo                = TSE_NO_SHARED_FIFO;
 821fcf0:	d0a07f83 	ldbu	r2,-32258(gp)
 821fcf4:	10c03fcc 	andi	r3,r2,255
 821fcf8:	18c0201c 	xori	r3,r3,128
 821fcfc:	18ffe004 	addi	r3,r3,-128
 821fd00:	00820974 	movhi	r2,2085
 821fd04:	1087b804 	addi	r2,r2,7904
 821fd08:	18c01224 	muli	r3,r3,72
 821fd0c:	10c5883a 	add	r2,r2,r3
 821fd10:	10800904 	addi	r2,r2,36
 821fd14:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= TSE_NO_SHARED_FIFO;
 821fd18:	d0a07f83 	ldbu	r2,-32258(gp)
 821fd1c:	10c03fcc 	andi	r3,r2,255
 821fd20:	18c0201c 	xori	r3,r3,128
 821fd24:	18ffe004 	addi	r3,r3,-128
 821fd28:	00820974 	movhi	r2,2085
 821fd2c:	1087b804 	addi	r2,r2,7904
 821fd30:	18c01224 	muli	r3,r3,72
 821fd34:	10c5883a 	add	r2,r2,r3
 821fd38:	10800a04 	addi	r2,r2,40
 821fd3c:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= TSE_NO_SHARED_FIFO;
 821fd40:	d0a07f83 	ldbu	r2,-32258(gp)
 821fd44:	10c03fcc 	andi	r3,r2,255
 821fd48:	18c0201c 	xori	r3,r3,128
 821fd4c:	18ffe004 	addi	r3,r3,-128
 821fd50:	00820974 	movhi	r2,2085
 821fd54:	1087b804 	addi	r2,r2,7904
 821fd58:	18c01224 	muli	r3,r3,72
 821fd5c:	10c5883a 	add	r2,r2,r3
 821fd60:	10800b04 	addi	r2,r2,44
 821fd64:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = TSE_NO_SHARED_FIFO;
 821fd68:	d0a07f83 	ldbu	r2,-32258(gp)
 821fd6c:	10c03fcc 	andi	r3,r2,255
 821fd70:	18c0201c 	xori	r3,r3,128
 821fd74:	18ffe004 	addi	r3,r3,-128
 821fd78:	00820974 	movhi	r2,2085
 821fd7c:	1087b804 	addi	r2,r2,7904
 821fd80:	18c01224 	muli	r3,r3,72
 821fd84:	10c5883a 	add	r2,r2,r3
 821fd88:	10800c04 	addi	r2,r2,48
 821fd8c:	10000015 	stw	zero,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= TSE_NO_SHARED_FIFO;
 821fd90:	d0a07f83 	ldbu	r2,-32258(gp)
 821fd94:	10c03fcc 	andi	r3,r2,255
 821fd98:	18c0201c 	xori	r3,r3,128
 821fd9c:	18ffe004 	addi	r3,r3,-128
 821fda0:	00820974 	movhi	r2,2085
 821fda4:	1087b804 	addi	r2,r2,7904
 821fda8:	18c01224 	muli	r3,r3,72
 821fdac:	10c5883a 	add	r2,r2,r3
 821fdb0:	10800d04 	addi	r2,r2,52
 821fdb4:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= TSE_NO_SHARED_FIFO;
 821fdb8:	d0a07f83 	ldbu	r2,-32258(gp)
 821fdbc:	10c03fcc 	andi	r3,r2,255
 821fdc0:	18c0201c 	xori	r3,r3,128
 821fdc4:	18ffe004 	addi	r3,r3,-128
 821fdc8:	00820974 	movhi	r2,2085
 821fdcc:	1087b804 	addi	r2,r2,7904
 821fdd0:	18c01224 	muli	r3,r3,72
 821fdd4:	10c5883a 	add	r2,r2,r3
 821fdd8:	10800e04 	addi	r2,r2,56
 821fddc:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = TSE_NO_SHARED_FIFO;
 821fde0:	d0a07f83 	ldbu	r2,-32258(gp)
 821fde4:	10c03fcc 	andi	r3,r2,255
 821fde8:	18c0201c 	xori	r3,r3,128
 821fdec:	18ffe004 	addi	r3,r3,-128
 821fdf0:	00820974 	movhi	r2,2085
 821fdf4:	1087b804 	addi	r2,r2,7904
 821fdf8:	18c01224 	muli	r3,r3,72
 821fdfc:	10c5883a 	add	r2,r2,r3
 821fe00:	10800f04 	addi	r2,r2,60
 821fe04:	10000015 	stw	zero,0(r2)
 821fe08:	00005406 	br	821ff5c <alt_tse_system_add_sys+0x8ac>
		}
		else {
			tse_mac_device[tse_system_count].use_shared_fifo                = pfifo->use_shared_fifo;
 821fe0c:	d0a07f83 	ldbu	r2,-32258(gp)
 821fe10:	11003fcc 	andi	r4,r2,255
 821fe14:	2100201c 	xori	r4,r4,128
 821fe18:	213fe004 	addi	r4,r4,-128
 821fe1c:	e0bff817 	ldw	r2,-32(fp)
 821fe20:	10c00003 	ldbu	r3,0(r2)
 821fe24:	00820974 	movhi	r2,2085
 821fe28:	1087b804 	addi	r2,r2,7904
 821fe2c:	21001224 	muli	r4,r4,72
 821fe30:	1105883a 	add	r2,r2,r4
 821fe34:	10800904 	addi	r2,r2,36
 821fe38:	10c00005 	stb	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= pfifo->tse_shared_fifo_tx_ctrl_base;
 821fe3c:	d0a07f83 	ldbu	r2,-32258(gp)
 821fe40:	11003fcc 	andi	r4,r2,255
 821fe44:	2100201c 	xori	r4,r4,128
 821fe48:	213fe004 	addi	r4,r4,-128
 821fe4c:	e0bff817 	ldw	r2,-32(fp)
 821fe50:	10c00117 	ldw	r3,4(r2)
 821fe54:	00820974 	movhi	r2,2085
 821fe58:	1087b804 	addi	r2,r2,7904
 821fe5c:	21001224 	muli	r4,r4,72
 821fe60:	1105883a 	add	r2,r2,r4
 821fe64:	10800a04 	addi	r2,r2,40
 821fe68:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= pfifo->tse_shared_fifo_tx_stat_base;
 821fe6c:	d0a07f83 	ldbu	r2,-32258(gp)
 821fe70:	11003fcc 	andi	r4,r2,255
 821fe74:	2100201c 	xori	r4,r4,128
 821fe78:	213fe004 	addi	r4,r4,-128
 821fe7c:	e0bff817 	ldw	r2,-32(fp)
 821fe80:	10c00217 	ldw	r3,8(r2)
 821fe84:	00820974 	movhi	r2,2085
 821fe88:	1087b804 	addi	r2,r2,7904
 821fe8c:	21001224 	muli	r4,r4,72
 821fe90:	1105883a 	add	r2,r2,r4
 821fe94:	10800b04 	addi	r2,r2,44
 821fe98:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = pfifo->tse_shared_fifo_tx_depth;
 821fe9c:	d0a07f83 	ldbu	r2,-32258(gp)
 821fea0:	11003fcc 	andi	r4,r2,255
 821fea4:	2100201c 	xori	r4,r4,128
 821fea8:	213fe004 	addi	r4,r4,-128
 821feac:	e0bff817 	ldw	r2,-32(fp)
 821feb0:	10c00317 	ldw	r3,12(r2)
 821feb4:	00820974 	movhi	r2,2085
 821feb8:	1087b804 	addi	r2,r2,7904
 821febc:	21001224 	muli	r4,r4,72
 821fec0:	1105883a 	add	r2,r2,r4
 821fec4:	10800c04 	addi	r2,r2,48
 821fec8:	10c00015 	stw	r3,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= pfifo->tse_shared_fifo_rx_ctrl_base;
 821fecc:	d0a07f83 	ldbu	r2,-32258(gp)
 821fed0:	11003fcc 	andi	r4,r2,255
 821fed4:	2100201c 	xori	r4,r4,128
 821fed8:	213fe004 	addi	r4,r4,-128
 821fedc:	e0bff817 	ldw	r2,-32(fp)
 821fee0:	10c00417 	ldw	r3,16(r2)
 821fee4:	00820974 	movhi	r2,2085
 821fee8:	1087b804 	addi	r2,r2,7904
 821feec:	21001224 	muli	r4,r4,72
 821fef0:	1105883a 	add	r2,r2,r4
 821fef4:	10800d04 	addi	r2,r2,52
 821fef8:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= pfifo->tse_shared_fifo_rx_stat_base;
 821fefc:	d0a07f83 	ldbu	r2,-32258(gp)
 821ff00:	11003fcc 	andi	r4,r2,255
 821ff04:	2100201c 	xori	r4,r4,128
 821ff08:	213fe004 	addi	r4,r4,-128
 821ff0c:	e0bff817 	ldw	r2,-32(fp)
 821ff10:	10c00517 	ldw	r3,20(r2)
 821ff14:	00820974 	movhi	r2,2085
 821ff18:	1087b804 	addi	r2,r2,7904
 821ff1c:	21001224 	muli	r4,r4,72
 821ff20:	1105883a 	add	r2,r2,r4
 821ff24:	10800e04 	addi	r2,r2,56
 821ff28:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = pfifo->tse_shared_fifo_rx_depth;
 821ff2c:	d0a07f83 	ldbu	r2,-32258(gp)
 821ff30:	11003fcc 	andi	r4,r2,255
 821ff34:	2100201c 	xori	r4,r4,128
 821ff38:	213fe004 	addi	r4,r4,-128
 821ff3c:	e0bff817 	ldw	r2,-32(fp)
 821ff40:	10c00617 	ldw	r3,24(r2)
 821ff44:	00820974 	movhi	r2,2085
 821ff48:	1087b804 	addi	r2,r2,7904
 821ff4c:	21001224 	muli	r4,r4,72
 821ff50:	1105883a 	add	r2,r2,r4
 821ff54:	10800f04 	addi	r2,r2,60
 821ff58:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add PHY info to alt_tse_system_info structure */
		if(pphy == 0) {
 821ff5c:	e0bff917 	ldw	r2,-28(fp)
 821ff60:	1000161e 	bne	r2,zero,821ffbc <alt_tse_system_add_sys+0x90c>
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= TSE_PHY_AUTO_ADDRESS;
 821ff64:	d0a07f83 	ldbu	r2,-32258(gp)
 821ff68:	10c03fcc 	andi	r3,r2,255
 821ff6c:	18c0201c 	xori	r3,r3,128
 821ff70:	18ffe004 	addi	r3,r3,-128
 821ff74:	00820974 	movhi	r2,2085
 821ff78:	1087b804 	addi	r2,r2,7904
 821ff7c:	18c01224 	muli	r3,r3,72
 821ff80:	10c5883a 	add	r2,r2,r3
 821ff84:	10801004 	addi	r2,r2,64
 821ff88:	00ffffc4 	movi	r3,-1
 821ff8c:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= 0;
 821ff90:	d0a07f83 	ldbu	r2,-32258(gp)
 821ff94:	10c03fcc 	andi	r3,r2,255
 821ff98:	18c0201c 	xori	r3,r3,128
 821ff9c:	18ffe004 	addi	r3,r3,-128
 821ffa0:	00820974 	movhi	r2,2085
 821ffa4:	1087b804 	addi	r2,r2,7904
 821ffa8:	18c01224 	muli	r3,r3,72
 821ffac:	10c5883a 	add	r2,r2,r3
 821ffb0:	10801104 	addi	r2,r2,68
 821ffb4:	10000015 	stw	zero,0(r2)
 821ffb8:	00001806 	br	822001c <alt_tse_system_add_sys+0x96c>
		}
		else {
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= pphy->tse_phy_mdio_address;
 821ffbc:	d0a07f83 	ldbu	r2,-32258(gp)
 821ffc0:	11003fcc 	andi	r4,r2,255
 821ffc4:	2100201c 	xori	r4,r4,128
 821ffc8:	213fe004 	addi	r4,r4,-128
 821ffcc:	e0bff917 	ldw	r2,-28(fp)
 821ffd0:	10c00017 	ldw	r3,0(r2)
 821ffd4:	00820974 	movhi	r2,2085
 821ffd8:	1087b804 	addi	r2,r2,7904
 821ffdc:	21001224 	muli	r4,r4,72
 821ffe0:	1105883a 	add	r2,r2,r4
 821ffe4:	10801004 	addi	r2,r2,64
 821ffe8:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= pphy->tse_phy_cfg;
 821ffec:	d0a07f83 	ldbu	r2,-32258(gp)
 821fff0:	11003fcc 	andi	r4,r2,255
 821fff4:	2100201c 	xori	r4,r4,128
 821fff8:	213fe004 	addi	r4,r4,-128
 821fffc:	e0bff917 	ldw	r2,-28(fp)
 8220000:	10c00117 	ldw	r3,4(r2)
 8220004:	00820974 	movhi	r2,2085
 8220008:	1087b804 	addi	r2,r2,7904
 822000c:	21001224 	muli	r4,r4,72
 8220010:	1105883a 	add	r2,r2,r4
 8220014:	10801104 	addi	r2,r2,68
 8220018:	10c00015 	stw	r3,0(r2)
		}
		
		/* Point to next structure */
		psgdma++;
 822001c:	e0bff617 	ldw	r2,-40(fp)
 8220020:	10800304 	addi	r2,r2,12
 8220024:	e0bff615 	stw	r2,-40(fp)
		if(pmem) pmem++;
 8220028:	e0bff717 	ldw	r2,-36(fp)
 822002c:	10000326 	beq	r2,zero,822003c <alt_tse_system_add_sys+0x98c>
 8220030:	e0bff717 	ldw	r2,-36(fp)
 8220034:	10800204 	addi	r2,r2,8
 8220038:	e0bff715 	stw	r2,-36(fp)
		if(pfifo) pfifo++;
 822003c:	e0bff817 	ldw	r2,-32(fp)
 8220040:	10000326 	beq	r2,zero,8220050 <alt_tse_system_add_sys+0x9a0>
 8220044:	e0bff817 	ldw	r2,-32(fp)
 8220048:	10800704 	addi	r2,r2,28
 822004c:	e0bff815 	stw	r2,-32(fp)
		if(pphy) pphy++;
 8220050:	e0bff917 	ldw	r2,-28(fp)
 8220054:	10000326 	beq	r2,zero,8220064 <alt_tse_system_add_sys+0x9b4>
 8220058:	e0bff917 	ldw	r2,-28(fp)
 822005c:	10800204 	addi	r2,r2,8
 8220060:	e0bff915 	stw	r2,-28(fp)
		
		tse_system_count++;
 8220064:	d0a07f83 	ldbu	r2,-32258(gp)
 8220068:	10800044 	addi	r2,r2,1
 822006c:	d0a07f85 	stb	r2,-32258(gp)
		max_mac_system = tse_system_count;
 8220070:	d0a07f83 	ldbu	r2,-32258(gp)
 8220074:	d0a02d05 	stb	r2,-32588(gp)
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
	}

	for(i = 0; i < loop_end; i++) {
 8220078:	e0bff417 	ldw	r2,-48(fp)
 822007c:	10800044 	addi	r2,r2,1
 8220080:	e0bff415 	stw	r2,-48(fp)
 8220084:	e0fff417 	ldw	r3,-48(fp)
 8220088:	e0bff517 	ldw	r2,-44(fp)
 822008c:	18bdb216 	blt	r3,r2,821f758 <alt_tse_system_add_sys+0xa8>
		
		tse_system_count++;
		max_mac_system = tse_system_count;
	}
	
	return SUCCESS;
 8220090:	0005883a 	mov	r2,zero
	
}
 8220094:	e6ffff04 	addi	sp,fp,-4
 8220098:	dfc00217 	ldw	ra,8(sp)
 822009c:	df000117 	ldw	fp,4(sp)
 82200a0:	dc000017 	ldw	r16,0(sp)
 82200a4:	dec00304 	addi	sp,sp,12
 82200a8:	f800283a 	ret

082200ac <alt_tse_sys_enable_mdio_sharing>:
 * @param		number_of_mac  number of MAC sharing MDIO block
 * @return      SUCCESS on success
 * 				ALTERA_TSE_SYSTEM_DEF_ERROR if definition of system incorrect or pointer == NULL
 * Multi-channel MAC not supported
 */
alt_32 alt_tse_sys_enable_mdio_sharing(alt_tse_system_mac **psys_mac_list, alt_u8 number_of_mac) {
 82200ac:	defff904 	addi	sp,sp,-28
 82200b0:	dfc00615 	stw	ra,24(sp)
 82200b4:	df000515 	stw	fp,20(sp)
 82200b8:	df000504 	addi	fp,sp,20
 82200bc:	e13ffe15 	stw	r4,-8(fp)
 82200c0:	2805883a 	mov	r2,r5
 82200c4:	e0bfff05 	stb	r2,-4(fp)
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 82200c8:	e03ffb15 	stw	zero,-20(fp)
 82200cc:	00004806 	br	82201f0 <alt_tse_sys_enable_mdio_sharing+0x144>
		psys_mac = psys_mac_list[i];
 82200d0:	e0bffb17 	ldw	r2,-20(fp)
 82200d4:	1085883a 	add	r2,r2,r2
 82200d8:	1085883a 	add	r2,r2,r2
 82200dc:	1007883a 	mov	r3,r2
 82200e0:	e0bffe17 	ldw	r2,-8(fp)
 82200e4:	10c5883a 	add	r2,r2,r3
 82200e8:	10800017 	ldw	r2,0(r2)
 82200ec:	e0bffd15 	stw	r2,-12(fp)
		
		if(psys_mac == 0) {
 82200f0:	e0bffd17 	ldw	r2,-12(fp)
 82200f4:	1000081e 	bne	r2,zero,8220118 <alt_tse_sys_enable_mdio_sharing+0x6c>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 82200f8:	01020974 	movhi	r4,2085
 82200fc:	21385004 	addi	r4,r4,-7872
 8220100:	82036240 	call	8203624 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
 8220104:	01020974 	movhi	r4,2085
 8220108:	2138b504 	addi	r4,r4,-7468
 822010c:	82036240 	call	8203624 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 8220110:	00bfffc4 	movi	r2,-1
 8220114:	00003a06 	br	8220200 <alt_tse_sys_enable_mdio_sharing+0x154>
		}
		
		for(j = 0; j < max_mac_system; j++) {
 8220118:	e03ffc15 	stw	zero,-16(fp)
 822011c:	00002d06 	br	82201d4 <alt_tse_sys_enable_mdio_sharing+0x128>
			
			if(psys_mac->tse_mac_base == tse_mac_device[j].tse_mac_base) {
 8220120:	e0bffd17 	ldw	r2,-12(fp)
 8220124:	10c00017 	ldw	r3,0(r2)
 8220128:	00820974 	movhi	r2,2085
 822012c:	1087b804 	addi	r2,r2,7904
 8220130:	e13ffc17 	ldw	r4,-16(fp)
 8220134:	21001224 	muli	r4,r4,72
 8220138:	1105883a 	add	r2,r2,r4
 822013c:	10800017 	ldw	r2,0(r2)
 8220140:	1880211e 	bne	r3,r2,82201c8 <alt_tse_sys_enable_mdio_sharing+0x11c>
				if(tse_mac_device[j].tse_multichannel_mac) {
 8220144:	00820974 	movhi	r2,2085
 8220148:	1087b804 	addi	r2,r2,7904
 822014c:	e0fffc17 	ldw	r3,-16(fp)
 8220150:	18c01224 	muli	r3,r3,72
 8220154:	10c5883a 	add	r2,r2,r3
 8220158:	108002c4 	addi	r2,r2,11
 822015c:	10800003 	ldbu	r2,0(r2)
 8220160:	10803fcc 	andi	r2,r2,255
 8220164:	10000826 	beq	r2,zero,8220188 <alt_tse_sys_enable_mdio_sharing+0xdc>
					tse_dprintf(2, "ERROR   : MDIO sharing supported by default for Multi-channel MAC\n");
 8220168:	01020974 	movhi	r4,2085
 822016c:	2138c904 	addi	r4,r4,-7388
 8220170:	82036240 	call	8203624 <puts>
					tse_dprintf(2, "ERROR   : Do not include Multi-channel MAC in the MAC List\n");
 8220174:	01020974 	movhi	r4,2085
 8220178:	2138da04 	addi	r4,r4,-7320
 822017c:	82036240 	call	8203624 <puts>
					return ALTERA_TSE_SYSTEM_DEF_ERROR;
 8220180:	00bfffc4 	movi	r2,-1
 8220184:	00001e06 	br	8220200 <alt_tse_sys_enable_mdio_sharing+0x154>
				}
				
				tse_mac_device[j].tse_mdio_shared = 1;
 8220188:	00820974 	movhi	r2,2085
 822018c:	1087b804 	addi	r2,r2,7904
 8220190:	e0fffc17 	ldw	r3,-16(fp)
 8220194:	18c01224 	muli	r3,r3,72
 8220198:	10c5883a 	add	r2,r2,r3
 822019c:	10800344 	addi	r2,r2,13
 82201a0:	00c00044 	movi	r3,1
 82201a4:	10c00005 	stb	r3,0(r2)
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
 82201a8:	00820974 	movhi	r2,2085
 82201ac:	1087b804 	addi	r2,r2,7904
 82201b0:	e0fffc17 	ldw	r3,-16(fp)
 82201b4:	18c01224 	muli	r3,r3,72
 82201b8:	10c5883a 	add	r2,r2,r3
 82201bc:	10800384 	addi	r2,r2,14
 82201c0:	e0ffff03 	ldbu	r3,-4(fp)
 82201c4:	10c00005 	stb	r3,0(r2)
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}
		
		for(j = 0; j < max_mac_system; j++) {
 82201c8:	e0bffc17 	ldw	r2,-16(fp)
 82201cc:	10800044 	addi	r2,r2,1
 82201d0:	e0bffc15 	stw	r2,-16(fp)
 82201d4:	d0a02d03 	ldbu	r2,-32588(gp)
 82201d8:	10803fcc 	andi	r2,r2,255
 82201dc:	e0fffc17 	ldw	r3,-16(fp)
 82201e0:	18bfcf16 	blt	r3,r2,8220120 <alt_tse_sys_enable_mdio_sharing+0x74>
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 82201e4:	e0bffb17 	ldw	r2,-20(fp)
 82201e8:	10800044 	addi	r2,r2,1
 82201ec:	e0bffb15 	stw	r2,-20(fp)
 82201f0:	e0bfff03 	ldbu	r2,-4(fp)
 82201f4:	e0fffb17 	ldw	r3,-20(fp)
 82201f8:	18bfb516 	blt	r3,r2,82200d0 <alt_tse_sys_enable_mdio_sharing+0x24>
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
			}
		}	
	}
	
	return SUCCESS;
 82201fc:	0005883a 	mov	r2,zero
}
 8220200:	e037883a 	mov	sp,fp
 8220204:	dfc00117 	ldw	ra,4(sp)
 8220208:	df000017 	ldw	fp,0(sp)
 822020c:	dec00204 	addi	sp,sp,8
 8220210:	f800283a 	ret

08220214 <alt_tse_mac_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Public
 * @param pmac          Pointer to the TSE MAC Control Interface Base address
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_mac_get_common_speed(np_tse_mac *pmac) {
 8220214:	defffc04 	addi	sp,sp,-16
 8220218:	dfc00315 	stw	ra,12(sp)
 822021c:	df000215 	stw	fp,8(sp)
 8220220:	df000204 	addi	fp,sp,8
 8220224:	e13fff15 	stw	r4,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 8220228:	e13fff17 	ldw	r4,-4(fp)
 822022c:	82203fc0 	call	82203fc <alt_tse_get_mac_info>
 8220230:	10800317 	ldw	r2,12(r2)
 8220234:	e0bffe15 	stw	r2,-8(fp)
    return alt_tse_phy_get_common_speed(pmac_group);
 8220238:	e13ffe17 	ldw	r4,-8(fp)
 822023c:	82235cc0 	call	82235cc <alt_tse_phy_get_common_speed>
}
 8220240:	e037883a 	mov	sp,fp
 8220244:	dfc00117 	ldw	ra,4(sp)
 8220248:	df000017 	ldw	fp,0(sp)
 822024c:	dec00204 	addi	sp,sp,8
 8220250:	f800283a 	ret

08220254 <alt_tse_mac_set_common_speed>:
 * @API Type:               Public
 * @param pmac              Pointer to the TSE MAC Control Interface Base address
 *        common_speed      common speed supported by all PHYs
 * @return                  common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_mac_set_common_speed(np_tse_mac *pmac, alt_32 common_speed) {
 8220254:	defffb04 	addi	sp,sp,-20
 8220258:	dfc00415 	stw	ra,16(sp)
 822025c:	df000315 	stw	fp,12(sp)
 8220260:	df000304 	addi	fp,sp,12
 8220264:	e13ffe15 	stw	r4,-8(fp)
 8220268:	e17fff15 	stw	r5,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 822026c:	e13ffe17 	ldw	r4,-8(fp)
 8220270:	82203fc0 	call	82203fc <alt_tse_get_mac_info>
 8220274:	10800317 	ldw	r2,12(r2)
 8220278:	e0bffd15 	stw	r2,-12(fp)
    return alt_tse_phy_set_common_speed(pmac_group, common_speed);
 822027c:	e17fff17 	ldw	r5,-4(fp)
 8220280:	e13ffd17 	ldw	r4,-12(fp)
 8220284:	82238f40 	call	82238f4 <alt_tse_phy_set_common_speed>
}
 8220288:	e037883a 	mov	sp,fp
 822028c:	dfc00117 	ldw	ra,4(sp)
 8220290:	df000017 	ldw	fp,0(sp)
 8220294:	dec00204 	addi	sp,sp,8
 8220298:	f800283a 	ret

0822029c <alt_tse_get_system_index>:
/* @Function Description: Get the index of alt_tse_system_info structure in tse_mac_device[]
 * @API Type:        Internal
 * @param psys_info  Pointer to the alt_tse_system_info structure
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
 822029c:	defffd04 	addi	sp,sp,-12
 82202a0:	df000215 	stw	fp,8(sp)
 82202a4:	df000204 	addi	fp,sp,8
 82202a8:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 82202ac:	e03ffe15 	stw	zero,-8(fp)
 82202b0:	00000c06 	br	82202e4 <alt_tse_get_system_index+0x48>
        if(psys_info == &tse_mac_device[i]) {
 82202b4:	e0bffe17 	ldw	r2,-8(fp)
 82202b8:	10c01224 	muli	r3,r2,72
 82202bc:	00820974 	movhi	r2,2085
 82202c0:	1087b804 	addi	r2,r2,7904
 82202c4:	1887883a 	add	r3,r3,r2
 82202c8:	e0bfff17 	ldw	r2,-4(fp)
 82202cc:	1880021e 	bne	r3,r2,82202d8 <alt_tse_get_system_index+0x3c>
            return i;
 82202d0:	e0bffe17 	ldw	r2,-8(fp)
 82202d4:	00000806 	br	82202f8 <alt_tse_get_system_index+0x5c>
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 82202d8:	e0bffe17 	ldw	r2,-8(fp)
 82202dc:	10800044 	addi	r2,r2,1
 82202e0:	e0bffe15 	stw	r2,-8(fp)
 82202e4:	d0a02d03 	ldbu	r2,-32588(gp)
 82202e8:	10803fcc 	andi	r2,r2,255
 82202ec:	e0fffe17 	ldw	r3,-8(fp)
 82202f0:	18bff016 	blt	r3,r2,82202b4 <alt_tse_get_system_index+0x18>
        if(psys_info == &tse_mac_device[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 82202f4:	00bfffc4 	movi	r2,-1
}
 82202f8:	e037883a 	mov	sp,fp
 82202fc:	df000017 	ldw	fp,0(sp)
 8220300:	dec00104 	addi	sp,sp,4
 8220304:	f800283a 	ret

08220308 <alt_tse_get_mac_group_index>:
/* @Function Description: Get the index of alt_tse_mac_group structure in pmac_groups[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_group structure
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
 8220308:	defffd04 	addi	sp,sp,-12
 822030c:	df000215 	stw	fp,8(sp)
 8220310:	df000204 	addi	fp,sp,8
 8220314:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 8220318:	e03ffe15 	stw	zero,-8(fp)
 822031c:	00000e06 	br	8220358 <alt_tse_get_mac_group_index+0x50>
        if(pmac_group == pmac_groups[i]) {
 8220320:	008209b4 	movhi	r2,2086
 8220324:	10b6f604 	addi	r2,r2,-9256
 8220328:	e0fffe17 	ldw	r3,-8(fp)
 822032c:	18c7883a 	add	r3,r3,r3
 8220330:	18c7883a 	add	r3,r3,r3
 8220334:	10c5883a 	add	r2,r2,r3
 8220338:	10c00017 	ldw	r3,0(r2)
 822033c:	e0bfff17 	ldw	r2,-4(fp)
 8220340:	1880021e 	bne	r3,r2,822034c <alt_tse_get_mac_group_index+0x44>
            return i;
 8220344:	e0bffe17 	ldw	r2,-8(fp)
 8220348:	00000806 	br	822036c <alt_tse_get_mac_group_index+0x64>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 822034c:	e0bffe17 	ldw	r2,-8(fp)
 8220350:	10800044 	addi	r2,r2,1
 8220354:	e0bffe15 	stw	r2,-8(fp)
 8220358:	d0a07f43 	ldbu	r2,-32259(gp)
 822035c:	10803fcc 	andi	r2,r2,255
 8220360:	e0fffe17 	ldw	r3,-8(fp)
 8220364:	18bfee16 	blt	r3,r2,8220320 <alt_tse_get_mac_group_index+0x18>
        if(pmac_group == pmac_groups[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 8220368:	00bfffc4 	movi	r2,-1
}
 822036c:	e037883a 	mov	sp,fp
 8220370:	df000017 	ldw	fp,0(sp)
 8220374:	dec00104 	addi	sp,sp,4
 8220378:	f800283a 	ret

0822037c <alt_tse_get_mac_info_index>:
/* @Function Description: Get the index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_info structure
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
 822037c:	defffd04 	addi	sp,sp,-12
 8220380:	df000215 	stw	fp,8(sp)
 8220384:	df000204 	addi	fp,sp,8
 8220388:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 822038c:	e03ffe15 	stw	zero,-8(fp)
 8220390:	00000f06 	br	82203d0 <alt_tse_get_mac_info_index+0x54>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
 8220394:	e0bfff17 	ldw	r2,-4(fp)
 8220398:	10c00317 	ldw	r3,12(r2)
 822039c:	e0bffe17 	ldw	r2,-8(fp)
 82203a0:	10800044 	addi	r2,r2,1
 82203a4:	1085883a 	add	r2,r2,r2
 82203a8:	1085883a 	add	r2,r2,r2
 82203ac:	1885883a 	add	r2,r3,r2
 82203b0:	10c00017 	ldw	r3,0(r2)
 82203b4:	e0bfff17 	ldw	r2,-4(fp)
 82203b8:	1880021e 	bne	r3,r2,82203c4 <alt_tse_get_mac_info_index+0x48>
            return i;
 82203bc:	e0bffe17 	ldw	r2,-8(fp)
 82203c0:	00000a06 	br	82203ec <alt_tse_get_mac_info_index+0x70>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 82203c4:	e0bffe17 	ldw	r2,-8(fp)
 82203c8:	10800044 	addi	r2,r2,1
 82203cc:	e0bffe15 	stw	r2,-8(fp)
 82203d0:	e0bfff17 	ldw	r2,-4(fp)
 82203d4:	10800317 	ldw	r2,12(r2)
 82203d8:	10800003 	ldbu	r2,0(r2)
 82203dc:	10803fcc 	andi	r2,r2,255
 82203e0:	e0fffe17 	ldw	r3,-8(fp)
 82203e4:	18bfeb16 	blt	r3,r2,8220394 <alt_tse_get_mac_info_index+0x18>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
            return i;
        }
    }
    
    return ALTERA_TSE_NO_INDEX_FOUND;
 82203e8:	00bfffc4 	movi	r2,-1
}
 82203ec:	e037883a 	mov	sp,fp
 82203f0:	df000017 	ldw	fp,0(sp)
 82203f4:	dec00104 	addi	sp,sp,4
 82203f8:	f800283a 	ret

082203fc <alt_tse_get_mac_info>:
/* @Function Description: Get the pointer of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac        Pointer to the TSE MAC Control Interface Base address
 * @return            Pointer to alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_tse_mac_info *alt_tse_get_mac_info(np_tse_mac *pmac) {
 82203fc:	defffa04 	addi	sp,sp,-24
 8220400:	df000515 	stw	fp,20(sp)
 8220404:	df000504 	addi	fp,sp,20
 8220408:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
 822040c:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
 8220410:	e03ffe15 	stw	zero,-8(fp)
    
    for(i = 0; i < mac_group_count; i++) {
 8220414:	e03ffb15 	stw	zero,-20(fp)
 8220418:	00002506 	br	82204b0 <alt_tse_get_mac_info+0xb4>
        pmac_group = pmac_groups[i];
 822041c:	008209b4 	movhi	r2,2086
 8220420:	10b6f604 	addi	r2,r2,-9256
 8220424:	e0fffb17 	ldw	r3,-20(fp)
 8220428:	18c7883a 	add	r3,r3,r3
 822042c:	18c7883a 	add	r3,r3,r3
 8220430:	10c5883a 	add	r2,r2,r3
 8220434:	10800017 	ldw	r2,0(r2)
 8220438:	e0bffd15 	stw	r2,-12(fp)
        for(j = 0; j < pmac_group->channel; j++) {
 822043c:	e03ffc15 	stw	zero,-16(fp)
 8220440:	00001306 	br	8220490 <alt_tse_get_mac_info+0x94>
            pmac_info = pmac_group->pmac_info[j];
 8220444:	e0fffd17 	ldw	r3,-12(fp)
 8220448:	e0bffc17 	ldw	r2,-16(fp)
 822044c:	10800044 	addi	r2,r2,1
 8220450:	1085883a 	add	r2,r2,r2
 8220454:	1085883a 	add	r2,r2,r2
 8220458:	1885883a 	add	r2,r3,r2
 822045c:	10800017 	ldw	r2,0(r2)
 8220460:	e0bffe15 	stw	r2,-8(fp)
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
 8220464:	e0bffe17 	ldw	r2,-8(fp)
 8220468:	10800217 	ldw	r2,8(r2)
 822046c:	10800017 	ldw	r2,0(r2)
 8220470:	1007883a 	mov	r3,r2
 8220474:	e0bfff17 	ldw	r2,-4(fp)
 8220478:	1880021e 	bne	r3,r2,8220484 <alt_tse_get_mac_info+0x88>
                return pmac_info;
 822047c:	e0bffe17 	ldw	r2,-8(fp)
 8220480:	00001006 	br	82204c4 <alt_tse_get_mac_info+0xc8>
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
 8220484:	e0bffc17 	ldw	r2,-16(fp)
 8220488:	10800044 	addi	r2,r2,1
 822048c:	e0bffc15 	stw	r2,-16(fp)
 8220490:	e0bffd17 	ldw	r2,-12(fp)
 8220494:	10800003 	ldbu	r2,0(r2)
 8220498:	10803fcc 	andi	r2,r2,255
 822049c:	e0fffc17 	ldw	r3,-16(fp)
 82204a0:	18bfe816 	blt	r3,r2,8220444 <alt_tse_get_mac_info+0x48>
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
 82204a4:	e0bffb17 	ldw	r2,-20(fp)
 82204a8:	10800044 	addi	r2,r2,1
 82204ac:	e0bffb15 	stw	r2,-20(fp)
 82204b0:	d0a07f43 	ldbu	r2,-32259(gp)
 82204b4:	10803fcc 	andi	r2,r2,255
 82204b8:	e0fffb17 	ldw	r3,-20(fp)
 82204bc:	18bfd716 	blt	r3,r2,822041c <alt_tse_get_mac_info+0x20>
                return pmac_info;
            }
        }        
    }
    
    return 0;
 82204c0:	0005883a 	mov	r2,zero
}
 82204c4:	e037883a 	mov	sp,fp
 82204c8:	df000017 	ldw	fp,0(sp)
 82204cc:	dec00104 	addi	sp,sp,4
 82204d0:	f800283a 	ret

082204d4 <alt_tse_mac_set_speed>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param speed 2 = 1000 Mbps, 1 = 100 Mbps, 0 = 10 Mbps
 * @return ENP_PARAM if invalid speed specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_speed(np_tse_mac *pmac, alt_u8 speed)
{
 82204d4:	defffc04 	addi	sp,sp,-16
 82204d8:	df000315 	stw	fp,12(sp)
 82204dc:	df000304 	addi	fp,sp,12
 82204e0:	e13ffe15 	stw	r4,-8(fp)
 82204e4:	2805883a 	mov	r2,r5
 82204e8:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 82204ec:	e0bffe17 	ldw	r2,-8(fp)
 82204f0:	10800204 	addi	r2,r2,8
 82204f4:	10800037 	ldwio	r2,0(r2)
 82204f8:	e0bffd15 	stw	r2,-12(fp)
  
  /* 1000 Mbps */
  if(speed == TSE_PHY_SPEED_1000) {
 82204fc:	e0bfff03 	ldbu	r2,-4(fp)
 8220500:	10800098 	cmpnei	r2,r2,2
 8220504:	1000091e 	bne	r2,zero,822052c <alt_tse_mac_set_speed+0x58>
    helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 8220508:	e0bffd17 	ldw	r2,-12(fp)
 822050c:	10800214 	ori	r2,r2,8
 8220510:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8220514:	e0fffd17 	ldw	r3,-12(fp)
 8220518:	00bf8034 	movhi	r2,65024
 822051c:	10bfffc4 	addi	r2,r2,-1
 8220520:	1884703a 	and	r2,r3,r2
 8220524:	e0bffd15 	stw	r2,-12(fp)
 8220528:	00001906 	br	8220590 <alt_tse_mac_set_speed+0xbc>
  }
  /* 100 Mbps */
  else if(speed == TSE_PHY_SPEED_100) {
 822052c:	e0bfff03 	ldbu	r2,-4(fp)
 8220530:	10800058 	cmpnei	r2,r2,1
 8220534:	10000a1e 	bne	r2,zero,8220560 <alt_tse_mac_set_speed+0x8c>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 8220538:	e0fffd17 	ldw	r3,-12(fp)
 822053c:	00bffdc4 	movi	r2,-9
 8220540:	1884703a 	and	r2,r3,r2
 8220544:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8220548:	e0fffd17 	ldw	r3,-12(fp)
 822054c:	00bf8034 	movhi	r2,65024
 8220550:	10bfffc4 	addi	r2,r2,-1
 8220554:	1884703a 	and	r2,r3,r2
 8220558:	e0bffd15 	stw	r2,-12(fp)
 822055c:	00000c06 	br	8220590 <alt_tse_mac_set_speed+0xbc>
  }
  /* 10 Mbps */
  else if(speed == TSE_PHY_SPEED_10) {
 8220560:	e0bfff03 	ldbu	r2,-4(fp)
 8220564:	1000081e 	bne	r2,zero,8220588 <alt_tse_mac_set_speed+0xb4>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 8220568:	e0fffd17 	ldw	r3,-12(fp)
 822056c:	00bffdc4 	movi	r2,-9
 8220570:	1884703a 	and	r2,r3,r2
 8220574:	e0bffd15 	stw	r2,-12(fp)
	helpvar |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8220578:	e0bffd17 	ldw	r2,-12(fp)
 822057c:	10808034 	orhi	r2,r2,512
 8220580:	e0bffd15 	stw	r2,-12(fp)
 8220584:	00000206 	br	8220590 <alt_tse_mac_set_speed+0xbc>
  }  
  else {
    return ENP_PARAM;
 8220588:	00bffd84 	movi	r2,-10
 822058c:	00000506 	br	82205a4 <alt_tse_mac_set_speed+0xd0>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 8220590:	e0bffe17 	ldw	r2,-8(fp)
 8220594:	10800204 	addi	r2,r2,8
 8220598:	e0fffd17 	ldw	r3,-12(fp)
 822059c:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 82205a0:	0005883a 	mov	r2,zero
}
 82205a4:	e037883a 	mov	sp,fp
 82205a8:	df000017 	ldw	fp,0(sp)
 82205ac:	dec00104 	addi	sp,sp,4
 82205b0:	f800283a 	ret

082205b4 <alt_tse_mac_set_duplex>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param duplex 1 = Full Duplex, 0 = Half Duplex
 * @return ENP_PARAM if invalid duplex specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_duplex(np_tse_mac *pmac, alt_u8 duplex)
{
 82205b4:	defffc04 	addi	sp,sp,-16
 82205b8:	df000315 	stw	fp,12(sp)
 82205bc:	df000304 	addi	fp,sp,12
 82205c0:	e13ffe15 	stw	r4,-8(fp)
 82205c4:	2805883a 	mov	r2,r5
 82205c8:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 82205cc:	e0bffe17 	ldw	r2,-8(fp)
 82205d0:	10800204 	addi	r2,r2,8
 82205d4:	10800037 	ldwio	r2,0(r2)
 82205d8:	e0bffd15 	stw	r2,-12(fp)
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
 82205dc:	e0bfff03 	ldbu	r2,-4(fp)
 82205e0:	1000041e 	bne	r2,zero,82205f4 <alt_tse_mac_set_duplex+0x40>
    helpvar |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 82205e4:	e0bffd17 	ldw	r2,-12(fp)
 82205e8:	10810014 	ori	r2,r2,1024
 82205ec:	e0bffd15 	stw	r2,-12(fp)
 82205f0:	00000a06 	br	822061c <alt_tse_mac_set_duplex+0x68>
  } 
  /* Full Duplex */
  else if(duplex == TSE_PHY_DUPLEX_FULL) {
 82205f4:	e0bfff03 	ldbu	r2,-4(fp)
 82205f8:	10800058 	cmpnei	r2,r2,1
 82205fc:	1000051e 	bne	r2,zero,8220614 <alt_tse_mac_set_duplex+0x60>
    helpvar &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 8220600:	e0fffd17 	ldw	r3,-12(fp)
 8220604:	00beffc4 	movi	r2,-1025
 8220608:	1884703a 	and	r2,r3,r2
 822060c:	e0bffd15 	stw	r2,-12(fp)
 8220610:	00000206 	br	822061c <alt_tse_mac_set_duplex+0x68>
  }
  else {
    return ENP_PARAM;
 8220614:	00bffd84 	movi	r2,-10
 8220618:	00000506 	br	8220630 <alt_tse_mac_set_duplex+0x7c>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 822061c:	e0bffe17 	ldw	r2,-8(fp)
 8220620:	10800204 	addi	r2,r2,8
 8220624:	e0fffd17 	ldw	r3,-12(fp)
 8220628:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 822062c:	0005883a 	mov	r2,zero

}
 8220630:	e037883a 	mov	sp,fp
 8220634:	df000017 	ldw	fp,0(sp)
 8220638:	dec00104 	addi	sp,sp,4
 822063c:	f800283a 	ret

08220640 <getPHYSpeed>:
  	(((speed == TSE_PHY_SPEED_1000) ? 1 : 0) << 1) |   \
	(((speed == TSE_PHY_SPEED_100) ? 1 : 0) << 2) |     \
	(((speed == TSE_PHY_SPEED_10) ? 1 : 0) << 3) |      \
	((speed == TSE_PHY_SPEED_INVALID) ? ALT_TSE_E_INVALID_SPEED : 0))
  
alt_32 getPHYSpeed(np_tse_mac *pmac) {
 8220640:	defff404 	addi	sp,sp,-48
 8220644:	dfc00b15 	stw	ra,44(sp)
 8220648:	df000a15 	stw	fp,40(sp)
 822064c:	df000a04 	addi	fp,sp,40
 8220650:	e13fff15 	stw	r4,-4(fp)

	alt_u8 speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220654:	00800044 	movi	r2,1
 8220658:	e0bff705 	stb	r2,-36(fp)
	alt_u8 duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;     /* 1 = full ; 0 = half*/
 822065c:	00800044 	movi	r2,1
 8220660:	e0bff745 	stb	r2,-35(fp)
	alt_32 result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 8220664:	e0bff743 	ldbu	r2,-35(fp)
 8220668:	10c0004c 	andi	r3,r2,1
 822066c:	e0bff703 	ldbu	r2,-36(fp)
 8220670:	10800098 	cmpnei	r2,r2,2
 8220674:	1000021e 	bne	r2,zero,8220680 <getPHYSpeed+0x40>
 8220678:	00800084 	movi	r2,2
 822067c:	00000106 	br	8220684 <getPHYSpeed+0x44>
 8220680:	0005883a 	mov	r2,zero
 8220684:	1886b03a 	or	r3,r3,r2
 8220688:	e0bff703 	ldbu	r2,-36(fp)
 822068c:	10800058 	cmpnei	r2,r2,1
 8220690:	1000021e 	bne	r2,zero,822069c <getPHYSpeed+0x5c>
 8220694:	00800104 	movi	r2,4
 8220698:	00000106 	br	82206a0 <getPHYSpeed+0x60>
 822069c:	0005883a 	mov	r2,zero
 82206a0:	1886b03a 	or	r3,r3,r2
 82206a4:	e0bff703 	ldbu	r2,-36(fp)
 82206a8:	1000021e 	bne	r2,zero,82206b4 <getPHYSpeed+0x74>
 82206ac:	00800204 	movi	r2,8
 82206b0:	00000106 	br	82206b8 <getPHYSpeed+0x78>
 82206b4:	0005883a 	mov	r2,zero
 82206b8:	1886b03a 	or	r3,r3,r2
 82206bc:	e0bff703 	ldbu	r2,-36(fp)
 82206c0:	108000d8 	cmpnei	r2,r2,3
 82206c4:	1000021e 	bne	r2,zero,82206d0 <getPHYSpeed+0x90>
 82206c8:	00800074 	movhi	r2,1
 82206cc:	00000106 	br	82206d4 <getPHYSpeed+0x94>
 82206d0:	0005883a 	mov	r2,zero
 82206d4:	1884b03a 	or	r2,r3,r2
 82206d8:	e0bff815 	stw	r2,-32(fp)
    
    alt_tse_phy_info *pphy = 0;
 82206dc:	e03ff915 	stw	zero,-28(fp)
    alt_tse_mac_info *pmac_info = 0;
 82206e0:	e03ffa15 	stw	zero,-24(fp)
    alt_tse_mac_group *pmac_group = 0;
 82206e4:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_system_info *psys = 0;
 82206e8:	e03ffc15 	stw	zero,-16(fp)
    
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 82206ec:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = 0;
 82206f0:	e03ffd45 	stb	zero,-11(fp)
    
    /* initialized PHYs only once */
    static alt_u8 is_init = 0;
    if(is_init == 0) {
 82206f4:	d0a07fc3 	ldbu	r2,-32257(gp)
 82206f8:	10803fcc 	andi	r2,r2,255
 82206fc:	1000031e 	bne	r2,zero,822070c <getPHYSpeed+0xcc>
        alt_tse_phy_init();
 8220700:	82226400 	call	8222640 <alt_tse_phy_init>
        is_init = 1;
 8220704:	00800044 	movi	r2,1
 8220708:	d0a07fc5 	stb	r2,-32257(gp)
    }
    
    /* Look for pmac_group and pmac_info structure based on pmac or iface */
    pmac_info = alt_tse_get_mac_info(pmac);
 822070c:	e13fff17 	ldw	r4,-4(fp)
 8220710:	82203fc0 	call	82203fc <alt_tse_get_mac_info>
 8220714:	e0bffa15 	stw	r2,-24(fp)
    
    if(pmac_info == 0) {
 8220718:	e0bffa17 	ldw	r2,-24(fp)
 822071c:	1000481e 	bne	r2,zero,8220840 <getPHYSpeed+0x200>
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220720:	00800044 	movi	r2,1
 8220724:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 8220728:	00800044 	movi	r2,1
 822072c:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PMAC_FOUND;
 8220730:	e0bff743 	ldbu	r2,-35(fp)
 8220734:	10c0004c 	andi	r3,r2,1
 8220738:	e0bff703 	ldbu	r2,-36(fp)
 822073c:	10800098 	cmpnei	r2,r2,2
 8220740:	1000021e 	bne	r2,zero,822074c <getPHYSpeed+0x10c>
 8220744:	00800084 	movi	r2,2
 8220748:	00000106 	br	8220750 <getPHYSpeed+0x110>
 822074c:	0005883a 	mov	r2,zero
 8220750:	1886b03a 	or	r3,r3,r2
 8220754:	e0bff703 	ldbu	r2,-36(fp)
 8220758:	10800058 	cmpnei	r2,r2,1
 822075c:	1000021e 	bne	r2,zero,8220768 <getPHYSpeed+0x128>
 8220760:	00800104 	movi	r2,4
 8220764:	00000106 	br	822076c <getPHYSpeed+0x12c>
 8220768:	0005883a 	mov	r2,zero
 822076c:	1886b03a 	or	r3,r3,r2
 8220770:	e0bff703 	ldbu	r2,-36(fp)
 8220774:	1000021e 	bne	r2,zero,8220780 <getPHYSpeed+0x140>
 8220778:	00800204 	movi	r2,8
 822077c:	00000106 	br	8220784 <getPHYSpeed+0x144>
 8220780:	0005883a 	mov	r2,zero
 8220784:	1886b03a 	or	r3,r3,r2
 8220788:	e0bff703 	ldbu	r2,-36(fp)
 822078c:	108000d8 	cmpnei	r2,r2,3
 8220790:	1000021e 	bne	r2,zero,822079c <getPHYSpeed+0x15c>
 8220794:	00800074 	movhi	r2,1
 8220798:	00000106 	br	82207a0 <getPHYSpeed+0x160>
 822079c:	0005883a 	mov	r2,zero
 82207a0:	1884b03a 	or	r2,r3,r2
 82207a4:	10802034 	orhi	r2,r2,128
 82207a8:	e0bff815 	stw	r2,-32(fp)
        tse_dprintf(2, "ERROR   : [getPHYSpeed] pmac not found from list of pmac_info[]! Speed = %s Mbps, Duplex = %s\n", speed == TSE_PHY_SPEED_1000 ? "1000" :
 82207ac:	e0bff703 	ldbu	r2,-36(fp)
 82207b0:	108000a0 	cmpeqi	r2,r2,2
 82207b4:	10000e1e 	bne	r2,zero,82207f0 <getPHYSpeed+0x1b0>
 82207b8:	e0bff703 	ldbu	r2,-36(fp)
 82207bc:	10800060 	cmpeqi	r2,r2,1
 82207c0:	1000081e 	bne	r2,zero,82207e4 <getPHYSpeed+0x1a4>
 82207c4:	e0bff703 	ldbu	r2,-36(fp)
 82207c8:	1000031e 	bne	r2,zero,82207d8 <getPHYSpeed+0x198>
 82207cc:	00820974 	movhi	r2,2085
 82207d0:	10b8e904 	addi	r2,r2,-7260
 82207d4:	00000806 	br	82207f8 <getPHYSpeed+0x1b8>
 82207d8:	00820974 	movhi	r2,2085
 82207dc:	10b8ea04 	addi	r2,r2,-7256
 82207e0:	00000506 	br	82207f8 <getPHYSpeed+0x1b8>
 82207e4:	00820974 	movhi	r2,2085
 82207e8:	10b8ec04 	addi	r2,r2,-7248
 82207ec:	00000206 	br	82207f8 <getPHYSpeed+0x1b8>
 82207f0:	00820974 	movhi	r2,2085
 82207f4:	10b8ed04 	addi	r2,r2,-7244
 82207f8:	e0fff743 	ldbu	r3,-35(fp)
 82207fc:	18c00058 	cmpnei	r3,r3,1
 8220800:	1800031e 	bne	r3,zero,8220810 <getPHYSpeed+0x1d0>
 8220804:	00c20974 	movhi	r3,2085
 8220808:	18f8ef04 	addi	r3,r3,-7236
 822080c:	00000206 	br	8220818 <getPHYSpeed+0x1d8>
 8220810:	00c20974 	movhi	r3,2085
 8220814:	18f8f104 	addi	r3,r3,-7228
 8220818:	180d883a 	mov	r6,r3
 822081c:	100b883a 	mov	r5,r2
 8220820:	01020974 	movhi	r4,2085
 8220824:	2138f304 	addi	r4,r4,-7220
 8220828:	82033a00 	call	82033a0 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        tse_dprintf(2, "ERROR   : [getPHYSpeed] Please define tse_mac_device[] correctly\n");
 822082c:	01020974 	movhi	r4,2085
 8220830:	21390b04 	addi	r4,r4,-7124
 8220834:	82036240 	call	8203624 <puts>
        return result;
 8220838:	e0bff817 	ldw	r2,-32(fp)
 822083c:	00021d06 	br	82210b4 <getPHYSpeed+0xa74>
    }
    
    pphy = pmac_info->pphy_info;
 8220840:	e0bffa17 	ldw	r2,-24(fp)
 8220844:	10800117 	ldw	r2,4(r2)
 8220848:	e0bff915 	stw	r2,-28(fp)
    pmac_group = pmac_info->pmac_group;
 822084c:	e0bffa17 	ldw	r2,-24(fp)
 8220850:	10800317 	ldw	r2,12(r2)
 8220854:	e0bffb15 	stw	r2,-20(fp)
    psys = pmac_info->psys_info;
 8220858:	e0bffa17 	ldw	r2,-24(fp)
 822085c:	10800217 	ldw	r2,8(r2)
 8220860:	e0bffc15 	stw	r2,-16(fp)
    
    mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8220864:	e13ffa17 	ldw	r4,-24(fp)
 8220868:	822037c0 	call	822037c <alt_tse_get_mac_info_index>
 822086c:	e0bffd05 	stb	r2,-12(fp)
    mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8220870:	e13ffb17 	ldw	r4,-20(fp)
 8220874:	82203080 	call	8220308 <alt_tse_get_mac_group_index>
 8220878:	e0bffd45 	stb	r2,-11(fp)
         
    /* MDIO is not used */
    if (pmac_group->pmac_info[0]->psys_info->tse_use_mdio == 0)
 822087c:	e0bffb17 	ldw	r2,-20(fp)
 8220880:	10800117 	ldw	r2,4(r2)
 8220884:	10800217 	ldw	r2,8(r2)
 8220888:	10800203 	ldbu	r2,8(r2)
 822088c:	10803fcc 	andi	r2,r2,255
 8220890:	10005a1e 	bne	r2,zero,82209fc <getPHYSpeed+0x3bc>
    {
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220894:	00800044 	movi	r2,1
 8220898:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 822089c:	00800044 	movi	r2,1
 82208a0:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_MDIO;
 82208a4:	e0bff743 	ldbu	r2,-35(fp)
 82208a8:	10c0004c 	andi	r3,r2,1
 82208ac:	e0bff703 	ldbu	r2,-36(fp)
 82208b0:	10800098 	cmpnei	r2,r2,2
 82208b4:	1000021e 	bne	r2,zero,82208c0 <getPHYSpeed+0x280>
 82208b8:	00800084 	movi	r2,2
 82208bc:	00000106 	br	82208c4 <getPHYSpeed+0x284>
 82208c0:	0005883a 	mov	r2,zero
 82208c4:	1886b03a 	or	r3,r3,r2
 82208c8:	e0bff703 	ldbu	r2,-36(fp)
 82208cc:	10800058 	cmpnei	r2,r2,1
 82208d0:	1000021e 	bne	r2,zero,82208dc <getPHYSpeed+0x29c>
 82208d4:	00800104 	movi	r2,4
 82208d8:	00000106 	br	82208e0 <getPHYSpeed+0x2a0>
 82208dc:	0005883a 	mov	r2,zero
 82208e0:	1886b03a 	or	r3,r3,r2
 82208e4:	e0bff703 	ldbu	r2,-36(fp)
 82208e8:	1000021e 	bne	r2,zero,82208f4 <getPHYSpeed+0x2b4>
 82208ec:	00800204 	movi	r2,8
 82208f0:	00000106 	br	82208f8 <getPHYSpeed+0x2b8>
 82208f4:	0005883a 	mov	r2,zero
 82208f8:	1886b03a 	or	r3,r3,r2
 82208fc:	e0bff703 	ldbu	r2,-36(fp)
 8220900:	108000d8 	cmpnei	r2,r2,3
 8220904:	1000021e 	bne	r2,zero,8220910 <getPHYSpeed+0x2d0>
 8220908:	00800074 	movhi	r2,1
 822090c:	00000106 	br	8220914 <getPHYSpeed+0x2d4>
 8220910:	0005883a 	mov	r2,zero
 8220914:	1884b03a 	or	r2,r3,r2
 8220918:	10801034 	orhi	r2,r2,64
 822091c:	e0bff815 	stw	r2,-32(fp)
        usleep(ALTERA_NOMDIO_TIMEOUT_THRESHOLD);
 8220920:	010003f4 	movhi	r4,15
 8220924:	21109004 	addi	r4,r4,16960
 8220928:	823ca240 	call	823ca24 <usleep>
        if(psys->tse_phy_cfg) {
 822092c:	e0bffc17 	ldw	r2,-16(fp)
 8220930:	10801117 	ldw	r2,68(r2)
 8220934:	10000d26 	beq	r2,zero,822096c <getPHYSpeed+0x32c>
        	tse_dprintf(4, "WARNING : PHY[%d.%d] - MDIO not enabled! Running user configuration...\n", mac_group_index, mac_info_index);
 8220938:	e0bffd47 	ldb	r2,-11(fp)
 822093c:	e0fffd07 	ldb	r3,-12(fp)
 8220940:	180d883a 	mov	r6,r3
 8220944:	100b883a 	mov	r5,r2
 8220948:	01020974 	movhi	r4,2085
 822094c:	21391c04 	addi	r4,r4,-7056
 8220950:	82033a00 	call	82033a0 <printf>
        	result = psys->tse_phy_cfg(pmac);
 8220954:	e0bffc17 	ldw	r2,-16(fp)
 8220958:	10801117 	ldw	r2,68(r2)
 822095c:	e13fff17 	ldw	r4,-4(fp)
 8220960:	103ee83a 	callr	r2
 8220964:	e0bff815 	stw	r2,-32(fp)
 8220968:	00002206 	br	82209f4 <getPHYSpeed+0x3b4>
        }
        else {
        	tse_dprintf(4, "WARNING : MAC Group[%d] - MDIO not enabled! Speed = %s, Duplex = %s\n", mac_group_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 822096c:	e13ffd47 	ldb	r4,-11(fp)
 8220970:	e0bff703 	ldbu	r2,-36(fp)
 8220974:	108000a0 	cmpeqi	r2,r2,2
 8220978:	10000e1e 	bne	r2,zero,82209b4 <getPHYSpeed+0x374>
 822097c:	e0bff703 	ldbu	r2,-36(fp)
 8220980:	10800060 	cmpeqi	r2,r2,1
 8220984:	1000081e 	bne	r2,zero,82209a8 <getPHYSpeed+0x368>
 8220988:	e0bff703 	ldbu	r2,-36(fp)
 822098c:	1000031e 	bne	r2,zero,822099c <getPHYSpeed+0x35c>
 8220990:	00820974 	movhi	r2,2085
 8220994:	10b8e904 	addi	r2,r2,-7260
 8220998:	00000806 	br	82209bc <getPHYSpeed+0x37c>
 822099c:	00820974 	movhi	r2,2085
 82209a0:	10b8ea04 	addi	r2,r2,-7256
 82209a4:	00000506 	br	82209bc <getPHYSpeed+0x37c>
 82209a8:	00820974 	movhi	r2,2085
 82209ac:	10b8ec04 	addi	r2,r2,-7248
 82209b0:	00000206 	br	82209bc <getPHYSpeed+0x37c>
 82209b4:	00820974 	movhi	r2,2085
 82209b8:	10b8ed04 	addi	r2,r2,-7244
 82209bc:	e0fff743 	ldbu	r3,-35(fp)
 82209c0:	18c00058 	cmpnei	r3,r3,1
 82209c4:	1800031e 	bne	r3,zero,82209d4 <getPHYSpeed+0x394>
 82209c8:	00c20974 	movhi	r3,2085
 82209cc:	18f8ef04 	addi	r3,r3,-7236
 82209d0:	00000206 	br	82209dc <getPHYSpeed+0x39c>
 82209d4:	00c20974 	movhi	r3,2085
 82209d8:	18f8f104 	addi	r3,r3,-7228
 82209dc:	180f883a 	mov	r7,r3
 82209e0:	100d883a 	mov	r6,r2
 82209e4:	200b883a 	mov	r5,r4
 82209e8:	01020974 	movhi	r4,2085
 82209ec:	21392e04 	addi	r4,r4,-6984
 82209f0:	82033a00 	call	82033a0 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        }
        return result;
 82209f4:	e0bff817 	ldw	r2,-32(fp)
 82209f8:	0001ae06 	br	82210b4 <getPHYSpeed+0xa74>

    /* Not running simulation */
    #ifndef ALT_SIM_OPTIMIZE
	
		/* These variables declaration are here to avoid "warning: unused variable" message when compile for simulation */
		np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 82209fc:	e0bffb17 	ldw	r2,-20(fp)
 8220a00:	10800117 	ldw	r2,4(r2)
 8220a04:	10800217 	ldw	r2,8(r2)
 8220a08:	10800017 	ldw	r2,0(r2)
 8220a0c:	e0bffe15 	stw	r2,-8(fp)
    
        /* if no PHY connected to the MAC */
        if(pphy == 0) {
 8220a10:	e0bff917 	ldw	r2,-28(fp)
 8220a14:	1000491e 	bne	r2,zero,8220b3c <getPHYSpeed+0x4fc>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220a18:	00800044 	movi	r2,1
 8220a1c:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 8220a20:	00800044 	movi	r2,1
 8220a24:	e0bff745 	stb	r2,-35(fp)
            result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY;
 8220a28:	e0bff743 	ldbu	r2,-35(fp)
 8220a2c:	10c0004c 	andi	r3,r2,1
 8220a30:	e0bff703 	ldbu	r2,-36(fp)
 8220a34:	10800098 	cmpnei	r2,r2,2
 8220a38:	1000021e 	bne	r2,zero,8220a44 <getPHYSpeed+0x404>
 8220a3c:	00800084 	movi	r2,2
 8220a40:	00000106 	br	8220a48 <getPHYSpeed+0x408>
 8220a44:	0005883a 	mov	r2,zero
 8220a48:	1886b03a 	or	r3,r3,r2
 8220a4c:	e0bff703 	ldbu	r2,-36(fp)
 8220a50:	10800058 	cmpnei	r2,r2,1
 8220a54:	1000021e 	bne	r2,zero,8220a60 <getPHYSpeed+0x420>
 8220a58:	00800104 	movi	r2,4
 8220a5c:	00000106 	br	8220a64 <getPHYSpeed+0x424>
 8220a60:	0005883a 	mov	r2,zero
 8220a64:	1886b03a 	or	r3,r3,r2
 8220a68:	e0bff703 	ldbu	r2,-36(fp)
 8220a6c:	1000021e 	bne	r2,zero,8220a78 <getPHYSpeed+0x438>
 8220a70:	00800204 	movi	r2,8
 8220a74:	00000106 	br	8220a7c <getPHYSpeed+0x43c>
 8220a78:	0005883a 	mov	r2,zero
 8220a7c:	1886b03a 	or	r3,r3,r2
 8220a80:	e0bff703 	ldbu	r2,-36(fp)
 8220a84:	108000d8 	cmpnei	r2,r2,3
 8220a88:	1000021e 	bne	r2,zero,8220a94 <getPHYSpeed+0x454>
 8220a8c:	00800074 	movhi	r2,1
 8220a90:	00000106 	br	8220a98 <getPHYSpeed+0x458>
 8220a94:	0005883a 	mov	r2,zero
 8220a98:	1884b03a 	or	r2,r3,r2
 8220a9c:	10800834 	orhi	r2,r2,32
 8220aa0:	e0bff815 	stw	r2,-32(fp)
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - No PHY connected! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 8220aa4:	e13ffd47 	ldb	r4,-11(fp)
 8220aa8:	e17ffd07 	ldb	r5,-12(fp)
 8220aac:	e0bff703 	ldbu	r2,-36(fp)
 8220ab0:	108000a0 	cmpeqi	r2,r2,2
 8220ab4:	10000e1e 	bne	r2,zero,8220af0 <getPHYSpeed+0x4b0>
 8220ab8:	e0bff703 	ldbu	r2,-36(fp)
 8220abc:	10800060 	cmpeqi	r2,r2,1
 8220ac0:	1000081e 	bne	r2,zero,8220ae4 <getPHYSpeed+0x4a4>
 8220ac4:	e0bff703 	ldbu	r2,-36(fp)
 8220ac8:	1000031e 	bne	r2,zero,8220ad8 <getPHYSpeed+0x498>
 8220acc:	00820974 	movhi	r2,2085
 8220ad0:	10b8e904 	addi	r2,r2,-7260
 8220ad4:	00000806 	br	8220af8 <getPHYSpeed+0x4b8>
 8220ad8:	00820974 	movhi	r2,2085
 8220adc:	10b8ea04 	addi	r2,r2,-7256
 8220ae0:	00000506 	br	8220af8 <getPHYSpeed+0x4b8>
 8220ae4:	00820974 	movhi	r2,2085
 8220ae8:	10b8ec04 	addi	r2,r2,-7248
 8220aec:	00000206 	br	8220af8 <getPHYSpeed+0x4b8>
 8220af0:	00820974 	movhi	r2,2085
 8220af4:	10b8ed04 	addi	r2,r2,-7244
 8220af8:	e0fff743 	ldbu	r3,-35(fp)
 8220afc:	18c00058 	cmpnei	r3,r3,1
 8220b00:	1800031e 	bne	r3,zero,8220b10 <getPHYSpeed+0x4d0>
 8220b04:	00c20974 	movhi	r3,2085
 8220b08:	18f8ef04 	addi	r3,r3,-7236
 8220b0c:	00000206 	br	8220b18 <getPHYSpeed+0x4d8>
 8220b10:	00c20974 	movhi	r3,2085
 8220b14:	18f8f104 	addi	r3,r3,-7228
 8220b18:	d8c00015 	stw	r3,0(sp)
 8220b1c:	100f883a 	mov	r7,r2
 8220b20:	280d883a 	mov	r6,r5
 8220b24:	200b883a 	mov	r5,r4
 8220b28:	01020974 	movhi	r4,2085
 8220b2c:	21394004 	addi	r4,r4,-6912
 8220b30:	82033a00 	call	82033a0 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
            return result;
 8220b34:	e0bff817 	ldw	r2,-32(fp)
 8220b38:	00015e06 	br	82210b4 <getPHYSpeed+0xa74>
        }

		/* Small MAC */
		if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 8220b3c:	e0bffa17 	ldw	r2,-24(fp)
 8220b40:	10800003 	ldbu	r2,0(r2)
 8220b44:	10803fcc 	andi	r2,r2,255
 8220b48:	10800058 	cmpnei	r2,r2,1
 8220b4c:	1000081e 	bne	r2,zero,8220b70 <getPHYSpeed+0x530>
			alt_tse_phy_set_adv_1000(pphy, 0);
 8220b50:	000b883a 	mov	r5,zero
 8220b54:	e13ff917 	ldw	r4,-28(fp)
 8220b58:	822300c0 	call	822300c <alt_tse_phy_set_adv_1000>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 8220b5c:	01400134 	movhi	r5,4
 8220b60:	29742404 	addi	r5,r5,-12144
 8220b64:	e13ff917 	ldw	r4,-28(fp)
 8220b68:	82227580 	call	8222758 <alt_tse_phy_restart_an>
 8220b6c:	00000f06 	br	8220bac <getPHYSpeed+0x56c>
		}
		else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 8220b70:	e0bffa17 	ldw	r2,-24(fp)
 8220b74:	10800003 	ldbu	r2,0(r2)
 8220b78:	10803fcc 	andi	r2,r2,255
 8220b7c:	10800098 	cmpnei	r2,r2,2
 8220b80:	10000a1e 	bne	r2,zero,8220bac <getPHYSpeed+0x56c>
			alt_tse_phy_set_adv_100(pphy, 0);
 8220b84:	000b883a 	mov	r5,zero
 8220b88:	e13ff917 	ldw	r4,-28(fp)
 8220b8c:	82231d00 	call	82231d0 <alt_tse_phy_set_adv_100>
			alt_tse_phy_set_adv_10(pphy, 0);
 8220b90:	000b883a 	mov	r5,zero
 8220b94:	e13ff917 	ldw	r4,-28(fp)
 8220b98:	82234240 	call	8223424 <alt_tse_phy_set_adv_10>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 8220b9c:	01400134 	movhi	r5,4
 8220ba0:	29742404 	addi	r5,r5,-12144
 8220ba4:	e13ff917 	ldw	r4,-28(fp)
 8220ba8:	82227580 	call	8222758 <alt_tse_phy_restart_an>
		}
		
		/* check link connection for this PHY */
		if(alt_tse_phy_check_link(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD) == TSE_PHY_AN_NOT_COMPLETE) {
 8220bac:	01400134 	movhi	r5,4
 8220bb0:	29742404 	addi	r5,r5,-12144
 8220bb4:	e13ff917 	ldw	r4,-28(fp)
 8220bb8:	82229140 	call	8222914 <alt_tse_phy_check_link>
 8220bbc:	10bfffd8 	cmpnei	r2,r2,-1
 8220bc0:	1000491e 	bne	r2,zero,8220ce8 <getPHYSpeed+0x6a8>
			speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220bc4:	00800044 	movi	r2,1
 8220bc8:	e0bff705 	stb	r2,-36(fp)
			duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 8220bcc:	00800044 	movi	r2,1
 8220bd0:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_AN_NOT_COMPLETE;
 8220bd4:	e0bff743 	ldbu	r2,-35(fp)
 8220bd8:	10c0004c 	andi	r3,r2,1
 8220bdc:	e0bff703 	ldbu	r2,-36(fp)
 8220be0:	10800098 	cmpnei	r2,r2,2
 8220be4:	1000021e 	bne	r2,zero,8220bf0 <getPHYSpeed+0x5b0>
 8220be8:	00800084 	movi	r2,2
 8220bec:	00000106 	br	8220bf4 <getPHYSpeed+0x5b4>
 8220bf0:	0005883a 	mov	r2,zero
 8220bf4:	1886b03a 	or	r3,r3,r2
 8220bf8:	e0bff703 	ldbu	r2,-36(fp)
 8220bfc:	10800058 	cmpnei	r2,r2,1
 8220c00:	1000021e 	bne	r2,zero,8220c0c <getPHYSpeed+0x5cc>
 8220c04:	00800104 	movi	r2,4
 8220c08:	00000106 	br	8220c10 <getPHYSpeed+0x5d0>
 8220c0c:	0005883a 	mov	r2,zero
 8220c10:	1886b03a 	or	r3,r3,r2
 8220c14:	e0bff703 	ldbu	r2,-36(fp)
 8220c18:	1000021e 	bne	r2,zero,8220c24 <getPHYSpeed+0x5e4>
 8220c1c:	00800204 	movi	r2,8
 8220c20:	00000106 	br	8220c28 <getPHYSpeed+0x5e8>
 8220c24:	0005883a 	mov	r2,zero
 8220c28:	1886b03a 	or	r3,r3,r2
 8220c2c:	e0bff703 	ldbu	r2,-36(fp)
 8220c30:	108000d8 	cmpnei	r2,r2,3
 8220c34:	1000021e 	bne	r2,zero,8220c40 <getPHYSpeed+0x600>
 8220c38:	00800074 	movhi	r2,1
 8220c3c:	00000106 	br	8220c44 <getPHYSpeed+0x604>
 8220c40:	0005883a 	mov	r2,zero
 8220c44:	1884b03a 	or	r2,r3,r2
 8220c48:	10800234 	orhi	r2,r2,8
 8220c4c:	e0bff815 	stw	r2,-32(fp)
			tse_dprintf(3, "WARNING : PHY[%d.%d] - Auto-Negotiation not completed! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 8220c50:	e13ffd47 	ldb	r4,-11(fp)
 8220c54:	e17ffd07 	ldb	r5,-12(fp)
 8220c58:	e0bff703 	ldbu	r2,-36(fp)
 8220c5c:	108000a0 	cmpeqi	r2,r2,2
 8220c60:	10000e1e 	bne	r2,zero,8220c9c <getPHYSpeed+0x65c>
 8220c64:	e0bff703 	ldbu	r2,-36(fp)
 8220c68:	10800060 	cmpeqi	r2,r2,1
 8220c6c:	1000081e 	bne	r2,zero,8220c90 <getPHYSpeed+0x650>
 8220c70:	e0bff703 	ldbu	r2,-36(fp)
 8220c74:	1000031e 	bne	r2,zero,8220c84 <getPHYSpeed+0x644>
 8220c78:	00820974 	movhi	r2,2085
 8220c7c:	10b8e904 	addi	r2,r2,-7260
 8220c80:	00000806 	br	8220ca4 <getPHYSpeed+0x664>
 8220c84:	00820974 	movhi	r2,2085
 8220c88:	10b8ea04 	addi	r2,r2,-7256
 8220c8c:	00000506 	br	8220ca4 <getPHYSpeed+0x664>
 8220c90:	00820974 	movhi	r2,2085
 8220c94:	10b8ec04 	addi	r2,r2,-7248
 8220c98:	00000206 	br	8220ca4 <getPHYSpeed+0x664>
 8220c9c:	00820974 	movhi	r2,2085
 8220ca0:	10b8ed04 	addi	r2,r2,-7244
 8220ca4:	e0fff743 	ldbu	r3,-35(fp)
 8220ca8:	18c00058 	cmpnei	r3,r3,1
 8220cac:	1800031e 	bne	r3,zero,8220cbc <getPHYSpeed+0x67c>
 8220cb0:	00c20974 	movhi	r3,2085
 8220cb4:	18f8ef04 	addi	r3,r3,-7236
 8220cb8:	00000206 	br	8220cc4 <getPHYSpeed+0x684>
 8220cbc:	00c20974 	movhi	r3,2085
 8220cc0:	18f8f104 	addi	r3,r3,-7228
 8220cc4:	d8c00015 	stw	r3,0(sp)
 8220cc8:	100f883a 	mov	r7,r2
 8220ccc:	280d883a 	mov	r6,r5
 8220cd0:	200b883a 	mov	r5,r4
 8220cd4:	01020974 	movhi	r4,2085
 8220cd8:	21395104 	addi	r4,r4,-6844
 8220cdc:	82033a00 	call	82033a0 <printf>
																			 speed == TSE_PHY_SPEED_100 ? "100" :
																			 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
																			 duplex == 1 ? "Full" : "Half");
			return result;
 8220ce0:	e0bff817 	ldw	r2,-32(fp)
 8220ce4:	0000f306 	br	82210b4 <getPHYSpeed+0xa74>
		}

        IOWR(&pmac_group_base->MDIO_ADDR1, 0, pphy->mdio_address);
 8220ce8:	e0bffe17 	ldw	r2,-8(fp)
 8220cec:	10801004 	addi	r2,r2,64
 8220cf0:	e0fff917 	ldw	r3,-28(fp)
 8220cf4:	18c00003 	ldbu	r3,0(r3)
 8220cf8:	18c03fcc 	andi	r3,r3,255
 8220cfc:	10c00035 	stwio	r3,0(r2)
        /* To enable PHY loopback */
        #if ENABLE_PHY_LOOPBACK
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Putting PHY in loopback\n", mac_group_index, mac_info_index);
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 1);   // enable PHY loopback
		#else
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 8220d00:	d8000015 	stw	zero,0(sp)
 8220d04:	01c00044 	movi	r7,1
 8220d08:	01800384 	movi	r6,14
 8220d0c:	000b883a 	mov	r5,zero
 8220d10:	e13ff917 	ldw	r4,-28(fp)
 8220d14:	82211680 	call	8221168 <alt_tse_phy_wr_mdio_reg>
        #endif
       
        /* if PHY not found in profile */
        if(pphy->pphy_profile == 0) {
 8220d18:	e0bff917 	ldw	r2,-28(fp)
 8220d1c:	10800517 	ldw	r2,20(r2)
 8220d20:	10002b1e 	bne	r2,zero,8220dd0 <getPHYSpeed+0x790>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not found in PHY profile\n", mac_group_index, mac_info_index);
 8220d24:	e0bffd47 	ldb	r2,-11(fp)
 8220d28:	e0fffd07 	ldb	r3,-12(fp)
 8220d2c:	180d883a 	mov	r6,r3
 8220d30:	100b883a 	mov	r5,r2
 8220d34:	01020974 	movhi	r4,2085
 8220d38:	21396504 	addi	r4,r4,-6764
 8220d3c:	82033a00 	call	82033a0 <printf>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220d40:	00800044 	movi	r2,1
 8220d44:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 8220d48:	00800044 	movi	r2,1
 8220d4c:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY_PROFILE;
 8220d50:	e0bff743 	ldbu	r2,-35(fp)
 8220d54:	10c0004c 	andi	r3,r2,1
 8220d58:	e0bff703 	ldbu	r2,-36(fp)
 8220d5c:	10800098 	cmpnei	r2,r2,2
 8220d60:	1000021e 	bne	r2,zero,8220d6c <getPHYSpeed+0x72c>
 8220d64:	00800084 	movi	r2,2
 8220d68:	00000106 	br	8220d70 <getPHYSpeed+0x730>
 8220d6c:	0005883a 	mov	r2,zero
 8220d70:	1886b03a 	or	r3,r3,r2
 8220d74:	e0bff703 	ldbu	r2,-36(fp)
 8220d78:	10800058 	cmpnei	r2,r2,1
 8220d7c:	1000021e 	bne	r2,zero,8220d88 <getPHYSpeed+0x748>
 8220d80:	00800104 	movi	r2,4
 8220d84:	00000106 	br	8220d8c <getPHYSpeed+0x74c>
 8220d88:	0005883a 	mov	r2,zero
 8220d8c:	1886b03a 	or	r3,r3,r2
 8220d90:	e0bff703 	ldbu	r2,-36(fp)
 8220d94:	1000021e 	bne	r2,zero,8220da0 <getPHYSpeed+0x760>
 8220d98:	00800204 	movi	r2,8
 8220d9c:	00000106 	br	8220da4 <getPHYSpeed+0x764>
 8220da0:	0005883a 	mov	r2,zero
 8220da4:	1886b03a 	or	r3,r3,r2
 8220da8:	e0bff703 	ldbu	r2,-36(fp)
 8220dac:	108000d8 	cmpnei	r2,r2,3
 8220db0:	1000021e 	bne	r2,zero,8220dbc <getPHYSpeed+0x77c>
 8220db4:	00800074 	movhi	r2,1
 8220db8:	00000106 	br	8220dc0 <getPHYSpeed+0x780>
 8220dbc:	0005883a 	mov	r2,zero
 8220dc0:	1884b03a 	or	r2,r3,r2
 8220dc4:	10800134 	orhi	r2,r2,4
 8220dc8:	e0bff815 	stw	r2,-32(fp)
 8220dcc:	00009406 	br	8221020 <getPHYSpeed+0x9e0>
        }
        // retrieve duplex information from PHY
		else
		{
			if(pphy->pphy_profile->link_status_read)
 8220dd0:	e0bff917 	ldw	r2,-28(fp)
 8220dd4:	10800517 	ldw	r2,20(r2)
 8220dd8:	10801817 	ldw	r2,96(r2)
 8220ddc:	10002626 	beq	r2,zero,8220e78 <getPHYSpeed+0x838>
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
 8220de0:	e0bff917 	ldw	r2,-28(fp)
 8220de4:	10800517 	ldw	r2,20(r2)
 8220de8:	10801817 	ldw	r2,96(r2)
 8220dec:	e13ffe17 	ldw	r4,-8(fp)
 8220df0:	103ee83a 	callr	r2
 8220df4:	e0bff815 	stw	r2,-32(fp)
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 8220df8:	e0bff817 	ldw	r2,-32(fp)
 8220dfc:	1080008c 	andi	r2,r2,2
 8220e00:	10000c1e 	bne	r2,zero,8220e34 <getPHYSpeed+0x7f4>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
 8220e04:	e0bff817 	ldw	r2,-32(fp)
 8220e08:	1080010c 	andi	r2,r2,4
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 8220e0c:	1000071e 	bne	r2,zero,8220e2c <getPHYSpeed+0x7ec>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
 8220e10:	e0bff817 	ldw	r2,-32(fp)
 8220e14:	1080020c 	andi	r2,r2,8
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 8220e18:	10000226 	beq	r2,zero,8220e24 <getPHYSpeed+0x7e4>
 8220e1c:	0005883a 	mov	r2,zero
 8220e20:	00000506 	br	8220e38 <getPHYSpeed+0x7f8>
 8220e24:	008000c4 	movi	r2,3
 8220e28:	00000306 	br	8220e38 <getPHYSpeed+0x7f8>
 8220e2c:	00800044 	movi	r2,1
 8220e30:	00000106 	br	8220e38 <getPHYSpeed+0x7f8>
 8220e34:	00800084 	movi	r2,2
 8220e38:	e0bff705 	stb	r2,-36(fp)
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
				duplex = (result & 0x01) ? TSE_PHY_DUPLEX_FULL : TSE_PHY_DUPLEX_HALF;
 8220e3c:	e0bff817 	ldw	r2,-32(fp)
 8220e40:	1080004c 	andi	r2,r2,1
 8220e44:	1004c03a 	cmpne	r2,r2,zero
 8220e48:	e0bff745 	stb	r2,-35(fp)
				
				if(result & ALT_TSE_E_INVALID_SPEED)
 8220e4c:	e0bff817 	ldw	r2,-32(fp)
 8220e50:	1080006c 	andhi	r2,r2,1
 8220e54:	10007226 	beq	r2,zero,8221020 <getPHYSpeed+0x9e0>
				{
					tse_dprintf(3, "WARNING : PHY[%d.%d] - Invalid speed read from PHY\n", mac_group_index, mac_info_index);
 8220e58:	e0bffd47 	ldb	r2,-11(fp)
 8220e5c:	e0fffd07 	ldb	r3,-12(fp)
 8220e60:	180d883a 	mov	r6,r3
 8220e64:	100b883a 	mov	r5,r2
 8220e68:	01020974 	movhi	r4,2085
 8220e6c:	21397304 	addi	r4,r4,-6708
 8220e70:	82033a00 	call	82033a0 <printf>
 8220e74:	00006a06 	br	8221020 <getPHYSpeed+0x9e0>
				}
			}
			else if(pphy->pphy_profile->status_reg_location == 0)
 8220e78:	e0bff917 	ldw	r2,-28(fp)
 8220e7c:	10800517 	ldw	r2,20(r2)
 8220e80:	10801583 	ldbu	r2,86(r2)
 8220e84:	10803fcc 	andi	r2,r2,255
 8220e88:	10002b1e 	bne	r2,zero,8220f38 <getPHYSpeed+0x8f8>
	        {
	            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY Specific Status register information not provided in profile\n", mac_group_index, mac_info_index);
 8220e8c:	e0bffd47 	ldb	r2,-11(fp)
 8220e90:	e0fffd07 	ldb	r3,-12(fp)
 8220e94:	180d883a 	mov	r6,r3
 8220e98:	100b883a 	mov	r5,r2
 8220e9c:	01020974 	movhi	r4,2085
 8220ea0:	21398004 	addi	r4,r4,-6656
 8220ea4:	82033a00 	call	82033a0 <printf>
	            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220ea8:	00800044 	movi	r2,1
 8220eac:	e0bff705 	stb	r2,-36(fp)
	            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 8220eb0:	00800044 	movi	r2,1
 8220eb4:	e0bff745 	stb	r2,-35(fp)
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_PROFILE_INCORRECT_DEFINED;
 8220eb8:	e0bff743 	ldbu	r2,-35(fp)
 8220ebc:	10c0004c 	andi	r3,r2,1
 8220ec0:	e0bff703 	ldbu	r2,-36(fp)
 8220ec4:	10800098 	cmpnei	r2,r2,2
 8220ec8:	1000021e 	bne	r2,zero,8220ed4 <getPHYSpeed+0x894>
 8220ecc:	00800084 	movi	r2,2
 8220ed0:	00000106 	br	8220ed8 <getPHYSpeed+0x898>
 8220ed4:	0005883a 	mov	r2,zero
 8220ed8:	1886b03a 	or	r3,r3,r2
 8220edc:	e0bff703 	ldbu	r2,-36(fp)
 8220ee0:	10800058 	cmpnei	r2,r2,1
 8220ee4:	1000021e 	bne	r2,zero,8220ef0 <getPHYSpeed+0x8b0>
 8220ee8:	00800104 	movi	r2,4
 8220eec:	00000106 	br	8220ef4 <getPHYSpeed+0x8b4>
 8220ef0:	0005883a 	mov	r2,zero
 8220ef4:	1886b03a 	or	r3,r3,r2
 8220ef8:	e0bff703 	ldbu	r2,-36(fp)
 8220efc:	1000021e 	bne	r2,zero,8220f08 <getPHYSpeed+0x8c8>
 8220f00:	00800204 	movi	r2,8
 8220f04:	00000106 	br	8220f0c <getPHYSpeed+0x8cc>
 8220f08:	0005883a 	mov	r2,zero
 8220f0c:	1886b03a 	or	r3,r3,r2
 8220f10:	e0bff703 	ldbu	r2,-36(fp)
 8220f14:	108000d8 	cmpnei	r2,r2,3
 8220f18:	1000021e 	bne	r2,zero,8220f24 <getPHYSpeed+0x8e4>
 8220f1c:	00800074 	movhi	r2,1
 8220f20:	00000106 	br	8220f28 <getPHYSpeed+0x8e8>
 8220f24:	0005883a 	mov	r2,zero
 8220f28:	1884b03a 	or	r2,r3,r2
 8220f2c:	108000b4 	orhi	r2,r2,2
 8220f30:	e0bff815 	stw	r2,-32(fp)
 8220f34:	00003a06 	br	8221020 <getPHYSpeed+0x9e0>
	        }
	        else
	        {
	            /* extract connection speed and duplex information */
	        	speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 8220f38:	e0bff917 	ldw	r2,-28(fp)
 8220f3c:	10800517 	ldw	r2,20(r2)
 8220f40:	10801583 	ldbu	r2,86(r2)
 8220f44:	10c03fcc 	andi	r3,r2,255
 8220f48:	e0bff917 	ldw	r2,-28(fp)
 8220f4c:	10800517 	ldw	r2,20(r2)
 8220f50:	108015c3 	ldbu	r2,87(r2)
 8220f54:	10803fcc 	andi	r2,r2,255
 8220f58:	01c00084 	movi	r7,2
 8220f5c:	100d883a 	mov	r6,r2
 8220f60:	180b883a 	mov	r5,r3
 8220f64:	e13ff917 	ldw	r4,-28(fp)
 8220f68:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8220f6c:	e0bff705 	stb	r2,-36(fp)
	            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 8220f70:	e0bff917 	ldw	r2,-28(fp)
 8220f74:	10800517 	ldw	r2,20(r2)
 8220f78:	10801583 	ldbu	r2,86(r2)
 8220f7c:	10c03fcc 	andi	r3,r2,255
 8220f80:	e0bff917 	ldw	r2,-28(fp)
 8220f84:	10800517 	ldw	r2,20(r2)
 8220f88:	10801603 	ldbu	r2,88(r2)
 8220f8c:	10803fcc 	andi	r2,r2,255
 8220f90:	01c00044 	movi	r7,1
 8220f94:	100d883a 	mov	r6,r2
 8220f98:	180b883a 	mov	r5,r3
 8220f9c:	e13ff917 	ldw	r4,-28(fp)
 8220fa0:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8220fa4:	e0bff745 	stb	r2,-35(fp)
				
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 8220fa8:	e0bff743 	ldbu	r2,-35(fp)
 8220fac:	10c0004c 	andi	r3,r2,1
 8220fb0:	e0bff703 	ldbu	r2,-36(fp)
 8220fb4:	10800098 	cmpnei	r2,r2,2
 8220fb8:	1000021e 	bne	r2,zero,8220fc4 <getPHYSpeed+0x984>
 8220fbc:	00800084 	movi	r2,2
 8220fc0:	00000106 	br	8220fc8 <getPHYSpeed+0x988>
 8220fc4:	0005883a 	mov	r2,zero
 8220fc8:	1886b03a 	or	r3,r3,r2
 8220fcc:	e0bff703 	ldbu	r2,-36(fp)
 8220fd0:	10800058 	cmpnei	r2,r2,1
 8220fd4:	1000021e 	bne	r2,zero,8220fe0 <getPHYSpeed+0x9a0>
 8220fd8:	00800104 	movi	r2,4
 8220fdc:	00000106 	br	8220fe4 <getPHYSpeed+0x9a4>
 8220fe0:	0005883a 	mov	r2,zero
 8220fe4:	1886b03a 	or	r3,r3,r2
 8220fe8:	e0bff703 	ldbu	r2,-36(fp)
 8220fec:	1000021e 	bne	r2,zero,8220ff8 <getPHYSpeed+0x9b8>
 8220ff0:	00800204 	movi	r2,8
 8220ff4:	00000106 	br	8220ffc <getPHYSpeed+0x9bc>
 8220ff8:	0005883a 	mov	r2,zero
 8220ffc:	1886b03a 	or	r3,r3,r2
 8221000:	e0bff703 	ldbu	r2,-36(fp)
 8221004:	108000d8 	cmpnei	r2,r2,3
 8221008:	1000021e 	bne	r2,zero,8221014 <getPHYSpeed+0x9d4>
 822100c:	00800074 	movhi	r2,1
 8221010:	00000106 	br	8221018 <getPHYSpeed+0x9d8>
 8221014:	0005883a 	mov	r2,zero
 8221018:	1884b03a 	or	r2,r3,r2
 822101c:	e0bff815 	stw	r2,-32(fp)
        /* for simulation purpose, default to gigabit mode */
        speed = 1;
        duplex = 1;
    #endif

    tse_dprintf(5, "INFO    : PHY[%d.%d] - Speed = %s, Duplex = %s\n",  mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 8221020:	e13ffd47 	ldb	r4,-11(fp)
 8221024:	e17ffd07 	ldb	r5,-12(fp)
 8221028:	e0bff703 	ldbu	r2,-36(fp)
 822102c:	108000a0 	cmpeqi	r2,r2,2
 8221030:	10000e1e 	bne	r2,zero,822106c <getPHYSpeed+0xa2c>
 8221034:	e0bff703 	ldbu	r2,-36(fp)
 8221038:	10800060 	cmpeqi	r2,r2,1
 822103c:	1000081e 	bne	r2,zero,8221060 <getPHYSpeed+0xa20>
 8221040:	e0bff703 	ldbu	r2,-36(fp)
 8221044:	1000031e 	bne	r2,zero,8221054 <getPHYSpeed+0xa14>
 8221048:	00820974 	movhi	r2,2085
 822104c:	10b8e904 	addi	r2,r2,-7260
 8221050:	00000806 	br	8221074 <getPHYSpeed+0xa34>
 8221054:	00820974 	movhi	r2,2085
 8221058:	10b8ea04 	addi	r2,r2,-7256
 822105c:	00000506 	br	8221074 <getPHYSpeed+0xa34>
 8221060:	00820974 	movhi	r2,2085
 8221064:	10b8ec04 	addi	r2,r2,-7248
 8221068:	00000206 	br	8221074 <getPHYSpeed+0xa34>
 822106c:	00820974 	movhi	r2,2085
 8221070:	10b8ed04 	addi	r2,r2,-7244
 8221074:	e0fff743 	ldbu	r3,-35(fp)
 8221078:	18c00058 	cmpnei	r3,r3,1
 822107c:	1800031e 	bne	r3,zero,822108c <getPHYSpeed+0xa4c>
 8221080:	00c20974 	movhi	r3,2085
 8221084:	18f8ef04 	addi	r3,r3,-7236
 8221088:	00000206 	br	8221094 <getPHYSpeed+0xa54>
 822108c:	00c20974 	movhi	r3,2085
 8221090:	18f8f104 	addi	r3,r3,-7228
 8221094:	d8c00015 	stw	r3,0(sp)
 8221098:	100f883a 	mov	r7,r2
 822109c:	280d883a 	mov	r6,r5
 82210a0:	200b883a 	mov	r5,r4
 82210a4:	01020974 	movhi	r4,2085
 82210a8:	21399704 	addi	r4,r4,-6564
 82210ac:	82033a00 	call	82033a0 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");

    return result;
 82210b0:	e0bff817 	ldw	r2,-32(fp)
}
 82210b4:	e037883a 	mov	sp,fp
 82210b8:	dfc00117 	ldw	ra,4(sp)
 82210bc:	df000017 	ldw	fp,0(sp)
 82210c0:	dec00204 	addi	sp,sp,8
 82210c4:	f800283a 	ret

082210c8 <alt_tse_phy_rd_mdio_addr>:
/* @Function Description: Read MDIO address from the MDIO address1 register of first MAC within MAC group
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
 82210c8:	defffd04 	addi	sp,sp,-12
 82210cc:	df000215 	stw	fp,8(sp)
 82210d0:	df000204 	addi	fp,sp,8
 82210d4:	e13fff15 	stw	r4,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 82210d8:	e0bfff17 	ldw	r2,-4(fp)
 82210dc:	10800617 	ldw	r2,24(r2)
 82210e0:	10800317 	ldw	r2,12(r2)
 82210e4:	10800117 	ldw	r2,4(r2)
 82210e8:	10800217 	ldw	r2,8(r2)
 82210ec:	10800017 	ldw	r2,0(r2)
 82210f0:	e0bffe15 	stw	r2,-8(fp)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
 82210f4:	e0bffe17 	ldw	r2,-8(fp)
 82210f8:	10801004 	addi	r2,r2,64
 82210fc:	10800037 	ldwio	r2,0(r2)
}
 8221100:	e037883a 	mov	sp,fp
 8221104:	df000017 	ldw	fp,0(sp)
 8221108:	dec00104 	addi	sp,sp,4
 822110c:	f800283a 	ret

08221110 <alt_tse_phy_wr_mdio_addr>:
 * @API Type:           Internal
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
 8221110:	defffc04 	addi	sp,sp,-16
 8221114:	df000315 	stw	fp,12(sp)
 8221118:	df000304 	addi	fp,sp,12
 822111c:	e13ffe15 	stw	r4,-8(fp)
 8221120:	2805883a 	mov	r2,r5
 8221124:	e0bfff05 	stb	r2,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8221128:	e0bffe17 	ldw	r2,-8(fp)
 822112c:	10800617 	ldw	r2,24(r2)
 8221130:	10800317 	ldw	r2,12(r2)
 8221134:	10800117 	ldw	r2,4(r2)
 8221138:	10800217 	ldw	r2,8(r2)
 822113c:	10800017 	ldw	r2,0(r2)
 8221140:	e0bffd15 	stw	r2,-12(fp)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
 8221144:	e0bffd17 	ldw	r2,-12(fp)
 8221148:	10801004 	addi	r2,r2,64
 822114c:	e0ffff03 	ldbu	r3,-4(fp)
 8221150:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 8221154:	0005883a 	mov	r2,zero
}
 8221158:	e037883a 	mov	sp,fp
 822115c:	df000017 	ldw	fp,0(sp)
 8221160:	dec00104 	addi	sp,sp,4
 8221164:	f800283a 	ret

08221168 <alt_tse_phy_wr_mdio_reg>:
  * @param  bit_length       number of bits to be written to the register.
  * @param  data             data to be written to the register at specific bit location of register.
  * @return SUCCESS 
  */
alt_32 alt_tse_phy_wr_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length, alt_u16 data)
{
 8221168:	defff604 	addi	sp,sp,-40
 822116c:	df000915 	stw	fp,36(sp)
 8221170:	df000904 	addi	fp,sp,36
 8221174:	e13ffb15 	stw	r4,-20(fp)
 8221178:	3009883a 	mov	r4,r6
 822117c:	3807883a 	mov	r3,r7
 8221180:	e0800117 	ldw	r2,4(fp)
 8221184:	e17ffc05 	stb	r5,-16(fp)
 8221188:	e13ffd05 	stb	r4,-12(fp)
 822118c:	e0fffe05 	stb	r3,-8(fp)
 8221190:	e0bfff0d 	sth	r2,-4(fp)
    
    alt_u16 temp_data;
    alt_u16 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8221194:	e0bffb17 	ldw	r2,-20(fp)
 8221198:	10800617 	ldw	r2,24(r2)
 822119c:	10800317 	ldw	r2,12(r2)
 82211a0:	10800117 	ldw	r2,4(r2)
 82211a4:	10800217 	ldw	r2,8(r2)
 82211a8:	10800017 	ldw	r2,0(r2)
 82211ac:	e0bff915 	stw	r2,-28(fp)
    
    bit_mask = 0x00;
 82211b0:	e03ff70d 	sth	zero,-36(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 82211b4:	e03ff815 	stw	zero,-32(fp)
 82211b8:	00000906 	br	82211e0 <alt_tse_phy_wr_mdio_reg+0x78>
    {
        bit_mask <<= 1;
 82211bc:	e0bff70b 	ldhu	r2,-36(fp)
 82211c0:	1085883a 	add	r2,r2,r2
 82211c4:	e0bff70d 	sth	r2,-36(fp)
        bit_mask |= 0x01;        
 82211c8:	e0bff70b 	ldhu	r2,-36(fp)
 82211cc:	10800054 	ori	r2,r2,1
 82211d0:	e0bff70d 	sth	r2,-36(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 82211d4:	e0bff817 	ldw	r2,-32(fp)
 82211d8:	10800044 	addi	r2,r2,1
 82211dc:	e0bff815 	stw	r2,-32(fp)
 82211e0:	e0bffe03 	ldbu	r2,-8(fp)
 82211e4:	e0fff817 	ldw	r3,-32(fp)
 82211e8:	18bff416 	blt	r3,r2,82211bc <alt_tse_phy_wr_mdio_reg+0x54>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* shifting mask to left by bit_num */
    bit_mask <<= lsb_num;
 82211ec:	e0fff70b 	ldhu	r3,-36(fp)
 82211f0:	e0bffd03 	ldbu	r2,-12(fp)
 82211f4:	1884983a 	sll	r2,r3,r2
 82211f8:	e0bff70d 	sth	r2,-36(fp)

    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 82211fc:	e0bff917 	ldw	r2,-28(fp)
 8221200:	10c0a004 	addi	r3,r2,640
 8221204:	e0bffc03 	ldbu	r2,-16(fp)
 8221208:	1085883a 	add	r2,r2,r2
 822120c:	1085883a 	add	r2,r2,r2
 8221210:	1885883a 	add	r2,r3,r2
 8221214:	10800037 	ldwio	r2,0(r2)
 8221218:	e0bffa0d 	sth	r2,-24(fp)
    
    /* clear bits to be written */
    temp_data &= ~bit_mask;
 822121c:	e0bff70b 	ldhu	r2,-36(fp)
 8221220:	0084303a 	nor	r2,zero,r2
 8221224:	1007883a 	mov	r3,r2
 8221228:	e0bffa0b 	ldhu	r2,-24(fp)
 822122c:	1884703a 	and	r2,r3,r2
 8221230:	e0bffa0d 	sth	r2,-24(fp)
    
    /* OR-ed together corresponding bits data */
    temp_data |= ((data << lsb_num) & bit_mask);    
 8221234:	e0ffff0b 	ldhu	r3,-4(fp)
 8221238:	e0bffd03 	ldbu	r2,-12(fp)
 822123c:	1884983a 	sll	r2,r3,r2
 8221240:	1007883a 	mov	r3,r2
 8221244:	e0bff70b 	ldhu	r2,-36(fp)
 8221248:	1884703a 	and	r2,r3,r2
 822124c:	1007883a 	mov	r3,r2
 8221250:	e0bffa0b 	ldhu	r2,-24(fp)
 8221254:	1884b03a 	or	r2,r3,r2
 8221258:	e0bffa0d 	sth	r2,-24(fp)
    
    /* write data to MDIO register */
    IOWR(&pmac->mdio1, reg_num, temp_data);
 822125c:	e0bff917 	ldw	r2,-28(fp)
 8221260:	10c0a004 	addi	r3,r2,640
 8221264:	e0bffc03 	ldbu	r2,-16(fp)
 8221268:	1085883a 	add	r2,r2,r2
 822126c:	1085883a 	add	r2,r2,r2
 8221270:	1885883a 	add	r2,r3,r2
 8221274:	e0fffa0b 	ldhu	r3,-24(fp)
 8221278:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 822127c:	0005883a 	mov	r2,zero
    
}
 8221280:	e037883a 	mov	sp,fp
 8221284:	df000017 	ldw	fp,0(sp)
 8221288:	dec00104 	addi	sp,sp,4
 822128c:	f800283a 	ret

08221290 <alt_tse_phy_rd_mdio_reg>:
 * @param  bit_length       number of bits to be read from the register.
 * @return data read from MDIO register 
 */

alt_u32 alt_tse_phy_rd_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length)
{
 8221290:	defff704 	addi	sp,sp,-36
 8221294:	df000815 	stw	fp,32(sp)
 8221298:	df000804 	addi	fp,sp,32
 822129c:	e13ffc15 	stw	r4,-16(fp)
 82212a0:	2809883a 	mov	r4,r5
 82212a4:	3007883a 	mov	r3,r6
 82212a8:	3805883a 	mov	r2,r7
 82212ac:	e13ffd05 	stb	r4,-12(fp)
 82212b0:	e0fffe05 	stb	r3,-8(fp)
 82212b4:	e0bfff05 	stb	r2,-4(fp)
    alt_u16 temp_data;
    alt_u32 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 82212b8:	e0bffc17 	ldw	r2,-16(fp)
 82212bc:	10800617 	ldw	r2,24(r2)
 82212c0:	10800317 	ldw	r2,12(r2)
 82212c4:	10800117 	ldw	r2,4(r2)
 82212c8:	10800217 	ldw	r2,8(r2)
 82212cc:	10800017 	ldw	r2,0(r2)
 82212d0:	e0bffa15 	stw	r2,-24(fp)
    
    bit_mask = 0x00;
 82212d4:	e03ff815 	stw	zero,-32(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 82212d8:	e03ff915 	stw	zero,-28(fp)
 82212dc:	00000906 	br	8221304 <alt_tse_phy_rd_mdio_reg+0x74>
    {
        bit_mask <<= 1;
 82212e0:	e0bff817 	ldw	r2,-32(fp)
 82212e4:	1085883a 	add	r2,r2,r2
 82212e8:	e0bff815 	stw	r2,-32(fp)
        bit_mask |= 0x01;        
 82212ec:	e0bff817 	ldw	r2,-32(fp)
 82212f0:	10800054 	ori	r2,r2,1
 82212f4:	e0bff815 	stw	r2,-32(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 82212f8:	e0bff917 	ldw	r2,-28(fp)
 82212fc:	10800044 	addi	r2,r2,1
 8221300:	e0bff915 	stw	r2,-28(fp)
 8221304:	e0bfff03 	ldbu	r2,-4(fp)
 8221308:	e0fff917 	ldw	r3,-28(fp)
 822130c:	18bff416 	blt	r3,r2,82212e0 <alt_tse_phy_rd_mdio_reg+0x50>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 8221310:	e0bffa17 	ldw	r2,-24(fp)
 8221314:	10c0a004 	addi	r3,r2,640
 8221318:	e0bffd03 	ldbu	r2,-12(fp)
 822131c:	1085883a 	add	r2,r2,r2
 8221320:	1085883a 	add	r2,r2,r2
 8221324:	1885883a 	add	r2,r3,r2
 8221328:	10800037 	ldwio	r2,0(r2)
 822132c:	e0bffb0d 	sth	r2,-20(fp)
    
    /* shifting read data */
    temp_data >>= lsb_num;
 8221330:	e0fffb0b 	ldhu	r3,-20(fp)
 8221334:	e0bffe03 	ldbu	r2,-8(fp)
 8221338:	1885d83a 	sra	r2,r3,r2
 822133c:	e0bffb0d 	sth	r2,-20(fp)
    
    return (temp_data & bit_mask);
 8221340:	e0fffb0b 	ldhu	r3,-20(fp)
 8221344:	e0bff817 	ldw	r2,-32(fp)
 8221348:	1884703a 	and	r2,r3,r2
}
 822134c:	e037883a 	mov	sp,fp
 8221350:	df000017 	ldw	fp,0(sp)
 8221354:	dec00104 	addi	sp,sp,4
 8221358:	f800283a 	ret

0822135c <alt_tse_phy_add_profile_default>:
 * @param pmac  N/A
 * @return      Number of PHY in profile
 * 
 * User might add their own PHY by calling alt_tse_phy_add_profile()
 */
alt_32 alt_tse_phy_add_profile_default() {
 822135c:	deff9a04 	addi	sp,sp,-408
 8221360:	dfc06515 	stw	ra,404(sp)
 8221364:	df006415 	stw	fp,400(sp)
 8221368:	df006404 	addi	fp,sp,400
        
    /* ------------------------------ */
    /* Marvell PHY on PHYWORKX board  */
    /* ------------------------------ */
    
    alt_tse_phy_profile MV88E1111 = {"Marvell 88E1111",      /* Marvell 88E1111                                  */
 822136c:	e0ff9c04 	addi	r3,fp,-400
 8221370:	00801904 	movi	r2,100
 8221374:	100d883a 	mov	r6,r2
 8221378:	000b883a 	mov	r5,zero
 822137c:	1809883a 	mov	r4,r3
 8221380:	82031b40 	call	82031b4 <memset>
 8221384:	009d9cb4 	movhi	r2,30322
 8221388:	10985344 	addi	r2,r2,24909
 822138c:	e0bf9c15 	stw	r2,-400(fp)
 8221390:	00881b34 	movhi	r2,8300
 8221394:	109b1944 	addi	r2,r2,27749
 8221398:	e0bf9d15 	stw	r2,-396(fp)
 822139c:	008c5174 	movhi	r2,12613
 82213a0:	108e0e04 	addi	r2,r2,14392
 82213a4:	e0bf9e15 	stw	r2,-392(fp)
 82213a8:	00800c74 	movhi	r2,49
 82213ac:	108c4c44 	addi	r2,r2,12593
 82213b0:	e0bf9f15 	stw	r2,-388(fp)
 82213b4:	e0bfa004 	addi	r2,fp,-384
 82213b8:	00c01004 	movi	r3,64
 82213bc:	180d883a 	mov	r6,r3
 82213c0:	000b883a 	mov	r5,zero
 82213c4:	1009883a 	mov	r4,r2
 82213c8:	82031b40 	call	82031b4 <memset>
 82213cc:	009410c4 	movi	r2,20547
 82213d0:	e0bfb015 	stw	r2,-320(fp)
 82213d4:	00800304 	movi	r2,12
 82213d8:	e0bfb105 	stb	r2,-316(fp)
 82213dc:	00800084 	movi	r2,2
 82213e0:	e0bfb145 	stb	r2,-315(fp)
 82213e4:	00800444 	movi	r2,17
 82213e8:	e0bfb185 	stb	r2,-314(fp)
 82213ec:	00800384 	movi	r2,14
 82213f0:	e0bfb1c5 	stb	r2,-313(fp)
 82213f4:	00800344 	movi	r2,13
 82213f8:	e0bfb205 	stb	r2,-312(fp)
 82213fc:	00800284 	movi	r2,10
 8221400:	e0bfb245 	stb	r2,-311(fp)
 8221404:	008208b4 	movhi	r2,2082
 8221408:	108f6b04 	addi	r2,r2,15788
 822140c:	e0bfb315 	stw	r2,-308(fp)
    
    /* ---------------------------------- */
    /* Marvell Quad PHY on PHYWORKX board */
    /* ---------------------------------- */
    
    alt_tse_phy_profile MV88E1145 = {"Marvell Quad PHY 88E1145",      /* Marvell 88E1145                                  */
 8221410:	e0bfb504 	addi	r2,fp,-300
 8221414:	00c01904 	movi	r3,100
 8221418:	180d883a 	mov	r6,r3
 822141c:	000b883a 	mov	r5,zero
 8221420:	1009883a 	mov	r4,r2
 8221424:	82031b40 	call	82031b4 <memset>
 8221428:	009d9cb4 	movhi	r2,30322
 822142c:	10985344 	addi	r2,r2,24909
 8221430:	e0bfb515 	stw	r2,-300(fp)
 8221434:	00881b34 	movhi	r2,8300
 8221438:	109b1944 	addi	r2,r2,27749
 822143c:	e0bfb615 	stw	r2,-296(fp)
 8221440:	00991874 	movhi	r2,25697
 8221444:	109d5444 	addi	r2,r2,30033
 8221448:	e0bfb715 	stw	r2,-292(fp)
 822144c:	00965234 	movhi	r2,22856
 8221450:	10940804 	addi	r2,r2,20512
 8221454:	e0bfb815 	stw	r2,-288(fp)
 8221458:	00914e34 	movhi	r2,17720
 822145c:	108e0804 	addi	r2,r2,14368
 8221460:	e0bfb915 	stw	r2,-284(fp)
 8221464:	008d4d34 	movhi	r2,13620
 8221468:	108c4c44 	addi	r2,r2,12593
 822146c:	e0bfba15 	stw	r2,-280(fp)
 8221470:	e03fbb15 	stw	zero,-276(fp)
 8221474:	e03fbc15 	stw	zero,-272(fp)
 8221478:	e03fbd15 	stw	zero,-268(fp)
 822147c:	e03fbe15 	stw	zero,-264(fp)
 8221480:	e03fbf15 	stw	zero,-260(fp)
 8221484:	e03fc015 	stw	zero,-256(fp)
 8221488:	e03fc115 	stw	zero,-252(fp)
 822148c:	e03fc215 	stw	zero,-248(fp)
 8221490:	e03fc315 	stw	zero,-244(fp)
 8221494:	e03fc415 	stw	zero,-240(fp)
 8221498:	e03fc515 	stw	zero,-236(fp)
 822149c:	e03fc615 	stw	zero,-232(fp)
 82214a0:	e03fc715 	stw	zero,-228(fp)
 82214a4:	e03fc815 	stw	zero,-224(fp)
 82214a8:	009410c4 	movi	r2,20547
 82214ac:	e0bfc915 	stw	r2,-220(fp)
 82214b0:	00800344 	movi	r2,13
 82214b4:	e0bfca05 	stb	r2,-216(fp)
 82214b8:	00800084 	movi	r2,2
 82214bc:	e0bfca45 	stb	r2,-215(fp)
 82214c0:	00800444 	movi	r2,17
 82214c4:	e0bfca85 	stb	r2,-214(fp)
 82214c8:	00800384 	movi	r2,14
 82214cc:	e0bfcac5 	stb	r2,-213(fp)
 82214d0:	00800344 	movi	r2,13
 82214d4:	e0bfcb05 	stb	r2,-212(fp)
 82214d8:	00800284 	movi	r2,10
 82214dc:	e0bfcb45 	stb	r2,-211(fp)
 82214e0:	008208b4 	movhi	r2,2082
 82214e4:	108f6b04 	addi	r2,r2,15788
 82214e8:	e0bfcc15 	stw	r2,-208(fp)
                      
    /* ------------------------------ */
    /* National PHY on PHYWORKX board */
    /* ------------------------------ */  
    
    alt_tse_phy_profile DP83865 = {"National DP83865",     /* National DP83865                                 */
 82214ec:	e0bfce04 	addi	r2,fp,-200
 82214f0:	00c01904 	movi	r3,100
 82214f4:	180d883a 	mov	r6,r3
 82214f8:	000b883a 	mov	r5,zero
 82214fc:	1009883a 	mov	r4,r2
 8221500:	82031b40 	call	82031b4 <memset>
 8221504:	009a5d34 	movhi	r2,26996
 8221508:	10985384 	addi	r2,r2,24910
 822150c:	e0bfce15 	stw	r2,-200(fp)
 8221510:	009b1874 	movhi	r2,27745
 8221514:	109b9bc4 	addi	r2,r2,28271
 8221518:	e0bfcf15 	stw	r2,-196(fp)
 822151c:	008e1434 	movhi	r2,14416
 8221520:	10910804 	addi	r2,r2,17440
 8221524:	e0bfd015 	stw	r2,-192(fp)
 8221528:	008d4db4 	movhi	r2,13622
 822152c:	108e0cc4 	addi	r2,r2,14387
 8221530:	e0bfd115 	stw	r2,-188(fp)
 8221534:	e03fd215 	stw	zero,-184(fp)
 8221538:	e0bfd304 	addi	r2,fp,-180
 822153c:	00c00f04 	movi	r3,60
 8221540:	180d883a 	mov	r6,r3
 8221544:	000b883a 	mov	r5,zero
 8221548:	1009883a 	mov	r4,r2
 822154c:	82031b40 	call	82031b4 <memset>
 8221550:	00800234 	movhi	r2,8
 8221554:	108005c4 	addi	r2,r2,23
 8221558:	e0bfe215 	stw	r2,-120(fp)
 822155c:	008001c4 	movi	r2,7
 8221560:	e0bfe305 	stb	r2,-116(fp)
 8221564:	00800284 	movi	r2,10
 8221568:	e0bfe345 	stb	r2,-115(fp)
 822156c:	00800444 	movi	r2,17
 8221570:	e0bfe385 	stb	r2,-114(fp)
 8221574:	008000c4 	movi	r2,3
 8221578:	e0bfe3c5 	stb	r2,-113(fp)
 822157c:	00800044 	movi	r2,1
 8221580:	e0bfe405 	stb	r2,-112(fp)
 8221584:	00800084 	movi	r2,2
 8221588:	e0bfe445 	stb	r2,-111(fp)
                      
    /* -------------------------------------- */
    /* National 10/100 PHY on PHYWORKX board  */
    /* -------------------------------------- */ 
                      
    alt_tse_phy_profile DP83848C = {"National DP83848C",  /* National DP83848C                                          */
 822158c:	00820974 	movhi	r2,2085
 8221590:	10b9a304 	addi	r2,r2,-6516
 8221594:	e0ffe704 	addi	r3,fp,-100
 8221598:	1009883a 	mov	r4,r2
 822159c:	00801904 	movi	r2,100
 82215a0:	100d883a 	mov	r6,r2
 82215a4:	200b883a 	mov	r5,r4
 82215a8:	1809883a 	mov	r4,r3
 82215ac:	8202f100 	call	8202f10 <memcpy>
						   0,                              /* No function pointer configure National DP83848C            */
						   &DP83848C_link_status_read      /* Function pointer to read from PHY specific status register */           
                          };
                      
    /* add supported PHY to profile */                          
    alt_tse_phy_add_profile(&MV88E1111);
 82215b0:	e13f9c04 	addi	r4,fp,-400
 82215b4:	821f4cc0 	call	821f4cc <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&MV88E1145);
 82215b8:	e0bfb504 	addi	r2,fp,-300
 82215bc:	1009883a 	mov	r4,r2
 82215c0:	821f4cc0 	call	821f4cc <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83865);
 82215c4:	e0bfce04 	addi	r2,fp,-200
 82215c8:	1009883a 	mov	r4,r2
 82215cc:	821f4cc0 	call	821f4cc <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83848C);
 82215d0:	e0bfe704 	addi	r2,fp,-100
 82215d4:	1009883a 	mov	r4,r2
 82215d8:	821f4cc0 	call	821f4cc <alt_tse_phy_add_profile>
    
    
    return phy_profile_count;
 82215dc:	d0a07f03 	ldbu	r2,-32260(gp)
 82215e0:	10803fcc 	andi	r2,r2,255
}
 82215e4:	e037883a 	mov	sp,fp
 82215e8:	dfc00117 	ldw	ra,4(sp)
 82215ec:	df000017 	ldw	fp,0(sp)
 82215f0:	dec00204 	addi	sp,sp,8
 82215f4:	f800283a 	ret

082215f8 <alt_tse_phy_print_profile>:
/* @Function Description: Display PHYs available in profile
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      Number of PHY in profile
 */
alt_32 alt_tse_phy_print_profile() {
 82215f8:	defffd04 	addi	sp,sp,-12
 82215fc:	dfc00215 	stw	ra,8(sp)
 8221600:	df000115 	stw	fp,4(sp)
 8221604:	df000104 	addi	fp,sp,4
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
 8221608:	d0a07f03 	ldbu	r2,-32260(gp)
 822160c:	10803fcc 	andi	r2,r2,255
 8221610:	100b883a 	mov	r5,r2
 8221614:	01020974 	movhi	r4,2085
 8221618:	2139bc04 	addi	r4,r4,-6416
 822161c:	821f1840 	call	821f184 <no_printf>
    
    for(i = 0; i < phy_profile_count; i++)
 8221620:	e03fff05 	stb	zero,-4(fp)
 8221624:	00006d06 	br	82217dc <alt_tse_phy_print_profile+0x1e4>
    {
        tse_dprintf(6, "Profile No.%2d   :\n", i);
 8221628:	e0bfff07 	ldb	r2,-4(fp)
 822162c:	100b883a 	mov	r5,r2
 8221630:	01020974 	movhi	r4,2085
 8221634:	2139cb04 	addi	r4,r4,-6356
 8221638:	821f1840 	call	821f184 <no_printf>
        tse_dprintf(6, "PHY Name        : %s\n", pphy_profiles[i]->name);
 822163c:	e0ffff07 	ldb	r3,-4(fp)
 8221640:	008209b4 	movhi	r2,2086
 8221644:	10b6fa04 	addi	r2,r2,-9240
 8221648:	18c7883a 	add	r3,r3,r3
 822164c:	18c7883a 	add	r3,r3,r3
 8221650:	10c5883a 	add	r2,r2,r3
 8221654:	10800017 	ldw	r2,0(r2)
 8221658:	100b883a 	mov	r5,r2
 822165c:	01020974 	movhi	r4,2085
 8221660:	2139d004 	addi	r4,r4,-6336
 8221664:	821f1840 	call	821f184 <no_printf>
   
        tse_dprintf(6, "PHY OUI         : 0x%06x\n", (int)pphy_profiles[i]->oui);
 8221668:	e0ffff07 	ldb	r3,-4(fp)
 822166c:	008209b4 	movhi	r2,2086
 8221670:	10b6fa04 	addi	r2,r2,-9240
 8221674:	18c7883a 	add	r3,r3,r3
 8221678:	18c7883a 	add	r3,r3,r3
 822167c:	10c5883a 	add	r2,r2,r3
 8221680:	10800017 	ldw	r2,0(r2)
 8221684:	10801417 	ldw	r2,80(r2)
 8221688:	100b883a 	mov	r5,r2
 822168c:	01020974 	movhi	r4,2085
 8221690:	2139d604 	addi	r4,r4,-6312
 8221694:	821f1840 	call	821f184 <no_printf>
        tse_dprintf(6, "PHY Model Num.  : 0x%02x\n", pphy_profiles[i]->model_number);
 8221698:	e0ffff07 	ldb	r3,-4(fp)
 822169c:	008209b4 	movhi	r2,2086
 82216a0:	10b6fa04 	addi	r2,r2,-9240
 82216a4:	18c7883a 	add	r3,r3,r3
 82216a8:	18c7883a 	add	r3,r3,r3
 82216ac:	10c5883a 	add	r2,r2,r3
 82216b0:	10800017 	ldw	r2,0(r2)
 82216b4:	10801503 	ldbu	r2,84(r2)
 82216b8:	10803fcc 	andi	r2,r2,255
 82216bc:	100b883a 	mov	r5,r2
 82216c0:	01020974 	movhi	r4,2085
 82216c4:	2139dd04 	addi	r4,r4,-6284
 82216c8:	821f1840 	call	821f184 <no_printf>
        tse_dprintf(6, "PHY Rev. Num.   : 0x%02x\n", pphy_profiles[i]->revision_number);
 82216cc:	e0ffff07 	ldb	r3,-4(fp)
 82216d0:	008209b4 	movhi	r2,2086
 82216d4:	10b6fa04 	addi	r2,r2,-9240
 82216d8:	18c7883a 	add	r3,r3,r3
 82216dc:	18c7883a 	add	r3,r3,r3
 82216e0:	10c5883a 	add	r2,r2,r3
 82216e4:	10800017 	ldw	r2,0(r2)
 82216e8:	10801543 	ldbu	r2,85(r2)
 82216ec:	10803fcc 	andi	r2,r2,255
 82216f0:	100b883a 	mov	r5,r2
 82216f4:	01020974 	movhi	r4,2085
 82216f8:	2139e404 	addi	r4,r4,-6256
 82216fc:	821f1840 	call	821f184 <no_printf>
        
        tse_dprintf(6, "Status Register : 0x%02x\n", pphy_profiles[i]->status_reg_location); 
 8221700:	e0ffff07 	ldb	r3,-4(fp)
 8221704:	008209b4 	movhi	r2,2086
 8221708:	10b6fa04 	addi	r2,r2,-9240
 822170c:	18c7883a 	add	r3,r3,r3
 8221710:	18c7883a 	add	r3,r3,r3
 8221714:	10c5883a 	add	r2,r2,r3
 8221718:	10800017 	ldw	r2,0(r2)
 822171c:	10801583 	ldbu	r2,86(r2)
 8221720:	10803fcc 	andi	r2,r2,255
 8221724:	100b883a 	mov	r5,r2
 8221728:	01020974 	movhi	r4,2085
 822172c:	2139eb04 	addi	r4,r4,-6228
 8221730:	821f1840 	call	821f184 <no_printf>
        
        tse_dprintf(6, "Speed Bit       : %d\n", pphy_profiles[i]->speed_lsb_location);
 8221734:	e0ffff07 	ldb	r3,-4(fp)
 8221738:	008209b4 	movhi	r2,2086
 822173c:	10b6fa04 	addi	r2,r2,-9240
 8221740:	18c7883a 	add	r3,r3,r3
 8221744:	18c7883a 	add	r3,r3,r3
 8221748:	10c5883a 	add	r2,r2,r3
 822174c:	10800017 	ldw	r2,0(r2)
 8221750:	108015c3 	ldbu	r2,87(r2)
 8221754:	10803fcc 	andi	r2,r2,255
 8221758:	100b883a 	mov	r5,r2
 822175c:	01020974 	movhi	r4,2085
 8221760:	2139f204 	addi	r4,r4,-6200
 8221764:	821f1840 	call	821f184 <no_printf>
        
        tse_dprintf(6, "Duplex Bit      : %d\n", pphy_profiles[i]->duplex_bit_location);
 8221768:	e0ffff07 	ldb	r3,-4(fp)
 822176c:	008209b4 	movhi	r2,2086
 8221770:	10b6fa04 	addi	r2,r2,-9240
 8221774:	18c7883a 	add	r3,r3,r3
 8221778:	18c7883a 	add	r3,r3,r3
 822177c:	10c5883a 	add	r2,r2,r3
 8221780:	10800017 	ldw	r2,0(r2)
 8221784:	10801603 	ldbu	r2,88(r2)
 8221788:	10803fcc 	andi	r2,r2,255
 822178c:	100b883a 	mov	r5,r2
 8221790:	01020974 	movhi	r4,2085
 8221794:	2139f804 	addi	r4,r4,-6176
 8221798:	821f1840 	call	821f184 <no_printf>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 822179c:	e0ffff07 	ldb	r3,-4(fp)
 82217a0:	008209b4 	movhi	r2,2086
 82217a4:	10b6fa04 	addi	r2,r2,-9240
 82217a8:	18c7883a 	add	r3,r3,r3
 82217ac:	18c7883a 	add	r3,r3,r3
 82217b0:	10c5883a 	add	r2,r2,r3
 82217b4:	10800017 	ldw	r2,0(r2)
 82217b8:	10801643 	ldbu	r2,89(r2)
 82217bc:	10803fcc 	andi	r2,r2,255
 82217c0:	100b883a 	mov	r5,r2
 82217c4:	01020974 	movhi	r4,2085
 82217c8:	2139fe04 	addi	r4,r4,-6152
 82217cc:	821f1840 	call	821f184 <no_printf>
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
    
    for(i = 0; i < phy_profile_count; i++)
 82217d0:	e0bfff03 	ldbu	r2,-4(fp)
 82217d4:	10800044 	addi	r2,r2,1
 82217d8:	e0bfff05 	stb	r2,-4(fp)
 82217dc:	e0ffff07 	ldb	r3,-4(fp)
 82217e0:	d0a07f03 	ldbu	r2,-32260(gp)
 82217e4:	10803fcc 	andi	r2,r2,255
 82217e8:	18bf8f16 	blt	r3,r2,8221628 <alt_tse_phy_print_profile+0x30>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 
    }
    
    return phy_profile_count;
 82217ec:	d0a07f03 	ldbu	r2,-32260(gp)
 82217f0:	10803fcc 	andi	r2,r2,255
}
 82217f4:	e037883a 	mov	sp,fp
 82217f8:	dfc00117 	ldw	ra,4(sp)
 82217fc:	df000017 	ldw	fp,0(sp)
 8221800:	dec00204 	addi	sp,sp,8
 8221804:	f800283a 	ret

08221808 <alt_tse_mac_group_init>:
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      return SUCCESS
 *              return ALTERA_TSE_SYSTEM_DEF_ERROR if alt_tse_system_info structure definition error
 */
alt_32 alt_tse_mac_group_init() {
 8221808:	defffa04 	addi	sp,sp,-24
 822180c:	dfc00515 	stw	ra,20(sp)
 8221810:	df000415 	stw	fp,16(sp)
 8221814:	df000404 	addi	fp,sp,16
    
	alt_8 i;
	alt_8 j;
    
    alt_tse_mac_group *pmac_group = 0;
 8221818:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
 822181c:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_system_info *psys = 0;
 8221820:	e03fff15 	stw	zero,-4(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
 8221824:	d0207f45 	stb	zero,-32259(gp)
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 8221828:	e03ffc05 	stb	zero,-16(fp)
 822182c:	00019506 	br	8221e84 <alt_tse_mac_group_init+0x67c>
        psys = &tse_mac_device[i];
 8221830:	e0bffc07 	ldb	r2,-16(fp)
 8221834:	10c01224 	muli	r3,r2,72
 8221838:	00820974 	movhi	r2,2085
 822183c:	1087b804 	addi	r2,r2,7904
 8221840:	1885883a 	add	r2,r3,r2
 8221844:	e0bfff15 	stw	r2,-4(fp)

        if((psys->tse_sgdma_tx != 0) && (psys->tse_sgdma_rx != 0)) {    	
 8221848:	e0bfff17 	ldw	r2,-4(fp)
 822184c:	10800517 	ldw	r2,20(r2)
 8221850:	10018926 	beq	r2,zero,8221e78 <alt_tse_mac_group_init+0x670>
 8221854:	e0bfff17 	ldw	r2,-4(fp)
 8221858:	10800617 	ldw	r2,24(r2)
 822185c:	10018626 	beq	r2,zero,8221e78 <alt_tse_mac_group_init+0x670>
            tse_dprintf(5, "INFO    : TSE MAC %d found at address 0x%08x\n", mac_group_count, (int) psys->tse_mac_base);
 8221860:	d0a07f43 	ldbu	r2,-32259(gp)
 8221864:	10c03fcc 	andi	r3,r2,255
 8221868:	e0bfff17 	ldw	r2,-4(fp)
 822186c:	10800017 	ldw	r2,0(r2)
 8221870:	100d883a 	mov	r6,r2
 8221874:	180b883a 	mov	r5,r3
 8221878:	01020974 	movhi	r4,2085
 822187c:	213a0404 	addi	r4,r4,-6128
 8221880:	82033a00 	call	82033a0 <printf>
            
            /* Allocate memory for the structure */
            pmac_group = (alt_tse_mac_group *) malloc(sizeof(alt_tse_mac_group));
 8221884:	01000504 	movi	r4,20
 8221888:	824b6900 	call	824b690 <malloc>
 822188c:	e0bffd15 	stw	r2,-12(fp)
            if(!pmac_group) {
 8221890:	e0bffd17 	ldw	r2,-12(fp)
 8221894:	1000081e 	bne	r2,zero,82218b8 <alt_tse_mac_group_init+0xb0>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]\n", mac_group_count);
 8221898:	d0a07f43 	ldbu	r2,-32259(gp)
 822189c:	10803fcc 	andi	r2,r2,255
 82218a0:	100b883a 	mov	r5,r2
 82218a4:	01020974 	movhi	r4,2085
 82218a8:	213a1004 	addi	r4,r4,-6080
 82218ac:	82033a00 	call	82033a0 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 82218b0:	00bfffc4 	movi	r2,-1
 82218b4:	00017806 	br	8221e98 <alt_tse_mac_group_init+0x690>
            }
           
            /* Non-multi-channel MAC considered as 1 channel */
            if(psys->tse_multichannel_mac) {
 82218b8:	e0bfff17 	ldw	r2,-4(fp)
 82218bc:	108002c3 	ldbu	r2,11(r2)
 82218c0:	10803fcc 	andi	r2,r2,255
 82218c4:	10001226 	beq	r2,zero,8221910 <alt_tse_mac_group_init+0x108>
                pmac_group->channel = psys->tse_num_of_channel;
 82218c8:	e0bfff17 	ldw	r2,-4(fp)
 82218cc:	10c00303 	ldbu	r3,12(r2)
 82218d0:	e0bffd17 	ldw	r2,-12(fp)
 82218d4:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = Yes\n");
 82218d8:	01020974 	movhi	r4,2085
 82218dc:	213a1e04 	addi	r4,r4,-6024
 82218e0:	821f1840 	call	821f184 <no_printf>
                tse_dprintf(6, "INFO    : Number of channel        = %d\n", pmac_group->channel);
 82218e4:	e0bffd17 	ldw	r2,-12(fp)
 82218e8:	10800003 	ldbu	r2,0(r2)
 82218ec:	10803fcc 	andi	r2,r2,255
 82218f0:	100b883a 	mov	r5,r2
 82218f4:	01020974 	movhi	r4,2085
 82218f8:	213a2904 	addi	r4,r4,-5980
 82218fc:	821f1840 	call	821f184 <no_printf>
            	tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 8221900:	01020974 	movhi	r4,2085
 8221904:	213a3404 	addi	r4,r4,-5936
 8221908:	821f1840 	call	821f184 <no_printf>
 822190c:	00001f06 	br	822198c <alt_tse_mac_group_init+0x184>
            }
            else if(psys->tse_mdio_shared) {
 8221910:	e0bfff17 	ldw	r2,-4(fp)
 8221914:	10800343 	ldbu	r2,13(r2)
 8221918:	10803fcc 	andi	r2,r2,255
 822191c:	10001226 	beq	r2,zero,8221968 <alt_tse_mac_group_init+0x160>
                pmac_group->channel = psys->tse_number_of_mac_mdio_shared;
 8221920:	e0bfff17 	ldw	r2,-4(fp)
 8221924:	10c00383 	ldbu	r3,14(r2)
 8221928:	e0bffd17 	ldw	r2,-12(fp)
 822192c:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 8221930:	01020974 	movhi	r4,2085
 8221934:	213a3f04 	addi	r4,r4,-5892
 8221938:	821f1840 	call	821f184 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 822193c:	01020974 	movhi	r4,2085
 8221940:	213a3404 	addi	r4,r4,-5936
 8221944:	821f1840 	call	821f184 <no_printf>
                tse_dprintf(6, "INFO    : Number of MAC Share MDIO = %d\n", pmac_group->channel);
 8221948:	e0bffd17 	ldw	r2,-12(fp)
 822194c:	10800003 	ldbu	r2,0(r2)
 8221950:	10803fcc 	andi	r2,r2,255
 8221954:	100b883a 	mov	r5,r2
 8221958:	01020974 	movhi	r4,2085
 822195c:	213a4a04 	addi	r4,r4,-5848
 8221960:	821f1840 	call	821f184 <no_printf>
 8221964:	00000906 	br	822198c <alt_tse_mac_group_init+0x184>
            }
            else {
                pmac_group->channel = 1;
 8221968:	e0bffd17 	ldw	r2,-12(fp)
 822196c:	00c00044 	movi	r3,1
 8221970:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 8221974:	01020974 	movhi	r4,2085
 8221978:	213a3f04 	addi	r4,r4,-5892
 822197c:	821f1840 	call	821f184 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
 8221980:	01020974 	movhi	r4,2085
 8221984:	213a5504 	addi	r4,r4,-5804
 8221988:	821f1840 	call	821f184 <no_printf>
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 822198c:	e03ffc45 	stb	zero,-15(fp)
 8221990:	00012206 	br	8221e1c <alt_tse_mac_group_init+0x614>
                /* Allocate memory for the structure */
                pmac_info = (alt_tse_mac_info *) malloc(sizeof(alt_tse_mac_info));
 8221994:	01000404 	movi	r4,16
 8221998:	824b6900 	call	824b690 <malloc>
 822199c:	e0bffe15 	stw	r2,-8(fp)
                if(!pmac_info) {
 82219a0:	e0bffe17 	ldw	r2,-8(fp)
 82219a4:	10000a1e 	bne	r2,zero,82219d0 <alt_tse_mac_group_init+0x1c8>
                    tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]->pmac_info[%d]\n", mac_group_count, j);
 82219a8:	d0a07f43 	ldbu	r2,-32259(gp)
 82219ac:	10803fcc 	andi	r2,r2,255
 82219b0:	e0fffc47 	ldb	r3,-15(fp)
 82219b4:	180d883a 	mov	r6,r3
 82219b8:	100b883a 	mov	r5,r2
 82219bc:	01020974 	movhi	r4,2085
 82219c0:	213a6004 	addi	r4,r4,-5760
 82219c4:	82033a00 	call	82033a0 <printf>
                    return ALTERA_TSE_MALLOC_FAILED;
 82219c8:	00bfffc4 	movi	r2,-1
 82219cc:	00013206 	br	8221e98 <alt_tse_mac_group_init+0x690>
                }
                
                pmac_info->pmac_group = pmac_group;
 82219d0:	e0bffe17 	ldw	r2,-8(fp)
 82219d4:	e0fffd17 	ldw	r3,-12(fp)
 82219d8:	10c00315 	stw	r3,12(r2)
                
                pmac_info->pphy_info = 0;
 82219dc:	e0bffe17 	ldw	r2,-8(fp)
 82219e0:	10000115 	stw	zero,4(r2)
                
                pmac_info->psys_info = &tse_mac_device[i + j];
 82219e4:	e0fffc07 	ldb	r3,-16(fp)
 82219e8:	e0bffc47 	ldb	r2,-15(fp)
 82219ec:	1885883a 	add	r2,r3,r2
 82219f0:	10c01224 	muli	r3,r2,72
 82219f4:	00820974 	movhi	r2,2085
 82219f8:	1087b804 	addi	r2,r2,7904
 82219fc:	1887883a 	add	r3,r3,r2
 8221a00:	e0bffe17 	ldw	r2,-8(fp)
 8221a04:	10c00215 	stw	r3,8(r2)
                
                /* check to make sure the alt_tse_system_info defined correctly or has been defined */
                if((pmac_info->psys_info->tse_sgdma_tx == 0) || (pmac_info->psys_info->tse_sgdma_rx == 0)){                	
 8221a08:	e0bffe17 	ldw	r2,-8(fp)
 8221a0c:	10800217 	ldw	r2,8(r2)
 8221a10:	10800517 	ldw	r2,20(r2)
 8221a14:	10000426 	beq	r2,zero,8221a28 <alt_tse_mac_group_init+0x220>
 8221a18:	e0bffe17 	ldw	r2,-8(fp)
 8221a1c:	10800217 	ldw	r2,8(r2)
 8221a20:	10800617 	ldw	r2,24(r2)
 8221a24:	1000091e 	bne	r2,zero,8221a4c <alt_tse_mac_group_init+0x244>
                    tse_dprintf(2, "ERROR   : tse_mac_device[%d] does not defined correctly!\n", i + j);
 8221a28:	e0fffc07 	ldb	r3,-16(fp)
 8221a2c:	e0bffc47 	ldb	r2,-15(fp)
 8221a30:	1885883a 	add	r2,r3,r2
 8221a34:	100b883a 	mov	r5,r2
 8221a38:	01020974 	movhi	r4,2085
 8221a3c:	213a7204 	addi	r4,r4,-5688
 8221a40:	82033a00 	call	82033a0 <printf>
                    return ALTERA_TSE_SYSTEM_DEF_ERROR;
 8221a44:	00bfffc4 	movi	r2,-1
 8221a48:	00011306 	br	8221e98 <alt_tse_mac_group_init+0x690>
                }
                
                /* MAC type detection */
                if(pmac_info->psys_info->tse_en_maclite) {
 8221a4c:	e0bffe17 	ldw	r2,-8(fp)
 8221a50:	10800217 	ldw	r2,8(r2)
 8221a54:	10800243 	ldbu	r2,9(r2)
 8221a58:	10803fcc 	andi	r2,r2,255
 8221a5c:	10000d26 	beq	r2,zero,8221a94 <alt_tse_mac_group_init+0x28c>
                    if(pmac_info->psys_info->tse_maclite_gige) {
 8221a60:	e0bffe17 	ldw	r2,-8(fp)
 8221a64:	10800217 	ldw	r2,8(r2)
 8221a68:	10800283 	ldbu	r2,10(r2)
 8221a6c:	10803fcc 	andi	r2,r2,255
 8221a70:	10000426 	beq	r2,zero,8221a84 <alt_tse_mac_group_init+0x27c>
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_1000;
 8221a74:	e0bffe17 	ldw	r2,-8(fp)
 8221a78:	00c00084 	movi	r3,2
 8221a7c:	10c00005 	stb	r3,0(r2)
 8221a80:	00000606 	br	8221a9c <alt_tse_mac_group_init+0x294>
                    }
                    else {
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_10_100;
 8221a84:	e0bffe17 	ldw	r2,-8(fp)
 8221a88:	00c00044 	movi	r3,1
 8221a8c:	10c00005 	stb	r3,0(r2)
 8221a90:	00000206 	br	8221a9c <alt_tse_mac_group_init+0x294>
                    }
                }
                else {
                    pmac_info->mac_type = ALTERA_TSE_FULL_MAC;                    
 8221a94:	e0bffe17 	ldw	r2,-8(fp)
 8221a98:	10000005 	stb	zero,0(r2)
                }
                
                if((pmac_info->psys_info->tse_mdio_shared) && (!pmac_info->psys_info->tse_multichannel_mac)){
 8221a9c:	e0bffe17 	ldw	r2,-8(fp)
 8221aa0:	10800217 	ldw	r2,8(r2)
 8221aa4:	10800343 	ldbu	r2,13(r2)
 8221aa8:	10803fcc 	andi	r2,r2,255
 8221aac:	10006626 	beq	r2,zero,8221c48 <alt_tse_mac_group_init+0x440>
 8221ab0:	e0bffe17 	ldw	r2,-8(fp)
 8221ab4:	10800217 	ldw	r2,8(r2)
 8221ab8:	108002c3 	ldbu	r2,11(r2)
 8221abc:	10803fcc 	andi	r2,r2,255
 8221ac0:	1000611e 	bne	r2,zero,8221c48 <alt_tse_mac_group_init+0x440>
                	tse_dprintf(6, "INFO    : MAC %2d Address           = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 8221ac4:	e0fffc47 	ldb	r3,-15(fp)
 8221ac8:	e0bffe17 	ldw	r2,-8(fp)
 8221acc:	10800217 	ldw	r2,8(r2)
 8221ad0:	10800017 	ldw	r2,0(r2)
 8221ad4:	100d883a 	mov	r6,r2
 8221ad8:	180b883a 	mov	r5,r3
 8221adc:	01020974 	movhi	r4,2085
 8221ae0:	213a8104 	addi	r4,r4,-5628
 8221ae4:	821f1840 	call	821f184 <no_printf>
                    tse_dprintf(6, "INFO    : MAC %2d Device            = tse_mac_device[%d]\n", j, i + j);
 8221ae8:	e13ffc47 	ldb	r4,-15(fp)
 8221aec:	e0fffc07 	ldb	r3,-16(fp)
 8221af0:	e0bffc47 	ldb	r2,-15(fp)
 8221af4:	1885883a 	add	r2,r3,r2
 8221af8:	100d883a 	mov	r6,r2
 8221afc:	200b883a 	mov	r5,r4
 8221b00:	01020974 	movhi	r4,2085
 8221b04:	213a8d04 	addi	r4,r4,-5580
 8221b08:	821f1840 	call	821f184 <no_printf>
                    
                	switch(pmac_info->mac_type) {
 8221b0c:	e0bffe17 	ldw	r2,-8(fp)
 8221b10:	10800003 	ldbu	r2,0(r2)
 8221b14:	10803fcc 	andi	r2,r2,255
 8221b18:	10c00060 	cmpeqi	r3,r2,1
 8221b1c:	18000c1e 	bne	r3,zero,8221b50 <alt_tse_mac_group_init+0x348>
 8221b20:	10c000a0 	cmpeqi	r3,r2,2
 8221b24:	1800021e 	bne	r3,zero,8221b30 <alt_tse_mac_group_init+0x328>
 8221b28:	10001126 	beq	r2,zero,8221b70 <alt_tse_mac_group_init+0x368>
 8221b2c:	00001806 	br	8221b90 <alt_tse_mac_group_init+0x388>
                        case ALTERA_TSE_MACLITE_1000:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "1000 Mbps Small MAC");
 8221b30:	e0bffc47 	ldb	r2,-15(fp)
 8221b34:	01820974 	movhi	r6,2085
 8221b38:	31ba9c04 	addi	r6,r6,-5520
 8221b3c:	100b883a 	mov	r5,r2
 8221b40:	01020974 	movhi	r4,2085
 8221b44:	213aa104 	addi	r4,r4,-5500
 8221b48:	821f1840 	call	821f184 <no_printf>
                            break;
 8221b4c:	00001806 	br	8221bb0 <alt_tse_mac_group_init+0x3a8>
                        case ALTERA_TSE_MACLITE_10_100:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100 Mbps Small MAC");
 8221b50:	e0bffc47 	ldb	r2,-15(fp)
 8221b54:	01820974 	movhi	r6,2085
 8221b58:	31baac04 	addi	r6,r6,-5456
 8221b5c:	100b883a 	mov	r5,r2
 8221b60:	01020974 	movhi	r4,2085
 8221b64:	213aa104 	addi	r4,r4,-5500
 8221b68:	821f1840 	call	821f184 <no_printf>
                            break;
 8221b6c:	00001006 	br	8221bb0 <alt_tse_mac_group_init+0x3a8>
                        case ALTERA_TSE_FULL_MAC:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100/1000 Ethernet MAC");
 8221b70:	e0bffc47 	ldb	r2,-15(fp)
 8221b74:	01820974 	movhi	r6,2085
 8221b78:	31bab204 	addi	r6,r6,-5432
 8221b7c:	100b883a 	mov	r5,r2
 8221b80:	01020974 	movhi	r4,2085
 8221b84:	213aa104 	addi	r4,r4,-5500
 8221b88:	821f1840 	call	821f184 <no_printf>
                            break;
 8221b8c:	00000806 	br	8221bb0 <alt_tse_mac_group_init+0x3a8>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
 8221b90:	e0bffc47 	ldb	r2,-15(fp)
 8221b94:	01820974 	movhi	r6,2085
 8221b98:	31b8ea04 	addi	r6,r6,-7256
 8221b9c:	100b883a 	mov	r5,r2
 8221ba0:	01020974 	movhi	r4,2085
 8221ba4:	213aa104 	addi	r4,r4,-5500
 8221ba8:	821f1840 	call	821f184 <no_printf>
                            break;
 8221bac:	0001883a 	nop
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
 8221bb0:	e0bffe17 	ldw	r2,-8(fp)
 8221bb4:	10800217 	ldw	r2,8(r2)
 8221bb8:	108003c3 	ldbu	r2,15(r2)
 8221bbc:	10803fcc 	andi	r2,r2,255
 8221bc0:	10008b26 	beq	r2,zero,8221df0 <alt_tse_mac_group_init+0x5e8>
                        tse_dprintf(6, "INFO    : PCS %2d Enable            = %s\n", j, pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 8221bc4:	e0fffc47 	ldb	r3,-15(fp)
 8221bc8:	e0bffe17 	ldw	r2,-8(fp)
 8221bcc:	10800217 	ldw	r2,8(r2)
 8221bd0:	108003c3 	ldbu	r2,15(r2)
 8221bd4:	10803fcc 	andi	r2,r2,255
 8221bd8:	10000326 	beq	r2,zero,8221be8 <alt_tse_mac_group_init+0x3e0>
 8221bdc:	00820974 	movhi	r2,2085
 8221be0:	10bab904 	addi	r2,r2,-5404
 8221be4:	00000206 	br	8221bf0 <alt_tse_mac_group_init+0x3e8>
 8221be8:	00820974 	movhi	r2,2085
 8221bec:	10baba04 	addi	r2,r2,-5400
 8221bf0:	100d883a 	mov	r6,r2
 8221bf4:	180b883a 	mov	r5,r3
 8221bf8:	01020974 	movhi	r4,2085
 8221bfc:	213abb04 	addi	r4,r4,-5396
 8221c00:	821f1840 	call	821f184 <no_printf>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
 8221c04:	e0fffc47 	ldb	r3,-15(fp)
 8221c08:	e0bffe17 	ldw	r2,-8(fp)
 8221c0c:	10800217 	ldw	r2,8(r2)
 8221c10:	10800403 	ldbu	r2,16(r2)
 8221c14:	10803fcc 	andi	r2,r2,255
 8221c18:	10000326 	beq	r2,zero,8221c28 <alt_tse_mac_group_init+0x420>
 8221c1c:	00820974 	movhi	r2,2085
 8221c20:	10bab904 	addi	r2,r2,-5404
 8221c24:	00000206 	br	8221c30 <alt_tse_mac_group_init+0x428>
 8221c28:	00820974 	movhi	r2,2085
 8221c2c:	10baba04 	addi	r2,r2,-5400
 8221c30:	100d883a 	mov	r6,r2
 8221c34:	180b883a 	mov	r5,r3
 8221c38:	01020974 	movhi	r4,2085
 8221c3c:	213ac604 	addi	r4,r4,-5352
 8221c40:	821f1840 	call	821f184 <no_printf>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
                            break;
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
 8221c44:	00006a06 	br	8221df0 <alt_tse_mac_group_init+0x5e8>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
                    }
                }
                else {
                	/* display only once for all MAC, except shared MDIO MACs */
	                if(j == 0) {
 8221c48:	e0bffc47 	ldb	r2,-15(fp)
 8221c4c:	1000421e 	bne	r2,zero,8221d58 <alt_tse_mac_group_init+0x550>
	                    switch(pmac_info->mac_type) {
 8221c50:	e0bffe17 	ldw	r2,-8(fp)
 8221c54:	10800003 	ldbu	r2,0(r2)
 8221c58:	10803fcc 	andi	r2,r2,255
 8221c5c:	10c00060 	cmpeqi	r3,r2,1
 8221c60:	18000a1e 	bne	r3,zero,8221c8c <alt_tse_mac_group_init+0x484>
 8221c64:	10c000a0 	cmpeqi	r3,r2,2
 8221c68:	1800021e 	bne	r3,zero,8221c74 <alt_tse_mac_group_init+0x46c>
 8221c6c:	10000d26 	beq	r2,zero,8221ca4 <alt_tse_mac_group_init+0x49c>
 8221c70:	00001206 	br	8221cbc <alt_tse_mac_group_init+0x4b4>
	                        case ALTERA_TSE_MACLITE_1000:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "1000 Mbps Small MAC");
 8221c74:	01420974 	movhi	r5,2085
 8221c78:	297a9c04 	addi	r5,r5,-5520
 8221c7c:	01020974 	movhi	r4,2085
 8221c80:	213ad104 	addi	r4,r4,-5308
 8221c84:	821f1840 	call	821f184 <no_printf>
	                            break;
 8221c88:	00001206 	br	8221cd4 <alt_tse_mac_group_init+0x4cc>
	                        case ALTERA_TSE_MACLITE_10_100:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100 Mbps Small MAC");
 8221c8c:	01420974 	movhi	r5,2085
 8221c90:	297aac04 	addi	r5,r5,-5456
 8221c94:	01020974 	movhi	r4,2085
 8221c98:	213ad104 	addi	r4,r4,-5308
 8221c9c:	821f1840 	call	821f184 <no_printf>
	                            break;
 8221ca0:	00000c06 	br	8221cd4 <alt_tse_mac_group_init+0x4cc>
	                        case ALTERA_TSE_FULL_MAC:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100/1000 Ethernet MAC");
 8221ca4:	01420974 	movhi	r5,2085
 8221ca8:	297ab204 	addi	r5,r5,-5432
 8221cac:	01020974 	movhi	r4,2085
 8221cb0:	213ad104 	addi	r4,r4,-5308
 8221cb4:	821f1840 	call	821f184 <no_printf>
	                            break;
 8221cb8:	00000606 	br	8221cd4 <alt_tse_mac_group_init+0x4cc>
	                        default :
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "Unknown");
 8221cbc:	01420974 	movhi	r5,2085
 8221cc0:	2978ea04 	addi	r5,r5,-7256
 8221cc4:	01020974 	movhi	r4,2085
 8221cc8:	213ad104 	addi	r4,r4,-5308
 8221ccc:	821f1840 	call	821f184 <no_printf>
                                    break;
 8221cd0:	0001883a 	nop
			    }
	                    
	                    if(pmac_info->psys_info->tse_pcs_ena) {
 8221cd4:	e0bffe17 	ldw	r2,-8(fp)
 8221cd8:	10800217 	ldw	r2,8(r2)
 8221cdc:	108003c3 	ldbu	r2,15(r2)
 8221ce0:	10803fcc 	andi	r2,r2,255
 8221ce4:	10001c26 	beq	r2,zero,8221d58 <alt_tse_mac_group_init+0x550>
	                        tse_dprintf(6, "INFO    : PCS Enable               = %s\n", pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 8221ce8:	e0bffe17 	ldw	r2,-8(fp)
 8221cec:	10800217 	ldw	r2,8(r2)
 8221cf0:	108003c3 	ldbu	r2,15(r2)
 8221cf4:	10803fcc 	andi	r2,r2,255
 8221cf8:	10000326 	beq	r2,zero,8221d08 <alt_tse_mac_group_init+0x500>
 8221cfc:	00820974 	movhi	r2,2085
 8221d00:	10bab904 	addi	r2,r2,-5404
 8221d04:	00000206 	br	8221d10 <alt_tse_mac_group_init+0x508>
 8221d08:	00820974 	movhi	r2,2085
 8221d0c:	10baba04 	addi	r2,r2,-5400
 8221d10:	100b883a 	mov	r5,r2
 8221d14:	01020974 	movhi	r4,2085
 8221d18:	213adc04 	addi	r4,r4,-5264
 8221d1c:	821f1840 	call	821f184 <no_printf>
	                        tse_dprintf(6, "INFO    : PCS SGMII Enable         = %s\n", pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");	                        
 8221d20:	e0bffe17 	ldw	r2,-8(fp)
 8221d24:	10800217 	ldw	r2,8(r2)
 8221d28:	10800403 	ldbu	r2,16(r2)
 8221d2c:	10803fcc 	andi	r2,r2,255
 8221d30:	10000326 	beq	r2,zero,8221d40 <alt_tse_mac_group_init+0x538>
 8221d34:	00820974 	movhi	r2,2085
 8221d38:	10bab904 	addi	r2,r2,-5404
 8221d3c:	00000206 	br	8221d48 <alt_tse_mac_group_init+0x540>
 8221d40:	00820974 	movhi	r2,2085
 8221d44:	10baba04 	addi	r2,r2,-5400
 8221d48:	100b883a 	mov	r5,r2
 8221d4c:	01020974 	movhi	r4,2085
 8221d50:	213ae704 	addi	r4,r4,-5220
 8221d54:	821f1840 	call	821f184 <no_printf>
	                    }
	                }
	                
                	if(pmac_info->psys_info->tse_multichannel_mac) {
 8221d58:	e0bffe17 	ldw	r2,-8(fp)
 8221d5c:	10800217 	ldw	r2,8(r2)
 8221d60:	108002c3 	ldbu	r2,11(r2)
 8221d64:	10803fcc 	andi	r2,r2,255
 8221d68:	10001326 	beq	r2,zero,8221db8 <alt_tse_mac_group_init+0x5b0>
                		tse_dprintf(6, "INFO    : Channel %2d Address       = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 8221d6c:	e0fffc47 	ldb	r3,-15(fp)
 8221d70:	e0bffe17 	ldw	r2,-8(fp)
 8221d74:	10800217 	ldw	r2,8(r2)
 8221d78:	10800017 	ldw	r2,0(r2)
 8221d7c:	100d883a 	mov	r6,r2
 8221d80:	180b883a 	mov	r5,r3
 8221d84:	01020974 	movhi	r4,2085
 8221d88:	213af204 	addi	r4,r4,-5176
 8221d8c:	821f1840 	call	821f184 <no_printf>
	                    tse_dprintf(6, "INFO    : Channel %2d Device        = tse_mac_device[%d]\n", j, i + j);
 8221d90:	e13ffc47 	ldb	r4,-15(fp)
 8221d94:	e0fffc07 	ldb	r3,-16(fp)
 8221d98:	e0bffc47 	ldb	r2,-15(fp)
 8221d9c:	1885883a 	add	r2,r3,r2
 8221da0:	100d883a 	mov	r6,r2
 8221da4:	200b883a 	mov	r5,r4
 8221da8:	01020974 	movhi	r4,2085
 8221dac:	213afe04 	addi	r4,r4,-5128
 8221db0:	821f1840 	call	821f184 <no_printf>
 8221db4:	00000e06 	br	8221df0 <alt_tse_mac_group_init+0x5e8>
	            	}                
	                else {
	                    tse_dprintf(6, "INFO    : MAC Address              = 0x%08x\n", (int) pmac_info->psys_info->tse_mac_base);
 8221db8:	e0bffe17 	ldw	r2,-8(fp)
 8221dbc:	10800217 	ldw	r2,8(r2)
 8221dc0:	10800017 	ldw	r2,0(r2)
 8221dc4:	100b883a 	mov	r5,r2
 8221dc8:	01020974 	movhi	r4,2085
 8221dcc:	213b0d04 	addi	r4,r4,-5068
 8221dd0:	821f1840 	call	821f184 <no_printf>
	                    tse_dprintf(6, "INFO    : MAC Device               = tse_mac_device[%d]\n", i + j);
 8221dd4:	e0fffc07 	ldb	r3,-16(fp)
 8221dd8:	e0bffc47 	ldb	r2,-15(fp)
 8221ddc:	1885883a 	add	r2,r3,r2
 8221de0:	100b883a 	mov	r5,r2
 8221de4:	01020974 	movhi	r4,2085
 8221de8:	213b1904 	addi	r4,r4,-5020
 8221dec:	821f1840 	call	821f184 <no_printf>
	                }
                }
                
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
 8221df0:	e0bffc47 	ldb	r2,-15(fp)
 8221df4:	e0fffd17 	ldw	r3,-12(fp)
 8221df8:	10800044 	addi	r2,r2,1
 8221dfc:	1085883a 	add	r2,r2,r2
 8221e00:	1085883a 	add	r2,r2,r2
 8221e04:	1885883a 	add	r2,r3,r2
 8221e08:	e0fffe17 	ldw	r3,-8(fp)
 8221e0c:	10c00015 	stw	r3,0(r2)
                pmac_group->channel = 1;
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 8221e10:	e0bffc43 	ldbu	r2,-15(fp)
 8221e14:	10800044 	addi	r2,r2,1
 8221e18:	e0bffc45 	stb	r2,-15(fp)
 8221e1c:	e0fffc47 	ldb	r3,-15(fp)
 8221e20:	e0bffd17 	ldw	r2,-12(fp)
 8221e24:	10800003 	ldbu	r2,0(r2)
 8221e28:	10803fcc 	andi	r2,r2,255
 8221e2c:	18bed916 	blt	r3,r2,8221994 <alt_tse_mac_group_init+0x18c>
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
            }
            
            /* store the pointer in global variable */
            pmac_groups[mac_group_count] = pmac_group;
 8221e30:	d0a07f43 	ldbu	r2,-32259(gp)
 8221e34:	10c03fcc 	andi	r3,r2,255
 8221e38:	008209b4 	movhi	r2,2086
 8221e3c:	10b6f604 	addi	r2,r2,-9256
 8221e40:	18c7883a 	add	r3,r3,r3
 8221e44:	18c7883a 	add	r3,r3,r3
 8221e48:	10c5883a 	add	r2,r2,r3
 8221e4c:	e0fffd17 	ldw	r3,-12(fp)
 8221e50:	10c00015 	stw	r3,0(r2)
            
            mac_group_count++;
 8221e54:	d0a07f43 	ldbu	r2,-32259(gp)
 8221e58:	10800044 	addi	r2,r2,1
 8221e5c:	d0a07f45 	stb	r2,-32259(gp)

            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
 8221e60:	e0bffd17 	ldw	r2,-12(fp)
 8221e64:	10c00003 	ldbu	r3,0(r2)
 8221e68:	e0bffc03 	ldbu	r2,-16(fp)
 8221e6c:	1885883a 	add	r2,r3,r2
 8221e70:	10bfffc4 	addi	r2,r2,-1
 8221e74:	e0bffc05 	stb	r2,-16(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 8221e78:	e0bffc03 	ldbu	r2,-16(fp)
 8221e7c:	10800044 	addi	r2,r2,1
 8221e80:	e0bffc05 	stb	r2,-16(fp)
 8221e84:	e0fffc07 	ldb	r3,-16(fp)
 8221e88:	d0a02d03 	ldbu	r2,-32588(gp)
 8221e8c:	10803fcc 	andi	r2,r2,255
 8221e90:	18be6716 	blt	r3,r2,8221830 <alt_tse_mac_group_init+0x28>
            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
                        
        }
    }
    return SUCCESS;
 8221e94:	0005883a 	mov	r2,zero
}
 8221e98:	e037883a 	mov	sp,fp
 8221e9c:	dfc00117 	ldw	ra,4(sp)
 8221ea0:	df000017 	ldw	fp,0(sp)
 8221ea4:	dec00204 	addi	sp,sp,8
 8221ea8:	f800283a 	ret

08221eac <alt_tse_mac_get_phy>:
/* @Function Description: Store information of all the PHYs connected to MAC to phy_list
 * @API Type:         Internal
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @return            Number of PHY not in profile, return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 */
alt_32 alt_tse_mac_get_phy(alt_tse_mac_group *pmac_group) {
 8221eac:	deffed04 	addi	sp,sp,-76
 8221eb0:	dfc01215 	stw	ra,72(sp)
 8221eb4:	df001115 	stw	fp,68(sp)
 8221eb8:	df001104 	addi	fp,sp,68
 8221ebc:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 phyid; 
	alt_32 phyid2 = 0;
 8221ec0:	e03ff515 	stw	zero,-44(fp)
    alt_u8 revision_number;

    alt_32 i;

    alt_u8 is_phy_in_profile;
    alt_32 return_value = 0;
 8221ec4:	e03ff315 	stw	zero,-52(fp)
    
    alt_8 phy_info_count = 0;
 8221ec8:	e03ff405 	stb	zero,-48(fp)
    
    alt_tse_phy_info *pphy = 0;
 8221ecc:	e03ff615 	stw	zero,-40(fp)
    alt_tse_mac_info *pmac_info = 0;
 8221ed0:	e03ff715 	stw	zero,-36(fp)
    alt_tse_system_info *psys = 0;
 8221ed4:	e03ff815 	stw	zero,-32(fp)
    
    np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8221ed8:	e0bfff17 	ldw	r2,-4(fp)
 8221edc:	10800117 	ldw	r2,4(r2)
 8221ee0:	10800217 	ldw	r2,8(r2)
 8221ee4:	10800017 	ldw	r2,0(r2)
 8221ee8:	e0bff915 	stw	r2,-28(fp)
            
    /* Record previous MDIO address, to be restored at the end of function */
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 8221eec:	e0bff917 	ldw	r2,-28(fp)
 8221ef0:	10801004 	addi	r2,r2,64
 8221ef4:	10800037 	ldwio	r2,0(r2)
 8221ef8:	e0bffa15 	stw	r2,-24(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8221efc:	e13fff17 	ldw	r4,-4(fp)
 8221f00:	82203080 	call	8220308 <alt_tse_get_mac_group_index>
 8221f04:	e0bffb05 	stb	r2,-20(fp)
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
 8221f08:	e03ff005 	stb	zero,-64(fp)
 8221f0c:	0000cb06 	br	822223c <alt_tse_mac_get_phy+0x390>
    {        
        IOWR(&pmac_group_base->MDIO_ADDR1, 0, phyadd);
 8221f10:	e0bff917 	ldw	r2,-28(fp)
 8221f14:	10801004 	addi	r2,r2,64
 8221f18:	e0fff003 	ldbu	r3,-64(fp)
 8221f1c:	10c00035 	stwio	r3,0(r2)
        phyid = IORD(&pmac_group_base->mdio1.PHY_ID1,0);     // read PHY ID
 8221f20:	e0bff917 	ldw	r2,-28(fp)
 8221f24:	1080a204 	addi	r2,r2,648
 8221f28:	10800037 	ldwio	r2,0(r2)
 8221f2c:	e0bffc15 	stw	r2,-16(fp)
        phyid2 = IORD(&pmac_group_base->mdio1.PHY_ID2,0);     // read PHY ID
 8221f30:	e0bff917 	ldw	r2,-28(fp)
 8221f34:	1080a304 	addi	r2,r2,652
 8221f38:	10800037 	ldwio	r2,0(r2)
 8221f3c:	e0bff515 	stw	r2,-44(fp)
        
        /* PHY found */
        if (phyid != phyid2)
 8221f40:	e0fffc17 	ldw	r3,-16(fp)
 8221f44:	e0bff517 	ldw	r2,-44(fp)
 8221f48:	1880b926 	beq	r3,r2,8222230 <alt_tse_mac_get_phy+0x384>
        {
            pphy = (alt_tse_phy_info *) malloc(sizeof(alt_tse_phy_info));
 8221f4c:	01000704 	movi	r4,28
 8221f50:	824b6900 	call	824b690 <malloc>
 8221f54:	e0bff615 	stw	r2,-40(fp)
            if(!pphy) {
 8221f58:	e0bff617 	ldw	r2,-40(fp)
 8221f5c:	1000091e 	bne	r2,zero,8221f84 <alt_tse_mac_get_phy+0xd8>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for phy_info[%d.%d]\n", mac_group_index, phy_info_count);
 8221f60:	e0bffb07 	ldb	r2,-20(fp)
 8221f64:	e0fff407 	ldb	r3,-48(fp)
 8221f68:	180d883a 	mov	r6,r3
 8221f6c:	100b883a 	mov	r5,r2
 8221f70:	01020974 	movhi	r4,2085
 8221f74:	213b2804 	addi	r4,r4,-4960
 8221f78:	82033a00 	call	82033a0 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 8221f7c:	00bfffc4 	movi	r2,-1
 8221f80:	0000ce06 	br	82222bc <alt_tse_mac_get_phy+0x410>
            }
            
            /* store PHY address */
            pphy->mdio_address = phyadd;
 8221f84:	e0bff617 	ldw	r2,-40(fp)
 8221f88:	e0fff003 	ldbu	r3,-64(fp)
 8221f8c:	10c00005 	stb	r3,0(r2)

            /* get oui, model number, and revision number from PHYID and PHYID2 */
            oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
 8221f90:	e0bffc17 	ldw	r2,-16(fp)
 8221f94:	100691ba 	slli	r3,r2,6
 8221f98:	e0bff517 	ldw	r2,-44(fp)
 8221f9c:	1005d2ba 	srai	r2,r2,10
 8221fa0:	10800fcc 	andi	r2,r2,63
 8221fa4:	1884b03a 	or	r2,r3,r2
 8221fa8:	e0bffd15 	stw	r2,-12(fp)
            model_number = (phyid2 >> 4) & 0x3f;
 8221fac:	e0bff517 	ldw	r2,-44(fp)
 8221fb0:	1005d13a 	srai	r2,r2,4
 8221fb4:	10800fcc 	andi	r2,r2,63
 8221fb8:	e0bffe05 	stb	r2,-8(fp)
            revision_number = phyid2 & 0x0f;
 8221fbc:	e0bff517 	ldw	r2,-44(fp)
 8221fc0:	108003cc 	andi	r2,r2,15
 8221fc4:	e0bffe45 	stb	r2,-7(fp)
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
 8221fc8:	e03ff205 	stb	zero,-56(fp)
            for(i = 0; i < phy_profile_count; i++) {
 8221fcc:	e03ff115 	stw	zero,-60(fp)
 8221fd0:	00003406 	br	82220a4 <alt_tse_mac_get_phy+0x1f8>
                
                /* if PHY match with PHY in profile */
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
 8221fd4:	008209b4 	movhi	r2,2086
 8221fd8:	10b6fa04 	addi	r2,r2,-9240
 8221fdc:	e0fff117 	ldw	r3,-60(fp)
 8221fe0:	18c7883a 	add	r3,r3,r3
 8221fe4:	18c7883a 	add	r3,r3,r3
 8221fe8:	10c5883a 	add	r2,r2,r3
 8221fec:	10800017 	ldw	r2,0(r2)
 8221ff0:	10c01417 	ldw	r3,80(r2)
 8221ff4:	e0bffd17 	ldw	r2,-12(fp)
 8221ff8:	1880271e 	bne	r3,r2,8222098 <alt_tse_mac_get_phy+0x1ec>
 8221ffc:	008209b4 	movhi	r2,2086
 8222000:	10b6fa04 	addi	r2,r2,-9240
 8222004:	e0fff117 	ldw	r3,-60(fp)
 8222008:	18c7883a 	add	r3,r3,r3
 822200c:	18c7883a 	add	r3,r3,r3
 8222010:	10c5883a 	add	r2,r2,r3
 8222014:	10800017 	ldw	r2,0(r2)
 8222018:	10801503 	ldbu	r2,84(r2)
 822201c:	10c03fcc 	andi	r3,r2,255
 8222020:	e0bffe03 	ldbu	r2,-8(fp)
 8222024:	18801c1e 	bne	r3,r2,8222098 <alt_tse_mac_get_phy+0x1ec>
                {
                    pphy->pphy_profile = pphy_profiles[i];
 8222028:	008209b4 	movhi	r2,2086
 822202c:	10b6fa04 	addi	r2,r2,-9240
 8222030:	e0fff117 	ldw	r3,-60(fp)
 8222034:	18c7883a 	add	r3,r3,r3
 8222038:	18c7883a 	add	r3,r3,r3
 822203c:	10c5883a 	add	r2,r2,r3
 8222040:	10c00017 	ldw	r3,0(r2)
 8222044:	e0bff617 	ldw	r2,-40(fp)
 8222048:	10c00515 	stw	r3,20(r2)
                    
                    /* PHY found, add it to phy_list */
                    tse_dprintf(5, "INFO    : PHY %s found at PHY address 0x%02x of MAC Group[%d]\n", pphy_profiles[i]->name, phyadd, mac_group_index);
 822204c:	008209b4 	movhi	r2,2086
 8222050:	10b6fa04 	addi	r2,r2,-9240
 8222054:	e0fff117 	ldw	r3,-60(fp)
 8222058:	18c7883a 	add	r3,r3,r3
 822205c:	18c7883a 	add	r3,r3,r3
 8222060:	10c5883a 	add	r2,r2,r3
 8222064:	10800017 	ldw	r2,0(r2)
 8222068:	1009883a 	mov	r4,r2
 822206c:	e0bff003 	ldbu	r2,-64(fp)
 8222070:	e0fffb07 	ldb	r3,-20(fp)
 8222074:	180f883a 	mov	r7,r3
 8222078:	100d883a 	mov	r6,r2
 822207c:	200b883a 	mov	r5,r4
 8222080:	01020974 	movhi	r4,2085
 8222084:	213b3704 	addi	r4,r4,-4900
 8222088:	82033a00 	call	82033a0 <printf>
                    is_phy_in_profile = 1;
 822208c:	00800044 	movi	r2,1
 8222090:	e0bff205 	stb	r2,-56(fp)
                    break;
 8222094:	00000706 	br	82220b4 <alt_tse_mac_get_phy+0x208>
            model_number = (phyid2 >> 4) & 0x3f;
            revision_number = phyid2 & 0x0f;
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
            for(i = 0; i < phy_profile_count; i++) {
 8222098:	e0bff117 	ldw	r2,-60(fp)
 822209c:	10800044 	addi	r2,r2,1
 82220a0:	e0bff115 	stw	r2,-60(fp)
 82220a4:	d0a07f03 	ldbu	r2,-32260(gp)
 82220a8:	10803fcc 	andi	r2,r2,255
 82220ac:	e0fff117 	ldw	r3,-60(fp)
 82220b0:	18bfc816 	blt	r3,r2,8221fd4 <alt_tse_mac_get_phy+0x128>
                    is_phy_in_profile = 1;
                    break;
                }
            }
            /* PHY not found in PHY profile */
            if(is_phy_in_profile == 0) {
 82220b4:	e0bff203 	ldbu	r2,-56(fp)
 82220b8:	10000f1e 	bne	r2,zero,82220f8 <alt_tse_mac_get_phy+0x24c>
                pphy->pphy_profile = 0;
 82220bc:	e0bff617 	ldw	r2,-40(fp)
 82220c0:	10000515 	stw	zero,20(r2)
                tse_dprintf(3, "WARNING : Unknown PHY found at PHY address 0x%02x of MAC Group[%d]\n", phyadd, mac_group_index);
 82220c4:	e0bff003 	ldbu	r2,-64(fp)
 82220c8:	e0fffb07 	ldb	r3,-20(fp)
 82220cc:	180d883a 	mov	r6,r3
 82220d0:	100b883a 	mov	r5,r2
 82220d4:	01020974 	movhi	r4,2085
 82220d8:	213b4704 	addi	r4,r4,-4836
 82220dc:	82033a00 	call	82033a0 <printf>
                tse_dprintf(3, "WARNING : Please add PHY information to PHY profile\n");
 82220e0:	01020974 	movhi	r4,2085
 82220e4:	213b5804 	addi	r4,r4,-4768
 82220e8:	82036240 	call	8203624 <puts>
                return_value++;
 82220ec:	e0bff317 	ldw	r2,-52(fp)
 82220f0:	10800044 	addi	r2,r2,1
 82220f4:	e0bff315 	stw	r2,-52(fp)
            }
            
            tse_dprintf(6, "INFO    : PHY OUI             =  0x%06x\n", (int) oui);
 82220f8:	e0bffd17 	ldw	r2,-12(fp)
 82220fc:	100b883a 	mov	r5,r2
 8222100:	01020974 	movhi	r4,2085
 8222104:	213b6504 	addi	r4,r4,-4716
 8222108:	821f1840 	call	821f184 <no_printf>
            tse_dprintf(6, "INFO    : PHY Model Number    =  0x%02x\n", model_number);
 822210c:	e0bffe03 	ldbu	r2,-8(fp)
 8222110:	100b883a 	mov	r5,r2
 8222114:	01020974 	movhi	r4,2085
 8222118:	213b7004 	addi	r4,r4,-4672
 822211c:	821f1840 	call	821f184 <no_printf>
            tse_dprintf(6, "INFO    : PHY Revision Number =  0x%01x\n", revision_number);
 8222120:	e0bffe43 	ldbu	r2,-7(fp)
 8222124:	100b883a 	mov	r5,r2
 8222128:	01020974 	movhi	r4,2085
 822212c:	213b7b04 	addi	r4,r4,-4628
 8222130:	821f1840 	call	821f184 <no_printf>
            
            /* map the detected PHY to connected MAC */
            if(alt_tse_mac_associate_phy(pmac_group, pphy) == TSE_PHY_MAP_SUCCESS) {
 8222134:	e17ff617 	ldw	r5,-40(fp)
 8222138:	e13fff17 	ldw	r4,-4(fp)
 822213c:	82222d00 	call	82222d0 <alt_tse_mac_associate_phy>
 8222140:	1000351e 	bne	r2,zero,8222218 <alt_tse_mac_get_phy+0x36c>
            	
            	pmac_info = pphy->pmac_info;
 8222144:	e0bff617 	ldw	r2,-40(fp)
 8222148:	10800617 	ldw	r2,24(r2)
 822214c:	e0bff715 	stw	r2,-36(fp)
            	psys = pmac_info->psys_info;
 8222150:	e0bff717 	ldw	r2,-36(fp)
 8222154:	10800217 	ldw	r2,8(r2)
 8222158:	e0bff815 	stw	r2,-32(fp)
            	
            	/* Disable PHY loopback to allow Auto-Negotiation completed */
    	        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 822215c:	d8000015 	stw	zero,0(sp)
 8222160:	01c00044 	movi	r7,1
 8222164:	01800384 	movi	r6,14
 8222168:	000b883a 	mov	r5,zero
 822216c:	e13ff617 	ldw	r4,-40(fp)
 8222170:	82211680 	call	8221168 <alt_tse_phy_wr_mdio_reg>
				
				/* Reset auto-negotiation advertisement */
				alt_tse_phy_set_adv_1000(pphy, 1);
 8222174:	01400044 	movi	r5,1
 8222178:	e13ff617 	ldw	r4,-40(fp)
 822217c:	822300c0 	call	822300c <alt_tse_phy_set_adv_1000>
				alt_tse_phy_set_adv_100(pphy, 1);
 8222180:	01400044 	movi	r5,1
 8222184:	e13ff617 	ldw	r4,-40(fp)
 8222188:	82231d00 	call	82231d0 <alt_tse_phy_set_adv_100>
				alt_tse_phy_set_adv_10(pphy, 1);
 822218c:	01400044 	movi	r5,1
 8222190:	e13ff617 	ldw	r4,-40(fp)
 8222194:	82234240 	call	8223424 <alt_tse_phy_set_adv_10>
            	            	
	            /* check link connection for this PHY */
	            alt_tse_phy_restart_an(pphy, ALTERA_CHECKLINK_TIMEOUT_THRESHOLD);
 8222198:	014003f4 	movhi	r5,15
 822219c:	29509004 	addi	r5,r5,16960
 82221a0:	e13ff617 	ldw	r4,-40(fp)
 82221a4:	82227580 	call	8222758 <alt_tse_phy_restart_an>
	            
	            /* Perform additional setting if there is any */
	            /* Profile specific */
	            if(pphy->pphy_profile) {
 82221a8:	e0bff617 	ldw	r2,-40(fp)
 82221ac:	10800517 	ldw	r2,20(r2)
 82221b0:	10000f26 	beq	r2,zero,82221f0 <alt_tse_mac_get_phy+0x344>
		            if(pphy->pphy_profile->phy_cfg) {
 82221b4:	e0bff617 	ldw	r2,-40(fp)
 82221b8:	10800517 	ldw	r2,20(r2)
 82221bc:	10801717 	ldw	r2,92(r2)
 82221c0:	10000b26 	beq	r2,zero,82221f0 <alt_tse_mac_get_phy+0x344>
		                tse_dprintf(6, "INFO    : Applying additional PHY configuration of %s\n", pphy->pphy_profile->name);
 82221c4:	e0bff617 	ldw	r2,-40(fp)
 82221c8:	10800517 	ldw	r2,20(r2)
 82221cc:	100b883a 	mov	r5,r2
 82221d0:	01020974 	movhi	r4,2085
 82221d4:	213b8604 	addi	r4,r4,-4584
 82221d8:	821f1840 	call	821f184 <no_printf>
		                pphy->pphy_profile->phy_cfg(pmac_group_base);
 82221dc:	e0bff617 	ldw	r2,-40(fp)
 82221e0:	10800517 	ldw	r2,20(r2)
 82221e4:	10801717 	ldw	r2,92(r2)
 82221e8:	e13ff917 	ldw	r4,-28(fp)
 82221ec:	103ee83a 	callr	r2
		            }
	            }
	            
	            /* Initialize PHY, call user's function pointer in alt_tse_system_info structure */
	            /* Individual PHY specific */
            	if(psys->tse_phy_cfg) {
 82221f0:	e0bff817 	ldw	r2,-32(fp)
 82221f4:	10801117 	ldw	r2,68(r2)
 82221f8:	10000726 	beq	r2,zero,8222218 <alt_tse_mac_get_phy+0x36c>
            		tse_dprintf(6, "INFO    : Applying additional user PHY configuration\n");
 82221fc:	01020974 	movhi	r4,2085
 8222200:	213b9404 	addi	r4,r4,-4528
 8222204:	821f1840 	call	821f184 <no_printf>
            		psys->tse_phy_cfg(pmac_group_base);
 8222208:	e0bff817 	ldw	r2,-32(fp)
 822220c:	10801117 	ldw	r2,68(r2)
 8222210:	e13ff917 	ldw	r4,-28(fp)
 8222214:	103ee83a 	callr	r2
            	}
            }
            
            tse_dprintf(6, "\n");
 8222218:	01020974 	movhi	r4,2085
 822221c:	213ba204 	addi	r4,r4,-4472
 8222220:	821f1840 	call	821f184 <no_printf>
	            
            phy_info_count++;
 8222224:	e0bff403 	ldbu	r2,-48(fp)
 8222228:	10800044 	addi	r2,r2,1
 822222c:	e0bff405 	stb	r2,-48(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
 8222230:	e0bff003 	ldbu	r2,-64(fp)
 8222234:	10800044 	addi	r2,r2,1
 8222238:	e0bff005 	stb	r2,-64(fp)
 822223c:	e0bff003 	ldbu	r2,-64(fp)
 8222240:	10800830 	cmpltui	r2,r2,32
 8222244:	103f321e 	bne	r2,zero,8221f10 <alt_tse_mac_get_phy+0x64>
            phy_info_count++;
        }
    }
    
    /* check to verify the number of connected PHY match the number of channel */
    if(pmac_group->channel != phy_info_count) {
 8222248:	e0bfff17 	ldw	r2,-4(fp)
 822224c:	10800003 	ldbu	r2,0(r2)
 8222250:	10c03fcc 	andi	r3,r2,255
 8222254:	e0bff407 	ldb	r2,-48(fp)
 8222258:	18801326 	beq	r3,r2,82222a8 <alt_tse_mac_get_phy+0x3fc>
        if(phy_info_count == 0) {
 822225c:	e0bff407 	ldb	r2,-48(fp)
 8222260:	1000061e 	bne	r2,zero,822227c <alt_tse_mac_get_phy+0x3d0>
            tse_dprintf(2, "ERROR   : MAC Group[%d] - No PHY connected!\n", mac_group_index);
 8222264:	e0bffb07 	ldb	r2,-20(fp)
 8222268:	100b883a 	mov	r5,r2
 822226c:	01020974 	movhi	r4,2085
 8222270:	213ba304 	addi	r4,r4,-4468
 8222274:	82033a00 	call	82033a0 <printf>
 8222278:	00000b06 	br	82222a8 <alt_tse_mac_get_phy+0x3fc>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Group[%d] - Number of PHY connected is not equal to the number of channel, Number of PHY : %d, Channel : %d\n", mac_group_index, phy_info_count, pmac_group->channel);
 822227c:	e0fffb07 	ldb	r3,-20(fp)
 8222280:	e13ff407 	ldb	r4,-48(fp)
 8222284:	e0bfff17 	ldw	r2,-4(fp)
 8222288:	10800003 	ldbu	r2,0(r2)
 822228c:	10803fcc 	andi	r2,r2,255
 8222290:	100f883a 	mov	r7,r2
 8222294:	200d883a 	mov	r6,r4
 8222298:	180b883a 	mov	r5,r3
 822229c:	01020974 	movhi	r4,2085
 82222a0:	213baf04 	addi	r4,r4,-4420
 82222a4:	82033a00 	call	82033a0 <printf>
        }
    }
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 82222a8:	e0bff917 	ldw	r2,-28(fp)
 82222ac:	10801004 	addi	r2,r2,64
 82222b0:	e0fffa17 	ldw	r3,-24(fp)
 82222b4:	10c00035 	stwio	r3,0(r2)
    
    return return_value;
 82222b8:	e0bff317 	ldw	r2,-52(fp)
}
 82222bc:	e037883a 	mov	sp,fp
 82222c0:	dfc00117 	ldw	ra,4(sp)
 82222c4:	df000017 	ldw	fp,0(sp)
 82222c8:	dec00204 	addi	sp,sp,8
 82222cc:	f800283a 	ret

082222d0 <alt_tse_mac_associate_phy>:
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @param pphy        Pointer to the TSE PHY info structure which hold information of PHY
 * @return            return TSE_PHY_MAP_ERROR if mapping error
 *                    return TSE_PHY_MAP_SUCCESS otherwise
 */
alt_32 alt_tse_mac_associate_phy(alt_tse_mac_group *pmac_group, alt_tse_phy_info *pphy) {
 82222d0:	defff604 	addi	sp,sp,-40
 82222d4:	dfc00915 	stw	ra,36(sp)
 82222d8:	df000815 	stw	fp,32(sp)
 82222dc:	df000804 	addi	fp,sp,32
 82222e0:	e13ffe15 	stw	r4,-8(fp)
 82222e4:	e17fff15 	stw	r5,-4(fp)
    
	alt_32 i;
	alt_32 return_value = TSE_PHY_MAP_SUCCESS;
 82222e8:	e03ff915 	stw	zero,-28(fp)
    
	alt_u8 is_mapped;

    alt_tse_system_info *psys = 0;
 82222ec:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_mac_info *pmac_info = 0;
 82222f0:	e03ffc15 	stw	zero,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 82222f4:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 82222f8:	e13ffe17 	ldw	r4,-8(fp)
 82222fc:	82203080 	call	8220308 <alt_tse_get_mac_group_index>
 8222300:	e0bffd45 	stb	r2,-11(fp)
    alt_8 sys_info_index = 0;
 8222304:	e03ffd85 	stb	zero,-10(fp)
    
    is_mapped = 0;
 8222308:	e03ffa05 	stb	zero,-24(fp)
    
    for(i = 0; i < pmac_group->channel; i++) {
 822230c:	e03ff815 	stw	zero,-32(fp)
 8222310:	00002c06 	br	82223c4 <alt_tse_mac_associate_phy+0xf4>
        pmac_info = pmac_group->pmac_info[i];
 8222314:	e0fffe17 	ldw	r3,-8(fp)
 8222318:	e0bff817 	ldw	r2,-32(fp)
 822231c:	10800044 	addi	r2,r2,1
 8222320:	1085883a 	add	r2,r2,r2
 8222324:	1085883a 	add	r2,r2,r2
 8222328:	1885883a 	add	r2,r3,r2
 822232c:	10800017 	ldw	r2,0(r2)
 8222330:	e0bffc15 	stw	r2,-16(fp)
        psys = pmac_info->psys_info;
 8222334:	e0bffc17 	ldw	r2,-16(fp)
 8222338:	10800217 	ldw	r2,8(r2)
 822233c:	e0bffb15 	stw	r2,-20(fp)
       
        /* map according to the PHY address in alt_tse_system_info.h */
        if(psys->tse_phy_mdio_address == pphy->mdio_address) {
 8222340:	e0bffb17 	ldw	r2,-20(fp)
 8222344:	10c01017 	ldw	r3,64(r2)
 8222348:	e0bfff17 	ldw	r2,-4(fp)
 822234c:	10800003 	ldbu	r2,0(r2)
 8222350:	10803fcc 	andi	r2,r2,255
 8222354:	1880181e 	bne	r3,r2,82223b8 <alt_tse_mac_associate_phy+0xe8>
        	mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8222358:	e13ffc17 	ldw	r4,-16(fp)
 822235c:	822037c0 	call	822037c <alt_tse_get_mac_info_index>
 8222360:	e0bffd05 	stb	r2,-12(fp)
	        sys_info_index = alt_tse_get_system_index(psys);
 8222364:	e13ffb17 	ldw	r4,-20(fp)
 8222368:	822029c0 	call	822029c <alt_tse_get_system_index>
 822236c:	e0bffd85 	stb	r2,-10(fp)
	        
            pmac_info->pphy_info = pphy;
 8222370:	e0bffc17 	ldw	r2,-16(fp)
 8222374:	e0ffff17 	ldw	r3,-4(fp)
 8222378:	10c00115 	stw	r3,4(r2)
            pphy->pmac_info = pmac_info;
 822237c:	e0bfff17 	ldw	r2,-4(fp)
 8222380:	e0fffc17 	ldw	r3,-16(fp)
 8222384:	10c00615 	stw	r3,24(r2)
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Explicitly mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 8222388:	e0bffd47 	ldb	r2,-11(fp)
 822238c:	e0fffd07 	ldb	r3,-12(fp)
 8222390:	e13ffd87 	ldb	r4,-10(fp)
 8222394:	200f883a 	mov	r7,r4
 8222398:	180d883a 	mov	r6,r3
 822239c:	100b883a 	mov	r5,r2
 82223a0:	01020974 	movhi	r4,2085
 82223a4:	213bce04 	addi	r4,r4,-4296
 82223a8:	82033a00 	call	82033a0 <printf>
            is_mapped = 1;
 82223ac:	00800044 	movi	r2,1
 82223b0:	e0bffa05 	stb	r2,-24(fp)
            break;
 82223b4:	00000806 	br	82223d8 <alt_tse_mac_associate_phy+0x108>
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    alt_8 sys_info_index = 0;
    
    is_mapped = 0;
    
    for(i = 0; i < pmac_group->channel; i++) {
 82223b8:	e0bff817 	ldw	r2,-32(fp)
 82223bc:	10800044 	addi	r2,r2,1
 82223c0:	e0bff815 	stw	r2,-32(fp)
 82223c4:	e0bffe17 	ldw	r2,-8(fp)
 82223c8:	10800003 	ldbu	r2,0(r2)
 82223cc:	10803fcc 	andi	r2,r2,255
 82223d0:	e0fff817 	ldw	r3,-32(fp)
 82223d4:	18bfcf16 	blt	r3,r2,8222314 <alt_tse_mac_associate_phy+0x44>
            break;
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
 82223d8:	e0bffa03 	ldbu	r2,-24(fp)
 82223dc:	10003d1e 	bne	r2,zero,82224d4 <alt_tse_mac_associate_phy+0x204>
        for(i = 0; i < pmac_group->channel; i++) {
 82223e0:	e03ff815 	stw	zero,-32(fp)
 82223e4:	00003606 	br	82224c0 <alt_tse_mac_associate_phy+0x1f0>
            pmac_info = pmac_group->pmac_info[i];
 82223e8:	e0fffe17 	ldw	r3,-8(fp)
 82223ec:	e0bff817 	ldw	r2,-32(fp)
 82223f0:	10800044 	addi	r2,r2,1
 82223f4:	1085883a 	add	r2,r2,r2
 82223f8:	1085883a 	add	r2,r2,r2
 82223fc:	1885883a 	add	r2,r3,r2
 8222400:	10800017 	ldw	r2,0(r2)
 8222404:	e0bffc15 	stw	r2,-16(fp)
            psys = pmac_info->psys_info;
 8222408:	e0bffc17 	ldw	r2,-16(fp)
 822240c:	10800217 	ldw	r2,8(r2)
 8222410:	e0bffb15 	stw	r2,-20(fp)
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
 8222414:	e0bffb17 	ldw	r2,-20(fp)
 8222418:	10800517 	ldw	r2,20(r2)
 822241c:	10002426 	beq	r2,zero,82224b0 <alt_tse_mac_associate_phy+0x1e0>
 8222420:	e0bffb17 	ldw	r2,-20(fp)
 8222424:	10800617 	ldw	r2,24(r2)
 8222428:	10002126 	beq	r2,zero,82224b0 <alt_tse_mac_associate_phy+0x1e0>
            	continue;
            }
            
            if(psys->tse_phy_mdio_address == TSE_PHY_AUTO_ADDRESS) {
 822242c:	e0bffb17 	ldw	r2,-20(fp)
 8222430:	10801017 	ldw	r2,64(r2)
 8222434:	10bfffd8 	cmpnei	r2,r2,-1
 8222438:	10001e1e 	bne	r2,zero,82224b4 <alt_tse_mac_associate_phy+0x1e4>
                mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 822243c:	e13ffc17 	ldw	r4,-16(fp)
 8222440:	822037c0 	call	822037c <alt_tse_get_mac_info_index>
 8222444:	e0bffd05 	stb	r2,-12(fp)
                sys_info_index = alt_tse_get_system_index(psys);
 8222448:	e13ffb17 	ldw	r4,-20(fp)
 822244c:	822029c0 	call	822029c <alt_tse_get_system_index>
 8222450:	e0bffd85 	stb	r2,-10(fp)
                
                pmac_info->pphy_info = pphy;
 8222454:	e0bffc17 	ldw	r2,-16(fp)
 8222458:	e0ffff17 	ldw	r3,-4(fp)
 822245c:	10c00115 	stw	r3,4(r2)
                pphy->pmac_info = pmac_info;
 8222460:	e0bfff17 	ldw	r2,-4(fp)
 8222464:	e0fffc17 	ldw	r3,-16(fp)
 8222468:	10c00615 	stw	r3,24(r2)
                psys->tse_phy_mdio_address = pphy->mdio_address;
 822246c:	e0bfff17 	ldw	r2,-4(fp)
 8222470:	10800003 	ldbu	r2,0(r2)
 8222474:	10c03fcc 	andi	r3,r2,255
 8222478:	e0bffb17 	ldw	r2,-20(fp)
 822247c:	10c01015 	stw	r3,64(r2)
                tse_dprintf(5, "INFO    : PHY[%d.%d] - Automatically mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 8222480:	e0bffd47 	ldb	r2,-11(fp)
 8222484:	e0fffd07 	ldb	r3,-12(fp)
 8222488:	e13ffd87 	ldb	r4,-10(fp)
 822248c:	200f883a 	mov	r7,r4
 8222490:	180d883a 	mov	r6,r3
 8222494:	100b883a 	mov	r5,r2
 8222498:	01020974 	movhi	r4,2085
 822249c:	213bde04 	addi	r4,r4,-4232
 82224a0:	82033a00 	call	82033a0 <printf>
                is_mapped = 1;
 82224a4:	00800044 	movi	r2,1
 82224a8:	e0bffa05 	stb	r2,-24(fp)
                break;
 82224ac:	00000906 	br	82224d4 <alt_tse_mac_associate_phy+0x204>
            pmac_info = pmac_group->pmac_info[i];
            psys = pmac_info->psys_info;
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
            	continue;
 82224b0:	0001883a 	nop
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
        for(i = 0; i < pmac_group->channel; i++) {
 82224b4:	e0bff817 	ldw	r2,-32(fp)
 82224b8:	10800044 	addi	r2,r2,1
 82224bc:	e0bff815 	stw	r2,-32(fp)
 82224c0:	e0bffe17 	ldw	r2,-8(fp)
 82224c4:	10800003 	ldbu	r2,0(r2)
 82224c8:	10803fcc 	andi	r2,r2,255
 82224cc:	e0fff817 	ldw	r3,-32(fp)
 82224d0:	18bfc516 	blt	r3,r2,82223e8 <alt_tse_mac_associate_phy+0x118>
            }
        }
    }
    
    /* Still cannot find any matched MAC-PHY */
    if(is_mapped == 0) {
 82224d4:	e0bffa03 	ldbu	r2,-24(fp)
 82224d8:	1000091e 	bne	r2,zero,8222500 <alt_tse_mac_associate_phy+0x230>
    	pphy->pmac_info = 0;
 82224dc:	e0bfff17 	ldw	r2,-4(fp)
 82224e0:	10000615 	stw	zero,24(r2)
        tse_dprintf(2, "WARNING : PHY[%d.X] - Mapping of PHY to MAC failed! Make sure the PHY address is defined correctly in tse_mac_device[] structure, and number of PHYs connected is equivalent to number of channel\n", mac_group_index);
 82224e4:	e0bffd47 	ldb	r2,-11(fp)
 82224e8:	100b883a 	mov	r5,r2
 82224ec:	01020974 	movhi	r4,2085
 82224f0:	213bef04 	addi	r4,r4,-4164
 82224f4:	82033a00 	call	82033a0 <printf>
        return_value = TSE_PHY_MAP_ERROR;
 82224f8:	00bfffc4 	movi	r2,-1
 82224fc:	e0bff915 	stw	r2,-28(fp)
    }
    
    return return_value;
 8222500:	e0bff917 	ldw	r2,-28(fp)
}
 8222504:	e037883a 	mov	sp,fp
 8222508:	dfc00117 	ldw	ra,4(sp)
 822250c:	df000017 	ldw	fp,0(sp)
 8222510:	dec00204 	addi	sp,sp,8
 8222514:	f800283a 	ret

08222518 <alt_tse_phy_cfg_pcs>:
/* @Function Description: Configure operating mode of Altera PCS if available
 * @API Type:           Internal
 * @param pmac_info     pointer to MAC info variable
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_cfg_pcs(alt_tse_mac_info *pmac_info) {
 8222518:	defff804 	addi	sp,sp,-32
 822251c:	dfc00715 	stw	ra,28(sp)
 8222520:	df000615 	stw	fp,24(sp)
 8222524:	df000604 	addi	fp,sp,24
 8222528:	e13fff15 	stw	r4,-4(fp)
    
    alt_tse_system_info *psys = pmac_info->psys_info;
 822252c:	e0bfff17 	ldw	r2,-4(fp)
 8222530:	10800217 	ldw	r2,8(r2)
 8222534:	e0bffa15 	stw	r2,-24(fp)
    np_tse_mac *pmac = (np_tse_mac *) psys->tse_mac_base;
 8222538:	e0bffa17 	ldw	r2,-24(fp)
 822253c:	10800017 	ldw	r2,0(r2)
 8222540:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 8222544:	e0bfff17 	ldw	r2,-4(fp)
 8222548:	10800317 	ldw	r2,12(r2)
 822254c:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8222550:	e13fff17 	ldw	r4,-4(fp)
 8222554:	822037c0 	call	822037c <alt_tse_get_mac_info_index>
 8222558:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 822255c:	e13ffc17 	ldw	r4,-16(fp)
 8222560:	82203080 	call	8220308 <alt_tse_get_mac_group_index>
 8222564:	e0bffd45 	stb	r2,-11(fp)

    if(psys->tse_pcs_ena) {
 8222568:	e0bffa17 	ldw	r2,-24(fp)
 822256c:	108003c3 	ldbu	r2,15(r2)
 8222570:	10803fcc 	andi	r2,r2,255
 8222574:	10002c26 	beq	r2,zero,8222628 <alt_tse_phy_cfg_pcs+0x110>
        tse_dprintf(5, "INFO    : PCS[%d.%d] - Configuring PCS operating mode\n", mac_group_index, mac_info_index);
 8222578:	e0bffd47 	ldb	r2,-11(fp)
 822257c:	e0fffd07 	ldb	r3,-12(fp)
 8222580:	180d883a 	mov	r6,r3
 8222584:	100b883a 	mov	r5,r2
 8222588:	01020974 	movhi	r4,2085
 822258c:	213c2004 	addi	r4,r4,-3968
 8222590:	82033a00 	call	82033a0 <printf>
        
        alt_32 data = IORD(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE); 
 8222594:	e0bffb17 	ldw	r2,-20(fp)
 8222598:	10808004 	addi	r2,r2,512
 822259c:	10801404 	addi	r2,r2,80
 82225a0:	10800037 	ldwio	r2,0(r2)
 82225a4:	e0bffe15 	stw	r2,-8(fp)
        
        if(psys->tse_pcs_sgmii) {
 82225a8:	e0bffa17 	ldw	r2,-24(fp)
 82225ac:	10800403 	ldbu	r2,16(r2)
 82225b0:	10803fcc 	andi	r2,r2,255
 82225b4:	10000e26 	beq	r2,zero,82225f0 <alt_tse_phy_cfg_pcs+0xd8>
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode enabled\n", mac_group_index, mac_info_index);
 82225b8:	e0bffd47 	ldb	r2,-11(fp)
 82225bc:	e0fffd07 	ldb	r3,-12(fp)
 82225c0:	180d883a 	mov	r6,r3
 82225c4:	100b883a 	mov	r5,r2
 82225c8:	01020974 	movhi	r4,2085
 82225cc:	213c2e04 	addi	r4,r4,-3912
 82225d0:	82033a00 	call	82033a0 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data | 0x03);
 82225d4:	e0bffb17 	ldw	r2,-20(fp)
 82225d8:	10808004 	addi	r2,r2,512
 82225dc:	10801404 	addi	r2,r2,80
 82225e0:	e0fffe17 	ldw	r3,-8(fp)
 82225e4:	18c000d4 	ori	r3,r3,3
 82225e8:	10c00035 	stwio	r3,0(r2)
 82225ec:	00000e06 	br	8222628 <alt_tse_phy_cfg_pcs+0x110>
            }
        else {
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode disabled\n", mac_group_index, mac_info_index);
 82225f0:	e0bffd47 	ldb	r2,-11(fp)
 82225f4:	e0fffd07 	ldb	r3,-12(fp)
 82225f8:	180d883a 	mov	r6,r3
 82225fc:	100b883a 	mov	r5,r2
 8222600:	01020974 	movhi	r4,2085
 8222604:	213c3a04 	addi	r4,r4,-3864
 8222608:	82033a00 	call	82033a0 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data & ~0x03);
 822260c:	e0bffb17 	ldw	r2,-20(fp)
 8222610:	10808004 	addi	r2,r2,512
 8222614:	10801404 	addi	r2,r2,80
 8222618:	e13ffe17 	ldw	r4,-8(fp)
 822261c:	00ffff04 	movi	r3,-4
 8222620:	20c6703a 	and	r3,r4,r3
 8222624:	10c00035 	stwio	r3,0(r2)
        }
    }
    
    return SUCCESS;
 8222628:	0005883a 	mov	r2,zero
}
 822262c:	e037883a 	mov	sp,fp
 8222630:	dfc00117 	ldw	ra,4(sp)
 8222634:	df000017 	ldw	fp,0(sp)
 8222638:	dec00204 	addi	sp,sp,8
 822263c:	f800283a 	ret

08222640 <alt_tse_phy_init>:
/* @Function Description: Detect and initialize all the PHYs connected
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      SUCCESS
 */
alt_32 alt_tse_phy_init() {
 8222640:	defffb04 	addi	sp,sp,-20
 8222644:	dfc00415 	stw	ra,16(sp)
 8222648:	df000315 	stw	fp,12(sp)
 822264c:	df000304 	addi	fp,sp,12
	alt_8 i = 0;
 8222650:	e03ffd05 	stb	zero,-12(fp)
	alt_8 j = 0;
 8222654:	e03ffd45 	stb	zero,-11(fp)
    
    alt_tse_mac_group *pmac_group = 0;
 8222658:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_mac_info *pmac_info = 0;
 822265c:	e03fff15 	stw	zero,-4(fp)
    
    /* add supported PHYs */
    alt_tse_phy_add_profile_default();
 8222660:	822135c0 	call	822135c <alt_tse_phy_add_profile_default>
    
    /* display PHY in profile */
    alt_tse_phy_print_profile();
 8222664:	82215f80 	call	82215f8 <alt_tse_phy_print_profile>
    
    alt_tse_mac_group_init();
 8222668:	82218080 	call	8221808 <alt_tse_mac_group_init>
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 822266c:	e03ffd05 	stb	zero,-12(fp)
 8222670:	00002f06 	br	8222730 <alt_tse_phy_init+0xf0>
        pmac_group = pmac_groups[i];
 8222674:	e0fffd07 	ldb	r3,-12(fp)
 8222678:	008209b4 	movhi	r2,2086
 822267c:	10b6f604 	addi	r2,r2,-9256
 8222680:	18c7883a 	add	r3,r3,r3
 8222684:	18c7883a 	add	r3,r3,r3
 8222688:	10c5883a 	add	r2,r2,r3
 822268c:	10800017 	ldw	r2,0(r2)
 8222690:	e0bffe15 	stw	r2,-8(fp)
        
        if(pmac_group->pmac_info[0]->psys_info->tse_use_mdio) {
 8222694:	e0bffe17 	ldw	r2,-8(fp)
 8222698:	10800117 	ldw	r2,4(r2)
 822269c:	10800217 	ldw	r2,8(r2)
 82226a0:	10800203 	ldbu	r2,8(r2)
 82226a4:	10803fcc 	andi	r2,r2,255
 82226a8:	10000326 	beq	r2,zero,82226b8 <alt_tse_phy_init+0x78>
            
        	/* get connected PHYs */
            alt_tse_mac_get_phy(pmac_group);
 82226ac:	e13ffe17 	ldw	r4,-8(fp)
 82226b0:	8221eac0 	call	8221eac <alt_tse_mac_get_phy>
 82226b4:	00000706 	br	82226d4 <alt_tse_phy_init+0x94>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
 82226b8:	e0bffd07 	ldb	r2,-12(fp)
 82226bc:	e0fffd47 	ldb	r3,-11(fp)
 82226c0:	180d883a 	mov	r6,r3
 82226c4:	100b883a 	mov	r5,r2
 82226c8:	01020974 	movhi	r4,2085
 82226cc:	213c4604 	addi	r4,r4,-3816
 82226d0:	82033a00 	call	82033a0 <printf>
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 82226d4:	e03ffd45 	stb	zero,-11(fp)
 82226d8:	00000d06 	br	8222710 <alt_tse_phy_init+0xd0>
            pmac_info = pmac_group->pmac_info[j];
 82226dc:	e0bffd47 	ldb	r2,-11(fp)
 82226e0:	e0fffe17 	ldw	r3,-8(fp)
 82226e4:	10800044 	addi	r2,r2,1
 82226e8:	1085883a 	add	r2,r2,r2
 82226ec:	1085883a 	add	r2,r2,r2
 82226f0:	1885883a 	add	r2,r3,r2
 82226f4:	10800017 	ldw	r2,0(r2)
 82226f8:	e0bfff15 	stw	r2,-4(fp)
            
            alt_tse_phy_cfg_pcs(pmac_info);
 82226fc:	e13fff17 	ldw	r4,-4(fp)
 8222700:	82225180 	call	8222518 <alt_tse_phy_cfg_pcs>
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 8222704:	e0bffd43 	ldbu	r2,-11(fp)
 8222708:	10800044 	addi	r2,r2,1
 822270c:	e0bffd45 	stb	r2,-11(fp)
 8222710:	e0fffd47 	ldb	r3,-11(fp)
 8222714:	e0bffe17 	ldw	r2,-8(fp)
 8222718:	10800003 	ldbu	r2,0(r2)
 822271c:	10803fcc 	andi	r2,r2,255
 8222720:	18bfee16 	blt	r3,r2,82226dc <alt_tse_phy_init+0x9c>
    
    alt_tse_mac_group_init();
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 8222724:	e0bffd03 	ldbu	r2,-12(fp)
 8222728:	10800044 	addi	r2,r2,1
 822272c:	e0bffd05 	stb	r2,-12(fp)
 8222730:	e0fffd07 	ldb	r3,-12(fp)
 8222734:	d0a07f43 	ldbu	r2,-32259(gp)
 8222738:	10803fcc 	andi	r2,r2,255
 822273c:	18bfcd16 	blt	r3,r2,8222674 <alt_tse_phy_init+0x34>
            
            alt_tse_phy_cfg_pcs(pmac_info);
        }
    }
                
    return SUCCESS;
 8222740:	0005883a 	mov	r2,zero
}
 8222744:	e037883a 	mov	sp,fp
 8222748:	dfc00117 	ldw	ra,4(sp)
 822274c:	df000017 	ldw	fp,0(sp)
 8222750:	dec00204 	addi	sp,sp,8
 8222754:	f800283a 	ret

08222758 <alt_tse_phy_restart_an>:
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *                              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_restart_an(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 8222758:	defff704 	addi	sp,sp,-36
 822275c:	dfc00815 	stw	ra,32(sp)
 8222760:	df000715 	stw	fp,28(sp)
 8222764:	df000704 	addi	fp,sp,28
 8222768:	e13ffe15 	stw	r4,-8(fp)
 822276c:	e17fff15 	stw	r5,-4(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 8222770:	e0bffe17 	ldw	r2,-8(fp)
 8222774:	10800617 	ldw	r2,24(r2)
 8222778:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 822277c:	e0bffb17 	ldw	r2,-20(fp)
 8222780:	10800317 	ldw	r2,12(r2)
 8222784:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8222788:	e13ffb17 	ldw	r4,-20(fp)
 822278c:	822037c0 	call	822037c <alt_tse_get_mac_info_index>
 8222790:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8222794:	e13ffc17 	ldw	r4,-16(fp)
 8222798:	82203080 	call	8220308 <alt_tse_get_mac_group_index>
 822279c:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 82227a0:	e13ffe17 	ldw	r4,-8(fp)
 82227a4:	82210c80 	call	82210c8 <alt_tse_phy_rd_mdio_addr>
 82227a8:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 82227ac:	e0bffe17 	ldw	r2,-8(fp)
 82227b0:	10800003 	ldbu	r2,0(r2)
 82227b4:	10803fcc 	andi	r2,r2,255
 82227b8:	100b883a 	mov	r5,r2
 82227bc:	e13ffe17 	ldw	r4,-8(fp)
 82227c0:	82211100 	call	8221110 <alt_tse_phy_wr_mdio_addr>
    
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 82227c4:	01c00044 	movi	r7,1
 82227c8:	018000c4 	movi	r6,3
 82227cc:	01400044 	movi	r5,1
 82227d0:	e13ffe17 	ldw	r4,-8(fp)
 82227d4:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 82227d8:	10000d1e 	bne	r2,zero,8222810 <alt_tse_phy_restart_an+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 82227dc:	e0bffd47 	ldb	r2,-11(fp)
 82227e0:	e0fffd07 	ldb	r3,-12(fp)
 82227e4:	180d883a 	mov	r6,r3
 82227e8:	100b883a 	mov	r5,r2
 82227ec:	01020974 	movhi	r4,2085
 82227f0:	213c5c04 	addi	r4,r4,-3728
 82227f4:	82033a00 	call	82033a0 <printf>
        
		/* Restore previous MDIO address */
		alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 82227f8:	e0bffd83 	ldbu	r2,-10(fp)
 82227fc:	100b883a 	mov	r5,r2
 8222800:	e13ffe17 	ldw	r4,-8(fp)
 8222804:	82211100 	call	8221110 <alt_tse_phy_wr_mdio_addr>
		
		return TSE_PHY_AN_NOT_CAPABLE;
 8222808:	00bfff84 	movi	r2,-2
 822280c:	00003c06 	br	8222900 <alt_tse_phy_restart_an+0x1a8>
    }
    
    /* enable Auto-Negotiation */    
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_AN_ENA, 1, 1);
 8222810:	00800044 	movi	r2,1
 8222814:	d8800015 	stw	r2,0(sp)
 8222818:	01c00044 	movi	r7,1
 822281c:	01800304 	movi	r6,12
 8222820:	000b883a 	mov	r5,zero
 8222824:	e13ffe17 	ldw	r4,-8(fp)
 8222828:	82211680 	call	8221168 <alt_tse_phy_wr_mdio_reg>
    
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
 822282c:	00800044 	movi	r2,1
 8222830:	d8800015 	stw	r2,0(sp)
 8222834:	01c00044 	movi	r7,1
 8222838:	01800244 	movi	r6,9
 822283c:	000b883a 	mov	r5,zero
 8222840:	e13ffe17 	ldw	r4,-8(fp)
 8222844:	82211680 	call	8221168 <alt_tse_phy_wr_mdio_reg>
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
 8222848:	e0bffd47 	ldb	r2,-11(fp)
 822284c:	e0fffd07 	ldb	r3,-12(fp)
 8222850:	180d883a 	mov	r6,r3
 8222854:	100b883a 	mov	r5,r2
 8222858:	01020974 	movhi	r4,2085
 822285c:	213c6c04 	addi	r4,r4,-3664
 8222860:	82033a00 	call	82033a0 <printf>
    
    alt_32 timeout = 0;
 8222864:	e03ffa15 	stw	zero,-24(fp)
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 8222868:	00001306 	br	82228b8 <alt_tse_phy_restart_an+0x160>
        if(timeout++ > timeout_threshold) {
 822286c:	e0bffa17 	ldw	r2,-24(fp)
 8222870:	10c00044 	addi	r3,r2,1
 8222874:	e0fffa15 	stw	r3,-24(fp)
 8222878:	1007883a 	mov	r3,r2
 822287c:	e0bfff17 	ldw	r2,-4(fp)
 8222880:	10c00d2e 	bgeu	r2,r3,82228b8 <alt_tse_phy_restart_an+0x160>
           tse_dprintf(4, "WARNING : PHY[%d.%d] - Auto-Negotiation FAILED\n", mac_group_index, mac_info_index);
 8222884:	e0bffd47 	ldb	r2,-11(fp)
 8222888:	e0fffd07 	ldb	r3,-12(fp)
 822288c:	180d883a 	mov	r6,r3
 8222890:	100b883a 	mov	r5,r2
 8222894:	01020974 	movhi	r4,2085
 8222898:	213c7e04 	addi	r4,r4,-3592
 822289c:	82033a00 	call	82033a0 <printf>
		   
		   /* Restore previous MDIO address */
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 82228a0:	e0bffd83 	ldbu	r2,-10(fp)
 82228a4:	100b883a 	mov	r5,r2
 82228a8:	e13ffe17 	ldw	r4,-8(fp)
 82228ac:	82211100 	call	8221110 <alt_tse_phy_wr_mdio_addr>
           
		   return TSE_PHY_AN_NOT_COMPLETE;
 82228b0:	00bfffc4 	movi	r2,-1
 82228b4:	00001206 	br	8222900 <alt_tse_phy_restart_an+0x1a8>
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
    
    alt_32 timeout = 0;
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 82228b8:	01c00044 	movi	r7,1
 82228bc:	01800144 	movi	r6,5
 82228c0:	01400044 	movi	r5,1
 82228c4:	e13ffe17 	ldw	r4,-8(fp)
 82228c8:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 82228cc:	103fe726 	beq	r2,zero,822286c <alt_tse_phy_restart_an+0x114>
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
           
		   return TSE_PHY_AN_NOT_COMPLETE;
        }
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Auto-Negotiation PASSED\n", mac_group_index, mac_info_index);
 82228d0:	e0bffd47 	ldb	r2,-11(fp)
 82228d4:	e0fffd07 	ldb	r3,-12(fp)
 82228d8:	180d883a 	mov	r6,r3
 82228dc:	100b883a 	mov	r5,r2
 82228e0:	01020974 	movhi	r4,2085
 82228e4:	213c8a04 	addi	r4,r4,-3544
 82228e8:	82033a00 	call	82033a0 <printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 82228ec:	e0bffd83 	ldbu	r2,-10(fp)
 82228f0:	100b883a 	mov	r5,r2
 82228f4:	e13ffe17 	ldw	r4,-8(fp)
 82228f8:	82211100 	call	8221110 <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE;
 82228fc:	0005883a 	mov	r2,zero
}
 8222900:	e037883a 	mov	sp,fp
 8222904:	dfc00117 	ldw	ra,4(sp)
 8222908:	df000017 	ldw	fp,0(sp)
 822290c:	dec00204 	addi	sp,sp,8
 8222910:	f800283a 	ret

08222914 <alt_tse_phy_check_link>:
 * @param pphy                  Pointer to the alt_tse_phy_info structure
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 */
alt_32 alt_tse_phy_check_link(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 8222914:	defff904 	addi	sp,sp,-28
 8222918:	dfc00615 	stw	ra,24(sp)
 822291c:	df000515 	stw	fp,20(sp)
 8222920:	df000504 	addi	fp,sp,20
 8222924:	e13ffe15 	stw	r4,-8(fp)
 8222928:	e17fff15 	stw	r5,-4(fp)

    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 822292c:	e0bffe17 	ldw	r2,-8(fp)
 8222930:	10800617 	ldw	r2,24(r2)
 8222934:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 8222938:	e0bffb17 	ldw	r2,-20(fp)
 822293c:	10800317 	ldw	r2,12(r2)
 8222940:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8222944:	e13ffb17 	ldw	r4,-20(fp)
 8222948:	822037c0 	call	822037c <alt_tse_get_mac_info_index>
 822294c:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group); 
 8222950:	e13ffc17 	ldw	r4,-16(fp)
 8222954:	82203080 	call	8220308 <alt_tse_get_mac_group_index>
 8222958:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 822295c:	e13ffe17 	ldw	r4,-8(fp)
 8222960:	82210c80 	call	82210c8 <alt_tse_phy_rd_mdio_addr>
 8222964:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 8222968:	e0bffe17 	ldw	r2,-8(fp)
 822296c:	10800003 	ldbu	r2,0(r2)
 8222970:	10803fcc 	andi	r2,r2,255
 8222974:	100b883a 	mov	r5,r2
 8222978:	e13ffe17 	ldw	r4,-8(fp)
 822297c:	82211100 	call	8221110 <alt_tse_phy_wr_mdio_addr>
    /* Issue a PHY reset here and wait for the link
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
 8222980:	e0bffd47 	ldb	r2,-11(fp)
 8222984:	e0fffd07 	ldb	r3,-12(fp)
 8222988:	180d883a 	mov	r6,r3
 822298c:	100b883a 	mov	r5,r2
 8222990:	01020974 	movhi	r4,2085
 8222994:	213c9604 	addi	r4,r4,-3496
 8222998:	82033a00 	call	82033a0 <printf>
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
 822299c:	01c00044 	movi	r7,1
 82229a0:	01800384 	movi	r6,14
 82229a4:	000b883a 	mov	r5,zero
 82229a8:	e13ffe17 	ldw	r4,-8(fp)
 82229ac:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 82229b0:	1000061e 	bne	r2,zero,82229cc <alt_tse_phy_check_link+0xb8>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
 82229b4:	01c00044 	movi	r7,1
 82229b8:	01800144 	movi	r6,5
 82229bc:	01400044 	movi	r5,1
 82229c0:	e13ffe17 	ldw	r4,-8(fp)
 82229c4:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
 82229c8:	1000191e 	bne	r2,zero,8222a30 <alt_tse_phy_check_link+0x11c>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
        
        tse_dprintf(5, "INFO    : PHY[%d.%d] - Link not yet established, restart auto-negotiation...\n", mac_group_index, mac_info_index);
 82229cc:	e0bffd47 	ldb	r2,-11(fp)
 82229d0:	e0fffd07 	ldb	r3,-12(fp)
 82229d4:	180d883a 	mov	r6,r3
 82229d8:	100b883a 	mov	r5,r2
 82229dc:	01020974 	movhi	r4,2085
 82229e0:	213ca104 	addi	r4,r4,-3452
 82229e4:	82033a00 	call	82033a0 <printf>
        /* restart Auto-Negotiation */
        /* if Auto-Negotiation still cannot complete, then go to next PHY */
        if(alt_tse_phy_restart_an(pphy, timeout_threshold) == TSE_PHY_AN_NOT_COMPLETE) {
 82229e8:	e17fff17 	ldw	r5,-4(fp)
 82229ec:	e13ffe17 	ldw	r4,-8(fp)
 82229f0:	82227580 	call	8222758 <alt_tse_phy_restart_an>
 82229f4:	10bfffd8 	cmpnei	r2,r2,-1
 82229f8:	10000d1e 	bne	r2,zero,8222a30 <alt_tse_phy_check_link+0x11c>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - Link could not established\n", mac_group_index, mac_info_index);
 82229fc:	e0bffd47 	ldb	r2,-11(fp)
 8222a00:	e0fffd07 	ldb	r3,-12(fp)
 8222a04:	180d883a 	mov	r6,r3
 8222a08:	100b883a 	mov	r5,r2
 8222a0c:	01020974 	movhi	r4,2085
 8222a10:	213cb504 	addi	r4,r4,-3372
 8222a14:	82033a00 	call	82033a0 <printf>
			
			/* Restore previous MDIO address */
			alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222a18:	e0bffd83 	ldbu	r2,-10(fp)
 8222a1c:	100b883a 	mov	r5,r2
 8222a20:	e13ffe17 	ldw	r4,-8(fp)
 8222a24:	82211100 	call	8221110 <alt_tse_phy_wr_mdio_addr>
	
            return TSE_PHY_AN_NOT_COMPLETE;
 8222a28:	00bfffc4 	movi	r2,-1
 8222a2c:	00000c06 	br	8222a60 <alt_tse_phy_check_link+0x14c>
        }            
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Link established\n", mac_group_index, mac_info_index);
 8222a30:	e0bffd47 	ldb	r2,-11(fp)
 8222a34:	e0fffd07 	ldb	r3,-12(fp)
 8222a38:	180d883a 	mov	r6,r3
 8222a3c:	100b883a 	mov	r5,r2
 8222a40:	01020974 	movhi	r4,2085
 8222a44:	213cc204 	addi	r4,r4,-3320
 8222a48:	82033a00 	call	82033a0 <printf>
            
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222a4c:	e0bffd83 	ldbu	r2,-10(fp)
 8222a50:	100b883a 	mov	r5,r2
 8222a54:	e13ffe17 	ldw	r4,-8(fp)
 8222a58:	82211100 	call	8221110 <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE; 
 8222a5c:	0005883a 	mov	r2,zero
}
 8222a60:	e037883a 	mov	sp,fp
 8222a64:	dfc00117 	ldw	ra,4(sp)
 8222a68:	df000017 	ldw	fp,0(sp)
 8222a6c:	dec00204 	addi	sp,sp,8
 8222a70:	f800283a 	ret

08222a74 <alt_tse_phy_get_cap>:
 * @param pmac  Pointer to the alt_tse_phy_info structure
 * @return      return TSE_PHY_AN_COMPLETE if success
 *              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
 8222a74:	defff904 	addi	sp,sp,-28
 8222a78:	dfc00615 	stw	ra,24(sp)
 8222a7c:	df000515 	stw	fp,20(sp)
 8222a80:	df000504 	addi	fp,sp,20
 8222a84:	e13fff15 	stw	r4,-4(fp)
	alt_32 return_value = TSE_PHY_AN_COMPLETE;
 8222a88:	e03ffb15 	stw	zero,-20(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 8222a8c:	e0bfff17 	ldw	r2,-4(fp)
 8222a90:	10800617 	ldw	r2,24(r2)
 8222a94:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 8222a98:	e0bffc17 	ldw	r2,-16(fp)
 8222a9c:	10800317 	ldw	r2,12(r2)
 8222aa0:	e0bffd15 	stw	r2,-12(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8222aa4:	e13ffc17 	ldw	r4,-16(fp)
 8222aa8:	822037c0 	call	822037c <alt_tse_get_mac_info_index>
 8222aac:	e0bffe05 	stb	r2,-8(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);    
 8222ab0:	e13ffd17 	ldw	r4,-12(fp)
 8222ab4:	82203080 	call	8220308 <alt_tse_get_mac_group_index>
 8222ab8:	e0bffe45 	stb	r2,-7(fp)
        
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 8222abc:	e13fff17 	ldw	r4,-4(fp)
 8222ac0:	82210c80 	call	82210c8 <alt_tse_phy_rd_mdio_addr>
 8222ac4:	e0bffe85 	stb	r2,-6(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 8222ac8:	e0bfff17 	ldw	r2,-4(fp)
 8222acc:	10800003 	ldbu	r2,0(r2)
 8222ad0:	10803fcc 	andi	r2,r2,255
 8222ad4:	100b883a 	mov	r5,r2
 8222ad8:	e13fff17 	ldw	r4,-4(fp)
 8222adc:	82211100 	call	8221110 <alt_tse_phy_wr_mdio_addr>
            
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 8222ae0:	01c00044 	movi	r7,1
 8222ae4:	018000c4 	movi	r6,3
 8222ae8:	01400044 	movi	r5,1
 8222aec:	e13fff17 	ldw	r4,-4(fp)
 8222af0:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8222af4:	10000d1e 	bne	r2,zero,8222b2c <alt_tse_phy_get_cap+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 8222af8:	e0bffe47 	ldb	r2,-7(fp)
 8222afc:	e0fffe07 	ldb	r3,-8(fp)
 8222b00:	180d883a 	mov	r6,r3
 8222b04:	100b883a 	mov	r5,r2
 8222b08:	01020974 	movhi	r4,2085
 8222b0c:	213c5c04 	addi	r4,r4,-3728
 8222b10:	82033a00 	call	82033a0 <printf>
        
        /* Restore previous MDIO address */
        alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222b14:	e0bffe83 	ldbu	r2,-6(fp)
 8222b18:	100b883a 	mov	r5,r2
 8222b1c:	e13fff17 	ldw	r4,-4(fp)
 8222b20:	82211100 	call	8221110 <alt_tse_phy_wr_mdio_addr>
        
        return TSE_PHY_AN_NOT_CAPABLE;
 8222b24:	00bfff84 	movi	r2,-2
 8222b28:	00013306 	br	8222ff8 <alt_tse_phy_get_cap+0x584>
    }
    
    /* check whether link has been established */
    alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 8222b2c:	01400134 	movhi	r5,4
 8222b30:	29742404 	addi	r5,r5,-12144
 8222b34:	e13fff17 	ldw	r4,-4(fp)
 8222b38:	82227580 	call	8222758 <alt_tse_phy_restart_an>
    
    if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0) {
 8222b3c:	01c00044 	movi	r7,1
 8222b40:	01800144 	movi	r6,5
 8222b44:	01400044 	movi	r5,1
 8222b48:	e13fff17 	ldw	r4,-4(fp)
 8222b4c:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8222b50:	1000021e 	bne	r2,zero,8222b5c <alt_tse_phy_get_cap+0xe8>
        return_value = TSE_PHY_AN_NOT_COMPLETE;
 8222b54:	00bfffc4 	movi	r2,-1
 8222b58:	e0bffb15 	stw	r2,-20(fp)
    }
    
    /* get PHY capabilities */
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
 8222b5c:	01c00044 	movi	r7,1
 8222b60:	018003c4 	movi	r6,15
 8222b64:	014003c4 	movi	r5,15
 8222b68:	e13fff17 	ldw	r4,-4(fp)
 8222b6c:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8222b70:	1007883a 	mov	r3,r2
 8222b74:	e0bfff17 	ldw	r2,-4(fp)
 8222b78:	10c00045 	stb	r3,1(r2)
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
 8222b7c:	01c00044 	movi	r7,1
 8222b80:	01800384 	movi	r6,14
 8222b84:	014003c4 	movi	r5,15
 8222b88:	e13fff17 	ldw	r4,-4(fp)
 8222b8c:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8222b90:	1007883a 	mov	r3,r2
 8222b94:	e0bfff17 	ldw	r2,-4(fp)
 8222b98:	10c00085 	stb	r3,2(r2)
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
 8222b9c:	01c00044 	movi	r7,1
 8222ba0:	01800344 	movi	r6,13
 8222ba4:	014003c4 	movi	r5,15
 8222ba8:	e13fff17 	ldw	r4,-4(fp)
 8222bac:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8222bb0:	1007883a 	mov	r3,r2
 8222bb4:	e0bfff17 	ldw	r2,-4(fp)
 8222bb8:	10c000c5 	stb	r3,3(r2)
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 8222bbc:	01c00044 	movi	r7,1
 8222bc0:	01800304 	movi	r6,12
 8222bc4:	014003c4 	movi	r5,15
 8222bc8:	e13fff17 	ldw	r4,-4(fp)
 8222bcc:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8222bd0:	1007883a 	mov	r3,r2
 8222bd4:	e0bfff17 	ldw	r2,-4(fp)
 8222bd8:	10c00105 	stb	r3,4(r2)
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 8222bdc:	01c00044 	movi	r7,1
 8222be0:	018003c4 	movi	r6,15
 8222be4:	01400044 	movi	r5,1
 8222be8:	e13fff17 	ldw	r4,-4(fp)
 8222bec:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8222bf0:	1007883a 	mov	r3,r2
 8222bf4:	e0bfff17 	ldw	r2,-4(fp)
 8222bf8:	10c00145 	stb	r3,5(r2)
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 8222bfc:	01c00044 	movi	r7,1
 8222c00:	01800384 	movi	r6,14
 8222c04:	01400044 	movi	r5,1
 8222c08:	e13fff17 	ldw	r4,-4(fp)
 8222c0c:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8222c10:	1007883a 	mov	r3,r2
 8222c14:	e0bfff17 	ldw	r2,-4(fp)
 8222c18:	10c00185 	stb	r3,6(r2)
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 8222c1c:	01c00044 	movi	r7,1
 8222c20:	01800344 	movi	r6,13
 8222c24:	01400044 	movi	r5,1
 8222c28:	e13fff17 	ldw	r4,-4(fp)
 8222c2c:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8222c30:	1007883a 	mov	r3,r2
 8222c34:	e0bfff17 	ldw	r2,-4(fp)
 8222c38:	10c001c5 	stb	r3,7(r2)
    pphy->link_capability.cap_100_base_t2_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_FULL, 1);
 8222c3c:	01c00044 	movi	r7,1
 8222c40:	01800284 	movi	r6,10
 8222c44:	01400044 	movi	r5,1
 8222c48:	e13fff17 	ldw	r4,-4(fp)
 8222c4c:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8222c50:	1007883a 	mov	r3,r2
 8222c54:	e0bfff17 	ldw	r2,-4(fp)
 8222c58:	10c00205 	stb	r3,8(r2)
    pphy->link_capability.cap_100_base_t2_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_HALF, 1);
 8222c5c:	01c00044 	movi	r7,1
 8222c60:	01800244 	movi	r6,9
 8222c64:	01400044 	movi	r5,1
 8222c68:	e13fff17 	ldw	r4,-4(fp)
 8222c6c:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8222c70:	1007883a 	mov	r3,r2
 8222c74:	e0bfff17 	ldw	r2,-4(fp)
 8222c78:	10c00245 	stb	r3,9(r2)
    pphy->link_capability.cap_10_base_t_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 8222c7c:	01c00044 	movi	r7,1
 8222c80:	01800304 	movi	r6,12
 8222c84:	01400044 	movi	r5,1
 8222c88:	e13fff17 	ldw	r4,-4(fp)
 8222c8c:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8222c90:	1007883a 	mov	r3,r2
 8222c94:	e0bfff17 	ldw	r2,-4(fp)
 8222c98:	10c00285 	stb	r3,10(r2)
    pphy->link_capability.cap_10_base_t_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 8222c9c:	01c00044 	movi	r7,1
 8222ca0:	018002c4 	movi	r6,11
 8222ca4:	01400044 	movi	r5,1
 8222ca8:	e13fff17 	ldw	r4,-4(fp)
 8222cac:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8222cb0:	1007883a 	mov	r3,r2
 8222cb4:	e0bfff17 	ldw	r2,-4(fp)
 8222cb8:	10c002c5 	stb	r3,11(r2)
    
    /* get link partner capability */
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
 8222cbc:	01c00044 	movi	r7,1
 8222cc0:	018002c4 	movi	r6,11
 8222cc4:	01400284 	movi	r5,10
 8222cc8:	e13fff17 	ldw	r4,-4(fp)
 8222ccc:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8222cd0:	1007883a 	mov	r3,r2
 8222cd4:	e0bfff17 	ldw	r2,-4(fp)
 8222cd8:	10c00305 	stb	r3,12(r2)
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
 8222cdc:	01c00044 	movi	r7,1
 8222ce0:	01800284 	movi	r6,10
 8222ce4:	01400284 	movi	r5,10
 8222ce8:	e13fff17 	ldw	r4,-4(fp)
 8222cec:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8222cf0:	1007883a 	mov	r3,r2
 8222cf4:	e0bfff17 	ldw	r2,-4(fp)
 8222cf8:	10c00345 	stb	r3,13(r2)
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
 8222cfc:	01c00044 	movi	r7,1
 8222d00:	01800244 	movi	r6,9
 8222d04:	01400144 	movi	r5,5
 8222d08:	e13fff17 	ldw	r4,-4(fp)
 8222d0c:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8222d10:	1007883a 	mov	r3,r2
 8222d14:	e0bfff17 	ldw	r2,-4(fp)
 8222d18:	10c00385 	stb	r3,14(r2)
    pphy->link_capability.lp_100_base_tx_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1);
 8222d1c:	01c00044 	movi	r7,1
 8222d20:	01800204 	movi	r6,8
 8222d24:	01400144 	movi	r5,5
 8222d28:	e13fff17 	ldw	r4,-4(fp)
 8222d2c:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8222d30:	1007883a 	mov	r3,r2
 8222d34:	e0bfff17 	ldw	r2,-4(fp)
 8222d38:	10c003c5 	stb	r3,15(r2)
    pphy->link_capability.lp_100_base_tx_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1);
 8222d3c:	01c00044 	movi	r7,1
 8222d40:	018001c4 	movi	r6,7
 8222d44:	01400144 	movi	r5,5
 8222d48:	e13fff17 	ldw	r4,-4(fp)
 8222d4c:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8222d50:	1007883a 	mov	r3,r2
 8222d54:	e0bfff17 	ldw	r2,-4(fp)
 8222d58:	10c00405 	stb	r3,16(r2)
    pphy->link_capability.lp_10_base_tx_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1);
 8222d5c:	01c00044 	movi	r7,1
 8222d60:	01800184 	movi	r6,6
 8222d64:	01400144 	movi	r5,5
 8222d68:	e13fff17 	ldw	r4,-4(fp)
 8222d6c:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8222d70:	1007883a 	mov	r3,r2
 8222d74:	e0bfff17 	ldw	r2,-4(fp)
 8222d78:	10c00445 	stb	r3,17(r2)
    pphy->link_capability.lp_10_base_tx_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1);
 8222d7c:	01c00044 	movi	r7,1
 8222d80:	01800144 	movi	r6,5
 8222d84:	01400144 	movi	r5,5
 8222d88:	e13fff17 	ldw	r4,-4(fp)
 8222d8c:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8222d90:	1007883a 	mov	r3,r2
 8222d94:	e0bfff17 	ldw	r2,-4(fp)
 8222d98:	10c00485 	stb	r3,18(r2)
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Capability of PHY :\n", mac_group_index, mac_info_index);
 8222d9c:	e0bffe47 	ldb	r2,-7(fp)
 8222da0:	e0fffe07 	ldb	r3,-8(fp)
 8222da4:	180d883a 	mov	r6,r3
 8222da8:	100b883a 	mov	r5,r2
 8222dac:	01020974 	movhi	r4,2085
 8222db0:	213ccd04 	addi	r4,r4,-3276
 8222db4:	821f1840 	call	821f184 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Full Duplex = %d\n", pphy->link_capability.cap_1000_base_x_full);
 8222db8:	e0bfff17 	ldw	r2,-4(fp)
 8222dbc:	10800043 	ldbu	r2,1(r2)
 8222dc0:	10803fcc 	andi	r2,r2,255
 8222dc4:	100b883a 	mov	r5,r2
 8222dc8:	01020974 	movhi	r4,2085
 8222dcc:	213cd804 	addi	r4,r4,-3232
 8222dd0:	821f1840 	call	821f184 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Half Duplex = %d\n", pphy->link_capability.cap_1000_base_x_half);
 8222dd4:	e0bfff17 	ldw	r2,-4(fp)
 8222dd8:	10800083 	ldbu	r2,2(r2)
 8222ddc:	10803fcc 	andi	r2,r2,255
 8222de0:	100b883a 	mov	r5,r2
 8222de4:	01020974 	movhi	r4,2085
 8222de8:	213ce204 	addi	r4,r4,-3192
 8222dec:	821f1840 	call	821f184 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.cap_1000_base_t_full);
 8222df0:	e0bfff17 	ldw	r2,-4(fp)
 8222df4:	108000c3 	ldbu	r2,3(r2)
 8222df8:	10803fcc 	andi	r2,r2,255
 8222dfc:	100b883a 	mov	r5,r2
 8222e00:	01020974 	movhi	r4,2085
 8222e04:	213cec04 	addi	r4,r4,-3152
 8222e08:	821f1840 	call	821f184 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.cap_1000_base_t_half);
 8222e0c:	e0bfff17 	ldw	r2,-4(fp)
 8222e10:	10800103 	ldbu	r2,4(r2)
 8222e14:	10803fcc 	andi	r2,r2,255
 8222e18:	100b883a 	mov	r5,r2
 8222e1c:	01020974 	movhi	r4,2085
 8222e20:	213cf604 	addi	r4,r4,-3112
 8222e24:	821f1840 	call	821f184 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.cap_100_base_t4);
 8222e28:	e0bfff17 	ldw	r2,-4(fp)
 8222e2c:	10800143 	ldbu	r2,5(r2)
 8222e30:	10803fcc 	andi	r2,r2,255
 8222e34:	100b883a 	mov	r5,r2
 8222e38:	01020974 	movhi	r4,2085
 8222e3c:	213d0004 	addi	r4,r4,-3072
 8222e40:	821f1840 	call	821f184 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Full Duplex  = %d\n", pphy->link_capability.cap_100_base_x_full);
 8222e44:	e0bfff17 	ldw	r2,-4(fp)
 8222e48:	10800183 	ldbu	r2,6(r2)
 8222e4c:	10803fcc 	andi	r2,r2,255
 8222e50:	100b883a 	mov	r5,r2
 8222e54:	01020974 	movhi	r4,2085
 8222e58:	213d0a04 	addi	r4,r4,-3032
 8222e5c:	821f1840 	call	821f184 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Half Duplex  = %d\n", pphy->link_capability.cap_100_base_x_half);
 8222e60:	e0bfff17 	ldw	r2,-4(fp)
 8222e64:	108001c3 	ldbu	r2,7(r2)
 8222e68:	10803fcc 	andi	r2,r2,255
 8222e6c:	100b883a 	mov	r5,r2
 8222e70:	01020974 	movhi	r4,2085
 8222e74:	213d1404 	addi	r4,r4,-2992
 8222e78:	821f1840 	call	821f184 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Full Duplex = %d\n", pphy->link_capability.cap_100_base_t2_full);
 8222e7c:	e0bfff17 	ldw	r2,-4(fp)
 8222e80:	10800203 	ldbu	r2,8(r2)
 8222e84:	10803fcc 	andi	r2,r2,255
 8222e88:	100b883a 	mov	r5,r2
 8222e8c:	01020974 	movhi	r4,2085
 8222e90:	213d1e04 	addi	r4,r4,-2952
 8222e94:	821f1840 	call	821f184 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Half Duplex = %d\n", pphy->link_capability.cap_100_base_t2_half);
 8222e98:	e0bfff17 	ldw	r2,-4(fp)
 8222e9c:	10800243 	ldbu	r2,9(r2)
 8222ea0:	10803fcc 	andi	r2,r2,255
 8222ea4:	100b883a 	mov	r5,r2
 8222ea8:	01020974 	movhi	r4,2085
 8222eac:	213d2804 	addi	r4,r4,-2912
 8222eb0:	821f1840 	call	821f184 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Full Duplex   = %d\n", pphy->link_capability.cap_10_base_t_full);
 8222eb4:	e0bfff17 	ldw	r2,-4(fp)
 8222eb8:	10800283 	ldbu	r2,10(r2)
 8222ebc:	10803fcc 	andi	r2,r2,255
 8222ec0:	100b883a 	mov	r5,r2
 8222ec4:	01020974 	movhi	r4,2085
 8222ec8:	213d3204 	addi	r4,r4,-2872
 8222ecc:	821f1840 	call	821f184 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Half Duplex   = %d\n", pphy->link_capability.cap_10_base_t_half);
 8222ed0:	e0bfff17 	ldw	r2,-4(fp)
 8222ed4:	108002c3 	ldbu	r2,11(r2)
 8222ed8:	10803fcc 	andi	r2,r2,255
 8222edc:	100b883a 	mov	r5,r2
 8222ee0:	01020974 	movhi	r4,2085
 8222ee4:	213d3c04 	addi	r4,r4,-2832
 8222ee8:	821f1840 	call	821f184 <no_printf>
    tse_dprintf(6, "\n");
 8222eec:	01020974 	movhi	r4,2085
 8222ef0:	213ba204 	addi	r4,r4,-4472
 8222ef4:	821f1840 	call	821f184 <no_printf>
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Link Partner Capability :\n", mac_group_index, mac_info_index);
 8222ef8:	e0bffe47 	ldb	r2,-7(fp)
 8222efc:	e0fffe07 	ldb	r3,-8(fp)
 8222f00:	180d883a 	mov	r6,r3
 8222f04:	100b883a 	mov	r5,r2
 8222f08:	01020974 	movhi	r4,2085
 8222f0c:	213d4604 	addi	r4,r4,-2792
 8222f10:	821f1840 	call	821f184 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.lp_1000_base_t_full);
 8222f14:	e0bfff17 	ldw	r2,-4(fp)
 8222f18:	10800303 	ldbu	r2,12(r2)
 8222f1c:	10803fcc 	andi	r2,r2,255
 8222f20:	100b883a 	mov	r5,r2
 8222f24:	01020974 	movhi	r4,2085
 8222f28:	213cec04 	addi	r4,r4,-3152
 8222f2c:	821f1840 	call	821f184 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.lp_1000_base_t_half);
 8222f30:	e0bfff17 	ldw	r2,-4(fp)
 8222f34:	10800343 	ldbu	r2,13(r2)
 8222f38:	10803fcc 	andi	r2,r2,255
 8222f3c:	100b883a 	mov	r5,r2
 8222f40:	01020974 	movhi	r4,2085
 8222f44:	213cf604 	addi	r4,r4,-3112
 8222f48:	821f1840 	call	821f184 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.lp_100_base_t4);
 8222f4c:	e0bfff17 	ldw	r2,-4(fp)
 8222f50:	10800383 	ldbu	r2,14(r2)
 8222f54:	10803fcc 	andi	r2,r2,255
 8222f58:	100b883a 	mov	r5,r2
 8222f5c:	01020974 	movhi	r4,2085
 8222f60:	213d0004 	addi	r4,r4,-3072
 8222f64:	821f1840 	call	821f184 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Full Duplex = %d\n", pphy->link_capability.lp_100_base_tx_full);
 8222f68:	e0bfff17 	ldw	r2,-4(fp)
 8222f6c:	108003c3 	ldbu	r2,15(r2)
 8222f70:	10803fcc 	andi	r2,r2,255
 8222f74:	100b883a 	mov	r5,r2
 8222f78:	01020974 	movhi	r4,2085
 8222f7c:	213d5304 	addi	r4,r4,-2740
 8222f80:	821f1840 	call	821f184 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Half Duplex = %d\n", pphy->link_capability.lp_100_base_tx_half);
 8222f84:	e0bfff17 	ldw	r2,-4(fp)
 8222f88:	10800403 	ldbu	r2,16(r2)
 8222f8c:	10803fcc 	andi	r2,r2,255
 8222f90:	100b883a 	mov	r5,r2
 8222f94:	01020974 	movhi	r4,2085
 8222f98:	213d5d04 	addi	r4,r4,-2700
 8222f9c:	821f1840 	call	821f184 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Full Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_full);
 8222fa0:	e0bfff17 	ldw	r2,-4(fp)
 8222fa4:	10800443 	ldbu	r2,17(r2)
 8222fa8:	10803fcc 	andi	r2,r2,255
 8222fac:	100b883a 	mov	r5,r2
 8222fb0:	01020974 	movhi	r4,2085
 8222fb4:	213d6704 	addi	r4,r4,-2660
 8222fb8:	821f1840 	call	821f184 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Half Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_half);
 8222fbc:	e0bfff17 	ldw	r2,-4(fp)
 8222fc0:	10800483 	ldbu	r2,18(r2)
 8222fc4:	10803fcc 	andi	r2,r2,255
 8222fc8:	100b883a 	mov	r5,r2
 8222fcc:	01020974 	movhi	r4,2085
 8222fd0:	213d7104 	addi	r4,r4,-2620
 8222fd4:	821f1840 	call	821f184 <no_printf>
    tse_dprintf(6, "\n");
 8222fd8:	01020974 	movhi	r4,2085
 8222fdc:	213ba204 	addi	r4,r4,-4472
 8222fe0:	821f1840 	call	821f184 <no_printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222fe4:	e0bffe83 	ldbu	r2,-6(fp)
 8222fe8:	100b883a 	mov	r5,r2
 8222fec:	e13fff17 	ldw	r4,-4(fp)
 8222ff0:	82211100 	call	8221110 <alt_tse_phy_wr_mdio_addr>
    
    return return_value;
 8222ff4:	e0bffb17 	ldw	r2,-20(fp)
    
}
 8222ff8:	e037883a 	mov	sp,fp
 8222ffc:	dfc00117 	ldw	ra,4(sp)
 8223000:	df000017 	ldw	fp,0(sp)
 8223004:	dec00204 	addi	sp,sp,8
 8223008:	f800283a 	ret

0822300c <alt_tse_phy_set_adv_1000>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_1000(alt_tse_phy_info *pphy, alt_u8 enable) {
 822300c:	defff804 	addi	sp,sp,-32
 8223010:	dfc00715 	stw	ra,28(sp)
 8223014:	df000615 	stw	fp,24(sp)
 8223018:	df000604 	addi	fp,sp,24
 822301c:	e13ffe15 	stw	r4,-8(fp)
 8223020:	2805883a 	mov	r2,r5
 8223024:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 8223028:	e0bffe17 	ldw	r2,-8(fp)
 822302c:	10800617 	ldw	r2,24(r2)
 8223030:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 8223034:	e0bffb17 	ldw	r2,-20(fp)
 8223038:	10800317 	ldw	r2,12(r2)
 822303c:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8223040:	e13ffb17 	ldw	r4,-20(fp)
 8223044:	822037c0 	call	822037c <alt_tse_get_mac_info_index>
 8223048:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 822304c:	e13ffc17 	ldw	r4,-16(fp)
 8223050:	82203080 	call	8220308 <alt_tse_get_mac_group_index>
 8223054:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 8223058:	e13ffe17 	ldw	r4,-8(fp)
 822305c:	82210c80 	call	82210c8 <alt_tse_phy_rd_mdio_addr>
 8223060:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 8223064:	e0bffe17 	ldw	r2,-8(fp)
 8223068:	10800003 	ldbu	r2,0(r2)
 822306c:	10803fcc 	andi	r2,r2,255
 8223070:	100b883a 	mov	r5,r2
 8223074:	e13ffe17 	ldw	r4,-8(fp)
 8223078:	82211100 	call	8221110 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 822307c:	e0bfff03 	ldbu	r2,-4(fp)
 8223080:	10002d26 	beq	r2,zero,8223138 <alt_tse_phy_set_adv_1000+0x12c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1); 
 8223084:	01c00044 	movi	r7,1
 8223088:	01800344 	movi	r6,13
 822308c:	014003c4 	movi	r5,15
 8223090:	e13ffe17 	ldw	r4,-8(fp)
 8223094:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8223098:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, cap);
 822309c:	e0bffdc3 	ldbu	r2,-9(fp)
 82230a0:	d8800015 	stw	r2,0(sp)
 82230a4:	01c00044 	movi	r7,1
 82230a8:	01800244 	movi	r6,9
 82230ac:	01400244 	movi	r5,9
 82230b0:	e13ffe17 	ldw	r4,-8(fp)
 82230b4:	82211680 	call	8221168 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 82230b8:	e0bffd47 	ldb	r2,-11(fp)
 82230bc:	e0fffd07 	ldb	r3,-12(fp)
 82230c0:	e13ffdc3 	ldbu	r4,-9(fp)
 82230c4:	200f883a 	mov	r7,r4
 82230c8:	180d883a 	mov	r6,r3
 82230cc:	100b883a 	mov	r5,r2
 82230d0:	01020974 	movhi	r4,2085
 82230d4:	213d7b04 	addi	r4,r4,-2580
 82230d8:	821f1840 	call	821f184 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 82230dc:	01c00044 	movi	r7,1
 82230e0:	01800304 	movi	r6,12
 82230e4:	014003c4 	movi	r5,15
 82230e8:	e13ffe17 	ldw	r4,-8(fp)
 82230ec:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 82230f0:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, cap);
 82230f4:	e0bffdc3 	ldbu	r2,-9(fp)
 82230f8:	d8800015 	stw	r2,0(sp)
 82230fc:	01c00044 	movi	r7,1
 8223100:	01800204 	movi	r6,8
 8223104:	01400244 	movi	r5,9
 8223108:	e13ffe17 	ldw	r4,-8(fp)
 822310c:	82211680 	call	8221168 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 8223110:	e0bffd47 	ldb	r2,-11(fp)
 8223114:	e0fffd07 	ldb	r3,-12(fp)
 8223118:	e13ffdc3 	ldbu	r4,-9(fp)
 822311c:	200f883a 	mov	r7,r4
 8223120:	180d883a 	mov	r6,r3
 8223124:	100b883a 	mov	r5,r2
 8223128:	01020974 	movhi	r4,2085
 822312c:	213d8e04 	addi	r4,r4,-2504
 8223130:	821f1840 	call	821f184 <no_printf>
 8223134:	00001c06 	br	82231a8 <alt_tse_phy_set_adv_1000+0x19c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, 0);
 8223138:	d8000015 	stw	zero,0(sp)
 822313c:	01c00044 	movi	r7,1
 8223140:	01800244 	movi	r6,9
 8223144:	01400244 	movi	r5,9
 8223148:	e13ffe17 	ldw	r4,-8(fp)
 822314c:	82211680 	call	8221168 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 8223150:	e0bffd47 	ldb	r2,-11(fp)
 8223154:	e0fffd07 	ldb	r3,-12(fp)
 8223158:	000f883a 	mov	r7,zero
 822315c:	180d883a 	mov	r6,r3
 8223160:	100b883a 	mov	r5,r2
 8223164:	01020974 	movhi	r4,2085
 8223168:	213d7b04 	addi	r4,r4,-2580
 822316c:	821f1840 	call	821f184 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, 0);
 8223170:	d8000015 	stw	zero,0(sp)
 8223174:	01c00044 	movi	r7,1
 8223178:	01800204 	movi	r6,8
 822317c:	01400244 	movi	r5,9
 8223180:	e13ffe17 	ldw	r4,-8(fp)
 8223184:	82211680 	call	8221168 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement 1000 Base-T half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 8223188:	e0bffd47 	ldb	r2,-11(fp)
 822318c:	e0fffd07 	ldb	r3,-12(fp)
 8223190:	000f883a 	mov	r7,zero
 8223194:	180d883a 	mov	r6,r3
 8223198:	100b883a 	mov	r5,r2
 822319c:	01020974 	movhi	r4,2085
 82231a0:	213da104 	addi	r4,r4,-2428
 82231a4:	821f1840 	call	821f184 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);    
 82231a8:	e0bffd83 	ldbu	r2,-10(fp)
 82231ac:	100b883a 	mov	r5,r2
 82231b0:	e13ffe17 	ldw	r4,-8(fp)
 82231b4:	82211100 	call	8221110 <alt_tse_phy_wr_mdio_addr>

    return SUCCESS;
 82231b8:	0005883a 	mov	r2,zero
}
 82231bc:	e037883a 	mov	sp,fp
 82231c0:	dfc00117 	ldw	ra,4(sp)
 82231c4:	df000017 	ldw	fp,0(sp)
 82231c8:	dec00204 	addi	sp,sp,8
 82231cc:	f800283a 	ret

082231d0 <alt_tse_phy_set_adv_100>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_100(alt_tse_phy_info *pphy, alt_u8 enable) {
 82231d0:	defff804 	addi	sp,sp,-32
 82231d4:	dfc00715 	stw	ra,28(sp)
 82231d8:	df000615 	stw	fp,24(sp)
 82231dc:	df000604 	addi	fp,sp,24
 82231e0:	e13ffe15 	stw	r4,-8(fp)
 82231e4:	2805883a 	mov	r2,r5
 82231e8:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 82231ec:	e0bffe17 	ldw	r2,-8(fp)
 82231f0:	10800617 	ldw	r2,24(r2)
 82231f4:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 82231f8:	e0bffb17 	ldw	r2,-20(fp)
 82231fc:	10800317 	ldw	r2,12(r2)
 8223200:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8223204:	e13ffb17 	ldw	r4,-20(fp)
 8223208:	822037c0 	call	822037c <alt_tse_get_mac_info_index>
 822320c:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8223210:	e13ffc17 	ldw	r4,-16(fp)
 8223214:	82203080 	call	8220308 <alt_tse_get_mac_group_index>
 8223218:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 822321c:	e13ffe17 	ldw	r4,-8(fp)
 8223220:	82210c80 	call	82210c8 <alt_tse_phy_rd_mdio_addr>
 8223224:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 8223228:	e0bffe17 	ldw	r2,-8(fp)
 822322c:	10800003 	ldbu	r2,0(r2)
 8223230:	10803fcc 	andi	r2,r2,255
 8223234:	100b883a 	mov	r5,r2
 8223238:	e13ffe17 	ldw	r4,-8(fp)
 822323c:	82211100 	call	8221110 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 8223240:	e0bfff03 	ldbu	r2,-4(fp)
 8223244:	10004326 	beq	r2,zero,8223354 <alt_tse_phy_set_adv_100+0x184>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 8223248:	01c00044 	movi	r7,1
 822324c:	018003c4 	movi	r6,15
 8223250:	01400044 	movi	r5,1
 8223254:	e13ffe17 	ldw	r4,-8(fp)
 8223258:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 822325c:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, cap);
 8223260:	e0bffdc3 	ldbu	r2,-9(fp)
 8223264:	d8800015 	stw	r2,0(sp)
 8223268:	01c00044 	movi	r7,1
 822326c:	01800244 	movi	r6,9
 8223270:	01400104 	movi	r5,4
 8223274:	e13ffe17 	ldw	r4,-8(fp)
 8223278:	82211680 	call	8221168 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, cap);
 822327c:	e0bffd47 	ldb	r2,-11(fp)
 8223280:	e0fffd07 	ldb	r3,-12(fp)
 8223284:	e13ffdc3 	ldbu	r4,-9(fp)
 8223288:	200f883a 	mov	r7,r4
 822328c:	180d883a 	mov	r6,r3
 8223290:	100b883a 	mov	r5,r2
 8223294:	01020974 	movhi	r4,2085
 8223298:	213db304 	addi	r4,r4,-2356
 822329c:	821f1840 	call	821f184 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 82232a0:	01c00044 	movi	r7,1
 82232a4:	01800384 	movi	r6,14
 82232a8:	01400044 	movi	r5,1
 82232ac:	e13ffe17 	ldw	r4,-8(fp)
 82232b0:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 82232b4:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, cap);
 82232b8:	e0bffdc3 	ldbu	r2,-9(fp)
 82232bc:	d8800015 	stw	r2,0(sp)
 82232c0:	01c00044 	movi	r7,1
 82232c4:	01800204 	movi	r6,8
 82232c8:	01400104 	movi	r5,4
 82232cc:	e13ffe17 	ldw	r4,-8(fp)
 82232d0:	82211680 	call	8221168 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 82232d4:	e0bffd47 	ldb	r2,-11(fp)
 82232d8:	e0fffd07 	ldb	r3,-12(fp)
 82232dc:	e13ffdc3 	ldbu	r4,-9(fp)
 82232e0:	200f883a 	mov	r7,r4
 82232e4:	180d883a 	mov	r6,r3
 82232e8:	100b883a 	mov	r5,r2
 82232ec:	01020974 	movhi	r4,2085
 82232f0:	213dc304 	addi	r4,r4,-2292
 82232f4:	821f1840 	call	821f184 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 82232f8:	01c00044 	movi	r7,1
 82232fc:	01800344 	movi	r6,13
 8223300:	01400044 	movi	r5,1
 8223304:	e13ffe17 	ldw	r4,-8(fp)
 8223308:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 822330c:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, cap);
 8223310:	e0bffdc3 	ldbu	r2,-9(fp)
 8223314:	d8800015 	stw	r2,0(sp)
 8223318:	01c00044 	movi	r7,1
 822331c:	018001c4 	movi	r6,7
 8223320:	01400104 	movi	r5,4
 8223324:	e13ffe17 	ldw	r4,-8(fp)
 8223328:	82211680 	call	8221168 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 822332c:	e0bffd47 	ldb	r2,-11(fp)
 8223330:	e0fffd07 	ldb	r3,-12(fp)
 8223334:	e13ffdc3 	ldbu	r4,-9(fp)
 8223338:	200f883a 	mov	r7,r4
 822333c:	180d883a 	mov	r6,r3
 8223340:	100b883a 	mov	r5,r2
 8223344:	01020974 	movhi	r4,2085
 8223348:	213dd604 	addi	r4,r4,-2216
 822334c:	821f1840 	call	821f184 <no_printf>
 8223350:	00002a06 	br	82233fc <alt_tse_phy_set_adv_100+0x22c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, 0);
 8223354:	d8000015 	stw	zero,0(sp)
 8223358:	01c00044 	movi	r7,1
 822335c:	01800244 	movi	r6,9
 8223360:	01400104 	movi	r5,4
 8223364:	e13ffe17 	ldw	r4,-8(fp)
 8223368:	82211680 	call	8221168 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, 0);
 822336c:	e0bffd47 	ldb	r2,-11(fp)
 8223370:	e0fffd07 	ldb	r3,-12(fp)
 8223374:	000f883a 	mov	r7,zero
 8223378:	180d883a 	mov	r6,r3
 822337c:	100b883a 	mov	r5,r2
 8223380:	01020974 	movhi	r4,2085
 8223384:	213db304 	addi	r4,r4,-2356
 8223388:	821f1840 	call	821f184 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, 0);
 822338c:	d8000015 	stw	zero,0(sp)
 8223390:	01c00044 	movi	r7,1
 8223394:	01800204 	movi	r6,8
 8223398:	01400104 	movi	r5,4
 822339c:	e13ffe17 	ldw	r4,-8(fp)
 82233a0:	82211680 	call	8221168 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 82233a4:	e0bffd47 	ldb	r2,-11(fp)
 82233a8:	e0fffd07 	ldb	r3,-12(fp)
 82233ac:	000f883a 	mov	r7,zero
 82233b0:	180d883a 	mov	r6,r3
 82233b4:	100b883a 	mov	r5,r2
 82233b8:	01020974 	movhi	r4,2085
 82233bc:	213dc304 	addi	r4,r4,-2292
 82233c0:	821f1840 	call	821f184 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, 0);
 82233c4:	d8000015 	stw	zero,0(sp)
 82233c8:	01c00044 	movi	r7,1
 82233cc:	018001c4 	movi	r6,7
 82233d0:	01400104 	movi	r5,4
 82233d4:	e13ffe17 	ldw	r4,-8(fp)
 82233d8:	82211680 	call	8221168 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 82233dc:	e0bffd47 	ldb	r2,-11(fp)
 82233e0:	e0fffd07 	ldb	r3,-12(fp)
 82233e4:	000f883a 	mov	r7,zero
 82233e8:	180d883a 	mov	r6,r3
 82233ec:	100b883a 	mov	r5,r2
 82233f0:	01020974 	movhi	r4,2085
 82233f4:	213dd604 	addi	r4,r4,-2216
 82233f8:	821f1840 	call	821f184 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);  
 82233fc:	e0bffd83 	ldbu	r2,-10(fp)
 8223400:	100b883a 	mov	r5,r2
 8223404:	e13ffe17 	ldw	r4,-8(fp)
 8223408:	82211100 	call	8221110 <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 822340c:	0005883a 	mov	r2,zero
}
 8223410:	e037883a 	mov	sp,fp
 8223414:	dfc00117 	ldw	ra,4(sp)
 8223418:	df000017 	ldw	fp,0(sp)
 822341c:	dec00204 	addi	sp,sp,8
 8223420:	f800283a 	ret

08223424 <alt_tse_phy_set_adv_10>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_10(alt_tse_phy_info *pphy, alt_u8 enable) {
 8223424:	defff504 	addi	sp,sp,-44
 8223428:	dfc00a15 	stw	ra,40(sp)
 822342c:	df000915 	stw	fp,36(sp)
 8223430:	df000904 	addi	fp,sp,36
 8223434:	e13ffe15 	stw	r4,-8(fp)
 8223438:	2805883a 	mov	r2,r5
 822343c:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 8223440:	e0bffe17 	ldw	r2,-8(fp)
 8223444:	10800617 	ldw	r2,24(r2)
 8223448:	e0bff815 	stw	r2,-32(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 822344c:	e0bff817 	ldw	r2,-32(fp)
 8223450:	10800317 	ldw	r2,12(r2)
 8223454:	e0bff915 	stw	r2,-28(fp)
    
    /* get index of the pointers in pointer array list */
    int mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8223458:	e13ff817 	ldw	r4,-32(fp)
 822345c:	822037c0 	call	822037c <alt_tse_get_mac_info_index>
 8223460:	e0bffa15 	stw	r2,-24(fp)
    int mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8223464:	e13ff917 	ldw	r4,-28(fp)
 8223468:	82203080 	call	8220308 <alt_tse_get_mac_group_index>
 822346c:	e0bffb15 	stw	r2,-20(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    int mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 8223470:	e13ffe17 	ldw	r4,-8(fp)
 8223474:	82210c80 	call	82210c8 <alt_tse_phy_rd_mdio_addr>
 8223478:	e0bffc15 	stw	r2,-16(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 822347c:	e0bffe17 	ldw	r2,-8(fp)
 8223480:	10800003 	ldbu	r2,0(r2)
 8223484:	10803fcc 	andi	r2,r2,255
 8223488:	100b883a 	mov	r5,r2
 822348c:	e13ffe17 	ldw	r4,-8(fp)
 8223490:	82211100 	call	8221110 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 8223494:	e0bfff03 	ldbu	r2,-4(fp)
 8223498:	10002926 	beq	r2,zero,8223540 <alt_tse_phy_set_adv_10+0x11c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 822349c:	01c00044 	movi	r7,1
 82234a0:	01800304 	movi	r6,12
 82234a4:	01400044 	movi	r5,1
 82234a8:	e13ffe17 	ldw	r4,-8(fp)
 82234ac:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 82234b0:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, cap);
 82234b4:	e0bffd03 	ldbu	r2,-12(fp)
 82234b8:	d8800015 	stw	r2,0(sp)
 82234bc:	01c00044 	movi	r7,1
 82234c0:	01800184 	movi	r6,6
 82234c4:	01400104 	movi	r5,4
 82234c8:	e13ffe17 	ldw	r4,-8(fp)
 82234cc:	82211680 	call	8221168 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 82234d0:	e0bffd03 	ldbu	r2,-12(fp)
 82234d4:	100f883a 	mov	r7,r2
 82234d8:	e1bffa17 	ldw	r6,-24(fp)
 82234dc:	e17ffb17 	ldw	r5,-20(fp)
 82234e0:	01020974 	movhi	r4,2085
 82234e4:	213de904 	addi	r4,r4,-2140
 82234e8:	821f1840 	call	821f184 <no_printf>
    
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 82234ec:	01c00044 	movi	r7,1
 82234f0:	018002c4 	movi	r6,11
 82234f4:	01400044 	movi	r5,1
 82234f8:	e13ffe17 	ldw	r4,-8(fp)
 82234fc:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8223500:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, cap);
 8223504:	e0bffd03 	ldbu	r2,-12(fp)
 8223508:	d8800015 	stw	r2,0(sp)
 822350c:	01c00044 	movi	r7,1
 8223510:	01800144 	movi	r6,5
 8223514:	01400104 	movi	r5,4
 8223518:	e13ffe17 	ldw	r4,-8(fp)
 822351c:	82211680 	call	8221168 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 8223520:	e0bffd03 	ldbu	r2,-12(fp)
 8223524:	100f883a 	mov	r7,r2
 8223528:	e1bffa17 	ldw	r6,-24(fp)
 822352c:	e17ffb17 	ldw	r5,-20(fp)
 8223530:	01020974 	movhi	r4,2085
 8223534:	213dfc04 	addi	r4,r4,-2064
 8223538:	821f1840 	call	821f184 <no_printf>
 822353c:	00001806 	br	82235a0 <alt_tse_phy_set_adv_10+0x17c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, 0);
 8223540:	d8000015 	stw	zero,0(sp)
 8223544:	01c00044 	movi	r7,1
 8223548:	01800184 	movi	r6,6
 822354c:	01400104 	movi	r5,4
 8223550:	e13ffe17 	ldw	r4,-8(fp)
 8223554:	82211680 	call	8221168 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 8223558:	000f883a 	mov	r7,zero
 822355c:	e1bffa17 	ldw	r6,-24(fp)
 8223560:	e17ffb17 	ldw	r5,-20(fp)
 8223564:	01020974 	movhi	r4,2085
 8223568:	213de904 	addi	r4,r4,-2140
 822356c:	821f1840 	call	821f184 <no_printf>
    
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, 0);
 8223570:	d8000015 	stw	zero,0(sp)
 8223574:	01c00044 	movi	r7,1
 8223578:	01800144 	movi	r6,5
 822357c:	01400104 	movi	r5,4
 8223580:	e13ffe17 	ldw	r4,-8(fp)
 8223584:	82211680 	call	8221168 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 8223588:	000f883a 	mov	r7,zero
 822358c:	e1bffa17 	ldw	r6,-24(fp)
 8223590:	e17ffb17 	ldw	r5,-20(fp)
 8223594:	01020974 	movhi	r4,2085
 8223598:	213dfc04 	addi	r4,r4,-2064
 822359c:	821f1840 	call	821f184 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 82235a0:	e0bffc17 	ldw	r2,-16(fp)
 82235a4:	10803fcc 	andi	r2,r2,255
 82235a8:	100b883a 	mov	r5,r2
 82235ac:	e13ffe17 	ldw	r4,-8(fp)
 82235b0:	82211100 	call	8221110 <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 82235b4:	0005883a 	mov	r2,zero
}
 82235b8:	e037883a 	mov	sp,fp
 82235bc:	dfc00117 	ldw	ra,4(sp)
 82235c0:	df000017 	ldw	fp,0(sp)
 82235c4:	dec00204 	addi	sp,sp,8
 82235c8:	f800283a 	ret

082235cc <alt_tse_phy_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Internal
 * @param pmac_group    Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_phy_get_common_speed(alt_tse_mac_group *pmac_group) {
 82235cc:	defff604 	addi	sp,sp,-40
 82235d0:	dfc00915 	stw	ra,36(sp)
 82235d4:	df000815 	stw	fp,32(sp)
 82235d8:	df000804 	addi	fp,sp,32
 82235dc:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 i;
	alt_u8 common_1000 = 1;
 82235e0:	00800044 	movi	r2,1
 82235e4:	e0bff905 	stb	r2,-28(fp)
	alt_u8 common_100 = 1;
 82235e8:	00800044 	movi	r2,1
 82235ec:	e0bff945 	stb	r2,-27(fp)
	alt_u8 common_10 = 1;
 82235f0:	00800044 	movi	r2,1
 82235f4:	e0bff985 	stb	r2,-26(fp)
    
	alt_32 common_speed;
    
	alt_u8 none_an_complete = 1;
 82235f8:	00800044 	movi	r2,1
 82235fc:	e0bffb05 	stb	r2,-20(fp)
    
    alt_tse_mac_info *pmac_info = 0;
 8223600:	e03ffc15 	stw	zero,-16(fp)
    alt_tse_phy_info *pphy = 0;
 8223604:	e03ffd15 	stw	zero,-12(fp)
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8223608:	e13fff17 	ldw	r4,-4(fp)
 822360c:	82203080 	call	8220308 <alt_tse_get_mac_group_index>
 8223610:	e0bffe05 	stb	r2,-8(fp)
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 8223614:	e03ff815 	stw	zero,-32(fp)
 8223618:	00001c06 	br	822368c <alt_tse_phy_get_common_speed+0xc0>
        pmac_info = pmac_group->pmac_info[i];
 822361c:	e0ffff17 	ldw	r3,-4(fp)
 8223620:	e0bff817 	ldw	r2,-32(fp)
 8223624:	10800044 	addi	r2,r2,1
 8223628:	1085883a 	add	r2,r2,r2
 822362c:	1085883a 	add	r2,r2,r2
 8223630:	1885883a 	add	r2,r3,r2
 8223634:	10800017 	ldw	r2,0(r2)
 8223638:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
 822363c:	e0bffc17 	ldw	r2,-16(fp)
 8223640:	10800117 	ldw	r2,4(r2)
 8223644:	e0bffd15 	stw	r2,-12(fp)
        
        /* run only if PHY connected */
        if(pphy) {
 8223648:	e0bffd17 	ldw	r2,-12(fp)
 822364c:	10000926 	beq	r2,zero,8223674 <alt_tse_phy_get_common_speed+0xa8>
            alt_tse_phy_set_adv_1000(pphy, 1);
 8223650:	01400044 	movi	r5,1
 8223654:	e13ffd17 	ldw	r4,-12(fp)
 8223658:	822300c0 	call	822300c <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 822365c:	01400044 	movi	r5,1
 8223660:	e13ffd17 	ldw	r4,-12(fp)
 8223664:	82231d00 	call	82231d0 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 8223668:	01400044 	movi	r5,1
 822366c:	e13ffd17 	ldw	r4,-12(fp)
 8223670:	82234240 	call	8223424 <alt_tse_phy_set_adv_10>
        }
        tse_dprintf(6, "\n");
 8223674:	01020974 	movhi	r4,2085
 8223678:	213ba204 	addi	r4,r4,-4472
 822367c:	821f1840 	call	821f184 <no_printf>
    alt_tse_phy_info *pphy = 0;
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 8223680:	e0bff817 	ldw	r2,-32(fp)
 8223684:	10800044 	addi	r2,r2,1
 8223688:	e0bff815 	stw	r2,-32(fp)
 822368c:	e0bfff17 	ldw	r2,-4(fp)
 8223690:	10800003 	ldbu	r2,0(r2)
 8223694:	10803fcc 	andi	r2,r2,255
 8223698:	e0fff817 	ldw	r3,-32(fp)
 822369c:	18bfdf16 	blt	r3,r2,822361c <alt_tse_phy_get_common_speed+0x50>
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 82236a0:	e03ff815 	stw	zero,-32(fp)
 82236a4:	00005606 	br	8223800 <alt_tse_phy_get_common_speed+0x234>

        pmac_info = pmac_group->pmac_info[i];
 82236a8:	e0ffff17 	ldw	r3,-4(fp)
 82236ac:	e0bff817 	ldw	r2,-32(fp)
 82236b0:	10800044 	addi	r2,r2,1
 82236b4:	1085883a 	add	r2,r2,r2
 82236b8:	1085883a 	add	r2,r2,r2
 82236bc:	1885883a 	add	r2,r3,r2
 82236c0:	10800017 	ldw	r2,0(r2)
 82236c4:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
 82236c8:	e0bffc17 	ldw	r2,-16(fp)
 82236cc:	10800117 	ldw	r2,4(r2)
 82236d0:	e0bffd15 	stw	r2,-12(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 82236d4:	e0bffd17 	ldw	r2,-12(fp)
 82236d8:	10004326 	beq	r2,zero,82237e8 <alt_tse_phy_get_common_speed+0x21c>
            continue;
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
 82236dc:	e13ffd17 	ldw	r4,-12(fp)
 82236e0:	8222a740 	call	8222a74 <alt_tse_phy_get_cap>
 82236e4:	1000421e 	bne	r2,zero,82237f0 <alt_tse_phy_get_common_speed+0x224>
            continue;
        }
        
        none_an_complete = 0;
 82236e8:	e03ffb05 	stb	zero,-20(fp)
        
        /* Small MAC */
        if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 82236ec:	e0bffc17 	ldw	r2,-16(fp)
 82236f0:	10800003 	ldbu	r2,0(r2)
 82236f4:	10803fcc 	andi	r2,r2,255
 82236f8:	10800058 	cmpnei	r2,r2,1
 82236fc:	1000021e 	bne	r2,zero,8223708 <alt_tse_phy_get_common_speed+0x13c>
            common_1000 = 0;
 8223700:	e03ff905 	stb	zero,-28(fp)
 8223704:	00000706 	br	8223724 <alt_tse_phy_get_common_speed+0x158>
        }
        else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 8223708:	e0bffc17 	ldw	r2,-16(fp)
 822370c:	10800003 	ldbu	r2,0(r2)
 8223710:	10803fcc 	andi	r2,r2,255
 8223714:	10800098 	cmpnei	r2,r2,2
 8223718:	1000021e 	bne	r2,zero,8223724 <alt_tse_phy_get_common_speed+0x158>
            common_100 = 0;
 822371c:	e03ff945 	stb	zero,-27(fp)
            common_10 = 0;            
 8223720:	e03ff985 	stb	zero,-26(fp)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
 8223724:	e0bffd17 	ldw	r2,-12(fp)
 8223728:	10c000c3 	ldbu	r3,3(r2)
 822372c:	e0bffd17 	ldw	r2,-12(fp)
 8223730:	10800303 	ldbu	r2,12(r2)
 8223734:	1884703a 	and	r2,r3,r2
 8223738:	1007883a 	mov	r3,r2
 822373c:	e0bff903 	ldbu	r2,-28(fp)
 8223740:	1884703a 	and	r2,r3,r2
 8223744:	e0bff905 	stb	r2,-28(fp)
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 8223748:	e0bffd17 	ldw	r2,-12(fp)
 822374c:	10c00183 	ldbu	r3,6(r2)
 8223750:	e0bffd17 	ldw	r2,-12(fp)
 8223754:	108003c3 	ldbu	r2,15(r2)
 8223758:	1884703a 	and	r2,r3,r2
 822375c:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
 8223760:	e0bffd17 	ldw	r2,-12(fp)
 8223764:	10c001c3 	ldbu	r3,7(r2)
 8223768:	e0bffd17 	ldw	r2,-12(fp)
 822376c:	10800403 	ldbu	r2,16(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 8223770:	1884703a 	and	r2,r3,r2
 8223774:	2084b03a 	or	r2,r4,r2
 8223778:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
 822377c:	e0bffd17 	ldw	r2,-12(fp)
 8223780:	10c00143 	ldbu	r3,5(r2)
 8223784:	e0bffd17 	ldw	r2,-12(fp)
 8223788:	10800383 	ldbu	r2,14(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 822378c:	1884703a 	and	r2,r3,r2
 8223790:	2084b03a 	or	r2,r4,r2
 8223794:	1007883a 	mov	r3,r2
 8223798:	e0bff943 	ldbu	r2,-27(fp)
 822379c:	1884703a 	and	r2,r3,r2
 82237a0:	e0bff945 	stb	r2,-27(fp)
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
 82237a4:	e0bffd17 	ldw	r2,-12(fp)
 82237a8:	10c00283 	ldbu	r3,10(r2)
 82237ac:	e0bffd17 	ldw	r2,-12(fp)
 82237b0:	10800443 	ldbu	r2,17(r2)
 82237b4:	1884703a 	and	r2,r3,r2
 82237b8:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));
 82237bc:	e0bffd17 	ldw	r2,-12(fp)
 82237c0:	10c002c3 	ldbu	r3,11(r2)
 82237c4:	e0bffd17 	ldw	r2,-12(fp)
 82237c8:	10800483 	ldbu	r2,18(r2)
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
 82237cc:	1884703a 	and	r2,r3,r2
 82237d0:	2084b03a 	or	r2,r4,r2
 82237d4:	1007883a 	mov	r3,r2
 82237d8:	e0bff983 	ldbu	r2,-26(fp)
 82237dc:	1884703a 	and	r2,r3,r2
 82237e0:	e0bff985 	stb	r2,-26(fp)
 82237e4:	00000306 	br	82237f4 <alt_tse_phy_get_common_speed+0x228>
        pmac_info = pmac_group->pmac_info[i];
        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
 82237e8:	0001883a 	nop
 82237ec:	00000106 	br	82237f4 <alt_tse_phy_get_common_speed+0x228>
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
            continue;
 82237f0:	0001883a 	nop
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 82237f4:	e0bff817 	ldw	r2,-32(fp)
 82237f8:	10800044 	addi	r2,r2,1
 82237fc:	e0bff815 	stw	r2,-32(fp)
 8223800:	e0bfff17 	ldw	r2,-4(fp)
 8223804:	10800003 	ldbu	r2,0(r2)
 8223808:	10803fcc 	andi	r2,r2,255
 822380c:	e0fff817 	ldw	r3,-32(fp)
 8223810:	18bfa516 	blt	r3,r2,82236a8 <alt_tse_phy_get_common_speed+0xdc>
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));

    }
    
    /* get common speed based on capabilities */
    if(none_an_complete == 1) {
 8223814:	e0bffb03 	ldbu	r2,-20(fp)
 8223818:	10800058 	cmpnei	r2,r2,1
 822381c:	1000081e 	bne	r2,zero,8223840 <alt_tse_phy_get_common_speed+0x274>
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 8223820:	00bfffc4 	movi	r2,-1
 8223824:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - None of the PHYs Auto-Negotiation completed!\n", mac_group_index);
 8223828:	e0bffe07 	ldb	r2,-8(fp)
 822382c:	100b883a 	mov	r5,r2
 8223830:	01020974 	movhi	r4,2085
 8223834:	213e0f04 	addi	r4,r4,-1988
 8223838:	82033a00 	call	82033a0 <printf>
 822383c:	00002706 	br	82238dc <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_1000) {
 8223840:	e0bff903 	ldbu	r2,-28(fp)
 8223844:	10000926 	beq	r2,zero,822386c <alt_tse_phy_get_common_speed+0x2a0>
        common_speed = TSE_PHY_SPEED_1000;
 8223848:	00800084 	movi	r2,2
 822384c:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 1000);
 8223850:	e0bffe07 	ldb	r2,-8(fp)
 8223854:	0180fa04 	movi	r6,1000
 8223858:	100b883a 	mov	r5,r2
 822385c:	01020974 	movhi	r4,2085
 8223860:	213e2104 	addi	r4,r4,-1916
 8223864:	82033a00 	call	82033a0 <printf>
 8223868:	00001c06 	br	82238dc <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_100) {
 822386c:	e0bff943 	ldbu	r2,-27(fp)
 8223870:	10000926 	beq	r2,zero,8223898 <alt_tse_phy_get_common_speed+0x2cc>
        common_speed = TSE_PHY_SPEED_100;
 8223874:	00800044 	movi	r2,1
 8223878:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 100);
 822387c:	e0bffe07 	ldb	r2,-8(fp)
 8223880:	01801904 	movi	r6,100
 8223884:	100b883a 	mov	r5,r2
 8223888:	01020974 	movhi	r4,2085
 822388c:	213e2104 	addi	r4,r4,-1916
 8223890:	82033a00 	call	82033a0 <printf>
 8223894:	00001106 	br	82238dc <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_10) {
 8223898:	e0bff983 	ldbu	r2,-26(fp)
 822389c:	10000826 	beq	r2,zero,82238c0 <alt_tse_phy_get_common_speed+0x2f4>
        common_speed = TSE_PHY_SPEED_10;
 82238a0:	e03ffa15 	stw	zero,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 10);
 82238a4:	e0bffe07 	ldb	r2,-8(fp)
 82238a8:	01800284 	movi	r6,10
 82238ac:	100b883a 	mov	r5,r2
 82238b0:	01020974 	movhi	r4,2085
 82238b4:	213e2104 	addi	r4,r4,-1916
 82238b8:	82033a00 	call	82033a0 <printf>
 82238bc:	00000706 	br	82238dc <alt_tse_phy_get_common_speed+0x310>
    }
    else {
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 82238c0:	00bfffc4 	movi	r2,-1
 82238c4:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - No common speed at all!\n", mac_group_index);    }
 82238c8:	e0bffe07 	ldb	r2,-8(fp)
 82238cc:	100b883a 	mov	r5,r2
 82238d0:	01020974 	movhi	r4,2085
 82238d4:	213e2e04 	addi	r4,r4,-1864
 82238d8:	82033a00 	call	82033a0 <printf>

    return common_speed;
 82238dc:	e0bffa17 	ldw	r2,-24(fp)
}
 82238e0:	e037883a 	mov	sp,fp
 82238e4:	dfc00117 	ldw	ra,4(sp)
 82238e8:	df000017 	ldw	fp,0(sp)
 82238ec:	dec00204 	addi	sp,sp,8
 82238f0:	f800283a 	ret

082238f4 <alt_tse_phy_set_common_speed>:
 * @API Type:               Internal
 * @param pmac_group        Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 *        common_speed      common speed supported by all PHYs
 * @return      common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_phy_set_common_speed(alt_tse_mac_group *pmac_group, alt_32 common_speed) {
 82238f4:	defff004 	addi	sp,sp,-64
 82238f8:	dfc00f15 	stw	ra,60(sp)
 82238fc:	df000e15 	stw	fp,56(sp)
 8223900:	dc400d15 	stw	r17,52(sp)
 8223904:	dc000c15 	stw	r16,48(sp)
 8223908:	df000e04 	addi	fp,sp,56
 822390c:	e13ffc15 	stw	r4,-16(fp)
 8223910:	e17ffd15 	stw	r5,-12(fp)
	alt_u8 speed;
	alt_u8 duplex;
    
	alt_u8 gb_capable;
    
    alt_tse_phy_info *pphy = 0;
 8223914:	e03ff515 	stw	zero,-44(fp)
    alt_tse_mac_info *pmac_info = 0;
 8223918:	e03ff615 	stw	zero,-40(fp)
    alt_tse_system_info *psys = 0;
 822391c:	e03ff715 	stw	zero,-36(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 8223920:	e03ff805 	stb	zero,-32(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8223924:	e13ffc17 	ldw	r4,-16(fp)
 8223928:	82203080 	call	8220308 <alt_tse_get_mac_group_index>
 822392c:	e0bff845 	stb	r2,-31(fp)
         
    /* Record previous MDIO address, to be restored at the end of function */
    np_tse_mac *pmac_group_base = (np_tse_mac *)pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8223930:	e0bffc17 	ldw	r2,-16(fp)
 8223934:	10800117 	ldw	r2,4(r2)
 8223938:	10800217 	ldw	r2,8(r2)
 822393c:	10800017 	ldw	r2,0(r2)
 8223940:	e0bff915 	stw	r2,-28(fp)
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 8223944:	e0bff917 	ldw	r2,-28(fp)
 8223948:	10801004 	addi	r2,r2,64
 822394c:	10800037 	ldwio	r2,0(r2)
 8223950:	e0bffa15 	stw	r2,-24(fp)
    
    if((common_speed < TSE_PHY_SPEED_10) || (common_speed > TSE_PHY_SPEED_1000)) {
 8223954:	e0bffd17 	ldw	r2,-12(fp)
 8223958:	10000316 	blt	r2,zero,8223968 <alt_tse_phy_set_common_speed+0x74>
 822395c:	e0bffd17 	ldw	r2,-12(fp)
 8223960:	108000d0 	cmplti	r2,r2,3
 8223964:	10000c1e 	bne	r2,zero,8223998 <alt_tse_phy_set_common_speed+0xa4>
        tse_dprintf(2, "ERROR   : MAC Group[%d] - Invalid common speed specified! common speed = %d\n", mac_group_index, (int)common_speed);
 8223968:	e0bff847 	ldb	r2,-31(fp)
 822396c:	e1bffd17 	ldw	r6,-12(fp)
 8223970:	100b883a 	mov	r5,r2
 8223974:	01020974 	movhi	r4,2085
 8223978:	213e3b04 	addi	r4,r4,-1812
 822397c:	82033a00 	call	82033a0 <printf>
		/* Restore previous MDIO address */
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 8223980:	e0bff917 	ldw	r2,-28(fp)
 8223984:	10801004 	addi	r2,r2,64
 8223988:	e0fffa17 	ldw	r3,-24(fp)
 822398c:	10c00035 	stwio	r3,0(r2)
        return TSE_PHY_SPEED_NO_COMMON;
 8223990:	00bfffc4 	movi	r2,-1
 8223994:	0000fe06 	br	8223d90 <alt_tse_phy_set_common_speed+0x49c>
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 8223998:	e03ff315 	stw	zero,-52(fp)
 822399c:	0000dc06 	br	8223d10 <alt_tse_phy_set_common_speed+0x41c>
        pmac_info = pmac_group->pmac_info[i];
 82239a0:	e0fffc17 	ldw	r3,-16(fp)
 82239a4:	e0bff317 	ldw	r2,-52(fp)
 82239a8:	10800044 	addi	r2,r2,1
 82239ac:	1085883a 	add	r2,r2,r2
 82239b0:	1085883a 	add	r2,r2,r2
 82239b4:	1885883a 	add	r2,r3,r2
 82239b8:	10800017 	ldw	r2,0(r2)
 82239bc:	e0bff615 	stw	r2,-40(fp)
        mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 82239c0:	e13ff617 	ldw	r4,-40(fp)
 82239c4:	822037c0 	call	822037c <alt_tse_get_mac_info_index>
 82239c8:	e0bff805 	stb	r2,-32(fp)

        pphy = pmac_info->pphy_info;
 82239cc:	e0bff617 	ldw	r2,-40(fp)
 82239d0:	10800117 	ldw	r2,4(r2)
 82239d4:	e0bff515 	stw	r2,-44(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 82239d8:	e0bff517 	ldw	r2,-44(fp)
 82239dc:	1000c826 	beq	r2,zero,8223d00 <alt_tse_phy_set_common_speed+0x40c>
            continue;
        }
        
        psys = pmac_info->psys_info; 
 82239e0:	e0bff617 	ldw	r2,-40(fp)
 82239e4:	10800217 	ldw	r2,8(r2)
 82239e8:	e0bff715 	stw	r2,-36(fp)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 82239ec:	e0bff517 	ldw	r2,-44(fp)
 82239f0:	10800003 	ldbu	r2,0(r2)
 82239f4:	10803fcc 	andi	r2,r2,255
 82239f8:	100b883a 	mov	r5,r2
 82239fc:	e13ff517 	ldw	r4,-44(fp)
 8223a00:	82211100 	call	8221110 <alt_tse_phy_wr_mdio_addr>

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 8223a04:	e0bff517 	ldw	r2,-44(fp)
 8223a08:	108000c3 	ldbu	r2,3(r2)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 8223a0c:	10803fcc 	andi	r2,r2,255
 8223a10:	10000c1e 	bne	r2,zero,8223a44 <alt_tse_phy_set_common_speed+0x150>
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 8223a14:	e0bff517 	ldw	r2,-44(fp)
 8223a18:	10800103 	ldbu	r2,4(r2)
 8223a1c:	10803fcc 	andi	r2,r2,255
 8223a20:	1000081e 	bne	r2,zero,8223a44 <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 8223a24:	e0bff517 	ldw	r2,-44(fp)
 8223a28:	10800043 	ldbu	r2,1(r2)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 8223a2c:	10803fcc 	andi	r2,r2,255
 8223a30:	1000041e 	bne	r2,zero,8223a44 <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 8223a34:	e0bff517 	ldw	r2,-44(fp)
 8223a38:	10800083 	ldbu	r2,2(r2)
 8223a3c:	10803fcc 	andi	r2,r2,255
 8223a40:	10000226 	beq	r2,zero,8223a4c <alt_tse_phy_set_common_speed+0x158>
 8223a44:	00800044 	movi	r2,1
 8223a48:	00000106 	br	8223a50 <alt_tse_phy_set_common_speed+0x15c>
 8223a4c:	0005883a 	mov	r2,zero
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 8223a50:	e0bffb05 	stb	r2,-20(fp)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
        
        /* if PHY does not supports 1000 Mbps, and common speed is 1000 Mbps */
        if((!gb_capable) && (common_speed == TSE_PHY_SPEED_1000)) {
 8223a54:	e0bffb03 	ldbu	r2,-20(fp)
 8223a58:	1000101e 	bne	r2,zero,8223a9c <alt_tse_phy_set_common_speed+0x1a8>
 8223a5c:	e0bffd17 	ldw	r2,-12(fp)
 8223a60:	10800098 	cmpnei	r2,r2,2
 8223a64:	10000d1e 	bne	r2,zero,8223a9c <alt_tse_phy_set_common_speed+0x1a8>
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - PHY does not support 1000 Mbps, please specify valid common speed\n", mac_group_index, mac_info_index);
 8223a68:	e0bff847 	ldb	r2,-31(fp)
 8223a6c:	e0fff807 	ldb	r3,-32(fp)
 8223a70:	180d883a 	mov	r6,r3
 8223a74:	100b883a 	mov	r5,r2
 8223a78:	01020974 	movhi	r4,2085
 8223a7c:	213e4f04 	addi	r4,r4,-1732
 8223a80:	82033a00 	call	82033a0 <printf>
			/* Restore previous MDIO address */
			IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 8223a84:	e0bff917 	ldw	r2,-28(fp)
 8223a88:	10801004 	addi	r2,r2,64
 8223a8c:	e0fffa17 	ldw	r3,-24(fp)
 8223a90:	10c00035 	stwio	r3,0(r2)
            return TSE_PHY_SPEED_NO_COMMON;
 8223a94:	00bfffc4 	movi	r2,-1
 8223a98:	0000bd06 	br	8223d90 <alt_tse_phy_set_common_speed+0x49c>
        }
        
        /* if PHY is not Auto-Negotiation capable */
        if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 8223a9c:	01c00044 	movi	r7,1
 8223aa0:	018000c4 	movi	r6,3
 8223aa4:	01400044 	movi	r5,1
 8223aa8:	e13ff517 	ldw	r4,-44(fp)
 8223aac:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8223ab0:	1000141e 	bne	r2,zero,8223b04 <alt_tse_phy_set_common_speed+0x210>
            
            /* if PHY supports 1000 Mbps, write msb of speed */
            if(gb_capable) {
 8223ab4:	e0bffb03 	ldbu	r2,-20(fp)
 8223ab8:	10000926 	beq	r2,zero,8223ae0 <alt_tse_phy_set_common_speed+0x1ec>
                alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_MSB, 1, common_speed >> 1);
 8223abc:	e0bffd17 	ldw	r2,-12(fp)
 8223ac0:	1005d07a 	srai	r2,r2,1
 8223ac4:	10bfffcc 	andi	r2,r2,65535
 8223ac8:	d8800015 	stw	r2,0(sp)
 8223acc:	01c00044 	movi	r7,1
 8223ad0:	01800184 	movi	r6,6
 8223ad4:	000b883a 	mov	r5,zero
 8223ad8:	e13ff517 	ldw	r4,-44(fp)
 8223adc:	82211680 	call	8221168 <alt_tse_phy_wr_mdio_reg>
            }
            /* write lsb of speed */
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_LSB, 1, common_speed);
 8223ae0:	e0bffd17 	ldw	r2,-12(fp)
 8223ae4:	10bfffcc 	andi	r2,r2,65535
 8223ae8:	d8800015 	stw	r2,0(sp)
 8223aec:	01c00044 	movi	r7,1
 8223af0:	01800344 	movi	r6,13
 8223af4:	000b883a 	mov	r5,zero
 8223af8:	e13ff517 	ldw	r4,-44(fp)
 8223afc:	82211680 	call	8221168 <alt_tse_phy_wr_mdio_reg>
            
            /* continue to next PHY */
            continue;
 8223b00:	00008006 	br	8223d04 <alt_tse_phy_set_common_speed+0x410>
        }
        
        /* set Auto-Negotiation advertisement based on common speed */
        if(common_speed == TSE_PHY_SPEED_1000) {
 8223b04:	e0bffd17 	ldw	r2,-12(fp)
 8223b08:	10800098 	cmpnei	r2,r2,2
 8223b0c:	10000a1e 	bne	r2,zero,8223b38 <alt_tse_phy_set_common_speed+0x244>
            alt_tse_phy_set_adv_1000(pphy, 1);
 8223b10:	01400044 	movi	r5,1
 8223b14:	e13ff517 	ldw	r4,-44(fp)
 8223b18:	822300c0 	call	822300c <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 8223b1c:	01400044 	movi	r5,1
 8223b20:	e13ff517 	ldw	r4,-44(fp)
 8223b24:	82231d00 	call	82231d0 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 8223b28:	01400044 	movi	r5,1
 8223b2c:	e13ff517 	ldw	r4,-44(fp)
 8223b30:	82234240 	call	8223424 <alt_tse_phy_set_adv_10>
 8223b34:	00002206 	br	8223bc0 <alt_tse_phy_set_common_speed+0x2cc>
        }
        else if(common_speed == TSE_PHY_SPEED_100) {
 8223b38:	e0bffd17 	ldw	r2,-12(fp)
 8223b3c:	10800058 	cmpnei	r2,r2,1
 8223b40:	10000a1e 	bne	r2,zero,8223b6c <alt_tse_phy_set_common_speed+0x278>
            alt_tse_phy_set_adv_1000(pphy, 0);
 8223b44:	000b883a 	mov	r5,zero
 8223b48:	e13ff517 	ldw	r4,-44(fp)
 8223b4c:	822300c0 	call	822300c <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 8223b50:	01400044 	movi	r5,1
 8223b54:	e13ff517 	ldw	r4,-44(fp)
 8223b58:	82231d00 	call	82231d0 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 8223b5c:	01400044 	movi	r5,1
 8223b60:	e13ff517 	ldw	r4,-44(fp)
 8223b64:	82234240 	call	8223424 <alt_tse_phy_set_adv_10>
 8223b68:	00001506 	br	8223bc0 <alt_tse_phy_set_common_speed+0x2cc>
        }    
        else if(common_speed == TSE_PHY_SPEED_10) {
 8223b6c:	e0bffd17 	ldw	r2,-12(fp)
 8223b70:	10000a1e 	bne	r2,zero,8223b9c <alt_tse_phy_set_common_speed+0x2a8>
            alt_tse_phy_set_adv_1000(pphy, 0);
 8223b74:	000b883a 	mov	r5,zero
 8223b78:	e13ff517 	ldw	r4,-44(fp)
 8223b7c:	822300c0 	call	822300c <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 8223b80:	000b883a 	mov	r5,zero
 8223b84:	e13ff517 	ldw	r4,-44(fp)
 8223b88:	82231d00 	call	82231d0 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 8223b8c:	01400044 	movi	r5,1
 8223b90:	e13ff517 	ldw	r4,-44(fp)
 8223b94:	82234240 	call	8223424 <alt_tse_phy_set_adv_10>
 8223b98:	00000906 	br	8223bc0 <alt_tse_phy_set_common_speed+0x2cc>
        }
        else {
            alt_tse_phy_set_adv_1000(pphy, 0);
 8223b9c:	000b883a 	mov	r5,zero
 8223ba0:	e13ff517 	ldw	r4,-44(fp)
 8223ba4:	822300c0 	call	822300c <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 8223ba8:	000b883a 	mov	r5,zero
 8223bac:	e13ff517 	ldw	r4,-44(fp)
 8223bb0:	82231d00 	call	82231d0 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 0);
 8223bb4:	000b883a 	mov	r5,zero
 8223bb8:	e13ff517 	ldw	r4,-44(fp)
 8223bbc:	82234240 	call	8223424 <alt_tse_phy_set_adv_10>
        }
        
        /* if PHY Auto-Negotiation is completed */
        if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 1) {
 8223bc0:	01c00044 	movi	r7,1
 8223bc4:	01800144 	movi	r6,5
 8223bc8:	01400044 	movi	r5,1
 8223bcc:	e13ff517 	ldw	r4,-44(fp)
 8223bd0:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8223bd4:	10800058 	cmpnei	r2,r2,1
 8223bd8:	10003b1e 	bne	r2,zero,8223cc8 <alt_tse_phy_set_common_speed+0x3d4>
            
            /* read both msb and lsb of speed bits if PHY support 1000 Mbps */
            if(gb_capable) {
 8223bdc:	e0bffb03 	ldbu	r2,-20(fp)
 8223be0:	10000f26 	beq	r2,zero,8223c20 <alt_tse_phy_set_common_speed+0x32c>
        
                /* get speed information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 8223be4:	e0bff517 	ldw	r2,-44(fp)
 8223be8:	10800517 	ldw	r2,20(r2)
 8223bec:	10801583 	ldbu	r2,86(r2)
 8223bf0:	10c03fcc 	andi	r3,r2,255
 8223bf4:	e0bff517 	ldw	r2,-44(fp)
 8223bf8:	10800517 	ldw	r2,20(r2)
 8223bfc:	108015c3 	ldbu	r2,87(r2)
 8223c00:	10803fcc 	andi	r2,r2,255
 8223c04:	01c00084 	movi	r7,2
 8223c08:	100d883a 	mov	r6,r2
 8223c0c:	180b883a 	mov	r5,r3
 8223c10:	e13ff517 	ldw	r4,-44(fp)
 8223c14:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8223c18:	e0bff405 	stb	r2,-48(fp)
 8223c1c:	00000e06 	br	8223c58 <alt_tse_phy_set_common_speed+0x364>
            }
            
            /* read lsb of speed only if PHY support only 10/100 Mbps */
            else {
                /* get speed and link information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 1);
 8223c20:	e0bff517 	ldw	r2,-44(fp)
 8223c24:	10800517 	ldw	r2,20(r2)
 8223c28:	10801583 	ldbu	r2,86(r2)
 8223c2c:	10c03fcc 	andi	r3,r2,255
 8223c30:	e0bff517 	ldw	r2,-44(fp)
 8223c34:	10800517 	ldw	r2,20(r2)
 8223c38:	108015c3 	ldbu	r2,87(r2)
 8223c3c:	10803fcc 	andi	r2,r2,255
 8223c40:	01c00044 	movi	r7,1
 8223c44:	100d883a 	mov	r6,r2
 8223c48:	180b883a 	mov	r5,r3
 8223c4c:	e13ff517 	ldw	r4,-44(fp)
 8223c50:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8223c54:	e0bff405 	stb	r2,-48(fp)
            }
            
            /* if current speed != common speed, then restart Auto-Negotiation */
            if(speed != common_speed) {
 8223c58:	e0fff403 	ldbu	r3,-48(fp)
 8223c5c:	e0bffd17 	ldw	r2,-12(fp)
 8223c60:	18800426 	beq	r3,r2,8223c74 <alt_tse_phy_set_common_speed+0x380>
                alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 8223c64:	01400134 	movhi	r5,4
 8223c68:	29742404 	addi	r5,r5,-12144
 8223c6c:	e13ff517 	ldw	r4,-44(fp)
 8223c70:	82227580 	call	8222758 <alt_tse_phy_restart_an>
            }
            
            /* get speed information after Auto-Negotiation */
            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 8223c74:	e0bff517 	ldw	r2,-44(fp)
 8223c78:	10800517 	ldw	r2,20(r2)
 8223c7c:	10801583 	ldbu	r2,86(r2)
 8223c80:	10c03fcc 	andi	r3,r2,255
 8223c84:	e0bff517 	ldw	r2,-44(fp)
 8223c88:	10800517 	ldw	r2,20(r2)
 8223c8c:	10801603 	ldbu	r2,88(r2)
 8223c90:	10803fcc 	andi	r2,r2,255
 8223c94:	01c00044 	movi	r7,1
 8223c98:	100d883a 	mov	r6,r2
 8223c9c:	180b883a 	mov	r5,r3
 8223ca0:	e13ff517 	ldw	r4,-44(fp)
 8223ca4:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8223ca8:	e0bffb45 	stb	r2,-19(fp)
            
            /* Set MAC duplex register */
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
 8223cac:	e0bff717 	ldw	r2,-36(fp)
 8223cb0:	10800017 	ldw	r2,0(r2)
 8223cb4:	1007883a 	mov	r3,r2
 8223cb8:	e0bffb43 	ldbu	r2,-19(fp)
 8223cbc:	100b883a 	mov	r5,r2
 8223cc0:	1809883a 	mov	r4,r3
 8223cc4:	82205b40 	call	82205b4 <alt_tse_mac_set_duplex>
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
 8223cc8:	e43ff847 	ldb	r16,-31(fp)
 8223ccc:	e47ff807 	ldb	r17,-32(fp)
 8223cd0:	01c00404 	movi	r7,16
 8223cd4:	000d883a 	mov	r6,zero
 8223cd8:	01400044 	movi	r5,1
 8223cdc:	e13ff517 	ldw	r4,-44(fp)
 8223ce0:	82212900 	call	8221290 <alt_tse_phy_rd_mdio_reg>
 8223ce4:	100f883a 	mov	r7,r2
 8223ce8:	880d883a 	mov	r6,r17
 8223cec:	800b883a 	mov	r5,r16
 8223cf0:	01020974 	movhi	r4,2085
 8223cf4:	213e6604 	addi	r4,r4,-1640
 8223cf8:	82033a00 	call	82033a0 <printf>
 8223cfc:	00000106 	br	8223d04 <alt_tse_phy_set_common_speed+0x410>

        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
 8223d00:	0001883a 	nop
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
        return TSE_PHY_SPEED_NO_COMMON;
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 8223d04:	e0bff317 	ldw	r2,-52(fp)
 8223d08:	10800044 	addi	r2,r2,1
 8223d0c:	e0bff315 	stw	r2,-52(fp)
 8223d10:	e0bffc17 	ldw	r2,-16(fp)
 8223d14:	10800003 	ldbu	r2,0(r2)
 8223d18:	10803fcc 	andi	r2,r2,255
 8223d1c:	e0fff317 	ldw	r3,-52(fp)
 8223d20:	18bf1f16 	blt	r3,r2,82239a0 <alt_tse_phy_set_common_speed+0xac>
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
    }
    tse_dprintf(5, "INFO    : MAC Group[%d] - All PHYs set to common speed : %d Mbps\n", mac_group_index, (common_speed == TSE_PHY_SPEED_1000) ? 1000 : ((common_speed == TSE_PHY_SPEED_100) ? 100 : 10));
 8223d24:	e0fff847 	ldb	r3,-31(fp)
 8223d28:	e0bffd17 	ldw	r2,-12(fp)
 8223d2c:	108000a0 	cmpeqi	r2,r2,2
 8223d30:	1000071e 	bne	r2,zero,8223d50 <alt_tse_phy_set_common_speed+0x45c>
 8223d34:	e0bffd17 	ldw	r2,-12(fp)
 8223d38:	10800058 	cmpnei	r2,r2,1
 8223d3c:	1000021e 	bne	r2,zero,8223d48 <alt_tse_phy_set_common_speed+0x454>
 8223d40:	00801904 	movi	r2,100
 8223d44:	00000306 	br	8223d54 <alt_tse_phy_set_common_speed+0x460>
 8223d48:	00800284 	movi	r2,10
 8223d4c:	00000106 	br	8223d54 <alt_tse_phy_set_common_speed+0x460>
 8223d50:	0080fa04 	movi	r2,1000
 8223d54:	100d883a 	mov	r6,r2
 8223d58:	180b883a 	mov	r5,r3
 8223d5c:	01020974 	movhi	r4,2085
 8223d60:	213e7204 	addi	r4,r4,-1592
 8223d64:	82033a00 	call	82033a0 <printf>

    /* Set MAC speed register */
    alt_tse_mac_set_speed(pmac_group_base, common_speed);
 8223d68:	e0bffd17 	ldw	r2,-12(fp)
 8223d6c:	10803fcc 	andi	r2,r2,255
 8223d70:	100b883a 	mov	r5,r2
 8223d74:	e13ff917 	ldw	r4,-28(fp)
 8223d78:	82204d40 	call	82204d4 <alt_tse_mac_set_speed>
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 8223d7c:	e0bff917 	ldw	r2,-28(fp)
 8223d80:	10801004 	addi	r2,r2,64
 8223d84:	e0fffa17 	ldw	r3,-24(fp)
 8223d88:	10c00035 	stwio	r3,0(r2)
        
    return common_speed;
 8223d8c:	e0bffd17 	ldw	r2,-12(fp)
}
 8223d90:	e6fffe04 	addi	sp,fp,-8
 8223d94:	dfc00317 	ldw	ra,12(sp)
 8223d98:	df000217 	ldw	fp,8(sp)
 8223d9c:	dc400117 	ldw	r17,4(sp)
 8223da0:	dc000017 	ldw	r16,0(sp)
 8223da4:	dec00404 	addi	sp,sp,16
 8223da8:	f800283a 	ret

08223dac <marvell_phy_cfg>:

/* @Function Description: Additional configuration for Marvell PHY
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address of MAC group
 */
alt_32 marvell_phy_cfg(np_tse_mac *pmac) {
 8223dac:	defffc04 	addi	sp,sp,-16
 8223db0:	dfc00315 	stw	ra,12(sp)
 8223db4:	df000215 	stw	fp,8(sp)
 8223db8:	df000204 	addi	fp,sp,8
 8223dbc:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat;
    
    /* If there is no link yet, we enable auto crossover and reset the PHY */
    if((IORD(&pmac->mdio1.STATUS, 0) & PCS_ST_an_done) == 0) {
 8223dc0:	e0bfff17 	ldw	r2,-4(fp)
 8223dc4:	1080a104 	addi	r2,r2,644
 8223dc8:	10800037 	ldwio	r2,0(r2)
 8223dcc:	1080080c 	andi	r2,r2,32
 8223dd0:	1000161e 	bne	r2,zero,8223e2c <marvell_phy_cfg+0x80>
        tse_dprintf(5, "MARVELL : Enabling auto crossover\n");
 8223dd4:	01020974 	movhi	r4,2085
 8223dd8:	213e8304 	addi	r4,r4,-1524
 8223ddc:	82036240 	call	8203624 <puts>
        IOWR(&pmac->mdio1.CONTROL, 16, 0x0078);
 8223de0:	e0bfff17 	ldw	r2,-4(fp)
 8223de4:	1080a004 	addi	r2,r2,640
 8223de8:	10801004 	addi	r2,r2,64
 8223dec:	00c01e04 	movi	r3,120
 8223df0:	10c00035 	stwio	r3,0(r2)
        tse_dprintf(5, "MARVELL : PHY reset\n");
 8223df4:	01020974 	movhi	r4,2085
 8223df8:	213e8c04 	addi	r4,r4,-1488
 8223dfc:	82036240 	call	8203624 <puts>
        dat = IORD(&pmac->mdio1.CONTROL, 0); 
 8223e00:	e0bfff17 	ldw	r2,-4(fp)
 8223e04:	1080a004 	addi	r2,r2,640
 8223e08:	10800037 	ldwio	r2,0(r2)
 8223e0c:	e0bffe0d 	sth	r2,-8(fp)
        IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);        
 8223e10:	e0bfff17 	ldw	r2,-4(fp)
 8223e14:	1080a004 	addi	r2,r2,640
 8223e18:	e13ffe0b 	ldhu	r4,-8(fp)
 8223e1c:	00e00004 	movi	r3,-32768
 8223e20:	20c6b03a 	or	r3,r4,r3
 8223e24:	18ffffcc 	andi	r3,r3,65535
 8223e28:	10c00035 	stwio	r3,0(r2)
    }
    
    return 0;
 8223e2c:	0005883a 	mov	r2,zero
}
 8223e30:	e037883a 	mov	sp,fp
 8223e34:	dfc00117 	ldw	ra,4(sp)
 8223e38:	df000017 	ldw	fp,0(sp)
 8223e3c:	dec00204 	addi	sp,sp,8
 8223e40:	f800283a 	ret

08223e44 <marvell_cfg_gmii>:

/* @Function Description: Change operating mode of Marvell PHY to GMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_gmii(np_tse_mac *pmac) {
 8223e44:	defffc04 	addi	sp,sp,-16
 8223e48:	dfc00315 	stw	ra,12(sp)
 8223e4c:	df000215 	stw	fp,8(sp)
 8223e50:	df000204 	addi	fp,sp,8
 8223e54:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 8223e58:	e0bfff17 	ldw	r2,-4(fp)
 8223e5c:	1080bb04 	addi	r2,r2,748
 8223e60:	10800037 	ldwio	r2,0(r2)
 8223e64:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 8223e68:	e0fffe0b 	ldhu	r3,-8(fp)
 8223e6c:	00bffc04 	movi	r2,-16
 8223e70:	1884703a 	and	r2,r3,r2
 8223e74:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to GMII to copper mode\n");
 8223e78:	01020974 	movhi	r4,2085
 8223e7c:	213e9104 	addi	r4,r4,-1468
 8223e80:	82036240 	call	8203624 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xf);
 8223e84:	e0bfff17 	ldw	r2,-4(fp)
 8223e88:	1080bb04 	addi	r2,r2,748
 8223e8c:	e0fffe0b 	ldhu	r3,-8(fp)
 8223e90:	18c003d4 	ori	r3,r3,15
 8223e94:	18ffffcc 	andi	r3,r3,65535
 8223e98:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 8223e9c:	01020974 	movhi	r4,2085
 8223ea0:	213e9d04 	addi	r4,r4,-1420
 8223ea4:	82036240 	call	8203624 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 8223ea8:	e0bfff17 	ldw	r2,-4(fp)
 8223eac:	1080b404 	addi	r2,r2,720
 8223eb0:	10800037 	ldwio	r2,0(r2)
 8223eb4:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 8223eb8:	e0fffe0b 	ldhu	r3,-8(fp)
 8223ebc:	00bfdf44 	movi	r2,-131
 8223ec0:	1884703a 	and	r2,r3,r2
 8223ec4:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 8223ec8:	e0bfff17 	ldw	r2,-4(fp)
 8223ecc:	1080b404 	addi	r2,r2,720
 8223ed0:	e0fffe0b 	ldhu	r3,-8(fp)
 8223ed4:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 8223ed8:	01020974 	movhi	r4,2085
 8223edc:	213e8c04 	addi	r4,r4,-1488
 8223ee0:	82036240 	call	8203624 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 8223ee4:	e0bfff17 	ldw	r2,-4(fp)
 8223ee8:	1080a004 	addi	r2,r2,640
 8223eec:	10800037 	ldwio	r2,0(r2)
 8223ef0:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 8223ef4:	e0bfff17 	ldw	r2,-4(fp)
 8223ef8:	1080a004 	addi	r2,r2,640
 8223efc:	e13ffe0b 	ldhu	r4,-8(fp)
 8223f00:	00e00004 	movi	r3,-32768
 8223f04:	20c6b03a 	or	r3,r4,r3
 8223f08:	18ffffcc 	andi	r3,r3,65535
 8223f0c:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 8223f10:	00800044 	movi	r2,1
}
 8223f14:	e037883a 	mov	sp,fp
 8223f18:	dfc00117 	ldw	ra,4(sp)
 8223f1c:	df000017 	ldw	fp,0(sp)
 8223f20:	dec00204 	addi	sp,sp,8
 8223f24:	f800283a 	ret

08223f28 <marvell_cfg_sgmii>:

/* @Function Description: Change operating mode of Marvell PHY to SGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_sgmii(np_tse_mac *pmac) {
 8223f28:	defffc04 	addi	sp,sp,-16
 8223f2c:	dfc00315 	stw	ra,12(sp)
 8223f30:	df000215 	stw	fp,8(sp)
 8223f34:	df000204 	addi	fp,sp,8
 8223f38:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 8223f3c:	e0bfff17 	ldw	r2,-4(fp)
 8223f40:	1080bb04 	addi	r2,r2,748
 8223f44:	10800037 	ldwio	r2,0(r2)
 8223f48:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 8223f4c:	e0fffe0b 	ldhu	r3,-8(fp)
 8223f50:	00bffc04 	movi	r2,-16
 8223f54:	1884703a 	and	r2,r3,r2
 8223f58:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to SGMII without clock with SGMII Auto-Neg to copper mode\n");
 8223f5c:	01020974 	movhi	r4,2085
 8223f60:	213ea704 	addi	r4,r4,-1380
 8223f64:	82036240 	call	8203624 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0x4);
 8223f68:	e0bfff17 	ldw	r2,-4(fp)
 8223f6c:	1080bb04 	addi	r2,r2,748
 8223f70:	e0fffe0b 	ldhu	r3,-8(fp)
 8223f74:	18c00114 	ori	r3,r3,4
 8223f78:	18ffffcc 	andi	r3,r3,65535
 8223f7c:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 8223f80:	01020974 	movhi	r4,2085
 8223f84:	213e9d04 	addi	r4,r4,-1420
 8223f88:	82036240 	call	8203624 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 8223f8c:	e0bfff17 	ldw	r2,-4(fp)
 8223f90:	1080b404 	addi	r2,r2,720
 8223f94:	10800037 	ldwio	r2,0(r2)
 8223f98:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 8223f9c:	e0fffe0b 	ldhu	r3,-8(fp)
 8223fa0:	00bfdf44 	movi	r2,-131
 8223fa4:	1884703a 	and	r2,r3,r2
 8223fa8:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 8223fac:	e0bfff17 	ldw	r2,-4(fp)
 8223fb0:	1080b404 	addi	r2,r2,720
 8223fb4:	e0fffe0b 	ldhu	r3,-8(fp)
 8223fb8:	10c00035 	stwio	r3,0(r2)

    tse_dprintf(5, "MARVELL : PHY reset\n");
 8223fbc:	01020974 	movhi	r4,2085
 8223fc0:	213e8c04 	addi	r4,r4,-1488
 8223fc4:	82036240 	call	8203624 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 8223fc8:	e0bfff17 	ldw	r2,-4(fp)
 8223fcc:	1080a004 	addi	r2,r2,640
 8223fd0:	10800037 	ldwio	r2,0(r2)
 8223fd4:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 8223fd8:	e0bfff17 	ldw	r2,-4(fp)
 8223fdc:	1080a004 	addi	r2,r2,640
 8223fe0:	e13ffe0b 	ldhu	r4,-8(fp)
 8223fe4:	00e00004 	movi	r3,-32768
 8223fe8:	20c6b03a 	or	r3,r4,r3
 8223fec:	18ffffcc 	andi	r3,r3,65535
 8223ff0:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 8223ff4:	00800044 	movi	r2,1
}
 8223ff8:	e037883a 	mov	sp,fp
 8223ffc:	dfc00117 	ldw	ra,4(sp)
 8224000:	df000017 	ldw	fp,0(sp)
 8224004:	dec00204 	addi	sp,sp,8
 8224008:	f800283a 	ret

0822400c <marvell_cfg_rgmii>:

/* @Function Description: Change operating mode of Marvell PHY to RGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_rgmii(np_tse_mac *pmac) {
 822400c:	defffc04 	addi	sp,sp,-16
 8224010:	dfc00315 	stw	ra,12(sp)
 8224014:	df000215 	stw	fp,8(sp)
 8224018:	df000204 	addi	fp,sp,8
 822401c:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 8224020:	e0bfff17 	ldw	r2,-4(fp)
 8224024:	1080bb04 	addi	r2,r2,748
 8224028:	10800037 	ldwio	r2,0(r2)
 822402c:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 8224030:	e0fffe0b 	ldhu	r3,-8(fp)
 8224034:	00bffc04 	movi	r2,-16
 8224038:	1884703a 	and	r2,r3,r2
 822403c:	e0bffe0d 	sth	r2,-8(fp)
    
    tse_dprintf(5, "MARVELL : Mode changed to RGMII/Modified MII to Copper mode\n");
 8224040:	01020974 	movhi	r4,2085
 8224044:	213ebc04 	addi	r4,r4,-1296
 8224048:	82036240 	call	8203624 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xb);
 822404c:	e0bfff17 	ldw	r2,-4(fp)
 8224050:	1080bb04 	addi	r2,r2,748
 8224054:	e0fffe0b 	ldhu	r3,-8(fp)
 8224058:	18c002d4 	ori	r3,r3,11
 822405c:	18ffffcc 	andi	r3,r3,65535
 8224060:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Enable RGMII Timing Control\n");
 8224064:	01020974 	movhi	r4,2085
 8224068:	213ecb04 	addi	r4,r4,-1236
 822406c:	82036240 	call	8203624 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0);
 8224070:	e0bfff17 	ldw	r2,-4(fp)
 8224074:	1080b404 	addi	r2,r2,720
 8224078:	10800037 	ldwio	r2,0(r2)
 822407c:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 8224080:	e0fffe0b 	ldhu	r3,-8(fp)
 8224084:	00bfdf44 	movi	r2,-131
 8224088:	1884703a 	and	r2,r3,r2
 822408c:	e0bffe0d 	sth	r2,-8(fp)
    dat |= 0x82;
 8224090:	e0bffe0b 	ldhu	r2,-8(fp)
 8224094:	10802094 	ori	r2,r2,130
 8224098:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);    
 822409c:	e0bfff17 	ldw	r2,-4(fp)
 82240a0:	1080b404 	addi	r2,r2,720
 82240a4:	e0fffe0b 	ldhu	r3,-8(fp)
 82240a8:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 82240ac:	01020974 	movhi	r4,2085
 82240b0:	213e8c04 	addi	r4,r4,-1488
 82240b4:	82036240 	call	8203624 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 82240b8:	e0bfff17 	ldw	r2,-4(fp)
 82240bc:	1080a004 	addi	r2,r2,640
 82240c0:	10800037 	ldwio	r2,0(r2)
 82240c4:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 82240c8:	e0bfff17 	ldw	r2,-4(fp)
 82240cc:	1080a004 	addi	r2,r2,640
 82240d0:	e13ffe0b 	ldhu	r4,-8(fp)
 82240d4:	00e00004 	movi	r3,-32768
 82240d8:	20c6b03a 	or	r3,r4,r3
 82240dc:	18ffffcc 	andi	r3,r3,65535
 82240e0:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 82240e4:	00800044 	movi	r2,1
    
}
 82240e8:	e037883a 	mov	sp,fp
 82240ec:	dfc00117 	ldw	ra,4(sp)
 82240f0:	df000017 	ldw	fp,0(sp)
 82240f4:	dec00204 	addi	sp,sp,8
 82240f8:	f800283a 	ret

082240fc <DP83848C_link_status_read>:

/* @Function Description: Read link status from PHY specific status register of DP83848C
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_u32 DP83848C_link_status_read(np_tse_mac *pmac) {
 82240fc:	defffc04 	addi	sp,sp,-16
 8224100:	df000315 	stw	fp,12(sp)
 8224104:	df000304 	addi	fp,sp,12
 8224108:	e13fff15 	stw	r4,-4(fp)
	alt_u32 link_status = 0;
 822410c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 reg_status = IORD(&pmac->mdio1.reg10, 0);
 8224110:	e0bfff17 	ldw	r2,-4(fp)
 8224114:	1080b004 	addi	r2,r2,704
 8224118:	10800037 	ldwio	r2,0(r2)
 822411c:	e0bffe15 	stw	r2,-8(fp)
	
	/* If speed == 10 Mbps */
	if(reg_status & 0x2) {
 8224120:	e0bffe17 	ldw	r2,-8(fp)
 8224124:	1080008c 	andi	r2,r2,2
 8224128:	10000426 	beq	r2,zero,822413c <DP83848C_link_status_read+0x40>
		link_status |= 0x8;
 822412c:	e0bffd17 	ldw	r2,-12(fp)
 8224130:	10800214 	ori	r2,r2,8
 8224134:	e0bffd15 	stw	r2,-12(fp)
 8224138:	00000306 	br	8224148 <DP83848C_link_status_read+0x4c>
	}
	/* Else speed = 100 Mbps */
	else {
		link_status |= 0x4;
 822413c:	e0bffd17 	ldw	r2,-12(fp)
 8224140:	10800114 	ori	r2,r2,4
 8224144:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* If duplex == Full */
	if(reg_status & 0x4) {
 8224148:	e0bffe17 	ldw	r2,-8(fp)
 822414c:	1080010c 	andi	r2,r2,4
 8224150:	10000326 	beq	r2,zero,8224160 <DP83848C_link_status_read+0x64>
		link_status |= 0x1;
 8224154:	e0bffd17 	ldw	r2,-12(fp)
 8224158:	10800054 	ori	r2,r2,1
 822415c:	e0bffd15 	stw	r2,-12(fp)
	}
	
	return link_status;
 8224160:	e0bffd17 	ldw	r2,-12(fp)
}
 8224164:	e037883a 	mov	sp,fp
 8224168:	df000017 	ldw	fp,0(sp)
 822416c:	dec00104 	addi	sp,sp,4
 8224170:	f800283a 	ret

08224174 <altera_eth_tse_init>:
 * @Return ENP_HARDWARE on error, otherwise return SUCCESS
 */

error_t altera_eth_tse_init(
    alt_iniche_dev              *p_dev)
{
 8224174:	defffa04 	addi	sp,sp,-24
 8224178:	dfc00515 	stw	ra,20(sp)
 822417c:	df000415 	stw	fp,16(sp)
 8224180:	df000404 	addi	fp,sp,16
 8224184:	e13fff15 	stw	r4,-4(fp)
    int i;
    
    alt_tse_iniche_dev_driver_data *p_driver_data = 0;
 8224188:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_system_info *psys_info = 0;
 822418c:	e03ffe15 	stw	zero,-8(fp)
    #ifdef PRINTIF
        dprintf("altera_eth_tse_init %d\n", p_dev->if_num);
    #endif

    /* Get the pointer to the alt_tse_iniche_dev_driver_data structure from the global array */
    for(i = 0; i < number_of_tse_mac; i++) {
 8224190:	e03ffc15 	stw	zero,-16(fp)
 8224194:	00001106 	br	82241dc <altera_eth_tse_init+0x68>
        if(tse_iniche_dev_driver_data[i].p_dev == p_dev) {
 8224198:	008209b4 	movhi	r2,2086
 822419c:	10b6fe04 	addi	r2,r2,-9224
 82241a0:	e0fffc17 	ldw	r3,-16(fp)
 82241a4:	18c00324 	muli	r3,r3,12
 82241a8:	10c5883a 	add	r2,r2,r3
 82241ac:	10c00017 	ldw	r3,0(r2)
 82241b0:	e0bfff17 	ldw	r2,-4(fp)
 82241b4:	1880061e 	bne	r3,r2,82241d0 <altera_eth_tse_init+0x5c>
            p_driver_data = &tse_iniche_dev_driver_data[i];
 82241b8:	e0bffc17 	ldw	r2,-16(fp)
 82241bc:	10c00324 	muli	r3,r2,12
 82241c0:	008209b4 	movhi	r2,2086
 82241c4:	10b6fe04 	addi	r2,r2,-9224
 82241c8:	1885883a 	add	r2,r3,r2
 82241cc:	e0bffd15 	stw	r2,-12(fp)
    #ifdef PRINTIF
        dprintf("altera_eth_tse_init %d\n", p_dev->if_num);
    #endif

    /* Get the pointer to the alt_tse_iniche_dev_driver_data structure from the global array */
    for(i = 0; i < number_of_tse_mac; i++) {
 82241d0:	e0bffc17 	ldw	r2,-16(fp)
 82241d4:	10800044 	addi	r2,r2,1
 82241d8:	e0bffc15 	stw	r2,-16(fp)
 82241dc:	d0a08003 	ldbu	r2,-32256(gp)
 82241e0:	10803fcc 	andi	r2,r2,255
 82241e4:	e0fffc17 	ldw	r3,-16(fp)
 82241e8:	18bfeb16 	blt	r3,r2,8224198 <altera_eth_tse_init+0x24>
        if(tse_iniche_dev_driver_data[i].p_dev == p_dev) {
            p_driver_data = &tse_iniche_dev_driver_data[i];
        }
    }
    /* If pointer could not found */
    if(p_driver_data == 0) {
 82241ec:	e0bffd17 	ldw	r2,-12(fp)
 82241f0:	1000021e 	bne	r2,zero,82241fc <altera_eth_tse_init+0x88>
        return ENP_HARDWARE;
 82241f4:	00bff744 	movi	r2,-35
 82241f8:	00002706 	br	8224298 <altera_eth_tse_init+0x124>
    }
    
    /* Get the pointer to the alt_tse_system_info structure from the global array */
    for(i = 0; i < max_mac_system; i++) {
 82241fc:	e03ffc15 	stw	zero,-16(fp)
 8224200:	00001206 	br	822424c <altera_eth_tse_init+0xd8>
        if(tse_mac_device[i].tse_mac_base == p_driver_data->hw_mac_base_addr) {
 8224204:	00820974 	movhi	r2,2085
 8224208:	1087b804 	addi	r2,r2,7904
 822420c:	e0fffc17 	ldw	r3,-16(fp)
 8224210:	18c01224 	muli	r3,r3,72
 8224214:	10c5883a 	add	r2,r2,r3
 8224218:	10c00017 	ldw	r3,0(r2)
 822421c:	e0bffd17 	ldw	r2,-12(fp)
 8224220:	10800117 	ldw	r2,4(r2)
 8224224:	1880061e 	bne	r3,r2,8224240 <altera_eth_tse_init+0xcc>
            psys_info = &tse_mac_device[i];
 8224228:	e0bffc17 	ldw	r2,-16(fp)
 822422c:	10c01224 	muli	r3,r2,72
 8224230:	00820974 	movhi	r2,2085
 8224234:	1087b804 	addi	r2,r2,7904
 8224238:	1885883a 	add	r2,r3,r2
 822423c:	e0bffe15 	stw	r2,-8(fp)
    if(p_driver_data == 0) {
        return ENP_HARDWARE;
    }
    
    /* Get the pointer to the alt_tse_system_info structure from the global array */
    for(i = 0; i < max_mac_system; i++) {
 8224240:	e0bffc17 	ldw	r2,-16(fp)
 8224244:	10800044 	addi	r2,r2,1
 8224248:	e0bffc15 	stw	r2,-16(fp)
 822424c:	d0a02d03 	ldbu	r2,-32588(gp)
 8224250:	10803fcc 	andi	r2,r2,255
 8224254:	e0fffc17 	ldw	r3,-16(fp)
 8224258:	18bfea16 	blt	r3,r2,8224204 <altera_eth_tse_init+0x90>
        if(tse_mac_device[i].tse_mac_base == p_driver_data->hw_mac_base_addr) {
            psys_info = &tse_mac_device[i];
        }
    }
    /* If pointer could not found */
    if(psys_info == 0) {
 822425c:	e0bffe17 	ldw	r2,-8(fp)
 8224260:	1000021e 	bne	r2,zero,822426c <altera_eth_tse_init+0xf8>
        return ENP_HARDWARE;
 8224264:	00bff744 	movi	r2,-35
 8224268:	00000b06 	br	8224298 <altera_eth_tse_init+0x124>
    }
    
    prep_tse_mac(p_dev->if_num, psys_info + p_driver_data->hw_channel_number);
 822426c:	e0bfff17 	ldw	r2,-4(fp)
 8224270:	11000517 	ldw	r4,20(r2)
 8224274:	e0bffd17 	ldw	r2,-12(fp)
 8224278:	10800203 	ldbu	r2,8(r2)
 822427c:	10803fcc 	andi	r2,r2,255
 8224280:	10801224 	muli	r2,r2,72
 8224284:	e0fffe17 	ldw	r3,-8(fp)
 8224288:	1885883a 	add	r2,r3,r2
 822428c:	100b883a 	mov	r5,r2
 8224290:	82242ac0 	call	82242ac <prep_tse_mac>
    
    return SUCCESS;
 8224294:	0005883a 	mov	r2,zero
}
 8224298:	e037883a 	mov	sp,fp
 822429c:	dfc00117 	ldw	ra,4(sp)
 82242a0:	df000017 	ldw	fp,0(sp)
 82242a4:	dec00204 	addi	sp,sp,8
 82242a8:	f800283a 	ret

082242ac <prep_tse_mac>:
 * @Param index     index of the NET structure associated with TSE instance
 * @Param psys_info pointer to the TSE hardware info structure
 * @Return next index of NET
 */
int prep_tse_mac(int index, alt_tse_system_info *psys_info)
{
 82242ac:	defffb04 	addi	sp,sp,-20
 82242b0:	dfc00415 	stw	ra,16(sp)
 82242b4:	df000315 	stw	fp,12(sp)
 82242b8:	df000304 	addi	fp,sp,12
 82242bc:	e13ffe15 	stw	r4,-8(fp)
 82242c0:	e17fff15 	stw	r5,-4(fp)
    NET ifp;
    dprintf("prep_tse_mac %d\n", index);
 82242c4:	e17ffe17 	ldw	r5,-8(fp)
 82242c8:	01020974 	movhi	r4,2085
 82242cc:	213ed504 	addi	r4,r4,-1196
 82242d0:	82033a00 	call	82033a0 <printf>
    {
        tse[index].sem = 0; /*Tx IDLE*/
 82242d4:	008209b4 	movhi	r2,2086
 82242d8:	10b70a04 	addi	r2,r2,-9176
 82242dc:	e0fffe17 	ldw	r3,-8(fp)
 82242e0:	18c01324 	muli	r3,r3,76
 82242e4:	10c5883a 	add	r2,r2,r3
 82242e8:	10800c04 	addi	r2,r2,48
 82242ec:	10000015 	stw	zero,0(r2)
        tse[index].tse = (void *)psys_info;
 82242f0:	008209b4 	movhi	r2,2086
 82242f4:	10b70a04 	addi	r2,r2,-9176
 82242f8:	e0fffe17 	ldw	r3,-8(fp)
 82242fc:	18c01324 	muli	r3,r3,76
 8224300:	10c5883a 	add	r2,r2,r3
 8224304:	10801204 	addi	r2,r2,72
 8224308:	e0ffff17 	ldw	r3,-4(fp)
 822430c:	10c00015 	stw	r3,0(r2)

        ifp = nets[index];
 8224310:	008209b4 	movhi	r2,2086
 8224314:	10b81b04 	addi	r2,r2,-8084
 8224318:	e0fffe17 	ldw	r3,-8(fp)
 822431c:	18c7883a 	add	r3,r3,r3
 8224320:	18c7883a 	add	r3,r3,r3
 8224324:	10c5883a 	add	r2,r2,r3
 8224328:	10800017 	ldw	r2,0(r2)
 822432c:	e0bffd15 	stw	r2,-12(fp)
        ifp->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_DOWN; /* status = down */
 8224330:	e0bffd17 	ldw	r2,-12(fp)
 8224334:	10802717 	ldw	r2,156(r2)
 8224338:	00c00084 	movi	r3,2
 822433c:	10c00615 	stw	r3,24(r2)
        ifp->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_DOWN;   
 8224340:	e0bffd17 	ldw	r2,-12(fp)
 8224344:	10802717 	ldw	r2,156(r2)
 8224348:	00c00084 	movi	r3,2
 822434c:	10c00715 	stw	r3,28(r2)
        ifp->n_mib->ifLastChange =  cticks * (100/TPS);
 8224350:	e0bffd17 	ldw	r2,-12(fp)
 8224354:	10802717 	ldw	r2,156(r2)
 8224358:	d0e0a817 	ldw	r3,-32096(gp)
 822435c:	10c00815 	stw	r3,32(r2)
        ifp->n_mib->ifPhysAddress = (u_char*)tse[index].mac_addr;
 8224360:	e0bffd17 	ldw	r2,-12(fp)
 8224364:	10c02717 	ldw	r3,156(r2)
 8224368:	e0bffe17 	ldw	r2,-8(fp)
 822436c:	10801324 	muli	r2,r2,76
 8224370:	11000604 	addi	r4,r2,24
 8224374:	008209b4 	movhi	r2,2086
 8224378:	10b70a04 	addi	r2,r2,-9176
 822437c:	2085883a 	add	r2,r4,r2
 8224380:	18800515 	stw	r2,20(r3)
        ifp->n_mib->ifDescr =       "Altera TSE MAC ethernet";
 8224384:	e0bffd17 	ldw	r2,-12(fp)
 8224388:	10c02717 	ldw	r3,156(r2)
 822438c:	00820974 	movhi	r2,2085
 8224390:	10beda04 	addi	r2,r2,-1176
 8224394:	18800115 	stw	r2,4(r3)
        ifp->n_lnh =                ETHHDR_SIZE; /* ethernet header size. was:14 */
 8224398:	e0bffd17 	ldw	r2,-12(fp)
 822439c:	00c00404 	movi	r3,16
 82243a0:	10c00815 	stw	r3,32(r2)
        ifp->n_hal =                ALTERA_TSE_HAL_ADDR_LEN;  /* hardware address length */
 82243a4:	e0bffd17 	ldw	r2,-12(fp)
 82243a8:	00c00184 	movi	r3,6
 82243ac:	10c01115 	stw	r3,68(r2)
        ifp->n_mib->ifType =        ETHERNET;   /* device type */
 82243b0:	e0bffd17 	ldw	r2,-12(fp)
 82243b4:	10802717 	ldw	r2,156(r2)
 82243b8:	00c00184 	movi	r3,6
 82243bc:	10c00215 	stw	r3,8(r2)
        ifp->n_mtu =                ALTERA_TSE_MAX_MTU_SIZE;  /* max frame size */
 82243c0:	e0bffd17 	ldw	r2,-12(fp)
 82243c4:	00c17a84 	movi	r3,1514
 82243c8:	10c00915 	stw	r3,36(r2)
    
        /* install our hardware driver routines */
        ifp->n_init =       tse_mac_init;
 82243cc:	e0fffd17 	ldw	r3,-12(fp)
 82243d0:	008208b4 	movhi	r2,2082
 82243d4:	10914104 	addi	r2,r2,17668
 82243d8:	18800215 	stw	r2,8(r3)
        ifp->pkt_send =     NULL;
 82243dc:	e0bffd17 	ldw	r2,-12(fp)
 82243e0:	10000415 	stw	zero,16(r2)
        ifp->raw_send =     tse_mac_raw_send;
 82243e4:	e0fffd17 	ldw	r3,-12(fp)
 82243e8:	008208b4 	movhi	r2,2082
 82243ec:	1093d904 	addi	r2,r2,20324
 82243f0:	18800315 	stw	r2,12(r3)
        ifp->n_close =      tse_mac_close;
 82243f4:	e0fffd17 	ldw	r3,-12(fp)
 82243f8:	008208b4 	movhi	r2,2082
 82243fc:	1095cd04 	addi	r2,r2,22324
 8224400:	18800515 	stw	r2,20(r3)
        ifp->n_stats =      (void(*)(void *, int))tse_mac_stats; 
 8224404:	e0fffd17 	ldw	r3,-12(fp)
 8224408:	008208b4 	movhi	r2,2082
 822440c:	1095bd04 	addi	r2,r2,22260
 8224410:	18800715 	stw	r2,28(r3)
    
    #ifdef IP_V6
        ifp->n_flags |= (NF_NBPROT | NF_IPV6);
    #else
        ifp->n_flags |= NF_NBPROT;
 8224414:	e0bffd17 	ldw	r2,-12(fp)
 8224418:	10802a17 	ldw	r2,168(r2)
 822441c:	10c00214 	ori	r3,r2,8
 8224420:	e0bffd17 	ldw	r2,-12(fp)
 8224424:	10c02a15 	stw	r3,168(r2)
    #endif
    
        nets[index]->n_mib->ifPhysAddress = (u_char*)tse[index].mac_addr;   /* ptr to MAC address */
 8224428:	008209b4 	movhi	r2,2086
 822442c:	10b81b04 	addi	r2,r2,-8084
 8224430:	e0fffe17 	ldw	r3,-8(fp)
 8224434:	18c7883a 	add	r3,r3,r3
 8224438:	18c7883a 	add	r3,r3,r3
 822443c:	10c5883a 	add	r2,r2,r3
 8224440:	10800017 	ldw	r2,0(r2)
 8224444:	10c02717 	ldw	r3,156(r2)
 8224448:	e0bffe17 	ldw	r2,-8(fp)
 822444c:	10801324 	muli	r2,r2,76
 8224450:	11000604 	addi	r4,r2,24
 8224454:	008209b4 	movhi	r2,2086
 8224458:	10b70a04 	addi	r2,r2,-9176
 822445c:	2085883a 	add	r2,r4,r2
 8224460:	18800515 	stw	r2,20(r3)
    
    #ifdef ALT_INICHE
        /* get the MAC address. */
        get_mac_addr(ifp, (unsigned char *)tse[index].mac_addr);
 8224464:	e0bffe17 	ldw	r2,-8(fp)
 8224468:	10801324 	muli	r2,r2,76
 822446c:	10c00604 	addi	r3,r2,24
 8224470:	008209b4 	movhi	r2,2086
 8224474:	10b70a04 	addi	r2,r2,-9176
 8224478:	1885883a 	add	r2,r3,r2
 822447c:	100b883a 	mov	r5,r2
 8224480:	e13ffd17 	ldw	r4,-12(fp)
 8224484:	82010c40 	call	82010c4 <get_mac_addr>
    #endif /* ALT_INICHE */
    
        /* set cross-pointers between iface and tse structs */
        tse[index].index = index;
 8224488:	008209b4 	movhi	r2,2086
 822448c:	10b70a04 	addi	r2,r2,-9176
 8224490:	e0fffe17 	ldw	r3,-8(fp)
 8224494:	18c01324 	muli	r3,r3,76
 8224498:	10c5883a 	add	r2,r2,r3
 822449c:	e0fffe17 	ldw	r3,-8(fp)
 82244a0:	10c00015 	stw	r3,0(r2)
        tse[index].netp = ifp;
 82244a4:	008209b4 	movhi	r2,2086
 82244a8:	10b70a04 	addi	r2,r2,-9176
 82244ac:	e0fffe17 	ldw	r3,-8(fp)
 82244b0:	18c01324 	muli	r3,r3,76
 82244b4:	10c5883a 	add	r2,r2,r3
 82244b8:	10800804 	addi	r2,r2,32
 82244bc:	e0fffd17 	ldw	r3,-12(fp)
 82244c0:	10c00015 	stw	r3,0(r2)
        ifp->n_local = (void*)(&tse[index]);
 82244c4:	e0bffe17 	ldw	r2,-8(fp)
 82244c8:	10c01324 	muli	r3,r2,76
 82244cc:	008209b4 	movhi	r2,2086
 82244d0:	10b70a04 	addi	r2,r2,-9176
 82244d4:	1887883a 	add	r3,r3,r2
 82244d8:	e0bffd17 	ldw	r2,-12(fp)
 82244dc:	10c02815 	stw	r3,160(r2)
    
        index++;
 82244e0:	e0bffe17 	ldw	r2,-8(fp)
 82244e4:	10800044 	addi	r2,r2,1
 82244e8:	e0bffe15 	stw	r2,-8(fp)
   }
 
   return index;
 82244ec:	e0bffe17 	ldw	r2,-8(fp)
}
 82244f0:	e037883a 	mov	sp,fp
 82244f4:	dfc00117 	ldw	ra,4(sp)
 82244f8:	df000017 	ldw	fp,0(sp)
 82244fc:	dec00204 	addi	sp,sp,8
 8224500:	f800283a 	ret

08224504 <tse_mac_init>:
 * @API TYPE: Internal
 * @Param iface index of the NET structure associated with TSE instance
 * @Return 0 if ok, else -1 if error
 */
int tse_mac_init(int iface)
{
 8224504:	defff004 	addi	sp,sp,-64
 8224508:	dfc00f15 	stw	ra,60(sp)
 822450c:	df000e15 	stw	fp,56(sp)
 8224510:	df000e04 	addi	fp,sp,56
 8224514:	e13fff15 	stw	r4,-4(fp)
   int dat;
   int speed, duplex, result, x;
   int status = SUCCESS;
 8224518:	e03ff815 	stw	zero,-32(fp)
   
   alt_sgdma_dev *sgdma_tx_dev;
   alt_sgdma_dev *sgdma_rx_dev;
   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse[iface].tse;
 822451c:	008209b4 	movhi	r2,2086
 8224520:	10b70a04 	addi	r2,r2,-9176
 8224524:	e0ffff17 	ldw	r3,-4(fp)
 8224528:	18c01324 	muli	r3,r3,76
 822452c:	10c5883a 	add	r2,r2,r3
 8224530:	10801204 	addi	r2,r2,72
 8224534:	10800017 	ldw	r2,0(r2)
 8224538:	e0bff915 	stw	r2,-28(fp)
   
   dprintf("[tse_mac_init]\n");
 822453c:	01020974 	movhi	r4,2085
 8224540:	213ee004 	addi	r4,r4,-1152
 8224544:	82036240 	call	8203624 <puts>
#ifdef PRINTIF
    dprintf("tse_mac_init %d\n", iface);
#endif    

    if (tse_hw->ext_desc_mem == 1) {
 8224548:	e0bff917 	ldw	r2,-28(fp)
 822454c:	10800783 	ldbu	r2,30(r2)
 8224550:	10803fcc 	andi	r2,r2,255
 8224554:	10800058 	cmpnei	r2,r2,1
 8224558:	10000b1e 	bne	r2,zero,8224588 <tse_mac_init+0x84>
        tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
 822455c:	e0bff917 	ldw	r2,-28(fp)
 8224560:	10800817 	ldw	r2,32(r2)
 8224564:	1009883a 	mov	r4,r2
 8224568:	008209b4 	movhi	r2,2086
 822456c:	10b70a04 	addi	r2,r2,-9176
 8224570:	e0ffff17 	ldw	r3,-4(fp)
 8224574:	18c01324 	muli	r3,r3,76
 8224578:	10c5883a 	add	r2,r2,r3
 822457c:	10800f04 	addi	r2,r2,60
 8224580:	11000015 	stw	r4,0(r2)
 8224584:	00001206 	br	82245d0 <tse_mac_init+0xcc>
    }
    else {
        unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
 8224588:	01002804 	movi	r4,160
 822458c:	823c9cc0 	call	823c9cc <alt_uncached_malloc>
 8224590:	e0bff515 	stw	r2,-44(fp)
    
        while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 8224594:	00000306 	br	82245a4 <tse_mac_init+0xa0>
        {
            temp_desc++;
 8224598:	e0bff517 	ldw	r2,-44(fp)
 822459c:	10800044 	addi	r2,r2,1
 82245a0:	e0bff515 	stw	r2,-44(fp)
        tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
    }
    else {
        unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
    
        while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 82245a4:	e0bff517 	ldw	r2,-44(fp)
 82245a8:	108007cc 	andi	r2,r2,31
 82245ac:	103ffa1e 	bne	r2,zero,8224598 <tse_mac_init+0x94>
        {
            temp_desc++;
        }
        tse[iface].desc = (alt_sgdma_descriptor *) temp_desc;
 82245b0:	008209b4 	movhi	r2,2086
 82245b4:	10b70a04 	addi	r2,r2,-9176
 82245b8:	e0ffff17 	ldw	r3,-4(fp)
 82245bc:	18c01324 	muli	r3,r3,76
 82245c0:	10c5883a 	add	r2,r2,r3
 82245c4:	10800f04 	addi	r2,r2,60
 82245c8:	e0fff517 	ldw	r3,-44(fp)
 82245cc:	10c00015 	stw	r3,0(r2)
    }

   
   /* Get the Rx and Tx SGDMA addresses */
   sgdma_tx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_tx);
 82245d0:	e0bff917 	ldw	r2,-28(fp)
 82245d4:	10800517 	ldw	r2,20(r2)
 82245d8:	1009883a 	mov	r4,r2
 82245dc:	821e9b40 	call	821e9b4 <alt_avalon_sgdma_open>
 82245e0:	e0bffa15 	stw	r2,-24(fp)
   
   if(!sgdma_tx_dev) {
 82245e4:	e0bffa17 	ldw	r2,-24(fp)
 82245e8:	1000051e 	bne	r2,zero,8224600 <tse_mac_init+0xfc>
      dprintf("[altera_eth_tse_init] Error opening TX SGDMA\n");
 82245ec:	01020974 	movhi	r4,2085
 82245f0:	213ee404 	addi	r4,r4,-1136
 82245f4:	82036240 	call	8203624 <puts>
      return ENP_RESOURCE;
 82245f8:	00bffa84 	movi	r2,-22
 82245fc:	00025406 	br	8224f50 <tse_mac_init+0xa4c>
   }
  
   sgdma_rx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_rx);
 8224600:	e0bff917 	ldw	r2,-28(fp)
 8224604:	10800617 	ldw	r2,24(r2)
 8224608:	1009883a 	mov	r4,r2
 822460c:	821e9b40 	call	821e9b4 <alt_avalon_sgdma_open>
 8224610:	e0bffb15 	stw	r2,-20(fp)
   if(!sgdma_rx_dev) {
 8224614:	e0bffb17 	ldw	r2,-20(fp)
 8224618:	1000051e 	bne	r2,zero,8224630 <tse_mac_init+0x12c>
      dprintf("[altera_eth_tse_init] Error opening RX SGDMA\n");
 822461c:	01020974 	movhi	r4,2085
 8224620:	213ef004 	addi	r4,r4,-1088
 8224624:	82036240 	call	8203624 <puts>
      return ENP_RESOURCE;
 8224628:	00bffa84 	movi	r2,-22
 822462c:	00024806 	br	8224f50 <tse_mac_init+0xa4c>
   }

   /* Initialize mtip_mac_trans_info structure with values from <system.h>*/
   tse_mac_initTransInfo2(&tse[iface].mi, (int)tse_hw->tse_mac_base,
 8224630:	e0bfff17 	ldw	r2,-4(fp)
 8224634:	10801324 	muli	r2,r2,76
 8224638:	10c00104 	addi	r3,r2,4
 822463c:	008209b4 	movhi	r2,2086
 8224640:	10b70a04 	addi	r2,r2,-9176
 8224644:	1887883a 	add	r3,r3,r2
 8224648:	e0bff917 	ldw	r2,-28(fp)
 822464c:	10800017 	ldw	r2,0(r2)
 8224650:	e13ffa17 	ldw	r4,-24(fp)
 8224654:	e17ffb17 	ldw	r5,-20(fp)
 8224658:	d8000015 	stw	zero,0(sp)
 822465c:	280f883a 	mov	r7,r5
 8224660:	200d883a 	mov	r6,r4
 8224664:	100b883a 	mov	r5,r2
 8224668:	1809883a 	mov	r4,r3
 822466c:	821f1b40 	call	821f1b4 <tse_mac_initTransInfo2>
                                   (unsigned int)sgdma_tx_dev,            
                                   (unsigned int)sgdma_rx_dev,
                                   0);

   /* Reset RX-side SGDMA */
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base,
 8224670:	008209b4 	movhi	r2,2086
 8224674:	10b70a04 	addi	r2,r2,-9176
 8224678:	e0ffff17 	ldw	r3,-4(fp)
 822467c:	18c01324 	muli	r3,r3,76
 8224680:	10c5883a 	add	r2,r2,r3
 8224684:	10800304 	addi	r2,r2,12
 8224688:	10800017 	ldw	r2,0(r2)
 822468c:	10800317 	ldw	r2,12(r2)
 8224690:	10800404 	addi	r2,r2,16
 8224694:	00c00074 	movhi	r3,1
 8224698:	10c00035 	stwio	r3,0(r2)
     ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, 0x0);
 822469c:	008209b4 	movhi	r2,2086
 82246a0:	10b70a04 	addi	r2,r2,-9176
 82246a4:	e0ffff17 	ldw	r3,-4(fp)
 82246a8:	18c01324 	muli	r3,r3,76
 82246ac:	10c5883a 	add	r2,r2,r3
 82246b0:	10800304 	addi	r2,r2,12
 82246b4:	10800017 	ldw	r2,0(r2)
 82246b8:	10800317 	ldw	r2,12(r2)
 82246bc:	10800404 	addi	r2,r2,16
 82246c0:	0007883a 	mov	r3,zero
 82246c4:	10c00035 	stwio	r3,0(r2)
   
   tse[iface].interruptNR = tse_hw->tse_sgdma_rx_irq;
 82246c8:	e0bff917 	ldw	r2,-28(fp)
 82246cc:	1080070b 	ldhu	r2,28(r2)
 82246d0:	10ffffcc 	andi	r3,r2,65535
 82246d4:	008209b4 	movhi	r2,2086
 82246d8:	10b70a04 	addi	r2,r2,-9176
 82246dc:	e13fff17 	ldw	r4,-4(fp)
 82246e0:	21001324 	muli	r4,r4,76
 82246e4:	1105883a 	add	r2,r2,r4
 82246e8:	10800904 	addi	r2,r2,36
 82246ec:	10c00015 	stw	r3,0(r2)

   /* reset the PHY if necessary */   
   result = getPHYSpeed(tse[iface].mi.base);
 82246f0:	008209b4 	movhi	r2,2086
 82246f4:	10b70a04 	addi	r2,r2,-9176
 82246f8:	e0ffff17 	ldw	r3,-4(fp)
 82246fc:	18c01324 	muli	r3,r3,76
 8224700:	10c5883a 	add	r2,r2,r3
 8224704:	10800104 	addi	r2,r2,4
 8224708:	10800017 	ldw	r2,0(r2)
 822470c:	1009883a 	mov	r4,r2
 8224710:	82206400 	call	8220640 <getPHYSpeed>
 8224714:	e0bffc15 	stw	r2,-16(fp)
   speed = (result >> 1) & 0x07;
 8224718:	e0bffc17 	ldw	r2,-16(fp)
 822471c:	1005d07a 	srai	r2,r2,1
 8224720:	108001cc 	andi	r2,r2,7
 8224724:	e0bffd15 	stw	r2,-12(fp)
   duplex = result & 0x01;
 8224728:	e0bffc17 	ldw	r2,-16(fp)
 822472c:	1080004c 	andi	r2,r2,1
 8224730:	e0bffe15 	stw	r2,-8(fp)
    
   /* reset the mac */ 
   IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,
 8224734:	008209b4 	movhi	r2,2086
 8224738:	10b70a04 	addi	r2,r2,-9176
 822473c:	e0ffff17 	ldw	r3,-4(fp)
 8224740:	18c01324 	muli	r3,r3,76
 8224744:	10c5883a 	add	r2,r2,r3
 8224748:	10800104 	addi	r2,r2,4
 822474c:	10800017 	ldw	r2,0(r2)
 8224750:	10800204 	addi	r2,r2,8
 8224754:	00c800c4 	movi	r3,8195
 8224758:	10c00035 	stwio	r3,0(r2)
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
 822475c:	e03ff415 	stw	zero,-48(fp)
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
 8224760:	00000506 	br	8224778 <tse_mac_init+0x274>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) {
     if( x++ > 10000 ) {
 8224764:	e0bff417 	ldw	r2,-48(fp)
 8224768:	10c00044 	addi	r3,r2,1
 822476c:	e0fff415 	stw	r3,-48(fp)
 8224770:	1089c450 	cmplti	r2,r2,10001
 8224774:	10000c26 	beq	r2,zero,82247a8 <tse_mac_init+0x2a4>
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
 8224778:	008209b4 	movhi	r2,2086
 822477c:	10b70a04 	addi	r2,r2,-9176
 8224780:	e0ffff17 	ldw	r3,-4(fp)
 8224784:	18c01324 	muli	r3,r3,76
 8224788:	10c5883a 	add	r2,r2,r3
 822478c:	10800104 	addi	r2,r2,4
 8224790:	10800017 	ldw	r2,0(r2)
 8224794:	10800204 	addi	r2,r2,8
 8224798:	10800037 	ldwio	r2,0(r2)
 822479c:	1088000c 	andi	r2,r2,8192
 82247a0:	103ff01e 	bne	r2,zero,8224764 <tse_mac_init+0x260>
 82247a4:	00000106 	br	82247ac <tse_mac_init+0x2a8>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) {
     if( x++ > 10000 ) {
       break;
 82247a8:	0001883a 	nop
     }
   }
   if(x >= 10000) {
 82247ac:	e0bff417 	ldw	r2,-48(fp)
 82247b0:	1089c410 	cmplti	r2,r2,10000
 82247b4:	1000031e 	bne	r2,zero,82247c4 <tse_mac_init+0x2c0>
     dprintf("TSEMAC SW reset bit never cleared!\n");
 82247b8:	01020974 	movhi	r4,2085
 82247bc:	213efc04 	addi	r4,r4,-1040
 82247c0:	82036240 	call	8203624 <puts>
   }

   dat = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
 82247c4:	008209b4 	movhi	r2,2086
 82247c8:	10b70a04 	addi	r2,r2,-9176
 82247cc:	e0ffff17 	ldw	r3,-4(fp)
 82247d0:	18c01324 	muli	r3,r3,76
 82247d4:	10c5883a 	add	r2,r2,r3
 82247d8:	10800104 	addi	r2,r2,4
 82247dc:	10800017 	ldw	r2,0(r2)
 82247e0:	10800204 	addi	r2,r2,8
 82247e4:	10800037 	ldwio	r2,0(r2)
 82247e8:	e0bff315 	stw	r2,-52(fp)
   if( (dat & 0x03) != 0 ) {
 82247ec:	e0bff317 	ldw	r2,-52(fp)
 82247f0:	108000cc 	andi	r2,r2,3
 82247f4:	10000526 	beq	r2,zero,822480c <tse_mac_init+0x308>
     dprintf("WARN: RX/TX not disabled after reset... missing PHY clock? CMD_CONFIG=0x%08x\n", dat);
 82247f8:	e17ff317 	ldw	r5,-52(fp)
 82247fc:	01020974 	movhi	r4,2085
 8224800:	213f0504 	addi	r4,r4,-1004
 8224804:	82033a00 	call	82033a0 <printf>
 8224808:	00000506 	br	8224820 <tse_mac_init+0x31c>
   } 
   else {
     dprintf("OK, x=%d, CMD_CONFIG=0x%08x\n", x, dat);
 822480c:	e1bff317 	ldw	r6,-52(fp)
 8224810:	e17ff417 	ldw	r5,-48(fp)
 8224814:	01020974 	movhi	r4,2085
 8224818:	213f1904 	addi	r4,r4,-924
 822481c:	82033a00 	call	82033a0 <printf>
  
    /* Hack code to determine the Channel number <- Someone please fix this ugly code in the future */
    extern alt_u8 mac_group_count;
    extern alt_tse_mac_group *pmac_groups[TSE_MAX_MAC_IN_SYSTEM];
      
    if(tse_hw->use_shared_fifo == 1) {
 8224820:	e0bff917 	ldw	r2,-28(fp)
 8224824:	10800903 	ldbu	r2,36(r2)
 8224828:	10803fcc 	andi	r2,r2,255
 822482c:	10800058 	cmpnei	r2,r2,1
 8224830:	1000331e 	bne	r2,zero,8224900 <tse_mac_init+0x3fc>
      int channel_loop = 0;
 8224834:	e03ff615 	stw	zero,-40(fp)
      int mac_loop = 0;
 8224838:	e03ff715 	stw	zero,-36(fp)
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
 822483c:	e03ff615 	stw	zero,-40(fp)
 8224840:	00002b06 	br	82248f0 <tse_mac_init+0x3ec>
        for (mac_loop = 0; mac_loop < pmac_groups[channel_loop]->channel; mac_loop ++) {
 8224844:	e03ff715 	stw	zero,-36(fp)
 8224848:	00001b06 	br	82248b8 <tse_mac_init+0x3b4>
          if (pmac_groups[channel_loop]->pmac_info[mac_loop]->psys_info == tse_hw) {
 822484c:	008209b4 	movhi	r2,2086
 8224850:	10b6f604 	addi	r2,r2,-9256
 8224854:	e0fff617 	ldw	r3,-40(fp)
 8224858:	18c7883a 	add	r3,r3,r3
 822485c:	18c7883a 	add	r3,r3,r3
 8224860:	10c5883a 	add	r2,r2,r3
 8224864:	10c00017 	ldw	r3,0(r2)
 8224868:	e0bff717 	ldw	r2,-36(fp)
 822486c:	10800044 	addi	r2,r2,1
 8224870:	1085883a 	add	r2,r2,r2
 8224874:	1085883a 	add	r2,r2,r2
 8224878:	1885883a 	add	r2,r3,r2
 822487c:	10800017 	ldw	r2,0(r2)
 8224880:	10c00217 	ldw	r3,8(r2)
 8224884:	e0bff917 	ldw	r2,-28(fp)
 8224888:	1880081e 	bne	r3,r2,82248ac <tse_mac_init+0x3a8>
            tse[iface].channel = mac_loop;
 822488c:	008209b4 	movhi	r2,2086
 8224890:	10b70a04 	addi	r2,r2,-9176
 8224894:	e0ffff17 	ldw	r3,-4(fp)
 8224898:	18c01324 	muli	r3,r3,76
 822489c:	10c5883a 	add	r2,r2,r3
 82248a0:	10800d04 	addi	r2,r2,52
 82248a4:	e0fff717 	ldw	r3,-36(fp)
 82248a8:	10c00015 	stw	r3,0(r2)
    if(tse_hw->use_shared_fifo == 1) {
      int channel_loop = 0;
      int mac_loop = 0;
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
        for (mac_loop = 0; mac_loop < pmac_groups[channel_loop]->channel; mac_loop ++) {
 82248ac:	e0bff717 	ldw	r2,-36(fp)
 82248b0:	10800044 	addi	r2,r2,1
 82248b4:	e0bff715 	stw	r2,-36(fp)
 82248b8:	008209b4 	movhi	r2,2086
 82248bc:	10b6f604 	addi	r2,r2,-9256
 82248c0:	e0fff617 	ldw	r3,-40(fp)
 82248c4:	18c7883a 	add	r3,r3,r3
 82248c8:	18c7883a 	add	r3,r3,r3
 82248cc:	10c5883a 	add	r2,r2,r3
 82248d0:	10800017 	ldw	r2,0(r2)
 82248d4:	10800003 	ldbu	r2,0(r2)
 82248d8:	10803fcc 	andi	r2,r2,255
 82248dc:	e0fff717 	ldw	r3,-36(fp)
 82248e0:	18bfda16 	blt	r3,r2,822484c <tse_mac_init+0x348>
      
    if(tse_hw->use_shared_fifo == 1) {
      int channel_loop = 0;
      int mac_loop = 0;
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
 82248e4:	e0bff617 	ldw	r2,-40(fp)
 82248e8:	10800044 	addi	r2,r2,1
 82248ec:	e0bff615 	stw	r2,-40(fp)
 82248f0:	d0a07f43 	ldbu	r2,-32259(gp)
 82248f4:	10803fcc 	andi	r2,r2,255
 82248f8:	e0fff617 	ldw	r3,-40(fp)
 82248fc:	18bfd116 	blt	r3,r2,8224844 <tse_mac_init+0x340>
        }
      }
    }
    /* End of Hack code */
  
  if(tse_hw->use_shared_fifo == 1) {
 8224900:	e0bff917 	ldw	r2,-28(fp)
 8224904:	10800903 	ldbu	r2,36(r2)
 8224908:	10803fcc 	andi	r2,r2,255
 822490c:	10800058 	cmpnei	r2,r2,1
 8224910:	10000f1e 	bne	r2,zero,8224950 <tse_mac_init+0x44c>
      IOWR_ALTERA_MULTI_CHAN_FIFO_SEC_FULL_THRESHOLD(tse_hw->tse_shared_fifo_rx_ctrl_base,tse_hw->tse_shared_fifo_rx_depth);
 8224914:	e0bff917 	ldw	r2,-28(fp)
 8224918:	10800d17 	ldw	r2,52(r2)
 822491c:	1007883a 	mov	r3,r2
 8224920:	e0bff917 	ldw	r2,-28(fp)
 8224924:	10800f17 	ldw	r2,60(r2)
 8224928:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_MULTI_CHAN_FIFO_ALMOST_FULL_THRESHOLD(tse_hw->tse_shared_fifo_rx_ctrl_base,((tse_hw->tse_shared_fifo_rx_depth) - 140));
 822492c:	e0bff917 	ldw	r2,-28(fp)
 8224930:	10800d17 	ldw	r2,52(r2)
 8224934:	10800204 	addi	r2,r2,8
 8224938:	1007883a 	mov	r3,r2
 822493c:	e0bff917 	ldw	r2,-28(fp)
 8224940:	10800f17 	ldw	r2,60(r2)
 8224944:	10bfdd04 	addi	r2,r2,-140
 8224948:	18800035 	stwio	r2,0(r3)
 822494c:	00006006 	br	8224ad0 <tse_mac_init+0x5cc>
  }
  else {
      /* Initialize MAC registers */
      IOWR_ALTERA_TSEMAC_FRM_LENGTH(tse[iface].mi.base, ALTERA_TSE_MAC_MAX_FRAME_LENGTH); 
 8224950:	008209b4 	movhi	r2,2086
 8224954:	10b70a04 	addi	r2,r2,-9176
 8224958:	e0ffff17 	ldw	r3,-4(fp)
 822495c:	18c01324 	muli	r3,r3,76
 8224960:	10c5883a 	add	r2,r2,r3
 8224964:	10800104 	addi	r2,r2,4
 8224968:	10800017 	ldw	r2,0(r2)
 822496c:	10800504 	addi	r2,r2,20
 8224970:	00c17b84 	movi	r3,1518
 8224974:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_ALMOST_EMPTY(tse[iface].mi.base, 8);
 8224978:	008209b4 	movhi	r2,2086
 822497c:	10b70a04 	addi	r2,r2,-9176
 8224980:	e0ffff17 	ldw	r3,-4(fp)
 8224984:	18c01324 	muli	r3,r3,76
 8224988:	10c5883a 	add	r2,r2,r3
 822498c:	10800104 	addi	r2,r2,4
 8224990:	10800017 	ldw	r2,0(r2)
 8224994:	10800b04 	addi	r2,r2,44
 8224998:	00c00204 	movi	r3,8
 822499c:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_ALMOST_FULL(tse[iface].mi.base, 8);
 82249a0:	008209b4 	movhi	r2,2086
 82249a4:	10b70a04 	addi	r2,r2,-9176
 82249a8:	e0ffff17 	ldw	r3,-4(fp)
 82249ac:	18c01324 	muli	r3,r3,76
 82249b0:	10c5883a 	add	r2,r2,r3
 82249b4:	10800104 	addi	r2,r2,4
 82249b8:	10800017 	ldw	r2,0(r2)
 82249bc:	10800c04 	addi	r2,r2,48
 82249c0:	00c00204 	movi	r3,8
 82249c4:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_ALMOST_EMPTY(tse[iface].mi.base, 8);
 82249c8:	008209b4 	movhi	r2,2086
 82249cc:	10b70a04 	addi	r2,r2,-9176
 82249d0:	e0ffff17 	ldw	r3,-4(fp)
 82249d4:	18c01324 	muli	r3,r3,76
 82249d8:	10c5883a 	add	r2,r2,r3
 82249dc:	10800104 	addi	r2,r2,4
 82249e0:	10800017 	ldw	r2,0(r2)
 82249e4:	10800d04 	addi	r2,r2,52
 82249e8:	00c00204 	movi	r3,8
 82249ec:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_ALMOST_FULL(tse[iface].mi.base,  3);
 82249f0:	008209b4 	movhi	r2,2086
 82249f4:	10b70a04 	addi	r2,r2,-9176
 82249f8:	e0ffff17 	ldw	r3,-4(fp)
 82249fc:	18c01324 	muli	r3,r3,76
 8224a00:	10c5883a 	add	r2,r2,r3
 8224a04:	10800104 	addi	r2,r2,4
 8224a08:	10800017 	ldw	r2,0(r2)
 8224a0c:	10800e04 	addi	r2,r2,56
 8224a10:	00c000c4 	movi	r3,3
 8224a14:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_SECTION_EMPTY(tse[iface].mi.base, tse_hw->tse_tx_depth - 16); //1024/4;  
 8224a18:	008209b4 	movhi	r2,2086
 8224a1c:	10b70a04 	addi	r2,r2,-9176
 8224a20:	e0ffff17 	ldw	r3,-4(fp)
 8224a24:	18c01324 	muli	r3,r3,76
 8224a28:	10c5883a 	add	r2,r2,r3
 8224a2c:	10800104 	addi	r2,r2,4
 8224a30:	10800017 	ldw	r2,0(r2)
 8224a34:	10800904 	addi	r2,r2,36
 8224a38:	e0fff917 	ldw	r3,-28(fp)
 8224a3c:	18c0010b 	ldhu	r3,4(r3)
 8224a40:	18ffffcc 	andi	r3,r3,65535
 8224a44:	18fffc04 	addi	r3,r3,-16
 8224a48:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_SECTION_FULL(tse[iface].mi.base,  0); //32/4; // start transmit when there are 48 bytes
 8224a4c:	008209b4 	movhi	r2,2086
 8224a50:	10b70a04 	addi	r2,r2,-9176
 8224a54:	e0ffff17 	ldw	r3,-4(fp)
 8224a58:	18c01324 	muli	r3,r3,76
 8224a5c:	10c5883a 	add	r2,r2,r3
 8224a60:	10800104 	addi	r2,r2,4
 8224a64:	10800017 	ldw	r2,0(r2)
 8224a68:	10800a04 	addi	r2,r2,40
 8224a6c:	0007883a 	mov	r3,zero
 8224a70:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_SECTION_EMPTY(tse[iface].mi.base, tse_hw->tse_rx_depth - 16); //4000/4);
 8224a74:	008209b4 	movhi	r2,2086
 8224a78:	10b70a04 	addi	r2,r2,-9176
 8224a7c:	e0ffff17 	ldw	r3,-4(fp)
 8224a80:	18c01324 	muli	r3,r3,76
 8224a84:	10c5883a 	add	r2,r2,r3
 8224a88:	10800104 	addi	r2,r2,4
 8224a8c:	10800017 	ldw	r2,0(r2)
 8224a90:	10800704 	addi	r2,r2,28
 8224a94:	e0fff917 	ldw	r3,-28(fp)
 8224a98:	18c0018b 	ldhu	r3,6(r3)
 8224a9c:	18ffffcc 	andi	r3,r3,65535
 8224aa0:	18fffc04 	addi	r3,r3,-16
 8224aa4:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_SECTION_FULL(tse[iface].mi.base,  0);
 8224aa8:	008209b4 	movhi	r2,2086
 8224aac:	10b70a04 	addi	r2,r2,-9176
 8224ab0:	e0ffff17 	ldw	r3,-4(fp)
 8224ab4:	18c01324 	muli	r3,r3,76
 8224ab8:	10c5883a 	add	r2,r2,r3
 8224abc:	10800104 	addi	r2,r2,4
 8224ac0:	10800017 	ldw	r2,0(r2)
 8224ac4:	10800804 	addi	r2,r2,32
 8224ac8:	0007883a 	mov	r3,zero
 8224acc:	10c00035 	stwio	r3,0(r2)
      tse[iface].rxShift16OK = 0;
    }
  } /* if(ETHHDR_BIAS == 0) */
 
  if(ETHHDR_BIAS == 2) {
    IOWR_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK);
 8224ad0:	008209b4 	movhi	r2,2086
 8224ad4:	10b70a04 	addi	r2,r2,-9176
 8224ad8:	e0ffff17 	ldw	r3,-4(fp)
 8224adc:	18c01324 	muli	r3,r3,76
 8224ae0:	10c5883a 	add	r2,r2,r3
 8224ae4:	10800104 	addi	r2,r2,4
 8224ae8:	10800017 	ldw	r2,0(r2)
 8224aec:	10803a04 	addi	r2,r2,232
 8224af0:	00c00134 	movhi	r3,4
 8224af4:	10c00035 	stwio	r3,0(r2)
 
    /*
     * check if the MAC supports the 16-bit shift option allowing us
     * to send BIASed frames without copying. Used by the send function later.
     */
    if(IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) &
 8224af8:	008209b4 	movhi	r2,2086
 8224afc:	10b70a04 	addi	r2,r2,-9176
 8224b00:	e0ffff17 	ldw	r3,-4(fp)
 8224b04:	18c01324 	muli	r3,r3,76
 8224b08:	10c5883a 	add	r2,r2,r3
 8224b0c:	10800104 	addi	r2,r2,4
 8224b10:	10800017 	ldw	r2,0(r2)
 8224b14:	10803a04 	addi	r2,r2,232
 8224b18:	10800037 	ldwio	r2,0(r2)
 8224b1c:	1080012c 	andhi	r2,r2,4
 8224b20:	10001e26 	beq	r2,zero,8224b9c <tse_mac_init+0x698>
      ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) {
      tse[iface].txShift16OK = 1;
 8224b24:	008209b4 	movhi	r2,2086
 8224b28:	10b70a04 	addi	r2,r2,-9176
 8224b2c:	e0ffff17 	ldw	r3,-4(fp)
 8224b30:	18c01324 	muli	r3,r3,76
 8224b34:	10c5883a 	add	r2,r2,r3
 8224b38:	10800a04 	addi	r2,r2,40
 8224b3c:	00c00044 	movi	r3,1
 8224b40:	10c00015 	stw	r3,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETHHDR_BIAS);
      return ENP_LOGIC;
    }
  
    /* Enable RX shift 16 for alignment of all received frames on 16-bit start address */
    IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
 8224b44:	008209b4 	movhi	r2,2086
 8224b48:	10b70a04 	addi	r2,r2,-9176
 8224b4c:	e0ffff17 	ldw	r3,-4(fp)
 8224b50:	18c01324 	muli	r3,r3,76
 8224b54:	10c5883a 	add	r2,r2,r3
 8224b58:	10800104 	addi	r2,r2,4
 8224b5c:	10800017 	ldw	r2,0(r2)
 8224b60:	10803b04 	addi	r2,r2,236
 8224b64:	00c08034 	movhi	r3,512
 8224b68:	10c00035 	stwio	r3,0(r2)
 
    /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
 8224b6c:	008209b4 	movhi	r2,2086
 8224b70:	10b70a04 	addi	r2,r2,-9176
 8224b74:	e0ffff17 	ldw	r3,-4(fp)
 8224b78:	18c01324 	muli	r3,r3,76
 8224b7c:	10c5883a 	add	r2,r2,r3
 8224b80:	10800104 	addi	r2,r2,4
 8224b84:	10800017 	ldw	r2,0(r2)
 8224b88:	10803b04 	addi	r2,r2,236
 8224b8c:	10800037 	ldwio	r2,0(r2)
 8224b90:	1080802c 	andhi	r2,r2,512
 8224b94:	10001d26 	beq	r2,zero,8224c0c <tse_mac_init+0x708>
 8224b98:	00000d06 	br	8224bd0 <tse_mac_init+0x6cc>
    if(IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) &
      ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) {
      tse[iface].txShift16OK = 1;
    } 
    else {
      tse[iface].txShift16OK = 0;
 8224b9c:	008209b4 	movhi	r2,2086
 8224ba0:	10b70a04 	addi	r2,r2,-9176
 8224ba4:	e0ffff17 	ldw	r3,-4(fp)
 8224ba8:	18c01324 	muli	r3,r3,76
 8224bac:	10c5883a 	add	r2,r2,r3
 8224bb0:	10800a04 	addi	r2,r2,40
 8224bb4:	10000015 	stw	zero,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETHHDR_BIAS);
 8224bb8:	01400084 	movi	r5,2
 8224bbc:	01020974 	movhi	r4,2085
 8224bc0:	213f2104 	addi	r4,r4,-892
 8224bc4:	82033a00 	call	82033a0 <printf>
      return ENP_LOGIC;
 8224bc8:	00bffd44 	movi	r2,-11
 8224bcc:	0000e006 	br	8224f50 <tse_mac_init+0xa4c>
    IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
 
    /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
    {
      tse[iface].rxShift16OK = 1;
 8224bd0:	008209b4 	movhi	r2,2086
 8224bd4:	10b70a04 	addi	r2,r2,-9176
 8224bd8:	e0ffff17 	ldw	r3,-4(fp)
 8224bdc:	18c01324 	muli	r3,r3,76
 8224be0:	10c5883a 	add	r2,r2,r3
 8224be4:	10800b04 	addi	r2,r2,44
 8224be8:	00c00044 	movi	r3,1
 8224bec:	10c00015 	stw	r3,0(r2)
      return ENP_LOGIC;
    }
  } /* if(ETHHDR_BIAS == 2) */
  
  /* enable MAC */
  dat = ALTERA_TSEMAC_CMD_TX_ENA_MSK       |
 8224bf0:	00810034 	movhi	r2,1024
 8224bf4:	108080c4 	addi	r2,r2,515
 8224bf8:	e0bff315 	stw	r2,-52(fp)
        ALTERA_TSEMAC_CMD_TX_ADDR_INS_MSK  |
        ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
  
  /* 1000 Mbps */
  if(speed == 0x01) {
 8224bfc:	e0bffd17 	ldw	r2,-12(fp)
 8224c00:	10800058 	cmpnei	r2,r2,1
 8224c04:	1000171e 	bne	r2,zero,8224c64 <tse_mac_init+0x760>
 8224c08:	00000d06 	br	8224c40 <tse_mac_init+0x73c>
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
    {
      tse[iface].rxShift16OK = 1;
    } 
    else {
      tse[iface].rxShift16OK = 0;
 8224c0c:	008209b4 	movhi	r2,2086
 8224c10:	10b70a04 	addi	r2,r2,-9176
 8224c14:	e0ffff17 	ldw	r3,-4(fp)
 8224c18:	18c01324 	muli	r3,r3,76
 8224c1c:	10c5883a 	add	r2,r2,r3
 8224c20:	10800b04 	addi	r2,r2,44
 8224c24:	10000015 	stw	zero,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with RX_CMD_STAT register return RxShift16 value. \n",ETHHDR_BIAS);
 8224c28:	01400084 	movi	r5,2
 8224c2c:	01020974 	movhi	r4,2085
 8224c30:	213f3904 	addi	r4,r4,-796
 8224c34:	82033a00 	call	82033a0 <printf>
      return ENP_LOGIC;
 8224c38:	00bffd44 	movi	r2,-11
 8224c3c:	0000c406 	br	8224f50 <tse_mac_init+0xa4c>
        ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
  
  /* 1000 Mbps */
  if(speed == 0x01) {
    dat |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 8224c40:	e0bff317 	ldw	r2,-52(fp)
 8224c44:	10800214 	ori	r2,r2,8
 8224c48:	e0bff315 	stw	r2,-52(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8224c4c:	e0fff317 	ldw	r3,-52(fp)
 8224c50:	00bf8034 	movhi	r2,65024
 8224c54:	10bfffc4 	addi	r2,r2,-1
 8224c58:	1884703a 	and	r2,r3,r2
 8224c5c:	e0bff315 	stw	r2,-52(fp)
 8224c60:	00002106 	br	8224ce8 <tse_mac_init+0x7e4>
  }
  /* 100 Mbps */
  else if(speed == 0x02) {
 8224c64:	e0bffd17 	ldw	r2,-12(fp)
 8224c68:	10800098 	cmpnei	r2,r2,2
 8224c6c:	10000a1e 	bne	r2,zero,8224c98 <tse_mac_init+0x794>
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 8224c70:	e0fff317 	ldw	r3,-52(fp)
 8224c74:	00bffdc4 	movi	r2,-9
 8224c78:	1884703a 	and	r2,r3,r2
 8224c7c:	e0bff315 	stw	r2,-52(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8224c80:	e0fff317 	ldw	r3,-52(fp)
 8224c84:	00bf8034 	movhi	r2,65024
 8224c88:	10bfffc4 	addi	r2,r2,-1
 8224c8c:	1884703a 	and	r2,r3,r2
 8224c90:	e0bff315 	stw	r2,-52(fp)
 8224c94:	00001406 	br	8224ce8 <tse_mac_init+0x7e4>
  }
  /* 10 Mbps */
  else if(speed == 0x04) {
 8224c98:	e0bffd17 	ldw	r2,-12(fp)
 8224c9c:	10800118 	cmpnei	r2,r2,4
 8224ca0:	1000081e 	bne	r2,zero,8224cc4 <tse_mac_init+0x7c0>
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 8224ca4:	e0fff317 	ldw	r3,-52(fp)
 8224ca8:	00bffdc4 	movi	r2,-9
 8224cac:	1884703a 	and	r2,r3,r2
 8224cb0:	e0bff315 	stw	r2,-52(fp)
	dat |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8224cb4:	e0bff317 	ldw	r2,-52(fp)
 8224cb8:	10808034 	orhi	r2,r2,512
 8224cbc:	e0bff315 	stw	r2,-52(fp)
 8224cc0:	00000906 	br	8224ce8 <tse_mac_init+0x7e4>
  }
  /* default to 100 Mbps if returned invalid speed */
  else {
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 8224cc4:	e0fff317 	ldw	r3,-52(fp)
 8224cc8:	00bffdc4 	movi	r2,-9
 8224ccc:	1884703a 	and	r2,r3,r2
 8224cd0:	e0bff315 	stw	r2,-52(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8224cd4:	e0fff317 	ldw	r3,-52(fp)
 8224cd8:	00bf8034 	movhi	r2,65024
 8224cdc:	10bfffc4 	addi	r2,r2,-1
 8224ce0:	1884703a 	and	r2,r3,r2
 8224ce4:	e0bff315 	stw	r2,-52(fp)
  }
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
 8224ce8:	e0bffe17 	ldw	r2,-8(fp)
 8224cec:	1000041e 	bne	r2,zero,8224d00 <tse_mac_init+0x7fc>
    dat |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 8224cf0:	e0bff317 	ldw	r2,-52(fp)
 8224cf4:	10810014 	ori	r2,r2,1024
 8224cf8:	e0bff315 	stw	r2,-52(fp)
 8224cfc:	00000406 	br	8224d10 <tse_mac_init+0x80c>
  }
  /* Full Duplex */
  else {
    dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 8224d00:	e0fff317 	ldw	r3,-52(fp)
 8224d04:	00beffc4 	movi	r2,-1025
 8224d08:	1884703a 	and	r2,r3,r2
 8224d0c:	e0bff315 	stw	r2,-52(fp)
  }
          
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
 8224d10:	008209b4 	movhi	r2,2086
 8224d14:	10b70a04 	addi	r2,r2,-9176
 8224d18:	e0ffff17 	ldw	r3,-4(fp)
 8224d1c:	18c01324 	muli	r3,r3,76
 8224d20:	10c5883a 	add	r2,r2,r3
 8224d24:	10800104 	addi	r2,r2,4
 8224d28:	10800017 	ldw	r2,0(r2)
 8224d2c:	10800204 	addi	r2,r2,8
 8224d30:	e0fff317 	ldw	r3,-52(fp)
 8224d34:	10c00035 	stwio	r3,0(r2)
  dprintf("\nMAC post-initialization: CMD_CONFIG=0x%08x\n", 
  IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base));
 8224d38:	008209b4 	movhi	r2,2086
 8224d3c:	10b70a04 	addi	r2,r2,-9176
 8224d40:	e0ffff17 	ldw	r3,-4(fp)
 8224d44:	18c01324 	muli	r3,r3,76
 8224d48:	10c5883a 	add	r2,r2,r3
 8224d4c:	10800104 	addi	r2,r2,4
 8224d50:	10800017 	ldw	r2,0(r2)
  else {
    dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
  }
          
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
  dprintf("\nMAC post-initialization: CMD_CONFIG=0x%08x\n", 
 8224d54:	10800204 	addi	r2,r2,8
 8224d58:	10800037 	ldwio	r2,0(r2)
 8224d5c:	100b883a 	mov	r5,r2
 8224d60:	01020974 	movhi	r4,2085
 8224d64:	213f5104 	addi	r4,r4,-700
 8224d68:	82033a00 	call	82033a0 <printf>
  IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base));
  
                          
#ifdef ALT_INICHE
   /* Set the MAC address */  
   IOWR_ALTERA_TSEMAC_MAC_0(tse[iface].mi.base,
 8224d6c:	008209b4 	movhi	r2,2086
 8224d70:	10b70a04 	addi	r2,r2,-9176
 8224d74:	e0ffff17 	ldw	r3,-4(fp)
 8224d78:	18c01324 	muli	r3,r3,76
 8224d7c:	10c5883a 	add	r2,r2,r3
 8224d80:	10800104 	addi	r2,r2,4
 8224d84:	10800017 	ldw	r2,0(r2)
 8224d88:	10c00304 	addi	r3,r2,12
 8224d8c:	008209b4 	movhi	r2,2086
 8224d90:	10b70a04 	addi	r2,r2,-9176
 8224d94:	e13fff17 	ldw	r4,-4(fp)
 8224d98:	21001324 	muli	r4,r4,76
 8224d9c:	1105883a 	add	r2,r2,r4
 8224da0:	10800604 	addi	r2,r2,24
 8224da4:	10800003 	ldbu	r2,0(r2)
 8224da8:	11003fcc 	andi	r4,r2,255
 8224dac:	008209b4 	movhi	r2,2086
 8224db0:	10b70a04 	addi	r2,r2,-9176
 8224db4:	e17fff17 	ldw	r5,-4(fp)
 8224db8:	29401324 	muli	r5,r5,76
 8224dbc:	1145883a 	add	r2,r2,r5
 8224dc0:	10800644 	addi	r2,r2,25
 8224dc4:	10800003 	ldbu	r2,0(r2)
 8224dc8:	10803fcc 	andi	r2,r2,255
 8224dcc:	1004923a 	slli	r2,r2,8
 8224dd0:	2088b03a 	or	r4,r4,r2
 8224dd4:	008209b4 	movhi	r2,2086
 8224dd8:	10b70a04 	addi	r2,r2,-9176
 8224ddc:	e17fff17 	ldw	r5,-4(fp)
 8224de0:	29401324 	muli	r5,r5,76
 8224de4:	1145883a 	add	r2,r2,r5
 8224de8:	10800684 	addi	r2,r2,26
 8224dec:	10800003 	ldbu	r2,0(r2)
 8224df0:	10803fcc 	andi	r2,r2,255
 8224df4:	1004943a 	slli	r2,r2,16
 8224df8:	2088b03a 	or	r4,r4,r2
 8224dfc:	008209b4 	movhi	r2,2086
 8224e00:	10b70a04 	addi	r2,r2,-9176
 8224e04:	e17fff17 	ldw	r5,-4(fp)
 8224e08:	29401324 	muli	r5,r5,76
 8224e0c:	1145883a 	add	r2,r2,r5
 8224e10:	108006c4 	addi	r2,r2,27
 8224e14:	10800003 	ldbu	r2,0(r2)
 8224e18:	10803fcc 	andi	r2,r2,255
 8224e1c:	1004963a 	slli	r2,r2,24
 8224e20:	2084b03a 	or	r2,r4,r2
 8224e24:	18800035 	stwio	r2,0(r3)
                           ((int)((unsigned char) tse[iface].mac_addr[0]) | 
                            (int)((unsigned char) tse[iface].mac_addr[1] <<  8) |
                            (int)((unsigned char) tse[iface].mac_addr[2] << 16) | 
                            (int)((unsigned char) tse[iface].mac_addr[3] << 24)));
  
   IOWR_ALTERA_TSEMAC_MAC_1(tse[iface].mi.base, 
 8224e28:	008209b4 	movhi	r2,2086
 8224e2c:	10b70a04 	addi	r2,r2,-9176
 8224e30:	e0ffff17 	ldw	r3,-4(fp)
 8224e34:	18c01324 	muli	r3,r3,76
 8224e38:	10c5883a 	add	r2,r2,r3
 8224e3c:	10800104 	addi	r2,r2,4
 8224e40:	10800017 	ldw	r2,0(r2)
 8224e44:	10c00404 	addi	r3,r2,16
 8224e48:	008209b4 	movhi	r2,2086
 8224e4c:	10b70a04 	addi	r2,r2,-9176
 8224e50:	e13fff17 	ldw	r4,-4(fp)
 8224e54:	21001324 	muli	r4,r4,76
 8224e58:	1105883a 	add	r2,r2,r4
 8224e5c:	10800704 	addi	r2,r2,28
 8224e60:	10800003 	ldbu	r2,0(r2)
 8224e64:	11003fcc 	andi	r4,r2,255
 8224e68:	008209b4 	movhi	r2,2086
 8224e6c:	10b70a04 	addi	r2,r2,-9176
 8224e70:	e17fff17 	ldw	r5,-4(fp)
 8224e74:	29401324 	muli	r5,r5,76
 8224e78:	1145883a 	add	r2,r2,r5
 8224e7c:	10800744 	addi	r2,r2,29
 8224e80:	10800003 	ldbu	r2,0(r2)
 8224e84:	10803fcc 	andi	r2,r2,255
 8224e88:	1004923a 	slli	r2,r2,8
 8224e8c:	2084b03a 	or	r2,r4,r2
 8224e90:	10bfffcc 	andi	r2,r2,65535
 8224e94:	18800035 	stwio	r2,0(r3)
   tse[iface].mac_addr[5] = 0xBA;

#endif /* not ALT_INICHE */

   /* status = UP */ 
   nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_UP;    
 8224e98:	008209b4 	movhi	r2,2086
 8224e9c:	10b81b04 	addi	r2,r2,-8084
 8224ea0:	e0ffff17 	ldw	r3,-4(fp)
 8224ea4:	18c7883a 	add	r3,r3,r3
 8224ea8:	18c7883a 	add	r3,r3,r3
 8224eac:	10c5883a 	add	r2,r2,r3
 8224eb0:	10800017 	ldw	r2,0(r2)
 8224eb4:	10802717 	ldw	r2,156(r2)
 8224eb8:	00c00044 	movi	r3,1
 8224ebc:	10c00615 	stw	r3,24(r2)
   nets[iface]->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_UP;
 8224ec0:	008209b4 	movhi	r2,2086
 8224ec4:	10b81b04 	addi	r2,r2,-8084
 8224ec8:	e0ffff17 	ldw	r3,-4(fp)
 8224ecc:	18c7883a 	add	r3,r3,r3
 8224ed0:	18c7883a 	add	r3,r3,r3
 8224ed4:	10c5883a 	add	r2,r2,r3
 8224ed8:	10800017 	ldw	r2,0(r2)
 8224edc:	10802717 	ldw	r2,156(r2)
 8224ee0:	00c00044 	movi	r3,1
 8224ee4:	10c00715 	stw	r3,28(r2)
   
   /* Install SGDMA (RX) interrupt handler */
   alt_avalon_sgdma_register_callback(
 8224ee8:	008209b4 	movhi	r2,2086
 8224eec:	10b70a04 	addi	r2,r2,-9176
 8224ef0:	e0ffff17 	ldw	r3,-4(fp)
 8224ef4:	18c01324 	muli	r3,r3,76
 8224ef8:	10c5883a 	add	r2,r2,r3
 8224efc:	10800304 	addi	r2,r2,12
 8224f00:	11000017 	ldw	r4,0(r2)
        tse[iface].mi.rx_sgdma,
        (alt_avalon_sgdma_callback)&tse_sgdmaRx_isr,
        (alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,
        (void*)(&tse[iface]));
 8224f04:	e0bfff17 	ldw	r2,-4(fp)
 8224f08:	10c01324 	muli	r3,r2,76
 8224f0c:	008209b4 	movhi	r2,2086
 8224f10:	10b70a04 	addi	r2,r2,-9176
 8224f14:	1885883a 	add	r2,r3,r2
   /* status = UP */ 
   nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_UP;    
   nets[iface]->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_UP;
   
   /* Install SGDMA (RX) interrupt handler */
   alt_avalon_sgdma_register_callback(
 8224f18:	100f883a 	mov	r7,r2
 8224f1c:	01800604 	movi	r6,24
 8224f20:	014208b4 	movhi	r5,2082
 8224f24:	29549704 	addi	r5,r5,21084
 8224f28:	821e8480 	call	821e848 <alt_avalon_sgdma_register_callback>
        tse[iface].mi.rx_sgdma,
        (alt_avalon_sgdma_callback)&tse_sgdmaRx_isr,
        (alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,
        (void*)(&tse[iface]));
    
  status = tse_sgdma_read_init(&tse[iface]);
 8224f2c:	e0bfff17 	ldw	r2,-4(fp)
 8224f30:	10c01324 	muli	r3,r2,76
 8224f34:	008209b4 	movhi	r2,2086
 8224f38:	10b70a04 	addi	r2,r2,-9176
 8224f3c:	1885883a 	add	r2,r3,r2
 8224f40:	1009883a 	mov	r4,r2
 8224f44:	82253080 	call	8225308 <tse_sgdma_read_init>
 8224f48:	e0bff815 	stw	r2,-32(fp)
  
  return status;
 8224f4c:	e0bff817 	ldw	r2,-32(fp)
}
 8224f50:	e037883a 	mov	sp,fp
 8224f54:	dfc00117 	ldw	ra,4(sp)
 8224f58:	df000017 	ldw	fp,0(sp)
 8224f5c:	dec00204 	addi	sp,sp,8
 8224f60:	f800283a 	ret

08224f64 <tse_mac_raw_send>:
 * @param  data - pointer to the data payload
 * @param  data_bytes - number of bytes of the data payload to be sent to the MAC
 * @return SUCCESS if success, else a negative value
 */
int tse_mac_raw_send(NET net, char * data, unsigned data_bytes)
{
 8224f64:	defe6504 	addi	sp,sp,-1644
 8224f68:	dfc19a15 	stw	ra,1640(sp)
 8224f6c:	df019915 	stw	fp,1636(sp)
 8224f70:	df019904 	addi	fp,sp,1636
 8224f74:	e13ffd15 	stw	r4,-12(fp)
 8224f78:	e17ffe15 	stw	r5,-8(fp)
 8224f7c:	e1bfff15 	stw	r6,-4(fp)
   int result,i;
   unsigned len = data_bytes;
 8224f80:	e0bfff17 	ldw	r2,-4(fp)
 8224f84:	e0be6e15 	stw	r2,-1608(fp)

   ins_tse_info* tse_ptr = (ins_tse_info*) net->n_local;
 8224f88:	e0bffd17 	ldw	r2,-12(fp)
 8224f8c:	10802817 	ldw	r2,160(r2)
 8224f90:	e0be6f15 	stw	r2,-1604(fp)

   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse_ptr->tse;
 8224f94:	e0be6f17 	ldw	r2,-1604(fp)
 8224f98:	10801217 	ldw	r2,72(r2)
 8224f9c:	e0be7015 	stw	r2,-1600(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8224fa0:	0005303a 	rdctl	r2,status
 8224fa4:	e0be7615 	stw	r2,-1576(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8224fa8:	e0fe7617 	ldw	r3,-1576(fp)
 8224fac:	00bfff84 	movi	r2,-2
 8224fb0:	1884703a 	and	r2,r3,r2
 8224fb4:	1001703a 	wrctl	status,r2
  
  return context;
 8224fb8:	e0be7617 	ldw	r2,-1576(fp)
   unsigned int* ActualData;
   int cpu_sr;
   /* Intermediate buffers used for temporary copy of frames that cannot be directrly DMA'ed*/
   char buf2[1560];

   OS_ENTER_CRITICAL();
 8224fbc:	e0be7215 	stw	r2,-1592(fp)
   mi = &tse_ptr->mi;
 8224fc0:	e0be6f17 	ldw	r2,-1604(fp)
 8224fc4:	10800104 	addi	r2,r2,4
 8224fc8:	e0be7315 	stw	r2,-1588(fp)
   
   if(tse_ptr->sem!=0) /* Tx is busy*/
 8224fcc:	e0be6f17 	ldw	r2,-1604(fp)
 8224fd0:	10800c17 	ldw	r2,48(r2)
 8224fd4:	10000926 	beq	r2,zero,8224ffc <tse_mac_raw_send+0x98>
   {
      dprintf("raw_send CALLED AGAIN!!!\n");
 8224fd8:	01020974 	movhi	r4,2085
 8224fdc:	213f5d04 	addi	r4,r4,-652
 8224fe0:	82036240 	call	8203624 <puts>
 8224fe4:	e0be7217 	ldw	r2,-1592(fp)
 8224fe8:	e0be7115 	stw	r2,-1596(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8224fec:	e0be7117 	ldw	r2,-1596(fp)
 8224ff0:	1001703a 	wrctl	status,r2
      OS_EXIT_CRITICAL();
      return ENP_RESOURCE;
 8224ff4:	00bffa84 	movi	r2,-22
 8224ff8:	00009306 	br	8225248 <tse_mac_raw_send+0x2e4>
   }
 
   tse_ptr->sem = 1;  
 8224ffc:	e0be6f17 	ldw	r2,-1604(fp)
 8225000:	00c00044 	movi	r3,1
 8225004:	10c00c15 	stw	r3,48(r2)

   if(((unsigned long)data & 0x03) == 0) 
 8225008:	e0bffe17 	ldw	r2,-8(fp)
 822500c:	108000cc 	andi	r2,r2,3
 8225010:	1000031e 	bne	r2,zero,8225020 <tse_mac_raw_send+0xbc>
   { 
      /* 32-bit aligned start, then header starts ETHHDR_BIAS later => 16 bit shift is ok */    
      ActualData = (unsigned int*)data;  /* base driver will detect 16-bit shift. */
 8225014:	e0bffe17 	ldw	r2,-8(fp)
 8225018:	e0be6d15 	stw	r2,-1612(fp)
 822501c:	00001406 	br	8225070 <tse_mac_raw_send+0x10c>
      /* 
       * Copy data to temporary buffer <buf2>. This is done because of allignment 
       * issues. The SGDMA cannot copy the data directly from (data + ETHHDR_BIAS)
       * because it needs a 32-bit alligned address space. 
       */
      for(i=0;i<len;i++) {
 8225020:	e03e6c15 	stw	zero,-1616(fp)
 8225024:	00000d06 	br	822505c <tse_mac_raw_send+0xf8>
         buf2[i] = IORD_8DIRECT(&data[i], 0);
 8225028:	e0be6c17 	ldw	r2,-1616(fp)
 822502c:	e0fffe17 	ldw	r3,-8(fp)
 8225030:	1885883a 	add	r2,r3,r2
 8225034:	10800023 	ldbuio	r2,0(r2)
 8225038:	10803fcc 	andi	r2,r2,255
 822503c:	1009883a 	mov	r4,r2
 8225040:	e0fe7704 	addi	r3,fp,-1572
 8225044:	e0be6c17 	ldw	r2,-1616(fp)
 8225048:	1885883a 	add	r2,r3,r2
 822504c:	11000005 	stb	r4,0(r2)
      /* 
       * Copy data to temporary buffer <buf2>. This is done because of allignment 
       * issues. The SGDMA cannot copy the data directly from (data + ETHHDR_BIAS)
       * because it needs a 32-bit alligned address space. 
       */
      for(i=0;i<len;i++) {
 8225050:	e0be6c17 	ldw	r2,-1616(fp)
 8225054:	10800044 	addi	r2,r2,1
 8225058:	e0be6c15 	stw	r2,-1616(fp)
 822505c:	e0fe6c17 	ldw	r3,-1616(fp)
 8225060:	e0be6e17 	ldw	r2,-1608(fp)
 8225064:	18bff036 	bltu	r3,r2,8225028 <tse_mac_raw_send+0xc4>
         buf2[i] = IORD_8DIRECT(&data[i], 0);
      }
      ActualData = (unsigned int*)buf2;
 8225068:	e0be7704 	addi	r2,fp,-1572
 822506c:	e0be6d15 	stw	r2,-1612(fp)
   }  
   
     // clear bit-31 before passing it to SGDMA Driver
    ActualData = (unsigned int*)alt_remap_cached ((volatile void*) ActualData, 4);
 8225070:	01400104 	movi	r5,4
 8225074:	e13e6d17 	ldw	r4,-1612(fp)
 8225078:	823c7b00 	call	823c7b0 <alt_remap_cached>
 822507c:	e0be6d15 	stw	r2,-1612(fp)

   /* Write data to Tx FIFO using the DMA */
   if((tse_hw->use_shared_fifo == 1) && (( len > ALTERA_TSE_MIN_MTU_SIZE )) && (IORD_ALTERA_MULTI_CHAN_FILL_LEVEL(tse_hw->tse_shared_fifo_tx_stat_base, tse_ptr->channel) < ALTERA_TSE_MIN_MTU_SIZE))
 8225080:	e0be7017 	ldw	r2,-1600(fp)
 8225084:	10800903 	ldbu	r2,36(r2)
 8225088:	10803fcc 	andi	r2,r2,255
 822508c:	10800058 	cmpnei	r2,r2,1
 8225090:	1000271e 	bne	r2,zero,8225130 <tse_mac_raw_send+0x1cc>
 8225094:	e0be6e17 	ldw	r2,-1608(fp)
 8225098:	108003f0 	cmpltui	r2,r2,15
 822509c:	1000241e 	bne	r2,zero,8225130 <tse_mac_raw_send+0x1cc>
 82250a0:	e0be6f17 	ldw	r2,-1604(fp)
 82250a4:	10800d17 	ldw	r2,52(r2)
 82250a8:	1085883a 	add	r2,r2,r2
 82250ac:	1085883a 	add	r2,r2,r2
 82250b0:	1007883a 	mov	r3,r2
 82250b4:	e0be7017 	ldw	r2,-1600(fp)
 82250b8:	10800b17 	ldw	r2,44(r2)
 82250bc:	1885883a 	add	r2,r3,r2
 82250c0:	10800037 	ldwio	r2,0(r2)
 82250c4:	10800388 	cmpgei	r2,r2,14
 82250c8:	1000191e 	bne	r2,zero,8225130 <tse_mac_raw_send+0x1cc>
   {
        /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 82250cc:	e0be6f17 	ldw	r2,-1604(fp)
 82250d0:	10c00f17 	ldw	r3,60(r2)
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
 82250d4:	e0be6f17 	ldw	r2,-1604(fp)
 82250d8:	10800f17 	ldw	r2,60(r2)

   /* Write data to Tx FIFO using the DMA */
   if((tse_hw->use_shared_fifo == 1) && (( len > ALTERA_TSE_MIN_MTU_SIZE )) && (IORD_ALTERA_MULTI_CHAN_FILL_LEVEL(tse_hw->tse_shared_fifo_tx_stat_base, tse_ptr->channel) < ALTERA_TSE_MIN_MTU_SIZE))
   {
        /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 82250dc:	11000804 	addi	r4,r2,32
 82250e0:	e0be6e17 	ldw	r2,-1608(fp)
 82250e4:	117fffcc 	andi	r5,r2,65535
 82250e8:	d8000315 	stw	zero,12(sp)
 82250ec:	00800044 	movi	r2,1
 82250f0:	d8800215 	stw	r2,8(sp)
 82250f4:	00800044 	movi	r2,1
 82250f8:	d8800115 	stw	r2,4(sp)
 82250fc:	d8000015 	stw	zero,0(sp)
 8225100:	280f883a 	mov	r7,r5
 8225104:	e1be6d17 	ldw	r6,-1612(fp)
 8225108:	200b883a 	mov	r5,r4
 822510c:	1809883a 	mov	r4,r3
 8225110:	821e73c0 	call	821e73c <alt_avalon_sgdma_construct_mem_to_stream_desc>
           0,                                        // don't read from constant address
           1,                                        // generate sop
           1,                                        // generate endofpacket signal
           0);                                       // atlantic channel (don't know/don't care: set to 0)

        tse_mac_sTxWrite(mi,tse_ptr->desc);
 8225114:	e0be6f17 	ldw	r2,-1604(fp)
 8225118:	10800f17 	ldw	r2,60(r2)
 822511c:	100b883a 	mov	r5,r2
 8225120:	e13e7317 	ldw	r4,-1588(fp)
 8225124:	821f2140 	call	821f214 <tse_mac_sTxWrite>
        result = 0;
 8225128:	e03e6b15 	stw	zero,-1620(fp)
 822512c:	00001e06 	br	82251a8 <tse_mac_raw_send+0x244>
   }
   else if( len > ALTERA_TSE_MIN_MTU_SIZE ) {    
 8225130:	e0be6e17 	ldw	r2,-1608(fp)
 8225134:	108003f0 	cmpltui	r2,r2,15
 8225138:	1000191e 	bne	r2,zero,82251a0 <tse_mac_raw_send+0x23c>

       /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 822513c:	e0be6f17 	ldw	r2,-1604(fp)
 8225140:	10c00f17 	ldw	r3,60(r2)
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
 8225144:	e0be6f17 	ldw	r2,-1604(fp)
 8225148:	10800f17 	ldw	r2,60(r2)
        result = 0;
   }
   else if( len > ALTERA_TSE_MIN_MTU_SIZE ) {    

       /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 822514c:	11000804 	addi	r4,r2,32
 8225150:	e0be6e17 	ldw	r2,-1608(fp)
 8225154:	117fffcc 	andi	r5,r2,65535
 8225158:	d8000315 	stw	zero,12(sp)
 822515c:	00800044 	movi	r2,1
 8225160:	d8800215 	stw	r2,8(sp)
 8225164:	00800044 	movi	r2,1
 8225168:	d8800115 	stw	r2,4(sp)
 822516c:	d8000015 	stw	zero,0(sp)
 8225170:	280f883a 	mov	r7,r5
 8225174:	e1be6d17 	ldw	r6,-1612(fp)
 8225178:	200b883a 	mov	r5,r4
 822517c:	1809883a 	mov	r4,r3
 8225180:	821e73c0 	call	821e73c <alt_avalon_sgdma_construct_mem_to_stream_desc>
           1,                                        // generate sop
           1,                                        // generate endofpacket signal
           0);                                       // atlantic channel (don't know/don't care: set to 0)
                  
    
       tse_mac_sTxWrite(mi,tse_ptr->desc);
 8225184:	e0be6f17 	ldw	r2,-1604(fp)
 8225188:	10800f17 	ldw	r2,60(r2)
 822518c:	100b883a 	mov	r5,r2
 8225190:	e13e7317 	ldw	r4,-1588(fp)
 8225194:	821f2140 	call	821f214 <tse_mac_sTxWrite>
       result = 0;
 8225198:	e03e6b15 	stw	zero,-1620(fp)
 822519c:	00000206 	br	82251a8 <tse_mac_raw_send+0x244>

   } else {
       result = -3;
 82251a0:	00bfff44 	movi	r2,-3
 82251a4:	e0be6b15 	stw	r2,-1620(fp)
   }

   if(result < 0)   /* SGDMA not available */
 82251a8:	e0be6b17 	ldw	r2,-1620(fp)
 82251ac:	1000120e 	bge	r2,zero,82251f8 <tse_mac_raw_send+0x294>
   {
      dprintf("raw_send() SGDMA not available, ret=%d, len=%d\n",result, len);
 82251b0:	e1be6e17 	ldw	r6,-1608(fp)
 82251b4:	e17e6b17 	ldw	r5,-1620(fp)
 82251b8:	01020974 	movhi	r4,2085
 82251bc:	213f6404 	addi	r4,r4,-624
 82251c0:	82033a00 	call	82033a0 <printf>
      net->n_mib->ifOutDiscards++;
 82251c4:	e0bffd17 	ldw	r2,-12(fp)
 82251c8:	10802717 	ldw	r2,156(r2)
 82251cc:	10c01217 	ldw	r3,72(r2)
 82251d0:	18c00044 	addi	r3,r3,1
 82251d4:	10c01215 	stw	r3,72(r2)
      tse_ptr->sem = 0;
 82251d8:	e0be6f17 	ldw	r2,-1604(fp)
 82251dc:	10000c15 	stw	zero,48(r2)
 82251e0:	e0be7217 	ldw	r2,-1592(fp)
 82251e4:	e0be7415 	stw	r2,-1584(fp)
 82251e8:	e0be7417 	ldw	r2,-1584(fp)
 82251ec:	1001703a 	wrctl	status,r2

      OS_EXIT_CRITICAL();
      return SEND_DROPPED;   /* ENP_RESOURCE and SEND_DROPPED have the same value! */
 82251f0:	00bffa84 	movi	r2,-22
 82251f4:	00001406 	br	8225248 <tse_mac_raw_send+0x2e4>
   }
   else   /* = 0, success */
   {
      net->n_mib->ifOutOctets += data_bytes;
 82251f8:	e0bffd17 	ldw	r2,-12(fp)
 82251fc:	10802717 	ldw	r2,156(r2)
 8225200:	e0fffd17 	ldw	r3,-12(fp)
 8225204:	18c02717 	ldw	r3,156(r3)
 8225208:	19000f17 	ldw	r4,60(r3)
 822520c:	e0ffff17 	ldw	r3,-4(fp)
 8225210:	20c7883a 	add	r3,r4,r3
 8225214:	10c00f15 	stw	r3,60(r2)
      /* we dont know whether it was unicast or not, we count both in <ifOutUcastPkts> */
      net->n_mib->ifOutUcastPkts++;
 8225218:	e0bffd17 	ldw	r2,-12(fp)
 822521c:	10802717 	ldw	r2,156(r2)
 8225220:	10c01017 	ldw	r3,64(r2)
 8225224:	18c00044 	addi	r3,r3,1
 8225228:	10c01015 	stw	r3,64(r2)
      tse_ptr->sem = 0;
 822522c:	e0be6f17 	ldw	r2,-1604(fp)
 8225230:	10000c15 	stw	zero,48(r2)
 8225234:	e0be7217 	ldw	r2,-1592(fp)
 8225238:	e0be7515 	stw	r2,-1580(fp)
 822523c:	e0be7517 	ldw	r2,-1580(fp)
 8225240:	1001703a 	wrctl	status,r2

      OS_EXIT_CRITICAL();
      return SUCCESS;  /*success */
 8225244:	0005883a 	mov	r2,zero
   }
}
 8225248:	e037883a 	mov	sp,fp
 822524c:	dfc00117 	ldw	ra,4(sp)
 8225250:	df000017 	ldw	fp,0(sp)
 8225254:	dec00204 	addi	sp,sp,8
 8225258:	f800283a 	ret

0822525c <tse_sgdmaRx_isr>:
 * @API TYPE - callback
 * @param  context  - context of the TSE MAC instance
 * @param  intnum - temporary storage
 */
void tse_sgdmaRx_isr(void * context)
{
 822525c:	defffa04 	addi	sp,sp,-24
 8225260:	dfc00515 	stw	ra,20(sp)
 8225264:	df000415 	stw	fp,16(sp)
 8225268:	df000404 	addi	fp,sp,16
 822526c:	e13fff15 	stw	r4,-4(fp)
  ins_tse_info* tse_ptr = (ins_tse_info *) context; 
 8225270:	e0bfff17 	ldw	r2,-4(fp)
 8225274:	e0bffc15 	stw	r2,-16(fp)
  alt_u8 sgdma_status;
  
  /* Capture whether there are existing packets on stack rcv queue */
  int initial_rcvdq_len = rcvdq.q_len;
 8225278:	008209b4 	movhi	r2,2086
 822527c:	10b75604 	addi	r2,r2,-8872
 8225280:	10800217 	ldw	r2,8(r2)
 8225284:	e0bffd15 	stw	r2,-12(fp)
   * IO read to peripheral that generated the IRQ is done after IO write
   * to negate the interrupt request. This ensures at the IO write reaches 
   * the peripheral (through any high-latency hardware in the system)
   * before the ISR exits.
   */   
  sgdma_status = IORD_ALTERA_AVALON_SGDMA_STATUS(tse_ptr->mi.rx_sgdma->base);
 8225288:	e0bffc17 	ldw	r2,-16(fp)
 822528c:	10800317 	ldw	r2,12(r2)
 8225290:	10800317 	ldw	r2,12(r2)
 8225294:	10800037 	ldwio	r2,0(r2)
 8225298:	e0bffe05 	stb	r2,-8(fp)
  
  /* Why are we here; should we be? */
  if(sgdma_status & (ALTERA_AVALON_SGDMA_STATUS_CHAIN_COMPLETED_MSK | 
 822529c:	e0bffe03 	ldbu	r2,-8(fp)
 82252a0:	1080030c 	andi	r2,r2,12
 82252a4:	10001226 	beq	r2,zero,82252f0 <tse_sgdmaRx_isr+0x94>
                     ALTERA_AVALON_SGDMA_STATUS_DESC_COMPLETED_MSK) ) {
    /* Handle received packet(s) */
    tse_mac_rcv(tse_ptr); 
 82252a8:	e13ffc17 	ldw	r4,-16(fp)
 82252ac:	82254b40 	call	82254b4 <tse_mac_rcv>
        tse_ptr->mi.rx_sgdma, 
        &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
    }
#else
    /* Re-start SGDMA (always, if we have a single descriptor) */
    alt_avalon_sgdma_do_async_transfer(
 82252b0:	e0bffc17 	ldw	r2,-16(fp)
 82252b4:	10c00317 	ldw	r3,12(r2)
      tse_ptr->mi.rx_sgdma, 
      &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
 82252b8:	e0bffc17 	ldw	r2,-16(fp)
 82252bc:	10800f17 	ldw	r2,60(r2)
        tse_ptr->mi.rx_sgdma, 
        &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
    }
#else
    /* Re-start SGDMA (always, if we have a single descriptor) */
    alt_avalon_sgdma_do_async_transfer(
 82252c0:	10801004 	addi	r2,r2,64
 82252c4:	100b883a 	mov	r5,r2
 82252c8:	1809883a 	mov	r4,r3
 82252cc:	821e3380 	call	821e338 <alt_avalon_sgdma_do_async_transfer>
      tse_ptr->mi.rx_sgdma, 
      &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
#endif
  
    /* Wake up Niche stack if there are new packets are on queue */
    if ((rcvdq.q_len) > initial_rcvdq_len) {
 82252d0:	008209b4 	movhi	r2,2086
 82252d4:	10b75604 	addi	r2,r2,-8872
 82252d8:	10800217 	ldw	r2,8(r2)
 82252dc:	e0fffd17 	ldw	r3,-12(fp)
 82252e0:	1880030e 	bge	r3,r2,82252f0 <tse_sgdmaRx_isr+0x94>
      SignalPktDemux();
 82252e4:	d0a0ab17 	ldw	r2,-32084(gp)
 82252e8:	1009883a 	mov	r4,r2
 82252ec:	821a44c0 	call	821a44c <OSSemPost>
    }  
  } /* if (valid SGDMA interrupt) */
}
 82252f0:	0001883a 	nop
 82252f4:	e037883a 	mov	sp,fp
 82252f8:	dfc00117 	ldw	ra,4(sp)
 82252fc:	df000017 	ldw	fp,0(sp)
 8225300:	dec00204 	addi	sp,sp,8
 8225304:	f800283a 	ret

08225308 <tse_sgdma_read_init>:
 * 
 * @API TYPE - Internal
 * @return SUCCESS on success 
 */
int tse_sgdma_read_init(ins_tse_info* tse_ptr)
{     
 8225308:	defffa04 	addi	sp,sp,-24
 822530c:	dfc00515 	stw	ra,20(sp)
 8225310:	df000415 	stw	fp,16(sp)
 8225314:	dc000315 	stw	r16,12(sp)
 8225318:	df000404 	addi	fp,sp,16
 822531c:	e13ffe15 	stw	r4,-8(fp)
  alt_u32 *uncached_packet_payload;
  
  for(tse_ptr->chain_loop = 0; tse_ptr->chain_loop < ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE; tse_ptr->chain_loop++)
 8225320:	e0bffe17 	ldw	r2,-8(fp)
 8225324:	10000e15 	stw	zero,56(r2)
 8225328:	00004406 	br	822543c <tse_sgdma_read_init+0x134>
  { 
    tse_ptr->pkt_array[tse_ptr->chain_loop] = pk_alloc(ALTERA_TSE_PKT_INIT_LEN+4);
 822532c:	e0bffe17 	ldw	r2,-8(fp)
 8225330:	14000e17 	ldw	r16,56(r2)
 8225334:	01017f04 	movi	r4,1532
 8225338:	822c9ec0 	call	822c9ec <pk_alloc>
 822533c:	1009883a 	mov	r4,r2
 8225340:	e0fffe17 	ldw	r3,-8(fp)
 8225344:	80800444 	addi	r2,r16,17
 8225348:	1085883a 	add	r2,r2,r2
 822534c:	1085883a 	add	r2,r2,r2
 8225350:	1885883a 	add	r2,r3,r2
 8225354:	11000015 	stw	r4,0(r2)
    
    if (!tse_ptr->pkt_array[tse_ptr->chain_loop])   /* couldn't get a free buffer for rx */
 8225358:	e0bffe17 	ldw	r2,-8(fp)
 822535c:	10800e17 	ldw	r2,56(r2)
 8225360:	e0fffe17 	ldw	r3,-8(fp)
 8225364:	10800444 	addi	r2,r2,17
 8225368:	1085883a 	add	r2,r2,r2
 822536c:	1085883a 	add	r2,r2,r2
 8225370:	1885883a 	add	r2,r3,r2
 8225374:	10800017 	ldw	r2,0(r2)
 8225378:	10000b1e 	bne	r2,zero,82253a8 <tse_sgdma_read_init+0xa0>
    {
      dprintf("[tse_sgdma_read_init] Fatal error: No free packet buffers for RX\n");
 822537c:	01020974 	movhi	r4,2085
 8225380:	213f7004 	addi	r4,r4,-576
 8225384:	82036240 	call	8203624 <puts>
      tse_ptr->netp->n_mib->ifInDiscards++;
 8225388:	e0bffe17 	ldw	r2,-8(fp)
 822538c:	10800817 	ldw	r2,32(r2)
 8225390:	10802717 	ldw	r2,156(r2)
 8225394:	10c00c17 	ldw	r3,48(r2)
 8225398:	18c00044 	addi	r3,r3,1
 822539c:	10c00c15 	stw	r3,48(r2)
      
      return ENP_NOBUFFER;
 82253a0:	00bffac4 	movi	r2,-21
 82253a4:	00003d06 	br	822549c <tse_sgdma_read_init+0x194>
    }
    
    // ensure bit-31 of tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff is clear before passing
    // to SGDMA Driver
    uncached_packet_payload = (alt_u32 *)alt_remap_cached ((volatile void*) tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);
 82253a8:	e0bffe17 	ldw	r2,-8(fp)
 82253ac:	10800e17 	ldw	r2,56(r2)
 82253b0:	e0fffe17 	ldw	r3,-8(fp)
 82253b4:	10800444 	addi	r2,r2,17
 82253b8:	1085883a 	add	r2,r2,r2
 82253bc:	1085883a 	add	r2,r2,r2
 82253c0:	1885883a 	add	r2,r3,r2
 82253c4:	10800017 	ldw	r2,0(r2)
 82253c8:	10800117 	ldw	r2,4(r2)
 82253cc:	01400104 	movi	r5,4
 82253d0:	1009883a 	mov	r4,r2
 82253d4:	823c7b00 	call	823c7b0 <alt_remap_cached>
 82253d8:	e0bffd15 	stw	r2,-12(fp)

    alt_avalon_sgdma_construct_stream_to_mem_desc(
            (alt_sgdma_descriptor *) &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
 82253dc:	e0bffe17 	ldw	r2,-8(fp)
 82253e0:	10c00f17 	ldw	r3,60(r2)
 82253e4:	e0bffe17 	ldw	r2,-8(fp)
 82253e8:	10800e17 	ldw	r2,56(r2)
    
    // ensure bit-31 of tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff is clear before passing
    // to SGDMA Driver
    uncached_packet_payload = (alt_u32 *)alt_remap_cached ((volatile void*) tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);

    alt_avalon_sgdma_construct_stream_to_mem_desc(
 82253ec:	10800084 	addi	r2,r2,2
 82253f0:	1004917a 	slli	r2,r2,5
 82253f4:	1889883a 	add	r4,r3,r2
            (alt_sgdma_descriptor *) &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
            (alt_sgdma_descriptor *) &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST], // pointer to "next"
 82253f8:	e0bffe17 	ldw	r2,-8(fp)
 82253fc:	10c00f17 	ldw	r3,60(r2)
 8225400:	e0bffe17 	ldw	r2,-8(fp)
 8225404:	10800e17 	ldw	r2,56(r2)
    
    // ensure bit-31 of tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff is clear before passing
    // to SGDMA Driver
    uncached_packet_payload = (alt_u32 *)alt_remap_cached ((volatile void*) tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);

    alt_avalon_sgdma_construct_stream_to_mem_desc(
 8225408:	108000c4 	addi	r2,r2,3
 822540c:	1004917a 	slli	r2,r2,5
 8225410:	1885883a 	add	r2,r3,r2
 8225414:	d8000015 	stw	zero,0(sp)
 8225418:	000f883a 	mov	r7,zero
 822541c:	e1bffd17 	ldw	r6,-12(fp)
 8225420:	100b883a 	mov	r5,r2
 8225424:	821e6640 	call	821e664 <alt_avalon_sgdma_construct_stream_to_mem_desc>
 */
int tse_sgdma_read_init(ins_tse_info* tse_ptr)
{     
  alt_u32 *uncached_packet_payload;
  
  for(tse_ptr->chain_loop = 0; tse_ptr->chain_loop < ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE; tse_ptr->chain_loop++)
 8225428:	e0bffe17 	ldw	r2,-8(fp)
 822542c:	10800e17 	ldw	r2,56(r2)
 8225430:	10c00044 	addi	r3,r2,1
 8225434:	e0bffe17 	ldw	r2,-8(fp)
 8225438:	10c00e15 	stw	r3,56(r2)
 822543c:	e0bffe17 	ldw	r2,-8(fp)
 8225440:	10800e17 	ldw	r2,56(r2)
 8225444:	00bfb90e 	bge	zero,r2,822532c <tse_sgdma_read_init+0x24>
            0,                          // read until EOP
            0);                         // don't write to constant address

  } // for

  dprintf("[tse_sgdma_read_init] RX descriptor chain desc (%d depth) created\n", 
 8225448:	e0bffe17 	ldw	r2,-8(fp)
 822544c:	10800e17 	ldw	r2,56(r2)
 8225450:	100b883a 	mov	r5,r2
 8225454:	01020974 	movhi	r4,2085
 8225458:	213f8104 	addi	r4,r4,-508
 822545c:	82033a00 	call	82033a0 <printf>
    tse_ptr->chain_loop);
   
  tse_ptr->chain_loop = 0;
 8225460:	e0bffe17 	ldw	r2,-8(fp)
 8225464:	10000e15 	stw	zero,56(r2)
  tse_ptr->currdescriptor_ptr =  &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
 8225468:	e0bffe17 	ldw	r2,-8(fp)
 822546c:	10800f17 	ldw	r2,60(r2)
 8225470:	10c01004 	addi	r3,r2,64
 8225474:	e0bffe17 	ldw	r2,-8(fp)
 8225478:	10c01015 	stw	r3,64(r2)

  tse_mac_aRxRead( &tse_ptr->mi, tse_ptr->currdescriptor_ptr);
 822547c:	e0bffe17 	ldw	r2,-8(fp)
 8225480:	10c00104 	addi	r3,r2,4
 8225484:	e0bffe17 	ldw	r2,-8(fp)
 8225488:	10801017 	ldw	r2,64(r2)
 822548c:	100b883a 	mov	r5,r2
 8225490:	1809883a 	mov	r4,r3
 8225494:	821f2f80 	call	821f2f8 <tse_mac_aRxRead>
  
  return SUCCESS;
 8225498:	0005883a 	mov	r2,zero
}
 822549c:	e6ffff04 	addi	sp,fp,-4
 82254a0:	dfc00217 	ldw	ra,8(sp)
 82254a4:	df000117 	ldw	fp,4(sp)
 82254a8:	dc000017 	ldw	r16,0(sp)
 82254ac:	dec00304 	addi	sp,sp,12
 82254b0:	f800283a 	ret

082254b4 <tse_mac_rcv>:
 * @API TYPE        - callback internal function
 * @return SUCCESS on success
 */

ALT_INLINE void tse_mac_rcv(ins_tse_info* tse_ptr)
{     
 82254b4:	defff704 	addi	sp,sp,-36
 82254b8:	dfc00815 	stw	ra,32(sp)
 82254bc:	df000715 	stw	fp,28(sp)
 82254c0:	df000704 	addi	fp,sp,28
 82254c4:	e13fff15 	stw	r4,-4(fp)
  PACKET rx_packet;
  alt_u32 *uncached_packet_payload;
  alt_u8 desc_status;

  tse_ptr->currdescriptor_ptr = 
    &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
 82254c8:	e0bfff17 	ldw	r2,-4(fp)
 82254cc:	10c00f17 	ldw	r3,60(r2)
 82254d0:	e0bfff17 	ldw	r2,-4(fp)
 82254d4:	10800e17 	ldw	r2,56(r2)
 82254d8:	10800084 	addi	r2,r2,2
 82254dc:	1004917a 	slli	r2,r2,5
 82254e0:	1887883a 	add	r3,r3,r2
  PACKET replacement_pkt;
  PACKET rx_packet;
  alt_u32 *uncached_packet_payload;
  alt_u8 desc_status;

  tse_ptr->currdescriptor_ptr = 
 82254e4:	e0bfff17 	ldw	r2,-4(fp)
 82254e8:	10c01015 	stw	r3,64(r2)
    &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
  
  /* Grab status bits from descriptor under test. Bypass cache */
  desc_status = IORD_ALTERA_TSE_SGDMA_DESC_STATUS(tse_ptr->currdescriptor_ptr);
 82254ec:	e0bfff17 	ldw	r2,-4(fp)
 82254f0:	10801017 	ldw	r2,64(r2)
 82254f4:	10800704 	addi	r2,r2,28
 82254f8:	10800037 	ldwio	r2,0(r2)
 82254fc:	1005d43a 	srai	r2,r2,16
 8225500:	e0bff905 	stb	r2,-28(fp)
  while ( desc_status & 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_TERMINATED_BY_EOP_MSK )
#endif
{      
    /* Correct frame length to actual (this is different from TX side) */
    pklen = IORD_16DIRECT(&tse_ptr->currdescriptor_ptr->actual_bytes_transferred, 0) - 2;
 8225504:	e0bfff17 	ldw	r2,-4(fp)
 8225508:	10801017 	ldw	r2,64(r2)
 822550c:	10800704 	addi	r2,r2,28
 8225510:	1080002b 	ldhuio	r2,0(r2)
 8225514:	10bfffcc 	andi	r2,r2,65535
 8225518:	10bfff84 	addi	r2,r2,-2
 822551c:	e0bffa15 	stw	r2,-24(fp)
    tse_ptr->netp->n_mib->ifInOctets += (u_long)pklen;
 8225520:	e0bfff17 	ldw	r2,-4(fp)
 8225524:	10800817 	ldw	r2,32(r2)
 8225528:	10802717 	ldw	r2,156(r2)
 822552c:	e0ffff17 	ldw	r3,-4(fp)
 8225530:	18c00817 	ldw	r3,32(r3)
 8225534:	18c02717 	ldw	r3,156(r3)
 8225538:	19000917 	ldw	r4,36(r3)
 822553c:	e0fffa17 	ldw	r3,-24(fp)
 8225540:	20c7883a 	add	r3,r4,r3
 8225544:	10c00915 	stw	r3,36(r2)
  
    rx_packet = tse_ptr->pkt_array[tse_ptr->chain_loop];   
 8225548:	e0bfff17 	ldw	r2,-4(fp)
 822554c:	10800e17 	ldw	r2,56(r2)
 8225550:	e0ffff17 	ldw	r3,-4(fp)
 8225554:	10800444 	addi	r2,r2,17
 8225558:	1085883a 	add	r2,r2,r2
 822555c:	1085883a 	add	r2,r2,r2
 8225560:	1885883a 	add	r2,r3,r2
 8225564:	10800017 	ldw	r2,0(r2)
 8225568:	e0bffb15 	stw	r2,-20(fp)
    
    rx_packet->nb_prot = rx_packet->nb_buff + ETHHDR_SIZE;
 822556c:	e0bffb17 	ldw	r2,-20(fp)
 8225570:	10800117 	ldw	r2,4(r2)
 8225574:	10c00404 	addi	r3,r2,16
 8225578:	e0bffb17 	ldw	r2,-20(fp)
 822557c:	10c00315 	stw	r3,12(r2)
    rx_packet->nb_plen = pklen - 14;
 8225580:	e0bffa17 	ldw	r2,-24(fp)
 8225584:	10bffc84 	addi	r2,r2,-14
 8225588:	1007883a 	mov	r3,r2
 822558c:	e0bffb17 	ldw	r2,-20(fp)
 8225590:	10c00415 	stw	r3,16(r2)
    rx_packet->nb_tstamp = cticks;
 8225594:	d0a0a817 	ldw	r2,-32096(gp)
 8225598:	1007883a 	mov	r3,r2
 822559c:	e0bffb17 	ldw	r2,-20(fp)
 82255a0:	10c00515 	stw	r3,20(r2)
    rx_packet->net = tse_ptr->netp;
 82255a4:	e0bfff17 	ldw	r2,-4(fp)
 82255a8:	10c00817 	ldw	r3,32(r2)
 82255ac:	e0bffb17 	ldw	r2,-20(fp)
 82255b0:	10c00615 	stw	r3,24(r2)
    
    // set packet type for demux routine
    eth = (struct ethhdr *)(rx_packet->nb_buff + ETHHDR_BIAS);
 82255b4:	e0bffb17 	ldw	r2,-20(fp)
 82255b8:	10800117 	ldw	r2,4(r2)
 82255bc:	10800084 	addi	r2,r2,2
 82255c0:	e0bffc15 	stw	r2,-16(fp)
    rx_packet->type = eth->e_type;
 82255c4:	e0bffc17 	ldw	r2,-16(fp)
 82255c8:	10c0030b 	ldhu	r3,12(r2)
 82255cc:	e0bffb17 	ldw	r2,-20(fp)
 82255d0:	10c0080d 	sth	r3,32(r2)
    
    if( (desc_status & 
 82255d4:	e0bff903 	ldbu	r2,-28(fp)
 82255d8:	10801fcc 	andi	r2,r2,127
 82255dc:	1000251e 	bne	r2,zero,8225674 <tse_mac_rcv+0x1c0>
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) == 0)
    {
      replacement_pkt = pk_alloc(ALTERA_TSE_PKT_INIT_LEN + 4);
 82255e0:	01017f04 	movi	r4,1532
 82255e4:	822c9ec0 	call	822c9ec <pk_alloc>
 82255e8:	e0bffd15 	stw	r2,-12(fp)
      if (!replacement_pkt) { /* couldn't get a free buffer for rx */
 82255ec:	e0bffd17 	ldw	r2,-12(fp)
 82255f0:	10000a1e 	bne	r2,zero,822561c <tse_mac_rcv+0x168>
        dprintf("No free buffers for rx\n");
 82255f4:	01020974 	movhi	r4,2085
 82255f8:	213f9204 	addi	r4,r4,-440
 82255fc:	82036240 	call	8203624 <puts>
        tse_ptr->netp->n_mib->ifInDiscards++;
 8225600:	e0bfff17 	ldw	r2,-4(fp)
 8225604:	10800817 	ldw	r2,32(r2)
 8225608:	10802717 	ldw	r2,156(r2)
 822560c:	10c00c17 	ldw	r3,48(r2)
 8225610:	18c00044 	addi	r3,r3,1
 8225614:	10c00c15 	stw	r3,48(r2)
 8225618:	00001906 	br	8225680 <tse_mac_rcv+0x1cc>
      }
      else {
        putq(&rcvdq, tse_ptr->pkt_array[tse_ptr->chain_loop]);
 822561c:	e0bfff17 	ldw	r2,-4(fp)
 8225620:	10800e17 	ldw	r2,56(r2)
 8225624:	e0ffff17 	ldw	r3,-4(fp)
 8225628:	10800444 	addi	r2,r2,17
 822562c:	1085883a 	add	r2,r2,r2
 8225630:	1085883a 	add	r2,r2,r2
 8225634:	1885883a 	add	r2,r3,r2
 8225638:	10800017 	ldw	r2,0(r2)
 822563c:	100b883a 	mov	r5,r2
 8225640:	010209b4 	movhi	r4,2086
 8225644:	21375604 	addi	r4,r4,-8872
 8225648:	822cf7c0 	call	822cf7c <putq>
        tse_ptr->pkt_array[tse_ptr->chain_loop] = replacement_pkt;
 822564c:	e0bfff17 	ldw	r2,-4(fp)
 8225650:	10800e17 	ldw	r2,56(r2)
 8225654:	e0ffff17 	ldw	r3,-4(fp)
 8225658:	10800444 	addi	r2,r2,17
 822565c:	1085883a 	add	r2,r2,r2
 8225660:	1085883a 	add	r2,r2,r2
 8225664:	1885883a 	add	r2,r3,r2
 8225668:	e0fffd17 	ldw	r3,-12(fp)
 822566c:	10c00015 	stw	r3,0(r2)
 8225670:	00000306 	br	8225680 <tse_mac_rcv+0x1cc>
      }
    } /* if(descriptor had no errors) */ 
    else {
      dprintf("RX descriptor reported error. packet dropped\n");
 8225674:	01020974 	movhi	r4,2085
 8225678:	213f9804 	addi	r4,r4,-416
 822567c:	82036240 	call	8203624 <puts>
    }     
             
    uncached_packet_payload = (alt_u32 *)alt_remap_cached(tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);
 8225680:	e0bfff17 	ldw	r2,-4(fp)
 8225684:	10800e17 	ldw	r2,56(r2)
 8225688:	e0ffff17 	ldw	r3,-4(fp)
 822568c:	10800444 	addi	r2,r2,17
 8225690:	1085883a 	add	r2,r2,r2
 8225694:	1085883a 	add	r2,r2,r2
 8225698:	1885883a 	add	r2,r3,r2
 822569c:	10800017 	ldw	r2,0(r2)
 82256a0:	10800117 	ldw	r2,4(r2)
 82256a4:	01400104 	movi	r5,4
 82256a8:	1009883a 	mov	r4,r2
 82256ac:	823c7b00 	call	823c7b0 <alt_remap_cached>
 82256b0:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Re-cycle previously constructed SGDMA buffer directly rather
     * than calling the SGDMA utility routines. This saves some call/return
     * overhead and only does cache-bypass writes of what we need
     */
    IOWR_32DIRECT(&tse_ptr->currdescriptor_ptr->write_addr, 0, 
 82256b4:	e0bfff17 	ldw	r2,-4(fp)
 82256b8:	10801017 	ldw	r2,64(r2)
 82256bc:	10800204 	addi	r2,r2,8
 82256c0:	e0fffe17 	ldw	r3,-8(fp)
 82256c4:	10c00035 	stwio	r3,0(r2)
     *   |31...24|23..16|15.....................0|
     *   |control|status|actual_bytes_transferred|
     * 
     * Set relevant control bits and ensure the rest are cleared.
     */
    IOWR_32DIRECT(&tse_ptr->currdescriptor_ptr->actual_bytes_transferred, 0, 
 82256c8:	e0bfff17 	ldw	r2,-4(fp)
 82256cc:	10801017 	ldw	r2,64(r2)
 82256d0:	10800704 	addi	r2,r2,28
 82256d4:	00e04034 	movhi	r3,33024
 82256d8:	10c00035 	stwio	r3,0(r2)
    
    /* Grab next descriptor status */
    desc_status = IORD_ALTERA_TSE_SGDMA_DESC_STATUS(tse_ptr->currdescriptor_ptr);
#endif
  } /* while (descriptor terminated by EOP) */
} 
 82256dc:	0001883a 	nop
 82256e0:	e037883a 	mov	sp,fp
 82256e4:	dfc00117 	ldw	ra,4(sp)
 82256e8:	df000017 	ldw	fp,0(sp)
 82256ec:	dec00204 	addi	sp,sp,8
 82256f0:	f800283a 	ret

082256f4 <tse_mac_stats>:

int tse_mac_stats(void * pio, int iface)
{
 82256f4:	defffc04 	addi	sp,sp,-16
 82256f8:	dfc00315 	stw	ra,12(sp)
 82256fc:	df000215 	stw	fp,8(sp)
 8225700:	df000204 	addi	fp,sp,8
 8225704:	e13ffe15 	stw	r4,-8(fp)
 8225708:	e17fff15 	stw	r5,-4(fp)
   ns_printf(pio, "tse_mac_stats(), stats will be added later!\n");
 822570c:	01420974 	movhi	r5,2085
 8225710:	297fa404 	addi	r5,r5,-368
 8225714:	e13ffe17 	ldw	r4,-8(fp)
 8225718:	8228e600 	call	8228e60 <ns_printf>
   return SUCCESS;
 822571c:	0005883a 	mov	r2,zero
}
 8225720:	e037883a 	mov	sp,fp
 8225724:	dfc00117 	ldw	ra,4(sp)
 8225728:	df000017 	ldw	fp,0(sp)
 822572c:	dec00204 	addi	sp,sp,8
 8225730:	f800283a 	ret

08225734 <tse_mac_close>:
 * @API TYPE - Public
 * @param  iface    index of the NET interface associated with the TSE MAC.
 * @return SUCCESS
 */
int tse_mac_close(int iface)
{
 8225734:	defffc04 	addi	sp,sp,-16
 8225738:	dfc00315 	stw	ra,12(sp)
 822573c:	df000215 	stw	fp,8(sp)
 8225740:	df000204 	addi	fp,sp,8
 8225744:	e13fff15 	stw	r4,-4(fp)
  int state;
   
  /* status = down */
  nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_DOWN;    
 8225748:	008209b4 	movhi	r2,2086
 822574c:	10b81b04 	addi	r2,r2,-8084
 8225750:	e0ffff17 	ldw	r3,-4(fp)
 8225754:	18c7883a 	add	r3,r3,r3
 8225758:	18c7883a 	add	r3,r3,r3
 822575c:	10c5883a 	add	r2,r2,r3
 8225760:	10800017 	ldw	r2,0(r2)
 8225764:	10802717 	ldw	r2,156(r2)
 8225768:	00c00084 	movi	r3,2
 822576c:	10c00615 	stw	r3,24(r2)

  /* disable the interrupt in the OS*/
  alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma, 0, 0, 0);
 8225770:	008209b4 	movhi	r2,2086
 8225774:	10b70a04 	addi	r2,r2,-9176
 8225778:	e0ffff17 	ldw	r3,-4(fp)
 822577c:	18c01324 	muli	r3,r3,76
 8225780:	10c5883a 	add	r2,r2,r3
 8225784:	10800304 	addi	r2,r2,12
 8225788:	10800017 	ldw	r2,0(r2)
 822578c:	000f883a 	mov	r7,zero
 8225790:	000d883a 	mov	r6,zero
 8225794:	000b883a 	mov	r5,zero
 8225798:	1009883a 	mov	r4,r2
 822579c:	821e8480 	call	821e848 <alt_avalon_sgdma_register_callback>
   
  /* Disable Receive path on the device*/
  state = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
 82257a0:	008209b4 	movhi	r2,2086
 82257a4:	10b70a04 	addi	r2,r2,-9176
 82257a8:	e0ffff17 	ldw	r3,-4(fp)
 82257ac:	18c01324 	muli	r3,r3,76
 82257b0:	10c5883a 	add	r2,r2,r3
 82257b4:	10800104 	addi	r2,r2,4
 82257b8:	10800017 	ldw	r2,0(r2)
 82257bc:	10800204 	addi	r2,r2,8
 82257c0:	10800037 	ldwio	r2,0(r2)
 82257c4:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,state & ~ALTERA_TSEMAC_CMD_RX_ENA_MSK); 
 82257c8:	008209b4 	movhi	r2,2086
 82257cc:	10b70a04 	addi	r2,r2,-9176
 82257d0:	e0ffff17 	ldw	r3,-4(fp)
 82257d4:	18c01324 	muli	r3,r3,76
 82257d8:	10c5883a 	add	r2,r2,r3
 82257dc:	10800104 	addi	r2,r2,4
 82257e0:	10800017 	ldw	r2,0(r2)
 82257e4:	10800204 	addi	r2,r2,8
 82257e8:	e13ffe17 	ldw	r4,-8(fp)
 82257ec:	00ffff44 	movi	r3,-3
 82257f0:	20c6703a 	and	r3,r4,r3
 82257f4:	10c00035 	stwio	r3,0(r2)
  
  /* status = down */                                     
  nets[iface]->n_mib->ifOperStatus = ALTERA_TSE_ADMIN_STATUS_DOWN;     
 82257f8:	008209b4 	movhi	r2,2086
 82257fc:	10b81b04 	addi	r2,r2,-8084
 8225800:	e0ffff17 	ldw	r3,-4(fp)
 8225804:	18c7883a 	add	r3,r3,r3
 8225808:	18c7883a 	add	r3,r3,r3
 822580c:	10c5883a 	add	r2,r2,r3
 8225810:	10800017 	ldw	r2,0(r2)
 8225814:	10802717 	ldw	r2,156(r2)
 8225818:	00c00084 	movi	r3,2
 822581c:	10c00715 	stw	r3,28(r2)

  return SUCCESS;
 8225820:	0005883a 	mov	r2,zero
}
 8225824:	e037883a 	mov	sp,fp
 8225828:	dfc00117 	ldw	ra,4(sp)
 822582c:	df000017 	ldw	fp,0(sp)
 8225830:	dec00204 	addi	sp,sp,8
 8225834:	f800283a 	ret

08225838 <close>:
 * (for files and device drivers) or the InterNiche soclose() function for
 * sockets.
 */
 
int close (int fd)
{
 8225838:	defffd04 	addi	sp,sp,-12
 822583c:	dfc00215 	stw	ra,8(sp)
 8225840:	df000115 	stw	fp,4(sp)
 8225844:	df000104 	addi	fp,sp,4
 8225848:	e13fff15 	stw	r4,-4(fp)
  return (fd < ALT_MAX_FD) ? alt_close (fd) : t_socketclose ((long) fd);
 822584c:	e0bfff17 	ldw	r2,-4(fp)
 8225850:	10800808 	cmpgei	r2,r2,32
 8225854:	1000031e 	bne	r2,zero,8225864 <close+0x2c>
 8225858:	e13fff17 	ldw	r4,-4(fp)
 822585c:	823bc3c0 	call	823bc3c <alt_close>
 8225860:	00000206 	br	822586c <close+0x34>
 8225864:	e13fff17 	ldw	r4,-4(fp)
 8225868:	823184c0 	call	823184c <t_socketclose>
}
 822586c:	e037883a 	mov	sp,fp
 8225870:	dfc00117 	ldw	ra,4(sp)
 8225874:	df000017 	ldw	fp,0(sp)
 8225878:	dec00204 	addi	sp,sp,8
 822587c:	f800283a 	ret

08225880 <iniche_devices_init>:
 * total number of interfaces after initialization.
 */

int iniche_devices_init(
    int                         if_count)
{
 8225880:	defff504 	addi	sp,sp,-44
 8225884:	dfc00a15 	stw	ra,40(sp)
 8225888:	df000915 	stw	fp,36(sp)
 822588c:	df000904 	addi	fp,sp,36
 8225890:	e13fff15 	stw	r4,-4(fp)
                                netmask,
                                gw;
    int                         use_dhcp;

    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
 8225894:	d0a02e17 	ldw	r2,-32584(gp)
 8225898:	e0bff815 	stw	r2,-32(fp)
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));
 822589c:	d0a02e04 	addi	r2,gp,-32584
 82258a0:	e0bff915 	stw	r2,-28(fp)

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 82258a4:	00003f06 	br	82259a4 <iniche_devices_init+0x124>
    {
        /* Initialize the InterNiche device data record. */
        p_dev->p_driver_data = p_dev;
 82258a8:	e0bff817 	ldw	r2,-32(fp)
 82258ac:	e0fff817 	ldw	r3,-32(fp)
 82258b0:	10c00415 	stw	r3,16(r2)
        p_dev->if_num = if_count;
 82258b4:	e0bff817 	ldw	r2,-32(fp)
 82258b8:	e0ffff17 	ldw	r3,-4(fp)
 82258bc:	10c00515 	stw	r3,20(r2)
        p_dev->p_net = nets[p_dev->if_num];
 82258c0:	e0bff817 	ldw	r2,-32(fp)
 82258c4:	10c00517 	ldw	r3,20(r2)
 82258c8:	008209b4 	movhi	r2,2086
 82258cc:	10b81b04 	addi	r2,r2,-8084
 82258d0:	18c7883a 	add	r3,r3,r3
 82258d4:	18c7883a 	add	r3,r3,r3
 82258d8:	10c5883a 	add	r2,r2,r3
 82258dc:	10c00017 	ldw	r3,0(r2)
 82258e0:	e0bff817 	ldw	r2,-32(fp)
 82258e4:	10c00615 	stw	r3,24(r2)

        /* Perform device specific initialization. */
        (*(p_dev->init_func))(p_dev);
 82258e8:	e0bff817 	ldw	r2,-32(fp)
 82258ec:	10800317 	ldw	r2,12(r2)
 82258f0:	e13ff817 	ldw	r4,-32(fp)
 82258f4:	103ee83a 	callr	r2

        /* Get the interface IP address. */
        p_net = p_dev->p_net;
 82258f8:	e0bff817 	ldw	r2,-32(fp)
 82258fc:	10800617 	ldw	r2,24(r2)
 8225900:	e0bffa15 	stw	r2,-24(fp)
                
        if (get_ip_addr(p_dev, &ipaddr, &netmask, &gw, &use_dhcp))
 8225904:	e17ffd04 	addi	r5,fp,-12
 8225908:	e13ffc04 	addi	r4,fp,-16
 822590c:	e0fffb04 	addi	r3,fp,-20
 8225910:	e0bffe04 	addi	r2,fp,-8
 8225914:	d8800015 	stw	r2,0(sp)
 8225918:	280f883a 	mov	r7,r5
 822591c:	200d883a 	mov	r6,r4
 8225920:	180b883a 	mov	r5,r3
 8225924:	e13ff817 	ldw	r4,-32(fp)
 8225928:	82011180 	call	8201118 <get_ip_addr>
 822592c:	10001726 	beq	r2,zero,822598c <iniche_devices_init+0x10c>
            /* 
             * OR in the DHCP flag, if enabled. This will allow any
             * application-specific flag setting in get_ip_addr(), such 
             * as enabling AUTOIP, to occur 
             */
            if (use_dhcp) {
 8225930:	e0bffe17 	ldw	r2,-8(fp)
 8225934:	10000526 	beq	r2,zero,822594c <iniche_devices_init+0xcc>
                p_net->n_flags |= NF_DHCPC;
 8225938:	e0bffa17 	ldw	r2,-24(fp)
 822593c:	10802a17 	ldw	r2,168(r2)
 8225940:	10c04014 	ori	r3,r2,256
 8225944:	e0bffa17 	ldw	r2,-24(fp)
 8225948:	10c02a15 	stw	r3,168(r2)
            }
#endif
            p_net->n_ipaddr = ipaddr;
 822594c:	e0fffb17 	ldw	r3,-20(fp)
 8225950:	e0bffa17 	ldw	r2,-24(fp)
 8225954:	10c00a15 	stw	r3,40(r2)
            p_net->snmask = netmask;
 8225958:	e0fffc17 	ldw	r3,-16(fp)
 822595c:	e0bffa17 	ldw	r2,-24(fp)
 8225960:	10c00c15 	stw	r3,48(r2)
            p_net->n_defgw = gw;
 8225964:	e0fffd17 	ldw	r3,-12(fp)
 8225968:	e0bffa17 	ldw	r2,-24(fp)
 822596c:	10c00d15 	stw	r3,52(r2)
#ifdef IP_MULTICAST
	    p_net->n_mcastlist = mcastlist;
 8225970:	e0fffa17 	ldw	r3,-24(fp)
 8225974:	00820934 	movhi	r2,2084
 8225978:	10b4e504 	addi	r2,r2,-11372
 822597c:	18802b15 	stw	r2,172(r3)
#if defined (IGMP_V1) || defined (IGMP_V2)
            p_net->igmp_oper_mode = IGMP_MODE_DEFAULT;
 8225980:	e0bffa17 	ldw	r2,-24(fp)
 8225984:	00c00084 	movi	r3,2
 8225988:	10c02f05 	stb	r3,188(r2)
#endif  /* IGMPv1 or IGMPv2 */
#endif  /* IP_MULTICAST */
        }

        /* Initialize next device. */
        if_count++;
 822598c:	e0bfff17 	ldw	r2,-4(fp)
 8225990:	10800044 	addi	r2,r2,1
 8225994:	e0bfff15 	stw	r2,-4(fp)
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
 8225998:	e0bff817 	ldw	r2,-32(fp)
 822599c:	10800017 	ldw	r2,0(r2)
 82259a0:	e0bff815 	stw	r2,-32(fp)
    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 82259a4:	e0fff817 	ldw	r3,-32(fp)
 82259a8:	e0bff917 	ldw	r2,-28(fp)
 82259ac:	18bfbe1e 	bne	r3,r2,82258a8 <iniche_devices_init+0x28>
        /* Initialize next device. */
        if_count++;
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
    }

    return (if_count);
 82259b0:	e0bfff17 	ldw	r2,-4(fp)
}
 82259b4:	e037883a 	mov	sp,fp
 82259b8:	dfc00117 	ldw	ra,4(sp)
 82259bc:	df000017 	ldw	fp,0(sp)
 82259c0:	dec00204 	addi	sp,sp,8
 82259c4:	f800283a 	ret

082259c8 <read>:
 * (for files and device drivers) or the InterNiche recvfrom() function for
 * sockets.
 */

int read (int fd, void *ptr, size_t len)
{
 82259c8:	defff904 	addi	sp,sp,-28
 82259cc:	dfc00615 	stw	ra,24(sp)
 82259d0:	df000515 	stw	fp,20(sp)
 82259d4:	df000504 	addi	fp,sp,20
 82259d8:	e13ffd15 	stw	r4,-12(fp)
 82259dc:	e17ffe15 	stw	r5,-8(fp)
 82259e0:	e1bfff15 	stw	r6,-4(fp)
  return (fd < ALT_MAX_FD) ? alt_read (fd, ptr, len)
                           : recvfrom(fd, ptr, len, 0, NULL, NULL);
 82259e4:	e0bffd17 	ldw	r2,-12(fp)
 82259e8:	10800808 	cmpgei	r2,r2,32
 82259ec:	1000051e 	bne	r2,zero,8225a04 <read+0x3c>
 82259f0:	e1bfff17 	ldw	r6,-4(fp)
 82259f4:	e17ffe17 	ldw	r5,-8(fp)
 82259f8:	e13ffd17 	ldw	r4,-12(fp)
 82259fc:	823c6500 	call	823c650 <alt_read>
 * sockets.
 */

int read (int fd, void *ptr, size_t len)
{
  return (fd < ALT_MAX_FD) ? alt_read (fd, ptr, len)
 8225a00:	00000806 	br	8225a24 <read+0x5c>
                           : recvfrom(fd, ptr, len, 0, NULL, NULL);
 8225a04:	e0bfff17 	ldw	r2,-4(fp)
 8225a08:	d8000115 	stw	zero,4(sp)
 8225a0c:	d8000015 	stw	zero,0(sp)
 8225a10:	000f883a 	mov	r7,zero
 8225a14:	100d883a 	mov	r6,r2
 8225a18:	e17ffe17 	ldw	r5,-8(fp)
 8225a1c:	e13ffd17 	ldw	r4,-12(fp)
 8225a20:	82283640 	call	8228364 <bsd_recvfrom>
}
 8225a24:	e037883a 	mov	sp,fp
 8225a28:	dfc00117 	ldw	ra,4(sp)
 8225a2c:	df000017 	ldw	fp,0(sp)
 8225a30:	dec00204 	addi	sp,sp,8
 8225a34:	f800283a 	ret

08225a38 <write>:
 * This implementation vectors requests to either the HAL alt_write() function 
 * (for files and device drivers) or the InterNiche send() function for sockets.
 */

int write (int fd, const void *ptr, size_t len)
{
 8225a38:	defffb04 	addi	sp,sp,-20
 8225a3c:	dfc00415 	stw	ra,16(sp)
 8225a40:	df000315 	stw	fp,12(sp)
 8225a44:	df000304 	addi	fp,sp,12
 8225a48:	e13ffd15 	stw	r4,-12(fp)
 8225a4c:	e17ffe15 	stw	r5,-8(fp)
 8225a50:	e1bfff15 	stw	r6,-4(fp)
  if (fd < ALT_MAX_FD)
 8225a54:	e0bffd17 	ldw	r2,-12(fp)
 8225a58:	10800808 	cmpgei	r2,r2,32
 8225a5c:	1000051e 	bne	r2,zero,8225a74 <write+0x3c>
  {
    return alt_write (fd, ptr, len);
 8225a60:	e1bfff17 	ldw	r6,-4(fp)
 8225a64:	e17ffe17 	ldw	r5,-8(fp)
 8225a68:	e13ffd17 	ldw	r4,-12(fp)
 8225a6c:	823cb980 	call	823cb98 <alt_write>
 8225a70:	00000606 	br	8225a8c <write+0x54>
  }
  else
  { 
    return send (fd, (void*) ptr, len, 0);
 8225a74:	e0bfff17 	ldw	r2,-4(fp)
 8225a78:	000f883a 	mov	r7,zero
 8225a7c:	100d883a 	mov	r6,r2
 8225a80:	e17ffe17 	ldw	r5,-8(fp)
 8225a84:	e13ffd17 	ldw	r4,-12(fp)
 8225a88:	82315700 	call	8231570 <t_send>
  }  
}
 8225a8c:	e037883a 	mov	sp,fp
 8225a90:	dfc00117 	ldw	ra,4(sp)
 8225a94:	df000017 	ldw	fp,0(sp)
 8225a98:	dec00204 	addi	sp,sp,8
 8225a9c:	f800283a 	ret

08225aa0 <Netinit>:
 * a non-zero error code
 */

int
Netinit()
{
 8225aa0:	defffc04 	addi	sp,sp,-16
 8225aa4:	dfc00315 	stw	ra,12(sp)
 8225aa8:	df000215 	stw	fp,8(sp)
 8225aac:	df000204 	addi	fp,sp,8
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 8225ab0:	e03ffe15 	stw	zero,-8(fp)
 8225ab4:	00004a06 	br	8225be0 <Netinit+0x140>
   {
      /* sanity check on mtu, et.al. We added this because earlier 
       * drivers were sloppy about setting them, but new
       * logic depends on these sizes.
       */
      if (nets[i]->n_mib->ifType == ETHERNET)   /* ethernet? */
 8225ab8:	008209b4 	movhi	r2,2086
 8225abc:	10b81b04 	addi	r2,r2,-8084
 8225ac0:	e0fffe17 	ldw	r3,-8(fp)
 8225ac4:	18c7883a 	add	r3,r3,r3
 8225ac8:	18c7883a 	add	r3,r3,r3
 8225acc:	10c5883a 	add	r2,r2,r3
 8225ad0:	10800017 	ldw	r2,0(r2)
 8225ad4:	10802717 	ldw	r2,156(r2)
 8225ad8:	10800217 	ldw	r2,8(r2)
 8225adc:	10800198 	cmpnei	r2,r2,6
 8225ae0:	1000241e 	bne	r2,zero,8225b74 <Netinit+0xd4>
      {
         if (nets[i]->n_mtu == 0)   /* let device code override */
 8225ae4:	008209b4 	movhi	r2,2086
 8225ae8:	10b81b04 	addi	r2,r2,-8084
 8225aec:	e0fffe17 	ldw	r3,-8(fp)
 8225af0:	18c7883a 	add	r3,r3,r3
 8225af4:	18c7883a 	add	r3,r3,r3
 8225af8:	10c5883a 	add	r2,r2,r3
 8225afc:	10800017 	ldw	r2,0(r2)
 8225b00:	10800917 	ldw	r2,36(r2)
 8225b04:	1000091e 	bne	r2,zero,8225b2c <Netinit+0x8c>
            nets[i]->n_mtu = 1514;
 8225b08:	008209b4 	movhi	r2,2086
 8225b0c:	10b81b04 	addi	r2,r2,-8084
 8225b10:	e0fffe17 	ldw	r3,-8(fp)
 8225b14:	18c7883a 	add	r3,r3,r3
 8225b18:	18c7883a 	add	r3,r3,r3
 8225b1c:	10c5883a 	add	r2,r2,r3
 8225b20:	10800017 	ldw	r2,0(r2)
 8225b24:	00c17a84 	movi	r3,1514
 8225b28:	10c00915 	stw	r3,36(r2)

         if (nets[i]->n_lnh == 0)
 8225b2c:	008209b4 	movhi	r2,2086
 8225b30:	10b81b04 	addi	r2,r2,-8084
 8225b34:	e0fffe17 	ldw	r3,-8(fp)
 8225b38:	18c7883a 	add	r3,r3,r3
 8225b3c:	18c7883a 	add	r3,r3,r3
 8225b40:	10c5883a 	add	r2,r2,r3
 8225b44:	10800017 	ldw	r2,0(r2)
 8225b48:	10800817 	ldw	r2,32(r2)
 8225b4c:	1000091e 	bne	r2,zero,8225b74 <Netinit+0xd4>
         {
#ifdef IEEE_802_3
            nets[i]->n_lnh = ETHHDR_SIZE + sizeof(struct snap_hdr);
#else
            nets[i]->n_lnh = ETHHDR_SIZE;
 8225b50:	008209b4 	movhi	r2,2086
 8225b54:	10b81b04 	addi	r2,r2,-8084
 8225b58:	e0fffe17 	ldw	r3,-8(fp)
 8225b5c:	18c7883a 	add	r3,r3,r3
 8225b60:	18c7883a 	add	r3,r3,r3
 8225b64:	10c5883a 	add	r2,r2,r3
 8225b68:	10800017 	ldw	r2,0(r2)
 8225b6c:	00c00404 	movi	r3,16
 8225b70:	10c00815 	stw	r3,32(r2)
      {
         continue;
      }
#endif   /* IP_V6 */

      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
 8225b74:	008209b4 	movhi	r2,2086
 8225b78:	10b81b04 	addi	r2,r2,-8084
 8225b7c:	e0fffe17 	ldw	r3,-8(fp)
 8225b80:	18c7883a 	add	r3,r3,r3
 8225b84:	18c7883a 	add	r3,r3,r3
 8225b88:	10c5883a 	add	r2,r2,r3
 8225b8c:	10800017 	ldw	r2,0(r2)
 8225b90:	10800817 	ldw	r2,32(r2)
 8225b94:	d0e08117 	ldw	r3,-32252(gp)
 8225b98:	10c0010e 	bge	r2,r3,8225ba0 <Netinit+0x100>
 8225b9c:	1805883a 	mov	r2,r3
 8225ba0:	d0a08115 	stw	r2,-32252(gp)
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
 8225ba4:	008209b4 	movhi	r2,2086
 8225ba8:	10b81b04 	addi	r2,r2,-8084
 8225bac:	e0fffe17 	ldw	r3,-8(fp)
 8225bb0:	18c7883a 	add	r3,r3,r3
 8225bb4:	18c7883a 	add	r3,r3,r3
 8225bb8:	10c5883a 	add	r2,r2,r3
 8225bbc:	10800017 	ldw	r2,0(r2)
 8225bc0:	10800917 	ldw	r2,36(r2)
 8225bc4:	d0e08217 	ldw	r3,-32248(gp)
 8225bc8:	10c0010e 	bge	r2,r3,8225bd0 <Netinit+0x130>
 8225bcc:	1805883a 	mov	r2,r3
 8225bd0:	d0a08215 	stw	r2,-32248(gp)
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 8225bd4:	e0bffe17 	ldw	r2,-8(fp)
 8225bd8:	10800044 	addi	r2,r2,1
 8225bdc:	e0bffe15 	stw	r2,-8(fp)
 8225be0:	d0a08417 	ldw	r2,-32240(gp)
 8225be4:	1007883a 	mov	r3,r2
 8225be8:	e0bffe17 	ldw	r2,-8(fp)
 8225bec:	10ffb216 	blt	r2,r3,8225ab8 <Netinit+0x18>
      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
   }

   /* set up the received packet queue */
   rcvdq.q_head = rcvdq.q_tail = NULL;
 8225bf0:	008209b4 	movhi	r2,2086
 8225bf4:	10b75604 	addi	r2,r2,-8872
 8225bf8:	10000115 	stw	zero,4(r2)
 8225bfc:	008209b4 	movhi	r2,2086
 8225c00:	10b75604 	addi	r2,r2,-8872
 8225c04:	10c00117 	ldw	r3,4(r2)
 8225c08:	008209b4 	movhi	r2,2086
 8225c0c:	10b75604 	addi	r2,r2,-8872
 8225c10:	10c00015 	stw	r3,0(r2)
   rcvdq.q_max = rcvdq.q_min = rcvdq.q_len = 0;
 8225c14:	008209b4 	movhi	r2,2086
 8225c18:	10b75604 	addi	r2,r2,-8872
 8225c1c:	10000215 	stw	zero,8(r2)
 8225c20:	008209b4 	movhi	r2,2086
 8225c24:	10b75604 	addi	r2,r2,-8872
 8225c28:	10c00217 	ldw	r3,8(r2)
 8225c2c:	008209b4 	movhi	r2,2086
 8225c30:	10b75604 	addi	r2,r2,-8872
 8225c34:	10c00415 	stw	r3,16(r2)
 8225c38:	008209b4 	movhi	r2,2086
 8225c3c:	10b75604 	addi	r2,r2,-8872
 8225c40:	10c00417 	ldw	r3,16(r2)
 8225c44:	008209b4 	movhi	r2,2086
 8225c48:	10b75604 	addi	r2,r2,-8872
 8225c4c:	10c00315 	stw	r3,12(r2)

   /* initialize freeq */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8225c50:	01000084 	movi	r4,2
 8225c54:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   e = pk_init();
 8225c58:	822c7500 	call	822c750 <pk_init>
 8225c5c:	e0bfff15 	stw	r2,-4(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8225c60:	01000084 	movi	r4,2
 8225c64:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   if (e)   /* report error (memory ran out?) */
 8225c68:	e0bfff17 	ldw	r2,-4(fp)
 8225c6c:	10000226 	beq	r2,zero,8225c78 <Netinit+0x1d8>
      return e;
 8225c70:	e0bfff17 	ldw	r2,-4(fp)
 8225c74:	0000ff06 	br	8226074 <Netinit+0x5d4>

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */
 8225c78:	010208b4 	movhi	r4,2082
 8225c7c:	21187804 	addi	r4,r4,25056
 8225c80:	8226b280 	call	8226b28 <exit_hook>

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 8225c84:	e03ffe15 	stw	zero,-8(fp)
 8225c88:	0000f506 	br	8226060 <Netinit+0x5c0>
   {
      if (nets[i]->n_init != NULL)  /* If iface has init routine... */
 8225c8c:	008209b4 	movhi	r2,2086
 8225c90:	10b81b04 	addi	r2,r2,-8084
 8225c94:	e0fffe17 	ldw	r3,-8(fp)
 8225c98:	18c7883a 	add	r3,r3,r3
 8225c9c:	18c7883a 	add	r3,r3,r3
 8225ca0:	10c5883a 	add	r2,r2,r3
 8225ca4:	10800017 	ldw	r2,0(r2)
 8225ca8:	10800217 	ldw	r2,8(r2)
 8225cac:	10009126 	beq	r2,zero,8225ef4 <Netinit+0x454>
      {
         if ((e = (*nets[i]->n_init)(i)) != 0)  /* call init routine */
 8225cb0:	008209b4 	movhi	r2,2086
 8225cb4:	10b81b04 	addi	r2,r2,-8084
 8225cb8:	e0fffe17 	ldw	r3,-8(fp)
 8225cbc:	18c7883a 	add	r3,r3,r3
 8225cc0:	18c7883a 	add	r3,r3,r3
 8225cc4:	10c5883a 	add	r2,r2,r3
 8225cc8:	10800017 	ldw	r2,0(r2)
 8225ccc:	10800217 	ldw	r2,8(r2)
 8225cd0:	e13ffe17 	ldw	r4,-8(fp)
 8225cd4:	103ee83a 	callr	r2
 8225cd8:	e0bfff15 	stw	r2,-4(fp)
 8225cdc:	e0bfff17 	ldw	r2,-4(fp)
 8225ce0:	10001026 	beq	r2,zero,8225d24 <Netinit+0x284>
         {
            dprintf("init error %d on net[%d]\n", e, i);
 8225ce4:	e1bffe17 	ldw	r6,-8(fp)
 8225ce8:	e17fff17 	ldw	r5,-4(fp)
 8225cec:	01020974 	movhi	r4,2085
 8225cf0:	213fb004 	addi	r4,r4,-320
 8225cf4:	82033a00 	call	82033a0 <printf>
            nets[i]->n_mib->ifOperStatus = NI_DOWN;
 8225cf8:	008209b4 	movhi	r2,2086
 8225cfc:	10b81b04 	addi	r2,r2,-8084
 8225d00:	e0fffe17 	ldw	r3,-8(fp)
 8225d04:	18c7883a 	add	r3,r3,r3
 8225d08:	18c7883a 	add	r3,r3,r3
 8225d0c:	10c5883a 	add	r2,r2,r3
 8225d10:	10800017 	ldw	r2,0(r2)
 8225d14:	10802717 	ldw	r2,156(r2)
 8225d18:	00c00084 	movi	r3,2
 8225d1c:	10c00715 	stw	r3,28(r2)
            continue;   /* ignore ifaces which fail */
 8225d20:	0000cc06 	br	8226054 <Netinit+0x5b4>
         }
         /* If interface is ethernet, set bcast flag bit. This
          * should really be done by the init routine, but we handle it
          * here to support MAC drivers which predate the flags field.
          */
         if(nets[i]->n_mib->ifType == ETHERNET)
 8225d24:	008209b4 	movhi	r2,2086
 8225d28:	10b81b04 	addi	r2,r2,-8084
 8225d2c:	e0fffe17 	ldw	r3,-8(fp)
 8225d30:	18c7883a 	add	r3,r3,r3
 8225d34:	18c7883a 	add	r3,r3,r3
 8225d38:	10c5883a 	add	r2,r2,r3
 8225d3c:	10800017 	ldw	r2,0(r2)
 8225d40:	10802717 	ldw	r2,156(r2)
 8225d44:	10800217 	ldw	r2,8(r2)
 8225d48:	10800198 	cmpnei	r2,r2,6
 8225d4c:	1000111e 	bne	r2,zero,8225d94 <Netinit+0x2f4>
            nets[i]->n_flags |= NF_BCAST;
 8225d50:	008209b4 	movhi	r2,2086
 8225d54:	10b81b04 	addi	r2,r2,-8084
 8225d58:	e0fffe17 	ldw	r3,-8(fp)
 8225d5c:	18c7883a 	add	r3,r3,r3
 8225d60:	18c7883a 	add	r3,r3,r3
 8225d64:	10c5883a 	add	r2,r2,r3
 8225d68:	11000017 	ldw	r4,0(r2)
 8225d6c:	008209b4 	movhi	r2,2086
 8225d70:	10b81b04 	addi	r2,r2,-8084
 8225d74:	e0fffe17 	ldw	r3,-8(fp)
 8225d78:	18c7883a 	add	r3,r3,r3
 8225d7c:	18c7883a 	add	r3,r3,r3
 8225d80:	10c5883a 	add	r2,r2,r3
 8225d84:	10800017 	ldw	r2,0(r2)
 8225d88:	10802a17 	ldw	r2,168(r2)
 8225d8c:	10800054 	ori	r2,r2,1
 8225d90:	20802a15 	stw	r2,168(r4)

         /* set ifAdminStatus in case init() routine forgot to. IfOperStatus
          * is not nessecarily up at this point, as in the case of a modem which
          * is now in autoanswer mode.
          */
         nets[i]->n_mib->ifAdminStatus = NI_UP;
 8225d94:	008209b4 	movhi	r2,2086
 8225d98:	10b81b04 	addi	r2,r2,-8084
 8225d9c:	e0fffe17 	ldw	r3,-8(fp)
 8225da0:	18c7883a 	add	r3,r3,r3
 8225da4:	18c7883a 	add	r3,r3,r3
 8225da8:	10c5883a 	add	r2,r2,r3
 8225dac:	10800017 	ldw	r2,0(r2)
 8225db0:	10802717 	ldw	r2,156(r2)
 8225db4:	00c00044 	movi	r3,1
 8225db8:	10c00615 	stw	r3,24(r2)

         /* assign default names to unnamed ifaces */
         if(nets[i]->name[0] == 0)     /* no name set by prep or init */
 8225dbc:	008209b4 	movhi	r2,2086
 8225dc0:	10b81b04 	addi	r2,r2,-8084
 8225dc4:	e0fffe17 	ldw	r3,-8(fp)
 8225dc8:	18c7883a 	add	r3,r3,r3
 8225dcc:	18c7883a 	add	r3,r3,r3
 8225dd0:	10c5883a 	add	r2,r2,r3
 8225dd4:	10800017 	ldw	r2,0(r2)
 8225dd8:	10800103 	ldbu	r2,4(r2)
 8225ddc:	10803fcc 	andi	r2,r2,255
 8225de0:	1080201c 	xori	r2,r2,128
 8225de4:	10bfe004 	addi	r2,r2,-128
 8225de8:	1000421e 	bne	r2,zero,8225ef4 <Netinit+0x454>
         {
            if(nets[i]->n_mib->ifType == ETHERNET)
 8225dec:	008209b4 	movhi	r2,2086
 8225df0:	10b81b04 	addi	r2,r2,-8084
 8225df4:	e0fffe17 	ldw	r3,-8(fp)
 8225df8:	18c7883a 	add	r3,r3,r3
 8225dfc:	18c7883a 	add	r3,r3,r3
 8225e00:	10c5883a 	add	r2,r2,r3
 8225e04:	10800017 	ldw	r2,0(r2)
 8225e08:	10802717 	ldw	r2,156(r2)
 8225e0c:	10800217 	ldw	r2,8(r2)
 8225e10:	10800198 	cmpnei	r2,r2,6
 8225e14:	1000131e 	bne	r2,zero,8225e64 <Netinit+0x3c4>
            {
               nets[i]->name[0] = 'e';    /* "et1", "et2", etc. */
 8225e18:	008209b4 	movhi	r2,2086
 8225e1c:	10b81b04 	addi	r2,r2,-8084
 8225e20:	e0fffe17 	ldw	r3,-8(fp)
 8225e24:	18c7883a 	add	r3,r3,r3
 8225e28:	18c7883a 	add	r3,r3,r3
 8225e2c:	10c5883a 	add	r2,r2,r3
 8225e30:	10800017 	ldw	r2,0(r2)
 8225e34:	00c01944 	movi	r3,101
 8225e38:	10c00105 	stb	r3,4(r2)
               nets[i]->name[1] = 't';
 8225e3c:	008209b4 	movhi	r2,2086
 8225e40:	10b81b04 	addi	r2,r2,-8084
 8225e44:	e0fffe17 	ldw	r3,-8(fp)
 8225e48:	18c7883a 	add	r3,r3,r3
 8225e4c:	18c7883a 	add	r3,r3,r3
 8225e50:	10c5883a 	add	r2,r2,r3
 8225e54:	10800017 	ldw	r2,0(r2)
 8225e58:	00c01d04 	movi	r3,116
 8225e5c:	10c00145 	stb	r3,5(r2)
 8225e60:	00001206 	br	8225eac <Netinit+0x40c>
            }
            else
            {
               nets[i]->name[0] = 'i';    /* "if1", "if2", etc. */
 8225e64:	008209b4 	movhi	r2,2086
 8225e68:	10b81b04 	addi	r2,r2,-8084
 8225e6c:	e0fffe17 	ldw	r3,-8(fp)
 8225e70:	18c7883a 	add	r3,r3,r3
 8225e74:	18c7883a 	add	r3,r3,r3
 8225e78:	10c5883a 	add	r2,r2,r3
 8225e7c:	10800017 	ldw	r2,0(r2)
 8225e80:	00c01a44 	movi	r3,105
 8225e84:	10c00105 	stb	r3,4(r2)
               nets[i]->name[1] = 'f';
 8225e88:	008209b4 	movhi	r2,2086
 8225e8c:	10b81b04 	addi	r2,r2,-8084
 8225e90:	e0fffe17 	ldw	r3,-8(fp)
 8225e94:	18c7883a 	add	r3,r3,r3
 8225e98:	18c7883a 	add	r3,r3,r3
 8225e9c:	10c5883a 	add	r2,r2,r3
 8225ea0:	10800017 	ldw	r2,0(r2)
 8225ea4:	00c01984 	movi	r3,102
 8225ea8:	10c00145 	stb	r3,5(r2)
            }
            nets[i]->name[2] = (char)(i + '1');
 8225eac:	008209b4 	movhi	r2,2086
 8225eb0:	10b81b04 	addi	r2,r2,-8084
 8225eb4:	e0fffe17 	ldw	r3,-8(fp)
 8225eb8:	18c7883a 	add	r3,r3,r3
 8225ebc:	18c7883a 	add	r3,r3,r3
 8225ec0:	10c5883a 	add	r2,r2,r3
 8225ec4:	10800017 	ldw	r2,0(r2)
 8225ec8:	e0fffe17 	ldw	r3,-8(fp)
 8225ecc:	18c00c44 	addi	r3,r3,49
 8225ed0:	10c00185 	stb	r3,6(r2)
            nets[i]->name[3] = '\0';
 8225ed4:	008209b4 	movhi	r2,2086
 8225ed8:	10b81b04 	addi	r2,r2,-8084
 8225edc:	e0fffe17 	ldw	r3,-8(fp)
 8225ee0:	18c7883a 	add	r3,r3,r3
 8225ee4:	18c7883a 	add	r3,r3,r3
 8225ee8:	10c5883a 	add	r2,r2,r3
 8225eec:	10800017 	ldw	r2,0(r2)
 8225ef0:	100001c5 	stb	zero,7(r2)
         }
      }
      /* check on subnet routing - if no mask then make one */
      fixup_subnet_mask(i);      /* make mask for this net */
 8225ef4:	e13ffe17 	ldw	r4,-8(fp)
 8225ef8:	82260880 	call	8226088 <fixup_subnet_mask>

      /* build broadcast addresses */
      if(nets[i]->n_ipaddr != 0)
 8225efc:	008209b4 	movhi	r2,2086
 8225f00:	10b81b04 	addi	r2,r2,-8084
 8225f04:	e0fffe17 	ldw	r3,-8(fp)
 8225f08:	18c7883a 	add	r3,r3,r3
 8225f0c:	18c7883a 	add	r3,r3,r3
 8225f10:	10c5883a 	add	r2,r2,r3
 8225f14:	10800017 	ldw	r2,0(r2)
 8225f18:	10800a17 	ldw	r2,40(r2)
 8225f1c:	10004d26 	beq	r2,zero,8226054 <Netinit+0x5b4>
      {
         nets[i]->n_netbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 8225f20:	008209b4 	movhi	r2,2086
 8225f24:	10b81b04 	addi	r2,r2,-8084
 8225f28:	e0fffe17 	ldw	r3,-8(fp)
 8225f2c:	18c7883a 	add	r3,r3,r3
 8225f30:	18c7883a 	add	r3,r3,r3
 8225f34:	10c5883a 	add	r2,r2,r3
 8225f38:	11000017 	ldw	r4,0(r2)
 8225f3c:	008209b4 	movhi	r2,2086
 8225f40:	10b81b04 	addi	r2,r2,-8084
 8225f44:	e0fffe17 	ldw	r3,-8(fp)
 8225f48:	18c7883a 	add	r3,r3,r3
 8225f4c:	18c7883a 	add	r3,r3,r3
 8225f50:	10c5883a 	add	r2,r2,r3
 8225f54:	10800017 	ldw	r2,0(r2)
 8225f58:	11400a17 	ldw	r5,40(r2)
 8225f5c:	008209b4 	movhi	r2,2086
 8225f60:	10b81b04 	addi	r2,r2,-8084
 8225f64:	e0fffe17 	ldw	r3,-8(fp)
 8225f68:	18c7883a 	add	r3,r3,r3
 8225f6c:	18c7883a 	add	r3,r3,r3
 8225f70:	10c5883a 	add	r2,r2,r3
 8225f74:	10800017 	ldw	r2,0(r2)
 8225f78:	10800c17 	ldw	r2,48(r2)
 8225f7c:	0084303a 	nor	r2,zero,r2
 8225f80:	2884b03a 	or	r2,r5,r2
 8225f84:	20800e15 	stw	r2,56(r4)
         nets[i]->n_netbr42 = nets[i]->n_ipaddr & nets[i]->snmask;
 8225f88:	008209b4 	movhi	r2,2086
 8225f8c:	10b81b04 	addi	r2,r2,-8084
 8225f90:	e0fffe17 	ldw	r3,-8(fp)
 8225f94:	18c7883a 	add	r3,r3,r3
 8225f98:	18c7883a 	add	r3,r3,r3
 8225f9c:	10c5883a 	add	r2,r2,r3
 8225fa0:	11000017 	ldw	r4,0(r2)
 8225fa4:	008209b4 	movhi	r2,2086
 8225fa8:	10b81b04 	addi	r2,r2,-8084
 8225fac:	e0fffe17 	ldw	r3,-8(fp)
 8225fb0:	18c7883a 	add	r3,r3,r3
 8225fb4:	18c7883a 	add	r3,r3,r3
 8225fb8:	10c5883a 	add	r2,r2,r3
 8225fbc:	10800017 	ldw	r2,0(r2)
 8225fc0:	11400a17 	ldw	r5,40(r2)
 8225fc4:	008209b4 	movhi	r2,2086
 8225fc8:	10b81b04 	addi	r2,r2,-8084
 8225fcc:	e0fffe17 	ldw	r3,-8(fp)
 8225fd0:	18c7883a 	add	r3,r3,r3
 8225fd4:	18c7883a 	add	r3,r3,r3
 8225fd8:	10c5883a 	add	r2,r2,r3
 8225fdc:	10800017 	ldw	r2,0(r2)
 8225fe0:	10800c17 	ldw	r2,48(r2)
 8225fe4:	2884703a 	and	r2,r5,r2
 8225fe8:	20800f15 	stw	r2,60(r4)
         nets[i]->n_subnetbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 8225fec:	008209b4 	movhi	r2,2086
 8225ff0:	10b81b04 	addi	r2,r2,-8084
 8225ff4:	e0fffe17 	ldw	r3,-8(fp)
 8225ff8:	18c7883a 	add	r3,r3,r3
 8225ffc:	18c7883a 	add	r3,r3,r3
 8226000:	10c5883a 	add	r2,r2,r3
 8226004:	11000017 	ldw	r4,0(r2)
 8226008:	008209b4 	movhi	r2,2086
 822600c:	10b81b04 	addi	r2,r2,-8084
 8226010:	e0fffe17 	ldw	r3,-8(fp)
 8226014:	18c7883a 	add	r3,r3,r3
 8226018:	18c7883a 	add	r3,r3,r3
 822601c:	10c5883a 	add	r2,r2,r3
 8226020:	10800017 	ldw	r2,0(r2)
 8226024:	11400a17 	ldw	r5,40(r2)
 8226028:	008209b4 	movhi	r2,2086
 822602c:	10b81b04 	addi	r2,r2,-8084
 8226030:	e0fffe17 	ldw	r3,-8(fp)
 8226034:	18c7883a 	add	r3,r3,r3
 8226038:	18c7883a 	add	r3,r3,r3
 822603c:	10c5883a 	add	r2,r2,r3
 8226040:	10800017 	ldw	r2,0(r2)
 8226044:	10800c17 	ldw	r2,48(r2)
 8226048:	0084303a 	nor	r2,zero,r2
 822604c:	2884b03a 	or	r2,r5,r2
 8226050:	20801015 	stw	r2,64(r4)

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 8226054:	e0bffe17 	ldw	r2,-8(fp)
 8226058:	10800044 	addi	r2,r2,1
 822605c:	e0bffe15 	stw	r2,-8(fp)
 8226060:	d0a08417 	ldw	r2,-32240(gp)
 8226064:	1007883a 	mov	r3,r2
 8226068:	e0bffe17 	ldw	r2,-8(fp)
 822606c:	10ff0716 	blt	r2,r3,8225c8c <Netinit+0x1ec>
#if defined(DYNAMIC_IFACES) && defined(IN_MENUS)
   /* Install dynamic iface menu */
   install_menu(&dynif_menu[0]);
#endif /* DYNAMIC_IFACES && IN_MENUS */

   return(0);
 8226070:	0005883a 	mov	r2,zero
}
 8226074:	e037883a 	mov	sp,fp
 8226078:	dfc00117 	ldw	ra,4(sp)
 822607c:	df000017 	ldw	fp,0(sp)
 8226080:	dec00204 	addi	sp,sp,8
 8226084:	f800283a 	ret

08226088 <fixup_subnet_mask>:
 * RETURNS: 
 */

void
fixup_subnet_mask(int netnum)      /* which of the nets[] to do. */
{
 8226088:	defffc04 	addi	sp,sp,-16
 822608c:	dfc00315 	stw	ra,12(sp)
 8226090:	df000215 	stw	fp,8(sp)
 8226094:	df000204 	addi	fp,sp,8
 8226098:	e13fff15 	stw	r4,-4(fp)
   u_long   smask;

   if (nets[netnum]->snmask)  /* if mask is already set, don't bother */
 822609c:	008209b4 	movhi	r2,2086
 82260a0:	10b81b04 	addi	r2,r2,-8084
 82260a4:	e0ffff17 	ldw	r3,-4(fp)
 82260a8:	18c7883a 	add	r3,r3,r3
 82260ac:	18c7883a 	add	r3,r3,r3
 82260b0:	10c5883a 	add	r2,r2,r3
 82260b4:	10800017 	ldw	r2,0(r2)
 82260b8:	10800c17 	ldw	r2,48(r2)
 82260bc:	1000421e 	bne	r2,zero,82261c8 <fixup_subnet_mask+0x140>
      return;

   /* things depending on IP address class: */
   if ((nets[netnum]->n_ipaddr & AMASK) == AADDR)
 82260c0:	008209b4 	movhi	r2,2086
 82260c4:	10b81b04 	addi	r2,r2,-8084
 82260c8:	e0ffff17 	ldw	r3,-4(fp)
 82260cc:	18c7883a 	add	r3,r3,r3
 82260d0:	18c7883a 	add	r3,r3,r3
 82260d4:	10c5883a 	add	r2,r2,r3
 82260d8:	10800017 	ldw	r2,0(r2)
 82260dc:	10800a17 	ldw	r2,40(r2)
 82260e0:	1080200c 	andi	r2,r2,128
 82260e4:	1000031e 	bne	r2,zero,82260f4 <fixup_subnet_mask+0x6c>
      smask = 0xFF000000L;
 82260e8:	00bfc034 	movhi	r2,65280
 82260ec:	e0bffe15 	stw	r2,-8(fp)
 82260f0:	00001f06 	br	8226170 <fixup_subnet_mask+0xe8>
   else if((nets[netnum]->n_ipaddr & BMASK) == BADDR)
 82260f4:	008209b4 	movhi	r2,2086
 82260f8:	10b81b04 	addi	r2,r2,-8084
 82260fc:	e0ffff17 	ldw	r3,-4(fp)
 8226100:	18c7883a 	add	r3,r3,r3
 8226104:	18c7883a 	add	r3,r3,r3
 8226108:	10c5883a 	add	r2,r2,r3
 822610c:	10800017 	ldw	r2,0(r2)
 8226110:	10800a17 	ldw	r2,40(r2)
 8226114:	1080300c 	andi	r2,r2,192
 8226118:	10802018 	cmpnei	r2,r2,128
 822611c:	1000031e 	bne	r2,zero,822612c <fixup_subnet_mask+0xa4>
      smask = 0xFFFF0000L;
 8226120:	00bffff4 	movhi	r2,65535
 8226124:	e0bffe15 	stw	r2,-8(fp)
 8226128:	00001106 	br	8226170 <fixup_subnet_mask+0xe8>
   else if((nets[netnum]->n_ipaddr & CMASK) == CADDR)
 822612c:	008209b4 	movhi	r2,2086
 8226130:	10b81b04 	addi	r2,r2,-8084
 8226134:	e0ffff17 	ldw	r3,-4(fp)
 8226138:	18c7883a 	add	r3,r3,r3
 822613c:	18c7883a 	add	r3,r3,r3
 8226140:	10c5883a 	add	r2,r2,r3
 8226144:	10800017 	ldw	r2,0(r2)
 8226148:	10800a17 	ldw	r2,40(r2)
 822614c:	1080380c 	andi	r2,r2,224
 8226150:	10803018 	cmpnei	r2,r2,192
 8226154:	1000031e 	bne	r2,zero,8226164 <fixup_subnet_mask+0xdc>
      smask = 0xFFFFFF00L;
 8226158:	00bfc004 	movi	r2,-256
 822615c:	e0bffe15 	stw	r2,-8(fp)
 8226160:	00000306 	br	8226170 <fixup_subnet_mask+0xe8>
   else
   {
      dtrap();    /* bad logic or setup values */
 8226164:	822d5940 	call	822d594 <dtrap>
      smask = 0xFFFFFF00L;
 8226168:	00bfc004 	movi	r2,-256
 822616c:	e0bffe15 	stw	r2,-8(fp)
   }
   nets[netnum]->snmask = htonl(smask);
 8226170:	008209b4 	movhi	r2,2086
 8226174:	10b81b04 	addi	r2,r2,-8084
 8226178:	e0ffff17 	ldw	r3,-4(fp)
 822617c:	18c7883a 	add	r3,r3,r3
 8226180:	18c7883a 	add	r3,r3,r3
 8226184:	10c5883a 	add	r2,r2,r3
 8226188:	10800017 	ldw	r2,0(r2)
 822618c:	e0fffe17 	ldw	r3,-8(fp)
 8226190:	1808d63a 	srli	r4,r3,24
 8226194:	e0fffe17 	ldw	r3,-8(fp)
 8226198:	1806d23a 	srli	r3,r3,8
 822619c:	18ffc00c 	andi	r3,r3,65280
 82261a0:	20c8b03a 	or	r4,r4,r3
 82261a4:	e0fffe17 	ldw	r3,-8(fp)
 82261a8:	18ffc00c 	andi	r3,r3,65280
 82261ac:	1806923a 	slli	r3,r3,8
 82261b0:	20c8b03a 	or	r4,r4,r3
 82261b4:	e0fffe17 	ldw	r3,-8(fp)
 82261b8:	1806963a 	slli	r3,r3,24
 82261bc:	20c6b03a 	or	r3,r4,r3
 82261c0:	10c00c15 	stw	r3,48(r2)
 82261c4:	00000106 	br	82261cc <fixup_subnet_mask+0x144>
fixup_subnet_mask(int netnum)      /* which of the nets[] to do. */
{
   u_long   smask;

   if (nets[netnum]->snmask)  /* if mask is already set, don't bother */
      return;
 82261c8:	0001883a 	nop
   {
      dtrap();    /* bad logic or setup values */
      smask = 0xFFFFFF00L;
   }
   nets[netnum]->snmask = htonl(smask);
}
 82261cc:	e037883a 	mov	sp,fp
 82261d0:	dfc00117 	ldw	ra,4(sp)
 82261d4:	df000017 	ldw	fp,0(sp)
 82261d8:	dec00204 	addi	sp,sp,8
 82261dc:	f800283a 	ret

082261e0 <netclose>:
 * RETURNS: 
 */

void
netclose()
{
 82261e0:	defffc04 	addi	sp,sp,-16
 82261e4:	dfc00315 	stw	ra,12(sp)
 82261e8:	df000215 	stw	fp,8(sp)
 82261ec:	df000204 	addi	fp,sp,8
   NET ifp;
   int index = 0;
 82261f0:	e03fff15 	stw	zero,-4(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
 82261f4:	d0a08317 	ldw	r2,-32244(gp)
 82261f8:	1080010c 	andi	r2,r2,4
 82261fc:	10000326 	beq	r2,zero,822620c <netclose+0x2c>
 8226200:	01020974 	movhi	r4,2085
 8226204:	213fb704 	addi	r4,r4,-292
 8226208:	82036240 	call	8203624 <puts>
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 822620c:	008209b4 	movhi	r2,2086
 8226210:	10ba5c04 	addi	r2,r2,-5776
 8226214:	10800017 	ldw	r2,0(r2)
 8226218:	e0bffe15 	stw	r2,-8(fp)
 822621c:	00002106 	br	82262a4 <netclose+0xc4>
   {
      if (ifp->n_close)
 8226220:	e0bffe17 	ldw	r2,-8(fp)
 8226224:	10800517 	ldw	r2,20(r2)
 8226228:	10000f26 	beq	r2,zero,8226268 <netclose+0x88>
      {
         dprintf("netclose: closing iface %s\n", ifp->n_mib->ifDescr);
 822622c:	e0bffe17 	ldw	r2,-8(fp)
 8226230:	10802717 	ldw	r2,156(r2)
 8226234:	10800117 	ldw	r2,4(r2)
 8226238:	100b883a 	mov	r5,r2
 822623c:	01020974 	movhi	r4,2085
 8226240:	213fbc04 	addi	r4,r4,-272
 8226244:	82033a00 	call	82033a0 <printf>
         (*(ifp->n_close))(index++);
 8226248:	e0bffe17 	ldw	r2,-8(fp)
 822624c:	10c00517 	ldw	r3,20(r2)
 8226250:	e0bfff17 	ldw	r2,-4(fp)
 8226254:	11000044 	addi	r4,r2,1
 8226258:	e13fff15 	stw	r4,-4(fp)
 822625c:	1009883a 	mov	r4,r2
 8226260:	183ee83a 	callr	r3
 8226264:	00000c06 	br	8226298 <netclose+0xb8>
      }
      else
      {
#ifdef NPDEBUG
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
 8226268:	d0a08317 	ldw	r2,-32244(gp)
 822626c:	1080010c 	andi	r2,r2,4
 8226270:	10000626 	beq	r2,zero,822628c <netclose+0xac>
 8226274:	e0bffe17 	ldw	r2,-8(fp)
 8226278:	10800104 	addi	r2,r2,4
 822627c:	100b883a 	mov	r5,r2
 8226280:	01020974 	movhi	r4,2085
 8226284:	213fc304 	addi	r4,r4,-244
 8226288:	82033a00 	call	82033a0 <printf>
#endif
         index++;
 822628c:	e0bfff17 	ldw	r2,-4(fp)
 8226290:	10800044 	addi	r2,r2,1
 8226294:	e0bfff15 	stw	r2,-4(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 8226298:	e0bffe17 	ldw	r2,-8(fp)
 822629c:	10800017 	ldw	r2,0(r2)
 82262a0:	e0bffe15 	stw	r2,-8(fp)
 82262a4:	e0bffe17 	ldw	r2,-8(fp)
 82262a8:	103fdd1e 	bne	r2,zero,8226220 <netclose+0x40>
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
#endif
         index++;
      }
   }
}
 82262ac:	0001883a 	nop
 82262b0:	e037883a 	mov	sp,fp
 82262b4:	dfc00117 	ldw	ra,4(sp)
 82262b8:	df000017 	ldw	fp,0(sp)
 82262bc:	dec00204 	addi	sp,sp,8
 82262c0:	f800283a 	ret

082262c4 <pktdemux>:
 * RETURNS: void
 */

void
pktdemux()
{
 82262c4:	defff904 	addi	sp,sp,-28
 82262c8:	dfc00615 	stw	ra,24(sp)
 82262cc:	df000515 	stw	fp,20(sp)
 82262d0:	df000504 	addi	fp,sp,20
   NET      ifc;                /* interface packet came from */
   IFMIB    mib;
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */
 82262d4:	e03ffb15 	stw	zero,-20(fp)

   while (rcvdq.q_len)
 82262d8:	0000d906 	br	8226640 <pktdemux+0x37c>
   {
      /* If we are low on free packets, don't hog CPU cycles */
      if (pkts++ > bigfreeq.q_len)
 82262dc:	e0fffb17 	ldw	r3,-20(fp)
 82262e0:	18800044 	addi	r2,r3,1
 82262e4:	e0bffb15 	stw	r2,-20(fp)
 82262e8:	008209b4 	movhi	r2,2086
 82262ec:	10b8c204 	addi	r2,r2,-7416
 82262f0:	10800217 	ldw	r2,8(r2)
 82262f4:	10c0020e 	bge	r2,r3,8226300 <pktdemux+0x3c>
      {
#ifdef SUPERLOOP
         return;        /* don't hog stack on superloop */
#else    /* SUPERLOOP */
         tk_yield(); /* let application tasks process received packets */
 82262f8:	822980c0 	call	822980c <tk_yield>
         pkts = 0;   /* reset counter */
 82262fc:	e03ffb15 	stw	zero,-20(fp)
#endif   /* SUPERLOOP else */
      }

      /* If we get receive interupt from the net during this
      lock, the MAC driver needs to wait or reschedule */
      LOCK_NET_RESOURCE(RXQ_RESID);
 8226300:	01000044 	movi	r4,1
 8226304:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pkt = (PACKET)q_deq(&rcvdq);
 8226308:	010209b4 	movhi	r4,2086
 822630c:	21375604 	addi	r4,r4,-8872
 8226310:	822cec40 	call	822cec4 <getq>
 8226314:	e0bffc15 	stw	r2,-16(fp)
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 8226318:	01000044 	movi	r4,1
 822631c:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      if (!pkt) panic("pktdemux: got null pkt");
 8226320:	e0bffc17 	ldw	r2,-16(fp)
 8226324:	1000031e 	bne	r2,zero,8226334 <pktdemux+0x70>
 8226328:	01020974 	movhi	r4,2085
 822632c:	213fca04 	addi	r4,r4,-216
 8226330:	8228c480 	call	8228c48 <panic>
      ifc = pkt->net;
 8226334:	e0bffc17 	ldw	r2,-16(fp)
 8226338:	10800617 	ldw	r2,24(r2)
 822633c:	e0bffd15 	stw	r2,-12(fp)

      mib = ifc->n_mib;
 8226340:	e0bffd17 	ldw	r2,-12(fp)
 8226344:	10802717 	ldw	r2,156(r2)
 8226348:	e0bffe15 	stw	r2,-8(fp)
      /* maintain mib stats for unicast and broadcast */
      if (isbcast(ifc, (u_char*)pkt->nb_buff + ETHHDR_BIAS))
 822634c:	e0bffc17 	ldw	r2,-16(fp)
 8226350:	10800117 	ldw	r2,4(r2)
 8226354:	10800084 	addi	r2,r2,2
 8226358:	100b883a 	mov	r5,r2
 822635c:	e13ffd17 	ldw	r4,-12(fp)
 8226360:	823edb80 	call	823edb8 <isbcast>
 8226364:	10000626 	beq	r2,zero,8226380 <pktdemux+0xbc>
         mib->ifInNUcastPkts++;
 8226368:	e0bffe17 	ldw	r2,-8(fp)
 822636c:	10800b17 	ldw	r2,44(r2)
 8226370:	10c00044 	addi	r3,r2,1
 8226374:	e0bffe17 	ldw	r2,-8(fp)
 8226378:	10c00b15 	stw	r3,44(r2)
 822637c:	00000506 	br	8226394 <pktdemux+0xd0>
      else
         mib->ifInUcastPkts++;
 8226380:	e0bffe17 	ldw	r2,-8(fp)
 8226384:	10800a17 	ldw	r2,40(r2)
 8226388:	10c00044 	addi	r3,r2,1
 822638c:	e0bffe17 	ldw	r2,-8(fp)
 8226390:	10c00a15 	stw	r3,40(r2)

      if(mib->ifAdminStatus == NI_DOWN)
 8226394:	e0bffe17 	ldw	r2,-8(fp)
 8226398:	10800617 	ldw	r2,24(r2)
 822639c:	10800098 	cmpnei	r2,r2,2
 82263a0:	10000c1e 	bne	r2,zero,82263d4 <pktdemux+0x110>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 82263a4:	01000084 	movi	r4,2
 82263a8:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
         pk_free(pkt);  /* dump packet from downed interface */
 82263ac:	e13ffc17 	ldw	r4,-16(fp)
 82263b0:	822cd3c0 	call	822cd3c <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82263b4:	01000084 	movi	r4,2
 82263b8:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         mib->ifInDiscards++;
 82263bc:	e0bffe17 	ldw	r2,-8(fp)
 82263c0:	10800c17 	ldw	r2,48(r2)
 82263c4:	10c00044 	addi	r3,r2,1
 82263c8:	e0bffe17 	ldw	r2,-8(fp)
 82263cc:	10c00c15 	stw	r3,48(r2)
         continue;      /* next packet */
 82263d0:	00009b06 	br	8226640 <pktdemux+0x37c>
      }

#ifdef NPDEBUG
      if (*(pkt->nb_buff - ALIGN_TYPE) != 'M' ||
 82263d4:	e0bffc17 	ldw	r2,-16(fp)
 82263d8:	10800117 	ldw	r2,4(r2)
 82263dc:	10bfff04 	addi	r2,r2,-4
 82263e0:	10800003 	ldbu	r2,0(r2)
 82263e4:	10803fcc 	andi	r2,r2,255
 82263e8:	1080201c 	xori	r2,r2,128
 82263ec:	10bfe004 	addi	r2,r2,-128
 82263f0:	10801358 	cmpnei	r2,r2,77
 82263f4:	10000b1e 	bne	r2,zero,8226424 <pktdemux+0x160>
          *(pkt->nb_buff + pkt->nb_blen) != 'M')
 82263f8:	e0bffc17 	ldw	r2,-16(fp)
 82263fc:	10c00117 	ldw	r3,4(r2)
 8226400:	e0bffc17 	ldw	r2,-16(fp)
 8226404:	10800217 	ldw	r2,8(r2)
 8226408:	1885883a 	add	r2,r3,r2
 822640c:	10800003 	ldbu	r2,0(r2)
         mib->ifInDiscards++;
         continue;      /* next packet */
      }

#ifdef NPDEBUG
      if (*(pkt->nb_buff - ALIGN_TYPE) != 'M' ||
 8226410:	10803fcc 	andi	r2,r2,255
 8226414:	1080201c 	xori	r2,r2,128
 8226418:	10bfe004 	addi	r2,r2,-128
 822641c:	10801360 	cmpeqi	r2,r2,77
 8226420:	1000041e 	bne	r2,zero,8226434 <pktdemux+0x170>
          *(pkt->nb_buff + pkt->nb_blen) != 'M')
      {
         dtrap();
 8226424:	822d5940 	call	822d594 <dtrap>
         panic("pktdemux: corrupt pkt");
 8226428:	01020974 	movhi	r4,2085
 822642c:	213fd004 	addi	r4,r4,-192
 8226430:	8228c480 	call	8228c48 <panic>
         }
      }
#endif   /* LOSSY_IO */

      /* see if driver set pkt->nb_prot and pkt->type */
      if((ifc->n_flags & NF_NBPROT) == 0)
 8226434:	e0bffd17 	ldw	r2,-12(fp)
 8226438:	10802a17 	ldw	r2,168(r2)
 822643c:	1080020c 	andi	r2,r2,8
 8226440:	1000491e 	bne	r2,zero,8226568 <pktdemux+0x2a4>
          * probably the right thing to do, but because of this historic
          * inconsistency we don't try to fix it here - the longer size
          * turns out to be harmless since the IP layer fixes the size
          * based on the IP header length field.
          */
         switch(ifc->n_mib->ifType)
 8226444:	e0bffd17 	ldw	r2,-12(fp)
 8226448:	10802717 	ldw	r2,156(r2)
 822644c:	10800217 	ldw	r2,8(r2)
 8226450:	108001a0 	cmpeqi	r2,r2,6
 8226454:	10003626 	beq	r2,zero,8226530 <pktdemux+0x26c>
         {
         case ETHERNET:
            /* get pointer to ethernet header */
            eth = (pkt->nb_buff + ETHHDR_BIAS);
 8226458:	e0bffc17 	ldw	r2,-16(fp)
 822645c:	10800117 	ldw	r2,4(r2)
 8226460:	10800084 	addi	r2,r2,2
 8226464:	e0bfff15 	stw	r2,-4(fp)
            {
               pkt->type = htons((unshort)ET_TYPE_GET(eth));
               pkt->nb_prot = pkt->nb_buff + ETHHDR_SIZE;
            }
#else
            pkt->type = htons((unshort)ET_TYPE_GET(eth));
 8226468:	e0bfff17 	ldw	r2,-4(fp)
 822646c:	10800304 	addi	r2,r2,12
 8226470:	10800003 	ldbu	r2,0(r2)
 8226474:	10803fcc 	andi	r2,r2,255
 8226478:	1080201c 	xori	r2,r2,128
 822647c:	10bfe004 	addi	r2,r2,-128
 8226480:	1004923a 	slli	r2,r2,8
 8226484:	1007883a 	mov	r3,r2
 8226488:	e0bfff17 	ldw	r2,-4(fp)
 822648c:	10800344 	addi	r2,r2,13
 8226490:	10800003 	ldbu	r2,0(r2)
 8226494:	10803fcc 	andi	r2,r2,255
 8226498:	1080201c 	xori	r2,r2,128
 822649c:	10bfe004 	addi	r2,r2,-128
 82264a0:	10803fcc 	andi	r2,r2,255
 82264a4:	1885883a 	add	r2,r3,r2
 82264a8:	10bfffcc 	andi	r2,r2,65535
 82264ac:	1004d23a 	srli	r2,r2,8
 82264b0:	1007883a 	mov	r3,r2
 82264b4:	e0bfff17 	ldw	r2,-4(fp)
 82264b8:	10800304 	addi	r2,r2,12
 82264bc:	10800003 	ldbu	r2,0(r2)
 82264c0:	10803fcc 	andi	r2,r2,255
 82264c4:	1080201c 	xori	r2,r2,128
 82264c8:	10bfe004 	addi	r2,r2,-128
 82264cc:	1004923a 	slli	r2,r2,8
 82264d0:	1009883a 	mov	r4,r2
 82264d4:	e0bfff17 	ldw	r2,-4(fp)
 82264d8:	10800344 	addi	r2,r2,13
 82264dc:	10800003 	ldbu	r2,0(r2)
 82264e0:	10803fcc 	andi	r2,r2,255
 82264e4:	1080201c 	xori	r2,r2,128
 82264e8:	10bfe004 	addi	r2,r2,-128
 82264ec:	10803fcc 	andi	r2,r2,255
 82264f0:	2085883a 	add	r2,r4,r2
 82264f4:	10bfffcc 	andi	r2,r2,65535
 82264f8:	1004923a 	slli	r2,r2,8
 82264fc:	1884b03a 	or	r2,r3,r2
 8226500:	1007883a 	mov	r3,r2
 8226504:	e0bffc17 	ldw	r2,-16(fp)
 8226508:	10c0080d 	sth	r3,32(r2)
            pkt->nb_prot = pkt->nb_buff + pkt->net->n_lnh;
 822650c:	e0bffc17 	ldw	r2,-16(fp)
 8226510:	10800117 	ldw	r2,4(r2)
 8226514:	e0fffc17 	ldw	r3,-16(fp)
 8226518:	18c00617 	ldw	r3,24(r3)
 822651c:	18c00817 	ldw	r3,32(r3)
 8226520:	10c7883a 	add	r3,r2,r3
 8226524:	e0bffc17 	ldw	r2,-16(fp)
 8226528:	10c00315 	stw	r3,12(r2)
#endif   /* IEEE_802_3 */
            break;
 822652c:	00000e06 	br	8226568 <pktdemux+0x2a4>
         case PPPOE:
            /* do not change type yet, for PPPoE */
            break;
#endif   /* USE_PPPOE */
         default:    /* driver bug? */
            dprintf("pktdemux: bad Iface type %ld\n",ifc->n_mib->ifType);
 8226530:	e0bffd17 	ldw	r2,-12(fp)
 8226534:	10802717 	ldw	r2,156(r2)
 8226538:	10800217 	ldw	r2,8(r2)
 822653c:	100b883a 	mov	r5,r2
 8226540:	01020974 	movhi	r4,2085
 8226544:	213fd604 	addi	r4,r4,-168
 8226548:	82033a00 	call	82033a0 <printf>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 822654c:	01000084 	movi	r4,2
 8226550:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
            pk_free(pkt);
 8226554:	e13ffc17 	ldw	r4,-16(fp)
 8226558:	822cd3c0 	call	822cd3c <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822655c:	01000084 	movi	r4,2
 8226560:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
            continue;
 8226564:	00003606 	br	8226640 <pktdemux+0x37c>
         }
      }

      /* pkt->nb_prot and pkt->type are now set. pass pkt to upper layer */
      switch(pkt->type)
 8226568:	e0bffc17 	ldw	r2,-16(fp)
 822656c:	1080080b 	ldhu	r2,32(r2)
 8226570:	10bfffcc 	andi	r2,r2,65535
 8226574:	10c00220 	cmpeqi	r3,r2,8
 8226578:	1800031e 	bne	r3,zero,8226588 <pktdemux+0x2c4>
 822657c:	10818220 	cmpeqi	r2,r2,1544
 8226580:	1000081e 	bne	r2,zero,82265a4 <pktdemux+0x2e0>
 8226584:	00000e06 	br	82265c0 <pktdemux+0x2fc>
      {
      case IPTP:     /* IP type */
         LOCK_NET_RESOURCE(NET_RESID);
 8226588:	0009883a 	mov	r4,zero
 822658c:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
#ifdef SHARED_IPADDRS
         add_share_route(pkt);
#endif /* SHARED_IPADDRS */
#ifdef IP_V4
         ip_rcv(pkt);
 8226590:	e13ffc17 	ldw	r4,-16(fp)
 8226594:	8242c300 	call	8242c30 <ip_rcv>
            /* don't care, it's IPv4 */
            LOCK_NET_RESOURCE(FREEQ_RESID);
            pk_free(pkt);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif
		UNLOCK_NET_RESOURCE(NET_RESID);
 8226598:	0009883a 	mov	r4,zero
 822659c:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         break;
 82265a0:	00002606 	br	822663c <pktdemux+0x378>
#ifdef INCLUDE_ARP
      case ARPTP:       /* ARP type */
         LOCK_NET_RESOURCE(NET_RESID);
 82265a4:	0009883a 	mov	r4,zero
 82265a8:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
         arprcv(pkt);
 82265ac:	e13ffc17 	ldw	r4,-16(fp)
 82265b0:	823e5a00 	call	823e5a0 <arprcv>
         UNLOCK_NET_RESOURCE(NET_RESID);
 82265b4:	0009883a 	mov	r4,zero
 82265b8:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         break;
 82265bc:	00001f06 	br	822663c <pktdemux+0x378>
         UNLOCK_NET_RESOURCE(NET_RESID);
         break;
#endif
      default:
#ifdef NPDEBUG
         if (NDEBUG & UPCTRACE)
 82265c0:	d0a08317 	ldw	r2,-32244(gp)
 82265c4:	1081000c 	andi	r2,r2,1024
 82265c8:	10001026 	beq	r2,zero,822660c <pktdemux+0x348>
            dprintf("pktdemux: bad pkt type 0x%04x\n", ntohs(pkt->type));
 82265cc:	e0bffc17 	ldw	r2,-16(fp)
 82265d0:	1080080b 	ldhu	r2,32(r2)
 82265d4:	10bfffcc 	andi	r2,r2,65535
 82265d8:	1004d23a 	srli	r2,r2,8
 82265dc:	10bfffcc 	andi	r2,r2,65535
 82265e0:	10c03fcc 	andi	r3,r2,255
 82265e4:	e0bffc17 	ldw	r2,-16(fp)
 82265e8:	1080080b 	ldhu	r2,32(r2)
 82265ec:	10bfffcc 	andi	r2,r2,65535
 82265f0:	1004923a 	slli	r2,r2,8
 82265f4:	10bfffcc 	andi	r2,r2,65535
 82265f8:	1884b03a 	or	r2,r3,r2
 82265fc:	100b883a 	mov	r5,r2
 8226600:	01020974 	movhi	r4,2085
 8226604:	213fde04 	addi	r4,r4,-136
 8226608:	82033a00 	call	82033a0 <printf>
#endif   /* NPDEBUG */
         ifc->n_mib->ifInUnknownProtos++;
 822660c:	e0bffd17 	ldw	r2,-12(fp)
 8226610:	10802717 	ldw	r2,156(r2)
 8226614:	10c00e17 	ldw	r3,56(r2)
 8226618:	18c00044 	addi	r3,r3,1
 822661c:	10c00e15 	stw	r3,56(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 8226620:	01000084 	movi	r4,2
 8226624:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
         pk_free(pkt);           /* return to free buffer */
 8226628:	e13ffc17 	ldw	r4,-16(fp)
 822662c:	822cd3c0 	call	822cd3c <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8226630:	01000084 	movi	r4,2
 8226634:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         break;
 8226638:	0001883a 	nop
      }
      continue;
 822663c:	0001883a 	nop
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */

   while (rcvdq.q_len)
 8226640:	008209b4 	movhi	r2,2086
 8226644:	10b75604 	addi	r2,r2,-8872
 8226648:	10800217 	ldw	r2,8(r2)
 822664c:	103f231e 	bne	r2,zero,82262dc <pktdemux+0x18>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
         break;
      }
      continue;
   }
}
 8226650:	0001883a 	nop
 8226654:	e037883a 	mov	sp,fp
 8226658:	dfc00117 	ldw	ra,4(sp)
 822665c:	df000017 	ldw	fp,0(sp)
 8226660:	dec00204 	addi	sp,sp,8
 8226664:	f800283a 	ret

08226668 <c_older>:
 * RETURNS: the older of the two passed tick counts
 */

u_long
c_older(u_long ct1, u_long ct2)
{
 8226668:	defffd04 	addi	sp,sp,-12
 822666c:	df000215 	stw	fp,8(sp)
 8226670:	df000204 	addi	fp,sp,8
 8226674:	e13ffe15 	stw	r4,-8(fp)
 8226678:	e17fff15 	stw	r5,-4(fp)

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
 822667c:	d0a0a817 	ldw	r2,-32096(gp)
 8226680:	10000c0e 	bge	r2,zero,82266b4 <c_older+0x4c>
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
 8226684:	d0e0a817 	ldw	r3,-32096(gp)

u_long
c_older(u_long ct1, u_long ct2)
{

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
 8226688:	e0bffe17 	ldw	r2,-8(fp)
 822668c:	18800336 	bltu	r3,r2,822669c <c_older+0x34>
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
 8226690:	d0e0a817 	ldw	r3,-32096(gp)
 8226694:	e0bfff17 	ldw	r2,-4(fp)
 8226698:	1880062e 	bgeu	r3,r2,82266b4 <c_older+0x4c>
       (ct1 >= cticks && ct2 >= cticks))   /* both are above cticks */
 822669c:	d0a0a817 	ldw	r2,-32096(gp)
u_long
c_older(u_long ct1, u_long ct2)
{

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
 82266a0:	e0fffe17 	ldw	r3,-8(fp)
 82266a4:	18800a36 	bltu	r3,r2,82266d0 <c_older+0x68>
       (ct1 >= cticks && ct2 >= cticks))   /* both are above cticks */
 82266a8:	d0a0a817 	ldw	r2,-32096(gp)
 82266ac:	e0ffff17 	ldw	r3,-4(fp)
 82266b0:	18800736 	bltu	r3,r2,82266d0 <c_older+0x68>
   {
      if (ct1 < ct2)
 82266b4:	e0fffe17 	ldw	r3,-8(fp)
 82266b8:	e0bfff17 	ldw	r2,-4(fp)
 82266bc:	1880022e 	bgeu	r3,r2,82266c8 <c_older+0x60>
         return(ct1);      /* then smaller is oldest */
 82266c0:	e0bffe17 	ldw	r2,-8(fp)
 82266c4:	00000806 	br	82266e8 <c_older+0x80>
      else 
         return(ct2);
 82266c8:	e0bfff17 	ldw	r2,-4(fp)
 82266cc:	00000606 	br	82266e8 <c_older+0x80>
   }

   /* else one is less than cticks, and one is greater.
   the larger value is then the oldest */
   if (ct1 >= ct2)
 82266d0:	e0fffe17 	ldw	r3,-8(fp)
 82266d4:	e0bfff17 	ldw	r2,-4(fp)
 82266d8:	18800236 	bltu	r3,r2,82266e4 <c_older+0x7c>
      return(ct1);
 82266dc:	e0bffe17 	ldw	r2,-8(fp)
 82266e0:	00000106 	br	82266e8 <c_older+0x80>
   else
      return(ct2);
 82266e4:	e0bfff17 	ldw	r2,-4(fp)
}
 82266e8:	e037883a 	mov	sp,fp
 82266ec:	df000017 	ldw	fp,0(sp)
 82266f0:	dec00104 	addi	sp,sp,4
 82266f4:	f800283a 	ret

082266f8 <ip2mac>:
 */

int
ip2mac(PACKET pkt,         /* the packet itself, all set but for dest MAC address */
   ip_addr  dest_ip)    /* the IP host or gateway to get MAC addr for */
{
 82266f8:	defffb04 	addi	sp,sp,-20
 82266fc:	dfc00415 	stw	ra,16(sp)
 8226700:	df000315 	stw	fp,12(sp)
 8226704:	df000304 	addi	fp,sp,12
 8226708:	e13ffe15 	stw	r4,-8(fp)
 822670c:	e17fff15 	stw	r5,-4(fp)
   IFMIB ifmib = pkt->net->n_mib;   /* mib info for this interface */
 8226710:	e0bffe17 	ldw	r2,-8(fp)
 8226714:	10800617 	ldw	r2,24(r2)
 8226718:	10802717 	ldw	r2,156(r2)
 822671c:	e0bffd15 	stw	r2,-12(fp)

   /* Always punt if iface ifAdminStatus is DOWN. ifOperStatus may 
    * be down too, but our packet may be the event required to bring 
    * it up - so don't worry about ifOperStatus here.
    */
   if(ifmib->ifAdminStatus == NI_DOWN)
 8226720:	e0bffd17 	ldw	r2,-12(fp)
 8226724:	10800617 	ldw	r2,24(r2)
 8226728:	10800098 	cmpnei	r2,r2,2
 822672c:	1000081e 	bne	r2,zero,8226750 <ip2mac+0x58>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 8226730:	01000084 	movi	r4,2
 8226734:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 8226738:	e13ffe17 	ldw	r4,-8(fp)
 822673c:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8226740:	01000084 	movi	r4,2
 8226744:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return(ENP_NO_ROUTE);
 8226748:	00bff7c4 	movi	r2,-33
 822674c:	00004806 	br	8226870 <ip2mac+0x178>
         return ENP_NOBUFFER;
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
 8226750:	e0bffe17 	ldw	r2,-8(fp)
 8226754:	10800617 	ldw	r2,24(r2)
 8226758:	10800817 	ldw	r2,32(r2)
 822675c:	10000826 	beq	r2,zero,8226780 <ip2mac+0x88>
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
 8226760:	e0bffd17 	ldw	r2,-12(fp)
 8226764:	10800217 	ldw	r2,8(r2)
         return ENP_NOBUFFER;
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
 8226768:	108005e0 	cmpeqi	r2,r2,23
 822676c:	1000041e 	bne	r2,zero,8226780 <ip2mac+0x88>
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
       (ifmib->ifType == SLIP))
 8226770:	e0bffd17 	ldw	r2,-12(fp)
 8226774:	10800217 	ldw	r2,8(r2)
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
 8226778:	10800718 	cmpnei	r2,r2,28
 822677c:	1000291e 	bne	r2,zero,8226824 <ip2mac+0x12c>
       (ifmib->ifType == SLIP))
   {
      ifmib->ifOutUcastPkts++;   /* maintain MIB counters */
 8226780:	e0bffd17 	ldw	r2,-12(fp)
 8226784:	10801017 	ldw	r2,64(r2)
 8226788:	10c00044 	addi	r3,r2,1
 822678c:	e0bffd17 	ldw	r2,-12(fp)
 8226790:	10c01015 	stw	r3,64(r2)
      ifmib->ifOutOctets += pkt->nb_plen;
 8226794:	e0bffd17 	ldw	r2,-12(fp)
 8226798:	10c00f17 	ldw	r3,60(r2)
 822679c:	e0bffe17 	ldw	r2,-8(fp)
 82267a0:	10800417 	ldw	r2,16(r2)
 82267a4:	1887883a 	add	r3,r3,r2
 82267a8:	e0bffd17 	ldw	r2,-12(fp)
 82267ac:	10c00f15 	stw	r3,60(r2)

      /* send packet on media */
      if (pkt->net->pkt_send) /* favor using packet send */
 82267b0:	e0bffe17 	ldw	r2,-8(fp)
 82267b4:	10800617 	ldw	r2,24(r2)
 82267b8:	10800417 	ldw	r2,16(r2)
 82267bc:	10000626 	beq	r2,zero,82267d8 <ip2mac+0xe0>
         pkt->net->pkt_send(pkt);   /* pkt will be freed by MAC code */
 82267c0:	e0bffe17 	ldw	r2,-8(fp)
 82267c4:	10800617 	ldw	r2,24(r2)
 82267c8:	10800417 	ldw	r2,16(r2)
 82267cc:	e13ffe17 	ldw	r4,-8(fp)
 82267d0:	103ee83a 	callr	r2
 82267d4:	00001106 	br	822681c <ip2mac+0x124>
      else  /* no packet send; try raw send */
      {
         pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 82267d8:	e0bffe17 	ldw	r2,-8(fp)
 82267dc:	10800617 	ldw	r2,24(r2)
 82267e0:	10800317 	ldw	r2,12(r2)
 82267e4:	e0fffe17 	ldw	r3,-8(fp)
 82267e8:	19000617 	ldw	r4,24(r3)
 82267ec:	e0fffe17 	ldw	r3,-8(fp)
 82267f0:	19400317 	ldw	r5,12(r3)
 82267f4:	e0fffe17 	ldw	r3,-8(fp)
 82267f8:	18c00417 	ldw	r3,16(r3)
 82267fc:	180d883a 	mov	r6,r3
 8226800:	103ee83a 	callr	r2
         LOCK_NET_RESOURCE(FREEQ_RESID);
 8226804:	01000084 	movi	r4,2
 8226808:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 822680c:	e13ffe17 	ldw	r4,-8(fp)
 8226810:	822cd3c0 	call	822cd3c <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8226814:	01000084 	movi	r4,2
 8226818:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      }
      return(SUCCESS);
 822681c:	0005883a 	mov	r2,zero
 8226820:	00001306 	br	8226870 <ip2mac+0x178>
   }

   /* don't allow unicast sends if NIC iface has no IP address. This
    * is to prevent DHCP clients from sending prior to assignment.
    */
   if (pkt->net->n_ipaddr == 0L)
 8226824:	e0bffe17 	ldw	r2,-8(fp)
 8226828:	10800617 	ldw	r2,24(r2)
 822682c:	10800a17 	ldw	r2,40(r2)
 8226830:	10000c1e 	bne	r2,zero,8226864 <ip2mac+0x16c>
   {
      if (pkt->fhost != 0xFFFFFFFF) /* check for broadcast packet */
 8226834:	e0bffe17 	ldw	r2,-8(fp)
 8226838:	10800717 	ldw	r2,28(r2)
 822683c:	10bfffe0 	cmpeqi	r2,r2,-1
 8226840:	1000081e 	bne	r2,zero,8226864 <ip2mac+0x16c>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 8226844:	01000084 	movi	r4,2
 8226848:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 822684c:	e13ffe17 	ldw	r4,-8(fp)
 8226850:	822cd3c0 	call	822cd3c <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8226854:	01000084 	movi	r4,2
 8226858:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         return ENP_SENDERR;
 822685c:	00bff884 	movi	r2,-30
 8226860:	00000306 	br	8226870 <ip2mac+0x178>
      }
   }

#ifdef INCLUDE_ARP   /* must be ethernet or token ring */
   return(send_via_arp(pkt, dest_ip));
 8226864:	e17fff17 	ldw	r5,-4(fp)
 8226868:	e13ffe17 	ldw	r4,-8(fp)
 822686c:	823e8040 	call	823e804 <send_via_arp>
#else
   dtrap();    /* Bad option combination? */
   return ENP_NO_IFACE; /* sent to unknown interface type */
#endif   /* INCLUDE_ARP */
}
 8226870:	e037883a 	mov	sp,fp
 8226874:	dfc00117 	ldw	ra,4(sp)
 8226878:	df000017 	ldw	fp,0(sp)
 822687c:	dec00204 	addi	sp,sp,8
 8226880:	f800283a 	ret

08226884 <ip_startup>:
 * RETURNS: returns NULL if OK, or text of an error message 
 */

char *   
ip_startup()
{
 8226884:	defffc04 	addi	sp,sp,-16
 8226888:	dfc00315 	stw	ra,12(sp)
 822688c:	df000215 	stw	fp,8(sp)
 8226890:	df000204 	addi	fp,sp,8
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 8226894:	e03ffe15 	stw	zero,-8(fp)
 8226898:	00002a06 	br	8226944 <ip_startup+0xc0>
   {
      nets[i] = &netstatic[i];   /* set up array of pointers */
 822689c:	e0bffe17 	ldw	r2,-8(fp)
 82268a0:	10c03024 	muli	r3,r2,192
 82268a4:	008209b4 	movhi	r2,2086
 82268a8:	10b75b04 	addi	r2,r2,-8852
 82268ac:	1889883a 	add	r4,r3,r2
 82268b0:	008209b4 	movhi	r2,2086
 82268b4:	10b81b04 	addi	r2,r2,-8084
 82268b8:	e0fffe17 	ldw	r3,-8(fp)
 82268bc:	18c7883a 	add	r3,r3,r3
 82268c0:	18c7883a 	add	r3,r3,r3
 82268c4:	10c5883a 	add	r2,r2,r3
 82268c8:	11000015 	stw	r4,0(r2)
      nets[i]->n_mib = &nets[i]->mib;   /* set mib pointer */
 82268cc:	008209b4 	movhi	r2,2086
 82268d0:	10b81b04 	addi	r2,r2,-8084
 82268d4:	e0fffe17 	ldw	r3,-8(fp)
 82268d8:	18c7883a 	add	r3,r3,r3
 82268dc:	18c7883a 	add	r3,r3,r3
 82268e0:	10c5883a 	add	r2,r2,r3
 82268e4:	11000017 	ldw	r4,0(r2)
 82268e8:	008209b4 	movhi	r2,2086
 82268ec:	10b81b04 	addi	r2,r2,-8084
 82268f0:	e0fffe17 	ldw	r3,-8(fp)
 82268f4:	18c7883a 	add	r3,r3,r3
 82268f8:	18c7883a 	add	r3,r3,r3
 82268fc:	10c5883a 	add	r2,r2,r3
 8226900:	10800017 	ldw	r2,0(r2)
 8226904:	10801204 	addi	r2,r2,72
 8226908:	20802715 	stw	r2,156(r4)

      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
 822690c:	008209b4 	movhi	r2,2086
 8226910:	10b81b04 	addi	r2,r2,-8084
 8226914:	e0fffe17 	ldw	r3,-8(fp)
 8226918:	18c7883a 	add	r3,r3,r3
 822691c:	18c7883a 	add	r3,r3,r3
 8226920:	10c5883a 	add	r2,r2,r3
 8226924:	10800017 	ldw	r2,0(r2)
 8226928:	100b883a 	mov	r5,r2
 822692c:	010209b4 	movhi	r4,2086
 8226930:	213a5c04 	addi	r4,r4,-5776
 8226934:	822cf7c0 	call	822cf7c <putq>
{
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 8226938:	e0bffe17 	ldw	r2,-8(fp)
 822693c:	10800044 	addi	r2,r2,1
 8226940:	e0bffe15 	stw	r2,-8(fp)
 8226944:	e0bffe17 	ldw	r2,-8(fp)
 8226948:	10800110 	cmplti	r2,r2,4
 822694c:	103fd31e 	bne	r2,zero,822689c <ip_startup+0x18>
      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
   }

   /* call port routine to locate and init network interfaces. */
   ifNumber = (unsigned)prep_ifaces(ifNumber);
 8226950:	d0a08417 	ldw	r2,-32240(gp)
 8226954:	1009883a 	mov	r4,r2
 8226958:	8243c0c0 	call	8243c0c <prep_ifaces>
 822695c:	d0a08415 	stw	r2,-32240(gp)

   if (ifNumber < 1)    /* no static interfaces? */
 8226960:	d0a08417 	ldw	r2,-32240(gp)
 8226964:	1000031e 	bne	r2,zero,8226974 <ip_startup+0xf0>
#ifdef DYNAMIC_IFACES
      /* print a debug message and hope user knows what he's doing */
      dprintf("unable to find any working interfaces");
#else /* static ifaces only */
      /* no static and no dynamic interfaces is probably a bug... */
      return("unable to find any working interfaces");
 8226968:	00820974 	movhi	r2,2085
 822696c:	10bfef04 	addi	r2,r2,-68
 8226970:	00006806 	br	8226b14 <ip_startup+0x290>
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 8226974:	d0a08417 	ldw	r2,-32240(gp)
 8226978:	e0bffe15 	stw	r2,-8(fp)
 822697c:	00001506 	br	82269d4 <ip_startup+0x150>
   {
      qdel(&netlist, (qp)nets[i]);  /* remove from queue */
 8226980:	008209b4 	movhi	r2,2086
 8226984:	10b81b04 	addi	r2,r2,-8084
 8226988:	e0fffe17 	ldw	r3,-8(fp)
 822698c:	18c7883a 	add	r3,r3,r3
 8226990:	18c7883a 	add	r3,r3,r3
 8226994:	10c5883a 	add	r2,r2,r3
 8226998:	10800017 	ldw	r2,0(r2)
 822699c:	100b883a 	mov	r5,r2
 82269a0:	010209b4 	movhi	r4,2086
 82269a4:	213a5c04 	addi	r4,r4,-5776
 82269a8:	822d02c0 	call	822d02c <qdel>
      nets[i] = NULL;               /* remove from array */
 82269ac:	008209b4 	movhi	r2,2086
 82269b0:	10b81b04 	addi	r2,r2,-8084
 82269b4:	e0fffe17 	ldw	r3,-8(fp)
 82269b8:	18c7883a 	add	r3,r3,r3
 82269bc:	18c7883a 	add	r3,r3,r3
 82269c0:	10c5883a 	add	r2,r2,r3
 82269c4:	10000015 	stw	zero,0(r2)
      return("unable to find any working interfaces");
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 82269c8:	e0bffe17 	ldw	r2,-8(fp)
 82269cc:	10800044 	addi	r2,r2,1
 82269d0:	e0bffe15 	stw	r2,-8(fp)
 82269d4:	e0bffe17 	ldw	r2,-8(fp)
 82269d8:	10800110 	cmplti	r2,r2,4
 82269dc:	103fe81e 	bne	r2,zero,8226980 <ip_startup+0xfc>
   /* The sequence of events when initing the net & interface systems 
    * is very important. Be very carefull about altering the order of 
    * the following statements. 
    */
   /* once these are done, we should call ip_exit before quiting IP */
   clock_init();           /* start clock system */
 82269e0:	822d6b80 	call	822d6b8 <clock_init>
   exit_hook(clock_c);
 82269e4:	010208f4 	movhi	r4,2083
 82269e8:	2135bc04 	addi	r4,r4,-10512
 82269ec:	8226b280 	call	8226b28 <exit_hook>

   e = Netinit();    /* start net interface(s) */
 82269f0:	8225aa00 	call	8225aa0 <Netinit>
 82269f4:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 82269f8:	e0bfff17 	ldw	r2,-4(fp)
 82269fc:	10000326 	beq	r2,zero,8226a0c <ip_startup+0x188>
   {
      return("unable to initialize net");
 8226a00:	00820974 	movhi	r2,2085
 8226a04:	10bff904 	addi	r2,r2,-28
 8226a08:	00004206 	br	8226b14 <ip_startup+0x290>
   }

#ifdef INCLUDE_ARP
   e = etainit();          /* startup ARP layer */
 8226a0c:	823d9600 	call	823d960 <etainit>
 8226a10:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 8226a14:	e0bfff17 	ldw	r2,-4(fp)
 8226a18:	10000426 	beq	r2,zero,8226a2c <ip_startup+0x1a8>
   {
      ip_exit();
 8226a1c:	8226b980 	call	8226b98 <ip_exit>
      return("unable to initialize arp");
 8226a20:	00820974 	movhi	r2,2085
 8226a24:	10800004 	addi	r2,r2,0
 8226a28:	00003a06 	br	8226b14 <ip_startup+0x290>
   }
#endif

#ifdef IP_V4
   e = ip_init();       /* start up IP layer */
 8226a2c:	823efb00 	call	823efb0 <ip_init>
 8226a30:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 8226a34:	e0bfff17 	ldw	r2,-4(fp)
 8226a38:	10000426 	beq	r2,zero,8226a4c <ip_startup+0x1c8>
   {
      ip_exit();
 8226a3c:	8226b980 	call	8226b98 <ip_exit>
      return("unable to initialize IP");
 8226a40:	00820974 	movhi	r2,2085
 8226a44:	10800704 	addi	r2,r2,28
 8226a48:	00003206 	br	8226b14 <ip_startup+0x290>

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Join the All hosts group on every interface that IP multicast is
    * supported
    */
   e = igmp_init();         /* Initialize igmp */
 8226a4c:	8226cec0 	call	8226cec <igmp_init>
 8226a50:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 8226a54:	e0bfff17 	ldw	r2,-4(fp)
 8226a58:	10000326 	beq	r2,zero,8226a68 <ip_startup+0x1e4>
   {
      ip_exit();
 8226a5c:	8226b980 	call	8226b98 <ip_exit>
      return(ipmcfail_str);
 8226a60:	d0a03017 	ldw	r2,-32576(gp)
 8226a64:	00002b06 	br	8226b14 <ip_startup+0x290>
   }

   for (i = 0; i < (int)ifNumber; i++)
 8226a68:	e03ffe15 	stw	zero,-8(fp)
 8226a6c:	00001b06 	br	8226adc <ip_startup+0x258>
   {
      if (nets[i]->n_mcastlist != NULL)
 8226a70:	008209b4 	movhi	r2,2086
 8226a74:	10b81b04 	addi	r2,r2,-8084
 8226a78:	e0fffe17 	ldw	r3,-8(fp)
 8226a7c:	18c7883a 	add	r3,r3,r3
 8226a80:	18c7883a 	add	r3,r3,r3
 8226a84:	10c5883a 	add	r2,r2,r3
 8226a88:	10800017 	ldw	r2,0(r2)
 8226a8c:	10802b17 	ldw	r2,172(r2)
 8226a90:	10000f26 	beq	r2,zero,8226ad0 <ip_startup+0x24c>
         if ((in_addmulti(&igmp_all_hosts_group, nets[i], 4) == NULL))
 8226a94:	008209b4 	movhi	r2,2086
 8226a98:	10b81b04 	addi	r2,r2,-8084
 8226a9c:	e0fffe17 	ldw	r3,-8(fp)
 8226aa0:	18c7883a 	add	r3,r3,r3
 8226aa4:	18c7883a 	add	r3,r3,r3
 8226aa8:	10c5883a 	add	r2,r2,r3
 8226aac:	10800017 	ldw	r2,0(r2)
 8226ab0:	01800104 	movi	r6,4
 8226ab4:	100b883a 	mov	r5,r2
 8226ab8:	d1208804 	addi	r4,gp,-32224
 8226abc:	82439500 	call	8243950 <in_addmulti>
 8226ac0:	1000031e 	bne	r2,zero,8226ad0 <ip_startup+0x24c>
      {
         ip_exit();
 8226ac4:	8226b980 	call	8226b98 <ip_exit>
         return(ipmcfail_str);
 8226ac8:	d0a03017 	ldw	r2,-32576(gp)
 8226acc:	00001106 	br	8226b14 <ip_startup+0x290>
   {
      ip_exit();
      return(ipmcfail_str);
   }

   for (i = 0; i < (int)ifNumber; i++)
 8226ad0:	e0bffe17 	ldw	r2,-8(fp)
 8226ad4:	10800044 	addi	r2,r2,1
 8226ad8:	e0bffe15 	stw	r2,-8(fp)
 8226adc:	d0a08417 	ldw	r2,-32240(gp)
 8226ae0:	1007883a 	mov	r3,r2
 8226ae4:	e0bffe17 	ldw	r2,-8(fp)
 8226ae8:	10ffe116 	blt	r2,r3,8226a70 <ip_startup+0x1ec>
      }
   }
#endif /* IP_MULTICAST and (IGMPv1 or IGMPv2) */   

#ifdef INCLUDE_TCP
   e = tcpinit();
 8226aec:	823aee00 	call	823aee0 <tcpinit>
 8226af0:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 8226af4:	e0bfff17 	ldw	r2,-4(fp)
 8226af8:	10000426 	beq	r2,zero,8226b0c <ip_startup+0x288>
   {
      ip_exit();
 8226afc:	8226b980 	call	8226b98 <ip_exit>
      return("unable to initialize TCP");
 8226b00:	00820974 	movhi	r2,2085
 8226b04:	10800d04 	addi	r2,r2,52
 8226b08:	00000206 	br	8226b14 <ip_startup+0x290>
   /* setup event map for (UDP and TCP) socket library's events (such as 
    * those used by tcp_sleep () and tcp_wakeup ()).  These events either 
    * map into operating system primitives such as events or semaphores, 
    * or into task suspend and task resume mechanisms.
    */
   evtmap_setup ();
 8226b0c:	8243cb40 	call	8243cb4 <evtmap_setup>
      return("unable to initialize IP Filter table");
   else
      exit_hook(ipf_cleanup);
#endif

   return(NULL);     /* we got through with no errors */
 8226b10:	0005883a 	mov	r2,zero
}
 8226b14:	e037883a 	mov	sp,fp
 8226b18:	dfc00117 	ldw	ra,4(sp)
 8226b1c:	df000017 	ldw	fp,0(sp)
 8226b20:	dec00204 	addi	sp,sp,8
 8226b24:	f800283a 	ret

08226b28 <exit_hook>:
 * RETURNS: 
 */

void
exit_hook(void (*func)(void))
{
 8226b28:	defffd04 	addi	sp,sp,-12
 8226b2c:	dfc00215 	stw	ra,8(sp)
 8226b30:	df000115 	stw	fp,4(sp)
 8226b34:	df000104 	addi	fp,sp,4
 8226b38:	e13fff15 	stw	r4,-4(fp)
   if (nclosers >= (NUMCLOSERS-1))
 8226b3c:	d0a08517 	ldw	r2,-32236(gp)
 8226b40:	10800390 	cmplti	r2,r2,14
 8226b44:	1000031e 	bne	r2,zero,8226b54 <exit_hook+0x2c>
      panic("exit_hook");
 8226b48:	01020974 	movhi	r4,2085
 8226b4c:	21001404 	addi	r4,r4,80
 8226b50:	8228c480 	call	8228c48 <panic>

   closers[++nclosers] = func;
 8226b54:	d0a08517 	ldw	r2,-32236(gp)
 8226b58:	10800044 	addi	r2,r2,1
 8226b5c:	d0a08515 	stw	r2,-32236(gp)
 8226b60:	d0e08517 	ldw	r3,-32236(gp)
 8226b64:	00820974 	movhi	r2,2085
 8226b68:	1091fa04 	addi	r2,r2,18408
 8226b6c:	18c7883a 	add	r3,r3,r3
 8226b70:	18c7883a 	add	r3,r3,r3
 8226b74:	10c5883a 	add	r2,r2,r3
 8226b78:	e0ffff17 	ldw	r3,-4(fp)
 8226b7c:	10c00015 	stw	r3,0(r2)
}
 8226b80:	0001883a 	nop
 8226b84:	e037883a 	mov	sp,fp
 8226b88:	dfc00117 	ldw	ra,4(sp)
 8226b8c:	df000017 	ldw	fp,0(sp)
 8226b90:	dec00204 	addi	sp,sp,8
 8226b94:	f800283a 	ret

08226b98 <ip_exit>:
 * RETURNS: void
 */

void
ip_exit()
{
 8226b98:	defffd04 	addi	sp,sp,-12
 8226b9c:	dfc00215 	stw	ra,8(sp)
 8226ba0:	df000115 	stw	fp,4(sp)
 8226ba4:	df000104 	addi	fp,sp,4
   int   n;

   for (n=nclosers; n; n--)
 8226ba8:	d0a08517 	ldw	r2,-32236(gp)
 8226bac:	e0bfff15 	stw	r2,-4(fp)
 8226bb0:	00002506 	br	8226c48 <ip_exit+0xb0>
   {
#ifdef NPDEBUG
      dprintf("ip_exit: calling func %p\n", closers[n]);
 8226bb4:	00820974 	movhi	r2,2085
 8226bb8:	1091fa04 	addi	r2,r2,18408
 8226bbc:	e0ffff17 	ldw	r3,-4(fp)
 8226bc0:	18c7883a 	add	r3,r3,r3
 8226bc4:	18c7883a 	add	r3,r3,r3
 8226bc8:	10c5883a 	add	r2,r2,r3
 8226bcc:	10800017 	ldw	r2,0(r2)
 8226bd0:	100b883a 	mov	r5,r2
 8226bd4:	01020974 	movhi	r4,2085
 8226bd8:	21001704 	addi	r4,r4,92
 8226bdc:	82033a00 	call	82033a0 <printf>
#endif
      if(closers[n])
 8226be0:	00820974 	movhi	r2,2085
 8226be4:	1091fa04 	addi	r2,r2,18408
 8226be8:	e0ffff17 	ldw	r3,-4(fp)
 8226bec:	18c7883a 	add	r3,r3,r3
 8226bf0:	18c7883a 	add	r3,r3,r3
 8226bf4:	10c5883a 	add	r2,r2,r3
 8226bf8:	10800017 	ldw	r2,0(r2)
 8226bfc:	10000f26 	beq	r2,zero,8226c3c <ip_exit+0xa4>
      {
         (*closers[n])();
 8226c00:	00820974 	movhi	r2,2085
 8226c04:	1091fa04 	addi	r2,r2,18408
 8226c08:	e0ffff17 	ldw	r3,-4(fp)
 8226c0c:	18c7883a 	add	r3,r3,r3
 8226c10:	18c7883a 	add	r3,r3,r3
 8226c14:	10c5883a 	add	r2,r2,r3
 8226c18:	10800017 	ldw	r2,0(r2)
 8226c1c:	103ee83a 	callr	r2
         closers[n] = NULL;
 8226c20:	00820974 	movhi	r2,2085
 8226c24:	1091fa04 	addi	r2,r2,18408
 8226c28:	e0ffff17 	ldw	r3,-4(fp)
 8226c2c:	18c7883a 	add	r3,r3,r3
 8226c30:	18c7883a 	add	r3,r3,r3
 8226c34:	10c5883a 	add	r2,r2,r3
 8226c38:	10000015 	stw	zero,0(r2)
void
ip_exit()
{
   int   n;

   for (n=nclosers; n; n--)
 8226c3c:	e0bfff17 	ldw	r2,-4(fp)
 8226c40:	10bfffc4 	addi	r2,r2,-1
 8226c44:	e0bfff15 	stw	r2,-4(fp)
 8226c48:	e0bfff17 	ldw	r2,-4(fp)
 8226c4c:	103fd91e 	bne	r2,zero,8226bb4 <ip_exit+0x1c>
      {
         (*closers[n])();
         closers[n] = NULL;
      }
   }
}
 8226c50:	0001883a 	nop
 8226c54:	e037883a 	mov	sp,fp
 8226c58:	dfc00117 	ldw	ra,4(sp)
 8226c5c:	df000017 	ldw	fp,0(sp)
 8226c60:	dec00204 	addi	sp,sp,8
 8226c64:	f800283a 	ret

08226c68 <if_netnumber>:
 * RETURNS: net index for passed net pointer
 */

int
if_netnumber(NET nptr)
{
 8226c68:	defffb04 	addi	sp,sp,-20
 8226c6c:	dfc00415 	stw	ra,16(sp)
 8226c70:	df000315 	stw	fp,12(sp)
 8226c74:	df000304 	addi	fp,sp,12
 8226c78:	e13fff15 	stw	r4,-4(fp)
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 8226c7c:	008209b4 	movhi	r2,2086
 8226c80:	10ba5c04 	addi	r2,r2,-5776
 8226c84:	10800017 	ldw	r2,0(r2)
 8226c88:	e0bffe15 	stw	r2,-8(fp)
 8226c8c:	e03ffd15 	stw	zero,-12(fp)
 8226c90:	00000b06 	br	8226cc0 <if_netnumber+0x58>
   {
      if(ifp == nptr)
 8226c94:	e0fffe17 	ldw	r3,-8(fp)
 8226c98:	e0bfff17 	ldw	r2,-4(fp)
 8226c9c:	1880021e 	bne	r3,r2,8226ca8 <if_netnumber+0x40>
        return (int)i;
 8226ca0:	e0bffd17 	ldw	r2,-12(fp)
 8226ca4:	00000c06 	br	8226cd8 <if_netnumber+0x70>
if_netnumber(NET nptr)
{
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 8226ca8:	e0bffe17 	ldw	r2,-8(fp)
 8226cac:	10800017 	ldw	r2,0(r2)
 8226cb0:	e0bffe15 	stw	r2,-8(fp)
 8226cb4:	e0bffd17 	ldw	r2,-12(fp)
 8226cb8:	10800044 	addi	r2,r2,1
 8226cbc:	e0bffd15 	stw	r2,-12(fp)
 8226cc0:	e0bffe17 	ldw	r2,-8(fp)
 8226cc4:	103ff31e 	bne	r2,zero,8226c94 <if_netnumber+0x2c>
   {
      if(ifp == nptr)
        return (int)i;
   }

   panic("bad net ptr");
 8226cc8:	01020974 	movhi	r4,2085
 8226ccc:	21001e04 	addi	r4,r4,120
 8226cd0:	8228c480 	call	8228c48 <panic>
   return 0;
 8226cd4:	0005883a 	mov	r2,zero
}
 8226cd8:	e037883a 	mov	sp,fp
 8226cdc:	dfc00117 	ldw	ra,4(sp)
 8226ce0:	df000017 	ldw	fp,0(sp)
 8226ce4:	dec00204 	addi	sp,sp,8
 8226ce8:	f800283a 	ret

08226cec <igmp_init>:
 *
 * OUTPUT: None.
 */

int igmp_init(void)
{
 8226cec:	defffe04 	addi	sp,sp,-8
 8226cf0:	df000115 	stw	fp,4(sp)
 8226cf4:	df000104 	addi	fp,sp,4
   NET ifp;

   /*
    * To avoid byte-swapping the same value over and over again.
    */
   igmp_all_hosts_group = htonl(INADDR_ALLHOSTS_GROUP);
 8226cf8:	00804034 	movhi	r2,256
 8226cfc:	10803804 	addi	r2,r2,224
 8226d00:	d0a08815 	stw	r2,-32224(gp)
   igmp_all_rtrs_group = htonl(INADDR_ALLRTRS_GROUP);
 8226d04:	00808034 	movhi	r2,512
 8226d08:	10803804 	addi	r2,r2,224
 8226d0c:	d0a08915 	stw	r2,-32220(gp)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 8226d10:	008209b4 	movhi	r2,2086
 8226d14:	10ba5c04 	addi	r2,r2,-5776
 8226d18:	10800017 	ldw	r2,0(r2)
 8226d1c:	e0bfff15 	stw	r2,-4(fp)
 8226d20:	00001006 	br	8226d64 <igmp_init+0x78>
   {
      if (ifp->igmp_oper_mode == IGMP_MODE_V1)
 8226d24:	e0bfff17 	ldw	r2,-4(fp)
 8226d28:	10802f03 	ldbu	r2,188(r2)
 8226d2c:	10803fcc 	andi	r2,r2,255
 8226d30:	10800058 	cmpnei	r2,r2,1
 8226d34:	1000041e 	bne	r2,zero,8226d48 <igmp_init+0x5c>
      {
         ifp->igmpv1_rtr_present = 1;
 8226d38:	e0bfff17 	ldw	r2,-4(fp)
 8226d3c:	00c00044 	movi	r3,1
 8226d40:	10c02d05 	stb	r3,180(r2)
 8226d44:	00000406 	br	8226d58 <igmp_init+0x6c>
      }
      else
      {
         ifp->igmpv1_rtr_present = 0;
 8226d48:	e0bfff17 	ldw	r2,-4(fp)
 8226d4c:	10002d05 	stb	zero,180(r2)
         /* not really required, only referred to if IGMPv1 router is 
          * "present" */
         ifp->igmpv1_query_rcvd_time = 0;
 8226d50:	e0bfff17 	ldw	r2,-4(fp)
 8226d54:	10002e15 	stw	zero,184(r2)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 8226d58:	e0bfff17 	ldw	r2,-4(fp)
 8226d5c:	10800017 	ldw	r2,0(r2)
 8226d60:	e0bfff15 	stw	r2,-4(fp)
 8226d64:	e0bfff17 	ldw	r2,-4(fp)
 8226d68:	103fee1e 	bne	r2,zero,8226d24 <igmp_init+0x38>
   }

   /*
    * Call igmp_fasttimo PR_FASTHZ (5) times per second
    */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 8226d6c:	d0a0a817 	ldw	r2,-32096(gp)
 8226d70:	10800504 	addi	r2,r2,20
 8226d74:	d0a08715 	stw	r2,-32228(gp)

   /* there are no timers running initially */
   igmp_timers_are_running = 0;
 8226d78:	d0208615 	stw	zero,-32232(gp)

   return IGMP_OK;
 8226d7c:	0005883a 	mov	r2,zero
}
 8226d80:	e037883a 	mov	sp,fp
 8226d84:	df000017 	ldw	fp,0(sp)
 8226d88:	dec00104 	addi	sp,sp,4
 8226d8c:	f800283a 	ret

08226d90 <igmp_input>:
 * returned if the operating mode is not correctly configured
 * to a valid IGMP operating mode.
 */

int igmp_input (PACKET p)
{
 8226d90:	defffb04 	addi	sp,sp,-20
 8226d94:	dfc00415 	stw	ra,16(sp)
 8226d98:	df000315 	stw	fp,12(sp)
 8226d9c:	df000304 	addi	fp,sp,12
 8226da0:	e13fff15 	stw	r4,-4(fp)
   u_char mode;
   int rc;
     
   ++igmpstats.igmp_total_rcvd;
 8226da4:	008209b4 	movhi	r2,2086
 8226da8:	10b81f04 	addi	r2,r2,-8068
 8226dac:	10800017 	ldw	r2,0(r2)
 8226db0:	10c00044 	addi	r3,r2,1
 8226db4:	008209b4 	movhi	r2,2086
 8226db8:	10b81f04 	addi	r2,r2,-8068
 8226dbc:	10c00015 	stw	r3,0(r2)
   
   /* validate the received packet; if validation fails,
    * drop the packet and return */
   if ((rc = igmp_validate (p)) != IGMP_OK) goto end;
 8226dc0:	e13fff17 	ldw	r4,-4(fp)
 8226dc4:	82275540 	call	8227554 <igmp_validate>
 8226dc8:	e0bffd15 	stw	r2,-12(fp)
 8226dcc:	e0bffd17 	ldw	r2,-12(fp)
 8226dd0:	10001a1e 	bne	r2,zero,8226e3c <igmp_input+0xac>

   /* determine the operating mode for IGMP on the ingress link */
   mode = p->net->igmp_oper_mode;
 8226dd4:	e0bfff17 	ldw	r2,-4(fp)
 8226dd8:	10800617 	ldw	r2,24(r2)
 8226ddc:	10802f03 	ldbu	r2,188(r2)
 8226de0:	e0bffe05 	stb	r2,-8(fp)
   
   /* feed packet to IGMPv1 or IGMPv2 code based on the operating
    * mode of the ingress link */
   switch (mode)
 8226de4:	e0bffe03 	ldbu	r2,-8(fp)
 8226de8:	10c00060 	cmpeqi	r3,r2,1
 8226dec:	1800031e 	bne	r3,zero,8226dfc <igmp_input+0x6c>
 8226df0:	108000a0 	cmpeqi	r2,r2,2
 8226df4:	1000041e 	bne	r2,zero,8226e08 <igmp_input+0x78>
 8226df8:	00000606 	br	8226e14 <igmp_input+0x84>
   {
#ifdef IGMP_V1   
      case IGMP_MODE_V1:   
         return (igmpv1_input (p)); 
 8226dfc:	e13fff17 	ldw	r4,-4(fp)
 8226e00:	824550c0 	call	824550c <igmpv1_input>
 8226e04:	00001506 	br	8226e5c <igmp_input+0xcc>
#endif
#ifdef IGMP_V2         
      case IGMP_MODE_V2:       
         return (igmpv2_input (p));
 8226e08:	e13fff17 	ldw	r4,-4(fp)
 8226e0c:	82457b00 	call	82457b0 <igmpv2_input>
 8226e10:	00001206 	br	8226e5c <igmp_input+0xcc>
#endif
      default:
         ++igmpstats.igmp_bad_oper_mode;     
 8226e14:	008209b4 	movhi	r2,2086
 8226e18:	10b81f04 	addi	r2,r2,-8068
 8226e1c:	10800d17 	ldw	r2,52(r2)
 8226e20:	10c00044 	addi	r3,r2,1
 8226e24:	008209b4 	movhi	r2,2086
 8226e28:	10b81f04 	addi	r2,r2,-8068
 8226e2c:	10c00d15 	stw	r3,52(r2)
         rc = IGMP_ERR;
 8226e30:	00bfffc4 	movi	r2,-1
 8226e34:	e0bffd15 	stw	r2,-12(fp)
         break;
 8226e38:	00000106 	br	8226e40 <igmp_input+0xb0>
     
   ++igmpstats.igmp_total_rcvd;
   
   /* validate the received packet; if validation fails,
    * drop the packet and return */
   if ((rc = igmp_validate (p)) != IGMP_OK) goto end;
 8226e3c:	0001883a 	nop
         break;
   }
   
end:   
   /* return packet buffer back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8226e40:	01000084 	movi	r4,2
 8226e44:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   pk_free(p);
 8226e48:	e13fff17 	ldw	r4,-4(fp)
 8226e4c:	822cd3c0 	call	822cd3c <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8226e50:	01000084 	movi	r4,2
 8226e54:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      
   return rc;
 8226e58:	e0bffd17 	ldw	r2,-12(fp)
}
 8226e5c:	e037883a 	mov	sp,fp
 8226e60:	dfc00117 	ldw	ra,4(sp)
 8226e64:	df000017 	ldw	fp,0(sp)
 8226e68:	dec00204 	addi	sp,sp,8
 8226e6c:	f800283a 	ret

08226e70 <igmp_fasttimo>:
 *
 * OUTPUT: None.
 */

void igmp_fasttimo (void)
{
 8226e70:	defffc04 	addi	sp,sp,-16
 8226e74:	dfc00315 	stw	ra,12(sp)
 8226e78:	df000215 	stw	fp,8(sp)
 8226e7c:	df000204 	addi	fp,sp,8
   struct in_multi * inm;
   NET ifp;
     
   LOCK_NET_RESOURCE (NET_RESID);
 8226e80:	0009883a 	mov	r4,zero
 8226e84:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   
   /*
    * Quick check to see if any work needs to be done, in order
    * to minimize the overhead of fasttimo processing.
    */
   if (!igmp_timers_are_running)
 8226e88:	d0a08617 	ldw	r2,-32232(gp)
 8226e8c:	1000031e 	bne	r2,zero,8226e9c <igmp_fasttimo+0x2c>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
 8226e90:	0009883a 	mov	r4,zero
 8226e94:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return;
 8226e98:	00004d06 	br	8226fd0 <igmp_fasttimo+0x160>
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 8226e9c:	008209b4 	movhi	r2,2086
 8226ea0:	10ba5c04 	addi	r2,r2,-5776
 8226ea4:	10800017 	ldw	r2,0(r2)
 8226ea8:	e0bfff15 	stw	r2,-4(fp)
 8226eac:	00004006 	br	8226fb0 <igmp_fasttimo+0x140>
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 8226eb0:	e0bfff17 	ldw	r2,-4(fp)
 8226eb4:	10802c17 	ldw	r2,176(r2)
 8226eb8:	e0bffe15 	stw	r2,-8(fp)
 8226ebc:	00003706 	br	8226f9c <igmp_fasttimo+0x12c>
      {
         /* skip IPv6 entries */
         if (inm->inm_addr == 0) 
 8226ec0:	e0bffe17 	ldw	r2,-8(fp)
 8226ec4:	10800017 	ldw	r2,0(r2)
 8226ec8:	10003026 	beq	r2,zero,8226f8c <igmp_fasttimo+0x11c>
               continue;

         if (inm->inm_timer == 0)   /* timer not set */
 8226ecc:	e0bffe17 	ldw	r2,-8(fp)
 8226ed0:	10800317 	ldw	r2,12(r2)
 8226ed4:	10002e26 	beq	r2,zero,8226f90 <igmp_fasttimo+0x120>
         {
            /* do nothing */
         }
         else if (--inm->inm_timer == 0)  /* timer expired */
 8226ed8:	e0bffe17 	ldw	r2,-8(fp)
 8226edc:	10800317 	ldw	r2,12(r2)
 8226ee0:	10ffffc4 	addi	r3,r2,-1
 8226ee4:	e0bffe17 	ldw	r2,-8(fp)
 8226ee8:	10c00315 	stw	r3,12(r2)
 8226eec:	e0bffe17 	ldw	r2,-8(fp)
 8226ef0:	10800317 	ldw	r2,12(r2)
 8226ef4:	1000261e 	bne	r2,zero,8226f90 <igmp_fasttimo+0x120>
         {
            /* send membership report in appropriate format */
            if (ifp->igmpv1_rtr_present)
 8226ef8:	e0bfff17 	ldw	r2,-4(fp)
 8226efc:	10802d03 	ldbu	r2,180(r2)
 8226f00:	10803fcc 	andi	r2,r2,255
 8226f04:	10000426 	beq	r2,zero,8226f18 <igmp_fasttimo+0xa8>
            {
               /* always true for IGMPv1, may be true for IGMPv2 */
               igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 8226f08:	e17ffe17 	ldw	r5,-8(fp)
 8226f0c:	01000484 	movi	r4,18
 8226f10:	8226fe40 	call	8226fe4 <igmp_send>
 8226f14:	00000306 	br	8226f24 <igmp_fasttimo+0xb4>
            }
            else
            {
               igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 8226f18:	e17ffe17 	ldw	r5,-8(fp)
 8226f1c:	01000584 	movi	r4,22
 8226f20:	8226fe40 	call	8226fe4 <igmp_send>

            /* for IGMPv2, indicate that we were the last to send 
             * a Report for this multicast group (relevant for 
             * IGMPv2 only).  also check to see if we should mark 
             * the IGMPv1 router as "absent". */
            if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 8226f24:	e0bfff17 	ldw	r2,-4(fp)
 8226f28:	10802f03 	ldbu	r2,188(r2)
 8226f2c:	10803fcc 	andi	r2,r2,255
 8226f30:	10800098 	cmpnei	r2,r2,2
 8226f34:	1000111e 	bne	r2,zero,8226f7c <igmp_fasttimo+0x10c>
            {
               inm->last2send_report = IGMP_TRUE;
 8226f38:	e0bffe17 	ldw	r2,-8(fp)
 8226f3c:	00c00044 	movi	r3,1
 8226f40:	10c00405 	stb	r3,16(r2)
               
               if (ifp->igmpv1_rtr_present)
 8226f44:	e0bfff17 	ldw	r2,-4(fp)
 8226f48:	10802d03 	ldbu	r2,180(r2)
 8226f4c:	10803fcc 	andi	r2,r2,255
 8226f50:	10000a26 	beq	r2,zero,8226f7c <igmp_fasttimo+0x10c>
               {
                  if (cticks > (ifp->igmpv1_query_rcvd_time + (IGMPv1_RTR_PRESENT_TMO * TPS)))
 8226f54:	e0bfff17 	ldw	r2,-4(fp)
 8226f58:	10c02e17 	ldw	r3,184(r2)
 8226f5c:	00a71014 	movui	r2,40000
 8226f60:	1887883a 	add	r3,r3,r2
 8226f64:	d0a0a817 	ldw	r2,-32096(gp)
 8226f68:	1880042e 	bgeu	r3,r2,8226f7c <igmp_fasttimo+0x10c>
                     /* we haven't heard from the IGMPv1 router for a duration
                      * greater than or equal to Version 1 Router Present Timeout 
                      * (400 seconds), and will now update the igmpv1_rtr_present 
                      * variable to reflect that.
                      */
                     ifp->igmpv1_rtr_present = IGMP_FALSE;
 8226f6c:	e0bfff17 	ldw	r2,-4(fp)
 8226f70:	10002d05 	stb	zero,180(r2)
                     ifp->igmpv1_query_rcvd_time = 0;
 8226f74:	e0bfff17 	ldw	r2,-4(fp)
 8226f78:	10002e15 	stw	zero,184(r2)
                  }
               }  
            }

            /* decrement the count of running IGMP timers */
            --igmp_timers_are_running;
 8226f7c:	d0a08617 	ldw	r2,-32232(gp)
 8226f80:	10bfffc4 	addi	r2,r2,-1
 8226f84:	d0a08615 	stw	r2,-32232(gp)
 8226f88:	00000106 	br	8226f90 <igmp_fasttimo+0x120>
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
      {
         /* skip IPv6 entries */
         if (inm->inm_addr == 0) 
               continue;
 8226f8c:	0001883a 	nop
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 8226f90:	e0bffe17 	ldw	r2,-8(fp)
 8226f94:	10800517 	ldw	r2,20(r2)
 8226f98:	e0bffe15 	stw	r2,-8(fp)
 8226f9c:	e0bffe17 	ldw	r2,-8(fp)
 8226fa0:	103fc71e 	bne	r2,zero,8226ec0 <igmp_fasttimo+0x50>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 8226fa4:	e0bfff17 	ldw	r2,-4(fp)
 8226fa8:	10800017 	ldw	r2,0(r2)
 8226fac:	e0bfff15 	stw	r2,-4(fp)
 8226fb0:	e0bfff17 	ldw	r2,-4(fp)
 8226fb4:	103fbe1e 	bne	r2,zero,8226eb0 <igmp_fasttimo+0x40>
      }     
   }

   /* Setup time for the next call into igmp_fasttimo ()
    * (200 ms later). */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 8226fb8:	d0a0a817 	ldw	r2,-32096(gp)
 8226fbc:	10800504 	addi	r2,r2,20
 8226fc0:	d0a08715 	stw	r2,-32228(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 8226fc4:	0009883a 	mov	r4,zero
 8226fc8:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   
   return;
 8226fcc:	0001883a 	nop
}
 8226fd0:	e037883a 	mov	sp,fp
 8226fd4:	dfc00117 	ldw	ra,4(sp)
 8226fd8:	df000017 	ldw	fp,0(sp)
 8226fdc:	dec00204 	addi	sp,sp,8
 8226fe0:	f800283a 	ret

08226fe4 <igmp_send>:
 *
 * OUTPUT: None.
 */

void igmp_send (u_char type, struct in_multi * inm)
{
 8226fe4:	deffde04 	addi	sp,sp,-136
 8226fe8:	dfc02115 	stw	ra,132(sp)
 8226fec:	df002015 	stw	fp,128(sp)
 8226ff0:	df002004 	addi	fp,sp,128
 8226ff4:	2005883a 	mov	r2,r4
 8226ff8:	e17fff15 	stw	r5,-4(fp)
 8226ffc:	e0bffe05 	stb	r2,-8(fp)
   struct igmp * igmp;
   struct ip_moptions * imop;
   struct ip_moptions simo;
   struct ip * pip;
   u_char * tmpp;
   u_char opts [2] = {IP_RTR_ALERT_OPT, EOL_OPT};
 8227000:	00800504 	movi	r2,20
 8227004:	e0bffd05 	stb	r2,-12(fp)
 8227008:	e03ffd45 	stb	zero,-11(fp)
   u_char reqd_len;

   /* compute length of buffer required for outgoing packet.
    * also account for the length of the IP Router Alert 
    * option, if required. */   
   reqd_len = MaxLnh + sizeof (struct ip) + sizeof (struct igmp);
 822700c:	d0a08117 	ldw	r2,-32252(gp)
 8227010:	10800704 	addi	r2,r2,28
 8227014:	e0bfe205 	stb	r2,-120(fp)
   if ((type == IGMPv2_LEAVE_GROUP) || 
 8227018:	e0bffe03 	ldbu	r2,-8(fp)
 822701c:	108005e0 	cmpeqi	r2,r2,23
 8227020:	1000031e 	bne	r2,zero,8227030 <igmp_send+0x4c>
 8227024:	e0bffe03 	ldbu	r2,-8(fp)
 8227028:	10800598 	cmpnei	r2,r2,22
 822702c:	1000031e 	bne	r2,zero,822703c <igmp_send+0x58>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      reqd_len += IP_RTR_ALERT_OPT_SIZE;
 8227030:	e0bfe203 	ldbu	r2,-120(fp)
 8227034:	10800104 	addi	r2,r2,4
 8227038:	e0bfe205 	stb	r2,-120(fp)
   }

   /* obtain a packet to send the IGMP message */
   LOCK_NET_RESOURCE (FREEQ_RESID);
 822703c:	01000084 	movi	r4,2
 8227040:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   p = pk_alloc (reqd_len);
 8227044:	e0bfe203 	ldbu	r2,-120(fp)
 8227048:	1009883a 	mov	r4,r2
 822704c:	822c9ec0 	call	822c9ec <pk_alloc>
 8227050:	e0bfe315 	stw	r2,-116(fp)
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8227054:	01000084 	movi	r4,2
 8227058:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   
   /* log an error and return if the allocation fails */   
   if (!p)
 822705c:	e0bfe317 	ldw	r2,-116(fp)
 8227060:	1000081e 	bne	r2,zero,8227084 <igmp_send+0xa0>
   {
      ++igmpstats.igmp_pkt_alloc_fail;
 8227064:	008209b4 	movhi	r2,2086
 8227068:	10b81f04 	addi	r2,r2,-8068
 822706c:	10800c17 	ldw	r2,48(r2)
 8227070:	10c00044 	addi	r3,r2,1
 8227074:	008209b4 	movhi	r2,2086
 8227078:	10b81f04 	addi	r2,r2,-8068
 822707c:	10c00c15 	stw	r3,48(r2)
 8227080:	00007a06 	br	822726c <igmp_send+0x288>
      return;
   }

   /* Need to fill in the source and destination ip addresses */
   pip = (struct ip *) p->nb_prot;
 8227084:	e0bfe317 	ldw	r2,-116(fp)
 8227088:	10800317 	ldw	r2,12(r2)
 822708c:	e0bfe415 	stw	r2,-112(fp)
   pip->ip_src = inm->inm_netp->n_ipaddr;
 8227090:	e0bfff17 	ldw	r2,-4(fp)
 8227094:	10800117 	ldw	r2,4(r2)
 8227098:	10c00a17 	ldw	r3,40(r2)
 822709c:	e0bfe417 	ldw	r2,-112(fp)
 82270a0:	10c00315 	stw	r3,12(r2)
   /* Leave Group messages are sent to the all-routers multicast group */
   if (type == IGMPv2_LEAVE_GROUP)
 82270a4:	e0bffe03 	ldbu	r2,-8(fp)
 82270a8:	108005d8 	cmpnei	r2,r2,23
 82270ac:	1000041e 	bne	r2,zero,82270c0 <igmp_send+0xdc>
   {
      /* igmp_all_rtrs_group is already in network byte order */
      pip->ip_dest = igmp_all_rtrs_group;
 82270b0:	d0e08917 	ldw	r3,-32220(gp)
 82270b4:	e0bfe417 	ldw	r2,-112(fp)
 82270b8:	10c00415 	stw	r3,16(r2)
 82270bc:	00000406 	br	82270d0 <igmp_send+0xec>
   }
   else
      pip->ip_dest = inm->inm_addr;
 82270c0:	e0bfff17 	ldw	r2,-4(fp)
 82270c4:	10c00017 	ldw	r3,0(r2)
 82270c8:	e0bfe417 	ldw	r2,-112(fp)
 82270cc:	10c00415 	stw	r3,16(r2)
   
   p->fhost = pip->ip_dest;
 82270d0:	e0bfe417 	ldw	r2,-112(fp)
 82270d4:	10c00417 	ldw	r3,16(r2)
 82270d8:	e0bfe317 	ldw	r2,-116(fp)
 82270dc:	10c00715 	stw	r3,28(r2)

   tmpp = (((u_char *) p->nb_prot) + sizeof (struct ip));
 82270e0:	e0bfe317 	ldw	r2,-116(fp)
 82270e4:	10800317 	ldw	r2,12(r2)
 82270e8:	10800504 	addi	r2,r2,20
 82270ec:	e0bfe015 	stw	r2,-128(fp)

   /* when transmitting an IGMP packet, our IGMP module will insert
    * data for the Router Alert option in the following types of
    * packets: Version 2 Membership Report (0x16) and Leave Group 
    * (0x17) */
   if ((type == IGMPv2_LEAVE_GROUP) || 
 82270f0:	e0bffe03 	ldbu	r2,-8(fp)
 82270f4:	108005e0 	cmpeqi	r2,r2,23
 82270f8:	1000031e 	bne	r2,zero,8227108 <igmp_send+0x124>
 82270fc:	e0bffe03 	ldbu	r2,-8(fp)
 8227100:	10800598 	cmpnei	r2,r2,22
 8227104:	1000061e 	bne	r2,zero,8227120 <igmp_send+0x13c>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      /* provide space for ip_write2 () to write option-related data */
      tmpp += IP_RTR_ALERT_OPT_SIZE;
 8227108:	e0bfe017 	ldw	r2,-128(fp)
 822710c:	10800104 	addi	r2,r2,4
 8227110:	e0bfe015 	stw	r2,-128(fp)
      optp = &(opts [0]); /* one option (IP Router Alert) */
 8227114:	e0bffd04 	addi	r2,fp,-12
 8227118:	e0bfe115 	stw	r2,-124(fp)
 822711c:	00000306 	br	822712c <igmp_send+0x148>
   }
   /* outgoing packet does not require any options */
   else 
      optp = &(opts [1]);
 8227120:	e0bffd04 	addi	r2,fp,-12
 8227124:	10800044 	addi	r2,r2,1
 8227128:	e0bfe115 	stw	r2,-124(fp)
   /* point to the start of the IGMP header */
   igmp = (struct igmp *) tmpp;
 822712c:	e0bfe017 	ldw	r2,-128(fp)
 8227130:	e0bfe515 	stw	r2,-108(fp)
   
   igmp->igmp_type = type;
 8227134:	e0bfe517 	ldw	r2,-108(fp)
 8227138:	e0fffe03 	ldbu	r3,-8(fp)
 822713c:	10c00005 	stb	r3,0(r2)
   igmp->igmp_code = 0;
 8227140:	e0bfe517 	ldw	r2,-108(fp)
 8227144:	10000045 	stb	zero,1(r2)
   
   /* all messages (Report or Leave) have Group Address field 
    * set to the group being reported or left */
   igmp->igmp_group = inm->inm_addr;
 8227148:	e0bfff17 	ldw	r2,-4(fp)
 822714c:	10c00017 	ldw	r3,0(r2)
 8227150:	e0bfe517 	ldw	r2,-108(fp)
 8227154:	10c00115 	stw	r3,4(r2)
   igmp->igmp_cksum = 0;
 8227158:	e0bfe517 	ldw	r2,-108(fp)
 822715c:	1000008d 	sth	zero,2(r2)
   igmp->igmp_cksum = ~cksum((void*)igmp, IGMP_MINLEN>>1);
 8227160:	01400104 	movi	r5,4
 8227164:	e13fe517 	ldw	r4,-108(fp)
 8227168:	82287b40 	call	82287b4 <cksum>
 822716c:	0084303a 	nor	r2,zero,r2
 8227170:	1007883a 	mov	r3,r2
 8227174:	e0bfe517 	ldw	r2,-108(fp)
 8227178:	10c0008d 	sth	r3,2(r2)

   imop = &simo;
 822717c:	e0bfe704 	addi	r2,fp,-100
 8227180:	e0bfe615 	stw	r2,-104(fp)
   MEMSET(imop, 0, sizeof(simo));
 8227184:	01801604 	movi	r6,88
 8227188:	000b883a 	mov	r5,zero
 822718c:	e13fe617 	ldw	r4,-104(fp)
 8227190:	82031b40 	call	82031b4 <memset>
   imop->imo_multicast_netp = inm->inm_netp;
 8227194:	e0bfff17 	ldw	r2,-4(fp)
 8227198:	10c00117 	ldw	r3,4(r2)
 822719c:	e0bfe617 	ldw	r2,-104(fp)
 82271a0:	10c00015 	stw	r3,0(r2)
   imop->imo_multicast_ttl = 1;
 82271a4:	e0bfe617 	ldw	r2,-104(fp)
 82271a8:	00c00044 	movi	r3,1
 82271ac:	10c00105 	stb	r3,4(r2)
   /* we do not want our own reports to be looped back */
   imop->imo_multicast_loop = 0;
 82271b0:	e0bfe617 	ldw	r2,-104(fp)
 82271b4:	10000145 	stb	zero,5(r2)

   /* set nb_prot to point to the beginning of the IGMP data,
    * and nb_plen to the length of the IGMP data, and attach
    * the multicast options structure to the outgoing packet */
   p->nb_prot = (char *) tmpp;
 82271b8:	e0bfe317 	ldw	r2,-116(fp)
 82271bc:	e0ffe017 	ldw	r3,-128(fp)
 82271c0:	10c00315 	stw	r3,12(r2)
   p->nb_plen = sizeof(struct igmp);
 82271c4:	e0bfe317 	ldw	r2,-116(fp)
 82271c8:	00c00204 	movi	r3,8
 82271cc:	10c00415 	stw	r3,16(r2)
   p->imo = imop;
 82271d0:	e0bfe317 	ldw	r2,-116(fp)
 82271d4:	e0ffe617 	ldw	r3,-104(fp)
 82271d8:	10c00b15 	stw	r3,44(r2)
   
   ip_write2 (IGMP_PROT, p, optp);
 82271dc:	e1bfe117 	ldw	r6,-124(fp)
 82271e0:	e17fe317 	ldw	r5,-116(fp)
 82271e4:	01000084 	movi	r4,2
 82271e8:	823fb6c0 	call	823fb6c <ip_write2>

   if (type == IGMPv2_LEAVE_GROUP)
 82271ec:	e0bffe03 	ldbu	r2,-8(fp)
 82271f0:	108005d8 	cmpnei	r2,r2,23
 82271f4:	1000081e 	bne	r2,zero,8227218 <igmp_send+0x234>
      ++igmpstats.igmpv2mode_v2_leave_msgs_sent;
 82271f8:	008209b4 	movhi	r2,2086
 82271fc:	10b81f04 	addi	r2,r2,-8068
 8227200:	10801717 	ldw	r2,92(r2)
 8227204:	10c00044 	addi	r3,r2,1
 8227208:	008209b4 	movhi	r2,2086
 822720c:	10b81f04 	addi	r2,r2,-8068
 8227210:	10c01715 	stw	r3,92(r2)
 8227214:	00001506 	br	822726c <igmp_send+0x288>
   else if (type == IGMPv2_MEMBERSHIP_REPORT)
 8227218:	e0bffe03 	ldbu	r2,-8(fp)
 822721c:	10800598 	cmpnei	r2,r2,22
 8227220:	1000081e 	bne	r2,zero,8227244 <igmp_send+0x260>
      ++igmpstats.igmpv2mode_v2_reports_sent;
 8227224:	008209b4 	movhi	r2,2086
 8227228:	10b81f04 	addi	r2,r2,-8068
 822722c:	10801817 	ldw	r2,96(r2)
 8227230:	10c00044 	addi	r3,r2,1
 8227234:	008209b4 	movhi	r2,2086
 8227238:	10b81f04 	addi	r2,r2,-8068
 822723c:	10c01815 	stw	r3,96(r2)
 8227240:	00000a06 	br	822726c <igmp_send+0x288>
   else if (type == IGMP_HOST_MEMBERSHIP_REPORT)
 8227244:	e0bffe03 	ldbu	r2,-8(fp)
 8227248:	10800498 	cmpnei	r2,r2,18
 822724c:	1000071e 	bne	r2,zero,822726c <igmp_send+0x288>
      ++igmpstats.igmp_v1_reports_sent;
 8227250:	008209b4 	movhi	r2,2086
 8227254:	10b81f04 	addi	r2,r2,-8068
 8227258:	10801617 	ldw	r2,88(r2)
 822725c:	10c00044 	addi	r3,r2,1
 8227260:	008209b4 	movhi	r2,2086
 8227264:	10b81f04 	addi	r2,r2,-8068
 8227268:	10c01615 	stw	r3,88(r2)
}
 822726c:	e037883a 	mov	sp,fp
 8227270:	dfc00117 	ldw	ra,4(sp)
 8227274:	df000017 	ldw	fp,0(sp)
 8227278:	dec00204 	addi	sp,sp,8
 822727c:	f800283a 	ret

08227280 <igmp_joingroup>:
 *
 * OUTPUT: None.
 */
 
void igmp_joingroup(struct in_multi * inm)
{
 8227280:	defffc04 	addi	sp,sp,-16
 8227284:	dfc00315 	stw	ra,12(sp)
 8227288:	df000215 	stw	fp,8(sp)
 822728c:	df000204 	addi	fp,sp,8
 8227290:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   /* extract the network interface to which this multicast
    * address is "attached" */
   ifp = inm->inm_netp;
 8227294:	e0bfff17 	ldw	r2,-4(fp)
 8227298:	10800117 	ldw	r2,4(r2)
 822729c:	e0bffe15 	stw	r2,-8(fp)

   if (inm->inm_addr == igmp_all_hosts_group)
 82272a0:	e0bfff17 	ldw	r2,-4(fp)
 82272a4:	10c00017 	ldw	r3,0(r2)
 82272a8:	d0a08817 	ldw	r2,-32224(gp)
 82272ac:	1880031e 	bne	r3,r2,82272bc <igmp_joingroup+0x3c>
   {
      inm->inm_timer = 0;
 82272b0:	e0bfff17 	ldw	r2,-4(fp)
 82272b4:	10000315 	stw	zero,12(r2)
      }

      ++igmp_timers_are_running;
   }
   
   return;
 82272b8:	00008106 	br	82274c0 <igmp_joingroup+0x240>
      inm->inm_timer = 0;
   }
   else 
   {
      /* send unsolicited membership report in appropriate format */
      if (ifp->igmpv1_rtr_present)
 82272bc:	e0bffe17 	ldw	r2,-8(fp)
 82272c0:	10802d03 	ldbu	r2,180(r2)
 82272c4:	10803fcc 	andi	r2,r2,255
 82272c8:	10003926 	beq	r2,zero,82273b0 <igmp_joingroup+0x130>
      {
         /* always true for IGMPv1, may be true for IGMPv2 */
         igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 82272cc:	e17fff17 	ldw	r5,-4(fp)
 82272d0:	01000484 	movi	r4,18
 82272d4:	8226fe40 	call	8226fe4 <igmp_send>
         /* set a delay timer (with a duration of 
          * IGMP_MAX_HOST_REPORT_DELAY) for a second unsolicited report */
         inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 82272d8:	008209b4 	movhi	r2,2086
 82272dc:	10ba6104 	addi	r2,r2,-5756
 82272e0:	10c00217 	ldw	r3,8(r2)
 82272e4:	008209b4 	movhi	r2,2086
 82272e8:	10b81b04 	addi	r2,r2,-8084
 82272ec:	10800017 	ldw	r2,0(r2)
 82272f0:	10800a17 	ldw	r2,40(r2)
 82272f4:	1008d63a 	srli	r4,r2,24
 82272f8:	008209b4 	movhi	r2,2086
 82272fc:	10b81b04 	addi	r2,r2,-8084
 8227300:	10800017 	ldw	r2,0(r2)
 8227304:	10800a17 	ldw	r2,40(r2)
 8227308:	1004d23a 	srli	r2,r2,8
 822730c:	10bfc00c 	andi	r2,r2,65280
 8227310:	2088b03a 	or	r4,r4,r2
 8227314:	008209b4 	movhi	r2,2086
 8227318:	10b81b04 	addi	r2,r2,-8084
 822731c:	10800017 	ldw	r2,0(r2)
 8227320:	10800a17 	ldw	r2,40(r2)
 8227324:	10bfc00c 	andi	r2,r2,65280
 8227328:	1004923a 	slli	r2,r2,8
 822732c:	2088b03a 	or	r4,r4,r2
 8227330:	008209b4 	movhi	r2,2086
 8227334:	10b81b04 	addi	r2,r2,-8084
 8227338:	10800017 	ldw	r2,0(r2)
 822733c:	10800a17 	ldw	r2,40(r2)
 8227340:	1004963a 	slli	r2,r2,24
 8227344:	2084b03a 	or	r2,r4,r2
 8227348:	1887883a 	add	r3,r3,r2
 822734c:	e0bfff17 	ldw	r2,-4(fp)
 8227350:	10800017 	ldw	r2,0(r2)
 8227354:	1008d63a 	srli	r4,r2,24
 8227358:	e0bfff17 	ldw	r2,-4(fp)
 822735c:	10800017 	ldw	r2,0(r2)
 8227360:	1004d23a 	srli	r2,r2,8
 8227364:	10bfc00c 	andi	r2,r2,65280
 8227368:	2088b03a 	or	r4,r4,r2
 822736c:	e0bfff17 	ldw	r2,-4(fp)
 8227370:	10800017 	ldw	r2,0(r2)
 8227374:	10bfc00c 	andi	r2,r2,65280
 8227378:	1004923a 	slli	r2,r2,8
 822737c:	2088b03a 	or	r4,r4,r2
 8227380:	e0bfff17 	ldw	r2,-4(fp)
 8227384:	10800017 	ldw	r2,0(r2)
 8227388:	1004963a 	slli	r2,r2,24
 822738c:	2084b03a 	or	r2,r4,r2
 8227390:	1885883a 	add	r2,r3,r2
 8227394:	01400c84 	movi	r5,50
 8227398:	1009883a 	mov	r4,r2
 822739c:	8202c740 	call	8202c74 <__umodsi3>
 82273a0:	10c00044 	addi	r3,r2,1
 82273a4:	e0bfff17 	ldw	r2,-4(fp)
 82273a8:	10c00315 	stw	r3,12(r2)
 82273ac:	00003806 	br	8227490 <igmp_joingroup+0x210>
      }
      else
      {
         igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 82273b0:	e17fff17 	ldw	r5,-4(fp)
 82273b4:	01000584 	movi	r4,22
 82273b8:	8226fe40 	call	8226fe4 <igmp_send>
         /* the delay time duration is the Unsolicited Report Interval */
         inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY ((UNSOLIC_RPT_INTERVAL * PR_FASTHZ), inm->inm_addr);
 82273bc:	008209b4 	movhi	r2,2086
 82273c0:	10ba6104 	addi	r2,r2,-5756
 82273c4:	10c00217 	ldw	r3,8(r2)
 82273c8:	008209b4 	movhi	r2,2086
 82273cc:	10b81b04 	addi	r2,r2,-8084
 82273d0:	10800017 	ldw	r2,0(r2)
 82273d4:	10800a17 	ldw	r2,40(r2)
 82273d8:	1008d63a 	srli	r4,r2,24
 82273dc:	008209b4 	movhi	r2,2086
 82273e0:	10b81b04 	addi	r2,r2,-8084
 82273e4:	10800017 	ldw	r2,0(r2)
 82273e8:	10800a17 	ldw	r2,40(r2)
 82273ec:	1004d23a 	srli	r2,r2,8
 82273f0:	10bfc00c 	andi	r2,r2,65280
 82273f4:	2088b03a 	or	r4,r4,r2
 82273f8:	008209b4 	movhi	r2,2086
 82273fc:	10b81b04 	addi	r2,r2,-8084
 8227400:	10800017 	ldw	r2,0(r2)
 8227404:	10800a17 	ldw	r2,40(r2)
 8227408:	10bfc00c 	andi	r2,r2,65280
 822740c:	1004923a 	slli	r2,r2,8
 8227410:	2088b03a 	or	r4,r4,r2
 8227414:	008209b4 	movhi	r2,2086
 8227418:	10b81b04 	addi	r2,r2,-8084
 822741c:	10800017 	ldw	r2,0(r2)
 8227420:	10800a17 	ldw	r2,40(r2)
 8227424:	1004963a 	slli	r2,r2,24
 8227428:	2084b03a 	or	r2,r4,r2
 822742c:	1887883a 	add	r3,r3,r2
 8227430:	e0bfff17 	ldw	r2,-4(fp)
 8227434:	10800017 	ldw	r2,0(r2)
 8227438:	1008d63a 	srli	r4,r2,24
 822743c:	e0bfff17 	ldw	r2,-4(fp)
 8227440:	10800017 	ldw	r2,0(r2)
 8227444:	1004d23a 	srli	r2,r2,8
 8227448:	10bfc00c 	andi	r2,r2,65280
 822744c:	2088b03a 	or	r4,r4,r2
 8227450:	e0bfff17 	ldw	r2,-4(fp)
 8227454:	10800017 	ldw	r2,0(r2)
 8227458:	10bfc00c 	andi	r2,r2,65280
 822745c:	1004923a 	slli	r2,r2,8
 8227460:	2088b03a 	or	r4,r4,r2
 8227464:	e0bfff17 	ldw	r2,-4(fp)
 8227468:	10800017 	ldw	r2,0(r2)
 822746c:	1004963a 	slli	r2,r2,24
 8227470:	2084b03a 	or	r2,r4,r2
 8227474:	1885883a 	add	r2,r3,r2
 8227478:	01400c84 	movi	r5,50
 822747c:	1009883a 	mov	r4,r2
 8227480:	8202c740 	call	8202c74 <__umodsi3>
 8227484:	10c00044 	addi	r3,r2,1
 8227488:	e0bfff17 	ldw	r2,-4(fp)
 822748c:	10c00315 	stw	r3,12(r2)
      }
      
      /* for IGMPv2, indicate that we were the last to send 
       * a Report for this multicast group (relevant for 
       * IGMPv2 only). */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 8227490:	e0bffe17 	ldw	r2,-8(fp)
 8227494:	10802f03 	ldbu	r2,188(r2)
 8227498:	10803fcc 	andi	r2,r2,255
 822749c:	10800098 	cmpnei	r2,r2,2
 82274a0:	1000031e 	bne	r2,zero,82274b0 <igmp_joingroup+0x230>
      {
         inm->last2send_report = IGMP_TRUE;
 82274a4:	e0bfff17 	ldw	r2,-4(fp)
 82274a8:	00c00044 	movi	r3,1
 82274ac:	10c00405 	stb	r3,16(r2)
      }

      ++igmp_timers_are_running;
 82274b0:	d0a08617 	ldw	r2,-32232(gp)
 82274b4:	10800044 	addi	r2,r2,1
 82274b8:	d0a08615 	stw	r2,-32232(gp)
   }
   
   return;
 82274bc:	0001883a 	nop
}     
 82274c0:	e037883a 	mov	sp,fp
 82274c4:	dfc00117 	ldw	ra,4(sp)
 82274c8:	df000017 	ldw	fp,0(sp)
 82274cc:	dec00204 	addi	sp,sp,8
 82274d0:	f800283a 	ret

082274d4 <igmp_leavegroup>:
 *
 * OUTPUT: None.
 */

void igmp_leavegroup (struct in_multi * inm)
{
 82274d4:	defffc04 	addi	sp,sp,-16
 82274d8:	dfc00315 	stw	ra,12(sp)
 82274dc:	df000215 	stw	fp,8(sp)
 82274e0:	df000204 	addi	fp,sp,8
 82274e4:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = inm->inm_netp;
 82274e8:	e0bfff17 	ldw	r2,-4(fp)
 82274ec:	10800117 	ldw	r2,4(r2)
 82274f0:	e0bffe15 	stw	r2,-8(fp)

   if ((ifp->igmp_oper_mode == IGMP_MODE_V2) && 
 82274f4:	e0bffe17 	ldw	r2,-8(fp)
 82274f8:	10802f03 	ldbu	r2,188(r2)
 82274fc:	10803fcc 	andi	r2,r2,255
 8227500:	10800098 	cmpnei	r2,r2,2
 8227504:	10000d1e 	bne	r2,zero,822753c <igmp_leavegroup+0x68>
       !ifp->igmpv1_rtr_present)
 8227508:	e0bffe17 	ldw	r2,-8(fp)
 822750c:	10802d03 	ldbu	r2,180(r2)
{
   NET ifp;

   ifp = inm->inm_netp;

   if ((ifp->igmp_oper_mode == IGMP_MODE_V2) && 
 8227510:	10803fcc 	andi	r2,r2,255
 8227514:	1000091e 	bne	r2,zero,822753c <igmp_leavegroup+0x68>
       !ifp->igmpv1_rtr_present)
   {
      if (inm->last2send_report == IGMP_TRUE)
 8227518:	e0bfff17 	ldw	r2,-4(fp)
 822751c:	10800403 	ldbu	r2,16(r2)
 8227520:	10803fcc 	andi	r2,r2,255
 8227524:	10800058 	cmpnei	r2,r2,1
 8227528:	1000041e 	bne	r2,zero,822753c <igmp_leavegroup+0x68>
         igmp_send (IGMPv2_LEAVE_GROUP, inm);
 822752c:	e17fff17 	ldw	r5,-4(fp)
 8227530:	010005c4 	movi	r4,23
 8227534:	8226fe40 	call	8226fe4 <igmp_send>
   }
   
   return;
 8227538:	0001883a 	nop
 822753c:	0001883a 	nop
}
 8227540:	e037883a 	mov	sp,fp
 8227544:	dfc00117 	ldw	ra,4(sp)
 8227548:	df000017 	ldw	fp,0(sp)
 822754c:	dec00204 	addi	sp,sp,8
 8227550:	f800283a 	ret

08227554 <igmp_validate>:
 *         validation fails; otherwise, it returns
 *         IGMP_OK.
 */

int igmp_validate (PACKET p)
{
 8227554:	defff604 	addi	sp,sp,-40
 8227558:	dfc00915 	stw	ra,36(sp)
 822755c:	df000815 	stw	fp,32(sp)
 8227560:	df000804 	addi	fp,sp,32
 8227564:	e13fff15 	stw	r4,-4(fp)
   u_short xsum;  
   u_char type;
   ip_addr mcgrp_addr;
   u_char resp_time;

   pip = ip_head (p);
 8227568:	e0bfff17 	ldw	r2,-4(fp)
 822756c:	10800317 	ldw	r2,12(r2)
 8227570:	e0bff815 	stw	r2,-32(fp)

   /* compute length of IGMP packet (after accounting for IP header, 
    * including the IP Router Alert option (if present)) */
   igmplen = p->nb_plen - ip_hlen (pip);
 8227574:	e0bfff17 	ldw	r2,-4(fp)
 8227578:	10c00417 	ldw	r3,16(r2)
 822757c:	e0bff817 	ldw	r2,-32(fp)
 8227580:	10800003 	ldbu	r2,0(r2)
 8227584:	10803fcc 	andi	r2,r2,255
 8227588:	108003cc 	andi	r2,r2,15
 822758c:	1085883a 	add	r2,r2,r2
 8227590:	1085883a 	add	r2,r2,r2
 8227594:	1885c83a 	sub	r2,r3,r2
 8227598:	e0bff915 	stw	r2,-28(fp)

   /* validate length (IGMP_MINLEN is 8 bytes) */
   if (igmplen != IGMP_MINLEN) 
 822759c:	e0bff917 	ldw	r2,-28(fp)
 82275a0:	10800220 	cmpeqi	r2,r2,8
 82275a4:	1000091e 	bne	r2,zero,82275cc <igmp_validate+0x78>
   {
      ++igmpstats.igmp_badlen_rcvd;
 82275a8:	008209b4 	movhi	r2,2086
 82275ac:	10b81f04 	addi	r2,r2,-8068
 82275b0:	10800a17 	ldw	r2,40(r2)
 82275b4:	10c00044 	addi	r3,r2,1
 82275b8:	008209b4 	movhi	r2,2086
 82275bc:	10b81f04 	addi	r2,r2,-8068
 82275c0:	10c00a15 	stw	r3,40(r2)
      return ENP_BAD_HEADER;
 82275c4:	00bff804 	movi	r2,-32
 82275c8:	0000a306 	br	8227858 <igmp_validate+0x304>
   }

   /* validate checksum */
   igmp = (struct igmp *) (ip_data (pip));
 82275cc:	e0bff817 	ldw	r2,-32(fp)
 82275d0:	10800003 	ldbu	r2,0(r2)
 82275d4:	10803fcc 	andi	r2,r2,255
 82275d8:	108003cc 	andi	r2,r2,15
 82275dc:	1085883a 	add	r2,r2,r2
 82275e0:	1085883a 	add	r2,r2,r2
 82275e4:	1007883a 	mov	r3,r2
 82275e8:	e0bff817 	ldw	r2,-32(fp)
 82275ec:	10c5883a 	add	r2,r2,r3
 82275f0:	e0bffa15 	stw	r2,-24(fp)
   osum = igmp->igmp_cksum;
 82275f4:	e0bffa17 	ldw	r2,-24(fp)
 82275f8:	1080008b 	ldhu	r2,2(r2)
 82275fc:	e0bffb0d 	sth	r2,-20(fp)
   igmp->igmp_cksum = 0;
 8227600:	e0bffa17 	ldw	r2,-24(fp)
 8227604:	1000008d 	sth	zero,2(r2)
   xsum = ~cksum(igmp, igmplen>>1);
 8227608:	e0bff917 	ldw	r2,-28(fp)
 822760c:	1005d07a 	srai	r2,r2,1
 8227610:	100b883a 	mov	r5,r2
 8227614:	e13ffa17 	ldw	r4,-24(fp)
 8227618:	82287b40 	call	82287b4 <cksum>
 822761c:	0084303a 	nor	r2,zero,r2
 8227620:	e0bffb8d 	sth	r2,-18(fp)
   if (xsum != osum)
 8227624:	e0fffb8b 	ldhu	r3,-18(fp)
 8227628:	e0bffb0b 	ldhu	r2,-20(fp)
 822762c:	18800c26 	beq	r3,r2,8227660 <igmp_validate+0x10c>
   {
      igmp->igmp_cksum = osum;
 8227630:	e0bffa17 	ldw	r2,-24(fp)
 8227634:	e0fffb0b 	ldhu	r3,-20(fp)
 8227638:	10c0008d 	sth	r3,2(r2)
      ++igmpstats.igmp_badsum_rcvd;
 822763c:	008209b4 	movhi	r2,2086
 8227640:	10b81f04 	addi	r2,r2,-8068
 8227644:	10800b17 	ldw	r2,44(r2)
 8227648:	10c00044 	addi	r3,r2,1
 822764c:	008209b4 	movhi	r2,2086
 8227650:	10b81f04 	addi	r2,r2,-8068
 8227654:	10c00b15 	stw	r3,44(r2)
      return ENP_BAD_HEADER;
 8227658:	00bff804 	movi	r2,-32
 822765c:	00007e06 	br	8227858 <igmp_validate+0x304>
   }
   
   /* extract the IGMP packet type, Group Address, and Max Response Time 
    * (unused for IGMPv1) fields from received packet */
   type = igmp->igmp_type;
 8227660:	e0bffa17 	ldw	r2,-24(fp)
 8227664:	10800003 	ldbu	r2,0(r2)
 8227668:	e0bffc05 	stb	r2,-16(fp)
   mcgrp_addr = ntohl(igmp->igmp_group); 
 822766c:	e0bffa17 	ldw	r2,-24(fp)
 8227670:	10800117 	ldw	r2,4(r2)
 8227674:	1006d63a 	srli	r3,r2,24
 8227678:	e0bffa17 	ldw	r2,-24(fp)
 822767c:	10800117 	ldw	r2,4(r2)
 8227680:	1004d23a 	srli	r2,r2,8
 8227684:	10bfc00c 	andi	r2,r2,65280
 8227688:	1886b03a 	or	r3,r3,r2
 822768c:	e0bffa17 	ldw	r2,-24(fp)
 8227690:	10800117 	ldw	r2,4(r2)
 8227694:	10bfc00c 	andi	r2,r2,65280
 8227698:	1004923a 	slli	r2,r2,8
 822769c:	1886b03a 	or	r3,r3,r2
 82276a0:	e0bffa17 	ldw	r2,-24(fp)
 82276a4:	10800117 	ldw	r2,4(r2)
 82276a8:	1004963a 	slli	r2,r2,24
 82276ac:	1884b03a 	or	r2,r3,r2
 82276b0:	e0bffd15 	stw	r2,-12(fp)
   resp_time = igmp->igmp_code;
 82276b4:	e0bffa17 	ldw	r2,-24(fp)
 82276b8:	10800043 	ldbu	r2,1(r2)
 82276bc:	e0bffe05 	stb	r2,-8(fp)
      
   if (type == IGMP_HOST_MEMBERSHIP_QUERY)
 82276c0:	e0bffc03 	ldbu	r2,-16(fp)
 82276c4:	10800458 	cmpnei	r2,r2,17
 82276c8:	1000301e 	bne	r2,zero,822778c <igmp_validate+0x238>
   {
      if ((resp_time == 0) || /* IGMPv1 Query */
 82276cc:	e0bffe03 	ldbu	r2,-8(fp)
 82276d0:	10000426 	beq	r2,zero,82276e4 <igmp_validate+0x190>
 82276d4:	e0bffe03 	ldbu	r2,-8(fp)
 82276d8:	10000f26 	beq	r2,zero,8227718 <igmp_validate+0x1c4>
          ((resp_time > 0) && (mcgrp_addr == 0))) /* IGMPv2 General Query */     
 82276dc:	e0bffd17 	ldw	r2,-12(fp)
 82276e0:	10000d1e 	bne	r2,zero,8227718 <igmp_validate+0x1c4>
      {
         /* if this is a IGMPv1 Host Membership Query or a IGMPv2 
          * General Query, it must be addressed to the all-hosts 
          * group */
         if (pip->ip_dest != igmp_all_hosts_group) 
 82276e4:	e0bff817 	ldw	r2,-32(fp)
 82276e8:	10c00417 	ldw	r3,16(r2)
 82276ec:	d0a08817 	ldw	r2,-32224(gp)
 82276f0:	18800926 	beq	r3,r2,8227718 <igmp_validate+0x1c4>
         {
            ++igmpstats.igmp_bad_queries_rcvd;
 82276f4:	008209b4 	movhi	r2,2086
 82276f8:	10b81f04 	addi	r2,r2,-8068
 82276fc:	10800e17 	ldw	r2,56(r2)
 8227700:	10c00044 	addi	r3,r2,1
 8227704:	008209b4 	movhi	r2,2086
 8227708:	10b81f04 	addi	r2,r2,-8068
 822770c:	10c00e15 	stw	r3,56(r2)
            return ENP_BAD_HEADER;
 8227710:	00bff804 	movi	r2,-32
 8227714:	00005006 	br	8227858 <igmp_validate+0x304>
         }     
      }
      
      if ((resp_time > 0) && (mcgrp_addr != 0))
 8227718:	e0bffe03 	ldbu	r2,-8(fp)
 822771c:	10001b26 	beq	r2,zero,822778c <igmp_validate+0x238>
 8227720:	e0bffd17 	ldw	r2,-12(fp)
 8227724:	10001926 	beq	r2,zero,822778c <igmp_validate+0x238>
      {
         /* this is a IGMPv2 Group-Specific Query. */
         if (p->net->igmp_oper_mode == IGMP_MODE_V1)
 8227728:	e0bfff17 	ldw	r2,-4(fp)
 822772c:	10800617 	ldw	r2,24(r2)
 8227730:	10802f03 	ldbu	r2,188(r2)
 8227734:	10803fcc 	andi	r2,r2,255
 8227738:	10800058 	cmpnei	r2,r2,1
 822773c:	1000021e 	bne	r2,zero,8227748 <igmp_validate+0x1f4>
         {
            /* IGMPv1 code does not understand a IGMPv2 Group-
             * Specific Query */
            return ENP_BAD_HEADER; 
 8227740:	00bff804 	movi	r2,-32
 8227744:	00004406 	br	8227858 <igmp_validate+0x304>
         /* check to make sure that the group address field carries
          * a valid multicast address; if it doesn't, we
          * drop the packet.  Also drop packets that
          * carry the multicast address for the all-hosts
          * group. */
         if ((!IN_MULTICAST(mcgrp_addr)) ||
 8227748:	e0bffd17 	ldw	r2,-12(fp)
 822774c:	10fc002c 	andhi	r3,r2,61440
 8227750:	00b80034 	movhi	r2,57344
 8227754:	1880041e 	bne	r3,r2,8227768 <igmp_validate+0x214>
             /* igmp_all_hosts_group is already in network byte order */
             (igmp->igmp_group == igmp_all_hosts_group))
 8227758:	e0bffa17 	ldw	r2,-24(fp)
 822775c:	10c00117 	ldw	r3,4(r2)
 8227760:	d0a08817 	ldw	r2,-32224(gp)
         /* check to make sure that the group address field carries
          * a valid multicast address; if it doesn't, we
          * drop the packet.  Also drop packets that
          * carry the multicast address for the all-hosts
          * group. */
         if ((!IN_MULTICAST(mcgrp_addr)) ||
 8227764:	1880091e 	bne	r3,r2,822778c <igmp_validate+0x238>
             /* igmp_all_hosts_group is already in network byte order */
             (igmp->igmp_group == igmp_all_hosts_group))
         {
            ++igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd;
 8227768:	008209b4 	movhi	r2,2086
 822776c:	10b81f04 	addi	r2,r2,-8068
 8227770:	10801117 	ldw	r2,68(r2)
 8227774:	10c00044 	addi	r3,r2,1
 8227778:	008209b4 	movhi	r2,2086
 822777c:	10b81f04 	addi	r2,r2,-8068
 8227780:	10c01115 	stw	r3,68(r2)
            /* caller will free received packet */
            return ENP_BAD_HEADER;
 8227784:	00bff804 	movi	r2,-32
 8227788:	00003306 	br	8227858 <igmp_validate+0x304>
   
   /* check to ensure that a received IGMPv1 or v2 Report has the 
    * same IP host group address in its IP destination field and 
    * its IGMP group address field, and that the group address is
    * a valid multicast address */
   if ((type == IGMP_HOST_MEMBERSHIP_REPORT) ||
 822778c:	e0bffc03 	ldbu	r2,-16(fp)
 8227790:	108004a0 	cmpeqi	r2,r2,18
 8227794:	1000031e 	bne	r2,zero,82277a4 <igmp_validate+0x250>
 8227798:	e0bffc03 	ldbu	r2,-16(fp)
 822779c:	10800598 	cmpnei	r2,r2,22
 82277a0:	1000121e 	bne	r2,zero,82277ec <igmp_validate+0x298>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      if ((igmp->igmp_group != pip->ip_dest) ||
 82277a4:	e0bffa17 	ldw	r2,-24(fp)
 82277a8:	10c00117 	ldw	r3,4(r2)
 82277ac:	e0bff817 	ldw	r2,-32(fp)
 82277b0:	10800417 	ldw	r2,16(r2)
 82277b4:	1880041e 	bne	r3,r2,82277c8 <igmp_validate+0x274>
          (!IN_MULTICAST(mcgrp_addr)))
 82277b8:	e0bffd17 	ldw	r2,-12(fp)
 82277bc:	10fc002c 	andhi	r3,r2,61440
    * its IGMP group address field, and that the group address is
    * a valid multicast address */
   if ((type == IGMP_HOST_MEMBERSHIP_REPORT) ||
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      if ((igmp->igmp_group != pip->ip_dest) ||
 82277c0:	00b80034 	movhi	r2,57344
 82277c4:	18800926 	beq	r3,r2,82277ec <igmp_validate+0x298>
          (!IN_MULTICAST(mcgrp_addr)))
      {
         ++igmpstats.igmp_bad_reports_rcvd;
 82277c8:	008209b4 	movhi	r2,2086
 82277cc:	10b81f04 	addi	r2,r2,-8068
 82277d0:	10800f17 	ldw	r2,60(r2)
 82277d4:	10c00044 	addi	r3,r2,1
 82277d8:	008209b4 	movhi	r2,2086
 82277dc:	10b81f04 	addi	r2,r2,-8068
 82277e0:	10c00f15 	stw	r3,60(r2)
         return ENP_BAD_HEADER;    
 82277e4:	00bff804 	movi	r2,-32
 82277e8:	00001b06 	br	8227858 <igmp_validate+0x304>

    * Version 1 Host Membership Reports and Version 1 Host Membership Query
    * packets will not be checked for the IP Router Alert option.
    */
#ifdef IGMP_V2    
   if ((type == IGMPv2_LEAVE_GROUP) || 
 82277ec:	e0bffc03 	ldbu	r2,-16(fp)
 82277f0:	108005e0 	cmpeqi	r2,r2,23
 82277f4:	10000a1e 	bne	r2,zero,8227820 <igmp_validate+0x2cc>
 82277f8:	e0bffc03 	ldbu	r2,-16(fp)
 82277fc:	108005a0 	cmpeqi	r2,r2,22
 8227800:	1000071e 	bne	r2,zero,8227820 <igmp_validate+0x2cc>
       (type == IGMPv2_MEMBERSHIP_REPORT) ||
 8227804:	e0bffc03 	ldbu	r2,-16(fp)
 8227808:	10800458 	cmpnei	r2,r2,17
 822780c:	1000111e 	bne	r2,zero,8227854 <igmp_validate+0x300>
       ((type == IGMP_HOST_MEMBERSHIP_QUERY) && (igmp->igmp_code > 0)))
 8227810:	e0bffa17 	ldw	r2,-24(fp)
 8227814:	10800043 	ldbu	r2,1(r2)
 8227818:	10803fcc 	andi	r2,r2,255
 822781c:	10000d26 	beq	r2,zero,8227854 <igmp_validate+0x300>
       
   {
      if (!igmpv2_chk4_rtr_alert_opt (pip))
 8227820:	e13ff817 	ldw	r4,-32(fp)
 8227824:	8245d380 	call	8245d38 <igmpv2_chk4_rtr_alert_opt>
 8227828:	10803fcc 	andi	r2,r2,255
 822782c:	1000091e 	bne	r2,zero,8227854 <igmp_validate+0x300>
      { 
         ++igmpstats.igmpv2mode_v2_rtr_alert_missing;
 8227830:	008209b4 	movhi	r2,2086
 8227834:	10b81f04 	addi	r2,r2,-8068
 8227838:	10801417 	ldw	r2,80(r2)
 822783c:	10c00044 	addi	r3,r2,1
 8227840:	008209b4 	movhi	r2,2086
 8227844:	10b81f04 	addi	r2,r2,-8068
 8227848:	10c01415 	stw	r3,80(r2)
         return ENP_BAD_HEADER;
 822784c:	00bff804 	movi	r2,-32
 8227850:	00000106 	br	8227858 <igmp_validate+0x304>
      }
   }
#endif   

   /* validation successful */
   return IGMP_OK;
 8227854:	0005883a 	mov	r2,zero
}
 8227858:	e037883a 	mov	sp,fp
 822785c:	dfc00117 	ldw	ra,4(sp)
 8227860:	df000017 	ldw	fp,0(sp)
 8227864:	dec00204 	addi	sp,sp,8
 8227868:	f800283a 	ret

0822786c <igmp_print_stats>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */
   
int igmp_print_stats (void * pio)
{  
 822786c:	defffa04 	addi	sp,sp,-24
 8227870:	dfc00515 	stw	ra,20(sp)
 8227874:	df000415 	stw	fp,16(sp)
 8227878:	df000404 	addi	fp,sp,16
 822787c:	e13fff15 	stw	r4,-4(fp)
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 8227880:	008209b4 	movhi	r2,2086
 8227884:	10ba5c04 	addi	r2,r2,-5776
 8227888:	10800017 	ldw	r2,0(r2)
 822788c:	e0bffe15 	stw	r2,-8(fp)
 8227890:	00003b06 	br	8227980 <igmp_print_stats+0x114>
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
                 ifp->name, 
 8227894:	e0bffe17 	ldw	r2,-8(fp)
 8227898:	10c00104 	addi	r3,r2,4
                 ifp->igmp_oper_mode, 
 822789c:	e0bffe17 	ldw	r2,-8(fp)
 82278a0:	10802f03 	ldbu	r2,188(r2)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
 82278a4:	11003fcc 	andi	r4,r2,255
                 ifp->name, 
                 ifp->igmp_oper_mode, 
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
 82278a8:	e0bffe17 	ldw	r2,-8(fp)
 82278ac:	10802f03 	ldbu	r2,188(r2)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
 82278b0:	10803fcc 	andi	r2,r2,255
 82278b4:	10800058 	cmpnei	r2,r2,1
 82278b8:	1000031e 	bne	r2,zero,82278c8 <igmp_print_stats+0x5c>
 82278bc:	00820974 	movhi	r2,2085
 82278c0:	10802104 	addi	r2,r2,132
 82278c4:	00000206 	br	82278d0 <igmp_print_stats+0x64>
 82278c8:	00820974 	movhi	r2,2085
 82278cc:	10802204 	addi	r2,r2,136
 82278d0:	d8800015 	stw	r2,0(sp)
 82278d4:	200f883a 	mov	r7,r4
 82278d8:	180d883a 	mov	r6,r3
 82278dc:	01420974 	movhi	r5,2085
 82278e0:	29402304 	addi	r5,r5,140
 82278e4:	e13fff17 	ldw	r4,-4(fp)
 82278e8:	8228e600 	call	8228e60 <ns_printf>
                 ifp->name, 
                 ifp->igmp_oper_mode, 
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 82278ec:	e0bffe17 	ldw	r2,-8(fp)
 82278f0:	10802f03 	ldbu	r2,188(r2)
 82278f4:	10803fcc 	andi	r2,r2,255
 82278f8:	10800098 	cmpnei	r2,r2,2
 82278fc:	1000191e 	bne	r2,zero,8227964 <igmp_print_stats+0xf8>
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
                    ifp->igmpv1_rtr_present,
 8227900:	e0bffe17 	ldw	r2,-8(fp)
 8227904:	10802d03 	ldbu	r2,180(r2)
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
 8227908:	11403fcc 	andi	r5,r2,255
                    ifp->igmpv1_rtr_present,
                    ((ifp->igmpv1_rtr_present == IGMP_TRUE)? "present" : "absent"),
 822790c:	e0bffe17 	ldw	r2,-8(fp)
 8227910:	10802d03 	ldbu	r2,180(r2)
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
 8227914:	10803fcc 	andi	r2,r2,255
 8227918:	10800058 	cmpnei	r2,r2,1
 822791c:	1000031e 	bne	r2,zero,822792c <igmp_print_stats+0xc0>
 8227920:	00820974 	movhi	r2,2085
 8227924:	10802804 	addi	r2,r2,160
 8227928:	00000206 	br	8227934 <igmp_print_stats+0xc8>
 822792c:	00820974 	movhi	r2,2085
 8227930:	10802a04 	addi	r2,r2,168
 8227934:	e0fffe17 	ldw	r3,-8(fp)
 8227938:	18c02e17 	ldw	r3,184(r3)
 822793c:	d120a817 	ldw	r4,-32096(gp)
 8227940:	d9000115 	stw	r4,4(sp)
 8227944:	d8c00015 	stw	r3,0(sp)
 8227948:	100f883a 	mov	r7,r2
 822794c:	280d883a 	mov	r6,r5
 8227950:	01420974 	movhi	r5,2085
 8227954:	29402c04 	addi	r5,r5,176
 8227958:	e13fff17 	ldw	r4,-4(fp)
 822795c:	8228e600 	call	8228e60 <ns_printf>
 8227960:	00000406 	br	8227974 <igmp_print_stats+0x108>
                    ifp->igmpv1_rtr_present,
                    ((ifp->igmpv1_rtr_present == IGMP_TRUE)? "present" : "absent"),
                    ifp->igmpv1_query_rcvd_time,
                    cticks);
      }
      else ns_printf (pio, "\n");
 8227964:	01420974 	movhi	r5,2085
 8227968:	29403704 	addi	r5,r5,220
 822796c:	e13fff17 	ldw	r4,-4(fp)
 8227970:	8228e600 	call	8228e60 <ns_printf>
   
int igmp_print_stats (void * pio)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 8227974:	e0bffe17 	ldw	r2,-8(fp)
 8227978:	10800017 	ldw	r2,0(r2)
 822797c:	e0bffe15 	stw	r2,-8(fp)
 8227980:	e0bffe17 	ldw	r2,-8(fp)
 8227984:	103fc31e 	bne	r2,zero,8227894 <igmp_print_stats+0x28>
      }
      else ns_printf (pio, "\n");
   }   

   /* rx and timer statistics */
   ns_printf (pio, "[Rx ] IGMP messages rcvd: %lu, timers running: %lu\n", igmpstats.igmp_total_rcvd, igmp_timers_are_running);
 8227988:	008209b4 	movhi	r2,2086
 822798c:	10b81f04 	addi	r2,r2,-8068
 8227990:	10800017 	ldw	r2,0(r2)
 8227994:	d0e08617 	ldw	r3,-32232(gp)
 8227998:	180f883a 	mov	r7,r3
 822799c:	100d883a 	mov	r6,r2
 82279a0:	01420974 	movhi	r5,2085
 82279a4:	29403804 	addi	r5,r5,224
 82279a8:	e13fff17 	ldw	r4,-4(fp)
 82279ac:	8228e600 	call	8228e60 <ns_printf>
   
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v1-mode links): %lu\n", igmpstats.igmpv1mode_v1_queries_rcvd);
 82279b0:	008209b4 	movhi	r2,2086
 82279b4:	10b81f04 	addi	r2,r2,-8068
 82279b8:	10800117 	ldw	r2,4(r2)
 82279bc:	100d883a 	mov	r6,r2
 82279c0:	01420974 	movhi	r5,2085
 82279c4:	29404504 	addi	r5,r5,276
 82279c8:	e13fff17 	ldw	r4,-4(fp)
 82279cc:	8228e600 	call	8228e60 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Reports rcvd: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd);
 82279d0:	008209b4 	movhi	r2,2086
 82279d4:	10b81f04 	addi	r2,r2,-8068
 82279d8:	10800217 	ldw	r2,8(r2)
 82279dc:	100d883a 	mov	r6,r2
 82279e0:	01420974 	movhi	r5,2085
 82279e4:	29405604 	addi	r5,r5,344
 82279e8:	e13fff17 	ldw	r4,-4(fp)
 82279ec:	8228e600 	call	8228e60 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer);
 82279f0:	008209b4 	movhi	r2,2086
 82279f4:	10b81f04 	addi	r2,r2,-8068
 82279f8:	10800317 	ldw	r2,12(r2)
 82279fc:	100d883a 	mov	r6,r2
 8227a00:	01420974 	movhi	r5,2085
 8227a04:	29406204 	addi	r5,r5,392
 8227a08:	e13fff17 	ldw	r4,-4(fp)
 8227a0c:	8228e600 	call	8228e60 <ns_printf>
      
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v2-mode links): %lu\n", igmpstats.igmpv2mode_v1_queries_rcvd);
 8227a10:	008209b4 	movhi	r2,2086
 8227a14:	10b81f04 	addi	r2,r2,-8068
 8227a18:	10800417 	ldw	r2,16(r2)
 8227a1c:	100d883a 	mov	r6,r2
 8227a20:	01420974 	movhi	r5,2085
 8227a24:	29407504 	addi	r5,r5,468
 8227a28:	e13fff17 	ldw	r4,-4(fp)
 8227a2c:	8228e600 	call	8228e60 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 General Queries rcvd: %lu, Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_general_queries_rcvd, igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd);
 8227a30:	008209b4 	movhi	r2,2086
 8227a34:	10b81f04 	addi	r2,r2,-8068
 8227a38:	10c00517 	ldw	r3,20(r2)
 8227a3c:	008209b4 	movhi	r2,2086
 8227a40:	10b81f04 	addi	r2,r2,-8068
 8227a44:	10800617 	ldw	r2,24(r2)
 8227a48:	100f883a 	mov	r7,r2
 8227a4c:	180d883a 	mov	r6,r3
 8227a50:	01420974 	movhi	r5,2085
 8227a54:	29408604 	addi	r5,r5,536
 8227a58:	e13fff17 	ldw	r4,-4(fp)
 8227a5c:	8228e600 	call	8228e60 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer);   
 8227a60:	008209b4 	movhi	r2,2086
 8227a64:	10b81f04 	addi	r2,r2,-8068
 8227a68:	10800717 	ldw	r2,28(r2)
 8227a6c:	100d883a 	mov	r6,r2
 8227a70:	01420974 	movhi	r5,2085
 8227a74:	29406204 	addi	r5,r5,392
 8227a78:	e13fff17 	ldw	r4,-4(fp)
 8227a7c:	8228e600 	call	8228e60 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd with no local timer: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_no_timer);
 8227a80:	008209b4 	movhi	r2,2086
 8227a84:	10b81f04 	addi	r2,r2,-8068
 8227a88:	10800817 	ldw	r2,32(r2)
 8227a8c:	100d883a 	mov	r6,r2
 8227a90:	01420974 	movhi	r5,2085
 8227a94:	29409904 	addi	r5,r5,612
 8227a98:	e13fff17 	ldw	r4,-4(fp)
 8227a9c:	8228e600 	call	8228e60 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 Leave Group messages rcvd: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_rcvd);
 8227aa0:	008209b4 	movhi	r2,2086
 8227aa4:	10b81f04 	addi	r2,r2,-8068
 8227aa8:	10800917 	ldw	r2,36(r2)
 8227aac:	100d883a 	mov	r6,r2
 8227ab0:	01420974 	movhi	r5,2085
 8227ab4:	2940aa04 	addi	r5,r5,680
 8227ab8:	e13fff17 	ldw	r4,-4(fp)
 8227abc:	8228e600 	call	8228e60 <ns_printf>
   
   /* tx statistics */
   ns_printf (pio, "[Tx ] IGMPv2 Leave Group messages sent: %lu, Membership Reports sent: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_sent, igmpstats.igmpv2mode_v2_reports_sent);
 8227ac0:	008209b4 	movhi	r2,2086
 8227ac4:	10b81f04 	addi	r2,r2,-8068
 8227ac8:	10c01717 	ldw	r3,92(r2)
 8227acc:	008209b4 	movhi	r2,2086
 8227ad0:	10b81f04 	addi	r2,r2,-8068
 8227ad4:	10801817 	ldw	r2,96(r2)
 8227ad8:	100f883a 	mov	r7,r2
 8227adc:	180d883a 	mov	r6,r3
 8227ae0:	01420974 	movhi	r5,2085
 8227ae4:	2940b604 	addi	r5,r5,728
 8227ae8:	e13fff17 	ldw	r4,-4(fp)
 8227aec:	8228e600 	call	8228e60 <ns_printf>
   ns_printf (pio, "[Tx ] IGMPv1 Host Membership Reports sent: %lu\n", igmpstats.igmp_v1_reports_sent);
 8227af0:	008209b4 	movhi	r2,2086
 8227af4:	10b81f04 	addi	r2,r2,-8068
 8227af8:	10801617 	ldw	r2,88(r2)
 8227afc:	100d883a 	mov	r6,r2
 8227b00:	01420974 	movhi	r5,2085
 8227b04:	2940c904 	addi	r5,r5,804
 8227b08:	e13fff17 	ldw	r4,-4(fp)
 8227b0c:	8228e600 	call	8228e60 <ns_printf>

   /* error statistics */
   ns_printf (pio, "[Err] IGMP packets rcvd with bad length: %lu\n", igmpstats.igmp_badlen_rcvd);
 8227b10:	008209b4 	movhi	r2,2086
 8227b14:	10b81f04 	addi	r2,r2,-8068
 8227b18:	10800a17 	ldw	r2,40(r2)
 8227b1c:	100d883a 	mov	r6,r2
 8227b20:	01420974 	movhi	r5,2085
 8227b24:	2940d504 	addi	r5,r5,852
 8227b28:	e13fff17 	ldw	r4,-4(fp)
 8227b2c:	8228e600 	call	8228e60 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets rcvd with bad checksum: %lu\n", igmpstats.igmp_badsum_rcvd);
 8227b30:	008209b4 	movhi	r2,2086
 8227b34:	10b81f04 	addi	r2,r2,-8068
 8227b38:	10800b17 	ldw	r2,44(r2)
 8227b3c:	100d883a 	mov	r6,r2
 8227b40:	01420974 	movhi	r5,2085
 8227b44:	2940e104 	addi	r5,r5,900
 8227b48:	e13fff17 	ldw	r4,-4(fp)
 8227b4c:	8228e600 	call	8228e60 <ns_printf>
   ns_printf (pio, "[Err] Packet buffer allocation failures: %lu, Bad IGMP Oper Mode config: %lu\n",igmpstats.igmp_pkt_alloc_fail, igmpstats.igmp_bad_oper_mode);
 8227b50:	008209b4 	movhi	r2,2086
 8227b54:	10b81f04 	addi	r2,r2,-8068
 8227b58:	10c00c17 	ldw	r3,48(r2)
 8227b5c:	008209b4 	movhi	r2,2086
 8227b60:	10b81f04 	addi	r2,r2,-8068
 8227b64:	10800d17 	ldw	r2,52(r2)
 8227b68:	100f883a 	mov	r7,r2
 8227b6c:	180d883a 	mov	r6,r3
 8227b70:	01420974 	movhi	r5,2085
 8227b74:	2940ed04 	addi	r5,r5,948
 8227b78:	e13fff17 	ldw	r4,-4(fp)
 8227b7c:	8228e600 	call	8228e60 <ns_printf>
   ns_printf (pio, "[Err] Bad IGMP Queries rcvd: %lu, Bad IGMP Reports rcvd: %lu\n", igmpstats.igmp_bad_queries_rcvd, igmpstats.igmp_bad_reports_rcvd); 
 8227b80:	008209b4 	movhi	r2,2086
 8227b84:	10b81f04 	addi	r2,r2,-8068
 8227b88:	10c00e17 	ldw	r3,56(r2)
 8227b8c:	008209b4 	movhi	r2,2086
 8227b90:	10b81f04 	addi	r2,r2,-8068
 8227b94:	10800f17 	ldw	r2,60(r2)
 8227b98:	100f883a 	mov	r7,r2
 8227b9c:	180d883a 	mov	r6,r3
 8227ba0:	01420974 	movhi	r5,2085
 8227ba4:	29410104 	addi	r5,r5,1028
 8227ba8:	e13fff17 	ldw	r4,-4(fp)
 8227bac:	8228e600 	call	8228e60 <ns_printf>
   ns_printf (pio, "[Err] Bad IGMPv2 Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd);
 8227bb0:	008209b4 	movhi	r2,2086
 8227bb4:	10b81f04 	addi	r2,r2,-8068
 8227bb8:	10801117 	ldw	r2,68(r2)
 8227bbc:	100d883a 	mov	r6,r2
 8227bc0:	01420974 	movhi	r5,2085
 8227bc4:	29411104 	addi	r5,r5,1092
 8227bc8:	e13fff17 	ldw	r4,-4(fp)
 8227bcc:	8228e600 	call	8228e60 <ns_printf>
   ns_printf (pio, "[Err] IGMPv2 Group-Specific Queries rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd);
 8227bd0:	008209b4 	movhi	r2,2086
 8227bd4:	10b81f04 	addi	r2,r2,-8068
 8227bd8:	10801217 	ldw	r2,72(r2)
 8227bdc:	100d883a 	mov	r6,r2
 8227be0:	01420974 	movhi	r5,2085
 8227be4:	29411e04 	addi	r5,r5,1144
 8227be8:	e13fff17 	ldw	r4,-4(fp)
 8227bec:	8228e600 	call	8228e60 <ns_printf>
   ns_printf (pio, "[Err] IGMP Membership Reports rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd);
 8227bf0:	008209b4 	movhi	r2,2086
 8227bf4:	10b81f04 	addi	r2,r2,-8068
 8227bf8:	10801317 	ldw	r2,76(r2)
 8227bfc:	100d883a 	mov	r6,r2
 8227c00:	01420974 	movhi	r5,2085
 8227c04:	29413104 	addi	r5,r5,1220
 8227c08:	e13fff17 	ldw	r4,-4(fp)
 8227c0c:	8228e600 	call	8228e60 <ns_printf>
   ns_printf (pio, "[Err] Number of IGMPv2 messages rcvd without Router Alert option: %lu\n", igmpstats.igmpv2mode_v2_rtr_alert_missing); 
 8227c10:	008209b4 	movhi	r2,2086
 8227c14:	10b81f04 	addi	r2,r2,-8068
 8227c18:	10801417 	ldw	r2,80(r2)
 8227c1c:	100d883a 	mov	r6,r2
 8227c20:	01420974 	movhi	r5,2085
 8227c24:	29414204 	addi	r5,r5,1288
 8227c28:	e13fff17 	ldw	r4,-4(fp)
 8227c2c:	8228e600 	call	8228e60 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v1-mode links: %lu\n", igmpstats.igmpv1mode_unknown_pkttype);
 8227c30:	008209b4 	movhi	r2,2086
 8227c34:	10b81f04 	addi	r2,r2,-8068
 8227c38:	10801017 	ldw	r2,64(r2)
 8227c3c:	100d883a 	mov	r6,r2
 8227c40:	01420974 	movhi	r5,2085
 8227c44:	29415404 	addi	r5,r5,1360
 8227c48:	e13fff17 	ldw	r4,-4(fp)
 8227c4c:	8228e600 	call	8228e60 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v2-mode links: %lu\n", igmpstats.igmpv2mode_unknown_pkttype);
 8227c50:	008209b4 	movhi	r2,2086
 8227c54:	10b81f04 	addi	r2,r2,-8068
 8227c58:	10801517 	ldw	r2,84(r2)
 8227c5c:	100d883a 	mov	r6,r2
 8227c60:	01420974 	movhi	r5,2085
 8227c64:	29416404 	addi	r5,r5,1424
 8227c68:	e13fff17 	ldw	r4,-4(fp)
 8227c6c:	8228e600 	call	8228e60 <ns_printf>
   
   return IGMP_OK;
 8227c70:	0005883a 	mov	r2,zero
}
 8227c74:	e037883a 	mov	sp,fp
 8227c78:	dfc00117 	ldw	ra,4(sp)
 8227c7c:	df000017 	ldw	fp,0(sp)
 8227c80:	dec00204 	addi	sp,sp,8
 8227c84:	f800283a 	ret

08227c88 <bsd_accept>:
 *          The error is available via bsd_errno(s).
 */
BSD_SOCKET
bsd_accept(BSD_SOCKET s,
           struct sockaddr * addr, int * addrlen)
{
 8227c88:	defff404 	addi	sp,sp,-48
 8227c8c:	dfc00b15 	stw	ra,44(sp)
 8227c90:	df000a15 	stw	fp,40(sp)
 8227c94:	df000a04 	addi	fp,sp,40
 8227c98:	e13ffd15 	stw	r4,-12(fp)
 8227c9c:	e17ffe15 	stw	r5,-8(fp)
 8227ca0:	e1bfff15 	stw	r6,-4(fp)
   struct socket * so;
   struct sockaddr laddr;
   long lret;

   so = LONG2SO(s);
 8227ca4:	e0bffd17 	ldw	r2,-12(fp)
 8227ca8:	10bff804 	addi	r2,r2,-32
 8227cac:	1085883a 	add	r2,r2,r2
 8227cb0:	1085883a 	add	r2,r2,r2
 8227cb4:	e0bff715 	stw	r2,-36(fp)
   SOC_CHECK(so);
 8227cb8:	008209b4 	movhi	r2,2086
 8227cbc:	10b95804 	addi	r2,r2,-6816
 8227cc0:	e0bff615 	stw	r2,-40(fp)
 8227cc4:	00000606 	br	8227ce0 <bsd_accept+0x58>
 8227cc8:	e0fff617 	ldw	r3,-40(fp)
 8227ccc:	e0bff717 	ldw	r2,-36(fp)
 8227cd0:	18800626 	beq	r3,r2,8227cec <bsd_accept+0x64>
 8227cd4:	e0bff617 	ldw	r2,-40(fp)
 8227cd8:	10800017 	ldw	r2,0(r2)
 8227cdc:	e0bff615 	stw	r2,-40(fp)
 8227ce0:	e0bff617 	ldw	r2,-40(fp)
 8227ce4:	103ff81e 	bne	r2,zero,8227cc8 <bsd_accept+0x40>
 8227ce8:	00000106 	br	8227cf0 <bsd_accept+0x68>
 8227cec:	0001883a 	nop
 8227cf0:	e0fff617 	ldw	r3,-40(fp)
 8227cf4:	e0bff717 	ldw	r2,-36(fp)
 8227cf8:	18800326 	beq	r3,r2,8227d08 <bsd_accept+0x80>
 8227cfc:	822d5940 	call	822d594 <dtrap>
 8227d00:	00bfffc4 	movi	r2,-1
 8227d04:	00002406 	br	8227d98 <bsd_accept+0x110>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (addr != NULL)
 8227d08:	e0bffe17 	ldw	r2,-8(fp)
 8227d0c:	10000726 	beq	r2,zero,8227d2c <bsd_accept+0xa4>
   {
      if (addrlen == 0)
 8227d10:	e0bfff17 	ldw	r2,-4(fp)
 8227d14:	1000051e 	bne	r2,zero,8227d2c <bsd_accept+0xa4>
      {
         so->so_error = EFAULT;
 8227d18:	e0bff717 	ldw	r2,-36(fp)
 8227d1c:	00c00384 	movi	r3,14
 8227d20:	10c00615 	stw	r3,24(r2)
         return -1;
 8227d24:	00bfffc4 	movi	r2,-1
 8227d28:	00001b06 	br	8227d98 <bsd_accept+0x110>
      }
   }

   lret = t_accept(s, &laddr, addrlen);
 8227d2c:	e0bff904 	addi	r2,fp,-28
 8227d30:	e1bfff17 	ldw	r6,-4(fp)
 8227d34:	100b883a 	mov	r5,r2
 8227d38:	e13ffd17 	ldw	r4,-12(fp)
 8227d3c:	82306ec0 	call	82306ec <t_accept>
 8227d40:	e0bff815 	stw	r2,-32(fp)
    * address: copy the peer's address back into the buffer, but limit
    * the copy to the lesser of the buffer's length and sizeof(struct
    * sockaddr_in), which is all that t_accept() can return as a peer
    * address.  
    */
   if ((lret != -1) && (addr != NULL))
 8227d44:	e0bff817 	ldw	r2,-32(fp)
 8227d48:	10bfffe0 	cmpeqi	r2,r2,-1
 8227d4c:	1000111e 	bne	r2,zero,8227d94 <bsd_accept+0x10c>
 8227d50:	e0bffe17 	ldw	r2,-8(fp)
 8227d54:	10000f26 	beq	r2,zero,8227d94 <bsd_accept+0x10c>
   {
      if (*addrlen > sizeof(struct sockaddr_in))
 8227d58:	e0bfff17 	ldw	r2,-4(fp)
 8227d5c:	10800017 	ldw	r2,0(r2)
 8227d60:	10800470 	cmpltui	r2,r2,17
 8227d64:	1000031e 	bne	r2,zero,8227d74 <bsd_accept+0xec>
         *addrlen = sizeof(struct sockaddr_in);
 8227d68:	e0bfff17 	ldw	r2,-4(fp)
 8227d6c:	00c00404 	movi	r3,16
 8227d70:	10c00015 	stw	r3,0(r2)
      MEMCPY(addr, &laddr, *addrlen);
 8227d74:	e0bfff17 	ldw	r2,-4(fp)
 8227d78:	10800017 	ldw	r2,0(r2)
 8227d7c:	1007883a 	mov	r3,r2
 8227d80:	e0bff904 	addi	r2,fp,-28
 8227d84:	180d883a 	mov	r6,r3
 8227d88:	100b883a 	mov	r5,r2
 8227d8c:	e13ffe17 	ldw	r4,-8(fp)
 8227d90:	8202f100 	call	8202f10 <memcpy>
   }

   return lret;
 8227d94:	e0bff817 	ldw	r2,-32(fp)
}
 8227d98:	e037883a 	mov	sp,fp
 8227d9c:	dfc00117 	ldw	ra,4(sp)
 8227da0:	df000017 	ldw	fp,0(sp)
 8227da4:	dec00204 	addi	sp,sp,8
 8227da8:	f800283a 	ret

08227dac <bsd_getpeername>:
 *          available via bsd_errno(s).
 */
int
bsd_getpeername(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 8227dac:	defff304 	addi	sp,sp,-52
 8227db0:	dfc00c15 	stw	ra,48(sp)
 8227db4:	df000b15 	stw	fp,44(sp)
 8227db8:	df000b04 	addi	fp,sp,44
 8227dbc:	e13ffd15 	stw	r4,-12(fp)
 8227dc0:	e17ffe15 	stw	r5,-8(fp)
 8227dc4:	e1bfff15 	stw	r6,-4(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 8227dc8:	e0bffd17 	ldw	r2,-12(fp)
 8227dcc:	10bff804 	addi	r2,r2,-32
 8227dd0:	1085883a 	add	r2,r2,r2
 8227dd4:	1085883a 	add	r2,r2,r2
 8227dd8:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 8227ddc:	008209b4 	movhi	r2,2086
 8227de0:	10b95804 	addi	r2,r2,-6816
 8227de4:	e0bff515 	stw	r2,-44(fp)
 8227de8:	00000606 	br	8227e04 <bsd_getpeername+0x58>
 8227dec:	e0fff517 	ldw	r3,-44(fp)
 8227df0:	e0bff617 	ldw	r2,-40(fp)
 8227df4:	18800626 	beq	r3,r2,8227e10 <bsd_getpeername+0x64>
 8227df8:	e0bff517 	ldw	r2,-44(fp)
 8227dfc:	10800017 	ldw	r2,0(r2)
 8227e00:	e0bff515 	stw	r2,-44(fp)
 8227e04:	e0bff517 	ldw	r2,-44(fp)
 8227e08:	103ff81e 	bne	r2,zero,8227dec <bsd_getpeername+0x40>
 8227e0c:	00000106 	br	8227e14 <bsd_getpeername+0x68>
 8227e10:	0001883a 	nop
 8227e14:	e0fff517 	ldw	r3,-44(fp)
 8227e18:	e0bff617 	ldw	r2,-40(fp)
 8227e1c:	18800326 	beq	r3,r2,8227e2c <bsd_getpeername+0x80>
 8227e20:	822d5940 	call	822d594 <dtrap>
 8227e24:	00bfffc4 	movi	r2,-1
 8227e28:	00002406 	br	8227ebc <bsd_getpeername+0x110>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 8227e2c:	e0bfff17 	ldw	r2,-4(fp)
 8227e30:	1000051e 	bne	r2,zero,8227e48 <bsd_getpeername+0x9c>
   {
      so->so_error = EFAULT;
 8227e34:	e0bff617 	ldw	r2,-40(fp)
 8227e38:	00c00384 	movi	r3,14
 8227e3c:	10c00615 	stw	r3,24(r2)
      return -1;
 8227e40:	00bfffc4 	movi	r2,-1
 8227e44:	00001d06 	br	8227ebc <bsd_getpeername+0x110>
   }
   lnamelen = *namelen;
 8227e48:	e0bfff17 	ldw	r2,-4(fp)
 8227e4c:	10800017 	ldw	r2,0(r2)
 8227e50:	e0bffc15 	stw	r2,-16(fp)

   lret = t_getpeername(s, &lname, &lnamelen);
 8227e54:	e0fffc04 	addi	r3,fp,-16
 8227e58:	e0bff804 	addi	r2,fp,-32
 8227e5c:	180d883a 	mov	r6,r3
 8227e60:	100b883a 	mov	r5,r2
 8227e64:	e13ffd17 	ldw	r4,-12(fp)
 8227e68:	8230bac0 	call	8230bac <t_getpeername>
 8227e6c:	e0bff715 	stw	r2,-36(fp)
    * t_getpeername() can return as a peer address, and pass the
    * copied length back to the caller.  
    * For IPV6 addresses, or for dual IPV4/IPV6 stack, 
    * the max size is sizeof(struct sockaddr_in6)
    */
   if (lret != -1)
 8227e70:	e0bff717 	ldw	r2,-36(fp)
 8227e74:	10bfffe0 	cmpeqi	r2,r2,-1
 8227e78:	10000f1e 	bne	r2,zero,8227eb8 <bsd_getpeername+0x10c>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 8227e7c:	e0bffc17 	ldw	r2,-16(fp)
 8227e80:	10800470 	cmpltui	r2,r2,17
 8227e84:	1000021e 	bne	r2,zero,8227e90 <bsd_getpeername+0xe4>
         lnamelen = sizeof(struct sockaddr_in);
 8227e88:	00800404 	movi	r2,16
 8227e8c:	e0bffc15 	stw	r2,-16(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(name, &lname, lnamelen);
 8227e90:	e0bffc17 	ldw	r2,-16(fp)
 8227e94:	1007883a 	mov	r3,r2
 8227e98:	e0bff804 	addi	r2,fp,-32
 8227e9c:	180d883a 	mov	r6,r3
 8227ea0:	100b883a 	mov	r5,r2
 8227ea4:	e13ffe17 	ldw	r4,-8(fp)
 8227ea8:	8202f100 	call	8202f10 <memcpy>
      *namelen = lnamelen;
 8227eac:	e0fffc17 	ldw	r3,-16(fp)
 8227eb0:	e0bfff17 	ldw	r2,-4(fp)
 8227eb4:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 8227eb8:	e0bff717 	ldw	r2,-36(fp)
}
 8227ebc:	e037883a 	mov	sp,fp
 8227ec0:	dfc00117 	ldw	ra,4(sp)
 8227ec4:	df000017 	ldw	fp,0(sp)
 8227ec8:	dec00204 	addi	sp,sp,8
 8227ecc:	f800283a 	ret

08227ed0 <bsd_getsockname>:
 *          available via bsd_errno(s).
 */
int
bsd_getsockname(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 8227ed0:	defff304 	addi	sp,sp,-52
 8227ed4:	dfc00c15 	stw	ra,48(sp)
 8227ed8:	df000b15 	stw	fp,44(sp)
 8227edc:	df000b04 	addi	fp,sp,44
 8227ee0:	e13ffd15 	stw	r4,-12(fp)
 8227ee4:	e17ffe15 	stw	r5,-8(fp)
 8227ee8:	e1bfff15 	stw	r6,-4(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 8227eec:	e0bffd17 	ldw	r2,-12(fp)
 8227ef0:	10bff804 	addi	r2,r2,-32
 8227ef4:	1085883a 	add	r2,r2,r2
 8227ef8:	1085883a 	add	r2,r2,r2
 8227efc:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 8227f00:	008209b4 	movhi	r2,2086
 8227f04:	10b95804 	addi	r2,r2,-6816
 8227f08:	e0bff515 	stw	r2,-44(fp)
 8227f0c:	00000606 	br	8227f28 <bsd_getsockname+0x58>
 8227f10:	e0fff517 	ldw	r3,-44(fp)
 8227f14:	e0bff617 	ldw	r2,-40(fp)
 8227f18:	18800626 	beq	r3,r2,8227f34 <bsd_getsockname+0x64>
 8227f1c:	e0bff517 	ldw	r2,-44(fp)
 8227f20:	10800017 	ldw	r2,0(r2)
 8227f24:	e0bff515 	stw	r2,-44(fp)
 8227f28:	e0bff517 	ldw	r2,-44(fp)
 8227f2c:	103ff81e 	bne	r2,zero,8227f10 <bsd_getsockname+0x40>
 8227f30:	00000106 	br	8227f38 <bsd_getsockname+0x68>
 8227f34:	0001883a 	nop
 8227f38:	e0fff517 	ldw	r3,-44(fp)
 8227f3c:	e0bff617 	ldw	r2,-40(fp)
 8227f40:	18800326 	beq	r3,r2,8227f50 <bsd_getsockname+0x80>
 8227f44:	822d5940 	call	822d594 <dtrap>
 8227f48:	00bfffc4 	movi	r2,-1
 8227f4c:	00002406 	br	8227fe0 <bsd_getsockname+0x110>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 8227f50:	e0bfff17 	ldw	r2,-4(fp)
 8227f54:	1000051e 	bne	r2,zero,8227f6c <bsd_getsockname+0x9c>
   {
      so->so_error = EFAULT;
 8227f58:	e0bff617 	ldw	r2,-40(fp)
 8227f5c:	00c00384 	movi	r3,14
 8227f60:	10c00615 	stw	r3,24(r2)
      return -1;
 8227f64:	00bfffc4 	movi	r2,-1
 8227f68:	00001d06 	br	8227fe0 <bsd_getsockname+0x110>
   }
   lnamelen = *namelen;
 8227f6c:	e0bfff17 	ldw	r2,-4(fp)
 8227f70:	10800017 	ldw	r2,0(r2)
 8227f74:	e0bffc15 	stw	r2,-16(fp)

   lret = t_getsockname(s, &lname, &lnamelen);
 8227f78:	e0fffc04 	addi	r3,fp,-16
 8227f7c:	e0bff804 	addi	r2,fp,-32
 8227f80:	180d883a 	mov	r6,r3
 8227f84:	100b883a 	mov	r5,r2
 8227f88:	e13ffd17 	ldw	r4,-12(fp)
 8227f8c:	8230bf00 	call	8230bf0 <t_getsockname>
 8227f90:	e0bff715 	stw	r2,-36(fp)
    * copied length back to the caller.  
    * For IPV6 addresses, or for a dual IPV4/IPV6 stack, 
    * the max size copied is sizeof(struct sockaddr_in6)
    *
    */
   if (lret != -1)
 8227f94:	e0bff717 	ldw	r2,-36(fp)
 8227f98:	10bfffe0 	cmpeqi	r2,r2,-1
 8227f9c:	10000f1e 	bne	r2,zero,8227fdc <bsd_getsockname+0x10c>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 8227fa0:	e0bffc17 	ldw	r2,-16(fp)
 8227fa4:	10800470 	cmpltui	r2,r2,17
 8227fa8:	1000021e 	bne	r2,zero,8227fb4 <bsd_getsockname+0xe4>
         lnamelen = sizeof(struct sockaddr_in);
 8227fac:	00800404 	movi	r2,16
 8227fb0:	e0bffc15 	stw	r2,-16(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);
#endif
      MEMCPY(name, &lname, lnamelen);
 8227fb4:	e0bffc17 	ldw	r2,-16(fp)
 8227fb8:	1007883a 	mov	r3,r2
 8227fbc:	e0bff804 	addi	r2,fp,-32
 8227fc0:	180d883a 	mov	r6,r3
 8227fc4:	100b883a 	mov	r5,r2
 8227fc8:	e13ffe17 	ldw	r4,-8(fp)
 8227fcc:	8202f100 	call	8202f10 <memcpy>
      *namelen = lnamelen;
 8227fd0:	e0fffc17 	ldw	r3,-16(fp)
 8227fd4:	e0bfff17 	ldw	r2,-4(fp)
 8227fd8:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 8227fdc:	e0bff717 	ldw	r2,-36(fp)
}
 8227fe0:	e037883a 	mov	sp,fp
 8227fe4:	dfc00117 	ldw	ra,4(sp)
 8227fe8:	df000017 	ldw	fp,0(sp)
 8227fec:	dec00204 	addi	sp,sp,8
 8227ff0:	f800283a 	ret

08227ff4 <bsd_i_sockoptlen>:
 * RETURNS: minimum length of the named socket option, in bytes
 */
int 
bsd_i_sockoptlen(int level,
                 int name)
{
 8227ff4:	defffd04 	addi	sp,sp,-12
 8227ff8:	df000215 	stw	fp,8(sp)
 8227ffc:	df000204 	addi	fp,sp,8
 8228000:	e13ffe15 	stw	r4,-8(fp)
 8228004:	e17fff15 	stw	r5,-4(fp)
   USE_ARG(level);

   switch (name)
 8228008:	e0bfff17 	ldw	r2,-4(fp)
 822800c:	10c02020 	cmpeqi	r3,r2,128
 8228010:	1800341e 	bne	r3,zero,82280e4 <bsd_i_sockoptlen+0xf0>
 8228014:	10c02048 	cmpgei	r3,r2,129
 8228018:	18001a1e 	bne	r3,zero,8228084 <bsd_i_sockoptlen+0x90>
 822801c:	10c00308 	cmpgei	r3,r2,12
 8228020:	18000e1e 	bne	r3,zero,822805c <bsd_i_sockoptlen+0x68>
 8228024:	10c00288 	cmpgei	r3,r2,10
 8228028:	1800361e 	bne	r3,zero,8228104 <bsd_i_sockoptlen+0x110>
 822802c:	10c00120 	cmpeqi	r3,r2,4
 8228030:	1800301e 	bne	r3,zero,82280f4 <bsd_i_sockoptlen+0x100>
 8228034:	10c00148 	cmpgei	r3,r2,5
 8228038:	1800031e 	bne	r3,zero,8228048 <bsd_i_sockoptlen+0x54>
 822803c:	108000e0 	cmpeqi	r2,r2,3
 8228040:	1000341e 	bne	r2,zero,8228114 <bsd_i_sockoptlen+0x120>
 8228044:	00003506 	br	822811c <bsd_i_sockoptlen+0x128>
 8228048:	10c00220 	cmpeqi	r3,r2,8
 822804c:	1800291e 	bne	r3,zero,82280f4 <bsd_i_sockoptlen+0x100>
 8228050:	10800260 	cmpeqi	r2,r2,9
 8228054:	1000291e 	bne	r2,zero,82280fc <bsd_i_sockoptlen+0x108>
 8228058:	00003006 	br	822811c <bsd_i_sockoptlen+0x128>
 822805c:	10c00420 	cmpeqi	r3,r2,16
 8228060:	1800241e 	bne	r3,zero,82280f4 <bsd_i_sockoptlen+0x100>
 8228064:	10c00448 	cmpgei	r3,r2,17
 8228068:	1800031e 	bne	r3,zero,8228078 <bsd_i_sockoptlen+0x84>
 822806c:	10800388 	cmpgei	r2,r2,14
 8228070:	10002a1e 	bne	r2,zero,822811c <bsd_i_sockoptlen+0x128>
 8228074:	00002506 	br	822810c <bsd_i_sockoptlen+0x118>
 8228078:	10800820 	cmpeqi	r2,r2,32
 822807c:	10001d1e 	bne	r2,zero,82280f4 <bsd_i_sockoptlen+0x100>
 8228080:	00002606 	br	822811c <bsd_i_sockoptlen+0x128>
 8228084:	10c401c8 	cmpgei	r3,r2,4103
 8228088:	18000a1e 	bne	r3,zero,82280b4 <bsd_i_sockoptlen+0xc0>
 822808c:	10c40148 	cmpgei	r3,r2,4101
 8228090:	1800161e 	bne	r3,zero,82280ec <bsd_i_sockoptlen+0xf8>
 8228094:	10c04020 	cmpeqi	r3,r2,256
 8228098:	1800161e 	bne	r3,zero,82280f4 <bsd_i_sockoptlen+0x100>
 822809c:	10c04010 	cmplti	r3,r2,256
 82280a0:	18001e1e 	bne	r3,zero,822811c <bsd_i_sockoptlen+0x128>
 82280a4:	10bbffc4 	addi	r2,r2,-4097
 82280a8:	108000a8 	cmpgeui	r2,r2,2
 82280ac:	10001b1e 	bne	r2,zero,822811c <bsd_i_sockoptlen+0x128>
 82280b0:	00001006 	br	82280f4 <bsd_i_sockoptlen+0x100>
 82280b4:	10c40588 	cmpgei	r3,r2,4118
 82280b8:	1800051e 	bne	r3,zero,82280d0 <bsd_i_sockoptlen+0xdc>
 82280bc:	10c40508 	cmpgei	r3,r2,4116
 82280c0:	1800061e 	bne	r3,zero,82280dc <bsd_i_sockoptlen+0xe8>
 82280c4:	10840248 	cmpgei	r2,r2,4105
 82280c8:	1000141e 	bne	r2,zero,822811c <bsd_i_sockoptlen+0x128>
 82280cc:	00000906 	br	82280f4 <bsd_i_sockoptlen+0x100>
 82280d0:	108405a0 	cmpeqi	r2,r2,4118
 82280d4:	1000071e 	bne	r2,zero,82280f4 <bsd_i_sockoptlen+0x100>
 82280d8:	00001006 	br	822811c <bsd_i_sockoptlen+0x128>
   {
   case SO_BIO:
   case SO_NBIO:
      /* these don't use an option value */
      return 0;
 82280dc:	0005883a 	mov	r2,zero
 82280e0:	00000f06 	br	8228120 <bsd_i_sockoptlen+0x12c>
   case SO_LINGER:
      /* this option is a struct linger */
      return sizeof(struct linger);
 82280e4:	00800204 	movi	r2,8
 82280e8:	00000d06 	br	8228120 <bsd_i_sockoptlen+0x12c>
   case SO_RCVTIMEO:
   case SO_SNDTIMEO:
      /* these options are type short */
      return sizeof(short);
 82280ec:	00800084 	movi	r2,2
 82280f0:	00000b06 	br	8228120 <bsd_i_sockoptlen+0x12c>
   case SO_RCVBUF:
   case SO_NONBLOCK:
   case SO_ERROR:
   case SO_TYPE:
      /* these options are type int */
      return sizeof(int);
 82280f4:	00800104 	movi	r2,4
 82280f8:	00000906 	br	8228120 <bsd_i_sockoptlen+0x12c>
      return sizeof(int (*)());
#endif /* TCP_ZEROCOPY */
#ifdef IP_MULTICAST
   case IP_MULTICAST_IF:
      /* this option is type ip_addr */
      return sizeof(ip_addr);
 82280fc:	00800104 	movi	r2,4
 8228100:	00000706 	br	8228120 <bsd_i_sockoptlen+0x12c>
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      /* these options are type u_char */
      return sizeof(u_char);
 8228104:	00800044 	movi	r2,1
 8228108:	00000506 	br	8228120 <bsd_i_sockoptlen+0x12c>
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      /* these options are struct ip_mreq */
      return sizeof(struct ip_mreq);
 822810c:	00800204 	movi	r2,8
 8228110:	00000306 	br	8228120 <bsd_i_sockoptlen+0x12c>
 * IP_TTL_OPT == SOREUSEADDR. This causes a build erro
 * due to duplicate cases. Removing this one. They both
 * return the same value (sizeof(int)).
 */
  // case IP_TTL_OPT:
      return sizeof(int);
 8228114:	00800104 	movi	r2,4
 8228118:	00000106 	br	8228120 <bsd_i_sockoptlen+0x12c>
   default:
      /* we don't know what type these options are */
      return 0;
 822811c:	0005883a 	mov	r2,zero
   }
   
}
 8228120:	e037883a 	mov	sp,fp
 8228124:	df000017 	ldw	fp,0(sp)
 8228128:	dec00104 	addi	sp,sp,4
 822812c:	f800283a 	ret

08228130 <bsd_getsockopt>:
int
bsd_getsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int * optlen)
{
 8228130:	defff504 	addi	sp,sp,-44
 8228134:	dfc00a15 	stw	ra,40(sp)
 8228138:	df000915 	stw	fp,36(sp)
 822813c:	df000904 	addi	fp,sp,36
 8228140:	e13ffc15 	stw	r4,-16(fp)
 8228144:	e17ffd15 	stw	r5,-12(fp)
 8228148:	e1bffe15 	stw	r6,-8(fp)
 822814c:	e1ffff15 	stw	r7,-4(fp)
   struct socket * so;
   int loptlen;
   int e;

   so = LONG2SO(s);
 8228150:	e0bffc17 	ldw	r2,-16(fp)
 8228154:	10bff804 	addi	r2,r2,-32
 8228158:	1085883a 	add	r2,r2,r2
 822815c:	1085883a 	add	r2,r2,r2
 8228160:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 8228164:	008209b4 	movhi	r2,2086
 8228168:	10b95804 	addi	r2,r2,-6816
 822816c:	e0bff815 	stw	r2,-32(fp)
 8228170:	00000606 	br	822818c <bsd_getsockopt+0x5c>
 8228174:	e0fff817 	ldw	r3,-32(fp)
 8228178:	e0bff917 	ldw	r2,-28(fp)
 822817c:	18800626 	beq	r3,r2,8228198 <bsd_getsockopt+0x68>
 8228180:	e0bff817 	ldw	r2,-32(fp)
 8228184:	10800017 	ldw	r2,0(r2)
 8228188:	e0bff815 	stw	r2,-32(fp)
 822818c:	e0bff817 	ldw	r2,-32(fp)
 8228190:	103ff81e 	bne	r2,zero,8228174 <bsd_getsockopt+0x44>
 8228194:	00000106 	br	822819c <bsd_getsockopt+0x6c>
 8228198:	0001883a 	nop
 822819c:	e0fff817 	ldw	r3,-32(fp)
 82281a0:	e0bff917 	ldw	r2,-28(fp)
 82281a4:	18800326 	beq	r3,r2,82281b4 <bsd_getsockopt+0x84>
 82281a8:	822d5940 	call	822d594 <dtrap>
 82281ac:	00bfffc4 	movi	r2,-1
 82281b0:	00001d06 	br	8228228 <bsd_getsockopt+0xf8>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   loptlen = bsd_i_sockoptlen(level, name);
 82281b4:	e17ffe17 	ldw	r5,-8(fp)
 82281b8:	e13ffd17 	ldw	r4,-12(fp)
 82281bc:	8227ff40 	call	8227ff4 <bsd_i_sockoptlen>
 82281c0:	e0bffa15 	stw	r2,-24(fp)
   if ((optlen == NULL) || (*optlen < loptlen))
 82281c4:	e0800217 	ldw	r2,8(fp)
 82281c8:	10000426 	beq	r2,zero,82281dc <bsd_getsockopt+0xac>
 82281cc:	e0800217 	ldw	r2,8(fp)
 82281d0:	10c00017 	ldw	r3,0(r2)
 82281d4:	e0bffa17 	ldw	r2,-24(fp)
 82281d8:	1880050e 	bge	r3,r2,82281f0 <bsd_getsockopt+0xc0>
   {
      so->so_error = EFAULT;
 82281dc:	e0bff917 	ldw	r2,-28(fp)
 82281e0:	00c00384 	movi	r3,14
 82281e4:	10c00615 	stw	r3,24(r2)
      return -1;
 82281e8:	00bfffc4 	movi	r2,-1
 82281ec:	00000e06 	br	8228228 <bsd_getsockopt+0xf8>
   }

   e = t_getsockopt(s, level, name, opt, loptlen);
 82281f0:	e0bffa17 	ldw	r2,-24(fp)
 82281f4:	d8800015 	stw	r2,0(sp)
 82281f8:	e1ffff17 	ldw	r7,-4(fp)
 82281fc:	e1bffe17 	ldw	r6,-8(fp)
 8228200:	e17ffd17 	ldw	r5,-12(fp)
 8228204:	e13ffc17 	ldw	r4,-16(fp)
 8228208:	8230fd00 	call	8230fd0 <t_getsockopt>
 822820c:	e0bffb15 	stw	r2,-20(fp)

   /* if it worked, copy the option length back for the caller's use */
   if (e == 0)
 8228210:	e0bffb17 	ldw	r2,-20(fp)
 8228214:	1000031e 	bne	r2,zero,8228224 <bsd_getsockopt+0xf4>
   {
      *optlen = loptlen;
 8228218:	e0800217 	ldw	r2,8(fp)
 822821c:	e0fffa17 	ldw	r3,-24(fp)
 8228220:	10c00015 	stw	r3,0(r2)
   }

   return e;
 8228224:	e0bffb17 	ldw	r2,-20(fp)
   
}
 8228228:	e037883a 	mov	sp,fp
 822822c:	dfc00117 	ldw	ra,4(sp)
 8228230:	df000017 	ldw	fp,0(sp)
 8228234:	dec00204 	addi	sp,sp,8
 8228238:	f800283a 	ret

0822823c <bsd_ioctl>:
 *          available via bsd_errno(s).
 */
int
bsd_ioctl(BSD_SOCKET s, 
          unsigned long request, ...)
{
 822823c:	defff504 	addi	sp,sp,-44
 8228240:	dfc00815 	stw	ra,32(sp)
 8228244:	df000715 	stw	fp,28(sp)
 8228248:	df000704 	addi	fp,sp,28
 822824c:	e13ffe15 	stw	r4,-8(fp)
 8228250:	e17fff15 	stw	r5,-4(fp)
 8228254:	e1800215 	stw	r6,8(fp)
 8228258:	e1c00315 	stw	r7,12(fp)
   struct socket * so;
   va_list argptr;
   int iarg;

   so = LONG2SO(s);
 822825c:	e0bffe17 	ldw	r2,-8(fp)
 8228260:	10bff804 	addi	r2,r2,-32
 8228264:	1085883a 	add	r2,r2,r2
 8228268:	1085883a 	add	r2,r2,r2
 822826c:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 8228270:	008209b4 	movhi	r2,2086
 8228274:	10b95804 	addi	r2,r2,-6816
 8228278:	e0bffa15 	stw	r2,-24(fp)
 822827c:	00000606 	br	8228298 <bsd_ioctl+0x5c>
 8228280:	e0fffa17 	ldw	r3,-24(fp)
 8228284:	e0bffb17 	ldw	r2,-20(fp)
 8228288:	18800626 	beq	r3,r2,82282a4 <bsd_ioctl+0x68>
 822828c:	e0bffa17 	ldw	r2,-24(fp)
 8228290:	10800017 	ldw	r2,0(r2)
 8228294:	e0bffa15 	stw	r2,-24(fp)
 8228298:	e0bffa17 	ldw	r2,-24(fp)
 822829c:	103ff81e 	bne	r2,zero,8228280 <bsd_ioctl+0x44>
 82282a0:	00000106 	br	82282a8 <bsd_ioctl+0x6c>
 82282a4:	0001883a 	nop
 82282a8:	e0fffa17 	ldw	r3,-24(fp)
 82282ac:	e0bffb17 	ldw	r2,-20(fp)
 82282b0:	18800326 	beq	r3,r2,82282c0 <bsd_ioctl+0x84>
 82282b4:	822d5940 	call	822d594 <dtrap>
 82282b8:	00bfffc4 	movi	r2,-1
 82282bc:	00001706 	br	822831c <bsd_ioctl+0xe0>

   va_start(argptr, request);
 82282c0:	e0800204 	addi	r2,fp,8
 82282c4:	e0bffc15 	stw	r2,-16(fp)

   switch (request)
 82282c8:	e0bfff17 	ldw	r2,-4(fp)
 82282cc:	108405a0 	cmpeqi	r2,r2,4118
 82282d0:	10000e26 	beq	r2,zero,822830c <bsd_ioctl+0xd0>
   {
   case FIONBIO:
      iarg = va_arg(argptr, int);
 82282d4:	e0bffc17 	ldw	r2,-16(fp)
 82282d8:	10c00104 	addi	r3,r2,4
 82282dc:	e0fffc15 	stw	r3,-16(fp)
 82282e0:	10800017 	ldw	r2,0(r2)
 82282e4:	e0bffd15 	stw	r2,-12(fp)
      va_end(argptr);
      return t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, &iarg, sizeof(iarg));
 82282e8:	e0fffd04 	addi	r3,fp,-12
 82282ec:	00800104 	movi	r2,4
 82282f0:	d8800015 	stw	r2,0(sp)
 82282f4:	180f883a 	mov	r7,r3
 82282f8:	01840584 	movi	r6,4118
 82282fc:	017fffc4 	movi	r5,-1
 8228300:	e13ffe17 	ldw	r4,-8(fp)
 8228304:	8230e100 	call	8230e10 <t_setsockopt>
 8228308:	00000406 	br	822831c <bsd_ioctl+0xe0>
   default:
      so->so_error = EINVAL;
 822830c:	e0bffb17 	ldw	r2,-20(fp)
 8228310:	00c00584 	movi	r3,22
 8228314:	10c00615 	stw	r3,24(r2)
      return -1;
 8228318:	00bfffc4 	movi	r2,-1
   }
}
 822831c:	e037883a 	mov	sp,fp
 8228320:	dfc00117 	ldw	ra,4(sp)
 8228324:	df000017 	ldw	fp,0(sp)
 8228328:	dec00404 	addi	sp,sp,16
 822832c:	f800283a 	ret

08228330 <bsd_inet_ntoa>:
 * RETURNS: pointer to null-terminated string containing dotted-decimal
 *          printable representation of in
 */
char *
bsd_inet_ntoa(struct in_addr in)
{
 8228330:	defffd04 	addi	sp,sp,-12
 8228334:	dfc00215 	stw	ra,8(sp)
 8228338:	df000115 	stw	fp,4(sp)
 822833c:	df000104 	addi	fp,sp,4
 8228340:	e13fff15 	stw	r4,-4(fp)
   return print_ipad(in.s_addr);
 8228344:	e0bfff17 	ldw	r2,-4(fp)
 8228348:	1009883a 	mov	r4,r2
 822834c:	82289f40 	call	82289f4 <print_ipad>
}
 8228350:	e037883a 	mov	sp,fp
 8228354:	dfc00117 	ldw	ra,4(sp)
 8228358:	df000017 	ldw	fp,0(sp)
 822835c:	dec00204 	addi	sp,sp,8
 8228360:	f800283a 	ret

08228364 <bsd_recvfrom>:
bsd_recvfrom(BSD_SOCKET s,
             void * buf,
             BSD_SIZE_T len,
             int flags,
             struct sockaddr * from, int * fromlen)
{
 8228364:	defff004 	addi	sp,sp,-64
 8228368:	dfc00f15 	stw	ra,60(sp)
 822836c:	df000e15 	stw	fp,56(sp)
 8228370:	df000e04 	addi	fp,sp,56
 8228374:	e13ffc15 	stw	r4,-16(fp)
 8228378:	e17ffd15 	stw	r5,-12(fp)
 822837c:	e1bffe15 	stw	r6,-8(fp)
 8228380:	e1ffff15 	stw	r7,-4(fp)
   struct socket * so;
   struct sockaddr lfrom;
   int lfromlen = 0;
 8228384:	e03ffb15 	stw	zero,-20(fp)
   int lret;

   so = LONG2SO(s);
 8228388:	e0bffc17 	ldw	r2,-16(fp)
 822838c:	10bff804 	addi	r2,r2,-32
 8228390:	1085883a 	add	r2,r2,r2
 8228394:	1085883a 	add	r2,r2,r2
 8228398:	e0bff515 	stw	r2,-44(fp)
   SOC_CHECK(so);
 822839c:	008209b4 	movhi	r2,2086
 82283a0:	10b95804 	addi	r2,r2,-6816
 82283a4:	e0bff415 	stw	r2,-48(fp)
 82283a8:	00000606 	br	82283c4 <bsd_recvfrom+0x60>
 82283ac:	e0fff417 	ldw	r3,-48(fp)
 82283b0:	e0bff517 	ldw	r2,-44(fp)
 82283b4:	18800626 	beq	r3,r2,82283d0 <bsd_recvfrom+0x6c>
 82283b8:	e0bff417 	ldw	r2,-48(fp)
 82283bc:	10800017 	ldw	r2,0(r2)
 82283c0:	e0bff415 	stw	r2,-48(fp)
 82283c4:	e0bff417 	ldw	r2,-48(fp)
 82283c8:	103ff81e 	bne	r2,zero,82283ac <bsd_recvfrom+0x48>
 82283cc:	00000106 	br	82283d4 <bsd_recvfrom+0x70>
 82283d0:	0001883a 	nop
 82283d4:	e0fff417 	ldw	r3,-48(fp)
 82283d8:	e0bff517 	ldw	r2,-44(fp)
 82283dc:	18800326 	beq	r3,r2,82283ec <bsd_recvfrom+0x88>
 82283e0:	822d5940 	call	822d594 <dtrap>
 82283e4:	00bfffc4 	movi	r2,-1
 82283e8:	00002b06 	br	8228498 <bsd_recvfrom+0x134>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (from != NULL)
 82283ec:	e0800217 	ldw	r2,8(fp)
 82283f0:	10000a26 	beq	r2,zero,822841c <bsd_recvfrom+0xb8>
   {
      if (fromlen == NULL)
 82283f4:	e0800317 	ldw	r2,12(fp)
 82283f8:	1000051e 	bne	r2,zero,8228410 <bsd_recvfrom+0xac>
      {
         so->so_error = EFAULT;
 82283fc:	e0bff517 	ldw	r2,-44(fp)
 8228400:	00c00384 	movi	r3,14
 8228404:	10c00615 	stw	r3,24(r2)
         return -1;
 8228408:	00bfffc4 	movi	r2,-1
 822840c:	00002206 	br	8228498 <bsd_recvfrom+0x134>
      }
      lfromlen = *fromlen;
 8228410:	e0800317 	ldw	r2,12(fp)
 8228414:	10800017 	ldw	r2,0(r2)
 8228418:	e0bffb15 	stw	r2,-20(fp)
   }

   lret = t_recvfrom(s, (char *)buf, len, flags, &lfrom, &lfromlen );
 822841c:	e0bffb04 	addi	r2,fp,-20
 8228420:	d8800115 	stw	r2,4(sp)
 8228424:	e0bff704 	addi	r2,fp,-36
 8228428:	d8800015 	stw	r2,0(sp)
 822842c:	e1ffff17 	ldw	r7,-4(fp)
 8228430:	e1bffe17 	ldw	r6,-8(fp)
 8228434:	e17ffd17 	ldw	r5,-12(fp)
 8228438:	e13ffc17 	ldw	r4,-16(fp)
 822843c:	823123c0 	call	823123c <t_recvfrom>
 8228440:	e0bff615 	stw	r2,-40(fp)
    * sockaddr_in), which is all that t_recvfrom() can return as a peer
    * name.
    * For IPV6 addresses or dual IPV4/IPV6 stack, the max size copied
    * is sizeof(struct sockaddr_in6)
    */
   if ((lret != -1) && (from != NULL))
 8228444:	e0bff617 	ldw	r2,-40(fp)
 8228448:	10bfffe0 	cmpeqi	r2,r2,-1
 822844c:	1000111e 	bne	r2,zero,8228494 <bsd_recvfrom+0x130>
 8228450:	e0800217 	ldw	r2,8(fp)
 8228454:	10000f26 	beq	r2,zero,8228494 <bsd_recvfrom+0x130>
   {
#ifndef IP_V6
      if (lfromlen > sizeof(struct sockaddr_in))
 8228458:	e0bffb17 	ldw	r2,-20(fp)
 822845c:	10800470 	cmpltui	r2,r2,17
 8228460:	1000021e 	bne	r2,zero,822846c <bsd_recvfrom+0x108>
         lfromlen = sizeof(struct sockaddr_in);
 8228464:	00800404 	movi	r2,16
 8228468:	e0bffb15 	stw	r2,-20(fp)
#else
      if (lfromlen > sizeof(struct sockaddr_in6))
         lfromlen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(from, &lfrom, lfromlen);
 822846c:	e0bffb17 	ldw	r2,-20(fp)
 8228470:	1007883a 	mov	r3,r2
 8228474:	e0bff704 	addi	r2,fp,-36
 8228478:	180d883a 	mov	r6,r3
 822847c:	100b883a 	mov	r5,r2
 8228480:	e1000217 	ldw	r4,8(fp)
 8228484:	8202f100 	call	8202f10 <memcpy>
      *fromlen = lfromlen;
 8228488:	e0fffb17 	ldw	r3,-20(fp)
 822848c:	e0800317 	ldw	r2,12(fp)
 8228490:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 8228494:	e0bff617 	ldw	r2,-40(fp)
}
 8228498:	e037883a 	mov	sp,fp
 822849c:	dfc00117 	ldw	ra,4(sp)
 82284a0:	df000017 	ldw	fp,0(sp)
 82284a4:	dec00204 	addi	sp,sp,8
 82284a8:	f800283a 	ret

082284ac <bsd_select>:
bsd_select(int nfds,
           fd_set * readfds,
           fd_set * writefds,
           fd_set * exceptfds,
           BSD_TIMEVAL_T * timeout)
{
 82284ac:	defff804 	addi	sp,sp,-32
 82284b0:	dfc00715 	stw	ra,28(sp)
 82284b4:	df000615 	stw	fp,24(sp)
 82284b8:	df000604 	addi	fp,sp,24
 82284bc:	e13ffc15 	stw	r4,-16(fp)
 82284c0:	e17ffd15 	stw	r5,-12(fp)
 82284c4:	e1bffe15 	stw	r6,-8(fp)
 82284c8:	e1ffff15 	stw	r7,-4(fp)
   long ltv;    /* timeout expressed in ticks */
   long tps;    /* local copy of TPS */

   USE_ARG(nfds);

   if (timeout != NULL)
 82284cc:	e0800217 	ldw	r2,8(fp)
 82284d0:	10004b26 	beq	r2,zero,8228600 <bsd_select+0x154>
       * million (i.e. any number of microseconds up to one second).
       * So we scale tv_usec from microseconds to something reasonable
       * based on TPS, multiply it by TPS, then scale it the rest of
       * the way to ticks-per-second.
       */
      tps = TPS;
 82284d4:	00801904 	movi	r2,100
 82284d8:	e0bffb15 	stw	r2,-20(fp)
      if (tps >= 1000)
 82284dc:	e0bffb17 	ldw	r2,-20(fp)
 82284e0:	1080fa10 	cmplti	r2,r2,1000
 82284e4:	10000e1e 	bne	r2,zero,8228520 <bsd_select+0x74>
      {
         ltv = (((timeout->tv_usec + 50) / 100) * tps) / 10000;
 82284e8:	e0800217 	ldw	r2,8(fp)
 82284ec:	10800117 	ldw	r2,4(r2)
 82284f0:	10800c84 	addi	r2,r2,50
 82284f4:	01401904 	movi	r5,100
 82284f8:	1009883a 	mov	r4,r2
 82284fc:	8202b180 	call	8202b18 <__divsi3>
 8228500:	1007883a 	mov	r3,r2
 8228504:	e0bffb17 	ldw	r2,-20(fp)
 8228508:	1885383a 	mul	r2,r3,r2
 822850c:	0149c404 	movi	r5,10000
 8228510:	1009883a 	mov	r4,r2
 8228514:	8202b180 	call	8202b18 <__divsi3>
 8228518:	e0bffa15 	stw	r2,-24(fp)
 822851c:	00003106 	br	82285e4 <bsd_select+0x138>
      }
      else if (tps >= 100)
 8228520:	e0bffb17 	ldw	r2,-20(fp)
 8228524:	10801910 	cmplti	r2,r2,100
 8228528:	10000e1e 	bne	r2,zero,8228564 <bsd_select+0xb8>
      {
         ltv = (((timeout->tv_usec + 500) / 1000) * tps) / 1000;
 822852c:	e0800217 	ldw	r2,8(fp)
 8228530:	10800117 	ldw	r2,4(r2)
 8228534:	10807d04 	addi	r2,r2,500
 8228538:	0140fa04 	movi	r5,1000
 822853c:	1009883a 	mov	r4,r2
 8228540:	8202b180 	call	8202b18 <__divsi3>
 8228544:	1007883a 	mov	r3,r2
 8228548:	e0bffb17 	ldw	r2,-20(fp)
 822854c:	1885383a 	mul	r2,r3,r2
 8228550:	0140fa04 	movi	r5,1000
 8228554:	1009883a 	mov	r4,r2
 8228558:	8202b180 	call	8202b18 <__divsi3>
 822855c:	e0bffa15 	stw	r2,-24(fp)
 8228560:	00002006 	br	82285e4 <bsd_select+0x138>
      }
      else if (tps >= 10)
 8228564:	e0bffb17 	ldw	r2,-20(fp)
 8228568:	10800290 	cmplti	r2,r2,10
 822856c:	10000e1e 	bne	r2,zero,82285a8 <bsd_select+0xfc>
      {
         ltv = (((timeout->tv_usec + 5000) / 10000) * tps) / 100;
 8228570:	e0800217 	ldw	r2,8(fp)
 8228574:	10800117 	ldw	r2,4(r2)
 8228578:	1084e204 	addi	r2,r2,5000
 822857c:	0149c404 	movi	r5,10000
 8228580:	1009883a 	mov	r4,r2
 8228584:	8202b180 	call	8202b18 <__divsi3>
 8228588:	1007883a 	mov	r3,r2
 822858c:	e0bffb17 	ldw	r2,-20(fp)
 8228590:	1885383a 	mul	r2,r3,r2
 8228594:	01401904 	movi	r5,100
 8228598:	1009883a 	mov	r4,r2
 822859c:	8202b180 	call	8202b18 <__divsi3>
 82285a0:	e0bffa15 	stw	r2,-24(fp)
 82285a4:	00000f06 	br	82285e4 <bsd_select+0x138>
      }
      else
      {
         ltv = (((timeout->tv_usec + 50000) / 100000) * tps) / 10;
 82285a8:	e0800217 	ldw	r2,8(fp)
 82285ac:	10c00117 	ldw	r3,4(r2)
 82285b0:	00b0d414 	movui	r2,50000
 82285b4:	1885883a 	add	r2,r3,r2
 82285b8:	014000b4 	movhi	r5,2
 82285bc:	2961a804 	addi	r5,r5,-31072
 82285c0:	1009883a 	mov	r4,r2
 82285c4:	8202b180 	call	8202b18 <__divsi3>
 82285c8:	1007883a 	mov	r3,r2
 82285cc:	e0bffb17 	ldw	r2,-20(fp)
 82285d0:	1885383a 	mul	r2,r3,r2
 82285d4:	01400284 	movi	r5,10
 82285d8:	1009883a 	mov	r4,r2
 82285dc:	8202b180 	call	8202b18 <__divsi3>
 82285e0:	e0bffa15 	stw	r2,-24(fp)
      }
      ltv += (timeout->tv_sec * TPS);
 82285e4:	e0800217 	ldw	r2,8(fp)
 82285e8:	10800017 	ldw	r2,0(r2)
 82285ec:	10801924 	muli	r2,r2,100
 82285f0:	e0fffa17 	ldw	r3,-24(fp)
 82285f4:	1885883a 	add	r2,r3,r2
 82285f8:	e0bffa15 	stw	r2,-24(fp)
 82285fc:	00000206 	br	8228608 <bsd_select+0x15c>
   }
   else {
      /*
       * NULL timeout: wait indefinitely in t_select()
       */
      ltv = -1;
 8228600:	00bfffc4 	movi	r2,-1
 8228604:	e0bffa15 	stw	r2,-24(fp)
   }

   return (t_select(readfds, writefds, exceptfds, ltv));
 8228608:	e1fffa17 	ldw	r7,-24(fp)
 822860c:	e1bfff17 	ldw	r6,-4(fp)
 8228610:	e17ffe17 	ldw	r5,-8(fp)
 8228614:	e13ffd17 	ldw	r4,-12(fp)
 8228618:	8234cf40 	call	8234cf4 <t_select>
}
 822861c:	e037883a 	mov	sp,fp
 8228620:	dfc00117 	ldw	ra,4(sp)
 8228624:	df000017 	ldw	fp,0(sp)
 8228628:	dec00204 	addi	sp,sp,8
 822862c:	f800283a 	ret

08228630 <bsd_setsockopt>:
int 
bsd_setsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int optlen)
{
 8228630:	defff704 	addi	sp,sp,-36
 8228634:	dfc00815 	stw	ra,32(sp)
 8228638:	df000715 	stw	fp,28(sp)
 822863c:	df000704 	addi	fp,sp,28
 8228640:	e13ffc15 	stw	r4,-16(fp)
 8228644:	e17ffd15 	stw	r5,-12(fp)
 8228648:	e1bffe15 	stw	r6,-8(fp)
 822864c:	e1ffff15 	stw	r7,-4(fp)
   struct socket * so;

   so = LONG2SO(s);
 8228650:	e0bffc17 	ldw	r2,-16(fp)
 8228654:	10bff804 	addi	r2,r2,-32
 8228658:	1085883a 	add	r2,r2,r2
 822865c:	1085883a 	add	r2,r2,r2
 8228660:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 8228664:	008209b4 	movhi	r2,2086
 8228668:	10b95804 	addi	r2,r2,-6816
 822866c:	e0bffa15 	stw	r2,-24(fp)
 8228670:	00000606 	br	822868c <bsd_setsockopt+0x5c>
 8228674:	e0fffa17 	ldw	r3,-24(fp)
 8228678:	e0bffb17 	ldw	r2,-20(fp)
 822867c:	18800626 	beq	r3,r2,8228698 <bsd_setsockopt+0x68>
 8228680:	e0bffa17 	ldw	r2,-24(fp)
 8228684:	10800017 	ldw	r2,0(r2)
 8228688:	e0bffa15 	stw	r2,-24(fp)
 822868c:	e0bffa17 	ldw	r2,-24(fp)
 8228690:	103ff81e 	bne	r2,zero,8228674 <bsd_setsockopt+0x44>
 8228694:	00000106 	br	822869c <bsd_setsockopt+0x6c>
 8228698:	0001883a 	nop
 822869c:	e0fffa17 	ldw	r3,-24(fp)
 82286a0:	e0bffb17 	ldw	r2,-20(fp)
 82286a4:	18800326 	beq	r3,r2,82286b4 <bsd_setsockopt+0x84>
 82286a8:	822d5940 	call	822d594 <dtrap>
 82286ac:	00bfffc4 	movi	r2,-1
 82286b0:	00001206 	br	82286fc <bsd_setsockopt+0xcc>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   if (optlen < bsd_i_sockoptlen(level, name))
 82286b4:	e17ffe17 	ldw	r5,-8(fp)
 82286b8:	e13ffd17 	ldw	r4,-12(fp)
 82286bc:	8227ff40 	call	8227ff4 <bsd_i_sockoptlen>
 82286c0:	1007883a 	mov	r3,r2
 82286c4:	e0800217 	ldw	r2,8(fp)
 82286c8:	10c0050e 	bge	r2,r3,82286e0 <bsd_setsockopt+0xb0>
   {
      so->so_error = EFAULT;
 82286cc:	e0bffb17 	ldw	r2,-20(fp)
 82286d0:	00c00384 	movi	r3,14
 82286d4:	10c00615 	stw	r3,24(r2)
      return -1;
 82286d8:	00bfffc4 	movi	r2,-1
 82286dc:	00000706 	br	82286fc <bsd_setsockopt+0xcc>
   }

   return t_setsockopt(s, level, name, opt, optlen);
 82286e0:	e0800217 	ldw	r2,8(fp)
 82286e4:	d8800015 	stw	r2,0(sp)
 82286e8:	e1ffff17 	ldw	r7,-4(fp)
 82286ec:	e1bffe17 	ldw	r6,-8(fp)
 82286f0:	e17ffd17 	ldw	r5,-12(fp)
 82286f4:	e13ffc17 	ldw	r4,-16(fp)
 82286f8:	8230e100 	call	8230e10 <t_setsockopt>
}
 82286fc:	e037883a 	mov	sp,fp
 8228700:	dfc00117 	ldw	ra,4(sp)
 8228704:	df000017 	ldw	fp,0(sp)
 8228708:	dec00204 	addi	sp,sp,8
 822870c:	f800283a 	ret

08228710 <ccksum>:
 * be done in 16-bit chunks.
 */

unsigned short
ccksum (void *ptr, unsigned words)
{
 8228710:	defffa04 	addi	sp,sp,-24
 8228714:	df000515 	stw	fp,20(sp)
 8228718:	df000504 	addi	fp,sp,20
 822871c:	e13ffe15 	stw	r4,-8(fp)
 8228720:	e17fff15 	stw	r5,-4(fp)
   unsigned short *addr = (unsigned short *)ptr;
 8228724:	e0bffe17 	ldw	r2,-8(fp)
 8228728:	e0bffb15 	stw	r2,-20(fp)
   unsigned long sum = 0;
 822872c:	e03ffc15 	stw	zero,-16(fp)
   int count = (int)words;
 8228730:	e0bfff17 	ldw	r2,-4(fp)
 8228734:	e0bffd15 	stw	r2,-12(fp)

   while (--count >= 0)
 8228738:	00000806 	br	822875c <ccksum+0x4c>
   {
      /*  This is the inner loop */
      sum += *addr++;
 822873c:	e0bffb17 	ldw	r2,-20(fp)
 8228740:	10c00084 	addi	r3,r2,2
 8228744:	e0fffb15 	stw	r3,-20(fp)
 8228748:	1080000b 	ldhu	r2,0(r2)
 822874c:	10bfffcc 	andi	r2,r2,65535
 8228750:	e0fffc17 	ldw	r3,-16(fp)
 8228754:	1885883a 	add	r2,r3,r2
 8228758:	e0bffc15 	stw	r2,-16(fp)
{
   unsigned short *addr = (unsigned short *)ptr;
   unsigned long sum = 0;
   int count = (int)words;

   while (--count >= 0)
 822875c:	e0bffd17 	ldw	r2,-12(fp)
 8228760:	10bfffc4 	addi	r2,r2,-1
 8228764:	e0bffd15 	stw	r2,-12(fp)
 8228768:	e0bffd17 	ldw	r2,-12(fp)
 822876c:	103ff30e 	bge	r2,zero,822873c <ccksum+0x2c>
      /*  This is the inner loop */
      sum += *addr++;
   }

   /*  Fold 32-bit sum to 16 bits */
   sum = (sum & 0xffff) + (sum >> 16);
 8228770:	e0bffc17 	ldw	r2,-16(fp)
 8228774:	10ffffcc 	andi	r3,r2,65535
 8228778:	e0bffc17 	ldw	r2,-16(fp)
 822877c:	1004d43a 	srli	r2,r2,16
 8228780:	1885883a 	add	r2,r3,r2
 8228784:	e0bffc15 	stw	r2,-16(fp)
   sum = (sum & 0xffff) + (sum >> 16);
 8228788:	e0bffc17 	ldw	r2,-16(fp)
 822878c:	10ffffcc 	andi	r3,r2,65535
 8228790:	e0bffc17 	ldw	r2,-16(fp)
 8228794:	1004d43a 	srli	r2,r2,16
 8228798:	1885883a 	add	r2,r3,r2
 822879c:	e0bffc15 	stw	r2,-16(fp)

   /* checksum = ~sum; *//* removed for MIT IP stack */
   return ((unsigned short)sum);
 82287a0:	e0bffc17 	ldw	r2,-16(fp)
}
 82287a4:	e037883a 	mov	sp,fp
 82287a8:	df000017 	ldw	fp,0(sp)
 82287ac:	dec00104 	addi	sp,sp,4
 82287b0:	f800283a 	ret

082287b4 <cksum>:
 *    3 = user-supplied alternate implementation
 */

unsigned short
cksum (void *ptr, unsigned count)
{
 82287b4:	defffc04 	addi	sp,sp,-16
 82287b8:	dfc00315 	stw	ra,12(sp)
 82287bc:	df000215 	stw	fp,8(sp)
 82287c0:	df000204 	addi	fp,sp,8
 82287c4:	e13ffe15 	stw	r4,-8(fp)
 82287c8:	e17fff15 	stw	r5,-4(fp)
   switch (cksum_select)
 82287cc:	d0a03117 	ldw	r2,-32572(gp)
 82287d0:	108000a0 	cmpeqi	r2,r2,2
 82287d4:	1000041e 	bne	r2,zero,82287e8 <cksum+0x34>
   {
      case 1:
      default:
         return (ccksum(ptr, count));
 82287d8:	e17fff17 	ldw	r5,-4(fp)
 82287dc:	e13ffe17 	ldw	r4,-8(fp)
 82287e0:	82287100 	call	8228710 <ccksum>
 82287e4:	00000306 	br	82287f4 <cksum+0x40>
 #ifndef C_CHECKSUM
      case 2:
         return (asm_cksum(ptr, count));
 82287e8:	e17fff17 	ldw	r5,-4(fp)
 82287ec:	e13ffe17 	ldw	r4,-8(fp)
 82287f0:	822d4000 	call	822d400 <asm_cksum>
#else
#endif
         return (alt_cksum(ptr, count));
#endif
   }
}
 82287f4:	e037883a 	mov	sp,fp
 82287f8:	dfc00117 	ldw	ra,4(sp)
 82287fc:	df000017 	ldw	fp,0(sp)
 8228800:	dec00204 	addi	sp,sp,8
 8228804:	f800283a 	ret

08228808 <do_trap>:
 * RETURNS: 0
 */

int
do_trap(void)
{
 8228808:	defffe04 	addi	sp,sp,-8
 822880c:	dfc00115 	stw	ra,4(sp)
 8228810:	df000015 	stw	fp,0(sp)
 8228814:	d839883a 	mov	fp,sp
   dtrap();
 8228818:	822d5940 	call	822d594 <dtrap>
   return 0;
 822881c:	0005883a 	mov	r2,zero
}
 8228820:	e037883a 	mov	sp,fp
 8228824:	dfc00117 	ldw	ra,4(sp)
 8228828:	df000017 	ldw	fp,0(sp)
 822882c:	dec00204 	addi	sp,sp,8
 8228830:	f800283a 	ret

08228834 <nextarg>:
 * RETURNS:  pointer to next arg in string 
 */

char *   
nextarg(char * argp)
{
 8228834:	defffe04 	addi	sp,sp,-8
 8228838:	df000115 	stw	fp,4(sp)
 822883c:	df000104 	addi	fp,sp,4
 8228840:	e13fff15 	stw	r4,-4(fp)
   while (*argp > ' ')argp++; /* scan past current arg */
 8228844:	00000306 	br	8228854 <nextarg+0x20>
 8228848:	e0bfff17 	ldw	r2,-4(fp)
 822884c:	10800044 	addi	r2,r2,1
 8228850:	e0bfff15 	stw	r2,-4(fp)
 8228854:	e0bfff17 	ldw	r2,-4(fp)
 8228858:	10800003 	ldbu	r2,0(r2)
 822885c:	10803fcc 	andi	r2,r2,255
 8228860:	1080201c 	xori	r2,r2,128
 8228864:	10bfe004 	addi	r2,r2,-128
 8228868:	10800848 	cmpgei	r2,r2,33
 822886c:	103ff61e 	bne	r2,zero,8228848 <nextarg+0x14>
      while (*argp == ' ')argp++;   /* scan past spaces */
 8228870:	00000306 	br	8228880 <nextarg+0x4c>
 8228874:	e0bfff17 	ldw	r2,-4(fp)
 8228878:	10800044 	addi	r2,r2,1
 822887c:	e0bfff15 	stw	r2,-4(fp)
 8228880:	e0bfff17 	ldw	r2,-4(fp)
 8228884:	10800003 	ldbu	r2,0(r2)
 8228888:	10803fcc 	andi	r2,r2,255
 822888c:	1080201c 	xori	r2,r2,128
 8228890:	10bfe004 	addi	r2,r2,-128
 8228894:	10800820 	cmpeqi	r2,r2,32
 8228898:	103ff61e 	bne	r2,zero,8228874 <nextarg+0x40>
      return (argp);
 822889c:	e0bfff17 	ldw	r2,-4(fp)
}
 82288a0:	e037883a 	mov	sp,fp
 82288a4:	df000017 	ldw	fp,0(sp)
 82288a8:	dec00104 	addi	sp,sp,4
 82288ac:	f800283a 	ret

082288b0 <hexdump>:

#define  HEX_BYTES_PER_LINE   16

void
hexdump(void * pio, void * buffer, unsigned len)
{
 82288b0:	defff804 	addi	sp,sp,-32
 82288b4:	dfc00715 	stw	ra,28(sp)
 82288b8:	df000615 	stw	fp,24(sp)
 82288bc:	df000604 	addi	fp,sp,24
 82288c0:	e13ffd15 	stw	r4,-12(fp)
 82288c4:	e17ffe15 	stw	r5,-8(fp)
 82288c8:	e1bfff15 	stw	r6,-4(fp)
   u_char * data  =  (u_char *)buffer;
 82288cc:	e0bffe17 	ldw	r2,-8(fp)
 82288d0:	e0bffa15 	stw	r2,-24(fp)
   unsigned int count;
   char  c;

   while (len)
 82288d4:	00003f06 	br	82289d4 <hexdump+0x124>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 82288d8:	e03ffb15 	stw	zero,-20(fp)
 82288dc:	00000d06 	br	8228914 <hexdump+0x64>
         ns_printf(pio, "%02x ", *(data + count));
 82288e0:	e0fffa17 	ldw	r3,-24(fp)
 82288e4:	e0bffb17 	ldw	r2,-20(fp)
 82288e8:	1885883a 	add	r2,r3,r2
 82288ec:	10800003 	ldbu	r2,0(r2)
 82288f0:	10803fcc 	andi	r2,r2,255
 82288f4:	100d883a 	mov	r6,r2
 82288f8:	01420974 	movhi	r5,2085
 82288fc:	29417404 	addi	r5,r5,1488
 8228900:	e13ffd17 	ldw	r4,-12(fp)
 8228904:	8228e600 	call	8228e60 <ns_printf>
   char  c;

   while (len)
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 8228908:	e0bffb17 	ldw	r2,-20(fp)
 822890c:	10800044 	addi	r2,r2,1
 8228910:	e0bffb15 	stw	r2,-20(fp)
 8228914:	e0bffb17 	ldw	r2,-20(fp)
 8228918:	10800428 	cmpgeui	r2,r2,16
 822891c:	1000031e 	bne	r2,zero,822892c <hexdump+0x7c>
 8228920:	e0fffb17 	ldw	r3,-20(fp)
 8228924:	e0bfff17 	ldw	r2,-4(fp)
 8228928:	18bfed36 	bltu	r3,r2,82288e0 <hexdump+0x30>
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 822892c:	e03ffb15 	stw	zero,-20(fp)
 8228930:	00001606 	br	822898c <hexdump+0xdc>
      {
         c = *(data + count);
 8228934:	e0fffa17 	ldw	r3,-24(fp)
 8228938:	e0bffb17 	ldw	r2,-20(fp)
 822893c:	1885883a 	add	r2,r3,r2
 8228940:	10800003 	ldbu	r2,0(r2)
 8228944:	e0bffc05 	stb	r2,-16(fp)
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
 8228948:	e0bffc07 	ldb	r2,-16(fp)
 822894c:	10800810 	cmplti	r2,r2,32
 8228950:	1000051e 	bne	r2,zero,8228968 <hexdump+0xb8>
 8228954:	e0bffc07 	ldb	r2,-16(fp)
 8228958:	10801fe0 	cmpeqi	r2,r2,127
 822895c:	1000021e 	bne	r2,zero,8228968 <hexdump+0xb8>
 8228960:	e0bffc07 	ldb	r2,-16(fp)
 8228964:	00000106 	br	822896c <hexdump+0xbc>
 8228968:	00800b84 	movi	r2,46
 822896c:	100d883a 	mov	r6,r2
 8228970:	01420974 	movhi	r5,2085
 8228974:	29417604 	addi	r5,r5,1496
 8228978:	e13ffd17 	ldw	r4,-12(fp)
 822897c:	8228e600 	call	8228e60 <ns_printf>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 8228980:	e0bffb17 	ldw	r2,-20(fp)
 8228984:	10800044 	addi	r2,r2,1
 8228988:	e0bffb15 	stw	r2,-20(fp)
 822898c:	e0bffb17 	ldw	r2,-20(fp)
 8228990:	10800428 	cmpgeui	r2,r2,16
 8228994:	1000031e 	bne	r2,zero,82289a4 <hexdump+0xf4>
 8228998:	e0fffb17 	ldw	r3,-20(fp)
 822899c:	e0bfff17 	ldw	r2,-4(fp)
 82289a0:	18bfe436 	bltu	r3,r2,8228934 <hexdump+0x84>
      {
         c = *(data + count);
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
      }
      ns_printf(pio,"\n");
 82289a4:	01420974 	movhi	r5,2085
 82289a8:	29417704 	addi	r5,r5,1500
 82289ac:	e13ffd17 	ldw	r4,-12(fp)
 82289b0:	8228e600 	call	8228e60 <ns_printf>
      len -= count;
 82289b4:	e0ffff17 	ldw	r3,-4(fp)
 82289b8:	e0bffb17 	ldw	r2,-20(fp)
 82289bc:	1885c83a 	sub	r2,r3,r2
 82289c0:	e0bfff15 	stw	r2,-4(fp)
      data += count;
 82289c4:	e0fffa17 	ldw	r3,-24(fp)
 82289c8:	e0bffb17 	ldw	r2,-20(fp)
 82289cc:	1885883a 	add	r2,r3,r2
 82289d0:	e0bffa15 	stw	r2,-24(fp)
{
   u_char * data  =  (u_char *)buffer;
   unsigned int count;
   char  c;

   while (len)
 82289d4:	e0bfff17 	ldw	r2,-4(fp)
 82289d8:	103fbf1e 	bne	r2,zero,82288d8 <hexdump+0x28>
      }
      ns_printf(pio,"\n");
      len -= count;
      data += count;
   }
}
 82289dc:	0001883a 	nop
 82289e0:	e037883a 	mov	sp,fp
 82289e4:	dfc00117 	ldw	ra,4(sp)
 82289e8:	df000017 	ldw	fp,0(sp)
 82289ec:	dec00204 	addi	sp,sp,8
 82289f0:	f800283a 	ret

082289f4 <print_ipad>:

char     ipreturn[18];     /* buffer for return */

char *   
print_ipad(unsigned long ipaddr)
{
 82289f4:	defffa04 	addi	sp,sp,-24
 82289f8:	dfc00515 	stw	ra,20(sp)
 82289fc:	df000415 	stw	fp,16(sp)
 8228a00:	df000404 	addi	fp,sp,16
 8228a04:	e13fff15 	stw	r4,-4(fp)
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
 8228a08:	e0bfff17 	ldw	r2,-4(fp)
 8228a0c:	e0bffe15 	stw	r2,-8(fp)
   sprintf(ipreturn, "%u.%u.%u.%u", 
    ip.ip.ipchar[0],
 8228a10:	e0bffe03 	ldbu	r2,-8(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 8228a14:	11003fcc 	andi	r4,r2,255
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
 8228a18:	e0bffe43 	ldbu	r2,-7(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 8228a1c:	11403fcc 	andi	r5,r2,255
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
 8228a20:	e0bffe83 	ldbu	r2,-6(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 8228a24:	10803fcc 	andi	r2,r2,255
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
    ip.ip.ipchar[3]);
 8228a28:	e0fffec3 	ldbu	r3,-5(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 8228a2c:	18c03fcc 	andi	r3,r3,255
 8228a30:	d8c00115 	stw	r3,4(sp)
 8228a34:	d8800015 	stw	r2,0(sp)
 8228a38:	280f883a 	mov	r7,r5
 8228a3c:	200d883a 	mov	r6,r4
 8228a40:	01420974 	movhi	r5,2085
 8228a44:	29417804 	addi	r5,r5,1504
 8228a48:	010209b4 	movhi	r4,2086
 8228a4c:	21383c84 	addi	r4,r4,-7950
 8228a50:	82037180 	call	8203718 <sprintf>
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
    ip.ip.ipchar[3]);

   return ipreturn;
 8228a54:	008209b4 	movhi	r2,2086
 8228a58:	10b83c84 	addi	r2,r2,-7950
}
 8228a5c:	e037883a 	mov	sp,fp
 8228a60:	dfc00117 	ldw	ra,4(sp)
 8228a64:	df000017 	ldw	fp,0(sp)
 8228a68:	dec00204 	addi	sp,sp,8
 8228a6c:	f800283a 	ret

08228a70 <print_uptime>:

static char tistring[24];     /* buffer for return */

char *   
print_uptime(unsigned long timetick)
{
 8228a70:	defff004 	addi	sp,sp,-64
 8228a74:	dfc00f15 	stw	ra,60(sp)
 8228a78:	df000e15 	stw	fp,56(sp)
 8228a7c:	ddc00d15 	stw	r23,52(sp)
 8228a80:	dd800c15 	stw	r22,48(sp)
 8228a84:	dd400b15 	stw	r21,44(sp)
 8228a88:	dd000a15 	stw	r20,40(sp)
 8228a8c:	dcc00915 	stw	r19,36(sp)
 8228a90:	dc800815 	stw	r18,32(sp)
 8228a94:	dc400715 	stw	r17,28(sp)
 8228a98:	dc000615 	stw	r16,24(sp)
 8228a9c:	df000e04 	addi	fp,sp,56
 8228aa0:	e13ff715 	stw	r4,-36(fp)
   unsigned seconds, minutes, hours;

   timetick = timetick/100;   /* turn timetick into seconds */
 8228aa4:	e0fff717 	ldw	r3,-36(fp)
 8228aa8:	00947b34 	movhi	r2,20972
 8228aac:	10a147c4 	addi	r2,r2,-31457
 8228ab0:	1888383a 	mulxuu	r4,r3,r2
 8228ab4:	1885383a 	mul	r2,r3,r2
 8228ab8:	100b883a 	mov	r5,r2
 8228abc:	200d883a 	mov	r6,r4
 8228ac0:	3004d17a 	srli	r2,r6,5
 8228ac4:	e0bff715 	stw	r2,-36(fp)
   seconds = (unsigned)(timetick%60);
 8228ac8:	e0bff717 	ldw	r2,-36(fp)
 8228acc:	01400f04 	movi	r5,60
 8228ad0:	1009883a 	mov	r4,r2
 8228ad4:	8202c740 	call	8202c74 <__umodsi3>
 8228ad8:	e0bff415 	stw	r2,-48(fp)
   timetick = timetick/60;    /* turn timetick into minutes */
 8228adc:	e0fff717 	ldw	r3,-36(fp)
 8228ae0:	00a22274 	movhi	r2,34953
 8228ae4:	10a22244 	addi	r2,r2,-30583
 8228ae8:	1888383a 	mulxuu	r4,r3,r2
 8228aec:	1885383a 	mul	r2,r3,r2
 8228af0:	102d883a 	mov	r22,r2
 8228af4:	202f883a 	mov	r23,r4
 8228af8:	b804d17a 	srli	r2,r23,5
 8228afc:	e0bff715 	stw	r2,-36(fp)
   minutes = (unsigned)(timetick%60);
 8228b00:	e0fff717 	ldw	r3,-36(fp)
 8228b04:	00a22274 	movhi	r2,34953
 8228b08:	10a22244 	addi	r2,r2,-30583
 8228b0c:	1888383a 	mulxuu	r4,r3,r2
 8228b10:	1885383a 	mul	r2,r3,r2
 8228b14:	1029883a 	mov	r20,r2
 8228b18:	202b883a 	mov	r21,r4
 8228b1c:	a804d17a 	srli	r2,r21,5
 8228b20:	10800f24 	muli	r2,r2,60
 8228b24:	1885c83a 	sub	r2,r3,r2
 8228b28:	e0bff515 	stw	r2,-44(fp)
   timetick = timetick/60;    /* turn timetick into hours */
 8228b2c:	e0fff717 	ldw	r3,-36(fp)
 8228b30:	00a22274 	movhi	r2,34953
 8228b34:	10a22244 	addi	r2,r2,-30583
 8228b38:	1888383a 	mulxuu	r4,r3,r2
 8228b3c:	1885383a 	mul	r2,r3,r2
 8228b40:	1025883a 	mov	r18,r2
 8228b44:	2027883a 	mov	r19,r4
 8228b48:	9804d17a 	srli	r2,r19,5
 8228b4c:	e0bff715 	stw	r2,-36(fp)
   hours = (unsigned)(timetick%24);
 8228b50:	e0bff717 	ldw	r2,-36(fp)
 8228b54:	01400604 	movi	r5,24
 8228b58:	1009883a 	mov	r4,r2
 8228b5c:	8202c740 	call	8202c74 <__umodsi3>
 8228b60:	e0bff615 	stw	r2,-40(fp)
   timetick = timetick/24;    /* turn timetick into days */
 8228b64:	e0fff717 	ldw	r3,-36(fp)
 8228b68:	00aaaaf4 	movhi	r2,43691
 8228b6c:	10aaaac4 	addi	r2,r2,-21845
 8228b70:	1888383a 	mulxuu	r4,r3,r2
 8228b74:	1885383a 	mul	r2,r3,r2
 8228b78:	1021883a 	mov	r16,r2
 8228b7c:	2023883a 	mov	r17,r4
 8228b80:	8804d13a 	srli	r2,r17,4
 8228b84:	e0bff715 	stw	r2,-36(fp)

   if (timetick)  /* Is there a whole number of days? */
 8228b88:	e0bff717 	ldw	r2,-36(fp)
 8228b8c:	10000c26 	beq	r2,zero,8228bc0 <print_uptime+0x150>
      sprintf(tistring, "%ld days, %dh:%dm:%ds", 
 8228b90:	e0bff417 	ldw	r2,-48(fp)
 8228b94:	d8800115 	stw	r2,4(sp)
 8228b98:	e0bff517 	ldw	r2,-44(fp)
 8228b9c:	d8800015 	stw	r2,0(sp)
 8228ba0:	e1fff617 	ldw	r7,-40(fp)
 8228ba4:	e1bff717 	ldw	r6,-36(fp)
 8228ba8:	01420974 	movhi	r5,2085
 8228bac:	29417b04 	addi	r5,r5,1516
 8228bb0:	01020974 	movhi	r4,2085
 8228bb4:	21120904 	addi	r4,r4,18468
 8228bb8:	82037180 	call	8203718 <sprintf>
 8228bbc:	00001306 	br	8228c0c <print_uptime+0x19c>
    timetick, hours, minutes, seconds);
   else if (hours)
 8228bc0:	e0bff617 	ldw	r2,-40(fp)
 8228bc4:	10000a26 	beq	r2,zero,8228bf0 <print_uptime+0x180>
      sprintf(tistring, "%d hours, %dm:%ds", hours, minutes, seconds);
 8228bc8:	e0bff417 	ldw	r2,-48(fp)
 8228bcc:	d8800015 	stw	r2,0(sp)
 8228bd0:	e1fff517 	ldw	r7,-44(fp)
 8228bd4:	e1bff617 	ldw	r6,-40(fp)
 8228bd8:	01420974 	movhi	r5,2085
 8228bdc:	29418104 	addi	r5,r5,1540
 8228be0:	01020974 	movhi	r4,2085
 8228be4:	21120904 	addi	r4,r4,18468
 8228be8:	82037180 	call	8203718 <sprintf>
 8228bec:	00000706 	br	8228c0c <print_uptime+0x19c>
   else
      sprintf(tistring, "%d minutes, %d sec.", minutes, seconds);
 8228bf0:	e1fff417 	ldw	r7,-48(fp)
 8228bf4:	e1bff517 	ldw	r6,-44(fp)
 8228bf8:	01420974 	movhi	r5,2085
 8228bfc:	29418604 	addi	r5,r5,1560
 8228c00:	01020974 	movhi	r4,2085
 8228c04:	21120904 	addi	r4,r4,18468
 8228c08:	82037180 	call	8203718 <sprintf>
   return tistring;
 8228c0c:	00820974 	movhi	r2,2085
 8228c10:	10920904 	addi	r2,r2,18468
}
 8228c14:	e6fff804 	addi	sp,fp,-32
 8228c18:	dfc00917 	ldw	ra,36(sp)
 8228c1c:	df000817 	ldw	fp,32(sp)
 8228c20:	ddc00717 	ldw	r23,28(sp)
 8228c24:	dd800617 	ldw	r22,24(sp)
 8228c28:	dd400517 	ldw	r21,20(sp)
 8228c2c:	dd000417 	ldw	r20,16(sp)
 8228c30:	dcc00317 	ldw	r19,12(sp)
 8228c34:	dc800217 	ldw	r18,8(sp)
 8228c38:	dc400117 	ldw	r17,4(sp)
 8228c3c:	dc000017 	ldw	r16,0(sp)
 8228c40:	dec00a04 	addi	sp,sp,40
 8228c44:	f800283a 	ret

08228c48 <panic>:
/* allow to be ifdeffed out on systems which already have a panic */
#ifndef PANIC_ALREADY

void
panic(char * msg)
{
 8228c48:	defffd04 	addi	sp,sp,-12
 8228c4c:	dfc00215 	stw	ra,8(sp)
 8228c50:	df000115 	stw	fp,4(sp)
 8228c54:	df000104 	addi	fp,sp,4
 8228c58:	e13fff15 	stw	r4,-4(fp)
   dprintf("panic: %s\n", msg);
 8228c5c:	e17fff17 	ldw	r5,-4(fp)
 8228c60:	01020974 	movhi	r4,2085
 8228c64:	21018b04 	addi	r4,r4,1580
 8228c68:	82033a00 	call	82033a0 <printf>
   dtrap();                   /* try to hook debugger */
 8228c6c:	822d5940 	call	822d594 <dtrap>
   netexit(1);                /* try to clean up */
 8228c70:	01000044 	movi	r4,1
 8228c74:	8243c8c0 	call	8243c8c <netexit>
}
 8228c78:	0001883a 	nop
 8228c7c:	e037883a 	mov	sp,fp
 8228c80:	dfc00117 	ldw	ra,4(sp)
 8228c84:	df000017 	ldw	fp,0(sp)
 8228c88:	dec00204 	addi	sp,sp,8
 8228c8c:	f800283a 	ret

08228c90 <print_eth>:

char     eth_prt_buf[18];  /* buffer for return */

char *   
print_eth(char * addr, char spacer)
{
 8228c90:	defffb04 	addi	sp,sp,-20
 8228c94:	df000415 	stw	fp,16(sp)
 8228c98:	df000404 	addi	fp,sp,16
 8228c9c:	e13ffe15 	stw	r4,-8(fp)
 8228ca0:	2805883a 	mov	r2,r5
 8228ca4:	e0bfff05 	stb	r2,-4(fp)
   int   i;
   char *   out   =  eth_prt_buf;
 8228ca8:	008209b4 	movhi	r2,2086
 8228cac:	10b83804 	addi	r2,r2,-7968
 8228cb0:	e0bffd15 	stw	r2,-12(fp)

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 8228cb4:	e03ffc15 	stw	zero,-16(fp)
 8228cb8:	00003f06 	br	8228db8 <print_eth+0x128>
   {
      /* high nibble */
      *out = (char)(((*addr >> 4) & 0x0f) + 0x30);
 8228cbc:	e0bffe17 	ldw	r2,-8(fp)
 8228cc0:	10800003 	ldbu	r2,0(r2)
 8228cc4:	10803fcc 	andi	r2,r2,255
 8228cc8:	1004d13a 	srli	r2,r2,4
 8228ccc:	10800c04 	addi	r2,r2,48
 8228cd0:	1007883a 	mov	r3,r2
 8228cd4:	e0bffd17 	ldw	r2,-12(fp)
 8228cd8:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 8228cdc:	e0bffd17 	ldw	r2,-12(fp)
 8228ce0:	10800003 	ldbu	r2,0(r2)
 8228ce4:	10803fcc 	andi	r2,r2,255
 8228ce8:	1080201c 	xori	r2,r2,128
 8228cec:	10bfe004 	addi	r2,r2,-128
 8228cf0:	10800e90 	cmplti	r2,r2,58
 8228cf4:	1000061e 	bne	r2,zero,8228d10 <print_eth+0x80>
         (*out) += 7;
 8228cf8:	e0bffd17 	ldw	r2,-12(fp)
 8228cfc:	10800003 	ldbu	r2,0(r2)
 8228d00:	108001c4 	addi	r2,r2,7
 8228d04:	1007883a 	mov	r3,r2
 8228d08:	e0bffd17 	ldw	r2,-12(fp)
 8228d0c:	10c00005 	stb	r3,0(r2)
      out++;
 8228d10:	e0bffd17 	ldw	r2,-12(fp)
 8228d14:	10800044 	addi	r2,r2,1
 8228d18:	e0bffd15 	stw	r2,-12(fp)

      /* low nibble */
      *out = (char)((*addr & 0x0f) + 0x30);  /* low nibble to digit */
 8228d1c:	e0bffe17 	ldw	r2,-8(fp)
 8228d20:	10800003 	ldbu	r2,0(r2)
 8228d24:	108003cc 	andi	r2,r2,15
 8228d28:	10800c04 	addi	r2,r2,48
 8228d2c:	1007883a 	mov	r3,r2
 8228d30:	e0bffd17 	ldw	r2,-12(fp)
 8228d34:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 8228d38:	e0bffd17 	ldw	r2,-12(fp)
 8228d3c:	10800003 	ldbu	r2,0(r2)
 8228d40:	10803fcc 	andi	r2,r2,255
 8228d44:	1080201c 	xori	r2,r2,128
 8228d48:	10bfe004 	addi	r2,r2,-128
 8228d4c:	10800e90 	cmplti	r2,r2,58
 8228d50:	1000061e 	bne	r2,zero,8228d6c <print_eth+0xdc>
         (*out) += 7;   /* eg 0x3a -> 0x41 ('A') */
 8228d54:	e0bffd17 	ldw	r2,-12(fp)
 8228d58:	10800003 	ldbu	r2,0(r2)
 8228d5c:	108001c4 	addi	r2,r2,7
 8228d60:	1007883a 	mov	r3,r2
 8228d64:	e0bffd17 	ldw	r2,-12(fp)
 8228d68:	10c00005 	stb	r3,0(r2)
      out++;
 8228d6c:	e0bffd17 	ldw	r2,-12(fp)
 8228d70:	10800044 	addi	r2,r2,1
 8228d74:	e0bffd15 	stw	r2,-12(fp)

      /* optional spacer character */
      if (spacer && i < 5)
 8228d78:	e0bfff07 	ldb	r2,-4(fp)
 8228d7c:	10000826 	beq	r2,zero,8228da0 <print_eth+0x110>
 8228d80:	e0bffc17 	ldw	r2,-16(fp)
 8228d84:	10800148 	cmpgei	r2,r2,5
 8228d88:	1000051e 	bne	r2,zero,8228da0 <print_eth+0x110>
         *out++ = spacer;
 8228d8c:	e0bffd17 	ldw	r2,-12(fp)
 8228d90:	10c00044 	addi	r3,r2,1
 8228d94:	e0fffd15 	stw	r3,-12(fp)
 8228d98:	e0ffff03 	ldbu	r3,-4(fp)
 8228d9c:	10c00005 	stb	r3,0(r2)
      addr++;
 8228da0:	e0bffe17 	ldw	r2,-8(fp)
 8228da4:	10800044 	addi	r2,r2,1
 8228da8:	e0bffe15 	stw	r2,-8(fp)
{
   int   i;
   char *   out   =  eth_prt_buf;

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 8228dac:	e0bffc17 	ldw	r2,-16(fp)
 8228db0:	10800044 	addi	r2,r2,1
 8228db4:	e0bffc15 	stw	r2,-16(fp)
 8228db8:	e0bffc17 	ldw	r2,-16(fp)
 8228dbc:	10800190 	cmplti	r2,r2,6
 8228dc0:	103fbe1e 	bne	r2,zero,8228cbc <print_eth+0x2c>
      /* optional spacer character */
      if (spacer && i < 5)
         *out++ = spacer;
      addr++;
   }
   *out = 0;
 8228dc4:	e0bffd17 	ldw	r2,-12(fp)
 8228dc8:	10000005 	stb	zero,0(r2)
   return eth_prt_buf;
 8228dcc:	008209b4 	movhi	r2,2086
 8228dd0:	10b83804 	addi	r2,r2,-7968
}
 8228dd4:	e037883a 	mov	sp,fp
 8228dd8:	df000017 	ldw	fp,0(sp)
 8228ddc:	dec00104 	addi	sp,sp,4
 8228de0:	f800283a 	ret

08228de4 <uslash>:
 * RETURNS:  pointer to formatted text
 */

char *   
uslash(char * path)
{
 8228de4:	defffd04 	addi	sp,sp,-12
 8228de8:	df000215 	stw	fp,8(sp)
 8228dec:	df000204 	addi	fp,sp,8
 8228df0:	e13fff15 	stw	r4,-4(fp)
   char *   cp;

   for (cp = path; *cp; cp++)
 8228df4:	e0bfff17 	ldw	r2,-4(fp)
 8228df8:	e0bffe15 	stw	r2,-8(fp)
 8228dfc:	00000d06 	br	8228e34 <uslash+0x50>
      if (*cp == '\\')
 8228e00:	e0bffe17 	ldw	r2,-8(fp)
 8228e04:	10800003 	ldbu	r2,0(r2)
 8228e08:	10803fcc 	andi	r2,r2,255
 8228e0c:	1080201c 	xori	r2,r2,128
 8228e10:	10bfe004 	addi	r2,r2,-128
 8228e14:	10801718 	cmpnei	r2,r2,92
 8228e18:	1000031e 	bne	r2,zero,8228e28 <uslash+0x44>
      *cp = '/';
 8228e1c:	e0bffe17 	ldw	r2,-8(fp)
 8228e20:	00c00bc4 	movi	r3,47
 8228e24:	10c00005 	stb	r3,0(r2)
char *   
uslash(char * path)
{
   char *   cp;

   for (cp = path; *cp; cp++)
 8228e28:	e0bffe17 	ldw	r2,-8(fp)
 8228e2c:	10800044 	addi	r2,r2,1
 8228e30:	e0bffe15 	stw	r2,-8(fp)
 8228e34:	e0bffe17 	ldw	r2,-8(fp)
 8228e38:	10800003 	ldbu	r2,0(r2)
 8228e3c:	10803fcc 	andi	r2,r2,255
 8228e40:	1080201c 	xori	r2,r2,128
 8228e44:	10bfe004 	addi	r2,r2,-128
 8228e48:	103fed1e 	bne	r2,zero,8228e00 <uslash+0x1c>
      if (*cp == '\\')
      *cp = '/';
   return path;
 8228e4c:	e0bfff17 	ldw	r2,-4(fp)
}
 8228e50:	e037883a 	mov	sp,fp
 8228e54:	df000017 	ldw	fp,0(sp)
 8228e58:	dec00104 	addi	sp,sp,4
 8228e5c:	f800283a 	ret

08228e60 <ns_printf>:
 */
#ifndef ns_printf

int 
ns_printf(void * vio, char * format, ...)
{
 8228e60:	defff304 	addi	sp,sp,-52
 8228e64:	dfc00a15 	stw	ra,40(sp)
 8228e68:	df000915 	stw	fp,36(sp)
 8228e6c:	dc400815 	stw	r17,32(sp)
 8228e70:	dc000715 	stw	r16,28(sp)
 8228e74:	df000904 	addi	fp,sp,36
 8228e78:	e13ffc15 	stw	r4,-16(fp)
 8228e7c:	e17ffd15 	stw	r5,-12(fp)
 8228e80:	e1800215 	stw	r6,8(fp)
 8228e84:	e1c00315 	stw	r7,12(fp)
   char *   outbuf=NULL;
 8228e88:	e03ff815 	stw	zero,-32(fp)
   int   ret_value   ;
   int   buf_size =  MAXIOSIZE   ;
 8228e8c:	00802704 	movi	r2,156
 8228e90:	e0bff715 	stw	r2,-36(fp)
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 8228e94:	e0bffc17 	ldw	r2,-16(fp)
 8228e98:	e0bff915 	stw	r2,-28(fp)
   int * next_arg=(int *)  &format;
   next_arg +=  sizeof(char *)/sizeof(int) ;
#endif   /* NATIVE_PRINTF || PRINTF_STRING */

   /* a NULL pio means just dump the output to stdout */
   if (pio == NULL)
 8228e9c:	e0bff917 	ldw	r2,-28(fp)
 8228ea0:	1000091e 	bne	r2,zero,8228ec8 <ns_printf+0x68>
   {
#ifdef NATIVE_PRINTF
      /* use the target system's ANSI routines */
      va_start(argList,format);
 8228ea4:	e0800204 	addi	r2,fp,8
 8228ea8:	e0bffb15 	stw	r2,-20(fp)
      ret_value = vprintf(format,argList);
 8228eac:	e0bffb17 	ldw	r2,-20(fp)
 8228eb0:	100b883a 	mov	r5,r2
 8228eb4:	e13ffd17 	ldw	r4,-12(fp)
 8228eb8:	824bb580 	call	824bb58 <vprintf>
 8228ebc:	e0bffa15 	stw	r2,-24(fp)
      va_end(argList);
      return ret_value;
 8228ec0:	e0bffa17 	ldw	r2,-24(fp)
 8228ec4:	00003b06 	br	8228fb4 <ns_printf+0x154>
      return strlen(format);
#endif   /* NATIVE_PRINTF */
   }

   /* Check if the output function is set */
   if (pio->out == NULL)
 8228ec8:	e0bff917 	ldw	r2,-28(fp)
 8228ecc:	10800117 	ldw	r2,4(r2)
 8228ed0:	1000021e 	bne	r2,zero,8228edc <ns_printf+0x7c>
   {
      /* Programming mistake. Output function not set. */
      return -1;
 8228ed4:	00bfffc4 	movi	r2,-1
 8228ed8:	00003606 	br	8228fb4 <ns_printf+0x154>

   /* Allocate memory for the output string 
    * If the format string is greater than MAXIOSIZE, then
    * we surely need to allocate a bigger block
    */
   ret_value = strlen(format); 
 8228edc:	e13ffd17 	ldw	r4,-12(fp)
 8228ee0:	8203f600 	call	8203f60 <strlen>
 8228ee4:	e0bffa15 	stw	r2,-24(fp)
   if (ret_value >= MAXIOSIZE)
 8228ee8:	e0bffa17 	ldw	r2,-24(fp)
 8228eec:	10802710 	cmplti	r2,r2,156
 8228ef0:	1000041e 	bne	r2,zero,8228f04 <ns_printf+0xa4>
   {
      buf_size += ret_value ;
 8228ef4:	e0fff717 	ldw	r3,-36(fp)
 8228ef8:	e0bffa17 	ldw	r2,-24(fp)
 8228efc:	1885883a 	add	r2,r3,r2
 8228f00:	e0bff715 	stw	r2,-36(fp)
   }

   outbuf=(char *)npalloc(buf_size); 
 8228f04:	e0bff717 	ldw	r2,-36(fp)
 8228f08:	1009883a 	mov	r4,r2
 8228f0c:	822e16c0 	call	822e16c <npalloc>
 8228f10:	e0bff815 	stw	r2,-32(fp)

   if (outbuf == NULL)
 8228f14:	e0bff817 	ldw	r2,-32(fp)
 8228f18:	1000021e 	bne	r2,zero,8228f24 <ns_printf+0xc4>
   {
      return -2;
 8228f1c:	00bfff84 	movi	r2,-2
 8228f20:	00002406 	br	8228fb4 <ns_printf+0x154>

   /* Now populate the output string */

#ifdef NATIVE_PRINTF
   /* use the target system's ANSI routines */
   va_start(argList,format);
 8228f24:	e0800204 	addi	r2,fp,8
 8228f28:	e0bffb15 	stw	r2,-20(fp)
   ret_value = vsprintf(outbuf,format,argList);
 8228f2c:	e0bffb17 	ldw	r2,-20(fp)
 8228f30:	100d883a 	mov	r6,r2
 8228f34:	e17ffd17 	ldw	r5,-12(fp)
 8228f38:	e13ff817 	ldw	r4,-32(fp)
 8228f3c:	824bbd40 	call	824bbd4 <vsprintf>
 8228f40:	e0bffa15 	stw	r2,-24(fp)
#endif   /* PRINTF_STDARG */
#endif   /* NATIVE_PRINTF */

#ifdef NATIVE_PRINTF
   /* Check if we have overwritten the output buffer */
   if ((int)strlen(outbuf) > buf_size)
 8228f44:	e13ff817 	ldw	r4,-32(fp)
 8228f48:	8203f600 	call	8203f60 <strlen>
 8228f4c:	1007883a 	mov	r3,r2
 8228f50:	e0bff717 	ldw	r2,-36(fp)
 8228f54:	10c0080e 	bge	r2,r3,8228f78 <ns_printf+0x118>
       */
      /* Yes , we have overwritten. Truncate the output string.
       * Some memory in the heap has been corrupted, but it is too
       * late to rectify.
       */
      panic("ns_printf:Buffer overflow");
 8228f58:	01020974 	movhi	r4,2085
 8228f5c:	21018e04 	addi	r4,r4,1592
 8228f60:	8228c480 	call	8228c48 <panic>
      outbuf[buf_size-1]=0;   /* Null terminate the string */
 8228f64:	e0bff717 	ldw	r2,-36(fp)
 8228f68:	10bfffc4 	addi	r2,r2,-1
 8228f6c:	e0fff817 	ldw	r3,-32(fp)
 8228f70:	1885883a 	add	r2,r3,r2
 8228f74:	10000005 	stb	zero,0(r2)
   }
#endif

   ret_value =(pio->out)(pio->id,outbuf,strlen(outbuf)) ;
 8228f78:	e0bff917 	ldw	r2,-28(fp)
 8228f7c:	14000117 	ldw	r16,4(r2)
 8228f80:	e0bff917 	ldw	r2,-28(fp)
 8228f84:	14400217 	ldw	r17,8(r2)
 8228f88:	e13ff817 	ldw	r4,-32(fp)
 8228f8c:	8203f600 	call	8203f60 <strlen>
 8228f90:	100d883a 	mov	r6,r2
 8228f94:	e17ff817 	ldw	r5,-32(fp)
 8228f98:	8809883a 	mov	r4,r17
 8228f9c:	803ee83a 	callr	r16
 8228fa0:	e0bffa15 	stw	r2,-24(fp)

   /* Free memory for the output string */
   npfree(outbuf); 
 8228fa4:	e13ff817 	ldw	r4,-32(fp)
 8228fa8:	822e1a00 	call	822e1a0 <npfree>

   /* since ns_printf() can get called repeatedly down in the bowels 
    * of a single command interpretting function, spin tk_yield() so 
    * that some packets get a chance to get received 
    */
   tk_yield();
 8228fac:	822980c0 	call	822980c <tk_yield>

   return ret_value ;
 8228fb0:	e0bffa17 	ldw	r2,-24(fp)
}
 8228fb4:	e6fffe04 	addi	sp,fp,-8
 8228fb8:	dfc00317 	ldw	ra,12(sp)
 8228fbc:	df000217 	ldw	fp,8(sp)
 8228fc0:	dc400117 	ldw	r17,4(sp)
 8228fc4:	dc000017 	ldw	r16,0(sp)
 8228fc8:	dec00604 	addi	sp,sp,24
 8228fcc:	f800283a 	ret

08228fd0 <std_out>:
 *
 * RETURNS: Number of bytes send to standard output. 
 */

int std_out(long s, char * buf, int len)
{
 8228fd0:	defffb04 	addi	sp,sp,-20
 8228fd4:	dfc00415 	stw	ra,16(sp)
 8228fd8:	df000315 	stw	fp,12(sp)
 8228fdc:	df000304 	addi	fp,sp,12
 8228fe0:	e13ffd15 	stw	r4,-12(fp)
 8228fe4:	e17ffe15 	stw	r5,-8(fp)
 8228fe8:	e1bfff15 	stw	r6,-4(fp)
   /* puts(buf); - This does newline expansion return 
    * write(0,buf,len); - This doesn't printf(buf); - This has 
    * problems when printf format strings (eg %s) is part of data. 
    */
   printf("%s",buf);
 8228fec:	e17ffe17 	ldw	r5,-8(fp)
 8228ff0:	01020974 	movhi	r4,2085
 8228ff4:	21019504 	addi	r4,r4,1620
 8228ff8:	82033a00 	call	82033a0 <printf>
   USE_ARG(s);
   return len;
 8228ffc:	e0bfff17 	ldw	r2,-4(fp)
}
 8229000:	e037883a 	mov	sp,fp
 8229004:	dfc00117 	ldw	ra,4(sp)
 8229008:	df000017 	ldw	fp,0(sp)
 822900c:	dec00204 	addi	sp,sp,8
 8229010:	f800283a 	ret

08229014 <con_page>:
 * RETURNS: 1 if we got a break, 0 to keep printing
 */

int
con_page(void * vio, int lines)
{
 8229014:	defffa04 	addi	sp,sp,-24
 8229018:	dfc00515 	stw	ra,20(sp)
 822901c:	df000415 	stw	fp,16(sp)
 8229020:	df000404 	addi	fp,sp,16
 8229024:	e13ffe15 	stw	r4,-8(fp)
 8229028:	e17fff15 	stw	r5,-4(fp)
   int   ch;
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 822902c:	e0bffe17 	ldw	r2,-8(fp)
 8229030:	e0bffc15 	stw	r2,-16(fp)

   if (lines % 20 == 0)   /* Time to get user input */
 8229034:	e0bfff17 	ldw	r2,-4(fp)
 8229038:	01400504 	movi	r5,20
 822903c:	1009883a 	mov	r4,r2
 8229040:	8202b9c0 	call	8202b9c <__modsi3>
 8229044:	1000231e 	bne	r2,zero,82290d4 <con_page+0xc0>
   {
      if (pio && pio->getch)   /*if i/p func is supplied*/
 8229048:	e0bffc17 	ldw	r2,-16(fp)
 822904c:	10002126 	beq	r2,zero,82290d4 <con_page+0xc0>
 8229050:	e0bffc17 	ldw	r2,-16(fp)
 8229054:	10800317 	ldw	r2,12(r2)
 8229058:	10001e26 	beq	r2,zero,82290d4 <con_page+0xc0>
      {
         ns_printf(pio,"....press any key for more (ESC to break)....");
 822905c:	01420974 	movhi	r5,2085
 8229060:	29419604 	addi	r5,r5,1624
 8229064:	e13ffc17 	ldw	r4,-16(fp)
 8229068:	8228e600 	call	8228e60 <ns_printf>

         do 
         {
            ch = (pio->getch)(pio->id);
 822906c:	e0bffc17 	ldw	r2,-16(fp)
 8229070:	10800317 	ldw	r2,12(r2)
 8229074:	e0fffc17 	ldw	r3,-16(fp)
 8229078:	18c00217 	ldw	r3,8(r3)
 822907c:	1809883a 	mov	r4,r3
 8229080:	103ee83a 	callr	r2
 8229084:	e0bffd15 	stw	r2,-12(fp)
            if (ch == 0)
 8229088:	e0bffd17 	ldw	r2,-12(fp)
 822908c:	1000011e 	bne	r2,zero,8229094 <con_page+0x80>
               tk_yield();    /* Give timeslice to other processes */
 8229090:	822980c0 	call	822980c <tk_yield>
         } while (ch == 0) ;
 8229094:	e0bffd17 	ldw	r2,-12(fp)
 8229098:	103ff426 	beq	r2,zero,822906c <con_page+0x58>

            /* if there is fatal error, we don't want to do any I/O */
         if (ch == -1)   /* fatal error */
 822909c:	e0bffd17 	ldw	r2,-12(fp)
 82290a0:	10bfffd8 	cmpnei	r2,r2,-1
 82290a4:	1000021e 	bne	r2,zero,82290b0 <con_page+0x9c>
            return 1 ;
 82290a8:	00800044 	movi	r2,1
 82290ac:	00000a06 	br	82290d8 <con_page+0xc4>

         ns_printf(pio,"\n");
 82290b0:	01420974 	movhi	r5,2085
 82290b4:	29417704 	addi	r5,r5,1500
 82290b8:	e13ffc17 	ldw	r4,-16(fp)
 82290bc:	8228e600 	call	8228e60 <ns_printf>
         if (ch == 27)   /* ESC key pressed */
 82290c0:	e0bffd17 	ldw	r2,-12(fp)
 82290c4:	108006d8 	cmpnei	r2,r2,27
 82290c8:	1000021e 	bne	r2,zero,82290d4 <con_page+0xc0>
            return 1 ;
 82290cc:	00800044 	movi	r2,1
 82290d0:	00000106 	br	82290d8 <con_page+0xc4>
      }
   }
   return  0;
 82290d4:	0005883a 	mov	r2,zero
}
 82290d8:	e037883a 	mov	sp,fp
 82290dc:	dfc00117 	ldw	ra,4(sp)
 82290e0:	df000017 	ldw	fp,0(sp)
 82290e4:	dec00204 	addi	sp,sp,8
 82290e8:	f800283a 	ret

082290ec <parse_args>:

char **parse_args(char *buf, int argc, int *pargc_index)
{
 82290ec:	defff704 	addi	sp,sp,-36
 82290f0:	dfc00815 	stw	ra,32(sp)
 82290f4:	df000715 	stw	fp,28(sp)
 82290f8:	df000704 	addi	fp,sp,28
 82290fc:	e13ffd15 	stw	r4,-12(fp)
 8229100:	e17ffe15 	stw	r5,-8(fp)
 8229104:	e1bfff15 	stw	r6,-4(fp)
   /* This routine assumes buf is a null terminated string */
   int i;
   int len;
   char *bp = buf;
 8229108:	e0bffd17 	ldw	r2,-12(fp)
 822910c:	e0bffa15 	stw	r2,-24(fp)
   char **pargv = NULL;
 8229110:	e03ffb15 	stw	zero,-20(fp)
   *pargc_index = 0;
 8229114:	e0bfff17 	ldw	r2,-4(fp)
 8229118:	10000015 	stw	zero,0(r2)
   if (buf == NULL)
 822911c:	e0bffd17 	ldw	r2,-12(fp)
 8229120:	1000021e 	bne	r2,zero,822912c <parse_args+0x40>
   {
      return (NULL);
 8229124:	0005883a 	mov	r2,zero
 8229128:	00006c06 	br	82292dc <parse_args+0x1f0>
   }
   len = strlen(buf);
 822912c:	e13ffd17 	ldw	r4,-12(fp)
 8229130:	8203f600 	call	8203f60 <strlen>
 8229134:	e0bffc15 	stw	r2,-16(fp)
   if (len <= 0)
 8229138:	e0bffc17 	ldw	r2,-16(fp)
 822913c:	00800216 	blt	zero,r2,8229148 <parse_args+0x5c>
   {
      return (NULL);
 8229140:	0005883a 	mov	r2,zero
 8229144:	00006506 	br	82292dc <parse_args+0x1f0>
   }
   pargv = (char **) npalloc(argc * sizeof(char *));
 8229148:	e0bffe17 	ldw	r2,-8(fp)
 822914c:	1085883a 	add	r2,r2,r2
 8229150:	1085883a 	add	r2,r2,r2
 8229154:	1009883a 	mov	r4,r2
 8229158:	822e16c0 	call	822e16c <npalloc>
 822915c:	e0bffb15 	stw	r2,-20(fp)
   if (pargv == NULL)
 8229160:	e0bffb17 	ldw	r2,-20(fp)
 8229164:	1000051e 	bne	r2,zero,822917c <parse_args+0x90>
   {
      return (NULL);
 8229168:	0005883a 	mov	r2,zero
 822916c:	00005b06 	br	82292dc <parse_args+0x1f0>
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
 8229170:	e0bffa17 	ldw	r2,-24(fp)
 8229174:	10800044 	addi	r2,r2,1
 8229178:	e0bffa15 	stw	r2,-24(fp)
   if (pargv == NULL)
   {
      return (NULL);
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
 822917c:	e0bffa17 	ldw	r2,-24(fp)
 8229180:	10800003 	ldbu	r2,0(r2)
 8229184:	10803fcc 	andi	r2,r2,255
 8229188:	1080201c 	xori	r2,r2,128
 822918c:	10bfe004 	addi	r2,r2,-128
 8229190:	10800820 	cmpeqi	r2,r2,32
 8229194:	103ff61e 	bne	r2,zero,8229170 <parse_args+0x84>
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 8229198:	00003006 	br	822925c <parse_args+0x170>
   {
      pargv[(*pargc_index)] = bp;
 822919c:	e0bfff17 	ldw	r2,-4(fp)
 82291a0:	10800017 	ldw	r2,0(r2)
 82291a4:	1085883a 	add	r2,r2,r2
 82291a8:	1085883a 	add	r2,r2,r2
 82291ac:	1007883a 	mov	r3,r2
 82291b0:	e0bffb17 	ldw	r2,-20(fp)
 82291b4:	10c5883a 	add	r2,r2,r3
 82291b8:	e0fffa17 	ldw	r3,-24(fp)
 82291bc:	10c00015 	stw	r3,0(r2)
      (*pargc_index)++;
 82291c0:	e0bfff17 	ldw	r2,-4(fp)
 82291c4:	10800017 	ldw	r2,0(r2)
 82291c8:	10c00044 	addi	r3,r2,1
 82291cc:	e0bfff17 	ldw	r2,-4(fp)
 82291d0:	10c00015 	stw	r3,0(r2)
      while (*bp != ' ' && *bp != '\0')
 82291d4:	00000306 	br	82291e4 <parse_args+0xf8>
      {
         bp++; 
 82291d8:	e0bffa17 	ldw	r2,-24(fp)
 82291dc:	10800044 	addi	r2,r2,1
 82291e0:	e0bffa15 	stw	r2,-24(fp)
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
   {
      pargv[(*pargc_index)] = bp;
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
 82291e4:	e0bffa17 	ldw	r2,-24(fp)
 82291e8:	10800003 	ldbu	r2,0(r2)
 82291ec:	10803fcc 	andi	r2,r2,255
 82291f0:	1080201c 	xori	r2,r2,128
 82291f4:	10bfe004 	addi	r2,r2,-128
 82291f8:	10800820 	cmpeqi	r2,r2,32
 82291fc:	10000a1e 	bne	r2,zero,8229228 <parse_args+0x13c>
 8229200:	e0bffa17 	ldw	r2,-24(fp)
 8229204:	10800003 	ldbu	r2,0(r2)
 8229208:	10803fcc 	andi	r2,r2,255
 822920c:	1080201c 	xori	r2,r2,128
 8229210:	10bfe004 	addi	r2,r2,-128
 8229214:	103ff01e 	bne	r2,zero,82291d8 <parse_args+0xec>
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 8229218:	00000306 	br	8229228 <parse_args+0x13c>
      {
         bp++; 
 822921c:	e0bffa17 	ldw	r2,-24(fp)
 8229220:	10800044 	addi	r2,r2,1
 8229224:	e0bffa15 	stw	r2,-24(fp)
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 8229228:	e0bffa17 	ldw	r2,-24(fp)
 822922c:	10800003 	ldbu	r2,0(r2)
 8229230:	10803fcc 	andi	r2,r2,255
 8229234:	1080201c 	xori	r2,r2,128
 8229238:	10bfe004 	addi	r2,r2,-128
 822923c:	10800818 	cmpnei	r2,r2,32
 8229240:	1000061e 	bne	r2,zero,822925c <parse_args+0x170>
 8229244:	e0bffa17 	ldw	r2,-24(fp)
 8229248:	10800003 	ldbu	r2,0(r2)
 822924c:	10803fcc 	andi	r2,r2,255
 8229250:	1080201c 	xori	r2,r2,128
 8229254:	10bfe004 	addi	r2,r2,-128
 8229258:	103ff01e 	bne	r2,zero,822921c <parse_args+0x130>
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 822925c:	e0bffa17 	ldw	r2,-24(fp)
 8229260:	10800003 	ldbu	r2,0(r2)
 8229264:	10803fcc 	andi	r2,r2,255
 8229268:	1080201c 	xori	r2,r2,128
 822926c:	10bfe004 	addi	r2,r2,-128
 8229270:	10000426 	beq	r2,zero,8229284 <parse_args+0x198>
 8229274:	e0bfff17 	ldw	r2,-4(fp)
 8229278:	10c00017 	ldw	r3,0(r2)
 822927c:	e0bffe17 	ldw	r2,-8(fp)
 8229280:	18bfc616 	blt	r3,r2,822919c <parse_args+0xb0>
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 8229284:	e03ff915 	stw	zero,-28(fp)
 8229288:	00001006 	br	82292cc <parse_args+0x1e0>
   {
      if (buf[i] == ' ')
 822928c:	e0bff917 	ldw	r2,-28(fp)
 8229290:	e0fffd17 	ldw	r3,-12(fp)
 8229294:	1885883a 	add	r2,r3,r2
 8229298:	10800003 	ldbu	r2,0(r2)
 822929c:	10803fcc 	andi	r2,r2,255
 82292a0:	1080201c 	xori	r2,r2,128
 82292a4:	10bfe004 	addi	r2,r2,-128
 82292a8:	10800818 	cmpnei	r2,r2,32
 82292ac:	1000041e 	bne	r2,zero,82292c0 <parse_args+0x1d4>
         buf[i] = '\0';
 82292b0:	e0bff917 	ldw	r2,-28(fp)
 82292b4:	e0fffd17 	ldw	r3,-12(fp)
 82292b8:	1885883a 	add	r2,r3,r2
 82292bc:	10000005 	stb	zero,0(r2)
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 82292c0:	e0bff917 	ldw	r2,-28(fp)
 82292c4:	10800044 	addi	r2,r2,1
 82292c8:	e0bff915 	stw	r2,-28(fp)
 82292cc:	e0fff917 	ldw	r3,-28(fp)
 82292d0:	e0bffc17 	ldw	r2,-16(fp)
 82292d4:	18bfed16 	blt	r3,r2,822928c <parse_args+0x1a0>
   {
      printf("pargv[%d] = %s\n", i, pargv[i]);
   }
#endif

   return (pargv);
 82292d8:	e0bffb17 	ldw	r2,-20(fp)
}
 82292dc:	e037883a 	mov	sp,fp
 82292e0:	dfc00117 	ldw	ra,4(sp)
 82292e4:	df000017 	ldw	fp,0(sp)
 82292e8:	dec00204 	addi	sp,sp,8
 82292ec:	f800283a 	ret

082292f0 <netmain>:
 * RETURNS: 
 */

int
netmain(void)
{
 82292f0:	defffc04 	addi	sp,sp,-16
 82292f4:	dfc00315 	stw	ra,12(sp)
 82292f8:	df000215 	stw	fp,8(sp)
 82292fc:	df000204 	addi	fp,sp,8
   int   i;
   int   e;

   iniche_net_ready = FALSE;
 8229300:	d0208c15 	stw	zero,-32208(gp)

   e = prep_modules();
 8229304:	823d3b80 	call	823d3b8 <prep_modules>
 8229308:	e0bfff15 	stw	r2,-4(fp)

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 822930c:	e03ffe15 	stw	zero,-8(fp)
 8229310:	00001a06 	br	822937c <netmain+0x8c>
   {
      e = TK_NEWTASK(&nettasks[i]);
 8229314:	e0bffe17 	ldw	r2,-8(fp)
 8229318:	10c00624 	muli	r3,r2,24
 822931c:	00820974 	movhi	r2,2085
 8229320:	108ea504 	addi	r2,r2,14996
 8229324:	1885883a 	add	r2,r3,r2
 8229328:	1009883a 	mov	r4,r2
 822932c:	822d95c0 	call	822d95c <TK_NEWTASK>
 8229330:	e0bfff15 	stw	r2,-4(fp)
      if (e != 0)
 8229334:	e0bfff17 	ldw	r2,-4(fp)
 8229338:	10000d26 	beq	r2,zero,8229370 <netmain+0x80>
      {
         dprintf("task create error\n");
 822933c:	01020974 	movhi	r4,2085
 8229340:	2101a804 	addi	r4,r4,1696
 8229344:	82036240 	call	8203624 <puts>
         panic((char *)&nettasks[i].name);
 8229348:	e0bffe17 	ldw	r2,-8(fp)
 822934c:	10800624 	muli	r2,r2,24
 8229350:	10c00104 	addi	r3,r2,4
 8229354:	00820974 	movhi	r2,2085
 8229358:	108ea504 	addi	r2,r2,14996
 822935c:	1885883a 	add	r2,r3,r2
 8229360:	1009883a 	mov	r4,r2
 8229364:	8228c480 	call	8228c48 <panic>
         return -1;  /* compiler warnings */
 8229368:	00bfffc4 	movi	r2,-1
 822936c:	00001306 	br	82293bc <netmain+0xcc>
   iniche_net_ready = FALSE;

   e = prep_modules();

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 8229370:	e0bffe17 	ldw	r2,-8(fp)
 8229374:	10800044 	addi	r2,r2,1
 8229378:	e0bffe15 	stw	r2,-8(fp)
 822937c:	d0a03217 	ldw	r2,-32568(gp)
 8229380:	e0fffe17 	ldw	r3,-8(fp)
 8229384:	18bfe316 	blt	r3,r2,8229314 <netmain+0x24>
         panic((char *)&nettasks[i].name);
         return -1;  /* compiler warnings */
      }
   }
   
   e = create_apptasks();
 8229388:	823d8200 	call	823d820 <create_apptasks>
 822938c:	e0bfff15 	stw	r2,-4(fp)
   if (e != 0) 
 8229390:	e0bfff17 	ldw	r2,-4(fp)
 8229394:	10000826 	beq	r2,zero,82293b8 <netmain+0xc8>
   {
      dprintf("task create error\n");
 8229398:	01020974 	movhi	r4,2085
 822939c:	2101a804 	addi	r4,r4,1696
 82293a0:	82036240 	call	8203624 <puts>
      panic("netmain");
 82293a4:	01020974 	movhi	r4,2085
 82293a8:	2101ad04 	addi	r4,r4,1716
 82293ac:	8228c480 	call	8228c48 <panic>
      return -1;  /* compiler warnings */
 82293b0:	00bfffc4 	movi	r2,-1
 82293b4:	00000106 	br	82293bc <netmain+0xcc>
#ifdef MAIN_TASK_IS_NET
   tk_netmain(TK_NETMAINPARM);
   panic("net task return");
   return -1;
#else
   return 0;
 82293b8:	0005883a 	mov	r2,zero
#endif
#endif   /* NO_INET_STACK */
}
 82293bc:	e037883a 	mov	sp,fp
 82293c0:	dfc00117 	ldw	ra,4(sp)
 82293c4:	df000017 	ldw	fp,0(sp)
 82293c8:	dec00204 	addi	sp,sp,8
 82293cc:	f800283a 	ret

082293d0 <tk_netmain>:
 * RETURNS: n/a
 */

#ifndef NO_INET_STACK
TK_ENTRY(tk_netmain)
{
 82293d0:	defffc04 	addi	sp,sp,-16
 82293d4:	dfc00315 	stw	ra,12(sp)
 82293d8:	df000215 	stw	fp,8(sp)
 82293dc:	df000204 	addi	fp,sp,8
 82293e0:	e13fff15 	stw	r4,-4(fp)
   netmain_init(); /* initialize all modules */
 82293e4:	823d0180 	call	823d018 <netmain_init>

   iniche_net_ready = TRUE;    /* let the other threads spin */
 82293e8:	00800044 	movi	r2,1
 82293ec:	d0a08c15 	stw	r2,-32208(gp)

   for (;;)
   {
      TK_NETRX_BLOCK();
 82293f0:	d0a0ab17 	ldw	r2,-32084(gp)
 82293f4:	e1bffe04 	addi	r6,fp,-8
 82293f8:	01401904 	movi	r5,100
 82293fc:	1009883a 	mov	r4,r2
 8229400:	821a0d40 	call	821a0d4 <OSSemPend>
 8229404:	e0bffe03 	ldbu	r2,-8(fp)
 8229408:	10803fcc 	andi	r2,r2,255
 822940c:	10000526 	beq	r2,zero,8229424 <tk_netmain+0x54>
 8229410:	e0bffe03 	ldbu	r2,-8(fp)
 8229414:	10803fcc 	andi	r2,r2,255
 8229418:	108002a0 	cmpeqi	r2,r2,10
 822941c:	1000011e 	bne	r2,zero,8229424 <tk_netmain+0x54>
 8229420:	822d5940 	call	822d594 <dtrap>
      netmain_wakes++;  /* count wakeups */
 8229424:	d0a08a17 	ldw	r2,-32216(gp)
 8229428:	10800044 	addi	r2,r2,1
 822942c:	d0a08a15 	stw	r2,-32216(gp)

      /* see if there's newly received network packets */
      if (rcvdq.q_len)
 8229430:	008209b4 	movhi	r2,2086
 8229434:	10b75604 	addi	r2,r2,-8872
 8229438:	10800217 	ldw	r2,8(r2)
 822943c:	103fec26 	beq	r2,zero,82293f0 <tk_netmain+0x20>
         pktdemux();
 8229440:	82262c40 	call	82262c4 <pktdemux>
       * vital to a clean shutdown 
       */
#ifdef USE_LCD
      update_display();
#endif
   }
 8229444:	003fea06 	br	82293f0 <tk_netmain+0x20>

08229448 <tk_nettick>:
extern   int dhc_second(void);
#endif

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
 8229448:	defffd04 	addi	sp,sp,-12
 822944c:	dfc00215 	stw	ra,8(sp)
 8229450:	df000115 	stw	fp,4(sp)
 8229454:	df000104 	addi	fp,sp,4
 8229458:	e13fff15 	stw	r4,-4(fp)
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 822945c:	00000306 	br	822946c <tk_nettick+0x24>
       * request and then we receive a NAK. At this point the DHCP
       * client is reset to INIT state and dhc_second() needs to be
       * run to restart it.
       */
#ifdef DHCP_CLIENT
      dhc_second();
 8229460:	822bd100 	call	822bd10 <dhc_second>
#endif
      TK_SLEEP(1);
 8229464:	01000084 	movi	r4,2
 8229468:	821bed80 	call	821bed8 <OSTimeDly>

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 822946c:	d0a08c17 	ldw	r2,-32208(gp)
 8229470:	103ffb26 	beq	r2,zero,8229460 <tk_nettick+0x18>
      TK_SLEEP(1);
   }

   for (;;)
   {
      TK_SLEEP(SYS_SHORT_SLEEP);
 8229474:	01000084 	movi	r4,2
 8229478:	821bed80 	call	821bed8 <OSTimeDly>
      nettick_wakes++;  /* count wakeups */
 822947c:	d0a08b17 	ldw	r2,-32212(gp)
 8229480:	10800044 	addi	r2,r2,1
 8229484:	d0a08b15 	stw	r2,-32212(gp)
      inet_timer();  /* let various timeouts occur */
 8229488:	823d40c0 	call	823d40c <inet_timer>
      /* do not kill timers on net_system_exit. They may be
       * vital to a clean shutdown 
       */
   }
 822948c:	003ff906 	br	8229474 <tk_nettick+0x2c>

08229490 <TK_OSTimeDly>:
u_char   TK_OSTaskQuery(void);



void TK_OSTimeDly(void)
{
 8229490:	defffe04 	addi	sp,sp,-8
 8229494:	dfc00115 	stw	ra,4(sp)
 8229498:	df000015 	stw	fp,0(sp)
 822949c:	d839883a 	mov	fp,sp
   OSTimeDly(2);
 82294a0:	01000084 	movi	r4,2
 82294a4:	821bed80 	call	821bed8 <OSTimeDly>
}
 82294a8:	0001883a 	nop
 82294ac:	e037883a 	mov	sp,fp
 82294b0:	dfc00117 	ldw	ra,4(sp)
 82294b4:	df000017 	ldw	fp,0(sp)
 82294b8:	dec00204 	addi	sp,sp,8
 82294bc:	f800283a 	ret

082294c0 <TK_OSTaskResume>:



void TK_OSTaskResume(u_char * Id)
{
 82294c0:	defffc04 	addi	sp,sp,-16
 82294c4:	dfc00315 	stw	ra,12(sp)
 82294c8:	df000215 	stw	fp,8(sp)
 82294cc:	df000204 	addi	fp,sp,8
 82294d0:	e13fff15 	stw	r4,-4(fp)
INT8U err;

   err = OSTaskResume(*Id);
 82294d4:	e0bfff17 	ldw	r2,-4(fp)
 82294d8:	10800003 	ldbu	r2,0(r2)
 82294dc:	10803fcc 	andi	r2,r2,255
 82294e0:	1009883a 	mov	r4,r2
 82294e4:	821b7cc0 	call	821b7cc <OSTaskResume>
 82294e8:	e0bffe05 	stb	r2,-8(fp)
   
#ifdef NPDEBUG
   if ((err != OS_NO_ERR) && (err != OS_TASK_NOT_SUSPENDED))
 82294ec:	e0bffe03 	ldbu	r2,-8(fp)
 82294f0:	10000a26 	beq	r2,zero,822951c <TK_OSTaskResume+0x5c>
 82294f4:	e0bffe03 	ldbu	r2,-8(fp)
 82294f8:	10801120 	cmpeqi	r2,r2,68
 82294fc:	1000071e 	bne	r2,zero,822951c <TK_OSTaskResume+0x5c>
   {
      dprintf("ChronOS API call failure, to Resume Suspended Task!\n");
 8229500:	01020974 	movhi	r4,2085
 8229504:	2101af04 	addi	r4,r4,1724
 8229508:	82036240 	call	8203624 <puts>
      dtrap();
 822950c:	822d5940 	call	822d594 <dtrap>
      panic("TK_OSTaskResume");      
 8229510:	01020974 	movhi	r4,2085
 8229514:	2101bc04 	addi	r4,r4,1776
 8229518:	8228c480 	call	8228c48 <panic>
   }
#endif
}
 822951c:	0001883a 	nop
 8229520:	e037883a 	mov	sp,fp
 8229524:	dfc00117 	ldw	ra,4(sp)
 8229528:	df000017 	ldw	fp,0(sp)
 822952c:	dec00204 	addi	sp,sp,8
 8229530:	f800283a 	ret

08229534 <tcp_sleep>:
 *
 * RETURN: none
 */
void
tcp_sleep(void * event)
{
 8229534:	defffb04 	addi	sp,sp,-20
 8229538:	dfc00415 	stw	ra,16(sp)
 822953c:	df000315 	stw	fp,12(sp)
 8229540:	df000304 	addi	fp,sp,12
 8229544:	e13fff15 	stw	r4,-4(fp)
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 8229548:	e03ffd15 	stw	zero,-12(fp)
 822954c:	00004706 	br	822966c <tcp_sleep+0x138>
   {
      if (global_TCPwakeup_set[i].soc_event == NULL)
 8229550:	008209b4 	movhi	r2,2086
 8229554:	10b90604 	addi	r2,r2,-7144
 8229558:	e0fffd17 	ldw	r3,-12(fp)
 822955c:	18c00324 	muli	r3,r3,12
 8229560:	10c5883a 	add	r2,r2,r3
 8229564:	10800104 	addi	r2,r2,4
 8229568:	10800017 	ldw	r2,0(r2)
 822956c:	10003c1e 	bne	r2,zero,8229660 <tcp_sleep+0x12c>
      {
         global_TCPwakeup_set[i].soc_event = event;
 8229570:	008209b4 	movhi	r2,2086
 8229574:	10b90604 	addi	r2,r2,-7144
 8229578:	e0fffd17 	ldw	r3,-12(fp)
 822957c:	18c00324 	muli	r3,r3,12
 8229580:	10c5883a 	add	r2,r2,r3
 8229584:	10800104 	addi	r2,r2,4
 8229588:	e0ffff17 	ldw	r3,-4(fp)
 822958c:	10c00015 	stw	r3,0(r2)
         global_TCPwakeup_set[i].ctick = cticks;
 8229590:	d0e0a817 	ldw	r3,-32096(gp)
 8229594:	008209b4 	movhi	r2,2086
 8229598:	10b90604 	addi	r2,r2,-7144
 822959c:	e13ffd17 	ldw	r4,-12(fp)
 82295a0:	21000324 	muli	r4,r4,12
 82295a4:	1105883a 	add	r2,r2,r4
 82295a8:	10c00015 	stw	r3,0(r2)
         if (i > global_TCPwakeup_setIndx)
 82295ac:	d0e0a717 	ldw	r3,-32100(gp)
 82295b0:	e0bffd17 	ldw	r2,-12(fp)
 82295b4:	1880020e 	bge	r3,r2,82295c0 <tcp_sleep+0x8c>
            global_TCPwakeup_setIndx = i;
 82295b8:	e0bffd17 	ldw	r2,-12(fp)
 82295bc:	d0a0a715 	stw	r2,-32100(gp)

         tcp_sleep_count++;
 82295c0:	d0a0a317 	ldw	r2,-32116(gp)
 82295c4:	10800044 	addi	r2,r2,1
 82295c8:	d0a0a315 	stw	r2,-32116(gp)

         /* Give up the lock before going to sleep. This can
          * potentially cause a context switch to the task
          * signaling the event.
          */
         UNLOCK_NET_RESOURCE(NET_RESID);
 82295cc:	0009883a 	mov	r4,zero
 82295d0:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>

         /* don't wait forever in case we miss the event */
         OSSemPend(global_TCPwakeup_set[i].semaphore, TPS, &err);
 82295d4:	008209b4 	movhi	r2,2086
 82295d8:	10b90604 	addi	r2,r2,-7144
 82295dc:	e0fffd17 	ldw	r3,-12(fp)
 82295e0:	18c00324 	muli	r3,r3,12
 82295e4:	10c5883a 	add	r2,r2,r3
 82295e8:	10800204 	addi	r2,r2,8
 82295ec:	10800017 	ldw	r2,0(r2)
 82295f0:	e0fffe04 	addi	r3,fp,-8
 82295f4:	180d883a 	mov	r6,r3
 82295f8:	01401904 	movi	r5,100
 82295fc:	1009883a 	mov	r4,r2
 8229600:	821a0d40 	call	821a0d4 <OSSemPend>
         if (err == 10)
 8229604:	e0bffe03 	ldbu	r2,-8(fp)
 8229608:	10803fcc 	andi	r2,r2,255
 822960c:	10800298 	cmpnei	r2,r2,10
 8229610:	1000101e 	bne	r2,zero,8229654 <tcp_sleep+0x120>
         {
            ++tcp_sleep_timeout;
 8229614:	d0a08e17 	ldw	r2,-32200(gp)
 8229618:	10800044 	addi	r2,r2,1
 822961c:	d0a08e15 	stw	r2,-32200(gp)

            /* clear the entry */
            global_TCPwakeup_set[i].ctick = 0;
 8229620:	008209b4 	movhi	r2,2086
 8229624:	10b90604 	addi	r2,r2,-7144
 8229628:	e0fffd17 	ldw	r3,-12(fp)
 822962c:	18c00324 	muli	r3,r3,12
 8229630:	10c5883a 	add	r2,r2,r3
 8229634:	10000015 	stw	zero,0(r2)
            global_TCPwakeup_set[i].soc_event = NULL;
 8229638:	008209b4 	movhi	r2,2086
 822963c:	10b90604 	addi	r2,r2,-7144
 8229640:	e0fffd17 	ldw	r3,-12(fp)
 8229644:	18c00324 	muli	r3,r3,12
 8229648:	10c5883a 	add	r2,r2,r3
 822964c:	10800104 	addi	r2,r2,4
 8229650:	10000015 	stw	zero,0(r2)
         }

         /* Regain the lock */
         LOCK_NET_RESOURCE(NET_RESID);
 8229654:	0009883a 	mov	r4,zero
 8229658:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
 822965c:	00000d06 	br	8229694 <tcp_sleep+0x160>
tcp_sleep(void * event)
{
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 8229660:	e0bffd17 	ldw	r2,-12(fp)
 8229664:	10800044 	addi	r2,r2,1
 8229668:	e0bffd15 	stw	r2,-12(fp)
 822966c:	e0bffd17 	ldw	r2,-12(fp)
 8229670:	10800510 	cmplti	r2,r2,20
 8229674:	103fb61e 	bne	r2,zero,8229550 <tcp_sleep+0x1c>

   /* The table is full. Try calling TK_YIELD() and hope for the best.
    * The user should increase the size of the table.
    * We'll record the max index for debugging purposes.
    */
   global_TCPwakeup_setIndx = i;
 8229678:	e0bffd17 	ldw	r2,-12(fp)
 822967c:	d0a0a715 	stw	r2,-32100(gp)

   UNLOCK_NET_RESOURCE(NET_RESID);
 8229680:	0009883a 	mov	r4,zero
 8229684:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   TK_YIELD();
 8229688:	822980c0 	call	822980c <tk_yield>
   LOCK_NET_RESOURCE(NET_RESID);
 822968c:	0009883a 	mov	r4,zero
 8229690:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
}
 8229694:	e037883a 	mov	sp,fp
 8229698:	dfc00117 	ldw	ra,4(sp)
 822969c:	df000017 	ldw	fp,0(sp)
 82296a0:	dec00204 	addi	sp,sp,8
 82296a4:	f800283a 	ret

082296a8 <tcp_wakeup>:
 *
 * RETURN: none
 */
void
tcp_wakeup(void *event)
{
 82296a8:	defffc04 	addi	sp,sp,-16
 82296ac:	dfc00315 	stw	ra,12(sp)
 82296b0:	df000215 	stw	fp,8(sp)
 82296b4:	df000204 	addi	fp,sp,8
 82296b8:	e13fff15 	stw	r4,-4(fp)
   int i;

   OSSchedLock();
 82296bc:	82155f00 	call	82155f0 <OSSchedLock>

   for (i = 0; i < GLOBWAKE_SZ; i++)
 82296c0:	e03ffe15 	stw	zero,-8(fp)
 82296c4:	00002c06 	br	8229778 <tcp_wakeup+0xd0>
   {
      if ((global_TCPwakeup_set[i].ctick != 0) &&
 82296c8:	008209b4 	movhi	r2,2086
 82296cc:	10b90604 	addi	r2,r2,-7144
 82296d0:	e0fffe17 	ldw	r3,-8(fp)
 82296d4:	18c00324 	muli	r3,r3,12
 82296d8:	10c5883a 	add	r2,r2,r3
 82296dc:	10800017 	ldw	r2,0(r2)
 82296e0:	10002226 	beq	r2,zero,822976c <tcp_wakeup+0xc4>
          (global_TCPwakeup_set[i].soc_event == event))
 82296e4:	008209b4 	movhi	r2,2086
 82296e8:	10b90604 	addi	r2,r2,-7144
 82296ec:	e0fffe17 	ldw	r3,-8(fp)
 82296f0:	18c00324 	muli	r3,r3,12
 82296f4:	10c5883a 	add	r2,r2,r3
 82296f8:	10800104 	addi	r2,r2,4
 82296fc:	10c00017 	ldw	r3,0(r2)

   OSSchedLock();

   for (i = 0; i < GLOBWAKE_SZ; i++)
   {
      if ((global_TCPwakeup_set[i].ctick != 0) &&
 8229700:	e0bfff17 	ldw	r2,-4(fp)
 8229704:	1880191e 	bne	r3,r2,822976c <tcp_wakeup+0xc4>
          (global_TCPwakeup_set[i].soc_event == event))
      {
         /* signal the event */
         OSSemPost(global_TCPwakeup_set[i].semaphore);
 8229708:	008209b4 	movhi	r2,2086
 822970c:	10b90604 	addi	r2,r2,-7144
 8229710:	e0fffe17 	ldw	r3,-8(fp)
 8229714:	18c00324 	muli	r3,r3,12
 8229718:	10c5883a 	add	r2,r2,r3
 822971c:	10800204 	addi	r2,r2,8
 8229720:	10800017 	ldw	r2,0(r2)
 8229724:	1009883a 	mov	r4,r2
 8229728:	821a44c0 	call	821a44c <OSSemPost>

         /* clear the entry */
         global_TCPwakeup_set[i].ctick = 0;
 822972c:	008209b4 	movhi	r2,2086
 8229730:	10b90604 	addi	r2,r2,-7144
 8229734:	e0fffe17 	ldw	r3,-8(fp)
 8229738:	18c00324 	muli	r3,r3,12
 822973c:	10c5883a 	add	r2,r2,r3
 8229740:	10000015 	stw	zero,0(r2)
         global_TCPwakeup_set[i].soc_event = NULL;
 8229744:	008209b4 	movhi	r2,2086
 8229748:	10b90604 	addi	r2,r2,-7144
 822974c:	e0fffe17 	ldw	r3,-8(fp)
 8229750:	18c00324 	muli	r3,r3,12
 8229754:	10c5883a 	add	r2,r2,r3
 8229758:	10800104 	addi	r2,r2,4
 822975c:	10000015 	stw	zero,0(r2)

         tcp_wakeup_count++;
 8229760:	d0a0a417 	ldw	r2,-32112(gp)
 8229764:	10800044 	addi	r2,r2,1
 8229768:	d0a0a415 	stw	r2,-32112(gp)
{
   int i;

   OSSchedLock();

   for (i = 0; i < GLOBWAKE_SZ; i++)
 822976c:	e0bffe17 	ldw	r2,-8(fp)
 8229770:	10800044 	addi	r2,r2,1
 8229774:	e0bffe15 	stw	r2,-8(fp)
 8229778:	e0bffe17 	ldw	r2,-8(fp)
 822977c:	10800510 	cmplti	r2,r2,20
 8229780:	103fd11e 	bne	r2,zero,82296c8 <tcp_wakeup+0x20>

         tcp_wakeup_count++;
      }
   }

   OSSchedUnlock();
 8229784:	821567c0 	call	821567c <OSSchedUnlock>
}
 8229788:	0001883a 	nop
 822978c:	e037883a 	mov	sp,fp
 8229790:	dfc00117 	ldw	ra,4(sp)
 8229794:	df000017 	ldw	fp,0(sp)
 8229798:	dec00204 	addi	sp,sp,8
 822979c:	f800283a 	ret

082297a0 <TK_OSTaskQuery>:



u_char TK_OSTaskQuery(void)
{
 82297a0:	deffe204 	addi	sp,sp,-120
 82297a4:	dfc01d15 	stw	ra,116(sp)
 82297a8:	df001c15 	stw	fp,112(sp)
 82297ac:	df001c04 	addi	fp,sp,112
   OS_TCB task_data;
   INT8U err, task_prio;

   err = OSTaskQuery(OS_PRIO_SELF, &task_data);
 82297b0:	e0bfe504 	addi	r2,fp,-108
 82297b4:	100b883a 	mov	r5,r2
 82297b8:	01003fc4 	movi	r4,255
 82297bc:	821bd440 	call	821bd44 <OSTaskQuery>
 82297c0:	e0bfe405 	stb	r2,-112(fp)

   if (err == OS_NO_ERR)
 82297c4:	e0bfe403 	ldbu	r2,-112(fp)
 82297c8:	1000041e 	bne	r2,zero,82297dc <TK_OSTaskQuery+0x3c>
   {
      task_prio = task_data.OSTCBPrio;
 82297cc:	e0bff183 	ldbu	r2,-58(fp)
 82297d0:	e0bfe445 	stb	r2,-111(fp)
      dprintf("ChronOS API call failure, unable to identify task!");
      panic("TK_OSTaskQuery");
      return 0;
   }
   
   return task_prio;
 82297d4:	e0bfe443 	ldbu	r2,-111(fp)
 82297d8:	00000706 	br	82297f8 <TK_OSTaskQuery+0x58>
   {
      task_prio = task_data.OSTCBPrio;
   }
   else
   {
      dprintf("ChronOS API call failure, unable to identify task!");
 82297dc:	01020974 	movhi	r4,2085
 82297e0:	2101c004 	addi	r4,r4,1792
 82297e4:	82033a00 	call	82033a0 <printf>
      panic("TK_OSTaskQuery");
 82297e8:	01020974 	movhi	r4,2085
 82297ec:	2101cd04 	addi	r4,r4,1844
 82297f0:	8228c480 	call	8228c48 <panic>
      return 0;
 82297f4:	0005883a 	mov	r2,zero
   }
   
   return task_prio;
}
 82297f8:	e037883a 	mov	sp,fp
 82297fc:	dfc00117 	ldw	ra,4(sp)
 8229800:	df000017 	ldw	fp,0(sp)
 8229804:	dec00204 	addi	sp,sp,8
 8229808:	f800283a 	ret

0822980c <tk_yield>:



void
tk_yield(void)
{
 822980c:	defffe04 	addi	sp,sp,-8
 8229810:	dfc00115 	stw	ra,4(sp)
 8229814:	df000015 	stw	fp,0(sp)
 8229818:	d839883a 	mov	fp,sp
   /* To ensure cycles to the lower priority tasks we should really
    * delay by two ticks, but that really hurts performance on some
    * long-tick targets. One tick works better overall....
    */
   OSTimeDly(1);
 822981c:	01000044 	movi	r4,1
 8229820:	821bed80 	call	821bed8 <OSTimeDly>
}
 8229824:	0001883a 	nop
 8229828:	e037883a 	mov	sp,fp
 822982c:	dfc00117 	ldw	ra,4(sp)
 8229830:	df000017 	ldw	fp,0(sp)
 8229834:	dec00204 	addi	sp,sp,8
 8229838:	f800283a 	ret

0822983c <tk_stats>:
extern struct inet_taskinfo * nettask;
extern int num_net_tasks;

int
tk_stats(void * pio)
{
 822983c:	deffef04 	addi	sp,sp,-68
 8229840:	dfc01015 	stw	ra,64(sp)
 8229844:	df000f15 	stw	fp,60(sp)
 8229848:	df000f04 	addi	fp,sp,60
 822984c:	e13fff15 	stw	r4,-4(fp)
   int      stackuse;
   char     name[OS_TASK_NAME_SIZE+1];
   INT8U    err;
   

   ns_printf(pio, "ChronOS RTOS stats:\n");
 8229850:	01420974 	movhi	r5,2085
 8229854:	2941d104 	addi	r5,r5,1860
 8229858:	e13fff17 	ldw	r4,-4(fp)
 822985c:	8228e600 	call	8228e60 <ns_printf>

#ifdef NO_INICHE_EXTENSIONS
   ns_printf(pio, "Context switches; Delay:  %lu\n",
 8229860:	d0a07017 	ldw	r2,-32320(gp)
 8229864:	100d883a 	mov	r6,r2
 8229868:	01420974 	movhi	r5,2085
 822986c:	2941d704 	addi	r5,r5,1884
 8229870:	e13fff17 	ldw	r4,-4(fp)
 8229874:	8228e600 	call	8228e60 <ns_printf>
#else
   ns_printf(pio, "Context switches; Delay:  %lu, Interrupt: %lu\n",
      OSCtxSwCtr, OSCtxIntCtr);
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");
 8229878:	01420974 	movhi	r5,2085
 822987c:	2941df04 	addi	r5,r5,1916
 8229880:	e13fff17 	ldw	r4,-4(fp)
 8229884:	8228e600 	call	8228e60 <ns_printf>

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 8229888:	e03ff215 	stw	zero,-56(fp)
 822988c:	00005406 	br	82299e0 <tk_stats+0x1a4>
   {
      /* get pointer to TCB and see if entry is in use and not a mutex */
      tcb = OSTCBPrioTbl[t];
 8229890:	008209b4 	movhi	r2,2086
 8229894:	10b6a904 	addi	r2,r2,-9564
 8229898:	e0fff217 	ldw	r3,-56(fp)
 822989c:	18c7883a 	add	r3,r3,r3
 82298a0:	18c7883a 	add	r3,r3,r3
 82298a4:	10c5883a 	add	r2,r2,r3
 82298a8:	10800017 	ldw	r2,0(r2)
 82298ac:	e0bff415 	stw	r2,-48(fp)
      if ((tcb == NULL) || (tcb == (OS_TCB *)1))
 82298b0:	e0bff417 	ldw	r2,-48(fp)
 82298b4:	10004626 	beq	r2,zero,82299d0 <tk_stats+0x194>
 82298b8:	e0bff417 	ldw	r2,-48(fp)
 82298bc:	10800058 	cmpnei	r2,r2,1
 82298c0:	10004326 	beq	r2,zero,82299d0 <tk_stats+0x194>
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);
 82298c4:	e0bff417 	ldw	r2,-48(fp)
 82298c8:	10800c83 	ldbu	r2,50(r2)
 82298cc:	10803fcc 	andi	r2,r2,255
 82298d0:	e13ffe44 	addi	r4,fp,-7
 82298d4:	e0fff604 	addi	r3,fp,-40
 82298d8:	200d883a 	mov	r6,r4
 82298dc:	180b883a 	mov	r5,r3
 82298e0:	1009883a 	mov	r4,r2
 82298e4:	821b4800 	call	821b480 <OSTaskNameGet>

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
                     name, tcb->OSTCBPrio, tcb->OSTCBStat);
 82298e8:	e0bff417 	ldw	r2,-48(fp)
 82298ec:	10800c83 	ldbu	r2,50(r2)
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
 82298f0:	11003fcc 	andi	r4,r2,255
                     name, tcb->OSTCBPrio, tcb->OSTCBStat);
 82298f4:	e0bff417 	ldw	r2,-48(fp)
 82298f8:	10800c03 	ldbu	r2,48(r2)
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
 82298fc:	10803fcc 	andi	r2,r2,255
 8229900:	e0fff604 	addi	r3,fp,-40
 8229904:	d8800015 	stw	r2,0(sp)
 8229908:	200f883a 	mov	r7,r4
 822990c:	180d883a 	mov	r6,r3
 8229910:	01420974 	movhi	r5,2085
 8229914:	2941ef04 	addi	r5,r5,1980
 8229918:	e13fff17 	ldw	r4,-4(fp)
 822991c:	8228e600 	call	8228e60 <ns_printf>
      /* Find lowest non-zero value in stack so we can estimate the
       * unused portion. Subtracting this from size gives us the used
       * portion of the stack.
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
 8229920:	e0bff417 	ldw	r2,-48(fp)
 8229924:	10800217 	ldw	r2,8(r2)
 8229928:	10002426 	beq	r2,zero,82299bc <tk_stats+0x180>
 822992c:	e0bff417 	ldw	r2,-48(fp)
 8229930:	10800317 	ldw	r2,12(r2)
 8229934:	10002126 	beq	r2,zero,82299bc <tk_stats+0x180>
      {
         sp = tcb->OSTCBStkBottom + 1;
 8229938:	e0bff417 	ldw	r2,-48(fp)
 822993c:	10800217 	ldw	r2,8(r2)
 8229940:	10800104 	addi	r2,r2,4
 8229944:	e0bff315 	stw	r2,-52(fp)
         while(*sp == 0)
 8229948:	00000306 	br	8229958 <tk_stats+0x11c>
            sp++;
 822994c:	e0bff317 	ldw	r2,-52(fp)
 8229950:	10800104 	addi	r2,r2,4
 8229954:	e0bff315 	stw	r2,-52(fp)
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
      {
         sp = tcb->OSTCBStkBottom + 1;
         while(*sp == 0)
 8229958:	e0bff317 	ldw	r2,-52(fp)
 822995c:	10800017 	ldw	r2,0(r2)
 8229960:	103ffa26 	beq	r2,zero,822994c <tk_stats+0x110>
            sp++;
         /* This OS traditionally keeps the size in OS_STK (int) units rather
          * than bytes, so convert back to bytes for display.
          */
         stackuse = (tcb->OSTCBStkSize - (sp - tcb->OSTCBStkBottom)) * sizeof(OS_STK);
 8229964:	e0bff417 	ldw	r2,-48(fp)
 8229968:	10800317 	ldw	r2,12(r2)
 822996c:	e0fff317 	ldw	r3,-52(fp)
 8229970:	e13ff417 	ldw	r4,-48(fp)
 8229974:	21000217 	ldw	r4,8(r4)
 8229978:	1907c83a 	sub	r3,r3,r4
 822997c:	1807d0ba 	srai	r3,r3,2
 8229980:	10c5c83a 	sub	r2,r2,r3
 8229984:	1085883a 	add	r2,r2,r2
 8229988:	1085883a 	add	r2,r2,r2
 822998c:	e0bff515 	stw	r2,-44(fp)
         ns_printf(pio, "%6d,      %6d\n",
            tcb->OSTCBStkSize * sizeof(OS_STK),  stackuse);
 8229990:	e0bff417 	ldw	r2,-48(fp)
 8229994:	10800317 	ldw	r2,12(r2)
            sp++;
         /* This OS traditionally keeps the size in OS_STK (int) units rather
          * than bytes, so convert back to bytes for display.
          */
         stackuse = (tcb->OSTCBStkSize - (sp - tcb->OSTCBStkBottom)) * sizeof(OS_STK);
         ns_printf(pio, "%6d,      %6d\n",
 8229998:	1085883a 	add	r2,r2,r2
 822999c:	1085883a 	add	r2,r2,r2
 82299a0:	e1fff517 	ldw	r7,-44(fp)
 82299a4:	100d883a 	mov	r6,r2
 82299a8:	01420974 	movhi	r5,2085
 82299ac:	2941f704 	addi	r5,r5,2012
 82299b0:	e13fff17 	ldw	r4,-4(fp)
 82299b4:	8228e600 	call	8228e60 <ns_printf>
 82299b8:	00000606 	br	82299d4 <tk_stats+0x198>
            tcb->OSTCBStkSize * sizeof(OS_STK),  stackuse);
      }
      else
#endif
      {
         ns_printf(pio, "No stack data\n");
 82299bc:	01420974 	movhi	r5,2085
 82299c0:	2941fb04 	addi	r5,r5,2028
 82299c4:	e13fff17 	ldw	r4,-4(fp)
 82299c8:	8228e600 	call	8228e60 <ns_printf>
 82299cc:	00000106 	br	82299d4 <tk_stats+0x198>
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
   {
      /* get pointer to TCB and see if entry is in use and not a mutex */
      tcb = OSTCBPrioTbl[t];
      if ((tcb == NULL) || (tcb == (OS_TCB *)1))
         continue;
 82299d0:	0001883a 	nop
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 82299d4:	e0bff217 	ldw	r2,-56(fp)
 82299d8:	10800044 	addi	r2,r2,1
 82299dc:	e0bff215 	stw	r2,-56(fp)
 82299e0:	e0bff217 	ldw	r2,-56(fp)
 82299e4:	10800550 	cmplti	r2,r2,21
 82299e8:	103fa91e 	bne	r2,zero,8229890 <tk_stats+0x54>
      {
         ns_printf(pio, "No stack data\n");
      }
   }

   ns_printf(pio, "tcp_sleep_count = %lu, tcp_wakeup_count = %lu\n",
 82299ec:	d0a0a317 	ldw	r2,-32116(gp)
 82299f0:	d0e0a417 	ldw	r3,-32112(gp)
 82299f4:	180f883a 	mov	r7,r3
 82299f8:	100d883a 	mov	r6,r2
 82299fc:	01420974 	movhi	r5,2085
 8229a00:	2941ff04 	addi	r5,r5,2044
 8229a04:	e13fff17 	ldw	r4,-4(fp)
 8229a08:	8228e600 	call	8228e60 <ns_printf>
                  tcp_sleep_count, tcp_wakeup_count);
   ns_printf(pio, "global_TCPwakeup_setIndx = %d, tcp_sleep_timeout = %lu\n",
 8229a0c:	d0a0a717 	ldw	r2,-32100(gp)
 8229a10:	d0e08e17 	ldw	r3,-32200(gp)
 8229a14:	180f883a 	mov	r7,r3
 8229a18:	100d883a 	mov	r6,r2
 8229a1c:	01420974 	movhi	r5,2085
 8229a20:	29420b04 	addi	r5,r5,2092
 8229a24:	e13fff17 	ldw	r4,-4(fp)
 8229a28:	8228e600 	call	8228e60 <ns_printf>
                  global_TCPwakeup_setIndx, tcp_sleep_timeout);

   return 0;
 8229a2c:	0005883a 	mov	r2,zero
}
 8229a30:	e037883a 	mov	sp,fp
 8229a34:	dfc00117 	ldw	ra,4(sp)
 8229a38:	df000017 	ldw	fp,0(sp)
 8229a3c:	dec00204 	addi	sp,sp,8
 8229a40:	f800283a 	ret

08229a44 <dhc_get_srv_ipaddr>:
 * RETURNS: 
 */

ip_addr 
dhc_get_srv_ipaddr(u_char *options /* after magic cookie */) 
{
 8229a44:	defffa04 	addi	sp,sp,-24
 8229a48:	dfc00515 	stw	ra,20(sp)
 8229a4c:	df000415 	stw	fp,16(sp)
 8229a50:	df000404 	addi	fp,sp,16
 8229a54:	e13fff15 	stw	r4,-4(fp)
    u_char * opts;
    u_char   optlen;
   ip_addr srv_ipaddr = 0;
 8229a58:	e03ffc15 	stw	zero,-16(fp)

   if ((opts = find_opt(DHOP_SERVER, options)) != NULL) 
 8229a5c:	e17fff17 	ldw	r5,-4(fp)
 8229a60:	01000d84 	movi	r4,54
 8229a64:	822c6900 	call	822c690 <find_opt>
 8229a68:	e0bffd15 	stw	r2,-12(fp)
 8229a6c:	e0bffd17 	ldw	r2,-12(fp)
 8229a70:	10001026 	beq	r2,zero,8229ab4 <dhc_get_srv_ipaddr+0x70>
   {
      opts++;
 8229a74:	e0bffd17 	ldw	r2,-12(fp)
 8229a78:	10800044 	addi	r2,r2,1
 8229a7c:	e0bffd15 	stw	r2,-12(fp)
      optlen = *opts;
 8229a80:	e0bffd17 	ldw	r2,-12(fp)
 8229a84:	10800003 	ldbu	r2,0(r2)
 8229a88:	e0bffe05 	stb	r2,-8(fp)
      opts++;
 8229a8c:	e0bffd17 	ldw	r2,-12(fp)
 8229a90:	10800044 	addi	r2,r2,1
 8229a94:	e0bffd15 	stw	r2,-12(fp)
      srv_ipaddr = dh_getlong(opts);
 8229a98:	e13ffd17 	ldw	r4,-12(fp)
 8229a9c:	822b9f40 	call	822b9f4 <dh_getlong>
 8229aa0:	e0bffc15 	stw	r2,-16(fp)
      opts += optlen;
 8229aa4:	e0bffe03 	ldbu	r2,-8(fp)
 8229aa8:	e0fffd17 	ldw	r3,-12(fp)
 8229aac:	1885883a 	add	r2,r3,r2
 8229ab0:	e0bffd15 	stw	r2,-12(fp)
   }

   return (srv_ipaddr);
 8229ab4:	e0bffc17 	ldw	r2,-16(fp)
} 
 8229ab8:	e037883a 	mov	sp,fp
 8229abc:	dfc00117 	ldw	ra,4(sp)
 8229ac0:	df000017 	ldw	fp,0(sp)
 8229ac4:	dec00204 	addi	sp,sp,8
 8229ac8:	f800283a 	ret

08229acc <dhc_init>:
 * RETURNS: Returns 0 if OK, else negative error code from net.h file 
 */

int
dhc_init(void)
{
 8229acc:	defffc04 	addi	sp,sp,-16
 8229ad0:	dfc00315 	stw	ra,12(sp)
 8229ad4:	df000215 	stw	fp,8(sp)
 8229ad8:	df000204 	addi	fp,sp,8
   int   i;

   /* open UDP connection to receive incoming DHCP replys */
   dhc_conn = udp_open(0L,    /* wildcard foriegn host */
 8229adc:	00bfff44 	movi	r2,-3
 8229ae0:	d8800015 	stw	r2,0(sp)
 8229ae4:	01c208f4 	movhi	r7,2083
 8229ae8:	39e6f104 	addi	r7,r7,-25660
 8229aec:	01801104 	movi	r6,68
 8229af0:	014010c4 	movi	r5,67
 8229af4:	0009883a 	mov	r4,zero
 8229af8:	822d12c0 	call	822d12c <udp_open>
 8229afc:	d0a08f15 	stw	r2,-32196(gp)
      BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT,
      dhc_upcall, DHCPDATA);

   if (!dhc_conn)
 8229b00:	d0a08f17 	ldw	r2,-32196(gp)
 8229b04:	1000021e 	bne	r2,zero,8229b10 <dhc_init+0x44>
      return ENP_RESOURCE;
 8229b08:	00bffa84 	movi	r2,-22
 8229b0c:	00001606 	br	8229b68 <dhc_init+0x9c>

   for (i = 0; i < MAXNETS; i++)
 8229b10:	e03fff15 	stw	zero,-4(fp)
 8229b14:	00001006 	br	8229b58 <dhc_init+0x8c>
   {
      dhc_states[i].state = DHCS_UNUSED;
 8229b18:	008209b4 	movhi	r2,2086
 8229b1c:	10b84104 	addi	r2,r2,-7932
 8229b20:	e0ffff17 	ldw	r3,-4(fp)
 8229b24:	18c00f24 	muli	r3,r3,60
 8229b28:	10c5883a 	add	r2,r2,r3
 8229b2c:	10000015 	stw	zero,0(r2)
      dhc_states[i].tries = 0;
 8229b30:	008209b4 	movhi	r2,2086
 8229b34:	10b84104 	addi	r2,r2,-7932
 8229b38:	e0ffff17 	ldw	r3,-4(fp)
 8229b3c:	18c00f24 	muli	r3,r3,60
 8229b40:	10c5883a 	add	r2,r2,r3
 8229b44:	10800104 	addi	r2,r2,4
 8229b48:	10000015 	stw	zero,0(r2)
      dhc_upcall, DHCPDATA);

   if (!dhc_conn)
      return ENP_RESOURCE;

   for (i = 0; i < MAXNETS; i++)
 8229b4c:	e0bfff17 	ldw	r2,-4(fp)
 8229b50:	10800044 	addi	r2,r2,1
 8229b54:	e0bfff15 	stw	r2,-4(fp)
 8229b58:	e0bfff17 	ldw	r2,-4(fp)
 8229b5c:	10800110 	cmplti	r2,r2,4
 8229b60:	103fed1e 	bne	r2,zero,8229b18 <dhc_init+0x4c>
   {
      dhc_states[i].state = DHCS_UNUSED;
      dhc_states[i].tries = 0;
   }

   return 0;
 8229b64:	0005883a 	mov	r2,zero
}
 8229b68:	e037883a 	mov	sp,fp
 8229b6c:	dfc00117 	ldw	ra,4(sp)
 8229b70:	df000017 	ldw	fp,0(sp)
 8229b74:	dec00204 	addi	sp,sp,8
 8229b78:	f800283a 	ret

08229b7c <dhc_set_callback>:
 * RETURNS: 
 */

void
dhc_set_callback(int iface, int (*routine)(int,int) )
{
 8229b7c:	defffd04 	addi	sp,sp,-12
 8229b80:	df000215 	stw	fp,8(sp)
 8229b84:	df000204 	addi	fp,sp,8
 8229b88:	e13ffe15 	stw	r4,-8(fp)
 8229b8c:	e17fff15 	stw	r5,-4(fp)
   dhc_states[iface].callback = routine;
 8229b90:	008209b4 	movhi	r2,2086
 8229b94:	10b84104 	addi	r2,r2,-7932
 8229b98:	e0fffe17 	ldw	r3,-8(fp)
 8229b9c:	18c00f24 	muli	r3,r3,60
 8229ba0:	10c5883a 	add	r2,r2,r3
 8229ba4:	10800e04 	addi	r2,r2,56
 8229ba8:	e0ffff17 	ldw	r3,-4(fp)
 8229bac:	10c00015 	stw	r3,0(r2)
}
 8229bb0:	0001883a 	nop
 8229bb4:	e037883a 	mov	sp,fp
 8229bb8:	df000017 	ldw	fp,0(sp)
 8229bbc:	dec00104 	addi	sp,sp,4
 8229bc0:	f800283a 	ret

08229bc4 <dhc_upcall>:
 * returned
 */

int
dhc_upcall(PACKET pkt, void * data)
{
 8229bc4:	defff504 	addi	sp,sp,-44
 8229bc8:	dfc00a15 	stw	ra,40(sp)
 8229bcc:	df000915 	stw	fp,36(sp)
 8229bd0:	dc000815 	stw	r16,32(sp)
 8229bd4:	df000904 	addi	fp,sp,36
 8229bd8:	e13ffd15 	stw	r4,-12(fp)
 8229bdc:	e17ffe15 	stw	r5,-8(fp)
   struct bootp * bp;
   int      len      =  pkt->nb_plen;  /* len of UDP data - the bootp/dhcp struct */
 8229be0:	e0bffd17 	ldw	r2,-12(fp)
 8229be4:	10800417 	ldw	r2,16(r2)
 8229be8:	e0bff815 	stw	r2,-32(fp)
   int      dhcptype =  0;    /* DHCP type - not valid if bootp */
 8229bec:	e03ff715 	stw	zero,-36(fp)
   int      e;
   int      iface;
   u_char * opts;          /* scratch options pointer */

   if (data != DHCPDATA)
 8229bf0:	e0bffe17 	ldw	r2,-8(fp)
 8229bf4:	10bfff60 	cmpeqi	r2,r2,-3
 8229bf8:	1000031e 	bne	r2,zero,8229c08 <dhc_upcall+0x44>
   {
      dtrap();
 8229bfc:	822d5940 	call	822d594 <dtrap>
      return ENP_LOGIC;    /* internal logic error */
 8229c00:	00bffd44 	movi	r2,-11
 8229c04:	0001d506 	br	822a35c <dhc_upcall+0x798>
   }

   /* punt if packet didn't come in a net we sent on */
   iface = net_num(pkt->net);
 8229c08:	e0bffd17 	ldw	r2,-12(fp)
 8229c0c:	10800617 	ldw	r2,24(r2)
 8229c10:	1009883a 	mov	r4,r2
 8229c14:	8226c680 	call	8226c68 <if_netnumber>
 8229c18:	e0bff915 	stw	r2,-28(fp)
   if (dhc_states[iface].state == DHCS_UNUSED)
 8229c1c:	008209b4 	movhi	r2,2086
 8229c20:	10b84104 	addi	r2,r2,-7932
 8229c24:	e0fff917 	ldw	r3,-28(fp)
 8229c28:	18c00f24 	muli	r3,r3,60
 8229c2c:	10c5883a 	add	r2,r2,r3
 8229c30:	10800017 	ldw	r2,0(r2)
 8229c34:	1000021e 	bne	r2,zero,8229c40 <dhc_upcall+0x7c>
      return ENP_NOT_MINE;
 8229c38:	00800084 	movi	r2,2
 8229c3c:	0001c706 	br	822a35c <dhc_upcall+0x798>

   bp = (struct bootp *)pkt->nb_prot;
 8229c40:	e0bffd17 	ldw	r2,-12(fp)
 8229c44:	10800317 	ldw	r2,12(r2)
 8229c48:	e0bffa15 	stw	r2,-24(fp)

   /*   Validate various fields   */
   if ((len < (sizeof(struct bootp)-BOOTP_OPTSIZE) ) || 
 8229c4c:	e0bff817 	ldw	r2,-32(fp)
 8229c50:	10803b30 	cmpltui	r2,r2,236
 8229c54:	10000b1e 	bne	r2,zero,8229c84 <dhc_upcall+0xc0>
       (bp->op != BOOTREPLY) ||
 8229c58:	e0bffa17 	ldw	r2,-24(fp)
 8229c5c:	10800003 	ldbu	r2,0(r2)
      return ENP_NOT_MINE;

   bp = (struct bootp *)pkt->nb_prot;

   /*   Validate various fields   */
   if ((len < (sizeof(struct bootp)-BOOTP_OPTSIZE) ) || 
 8229c60:	10803fcc 	andi	r2,r2,255
 8229c64:	10800098 	cmpnei	r2,r2,2
 8229c68:	1000061e 	bne	r2,zero,8229c84 <dhc_upcall+0xc0>
       (bp->op != BOOTREPLY) ||
       (*(u_long*)(&bp->options) != RFC1084_MAGIC_COOKIE))
 8229c6c:	e0bffa17 	ldw	r2,-24(fp)
 8229c70:	10803b04 	addi	r2,r2,236
 8229c74:	10c00017 	ldw	r3,0(r2)

   bp = (struct bootp *)pkt->nb_prot;

   /*   Validate various fields   */
   if ((len < (sizeof(struct bootp)-BOOTP_OPTSIZE) ) || 
       (bp->op != BOOTREPLY) ||
 8229c78:	0098d534 	movhi	r2,25428
 8229c7c:	10a098c4 	addi	r2,r2,-32157
 8229c80:	18800626 	beq	r3,r2,8229c9c <dhc_upcall+0xd8>
       (*(u_long*)(&bp->options) != RFC1084_MAGIC_COOKIE))
   {
      dtrap();
 8229c84:	822d5940 	call	822d594 <dtrap>
      dsc_errors++;
 8229c88:	d0a09017 	ldw	r2,-32192(gp)
 8229c8c:	10800044 	addi	r2,r2,1
 8229c90:	d0a09015 	stw	r2,-32192(gp)
      return ENP_NOT_MINE;
 8229c94:	00800084 	movi	r2,2
 8229c98:	0001b006 	br	822a35c <dhc_upcall+0x798>
   }

   /* punt offers or replys which are not for me */
   if(MEMCMP(bp->chaddr, pkt->net->mib.ifPhysAddress, pkt->net->n_hal))
 8229c9c:	e0bffa17 	ldw	r2,-24(fp)
 8229ca0:	10c00704 	addi	r3,r2,28
 8229ca4:	e0bffd17 	ldw	r2,-12(fp)
 8229ca8:	10800617 	ldw	r2,24(r2)
 8229cac:	11001717 	ldw	r4,92(r2)
 8229cb0:	e0bffd17 	ldw	r2,-12(fp)
 8229cb4:	10800617 	ldw	r2,24(r2)
 8229cb8:	10801117 	ldw	r2,68(r2)
 8229cbc:	100d883a 	mov	r6,r2
 8229cc0:	200b883a 	mov	r5,r4
 8229cc4:	1809883a 	mov	r4,r3
 8229cc8:	820c5dc0 	call	820c5dc <memcmp>
 8229ccc:	10000226 	beq	r2,zero,8229cd8 <dhc_upcall+0x114>
      return ENP_NOT_MINE;    /* not an error, just ignore it */
 8229cd0:	00800084 	movi	r2,2
 8229cd4:	0001a106 	br	822a35c <dhc_upcall+0x798>

   /* see if it's full DHCP or plain bootp by looking for dhcp type option */
   opts = find_opt(DHOP_TYPE ,&bp->options[4]);
 8229cd8:	e0bffa17 	ldw	r2,-24(fp)
 8229cdc:	10803c04 	addi	r2,r2,240
 8229ce0:	100b883a 	mov	r5,r2
 8229ce4:	01000d44 	movi	r4,53
 8229ce8:	822c6900 	call	822c690 <find_opt>
 8229cec:	e0bffb15 	stw	r2,-20(fp)
   if (opts && *opts == DHOP_TYPE)
 8229cf0:	e0bffb17 	ldw	r2,-20(fp)
 8229cf4:	10001026 	beq	r2,zero,8229d38 <dhc_upcall+0x174>
 8229cf8:	e0bffb17 	ldw	r2,-20(fp)
 8229cfc:	10800003 	ldbu	r2,0(r2)
 8229d00:	10803fcc 	andi	r2,r2,255
 8229d04:	10800d58 	cmpnei	r2,r2,53
 8229d08:	10000b1e 	bne	r2,zero,8229d38 <dhc_upcall+0x174>
   {
      dhcptype = *(opts+2);
 8229d0c:	e0bffb17 	ldw	r2,-20(fp)
 8229d10:	10800084 	addi	r2,r2,2
 8229d14:	10800003 	ldbu	r2,0(r2)
 8229d18:	10803fcc 	andi	r2,r2,255
 8229d1c:	e0bff715 	stw	r2,-36(fp)
      bp->op |= ISDHCP;       /* tag packet for isdhcp() macro */
 8229d20:	e0bffa17 	ldw	r2,-24(fp)
 8229d24:	10800003 	ldbu	r2,0(r2)
 8229d28:	10800114 	ori	r2,r2,4
 8229d2c:	1007883a 	mov	r3,r2
 8229d30:	e0bffa17 	ldw	r2,-24(fp)
 8229d34:	10c00005 	stb	r3,0(r2)
   }

   if (isdhcp(bp))
 8229d38:	e0bffa17 	ldw	r2,-24(fp)
 8229d3c:	10800003 	ldbu	r2,0(r2)
 8229d40:	10803fcc 	andi	r2,r2,255
 8229d44:	1080010c 	andi	r2,r2,4
 8229d48:	10016326 	beq	r2,zero,822a2d8 <dhc_upcall+0x714>
   {
      switch (dhcptype)
 8229d4c:	e0bff717 	ldw	r2,-36(fp)
 8229d50:	10c00148 	cmpgei	r3,r2,5
 8229d54:	1800051e 	bne	r3,zero,8229d6c <dhc_upcall+0x1a8>
 8229d58:	10c000c8 	cmpgei	r3,r2,3
 8229d5c:	1800051e 	bne	r3,zero,8229d74 <dhc_upcall+0x1b0>
 8229d60:	10800060 	cmpeqi	r2,r2,1
 8229d64:	1000031e 	bne	r2,zero,8229d74 <dhc_upcall+0x1b0>
 8229d68:	00000706 	br	8229d88 <dhc_upcall+0x1c4>
 8229d6c:	108001e0 	cmpeqi	r2,r2,7
 8229d70:	10000526 	beq	r2,zero,8229d88 <dhc_upcall+0x1c4>
      {
      case DHCP_DISCOVER:
      case DHCP_REQUEST:
      case DHCP_DECLINE:
      case DHCP_RELEASE:
         dsc_errors++;     /* these should only be upcalled to a server */
 8229d74:	d0a09017 	ldw	r2,-32192(gp)
 8229d78:	10800044 	addi	r2,r2,1
 8229d7c:	d0a09015 	stw	r2,-32192(gp)
         return ENP_NOT_MINE;
 8229d80:	00800084 	movi	r2,2
 8229d84:	00017506 	br	822a35c <dhc_upcall+0x798>
      }

      switch (dhc_states[iface].state)
 8229d88:	008209b4 	movhi	r2,2086
 8229d8c:	10b84104 	addi	r2,r2,-7932
 8229d90:	e0fff917 	ldw	r3,-28(fp)
 8229d94:	18c00f24 	muli	r3,r3,60
 8229d98:	10c5883a 	add	r2,r2,r3
 8229d9c:	10800017 	ldw	r2,0(r2)
 8229da0:	10c00268 	cmpgeui	r3,r2,9
 8229da4:	1801431e 	bne	r3,zero,822a2b4 <dhc_upcall+0x6f0>
 8229da8:	100690ba 	slli	r3,r2,2
 8229dac:	008208f4 	movhi	r2,2083
 8229db0:	10a77004 	addi	r2,r2,-25152
 8229db4:	1885883a 	add	r2,r3,r2
 8229db8:	10800017 	ldw	r2,0(r2)
 8229dbc:	1000683a 	jmp	r2
 8229dc0:	0822a2b4 	orhi	zero,at,35466
 8229dc4:	08229de4 	muli	zero,at,-30089
 8229dc8:	08229de4 	muli	zero,at,-30089
 8229dcc:	0822a018 	cmpnei	zero,at,-30080
 8229dd0:	08229df8 	rdprs	zero,at,-30089
 8229dd4:	08229f6c 	andhi	zero,at,35453
 8229dd8:	08229de4 	muli	zero,at,-30089
 8229ddc:	08229f6c 	andhi	zero,at,35453
 8229de0:	08229f6c 	andhi	zero,at,35453
      case DHCS_INITREBOOT:
         /* How can we receive any response when we never sent one */
      case DHCS_BOUND:
         /* If there are multiple DHCP Servers, and one of them is slow
            in responding, we might get OFFER pkts when are in BOUND state */
         dsc_errors++;     /* these should only be upcalled to a server */
 8229de4:	d0a09017 	ldw	r2,-32192(gp)
 8229de8:	10800044 	addi	r2,r2,1
 8229dec:	d0a09015 	stw	r2,-32192(gp)
         return ENP_NOT_MINE;
 8229df0:	00800084 	movi	r2,2
 8229df4:	00015906 	br	822a35c <dhc_upcall+0x798>
      case DHCS_SELECTING:
         /* We will respond to the first offer packet that we receive ) */
         if ( dhcptype == DHCP_OFFER ) /* got offer back from server */
 8229df8:	e0bff717 	ldw	r2,-36(fp)
 8229dfc:	10800098 	cmpnei	r2,r2,2
 8229e00:	10004f1e 	bne	r2,zero,8229f40 <dhc_upcall+0x37c>
         {
            dsc_offers++;
 8229e04:	d0a09217 	ldw	r2,-32184(gp)
 8229e08:	10800044 	addi	r2,r2,1
 8229e0c:	d0a09215 	stw	r2,-32184(gp)
            dhc_states[iface].srv_ipaddr = dhc_get_srv_ipaddr(&bp->options[4]);
 8229e10:	e0bffa17 	ldw	r2,-24(fp)
 8229e14:	10803c04 	addi	r2,r2,240
 8229e18:	1009883a 	mov	r4,r2
 8229e1c:	8229a440 	call	8229a44 <dhc_get_srv_ipaddr>
 8229e20:	1009883a 	mov	r4,r2
 8229e24:	008209b4 	movhi	r2,2086
 8229e28:	10b84104 	addi	r2,r2,-7932
 8229e2c:	e0fff917 	ldw	r3,-28(fp)
 8229e30:	18c00f24 	muli	r3,r3,60
 8229e34:	10c5883a 	add	r2,r2,r3
 8229e38:	10800d04 	addi	r2,r2,52
 8229e3c:	11000015 	stw	r4,0(r2)
            if (dhc_states[iface].srv_ipaddr == 0 )
 8229e40:	008209b4 	movhi	r2,2086
 8229e44:	10b84104 	addi	r2,r2,-7932
 8229e48:	e0fff917 	ldw	r3,-28(fp)
 8229e4c:	18c00f24 	muli	r3,r3,60
 8229e50:	10c5883a 	add	r2,r2,r3
 8229e54:	10800d04 	addi	r2,r2,52
 8229e58:	10800017 	ldw	r2,0(r2)
 8229e5c:	10000d1e 	bne	r2,zero,8229e94 <dhc_upcall+0x2d0>
            {
               dtrap(); /* didn't receive server-identifier option */
 8229e60:	822d5940 	call	822d594 <dtrap>
               dsc_errors++;
 8229e64:	d0a09017 	ldw	r2,-32192(gp)
 8229e68:	10800044 	addi	r2,r2,1
 8229e6c:	d0a09015 	stw	r2,-32192(gp)
               dhc_states[iface].srv_ipaddr = pkt->fhost;   /* Try using fhost */
 8229e70:	e0bffd17 	ldw	r2,-12(fp)
 8229e74:	10c00717 	ldw	r3,28(r2)
 8229e78:	008209b4 	movhi	r2,2086
 8229e7c:	10b84104 	addi	r2,r2,-7932
 8229e80:	e13ff917 	ldw	r4,-28(fp)
 8229e84:	21000f24 	muli	r4,r4,60
 8229e88:	1105883a 	add	r2,r2,r4
 8229e8c:	10800d04 	addi	r2,r2,52
 8229e90:	10c00015 	stw	r3,0(r2)
            }

            if (bp->hops)
 8229e94:	e0bffa17 	ldw	r2,-24(fp)
 8229e98:	108000c3 	ldbu	r2,3(r2)
 8229e9c:	10803fcc 	andi	r2,r2,255
 8229ea0:	10000a26 	beq	r2,zero,8229ecc <dhc_upcall+0x308>
            {
               /* OFFER is received via DHCP Relay Agent. Remember the
                * IP addr of DHCP Relay Agent, so that packets from other
                * DHCP Relay Agents can be discarded 
                */
               dhc_states[iface].rly_ipaddr = pkt->fhost;   /* Try using fhost */
 8229ea4:	e0bffd17 	ldw	r2,-12(fp)
 8229ea8:	10c00717 	ldw	r3,28(r2)
 8229eac:	008209b4 	movhi	r2,2086
 8229eb0:	10b84104 	addi	r2,r2,-7932
 8229eb4:	e13ff917 	ldw	r4,-28(fp)
 8229eb8:	21000f24 	muli	r4,r4,60
 8229ebc:	1105883a 	add	r2,r2,r4
 8229ec0:	10800c04 	addi	r2,r2,48
 8229ec4:	10c00015 	stw	r3,0(r2)
 8229ec8:	00000706 	br	8229ee8 <dhc_upcall+0x324>
            }
            else
               dhc_states[iface].rly_ipaddr = 0;
 8229ecc:	008209b4 	movhi	r2,2086
 8229ed0:	10b84104 	addi	r2,r2,-7932
 8229ed4:	e0fff917 	ldw	r3,-28(fp)
 8229ed8:	18c00f24 	muli	r3,r3,60
 8229edc:	10c5883a 	add	r2,r2,r3
 8229ee0:	10800c04 	addi	r2,r2,48
 8229ee4:	10000015 	stw	zero,0(r2)

            e = dhc_rx_offer(iface,bp,pkt->nb_plen);     /* send request */
 8229ee8:	e0bffd17 	ldw	r2,-12(fp)
 8229eec:	10800417 	ldw	r2,16(r2)
 8229ef0:	100d883a 	mov	r6,r2
 8229ef4:	e17ffa17 	ldw	r5,-24(fp)
 8229ef8:	e13ff917 	ldw	r4,-28(fp)
 8229efc:	822aa240 	call	822aa24 <dhc_rx_offer>
 8229f00:	e0bffc15 	stw	r2,-16(fp)
            if (e)
 8229f04:	e0bffc17 	ldw	r2,-16(fp)
 8229f08:	10000926 	beq	r2,zero,8229f30 <dhc_upcall+0x36c>
            {
               dsc_errors++;
 8229f0c:	d0a09017 	ldw	r2,-32192(gp)
 8229f10:	10800044 	addi	r2,r2,1
 8229f14:	d0a09015 	stw	r2,-32192(gp)
               dhc_set_state(iface,DHCS_INIT);
 8229f18:	01400044 	movi	r5,1
 8229f1c:	e13ff917 	ldw	r4,-28(fp)
 8229f20:	822c5e00 	call	822c5e0 <dhc_set_state>
               dtrap();
 8229f24:	822d5940 	call	822d594 <dtrap>
               return ENP_NOT_MINE;
 8229f28:	00800084 	movi	r2,2
 8229f2c:	00010b06 	br	822a35c <dhc_upcall+0x798>
            }
            else
               dhc_set_state(iface,DHCS_REQUESTING);
 8229f30:	01400144 	movi	r5,5
 8229f34:	e13ff917 	ldw	r4,-28(fp)
 8229f38:	822c5e00 	call	822c5e0 <dhc_set_state>
            dsc_errors++;
            if ( dhcptype == DHCP_NAK ) 
               dsc_naks++;
            return ENP_NOT_MINE;
         }
         break;
 8229f3c:	00010406 	br	822a350 <dhc_upcall+0x78c>
             * Report an error and remain in SELECTING state, so that 
             * an OFFER packet from another DHCP server can be 
             * accepted. If we timeout waiting for a OFFER packet, 
             * then dhc_second() will transition to DHCS_INIT state. 
             */
            dsc_errors++;
 8229f40:	d0a09017 	ldw	r2,-32192(gp)
 8229f44:	10800044 	addi	r2,r2,1
 8229f48:	d0a09015 	stw	r2,-32192(gp)
            if ( dhcptype == DHCP_NAK ) 
 8229f4c:	e0bff717 	ldw	r2,-36(fp)
 8229f50:	10800198 	cmpnei	r2,r2,6
 8229f54:	1000031e 	bne	r2,zero,8229f64 <dhc_upcall+0x3a0>
               dsc_naks++;
 8229f58:	d0a09817 	ldw	r2,-32160(gp)
 8229f5c:	10800044 	addi	r2,r2,1
 8229f60:	d0a09815 	stw	r2,-32160(gp)
            return ENP_NOT_MINE;
 8229f64:	00800084 	movi	r2,2
 8229f68:	0000fc06 	br	822a35c <dhc_upcall+0x798>
      case DHCS_RENEWING:
         /* If the ACK/NACK is not from the same server which sent 
          * the OFFER packet, then discard it. in DHCS_REBOOTING 
          * state, srv_ipaddr is 0. Hence don't check in that state 
          */
         if ( dhc_states[iface].srv_ipaddr != 
 8229f6c:	008209b4 	movhi	r2,2086
 8229f70:	10b84104 	addi	r2,r2,-7932
 8229f74:	e0fff917 	ldw	r3,-28(fp)
 8229f78:	18c00f24 	muli	r3,r3,60
 8229f7c:	10c5883a 	add	r2,r2,r3
 8229f80:	10800d04 	addi	r2,r2,52
 8229f84:	14000017 	ldw	r16,0(r2)
             dhc_get_srv_ipaddr(&bp->options[4]) )
 8229f88:	e0bffa17 	ldw	r2,-24(fp)
 8229f8c:	10803c04 	addi	r2,r2,240
 8229f90:	1009883a 	mov	r4,r2
 8229f94:	8229a440 	call	8229a44 <dhc_get_srv_ipaddr>
      case DHCS_RENEWING:
         /* If the ACK/NACK is not from the same server which sent 
          * the OFFER packet, then discard it. in DHCS_REBOOTING 
          * state, srv_ipaddr is 0. Hence don't check in that state 
          */
         if ( dhc_states[iface].srv_ipaddr != 
 8229f98:	80800526 	beq	r16,r2,8229fb0 <dhc_upcall+0x3ec>
             dhc_get_srv_ipaddr(&bp->options[4]) )
         {
            dsc_errors++;
 8229f9c:	d0a09017 	ldw	r2,-32192(gp)
 8229fa0:	10800044 	addi	r2,r2,1
 8229fa4:	d0a09015 	stw	r2,-32192(gp)
            return ENP_NOT_MINE;
 8229fa8:	00800084 	movi	r2,2
 8229fac:	0000eb06 	br	822a35c <dhc_upcall+0x798>
         }
         if (dhc_states[iface].rly_ipaddr &&
 8229fb0:	008209b4 	movhi	r2,2086
 8229fb4:	10b84104 	addi	r2,r2,-7932
 8229fb8:	e0fff917 	ldw	r3,-28(fp)
 8229fbc:	18c00f24 	muli	r3,r3,60
 8229fc0:	10c5883a 	add	r2,r2,r3
 8229fc4:	10800c04 	addi	r2,r2,48
 8229fc8:	10800017 	ldw	r2,0(r2)
 8229fcc:	10001226 	beq	r2,zero,822a018 <dhc_upcall+0x454>
            (dhc_states[iface].rly_ipaddr != pkt->fhost))
 8229fd0:	008209b4 	movhi	r2,2086
 8229fd4:	10b84104 	addi	r2,r2,-7932
 8229fd8:	e0fff917 	ldw	r3,-28(fp)
 8229fdc:	18c00f24 	muli	r3,r3,60
 8229fe0:	10c5883a 	add	r2,r2,r3
 8229fe4:	10800c04 	addi	r2,r2,48
 8229fe8:	10c00017 	ldw	r3,0(r2)
 8229fec:	e0bffd17 	ldw	r2,-12(fp)
 8229ff0:	10800717 	ldw	r2,28(r2)
             dhc_get_srv_ipaddr(&bp->options[4]) )
         {
            dsc_errors++;
            return ENP_NOT_MINE;
         }
         if (dhc_states[iface].rly_ipaddr &&
 8229ff4:	18800826 	beq	r3,r2,822a018 <dhc_upcall+0x454>
            (dhc_states[iface].rly_ipaddr != pkt->fhost))
         {
            dsc_rlyerrs++;
 8229ff8:	d0a09b17 	ldw	r2,-32148(gp)
 8229ffc:	10800044 	addi	r2,r2,1
 822a000:	d0a09b15 	stw	r2,-32148(gp)
            dsc_errors++;
 822a004:	d0a09017 	ldw	r2,-32192(gp)
 822a008:	10800044 	addi	r2,r2,1
 822a00c:	d0a09015 	stw	r2,-32192(gp)
            return ENP_NOT_MINE;
 822a010:	00800084 	movi	r2,2
 822a014:	0000d106 	br	822a35c <dhc_upcall+0x798>
         }
      case DHCS_REBOOTING:
         if ( dhcptype == DHCP_ACK )   /* Server OKed our request */
 822a018:	e0bff717 	ldw	r2,-36(fp)
 822a01c:	10800158 	cmpnei	r2,r2,5
 822a020:	1000851e 	bne	r2,zero,822a238 <dhc_upcall+0x674>
         {
            dsc_acks++;
 822a024:	d0a09417 	ldw	r2,-32176(gp)
 822a028:	10800044 	addi	r2,r2,1
 822a02c:	d0a09415 	stw	r2,-32176(gp)
            dhc_extract_opts(iface,&bp->options[4]);
 822a030:	e0bffa17 	ldw	r2,-24(fp)
 822a034:	10803c04 	addi	r2,r2,240
 822a038:	100b883a 	mov	r5,r2
 822a03c:	e13ff917 	ldw	r4,-28(fp)
 822a040:	822baa00 	call	822baa0 <dhc_extract_opts>
            if ( dhc_states[iface].lease == DHC_INFINITY )
 822a044:	008209b4 	movhi	r2,2086
 822a048:	10b84104 	addi	r2,r2,-7932
 822a04c:	e0fff917 	ldw	r3,-28(fp)
 822a050:	18c00f24 	muli	r3,r3,60
 822a054:	10c5883a 	add	r2,r2,r3
 822a058:	10800504 	addi	r2,r2,20
 822a05c:	10800017 	ldw	r2,0(r2)
 822a060:	10bfffd8 	cmpnei	r2,r2,-1
 822a064:	1000111e 	bne	r2,zero,822a0ac <dhc_upcall+0x4e8>
            {
               dhc_states[iface].t1 = DHC_INFINITY ;
 822a068:	008209b4 	movhi	r2,2086
 822a06c:	10b84104 	addi	r2,r2,-7932
 822a070:	e0fff917 	ldw	r3,-28(fp)
 822a074:	18c00f24 	muli	r3,r3,60
 822a078:	10c5883a 	add	r2,r2,r3
 822a07c:	10800604 	addi	r2,r2,24
 822a080:	00ffffc4 	movi	r3,-1
 822a084:	10c00015 	stw	r3,0(r2)
               dhc_states[iface].t2 = DHC_INFINITY ;
 822a088:	008209b4 	movhi	r2,2086
 822a08c:	10b84104 	addi	r2,r2,-7932
 822a090:	e0fff917 	ldw	r3,-28(fp)
 822a094:	18c00f24 	muli	r3,r3,60
 822a098:	10c5883a 	add	r2,r2,r3
 822a09c:	10800704 	addi	r2,r2,28
 822a0a0:	00ffffc4 	movi	r3,-1
 822a0a4:	10c00015 	stw	r3,0(r2)
 822a0a8:	00001f06 	br	822a128 <dhc_upcall+0x564>
            }
            else
            {
               dhc_states[iface].t1 = dhc_states[iface].lease/2     ;
 822a0ac:	008209b4 	movhi	r2,2086
 822a0b0:	10b84104 	addi	r2,r2,-7932
 822a0b4:	e0fff917 	ldw	r3,-28(fp)
 822a0b8:	18c00f24 	muli	r3,r3,60
 822a0bc:	10c5883a 	add	r2,r2,r3
 822a0c0:	10800504 	addi	r2,r2,20
 822a0c4:	10800017 	ldw	r2,0(r2)
 822a0c8:	1006d07a 	srli	r3,r2,1
 822a0cc:	008209b4 	movhi	r2,2086
 822a0d0:	10b84104 	addi	r2,r2,-7932
 822a0d4:	e13ff917 	ldw	r4,-28(fp)
 822a0d8:	21000f24 	muli	r4,r4,60
 822a0dc:	1105883a 	add	r2,r2,r4
 822a0e0:	10800604 	addi	r2,r2,24
 822a0e4:	10c00015 	stw	r3,0(r2)
               dhc_states[iface].t2 = (dhc_states[iface].lease/8)*7 ;
 822a0e8:	008209b4 	movhi	r2,2086
 822a0ec:	10b84104 	addi	r2,r2,-7932
 822a0f0:	e0fff917 	ldw	r3,-28(fp)
 822a0f4:	18c00f24 	muli	r3,r3,60
 822a0f8:	10c5883a 	add	r2,r2,r3
 822a0fc:	10800504 	addi	r2,r2,20
 822a100:	10800017 	ldw	r2,0(r2)
 822a104:	1004d0fa 	srli	r2,r2,3
 822a108:	10c001e4 	muli	r3,r2,7
 822a10c:	008209b4 	movhi	r2,2086
 822a110:	10b84104 	addi	r2,r2,-7932
 822a114:	e13ff917 	ldw	r4,-28(fp)
 822a118:	21000f24 	muli	r4,r4,60
 822a11c:	1105883a 	add	r2,r2,r4
 822a120:	10800704 	addi	r2,r2,28
 822a124:	10c00015 	stw	r3,0(r2)
            }
            dhc_states[iface].lease_start = cticks;   /* to calc lease expiry */
 822a128:	d0e0a817 	ldw	r3,-32096(gp)
 822a12c:	008209b4 	movhi	r2,2086
 822a130:	10b84104 	addi	r2,r2,-7932
 822a134:	e13ff917 	ldw	r4,-28(fp)
 822a138:	21000f24 	muli	r4,r4,60
 822a13c:	1105883a 	add	r2,r2,r4
 822a140:	10800804 	addi	r2,r2,32
 822a144:	10c00015 	stw	r3,0(r2)
            dhc_states[iface].srv_ipaddr = dhc_get_srv_ipaddr(&bp->options[4]); 
 822a148:	e0bffa17 	ldw	r2,-24(fp)
 822a14c:	10803c04 	addi	r2,r2,240
 822a150:	1009883a 	mov	r4,r2
 822a154:	8229a440 	call	8229a44 <dhc_get_srv_ipaddr>
 822a158:	1009883a 	mov	r4,r2
 822a15c:	008209b4 	movhi	r2,2086
 822a160:	10b84104 	addi	r2,r2,-7932
 822a164:	e0fff917 	ldw	r3,-28(fp)
 822a168:	18c00f24 	muli	r3,r3,60
 822a16c:	10c5883a 	add	r2,r2,r3
 822a170:	10800d04 	addi	r2,r2,52
 822a174:	11000015 	stw	r4,0(r2)
            if (dhc_states[iface].srv_ipaddr == 0 )
 822a178:	008209b4 	movhi	r2,2086
 822a17c:	10b84104 	addi	r2,r2,-7932
 822a180:	e0fff917 	ldw	r3,-28(fp)
 822a184:	18c00f24 	muli	r3,r3,60
 822a188:	10c5883a 	add	r2,r2,r3
 822a18c:	10800d04 	addi	r2,r2,52
 822a190:	10800017 	ldw	r2,0(r2)
 822a194:	10000d1e 	bne	r2,zero,822a1cc <dhc_upcall+0x608>
            {
               dtrap(); /* didn't receive server-identifier option */
 822a198:	822d5940 	call	822d594 <dtrap>
               dsc_errors++;
 822a19c:	d0a09017 	ldw	r2,-32192(gp)
 822a1a0:	10800044 	addi	r2,r2,1
 822a1a4:	d0a09015 	stw	r2,-32192(gp)
               dhc_states[iface].srv_ipaddr = pkt->fhost;   /* Try using fhost */
 822a1a8:	e0bffd17 	ldw	r2,-12(fp)
 822a1ac:	10c00717 	ldw	r3,28(r2)
 822a1b0:	008209b4 	movhi	r2,2086
 822a1b4:	10b84104 	addi	r2,r2,-7932
 822a1b8:	e13ff917 	ldw	r4,-28(fp)
 822a1bc:	21000f24 	muli	r4,r4,60
 822a1c0:	1105883a 	add	r2,r2,r4
 822a1c4:	10800d04 	addi	r2,r2,52
 822a1c8:	10c00015 	stw	r3,0(r2)
            }
            if (bp->hops)
 822a1cc:	e0bffa17 	ldw	r2,-24(fp)
 822a1d0:	108000c3 	ldbu	r2,3(r2)
 822a1d4:	10803fcc 	andi	r2,r2,255
 822a1d8:	10000a26 	beq	r2,zero,822a204 <dhc_upcall+0x640>
            {
               /* OFFER is received via DHCP Relay Agent. Remember the
                * IP addr of DHCP Relay Agent, so that packets from other
                * DHCP Relay Agents can be discarded 
                */
               dhc_states[iface].rly_ipaddr = pkt->fhost;   /* Try using fhost */
 822a1dc:	e0bffd17 	ldw	r2,-12(fp)
 822a1e0:	10c00717 	ldw	r3,28(r2)
 822a1e4:	008209b4 	movhi	r2,2086
 822a1e8:	10b84104 	addi	r2,r2,-7932
 822a1ec:	e13ff917 	ldw	r4,-28(fp)
 822a1f0:	21000f24 	muli	r4,r4,60
 822a1f4:	1105883a 	add	r2,r2,r4
 822a1f8:	10800c04 	addi	r2,r2,48
 822a1fc:	10c00015 	stw	r3,0(r2)
 822a200:	00000706 	br	822a220 <dhc_upcall+0x65c>
            }
            else
               dhc_states[iface].rly_ipaddr = 0;
 822a204:	008209b4 	movhi	r2,2086
 822a208:	10b84104 	addi	r2,r2,-7932
 822a20c:	e0fff917 	ldw	r3,-28(fp)
 822a210:	18c00f24 	muli	r3,r3,60
 822a214:	10c5883a 	add	r2,r2,r3
 822a218:	10800c04 	addi	r2,r2,48
 822a21c:	10000015 	stw	zero,0(r2)

            dhc_setip(iface);
 822a220:	e13ff917 	ldw	r4,-28(fp)
 822a224:	822b58c0 	call	822b58c <dhc_setip>
            dhc_set_state(iface,DHCS_BOUND);
 822a228:	01400184 	movi	r5,6
 822a22c:	e13ff917 	ldw	r4,-28(fp)
 822a230:	822c5e00 	call	822c5e0 <dhc_set_state>
             * error and discard it with no change to our state.
             */
            dsc_errors++;
            return ENP_NOT_MINE;
         }
         break;
 822a234:	00004606 	br	822a350 <dhc_upcall+0x78c>
               dhc_states[iface].rly_ipaddr = 0;

            dhc_setip(iface);
            dhc_set_state(iface,DHCS_BOUND);
         }
         else if ( dhcptype == DHCP_NAK ) /* Server denied our request */
 822a238:	e0bff717 	ldw	r2,-36(fp)
 822a23c:	10800198 	cmpnei	r2,r2,6
 822a240:	1000071e 	bne	r2,zero,822a260 <dhc_upcall+0x69c>
         {
            dhc_set_state(iface,DHCS_INIT);
 822a244:	01400044 	movi	r5,1
 822a248:	e13ff917 	ldw	r4,-28(fp)
 822a24c:	822c5e00 	call	822c5e0 <dhc_set_state>
            dsc_naks++;
 822a250:	d0a09817 	ldw	r2,-32160(gp)
 822a254:	10800044 	addi	r2,r2,1
 822a258:	d0a09815 	stw	r2,-32160(gp)
             * error and discard it with no change to our state.
             */
            dsc_errors++;
            return ENP_NOT_MINE;
         }
         break;
 822a25c:	00003c06 	br	822a350 <dhc_upcall+0x78c>
         {
            /* In REQUESTING state, we might receive a retransmitted
             * OFFER, which we should discard, but it's not an error,
             * so we log it.
             */
            if ((dhc_states[iface].state == DHCS_REQUESTING) &&
 822a260:	008209b4 	movhi	r2,2086
 822a264:	10b84104 	addi	r2,r2,-7932
 822a268:	e0fff917 	ldw	r3,-28(fp)
 822a26c:	18c00f24 	muli	r3,r3,60
 822a270:	10c5883a 	add	r2,r2,r3
 822a274:	10800017 	ldw	r2,0(r2)
 822a278:	10800158 	cmpnei	r2,r2,5
 822a27c:	1000081e 	bne	r2,zero,822a2a0 <dhc_upcall+0x6dc>
 822a280:	e0bff717 	ldw	r2,-36(fp)
 822a284:	10800098 	cmpnei	r2,r2,2
 822a288:	1000051e 	bne	r2,zero,822a2a0 <dhc_upcall+0x6dc>
                (dhcptype == DHCP_OFFER))
            {
               dsc_offers++;
 822a28c:	d0a09217 	ldw	r2,-32184(gp)
 822a290:	10800044 	addi	r2,r2,1
 822a294:	d0a09215 	stw	r2,-32184(gp)
               return ENP_NOT_MINE;
 822a298:	00800084 	movi	r2,2
 822a29c:	00002f06 	br	822a35c <dhc_upcall+0x798>
             * only receive ACK or NAK, and in REQUESTING state we
             * should only receive ACK or NAK or OFFER; these are
             * accounted for above, so we log whatever this is as an
             * error and discard it with no change to our state.
             */
            dsc_errors++;
 822a2a0:	d0a09017 	ldw	r2,-32192(gp)
 822a2a4:	10800044 	addi	r2,r2,1
 822a2a8:	d0a09015 	stw	r2,-32192(gp)
            return ENP_NOT_MINE;
 822a2ac:	00800084 	movi	r2,2
 822a2b0:	00002a06 	br	822a35c <dhc_upcall+0x798>
         }
         break;
      default:    /* bad state */
         dtrap();
 822a2b4:	822d5940 	call	822d594 <dtrap>
         dhc_set_state(iface,DHCS_INIT);
 822a2b8:	01400044 	movi	r5,1
 822a2bc:	e13ff917 	ldw	r4,-28(fp)
 822a2c0:	822c5e00 	call	822c5e0 <dhc_set_state>
         dsc_errors++;
 822a2c4:	d0a09017 	ldw	r2,-32192(gp)
 822a2c8:	10800044 	addi	r2,r2,1
 822a2cc:	d0a09015 	stw	r2,-32192(gp)
         return -1;
 822a2d0:	00bfffc4 	movi	r2,-1
 822a2d4:	00002106 	br	822a35c <dhc_upcall+0x798>
      }
   }
   else     /* plain bootp reply */
   {
      dsc_bpreplys++;
 822a2d8:	d0a09517 	ldw	r2,-32172(gp)
 822a2dc:	10800044 	addi	r2,r2,1
 822a2e0:	d0a09515 	stw	r2,-32172(gp)
      dhc_extract_opts(iface,&bp->options[4]);
 822a2e4:	e0bffa17 	ldw	r2,-24(fp)
 822a2e8:	10803c04 	addi	r2,r2,240
 822a2ec:	100b883a 	mov	r5,r2
 822a2f0:	e13ff917 	ldw	r4,-28(fp)
 822a2f4:	822baa00 	call	822baa0 <dhc_extract_opts>
      dhc_states[iface].ipaddr = bp->yiaddr;
 822a2f8:	e0bffa17 	ldw	r2,-24(fp)
 822a2fc:	10c00417 	ldw	r3,16(r2)
 822a300:	008209b4 	movhi	r2,2086
 822a304:	10b84104 	addi	r2,r2,-7932
 822a308:	e13ff917 	ldw	r4,-28(fp)
 822a30c:	21000f24 	muli	r4,r4,60
 822a310:	1105883a 	add	r2,r2,r4
 822a314:	10800904 	addi	r2,r2,36
 822a318:	10c00015 	stw	r3,0(r2)
      dhc_setip(iface);
 822a31c:	e13ff917 	ldw	r4,-28(fp)
 822a320:	822b58c0 	call	822b58c <dhc_setip>

      /* Set values so that DHCP State Machine remains happy */
      dhc_set_state(iface,DHCS_BOUND);
 822a324:	01400184 	movi	r5,6
 822a328:	e13ff917 	ldw	r4,-28(fp)
 822a32c:	822c5e00 	call	822c5e0 <dhc_set_state>
      dhc_states[iface].t1    = DHC_INFINITY ;
 822a330:	008209b4 	movhi	r2,2086
 822a334:	10b84104 	addi	r2,r2,-7932
 822a338:	e0fff917 	ldw	r3,-28(fp)
 822a33c:	18c00f24 	muli	r3,r3,60
 822a340:	10c5883a 	add	r2,r2,r3
 822a344:	10800604 	addi	r2,r2,24
 822a348:	00ffffc4 	movi	r3,-1
 822a34c:	10c00015 	stw	r3,0(r2)
   }

   udp_free(pkt);
 822a350:	e13ffd17 	ldw	r4,-12(fp)
 822a354:	82454c80 	call	82454c8 <udp_free>
   return 0;
 822a358:	0005883a 	mov	r2,zero
}
 822a35c:	e6ffff04 	addi	sp,fp,-4
 822a360:	dfc00217 	ldw	ra,8(sp)
 822a364:	df000117 	ldw	fp,4(sp)
 822a368:	dc000017 	ldw	r16,0(sp)
 822a36c:	dec00304 	addi	sp,sp,12
 822a370:	f800283a 	ret

0822a374 <dhc_buildheader>:
 * RETURNS: Returns 0 on success, else an ENP_ error code. 
 */

int
dhc_buildheader(int iface, struct bootp * outbp)
{
 822a374:	defffb04 	addi	sp,sp,-20
 822a378:	dfc00415 	stw	ra,16(sp)
 822a37c:	df000315 	stw	fp,12(sp)
 822a380:	df000304 	addi	fp,sp,12
 822a384:	e13ffe15 	stw	r4,-8(fp)
 822a388:	e17fff15 	stw	r5,-4(fp)
   int   addrlen;    /* length of hardware address */

   MEMSET(outbp, 0, sizeof(struct bootp));   /* most of this is 0 anyway */
 822a38c:	01804b04 	movi	r6,300
 822a390:	000b883a 	mov	r5,zero
 822a394:	e13fff17 	ldw	r4,-4(fp)
 822a398:	82031b40 	call	82031b4 <memset>
   outbp->op = BOOTREQUEST;
 822a39c:	e0bfff17 	ldw	r2,-4(fp)
 822a3a0:	00c00044 	movi	r3,1
 822a3a4:	10c00005 	stb	r3,0(r2)

   /* map SNMPish hardware types into bootp types */
   switch (nets[iface]->n_mib->ifType)
 822a3a8:	008209b4 	movhi	r2,2086
 822a3ac:	10b81b04 	addi	r2,r2,-8084
 822a3b0:	e0fffe17 	ldw	r3,-8(fp)
 822a3b4:	18c7883a 	add	r3,r3,r3
 822a3b8:	18c7883a 	add	r3,r3,r3
 822a3bc:	10c5883a 	add	r2,r2,r3
 822a3c0:	10800017 	ldw	r2,0(r2)
 822a3c4:	10802717 	ldw	r2,156(r2)
 822a3c8:	10800217 	ldw	r2,8(r2)
 822a3cc:	10c005e0 	cmpeqi	r3,r2,23
 822a3d0:	1800081e 	bne	r3,zero,822a3f4 <dhc_buildheader+0x80>
 822a3d4:	10c00720 	cmpeqi	r3,r2,28
 822a3d8:	1800061e 	bne	r3,zero,822a3f4 <dhc_buildheader+0x80>
 822a3dc:	108001a0 	cmpeqi	r2,r2,6
 822a3e0:	10000826 	beq	r2,zero,822a404 <dhc_buildheader+0x90>
   {
   case ETHERNET:       /* ETHERNET defined in net.h */
      outbp->htype = ETHHWTYPE;  /* defined in dhcp.h */
 822a3e4:	e0bfff17 	ldw	r2,-4(fp)
 822a3e8:	00c00044 	movi	r3,1
 822a3ec:	10c00045 	stb	r3,1(r2)
   break;
 822a3f0:	00000706 	br	822a410 <dhc_buildheader+0x9c>
   case PPP:
   case SLIP:
      outbp->htype = LINEHWTYPE;    /* line type for PPP or SLIP */
 822a3f4:	e0bfff17 	ldw	r2,-4(fp)
 822a3f8:	00c00504 	movi	r3,20
 822a3fc:	10c00045 	stb	r3,1(r2)
   break;
 822a400:	00000306 	br	822a410 <dhc_buildheader+0x9c>
      default:
      dtrap();
 822a404:	822d5940 	call	822d594 <dtrap>
      return ENP_LOGIC;             /* this shouldn't happen */
 822a408:	00bffd44 	movi	r2,-11
 822a40c:	00004d06 	br	822a544 <dhc_buildheader+0x1d0>
   }

   addrlen = min(16, nets[iface]->n_hal);
 822a410:	008209b4 	movhi	r2,2086
 822a414:	10b81b04 	addi	r2,r2,-8084
 822a418:	e0fffe17 	ldw	r3,-8(fp)
 822a41c:	18c7883a 	add	r3,r3,r3
 822a420:	18c7883a 	add	r3,r3,r3
 822a424:	10c5883a 	add	r2,r2,r3
 822a428:	10800017 	ldw	r2,0(r2)
 822a42c:	10801117 	ldw	r2,68(r2)
 822a430:	10c00470 	cmpltui	r3,r2,17
 822a434:	1800011e 	bne	r3,zero,822a43c <dhc_buildheader+0xc8>
 822a438:	00800404 	movi	r2,16
 822a43c:	e0bffd15 	stw	r2,-12(fp)
   outbp->hlen = (u_char)addrlen;
 822a440:	e0bffd17 	ldw	r2,-12(fp)
 822a444:	1007883a 	mov	r3,r2
 822a448:	e0bfff17 	ldw	r2,-4(fp)
 822a44c:	10c00085 	stb	r3,2(r2)
   outbp->hops = 0;
 822a450:	e0bfff17 	ldw	r2,-4(fp)
 822a454:	100000c5 	stb	zero,3(r2)
   if(dhc_states[iface].state == DHCS_RENEWING) 
 822a458:	008209b4 	movhi	r2,2086
 822a45c:	10b84104 	addi	r2,r2,-7932
 822a460:	e0fffe17 	ldw	r3,-8(fp)
 822a464:	18c00f24 	muli	r3,r3,60
 822a468:	10c5883a 	add	r2,r2,r3
 822a46c:	10800017 	ldw	r2,0(r2)
 822a470:	108001d8 	cmpnei	r2,r2,7
 822a474:	1000031e 	bne	r2,zero,822a484 <dhc_buildheader+0x110>
      outbp->flags = 0; /* Renewing needs unicast */
 822a478:	e0bfff17 	ldw	r2,-4(fp)
 822a47c:	1000028d 	sth	zero,10(r2)
 822a480:	00000306 	br	822a490 <dhc_buildheader+0x11c>
   else
      outbp->flags = htons(DHC_BCASTFLAG); /* Othwise broadcast */
 822a484:	e0bfff17 	ldw	r2,-4(fp)
 822a488:	00c02004 	movi	r3,128
 822a48c:	10c0028d 	sth	r3,10(r2)
   outbp->xid = dhc_states[iface].xid;
 822a490:	008209b4 	movhi	r2,2086
 822a494:	10b84104 	addi	r2,r2,-7932
 822a498:	e0fffe17 	ldw	r3,-8(fp)
 822a49c:	18c00f24 	muli	r3,r3,60
 822a4a0:	10c5883a 	add	r2,r2,r3
 822a4a4:	10800204 	addi	r2,r2,8
 822a4a8:	10c00017 	ldw	r3,0(r2)
 822a4ac:	e0bfff17 	ldw	r2,-4(fp)
 822a4b0:	10c00115 	stw	r3,4(r2)
   outbp->secs = dhc_states[iface].secs;
 822a4b4:	008209b4 	movhi	r2,2086
 822a4b8:	10b84104 	addi	r2,r2,-7932
 822a4bc:	e0fffe17 	ldw	r3,-8(fp)
 822a4c0:	18c00f24 	muli	r3,r3,60
 822a4c4:	10c5883a 	add	r2,r2,r3
 822a4c8:	10800304 	addi	r2,r2,12
 822a4cc:	10c0000b 	ldhu	r3,0(r2)
 822a4d0:	e0bfff17 	ldw	r2,-4(fp)
 822a4d4:	10c0020d 	sth	r3,8(r2)
#ifdef NPDEBUG
   /* make sure net[] has a MAC address, even if length is zero */
   if(nets[iface]->mib.ifPhysAddress == NULL)
 822a4d8:	008209b4 	movhi	r2,2086
 822a4dc:	10b81b04 	addi	r2,r2,-8084
 822a4e0:	e0fffe17 	ldw	r3,-8(fp)
 822a4e4:	18c7883a 	add	r3,r3,r3
 822a4e8:	18c7883a 	add	r3,r3,r3
 822a4ec:	10c5883a 	add	r2,r2,r3
 822a4f0:	10800017 	ldw	r2,0(r2)
 822a4f4:	10801717 	ldw	r2,92(r2)
 822a4f8:	1000031e 	bne	r2,zero,822a508 <dhc_buildheader+0x194>
   {
      dtrap();
 822a4fc:	822d5940 	call	822d594 <dtrap>
      return ENP_LOGIC;
 822a500:	00bffd44 	movi	r2,-11
 822a504:	00000f06 	br	822a544 <dhc_buildheader+0x1d0>
   }
#endif
   MEMCPY(outbp->chaddr, nets[iface]->mib.ifPhysAddress, addrlen);
 822a508:	e0bfff17 	ldw	r2,-4(fp)
 822a50c:	11000704 	addi	r4,r2,28
 822a510:	008209b4 	movhi	r2,2086
 822a514:	10b81b04 	addi	r2,r2,-8084
 822a518:	e0fffe17 	ldw	r3,-8(fp)
 822a51c:	18c7883a 	add	r3,r3,r3
 822a520:	18c7883a 	add	r3,r3,r3
 822a524:	10c5883a 	add	r2,r2,r3
 822a528:	10800017 	ldw	r2,0(r2)
 822a52c:	10801717 	ldw	r2,92(r2)
 822a530:	e0fffd17 	ldw	r3,-12(fp)
 822a534:	180d883a 	mov	r6,r3
 822a538:	100b883a 	mov	r5,r2
 822a53c:	8202f100 	call	8202f10 <memcpy>

   /* return success */
   return 0;
 822a540:	0005883a 	mov	r2,zero
}
 822a544:	e037883a 	mov	sp,fp
 822a548:	dfc00117 	ldw	ra,4(sp)
 822a54c:	df000017 	ldw	fp,0(sp)
 822a550:	dec00204 	addi	sp,sp,8
 822a554:	f800283a 	ret

0822a558 <dhc_discover>:
 * RETURNS: Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_discover(int iface)
{
 822a558:	defff404 	addi	sp,sp,-48
 822a55c:	dfc00b15 	stw	ra,44(sp)
 822a560:	df000a15 	stw	fp,40(sp)
 822a564:	dc400915 	stw	r17,36(sp)
 822a568:	dc000815 	stw	r16,32(sp)
 822a56c:	df000a04 	addi	fp,sp,40
 822a570:	e13ffd15 	stw	r4,-12(fp)
   u_char * opts;       /* scratch pointer to DHCP options field */
   long     leasetime;
   int      e;

   /* get a UDP packet buffer for DHCP sending */
   pkt = udp_alloc(sizeof(struct bootp), 0);
 822a574:	000b883a 	mov	r5,zero
 822a578:	01004b04 	movi	r4,300
 822a57c:	82453e80 	call	82453e8 <udp_alloc>
 822a580:	e0bff815 	stw	r2,-32(fp)
   if (!pkt) 
 822a584:	e0bff817 	ldw	r2,-32(fp)
 822a588:	1000021e 	bne	r2,zero,822a594 <dhc_discover+0x3c>
      return ENP_NOMEM;
 822a58c:	00bffb04 	movi	r2,-20
 822a590:	00011d06 	br	822aa08 <dhc_discover+0x4b0>
   pkt->nb_plen = sizeof(struct bootp);
 822a594:	e0bff817 	ldw	r2,-32(fp)
 822a598:	00c04b04 	movi	r3,300
 822a59c:	10c00415 	stw	r3,16(r2)

   /* start a new DHCP transaction */
   dhc_states[iface].xid = xids++;
 822a5a0:	d0a03317 	ldw	r2,-32564(gp)
 822a5a4:	10c00044 	addi	r3,r2,1
 822a5a8:	d0e03315 	stw	r3,-32564(gp)
 822a5ac:	1009883a 	mov	r4,r2
 822a5b0:	008209b4 	movhi	r2,2086
 822a5b4:	10b84104 	addi	r2,r2,-7932
 822a5b8:	e0fffd17 	ldw	r3,-12(fp)
 822a5bc:	18c00f24 	muli	r3,r3,60
 822a5c0:	10c5883a 	add	r2,r2,r3
 822a5c4:	10800204 	addi	r2,r2,8
 822a5c8:	11000015 	stw	r4,0(r2)
   dhc_states[iface].secs = (unsigned short)(sysuptime()/100L);
 822a5cc:	823d3040 	call	823d304 <sysuptime>
 822a5d0:	1007883a 	mov	r3,r2
 822a5d4:	00947b34 	movhi	r2,20972
 822a5d8:	10a147c4 	addi	r2,r2,-31457
 822a5dc:	1888383a 	mulxuu	r4,r3,r2
 822a5e0:	1885383a 	mul	r2,r3,r2
 822a5e4:	1021883a 	mov	r16,r2
 822a5e8:	2023883a 	mov	r17,r4
 822a5ec:	8804d17a 	srli	r2,r17,5
 822a5f0:	1009883a 	mov	r4,r2
 822a5f4:	008209b4 	movhi	r2,2086
 822a5f8:	10b84104 	addi	r2,r2,-7932
 822a5fc:	e0fffd17 	ldw	r3,-12(fp)
 822a600:	18c00f24 	muli	r3,r3,60
 822a604:	10c5883a 	add	r2,r2,r3
 822a608:	10800304 	addi	r2,r2,12
 822a60c:	1100000d 	sth	r4,0(r2)

   /* set up DHCP/BOOTP header in buffer */
   outbp = (struct bootp *)pkt->nb_prot;     /* overlay bootp struct on buffer */
 822a610:	e0bff817 	ldw	r2,-32(fp)
 822a614:	10800317 	ldw	r2,12(r2)
 822a618:	e0bff915 	stw	r2,-28(fp)
   e = dhc_buildheader(iface,outbp);
 822a61c:	e17ff917 	ldw	r5,-28(fp)
 822a620:	e13ffd17 	ldw	r4,-12(fp)
 822a624:	822a3740 	call	822a374 <dhc_buildheader>
 822a628:	e0bffa15 	stw	r2,-24(fp)
   if (e)
 822a62c:	e0bffa17 	ldw	r2,-24(fp)
 822a630:	10000226 	beq	r2,zero,822a63c <dhc_discover+0xe4>
      return e;
 822a634:	e0bffa17 	ldw	r2,-24(fp)
 822a638:	0000f306 	br	822aa08 <dhc_discover+0x4b0>

   /* and turn it into a DHCP DISCOVER packet */
   *(long*)(&outbp->options) = RFC1084_MAGIC_COOKIE; 
 822a63c:	e0bff917 	ldw	r2,-28(fp)
 822a640:	10c03b04 	addi	r3,r2,236
 822a644:	0098d534 	movhi	r2,25428
 822a648:	10a098c4 	addi	r2,r2,-32157
 822a64c:	18800015 	stw	r2,0(r3)
   opts = &outbp->options[4];    /* encode options after cookie */
 822a650:	e0bff917 	ldw	r2,-28(fp)
 822a654:	10803c04 	addi	r2,r2,240
 822a658:	e0bff615 	stw	r2,-40(fp)
   *opts++ = DHOP_TYPE;
 822a65c:	e0bff617 	ldw	r2,-40(fp)
 822a660:	10c00044 	addi	r3,r2,1
 822a664:	e0fff615 	stw	r3,-40(fp)
 822a668:	00c00d44 	movi	r3,53
 822a66c:	10c00005 	stb	r3,0(r2)
   *opts++ = 1;   /* length of option field */
 822a670:	e0bff617 	ldw	r2,-40(fp)
 822a674:	10c00044 	addi	r3,r2,1
 822a678:	e0fff615 	stw	r3,-40(fp)
 822a67c:	00c00044 	movi	r3,1
 822a680:	10c00005 	stb	r3,0(r2)
   *opts++ = DHCP_DISCOVER;
 822a684:	e0bff617 	ldw	r2,-40(fp)
 822a688:	10c00044 	addi	r3,r2,1
 822a68c:	e0fff615 	stw	r3,-40(fp)
 822a690:	00c00044 	movi	r3,1
 822a694:	10c00005 	stb	r3,0(r2)
   leasetime = -1L ;    /* ask for infinite lease */
 822a698:	00bfffc4 	movi	r2,-1
 822a69c:	e0bffb15 	stw	r2,-20(fp)
   PUT_IP_OPT(opts, DHOP_LEASE, leasetime);
 822a6a0:	e0bff617 	ldw	r2,-40(fp)
 822a6a4:	10c00044 	addi	r3,r2,1
 822a6a8:	e0fff615 	stw	r3,-40(fp)
 822a6ac:	00c00cc4 	movi	r3,51
 822a6b0:	10c00005 	stb	r3,0(r2)
 822a6b4:	e0bff617 	ldw	r2,-40(fp)
 822a6b8:	10c00044 	addi	r3,r2,1
 822a6bc:	e0fff615 	stw	r3,-40(fp)
 822a6c0:	00c00104 	movi	r3,4
 822a6c4:	10c00005 	stb	r3,0(r2)
 822a6c8:	e0bff617 	ldw	r2,-40(fp)
 822a6cc:	108000c4 	addi	r2,r2,3
 822a6d0:	e0fffb04 	addi	r3,fp,-20
 822a6d4:	18c00003 	ldbu	r3,0(r3)
 822a6d8:	10c00005 	stb	r3,0(r2)
 822a6dc:	e0bff617 	ldw	r2,-40(fp)
 822a6e0:	10c00084 	addi	r3,r2,2
 822a6e4:	e0bffb04 	addi	r2,fp,-20
 822a6e8:	10800044 	addi	r2,r2,1
 822a6ec:	10800003 	ldbu	r2,0(r2)
 822a6f0:	18800005 	stb	r2,0(r3)
 822a6f4:	e0bff617 	ldw	r2,-40(fp)
 822a6f8:	10c00044 	addi	r3,r2,1
 822a6fc:	e0bffb04 	addi	r2,fp,-20
 822a700:	10800084 	addi	r2,r2,2
 822a704:	10800003 	ldbu	r2,0(r2)
 822a708:	18800005 	stb	r2,0(r3)
 822a70c:	e0bffb04 	addi	r2,fp,-20
 822a710:	108000c4 	addi	r2,r2,3
 822a714:	10800003 	ldbu	r2,0(r2)
 822a718:	1007883a 	mov	r3,r2
 822a71c:	e0bff617 	ldw	r2,-40(fp)
 822a720:	10c00005 	stb	r3,0(r2)
 822a724:	e0bff617 	ldw	r2,-40(fp)
 822a728:	10800104 	addi	r2,r2,4
 822a72c:	e0bff615 	stw	r2,-40(fp)

   /* if we already have an IP address, try to get it from the server */
   if (nets[iface]->n_ipaddr != 0)
 822a730:	008209b4 	movhi	r2,2086
 822a734:	10b81b04 	addi	r2,r2,-8084
 822a738:	e0fffd17 	ldw	r3,-12(fp)
 822a73c:	18c7883a 	add	r3,r3,r3
 822a740:	18c7883a 	add	r3,r3,r3
 822a744:	10c5883a 	add	r2,r2,r3
 822a748:	10800017 	ldw	r2,0(r2)
 822a74c:	10800a17 	ldw	r2,40(r2)
 822a750:	10004e26 	beq	r2,zero,822a88c <dhc_discover+0x334>
   {
      ip_addr my_ip = htonl(nets[iface]->n_ipaddr);
 822a754:	008209b4 	movhi	r2,2086
 822a758:	10b81b04 	addi	r2,r2,-8084
 822a75c:	e0fffd17 	ldw	r3,-12(fp)
 822a760:	18c7883a 	add	r3,r3,r3
 822a764:	18c7883a 	add	r3,r3,r3
 822a768:	10c5883a 	add	r2,r2,r3
 822a76c:	10800017 	ldw	r2,0(r2)
 822a770:	10800a17 	ldw	r2,40(r2)
 822a774:	1008d63a 	srli	r4,r2,24
 822a778:	008209b4 	movhi	r2,2086
 822a77c:	10b81b04 	addi	r2,r2,-8084
 822a780:	e0fffd17 	ldw	r3,-12(fp)
 822a784:	18c7883a 	add	r3,r3,r3
 822a788:	18c7883a 	add	r3,r3,r3
 822a78c:	10c5883a 	add	r2,r2,r3
 822a790:	10800017 	ldw	r2,0(r2)
 822a794:	10800a17 	ldw	r2,40(r2)
 822a798:	1004d23a 	srli	r2,r2,8
 822a79c:	10bfc00c 	andi	r2,r2,65280
 822a7a0:	2088b03a 	or	r4,r4,r2
 822a7a4:	008209b4 	movhi	r2,2086
 822a7a8:	10b81b04 	addi	r2,r2,-8084
 822a7ac:	e0fffd17 	ldw	r3,-12(fp)
 822a7b0:	18c7883a 	add	r3,r3,r3
 822a7b4:	18c7883a 	add	r3,r3,r3
 822a7b8:	10c5883a 	add	r2,r2,r3
 822a7bc:	10800017 	ldw	r2,0(r2)
 822a7c0:	10800a17 	ldw	r2,40(r2)
 822a7c4:	10bfc00c 	andi	r2,r2,65280
 822a7c8:	1004923a 	slli	r2,r2,8
 822a7cc:	2088b03a 	or	r4,r4,r2
 822a7d0:	008209b4 	movhi	r2,2086
 822a7d4:	10b81b04 	addi	r2,r2,-8084
 822a7d8:	e0fffd17 	ldw	r3,-12(fp)
 822a7dc:	18c7883a 	add	r3,r3,r3
 822a7e0:	18c7883a 	add	r3,r3,r3
 822a7e4:	10c5883a 	add	r2,r2,r3
 822a7e8:	10800017 	ldw	r2,0(r2)
 822a7ec:	10800a17 	ldw	r2,40(r2)
 822a7f0:	1004963a 	slli	r2,r2,24
 822a7f4:	2084b03a 	or	r2,r4,r2
 822a7f8:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_CADDR, my_ip);
 822a7fc:	e0bff617 	ldw	r2,-40(fp)
 822a800:	10c00044 	addi	r3,r2,1
 822a804:	e0fff615 	stw	r3,-40(fp)
 822a808:	00c00c84 	movi	r3,50
 822a80c:	10c00005 	stb	r3,0(r2)
 822a810:	e0bff617 	ldw	r2,-40(fp)
 822a814:	10c00044 	addi	r3,r2,1
 822a818:	e0fff615 	stw	r3,-40(fp)
 822a81c:	00c00104 	movi	r3,4
 822a820:	10c00005 	stb	r3,0(r2)
 822a824:	e0bff617 	ldw	r2,-40(fp)
 822a828:	108000c4 	addi	r2,r2,3
 822a82c:	e0fffc04 	addi	r3,fp,-16
 822a830:	18c00003 	ldbu	r3,0(r3)
 822a834:	10c00005 	stb	r3,0(r2)
 822a838:	e0bff617 	ldw	r2,-40(fp)
 822a83c:	10c00084 	addi	r3,r2,2
 822a840:	e0bffc04 	addi	r2,fp,-16
 822a844:	10800044 	addi	r2,r2,1
 822a848:	10800003 	ldbu	r2,0(r2)
 822a84c:	18800005 	stb	r2,0(r3)
 822a850:	e0bff617 	ldw	r2,-40(fp)
 822a854:	10c00044 	addi	r3,r2,1
 822a858:	e0bffc04 	addi	r2,fp,-16
 822a85c:	10800084 	addi	r2,r2,2
 822a860:	10800003 	ldbu	r2,0(r2)
 822a864:	18800005 	stb	r2,0(r3)
 822a868:	e0bffc04 	addi	r2,fp,-16
 822a86c:	108000c4 	addi	r2,r2,3
 822a870:	10800003 	ldbu	r2,0(r2)
 822a874:	1007883a 	mov	r3,r2
 822a878:	e0bff617 	ldw	r2,-40(fp)
 822a87c:	10c00005 	stb	r3,0(r2)
 822a880:	e0bff617 	ldw	r2,-40(fp)
 822a884:	10800104 	addi	r2,r2,4
 822a888:	e0bff615 	stw	r2,-40(fp)
   }

   /* If there is a list of options to be requested from server, include it*/
#ifdef DHCP_REQLIST
   if ( reqlist_len > 0 )
 822a88c:	d0a03517 	ldw	r2,-32556(gp)
 822a890:	00801a0e 	bge	zero,r2,822a8fc <dhc_discover+0x3a4>
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
 822a894:	e0bff617 	ldw	r2,-40(fp)
 822a898:	10c00044 	addi	r3,r2,1
 822a89c:	e0fff615 	stw	r3,-40(fp)
 822a8a0:	00c00dc4 	movi	r3,55
 822a8a4:	10c00005 	stb	r3,0(r2)
      *opts++ = (u_char)reqlist_len ;
 822a8a8:	e0bff617 	ldw	r2,-40(fp)
 822a8ac:	10c00044 	addi	r3,r2,1
 822a8b0:	e0fff615 	stw	r3,-40(fp)
 822a8b4:	d0e03517 	ldw	r3,-32556(gp)
 822a8b8:	10c00005 	stb	r3,0(r2)

      for (i=0 ; i < reqlist_len ; i++ )
 822a8bc:	e03ff715 	stw	zero,-36(fp)
 822a8c0:	00000b06 	br	822a8f0 <dhc_discover+0x398>
         *opts++ = reqlist[i];
 822a8c4:	e0bff617 	ldw	r2,-40(fp)
 822a8c8:	10c00044 	addi	r3,r2,1
 822a8cc:	e0fff615 	stw	r3,-40(fp)
 822a8d0:	e13ff717 	ldw	r4,-36(fp)
 822a8d4:	d0e03404 	addi	r3,gp,-32560
 822a8d8:	20c7883a 	add	r3,r4,r3
 822a8dc:	18c00003 	ldbu	r3,0(r3)
 822a8e0:	10c00005 	stb	r3,0(r2)
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
      *opts++ = (u_char)reqlist_len ;

      for (i=0 ; i < reqlist_len ; i++ )
 822a8e4:	e0bff717 	ldw	r2,-36(fp)
 822a8e8:	10800044 	addi	r2,r2,1
 822a8ec:	e0bff715 	stw	r2,-36(fp)
 822a8f0:	d0a03517 	ldw	r2,-32556(gp)
 822a8f4:	e0fff717 	ldw	r3,-36(fp)
 822a8f8:	18bff216 	blt	r3,r2,822a8c4 <dhc_discover+0x36c>
         *opts++ = reqlist[i];
   }
#endif   /* DHCP_REQLIST */

   *opts++ = DHOP_END;
 822a8fc:	e0bff617 	ldw	r2,-40(fp)
 822a900:	10c00044 	addi	r3,r2,1
 822a904:	e0fff615 	stw	r3,-40(fp)
 822a908:	00ffffc4 	movi	r3,-1
 822a90c:	10c00005 	stb	r3,0(r2)

   /* last_tick needs to be set in case we are doing a retry. It 
    * prevents dhc_second from calling us to do another retry while 
    * we are stuck 
    */
   dhc_states[iface].last_tick = cticks;
 822a910:	d0e0a817 	ldw	r3,-32096(gp)
 822a914:	008209b4 	movhi	r2,2086
 822a918:	10b84104 	addi	r2,r2,-7932
 822a91c:	e13ffd17 	ldw	r4,-12(fp)
 822a920:	21000f24 	muli	r4,r4,60
 822a924:	1105883a 	add	r2,r2,r4
 822a928:	10800404 	addi	r2,r2,16
 822a92c:	10c00015 	stw	r3,0(r2)

   pkt->fhost = 0xFFFFFFFF;   /* broadcast discovery request */
 822a930:	e0bff817 	ldw	r2,-32(fp)
 822a934:	00ffffc4 	movi	r3,-1
 822a938:	10c00715 	stw	r3,28(r2)
   pkt->net = nets[iface];    /* send out caller spec'ed net */
 822a93c:	008209b4 	movhi	r2,2086
 822a940:	10b81b04 	addi	r2,r2,-8084
 822a944:	e0fffd17 	ldw	r3,-12(fp)
 822a948:	18c7883a 	add	r3,r3,r3
 822a94c:	18c7883a 	add	r3,r3,r3
 822a950:	10c5883a 	add	r2,r2,r3
 822a954:	10c00017 	ldw	r3,0(r2)
 822a958:	e0bff817 	ldw	r2,-32(fp)
 822a95c:	10c00615 	stw	r3,24(r2)

   /* we need to change the DHCP state before sending to avoid a 
    * race condition with the expected reply 
    */
   if (dhc_states[iface].state != DHCS_SELECTING)
 822a960:	008209b4 	movhi	r2,2086
 822a964:	10b84104 	addi	r2,r2,-7932
 822a968:	e0fffd17 	ldw	r3,-12(fp)
 822a96c:	18c00f24 	muli	r3,r3,60
 822a970:	10c5883a 	add	r2,r2,r3
 822a974:	10800017 	ldw	r2,0(r2)
 822a978:	10800120 	cmpeqi	r2,r2,4
 822a97c:	1000031e 	bne	r2,zero,822a98c <dhc_discover+0x434>
      dhc_set_state(iface, DHCS_SELECTING);
 822a980:	01400104 	movi	r5,4
 822a984:	e13ffd17 	ldw	r4,-12(fp)
 822a988:	822c5e00 	call	822c5e0 <dhc_set_state>

   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 822a98c:	e1bff817 	ldw	r6,-32(fp)
 822a990:	01401104 	movi	r5,68
 822a994:	010010c4 	movi	r4,67
 822a998:	8244fac0 	call	8244fac <udp_send>
   dsc_discovers++;
 822a99c:	d0a09117 	ldw	r2,-32188(gp)
 822a9a0:	10800044 	addi	r2,r2,1
 822a9a4:	d0a09115 	stw	r2,-32188(gp)

   /* state info is the same even if udp_send() failed */
   dhc_states[iface].last_tick = cticks;     /* set this again, post udp_send */
 822a9a8:	d0e0a817 	ldw	r3,-32096(gp)
 822a9ac:	008209b4 	movhi	r2,2086
 822a9b0:	10b84104 	addi	r2,r2,-7932
 822a9b4:	e13ffd17 	ldw	r4,-12(fp)
 822a9b8:	21000f24 	muli	r4,r4,60
 822a9bc:	1105883a 	add	r2,r2,r4
 822a9c0:	10800404 	addi	r2,r2,16
 822a9c4:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].tries++;
 822a9c8:	008209b4 	movhi	r2,2086
 822a9cc:	10b84104 	addi	r2,r2,-7932
 822a9d0:	e0fffd17 	ldw	r3,-12(fp)
 822a9d4:	18c00f24 	muli	r3,r3,60
 822a9d8:	10c5883a 	add	r2,r2,r3
 822a9dc:	10800104 	addi	r2,r2,4
 822a9e0:	10800017 	ldw	r2,0(r2)
 822a9e4:	10c00044 	addi	r3,r2,1
 822a9e8:	008209b4 	movhi	r2,2086
 822a9ec:	10b84104 	addi	r2,r2,-7932
 822a9f0:	e13ffd17 	ldw	r4,-12(fp)
 822a9f4:	21000f24 	muli	r4,r4,60
 822a9f8:	1105883a 	add	r2,r2,r4
 822a9fc:	10800104 	addi	r2,r2,4
 822aa00:	10c00015 	stw	r3,0(r2)

   return 0;
 822aa04:	0005883a 	mov	r2,zero
}
 822aa08:	e6fffe04 	addi	sp,fp,-8
 822aa0c:	dfc00317 	ldw	ra,12(sp)
 822aa10:	df000217 	ldw	fp,8(sp)
 822aa14:	dc400117 	ldw	r17,4(sp)
 822aa18:	dc000017 	ldw	r16,0(sp)
 822aa1c:	dec00404 	addi	sp,sp,16
 822aa20:	f800283a 	ret

0822aa24 <dhc_rx_offer>:
 * RETURNS: 0 if OK, else ENP_ error
 */

int
dhc_rx_offer(int iface, struct bootp * bp, unsigned bplen)
{
 822aa24:	defff904 	addi	sp,sp,-28
 822aa28:	dfc00615 	stw	ra,24(sp)
 822aa2c:	df000515 	stw	fp,20(sp)
 822aa30:	df000504 	addi	fp,sp,20
 822aa34:	e13ffd15 	stw	r4,-12(fp)
 822aa38:	e17ffe15 	stw	r5,-8(fp)
 822aa3c:	e1bfff15 	stw	r6,-4(fp)
   u_char * opts;
   int   e;

   if (dhc_states[iface].xid != bp->xid)
 822aa40:	008209b4 	movhi	r2,2086
 822aa44:	10b84104 	addi	r2,r2,-7932
 822aa48:	e0fffd17 	ldw	r3,-12(fp)
 822aa4c:	18c00f24 	muli	r3,r3,60
 822aa50:	10c5883a 	add	r2,r2,r3
 822aa54:	10800204 	addi	r2,r2,8
 822aa58:	10c00017 	ldw	r3,0(r2)
 822aa5c:	e0bffe17 	ldw	r2,-8(fp)
 822aa60:	10800117 	ldw	r2,4(r2)
 822aa64:	18800226 	beq	r3,r2,822aa70 <dhc_rx_offer+0x4c>
      return ENP_NOT_MINE;
 822aa68:	00800084 	movi	r2,2
 822aa6c:	00002106 	br	822aaf4 <dhc_rx_offer+0xd0>

   opts = &bp->options[4];    /* examine options after cookie */
 822aa70:	e0bffe17 	ldw	r2,-8(fp)
 822aa74:	10803c04 	addi	r2,r2,240
 822aa78:	e0bffb15 	stw	r2,-20(fp)
   e = dhc_extract_opts(iface,opts);
 822aa7c:	e17ffb17 	ldw	r5,-20(fp)
 822aa80:	e13ffd17 	ldw	r4,-12(fp)
 822aa84:	822baa00 	call	822baa0 <dhc_extract_opts>
 822aa88:	e0bffc15 	stw	r2,-16(fp)
   if (e)   /* parse error? */
 822aa8c:	e0bffc17 	ldw	r2,-16(fp)
 822aa90:	10000326 	beq	r2,zero,822aaa0 <dhc_rx_offer+0x7c>
   {
      dtrap();
 822aa94:	822d5940 	call	822d594 <dtrap>
      return e;
 822aa98:	e0bffc17 	ldw	r2,-16(fp)
 822aa9c:	00001506 	br	822aaf4 <dhc_rx_offer+0xd0>
   }
   if (!bp->yiaddr)  /* require an IP address */
 822aaa0:	e0bffe17 	ldw	r2,-8(fp)
 822aaa4:	10800417 	ldw	r2,16(r2)
 822aaa8:	1000061e 	bne	r2,zero,822aac4 <dhc_rx_offer+0xa0>
   {
      dhc_decline(iface,bp, bplen);
 822aaac:	e1bfff17 	ldw	r6,-4(fp)
 822aab0:	e17ffe17 	ldw	r5,-8(fp)
 822aab4:	e13ffd17 	ldw	r4,-12(fp)
 822aab8:	822b8ec0 	call	822b8ec <dhc_decline>
      return ENP_NOT_MINE;
 822aabc:	00800084 	movi	r2,2
 822aac0:	00000c06 	br	822aaf4 <dhc_rx_offer+0xd0>
   }
   dhc_states[iface].ipaddr = bp->yiaddr;
 822aac4:	e0bffe17 	ldw	r2,-8(fp)
 822aac8:	10c00417 	ldw	r3,16(r2)
 822aacc:	008209b4 	movhi	r2,2086
 822aad0:	10b84104 	addi	r2,r2,-7932
 822aad4:	e13ffd17 	ldw	r4,-12(fp)
 822aad8:	21000f24 	muli	r4,r4,60
 822aadc:	1105883a 	add	r2,r2,r4
 822aae0:	10800904 	addi	r2,r2,36
 822aae4:	10c00015 	stw	r3,0(r2)

   /* if we got here, we must like the offer -- send a DHCP REQUEST */
   return (dhc_request(iface,FALSE));
 822aae8:	000b883a 	mov	r5,zero
 822aaec:	e13ffd17 	ldw	r4,-12(fp)
 822aaf0:	822ab080 	call	822ab08 <dhc_request>
}
 822aaf4:	e037883a 	mov	sp,fp
 822aaf8:	dfc00117 	ldw	ra,4(sp)
 822aafc:	df000017 	ldw	fp,0(sp)
 822ab00:	dec00204 	addi	sp,sp,8
 822ab04:	f800283a 	ret

0822ab08 <dhc_request>:
 * RETURNS:  Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_request(int iface,int xid_flag)
{
 822ab08:	defff404 	addi	sp,sp,-48
 822ab0c:	dfc00b15 	stw	ra,44(sp)
 822ab10:	df000a15 	stw	fp,40(sp)
 822ab14:	df000a04 	addi	fp,sp,40
 822ab18:	e13ffe15 	stw	r4,-8(fp)
 822ab1c:	e17fff15 	stw	r5,-4(fp)
   u_char  *   opts; /* scratch pointer to DHCP options field */
   ip_addr opt_ip;      /* IP address temporary */
   int      e;       /* error holder */

   /* get a UDP packet buffer for sending DHCP request */
   pkt = udp_alloc(sizeof(struct bootp) + DHCP_OPTSIZE - BOOTP_OPTSIZE, 0);
 822ab20:	000b883a 	mov	r5,zero
 822ab24:	01008904 	movi	r4,548
 822ab28:	82453e80 	call	82453e8 <udp_alloc>
 822ab2c:	e0bff815 	stw	r2,-32(fp)
   if (!pkt) 
 822ab30:	e0bff817 	ldw	r2,-32(fp)
 822ab34:	1000021e 	bne	r2,zero,822ab40 <dhc_request+0x38>
      return ENP_NOMEM;
 822ab38:	00bffb04 	movi	r2,-20
 822ab3c:	00028e06 	br	822b578 <dhc_request+0xa70>
   pkt->nb_plen = sizeof(struct bootp) - BOOTP_OPTSIZE;
 822ab40:	e0bff817 	ldw	r2,-32(fp)
 822ab44:	00c03b04 	movi	r3,236
 822ab48:	10c00415 	stw	r3,16(r2)

   if ( xid_flag == TRUE )
 822ab4c:	e0bfff17 	ldw	r2,-4(fp)
 822ab50:	10800058 	cmpnei	r2,r2,1
 822ab54:	1000121e 	bne	r2,zero,822aba0 <dhc_request+0x98>
   {
      dhc_states[iface].xid  = xids++;
 822ab58:	d0a03317 	ldw	r2,-32564(gp)
 822ab5c:	10c00044 	addi	r3,r2,1
 822ab60:	d0e03315 	stw	r3,-32564(gp)
 822ab64:	1009883a 	mov	r4,r2
 822ab68:	008209b4 	movhi	r2,2086
 822ab6c:	10b84104 	addi	r2,r2,-7932
 822ab70:	e0fffe17 	ldw	r3,-8(fp)
 822ab74:	18c00f24 	muli	r3,r3,60
 822ab78:	10c5883a 	add	r2,r2,r3
 822ab7c:	10800204 	addi	r2,r2,8
 822ab80:	11000015 	stw	r4,0(r2)
      dhc_states[iface].secs = 0;
 822ab84:	008209b4 	movhi	r2,2086
 822ab88:	10b84104 	addi	r2,r2,-7932
 822ab8c:	e0fffe17 	ldw	r3,-8(fp)
 822ab90:	18c00f24 	muli	r3,r3,60
 822ab94:	10c5883a 	add	r2,r2,r3
 822ab98:	10800304 	addi	r2,r2,12
 822ab9c:	1000000d 	sth	zero,0(r2)
   }

   /* build a BOOTP request header */
   outbp = (struct bootp *)pkt->nb_prot;
 822aba0:	e0bff817 	ldw	r2,-32(fp)
 822aba4:	10800317 	ldw	r2,12(r2)
 822aba8:	e0bff915 	stw	r2,-28(fp)
   e     = dhc_buildheader(iface,outbp);
 822abac:	e17ff917 	ldw	r5,-28(fp)
 822abb0:	e13ffe17 	ldw	r4,-8(fp)
 822abb4:	822a3740 	call	822a374 <dhc_buildheader>
 822abb8:	e0bffa15 	stw	r2,-24(fp)
   if (e)
 822abbc:	e0bffa17 	ldw	r2,-24(fp)
 822abc0:	10000226 	beq	r2,zero,822abcc <dhc_request+0xc4>
      return e;
 822abc4:	e0bffa17 	ldw	r2,-24(fp)
 822abc8:	00026b06 	br	822b578 <dhc_request+0xa70>

   /* turn it into a DHCP REQUEST packet */
   *(long*)(&outbp->options) = RFC1084_MAGIC_COOKIE; 
 822abcc:	e0bff917 	ldw	r2,-28(fp)
 822abd0:	10c03b04 	addi	r3,r2,236
 822abd4:	0098d534 	movhi	r2,25428
 822abd8:	10a098c4 	addi	r2,r2,-32157
 822abdc:	18800015 	stw	r2,0(r3)
   opts    = &outbp->options[4];    /* encode options after cookie */
 822abe0:	e0bff917 	ldw	r2,-28(fp)
 822abe4:	10803c04 	addi	r2,r2,240
 822abe8:	e0bff615 	stw	r2,-40(fp)
   *opts++ = DHOP_TYPE;
 822abec:	e0bff617 	ldw	r2,-40(fp)
 822abf0:	10c00044 	addi	r3,r2,1
 822abf4:	e0fff615 	stw	r3,-40(fp)
 822abf8:	00c00d44 	movi	r3,53
 822abfc:	10c00005 	stb	r3,0(r2)
   *opts++ = 1;   /* length of option field */
 822ac00:	e0bff617 	ldw	r2,-40(fp)
 822ac04:	10c00044 	addi	r3,r2,1
 822ac08:	e0fff615 	stw	r3,-40(fp)
 822ac0c:	00c00044 	movi	r3,1
 822ac10:	10c00005 	stb	r3,0(r2)
   *opts++ = DHCP_REQUEST;
 822ac14:	e0bff617 	ldw	r2,-40(fp)
 822ac18:	10c00044 	addi	r3,r2,1
 822ac1c:	e0fff615 	stw	r3,-40(fp)
 822ac20:	00c000c4 	movi	r3,3
 822ac24:	10c00005 	stb	r3,0(r2)

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 822ac28:	008209b4 	movhi	r2,2086
 822ac2c:	10b84104 	addi	r2,r2,-7932
 822ac30:	e0fffe17 	ldw	r3,-8(fp)
 822ac34:	18c00f24 	muli	r3,r3,60
 822ac38:	10c5883a 	add	r2,r2,r3
 822ac3c:	10800017 	ldw	r2,0(r2)
 822ac40:	10800120 	cmpeqi	r2,r2,4
 822ac44:	1000181e 	bne	r2,zero,822aca8 <dhc_request+0x1a0>
       (dhc_states[iface].state == DHCS_REQUESTING) ||
 822ac48:	008209b4 	movhi	r2,2086
 822ac4c:	10b84104 	addi	r2,r2,-7932
 822ac50:	e0fffe17 	ldw	r3,-8(fp)
 822ac54:	18c00f24 	muli	r3,r3,60
 822ac58:	10c5883a 	add	r2,r2,r3
 822ac5c:	10800017 	ldw	r2,0(r2)
   *opts++ = DHOP_TYPE;
   *opts++ = 1;   /* length of option field */
   *opts++ = DHCP_REQUEST;

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 822ac60:	10800160 	cmpeqi	r2,r2,5
 822ac64:	1000101e 	bne	r2,zero,822aca8 <dhc_request+0x1a0>
       (dhc_states[iface].state == DHCS_REQUESTING) ||
       (dhc_states[iface].state == DHCS_REBOOTING) ||
 822ac68:	008209b4 	movhi	r2,2086
 822ac6c:	10b84104 	addi	r2,r2,-7932
 822ac70:	e0fffe17 	ldw	r3,-8(fp)
 822ac74:	18c00f24 	muli	r3,r3,60
 822ac78:	10c5883a 	add	r2,r2,r3
 822ac7c:	10800017 	ldw	r2,0(r2)
   *opts++ = 1;   /* length of option field */
   *opts++ = DHCP_REQUEST;

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
       (dhc_states[iface].state == DHCS_REQUESTING) ||
 822ac80:	108000e0 	cmpeqi	r2,r2,3
 822ac84:	1000081e 	bne	r2,zero,822aca8 <dhc_request+0x1a0>
       (dhc_states[iface].state == DHCS_REBOOTING) ||
       (dhc_states[iface].state == DHCS_INITREBOOT))
 822ac88:	008209b4 	movhi	r2,2086
 822ac8c:	10b84104 	addi	r2,r2,-7932
 822ac90:	e0fffe17 	ldw	r3,-8(fp)
 822ac94:	18c00f24 	muli	r3,r3,60
 822ac98:	10c5883a 	add	r2,r2,r3
 822ac9c:	10800017 	ldw	r2,0(r2)
   *opts++ = DHCP_REQUEST;

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
       (dhc_states[iface].state == DHCS_REQUESTING) ||
       (dhc_states[iface].state == DHCS_REBOOTING) ||
 822aca0:	10800098 	cmpnei	r2,r2,2
 822aca4:	10004a1e 	bne	r2,zero,822add0 <dhc_request+0x2c8>
       (dhc_states[iface].state == DHCS_INITREBOOT))
   {
      opt_ip = ntohl(dhc_states[iface].ipaddr);
 822aca8:	008209b4 	movhi	r2,2086
 822acac:	10b84104 	addi	r2,r2,-7932
 822acb0:	e0fffe17 	ldw	r3,-8(fp)
 822acb4:	18c00f24 	muli	r3,r3,60
 822acb8:	10c5883a 	add	r2,r2,r3
 822acbc:	10800904 	addi	r2,r2,36
 822acc0:	10800017 	ldw	r2,0(r2)
 822acc4:	1006d63a 	srli	r3,r2,24
 822acc8:	008209b4 	movhi	r2,2086
 822accc:	10b84104 	addi	r2,r2,-7932
 822acd0:	e13ffe17 	ldw	r4,-8(fp)
 822acd4:	21000f24 	muli	r4,r4,60
 822acd8:	1105883a 	add	r2,r2,r4
 822acdc:	10800904 	addi	r2,r2,36
 822ace0:	10800017 	ldw	r2,0(r2)
 822ace4:	1004d23a 	srli	r2,r2,8
 822ace8:	10bfc00c 	andi	r2,r2,65280
 822acec:	1886b03a 	or	r3,r3,r2
 822acf0:	008209b4 	movhi	r2,2086
 822acf4:	10b84104 	addi	r2,r2,-7932
 822acf8:	e13ffe17 	ldw	r4,-8(fp)
 822acfc:	21000f24 	muli	r4,r4,60
 822ad00:	1105883a 	add	r2,r2,r4
 822ad04:	10800904 	addi	r2,r2,36
 822ad08:	10800017 	ldw	r2,0(r2)
 822ad0c:	10bfc00c 	andi	r2,r2,65280
 822ad10:	1004923a 	slli	r2,r2,8
 822ad14:	1886b03a 	or	r3,r3,r2
 822ad18:	008209b4 	movhi	r2,2086
 822ad1c:	10b84104 	addi	r2,r2,-7932
 822ad20:	e13ffe17 	ldw	r4,-8(fp)
 822ad24:	21000f24 	muli	r4,r4,60
 822ad28:	1105883a 	add	r2,r2,r4
 822ad2c:	10800904 	addi	r2,r2,36
 822ad30:	10800017 	ldw	r2,0(r2)
 822ad34:	1004963a 	slli	r2,r2,24
 822ad38:	1884b03a 	or	r2,r3,r2
 822ad3c:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_CADDR, opt_ip);
 822ad40:	e0bff617 	ldw	r2,-40(fp)
 822ad44:	10c00044 	addi	r3,r2,1
 822ad48:	e0fff615 	stw	r3,-40(fp)
 822ad4c:	00c00c84 	movi	r3,50
 822ad50:	10c00005 	stb	r3,0(r2)
 822ad54:	e0bff617 	ldw	r2,-40(fp)
 822ad58:	10c00044 	addi	r3,r2,1
 822ad5c:	e0fff615 	stw	r3,-40(fp)
 822ad60:	00c00104 	movi	r3,4
 822ad64:	10c00005 	stb	r3,0(r2)
 822ad68:	e0bff617 	ldw	r2,-40(fp)
 822ad6c:	108000c4 	addi	r2,r2,3
 822ad70:	e0fffd04 	addi	r3,fp,-12
 822ad74:	18c00003 	ldbu	r3,0(r3)
 822ad78:	10c00005 	stb	r3,0(r2)
 822ad7c:	e0bff617 	ldw	r2,-40(fp)
 822ad80:	10c00084 	addi	r3,r2,2
 822ad84:	e0bffd04 	addi	r2,fp,-12
 822ad88:	10800044 	addi	r2,r2,1
 822ad8c:	10800003 	ldbu	r2,0(r2)
 822ad90:	18800005 	stb	r2,0(r3)
 822ad94:	e0bff617 	ldw	r2,-40(fp)
 822ad98:	10c00044 	addi	r3,r2,1
 822ad9c:	e0bffd04 	addi	r2,fp,-12
 822ada0:	10800084 	addi	r2,r2,2
 822ada4:	10800003 	ldbu	r2,0(r2)
 822ada8:	18800005 	stb	r2,0(r3)
 822adac:	e0bffd04 	addi	r2,fp,-12
 822adb0:	108000c4 	addi	r2,r2,3
 822adb4:	10800003 	ldbu	r2,0(r2)
 822adb8:	1007883a 	mov	r3,r2
 822adbc:	e0bff617 	ldw	r2,-40(fp)
 822adc0:	10c00005 	stb	r3,0(r2)
 822adc4:	e0bff617 	ldw	r2,-40(fp)
 822adc8:	10800104 	addi	r2,r2,4
 822adcc:	e0bff615 	stw	r2,-40(fp)
   }
   if (dhc_states[iface].snmask)
 822add0:	008209b4 	movhi	r2,2086
 822add4:	10b84104 	addi	r2,r2,-7932
 822add8:	e0fffe17 	ldw	r3,-8(fp)
 822addc:	18c00f24 	muli	r3,r3,60
 822ade0:	10c5883a 	add	r2,r2,r3
 822ade4:	10800a04 	addi	r2,r2,40
 822ade8:	10800017 	ldw	r2,0(r2)
 822adec:	10004a26 	beq	r2,zero,822af18 <dhc_request+0x410>
   {
      opt_ip = ntohl(dhc_states[iface].snmask);
 822adf0:	008209b4 	movhi	r2,2086
 822adf4:	10b84104 	addi	r2,r2,-7932
 822adf8:	e0fffe17 	ldw	r3,-8(fp)
 822adfc:	18c00f24 	muli	r3,r3,60
 822ae00:	10c5883a 	add	r2,r2,r3
 822ae04:	10800a04 	addi	r2,r2,40
 822ae08:	10800017 	ldw	r2,0(r2)
 822ae0c:	1006d63a 	srli	r3,r2,24
 822ae10:	008209b4 	movhi	r2,2086
 822ae14:	10b84104 	addi	r2,r2,-7932
 822ae18:	e13ffe17 	ldw	r4,-8(fp)
 822ae1c:	21000f24 	muli	r4,r4,60
 822ae20:	1105883a 	add	r2,r2,r4
 822ae24:	10800a04 	addi	r2,r2,40
 822ae28:	10800017 	ldw	r2,0(r2)
 822ae2c:	1004d23a 	srli	r2,r2,8
 822ae30:	10bfc00c 	andi	r2,r2,65280
 822ae34:	1886b03a 	or	r3,r3,r2
 822ae38:	008209b4 	movhi	r2,2086
 822ae3c:	10b84104 	addi	r2,r2,-7932
 822ae40:	e13ffe17 	ldw	r4,-8(fp)
 822ae44:	21000f24 	muli	r4,r4,60
 822ae48:	1105883a 	add	r2,r2,r4
 822ae4c:	10800a04 	addi	r2,r2,40
 822ae50:	10800017 	ldw	r2,0(r2)
 822ae54:	10bfc00c 	andi	r2,r2,65280
 822ae58:	1004923a 	slli	r2,r2,8
 822ae5c:	1886b03a 	or	r3,r3,r2
 822ae60:	008209b4 	movhi	r2,2086
 822ae64:	10b84104 	addi	r2,r2,-7932
 822ae68:	e13ffe17 	ldw	r4,-8(fp)
 822ae6c:	21000f24 	muli	r4,r4,60
 822ae70:	1105883a 	add	r2,r2,r4
 822ae74:	10800a04 	addi	r2,r2,40
 822ae78:	10800017 	ldw	r2,0(r2)
 822ae7c:	1004963a 	slli	r2,r2,24
 822ae80:	1884b03a 	or	r2,r3,r2
 822ae84:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_SNMASK, opt_ip);
 822ae88:	e0bff617 	ldw	r2,-40(fp)
 822ae8c:	10c00044 	addi	r3,r2,1
 822ae90:	e0fff615 	stw	r3,-40(fp)
 822ae94:	00c00044 	movi	r3,1
 822ae98:	10c00005 	stb	r3,0(r2)
 822ae9c:	e0bff617 	ldw	r2,-40(fp)
 822aea0:	10c00044 	addi	r3,r2,1
 822aea4:	e0fff615 	stw	r3,-40(fp)
 822aea8:	00c00104 	movi	r3,4
 822aeac:	10c00005 	stb	r3,0(r2)
 822aeb0:	e0bff617 	ldw	r2,-40(fp)
 822aeb4:	108000c4 	addi	r2,r2,3
 822aeb8:	e0fffd04 	addi	r3,fp,-12
 822aebc:	18c00003 	ldbu	r3,0(r3)
 822aec0:	10c00005 	stb	r3,0(r2)
 822aec4:	e0bff617 	ldw	r2,-40(fp)
 822aec8:	10c00084 	addi	r3,r2,2
 822aecc:	e0bffd04 	addi	r2,fp,-12
 822aed0:	10800044 	addi	r2,r2,1
 822aed4:	10800003 	ldbu	r2,0(r2)
 822aed8:	18800005 	stb	r2,0(r3)
 822aedc:	e0bff617 	ldw	r2,-40(fp)
 822aee0:	10c00044 	addi	r3,r2,1
 822aee4:	e0bffd04 	addi	r2,fp,-12
 822aee8:	10800084 	addi	r2,r2,2
 822aeec:	10800003 	ldbu	r2,0(r2)
 822aef0:	18800005 	stb	r2,0(r3)
 822aef4:	e0bffd04 	addi	r2,fp,-12
 822aef8:	108000c4 	addi	r2,r2,3
 822aefc:	10800003 	ldbu	r2,0(r2)
 822af00:	1007883a 	mov	r3,r2
 822af04:	e0bff617 	ldw	r2,-40(fp)
 822af08:	10c00005 	stb	r3,0(r2)
 822af0c:	e0bff617 	ldw	r2,-40(fp)
 822af10:	10800104 	addi	r2,r2,4
 822af14:	e0bff615 	stw	r2,-40(fp)
   }
   if (dhc_states[iface].defgw)
 822af18:	008209b4 	movhi	r2,2086
 822af1c:	10b84104 	addi	r2,r2,-7932
 822af20:	e0fffe17 	ldw	r3,-8(fp)
 822af24:	18c00f24 	muli	r3,r3,60
 822af28:	10c5883a 	add	r2,r2,r3
 822af2c:	10800b04 	addi	r2,r2,44
 822af30:	10800017 	ldw	r2,0(r2)
 822af34:	10004a26 	beq	r2,zero,822b060 <dhc_request+0x558>
   {
      opt_ip = ntohl(dhc_states[iface].defgw);
 822af38:	008209b4 	movhi	r2,2086
 822af3c:	10b84104 	addi	r2,r2,-7932
 822af40:	e0fffe17 	ldw	r3,-8(fp)
 822af44:	18c00f24 	muli	r3,r3,60
 822af48:	10c5883a 	add	r2,r2,r3
 822af4c:	10800b04 	addi	r2,r2,44
 822af50:	10800017 	ldw	r2,0(r2)
 822af54:	1006d63a 	srli	r3,r2,24
 822af58:	008209b4 	movhi	r2,2086
 822af5c:	10b84104 	addi	r2,r2,-7932
 822af60:	e13ffe17 	ldw	r4,-8(fp)
 822af64:	21000f24 	muli	r4,r4,60
 822af68:	1105883a 	add	r2,r2,r4
 822af6c:	10800b04 	addi	r2,r2,44
 822af70:	10800017 	ldw	r2,0(r2)
 822af74:	1004d23a 	srli	r2,r2,8
 822af78:	10bfc00c 	andi	r2,r2,65280
 822af7c:	1886b03a 	or	r3,r3,r2
 822af80:	008209b4 	movhi	r2,2086
 822af84:	10b84104 	addi	r2,r2,-7932
 822af88:	e13ffe17 	ldw	r4,-8(fp)
 822af8c:	21000f24 	muli	r4,r4,60
 822af90:	1105883a 	add	r2,r2,r4
 822af94:	10800b04 	addi	r2,r2,44
 822af98:	10800017 	ldw	r2,0(r2)
 822af9c:	10bfc00c 	andi	r2,r2,65280
 822afa0:	1004923a 	slli	r2,r2,8
 822afa4:	1886b03a 	or	r3,r3,r2
 822afa8:	008209b4 	movhi	r2,2086
 822afac:	10b84104 	addi	r2,r2,-7932
 822afb0:	e13ffe17 	ldw	r4,-8(fp)
 822afb4:	21000f24 	muli	r4,r4,60
 822afb8:	1105883a 	add	r2,r2,r4
 822afbc:	10800b04 	addi	r2,r2,44
 822afc0:	10800017 	ldw	r2,0(r2)
 822afc4:	1004963a 	slli	r2,r2,24
 822afc8:	1884b03a 	or	r2,r3,r2
 822afcc:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_ROUTER, opt_ip);
 822afd0:	e0bff617 	ldw	r2,-40(fp)
 822afd4:	10c00044 	addi	r3,r2,1
 822afd8:	e0fff615 	stw	r3,-40(fp)
 822afdc:	00c000c4 	movi	r3,3
 822afe0:	10c00005 	stb	r3,0(r2)
 822afe4:	e0bff617 	ldw	r2,-40(fp)
 822afe8:	10c00044 	addi	r3,r2,1
 822afec:	e0fff615 	stw	r3,-40(fp)
 822aff0:	00c00104 	movi	r3,4
 822aff4:	10c00005 	stb	r3,0(r2)
 822aff8:	e0bff617 	ldw	r2,-40(fp)
 822affc:	108000c4 	addi	r2,r2,3
 822b000:	e0fffd04 	addi	r3,fp,-12
 822b004:	18c00003 	ldbu	r3,0(r3)
 822b008:	10c00005 	stb	r3,0(r2)
 822b00c:	e0bff617 	ldw	r2,-40(fp)
 822b010:	10c00084 	addi	r3,r2,2
 822b014:	e0bffd04 	addi	r2,fp,-12
 822b018:	10800044 	addi	r2,r2,1
 822b01c:	10800003 	ldbu	r2,0(r2)
 822b020:	18800005 	stb	r2,0(r3)
 822b024:	e0bff617 	ldw	r2,-40(fp)
 822b028:	10c00044 	addi	r3,r2,1
 822b02c:	e0bffd04 	addi	r2,fp,-12
 822b030:	10800084 	addi	r2,r2,2
 822b034:	10800003 	ldbu	r2,0(r2)
 822b038:	18800005 	stb	r2,0(r3)
 822b03c:	e0bffd04 	addi	r2,fp,-12
 822b040:	108000c4 	addi	r2,r2,3
 822b044:	10800003 	ldbu	r2,0(r2)
 822b048:	1007883a 	mov	r3,r2
 822b04c:	e0bff617 	ldw	r2,-40(fp)
 822b050:	10c00005 	stb	r3,0(r2)
 822b054:	e0bff617 	ldw	r2,-40(fp)
 822b058:	10800104 	addi	r2,r2,4
 822b05c:	e0bff615 	stw	r2,-40(fp)
         }
      }
   }
#endif

   if (dhc_states[iface].lease)
 822b060:	008209b4 	movhi	r2,2086
 822b064:	10b84104 	addi	r2,r2,-7932
 822b068:	e0fffe17 	ldw	r3,-8(fp)
 822b06c:	18c00f24 	muli	r3,r3,60
 822b070:	10c5883a 	add	r2,r2,r3
 822b074:	10800504 	addi	r2,r2,20
 822b078:	10800017 	ldw	r2,0(r2)
 822b07c:	10003826 	beq	r2,zero,822b160 <dhc_request+0x658>
   {
      PUT_IP_OPT(opts, DHOP_LEASE, dhc_states[iface].lease);
 822b080:	e0bff617 	ldw	r2,-40(fp)
 822b084:	10c00044 	addi	r3,r2,1
 822b088:	e0fff615 	stw	r3,-40(fp)
 822b08c:	00c00cc4 	movi	r3,51
 822b090:	10c00005 	stb	r3,0(r2)
 822b094:	e0bff617 	ldw	r2,-40(fp)
 822b098:	10c00044 	addi	r3,r2,1
 822b09c:	e0fff615 	stw	r3,-40(fp)
 822b0a0:	00c00104 	movi	r3,4
 822b0a4:	10c00005 	stb	r3,0(r2)
 822b0a8:	e0bff617 	ldw	r2,-40(fp)
 822b0ac:	10c000c4 	addi	r3,r2,3
 822b0b0:	e0bffe17 	ldw	r2,-8(fp)
 822b0b4:	10800f24 	muli	r2,r2,60
 822b0b8:	11000504 	addi	r4,r2,20
 822b0bc:	008209b4 	movhi	r2,2086
 822b0c0:	10b84104 	addi	r2,r2,-7932
 822b0c4:	2085883a 	add	r2,r4,r2
 822b0c8:	10800003 	ldbu	r2,0(r2)
 822b0cc:	18800005 	stb	r2,0(r3)
 822b0d0:	e0bff617 	ldw	r2,-40(fp)
 822b0d4:	10c00084 	addi	r3,r2,2
 822b0d8:	e0bffe17 	ldw	r2,-8(fp)
 822b0dc:	10800f24 	muli	r2,r2,60
 822b0e0:	11000504 	addi	r4,r2,20
 822b0e4:	008209b4 	movhi	r2,2086
 822b0e8:	10b84104 	addi	r2,r2,-7932
 822b0ec:	2085883a 	add	r2,r4,r2
 822b0f0:	10800044 	addi	r2,r2,1
 822b0f4:	10800003 	ldbu	r2,0(r2)
 822b0f8:	18800005 	stb	r2,0(r3)
 822b0fc:	e0bff617 	ldw	r2,-40(fp)
 822b100:	10c00044 	addi	r3,r2,1
 822b104:	e0bffe17 	ldw	r2,-8(fp)
 822b108:	10800f24 	muli	r2,r2,60
 822b10c:	11000504 	addi	r4,r2,20
 822b110:	008209b4 	movhi	r2,2086
 822b114:	10b84104 	addi	r2,r2,-7932
 822b118:	2085883a 	add	r2,r4,r2
 822b11c:	10800084 	addi	r2,r2,2
 822b120:	10800003 	ldbu	r2,0(r2)
 822b124:	18800005 	stb	r2,0(r3)
 822b128:	e0bffe17 	ldw	r2,-8(fp)
 822b12c:	10800f24 	muli	r2,r2,60
 822b130:	10c00504 	addi	r3,r2,20
 822b134:	008209b4 	movhi	r2,2086
 822b138:	10b84104 	addi	r2,r2,-7932
 822b13c:	1885883a 	add	r2,r3,r2
 822b140:	108000c4 	addi	r2,r2,3
 822b144:	10800003 	ldbu	r2,0(r2)
 822b148:	1007883a 	mov	r3,r2
 822b14c:	e0bff617 	ldw	r2,-40(fp)
 822b150:	10c00005 	stb	r3,0(r2)
 822b154:	e0bff617 	ldw	r2,-40(fp)
 822b158:	10800104 	addi	r2,r2,4
 822b15c:	e0bff615 	stw	r2,-40(fp)
   }

   /* If there is a list of options to be requested from server, include it*/
#ifdef DHCP_REQLIST
   if ( reqlist_len > 0 )
 822b160:	d0a03517 	ldw	r2,-32556(gp)
 822b164:	00801a0e 	bge	zero,r2,822b1d0 <dhc_request+0x6c8>
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
 822b168:	e0bff617 	ldw	r2,-40(fp)
 822b16c:	10c00044 	addi	r3,r2,1
 822b170:	e0fff615 	stw	r3,-40(fp)
 822b174:	00c00dc4 	movi	r3,55
 822b178:	10c00005 	stb	r3,0(r2)
      *opts++ = (u_char)reqlist_len ;
 822b17c:	e0bff617 	ldw	r2,-40(fp)
 822b180:	10c00044 	addi	r3,r2,1
 822b184:	e0fff615 	stw	r3,-40(fp)
 822b188:	d0e03517 	ldw	r3,-32556(gp)
 822b18c:	10c00005 	stb	r3,0(r2)

      for (i=0 ; i < reqlist_len ; i++ )
 822b190:	e03ff715 	stw	zero,-36(fp)
 822b194:	00000b06 	br	822b1c4 <dhc_request+0x6bc>
         *opts++ = reqlist[i];
 822b198:	e0bff617 	ldw	r2,-40(fp)
 822b19c:	10c00044 	addi	r3,r2,1
 822b1a0:	e0fff615 	stw	r3,-40(fp)
 822b1a4:	e13ff717 	ldw	r4,-36(fp)
 822b1a8:	d0e03404 	addi	r3,gp,-32560
 822b1ac:	20c7883a 	add	r3,r4,r3
 822b1b0:	18c00003 	ldbu	r3,0(r3)
 822b1b4:	10c00005 	stb	r3,0(r2)
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
      *opts++ = (u_char)reqlist_len ;

      for (i=0 ; i < reqlist_len ; i++ )
 822b1b8:	e0bff717 	ldw	r2,-36(fp)
 822b1bc:	10800044 	addi	r2,r2,1
 822b1c0:	e0bff715 	stw	r2,-36(fp)
 822b1c4:	d0a03517 	ldw	r2,-32556(gp)
 822b1c8:	e0fff717 	ldw	r3,-36(fp)
 822b1cc:	18bff216 	blt	r3,r2,822b198 <dhc_request+0x690>
         *opts++ = reqlist[i];
   }
#endif   /* DHCP_REQLIST */

   /* only set client IP address (ours) when renewing or rebinding */
   if ((dhc_states[iface].state == DHCS_RENEWING)
 822b1d0:	008209b4 	movhi	r2,2086
 822b1d4:	10b84104 	addi	r2,r2,-7932
 822b1d8:	e0fffe17 	ldw	r3,-8(fp)
 822b1dc:	18c00f24 	muli	r3,r3,60
 822b1e0:	10c5883a 	add	r2,r2,r3
 822b1e4:	10800017 	ldw	r2,0(r2)
 822b1e8:	108001e0 	cmpeqi	r2,r2,7
 822b1ec:	1000081e 	bne	r2,zero,822b210 <dhc_request+0x708>
       || (dhc_states[iface].state == DHCS_REBINDING))
 822b1f0:	008209b4 	movhi	r2,2086
 822b1f4:	10b84104 	addi	r2,r2,-7932
 822b1f8:	e0fffe17 	ldw	r3,-8(fp)
 822b1fc:	18c00f24 	muli	r3,r3,60
 822b200:	10c5883a 	add	r2,r2,r3
 822b204:	10800017 	ldw	r2,0(r2)
 822b208:	10800218 	cmpnei	r2,r2,8
 822b20c:	10000a1e 	bne	r2,zero,822b238 <dhc_request+0x730>
   {
      outbp->ciaddr = nets[iface]->n_ipaddr;
 822b210:	008209b4 	movhi	r2,2086
 822b214:	10b81b04 	addi	r2,r2,-8084
 822b218:	e0fffe17 	ldw	r3,-8(fp)
 822b21c:	18c7883a 	add	r3,r3,r3
 822b220:	18c7883a 	add	r3,r3,r3
 822b224:	10c5883a 	add	r2,r2,r3
 822b228:	10800017 	ldw	r2,0(r2)
 822b22c:	10c00a17 	ldw	r3,40(r2)
 822b230:	e0bff917 	ldw	r2,-28(fp)
 822b234:	10c00315 	stw	r3,12(r2)
    * "Client inserts the address of the selected server in 'server 
    * identifier'. . . ." RFC 951, p. 4 definition of 'siaddr' is 
    * "server IP address; returned in bootreply by server." 
    */
   /* Only include server identifier option when selecting a server. */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 822b238:	008209b4 	movhi	r2,2086
 822b23c:	10b84104 	addi	r2,r2,-7932
 822b240:	e0fffe17 	ldw	r3,-8(fp)
 822b244:	18c00f24 	muli	r3,r3,60
 822b248:	10c5883a 	add	r2,r2,r3
 822b24c:	10800017 	ldw	r2,0(r2)
 822b250:	10800120 	cmpeqi	r2,r2,4
 822b254:	1000081e 	bne	r2,zero,822b278 <dhc_request+0x770>
       (dhc_states[iface].state == DHCS_REQUESTING))
 822b258:	008209b4 	movhi	r2,2086
 822b25c:	10b84104 	addi	r2,r2,-7932
 822b260:	e0fffe17 	ldw	r3,-8(fp)
 822b264:	18c00f24 	muli	r3,r3,60
 822b268:	10c5883a 	add	r2,r2,r3
 822b26c:	10800017 	ldw	r2,0(r2)
    * "Client inserts the address of the selected server in 'server 
    * identifier'. . . ." RFC 951, p. 4 definition of 'siaddr' is 
    * "server IP address; returned in bootreply by server." 
    */
   /* Only include server identifier option when selecting a server. */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 822b270:	10800158 	cmpnei	r2,r2,5
 822b274:	10004a1e 	bne	r2,zero,822b3a0 <dhc_request+0x898>
       (dhc_states[iface].state == DHCS_REQUESTING))
   {
      opt_ip = ntohl(dhc_states[iface].srv_ipaddr);
 822b278:	008209b4 	movhi	r2,2086
 822b27c:	10b84104 	addi	r2,r2,-7932
 822b280:	e0fffe17 	ldw	r3,-8(fp)
 822b284:	18c00f24 	muli	r3,r3,60
 822b288:	10c5883a 	add	r2,r2,r3
 822b28c:	10800d04 	addi	r2,r2,52
 822b290:	10800017 	ldw	r2,0(r2)
 822b294:	1006d63a 	srli	r3,r2,24
 822b298:	008209b4 	movhi	r2,2086
 822b29c:	10b84104 	addi	r2,r2,-7932
 822b2a0:	e13ffe17 	ldw	r4,-8(fp)
 822b2a4:	21000f24 	muli	r4,r4,60
 822b2a8:	1105883a 	add	r2,r2,r4
 822b2ac:	10800d04 	addi	r2,r2,52
 822b2b0:	10800017 	ldw	r2,0(r2)
 822b2b4:	1004d23a 	srli	r2,r2,8
 822b2b8:	10bfc00c 	andi	r2,r2,65280
 822b2bc:	1886b03a 	or	r3,r3,r2
 822b2c0:	008209b4 	movhi	r2,2086
 822b2c4:	10b84104 	addi	r2,r2,-7932
 822b2c8:	e13ffe17 	ldw	r4,-8(fp)
 822b2cc:	21000f24 	muli	r4,r4,60
 822b2d0:	1105883a 	add	r2,r2,r4
 822b2d4:	10800d04 	addi	r2,r2,52
 822b2d8:	10800017 	ldw	r2,0(r2)
 822b2dc:	10bfc00c 	andi	r2,r2,65280
 822b2e0:	1004923a 	slli	r2,r2,8
 822b2e4:	1886b03a 	or	r3,r3,r2
 822b2e8:	008209b4 	movhi	r2,2086
 822b2ec:	10b84104 	addi	r2,r2,-7932
 822b2f0:	e13ffe17 	ldw	r4,-8(fp)
 822b2f4:	21000f24 	muli	r4,r4,60
 822b2f8:	1105883a 	add	r2,r2,r4
 822b2fc:	10800d04 	addi	r2,r2,52
 822b300:	10800017 	ldw	r2,0(r2)
 822b304:	1004963a 	slli	r2,r2,24
 822b308:	1884b03a 	or	r2,r3,r2
 822b30c:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_SERVER, opt_ip);
 822b310:	e0bff617 	ldw	r2,-40(fp)
 822b314:	10c00044 	addi	r3,r2,1
 822b318:	e0fff615 	stw	r3,-40(fp)
 822b31c:	00c00d84 	movi	r3,54
 822b320:	10c00005 	stb	r3,0(r2)
 822b324:	e0bff617 	ldw	r2,-40(fp)
 822b328:	10c00044 	addi	r3,r2,1
 822b32c:	e0fff615 	stw	r3,-40(fp)
 822b330:	00c00104 	movi	r3,4
 822b334:	10c00005 	stb	r3,0(r2)
 822b338:	e0bff617 	ldw	r2,-40(fp)
 822b33c:	108000c4 	addi	r2,r2,3
 822b340:	e0fffd04 	addi	r3,fp,-12
 822b344:	18c00003 	ldbu	r3,0(r3)
 822b348:	10c00005 	stb	r3,0(r2)
 822b34c:	e0bff617 	ldw	r2,-40(fp)
 822b350:	10c00084 	addi	r3,r2,2
 822b354:	e0bffd04 	addi	r2,fp,-12
 822b358:	10800044 	addi	r2,r2,1
 822b35c:	10800003 	ldbu	r2,0(r2)
 822b360:	18800005 	stb	r2,0(r3)
 822b364:	e0bff617 	ldw	r2,-40(fp)
 822b368:	10c00044 	addi	r3,r2,1
 822b36c:	e0bffd04 	addi	r2,fp,-12
 822b370:	10800084 	addi	r2,r2,2
 822b374:	10800003 	ldbu	r2,0(r2)
 822b378:	18800005 	stb	r2,0(r3)
 822b37c:	e0bffd04 	addi	r2,fp,-12
 822b380:	108000c4 	addi	r2,r2,3
 822b384:	10800003 	ldbu	r2,0(r2)
 822b388:	1007883a 	mov	r3,r2
 822b38c:	e0bff617 	ldw	r2,-40(fp)
 822b390:	10c00005 	stb	r3,0(r2)
 822b394:	e0bff617 	ldw	r2,-40(fp)
 822b398:	10800104 	addi	r2,r2,4
 822b39c:	e0bff615 	stw	r2,-40(fp)
   /* add hostname (code 12) */
   PUT_STRING_OPT(opts, 12, dhc_hostname()); 
#endif /* USE_AUTOIP */

   /* Client Fully Qualified Domain Name */
   PUT_STRING_OPT(opts, 81, DC_DOMAINNAME); 
 822b3a0:	e0bff617 	ldw	r2,-40(fp)
 822b3a4:	10c00044 	addi	r3,r2,1
 822b3a8:	e0fff615 	stw	r3,-40(fp)
 822b3ac:	00c01444 	movi	r3,81
 822b3b0:	10c00005 	stb	r3,0(r2)
 822b3b4:	00800184 	movi	r2,6
 822b3b8:	e0bffb15 	stw	r2,-20(fp)
 822b3bc:	e0bff617 	ldw	r2,-40(fp)
 822b3c0:	10c00044 	addi	r3,r2,1
 822b3c4:	e0fff615 	stw	r3,-40(fp)
 822b3c8:	e0fffb17 	ldw	r3,-20(fp)
 822b3cc:	10c00005 	stb	r3,0(r2)
 822b3d0:	e0bffb17 	ldw	r2,-20(fp)
 822b3d4:	100d883a 	mov	r6,r2
 822b3d8:	01420974 	movhi	r5,2085
 822b3dc:	29421904 	addi	r5,r5,2148
 822b3e0:	e13ff617 	ldw	r4,-40(fp)
 822b3e4:	824b8180 	call	824b818 <strncpy>
 822b3e8:	e0bffb17 	ldw	r2,-20(fp)
 822b3ec:	e0fff617 	ldw	r3,-40(fp)
 822b3f0:	1885883a 	add	r2,r3,r2
 822b3f4:	e0bff615 	stw	r2,-40(fp)
   /* Vendor Class Identifier */
   PUT_STRING_OPT(opts, 60, name); 
 822b3f8:	e0bff617 	ldw	r2,-40(fp)
 822b3fc:	10c00044 	addi	r3,r2,1
 822b400:	e0fff615 	stw	r3,-40(fp)
 822b404:	00c00f04 	movi	r3,60
 822b408:	10c00005 	stb	r3,0(r2)
 822b40c:	d0a04b17 	ldw	r2,-32468(gp)
 822b410:	1009883a 	mov	r4,r2
 822b414:	8203f600 	call	8203f60 <strlen>
 822b418:	e0bffc15 	stw	r2,-16(fp)
 822b41c:	e0bff617 	ldw	r2,-40(fp)
 822b420:	10c00044 	addi	r3,r2,1
 822b424:	e0fff615 	stw	r3,-40(fp)
 822b428:	e0fffc17 	ldw	r3,-16(fp)
 822b42c:	10c00005 	stb	r3,0(r2)
 822b430:	d0a04b17 	ldw	r2,-32468(gp)
 822b434:	e0fffc17 	ldw	r3,-16(fp)
 822b438:	180d883a 	mov	r6,r3
 822b43c:	100b883a 	mov	r5,r2
 822b440:	e13ff617 	ldw	r4,-40(fp)
 822b444:	824b8180 	call	824b818 <strncpy>
 822b448:	e0bffc17 	ldw	r2,-16(fp)
 822b44c:	e0fff617 	ldw	r3,-40(fp)
 822b450:	1885883a 	add	r2,r3,r2
 822b454:	e0bff615 	stw	r2,-40(fp)

   *opts++ = DHOP_END;  /* Mark the end of options */
 822b458:	e0bff617 	ldw	r2,-40(fp)
 822b45c:	10c00044 	addi	r3,r2,1
 822b460:	e0fff615 	stw	r3,-40(fp)
 822b464:	00ffffc4 	movi	r3,-1
 822b468:	10c00005 	stb	r3,0(r2)

   /* figure out whether to send via unicast or broadcast */
   if (dhc_states[iface].state == DHCS_RENEWING)
 822b46c:	008209b4 	movhi	r2,2086
 822b470:	10b84104 	addi	r2,r2,-7932
 822b474:	e0fffe17 	ldw	r3,-8(fp)
 822b478:	18c00f24 	muli	r3,r3,60
 822b47c:	10c5883a 	add	r2,r2,r3
 822b480:	10800017 	ldw	r2,0(r2)
 822b484:	108001d8 	cmpnei	r2,r2,7
 822b488:	10000a1e 	bne	r2,zero,822b4b4 <dhc_request+0x9ac>
   {
      pkt->fhost = dhc_states[iface].srv_ipaddr;
 822b48c:	008209b4 	movhi	r2,2086
 822b490:	10b84104 	addi	r2,r2,-7932
 822b494:	e0fffe17 	ldw	r3,-8(fp)
 822b498:	18c00f24 	muli	r3,r3,60
 822b49c:	10c5883a 	add	r2,r2,r3
 822b4a0:	10800d04 	addi	r2,r2,52
 822b4a4:	10c00017 	ldw	r3,0(r2)
 822b4a8:	e0bff817 	ldw	r2,-32(fp)
 822b4ac:	10c00715 	stw	r3,28(r2)
 822b4b0:	00000306 	br	822b4c0 <dhc_request+0x9b8>
   }
   else
   {
      pkt->fhost = 0xFFFFFFFF;   /* broadcast request */
 822b4b4:	e0bff817 	ldw	r2,-32(fp)
 822b4b8:	00ffffc4 	movi	r3,-1
 822b4bc:	10c00715 	stw	r3,28(r2)
   }

   pkt->net = nets[iface];    /* send out caller spec'ed net */
 822b4c0:	008209b4 	movhi	r2,2086
 822b4c4:	10b81b04 	addi	r2,r2,-8084
 822b4c8:	e0fffe17 	ldw	r3,-8(fp)
 822b4cc:	18c7883a 	add	r3,r3,r3
 822b4d0:	18c7883a 	add	r3,r3,r3
 822b4d4:	10c5883a 	add	r2,r2,r3
 822b4d8:	10c00017 	ldw	r3,0(r2)
 822b4dc:	e0bff817 	ldw	r2,-32(fp)
 822b4e0:	10c00615 	stw	r3,24(r2)
   pkt->nb_plen = (char *)opts - (char *)outbp;
 822b4e4:	e0fff617 	ldw	r3,-40(fp)
 822b4e8:	e0bff917 	ldw	r2,-28(fp)
 822b4ec:	1885c83a 	sub	r2,r3,r2
 822b4f0:	1007883a 	mov	r3,r2
 822b4f4:	e0bff817 	ldw	r2,-32(fp)
 822b4f8:	10c00415 	stw	r3,16(r2)
   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 822b4fc:	e1bff817 	ldw	r6,-32(fp)
 822b500:	01401104 	movi	r5,68
 822b504:	010010c4 	movi	r4,67
 822b508:	8244fac0 	call	8244fac <udp_send>
   dsc_requests++;
 822b50c:	d0a09317 	ldw	r2,-32180(gp)
 822b510:	10800044 	addi	r2,r2,1
 822b514:	d0a09315 	stw	r2,-32180(gp)

   dhc_states[iface].last_tick = cticks;
 822b518:	d0e0a817 	ldw	r3,-32096(gp)
 822b51c:	008209b4 	movhi	r2,2086
 822b520:	10b84104 	addi	r2,r2,-7932
 822b524:	e13ffe17 	ldw	r4,-8(fp)
 822b528:	21000f24 	muli	r4,r4,60
 822b52c:	1105883a 	add	r2,r2,r4
 822b530:	10800404 	addi	r2,r2,16
 822b534:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].tries++;
 822b538:	008209b4 	movhi	r2,2086
 822b53c:	10b84104 	addi	r2,r2,-7932
 822b540:	e0fffe17 	ldw	r3,-8(fp)
 822b544:	18c00f24 	muli	r3,r3,60
 822b548:	10c5883a 	add	r2,r2,r3
 822b54c:	10800104 	addi	r2,r2,4
 822b550:	10800017 	ldw	r2,0(r2)
 822b554:	10c00044 	addi	r3,r2,1
 822b558:	008209b4 	movhi	r2,2086
 822b55c:	10b84104 	addi	r2,r2,-7932
 822b560:	e13ffe17 	ldw	r4,-8(fp)
 822b564:	21000f24 	muli	r4,r4,60
 822b568:	1105883a 	add	r2,r2,r4
 822b56c:	10800104 	addi	r2,r2,4
 822b570:	10c00015 	stw	r3,0(r2)

   return 0;   /* return OK code */
 822b574:	0005883a 	mov	r2,zero
}
 822b578:	e037883a 	mov	sp,fp
 822b57c:	dfc00117 	ldw	ra,4(sp)
 822b580:	df000017 	ldw	fp,0(sp)
 822b584:	dec00204 	addi	sp,sp,8
 822b588:	f800283a 	ret

0822b58c <dhc_setip>:
 * RETURNS: Returns 0 if ok, else non-zero ENP error.
 */

int
dhc_setip(int iface)
{
 822b58c:	defffd04 	addi	sp,sp,-12
 822b590:	dfc00215 	stw	ra,8(sp)
 822b594:	df000115 	stw	fp,4(sp)
 822b598:	df000104 	addi	fp,sp,4
 822b59c:	e13fff15 	stw	r4,-4(fp)
   nets[iface]->n_ipaddr = dhc_states[iface].ipaddr;
 822b5a0:	008209b4 	movhi	r2,2086
 822b5a4:	10b81b04 	addi	r2,r2,-8084
 822b5a8:	e0ffff17 	ldw	r3,-4(fp)
 822b5ac:	18c7883a 	add	r3,r3,r3
 822b5b0:	18c7883a 	add	r3,r3,r3
 822b5b4:	10c5883a 	add	r2,r2,r3
 822b5b8:	10c00017 	ldw	r3,0(r2)
 822b5bc:	008209b4 	movhi	r2,2086
 822b5c0:	10b84104 	addi	r2,r2,-7932
 822b5c4:	e13fff17 	ldw	r4,-4(fp)
 822b5c8:	21000f24 	muli	r4,r4,60
 822b5cc:	1105883a 	add	r2,r2,r4
 822b5d0:	10800904 	addi	r2,r2,36
 822b5d4:	10800017 	ldw	r2,0(r2)
 822b5d8:	18800a15 	stw	r2,40(r3)
   nets[iface]->snmask   = dhc_states[iface].snmask;
 822b5dc:	008209b4 	movhi	r2,2086
 822b5e0:	10b81b04 	addi	r2,r2,-8084
 822b5e4:	e0ffff17 	ldw	r3,-4(fp)
 822b5e8:	18c7883a 	add	r3,r3,r3
 822b5ec:	18c7883a 	add	r3,r3,r3
 822b5f0:	10c5883a 	add	r2,r2,r3
 822b5f4:	10c00017 	ldw	r3,0(r2)
 822b5f8:	008209b4 	movhi	r2,2086
 822b5fc:	10b84104 	addi	r2,r2,-7932
 822b600:	e13fff17 	ldw	r4,-4(fp)
 822b604:	21000f24 	muli	r4,r4,60
 822b608:	1105883a 	add	r2,r2,r4
 822b60c:	10800a04 	addi	r2,r2,40
 822b610:	10800017 	ldw	r2,0(r2)
 822b614:	18800c15 	stw	r2,48(r3)
   nets[iface]->n_defgw  = dhc_states[iface].defgw;
 822b618:	008209b4 	movhi	r2,2086
 822b61c:	10b81b04 	addi	r2,r2,-8084
 822b620:	e0ffff17 	ldw	r3,-4(fp)
 822b624:	18c7883a 	add	r3,r3,r3
 822b628:	18c7883a 	add	r3,r3,r3
 822b62c:	10c5883a 	add	r2,r2,r3
 822b630:	10c00017 	ldw	r3,0(r2)
 822b634:	008209b4 	movhi	r2,2086
 822b638:	10b84104 	addi	r2,r2,-7932
 822b63c:	e13fff17 	ldw	r4,-4(fp)
 822b640:	21000f24 	muli	r4,r4,60
 822b644:	1105883a 	add	r2,r2,r4
 822b648:	10800b04 	addi	r2,r2,44
 822b64c:	10800017 	ldw	r2,0(r2)
 822b650:	18800d15 	stw	r2,52(r3)

   if ( nets[iface]->snmask == 0 )
 822b654:	008209b4 	movhi	r2,2086
 822b658:	10b81b04 	addi	r2,r2,-8084
 822b65c:	e0ffff17 	ldw	r3,-4(fp)
 822b660:	18c7883a 	add	r3,r3,r3
 822b664:	18c7883a 	add	r3,r3,r3
 822b668:	10c5883a 	add	r2,r2,r3
 822b66c:	10800017 	ldw	r2,0(r2)
 822b670:	10800c17 	ldw	r2,48(r2)
 822b674:	1000111e 	bne	r2,zero,822b6bc <dhc_setip+0x130>
   {
      fixup_subnet_mask(iface);
 822b678:	e13fff17 	ldw	r4,-4(fp)
 822b67c:	82260880 	call	8226088 <fixup_subnet_mask>
      dhc_states[iface].snmask = nets[iface]->snmask; 
 822b680:	008209b4 	movhi	r2,2086
 822b684:	10b81b04 	addi	r2,r2,-8084
 822b688:	e0ffff17 	ldw	r3,-4(fp)
 822b68c:	18c7883a 	add	r3,r3,r3
 822b690:	18c7883a 	add	r3,r3,r3
 822b694:	10c5883a 	add	r2,r2,r3
 822b698:	10800017 	ldw	r2,0(r2)
 822b69c:	10c00c17 	ldw	r3,48(r2)
 822b6a0:	008209b4 	movhi	r2,2086
 822b6a4:	10b84104 	addi	r2,r2,-7932
 822b6a8:	e13fff17 	ldw	r4,-4(fp)
 822b6ac:	21000f24 	muli	r4,r4,60
 822b6b0:	1105883a 	add	r2,r2,r4
 822b6b4:	10800a04 	addi	r2,r2,40
 822b6b8:	10c00015 	stw	r3,0(r2)
   }

   /* fixup broadcast addresses */
   nets[iface]->n_netbr    = nets[iface]->n_ipaddr | ~nets[iface]->snmask;
 822b6bc:	008209b4 	movhi	r2,2086
 822b6c0:	10b81b04 	addi	r2,r2,-8084
 822b6c4:	e0ffff17 	ldw	r3,-4(fp)
 822b6c8:	18c7883a 	add	r3,r3,r3
 822b6cc:	18c7883a 	add	r3,r3,r3
 822b6d0:	10c5883a 	add	r2,r2,r3
 822b6d4:	11000017 	ldw	r4,0(r2)
 822b6d8:	008209b4 	movhi	r2,2086
 822b6dc:	10b81b04 	addi	r2,r2,-8084
 822b6e0:	e0ffff17 	ldw	r3,-4(fp)
 822b6e4:	18c7883a 	add	r3,r3,r3
 822b6e8:	18c7883a 	add	r3,r3,r3
 822b6ec:	10c5883a 	add	r2,r2,r3
 822b6f0:	10800017 	ldw	r2,0(r2)
 822b6f4:	11400a17 	ldw	r5,40(r2)
 822b6f8:	008209b4 	movhi	r2,2086
 822b6fc:	10b81b04 	addi	r2,r2,-8084
 822b700:	e0ffff17 	ldw	r3,-4(fp)
 822b704:	18c7883a 	add	r3,r3,r3
 822b708:	18c7883a 	add	r3,r3,r3
 822b70c:	10c5883a 	add	r2,r2,r3
 822b710:	10800017 	ldw	r2,0(r2)
 822b714:	10800c17 	ldw	r2,48(r2)
 822b718:	0084303a 	nor	r2,zero,r2
 822b71c:	2884b03a 	or	r2,r5,r2
 822b720:	20800e15 	stw	r2,56(r4)
   nets[iface]->n_netbr42  = nets[iface]->n_ipaddr &  nets[iface]->snmask;
 822b724:	008209b4 	movhi	r2,2086
 822b728:	10b81b04 	addi	r2,r2,-8084
 822b72c:	e0ffff17 	ldw	r3,-4(fp)
 822b730:	18c7883a 	add	r3,r3,r3
 822b734:	18c7883a 	add	r3,r3,r3
 822b738:	10c5883a 	add	r2,r2,r3
 822b73c:	11000017 	ldw	r4,0(r2)
 822b740:	008209b4 	movhi	r2,2086
 822b744:	10b81b04 	addi	r2,r2,-8084
 822b748:	e0ffff17 	ldw	r3,-4(fp)
 822b74c:	18c7883a 	add	r3,r3,r3
 822b750:	18c7883a 	add	r3,r3,r3
 822b754:	10c5883a 	add	r2,r2,r3
 822b758:	10800017 	ldw	r2,0(r2)
 822b75c:	11400a17 	ldw	r5,40(r2)
 822b760:	008209b4 	movhi	r2,2086
 822b764:	10b81b04 	addi	r2,r2,-8084
 822b768:	e0ffff17 	ldw	r3,-4(fp)
 822b76c:	18c7883a 	add	r3,r3,r3
 822b770:	18c7883a 	add	r3,r3,r3
 822b774:	10c5883a 	add	r2,r2,r3
 822b778:	10800017 	ldw	r2,0(r2)
 822b77c:	10800c17 	ldw	r2,48(r2)
 822b780:	2884703a 	and	r2,r5,r2
 822b784:	20800f15 	stw	r2,60(r4)
   nets[iface]->n_subnetbr = nets[iface]->n_ipaddr | ~nets[iface]->snmask;
 822b788:	008209b4 	movhi	r2,2086
 822b78c:	10b81b04 	addi	r2,r2,-8084
 822b790:	e0ffff17 	ldw	r3,-4(fp)
 822b794:	18c7883a 	add	r3,r3,r3
 822b798:	18c7883a 	add	r3,r3,r3
 822b79c:	10c5883a 	add	r2,r2,r3
 822b7a0:	11000017 	ldw	r4,0(r2)
 822b7a4:	008209b4 	movhi	r2,2086
 822b7a8:	10b81b04 	addi	r2,r2,-8084
 822b7ac:	e0ffff17 	ldw	r3,-4(fp)
 822b7b0:	18c7883a 	add	r3,r3,r3
 822b7b4:	18c7883a 	add	r3,r3,r3
 822b7b8:	10c5883a 	add	r2,r2,r3
 822b7bc:	10800017 	ldw	r2,0(r2)
 822b7c0:	11400a17 	ldw	r5,40(r2)
 822b7c4:	008209b4 	movhi	r2,2086
 822b7c8:	10b81b04 	addi	r2,r2,-8084
 822b7cc:	e0ffff17 	ldw	r3,-4(fp)
 822b7d0:	18c7883a 	add	r3,r3,r3
 822b7d4:	18c7883a 	add	r3,r3,r3
 822b7d8:	10c5883a 	add	r2,r2,r3
 822b7dc:	10800017 	ldw	r2,0(r2)
 822b7e0:	10800c17 	ldw	r2,48(r2)
 822b7e4:	0084303a 	nor	r2,zero,r2
 822b7e8:	2884b03a 	or	r2,r5,r2
 822b7ec:	20801015 	stw	r2,64(r4)

   return 0;   /* return OK code */
 822b7f0:	0005883a 	mov	r2,zero
}
 822b7f4:	e037883a 	mov	sp,fp
 822b7f8:	dfc00117 	ldw	ra,4(sp)
 822b7fc:	df000017 	ldw	fp,0(sp)
 822b800:	dec00204 	addi	sp,sp,8
 822b804:	f800283a 	ret

0822b808 <dhc_resetip>:
 * RETURNS: Returns 0 if ok, else non-zero error. 
 */

int
dhc_resetip(int iface)
{
 822b808:	defffe04 	addi	sp,sp,-8
 822b80c:	df000115 	stw	fp,4(sp)
 822b810:	df000104 	addi	fp,sp,4
 822b814:	e13fff15 	stw	r4,-4(fp)
   /* reset the ipaddress */
   nets[iface]->n_ipaddr = 0;
 822b818:	008209b4 	movhi	r2,2086
 822b81c:	10b81b04 	addi	r2,r2,-8084
 822b820:	e0ffff17 	ldw	r3,-4(fp)
 822b824:	18c7883a 	add	r3,r3,r3
 822b828:	18c7883a 	add	r3,r3,r3
 822b82c:	10c5883a 	add	r2,r2,r3
 822b830:	10800017 	ldw	r2,0(r2)
 822b834:	10000a15 	stw	zero,40(r2)
   nets[iface]->snmask   = 0;
 822b838:	008209b4 	movhi	r2,2086
 822b83c:	10b81b04 	addi	r2,r2,-8084
 822b840:	e0ffff17 	ldw	r3,-4(fp)
 822b844:	18c7883a 	add	r3,r3,r3
 822b848:	18c7883a 	add	r3,r3,r3
 822b84c:	10c5883a 	add	r2,r2,r3
 822b850:	10800017 	ldw	r2,0(r2)
 822b854:	10000c15 	stw	zero,48(r2)
   nets[iface]->n_defgw  = 0;
 822b858:	008209b4 	movhi	r2,2086
 822b85c:	10b81b04 	addi	r2,r2,-8084
 822b860:	e0ffff17 	ldw	r3,-4(fp)
 822b864:	18c7883a 	add	r3,r3,r3
 822b868:	18c7883a 	add	r3,r3,r3
 822b86c:	10c5883a 	add	r2,r2,r3
 822b870:	10800017 	ldw	r2,0(r2)
 822b874:	10000d15 	stw	zero,52(r2)

   /* reset the broadcast addresses */
   nets[iface]->n_netbr    = 0;
 822b878:	008209b4 	movhi	r2,2086
 822b87c:	10b81b04 	addi	r2,r2,-8084
 822b880:	e0ffff17 	ldw	r3,-4(fp)
 822b884:	18c7883a 	add	r3,r3,r3
 822b888:	18c7883a 	add	r3,r3,r3
 822b88c:	10c5883a 	add	r2,r2,r3
 822b890:	10800017 	ldw	r2,0(r2)
 822b894:	10000e15 	stw	zero,56(r2)
   nets[iface]->n_netbr42  = 0;
 822b898:	008209b4 	movhi	r2,2086
 822b89c:	10b81b04 	addi	r2,r2,-8084
 822b8a0:	e0ffff17 	ldw	r3,-4(fp)
 822b8a4:	18c7883a 	add	r3,r3,r3
 822b8a8:	18c7883a 	add	r3,r3,r3
 822b8ac:	10c5883a 	add	r2,r2,r3
 822b8b0:	10800017 	ldw	r2,0(r2)
 822b8b4:	10000f15 	stw	zero,60(r2)
   nets[iface]->n_subnetbr = 0;
 822b8b8:	008209b4 	movhi	r2,2086
 822b8bc:	10b81b04 	addi	r2,r2,-8084
 822b8c0:	e0ffff17 	ldw	r3,-4(fp)
 822b8c4:	18c7883a 	add	r3,r3,r3
 822b8c8:	18c7883a 	add	r3,r3,r3
 822b8cc:	10c5883a 	add	r2,r2,r3
 822b8d0:	10800017 	ldw	r2,0(r2)
 822b8d4:	10001015 	stw	zero,64(r2)

   return 0;   /* return OK code */
 822b8d8:	0005883a 	mov	r2,zero
}
 822b8dc:	e037883a 	mov	sp,fp
 822b8e0:	df000017 	ldw	fp,0(sp)
 822b8e4:	dec00104 	addi	sp,sp,4
 822b8e8:	f800283a 	ret

0822b8ec <dhc_decline>:
 * RETURNS: Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_decline(int iface,struct bootp * bp, unsigned bplen)
{
 822b8ec:	defff804 	addi	sp,sp,-32
 822b8f0:	dfc00715 	stw	ra,28(sp)
 822b8f4:	df000615 	stw	fp,24(sp)
 822b8f8:	df000604 	addi	fp,sp,24
 822b8fc:	e13ffd15 	stw	r4,-12(fp)
 822b900:	e17ffe15 	stw	r5,-8(fp)
 822b904:	e1bfff15 	stw	r6,-4(fp)
   struct bootp * outbp;
   PACKET pkt;
   u_char * opts;    /* scratch pointer to DHCP options field */

   /* get a UDP packet buffer for sending DHCP */
   pkt = udp_alloc(bplen, 0);
 822b908:	e0bfff17 	ldw	r2,-4(fp)
 822b90c:	000b883a 	mov	r5,zero
 822b910:	1009883a 	mov	r4,r2
 822b914:	82453e80 	call	82453e8 <udp_alloc>
 822b918:	e0bffa15 	stw	r2,-24(fp)
   if (!pkt) 
 822b91c:	e0bffa17 	ldw	r2,-24(fp)
 822b920:	1000021e 	bne	r2,zero,822b92c <dhc_decline+0x40>
      return ENP_NOMEM;
 822b924:	00bffb04 	movi	r2,-20
 822b928:	00002d06 	br	822b9e0 <dhc_decline+0xf4>
   pkt->nb_plen = bplen;
 822b92c:	e0bffa17 	ldw	r2,-24(fp)
 822b930:	e0ffff17 	ldw	r3,-4(fp)
 822b934:	10c00415 	stw	r3,16(r2)

   outbp = (struct bootp *)pkt->nb_prot;
 822b938:	e0bffa17 	ldw	r2,-24(fp)
 822b93c:	10800317 	ldw	r2,12(r2)
 822b940:	e0bffb15 	stw	r2,-20(fp)
   MEMCPY(outbp, bp, bplen);
 822b944:	e1bfff17 	ldw	r6,-4(fp)
 822b948:	e17ffe17 	ldw	r5,-8(fp)
 822b94c:	e13ffb17 	ldw	r4,-20(fp)
 822b950:	8202f100 	call	8202f10 <memcpy>
   outbp->op = BOOTREQUEST;
 822b954:	e0bffb17 	ldw	r2,-20(fp)
 822b958:	00c00044 	movi	r3,1
 822b95c:	10c00005 	stb	r3,0(r2)

   /* find DHCP TYPE option so we can overwrite it */   
   opts = find_opt(DHOP_TYPE, &outbp->options[4]);
 822b960:	e0bffb17 	ldw	r2,-20(fp)
 822b964:	10803c04 	addi	r2,r2,240
 822b968:	100b883a 	mov	r5,r2
 822b96c:	01000d44 	movi	r4,53
 822b970:	822c6900 	call	822c690 <find_opt>
 822b974:	e0bffc15 	stw	r2,-16(fp)
   opts += 2;     /* point to actual op code */
 822b978:	e0bffc17 	ldw	r2,-16(fp)
 822b97c:	10800084 	addi	r2,r2,2
 822b980:	e0bffc15 	stw	r2,-16(fp)
   *opts = DHCP_DECLINE;   /* overwrite op code */
 822b984:	e0bffc17 	ldw	r2,-16(fp)
 822b988:	00c00104 	movi	r3,4
 822b98c:	10c00005 	stb	r3,0(r2)

   pkt->fhost = 0xFFFFFFFF;   /* broadcast decline pkt */
 822b990:	e0bffa17 	ldw	r2,-24(fp)
 822b994:	00ffffc4 	movi	r3,-1
 822b998:	10c00715 	stw	r3,28(r2)
   pkt->net = nets[iface];    /* send out caller speced net */
 822b99c:	008209b4 	movhi	r2,2086
 822b9a0:	10b81b04 	addi	r2,r2,-8084
 822b9a4:	e0fffd17 	ldw	r3,-12(fp)
 822b9a8:	18c7883a 	add	r3,r3,r3
 822b9ac:	18c7883a 	add	r3,r3,r3
 822b9b0:	10c5883a 	add	r2,r2,r3
 822b9b4:	10c00017 	ldw	r3,0(r2)
 822b9b8:	e0bffa17 	ldw	r2,-24(fp)
 822b9bc:	10c00615 	stw	r3,24(r2)
   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 822b9c0:	e1bffa17 	ldw	r6,-24(fp)
 822b9c4:	01401104 	movi	r5,68
 822b9c8:	010010c4 	movi	r4,67
 822b9cc:	8244fac0 	call	8244fac <udp_send>
   dsc_declines++;   /* count declines sent */
 822b9d0:	d0a09617 	ldw	r2,-32168(gp)
 822b9d4:	10800044 	addi	r2,r2,1
 822b9d8:	d0a09615 	stw	r2,-32168(gp)
   return 0;
 822b9dc:	0005883a 	mov	r2,zero
}
 822b9e0:	e037883a 	mov	sp,fp
 822b9e4:	dfc00117 	ldw	ra,4(sp)
 822b9e8:	df000017 	ldw	fp,0(sp)
 822b9ec:	dec00204 	addi	sp,sp,8
 822b9f0:	f800283a 	ret

0822b9f4 <dh_getlong>:
 *
 * RETURNS: the extracted 32 bit value
 */

static   long dh_getlong( u_char *ptr )
{
 822b9f4:	defffc04 	addi	sp,sp,-16
 822b9f8:	df000315 	stw	fp,12(sp)
 822b9fc:	df000304 	addi	fp,sp,12
 822ba00:	e13fff15 	stw	r4,-4(fp)
     long  v;
     u_char * p2 =  (u_char *)&v;
 822ba04:	e0bffe04 	addi	r2,fp,-8
 822ba08:	e0bffd15 	stw	r2,-12(fp)

   *p2++ = *ptr++;
 822ba0c:	e0bffd17 	ldw	r2,-12(fp)
 822ba10:	10c00044 	addi	r3,r2,1
 822ba14:	e0fffd15 	stw	r3,-12(fp)
 822ba18:	e0ffff17 	ldw	r3,-4(fp)
 822ba1c:	19000044 	addi	r4,r3,1
 822ba20:	e13fff15 	stw	r4,-4(fp)
 822ba24:	18c00003 	ldbu	r3,0(r3)
 822ba28:	10c00005 	stb	r3,0(r2)
   *p2++ = *ptr++;
 822ba2c:	e0bffd17 	ldw	r2,-12(fp)
 822ba30:	10c00044 	addi	r3,r2,1
 822ba34:	e0fffd15 	stw	r3,-12(fp)
 822ba38:	e0ffff17 	ldw	r3,-4(fp)
 822ba3c:	19000044 	addi	r4,r3,1
 822ba40:	e13fff15 	stw	r4,-4(fp)
 822ba44:	18c00003 	ldbu	r3,0(r3)
 822ba48:	10c00005 	stb	r3,0(r2)
   *p2++ = *ptr++;
 822ba4c:	e0bffd17 	ldw	r2,-12(fp)
 822ba50:	10c00044 	addi	r3,r2,1
 822ba54:	e0fffd15 	stw	r3,-12(fp)
 822ba58:	e0ffff17 	ldw	r3,-4(fp)
 822ba5c:	19000044 	addi	r4,r3,1
 822ba60:	e13fff15 	stw	r4,-4(fp)
 822ba64:	18c00003 	ldbu	r3,0(r3)
 822ba68:	10c00005 	stb	r3,0(r2)
   *p2++ = *ptr++;
 822ba6c:	e0bffd17 	ldw	r2,-12(fp)
 822ba70:	10c00044 	addi	r3,r2,1
 822ba74:	e0fffd15 	stw	r3,-12(fp)
 822ba78:	e0ffff17 	ldw	r3,-4(fp)
 822ba7c:	19000044 	addi	r4,r3,1
 822ba80:	e13fff15 	stw	r4,-4(fp)
 822ba84:	18c00003 	ldbu	r3,0(r3)
 822ba88:	10c00005 	stb	r3,0(r2)

   return v;
 822ba8c:	e0bffe17 	ldw	r2,-8(fp)
}
 822ba90:	e037883a 	mov	sp,fp
 822ba94:	df000017 	ldw	fp,0(sp)
 822ba98:	dec00104 	addi	sp,sp,4
 822ba9c:	f800283a 	ret

0822baa0 <dhc_extract_opts>:
 * of the options passed were filled in with good values. 
 */

int
dhc_extract_opts(int iface, u_char *opts)
{
 822baa0:	defff904 	addi	sp,sp,-28
 822baa4:	dfc00615 	stw	ra,24(sp)
 822baa8:	df000515 	stw	fp,20(sp)
 822baac:	dc000415 	stw	r16,16(sp)
 822bab0:	df000504 	addi	fp,sp,20
 822bab4:	e13ffd15 	stw	r4,-12(fp)
 822bab8:	e17ffe15 	stw	r5,-8(fp)
   u_char *end = opts + DHCP_OPTSIZE;  /* limit scope of search */
 822babc:	e0bffe17 	ldw	r2,-8(fp)
 822bac0:	10804e04 	addi	r2,r2,312
 822bac4:	e0bffb15 	stw	r2,-20(fp)
   u_char optlen;

   /* first, clear the options */
   dhc_states[iface].snmask = 0; 
 822bac8:	008209b4 	movhi	r2,2086
 822bacc:	10b84104 	addi	r2,r2,-7932
 822bad0:	e0fffd17 	ldw	r3,-12(fp)
 822bad4:	18c00f24 	muli	r3,r3,60
 822bad8:	10c5883a 	add	r2,r2,r3
 822badc:	10800a04 	addi	r2,r2,40
 822bae0:	10000015 	stw	zero,0(r2)
   dhc_states[iface].defgw = 0; 
 822bae4:	008209b4 	movhi	r2,2086
 822bae8:	10b84104 	addi	r2,r2,-7932
 822baec:	e0fffd17 	ldw	r3,-12(fp)
 822baf0:	18c00f24 	muli	r3,r3,60
 822baf4:	10c5883a 	add	r2,r2,r3
 822baf8:	10800b04 	addi	r2,r2,44
 822bafc:	10000015 	stw	zero,0(r2)
   dhc_states[iface].lease = 0; 
 822bb00:	008209b4 	movhi	r2,2086
 822bb04:	10b84104 	addi	r2,r2,-7932
 822bb08:	e0fffd17 	ldw	r3,-12(fp)
 822bb0c:	18c00f24 	muli	r3,r3,60
 822bb10:	10c5883a 	add	r2,r2,r3
 822bb14:	10800504 	addi	r2,r2,20
 822bb18:	10000015 	stw	zero,0(r2)
#if defined(DHC_MAXDNSRVS) && (DHC_MAXDNSRVS > 0)
   MEMSET(dhc_states[iface].dnsrv, 0, sizeof(dhc_states[iface].dnsrv));
#endif   /* DHC_MAXDNSRVS */

   /* then fill them in from the DHCP data */
   while (opts <= end)
 822bb1c:	00007106 	br	822bce4 <dhc_extract_opts+0x244>
   {
      switch (*opts++)
 822bb20:	e0bffe17 	ldw	r2,-8(fp)
 822bb24:	10c00044 	addi	r3,r2,1
 822bb28:	e0fffe15 	stw	r3,-8(fp)
 822bb2c:	10800003 	ldbu	r2,0(r2)
 822bb30:	10803fcc 	andi	r2,r2,255
 822bb34:	10c000e0 	cmpeqi	r3,r2,3
 822bb38:	1800201e 	bne	r3,zero,822bbbc <dhc_extract_opts+0x11c>
 822bb3c:	10c00108 	cmpgei	r3,r2,4
 822bb40:	1800041e 	bne	r3,zero,822bb54 <dhc_extract_opts+0xb4>
 822bb44:	10006726 	beq	r2,zero,822bce4 <dhc_extract_opts+0x244>
 822bb48:	10800060 	cmpeqi	r2,r2,1
 822bb4c:	10000a1e 	bne	r2,zero,822bb78 <dhc_extract_opts+0xd8>
 822bb50:	00005c06 	br	822bcc4 <dhc_extract_opts+0x224>
 822bb54:	10c00ce0 	cmpeqi	r3,r2,51
 822bb58:	18002f1e 	bne	r3,zero,822bc18 <dhc_extract_opts+0x178>
 822bb5c:	10c03fe0 	cmpeqi	r3,r2,255
 822bb60:	1800031e 	bne	r3,zero,822bb70 <dhc_extract_opts+0xd0>
 822bb64:	108001a0 	cmpeqi	r2,r2,6
 822bb68:	10004c1e 	bne	r2,zero,822bc9c <dhc_extract_opts+0x1fc>
 822bb6c:	00005506 	br	822bcc4 <dhc_extract_opts+0x224>
      {
      case DHOP_PAD:
         break;
      case DHOP_END:
         return 0;   /* only good exit point */
 822bb70:	0005883a 	mov	r2,zero
 822bb74:	00006006 	br	822bcf8 <dhc_extract_opts+0x258>
      case DHOP_SNMASK:
         opts++;
 822bb78:	e0bffe17 	ldw	r2,-8(fp)
 822bb7c:	10800044 	addi	r2,r2,1
 822bb80:	e0bffe15 	stw	r2,-8(fp)
         dhc_states[iface].snmask = dh_getlong(opts);
 822bb84:	e13ffe17 	ldw	r4,-8(fp)
 822bb88:	822b9f40 	call	822b9f4 <dh_getlong>
 822bb8c:	1009883a 	mov	r4,r2
 822bb90:	008209b4 	movhi	r2,2086
 822bb94:	10b84104 	addi	r2,r2,-7932
 822bb98:	e0fffd17 	ldw	r3,-12(fp)
 822bb9c:	18c00f24 	muli	r3,r3,60
 822bba0:	10c5883a 	add	r2,r2,r3
 822bba4:	10800a04 	addi	r2,r2,40
 822bba8:	11000015 	stw	r4,0(r2)
         opts += 4;
 822bbac:	e0bffe17 	ldw	r2,-8(fp)
 822bbb0:	10800104 	addi	r2,r2,4
 822bbb4:	e0bffe15 	stw	r2,-8(fp)
         break;
 822bbb8:	00004a06 	br	822bce4 <dhc_extract_opts+0x244>
      case DHOP_ROUTER:
         optlen = *opts++;
 822bbbc:	e0bffe17 	ldw	r2,-8(fp)
 822bbc0:	10c00044 	addi	r3,r2,1
 822bbc4:	e0fffe15 	stw	r3,-8(fp)
 822bbc8:	10800003 	ldbu	r2,0(r2)
 822bbcc:	e0bffc05 	stb	r2,-16(fp)
         if (optlen >= 4)
 822bbd0:	e0bffc03 	ldbu	r2,-16(fp)
 822bbd4:	10800130 	cmpltui	r2,r2,4
 822bbd8:	10000a1e 	bne	r2,zero,822bc04 <dhc_extract_opts+0x164>
            dhc_states[iface].defgw = dh_getlong(opts);
 822bbdc:	e13ffe17 	ldw	r4,-8(fp)
 822bbe0:	822b9f40 	call	822b9f4 <dh_getlong>
 822bbe4:	1009883a 	mov	r4,r2
 822bbe8:	008209b4 	movhi	r2,2086
 822bbec:	10b84104 	addi	r2,r2,-7932
 822bbf0:	e0fffd17 	ldw	r3,-12(fp)
 822bbf4:	18c00f24 	muli	r3,r3,60
 822bbf8:	10c5883a 	add	r2,r2,r3
 822bbfc:	10800b04 	addi	r2,r2,44
 822bc00:	11000015 	stw	r4,0(r2)
         opts += optlen;
 822bc04:	e0bffc03 	ldbu	r2,-16(fp)
 822bc08:	e0fffe17 	ldw	r3,-8(fp)
 822bc0c:	1885883a 	add	r2,r3,r2
 822bc10:	e0bffe15 	stw	r2,-8(fp)
         break;
 822bc14:	00003306 	br	822bce4 <dhc_extract_opts+0x244>
      case DHOP_LEASE:
         opts++;
 822bc18:	e0bffe17 	ldw	r2,-8(fp)
 822bc1c:	10800044 	addi	r2,r2,1
 822bc20:	e0bffe15 	stw	r2,-8(fp)
         dhc_states[iface].lease = htonl(dh_getlong(opts));
 822bc24:	e13ffe17 	ldw	r4,-8(fp)
 822bc28:	822b9f40 	call	822b9f4 <dh_getlong>
 822bc2c:	1004d63a 	srli	r2,r2,24
 822bc30:	1021883a 	mov	r16,r2
 822bc34:	e13ffe17 	ldw	r4,-8(fp)
 822bc38:	822b9f40 	call	822b9f4 <dh_getlong>
 822bc3c:	1005d23a 	srai	r2,r2,8
 822bc40:	10bfc00c 	andi	r2,r2,65280
 822bc44:	80a0b03a 	or	r16,r16,r2
 822bc48:	e13ffe17 	ldw	r4,-8(fp)
 822bc4c:	822b9f40 	call	822b9f4 <dh_getlong>
 822bc50:	10bfc00c 	andi	r2,r2,65280
 822bc54:	1004923a 	slli	r2,r2,8
 822bc58:	80a0b03a 	or	r16,r16,r2
 822bc5c:	e13ffe17 	ldw	r4,-8(fp)
 822bc60:	822b9f40 	call	822b9f4 <dh_getlong>
 822bc64:	1004963a 	slli	r2,r2,24
 822bc68:	8084b03a 	or	r2,r16,r2
 822bc6c:	1009883a 	mov	r4,r2
 822bc70:	008209b4 	movhi	r2,2086
 822bc74:	10b84104 	addi	r2,r2,-7932
 822bc78:	e0fffd17 	ldw	r3,-12(fp)
 822bc7c:	18c00f24 	muli	r3,r3,60
 822bc80:	10c5883a 	add	r2,r2,r3
 822bc84:	10800504 	addi	r2,r2,20
 822bc88:	11000015 	stw	r4,0(r2)
         opts += 4;
 822bc8c:	e0bffe17 	ldw	r2,-8(fp)
 822bc90:	10800104 	addi	r2,r2,4
 822bc94:	e0bffe15 	stw	r2,-8(fp)
         break;
 822bc98:	00001206 	br	822bce4 <dhc_extract_opts+0x244>
      case DHOP_DNSRV:
         optlen = *opts++;
 822bc9c:	e0bffe17 	ldw	r2,-8(fp)
 822bca0:	10c00044 	addi	r3,r2,1
 822bca4:	e0fffe15 	stw	r3,-8(fp)
 822bca8:	10800003 	ldbu	r2,0(r2)
 822bcac:	e0bffc05 	stb	r2,-16(fp)
               opts += 4;
               i++;
            }
         }
#endif   /* DHC_MAXDNSRVS */
         opts += optlen;
 822bcb0:	e0bffc03 	ldbu	r2,-16(fp)
 822bcb4:	e0fffe17 	ldw	r3,-8(fp)
 822bcb8:	1885883a 	add	r2,r3,r2
 822bcbc:	e0bffe15 	stw	r2,-8(fp)
         break;
 822bcc0:	00000806 	br	822bce4 <dhc_extract_opts+0x244>
      default:
         opts += ((*opts) + 1);
 822bcc4:	e0bffe17 	ldw	r2,-8(fp)
 822bcc8:	10800003 	ldbu	r2,0(r2)
 822bccc:	10803fcc 	andi	r2,r2,255
 822bcd0:	10800044 	addi	r2,r2,1
 822bcd4:	e0fffe17 	ldw	r3,-8(fp)
 822bcd8:	1885883a 	add	r2,r3,r2
 822bcdc:	e0bffe15 	stw	r2,-8(fp)
         break;
 822bce0:	0001883a 	nop
#if defined(DHC_MAXDNSRVS) && (DHC_MAXDNSRVS > 0)
   MEMSET(dhc_states[iface].dnsrv, 0, sizeof(dhc_states[iface].dnsrv));
#endif   /* DHC_MAXDNSRVS */

   /* then fill them in from the DHCP data */
   while (opts <= end)
 822bce4:	e0bffe17 	ldw	r2,-8(fp)
 822bce8:	e0fffb17 	ldw	r3,-20(fp)
 822bcec:	18bf8c2e 	bgeu	r3,r2,822bb20 <dhc_extract_opts+0x80>
      default:
         opts += ((*opts) + 1);
         break;
      }
   }
   dtrap();
 822bcf0:	822d5940 	call	822d594 <dtrap>
   return -1;
 822bcf4:	00bfffc4 	movi	r2,-1
}
 822bcf8:	e6ffff04 	addi	sp,fp,-4
 822bcfc:	dfc00217 	ldw	ra,8(sp)
 822bd00:	df000117 	ldw	fp,4(sp)
 822bd04:	dc000017 	ldw	r16,0(sp)
 822bd08:	dec00304 	addi	sp,sp,12
 822bd0c:	f800283a 	ret

0822bd10 <dhc_second>:
 * RETURNS: Returns 0 or ENP_ error code 
 */

int
dhc_second(void)
{
 822bd10:	defffa04 	addi	sp,sp,-24
 822bd14:	dfc00515 	stw	ra,20(sp)
 822bd18:	df000415 	stw	fp,16(sp)
 822bd1c:	df000404 	addi	fp,sp,16
   int   iface;
   int   tries;
   int   e;
   u_long   half_time;

   for (iface = 0; iface < MAXNETS; iface++)
 822bd20:	e03ffc15 	stw	zero,-16(fp)
 822bd24:	00014506 	br	822c23c <dhc_second+0x52c>
   {
      switch (dhc_states[iface].state)
 822bd28:	008209b4 	movhi	r2,2086
 822bd2c:	10b84104 	addi	r2,r2,-7932
 822bd30:	e0fffc17 	ldw	r3,-16(fp)
 822bd34:	18c00f24 	muli	r3,r3,60
 822bd38:	10c5883a 	add	r2,r2,r3
 822bd3c:	10800017 	ldw	r2,0(r2)
 822bd40:	10c00268 	cmpgeui	r3,r2,9
 822bd44:	1801311e 	bne	r3,zero,822c20c <dhc_second+0x4fc>
 822bd48:	100690ba 	slli	r3,r2,2
 822bd4c:	008208f4 	movhi	r2,2083
 822bd50:	10af5804 	addi	r2,r2,-17056
 822bd54:	1885883a 	add	r2,r3,r2
 822bd58:	10800017 	ldw	r2,0(r2)
 822bd5c:	1000683a 	jmp	r2
 822bd60:	0822c20c 	andi	zero,at,35592
 822bd64:	0822bd84 	addi	zero,at,-29962
 822bd68:	0822bdb4 	orhi	zero,at,35574
 822bd6c:	0822bde4 	muli	zero,at,-29961
 822bd70:	0822bde4 	muli	zero,at,-29961
 822bd74:	0822bde4 	muli	zero,at,-29961
 822bd78:	0822c024 	muli	zero,at,-29952
 822bd7c:	0822c0cc 	andi	zero,at,35587
 822bd80:	0822bf00 	call	822bf0 <OSCtxSw_SWITCH_PC+0x822bb0>
      {
      case DHCS_INIT:         /* Send a discover packet */
         e = dhc_discover(iface);
 822bd84:	e13ffc17 	ldw	r4,-16(fp)
 822bd88:	822a5580 	call	822a558 <dhc_discover>
 822bd8c:	e0bfff15 	stw	r2,-4(fp)
         /* Error while sending a discover packet */
         if (e)
 822bd90:	e0bfff17 	ldw	r2,-4(fp)
 822bd94:	10000326 	beq	r2,zero,822bda4 <dhc_second+0x94>
         {
            dtrap();
 822bd98:	822d5940 	call	822d594 <dtrap>
            return e;
 822bd9c:	e0bfff17 	ldw	r2,-4(fp)
 822bda0:	00012a06 	br	822c24c <dhc_second+0x53c>
         }
         dhc_set_state(iface,DHCS_SELECTING);
 822bda4:	01400104 	movi	r5,4
 822bda8:	e13ffc17 	ldw	r4,-16(fp)
 822bdac:	822c5e00 	call	822c5e0 <dhc_set_state>
         break;
 822bdb0:	00011f06 	br	822c230 <dhc_second+0x520>
      case DHCS_INITREBOOT:   /* Send a request packet */
         e = dhc_reclaim(iface);
 822bdb4:	e13ffc17 	ldw	r4,-16(fp)
 822bdb8:	822c2e00 	call	822c2e0 <dhc_reclaim>
 822bdbc:	e0bfff15 	stw	r2,-4(fp)
         if (e)
 822bdc0:	e0bfff17 	ldw	r2,-4(fp)
 822bdc4:	10000326 	beq	r2,zero,822bdd4 <dhc_second+0xc4>
         {
            dtrap();
 822bdc8:	822d5940 	call	822d594 <dtrap>
            return e;
 822bdcc:	e0bfff17 	ldw	r2,-4(fp)
 822bdd0:	00011e06 	br	822c24c <dhc_second+0x53c>
         }
         dhc_set_state(iface,DHCS_REBOOTING);
 822bdd4:	014000c4 	movi	r5,3
 822bdd8:	e13ffc17 	ldw	r4,-16(fp)
 822bddc:	822c5e00 	call	822c5e0 <dhc_set_state>
         break;
 822bde0:	00011306 	br	822c230 <dhc_second+0x520>
         /* Send discover packet on timeout */
      case DHCS_REBOOTING:
      case DHCS_REQUESTING:
         /* Discovery timeout = DHC_RETRY_TMO secs * (2 ** retries), max 64 */

         tries = dhc_states[iface].tries ;
 822bde4:	008209b4 	movhi	r2,2086
 822bde8:	10b84104 	addi	r2,r2,-7932
 822bdec:	e0fffc17 	ldw	r3,-16(fp)
 822bdf0:	18c00f24 	muli	r3,r3,60
 822bdf4:	10c5883a 	add	r2,r2,r3
 822bdf8:	10800104 	addi	r2,r2,4
 822bdfc:	10800017 	ldw	r2,0(r2)
 822be00:	e0bffd15 	stw	r2,-12(fp)

         /* Set the exponential count */
         if ( tries >= DHC_MAX_TRIES) 
 822be04:	e0bffd17 	ldw	r2,-12(fp)
 822be08:	10800110 	cmplti	r2,r2,4
 822be0c:	1000021e 	bne	r2,zero,822be18 <dhc_second+0x108>
            tries= DHC_MAX_TRIES;
 822be10:	00800104 	movi	r2,4
 822be14:	e0bffd15 	stw	r2,-12(fp)
         if ( cticks > (dhc_states[iface].last_tick + 
 822be18:	008209b4 	movhi	r2,2086
 822be1c:	10b84104 	addi	r2,r2,-7932
 822be20:	e0fffc17 	ldw	r3,-16(fp)
 822be24:	18c00f24 	muli	r3,r3,60
 822be28:	10c5883a 	add	r2,r2,r3
 822be2c:	10800404 	addi	r2,r2,16
 822be30:	10c00017 	ldw	r3,0(r2)
             (((u_long) (DHC_RETRY_TMO*TPS)) << tries ) ) )
 822be34:	01006404 	movi	r4,400
 822be38:	e0bffd17 	ldw	r2,-12(fp)
 822be3c:	2084983a 	sll	r2,r4,r2
         tries = dhc_states[iface].tries ;

         /* Set the exponential count */
         if ( tries >= DHC_MAX_TRIES) 
            tries= DHC_MAX_TRIES;
         if ( cticks > (dhc_states[iface].last_tick + 
 822be40:	1887883a 	add	r3,r3,r2
 822be44:	d0a0a817 	ldw	r2,-32096(gp)
 822be48:	1880192e 	bgeu	r3,r2,822beb0 <dhc_second+0x1a0>
             (((u_long) (DHC_RETRY_TMO*TPS)) << tries ) ) )
         {
            /* Timeout while waiting for a OFFER/ACK/NAK. Retransmit */
            switch(dhc_states[iface].state)
 822be4c:	008209b4 	movhi	r2,2086
 822be50:	10b84104 	addi	r2,r2,-7932
 822be54:	e0fffc17 	ldw	r3,-16(fp)
 822be58:	18c00f24 	muli	r3,r3,60
 822be5c:	10c5883a 	add	r2,r2,r3
 822be60:	10800017 	ldw	r2,0(r2)
 822be64:	10c00120 	cmpeqi	r3,r2,4
 822be68:	1800051e 	bne	r3,zero,822be80 <dhc_second+0x170>
 822be6c:	10c00160 	cmpeqi	r3,r2,5
 822be70:	1800061e 	bne	r3,zero,822be8c <dhc_second+0x17c>
 822be74:	108000e0 	cmpeqi	r2,r2,3
 822be78:	1000081e 	bne	r2,zero,822be9c <dhc_second+0x18c>
 822be7c:	00000a06 	br	822bea8 <dhc_second+0x198>
            {
            case DHCS_SELECTING:
               dhc_discover(iface);
 822be80:	e13ffc17 	ldw	r4,-16(fp)
 822be84:	822a5580 	call	822a558 <dhc_discover>
               break;
 822be88:	00000906 	br	822beb0 <dhc_second+0x1a0>
            case DHCS_REQUESTING:
               dhc_request(iface,FALSE);
 822be8c:	000b883a 	mov	r5,zero
 822be90:	e13ffc17 	ldw	r4,-16(fp)
 822be94:	822ab080 	call	822ab08 <dhc_request>
               break;
 822be98:	00000506 	br	822beb0 <dhc_second+0x1a0>
            case DHCS_REBOOTING:
               dhc_reclaim(iface);
 822be9c:	e13ffc17 	ldw	r4,-16(fp)
 822bea0:	822c2e00 	call	822c2e0 <dhc_reclaim>
               break;
 822bea4:	00000206 	br	822beb0 <dhc_second+0x1a0>
            default:
               dtrap(); /* bogus state */
 822bea8:	822d5940 	call	822d594 <dtrap>
               break;
 822beac:	0001883a 	nop
            }
         }
         if ( tries == DHC_MAX_TRIES && 
 822beb0:	e0bffd17 	ldw	r2,-12(fp)
 822beb4:	10800118 	cmpnei	r2,r2,4
 822beb8:	1000d61e 	bne	r2,zero,822c214 <dhc_second+0x504>
             (dhc_states[iface].state !=DHCS_SELECTING) )
 822bebc:	008209b4 	movhi	r2,2086
 822bec0:	10b84104 	addi	r2,r2,-7932
 822bec4:	e0fffc17 	ldw	r3,-16(fp)
 822bec8:	18c00f24 	muli	r3,r3,60
 822becc:	10c5883a 	add	r2,r2,r3
 822bed0:	10800017 	ldw	r2,0(r2)
            default:
               dtrap(); /* bogus state */
               break;
            }
         }
         if ( tries == DHC_MAX_TRIES && 
 822bed4:	10800120 	cmpeqi	r2,r2,4
 822bed8:	1000ce1e 	bne	r2,zero,822c214 <dhc_second+0x504>
             (dhc_states[iface].state !=DHCS_SELECTING) )
         {
            /* We have tried enough. Restart from INIT state */
            dhc_set_state(iface,DHCS_RESTARTING);
 822bedc:	01400244 	movi	r5,9
 822bee0:	e13ffc17 	ldw	r4,-16(fp)
 822bee4:	822c5e00 	call	822c5e0 <dhc_set_state>
            dhc_resetip(iface);
 822bee8:	e13ffc17 	ldw	r4,-16(fp)
 822beec:	822b8080 	call	822b808 <dhc_resetip>
            dhc_set_state(iface,DHCS_INIT);
 822bef0:	01400044 	movi	r5,1
 822bef4:	e13ffc17 	ldw	r4,-16(fp)
 822bef8:	822c5e00 	call	822c5e0 <dhc_set_state>
         }
         break;
 822befc:	0000c506 	br	822c214 <dhc_second+0x504>
      case DHCS_REBINDING:
         /* Check for timeout. Retry if we didn't get a ACK/NAK response. */

         if ( (dhc_states[iface].lease*TPS+dhc_states[iface].lease_start) > cticks )
 822bf00:	008209b4 	movhi	r2,2086
 822bf04:	10b84104 	addi	r2,r2,-7932
 822bf08:	e0fffc17 	ldw	r3,-16(fp)
 822bf0c:	18c00f24 	muli	r3,r3,60
 822bf10:	10c5883a 	add	r2,r2,r3
 822bf14:	10800504 	addi	r2,r2,20
 822bf18:	10800017 	ldw	r2,0(r2)
 822bf1c:	10c01924 	muli	r3,r2,100
 822bf20:	008209b4 	movhi	r2,2086
 822bf24:	10b84104 	addi	r2,r2,-7932
 822bf28:	e13ffc17 	ldw	r4,-16(fp)
 822bf2c:	21000f24 	muli	r4,r4,60
 822bf30:	1105883a 	add	r2,r2,r4
 822bf34:	10800804 	addi	r2,r2,32
 822bf38:	10800017 	ldw	r2,0(r2)
 822bf3c:	1885883a 	add	r2,r3,r2
 822bf40:	d0e0a817 	ldw	r3,-32096(gp)
 822bf44:	18802e2e 	bgeu	r3,r2,822c000 <dhc_second+0x2f0>
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
 822bf48:	008209b4 	movhi	r2,2086
 822bf4c:	10b84104 	addi	r2,r2,-7932
 822bf50:	e0fffc17 	ldw	r3,-16(fp)
 822bf54:	18c00f24 	muli	r3,r3,60
 822bf58:	10c5883a 	add	r2,r2,r3
 822bf5c:	10800804 	addi	r2,r2,32
 822bf60:	10c00017 	ldw	r3,0(r2)
             dhc_states[iface].lease*TPS - 
 822bf64:	008209b4 	movhi	r2,2086
 822bf68:	10b84104 	addi	r2,r2,-7932
 822bf6c:	e13ffc17 	ldw	r4,-16(fp)
 822bf70:	21000f24 	muli	r4,r4,60
 822bf74:	1105883a 	add	r2,r2,r4
 822bf78:	10800504 	addi	r2,r2,20
 822bf7c:	10800017 	ldw	r2,0(r2)
 822bf80:	10801924 	muli	r2,r2,100
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
 822bf84:	1887883a 	add	r3,r3,r2
             dhc_states[iface].lease*TPS - 
             dhc_states[iface].last_tick)/2;
 822bf88:	008209b4 	movhi	r2,2086
 822bf8c:	10b84104 	addi	r2,r2,-7932
 822bf90:	e13ffc17 	ldw	r4,-16(fp)
 822bf94:	21000f24 	muli	r4,r4,60
 822bf98:	1105883a 	add	r2,r2,r4
 822bf9c:	10800404 	addi	r2,r2,16
 822bfa0:	10800017 	ldw	r2,0(r2)
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
             dhc_states[iface].lease*TPS - 
 822bfa4:	1885c83a 	sub	r2,r3,r2
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
 822bfa8:	1004d07a 	srli	r2,r2,1
 822bfac:	e0bffe15 	stw	r2,-8(fp)
             dhc_states[iface].lease*TPS - 
             dhc_states[iface].last_tick)/2;

            if ( half_time < 60*TPS )
 822bfb0:	e0bffe17 	ldw	r2,-8(fp)
 822bfb4:	1085dc28 	cmpgeui	r2,r2,6000
 822bfb8:	1000021e 	bne	r2,zero,822bfc4 <dhc_second+0x2b4>
               half_time = 60*TPS;
 822bfbc:	0085dc04 	movi	r2,6000
 822bfc0:	e0bffe15 	stw	r2,-8(fp)
            if ( dhc_states[iface].last_tick + half_time < cticks )
 822bfc4:	008209b4 	movhi	r2,2086
 822bfc8:	10b84104 	addi	r2,r2,-7932
 822bfcc:	e0fffc17 	ldw	r3,-16(fp)
 822bfd0:	18c00f24 	muli	r3,r3,60
 822bfd4:	10c5883a 	add	r2,r2,r3
 822bfd8:	10800404 	addi	r2,r2,16
 822bfdc:	10c00017 	ldw	r3,0(r2)
 822bfe0:	e0bffe17 	ldw	r2,-8(fp)
 822bfe4:	1887883a 	add	r3,r3,r2
 822bfe8:	d0a0a817 	ldw	r2,-32096(gp)
 822bfec:	18808b2e 	bgeu	r3,r2,822c21c <dhc_second+0x50c>
            {
               dhc_request(iface,FALSE);
 822bff0:	000b883a 	mov	r5,zero
 822bff4:	e13ffc17 	ldw	r4,-16(fp)
 822bff8:	822ab080 	call	822ab08 <dhc_request>
            /* Lease has expired. We didn't receive a ACK/NAK. Hence restart*/
            dhc_set_state(iface,DHCS_RESTARTING);
            dhc_resetip(iface);
            dhc_set_state(iface,DHCS_INIT);
         }
         break;
 822bffc:	00008706 	br	822c21c <dhc_second+0x50c>
            }
         }
         else
         {
            /* Lease has expired. We didn't receive a ACK/NAK. Hence restart*/
            dhc_set_state(iface,DHCS_RESTARTING);
 822c000:	01400244 	movi	r5,9
 822c004:	e13ffc17 	ldw	r4,-16(fp)
 822c008:	822c5e00 	call	822c5e0 <dhc_set_state>
            dhc_resetip(iface);
 822c00c:	e13ffc17 	ldw	r4,-16(fp)
 822c010:	822b8080 	call	822b808 <dhc_resetip>
            dhc_set_state(iface,DHCS_INIT);
 822c014:	01400044 	movi	r5,1
 822c018:	e13ffc17 	ldw	r4,-16(fp)
 822c01c:	822c5e00 	call	822c5e0 <dhc_set_state>
         }
         break;
 822c020:	00007e06 	br	822c21c <dhc_second+0x50c>

      case DHCS_BOUND:
         /* Test for lease expiry. The RENEW timer. */
         if ( (dhc_states[iface].t1 != DHC_INFINITY) &&
 822c024:	008209b4 	movhi	r2,2086
 822c028:	10b84104 	addi	r2,r2,-7932
 822c02c:	e0fffc17 	ldw	r3,-16(fp)
 822c030:	18c00f24 	muli	r3,r3,60
 822c034:	10c5883a 	add	r2,r2,r3
 822c038:	10800604 	addi	r2,r2,24
 822c03c:	10800017 	ldw	r2,0(r2)
 822c040:	10bfffe0 	cmpeqi	r2,r2,-1
 822c044:	1000771e 	bne	r2,zero,822c224 <dhc_second+0x514>
             (((dhc_states[iface].t1*TPS)+dhc_states[iface].lease_start) < cticks ) )
 822c048:	008209b4 	movhi	r2,2086
 822c04c:	10b84104 	addi	r2,r2,-7932
 822c050:	e0fffc17 	ldw	r3,-16(fp)
 822c054:	18c00f24 	muli	r3,r3,60
 822c058:	10c5883a 	add	r2,r2,r3
 822c05c:	10800604 	addi	r2,r2,24
 822c060:	10800017 	ldw	r2,0(r2)
 822c064:	10c01924 	muli	r3,r2,100
 822c068:	008209b4 	movhi	r2,2086
 822c06c:	10b84104 	addi	r2,r2,-7932
 822c070:	e13ffc17 	ldw	r4,-16(fp)
 822c074:	21000f24 	muli	r4,r4,60
 822c078:	1105883a 	add	r2,r2,r4
 822c07c:	10800804 	addi	r2,r2,32
 822c080:	10800017 	ldw	r2,0(r2)
 822c084:	1887883a 	add	r3,r3,r2
 822c088:	d0a0a817 	ldw	r2,-32096(gp)
         }
         break;

      case DHCS_BOUND:
         /* Test for lease expiry. The RENEW timer. */
         if ( (dhc_states[iface].t1 != DHC_INFINITY) &&
 822c08c:	1880652e 	bgeu	r3,r2,822c224 <dhc_second+0x514>
             (((dhc_states[iface].t1*TPS)+dhc_states[iface].lease_start) < cticks ) )
         {
            /* Time to renew. Send a UNICAST to the DHCP server */
            dhc_set_state(iface,DHCS_RENEWING);
 822c090:	014001c4 	movi	r5,7
 822c094:	e13ffc17 	ldw	r4,-16(fp)
 822c098:	822c5e00 	call	822c5e0 <dhc_set_state>
            e = dhc_reclaim(iface); /* unicast */ 
 822c09c:	e13ffc17 	ldw	r4,-16(fp)
 822c0a0:	822c2e00 	call	822c2e0 <dhc_reclaim>
 822c0a4:	e0bfff15 	stw	r2,-4(fp)
            if (e)
 822c0a8:	e0bfff17 	ldw	r2,-4(fp)
 822c0ac:	10000326 	beq	r2,zero,822c0bc <dhc_second+0x3ac>
            {
               dtrap();
 822c0b0:	822d5940 	call	822d594 <dtrap>
               return e;
 822c0b4:	e0bfff17 	ldw	r2,-4(fp)
 822c0b8:	00006406 	br	822c24c <dhc_second+0x53c>
            }
            dsc_renew++;
 822c0bc:	d0a09917 	ldw	r2,-32156(gp)
 822c0c0:	10800044 	addi	r2,r2,1
 822c0c4:	d0a09915 	stw	r2,-32156(gp)
         }
         break;
 822c0c8:	00005606 	br	822c224 <dhc_second+0x514>
      case DHCS_RENEWING:
         /* Test for lease expiry. The REBIND timer. */
         if ( (dhc_states[iface].t2*TPS+dhc_states[iface].lease_start) > cticks )
 822c0cc:	008209b4 	movhi	r2,2086
 822c0d0:	10b84104 	addi	r2,r2,-7932
 822c0d4:	e0fffc17 	ldw	r3,-16(fp)
 822c0d8:	18c00f24 	muli	r3,r3,60
 822c0dc:	10c5883a 	add	r2,r2,r3
 822c0e0:	10800704 	addi	r2,r2,28
 822c0e4:	10800017 	ldw	r2,0(r2)
 822c0e8:	10c01924 	muli	r3,r2,100
 822c0ec:	008209b4 	movhi	r2,2086
 822c0f0:	10b84104 	addi	r2,r2,-7932
 822c0f4:	e13ffc17 	ldw	r4,-16(fp)
 822c0f8:	21000f24 	muli	r4,r4,60
 822c0fc:	1105883a 	add	r2,r2,r4
 822c100:	10800804 	addi	r2,r2,32
 822c104:	10800017 	ldw	r2,0(r2)
 822c108:	1885883a 	add	r2,r3,r2
 822c10c:	d0e0a817 	ldw	r3,-32096(gp)
 822c110:	18802e2e 	bgeu	r3,r2,822c1cc <dhc_second+0x4bc>
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
 822c114:	008209b4 	movhi	r2,2086
 822c118:	10b84104 	addi	r2,r2,-7932
 822c11c:	e0fffc17 	ldw	r3,-16(fp)
 822c120:	18c00f24 	muli	r3,r3,60
 822c124:	10c5883a 	add	r2,r2,r3
 822c128:	10800804 	addi	r2,r2,32
 822c12c:	10c00017 	ldw	r3,0(r2)
             dhc_states[iface].t2*TPS - 
 822c130:	008209b4 	movhi	r2,2086
 822c134:	10b84104 	addi	r2,r2,-7932
 822c138:	e13ffc17 	ldw	r4,-16(fp)
 822c13c:	21000f24 	muli	r4,r4,60
 822c140:	1105883a 	add	r2,r2,r4
 822c144:	10800704 	addi	r2,r2,28
 822c148:	10800017 	ldw	r2,0(r2)
 822c14c:	10801924 	muli	r2,r2,100
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
 822c150:	1887883a 	add	r3,r3,r2
             dhc_states[iface].t2*TPS - 
             dhc_states[iface].last_tick)/2;
 822c154:	008209b4 	movhi	r2,2086
 822c158:	10b84104 	addi	r2,r2,-7932
 822c15c:	e13ffc17 	ldw	r4,-16(fp)
 822c160:	21000f24 	muli	r4,r4,60
 822c164:	1105883a 	add	r2,r2,r4
 822c168:	10800404 	addi	r2,r2,16
 822c16c:	10800017 	ldw	r2,0(r2)
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
             dhc_states[iface].t2*TPS - 
 822c170:	1885c83a 	sub	r2,r3,r2
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
 822c174:	1004d07a 	srli	r2,r2,1
 822c178:	e0bffe15 	stw	r2,-8(fp)
             dhc_states[iface].t2*TPS - 
             dhc_states[iface].last_tick)/2;

            if ( half_time < 60*TPS )
 822c17c:	e0bffe17 	ldw	r2,-8(fp)
 822c180:	1085dc28 	cmpgeui	r2,r2,6000
 822c184:	1000021e 	bne	r2,zero,822c190 <dhc_second+0x480>
               half_time = 60*TPS;
 822c188:	0085dc04 	movi	r2,6000
 822c18c:	e0bffe15 	stw	r2,-8(fp)
            if ( dhc_states[iface].last_tick + half_time < cticks )
 822c190:	008209b4 	movhi	r2,2086
 822c194:	10b84104 	addi	r2,r2,-7932
 822c198:	e0fffc17 	ldw	r3,-16(fp)
 822c19c:	18c00f24 	muli	r3,r3,60
 822c1a0:	10c5883a 	add	r2,r2,r3
 822c1a4:	10800404 	addi	r2,r2,16
 822c1a8:	10c00017 	ldw	r3,0(r2)
 822c1ac:	e0bffe17 	ldw	r2,-8(fp)
 822c1b0:	1887883a 	add	r3,r3,r2
 822c1b4:	d0a0a817 	ldw	r2,-32096(gp)
 822c1b8:	18801c2e 	bgeu	r3,r2,822c22c <dhc_second+0x51c>
            {
               dhc_request(iface,FALSE);
 822c1bc:	000b883a 	mov	r5,zero
 822c1c0:	e13ffc17 	ldw	r4,-16(fp)
 822c1c4:	822ab080 	call	822ab08 <dhc_request>
               dtrap();
               return e;
            }
            dsc_rebind++;
         }
         break;
 822c1c8:	00001806 	br	822c22c <dhc_second+0x51c>
         {
            /* No Response has come from the Server that assigned our 
             * IP. Hence send a broadcast packet to see if we can 
             * lease this IP from some other server 
             */
            dhc_set_state(iface,DHCS_REBINDING);
 822c1cc:	01400204 	movi	r5,8
 822c1d0:	e13ffc17 	ldw	r4,-16(fp)
 822c1d4:	822c5e00 	call	822c5e0 <dhc_set_state>
            e = dhc_request(iface,TRUE);  /* broadcast */
 822c1d8:	01400044 	movi	r5,1
 822c1dc:	e13ffc17 	ldw	r4,-16(fp)
 822c1e0:	822ab080 	call	822ab08 <dhc_request>
 822c1e4:	e0bfff15 	stw	r2,-4(fp)
            if (e)
 822c1e8:	e0bfff17 	ldw	r2,-4(fp)
 822c1ec:	10000326 	beq	r2,zero,822c1fc <dhc_second+0x4ec>
            {
               dtrap();
 822c1f0:	822d5940 	call	822d594 <dtrap>
               return e;
 822c1f4:	e0bfff17 	ldw	r2,-4(fp)
 822c1f8:	00001406 	br	822c24c <dhc_second+0x53c>
            }
            dsc_rebind++;
 822c1fc:	d0a09a17 	ldw	r2,-32152(gp)
 822c200:	10800044 	addi	r2,r2,1
 822c204:	d0a09a15 	stw	r2,-32152(gp)
         }
         break;
 822c208:	00000806 	br	822c22c <dhc_second+0x51c>
      case DHCS_UNUSED:
      default:
         continue;
 822c20c:	0001883a 	nop
 822c210:	00000706 	br	822c230 <dhc_second+0x520>
            /* We have tried enough. Restart from INIT state */
            dhc_set_state(iface,DHCS_RESTARTING);
            dhc_resetip(iface);
            dhc_set_state(iface,DHCS_INIT);
         }
         break;
 822c214:	0001883a 	nop
 822c218:	00000506 	br	822c230 <dhc_second+0x520>
            /* Lease has expired. We didn't receive a ACK/NAK. Hence restart*/
            dhc_set_state(iface,DHCS_RESTARTING);
            dhc_resetip(iface);
            dhc_set_state(iface,DHCS_INIT);
         }
         break;
 822c21c:	0001883a 	nop
 822c220:	00000306 	br	822c230 <dhc_second+0x520>
               dtrap();
               return e;
            }
            dsc_renew++;
         }
         break;
 822c224:	0001883a 	nop
 822c228:	00000106 	br	822c230 <dhc_second+0x520>
               dtrap();
               return e;
            }
            dsc_rebind++;
         }
         break;
 822c22c:	0001883a 	nop
   int   iface;
   int   tries;
   int   e;
   u_long   half_time;

   for (iface = 0; iface < MAXNETS; iface++)
 822c230:	e0bffc17 	ldw	r2,-16(fp)
 822c234:	10800044 	addi	r2,r2,1
 822c238:	e0bffc15 	stw	r2,-16(fp)
 822c23c:	e0bffc17 	ldw	r2,-16(fp)
 822c240:	10800110 	cmplti	r2,r2,4
 822c244:	103eb81e 	bne	r2,zero,822bd28 <dhc_second+0x18>
      case DHCS_UNUSED:
      default:
         continue;
      }
   }
   return 0;
 822c248:	0005883a 	mov	r2,zero
}
 822c24c:	e037883a 	mov	sp,fp
 822c250:	dfc00117 	ldw	ra,4(sp)
 822c254:	df000017 	ldw	fp,0(sp)
 822c258:	dec00204 	addi	sp,sp,8
 822c25c:	f800283a 	ret

0822c260 <dhc_halt>:
 * RETURNS: void
 */

void
dhc_halt(int iface)
{
 822c260:	defffd04 	addi	sp,sp,-12
 822c264:	dfc00215 	stw	ra,8(sp)
 822c268:	df000115 	stw	fp,4(sp)
 822c26c:	df000104 	addi	fp,sp,4
 822c270:	e13fff15 	stw	r4,-4(fp)
   if (iface < 0 || iface > MAXNETS)
 822c274:	e0bfff17 	ldw	r2,-4(fp)
 822c278:	10000316 	blt	r2,zero,822c288 <dhc_halt+0x28>
 822c27c:	e0bfff17 	ldw	r2,-4(fp)
 822c280:	10800150 	cmplti	r2,r2,5
 822c284:	1000021e 	bne	r2,zero,822c290 <dhc_halt+0x30>
   {
      dtrap();
 822c288:	822d5940 	call	822d594 <dtrap>
      return;
 822c28c:	00000f06 	br	822c2cc <dhc_halt+0x6c>
   }
   /* clear dhc_states entry - (kills retrys) */
   MEMSET(&dhc_states[iface], 0, sizeof(struct dhc_state));
 822c290:	e0bfff17 	ldw	r2,-4(fp)
 822c294:	10c00f24 	muli	r3,r2,60
 822c298:	008209b4 	movhi	r2,2086
 822c29c:	10b84104 	addi	r2,r2,-7932
 822c2a0:	1885883a 	add	r2,r3,r2
 822c2a4:	01800f04 	movi	r6,60
 822c2a8:	000b883a 	mov	r5,zero
 822c2ac:	1009883a 	mov	r4,r2
 822c2b0:	82031b40 	call	82031b4 <memset>
   dhc_states[iface].state = DHCS_UNUSED;
 822c2b4:	008209b4 	movhi	r2,2086
 822c2b8:	10b84104 	addi	r2,r2,-7932
 822c2bc:	e0ffff17 	ldw	r3,-4(fp)
 822c2c0:	18c00f24 	muli	r3,r3,60
 822c2c4:	10c5883a 	add	r2,r2,r3
 822c2c8:	10000015 	stw	zero,0(r2)
}
 822c2cc:	e037883a 	mov	sp,fp
 822c2d0:	dfc00117 	ldw	ra,4(sp)
 822c2d4:	df000017 	ldw	fp,0(sp)
 822c2d8:	dec00204 	addi	sp,sp,8
 822c2dc:	f800283a 	ret

0822c2e0 <dhc_reclaim>:
 * RETURNS: Returns 0 if DHCP request was sent OK, else non-zero error. 
 */

int   
dhc_reclaim(int iface)
{
 822c2e0:	defffc04 	addi	sp,sp,-16
 822c2e4:	dfc00315 	stw	ra,12(sp)
 822c2e8:	df000215 	stw	fp,8(sp)
 822c2ec:	df000204 	addi	fp,sp,8
 822c2f0:	e13fff15 	stw	r4,-4(fp)
   /* punt if IP address is not set */
   if (nets[iface]->n_ipaddr == 0L)
 822c2f4:	008209b4 	movhi	r2,2086
 822c2f8:	10b81b04 	addi	r2,r2,-8084
 822c2fc:	e0ffff17 	ldw	r3,-4(fp)
 822c300:	18c7883a 	add	r3,r3,r3
 822c304:	18c7883a 	add	r3,r3,r3
 822c308:	10c5883a 	add	r2,r2,r3
 822c30c:	10800017 	ldw	r2,0(r2)
 822c310:	10800a17 	ldw	r2,40(r2)
 822c314:	1000031e 	bne	r2,zero,822c324 <dhc_reclaim+0x44>
   {
      dtrap();    /* programming bug? */
 822c318:	822d5940 	call	822d594 <dtrap>
      return ENP_LOGIC;
 822c31c:	00bffd44 	movi	r2,-11
 822c320:	00005806 	br	822c484 <dhc_reclaim+0x1a4>
   }

   dhc_states[iface].ipaddr = nets[iface]->n_ipaddr;
 822c324:	008209b4 	movhi	r2,2086
 822c328:	10b81b04 	addi	r2,r2,-8084
 822c32c:	e0ffff17 	ldw	r3,-4(fp)
 822c330:	18c7883a 	add	r3,r3,r3
 822c334:	18c7883a 	add	r3,r3,r3
 822c338:	10c5883a 	add	r2,r2,r3
 822c33c:	10800017 	ldw	r2,0(r2)
 822c340:	10c00a17 	ldw	r3,40(r2)
 822c344:	008209b4 	movhi	r2,2086
 822c348:	10b84104 	addi	r2,r2,-7932
 822c34c:	e13fff17 	ldw	r4,-4(fp)
 822c350:	21000f24 	muli	r4,r4,60
 822c354:	1105883a 	add	r2,r2,r4
 822c358:	10800904 	addi	r2,r2,36
 822c35c:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].snmask = nets[iface]->snmask;
 822c360:	008209b4 	movhi	r2,2086
 822c364:	10b81b04 	addi	r2,r2,-8084
 822c368:	e0ffff17 	ldw	r3,-4(fp)
 822c36c:	18c7883a 	add	r3,r3,r3
 822c370:	18c7883a 	add	r3,r3,r3
 822c374:	10c5883a 	add	r2,r2,r3
 822c378:	10800017 	ldw	r2,0(r2)
 822c37c:	10c00c17 	ldw	r3,48(r2)
 822c380:	008209b4 	movhi	r2,2086
 822c384:	10b84104 	addi	r2,r2,-7932
 822c388:	e13fff17 	ldw	r4,-4(fp)
 822c38c:	21000f24 	muli	r4,r4,60
 822c390:	1105883a 	add	r2,r2,r4
 822c394:	10800a04 	addi	r2,r2,40
 822c398:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].defgw  = nets[iface]->n_defgw;
 822c39c:	008209b4 	movhi	r2,2086
 822c3a0:	10b81b04 	addi	r2,r2,-8084
 822c3a4:	e0ffff17 	ldw	r3,-4(fp)
 822c3a8:	18c7883a 	add	r3,r3,r3
 822c3ac:	18c7883a 	add	r3,r3,r3
 822c3b0:	10c5883a 	add	r2,r2,r3
 822c3b4:	10800017 	ldw	r2,0(r2)
 822c3b8:	10c00d17 	ldw	r3,52(r2)
 822c3bc:	008209b4 	movhi	r2,2086
 822c3c0:	10b84104 	addi	r2,r2,-7932
 822c3c4:	e13fff17 	ldw	r4,-4(fp)
 822c3c8:	21000f24 	muli	r4,r4,60
 822c3cc:	1105883a 	add	r2,r2,r4
 822c3d0:	10800b04 	addi	r2,r2,44
 822c3d4:	10c00015 	stw	r3,0(r2)

#ifdef IP_ROUTING
   /* If the DHCP Server is on other network, route the request
    * from the same DHCP relay agent. To do that, add a route.
    */
   if (dhc_states[iface].rly_ipaddr)
 822c3d8:	008209b4 	movhi	r2,2086
 822c3dc:	10b84104 	addi	r2,r2,-7932
 822c3e0:	e0ffff17 	ldw	r3,-4(fp)
 822c3e4:	18c00f24 	muli	r3,r3,60
 822c3e8:	10c5883a 	add	r2,r2,r3
 822c3ec:	10800c04 	addi	r2,r2,48
 822c3f0:	10800017 	ldw	r2,0(r2)
 822c3f4:	10002026 	beq	r2,zero,822c478 <dhc_reclaim+0x198>
   {
      if (dhc_states[iface].srv_ipaddr)
 822c3f8:	008209b4 	movhi	r2,2086
 822c3fc:	10b84104 	addi	r2,r2,-7932
 822c400:	e0ffff17 	ldw	r3,-4(fp)
 822c404:	18c00f24 	muli	r3,r3,60
 822c408:	10c5883a 	add	r2,r2,r3
 822c40c:	10800d04 	addi	r2,r2,52
 822c410:	10800017 	ldw	r2,0(r2)
 822c414:	10001726 	beq	r2,zero,822c474 <dhc_reclaim+0x194>
      {
         /* yes, earlier negotiation was done via a relay agent */
         if ( !add_route(dhc_states[iface].srv_ipaddr, 0xFFFFFFFF,
 822c418:	008209b4 	movhi	r2,2086
 822c41c:	10b84104 	addi	r2,r2,-7932
 822c420:	e0ffff17 	ldw	r3,-4(fp)
 822c424:	18c00f24 	muli	r3,r3,60
 822c428:	10c5883a 	add	r2,r2,r3
 822c42c:	10800d04 	addi	r2,r2,52
 822c430:	11000017 	ldw	r4,0(r2)
 822c434:	008209b4 	movhi	r2,2086
 822c438:	10b84104 	addi	r2,r2,-7932
 822c43c:	e0ffff17 	ldw	r3,-4(fp)
 822c440:	18c00f24 	muli	r3,r3,60
 822c444:	10c5883a 	add	r2,r2,r3
 822c448:	10800c04 	addi	r2,r2,48
 822c44c:	10c00017 	ldw	r3,0(r2)
 822c450:	00800084 	movi	r2,2
 822c454:	d8800015 	stw	r2,0(sp)
 822c458:	e1ffff17 	ldw	r7,-4(fp)
 822c45c:	180d883a 	mov	r6,r3
 822c460:	017fffc4 	movi	r5,-1
 822c464:	82443300 	call	8244330 <add_route>
 822c468:	1000031e 	bne	r2,zero,822c478 <dhc_reclaim+0x198>
             dhc_states[iface].rly_ipaddr, iface, IPRP_LOCAL))
         {
            /* route was not added. check this case */
            dtrap(); 
 822c46c:	822d5940 	call	822d594 <dtrap>
 822c470:	00000106 	br	822c478 <dhc_reclaim+0x198>
      else
      {
         /* DHCP relay IP address is set, but DHCP Server IP address is
          * not set ! How can this happen ?
          */
         dtrap();
 822c474:	822d5940 	call	822d594 <dtrap>
      }
   }
#endif  /* IP_ROUTING */

   /* send the request */
   return(dhc_request(iface,TRUE));  
 822c478:	01400044 	movi	r5,1
 822c47c:	e13fff17 	ldw	r4,-4(fp)
 822c480:	822ab080 	call	822ab08 <dhc_request>
}
 822c484:	e037883a 	mov	sp,fp
 822c488:	dfc00117 	ldw	ra,4(sp)
 822c48c:	df000017 	ldw	fp,0(sp)
 822c490:	dec00204 	addi	sp,sp,8
 822c494:	f800283a 	ret

0822c498 <dhc_state_init>:
 * RETURNS: void
 */

void 
dhc_state_init(int iface, int init_flag)
{
 822c498:	defffb04 	addi	sp,sp,-20
 822c49c:	dfc00415 	stw	ra,16(sp)
 822c4a0:	df000315 	stw	fp,12(sp)
 822c4a4:	df000304 	addi	fp,sp,12
 822c4a8:	e13ffe15 	stw	r4,-8(fp)
 822c4ac:	e17fff15 	stw	r5,-4(fp)
   int state = (init_flag == TRUE) ? DHCS_INIT : DHCS_INITREBOOT;
 822c4b0:	e0bfff17 	ldw	r2,-4(fp)
 822c4b4:	10800058 	cmpnei	r2,r2,1
 822c4b8:	1000021e 	bne	r2,zero,822c4c4 <dhc_state_init+0x2c>
 822c4bc:	00800044 	movi	r2,1
 822c4c0:	00000106 	br	822c4c8 <dhc_state_init+0x30>
 822c4c4:	00800084 	movi	r2,2
 822c4c8:	e0bffd15 	stw	r2,-12(fp)
   
   dhc_set_state(iface, state);
 822c4cc:	e17ffd17 	ldw	r5,-12(fp)
 822c4d0:	e13ffe17 	ldw	r4,-8(fp)
 822c4d4:	822c5e00 	call	822c5e0 <dhc_set_state>
}
 822c4d8:	0001883a 	nop
 822c4dc:	e037883a 	mov	sp,fp
 822c4e0:	dfc00117 	ldw	ra,4(sp)
 822c4e4:	df000017 	ldw	fp,0(sp)
 822c4e8:	dec00204 	addi	sp,sp,8
 822c4ec:	f800283a 	ret

0822c4f0 <dhc_alldone>:
 * otherwise. 
 */

int 
dhc_alldone(void)
{
 822c4f0:	defffe04 	addi	sp,sp,-8
 822c4f4:	df000115 	stw	fp,4(sp)
 822c4f8:	df000104 	addi	fp,sp,4
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 822c4fc:	e03fff15 	stw	zero,-4(fp)
 822c500:	00001506 	br	822c558 <dhc_alldone+0x68>
   {
      if ( ( dhc_states[i].state == DHCS_UNUSED ) || 
 822c504:	008209b4 	movhi	r2,2086
 822c508:	10b84104 	addi	r2,r2,-7932
 822c50c:	e0ffff17 	ldw	r3,-4(fp)
 822c510:	18c00f24 	muli	r3,r3,60
 822c514:	10c5883a 	add	r2,r2,r3
 822c518:	10800017 	ldw	r2,0(r2)
 822c51c:	10000826 	beq	r2,zero,822c540 <dhc_alldone+0x50>
          ( dhc_states[i].state == DHCS_BOUND  )  )
 822c520:	008209b4 	movhi	r2,2086
 822c524:	10b84104 	addi	r2,r2,-7932
 822c528:	e0ffff17 	ldw	r3,-4(fp)
 822c52c:	18c00f24 	muli	r3,r3,60
 822c530:	10c5883a 	add	r2,r2,r3
 822c534:	10800017 	ldw	r2,0(r2)
dhc_alldone(void)
{
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
   {
      if ( ( dhc_states[i].state == DHCS_UNUSED ) || 
 822c538:	10800198 	cmpnei	r2,r2,6
 822c53c:	1000041e 	bne	r2,zero,822c550 <dhc_alldone+0x60>

int 
dhc_alldone(void)
{
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 822c540:	e0bfff17 	ldw	r2,-4(fp)
 822c544:	10800044 	addi	r2,r2,1
 822c548:	e0bfff15 	stw	r2,-4(fp)
 822c54c:	00000206 	br	822c558 <dhc_alldone+0x68>
      {
         continue ;
      }
      else
      {
         return FALSE ;
 822c550:	0005883a 	mov	r2,zero
 822c554:	00000406 	br	822c568 <dhc_alldone+0x78>

int 
dhc_alldone(void)
{
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 822c558:	e0bfff17 	ldw	r2,-4(fp)
 822c55c:	10800110 	cmplti	r2,r2,4
 822c560:	103fe81e 	bne	r2,zero,822c504 <dhc_alldone+0x14>
      else
      {
         return FALSE ;
      }
   }
   return TRUE ;
 822c564:	00800044 	movi	r2,1
}
 822c568:	e037883a 	mov	sp,fp
 822c56c:	df000017 	ldw	fp,0(sp)
 822c570:	dec00104 	addi	sp,sp,4
 822c574:	f800283a 	ret

0822c578 <dhc_ifacedone>:
 * RETURNS: 
 */

int 
dhc_ifacedone(int iface)
{
 822c578:	defffe04 	addi	sp,sp,-8
 822c57c:	df000115 	stw	fp,4(sp)
 822c580:	df000104 	addi	fp,sp,4
 822c584:	e13fff15 	stw	r4,-4(fp)
   if ( ( dhc_states[iface].state == DHCS_UNUSED ) || 
 822c588:	008209b4 	movhi	r2,2086
 822c58c:	10b84104 	addi	r2,r2,-7932
 822c590:	e0ffff17 	ldw	r3,-4(fp)
 822c594:	18c00f24 	muli	r3,r3,60
 822c598:	10c5883a 	add	r2,r2,r3
 822c59c:	10800017 	ldw	r2,0(r2)
 822c5a0:	10000826 	beq	r2,zero,822c5c4 <dhc_ifacedone+0x4c>
       ( dhc_states[iface].state == DHCS_BOUND  )  )
 822c5a4:	008209b4 	movhi	r2,2086
 822c5a8:	10b84104 	addi	r2,r2,-7932
 822c5ac:	e0ffff17 	ldw	r3,-4(fp)
 822c5b0:	18c00f24 	muli	r3,r3,60
 822c5b4:	10c5883a 	add	r2,r2,r3
 822c5b8:	10800017 	ldw	r2,0(r2)
 */

int 
dhc_ifacedone(int iface)
{
   if ( ( dhc_states[iface].state == DHCS_UNUSED ) || 
 822c5bc:	10800198 	cmpnei	r2,r2,6
 822c5c0:	1000021e 	bne	r2,zero,822c5cc <dhc_ifacedone+0x54>
       ( dhc_states[iface].state == DHCS_BOUND  )  )
   {
      return TRUE ;
 822c5c4:	00800044 	movi	r2,1
 822c5c8:	00000106 	br	822c5d0 <dhc_ifacedone+0x58>
   }
   else
   {
      return FALSE ;
 822c5cc:	0005883a 	mov	r2,zero
   }
}
 822c5d0:	e037883a 	mov	sp,fp
 822c5d4:	df000017 	ldw	fp,0(sp)
 822c5d8:	dec00104 	addi	sp,sp,4
 822c5dc:	f800283a 	ret

0822c5e0 <dhc_set_state>:
 *
 * RETURNS: 
 */

void dhc_set_state(int iface, int state)
{
 822c5e0:	defffc04 	addi	sp,sp,-16
 822c5e4:	dfc00315 	stw	ra,12(sp)
 822c5e8:	df000215 	stw	fp,8(sp)
 822c5ec:	df000204 	addi	fp,sp,8
 822c5f0:	e13ffe15 	stw	r4,-8(fp)
 822c5f4:	e17fff15 	stw	r5,-4(fp)
   dhc_states[iface].state = state; /* Set the new state */
 822c5f8:	e0ffff17 	ldw	r3,-4(fp)
 822c5fc:	008209b4 	movhi	r2,2086
 822c600:	10b84104 	addi	r2,r2,-7932
 822c604:	e13ffe17 	ldw	r4,-8(fp)
 822c608:	21000f24 	muli	r4,r4,60
 822c60c:	1105883a 	add	r2,r2,r4
 822c610:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].tries = 0;     /* Reset the number of tries */
 822c614:	008209b4 	movhi	r2,2086
 822c618:	10b84104 	addi	r2,r2,-7932
 822c61c:	e0fffe17 	ldw	r3,-8(fp)
 822c620:	18c00f24 	muli	r3,r3,60
 822c624:	10c5883a 	add	r2,r2,r3
 822c628:	10800104 	addi	r2,r2,4
 822c62c:	10000015 	stw	zero,0(r2)

   /* If callback is set, call it */
   if (dhc_states[iface].callback)
 822c630:	008209b4 	movhi	r2,2086
 822c634:	10b84104 	addi	r2,r2,-7932
 822c638:	e0fffe17 	ldw	r3,-8(fp)
 822c63c:	18c00f24 	muli	r3,r3,60
 822c640:	10c5883a 	add	r2,r2,r3
 822c644:	10800e04 	addi	r2,r2,56
 822c648:	10800017 	ldw	r2,0(r2)
 822c64c:	10000a26 	beq	r2,zero,822c678 <dhc_set_state+0x98>
      dhc_states[iface].callback(iface,state);
 822c650:	008209b4 	movhi	r2,2086
 822c654:	10b84104 	addi	r2,r2,-7932
 822c658:	e0fffe17 	ldw	r3,-8(fp)
 822c65c:	18c00f24 	muli	r3,r3,60
 822c660:	10c5883a 	add	r2,r2,r3
 822c664:	10800e04 	addi	r2,r2,56
 822c668:	10800017 	ldw	r2,0(r2)
 822c66c:	e17fff17 	ldw	r5,-4(fp)
 822c670:	e13ffe17 	ldw	r4,-8(fp)
 822c674:	103ee83a 	callr	r2
}
 822c678:	0001883a 	nop
 822c67c:	e037883a 	mov	sp,fp
 822c680:	dfc00117 	ldw	ra,4(sp)
 822c684:	df000017 	ldw	fp,0(sp)
 822c688:	dec00204 	addi	sp,sp,8
 822c68c:	f800283a 	ret

0822c690 <find_opt>:
 * RETURNS:  Return pointer to that code if found, NULL if not found.
 */

u_char * 
find_opt(u_char opcode, u_char * opts)
{
 822c690:	defffc04 	addi	sp,sp,-16
 822c694:	df000315 	stw	fp,12(sp)
 822c698:	df000304 	addi	fp,sp,12
 822c69c:	2005883a 	mov	r2,r4
 822c6a0:	e17fff15 	stw	r5,-4(fp)
 822c6a4:	e0bffe05 	stb	r2,-8(fp)
   u_char * end   =  opts  +  DHCP_OPTSIZE;  /* limit scope of search */
 822c6a8:	e0bfff17 	ldw	r2,-4(fp)
 822c6ac:	10804e04 	addi	r2,r2,312
 822c6b0:	e0bffd15 	stw	r2,-12(fp)

   while (opts < end)
 822c6b4:	00001e06 	br	822c730 <find_opt+0xa0>
   {
      if (*opts == opcode) /* found it */
 822c6b8:	e0bfff17 	ldw	r2,-4(fp)
 822c6bc:	10800003 	ldbu	r2,0(r2)
 822c6c0:	10c03fcc 	andi	r3,r2,255
 822c6c4:	e0bffe03 	ldbu	r2,-8(fp)
 822c6c8:	1880021e 	bne	r3,r2,822c6d4 <find_opt+0x44>
         return opts;
 822c6cc:	e0bfff17 	ldw	r2,-4(fp)
 822c6d0:	00001b06 	br	822c740 <find_opt+0xb0>
      if (*opts == DHOP_END)  /* end of options; opcode not found */
 822c6d4:	e0bfff17 	ldw	r2,-4(fp)
 822c6d8:	10800003 	ldbu	r2,0(r2)
 822c6dc:	10803fcc 	andi	r2,r2,255
 822c6e0:	10803fd8 	cmpnei	r2,r2,255
 822c6e4:	1000021e 	bne	r2,zero,822c6f0 <find_opt+0x60>
         return NULL;
 822c6e8:	0005883a 	mov	r2,zero
 822c6ec:	00001406 	br	822c740 <find_opt+0xb0>
      if (*opts == DHOP_PAD)  /* PAD has only 1 byte */
 822c6f0:	e0bfff17 	ldw	r2,-4(fp)
 822c6f4:	10800003 	ldbu	r2,0(r2)
 822c6f8:	10803fcc 	andi	r2,r2,255
 822c6fc:	1000041e 	bne	r2,zero,822c710 <find_opt+0x80>
         opts++;
 822c700:	e0bfff17 	ldw	r2,-4(fp)
 822c704:	10800044 	addi	r2,r2,1
 822c708:	e0bfff15 	stw	r2,-4(fp)
 822c70c:	00000806 	br	822c730 <find_opt+0xa0>
      else     /* all other options should have a length field */
         opts += (*(opts+1))+2;
 822c710:	e0bfff17 	ldw	r2,-4(fp)
 822c714:	10800044 	addi	r2,r2,1
 822c718:	10800003 	ldbu	r2,0(r2)
 822c71c:	10803fcc 	andi	r2,r2,255
 822c720:	10800084 	addi	r2,r2,2
 822c724:	e0ffff17 	ldw	r3,-4(fp)
 822c728:	1885883a 	add	r2,r3,r2
 822c72c:	e0bfff15 	stw	r2,-4(fp)
u_char * 
find_opt(u_char opcode, u_char * opts)
{
   u_char * end   =  opts  +  DHCP_OPTSIZE;  /* limit scope of search */

   while (opts < end)
 822c730:	e0ffff17 	ldw	r3,-4(fp)
 822c734:	e0bffd17 	ldw	r2,-12(fp)
 822c738:	18bfdf36 	bltu	r3,r2,822c6b8 <find_opt+0x28>
         opts++;
      else     /* all other options should have a length field */
         opts += (*(opts+1))+2;
   }
   /* no DHOP_END option?? */
   return NULL;
 822c73c:	0005883a 	mov	r2,zero
}
 822c740:	e037883a 	mov	sp,fp
 822c744:	df000017 	ldw	fp,0(sp)
 822c748:	dec00104 	addi	sp,sp,4
 822c74c:	f800283a 	ret

0822c750 <pk_init>:
 * for a PACKET buffer or a data buffer fails, or if there is an inconsistency
 * between (bigbufs + lilbufs) and MAXPACKETS) it returns -1. 
 */

int pk_init (void)
{
 822c750:	defff804 	addi	sp,sp,-32
 822c754:	dfc00715 	stw	ra,28(sp)
 822c758:	df000615 	stw	fp,24(sp)
 822c75c:	df000604 	addi	fp,sp,24
   PACKET packet;
   unsigned i;
   unsigned numpkts = bigbufs + lilbufs;
 822c760:	d0e03817 	ldw	r3,-32544(gp)
 822c764:	d0a03617 	ldw	r2,-32552(gp)
 822c768:	1885883a 	add	r2,r3,r2
 822c76c:	e0bffd15 	stw	r2,-12(fp)
   u_char align_req;
   
#ifdef ALIGN_BUFS
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
 822c770:	e03ffe05 	stb	zero,-8(fp)
#endif

   for (i = 0; i < numpkts; i++)
 822c774:	e03ffa15 	stw	zero,-24(fp)
 822c778:	00007a06 	br	822c964 <pk_init+0x214>
   {
      packet = (PACKET)NB_ALLOC(sizeof(struct netbuf));
 822c77c:	01000d04 	movi	r4,52
 822c780:	822e16c0 	call	822e16c <npalloc>
 822c784:	e0bfff15 	stw	r2,-4(fp)
      if (packet == NULL)
 822c788:	e0bfff17 	ldw	r2,-4(fp)
 822c78c:	10008426 	beq	r2,zero,822c9a0 <pk_init+0x250>
         goto no_pkt_buf;

#ifdef NPDEBUG
      if (i >= MAXPACKETS)
 822c790:	e0bffa17 	ldw	r2,-24(fp)
 822c794:	10800f30 	cmpltui	r2,r2,60
 822c798:	1000051e 	bne	r2,zero,822c7b0 <pk_init+0x60>
      {
         dprintf("pk_init: bad define\n");
 822c79c:	01020974 	movhi	r4,2085
 822c7a0:	21021b04 	addi	r4,r4,2156
 822c7a4:	82036240 	call	8203624 <puts>
         return -1;
 822c7a8:	00bfffc4 	movi	r2,-1
 822c7ac:	00008a06 	br	822c9d8 <pk_init+0x288>
      }
      pktlog[i] = packet;     /* save for debugging */
 822c7b0:	008209b4 	movhi	r2,2086
 822c7b4:	10b88604 	addi	r2,r2,-7656
 822c7b8:	e0fffa17 	ldw	r3,-24(fp)
 822c7bc:	18c7883a 	add	r3,r3,r3
 822c7c0:	18c7883a 	add	r3,r3,r3
 822c7c4:	10c5883a 	add	r2,r2,r3
 822c7c8:	e0ffff17 	ldw	r3,-4(fp)
 822c7cc:	10c00015 	stw	r3,0(r2)
#endif

      packet->nb_tstamp = 0L;
 822c7d0:	e0bfff17 	ldw	r2,-4(fp)
 822c7d4:	10000515 	stw	zero,20(r2)

      if (i < bigbufs)
 822c7d8:	d0a03817 	ldw	r2,-32544(gp)
 822c7dc:	e0fffa17 	ldw	r3,-24(fp)
 822c7e0:	18802f2e 	bgeu	r3,r2,822c8a0 <pk_init+0x150>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
 822c7e4:	d0a03917 	ldw	r2,-32540(gp)
 822c7e8:	10800144 	addi	r2,r2,5
 822c7ec:	1009883a 	mov	r4,r2
 822c7f0:	822e1e00 	call	822e1e0 <ncpalloc>
 822c7f4:	1007883a 	mov	r3,r2
 822c7f8:	e0bfff17 	ldw	r2,-4(fp)
 822c7fc:	10c00115 	stw	r3,4(r2)
            if (!(packet->nb_buff))
 822c800:	e0bfff17 	ldw	r2,-4(fp)
 822c804:	10800117 	ldw	r2,4(r2)
 822c808:	10006726 	beq	r2,zero,822c9a8 <pk_init+0x258>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 822c80c:	e03ffb15 	stw	zero,-20(fp)
 822c810:	00000906 	br	822c838 <pk_init+0xe8>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 822c814:	e0bfff17 	ldw	r2,-4(fp)
 822c818:	10c00117 	ldw	r3,4(r2)
 822c81c:	e0bffb17 	ldw	r2,-20(fp)
 822c820:	1885883a 	add	r2,r3,r2
 822c824:	00c01344 	movi	r3,77
 822c828:	10c00005 	stb	r3,0(r2)
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 822c82c:	e0bffb17 	ldw	r2,-20(fp)
 822c830:	10800044 	addi	r2,r2,1
 822c834:	e0bffb15 	stw	r2,-20(fp)
 822c838:	e0bffb17 	ldw	r2,-20(fp)
 822c83c:	10800110 	cmplti	r2,r2,4
 822c840:	103ff41e 	bne	r2,zero,822c814 <pk_init+0xc4>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + bigbufsiz + ALIGN_TYPE) = 'M';
 822c844:	e0bfff17 	ldw	r2,-4(fp)
 822c848:	10c00117 	ldw	r3,4(r2)
 822c84c:	d0a03917 	ldw	r2,-32540(gp)
 822c850:	10800104 	addi	r2,r2,4
 822c854:	1885883a 	add	r2,r3,r2
 822c858:	00c01344 	movi	r3,77
 822c85c:	10c00005 	stb	r3,0(r2)
            packet->nb_buff += ALIGN_TYPE;   /* bump buf past MMs */
 822c860:	e0bfff17 	ldw	r2,-4(fp)
 822c864:	10800117 	ldw	r2,4(r2)
 822c868:	10c00104 	addi	r3,r2,4
 822c86c:	e0bfff17 	ldw	r2,-4(fp)
 822c870:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 822c874:	e0bfff17 	ldw	r2,-4(fp)
 822c878:	10800117 	ldw	r2,4(r2)
 822c87c:	10004c26 	beq	r2,zero,822c9b0 <pk_init+0x260>
            goto no_pkt_buf;
         packet->nb_blen = bigbufsiz;
 822c880:	d0e03917 	ldw	r3,-32540(gp)
 822c884:	e0bfff17 	ldw	r2,-4(fp)
 822c888:	10c00215 	stw	r3,8(r2)
         q_add(&bigfreeq, packet);        /* save it in big pkt free queue */
 822c88c:	e17fff17 	ldw	r5,-4(fp)
 822c890:	010209b4 	movhi	r4,2086
 822c894:	2138c204 	addi	r4,r4,-7416
 822c898:	822cf7c0 	call	822cf7c <putq>
 822c89c:	00002e06 	br	822c958 <pk_init+0x208>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
 822c8a0:	d0a03717 	ldw	r2,-32548(gp)
 822c8a4:	10800144 	addi	r2,r2,5
 822c8a8:	1009883a 	mov	r4,r2
 822c8ac:	822e1e00 	call	822e1e0 <ncpalloc>
 822c8b0:	1007883a 	mov	r3,r2
 822c8b4:	e0bfff17 	ldw	r2,-4(fp)
 822c8b8:	10c00115 	stw	r3,4(r2)
            if (!(packet->nb_buff))
 822c8bc:	e0bfff17 	ldw	r2,-4(fp)
 822c8c0:	10800117 	ldw	r2,4(r2)
 822c8c4:	10003c26 	beq	r2,zero,822c9b8 <pk_init+0x268>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 822c8c8:	e03ffc15 	stw	zero,-16(fp)
 822c8cc:	00000906 	br	822c8f4 <pk_init+0x1a4>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 822c8d0:	e0bfff17 	ldw	r2,-4(fp)
 822c8d4:	10c00117 	ldw	r3,4(r2)
 822c8d8:	e0bffc17 	ldw	r2,-16(fp)
 822c8dc:	1885883a 	add	r2,r3,r2
 822c8e0:	00c01344 	movi	r3,77
 822c8e4:	10c00005 	stb	r3,0(r2)
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 822c8e8:	e0bffc17 	ldw	r2,-16(fp)
 822c8ec:	10800044 	addi	r2,r2,1
 822c8f0:	e0bffc15 	stw	r2,-16(fp)
 822c8f4:	e0bffc17 	ldw	r2,-16(fp)
 822c8f8:	10800110 	cmplti	r2,r2,4
 822c8fc:	103ff41e 	bne	r2,zero,822c8d0 <pk_init+0x180>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + lilbufsiz + ALIGN_TYPE) = 'M';
 822c900:	e0bfff17 	ldw	r2,-4(fp)
 822c904:	10c00117 	ldw	r3,4(r2)
 822c908:	d0a03717 	ldw	r2,-32548(gp)
 822c90c:	10800104 	addi	r2,r2,4
 822c910:	1885883a 	add	r2,r3,r2
 822c914:	00c01344 	movi	r3,77
 822c918:	10c00005 	stb	r3,0(r2)
            packet->nb_buff += ALIGN_TYPE;
 822c91c:	e0bfff17 	ldw	r2,-4(fp)
 822c920:	10800117 	ldw	r2,4(r2)
 822c924:	10c00104 	addi	r3,r2,4
 822c928:	e0bfff17 	ldw	r2,-4(fp)
 822c92c:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 822c930:	e0bfff17 	ldw	r2,-4(fp)
 822c934:	10800117 	ldw	r2,4(r2)
 822c938:	10002126 	beq	r2,zero,822c9c0 <pk_init+0x270>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
 822c93c:	d0e03717 	ldw	r3,-32548(gp)
 822c940:	e0bfff17 	ldw	r2,-4(fp)
 822c944:	10c00215 	stw	r3,8(r2)
         q_add(&lilfreeq, packet);        /* save it in little free queue */
 822c948:	e17fff17 	ldw	r5,-4(fp)
 822c94c:	010209b4 	movhi	r4,2086
 822c950:	21387d04 	addi	r4,r4,-7692
 822c954:	822cf7c0 	call	822cf7c <putq>
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
#endif

   for (i = 0; i < numpkts; i++)
 822c958:	e0bffa17 	ldw	r2,-24(fp)
 822c95c:	10800044 	addi	r2,r2,1
 822c960:	e0bffa15 	stw	r2,-24(fp)
 822c964:	e0fffa17 	ldw	r3,-24(fp)
 822c968:	e0bffd17 	ldw	r2,-12(fp)
 822c96c:	18bf8336 	bltu	r3,r2,822c77c <pk_init+0x2c>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
         q_add(&lilfreeq, packet);        /* save it in little free queue */
      }
   }
   bigfreeq.q_min = bigbufs;
 822c970:	d0a03817 	ldw	r2,-32544(gp)
 822c974:	1007883a 	mov	r3,r2
 822c978:	008209b4 	movhi	r2,2086
 822c97c:	10b8c204 	addi	r2,r2,-7416
 822c980:	10c00415 	stw	r3,16(r2)
   lilfreeq.q_min = lilbufs;
 822c984:	d0a03617 	ldw	r2,-32552(gp)
 822c988:	1007883a 	mov	r3,r2
 822c98c:	008209b4 	movhi	r2,2086
 822c990:	10b87d04 	addi	r2,r2,-7692
 822c994:	10c00415 	stw	r3,16(r2)
   heap_curr_mem_hi_watermark = 0;
   /* set the heap's access type to blocking */
   heap_type = HEAP_ACCESS_BLOCKING;
#endif

   return 0;
 822c998:	0005883a 	mov	r2,zero
 822c99c:	00000e06 	br	822c9d8 <pk_init+0x288>

   for (i = 0; i < numpkts; i++)
   {
      packet = (PACKET)NB_ALLOC(sizeof(struct netbuf));
      if (packet == NULL)
         goto no_pkt_buf;
 822c9a0:	0001883a 	nop
 822c9a4:	00000706 	br	822c9c4 <pk_init+0x274>
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;
 822c9a8:	0001883a 	nop
 822c9ac:	00000506 	br	822c9c4 <pk_init+0x274>
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
            goto no_pkt_buf;
 822c9b0:	0001883a 	nop
 822c9b4:	00000306 	br	822c9c4 <pk_init+0x274>
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;
 822c9b8:	0001883a 	nop
 822c9bc:	00000106 	br	822c9c4 <pk_init+0x274>
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
            goto no_pkt_buf;
 822c9c0:	0001883a 	nop

   return 0;

no_pkt_buf:
#ifdef NPDEBUG
   dprintf("Netinit: calloc failed getting buffer %d\n", i);
 822c9c4:	e17ffa17 	ldw	r5,-24(fp)
 822c9c8:	01020974 	movhi	r4,2085
 822c9cc:	21022004 	addi	r4,r4,2176
 822c9d0:	82033a00 	call	82033a0 <printf>
#endif
   return(-1);
 822c9d4:	00bfffc4 	movi	r2,-1
}
 822c9d8:	e037883a 	mov	sp,fp
 822c9dc:	dfc00117 	ldw	ra,4(sp)
 822c9e0:	df000017 	ldw	fp,0(sp)
 822c9e4:	dec00204 	addi	sp,sp,8
 822c9e8:	f800283a 	ret

0822c9ec <pk_alloc>:
 * OUTPUT: 0 if the request cannot be satisfied, or a pointer to the struct
 * netbuf structure that corresponds to the just allocated data buffer.
 */

PACKET pk_alloc(unsigned len)
{
 822c9ec:	defffc04 	addi	sp,sp,-16
 822c9f0:	dfc00315 	stw	ra,12(sp)
 822c9f4:	df000215 	stw	fp,8(sp)
 822c9f8:	df000204 	addi	fp,sp,8
 822c9fc:	e13fff15 	stw	r4,-4(fp)
   PACKET p;

   if (len > bigbufsiz) /* caller wants oversize buffer? */
 822ca00:	d0e03917 	ldw	r3,-32540(gp)
 822ca04:	e0bfff17 	ldw	r2,-4(fp)
 822ca08:	1880022e 	bgeu	r3,r2,822ca14 <pk_alloc+0x28>
   {
#ifdef HEAPBUFS
      if ((p = pk_alloc_heapbuf (len)) == NULL)
         return NULL;
#else
      return(NULL);
 822ca0c:	0005883a 	mov	r2,zero
 822ca10:	00002206 	br	822ca9c <pk_alloc+0xb0>
#endif
   }
   else
   {
      if ((len > lilbufsiz) || (lilfreeq.q_len == 0)) /* must use a big buffer */
 822ca14:	d0e03717 	ldw	r3,-32548(gp)
 822ca18:	e0bfff17 	ldw	r2,-4(fp)
 822ca1c:	18800436 	bltu	r3,r2,822ca30 <pk_alloc+0x44>
 822ca20:	008209b4 	movhi	r2,2086
 822ca24:	10b87d04 	addi	r2,r2,-7692
 822ca28:	10800217 	ldw	r2,8(r2)
 822ca2c:	1000051e 	bne	r2,zero,822ca44 <pk_alloc+0x58>
         p = (PACKET)getq(&bigfreeq);
 822ca30:	010209b4 	movhi	r4,2086
 822ca34:	2138c204 	addi	r4,r4,-7416
 822ca38:	822cec40 	call	822cec4 <getq>
 822ca3c:	e0bffe15 	stw	r2,-8(fp)
 822ca40:	00000406 	br	822ca54 <pk_alloc+0x68>
      else
         p = (PACKET)getq(&lilfreeq);
 822ca44:	010209b4 	movhi	r4,2086
 822ca48:	21387d04 	addi	r4,r4,-7692
 822ca4c:	822cec40 	call	822cec4 <getq>
 822ca50:	e0bffe15 	stw	r2,-8(fp)

      if (!p)
 822ca54:	e0bffe17 	ldw	r2,-8(fp)
 822ca58:	1000021e 	bne	r2,zero,822ca64 <pk_alloc+0x78>
         return NULL;
 822ca5c:	0005883a 	mov	r2,zero
 822ca60:	00000e06 	br	822ca9c <pk_alloc+0xb0>
   }

   p->nb_prot = p->nb_buff + MaxLnh;   /* point past biggest mac header */
 822ca64:	e0bffe17 	ldw	r2,-8(fp)
 822ca68:	10800117 	ldw	r2,4(r2)
 822ca6c:	d0e08117 	ldw	r3,-32252(gp)
 822ca70:	10c7883a 	add	r3,r2,r3
 822ca74:	e0bffe17 	ldw	r2,-8(fp)
 822ca78:	10c00315 	stw	r3,12(r2)
   p->nb_plen = 0;   /* no protocol data there yet */
 822ca7c:	e0bffe17 	ldw	r2,-8(fp)
 822ca80:	10000415 	stw	zero,16(r2)
   p->net = NULL;
 822ca84:	e0bffe17 	ldw	r2,-8(fp)
 822ca88:	10000615 	stw	zero,24(r2)
   p->nexthop = NULL;      /* no next hop  */
   p->nb_pmtu = 1240;      /* Set minimum IPv6 Path MTU */
#endif   /* IP_V6 */
#endif /* LINKED_PKTS */

   p->inuse = 1;  /* initially buffer in use by 1 user */
 822ca8c:	e0bffe17 	ldw	r2,-8(fp)
 822ca90:	00c00044 	movi	r3,1
 822ca94:	10c00915 	stw	r3,36(r2)

   /* note that 'type' and 'fhost' fields are not set in pk_alloc () */
   return(p);
 822ca98:	e0bffe17 	ldw	r2,-8(fp)
}
 822ca9c:	e037883a 	mov	sp,fp
 822caa0:	dfc00117 	ldw	ra,4(sp)
 822caa4:	df000017 	ldw	fp,0(sp)
 822caa8:	dec00204 	addi	sp,sp,8
 822caac:	f800283a 	ret

0822cab0 <pk_validate>:
 * OUTPUT: 0 if the buffer being freed was successfully validated, or
 * -1 if the validation failed.
 */

int pk_validate(PACKET pkt)   /* check if pk_free() can free the pkt */
{
 822cab0:	defffb04 	addi	sp,sp,-20
 822cab4:	dfc00415 	stw	ra,16(sp)
 822cab8:	df000315 	stw	fp,12(sp)
 822cabc:	df000304 	addi	fp,sp,12
 822cac0:	e13fff15 	stw	r4,-4(fp)
   /* If packet link is non-zero, then this packet is
    * part of a chain and deleted this packet would break
    * the chain and cause memory leak for subsequent pkts.
    * Note that heapbufs do not use the 'next' field at all.
    */
   if ((pkt->next) && (pkt->inuse >= 1))
 822cac4:	e0bfff17 	ldw	r2,-4(fp)
 822cac8:	10800017 	ldw	r2,0(r2)
 822cacc:	10000e26 	beq	r2,zero,822cb08 <pk_validate+0x58>
 822cad0:	e0bfff17 	ldw	r2,-4(fp)
 822cad4:	10800917 	ldw	r2,36(r2)
 822cad8:	10000b26 	beq	r2,zero,822cb08 <pk_validate+0x58>
   {
      INCR_SHARED_VAR (memestats, INCONSISTENT_LOCATION_ERR, 1);   
 822cadc:	822d76c0 	call	822d76c <irq_Mask>
 822cae0:	008209b4 	movhi	r2,2086
 822cae4:	10b88204 	addi	r2,r2,-7672
 822cae8:	10800317 	ldw	r2,12(r2)
 822caec:	10c00044 	addi	r3,r2,1
 822caf0:	008209b4 	movhi	r2,2086
 822caf4:	10b88204 	addi	r2,r2,-7672
 822caf8:	10c00315 	stw	r3,12(r2)
 822cafc:	822d7cc0 	call	822d7cc <irq_Unmask>
      return -1;
 822cb00:	00bfffc4 	movi	r2,-1
 822cb04:	00008806 	br	822cd28 <pk_validate+0x278>
   }
   else  
#endif /* HEAPBUFS */
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
 822cb08:	e0bfff17 	ldw	r2,-4(fp)
 822cb0c:	10c00217 	ldw	r3,8(r2)
 822cb10:	d0a03917 	ldw	r2,-32540(gp)
 822cb14:	1880201e 	bne	r3,r2,822cb98 <pk_validate+0xe8>
      {
         ENTER_CRIT_SECTION(&bigfreeq);
 822cb18:	822d76c0 	call	822d76c <irq_Mask>
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 822cb1c:	008209b4 	movhi	r2,2086
 822cb20:	10b8c204 	addi	r2,r2,-7416
 822cb24:	10800017 	ldw	r2,0(r2)
 822cb28:	e0bffd15 	stw	r2,-12(fp)
 822cb2c:	00001606 	br	822cb88 <pk_validate+0xd8>
            if (p == pkt)
 822cb30:	e0fffd17 	ldw	r3,-12(fp)
 822cb34:	e0bfff17 	ldw	r2,-4(fp)
 822cb38:	1880101e 	bne	r3,r2,822cb7c <pk_validate+0xcc>
            {
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
 822cb3c:	e17fff17 	ldw	r5,-4(fp)
 822cb40:	01020974 	movhi	r4,2085
 822cb44:	21022b04 	addi	r4,r4,2220
 822cb48:	82033a00 	call	82033a0 <printf>
               EXIT_CRIT_SECTION(&bigfreeq);
 822cb4c:	822d7cc0 	call	822d7cc <irq_Unmask>
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 822cb50:	822d76c0 	call	822d76c <irq_Mask>
 822cb54:	008209b4 	movhi	r2,2086
 822cb58:	10b88204 	addi	r2,r2,-7672
 822cb5c:	10800217 	ldw	r2,8(r2)
 822cb60:	10c00044 	addi	r3,r2,1
 822cb64:	008209b4 	movhi	r2,2086
 822cb68:	10b88204 	addi	r2,r2,-7672
 822cb6c:	10c00215 	stw	r3,8(r2)
 822cb70:	822d7cc0 	call	822d7cc <irq_Unmask>
               return -1;
 822cb74:	00bfffc4 	movi	r2,-1
 822cb78:	00006b06 	br	822cd28 <pk_validate+0x278>
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
      {
         ENTER_CRIT_SECTION(&bigfreeq);
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 822cb7c:	e0bffd17 	ldw	r2,-12(fp)
 822cb80:	10800017 	ldw	r2,0(r2)
 822cb84:	e0bffd15 	stw	r2,-12(fp)
 822cb88:	e0bffd17 	ldw	r2,-12(fp)
 822cb8c:	103fe81e 	bne	r2,zero,822cb30 <pk_validate+0x80>
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
               EXIT_CRIT_SECTION(&bigfreeq);
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
               return -1;
            }
         EXIT_CRIT_SECTION(&bigfreeq);
 822cb90:	822d7cc0 	call	822d7cc <irq_Unmask>
 822cb94:	00002f06 	br	822cc54 <pk_validate+0x1a4>
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
 822cb98:	e0bfff17 	ldw	r2,-4(fp)
 822cb9c:	10c00217 	ldw	r3,8(r2)
 822cba0:	d0a03717 	ldw	r2,-32548(gp)
 822cba4:	1880201e 	bne	r3,r2,822cc28 <pk_validate+0x178>
      {
         ENTER_CRIT_SECTION(&lilfreeq);
 822cba8:	822d76c0 	call	822d76c <irq_Mask>
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 822cbac:	008209b4 	movhi	r2,2086
 822cbb0:	10b87d04 	addi	r2,r2,-7692
 822cbb4:	10800017 	ldw	r2,0(r2)
 822cbb8:	e0bffd15 	stw	r2,-12(fp)
 822cbbc:	00001606 	br	822cc18 <pk_validate+0x168>
            if (p == pkt)
 822cbc0:	e0fffd17 	ldw	r3,-12(fp)
 822cbc4:	e0bfff17 	ldw	r2,-4(fp)
 822cbc8:	1880101e 	bne	r3,r2,822cc0c <pk_validate+0x15c>
         {
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
 822cbcc:	e17fff17 	ldw	r5,-4(fp)
 822cbd0:	01020974 	movhi	r4,2085
 822cbd4:	21023504 	addi	r4,r4,2260
 822cbd8:	82033a00 	call	82033a0 <printf>
            EXIT_CRIT_SECTION(&lilfreeq);
 822cbdc:	822d7cc0 	call	822d7cc <irq_Unmask>
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 822cbe0:	822d76c0 	call	822d76c <irq_Mask>
 822cbe4:	008209b4 	movhi	r2,2086
 822cbe8:	10b88204 	addi	r2,r2,-7672
 822cbec:	10800217 	ldw	r2,8(r2)
 822cbf0:	10c00044 	addi	r3,r2,1
 822cbf4:	008209b4 	movhi	r2,2086
 822cbf8:	10b88204 	addi	r2,r2,-7672
 822cbfc:	10c00215 	stw	r3,8(r2)
 822cc00:	822d7cc0 	call	822d7cc <irq_Unmask>
            return -1;
 822cc04:	00bfffc4 	movi	r2,-1
 822cc08:	00004706 	br	822cd28 <pk_validate+0x278>
         EXIT_CRIT_SECTION(&bigfreeq);
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
      {
         ENTER_CRIT_SECTION(&lilfreeq);
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 822cc0c:	e0bffd17 	ldw	r2,-12(fp)
 822cc10:	10800017 	ldw	r2,0(r2)
 822cc14:	e0bffd15 	stw	r2,-12(fp)
 822cc18:	e0bffd17 	ldw	r2,-12(fp)
 822cc1c:	103fe81e 	bne	r2,zero,822cbc0 <pk_validate+0x110>
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
            EXIT_CRIT_SECTION(&lilfreeq);
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
            return -1;
         }
         EXIT_CRIT_SECTION(&lilfreeq);
 822cc20:	822d7cc0 	call	822d7cc <irq_Unmask>
 822cc24:	00000b06 	br	822cc54 <pk_validate+0x1a4>
      }
      else
      {
         /* log an error */
         INCR_SHARED_VAR (memestats, BAD_REGULAR_BUF_LEN_ERR, 1);
 822cc28:	822d76c0 	call	822d76c <irq_Mask>
 822cc2c:	008209b4 	movhi	r2,2086
 822cc30:	10b88204 	addi	r2,r2,-7672
 822cc34:	10800017 	ldw	r2,0(r2)
 822cc38:	10c00044 	addi	r3,r2,1
 822cc3c:	008209b4 	movhi	r2,2086
 822cc40:	10b88204 	addi	r2,r2,-7672
 822cc44:	10c00015 	stw	r3,0(r2)
 822cc48:	822d7cc0 	call	822d7cc <irq_Unmask>
         return -1;
 822cc4c:	00bfffc4 	movi	r2,-1
 822cc50:	00003506 	br	822cd28 <pk_validate+0x278>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 822cc54:	00800104 	movi	r2,4
 822cc58:	e0bffe15 	stw	r2,-8(fp)
 822cc5c:	00001906 	br	822ccc4 <pk_validate+0x214>
   {
      if (*(pkt->nb_buff - j) != 'M')
 822cc60:	e0bfff17 	ldw	r2,-4(fp)
 822cc64:	10c00117 	ldw	r3,4(r2)
 822cc68:	e0bffe17 	ldw	r2,-8(fp)
 822cc6c:	0085c83a 	sub	r2,zero,r2
 822cc70:	1885883a 	add	r2,r3,r2
 822cc74:	10800003 	ldbu	r2,0(r2)
 822cc78:	10803fcc 	andi	r2,r2,255
 822cc7c:	1080201c 	xori	r2,r2,128
 822cc80:	10bfe004 	addi	r2,r2,-128
 822cc84:	10801360 	cmpeqi	r2,r2,77
 822cc88:	10000b1e 	bne	r2,zero,822ccb8 <pk_validate+0x208>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 822cc8c:	822d76c0 	call	822d76c <irq_Mask>
 822cc90:	008209b4 	movhi	r2,2086
 822cc94:	10b88204 	addi	r2,r2,-7672
 822cc98:	10800117 	ldw	r2,4(r2)
 822cc9c:	10c00044 	addi	r3,r2,1
 822cca0:	008209b4 	movhi	r2,2086
 822cca4:	10b88204 	addi	r2,r2,-7672
 822cca8:	10c00115 	stw	r3,4(r2)
 822ccac:	822d7cc0 	call	822d7cc <irq_Unmask>
         return -1;
 822ccb0:	00bfffc4 	movi	r2,-1
 822ccb4:	00001c06 	br	822cd28 <pk_validate+0x278>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 822ccb8:	e0bffe17 	ldw	r2,-8(fp)
 822ccbc:	10bfffc4 	addi	r2,r2,-1
 822ccc0:	e0bffe15 	stw	r2,-8(fp)
 822ccc4:	e0bffe17 	ldw	r2,-8(fp)
 822ccc8:	00bfe516 	blt	zero,r2,822cc60 <pk_validate+0x1b0>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
         return -1;
      }
   }
   if (*(pkt->nb_buff + pkt->nb_blen) != 'M')
 822cccc:	e0bfff17 	ldw	r2,-4(fp)
 822ccd0:	10c00117 	ldw	r3,4(r2)
 822ccd4:	e0bfff17 	ldw	r2,-4(fp)
 822ccd8:	10800217 	ldw	r2,8(r2)
 822ccdc:	1885883a 	add	r2,r3,r2
 822cce0:	10800003 	ldbu	r2,0(r2)
 822cce4:	10803fcc 	andi	r2,r2,255
 822cce8:	1080201c 	xori	r2,r2,128
 822ccec:	10bfe004 	addi	r2,r2,-128
 822ccf0:	10801360 	cmpeqi	r2,r2,77
 822ccf4:	10000b1e 	bne	r2,zero,822cd24 <pk_validate+0x274>
   {
      INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 822ccf8:	822d76c0 	call	822d76c <irq_Mask>
 822ccfc:	008209b4 	movhi	r2,2086
 822cd00:	10b88204 	addi	r2,r2,-7672
 822cd04:	10800117 	ldw	r2,4(r2)
 822cd08:	10c00044 	addi	r3,r2,1
 822cd0c:	008209b4 	movhi	r2,2086
 822cd10:	10b88204 	addi	r2,r2,-7672
 822cd14:	10c00115 	stw	r3,4(r2)
 822cd18:	822d7cc0 	call	822d7cc <irq_Unmask>
      return -1;
 822cd1c:	00bfffc4 	movi	r2,-1
 822cd20:	00000106 	br	822cd28 <pk_validate+0x278>
   }
#endif /* NPDEBUG */

   return 0;
 822cd24:	0005883a 	mov	r2,zero
}
 822cd28:	e037883a 	mov	sp,fp
 822cd2c:	dfc00117 	ldw	ra,4(sp)
 822cd30:	df000017 	ldw	fp,0(sp)
 822cd34:	dec00204 	addi	sp,sp,8
 822cd38:	f800283a 	ret

0822cd3c <pk_free>:
 *
 * OUTPUT: None.
 */

void pk_free(PACKET pkt)   /* PACKET to place in free queue */
{
 822cd3c:	defffc04 	addi	sp,sp,-16
 822cd40:	dfc00315 	stw	ra,12(sp)
 822cd44:	df000215 	stw	fp,8(sp)
 822cd48:	df000204 	addi	fp,sp,8
 822cd4c:	e13fff15 	stw	r4,-4(fp)
      PACKET pknext;
      pknext = pkt->pk_next;
#endif /* LINKED_PKTS */

      /* validate the pkt before freeing */
      e = pk_validate(pkt);
 822cd50:	e13fff17 	ldw	r4,-4(fp)
 822cd54:	822cab00 	call	822cab0 <pk_validate>
 822cd58:	e0bffe15 	stw	r2,-8(fp)
      if (e)
 822cd5c:	e0bffe17 	ldw	r2,-8(fp)
 822cd60:	1000191e 	bne	r2,zero,822cdc8 <pk_free+0x8c>
            continue; /* skip this pkt, examine the next pkt */
         }
#endif
         return;
      }
      if (pkt->inuse-- > 1)   /* more than 1 owner? */
 822cd64:	e0bfff17 	ldw	r2,-4(fp)
 822cd68:	10800917 	ldw	r2,36(r2)
 822cd6c:	113fffc4 	addi	r4,r2,-1
 822cd70:	e0ffff17 	ldw	r3,-4(fp)
 822cd74:	19000915 	stw	r4,36(r3)
 822cd78:	108000b0 	cmpltui	r2,r2,2
 822cd7c:	10001426 	beq	r2,zero,822cdd0 <pk_free+0x94>
         pk_free_heapbuf (pkt);
      }
      else 
#endif /* HEAPBUFS */
      {
         if (pkt->nb_blen == bigbufsiz)
 822cd80:	e0bfff17 	ldw	r2,-4(fp)
 822cd84:	10c00217 	ldw	r3,8(r2)
 822cd88:	d0a03917 	ldw	r2,-32540(gp)
 822cd8c:	1880051e 	bne	r3,r2,822cda4 <pk_free+0x68>
            q_add(&bigfreeq, (qp)pkt);
 822cd90:	e17fff17 	ldw	r5,-4(fp)
 822cd94:	010209b4 	movhi	r4,2086
 822cd98:	2138c204 	addi	r4,r4,-7416
 822cd9c:	822cf7c0 	call	822cf7c <putq>
 822cda0:	00000c06 	br	822cdd4 <pk_free+0x98>
         else if (pkt->nb_blen == lilbufsiz)
 822cda4:	e0bfff17 	ldw	r2,-4(fp)
 822cda8:	10c00217 	ldw	r3,8(r2)
 822cdac:	d0a03717 	ldw	r2,-32548(gp)
 822cdb0:	1880081e 	bne	r3,r2,822cdd4 <pk_free+0x98>
            q_add(&lilfreeq, (qp)pkt);
 822cdb4:	e17fff17 	ldw	r5,-4(fp)
 822cdb8:	010209b4 	movhi	r4,2086
 822cdbc:	21387d04 	addi	r4,r4,-7692
 822cdc0:	822cf7c0 	call	822cf7c <putq>
 822cdc4:	00000306 	br	822cdd4 <pk_free+0x98>
         {
            pkt = pknext;
            continue; /* skip this pkt, examine the next pkt */
         }
#endif
         return;
 822cdc8:	0001883a 	nop
 822cdcc:	00000106 	br	822cdd4 <pk_free+0x98>
      }
      if (pkt->inuse-- > 1)   /* more than 1 owner? */
         return;  /* packet was cloned, don't delete yet */
 822cdd0:	0001883a 	nop
#ifdef LINKED_PKTS
      pkt = pknext;
   }
#endif 

}
 822cdd4:	e037883a 	mov	sp,fp
 822cdd8:	dfc00117 	ldw	ra,4(sp)
 822cddc:	df000017 	ldw	fp,0(sp)
 822cde0:	dec00204 	addi	sp,sp,8
 822cde4:	f800283a 	ret

0822cde8 <pk_get_max_intrsafe_buf_len>:
 *
 * OUTPUT: This function always returns the length of a big buffer (bigbufsiz).
 */

unsigned pk_get_max_intrsafe_buf_len(void)
{
 822cde8:	deffff04 	addi	sp,sp,-4
 822cdec:	df000015 	stw	fp,0(sp)
 822cdf0:	d839883a 	mov	fp,sp
   return bigbufsiz;
 822cdf4:	d0a03917 	ldw	r2,-32540(gp)
}
 822cdf8:	e037883a 	mov	sp,fp
 822cdfc:	df000017 	ldw	fp,0(sp)
 822ce00:	dec00104 	addi	sp,sp,4
 822ce04:	f800283a 	ret

0822ce08 <dump_buf_estats>:
 *
 * OUTPUT: This function always returns 0.
 */

int dump_buf_estats (void * pio)
{
 822ce08:	defff904 	addi	sp,sp,-28
 822ce0c:	dfc00615 	stw	ra,24(sp)
 822ce10:	df000515 	stw	fp,20(sp)
 822ce14:	df000504 	addi	fp,sp,20
 822ce18:	e13fff15 	stw	r4,-4(fp)
   u_long mlocal [MEMERR_NUM_STATS];

   LOCK_NET_RESOURCE(FREEQ_RESID);
 822ce1c:	01000084 	movi	r4,2
 822ce20:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   ENTER_CRIT_SECTION(&memestats);
 822ce24:	822d76c0 	call	822d76c <irq_Mask>
   MEMCPY (&mlocal, &memestats, sizeof(memestats));
 822ce28:	008209b4 	movhi	r2,2086
 822ce2c:	10b88204 	addi	r2,r2,-7672
 822ce30:	10c00017 	ldw	r3,0(r2)
 822ce34:	e0fffb15 	stw	r3,-20(fp)
 822ce38:	10c00117 	ldw	r3,4(r2)
 822ce3c:	e0fffc15 	stw	r3,-16(fp)
 822ce40:	10c00217 	ldw	r3,8(r2)
 822ce44:	e0fffd15 	stw	r3,-12(fp)
 822ce48:	10800317 	ldw	r2,12(r2)
 822ce4c:	e0bffe15 	stw	r2,-8(fp)
   EXIT_CRIT_SECTION(&memestats);
 822ce50:	822d7cc0 	call	822d7cc <irq_Unmask>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822ce54:	01000084 	movi	r4,2
 822ce58:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>

   ns_printf(pio, "Regular buffer error statistics:\n");
 822ce5c:	01420974 	movhi	r5,2085
 822ce60:	29423f04 	addi	r5,r5,2300
 822ce64:	e13fff17 	ldw	r4,-4(fp)
 822ce68:	8228e600 	call	8228e60 <ns_printf>
   ns_printf(pio, "Bad buffer length %lu, Guard band violations %lu\n",mlocal[BAD_REGULAR_BUF_LEN_ERR],mlocal[GUARD_BAND_VIOLATED_ERR]);
 822ce6c:	e0bffb17 	ldw	r2,-20(fp)
 822ce70:	e0fffc17 	ldw	r3,-16(fp)
 822ce74:	180f883a 	mov	r7,r3
 822ce78:	100d883a 	mov	r6,r2
 822ce7c:	01420974 	movhi	r5,2085
 822ce80:	29424804 	addi	r5,r5,2336
 822ce84:	e13fff17 	ldw	r4,-4(fp)
 822ce88:	8228e600 	call	8228e60 <ns_printf>
   ns_printf(pio, "Multiple frees %lu, Inconsistent location %lu\n",mlocal[MULTIPLE_FREE_ERR],mlocal[INCONSISTENT_LOCATION_ERR]);
 822ce8c:	e0bffd17 	ldw	r2,-12(fp)
 822ce90:	e0fffe17 	ldw	r3,-8(fp)
 822ce94:	180f883a 	mov	r7,r3
 822ce98:	100d883a 	mov	r6,r2
 822ce9c:	01420974 	movhi	r5,2085
 822cea0:	29425504 	addi	r5,r5,2388
 822cea4:	e13fff17 	ldw	r4,-4(fp)
 822cea8:	8228e600 	call	8228e60 <ns_printf>

   return 0;
 822ceac:	0005883a 	mov	r2,zero
}
 822ceb0:	e037883a 	mov	sp,fp
 822ceb4:	dfc00117 	ldw	ra,4(sp)
 822ceb8:	df000017 	ldw	fp,0(sp)
 822cebc:	dec00204 	addi	sp,sp,8
 822cec0:	f800283a 	ret

0822cec4 <getq>:
 * RETURNS: pointer to the first element if any, or 0 if the queue is empty.
 */

void*
getq(queue * q)
{
 822cec4:	defffc04 	addi	sp,sp,-16
 822cec8:	dfc00315 	stw	ra,12(sp)
 822cecc:	df000215 	stw	fp,8(sp)
 822ced0:	df000204 	addi	fp,sp,8
 822ced4:	e13fff15 	stw	r4,-4(fp)
   q_elt   temp;        /* temp for result */


   ENTER_CRIT_SECTION(q);     /* shut off ints, save old state */   
 822ced8:	822d76c0 	call	822d76c <irq_Mask>

   LOCKNET_CHECK(q);          /* make sure queue is protected */

   if ((temp = q->q_head) == 0)  /* queue empty? */
 822cedc:	e0bfff17 	ldw	r2,-4(fp)
 822cee0:	10800017 	ldw	r2,0(r2)
 822cee4:	e0bffe15 	stw	r2,-8(fp)
 822cee8:	e0bffe17 	ldw	r2,-8(fp)
 822ceec:	1000031e 	bne	r2,zero,822cefc <getq+0x38>
   {
      EXIT_CRIT_SECTION(q);
 822cef0:	822d7cc0 	call	822d7cc <irq_Unmask>
      return (0);             /* yes, show none */
 822cef4:	0005883a 	mov	r2,zero
 822cef8:	00001b06 	br	822cf68 <getq+0xa4>
   }

   q->q_head = temp->qe_next; /* else unlink */
 822cefc:	e0bffe17 	ldw	r2,-8(fp)
 822cf00:	10c00017 	ldw	r3,0(r2)
 822cf04:	e0bfff17 	ldw	r2,-4(fp)
 822cf08:	10c00015 	stw	r3,0(r2)
   temp->qe_next = 0;         /* avoid dangling pointers */
 822cf0c:	e0bffe17 	ldw	r2,-8(fp)
 822cf10:	10000015 	stw	zero,0(r2)
   if (q->q_head == 0)        /* queue empty? */
 822cf14:	e0bfff17 	ldw	r2,-4(fp)
 822cf18:	10800017 	ldw	r2,0(r2)
 822cf1c:	1000021e 	bne	r2,zero,822cf28 <getq+0x64>
      q->q_tail = 0;          /* yes, update tail pointer too */
 822cf20:	e0bfff17 	ldw	r2,-4(fp)
 822cf24:	10000115 	stw	zero,4(r2)
   q->q_len--;                /* update queue length */
 822cf28:	e0bfff17 	ldw	r2,-4(fp)
 822cf2c:	10800217 	ldw	r2,8(r2)
 822cf30:	10ffffc4 	addi	r3,r2,-1
 822cf34:	e0bfff17 	ldw	r2,-4(fp)
 822cf38:	10c00215 	stw	r3,8(r2)
   if (q->q_len < q->q_min)
 822cf3c:	e0bfff17 	ldw	r2,-4(fp)
 822cf40:	10c00217 	ldw	r3,8(r2)
 822cf44:	e0bfff17 	ldw	r2,-4(fp)
 822cf48:	10800417 	ldw	r2,16(r2)
 822cf4c:	1880040e 	bge	r3,r2,822cf60 <getq+0x9c>
      q->q_min = q->q_len;
 822cf50:	e0bfff17 	ldw	r2,-4(fp)
 822cf54:	10c00217 	ldw	r3,8(r2)
 822cf58:	e0bfff17 	ldw	r2,-4(fp)
 822cf5c:	10c00415 	stw	r3,16(r2)

   QUEUE_CHECK(q);         /* make sure queue is not corrupted */

   EXIT_CRIT_SECTION(q);   /* restore caller's int state */
 822cf60:	822d7cc0 	call	822d7cc <irq_Unmask>

   return ((void*)temp);
 822cf64:	e0bffe17 	ldw	r2,-8(fp)
}
 822cf68:	e037883a 	mov	sp,fp
 822cf6c:	dfc00117 	ldw	ra,4(sp)
 822cf70:	df000017 	ldw	fp,0(sp)
 822cf74:	dec00204 	addi	sp,sp,8
 822cf78:	f800283a 	ret

0822cf7c <putq>:

void
putq(
   queue   *   q,       /* the queue */
   void *   elt)        /* element to delete */
{
 822cf7c:	defffc04 	addi	sp,sp,-16
 822cf80:	dfc00315 	stw	ra,12(sp)
 822cf84:	df000215 	stw	fp,8(sp)
 822cf88:	df000204 	addi	fp,sp,8
 822cf8c:	e13ffe15 	stw	r4,-8(fp)
 822cf90:	e17fff15 	stw	r5,-4(fp)
   ENTER_CRIT_SECTION(q);
 822cf94:	822d76c0 	call	822d76c <irq_Mask>
   LOCKNET_CHECK(q);       /* make sure queue is protected */
   q_addt(q, (qp)elt);     /* use macro to do work */
 822cf98:	e0bfff17 	ldw	r2,-4(fp)
 822cf9c:	10000015 	stw	zero,0(r2)
 822cfa0:	e0bffe17 	ldw	r2,-8(fp)
 822cfa4:	10800017 	ldw	r2,0(r2)
 822cfa8:	1000041e 	bne	r2,zero,822cfbc <putq+0x40>
 822cfac:	e0bffe17 	ldw	r2,-8(fp)
 822cfb0:	e0ffff17 	ldw	r3,-4(fp)
 822cfb4:	10c00015 	stw	r3,0(r2)
 822cfb8:	00000406 	br	822cfcc <putq+0x50>
 822cfbc:	e0bffe17 	ldw	r2,-8(fp)
 822cfc0:	10800117 	ldw	r2,4(r2)
 822cfc4:	e0ffff17 	ldw	r3,-4(fp)
 822cfc8:	10c00015 	stw	r3,0(r2)
 822cfcc:	e0bffe17 	ldw	r2,-8(fp)
 822cfd0:	e0ffff17 	ldw	r3,-4(fp)
 822cfd4:	10c00115 	stw	r3,4(r2)
 822cfd8:	e0bffe17 	ldw	r2,-8(fp)
 822cfdc:	10800217 	ldw	r2,8(r2)
 822cfe0:	10c00044 	addi	r3,r2,1
 822cfe4:	e0bffe17 	ldw	r2,-8(fp)
 822cfe8:	10c00215 	stw	r3,8(r2)
 822cfec:	e0bffe17 	ldw	r2,-8(fp)
 822cff0:	10800217 	ldw	r2,8(r2)
 822cff4:	e0fffe17 	ldw	r3,-8(fp)
 822cff8:	18c00317 	ldw	r3,12(r3)
 822cffc:	1880040e 	bge	r3,r2,822d010 <putq+0x94>
 822d000:	e0bffe17 	ldw	r2,-8(fp)
 822d004:	10c00217 	ldw	r3,8(r2)
 822d008:	e0bffe17 	ldw	r2,-8(fp)
 822d00c:	10c00315 	stw	r3,12(r2)
   QUEUE_CHECK(q);         /* make sure queue is not corrupted */
   EXIT_CRIT_SECTION(q);   /* restore int state */
 822d010:	822d7cc0 	call	822d7cc <irq_Unmask>
}
 822d014:	0001883a 	nop
 822d018:	e037883a 	mov	sp,fp
 822d01c:	dfc00117 	ldw	ra,4(sp)
 822d020:	df000017 	ldw	fp,0(sp)
 822d024:	dec00204 	addi	sp,sp,8
 822d028:	f800283a 	ret

0822d02c <qdel>:
 * RETURNS: Return pointer to queue member if found, else NULL. 
 */

qp
qdel(queue * q, void * elt)
{
 822d02c:	defffa04 	addi	sp,sp,-24
 822d030:	dfc00515 	stw	ra,20(sp)
 822d034:	df000415 	stw	fp,16(sp)
 822d038:	df000404 	addi	fp,sp,16
 822d03c:	e13ffe15 	stw	r4,-8(fp)
 822d040:	e17fff15 	stw	r5,-4(fp)
   qp qptr;
   qp qlast;

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
 822d044:	822d76c0 	call	822d76c <irq_Mask>
   qptr = q->q_head;
 822d048:	e0bffe17 	ldw	r2,-8(fp)
 822d04c:	10800017 	ldw	r2,0(r2)
 822d050:	e0bffc15 	stw	r2,-16(fp)
   qlast = NULL;
 822d054:	e03ffd15 	stw	zero,-12(fp)
   while (qptr)
 822d058:	00002b06 	br	822d108 <qdel+0xdc>
   {
      if (qptr == (qp)elt)
 822d05c:	e0fffc17 	ldw	r3,-16(fp)
 822d060:	e0bfff17 	ldw	r2,-4(fp)
 822d064:	1880231e 	bne	r3,r2,822d0f4 <qdel+0xc8>
      {
         /* found our item; dequeue it */
         if (qlast)
 822d068:	e0bffd17 	ldw	r2,-12(fp)
 822d06c:	10000526 	beq	r2,zero,822d084 <qdel+0x58>
            qlast->qe_next = qptr->qe_next;
 822d070:	e0bffc17 	ldw	r2,-16(fp)
 822d074:	10c00017 	ldw	r3,0(r2)
 822d078:	e0bffd17 	ldw	r2,-12(fp)
 822d07c:	10c00015 	stw	r3,0(r2)
 822d080:	00000406 	br	822d094 <qdel+0x68>
         else     /* item was at head of queqe */
            q->q_head = qptr->qe_next;
 822d084:	e0bffc17 	ldw	r2,-16(fp)
 822d088:	10c00017 	ldw	r3,0(r2)
 822d08c:	e0bffe17 	ldw	r2,-8(fp)
 822d090:	10c00015 	stw	r3,0(r2)

         /* fix queue tail pointer if needed */
         if (q->q_tail == (qp)elt)
 822d094:	e0bffe17 	ldw	r2,-8(fp)
 822d098:	10c00117 	ldw	r3,4(r2)
 822d09c:	e0bfff17 	ldw	r2,-4(fp)
 822d0a0:	1880031e 	bne	r3,r2,822d0b0 <qdel+0x84>
            q->q_tail = qlast;
 822d0a4:	e0bffe17 	ldw	r2,-8(fp)
 822d0a8:	e0fffd17 	ldw	r3,-12(fp)
 822d0ac:	10c00115 	stw	r3,4(r2)

         /* fix queue counters */
         q->q_len--;
 822d0b0:	e0bffe17 	ldw	r2,-8(fp)
 822d0b4:	10800217 	ldw	r2,8(r2)
 822d0b8:	10ffffc4 	addi	r3,r2,-1
 822d0bc:	e0bffe17 	ldw	r2,-8(fp)
 822d0c0:	10c00215 	stw	r3,8(r2)
         if (q->q_len < q->q_min)
 822d0c4:	e0bffe17 	ldw	r2,-8(fp)
 822d0c8:	10c00217 	ldw	r3,8(r2)
 822d0cc:	e0bffe17 	ldw	r2,-8(fp)
 822d0d0:	10800417 	ldw	r2,16(r2)
 822d0d4:	1880040e 	bge	r3,r2,822d0e8 <qdel+0xbc>
            q->q_min = q->q_len;
 822d0d8:	e0bffe17 	ldw	r2,-8(fp)
 822d0dc:	10c00217 	ldw	r3,8(r2)
 822d0e0:	e0bffe17 	ldw	r2,-8(fp)
 822d0e4:	10c00415 	stw	r3,16(r2)
         EXIT_CRIT_SECTION(q);   /* restore int state */
 822d0e8:	822d7cc0 	call	822d7cc <irq_Unmask>
         return (qp)elt;   /* success exit point */
 822d0ec:	e0bfff17 	ldw	r2,-4(fp)
 822d0f0:	00000906 	br	822d118 <qdel+0xec>
      }
      qlast = qptr;
 822d0f4:	e0bffc17 	ldw	r2,-16(fp)
 822d0f8:	e0bffd15 	stw	r2,-12(fp)
      qptr = qptr->qe_next;
 822d0fc:	e0bffc17 	ldw	r2,-16(fp)
 822d100:	10800017 	ldw	r2,0(r2)
 822d104:	e0bffc15 	stw	r2,-16(fp)

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
   qptr = q->q_head;
   qlast = NULL;
   while (qptr)
 822d108:	e0bffc17 	ldw	r2,-16(fp)
 822d10c:	103fd31e 	bne	r2,zero,822d05c <qdel+0x30>
         return (qp)elt;   /* success exit point */
      }
      qlast = qptr;
      qptr = qptr->qe_next;
   }
   EXIT_CRIT_SECTION(q);   /* restore int state */
 822d110:	822d7cc0 	call	822d7cc <irq_Unmask>
   return NULL;   /* item not found in queue */
 822d114:	0005883a 	mov	r2,zero
}
 822d118:	e037883a 	mov	sp,fp
 822d11c:	dfc00117 	ldw	ra,4(sp)
 822d120:	df000017 	ldw	fp,0(sp)
 822d124:	dec00204 	addi	sp,sp,8
 822d128:	f800283a 	ret

0822d12c <udp_open>:
   ip_addr  fhost,      /* foreign host, 0L for any */
   unshort  fsock,      /* foreign socket, 0 for any */
   unshort  lsock,      /* local socket */
   int (*handler)(PACKET, void*),   /* rcv upcall */
   void *   data)       /* random data, returned on upcalls to aid demuxing */
{
 822d12c:	defff404 	addi	sp,sp,-48
 822d130:	dfc00b15 	stw	ra,44(sp)
 822d134:	df000a15 	stw	fp,40(sp)
 822d138:	df000a04 	addi	fp,sp,40
 822d13c:	e13ffc15 	stw	r4,-16(fp)
 822d140:	2807883a 	mov	r3,r5
 822d144:	3005883a 	mov	r2,r6
 822d148:	e1ffff15 	stw	r7,-4(fp)
 822d14c:	e0fffd0d 	sth	r3,-12(fp)
 822d150:	e0bffe0d 	sth	r2,-8(fp)
/*
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
 822d154:	d0a08317 	ldw	r2,-32244(gp)
 822d158:	1080010c 	andi	r2,r2,4
 822d15c:	10001526 	beq	r2,zero,822d1b4 <udp_open+0x88>
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 822d160:	e0bffc17 	ldw	r2,-16(fp)
 822d164:	12003fcc 	andi	r8,r2,255
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
 822d168:	e0bffc17 	ldw	r2,-16(fp)
 822d16c:	1004d23a 	srli	r2,r2,8
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 822d170:	11803fcc 	andi	r6,r2,255
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
 822d174:	e0bffc17 	ldw	r2,-16(fp)
 822d178:	1004d43a 	srli	r2,r2,16
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 822d17c:	11c03fcc 	andi	r7,r2,255
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
 822d180:	e0bffc17 	ldw	r2,-16(fp)
 822d184:	1004d63a 	srli	r2,r2,24
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 822d188:	e0fffe0b 	ldhu	r3,-8(fp)
 822d18c:	e13ffd0b 	ldhu	r4,-12(fp)
 822d190:	e1400217 	ldw	r5,8(fp)
 822d194:	d9400315 	stw	r5,12(sp)
 822d198:	d9000215 	stw	r4,8(sp)
 822d19c:	d8c00115 	stw	r3,4(sp)
 822d1a0:	d8800015 	stw	r2,0(sp)
 822d1a4:	400b883a 	mov	r5,r8
 822d1a8:	01020974 	movhi	r4,2085
 822d1ac:	21026104 	addi	r4,r4,2436
 822d1b0:	82033a00 	call	82033a0 <printf>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 822d1b4:	0009883a 	mov	r4,zero
 822d1b8:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   ocon = NULL;
 822d1bc:	e03ffb15 	stw	zero,-20(fp)
   for (con = firstudp; con; con = con->u_next)
 822d1c0:	d0a09c17 	ldw	r2,-32144(gp)
 822d1c4:	e0bffa15 	stw	r2,-24(fp)
 822d1c8:	00002006 	br	822d24c <udp_open+0x120>
   {
      ocon = con;       /* remember last con in list */
 822d1cc:	e0bffa17 	ldw	r2,-24(fp)
 822d1d0:	e0bffb15 	stw	r2,-20(fp)
      /* we only want to check UDP-over-IPv4 connections */
      if (!(con->u_flags & UDPCF_V4))
         continue;
#endif

      if (con->u_lport == lsock && con->u_fport == fsock &&
 822d1d4:	e0bffa17 	ldw	r2,-24(fp)
 822d1d8:	1080018b 	ldhu	r2,6(r2)
 822d1dc:	10ffffcc 	andi	r3,r2,65535
 822d1e0:	e0bffe0b 	ldhu	r2,-8(fp)
 822d1e4:	1880161e 	bne	r3,r2,822d240 <udp_open+0x114>
 822d1e8:	e0bffa17 	ldw	r2,-24(fp)
 822d1ec:	1080020b 	ldhu	r2,8(r2)
 822d1f0:	10ffffcc 	andi	r3,r2,65535
 822d1f4:	e0bffd0b 	ldhu	r2,-12(fp)
 822d1f8:	1880111e 	bne	r3,r2,822d240 <udp_open+0x114>
          con->u_lhost == 0 && con->u_fhost == fhost)
 822d1fc:	e0bffa17 	ldw	r2,-24(fp)
 822d200:	10800317 	ldw	r2,12(r2)
      /* we only want to check UDP-over-IPv4 connections */
      if (!(con->u_flags & UDPCF_V4))
         continue;
#endif

      if (con->u_lport == lsock && con->u_fport == fsock &&
 822d204:	10000e1e 	bne	r2,zero,822d240 <udp_open+0x114>
          con->u_lhost == 0 && con->u_fhost == fhost)
 822d208:	e0bffa17 	ldw	r2,-24(fp)
 822d20c:	10c00417 	ldw	r3,16(r2)
 822d210:	e0bffc17 	ldw	r2,-16(fp)
 822d214:	18800a1e 	bne	r3,r2,822d240 <udp_open+0x114>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (INFOMSG|PROTERR))
 822d218:	d0a08317 	ldw	r2,-32244(gp)
 822d21c:	1080050c 	andi	r2,r2,20
 822d220:	10000326 	beq	r2,zero,822d230 <udp_open+0x104>
            dprintf("UDP: Connection already exists.\n");
 822d224:	01020974 	movhi	r4,2085
 822d228:	21027004 	addi	r4,r4,2496
 822d22c:	82036240 	call	8203624 <puts>
#endif
         UNLOCK_NET_RESOURCE(NET_RESID);
 822d230:	0009883a 	mov	r4,zero
 822d234:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         return(NULL);
 822d238:	0005883a 	mov	r2,zero
 822d23c:	00003506 	br	822d314 <udp_open+0x1e8>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
   ocon = NULL;
   for (con = firstudp; con; con = con->u_next)
 822d240:	e0bffa17 	ldw	r2,-24(fp)
 822d244:	10800017 	ldw	r2,0(r2)
 822d248:	e0bffa15 	stw	r2,-24(fp)
 822d24c:	e0bffa17 	ldw	r2,-24(fp)
 822d250:	103fde1e 	bne	r2,zero,822d1cc <udp_open+0xa0>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return(NULL);
      }
   }

   con = (UDPCONN)UC_ALLOC(sizeof(struct udp_conn));
 822d254:	01000804 	movi	r4,32
 822d258:	822e16c0 	call	822e16c <npalloc>
 822d25c:	e0bffa15 	stw	r2,-24(fp)
   if (con == 0)
 822d260:	e0bffa17 	ldw	r2,-24(fp)
 822d264:	10000a1e 	bne	r2,zero,822d290 <udp_open+0x164>
   {
#ifdef   NPDEBUG
      if (NDEBUG & INFOMSG)
 822d268:	d0a08317 	ldw	r2,-32244(gp)
 822d26c:	1080010c 	andi	r2,r2,4
 822d270:	10000326 	beq	r2,zero,822d280 <udp_open+0x154>
         dprintf("UDP: Couldn't allocate conn storage.\n");
 822d274:	01020974 	movhi	r4,2085
 822d278:	21027804 	addi	r4,r4,2528
 822d27c:	82036240 	call	8203624 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 822d280:	0009883a 	mov	r4,zero
 822d284:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return(NULL);
 822d288:	0005883a 	mov	r2,zero
 822d28c:	00002106 	br	822d314 <udp_open+0x1e8>
   }

   if (ocon)   /* ocon is end of list */
 822d290:	e0bffb17 	ldw	r2,-20(fp)
 822d294:	10000426 	beq	r2,zero,822d2a8 <udp_open+0x17c>
      ocon->u_next = con;  /* add new connection to end */
 822d298:	e0bffb17 	ldw	r2,-20(fp)
 822d29c:	e0fffa17 	ldw	r3,-24(fp)
 822d2a0:	10c00015 	stw	r3,0(r2)
 822d2a4:	00000206 	br	822d2b0 <udp_open+0x184>
   else  /* no list, start one */
      firstudp = con;
 822d2a8:	e0bffa17 	ldw	r2,-24(fp)
 822d2ac:	d0a09c15 	stw	r2,-32144(gp)

   con->u_next = 0;
 822d2b0:	e0bffa17 	ldw	r2,-24(fp)
 822d2b4:	10000015 	stw	zero,0(r2)

   con->u_lport = lsock;      /* fill in connection info */
 822d2b8:	e0bffa17 	ldw	r2,-24(fp)
 822d2bc:	e0fffe0b 	ldhu	r3,-8(fp)
 822d2c0:	10c0018d 	sth	r3,6(r2)
   con->u_fport = fsock;
 822d2c4:	e0bffa17 	ldw	r2,-24(fp)
 822d2c8:	e0fffd0b 	ldhu	r3,-12(fp)
 822d2cc:	10c0020d 	sth	r3,8(r2)
   con->u_lhost = 0;
 822d2d0:	e0bffa17 	ldw	r2,-24(fp)
 822d2d4:	10000315 	stw	zero,12(r2)
   con->u_fhost = fhost;
 822d2d8:	e0bffa17 	ldw	r2,-24(fp)
 822d2dc:	e0fffc17 	ldw	r3,-16(fp)
 822d2e0:	10c00415 	stw	r3,16(r2)
   con->u_rcv   = handler;
 822d2e4:	e0bffa17 	ldw	r2,-24(fp)
 822d2e8:	e0ffff17 	ldw	r3,-4(fp)
 822d2ec:	10c00515 	stw	r3,20(r2)
   con->u_data  = data;
 822d2f0:	e0bffa17 	ldw	r2,-24(fp)
 822d2f4:	e0c00217 	ldw	r3,8(fp)
 822d2f8:	10c00615 	stw	r3,24(r2)
   con->u_flags = UDPCF_V4;
 822d2fc:	e0bffa17 	ldw	r2,-24(fp)
 822d300:	00c00044 	movi	r3,1
 822d304:	10c0010d 	sth	r3,4(r2)

   UNLOCK_NET_RESOURCE(NET_RESID);
 822d308:	0009883a 	mov	r4,zero
 822d30c:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   return(con);
 822d310:	e0bffa17 	ldw	r2,-24(fp)
}
 822d314:	e037883a 	mov	sp,fp
 822d318:	dfc00117 	ldw	ra,4(sp)
 822d31c:	df000017 	ldw	fp,0(sp)
 822d320:	dec00204 	addi	sp,sp,8
 822d324:	f800283a 	ret

0822d328 <udp_close>:
 * RETURNS: void
 */

void
udp_close(UDPCONN con)
{
 822d328:	defffb04 	addi	sp,sp,-20
 822d32c:	dfc00415 	stw	ra,16(sp)
 822d330:	df000315 	stw	fp,12(sp)
 822d334:	df000304 	addi	fp,sp,12
 822d338:	e13fff15 	stw	r4,-4(fp)
   UDPCONN pcon;
   UDPCONN lcon;

#ifdef NPDEBUG
   if ((con == NULL) || (firstudp == NULL))
 822d33c:	e0bfff17 	ldw	r2,-4(fp)
 822d340:	10000226 	beq	r2,zero,822d34c <udp_close+0x24>
 822d344:	d0a09c17 	ldw	r2,-32144(gp)
 822d348:	1000021e 	bne	r2,zero,822d354 <udp_close+0x2c>
   {
      dtrap(); /* bad programming! */
 822d34c:	822d5940 	call	822d594 <dtrap>
      return;
 822d350:	00002606 	br	822d3ec <udp_close+0xc4>
   }
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 822d354:	0009883a 	mov	r4,zero
 822d358:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
 822d35c:	e03ffe15 	stw	zero,-8(fp)
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 822d360:	d0a09c17 	ldw	r2,-32144(gp)
 822d364:	e0bffd15 	stw	r2,-12(fp)
 822d368:	00000806 	br	822d38c <udp_close+0x64>
   {
      if (pcon == con)  /* found connection to delete */
 822d36c:	e0fffd17 	ldw	r3,-12(fp)
 822d370:	e0bfff17 	ldw	r2,-4(fp)
 822d374:	18800826 	beq	r3,r2,822d398 <udp_close+0x70>
      break;
      lcon = pcon;   /* remember last connection */
 822d378:	e0bffd17 	ldw	r2,-12(fp)
 822d37c:	e0bffe15 	stw	r2,-8(fp)
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 822d380:	e0bffd17 	ldw	r2,-12(fp)
 822d384:	10800017 	ldw	r2,0(r2)
 822d388:	e0bffd15 	stw	r2,-12(fp)
 822d38c:	e0bffd17 	ldw	r2,-12(fp)
 822d390:	103ff61e 	bne	r2,zero,822d36c <udp_close+0x44>
 822d394:	00000106 	br	822d39c <udp_close+0x74>
   {
      if (pcon == con)  /* found connection to delete */
      break;
 822d398:	0001883a 	nop
      lcon = pcon;   /* remember last connection */
   }

   if (!pcon)
 822d39c:	e0bffd17 	ldw	r2,-12(fp)
 822d3a0:	1000041e 	bne	r2,zero,822d3b4 <udp_close+0x8c>
   {
      dtrap(); /* prog error - connenction not in list */
 822d3a4:	822d5940 	call	822d594 <dtrap>
      UNLOCK_NET_RESOURCE(NET_RESID);
 822d3a8:	0009883a 	mov	r4,zero
 822d3ac:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return;
 822d3b0:	00000e06 	br	822d3ec <udp_close+0xc4>
   }

   if (lcon)   /* in con is not head of list */
 822d3b4:	e0bffe17 	ldw	r2,-8(fp)
 822d3b8:	10000526 	beq	r2,zero,822d3d0 <udp_close+0xa8>
      lcon->u_next = con->u_next;   /* unlink */
 822d3bc:	e0bfff17 	ldw	r2,-4(fp)
 822d3c0:	10c00017 	ldw	r3,0(r2)
 822d3c4:	e0bffe17 	ldw	r2,-8(fp)
 822d3c8:	10c00015 	stw	r3,0(r2)
 822d3cc:	00000306 	br	822d3dc <udp_close+0xb4>
   else
      firstudp = con->u_next; /* remove from head */
 822d3d0:	e0bfff17 	ldw	r2,-4(fp)
 822d3d4:	10800017 	ldw	r2,0(r2)
 822d3d8:	d0a09c15 	stw	r2,-32144(gp)

   UC_FREE(con);  /* free memory for structure */
 822d3dc:	e13fff17 	ldw	r4,-4(fp)
 822d3e0:	822e1a00 	call	822e1a0 <npfree>
   UNLOCK_NET_RESOURCE(NET_RESID);
 822d3e4:	0009883a 	mov	r4,zero
 822d3e8:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
}
 822d3ec:	e037883a 	mov	sp,fp
 822d3f0:	dfc00117 	ldw	ra,4(sp)
 822d3f4:	df000017 	ldw	fp,0(sp)
 822d3f8:	dec00204 	addi	sp,sp,8
 822d3fc:	f800283a 	ret

0822d400 <asm_cksum>:
      .text

      .global	  asm_cksum

asm_cksum:
      mov   r2, zero		       /* accumulator = 0 */
 822d400:	0005883a 	mov	r2,zero
      ble   r5, zero, done	       /* count <= 0 ? */
 822d404:	0140620e 	bge	zero,r5,822d590 <done>

      mov   r6, zero		       /* carry accumulator */
 822d408:	000d883a 	mov	r6,zero

      andi  r3, r4, 2		       /* ptr 32-bit aligned? */
 822d40c:	20c0008c 	andi	r3,r4,2
      beq   r3, zero, asm1
 822d410:	18000326 	beq	r3,zero,822d420 <asm1>
      ldhu  r2, (r4)		       /* no - process first 16-bits */
 822d414:	2080000b 	ldhu	r2,0(r4)
      addi  r4, r4, 2
 822d418:	21000084 	addi	r4,r4,2
      subi  r5, r5, 1
 822d41c:	297fffc4 	addi	r5,r5,-1

0822d420 <asm1>:
 822d420:	02c208f4 	movhi	r11,2083
/*
 * adjust ptr by ((count/2) mod 16) * 4 bytes
 * jump to location: loop0 - (count/2 mod 16) * 4 instructions
 */
asm1:
      movia r11, loop0
 822d424:	5af55304 	addi	r11,r11,-10932
      andi  r9, r5, 1		       /* r9 = last halfword flag */
 822d428:	2a40004c 	andi	r9,r5,1
      srai  r5, r5, 1		       /* count = number of words */
 822d42c:	280bd07a 	srai	r5,r5,1
      andi  r10, r5, 0xf	       /* modulo 16 */
 822d430:	2a8003cc 	andi	r10,r5,15
      slli  r10, r10, 2		       /*      * 4 bytes per word */
 822d434:	501490ba 	slli	r10,r10,2
      add   r4, r10, r4		       /* adjust ptr */
 822d438:	5109883a 	add	r4,r10,r4
      slli  r10, r10, 2		       /*      * 4 instructions per 4 bytes */
 822d43c:	501490ba 	slli	r10,r10,2
      sub   r11, r11, r10
 822d440:	5a97c83a 	sub	r11,r11,r10
      jmp   r11
 822d444:	5800683a 	jmp	r11

0822d448 <loop>:
      
loop:
      addi  r4, r4, 64		       /* increment data pointer */
 822d448:	21001004 	addi	r4,r4,64

      ldw   r7, -64(r4)
 822d44c:	21fff017 	ldw	r7,-64(r4)
      add   r2, r7, r2
 822d450:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d454:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d458:	418d883a 	add	r6,r8,r6

      ldw   r7, -60(r4)
 822d45c:	21fff117 	ldw	r7,-60(r4)
      add   r2, r7, r2
 822d460:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d464:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d468:	418d883a 	add	r6,r8,r6

      ldw   r7, -56(r4)
 822d46c:	21fff217 	ldw	r7,-56(r4)
      add   r2, r7, r2
 822d470:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d474:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d478:	418d883a 	add	r6,r8,r6

      ldw   r7, -52(r4)
 822d47c:	21fff317 	ldw	r7,-52(r4)
      add   r2, r7, r2
 822d480:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d484:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d488:	418d883a 	add	r6,r8,r6

      ldw   r7, -48(r4)
 822d48c:	21fff417 	ldw	r7,-48(r4)
      add   r2, r7, r2
 822d490:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d494:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d498:	418d883a 	add	r6,r8,r6

      ldw   r7, -44(r4)
 822d49c:	21fff517 	ldw	r7,-44(r4)
      add   r2, r7, r2
 822d4a0:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d4a4:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d4a8:	418d883a 	add	r6,r8,r6

      ldw   r7, -40(r4)
 822d4ac:	21fff617 	ldw	r7,-40(r4)
      add   r2, r7, r2
 822d4b0:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d4b4:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d4b8:	418d883a 	add	r6,r8,r6

      ldw   r7, -36(r4)
 822d4bc:	21fff717 	ldw	r7,-36(r4)
      add   r2, r7, r2
 822d4c0:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d4c4:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d4c8:	418d883a 	add	r6,r8,r6

      ldw   r7, -32(r4)
 822d4cc:	21fff817 	ldw	r7,-32(r4)
      add   r2, r7, r2
 822d4d0:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d4d4:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d4d8:	418d883a 	add	r6,r8,r6

      ldw   r7, -28(r4)
 822d4dc:	21fff917 	ldw	r7,-28(r4)
      add   r2, r7, r2
 822d4e0:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d4e4:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d4e8:	418d883a 	add	r6,r8,r6

      ldw   r7, -24(r4)
 822d4ec:	21fffa17 	ldw	r7,-24(r4)
      add   r2, r7, r2
 822d4f0:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d4f4:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d4f8:	418d883a 	add	r6,r8,r6

      ldw   r7, -20(r4)
 822d4fc:	21fffb17 	ldw	r7,-20(r4)
      add   r2, r7, r2
 822d500:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d504:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d508:	418d883a 	add	r6,r8,r6

      ldw   r7, -16(r4)
 822d50c:	21fffc17 	ldw	r7,-16(r4)
      add   r2, r7, r2
 822d510:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d514:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d518:	418d883a 	add	r6,r8,r6

      ldw   r7, -12(r4)
 822d51c:	21fffd17 	ldw	r7,-12(r4)
      add   r2, r7, r2
 822d520:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d524:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d528:	418d883a 	add	r6,r8,r6

      ldw   r7, -8(r4)
 822d52c:	21fffe17 	ldw	r7,-8(r4)
      add   r2, r7, r2
 822d530:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d534:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d538:	418d883a 	add	r6,r8,r6

      ldw   r7, -4(r4)
 822d53c:	21ffff17 	ldw	r7,-4(r4)
      add   r2, r7, r2
 822d540:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d544:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d548:	418d883a 	add	r6,r8,r6

0822d54c <loop0>:
loop0:
      subi  r5, r5, 16
 822d54c:	297ffc04 	addi	r5,r5,-16
      bge   r5, zero, loop
 822d550:	283fbd0e 	bge	r5,zero,822d448 <loop>
/*
 * process last halfword (if any)
 */
      beq   r9, zero, fold
 822d554:	48000426 	beq	r9,zero,822d568 <fold>
      ldhu  r7, 0(r4)
 822d558:	21c0000b 	ldhu	r7,0(r4)
      add   r2, r7, r2
 822d55c:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d560:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d564:	418d883a 	add	r6,r8,r6

0822d568 <fold>:
      
fold:
      srli  r7, r2, 16
 822d568:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 822d56c:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add the upper and lower halfwords */
 822d570:	3885883a 	add	r2,r7,r2
      add   r2, r6, r2		    /* add the carries */
 822d574:	3085883a 	add	r2,r6,r2
/* the accumulator is 18 bits */
      srli  r7, r2, 16
 822d578:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 822d57c:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add 2 carry bits to lower halfword */
 822d580:	3885883a 	add	r2,r7,r2
/* the accumulator is 17 bits */
      srli  r7, r2, 16
 822d584:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 822d588:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add carry to lower halfword */
 822d58c:	3885883a 	add	r2,r7,r2

0822d590 <done>:

done:
      ret			    		/* r2 = 16-bit checksum */
 822d590:	f800283a 	ret

0822d594 <dtrap>:
void irq_Unmask(void);

/* dtrap() - function to trap to debugger */
void
dtrap(void)
{
 822d594:	defffe04 	addi	sp,sp,-8
 822d598:	dfc00115 	stw	ra,4(sp)
 822d59c:	df000015 	stw	fp,0(sp)
 822d5a0:	d839883a 	mov	fp,sp
   printf("dtrap - needs breakpoint\n");
 822d5a4:	01020974 	movhi	r4,2085
 822d5a8:	21028204 	addi	r4,r4,2568
 822d5ac:	82036240 	call	8203624 <puts>
}
 822d5b0:	0001883a 	nop
 822d5b4:	e037883a 	mov	sp,fp
 822d5b8:	dfc00117 	ldw	ra,4(sp)
 822d5bc:	df000017 	ldw	fp,0(sp)
 822d5c0:	dec00204 	addi	sp,sp,8
 822d5c4:	f800283a 	ret

0822d5c8 <kbhit>:

int
kbhit()
{
 822d5c8:	defffd04 	addi	sp,sp,-12
 822d5cc:	dfc00215 	stw	ra,8(sp)
 822d5d0:	df000115 	stw	fp,4(sp)
 822d5d4:	df000104 	addi	fp,sp,4
   static int kbd_init = 0;
   int   kb;
   
   if (!kbd_init)
 822d5d8:	d0a0a017 	ldw	r2,-32128(gp)
 822d5dc:	10000b1e 	bne	r2,zero,822d60c <kbhit+0x44>
      /* we really should read the flags, OR in O_NONBLOCK, and write
       * the flags back to STDIN, but the NIOS-II/HAL implementation
       * will only let us modify O_NONBLOCK and O_APPEND, so we'll
       * just write the new flag value.
       */
      if (fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK) != 0)
 822d5e0:	01900004 	movi	r6,16384
 822d5e4:	01400104 	movi	r5,4
 822d5e8:	0009883a 	mov	r4,zero
 822d5ec:	823d8c00 	call	823d8c0 <fcntl>
 822d5f0:	10000426 	beq	r2,zero,822d604 <kbhit+0x3c>
      {
         printf("F_SETFL failed.\n");
 822d5f4:	01020974 	movhi	r4,2085
 822d5f8:	21028904 	addi	r4,r4,2596
 822d5fc:	82036240 	call	8203624 <puts>
         dtrap();
 822d600:	822d5940 	call	822d594 <dtrap>
      }
      kbd_init = 1; 
 822d604:	00800044 	movi	r2,1
 822d608:	d0a0a015 	stw	r2,-32128(gp)
   }

   /* we have to do a read to see if there is a character available.
    * we save the character, if there was one, to be read later. */
   if (kb_last == EOF)
 822d60c:	d0a03a17 	ldw	r2,-32536(gp)
 822d610:	10bfffd8 	cmpnei	r2,r2,-1
 822d614:	10000b1e 	bne	r2,zero,822d644 <kbhit+0x7c>
   {
      kb = getchar();
 822d618:	d0a00217 	ldw	r2,-32760(gp)
 822d61c:	10800117 	ldw	r2,4(r2)
 822d620:	1009883a 	mov	r4,r2
 822d624:	8202e880 	call	8202e88 <getc>
 822d628:	e0bfff15 	stw	r2,-4(fp)
      if (kb < 0)       /* any error means no character present */
 822d62c:	e0bfff17 	ldw	r2,-4(fp)
 822d630:	1000020e 	bge	r2,zero,822d63c <kbhit+0x74>
         return (FALSE);
 822d634:	0005883a 	mov	r2,zero
 822d638:	00000306 	br	822d648 <kbhit+0x80>
         
      /* there was a character, and we read it. */
      kb_last = kb;
 822d63c:	e0bfff17 	ldw	r2,-4(fp)
 822d640:	d0a03a15 	stw	r2,-32536(gp)
   }

   return (TRUE);
 822d644:	00800044 	movi	r2,1
}
 822d648:	e037883a 	mov	sp,fp
 822d64c:	dfc00117 	ldw	ra,4(sp)
 822d650:	df000017 	ldw	fp,0(sp)
 822d654:	dec00204 	addi	sp,sp,8
 822d658:	f800283a 	ret

0822d65c <getch>:

int 
getch()
{
 822d65c:	defffd04 	addi	sp,sp,-12
 822d660:	dfc00215 	stw	ra,8(sp)
 822d664:	df000115 	stw	fp,4(sp)
 822d668:	df000104 	addi	fp,sp,4
int chr;

   if(kb_last != EOF)
 822d66c:	d0a03a17 	ldw	r2,-32536(gp)
 822d670:	10bfffe0 	cmpeqi	r2,r2,-1
 822d674:	1000051e 	bne	r2,zero,822d68c <getch+0x30>
   {
      chr = kb_last;
 822d678:	d0a03a17 	ldw	r2,-32536(gp)
 822d67c:	e0bfff15 	stw	r2,-4(fp)
      kb_last = EOF;
 822d680:	00bfffc4 	movi	r2,-1
 822d684:	d0a03a15 	stw	r2,-32536(gp)
 822d688:	00000506 	br	822d6a0 <getch+0x44>
   }
   else
      chr = getchar();
 822d68c:	d0a00217 	ldw	r2,-32760(gp)
 822d690:	10800117 	ldw	r2,4(r2)
 822d694:	1009883a 	mov	r4,r2
 822d698:	8202e880 	call	8202e88 <getc>
 822d69c:	e0bfff15 	stw	r2,-4(fp)

   return chr;
 822d6a0:	e0bfff17 	ldw	r2,-4(fp)
}
 822d6a4:	e037883a 	mov	sp,fp
 822d6a8:	dfc00117 	ldw	ra,4(sp)
 822d6ac:	df000017 	ldw	fp,0(sp)
 822d6b0:	dec00204 	addi	sp,sp,8
 822d6b4:	f800283a 	ret

0822d6b8 <clock_init>:
int OS_TPS;
int cticks_factor;
int cticks_initialized = 0;

void clock_init(void)
{
 822d6b8:	deffff04 	addi	sp,sp,-4
 822d6bc:	df000015 	stw	fp,0(sp)
 822d6c0:	d839883a 	mov	fp,sp
   OS_TPS = OS_TICKS_PER_SEC;
 822d6c4:	00801904 	movi	r2,100
 822d6c8:	d0a0a215 	stw	r2,-32120(gp)
   cticks_factor = 0;
 822d6cc:	d020a115 	stw	zero,-32124(gp)
   cticks = 0;
 822d6d0:	d020a815 	stw	zero,-32096(gp)
   cticks_initialized = 1;
 822d6d4:	00800044 	movi	r2,1
 822d6d8:	d0a09d15 	stw	r2,-32140(gp)
}
 822d6dc:	0001883a 	nop
 822d6e0:	e037883a 	mov	sp,fp
 822d6e4:	df000017 	ldw	fp,0(sp)
 822d6e8:	dec00104 	addi	sp,sp,4
 822d6ec:	f800283a 	ret

0822d6f0 <clock_c>:

/* undo effects of clock_init (i.e. restore ISR vector) 
 * NO OP since using RTOS's timer.
 */
void clock_c(void)
{
 822d6f0:	deffff04 	addi	sp,sp,-4
 822d6f4:	df000015 	stw	fp,0(sp)
 822d6f8:	d839883a 	mov	fp,sp
   /* null */ ;
}
 822d6fc:	0001883a 	nop
 822d700:	e037883a 	mov	sp,fp
 822d704:	df000017 	ldw	fp,0(sp)
 822d708:	dec00104 	addi	sp,sp,4
 822d70c:	f800283a 	ret

0822d710 <cticks_hook>:
 * Use the uCOS-II/Altera HAL BSP's timer and scale cticks as per TPS.
 */

void
cticks_hook(void)
{
 822d710:	deffff04 	addi	sp,sp,-4
 822d714:	df000015 	stw	fp,0(sp)
 822d718:	d839883a 	mov	fp,sp
   if (cticks_initialized) 
 822d71c:	d0a09d17 	ldw	r2,-32140(gp)
 822d720:	10000d26 	beq	r2,zero,822d758 <cticks_hook+0x48>
   {
      cticks_factor += TPS;
 822d724:	d0a0a117 	ldw	r2,-32124(gp)
 822d728:	10801904 	addi	r2,r2,100
 822d72c:	d0a0a115 	stw	r2,-32124(gp)
      if (cticks_factor >= OS_TPS)
 822d730:	d0e0a117 	ldw	r3,-32124(gp)
 822d734:	d0a0a217 	ldw	r2,-32120(gp)
 822d738:	18800716 	blt	r3,r2,822d758 <cticks_hook+0x48>
      {
         cticks++;
 822d73c:	d0a0a817 	ldw	r2,-32096(gp)
 822d740:	10800044 	addi	r2,r2,1
 822d744:	d0a0a815 	stw	r2,-32096(gp)
         cticks_factor -= OS_TPS;
 822d748:	d0e0a117 	ldw	r3,-32124(gp)
 822d74c:	d0a0a217 	ldw	r2,-32120(gp)
 822d750:	1885c83a 	sub	r2,r3,r2
 822d754:	d0a0a115 	stw	r2,-32124(gp)
#ifdef USE_LCD
         update_display();
#endif
      }
   }
}
 822d758:	0001883a 	nop
 822d75c:	e037883a 	mov	sp,fp
 822d760:	df000017 	ldw	fp,0(sp)
 822d764:	dec00104 	addi	sp,sp,4
 822d768:	f800283a 	ret

0822d76c <irq_Mask>:
 * ENTER_CRIT_SECTION() and enable them in EXIT_CRIT_SECTION()
 * because calls to ENTER_CRIT_SECTION() can be nested."
 */
void
irq_Mask(void)
{
 822d76c:	defffd04 	addi	sp,sp,-12
 822d770:	df000215 	stw	fp,8(sp)
 822d774:	df000204 	addi	fp,sp,8
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 822d778:	0005303a 	rdctl	r2,status
 822d77c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 822d780:	e0ffff17 	ldw	r3,-4(fp)
 822d784:	00bfff84 	movi	r2,-2
 822d788:	1884703a 	and	r2,r3,r2
 822d78c:	1001703a 	wrctl	status,r2
  
  return context;
 822d790:	e0bfff17 	ldw	r2,-4(fp)
   alt_irq_context  local_cpu_statusreg;

   local_cpu_statusreg = alt_irq_disable_all();
 822d794:	e0bffe15 	stw	r2,-8(fp)
	
   if (++irq_level == 1)
 822d798:	d0a09e17 	ldw	r2,-32136(gp)
 822d79c:	10800044 	addi	r2,r2,1
 822d7a0:	d0a09e15 	stw	r2,-32136(gp)
 822d7a4:	d0a09e17 	ldw	r2,-32136(gp)
 822d7a8:	10800058 	cmpnei	r2,r2,1
 822d7ac:	1000021e 	bne	r2,zero,822d7b8 <irq_Mask+0x4c>
   {
      cpu_statusreg = local_cpu_statusreg;
 822d7b0:	e0bffe17 	ldw	r2,-8(fp)
 822d7b4:	d0a09f15 	stw	r2,-32132(gp)
   }
}
 822d7b8:	0001883a 	nop
 822d7bc:	e037883a 	mov	sp,fp
 822d7c0:	df000017 	ldw	fp,0(sp)
 822d7c4:	dec00104 	addi	sp,sp,4
 822d7c8:	f800283a 	ret

0822d7cc <irq_Unmask>:


/* Re-Enable Interrupts */
void
irq_Unmask(void)
{
 822d7cc:	defffe04 	addi	sp,sp,-8
 822d7d0:	df000115 	stw	fp,4(sp)
 822d7d4:	df000104 	addi	fp,sp,4
   if (--irq_level == 0)
 822d7d8:	d0a09e17 	ldw	r2,-32136(gp)
 822d7dc:	10bfffc4 	addi	r2,r2,-1
 822d7e0:	d0a09e15 	stw	r2,-32136(gp)
 822d7e4:	d0a09e17 	ldw	r2,-32136(gp)
 822d7e8:	1000041e 	bne	r2,zero,822d7fc <irq_Unmask+0x30>
   {
      alt_irq_enable_all(cpu_statusreg);
 822d7ec:	d0a09f17 	ldw	r2,-32132(gp)
 822d7f0:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 822d7f4:	e0bfff17 	ldw	r2,-4(fp)
 822d7f8:	1001703a 	wrctl	status,r2
   }
}
 822d7fc:	0001883a 	nop
 822d800:	e037883a 	mov	sp,fp
 822d804:	df000017 	ldw	fp,0(sp)
 822d808:	dec00104 	addi	sp,sp,4
 822d80c:	f800283a 	ret

0822d810 <LOCK_NET_RESOURCE>:
extern void irq_Mask(void);
extern void irq_Unmask(void);

void
LOCK_NET_RESOURCE(int resid)
{
 822d810:	defffb04 	addi	sp,sp,-20
 822d814:	dfc00415 	stw	ra,16(sp)
 822d818:	df000315 	stw	fp,12(sp)
 822d81c:	df000304 	addi	fp,sp,12
 822d820:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 822d824:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 822d828:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 822d82c:	e0bfff17 	ldw	r2,-4(fp)
 822d830:	10002216 	blt	r2,zero,822d8bc <LOCK_NET_RESOURCE+0xac>
 822d834:	e0bfff17 	ldw	r2,-4(fp)
 822d838:	10800408 	cmpgei	r2,r2,16
 822d83c:	10001f1e 	bne	r2,zero,822d8bc <LOCK_NET_RESOURCE+0xac>
   {
      do
      {
         OSSemPend(resid_semaphore[resid], 0, &error);
 822d840:	008209b4 	movhi	r2,2086
 822d844:	10b94204 	addi	r2,r2,-6904
 822d848:	e0ffff17 	ldw	r3,-4(fp)
 822d84c:	18c7883a 	add	r3,r3,r3
 822d850:	18c7883a 	add	r3,r3,r3
 822d854:	10c5883a 	add	r2,r2,r3
 822d858:	10800017 	ldw	r2,0(r2)
 822d85c:	e0fffe04 	addi	r3,fp,-8
 822d860:	180d883a 	mov	r6,r3
 822d864:	000b883a 	mov	r5,zero
 822d868:	1009883a 	mov	r4,r2
 822d86c:	821a0d40 	call	821a0d4 <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 822d870:	e0bffe03 	ldbu	r2,-8(fp)
 822d874:	10803fcc 	andi	r2,r2,255
 822d878:	10800298 	cmpnei	r2,r2,10
 822d87c:	10000a1e 	bne	r2,zero,822d8a8 <LOCK_NET_RESOURCE+0x98>
 822d880:	e0bffd17 	ldw	r2,-12(fp)
 822d884:	10800044 	addi	r2,r2,1
 822d888:	e0bffd15 	stw	r2,-12(fp)
 822d88c:	e0bffd17 	ldw	r2,-12(fp)
 822d890:	1080fa50 	cmplti	r2,r2,1001
 822d894:	1000041e 	bne	r2,zero,822d8a8 <LOCK_NET_RESOURCE+0x98>
         {
            panic("lock NET");   /* fatal */
 822d898:	01020974 	movhi	r4,2085
 822d89c:	21028d04 	addi	r4,r4,2612
 822d8a0:	8228c480 	call	8228c48 <panic>
 822d8a4:	00000606 	br	822d8c0 <LOCK_NET_RESOURCE+0xb0>
            return;
         }
      } while (error == 10);
 822d8a8:	e0bffe03 	ldbu	r2,-8(fp)
 822d8ac:	10803fcc 	andi	r2,r2,255
 822d8b0:	108002a0 	cmpeqi	r2,r2,10
 822d8b4:	103fe21e 	bne	r2,zero,822d840 <LOCK_NET_RESOURCE+0x30>
LOCK_NET_RESOURCE(int resid)
{
   INT8U error = 0;
   int   errct = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
 822d8b8:	00000106 	br	822d8c0 <LOCK_NET_RESOURCE+0xb0>
            return;
         }
      } while (error == 10);
   }
   else
      dtrap();
 822d8bc:	822d5940 	call	822d594 <dtrap>
}
 822d8c0:	e037883a 	mov	sp,fp
 822d8c4:	dfc00117 	ldw	ra,4(sp)
 822d8c8:	df000017 	ldw	fp,0(sp)
 822d8cc:	dec00204 	addi	sp,sp,8
 822d8d0:	f800283a 	ret

0822d8d4 <UNLOCK_NET_RESOURCE>:

void
UNLOCK_NET_RESOURCE(int resid)
{
 822d8d4:	defffc04 	addi	sp,sp,-16
 822d8d8:	dfc00315 	stw	ra,12(sp)
 822d8dc:	df000215 	stw	fp,8(sp)
 822d8e0:	df000204 	addi	fp,sp,8
 822d8e4:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 822d8e8:	e03ffe05 	stb	zero,-8(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 822d8ec:	e0bfff17 	ldw	r2,-4(fp)
 822d8f0:	10001316 	blt	r2,zero,822d940 <UNLOCK_NET_RESOURCE+0x6c>
 822d8f4:	e0bfff17 	ldw	r2,-4(fp)
 822d8f8:	10800408 	cmpgei	r2,r2,16
 822d8fc:	1000101e 	bne	r2,zero,822d940 <UNLOCK_NET_RESOURCE+0x6c>
   {
      error = OSSemPost(resid_semaphore[resid]);
 822d900:	008209b4 	movhi	r2,2086
 822d904:	10b94204 	addi	r2,r2,-6904
 822d908:	e0ffff17 	ldw	r3,-4(fp)
 822d90c:	18c7883a 	add	r3,r3,r3
 822d910:	18c7883a 	add	r3,r3,r3
 822d914:	10c5883a 	add	r2,r2,r3
 822d918:	10800017 	ldw	r2,0(r2)
 822d91c:	1009883a 	mov	r4,r2
 822d920:	821a44c0 	call	821a44c <OSSemPost>
 822d924:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 822d928:	e0bffe03 	ldbu	r2,-8(fp)
 822d92c:	10000526 	beq	r2,zero,822d944 <UNLOCK_NET_RESOURCE+0x70>
      {
         panic("unlock NET");
 822d930:	01020974 	movhi	r4,2085
 822d934:	21029004 	addi	r4,r4,2624
 822d938:	8228c480 	call	8228c48 <panic>
   INT8U error = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
   {
      error = OSSemPost(resid_semaphore[resid]);
      if (error != OS_NO_ERR)
 822d93c:	00000106 	br	822d944 <UNLOCK_NET_RESOURCE+0x70>
      {
         panic("unlock NET");
      }
   }
   else
      dtrap();
 822d940:	822d5940 	call	822d594 <dtrap>
}
 822d944:	0001883a 	nop
 822d948:	e037883a 	mov	sp,fp
 822d94c:	dfc00117 	ldw	ra,4(sp)
 822d950:	df000017 	ldw	fp,0(sp)
 822d954:	dec00204 	addi	sp,sp,8
 822d958:	f800283a 	ret

0822d95c <TK_NEWTASK>:
extern long     nettick_wakes;


int
TK_NEWTASK(struct inet_taskinfo * nettask)
{
 822d95c:	deffee04 	addi	sp,sp,-72
 822d960:	dfc01115 	stw	ra,68(sp)
 822d964:	df001015 	stw	fp,64(sp)
 822d968:	df001004 	addi	fp,sp,64
 822d96c:	e13fff15 	stw	r4,-4(fp)
   INT8U    error;
   OS_STK * stack;

   stack = (OS_STK*)npalloc(nettask->stacksize);
 822d970:	e0bfff17 	ldw	r2,-4(fp)
 822d974:	10800417 	ldw	r2,16(r2)
 822d978:	1009883a 	mov	r4,r2
 822d97c:	822e16c0 	call	822e16c <npalloc>
 822d980:	e0bff515 	stw	r2,-44(fp)
   if(!stack)
 822d984:	e0bff517 	ldw	r2,-44(fp)
 822d988:	1000031e 	bne	r2,zero,822d998 <TK_NEWTASK+0x3c>
      panic("stack alloc");
 822d98c:	01020974 	movhi	r4,2085
 822d990:	21029304 	addi	r4,r4,2636
 822d994:	8228c480 	call	8228c48 <panic>

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822d998:	e0bfff17 	ldw	r2,-4(fp)
 822d99c:	12000217 	ldw	r8,8(r2)
      nettask->entry,
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
 822d9a0:	e0bfff17 	ldw	r2,-4(fp)
 822d9a4:	10800417 	ldw	r2,16(r2)
 822d9a8:	1006d0ba 	srli	r3,r2,2
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822d9ac:	00900034 	movhi	r2,16384
 822d9b0:	10bfffc4 	addi	r2,r2,-1
 822d9b4:	1885883a 	add	r2,r3,r2
 822d9b8:	1085883a 	add	r2,r2,r2
 822d9bc:	1085883a 	add	r2,r2,r2
 822d9c0:	1007883a 	mov	r3,r2
 822d9c4:	e0bff517 	ldw	r2,-44(fp)
 822d9c8:	10cb883a 	add	r5,r2,r3
      nettask->entry,
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority,
 822d9cc:	e0bfff17 	ldw	r2,-4(fp)
 822d9d0:	10800317 	ldw	r2,12(r2)
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822d9d4:	11803fcc 	andi	r6,r2,255
      nettask->entry,
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority,
      nettask->priority,
 822d9d8:	e0bfff17 	ldw	r2,-4(fp)
 822d9dc:	10800317 	ldw	r2,12(r2)
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822d9e0:	10bfffcc 	andi	r2,r2,65535
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority,
      nettask->priority,
      stack, 
      (INT32U)nettask->stacksize / sizeof(OS_STK),
 822d9e4:	e0ffff17 	ldw	r3,-4(fp)
 822d9e8:	18c00417 	ldw	r3,16(r3)
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822d9ec:	1806d0ba 	srli	r3,r3,2
 822d9f0:	010000c4 	movi	r4,3
 822d9f4:	d9000415 	stw	r4,16(sp)
 822d9f8:	d8000315 	stw	zero,12(sp)
 822d9fc:	d8c00215 	stw	r3,8(sp)
 822da00:	e0fff517 	ldw	r3,-44(fp)
 822da04:	d8c00115 	stw	r3,4(sp)
 822da08:	d8800015 	stw	r2,0(sp)
 822da0c:	300f883a 	mov	r7,r6
 822da10:	280d883a 	mov	r6,r5
 822da14:	000b883a 	mov	r5,zero
 822da18:	4009883a 	mov	r4,r8
 822da1c:	821ae080 	call	821ae08 <OSTaskCreateExt>
 822da20:	e0bff605 	stb	r2,-40(fp)
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority);
#endif
   /* If we go here, then there's another task using our priority */
   /* Tell the user and exit with an error */
   if (error == OS_PRIO_EXIST)
 822da24:	e0bff603 	ldbu	r2,-40(fp)
 822da28:	10803fcc 	andi	r2,r2,255
 822da2c:	10800a18 	cmpnei	r2,r2,40
 822da30:	10001c1e 	bne	r2,zero,822daa4 <TK_NEWTASK+0x148>
   { 
     char curr_task[OS_TASK_NAME_SIZE];
     INT8U err;
     OSTaskNameGet(nettask->priority, (INT8U*)curr_task, &err);
 822da34:	e0bfff17 	ldw	r2,-4(fp)
 822da38:	10800317 	ldw	r2,12(r2)
 822da3c:	10803fcc 	andi	r2,r2,255
 822da40:	e13ff644 	addi	r4,fp,-39
 822da44:	e0fff684 	addi	r3,fp,-38
 822da48:	200d883a 	mov	r6,r4
 822da4c:	180b883a 	mov	r5,r3
 822da50:	1009883a 	mov	r4,r2
 822da54:	821b4800 	call	821b480 <OSTaskNameGet>
     curr_task[OS_TASK_NAME_SIZE-1]=0;
 822da58:	e03ffe45 	stb	zero,-7(fp)
    
     printf("Priority requested for task \"%s\" (Prio:%d) conflicts with "\
 822da5c:	e0bfff17 	ldw	r2,-4(fp)
 822da60:	10c00117 	ldw	r3,4(r2)
 822da64:	e0bfff17 	ldw	r2,-4(fp)
 822da68:	11000317 	ldw	r4,12(r2)
 822da6c:	e0bfff17 	ldw	r2,-4(fp)
 822da70:	10800317 	ldw	r2,12(r2)
 822da74:	e17ff684 	addi	r5,fp,-38
 822da78:	d8800015 	stw	r2,0(sp)
 822da7c:	280f883a 	mov	r7,r5
 822da80:	200d883a 	mov	r6,r4
 822da84:	180b883a 	mov	r5,r3
 822da88:	01020974 	movhi	r4,2085
 822da8c:	21029604 	addi	r4,r4,2648
 822da90:	82033a00 	call	82033a0 <printf>
            "already running task \"%s\" (Prio: %d)\n",
             nettask->name, nettask->priority, curr_task, nettask->priority);
             
     printf("You may wish to check your task priority settings in "\
 822da94:	01020974 	movhi	r4,2085
 822da98:	2102ae04 	addi	r4,r4,2744
 822da9c:	82036240 	call	8203624 <puts>
 822daa0:	00002006 	br	822db24 <TK_NEWTASK+0x1c8>
            "\"<bsp path>\\iniche\\src\\h\\nios2\\ipport.h\" against "\
            "the priority settings in your application and recompile.\n\n");
   }
   else if (error == OS_PRIO_INVALID)
 822daa4:	e0bff603 	ldbu	r2,-40(fp)
 822daa8:	10803fcc 	andi	r2,r2,255
 822daac:	10800a98 	cmpnei	r2,r2,42
 822dab0:	10000e1e 	bne	r2,zero,822daec <TK_NEWTASK+0x190>
   {
     printf("Priority requested for task \"%s\" (Prio:%d) exceeds "\
 822dab4:	e0bfff17 	ldw	r2,-4(fp)
 822dab8:	10c00117 	ldw	r3,4(r2)
 822dabc:	e0bfff17 	ldw	r2,-4(fp)
 822dac0:	10800317 	ldw	r2,12(r2)
 822dac4:	01c00504 	movi	r7,20
 822dac8:	100d883a 	mov	r6,r2
 822dacc:	180b883a 	mov	r5,r3
 822dad0:	01020974 	movhi	r4,2085
 822dad4:	2102d604 	addi	r4,r4,2904
 822dad8:	82033a00 	call	82033a0 <printf>
            "available priority levels in the system (OS_LOWEST_PRIO = %d)\n\n",
             nettask->name, nettask->priority, OS_LOWEST_PRIO);
             
     printf("Please modify the tasks priority level, or modify the "\
 822dadc:	01020974 	movhi	r4,2085
 822dae0:	2102f304 	addi	r4,r4,3020
 822dae4:	82036240 	call	8203624 <puts>
 822dae8:	00000e06 	br	822db24 <TK_NEWTASK+0x1c8>
            "\"Lowest assignable priority\" setting in the MicroC/OS-II "\
            "component\n");
   }
   else if (error != OS_NO_ERR)
 822daec:	e0bff603 	ldbu	r2,-40(fp)
 822daf0:	10803fcc 	andi	r2,r2,255
 822daf4:	10000b26 	beq	r2,zero,822db24 <TK_NEWTASK+0x1c8>
   {                          /* All other errors are fatal */
      printf("Task create error /(MicroC/OS-II error code:%d/) on %s\n",
 822daf8:	e0bff603 	ldbu	r2,-40(fp)
 822dafc:	10c03fcc 	andi	r3,r2,255
 822db00:	e0bfff17 	ldw	r2,-4(fp)
 822db04:	10800117 	ldw	r2,4(r2)
 822db08:	100d883a 	mov	r6,r2
 822db0c:	180b883a 	mov	r5,r3
 822db10:	01020974 	movhi	r4,2085
 822db14:	21031204 	addi	r4,r4,3144
 822db18:	82033a00 	call	82033a0 <printf>
             error, nettask->name);
      return (-1);
 822db1c:	00bfffc4 	movi	r2,-1
 822db20:	00001c06 	br	822db94 <TK_NEWTASK+0x238>
   }

   /* Include the task name, so that uc/osII (os aware) debuggers can
    * display it.
    */
   OSTaskNameSet(nettask->priority, (INT8U*)&nettask->name[0], &error);
 822db24:	e0bfff17 	ldw	r2,-4(fp)
 822db28:	10800317 	ldw	r2,12(r2)
 822db2c:	10c03fcc 	andi	r3,r2,255
 822db30:	e0bfff17 	ldw	r2,-4(fp)
 822db34:	10800117 	ldw	r2,4(r2)
 822db38:	e13ff604 	addi	r4,fp,-40
 822db3c:	200d883a 	mov	r6,r4
 822db40:	100b883a 	mov	r5,r2
 822db44:	1809883a 	mov	r4,r3
 822db48:	821b6180 	call	821b618 <OSTaskNameSet>

   nettask->stackbase = (char*)stack;
 822db4c:	e0bfff17 	ldw	r2,-4(fp)
 822db50:	e0fff517 	ldw	r3,-44(fp)
 822db54:	10c00515 	stw	r3,20(r2)
   *nettask->tk_ptr = (INT8U)nettask->priority;  
 822db58:	e0bfff17 	ldw	r2,-4(fp)
 822db5c:	10800017 	ldw	r2,0(r2)
 822db60:	e0ffff17 	ldw	r3,-4(fp)
 822db64:	18c00317 	ldw	r3,12(r3)
 822db68:	10c00005 	stb	r3,0(r2)

   printf("Created \"%s\" task (Prio: %d)\n",
 822db6c:	e0bfff17 	ldw	r2,-4(fp)
 822db70:	10c00117 	ldw	r3,4(r2)
 822db74:	e0bfff17 	ldw	r2,-4(fp)
 822db78:	10800317 	ldw	r2,12(r2)
 822db7c:	100d883a 	mov	r6,r2
 822db80:	180b883a 	mov	r5,r3
 822db84:	01020974 	movhi	r4,2085
 822db88:	21032004 	addi	r4,r4,3200
 822db8c:	82033a00 	call	82033a0 <printf>
         (char *)nettask->name, nettask->priority);

   return (0);
 822db90:	0005883a 	mov	r2,zero
}
 822db94:	e037883a 	mov	sp,fp
 822db98:	dfc00117 	ldw	ra,4(sp)
 822db9c:	df000017 	ldw	fp,0(sp)
 822dba0:	dec00204 	addi	sp,sp,8
 822dba4:	f800283a 	ret

0822dba8 <wait_app_sem>:
 * event (e.g., configuration inputs from user, initiation of a new session,
 * or a periodic timeout notification.
 */
void
wait_app_sem(unsigned long semid)
{
 822dba8:	defffb04 	addi	sp,sp,-20
 822dbac:	dfc00415 	stw	ra,16(sp)
 822dbb0:	df000315 	stw	fp,12(sp)
 822dbb4:	df000304 	addi	fp,sp,12
 822dbb8:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 822dbbc:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 822dbc0:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= semid) && (semid <= MAX_SEMID))
 822dbc4:	e0bfff17 	ldw	r2,-4(fp)
 822dbc8:	108001a8 	cmpgeui	r2,r2,6
 822dbcc:	10001f1e 	bne	r2,zero,822dc4c <wait_app_sem+0xa4>
   {
      do
      {
         OSSemPend(app_semaphore[semid], 0, &error);
 822dbd0:	008209b4 	movhi	r2,2086
 822dbd4:	10b95204 	addi	r2,r2,-6840
 822dbd8:	e0ffff17 	ldw	r3,-4(fp)
 822dbdc:	18c7883a 	add	r3,r3,r3
 822dbe0:	18c7883a 	add	r3,r3,r3
 822dbe4:	10c5883a 	add	r2,r2,r3
 822dbe8:	10800017 	ldw	r2,0(r2)
 822dbec:	e0fffe04 	addi	r3,fp,-8
 822dbf0:	180d883a 	mov	r6,r3
 822dbf4:	000b883a 	mov	r5,zero
 822dbf8:	1009883a 	mov	r4,r2
 822dbfc:	821a0d40 	call	821a0d4 <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 822dc00:	e0bffe03 	ldbu	r2,-8(fp)
 822dc04:	10803fcc 	andi	r2,r2,255
 822dc08:	10800298 	cmpnei	r2,r2,10
 822dc0c:	10000a1e 	bne	r2,zero,822dc38 <wait_app_sem+0x90>
 822dc10:	e0bffd17 	ldw	r2,-12(fp)
 822dc14:	10800044 	addi	r2,r2,1
 822dc18:	e0bffd15 	stw	r2,-12(fp)
 822dc1c:	e0bffd17 	ldw	r2,-12(fp)
 822dc20:	1080fa50 	cmplti	r2,r2,1001
 822dc24:	1000041e 	bne	r2,zero,822dc38 <wait_app_sem+0x90>
         {
            panic("lock NET");   /* fatal */
 822dc28:	01020974 	movhi	r4,2085
 822dc2c:	21028d04 	addi	r4,r4,2612
 822dc30:	8228c480 	call	8228c48 <panic>
 822dc34:	00000606 	br	822dc50 <wait_app_sem+0xa8>
            return;
         }
      } while (error == 10);
 822dc38:	e0bffe03 	ldbu	r2,-8(fp)
 822dc3c:	10803fcc 	andi	r2,r2,255
 822dc40:	108002a0 	cmpeqi	r2,r2,10
 822dc44:	103fe21e 	bne	r2,zero,822dbd0 <wait_app_sem+0x28>
 822dc48:	00000106 	br	822dc50 <wait_app_sem+0xa8>
   }
   else
      dtrap();
 822dc4c:	822d5940 	call	822d594 <dtrap>
}
 822dc50:	e037883a 	mov	sp,fp
 822dc54:	dfc00117 	ldw	ra,4(sp)
 822dc58:	df000017 	ldw	fp,0(sp)
 822dc5c:	dec00204 	addi	sp,sp,8
 822dc60:	f800283a 	ret

0822dc64 <post_app_sem>:
 * notification. It signals the corresponding application event.
 */

void
post_app_sem(unsigned long semid)
{
 822dc64:	defffc04 	addi	sp,sp,-16
 822dc68:	dfc00315 	stw	ra,12(sp)
 822dc6c:	df000215 	stw	fp,8(sp)
 822dc70:	df000204 	addi	fp,sp,8
 822dc74:	e13fff15 	stw	r4,-4(fp)
   INT8U error;

   if ((0 <= semid) && (semid <= MAX_SEMID))
 822dc78:	e0bfff17 	ldw	r2,-4(fp)
 822dc7c:	108001a8 	cmpgeui	r2,r2,6
 822dc80:	1000101e 	bne	r2,zero,822dcc4 <post_app_sem+0x60>
   {
      error = OSSemPost(app_semaphore[semid]);
 822dc84:	008209b4 	movhi	r2,2086
 822dc88:	10b95204 	addi	r2,r2,-6840
 822dc8c:	e0ffff17 	ldw	r3,-4(fp)
 822dc90:	18c7883a 	add	r3,r3,r3
 822dc94:	18c7883a 	add	r3,r3,r3
 822dc98:	10c5883a 	add	r2,r2,r3
 822dc9c:	10800017 	ldw	r2,0(r2)
 822dca0:	1009883a 	mov	r4,r2
 822dca4:	821a44c0 	call	821a44c <OSSemPost>
 822dca8:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 822dcac:	e0bffe03 	ldbu	r2,-8(fp)
 822dcb0:	10000526 	beq	r2,zero,822dcc8 <post_app_sem+0x64>
      {
         panic("unlock NET");
 822dcb4:	01020974 	movhi	r4,2085
 822dcb8:	21029004 	addi	r4,r4,2624
 822dcbc:	8228c480 	call	8228c48 <panic>
      }
   }
   else
      dtrap();
}
 822dcc0:	00000106 	br	822dcc8 <post_app_sem+0x64>
      {
         panic("unlock NET");
      }
   }
   else
      dtrap();
 822dcc4:	822d5940 	call	822d594 <dtrap>
}
 822dcc8:	0001883a 	nop
 822dccc:	e037883a 	mov	sp,fp
 822dcd0:	dfc00117 	ldw	ra,4(sp)
 822dcd4:	df000017 	ldw	fp,0(sp)
 822dcd8:	dec00204 	addi	sp,sp,8
 822dcdc:	f800283a 	ret

0822dce0 <alt_iniche_init>:
#ifndef SUPERLOOP

extern OS_EVENT *resid_semaphore[MAX_RESID+1];

void alt_iniche_init(void)
{
 822dce0:	defffd04 	addi	sp,sp,-12
 822dce4:	dfc00215 	stw	ra,8(sp)
 822dce8:	df000115 	stw	fp,4(sp)
 822dcec:	df000104 	addi	fp,sp,4
   int i;

   /* initialize the npalloc() heap semaphore */
   mheap_sem_ptr = OSSemCreate(1);
 822dcf0:	01000044 	movi	r4,1
 822dcf4:	8219dbc0 	call	8219dbc <OSSemCreate>
 822dcf8:	d0a0aa15 	stw	r2,-32088(gp)
   if (!mheap_sem_ptr)
 822dcfc:	d0a0aa17 	ldw	r2,-32088(gp)
 822dd00:	1000031e 	bne	r2,zero,822dd10 <alt_iniche_init+0x30>
      panic("mheap_sem_ptr create err"); 
 822dd04:	01020974 	movhi	r4,2085
 822dd08:	21032804 	addi	r4,r4,3232
 822dd0c:	8228c480 	call	8228c48 <panic>

   rcvdq_sem_ptr = OSSemCreate(0);
 822dd10:	0009883a 	mov	r4,zero
 822dd14:	8219dbc0 	call	8219dbc <OSSemCreate>
 822dd18:	d0a0ab15 	stw	r2,-32084(gp)
   if (!rcvdq_sem_ptr)
 822dd1c:	d0a0ab17 	ldw	r2,-32084(gp)
 822dd20:	1000031e 	bne	r2,zero,822dd30 <alt_iniche_init+0x50>
      panic("rcvdq_sem_ptr create err"); 
 822dd24:	01020974 	movhi	r4,2085
 822dd28:	21032f04 	addi	r4,r4,3260
 822dd2c:	8228c480 	call	8228c48 <panic>

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 822dd30:	e03fff15 	stw	zero,-4(fp)
 822dd34:	00001806 	br	822dd98 <alt_iniche_init+0xb8>
   {
      resid_semaphore[i] = OSSemCreate(1);
 822dd38:	01000044 	movi	r4,1
 822dd3c:	8219dbc0 	call	8219dbc <OSSemCreate>
 822dd40:	1009883a 	mov	r4,r2
 822dd44:	008209b4 	movhi	r2,2086
 822dd48:	10b94204 	addi	r2,r2,-6904
 822dd4c:	e0ffff17 	ldw	r3,-4(fp)
 822dd50:	18c7883a 	add	r3,r3,r3
 822dd54:	18c7883a 	add	r3,r3,r3
 822dd58:	10c5883a 	add	r2,r2,r3
 822dd5c:	11000015 	stw	r4,0(r2)
      if (!resid_semaphore[i])
 822dd60:	008209b4 	movhi	r2,2086
 822dd64:	10b94204 	addi	r2,r2,-6904
 822dd68:	e0ffff17 	ldw	r3,-4(fp)
 822dd6c:	18c7883a 	add	r3,r3,r3
 822dd70:	18c7883a 	add	r3,r3,r3
 822dd74:	10c5883a 	add	r2,r2,r3
 822dd78:	10800017 	ldw	r2,0(r2)
 822dd7c:	1000031e 	bne	r2,zero,822dd8c <alt_iniche_init+0xac>
         panic("resid_semaphore create err");  
 822dd80:	01020974 	movhi	r4,2085
 822dd84:	21033604 	addi	r4,r4,3288
 822dd88:	8228c480 	call	8228c48 <panic>
   rcvdq_sem_ptr = OSSemCreate(0);
   if (!rcvdq_sem_ptr)
      panic("rcvdq_sem_ptr create err"); 

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 822dd8c:	e0bfff17 	ldw	r2,-4(fp)
 822dd90:	10800044 	addi	r2,r2,1
 822dd94:	e0bfff15 	stw	r2,-4(fp)
 822dd98:	e0bfff17 	ldw	r2,-4(fp)
 822dd9c:	10800410 	cmplti	r2,r2,16
 822dda0:	103fe51e 	bne	r2,zero,822dd38 <alt_iniche_init+0x58>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 822dda4:	e03fff15 	stw	zero,-4(fp)
 822dda8:	00001806 	br	822de0c <alt_iniche_init+0x12c>
   {
      app_semaphore[i] = OSSemCreate(1);
 822ddac:	01000044 	movi	r4,1
 822ddb0:	8219dbc0 	call	8219dbc <OSSemCreate>
 822ddb4:	1009883a 	mov	r4,r2
 822ddb8:	008209b4 	movhi	r2,2086
 822ddbc:	10b95204 	addi	r2,r2,-6840
 822ddc0:	e0ffff17 	ldw	r3,-4(fp)
 822ddc4:	18c7883a 	add	r3,r3,r3
 822ddc8:	18c7883a 	add	r3,r3,r3
 822ddcc:	10c5883a 	add	r2,r2,r3
 822ddd0:	11000015 	stw	r4,0(r2)
      if (!app_semaphore[i])
 822ddd4:	008209b4 	movhi	r2,2086
 822ddd8:	10b95204 	addi	r2,r2,-6840
 822dddc:	e0ffff17 	ldw	r3,-4(fp)
 822dde0:	18c7883a 	add	r3,r3,r3
 822dde4:	18c7883a 	add	r3,r3,r3
 822dde8:	10c5883a 	add	r2,r2,r3
 822ddec:	10800017 	ldw	r2,0(r2)
 822ddf0:	1000031e 	bne	r2,zero,822de00 <alt_iniche_init+0x120>
         panic("app_semaphore create err");  
 822ddf4:	01020974 	movhi	r4,2085
 822ddf8:	21033d04 	addi	r4,r4,3316
 822ddfc:	8228c480 	call	8228c48 <panic>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 822de00:	e0bfff17 	ldw	r2,-4(fp)
 822de04:	10800044 	addi	r2,r2,1
 822de08:	e0bfff15 	stw	r2,-4(fp)
 822de0c:	e0bfff17 	ldw	r2,-4(fp)
 822de10:	10800190 	cmplti	r2,r2,6
 822de14:	103fe51e 	bne	r2,zero,822ddac <alt_iniche_init+0xcc>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 822de18:	e03fff15 	stw	zero,-4(fp)
 822de1c:	00002506 	br	822deb4 <alt_iniche_init+0x1d4>
   {
      global_TCPwakeup_set[i].ctick = 0;
 822de20:	008209b4 	movhi	r2,2086
 822de24:	10b90604 	addi	r2,r2,-7144
 822de28:	e0ffff17 	ldw	r3,-4(fp)
 822de2c:	18c00324 	muli	r3,r3,12
 822de30:	10c5883a 	add	r2,r2,r3
 822de34:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].soc_event = NULL;
 822de38:	008209b4 	movhi	r2,2086
 822de3c:	10b90604 	addi	r2,r2,-7144
 822de40:	e0ffff17 	ldw	r3,-4(fp)
 822de44:	18c00324 	muli	r3,r3,12
 822de48:	10c5883a 	add	r2,r2,r3
 822de4c:	10800104 	addi	r2,r2,4
 822de50:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
 822de54:	0009883a 	mov	r4,zero
 822de58:	8219dbc0 	call	8219dbc <OSSemCreate>
 822de5c:	1009883a 	mov	r4,r2
 822de60:	008209b4 	movhi	r2,2086
 822de64:	10b90604 	addi	r2,r2,-7144
 822de68:	e0ffff17 	ldw	r3,-4(fp)
 822de6c:	18c00324 	muli	r3,r3,12
 822de70:	10c5883a 	add	r2,r2,r3
 822de74:	10800204 	addi	r2,r2,8
 822de78:	11000015 	stw	r4,0(r2)
      if (!global_TCPwakeup_set[i].semaphore)
 822de7c:	008209b4 	movhi	r2,2086
 822de80:	10b90604 	addi	r2,r2,-7144
 822de84:	e0ffff17 	ldw	r3,-4(fp)
 822de88:	18c00324 	muli	r3,r3,12
 822de8c:	10c5883a 	add	r2,r2,r3
 822de90:	10800204 	addi	r2,r2,8
 822de94:	10800017 	ldw	r2,0(r2)
 822de98:	1000031e 	bne	r2,zero,822dea8 <alt_iniche_init+0x1c8>
         panic("globwake_semaphore create err");  
 822de9c:	01020974 	movhi	r4,2085
 822dea0:	21034404 	addi	r4,r4,3344
 822dea4:	8228c480 	call	8228c48 <panic>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 822dea8:	e0bfff17 	ldw	r2,-4(fp)
 822deac:	10800044 	addi	r2,r2,1
 822deb0:	e0bfff15 	stw	r2,-4(fp)
 822deb4:	e0bfff17 	ldw	r2,-4(fp)
 822deb8:	10800510 	cmplti	r2,r2,20
 822debc:	103fd81e 	bne	r2,zero,822de20 <alt_iniche_init+0x140>
      global_TCPwakeup_set[i].soc_event = NULL;
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
      if (!global_TCPwakeup_set[i].semaphore)
         panic("globwake_semaphore create err");  
   }
   global_TCPwakeup_setIndx = 0;
 822dec0:	d020a715 	stw	zero,-32100(gp)
#endif  /* TCPWAKE_RTOS */
}
 822dec4:	0001883a 	nop
 822dec8:	e037883a 	mov	sp,fp
 822decc:	dfc00117 	ldw	ra,4(sp)
 822ded0:	df000017 	ldw	fp,0(sp)
 822ded4:	dec00204 	addi	sp,sp,8
 822ded8:	f800283a 	ret

0822dedc <pre_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
pre_task_setup()
{
 822dedc:	deffff04 	addi	sp,sp,-4
 822dee0:	df000015 	stw	fp,0(sp)
 822dee4:	d839883a 	mov	fp,sp
   write_leds(0);
   write_7seg_raw(0x0000);
#endif

   /* preset buffer counts; may be overridden from command line */
   bigbufs = MAXBIGPKTS;
 822dee8:	00800784 	movi	r2,30
 822deec:	d0a03815 	stw	r2,-32544(gp)
   lilbufs = MAXLILPKTS;
 822def0:	00800784 	movi	r2,30
 822def4:	d0a03615 	stw	r2,-32552(gp)
   bigbufsiz = BIGBUFSIZE;
 822def8:	00818004 	movi	r2,1536
 822defc:	d0a03915 	stw	r2,-32540(gp)
   lilbufsiz = LILBUFSIZE;
 822df00:	00802004 	movi	r2,128
 822df04:	d0a03715 	stw	r2,-32548(gp)

   /* Install callback to prep_armintcp from prep_ifaces() */
   port_prep = prep_armintcp;
 822df08:	008208f4 	movhi	r2,2083
 822df0c:	10b7d204 	addi	r2,r2,-8376
 822df10:	d0a0ca15 	stw	r2,-31960(gp)
#endif   /* NOTDEF */

#endif   /* USE_PPP */


   return NULL;
 822df14:	0005883a 	mov	r2,zero
}
 822df18:	e037883a 	mov	sp,fp
 822df1c:	df000017 	ldw	fp,0(sp)
 822df20:	dec00104 	addi	sp,sp,4
 822df24:	f800283a 	ret

0822df28 <post_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
post_task_setup()
{
 822df28:	deffff04 	addi	sp,sp,-4
 822df2c:	df000015 	stw	fp,0(sp)
 822df30:	d839883a 	mov	fp,sp
   return NULL;
 822df34:	0005883a 	mov	r2,zero
}
 822df38:	e037883a 	mov	sp,fp
 822df3c:	df000017 	ldw	fp,0(sp)
 822df40:	dec00104 	addi	sp,sp,4
 822df44:	f800283a 	ret

0822df48 <prep_armintcp>:

#endif  /* INCLUDE_NVPARMS */

int 
prep_armintcp(int ifaces_found)
{
 822df48:	defffd04 	addi	sp,sp,-12
 822df4c:	dfc00215 	stw	ra,8(sp)
 822df50:	df000115 	stw	fp,4(sp)
 822df54:	df000104 	addi	fp,sp,4
 822df58:	e13fff15 	stw	r4,-4(fp)
 * Call iniche_devices_init, in alt_iniche_dev.c, 
 * to step through all devices and all their respective
 * low-level initialization routines.
 */
#ifdef ALT_INICHE
   ifaces_found = iniche_devices_init(ifaces_found);
 822df5c:	e13fff17 	ldw	r4,-4(fp)
 822df60:	82258800 	call	8225880 <iniche_devices_init>
 822df64:	e0bfff15 	stw	r2,-4(fp)

#ifdef USE_SLIP
   ifaces_found = prep_slip(ifaces_found);
#endif

   return ifaces_found;
 822df68:	e0bfff17 	ldw	r2,-4(fp)
}
 822df6c:	e037883a 	mov	sp,fp
 822df70:	dfc00117 	ldw	ra,4(sp)
 822df74:	df000017 	ldw	fp,0(sp)
 822df78:	dec00204 	addi	sp,sp,8
 822df7c:	f800283a 	ret

0822df80 <npalloc_base>:
#endif


char *
npalloc_base(unsigned size, int cacheable)
{
 822df80:	defff804 	addi	sp,sp,-32
 822df84:	dfc00715 	stw	ra,28(sp)
 822df88:	df000615 	stw	fp,24(sp)
 822df8c:	df000604 	addi	fp,sp,24
 822df90:	e13ffe15 	stw	r4,-8(fp)
 822df94:	e17fff15 	stw	r5,-4(fp)
char * ptr;
void *(*alloc_rtn)(size_t size) = cacheable ? malloc : alt_uncached_malloc;
 822df98:	e0bfff17 	ldw	r2,-4(fp)
 822df9c:	10000326 	beq	r2,zero,822dfac <npalloc_base+0x2c>
 822dfa0:	00820974 	movhi	r2,2085
 822dfa4:	10ada404 	addi	r2,r2,-18800
 822dfa8:	00000206 	br	822dfb4 <npalloc_base+0x34>
 822dfac:	00820934 	movhi	r2,2084
 822dfb0:	10b27304 	addi	r2,r2,-13876
 822dfb4:	e0bffb15 	stw	r2,-20(fp)
#ifdef UCOS_II
   INT8U err;
#endif

#ifdef UCOS_II
   OSSemPend(mheap_sem_ptr, 0, &err);
 822dfb8:	d0a0aa17 	ldw	r2,-32088(gp)
 822dfbc:	e0fffd04 	addi	r3,fp,-12
 822dfc0:	180d883a 	mov	r6,r3
 822dfc4:	000b883a 	mov	r5,zero
 822dfc8:	1009883a 	mov	r4,r2
 822dfcc:	821a0d40 	call	821a0d4 <OSSemPend>
   if(err)
 822dfd0:	e0bffd03 	ldbu	r2,-12(fp)
 822dfd4:	10803fcc 	andi	r2,r2,255
 822dfd8:	10001626 	beq	r2,zero,822e034 <npalloc_base+0xb4>
   {
      int errct = 0;
 822dfdc:	e03ffa15 	stw	zero,-24(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 822dfe0:	00001006 	br	822e024 <npalloc_base+0xa4>
      {
         if(errct++ > 1000)
 822dfe4:	e0bffa17 	ldw	r2,-24(fp)
 822dfe8:	10c00044 	addi	r3,r2,1
 822dfec:	e0fffa15 	stw	r3,-24(fp)
 822dff0:	1080fa50 	cmplti	r2,r2,1001
 822dff4:	1000051e 	bne	r2,zero,822e00c <npalloc_base+0x8c>
         {
            panic("npalloc");    /* fatal? */
 822dff8:	01020974 	movhi	r4,2085
 822dffc:	21034c04 	addi	r4,r4,3376
 822e000:	8228c480 	call	8228c48 <panic>
            return NULL;
 822e004:	0005883a 	mov	r2,zero
 822e008:	00001b06 	br	822e078 <npalloc_base+0xf8>
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 822e00c:	d0a0aa17 	ldw	r2,-32088(gp)
 822e010:	e0fffd04 	addi	r3,fp,-12
 822e014:	180d883a 	mov	r6,r3
 822e018:	000b883a 	mov	r5,zero
 822e01c:	1009883a 	mov	r4,r2
 822e020:	821a0d40 	call	821a0d4 <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 822e024:	e0bffd03 	ldbu	r2,-12(fp)
 822e028:	10803fcc 	andi	r2,r2,255
 822e02c:	108002a0 	cmpeqi	r2,r2,10
 822e030:	103fec1e 	bne	r2,zero,822dfe4 <npalloc_base+0x64>
#endif

#ifdef   MEM_WRAPPERS
   ptr = wrap_alloc(size, alloc_rtn);
#else
   ptr = (*alloc_rtn)(size);
 822e034:	e0bffb17 	ldw	r2,-20(fp)
 822e038:	e13ffe17 	ldw	r4,-8(fp)
 822e03c:	103ee83a 	callr	r2
 822e040:	e0bffc15 	stw	r2,-16(fp)
#endif

#ifdef UCOS_II 
   err = OSSemPost(mheap_sem_ptr);
 822e044:	d0a0aa17 	ldw	r2,-32088(gp)
 822e048:	1009883a 	mov	r4,r2
 822e04c:	821a44c0 	call	821a44c <OSSemPost>
 822e050:	e0bffd05 	stb	r2,-12(fp)
#endif
   
   if(!ptr)
 822e054:	e0bffc17 	ldw	r2,-16(fp)
 822e058:	1000021e 	bne	r2,zero,822e064 <npalloc_base+0xe4>
      return NULL;
 822e05c:	0005883a 	mov	r2,zero
 822e060:	00000506 	br	822e078 <npalloc_base+0xf8>

   MEMSET(ptr, 0, size);
 822e064:	e1bffe17 	ldw	r6,-8(fp)
 822e068:	000b883a 	mov	r5,zero
 822e06c:	e13ffc17 	ldw	r4,-16(fp)
 822e070:	82031b40 	call	82031b4 <memset>
   return ptr;      
 822e074:	e0bffc17 	ldw	r2,-16(fp)
}
 822e078:	e037883a 	mov	sp,fp
 822e07c:	dfc00117 	ldw	ra,4(sp)
 822e080:	df000017 	ldw	fp,0(sp)
 822e084:	dec00204 	addi	sp,sp,8
 822e088:	f800283a 	ret

0822e08c <npfree_base>:

void
npfree_base(void *ptr, int cacheable)
{
 822e08c:	defff904 	addi	sp,sp,-28
 822e090:	dfc00615 	stw	ra,24(sp)
 822e094:	df000515 	stw	fp,20(sp)
 822e098:	df000504 	addi	fp,sp,20
 822e09c:	e13ffe15 	stw	r4,-8(fp)
 822e0a0:	e17fff15 	stw	r5,-4(fp)
   void (*free_rtn)(void *ptr) = cacheable ? free : alt_uncached_free;
 822e0a4:	e0bfff17 	ldw	r2,-4(fp)
 822e0a8:	10000326 	beq	r2,zero,822e0b8 <npfree_base+0x2c>
 822e0ac:	00820974 	movhi	r2,2085
 822e0b0:	10ada904 	addi	r2,r2,-18780
 822e0b4:	00000206 	br	822e0c0 <npfree_base+0x34>
 822e0b8:	00820934 	movhi	r2,2084
 822e0bc:	10b26204 	addi	r2,r2,-13944
 822e0c0:	e0bffc15 	stw	r2,-16(fp)
#ifdef UCOS_II
   INT8U err;

   OSSemPend(mheap_sem_ptr, 0, &err);
 822e0c4:	d0a0aa17 	ldw	r2,-32088(gp)
 822e0c8:	e0fffd04 	addi	r3,fp,-12
 822e0cc:	180d883a 	mov	r6,r3
 822e0d0:	000b883a 	mov	r5,zero
 822e0d4:	1009883a 	mov	r4,r2
 822e0d8:	821a0d40 	call	821a0d4 <OSSemPend>
   if (err)
 822e0dc:	e0bffd03 	ldbu	r2,-12(fp)
 822e0e0:	10803fcc 	andi	r2,r2,255
 822e0e4:	10001526 	beq	r2,zero,822e13c <npfree_base+0xb0>
   {
      int errct = 0;
 822e0e8:	e03ffb15 	stw	zero,-20(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 822e0ec:	00000f06 	br	822e12c <npfree_base+0xa0>
      {
         if (errct++ > 1000)
 822e0f0:	e0bffb17 	ldw	r2,-20(fp)
 822e0f4:	10c00044 	addi	r3,r2,1
 822e0f8:	e0fffb15 	stw	r3,-20(fp)
 822e0fc:	1080fa50 	cmplti	r2,r2,1001
 822e100:	1000041e 	bne	r2,zero,822e114 <npfree_base+0x88>
         {
            panic("npfree");    /* fatal? */
 822e104:	01020974 	movhi	r4,2085
 822e108:	21034e04 	addi	r4,r4,3384
 822e10c:	8228c480 	call	8228c48 <panic>
            return;
 822e110:	00001106 	br	822e158 <npfree_base+0xcc>
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 822e114:	d0a0aa17 	ldw	r2,-32088(gp)
 822e118:	e0fffd04 	addi	r3,fp,-12
 822e11c:	180d883a 	mov	r6,r3
 822e120:	000b883a 	mov	r5,zero
 822e124:	1009883a 	mov	r4,r2
 822e128:	821a0d40 	call	821a0d4 <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 822e12c:	e0bffd03 	ldbu	r2,-12(fp)
 822e130:	10803fcc 	andi	r2,r2,255
 822e134:	108002a0 	cmpeqi	r2,r2,10
 822e138:	103fed1e 	bne	r2,zero,822e0f0 <npfree_base+0x64>
   }
   
#ifdef   MEM_WRAPPERS
   wrap_free((char*)ptr, free_rtn);
#else
   (*free_rtn)(ptr);
 822e13c:	e0bffc17 	ldw	r2,-16(fp)
 822e140:	e13ffe17 	ldw	r4,-8(fp)
 822e144:	103ee83a 	callr	r2
#endif

   err = OSSemPost(mheap_sem_ptr);
 822e148:	d0a0aa17 	ldw	r2,-32088(gp)
 822e14c:	1009883a 	mov	r4,r2
 822e150:	821a44c0 	call	821a44c <OSSemPost>
 822e154:	e0bffd05 	stb	r2,-12(fp)
#else
   (*free_rtn)(ptr);
#endif
#endif

}
 822e158:	e037883a 	mov	sp,fp
 822e15c:	dfc00117 	ldw	ra,4(sp)
 822e160:	df000017 	ldw	fp,0(sp)
 822e164:	dec00204 	addi	sp,sp,8
 822e168:	f800283a 	ret

0822e16c <npalloc>:

char *
npalloc(unsigned size)
{
 822e16c:	defffd04 	addi	sp,sp,-12
 822e170:	dfc00215 	stw	ra,8(sp)
 822e174:	df000115 	stw	fp,4(sp)
 822e178:	df000104 	addi	fp,sp,4
 822e17c:	e13fff15 	stw	r4,-4(fp)
   return npalloc_base(size, 1);
 822e180:	01400044 	movi	r5,1
 822e184:	e13fff17 	ldw	r4,-4(fp)
 822e188:	822df800 	call	822df80 <npalloc_base>
}
 822e18c:	e037883a 	mov	sp,fp
 822e190:	dfc00117 	ldw	ra,4(sp)
 822e194:	df000017 	ldw	fp,0(sp)
 822e198:	dec00204 	addi	sp,sp,8
 822e19c:	f800283a 	ret

0822e1a0 <npfree>:

void
npfree(void *ptr)
{
 822e1a0:	defffd04 	addi	sp,sp,-12
 822e1a4:	dfc00215 	stw	ra,8(sp)
 822e1a8:	df000115 	stw	fp,4(sp)
 822e1ac:	df000104 	addi	fp,sp,4
 822e1b0:	e13fff15 	stw	r4,-4(fp)
   if(ptr) {
 822e1b4:	e0bfff17 	ldw	r2,-4(fp)
 822e1b8:	10000326 	beq	r2,zero,822e1c8 <npfree+0x28>
      npfree_base(ptr, 1);
 822e1bc:	01400044 	movi	r5,1
 822e1c0:	e13fff17 	ldw	r4,-4(fp)
 822e1c4:	822e08c0 	call	822e08c <npfree_base>
   }
}
 822e1c8:	0001883a 	nop
 822e1cc:	e037883a 	mov	sp,fp
 822e1d0:	dfc00117 	ldw	ra,4(sp)
 822e1d4:	df000017 	ldw	fp,0(sp)
 822e1d8:	dec00204 	addi	sp,sp,8
 822e1dc:	f800283a 	ret

0822e1e0 <ncpalloc>:
 * contains macro definitions that assign specific memory
 * allocation calls to these routines.
 */
#ifdef ALT_INICHE
char * ncpalloc(unsigned size)
{
 822e1e0:	defffd04 	addi	sp,sp,-12
 822e1e4:	dfc00215 	stw	ra,8(sp)
 822e1e8:	df000115 	stw	fp,4(sp)
 822e1ec:	df000104 	addi	fp,sp,4
 822e1f0:	e13fff15 	stw	r4,-4(fp)
   return npalloc_base(size, 0);
 822e1f4:	000b883a 	mov	r5,zero
 822e1f8:	e13fff17 	ldw	r4,-4(fp)
 822e1fc:	822df800 	call	822df80 <npalloc_base>
}
 822e200:	e037883a 	mov	sp,fp
 822e204:	dfc00117 	ldw	ra,4(sp)
 822e208:	df000017 	ldw	fp,0(sp)
 822e20c:	dec00204 	addi	sp,sp,8
 822e210:	f800283a 	ret

0822e214 <ncpfree>:

void ncpfree(void *ptr)
{
 822e214:	defffd04 	addi	sp,sp,-12
 822e218:	dfc00215 	stw	ra,8(sp)
 822e21c:	df000115 	stw	fp,4(sp)
 822e220:	df000104 	addi	fp,sp,4
 822e224:	e13fff15 	stw	r4,-4(fp)
   if(ptr) {
 822e228:	e0bfff17 	ldw	r2,-4(fp)
 822e22c:	10000326 	beq	r2,zero,822e23c <ncpfree+0x28>
      npfree_base(ptr, 0);
 822e230:	000b883a 	mov	r5,zero
 822e234:	e13fff17 	ldw	r4,-4(fp)
 822e238:	822e08c0 	call	822e08c <npfree_base>
   }
}
 822e23c:	0001883a 	nop
 822e240:	e037883a 	mov	sp,fp
 822e244:	dfc00117 	ldw	ra,4(sp)
 822e248:	df000017 	ldw	fp,0(sp)
 822e24c:	dec00204 	addi	sp,sp,8
 822e250:	f800283a 	ret

0822e254 <pffindtype>:
 * RETURNS: 
 */

struct protosw *  
pffindtype(int domain, int type)
{
 822e254:	defffc04 	addi	sp,sp,-16
 822e258:	dfc00315 	stw	ra,12(sp)
 822e25c:	df000215 	stw	fp,8(sp)
 822e260:	df000204 	addi	fp,sp,8
 822e264:	e13ffe15 	stw	r4,-8(fp)
 822e268:	e17fff15 	stw	r5,-4(fp)

   /* check that the passed domain is vaid for the build */
   if (domain != AF_INET)
 822e26c:	e0bffe17 	ldw	r2,-8(fp)
 822e270:	108000a0 	cmpeqi	r2,r2,2
 822e274:	1000031e 	bne	r2,zero,822e284 <pffindtype+0x30>
   {
#ifdef IP_V6
      if(domain != AF_INET6)
#endif
      {
         dtrap();    /* programming error */
 822e278:	822d5940 	call	822d594 <dtrap>
         return NULL;
 822e27c:	0005883a 	mov	r2,zero
 822e280:	00001306 	br	822e2d0 <pffindtype+0x7c>
      }
   }

   if (type == SOCK_STREAM)
 822e284:	e0bfff17 	ldw	r2,-4(fp)
 822e288:	10800058 	cmpnei	r2,r2,1
 822e28c:	1000031e 	bne	r2,zero,822e29c <pffindtype+0x48>
      return &tcp_protosw;
 822e290:	00820974 	movhi	r2,2085
 822e294:	108eb104 	addi	r2,r2,15044
 822e298:	00000d06 	br	822e2d0 <pffindtype+0x7c>
#ifdef UDP_SOCKETS
   else if(type == SOCK_DGRAM)
 822e29c:	e0bfff17 	ldw	r2,-4(fp)
 822e2a0:	10800098 	cmpnei	r2,r2,2
 822e2a4:	1000031e 	bne	r2,zero,822e2b4 <pffindtype+0x60>
      return &udp_protosw;
 822e2a8:	00820974 	movhi	r2,2085
 822e2ac:	108eb704 	addi	r2,r2,15068
 822e2b0:	00000706 	br	822e2d0 <pffindtype+0x7c>
#endif   /* UDP_SOCKETS */
#ifdef IP_RAW
   else if(type == SOCK_RAW)
 822e2b4:	e0bfff17 	ldw	r2,-4(fp)
 822e2b8:	108000d8 	cmpnei	r2,r2,3
 822e2bc:	1000031e 	bne	r2,zero,822e2cc <pffindtype+0x78>
      return &rawip_protosw;
 822e2c0:	00820974 	movhi	r2,2085
 822e2c4:	108ebd04 	addi	r2,r2,15092
 822e2c8:	00000106 	br	822e2d0 <pffindtype+0x7c>
#endif  /* IP_RAW */
   else
      return NULL;
 822e2cc:	0005883a 	mov	r2,zero
}
 822e2d0:	e037883a 	mov	sp,fp
 822e2d4:	dfc00117 	ldw	ra,4(sp)
 822e2d8:	df000017 	ldw	fp,0(sp)
 822e2dc:	dec00204 	addi	sp,sp,8
 822e2e0:	f800283a 	ret

0822e2e4 <pffindproto>:
 * RETURNS: 
 */

struct protosw *  
pffindproto(int domain, int protocol, int type)
{
 822e2e4:	defffb04 	addi	sp,sp,-20
 822e2e8:	dfc00415 	stw	ra,16(sp)
 822e2ec:	df000315 	stw	fp,12(sp)
 822e2f0:	df000304 	addi	fp,sp,12
 822e2f4:	e13ffd15 	stw	r4,-12(fp)
 822e2f8:	e17ffe15 	stw	r5,-8(fp)
 822e2fc:	e1bfff15 	stw	r6,-4(fp)
#ifdef IP_RAW
   if (type == SOCK_RAW)
 822e300:	e0bfff17 	ldw	r2,-4(fp)
 822e304:	108000d8 	cmpnei	r2,r2,3
 822e308:	1000041e 	bne	r2,zero,822e31c <pffindproto+0x38>
      return(pffindtype(domain, type));
 822e30c:	e17fff17 	ldw	r5,-4(fp)
 822e310:	e13ffd17 	ldw	r4,-12(fp)
 822e314:	822e2540 	call	822e254 <pffindtype>
 822e318:	00001e06 	br	822e394 <pffindproto+0xb0>
#endif

   switch (protocol)
 822e31c:	e0bffe17 	ldw	r2,-8(fp)
 822e320:	10c001a0 	cmpeqi	r3,r2,6
 822e324:	1800041e 	bne	r3,zero,822e338 <pffindproto+0x54>
 822e328:	10c00460 	cmpeqi	r3,r2,17
 822e32c:	1800081e 	bne	r3,zero,822e350 <pffindproto+0x6c>
 822e330:	10001026 	beq	r2,zero,822e374 <pffindproto+0x90>
 822e334:	00000c06 	br	822e368 <pffindproto+0x84>
   {
#ifdef BSD_SOCKETS
   case IPPROTO_TCP:
      if (type == SOCK_STREAM)
 822e338:	e0bfff17 	ldw	r2,-4(fp)
 822e33c:	10800058 	cmpnei	r2,r2,1
 822e340:	10000e26 	beq	r2,zero,822e37c <pffindproto+0x98>
         break;
      /* IPPROTO_TCP protocol on non-SOCK_STREAM type socket */
      dtrap();
 822e344:	822d5940 	call	822d594 <dtrap>
      return NULL;
 822e348:	0005883a 	mov	r2,zero
 822e34c:	00001106 	br	822e394 <pffindproto+0xb0>
   case IPPROTO_UDP:
      if (type == SOCK_DGRAM)
 822e350:	e0bfff17 	ldw	r2,-4(fp)
 822e354:	10800098 	cmpnei	r2,r2,2
 822e358:	10000a26 	beq	r2,zero,822e384 <pffindproto+0xa0>
         break;
      /* IPPROTO_UDP protocol on non-SOCK_DGRAM type socket */
      dtrap();
 822e35c:	822d5940 	call	822d594 <dtrap>
      return NULL;
 822e360:	0005883a 	mov	r2,zero
 822e364:	00000b06 	br	822e394 <pffindproto+0xb0>
   case 0:
      /* let protocol default based on socket type */
      break;
   default:
      /* unknown/unsupported protocol on socket */
      dtrap();
 822e368:	822d5940 	call	822d594 <dtrap>
      return NULL;
 822e36c:	0005883a 	mov	r2,zero
 822e370:	00000806 	br	822e394 <pffindproto+0xb0>
      dtrap();
      return NULL;
#endif /* BSD_SOCKETS */
   case 0:
      /* let protocol default based on socket type */
      break;
 822e374:	0001883a 	nop
 822e378:	00000306 	br	822e388 <pffindproto+0xa4>
   switch (protocol)
   {
#ifdef BSD_SOCKETS
   case IPPROTO_TCP:
      if (type == SOCK_STREAM)
         break;
 822e37c:	0001883a 	nop
 822e380:	00000106 	br	822e388 <pffindproto+0xa4>
      /* IPPROTO_TCP protocol on non-SOCK_STREAM type socket */
      dtrap();
      return NULL;
   case IPPROTO_UDP:
      if (type == SOCK_DGRAM)
         break;
 822e384:	0001883a 	nop
   default:
      /* unknown/unsupported protocol on socket */
      dtrap();
      return NULL;
   }
   return(pffindtype(domain, type));   /* map to findtype */
 822e388:	e17fff17 	ldw	r5,-4(fp)
 822e38c:	e13ffd17 	ldw	r4,-12(fp)
 822e390:	822e2540 	call	822e254 <pffindtype>
}
 822e394:	e037883a 	mov	sp,fp
 822e398:	dfc00117 	ldw	ra,4(sp)
 822e39c:	df000017 	ldw	fp,0(sp)
 822e3a0:	dec00204 	addi	sp,sp,8
 822e3a4:	f800283a 	ret

0822e3a8 <m_getnbuf>:
 * RETURNS: 
 */

struct mbuf *  
m_getnbuf(int type, int len)
{
 822e3a8:	defffa04 	addi	sp,sp,-24
 822e3ac:	dfc00515 	stw	ra,20(sp)
 822e3b0:	df000415 	stw	fp,16(sp)
 822e3b4:	df000404 	addi	fp,sp,16
 822e3b8:	e13ffe15 	stw	r4,-8(fp)
 822e3bc:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;
   PACKET pkt = NULL;
 822e3c0:	e03ffc15 	stw	zero,-16(fp)

#ifdef NPDEBUG
   if (type < MT_RXDATA || type > MT_IFADDR)
 822e3c4:	e0bffe17 	ldw	r2,-8(fp)
 822e3c8:	0080030e 	bge	zero,r2,822e3d8 <m_getnbuf+0x30>
 822e3cc:	e0bffe17 	ldw	r2,-8(fp)
 822e3d0:	10800390 	cmplti	r2,r2,14
 822e3d4:	1000011e 	bne	r2,zero,822e3dc <m_getnbuf+0x34>
   {
      dtrap(); /* is this OK? */
 822e3d8:	822d5940 	call	822d594 <dtrap>
   }
#endif

   /* if caller has data (len >= 0), we need to allocate 
    * a packet buffer; else all we need is the mbuf */
   if (len != 0)
 822e3dc:	e0bfff17 	ldw	r2,-4(fp)
 822e3e0:	10000d26 	beq	r2,zero,822e418 <m_getnbuf+0x70>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 822e3e4:	01000084 	movi	r4,2
 822e3e8:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pkt = pk_alloc(len + HDRSLEN);
 822e3ec:	e0bfff17 	ldw	r2,-4(fp)
 822e3f0:	10800e04 	addi	r2,r2,56
 822e3f4:	1009883a 	mov	r4,r2
 822e3f8:	822c9ec0 	call	822c9ec <pk_alloc>
 822e3fc:	e0bffc15 	stw	r2,-16(fp)

      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822e400:	01000084 	movi	r4,2
 822e404:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      if (!pkt)
 822e408:	e0bffc17 	ldw	r2,-16(fp)
 822e40c:	1000021e 	bne	r2,zero,822e418 <m_getnbuf+0x70>
         return NULL;
 822e410:	0005883a 	mov	r2,zero
 822e414:	00004106 	br	822e51c <m_getnbuf+0x174>
   }

   m = (struct mbuf *)getq(&mfreeq);
 822e418:	010209b4 	movhi	r4,2086
 822e41c:	21397104 	addi	r4,r4,-6716
 822e420:	822cec40 	call	822cec4 <getq>
 822e424:	e0bffd15 	stw	r2,-12(fp)
   if (!m)
 822e428:	e0bffd17 	ldw	r2,-12(fp)
 822e42c:	10000a1e 	bne	r2,zero,822e458 <m_getnbuf+0xb0>
   {
      if (pkt) 
 822e430:	e0bffc17 	ldw	r2,-16(fp)
 822e434:	10000626 	beq	r2,zero,822e450 <m_getnbuf+0xa8>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 822e438:	01000084 	movi	r4,2
 822e43c:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 822e440:	e13ffc17 	ldw	r4,-16(fp)
 822e444:	822cd3c0 	call	822cd3c <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822e448:	01000084 	movi	r4,2
 822e44c:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      }
      return NULL;
 822e450:	0005883a 	mov	r2,zero
 822e454:	00003106 	br	822e51c <m_getnbuf+0x174>
   }
   m->m_type = type;
 822e458:	e0bffd17 	ldw	r2,-12(fp)
 822e45c:	e0fffe17 	ldw	r3,-8(fp)
 822e460:	10c00815 	stw	r3,32(r2)
   if (len == 0)
 822e464:	e0bfff17 	ldw	r2,-4(fp)
 822e468:	1000071e 	bne	r2,zero,822e488 <m_getnbuf+0xe0>
   {
      m->pkt = NULL;
 822e46c:	e0bffd17 	ldw	r2,-12(fp)
 822e470:	10000115 	stw	zero,4(r2)
      m->m_base = NULL;    /* caller better fill these in! */
 822e474:	e0bffd17 	ldw	r2,-12(fp)
 822e478:	10000415 	stw	zero,16(r2)
      m->m_memsz = 0;
 822e47c:	e0bffd17 	ldw	r2,-12(fp)
 822e480:	10000515 	stw	zero,20(r2)
 822e484:	00001506 	br	822e4dc <m_getnbuf+0x134>
   }
   else
   {
      m->pkt = pkt;
 822e488:	e0bffd17 	ldw	r2,-12(fp)
 822e48c:	e0fffc17 	ldw	r3,-16(fp)
 822e490:	10c00115 	stw	r3,4(r2)
      /* set m_data to the part where tcp data should go */
      m->m_base = m->m_data = pkt->nb_prot = pkt->nb_buff + HDRSLEN;
 822e494:	e0bffc17 	ldw	r2,-16(fp)
 822e498:	10800117 	ldw	r2,4(r2)
 822e49c:	10c00e04 	addi	r3,r2,56
 822e4a0:	e0bffc17 	ldw	r2,-16(fp)
 822e4a4:	10c00315 	stw	r3,12(r2)
 822e4a8:	e0bffc17 	ldw	r2,-16(fp)
 822e4ac:	10c00317 	ldw	r3,12(r2)
 822e4b0:	e0bffd17 	ldw	r2,-12(fp)
 822e4b4:	10c00315 	stw	r3,12(r2)
 822e4b8:	e0bffd17 	ldw	r2,-12(fp)
 822e4bc:	10c00317 	ldw	r3,12(r2)
 822e4c0:	e0bffd17 	ldw	r2,-12(fp)
 822e4c4:	10c00415 	stw	r3,16(r2)
      m->m_memsz = pkt->nb_blen - HDRSLEN;
 822e4c8:	e0bffc17 	ldw	r2,-16(fp)
 822e4cc:	10800217 	ldw	r2,8(r2)
 822e4d0:	10fff204 	addi	r3,r2,-56
 822e4d4:	e0bffd17 	ldw	r2,-12(fp)
 822e4d8:	10c00515 	stw	r3,20(r2)
   }
   m->m_len = 0;
 822e4dc:	e0bffd17 	ldw	r2,-12(fp)
 822e4e0:	10000215 	stw	zero,8(r2)
   m->m_next = m->m_act = NULL;
 822e4e4:	e0bffd17 	ldw	r2,-12(fp)
 822e4e8:	10000715 	stw	zero,28(r2)
 822e4ec:	e0bffd17 	ldw	r2,-12(fp)
 822e4f0:	10c00717 	ldw	r3,28(r2)
 822e4f4:	e0bffd17 	ldw	r2,-12(fp)
 822e4f8:	10c00615 	stw	r3,24(r2)
   mbstat.allocs++;        /* maintain local statistics */
 822e4fc:	d0a0ae17 	ldw	r2,-32072(gp)
 822e500:	10800044 	addi	r2,r2,1
 822e504:	d0a0ae15 	stw	r2,-32072(gp)
   putq(&mbufq, (qp)m);
 822e508:	e17ffd17 	ldw	r5,-12(fp)
 822e50c:	010209b4 	movhi	r4,2086
 822e510:	21396c04 	addi	r4,r4,-6736
 822e514:	822cf7c0 	call	822cf7c <putq>
   return m;
 822e518:	e0bffd17 	ldw	r2,-12(fp)
}
 822e51c:	e037883a 	mov	sp,fp
 822e520:	dfc00117 	ldw	ra,4(sp)
 822e524:	df000017 	ldw	fp,0(sp)
 822e528:	dec00204 	addi	sp,sp,8
 822e52c:	f800283a 	ret

0822e530 <m_free>:
 */


struct mbuf *  
m_free(struct mbuf * m)
{
 822e530:	defffc04 	addi	sp,sp,-16
 822e534:	dfc00315 	stw	ra,12(sp)
 822e538:	df000215 	stw	fp,8(sp)
 822e53c:	df000204 	addi	fp,sp,8
 822e540:	e13fff15 	stw	r4,-4(fp)
   struct mbuf *  nextptr;

#ifdef NPDEBUG
   if (mbufq.q_len < 1)
 822e544:	008209b4 	movhi	r2,2086
 822e548:	10b96c04 	addi	r2,r2,-6736
 822e54c:	10800217 	ldw	r2,8(r2)
 822e550:	00800316 	blt	zero,r2,822e560 <m_free+0x30>
      panic("mfree: q_len");
 822e554:	01020974 	movhi	r4,2085
 822e558:	21035004 	addi	r4,r4,3392
 822e55c:	8228c480 	call	8228c48 <panic>

   if (m->m_type < MT_RXDATA || m->m_type > MT_IFADDR)
 822e560:	e0bfff17 	ldw	r2,-4(fp)
 822e564:	10800817 	ldw	r2,32(r2)
 822e568:	0080040e 	bge	zero,r2,822e57c <m_free+0x4c>
 822e56c:	e0bfff17 	ldw	r2,-4(fp)
 822e570:	10800817 	ldw	r2,32(r2)
 822e574:	10800390 	cmplti	r2,r2,14
 822e578:	10000a1e 	bne	r2,zero,822e5a4 <m_free+0x74>
   {
      if (m->m_type == MT_FREE)
 822e57c:	e0bfff17 	ldw	r2,-4(fp)
 822e580:	10800817 	ldw	r2,32(r2)
 822e584:	1000041e 	bne	r2,zero,822e598 <m_free+0x68>
      {
         dtrap(); /* debug double free of mbuf by tcp_in() */
 822e588:	822d5940 	call	822d594 <dtrap>
         return m->m_next; /* seems harmless, though.... */
 822e58c:	e0bfff17 	ldw	r2,-4(fp)
 822e590:	10800617 	ldw	r2,24(r2)
 822e594:	00002306 	br	822e624 <m_free+0xf4>
      }
      else
         panic("m_free: type");
 822e598:	01020974 	movhi	r4,2085
 822e59c:	21035404 	addi	r4,r4,3408
 822e5a0:	8228c480 	call	8228c48 <panic>
   }
#endif   /* NPDEBUG */

   nextptr = m->m_next;    /* remember value to return */
 822e5a4:	e0bfff17 	ldw	r2,-4(fp)
 822e5a8:	10800617 	ldw	r2,24(r2)
 822e5ac:	e0bffe15 	stw	r2,-8(fp)

   if (qdel(&mbufq, m) == NULL)
 822e5b0:	e17fff17 	ldw	r5,-4(fp)
 822e5b4:	010209b4 	movhi	r4,2086
 822e5b8:	21396c04 	addi	r4,r4,-6736
 822e5bc:	822d02c0 	call	822d02c <qdel>
 822e5c0:	1000031e 	bne	r2,zero,822e5d0 <m_free+0xa0>
      panic("m_free: missing");
 822e5c4:	01020974 	movhi	r4,2085
 822e5c8:	21035804 	addi	r4,r4,3424
 822e5cc:	8228c480 	call	8228c48 <panic>

   m->m_type = MT_FREE;    /* this may seem silly, but helps error checking */
 822e5d0:	e0bfff17 	ldw	r2,-4(fp)
 822e5d4:	10000815 	stw	zero,32(r2)

   if (m->pkt)
 822e5d8:	e0bfff17 	ldw	r2,-4(fp)
 822e5dc:	10800117 	ldw	r2,4(r2)
 822e5e0:	10000826 	beq	r2,zero,822e604 <m_free+0xd4>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 822e5e4:	01000084 	movi	r4,2
 822e5e8:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free(m->pkt);     /* free up the netport buffer */
 822e5ec:	e0bfff17 	ldw	r2,-4(fp)
 822e5f0:	10800117 	ldw	r2,4(r2)
 822e5f4:	1009883a 	mov	r4,r2
 822e5f8:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822e5fc:	01000084 	movi	r4,2
 822e600:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   }
   mbstat.frees++;
 822e604:	d0a0af17 	ldw	r2,-32068(gp)
 822e608:	10800044 	addi	r2,r2,1
 822e60c:	d0a0af15 	stw	r2,-32068(gp)
   putq(&mfreeq, (qp)m);
 822e610:	e17fff17 	ldw	r5,-4(fp)
 822e614:	010209b4 	movhi	r4,2086
 822e618:	21397104 	addi	r4,r4,-6716
 822e61c:	822cf7c0 	call	822cf7c <putq>
   return nextptr;
 822e620:	e0bffe17 	ldw	r2,-8(fp)
}
 822e624:	e037883a 	mov	sp,fp
 822e628:	dfc00117 	ldw	ra,4(sp)
 822e62c:	df000017 	ldw	fp,0(sp)
 822e630:	dec00204 	addi	sp,sp,8
 822e634:	f800283a 	ret

0822e638 <m_freem>:
 * RETURNS: 
 */

void
m_freem(struct mbuf * m)
{
 822e638:	defffd04 	addi	sp,sp,-12
 822e63c:	dfc00215 	stw	ra,8(sp)
 822e640:	df000115 	stw	fp,4(sp)
 822e644:	df000104 	addi	fp,sp,4
 822e648:	e13fff15 	stw	r4,-4(fp)
   while (m != NULL)
 822e64c:	00000306 	br	822e65c <m_freem+0x24>
      m = m_free(m);
 822e650:	e13fff17 	ldw	r4,-4(fp)
 822e654:	822e5300 	call	822e530 <m_free>
 822e658:	e0bfff15 	stw	r2,-4(fp)
 */

void
m_freem(struct mbuf * m)
{
   while (m != NULL)
 822e65c:	e0bfff17 	ldw	r2,-4(fp)
 822e660:	103ffb1e 	bne	r2,zero,822e650 <m_freem+0x18>
      m = m_free(m);
}
 822e664:	0001883a 	nop
 822e668:	e037883a 	mov	sp,fp
 822e66c:	dfc00117 	ldw	ra,4(sp)
 822e670:	df000017 	ldw	fp,0(sp)
 822e674:	dec00204 	addi	sp,sp,8
 822e678:	f800283a 	ret

0822e67c <m_copy>:
 * RETURNS: 
 */

struct mbuf *  
m_copy(struct mbuf * m, int off, int len)
{
 822e67c:	defff704 	addi	sp,sp,-36
 822e680:	dfc00815 	stw	ra,32(sp)
 822e684:	df000715 	stw	fp,28(sp)
 822e688:	df000704 	addi	fp,sp,28
 822e68c:	e13ffd15 	stw	r4,-12(fp)
 822e690:	e17ffe15 	stw	r5,-8(fp)
 822e694:	e1bfff15 	stw	r6,-4(fp)
   struct mbuf *  nb, * head, *  tail;
   int   tocopy;

   if (len == 0)  /* nothing to do */
 822e698:	e0bfff17 	ldw	r2,-4(fp)
 822e69c:	1000021e 	bne	r2,zero,822e6a8 <m_copy+0x2c>
      return NULL;
 822e6a0:	0005883a 	mov	r2,zero
 822e6a4:	0000ad06 	br	822e95c <m_copy+0x2e0>

#ifdef NPDEBUG
   /* sanity test parms */
   if (off < 0 || (len < 0 && len != M_COPYALL))
 822e6a8:	e0bffe17 	ldw	r2,-8(fp)
 822e6ac:	10000516 	blt	r2,zero,822e6c4 <m_copy+0x48>
 822e6b0:	e0bfff17 	ldw	r2,-4(fp)
 822e6b4:	1000180e 	bge	r2,zero,822e718 <m_copy+0x9c>
 822e6b8:	e0bfff17 	ldw	r2,-4(fp)
 822e6bc:	10bfffe0 	cmpeqi	r2,r2,-1
 822e6c0:	1000151e 	bne	r2,zero,822e718 <m_copy+0x9c>
   {
      dtrap();
 822e6c4:	822d5940 	call	822d594 <dtrap>
      return NULL;
 822e6c8:	0005883a 	mov	r2,zero
 822e6cc:	0000a306 	br	822e95c <m_copy+0x2e0>
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
   {
      if (!m)
 822e6d0:	e0bffd17 	ldw	r2,-12(fp)
 822e6d4:	1000031e 	bne	r2,zero,822e6e4 <m_copy+0x68>
      {
         dtrap();
 822e6d8:	822d5940 	call	822d594 <dtrap>
         return NULL;
 822e6dc:	0005883a 	mov	r2,zero
 822e6e0:	00009e06 	br	822e95c <m_copy+0x2e0>
      }
      if (off < (int)m->m_len)
 822e6e4:	e0bffd17 	ldw	r2,-12(fp)
 822e6e8:	10800217 	ldw	r2,8(r2)
 822e6ec:	1007883a 	mov	r3,r2
 822e6f0:	e0bffe17 	ldw	r2,-8(fp)
 822e6f4:	10c00b16 	blt	r2,r3,822e724 <m_copy+0xa8>
         break;
      off -= m->m_len;
 822e6f8:	e0fffe17 	ldw	r3,-8(fp)
 822e6fc:	e0bffd17 	ldw	r2,-12(fp)
 822e700:	10800217 	ldw	r2,8(r2)
 822e704:	1885c83a 	sub	r2,r3,r2
 822e708:	e0bffe15 	stw	r2,-8(fp)
      m = m->m_next;
 822e70c:	e0bffd17 	ldw	r2,-12(fp)
 822e710:	10800617 	ldw	r2,24(r2)
 822e714:	e0bffd15 	stw	r2,-12(fp)
      return NULL;
   }
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
 822e718:	e0bffe17 	ldw	r2,-8(fp)
 822e71c:	00bfec16 	blt	zero,r2,822e6d0 <m_copy+0x54>
 822e720:	00000106 	br	822e728 <m_copy+0xac>
      {
         dtrap();
         return NULL;
      }
      if (off < (int)m->m_len)
         break;
 822e724:	0001883a 	nop
      off -= m->m_len;
      m = m->m_next;
   }

   head = tail = NULL;
 822e728:	e03ffb15 	stw	zero,-20(fp)
 822e72c:	e0bffb17 	ldw	r2,-20(fp)
 822e730:	e0bffa15 	stw	r2,-24(fp)

   while (len > 0)
 822e734:	00007f06 	br	822e934 <m_copy+0x2b8>
   {
      if (m == NULL) /* at end of queue? */
 822e738:	e0bffd17 	ldw	r2,-12(fp)
 822e73c:	1000051e 	bne	r2,zero,822e754 <m_copy+0xd8>
      {
         panic("m_copy: bad len");
 822e740:	01020974 	movhi	r4,2085
 822e744:	21035c04 	addi	r4,r4,3440
 822e748:	8228c480 	call	8228c48 <panic>
         return NULL;
 822e74c:	0005883a 	mov	r2,zero
 822e750:	00008206 	br	822e95c <m_copy+0x2e0>
      }
      tocopy = (int)MIN(len, (int)(m->m_len - off));
 822e754:	e0bffd17 	ldw	r2,-12(fp)
 822e758:	10c00217 	ldw	r3,8(r2)
 822e75c:	e0bffe17 	ldw	r2,-8(fp)
 822e760:	1885c83a 	sub	r2,r3,r2
 822e764:	e0ffff17 	ldw	r3,-4(fp)
 822e768:	1880010e 	bge	r3,r2,822e770 <m_copy+0xf4>
 822e76c:	1805883a 	mov	r2,r3
 822e770:	e0bffc15 	stw	r2,-16(fp)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 822e774:	e0bffe17 	ldw	r2,-8(fp)
 822e778:	108000cc 	andi	r2,r2,3
 822e77c:	1000051e 	bne	r2,zero,822e794 <m_copy+0x118>
          (m->pkt->inuse != 1))
 822e780:	e0bffd17 	ldw	r2,-12(fp)
 822e784:	10800117 	ldw	r2,4(r2)
 822e788:	10800917 	ldw	r2,36(r2)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 822e78c:	10800060 	cmpeqi	r2,r2,1
 822e790:	1000251e 	bne	r2,zero,822e828 <m_copy+0x1ac>
          (m->pkt->inuse != 1))
      {
         if ((nb = m_getwithdata (m->m_type, tocopy)) == NULL)
 822e794:	e0bffd17 	ldw	r2,-12(fp)
 822e798:	10800817 	ldw	r2,32(r2)
 822e79c:	e17ffc17 	ldw	r5,-16(fp)
 822e7a0:	1009883a 	mov	r4,r2
 822e7a4:	822e3a80 	call	822e3a8 <m_getnbuf>
 822e7a8:	e0bff915 	stw	r2,-28(fp)
 822e7ac:	e0bff917 	ldw	r2,-28(fp)
 822e7b0:	10006426 	beq	r2,zero,822e944 <m_copy+0x2c8>
            goto nospace;
         MEMCPY(nb->m_data, m->m_data+off, tocopy);
 822e7b4:	e0bff917 	ldw	r2,-28(fp)
 822e7b8:	11000317 	ldw	r4,12(r2)
 822e7bc:	e0bffd17 	ldw	r2,-12(fp)
 822e7c0:	10c00317 	ldw	r3,12(r2)
 822e7c4:	e0bffe17 	ldw	r2,-8(fp)
 822e7c8:	1885883a 	add	r2,r3,r2
 822e7cc:	e0fffc17 	ldw	r3,-16(fp)
 822e7d0:	180d883a 	mov	r6,r3
 822e7d4:	100b883a 	mov	r5,r2
 822e7d8:	8202f100 	call	8202f10 <memcpy>
         nb->m_len = tocopy;  /* set length of data we just moved into new mbuf */
 822e7dc:	e0fffc17 	ldw	r3,-16(fp)
 822e7e0:	e0bff917 	ldw	r2,-28(fp)
 822e7e4:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mcopies++;
 822e7e8:	008209b4 	movhi	r2,2086
 822e7ec:	10b98b04 	addi	r2,r2,-6612
 822e7f0:	10802e17 	ldw	r2,184(r2)
 822e7f4:	10c00044 	addi	r3,r2,1
 822e7f8:	008209b4 	movhi	r2,2086
 822e7fc:	10b98b04 	addi	r2,r2,-6612
 822e800:	10c02e15 	stw	r3,184(r2)
         tcpstat.tcps_mcopiedbytes += tocopy;
 822e804:	008209b4 	movhi	r2,2086
 822e808:	10b98b04 	addi	r2,r2,-6612
 822e80c:	10c03017 	ldw	r3,192(r2)
 822e810:	e0bffc17 	ldw	r2,-16(fp)
 822e814:	1887883a 	add	r3,r3,r2
 822e818:	008209b4 	movhi	r2,2086
 822e81c:	10b98b04 	addi	r2,r2,-6612
 822e820:	10c03015 	stw	r3,192(r2)
 822e824:	00003106 	br	822e8ec <m_copy+0x270>
      {
         /* Rather than memcpy every mbuf's data, "clone" the data by 
          * making a duplicate of the mbufs involved and bumping the 
          * inuse count of the actual packet structs
          */
         if ((nb = m_getwithdata (m->m_type, 0)) == NULL)
 822e828:	e0bffd17 	ldw	r2,-12(fp)
 822e82c:	10800817 	ldw	r2,32(r2)
 822e830:	000b883a 	mov	r5,zero
 822e834:	1009883a 	mov	r4,r2
 822e838:	822e3a80 	call	822e3a8 <m_getnbuf>
 822e83c:	e0bff915 	stw	r2,-28(fp)
 822e840:	e0bff917 	ldw	r2,-28(fp)
 822e844:	10004126 	beq	r2,zero,822e94c <m_copy+0x2d0>
            goto nospace;

         m->pkt->inuse++;     /* bump pkt use count to clone it */
 822e848:	e0bffd17 	ldw	r2,-12(fp)
 822e84c:	10800117 	ldw	r2,4(r2)
 822e850:	10c00917 	ldw	r3,36(r2)
 822e854:	18c00044 	addi	r3,r3,1
 822e858:	10c00915 	stw	r3,36(r2)

         /* set up new mbuf with pointers to cloned packet */
         nb->pkt = m->pkt;
 822e85c:	e0bffd17 	ldw	r2,-12(fp)
 822e860:	10c00117 	ldw	r3,4(r2)
 822e864:	e0bff917 	ldw	r2,-28(fp)
 822e868:	10c00115 	stw	r3,4(r2)
         nb->m_base = m->m_base;
 822e86c:	e0bffd17 	ldw	r2,-12(fp)
 822e870:	10c00417 	ldw	r3,16(r2)
 822e874:	e0bff917 	ldw	r2,-28(fp)
 822e878:	10c00415 	stw	r3,16(r2)
         nb->m_memsz = m->m_memsz;
 822e87c:	e0bffd17 	ldw	r2,-12(fp)
 822e880:	10c00517 	ldw	r3,20(r2)
 822e884:	e0bff917 	ldw	r2,-28(fp)
 822e888:	10c00515 	stw	r3,20(r2)
         nb->m_data = m->m_data + off;
 822e88c:	e0bffd17 	ldw	r2,-12(fp)
 822e890:	10c00317 	ldw	r3,12(r2)
 822e894:	e0bffe17 	ldw	r2,-8(fp)
 822e898:	1887883a 	add	r3,r3,r2
 822e89c:	e0bff917 	ldw	r2,-28(fp)
 822e8a0:	10c00315 	stw	r3,12(r2)
         nb->m_len = tocopy;
 822e8a4:	e0fffc17 	ldw	r3,-16(fp)
 822e8a8:	e0bff917 	ldw	r2,-28(fp)
 822e8ac:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mclones++;
 822e8b0:	008209b4 	movhi	r2,2086
 822e8b4:	10b98b04 	addi	r2,r2,-6612
 822e8b8:	10802f17 	ldw	r2,188(r2)
 822e8bc:	10c00044 	addi	r3,r2,1
 822e8c0:	008209b4 	movhi	r2,2086
 822e8c4:	10b98b04 	addi	r2,r2,-6612
 822e8c8:	10c02f15 	stw	r3,188(r2)
         tcpstat.tcps_mclonedbytes += tocopy;
 822e8cc:	008209b4 	movhi	r2,2086
 822e8d0:	10b98b04 	addi	r2,r2,-6612
 822e8d4:	10c03117 	ldw	r3,196(r2)
 822e8d8:	e0bffc17 	ldw	r2,-16(fp)
 822e8dc:	1887883a 	add	r3,r3,r2
 822e8e0:	008209b4 	movhi	r2,2086
 822e8e4:	10b98b04 	addi	r2,r2,-6612
 822e8e8:	10c03115 	stw	r3,196(r2)
      }

      len -= tocopy;
 822e8ec:	e0ffff17 	ldw	r3,-4(fp)
 822e8f0:	e0bffc17 	ldw	r2,-16(fp)
 822e8f4:	1885c83a 	sub	r2,r3,r2
 822e8f8:	e0bfff15 	stw	r2,-4(fp)
      off = 0;
 822e8fc:	e03ffe15 	stw	zero,-8(fp)
      if (tail)      /* head & tail are set by first pass thru loop */
 822e900:	e0bffb17 	ldw	r2,-20(fp)
 822e904:	10000426 	beq	r2,zero,822e918 <m_copy+0x29c>
         tail->m_next = nb;
 822e908:	e0bffb17 	ldw	r2,-20(fp)
 822e90c:	e0fff917 	ldw	r3,-28(fp)
 822e910:	10c00615 	stw	r3,24(r2)
 822e914:	00000206 	br	822e920 <m_copy+0x2a4>
      else
         head = nb;
 822e918:	e0bff917 	ldw	r2,-28(fp)
 822e91c:	e0bffa15 	stw	r2,-24(fp)
      tail = nb;     /* always make new mbuf the tail */
 822e920:	e0bff917 	ldw	r2,-28(fp)
 822e924:	e0bffb15 	stw	r2,-20(fp)
      m = m->m_next;
 822e928:	e0bffd17 	ldw	r2,-12(fp)
 822e92c:	10800617 	ldw	r2,24(r2)
 822e930:	e0bffd15 	stw	r2,-12(fp)
      m = m->m_next;
   }

   head = tail = NULL;

   while (len > 0)
 822e934:	e0bfff17 	ldw	r2,-4(fp)
 822e938:	00bf7f16 	blt	zero,r2,822e738 <m_copy+0xbc>
      tail = nb;     /* always make new mbuf the tail */
      m = m->m_next;

   }

   return head;
 822e93c:	e0bffa17 	ldw	r2,-24(fp)
 822e940:	00000606 	br	822e95c <m_copy+0x2e0>
       */
      if ((off & (ALIGN_TYPE - 1)) ||
          (m->pkt->inuse != 1))
      {
         if ((nb = m_getwithdata (m->m_type, tocopy)) == NULL)
            goto nospace;
 822e944:	0001883a 	nop
 822e948:	00000106 	br	822e950 <m_copy+0x2d4>
         /* Rather than memcpy every mbuf's data, "clone" the data by 
          * making a duplicate of the mbufs involved and bumping the 
          * inuse count of the actual packet structs
          */
         if ((nb = m_getwithdata (m->m_type, 0)) == NULL)
            goto nospace;
 822e94c:	0001883a 	nop
   }

   return head;

nospace:
   m_freem (head);
 822e950:	e13ffa17 	ldw	r4,-24(fp)
 822e954:	822e6380 	call	822e638 <m_freem>
   return NULL;
 822e958:	0005883a 	mov	r2,zero
}
 822e95c:	e037883a 	mov	sp,fp
 822e960:	dfc00117 	ldw	ra,4(sp)
 822e964:	df000017 	ldw	fp,0(sp)
 822e968:	dec00204 	addi	sp,sp,8
 822e96c:	f800283a 	ret

0822e970 <m_adj>:
 * RETURNS: 
 */

void
m_adj(struct mbuf * mp, int len)
{
 822e970:	defffb04 	addi	sp,sp,-20
 822e974:	df000415 	stw	fp,16(sp)
 822e978:	df000404 	addi	fp,sp,16
 822e97c:	e13ffe15 	stw	r4,-8(fp)
 822e980:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;
   int   count;

   if ((m = mp) == NULL)
 822e984:	e0bffe17 	ldw	r2,-8(fp)
 822e988:	e0bffc15 	stw	r2,-16(fp)
 822e98c:	e0bffc17 	ldw	r2,-16(fp)
 822e990:	10006226 	beq	r2,zero,822eb1c <m_adj+0x1ac>
      return;

   if (len >= 0) 
 822e994:	e0bfff17 	ldw	r2,-4(fp)
 822e998:	10002216 	blt	r2,zero,822ea24 <m_adj+0xb4>
   {
      while (m != NULL && len > 0) 
 822e99c:	00001c06 	br	822ea10 <m_adj+0xa0>
      {
         if (m->m_len <= (unsigned)len)
 822e9a0:	e0bffc17 	ldw	r2,-16(fp)
 822e9a4:	10800217 	ldw	r2,8(r2)
 822e9a8:	e0ffff17 	ldw	r3,-4(fp)
 822e9ac:	18800b36 	bltu	r3,r2,822e9dc <m_adj+0x6c>
         {
            len -= m->m_len;
 822e9b0:	e0ffff17 	ldw	r3,-4(fp)
 822e9b4:	e0bffc17 	ldw	r2,-16(fp)
 822e9b8:	10800217 	ldw	r2,8(r2)
 822e9bc:	1885c83a 	sub	r2,r3,r2
 822e9c0:	e0bfff15 	stw	r2,-4(fp)
            m->m_len = 0;
 822e9c4:	e0bffc17 	ldw	r2,-16(fp)
 822e9c8:	10000215 	stw	zero,8(r2)
            m = m->m_next;
 822e9cc:	e0bffc17 	ldw	r2,-16(fp)
 822e9d0:	10800617 	ldw	r2,24(r2)
 822e9d4:	e0bffc15 	stw	r2,-16(fp)
 822e9d8:	00000d06 	br	822ea10 <m_adj+0xa0>
         }
         else
         {
            m->m_len -= len;
 822e9dc:	e0bffc17 	ldw	r2,-16(fp)
 822e9e0:	10c00217 	ldw	r3,8(r2)
 822e9e4:	e0bfff17 	ldw	r2,-4(fp)
 822e9e8:	1887c83a 	sub	r3,r3,r2
 822e9ec:	e0bffc17 	ldw	r2,-16(fp)
 822e9f0:	10c00215 	stw	r3,8(r2)
            m->m_data += len;
 822e9f4:	e0bffc17 	ldw	r2,-16(fp)
 822e9f8:	10c00317 	ldw	r3,12(r2)
 822e9fc:	e0bfff17 	ldw	r2,-4(fp)
 822ea00:	1887883a 	add	r3,r3,r2
 822ea04:	e0bffc17 	ldw	r2,-16(fp)
 822ea08:	10c00315 	stw	r3,12(r2)
            break;
 822ea0c:	00004406 	br	822eb20 <m_adj+0x1b0>
   if ((m = mp) == NULL)
      return;

   if (len >= 0) 
   {
      while (m != NULL && len > 0) 
 822ea10:	e0bffc17 	ldw	r2,-16(fp)
 822ea14:	10004226 	beq	r2,zero,822eb20 <m_adj+0x1b0>
 822ea18:	e0bfff17 	ldw	r2,-4(fp)
 822ea1c:	00bfe016 	blt	zero,r2,822e9a0 <m_adj+0x30>
 822ea20:	00003f06 	br	822eb20 <m_adj+0x1b0>
       * calculating its length and finding the last mbuf.
       * If the adjustment only affects this mbuf, then just
       * adjust and return.  Otherwise, rescan and truncate
       * after the remaining size.
       */
      len = -len;
 822ea24:	e0bfff17 	ldw	r2,-4(fp)
 822ea28:	0085c83a 	sub	r2,zero,r2
 822ea2c:	e0bfff15 	stw	r2,-4(fp)
      count = 0;
 822ea30:	e03ffd15 	stw	zero,-12(fp)
      for (;;) 
      {
         count += m->m_len;
 822ea34:	e0bffc17 	ldw	r2,-16(fp)
 822ea38:	10c00217 	ldw	r3,8(r2)
 822ea3c:	e0bffd17 	ldw	r2,-12(fp)
 822ea40:	1885883a 	add	r2,r3,r2
 822ea44:	e0bffd15 	stw	r2,-12(fp)
         if (m->m_next == (struct mbuf *)0)
 822ea48:	e0bffc17 	ldw	r2,-16(fp)
 822ea4c:	10800617 	ldw	r2,24(r2)
 822ea50:	10000426 	beq	r2,zero,822ea64 <m_adj+0xf4>
            break;
         m = m->m_next;
 822ea54:	e0bffc17 	ldw	r2,-16(fp)
 822ea58:	10800617 	ldw	r2,24(r2)
 822ea5c:	e0bffc15 	stw	r2,-16(fp)
      }
 822ea60:	003ff406 	br	822ea34 <m_adj+0xc4>
      count = 0;
      for (;;) 
      {
         count += m->m_len;
         if (m->m_next == (struct mbuf *)0)
            break;
 822ea64:	0001883a 	nop
         m = m->m_next;
      }
      if (m->m_len >= (unsigned)len)
 822ea68:	e0bffc17 	ldw	r2,-16(fp)
 822ea6c:	10c00217 	ldw	r3,8(r2)
 822ea70:	e0bfff17 	ldw	r2,-4(fp)
 822ea74:	18800736 	bltu	r3,r2,822ea94 <m_adj+0x124>
      {
         m->m_len -= len;
 822ea78:	e0bffc17 	ldw	r2,-16(fp)
 822ea7c:	10c00217 	ldw	r3,8(r2)
 822ea80:	e0bfff17 	ldw	r2,-4(fp)
 822ea84:	1887c83a 	sub	r3,r3,r2
 822ea88:	e0bffc17 	ldw	r2,-16(fp)
 822ea8c:	10c00215 	stw	r3,8(r2)
         return;
 822ea90:	00002306 	br	822eb20 <m_adj+0x1b0>
      }
      count -= len;
 822ea94:	e0fffd17 	ldw	r3,-12(fp)
 822ea98:	e0bfff17 	ldw	r2,-4(fp)
 822ea9c:	1885c83a 	sub	r2,r3,r2
 822eaa0:	e0bffd15 	stw	r2,-12(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 822eaa4:	e0bffe17 	ldw	r2,-8(fp)
 822eaa8:	e0bffc15 	stw	r2,-16(fp)
 822eaac:	00001006 	br	822eaf0 <m_adj+0x180>
      {
         if (m->m_len >= (unsigned)count)
 822eab0:	e0bffc17 	ldw	r2,-16(fp)
 822eab4:	10c00217 	ldw	r3,8(r2)
 822eab8:	e0bffd17 	ldw	r2,-12(fp)
 822eabc:	18800436 	bltu	r3,r2,822ead0 <m_adj+0x160>
         {
            m->m_len = count;
 822eac0:	e0fffd17 	ldw	r3,-12(fp)
 822eac4:	e0bffc17 	ldw	r2,-16(fp)
 822eac8:	10c00215 	stw	r3,8(r2)
            break;
 822eacc:	00000a06 	br	822eaf8 <m_adj+0x188>
         }
         count -= m->m_len;
 822ead0:	e0fffd17 	ldw	r3,-12(fp)
 822ead4:	e0bffc17 	ldw	r2,-16(fp)
 822ead8:	10800217 	ldw	r2,8(r2)
 822eadc:	1885c83a 	sub	r2,r3,r2
 822eae0:	e0bffd15 	stw	r2,-12(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 822eae4:	e0bffc17 	ldw	r2,-16(fp)
 822eae8:	10800617 	ldw	r2,24(r2)
 822eaec:	e0bffc15 	stw	r2,-16(fp)
 822eaf0:	e0bffc17 	ldw	r2,-16(fp)
 822eaf4:	103fee1e 	bne	r2,zero,822eab0 <m_adj+0x140>
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 822eaf8:	00000206 	br	822eb04 <m_adj+0x194>
         m->m_len = 0;
 822eafc:	e0bffc17 	ldw	r2,-16(fp)
 822eb00:	10000215 	stw	zero,8(r2)
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 822eb04:	e0bffc17 	ldw	r2,-16(fp)
 822eb08:	10800617 	ldw	r2,24(r2)
 822eb0c:	e0bffc15 	stw	r2,-16(fp)
 822eb10:	e0bffc17 	ldw	r2,-16(fp)
 822eb14:	103ff91e 	bne	r2,zero,822eafc <m_adj+0x18c>
 822eb18:	00000106 	br	822eb20 <m_adj+0x1b0>
{
   struct mbuf *  m;
   int   count;

   if ((m = mp) == NULL)
      return;
 822eb1c:	0001883a 	nop
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
         m->m_len = 0;
   }
}
 822eb20:	e037883a 	mov	sp,fp
 822eb24:	df000017 	ldw	fp,0(sp)
 822eb28:	dec00104 	addi	sp,sp,4
 822eb2c:	f800283a 	ret

0822eb30 <mbuf_len>:
 * RETURNS: 
 */

int
mbuf_len (struct mbuf * m)
{
 822eb30:	defffd04 	addi	sp,sp,-12
 822eb34:	df000215 	stw	fp,8(sp)
 822eb38:	df000204 	addi	fp,sp,8
 822eb3c:	e13fff15 	stw	r4,-4(fp)
   int   len   =  0;
 822eb40:	e03ffe15 	stw	zero,-8(fp)

   while (m)
 822eb44:	00000806 	br	822eb68 <mbuf_len+0x38>
   {
      len += m->m_len;
 822eb48:	e0bfff17 	ldw	r2,-4(fp)
 822eb4c:	10c00217 	ldw	r3,8(r2)
 822eb50:	e0bffe17 	ldw	r2,-8(fp)
 822eb54:	1885883a 	add	r2,r3,r2
 822eb58:	e0bffe15 	stw	r2,-8(fp)
      m = m->m_next;
 822eb5c:	e0bfff17 	ldw	r2,-4(fp)
 822eb60:	10800617 	ldw	r2,24(r2)
 822eb64:	e0bfff15 	stw	r2,-4(fp)
int
mbuf_len (struct mbuf * m)
{
   int   len   =  0;

   while (m)
 822eb68:	e0bfff17 	ldw	r2,-4(fp)
 822eb6c:	103ff61e 	bne	r2,zero,822eb48 <mbuf_len+0x18>
   {
      len += m->m_len;
      m = m->m_next;
   }
   return len;
 822eb70:	e0bffe17 	ldw	r2,-8(fp)
}
 822eb74:	e037883a 	mov	sp,fp
 822eb78:	df000017 	ldw	fp,0(sp)
 822eb7c:	dec00104 	addi	sp,sp,4
 822eb80:	f800283a 	ret

0822eb84 <dtom>:
 * RETURNS: 
 */

struct mbuf *  
dtom(void * data)
{
 822eb84:	defffb04 	addi	sp,sp,-20
 822eb88:	dfc00415 	stw	ra,16(sp)
 822eb8c:	df000315 	stw	fp,12(sp)
 822eb90:	df000304 	addi	fp,sp,12
 822eb94:	e13fff15 	stw	r4,-4(fp)
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 822eb98:	008209b4 	movhi	r2,2086
 822eb9c:	10b96c04 	addi	r2,r2,-6736
 822eba0:	10800017 	ldw	r2,0(r2)
 822eba4:	e0bffd15 	stw	r2,-12(fp)
 822eba8:	00001206 	br	822ebf4 <dtom+0x70>
   {
      m = (struct mbuf *)qptr;
 822ebac:	e0bffd17 	ldw	r2,-12(fp)
 822ebb0:	e0bffe15 	stw	r2,-8(fp)

      if (IN_RANGE(m->m_base, m->m_memsz, (char*)data))
 822ebb4:	e0bffe17 	ldw	r2,-8(fp)
 822ebb8:	10800417 	ldw	r2,16(r2)
 822ebbc:	e0ffff17 	ldw	r3,-4(fp)
 822ebc0:	18800936 	bltu	r3,r2,822ebe8 <dtom+0x64>
 822ebc4:	e0bffe17 	ldw	r2,-8(fp)
 822ebc8:	10c00417 	ldw	r3,16(r2)
 822ebcc:	e0bffe17 	ldw	r2,-8(fp)
 822ebd0:	10800517 	ldw	r2,20(r2)
 822ebd4:	1885883a 	add	r2,r3,r2
 822ebd8:	e0ffff17 	ldw	r3,-4(fp)
 822ebdc:	1880022e 	bgeu	r3,r2,822ebe8 <dtom+0x64>
         return (struct mbuf *)qptr;
 822ebe0:	e0bffd17 	ldw	r2,-12(fp)
 822ebe4:	00000906 	br	822ec0c <dtom+0x88>
dtom(void * data)
{
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 822ebe8:	e0bffd17 	ldw	r2,-12(fp)
 822ebec:	10800017 	ldw	r2,0(r2)
 822ebf0:	e0bffd15 	stw	r2,-12(fp)
 822ebf4:	e0bffd17 	ldw	r2,-12(fp)
 822ebf8:	103fec1e 	bne	r2,zero,822ebac <dtom+0x28>
      else
         continue;

   }

   panic("dtom");    /* data not found in any "in use" mbuf */
 822ebfc:	01020974 	movhi	r4,2085
 822ec00:	21036004 	addi	r4,r4,3456
 822ec04:	8228c480 	call	8228c48 <panic>
   return NULL;
 822ec08:	0005883a 	mov	r2,zero
}
 822ec0c:	e037883a 	mov	sp,fp
 822ec10:	dfc00117 	ldw	ra,4(sp)
 822ec14:	df000017 	ldw	fp,0(sp)
 822ec18:	dec00204 	addi	sp,sp,8
 822ec1c:	f800283a 	ret

0822ec20 <remque>:
};


void
remque (void * arg)
{
 822ec20:	defffd04 	addi	sp,sp,-12
 822ec24:	df000215 	stw	fp,8(sp)
 822ec28:	df000204 	addi	fp,sp,8
 822ec2c:	e13fff15 	stw	r4,-4(fp)
   struct bsdq *  old;

   old = (struct bsdq *)arg;
 822ec30:	e0bfff17 	ldw	r2,-4(fp)
 822ec34:	e0bffe15 	stw	r2,-8(fp)
   if (!old->prev) return;
 822ec38:	e0bffe17 	ldw	r2,-8(fp)
 822ec3c:	10800117 	ldw	r2,4(r2)
 822ec40:	10000e26 	beq	r2,zero,822ec7c <remque+0x5c>
      old->prev->next = old->next;
 822ec44:	e0bffe17 	ldw	r2,-8(fp)
 822ec48:	10800117 	ldw	r2,4(r2)
 822ec4c:	e0fffe17 	ldw	r3,-8(fp)
 822ec50:	18c00017 	ldw	r3,0(r3)
 822ec54:	10c00015 	stw	r3,0(r2)
   if (old->next)
 822ec58:	e0bffe17 	ldw	r2,-8(fp)
 822ec5c:	10800017 	ldw	r2,0(r2)
 822ec60:	10000726 	beq	r2,zero,822ec80 <remque+0x60>
      old->next->prev = old->prev;
 822ec64:	e0bffe17 	ldw	r2,-8(fp)
 822ec68:	10800017 	ldw	r2,0(r2)
 822ec6c:	e0fffe17 	ldw	r3,-8(fp)
 822ec70:	18c00117 	ldw	r3,4(r3)
 822ec74:	10c00115 	stw	r3,4(r2)
 822ec78:	00000106 	br	822ec80 <remque+0x60>
remque (void * arg)
{
   struct bsdq *  old;

   old = (struct bsdq *)arg;
   if (!old->prev) return;
 822ec7c:	0001883a 	nop
      old->prev->next = old->next;
   if (old->next)
      old->next->prev = old->prev;
}
 822ec80:	e037883a 	mov	sp,fp
 822ec84:	df000017 	ldw	fp,0(sp)
 822ec88:	dec00104 	addi	sp,sp,4
 822ec8c:	f800283a 	ret

0822ec90 <insque>:
 * RETURNS: 
 */

void
insque(void * n, void * p)
{
 822ec90:	defffb04 	addi	sp,sp,-20
 822ec94:	df000415 	stw	fp,16(sp)
 822ec98:	df000404 	addi	fp,sp,16
 822ec9c:	e13ffe15 	stw	r4,-8(fp)
 822eca0:	e17fff15 	stw	r5,-4(fp)
   struct bsdq *  newe, *  prev;

   newe = (struct bsdq *)n;
 822eca4:	e0bffe17 	ldw	r2,-8(fp)
 822eca8:	e0bffc15 	stw	r2,-16(fp)
   prev = (struct bsdq *)p;
 822ecac:	e0bfff17 	ldw	r2,-4(fp)
 822ecb0:	e0bffd15 	stw	r2,-12(fp)
   newe->next = prev->next;
 822ecb4:	e0bffd17 	ldw	r2,-12(fp)
 822ecb8:	10c00017 	ldw	r3,0(r2)
 822ecbc:	e0bffc17 	ldw	r2,-16(fp)
 822ecc0:	10c00015 	stw	r3,0(r2)
   newe->prev = prev;
 822ecc4:	e0bffc17 	ldw	r2,-16(fp)
 822ecc8:	e0fffd17 	ldw	r3,-12(fp)
 822eccc:	10c00115 	stw	r3,4(r2)
   prev->next = newe;
 822ecd0:	e0bffd17 	ldw	r2,-12(fp)
 822ecd4:	e0fffc17 	ldw	r3,-16(fp)
 822ecd8:	10c00015 	stw	r3,0(r2)
   if (newe->next)
 822ecdc:	e0bffc17 	ldw	r2,-16(fp)
 822ece0:	10800017 	ldw	r2,0(r2)
 822ece4:	10000426 	beq	r2,zero,822ecf8 <insque+0x68>
      newe->next->prev = newe;
 822ece8:	e0bffc17 	ldw	r2,-16(fp)
 822ecec:	10800017 	ldw	r2,0(r2)
 822ecf0:	e0fffc17 	ldw	r3,-16(fp)
 822ecf4:	10c00115 	stw	r3,4(r2)
}
 822ecf8:	0001883a 	nop
 822ecfc:	e037883a 	mov	sp,fp
 822ed00:	df000017 	ldw	fp,0(sp)
 822ed04:	dec00104 	addi	sp,sp,4
 822ed08:	f800283a 	ret

0822ed0c <nptcp_init>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
nptcp_init()
{
 822ed0c:	defffb04 	addi	sp,sp,-20
 822ed10:	dfc00415 	stw	ra,16(sp)
 822ed14:	df000315 	stw	fp,12(sp)
 822ed18:	df000304 	addi	fp,sp,12
    * buffers, soreceive() can't complete and the packet buffers stay 
    * on the queue, so we allocate 3 extra mbufs in the hope that 
    * this will allow soreceive() to complete and free up the packet 
    * buffers. yes, its kind of an ugly hack and 3 is a wild guess.
    */
   unsigned bufcount = (lilbufs + bigbufs) * 2 + 3;
 822ed1c:	d0e03617 	ldw	r3,-32552(gp)
 822ed20:	d0a03817 	ldw	r2,-32544(gp)
 822ed24:	1885883a 	add	r2,r3,r2
 822ed28:	1085883a 	add	r2,r2,r2
 822ed2c:	108000c4 	addi	r2,r2,3
 822ed30:	e0bffe15 	stw	r2,-8(fp)
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
 822ed34:	01800504 	movi	r6,20
 822ed38:	000b883a 	mov	r5,zero
 822ed3c:	010209b4 	movhi	r4,2086
 822ed40:	21395804 	addi	r4,r4,-6816
 822ed44:	82031b40 	call	82031b4 <memset>
   MEMSET(&mbufq, 0, sizeof(mbufq));
 822ed48:	01800504 	movi	r6,20
 822ed4c:	000b883a 	mov	r5,zero
 822ed50:	010209b4 	movhi	r4,2086
 822ed54:	21396c04 	addi	r4,r4,-6736
 822ed58:	82031b40 	call	82031b4 <memset>
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
 822ed5c:	01800504 	movi	r6,20
 822ed60:	000b883a 	mov	r5,zero
 822ed64:	010209b4 	movhi	r4,2086
 822ed68:	21397104 	addi	r4,r4,-6716
 822ed6c:	82031b40 	call	82031b4 <memset>
   for (i = 0; i < (int)bufcount; i++)
 822ed70:	e03ffd15 	stw	zero,-12(fp)
 822ed74:	00001506 	br	822edcc <nptcp_init+0xc0>
   {
      m = MBU_ALLOC(sizeof(struct mbuf));
 822ed78:	01000904 	movi	r4,36
 822ed7c:	822e16c0 	call	822e16c <npalloc>
 822ed80:	e0bfff15 	stw	r2,-4(fp)
      if (!m)  /* malloc error, bail out */
 822ed84:	e0bfff17 	ldw	r2,-4(fp)
 822ed88:	1000031e 	bne	r2,zero,822ed98 <nptcp_init+0x8c>
         panic("tcpinit");
 822ed8c:	01020974 	movhi	r4,2085
 822ed90:	21036204 	addi	r4,r4,3464
 822ed94:	8228c480 	call	8228c48 <panic>
      m->m_type = MT_FREE;
 822ed98:	e0bfff17 	ldw	r2,-4(fp)
 822ed9c:	10000815 	stw	zero,32(r2)
      m->m_len = 0;
 822eda0:	e0bfff17 	ldw	r2,-4(fp)
 822eda4:	10000215 	stw	zero,8(r2)
      m->m_data = NULL;
 822eda8:	e0bfff17 	ldw	r2,-4(fp)
 822edac:	10000315 	stw	zero,12(r2)
      putq(&mfreeq, (qp)m);
 822edb0:	e17fff17 	ldw	r5,-4(fp)
 822edb4:	010209b4 	movhi	r4,2086
 822edb8:	21397104 	addi	r4,r4,-6716
 822edbc:	822cf7c0 	call	822cf7c <putq>
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
   MEMSET(&mbufq, 0, sizeof(mbufq));
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
   for (i = 0; i < (int)bufcount; i++)
 822edc0:	e0bffd17 	ldw	r2,-12(fp)
 822edc4:	10800044 	addi	r2,r2,1
 822edc8:	e0bffd15 	stw	r2,-12(fp)
 822edcc:	e0bffe17 	ldw	r2,-8(fp)
 822edd0:	e0fffd17 	ldw	r3,-12(fp)
 822edd4:	18bfe816 	blt	r3,r2,822ed78 <nptcp_init+0x6c>
      m->m_type = MT_FREE;
      m->m_len = 0;
      m->m_data = NULL;
      putq(&mfreeq, (qp)m);
   }
   mfreeq.q_min = (int)bufcount;   /* this should match q_max and q_len */
 822edd8:	e0fffe17 	ldw	r3,-8(fp)
 822eddc:	008209b4 	movhi	r2,2086
 822ede0:	10b97104 	addi	r2,r2,-6716
 822ede4:	10c00415 	stw	r3,16(r2)
   tcpmib.tcpRtoAlgorithm = 4;     /* Van Jacobson's algorithm */
   tcpmib.tcpRtoMin = TCPTV_MIN * 1000;      /* PR_SLOWHZ */
   tcpmib.tcpRtoMax = TCPTV_REXMTMAX * 1000; /* PR_SLOWHZ */
#endif

   tcp_init();    /* call the BSD init in tcp_usr.c */
 822ede8:	82394cc0 	call	82394cc <tcp_init>

#ifdef TCP_MENUS
   install_menu(&tcpmenu[0]);
#endif   /* IN_MENUS */

   return 0;   /* good return */
 822edec:	0005883a 	mov	r2,zero
}
 822edf0:	e037883a 	mov	sp,fp
 822edf4:	dfc00117 	ldw	ra,4(sp)
 822edf8:	df000017 	ldw	fp,0(sp)
 822edfc:	dec00204 	addi	sp,sp,8
 822ee00:	f800283a 	ret

0822ee04 <tcp_rcv>:

#ifdef IP_V4
 
int
tcp_rcv(PACKET pkt)     /* NOTE: pkt has nb_prot pointing to IP header */
{
 822ee04:	defff904 	addi	sp,sp,-28
 822ee08:	dfc00615 	stw	ra,24(sp)
 822ee0c:	df000515 	stw	fp,20(sp)
 822ee10:	df000504 	addi	fp,sp,20
 822ee14:	e13fff15 	stw	r4,-4(fp)

   /* For TCP, the netport IP layer is modified to set nb_prot to the 
    * start of the IP header (not TCP). We need to do some further
    * mods which the BSD code expects:
    */
   bip = (struct ip *)pkt->nb_prot;    /* get ip header */
 822ee18:	e0bfff17 	ldw	r2,-4(fp)
 822ee1c:	10800317 	ldw	r2,12(r2)
 822ee20:	e0bffb15 	stw	r2,-20(fp)
   len = ntohs(bip->ip_len);  /* get length in local endian */
 822ee24:	e0bffb17 	ldw	r2,-20(fp)
 822ee28:	1080008b 	ldhu	r2,2(r2)
 822ee2c:	10bfffcc 	andi	r2,r2,65535
 822ee30:	1004d23a 	srli	r2,r2,8
 822ee34:	1007883a 	mov	r3,r2
 822ee38:	e0bffb17 	ldw	r2,-20(fp)
 822ee3c:	1080008b 	ldhu	r2,2(r2)
 822ee40:	10bfffcc 	andi	r2,r2,65535
 822ee44:	1004923a 	slli	r2,r2,8
 822ee48:	1884b03a 	or	r2,r3,r2
 822ee4c:	e0bffc0d 	sth	r2,-16(fp)

   /* verify checksum of received packet */

   tcpp = (struct tcphdr *)ip_data(bip);
 822ee50:	e0bffb17 	ldw	r2,-20(fp)
 822ee54:	10800003 	ldbu	r2,0(r2)
 822ee58:	10803fcc 	andi	r2,r2,255
 822ee5c:	108003cc 	andi	r2,r2,15
 822ee60:	1085883a 	add	r2,r2,r2
 822ee64:	1085883a 	add	r2,r2,r2
 822ee68:	1007883a 	mov	r3,r2
 822ee6c:	e0bffb17 	ldw	r2,-20(fp)
 822ee70:	10c5883a 	add	r2,r2,r3
 822ee74:	e0bffd15 	stw	r2,-12(fp)
   if (tcp_cksum(bip) != tcpp->th_sum)
 822ee78:	e13ffb17 	ldw	r4,-20(fp)
 822ee7c:	8247c980 	call	8247c98 <tcp_cksum>
 822ee80:	1007883a 	mov	r3,r2
 822ee84:	e0bffd17 	ldw	r2,-12(fp)
 822ee88:	1080040b 	ldhu	r2,16(r2)
 822ee8c:	18ffffcc 	andi	r3,r3,65535
 822ee90:	10bfffcc 	andi	r2,r2,65535
 822ee94:	18801626 	beq	r3,r2,822eef0 <tcp_rcv+0xec>
   {
      TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 822ee98:	008209b4 	movhi	r2,2086
 822ee9c:	10b95d04 	addi	r2,r2,-6796
 822eea0:	10800d17 	ldw	r2,52(r2)
 822eea4:	10c00044 	addi	r3,r2,1
 822eea8:	008209b4 	movhi	r2,2086
 822eeac:	10b95d04 	addi	r2,r2,-6796
 822eeb0:	10c00d15 	stw	r3,52(r2)
      tcpstat.tcps_rcvbadsum++;  /* keep BSD stats */
 822eeb4:	008209b4 	movhi	r2,2086
 822eeb8:	10b98b04 	addi	r2,r2,-6612
 822eebc:	10801c17 	ldw	r2,112(r2)
 822eec0:	10c00044 	addi	r3,r2,1
 822eec4:	008209b4 	movhi	r2,2086
 822eec8:	10b98b04 	addi	r2,r2,-6612
 822eecc:	10c01c15 	stw	r3,112(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 822eed0:	01000084 	movi	r4,2
 822eed4:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free(pkt);  /* punt packet */
 822eed8:	e13fff17 	ldw	r4,-4(fp)
 822eedc:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822eee0:	01000084 	movi	r4,2
 822eee4:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 822eee8:	00bff804 	movi	r2,-32
 822eeec:	00003406 	br	822efc0 <tcp_rcv+0x1bc>
   }

   m_in = m_getnbuf(MT_RXDATA, 0);
 822eef0:	000b883a 	mov	r5,zero
 822eef4:	01000044 	movi	r4,1
 822eef8:	822e3a80 	call	822e3a8 <m_getnbuf>
 822eefc:	e0bffe15 	stw	r2,-8(fp)
   if (!m_in){
 822ef00:	e0bffe17 	ldw	r2,-8(fp)
 822ef04:	1000081e 	bne	r2,zero,822ef28 <tcp_rcv+0x124>
      LOCK_NET_RESOURCE(FREEQ_RESID);
 822ef08:	01000084 	movi	r4,2
 822ef0c:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 822ef10:	e13fff17 	ldw	r4,-4(fp)
 822ef14:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822ef18:	01000084 	movi	r4,2
 822ef1c:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;  
 822ef20:	00bffa84 	movi	r2,-22
 822ef24:	00002606 	br	822efc0 <tcp_rcv+0x1bc>
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);      /* measure time in TCP */

   /* subtract IP header length from total IP packet length */
   len -= ((unshort)(bip->ip_ver_ihl & 0x0f) << 2);
 822ef28:	e0bffb17 	ldw	r2,-20(fp)
 822ef2c:	10800003 	ldbu	r2,0(r2)
 822ef30:	10803fcc 	andi	r2,r2,255
 822ef34:	108003cc 	andi	r2,r2,15
 822ef38:	1085883a 	add	r2,r2,r2
 822ef3c:	1085883a 	add	r2,r2,r2
 822ef40:	1007883a 	mov	r3,r2
 822ef44:	e0bffc0b 	ldhu	r2,-16(fp)
 822ef48:	10c5c83a 	sub	r2,r2,r3
 822ef4c:	e0bffc0d 	sth	r2,-16(fp)
   bip->ip_len = len;   /* put TCP length in struct for TCP code to use */
 822ef50:	e0bffb17 	ldw	r2,-20(fp)
 822ef54:	e0fffc0b 	ldhu	r3,-16(fp)
 822ef58:	10c0008d 	sth	r3,2(r2)

   /* set mbuf to point to start of IP header (not TCP) */
   m_in->pkt = pkt;
 822ef5c:	e0bffe17 	ldw	r2,-8(fp)
 822ef60:	e0ffff17 	ldw	r3,-4(fp)
 822ef64:	10c00115 	stw	r3,4(r2)
   m_in->m_data = pkt->nb_prot;
 822ef68:	e0bfff17 	ldw	r2,-4(fp)
 822ef6c:	10c00317 	ldw	r3,12(r2)
 822ef70:	e0bffe17 	ldw	r2,-8(fp)
 822ef74:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 822ef78:	e0bfff17 	ldw	r2,-4(fp)
 822ef7c:	10c00417 	ldw	r3,16(r2)
 822ef80:	e0bffe17 	ldw	r2,-8(fp)
 822ef84:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;     /* ??? */
 822ef88:	e0bfff17 	ldw	r2,-4(fp)
 822ef8c:	10c00117 	ldw	r3,4(r2)
 822ef90:	e0bffe17 	ldw	r2,-8(fp)
 822ef94:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;    /* ??? */
 822ef98:	e0bfff17 	ldw	r2,-4(fp)
 822ef9c:	10c00217 	ldw	r3,8(r2)
 822efa0:	e0bffe17 	ldw	r2,-8(fp)
 822efa4:	10c00515 	stw	r3,20(r2)

   tcp_input(m_in, pkt->net);
 822efa8:	e0bfff17 	ldw	r2,-4(fp)
 822efac:	10800617 	ldw	r2,24(r2)
 822efb0:	100b883a 	mov	r5,r2
 822efb4:	e13ffe17 	ldw	r4,-8(fp)
 822efb8:	82359800 	call	8235980 <tcp_input>

   IN_PROFILER(PF_TCP, PF_EXIT);      /* measure time in TCP */

   return 0;
 822efbc:	0005883a 	mov	r2,zero
}
 822efc0:	e037883a 	mov	sp,fp
 822efc4:	dfc00117 	ldw	ra,4(sp)
 822efc8:	df000017 	ldw	fp,0(sp)
 822efcc:	dec00204 	addi	sp,sp,8
 822efd0:	f800283a 	ret

0822efd4 <ip_output>:
 * RETURNS: 
 */

int
ip_output(struct mbuf * data, struct   ip_socopts * so_optsPack) /* mbuf chain with data to send */
{
 822efd4:	defff404 	addi	sp,sp,-48
 822efd8:	dfc00b15 	stw	ra,44(sp)
 822efdc:	df000a15 	stw	fp,40(sp)
 822efe0:	df000a04 	addi	fp,sp,40
 822efe4:	e13ffe15 	stw	r4,-8(fp)
 822efe8:	e17fff15 	stw	r5,-4(fp)
    * little copying as possible. Typically the mbufs will be either 
    * 1) a single mbuf with iptcp header info only (e.g.tcp ACK 
    * packet), or 2) iptcp header with data mbuf chained to it, or 3) 
    * #2) with a tiny option data mbuf between header and data. 
    */
   if ((data->m_next))
 822efec:	e0bffe17 	ldw	r2,-8(fp)
 822eff0:	10800617 	ldw	r2,24(r2)
 822eff4:	10010a26 	beq	r2,zero,822f420 <ip_output+0x44c>
   {
      m1 = data;
 822eff8:	e0bffe17 	ldw	r2,-8(fp)
 822effc:	e0bff615 	stw	r2,-40(fp)
      m2 = data->m_next;
 822f000:	e0bffe17 	ldw	r2,-8(fp)
 822f004:	10800617 	ldw	r2,24(r2)
 822f008:	e0bff715 	stw	r2,-36(fp)

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 822f00c:	00003506 	br	822f0e4 <ip_output+0x110>
      {
         pkt = m1->pkt;
 822f010:	e0bff617 	ldw	r2,-40(fp)
 822f014:	10800117 	ldw	r2,4(r2)
 822f018:	e0bffa15 	stw	r2,-24(fp)
         if ((pkt->nb_buff + pkt->nb_blen) > /* make sure m2 will fit in m1 */
 822f01c:	e0bffa17 	ldw	r2,-24(fp)
 822f020:	10c00117 	ldw	r3,4(r2)
 822f024:	e0bffa17 	ldw	r2,-24(fp)
 822f028:	10800217 	ldw	r2,8(r2)
 822f02c:	1885883a 	add	r2,r3,r2
             (m1->m_data + m1->m_len + m2->m_len))
 822f030:	e0fff617 	ldw	r3,-40(fp)
 822f034:	19000317 	ldw	r4,12(r3)
 822f038:	e0fff617 	ldw	r3,-40(fp)
 822f03c:	19400217 	ldw	r5,8(r3)
 822f040:	e0fff717 	ldw	r3,-36(fp)
 822f044:	18c00217 	ldw	r3,8(r3)
 822f048:	28c7883a 	add	r3,r5,r3
 822f04c:	20c7883a 	add	r3,r4,r3

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
      {
         pkt = m1->pkt;
         if ((pkt->nb_buff + pkt->nb_blen) > /* make sure m2 will fit in m1 */
 822f050:	18802b2e 	bgeu	r3,r2,822f100 <ip_output+0x12c>
             (m1->m_data + m1->m_len + m2->m_len))
         {
            MEMCPY((m1->m_data + m1->m_len), m2->m_data, m2->m_len);
 822f054:	e0bff617 	ldw	r2,-40(fp)
 822f058:	10c00317 	ldw	r3,12(r2)
 822f05c:	e0bff617 	ldw	r2,-40(fp)
 822f060:	10800217 	ldw	r2,8(r2)
 822f064:	1887883a 	add	r3,r3,r2
 822f068:	e0bff717 	ldw	r2,-36(fp)
 822f06c:	11000317 	ldw	r4,12(r2)
 822f070:	e0bff717 	ldw	r2,-36(fp)
 822f074:	10800217 	ldw	r2,8(r2)
 822f078:	100d883a 	mov	r6,r2
 822f07c:	200b883a 	mov	r5,r4
 822f080:	1809883a 	mov	r4,r3
 822f084:	8202f100 	call	8202f10 <memcpy>
            m1->m_len += m2->m_len;
 822f088:	e0bff617 	ldw	r2,-40(fp)
 822f08c:	10c00217 	ldw	r3,8(r2)
 822f090:	e0bff717 	ldw	r2,-36(fp)
 822f094:	10800217 	ldw	r2,8(r2)
 822f098:	1887883a 	add	r3,r3,r2
 822f09c:	e0bff617 	ldw	r2,-40(fp)
 822f0a0:	10c00215 	stw	r3,8(r2)
            m1->m_next = m2->m_next;
 822f0a4:	e0bff717 	ldw	r2,-36(fp)
 822f0a8:	10c00617 	ldw	r3,24(r2)
 822f0ac:	e0bff617 	ldw	r2,-40(fp)
 822f0b0:	10c00615 	stw	r3,24(r2)
            m_free(m2);    /* free this m2.... */
 822f0b4:	e13ff717 	ldw	r4,-36(fp)
 822f0b8:	822e5300 	call	822e530 <m_free>
            m2 = m1->m_next;  /* ...and thread the next one */
 822f0bc:	e0bff617 	ldw	r2,-40(fp)
 822f0c0:	10800617 	ldw	r2,24(r2)
 822f0c4:	e0bff715 	stw	r2,-36(fp)
            tcpstat.tcps_oappends++;
 822f0c8:	008209b4 	movhi	r2,2086
 822f0cc:	10b98b04 	addi	r2,r2,-6612
 822f0d0:	10803317 	ldw	r2,204(r2)
 822f0d4:	10c00044 	addi	r3,r2,1
 822f0d8:	008209b4 	movhi	r2,2086
 822f0dc:	10b98b04 	addi	r2,r2,-6612
 822f0e0:	10c03315 	stw	r3,204(r2)
   {
      m1 = data;
      m2 = data->m_next;

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 822f0e4:	e0bff717 	ldw	r2,-36(fp)
 822f0e8:	10005b26 	beq	r2,zero,822f258 <ip_output+0x284>
 822f0ec:	e0bff717 	ldw	r2,-36(fp)
 822f0f0:	10800217 	ldw	r2,8(r2)
 822f0f4:	108002b0 	cmpltui	r2,r2,10
 822f0f8:	103fc51e 	bne	r2,zero,822f010 <ip_output+0x3c>
 822f0fc:	00005606 	br	822f258 <ip_output+0x284>
            m_free(m2);    /* free this m2.... */
            m2 = m1->m_next;  /* ...and thread the next one */
            tcpstat.tcps_oappends++;
         }
         else     /* if won't fit, fall to next copy */
            break;
 822f100:	0001883a 	nop
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 822f104:	00005406 	br	822f258 <ip_output+0x284>
      {
         /* try prepending m1 to m2, first see if it fits: */
         e = m2->m_data - m2->pkt->nb_buff;  /* e is prepend space */
 822f108:	e0bff717 	ldw	r2,-36(fp)
 822f10c:	10800317 	ldw	r2,12(r2)
 822f110:	1007883a 	mov	r3,r2
 822f114:	e0bff717 	ldw	r2,-36(fp)
 822f118:	10800117 	ldw	r2,4(r2)
 822f11c:	10800117 	ldw	r2,4(r2)
 822f120:	1885c83a 	sub	r2,r3,r2
 822f124:	e0bffb15 	stw	r2,-20(fp)
         if (e < MaxLnh)
 822f128:	d0a08117 	ldw	r2,-32252(gp)
 822f12c:	e0fffb17 	ldw	r3,-20(fp)
 822f130:	1880090e 	bge	r3,r2,822f158 <ip_output+0x184>
         { 
#ifdef NPDEBUG
            dprintf("nptcp: MaxLnh:%d, e:%d\n", MaxLnh, e);
 822f134:	d0a08117 	ldw	r2,-32252(gp)
 822f138:	e1bffb17 	ldw	r6,-20(fp)
 822f13c:	100b883a 	mov	r5,r2
 822f140:	01020974 	movhi	r4,2085
 822f144:	21036404 	addi	r4,r4,3472
 822f148:	82033a00 	call	82033a0 <printf>
#endif
            panic("tcp_out:mbuf-nbuf");   /* sanity check */
 822f14c:	01020974 	movhi	r4,2085
 822f150:	21036a04 	addi	r4,r4,3496
 822f154:	8228c480 	call	8228c48 <panic>
         }

         if ((m1->m_len < (unsigned)(e - MaxLnh))  /* leave room for MAC */
 822f158:	e0bff617 	ldw	r2,-40(fp)
 822f15c:	10800217 	ldw	r2,8(r2)
 822f160:	d0e08117 	ldw	r3,-32252(gp)
 822f164:	e13ffb17 	ldw	r4,-20(fp)
 822f168:	20c7c83a 	sub	r3,r4,r3
 822f16c:	10c03c2e 	bgeu	r2,r3,822f260 <ip_output+0x28c>
             && ((m1->m_len & (ALIGN_TYPE - 1)) == 0)  /* and stay aligned */
 822f170:	e0bff617 	ldw	r2,-40(fp)
 822f174:	10800217 	ldw	r2,8(r2)
 822f178:	108000cc 	andi	r2,r2,3
 822f17c:	1000381e 	bne	r2,zero,822f260 <ip_output+0x28c>
             && ((m2->m_data - m2->pkt->nb_buff) == HDRSLEN))   /* be at start */
 822f180:	e0bff717 	ldw	r2,-36(fp)
 822f184:	10800317 	ldw	r2,12(r2)
 822f188:	1007883a 	mov	r3,r2
 822f18c:	e0bff717 	ldw	r2,-36(fp)
 822f190:	10800117 	ldw	r2,4(r2)
 822f194:	10800117 	ldw	r2,4(r2)
 822f198:	1885c83a 	sub	r2,r3,r2
 822f19c:	10800e18 	cmpnei	r2,r2,56
 822f1a0:	10002f1e 	bne	r2,zero,822f260 <ip_output+0x28c>
         {
            MEMCPY((m2->m_data - m1->m_len), m1->m_data, m1->m_len);
 822f1a4:	e0bff717 	ldw	r2,-36(fp)
 822f1a8:	10c00317 	ldw	r3,12(r2)
 822f1ac:	e0bff617 	ldw	r2,-40(fp)
 822f1b0:	10800217 	ldw	r2,8(r2)
 822f1b4:	0085c83a 	sub	r2,zero,r2
 822f1b8:	1887883a 	add	r3,r3,r2
 822f1bc:	e0bff617 	ldw	r2,-40(fp)
 822f1c0:	11000317 	ldw	r4,12(r2)
 822f1c4:	e0bff617 	ldw	r2,-40(fp)
 822f1c8:	10800217 	ldw	r2,8(r2)
 822f1cc:	100d883a 	mov	r6,r2
 822f1d0:	200b883a 	mov	r5,r4
 822f1d4:	1809883a 	mov	r4,r3
 822f1d8:	8202f100 	call	8202f10 <memcpy>
            m2->m_data -= m1->m_len;   /* fix target to reflect prepend */
 822f1dc:	e0bff717 	ldw	r2,-36(fp)
 822f1e0:	10c00317 	ldw	r3,12(r2)
 822f1e4:	e0bff617 	ldw	r2,-40(fp)
 822f1e8:	10800217 	ldw	r2,8(r2)
 822f1ec:	0085c83a 	sub	r2,zero,r2
 822f1f0:	1887883a 	add	r3,r3,r2
 822f1f4:	e0bff717 	ldw	r2,-36(fp)
 822f1f8:	10c00315 	stw	r3,12(r2)
            m2->m_len += m1->m_len;
 822f1fc:	e0bff717 	ldw	r2,-36(fp)
 822f200:	10c00217 	ldw	r3,8(r2)
 822f204:	e0bff617 	ldw	r2,-40(fp)
 822f208:	10800217 	ldw	r2,8(r2)
 822f20c:	1887883a 	add	r3,r3,r2
 822f210:	e0bff717 	ldw	r2,-36(fp)
 822f214:	10c00215 	stw	r3,8(r2)
            m_free(m1);    /* free head (copied) mbuf */
 822f218:	e13ff617 	ldw	r4,-40(fp)
 822f21c:	822e5300 	call	822e530 <m_free>
            data = m1 = m2;   /* move other mbufs up the chain */
 822f220:	e0bff717 	ldw	r2,-36(fp)
 822f224:	e0bff615 	stw	r2,-40(fp)
 822f228:	e0bff617 	ldw	r2,-40(fp)
 822f22c:	e0bffe15 	stw	r2,-8(fp)
            m2 = m2->m_next;  /* loop to while(m2) test */
 822f230:	e0bff717 	ldw	r2,-36(fp)
 822f234:	10800617 	ldw	r2,24(r2)
 822f238:	e0bff715 	stw	r2,-36(fp)
            tcpstat.tcps_oprepends++;
 822f23c:	008209b4 	movhi	r2,2086
 822f240:	10b98b04 	addi	r2,r2,-6612
 822f244:	10803217 	ldw	r2,200(r2)
 822f248:	10c00044 	addi	r3,r2,1
 822f24c:	008209b4 	movhi	r2,2086
 822f250:	10b98b04 	addi	r2,r2,-6612
 822f254:	10c03215 	stw	r3,200(r2)
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 822f258:	e0bff717 	ldw	r2,-36(fp)
 822f25c:	103faa1e 	bne	r2,zero,822f108 <ip_output+0x134>
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      if (m2)  /* If all else fails, brute force copy: */
 822f260:	e0bff717 	ldw	r2,-36(fp)
 822f264:	10006e26 	beq	r2,zero,822f420 <ip_output+0x44c>
      {
         total = 0;
 822f268:	e03ff915 	stw	zero,-28(fp)
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 822f26c:	e0bff617 	ldw	r2,-40(fp)
 822f270:	e0bff815 	stw	r2,-32(fp)
 822f274:	00000806 	br	822f298 <ip_output+0x2c4>
            total += mtmp->m_len;
 822f278:	e0bff817 	ldw	r2,-32(fp)
 822f27c:	10c00217 	ldw	r3,8(r2)
 822f280:	e0bff917 	ldw	r2,-28(fp)
 822f284:	1885883a 	add	r2,r3,r2
 822f288:	e0bff915 	stw	r2,-28(fp)
      }

      if (m2)  /* If all else fails, brute force copy: */
      {
         total = 0;
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 822f28c:	e0bff817 	ldw	r2,-32(fp)
 822f290:	10800617 	ldw	r2,24(r2)
 822f294:	e0bff815 	stw	r2,-32(fp)
 822f298:	e0bff817 	ldw	r2,-32(fp)
 822f29c:	103ff61e 	bne	r2,zero,822f278 <ip_output+0x2a4>
            total += mtmp->m_len;
         LOCK_NET_RESOURCE(FREEQ_RESID);
 822f2a0:	01000084 	movi	r4,2
 822f2a4:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
         pkt = pk_alloc(total + HDRSLEN);
 822f2a8:	e0bff917 	ldw	r2,-28(fp)
 822f2ac:	10800e04 	addi	r2,r2,56
 822f2b0:	1009883a 	mov	r4,r2
 822f2b4:	822c9ec0 	call	822c9ec <pk_alloc>
 822f2b8:	e0bffa15 	stw	r2,-24(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822f2bc:	01000084 	movi	r4,2
 822f2c0:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         if (!pkt)
 822f2c4:	e0bffa17 	ldw	r2,-24(fp)
 822f2c8:	1000021e 	bne	r2,zero,822f2d4 <ip_output+0x300>
            return ENOBUFS;
 822f2cc:	00801a44 	movi	r2,105
 822f2d0:	0000a706 	br	822f570 <ip_output+0x59c>
         pkt->nb_prot = pkt->nb_buff + MaxLnh;
 822f2d4:	e0bffa17 	ldw	r2,-24(fp)
 822f2d8:	10800117 	ldw	r2,4(r2)
 822f2dc:	d0e08117 	ldw	r3,-32252(gp)
 822f2e0:	10c7883a 	add	r3,r2,r3
 822f2e4:	e0bffa17 	ldw	r2,-24(fp)
 822f2e8:	10c00315 	stw	r3,12(r2)

         mtmp = m1;
 822f2ec:	e0bff617 	ldw	r2,-40(fp)
 822f2f0:	e0bff815 	stw	r2,-32(fp)
         while (mtmp)
 822f2f4:	00002906 	br	822f39c <ip_output+0x3c8>
         {
            MEMCPY(pkt->nb_prot, mtmp->m_data, mtmp->m_len);
 822f2f8:	e0bffa17 	ldw	r2,-24(fp)
 822f2fc:	10c00317 	ldw	r3,12(r2)
 822f300:	e0bff817 	ldw	r2,-32(fp)
 822f304:	11000317 	ldw	r4,12(r2)
 822f308:	e0bff817 	ldw	r2,-32(fp)
 822f30c:	10800217 	ldw	r2,8(r2)
 822f310:	100d883a 	mov	r6,r2
 822f314:	200b883a 	mov	r5,r4
 822f318:	1809883a 	mov	r4,r3
 822f31c:	8202f100 	call	8202f10 <memcpy>
            pkt->nb_prot += mtmp->m_len;
 822f320:	e0bffa17 	ldw	r2,-24(fp)
 822f324:	10c00317 	ldw	r3,12(r2)
 822f328:	e0bff817 	ldw	r2,-32(fp)
 822f32c:	10800217 	ldw	r2,8(r2)
 822f330:	1887883a 	add	r3,r3,r2
 822f334:	e0bffa17 	ldw	r2,-24(fp)
 822f338:	10c00315 	stw	r3,12(r2)
            pkt->nb_plen += mtmp->m_len;
 822f33c:	e0bffa17 	ldw	r2,-24(fp)
 822f340:	10c00417 	ldw	r3,16(r2)
 822f344:	e0bff817 	ldw	r2,-32(fp)
 822f348:	10800217 	ldw	r2,8(r2)
 822f34c:	1887883a 	add	r3,r3,r2
 822f350:	e0bffa17 	ldw	r2,-24(fp)
 822f354:	10c00415 	stw	r3,16(r2)
            m2 = mtmp;
 822f358:	e0bff817 	ldw	r2,-32(fp)
 822f35c:	e0bff715 	stw	r2,-36(fp)
            mtmp = mtmp->m_next;
 822f360:	e0bff817 	ldw	r2,-32(fp)
 822f364:	10800617 	ldw	r2,24(r2)
 822f368:	e0bff815 	stw	r2,-32(fp)
            if (m2 != data)   /* save original head */
 822f36c:	e0fff717 	ldw	r3,-36(fp)
 822f370:	e0bffe17 	ldw	r2,-8(fp)
 822f374:	18800226 	beq	r3,r2,822f380 <ip_output+0x3ac>
               m_free(m2);
 822f378:	e13ff717 	ldw	r4,-36(fp)
 822f37c:	822e5300 	call	822e530 <m_free>
            tcpstat.tcps_ocopies++;
 822f380:	008209b4 	movhi	r2,2086
 822f384:	10b98b04 	addi	r2,r2,-6612
 822f388:	10803417 	ldw	r2,208(r2)
 822f38c:	10c00044 	addi	r3,r2,1
 822f390:	008209b4 	movhi	r2,2086
 822f394:	10b98b04 	addi	r2,r2,-6612
 822f398:	10c03415 	stw	r3,208(r2)
         if (!pkt)
            return ENOBUFS;
         pkt->nb_prot = pkt->nb_buff + MaxLnh;

         mtmp = m1;
         while (mtmp)
 822f39c:	e0bff817 	ldw	r2,-32(fp)
 822f3a0:	103fd51e 	bne	r2,zero,822f2f8 <ip_output+0x324>
            mtmp = mtmp->m_next;
            if (m2 != data)   /* save original head */
               m_free(m2);
            tcpstat.tcps_ocopies++;
         }
         pkt->nb_prot -= total;     /* fix data pointer */
 822f3a4:	e0bffa17 	ldw	r2,-24(fp)
 822f3a8:	10c00317 	ldw	r3,12(r2)
 822f3ac:	e0bff917 	ldw	r2,-28(fp)
 822f3b0:	0085c83a 	sub	r2,zero,r2
 822f3b4:	1887883a 	add	r3,r3,r2
 822f3b8:	e0bffa17 	ldw	r2,-24(fp)
 822f3bc:	10c00315 	stw	r3,12(r2)

         /* release the original mbufs packet install the new one */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 822f3c0:	01000084 	movi	r4,2
 822f3c4:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
         pk_free(data->pkt);
 822f3c8:	e0bffe17 	ldw	r2,-8(fp)
 822f3cc:	10800117 	ldw	r2,4(r2)
 822f3d0:	1009883a 	mov	r4,r2
 822f3d4:	822cd3c0 	call	822cd3c <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822f3d8:	01000084 	movi	r4,2
 822f3dc:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         data->pkt = pkt;
 822f3e0:	e0bffe17 	ldw	r2,-8(fp)
 822f3e4:	e0fffa17 	ldw	r3,-24(fp)
 822f3e8:	10c00115 	stw	r3,4(r2)
         data->m_len = pkt->nb_plen;
 822f3ec:	e0bffa17 	ldw	r2,-24(fp)
 822f3f0:	10c00417 	ldw	r3,16(r2)
 822f3f4:	e0bffe17 	ldw	r2,-8(fp)
 822f3f8:	10c00215 	stw	r3,8(r2)
         data->m_next = NULL;
 822f3fc:	e0bffe17 	ldw	r2,-8(fp)
 822f400:	10000615 	stw	zero,24(r2)
         data->m_data = pkt->nb_prot;
 822f404:	e0bffa17 	ldw	r2,-24(fp)
 822f408:	10c00317 	ldw	r3,12(r2)
 822f40c:	e0bffe17 	ldw	r2,-8(fp)
 822f410:	10c00315 	stw	r3,12(r2)
         data->m_len = total;
 822f414:	e0fff917 	ldw	r3,-28(fp)
 822f418:	e0bffe17 	ldw	r2,-8(fp)
 822f41c:	10c00215 	stw	r3,8(r2)
      }
   }

   if ((data->m_data < (data->pkt->nb_buff + MaxLnh)))
 822f420:	e0bffe17 	ldw	r2,-8(fp)
 822f424:	10c00317 	ldw	r3,12(r2)
 822f428:	e0bffe17 	ldw	r2,-8(fp)
 822f42c:	10800117 	ldw	r2,4(r2)
 822f430:	10800117 	ldw	r2,4(r2)
 822f434:	d1208117 	ldw	r4,-32252(gp)
 822f438:	1105883a 	add	r2,r2,r4
 822f43c:	1880032e 	bgeu	r3,r2,822f44c <ip_output+0x478>
      panic("ip_output: overflow");
 822f440:	01020974 	movhi	r4,2085
 822f444:	21036f04 	addi	r4,r4,3516
 822f448:	8228c480 	call	8228c48 <panic>

   pkt = data->pkt;
 822f44c:	e0bffe17 	ldw	r2,-8(fp)
 822f450:	10800117 	ldw	r2,4(r2)
 822f454:	e0bffa15 	stw	r2,-24(fp)

   /* do we have options? */
   if (so_optsPack)
 822f458:	e0bfff17 	ldw	r2,-4(fp)
 822f45c:	10000326 	beq	r2,zero,822f46c <ip_output+0x498>
	   pkt->soxopts = so_optsPack;   /* yup */
 822f460:	e0bffa17 	ldw	r2,-24(fp)
 822f464:	e0ffff17 	ldw	r3,-4(fp)
 822f468:	10c00c15 	stw	r3,48(r2)
      panic("ip_output: no so_optsPack for the IPv6 scope");     
   }
#endif

   /* fill in dest host for IP layer */
   bip = (struct ip *)data->m_data;
 822f46c:	e0bffe17 	ldw	r2,-8(fp)
 822f470:	10800317 	ldw	r2,12(r2)
 822f474:	e0bffc15 	stw	r2,-16(fp)
   pkt->fhost = bip->ip_dest;
 822f478:	e0bffc17 	ldw	r2,-16(fp)
 822f47c:	10c00417 	ldw	r3,16(r2)
 822f480:	e0bffa17 	ldw	r2,-24(fp)
 822f484:	10c00715 	stw	r3,28(r2)

   /* make enough IP header for cksum calculation */
   bip->ip_ver_ihl = 0x45;
 822f488:	e0bffc17 	ldw	r2,-16(fp)
 822f48c:	00c01144 	movi	r3,69
 822f490:	10c00005 	stb	r3,0(r2)
   bip->ip_len = htons(bip->ip_len);   /* make net endian for calculation */
 822f494:	e0bffc17 	ldw	r2,-16(fp)
 822f498:	1080008b 	ldhu	r2,2(r2)
 822f49c:	10bfffcc 	andi	r2,r2,65535
 822f4a0:	1004d23a 	srli	r2,r2,8
 822f4a4:	1007883a 	mov	r3,r2
 822f4a8:	e0bffc17 	ldw	r2,-16(fp)
 822f4ac:	1080008b 	ldhu	r2,2(r2)
 822f4b0:	10bfffcc 	andi	r2,r2,65535
 822f4b4:	1004923a 	slli	r2,r2,8
 822f4b8:	1884b03a 	or	r2,r3,r2
 822f4bc:	1007883a 	mov	r3,r2
 822f4c0:	e0bffc17 	ldw	r2,-16(fp)
 822f4c4:	10c0008d 	sth	r3,2(r2)
   tcpp = (struct tcphdr *)ip_data(bip);
 822f4c8:	e0bffc17 	ldw	r2,-16(fp)
 822f4cc:	10800003 	ldbu	r2,0(r2)
 822f4d0:	10803fcc 	andi	r2,r2,255
 822f4d4:	108003cc 	andi	r2,r2,15
 822f4d8:	1085883a 	add	r2,r2,r2
 822f4dc:	1085883a 	add	r2,r2,r2
 822f4e0:	1007883a 	mov	r3,r2
 822f4e4:	e0bffc17 	ldw	r2,-16(fp)
 822f4e8:	10c5883a 	add	r2,r2,r3
 822f4ec:	e0bffd15 	stw	r2,-12(fp)
#ifdef CSUM_DEMO
   if (!(tcpp->th_flags & TH_SYN))
   tcpp->th_flags |= TH_PUSH;     /* force the PSH flag in TCP hdr */
#endif
   tcpp->th_sum = tcp_cksum(bip);
 822f4f0:	e13ffc17 	ldw	r4,-16(fp)
 822f4f4:	8247c980 	call	8247c98 <tcp_cksum>
 822f4f8:	1007883a 	mov	r3,r2
 822f4fc:	e0bffd17 	ldw	r2,-12(fp)
 822f500:	10c0040d 	sth	r3,16(r2)

   pkt->nb_prot = (char*)(bip + 1);    /* point past IP header */
 822f504:	e0bffc17 	ldw	r2,-16(fp)
 822f508:	10c00504 	addi	r3,r2,20
 822f50c:	e0bffa17 	ldw	r2,-24(fp)
 822f510:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen = data->m_len - sizeof(struct ip);
 822f514:	e0bffe17 	ldw	r2,-8(fp)
 822f518:	10800217 	ldw	r2,8(r2)
 822f51c:	10fffb04 	addi	r3,r2,-20
 822f520:	e0bffa17 	ldw	r2,-24(fp)
 822f524:	10c00415 	stw	r3,16(r2)

   e = ip_write(IPPROTO_TCP, pkt);
 822f528:	e17ffa17 	ldw	r5,-24(fp)
 822f52c:	01000184 	movi	r4,6
 822f530:	823f94c0 	call	823f94c <ip_write>
 822f534:	e0bffb15 	stw	r2,-20(fp)

   /* ip_write() is now responsable for data->pkt, so... */
   data->pkt = NULL;
 822f538:	e0bffe17 	ldw	r2,-8(fp)
 822f53c:	10000115 	stw	zero,4(r2)
   m_freem(data);
 822f540:	e13ffe17 	ldw	r4,-8(fp)
 822f544:	822e6380 	call	822e638 <m_freem>

   if (e < 0)
 822f548:	e0bffb17 	ldw	r2,-20(fp)
 822f54c:	1000070e 	bge	r2,zero,822f56c <ip_output+0x598>
   {
      /* don't report dropped sends, it causes socket applications to 
      bail when a TCP retry will fix the problem */
      if (e == SEND_DROPPED)
 822f550:	e0bffb17 	ldw	r2,-20(fp)
 822f554:	10bffa98 	cmpnei	r2,r2,-22
 822f558:	1000021e 	bne	r2,zero,822f564 <ip_output+0x590>
         return 0;
 822f55c:	0005883a 	mov	r2,zero
 822f560:	00000306 	br	822f570 <ip_output+0x59c>
      return e;
 822f564:	e0bffb17 	ldw	r2,-20(fp)
 822f568:	00000106 	br	822f570 <ip_output+0x59c>
   }
   else
      return 0;
 822f56c:	0005883a 	mov	r2,zero
}
 822f570:	e037883a 	mov	sp,fp
 822f574:	dfc00117 	ldw	ra,4(sp)
 822f578:	df000017 	ldw	fp,0(sp)
 822f57c:	dec00204 	addi	sp,sp,8
 822f580:	f800283a 	ret

0822f584 <in_broadcast>:
 * RETURNS: TRUE if broadcast, else FALSE
 */

int
in_broadcast(u_long ipaddr)   /* passed in net endian */
{
 822f584:	defffe04 	addi	sp,sp,-8
 822f588:	df000115 	stw	fp,4(sp)
 822f58c:	df000104 	addi	fp,sp,4
 822f590:	e13fff15 	stw	r4,-4(fp)
   if (ipaddr == 0xffffffff)
 822f594:	e0bfff17 	ldw	r2,-4(fp)
 822f598:	10bfffd8 	cmpnei	r2,r2,-1
 822f59c:	1000021e 	bne	r2,zero,822f5a8 <in_broadcast+0x24>
      return TRUE;
 822f5a0:	00800044 	movi	r2,1
 822f5a4:	00000106 	br	822f5ac <in_broadcast+0x28>

   return FALSE;
 822f5a8:	0005883a 	mov	r2,zero
}
 822f5ac:	e037883a 	mov	sp,fp
 822f5b0:	df000017 	ldw	fp,0(sp)
 822f5b4:	dec00104 	addi	sp,sp,4
 822f5b8:	f800283a 	ret

0822f5bc <np_stripoptions>:
 * RETURNS: void
 */

void
np_stripoptions(struct ip * ti, struct mbuf * m)
{
 822f5bc:	defffb04 	addi	sp,sp,-20
 822f5c0:	dfc00415 	stw	ra,16(sp)
 822f5c4:	df000315 	stw	fp,12(sp)
 822f5c8:	df000304 	addi	fp,sp,12
 822f5cc:	e13ffe15 	stw	r4,-8(fp)
 822f5d0:	e17fff15 	stw	r5,-4(fp)
   int   ihlen;

   /* get the IP header length in octets */
   ihlen = (ti->ip_ver_ihl & 0x0f) << 2;
 822f5d4:	e0bffe17 	ldw	r2,-8(fp)
 822f5d8:	10800003 	ldbu	r2,0(r2)
 822f5dc:	10803fcc 	andi	r2,r2,255
 822f5e0:	108003cc 	andi	r2,r2,15
 822f5e4:	1085883a 	add	r2,r2,r2
 822f5e8:	1085883a 	add	r2,r2,r2
 822f5ec:	e0bffd15 	stw	r2,-12(fp)

   /* if it's <= 20 octets, there are no IP header options to strip */
   if (ihlen <= 20)
 822f5f0:	e0bffd17 	ldw	r2,-12(fp)
 822f5f4:	10800548 	cmpgei	r2,r2,21
 822f5f8:	10002726 	beq	r2,zero,822f698 <np_stripoptions+0xdc>
      return;

   /* figure out how much to strip: we want to keep the 20-octet IP header */
   ihlen -= 20;
 822f5fc:	e0bffd17 	ldw	r2,-12(fp)
 822f600:	10bffb04 	addi	r2,r2,-20
 822f604:	e0bffd15 	stw	r2,-12(fp)

   /* remove the stripped options from the IP datagram length */
   ti->ip_len -= ihlen;
 822f608:	e0bffe17 	ldw	r2,-8(fp)
 822f60c:	1080008b 	ldhu	r2,2(r2)
 822f610:	e0fffd17 	ldw	r3,-12(fp)
 822f614:	10c5c83a 	sub	r2,r2,r3
 822f618:	1007883a 	mov	r3,r2
 822f61c:	e0bffe17 	ldw	r2,-8(fp)
 822f620:	10c0008d 	sth	r3,2(r2)

   /* and from the IP header length (which will be 5*4 octets long) */
   ti->ip_ver_ihl = (ti->ip_ver_ihl & 0xf0) | 5;
 822f624:	e0bffe17 	ldw	r2,-8(fp)
 822f628:	10800003 	ldbu	r2,0(r2)
 822f62c:	1007883a 	mov	r3,r2
 822f630:	00bffc04 	movi	r2,-16
 822f634:	1884703a 	and	r2,r3,r2
 822f638:	10800154 	ori	r2,r2,5
 822f63c:	1007883a 	mov	r3,r2
 822f640:	e0bffe17 	ldw	r2,-8(fp)
 822f644:	10c00005 	stb	r3,0(r2)

   /* move the 20-octet IP header up against the IP payload */
   MEMMOVE( ((char*)ti) + ihlen, ti, 20);
 822f648:	e0bffd17 	ldw	r2,-12(fp)
 822f64c:	e0fffe17 	ldw	r3,-8(fp)
 822f650:	1885883a 	add	r2,r3,r2
 822f654:	01800504 	movi	r6,20
 822f658:	e17ffe17 	ldw	r5,-8(fp)
 822f65c:	1009883a 	mov	r4,r2
 822f660:	82030580 	call	8203058 <memmove>
   m->m_len -= ihlen;
 822f664:	e0bfff17 	ldw	r2,-4(fp)
 822f668:	10c00217 	ldw	r3,8(r2)
 822f66c:	e0bffd17 	ldw	r2,-12(fp)
 822f670:	1887c83a 	sub	r3,r3,r2
 822f674:	e0bfff17 	ldw	r2,-4(fp)
 822f678:	10c00215 	stw	r3,8(r2)
   m->m_data += ihlen;
 822f67c:	e0bfff17 	ldw	r2,-4(fp)
 822f680:	10c00317 	ldw	r3,12(r2)
 822f684:	e0bffd17 	ldw	r2,-12(fp)
 822f688:	1887883a 	add	r3,r3,r2
 822f68c:	e0bfff17 	ldw	r2,-4(fp)
 822f690:	10c00315 	stw	r3,12(r2)
 822f694:	00000106 	br	822f69c <np_stripoptions+0xe0>
   /* get the IP header length in octets */
   ihlen = (ti->ip_ver_ihl & 0x0f) << 2;

   /* if it's <= 20 octets, there are no IP header options to strip */
   if (ihlen <= 20)
      return;
 822f698:	0001883a 	nop

   /* move the 20-octet IP header up against the IP payload */
   MEMMOVE( ((char*)ti) + ihlen, ti, 20);
   m->m_len -= ihlen;
   m->m_data += ihlen;
}
 822f69c:	e037883a 	mov	sp,fp
 822f6a0:	dfc00117 	ldw	ra,4(sp)
 822f6a4:	df000017 	ldw	fp,0(sp)
 822f6a8:	dec00204 	addi	sp,sp,8
 822f6ac:	f800283a 	ret

0822f6b0 <so_icmpdu>:
 * RETURNS: 
 */

void
so_icmpdu(PACKET p, struct destun * pdp)
{
 822f6b0:	defff304 	addi	sp,sp,-52
 822f6b4:	dfc00c15 	stw	ra,48(sp)
 822f6b8:	df000b15 	stw	fp,44(sp)
 822f6bc:	df000b04 	addi	fp,sp,44
 822f6c0:	e13ffe15 	stw	r4,-8(fp)
 822f6c4:	e17fff15 	stw	r5,-4(fp)
   struct inpcb * inp;
   struct socket *   so;
   struct tcpcb * tp;

   /* extract information about packet which generated DU */
   fhost = htonl(pdp->dip.ip_dest);
 822f6c8:	e0bfff17 	ldw	r2,-4(fp)
 822f6cc:	10800617 	ldw	r2,24(r2)
 822f6d0:	1006d63a 	srli	r3,r2,24
 822f6d4:	e0bfff17 	ldw	r2,-4(fp)
 822f6d8:	10800617 	ldw	r2,24(r2)
 822f6dc:	1004d23a 	srli	r2,r2,8
 822f6e0:	10bfc00c 	andi	r2,r2,65280
 822f6e4:	1886b03a 	or	r3,r3,r2
 822f6e8:	e0bfff17 	ldw	r2,-4(fp)
 822f6ec:	10800617 	ldw	r2,24(r2)
 822f6f0:	10bfc00c 	andi	r2,r2,65280
 822f6f4:	1004923a 	slli	r2,r2,8
 822f6f8:	1886b03a 	or	r3,r3,r2
 822f6fc:	e0bfff17 	ldw	r2,-4(fp)
 822f700:	10800617 	ldw	r2,24(r2)
 822f704:	1004963a 	slli	r2,r2,24
 822f708:	1884b03a 	or	r2,r3,r2
 822f70c:	e0bff815 	stw	r2,-32(fp)
   lhost = htonl(pdp->dip.ip_src);
 822f710:	e0bfff17 	ldw	r2,-4(fp)
 822f714:	10800517 	ldw	r2,20(r2)
 822f718:	1006d63a 	srli	r3,r2,24
 822f71c:	e0bfff17 	ldw	r2,-4(fp)
 822f720:	10800517 	ldw	r2,20(r2)
 822f724:	1004d23a 	srli	r2,r2,8
 822f728:	10bfc00c 	andi	r2,r2,65280
 822f72c:	1886b03a 	or	r3,r3,r2
 822f730:	e0bfff17 	ldw	r2,-4(fp)
 822f734:	10800517 	ldw	r2,20(r2)
 822f738:	10bfc00c 	andi	r2,r2,65280
 822f73c:	1004923a 	slli	r2,r2,8
 822f740:	1886b03a 	or	r3,r3,r2
 822f744:	e0bfff17 	ldw	r2,-4(fp)
 822f748:	10800517 	ldw	r2,20(r2)
 822f74c:	1004963a 	slli	r2,r2,24
 822f750:	1884b03a 	or	r2,r3,r2
 822f754:	e0bff915 	stw	r2,-28(fp)
   lport = htons(*(unshort*)(&pdp->ddata[0]));
 822f758:	e0bfff17 	ldw	r2,-4(fp)
 822f75c:	10800704 	addi	r2,r2,28
 822f760:	1080000b 	ldhu	r2,0(r2)
 822f764:	10bfffcc 	andi	r2,r2,65535
 822f768:	1004d23a 	srli	r2,r2,8
 822f76c:	1007883a 	mov	r3,r2
 822f770:	e0bfff17 	ldw	r2,-4(fp)
 822f774:	10800704 	addi	r2,r2,28
 822f778:	1080000b 	ldhu	r2,0(r2)
 822f77c:	10bfffcc 	andi	r2,r2,65535
 822f780:	1004923a 	slli	r2,r2,8
 822f784:	1884b03a 	or	r2,r3,r2
 822f788:	e0bffa0d 	sth	r2,-24(fp)
   fport = htons(*(unshort*)(&pdp->ddata[2]));
 822f78c:	e0bfff17 	ldw	r2,-4(fp)
 822f790:	10800784 	addi	r2,r2,30
 822f794:	1080000b 	ldhu	r2,0(r2)
 822f798:	10bfffcc 	andi	r2,r2,65535
 822f79c:	1004d23a 	srli	r2,r2,8
 822f7a0:	1007883a 	mov	r3,r2
 822f7a4:	e0bfff17 	ldw	r2,-4(fp)
 822f7a8:	10800784 	addi	r2,r2,30
 822f7ac:	1080000b 	ldhu	r2,0(r2)
 822f7b0:	10bfffcc 	andi	r2,r2,65535
 822f7b4:	1004923a 	slli	r2,r2,8
 822f7b8:	1884b03a 	or	r2,r3,r2
 822f7bc:	e0bffa8d 	sth	r2,-22(fp)
#ifndef IP_PMTU
   /* if it's a datagram-too-big message, ignore it -- As the
    * build isn't using PMTU Discovery this packet is most 
    * probably a Denial of Service Attack.
    */
    if(pdp->dcode == DSTFRAG)
 822f7c0:	e0bfff17 	ldw	r2,-4(fp)
 822f7c4:	10800043 	ldbu	r2,1(r2)
 822f7c8:	10803fcc 	andi	r2,r2,255
 822f7cc:	1080201c 	xori	r2,r2,128
 822f7d0:	10bfe004 	addi	r2,r2,-128
 822f7d4:	10800118 	cmpnei	r2,r2,4
 822f7d8:	10006e26 	beq	r2,zero,822f994 <so_icmpdu+0x2e4>
       goto done;
    }
#endif   /* IP_PMTU */

   /* if it's a TCP connection, clean it up */
   if (pdp->dip.ip_prot == TCPTP)
 822f7dc:	e0bfff17 	ldw	r2,-4(fp)
 822f7e0:	10800443 	ldbu	r2,17(r2)
 822f7e4:	10803fcc 	andi	r2,r2,255
 822f7e8:	10800198 	cmpnei	r2,r2,6
 822f7ec:	1000221e 	bne	r2,zero,822f878 <so_icmpdu+0x1c8>
   {
      /* find associated data structs and socket */
      inp = in_pcblookup(&tcb, fhost, fport, lhost, lport, INPLOOKUP_WILDCARD);
 822f7f0:	e13ffa8b 	ldhu	r4,-22(fp)
 822f7f4:	e0bffa0b 	ldhu	r2,-24(fp)
 822f7f8:	00c00044 	movi	r3,1
 822f7fc:	d8c00115 	stw	r3,4(sp)
 822f800:	d8800015 	stw	r2,0(sp)
 822f804:	e1fff917 	ldw	r7,-28(fp)
 822f808:	200d883a 	mov	r6,r4
 822f80c:	e17ff817 	ldw	r5,-32(fp)
 822f810:	010209b4 	movhi	r4,2086
 822f814:	21398004 	addi	r4,r4,-6656
 822f818:	824846c0 	call	824846c <in_pcblookup>
 822f81c:	e0bffb15 	stw	r2,-20(fp)
      if (inp == 0)
 822f820:	e0bffb17 	ldw	r2,-20(fp)
 822f824:	10005d26 	beq	r2,zero,822f99c <so_icmpdu+0x2ec>
         goto done;
      so = inp->inp_socket;
 822f828:	e0bffb17 	ldw	r2,-20(fp)
 822f82c:	10800817 	ldw	r2,32(r2)
 822f830:	e0bffc15 	stw	r2,-16(fp)
      if (so == 0)
 822f834:	e0bffc17 	ldw	r2,-16(fp)
 822f838:	10005a26 	beq	r2,zero,822f9a4 <so_icmpdu+0x2f4>
         goto done;
      tp = intotcpcb(inp);
 822f83c:	e0bffb17 	ldw	r2,-20(fp)
 822f840:	10800917 	ldw	r2,36(r2)
 822f844:	e0bffd15 	stw	r2,-12(fp)
      if (tp)
 822f848:	e0bffd17 	ldw	r2,-12(fp)
 822f84c:	10000626 	beq	r2,zero,822f868 <so_icmpdu+0x1b8>
      {
         if (tp->t_state <= TCPS_LISTEN)
 822f850:	e0bffd17 	ldw	r2,-12(fp)
 822f854:	10800217 	ldw	r2,8(r2)
 822f858:	10800088 	cmpgei	r2,r2,2
 822f85c:	10005326 	beq	r2,zero,822f9ac <so_icmpdu+0x2fc>
               goto done;
        }
   }
#endif

         tcp_close(tp);
 822f860:	e13ffd17 	ldw	r4,-12(fp)
 822f864:	8239be00 	call	8239be0 <tcp_close>
      }
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 822f868:	e0bffc17 	ldw	r2,-16(fp)
 822f86c:	00c01bc4 	movi	r3,111
 822f870:	10c00615 	stw	r3,24(r2)
 822f874:	00005406 	br	822f9c8 <so_icmpdu+0x318>
   }   
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
 822f878:	e0bfff17 	ldw	r2,-4(fp)
 822f87c:	10800443 	ldbu	r2,17(r2)
 822f880:	10803fcc 	andi	r2,r2,255
 822f884:	10800458 	cmpnei	r2,r2,17
 822f888:	10004a1e 	bne	r2,zero,822f9b4 <so_icmpdu+0x304>
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 822f88c:	d0a09c17 	ldw	r2,-32144(gp)
 822f890:	e0bff715 	stw	r2,-36(fp)
 822f894:	00002106 	br	822f91c <so_icmpdu+0x26c>
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
 822f898:	e0bff717 	ldw	r2,-36(fp)
 822f89c:	1080020b 	ldhu	r2,8(r2)
 822f8a0:	10ffffcc 	andi	r3,r2,65535
 822f8a4:	e0bffa8b 	ldhu	r2,-22(fp)
 822f8a8:	18800426 	beq	r3,r2,822f8bc <so_icmpdu+0x20c>
 822f8ac:	e0bff717 	ldw	r2,-36(fp)
 822f8b0:	1080020b 	ldhu	r2,8(r2)
 822f8b4:	10bfffcc 	andi	r2,r2,65535
 822f8b8:	1000151e 	bne	r2,zero,822f910 <so_icmpdu+0x260>
             (tmp->u_fhost == htonl(fhost)) &&
 822f8bc:	e0bff717 	ldw	r2,-36(fp)
 822f8c0:	10c00417 	ldw	r3,16(r2)
 822f8c4:	e0bff817 	ldw	r2,-32(fp)
 822f8c8:	1008d63a 	srli	r4,r2,24
 822f8cc:	e0bff817 	ldw	r2,-32(fp)
 822f8d0:	1004d23a 	srli	r2,r2,8
 822f8d4:	10bfc00c 	andi	r2,r2,65280
 822f8d8:	2088b03a 	or	r4,r4,r2
 822f8dc:	e0bff817 	ldw	r2,-32(fp)
 822f8e0:	10bfc00c 	andi	r2,r2,65280
 822f8e4:	1004923a 	slli	r2,r2,8
 822f8e8:	2088b03a 	or	r4,r4,r2
 822f8ec:	e0bff817 	ldw	r2,-32(fp)
 822f8f0:	1004963a 	slli	r2,r2,24
 822f8f4:	2084b03a 	or	r2,r4,r2
   else if(pdp->dip.ip_prot == UDP_PROT)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
 822f8f8:	1880051e 	bne	r3,r2,822f910 <so_icmpdu+0x260>
             (tmp->u_fhost == htonl(fhost)) &&
             (tmp->u_lport == lport))
 822f8fc:	e0bff717 	ldw	r2,-36(fp)
 822f900:	1080018b 	ldhu	r2,6(r2)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
             (tmp->u_fhost == htonl(fhost)) &&
 822f904:	10ffffcc 	andi	r3,r2,65535
 822f908:	e0bffa0b 	ldhu	r2,-24(fp)
 822f90c:	18800626 	beq	r3,r2,822f928 <so_icmpdu+0x278>
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 822f910:	e0bff717 	ldw	r2,-36(fp)
 822f914:	10800017 	ldw	r2,0(r2)
 822f918:	e0bff715 	stw	r2,-36(fp)
 822f91c:	e0bff717 	ldw	r2,-36(fp)
 822f920:	103fdd1e 	bne	r2,zero,822f898 <so_icmpdu+0x1e8>
 822f924:	00000106 	br	822f92c <so_icmpdu+0x27c>
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
             (tmp->u_fhost == htonl(fhost)) &&
             (tmp->u_lport == lport))
         {
            break;   /* found our UDP table entry */
 822f928:	0001883a 	nop
         }
      if (!tmp) 
 822f92c:	e0bff717 	ldw	r2,-36(fp)
 822f930:	10002226 	beq	r2,zero,822f9bc <so_icmpdu+0x30c>
         goto done;
      so = (struct socket *)tmp->u_data;
 822f934:	e0bff717 	ldw	r2,-36(fp)
 822f938:	10800617 	ldw	r2,24(r2)
 822f93c:	e0bffc15 	stw	r2,-16(fp)
      /* May be non-socket (lightweight) UDP connection. */
      if (so->so_type != SOCK_DGRAM)
 822f940:	e0bffc17 	ldw	r2,-16(fp)
 822f944:	10800983 	ldbu	r2,38(r2)
 822f948:	10803fcc 	andi	r2,r2,255
 822f94c:	1080201c 	xori	r2,r2,128
 822f950:	10bfe004 	addi	r2,r2,-128
 822f954:	108000a0 	cmpeqi	r2,r2,2
 822f958:	10001a26 	beq	r2,zero,822f9c4 <so_icmpdu+0x314>
         goto done;
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 822f95c:	e0bffc17 	ldw	r2,-16(fp)
 822f960:	00c01bc4 	movi	r3,111
 822f964:	10c00615 	stw	r3,24(r2)
      /* do a select() notify on socket here */
      sorwakeup(so);
 822f968:	e0bffc17 	ldw	r2,-16(fp)
 822f96c:	10800a04 	addi	r2,r2,40
 822f970:	100b883a 	mov	r5,r2
 822f974:	e13ffc17 	ldw	r4,-16(fp)
 822f978:	82342440 	call	8234244 <sbwakeup>
      sowwakeup(so);
 822f97c:	e0bffc17 	ldw	r2,-16(fp)
 822f980:	10801204 	addi	r2,r2,72
 822f984:	100b883a 	mov	r5,r2
 822f988:	e13ffc17 	ldw	r4,-16(fp)
 822f98c:	82342440 	call	8234244 <sbwakeup>
 822f990:	00000d06 	br	822f9c8 <so_icmpdu+0x318>
    * build isn't using PMTU Discovery this packet is most 
    * probably a Denial of Service Attack.
    */
    if(pdp->dcode == DSTFRAG)
    {
       goto done;
 822f994:	0001883a 	nop
 822f998:	00000b06 	br	822f9c8 <so_icmpdu+0x318>
   if (pdp->dip.ip_prot == TCPTP)
   {
      /* find associated data structs and socket */
      inp = in_pcblookup(&tcb, fhost, fport, lhost, lport, INPLOOKUP_WILDCARD);
      if (inp == 0)
         goto done;
 822f99c:	0001883a 	nop
 822f9a0:	00000906 	br	822f9c8 <so_icmpdu+0x318>
      so = inp->inp_socket;
      if (so == 0)
         goto done;
 822f9a4:	0001883a 	nop
 822f9a8:	00000706 	br	822f9c8 <so_icmpdu+0x318>
      tp = intotcpcb(inp);
      if (tp)
      {
         if (tp->t_state <= TCPS_LISTEN)
         {
            goto done;
 822f9ac:	0001883a 	nop
 822f9b0:	00000506 	br	822f9c8 <so_icmpdu+0x318>
      sorwakeup(so);
      sowwakeup(so);
   }
#endif   /* UDP_SOCKETS */
   else
      goto done;
 822f9b4:	0001883a 	nop
 822f9b8:	00000306 	br	822f9c8 <so_icmpdu+0x318>
             (tmp->u_lport == lport))
         {
            break;   /* found our UDP table entry */
         }
      if (!tmp) 
         goto done;
 822f9bc:	0001883a 	nop
 822f9c0:	00000106 	br	822f9c8 <so_icmpdu+0x318>
      so = (struct socket *)tmp->u_data;
      /* May be non-socket (lightweight) UDP connection. */
      if (so->so_type != SOCK_DGRAM)
         goto done;
 822f9c4:	0001883a 	nop
   if (pdp->dcode == DSTFRAG)
      pmtucache_set(pdp->dip.ip_dest, htons(pdp->dno2));
#endif   /* IP_PMTU */

done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
 822f9c8:	01000084 	movi	r4,2
 822f9cc:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   pk_free(p); /* done with original packet */
 822f9d0:	e13ffe17 	ldw	r4,-8(fp)
 822f9d4:	822cd3c0 	call	822cd3c <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822f9d8:	01000084 	movi	r4,2
 822f9dc:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   return;
 822f9e0:	0001883a 	nop
}
 822f9e4:	e037883a 	mov	sp,fp
 822f9e8:	dfc00117 	ldw	ra,4(sp)
 822f9ec:	df000017 	ldw	fp,0(sp)
 822f9f0:	dec00204 	addi	sp,sp,8
 822f9f4:	f800283a 	ret

0822f9f8 <tcp_tick>:
unsigned long nextslow = 0L;     /* next slow tcp timer time */
static int in_tcptick = 0;       /* reentry gaurd */

void
tcp_tick()
{
 822f9f8:	defffe04 	addi	sp,sp,-8
 822f9fc:	dfc00115 	stw	ra,4(sp)
 822fa00:	df000015 	stw	fp,0(sp)
 822fa04:	d839883a 	mov	fp,sp
   /* guard against re-entry */
   if (in_tcptick)
 822fa08:	d0a0ad17 	ldw	r2,-32076(gp)
 822fa0c:	1000121e 	bne	r2,zero,822fa58 <tcp_tick+0x60>
      return;
   in_tcptick++;
 822fa10:	d0a0ad17 	ldw	r2,-32076(gp)
 822fa14:	10800044 	addi	r2,r2,1
 822fa18:	d0a0ad15 	stw	r2,-32076(gp)

   LOCK_NET_RESOURCE(NET_RESID);
 822fa1c:	0009883a 	mov	r4,zero
 822fa20:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>

   if (cticks >= nextslow) /* time to do it again */
 822fa24:	d0e0a817 	ldw	r3,-32096(gp)
 822fa28:	d0a0ac17 	ldw	r2,-32080(gp)
 822fa2c:	18800436 	bltu	r3,r2,822fa40 <tcp_tick+0x48>
   {
      tcp_slowtimo();      /* call routine in BSD tcp_timr.c */
 822fa30:	8239e080 	call	8239e08 <tcp_slowtimo>
#ifdef CSUM_DEMO
      nextslow = cticks + (TPS/5);  /* another 200 ms */
#else
      nextslow = cticks + (TPS/2);  /* another 500 ms */
 822fa34:	d0a0a817 	ldw	r2,-32096(gp)
 822fa38:	10800c84 	addi	r2,r2,50
 822fa3c:	d0a0ac15 	stw	r2,-32080(gp)

#ifdef DO_DELAY_ACKS
   tcp_fasttimo();
#endif   /* DO_DELAY_ACKS */

   UNLOCK_NET_RESOURCE(NET_RESID);
 822fa40:	0009883a 	mov	r4,zero
 822fa44:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>

   in_tcptick--;
 822fa48:	d0a0ad17 	ldw	r2,-32076(gp)
 822fa4c:	10bfffc4 	addi	r2,r2,-1
 822fa50:	d0a0ad15 	stw	r2,-32076(gp)
 822fa54:	00000106 	br	822fa5c <tcp_tick+0x64>
void
tcp_tick()
{
   /* guard against re-entry */
   if (in_tcptick)
      return;
 822fa58:	0001883a 	nop
#endif   /* DO_DELAY_ACKS */

   UNLOCK_NET_RESOURCE(NET_RESID);

   in_tcptick--;
}
 822fa5c:	e037883a 	mov	sp,fp
 822fa60:	dfc00117 	ldw	ra,4(sp)
 822fa64:	df000017 	ldw	fp,0(sp)
 822fa68:	dec00204 	addi	sp,sp,8
 822fa6c:	f800283a 	ret

0822fa70 <rawip_lookup>:
 *          or NULL if no matching raw IP endpoint is found.
 */

struct ipraw_ep *
rawip_lookup(struct socket * so)
{
 822fa70:	defffd04 	addi	sp,sp,-12
 822fa74:	df000215 	stw	fp,8(sp)
 822fa78:	df000204 	addi	fp,sp,8
 822fa7c:	e13fff15 	stw	r4,-4(fp)
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 822fa80:	d0a0cf17 	ldw	r2,-31940(gp)
 822fa84:	e0bffe15 	stw	r2,-8(fp)
 822fa88:	00000906 	br	822fab0 <rawip_lookup+0x40>
      if (tmp->ipr_data == (void*)so)
 822fa8c:	e0bffe17 	ldw	r2,-8(fp)
 822fa90:	10c00417 	ldw	r3,16(r2)
 822fa94:	e0bfff17 	ldw	r2,-4(fp)
 822fa98:	1880021e 	bne	r3,r2,822faa4 <rawip_lookup+0x34>
      return (tmp);
 822fa9c:	e0bffe17 	ldw	r2,-8(fp)
 822faa0:	00000606 	br	822fabc <rawip_lookup+0x4c>
struct ipraw_ep *
rawip_lookup(struct socket * so)
{
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 822faa4:	e0bffe17 	ldw	r2,-8(fp)
 822faa8:	10800017 	ldw	r2,0(r2)
 822faac:	e0bffe15 	stw	r2,-8(fp)
 822fab0:	e0bffe17 	ldw	r2,-8(fp)
 822fab4:	103ff51e 	bne	r2,zero,822fa8c <rawip_lookup+0x1c>
      if (tmp->ipr_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 822fab8:	0005883a 	mov	r2,zero
}
 822fabc:	e037883a 	mov	sp,fp
 822fac0:	df000017 	ldw	fp,0(sp)
 822fac4:	dec00104 	addi	sp,sp,4
 822fac8:	f800283a 	ret

0822facc <rawip_soinput>:
 *          indicates that the packet has not been accepted.
 */

int
rawip_soinput(PACKET pkt, void * so_ptr)
{
 822facc:	defff504 	addi	sp,sp,-44
 822fad0:	dfc00a15 	stw	ra,40(sp)
 822fad4:	df000915 	stw	fp,36(sp)
 822fad8:	df000904 	addi	fp,sp,36
 822fadc:	e13ffe15 	stw	r4,-8(fp)
 822fae0:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 822fae4:	e0bfff17 	ldw	r2,-4(fp)
 822fae8:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;

   LOCK_NET_RESOURCE(NET_RESID); 
 822faec:	0009883a 	mov	r4,zero
 822faf0:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 822faf4:	e0bff717 	ldw	r2,-36(fp)
 822faf8:	10c00a17 	ldw	r3,40(r2)
 822fafc:	e0bffe17 	ldw	r2,-8(fp)
 822fb00:	10800417 	ldw	r2,16(r2)
 822fb04:	1887883a 	add	r3,r3,r2
 822fb08:	e0bff717 	ldw	r2,-36(fp)
 822fb0c:	10800b17 	ldw	r2,44(r2)
 822fb10:	18800436 	bltu	r3,r2,822fb24 <rawip_soinput+0x58>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 822fb14:	0009883a 	mov	r4,zero
 822fb18:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 822fb1c:	00801a44 	movi	r2,105
 822fb20:	00005706 	br	822fc80 <rawip_soinput+0x1b4>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 822fb24:	000b883a 	mov	r5,zero
 822fb28:	01000044 	movi	r4,1
 822fb2c:	822e3a80 	call	822e3a8 <m_getnbuf>
 822fb30:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 822fb34:	e0bff817 	ldw	r2,-32(fp)
 822fb38:	1000041e 	bne	r2,zero,822fb4c <rawip_soinput+0x80>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 822fb3c:	0009883a 	mov	r4,zero
 822fb40:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 822fb44:	00801a44 	movi	r2,105
 822fb48:	00004d06 	br	822fc80 <rawip_soinput+0x1b4>
   }

   /* set data mbuf to point to start of IP header */
   m_in->pkt = pkt;
 822fb4c:	e0bff817 	ldw	r2,-32(fp)
 822fb50:	e0fffe17 	ldw	r3,-8(fp)
 822fb54:	10c00115 	stw	r3,4(r2)
   m_in->m_base = pkt->nb_buff;
 822fb58:	e0bffe17 	ldw	r2,-8(fp)
 822fb5c:	10c00117 	ldw	r3,4(r2)
 822fb60:	e0bff817 	ldw	r2,-32(fp)
 822fb64:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 822fb68:	e0bffe17 	ldw	r2,-8(fp)
 822fb6c:	10c00217 	ldw	r3,8(r2)
 822fb70:	e0bff817 	ldw	r2,-32(fp)
 822fb74:	10c00515 	stw	r3,20(r2)
   m_in->m_data = pkt->nb_prot;
 822fb78:	e0bffe17 	ldw	r2,-8(fp)
 822fb7c:	10c00317 	ldw	r3,12(r2)
 822fb80:	e0bff817 	ldw	r2,-32(fp)
 822fb84:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 822fb88:	e0bffe17 	ldw	r2,-8(fp)
 822fb8c:	10c00417 	ldw	r3,16(r2)
 822fb90:	e0bff817 	ldw	r2,-32(fp)
 822fb94:	10c00215 	stw	r3,8(r2)

   /* if this socket doesn't have IP_HDRINCL set, adjust the
    * mbuf to skip past the IP header
    */
   if (!(so->so_options & SO_HDRINCL))
 822fb98:	e0bff717 	ldw	r2,-36(fp)
 822fb9c:	10800417 	ldw	r2,16(r2)
 822fba0:	1088000c 	andi	r2,r2,8192
 822fba4:	1000141e 	bne	r2,zero,822fbf8 <rawip_soinput+0x12c>
   {
      unsigned int ihl = 
         (((struct ip *)(pkt->nb_prot))->ip_ver_ihl & 0x0f) << 2;
 822fba8:	e0bffe17 	ldw	r2,-8(fp)
 822fbac:	10800317 	ldw	r2,12(r2)
 822fbb0:	10800003 	ldbu	r2,0(r2)
 822fbb4:	10803fcc 	andi	r2,r2,255
 822fbb8:	108003cc 	andi	r2,r2,15
 822fbbc:	1085883a 	add	r2,r2,r2
 822fbc0:	1085883a 	add	r2,r2,r2
   /* if this socket doesn't have IP_HDRINCL set, adjust the
    * mbuf to skip past the IP header
    */
   if (!(so->so_options & SO_HDRINCL))
   {
      unsigned int ihl = 
 822fbc4:	e0bff915 	stw	r2,-28(fp)
         (((struct ip *)(pkt->nb_prot))->ip_ver_ihl & 0x0f) << 2;
      m_in->m_data += ihl;
 822fbc8:	e0bff817 	ldw	r2,-32(fp)
 822fbcc:	10c00317 	ldw	r3,12(r2)
 822fbd0:	e0bff917 	ldw	r2,-28(fp)
 822fbd4:	1887883a 	add	r3,r3,r2
 822fbd8:	e0bff817 	ldw	r2,-32(fp)
 822fbdc:	10c00315 	stw	r3,12(r2)
      m_in->m_len -= ihl;
 822fbe0:	e0bff817 	ldw	r2,-32(fp)
 822fbe4:	10c00217 	ldw	r3,8(r2)
 822fbe8:	e0bff917 	ldw	r2,-28(fp)
 822fbec:	1887c83a 	sub	r3,r3,r2
 822fbf0:	e0bff817 	ldw	r2,-32(fp)
 822fbf4:	10c00215 	stw	r3,8(r2)
   }

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 822fbf8:	e0bffe17 	ldw	r2,-8(fp)
 822fbfc:	10800717 	ldw	r2,28(r2)
 822fc00:	e0bffb15 	stw	r2,-20(fp)
   sin.sin_port = 0;
 822fc04:	e03ffa8d 	sth	zero,-22(fp)
   sin.sin_family = AF_INET;
 822fc08:	00800084 	movi	r2,2
 822fc0c:	e0bffa0d 	sth	r2,-24(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 822fc10:	e0bff717 	ldw	r2,-36(fp)
 822fc14:	10800a04 	addi	r2,r2,40
 822fc18:	e0fffa04 	addi	r3,fp,-24
 822fc1c:	e1bff817 	ldw	r6,-32(fp)
 822fc20:	180b883a 	mov	r5,r3
 822fc24:	1009883a 	mov	r4,r2
 822fc28:	823456c0 	call	823456c <sbappendaddr>
 822fc2c:	1000081e 	bne	r2,zero,822fc50 <rawip_soinput+0x184>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       * underlying stack
       */
      m_in->pkt = NULL;
 822fc30:	e0bff817 	ldw	r2,-32(fp)
 822fc34:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 822fc38:	e13ff817 	ldw	r4,-32(fp)
 822fc3c:	822e5300 	call	822e530 <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 822fc40:	0009883a 	mov	r4,zero
 822fc44:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 822fc48:	00801a44 	movi	r2,105
 822fc4c:	00000c06 	br	822fc80 <rawip_soinput+0x1b4>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 822fc50:	e0bff717 	ldw	r2,-36(fp)
 822fc54:	10800a04 	addi	r2,r2,40
 822fc58:	1009883a 	mov	r4,r2
 822fc5c:	82296a80 	call	82296a8 <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 822fc60:	e0bff717 	ldw	r2,-36(fp)
 822fc64:	10800a04 	addi	r2,r2,40
 822fc68:	100b883a 	mov	r5,r2
 822fc6c:	e13ff717 	ldw	r4,-36(fp)
 822fc70:	82342440 	call	8234244 <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 822fc74:	0009883a 	mov	r4,zero
 822fc78:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   return 0;
 822fc7c:	0005883a 	mov	r2,zero
}
 822fc80:	e037883a 	mov	sp,fp
 822fc84:	dfc00117 	ldw	ra,4(sp)
 822fc88:	df000017 	ldw	fp,0(sp)
 822fc8c:	dec00204 	addi	sp,sp,8
 822fc90:	f800283a 	ret

0822fc94 <rawip_usrreq>:

int
rawip_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 822fc94:	deffef04 	addi	sp,sp,-68
 822fc98:	dfc01015 	stw	ra,64(sp)
 822fc9c:	df000f15 	stw	fp,60(sp)
 822fca0:	dc000e15 	stw	r16,56(sp)
 822fca4:	df000f04 	addi	fp,sp,60
 822fca8:	e13ffc15 	stw	r4,-16(fp)
 822fcac:	e17ffd15 	stw	r5,-12(fp)
 822fcb0:	e1bffe15 	stw	r6,-8(fp)
   u_char prot;
   struct ip * pip;
   int   req;
   NET   ifp;     /* ptr to network interface structure */

   req = so->so_req;    /* get request from socket struct */
 822fcb4:	e0bffc17 	ldw	r2,-16(fp)
 822fcb8:	10800717 	ldw	r2,28(r2)
 822fcbc:	e0bff615 	stw	r2,-40(fp)

   switch (req) 
 822fcc0:	e0bff617 	ldw	r2,-40(fp)
 822fcc4:	10800468 	cmpgeui	r2,r2,17
 822fcc8:	1001be1e 	bne	r2,zero,82303c4 <rawip_usrreq+0x730>
 822fccc:	e0bff617 	ldw	r2,-40(fp)
 822fcd0:	100690ba 	slli	r3,r2,2
 822fcd4:	008208f4 	movhi	r2,2083
 822fcd8:	10bf3a04 	addi	r2,r2,-792
 822fcdc:	1885883a 	add	r2,r3,r2
 822fce0:	10800017 	ldw	r2,0(r2)
 822fce4:	1000683a 	jmp	r2
 822fce8:	0822fd2c 	andhi	zero,at,35828
 822fcec:	0822fdb4 	orhi	zero,at,35830
 822fcf0:	0822fdf0 	cmpltui	zero,at,35831
 822fcf4:	082303c4 	addi	zero,at,-29681
 822fcf8:	0822fdf0 	cmpltui	zero,at,35831
 822fcfc:	082303c4 	addi	zero,at,-29681
 822fd00:	082303b8 	rdprs	zero,at,-29682
 822fd04:	082303c4 	addi	zero,at,-29681
 822fd08:	082303b8 	rdprs	zero,at,-29682
 822fd0c:	0822ff7c 	xorhi	zero,at,35837
 822fd10:	082303c4 	addi	zero,at,-29681
 822fd14:	082303c4 	addi	zero,at,-29681
 822fd18:	082303c4 	addi	zero,at,-29681
 822fd1c:	082303c4 	addi	zero,at,-29681
 822fd20:	082303c4 	addi	zero,at,-29681
 822fd24:	08230324 	muli	zero,at,-29684
 822fd28:	08230324 	muli	zero,at,-29684
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = 
         ip_raw_maxalloc(so->so_options & SO_HDRINCL);
 822fd2c:	e0bffc17 	ldw	r2,-16(fp)
 822fd30:	10800417 	ldw	r2,16(r2)
 822fd34:	1088000c 	andi	r2,r2,8192
 822fd38:	1009883a 	mov	r4,r2
 822fd3c:	82441940 	call	8244194 <ip_raw_maxalloc>

   switch (req) 
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = 
 822fd40:	1007883a 	mov	r3,r2
 822fd44:	e0bffc17 	ldw	r2,-16(fp)
 822fd48:	10c01315 	stw	r3,76(r2)
 822fd4c:	e0bffc17 	ldw	r2,-16(fp)
 822fd50:	10c01317 	ldw	r3,76(r2)
 822fd54:	e0bffc17 	ldw	r2,-16(fp)
 822fd58:	10c00b15 	stw	r3,44(r2)
         ip_raw_maxalloc(so->so_options & SO_HDRINCL);
      /* make a raw IP endpoint */
      prot = (u_char)(MBUF2LONG(nam));
 822fd5c:	e0bffe17 	ldw	r2,-8(fp)
 822fd60:	e0bff705 	stb	r2,-36(fp)
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 822fd64:	0009883a 	mov	r4,zero
 822fd68:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      ep = ip_raw_open(prot, 0L, 0L, rawip_soinput, so);
 822fd6c:	e0fff703 	ldbu	r3,-36(fp)
 822fd70:	e0bffc17 	ldw	r2,-16(fp)
 822fd74:	d8800015 	stw	r2,0(sp)
 822fd78:	01c208f4 	movhi	r7,2083
 822fd7c:	39feb304 	addi	r7,r7,-1332
 822fd80:	000d883a 	mov	r6,zero
 822fd84:	000b883a 	mov	r5,zero
 822fd88:	1809883a 	mov	r4,r3
 822fd8c:	8243ce00 	call	8243ce0 <ip_raw_open>
 822fd90:	e0bff815 	stw	r2,-32(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 822fd94:	0009883a 	mov	r4,zero
 822fd98:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      if (!ep)
 822fd9c:	e0bff817 	ldw	r2,-32(fp)
 822fda0:	1000021e 	bne	r2,zero,822fdac <rawip_usrreq+0x118>
         return(EINVAL);
 822fda4:	00800584 	movi	r2,22
 822fda8:	00018706 	br	82303c8 <rawip_usrreq+0x734>
      return 0;
 822fdac:	0005883a 	mov	r2,zero
 822fdb0:	00018506 	br	82303c8 <rawip_usrreq+0x734>
   case PRU_DETACH:
      /* delete the raw IP endpoint */
      ep = rawip_lookup(so);
 822fdb4:	e13ffc17 	ldw	r4,-16(fp)
 822fdb8:	822fa700 	call	822fa70 <rawip_lookup>
 822fdbc:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 822fdc0:	e0bff817 	ldw	r2,-32(fp)
 822fdc4:	1000021e 	bne	r2,zero,822fdd0 <rawip_usrreq+0x13c>
         return(EINVAL);
 822fdc8:	00800584 	movi	r2,22
 822fdcc:	00017e06 	br	82303c8 <rawip_usrreq+0x734>
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 822fdd0:	0009883a 	mov	r4,zero
 822fdd4:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      ip_raw_close(ep);
 822fdd8:	e13ff817 	ldw	r4,-32(fp)
 822fddc:	8243db80 	call	8243db8 <ip_raw_close>
      LOCK_NET_RESOURCE(NET_RESID);
 822fde0:	0009883a 	mov	r4,zero
 822fde4:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      return 0;
 822fde8:	0005883a 	mov	r2,zero
 822fdec:	00017606 	br	82303c8 <rawip_usrreq+0x734>
       * a default address for sending
       */
      /* fall through to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 822fdf0:	e0bffe17 	ldw	r2,-8(fp)
 822fdf4:	1000021e 	bne	r2,zero,822fe00 <rawip_usrreq+0x16c>
         return(EINVAL);
 822fdf8:	00800584 	movi	r2,22
 822fdfc:	00017206 	br	82303c8 <rawip_usrreq+0x734>
      sin = mtod(nam, struct sockaddr_in *);
 822fe00:	e0bffe17 	ldw	r2,-8(fp)
 822fe04:	10800317 	ldw	r2,12(r2)
 822fe08:	e0bff915 	stw	r2,-28(fp)
      if (sin == NULL)
 822fe0c:	e0bff917 	ldw	r2,-28(fp)
 822fe10:	1000021e 	bne	r2,zero,822fe1c <rawip_usrreq+0x188>
         return(EINVAL);
 822fe14:	00800584 	movi	r2,22
 822fe18:	00016b06 	br	82303c8 <rawip_usrreq+0x734>
      if (nam->m_len != sizeof (*sin))
 822fe1c:	e0bffe17 	ldw	r2,-8(fp)
 822fe20:	10800217 	ldw	r2,8(r2)
 822fe24:	10800420 	cmpeqi	r2,r2,16
 822fe28:	1000021e 	bne	r2,zero,822fe34 <rawip_usrreq+0x1a0>
         return(EINVAL);
 822fe2c:	00800584 	movi	r2,22
 822fe30:	00016506 	br	82303c8 <rawip_usrreq+0x734>
      ep = rawip_lookup(so);
 822fe34:	e13ffc17 	ldw	r4,-16(fp)
 822fe38:	822fa700 	call	822fa70 <rawip_lookup>
 822fe3c:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 822fe40:	e0bff817 	ldw	r2,-32(fp)
 822fe44:	1000021e 	bne	r2,zero,822fe50 <rawip_usrreq+0x1bc>
         return(EINVAL);
 822fe48:	00800584 	movi	r2,22
 822fe4c:	00015e06 	br	82303c8 <rawip_usrreq+0x734>
      if (req == PRU_BIND)
 822fe50:	e0bff617 	ldw	r2,-40(fp)
 822fe54:	10800098 	cmpnei	r2,r2,2
 822fe58:	1000201e 	bne	r2,zero,822fedc <rawip_usrreq+0x248>
          * if the caller-supplied address is INADDR_ANY,
          * don't bind to a specific address; else, 
          * make sure the caller-supplied address is
          * an interface IP address and if so, bind to that
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 822fe5c:	e0bff917 	ldw	r2,-28(fp)
 822fe60:	10800117 	ldw	r2,4(r2)
 822fe64:	1000021e 	bne	r2,zero,822fe70 <rawip_usrreq+0x1dc>
         {
            lhost = 0L;
 822fe68:	e03ff415 	stw	zero,-48(fp)
 822fe6c:	00001706 	br	822fecc <rawip_usrreq+0x238>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
 822fe70:	e0bff917 	ldw	r2,-28(fp)
 822fe74:	10800117 	ldw	r2,4(r2)
 822fe78:	e0bff415 	stw	r2,-48(fp)
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822fe7c:	008209b4 	movhi	r2,2086
 822fe80:	10ba5c04 	addi	r2,r2,-5776
 822fe84:	10800017 	ldw	r2,0(r2)
 822fe88:	e0bff515 	stw	r2,-44(fp)
 822fe8c:	00000706 	br	822feac <rawip_usrreq+0x218>
               if (ifp->n_ipaddr == lhost)
 822fe90:	e0bff517 	ldw	r2,-44(fp)
 822fe94:	10c00a17 	ldw	r3,40(r2)
 822fe98:	e0bff417 	ldw	r2,-48(fp)
 822fe9c:	18800626 	beq	r3,r2,822feb8 <rawip_usrreq+0x224>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822fea0:	e0bff517 	ldw	r2,-44(fp)
 822fea4:	10800017 	ldw	r2,0(r2)
 822fea8:	e0bff515 	stw	r2,-44(fp)
 822feac:	e0bff517 	ldw	r2,-44(fp)
 822feb0:	103ff71e 	bne	r2,zero,822fe90 <rawip_usrreq+0x1fc>
 822feb4:	00000106 	br	822febc <rawip_usrreq+0x228>
               if (ifp->n_ipaddr == lhost)
                  break;
 822feb8:	0001883a 	nop
            if (ifp == NULL)
 822febc:	e0bff517 	ldw	r2,-44(fp)
 822fec0:	1000021e 	bne	r2,zero,822fecc <rawip_usrreq+0x238>
               return(EADDRNOTAVAIL);
 822fec4:	00801f44 	movi	r2,125
 822fec8:	00013f06 	br	82303c8 <rawip_usrreq+0x734>
         }

         /* bind the endpoint */
         ep->ipr_laddr = lhost;
 822fecc:	e0bff817 	ldw	r2,-32(fp)
 822fed0:	e0fff417 	ldw	r3,-48(fp)
 822fed4:	10c00115 	stw	r3,4(r2)
 822fed8:	00002606 	br	822ff74 <rawip_usrreq+0x2e0>
          *
          * if the caller-supplied address is INADDR_ANY,
          * use the wildcard address; else, use the caller-
          * supplied address
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 822fedc:	e0bff917 	ldw	r2,-28(fp)
 822fee0:	10800117 	ldw	r2,4(r2)
 822fee4:	1000021e 	bne	r2,zero,822fef0 <rawip_usrreq+0x25c>
            fhost = 0L;
 822fee8:	e03ff315 	stw	zero,-52(fp)
 822feec:	00000306 	br	822fefc <rawip_usrreq+0x268>
         else
            fhost = sin->sin_addr.s_addr;
 822fef0:	e0bff917 	ldw	r2,-28(fp)
 822fef4:	10800117 	ldw	r2,4(r2)
 822fef8:	e0bff315 	stw	r2,-52(fp)
         /* connect the IP endpoint */
         ep->ipr_faddr = fhost;
 822fefc:	e0bff817 	ldw	r2,-32(fp)
 822ff00:	e0fff317 	ldw	r3,-52(fp)
 822ff04:	10c00215 	stw	r3,8(r2)
         /* mark the socket as connected or disconnected, as appropriate */
         if (fhost != 0L) {
 822ff08:	e0bff317 	ldw	r2,-52(fp)
 822ff0c:	10000e26 	beq	r2,zero,822ff48 <rawip_usrreq+0x2b4>
            so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 822ff10:	e0bffc17 	ldw	r2,-16(fp)
 822ff14:	10c0088b 	ldhu	r3,34(r2)
 822ff18:	00bffcc4 	movi	r2,-13
 822ff1c:	1884703a 	and	r2,r3,r2
 822ff20:	1007883a 	mov	r3,r2
 822ff24:	e0bffc17 	ldw	r2,-16(fp)
 822ff28:	10c0088d 	sth	r3,34(r2)
            so->so_state |= SS_ISCONNECTED;
 822ff2c:	e0bffc17 	ldw	r2,-16(fp)
 822ff30:	1080088b 	ldhu	r2,34(r2)
 822ff34:	10800094 	ori	r2,r2,2
 822ff38:	1007883a 	mov	r3,r2
 822ff3c:	e0bffc17 	ldw	r2,-16(fp)
 822ff40:	10c0088d 	sth	r3,34(r2)
 822ff44:	00000706 	br	822ff64 <rawip_usrreq+0x2d0>
         }
         else
         {
            so->so_state &= ~SS_ISCONNECTED;
 822ff48:	e0bffc17 	ldw	r2,-16(fp)
 822ff4c:	10c0088b 	ldhu	r3,34(r2)
 822ff50:	00bfff44 	movi	r2,-3
 822ff54:	1884703a 	and	r2,r3,r2
 822ff58:	1007883a 	mov	r3,r2
 822ff5c:	e0bffc17 	ldw	r2,-16(fp)
 822ff60:	10c0088d 	sth	r3,34(r2)
         }
         /* since socket was in listen state, packets may be queued */
         sbflush(&so->so_rcv);   /* dump these now */
 822ff64:	e0bffc17 	ldw	r2,-16(fp)
 822ff68:	10800a04 	addi	r2,r2,40
 822ff6c:	1009883a 	mov	r4,r2
 822ff70:	82349280 	call	8234928 <sbflush>
      }
      return 0;
 822ff74:	0005883a 	mov	r2,zero
 822ff78:	00011306 	br	82303c8 <rawip_usrreq+0x734>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 822ff7c:	e0bffd17 	ldw	r2,-12(fp)
 822ff80:	1000021e 	bne	r2,zero,822ff8c <rawip_usrreq+0x2f8>
         return(EINVAL);
 822ff84:	00800584 	movi	r2,22
 822ff88:	00010f06 	br	82303c8 <rawip_usrreq+0x734>

      ep = rawip_lookup(so);
 822ff8c:	e13ffc17 	ldw	r4,-16(fp)
 822ff90:	822fa700 	call	822fa70 <rawip_lookup>
 822ff94:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 822ff98:	e0bff817 	ldw	r2,-32(fp)
 822ff9c:	1000041e 	bne	r2,zero,822ffb0 <rawip_usrreq+0x31c>
      {
         m_free(m);
 822ffa0:	e13ffd17 	ldw	r4,-12(fp)
 822ffa4:	822e5300 	call	822e530 <m_free>
         /* may be bogus socket, but more likely the connection may 
         have closed due to ICMP dest unreachable from other side. */
         return(ECONNREFUSED);
 822ffa8:	00801bc4 	movi	r2,111
 822ffac:	00010606 	br	82303c8 <rawip_usrreq+0x734>
      }

      if (nam == NULL)  /* no sendto() info passed, must be send() */
 822ffb0:	e0bffe17 	ldw	r2,-8(fp)
 822ffb4:	10000b1e 	bne	r2,zero,822ffe4 <rawip_usrreq+0x350>
      {
         if (!(so->so_state & SS_ISCONNECTED))
 822ffb8:	e0bffc17 	ldw	r2,-16(fp)
 822ffbc:	1080088b 	ldhu	r2,34(r2)
 822ffc0:	10bfffcc 	andi	r2,r2,65535
 822ffc4:	1080008c 	andi	r2,r2,2
 822ffc8:	1000021e 	bne	r2,zero,822ffd4 <rawip_usrreq+0x340>
            return (ENOTCONN);
 822ffcc:	00802004 	movi	r2,128
 822ffd0:	0000fd06 	br	82303c8 <rawip_usrreq+0x734>
         fhost = ep->ipr_faddr;
 822ffd4:	e0bff817 	ldw	r2,-32(fp)
 822ffd8:	10800217 	ldw	r2,8(r2)
 822ffdc:	e0bff315 	stw	r2,-52(fp)
 822ffe0:	00001406 	br	8230034 <rawip_usrreq+0x3a0>
      }
      else 
      {
         if (so->so_state & SS_ISCONNECTED)
 822ffe4:	e0bffc17 	ldw	r2,-16(fp)
 822ffe8:	1080088b 	ldhu	r2,34(r2)
 822ffec:	10bfffcc 	andi	r2,r2,65535
 822fff0:	1080008c 	andi	r2,r2,2
 822fff4:	10000226 	beq	r2,zero,8230000 <rawip_usrreq+0x36c>
            return (EISCONN);
 822fff8:	00801fc4 	movi	r2,127
 822fffc:	0000f206 	br	82303c8 <rawip_usrreq+0x734>
         if (nam->m_len != sizeof (*sin))
 8230000:	e0bffe17 	ldw	r2,-8(fp)
 8230004:	10800217 	ldw	r2,8(r2)
 8230008:	10800420 	cmpeqi	r2,r2,16
 823000c:	1000031e 	bne	r2,zero,823001c <rawip_usrreq+0x388>
         {
            dtrap();
 8230010:	822d5940 	call	822d594 <dtrap>
            return (EINVAL);
 8230014:	00800584 	movi	r2,22
 8230018:	0000eb06 	br	82303c8 <rawip_usrreq+0x734>
         }
         sin = mtod(nam, struct sockaddr_in *);
 823001c:	e0bffe17 	ldw	r2,-8(fp)
 8230020:	10800317 	ldw	r2,12(r2)
 8230024:	e0bff915 	stw	r2,-28(fp)
         fhost = sin->sin_addr.s_addr;
 8230028:	e0bff917 	ldw	r2,-28(fp)
 823002c:	10800117 	ldw	r2,4(r2)
 8230030:	e0bff315 	stw	r2,-52(fp)

      /* since our pkt->nb_buff size is tied to max packet size, we 
       * assume our raw IP datagrams are always in one mbuf and that the 
       * mbuf -- but check anyway
       */
      if (m->m_len > (unsigned)ip_raw_maxalloc(so->so_options & SO_HDRINCL))
 8230034:	e0bffd17 	ldw	r2,-12(fp)
 8230038:	14000217 	ldw	r16,8(r2)
 823003c:	e0bffc17 	ldw	r2,-16(fp)
 8230040:	10800417 	ldw	r2,16(r2)
 8230044:	1088000c 	andi	r2,r2,8192
 8230048:	1009883a 	mov	r4,r2
 823004c:	82441940 	call	8244194 <ip_raw_maxalloc>
 8230050:	1400032e 	bgeu	r2,r16,8230060 <rawip_usrreq+0x3cc>
      {
         dtrap(); /* should never happen */
 8230054:	822d5940 	call	822d594 <dtrap>
         return EMSGSIZE;  /* try to recover */
 8230058:	00801e84 	movi	r2,122
 823005c:	0000da06 	br	82303c8 <rawip_usrreq+0x734>
      }
      /* get a packet buffer for send */
      pkt = ip_raw_alloc(m->m_len, so->so_options & SO_HDRINCL);
 8230060:	e0bffd17 	ldw	r2,-12(fp)
 8230064:	10800217 	ldw	r2,8(r2)
 8230068:	1007883a 	mov	r3,r2
 823006c:	e0bffc17 	ldw	r2,-16(fp)
 8230070:	10800417 	ldw	r2,16(r2)
 8230074:	1088000c 	andi	r2,r2,8192
 8230078:	100b883a 	mov	r5,r2
 823007c:	1809883a 	mov	r4,r3
 8230080:	82440980 	call	8244098 <ip_raw_alloc>
 8230084:	e0bffa15 	stw	r2,-24(fp)
      if (!pkt)
 8230088:	e0bffa17 	ldw	r2,-24(fp)
 823008c:	1000041e 	bne	r2,zero,82300a0 <rawip_usrreq+0x40c>
      {
         m_free(m);
 8230090:	e13ffd17 	ldw	r4,-12(fp)
 8230094:	822e5300 	call	822e530 <m_free>
         return ENOBUFS;   /* report buffer shortages */
 8230098:	00801a44 	movi	r2,105
 823009c:	0000ca06 	br	82303c8 <rawip_usrreq+0x734>
      }
      MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 82300a0:	e0bffa17 	ldw	r2,-24(fp)
 82300a4:	10c00317 	ldw	r3,12(r2)
 82300a8:	e0bffd17 	ldw	r2,-12(fp)
 82300ac:	11000317 	ldw	r4,12(r2)
 82300b0:	e0bffd17 	ldw	r2,-12(fp)
 82300b4:	10800217 	ldw	r2,8(r2)
 82300b8:	100d883a 	mov	r6,r2
 82300bc:	200b883a 	mov	r5,r4
 82300c0:	1809883a 	mov	r4,r3
 82300c4:	8202f100 	call	8202f10 <memcpy>
      pkt->nb_plen = m->m_len;
 82300c8:	e0bffd17 	ldw	r2,-12(fp)
 82300cc:	10c00217 	ldw	r3,8(r2)
 82300d0:	e0bffa17 	ldw	r2,-24(fp)
 82300d4:	10c00415 	stw	r3,16(r2)
      /* finished with mbuf, free it now */
      m_free(m);
 82300d8:	e13ffd17 	ldw	r4,-12(fp)
 82300dc:	822e5300 	call	822e530 <m_free>
      pkt->fhost = fhost;
 82300e0:	e0bffa17 	ldw	r2,-24(fp)
 82300e4:	e0fff317 	ldw	r3,-52(fp)
 82300e8:	10c00715 	stw	r3,28(r2)
       * is up; if (after all that) we don't have an interface then we
       * fail with error EADDRNOTAVAIL; and finally, if we're built
       * for a single-homed configuration where there's only one
       * interface, we might as well use it, so we do.  
       */
      if (fhost == 0xffffffff)
 82300ec:	e0bff317 	ldw	r2,-52(fp)
 82300f0:	10bfffd8 	cmpnei	r2,r2,-1
 82300f4:	10004a1e 	bne	r2,zero,8230220 <rawip_usrreq+0x58c>
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
 82300f8:	e0bff817 	ldw	r2,-32(fp)
 82300fc:	10800117 	ldw	r2,4(r2)
 8230100:	10001026 	beq	r2,zero,8230144 <rawip_usrreq+0x4b0>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 8230104:	008209b4 	movhi	r2,2086
 8230108:	10ba5c04 	addi	r2,r2,-5776
 823010c:	10800017 	ldw	r2,0(r2)
 8230110:	e0bff515 	stw	r2,-44(fp)
 8230114:	00000806 	br	8230138 <rawip_usrreq+0x4a4>
               if (ifp->n_ipaddr == ep->ipr_laddr)
 8230118:	e0bff517 	ldw	r2,-44(fp)
 823011c:	10c00a17 	ldw	r3,40(r2)
 8230120:	e0bff817 	ldw	r2,-32(fp)
 8230124:	10800117 	ldw	r2,4(r2)
 8230128:	18801d26 	beq	r3,r2,82301a0 <rawip_usrreq+0x50c>
      if (fhost == 0xffffffff)
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823012c:	e0bff517 	ldw	r2,-44(fp)
 8230130:	10800017 	ldw	r2,0(r2)
 8230134:	e0bff515 	stw	r2,-44(fp)
 8230138:	e0bff517 	ldw	r2,-44(fp)
 823013c:	103ff61e 	bne	r2,zero,8230118 <rawip_usrreq+0x484>
 8230140:	00001a06 	br	82301ac <rawip_usrreq+0x518>
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 8230144:	008209b4 	movhi	r2,2086
 8230148:	10ba5c04 	addi	r2,r2,-5776
 823014c:	10800017 	ldw	r2,0(r2)
 8230150:	e0bff515 	stw	r2,-44(fp)
 8230154:	00000f06 	br	8230194 <rawip_usrreq+0x500>
               if ((ifp->n_flags & NF_BCAST) &&
 8230158:	e0bff517 	ldw	r2,-44(fp)
 823015c:	10802a17 	ldw	r2,168(r2)
 8230160:	1080004c 	andi	r2,r2,1
 8230164:	10000826 	beq	r2,zero,8230188 <rawip_usrreq+0x4f4>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 8230168:	e0bff517 	ldw	r2,-44(fp)
 823016c:	10802717 	ldw	r2,156(r2)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if ((ifp->n_flags & NF_BCAST) &&
 8230170:	10000526 	beq	r2,zero,8230188 <rawip_usrreq+0x4f4>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 8230174:	e0bff517 	ldw	r2,-44(fp)
 8230178:	10802717 	ldw	r2,156(r2)
 823017c:	10800617 	ldw	r2,24(r2)
 8230180:	10800058 	cmpnei	r2,r2,1
 8230184:	10000826 	beq	r2,zero,82301a8 <rawip_usrreq+0x514>
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 8230188:	e0bff517 	ldw	r2,-44(fp)
 823018c:	10800017 	ldw	r2,0(r2)
 8230190:	e0bff515 	stw	r2,-44(fp)
 8230194:	e0bff517 	ldw	r2,-44(fp)
 8230198:	103fef1e 	bne	r2,zero,8230158 <rawip_usrreq+0x4c4>
 823019c:	00000306 	br	82301ac <rawip_usrreq+0x518>
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
 82301a0:	0001883a 	nop
 82301a4:	00000106 	br	82301ac <rawip_usrreq+0x518>
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if ((ifp->n_flags & NF_BCAST) &&
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
 82301a8:	0001883a 	nop
         }
         if (ifp == NULL)
 82301ac:	e0bff517 	ldw	r2,-44(fp)
 82301b0:	1000181e 	bne	r2,zero,8230214 <rawip_usrreq+0x580>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 82301b4:	008209b4 	movhi	r2,2086
 82301b8:	10ba5c04 	addi	r2,r2,-5776
 82301bc:	10800017 	ldw	r2,0(r2)
 82301c0:	e0bff515 	stw	r2,-44(fp)
 82301c4:	00000b06 	br	82301f4 <rawip_usrreq+0x560>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 82301c8:	e0bff517 	ldw	r2,-44(fp)
 82301cc:	10802717 	ldw	r2,156(r2)
 82301d0:	10000526 	beq	r2,zero,82301e8 <rawip_usrreq+0x554>
 82301d4:	e0bff517 	ldw	r2,-44(fp)
 82301d8:	10802717 	ldw	r2,156(r2)
 82301dc:	10800617 	ldw	r2,24(r2)
 82301e0:	10800058 	cmpnei	r2,r2,1
 82301e4:	10000626 	beq	r2,zero,8230200 <rawip_usrreq+0x56c>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
         }
         if (ifp == NULL)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 82301e8:	e0bff517 	ldw	r2,-44(fp)
 82301ec:	10800017 	ldw	r2,0(r2)
 82301f0:	e0bff515 	stw	r2,-44(fp)
 82301f4:	e0bff517 	ldw	r2,-44(fp)
 82301f8:	103ff31e 	bne	r2,zero,82301c8 <rawip_usrreq+0x534>
 82301fc:	00000106 	br	8230204 <rawip_usrreq+0x570>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
 8230200:	0001883a 	nop
            if (ifp == NULL)
 8230204:	e0bff517 	ldw	r2,-44(fp)
 8230208:	1000021e 	bne	r2,zero,8230214 <rawip_usrreq+0x580>
               return(EADDRNOTAVAIL);
 823020c:	00801f44 	movi	r2,125
 8230210:	00006d06 	br	82303c8 <rawip_usrreq+0x734>
         }
         pkt->net = ifp;
 8230214:	e0bffa17 	ldw	r2,-24(fp)
 8230218:	e0fff517 	ldw	r3,-44(fp)
 823021c:	10c00615 	stw	r3,24(r2)
#ifdef IP_MULTICAST

      /* If the socket has an IP moptions structure for multicast options,
       * place a pointer to this structure in the PACKET structure.
       */
      if (so->inp_moptions)
 8230220:	e0bffc17 	ldw	r2,-16(fp)
 8230224:	10800317 	ldw	r2,12(r2)
 8230228:	10000426 	beq	r2,zero,823023c <rawip_usrreq+0x5a8>
         pkt->imo = so->inp_moptions;
 823022c:	e0bffc17 	ldw	r2,-16(fp)
 8230230:	10c00317 	ldw	r3,12(r2)
 8230234:	e0bffa17 	ldw	r2,-24(fp)
 8230238:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

      if (so->so_options & SO_HDRINCL)
 823023c:	e0bffc17 	ldw	r2,-16(fp)
 8230240:	10800417 	ldw	r2,16(r2)
 8230244:	1088000c 	andi	r2,r2,8192
 8230248:	10000826 	beq	r2,zero,823026c <rawip_usrreq+0x5d8>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 823024c:	0009883a 	mov	r4,zero
 8230250:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         e = ip_raw_write(pkt);
 8230254:	e13ffa17 	ldw	r4,-24(fp)
 8230258:	823fef00 	call	823fef0 <ip_raw_write>
 823025c:	e0bff215 	stw	r2,-56(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 8230260:	0009883a 	mov	r4,zero
 8230264:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
 8230268:	00002806 	br	823030c <rawip_usrreq+0x678>
      }
      else
      {
         pip = (struct ip *)(pkt->nb_prot - IPHSIZ);
 823026c:	e0bffa17 	ldw	r2,-24(fp)
 8230270:	10800317 	ldw	r2,12(r2)
 8230274:	10bffb04 	addi	r2,r2,-20
 8230278:	e0bffb15 	stw	r2,-20(fp)
         if (ep->ipr_laddr)
 823027c:	e0bff817 	ldw	r2,-32(fp)
 8230280:	10800117 	ldw	r2,4(r2)
 8230284:	10000526 	beq	r2,zero,823029c <rawip_usrreq+0x608>
            pip->ip_src = ep->ipr_laddr;
 8230288:	e0bff817 	ldw	r2,-32(fp)
 823028c:	10c00117 	ldw	r3,4(r2)
 8230290:	e0bffb17 	ldw	r2,-20(fp)
 8230294:	10c00315 	stw	r3,12(r2)
 8230298:	00000e06 	br	82302d4 <rawip_usrreq+0x640>
         else
         {
            if (fhost == 0xffffffff)
 823029c:	e0bff317 	ldw	r2,-52(fp)
 82302a0:	10bfffd8 	cmpnei	r2,r2,-1
 82302a4:	1000061e 	bne	r2,zero,82302c0 <rawip_usrreq+0x62c>
               pip->ip_src = pkt->net->n_ipaddr;
 82302a8:	e0bffa17 	ldw	r2,-24(fp)
 82302ac:	10800617 	ldw	r2,24(r2)
 82302b0:	10c00a17 	ldw	r3,40(r2)
 82302b4:	e0bffb17 	ldw	r2,-20(fp)
 82302b8:	10c00315 	stw	r3,12(r2)
 82302bc:	00000506 	br	82302d4 <rawip_usrreq+0x640>
            else
               pip->ip_src = ip_mymach(fhost);
 82302c0:	e13ff317 	ldw	r4,-52(fp)
 82302c4:	824099c0 	call	824099c <ip_mymach>
 82302c8:	1007883a 	mov	r3,r2
 82302cc:	e0bffb17 	ldw	r2,-20(fp)
 82302d0:	10c00315 	stw	r3,12(r2)
         }
         pip->ip_dest = fhost;
 82302d4:	e0bffb17 	ldw	r2,-20(fp)
 82302d8:	e0fff317 	ldw	r3,-52(fp)
 82302dc:	10c00415 	stw	r3,16(r2)
         UNLOCK_NET_RESOURCE(NET_RESID);
 82302e0:	0009883a 	mov	r4,zero
 82302e4:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         e = ip_write(ep->ipr_prot, pkt);
 82302e8:	e0bff817 	ldw	r2,-32(fp)
 82302ec:	10800503 	ldbu	r2,20(r2)
 82302f0:	10803fcc 	andi	r2,r2,255
 82302f4:	e17ffa17 	ldw	r5,-24(fp)
 82302f8:	1009883a 	mov	r4,r2
 82302fc:	823f94c0 	call	823f94c <ip_write>
 8230300:	e0bff215 	stw	r2,-56(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 8230304:	0009883a 	mov	r4,zero
 8230308:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      }         
      if (e < 0) 
 823030c:	e0bff217 	ldw	r2,-56(fp)
 8230310:	1000020e 	bge	r2,zero,823031c <rawip_usrreq+0x688>
         return(e);
 8230314:	e0bff217 	ldw	r2,-56(fp)
 8230318:	00002b06 	br	82303c8 <rawip_usrreq+0x734>
      return 0;
 823031c:	0005883a 	mov	r2,zero
 8230320:	00002906 	br	82303c8 <rawip_usrreq+0x734>
   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 8230324:	e0bffe17 	ldw	r2,-8(fp)
 8230328:	1000021e 	bne	r2,zero,8230334 <rawip_usrreq+0x6a0>
         return(EINVAL);
 823032c:	00800584 	movi	r2,22
 8230330:	00002506 	br	82303c8 <rawip_usrreq+0x734>
      sin = mtod(nam, struct sockaddr_in *);
 8230334:	e0bffe17 	ldw	r2,-8(fp)
 8230338:	10800317 	ldw	r2,12(r2)
 823033c:	e0bff915 	stw	r2,-28(fp)
      if (sin == NULL)
 8230340:	e0bff917 	ldw	r2,-28(fp)
 8230344:	1000021e 	bne	r2,zero,8230350 <rawip_usrreq+0x6bc>
         return(EINVAL);
 8230348:	00800584 	movi	r2,22
 823034c:	00001e06 	br	82303c8 <rawip_usrreq+0x734>
      ep = rawip_lookup(so);
 8230350:	e13ffc17 	ldw	r4,-16(fp)
 8230354:	822fa700 	call	822fa70 <rawip_lookup>
 8230358:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 823035c:	e0bff817 	ldw	r2,-32(fp)
 8230360:	1000021e 	bne	r2,zero,823036c <rawip_usrreq+0x6d8>
         return(EINVAL);
 8230364:	00800584 	movi	r2,22
 8230368:	00001706 	br	82303c8 <rawip_usrreq+0x734>
      sin->sin_port = 0;
 823036c:	e0bff917 	ldw	r2,-28(fp)
 8230370:	1000008d 	sth	zero,2(r2)
      nam->m_len = sizeof(*sin);
 8230374:	e0bffe17 	ldw	r2,-8(fp)
 8230378:	00c00404 	movi	r3,16
 823037c:	10c00215 	stw	r3,8(r2)
      if (req == PRU_SOCKADDR)
 8230380:	e0bff617 	ldw	r2,-40(fp)
 8230384:	108003d8 	cmpnei	r2,r2,15
 8230388:	1000051e 	bne	r2,zero,82303a0 <rawip_usrreq+0x70c>
      {
         sin->sin_addr.s_addr = ep->ipr_laddr;
 823038c:	e0bff817 	ldw	r2,-32(fp)
 8230390:	10c00117 	ldw	r3,4(r2)
 8230394:	e0bff917 	ldw	r2,-28(fp)
 8230398:	10c00115 	stw	r3,4(r2)
 823039c:	00000406 	br	82303b0 <rawip_usrreq+0x71c>
      }
      else /* PRU_PEERADDR */
      {
         sin->sin_addr.s_addr = ep->ipr_faddr;
 82303a0:	e0bff817 	ldw	r2,-32(fp)
 82303a4:	10c00217 	ldw	r3,8(r2)
 82303a8:	e0bff917 	ldw	r2,-28(fp)
 82303ac:	10c00115 	stw	r3,4(r2)
      }
      return 0;
 82303b0:	0005883a 	mov	r2,zero
 82303b4:	00000406 	br	82303c8 <rawip_usrreq+0x734>
   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 82303b8:	822d5940 	call	822d594 <dtrap>
      return 0;
 82303bc:	0005883a 	mov	r2,zero
 82303c0:	00000106 	br	82303c8 <rawip_usrreq+0x734>
   case PRU_LISTEN:     /* don't support these for raw IP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 82303c4:	008017c4 	movi	r2,95
   }
}
 82303c8:	e6ffff04 	addi	sp,fp,-4
 82303cc:	dfc00217 	ldw	ra,8(sp)
 82303d0:	df000117 	ldw	fp,4(sp)
 82303d4:	dc000017 	ldw	r16,0(sp)
 82303d8:	dec00304 	addi	sp,sp,12
 82303dc:	f800283a 	ret

082303e0 <DOMAIN_CHECK>:
 */

#ifdef NPDEBUG
void
DOMAIN_CHECK(struct socket * so, int size)
{
 82303e0:	defffc04 	addi	sp,sp,-16
 82303e4:	dfc00315 	stw	ra,12(sp)
 82303e8:	df000215 	stw	fp,8(sp)
 82303ec:	df000204 	addi	fp,sp,8
 82303f0:	e13ffe15 	stw	r4,-8(fp)
 82303f4:	e17fff15 	stw	r5,-4(fp)
#ifdef IP_V4
   if((so->so_domain == AF_INET) &&
 82303f8:	e0bffe17 	ldw	r2,-8(fp)
 82303fc:	10800517 	ldw	r2,20(r2)
 8230400:	10800098 	cmpnei	r2,r2,2
 8230404:	1000041e 	bne	r2,zero,8230418 <DOMAIN_CHECK+0x38>
      (size < sizeof(struct sockaddr_in)))
 8230408:	e0bfff17 	ldw	r2,-4(fp)
#ifdef NPDEBUG
void
DOMAIN_CHECK(struct socket * so, int size)
{
#ifdef IP_V4
   if((so->so_domain == AF_INET) &&
 823040c:	10800428 	cmpgeui	r2,r2,16
 8230410:	1000011e 	bne	r2,zero,8230418 <DOMAIN_CHECK+0x38>
      (size < sizeof(struct sockaddr_in)))
   {
      dtrap(); /* programmer passed wrong structure */
 8230414:	822d5940 	call	822d594 <dtrap>
      (size != sizeof(struct sockaddr_in6)))
   {
      dtrap(); /* programmer passed wrong structure */
   }
#endif   /* IP_V6 */
}
 8230418:	0001883a 	nop
 823041c:	e037883a 	mov	sp,fp
 8230420:	dfc00117 	ldw	ra,4(sp)
 8230424:	df000017 	ldw	fp,0(sp)
 8230428:	dec00204 	addi	sp,sp,8
 823042c:	f800283a 	ret

08230430 <t_socket>:

long
t_socket(int family, 
   int   type, 
   int   proto)
{
 8230430:	defffa04 	addi	sp,sp,-24
 8230434:	dfc00515 	stw	ra,20(sp)
 8230438:	df000415 	stw	fp,16(sp)
 823043c:	df000404 	addi	fp,sp,16
 8230440:	e13ffd15 	stw	r4,-12(fp)
 8230444:	e17ffe15 	stw	r5,-8(fp)
 8230448:	e1bfff15 	stw	r6,-4(fp)
   struct socket *   so;

   INET_TRACE (INETM_SOCKET, ("SOCK:sock:family %d, typ %d, proto %d\n",
    family, type, proto));
   LOCK_NET_RESOURCE(NET_RESID);
 823044c:	0009883a 	mov	r4,zero
 8230450:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   if ((so = socreate (family, type, proto)) == NULL) 
 8230454:	e1bfff17 	ldw	r6,-4(fp)
 8230458:	e17ffe17 	ldw	r5,-8(fp)
 823045c:	e13ffd17 	ldw	r4,-12(fp)
 8230460:	8231a340 	call	8231a34 <socreate>
 8230464:	e0bffc15 	stw	r2,-16(fp)
 8230468:	e0bffc17 	ldw	r2,-16(fp)
 823046c:	1000041e 	bne	r2,zero,8230480 <t_socket+0x50>
   {  /* can't really return error info since no socket.... */
      UNLOCK_NET_RESOURCE(NET_RESID);
 8230470:	0009883a 	mov	r4,zero
 8230474:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 8230478:	00bfffc4 	movi	r2,-1
 823047c:	00000706 	br	823049c <t_socket+0x6c>
   }
   SOC_RANGE(so);
   so->so_error = 0;
 8230480:	e0bffc17 	ldw	r2,-16(fp)
 8230484:	10000615 	stw	zero,24(r2)
   UNLOCK_NET_RESOURCE(NET_RESID);
 8230488:	0009883a 	mov	r4,zero
 823048c:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   return SO2LONG(so);
 8230490:	e0bffc17 	ldw	r2,-16(fp)
 8230494:	1004d0ba 	srli	r2,r2,2
 8230498:	10800804 	addi	r2,r2,32
}
 823049c:	e037883a 	mov	sp,fp
 82304a0:	dfc00117 	ldw	ra,4(sp)
 82304a4:	df000017 	ldw	fp,0(sp)
 82304a8:	dec00204 	addi	sp,sp,8
 82304ac:	f800283a 	ret

082304b0 <t_bind>:

int
t_bind (long s, 
   struct sockaddr * addr,
   int addrlen)
{
 82304b0:	defff204 	addi	sp,sp,-56
 82304b4:	dfc00d15 	stw	ra,52(sp)
 82304b8:	df000c15 	stw	fp,48(sp)
 82304bc:	df000c04 	addi	fp,sp,48
 82304c0:	e13ffd15 	stw	r4,-12(fp)
 82304c4:	e17ffe15 	stw	r5,-8(fp)
 82304c8:	e1bfff15 	stw	r6,-4(fp)
   struct sockaddr   sa;
   struct sockaddr * sap;
   struct socket *   so;
   int               err;

   so = LONG2SO(s);  /* convert long to socket */
 82304cc:	e0bffd17 	ldw	r2,-12(fp)
 82304d0:	10bff804 	addi	r2,r2,-32
 82304d4:	1085883a 	add	r2,r2,r2
 82304d8:	1085883a 	add	r2,r2,r2
 82304dc:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 82304e0:	008209b4 	movhi	r2,2086
 82304e4:	10b95804 	addi	r2,r2,-6816
 82304e8:	e0bff515 	stw	r2,-44(fp)
 82304ec:	00000606 	br	8230508 <t_bind+0x58>
 82304f0:	e0fff517 	ldw	r3,-44(fp)
 82304f4:	e0bff617 	ldw	r2,-40(fp)
 82304f8:	18800626 	beq	r3,r2,8230514 <t_bind+0x64>
 82304fc:	e0bff517 	ldw	r2,-44(fp)
 8230500:	10800017 	ldw	r2,0(r2)
 8230504:	e0bff515 	stw	r2,-44(fp)
 8230508:	e0bff517 	ldw	r2,-44(fp)
 823050c:	103ff81e 	bne	r2,zero,82304f0 <t_bind+0x40>
 8230510:	00000106 	br	8230518 <t_bind+0x68>
 8230514:	0001883a 	nop
 8230518:	e0fff517 	ldw	r3,-44(fp)
 823051c:	e0bff617 	ldw	r2,-40(fp)
 8230520:	18800326 	beq	r3,r2,8230530 <t_bind+0x80>
 8230524:	822d5940 	call	822d594 <dtrap>
 8230528:	00bfffc4 	movi	r2,-1
 823052c:	00003406 	br	8230600 <t_bind+0x150>
   DOMAIN_CHECK(so, addrlen);
 8230530:	e17fff17 	ldw	r5,-4(fp)
 8230534:	e13ff617 	ldw	r4,-40(fp)
 8230538:	82303e00 	call	82303e0 <DOMAIN_CHECK>

   so->so_error = 0;
 823053c:	e0bff617 	ldw	r2,-40(fp)
 8230540:	10000615 	stw	zero,24(r2)
   if (addr == (struct sockaddr *)NULL) 
 8230544:	e0bffe17 	ldw	r2,-8(fp)
 8230548:	10000d1e 	bne	r2,zero,8230580 <t_bind+0xd0>
   {
      MEMSET ((void *)&sa, 0, sizeof(sa));
 823054c:	e0bff904 	addi	r2,fp,-28
 8230550:	01800404 	movi	r6,16
 8230554:	000b883a 	mov	r5,zero
 8230558:	1009883a 	mov	r4,r2
 823055c:	82031b40 	call	82031b4 <memset>
      addrlen = sizeof(sa);
 8230560:	00800404 	movi	r2,16
 8230564:	e0bfff15 	stw	r2,-4(fp)
      sa.sa_family = so->so_domain;
 8230568:	e0bff617 	ldw	r2,-40(fp)
 823056c:	10800517 	ldw	r2,20(r2)
 8230570:	e0bff90d 	sth	r2,-28(fp)
      sap = &sa;
 8230574:	e0bff904 	addi	r2,fp,-28
 8230578:	e0bff415 	stw	r2,-48(fp)
 823057c:	00000206 	br	8230588 <t_bind+0xd8>
   } else
      sap = addr;
 8230580:	e0bffe17 	ldw	r2,-8(fp)
 8230584:	e0bff415 	stw	r2,-48(fp)

   if ((nam = sockargs (sap, addrlen, MT_SONAME)) == NULL) 
 8230588:	01800244 	movi	r6,9
 823058c:	e17fff17 	ldw	r5,-4(fp)
 8230590:	e13ff417 	ldw	r4,-48(fp)
 8230594:	82319100 	call	8231910 <sockargs>
 8230598:	e0bff715 	stw	r2,-36(fp)
 823059c:	e0bff717 	ldw	r2,-36(fp)
 82305a0:	1000051e 	bne	r2,zero,82305b8 <t_bind+0x108>
   {
      so->so_error = ENOMEM;
 82305a4:	e0bff617 	ldw	r2,-40(fp)
 82305a8:	00c00304 	movi	r3,12
 82305ac:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 82305b0:	00bfffc4 	movi	r2,-1
 82305b4:	00001206 	br	8230600 <t_bind+0x150>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 82305b8:	0009883a 	mov	r4,zero
 82305bc:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   err = sobind (so, nam);
 82305c0:	e17ff717 	ldw	r5,-36(fp)
 82305c4:	e13ff617 	ldw	r4,-40(fp)
 82305c8:	8231bdc0 	call	8231bdc <sobind>
 82305cc:	e0bff815 	stw	r2,-32(fp)
   m_freem(nam);
 82305d0:	e13ff717 	ldw	r4,-36(fp)
 82305d4:	822e6380 	call	822e638 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 82305d8:	0009883a 	mov	r4,zero
 82305dc:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   if (err) 
 82305e0:	e0bff817 	ldw	r2,-32(fp)
 82305e4:	10000526 	beq	r2,zero,82305fc <t_bind+0x14c>
   {
      so->so_error = err;
 82305e8:	e0bff617 	ldw	r2,-40(fp)
 82305ec:	e0fff817 	ldw	r3,-32(fp)
 82305f0:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 82305f4:	00bfffc4 	movi	r2,-1
 82305f8:	00000106 	br	8230600 <t_bind+0x150>
   }
   return 0;
 82305fc:	0005883a 	mov	r2,zero
}
 8230600:	e037883a 	mov	sp,fp
 8230604:	dfc00117 	ldw	ra,4(sp)
 8230608:	df000017 	ldw	fp,0(sp)
 823060c:	dec00204 	addi	sp,sp,8
 8230610:	f800283a 	ret

08230614 <t_listen>:
 */

int
t_listen(long s, 
   int   backlog)
{
 8230614:	defff904 	addi	sp,sp,-28
 8230618:	dfc00615 	stw	ra,24(sp)
 823061c:	df000515 	stw	fp,20(sp)
 8230620:	df000504 	addi	fp,sp,20
 8230624:	e13ffe15 	stw	r4,-8(fp)
 8230628:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);  /* convert long to socket */
 823062c:	e0bffe17 	ldw	r2,-8(fp)
 8230630:	10bff804 	addi	r2,r2,-32
 8230634:	1085883a 	add	r2,r2,r2
 8230638:	1085883a 	add	r2,r2,r2
 823063c:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 8230640:	008209b4 	movhi	r2,2086
 8230644:	10b95804 	addi	r2,r2,-6816
 8230648:	e0bffb15 	stw	r2,-20(fp)
 823064c:	00000606 	br	8230668 <t_listen+0x54>
 8230650:	e0fffb17 	ldw	r3,-20(fp)
 8230654:	e0bffc17 	ldw	r2,-16(fp)
 8230658:	18800626 	beq	r3,r2,8230674 <t_listen+0x60>
 823065c:	e0bffb17 	ldw	r2,-20(fp)
 8230660:	10800017 	ldw	r2,0(r2)
 8230664:	e0bffb15 	stw	r2,-20(fp)
 8230668:	e0bffb17 	ldw	r2,-20(fp)
 823066c:	103ff81e 	bne	r2,zero,8230650 <t_listen+0x3c>
 8230670:	00000106 	br	8230678 <t_listen+0x64>
 8230674:	0001883a 	nop
 8230678:	e0fffb17 	ldw	r3,-20(fp)
 823067c:	e0bffc17 	ldw	r2,-16(fp)
 8230680:	18800326 	beq	r3,r2,8230690 <t_listen+0x7c>
 8230684:	822d5940 	call	822d594 <dtrap>
 8230688:	00bfffc4 	movi	r2,-1
 823068c:	00001206 	br	82306d8 <t_listen+0xc4>
   so->so_error = 0;
 8230690:	e0bffc17 	ldw	r2,-16(fp)
 8230694:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("SOCK:listen:qlen %d\n", backlog));

   LOCK_NET_RESOURCE(NET_RESID);
 8230698:	0009883a 	mov	r4,zero
 823069c:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   err = solisten (so, backlog);
 82306a0:	e17fff17 	ldw	r5,-4(fp)
 82306a4:	e13ffc17 	ldw	r4,-16(fp)
 82306a8:	8231c380 	call	8231c38 <solisten>
 82306ac:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 82306b0:	0009883a 	mov	r4,zero
 82306b4:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 82306b8:	e0bffd17 	ldw	r2,-12(fp)
 82306bc:	10000526 	beq	r2,zero,82306d4 <t_listen+0xc0>
   {
      so->so_error = err;
 82306c0:	e0bffc17 	ldw	r2,-16(fp)
 82306c4:	e0fffd17 	ldw	r3,-12(fp)
 82306c8:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 82306cc:	00bfffc4 	movi	r2,-1
 82306d0:	00000106 	br	82306d8 <t_listen+0xc4>
   }
   return 0;
 82306d4:	0005883a 	mov	r2,zero
}
 82306d8:	e037883a 	mov	sp,fp
 82306dc:	dfc00117 	ldw	ra,4(sp)
 82306e0:	df000017 	ldw	fp,0(sp)
 82306e4:	dec00204 	addi	sp,sp,8
 82306e8:	f800283a 	ret

082306ec <t_accept>:

long
t_accept(long s, 
   struct sockaddr * addr,
   int * addrlen)
{
 82306ec:	defff704 	addi	sp,sp,-36
 82306f0:	dfc00815 	stw	ra,32(sp)
 82306f4:	df000715 	stw	fp,28(sp)
 82306f8:	df000704 	addi	fp,sp,28
 82306fc:	e13ffd15 	stw	r4,-12(fp)
 8230700:	e17ffe15 	stw	r5,-8(fp)
 8230704:	e1bfff15 	stw	r6,-4(fp)
   char logbuf[10];
#endif
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 8230708:	e0bffd17 	ldw	r2,-12(fp)
 823070c:	10bff804 	addi	r2,r2,-32
 8230710:	1085883a 	add	r2,r2,r2
 8230714:	1085883a 	add	r2,r2,r2
 8230718:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 823071c:	008209b4 	movhi	r2,2086
 8230720:	10b95804 	addi	r2,r2,-6816
 8230724:	e0bff915 	stw	r2,-28(fp)
 8230728:	00000606 	br	8230744 <t_accept+0x58>
 823072c:	e0fff917 	ldw	r3,-28(fp)
 8230730:	e0bffa17 	ldw	r2,-24(fp)
 8230734:	18800626 	beq	r3,r2,8230750 <t_accept+0x64>
 8230738:	e0bff917 	ldw	r2,-28(fp)
 823073c:	10800017 	ldw	r2,0(r2)
 8230740:	e0bff915 	stw	r2,-28(fp)
 8230744:	e0bff917 	ldw	r2,-28(fp)
 8230748:	103ff81e 	bne	r2,zero,823072c <t_accept+0x40>
 823074c:	00000106 	br	8230754 <t_accept+0x68>
 8230750:	0001883a 	nop
 8230754:	e0fff917 	ldw	r3,-28(fp)
 8230758:	e0bffa17 	ldw	r2,-24(fp)
 823075c:	18800326 	beq	r3,r2,823076c <t_accept+0x80>
 8230760:	822d5940 	call	822d594 <dtrap>
 8230764:	00bfffc4 	movi	r2,-1
 8230768:	00007006 	br	823092c <t_accept+0x240>
   DOMAIN_CHECK(so, *addrlen);
 823076c:	e0bfff17 	ldw	r2,-4(fp)
 8230770:	10800017 	ldw	r2,0(r2)
 8230774:	100b883a 	mov	r5,r2
 8230778:	e13ffa17 	ldw	r4,-24(fp)
 823077c:	82303e00 	call	82303e0 <DOMAIN_CHECK>

   so->so_error = 0;
 8230780:	e0bffa17 	ldw	r2,-24(fp)
 8230784:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
      ("INET:accept:so %x so_qlen %d so_state %x\n", so, so->so_qlen, so->so_state));
   if ((so->so_options & SO_ACCEPTCONN) == 0)
 8230788:	e0bffa17 	ldw	r2,-24(fp)
 823078c:	10800417 	ldw	r2,16(r2)
 8230790:	1080008c 	andi	r2,r2,2
 8230794:	1000051e 	bne	r2,zero,82307ac <t_accept+0xc0>
   {
      so->so_error = EINVAL;
 8230798:	e0bffa17 	ldw	r2,-24(fp)
 823079c:	00c00584 	movi	r3,22
 82307a0:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 82307a4:	00bfffc4 	movi	r2,-1
 82307a8:	00006006 	br	823092c <t_accept+0x240>
   }
   if ((so->so_state & SS_NBIO) && so->so_qlen == 0)
 82307ac:	e0bffa17 	ldw	r2,-24(fp)
 82307b0:	1080088b 	ldhu	r2,34(r2)
 82307b4:	10bfffcc 	andi	r2,r2,65535
 82307b8:	1080400c 	andi	r2,r2,256
 82307bc:	10000b26 	beq	r2,zero,82307ec <t_accept+0x100>
 82307c0:	e0bffa17 	ldw	r2,-24(fp)
 82307c4:	10801e43 	ldbu	r2,121(r2)
 82307c8:	10803fcc 	andi	r2,r2,255
 82307cc:	1080201c 	xori	r2,r2,128
 82307d0:	10bfe004 	addi	r2,r2,-128
 82307d4:	1000051e 	bne	r2,zero,82307ec <t_accept+0x100>
   {
      so->so_error = EWOULDBLOCK;
 82307d8:	e0bffa17 	ldw	r2,-24(fp)
 82307dc:	00c002c4 	movi	r3,11
 82307e0:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 82307e4:	00bfffc4 	movi	r2,-1
 82307e8:	00005006 	br	823092c <t_accept+0x240>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 82307ec:	0009883a 	mov	r4,zero
 82307f0:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   while (so->so_qlen == 0 && so->so_error == 0)
 82307f4:	00001006 	br	8230838 <t_accept+0x14c>
   {
      if (so->so_state & SS_CANTRCVMORE)
 82307f8:	e0bffa17 	ldw	r2,-24(fp)
 82307fc:	1080088b 	ldhu	r2,34(r2)
 8230800:	10bfffcc 	andi	r2,r2,65535
 8230804:	1080080c 	andi	r2,r2,32
 8230808:	10000726 	beq	r2,zero,8230828 <t_accept+0x13c>
      {
         so->so_error = ECONNABORTED;
 823080c:	e0bffa17 	ldw	r2,-24(fp)
 8230810:	00c01c44 	movi	r3,113
 8230814:	10c00615 	stw	r3,24(r2)
         UNLOCK_NET_RESOURCE(NET_RESID);
 8230818:	0009883a 	mov	r4,zero
 823081c:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 8230820:	00bfffc4 	movi	r2,-1
 8230824:	00004106 	br	823092c <t_accept+0x240>
      }
      tcp_sleep ((char *)&so->so_timeo);
 8230828:	e0bffa17 	ldw	r2,-24(fp)
 823082c:	10800904 	addi	r2,r2,36
 8230830:	1009883a 	mov	r4,r2
 8230834:	82295340 	call	8229534 <tcp_sleep>
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
   }
   LOCK_NET_RESOURCE(NET_RESID);
   while (so->so_qlen == 0 && so->so_error == 0)
 8230838:	e0bffa17 	ldw	r2,-24(fp)
 823083c:	10801e43 	ldbu	r2,121(r2)
 8230840:	10803fcc 	andi	r2,r2,255
 8230844:	1080201c 	xori	r2,r2,128
 8230848:	10bfe004 	addi	r2,r2,-128
 823084c:	1000031e 	bne	r2,zero,823085c <t_accept+0x170>
 8230850:	e0bffa17 	ldw	r2,-24(fp)
 8230854:	10800617 	ldw	r2,24(r2)
 8230858:	103fe726 	beq	r2,zero,82307f8 <t_accept+0x10c>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return SOCKET_ERROR;
      }
      tcp_sleep ((char *)&so->so_timeo);
   }
   if (so->so_error)
 823085c:	e0bffa17 	ldw	r2,-24(fp)
 8230860:	10800617 	ldw	r2,24(r2)
 8230864:	10000426 	beq	r2,zero,8230878 <t_accept+0x18c>
   {
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 8230868:	0009883a 	mov	r4,zero
 823086c:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 8230870:	00bfffc4 	movi	r2,-1
 8230874:	00002d06 	br	823092c <t_accept+0x240>
   }
   nam = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 8230878:	01400404 	movi	r5,16
 823087c:	01000244 	movi	r4,9
 8230880:	822e3a80 	call	822e3a8 <m_getnbuf>
 8230884:	e0bffb15 	stw	r2,-20(fp)
   if (nam == NULL) 
 8230888:	e0bffb17 	ldw	r2,-20(fp)
 823088c:	1000071e 	bne	r2,zero,82308ac <t_accept+0x1c0>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 8230890:	0009883a 	mov	r4,zero
 8230894:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      so->so_error = ENOMEM;
 8230898:	e0bffa17 	ldw	r2,-24(fp)
 823089c:	00c00304 	movi	r3,12
 82308a0:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 82308a4:	00bfffc4 	movi	r2,-1
 82308a8:	00002006 	br	823092c <t_accept+0x240>
   }
   { 
      struct socket *aso = so->so_q;
 82308ac:	e0bffa17 	ldw	r2,-24(fp)
 82308b0:	10801d17 	ldw	r2,116(r2)
 82308b4:	e0bffc15 	stw	r2,-16(fp)
      if (soqremque (aso, 1) == 0)
 82308b8:	01400044 	movi	r5,1
 82308bc:	e13ffc17 	ldw	r4,-16(fp)
 82308c0:	8233fe40 	call	8233fe4 <soqremque>
 82308c4:	1000031e 	bne	r2,zero,82308d4 <t_accept+0x1e8>
         panic("accept");
 82308c8:	01020974 	movhi	r4,2085
 82308cc:	21037404 	addi	r4,r4,3536
 82308d0:	8228c480 	call	8228c48 <panic>
      so = aso;
 82308d4:	e0bffc17 	ldw	r2,-16(fp)
 82308d8:	e0bffa15 	stw	r2,-24(fp)
   }
   (void)soaccept (so, nam);
 82308dc:	e17ffb17 	ldw	r5,-20(fp)
 82308e0:	e13ffa17 	ldw	r4,-24(fp)
 82308e4:	82321240 	call	8232124 <soaccept>
      INET_TRACE (INETM_SOCKET, ("INET:accept:done so %lx port %d addr %lx\n",
       so, sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_INET */
   /* return the addressing info in the passed structure */
   if (addr != NULL)
 82308e8:	e0bffe17 	ldw	r2,-8(fp)
 82308ec:	10000826 	beq	r2,zero,8230910 <t_accept+0x224>
      MEMCPY(addr, nam->m_data, *addrlen);
 82308f0:	e0bffb17 	ldw	r2,-20(fp)
 82308f4:	10c00317 	ldw	r3,12(r2)
 82308f8:	e0bfff17 	ldw	r2,-4(fp)
 82308fc:	10800017 	ldw	r2,0(r2)
 8230900:	100d883a 	mov	r6,r2
 8230904:	180b883a 	mov	r5,r3
 8230908:	e13ffe17 	ldw	r4,-8(fp)
 823090c:	8202f100 	call	8202f10 <memcpy>
   m_freem (nam);
 8230910:	e13ffb17 	ldw	r4,-20(fp)
 8230914:	822e6380 	call	822e638 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 8230918:	0009883a 	mov	r4,zero
 823091c:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   SOC_RANGE(so);
   return SO2LONG(so);
 8230920:	e0bffa17 	ldw	r2,-24(fp)
 8230924:	1004d0ba 	srli	r2,r2,2
 8230928:	10800804 	addi	r2,r2,32
}
 823092c:	e037883a 	mov	sp,fp
 8230930:	dfc00117 	ldw	ra,4(sp)
 8230934:	df000017 	ldw	fp,0(sp)
 8230938:	dec00204 	addi	sp,sp,8
 823093c:	f800283a 	ret

08230940 <t_connect>:

int
t_connect(long s, 
   struct sockaddr * addr,
   int   addrlen)
{
 8230940:	defff804 	addi	sp,sp,-32
 8230944:	dfc00715 	stw	ra,28(sp)
 8230948:	df000615 	stw	fp,24(sp)
 823094c:	df000604 	addi	fp,sp,24
 8230950:	e13ffd15 	stw	r4,-12(fp)
 8230954:	e17ffe15 	stw	r5,-8(fp)
 8230958:	e1bfff15 	stw	r6,-4(fp)
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 823095c:	e0bffd17 	ldw	r2,-12(fp)
 8230960:	10bff804 	addi	r2,r2,-32
 8230964:	1085883a 	add	r2,r2,r2
 8230968:	1085883a 	add	r2,r2,r2
 823096c:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 8230970:	008209b4 	movhi	r2,2086
 8230974:	10b95804 	addi	r2,r2,-6816
 8230978:	e0bffa15 	stw	r2,-24(fp)
 823097c:	00000606 	br	8230998 <t_connect+0x58>
 8230980:	e0fffa17 	ldw	r3,-24(fp)
 8230984:	e0bffb17 	ldw	r2,-20(fp)
 8230988:	18800626 	beq	r3,r2,82309a4 <t_connect+0x64>
 823098c:	e0bffa17 	ldw	r2,-24(fp)
 8230990:	10800017 	ldw	r2,0(r2)
 8230994:	e0bffa15 	stw	r2,-24(fp)
 8230998:	e0bffa17 	ldw	r2,-24(fp)
 823099c:	103ff81e 	bne	r2,zero,8230980 <t_connect+0x40>
 82309a0:	00000106 	br	82309a8 <t_connect+0x68>
 82309a4:	0001883a 	nop
 82309a8:	e0fffa17 	ldw	r3,-24(fp)
 82309ac:	e0bffb17 	ldw	r2,-20(fp)
 82309b0:	18800326 	beq	r3,r2,82309c0 <t_connect+0x80>
 82309b4:	822d5940 	call	822d594 <dtrap>
 82309b8:	00bfffc4 	movi	r2,-1
 82309bc:	00007606 	br	8230b98 <t_connect+0x258>
   DOMAIN_CHECK(so, addrlen);
 82309c0:	e17fff17 	ldw	r5,-4(fp)
 82309c4:	e13ffb17 	ldw	r4,-20(fp)
 82309c8:	82303e00 	call	82303e0 <DOMAIN_CHECK>

#ifdef NB_CONNECT
   /* need to test non blocking connect bits in case this is a 
      poll of a previous request */
   if (so->so_state & SS_NBIO)
 82309cc:	e0bffb17 	ldw	r2,-20(fp)
 82309d0:	1080088b 	ldhu	r2,34(r2)
 82309d4:	10bfffcc 	andi	r2,r2,65535
 82309d8:	1080400c 	andi	r2,r2,256
 82309dc:	10002426 	beq	r2,zero,8230a70 <t_connect+0x130>
   {
      if (so->so_state & SS_ISCONNECTING) /* still trying */
 82309e0:	e0bffb17 	ldw	r2,-20(fp)
 82309e4:	1080088b 	ldhu	r2,34(r2)
 82309e8:	10bfffcc 	andi	r2,r2,65535
 82309ec:	1080010c 	andi	r2,r2,4
 82309f0:	10000526 	beq	r2,zero,8230a08 <t_connect+0xc8>
      {
         so->so_error = EINPROGRESS;
 82309f4:	e0bffb17 	ldw	r2,-20(fp)
 82309f8:	00c01dc4 	movi	r3,119
 82309fc:	10c00615 	stw	r3,24(r2)
         return SOCKET_ERROR;
 8230a00:	00bfffc4 	movi	r2,-1
 8230a04:	00006406 	br	8230b98 <t_connect+0x258>
      }
      if (so->so_state & SS_ISCONNECTED)  /* connected OK */
 8230a08:	e0bffb17 	ldw	r2,-20(fp)
 8230a0c:	1080088b 	ldhu	r2,34(r2)
 8230a10:	10bfffcc 	andi	r2,r2,65535
 8230a14:	1080008c 	andi	r2,r2,2
 8230a18:	10000426 	beq	r2,zero,8230a2c <t_connect+0xec>
      {
         so->so_error = 0;
 8230a1c:	e0bffb17 	ldw	r2,-20(fp)
 8230a20:	10000615 	stw	zero,24(r2)
         return 0;
 8230a24:	0005883a 	mov	r2,zero
 8230a28:	00005b06 	br	8230b98 <t_connect+0x258>
      }
      if (so->so_state & SS_WASCONNECTING)
 8230a2c:	e0bffb17 	ldw	r2,-20(fp)
 8230a30:	1080088b 	ldhu	r2,34(r2)
 8230a34:	10bfffcc 	andi	r2,r2,65535
 8230a38:	1088000c 	andi	r2,r2,8192
 8230a3c:	10000c26 	beq	r2,zero,8230a70 <t_connect+0x130>
      {
         so->so_state &= ~SS_WASCONNECTING;
 8230a40:	e0bffb17 	ldw	r2,-20(fp)
 8230a44:	10c0088b 	ldhu	r3,34(r2)
 8230a48:	00b7ffc4 	movi	r2,-8193
 8230a4c:	1884703a 	and	r2,r3,r2
 8230a50:	1007883a 	mov	r3,r2
 8230a54:	e0bffb17 	ldw	r2,-20(fp)
 8230a58:	10c0088d 	sth	r3,34(r2)
         if (so->so_error) /* connect error - maybe timeout */
 8230a5c:	e0bffb17 	ldw	r2,-20(fp)
 8230a60:	10800617 	ldw	r2,24(r2)
 8230a64:	10000226 	beq	r2,zero,8230a70 <t_connect+0x130>
            return SOCKET_ERROR;
 8230a68:	00bfffc4 	movi	r2,-1
 8230a6c:	00004a06 	br	8230b98 <t_connect+0x258>
      }
   }
#endif   /*  NB_CONNECT */

   so->so_error = 0;
 8230a70:	e0bffb17 	ldw	r2,-20(fp)
 8230a74:	10000615 	stw	zero,24(r2)

   if ((nam = sockargs (addr, addrlen, MT_SONAME))
 8230a78:	01800244 	movi	r6,9
 8230a7c:	e17fff17 	ldw	r5,-4(fp)
 8230a80:	e13ffe17 	ldw	r4,-8(fp)
 8230a84:	82319100 	call	8231910 <sockargs>
 8230a88:	e0bffc15 	stw	r2,-16(fp)
 8230a8c:	e0bffc17 	ldw	r2,-16(fp)
 8230a90:	1000051e 	bne	r2,zero,8230aa8 <t_connect+0x168>
       == NULL)
   {
      so->so_error = ENOMEM;
 8230a94:	e0bffb17 	ldw	r2,-20(fp)
 8230a98:	00c00304 	movi	r3,12
 8230a9c:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8230aa0:	00bfffc4 	movi	r2,-1
 8230aa4:	00003c06 	br	8230b98 <t_connect+0x258>
      INET_TRACE (INETM_SOCKET, ("INET: connect, port %d addr %lx\n",
       sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_DEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 8230aa8:	0009883a 	mov	r4,zero
 8230aac:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   if ((so->so_error = soconnect (so, nam)) != 0)
 8230ab0:	e17ffc17 	ldw	r5,-16(fp)
 8230ab4:	e13ffb17 	ldw	r4,-20(fp)
 8230ab8:	82321bc0 	call	82321bc <soconnect>
 8230abc:	1007883a 	mov	r3,r2
 8230ac0:	e0bffb17 	ldw	r2,-20(fp)
 8230ac4:	10c00615 	stw	r3,24(r2)
 8230ac8:	e0bffb17 	ldw	r2,-20(fp)
 8230acc:	10800617 	ldw	r2,24(r2)
 8230ad0:	10001b1e 	bne	r2,zero,8230b40 <t_connect+0x200>
      goto bad;

#ifdef NB_CONNECT
   /* need to test non blocking connect bits after soconnect() call */
   if ((so->so_state & SS_NBIO)&& (so->so_state & SS_ISCONNECTING))
 8230ad4:	e0bffb17 	ldw	r2,-20(fp)
 8230ad8:	1080088b 	ldhu	r2,34(r2)
 8230adc:	10bfffcc 	andi	r2,r2,65535
 8230ae0:	1080400c 	andi	r2,r2,256
 8230ae4:	10000d26 	beq	r2,zero,8230b1c <t_connect+0x1dc>
 8230ae8:	e0bffb17 	ldw	r2,-20(fp)
 8230aec:	1080088b 	ldhu	r2,34(r2)
 8230af0:	10bfffcc 	andi	r2,r2,65535
 8230af4:	1080010c 	andi	r2,r2,4
 8230af8:	10000826 	beq	r2,zero,8230b1c <t_connect+0x1dc>
   {
      so->so_error = EINPROGRESS;
 8230afc:	e0bffb17 	ldw	r2,-20(fp)
 8230b00:	00c01dc4 	movi	r3,119
 8230b04:	10c00615 	stw	r3,24(r2)
      goto bad;
 8230b08:	00000e06 	br	8230b44 <t_connect+0x204>
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
   {
      tcp_sleep ((char *)&so->so_timeo);
 8230b0c:	e0bffb17 	ldw	r2,-20(fp)
 8230b10:	10800904 	addi	r2,r2,36
 8230b14:	1009883a 	mov	r4,r2
 8230b18:	82295340 	call	8229534 <tcp_sleep>
   }
#endif   /*  NB_CONNECT */
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
 8230b1c:	e0bffb17 	ldw	r2,-20(fp)
 8230b20:	1080088b 	ldhu	r2,34(r2)
 8230b24:	10bfffcc 	andi	r2,r2,65535
 8230b28:	1080010c 	andi	r2,r2,4
 8230b2c:	10000526 	beq	r2,zero,8230b44 <t_connect+0x204>
 8230b30:	e0bffb17 	ldw	r2,-20(fp)
 8230b34:	10800617 	ldw	r2,24(r2)
 8230b38:	103ff426 	beq	r2,zero,8230b0c <t_connect+0x1cc>
 8230b3c:	00000106 	br	8230b44 <t_connect+0x204>
   }
#endif   /* TRACE_DEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
   if ((so->so_error = soconnect (so, nam)) != 0)
      goto bad;
 8230b40:	0001883a 	nop
   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
   {
      tcp_sleep ((char *)&so->so_timeo);
   }
bad:
   if (so->so_error != EINPROGRESS)
 8230b44:	e0bffb17 	ldw	r2,-20(fp)
 8230b48:	10800617 	ldw	r2,24(r2)
 8230b4c:	10801de0 	cmpeqi	r2,r2,119
 8230b50:	1000071e 	bne	r2,zero,8230b70 <t_connect+0x230>
      so->so_state &= ~(SS_ISCONNECTING|SS_WASCONNECTING);
 8230b54:	e0bffb17 	ldw	r2,-20(fp)
 8230b58:	10c0088b 	ldhu	r3,34(r2)
 8230b5c:	00b7fec4 	movi	r2,-8197
 8230b60:	1884703a 	and	r2,r3,r2
 8230b64:	1007883a 	mov	r3,r2
 8230b68:	e0bffb17 	ldw	r2,-20(fp)
 8230b6c:	10c0088d 	sth	r3,34(r2)
   m_freem (nam);
 8230b70:	e13ffc17 	ldw	r4,-16(fp)
 8230b74:	822e6380 	call	822e638 <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 8230b78:	0009883a 	mov	r4,zero
 8230b7c:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   if (so->so_error)
 8230b80:	e0bffb17 	ldw	r2,-20(fp)
 8230b84:	10800617 	ldw	r2,24(r2)
 8230b88:	10000226 	beq	r2,zero,8230b94 <t_connect+0x254>
   {
/*      printf("t_connect(): so_error = %d\n", so->so_error);*/
      return SOCKET_ERROR;
 8230b8c:	00bfffc4 	movi	r2,-1
 8230b90:	00000106 	br	8230b98 <t_connect+0x258>

   }
      return 0;
 8230b94:	0005883a 	mov	r2,zero
}
 8230b98:	e037883a 	mov	sp,fp
 8230b9c:	dfc00117 	ldw	ra,4(sp)
 8230ba0:	df000017 	ldw	fp,0(sp)
 8230ba4:	dec00204 	addi	sp,sp,8
 8230ba8:	f800283a 	ret

08230bac <t_getpeername>:
 * RETURNS: 
 */

int
t_getpeername(long s, struct sockaddr * addr, int * addrlen)
{
 8230bac:	defffb04 	addi	sp,sp,-20
 8230bb0:	dfc00415 	stw	ra,16(sp)
 8230bb4:	df000315 	stw	fp,12(sp)
 8230bb8:	df000304 	addi	fp,sp,12
 8230bbc:	e13ffd15 	stw	r4,-12(fp)
 8230bc0:	e17ffe15 	stw	r5,-8(fp)
 8230bc4:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_PEERADDR));
 8230bc8:	01c00404 	movi	r7,16
 8230bcc:	e1bfff17 	ldw	r6,-4(fp)
 8230bd0:	e17ffe17 	ldw	r5,-8(fp)
 8230bd4:	e13ffd17 	ldw	r4,-12(fp)
 8230bd8:	8230c340 	call	8230c34 <t_getname>
}
 8230bdc:	e037883a 	mov	sp,fp
 8230be0:	dfc00117 	ldw	ra,4(sp)
 8230be4:	df000017 	ldw	fp,0(sp)
 8230be8:	dec00204 	addi	sp,sp,8
 8230bec:	f800283a 	ret

08230bf0 <t_getsockname>:
 * RETURNS: 
 */

int 
t_getsockname(long s, struct sockaddr * addr, int * addrlen)
{
 8230bf0:	defffb04 	addi	sp,sp,-20
 8230bf4:	dfc00415 	stw	ra,16(sp)
 8230bf8:	df000315 	stw	fp,12(sp)
 8230bfc:	df000304 	addi	fp,sp,12
 8230c00:	e13ffd15 	stw	r4,-12(fp)
 8230c04:	e17ffe15 	stw	r5,-8(fp)
 8230c08:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_SOCKADDR));
 8230c0c:	01c003c4 	movi	r7,15
 8230c10:	e1bfff17 	ldw	r6,-4(fp)
 8230c14:	e17ffe17 	ldw	r5,-8(fp)
 8230c18:	e13ffd17 	ldw	r4,-12(fp)
 8230c1c:	8230c340 	call	8230c34 <t_getname>
}
 8230c20:	e037883a 	mov	sp,fp
 8230c24:	dfc00117 	ldw	ra,4(sp)
 8230c28:	df000017 	ldw	fp,0(sp)
 8230c2c:	dec00204 	addi	sp,sp,8
 8230c30:	f800283a 	ret

08230c34 <t_getname>:
 * RETURNS: 
 */

static int
t_getname(long s, struct sockaddr * addr, int * addrlen, int opcode)
{
 8230c34:	defff604 	addi	sp,sp,-40
 8230c38:	dfc00915 	stw	ra,36(sp)
 8230c3c:	df000815 	stw	fp,32(sp)
 8230c40:	df000804 	addi	fp,sp,32
 8230c44:	e13ffc15 	stw	r4,-16(fp)
 8230c48:	e17ffd15 	stw	r5,-12(fp)
 8230c4c:	e1bffe15 	stw	r6,-8(fp)
 8230c50:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   struct mbuf *  m;
   int   err;

   so = LONG2SO(s);
 8230c54:	e0bffc17 	ldw	r2,-16(fp)
 8230c58:	10bff804 	addi	r2,r2,-32
 8230c5c:	1085883a 	add	r2,r2,r2
 8230c60:	1085883a 	add	r2,r2,r2
 8230c64:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 8230c68:	008209b4 	movhi	r2,2086
 8230c6c:	10b95804 	addi	r2,r2,-6816
 8230c70:	e0bff815 	stw	r2,-32(fp)
 8230c74:	00000606 	br	8230c90 <t_getname+0x5c>
 8230c78:	e0fff817 	ldw	r3,-32(fp)
 8230c7c:	e0bff917 	ldw	r2,-28(fp)
 8230c80:	18800626 	beq	r3,r2,8230c9c <t_getname+0x68>
 8230c84:	e0bff817 	ldw	r2,-32(fp)
 8230c88:	10800017 	ldw	r2,0(r2)
 8230c8c:	e0bff815 	stw	r2,-32(fp)
 8230c90:	e0bff817 	ldw	r2,-32(fp)
 8230c94:	103ff81e 	bne	r2,zero,8230c78 <t_getname+0x44>
 8230c98:	00000106 	br	8230ca0 <t_getname+0x6c>
 8230c9c:	0001883a 	nop
 8230ca0:	e0fff817 	ldw	r3,-32(fp)
 8230ca4:	e0bff917 	ldw	r2,-28(fp)
 8230ca8:	18800326 	beq	r3,r2,8230cb8 <t_getname+0x84>
 8230cac:	822d5940 	call	822d594 <dtrap>
 8230cb0:	00bfffc4 	movi	r2,-1
 8230cb4:	00005106 	br	8230dfc <t_getname+0x1c8>

   so->so_error = 0;
 8230cb8:	e0bff917 	ldw	r2,-28(fp)
 8230cbc:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:get[sock|peer]name so %x\n", so));
   if((opcode == PRU_PEERADDR) && (so->so_state & SS_ISCONNECTED) == 0)
 8230cc0:	e0bfff17 	ldw	r2,-4(fp)
 8230cc4:	10800418 	cmpnei	r2,r2,16
 8230cc8:	10000a1e 	bne	r2,zero,8230cf4 <t_getname+0xc0>
 8230ccc:	e0bff917 	ldw	r2,-28(fp)
 8230cd0:	1080088b 	ldhu	r2,34(r2)
 8230cd4:	10bfffcc 	andi	r2,r2,65535
 8230cd8:	1080008c 	andi	r2,r2,2
 8230cdc:	1000051e 	bne	r2,zero,8230cf4 <t_getname+0xc0>
   {
      so->so_error = ENOTCONN;
 8230ce0:	e0bff917 	ldw	r2,-28(fp)
 8230ce4:	00c02004 	movi	r3,128
 8230ce8:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8230cec:	00bfffc4 	movi	r2,-1
 8230cf0:	00004206 	br	8230dfc <t_getname+0x1c8>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 8230cf4:	0009883a 	mov	r4,zero
 8230cf8:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 8230cfc:	01400404 	movi	r5,16
 8230d00:	01000244 	movi	r4,9
 8230d04:	822e3a80 	call	822e3a8 <m_getnbuf>
 8230d08:	e0bffa15 	stw	r2,-24(fp)
   if (m == NULL) 
 8230d0c:	e0bffa17 	ldw	r2,-24(fp)
 8230d10:	1000071e 	bne	r2,zero,8230d30 <t_getname+0xfc>
   {
      so->so_error = ENOMEM;
 8230d14:	e0bff917 	ldw	r2,-28(fp)
 8230d18:	00c00304 	movi	r3,12
 8230d1c:	10c00615 	stw	r3,24(r2)
      UNLOCK_NET_RESOURCE(NET_RESID);
 8230d20:	0009883a 	mov	r4,zero
 8230d24:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 8230d28:	00bfffc4 	movi	r2,-1
 8230d2c:	00003306 	br	8230dfc <t_getname+0x1c8>
   }
   so->so_req = opcode;
 8230d30:	e0bff917 	ldw	r2,-28(fp)
 8230d34:	e0ffff17 	ldw	r3,-4(fp)
 8230d38:	10c00715 	stw	r3,28(r2)
   if ((err = (*so->so_proto->pr_usrreq)(so, 0, m)) != 0)
 8230d3c:	e0bff917 	ldw	r2,-28(fp)
 8230d40:	10800217 	ldw	r2,8(r2)
 8230d44:	10800317 	ldw	r2,12(r2)
 8230d48:	e1bffa17 	ldw	r6,-24(fp)
 8230d4c:	000b883a 	mov	r5,zero
 8230d50:	e13ff917 	ldw	r4,-28(fp)
 8230d54:	103ee83a 	callr	r2
 8230d58:	e0bffb15 	stw	r2,-20(fp)
 8230d5c:	e0bffb17 	ldw	r2,-20(fp)
 8230d60:	1000191e 	bne	r2,zero,8230dc8 <t_getname+0x194>
      goto bad;

#ifdef IP_V4
   if(so->so_domain == AF_INET)
 8230d64:	e0bff917 	ldw	r2,-28(fp)
 8230d68:	10800517 	ldw	r2,20(r2)
 8230d6c:	10800098 	cmpnei	r2,r2,2
 8230d70:	1000161e 	bne	r2,zero,8230dcc <t_getname+0x198>
   {
      if(*addrlen < sizeof(struct sockaddr_in))
 8230d74:	e0bffe17 	ldw	r2,-8(fp)
 8230d78:	10800017 	ldw	r2,0(r2)
 8230d7c:	10800428 	cmpgeui	r2,r2,16
 8230d80:	1000071e 	bne	r2,zero,8230da0 <t_getname+0x16c>
      {
         dtrap();    /* programming error */
 8230d84:	822d5940 	call	822d594 <dtrap>
         m_freem(m);
 8230d88:	e13ffa17 	ldw	r4,-24(fp)
 8230d8c:	822e6380 	call	822e638 <m_freem>
         UNLOCK_NET_RESOURCE(NET_RESID);
 8230d90:	0009883a 	mov	r4,zero
 8230d94:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         return EINVAL;
 8230d98:	00800584 	movi	r2,22
 8230d9c:	00001706 	br	8230dfc <t_getname+0x1c8>
      }
      MEMCPY(addr, m->m_data, sizeof(struct sockaddr_in));
 8230da0:	e0bffa17 	ldw	r2,-24(fp)
 8230da4:	10800317 	ldw	r2,12(r2)
 8230da8:	01800404 	movi	r6,16
 8230dac:	100b883a 	mov	r5,r2
 8230db0:	e13ffd17 	ldw	r4,-12(fp)
 8230db4:	8202f100 	call	8202f10 <memcpy>
      *addrlen = sizeof(struct sockaddr_in);
 8230db8:	e0bffe17 	ldw	r2,-8(fp)
 8230dbc:	00c00404 	movi	r3,16
 8230dc0:	10c00015 	stw	r3,0(r2)
 8230dc4:	00000106 	br	8230dcc <t_getname+0x198>
      UNLOCK_NET_RESOURCE(NET_RESID);
      return SOCKET_ERROR;
   }
   so->so_req = opcode;
   if ((err = (*so->so_proto->pr_usrreq)(so, 0, m)) != 0)
      goto bad;
 8230dc8:	0001883a 	nop
   }
#endif   /* IP_V6 */


bad:
   m_freem(m);
 8230dcc:	e13ffa17 	ldw	r4,-24(fp)
 8230dd0:	822e6380 	call	822e638 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 8230dd4:	0009883a 	mov	r4,zero
 8230dd8:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   if (err) 
 8230ddc:	e0bffb17 	ldw	r2,-20(fp)
 8230de0:	10000526 	beq	r2,zero,8230df8 <t_getname+0x1c4>
   {
      so->so_error = err;
 8230de4:	e0bff917 	ldw	r2,-28(fp)
 8230de8:	e0fffb17 	ldw	r3,-20(fp)
 8230dec:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8230df0:	00bfffc4 	movi	r2,-1
 8230df4:	00000106 	br	8230dfc <t_getname+0x1c8>
   }
   return 0;
 8230df8:	0005883a 	mov	r2,zero
}
 8230dfc:	e037883a 	mov	sp,fp
 8230e00:	dfc00117 	ldw	ra,4(sp)
 8230e04:	df000017 	ldw	fp,0(sp)
 8230e08:	dec00204 	addi	sp,sp,8
 8230e0c:	f800283a 	ret

08230e10 <t_setsockopt>:
t_setsockopt(long s,
   int   level,
   int   name,
   void * arg,
   int arglen)
{
 8230e10:	defff704 	addi	sp,sp,-36
 8230e14:	dfc00815 	stw	ra,32(sp)
 8230e18:	df000715 	stw	fp,28(sp)
 8230e1c:	df000704 	addi	fp,sp,28
 8230e20:	e13ffc15 	stw	r4,-16(fp)
 8230e24:	e17ffd15 	stw	r5,-12(fp)
 8230e28:	e1bffe15 	stw	r6,-8(fp)
 8230e2c:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 8230e30:	e0bffc17 	ldw	r2,-16(fp)
 8230e34:	10bff804 	addi	r2,r2,-32
 8230e38:	1085883a 	add	r2,r2,r2
 8230e3c:	1085883a 	add	r2,r2,r2
 8230e40:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 8230e44:	008209b4 	movhi	r2,2086
 8230e48:	10b95804 	addi	r2,r2,-6816
 8230e4c:	e0bff915 	stw	r2,-28(fp)
 8230e50:	00000606 	br	8230e6c <t_setsockopt+0x5c>
 8230e54:	e0fff917 	ldw	r3,-28(fp)
 8230e58:	e0bffa17 	ldw	r2,-24(fp)
 8230e5c:	18800626 	beq	r3,r2,8230e78 <t_setsockopt+0x68>
 8230e60:	e0bff917 	ldw	r2,-28(fp)
 8230e64:	10800017 	ldw	r2,0(r2)
 8230e68:	e0bff915 	stw	r2,-28(fp)
 8230e6c:	e0bff917 	ldw	r2,-28(fp)
 8230e70:	103ff81e 	bne	r2,zero,8230e54 <t_setsockopt+0x44>
 8230e74:	00000106 	br	8230e7c <t_setsockopt+0x6c>
 8230e78:	0001883a 	nop
 8230e7c:	e0fff917 	ldw	r3,-28(fp)
 8230e80:	e0bffa17 	ldw	r2,-24(fp)
 8230e84:	18800326 	beq	r3,r2,8230e94 <t_setsockopt+0x84>
 8230e88:	822d5940 	call	822d594 <dtrap>
 8230e8c:	00bfffc4 	movi	r2,-1
 8230e90:	00004a06 	br	8230fbc <t_setsockopt+0x1ac>
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 8230e94:	0009883a 	mov	r4,zero
 8230e98:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>

   so->so_error = 0;
 8230e9c:	e0bffa17 	ldw	r2,-24(fp)
 8230ea0:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
    ("INET: setsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 8230ea4:	e0bffd17 	ldw	r2,-12(fp)
 8230ea8:	10800060 	cmpeqi	r2,r2,1
 8230eac:	10000e1e 	bne	r2,zero,8230ee8 <t_setsockopt+0xd8>
   {
      if ((err = sosetopt (so, name, arg)) != 0) 
 8230eb0:	e1bfff17 	ldw	r6,-4(fp)
 8230eb4:	e17ffe17 	ldw	r5,-8(fp)
 8230eb8:	e13ffa17 	ldw	r4,-24(fp)
 8230ebc:	82331440 	call	8233144 <sosetopt>
 8230ec0:	e0bffb15 	stw	r2,-20(fp)
 8230ec4:	e0bffb17 	ldw	r2,-20(fp)
 8230ec8:	10003926 	beq	r2,zero,8230fb0 <t_setsockopt+0x1a0>
      {
         so->so_error = err;
 8230ecc:	e0bffa17 	ldw	r2,-24(fp)
 8230ed0:	e0fffb17 	ldw	r3,-20(fp)
 8230ed4:	10c00615 	stw	r3,24(r2)
         UNLOCK_NET_RESOURCE (NET_RESID);
 8230ed8:	0009883a 	mov	r4,zero
 8230edc:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 8230ee0:	00bfffc4 	movi	r2,-1
 8230ee4:	00003506 	br	8230fbc <t_setsockopt+0x1ac>
   {
   /* level 1 options are for the IP packet level.
    * the info is carried in the socket CB, then put 
    * into the PACKET.
    */
      if (!so->so_optsPack)
 8230ee8:	e0bffa17 	ldw	r2,-24(fp)
 8230eec:	10801f17 	ldw	r2,124(r2)
 8230ef0:	10000f1e 	bne	r2,zero,8230f30 <t_setsockopt+0x120>
      {
         so->so_optsPack = (struct ip_socopts *) SOCOPT_ALLOC (sizeof(struct ip_socopts *));
 8230ef4:	01000104 	movi	r4,4
 8230ef8:	822e16c0 	call	822e16c <npalloc>
 8230efc:	1007883a 	mov	r3,r2
 8230f00:	e0bffa17 	ldw	r2,-24(fp)
 8230f04:	10c01f15 	stw	r3,124(r2)
         if (!so->so_optsPack) 
 8230f08:	e0bffa17 	ldw	r2,-24(fp)
 8230f0c:	10801f17 	ldw	r2,124(r2)
 8230f10:	1000071e 	bne	r2,zero,8230f30 <t_setsockopt+0x120>
         {
            so->so_error = ENOMEM;
 8230f14:	e0bffa17 	ldw	r2,-24(fp)
 8230f18:	00c00304 	movi	r3,12
 8230f1c:	10c00615 	stw	r3,24(r2)
            UNLOCK_NET_RESOURCE (NET_RESID);
 8230f20:	0009883a 	mov	r4,zero
 8230f24:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
            return SOCKET_ERROR;
 8230f28:	00bfffc4 	movi	r2,-1
 8230f2c:	00002306 	br	8230fbc <t_setsockopt+0x1ac>
         }
      }
      
      if (name == IP_TTL_OPT)
 8230f30:	e0bffe17 	ldw	r2,-8(fp)
 8230f34:	10800118 	cmpnei	r2,r2,4
 8230f38:	1000061e 	bne	r2,zero,8230f54 <t_setsockopt+0x144>
         so->so_optsPack->ip_ttl = (u_char)(*(int *)arg);
 8230f3c:	e0bffa17 	ldw	r2,-24(fp)
 8230f40:	10801f17 	ldw	r2,124(r2)
 8230f44:	e0ffff17 	ldw	r3,-4(fp)
 8230f48:	18c00017 	ldw	r3,0(r3)
 8230f4c:	10c00045 	stb	r3,1(r2)
 8230f50:	00001706 	br	8230fb0 <t_setsockopt+0x1a0>
      else
      if (name == IP_TOS)
 8230f54:	e0bffe17 	ldw	r2,-8(fp)
 8230f58:	108000d8 	cmpnei	r2,r2,3
 8230f5c:	1000061e 	bne	r2,zero,8230f78 <t_setsockopt+0x168>
         so->so_optsPack->ip_tos = (u_char)(*(int *)arg);
 8230f60:	e0bffa17 	ldw	r2,-24(fp)
 8230f64:	10801f17 	ldw	r2,124(r2)
 8230f68:	e0ffff17 	ldw	r3,-4(fp)
 8230f6c:	18c00017 	ldw	r3,0(r3)
 8230f70:	10c00005 	stb	r3,0(r2)
 8230f74:	00000e06 	br	8230fb0 <t_setsockopt+0x1a0>
	   else
	   if (name == IP_SCOPEID)
 8230f78:	e0bffe17 	ldw	r2,-8(fp)
 8230f7c:	10800398 	cmpnei	r2,r2,14
 8230f80:	1000071e 	bne	r2,zero,8230fa0 <t_setsockopt+0x190>
            so->so_optsPack->ip_scopeid = (u_char)(*(u_int *)arg);
 8230f84:	e0bffa17 	ldw	r2,-24(fp)
 8230f88:	10801f17 	ldw	r2,124(r2)
 8230f8c:	e0ffff17 	ldw	r3,-4(fp)
 8230f90:	18c00017 	ldw	r3,0(r3)
 8230f94:	18c03fcc 	andi	r3,r3,255
 8230f98:	10c00115 	stw	r3,4(r2)
 8230f9c:	00000406 	br	8230fb0 <t_setsockopt+0x1a0>
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 8230fa0:	0009883a 	mov	r4,zero
 8230fa4:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 8230fa8:	00bfffc4 	movi	r2,-1
 8230fac:	00000306 	br	8230fbc <t_setsockopt+0x1ac>
      }   
   }

   UNLOCK_NET_RESOURCE (NET_RESID);
 8230fb0:	0009883a 	mov	r4,zero
 8230fb4:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   return 0;
 8230fb8:	0005883a 	mov	r2,zero
}
 8230fbc:	e037883a 	mov	sp,fp
 8230fc0:	dfc00117 	ldw	ra,4(sp)
 8230fc4:	df000017 	ldw	fp,0(sp)
 8230fc8:	dec00204 	addi	sp,sp,8
 8230fcc:	f800283a 	ret

08230fd0 <t_getsockopt>:
   int   level,
   int   name,
   void *   arg,
   int   arglen)

{
 8230fd0:	defff704 	addi	sp,sp,-36
 8230fd4:	dfc00815 	stw	ra,32(sp)
 8230fd8:	df000715 	stw	fp,28(sp)
 8230fdc:	df000704 	addi	fp,sp,28
 8230fe0:	e13ffc15 	stw	r4,-16(fp)
 8230fe4:	e17ffd15 	stw	r5,-12(fp)
 8230fe8:	e1bffe15 	stw	r6,-8(fp)
 8230fec:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 8230ff0:	e0bffc17 	ldw	r2,-16(fp)
 8230ff4:	10bff804 	addi	r2,r2,-32
 8230ff8:	1085883a 	add	r2,r2,r2
 8230ffc:	1085883a 	add	r2,r2,r2
 8231000:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 8231004:	008209b4 	movhi	r2,2086
 8231008:	10b95804 	addi	r2,r2,-6816
 823100c:	e0bff915 	stw	r2,-28(fp)
 8231010:	00000606 	br	823102c <t_getsockopt+0x5c>
 8231014:	e0fff917 	ldw	r3,-28(fp)
 8231018:	e0bffa17 	ldw	r2,-24(fp)
 823101c:	18800626 	beq	r3,r2,8231038 <t_getsockopt+0x68>
 8231020:	e0bff917 	ldw	r2,-28(fp)
 8231024:	10800017 	ldw	r2,0(r2)
 8231028:	e0bff915 	stw	r2,-28(fp)
 823102c:	e0bff917 	ldw	r2,-28(fp)
 8231030:	103ff81e 	bne	r2,zero,8231014 <t_getsockopt+0x44>
 8231034:	00000106 	br	823103c <t_getsockopt+0x6c>
 8231038:	0001883a 	nop
 823103c:	e0fff917 	ldw	r3,-28(fp)
 8231040:	e0bffa17 	ldw	r2,-24(fp)
 8231044:	18800326 	beq	r3,r2,8231054 <t_getsockopt+0x84>
 8231048:	822d5940 	call	822d594 <dtrap>
 823104c:	00bfffc4 	movi	r2,-1
 8231050:	00003d06 	br	8231148 <t_getsockopt+0x178>
   USE_ARG(level);
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 8231054:	0009883a 	mov	r4,zero
 8231058:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   INET_TRACE (INETM_SOCKET,
    ("INET: getsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 823105c:	e0bffd17 	ldw	r2,-12(fp)
 8231060:	10800060 	cmpeqi	r2,r2,1
 8231064:	10000e1e 	bne	r2,zero,82310a0 <t_getsockopt+0xd0>
   {
      if ((err = sogetopt (so, name, arg)) != 0) 
 8231068:	e1bfff17 	ldw	r6,-4(fp)
 823106c:	e17ffe17 	ldw	r5,-8(fp)
 8231070:	e13ffa17 	ldw	r4,-24(fp)
 8231074:	82335740 	call	8233574 <sogetopt>
 8231078:	e0bffb15 	stw	r2,-20(fp)
 823107c:	e0bffb17 	ldw	r2,-20(fp)
 8231080:	10002c26 	beq	r2,zero,8231134 <t_getsockopt+0x164>
      {
         so->so_error = err;
 8231084:	e0bffa17 	ldw	r2,-24(fp)
 8231088:	e0fffb17 	ldw	r3,-20(fp)
 823108c:	10c00615 	stw	r3,24(r2)
         UNLOCK_NET_RESOURCE (NET_RESID);
 8231090:	0009883a 	mov	r4,zero
 8231094:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 8231098:	00bfffc4 	movi	r2,-1
 823109c:	00002a06 	br	8231148 <t_getsockopt+0x178>
   {
      /* level 1 options are for the IP packet level.
       * the info is carried in the socket CB, then put 
       * into the PACKET.
       */
      if (name == IP_TTL_OPT)
 82310a0:	e0bffe17 	ldw	r2,-8(fp)
 82310a4:	10800118 	cmpnei	r2,r2,4
 82310a8:	10000e1e 	bne	r2,zero,82310e4 <t_getsockopt+0x114>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TTL;
 82310ac:	e0bffa17 	ldw	r2,-24(fp)
 82310b0:	10801f17 	ldw	r2,124(r2)
 82310b4:	1000041e 	bne	r2,zero,82310c8 <t_getsockopt+0xf8>
 82310b8:	e0bfff17 	ldw	r2,-4(fp)
 82310bc:	00c01004 	movi	r3,64
 82310c0:	10c00015 	stw	r3,0(r2)
 82310c4:	00001b06 	br	8231134 <t_getsockopt+0x164>
         else *(int *)arg = (int)so->so_optsPack->ip_ttl;
 82310c8:	e0bffa17 	ldw	r2,-24(fp)
 82310cc:	10801f17 	ldw	r2,124(r2)
 82310d0:	10800043 	ldbu	r2,1(r2)
 82310d4:	10c03fcc 	andi	r3,r2,255
 82310d8:	e0bfff17 	ldw	r2,-4(fp)
 82310dc:	10c00015 	stw	r3,0(r2)
 82310e0:	00001406 	br	8231134 <t_getsockopt+0x164>
      }
      else if (name == IP_TOS)
 82310e4:	e0bffe17 	ldw	r2,-8(fp)
 82310e8:	108000d8 	cmpnei	r2,r2,3
 82310ec:	10000d1e 	bne	r2,zero,8231124 <t_getsockopt+0x154>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TOS_DEFVAL;
 82310f0:	e0bffa17 	ldw	r2,-24(fp)
 82310f4:	10801f17 	ldw	r2,124(r2)
 82310f8:	1000031e 	bne	r2,zero,8231108 <t_getsockopt+0x138>
 82310fc:	e0bfff17 	ldw	r2,-4(fp)
 8231100:	10000015 	stw	zero,0(r2)
 8231104:	00000b06 	br	8231134 <t_getsockopt+0x164>
         else *(int *)arg = (int)so->so_optsPack->ip_tos;
 8231108:	e0bffa17 	ldw	r2,-24(fp)
 823110c:	10801f17 	ldw	r2,124(r2)
 8231110:	10800003 	ldbu	r2,0(r2)
 8231114:	10c03fcc 	andi	r3,r2,255
 8231118:	e0bfff17 	ldw	r2,-4(fp)
 823111c:	10c00015 	stw	r3,0(r2)
 8231120:	00000406 	br	8231134 <t_getsockopt+0x164>
      }
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 8231124:	0009883a 	mov	r4,zero
 8231128:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 823112c:	00bfffc4 	movi	r2,-1
 8231130:	00000506 	br	8231148 <t_getsockopt+0x178>
      }
   }   
   so->so_error = 0;
 8231134:	e0bffa17 	ldw	r2,-24(fp)
 8231138:	10000615 	stw	zero,24(r2)

   UNLOCK_NET_RESOURCE (NET_RESID);
 823113c:	0009883a 	mov	r4,zero
 8231140:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   return 0;
 8231144:	0005883a 	mov	r2,zero
}
 8231148:	e037883a 	mov	sp,fp
 823114c:	dfc00117 	ldw	ra,4(sp)
 8231150:	df000017 	ldw	fp,0(sp)
 8231154:	dec00204 	addi	sp,sp,8
 8231158:	f800283a 	ret

0823115c <t_recv>:
int
t_recv (long s, 
   char *   buf,
   int   len, 
   int   flag)
{
 823115c:	defff604 	addi	sp,sp,-40
 8231160:	dfc00915 	stw	ra,36(sp)
 8231164:	df000815 	stw	fp,32(sp)
 8231168:	df000804 	addi	fp,sp,32
 823116c:	e13ffc15 	stw	r4,-16(fp)
 8231170:	e17ffd15 	stw	r5,-12(fp)
 8231174:	e1bffe15 	stw	r6,-8(fp)
 8231178:	e1ffff15 	stw	r7,-4(fp)
#ifdef SOCKDEBUG
   char logbuf[10];
#endif
   struct socket *   so;
   int   err;
   int   sendlen = len;
 823117c:	e0bffe17 	ldw	r2,-8(fp)
 8231180:	e0bff915 	stw	r2,-28(fp)

   so = LONG2SO(s);
 8231184:	e0bffc17 	ldw	r2,-16(fp)
 8231188:	10bff804 	addi	r2,r2,-32
 823118c:	1085883a 	add	r2,r2,r2
 8231190:	1085883a 	add	r2,r2,r2
 8231194:	e0bffa15 	stw	r2,-24(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 8231198:	e0bffa17 	ldw	r2,-24(fp)
 823119c:	1080088b 	ldhu	r2,34(r2)
 82311a0:	10bfffcc 	andi	r2,r2,65535
 82311a4:	1080038c 	andi	r2,r2,14
 82311a8:	108000a0 	cmpeqi	r2,r2,2
 82311ac:	1000051e 	bne	r2,zero,82311c4 <t_recv+0x68>
   {
      so->so_error = EPIPE;
 82311b0:	e0bffa17 	ldw	r2,-24(fp)
 82311b4:	00c00804 	movi	r3,32
 82311b8:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 82311bc:	00bfffc4 	movi	r2,-1
 82311c0:	00001906 	br	8231228 <t_recv+0xcc>
   }
   so->so_error = 0;
 82311c4:	e0bffa17 	ldw	r2,-24(fp)
 82311c8:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 82311cc:	0009883a 	mov	r4,zero
 82311d0:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   IN_PROFILER(PF_TCP, PF_ENTRY);        /* measure time in TCP */
   INET_TRACE (INETM_IO, ("INET:recv: so %x, len %d\n", so, len));
   err = soreceive(so, NULL, buf, &len, flag);
 82311d4:	e0fffe04 	addi	r3,fp,-8
 82311d8:	e0bfff17 	ldw	r2,-4(fp)
 82311dc:	d8800015 	stw	r2,0(sp)
 82311e0:	180f883a 	mov	r7,r3
 82311e4:	e1bffd17 	ldw	r6,-12(fp)
 82311e8:	000b883a 	mov	r5,zero
 82311ec:	e13ffa17 	ldw	r4,-24(fp)
 82311f0:	82328640 	call	8232864 <soreceive>
 82311f4:	e0bffb15 	stw	r2,-20(fp)
   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   UNLOCK_NET_RESOURCE(NET_RESID);
 82311f8:	0009883a 	mov	r4,zero
 82311fc:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>

   if(err)
 8231200:	e0bffb17 	ldw	r2,-20(fp)
 8231204:	10000526 	beq	r2,zero,823121c <t_recv+0xc0>
   {
      so->so_error = err;
 8231208:	e0bffa17 	ldw	r2,-24(fp)
 823120c:	e0fffb17 	ldw	r3,-20(fp)
 8231210:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 8231214:	00bfffc4 	movi	r2,-1
 8231218:	00000306 	br	8231228 <t_recv+0xcc>
   }

   /* return bytes we sent - the amount we wanted to send minus
    * the amount left in the buffer.
    */
   return (sendlen - len);
 823121c:	e0bffe17 	ldw	r2,-8(fp)
 8231220:	e0fff917 	ldw	r3,-28(fp)
 8231224:	1885c83a 	sub	r2,r3,r2
}
 8231228:	e037883a 	mov	sp,fp
 823122c:	dfc00117 	ldw	ra,4(sp)
 8231230:	df000017 	ldw	fp,0(sp)
 8231234:	dec00204 	addi	sp,sp,8
 8231238:	f800283a 	ret

0823123c <t_recvfrom>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * from,
   int * fromlen)
{
 823123c:	defff404 	addi	sp,sp,-48
 8231240:	dfc00b15 	stw	ra,44(sp)
 8231244:	df000a15 	stw	fp,40(sp)
 8231248:	df000a04 	addi	fp,sp,40
 823124c:	e13ffc15 	stw	r4,-16(fp)
 8231250:	e17ffd15 	stw	r5,-12(fp)
 8231254:	e1bffe15 	stw	r6,-8(fp)
 8231258:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   struct mbuf *     sender = NULL;
 823125c:	e03ffb15 	stw	zero,-20(fp)
   int   err;
   int   sendlen = len;
 8231260:	e0bffe17 	ldw	r2,-8(fp)
 8231264:	e0bff815 	stw	r2,-32(fp)

   so = LONG2SO(s);
 8231268:	e0bffc17 	ldw	r2,-16(fp)
 823126c:	10bff804 	addi	r2,r2,-32
 8231270:	1085883a 	add	r2,r2,r2
 8231274:	1085883a 	add	r2,r2,r2
 8231278:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 823127c:	008209b4 	movhi	r2,2086
 8231280:	10b95804 	addi	r2,r2,-6816
 8231284:	e0bff715 	stw	r2,-36(fp)
 8231288:	00000606 	br	82312a4 <t_recvfrom+0x68>
 823128c:	e0fff717 	ldw	r3,-36(fp)
 8231290:	e0bff917 	ldw	r2,-28(fp)
 8231294:	18800626 	beq	r3,r2,82312b0 <t_recvfrom+0x74>
 8231298:	e0bff717 	ldw	r2,-36(fp)
 823129c:	10800017 	ldw	r2,0(r2)
 82312a0:	e0bff715 	stw	r2,-36(fp)
 82312a4:	e0bff717 	ldw	r2,-36(fp)
 82312a8:	103ff81e 	bne	r2,zero,823128c <t_recvfrom+0x50>
 82312ac:	00000106 	br	82312b4 <t_recvfrom+0x78>
 82312b0:	0001883a 	nop
 82312b4:	e0fff717 	ldw	r3,-36(fp)
 82312b8:	e0bff917 	ldw	r2,-28(fp)
 82312bc:	18800326 	beq	r3,r2,82312cc <t_recvfrom+0x90>
 82312c0:	822d5940 	call	822d594 <dtrap>
 82312c4:	00bfffc4 	movi	r2,-1
 82312c8:	00002706 	br	8231368 <t_recvfrom+0x12c>
   so->so_error = 0;
 82312cc:	e0bff917 	ldw	r2,-28(fp)
 82312d0:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 82312d4:	0009883a 	mov	r4,zero
 82312d8:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>

   err = soreceive(so, &sender, buf, &len, flags);
 82312dc:	e13ffe04 	addi	r4,fp,-8
 82312e0:	e0fffb04 	addi	r3,fp,-20
 82312e4:	e0bfff17 	ldw	r2,-4(fp)
 82312e8:	d8800015 	stw	r2,0(sp)
 82312ec:	200f883a 	mov	r7,r4
 82312f0:	e1bffd17 	ldw	r6,-12(fp)
 82312f4:	180b883a 	mov	r5,r3
 82312f8:	e13ff917 	ldw	r4,-28(fp)
 82312fc:	82328640 	call	8232864 <soreceive>
 8231300:	e0bffa15 	stw	r2,-24(fp)

   /* copy sender info from mbuf to sockaddr */
   if (sender)
 8231304:	e0bffb17 	ldw	r2,-20(fp)
 8231308:	10000b26 	beq	r2,zero,8231338 <t_recvfrom+0xfc>
   {
      MEMCPY(from, (mtod(sender, struct sockaddr *)), *fromlen );
 823130c:	e0bffb17 	ldw	r2,-20(fp)
 8231310:	10c00317 	ldw	r3,12(r2)
 8231314:	e0800317 	ldw	r2,12(fp)
 8231318:	10800017 	ldw	r2,0(r2)
 823131c:	100d883a 	mov	r6,r2
 8231320:	180b883a 	mov	r5,r3
 8231324:	e1000217 	ldw	r4,8(fp)
 8231328:	8202f100 	call	8202f10 <memcpy>
      m_freem (sender);
 823132c:	e0bffb17 	ldw	r2,-20(fp)
 8231330:	1009883a 	mov	r4,r2
 8231334:	822e6380 	call	822e638 <m_freem>
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 8231338:	0009883a 	mov	r4,zero
 823133c:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>

   if(err)
 8231340:	e0bffa17 	ldw	r2,-24(fp)
 8231344:	10000526 	beq	r2,zero,823135c <t_recvfrom+0x120>
   {
      so->so_error = err;
 8231348:	e0bff917 	ldw	r2,-28(fp)
 823134c:	e0fffa17 	ldw	r3,-24(fp)
 8231350:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8231354:	00bfffc4 	movi	r2,-1
 8231358:	00000306 	br	8231368 <t_recvfrom+0x12c>
   }

   /* OK return: amount of data actually sent */
   return (sendlen - len);
 823135c:	e0bffe17 	ldw	r2,-8(fp)
 8231360:	e0fff817 	ldw	r3,-32(fp)
 8231364:	1885c83a 	sub	r2,r3,r2
}
 8231368:	e037883a 	mov	sp,fp
 823136c:	dfc00117 	ldw	ra,4(sp)
 8231370:	df000017 	ldw	fp,0(sp)
 8231374:	dec00204 	addi	sp,sp,8
 8231378:	f800283a 	ret

0823137c <t_sendto>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * to,
   int   tolen)
{
 823137c:	defff404 	addi	sp,sp,-48
 8231380:	dfc00b15 	stw	ra,44(sp)
 8231384:	df000a15 	stw	fp,40(sp)
 8231388:	df000a04 	addi	fp,sp,40
 823138c:	e13ffc15 	stw	r4,-16(fp)
 8231390:	e17ffd15 	stw	r5,-12(fp)
 8231394:	e1bffe15 	stw	r6,-8(fp)
 8231398:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   sendlen;
   int   err;
   struct mbuf *     name;

   so = LONG2SO(s);
 823139c:	e0bffc17 	ldw	r2,-16(fp)
 82313a0:	10bff804 	addi	r2,r2,-32
 82313a4:	1085883a 	add	r2,r2,r2
 82313a8:	1085883a 	add	r2,r2,r2
 82313ac:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 82313b0:	008209b4 	movhi	r2,2086
 82313b4:	10b95804 	addi	r2,r2,-6816
 82313b8:	e0bff815 	stw	r2,-32(fp)
 82313bc:	00000606 	br	82313d8 <t_sendto+0x5c>
 82313c0:	e0fff817 	ldw	r3,-32(fp)
 82313c4:	e0bff917 	ldw	r2,-28(fp)
 82313c8:	18800626 	beq	r3,r2,82313e4 <t_sendto+0x68>
 82313cc:	e0bff817 	ldw	r2,-32(fp)
 82313d0:	10800017 	ldw	r2,0(r2)
 82313d4:	e0bff815 	stw	r2,-32(fp)
 82313d8:	e0bff817 	ldw	r2,-32(fp)
 82313dc:	103ff81e 	bne	r2,zero,82313c0 <t_sendto+0x44>
 82313e0:	00000106 	br	82313e8 <t_sendto+0x6c>
 82313e4:	0001883a 	nop
 82313e8:	e0fff817 	ldw	r3,-32(fp)
 82313ec:	e0bff917 	ldw	r2,-28(fp)
 82313f0:	18800326 	beq	r3,r2,8231400 <t_sendto+0x84>
 82313f4:	822d5940 	call	822d594 <dtrap>
 82313f8:	00bfffc4 	movi	r2,-1
 82313fc:	00005706 	br	823155c <t_sendto+0x1e0>
   so->so_error = 0;
 8231400:	e0bff917 	ldw	r2,-28(fp)
 8231404:	10000615 	stw	zero,24(r2)

   switch (so->so_type)
 8231408:	e0bff917 	ldw	r2,-28(fp)
 823140c:	10800983 	ldbu	r2,38(r2)
 8231410:	10803fcc 	andi	r2,r2,255
 8231414:	1080201c 	xori	r2,r2,128
 8231418:	10bfe004 	addi	r2,r2,-128
 823141c:	10c000a0 	cmpeqi	r3,r2,2
 8231420:	18000a1e 	bne	r3,zero,823144c <t_sendto+0xd0>
 8231424:	10c000e0 	cmpeqi	r3,r2,3
 8231428:	18000b1e 	bne	r3,zero,8231458 <t_sendto+0xdc>
 823142c:	10800060 	cmpeqi	r2,r2,1
 8231430:	10001026 	beq	r2,zero,8231474 <t_sendto+0xf8>
   {
   case SOCK_STREAM:
      /* this is a stream socket, so pass this request through
       * t_send() for its large-send support.
       */
      return t_send(s, buf, len, flags);
 8231434:	e1ffff17 	ldw	r7,-4(fp)
 8231438:	e1bffe17 	ldw	r6,-8(fp)
 823143c:	e17ffd17 	ldw	r5,-12(fp)
 8231440:	e13ffc17 	ldw	r4,-16(fp)
 8231444:	82315700 	call	8231570 <t_send>
 8231448:	00004406 	br	823155c <t_sendto+0x1e0>
      /*NOTREACHED*/
   case SOCK_DGRAM:
      /* datagram (UDP) socket -- prepare to check length */
      sendlen = udp_maxalloc();
 823144c:	82454a40 	call	82454a4 <udp_maxalloc>
 8231450:	e0bffb15 	stw	r2,-20(fp)
      break;
 8231454:	00000d06 	br	823148c <t_sendto+0x110>
#ifdef IP_RAW
   case SOCK_RAW:
      /* raw socket -- prepare to check length */
      sendlen = ip_raw_maxalloc(so->so_options & SO_HDRINCL);
 8231458:	e0bff917 	ldw	r2,-28(fp)
 823145c:	10800417 	ldw	r2,16(r2)
 8231460:	1088000c 	andi	r2,r2,8192
 8231464:	1009883a 	mov	r4,r2
 8231468:	82441940 	call	8244194 <ip_raw_maxalloc>
 823146c:	e0bffb15 	stw	r2,-20(fp)
      break;
 8231470:	00000606 	br	823148c <t_sendto+0x110>
#endif /* IP_RAW */
   default:
      /* socket has unknown type */
      dtrap();
 8231474:	822d5940 	call	822d594 <dtrap>
      so->so_error = EFAULT;
 8231478:	e0bff917 	ldw	r2,-28(fp)
 823147c:	00c00384 	movi	r3,14
 8231480:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8231484:	00bfffc4 	movi	r2,-1
 8231488:	00003406 	br	823155c <t_sendto+0x1e0>
   /* fall through for non-stream sockets: SOCK_DGRAM (UDP) and
    * SOCK_RAW (raw IP)
    */

   /* check length against underlying stack's maximum */
   if (len > sendlen)
 823148c:	e0fffb17 	ldw	r3,-20(fp)
 8231490:	e0bffe17 	ldw	r2,-8(fp)
 8231494:	1880050e 	bge	r3,r2,82314ac <t_sendto+0x130>
   {
      so->so_error = EMSGSIZE;
 8231498:	e0bff917 	ldw	r2,-28(fp)
 823149c:	00c01e84 	movi	r3,122
 82314a0:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 82314a4:	00bfffc4 	movi	r2,-1
 82314a8:	00002c06 	br	823155c <t_sendto+0x1e0>
   /* if a sockaddr was passed, wrap it in an mbuf and pas it into the
    * bowels of the BSD code; else assume this is a bound UDP socket
    * and this call came from t_send() below.
    */

   if (to)  /* sockaddr was passed */
 82314ac:	e0800217 	ldw	r2,8(fp)
 82314b0:	10000c26 	beq	r2,zero,82314e4 <t_sendto+0x168>
   {
      name = sockargs(to, tolen, MT_SONAME);
 82314b4:	01800244 	movi	r6,9
 82314b8:	e1400317 	ldw	r5,12(fp)
 82314bc:	e1000217 	ldw	r4,8(fp)
 82314c0:	82319100 	call	8231910 <sockargs>
 82314c4:	e0bff715 	stw	r2,-36(fp)
      if(name == NULL)
 82314c8:	e0bff717 	ldw	r2,-36(fp)
 82314cc:	1000061e 	bne	r2,zero,82314e8 <t_sendto+0x16c>
      {
         so->so_error = ENOMEM;
 82314d0:	e0bff917 	ldw	r2,-28(fp)
 82314d4:	00c00304 	movi	r3,12
 82314d8:	10c00615 	stw	r3,24(r2)
         return SOCKET_ERROR;
 82314dc:	00bfffc4 	movi	r2,-1
 82314e0:	00001e06 	br	823155c <t_sendto+0x1e0>
      }
   }
   else     /* hope user called bind() first... */
      name = NULL;
 82314e4:	e03ff715 	stw	zero,-36(fp)
   
   sendlen = len;
 82314e8:	e0bffe17 	ldw	r2,-8(fp)
 82314ec:	e0bffb15 	stw	r2,-20(fp)

   LOCK_NET_RESOURCE(NET_RESID);
 82314f0:	0009883a 	mov	r4,zero
 82314f4:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>

   err = sosend (so, name, buf, &sendlen, flags);
 82314f8:	e0fffb04 	addi	r3,fp,-20
 82314fc:	e0bfff17 	ldw	r2,-4(fp)
 8231500:	d8800015 	stw	r2,0(sp)
 8231504:	180f883a 	mov	r7,r3
 8231508:	e1bffd17 	ldw	r6,-12(fp)
 823150c:	e17ff717 	ldw	r5,-36(fp)
 8231510:	e13ff917 	ldw	r4,-28(fp)
 8231514:	823230c0 	call	823230c <sosend>
 8231518:	e0bffa15 	stw	r2,-24(fp)

   if (name)
 823151c:	e0bff717 	ldw	r2,-36(fp)
 8231520:	10000226 	beq	r2,zero,823152c <t_sendto+0x1b0>
      m_freem(name);
 8231524:	e13ff717 	ldw	r4,-36(fp)
 8231528:	822e6380 	call	822e638 <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 823152c:	0009883a 	mov	r4,zero
 8231530:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>

   if (err != 0)
 8231534:	e0bffa17 	ldw	r2,-24(fp)
 8231538:	10000526 	beq	r2,zero,8231550 <t_sendto+0x1d4>
   {
      so->so_error = err;
 823153c:	e0bff917 	ldw	r2,-28(fp)
 8231540:	e0fffa17 	ldw	r3,-24(fp)
 8231544:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8231548:	00bfffc4 	movi	r2,-1
 823154c:	00000306 	br	823155c <t_sendto+0x1e0>
   }

   return (len - sendlen);
 8231550:	e0bffb17 	ldw	r2,-20(fp)
 8231554:	e0fffe17 	ldw	r3,-8(fp)
 8231558:	1885c83a 	sub	r2,r3,r2
}
 823155c:	e037883a 	mov	sp,fp
 8231560:	dfc00117 	ldw	ra,4(sp)
 8231564:	df000017 	ldw	fp,0(sp)
 8231568:	dec00204 	addi	sp,sp,8
 823156c:	f800283a 	ret

08231570 <t_send>:
int
t_send(long s, 
   char *   buf,
   int      len, 
   int      flags)
{
 8231570:	defff104 	addi	sp,sp,-60
 8231574:	dfc00e15 	stw	ra,56(sp)
 8231578:	df000d15 	stw	fp,52(sp)
 823157c:	df000d04 	addi	fp,sp,52
 8231580:	e13ffc15 	stw	r4,-16(fp)
 8231584:	e17ffd15 	stw	r5,-12(fp)
 8231588:	e1bffe15 	stw	r6,-8(fp)
 823158c:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   e;       /* error holder */
   int   total_sent  =  0;
 8231590:	e03ff515 	stw	zero,-44(fp)
   int   maxpkt;
   int   sendlen;
   int   sent;

   so = LONG2SO(s);
 8231594:	e0bffc17 	ldw	r2,-16(fp)
 8231598:	10bff804 	addi	r2,r2,-32
 823159c:	1085883a 	add	r2,r2,r2
 82315a0:	1085883a 	add	r2,r2,r2
 82315a4:	e0bff715 	stw	r2,-36(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 82315a8:	e0bff717 	ldw	r2,-36(fp)
 82315ac:	1080088b 	ldhu	r2,34(r2)
 82315b0:	10bfffcc 	andi	r2,r2,65535
 82315b4:	1080038c 	andi	r2,r2,14
 82315b8:	108000a0 	cmpeqi	r2,r2,2
 82315bc:	1000051e 	bne	r2,zero,82315d4 <t_send+0x64>
   {
      so->so_error = EPIPE;
 82315c0:	e0bff717 	ldw	r2,-36(fp)
 82315c4:	00c00804 	movi	r3,32
 82315c8:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 82315cc:	00bfffc4 	movi	r2,-1
 82315d0:	00006306 	br	8231760 <t_send+0x1f0>
   }
   so->so_error = 0;
 82315d4:	e0bff717 	ldw	r2,-36(fp)
 82315d8:	10000615 	stw	zero,24(r2)

   /* If this is not a stream socket, assume it is bound and pass to
    * t_sendto() with a null sockaddr
    */
   if (so->so_type != SOCK_STREAM)
 82315dc:	e0bff717 	ldw	r2,-36(fp)
 82315e0:	10800983 	ldbu	r2,38(r2)
 82315e4:	10803fcc 	andi	r2,r2,255
 82315e8:	1080201c 	xori	r2,r2,128
 82315ec:	10bfe004 	addi	r2,r2,-128
 82315f0:	10800060 	cmpeqi	r2,r2,1
 82315f4:	1000081e 	bne	r2,zero,8231618 <t_send+0xa8>
      return(t_sendto(s, buf, len, flags, NULL, 0));
 82315f8:	d8000115 	stw	zero,4(sp)
 82315fc:	d8000015 	stw	zero,0(sp)
 8231600:	e1ffff17 	ldw	r7,-4(fp)
 8231604:	e1bffe17 	ldw	r6,-8(fp)
 8231608:	e17ffd17 	ldw	r5,-12(fp)
 823160c:	e13ffc17 	ldw	r4,-16(fp)
 8231610:	823137c0 	call	823137c <t_sendto>
 8231614:	00005206 	br	8231760 <t_send+0x1f0>

   maxpkt = TCP_MSS;
 8231618:	00816d04 	movi	r2,1460
 823161c:	e0bff615 	stw	r2,-40(fp)
   if(so->so_pcb)
 8231620:	e0bff717 	ldw	r2,-36(fp)
 8231624:	10800117 	ldw	r2,4(r2)
 8231628:	10004826 	beq	r2,zero,823174c <t_send+0x1dc>
   { 
      struct tcpcb * tp;
      tp = intotcpcb(so->so_pcb);   /* get tcp structure with mss */
 823162c:	e0bff717 	ldw	r2,-36(fp)
 8231630:	10800117 	ldw	r2,4(r2)
 8231634:	10800917 	ldw	r2,36(r2)
 8231638:	e0bff815 	stw	r2,-32(fp)
      if(tp->t_maxseg)              /* Make sure it's set */
 823163c:	e0bff817 	ldw	r2,-32(fp)
 8231640:	10800a0b 	ldhu	r2,40(r2)
 8231644:	10bfffcc 	andi	r2,r2,65535
 8231648:	10004026 	beq	r2,zero,823174c <t_send+0x1dc>
         maxpkt = tp->t_maxseg;
 823164c:	e0bff817 	ldw	r2,-32(fp)
 8231650:	10800a0b 	ldhu	r2,40(r2)
 8231654:	10bfffcc 	andi	r2,r2,65535
 8231658:	e0bff615 	stw	r2,-40(fp)
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 823165c:	00003b06 	br	823174c <t_send+0x1dc>
   {
      if (len > maxpkt)
 8231660:	e0bffe17 	ldw	r2,-8(fp)
 8231664:	e0fff617 	ldw	r3,-40(fp)
 8231668:	1880030e 	bge	r3,r2,8231678 <t_send+0x108>
         sendlen = maxpkt;  /* take biggest block we can */
 823166c:	e0bff617 	ldw	r2,-40(fp)
 8231670:	e0bffb15 	stw	r2,-20(fp)
 8231674:	00000206 	br	8231680 <t_send+0x110>
      else
         sendlen = len;
 8231678:	e0bffe17 	ldw	r2,-8(fp)
 823167c:	e0bffb15 	stw	r2,-20(fp)
      sent = sendlen;
 8231680:	e0bffb17 	ldw	r2,-20(fp)
 8231684:	e0bff915 	stw	r2,-28(fp)

      LOCK_NET_RESOURCE(NET_RESID);
 8231688:	0009883a 	mov	r4,zero
 823168c:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      e = sosend (so, NULL, buf, &sendlen, flags);
 8231690:	e0fffb04 	addi	r3,fp,-20
 8231694:	e0bfff17 	ldw	r2,-4(fp)
 8231698:	d8800015 	stw	r2,0(sp)
 823169c:	180f883a 	mov	r7,r3
 82316a0:	e1bffd17 	ldw	r6,-12(fp)
 82316a4:	000b883a 	mov	r5,zero
 82316a8:	e13ff717 	ldw	r4,-36(fp)
 82316ac:	823230c0 	call	823230c <sosend>
 82316b0:	e0bffa15 	stw	r2,-24(fp)
      UNLOCK_NET_RESOURCE(NET_RESID);
 82316b4:	0009883a 	mov	r4,zero
 82316b8:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
 
      if (e != 0)  /* sock_sendit failed? */
 82316bc:	e0bffa17 	ldw	r2,-24(fp)
 82316c0:	10001026 	beq	r2,zero,8231704 <t_send+0x194>
      {
         /* if we simply ran out of bufs, report back to caller. */
         if ((e == ENOBUFS) || (e == EWOULDBLOCK))
 82316c4:	e0bffa17 	ldw	r2,-24(fp)
 82316c8:	10801a60 	cmpeqi	r2,r2,105
 82316cc:	1000031e 	bne	r2,zero,82316dc <t_send+0x16c>
 82316d0:	e0bffa17 	ldw	r2,-24(fp)
 82316d4:	108002d8 	cmpnei	r2,r2,11
 82316d8:	1000051e 	bne	r2,zero,82316f0 <t_send+0x180>
            /* if we actually sent something before running out
             * of buffers, report what we sent; 
             * else, report the error and let the application 
             * retry the call later
             */
            if (total_sent != 0)
 82316dc:	e0bff517 	ldw	r2,-44(fp)
 82316e0:	10000326 	beq	r2,zero,82316f0 <t_send+0x180>
            {
               so->so_error = 0;
 82316e4:	e0bff717 	ldw	r2,-36(fp)
 82316e8:	10000615 	stw	zero,24(r2)
               break;      /* break out of while(len) loop */
 82316ec:	00001b06 	br	823175c <t_send+0x1ec>
            }
         }
         so->so_error = e;
 82316f0:	e0bff717 	ldw	r2,-36(fp)
 82316f4:	e0fffa17 	ldw	r3,-24(fp)
 82316f8:	10c00615 	stw	r3,24(r2)
         return SOCKET_ERROR;
 82316fc:	00bfffc4 	movi	r2,-1
 8231700:	00001706 	br	8231760 <t_send+0x1f0>
      }
      /* if we can't send anymore, return now */
      if (sendlen != 0)
 8231704:	e0bffb17 	ldw	r2,-20(fp)
 8231708:	1000131e 	bne	r2,zero,8231758 <t_send+0x1e8>
         break;         /* break out of while(len) loop */

      /* adjust numbers & pointers, and go do next send loop */
      sent -= sendlen;        /* subtract anything that didn't get sent */
 823170c:	e0bffb17 	ldw	r2,-20(fp)
 8231710:	e0fff917 	ldw	r3,-28(fp)
 8231714:	1885c83a 	sub	r2,r3,r2
 8231718:	e0bff915 	stw	r2,-28(fp)
      buf += sent;
 823171c:	e0bff917 	ldw	r2,-28(fp)
 8231720:	e0fffd17 	ldw	r3,-12(fp)
 8231724:	1885883a 	add	r2,r3,r2
 8231728:	e0bffd15 	stw	r2,-12(fp)
      len -= sent;
 823172c:	e0fffe17 	ldw	r3,-8(fp)
 8231730:	e0bff917 	ldw	r2,-28(fp)
 8231734:	1885c83a 	sub	r2,r3,r2
 8231738:	e0bffe15 	stw	r2,-8(fp)
      total_sent += sent;
 823173c:	e0fff517 	ldw	r3,-44(fp)
 8231740:	e0bff917 	ldw	r2,-28(fp)
 8231744:	1885883a 	add	r2,r3,r2
 8231748:	e0bff515 	stw	r2,-44(fp)
         maxpkt = tp->t_maxseg;
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 823174c:	e0bffe17 	ldw	r2,-8(fp)
 8231750:	103fc31e 	bne	r2,zero,8231660 <t_send+0xf0>
 8231754:	00000106 	br	823175c <t_send+0x1ec>
         so->so_error = e;
         return SOCKET_ERROR;
      }
      /* if we can't send anymore, return now */
      if (sendlen != 0)
         break;         /* break out of while(len) loop */
 8231758:	0001883a 	nop
      len -= sent;
      total_sent += sent;
   }

   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   return total_sent;
 823175c:	e0bff517 	ldw	r2,-44(fp)
}
 8231760:	e037883a 	mov	sp,fp
 8231764:	dfc00117 	ldw	ra,4(sp)
 8231768:	df000017 	ldw	fp,0(sp)
 823176c:	dec00204 	addi	sp,sp,8
 8231770:	f800283a 	ret

08231774 <t_shutdown>:
 * RETURNS: 
 */

int
t_shutdown(long s, int   how)
{
 8231774:	defff904 	addi	sp,sp,-28
 8231778:	dfc00615 	stw	ra,24(sp)
 823177c:	df000515 	stw	fp,20(sp)
 8231780:	df000504 	addi	fp,sp,20
 8231784:	e13ffe15 	stw	r4,-8(fp)
 8231788:	e17fff15 	stw	r5,-4(fp)
   struct socket *so;
   int   err;

   so = LONG2SO(s);
 823178c:	e0bffe17 	ldw	r2,-8(fp)
 8231790:	10bff804 	addi	r2,r2,-32
 8231794:	1085883a 	add	r2,r2,r2
 8231798:	1085883a 	add	r2,r2,r2
 823179c:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 82317a0:	008209b4 	movhi	r2,2086
 82317a4:	10b95804 	addi	r2,r2,-6816
 82317a8:	e0bffb15 	stw	r2,-20(fp)
 82317ac:	00000606 	br	82317c8 <t_shutdown+0x54>
 82317b0:	e0fffb17 	ldw	r3,-20(fp)
 82317b4:	e0bffc17 	ldw	r2,-16(fp)
 82317b8:	18800626 	beq	r3,r2,82317d4 <t_shutdown+0x60>
 82317bc:	e0bffb17 	ldw	r2,-20(fp)
 82317c0:	10800017 	ldw	r2,0(r2)
 82317c4:	e0bffb15 	stw	r2,-20(fp)
 82317c8:	e0bffb17 	ldw	r2,-20(fp)
 82317cc:	103ff81e 	bne	r2,zero,82317b0 <t_shutdown+0x3c>
 82317d0:	00000106 	br	82317d8 <t_shutdown+0x64>
 82317d4:	0001883a 	nop
 82317d8:	e0fffb17 	ldw	r3,-20(fp)
 82317dc:	e0bffc17 	ldw	r2,-16(fp)
 82317e0:	18800326 	beq	r3,r2,82317f0 <t_shutdown+0x7c>
 82317e4:	822d5940 	call	822d594 <dtrap>
 82317e8:	00bfffc4 	movi	r2,-1
 82317ec:	00001206 	br	8231838 <t_shutdown+0xc4>
   so->so_error = 0;
 82317f0:	e0bffc17 	ldw	r2,-16(fp)
 82317f4:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:shutdown so %x how %d\n", so, how));

   LOCK_NET_RESOURCE(NET_RESID);
 82317f8:	0009883a 	mov	r4,zero
 82317fc:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   err = soshutdown(so, how);
 8231800:	e17fff17 	ldw	r5,-4(fp)
 8231804:	e13ffc17 	ldw	r4,-16(fp)
 8231808:	8232fb00 	call	8232fb0 <soshutdown>
 823180c:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 8231810:	0009883a 	mov	r4,zero
 8231814:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>

   if (err != 0)
 8231818:	e0bffd17 	ldw	r2,-12(fp)
 823181c:	10000526 	beq	r2,zero,8231834 <t_shutdown+0xc0>
   {
      so->so_error = err;
 8231820:	e0bffc17 	ldw	r2,-16(fp)
 8231824:	e0fffd17 	ldw	r3,-12(fp)
 8231828:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 823182c:	00bfffc4 	movi	r2,-1
 8231830:	00000106 	br	8231838 <t_shutdown+0xc4>
   }
   return 0;
 8231834:	0005883a 	mov	r2,zero
}
 8231838:	e037883a 	mov	sp,fp
 823183c:	dfc00117 	ldw	ra,4(sp)
 8231840:	df000017 	ldw	fp,0(sp)
 8231844:	dec00204 	addi	sp,sp,8
 8231848:	f800283a 	ret

0823184c <t_socketclose>:
 * RETURNS: 
 */

int
t_socketclose(long s)
{
 823184c:	defffa04 	addi	sp,sp,-24
 8231850:	dfc00515 	stw	ra,20(sp)
 8231854:	df000415 	stw	fp,16(sp)
 8231858:	df000404 	addi	fp,sp,16
 823185c:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 8231860:	e0bfff17 	ldw	r2,-4(fp)
 8231864:	10bff804 	addi	r2,r2,-32
 8231868:	1085883a 	add	r2,r2,r2
 823186c:	1085883a 	add	r2,r2,r2
 8231870:	e0bffd15 	stw	r2,-12(fp)
   SOC_CHECK(so);
 8231874:	008209b4 	movhi	r2,2086
 8231878:	10b95804 	addi	r2,r2,-6816
 823187c:	e0bffc15 	stw	r2,-16(fp)
 8231880:	00000606 	br	823189c <t_socketclose+0x50>
 8231884:	e0fffc17 	ldw	r3,-16(fp)
 8231888:	e0bffd17 	ldw	r2,-12(fp)
 823188c:	18800626 	beq	r3,r2,82318a8 <t_socketclose+0x5c>
 8231890:	e0bffc17 	ldw	r2,-16(fp)
 8231894:	10800017 	ldw	r2,0(r2)
 8231898:	e0bffc15 	stw	r2,-16(fp)
 823189c:	e0bffc17 	ldw	r2,-16(fp)
 82318a0:	103ff81e 	bne	r2,zero,8231884 <t_socketclose+0x38>
 82318a4:	00000106 	br	82318ac <t_socketclose+0x60>
 82318a8:	0001883a 	nop
 82318ac:	e0fffc17 	ldw	r3,-16(fp)
 82318b0:	e0bffd17 	ldw	r2,-12(fp)
 82318b4:	18800326 	beq	r3,r2,82318c4 <t_socketclose+0x78>
 82318b8:	822d5940 	call	822d594 <dtrap>
 82318bc:	00bfffc4 	movi	r2,-1
 82318c0:	00000e06 	br	82318fc <t_socketclose+0xb0>
   so->so_error = 0;
 82318c4:	e0bffd17 	ldw	r2,-12(fp)
 82318c8:	10000615 	stw	zero,24(r2)
   INET_TRACE ((INETM_CLOSE|INETM_SOCKET), ("INET:close, so %lx\n",so));

   LOCK_NET_RESOURCE(NET_RESID);
 82318cc:	0009883a 	mov	r4,zero
 82318d0:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   err = soclose(so);
 82318d4:	e13ffd17 	ldw	r4,-12(fp)
 82318d8:	8231e180 	call	8231e18 <soclose>
 82318dc:	e0bffe15 	stw	r2,-8(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 82318e0:	0009883a 	mov	r4,zero
 82318e4:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 82318e8:	e0bffe17 	ldw	r2,-8(fp)
 82318ec:	10000226 	beq	r2,zero,82318f8 <t_socketclose+0xac>
   {
      /* do not do the following assignment since the socket structure
         addressed by so has been freed by this point, jharan 12-10-98 */
      /*      so->so_error = err;   */
      return SOCKET_ERROR;
 82318f0:	00bfffc4 	movi	r2,-1
 82318f4:	00000106 	br	82318fc <t_socketclose+0xb0>
   }
   return 0;
 82318f8:	0005883a 	mov	r2,zero
}
 82318fc:	e037883a 	mov	sp,fp
 8231900:	dfc00117 	ldw	ra,4(sp)
 8231904:	df000017 	ldw	fp,0(sp)
 8231908:	dec00204 	addi	sp,sp,8
 823190c:	f800283a 	ret

08231910 <sockargs>:

static struct mbuf  * 
sockargs (void * arg, 
   int   arglen, 
   int   type)
{
 8231910:	defffa04 	addi	sp,sp,-24
 8231914:	dfc00515 	stw	ra,20(sp)
 8231918:	df000415 	stw	fp,16(sp)
 823191c:	df000404 	addi	fp,sp,16
 8231920:	e13ffd15 	stw	r4,-12(fp)
 8231924:	e17ffe15 	stw	r5,-8(fp)
 8231928:	e1bfff15 	stw	r6,-4(fp)
   struct mbuf *  m;

   LOCK_NET_RESOURCE(NET_RESID);    /* protect mfreeq */
 823192c:	0009883a 	mov	r4,zero
 8231930:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   m = m_getwithdata (type, arglen);
 8231934:	e17ffe17 	ldw	r5,-8(fp)
 8231938:	e13fff17 	ldw	r4,-4(fp)
 823193c:	822e3a80 	call	822e3a8 <m_getnbuf>
 8231940:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 8231944:	0009883a 	mov	r4,zero
 8231948:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   if (m == NULL)
 823194c:	e0bffc17 	ldw	r2,-16(fp)
 8231950:	1000021e 	bne	r2,zero,823195c <sockargs+0x4c>
      return NULL;
 8231954:	0005883a 	mov	r2,zero
 8231958:	00000b06 	br	8231988 <sockargs+0x78>
   m->m_len = arglen;
 823195c:	e0fffe17 	ldw	r3,-8(fp)
 8231960:	e0bffc17 	ldw	r2,-16(fp)
 8231964:	10c00215 	stw	r3,8(r2)
   MEMCPY(mtod (m, char *), arg, arglen);
 8231968:	e0bffc17 	ldw	r2,-16(fp)
 823196c:	10800317 	ldw	r2,12(r2)
 8231970:	e0fffe17 	ldw	r3,-8(fp)
 8231974:	180d883a 	mov	r6,r3
 8231978:	e17ffd17 	ldw	r5,-12(fp)
 823197c:	1009883a 	mov	r4,r2
 8231980:	8202f100 	call	8202f10 <memcpy>
   return m;
 8231984:	e0bffc17 	ldw	r2,-16(fp)
}
 8231988:	e037883a 	mov	sp,fp
 823198c:	dfc00117 	ldw	ra,4(sp)
 8231990:	df000017 	ldw	fp,0(sp)
 8231994:	dec00204 	addi	sp,sp,8
 8231998:	f800283a 	ret

0823199c <t_errno>:
 *                            ENOTSOCK if socket not found
 */

int
t_errno(long s)
{
 823199c:	defffa04 	addi	sp,sp,-24
 82319a0:	dfc00515 	stw	ra,20(sp)
 82319a4:	df000415 	stw	fp,16(sp)
 82319a8:	df000404 	addi	fp,sp,16
 82319ac:	e13fff15 	stw	r4,-4(fp)
   struct socket *so = LONG2SO(s);
 82319b0:	e0bfff17 	ldw	r2,-4(fp)
 82319b4:	10bff804 	addi	r2,r2,-32
 82319b8:	1085883a 	add	r2,r2,r2
 82319bc:	1085883a 	add	r2,r2,r2
 82319c0:	e0bffe15 	stw	r2,-8(fp)
   struct socket *tmp;
   int errcode = ENOTSOCK;
 82319c4:	00801b04 	movi	r2,108
 82319c8:	e0bffd15 	stw	r2,-12(fp)

   LOCK_NET_RESOURCE(NET_RESID);    /* protect soq */
 82319cc:	0009883a 	mov	r4,zero
 82319d0:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 82319d4:	008209b4 	movhi	r2,2086
 82319d8:	10b95804 	addi	r2,r2,-6816
 82319dc:	e0bffc15 	stw	r2,-16(fp)
 82319e0:	00000a06 	br	8231a0c <t_errno+0x70>
   {
      if (tmp == so)  /* found socket, return error */
 82319e4:	e0fffc17 	ldw	r3,-16(fp)
 82319e8:	e0bffe17 	ldw	r2,-8(fp)
 82319ec:	1880041e 	bne	r3,r2,8231a00 <t_errno+0x64>
      {
         errcode = so->so_error;
 82319f0:	e0bffe17 	ldw	r2,-8(fp)
 82319f4:	10800617 	ldw	r2,24(r2)
 82319f8:	e0bffd15 	stw	r2,-12(fp)
         break;
 82319fc:	00000506 	br	8231a14 <t_errno+0x78>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 8231a00:	e0bffc17 	ldw	r2,-16(fp)
 8231a04:	10800017 	ldw	r2,0(r2)
 8231a08:	e0bffc15 	stw	r2,-16(fp)
 8231a0c:	e0bffc17 	ldw	r2,-16(fp)
 8231a10:	103ff41e 	bne	r2,zero,82319e4 <t_errno+0x48>
         errcode = so->so_error;
         break;
      }
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 8231a14:	0009883a 	mov	r4,zero
 8231a18:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>

   return errcode;
 8231a1c:	e0bffd17 	ldw	r2,-12(fp)
}
 8231a20:	e037883a 	mov	sp,fp
 8231a24:	dfc00117 	ldw	ra,4(sp)
 8231a28:	df000017 	ldw	fp,0(sp)
 8231a2c:	dec00204 	addi	sp,sp,8
 8231a30:	f800283a 	ret

08231a34 <socreate>:
 * RETURNS: 
 */

struct socket *   
socreate (int dom, int type, int proto)
{
 8231a34:	defff704 	addi	sp,sp,-36
 8231a38:	dfc00815 	stw	ra,32(sp)
 8231a3c:	df000715 	stw	fp,28(sp)
 8231a40:	df000704 	addi	fp,sp,28
 8231a44:	e13ffd15 	stw	r4,-12(fp)
 8231a48:	e17ffe15 	stw	r5,-8(fp)
 8231a4c:	e1bfff15 	stw	r6,-4(fp)
   struct protosw *prp;
   struct socket *so;
   int   error;
   int rc;

   if (proto)
 8231a50:	e0bfff17 	ldw	r2,-4(fp)
 8231a54:	10000626 	beq	r2,zero,8231a70 <socreate+0x3c>
      prp = pffindproto(dom, proto, type);
 8231a58:	e1bffe17 	ldw	r6,-8(fp)
 8231a5c:	e17fff17 	ldw	r5,-4(fp)
 8231a60:	e13ffd17 	ldw	r4,-12(fp)
 8231a64:	822e2e40 	call	822e2e4 <pffindproto>
 8231a68:	e0bff915 	stw	r2,-28(fp)
 8231a6c:	00000406 	br	8231a80 <socreate+0x4c>
   else
      prp = pffindtype(dom, type);
 8231a70:	e17ffe17 	ldw	r5,-8(fp)
 8231a74:	e13ffd17 	ldw	r4,-12(fp)
 8231a78:	822e2540 	call	822e254 <pffindtype>
 8231a7c:	e0bff915 	stw	r2,-28(fp)
   if (prp == 0)
 8231a80:	e0bff917 	ldw	r2,-28(fp)
 8231a84:	1000021e 	bne	r2,zero,8231a90 <socreate+0x5c>
      return NULL;
 8231a88:	0005883a 	mov	r2,zero
 8231a8c:	00004e06 	br	8231bc8 <socreate+0x194>
   if (prp->pr_type != type)
 8231a90:	e0bff917 	ldw	r2,-28(fp)
 8231a94:	1080000b 	ldhu	r2,0(r2)
 8231a98:	10ffffcc 	andi	r3,r2,65535
 8231a9c:	18e0001c 	xori	r3,r3,32768
 8231aa0:	18e00004 	addi	r3,r3,-32768
 8231aa4:	e0bffe17 	ldw	r2,-8(fp)
 8231aa8:	18800226 	beq	r3,r2,8231ab4 <socreate+0x80>
      return NULL;
 8231aac:	0005883a 	mov	r2,zero
 8231ab0:	00004506 	br	8231bc8 <socreate+0x194>
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 8231ab4:	01002104 	movi	r4,132
 8231ab8:	822e16c0 	call	822e16c <npalloc>
 8231abc:	e0bffa15 	stw	r2,-24(fp)
 8231ac0:	e0bffa17 	ldw	r2,-24(fp)
 8231ac4:	1000021e 	bne	r2,zero,8231ad0 <socreate+0x9c>
      return NULL;
 8231ac8:	0005883a 	mov	r2,zero
 8231acc:	00003e06 	br	8231bc8 <socreate+0x194>
   so->next = NULL;
 8231ad0:	e0bffa17 	ldw	r2,-24(fp)
 8231ad4:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);
 8231ad8:	e17ffa17 	ldw	r5,-24(fp)
 8231adc:	010209b4 	movhi	r4,2086
 8231ae0:	21395804 	addi	r4,r4,-6816
 8231ae4:	822cf7c0 	call	822cf7c <putq>

   so->so_options = socket_defaults;
 8231ae8:	d0a03c0b 	ldhu	r2,-32528(gp)
 8231aec:	10ffffcc 	andi	r3,r2,65535
 8231af0:	e0bffa17 	ldw	r2,-24(fp)
 8231af4:	10c00415 	stw	r3,16(r2)
   so->so_domain = dom;
 8231af8:	e0bffa17 	ldw	r2,-24(fp)
 8231afc:	e0fffd17 	ldw	r3,-12(fp)
 8231b00:	10c00515 	stw	r3,20(r2)
   so->so_state = 0;
 8231b04:	e0bffa17 	ldw	r2,-24(fp)
 8231b08:	1000088d 	sth	zero,34(r2)
   so->so_type = (char)type;
 8231b0c:	e0bffe17 	ldw	r2,-8(fp)
 8231b10:	1007883a 	mov	r3,r2
 8231b14:	e0bffa17 	ldw	r2,-24(fp)
 8231b18:	10c00985 	stb	r3,38(r2)
   so->so_proto = prp;
 8231b1c:	e0bffa17 	ldw	r2,-24(fp)
 8231b20:	e0fff917 	ldw	r3,-28(fp)
 8231b24:	10c00215 	stw	r3,8(r2)

#ifdef IP_MULTICAST
   so->inp_moptions = NULL;
 8231b28:	e0bffa17 	ldw	r2,-24(fp)
 8231b2c:	10000315 	stw	zero,12(r2)
#endif   /* IP_MULTICAST */

   so->so_req = PRU_ATTACH;
 8231b30:	e0bffa17 	ldw	r2,-24(fp)
 8231b34:	10000715 	stw	zero,28(r2)
   error = (*prp->pr_usrreq)(so,(struct mbuf *)0, LONG2MBUF((long)proto));
 8231b38:	e0bff917 	ldw	r2,-28(fp)
 8231b3c:	10800317 	ldw	r2,12(r2)
 8231b40:	e0ffff17 	ldw	r3,-4(fp)
 8231b44:	180d883a 	mov	r6,r3
 8231b48:	000b883a 	mov	r5,zero
 8231b4c:	e13ffa17 	ldw	r4,-24(fp)
 8231b50:	103ee83a 	callr	r2
 8231b54:	e0bffb15 	stw	r2,-20(fp)
   if (error) goto bad;
 8231b58:	e0bffb17 	ldw	r2,-20(fp)
 8231b5c:	10000a1e 	bne	r2,zero,8231b88 <socreate+0x154>

   if (so_evtmap)
 8231b60:	d0a0ce03 	ldbu	r2,-31944(gp)
 8231b64:	10803fcc 	andi	r2,r2,255
 8231b68:	10001626 	beq	r2,zero,8231bc4 <socreate+0x190>
   {                       
      rc = (*so_evtmap_create) (so);
 8231b6c:	d0a0cc17 	ldw	r2,-31952(gp)
 8231b70:	e13ffa17 	ldw	r4,-24(fp)
 8231b74:	103ee83a 	callr	r2
 8231b78:	e0bffc15 	stw	r2,-16(fp)
      if (rc != 0)
 8231b7c:	e0bffc17 	ldw	r2,-16(fp)
 8231b80:	10000c26 	beq	r2,zero,8231bb4 <socreate+0x180>
 8231b84:	00000106 	br	8231b8c <socreate+0x158>
   so->inp_moptions = NULL;
#endif   /* IP_MULTICAST */

   so->so_req = PRU_ATTACH;
   error = (*prp->pr_usrreq)(so,(struct mbuf *)0, LONG2MBUF((long)proto));
   if (error) goto bad;
 8231b88:	0001883a 	nop
   {                       
      rc = (*so_evtmap_create) (so);
      if (rc != 0)
      {
bad:   
         so->so_state |= SS_NOFDREF;
 8231b8c:	e0bffa17 	ldw	r2,-24(fp)
 8231b90:	1080088b 	ldhu	r2,34(r2)
 8231b94:	10800054 	ori	r2,r2,1
 8231b98:	1007883a 	mov	r3,r2
 8231b9c:	e0bffa17 	ldw	r2,-24(fp)
 8231ba0:	10c0088d 	sth	r3,34(r2)
         sofree (so);
 8231ba4:	e13ffa17 	ldw	r4,-24(fp)
 8231ba8:	8231d080 	call	8231d08 <sofree>
         return NULL;   
 8231bac:	0005883a 	mov	r2,zero
 8231bb0:	00000506 	br	8231bc8 <socreate+0x194>
      /*
       * Altera Niche Stack Nios port modification:
       * Remove (void *) cast since -> owner is now TK_OBJECT
       * to fix build warning.
       */
      so->owner = TK_THIS;
 8231bb4:	82297a00 	call	82297a0 <TK_OSTaskQuery>
 8231bb8:	1007883a 	mov	r3,r2
 8231bbc:	e0bffa17 	ldw	r2,-24(fp)
 8231bc0:	10c02005 	stb	r3,128(r2)
   }

   return so;
 8231bc4:	e0bffa17 	ldw	r2,-24(fp)
}
 8231bc8:	e037883a 	mov	sp,fp
 8231bcc:	dfc00117 	ldw	ra,4(sp)
 8231bd0:	df000017 	ldw	fp,0(sp)
 8231bd4:	dec00204 	addi	sp,sp,8
 8231bd8:	f800283a 	ret

08231bdc <sobind>:
 */

int
sobind(struct socket * so, 
   struct mbuf *  nam)
{
 8231bdc:	defffb04 	addi	sp,sp,-20
 8231be0:	dfc00415 	stw	ra,16(sp)
 8231be4:	df000315 	stw	fp,12(sp)
 8231be8:	df000304 	addi	fp,sp,12
 8231bec:	e13ffe15 	stw	r4,-8(fp)
 8231bf0:	e17fff15 	stw	r5,-4(fp)
   int   error;

   so->so_req = PRU_BIND;
 8231bf4:	e0bffe17 	ldw	r2,-8(fp)
 8231bf8:	00c00084 	movi	r3,2
 8231bfc:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 8231c00:	e0bffe17 	ldw	r2,-8(fp)
 8231c04:	10800217 	ldw	r2,8(r2)
 8231c08:	10800317 	ldw	r2,12(r2)
 8231c0c:	e1bfff17 	ldw	r6,-4(fp)
 8231c10:	000b883a 	mov	r5,zero
 8231c14:	e13ffe17 	ldw	r4,-8(fp)
 8231c18:	103ee83a 	callr	r2
 8231c1c:	e0bffd15 	stw	r2,-12(fp)
   return (error);
 8231c20:	e0bffd17 	ldw	r2,-12(fp)
}
 8231c24:	e037883a 	mov	sp,fp
 8231c28:	dfc00117 	ldw	ra,4(sp)
 8231c2c:	df000017 	ldw	fp,0(sp)
 8231c30:	dec00204 	addi	sp,sp,8
 8231c34:	f800283a 	ret

08231c38 <solisten>:
 */

int
solisten(struct socket * so, 
   int   backlog)
{
 8231c38:	defffb04 	addi	sp,sp,-20
 8231c3c:	dfc00415 	stw	ra,16(sp)
 8231c40:	df000315 	stw	fp,12(sp)
 8231c44:	df000304 	addi	fp,sp,12
 8231c48:	e13ffe15 	stw	r4,-8(fp)
 8231c4c:	e17fff15 	stw	r5,-4(fp)
   int   error;

   so->so_req = PRU_LISTEN;
 8231c50:	e0bffe17 	ldw	r2,-8(fp)
 8231c54:	00c000c4 	movi	r3,3
 8231c58:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so,
 8231c5c:	e0bffe17 	ldw	r2,-8(fp)
 8231c60:	10800217 	ldw	r2,8(r2)
 8231c64:	10800317 	ldw	r2,12(r2)
 8231c68:	000d883a 	mov	r6,zero
 8231c6c:	000b883a 	mov	r5,zero
 8231c70:	e13ffe17 	ldw	r4,-8(fp)
 8231c74:	103ee83a 	callr	r2
 8231c78:	e0bffd15 	stw	r2,-12(fp)
    (struct mbuf *)0, (struct mbuf *)0);
   if (error) 
 8231c7c:	e0bffd17 	ldw	r2,-12(fp)
 8231c80:	10000226 	beq	r2,zero,8231c8c <solisten+0x54>
   {
      return (error);
 8231c84:	e0bffd17 	ldw	r2,-12(fp)
 8231c88:	00001a06 	br	8231cf4 <solisten+0xbc>
   }
   if (so->so_q == 0) 
 8231c8c:	e0bffe17 	ldw	r2,-8(fp)
 8231c90:	10801d17 	ldw	r2,116(r2)
 8231c94:	10000b1e 	bne	r2,zero,8231cc4 <solisten+0x8c>
   {
      so->so_q = so;
 8231c98:	e0bffe17 	ldw	r2,-8(fp)
 8231c9c:	e0fffe17 	ldw	r3,-8(fp)
 8231ca0:	10c01d15 	stw	r3,116(r2)
      so->so_q0 = so;
 8231ca4:	e0bffe17 	ldw	r2,-8(fp)
 8231ca8:	e0fffe17 	ldw	r3,-8(fp)
 8231cac:	10c01c15 	stw	r3,112(r2)
      so->so_options |= SO_ACCEPTCONN;
 8231cb0:	e0bffe17 	ldw	r2,-8(fp)
 8231cb4:	10800417 	ldw	r2,16(r2)
 8231cb8:	10c00094 	ori	r3,r2,2
 8231cbc:	e0bffe17 	ldw	r2,-8(fp)
 8231cc0:	10c00415 	stw	r3,16(r2)
   }
   if (backlog < 0)
 8231cc4:	e0bfff17 	ldw	r2,-4(fp)
 8231cc8:	1000010e 	bge	r2,zero,8231cd0 <solisten+0x98>
      backlog = 0;
 8231ccc:	e03fff15 	stw	zero,-4(fp)
   so->so_qlimit = (char)MIN(backlog, SOMAXCONN);
 8231cd0:	e0bfff17 	ldw	r2,-4(fp)
 8231cd4:	10800188 	cmpgei	r2,r2,6
 8231cd8:	1000021e 	bne	r2,zero,8231ce4 <solisten+0xac>
 8231cdc:	e0bfff17 	ldw	r2,-4(fp)
 8231ce0:	00000106 	br	8231ce8 <solisten+0xb0>
 8231ce4:	00800144 	movi	r2,5
 8231ce8:	e0fffe17 	ldw	r3,-8(fp)
 8231cec:	18801e85 	stb	r2,122(r3)
   return 0;
 8231cf0:	0005883a 	mov	r2,zero
}
 8231cf4:	e037883a 	mov	sp,fp
 8231cf8:	dfc00117 	ldw	ra,4(sp)
 8231cfc:	df000017 	ldw	fp,0(sp)
 8231d00:	dec00204 	addi	sp,sp,8
 8231d04:	f800283a 	ret

08231d08 <sofree>:
 * RETURNS: 
 */

void
sofree(struct socket * so)
{
 8231d08:	defffd04 	addi	sp,sp,-12
 8231d0c:	dfc00215 	stw	ra,8(sp)
 8231d10:	df000115 	stw	fp,4(sp)
 8231d14:	df000104 	addi	fp,sp,4
 8231d18:	e13fff15 	stw	r4,-4(fp)
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sofree, so %lx so_pcb %lx so_state %x so_head %lx\n",
    so, so->so_pcb, so->so_state, so->so_head));

   if (so->so_pcb || (so->so_state & SS_NOFDREF) == 0)
 8231d1c:	e0bfff17 	ldw	r2,-4(fp)
 8231d20:	10800117 	ldw	r2,4(r2)
 8231d24:	1000361e 	bne	r2,zero,8231e00 <sofree+0xf8>
 8231d28:	e0bfff17 	ldw	r2,-4(fp)
 8231d2c:	1080088b 	ldhu	r2,34(r2)
 8231d30:	10bfffcc 	andi	r2,r2,65535
 8231d34:	1080004c 	andi	r2,r2,1
 8231d38:	10003126 	beq	r2,zero,8231e00 <sofree+0xf8>
      return;
   if (so->so_head) 
 8231d3c:	e0bfff17 	ldw	r2,-4(fp)
 8231d40:	10801b17 	ldw	r2,108(r2)
 8231d44:	10000d26 	beq	r2,zero,8231d7c <sofree+0x74>
   {
      if (!soqremque(so, 0) && !soqremque(so, 1))
 8231d48:	000b883a 	mov	r5,zero
 8231d4c:	e13fff17 	ldw	r4,-4(fp)
 8231d50:	8233fe40 	call	8233fe4 <soqremque>
 8231d54:	1000071e 	bne	r2,zero,8231d74 <sofree+0x6c>
 8231d58:	01400044 	movi	r5,1
 8231d5c:	e13fff17 	ldw	r4,-4(fp)
 8231d60:	8233fe40 	call	8233fe4 <soqremque>
 8231d64:	1000031e 	bne	r2,zero,8231d74 <sofree+0x6c>
         panic("sofree");
 8231d68:	01020974 	movhi	r4,2085
 8231d6c:	21037604 	addi	r4,r4,3544
 8231d70:	8228c480 	call	8228c48 <panic>
      so->so_head = 0;
 8231d74:	e0bfff17 	ldw	r2,-4(fp)
 8231d78:	10001b15 	stw	zero,108(r2)
   }
   sbrelease(&so->so_snd);
 8231d7c:	e0bfff17 	ldw	r2,-4(fp)
 8231d80:	10801204 	addi	r2,r2,72
 8231d84:	1009883a 	mov	r4,r2
 8231d88:	82343a80 	call	82343a8 <sbrelease>
   sorflush(so);
 8231d8c:	e13fff17 	ldw	r4,-4(fp)
 8231d90:	82330480 	call	8233048 <sorflush>
      _socket_free_entry (so);
#endif   /* SAVE_SOCK_ENDPOINTS */

#ifdef IP_MULTICAST
   /* multicast opts? */
   if (so->inp_moptions)
 8231d94:	e0bfff17 	ldw	r2,-4(fp)
 8231d98:	10800317 	ldw	r2,12(r2)
 8231d9c:	10000426 	beq	r2,zero,8231db0 <sofree+0xa8>
	   ip_freemoptions(so->inp_moptions);
 8231da0:	e0bfff17 	ldw	r2,-4(fp)
 8231da4:	10800317 	ldw	r2,12(r2)
 8231da8:	1009883a 	mov	r4,r2
 8231dac:	824667c0 	call	824667c <ip_freemoptions>
#endif   /* IP_MULTICAST */

   /* IP_TOS opts? */
   if (so->so_optsPack)
 8231db0:	e0bfff17 	ldw	r2,-4(fp)
 8231db4:	10801f17 	ldw	r2,124(r2)
 8231db8:	10000426 	beq	r2,zero,8231dcc <sofree+0xc4>
      SOCOPT_FREE(so->so_optsPack);
 8231dbc:	e0bfff17 	ldw	r2,-4(fp)
 8231dc0:	10801f17 	ldw	r2,124(r2)
 8231dc4:	1009883a 	mov	r4,r2
 8231dc8:	822e1a00 	call	822e1a0 <npfree>
	   
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 8231dcc:	e17fff17 	ldw	r5,-4(fp)
 8231dd0:	010209b4 	movhi	r4,2086
 8231dd4:	21395804 	addi	r4,r4,-6816
 8231dd8:	822d02c0 	call	822d02c <qdel>
   
   if (so_evtmap)  
 8231ddc:	d0a0ce03 	ldbu	r2,-31944(gp)
 8231de0:	10803fcc 	andi	r2,r2,255
 8231de4:	10000326 	beq	r2,zero,8231df4 <sofree+0xec>
      (*so_evtmap_delete) (so);
 8231de8:	d0a0cd17 	ldw	r2,-31948(gp)
 8231dec:	e13fff17 	ldw	r4,-4(fp)
 8231df0:	103ee83a 	callr	r2
   
   SOC_FREE(so);
 8231df4:	e13fff17 	ldw	r4,-4(fp)
 8231df8:	822e1a00 	call	822e1a0 <npfree>
 8231dfc:	00000106 	br	8231e04 <sofree+0xfc>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sofree, so %lx so_pcb %lx so_state %x so_head %lx\n",
    so, so->so_pcb, so->so_state, so->so_head));

   if (so->so_pcb || (so->so_state & SS_NOFDREF) == 0)
      return;
 8231e00:	0001883a 	nop
   
   if (so_evtmap)  
      (*so_evtmap_delete) (so);
   
   SOC_FREE(so);
}
 8231e04:	e037883a 	mov	sp,fp
 8231e08:	dfc00117 	ldw	ra,4(sp)
 8231e0c:	df000017 	ldw	fp,0(sp)
 8231e10:	dec00204 	addi	sp,sp,8
 8231e14:	f800283a 	ret

08231e18 <soclose>:
 * RETURNS: 
 */

int
soclose(struct socket * so)
{
 8231e18:	defff904 	addi	sp,sp,-28
 8231e1c:	dfc00615 	stw	ra,24(sp)
 8231e20:	df000515 	stw	fp,20(sp)
 8231e24:	df000504 	addi	fp,sp,20
 8231e28:	e13fff15 	stw	r4,-4(fp)
   int   error =  0;
 8231e2c:	e03ffb15 	stw	zero,-20(fp)
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 8231e30:	008209b4 	movhi	r2,2086
 8231e34:	10b95804 	addi	r2,r2,-6816
 8231e38:	10800017 	ldw	r2,0(r2)
 8231e3c:	e0bffc15 	stw	r2,-16(fp)
 8231e40:	00000606 	br	8231e5c <soclose+0x44>
   {
      if (so == tmpso)
 8231e44:	e0ffff17 	ldw	r3,-4(fp)
 8231e48:	e0bffc17 	ldw	r2,-16(fp)
 8231e4c:	18800626 	beq	r3,r2,8231e68 <soclose+0x50>
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 8231e50:	e0bffc17 	ldw	r2,-16(fp)
 8231e54:	10800017 	ldw	r2,0(r2)
 8231e58:	e0bffc15 	stw	r2,-16(fp)
 8231e5c:	e0bffc17 	ldw	r2,-16(fp)
 8231e60:	103ff81e 	bne	r2,zero,8231e44 <soclose+0x2c>
 8231e64:	00000106 	br	8231e6c <soclose+0x54>
   {
      if (so == tmpso)
         break;
 8231e68:	0001883a 	nop
   }
   if ( tmpso == NULL)
 8231e6c:	e0bffc17 	ldw	r2,-16(fp)
 8231e70:	1000021e 	bne	r2,zero,8231e7c <soclose+0x64>
      return EINVAL;
 8231e74:	00800584 	movi	r2,22
 8231e78:	00009106 	br	82320c0 <soclose+0x2a8>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
 8231e7c:	e0bfff17 	ldw	r2,-4(fp)
 8231e80:	10800417 	ldw	r2,16(r2)
 8231e84:	1080008c 	andi	r2,r2,2
 8231e88:	10001226 	beq	r2,zero,8231ed4 <soclose+0xbc>
   {
      while (so->so_q0 != so)
 8231e8c:	00000406 	br	8231ea0 <soclose+0x88>
         (void) soabort(so->so_q0);
 8231e90:	e0bfff17 	ldw	r2,-4(fp)
 8231e94:	10801c17 	ldw	r2,112(r2)
 8231e98:	1009883a 	mov	r4,r2
 8231e9c:	82320d40 	call	82320d4 <soabort>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
 8231ea0:	e0bfff17 	ldw	r2,-4(fp)
 8231ea4:	10c01c17 	ldw	r3,112(r2)
 8231ea8:	e0bfff17 	ldw	r2,-4(fp)
 8231eac:	18bff81e 	bne	r3,r2,8231e90 <soclose+0x78>
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 8231eb0:	00000406 	br	8231ec4 <soclose+0xac>
         (void) soabort(so->so_q);
 8231eb4:	e0bfff17 	ldw	r2,-4(fp)
 8231eb8:	10801d17 	ldw	r2,116(r2)
 8231ebc:	1009883a 	mov	r4,r2
 8231ec0:	82320d40 	call	82320d4 <soabort>
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 8231ec4:	e0bfff17 	ldw	r2,-4(fp)
 8231ec8:	10c01d17 	ldw	r3,116(r2)
 8231ecc:	e0bfff17 	ldw	r2,-4(fp)
 8231ed0:	18bff81e 	bne	r3,r2,8231eb4 <soclose+0x9c>
         (void) soabort(so->so_q);
   }
   /* for datagram-oriented sockets, dispense with further tests */
   if (so->so_type != SOCK_STREAM)
 8231ed4:	e0bfff17 	ldw	r2,-4(fp)
 8231ed8:	10800983 	ldbu	r2,38(r2)
 8231edc:	10803fcc 	andi	r2,r2,255
 8231ee0:	1080201c 	xori	r2,r2,128
 8231ee4:	10bfe004 	addi	r2,r2,-128
 8231ee8:	10800060 	cmpeqi	r2,r2,1
 8231eec:	10000c1e 	bne	r2,zero,8231f20 <soclose+0x108>
   { 
      so->so_req = PRU_DETACH;
 8231ef0:	e0bfff17 	ldw	r2,-4(fp)
 8231ef4:	00c00044 	movi	r3,1
 8231ef8:	10c00715 	stw	r3,28(r2)
      error = (*so->so_proto->pr_usrreq)(so,
 8231efc:	e0bfff17 	ldw	r2,-4(fp)
 8231f00:	10800217 	ldw	r2,8(r2)
 8231f04:	10800317 	ldw	r2,12(r2)
 8231f08:	000d883a 	mov	r6,zero
 8231f0c:	000b883a 	mov	r5,zero
 8231f10:	e13fff17 	ldw	r4,-4(fp)
 8231f14:	103ee83a 	callr	r2
 8231f18:	e0bffb15 	stw	r2,-20(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      goto discard;
 8231f1c:	00005906 	br	8232084 <soclose+0x26c>
   }

   if (so->so_pcb == 0)
 8231f20:	e0bfff17 	ldw	r2,-4(fp)
 8231f24:	10800117 	ldw	r2,4(r2)
 8231f28:	10005526 	beq	r2,zero,8232080 <soclose+0x268>
      goto discard;
   if (so->so_state & SS_ISCONNECTED) 
 8231f2c:	e0bfff17 	ldw	r2,-4(fp)
 8231f30:	1080088b 	ldhu	r2,34(r2)
 8231f34:	10bfffcc 	andi	r2,r2,65535
 8231f38:	1080008c 	andi	r2,r2,2
 8231f3c:	10003d26 	beq	r2,zero,8232034 <soclose+0x21c>
   {
      if ((so->so_state & SS_ISDISCONNECTING) == 0) 
 8231f40:	e0bfff17 	ldw	r2,-4(fp)
 8231f44:	1080088b 	ldhu	r2,34(r2)
 8231f48:	10bfffcc 	andi	r2,r2,65535
 8231f4c:	1080020c 	andi	r2,r2,8
 8231f50:	1000051e 	bne	r2,zero,8231f68 <soclose+0x150>
      {
         error = sodisconnect(so);
 8231f54:	e13fff17 	ldw	r4,-4(fp)
 8231f58:	82322740 	call	8232274 <sodisconnect>
 8231f5c:	e0bffb15 	stw	r2,-20(fp)
         if (error)
 8231f60:	e0bffb17 	ldw	r2,-20(fp)
 8231f64:	1000301e 	bne	r2,zero,8232028 <soclose+0x210>
            goto drop;
      }
      if (so->so_options & SO_LINGER) 
 8231f68:	e0bfff17 	ldw	r2,-4(fp)
 8231f6c:	10800417 	ldw	r2,16(r2)
 8231f70:	1080200c 	andi	r2,r2,128
 8231f74:	10002126 	beq	r2,zero,8231ffc <soclose+0x1e4>
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
 8231f78:	e0bfff17 	ldw	r2,-4(fp)
 8231f7c:	1080088b 	ldhu	r2,34(r2)
 8231f80:	10bfffcc 	andi	r2,r2,65535
 8231f84:	1080020c 	andi	r2,r2,8
 8231f88:	10000526 	beq	r2,zero,8231fa0 <soclose+0x188>
             (so->so_state & SS_NBIO))
 8231f8c:	e0bfff17 	ldw	r2,-4(fp)
 8231f90:	1080088b 	ldhu	r2,34(r2)
 8231f94:	10bfffcc 	andi	r2,r2,65535
 8231f98:	1080400c 	andi	r2,r2,256
         if (error)
            goto drop;
      }
      if (so->so_options & SO_LINGER) 
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
 8231f9c:	1000241e 	bne	r2,zero,8232030 <soclose+0x218>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
 8231fa0:	e0bfff17 	ldw	r2,-4(fp)
 8231fa4:	1080080b 	ldhu	r2,32(r2)
 8231fa8:	10bfffcc 	andi	r2,r2,65535
 8231fac:	10a0001c 	xori	r2,r2,32768
 8231fb0:	10a00004 	addi	r2,r2,-32768
 8231fb4:	10c01924 	muli	r3,r2,100
 8231fb8:	d0a0a817 	ldw	r2,-32096(gp)
 8231fbc:	1885883a 	add	r2,r3,r2
 8231fc0:	e0bffd15 	stw	r2,-12(fp)
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 8231fc4:	00000406 	br	8231fd8 <soclose+0x1c0>
         {
            tcp_sleep((char *)&so->so_timeo);
 8231fc8:	e0bfff17 	ldw	r2,-4(fp)
 8231fcc:	10800904 	addi	r2,r2,36
 8231fd0:	1009883a 	mov	r4,r2
 8231fd4:	82295340 	call	8229534 <tcp_sleep>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 8231fd8:	e0bfff17 	ldw	r2,-4(fp)
 8231fdc:	1080088b 	ldhu	r2,34(r2)
 8231fe0:	10bfffcc 	andi	r2,r2,65535
 8231fe4:	1080008c 	andi	r2,r2,2
 8231fe8:	10001226 	beq	r2,zero,8232034 <soclose+0x21c>
 8231fec:	d0e0a817 	ldw	r3,-32096(gp)
 8231ff0:	e0bffd17 	ldw	r2,-12(fp)
 8231ff4:	18bff436 	bltu	r3,r2,8231fc8 <soclose+0x1b0>
 8231ff8:	00000e06 	br	8232034 <soclose+0x21c>
      {
         /* If socket still has send data just return now, leaving the 
          * socket intact so the data can be sent. Socket should be cleaned
          * up later by timers.
          */
         if(so->so_snd.sb_cc)
 8231ffc:	e0bfff17 	ldw	r2,-4(fp)
 8232000:	10801217 	ldw	r2,72(r2)
 8232004:	10000b26 	beq	r2,zero,8232034 <soclose+0x21c>
         {
            so->so_state |= SS_NOFDREF;   /* mark as OK to close */
 8232008:	e0bfff17 	ldw	r2,-4(fp)
 823200c:	1080088b 	ldhu	r2,34(r2)
 8232010:	10800054 	ori	r2,r2,1
 8232014:	1007883a 	mov	r3,r2
 8232018:	e0bfff17 	ldw	r2,-4(fp)
 823201c:	10c0088d 	sth	r3,34(r2)
            return 0;
 8232020:	0005883a 	mov	r2,zero
 8232024:	00002606 	br	82320c0 <soclose+0x2a8>
   {
      if ((so->so_state & SS_ISDISCONNECTING) == 0) 
      {
         error = sodisconnect(so);
         if (error)
            goto drop;
 8232028:	0001883a 	nop
 823202c:	00000106 	br	8232034 <soclose+0x21c>
      if (so->so_options & SO_LINGER) 
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
             (so->so_state & SS_NBIO))
         {
            goto drop;
 8232030:	0001883a 	nop
            return 0;
         }
      }
   }
drop:
   if (so->so_pcb) 
 8232034:	e0bfff17 	ldw	r2,-4(fp)
 8232038:	10800117 	ldw	r2,4(r2)
 823203c:	10001126 	beq	r2,zero,8232084 <soclose+0x26c>
   {
      int   error2;
      so->so_req = PRU_DETACH;
 8232040:	e0bfff17 	ldw	r2,-4(fp)
 8232044:	00c00044 	movi	r3,1
 8232048:	10c00715 	stw	r3,28(r2)
      error2 = (*so->so_proto->pr_usrreq)(so,
 823204c:	e0bfff17 	ldw	r2,-4(fp)
 8232050:	10800217 	ldw	r2,8(r2)
 8232054:	10800317 	ldw	r2,12(r2)
 8232058:	000d883a 	mov	r6,zero
 823205c:	000b883a 	mov	r5,zero
 8232060:	e13fff17 	ldw	r4,-4(fp)
 8232064:	103ee83a 	callr	r2
 8232068:	e0bffe15 	stw	r2,-8(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      if (error == 0)
 823206c:	e0bffb17 	ldw	r2,-20(fp)
 8232070:	1000041e 	bne	r2,zero,8232084 <soclose+0x26c>
         error = error2;
 8232074:	e0bffe17 	ldw	r2,-8(fp)
 8232078:	e0bffb15 	stw	r2,-20(fp)
 823207c:	00000106 	br	8232084 <soclose+0x26c>
       (struct mbuf *)0, (struct mbuf *)0);
      goto discard;
   }

   if (so->so_pcb == 0)
      goto discard;
 8232080:	0001883a 	nop
       (struct mbuf *)0, (struct mbuf *)0);
      if (error == 0)
         error = error2;
   }
discard:
   if (so->so_state & SS_NOFDREF)
 8232084:	e0bfff17 	ldw	r2,-4(fp)
 8232088:	1080088b 	ldhu	r2,34(r2)
 823208c:	10bfffcc 	andi	r2,r2,65535
 8232090:	1080004c 	andi	r2,r2,1
 8232094:	10000126 	beq	r2,zero,823209c <soclose+0x284>
   {
      /* panic("soclose");  - non-fatal - degrade to dtrap() for now */
      dtrap();
 8232098:	822d5940 	call	822d594 <dtrap>
   }
   so->so_state |= SS_NOFDREF;
 823209c:	e0bfff17 	ldw	r2,-4(fp)
 82320a0:	1080088b 	ldhu	r2,34(r2)
 82320a4:	10800054 	ori	r2,r2,1
 82320a8:	1007883a 	mov	r3,r2
 82320ac:	e0bfff17 	ldw	r2,-4(fp)
 82320b0:	10c0088d 	sth	r3,34(r2)
   sofree(so);
 82320b4:	e13fff17 	ldw	r4,-4(fp)
 82320b8:	8231d080 	call	8231d08 <sofree>
   return (error);
 82320bc:	e0bffb17 	ldw	r2,-20(fp)
}
 82320c0:	e037883a 	mov	sp,fp
 82320c4:	dfc00117 	ldw	ra,4(sp)
 82320c8:	df000017 	ldw	fp,0(sp)
 82320cc:	dec00204 	addi	sp,sp,8
 82320d0:	f800283a 	ret

082320d4 <soabort>:
 * RETURNS: 
 */

int
soabort(struct socket * so)
{
 82320d4:	defffd04 	addi	sp,sp,-12
 82320d8:	dfc00215 	stw	ra,8(sp)
 82320dc:	df000115 	stw	fp,4(sp)
 82320e0:	df000104 	addi	fp,sp,4
 82320e4:	e13fff15 	stw	r4,-4(fp)
   so->so_req = PRU_ABORT;
 82320e8:	e0bfff17 	ldw	r2,-4(fp)
 82320ec:	00c00284 	movi	r3,10
 82320f0:	10c00715 	stw	r3,28(r2)
   return(*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 82320f4:	e0bfff17 	ldw	r2,-4(fp)
 82320f8:	10800217 	ldw	r2,8(r2)
 82320fc:	10800317 	ldw	r2,12(r2)
 8232100:	000d883a 	mov	r6,zero
 8232104:	000b883a 	mov	r5,zero
 8232108:	e13fff17 	ldw	r4,-4(fp)
 823210c:	103ee83a 	callr	r2
}
 8232110:	e037883a 	mov	sp,fp
 8232114:	dfc00117 	ldw	ra,4(sp)
 8232118:	df000017 	ldw	fp,0(sp)
 823211c:	dec00204 	addi	sp,sp,8
 8232120:	f800283a 	ret

08232124 <soaccept>:
 */

int
soaccept(struct socket * so, 
   struct mbuf *  nam)
{
 8232124:	defffb04 	addi	sp,sp,-20
 8232128:	dfc00415 	stw	ra,16(sp)
 823212c:	df000315 	stw	fp,12(sp)
 8232130:	df000304 	addi	fp,sp,12
 8232134:	e13ffe15 	stw	r4,-8(fp)
 8232138:	e17fff15 	stw	r5,-4(fp)
   int   error;

   if ((so->so_state & SS_NOFDREF) == 0)
 823213c:	e0bffe17 	ldw	r2,-8(fp)
 8232140:	1080088b 	ldhu	r2,34(r2)
 8232144:	10bfffcc 	andi	r2,r2,65535
 8232148:	1080004c 	andi	r2,r2,1
 823214c:	1000031e 	bne	r2,zero,823215c <soaccept+0x38>
      panic("soaccept");
 8232150:	01020974 	movhi	r4,2085
 8232154:	21037804 	addi	r4,r4,3552
 8232158:	8228c480 	call	8228c48 <panic>
   so->so_state &= ~SS_NOFDREF;
 823215c:	e0bffe17 	ldw	r2,-8(fp)
 8232160:	10c0088b 	ldhu	r3,34(r2)
 8232164:	00bfff84 	movi	r2,-2
 8232168:	1884703a 	and	r2,r3,r2
 823216c:	1007883a 	mov	r3,r2
 8232170:	e0bffe17 	ldw	r2,-8(fp)
 8232174:	10c0088d 	sth	r3,34(r2)
   so->so_req = PRU_ACCEPT;
 8232178:	e0bffe17 	ldw	r2,-8(fp)
 823217c:	00c00144 	movi	r3,5
 8232180:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 8232184:	e0bffe17 	ldw	r2,-8(fp)
 8232188:	10800217 	ldw	r2,8(r2)
 823218c:	10800317 	ldw	r2,12(r2)
 8232190:	e1bfff17 	ldw	r6,-4(fp)
 8232194:	000b883a 	mov	r5,zero
 8232198:	e13ffe17 	ldw	r4,-8(fp)
 823219c:	103ee83a 	callr	r2
 82321a0:	e0bffd15 	stw	r2,-12(fp)

   return (error);
 82321a4:	e0bffd17 	ldw	r2,-12(fp)
}
 82321a8:	e037883a 	mov	sp,fp
 82321ac:	dfc00117 	ldw	ra,4(sp)
 82321b0:	df000017 	ldw	fp,0(sp)
 82321b4:	dec00204 	addi	sp,sp,8
 82321b8:	f800283a 	ret

082321bc <soconnect>:
 */

int
soconnect(struct socket * so, 
   struct mbuf *  nam)
{
 82321bc:	defffb04 	addi	sp,sp,-20
 82321c0:	dfc00415 	stw	ra,16(sp)
 82321c4:	df000315 	stw	fp,12(sp)
 82321c8:	df000304 	addi	fp,sp,12
 82321cc:	e13ffe15 	stw	r4,-8(fp)
 82321d0:	e17fff15 	stw	r5,-4(fp)
   int   error;

   if (so->so_options & SO_ACCEPTCONN)
 82321d4:	e0bffe17 	ldw	r2,-8(fp)
 82321d8:	10800417 	ldw	r2,16(r2)
 82321dc:	1080008c 	andi	r2,r2,2
 82321e0:	10000226 	beq	r2,zero,82321ec <soconnect+0x30>
      return (EOPNOTSUPP);
 82321e4:	008017c4 	movi	r2,95
 82321e8:	00001d06 	br	8232260 <soconnect+0xa4>
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 82321ec:	e0bffe17 	ldw	r2,-8(fp)
 82321f0:	1080088b 	ldhu	r2,34(r2)
 82321f4:	10bfffcc 	andi	r2,r2,65535
 82321f8:	1080018c 	andi	r2,r2,6
 82321fc:	10000c26 	beq	r2,zero,8232230 <soconnect+0x74>
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
 8232200:	e0bffe17 	ldw	r2,-8(fp)
 8232204:	10800217 	ldw	r2,8(r2)
 8232208:	1080010b 	ldhu	r2,4(r2)
 823220c:	10bfffcc 	andi	r2,r2,65535
 8232210:	1080010c 	andi	r2,r2,4
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 8232214:	1000031e 	bne	r2,zero,8232224 <soconnect+0x68>
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
       (sodisconnect(so) != 0)))
 8232218:	e13ffe17 	ldw	r4,-8(fp)
 823221c:	82322740 	call	8232274 <sodisconnect>
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
 8232220:	10000326 	beq	r2,zero,8232230 <soconnect+0x74>
       (sodisconnect(so) != 0)))
   {
      error = EISCONN;
 8232224:	00801fc4 	movi	r2,127
 8232228:	e0bffd15 	stw	r2,-12(fp)
 823222c:	00000b06 	br	823225c <soconnect+0xa0>
   }
   else
   {
      so->so_req = PRU_CONNECT;
 8232230:	e0bffe17 	ldw	r2,-8(fp)
 8232234:	00c00104 	movi	r3,4
 8232238:	10c00715 	stw	r3,28(r2)
      error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 823223c:	e0bffe17 	ldw	r2,-8(fp)
 8232240:	10800217 	ldw	r2,8(r2)
 8232244:	10800317 	ldw	r2,12(r2)
 8232248:	e1bfff17 	ldw	r6,-4(fp)
 823224c:	000b883a 	mov	r5,zero
 8232250:	e13ffe17 	ldw	r4,-8(fp)
 8232254:	103ee83a 	callr	r2
 8232258:	e0bffd15 	stw	r2,-12(fp)
   }
   return error;
 823225c:	e0bffd17 	ldw	r2,-12(fp)
}
 8232260:	e037883a 	mov	sp,fp
 8232264:	dfc00117 	ldw	ra,4(sp)
 8232268:	df000017 	ldw	fp,0(sp)
 823226c:	dec00204 	addi	sp,sp,8
 8232270:	f800283a 	ret

08232274 <sodisconnect>:
 * RETURNS: 
 */

int
sodisconnect(struct socket * so)
{
 8232274:	defffc04 	addi	sp,sp,-16
 8232278:	dfc00315 	stw	ra,12(sp)
 823227c:	df000215 	stw	fp,8(sp)
 8232280:	df000204 	addi	fp,sp,8
 8232284:	e13fff15 	stw	r4,-4(fp)
   int   error;

   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sodisconnect, so %lx so_state %x\n", so, so->so_state));

   if ((so->so_state & SS_ISCONNECTED) == 0) 
 8232288:	e0bfff17 	ldw	r2,-4(fp)
 823228c:	1080088b 	ldhu	r2,34(r2)
 8232290:	10bfffcc 	andi	r2,r2,65535
 8232294:	1080008c 	andi	r2,r2,2
 8232298:	1000031e 	bne	r2,zero,82322a8 <sodisconnect+0x34>
   {
      error = ENOTCONN;
 823229c:	00802004 	movi	r2,128
 82322a0:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 82322a4:	00001306 	br	82322f4 <sodisconnect+0x80>
   }
   if (so->so_state & SS_ISDISCONNECTING) 
 82322a8:	e0bfff17 	ldw	r2,-4(fp)
 82322ac:	1080088b 	ldhu	r2,34(r2)
 82322b0:	10bfffcc 	andi	r2,r2,65535
 82322b4:	1080020c 	andi	r2,r2,8
 82322b8:	10000326 	beq	r2,zero,82322c8 <sodisconnect+0x54>
   {
      error = EALREADY;
 82322bc:	00801e04 	movi	r2,120
 82322c0:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 82322c4:	00000b06 	br	82322f4 <sodisconnect+0x80>
   }
   so->so_req = PRU_DISCONNECT;
 82322c8:	e0bfff17 	ldw	r2,-4(fp)
 82322cc:	00c00184 	movi	r3,6
 82322d0:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 82322d4:	e0bfff17 	ldw	r2,-4(fp)
 82322d8:	10800217 	ldw	r2,8(r2)
 82322dc:	10800317 	ldw	r2,12(r2)
 82322e0:	000d883a 	mov	r6,zero
 82322e4:	000b883a 	mov	r5,zero
 82322e8:	e13fff17 	ldw	r4,-4(fp)
 82322ec:	103ee83a 	callr	r2
 82322f0:	e0bffe15 	stw	r2,-8(fp)

bad:
   return (error);
 82322f4:	e0bffe17 	ldw	r2,-8(fp)
}
 82322f8:	e037883a 	mov	sp,fp
 82322fc:	dfc00117 	ldw	ra,4(sp)
 8232300:	df000017 	ldw	fp,0(sp)
 8232304:	dec00204 	addi	sp,sp,8
 8232308:	f800283a 	ret

0823230c <sosend>:
sosend(struct socket *so, 
       struct mbuf *nam,      /* sockaddr, if UDP socket, NULL if TCP */
       char  *data,           /* data to send */
       int   *data_length,    /* IN/OUT  length of (remaining) data */
       int   flags)
{
 823230c:	defff204 	addi	sp,sp,-56
 8232310:	dfc00d15 	stw	ra,52(sp)
 8232314:	df000c15 	stw	fp,48(sp)
 8232318:	df000c04 	addi	fp,sp,48
 823231c:	e13ffc15 	stw	r4,-16(fp)
 8232320:	e17ffd15 	stw	r5,-12(fp)
 8232324:	e1bffe15 	stw	r6,-8(fp)
 8232328:	e1ffff15 	stw	r7,-4(fp)
   struct mbuf *head = (struct mbuf *)NULL;
 823232c:	e03ff415 	stw	zero,-48(fp)
   struct mbuf *m;
   int   space;
   int   resid;
   int   len;
   int   error = 0;
 8232330:	e03ff815 	stw	zero,-32(fp)
   int   dontroute;
   int   first = 1;
 8232334:	00800044 	movi	r2,1
 8232338:	e0bff915 	stw	r2,-28(fp)

   resid = *data_length;
 823233c:	e0bfff17 	ldw	r2,-4(fp)
 8232340:	10800017 	ldw	r2,0(r2)
 8232344:	e0bff715 	stw	r2,-36(fp)
    * However, space must be signed, as it might be less than 0
    * if we over-committed, and we must use a signed comparison
    * of space and resid.  On the other hand, a negative resid
    * causes us to loop sending 0-length segments to the protocol.
    */
   if (resid < 0)
 8232348:	e0bff717 	ldw	r2,-36(fp)
 823234c:	1000020e 	bge	r2,zero,8232358 <sosend+0x4c>
      return (EINVAL);
 8232350:	00800584 	movi	r2,22
 8232354:	00013e06 	br	8232850 <sosend+0x544>

   INET_TRACE (INETM_IO, ("INET:sosend: so %lx resid %d sb_hiwat %d so_state %x\n",
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
 8232358:	e0bffc17 	ldw	r2,-16(fp)
 823235c:	10800217 	ldw	r2,8(r2)
 8232360:	1080010b 	ldhu	r2,4(r2)
 8232364:	10bfffcc 	andi	r2,r2,65535
 8232368:	1080004c 	andi	r2,r2,1
 823236c:	10000726 	beq	r2,zero,823238c <sosend+0x80>
 8232370:	e0bffc17 	ldw	r2,-16(fp)
 8232374:	10801317 	ldw	r2,76(r2)
 8232378:	1007883a 	mov	r3,r2
 823237c:	e0bff717 	ldw	r2,-36(fp)
 8232380:	1880020e 	bge	r3,r2,823238c <sosend+0x80>
      return (EMSGSIZE);
 8232384:	00801e84 	movi	r2,122
 8232388:	00013106 	br	8232850 <sosend+0x544>

   dontroute = (flags & MSG_DONTROUTE) &&
 823238c:	e0800217 	ldw	r2,8(fp)
 8232390:	1080010c 	andi	r2,r2,4
               ((so->so_options & SO_DONTROUTE) == 0) &&
 8232394:	10000c26 	beq	r2,zero,82323c8 <sosend+0xbc>
 8232398:	e0bffc17 	ldw	r2,-16(fp)
 823239c:	10800417 	ldw	r2,16(r2)
 82323a0:	1080040c 	andi	r2,r2,16
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
      return (EMSGSIZE);

   dontroute = (flags & MSG_DONTROUTE) &&
 82323a4:	1000081e 	bne	r2,zero,82323c8 <sosend+0xbc>
               ((so->so_options & SO_DONTROUTE) == 0) &&
               (so->so_proto->pr_flags & PR_ATOMIC);
 82323a8:	e0bffc17 	ldw	r2,-16(fp)
 82323ac:	10800217 	ldw	r2,8(r2)
 82323b0:	1080010b 	ldhu	r2,4(r2)
 82323b4:	10bfffcc 	andi	r2,r2,65535
 82323b8:	1080004c 	andi	r2,r2,1

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
      return (EMSGSIZE);

   dontroute = (flags & MSG_DONTROUTE) &&
               ((so->so_options & SO_DONTROUTE) == 0) &&
 82323bc:	10000226 	beq	r2,zero,82323c8 <sosend+0xbc>
 82323c0:	00800044 	movi	r2,1
 82323c4:	00000106 	br	82323cc <sosend+0xc0>
 82323c8:	0005883a 	mov	r2,zero
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
      return (EMSGSIZE);

   dontroute = (flags & MSG_DONTROUTE) &&
 82323cc:	e0bffa15 	stw	r2,-24(fp)
               (so->so_proto->pr_flags & PR_ATOMIC);

#define     snderr(errno)     {  error =  errno;   goto  release; }

restart:
   sblock(&so->so_snd);
 82323d0:	00000406 	br	82323e4 <sosend+0xd8>
 82323d4:	e0bffc17 	ldw	r2,-16(fp)
 82323d8:	10801904 	addi	r2,r2,100
 82323dc:	1009883a 	mov	r4,r2
 82323e0:	82295340 	call	8229534 <tcp_sleep>
 82323e4:	e0bffc17 	ldw	r2,-16(fp)
 82323e8:	1080190b 	ldhu	r2,100(r2)
 82323ec:	10bfffcc 	andi	r2,r2,65535
 82323f0:	1080004c 	andi	r2,r2,1
 82323f4:	103ff71e 	bne	r2,zero,82323d4 <sosend+0xc8>
 82323f8:	e0bffc17 	ldw	r2,-16(fp)
 82323fc:	1080190b 	ldhu	r2,100(r2)
 8232400:	10800054 	ori	r2,r2,1
 8232404:	1007883a 	mov	r3,r2
 8232408:	e0bffc17 	ldw	r2,-16(fp)
 823240c:	10c0190d 	sth	r3,100(r2)
   do 
   {
      if (so->so_error) 
 8232410:	e0bffc17 	ldw	r2,-16(fp)
 8232414:	10800617 	ldw	r2,24(r2)
 8232418:	10000626 	beq	r2,zero,8232434 <sosend+0x128>
      {
         error = so->so_error;
 823241c:	e0bffc17 	ldw	r2,-16(fp)
 8232420:	10800617 	ldw	r2,24(r2)
 8232424:	e0bff815 	stw	r2,-32(fp)
         so->so_error = 0;          /* ??? */
 8232428:	e0bffc17 	ldw	r2,-16(fp)
 823242c:	10000615 	stw	zero,24(r2)
         goto release;
 8232430:	0000f706 	br	8232810 <sosend+0x504>
      }
      if (so->so_state & SS_CANTSENDMORE)
 8232434:	e0bffc17 	ldw	r2,-16(fp)
 8232438:	1080088b 	ldhu	r2,34(r2)
 823243c:	10bfffcc 	andi	r2,r2,65535
 8232440:	1080040c 	andi	r2,r2,16
 8232444:	10000326 	beq	r2,zero,8232454 <sosend+0x148>
         snderr(EPIPE);
 8232448:	00800804 	movi	r2,32
 823244c:	e0bff815 	stw	r2,-32(fp)
 8232450:	0000ef06 	br	8232810 <sosend+0x504>
      if ((so->so_state & SS_ISCONNECTED) == 0) 
 8232454:	e0bffc17 	ldw	r2,-16(fp)
 8232458:	1080088b 	ldhu	r2,34(r2)
 823245c:	10bfffcc 	andi	r2,r2,65535
 8232460:	1080008c 	andi	r2,r2,2
 8232464:	10000e1e 	bne	r2,zero,82324a0 <sosend+0x194>
      {
         if (so->so_proto->pr_flags & PR_CONNREQUIRED)
 8232468:	e0bffc17 	ldw	r2,-16(fp)
 823246c:	10800217 	ldw	r2,8(r2)
 8232470:	1080010b 	ldhu	r2,4(r2)
 8232474:	10bfffcc 	andi	r2,r2,65535
 8232478:	1080010c 	andi	r2,r2,4
 823247c:	10000326 	beq	r2,zero,823248c <sosend+0x180>
            snderr(ENOTCONN);
 8232480:	00802004 	movi	r2,128
 8232484:	e0bff815 	stw	r2,-32(fp)
 8232488:	0000e106 	br	8232810 <sosend+0x504>
         if (nam == 0)
 823248c:	e0bffd17 	ldw	r2,-12(fp)
 8232490:	1000031e 	bne	r2,zero,82324a0 <sosend+0x194>
            snderr(EDESTADDRREQ);
 8232494:	00801e44 	movi	r2,121
 8232498:	e0bff815 	stw	r2,-32(fp)
 823249c:	0000dc06 	br	8232810 <sosend+0x504>
      }
      if (flags & MSG_OOB)
 82324a0:	e0800217 	ldw	r2,8(fp)
 82324a4:	1080004c 	andi	r2,r2,1
 82324a8:	10000326 	beq	r2,zero,82324b8 <sosend+0x1ac>
         space = 1024;
 82324ac:	00810004 	movi	r2,1024
 82324b0:	e0bff615 	stw	r2,-40(fp)
 82324b4:	00004706 	br	82325d4 <sosend+0x2c8>
      else 
      {
         space = (int)sbspace(&so->so_snd);
 82324b8:	e0bffc17 	ldw	r2,-16(fp)
 82324bc:	10801317 	ldw	r2,76(r2)
 82324c0:	1007883a 	mov	r3,r2
 82324c4:	e0bffc17 	ldw	r2,-16(fp)
 82324c8:	10801217 	ldw	r2,72(r2)
 82324cc:	1885c83a 	sub	r2,r3,r2
 82324d0:	10000616 	blt	r2,zero,82324ec <sosend+0x1e0>
 82324d4:	e0bffc17 	ldw	r2,-16(fp)
 82324d8:	10c01317 	ldw	r3,76(r2)
 82324dc:	e0bffc17 	ldw	r2,-16(fp)
 82324e0:	10801217 	ldw	r2,72(r2)
 82324e4:	1885c83a 	sub	r2,r3,r2
 82324e8:	00000106 	br	82324f0 <sosend+0x1e4>
 82324ec:	0005883a 	mov	r2,zero
 82324f0:	e0bff615 	stw	r2,-40(fp)
         if ((sosendallatonce(so) && (space < resid)) ||
 82324f4:	e0bffc17 	ldw	r2,-16(fp)
 82324f8:	10800217 	ldw	r2,8(r2)
 82324fc:	1080010b 	ldhu	r2,4(r2)
 8232500:	10bfffcc 	andi	r2,r2,65535
 8232504:	1080004c 	andi	r2,r2,1
 8232508:	10000326 	beq	r2,zero,8232518 <sosend+0x20c>
 823250c:	e0fff617 	ldw	r3,-40(fp)
 8232510:	e0bff717 	ldw	r2,-36(fp)
 8232514:	18801216 	blt	r3,r2,8232560 <sosend+0x254>
 8232518:	e0bff717 	ldw	r2,-36(fp)
 823251c:	10815e10 	cmplti	r2,r2,1400
 8232520:	10002c1e 	bne	r2,zero,82325d4 <sosend+0x2c8>
             ((resid >= CLBYTES) && (space < CLBYTES) &&
 8232524:	e0bff617 	ldw	r2,-40(fp)
 8232528:	10815e08 	cmpgei	r2,r2,1400
 823252c:	1000291e 	bne	r2,zero,82325d4 <sosend+0x2c8>
              (so->so_snd.sb_cc >= CLBYTES) &&
 8232530:	e0bffc17 	ldw	r2,-16(fp)
 8232534:	10801217 	ldw	r2,72(r2)
         space = 1024;
      else 
      {
         space = (int)sbspace(&so->so_snd);
         if ((sosendallatonce(so) && (space < resid)) ||
             ((resid >= CLBYTES) && (space < CLBYTES) &&
 8232538:	10815e30 	cmpltui	r2,r2,1400
 823253c:	1000251e 	bne	r2,zero,82325d4 <sosend+0x2c8>
              (so->so_snd.sb_cc >= CLBYTES) &&
              ((so->so_state & SS_NBIO) == 0) &&
 8232540:	e0bffc17 	ldw	r2,-16(fp)
 8232544:	1080088b 	ldhu	r2,34(r2)
 8232548:	10bfffcc 	andi	r2,r2,65535
 823254c:	1080400c 	andi	r2,r2,256
      else 
      {
         space = (int)sbspace(&so->so_snd);
         if ((sosendallatonce(so) && (space < resid)) ||
             ((resid >= CLBYTES) && (space < CLBYTES) &&
              (so->so_snd.sb_cc >= CLBYTES) &&
 8232550:	1000201e 	bne	r2,zero,82325d4 <sosend+0x2c8>
              ((so->so_state & SS_NBIO) == 0) &&
              ((flags & MSG_DONTWAIT) == 0)))
 8232554:	e0800217 	ldw	r2,8(fp)
 8232558:	1080080c 	andi	r2,r2,32
      {
         space = (int)sbspace(&so->so_snd);
         if ((sosendallatonce(so) && (space < resid)) ||
             ((resid >= CLBYTES) && (space < CLBYTES) &&
              (so->so_snd.sb_cc >= CLBYTES) &&
              ((so->so_state & SS_NBIO) == 0) &&
 823255c:	10001d1e 	bne	r2,zero,82325d4 <sosend+0x2c8>
              ((flags & MSG_DONTWAIT) == 0)))
         {
            if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 8232560:	e0bffc17 	ldw	r2,-16(fp)
 8232564:	1080088b 	ldhu	r2,34(r2)
 8232568:	10bfffcc 	andi	r2,r2,65535
 823256c:	1080400c 	andi	r2,r2,256
 8232570:	1000031e 	bne	r2,zero,8232580 <sosend+0x274>
 8232574:	e0800217 	ldw	r2,8(fp)
 8232578:	1080080c 	andi	r2,r2,32
 823257c:	10000526 	beq	r2,zero,8232594 <sosend+0x288>
            {
               if (first)
 8232580:	e0bff917 	ldw	r2,-28(fp)
 8232584:	10009d26 	beq	r2,zero,82327fc <sosend+0x4f0>
                  error = EWOULDBLOCK;
 8232588:	008002c4 	movi	r2,11
 823258c:	e0bff815 	stw	r2,-32(fp)
               goto release;
 8232590:	00009a06 	br	82327fc <sosend+0x4f0>
            }
            sbunlock(&so->so_snd);
 8232594:	e0bffc17 	ldw	r2,-16(fp)
 8232598:	10c0190b 	ldhu	r3,100(r2)
 823259c:	00bfff84 	movi	r2,-2
 82325a0:	1884703a 	and	r2,r3,r2
 82325a4:	1007883a 	mov	r3,r2
 82325a8:	e0bffc17 	ldw	r2,-16(fp)
 82325ac:	10c0190d 	sth	r3,100(r2)
 82325b0:	e0bffc17 	ldw	r2,-16(fp)
 82325b4:	10801904 	addi	r2,r2,100
 82325b8:	1009883a 	mov	r4,r2
 82325bc:	82296a80 	call	82296a8 <tcp_wakeup>
            sbwait(&so->so_snd);
 82325c0:	e0bffc17 	ldw	r2,-16(fp)
 82325c4:	10801204 	addi	r2,r2,72
 82325c8:	1009883a 	mov	r4,r2
 82325cc:	82341d80 	call	82341d8 <sbwait>
            goto restart;
 82325d0:	003f7f06 	br	82323d0 <sosend+0xc4>
         }
      }
      if ( space <= 0 ) 
 82325d4:	e0bff617 	ldw	r2,-40(fp)
 82325d8:	00805e16 	blt	zero,r2,8232754 <sosend+0x448>
      {
         /* no space in socket send buffer - see if we can wait */
         if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 82325dc:	e0bffc17 	ldw	r2,-16(fp)
 82325e0:	1080088b 	ldhu	r2,34(r2)
 82325e4:	10bfffcc 	andi	r2,r2,65535
 82325e8:	1080400c 	andi	r2,r2,256
 82325ec:	1000031e 	bne	r2,zero,82325fc <sosend+0x2f0>
 82325f0:	e0800217 	ldw	r2,8(fp)
 82325f4:	1080080c 	andi	r2,r2,32
 82325f8:	10000526 	beq	r2,zero,8232610 <sosend+0x304>
         {
            if (first)     /* report first error */
 82325fc:	e0bff917 	ldw	r2,-28(fp)
 8232600:	10008026 	beq	r2,zero,8232804 <sosend+0x4f8>
               error = EWOULDBLOCK;
 8232604:	008002c4 	movi	r2,11
 8232608:	e0bff815 	stw	r2,-32(fp)
            goto release;
 823260c:	00007d06 	br	8232804 <sosend+0x4f8>
         }
         /* If blocking socket, let someone else run */
         sbunlock(&so->so_snd);
 8232610:	e0bffc17 	ldw	r2,-16(fp)
 8232614:	10c0190b 	ldhu	r3,100(r2)
 8232618:	00bfff84 	movi	r2,-2
 823261c:	1884703a 	and	r2,r3,r2
 8232620:	1007883a 	mov	r3,r2
 8232624:	e0bffc17 	ldw	r2,-16(fp)
 8232628:	10c0190d 	sth	r3,100(r2)
 823262c:	e0bffc17 	ldw	r2,-16(fp)
 8232630:	10801904 	addi	r2,r2,100
 8232634:	1009883a 	mov	r4,r2
 8232638:	82296a80 	call	82296a8 <tcp_wakeup>
         sbwait(&so->so_snd);
 823263c:	e0bffc17 	ldw	r2,-16(fp)
 8232640:	10801204 	addi	r2,r2,72
 8232644:	1009883a 	mov	r4,r2
 8232648:	82341d80 	call	82341d8 <sbwait>
         goto restart;
 823264c:	003f6006 	br	82323d0 <sosend+0xc4>
      }

      while (space > 0) 
      {
         len = resid;
 8232650:	e0bff717 	ldw	r2,-36(fp)
 8232654:	e0bffb15 	stw	r2,-20(fp)
         if ( so->so_type == SOCK_STREAM )
 8232658:	e0bffc17 	ldw	r2,-16(fp)
 823265c:	10800983 	ldbu	r2,38(r2)
 8232660:	10803fcc 	andi	r2,r2,255
 8232664:	1080201c 	xori	r2,r2,128
 8232668:	10bfe004 	addi	r2,r2,-128
 823266c:	10800058 	cmpnei	r2,r2,1
 8232670:	1000171e 	bne	r2,zero,82326d0 <sosend+0x3c4>
         {
            m = m_getwithdata(MT_TXDATA, len);
 8232674:	e17ffb17 	ldw	r5,-20(fp)
 8232678:	01000084 	movi	r4,2
 823267c:	822e3a80 	call	822e3a8 <m_getnbuf>
 8232680:	e0bff515 	stw	r2,-44(fp)
            if (!m)   
 8232684:	e0bff517 	ldw	r2,-44(fp)
 8232688:	1000031e 	bne	r2,zero,8232698 <sosend+0x38c>
               snderr(ENOBUFS);
 823268c:	00801a44 	movi	r2,105
 8232690:	e0bff815 	stw	r2,-32(fp)
 8232694:	00005e06 	br	8232810 <sosend+0x504>
            MEMCPY(m->m_data, data, len);
 8232698:	e0bff517 	ldw	r2,-44(fp)
 823269c:	10800317 	ldw	r2,12(r2)
 82326a0:	e0fffb17 	ldw	r3,-20(fp)
 82326a4:	180d883a 	mov	r6,r3
 82326a8:	e17ffe17 	ldw	r5,-8(fp)
 82326ac:	1009883a 	mov	r4,r2
 82326b0:	8202f100 	call	8202f10 <memcpy>
            so->so_snd.sb_flags |= SB_MBCOMP;   /* allow compression */
 82326b4:	e0bffc17 	ldw	r2,-16(fp)
 82326b8:	1080190b 	ldhu	r2,100(r2)
 82326bc:	10802014 	ori	r2,r2,128
 82326c0:	1007883a 	mov	r3,r2
 82326c4:	e0bffc17 	ldw	r2,-16(fp)
 82326c8:	10c0190d 	sth	r3,100(r2)
 82326cc:	00000706 	br	82326ec <sosend+0x3e0>
         }
         else
         {
            m = m_get (M_WAIT, MT_TXDATA);
 82326d0:	000b883a 	mov	r5,zero
 82326d4:	01000084 	movi	r4,2
 82326d8:	822e3a80 	call	822e3a8 <m_getnbuf>
 82326dc:	e0bff515 	stw	r2,-44(fp)
            m->m_data = data;
 82326e0:	e0bff517 	ldw	r2,-44(fp)
 82326e4:	e0fffe17 	ldw	r3,-8(fp)
 82326e8:	10c00315 	stw	r3,12(r2)
         }
         INET_TRACE (INETM_IO,
          ("sosend:got %d bytes so %lx mlen %d, off %d mtod %x\n",
             len, so, m->m_len, m->m_off, mtod (m, caddr_t)));

         *data_length -= len;
 82326ec:	e0bfff17 	ldw	r2,-4(fp)
 82326f0:	10c00017 	ldw	r3,0(r2)
 82326f4:	e0bffb17 	ldw	r2,-20(fp)
 82326f8:	1887c83a 	sub	r3,r3,r2
 82326fc:	e0bfff17 	ldw	r2,-4(fp)
 8232700:	10c00015 	stw	r3,0(r2)
         resid -= len;
 8232704:	e0fff717 	ldw	r3,-36(fp)
 8232708:	e0bffb17 	ldw	r2,-20(fp)
 823270c:	1885c83a 	sub	r2,r3,r2
 8232710:	e0bff715 	stw	r2,-36(fp)
         data += len;
 8232714:	e0bffb17 	ldw	r2,-20(fp)
 8232718:	e0fffe17 	ldw	r3,-8(fp)
 823271c:	1885883a 	add	r2,r3,r2
 8232720:	e0bffe15 	stw	r2,-8(fp)
         m->m_len = len;
 8232724:	e0fffb17 	ldw	r3,-20(fp)
 8232728:	e0bff517 	ldw	r2,-44(fp)
 823272c:	10c00215 	stw	r3,8(r2)
         if (head == (struct mbuf *)NULL)
 8232730:	e0bff417 	ldw	r2,-48(fp)
 8232734:	1000021e 	bne	r2,zero,8232740 <sosend+0x434>
            head = m;
 8232738:	e0bff517 	ldw	r2,-44(fp)
 823273c:	e0bff415 	stw	r2,-48(fp)
         if (error)
 8232740:	e0bff817 	ldw	r2,-32(fp)
 8232744:	1000311e 	bne	r2,zero,823280c <sosend+0x500>
            goto release;
         if (*data_length <= 0)
 8232748:	e0bfff17 	ldw	r2,-4(fp)
 823274c:	10800017 	ldw	r2,0(r2)
 8232750:	0080030e 	bge	zero,r2,8232760 <sosend+0x454>
         sbunlock(&so->so_snd);
         sbwait(&so->so_snd);
         goto restart;
      }

      while (space > 0) 
 8232754:	e0bff617 	ldw	r2,-40(fp)
 8232758:	00bfbd16 	blt	zero,r2,8232650 <sosend+0x344>
 823275c:	00000106 	br	8232764 <sosend+0x458>
         if (head == (struct mbuf *)NULL)
            head = m;
         if (error)
            goto release;
         if (*data_length <= 0)
            break;
 8232760:	0001883a 	nop
      }

      if (dontroute)
 8232764:	e0bffa17 	ldw	r2,-24(fp)
 8232768:	10000526 	beq	r2,zero,8232780 <sosend+0x474>
         so->so_options |= SO_DONTROUTE;
 823276c:	e0bffc17 	ldw	r2,-16(fp)
 8232770:	10800417 	ldw	r2,16(r2)
 8232774:	10c00414 	ori	r3,r2,16
 8232778:	e0bffc17 	ldw	r2,-16(fp)
 823277c:	10c00415 	stw	r3,16(r2)

      so->so_req = (flags & MSG_OOB) ? PRU_SENDOOB : PRU_SEND;
 8232780:	e0800217 	ldw	r2,8(fp)
 8232784:	1080004c 	andi	r2,r2,1
 8232788:	10000226 	beq	r2,zero,8232794 <sosend+0x488>
 823278c:	00800384 	movi	r2,14
 8232790:	00000106 	br	8232798 <sosend+0x48c>
 8232794:	00800244 	movi	r2,9
 8232798:	e0fffc17 	ldw	r3,-16(fp)
 823279c:	18800715 	stw	r2,28(r3)
      error = (*so->so_proto->pr_usrreq)(so, head, nam);
 82327a0:	e0bffc17 	ldw	r2,-16(fp)
 82327a4:	10800217 	ldw	r2,8(r2)
 82327a8:	10800317 	ldw	r2,12(r2)
 82327ac:	e1bffd17 	ldw	r6,-12(fp)
 82327b0:	e17ff417 	ldw	r5,-48(fp)
 82327b4:	e13ffc17 	ldw	r4,-16(fp)
 82327b8:	103ee83a 	callr	r2
 82327bc:	e0bff815 	stw	r2,-32(fp)

      if (dontroute)
 82327c0:	e0bffa17 	ldw	r2,-24(fp)
 82327c4:	10000626 	beq	r2,zero,82327e0 <sosend+0x4d4>
         so->so_options &= ~SO_DONTROUTE;
 82327c8:	e0bffc17 	ldw	r2,-16(fp)
 82327cc:	10c00417 	ldw	r3,16(r2)
 82327d0:	00bffbc4 	movi	r2,-17
 82327d4:	1886703a 	and	r3,r3,r2
 82327d8:	e0bffc17 	ldw	r2,-16(fp)
 82327dc:	10c00415 	stw	r3,16(r2)

      head = (struct mbuf *)NULL;
 82327e0:	e03ff415 	stw	zero,-48(fp)
      first = 0;
 82327e4:	e03ff915 	stw	zero,-28(fp)
   } while ((resid != 0) && (error == 0));
 82327e8:	e0bff717 	ldw	r2,-36(fp)
 82327ec:	10000826 	beq	r2,zero,8232810 <sosend+0x504>
 82327f0:	e0bff817 	ldw	r2,-32(fp)
 82327f4:	103f0626 	beq	r2,zero,8232410 <sosend+0x104>
 82327f8:	00000506 	br	8232810 <sosend+0x504>
         {
            if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
            {
               if (first)
                  error = EWOULDBLOCK;
               goto release;
 82327fc:	0001883a 	nop
 8232800:	00000306 	br	8232810 <sosend+0x504>
         /* no space in socket send buffer - see if we can wait */
         if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
         {
            if (first)     /* report first error */
               error = EWOULDBLOCK;
            goto release;
 8232804:	0001883a 	nop
 8232808:	00000106 	br	8232810 <sosend+0x504>
         data += len;
         m->m_len = len;
         if (head == (struct mbuf *)NULL)
            head = m;
         if (error)
            goto release;
 823280c:	0001883a 	nop
      head = (struct mbuf *)NULL;
      first = 0;
   } while ((resid != 0) && (error == 0));

release:
   sbunlock(&so->so_snd);  
 8232810:	e0bffc17 	ldw	r2,-16(fp)
 8232814:	10c0190b 	ldhu	r3,100(r2)
 8232818:	00bfff84 	movi	r2,-2
 823281c:	1884703a 	and	r2,r3,r2
 8232820:	1007883a 	mov	r3,r2
 8232824:	e0bffc17 	ldw	r2,-16(fp)
 8232828:	10c0190d 	sth	r3,100(r2)
 823282c:	e0bffc17 	ldw	r2,-16(fp)
 8232830:	10801904 	addi	r2,r2,100
 8232834:	1009883a 	mov	r4,r2
 8232838:	82296a80 	call	82296a8 <tcp_wakeup>
   if (head)
 823283c:	e0bff417 	ldw	r2,-48(fp)
 8232840:	10000226 	beq	r2,zero,823284c <sosend+0x540>
      m_freem(head);
 8232844:	e13ff417 	ldw	r4,-48(fp)
 8232848:	822e6380 	call	822e638 <m_freem>
   return error;
 823284c:	e0bff817 	ldw	r2,-32(fp)
}
 8232850:	e037883a 	mov	sp,fp
 8232854:	dfc00117 	ldw	ra,4(sp)
 8232858:	df000017 	ldw	fp,0(sp)
 823285c:	dec00204 	addi	sp,sp,8
 8232860:	f800283a 	ret

08232864 <soreceive>:
soreceive(struct socket * so, 
   struct mbuf **aname,
   char * data,
   int * datalen,
   int   flags)
{
 8232864:	defff204 	addi	sp,sp,-56
 8232868:	dfc00d15 	stw	ra,52(sp)
 823286c:	df000c15 	stw	fp,48(sp)
 8232870:	df000c04 	addi	fp,sp,48
 8232874:	e13ffc15 	stw	r4,-16(fp)
 8232878:	e17ffd15 	stw	r5,-12(fp)
 823287c:	e1bffe15 	stw	r6,-8(fp)
 8232880:	e1ffff15 	stw	r7,-4(fp)
   struct mbuf *  m;
   int   len;
   int   error =  0;
 8232884:	e03ff615 	stw	zero,-40(fp)
   int   offset;
   struct protosw *  pr =  so->so_proto;
 8232888:	e0bffc17 	ldw	r2,-16(fp)
 823288c:	10800217 	ldw	r2,8(r2)
 8232890:	e0bffa15 	stw	r2,-24(fp)
   struct mbuf *  nextrecord;
   int   moff;
   int   lflags;

   if (aname)
 8232894:	e0bffd17 	ldw	r2,-12(fp)
 8232898:	10000226 	beq	r2,zero,82328a4 <soreceive+0x40>
      *aname = 0;
 823289c:	e0bffd17 	ldw	r2,-12(fp)
 82328a0:	10000015 	stw	zero,0(r2)
   if (flags & MSG_OOB) 
 82328a4:	e0800217 	ldw	r2,8(fp)
 82328a8:	1080004c 	andi	r2,r2,1
 82328ac:	10004626 	beq	r2,zero,82329c8 <soreceive+0x164>
   {
      m = m_get (M_WAIT, MT_RXDATA);
 82328b0:	000b883a 	mov	r5,zero
 82328b4:	01000044 	movi	r4,1
 82328b8:	822e3a80 	call	822e3a8 <m_getnbuf>
 82328bc:	e0bff415 	stw	r2,-48(fp)
      if (m == NULL)
 82328c0:	e0bff417 	ldw	r2,-48(fp)
 82328c4:	1000021e 	bne	r2,zero,82328d0 <soreceive+0x6c>
         return ENOBUFS;
 82328c8:	00801a44 	movi	r2,105
 82328cc:	0001b306 	br	8232f9c <soreceive+0x738>
      lflags = flags & MSG_PEEK;
 82328d0:	e0800217 	ldw	r2,8(fp)
 82328d4:	1080008c 	andi	r2,r2,2
 82328d8:	e0bffb15 	stw	r2,-20(fp)

      so->so_req = PRU_RCVOOB;
 82328dc:	e0bffc17 	ldw	r2,-16(fp)
 82328e0:	00c00344 	movi	r3,13
 82328e4:	10c00715 	stw	r3,28(r2)
      error = (*pr->pr_usrreq)(so, m, LONG2MBUF((long)lflags));
 82328e8:	e0bffa17 	ldw	r2,-24(fp)
 82328ec:	10800317 	ldw	r2,12(r2)
 82328f0:	e0fffb17 	ldw	r3,-20(fp)
 82328f4:	180d883a 	mov	r6,r3
 82328f8:	e17ff417 	ldw	r5,-48(fp)
 82328fc:	e13ffc17 	ldw	r4,-16(fp)
 8232900:	103ee83a 	callr	r2
 8232904:	e0bff615 	stw	r2,-40(fp)
      if (error == 0)
 8232908:	e0bff617 	ldw	r2,-40(fp)
 823290c:	1000231e 	bne	r2,zero,823299c <soreceive+0x138>
      {
         do 
         {
            len = *datalen;
 8232910:	e0bfff17 	ldw	r2,-4(fp)
 8232914:	10800017 	ldw	r2,0(r2)
 8232918:	e0bff515 	stw	r2,-44(fp)
            if (len > (int)m->m_len)
 823291c:	e0bff417 	ldw	r2,-48(fp)
 8232920:	10800217 	ldw	r2,8(r2)
 8232924:	1007883a 	mov	r3,r2
 8232928:	e0bff517 	ldw	r2,-44(fp)
 823292c:	1880030e 	bge	r3,r2,823293c <soreceive+0xd8>
               len = m->m_len;
 8232930:	e0bff417 	ldw	r2,-48(fp)
 8232934:	10800217 	ldw	r2,8(r2)
 8232938:	e0bff515 	stw	r2,-44(fp)

            MEMCPY(data, mtod(m, char*), len);
 823293c:	e0bff417 	ldw	r2,-48(fp)
 8232940:	10800317 	ldw	r2,12(r2)
 8232944:	e0fff517 	ldw	r3,-44(fp)
 8232948:	180d883a 	mov	r6,r3
 823294c:	100b883a 	mov	r5,r2
 8232950:	e13ffe17 	ldw	r4,-8(fp)
 8232954:	8202f100 	call	8202f10 <memcpy>
            data += len;
 8232958:	e0bff517 	ldw	r2,-44(fp)
 823295c:	e0fffe17 	ldw	r3,-8(fp)
 8232960:	1885883a 	add	r2,r3,r2
 8232964:	e0bffe15 	stw	r2,-8(fp)
            *datalen = len;
 8232968:	e0bfff17 	ldw	r2,-4(fp)
 823296c:	e0fff517 	ldw	r3,-44(fp)
 8232970:	10c00015 	stw	r3,0(r2)
            m = m_free(m);
 8232974:	e13ff417 	ldw	r4,-48(fp)
 8232978:	822e5300 	call	822e530 <m_free>
 823297c:	e0bff415 	stw	r2,-48(fp)
         } while (*datalen && (error == 0) && m);
 8232980:	e0bfff17 	ldw	r2,-4(fp)
 8232984:	10800017 	ldw	r2,0(r2)
 8232988:	10000426 	beq	r2,zero,823299c <soreceive+0x138>
 823298c:	e0bff617 	ldw	r2,-40(fp)
 8232990:	1000021e 	bne	r2,zero,823299c <soreceive+0x138>
 8232994:	e0bff417 	ldw	r2,-48(fp)
 8232998:	103fdd1e 	bne	r2,zero,8232910 <soreceive+0xac>
      }

      if (m)
 823299c:	e0bff417 	ldw	r2,-48(fp)
 82329a0:	10000226 	beq	r2,zero,82329ac <soreceive+0x148>
         m_freem(m);
 82329a4:	e13ff417 	ldw	r4,-48(fp)
 82329a8:	822e6380 	call	822e638 <m_freem>
      return (error);
 82329ac:	e0bff617 	ldw	r2,-40(fp)
 82329b0:	00017a06 	br	8232f9c <soreceive+0x738>
   }

restart:
   sblock (&so->so_rcv);
 82329b4:	00000406 	br	82329c8 <soreceive+0x164>
 82329b8:	e0bffc17 	ldw	r2,-16(fp)
 82329bc:	10801104 	addi	r2,r2,68
 82329c0:	1009883a 	mov	r4,r2
 82329c4:	82295340 	call	8229534 <tcp_sleep>
 82329c8:	e0bffc17 	ldw	r2,-16(fp)
 82329cc:	1080110b 	ldhu	r2,68(r2)
 82329d0:	10bfffcc 	andi	r2,r2,65535
 82329d4:	1080004c 	andi	r2,r2,1
 82329d8:	103ff71e 	bne	r2,zero,82329b8 <soreceive+0x154>
 82329dc:	e0bffc17 	ldw	r2,-16(fp)
 82329e0:	1080110b 	ldhu	r2,68(r2)
 82329e4:	10800054 	ori	r2,r2,1
 82329e8:	1007883a 	mov	r3,r2
 82329ec:	e0bffc17 	ldw	r2,-16(fp)
 82329f0:	10c0110d 	sth	r3,68(r2)
   INET_TRACE (INETM_IO,
    ("INET:soreceive sbcc %d soerror %d so_state %d *datalen %d\n",
    so->so_rcv.sb_cc, so->so_error, so->so_state, *datalen));

   /* If no data is ready, see if we should wait or return */
   if (so->so_rcv.sb_cc == 0) 
 82329f4:	e0bffc17 	ldw	r2,-16(fp)
 82329f8:	10800a17 	ldw	r2,40(r2)
 82329fc:	10003a1e 	bne	r2,zero,8232ae8 <soreceive+0x284>
   {
      if (so->so_error) 
 8232a00:	e0bffc17 	ldw	r2,-16(fp)
 8232a04:	10800617 	ldw	r2,24(r2)
 8232a08:	10000626 	beq	r2,zero,8232a24 <soreceive+0x1c0>
      {
         error = so->so_error;
 8232a0c:	e0bffc17 	ldw	r2,-16(fp)
 8232a10:	10800617 	ldw	r2,24(r2)
 8232a14:	e0bff615 	stw	r2,-40(fp)
         so->so_error = 0;
 8232a18:	e0bffc17 	ldw	r2,-16(fp)
 8232a1c:	10000615 	stw	zero,24(r2)
         goto release;
 8232a20:	00015206 	br	8232f6c <soreceive+0x708>
      }
      if (so->so_state & SS_CANTRCVMORE)
 8232a24:	e0bffc17 	ldw	r2,-16(fp)
 8232a28:	1080088b 	ldhu	r2,34(r2)
 8232a2c:	10bfffcc 	andi	r2,r2,65535
 8232a30:	1080080c 	andi	r2,r2,32
 8232a34:	10014a1e 	bne	r2,zero,8232f60 <soreceive+0x6fc>
         goto release;
      if ((so->so_state & SS_ISCONNECTED) == 0 &&
 8232a38:	e0bffc17 	ldw	r2,-16(fp)
 8232a3c:	1080088b 	ldhu	r2,34(r2)
 8232a40:	10bfffcc 	andi	r2,r2,65535
 8232a44:	1080008c 	andi	r2,r2,2
 8232a48:	1000091e 	bne	r2,zero,8232a70 <soreceive+0x20c>
          (so->so_proto->pr_flags & PR_CONNREQUIRED)) 
 8232a4c:	e0bffc17 	ldw	r2,-16(fp)
 8232a50:	10800217 	ldw	r2,8(r2)
 8232a54:	1080010b 	ldhu	r2,4(r2)
 8232a58:	10bfffcc 	andi	r2,r2,65535
 8232a5c:	1080010c 	andi	r2,r2,4
         so->so_error = 0;
         goto release;
      }
      if (so->so_state & SS_CANTRCVMORE)
         goto release;
      if ((so->so_state & SS_ISCONNECTED) == 0 &&
 8232a60:	10000326 	beq	r2,zero,8232a70 <soreceive+0x20c>
          (so->so_proto->pr_flags & PR_CONNREQUIRED)) 
      {
         error = ENOTCONN;
 8232a64:	00802004 	movi	r2,128
 8232a68:	e0bff615 	stw	r2,-40(fp)
         goto release;
 8232a6c:	00013f06 	br	8232f6c <soreceive+0x708>
      }
      if (*datalen == 0)
 8232a70:	e0bfff17 	ldw	r2,-4(fp)
 8232a74:	10800017 	ldw	r2,0(r2)
 8232a78:	10013b26 	beq	r2,zero,8232f68 <soreceive+0x704>
         goto release;
      if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT)) 
 8232a7c:	e0bffc17 	ldw	r2,-16(fp)
 8232a80:	1080088b 	ldhu	r2,34(r2)
 8232a84:	10bfffcc 	andi	r2,r2,65535
 8232a88:	1080400c 	andi	r2,r2,256
 8232a8c:	1000031e 	bne	r2,zero,8232a9c <soreceive+0x238>
 8232a90:	e0800217 	ldw	r2,8(fp)
 8232a94:	1080080c 	andi	r2,r2,32
 8232a98:	10000326 	beq	r2,zero,8232aa8 <soreceive+0x244>
      {
         error = EWOULDBLOCK;
 8232a9c:	008002c4 	movi	r2,11
 8232aa0:	e0bff615 	stw	r2,-40(fp)
         goto release;
 8232aa4:	00013106 	br	8232f6c <soreceive+0x708>
      }
      sbunlock(&so->so_rcv);
 8232aa8:	e0bffc17 	ldw	r2,-16(fp)
 8232aac:	10c0110b 	ldhu	r3,68(r2)
 8232ab0:	00bfff84 	movi	r2,-2
 8232ab4:	1884703a 	and	r2,r3,r2
 8232ab8:	1007883a 	mov	r3,r2
 8232abc:	e0bffc17 	ldw	r2,-16(fp)
 8232ac0:	10c0110d 	sth	r3,68(r2)
 8232ac4:	e0bffc17 	ldw	r2,-16(fp)
 8232ac8:	10801104 	addi	r2,r2,68
 8232acc:	1009883a 	mov	r4,r2
 8232ad0:	82296a80 	call	82296a8 <tcp_wakeup>
      sbwait(&so->so_rcv);
 8232ad4:	e0bffc17 	ldw	r2,-16(fp)
 8232ad8:	10800a04 	addi	r2,r2,40
 8232adc:	1009883a 	mov	r4,r2
 8232ae0:	82341d80 	call	82341d8 <sbwait>
      goto restart;
 8232ae4:	003fb306 	br	82329b4 <soreceive+0x150>
   }
   m = so->so_rcv.sb_mb;
 8232ae8:	e0bffc17 	ldw	r2,-16(fp)
 8232aec:	10801017 	ldw	r2,64(r2)
 8232af0:	e0bff415 	stw	r2,-48(fp)
   if (m == 0)
 8232af4:	e0bff417 	ldw	r2,-48(fp)
 8232af8:	1000031e 	bne	r2,zero,8232b08 <soreceive+0x2a4>
      panic("sorecv 1");
 8232afc:	01020974 	movhi	r4,2085
 8232b00:	21037b04 	addi	r4,r4,3564
 8232b04:	8228c480 	call	8228c48 <panic>
   nextrecord = m->m_act;
 8232b08:	e0bff417 	ldw	r2,-48(fp)
 8232b0c:	10800717 	ldw	r2,28(r2)
 8232b10:	e0bff815 	stw	r2,-32(fp)
   if (pr->pr_flags & PR_ADDR) 
 8232b14:	e0bffa17 	ldw	r2,-24(fp)
 8232b18:	1080010b 	ldhu	r2,4(r2)
 8232b1c:	10bfffcc 	andi	r2,r2,65535
 8232b20:	1080008c 	andi	r2,r2,2
 8232b24:	10004226 	beq	r2,zero,8232c30 <soreceive+0x3cc>
   {
      if (m->m_type != MT_SONAME) 
 8232b28:	e0bff417 	ldw	r2,-48(fp)
 8232b2c:	10800817 	ldw	r2,32(r2)
 8232b30:	10800260 	cmpeqi	r2,r2,9
 8232b34:	1000091e 	bne	r2,zero,8232b5c <soreceive+0x2f8>
      {
         dprintf ("sorecv:type %d not nam", m->m_type);
 8232b38:	e0bff417 	ldw	r2,-48(fp)
 8232b3c:	10800817 	ldw	r2,32(r2)
 8232b40:	100b883a 	mov	r5,r2
 8232b44:	01020974 	movhi	r4,2085
 8232b48:	21037e04 	addi	r4,r4,3576
 8232b4c:	82033a00 	call	82033a0 <printf>
         panic("sorecv 2");
 8232b50:	01020974 	movhi	r4,2085
 8232b54:	21038404 	addi	r4,r4,3600
 8232b58:	8228c480 	call	8228c48 <panic>
      }
      if (flags & MSG_PEEK) 
 8232b5c:	e0800217 	ldw	r2,8(fp)
 8232b60:	1080008c 	andi	r2,r2,2
 8232b64:	10000f26 	beq	r2,zero,8232ba4 <soreceive+0x340>
      {
         if (aname)
 8232b68:	e0bffd17 	ldw	r2,-12(fp)
 8232b6c:	10000926 	beq	r2,zero,8232b94 <soreceive+0x330>
            *aname = m_copy (m, 0, m->m_len);
 8232b70:	e0bff417 	ldw	r2,-48(fp)
 8232b74:	10800217 	ldw	r2,8(r2)
 8232b78:	100d883a 	mov	r6,r2
 8232b7c:	000b883a 	mov	r5,zero
 8232b80:	e13ff417 	ldw	r4,-48(fp)
 8232b84:	822e67c0 	call	822e67c <m_copy>
 8232b88:	1007883a 	mov	r3,r2
 8232b8c:	e0bffd17 	ldw	r2,-12(fp)
 8232b90:	10c00015 	stw	r3,0(r2)
         m = m->m_next;
 8232b94:	e0bff417 	ldw	r2,-48(fp)
 8232b98:	10800617 	ldw	r2,24(r2)
 8232b9c:	e0bff415 	stw	r2,-48(fp)
 8232ba0:	00002306 	br	8232c30 <soreceive+0x3cc>
      } else 
      {
         sbfree (&so->so_rcv, m);
 8232ba4:	e0bffc17 	ldw	r2,-16(fp)
 8232ba8:	10c00a17 	ldw	r3,40(r2)
 8232bac:	e0bff417 	ldw	r2,-48(fp)
 8232bb0:	10800217 	ldw	r2,8(r2)
 8232bb4:	1887c83a 	sub	r3,r3,r2
 8232bb8:	e0bffc17 	ldw	r2,-16(fp)
 8232bbc:	10c00a15 	stw	r3,40(r2)
         if (aname) 
 8232bc0:	e0bffd17 	ldw	r2,-12(fp)
 8232bc4:	10000d26 	beq	r2,zero,8232bfc <soreceive+0x398>
         {
            *aname = m;
 8232bc8:	e0bffd17 	ldw	r2,-12(fp)
 8232bcc:	e0fff417 	ldw	r3,-48(fp)
 8232bd0:	10c00015 	stw	r3,0(r2)
            m = m->m_next;
 8232bd4:	e0bff417 	ldw	r2,-48(fp)
 8232bd8:	10800617 	ldw	r2,24(r2)
 8232bdc:	e0bff415 	stw	r2,-48(fp)
            (*aname)->m_next = 0;
 8232be0:	e0bffd17 	ldw	r2,-12(fp)
 8232be4:	10800017 	ldw	r2,0(r2)
 8232be8:	10000615 	stw	zero,24(r2)
            so->so_rcv.sb_mb = m;
 8232bec:	e0bffc17 	ldw	r2,-16(fp)
 8232bf0:	e0fff417 	ldw	r3,-48(fp)
 8232bf4:	10c01015 	stw	r3,64(r2)
 8232bf8:	00000806 	br	8232c1c <soreceive+0x3b8>
         } else 
         {
            MFREE(m, so->so_rcv.sb_mb);
 8232bfc:	e13ff417 	ldw	r4,-48(fp)
 8232c00:	822e5300 	call	822e530 <m_free>
 8232c04:	1007883a 	mov	r3,r2
 8232c08:	e0bffc17 	ldw	r2,-16(fp)
 8232c0c:	10c01015 	stw	r3,64(r2)
            m = so->so_rcv.sb_mb;
 8232c10:	e0bffc17 	ldw	r2,-16(fp)
 8232c14:	10801017 	ldw	r2,64(r2)
 8232c18:	e0bff415 	stw	r2,-48(fp)
         }
         if (m)
 8232c1c:	e0bff417 	ldw	r2,-48(fp)
 8232c20:	10000326 	beq	r2,zero,8232c30 <soreceive+0x3cc>
            m->m_act = nextrecord;
 8232c24:	e0bff417 	ldw	r2,-48(fp)
 8232c28:	e0fff817 	ldw	r3,-32(fp)
 8232c2c:	10c00715 	stw	r3,28(r2)
      }
   }
   moff = 0;
 8232c30:	e03ff915 	stw	zero,-28(fp)
   offset = 0;
 8232c34:	e03ff715 	stw	zero,-36(fp)
   while (m && (*datalen > 0) && (error == 0))
 8232c38:	00009e06 	br	8232eb4 <soreceive+0x650>
   {
      if (m->m_type != MT_RXDATA && m->m_type != MT_HEADER)
 8232c3c:	e0bff417 	ldw	r2,-48(fp)
 8232c40:	10800817 	ldw	r2,32(r2)
 8232c44:	10800060 	cmpeqi	r2,r2,1
 8232c48:	1000071e 	bne	r2,zero,8232c68 <soreceive+0x404>
 8232c4c:	e0bff417 	ldw	r2,-48(fp)
 8232c50:	10800817 	ldw	r2,32(r2)
 8232c54:	108000e0 	cmpeqi	r2,r2,3
 8232c58:	1000031e 	bne	r2,zero,8232c68 <soreceive+0x404>
         panic("sorecv 3");
 8232c5c:	01020974 	movhi	r4,2085
 8232c60:	21038704 	addi	r4,r4,3612
 8232c64:	8228c480 	call	8228c48 <panic>
      len = *datalen;
 8232c68:	e0bfff17 	ldw	r2,-4(fp)
 8232c6c:	10800017 	ldw	r2,0(r2)
 8232c70:	e0bff515 	stw	r2,-44(fp)
      so->so_state &= ~SS_RCVATMARK;
 8232c74:	e0bffc17 	ldw	r2,-16(fp)
 8232c78:	10c0088b 	ldhu	r3,34(r2)
 8232c7c:	00bfefc4 	movi	r2,-65
 8232c80:	1884703a 	and	r2,r3,r2
 8232c84:	1007883a 	mov	r3,r2
 8232c88:	e0bffc17 	ldw	r2,-16(fp)
 8232c8c:	10c0088d 	sth	r3,34(r2)
      if (so->so_oobmark && (len > (int)(so->so_oobmark - offset)))
 8232c90:	e0bffc17 	ldw	r2,-16(fp)
 8232c94:	10801a17 	ldw	r2,104(r2)
 8232c98:	10000c26 	beq	r2,zero,8232ccc <soreceive+0x468>
 8232c9c:	e0bffc17 	ldw	r2,-16(fp)
 8232ca0:	10c01a17 	ldw	r3,104(r2)
 8232ca4:	e0bff717 	ldw	r2,-36(fp)
 8232ca8:	1885c83a 	sub	r2,r3,r2
 8232cac:	1007883a 	mov	r3,r2
 8232cb0:	e0bff517 	ldw	r2,-44(fp)
 8232cb4:	1880050e 	bge	r3,r2,8232ccc <soreceive+0x468>
         len = (int)(so->so_oobmark - offset);
 8232cb8:	e0bffc17 	ldw	r2,-16(fp)
 8232cbc:	10c01a17 	ldw	r3,104(r2)
 8232cc0:	e0bff717 	ldw	r2,-36(fp)
 8232cc4:	1885c83a 	sub	r2,r3,r2
 8232cc8:	e0bff515 	stw	r2,-44(fp)
      if (len > (int)(m->m_len - moff))
 8232ccc:	e0bff417 	ldw	r2,-48(fp)
 8232cd0:	10c00217 	ldw	r3,8(r2)
 8232cd4:	e0bff917 	ldw	r2,-28(fp)
 8232cd8:	1885c83a 	sub	r2,r3,r2
 8232cdc:	1007883a 	mov	r3,r2
 8232ce0:	e0bff517 	ldw	r2,-44(fp)
 8232ce4:	1880050e 	bge	r3,r2,8232cfc <soreceive+0x498>
         len = m->m_len - moff;
 8232ce8:	e0bff417 	ldw	r2,-48(fp)
 8232cec:	10c00217 	ldw	r3,8(r2)
 8232cf0:	e0bff917 	ldw	r2,-28(fp)
 8232cf4:	1885c83a 	sub	r2,r3,r2
 8232cf8:	e0bff515 	stw	r2,-44(fp)
       * it points to next record) when we drop priority;
       * we must note any additions to the sockbuf when we
       * block interrupts again.
       */

      MEMCPY(data, (mtod(m, char *) + moff), len);
 8232cfc:	e0bff417 	ldw	r2,-48(fp)
 8232d00:	10c00317 	ldw	r3,12(r2)
 8232d04:	e0bff917 	ldw	r2,-28(fp)
 8232d08:	1885883a 	add	r2,r3,r2
 8232d0c:	e0fff517 	ldw	r3,-44(fp)
 8232d10:	180d883a 	mov	r6,r3
 8232d14:	100b883a 	mov	r5,r2
 8232d18:	e13ffe17 	ldw	r4,-8(fp)
 8232d1c:	8202f100 	call	8202f10 <memcpy>
      data += len;
 8232d20:	e0bff517 	ldw	r2,-44(fp)
 8232d24:	e0fffe17 	ldw	r3,-8(fp)
 8232d28:	1885883a 	add	r2,r3,r2
 8232d2c:	e0bffe15 	stw	r2,-8(fp)
      *datalen -= len;
 8232d30:	e0bfff17 	ldw	r2,-4(fp)
 8232d34:	10c00017 	ldw	r3,0(r2)
 8232d38:	e0bff517 	ldw	r2,-44(fp)
 8232d3c:	1887c83a 	sub	r3,r3,r2
 8232d40:	e0bfff17 	ldw	r2,-4(fp)
 8232d44:	10c00015 	stw	r3,0(r2)

      if (len == (int)(m->m_len - moff))
 8232d48:	e0bff417 	ldw	r2,-48(fp)
 8232d4c:	10c00217 	ldw	r3,8(r2)
 8232d50:	e0bff917 	ldw	r2,-28(fp)
 8232d54:	1885c83a 	sub	r2,r3,r2
 8232d58:	1007883a 	mov	r3,r2
 8232d5c:	e0bff517 	ldw	r2,-44(fp)
 8232d60:	1880201e 	bne	r3,r2,8232de4 <soreceive+0x580>
      {
         if (flags & MSG_PEEK) 
 8232d64:	e0800217 	ldw	r2,8(fp)
 8232d68:	1080008c 	andi	r2,r2,2
 8232d6c:	10000526 	beq	r2,zero,8232d84 <soreceive+0x520>
         {
            m = m->m_next;
 8232d70:	e0bff417 	ldw	r2,-48(fp)
 8232d74:	10800617 	ldw	r2,24(r2)
 8232d78:	e0bff415 	stw	r2,-48(fp)
            moff = 0;
 8232d7c:	e03ff915 	stw	zero,-28(fp)
 8232d80:	00003206 	br	8232e4c <soreceive+0x5e8>
         } else 
         {
            nextrecord = m->m_act;
 8232d84:	e0bff417 	ldw	r2,-48(fp)
 8232d88:	10800717 	ldw	r2,28(r2)
 8232d8c:	e0bff815 	stw	r2,-32(fp)
            sbfree(&so->so_rcv, m);
 8232d90:	e0bffc17 	ldw	r2,-16(fp)
 8232d94:	10c00a17 	ldw	r3,40(r2)
 8232d98:	e0bff417 	ldw	r2,-48(fp)
 8232d9c:	10800217 	ldw	r2,8(r2)
 8232da0:	1887c83a 	sub	r3,r3,r2
 8232da4:	e0bffc17 	ldw	r2,-16(fp)
 8232da8:	10c00a15 	stw	r3,40(r2)
            {
               MFREE(m, so->so_rcv.sb_mb);
 8232dac:	e13ff417 	ldw	r4,-48(fp)
 8232db0:	822e5300 	call	822e530 <m_free>
 8232db4:	1007883a 	mov	r3,r2
 8232db8:	e0bffc17 	ldw	r2,-16(fp)
 8232dbc:	10c01015 	stw	r3,64(r2)
               m = so->so_rcv.sb_mb;
 8232dc0:	e0bffc17 	ldw	r2,-16(fp)
 8232dc4:	10801017 	ldw	r2,64(r2)
 8232dc8:	e0bff415 	stw	r2,-48(fp)
            }
            if (m)
 8232dcc:	e0bff417 	ldw	r2,-48(fp)
 8232dd0:	10001e26 	beq	r2,zero,8232e4c <soreceive+0x5e8>
               m->m_act = nextrecord;
 8232dd4:	e0bff417 	ldw	r2,-48(fp)
 8232dd8:	e0fff817 	ldw	r3,-32(fp)
 8232ddc:	10c00715 	stw	r3,28(r2)
 8232de0:	00001a06 	br	8232e4c <soreceive+0x5e8>
         }
      } else 
      {
         if (flags & MSG_PEEK)
 8232de4:	e0800217 	ldw	r2,8(fp)
 8232de8:	1080008c 	andi	r2,r2,2
 8232dec:	10000526 	beq	r2,zero,8232e04 <soreceive+0x5a0>
            moff += len;
 8232df0:	e0fff917 	ldw	r3,-28(fp)
 8232df4:	e0bff517 	ldw	r2,-44(fp)
 8232df8:	1885883a 	add	r2,r3,r2
 8232dfc:	e0bff915 	stw	r2,-28(fp)
 8232e00:	00001206 	br	8232e4c <soreceive+0x5e8>
         else 
         {
            m->m_data += len;
 8232e04:	e0bff417 	ldw	r2,-48(fp)
 8232e08:	10c00317 	ldw	r3,12(r2)
 8232e0c:	e0bff517 	ldw	r2,-44(fp)
 8232e10:	1887883a 	add	r3,r3,r2
 8232e14:	e0bff417 	ldw	r2,-48(fp)
 8232e18:	10c00315 	stw	r3,12(r2)
            m->m_len -= len;
 8232e1c:	e0bff417 	ldw	r2,-48(fp)
 8232e20:	10c00217 	ldw	r3,8(r2)
 8232e24:	e0bff517 	ldw	r2,-44(fp)
 8232e28:	1887c83a 	sub	r3,r3,r2
 8232e2c:	e0bff417 	ldw	r2,-48(fp)
 8232e30:	10c00215 	stw	r3,8(r2)
            so->so_rcv.sb_cc -= len;
 8232e34:	e0bffc17 	ldw	r2,-16(fp)
 8232e38:	10c00a17 	ldw	r3,40(r2)
 8232e3c:	e0bff517 	ldw	r2,-44(fp)
 8232e40:	1887c83a 	sub	r3,r3,r2
 8232e44:	e0bffc17 	ldw	r2,-16(fp)
 8232e48:	10c00a15 	stw	r3,40(r2)
         }
      }
      if (so->so_oobmark) 
 8232e4c:	e0bffc17 	ldw	r2,-16(fp)
 8232e50:	10801a17 	ldw	r2,104(r2)
 8232e54:	10001726 	beq	r2,zero,8232eb4 <soreceive+0x650>
      {
         if ((flags & MSG_PEEK) == 0) 
 8232e58:	e0800217 	ldw	r2,8(fp)
 8232e5c:	1080008c 	andi	r2,r2,2
 8232e60:	1000101e 	bne	r2,zero,8232ea4 <soreceive+0x640>
         {
            so->so_oobmark -= len;
 8232e64:	e0bffc17 	ldw	r2,-16(fp)
 8232e68:	10c01a17 	ldw	r3,104(r2)
 8232e6c:	e0bff517 	ldw	r2,-44(fp)
 8232e70:	1887c83a 	sub	r3,r3,r2
 8232e74:	e0bffc17 	ldw	r2,-16(fp)
 8232e78:	10c01a15 	stw	r3,104(r2)
            if (so->so_oobmark == 0) 
 8232e7c:	e0bffc17 	ldw	r2,-16(fp)
 8232e80:	10801a17 	ldw	r2,104(r2)
 8232e84:	10000b1e 	bne	r2,zero,8232eb4 <soreceive+0x650>
            {
               so->so_state |= SS_RCVATMARK;
 8232e88:	e0bffc17 	ldw	r2,-16(fp)
 8232e8c:	1080088b 	ldhu	r2,34(r2)
 8232e90:	10801014 	ori	r2,r2,64
 8232e94:	1007883a 	mov	r3,r2
 8232e98:	e0bffc17 	ldw	r2,-16(fp)
 8232e9c:	10c0088d 	sth	r3,34(r2)
               break;
 8232ea0:	00000b06 	br	8232ed0 <soreceive+0x66c>
            }
         } else
            offset += len;
 8232ea4:	e0fff717 	ldw	r3,-36(fp)
 8232ea8:	e0bff517 	ldw	r2,-44(fp)
 8232eac:	1885883a 	add	r2,r3,r2
 8232eb0:	e0bff715 	stw	r2,-36(fp)
            m->m_act = nextrecord;
      }
   }
   moff = 0;
   offset = 0;
   while (m && (*datalen > 0) && (error == 0))
 8232eb4:	e0bff417 	ldw	r2,-48(fp)
 8232eb8:	10000526 	beq	r2,zero,8232ed0 <soreceive+0x66c>
 8232ebc:	e0bfff17 	ldw	r2,-4(fp)
 8232ec0:	10800017 	ldw	r2,0(r2)
 8232ec4:	0080020e 	bge	zero,r2,8232ed0 <soreceive+0x66c>
 8232ec8:	e0bff617 	ldw	r2,-40(fp)
 8232ecc:	103f5b26 	beq	r2,zero,8232c3c <soreceive+0x3d8>
         } else
            offset += len;
      }
   }

   if ((flags & MSG_PEEK) == 0) 
 8232ed0:	e0800217 	ldw	r2,8(fp)
 8232ed4:	1080008c 	andi	r2,r2,2
 8232ed8:	1000241e 	bne	r2,zero,8232f6c <soreceive+0x708>
   {
      if (m == 0)
 8232edc:	e0bff417 	ldw	r2,-48(fp)
 8232ee0:	1000041e 	bne	r2,zero,8232ef4 <soreceive+0x690>
         so->so_rcv.sb_mb = nextrecord;
 8232ee4:	e0bffc17 	ldw	r2,-16(fp)
 8232ee8:	e0fff817 	ldw	r3,-32(fp)
 8232eec:	10c01015 	stw	r3,64(r2)
 8232ef0:	00000906 	br	8232f18 <soreceive+0x6b4>
      else if (pr->pr_flags & PR_ATOMIC)
 8232ef4:	e0bffa17 	ldw	r2,-24(fp)
 8232ef8:	1080010b 	ldhu	r2,4(r2)
 8232efc:	10bfffcc 	andi	r2,r2,65535
 8232f00:	1080004c 	andi	r2,r2,1
 8232f04:	10000426 	beq	r2,zero,8232f18 <soreceive+0x6b4>
         (void) sbdroprecord(&so->so_rcv);
 8232f08:	e0bffc17 	ldw	r2,-16(fp)
 8232f0c:	10800a04 	addi	r2,r2,40
 8232f10:	1009883a 	mov	r4,r2
 8232f14:	8234c640 	call	8234c64 <sbdroprecord>
      if (pr->pr_flags & PR_WANTRCVD && so->so_pcb)
 8232f18:	e0bffa17 	ldw	r2,-24(fp)
 8232f1c:	1080010b 	ldhu	r2,4(r2)
 8232f20:	10bfffcc 	andi	r2,r2,65535
 8232f24:	1080020c 	andi	r2,r2,8
 8232f28:	10001026 	beq	r2,zero,8232f6c <soreceive+0x708>
 8232f2c:	e0bffc17 	ldw	r2,-16(fp)
 8232f30:	10800117 	ldw	r2,4(r2)
 8232f34:	10000d26 	beq	r2,zero,8232f6c <soreceive+0x708>
      {
         so->so_req = PRU_RCVD;
 8232f38:	e0bffc17 	ldw	r2,-16(fp)
 8232f3c:	00c00204 	movi	r3,8
 8232f40:	10c00715 	stw	r3,28(r2)
         (*pr->pr_usrreq)(so, (struct mbuf *)0,
 8232f44:	e0bffa17 	ldw	r2,-24(fp)
 8232f48:	10800317 	ldw	r2,12(r2)
 8232f4c:	000d883a 	mov	r6,zero
 8232f50:	000b883a 	mov	r5,zero
 8232f54:	e13ffc17 	ldw	r4,-16(fp)
 8232f58:	103ee83a 	callr	r2
 8232f5c:	00000306 	br	8232f6c <soreceive+0x708>
         error = so->so_error;
         so->so_error = 0;
         goto release;
      }
      if (so->so_state & SS_CANTRCVMORE)
         goto release;
 8232f60:	0001883a 	nop
 8232f64:	00000106 	br	8232f6c <soreceive+0x708>
      {
         error = ENOTCONN;
         goto release;
      }
      if (*datalen == 0)
         goto release;
 8232f68:	0001883a 	nop
         (*pr->pr_usrreq)(so, (struct mbuf *)0,
          (struct mbuf *)0);
      }
   }
release:
   sbunlock(&so->so_rcv);
 8232f6c:	e0bffc17 	ldw	r2,-16(fp)
 8232f70:	10c0110b 	ldhu	r3,68(r2)
 8232f74:	00bfff84 	movi	r2,-2
 8232f78:	1884703a 	and	r2,r3,r2
 8232f7c:	1007883a 	mov	r3,r2
 8232f80:	e0bffc17 	ldw	r2,-16(fp)
 8232f84:	10c0110d 	sth	r3,68(r2)
 8232f88:	e0bffc17 	ldw	r2,-16(fp)
 8232f8c:	10801104 	addi	r2,r2,68
 8232f90:	1009883a 	mov	r4,r2
 8232f94:	82296a80 	call	82296a8 <tcp_wakeup>
   return (error);
 8232f98:	e0bff617 	ldw	r2,-40(fp)
}
 8232f9c:	e037883a 	mov	sp,fp
 8232fa0:	dfc00117 	ldw	ra,4(sp)
 8232fa4:	df000017 	ldw	fp,0(sp)
 8232fa8:	dec00204 	addi	sp,sp,8
 8232fac:	f800283a 	ret

08232fb0 <soshutdown>:
 *
 * RETURNS: int               0 if successful, else error code
 */
int
soshutdown(struct socket *so, int how)
{
 8232fb0:	defffc04 	addi	sp,sp,-16
 8232fb4:	dfc00315 	stw	ra,12(sp)
 8232fb8:	df000215 	stw	fp,8(sp)
 8232fbc:	df000204 	addi	fp,sp,8
 8232fc0:	e13ffe15 	stw	r4,-8(fp)
 8232fc4:	e17fff15 	stw	r5,-4(fp)
   how++;   /* convert 0,1,2 into 1,2,3 */
 8232fc8:	e0bfff17 	ldw	r2,-4(fp)
 8232fcc:	10800044 	addi	r2,r2,1
 8232fd0:	e0bfff15 	stw	r2,-4(fp)
   if (how & 1)   /* caller wanted READ or BOTH */
 8232fd4:	e0bfff17 	ldw	r2,-4(fp)
 8232fd8:	1080004c 	andi	r2,r2,1
 8232fdc:	10000226 	beq	r2,zero,8232fe8 <soshutdown+0x38>
      sorflush(so);
 8232fe0:	e13ffe17 	ldw	r4,-8(fp)
 8232fe4:	82330480 	call	8233048 <sorflush>

   if (how & 2)   /* caller wanted WRITE or BOTH */
 8232fe8:	e0bfff17 	ldw	r2,-4(fp)
 8232fec:	1080008c 	andi	r2,r2,2
 8232ff0:	10000f26 	beq	r2,zero,8233030 <soshutdown+0x80>
   {
      sbflush(&so->so_snd); /* flush the socket send queue */
 8232ff4:	e0bffe17 	ldw	r2,-8(fp)
 8232ff8:	10801204 	addi	r2,r2,72
 8232ffc:	1009883a 	mov	r4,r2
 8233000:	82349280 	call	8234928 <sbflush>
      so->so_req = PRU_SHUTDOWN;
 8233004:	e0bffe17 	ldw	r2,-8(fp)
 8233008:	00c001c4 	movi	r3,7
 823300c:	10c00715 	stw	r3,28(r2)
      return ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0));
 8233010:	e0bffe17 	ldw	r2,-8(fp)
 8233014:	10800217 	ldw	r2,8(r2)
 8233018:	10800317 	ldw	r2,12(r2)
 823301c:	000d883a 	mov	r6,zero
 8233020:	000b883a 	mov	r5,zero
 8233024:	e13ffe17 	ldw	r4,-8(fp)
 8233028:	103ee83a 	callr	r2
 823302c:	00000106 	br	8233034 <soshutdown+0x84>
   }

   return 0;
 8233030:	0005883a 	mov	r2,zero
}
 8233034:	e037883a 	mov	sp,fp
 8233038:	dfc00117 	ldw	ra,4(sp)
 823303c:	df000017 	ldw	fp,0(sp)
 8233040:	dec00204 	addi	sp,sp,8
 8233044:	f800283a 	ret

08233048 <sorflush>:
 * socket receive buffer is discarded. Wakeup any processes waiting
 * on the socket.
 */
void
sorflush(struct socket * so)
{
 8233048:	defffb04 	addi	sp,sp,-20
 823304c:	dfc00415 	stw	ra,16(sp)
 8233050:	df000315 	stw	fp,12(sp)
 8233054:	df000304 	addi	fp,sp,12
 8233058:	e13fff15 	stw	r4,-4(fp)
   struct sockbuf *sb =  &so->so_rcv;
 823305c:	e0bfff17 	ldw	r2,-4(fp)
 8233060:	10800a04 	addi	r2,r2,40
 8233064:	e0bffd15 	stw	r2,-12(fp)
   int   s;

   sblock(sb);
 8233068:	00000406 	br	823307c <sorflush+0x34>
 823306c:	e0bffd17 	ldw	r2,-12(fp)
 8233070:	10800704 	addi	r2,r2,28
 8233074:	1009883a 	mov	r4,r2
 8233078:	82295340 	call	8229534 <tcp_sleep>
 823307c:	e0bffd17 	ldw	r2,-12(fp)
 8233080:	1080070b 	ldhu	r2,28(r2)
 8233084:	10bfffcc 	andi	r2,r2,65535
 8233088:	1080004c 	andi	r2,r2,1
 823308c:	103ff71e 	bne	r2,zero,823306c <sorflush+0x24>
 8233090:	e0bffd17 	ldw	r2,-12(fp)
 8233094:	1080070b 	ldhu	r2,28(r2)
 8233098:	10800054 	ori	r2,r2,1
 823309c:	1007883a 	mov	r3,r2
 82330a0:	e0bffd17 	ldw	r2,-12(fp)
 82330a4:	10c0070d 	sth	r3,28(r2)
   socantrcvmore(so);
 82330a8:	e13fff17 	ldw	r4,-4(fp)
 82330ac:	82341440 	call	8234144 <socantrcvmore>
   sbunlock(sb);
 82330b0:	e0bffd17 	ldw	r2,-12(fp)
 82330b4:	10c0070b 	ldhu	r3,28(r2)
 82330b8:	00bfff84 	movi	r2,-2
 82330bc:	1884703a 	and	r2,r3,r2
 82330c0:	1007883a 	mov	r3,r2
 82330c4:	e0bffd17 	ldw	r2,-12(fp)
 82330c8:	10c0070d 	sth	r3,28(r2)
 82330cc:	e0bffd17 	ldw	r2,-12(fp)
 82330d0:	10800704 	addi	r2,r2,28
 82330d4:	1009883a 	mov	r4,r2
 82330d8:	82296a80 	call	82296a8 <tcp_wakeup>
   sbrelease(sb);
 82330dc:	e13ffd17 	ldw	r4,-12(fp)
 82330e0:	82343a80 	call	82343a8 <sbrelease>
   MEMSET((char *)sb, 0, sizeof (*sb));
 82330e4:	01800804 	movi	r6,32
 82330e8:	000b883a 	mov	r5,zero
 82330ec:	e13ffd17 	ldw	r4,-12(fp)
 82330f0:	82031b40 	call	82031b4 <memset>
   s = so->so_error;
 82330f4:	e0bfff17 	ldw	r2,-4(fp)
 82330f8:	10800617 	ldw	r2,24(r2)
 82330fc:	e0bffe15 	stw	r2,-8(fp)
   so->so_error = ESHUTDOWN;
 8233100:	e0bfff17 	ldw	r2,-4(fp)
 8233104:	00c01b84 	movi	r3,110
 8233108:	10c00615 	stw	r3,24(r2)
   sorwakeup(so);
 823310c:	e0bfff17 	ldw	r2,-4(fp)
 8233110:	10800a04 	addi	r2,r2,40
 8233114:	100b883a 	mov	r5,r2
 8233118:	e13fff17 	ldw	r4,-4(fp)
 823311c:	82342440 	call	8234244 <sbwakeup>
   so->so_error = s;
 8233120:	e0bfff17 	ldw	r2,-4(fp)
 8233124:	e0fffe17 	ldw	r3,-8(fp)
 8233128:	10c00615 	stw	r3,24(r2)
}
 823312c:	0001883a 	nop
 8233130:	e037883a 	mov	sp,fp
 8233134:	dfc00117 	ldw	ra,4(sp)
 8233138:	df000017 	ldw	fp,0(sp)
 823313c:	dec00204 	addi	sp,sp,8
 8233140:	f800283a 	ret

08233144 <sosetopt>:

int
sosetopt(struct socket * so, 
   int   optname,
   void *   arg)
{
 8233144:	defff604 	addi	sp,sp,-40
 8233148:	dfc00915 	stw	ra,36(sp)
 823314c:	df000815 	stw	fp,32(sp)
 8233150:	df000804 	addi	fp,sp,32
 8233154:	e13ffd15 	stw	r4,-12(fp)
 8233158:	e17ffe15 	stw	r5,-8(fp)
 823315c:	e1bfff15 	stw	r6,-4(fp)
   int   error =  0;
 8233160:	e03ff815 	stw	zero,-32(fp)

   switch (optname) 
 8233164:	e0bffe17 	ldw	r2,-8(fp)
 8233168:	10c08020 	cmpeqi	r3,r2,512
 823316c:	18003b1e 	bne	r3,zero,823325c <sosetopt+0x118>
 8233170:	10c08048 	cmpgei	r3,r2,513
 8233174:	1800171e 	bne	r3,zero,82331d4 <sosetopt+0x90>
 8233178:	10c00388 	cmpgei	r3,r2,14
 823317c:	1800091e 	bne	r3,zero,82331a4 <sosetopt+0x60>
 8233180:	10c00248 	cmpgei	r3,r2,9
 8233184:	1800831e 	bne	r3,zero,8233394 <sosetopt+0x250>
 8233188:	10c00120 	cmpeqi	r3,r2,4
 823318c:	1800331e 	bne	r3,zero,823325c <sosetopt+0x118>
 8233190:	10c00220 	cmpeqi	r3,r2,8
 8233194:	1800311e 	bne	r3,zero,823325c <sosetopt+0x118>
 8233198:	108000a0 	cmpeqi	r2,r2,2
 823319c:	1000831e 	bne	r2,zero,82333ac <sosetopt+0x268>
 82331a0:	0000ea06 	br	823354c <sosetopt+0x408>
 82331a4:	10c00820 	cmpeqi	r3,r2,32
 82331a8:	18002c1e 	bne	r3,zero,823325c <sosetopt+0x118>
 82331ac:	10c00848 	cmpgei	r3,r2,33
 82331b0:	1800031e 	bne	r3,zero,82331c0 <sosetopt+0x7c>
 82331b4:	10800420 	cmpeqi	r2,r2,16
 82331b8:	1000281e 	bne	r2,zero,823325c <sosetopt+0x118>
 82331bc:	0000e306 	br	823354c <sosetopt+0x408>
 82331c0:	10c02020 	cmpeqi	r3,r2,128
 82331c4:	1800201e 	bne	r3,zero,8233248 <sosetopt+0x104>
 82331c8:	10804020 	cmpeqi	r2,r2,256
 82331cc:	1000231e 	bne	r2,zero,823325c <sosetopt+0x118>
 82331d0:	0000de06 	br	823354c <sosetopt+0x408>
 82331d4:	10c40520 	cmpeqi	r3,r2,4116
 82331d8:	1800481e 	bne	r3,zero,82332fc <sosetopt+0x1b8>
 82331dc:	10c40548 	cmpgei	r3,r2,4117
 82331e0:	18000b1e 	bne	r3,zero,8233210 <sosetopt+0xcc>
 82331e4:	10c401a0 	cmpeqi	r3,r2,4102
 82331e8:	18003f1e 	bne	r3,zero,82332e8 <sosetopt+0x1a4>
 82331ec:	10c401c8 	cmpgei	r3,r2,4103
 82331f0:	1800041e 	bne	r3,zero,8233204 <sosetopt+0xc0>
 82331f4:	10bbffc4 	addi	r2,r2,-4097
 82331f8:	108000a8 	cmpgeui	r2,r2,2
 82331fc:	1000d31e 	bne	r2,zero,823354c <sosetopt+0x408>
 8233200:	00002806 	br	82332a4 <sosetopt+0x160>
 8233204:	10840420 	cmpeqi	r2,r2,4112
 8233208:	1000a91e 	bne	r2,zero,82334b0 <sosetopt+0x36c>
 823320c:	0000cf06 	br	823354c <sosetopt+0x408>
 8233210:	10c800e0 	cmpeqi	r3,r2,8195
 8233214:	1800a61e 	bne	r3,zero,82334b0 <sosetopt+0x36c>
 8233218:	10c80108 	cmpgei	r3,r2,8196
 823321c:	1800051e 	bne	r3,zero,8233234 <sosetopt+0xf0>
 8233220:	10c40560 	cmpeqi	r3,r2,4117
 8233224:	18003c1e 	bne	r3,zero,8233318 <sosetopt+0x1d4>
 8233228:	108405a0 	cmpeqi	r2,r2,4118
 823322c:	1000421e 	bne	r2,zero,8233338 <sosetopt+0x1f4>
 8233230:	0000c606 	br	823354c <sosetopt+0x408>
 8233234:	10c80120 	cmpeqi	r3,r2,8196
 8233238:	1800711e 	bne	r3,zero,8233400 <sosetopt+0x2bc>
 823323c:	10900020 	cmpeqi	r2,r2,16384
 8233240:	1000061e 	bne	r2,zero,823325c <sosetopt+0x118>
 8233244:	0000c106 	br	823354c <sosetopt+0x408>
   {
   case SO_LINGER:
      so->so_linger = (short)((struct linger *)arg)->l_linger;
 8233248:	e0bfff17 	ldw	r2,-4(fp)
 823324c:	10800117 	ldw	r2,4(r2)
 8233250:	1007883a 	mov	r3,r2
 8233254:	e0bffd17 	ldw	r2,-12(fp)
 8233258:	10c0080d 	sth	r3,32(r2)
   case SO_TCPSACK:
   case SO_NOSLOWSTART:
#ifdef SUPPORT_SO_FULLMSS
   case SO_FULLMSS:
#endif
      if (*(int *)arg) 
 823325c:	e0bfff17 	ldw	r2,-4(fp)
 8233260:	10800017 	ldw	r2,0(r2)
 8233264:	10000726 	beq	r2,zero,8233284 <sosetopt+0x140>
         so->so_options |= optname;
 8233268:	e0bffd17 	ldw	r2,-12(fp)
 823326c:	10c00417 	ldw	r3,16(r2)
 8233270:	e0bffe17 	ldw	r2,-8(fp)
 8233274:	1886b03a 	or	r3,r3,r2
 8233278:	e0bffd17 	ldw	r2,-12(fp)
 823327c:	10c00415 	stw	r3,16(r2)
      else
         so->so_options &= ~optname;
      break;
 8233280:	0000b606 	br	823355c <sosetopt+0x418>
   case SO_FULLMSS:
#endif
      if (*(int *)arg) 
         so->so_options |= optname;
      else
         so->so_options &= ~optname;
 8233284:	e0bffd17 	ldw	r2,-12(fp)
 8233288:	10800417 	ldw	r2,16(r2)
 823328c:	e0fffe17 	ldw	r3,-8(fp)
 8233290:	00c6303a 	nor	r3,zero,r3
 8233294:	10c6703a 	and	r3,r2,r3
 8233298:	e0bffd17 	ldw	r2,-12(fp)
 823329c:	10c00415 	stw	r3,16(r2)
      break;
 82332a0:	0000ae06 	br	823355c <sosetopt+0x418>
      break;
#endif /* TCP_BIGCWND */

   case SO_SNDBUF:
   case SO_RCVBUF:
      if (sbreserve(optname == SO_SNDBUF ?
 82332a4:	e0bffe17 	ldw	r2,-8(fp)
 82332a8:	10840058 	cmpnei	r2,r2,4097
 82332ac:	1000031e 	bne	r2,zero,82332bc <sosetopt+0x178>
 82332b0:	e0bffd17 	ldw	r2,-12(fp)
 82332b4:	10801204 	addi	r2,r2,72
 82332b8:	00000206 	br	82332c4 <sosetopt+0x180>
 82332bc:	e0bffd17 	ldw	r2,-12(fp)
 82332c0:	10800a04 	addi	r2,r2,40
          &so->so_snd : &so->so_rcv,
          (u_long) * (int *)arg) == 0) 
 82332c4:	e0ffff17 	ldw	r3,-4(fp)
 82332c8:	18c00017 	ldw	r3,0(r3)
      break;
#endif /* TCP_BIGCWND */

   case SO_SNDBUF:
   case SO_RCVBUF:
      if (sbreserve(optname == SO_SNDBUF ?
 82332cc:	180b883a 	mov	r5,r3
 82332d0:	1009883a 	mov	r4,r2
 82332d4:	82343580 	call	8234358 <sbreserve>
 82332d8:	10009f1e 	bne	r2,zero,8233558 <sosetopt+0x414>
          &so->so_snd : &so->so_rcv,
          (u_long) * (int *)arg) == 0) 
      {
         error = ENOBUFS;
 82332dc:	00801a44 	movi	r2,105
 82332e0:	e0bff815 	stw	r2,-32(fp)
         goto bad;
 82332e4:	00009d06 	br	823355c <sosetopt+0x418>
      }
      break;

   case SO_RCVTIMEO:
      so->so_rcv.sb_timeo = *(short *)arg;
 82332e8:	e0bfff17 	ldw	r2,-4(fp)
 82332ec:	10c0000b 	ldhu	r3,0(r2)
 82332f0:	e0bffd17 	ldw	r2,-12(fp)
 82332f4:	10c0118d 	sth	r3,70(r2)
      break;
 82332f8:	00009806 	br	823355c <sosetopt+0x418>

   case SO_NBIO:     /* set socket into NON-blocking mode */
      so->so_state |= SS_NBIO;
 82332fc:	e0bffd17 	ldw	r2,-12(fp)
 8233300:	1080088b 	ldhu	r2,34(r2)
 8233304:	10804014 	ori	r2,r2,256
 8233308:	1007883a 	mov	r3,r2
 823330c:	e0bffd17 	ldw	r2,-12(fp)
 8233310:	10c0088d 	sth	r3,34(r2)
      break;
 8233314:	00009106 	br	823355c <sosetopt+0x418>

   case SO_BIO:   /* set socket into blocking mode */
      so->so_state &= ~SS_NBIO;
 8233318:	e0bffd17 	ldw	r2,-12(fp)
 823331c:	10c0088b 	ldhu	r3,34(r2)
 8233320:	00bfbfc4 	movi	r2,-257
 8233324:	1884703a 	and	r2,r3,r2
 8233328:	1007883a 	mov	r3,r2
 823332c:	e0bffd17 	ldw	r2,-12(fp)
 8233330:	10c0088d 	sth	r3,34(r2)
      break;
 8233334:	00008906 	br	823355c <sosetopt+0x418>

   case SO_NONBLOCK:    /* set blocking mode according to arg */
      /* sanity check the arg parameter */
      if (!arg)
 8233338:	e0bfff17 	ldw	r2,-4(fp)
 823333c:	1000031e 	bne	r2,zero,823334c <sosetopt+0x208>
      {
         error = ENP_PARAM;
 8233340:	00bffd84 	movi	r2,-10
 8233344:	e0bff815 	stw	r2,-32(fp)
         break;
 8233348:	00008406 	br	823355c <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 823334c:	e0bfff17 	ldw	r2,-4(fp)
 8233350:	10800017 	ldw	r2,0(r2)
 8233354:	10000726 	beq	r2,zero,8233374 <sosetopt+0x230>
         so->so_state |= SS_NBIO;   /* set non-blocking mode */
 8233358:	e0bffd17 	ldw	r2,-12(fp)
 823335c:	1080088b 	ldhu	r2,34(r2)
 8233360:	10804014 	ori	r2,r2,256
 8233364:	1007883a 	mov	r3,r2
 8233368:	e0bffd17 	ldw	r2,-12(fp)
 823336c:	10c0088d 	sth	r3,34(r2)
      else
         so->so_state &= ~SS_NBIO;  /* set blocking mode */
      break;
 8233370:	00007a06 	br	823355c <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
         so->so_state |= SS_NBIO;   /* set non-blocking mode */
      else
         so->so_state &= ~SS_NBIO;  /* set blocking mode */
 8233374:	e0bffd17 	ldw	r2,-12(fp)
 8233378:	10c0088b 	ldhu	r3,34(r2)
 823337c:	00bfbfc4 	movi	r2,-257
 8233380:	1884703a 	and	r2,r3,r2
 8233384:	1007883a 	mov	r3,r2
 8233388:	e0bffd17 	ldw	r2,-12(fp)
 823338c:	10c0088d 	sth	r3,34(r2)
      break;
 8233390:	00007206 	br	823355c <sosetopt+0x418>
   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      error = ip_setmoptions(optname, so, arg);
 8233394:	e1bfff17 	ldw	r6,-4(fp)
 8233398:	e17ffd17 	ldw	r5,-12(fp)
 823339c:	e13ffe17 	ldw	r4,-8(fp)
 82333a0:	8245fac0 	call	8245fac <ip_setmoptions>
 82333a4:	e0bff815 	stw	r2,-32(fp)
      break;
 82333a8:	00006c06 	br	823355c <sosetopt+0x418>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 82333ac:	e0bfff17 	ldw	r2,-4(fp)
 82333b0:	1000031e 	bne	r2,zero,82333c0 <sosetopt+0x27c>
      {
         error = ENP_PARAM;
 82333b4:	00bffd84 	movi	r2,-10
 82333b8:	e0bff815 	stw	r2,-32(fp)
         break;
 82333bc:	00006706 	br	823355c <sosetopt+0x418>
      }
      /* set the socket option flag based on the pointed-to argument */
      if (*(int *)arg)
 82333c0:	e0bfff17 	ldw	r2,-4(fp)
 82333c4:	10800017 	ldw	r2,0(r2)
 82333c8:	10000626 	beq	r2,zero,82333e4 <sosetopt+0x2a0>
         so->so_options |= SO_HDRINCL;
 82333cc:	e0bffd17 	ldw	r2,-12(fp)
 82333d0:	10800417 	ldw	r2,16(r2)
 82333d4:	10c80014 	ori	r3,r2,8192
 82333d8:	e0bffd17 	ldw	r2,-12(fp)
 82333dc:	10c00415 	stw	r3,16(r2)
      else
         so->so_options &= ~SO_HDRINCL;
      break;
 82333e0:	00005e06 	br	823355c <sosetopt+0x418>
      }
      /* set the socket option flag based on the pointed-to argument */
      if (*(int *)arg)
         so->so_options |= SO_HDRINCL;
      else
         so->so_options &= ~SO_HDRINCL;
 82333e4:	e0bffd17 	ldw	r2,-12(fp)
 82333e8:	10c00417 	ldw	r3,16(r2)
 82333ec:	00b7ffc4 	movi	r2,-8193
 82333f0:	1886703a 	and	r3,r3,r2
 82333f4:	e0bffd17 	ldw	r2,-12(fp)
 82333f8:	10c00415 	stw	r3,16(r2)
      break;
 82333fc:	00005706 	br	823355c <sosetopt+0x418>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 8233400:	e0bffd17 	ldw	r2,-12(fp)
 8233404:	10800983 	ldbu	r2,38(r2)
 8233408:	10803fcc 	andi	r2,r2,255
 823340c:	1080201c 	xori	r2,r2,128
 8233410:	10bfe004 	addi	r2,r2,-128
 8233414:	10800060 	cmpeqi	r2,r2,1
 8233418:	1000031e 	bne	r2,zero,8233428 <sosetopt+0x2e4>
      {
         error = EINVAL;
 823341c:	00800584 	movi	r2,22
 8233420:	e0bff815 	stw	r2,-32(fp)
         break;
 8233424:	00004d06 	br	823355c <sosetopt+0x418>
      }
      inp = (struct inpcb *)(so->so_pcb);
 8233428:	e0bffd17 	ldw	r2,-12(fp)
 823342c:	10800117 	ldw	r2,4(r2)
 8233430:	e0bff915 	stw	r2,-28(fp)
      tp = intotcpcb(inp);
 8233434:	e0bff917 	ldw	r2,-28(fp)
 8233438:	10800917 	ldw	r2,36(r2)
 823343c:	e0bffa15 	stw	r2,-24(fp)
      if(!tp)
 8233440:	e0bffa17 	ldw	r2,-24(fp)
 8233444:	1000031e 	bne	r2,zero,8233454 <sosetopt+0x310>
      {
         error = ENOTCONN;
 8233448:	00802004 	movi	r2,128
 823344c:	e0bff815 	stw	r2,-32(fp)
         break;
 8233450:	00004206 	br	823355c <sosetopt+0x418>
      }
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 8233454:	e0bfff17 	ldw	r2,-4(fp)
 8233458:	1000031e 	bne	r2,zero,8233468 <sosetopt+0x324>
      {
         error = ENP_PARAM;
 823345c:	00bffd84 	movi	r2,-10
 8233460:	e0bff815 	stw	r2,-32(fp)
         break;
 8233464:	00003d06 	br	823355c <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 8233468:	e0bfff17 	ldw	r2,-4(fp)
 823346c:	10800017 	ldw	r2,0(r2)
 8233470:	10000726 	beq	r2,zero,8233490 <sosetopt+0x34c>
         tp->t_flags |= TF_NODELAY;   /* Disable Nagle Algorithm */
 8233474:	e0bffa17 	ldw	r2,-24(fp)
 8233478:	10800b0b 	ldhu	r2,44(r2)
 823347c:	10800114 	ori	r2,r2,4
 8233480:	1007883a 	mov	r3,r2
 8233484:	e0bffa17 	ldw	r2,-24(fp)
 8233488:	10c00b0d 	sth	r3,44(r2)
      else
         tp->t_flags &= ~TF_NODELAY;  /* Enable Nagle Algorithm */

      break;
 823348c:	00003306 	br	823355c <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
         tp->t_flags |= TF_NODELAY;   /* Disable Nagle Algorithm */
      else
         tp->t_flags &= ~TF_NODELAY;  /* Enable Nagle Algorithm */
 8233490:	e0bffa17 	ldw	r2,-24(fp)
 8233494:	10c00b0b 	ldhu	r3,44(r2)
 8233498:	00bffec4 	movi	r2,-5
 823349c:	1884703a 	and	r2,r3,r2
 82334a0:	1007883a 	mov	r3,r2
 82334a4:	e0bffa17 	ldw	r2,-24(fp)
 82334a8:	10c00b0d 	sth	r3,44(r2)

      break;
 82334ac:	00002b06 	br	823355c <sosetopt+0x418>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 82334b0:	e0bffd17 	ldw	r2,-12(fp)
 82334b4:	10800983 	ldbu	r2,38(r2)
 82334b8:	10803fcc 	andi	r2,r2,255
 82334bc:	1080201c 	xori	r2,r2,128
 82334c0:	10bfe004 	addi	r2,r2,-128
 82334c4:	10800060 	cmpeqi	r2,r2,1
 82334c8:	1000031e 	bne	r2,zero,82334d8 <sosetopt+0x394>
      {
         error = EINVAL;
 82334cc:	00800584 	movi	r2,22
 82334d0:	e0bff815 	stw	r2,-32(fp)
         break;
 82334d4:	00002106 	br	823355c <sosetopt+0x418>
      }
      inp = (struct inpcb *)(so->so_pcb);
 82334d8:	e0bffd17 	ldw	r2,-12(fp)
 82334dc:	10800117 	ldw	r2,4(r2)
 82334e0:	e0bffb15 	stw	r2,-20(fp)
      tp = intotcpcb(inp);
 82334e4:	e0bffb17 	ldw	r2,-20(fp)
 82334e8:	10800917 	ldw	r2,36(r2)
 82334ec:	e0bffc15 	stw	r2,-16(fp)
      if(!tp)
 82334f0:	e0bffc17 	ldw	r2,-16(fp)
 82334f4:	1000031e 	bne	r2,zero,8233504 <sosetopt+0x3c0>
      {
         error = ENOTCONN;
 82334f8:	00802004 	movi	r2,128
 82334fc:	e0bff815 	stw	r2,-32(fp)
         break;
 8233500:	00001606 	br	823355c <sosetopt+0x418>
      }
      if (tp->t_state != TCPS_CLOSED)
 8233504:	e0bffc17 	ldw	r2,-16(fp)
 8233508:	10800217 	ldw	r2,8(r2)
 823350c:	10000326 	beq	r2,zero,823351c <sosetopt+0x3d8>
      {
         error = EINVAL;
 8233510:	00800584 	movi	r2,22
 8233514:	e0bff815 	stw	r2,-32(fp)
         break;
 8233518:	00001006 	br	823355c <sosetopt+0x418>
      }
      tp->t_maxseg = *(int*)(arg);    /* set TCP MSS */
 823351c:	e0bfff17 	ldw	r2,-4(fp)
 8233520:	10800017 	ldw	r2,0(r2)
 8233524:	1007883a 	mov	r3,r2
 8233528:	e0bffc17 	ldw	r2,-16(fp)
 823352c:	10c00a0d 	sth	r3,40(r2)
      tp->t_flags |= TF_MAXSEG;   /* mark as user set max seg */
 8233530:	e0bffc17 	ldw	r2,-16(fp)
 8233534:	10800b0b 	ldhu	r2,44(r2)
 8233538:	10810014 	ori	r2,r2,1024
 823353c:	1007883a 	mov	r3,r2
 8233540:	e0bffc17 	ldw	r2,-16(fp)
 8233544:	10c00b0d 	sth	r3,44(r2)
      break;
 8233548:	00000406 	br	823355c <sosetopt+0x418>
   }
   default:
      error = ENOPROTOOPT;
 823354c:	00801b44 	movi	r2,109
 8233550:	e0bff815 	stw	r2,-32(fp)
      break;
 8233554:	00000106 	br	823355c <sosetopt+0x418>
          (u_long) * (int *)arg) == 0) 
      {
         error = ENOBUFS;
         goto bad;
      }
      break;
 8233558:	0001883a 	nop
   default:
      error = ENOPROTOOPT;
      break;
   }
bad:
   return (error);
 823355c:	e0bff817 	ldw	r2,-32(fp)
}
 8233560:	e037883a 	mov	sp,fp
 8233564:	dfc00117 	ldw	ra,4(sp)
 8233568:	df000017 	ldw	fp,0(sp)
 823356c:	dec00204 	addi	sp,sp,8
 8233570:	f800283a 	ret

08233574 <sogetopt>:

int
sogetopt(struct socket * so, 
   int   optname,
   void *   val)
{
 8233574:	defff504 	addi	sp,sp,-44
 8233578:	dfc00a15 	stw	ra,40(sp)
 823357c:	df000915 	stw	fp,36(sp)
 8233580:	df000904 	addi	fp,sp,36
 8233584:	e13ffd15 	stw	r4,-12(fp)
 8233588:	e17ffe15 	stw	r5,-8(fp)
 823358c:	e1bfff15 	stw	r6,-4(fp)
   int   error =  0;
 8233590:	e03ff715 	stw	zero,-36(fp)

   /* sanity check the val parameter */
   if (!val)
 8233594:	e0bfff17 	ldw	r2,-4(fp)
 8233598:	1000021e 	bne	r2,zero,82335a4 <sogetopt+0x30>
   {
      return ENP_PARAM;
 823359c:	00bffd84 	movi	r2,-10
 82335a0:	00011906 	br	8233a08 <sogetopt+0x494>
   }

   switch (optname) 
 82335a4:	e0bffe17 	ldw	r2,-8(fp)
 82335a8:	10c400e0 	cmpeqi	r3,r2,4099
 82335ac:	1800701e 	bne	r3,zero,8233770 <sogetopt+0x1fc>
 82335b0:	10c40108 	cmpgei	r3,r2,4100
 82335b4:	1800201e 	bne	r3,zero,8233638 <sogetopt+0xc4>
 82335b8:	10c00420 	cmpeqi	r3,r2,16
 82335bc:	1800641e 	bne	r3,zero,8233750 <sogetopt+0x1dc>
 82335c0:	10c00448 	cmpgei	r3,r2,17
 82335c4:	18000c1e 	bne	r3,zero,82335f8 <sogetopt+0x84>
 82335c8:	10c00220 	cmpeqi	r3,r2,8
 82335cc:	1800601e 	bne	r3,zero,8233750 <sogetopt+0x1dc>
 82335d0:	10c00248 	cmpgei	r3,r2,9
 82335d4:	1800051e 	bne	r3,zero,82335ec <sogetopt+0x78>
 82335d8:	10c000a0 	cmpeqi	r3,r2,2
 82335dc:	1800d61e 	bne	r3,zero,8233938 <sogetopt+0x3c4>
 82335e0:	10800120 	cmpeqi	r2,r2,4
 82335e4:	10005a1e 	bne	r2,zero,8233750 <sogetopt+0x1dc>
 82335e8:	00010406 	br	82339fc <sogetopt+0x488>
 82335ec:	10800308 	cmpgei	r2,r2,12
 82335f0:	1001021e 	bne	r2,zero,82339fc <sogetopt+0x488>
 82335f4:	0000ca06 	br	8233920 <sogetopt+0x3ac>
 82335f8:	10c04020 	cmpeqi	r3,r2,256
 82335fc:	1800541e 	bne	r3,zero,8233750 <sogetopt+0x1dc>
 8233600:	10c04048 	cmpgei	r3,r2,257
 8233604:	1800051e 	bne	r3,zero,823361c <sogetopt+0xa8>
 8233608:	10c00820 	cmpeqi	r3,r2,32
 823360c:	1800501e 	bne	r3,zero,8233750 <sogetopt+0x1dc>
 8233610:	10802020 	cmpeqi	r2,r2,128
 8233614:	10003f1e 	bne	r2,zero,8233714 <sogetopt+0x1a0>
 8233618:	0000f806 	br	82339fc <sogetopt+0x488>
 823361c:	10c40060 	cmpeqi	r3,r2,4097
 8233620:	18005f1e 	bne	r3,zero,82337a0 <sogetopt+0x22c>
 8233624:	10c40088 	cmpgei	r3,r2,4098
 8233628:	1800631e 	bne	r3,zero,82337b8 <sogetopt+0x244>
 823362c:	10808020 	cmpeqi	r2,r2,512
 8233630:	1000471e 	bne	r2,zero,8233750 <sogetopt+0x1dc>
 8233634:	0000f106 	br	82339fc <sogetopt+0x488>
 8233638:	10c40420 	cmpeqi	r3,r2,4112
 823363c:	18007f1e 	bne	r3,zero,823383c <sogetopt+0x2c8>
 8233640:	10c40448 	cmpgei	r3,r2,4113
 8233644:	1800101e 	bne	r3,zero,8233688 <sogetopt+0x114>
 8233648:	10c401a0 	cmpeqi	r3,r2,4102
 823364c:	18009b1e 	bne	r3,zero,82338bc <sogetopt+0x348>
 8233650:	10c401c8 	cmpgei	r3,r2,4103
 8233654:	1800051e 	bne	r3,zero,823366c <sogetopt+0xf8>
 8233658:	10c40120 	cmpeqi	r3,r2,4100
 823365c:	18004a1e 	bne	r3,zero,8233788 <sogetopt+0x214>
 8233660:	10840160 	cmpeqi	r2,r2,4101
 8233664:	1000901e 	bne	r2,zero,82338a8 <sogetopt+0x334>
 8233668:	0000e406 	br	82339fc <sogetopt+0x488>
 823366c:	10c40220 	cmpeqi	r3,r2,4104
 8233670:	1800631e 	bne	r3,zero,8233800 <sogetopt+0x28c>
 8233674:	10c40210 	cmplti	r3,r2,4104
 8233678:	1800691e 	bne	r3,zero,8233820 <sogetopt+0x2ac>
 823367c:	10840260 	cmpeqi	r2,r2,4105
 8233680:	1000931e 	bne	r2,zero,82338d0 <sogetopt+0x35c>
 8233684:	0000dd06 	br	82339fc <sogetopt+0x488>
 8233688:	10c404e0 	cmpeqi	r3,r2,4115
 823368c:	18000e1e 	bne	r3,zero,82336c8 <sogetopt+0x154>
 8233690:	10c40508 	cmpgei	r3,r2,4116
 8233694:	1800051e 	bne	r3,zero,82336ac <sogetopt+0x138>
 8233698:	10c40460 	cmpeqi	r3,r2,4113
 823369c:	18004c1e 	bne	r3,zero,82337d0 <sogetopt+0x25c>
 82336a0:	108404a0 	cmpeqi	r2,r2,4114
 82336a4:	1000501e 	bne	r2,zero,82337e8 <sogetopt+0x274>
 82336a8:	0000d406 	br	82339fc <sogetopt+0x488>
 82336ac:	10c800e0 	cmpeqi	r3,r2,8195
 82336b0:	1800621e 	bne	r3,zero,823383c <sogetopt+0x2c8>
 82336b4:	10c80120 	cmpeqi	r3,r2,8196
 82336b8:	1800aa1e 	bne	r3,zero,8233964 <sogetopt+0x3f0>
 82336bc:	108405a0 	cmpeqi	r2,r2,4118
 82336c0:	10008b1e 	bne	r2,zero,82338f0 <sogetopt+0x37c>
 82336c4:	0000cd06 	br	82339fc <sogetopt+0x488>
   {
   case SO_MYADDR:
      /* Get my IP address. */
      if (so->so_state & SS_ISCONNECTED)
 82336c8:	e0bffd17 	ldw	r2,-12(fp)
 82336cc:	1080088b 	ldhu	r2,34(r2)
 82336d0:	10bfffcc 	andi	r2,r2,65535
 82336d4:	1080008c 	andi	r2,r2,2
 82336d8:	10000726 	beq	r2,zero,82336f8 <sogetopt+0x184>
      {
         *(u_long *)val = so->so_pcb->ifp->n_ipaddr;
 82336dc:	e0bffd17 	ldw	r2,-12(fp)
 82336e0:	10800117 	ldw	r2,4(r2)
 82336e4:	10800a17 	ldw	r2,40(r2)
 82336e8:	10c00a17 	ldw	r3,40(r2)
 82336ec:	e0bfff17 	ldw	r2,-4(fp)
 82336f0:	10c00015 	stw	r3,0(r2)
      }
      else  /* not connected, use first iface */
         *(u_long *)val = nets[0]->n_ipaddr;
      break;
 82336f4:	0000c306 	br	8233a04 <sogetopt+0x490>
      if (so->so_state & SS_ISCONNECTED)
      {
         *(u_long *)val = so->so_pcb->ifp->n_ipaddr;
      }
      else  /* not connected, use first iface */
         *(u_long *)val = nets[0]->n_ipaddr;
 82336f8:	008209b4 	movhi	r2,2086
 82336fc:	10b81b04 	addi	r2,r2,-8084
 8233700:	10800017 	ldw	r2,0(r2)
 8233704:	10c00a17 	ldw	r3,40(r2)
 8233708:	e0bfff17 	ldw	r2,-4(fp)
 823370c:	10c00015 	stw	r3,0(r2)
      break;
 8233710:	0000bc06 	br	8233a04 <sogetopt+0x490>
   case SO_LINGER:
      {
         struct linger *   l  =  (struct  linger *)val;
 8233714:	e0bfff17 	ldw	r2,-4(fp)
 8233718:	e0bff815 	stw	r2,-32(fp)
         l->l_onoff = so->so_options & SO_LINGER;
 823371c:	e0bffd17 	ldw	r2,-12(fp)
 8233720:	10800417 	ldw	r2,16(r2)
 8233724:	10c0200c 	andi	r3,r2,128
 8233728:	e0bff817 	ldw	r2,-32(fp)
 823372c:	10c00015 	stw	r3,0(r2)
         l->l_linger = so->so_linger;
 8233730:	e0bffd17 	ldw	r2,-12(fp)
 8233734:	1080080b 	ldhu	r2,32(r2)
 8233738:	10ffffcc 	andi	r3,r2,65535
 823373c:	18e0001c 	xori	r3,r3,32768
 8233740:	18e00004 	addi	r3,r3,-32768
 8233744:	e0bff817 	ldw	r2,-32(fp)
 8233748:	10c00115 	stw	r3,4(r2)
      }
      break;
 823374c:	0000ad06 	br	8233a04 <sogetopt+0x490>
   case SO_OOBINLINE:
   case SO_DONTROUTE:
   case SO_REUSEADDR:
   case SO_BROADCAST:
   case SO_TCPSACK:
      *(int *)val = so->so_options & optname;
 8233750:	e0bffd17 	ldw	r2,-12(fp)
 8233754:	10c00417 	ldw	r3,16(r2)
 8233758:	e0bffe17 	ldw	r2,-8(fp)
 823375c:	1884703a 	and	r2,r3,r2
 8233760:	1007883a 	mov	r3,r2
 8233764:	e0bfff17 	ldw	r2,-4(fp)
 8233768:	10c00015 	stw	r3,0(r2)
      break;
 823376c:	0000a506 	br	8233a04 <sogetopt+0x490>

   case SO_SNDLOWAT:
      *(int *)val = (int)so->so_snd.sb_lowat;
 8233770:	e0bffd17 	ldw	r2,-12(fp)
 8233774:	10801617 	ldw	r2,88(r2)
 8233778:	1007883a 	mov	r3,r2
 823377c:	e0bfff17 	ldw	r2,-4(fp)
 8233780:	10c00015 	stw	r3,0(r2)
      break;
 8233784:	00009f06 	br	8233a04 <sogetopt+0x490>

   case SO_RCVLOWAT:
      *(int *)val = (int)so->so_rcv.sb_lowat;
 8233788:	e0bffd17 	ldw	r2,-12(fp)
 823378c:	10800e17 	ldw	r2,56(r2)
 8233790:	1007883a 	mov	r3,r2
 8233794:	e0bfff17 	ldw	r2,-4(fp)
 8233798:	10c00015 	stw	r3,0(r2)
      break;
 823379c:	00009906 	br	8233a04 <sogetopt+0x490>

   case SO_SNDBUF:
      *(int *)val = (int)so->so_snd.sb_hiwat;
 82337a0:	e0bffd17 	ldw	r2,-12(fp)
 82337a4:	10801317 	ldw	r2,76(r2)
 82337a8:	1007883a 	mov	r3,r2
 82337ac:	e0bfff17 	ldw	r2,-4(fp)
 82337b0:	10c00015 	stw	r3,0(r2)
      break;
 82337b4:	00009306 	br	8233a04 <sogetopt+0x490>

   case SO_RCVBUF:
      *(int *)val = (int)so->so_rcv.sb_hiwat;
 82337b8:	e0bffd17 	ldw	r2,-12(fp)
 82337bc:	10800b17 	ldw	r2,44(r2)
 82337c0:	1007883a 	mov	r3,r2
 82337c4:	e0bfff17 	ldw	r2,-4(fp)
 82337c8:	10c00015 	stw	r3,0(r2)
      break;
 82337cc:	00008d06 	br	8233a04 <sogetopt+0x490>

   case SO_RXDATA:   /* added, JB */
      *(int *)val = (int)so->so_rcv.sb_cc;
 82337d0:	e0bffd17 	ldw	r2,-12(fp)
 82337d4:	10800a17 	ldw	r2,40(r2)
 82337d8:	1007883a 	mov	r3,r2
 82337dc:	e0bfff17 	ldw	r2,-4(fp)
 82337e0:	10c00015 	stw	r3,0(r2)
      break;
 82337e4:	00008706 	br	8233a04 <sogetopt+0x490>

   case SO_TXDATA:   /* added for rel 1.8 */
      *(int *)val = (int)so->so_snd.sb_cc;
 82337e8:	e0bffd17 	ldw	r2,-12(fp)
 82337ec:	10801217 	ldw	r2,72(r2)
 82337f0:	1007883a 	mov	r3,r2
 82337f4:	e0bfff17 	ldw	r2,-4(fp)
 82337f8:	10c00015 	stw	r3,0(r2)
      break;
 82337fc:	00008106 	br	8233a04 <sogetopt+0x490>

   case SO_TYPE:
      *(int *)val = so->so_type;
 8233800:	e0bffd17 	ldw	r2,-12(fp)
 8233804:	10800983 	ldbu	r2,38(r2)
 8233808:	10c03fcc 	andi	r3,r2,255
 823380c:	18c0201c 	xori	r3,r3,128
 8233810:	18ffe004 	addi	r3,r3,-128
 8233814:	e0bfff17 	ldw	r2,-4(fp)
 8233818:	10c00015 	stw	r3,0(r2)
      break;
 823381c:	00007906 	br	8233a04 <sogetopt+0x490>

   case SO_ERROR:
      *(int *)val = so->so_error;
 8233820:	e0bffd17 	ldw	r2,-12(fp)
 8233824:	10c00617 	ldw	r3,24(r2)
 8233828:	e0bfff17 	ldw	r2,-4(fp)
 823382c:	10c00015 	stw	r3,0(r2)
      so->so_error = 0;
 8233830:	e0bffd17 	ldw	r2,-12(fp)
 8233834:	10000615 	stw	zero,24(r2)
      break;
 8233838:	00007206 	br	8233a04 <sogetopt+0x490>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 823383c:	e0bffd17 	ldw	r2,-12(fp)
 8233840:	10800983 	ldbu	r2,38(r2)
 8233844:	10803fcc 	andi	r2,r2,255
 8233848:	1080201c 	xori	r2,r2,128
 823384c:	10bfe004 	addi	r2,r2,-128
 8233850:	10800060 	cmpeqi	r2,r2,1
 8233854:	1000031e 	bne	r2,zero,8233864 <sogetopt+0x2f0>
      {
         error = EINVAL;
 8233858:	00800584 	movi	r2,22
 823385c:	e0bff715 	stw	r2,-36(fp)
         break;
 8233860:	00006806 	br	8233a04 <sogetopt+0x490>
      }
      inp = (struct inpcb *)(so->so_pcb);
 8233864:	e0bffd17 	ldw	r2,-12(fp)
 8233868:	10800117 	ldw	r2,4(r2)
 823386c:	e0bff915 	stw	r2,-28(fp)
      tp = intotcpcb(inp);
 8233870:	e0bff917 	ldw	r2,-28(fp)
 8233874:	10800917 	ldw	r2,36(r2)
 8233878:	e0bffa15 	stw	r2,-24(fp)
      if(!tp)
 823387c:	e0bffa17 	ldw	r2,-24(fp)
 8233880:	1000031e 	bne	r2,zero,8233890 <sogetopt+0x31c>
      {
         error = ENOTCONN;
 8233884:	00802004 	movi	r2,128
 8233888:	e0bff715 	stw	r2,-36(fp)
         break;
 823388c:	00005d06 	br	8233a04 <sogetopt+0x490>
      }
      *(int *)val = tp->t_maxseg;     /* Fill in TCP MSS for current socket */
 8233890:	e0bffa17 	ldw	r2,-24(fp)
 8233894:	10800a0b 	ldhu	r2,40(r2)
 8233898:	10ffffcc 	andi	r3,r2,65535
 823389c:	e0bfff17 	ldw	r2,-4(fp)
 82338a0:	10c00015 	stw	r3,0(r2)
      break;
 82338a4:	00005706 	br	8233a04 <sogetopt+0x490>
   }
 
   case SO_SNDTIMEO:
      *(short*)val = so->so_snd.sb_timeo;
 82338a8:	e0bffd17 	ldw	r2,-12(fp)
 82338ac:	10c0198b 	ldhu	r3,102(r2)
 82338b0:	e0bfff17 	ldw	r2,-4(fp)
 82338b4:	10c0000d 	sth	r3,0(r2)
      break;
 82338b8:	00005206 	br	8233a04 <sogetopt+0x490>

   case SO_RCVTIMEO:
      *(short*)val = so->so_rcv.sb_timeo;
 82338bc:	e0bffd17 	ldw	r2,-12(fp)
 82338c0:	10c0118b 	ldhu	r3,70(r2)
 82338c4:	e0bfff17 	ldw	r2,-4(fp)
 82338c8:	10c0000d 	sth	r3,0(r2)
      break;
 82338cc:	00004d06 	br	8233a04 <sogetopt+0x490>

   case SO_HOPCNT:
      *(int *)val = so->so_hopcnt;
 82338d0:	e0bffd17 	ldw	r2,-12(fp)
 82338d4:	108009c3 	ldbu	r2,39(r2)
 82338d8:	10c03fcc 	andi	r3,r2,255
 82338dc:	18c0201c 	xori	r3,r3,128
 82338e0:	18ffe004 	addi	r3,r3,-128
 82338e4:	e0bfff17 	ldw	r2,-4(fp)
 82338e8:	10c00015 	stw	r3,0(r2)
      break;
 82338ec:	00004506 	br	8233a04 <sogetopt+0x490>

   case SO_NONBLOCK:    /* get blocking mode according to val */
      /* if the non-blocking I/O bit is set in the state */
      if (so->so_state & SS_NBIO)
 82338f0:	e0bffd17 	ldw	r2,-12(fp)
 82338f4:	1080088b 	ldhu	r2,34(r2)
 82338f8:	10bfffcc 	andi	r2,r2,65535
 82338fc:	1080400c 	andi	r2,r2,256
 8233900:	10000426 	beq	r2,zero,8233914 <sogetopt+0x3a0>
         *(int *)val = 1;   /* return 1 in val */
 8233904:	e0bfff17 	ldw	r2,-4(fp)
 8233908:	00c00044 	movi	r3,1
 823390c:	10c00015 	stw	r3,0(r2)
      else
         *(int *)val = 0;     /* return 0 in val */
      break;
 8233910:	00003c06 	br	8233a04 <sogetopt+0x490>
   case SO_NONBLOCK:    /* get blocking mode according to val */
      /* if the non-blocking I/O bit is set in the state */
      if (so->so_state & SS_NBIO)
         *(int *)val = 1;   /* return 1 in val */
      else
         *(int *)val = 0;     /* return 0 in val */
 8233914:	e0bfff17 	ldw	r2,-4(fp)
 8233918:	10000015 	stw	zero,0(r2)
      break;
 823391c:	00003906 	br	8233a04 <sogetopt+0x490>
#ifdef IP_MULTICAST

   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      error = ip_getmoptions(optname, so, val);
 8233920:	e1bfff17 	ldw	r6,-4(fp)
 8233924:	e17ffd17 	ldw	r5,-12(fp)
 8233928:	e13ffe17 	ldw	r4,-8(fp)
 823392c:	82465740 	call	8246574 <ip_getmoptions>
 8233930:	e0bff715 	stw	r2,-36(fp)
      break;
 8233934:	00003306 	br	8233a04 <sogetopt+0x490>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* indicate based on header-include flag in socket state */
      if (so->so_options & SO_HDRINCL)
 8233938:	e0bffd17 	ldw	r2,-12(fp)
 823393c:	10800417 	ldw	r2,16(r2)
 8233940:	1088000c 	andi	r2,r2,8192
 8233944:	10000426 	beq	r2,zero,8233958 <sogetopt+0x3e4>
         *(int *)val = 1;
 8233948:	e0bfff17 	ldw	r2,-4(fp)
 823394c:	00c00044 	movi	r3,1
 8233950:	10c00015 	stw	r3,0(r2)
      else
         *(int *)val = 0;
      break;
 8233954:	00002b06 	br	8233a04 <sogetopt+0x490>
   case IP_HDRINCL:
      /* indicate based on header-include flag in socket state */
      if (so->so_options & SO_HDRINCL)
         *(int *)val = 1;
      else
         *(int *)val = 0;
 8233958:	e0bfff17 	ldw	r2,-4(fp)
 823395c:	10000015 	stw	zero,0(r2)
      break;
 8233960:	00002806 	br	8233a04 <sogetopt+0x490>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 8233964:	e0bffd17 	ldw	r2,-12(fp)
 8233968:	10800983 	ldbu	r2,38(r2)
 823396c:	10803fcc 	andi	r2,r2,255
 8233970:	1080201c 	xori	r2,r2,128
 8233974:	10bfe004 	addi	r2,r2,-128
 8233978:	10800060 	cmpeqi	r2,r2,1
 823397c:	1000031e 	bne	r2,zero,823398c <sogetopt+0x418>
      {
         error = EINVAL;
 8233980:	00800584 	movi	r2,22
 8233984:	e0bff715 	stw	r2,-36(fp)
         break;
 8233988:	00001e06 	br	8233a04 <sogetopt+0x490>
      }
      inp = (struct inpcb *)(so->so_pcb);
 823398c:	e0bffd17 	ldw	r2,-12(fp)
 8233990:	10800117 	ldw	r2,4(r2)
 8233994:	e0bffb15 	stw	r2,-20(fp)
      tp = intotcpcb(inp);
 8233998:	e0bffb17 	ldw	r2,-20(fp)
 823399c:	10800917 	ldw	r2,36(r2)
 82339a0:	e0bffc15 	stw	r2,-16(fp)
      if (!tp)
 82339a4:	e0bffc17 	ldw	r2,-16(fp)
 82339a8:	1000031e 	bne	r2,zero,82339b8 <sogetopt+0x444>
      {
         error = ENOTCONN;
 82339ac:	00802004 	movi	r2,128
 82339b0:	e0bff715 	stw	r2,-36(fp)
         break;
 82339b4:	00001306 	br	8233a04 <sogetopt+0x490>
      }
      /* try to make sure that the argument pointer is valid */
      if (val == NULL)
 82339b8:	e0bfff17 	ldw	r2,-4(fp)
 82339bc:	1000031e 	bne	r2,zero,82339cc <sogetopt+0x458>
      {
         error = ENP_PARAM;
 82339c0:	00bffd84 	movi	r2,-10
 82339c4:	e0bff715 	stw	r2,-36(fp)
         break;
 82339c8:	00000e06 	br	8233a04 <sogetopt+0x490>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (tp->t_flags & TF_NODELAY)
 82339cc:	e0bffc17 	ldw	r2,-16(fp)
 82339d0:	10800b0b 	ldhu	r2,44(r2)
 82339d4:	10bfffcc 	andi	r2,r2,65535
 82339d8:	1080010c 	andi	r2,r2,4
 82339dc:	10000426 	beq	r2,zero,82339f0 <sogetopt+0x47c>
         *(int *)val = 1;  /* Nagle Algorithm is Enabled */
 82339e0:	e0bfff17 	ldw	r2,-4(fp)
 82339e4:	00c00044 	movi	r3,1
 82339e8:	10c00015 	stw	r3,0(r2)
      else
         *(int *)val = 0;  /* Nagle Algorithm is NOT Enabled */

      break;
 82339ec:	00000506 	br	8233a04 <sogetopt+0x490>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (tp->t_flags & TF_NODELAY)
         *(int *)val = 1;  /* Nagle Algorithm is Enabled */
      else
         *(int *)val = 0;  /* Nagle Algorithm is NOT Enabled */
 82339f0:	e0bfff17 	ldw	r2,-4(fp)
 82339f4:	10000015 	stw	zero,0(r2)

      break;
 82339f8:	00000206 	br	8233a04 <sogetopt+0x490>
   }

   default:
      return ENOPROTOOPT;
 82339fc:	00801b44 	movi	r2,109
 8233a00:	00000106 	br	8233a08 <sogetopt+0x494>
   }
   return error;     /* no error */
 8233a04:	e0bff717 	ldw	r2,-36(fp)
}
 8233a08:	e037883a 	mov	sp,fp
 8233a0c:	dfc00117 	ldw	ra,4(sp)
 8233a10:	df000017 	ldw	fp,0(sp)
 8233a14:	dec00204 	addi	sp,sp,8
 8233a18:	f800283a 	ret

08233a1c <sohasoutofband>:
 * RETURNS: 
 */

void
sohasoutofband(struct socket * so)
{
 8233a1c:	defffd04 	addi	sp,sp,-12
 8233a20:	dfc00215 	stw	ra,8(sp)
 8233a24:	df000115 	stw	fp,4(sp)
 8233a28:	df000104 	addi	fp,sp,4
 8233a2c:	e13fff15 	stw	r4,-4(fp)
   so->so_error = EHAVEOOB;   /* WILL be picked up by the socket */
 8233a30:	e0bfff17 	ldw	r2,-4(fp)
 8233a34:	00c03644 	movi	r3,217
 8233a38:	10c00615 	stw	r3,24(r2)
   sorwakeup (so);
 8233a3c:	e0bfff17 	ldw	r2,-4(fp)
 8233a40:	10800a04 	addi	r2,r2,40
 8233a44:	100b883a 	mov	r5,r2
 8233a48:	e13fff17 	ldw	r4,-4(fp)
 8233a4c:	82342440 	call	8234244 <sbwakeup>
}
 8233a50:	0001883a 	nop
 8233a54:	e037883a 	mov	sp,fp
 8233a58:	dfc00117 	ldw	ra,4(sp)
 8233a5c:	df000017 	ldw	fp,0(sp)
 8233a60:	dec00204 	addi	sp,sp,8
 8233a64:	f800283a 	ret

08233a68 <soisconnecting>:
 * RETURNS: 
 */

void
soisconnecting(struct socket * so)
{
 8233a68:	defffd04 	addi	sp,sp,-12
 8233a6c:	dfc00215 	stw	ra,8(sp)
 8233a70:	df000115 	stw	fp,4(sp)
 8233a74:	df000104 	addi	fp,sp,4
 8233a78:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~(SS_ISCONNECTED|SS_ISDISCONNECTING);
 8233a7c:	e0bfff17 	ldw	r2,-4(fp)
 8233a80:	10c0088b 	ldhu	r3,34(r2)
 8233a84:	00bffd44 	movi	r2,-11
 8233a88:	1884703a 	and	r2,r3,r2
 8233a8c:	1007883a 	mov	r3,r2
 8233a90:	e0bfff17 	ldw	r2,-4(fp)
 8233a94:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTING;
 8233a98:	e0bfff17 	ldw	r2,-4(fp)
 8233a9c:	1080088b 	ldhu	r2,34(r2)
 8233aa0:	10800114 	ori	r2,r2,4
 8233aa4:	1007883a 	mov	r3,r2
 8233aa8:	e0bfff17 	ldw	r2,-4(fp)
 8233aac:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 8233ab0:	e0bfff17 	ldw	r2,-4(fp)
 8233ab4:	10800904 	addi	r2,r2,36
 8233ab8:	1009883a 	mov	r4,r2
 8233abc:	82296a80 	call	82296a8 <tcp_wakeup>
}
 8233ac0:	0001883a 	nop
 8233ac4:	e037883a 	mov	sp,fp
 8233ac8:	dfc00117 	ldw	ra,4(sp)
 8233acc:	df000017 	ldw	fp,0(sp)
 8233ad0:	dec00204 	addi	sp,sp,8
 8233ad4:	f800283a 	ret

08233ad8 <soisconnected>:
 * RETURNS: 
 */

void
soisconnected(struct socket * so)
{
 8233ad8:	defffc04 	addi	sp,sp,-16
 8233adc:	dfc00315 	stw	ra,12(sp)
 8233ae0:	df000215 	stw	fp,8(sp)
 8233ae4:	df000204 	addi	fp,sp,8
 8233ae8:	e13fff15 	stw	r4,-4(fp)
   struct socket *   head  =  so->so_head;
 8233aec:	e0bfff17 	ldw	r2,-4(fp)
 8233af0:	10801b17 	ldw	r2,108(r2)
 8233af4:	e0bffe15 	stw	r2,-8(fp)

   if (head) 
 8233af8:	e0bffe17 	ldw	r2,-8(fp)
 8233afc:	10001426 	beq	r2,zero,8233b50 <soisconnected+0x78>
   {
      if (soqremque(so, 0) == 0)
 8233b00:	000b883a 	mov	r5,zero
 8233b04:	e13fff17 	ldw	r4,-4(fp)
 8233b08:	8233fe40 	call	8233fe4 <soqremque>
 8233b0c:	1000031e 	bne	r2,zero,8233b1c <soisconnected+0x44>
         panic("soisconnected");
 8233b10:	01020974 	movhi	r4,2085
 8233b14:	21038a04 	addi	r4,r4,3624
 8233b18:	8228c480 	call	8228c48 <panic>
      soqinsque(head, so, 1);
 8233b1c:	01800044 	movi	r6,1
 8233b20:	e17fff17 	ldw	r5,-4(fp)
 8233b24:	e13ffe17 	ldw	r4,-8(fp)
 8233b28:	8233f380 	call	8233f38 <soqinsque>
      sorwakeup(head);
 8233b2c:	e0bffe17 	ldw	r2,-8(fp)
 8233b30:	10800a04 	addi	r2,r2,40
 8233b34:	100b883a 	mov	r5,r2
 8233b38:	e13ffe17 	ldw	r4,-8(fp)
 8233b3c:	82342440 	call	8234244 <sbwakeup>
      tcp_wakeup ((char *)&head->so_timeo);
 8233b40:	e0bffe17 	ldw	r2,-8(fp)
 8233b44:	10800904 	addi	r2,r2,36
 8233b48:	1009883a 	mov	r4,r2
 8233b4c:	82296a80 	call	82296a8 <tcp_wakeup>
   }

   so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 8233b50:	e0bfff17 	ldw	r2,-4(fp)
 8233b54:	10c0088b 	ldhu	r3,34(r2)
 8233b58:	00bffcc4 	movi	r2,-13
 8233b5c:	1884703a 	and	r2,r3,r2
 8233b60:	1007883a 	mov	r3,r2
 8233b64:	e0bfff17 	ldw	r2,-4(fp)
 8233b68:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTED;
 8233b6c:	e0bfff17 	ldw	r2,-4(fp)
 8233b70:	1080088b 	ldhu	r2,34(r2)
 8233b74:	10800094 	ori	r2,r2,2
 8233b78:	1007883a 	mov	r3,r2
 8233b7c:	e0bfff17 	ldw	r2,-4(fp)
 8233b80:	10c0088d 	sth	r3,34(r2)
   so->so_error = 0;
 8233b84:	e0bfff17 	ldw	r2,-4(fp)
 8233b88:	10000615 	stw	zero,24(r2)
   tcp_wakeup  ((char *)&so->so_timeo);
 8233b8c:	e0bfff17 	ldw	r2,-4(fp)
 8233b90:	10800904 	addi	r2,r2,36
 8233b94:	1009883a 	mov	r4,r2
 8233b98:	82296a80 	call	82296a8 <tcp_wakeup>
   sorwakeup (so);
 8233b9c:	e0bfff17 	ldw	r2,-4(fp)
 8233ba0:	10800a04 	addi	r2,r2,40
 8233ba4:	100b883a 	mov	r5,r2
 8233ba8:	e13fff17 	ldw	r4,-4(fp)
 8233bac:	82342440 	call	8234244 <sbwakeup>
   sowwakeup (so);
 8233bb0:	e0bfff17 	ldw	r2,-4(fp)
 8233bb4:	10801204 	addi	r2,r2,72
 8233bb8:	100b883a 	mov	r5,r2
 8233bbc:	e13fff17 	ldw	r4,-4(fp)
 8233bc0:	82342440 	call	8234244 <sbwakeup>
}
 8233bc4:	0001883a 	nop
 8233bc8:	e037883a 	mov	sp,fp
 8233bcc:	dfc00117 	ldw	ra,4(sp)
 8233bd0:	df000017 	ldw	fp,0(sp)
 8233bd4:	dec00204 	addi	sp,sp,8
 8233bd8:	f800283a 	ret

08233bdc <soisdisconnecting>:
 * RETURNS: 
 */

void
soisdisconnecting(struct socket * so)
{
 8233bdc:	defffd04 	addi	sp,sp,-12
 8233be0:	dfc00215 	stw	ra,8(sp)
 8233be4:	df000115 	stw	fp,4(sp)
 8233be8:	df000104 	addi	fp,sp,4
 8233bec:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~SS_ISCONNECTING;
 8233bf0:	e0bfff17 	ldw	r2,-4(fp)
 8233bf4:	10c0088b 	ldhu	r3,34(r2)
 8233bf8:	00bffec4 	movi	r2,-5
 8233bfc:	1884703a 	and	r2,r3,r2
 8233c00:	1007883a 	mov	r3,r2
 8233c04:	e0bfff17 	ldw	r2,-4(fp)
 8233c08:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_ISDISCONNECTING|SS_CANTRCVMORE|SS_CANTSENDMORE);
 8233c0c:	e0bfff17 	ldw	r2,-4(fp)
 8233c10:	1080088b 	ldhu	r2,34(r2)
 8233c14:	10800e14 	ori	r2,r2,56
 8233c18:	1007883a 	mov	r3,r2
 8233c1c:	e0bfff17 	ldw	r2,-4(fp)
 8233c20:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup  ((char *)&so->so_timeo);   
 8233c24:	e0bfff17 	ldw	r2,-4(fp)
 8233c28:	10800904 	addi	r2,r2,36
 8233c2c:	1009883a 	mov	r4,r2
 8233c30:	82296a80 	call	82296a8 <tcp_wakeup>
   sowwakeup (so);
 8233c34:	e0bfff17 	ldw	r2,-4(fp)
 8233c38:	10801204 	addi	r2,r2,72
 8233c3c:	100b883a 	mov	r5,r2
 8233c40:	e13fff17 	ldw	r4,-4(fp)
 8233c44:	82342440 	call	8234244 <sbwakeup>
   sorwakeup (so);
 8233c48:	e0bfff17 	ldw	r2,-4(fp)
 8233c4c:	10800a04 	addi	r2,r2,40
 8233c50:	100b883a 	mov	r5,r2
 8233c54:	e13fff17 	ldw	r4,-4(fp)
 8233c58:	82342440 	call	8234244 <sbwakeup>
}
 8233c5c:	0001883a 	nop
 8233c60:	e037883a 	mov	sp,fp
 8233c64:	dfc00117 	ldw	ra,4(sp)
 8233c68:	df000017 	ldw	fp,0(sp)
 8233c6c:	dec00204 	addi	sp,sp,8
 8233c70:	f800283a 	ret

08233c74 <soisdisconnected>:
 * RETURNS: 
 */

void
soisdisconnected(struct socket * so)
{
 8233c74:	defffd04 	addi	sp,sp,-12
 8233c78:	dfc00215 	stw	ra,8(sp)
 8233c7c:	df000115 	stw	fp,4(sp)
 8233c80:	df000104 	addi	fp,sp,4
 8233c84:	e13fff15 	stw	r4,-4(fp)
   if (so->so_state & SS_ISCONNECTING)
 8233c88:	e0bfff17 	ldw	r2,-4(fp)
 8233c8c:	1080088b 	ldhu	r2,34(r2)
 8233c90:	10bfffcc 	andi	r2,r2,65535
 8233c94:	1080010c 	andi	r2,r2,4
 8233c98:	10000626 	beq	r2,zero,8233cb4 <soisdisconnected+0x40>
      so->so_state |= SS_WASCONNECTING;
 8233c9c:	e0bfff17 	ldw	r2,-4(fp)
 8233ca0:	1080088b 	ldhu	r2,34(r2)
 8233ca4:	10880014 	ori	r2,r2,8192
 8233ca8:	1007883a 	mov	r3,r2
 8233cac:	e0bfff17 	ldw	r2,-4(fp)
 8233cb0:	10c0088d 	sth	r3,34(r2)
   so->so_state &= ~(SS_ISCONNECTING|SS_ISCONNECTED|SS_ISDISCONNECTING);
 8233cb4:	e0bfff17 	ldw	r2,-4(fp)
 8233cb8:	10c0088b 	ldhu	r3,34(r2)
 8233cbc:	00bffc44 	movi	r2,-15
 8233cc0:	1884703a 	and	r2,r3,r2
 8233cc4:	1007883a 	mov	r3,r2
 8233cc8:	e0bfff17 	ldw	r2,-4(fp)
 8233ccc:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_CANTRCVMORE|SS_CANTSENDMORE);
 8233cd0:	e0bfff17 	ldw	r2,-4(fp)
 8233cd4:	1080088b 	ldhu	r2,34(r2)
 8233cd8:	10800c14 	ori	r2,r2,48
 8233cdc:	1007883a 	mov	r3,r2
 8233ce0:	e0bfff17 	ldw	r2,-4(fp)
 8233ce4:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 8233ce8:	e0bfff17 	ldw	r2,-4(fp)
 8233cec:	10800904 	addi	r2,r2,36
 8233cf0:	1009883a 	mov	r4,r2
 8233cf4:	82296a80 	call	82296a8 <tcp_wakeup>
   sowwakeup (so);
 8233cf8:	e0bfff17 	ldw	r2,-4(fp)
 8233cfc:	10801204 	addi	r2,r2,72
 8233d00:	100b883a 	mov	r5,r2
 8233d04:	e13fff17 	ldw	r4,-4(fp)
 8233d08:	82342440 	call	8234244 <sbwakeup>
   sorwakeup (so);
 8233d0c:	e0bfff17 	ldw	r2,-4(fp)
 8233d10:	10800a04 	addi	r2,r2,40
 8233d14:	100b883a 	mov	r5,r2
 8233d18:	e13fff17 	ldw	r4,-4(fp)
 8233d1c:	82342440 	call	8234244 <sbwakeup>
}
 8233d20:	0001883a 	nop
 8233d24:	e037883a 	mov	sp,fp
 8233d28:	dfc00117 	ldw	ra,4(sp)
 8233d2c:	df000017 	ldw	fp,0(sp)
 8233d30:	dec00204 	addi	sp,sp,8
 8233d34:	f800283a 	ret

08233d38 <sonewconn>:
 * RETURNS: 
 */

struct socket *   
sonewconn(struct socket * head)
{
 8233d38:	defffb04 	addi	sp,sp,-20
 8233d3c:	dfc00415 	stw	ra,16(sp)
 8233d40:	df000315 	stw	fp,12(sp)
 8233d44:	df000304 	addi	fp,sp,12
 8233d48:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so;
   int rc;  

   if (head->so_qlen + head->so_q0len > 3 * head->so_qlimit / 2)
 8233d4c:	e0bfff17 	ldw	r2,-4(fp)
 8233d50:	10801e43 	ldbu	r2,121(r2)
 8233d54:	10c03fcc 	andi	r3,r2,255
 8233d58:	18c0201c 	xori	r3,r3,128
 8233d5c:	18ffe004 	addi	r3,r3,-128
 8233d60:	e0bfff17 	ldw	r2,-4(fp)
 8233d64:	10801e03 	ldbu	r2,120(r2)
 8233d68:	10803fcc 	andi	r2,r2,255
 8233d6c:	1080201c 	xori	r2,r2,128
 8233d70:	10bfe004 	addi	r2,r2,-128
 8233d74:	1889883a 	add	r4,r3,r2
 8233d78:	e0bfff17 	ldw	r2,-4(fp)
 8233d7c:	10801e83 	ldbu	r2,122(r2)
 8233d80:	10c03fcc 	andi	r3,r2,255
 8233d84:	18c0201c 	xori	r3,r3,128
 8233d88:	18ffe004 	addi	r3,r3,-128
 8233d8c:	1805883a 	mov	r2,r3
 8233d90:	1085883a 	add	r2,r2,r2
 8233d94:	10c5883a 	add	r2,r2,r3
 8233d98:	1006d7fa 	srli	r3,r2,31
 8233d9c:	1885883a 	add	r2,r3,r2
 8233da0:	1005d07a 	srai	r2,r2,1
 8233da4:	11005b16 	blt	r2,r4,8233f14 <sonewconn+0x1dc>
      goto bad;
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 8233da8:	01002104 	movi	r4,132
 8233dac:	822e16c0 	call	822e16c <npalloc>
 8233db0:	e0bffd15 	stw	r2,-12(fp)
 8233db4:	e0bffd17 	ldw	r2,-12(fp)
 8233db8:	10005826 	beq	r2,zero,8233f1c <sonewconn+0x1e4>
      goto bad;
   so->next = NULL;
 8233dbc:	e0bffd17 	ldw	r2,-12(fp)
 8233dc0:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);      /* Place newly created socket in a queue */
 8233dc4:	e17ffd17 	ldw	r5,-12(fp)
 8233dc8:	010209b4 	movhi	r4,2086
 8233dcc:	21395804 	addi	r4,r4,-6816
 8233dd0:	822cf7c0 	call	822cf7c <putq>
   so->so_type = head->so_type;
 8233dd4:	e0bfff17 	ldw	r2,-4(fp)
 8233dd8:	10c00983 	ldbu	r3,38(r2)
 8233ddc:	e0bffd17 	ldw	r2,-12(fp)
 8233de0:	10c00985 	stb	r3,38(r2)
   so->so_options = head->so_options &~ (unshort)SO_ACCEPTCONN;
 8233de4:	e0bfff17 	ldw	r2,-4(fp)
 8233de8:	10c00417 	ldw	r3,16(r2)
 8233dec:	00bfff44 	movi	r2,-3
 8233df0:	1886703a 	and	r3,r3,r2
 8233df4:	e0bffd17 	ldw	r2,-12(fp)
 8233df8:	10c00415 	stw	r3,16(r2)
   so->so_linger = head->so_linger;
 8233dfc:	e0bfff17 	ldw	r2,-4(fp)
 8233e00:	10c0080b 	ldhu	r3,32(r2)
 8233e04:	e0bffd17 	ldw	r2,-12(fp)
 8233e08:	10c0080d 	sth	r3,32(r2)
   so->so_state = head->so_state | (unshort)SS_NOFDREF;
 8233e0c:	e0bfff17 	ldw	r2,-4(fp)
 8233e10:	1080088b 	ldhu	r2,34(r2)
 8233e14:	10800054 	ori	r2,r2,1
 8233e18:	1007883a 	mov	r3,r2
 8233e1c:	e0bffd17 	ldw	r2,-12(fp)
 8233e20:	10c0088d 	sth	r3,34(r2)
   so->so_proto = head->so_proto;
 8233e24:	e0bfff17 	ldw	r2,-4(fp)
 8233e28:	10c00217 	ldw	r3,8(r2)
 8233e2c:	e0bffd17 	ldw	r2,-12(fp)
 8233e30:	10c00215 	stw	r3,8(r2)
   so->so_timeo = head->so_timeo;
 8233e34:	e0bfff17 	ldw	r2,-4(fp)
 8233e38:	10c0090b 	ldhu	r3,36(r2)
 8233e3c:	e0bffd17 	ldw	r2,-12(fp)
 8233e40:	10c0090d 	sth	r3,36(r2)
   so->so_rcv.sb_hiwat = (u_int)tcp_recvspace;
 8233e44:	d0e04117 	ldw	r3,-32508(gp)
 8233e48:	e0bffd17 	ldw	r2,-12(fp)
 8233e4c:	10c00b15 	stw	r3,44(r2)
   so->so_snd.sb_hiwat = (u_int)tcp_sendspace;
 8233e50:	d0e04017 	ldw	r3,-32512(gp)
 8233e54:	e0bffd17 	ldw	r2,-12(fp)
 8233e58:	10c01315 	stw	r3,76(r2)
   soqinsque (head, so, 0);
 8233e5c:	000d883a 	mov	r6,zero
 8233e60:	e17ffd17 	ldw	r5,-12(fp)
 8233e64:	e13fff17 	ldw	r4,-4(fp)
 8233e68:	8233f380 	call	8233f38 <soqinsque>
   so->so_req = PRU_ATTACH;
 8233e6c:	e0bffd17 	ldw	r2,-12(fp)
 8233e70:	10000715 	stw	zero,28(r2)
   so->so_domain = head->so_domain;
 8233e74:	e0bfff17 	ldw	r2,-4(fp)
 8233e78:	10c00517 	ldw	r3,20(r2)
 8233e7c:	e0bffd17 	ldw	r2,-12(fp)
 8233e80:	10c00515 	stw	r3,20(r2)

   if ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0))
 8233e84:	e0bffd17 	ldw	r2,-12(fp)
 8233e88:	10800217 	ldw	r2,8(r2)
 8233e8c:	10800317 	ldw	r2,12(r2)
 8233e90:	000d883a 	mov	r6,zero
 8233e94:	000b883a 	mov	r5,zero
 8233e98:	e13ffd17 	ldw	r4,-12(fp)
 8233e9c:	103ee83a 	callr	r2
 8233ea0:	10000f1e 	bne	r2,zero,8233ee0 <sonewconn+0x1a8>
      goto bad2;
   if (so_evtmap)
 8233ea4:	d0a0ce03 	ldbu	r2,-31944(gp)
 8233ea8:	10803fcc 	andi	r2,r2,255
 8233eac:	10000a26 	beq	r2,zero,8233ed8 <sonewconn+0x1a0>
   {
      rc = (*so_evtmap_create) (so);                       
 8233eb0:	d0a0cc17 	ldw	r2,-31952(gp)
 8233eb4:	e13ffd17 	ldw	r4,-12(fp)
 8233eb8:	103ee83a 	callr	r2
 8233ebc:	e0bffe15 	stw	r2,-8(fp)
      if (rc != 0) goto bad2;
 8233ec0:	e0bffe17 	ldw	r2,-8(fp)
 8233ec4:	1000081e 	bne	r2,zero,8233ee8 <sonewconn+0x1b0>
      so->owner = head->owner;
 8233ec8:	e0bfff17 	ldw	r2,-4(fp)
 8233ecc:	10c02003 	ldbu	r3,128(r2)
 8233ed0:	e0bffd17 	ldw	r2,-12(fp)
 8233ed4:	10c02005 	stb	r3,128(r2)
   }
   return (so);
 8233ed8:	e0bffd17 	ldw	r2,-12(fp)
 8233edc:	00001106 	br	8233f24 <sonewconn+0x1ec>
   soqinsque (head, so, 0);
   so->so_req = PRU_ATTACH;
   so->so_domain = head->so_domain;

   if ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0))
      goto bad2;
 8233ee0:	0001883a 	nop
 8233ee4:	00000106 	br	8233eec <sonewconn+0x1b4>
   if (so_evtmap)
   {
      rc = (*so_evtmap_create) (so);                       
      if (rc != 0) goto bad2;
 8233ee8:	0001883a 	nop
      so->owner = head->owner;
   }
   return (so);
   
bad2:
   (void) soqremque (so, 0);
 8233eec:	000b883a 	mov	r5,zero
 8233ef0:	e13ffd17 	ldw	r4,-12(fp)
 8233ef4:	8233fe40 	call	8233fe4 <soqremque>
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 8233ef8:	e17ffd17 	ldw	r5,-12(fp)
 8233efc:	010209b4 	movhi	r4,2086
 8233f00:	21395804 	addi	r4,r4,-6816
 8233f04:	822d02c0 	call	822d02c <qdel>
   SOC_FREE(so);  /* Free the socket structure */
 8233f08:	e13ffd17 	ldw	r4,-12(fp)
 8233f0c:	822e1a00 	call	822e1a0 <npfree>
 8233f10:	00000306 	br	8233f20 <sonewconn+0x1e8>
{
   struct socket *   so;
   int rc;  

   if (head->so_qlen + head->so_q0len > 3 * head->so_qlimit / 2)
      goto bad;
 8233f14:	0001883a 	nop
 8233f18:	00000106 	br	8233f20 <sonewconn+0x1e8>
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
      goto bad;
 8233f1c:	0001883a 	nop
bad2:
   (void) soqremque (so, 0);
   qdel(&soq, so);   /* Delete the socket entry from the queue */
   SOC_FREE(so);  /* Free the socket structure */
bad:
   return ((struct socket *)0);
 8233f20:	0005883a 	mov	r2,zero
}
 8233f24:	e037883a 	mov	sp,fp
 8233f28:	dfc00117 	ldw	ra,4(sp)
 8233f2c:	df000017 	ldw	fp,0(sp)
 8233f30:	dec00204 	addi	sp,sp,8
 8233f34:	f800283a 	ret

08233f38 <soqinsque>:

void
soqinsque(struct socket * head, 
   struct socket *   so,
   int   q)
{
 8233f38:	defffc04 	addi	sp,sp,-16
 8233f3c:	df000315 	stw	fp,12(sp)
 8233f40:	df000304 	addi	fp,sp,12
 8233f44:	e13ffd15 	stw	r4,-12(fp)
 8233f48:	e17ffe15 	stw	r5,-8(fp)
 8233f4c:	e1bfff15 	stw	r6,-4(fp)
   so->so_head = head;
 8233f50:	e0bffe17 	ldw	r2,-8(fp)
 8233f54:	e0fffd17 	ldw	r3,-12(fp)
 8233f58:	10c01b15 	stw	r3,108(r2)
   if (q == 0) 
 8233f5c:	e0bfff17 	ldw	r2,-4(fp)
 8233f60:	10000e1e 	bne	r2,zero,8233f9c <soqinsque+0x64>
   {
      head->so_q0len++;
 8233f64:	e0bffd17 	ldw	r2,-12(fp)
 8233f68:	10801e03 	ldbu	r2,120(r2)
 8233f6c:	10800044 	addi	r2,r2,1
 8233f70:	1007883a 	mov	r3,r2
 8233f74:	e0bffd17 	ldw	r2,-12(fp)
 8233f78:	10c01e05 	stb	r3,120(r2)
      so->so_q0 = head->so_q0;
 8233f7c:	e0bffd17 	ldw	r2,-12(fp)
 8233f80:	10c01c17 	ldw	r3,112(r2)
 8233f84:	e0bffe17 	ldw	r2,-8(fp)
 8233f88:	10c01c15 	stw	r3,112(r2)
      head->so_q0 = so;
 8233f8c:	e0bffd17 	ldw	r2,-12(fp)
 8233f90:	e0fffe17 	ldw	r3,-8(fp)
 8233f94:	10c01c15 	stw	r3,112(r2)
   {
      head->so_qlen++;
      so->so_q = head->so_q;
      head->so_q = so;
   }
}
 8233f98:	00000d06 	br	8233fd0 <soqinsque+0x98>
      head->so_q0len++;
      so->so_q0 = head->so_q0;
      head->so_q0 = so;
   } else 
   {
      head->so_qlen++;
 8233f9c:	e0bffd17 	ldw	r2,-12(fp)
 8233fa0:	10801e43 	ldbu	r2,121(r2)
 8233fa4:	10800044 	addi	r2,r2,1
 8233fa8:	1007883a 	mov	r3,r2
 8233fac:	e0bffd17 	ldw	r2,-12(fp)
 8233fb0:	10c01e45 	stb	r3,121(r2)
      so->so_q = head->so_q;
 8233fb4:	e0bffd17 	ldw	r2,-12(fp)
 8233fb8:	10c01d17 	ldw	r3,116(r2)
 8233fbc:	e0bffe17 	ldw	r2,-8(fp)
 8233fc0:	10c01d15 	stw	r3,116(r2)
      head->so_q = so;
 8233fc4:	e0bffd17 	ldw	r2,-12(fp)
 8233fc8:	e0fffe17 	ldw	r3,-8(fp)
 8233fcc:	10c01d15 	stw	r3,116(r2)
   }
}
 8233fd0:	0001883a 	nop
 8233fd4:	e037883a 	mov	sp,fp
 8233fd8:	df000017 	ldw	fp,0(sp)
 8233fdc:	dec00104 	addi	sp,sp,4
 8233fe0:	f800283a 	ret

08233fe4 <soqremque>:
 * RETURNS: 
 */

int
soqremque(struct socket * so, int q)
{
 8233fe4:	defffa04 	addi	sp,sp,-24
 8233fe8:	df000515 	stw	fp,20(sp)
 8233fec:	df000504 	addi	fp,sp,20
 8233ff0:	e13ffe15 	stw	r4,-8(fp)
 8233ff4:	e17fff15 	stw	r5,-4(fp)
   struct socket *   head, *  prev, *  next;

   head = so->so_head;
 8233ff8:	e0bffe17 	ldw	r2,-8(fp)
 8233ffc:	10801b17 	ldw	r2,108(r2)
 8234000:	e0bffc15 	stw	r2,-16(fp)
   prev = head;
 8234004:	e0bffc17 	ldw	r2,-16(fp)
 8234008:	e0bffb15 	stw	r2,-20(fp)
   for (;;) 
   {
      next = q ? prev->so_q : prev->so_q0;
 823400c:	e0bfff17 	ldw	r2,-4(fp)
 8234010:	10000326 	beq	r2,zero,8234020 <soqremque+0x3c>
 8234014:	e0bffb17 	ldw	r2,-20(fp)
 8234018:	10801d17 	ldw	r2,116(r2)
 823401c:	00000206 	br	8234028 <soqremque+0x44>
 8234020:	e0bffb17 	ldw	r2,-20(fp)
 8234024:	10801c17 	ldw	r2,112(r2)
 8234028:	e0bffd15 	stw	r2,-12(fp)
      if (next == so)
 823402c:	e0fffd17 	ldw	r3,-12(fp)
 8234030:	e0bffe17 	ldw	r2,-8(fp)
 8234034:	18800826 	beq	r3,r2,8234058 <soqremque+0x74>
         break;
      if (next == head)
 8234038:	e0fffd17 	ldw	r3,-12(fp)
 823403c:	e0bffc17 	ldw	r2,-16(fp)
 8234040:	1880021e 	bne	r3,r2,823404c <soqremque+0x68>
         return (0);
 8234044:	0005883a 	mov	r2,zero
 8234048:	00002406 	br	82340dc <soqremque+0xf8>
      prev = next;
 823404c:	e0bffd17 	ldw	r2,-12(fp)
 8234050:	e0bffb15 	stw	r2,-20(fp)
   }
 8234054:	003fed06 	br	823400c <soqremque+0x28>
   prev = head;
   for (;;) 
   {
      next = q ? prev->so_q : prev->so_q0;
      if (next == so)
         break;
 8234058:	0001883a 	nop
      if (next == head)
         return (0);
      prev = next;
   }
   if (q == 0) 
 823405c:	e0bfff17 	ldw	r2,-4(fp)
 8234060:	10000b1e 	bne	r2,zero,8234090 <soqremque+0xac>
   {
      prev->so_q0 = next->so_q0;
 8234064:	e0bffd17 	ldw	r2,-12(fp)
 8234068:	10c01c17 	ldw	r3,112(r2)
 823406c:	e0bffb17 	ldw	r2,-20(fp)
 8234070:	10c01c15 	stw	r3,112(r2)
      head->so_q0len--;
 8234074:	e0bffc17 	ldw	r2,-16(fp)
 8234078:	10801e03 	ldbu	r2,120(r2)
 823407c:	10bfffc4 	addi	r2,r2,-1
 8234080:	1007883a 	mov	r3,r2
 8234084:	e0bffc17 	ldw	r2,-16(fp)
 8234088:	10c01e05 	stb	r3,120(r2)
 823408c:	00000a06 	br	82340b8 <soqremque+0xd4>
   } else 
   {
      prev->so_q = next->so_q;
 8234090:	e0bffd17 	ldw	r2,-12(fp)
 8234094:	10c01d17 	ldw	r3,116(r2)
 8234098:	e0bffb17 	ldw	r2,-20(fp)
 823409c:	10c01d15 	stw	r3,116(r2)
      head->so_qlen--;
 82340a0:	e0bffc17 	ldw	r2,-16(fp)
 82340a4:	10801e43 	ldbu	r2,121(r2)
 82340a8:	10bfffc4 	addi	r2,r2,-1
 82340ac:	1007883a 	mov	r3,r2
 82340b0:	e0bffc17 	ldw	r2,-16(fp)
 82340b4:	10c01e45 	stb	r3,121(r2)
   }
   next->so_q0 = next->so_q = 0;
 82340b8:	e0bffd17 	ldw	r2,-12(fp)
 82340bc:	10001d15 	stw	zero,116(r2)
 82340c0:	e0bffd17 	ldw	r2,-12(fp)
 82340c4:	10c01d17 	ldw	r3,116(r2)
 82340c8:	e0bffd17 	ldw	r2,-12(fp)
 82340cc:	10c01c15 	stw	r3,112(r2)
   next->so_head = 0;
 82340d0:	e0bffd17 	ldw	r2,-12(fp)
 82340d4:	10001b15 	stw	zero,108(r2)
   return 1;
 82340d8:	00800044 	movi	r2,1
}
 82340dc:	e037883a 	mov	sp,fp
 82340e0:	df000017 	ldw	fp,0(sp)
 82340e4:	dec00104 	addi	sp,sp,4
 82340e8:	f800283a 	ret

082340ec <socantsendmore>:
 * RETURNS: 
 */

void
socantsendmore(struct socket * so)
{
 82340ec:	defffd04 	addi	sp,sp,-12
 82340f0:	dfc00215 	stw	ra,8(sp)
 82340f4:	df000115 	stw	fp,4(sp)
 82340f8:	df000104 	addi	fp,sp,4
 82340fc:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTSENDMORE;
 8234100:	e0bfff17 	ldw	r2,-4(fp)
 8234104:	1080088b 	ldhu	r2,34(r2)
 8234108:	10800414 	ori	r2,r2,16
 823410c:	1007883a 	mov	r3,r2
 8234110:	e0bfff17 	ldw	r2,-4(fp)
 8234114:	10c0088d 	sth	r3,34(r2)
   sowwakeup(so);
 8234118:	e0bfff17 	ldw	r2,-4(fp)
 823411c:	10801204 	addi	r2,r2,72
 8234120:	100b883a 	mov	r5,r2
 8234124:	e13fff17 	ldw	r4,-4(fp)
 8234128:	82342440 	call	8234244 <sbwakeup>
}
 823412c:	0001883a 	nop
 8234130:	e037883a 	mov	sp,fp
 8234134:	dfc00117 	ldw	ra,4(sp)
 8234138:	df000017 	ldw	fp,0(sp)
 823413c:	dec00204 	addi	sp,sp,8
 8234140:	f800283a 	ret

08234144 <socantrcvmore>:
 * RETURNS: 
 */

void
socantrcvmore(struct socket * so)
{
 8234144:	defffd04 	addi	sp,sp,-12
 8234148:	dfc00215 	stw	ra,8(sp)
 823414c:	df000115 	stw	fp,4(sp)
 8234150:	df000104 	addi	fp,sp,4
 8234154:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTRCVMORE;
 8234158:	e0bfff17 	ldw	r2,-4(fp)
 823415c:	1080088b 	ldhu	r2,34(r2)
 8234160:	10800814 	ori	r2,r2,32
 8234164:	1007883a 	mov	r3,r2
 8234168:	e0bfff17 	ldw	r2,-4(fp)
 823416c:	10c0088d 	sth	r3,34(r2)
   sorwakeup(so);
 8234170:	e0bfff17 	ldw	r2,-4(fp)
 8234174:	10800a04 	addi	r2,r2,40
 8234178:	100b883a 	mov	r5,r2
 823417c:	e13fff17 	ldw	r4,-4(fp)
 8234180:	82342440 	call	8234244 <sbwakeup>
}
 8234184:	0001883a 	nop
 8234188:	e037883a 	mov	sp,fp
 823418c:	dfc00117 	ldw	ra,4(sp)
 8234190:	df000017 	ldw	fp,0(sp)
 8234194:	dec00204 	addi	sp,sp,8
 8234198:	f800283a 	ret

0823419c <sbselqueue>:
 * RETURNS: 
 */

void
sbselqueue(struct sockbuf * sb)
{
 823419c:	defffe04 	addi	sp,sp,-8
 82341a0:	df000115 	stw	fp,4(sp)
 82341a4:	df000104 	addi	fp,sp,4
 82341a8:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_SEL;
 82341ac:	e0bfff17 	ldw	r2,-4(fp)
 82341b0:	1080070b 	ldhu	r2,28(r2)
 82341b4:	10800214 	ori	r2,r2,8
 82341b8:	1007883a 	mov	r3,r2
 82341bc:	e0bfff17 	ldw	r2,-4(fp)
 82341c0:	10c0070d 	sth	r3,28(r2)
}
 82341c4:	0001883a 	nop
 82341c8:	e037883a 	mov	sp,fp
 82341cc:	df000017 	ldw	fp,0(sp)
 82341d0:	dec00104 	addi	sp,sp,4
 82341d4:	f800283a 	ret

082341d8 <sbwait>:
 * RETURNS: 
 */

void
sbwait(struct sockbuf * sb)
{
 82341d8:	defffd04 	addi	sp,sp,-12
 82341dc:	dfc00215 	stw	ra,8(sp)
 82341e0:	df000115 	stw	fp,4(sp)
 82341e4:	df000104 	addi	fp,sp,4
 82341e8:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_WAIT;
 82341ec:	e0bfff17 	ldw	r2,-4(fp)
 82341f0:	1080070b 	ldhu	r2,28(r2)
 82341f4:	10800114 	ori	r2,r2,4
 82341f8:	1007883a 	mov	r3,r2
 82341fc:	e0bfff17 	ldw	r2,-4(fp)
 8234200:	10c0070d 	sth	r3,28(r2)
   tcp_sleep ((char *)&sb->sb_cc);
 8234204:	e0bfff17 	ldw	r2,-4(fp)
 8234208:	1009883a 	mov	r4,r2
 823420c:	82295340 	call	8229534 <tcp_sleep>
   sb->sb_flags &= ~SB_WAIT;
 8234210:	e0bfff17 	ldw	r2,-4(fp)
 8234214:	10c0070b 	ldhu	r3,28(r2)
 8234218:	00bffec4 	movi	r2,-5
 823421c:	1884703a 	and	r2,r3,r2
 8234220:	1007883a 	mov	r3,r2
 8234224:	e0bfff17 	ldw	r2,-4(fp)
 8234228:	10c0070d 	sth	r3,28(r2)
}
 823422c:	0001883a 	nop
 8234230:	e037883a 	mov	sp,fp
 8234234:	dfc00117 	ldw	ra,4(sp)
 8234238:	df000017 	ldw	fp,0(sp)
 823423c:	dec00204 	addi	sp,sp,8
 8234240:	f800283a 	ret

08234244 <sbwakeup>:
 * RETURNS: 
 */

void
sbwakeup(struct socket * so, struct sockbuf * sb)
{
 8234244:	defffc04 	addi	sp,sp,-16
 8234248:	dfc00315 	stw	ra,12(sp)
 823424c:	df000215 	stw	fp,8(sp)
 8234250:	df000204 	addi	fp,sp,8
 8234254:	e13ffe15 	stw	r4,-8(fp)
 8234258:	e17fff15 	stw	r5,-4(fp)
   if (sb->sb_flags & SB_SEL) 
 823425c:	e0bfff17 	ldw	r2,-4(fp)
 8234260:	1080070b 	ldhu	r2,28(r2)
 8234264:	10bfffcc 	andi	r2,r2,65535
 8234268:	1080020c 	andi	r2,r2,8
 823426c:	10000a26 	beq	r2,zero,8234298 <sbwakeup+0x54>
   {
      select_wait = 0;
 8234270:	d020b00d 	sth	zero,-32064(gp)
#ifndef SOCK_MAP_EVENTS
      tcp_wakeup ((char *)&select_wait);
 8234274:	d120b004 	addi	r4,gp,-32064
 8234278:	82296a80 	call	82296a8 <tcp_wakeup>
#else
      tcp_wakeup2 (so->owner);
#endif      
      sb->sb_flags &= ~SB_SEL;
 823427c:	e0bfff17 	ldw	r2,-4(fp)
 8234280:	10c0070b 	ldhu	r3,28(r2)
 8234284:	00bffdc4 	movi	r2,-9
 8234288:	1884703a 	and	r2,r3,r2
 823428c:	1007883a 	mov	r3,r2
 8234290:	e0bfff17 	ldw	r2,-4(fp)
 8234294:	10c0070d 	sth	r3,28(r2)
#ifdef SOCK_WAKEALWAYS  /* Always wake the socket? */
   /* Systems Like Green Hills Integrity RTOS, need to process socket
      input even if looks like no one is blocked on the socket */
   tcp_wakeup ((char *)&sb->sb_cc); /* signal wake on socket */
#else /* older BSD style code - only call tcp_wakeup if blocked */
   if (sb->sb_flags & SB_WAIT)   /* is sockbuf's WAIT flag set? */
 8234298:	e0bfff17 	ldw	r2,-4(fp)
 823429c:	1080070b 	ldhu	r2,28(r2)
 82342a0:	10bfffcc 	andi	r2,r2,65535
 82342a4:	1080010c 	andi	r2,r2,4
 82342a8:	10000326 	beq	r2,zero,82342b8 <sbwakeup+0x74>
   {
      tcp_wakeup ((char *)&sb->sb_cc);   /* call port wakeup routine */
 82342ac:	e0bfff17 	ldw	r2,-4(fp)
 82342b0:	1009883a 	mov	r4,r2
 82342b4:	82296a80 	call	82296a8 <tcp_wakeup>
   }
#endif   /* SOCK_WAKEALWAYS */
}
 82342b8:	0001883a 	nop
 82342bc:	e037883a 	mov	sp,fp
 82342c0:	dfc00117 	ldw	ra,4(sp)
 82342c4:	df000017 	ldw	fp,0(sp)
 82342c8:	dec00204 	addi	sp,sp,8
 82342cc:	f800283a 	ret

082342d0 <soreserve>:

int
soreserve(struct socket * so, 
   u_long   sndcc, 
   u_long   rcvcc)
{
 82342d0:	defffb04 	addi	sp,sp,-20
 82342d4:	dfc00415 	stw	ra,16(sp)
 82342d8:	df000315 	stw	fp,12(sp)
 82342dc:	df000304 	addi	fp,sp,12
 82342e0:	e13ffd15 	stw	r4,-12(fp)
 82342e4:	e17ffe15 	stw	r5,-8(fp)
 82342e8:	e1bfff15 	stw	r6,-4(fp)
   if (sbreserve(&so->so_snd, sndcc) == 0)
 82342ec:	e0bffd17 	ldw	r2,-12(fp)
 82342f0:	10801204 	addi	r2,r2,72
 82342f4:	e17ffe17 	ldw	r5,-8(fp)
 82342f8:	1009883a 	mov	r4,r2
 82342fc:	82343580 	call	8234358 <sbreserve>
 8234300:	10000e26 	beq	r2,zero,823433c <soreserve+0x6c>
      goto bad;
   if (sbreserve(&so->so_rcv, rcvcc) == 0)
 8234304:	e0bffd17 	ldw	r2,-12(fp)
 8234308:	10800a04 	addi	r2,r2,40
 823430c:	e17fff17 	ldw	r5,-4(fp)
 8234310:	1009883a 	mov	r4,r2
 8234314:	82343580 	call	8234358 <sbreserve>
 8234318:	10000226 	beq	r2,zero,8234324 <soreserve+0x54>
      goto bad2;
   return (0);
 823431c:	0005883a 	mov	r2,zero
 8234320:	00000806 	br	8234344 <soreserve+0x74>
   u_long   rcvcc)
{
   if (sbreserve(&so->so_snd, sndcc) == 0)
      goto bad;
   if (sbreserve(&so->so_rcv, rcvcc) == 0)
      goto bad2;
 8234324:	0001883a 	nop
   return (0);
bad2:
   sbrelease(&so->so_snd);
 8234328:	e0bffd17 	ldw	r2,-12(fp)
 823432c:	10801204 	addi	r2,r2,72
 8234330:	1009883a 	mov	r4,r2
 8234334:	82343a80 	call	82343a8 <sbrelease>
 8234338:	00000106 	br	8234340 <soreserve+0x70>
soreserve(struct socket * so, 
   u_long   sndcc, 
   u_long   rcvcc)
{
   if (sbreserve(&so->so_snd, sndcc) == 0)
      goto bad;
 823433c:	0001883a 	nop
      goto bad2;
   return (0);
bad2:
   sbrelease(&so->so_snd);
bad:
   return (ENOBUFS);
 8234340:	00801a44 	movi	r2,105
}
 8234344:	e037883a 	mov	sp,fp
 8234348:	dfc00117 	ldw	ra,4(sp)
 823434c:	df000017 	ldw	fp,0(sp)
 8234350:	dec00204 	addi	sp,sp,8
 8234354:	f800283a 	ret

08234358 <sbreserve>:
 * RETURNS: 
 */

int
sbreserve(struct sockbuf * sb, u_long cc)
{
 8234358:	defffd04 	addi	sp,sp,-12
 823435c:	df000215 	stw	fp,8(sp)
 8234360:	df000204 	addi	fp,sp,8
 8234364:	e13ffe15 	stw	r4,-8(fp)
 8234368:	e17fff15 	stw	r5,-4(fp)
#ifdef COMPILER_32BIT
   if (cc > (u_long)SB_MAX * CLBYTES / (2 * MSIZE + CLBYTES))
      return (0);
#endif
   sb->sb_hiwat = cc;
 823436c:	e0bffe17 	ldw	r2,-8(fp)
 8234370:	e0ffff17 	ldw	r3,-4(fp)
 8234374:	10c00115 	stw	r3,4(r2)
   sb->sb_mbmax = MIN(cc * 2, SB_MAX);
 8234378:	e0bfff17 	ldw	r2,-4(fp)
 823437c:	1085883a 	add	r2,r2,r2
 8234380:	10d00070 	cmpltui	r3,r2,16385
 8234384:	1800011e 	bne	r3,zero,823438c <sbreserve+0x34>
 8234388:	00900004 	movi	r2,16384
 823438c:	e0fffe17 	ldw	r3,-8(fp)
 8234390:	18800315 	stw	r2,12(r3)
   return (1);
 8234394:	00800044 	movi	r2,1
}
 8234398:	e037883a 	mov	sp,fp
 823439c:	df000017 	ldw	fp,0(sp)
 82343a0:	dec00104 	addi	sp,sp,4
 82343a4:	f800283a 	ret

082343a8 <sbrelease>:
 * RETURNS: 
 */

void
sbrelease(struct sockbuf * sb)
{
 82343a8:	defffd04 	addi	sp,sp,-12
 82343ac:	dfc00215 	stw	ra,8(sp)
 82343b0:	df000115 	stw	fp,4(sp)
 82343b4:	df000104 	addi	fp,sp,4
 82343b8:	e13fff15 	stw	r4,-4(fp)
   sbflush(sb);
 82343bc:	e13fff17 	ldw	r4,-4(fp)
 82343c0:	82349280 	call	8234928 <sbflush>
   sb->sb_hiwat = sb->sb_mbmax = 0;
 82343c4:	e0bfff17 	ldw	r2,-4(fp)
 82343c8:	10000315 	stw	zero,12(r2)
 82343cc:	e0bfff17 	ldw	r2,-4(fp)
 82343d0:	10c00317 	ldw	r3,12(r2)
 82343d4:	e0bfff17 	ldw	r2,-4(fp)
 82343d8:	10c00115 	stw	r3,4(r2)
}
 82343dc:	0001883a 	nop
 82343e0:	e037883a 	mov	sp,fp
 82343e4:	dfc00117 	ldw	ra,4(sp)
 82343e8:	df000017 	ldw	fp,0(sp)
 82343ec:	dec00204 	addi	sp,sp,8
 82343f0:	f800283a 	ret

082343f4 <sbappend>:
 * RETURNS: 
 */

void
sbappend(struct sockbuf * sb, struct mbuf * m)
{
 82343f4:	defffb04 	addi	sp,sp,-20
 82343f8:	dfc00415 	stw	ra,16(sp)
 82343fc:	df000315 	stw	fp,12(sp)
 8234400:	df000304 	addi	fp,sp,12
 8234404:	e13ffe15 	stw	r4,-8(fp)
 8234408:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  n;

   if (m == 0)
 823440c:	e0bfff17 	ldw	r2,-4(fp)
 8234410:	10001a26 	beq	r2,zero,823447c <sbappend+0x88>
      return;
   ENTER_CRIT_SECTION(sb);
 8234414:	822d76c0 	call	822d76c <irq_Mask>
   if ((n = sb->sb_mb) != NULL) 
 8234418:	e0bffe17 	ldw	r2,-8(fp)
 823441c:	10800617 	ldw	r2,24(r2)
 8234420:	e0bffd15 	stw	r2,-12(fp)
 8234424:	e0bffd17 	ldw	r2,-12(fp)
 8234428:	10000e26 	beq	r2,zero,8234464 <sbappend+0x70>
   {
      while (n->m_act)
 823442c:	00000306 	br	823443c <sbappend+0x48>
         n = n->m_act;
 8234430:	e0bffd17 	ldw	r2,-12(fp)
 8234434:	10800717 	ldw	r2,28(r2)
 8234438:	e0bffd15 	stw	r2,-12(fp)
   if (m == 0)
      return;
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 823443c:	e0bffd17 	ldw	r2,-12(fp)
 8234440:	10800717 	ldw	r2,28(r2)
 8234444:	103ffa1e 	bne	r2,zero,8234430 <sbappend+0x3c>
         n = n->m_act;
      while (n->m_next)
 8234448:	00000306 	br	8234458 <sbappend+0x64>
         n = n->m_next;
 823444c:	e0bffd17 	ldw	r2,-12(fp)
 8234450:	10800617 	ldw	r2,24(r2)
 8234454:	e0bffd15 	stw	r2,-12(fp)
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
         n = n->m_act;
      while (n->m_next)
 8234458:	e0bffd17 	ldw	r2,-12(fp)
 823445c:	10800617 	ldw	r2,24(r2)
 8234460:	103ffa1e 	bne	r2,zero,823444c <sbappend+0x58>
         n = n->m_next;
   }
   sbcompress(sb, m, n);
 8234464:	e1bffd17 	ldw	r6,-12(fp)
 8234468:	e17fff17 	ldw	r5,-4(fp)
 823446c:	e13ffe17 	ldw	r4,-8(fp)
 8234470:	82347480 	call	8234748 <sbcompress>
   EXIT_CRIT_SECTION(sb);
 8234474:	822d7cc0 	call	822d7cc <irq_Unmask>
 8234478:	00000106 	br	8234480 <sbappend+0x8c>
sbappend(struct sockbuf * sb, struct mbuf * m)
{
   struct mbuf *  n;

   if (m == 0)
      return;
 823447c:	0001883a 	nop
      while (n->m_next)
         n = n->m_next;
   }
   sbcompress(sb, m, n);
   EXIT_CRIT_SECTION(sb);
}
 8234480:	e037883a 	mov	sp,fp
 8234484:	dfc00117 	ldw	ra,4(sp)
 8234488:	df000017 	ldw	fp,0(sp)
 823448c:	dec00204 	addi	sp,sp,8
 8234490:	f800283a 	ret

08234494 <sbappendrecord>:
 */

void
sbappendrecord(struct sockbuf * sb, 
   struct mbuf *  m0)
{
 8234494:	defffb04 	addi	sp,sp,-20
 8234498:	dfc00415 	stw	ra,16(sp)
 823449c:	df000315 	stw	fp,12(sp)
 82344a0:	df000304 	addi	fp,sp,12
 82344a4:	e13ffe15 	stw	r4,-8(fp)
 82344a8:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;

   if (m0 == 0)
 82344ac:	e0bfff17 	ldw	r2,-4(fp)
 82344b0:	10002826 	beq	r2,zero,8234554 <sbappendrecord+0xc0>
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
 82344b4:	822d76c0 	call	822d76c <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 82344b8:	e0bffe17 	ldw	r2,-8(fp)
 82344bc:	10800617 	ldw	r2,24(r2)
 82344c0:	e0bffd15 	stw	r2,-12(fp)
 82344c4:	e0bffd17 	ldw	r2,-12(fp)
 82344c8:	10000726 	beq	r2,zero,82344e8 <sbappendrecord+0x54>
      while (m->m_act)
 82344cc:	00000306 	br	82344dc <sbappendrecord+0x48>
      m = m->m_act;
 82344d0:	e0bffd17 	ldw	r2,-12(fp)
 82344d4:	10800717 	ldw	r2,28(r2)
 82344d8:	e0bffd15 	stw	r2,-12(fp)

   if (m0 == 0)
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
   if ((m = sb->sb_mb) != NULL)
      while (m->m_act)
 82344dc:	e0bffd17 	ldw	r2,-12(fp)
 82344e0:	10800717 	ldw	r2,28(r2)
 82344e4:	103ffa1e 	bne	r2,zero,82344d0 <sbappendrecord+0x3c>
      m = m->m_act;
   /*
    * Put the first mbuf on the queue.
    * Note this permits zero length records.
    */
   sballoc(sb, m0);
 82344e8:	e0bffe17 	ldw	r2,-8(fp)
 82344ec:	10c00017 	ldw	r3,0(r2)
 82344f0:	e0bfff17 	ldw	r2,-4(fp)
 82344f4:	10800217 	ldw	r2,8(r2)
 82344f8:	1887883a 	add	r3,r3,r2
 82344fc:	e0bffe17 	ldw	r2,-8(fp)
 8234500:	10c00015 	stw	r3,0(r2)
   if (m)
 8234504:	e0bffd17 	ldw	r2,-12(fp)
 8234508:	10000426 	beq	r2,zero,823451c <sbappendrecord+0x88>
      m->m_act = m0;
 823450c:	e0bffd17 	ldw	r2,-12(fp)
 8234510:	e0ffff17 	ldw	r3,-4(fp)
 8234514:	10c00715 	stw	r3,28(r2)
 8234518:	00000306 	br	8234528 <sbappendrecord+0x94>
   else
      sb->sb_mb = m0;
 823451c:	e0bffe17 	ldw	r2,-8(fp)
 8234520:	e0ffff17 	ldw	r3,-4(fp)
 8234524:	10c00615 	stw	r3,24(r2)
   m = m0->m_next;
 8234528:	e0bfff17 	ldw	r2,-4(fp)
 823452c:	10800617 	ldw	r2,24(r2)
 8234530:	e0bffd15 	stw	r2,-12(fp)
   m0->m_next = 0;
 8234534:	e0bfff17 	ldw	r2,-4(fp)
 8234538:	10000615 	stw	zero,24(r2)
   sbcompress(sb, m, m0);
 823453c:	e1bfff17 	ldw	r6,-4(fp)
 8234540:	e17ffd17 	ldw	r5,-12(fp)
 8234544:	e13ffe17 	ldw	r4,-8(fp)
 8234548:	82347480 	call	8234748 <sbcompress>
   EXIT_CRIT_SECTION(sb);
 823454c:	822d7cc0 	call	822d7cc <irq_Unmask>
 8234550:	00000106 	br	8234558 <sbappendrecord+0xc4>
   struct mbuf *  m0)
{
   struct mbuf *  m;

   if (m0 == 0)
      return;
 8234554:	0001883a 	nop
      sb->sb_mb = m0;
   m = m0->m_next;
   m0->m_next = 0;
   sbcompress(sb, m, m0);
   EXIT_CRIT_SECTION(sb);
}
 8234558:	e037883a 	mov	sp,fp
 823455c:	dfc00117 	ldw	ra,4(sp)
 8234560:	df000017 	ldw	fp,0(sp)
 8234564:	dec00204 	addi	sp,sp,8
 8234568:	f800283a 	ret

0823456c <sbappendaddr>:

int
sbappendaddr(struct sockbuf * sb, 
   struct sockaddr * asa,
   struct mbuf *  m0)
{
 823456c:	defff804 	addi	sp,sp,-32
 8234570:	dfc00715 	stw	ra,28(sp)
 8234574:	df000615 	stw	fp,24(sp)
 8234578:	df000604 	addi	fp,sp,24
 823457c:	e13ffd15 	stw	r4,-12(fp)
 8234580:	e17ffe15 	stw	r5,-8(fp)
 8234584:	e1bfff15 	stw	r6,-4(fp)
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);
 8234588:	00800404 	movi	r2,16
 823458c:	e0bffc15 	stw	r2,-16(fp)

   ENTER_CRIT_SECTION(sb);
 8234590:	822d76c0 	call	822d76c <irq_Mask>
   for (m = m0; m; m = m->m_next)
 8234594:	e0bfff17 	ldw	r2,-4(fp)
 8234598:	e0bffa15 	stw	r2,-24(fp)
 823459c:	00000806 	br	82345c0 <sbappendaddr+0x54>
      space += m->m_len;
 82345a0:	e0bffa17 	ldw	r2,-24(fp)
 82345a4:	10c00217 	ldw	r3,8(r2)
 82345a8:	e0bffc17 	ldw	r2,-16(fp)
 82345ac:	1885883a 	add	r2,r3,r2
 82345b0:	e0bffc15 	stw	r2,-16(fp)
{
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);

   ENTER_CRIT_SECTION(sb);
   for (m = m0; m; m = m->m_next)
 82345b4:	e0bffa17 	ldw	r2,-24(fp)
 82345b8:	10800617 	ldw	r2,24(r2)
 82345bc:	e0bffa15 	stw	r2,-24(fp)
 82345c0:	e0bffa17 	ldw	r2,-24(fp)
 82345c4:	103ff61e 	bne	r2,zero,82345a0 <sbappendaddr+0x34>
      space += m->m_len;
   if (space > (int)sbspace(sb))
 82345c8:	e0bffd17 	ldw	r2,-12(fp)
 82345cc:	10800117 	ldw	r2,4(r2)
 82345d0:	1007883a 	mov	r3,r2
 82345d4:	e0bffd17 	ldw	r2,-12(fp)
 82345d8:	10800017 	ldw	r2,0(r2)
 82345dc:	1885c83a 	sub	r2,r3,r2
 82345e0:	10000716 	blt	r2,zero,8234600 <sbappendaddr+0x94>
 82345e4:	e0bffd17 	ldw	r2,-12(fp)
 82345e8:	10c00117 	ldw	r3,4(r2)
 82345ec:	e0bffd17 	ldw	r2,-12(fp)
 82345f0:	10800017 	ldw	r2,0(r2)
 82345f4:	1885c83a 	sub	r2,r3,r2
 82345f8:	1007883a 	mov	r3,r2
 82345fc:	00000106 	br	8234604 <sbappendaddr+0x98>
 8234600:	0007883a 	mov	r3,zero
 8234604:	e0bffc17 	ldw	r2,-16(fp)
 8234608:	1880030e 	bge	r3,r2,8234618 <sbappendaddr+0xac>
   {
      EXIT_CRIT_SECTION(sb);
 823460c:	822d7cc0 	call	822d7cc <irq_Unmask>
      return (0);
 8234610:	0005883a 	mov	r2,zero
 8234614:	00004706 	br	8234734 <sbappendaddr+0x1c8>
   }
   if ((m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr))) == NULL)
 8234618:	01400404 	movi	r5,16
 823461c:	01000244 	movi	r4,9
 8234620:	822e3a80 	call	822e3a8 <m_getnbuf>
 8234624:	e0bffa15 	stw	r2,-24(fp)
 8234628:	e0bffa17 	ldw	r2,-24(fp)
 823462c:	1000031e 	bne	r2,zero,823463c <sbappendaddr+0xd0>
   {
      EXIT_CRIT_SECTION(sb);
 8234630:	822d7cc0 	call	822d7cc <irq_Unmask>
      return 0;
 8234634:	0005883a 	mov	r2,zero
 8234638:	00003e06 	br	8234734 <sbappendaddr+0x1c8>
   }
   *mtod(m, struct sockaddr *) = *asa;
 823463c:	e0bffa17 	ldw	r2,-24(fp)
 8234640:	10800317 	ldw	r2,12(r2)
 8234644:	e0fffe17 	ldw	r3,-8(fp)
 8234648:	1900000b 	ldhu	r4,0(r3)
 823464c:	1100000d 	sth	r4,0(r2)
 8234650:	1900008b 	ldhu	r4,2(r3)
 8234654:	1100008d 	sth	r4,2(r2)
 8234658:	1900010b 	ldhu	r4,4(r3)
 823465c:	1100010d 	sth	r4,4(r2)
 8234660:	1900018b 	ldhu	r4,6(r3)
 8234664:	1100018d 	sth	r4,6(r2)
 8234668:	1900020b 	ldhu	r4,8(r3)
 823466c:	1100020d 	sth	r4,8(r2)
 8234670:	1900028b 	ldhu	r4,10(r3)
 8234674:	1100028d 	sth	r4,10(r2)
 8234678:	1900030b 	ldhu	r4,12(r3)
 823467c:	1100030d 	sth	r4,12(r2)
 8234680:	18c0038b 	ldhu	r3,14(r3)
 8234684:	10c0038d 	sth	r3,14(r2)
   m->m_len = sizeof (*asa);
 8234688:	e0bffa17 	ldw	r2,-24(fp)
 823468c:	00c00404 	movi	r3,16
 8234690:	10c00215 	stw	r3,8(r2)
   sballoc (sb, m);
 8234694:	e0bffd17 	ldw	r2,-12(fp)
 8234698:	10c00017 	ldw	r3,0(r2)
 823469c:	e0bffa17 	ldw	r2,-24(fp)
 82346a0:	10800217 	ldw	r2,8(r2)
 82346a4:	1887883a 	add	r3,r3,r2
 82346a8:	e0bffd17 	ldw	r2,-12(fp)
 82346ac:	10c00015 	stw	r3,0(r2)
   if ((n = sb->sb_mb) != NULL) 
 82346b0:	e0bffd17 	ldw	r2,-12(fp)
 82346b4:	10800617 	ldw	r2,24(r2)
 82346b8:	e0bffb15 	stw	r2,-20(fp)
 82346bc:	e0bffb17 	ldw	r2,-20(fp)
 82346c0:	10000b26 	beq	r2,zero,82346f0 <sbappendaddr+0x184>
   {
      while (n->m_act)
 82346c4:	00000306 	br	82346d4 <sbappendaddr+0x168>
         n = n->m_act;
 82346c8:	e0bffb17 	ldw	r2,-20(fp)
 82346cc:	10800717 	ldw	r2,28(r2)
 82346d0:	e0bffb15 	stw	r2,-20(fp)
   *mtod(m, struct sockaddr *) = *asa;
   m->m_len = sizeof (*asa);
   sballoc (sb, m);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 82346d4:	e0bffb17 	ldw	r2,-20(fp)
 82346d8:	10800717 	ldw	r2,28(r2)
 82346dc:	103ffa1e 	bne	r2,zero,82346c8 <sbappendaddr+0x15c>
         n = n->m_act;
      n->m_act = m;
 82346e0:	e0bffb17 	ldw	r2,-20(fp)
 82346e4:	e0fffa17 	ldw	r3,-24(fp)
 82346e8:	10c00715 	stw	r3,28(r2)
 82346ec:	00000306 	br	82346fc <sbappendaddr+0x190>
   } else
      sb->sb_mb = m;
 82346f0:	e0bffd17 	ldw	r2,-12(fp)
 82346f4:	e0fffa17 	ldw	r3,-24(fp)
 82346f8:	10c00615 	stw	r3,24(r2)
   if (m->m_next)
 82346fc:	e0bffa17 	ldw	r2,-24(fp)
 8234700:	10800617 	ldw	r2,24(r2)
 8234704:	10000326 	beq	r2,zero,8234714 <sbappendaddr+0x1a8>
      m = m->m_next;
 8234708:	e0bffa17 	ldw	r2,-24(fp)
 823470c:	10800617 	ldw	r2,24(r2)
 8234710:	e0bffa15 	stw	r2,-24(fp)
   if (m0)
 8234714:	e0bfff17 	ldw	r2,-4(fp)
 8234718:	10000426 	beq	r2,zero,823472c <sbappendaddr+0x1c0>
      sbcompress(sb, m0, m);
 823471c:	e1bffa17 	ldw	r6,-24(fp)
 8234720:	e17fff17 	ldw	r5,-4(fp)
 8234724:	e13ffd17 	ldw	r4,-12(fp)
 8234728:	82347480 	call	8234748 <sbcompress>

   EXIT_CRIT_SECTION(sb);
 823472c:	822d7cc0 	call	822d7cc <irq_Unmask>
   return (1);
 8234730:	00800044 	movi	r2,1
}
 8234734:	e037883a 	mov	sp,fp
 8234738:	dfc00117 	ldw	ra,4(sp)
 823473c:	df000017 	ldw	fp,0(sp)
 8234740:	dec00204 	addi	sp,sp,8
 8234744:	f800283a 	ret

08234748 <sbcompress>:

void
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{
 8234748:	defffb04 	addi	sp,sp,-20
 823474c:	dfc00415 	stw	ra,16(sp)
 8234750:	df000315 	stw	fp,12(sp)
 8234754:	df000304 	addi	fp,sp,12
 8234758:	e13ffd15 	stw	r4,-12(fp)
 823475c:	e17ffe15 	stw	r5,-8(fp)
 8234760:	e1bfff15 	stw	r6,-4(fp)

   while (m) 
 8234764:	00006806 	br	8234908 <sbcompress+0x1c0>
   {
      if (m->m_len == 0) 
 8234768:	e0bffe17 	ldw	r2,-8(fp)
 823476c:	10800217 	ldw	r2,8(r2)
 8234770:	1000041e 	bne	r2,zero,8234784 <sbcompress+0x3c>
      {
         m = m_free(m);
 8234774:	e13ffe17 	ldw	r4,-8(fp)
 8234778:	822e5300 	call	822e530 <m_free>
 823477c:	e0bffe15 	stw	r2,-8(fp)
         continue;
 8234780:	00006106 	br	8234908 <sbcompress+0x1c0>
      }
      if (m->m_type != MT_RXDATA && 
 8234784:	e0bffe17 	ldw	r2,-8(fp)
 8234788:	10800817 	ldw	r2,32(r2)
 823478c:	10800060 	cmpeqi	r2,r2,1
 8234790:	1000111e 	bne	r2,zero,82347d8 <sbcompress+0x90>
          m->m_type != MT_TXDATA && 
 8234794:	e0bffe17 	ldw	r2,-8(fp)
 8234798:	10800817 	ldw	r2,32(r2)
      if (m->m_len == 0) 
      {
         m = m_free(m);
         continue;
      }
      if (m->m_type != MT_RXDATA && 
 823479c:	108000a0 	cmpeqi	r2,r2,2
 82347a0:	10000d1e 	bne	r2,zero,82347d8 <sbcompress+0x90>
          m->m_type != MT_TXDATA && 
          m->m_type != MT_SONAME) 
 82347a4:	e0bffe17 	ldw	r2,-8(fp)
 82347a8:	10800817 	ldw	r2,32(r2)
      {
         m = m_free(m);
         continue;
      }
      if (m->m_type != MT_RXDATA && 
          m->m_type != MT_TXDATA && 
 82347ac:	10800260 	cmpeqi	r2,r2,9
 82347b0:	1000091e 	bne	r2,zero,82347d8 <sbcompress+0x90>
          m->m_type != MT_SONAME) 
      {
         dprintf ("sbcomp:bad type %d\n", m->m_type);
 82347b4:	e0bffe17 	ldw	r2,-8(fp)
 82347b8:	10800817 	ldw	r2,32(r2)
 82347bc:	100b883a 	mov	r5,r2
 82347c0:	01020974 	movhi	r4,2085
 82347c4:	21038e04 	addi	r4,r4,3640
 82347c8:	82033a00 	call	82033a0 <printf>
         panic ("sbcomp:bad");
 82347cc:	01020974 	movhi	r4,2085
 82347d0:	21039304 	addi	r4,r4,3660
 82347d4:	8228c480 	call	8228c48 <panic>
      /* If there is room for all the data in M in N, then
       * just copy the data to N.  Note that sbdrop will 
       * increment the n->m_data pointer, so that we must
       * correct n->m_memsz.
       */
      if ( n && (sb->sb_flags & SB_MBCOMP) &&
 82347d8:	e0bfff17 	ldw	r2,-4(fp)
 82347dc:	10003326 	beq	r2,zero,82348ac <sbcompress+0x164>
 82347e0:	e0bffd17 	ldw	r2,-12(fp)
 82347e4:	1080070b 	ldhu	r2,28(r2)
 82347e8:	10bfffcc 	andi	r2,r2,65535
 82347ec:	1080200c 	andi	r2,r2,128
 82347f0:	10002e26 	beq	r2,zero,82348ac <sbcompress+0x164>
          ((n->m_len + m->m_len) <
 82347f4:	e0bfff17 	ldw	r2,-4(fp)
 82347f8:	10c00217 	ldw	r3,8(r2)
 82347fc:	e0bffe17 	ldw	r2,-8(fp)
 8234800:	10800217 	ldw	r2,8(r2)
 8234804:	1887883a 	add	r3,r3,r2
          n->m_memsz - (n->m_data - n->m_base) ) ) 
 8234808:	e0bfff17 	ldw	r2,-4(fp)
 823480c:	10800517 	ldw	r2,20(r2)
 8234810:	e13fff17 	ldw	r4,-4(fp)
 8234814:	21000317 	ldw	r4,12(r4)
 8234818:	200b883a 	mov	r5,r4
 823481c:	e13fff17 	ldw	r4,-4(fp)
 8234820:	21000417 	ldw	r4,16(r4)
 8234824:	2909c83a 	sub	r4,r5,r4
 8234828:	1105c83a 	sub	r2,r2,r4
      /* If there is room for all the data in M in N, then
       * just copy the data to N.  Note that sbdrop will 
       * increment the n->m_data pointer, so that we must
       * correct n->m_memsz.
       */
      if ( n && (sb->sb_flags & SB_MBCOMP) &&
 823482c:	18801f2e 	bgeu	r3,r2,82348ac <sbcompress+0x164>
          ((n->m_len + m->m_len) <
          n->m_memsz - (n->m_data - n->m_base) ) ) 
      {
         MEMCPY(n->m_data+n->m_len, m->m_data, m->m_len);
 8234830:	e0bfff17 	ldw	r2,-4(fp)
 8234834:	10c00317 	ldw	r3,12(r2)
 8234838:	e0bfff17 	ldw	r2,-4(fp)
 823483c:	10800217 	ldw	r2,8(r2)
 8234840:	1887883a 	add	r3,r3,r2
 8234844:	e0bffe17 	ldw	r2,-8(fp)
 8234848:	11000317 	ldw	r4,12(r2)
 823484c:	e0bffe17 	ldw	r2,-8(fp)
 8234850:	10800217 	ldw	r2,8(r2)
 8234854:	100d883a 	mov	r6,r2
 8234858:	200b883a 	mov	r5,r4
 823485c:	1809883a 	mov	r4,r3
 8234860:	8202f100 	call	8202f10 <memcpy>
         sballoc(sb, m);
 8234864:	e0bffd17 	ldw	r2,-12(fp)
 8234868:	10c00017 	ldw	r3,0(r2)
 823486c:	e0bffe17 	ldw	r2,-8(fp)
 8234870:	10800217 	ldw	r2,8(r2)
 8234874:	1887883a 	add	r3,r3,r2
 8234878:	e0bffd17 	ldw	r2,-12(fp)
 823487c:	10c00015 	stw	r3,0(r2)
         n->m_len += m->m_len;
 8234880:	e0bfff17 	ldw	r2,-4(fp)
 8234884:	10c00217 	ldw	r3,8(r2)
 8234888:	e0bffe17 	ldw	r2,-8(fp)
 823488c:	10800217 	ldw	r2,8(r2)
 8234890:	1887883a 	add	r3,r3,r2
 8234894:	e0bfff17 	ldw	r2,-4(fp)
 8234898:	10c00215 	stw	r3,8(r2)
         m = m_free(m);
 823489c:	e13ffe17 	ldw	r4,-8(fp)
 82348a0:	822e5300 	call	822e530 <m_free>
 82348a4:	e0bffe15 	stw	r2,-8(fp)
         continue;
 82348a8:	00001706 	br	8234908 <sbcompress+0x1c0>
      }
      sballoc(sb, m);
 82348ac:	e0bffd17 	ldw	r2,-12(fp)
 82348b0:	10c00017 	ldw	r3,0(r2)
 82348b4:	e0bffe17 	ldw	r2,-8(fp)
 82348b8:	10800217 	ldw	r2,8(r2)
 82348bc:	1887883a 	add	r3,r3,r2
 82348c0:	e0bffd17 	ldw	r2,-12(fp)
 82348c4:	10c00015 	stw	r3,0(r2)
      if (n)
 82348c8:	e0bfff17 	ldw	r2,-4(fp)
 82348cc:	10000426 	beq	r2,zero,82348e0 <sbcompress+0x198>
         n->m_next = m;
 82348d0:	e0bfff17 	ldw	r2,-4(fp)
 82348d4:	e0fffe17 	ldw	r3,-8(fp)
 82348d8:	10c00615 	stw	r3,24(r2)
 82348dc:	00000306 	br	82348ec <sbcompress+0x1a4>
      else
         sb->sb_mb = m;
 82348e0:	e0bffd17 	ldw	r2,-12(fp)
 82348e4:	e0fffe17 	ldw	r3,-8(fp)
 82348e8:	10c00615 	stw	r3,24(r2)
      n = m;
 82348ec:	e0bffe17 	ldw	r2,-8(fp)
 82348f0:	e0bfff15 	stw	r2,-4(fp)
      m = m->m_next;
 82348f4:	e0bffe17 	ldw	r2,-8(fp)
 82348f8:	10800617 	ldw	r2,24(r2)
 82348fc:	e0bffe15 	stw	r2,-8(fp)
      n->m_next = 0;
 8234900:	e0bfff17 	ldw	r2,-4(fp)
 8234904:	10000615 	stw	zero,24(r2)
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{

   while (m) 
 8234908:	e0bffe17 	ldw	r2,-8(fp)
 823490c:	103f961e 	bne	r2,zero,8234768 <sbcompress+0x20>
         sb->sb_mb = m;
      n = m;
      m = m->m_next;
      n->m_next = 0;
   }
}
 8234910:	0001883a 	nop
 8234914:	e037883a 	mov	sp,fp
 8234918:	dfc00117 	ldw	ra,4(sp)
 823491c:	df000017 	ldw	fp,0(sp)
 8234920:	dec00204 	addi	sp,sp,8
 8234924:	f800283a 	ret

08234928 <sbflush>:
 * RETURNS: 
 */

void
sbflush(struct sockbuf * sb)
{
 8234928:	defffd04 	addi	sp,sp,-12
 823492c:	dfc00215 	stw	ra,8(sp)
 8234930:	df000115 	stw	fp,4(sp)
 8234934:	df000104 	addi	fp,sp,4
 8234938:	e13fff15 	stw	r4,-4(fp)
   ENTER_CRIT_SECTION(sb);
 823493c:	822d76c0 	call	822d76c <irq_Mask>
   if (sb->sb_flags & SB_LOCK)
 8234940:	e0bfff17 	ldw	r2,-4(fp)
 8234944:	1080070b 	ldhu	r2,28(r2)
 8234948:	10bfffcc 	andi	r2,r2,65535
 823494c:	1080004c 	andi	r2,r2,1
 8234950:	10000926 	beq	r2,zero,8234978 <sbflush+0x50>
      panic("sbflush");
 8234954:	01020974 	movhi	r4,2085
 8234958:	21039604 	addi	r4,r4,3672
 823495c:	8228c480 	call	8228c48 <panic>
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 8234960:	00000506 	br	8234978 <sbflush+0x50>
      sbdrop (sb, (int)sb->sb_cc);
 8234964:	e0bfff17 	ldw	r2,-4(fp)
 8234968:	10800017 	ldw	r2,0(r2)
 823496c:	100b883a 	mov	r5,r2
 8234970:	e13fff17 	ldw	r4,-4(fp)
 8234974:	82349ac0 	call	82349ac <sbdrop>
sbflush(struct sockbuf * sb)
{
   ENTER_CRIT_SECTION(sb);
   if (sb->sb_flags & SB_LOCK)
      panic("sbflush");
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 8234978:	e0bfff17 	ldw	r2,-4(fp)
 823497c:	10800217 	ldw	r2,8(r2)
 8234980:	103ff81e 	bne	r2,zero,8234964 <sbflush+0x3c>
 8234984:	e0bfff17 	ldw	r2,-4(fp)
 8234988:	10800017 	ldw	r2,0(r2)
 823498c:	103ff51e 	bne	r2,zero,8234964 <sbflush+0x3c>
      sbdrop (sb, (int)sb->sb_cc);
   EXIT_CRIT_SECTION(sb);
 8234990:	822d7cc0 	call	822d7cc <irq_Unmask>
}
 8234994:	0001883a 	nop
 8234998:	e037883a 	mov	sp,fp
 823499c:	dfc00117 	ldw	ra,4(sp)
 82349a0:	df000017 	ldw	fp,0(sp)
 82349a4:	dec00204 	addi	sp,sp,8
 82349a8:	f800283a 	ret

082349ac <sbdrop>:
 * RETURNS: 
 */

void
sbdrop(struct sockbuf * sb, int len)
{
 82349ac:	defff904 	addi	sp,sp,-28
 82349b0:	dfc00615 	stw	ra,24(sp)
 82349b4:	df000515 	stw	fp,20(sp)
 82349b8:	df000504 	addi	fp,sp,20
 82349bc:	e13ffe15 	stw	r4,-8(fp)
 82349c0:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m, *  mn;
   struct mbuf *  next;

   ENTER_CRIT_SECTION(sb);
 82349c4:	822d76c0 	call	822d76c <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 82349c8:	e0bffe17 	ldw	r2,-8(fp)
 82349cc:	10800617 	ldw	r2,24(r2)
 82349d0:	e0bffb15 	stw	r2,-20(fp)
 82349d4:	e0bffb17 	ldw	r2,-20(fp)
 82349d8:	10000426 	beq	r2,zero,82349ec <sbdrop+0x40>
      next = m->m_act;
 82349dc:	e0bffb17 	ldw	r2,-20(fp)
 82349e0:	10800717 	ldw	r2,28(r2)
 82349e4:	e0bffc15 	stw	r2,-16(fp)
 82349e8:	00003706 	br	8234ac8 <sbdrop+0x11c>
   else
      next = NULL;
 82349ec:	e03ffc15 	stw	zero,-16(fp)
   while (len > 0) 
 82349f0:	00003506 	br	8234ac8 <sbdrop+0x11c>
   {
      if (m == 0) 
 82349f4:	e0bffb17 	ldw	r2,-20(fp)
 82349f8:	10000b1e 	bne	r2,zero,8234a28 <sbdrop+0x7c>
      {
         if (next == 0)
 82349fc:	e0bffc17 	ldw	r2,-16(fp)
 8234a00:	1000031e 	bne	r2,zero,8234a10 <sbdrop+0x64>
            panic("sbdrop");
 8234a04:	01020974 	movhi	r4,2085
 8234a08:	21039804 	addi	r4,r4,3680
 8234a0c:	8228c480 	call	8228c48 <panic>
         m = next;
 8234a10:	e0bffc17 	ldw	r2,-16(fp)
 8234a14:	e0bffb15 	stw	r2,-20(fp)
         next = m->m_act;
 8234a18:	e0bffb17 	ldw	r2,-20(fp)
 8234a1c:	10800717 	ldw	r2,28(r2)
 8234a20:	e0bffc15 	stw	r2,-16(fp)
         continue;
 8234a24:	00002806 	br	8234ac8 <sbdrop+0x11c>
      }
      if (m->m_len > (unsigned)len) 
 8234a28:	e0bffb17 	ldw	r2,-20(fp)
 8234a2c:	10800217 	ldw	r2,8(r2)
 8234a30:	e0ffff17 	ldw	r3,-4(fp)
 8234a34:	1880132e 	bgeu	r3,r2,8234a84 <sbdrop+0xd8>
      {
         m->m_len -= len;
 8234a38:	e0bffb17 	ldw	r2,-20(fp)
 8234a3c:	10c00217 	ldw	r3,8(r2)
 8234a40:	e0bfff17 	ldw	r2,-4(fp)
 8234a44:	1887c83a 	sub	r3,r3,r2
 8234a48:	e0bffb17 	ldw	r2,-20(fp)
 8234a4c:	10c00215 	stw	r3,8(r2)
         m->m_data += len;
 8234a50:	e0bffb17 	ldw	r2,-20(fp)
 8234a54:	10c00317 	ldw	r3,12(r2)
 8234a58:	e0bfff17 	ldw	r2,-4(fp)
 8234a5c:	1887883a 	add	r3,r3,r2
 8234a60:	e0bffb17 	ldw	r2,-20(fp)
 8234a64:	10c00315 	stw	r3,12(r2)
         sb->sb_cc -= len;
 8234a68:	e0bffe17 	ldw	r2,-8(fp)
 8234a6c:	10c00017 	ldw	r3,0(r2)
 8234a70:	e0bfff17 	ldw	r2,-4(fp)
 8234a74:	1887c83a 	sub	r3,r3,r2
 8234a78:	e0bffe17 	ldw	r2,-8(fp)
 8234a7c:	10c00015 	stw	r3,0(r2)
         break;
 8234a80:	00001306 	br	8234ad0 <sbdrop+0x124>
      }
      len -= m->m_len;
 8234a84:	e0ffff17 	ldw	r3,-4(fp)
 8234a88:	e0bffb17 	ldw	r2,-20(fp)
 8234a8c:	10800217 	ldw	r2,8(r2)
 8234a90:	1885c83a 	sub	r2,r3,r2
 8234a94:	e0bfff15 	stw	r2,-4(fp)
      sbfree (sb, m);
 8234a98:	e0bffe17 	ldw	r2,-8(fp)
 8234a9c:	10c00017 	ldw	r3,0(r2)
 8234aa0:	e0bffb17 	ldw	r2,-20(fp)
 8234aa4:	10800217 	ldw	r2,8(r2)
 8234aa8:	1887c83a 	sub	r3,r3,r2
 8234aac:	e0bffe17 	ldw	r2,-8(fp)
 8234ab0:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 8234ab4:	e13ffb17 	ldw	r4,-20(fp)
 8234ab8:	822e5300 	call	822e530 <m_free>
 8234abc:	e0bffd15 	stw	r2,-12(fp)
      m = mn;
 8234ac0:	e0bffd17 	ldw	r2,-12(fp)
 8234ac4:	e0bffb15 	stw	r2,-20(fp)
   ENTER_CRIT_SECTION(sb);
   if ((m = sb->sb_mb) != NULL)
      next = m->m_act;
   else
      next = NULL;
   while (len > 0) 
 8234ac8:	e0bfff17 	ldw	r2,-4(fp)
 8234acc:	00bfc916 	blt	zero,r2,82349f4 <sbdrop+0x48>
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 8234ad0:	00000c06 	br	8234b04 <sbdrop+0x158>
   {
      sbfree(sb, m);
 8234ad4:	e0bffe17 	ldw	r2,-8(fp)
 8234ad8:	10c00017 	ldw	r3,0(r2)
 8234adc:	e0bffb17 	ldw	r2,-20(fp)
 8234ae0:	10800217 	ldw	r2,8(r2)
 8234ae4:	1887c83a 	sub	r3,r3,r2
 8234ae8:	e0bffe17 	ldw	r2,-8(fp)
 8234aec:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 8234af0:	e13ffb17 	ldw	r4,-20(fp)
 8234af4:	822e5300 	call	822e530 <m_free>
 8234af8:	e0bffd15 	stw	r2,-12(fp)
      m = mn;
 8234afc:	e0bffd17 	ldw	r2,-12(fp)
 8234b00:	e0bffb15 	stw	r2,-20(fp)
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 8234b04:	e0bffb17 	ldw	r2,-20(fp)
 8234b08:	10000326 	beq	r2,zero,8234b18 <sbdrop+0x16c>
 8234b0c:	e0bffb17 	ldw	r2,-20(fp)
 8234b10:	10800217 	ldw	r2,8(r2)
 8234b14:	103fef26 	beq	r2,zero,8234ad4 <sbdrop+0x128>
   {
      sbfree(sb, m);
      MFREE(m, mn);
      m = mn;
   }
   if (m) 
 8234b18:	e0bffb17 	ldw	r2,-20(fp)
 8234b1c:	10000726 	beq	r2,zero,8234b3c <sbdrop+0x190>
   {
      sb->sb_mb = m;
 8234b20:	e0bffe17 	ldw	r2,-8(fp)
 8234b24:	e0fffb17 	ldw	r3,-20(fp)
 8234b28:	10c00615 	stw	r3,24(r2)
      m->m_act = next;
 8234b2c:	e0bffb17 	ldw	r2,-20(fp)
 8234b30:	e0fffc17 	ldw	r3,-16(fp)
 8234b34:	10c00715 	stw	r3,28(r2)
 8234b38:	00000306 	br	8234b48 <sbdrop+0x19c>
   } else
      sb->sb_mb = next;
 8234b3c:	e0bffe17 	ldw	r2,-8(fp)
 8234b40:	e0fffc17 	ldw	r3,-16(fp)
 8234b44:	10c00615 	stw	r3,24(r2)
   EXIT_CRIT_SECTION(sb);
 8234b48:	822d7cc0 	call	822d7cc <irq_Unmask>
}
 8234b4c:	0001883a 	nop
 8234b50:	e037883a 	mov	sp,fp
 8234b54:	dfc00117 	ldw	ra,4(sp)
 8234b58:	df000017 	ldw	fp,0(sp)
 8234b5c:	dec00204 	addi	sp,sp,8
 8234b60:	f800283a 	ret

08234b64 <sbdropend>:
 * RETURNS: 
 */

void
sbdropend(struct sockbuf * sb, struct mbuf * m)
{
 8234b64:	defff904 	addi	sp,sp,-28
 8234b68:	dfc00615 	stw	ra,24(sp)
 8234b6c:	df000515 	stw	fp,20(sp)
 8234b70:	df000504 	addi	fp,sp,20
 8234b74:	e13ffe15 	stw	r4,-8(fp)
 8234b78:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  nmb, *   pmb;
   int   len;
   ENTER_CRIT_SECTION(sb);
 8234b7c:	822d76c0 	call	822d76c <irq_Mask>
   len = mbuf_len(m);
 8234b80:	e13fff17 	ldw	r4,-4(fp)
 8234b84:	822eb300 	call	822eb30 <mbuf_len>
 8234b88:	e0bffd15 	stw	r2,-12(fp)
   if (len > 0)
 8234b8c:	e0bffd17 	ldw	r2,-12(fp)
 8234b90:	0080070e 	bge	zero,r2,8234bb0 <sbdropend+0x4c>
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
 8234b94:	e0bffe17 	ldw	r2,-8(fp)
 8234b98:	10c00617 	ldw	r3,24(r2)
 8234b9c:	e0bffd17 	ldw	r2,-12(fp)
 8234ba0:	0085c83a 	sub	r2,zero,r2
 8234ba4:	100b883a 	mov	r5,r2
 8234ba8:	1809883a 	mov	r4,r3
 8234bac:	822e9700 	call	822e970 <m_adj>
   nmb = sb->sb_mb;
 8234bb0:	e0bffe17 	ldw	r2,-8(fp)
 8234bb4:	10800617 	ldw	r2,24(r2)
 8234bb8:	e0bffb15 	stw	r2,-20(fp)
   pmb = NULL;
 8234bbc:	e03ffc15 	stw	zero,-16(fp)
   if (sb->sb_mb->m_len == 0)
 8234bc0:	e0bffe17 	ldw	r2,-8(fp)
 8234bc4:	10800617 	ldw	r2,24(r2)
 8234bc8:	10800217 	ldw	r2,8(r2)
 8234bcc:	1000081e 	bne	r2,zero,8234bf0 <sbdropend+0x8c>
      sb->sb_mb = NULL;
 8234bd0:	e0bffe17 	ldw	r2,-8(fp)
 8234bd4:	10000615 	stw	zero,24(r2)
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 8234bd8:	00000506 	br	8234bf0 <sbdropend+0x8c>
   {
      pmb = nmb;  /* Remember previous */
 8234bdc:	e0bffb17 	ldw	r2,-20(fp)
 8234be0:	e0bffc15 	stw	r2,-16(fp)
      nmb = nmb->m_next;    
 8234be4:	e0bffb17 	ldw	r2,-20(fp)
 8234be8:	10800617 	ldw	r2,24(r2)
 8234bec:	e0bffb15 	stw	r2,-20(fp)
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
   nmb = sb->sb_mb;
   pmb = NULL;
   if (sb->sb_mb->m_len == 0)
      sb->sb_mb = NULL;
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 8234bf0:	e0bffb17 	ldw	r2,-20(fp)
 8234bf4:	10000326 	beq	r2,zero,8234c04 <sbdropend+0xa0>
 8234bf8:	e0bffb17 	ldw	r2,-20(fp)
 8234bfc:	10800217 	ldw	r2,8(r2)
 8234c00:	103ff61e 	bne	r2,zero,8234bdc <sbdropend+0x78>
   {
      pmb = nmb;  /* Remember previous */
      nmb = nmb->m_next;    
   }
   if (nmb && (nmb->m_len == 0)) /* Assume once 0 len found, all the rest */
 8234c04:	e0bffb17 	ldw	r2,-20(fp)
 8234c08:	10000926 	beq	r2,zero,8234c30 <sbdropend+0xcc>
 8234c0c:	e0bffb17 	ldw	r2,-20(fp)
 8234c10:	10800217 	ldw	r2,8(r2)
 8234c14:	1000061e 	bne	r2,zero,8234c30 <sbdropend+0xcc>
   {                             /* are zeroes */ 
      if (pmb != NULL)
 8234c18:	e0bffc17 	ldw	r2,-16(fp)
 8234c1c:	10000226 	beq	r2,zero,8234c28 <sbdropend+0xc4>
         pmb->m_next = NULL;
 8234c20:	e0bffc17 	ldw	r2,-16(fp)
 8234c24:	10000615 	stw	zero,24(r2)
      m_freem(nmb);            
 8234c28:	e13ffb17 	ldw	r4,-20(fp)
 8234c2c:	822e6380 	call	822e638 <m_freem>
   }
   sb->sb_cc -= len;       /* Do a sbfree using the len */
 8234c30:	e0bffe17 	ldw	r2,-8(fp)
 8234c34:	10c00017 	ldw	r3,0(r2)
 8234c38:	e0bffd17 	ldw	r2,-12(fp)
 8234c3c:	1887c83a 	sub	r3,r3,r2
 8234c40:	e0bffe17 	ldw	r2,-8(fp)
 8234c44:	10c00015 	stw	r3,0(r2)
   EXIT_CRIT_SECTION(sb);
 8234c48:	822d7cc0 	call	822d7cc <irq_Unmask>
}
 8234c4c:	0001883a 	nop
 8234c50:	e037883a 	mov	sp,fp
 8234c54:	dfc00117 	ldw	ra,4(sp)
 8234c58:	df000017 	ldw	fp,0(sp)
 8234c5c:	dec00204 	addi	sp,sp,8
 8234c60:	f800283a 	ret

08234c64 <sbdroprecord>:
 * RETURNS: 
 */

void
sbdroprecord(struct sockbuf * sb)
{
 8234c64:	defffb04 	addi	sp,sp,-20
 8234c68:	dfc00415 	stw	ra,16(sp)
 8234c6c:	df000315 	stw	fp,12(sp)
 8234c70:	df000304 	addi	fp,sp,12
 8234c74:	e13fff15 	stw	r4,-4(fp)
   struct mbuf *  m, *  mn;

   ENTER_CRIT_SECTION(sb);
 8234c78:	822d76c0 	call	822d76c <irq_Mask>
   m = sb->sb_mb;
 8234c7c:	e0bfff17 	ldw	r2,-4(fp)
 8234c80:	10800617 	ldw	r2,24(r2)
 8234c84:	e0bffd15 	stw	r2,-12(fp)
   if (m)
 8234c88:	e0bffd17 	ldw	r2,-12(fp)
 8234c8c:	10001226 	beq	r2,zero,8234cd8 <sbdroprecord+0x74>
   {  sb->sb_mb = m->m_act;
 8234c90:	e0bffd17 	ldw	r2,-12(fp)
 8234c94:	10c00717 	ldw	r3,28(r2)
 8234c98:	e0bfff17 	ldw	r2,-4(fp)
 8234c9c:	10c00615 	stw	r3,24(r2)
      do 
      {  sbfree(sb, m);
 8234ca0:	e0bfff17 	ldw	r2,-4(fp)
 8234ca4:	10c00017 	ldw	r3,0(r2)
 8234ca8:	e0bffd17 	ldw	r2,-12(fp)
 8234cac:	10800217 	ldw	r2,8(r2)
 8234cb0:	1887c83a 	sub	r3,r3,r2
 8234cb4:	e0bfff17 	ldw	r2,-4(fp)
 8234cb8:	10c00015 	stw	r3,0(r2)
         MFREE(m, mn);
 8234cbc:	e13ffd17 	ldw	r4,-12(fp)
 8234cc0:	822e5300 	call	822e530 <m_free>
 8234cc4:	e0bffe15 	stw	r2,-8(fp)
      } while ((m = mn) != NULL);
 8234cc8:	e0bffe17 	ldw	r2,-8(fp)
 8234ccc:	e0bffd15 	stw	r2,-12(fp)
 8234cd0:	e0bffd17 	ldw	r2,-12(fp)
 8234cd4:	103ff21e 	bne	r2,zero,8234ca0 <sbdroprecord+0x3c>
         }
   EXIT_CRIT_SECTION(sb);
 8234cd8:	822d7cc0 	call	822d7cc <irq_Unmask>
}
 8234cdc:	0001883a 	nop
 8234ce0:	e037883a 	mov	sp,fp
 8234ce4:	dfc00117 	ldw	ra,4(sp)
 8234ce8:	df000017 	ldw	fp,0(sp)
 8234cec:	dec00204 	addi	sp,sp,8
 8234cf0:	f800283a 	ret

08234cf4 <t_select>:
int
t_select(fd_set * in,   /* lists of sockets to watch */
   fd_set * out,
   fd_set * ex,
   long  tv)   /* ticks to wait */
{
 8234cf4:	defe7204 	addi	sp,sp,-1592
 8234cf8:	dfc18d15 	stw	ra,1588(sp)
 8234cfc:	df018c15 	stw	fp,1584(sp)
 8234d00:	df018c04 	addi	fp,sp,1584
 8234d04:	e13ffc15 	stw	r4,-16(fp)
 8234d08:	e17ffd15 	stw	r5,-12(fp)
 8234d0c:	e1bffe15 	stw	r6,-8(fp)
 8234d10:	e1ffff15 	stw	r7,-4(fp)
   fd_set obits[3], ibits [3];
   u_long   tmo;
   int   retval   =  0;
 8234d14:	e03e7415 	stw	zero,-1584(fp)

   MEMSET(&obits, 0, sizeof(obits));
 8234d18:	e0be7604 	addi	r2,fp,-1576
 8234d1c:	0180c304 	movi	r6,780
 8234d20:	000b883a 	mov	r5,zero
 8234d24:	1009883a 	mov	r4,r2
 8234d28:	82031b40 	call	82031b4 <memset>
   MEMSET(&ibits, 0, sizeof(ibits));
 8234d2c:	e0bf3904 	addi	r2,fp,-796
 8234d30:	0180c304 	movi	r6,780
 8234d34:	000b883a 	mov	r5,zero
 8234d38:	1009883a 	mov	r4,r2
 8234d3c:	82031b40 	call	82031b4 <memset>

   if (in)
 8234d40:	e0bffc17 	ldw	r2,-16(fp)
 8234d44:	10000526 	beq	r2,zero,8234d5c <t_select+0x68>
      MEMCPY(&ibits[0], in, sizeof(fd_set));
 8234d48:	e0bf3904 	addi	r2,fp,-796
 8234d4c:	01804104 	movi	r6,260
 8234d50:	e17ffc17 	ldw	r5,-16(fp)
 8234d54:	1009883a 	mov	r4,r2
 8234d58:	8202f100 	call	8202f10 <memcpy>
   if (out)
 8234d5c:	e0bffd17 	ldw	r2,-12(fp)
 8234d60:	10000626 	beq	r2,zero,8234d7c <t_select+0x88>
      MEMCPY(&ibits[1], out, sizeof(fd_set));
 8234d64:	e0bf3904 	addi	r2,fp,-796
 8234d68:	10804104 	addi	r2,r2,260
 8234d6c:	01804104 	movi	r6,260
 8234d70:	e17ffd17 	ldw	r5,-12(fp)
 8234d74:	1009883a 	mov	r4,r2
 8234d78:	8202f100 	call	8202f10 <memcpy>
   if (ex)
 8234d7c:	e0bffe17 	ldw	r2,-8(fp)
 8234d80:	10000626 	beq	r2,zero,8234d9c <t_select+0xa8>
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
 8234d84:	e0bf3904 	addi	r2,fp,-796
 8234d88:	10808204 	addi	r2,r2,520
 8234d8c:	01804104 	movi	r6,260
 8234d90:	e17ffe17 	ldw	r5,-8(fp)
 8234d94:	1009883a 	mov	r4,r2
 8234d98:	8202f100 	call	8202f10 <memcpy>
   tmo = cticks + tv;
 8234d9c:	d0e0a817 	ldw	r3,-32096(gp)
 8234da0:	e0bfff17 	ldw	r2,-4(fp)
 8234da4:	1885883a 	add	r2,r3,r2
 8234da8:	e0be7515 	stw	r2,-1580(fp)

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 8234dac:	e0bf3917 	ldw	r2,-796(fp)
 8234db0:	10000c1e 	bne	r2,zero,8234de4 <t_select+0xf0>
 8234db4:	e0bf7a17 	ldw	r2,-536(fp)
 8234db8:	10000a1e 	bne	r2,zero,8234de4 <t_select+0xf0>
       (ibits[2].fd_count == 0))
 8234dbc:	e0bfbb17 	ldw	r2,-276(fp)
   if (ex)
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
   tmo = cticks + tv;

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 8234dc0:	1000081e 	bne	r2,zero,8234de4 <t_select+0xf0>
       (ibits[2].fd_count == 0))
   {
      if (tv > 0)      /* make sure we don't block on nothing forever */
 8234dc4:	e0bfff17 	ldw	r2,-4(fp)
 8234dc8:	00801f0e 	bge	zero,r2,8234e48 <t_select+0x154>
         while (tmo > cticks)
         {
            tk_yield();
         }
#else
         TK_SLEEP(tv);
 8234dcc:	e0bfff17 	ldw	r2,-4(fp)
 8234dd0:	10800044 	addi	r2,r2,1
 8234dd4:	10bfffcc 	andi	r2,r2,65535
 8234dd8:	1009883a 	mov	r4,r2
 8234ddc:	821bed80 	call	821bed8 <OSTimeDly>

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
       (ibits[2].fd_count == 0))
   {
      if (tv > 0)      /* make sure we don't block on nothing forever */
 8234de0:	00001906 	br	8234e48 <t_select+0x154>

      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
 8234de4:	0009883a 	mov	r4,zero
 8234de8:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      while ((retval = sock_selscan(ibits, obits)) == 0)
 8234dec:	00000a06 	br	8234e18 <t_select+0x124>
      {
         if (tv != -1L) 
 8234df0:	e0bfff17 	ldw	r2,-4(fp)
 8234df4:	10bfffe0 	cmpeqi	r2,r2,-1
 8234df8:	1000031e 	bne	r2,zero,8234e08 <t_select+0x114>
         {
            if (tmo <= cticks)
 8234dfc:	d0e0a817 	ldw	r3,-32096(gp)
 8234e00:	e0be7517 	ldw	r2,-1580(fp)
 8234e04:	18800d2e 	bgeu	r3,r2,8234e3c <t_select+0x148>
               break;
         }
         select_wait = 1;
 8234e08:	00800044 	movi	r2,1
 8234e0c:	d0a0b00d 	sth	r2,-32064(gp)
         tcp_sleep (&select_wait);
 8234e10:	d120b004 	addi	r4,gp,-32064
 8234e14:	82295340 	call	8229534 <tcp_sleep>
      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
      while ((retval = sock_selscan(ibits, obits)) == 0)
 8234e18:	e0fe7604 	addi	r3,fp,-1576
 8234e1c:	e0bf3904 	addi	r2,fp,-796
 8234e20:	180b883a 	mov	r5,r3
 8234e24:	1009883a 	mov	r4,r2
 8234e28:	8234ec40 	call	8234ec4 <sock_selscan>
 8234e2c:	e0be7415 	stw	r2,-1584(fp)
 8234e30:	e0be7417 	ldw	r2,-1584(fp)
 8234e34:	103fee26 	beq	r2,zero,8234df0 <t_select+0xfc>
 8234e38:	00000106 	br	8234e40 <t_select+0x14c>
      {
         if (tv != -1L) 
         {
            if (tmo <= cticks)
               break;
 8234e3c:	0001883a 	nop
         }
         select_wait = 1;
         tcp_sleep (&select_wait);
      }
      UNLOCK_NET_RESOURCE(NET_RESID);
 8234e40:	0009883a 	mov	r4,zero
 8234e44:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>

   }

   if (retval >= 0)
 8234e48:	e0be7417 	ldw	r2,-1584(fp)
 8234e4c:	10001716 	blt	r2,zero,8234eac <t_select+0x1b8>
   {
      if (in)
 8234e50:	e0bffc17 	ldw	r2,-16(fp)
 8234e54:	10000526 	beq	r2,zero,8234e6c <t_select+0x178>
         MEMCPY(in, &obits[0], sizeof(fd_set));
 8234e58:	e0be7604 	addi	r2,fp,-1576
 8234e5c:	01804104 	movi	r6,260
 8234e60:	100b883a 	mov	r5,r2
 8234e64:	e13ffc17 	ldw	r4,-16(fp)
 8234e68:	8202f100 	call	8202f10 <memcpy>
      if (out)
 8234e6c:	e0bffd17 	ldw	r2,-12(fp)
 8234e70:	10000626 	beq	r2,zero,8234e8c <t_select+0x198>
         MEMCPY(out, &obits[1], sizeof(fd_set));
 8234e74:	e0be7604 	addi	r2,fp,-1576
 8234e78:	10804104 	addi	r2,r2,260
 8234e7c:	01804104 	movi	r6,260
 8234e80:	100b883a 	mov	r5,r2
 8234e84:	e13ffd17 	ldw	r4,-12(fp)
 8234e88:	8202f100 	call	8202f10 <memcpy>
      if (ex)
 8234e8c:	e0bffe17 	ldw	r2,-8(fp)
 8234e90:	10000626 	beq	r2,zero,8234eac <t_select+0x1b8>
         MEMCPY(ex, &obits[2], sizeof(fd_set));
 8234e94:	e0be7604 	addi	r2,fp,-1576
 8234e98:	10808204 	addi	r2,r2,520
 8234e9c:	01804104 	movi	r6,260
 8234ea0:	100b883a 	mov	r5,r2
 8234ea4:	e13ffe17 	ldw	r4,-8(fp)
 8234ea8:	8202f100 	call	8202f10 <memcpy>
   }
   return retval;
 8234eac:	e0be7417 	ldw	r2,-1584(fp)
}
 8234eb0:	e037883a 	mov	sp,fp
 8234eb4:	dfc00117 	ldw	ra,4(sp)
 8234eb8:	df000017 	ldw	fp,0(sp)
 8234ebc:	dec00204 	addi	sp,sp,8
 8234ec0:	f800283a 	ret

08234ec4 <sock_selscan>:
 * RETURNS: 
 */

int
sock_selscan(fd_set * ibits, fd_set * obits)
{
 8234ec4:	defff604 	addi	sp,sp,-40
 8234ec8:	dfc00915 	stw	ra,36(sp)
 8234ecc:	df000815 	stw	fp,32(sp)
 8234ed0:	df000804 	addi	fp,sp,32
 8234ed4:	e13ffe15 	stw	r4,-8(fp)
 8234ed8:	e17fff15 	stw	r5,-4(fp)
   fd_set *in, *out;
   int   which;
   int   sock;
   int   flag  =  0;
 8234edc:	e03ffa15 	stw	zero,-24(fp)
   int   num_sel  =  0;
 8234ee0:	e03ffb15 	stw	zero,-20(fp)

   for (which = 0; which < 3; which++)
 8234ee4:	e03ff815 	stw	zero,-32(fp)
 8234ee8:	00003d06 	br	8234fe0 <sock_selscan+0x11c>
   {
      switch (which)
 8234eec:	e0bff817 	ldw	r2,-32(fp)
 8234ef0:	10c00060 	cmpeqi	r3,r2,1
 8234ef4:	1800061e 	bne	r3,zero,8234f10 <sock_selscan+0x4c>
 8234ef8:	10c000a0 	cmpeqi	r3,r2,2
 8234efc:	1800071e 	bne	r3,zero,8234f1c <sock_selscan+0x58>
 8234f00:	1000081e 	bne	r2,zero,8234f24 <sock_selscan+0x60>
      {
      case 0:
         flag = SOREAD; break;
 8234f04:	00800044 	movi	r2,1
 8234f08:	e0bffa15 	stw	r2,-24(fp)
 8234f0c:	00000506 	br	8234f24 <sock_selscan+0x60>

      case 1:
         flag = SOWRITE; break;
 8234f10:	00800084 	movi	r2,2
 8234f14:	e0bffa15 	stw	r2,-24(fp)
 8234f18:	00000206 	br	8234f24 <sock_selscan+0x60>

      case 2:
         flag = 0; break;
 8234f1c:	e03ffa15 	stw	zero,-24(fp)
 8234f20:	0001883a 	nop
      }
      in = &ibits [which];
 8234f24:	e0bff817 	ldw	r2,-32(fp)
 8234f28:	10804124 	muli	r2,r2,260
 8234f2c:	e0fffe17 	ldw	r3,-8(fp)
 8234f30:	1885883a 	add	r2,r3,r2
 8234f34:	e0bffc15 	stw	r2,-16(fp)
      out = &obits [which];
 8234f38:	e0bff817 	ldw	r2,-32(fp)
 8234f3c:	10804124 	muli	r2,r2,260
 8234f40:	e0ffff17 	ldw	r3,-4(fp)
 8234f44:	1885883a 	add	r2,r3,r2
 8234f48:	e0bffd15 	stw	r2,-12(fp)
      for (sock = 0; sock < (int)in->fd_count; sock++)
 8234f4c:	e03ff915 	stw	zero,-28(fp)
 8234f50:	00001b06 	br	8234fc0 <sock_selscan+0xfc>
      {
         if (sock_select (in->fd_array[sock], flag))
 8234f54:	e0fffc17 	ldw	r3,-16(fp)
 8234f58:	e0bff917 	ldw	r2,-28(fp)
 8234f5c:	10800044 	addi	r2,r2,1
 8234f60:	1085883a 	add	r2,r2,r2
 8234f64:	1085883a 	add	r2,r2,r2
 8234f68:	1885883a 	add	r2,r3,r2
 8234f6c:	10800017 	ldw	r2,0(r2)
 8234f70:	e17ffa17 	ldw	r5,-24(fp)
 8234f74:	1009883a 	mov	r4,r2
 8234f78:	82350040 	call	8235004 <sock_select>
 8234f7c:	10000d26 	beq	r2,zero,8234fb4 <sock_selscan+0xf0>
         {
            FD_SET(in->fd_array[sock], out);
 8234f80:	e0fffc17 	ldw	r3,-16(fp)
 8234f84:	e0bff917 	ldw	r2,-28(fp)
 8234f88:	10800044 	addi	r2,r2,1
 8234f8c:	1085883a 	add	r2,r2,r2
 8234f90:	1085883a 	add	r2,r2,r2
 8234f94:	1885883a 	add	r2,r3,r2
 8234f98:	10800017 	ldw	r2,0(r2)
 8234f9c:	e17ffd17 	ldw	r5,-12(fp)
 8234fa0:	1009883a 	mov	r4,r2
 8234fa4:	823541c0 	call	823541c <ifd_set>
            num_sel++;
 8234fa8:	e0bffb17 	ldw	r2,-20(fp)
 8234fac:	10800044 	addi	r2,r2,1
 8234fb0:	e0bffb15 	stw	r2,-20(fp)
      case 2:
         flag = 0; break;
      }
      in = &ibits [which];
      out = &obits [which];
      for (sock = 0; sock < (int)in->fd_count; sock++)
 8234fb4:	e0bff917 	ldw	r2,-28(fp)
 8234fb8:	10800044 	addi	r2,r2,1
 8234fbc:	e0bff915 	stw	r2,-28(fp)
 8234fc0:	e0bffc17 	ldw	r2,-16(fp)
 8234fc4:	10800017 	ldw	r2,0(r2)
 8234fc8:	1007883a 	mov	r3,r2
 8234fcc:	e0bff917 	ldw	r2,-28(fp)
 8234fd0:	10ffe016 	blt	r2,r3,8234f54 <sock_selscan+0x90>
   int   which;
   int   sock;
   int   flag  =  0;
   int   num_sel  =  0;

   for (which = 0; which < 3; which++)
 8234fd4:	e0bff817 	ldw	r2,-32(fp)
 8234fd8:	10800044 	addi	r2,r2,1
 8234fdc:	e0bff815 	stw	r2,-32(fp)
 8234fe0:	e0bff817 	ldw	r2,-32(fp)
 8234fe4:	108000d0 	cmplti	r2,r2,3
 8234fe8:	103fc01e 	bne	r2,zero,8234eec <sock_selscan+0x28>
            FD_SET(in->fd_array[sock], out);
            num_sel++;
         }
      }
   }
   return num_sel;
 8234fec:	e0bffb17 	ldw	r2,-20(fp)
}
 8234ff0:	e037883a 	mov	sp,fp
 8234ff4:	dfc00117 	ldw	ra,4(sp)
 8234ff8:	df000017 	ldw	fp,0(sp)
 8234ffc:	dec00204 	addi	sp,sp,8
 8235000:	f800283a 	ret

08235004 <sock_select>:
 * RETURNS: 
 */

int
sock_select(long sock, int flag)
{
 8235004:	defffa04 	addi	sp,sp,-24
 8235008:	dfc00515 	stw	ra,20(sp)
 823500c:	df000415 	stw	fp,16(sp)
 8235010:	df000404 	addi	fp,sp,16
 8235014:	e13ffe15 	stw	r4,-8(fp)
 8235018:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so;
   int   ready =  0;
 823501c:	e03ffc15 	stw	zero,-16(fp)

   so = LONG2SO(sock);
 8235020:	e0bffe17 	ldw	r2,-8(fp)
 8235024:	10bff804 	addi	r2,r2,-32
 8235028:	1085883a 	add	r2,r2,r2
 823502c:	1085883a 	add	r2,r2,r2
 8235030:	e0bffd15 	stw	r2,-12(fp)

   switch (flag) 
 8235034:	e0bfff17 	ldw	r2,-4(fp)
 8235038:	10c00060 	cmpeqi	r3,r2,1
 823503c:	1800041e 	bne	r3,zero,8235050 <sock_select+0x4c>
 8235040:	10c000a0 	cmpeqi	r3,r2,2
 8235044:	1800201e 	bne	r3,zero,82350c8 <sock_select+0xc4>
 8235048:	10004326 	beq	r2,zero,8235158 <sock_select+0x154>
 823504c:	00006006 	br	82351d0 <sock_select+0x1cc>
   {
   case SOREAD:
      /* can we read something from so? */
      if (so->so_rcv.sb_cc)
 8235050:	e0bffd17 	ldw	r2,-12(fp)
 8235054:	10800a17 	ldw	r2,40(r2)
 8235058:	10000326 	beq	r2,zero,8235068 <sock_select+0x64>
      {
         ready = 1;
 823505c:	00800044 	movi	r2,1
 8235060:	e0bffc15 	stw	r2,-16(fp)
         break;
 8235064:	00005a06 	br	82351d0 <sock_select+0x1cc>
      }
      if (so->so_state & SS_CANTRCVMORE)
 8235068:	e0bffd17 	ldw	r2,-12(fp)
 823506c:	1080088b 	ldhu	r2,34(r2)
 8235070:	10bfffcc 	andi	r2,r2,65535
 8235074:	1080080c 	andi	r2,r2,32
 8235078:	10000326 	beq	r2,zero,8235088 <sock_select+0x84>
      {  ready = 1;
 823507c:	00800044 	movi	r2,1
 8235080:	e0bffc15 	stw	r2,-16(fp)
         break;
 8235084:	00005206 	br	82351d0 <sock_select+0x1cc>
      }
      if (so->so_qlen)  /* attach is ready */
 8235088:	e0bffd17 	ldw	r2,-12(fp)
 823508c:	10801e43 	ldbu	r2,121(r2)
 8235090:	10803fcc 	andi	r2,r2,255
 8235094:	1080201c 	xori	r2,r2,128
 8235098:	10bfe004 	addi	r2,r2,-128
 823509c:	10000326 	beq	r2,zero,82350ac <sock_select+0xa8>
      {
         ready = 1;
 82350a0:	00800044 	movi	r2,1
 82350a4:	e0bffc15 	stw	r2,-16(fp)
         break;
 82350a8:	00004906 	br	82351d0 <sock_select+0x1cc>
         }
      }
#endif   /* TCP_ZEROCOPY */

      /* fall to here if so is not ready to read */
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
 82350ac:	e0bffd17 	ldw	r2,-12(fp)
 82350b0:	1080110b 	ldhu	r2,68(r2)
 82350b4:	10800214 	ori	r2,r2,8
 82350b8:	1007883a 	mov	r3,r2
 82350bc:	e0bffd17 	ldw	r2,-12(fp)
 82350c0:	10c0110d 	sth	r3,68(r2)
      break;
 82350c4:	00004206 	br	82351d0 <sock_select+0x1cc>

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
 82350c8:	e0bffd17 	ldw	r2,-12(fp)
 82350cc:	10801317 	ldw	r2,76(r2)
 82350d0:	1007883a 	mov	r3,r2
 82350d4:	e0bffd17 	ldw	r2,-12(fp)
 82350d8:	10801217 	ldw	r2,72(r2)
 82350dc:	1885c83a 	sub	r2,r3,r2
 82350e0:	10001816 	blt	r2,zero,8235144 <sock_select+0x140>
 82350e4:	e0bffd17 	ldw	r2,-12(fp)
 82350e8:	10c01317 	ldw	r3,76(r2)
 82350ec:	e0bffd17 	ldw	r2,-12(fp)
 82350f0:	10801217 	ldw	r2,72(r2)
 82350f4:	18801326 	beq	r3,r2,8235144 <sock_select+0x140>
          ((((so)->so_state&SS_ISCONNECTED) || 
 82350f8:	e0bffd17 	ldw	r2,-12(fp)
 82350fc:	1080088b 	ldhu	r2,34(r2)
 8235100:	10bfffcc 	andi	r2,r2,65535
 8235104:	1080008c 	andi	r2,r2,2
      /* fall to here if so is not ready to read */
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
      break;

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
 8235108:	10000b1e 	bne	r2,zero,8235138 <sock_select+0x134>
          ((((so)->so_state&SS_ISCONNECTED) || 
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
 823510c:	e0bffd17 	ldw	r2,-12(fp)
 8235110:	10800217 	ldw	r2,8(r2)
 8235114:	1080010b 	ldhu	r2,4(r2)
 8235118:	10bfffcc 	andi	r2,r2,65535
 823511c:	1080010c 	andi	r2,r2,4
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
      break;

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
          ((((so)->so_state&SS_ISCONNECTED) || 
 8235120:	10000526 	beq	r2,zero,8235138 <sock_select+0x134>
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
           ((so)->so_state & SS_CANTSENDMORE)))
 8235124:	e0bffd17 	ldw	r2,-12(fp)
 8235128:	1080088b 	ldhu	r2,34(r2)
 823512c:	10bfffcc 	andi	r2,r2,65535
 8235130:	1080040c 	andi	r2,r2,16
      break;

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
          ((((so)->so_state&SS_ISCONNECTED) || 
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
 8235134:	10000326 	beq	r2,zero,8235144 <sock_select+0x140>
           ((so)->so_state & SS_CANTSENDMORE)))
      {
         ready = 1;
 8235138:	00800044 	movi	r2,1
 823513c:	e0bffc15 	stw	r2,-16(fp)
         break;
 8235140:	00002306 	br	82351d0 <sock_select+0x1cc>
      }
      sbselqueue (&so->so_snd);
 8235144:	e0bffd17 	ldw	r2,-12(fp)
 8235148:	10801204 	addi	r2,r2,72
 823514c:	1009883a 	mov	r4,r2
 8235150:	823419c0 	call	823419c <sbselqueue>
      break;
 8235154:	00001e06 	br	82351d0 <sock_select+0x1cc>

   case 0:
      if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
 8235158:	e0bffd17 	ldw	r2,-12(fp)
 823515c:	10801a17 	ldw	r2,104(r2)
 8235160:	1000051e 	bne	r2,zero,8235178 <sock_select+0x174>
 8235164:	e0bffd17 	ldw	r2,-12(fp)
 8235168:	1080088b 	ldhu	r2,34(r2)
 823516c:	10bfffcc 	andi	r2,r2,65535
 8235170:	1080100c 	andi	r2,r2,64
 8235174:	10000326 	beq	r2,zero,8235184 <sock_select+0x180>
      {
         ready = 1;
 8235178:	00800044 	movi	r2,1
 823517c:	e0bffc15 	stw	r2,-16(fp)
         break;
 8235180:	00001306 	br	82351d0 <sock_select+0x1cc>
      }
      if (so->so_error &&
 8235184:	e0bffd17 	ldw	r2,-12(fp)
 8235188:	10800617 	ldw	r2,24(r2)
 823518c:	10000b26 	beq	r2,zero,82351bc <sock_select+0x1b8>
          (so->so_error != EINPROGRESS) &&
 8235190:	e0bffd17 	ldw	r2,-12(fp)
 8235194:	10800617 	ldw	r2,24(r2)
      if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
      {
         ready = 1;
         break;
      }
      if (so->so_error &&
 8235198:	10801de0 	cmpeqi	r2,r2,119
 823519c:	1000071e 	bne	r2,zero,82351bc <sock_select+0x1b8>
          (so->so_error != EINPROGRESS) &&
          (so->so_error != EWOULDBLOCK))
 82351a0:	e0bffd17 	ldw	r2,-12(fp)
 82351a4:	10800617 	ldw	r2,24(r2)
      {
         ready = 1;
         break;
      }
      if (so->so_error &&
          (so->so_error != EINPROGRESS) &&
 82351a8:	108002e0 	cmpeqi	r2,r2,11
 82351ac:	1000031e 	bne	r2,zero,82351bc <sock_select+0x1b8>
          (so->so_error != EWOULDBLOCK))
      {
         ready = 1;
 82351b0:	00800044 	movi	r2,1
 82351b4:	e0bffc15 	stw	r2,-16(fp)
         break;
 82351b8:	00000506 	br	82351d0 <sock_select+0x1cc>
      }
      sbselqueue(&so->so_rcv);
 82351bc:	e0bffd17 	ldw	r2,-12(fp)
 82351c0:	10800a04 	addi	r2,r2,40
 82351c4:	1009883a 	mov	r4,r2
 82351c8:	823419c0 	call	823419c <sbselqueue>
      break;
 82351cc:	0001883a 	nop
   }

   return ready;
 82351d0:	e0bffc17 	ldw	r2,-16(fp)
}
 82351d4:	e037883a 	mov	sp,fp
 82351d8:	dfc00117 	ldw	ra,4(sp)
 82351dc:	df000017 	ldw	fp,0(sp)
 82351e0:	dec00204 	addi	sp,sp,8
 82351e4:	f800283a 	ret

082351e8 <in_pcbnotify>:
void
in_pcbnotify(struct inpcb * head, 
   struct in_addr *  dst,
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
 82351e8:	defff804 	addi	sp,sp,-32
 82351ec:	dfc00715 	stw	ra,28(sp)
 82351f0:	df000615 	stw	fp,24(sp)
 82351f4:	df000604 	addi	fp,sp,24
 82351f8:	e13ffc15 	stw	r4,-16(fp)
 82351fc:	e17ffd15 	stw	r5,-12(fp)
 8235200:	e1bffe15 	stw	r6,-8(fp)
 8235204:	e1ffff15 	stw	r7,-4(fp)
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 8235208:	e0bffc17 	ldw	r2,-16(fp)
 823520c:	10800017 	ldw	r2,0(r2)
 8235210:	e0bffa15 	stw	r2,-24(fp)
 8235214:	00001c06 	br	8235288 <in_pcbnotify+0xa0>
   {
      if (inp->inp_faddr.s_addr != dst->s_addr ||
 8235218:	e0bffa17 	ldw	r2,-24(fp)
 823521c:	10c00317 	ldw	r3,12(r2)
 8235220:	e0bffd17 	ldw	r2,-12(fp)
 8235224:	10800017 	ldw	r2,0(r2)
 8235228:	1880031e 	bne	r3,r2,8235238 <in_pcbnotify+0x50>
          inp->inp_socket == 0) 
 823522c:	e0bffa17 	ldw	r2,-24(fp)
 8235230:	10800817 	ldw	r2,32(r2)
{
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
   {
      if (inp->inp_faddr.s_addr != dst->s_addr ||
 8235234:	1000041e 	bne	r2,zero,8235248 <in_pcbnotify+0x60>
          inp->inp_socket == 0) 
      {
         inp = inp->inp_next;
 8235238:	e0bffa17 	ldw	r2,-24(fp)
 823523c:	10800017 	ldw	r2,0(r2)
 8235240:	e0bffa15 	stw	r2,-24(fp)
         continue;
 8235244:	00001006 	br	8235288 <in_pcbnotify+0xa0>
      }
      if (errnum) 
 8235248:	e0bffe17 	ldw	r2,-8(fp)
 823524c:	10000426 	beq	r2,zero,8235260 <in_pcbnotify+0x78>
         inp->inp_socket->so_error = errnum;
 8235250:	e0bffa17 	ldw	r2,-24(fp)
 8235254:	10800817 	ldw	r2,32(r2)
 8235258:	e0fffe17 	ldw	r3,-8(fp)
 823525c:	10c00615 	stw	r3,24(r2)
      oinp = inp;
 8235260:	e0bffa17 	ldw	r2,-24(fp)
 8235264:	e0bffb15 	stw	r2,-20(fp)
      inp = inp->inp_next;
 8235268:	e0bffa17 	ldw	r2,-24(fp)
 823526c:	10800017 	ldw	r2,0(r2)
 8235270:	e0bffa15 	stw	r2,-24(fp)
      if (notify)
 8235274:	e0bfff17 	ldw	r2,-4(fp)
 8235278:	10000326 	beq	r2,zero,8235288 <in_pcbnotify+0xa0>
         (*notify)(oinp);
 823527c:	e0bfff17 	ldw	r2,-4(fp)
 8235280:	e13ffb17 	ldw	r4,-20(fp)
 8235284:	103ee83a 	callr	r2
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 8235288:	e0fffa17 	ldw	r3,-24(fp)
 823528c:	e0bffc17 	ldw	r2,-16(fp)
 8235290:	18bfe11e 	bne	r3,r2,8235218 <in_pcbnotify+0x30>
      oinp = inp;
      inp = inp->inp_next;
      if (notify)
         (*notify)(oinp);
   }
}
 8235294:	0001883a 	nop
 8235298:	e037883a 	mov	sp,fp
 823529c:	dfc00117 	ldw	ra,4(sp)
 82352a0:	df000017 	ldw	fp,0(sp)
 82352a4:	dec00204 	addi	sp,sp,8
 82352a8:	f800283a 	ret

082352ac <tcp_notify>:
 * RETURNS: 
 */

void
tcp_notify(struct inpcb * inp)
{
 82352ac:	defffd04 	addi	sp,sp,-12
 82352b0:	dfc00215 	stw	ra,8(sp)
 82352b4:	df000115 	stw	fp,4(sp)
 82352b8:	df000104 	addi	fp,sp,4
 82352bc:	e13fff15 	stw	r4,-4(fp)
   tcp_wakeup(&inp->inp_socket->so_timeo);
 82352c0:	e0bfff17 	ldw	r2,-4(fp)
 82352c4:	10800817 	ldw	r2,32(r2)
 82352c8:	10800904 	addi	r2,r2,36
 82352cc:	1009883a 	mov	r4,r2
 82352d0:	82296a80 	call	82296a8 <tcp_wakeup>
   sorwakeup(inp->inp_socket);
 82352d4:	e0bfff17 	ldw	r2,-4(fp)
 82352d8:	10c00817 	ldw	r3,32(r2)
 82352dc:	e0bfff17 	ldw	r2,-4(fp)
 82352e0:	10800817 	ldw	r2,32(r2)
 82352e4:	10800a04 	addi	r2,r2,40
 82352e8:	100b883a 	mov	r5,r2
 82352ec:	1809883a 	mov	r4,r3
 82352f0:	82342440 	call	8234244 <sbwakeup>
   sowwakeup(inp->inp_socket);
 82352f4:	e0bfff17 	ldw	r2,-4(fp)
 82352f8:	10c00817 	ldw	r3,32(r2)
 82352fc:	e0bfff17 	ldw	r2,-4(fp)
 8235300:	10800817 	ldw	r2,32(r2)
 8235304:	10801204 	addi	r2,r2,72
 8235308:	100b883a 	mov	r5,r2
 823530c:	1809883a 	mov	r4,r3
 8235310:	82342440 	call	8234244 <sbwakeup>
}
 8235314:	0001883a 	nop
 8235318:	e037883a 	mov	sp,fp
 823531c:	dfc00117 	ldw	ra,4(sp)
 8235320:	df000017 	ldw	fp,0(sp)
 8235324:	dec00204 	addi	sp,sp,8
 8235328:	f800283a 	ret

0823532c <ifd_clr>:
 * compacts the fd_set.
 */

void
ifd_clr(long sock, fd_set *set)
{
 823532c:	defffb04 	addi	sp,sp,-20
 8235330:	dfc00415 	stw	ra,16(sp)
 8235334:	df000315 	stw	fp,12(sp)
 8235338:	df000304 	addi	fp,sp,12
 823533c:	e13ffe15 	stw	r4,-8(fp)
 8235340:	e17fff15 	stw	r5,-4(fp)
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 8235344:	e03ffd15 	stw	zero,-12(fp)
 8235348:	00002a06 	br	82353f4 <ifd_clr+0xc8>
   {
      if (set->fd_array[i] == sock)
 823534c:	e0ffff17 	ldw	r3,-4(fp)
 8235350:	e0bffd17 	ldw	r2,-12(fp)
 8235354:	10800044 	addi	r2,r2,1
 8235358:	1085883a 	add	r2,r2,r2
 823535c:	1085883a 	add	r2,r2,r2
 8235360:	1885883a 	add	r2,r3,r2
 8235364:	10c00017 	ldw	r3,0(r2)
 8235368:	e0bffe17 	ldw	r2,-8(fp)
 823536c:	18801e1e 	bne	r3,r2,82353e8 <ifd_clr+0xbc>
      {
         while (i + 1 < set->fd_count)
 8235370:	00001206 	br	82353bc <ifd_clr+0x90>
         {
            set->fd_array[i] = set->fd_array[i + 1];
 8235374:	e0bffd17 	ldw	r2,-12(fp)
 8235378:	10800044 	addi	r2,r2,1
 823537c:	e0ffff17 	ldw	r3,-4(fp)
 8235380:	10800044 	addi	r2,r2,1
 8235384:	1085883a 	add	r2,r2,r2
 8235388:	1085883a 	add	r2,r2,r2
 823538c:	1885883a 	add	r2,r3,r2
 8235390:	10c00017 	ldw	r3,0(r2)
 8235394:	e13fff17 	ldw	r4,-4(fp)
 8235398:	e0bffd17 	ldw	r2,-12(fp)
 823539c:	10800044 	addi	r2,r2,1
 82353a0:	1085883a 	add	r2,r2,r2
 82353a4:	1085883a 	add	r2,r2,r2
 82353a8:	2085883a 	add	r2,r4,r2
 82353ac:	10c00015 	stw	r3,0(r2)
            i++;
 82353b0:	e0bffd17 	ldw	r2,-12(fp)
 82353b4:	10800044 	addi	r2,r2,1
 82353b8:	e0bffd15 	stw	r2,-12(fp)

   for (i = 0; i < set->fd_count ; i++) 
   {
      if (set->fd_array[i] == sock)
      {
         while (i + 1 < set->fd_count)
 82353bc:	e0bffd17 	ldw	r2,-12(fp)
 82353c0:	10c00044 	addi	r3,r2,1
 82353c4:	e0bfff17 	ldw	r2,-4(fp)
 82353c8:	10800017 	ldw	r2,0(r2)
 82353cc:	18bfe936 	bltu	r3,r2,8235374 <ifd_clr+0x48>
         {
            set->fd_array[i] = set->fd_array[i + 1];
            i++;
         }
         set->fd_count--;
 82353d0:	e0bfff17 	ldw	r2,-4(fp)
 82353d4:	10800017 	ldw	r2,0(r2)
 82353d8:	10ffffc4 	addi	r3,r2,-1
 82353dc:	e0bfff17 	ldw	r2,-4(fp)
 82353e0:	10c00015 	stw	r3,0(r2)
         return;
 82353e4:	00000806 	br	8235408 <ifd_clr+0xdc>
void
ifd_clr(long sock, fd_set *set)
{
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 82353e8:	e0bffd17 	ldw	r2,-12(fp)
 82353ec:	10800044 	addi	r2,r2,1
 82353f0:	e0bffd15 	stw	r2,-12(fp)
 82353f4:	e0bfff17 	ldw	r2,-4(fp)
 82353f8:	10800017 	ldw	r2,0(r2)
 82353fc:	e0fffd17 	ldw	r3,-12(fp)
 8235400:	18bfd236 	bltu	r3,r2,823534c <ifd_clr+0x20>
         return;
      }
   }

#ifdef NPDEBUG
   dtrap(); /* socket wasn't found in array */
 8235404:	822d5940 	call	822d594 <dtrap>
#endif
}
 8235408:	e037883a 	mov	sp,fp
 823540c:	dfc00117 	ldw	ra,4(sp)
 8235410:	df000017 	ldw	fp,0(sp)
 8235414:	dec00204 	addi	sp,sp,8
 8235418:	f800283a 	ret

0823541c <ifd_set>:
 * called if the fd_set structure is already full.
 */

void
ifd_set(long sock, fd_set *set)
{
 823541c:	defffc04 	addi	sp,sp,-16
 8235420:	dfc00315 	stw	ra,12(sp)
 8235424:	df000215 	stw	fp,8(sp)
 8235428:	df000204 	addi	fp,sp,8
 823542c:	e13ffe15 	stw	r4,-8(fp)
 8235430:	e17fff15 	stw	r5,-4(fp)
   if (set->fd_count < FD_SETSIZE)
 8235434:	e0bfff17 	ldw	r2,-4(fp)
 8235438:	10800017 	ldw	r2,0(r2)
 823543c:	10801028 	cmpgeui	r2,r2,64
 8235440:	10000d1e 	bne	r2,zero,8235478 <ifd_set+0x5c>
      set->fd_array[set->fd_count++] = sock;
 8235444:	e0bfff17 	ldw	r2,-4(fp)
 8235448:	10800017 	ldw	r2,0(r2)
 823544c:	11000044 	addi	r4,r2,1
 8235450:	e0ffff17 	ldw	r3,-4(fp)
 8235454:	19000015 	stw	r4,0(r3)
 8235458:	e0ffff17 	ldw	r3,-4(fp)
 823545c:	10800044 	addi	r2,r2,1
 8235460:	1085883a 	add	r2,r2,r2
 8235464:	1085883a 	add	r2,r2,r2
 8235468:	1885883a 	add	r2,r3,r2
 823546c:	e0fffe17 	ldw	r3,-8(fp)
 8235470:	10c00015 	stw	r3,0(r2)
#ifdef NPDEBUG
   else
      dtrap();
#endif
}
 8235474:	00000106 	br	823547c <ifd_set+0x60>
{
   if (set->fd_count < FD_SETSIZE)
      set->fd_array[set->fd_count++] = sock;
#ifdef NPDEBUG
   else
      dtrap();
 8235478:	822d5940 	call	822d594 <dtrap>
#endif
}
 823547c:	0001883a 	nop
 8235480:	e037883a 	mov	sp,fp
 8235484:	dfc00117 	ldw	ra,4(sp)
 8235488:	df000017 	ldw	fp,0(sp)
 823548c:	dec00204 	addi	sp,sp,8
 8235490:	f800283a 	ret

08235494 <ifd_isset>:
 * Tests if a socket is a member of a file descriptor set.
 */

int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
 8235494:	defffc04 	addi	sp,sp,-16
 8235498:	df000315 	stw	fp,12(sp)
 823549c:	df000304 	addi	fp,sp,12
 82354a0:	e13ffe15 	stw	r4,-8(fp)
 82354a4:	e17fff15 	stw	r5,-4(fp)
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 82354a8:	e03ffd15 	stw	zero,-12(fp)
 82354ac:	00000e06 	br	82354e8 <ifd_isset+0x54>
   {
      if (set->fd_array[i] == sock)
 82354b0:	e0ffff17 	ldw	r3,-4(fp)
 82354b4:	e0bffd17 	ldw	r2,-12(fp)
 82354b8:	10800044 	addi	r2,r2,1
 82354bc:	1085883a 	add	r2,r2,r2
 82354c0:	1085883a 	add	r2,r2,r2
 82354c4:	1885883a 	add	r2,r3,r2
 82354c8:	10c00017 	ldw	r3,0(r2)
 82354cc:	e0bffe17 	ldw	r2,-8(fp)
 82354d0:	1880021e 	bne	r3,r2,82354dc <ifd_isset+0x48>
         return TRUE;
 82354d4:	00800044 	movi	r2,1
 82354d8:	00000806 	br	82354fc <ifd_isset+0x68>
int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 82354dc:	e0bffd17 	ldw	r2,-12(fp)
 82354e0:	10800044 	addi	r2,r2,1
 82354e4:	e0bffd15 	stw	r2,-12(fp)
 82354e8:	e0bfff17 	ldw	r2,-4(fp)
 82354ec:	10800017 	ldw	r2,0(r2)
 82354f0:	e0fffd17 	ldw	r3,-12(fp)
 82354f4:	18bfee36 	bltu	r3,r2,82354b0 <ifd_isset+0x1c>
   {
      if (set->fd_array[i] == sock)
         return TRUE;
   }
   return FALSE;
 82354f8:	0005883a 	mov	r2,zero
}
 82354fc:	e037883a 	mov	sp,fp
 8235500:	df000017 	ldw	fp,0(sp)
 8235504:	dec00104 	addi	sp,sp,4
 8235508:	f800283a 	ret

0823550c <ifd_get>:
 * NOTE: This is not part of the original FD_XXX() functionality.
 */

long
ifd_get(unsigned i, fd_set *set)
{
 823550c:	defffc04 	addi	sp,sp,-16
 8235510:	dfc00315 	stw	ra,12(sp)
 8235514:	df000215 	stw	fp,8(sp)
 8235518:	df000204 	addi	fp,sp,8
 823551c:	e13ffe15 	stw	r4,-8(fp)
 8235520:	e17fff15 	stw	r5,-4(fp)
   if (i < set->fd_count)
 8235524:	e0bfff17 	ldw	r2,-4(fp)
 8235528:	10800017 	ldw	r2,0(r2)
 823552c:	e0fffe17 	ldw	r3,-8(fp)
 8235530:	1880082e 	bgeu	r3,r2,8235554 <ifd_get+0x48>
      return set->fd_array[i];
 8235534:	e0ffff17 	ldw	r3,-4(fp)
 8235538:	e0bffe17 	ldw	r2,-8(fp)
 823553c:	10800044 	addi	r2,r2,1
 8235540:	1085883a 	add	r2,r2,r2
 8235544:	1085883a 	add	r2,r2,r2
 8235548:	1885883a 	add	r2,r3,r2
 823554c:	10800017 	ldw	r2,0(r2)
 8235550:	00000206 	br	823555c <ifd_get+0x50>
   else
   {
#ifdef NPDEBUG
      dtrap();
 8235554:	822d5940 	call	822d594 <dtrap>
#endif
      return INVALID_SOCKET;
 8235558:	00bfffc4 	movi	r2,-1
   }
}
 823555c:	e037883a 	mov	sp,fp
 8235560:	dfc00117 	ldw	ra,4(sp)
 8235564:	df000017 	ldw	fp,0(sp)
 8235568:	dec00204 	addi	sp,sp,8
 823556c:	f800283a 	ret

08235570 <tcp_reass>:

int
tcp_reass(struct tcpcb * tp, 
   struct tcpiphdr * ti,
   struct mbuf *  ti_mbuf)
{
 8235570:	defff504 	addi	sp,sp,-44
 8235574:	dfc00a15 	stw	ra,40(sp)
 8235578:	df000915 	stw	fp,36(sp)
 823557c:	df000904 	addi	fp,sp,36
 8235580:	e13ffd15 	stw	r4,-12(fp)
 8235584:	e17ffe15 	stw	r5,-8(fp)
 8235588:	e1bfff15 	stw	r6,-4(fp)
   struct tcpiphdr * q;
   struct socket *   so =  tp->t_inpcb->inp_socket;
 823558c:	e0bffd17 	ldw	r2,-12(fp)
 8235590:	10800d17 	ldw	r2,52(r2)
 8235594:	10800817 	ldw	r2,32(r2)
 8235598:	e0bff815 	stw	r2,-32(fp)

   /*
    * Call with ti==0 after become established to
    * force pre-ESTABLISHED data up to user socket.
    */
   if (ti == 0)
 823559c:	e0bffe17 	ldw	r2,-8(fp)
 82355a0:	1000a426 	beq	r2,zero,8235834 <tcp_reass+0x2c4>
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 82355a4:	e0bffd17 	ldw	r2,-12(fp)
 82355a8:	10800017 	ldw	r2,0(r2)
 82355ac:	e0bff715 	stw	r2,-36(fp)
 82355b0:	00000906 	br	82355d8 <tcp_reass+0x68>
       q = (struct tcpiphdr *)q->ti_next)
   {
      if (SEQ_GT(q->ti_seq, ti->ti_seq))
 82355b4:	e0bff717 	ldw	r2,-36(fp)
 82355b8:	10c00617 	ldw	r3,24(r2)
 82355bc:	e0bffe17 	ldw	r2,-8(fp)
 82355c0:	10800617 	ldw	r2,24(r2)
 82355c4:	1885c83a 	sub	r2,r3,r2
 82355c8:	00800716 	blt	zero,r2,82355e8 <tcp_reass+0x78>

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
       q = (struct tcpiphdr *)q->ti_next)
 82355cc:	e0bff717 	ldw	r2,-36(fp)
 82355d0:	10800017 	ldw	r2,0(r2)
 82355d4:	e0bff715 	stw	r2,-36(fp)
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 82355d8:	e0fff717 	ldw	r3,-36(fp)
 82355dc:	e0bffd17 	ldw	r2,-12(fp)
 82355e0:	18bff41e 	bne	r3,r2,82355b4 <tcp_reass+0x44>
 82355e4:	00000106 	br	82355ec <tcp_reass+0x7c>
       q = (struct tcpiphdr *)q->ti_next)
   {
      if (SEQ_GT(q->ti_seq, ti->ti_seq))
      break;
 82355e8:	0001883a 	nop
   /*
    * If there is a preceding segment, it may provide some of
    * our data already.  If so, drop the data from the incoming
    * segment.  If it provides all of our data, drop us.
    */
   if ((struct tcpiphdr *)q->ti_prev != (struct tcpiphdr *)tp) 
 82355ec:	e0bff717 	ldw	r2,-36(fp)
 82355f0:	10c00117 	ldw	r3,4(r2)
 82355f4:	e0bffd17 	ldw	r2,-12(fp)
 82355f8:	18803f26 	beq	r3,r2,82356f8 <tcp_reass+0x188>
   {
      long  i;
      q = (struct tcpiphdr *)q->ti_prev;
 82355fc:	e0bff717 	ldw	r2,-36(fp)
 8235600:	10800117 	ldw	r2,4(r2)
 8235604:	e0bff715 	stw	r2,-36(fp)
      /* conversion to int (in i) handles seq wraparound */
      i = q->ti_seq + q->ti_len - ti->ti_seq;
 8235608:	e0bff717 	ldw	r2,-36(fp)
 823560c:	10c00617 	ldw	r3,24(r2)
 8235610:	e0bff717 	ldw	r2,-36(fp)
 8235614:	1080028b 	ldhu	r2,10(r2)
 8235618:	10bfffcc 	andi	r2,r2,65535
 823561c:	1887883a 	add	r3,r3,r2
 8235620:	e0bffe17 	ldw	r2,-8(fp)
 8235624:	10800617 	ldw	r2,24(r2)
 8235628:	1885c83a 	sub	r2,r3,r2
 823562c:	e0bff915 	stw	r2,-28(fp)
      if (i > 0) 
 8235630:	e0bff917 	ldw	r2,-28(fp)
 8235634:	00802d0e 	bge	zero,r2,82356ec <tcp_reass+0x17c>
      {
         if (i >= (long)ti->ti_len) 
 8235638:	e0bffe17 	ldw	r2,-8(fp)
 823563c:	1080028b 	ldhu	r2,10(r2)
 8235640:	10bfffcc 	andi	r2,r2,65535
 8235644:	e0fff917 	ldw	r3,-28(fp)
 8235648:	18801816 	blt	r3,r2,82356ac <tcp_reass+0x13c>
         {
            tcpstat.tcps_rcvduppack++;
 823564c:	008209b4 	movhi	r2,2086
 8235650:	10b98b04 	addi	r2,r2,-6612
 8235654:	10801f17 	ldw	r2,124(r2)
 8235658:	10c00044 	addi	r3,r2,1
 823565c:	008209b4 	movhi	r2,2086
 8235660:	10b98b04 	addi	r2,r2,-6612
 8235664:	10c01f15 	stw	r3,124(r2)
            tcpstat.tcps_rcvdupbyte += ti->ti_len;
 8235668:	008209b4 	movhi	r2,2086
 823566c:	10b98b04 	addi	r2,r2,-6612
 8235670:	10c02017 	ldw	r3,128(r2)
 8235674:	e0bffe17 	ldw	r2,-8(fp)
 8235678:	1080028b 	ldhu	r2,10(r2)
 823567c:	10bfffcc 	andi	r2,r2,65535
 8235680:	1887883a 	add	r3,r3,r2
 8235684:	008209b4 	movhi	r2,2086
 8235688:	10b98b04 	addi	r2,r2,-6612
 823568c:	10c02015 	stw	r3,128(r2)
            GOTO_DROP;
 8235690:	008025c4 	movi	r2,151
 8235694:	d0a0b215 	stw	r2,-32056(gp)
 8235698:	0001883a 	nop
   } while (ti != (struct tcpiphdr *)tp && ti->ti_seq == tp->rcv_nxt);
      sorwakeup(so);
   return (flags);
drop:
   /**m_freem (dtom(ti));**/
   m_freem (ti_mbuf);
 823569c:	e13fff17 	ldw	r4,-4(fp)
 82356a0:	822e6380 	call	822e638 <m_freem>
   return (0);
 82356a4:	0005883a 	mov	r2,zero
 82356a8:	0000b006 	br	823596c <tcp_reass+0x3fc>
         {
            tcpstat.tcps_rcvduppack++;
            tcpstat.tcps_rcvdupbyte += ti->ti_len;
            GOTO_DROP;
         }
         m_adj (ti_mbuf, (int)i);
 82356ac:	e17ff917 	ldw	r5,-28(fp)
 82356b0:	e13fff17 	ldw	r4,-4(fp)
 82356b4:	822e9700 	call	822e970 <m_adj>
         ti->ti_len -= (short)i;
 82356b8:	e0bffe17 	ldw	r2,-8(fp)
 82356bc:	1080028b 	ldhu	r2,10(r2)
 82356c0:	e0fff917 	ldw	r3,-28(fp)
 82356c4:	10c5c83a 	sub	r2,r2,r3
 82356c8:	1007883a 	mov	r3,r2
 82356cc:	e0bffe17 	ldw	r2,-8(fp)
 82356d0:	10c0028d 	sth	r3,10(r2)
         ti->ti_seq += (tcp_seq)i;
 82356d4:	e0bffe17 	ldw	r2,-8(fp)
 82356d8:	10c00617 	ldw	r3,24(r2)
 82356dc:	e0bff917 	ldw	r2,-28(fp)
 82356e0:	1887883a 	add	r3,r3,r2
 82356e4:	e0bffe17 	ldw	r2,-8(fp)
 82356e8:	10c00615 	stw	r3,24(r2)
      }
      q = (struct tcpiphdr *)(q->ti_next);
 82356ec:	e0bff717 	ldw	r2,-36(fp)
 82356f0:	10800017 	ldw	r2,0(r2)
 82356f4:	e0bff715 	stw	r2,-36(fp)
   }
   tcpstat.tcps_rcvoopack++;
 82356f8:	008209b4 	movhi	r2,2086
 82356fc:	10b98b04 	addi	r2,r2,-6612
 8235700:	10802317 	ldw	r2,140(r2)
 8235704:	10c00044 	addi	r3,r2,1
 8235708:	008209b4 	movhi	r2,2086
 823570c:	10b98b04 	addi	r2,r2,-6612
 8235710:	10c02315 	stw	r3,140(r2)
   tcpstat.tcps_rcvoobyte += ti->ti_len;
 8235714:	008209b4 	movhi	r2,2086
 8235718:	10b98b04 	addi	r2,r2,-6612
 823571c:	10c02417 	ldw	r3,144(r2)
 8235720:	e0bffe17 	ldw	r2,-8(fp)
 8235724:	1080028b 	ldhu	r2,10(r2)
 8235728:	10bfffcc 	andi	r2,r2,65535
 823572c:	1887883a 	add	r3,r3,r2
 8235730:	008209b4 	movhi	r2,2086
 8235734:	10b98b04 	addi	r2,r2,-6612
 8235738:	10c02415 	stw	r3,144(r2)

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 823573c:	00003206 	br	8235808 <tcp_reass+0x298>
   {
      int   i  =  (int)((ti->ti_seq +  ti->ti_len) -  q->ti_seq);
 8235740:	e0bffe17 	ldw	r2,-8(fp)
 8235744:	10c00617 	ldw	r3,24(r2)
 8235748:	e0bffe17 	ldw	r2,-8(fp)
 823574c:	1080028b 	ldhu	r2,10(r2)
 8235750:	10bfffcc 	andi	r2,r2,65535
 8235754:	1887883a 	add	r3,r3,r2
 8235758:	e0bff717 	ldw	r2,-36(fp)
 823575c:	10800617 	ldw	r2,24(r2)
 8235760:	1885c83a 	sub	r2,r3,r2
 8235764:	e0bffa15 	stw	r2,-24(fp)
      if (i <= 0)
 8235768:	e0bffa17 	ldw	r2,-24(fp)
 823576c:	00802a0e 	bge	zero,r2,8235818 <tcp_reass+0x2a8>
         break;
      if (i < (int)(q->ti_len))
 8235770:	e0bff717 	ldw	r2,-36(fp)
 8235774:	1080028b 	ldhu	r2,10(r2)
 8235778:	10bfffcc 	andi	r2,r2,65535
 823577c:	e0fffa17 	ldw	r3,-24(fp)
 8235780:	1880130e 	bge	r3,r2,82357d0 <tcp_reass+0x260>
      {
         q->ti_seq += i;
 8235784:	e0bff717 	ldw	r2,-36(fp)
 8235788:	10c00617 	ldw	r3,24(r2)
 823578c:	e0bffa17 	ldw	r2,-24(fp)
 8235790:	1887883a 	add	r3,r3,r2
 8235794:	e0bff717 	ldw	r2,-36(fp)
 8235798:	10c00615 	stw	r3,24(r2)
         q->ti_len -= (u_short)i;
 823579c:	e0bff717 	ldw	r2,-36(fp)
 82357a0:	1080028b 	ldhu	r2,10(r2)
 82357a4:	e0fffa17 	ldw	r3,-24(fp)
 82357a8:	10c5c83a 	sub	r2,r2,r3
 82357ac:	1007883a 	mov	r3,r2
 82357b0:	e0bff717 	ldw	r2,-36(fp)
 82357b4:	10c0028d 	sth	r3,10(r2)
         m_adj (dtom(q), (int)i);
 82357b8:	e13ff717 	ldw	r4,-36(fp)
 82357bc:	822eb840 	call	822eb84 <dtom>
 82357c0:	e17ffa17 	ldw	r5,-24(fp)
 82357c4:	1009883a 	mov	r4,r2
 82357c8:	822e9700 	call	822e970 <m_adj>
         break;
 82357cc:	00001306 	br	823581c <tcp_reass+0x2ac>
      }
      q = (struct tcpiphdr *)q->ti_next;
 82357d0:	e0bff717 	ldw	r2,-36(fp)
 82357d4:	10800017 	ldw	r2,0(r2)
 82357d8:	e0bff715 	stw	r2,-36(fp)
      m = dtom(q->ti_prev);
 82357dc:	e0bff717 	ldw	r2,-36(fp)
 82357e0:	10800117 	ldw	r2,4(r2)
 82357e4:	1009883a 	mov	r4,r2
 82357e8:	822eb840 	call	822eb84 <dtom>
 82357ec:	e0bffb15 	stw	r2,-20(fp)
      remque (q->ti_prev);
 82357f0:	e0bff717 	ldw	r2,-36(fp)
 82357f4:	10800117 	ldw	r2,4(r2)
 82357f8:	1009883a 	mov	r4,r2
 82357fc:	822ec200 	call	822ec20 <remque>
      m_freem (m);
 8235800:	e13ffb17 	ldw	r4,-20(fp)
 8235804:	822e6380 	call	822e638 <m_freem>

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 8235808:	e0fff717 	ldw	r3,-36(fp)
 823580c:	e0bffd17 	ldw	r2,-12(fp)
 8235810:	18bfcb1e 	bne	r3,r2,8235740 <tcp_reass+0x1d0>
 8235814:	00000106 	br	823581c <tcp_reass+0x2ac>
   {
      int   i  =  (int)((ti->ti_seq +  ti->ti_len) -  q->ti_seq);
      if (i <= 0)
         break;
 8235818:	0001883a 	nop
   }

   /*
    * Stick new segment in its place.
    */
   insque(ti, q->ti_prev);
 823581c:	e0bff717 	ldw	r2,-36(fp)
 8235820:	10800117 	ldw	r2,4(r2)
 8235824:	100b883a 	mov	r5,r2
 8235828:	e13ffe17 	ldw	r4,-8(fp)
 823582c:	822ec900 	call	822ec90 <insque>
 8235830:	00000106 	br	8235838 <tcp_reass+0x2c8>
   /*
    * Call with ti==0 after become established to
    * force pre-ESTABLISHED data up to user socket.
    */
   if (ti == 0)
      goto present;
 8235834:	0001883a 	nop
present:
   /*
    * Present data to user, advancing rcv_nxt through
    * completed sequence space.
    */
   if (TCPS_HAVERCVDSYN (tp->t_state) == 0)
 8235838:	e0bffd17 	ldw	r2,-12(fp)
 823583c:	10800217 	ldw	r2,8(r2)
 8235840:	108000c8 	cmpgei	r2,r2,3
 8235844:	1000021e 	bne	r2,zero,8235850 <tcp_reass+0x2e0>
      return (0);
 8235848:	0005883a 	mov	r2,zero
 823584c:	00004706 	br	823596c <tcp_reass+0x3fc>
   ti = tp->seg_next;
 8235850:	e0bffd17 	ldw	r2,-12(fp)
 8235854:	10800017 	ldw	r2,0(r2)
 8235858:	e0bffe15 	stw	r2,-8(fp)
   if (ti == (struct tcpiphdr *)tp || ti->ti_seq != tp->rcv_nxt)
 823585c:	e0fffe17 	ldw	r3,-8(fp)
 8235860:	e0bffd17 	ldw	r2,-12(fp)
 8235864:	18800526 	beq	r3,r2,823587c <tcp_reass+0x30c>
 8235868:	e0bffe17 	ldw	r2,-8(fp)
 823586c:	10c00617 	ldw	r3,24(r2)
 8235870:	e0bffd17 	ldw	r2,-12(fp)
 8235874:	10801617 	ldw	r2,88(r2)
 8235878:	18800226 	beq	r3,r2,8235884 <tcp_reass+0x314>
      return (0);
 823587c:	0005883a 	mov	r2,zero
 8235880:	00003a06 	br	823596c <tcp_reass+0x3fc>
   if (tp->t_state == TCPS_SYN_RECEIVED && ti->ti_len)
 8235884:	e0bffd17 	ldw	r2,-12(fp)
 8235888:	10800217 	ldw	r2,8(r2)
 823588c:	108000d8 	cmpnei	r2,r2,3
 8235890:	1000061e 	bne	r2,zero,82358ac <tcp_reass+0x33c>
 8235894:	e0bffe17 	ldw	r2,-8(fp)
 8235898:	1080028b 	ldhu	r2,10(r2)
 823589c:	10bfffcc 	andi	r2,r2,65535
 82358a0:	10000226 	beq	r2,zero,82358ac <tcp_reass+0x33c>
      return (0);
 82358a4:	0005883a 	mov	r2,zero
 82358a8:	00003006 	br	823596c <tcp_reass+0x3fc>
   do 
   {
      tp->rcv_nxt += ti->ti_len;
 82358ac:	e0bffd17 	ldw	r2,-12(fp)
 82358b0:	10c01617 	ldw	r3,88(r2)
 82358b4:	e0bffe17 	ldw	r2,-8(fp)
 82358b8:	1080028b 	ldhu	r2,10(r2)
 82358bc:	10bfffcc 	andi	r2,r2,65535
 82358c0:	1887883a 	add	r3,r3,r2
 82358c4:	e0bffd17 	ldw	r2,-12(fp)
 82358c8:	10c01615 	stw	r3,88(r2)
      flags = ti->ti_flags & TH_FIN;
 82358cc:	e0bffe17 	ldw	r2,-8(fp)
 82358d0:	10800843 	ldbu	r2,33(r2)
 82358d4:	10803fcc 	andi	r2,r2,255
 82358d8:	1080004c 	andi	r2,r2,1
 82358dc:	e0bffc15 	stw	r2,-16(fp)
      remque(ti);
 82358e0:	e13ffe17 	ldw	r4,-8(fp)
 82358e4:	822ec200 	call	822ec20 <remque>
      m = dtom(ti);
 82358e8:	e13ffe17 	ldw	r4,-8(fp)
 82358ec:	822eb840 	call	822eb84 <dtom>
 82358f0:	e0bffb15 	stw	r2,-20(fp)
      ti = (struct tcpiphdr *)ti->ti_next;
 82358f4:	e0bffe17 	ldw	r2,-8(fp)
 82358f8:	10800017 	ldw	r2,0(r2)
 82358fc:	e0bffe15 	stw	r2,-8(fp)
      if (so->so_state & SS_CANTRCVMORE)
 8235900:	e0bff817 	ldw	r2,-32(fp)
 8235904:	1080088b 	ldhu	r2,34(r2)
 8235908:	10bfffcc 	andi	r2,r2,65535
 823590c:	1080080c 	andi	r2,r2,32
 8235910:	10000326 	beq	r2,zero,8235920 <tcp_reass+0x3b0>
         m_freem (m);
 8235914:	e13ffb17 	ldw	r4,-20(fp)
 8235918:	822e6380 	call	822e638 <m_freem>
 823591c:	00000506 	br	8235934 <tcp_reass+0x3c4>
      else
         sbappend (&so->so_rcv, m);
 8235920:	e0bff817 	ldw	r2,-32(fp)
 8235924:	10800a04 	addi	r2,r2,40
 8235928:	e17ffb17 	ldw	r5,-20(fp)
 823592c:	1009883a 	mov	r4,r2
 8235930:	82343f40 	call	82343f4 <sbappend>
   } while (ti != (struct tcpiphdr *)tp && ti->ti_seq == tp->rcv_nxt);
 8235934:	e0fffe17 	ldw	r3,-8(fp)
 8235938:	e0bffd17 	ldw	r2,-12(fp)
 823593c:	18800526 	beq	r3,r2,8235954 <tcp_reass+0x3e4>
 8235940:	e0bffe17 	ldw	r2,-8(fp)
 8235944:	10c00617 	ldw	r3,24(r2)
 8235948:	e0bffd17 	ldw	r2,-12(fp)
 823594c:	10801617 	ldw	r2,88(r2)
 8235950:	18bfd626 	beq	r3,r2,82358ac <tcp_reass+0x33c>
      sorwakeup(so);
 8235954:	e0bff817 	ldw	r2,-32(fp)
 8235958:	10800a04 	addi	r2,r2,40
 823595c:	100b883a 	mov	r5,r2
 8235960:	e13ff817 	ldw	r4,-32(fp)
 8235964:	82342440 	call	8234244 <sbwakeup>
   return (flags);
 8235968:	e0bffc17 	ldw	r2,-16(fp)
drop:
   /**m_freem (dtom(ti));**/
   m_freem (ti_mbuf);
   return (0);
}
 823596c:	e037883a 	mov	sp,fp
 8235970:	dfc00117 	ldw	ra,4(sp)
 8235974:	df000017 	ldw	fp,0(sp)
 8235978:	dec00204 	addi	sp,sp,8
 823597c:	f800283a 	ret

08235980 <tcp_input>:
 * RETURNS: void
 */

void
tcp_input(struct mbuf * m, NET ifp)
{
 8235980:	deffdf04 	addi	sp,sp,-132
 8235984:	dfc02015 	stw	ra,128(sp)
 8235988:	df001f15 	stw	fp,124(sp)
 823598c:	df001f04 	addi	fp,sp,124
 8235990:	e13ffe15 	stw	r4,-8(fp)
 8235994:	e17fff15 	stw	r5,-4(fp)
   ip6_addr    ip6_src;
   ip6_addr    ip6_dst;
#endif   /* IP_V6 */
   struct tcpiphdr * ti;
   struct inpcb * inp;
   struct mbuf *  om =  0;
 8235998:	e03fe515 	stw	zero,-108(fp)
   int   len,  tlen, off;
   struct tcpcb * tp =  0;
 823599c:	e03fe615 	stw	zero,-104(fp)
   int   tiflags;
   struct socket *   so =  NULL;
 82359a0:	e03fe815 	stw	zero,-96(fp)
   int   todrop,  acked,   ourfinisacked, needoutput  =  0;
 82359a4:	e03feb15 	stw	zero,-84(fp)
   int   dropsocket  =  0;
 82359a8:	e03fec15 	stw	zero,-80(fp)
   long  iss   =  0;
 82359ac:	e03fed15 	stw	zero,-76(fp)
#ifdef DO_TCPTRACE
   int   ostate;
#endif


   tcpstat.tcps_rcvtotal++;
 82359b0:	008209b4 	movhi	r2,2086
 82359b4:	10b98b04 	addi	r2,r2,-6612
 82359b8:	10801917 	ldw	r2,100(r2)
 82359bc:	10c00044 	addi	r3,r2,1
 82359c0:	008209b4 	movhi	r2,2086
 82359c4:	10b98b04 	addi	r2,r2,-6612
 82359c8:	10c01915 	stw	r3,100(r2)
   TCP_MIB_INC(tcpInSegs);    /* keep MIB stats */
 82359cc:	008209b4 	movhi	r2,2086
 82359d0:	10b95d04 	addi	r2,r2,-6796
 82359d4:	10800917 	ldw	r2,36(r2)
 82359d8:	10c00044 	addi	r3,r2,1
 82359dc:	008209b4 	movhi	r2,2086
 82359e0:	10b95d04 	addi	r2,r2,-6796
 82359e4:	10c00915 	stw	r3,36(r2)
   {
      /*
       * Get IP and TCP header together in first mbuf.
       * Note: IP leaves IP header in first mbuf.
       */
      pip = mtod(m, struct ip *);
 82359e8:	e0bffe17 	ldw	r2,-8(fp)
 82359ec:	10800317 	ldw	r2,12(r2)
 82359f0:	e0bfe315 	stw	r2,-116(fp)
      if (pip->ip_ver_ihl > 0x45)   /* IP v4, 5 dword hdr len */
 82359f4:	e0bfe317 	ldw	r2,-116(fp)
 82359f8:	10800003 	ldbu	r2,0(r2)
 82359fc:	10803fcc 	andi	r2,r2,255
 8235a00:	108011b0 	cmpltui	r2,r2,70
 8235a04:	1000061e 	bne	r2,zero,8235a20 <tcp_input+0xa0>
      {
         np_stripoptions(pip, (struct mbuf *)m);
 8235a08:	e17ffe17 	ldw	r5,-8(fp)
 8235a0c:	e13fe317 	ldw	r4,-116(fp)
 8235a10:	822f5bc0 	call	822f5bc <np_stripoptions>
         pip = mtod(m, struct ip *);
 8235a14:	e0bffe17 	ldw	r2,-8(fp)
 8235a18:	10800317 	ldw	r2,12(r2)
 8235a1c:	e0bfe315 	stw	r2,-116(fp)
      }
      if (m->m_len < ((sizeof (struct ip) + sizeof (struct tcphdr))))
 8235a20:	e0bffe17 	ldw	r2,-8(fp)
 8235a24:	10800217 	ldw	r2,8(r2)
 8235a28:	10800a28 	cmpgeui	r2,r2,40
 8235a2c:	1000081e 	bne	r2,zero,8235a50 <tcp_input+0xd0>
      {
         tcpstat.tcps_rcvshort++;
 8235a30:	008209b4 	movhi	r2,2086
 8235a34:	10b98b04 	addi	r2,r2,-6612
 8235a38:	10801e17 	ldw	r2,120(r2)
 8235a3c:	10c00044 	addi	r3,r2,1
 8235a40:	008209b4 	movhi	r2,2086
 8235a44:	10b98b04 	addi	r2,r2,-6612
 8235a48:	10c01e15 	stw	r3,120(r2)
         return;
 8235a4c:	00089306 	br	8237c9c <tcp_input+0x231c>
      }
      tlen = pip->ip_len;     /* this was fudged by IP layer */
 8235a50:	e0bfe317 	ldw	r2,-116(fp)
 8235a54:	1080008b 	ldhu	r2,2(r2)
 8235a58:	10bfffcc 	andi	r2,r2,65535
 8235a5c:	e0bff115 	stw	r2,-60(fp)
      /* The following is needed in the cases where the size of the
       * overlay structure is larger than the size of the ip header.
       * This can happen if the ih_next and ih_prev pointers in the
       * overlay structure are larger than 32 bit pointers.
       */
      ti = (struct tcpiphdr *)(m->m_data + sizeof(struct ip) - 
 8235a60:	e0bffe17 	ldw	r2,-8(fp)
 8235a64:	10800317 	ldw	r2,12(r2)
 8235a68:	e0bff215 	stw	r2,-56(fp)
         sizeof(struct ipovly));
      if ((char *)ti < m->pkt->nb_buff)
 8235a6c:	e0bffe17 	ldw	r2,-8(fp)
 8235a70:	10800117 	ldw	r2,4(r2)
 8235a74:	10800117 	ldw	r2,4(r2)
 8235a78:	e0fff217 	ldw	r3,-56(fp)
 8235a7c:	1880032e 	bgeu	r3,r2,8235a8c <tcp_input+0x10c>
      {
         panic("tcp_input");
 8235a80:	01020974 	movhi	r4,2085
 8235a84:	21039a04 	addi	r4,r4,3688
 8235a88:	8228c480 	call	8228c48 <panic>
   /*
    * Check that TCP offset makes sense,
    * pull out TCP options and adjust length.
    */

   off = GET_TH_OFF(ti->ti_t) << 2;
 8235a8c:	e0bff217 	ldw	r2,-56(fp)
 8235a90:	10800803 	ldbu	r2,32(r2)
 8235a94:	10803fcc 	andi	r2,r2,255
 8235a98:	1004d13a 	srli	r2,r2,4
 8235a9c:	10803fcc 	andi	r2,r2,255
 8235aa0:	1085883a 	add	r2,r2,r2
 8235aa4:	1085883a 	add	r2,r2,r2
 8235aa8:	e0bff315 	stw	r2,-52(fp)
   if (off < sizeof (struct tcphdr) || off > tlen) 
 8235aac:	e0bff317 	ldw	r2,-52(fp)
 8235ab0:	10800530 	cmpltui	r2,r2,20
 8235ab4:	1000031e 	bne	r2,zero,8235ac4 <tcp_input+0x144>
 8235ab8:	e0bff317 	ldw	r2,-52(fp)
 8235abc:	e0fff117 	ldw	r3,-60(fp)
 8235ac0:	1880110e 	bge	r3,r2,8235b08 <tcp_input+0x188>
   {
#ifdef DO_TCPTRACE
      tcp_trace("tcp off: src %x off %d\n", ti->ti_src, off);
#endif
      tcpstat.tcps_rcvbadoff++;
 8235ac4:	008209b4 	movhi	r2,2086
 8235ac8:	10b98b04 	addi	r2,r2,-6612
 8235acc:	10801d17 	ldw	r2,116(r2)
 8235ad0:	10c00044 	addi	r3,r2,1
 8235ad4:	008209b4 	movhi	r2,2086
 8235ad8:	10b98b04 	addi	r2,r2,-6612
 8235adc:	10c01d15 	stw	r3,116(r2)
      TCP_MIB_INC(tcpInErrs);   /* keep MIB stats */
 8235ae0:	008209b4 	movhi	r2,2086
 8235ae4:	10b95d04 	addi	r2,r2,-6796
 8235ae8:	10800d17 	ldw	r2,52(r2)
 8235aec:	10c00044 	addi	r3,r2,1
 8235af0:	008209b4 	movhi	r2,2086
 8235af4:	10b95d04 	addi	r2,r2,-6796
 8235af8:	10c00d15 	stw	r3,52(r2)
      GOTO_DROP;
 8235afc:	00805784 	movi	r2,350
 8235b00:	d0a0b215 	stw	r2,-32056(gp)
 8235b04:	00085006 	br	8237c48 <tcp_input+0x22c8>
   }
   tlen -= (int)off;
 8235b08:	e0fff117 	ldw	r3,-60(fp)
 8235b0c:	e0bff317 	ldw	r2,-52(fp)
 8235b10:	1885c83a 	sub	r2,r3,r2
 8235b14:	e0bff115 	stw	r2,-60(fp)
   ti->ti_len = (u_short)tlen;
 8235b18:	e0bff117 	ldw	r2,-60(fp)
 8235b1c:	1007883a 	mov	r3,r2
 8235b20:	e0bff217 	ldw	r2,-56(fp)
 8235b24:	10c0028d 	sth	r3,10(r2)
   if (off > sizeof (struct tcphdr)) 
 8235b28:	e0bff317 	ldw	r2,-52(fp)
 8235b2c:	10800570 	cmpltui	r2,r2,21
 8235b30:	1000331e 	bne	r2,zero,8235c00 <tcp_input+0x280>
   {
      int olen;      /* length of options field */
      u_char * op;   /* scratch option pointer */

      olen = off - sizeof (struct tcphdr);   /* get options length */
 8235b34:	e0bff317 	ldw	r2,-52(fp)
 8235b38:	10bffb04 	addi	r2,r2,-20
 8235b3c:	e0bff415 	stw	r2,-48(fp)
      om = m_getwithdata (MT_RXDATA, olen);  /* get mbuf for opts */
 8235b40:	e17ff417 	ldw	r5,-48(fp)
 8235b44:	01000044 	movi	r4,1
 8235b48:	822e3a80 	call	822e3a8 <m_getnbuf>
 8235b4c:	e0bfe515 	stw	r2,-108(fp)
      if (om == 0)
 8235b50:	e0bfe517 	ldw	r2,-108(fp)
 8235b54:	1000031e 	bne	r2,zero,8235b64 <tcp_input+0x1e4>
         GOTO_DROP;
 8235b58:	00805a84 	movi	r2,362
 8235b5c:	d0a0b215 	stw	r2,-32056(gp)
 8235b60:	00083906 	br	8237c48 <tcp_input+0x22c8>
      om->m_len = olen;       /* set mbuf length */
 8235b64:	e0fff417 	ldw	r3,-48(fp)
 8235b68:	e0bfe517 	ldw	r2,-108(fp)
 8235b6c:	10c00215 	stw	r3,8(r2)
      /* set pointer to options field at end of TCP header */
      if(m->pkt->type == htons(0x86DD))   /* IPv6 packet */
 8235b70:	e0bffe17 	ldw	r2,-8(fp)
 8235b74:	10800117 	ldw	r2,4(r2)
 8235b78:	1080080b 	ldhu	r2,32(r2)
 8235b7c:	10ffffcc 	andi	r3,r2,65535
 8235b80:	00b76194 	movui	r2,56710
 8235b84:	1880051e 	bne	r3,r2,8235b9c <tcp_input+0x21c>
         op = (u_char*)(m->m_data + 20);  /* past TCP header */
 8235b88:	e0bffe17 	ldw	r2,-8(fp)
 8235b8c:	10800317 	ldw	r2,12(r2)
 8235b90:	10800504 	addi	r2,r2,20
 8235b94:	e0bfee15 	stw	r2,-72(fp)
 8235b98:	00000406 	br	8235bac <tcp_input+0x22c>
      else
         op = (u_char*)(m->m_data + 40);  /* past IP + TCP */
 8235b9c:	e0bffe17 	ldw	r2,-8(fp)
 8235ba0:	10800317 	ldw	r2,12(r2)
 8235ba4:	10800a04 	addi	r2,r2,40
 8235ba8:	e0bfee15 	stw	r2,-72(fp)
      MEMCPY(om->m_data, op, olen); /* copy to new mbuf */
 8235bac:	e0bfe517 	ldw	r2,-108(fp)
 8235bb0:	10800317 	ldw	r2,12(r2)
 8235bb4:	e0fff417 	ldw	r3,-48(fp)
 8235bb8:	180d883a 	mov	r6,r3
 8235bbc:	e17fee17 	ldw	r5,-72(fp)
 8235bc0:	1009883a 	mov	r4,r2
 8235bc4:	8202f100 	call	8202f10 <memcpy>

      /* strip options from data mbuf. This actually just cuts the first 
       * m_len bytes from the TCP header, but it leaves the mbuf members 
       * set so the adjustment below does the right thing.
       */
      m->m_data += om->m_len;
 8235bc8:	e0bffe17 	ldw	r2,-8(fp)
 8235bcc:	10c00317 	ldw	r3,12(r2)
 8235bd0:	e0bfe517 	ldw	r2,-108(fp)
 8235bd4:	10800217 	ldw	r2,8(r2)
 8235bd8:	1887883a 	add	r3,r3,r2
 8235bdc:	e0bffe17 	ldw	r2,-8(fp)
 8235be0:	10c00315 	stw	r3,12(r2)
      m->m_len -= om->m_len;
 8235be4:	e0bffe17 	ldw	r2,-8(fp)
 8235be8:	10c00217 	ldw	r3,8(r2)
 8235bec:	e0bfe517 	ldw	r2,-108(fp)
 8235bf0:	10800217 	ldw	r2,8(r2)
 8235bf4:	1887c83a 	sub	r3,r3,r2
 8235bf8:	e0bffe17 	ldw	r2,-8(fp)
 8235bfc:	10c00215 	stw	r3,8(r2)
   }
   tiflags = ti->ti_flags;
 8235c00:	e0bff217 	ldw	r2,-56(fp)
 8235c04:	10800843 	ldbu	r2,33(r2)
 8235c08:	10803fcc 	andi	r2,r2,255
 8235c0c:	e0bfe715 	stw	r2,-100(fp)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   /* Convert TCP protocol specific fields to host format. */
   ti->ti_seq = ntohl(ti->ti_seq);
 8235c10:	e0bff217 	ldw	r2,-56(fp)
 8235c14:	10800617 	ldw	r2,24(r2)
 8235c18:	1006d63a 	srli	r3,r2,24
 8235c1c:	e0bff217 	ldw	r2,-56(fp)
 8235c20:	10800617 	ldw	r2,24(r2)
 8235c24:	1004d23a 	srli	r2,r2,8
 8235c28:	10bfc00c 	andi	r2,r2,65280
 8235c2c:	1886b03a 	or	r3,r3,r2
 8235c30:	e0bff217 	ldw	r2,-56(fp)
 8235c34:	10800617 	ldw	r2,24(r2)
 8235c38:	10bfc00c 	andi	r2,r2,65280
 8235c3c:	1004923a 	slli	r2,r2,8
 8235c40:	1886b03a 	or	r3,r3,r2
 8235c44:	e0bff217 	ldw	r2,-56(fp)
 8235c48:	10800617 	ldw	r2,24(r2)
 8235c4c:	1004963a 	slli	r2,r2,24
 8235c50:	1886b03a 	or	r3,r3,r2
 8235c54:	e0bff217 	ldw	r2,-56(fp)
 8235c58:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = ntohl(ti->ti_ack);
 8235c5c:	e0bff217 	ldw	r2,-56(fp)
 8235c60:	10800717 	ldw	r2,28(r2)
 8235c64:	1006d63a 	srli	r3,r2,24
 8235c68:	e0bff217 	ldw	r2,-56(fp)
 8235c6c:	10800717 	ldw	r2,28(r2)
 8235c70:	1004d23a 	srli	r2,r2,8
 8235c74:	10bfc00c 	andi	r2,r2,65280
 8235c78:	1886b03a 	or	r3,r3,r2
 8235c7c:	e0bff217 	ldw	r2,-56(fp)
 8235c80:	10800717 	ldw	r2,28(r2)
 8235c84:	10bfc00c 	andi	r2,r2,65280
 8235c88:	1004923a 	slli	r2,r2,8
 8235c8c:	1886b03a 	or	r3,r3,r2
 8235c90:	e0bff217 	ldw	r2,-56(fp)
 8235c94:	10800717 	ldw	r2,28(r2)
 8235c98:	1004963a 	slli	r2,r2,24
 8235c9c:	1886b03a 	or	r3,r3,r2
 8235ca0:	e0bff217 	ldw	r2,-56(fp)
 8235ca4:	10c00715 	stw	r3,28(r2)
   ti->ti_urp = ntohs(ti->ti_urp);
 8235ca8:	e0bff217 	ldw	r2,-56(fp)
 8235cac:	1080098b 	ldhu	r2,38(r2)
 8235cb0:	10bfffcc 	andi	r2,r2,65535
 8235cb4:	1004d23a 	srli	r2,r2,8
 8235cb8:	1007883a 	mov	r3,r2
 8235cbc:	e0bff217 	ldw	r2,-56(fp)
 8235cc0:	1080098b 	ldhu	r2,38(r2)
 8235cc4:	10bfffcc 	andi	r2,r2,65535
 8235cc8:	1004923a 	slli	r2,r2,8
 8235ccc:	1884b03a 	or	r2,r3,r2
 8235cd0:	1007883a 	mov	r3,r2
 8235cd4:	e0bff217 	ldw	r2,-56(fp)
 8235cd8:	10c0098d 	sth	r3,38(r2)
   /*
    * Locate pcb for segment.
    */
findpcb:

   switch(m->pkt->type)
 8235cdc:	e0bffe17 	ldw	r2,-8(fp)
 8235ce0:	10800117 	ldw	r2,4(r2)
 8235ce4:	1080080b 	ldhu	r2,32(r2)
 8235ce8:	10bfffcc 	andi	r2,r2,65535
 8235cec:	10800220 	cmpeqi	r2,r2,8
 8235cf0:	10002226 	beq	r2,zero,8235d7c <tcp_input+0x3fc>
   {
#ifdef IP_V4
   case  IPTP:   /* IPv4 packet */
      /* Drop TCP and IP headers; TCP options were dropped above. */
      m->m_data += 40;
 8235cf4:	e0bffe17 	ldw	r2,-8(fp)
 8235cf8:	10800317 	ldw	r2,12(r2)
 8235cfc:	10c00a04 	addi	r3,r2,40
 8235d00:	e0bffe17 	ldw	r2,-8(fp)
 8235d04:	10c00315 	stw	r3,12(r2)
      m->m_len -= 40;
 8235d08:	e0bffe17 	ldw	r2,-8(fp)
 8235d0c:	10800217 	ldw	r2,8(r2)
 8235d10:	10fff604 	addi	r3,r2,-40
 8235d14:	e0bffe17 	ldw	r2,-8(fp)
 8235d18:	10c00215 	stw	r3,8(r2)

      inp = in_pcblookup(&tcb, ti->ti_src.s_addr, ti->ti_sport, 
 8235d1c:	e0bff217 	ldw	r2,-56(fp)
 8235d20:	11000317 	ldw	r4,12(r2)
 8235d24:	e0bff217 	ldw	r2,-56(fp)
 8235d28:	1080050b 	ldhu	r2,20(r2)
 8235d2c:	117fffcc 	andi	r5,r2,65535
 8235d30:	e0bff217 	ldw	r2,-56(fp)
 8235d34:	11800417 	ldw	r6,16(r2)
         ti->ti_dst.s_addr, ti->ti_dport, INPLOOKUP_WILDCARD);
 8235d38:	e0bff217 	ldw	r2,-56(fp)
 8235d3c:	1080058b 	ldhu	r2,22(r2)
   case  IPTP:   /* IPv4 packet */
      /* Drop TCP and IP headers; TCP options were dropped above. */
      m->m_data += 40;
      m->m_len -= 40;

      inp = in_pcblookup(&tcb, ti->ti_src.s_addr, ti->ti_sport, 
 8235d40:	10bfffcc 	andi	r2,r2,65535
 8235d44:	00c00044 	movi	r3,1
 8235d48:	d8c00115 	stw	r3,4(sp)
 8235d4c:	d8800015 	stw	r2,0(sp)
 8235d50:	300f883a 	mov	r7,r6
 8235d54:	280d883a 	mov	r6,r5
 8235d58:	200b883a 	mov	r5,r4
 8235d5c:	010209b4 	movhi	r4,2086
 8235d60:	21398004 	addi	r4,r4,-6656
 8235d64:	824846c0 	call	824846c <in_pcblookup>
 8235d68:	e0bfe415 	stw	r2,-112(fp)
         ti->ti_dst.s_addr, ti->ti_dport, INPLOOKUP_WILDCARD);
      break;
 8235d6c:	0001883a 	nop
    * If the state is CLOSED (i.e., TCB does not exist) then
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
 8235d70:	e0bfe417 	ldw	r2,-112(fp)
 8235d74:	1000061e 	bne	r2,zero,8235d90 <tcp_input+0x410>
 8235d78:	00000206 	br	8235d84 <tcp_input+0x404>
      inp = ip6_pcblookup(&tcb, &ip6_src, ti->ti_sport, 
         &ip6_dst, ti->ti_dport, INPLOOKUP_WILDCARD);
      break;
#endif   /* IP_V6 */
   default:
      dtrap();
 8235d7c:	822d5940 	call	822d594 <dtrap>
      return;
 8235d80:	0007c606 	br	8237c9c <tcp_input+0x231c>
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
      GOTO_DROPWITHRESET;
 8235d84:	00806b04 	movi	r2,428
 8235d88:	d0a0b215 	stw	r2,-32056(gp)
 8235d8c:	00076d06 	br	8237b44 <tcp_input+0x21c4>
   tp = intotcpcb (inp);
 8235d90:	e0bfe417 	ldw	r2,-112(fp)
 8235d94:	10800917 	ldw	r2,36(r2)
 8235d98:	e0bfe615 	stw	r2,-104(fp)
   if (tp == 0)
 8235d9c:	e0bfe617 	ldw	r2,-104(fp)
 8235da0:	1000031e 	bne	r2,zero,8235db0 <tcp_input+0x430>
      GOTO_DROPWITHRESET;
 8235da4:	00806bc4 	movi	r2,431
 8235da8:	d0a0b215 	stw	r2,-32056(gp)
 8235dac:	00076506 	br	8237b44 <tcp_input+0x21c4>
   if (tp->t_state == TCPS_CLOSED)
 8235db0:	e0bfe617 	ldw	r2,-104(fp)
 8235db4:	10800217 	ldw	r2,8(r2)
 8235db8:	1000031e 	bne	r2,zero,8235dc8 <tcp_input+0x448>
      GOTO_DROP;
 8235dbc:	00806c44 	movi	r2,433
 8235dc0:	d0a0b215 	stw	r2,-32056(gp)
 8235dc4:	0007a006 	br	8237c48 <tcp_input+0x22c8>
   so = inp->inp_socket;
 8235dc8:	e0bfe417 	ldw	r2,-112(fp)
 8235dcc:	10800817 	ldw	r2,32(r2)
 8235dd0:	e0bfe815 	stw	r2,-96(fp)
      tcp_saveti = *ti;
   }
#endif

   /* figure out the size of the other guy's receive window */
   rx_win = (tcp_win)(ntohs(ti->ti_win));    /* convert endian */
 8235dd4:	e0bff217 	ldw	r2,-56(fp)
 8235dd8:	1080088b 	ldhu	r2,34(r2)
 8235ddc:	10bfffcc 	andi	r2,r2,65535
 8235de0:	1004d23a 	srli	r2,r2,8
 8235de4:	10bfffcc 	andi	r2,r2,65535
 8235de8:	10c03fcc 	andi	r3,r2,255
 8235dec:	e0bff217 	ldw	r2,-56(fp)
 8235df0:	1080088b 	ldhu	r2,34(r2)
 8235df4:	10bfffcc 	andi	r2,r2,65535
 8235df8:	1004923a 	slli	r2,r2,8
 8235dfc:	10bfffcc 	andi	r2,r2,65535
 8235e00:	1884b03a 	or	r2,r3,r2
 8235e04:	e0bff515 	stw	r2,-44(fp)
   {
      rx_win <<= tp->snd_wind_scale;         /* apply scale */
   }
#endif /* TCP_WIN_SCALE */

   if (so->so_options & SO_ACCEPTCONN) 
 8235e08:	e0bfe817 	ldw	r2,-96(fp)
 8235e0c:	10800417 	ldw	r2,16(r2)
 8235e10:	1080008c 	andi	r2,r2,2
 8235e14:	10002c26 	beq	r2,zero,8235ec8 <tcp_input+0x548>
   {
      so = sonewconn(so);
 8235e18:	e13fe817 	ldw	r4,-96(fp)
 8235e1c:	8233d380 	call	8233d38 <sonewconn>
 8235e20:	e0bfe815 	stw	r2,-96(fp)
      if (so == 0)
 8235e24:	e0bfe817 	ldw	r2,-96(fp)
 8235e28:	1000031e 	bne	r2,zero,8235e38 <tcp_input+0x4b8>
         GOTO_DROP;
 8235e2c:	00807344 	movi	r2,461
 8235e30:	d0a0b215 	stw	r2,-32056(gp)
 8235e34:	00078406 	br	8237c48 <tcp_input+0x22c8>
       * flag dropsocket to see if the temporary
       * socket created here should be discarded.
       * We mark the socket as discardable until
       * we're committed to it below in TCPS_LISTEN.
       */
      dropsocket++;
 8235e38:	e0bfec17 	ldw	r2,-80(fp)
 8235e3c:	10800044 	addi	r2,r2,1
 8235e40:	e0bfec15 	stw	r2,-80(fp)

      inp = (struct inpcb *)so->so_pcb;
 8235e44:	e0bfe817 	ldw	r2,-96(fp)
 8235e48:	10800117 	ldw	r2,4(r2)
 8235e4c:	e0bfe415 	stw	r2,-112(fp)
      inp->ifp = ifp;      /* save iface to peer */
 8235e50:	e0bfe417 	ldw	r2,-112(fp)
 8235e54:	e0ffff17 	ldw	r3,-4(fp)
 8235e58:	10c00a15 	stw	r3,40(r2)

      switch(so->so_domain)
 8235e5c:	e0bfe817 	ldw	r2,-96(fp)
 8235e60:	10800517 	ldw	r2,20(r2)
 8235e64:	108000a0 	cmpeqi	r2,r2,2
 8235e68:	10000d26 	beq	r2,zero,8235ea0 <tcp_input+0x520>
      {
#ifdef IP_V4
      case AF_INET:
         inp->inp_laddr = ti->ti_dst;
 8235e6c:	e0bfe417 	ldw	r2,-112(fp)
 8235e70:	e0fff217 	ldw	r3,-56(fp)
 8235e74:	18c00417 	ldw	r3,16(r3)
 8235e78:	10c00415 	stw	r3,16(r2)
#ifdef IP_PMTU
         inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
         inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 8235e7c:	e0bfff17 	ldw	r2,-4(fp)
 8235e80:	10c00917 	ldw	r3,36(r2)
 8235e84:	e0bfff17 	ldw	r2,-4(fp)
 8235e88:	10800817 	ldw	r2,32(r2)
 8235e8c:	10800a04 	addi	r2,r2,40
 8235e90:	1887c83a 	sub	r3,r3,r2
 8235e94:	e0bfe417 	ldw	r2,-112(fp)
 8235e98:	10c00615 	stw	r3,24(r2)
#endif   /* IP_PMTU */
         break;
 8235e9c:	0001883a 	nop
         inp->inp_pmtu = ip6_pmtulookup(&ip6_src, ifp);
         break;
#endif   /* end v6 */
      }

      inp->inp_lport = ti->ti_dport;
 8235ea0:	e0bff217 	ldw	r2,-56(fp)
 8235ea4:	10c0058b 	ldhu	r3,22(r2)
 8235ea8:	e0bfe417 	ldw	r2,-112(fp)
 8235eac:	10c0078d 	sth	r3,30(r2)
      tp = intotcpcb(inp);
 8235eb0:	e0bfe417 	ldw	r2,-112(fp)
 8235eb4:	10800917 	ldw	r2,36(r2)
 8235eb8:	e0bfe615 	stw	r2,-104(fp)
      tp->t_state = TCPS_LISTEN;
 8235ebc:	e0bfe617 	ldw	r2,-104(fp)
 8235ec0:	00c00044 	movi	r3,1
 8235ec4:	10c00215 	stw	r3,8(r2)

   /*
    * Segment received on connection.
    * Reset idle time and keep-alive timer.
    */
   tp->t_idle = 0;
 8235ec8:	e0bfe617 	ldw	r2,-104(fp)
 8235ecc:	10001d15 	stw	zero,116(r2)
   tp->t_timer[TCPT_KEEP] = tcp_keepidle;
 8235ed0:	d0e03e17 	ldw	r3,-32520(gp)
 8235ed4:	e0bfe617 	ldw	r2,-104(fp)
 8235ed8:	10c00515 	stw	r3,20(r2)

   /*
    * Process options if not in LISTEN state,
    * else do it below (after getting remote address).
    */
   if (om && tp->t_state != TCPS_LISTEN) 
 8235edc:	e0bfe517 	ldw	r2,-108(fp)
 8235ee0:	10000926 	beq	r2,zero,8235f08 <tcp_input+0x588>
 8235ee4:	e0bfe617 	ldw	r2,-104(fp)
 8235ee8:	10800217 	ldw	r2,8(r2)
 8235eec:	10800060 	cmpeqi	r2,r2,1
 8235ef0:	1000051e 	bne	r2,zero,8235f08 <tcp_input+0x588>
   {
      tcp_dooptions(tp, om, ti);
 8235ef4:	e1bff217 	ldw	r6,-56(fp)
 8235ef8:	e17fe517 	ldw	r5,-108(fp)
 8235efc:	e13fe617 	ldw	r4,-104(fp)
 8235f00:	8237cb00 	call	8237cb0 <tcp_dooptions>
      om = 0;
 8235f04:	e03fe515 	stw	zero,-108(fp)
   }

   acked = (int)(ti->ti_ack - tp->snd_una);
 8235f08:	e0bff217 	ldw	r2,-56(fp)
 8235f0c:	10c00717 	ldw	r3,28(r2)
 8235f10:	e0bfe617 	ldw	r2,-104(fp)
 8235f14:	10800e17 	ldw	r2,56(r2)
 8235f18:	1885c83a 	sub	r2,r3,r2
 8235f1c:	e0bff615 	stw	r2,-40(fp)
    * Receive window is amount of space in rcv queue,
    * but not less than advertised window.
    */
   { long win;

      win = (long)sbspace(&so->so_rcv);
 8235f20:	e0bfe817 	ldw	r2,-96(fp)
 8235f24:	10800b17 	ldw	r2,44(r2)
 8235f28:	1007883a 	mov	r3,r2
 8235f2c:	e0bfe817 	ldw	r2,-96(fp)
 8235f30:	10800a17 	ldw	r2,40(r2)
 8235f34:	1885c83a 	sub	r2,r3,r2
 8235f38:	10000616 	blt	r2,zero,8235f54 <tcp_input+0x5d4>
 8235f3c:	e0bfe817 	ldw	r2,-96(fp)
 8235f40:	10c00b17 	ldw	r3,44(r2)
 8235f44:	e0bfe817 	ldw	r2,-96(fp)
 8235f48:	10800a17 	ldw	r2,40(r2)
 8235f4c:	1885c83a 	sub	r2,r3,r2
 8235f50:	00000106 	br	8235f58 <tcp_input+0x5d8>
 8235f54:	0005883a 	mov	r2,zero
 8235f58:	e0bfef15 	stw	r2,-68(fp)
      if (win < 0)
 8235f5c:	e0bfef17 	ldw	r2,-68(fp)
 8235f60:	1000010e 	bge	r2,zero,8235f68 <tcp_input+0x5e8>
         win = 0;
 8235f64:	e03fef15 	stw	zero,-68(fp)
      tp->rcv_wnd = (tcp_win)MAX((u_long)win, (tp->rcv_adv - tp->rcv_nxt));
 8235f68:	e0bfe617 	ldw	r2,-104(fp)
 8235f6c:	10c01917 	ldw	r3,100(r2)
 8235f70:	e0bfe617 	ldw	r2,-104(fp)
 8235f74:	10801617 	ldw	r2,88(r2)
 8235f78:	1885c83a 	sub	r2,r3,r2
 8235f7c:	e0ffef17 	ldw	r3,-68(fp)
 8235f80:	10c0012e 	bgeu	r2,r3,8235f88 <tcp_input+0x608>
 8235f84:	1805883a 	mov	r2,r3
 8235f88:	e0ffe617 	ldw	r3,-104(fp)
 8235f8c:	18801515 	stw	r2,84(r3)
    * is non-zero and the ack didn't move, we're the
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
 8235f90:	e0bfe617 	ldw	r2,-104(fp)
 8235f94:	10800217 	ldw	r2,8(r2)
 8235f98:	10800118 	cmpnei	r2,r2,4
 8235f9c:	1001021e 	bne	r2,zero,82363a8 <tcp_input+0xa28>
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
 8235fa0:	e0bfe717 	ldw	r2,-100(fp)
 8235fa4:	10800dcc 	andi	r2,r2,55
    * is non-zero and the ack didn't move, we're the
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
 8235fa8:	10800418 	cmpnei	r2,r2,16
 8235fac:	1000fe1e 	bne	r2,zero,82363a8 <tcp_input+0xa28>
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
       (ti->ti_seq == tp->rcv_nxt) &&
 8235fb0:	e0bff217 	ldw	r2,-56(fp)
 8235fb4:	10c00617 	ldw	r3,24(r2)
 8235fb8:	e0bfe617 	ldw	r2,-104(fp)
 8235fbc:	10801617 	ldw	r2,88(r2)
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
 8235fc0:	1880f91e 	bne	r3,r2,82363a8 <tcp_input+0xa28>
       (ti->ti_seq == tp->rcv_nxt) &&
 8235fc4:	e0bff517 	ldw	r2,-44(fp)
 8235fc8:	1000f726 	beq	r2,zero,82363a8 <tcp_input+0xa28>
       (rx_win && rx_win == tp->snd_wnd) &&
 8235fcc:	e0bfe617 	ldw	r2,-104(fp)
 8235fd0:	10c01417 	ldw	r3,80(r2)
 8235fd4:	e0bff517 	ldw	r2,-44(fp)
 8235fd8:	1880f31e 	bne	r3,r2,82363a8 <tcp_input+0xa28>
       (tp->snd_nxt == tp->snd_max))
 8235fdc:	e0bfe617 	ldw	r2,-104(fp)
 8235fe0:	10c00f17 	ldw	r3,60(r2)
 8235fe4:	e0bfe617 	ldw	r2,-104(fp)
 8235fe8:	10801a17 	ldw	r2,104(r2)
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
       (ti->ti_seq == tp->rcv_nxt) &&
       (rx_win && rx_win == tp->snd_wnd) &&
 8235fec:	1880ee1e 	bne	r3,r2,82363a8 <tcp_input+0xa28>
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
 8235ff0:	e0bff217 	ldw	r2,-56(fp)
 8235ff4:	1080028b 	ldhu	r2,10(r2)
 8235ff8:	10bfffcc 	andi	r2,r2,65535
 8235ffc:	1000611e 	bne	r2,zero,8236184 <tcp_input+0x804>
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
 8236000:	e0bff217 	ldw	r2,-56(fp)
 8236004:	10c00717 	ldw	r3,28(r2)
 8236008:	e0bfe617 	ldw	r2,-104(fp)
 823600c:	10800e17 	ldw	r2,56(r2)
 8236010:	1885c83a 	sub	r2,r3,r2
 8236014:	0080e40e 	bge	zero,r2,82363a8 <tcp_input+0xa28>
             SEQ_LEQ(ti->ti_ack, tp->snd_max) &&
 8236018:	e0bff217 	ldw	r2,-56(fp)
 823601c:	10c00717 	ldw	r3,28(r2)
 8236020:	e0bfe617 	ldw	r2,-104(fp)
 8236024:	10801a17 	ldw	r2,104(r2)
 8236028:	1885c83a 	sub	r2,r3,r2
       (rx_win && rx_win == tp->snd_wnd) &&
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
 823602c:	0080de16 	blt	zero,r2,82363a8 <tcp_input+0xa28>
             SEQ_LEQ(ti->ti_ack, tp->snd_max) &&
             tp->snd_cwnd >= tp->snd_wnd) 
 8236030:	e0bfe617 	ldw	r2,-104(fp)
 8236034:	10c01b17 	ldw	r3,108(r2)
 8236038:	e0bfe617 	ldw	r2,-104(fp)
 823603c:	10801417 	ldw	r2,80(r2)
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
             SEQ_LEQ(ti->ti_ack, tp->snd_max) &&
 8236040:	1880d936 	bltu	r3,r2,82363a8 <tcp_input+0xa28>
             tp->snd_cwnd >= tp->snd_wnd) 
         {
            /*
             * this is a pure ack for outstanding data.
             */
            ++tcpstat.tcps_predack;
 8236044:	008209b4 	movhi	r2,2086
 8236048:	10b98b04 	addi	r2,r2,-6612
 823604c:	10803517 	ldw	r2,212(r2)
 8236050:	10c00044 	addi	r3,r2,1
 8236054:	008209b4 	movhi	r2,2086
 8236058:	10b98b04 	addi	r2,r2,-6612
 823605c:	10c03515 	stw	r3,212(r2)
            if (tp->t_rttick && 
 8236060:	e0bfe617 	ldw	r2,-104(fp)
 8236064:	10801e17 	ldw	r2,120(r2)
 8236068:	10000826 	beq	r2,zero,823608c <tcp_input+0x70c>
#ifdef TCP_TIMESTAMP
               ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
               (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
 823606c:	e0bff217 	ldw	r2,-56(fp)
 8236070:	10c00717 	ldw	r3,28(r2)
 8236074:	e0bfe617 	ldw	r2,-104(fp)
 8236078:	10801f17 	ldw	r2,124(r2)
 823607c:	1885c83a 	sub	r2,r3,r2
         {
            /*
             * this is a pure ack for outstanding data.
             */
            ++tcpstat.tcps_predack;
            if (tp->t_rttick && 
 8236080:	0080020e 	bge	zero,r2,823608c <tcp_input+0x70c>
#ifdef TCP_TIMESTAMP
               ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
               (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
            {
               tcp_xmit_timer(tp);
 8236084:	e13fe617 	ldw	r4,-104(fp)
 8236088:	8237f640 	call	8237f64 <tcp_xmit_timer>
            }

            tcpstat.tcps_rcvackpack++;
 823608c:	008209b4 	movhi	r2,2086
 8236090:	10b98b04 	addi	r2,r2,-6612
 8236094:	10802b17 	ldw	r2,172(r2)
 8236098:	10c00044 	addi	r3,r2,1
 823609c:	008209b4 	movhi	r2,2086
 82360a0:	10b98b04 	addi	r2,r2,-6612
 82360a4:	10c02b15 	stw	r3,172(r2)
            tcpstat.tcps_rcvackbyte += acked;
 82360a8:	008209b4 	movhi	r2,2086
 82360ac:	10b98b04 	addi	r2,r2,-6612
 82360b0:	10c02c17 	ldw	r3,176(r2)
 82360b4:	e0bff617 	ldw	r2,-40(fp)
 82360b8:	1887883a 	add	r3,r3,r2
 82360bc:	008209b4 	movhi	r2,2086
 82360c0:	10b98b04 	addi	r2,r2,-6612
 82360c4:	10c02c15 	stw	r3,176(r2)
            sbdrop(&so->so_snd, acked);
 82360c8:	e0bfe817 	ldw	r2,-96(fp)
 82360cc:	10801204 	addi	r2,r2,72
 82360d0:	e17ff617 	ldw	r5,-40(fp)
 82360d4:	1009883a 	mov	r4,r2
 82360d8:	82349ac0 	call	82349ac <sbdrop>
            tp->snd_una = ti->ti_ack;
 82360dc:	e0bff217 	ldw	r2,-56(fp)
 82360e0:	10c00717 	ldw	r3,28(r2)
 82360e4:	e0bfe617 	ldw	r2,-104(fp)
 82360e8:	10c00e15 	stw	r3,56(r2)
            m_freem(m);
 82360ec:	e13ffe17 	ldw	r4,-8(fp)
 82360f0:	822e6380 	call	822e638 <m_freem>
             * If process is waiting for space,
             * wakeup/selwakeup/signal.  If data
             * are ready to send, let tcp_output
             * decide between more output or persist.
             */
            if (tp->snd_una == tp->snd_max)
 82360f4:	e0bfe617 	ldw	r2,-104(fp)
 82360f8:	10c00e17 	ldw	r3,56(r2)
 82360fc:	e0bfe617 	ldw	r2,-104(fp)
 8236100:	10801a17 	ldw	r2,104(r2)
 8236104:	1880031e 	bne	r3,r2,8236114 <tcp_input+0x794>
               tp->t_timer[TCPT_REXMT] = 0;
 8236108:	e0bfe617 	ldw	r2,-104(fp)
 823610c:	10000315 	stw	zero,12(r2)
 8236110:	00000706 	br	8236130 <tcp_input+0x7b0>
            else if (tp->t_timer[TCPT_PERSIST] == 0)
 8236114:	e0bfe617 	ldw	r2,-104(fp)
 8236118:	10800417 	ldw	r2,16(r2)
 823611c:	1000041e 	bne	r2,zero,8236130 <tcp_input+0x7b0>
               tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 8236120:	e0bfe617 	ldw	r2,-104(fp)
 8236124:	10c00817 	ldw	r3,32(r2)
 8236128:	e0bfe617 	ldw	r2,-104(fp)
 823612c:	10c00315 	stw	r3,12(r2)

            if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 8236130:	e0bfe817 	ldw	r2,-96(fp)
 8236134:	1080190b 	ldhu	r2,100(r2)
 8236138:	10bfffcc 	andi	r2,r2,65535
 823613c:	1080030c 	andi	r2,r2,12
 8236140:	10000526 	beq	r2,zero,8236158 <tcp_input+0x7d8>
               sowwakeup(so);
 8236144:	e0bfe817 	ldw	r2,-96(fp)
 8236148:	10801204 	addi	r2,r2,72
 823614c:	100b883a 	mov	r5,r2
 8236150:	e13fe817 	ldw	r4,-96(fp)
 8236154:	82342440 	call	8234244 <sbwakeup>

            /* If there is more data in the send buffer, and some is
             * still unsent, then call tcp_output() to try to send it
             */
            if (so->so_snd.sb_cc > (tp->snd_nxt - tp->snd_una))
 8236158:	e0bfe817 	ldw	r2,-96(fp)
 823615c:	10801217 	ldw	r2,72(r2)
 8236160:	e0ffe617 	ldw	r3,-104(fp)
 8236164:	19000f17 	ldw	r4,60(r3)
 8236168:	e0ffe617 	ldw	r3,-104(fp)
 823616c:	18c00e17 	ldw	r3,56(r3)
 8236170:	20c7c83a 	sub	r3,r4,r3
 8236174:	1886c02e 	bgeu	r3,r2,8237c78 <tcp_input+0x22f8>
               (void) tcp_output(tp);
 8236178:	e13fe617 	ldw	r4,-104(fp)
 823617c:	82383000 	call	8238300 <tcp_output>
            return;
 8236180:	0006bd06 	br	8237c78 <tcp_input+0x22f8>
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
 8236184:	e0bff217 	ldw	r2,-56(fp)
 8236188:	10c00717 	ldw	r3,28(r2)
 823618c:	e0bfe617 	ldw	r2,-104(fp)
 8236190:	10800e17 	ldw	r2,56(r2)
 8236194:	1880841e 	bne	r3,r2,82363a8 <tcp_input+0xa28>
          tp->seg_next == (struct tcpiphdr *)tp &&
 8236198:	e0bfe617 	ldw	r2,-104(fp)
 823619c:	10c00017 	ldw	r3,0(r2)
            if (so->so_snd.sb_cc > (tp->snd_nxt - tp->snd_una))
               (void) tcp_output(tp);
            return;
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
 82361a0:	e0bfe617 	ldw	r2,-104(fp)
 82361a4:	1880801e 	bne	r3,r2,82363a8 <tcp_input+0xa28>
          tp->seg_next == (struct tcpiphdr *)tp &&
          ti->ti_len <= sbspace(&so->so_rcv))
 82361a8:	e0bff217 	ldw	r2,-56(fp)
 82361ac:	1080028b 	ldhu	r2,10(r2)
 82361b0:	10ffffcc 	andi	r3,r2,65535
 82361b4:	e0bfe817 	ldw	r2,-96(fp)
 82361b8:	10800b17 	ldw	r2,44(r2)
 82361bc:	1009883a 	mov	r4,r2
 82361c0:	e0bfe817 	ldw	r2,-96(fp)
 82361c4:	10800a17 	ldw	r2,40(r2)
 82361c8:	2085c83a 	sub	r2,r4,r2
 82361cc:	10000616 	blt	r2,zero,82361e8 <tcp_input+0x868>
 82361d0:	e0bfe817 	ldw	r2,-96(fp)
 82361d4:	11000b17 	ldw	r4,44(r2)
 82361d8:	e0bfe817 	ldw	r2,-96(fp)
 82361dc:	10800a17 	ldw	r2,40(r2)
 82361e0:	2085c83a 	sub	r2,r4,r2
 82361e4:	00000106 	br	82361ec <tcp_input+0x86c>
 82361e8:	0005883a 	mov	r2,zero
               (void) tcp_output(tp);
            return;
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
          tp->seg_next == (struct tcpiphdr *)tp &&
 82361ec:	10c06e36 	bltu	r2,r3,82363a8 <tcp_input+0xa28>
#endif   /* TCP_ZEROCOPY */

         /* this may also be a garden-variety probe received because
          * the socket sendbuf was full.
          */
         if(tp->rcv_wnd == 0)
 82361f0:	e0bfe617 	ldw	r2,-104(fp)
 82361f4:	10801517 	ldw	r2,84(r2)
 82361f8:	10000c1e 	bne	r2,zero,823622c <tcp_input+0x8ac>
             * info in this seg, but Windows NT 4.0 has a nasty bug where it
             * will hammer us mericilessly with these probes (one customer
             * reports thousands per second) so we just dump it ASAP to
             * save cycles.
             */
            tcpstat.tcps_rcvwinprobe++;
 82361fc:	008209b4 	movhi	r2,2086
 8236200:	10b98b04 	addi	r2,r2,-6612
 8236204:	10802817 	ldw	r2,160(r2)
 8236208:	10c00044 	addi	r3,r2,1
 823620c:	008209b4 	movhi	r2,2086
 8236210:	10b98b04 	addi	r2,r2,-6612
 8236214:	10c02815 	stw	r3,160(r2)
            m_freem (m);      /* free the received mbuf */
 8236218:	e13ffe17 	ldw	r4,-8(fp)
 823621c:	822e6380 	call	822e638 <m_freem>
            tcp_output(tp);   /* send the ack now... */
 8236220:	e13fe617 	ldw	r4,-104(fp)
 8236224:	82383000 	call	8238300 <tcp_output>
            return;
 8236228:	00069c06 	br	8237c9c <tcp_input+0x231c>
         /*
          * this is a pure, in-sequence data packet
          * with nothing on the reassembly queue and
          * we have enough buffer space to take it.
          */
         ++tcpstat.tcps_preddat;
 823622c:	008209b4 	movhi	r2,2086
 8236230:	10b98b04 	addi	r2,r2,-6612
 8236234:	10803617 	ldw	r2,216(r2)
 8236238:	10c00044 	addi	r3,r2,1
 823623c:	008209b4 	movhi	r2,2086
 8236240:	10b98b04 	addi	r2,r2,-6612
 8236244:	10c03615 	stw	r3,216(r2)
         tp->rcv_nxt += ti->ti_len;
 8236248:	e0bfe617 	ldw	r2,-104(fp)
 823624c:	10c01617 	ldw	r3,88(r2)
 8236250:	e0bff217 	ldw	r2,-56(fp)
 8236254:	1080028b 	ldhu	r2,10(r2)
 8236258:	10bfffcc 	andi	r2,r2,65535
 823625c:	1887883a 	add	r3,r3,r2
 8236260:	e0bfe617 	ldw	r2,-104(fp)
 8236264:	10c01615 	stw	r3,88(r2)
         tcpstat.tcps_rcvpack++;
 8236268:	008209b4 	movhi	r2,2086
 823626c:	10b98b04 	addi	r2,r2,-6612
 8236270:	10801a17 	ldw	r2,104(r2)
 8236274:	10c00044 	addi	r3,r2,1
 8236278:	008209b4 	movhi	r2,2086
 823627c:	10b98b04 	addi	r2,r2,-6612
 8236280:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 8236284:	008209b4 	movhi	r2,2086
 8236288:	10b98b04 	addi	r2,r2,-6612
 823628c:	10c01b17 	ldw	r3,108(r2)
 8236290:	e0bff217 	ldw	r2,-56(fp)
 8236294:	1080028b 	ldhu	r2,10(r2)
 8236298:	10bfffcc 	andi	r2,r2,65535
 823629c:	1887883a 	add	r3,r3,r2
 82362a0:	008209b4 	movhi	r2,2086
 82362a4:	10b98b04 	addi	r2,r2,-6612
 82362a8:	10c01b15 	stw	r3,108(r2)
         /*
          * Add data to socket buffer.
          */
         sbappend(&so->so_rcv, m);
 82362ac:	e0bfe817 	ldw	r2,-96(fp)
 82362b0:	10800a04 	addi	r2,r2,40
 82362b4:	e17ffe17 	ldw	r5,-8(fp)
 82362b8:	1009883a 	mov	r4,r2
 82362bc:	82343f40 	call	82343f4 <sbappend>
         sorwakeup(so);
 82362c0:	e0bfe817 	ldw	r2,-96(fp)
 82362c4:	10800a04 	addi	r2,r2,40
 82362c8:	100b883a 	mov	r5,r2
 82362cc:	e13fe817 	ldw	r4,-96(fp)
 82362d0:	82342440 	call	8234244 <sbwakeup>
         /*
          * If this is a short packet, then ACK now - with Nagel
          *   congestion avoidance sender won't send more until
          *   he gets an ACK.
          */
         if (tiflags & TH_PUSH)
 82362d4:	e0bfe717 	ldw	r2,-100(fp)
 82362d8:	1080020c 	andi	r2,r2,8
 82362dc:	10000726 	beq	r2,zero,82362fc <tcp_input+0x97c>
            tp->t_flags |= TF_ACKNOW;
 82362e0:	e0bfe617 	ldw	r2,-104(fp)
 82362e4:	10800b0b 	ldhu	r2,44(r2)
 82362e8:	10800054 	ori	r2,r2,1
 82362ec:	1007883a 	mov	r3,r2
 82362f0:	e0bfe617 	ldw	r2,-104(fp)
 82362f4:	10c00b0d 	sth	r3,44(r2)
 82362f8:	00000606 	br	8236314 <tcp_input+0x994>
         else
            tp->t_flags |= TF_DELACK;
 82362fc:	e0bfe617 	ldw	r2,-104(fp)
 8236300:	10800b0b 	ldhu	r2,44(r2)
 8236304:	10800094 	ori	r2,r2,2
 8236308:	1007883a 	mov	r3,r2
 823630c:	e0bfe617 	ldw	r2,-104(fp)
 8236310:	10c00b0d 	sth	r3,44(r2)

         /* see if we need to send an ack */
         adv = (int)(tp->rcv_wnd - (tcp_win)(tp->rcv_adv - tp->rcv_nxt));
 8236314:	e0bfe617 	ldw	r2,-104(fp)
 8236318:	10c01517 	ldw	r3,84(r2)
 823631c:	e0bfe617 	ldw	r2,-104(fp)
 8236320:	11001617 	ldw	r4,88(r2)
 8236324:	e0bfe617 	ldw	r2,-104(fp)
 8236328:	10801917 	ldw	r2,100(r2)
 823632c:	2085c83a 	sub	r2,r4,r2
 8236330:	1885883a 	add	r2,r3,r2
 8236334:	e0bff715 	stw	r2,-36(fp)

         if ((adv >= (int)(tp->t_maxseg * 2)) ||
 8236338:	e0bfe617 	ldw	r2,-104(fp)
 823633c:	10800a0b 	ldhu	r2,40(r2)
 8236340:	10bfffcc 	andi	r2,r2,65535
 8236344:	1085883a 	add	r2,r2,r2
 8236348:	1007883a 	mov	r3,r2
 823634c:	e0bff717 	ldw	r2,-36(fp)
 8236350:	10c0050e 	bge	r2,r3,8236368 <tcp_input+0x9e8>
             (tp->t_flags & TF_ACKNOW))
 8236354:	e0bfe617 	ldw	r2,-104(fp)
 8236358:	10800b0b 	ldhu	r2,44(r2)
 823635c:	10bfffcc 	andi	r2,r2,65535
 8236360:	1080004c 	andi	r2,r2,1
            tp->t_flags |= TF_DELACK;

         /* see if we need to send an ack */
         adv = (int)(tp->rcv_wnd - (tcp_win)(tp->rcv_adv - tp->rcv_nxt));

         if ((adv >= (int)(tp->t_maxseg * 2)) ||
 8236364:	10064626 	beq	r2,zero,8237c80 <tcp_input+0x2300>
               tp->t_flags &= ~TF_ACKNOW;
               return;
            }
#endif   /* DO_DELAY_ACKS */

            tp->t_flags |= TF_ACKNOW;
 8236368:	e0bfe617 	ldw	r2,-104(fp)
 823636c:	10800b0b 	ldhu	r2,44(r2)
 8236370:	10800054 	ori	r2,r2,1
 8236374:	1007883a 	mov	r3,r2
 8236378:	e0bfe617 	ldw	r2,-104(fp)
 823637c:	10c00b0d 	sth	r3,44(r2)
            tp->t_flags &= ~TF_DELACK;
 8236380:	e0bfe617 	ldw	r2,-104(fp)
 8236384:	10c00b0b 	ldhu	r3,44(r2)
 8236388:	00bfff44 	movi	r2,-3
 823638c:	1884703a 	and	r2,r3,r2
 8236390:	1007883a 	mov	r3,r2
 8236394:	e0bfe617 	ldw	r2,-104(fp)
 8236398:	10c00b0d 	sth	r3,44(r2)
            tcp_output(tp);   /* send the ack now... */
 823639c:	e13fe617 	ldw	r4,-104(fp)
 82363a0:	82383000 	call	8238300 <tcp_output>
         }

         return;
 82363a4:	00063606 	br	8237c80 <tcp_input+0x2300>
      }
   }

   switch (tp->t_state) 
 82363a8:	e0bfe617 	ldw	r2,-104(fp)
 82363ac:	10800217 	ldw	r2,8(r2)
 82363b0:	10c00060 	cmpeqi	r3,r2,1
 82363b4:	1800031e 	bne	r3,zero,82363c4 <tcp_input+0xa44>
 82363b8:	108000a0 	cmpeqi	r2,r2,2
 82363bc:	1000aa1e 	bne	r2,zero,8236668 <tcp_input+0xce8>
 82363c0:	00017e06 	br	82369bc <tcp_input+0x103c>
    */
   case TCPS_LISTEN: 
   {
         struct mbuf *  am;

         if (tiflags & TH_RST)
 82363c4:	e0bfe717 	ldw	r2,-100(fp)
 82363c8:	1080010c 	andi	r2,r2,4
 82363cc:	10000326 	beq	r2,zero,82363dc <tcp_input+0xa5c>
            GOTO_DROP;
 82363d0:	0080bec4 	movi	r2,763
 82363d4:	d0a0b215 	stw	r2,-32056(gp)
 82363d8:	00061b06 	br	8237c48 <tcp_input+0x22c8>
         if (tiflags & TH_ACK)
 82363dc:	e0bfe717 	ldw	r2,-100(fp)
 82363e0:	1080040c 	andi	r2,r2,16
 82363e4:	10000326 	beq	r2,zero,82363f4 <tcp_input+0xa74>
            GOTO_DROPWITHRESET;
 82363e8:	0080bf44 	movi	r2,765
 82363ec:	d0a0b215 	stw	r2,-32056(gp)
 82363f0:	0005d406 	br	8237b44 <tcp_input+0x21c4>
         if ((tiflags & TH_SYN) == 0)
 82363f4:	e0bfe717 	ldw	r2,-100(fp)
 82363f8:	1080008c 	andi	r2,r2,2
 82363fc:	1000031e 	bne	r2,zero,823640c <tcp_input+0xa8c>
            GOTO_DROP;
 8236400:	0080bfc4 	movi	r2,767
 8236404:	d0a0b215 	stw	r2,-32056(gp)
 8236408:	00060f06 	br	8237c48 <tcp_input+0x22c8>
         if(in_broadcast(ti->ti_dst.s_addr))
 823640c:	e0bff217 	ldw	r2,-56(fp)
 8236410:	10800417 	ldw	r2,16(r2)
 8236414:	1009883a 	mov	r4,r2
 8236418:	822f5840 	call	822f584 <in_broadcast>
 823641c:	10000326 	beq	r2,zero,823642c <tcp_input+0xaac>
            GOTO_DROP;
 8236420:	0080c044 	movi	r2,769
 8236424:	d0a0b215 	stw	r2,-32056(gp)
 8236428:	00060706 	br	8237c48 <tcp_input+0x22c8>
         am = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 823642c:	01400404 	movi	r5,16
 8236430:	01000244 	movi	r4,9
 8236434:	822e3a80 	call	822e3a8 <m_getnbuf>
 8236438:	e0bffa15 	stw	r2,-24(fp)
         if (am == NULL)
 823643c:	e0bffa17 	ldw	r2,-24(fp)
 8236440:	1000031e 	bne	r2,zero,8236450 <tcp_input+0xad0>
            GOTO_DROP;
 8236444:	0080c104 	movi	r2,772
 8236448:	d0a0b215 	stw	r2,-32056(gp)
 823644c:	0005fe06 	br	8237c48 <tcp_input+0x22c8>

#ifdef IP_V4
         if(inp->inp_socket->so_domain == AF_INET)
 8236450:	e0bfe417 	ldw	r2,-112(fp)
 8236454:	10800817 	ldw	r2,32(r2)
 8236458:	10800517 	ldw	r2,20(r2)
 823645c:	10800098 	cmpnei	r2,r2,2
 8236460:	10002c1e 	bne	r2,zero,8236514 <tcp_input+0xb94>
         {
         struct sockaddr_in * sin;
         am->m_len = sizeof (struct sockaddr_in);
 8236464:	e0bffa17 	ldw	r2,-24(fp)
 8236468:	00c00404 	movi	r3,16
 823646c:	10c00215 	stw	r3,8(r2)
         sin = mtod(am, struct sockaddr_in *);
 8236470:	e0bffa17 	ldw	r2,-24(fp)
 8236474:	10800317 	ldw	r2,12(r2)
 8236478:	e0bffb15 	stw	r2,-20(fp)
         sin->sin_family = AF_INET;
 823647c:	e0bffb17 	ldw	r2,-20(fp)
 8236480:	00c00084 	movi	r3,2
 8236484:	10c0000d 	sth	r3,0(r2)
         sin->sin_addr = ti->ti_src;
 8236488:	e0bffb17 	ldw	r2,-20(fp)
 823648c:	e0fff217 	ldw	r3,-56(fp)
 8236490:	18c00317 	ldw	r3,12(r3)
 8236494:	10c00115 	stw	r3,4(r2)
         sin->sin_port = ti->ti_sport;
 8236498:	e0bff217 	ldw	r2,-56(fp)
 823649c:	10c0050b 	ldhu	r3,20(r2)
 82364a0:	e0bffb17 	ldw	r2,-20(fp)
 82364a4:	10c0008d 	sth	r3,2(r2)
         /* Assuming pcbconnect will work, we put the sender's address in 
          * the inp_laddr (after saving a local laddr copy). If the connect
          * fails we restore the inpcb before going to drop:
          */
         laddr = inp->inp_laddr;    /* save tmp laddr */
 82364a8:	e0bfe417 	ldw	r2,-112(fp)
 82364ac:	10800417 	ldw	r2,16(r2)
 82364b0:	e0bffd15 	stw	r2,-12(fp)
         if (inp->inp_laddr.s_addr == INADDR_ANY)
 82364b4:	e0bfe417 	ldw	r2,-112(fp)
 82364b8:	10800417 	ldw	r2,16(r2)
 82364bc:	1000041e 	bne	r2,zero,82364d0 <tcp_input+0xb50>
            inp->inp_laddr = ti->ti_dst;
 82364c0:	e0bfe417 	ldw	r2,-112(fp)
 82364c4:	e0fff217 	ldw	r3,-56(fp)
 82364c8:	18c00417 	ldw	r3,16(r3)
 82364cc:	10c00415 	stw	r3,16(r2)
         if (in_pcbconnect (inp, am)) 
 82364d0:	e17ffa17 	ldw	r5,-24(fp)
 82364d4:	e13fe417 	ldw	r4,-112(fp)
 82364d8:	82481280 	call	8248128 <in_pcbconnect>
 82364dc:	10000826 	beq	r2,zero,8236500 <tcp_input+0xb80>
         {
            inp->inp_laddr = laddr;
 82364e0:	e0bfe417 	ldw	r2,-112(fp)
 82364e4:	e0fffd17 	ldw	r3,-12(fp)
 82364e8:	10c00415 	stw	r3,16(r2)
            (void) m_free(am);
 82364ec:	e13ffa17 	ldw	r4,-24(fp)
 82364f0:	822e5300 	call	822e530 <m_free>
            GOTO_DROP;
 82364f4:	0080c684 	movi	r2,794
 82364f8:	d0a0b215 	stw	r2,-32056(gp)
 82364fc:	0005d206 	br	8237c48 <tcp_input+0x22c8>
         }
         
         inp->ifp = ifp;      /* set interface for conn.*/
 8236500:	e0bfe417 	ldw	r2,-112(fp)
 8236504:	e0ffff17 	ldw	r3,-4(fp)
 8236508:	10c00a15 	stw	r3,40(r2)
         
         (void) m_free (am);
 823650c:	e13ffa17 	ldw	r4,-24(fp)
 8236510:	822e5300 	call	822e530 <m_free>
            }
            (void) m_free(am);
         }
#endif   /* end v6 */

         tp->t_template = tcp_template(tp);
 8236514:	e13fe617 	ldw	r4,-104(fp)
 8236518:	82395200 	call	8239520 <tcp_template>
 823651c:	1007883a 	mov	r3,r2
 8236520:	e0bfe617 	ldw	r2,-104(fp)
 8236524:	10c00c15 	stw	r3,48(r2)
         if (tp->t_template == 0) 
 8236528:	e0bfe617 	ldw	r2,-104(fp)
 823652c:	10800c17 	ldw	r2,48(r2)
 8236530:	1000071e 	bne	r2,zero,8236550 <tcp_input+0xbd0>
         {
            SETTP(tp, tcp_drop(tp, ENOBUFS));
 8236534:	01401a44 	movi	r5,105
 8236538:	e13fe617 	ldw	r4,-104(fp)
 823653c:	8239b340 	call	8239b34 <tcp_drop>
            dropsocket = 0;      /* socket is already gone */
 8236540:	e03fec15 	stw	zero,-80(fp)
            GOTO_DROP;
 8236544:	0080d1c4 	movi	r2,839
 8236548:	d0a0b215 	stw	r2,-32056(gp)
 823654c:	0005be06 	br	8237c48 <tcp_input+0x22c8>
         }
         if (om) 
 8236550:	e0bfe517 	ldw	r2,-108(fp)
 8236554:	10000526 	beq	r2,zero,823656c <tcp_input+0xbec>
         {
            tcp_dooptions(tp, om, ti);
 8236558:	e1bff217 	ldw	r6,-56(fp)
 823655c:	e17fe517 	ldw	r5,-108(fp)
 8236560:	e13fe617 	ldw	r4,-104(fp)
 8236564:	8237cb00 	call	8237cb0 <tcp_dooptions>
            om = 0;
 8236568:	e03fe515 	stw	zero,-108(fp)
         }
         if (iss)
 823656c:	e0bfed17 	ldw	r2,-76(fp)
 8236570:	10000426 	beq	r2,zero,8236584 <tcp_input+0xc04>
            tp->iss = iss;
 8236574:	e0ffed17 	ldw	r3,-76(fp)
 8236578:	e0bfe617 	ldw	r2,-104(fp)
 823657c:	10c01315 	stw	r3,76(r2)
 8236580:	00000306 	br	8236590 <tcp_input+0xc10>
         else
            tp->iss = tcp_iss;
 8236584:	d0e0b517 	ldw	r3,-32044(gp)
 8236588:	e0bfe617 	ldw	r2,-104(fp)
 823658c:	10c01315 	stw	r3,76(r2)
         tcp_iss += (unsigned)(TCP_ISSINCR/2);
 8236590:	d0e0b517 	ldw	r3,-32044(gp)
 8236594:	00be9fd4 	movui	r2,64127
 8236598:	1885883a 	add	r2,r3,r2
 823659c:	d0a0b515 	stw	r2,-32044(gp)
         tp->irs = ti->ti_seq;
 82365a0:	e0bff217 	ldw	r2,-56(fp)
 82365a4:	10c00617 	ldw	r3,24(r2)
 82365a8:	e0bfe617 	ldw	r2,-104(fp)
 82365ac:	10c01815 	stw	r3,96(r2)
         tcp_sendseqinit(tp);
 82365b0:	e0bfe617 	ldw	r2,-104(fp)
 82365b4:	10c01317 	ldw	r3,76(r2)
 82365b8:	e0bfe617 	ldw	r2,-104(fp)
 82365bc:	10c01015 	stw	r3,64(r2)
 82365c0:	e0bfe617 	ldw	r2,-104(fp)
 82365c4:	10c01017 	ldw	r3,64(r2)
 82365c8:	e0bfe617 	ldw	r2,-104(fp)
 82365cc:	10c01a15 	stw	r3,104(r2)
 82365d0:	e0bfe617 	ldw	r2,-104(fp)
 82365d4:	10c01a17 	ldw	r3,104(r2)
 82365d8:	e0bfe617 	ldw	r2,-104(fp)
 82365dc:	10c00f15 	stw	r3,60(r2)
 82365e0:	e0bfe617 	ldw	r2,-104(fp)
 82365e4:	10c00f17 	ldw	r3,60(r2)
 82365e8:	e0bfe617 	ldw	r2,-104(fp)
 82365ec:	10c00e15 	stw	r3,56(r2)
         tcp_rcvseqinit(tp);
 82365f0:	e0bfe617 	ldw	r2,-104(fp)
 82365f4:	10801817 	ldw	r2,96(r2)
 82365f8:	10c00044 	addi	r3,r2,1
 82365fc:	e0bfe617 	ldw	r2,-104(fp)
 8236600:	10c01615 	stw	r3,88(r2)
 8236604:	e0bfe617 	ldw	r2,-104(fp)
 8236608:	10c01617 	ldw	r3,88(r2)
 823660c:	e0bfe617 	ldw	r2,-104(fp)
 8236610:	10c01915 	stw	r3,100(r2)
         tp->t_flags |= TF_ACKNOW;
 8236614:	e0bfe617 	ldw	r2,-104(fp)
 8236618:	10800b0b 	ldhu	r2,44(r2)
 823661c:	10800054 	ori	r2,r2,1
 8236620:	1007883a 	mov	r3,r2
 8236624:	e0bfe617 	ldw	r2,-104(fp)
 8236628:	10c00b0d 	sth	r3,44(r2)
         tp->t_state = TCPS_SYN_RECEIVED;
 823662c:	e0bfe617 	ldw	r2,-104(fp)
 8236630:	00c000c4 	movi	r3,3
 8236634:	10c00215 	stw	r3,8(r2)
         tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 8236638:	e0bfe617 	ldw	r2,-104(fp)
 823663c:	00c02584 	movi	r3,150
 8236640:	10c00515 	stw	r3,20(r2)
         dropsocket = 0;      /* committed to socket */
 8236644:	e03fec15 	stw	zero,-80(fp)
         tcpstat.tcps_accepts++;
 8236648:	008209b4 	movhi	r2,2086
 823664c:	10b98b04 	addi	r2,r2,-6612
 8236650:	10800117 	ldw	r2,4(r2)
 8236654:	10c00044 	addi	r3,r2,1
 8236658:	008209b4 	movhi	r2,2086
 823665c:	10b98b04 	addi	r2,r2,-6612
 8236660:	10c00115 	stw	r3,4(r2)
         goto trimthenstep6;
 8236664:	00009006 	br	82368a8 <tcp_input+0xf28>
    *   if SYN has been acked change to ESTABLISHED else SYN_RCVD state
    *   arrange for segment to be acked (eventually)
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
 8236668:	e0bfe417 	ldw	r2,-112(fp)
 823666c:	e0ffff17 	ldw	r3,-4(fp)
 8236670:	10c00a15 	stw	r3,40(r2)
      if ((tiflags & TH_ACK) &&
 8236674:	e0bfe717 	ldw	r2,-100(fp)
 8236678:	1080040c 	andi	r2,r2,16
 823667c:	10000f26 	beq	r2,zero,82366bc <tcp_input+0xd3c>
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
 8236680:	e0bff217 	ldw	r2,-56(fp)
 8236684:	10c00717 	ldw	r3,28(r2)
 8236688:	e0bfe617 	ldw	r2,-104(fp)
 823668c:	10801317 	ldw	r2,76(r2)
 8236690:	1885c83a 	sub	r2,r3,r2
    *   arrange for segment to be acked (eventually)
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
      if ((tiflags & TH_ACK) &&
 8236694:	0080060e 	bge	zero,r2,82366b0 <tcp_input+0xd30>
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
          SEQ_GT(ti->ti_ack, tp->snd_max)))
 8236698:	e0bff217 	ldw	r2,-56(fp)
 823669c:	10c00717 	ldw	r3,28(r2)
 82366a0:	e0bfe617 	ldw	r2,-104(fp)
 82366a4:	10801a17 	ldw	r2,104(r2)
 82366a8:	1885c83a 	sub	r2,r3,r2
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
      if ((tiflags & TH_ACK) &&
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
 82366ac:	0080030e 	bge	zero,r2,82366bc <tcp_input+0xd3c>
          SEQ_GT(ti->ti_ack, tp->snd_max)))
      {
         GOTO_DROPWITHRESET;
 82366b0:	0080dc04 	movi	r2,880
 82366b4:	d0a0b215 	stw	r2,-32056(gp)
 82366b8:	00052206 	br	8237b44 <tcp_input+0x21c4>
      }
      if (tiflags & TH_RST) 
 82366bc:	e0bfe717 	ldw	r2,-100(fp)
 82366c0:	1080010c 	andi	r2,r2,4
 82366c4:	10000926 	beq	r2,zero,82366ec <tcp_input+0xd6c>
      {
         if (tiflags & TH_ACK)
 82366c8:	e0bfe717 	ldw	r2,-100(fp)
 82366cc:	1080040c 	andi	r2,r2,16
 82366d0:	10000326 	beq	r2,zero,82366e0 <tcp_input+0xd60>
            SETTP(tp, tcp_drop(tp, ECONNREFUSED));
 82366d4:	01401bc4 	movi	r5,111
 82366d8:	e13fe617 	ldw	r4,-104(fp)
 82366dc:	8239b340 	call	8239b34 <tcp_drop>
         GOTO_DROP;
 82366e0:	0080dd84 	movi	r2,886
 82366e4:	d0a0b215 	stw	r2,-32056(gp)
 82366e8:	00055706 	br	8237c48 <tcp_input+0x22c8>
      }
      if ((tiflags & TH_SYN) == 0)
 82366ec:	e0bfe717 	ldw	r2,-100(fp)
 82366f0:	1080008c 	andi	r2,r2,2
 82366f4:	1000031e 	bne	r2,zero,8236704 <tcp_input+0xd84>
         GOTO_DROP;
 82366f8:	0080de44 	movi	r2,889
 82366fc:	d0a0b215 	stw	r2,-32056(gp)
 8236700:	00055106 	br	8237c48 <tcp_input+0x22c8>
      if (tiflags & TH_ACK) 
 8236704:	e0bfe717 	ldw	r2,-100(fp)
 8236708:	1080040c 	andi	r2,r2,16
 823670c:	10000e26 	beq	r2,zero,8236748 <tcp_input+0xdc8>
      {
         tp->snd_una = ti->ti_ack;
 8236710:	e0bff217 	ldw	r2,-56(fp)
 8236714:	10c00717 	ldw	r3,28(r2)
 8236718:	e0bfe617 	ldw	r2,-104(fp)
 823671c:	10c00e15 	stw	r3,56(r2)
         if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 8236720:	e0bfe617 	ldw	r2,-104(fp)
 8236724:	10c00f17 	ldw	r3,60(r2)
 8236728:	e0bfe617 	ldw	r2,-104(fp)
 823672c:	10800e17 	ldw	r2,56(r2)
 8236730:	1885c83a 	sub	r2,r3,r2
 8236734:	1000040e 	bge	r2,zero,8236748 <tcp_input+0xdc8>
            tp->snd_nxt = tp->snd_una;
 8236738:	e0bfe617 	ldw	r2,-104(fp)
 823673c:	10c00e17 	ldw	r3,56(r2)
 8236740:	e0bfe617 	ldw	r2,-104(fp)
 8236744:	10c00f15 	stw	r3,60(r2)
      }
      tp->t_timer[TCPT_REXMT] = 0;
 8236748:	e0bfe617 	ldw	r2,-104(fp)
 823674c:	10000315 	stw	zero,12(r2)
      tp->irs = ti->ti_seq;
 8236750:	e0bff217 	ldw	r2,-56(fp)
 8236754:	10c00617 	ldw	r3,24(r2)
 8236758:	e0bfe617 	ldw	r2,-104(fp)
 823675c:	10c01815 	stw	r3,96(r2)
      tcp_rcvseqinit(tp);
 8236760:	e0bfe617 	ldw	r2,-104(fp)
 8236764:	10801817 	ldw	r2,96(r2)
 8236768:	10c00044 	addi	r3,r2,1
 823676c:	e0bfe617 	ldw	r2,-104(fp)
 8236770:	10c01615 	stw	r3,88(r2)
 8236774:	e0bfe617 	ldw	r2,-104(fp)
 8236778:	10c01617 	ldw	r3,88(r2)
 823677c:	e0bfe617 	ldw	r2,-104(fp)
 8236780:	10c01915 	stw	r3,100(r2)
      if (inp->inp_laddr.s_addr != ti->ti_dst.s_addr) 
 8236784:	e0bfe417 	ldw	r2,-112(fp)
 8236788:	10c00417 	ldw	r3,16(r2)
 823678c:	e0bff217 	ldw	r2,-56(fp)
 8236790:	10800417 	ldw	r2,16(r2)
 8236794:	18801726 	beq	r3,r2,82367f4 <tcp_input+0xe74>
          * the IP interface may have changed address since we sent our SYN
          * (e.g. PPP brings link up as a result of said SYN and gets new
          * address via IPCP); if so we need to update the inpcb and the
          * TCP header template with the new address.
          */
         if ((m->pkt->net != NULL)
 8236798:	e0bffe17 	ldw	r2,-8(fp)
 823679c:	10800117 	ldw	r2,4(r2)
 82367a0:	10800617 	ldw	r2,24(r2)
 82367a4:	10001326 	beq	r2,zero,82367f4 <tcp_input+0xe74>
             && (m->pkt->net->n_ipaddr == ti->ti_dst.s_addr)) 
 82367a8:	e0bffe17 	ldw	r2,-8(fp)
 82367ac:	10800117 	ldw	r2,4(r2)
 82367b0:	10800617 	ldw	r2,24(r2)
 82367b4:	10c00a17 	ldw	r3,40(r2)
 82367b8:	e0bff217 	ldw	r2,-56(fp)
 82367bc:	10800417 	ldw	r2,16(r2)
 82367c0:	18800c1e 	bne	r3,r2,82367f4 <tcp_input+0xe74>
      /* send an ack */
         {
            inp->inp_laddr = ti->ti_dst;
 82367c4:	e0bfe417 	ldw	r2,-112(fp)
 82367c8:	e0fff217 	ldw	r3,-56(fp)
 82367cc:	18c00417 	ldw	r3,16(r3)
 82367d0:	10c00415 	stw	r3,16(r2)
            if (tp->t_template != NULL)
 82367d4:	e0bfe617 	ldw	r2,-104(fp)
 82367d8:	10800c17 	ldw	r2,48(r2)
 82367dc:	10000526 	beq	r2,zero,82367f4 <tcp_input+0xe74>
               tp->t_template->ti_src = ti->ti_dst;
 82367e0:	e0bfe617 	ldw	r2,-104(fp)
 82367e4:	10800c17 	ldw	r2,48(r2)
 82367e8:	e0fff217 	ldw	r3,-56(fp)
 82367ec:	18c00417 	ldw	r3,16(r3)
 82367f0:	10c00315 	stw	r3,12(r2)
         }
      }
      tp->t_flags |= TF_ACKNOW;
 82367f4:	e0bfe617 	ldw	r2,-104(fp)
 82367f8:	10800b0b 	ldhu	r2,44(r2)
 82367fc:	10800054 	ori	r2,r2,1
 8236800:	1007883a 	mov	r3,r2
 8236804:	e0bfe617 	ldw	r2,-104(fp)
 8236808:	10c00b0d 	sth	r3,44(r2)
      if (tiflags & TH_ACK && SEQ_GT(tp->snd_una, tp->iss)) 
 823680c:	e0bfe717 	ldw	r2,-100(fp)
 8236810:	1080040c 	andi	r2,r2,16
 8236814:	10002126 	beq	r2,zero,823689c <tcp_input+0xf1c>
 8236818:	e0bfe617 	ldw	r2,-104(fp)
 823681c:	10c00e17 	ldw	r3,56(r2)
 8236820:	e0bfe617 	ldw	r2,-104(fp)
 8236824:	10801317 	ldw	r2,76(r2)
 8236828:	1885c83a 	sub	r2,r3,r2
 823682c:	00801b0e 	bge	zero,r2,823689c <tcp_input+0xf1c>
      {
         tcpstat.tcps_connects++;
 8236830:	008209b4 	movhi	r2,2086
 8236834:	10b98b04 	addi	r2,r2,-6612
 8236838:	10800217 	ldw	r2,8(r2)
 823683c:	10c00044 	addi	r3,r2,1
 8236840:	008209b4 	movhi	r2,2086
 8236844:	10b98b04 	addi	r2,r2,-6612
 8236848:	10c00215 	stw	r3,8(r2)
         tp->t_state = TCPS_ESTABLISHED;
 823684c:	e0bfe617 	ldw	r2,-104(fp)
 8236850:	00c00104 	movi	r3,4
 8236854:	10c00215 	stw	r3,8(r2)
         soisconnected (so);
 8236858:	e13fe817 	ldw	r4,-96(fp)
 823685c:	8233ad80 	call	8233ad8 <soisconnected>
         tp->t_maxseg = tcp_mss(so);
 8236860:	e13fe817 	ldw	r4,-96(fp)
 8236864:	82382080 	call	8238208 <tcp_mss>
 8236868:	1007883a 	mov	r3,r2
 823686c:	e0bfe617 	ldw	r2,-104(fp)
 8236870:	10c00a0d 	sth	r3,40(r2)
         (void) tcp_reass (tp, (struct tcpiphdr *)0, m);
 8236874:	e1bffe17 	ldw	r6,-8(fp)
 8236878:	000b883a 	mov	r5,zero
 823687c:	e13fe617 	ldw	r4,-104(fp)
 8236880:	82355700 	call	8235570 <tcp_reass>
         /*
          * if we didn't have to retransmit the SYN,
          * use its rtt as our initial srtt & rtt var.
          */
         if (tp->t_rttick) 
 8236884:	e0bfe617 	ldw	r2,-104(fp)
 8236888:	10801e17 	ldw	r2,120(r2)
 823688c:	10000626 	beq	r2,zero,82368a8 <tcp_input+0xf28>
         {
            tcp_xmit_timer(tp);
 8236890:	e13fe617 	ldw	r4,-104(fp)
 8236894:	8237f640 	call	8237f64 <tcp_xmit_timer>
         (void) tcp_reass (tp, (struct tcpiphdr *)0, m);
         /*
          * if we didn't have to retransmit the SYN,
          * use its rtt as our initial srtt & rtt var.
          */
         if (tp->t_rttick) 
 8236898:	00000306 	br	82368a8 <tcp_input+0xf28>
         {
            tcp_xmit_timer(tp);
         }
      } else
         tp->t_state = TCPS_SYN_RECEIVED;
 823689c:	e0bfe617 	ldw	r2,-104(fp)
 82368a0:	00c000c4 	movi	r3,3
 82368a4:	10c00215 	stw	r3,8(r2)
      /*
       * Advance ti->ti_seq to correspond to first data byte.
       * If data, trim to stay within window,
       * dropping FIN if necessary.
       */
      ti->ti_seq++;
 82368a8:	e0bff217 	ldw	r2,-56(fp)
 82368ac:	10800617 	ldw	r2,24(r2)
 82368b0:	10c00044 	addi	r3,r2,1
 82368b4:	e0bff217 	ldw	r2,-56(fp)
 82368b8:	10c00615 	stw	r3,24(r2)
      if ((tcp_win)ti->ti_len > tp->rcv_wnd) 
 82368bc:	e0bff217 	ldw	r2,-56(fp)
 82368c0:	1080028b 	ldhu	r2,10(r2)
 82368c4:	10bfffcc 	andi	r2,r2,65535
 82368c8:	e0ffe617 	ldw	r3,-104(fp)
 82368cc:	18c01517 	ldw	r3,84(r3)
 82368d0:	1880302e 	bgeu	r3,r2,8236994 <tcp_input+0x1014>
      {
         todrop = ti->ti_len - (u_short)tp->rcv_wnd;
 82368d4:	e0bff217 	ldw	r2,-56(fp)
 82368d8:	1080028b 	ldhu	r2,10(r2)
 82368dc:	10ffffcc 	andi	r3,r2,65535
 82368e0:	e0bfe617 	ldw	r2,-104(fp)
 82368e4:	10801517 	ldw	r2,84(r2)
 82368e8:	10bfffcc 	andi	r2,r2,65535
 82368ec:	1885c83a 	sub	r2,r3,r2
 82368f0:	e0bfe915 	stw	r2,-92(fp)
         /* XXX work around 4.2 m_adj bug */
         if (m->m_len) 
 82368f4:	e0bffe17 	ldw	r2,-8(fp)
 82368f8:	10800217 	ldw	r2,8(r2)
 82368fc:	10000626 	beq	r2,zero,8236918 <tcp_input+0xf98>
         {
            m_adj(m, -todrop);
 8236900:	e0bfe917 	ldw	r2,-92(fp)
 8236904:	0085c83a 	sub	r2,zero,r2
 8236908:	100b883a 	mov	r5,r2
 823690c:	e13ffe17 	ldw	r4,-8(fp)
 8236910:	822e9700 	call	822e970 <m_adj>
 8236914:	00000706 	br	8236934 <tcp_input+0xfb4>
         }
         else 
         {
            /* skip tcp/ip header in first mbuf */
            m_adj(m->m_next, -todrop);
 8236918:	e0bffe17 	ldw	r2,-8(fp)
 823691c:	10c00617 	ldw	r3,24(r2)
 8236920:	e0bfe917 	ldw	r2,-92(fp)
 8236924:	0085c83a 	sub	r2,zero,r2
 8236928:	100b883a 	mov	r5,r2
 823692c:	1809883a 	mov	r4,r3
 8236930:	822e9700 	call	822e970 <m_adj>
         }
         ti->ti_len = (u_short)tp->rcv_wnd;
 8236934:	e0bfe617 	ldw	r2,-104(fp)
 8236938:	10801517 	ldw	r2,84(r2)
 823693c:	1007883a 	mov	r3,r2
 8236940:	e0bff217 	ldw	r2,-56(fp)
 8236944:	10c0028d 	sth	r3,10(r2)
         tiflags &= ~TH_FIN;
 8236948:	e0ffe717 	ldw	r3,-100(fp)
 823694c:	00bfff84 	movi	r2,-2
 8236950:	1884703a 	and	r2,r3,r2
 8236954:	e0bfe715 	stw	r2,-100(fp)
         tcpstat.tcps_rcvpackafterwin++;
 8236958:	008209b4 	movhi	r2,2086
 823695c:	10b98b04 	addi	r2,r2,-6612
 8236960:	10802517 	ldw	r2,148(r2)
 8236964:	10c00044 	addi	r3,r2,1
 8236968:	008209b4 	movhi	r2,2086
 823696c:	10b98b04 	addi	r2,r2,-6612
 8236970:	10c02515 	stw	r3,148(r2)
         tcpstat.tcps_rcvbyteafterwin += todrop;
 8236974:	008209b4 	movhi	r2,2086
 8236978:	10b98b04 	addi	r2,r2,-6612
 823697c:	10c02617 	ldw	r3,152(r2)
 8236980:	e0bfe917 	ldw	r2,-92(fp)
 8236984:	1887883a 	add	r3,r3,r2
 8236988:	008209b4 	movhi	r2,2086
 823698c:	10b98b04 	addi	r2,r2,-6612
 8236990:	10c02615 	stw	r3,152(r2)
      }
      tp->snd_wl1 = ti->ti_seq - 1;
 8236994:	e0bff217 	ldw	r2,-56(fp)
 8236998:	10800617 	ldw	r2,24(r2)
 823699c:	10ffffc4 	addi	r3,r2,-1
 82369a0:	e0bfe617 	ldw	r2,-104(fp)
 82369a4:	10c01115 	stw	r3,68(r2)
      tp->rcv_up = ti->ti_seq;
 82369a8:	e0bff217 	ldw	r2,-56(fp)
 82369ac:	10c00617 	ldw	r3,24(r2)
 82369b0:	e0bfe617 	ldw	r2,-104(fp)
 82369b4:	10c01715 	stw	r3,92(r2)
      goto step6;
 82369b8:	0002ee06 	br	8237574 <tcp_input+0x1bf4>
    * States other than LISTEN or SYN_SENT.
    * First check that at least some bytes of segment are within 
    * receive window.  If segment begins before rcv_nxt,
    * drop leading data (and SYN); if nothing left, just ack.
    */
   todrop = (int)(tp->rcv_nxt - ti->ti_seq);
 82369bc:	e0bfe617 	ldw	r2,-104(fp)
 82369c0:	10c01617 	ldw	r3,88(r2)
 82369c4:	e0bff217 	ldw	r2,-56(fp)
 82369c8:	10800617 	ldw	r2,24(r2)
 82369cc:	1885c83a 	sub	r2,r3,r2
 82369d0:	e0bfe915 	stw	r2,-92(fp)
   if (todrop > 0) 
 82369d4:	e0bfe917 	ldw	r2,-92(fp)
 82369d8:	0080910e 	bge	zero,r2,8236c20 <tcp_input+0x12a0>
   {
      if (tiflags & TH_SYN) 
 82369dc:	e0bfe717 	ldw	r2,-100(fp)
 82369e0:	1080008c 	andi	r2,r2,2
 82369e4:	10001c26 	beq	r2,zero,8236a58 <tcp_input+0x10d8>
      {
         tiflags &= ~TH_SYN;
 82369e8:	e0ffe717 	ldw	r3,-100(fp)
 82369ec:	00bfff44 	movi	r2,-3
 82369f0:	1884703a 	and	r2,r3,r2
 82369f4:	e0bfe715 	stw	r2,-100(fp)
         ti->ti_seq++;
 82369f8:	e0bff217 	ldw	r2,-56(fp)
 82369fc:	10800617 	ldw	r2,24(r2)
 8236a00:	10c00044 	addi	r3,r2,1
 8236a04:	e0bff217 	ldw	r2,-56(fp)
 8236a08:	10c00615 	stw	r3,24(r2)
         if (ti->ti_urp > 1) 
 8236a0c:	e0bff217 	ldw	r2,-56(fp)
 8236a10:	1080098b 	ldhu	r2,38(r2)
 8236a14:	10bfffcc 	andi	r2,r2,65535
 8236a18:	108000b0 	cmpltui	r2,r2,2
 8236a1c:	1000071e 	bne	r2,zero,8236a3c <tcp_input+0x10bc>
            ti->ti_urp--;
 8236a20:	e0bff217 	ldw	r2,-56(fp)
 8236a24:	1080098b 	ldhu	r2,38(r2)
 8236a28:	10bfffc4 	addi	r2,r2,-1
 8236a2c:	1007883a 	mov	r3,r2
 8236a30:	e0bff217 	ldw	r2,-56(fp)
 8236a34:	10c0098d 	sth	r3,38(r2)
 8236a38:	00000406 	br	8236a4c <tcp_input+0x10cc>
         else
            tiflags &= ~TH_URG;
 8236a3c:	e0ffe717 	ldw	r3,-100(fp)
 8236a40:	00bff7c4 	movi	r2,-33
 8236a44:	1884703a 	and	r2,r3,r2
 8236a48:	e0bfe715 	stw	r2,-100(fp)
         todrop--;
 8236a4c:	e0bfe917 	ldw	r2,-92(fp)
 8236a50:	10bfffc4 	addi	r2,r2,-1
 8236a54:	e0bfe915 	stw	r2,-92(fp)
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 8236a58:	e0bff217 	ldw	r2,-56(fp)
 8236a5c:	1080028b 	ldhu	r2,10(r2)
 8236a60:	10ffffcc 	andi	r3,r2,65535
 8236a64:	e0bfe917 	ldw	r2,-92(fp)
 8236a68:	18800816 	blt	r3,r2,8236a8c <tcp_input+0x110c>
          ((todrop == (int)ti->ti_len) && 
 8236a6c:	e0bff217 	ldw	r2,-56(fp)
 8236a70:	1080028b 	ldhu	r2,10(r2)
 8236a74:	10ffffcc 	andi	r3,r2,65535
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 8236a78:	e0bfe917 	ldw	r2,-92(fp)
 8236a7c:	1880351e 	bne	r3,r2,8236b54 <tcp_input+0x11d4>
          ((todrop == (int)ti->ti_len) && 
          (tiflags&TH_FIN) == 0)) 
 8236a80:	e0bfe717 	ldw	r2,-100(fp)
 8236a84:	1080004c 	andi	r2,r2,1
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
          ((todrop == (int)ti->ti_len) && 
 8236a88:	1000321e 	bne	r2,zero,8236b54 <tcp_input+0x11d4>
          (tiflags&TH_FIN) == 0)) 
      {
         tcpstat.tcps_rcvduppack++;
 8236a8c:	008209b4 	movhi	r2,2086
 8236a90:	10b98b04 	addi	r2,r2,-6612
 8236a94:	10801f17 	ldw	r2,124(r2)
 8236a98:	10c00044 	addi	r3,r2,1
 8236a9c:	008209b4 	movhi	r2,2086
 8236aa0:	10b98b04 	addi	r2,r2,-6612
 8236aa4:	10c01f15 	stw	r3,124(r2)
         tcpstat.tcps_rcvdupbyte += ti->ti_len;
 8236aa8:	008209b4 	movhi	r2,2086
 8236aac:	10b98b04 	addi	r2,r2,-6612
 8236ab0:	10c02017 	ldw	r3,128(r2)
 8236ab4:	e0bff217 	ldw	r2,-56(fp)
 8236ab8:	1080028b 	ldhu	r2,10(r2)
 8236abc:	10bfffcc 	andi	r2,r2,65535
 8236ac0:	1887883a 	add	r3,r3,r2
 8236ac4:	008209b4 	movhi	r2,2086
 8236ac8:	10b98b04 	addi	r2,r2,-6612
 8236acc:	10c02015 	stw	r3,128(r2)
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 8236ad0:	e0bfe717 	ldw	r2,-100(fp)
 8236ad4:	1080004c 	andi	r2,r2,1
 8236ad8:	10000626 	beq	r2,zero,8236af4 <tcp_input+0x1174>
 8236adc:	e0bff217 	ldw	r2,-56(fp)
 8236ae0:	1080028b 	ldhu	r2,10(r2)
 8236ae4:	10bfffcc 	andi	r2,r2,65535
 8236ae8:	10c00044 	addi	r3,r2,1
 8236aec:	e0bfe917 	ldw	r2,-92(fp)
 8236af0:	18800926 	beq	r3,r2,8236b18 <tcp_input+0x1198>
            (tiflags & TH_RST && ti->ti_seq == tp->rcv_nxt - 1))
 8236af4:	e0bfe717 	ldw	r2,-100(fp)
 8236af8:	1080010c 	andi	r2,r2,4
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 8236afc:	10040026 	beq	r2,zero,8237b00 <tcp_input+0x2180>
            (tiflags & TH_RST && ti->ti_seq == tp->rcv_nxt - 1))
 8236b00:	e0bff217 	ldw	r2,-56(fp)
 8236b04:	10c00617 	ldw	r3,24(r2)
 8236b08:	e0bfe617 	ldw	r2,-104(fp)
 8236b0c:	10801617 	ldw	r2,88(r2)
 8236b10:	10bfffc4 	addi	r2,r2,-1
 8236b14:	1883fa1e 	bne	r3,r2,8237b00 <tcp_input+0x2180>
         {
            todrop = ti->ti_len;
 8236b18:	e0bff217 	ldw	r2,-56(fp)
 8236b1c:	1080028b 	ldhu	r2,10(r2)
 8236b20:	10bfffcc 	andi	r2,r2,65535
 8236b24:	e0bfe915 	stw	r2,-92(fp)
            tiflags &= ~TH_FIN;
 8236b28:	e0ffe717 	ldw	r3,-100(fp)
 8236b2c:	00bfff84 	movi	r2,-2
 8236b30:	1884703a 	and	r2,r3,r2
 8236b34:	e0bfe715 	stw	r2,-100(fp)
            tp->t_flags |= TF_ACKNOW;
 8236b38:	e0bfe617 	ldw	r2,-104(fp)
 8236b3c:	10800b0b 	ldhu	r2,44(r2)
 8236b40:	10800054 	ori	r2,r2,1
 8236b44:	1007883a 	mov	r3,r2
 8236b48:	e0bfe617 	ldw	r2,-104(fp)
 8236b4c:	10c00b0d 	sth	r3,44(r2)
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 8236b50:	00000f06 	br	8236b90 <tcp_input+0x1210>
         else
            goto dropafterack;
      }
      else 
      {
         tcpstat.tcps_rcvpartduppack++;
 8236b54:	008209b4 	movhi	r2,2086
 8236b58:	10b98b04 	addi	r2,r2,-6612
 8236b5c:	10802117 	ldw	r2,132(r2)
 8236b60:	10c00044 	addi	r3,r2,1
 8236b64:	008209b4 	movhi	r2,2086
 8236b68:	10b98b04 	addi	r2,r2,-6612
 8236b6c:	10c02115 	stw	r3,132(r2)
         tcpstat.tcps_rcvpartdupbyte += todrop;
 8236b70:	008209b4 	movhi	r2,2086
 8236b74:	10b98b04 	addi	r2,r2,-6612
 8236b78:	10c02217 	ldw	r3,136(r2)
 8236b7c:	e0bfe917 	ldw	r2,-92(fp)
 8236b80:	1887883a 	add	r3,r3,r2
 8236b84:	008209b4 	movhi	r2,2086
 8236b88:	10b98b04 	addi	r2,r2,-6612
 8236b8c:	10c02215 	stw	r3,136(r2)
      }
      m_adj(m, todrop);
 8236b90:	e17fe917 	ldw	r5,-92(fp)
 8236b94:	e13ffe17 	ldw	r4,-8(fp)
 8236b98:	822e9700 	call	822e970 <m_adj>
      ti->ti_seq += todrop;
 8236b9c:	e0bff217 	ldw	r2,-56(fp)
 8236ba0:	10c00617 	ldw	r3,24(r2)
 8236ba4:	e0bfe917 	ldw	r2,-92(fp)
 8236ba8:	1887883a 	add	r3,r3,r2
 8236bac:	e0bff217 	ldw	r2,-56(fp)
 8236bb0:	10c00615 	stw	r3,24(r2)
      ti->ti_len -= (u_short)todrop;
 8236bb4:	e0bff217 	ldw	r2,-56(fp)
 8236bb8:	1080028b 	ldhu	r2,10(r2)
 8236bbc:	e0ffe917 	ldw	r3,-92(fp)
 8236bc0:	10c5c83a 	sub	r2,r2,r3
 8236bc4:	1007883a 	mov	r3,r2
 8236bc8:	e0bff217 	ldw	r2,-56(fp)
 8236bcc:	10c0028d 	sth	r3,10(r2)
      if (ti->ti_urp > (u_short)todrop)
 8236bd0:	e0bff217 	ldw	r2,-56(fp)
 8236bd4:	1080098b 	ldhu	r2,38(r2)
 8236bd8:	10bfffcc 	andi	r2,r2,65535
 8236bdc:	e0ffe917 	ldw	r3,-92(fp)
 8236be0:	18ffffcc 	andi	r3,r3,65535
 8236be4:	1880080e 	bge	r3,r2,8236c08 <tcp_input+0x1288>
         ti->ti_urp -= (u_short)todrop;
 8236be8:	e0bff217 	ldw	r2,-56(fp)
 8236bec:	1080098b 	ldhu	r2,38(r2)
 8236bf0:	e0ffe917 	ldw	r3,-92(fp)
 8236bf4:	10c5c83a 	sub	r2,r2,r3
 8236bf8:	1007883a 	mov	r3,r2
 8236bfc:	e0bff217 	ldw	r2,-56(fp)
 8236c00:	10c0098d 	sth	r3,38(r2)
 8236c04:	00000606 	br	8236c20 <tcp_input+0x12a0>
      else 
      {
         tiflags &= ~TH_URG;
 8236c08:	e0ffe717 	ldw	r3,-100(fp)
 8236c0c:	00bff7c4 	movi	r2,-33
 8236c10:	1884703a 	and	r2,r3,r2
 8236c14:	e0bfe715 	stw	r2,-100(fp)
         ti->ti_urp = 0;
 8236c18:	e0bff217 	ldw	r2,-56(fp)
 8236c1c:	1000098d 	sth	zero,38(r2)

   /*
    * If new data are received on a connection after the
    * user processes are gone, then RST the other end.
    */
   if ((so->so_state & SS_NOFDREF) &&
 8236c20:	e0bfe817 	ldw	r2,-96(fp)
 8236c24:	1080088b 	ldhu	r2,34(r2)
 8236c28:	10bfffcc 	andi	r2,r2,65535
 8236c2c:	1080004c 	andi	r2,r2,1
 8236c30:	10001526 	beq	r2,zero,8236c88 <tcp_input+0x1308>
       tp->t_state > TCPS_CLOSE_WAIT && ti->ti_len) 
 8236c34:	e0bfe617 	ldw	r2,-104(fp)
 8236c38:	10800217 	ldw	r2,8(r2)

   /*
    * If new data are received on a connection after the
    * user processes are gone, then RST the other end.
    */
   if ((so->so_state & SS_NOFDREF) &&
 8236c3c:	10800190 	cmplti	r2,r2,6
 8236c40:	1000111e 	bne	r2,zero,8236c88 <tcp_input+0x1308>
       tp->t_state > TCPS_CLOSE_WAIT && ti->ti_len) 
 8236c44:	e0bff217 	ldw	r2,-56(fp)
 8236c48:	1080028b 	ldhu	r2,10(r2)
 8236c4c:	10bfffcc 	andi	r2,r2,65535
 8236c50:	10000d26 	beq	r2,zero,8236c88 <tcp_input+0x1308>
   {
      tp = tcp_close(tp);
 8236c54:	e13fe617 	ldw	r4,-104(fp)
 8236c58:	8239be00 	call	8239be0 <tcp_close>
 8236c5c:	e0bfe615 	stw	r2,-104(fp)
      tcpstat.tcps_rcvafterclose++;
 8236c60:	008209b4 	movhi	r2,2086
 8236c64:	10b98b04 	addi	r2,r2,-6612
 8236c68:	10802717 	ldw	r2,156(r2)
 8236c6c:	10c00044 	addi	r3,r2,1
 8236c70:	008209b4 	movhi	r2,2086
 8236c74:	10b98b04 	addi	r2,r2,-6612
 8236c78:	10c02715 	stw	r3,156(r2)
      GOTO_DROPWITHRESET;
 8236c7c:	00810444 	movi	r2,1041
 8236c80:	d0a0b215 	stw	r2,-32056(gp)
 8236c84:	0003af06 	br	8237b44 <tcp_input+0x21c4>

   /*
    * If segment ends after window, drop trailing data
    * (and PUSH and FIN); if nothing left, just ACK.
    */
   todrop = (int)((ti->ti_seq + (short)ti->ti_len) - (tp->rcv_nxt+tp->rcv_wnd));
 8236c88:	e0bff217 	ldw	r2,-56(fp)
 8236c8c:	10c00617 	ldw	r3,24(r2)
 8236c90:	e0bff217 	ldw	r2,-56(fp)
 8236c94:	1080028b 	ldhu	r2,10(r2)
 8236c98:	10bfffcc 	andi	r2,r2,65535
 8236c9c:	10a0001c 	xori	r2,r2,32768
 8236ca0:	10a00004 	addi	r2,r2,-32768
 8236ca4:	1887883a 	add	r3,r3,r2
 8236ca8:	e0bfe617 	ldw	r2,-104(fp)
 8236cac:	11001617 	ldw	r4,88(r2)
 8236cb0:	e0bfe617 	ldw	r2,-104(fp)
 8236cb4:	10801517 	ldw	r2,84(r2)
 8236cb8:	2085883a 	add	r2,r4,r2
 8236cbc:	1885c83a 	sub	r2,r3,r2
 8236cc0:	e0bfe915 	stw	r2,-92(fp)
   if (todrop > 0) 
 8236cc4:	e0bfe917 	ldw	r2,-92(fp)
 8236cc8:	0080690e 	bge	zero,r2,8236e70 <tcp_input+0x14f0>
   {
      tcpstat.tcps_rcvpackafterwin++;
 8236ccc:	008209b4 	movhi	r2,2086
 8236cd0:	10b98b04 	addi	r2,r2,-6612
 8236cd4:	10802517 	ldw	r2,148(r2)
 8236cd8:	10c00044 	addi	r3,r2,1
 8236cdc:	008209b4 	movhi	r2,2086
 8236ce0:	10b98b04 	addi	r2,r2,-6612
 8236ce4:	10c02515 	stw	r3,148(r2)
      if (todrop >= (int)ti->ti_len) 
 8236ce8:	e0bff217 	ldw	r2,-56(fp)
 8236cec:	1080028b 	ldhu	r2,10(r2)
 8236cf0:	10bfffcc 	andi	r2,r2,65535
 8236cf4:	e0ffe917 	ldw	r3,-92(fp)
 8236cf8:	18803a16 	blt	r3,r2,8236de4 <tcp_input+0x1464>
      {
         tcpstat.tcps_rcvbyteafterwin += ti->ti_len;
 8236cfc:	008209b4 	movhi	r2,2086
 8236d00:	10b98b04 	addi	r2,r2,-6612
 8236d04:	10c02617 	ldw	r3,152(r2)
 8236d08:	e0bff217 	ldw	r2,-56(fp)
 8236d0c:	1080028b 	ldhu	r2,10(r2)
 8236d10:	10bfffcc 	andi	r2,r2,65535
 8236d14:	1887883a 	add	r3,r3,r2
 8236d18:	008209b4 	movhi	r2,2086
 8236d1c:	10b98b04 	addi	r2,r2,-6612
 8236d20:	10c02615 	stw	r3,152(r2)
          * If a new connection request is received
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
 8236d24:	e0bfe717 	ldw	r2,-100(fp)
 8236d28:	1080008c 	andi	r2,r2,2
 8236d2c:	10001726 	beq	r2,zero,8236d8c <tcp_input+0x140c>
             tp->t_state == TCPS_TIME_WAIT &&
 8236d30:	e0bfe617 	ldw	r2,-104(fp)
 8236d34:	10800217 	ldw	r2,8(r2)
          * If a new connection request is received
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
 8236d38:	10800298 	cmpnei	r2,r2,10
 8236d3c:	1000131e 	bne	r2,zero,8236d8c <tcp_input+0x140c>
             tp->t_state == TCPS_TIME_WAIT &&
             SEQ_GT(ti->ti_seq, tp->rcv_nxt)) 
 8236d40:	e0bff217 	ldw	r2,-56(fp)
 8236d44:	10c00617 	ldw	r3,24(r2)
 8236d48:	e0bfe617 	ldw	r2,-104(fp)
 8236d4c:	10801617 	ldw	r2,88(r2)
 8236d50:	1885c83a 	sub	r2,r3,r2
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
             tp->t_state == TCPS_TIME_WAIT &&
 8236d54:	00800d0e 	bge	zero,r2,8236d8c <tcp_input+0x140c>
             SEQ_GT(ti->ti_seq, tp->rcv_nxt)) 
         {
            iss = (tcp_seq)(tp->rcv_nxt + (TCP_ISSINCR));
 8236d58:	e0bfe617 	ldw	r2,-104(fp)
 8236d5c:	10c01617 	ldw	r3,88(r2)
 8236d60:	008000b4 	movhi	r2,2
 8236d64:	10bd3fc4 	addi	r2,r2,-2817
 8236d68:	1885883a 	add	r2,r3,r2
 8236d6c:	e0bfed15 	stw	r2,-76(fp)
            if (iss & 0xff000000)
 8236d70:	e0bfed17 	ldw	r2,-76(fp)
 8236d74:	10bfc02c 	andhi	r2,r2,65280
 8236d78:	10000126 	beq	r2,zero,8236d80 <tcp_input+0x1400>
            {
               iss = 0L;
 8236d7c:	e03fed15 	stw	zero,-76(fp)
            }
            (void) tcp_close(tp);
 8236d80:	e13fe617 	ldw	r4,-104(fp)
 8236d84:	8239be00 	call	8239be0 <tcp_close>
            goto findpcb;
 8236d88:	003bd406 	br	8235cdc <tcp_input+0x35c>
          * window edge, and have to drop data and PUSH from
          * incoming segments.  Continue processing, but
          * remember to ack.  Otherwise, drop segment
          * and ack.
          */
         if ((tp->rcv_wnd == 0) && (ti->ti_seq == tp->rcv_nxt))
 8236d8c:	e0bfe617 	ldw	r2,-104(fp)
 8236d90:	10801517 	ldw	r2,84(r2)
 8236d94:	10035a1e 	bne	r2,zero,8237b00 <tcp_input+0x2180>
 8236d98:	e0bff217 	ldw	r2,-56(fp)
 8236d9c:	10c00617 	ldw	r3,24(r2)
 8236da0:	e0bfe617 	ldw	r2,-104(fp)
 8236da4:	10801617 	ldw	r2,88(r2)
 8236da8:	1883551e 	bne	r3,r2,8237b00 <tcp_input+0x2180>
         {
            tp->t_flags |= TF_ACKNOW;
 8236dac:	e0bfe617 	ldw	r2,-104(fp)
 8236db0:	10800b0b 	ldhu	r2,44(r2)
 8236db4:	10800054 	ori	r2,r2,1
 8236db8:	1007883a 	mov	r3,r2
 8236dbc:	e0bfe617 	ldw	r2,-104(fp)
 8236dc0:	10c00b0d 	sth	r3,44(r2)
            tcpstat.tcps_rcvwinprobe++;
 8236dc4:	008209b4 	movhi	r2,2086
 8236dc8:	10b98b04 	addi	r2,r2,-6612
 8236dcc:	10802817 	ldw	r2,160(r2)
 8236dd0:	10c00044 	addi	r3,r2,1
 8236dd4:	008209b4 	movhi	r2,2086
 8236dd8:	10b98b04 	addi	r2,r2,-6612
 8236ddc:	10c02815 	stw	r3,160(r2)
 8236de0:	00000806 	br	8236e04 <tcp_input+0x1484>
         } else
            goto dropafterack;
      } else
         tcpstat.tcps_rcvbyteafterwin += todrop;
 8236de4:	008209b4 	movhi	r2,2086
 8236de8:	10b98b04 	addi	r2,r2,-6612
 8236dec:	10c02617 	ldw	r3,152(r2)
 8236df0:	e0bfe917 	ldw	r2,-92(fp)
 8236df4:	1887883a 	add	r3,r3,r2
 8236df8:	008209b4 	movhi	r2,2086
 8236dfc:	10b98b04 	addi	r2,r2,-6612
 8236e00:	10c02615 	stw	r3,152(r2)
      /* XXX work around m_adj bug */
      if (m->m_len) 
 8236e04:	e0bffe17 	ldw	r2,-8(fp)
 8236e08:	10800217 	ldw	r2,8(r2)
 8236e0c:	10000626 	beq	r2,zero,8236e28 <tcp_input+0x14a8>
      {
         m_adj(m, -todrop);
 8236e10:	e0bfe917 	ldw	r2,-92(fp)
 8236e14:	0085c83a 	sub	r2,zero,r2
 8236e18:	100b883a 	mov	r5,r2
 8236e1c:	e13ffe17 	ldw	r4,-8(fp)
 8236e20:	822e9700 	call	822e970 <m_adj>
 8236e24:	00000706 	br	8236e44 <tcp_input+0x14c4>
      }
      else 
      {
         /* skip tcp/ip header in first mbuf */
         m_adj(m->m_next, -todrop);
 8236e28:	e0bffe17 	ldw	r2,-8(fp)
 8236e2c:	10c00617 	ldw	r3,24(r2)
 8236e30:	e0bfe917 	ldw	r2,-92(fp)
 8236e34:	0085c83a 	sub	r2,zero,r2
 8236e38:	100b883a 	mov	r5,r2
 8236e3c:	1809883a 	mov	r4,r3
 8236e40:	822e9700 	call	822e970 <m_adj>
      }
      ti->ti_len -= (u_short)todrop;
 8236e44:	e0bff217 	ldw	r2,-56(fp)
 8236e48:	1080028b 	ldhu	r2,10(r2)
 8236e4c:	e0ffe917 	ldw	r3,-92(fp)
 8236e50:	10c5c83a 	sub	r2,r2,r3
 8236e54:	1007883a 	mov	r3,r2
 8236e58:	e0bff217 	ldw	r2,-56(fp)
 8236e5c:	10c0028d 	sth	r3,10(r2)
      tiflags &= ~(TH_PUSH|TH_FIN);
 8236e60:	e0ffe717 	ldw	r3,-100(fp)
 8236e64:	00bffd84 	movi	r2,-10
 8236e68:	1884703a 	and	r2,r3,r2
 8236e6c:	e0bfe715 	stw	r2,-100(fp)
      tiflags &= ~TH_RST;  /* clear reset flag */
      goto dropafterack;   /* send an ack and drop current packet */
   }
#endif /* DOS_RST */

   if (tiflags&TH_RST) 
 8236e70:	e0bfe717 	ldw	r2,-100(fp)
 8236e74:	1080010c 	andi	r2,r2,4
 8236e78:	10003426 	beq	r2,zero,8236f4c <tcp_input+0x15cc>
   {
      switch (tp->t_state) 
 8236e7c:	e0bfe617 	ldw	r2,-104(fp)
 8236e80:	10800217 	ldw	r2,8(r2)
 8236e84:	10bfff44 	addi	r2,r2,-3
 8236e88:	10c00228 	cmpgeui	r3,r2,8
 8236e8c:	18002f1e 	bne	r3,zero,8236f4c <tcp_input+0x15cc>
 8236e90:	100690ba 	slli	r3,r2,2
 8236e94:	008208f4 	movhi	r2,2083
 8236e98:	109baa04 	addi	r2,r2,28328
 8236e9c:	1885883a 	add	r2,r3,r2
 8236ea0:	10800017 	ldw	r2,0(r2)
 8236ea4:	1000683a 	jmp	r2
 8236ea8:	08236ec8 	cmpgei	zero,at,-29253
 8236eac:	08236ed8 	cmpnei	zero,at,-29253
 8236eb0:	08236ef4 	orhi	zero,at,36283
 8236eb4:	08236ef4 	orhi	zero,at,36283
 8236eb8:	08236f38 	rdprs	zero,at,-29252
 8236ebc:	08236f38 	rdprs	zero,at,-29252
 8236ec0:	08236ef4 	orhi	zero,at,36283
 8236ec4:	08236f38 	rdprs	zero,at,-29252
      {
   
      case TCPS_SYN_RECEIVED:
         so->so_error = ECONNREFUSED;
 8236ec8:	e0bfe817 	ldw	r2,-96(fp)
 8236ecc:	00c01bc4 	movi	r3,111
 8236ed0:	10c00615 	stw	r3,24(r2)
         goto close;
 8236ed4:	00000a06 	br	8236f00 <tcp_input+0x1580>
   
      case TCPS_ESTABLISHED:
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 8236ed8:	008209b4 	movhi	r2,2086
 8236edc:	10b95d04 	addi	r2,r2,-6796
 8236ee0:	10800717 	ldw	r2,28(r2)
 8236ee4:	10c00044 	addi	r3,r2,1
 8236ee8:	008209b4 	movhi	r2,2086
 8236eec:	10b95d04 	addi	r2,r2,-6796
 8236ef0:	10c00715 	stw	r3,28(r2)
      case TCPS_FIN_WAIT_1:
      case TCPS_FIN_WAIT_2:
      case TCPS_CLOSE_WAIT:
         so->so_error = ECONNRESET;
 8236ef4:	e0bfe817 	ldw	r2,-96(fp)
 8236ef8:	00c01a04 	movi	r3,104
 8236efc:	10c00615 	stw	r3,24(r2)
         close:
         tp->t_state = TCPS_CLOSED;
 8236f00:	e0bfe617 	ldw	r2,-104(fp)
 8236f04:	10000215 	stw	zero,8(r2)
         tcpstat.tcps_drops++;
 8236f08:	008209b4 	movhi	r2,2086
 8236f0c:	10b98b04 	addi	r2,r2,-6612
 8236f10:	10800317 	ldw	r2,12(r2)
 8236f14:	10c00044 	addi	r3,r2,1
 8236f18:	008209b4 	movhi	r2,2086
 8236f1c:	10b98b04 	addi	r2,r2,-6612
 8236f20:	10c00315 	stw	r3,12(r2)
         SETTP(tp, tcp_close(tp));
 8236f24:	e13fe617 	ldw	r4,-104(fp)
 8236f28:	8239be00 	call	8239be0 <tcp_close>
#ifdef TCP_ZEROCOPY
         if (so->rx_upcall)
            so->rx_upcall(so, NULL, ECONNRESET);
#endif   /* TCP_ZEROCOPY */
         GOTO_DROP;
 8236f2c:	00812204 	movi	r2,1160
 8236f30:	d0a0b215 	stw	r2,-32056(gp)
 8236f34:	00034406 	br	8237c48 <tcp_input+0x22c8>
   
      case TCPS_CLOSING:
      case TCPS_LAST_ACK:
      case TCPS_TIME_WAIT:
         SETTP(tp, tcp_close(tp));
 8236f38:	e13fe617 	ldw	r4,-104(fp)
 8236f3c:	8239be00 	call	8239be0 <tcp_close>
         GOTO_DROP;
 8236f40:	00812384 	movi	r2,1166
 8236f44:	d0a0b215 	stw	r2,-32056(gp)
 8236f48:	00033f06 	br	8237c48 <tcp_input+0x22c8>
     tcp_trace("rcvd SYN in established state - ignoring SYN.\n");
#endif
      GOTO_DROP;
   }
#else
   if (tiflags & TH_SYN) 
 8236f4c:	e0bfe717 	ldw	r2,-100(fp)
 8236f50:	1080008c 	andi	r2,r2,2
 8236f54:	10000726 	beq	r2,zero,8236f74 <tcp_input+0x15f4>
   {
      tp = tcp_drop(tp, ECONNRESET);
 8236f58:	01401a04 	movi	r5,104
 8236f5c:	e13fe617 	ldw	r4,-104(fp)
 8236f60:	8239b340 	call	8239b34 <tcp_drop>
 8236f64:	e0bfe615 	stw	r2,-104(fp)
      GOTO_DROPWITHRESET;
 8236f68:	00812b04 	movi	r2,1196
 8236f6c:	d0a0b215 	stw	r2,-32056(gp)
 8236f70:	0002f406 	br	8237b44 <tcp_input+0x21c4>
#endif /* end of else of DOS_SYN */

   /*
    * If the ACK bit is off we drop the segment and return.
    */
   if ((tiflags & TH_ACK) == 0)
 8236f74:	e0bfe717 	ldw	r2,-100(fp)
 8236f78:	1080040c 	andi	r2,r2,16
 8236f7c:	1000031e 	bne	r2,zero,8236f8c <tcp_input+0x160c>
      GOTO_DROP;
 8236f80:	00812d04 	movi	r2,1204
 8236f84:	d0a0b215 	stw	r2,-32056(gp)
 8236f88:	00032f06 	br	8237c48 <tcp_input+0x22c8>

   /*
    * Ack processing.
    */
   switch (tp->t_state) 
 8236f8c:	e0bfe617 	ldw	r2,-104(fp)
 8236f90:	10800217 	ldw	r2,8(r2)
 8236f94:	10c000e0 	cmpeqi	r3,r2,3
 8236f98:	1800051e 	bne	r3,zero,8236fb0 <tcp_input+0x1630>
 8236f9c:	10c000d0 	cmplti	r3,r2,3
 8236fa0:	1801741e 	bne	r3,zero,8237574 <tcp_input+0x1bf4>
 8236fa4:	108002c8 	cmpgei	r2,r2,11
 8236fa8:	1001721e 	bne	r2,zero,8237574 <tcp_input+0x1bf4>
 8236fac:	00003006 	br	8237070 <tcp_input+0x16f0>
    * In SYN_RECEIVED state if the ack ACKs our SYN then enter
    * ESTABLISHED state and continue processing, otherwise
    * send an RST.
    */
   case TCPS_SYN_RECEIVED:
      if (SEQ_GT(tp->snd_una, ti->ti_ack) ||
 8236fb0:	e0bfe617 	ldw	r2,-104(fp)
 8236fb4:	10c00e17 	ldw	r3,56(r2)
 8236fb8:	e0bff217 	ldw	r2,-56(fp)
 8236fbc:	10800717 	ldw	r2,28(r2)
 8236fc0:	1885c83a 	sub	r2,r3,r2
 8236fc4:	00800616 	blt	zero,r2,8236fe0 <tcp_input+0x1660>
          SEQ_GT(ti->ti_ack, tp->snd_max))
 8236fc8:	e0bff217 	ldw	r2,-56(fp)
 8236fcc:	10c00717 	ldw	r3,28(r2)
 8236fd0:	e0bfe617 	ldw	r2,-104(fp)
 8236fd4:	10801a17 	ldw	r2,104(r2)
 8236fd8:	1885c83a 	sub	r2,r3,r2
    * In SYN_RECEIVED state if the ack ACKs our SYN then enter
    * ESTABLISHED state and continue processing, otherwise
    * send an RST.
    */
   case TCPS_SYN_RECEIVED:
      if (SEQ_GT(tp->snd_una, ti->ti_ack) ||
 8236fdc:	00800a0e 	bge	zero,r2,8237008 <tcp_input+0x1688>
          SEQ_GT(ti->ti_ack, tp->snd_max))
      {
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 8236fe0:	008209b4 	movhi	r2,2086
 8236fe4:	10b95d04 	addi	r2,r2,-6796
 8236fe8:	10800717 	ldw	r2,28(r2)
 8236fec:	10c00044 	addi	r3,r2,1
 8236ff0:	008209b4 	movhi	r2,2086
 8236ff4:	10b95d04 	addi	r2,r2,-6796
 8236ff8:	10c00715 	stw	r3,28(r2)
         GOTO_DROPWITHRESET;
 8236ffc:	00813184 	movi	r2,1222
 8237000:	d0a0b215 	stw	r2,-32056(gp)
 8237004:	0002cf06 	br	8237b44 <tcp_input+0x21c4>
      }
      tcpstat.tcps_connects++;
 8237008:	008209b4 	movhi	r2,2086
 823700c:	10b98b04 	addi	r2,r2,-6612
 8237010:	10800217 	ldw	r2,8(r2)
 8237014:	10c00044 	addi	r3,r2,1
 8237018:	008209b4 	movhi	r2,2086
 823701c:	10b98b04 	addi	r2,r2,-6612
 8237020:	10c00215 	stw	r3,8(r2)
      tp->t_state = TCPS_ESTABLISHED;
 8237024:	e0bfe617 	ldw	r2,-104(fp)
 8237028:	00c00104 	movi	r3,4
 823702c:	10c00215 	stw	r3,8(r2)
      soisconnected(so);
 8237030:	e13fe817 	ldw	r4,-96(fp)
 8237034:	8233ad80 	call	8233ad8 <soisconnected>
      tp->t_maxseg = tcp_mss(so);
 8237038:	e13fe817 	ldw	r4,-96(fp)
 823703c:	82382080 	call	8238208 <tcp_mss>
 8237040:	1007883a 	mov	r3,r2
 8237044:	e0bfe617 	ldw	r2,-104(fp)
 8237048:	10c00a0d 	sth	r3,40(r2)
      (void) tcp_reass(tp, (struct tcpiphdr *)0, m);
 823704c:	e1bffe17 	ldw	r6,-8(fp)
 8237050:	000b883a 	mov	r5,zero
 8237054:	e13fe617 	ldw	r4,-104(fp)
 8237058:	82355700 	call	8235570 <tcp_reass>
      tp->snd_wl1 = ti->ti_seq - 1;
 823705c:	e0bff217 	ldw	r2,-56(fp)
 8237060:	10800617 	ldw	r2,24(r2)
 8237064:	10ffffc4 	addi	r3,r2,-1
 8237068:	e0bfe617 	ldw	r2,-104(fp)
 823706c:	10c01115 	stw	r3,68(r2)
   case TCPS_CLOSE_WAIT:
   case TCPS_CLOSING:
   case TCPS_LAST_ACK:
   case TCPS_TIME_WAIT:

      if (SEQ_LEQ(ti->ti_ack, tp->snd_una)) 
 8237070:	e0bff217 	ldw	r2,-56(fp)
 8237074:	10c00717 	ldw	r3,28(r2)
 8237078:	e0bfe617 	ldw	r2,-104(fp)
 823707c:	10800e17 	ldw	r2,56(r2)
 8237080:	1885c83a 	sub	r2,r3,r2
 8237084:	00806316 	blt	zero,r2,8237214 <tcp_input+0x1894>
      {
         if (ti->ti_len == 0 && rx_win == tp->snd_wnd) 
 8237088:	e0bff217 	ldw	r2,-56(fp)
 823708c:	1080028b 	ldhu	r2,10(r2)
 8237090:	10bfffcc 	andi	r2,r2,65535
 8237094:	10005a1e 	bne	r2,zero,8237200 <tcp_input+0x1880>
 8237098:	e0bfe617 	ldw	r2,-104(fp)
 823709c:	10c01417 	ldw	r3,80(r2)
 82370a0:	e0bff517 	ldw	r2,-44(fp)
 82370a4:	1880561e 	bne	r3,r2,8237200 <tcp_input+0x1880>
         {
            tcpstat.tcps_rcvdupack++;
 82370a8:	008209b4 	movhi	r2,2086
 82370ac:	10b98b04 	addi	r2,r2,-6612
 82370b0:	10802917 	ldw	r2,164(r2)
 82370b4:	10c00044 	addi	r3,r2,1
 82370b8:	008209b4 	movhi	r2,2086
 82370bc:	10b98b04 	addi	r2,r2,-6612
 82370c0:	10c02915 	stw	r3,164(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 82370c4:	e0bfe617 	ldw	r2,-104(fp)
 82370c8:	10800317 	ldw	r2,12(r2)
 82370cc:	10000526 	beq	r2,zero,82370e4 <tcp_input+0x1764>
                ti->ti_ack != tp->snd_una)
 82370d0:	e0bff217 	ldw	r2,-56(fp)
 82370d4:	10c00717 	ldw	r3,28(r2)
 82370d8:	e0bfe617 	ldw	r2,-104(fp)
 82370dc:	10800e17 	ldw	r2,56(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 82370e0:	18800326 	beq	r3,r2,82370f0 <tcp_input+0x1770>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
 82370e4:	e0bfe617 	ldw	r2,-104(fp)
 82370e8:	10000915 	stw	zero,36(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 82370ec:	00004706 	br	823720c <tcp_input+0x188c>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
 82370f0:	e0bfe617 	ldw	r2,-104(fp)
 82370f4:	10800917 	ldw	r2,36(r2)
 82370f8:	10c00044 	addi	r3,r2,1
 82370fc:	e0bfe617 	ldw	r2,-104(fp)
 8237100:	10c00915 	stw	r3,36(r2)
 8237104:	e0bfe617 	ldw	r2,-104(fp)
 8237108:	10c00917 	ldw	r3,36(r2)
 823710c:	d0a03c83 	ldbu	r2,-32526(gp)
 8237110:	10803fcc 	andi	r2,r2,255
 8237114:	1080201c 	xori	r2,r2,128
 8237118:	10bfe004 	addi	r2,r2,-128
 823711c:	18803b1e 	bne	r3,r2,823720c <tcp_input+0x188c>
            {
               tcp_seq onxt = tp->snd_nxt;
 8237120:	e0bfe617 	ldw	r2,-104(fp)
 8237124:	10800f17 	ldw	r2,60(r2)
 8237128:	e0bff815 	stw	r2,-32(fp)
               u_short  win   =
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
 823712c:	e0bfe617 	ldw	r2,-104(fp)
 8237130:	11001417 	ldw	r4,80(r2)
 8237134:	e0bfe617 	ldw	r2,-104(fp)
 8237138:	10c01b17 	ldw	r3,108(r2)
 823713c:	2005883a 	mov	r2,r4
 8237140:	1880012e 	bgeu	r3,r2,8237148 <tcp_input+0x17c8>
 8237144:	1805883a 	mov	r2,r3
 8237148:	1006d07a 	srli	r3,r2,1
               tp->t_maxseg;
 823714c:	e0bfe617 	ldw	r2,-104(fp)
 8237150:	10800a0b 	ldhu	r2,40(r2)
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
            {
               tcp_seq onxt = tp->snd_nxt;
               u_short  win   =
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
 8237154:	10bfffcc 	andi	r2,r2,65535
 8237158:	100b883a 	mov	r5,r2
 823715c:	1809883a 	mov	r4,r3
 8237160:	8202c100 	call	8202c10 <__udivsi3>
               tp->t_dupacks = 0;
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
            {
               tcp_seq onxt = tp->snd_nxt;
               u_short  win   =
 8237164:	e0bff00d 	sth	r2,-64(fp)
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
               tp->t_maxseg;

               if (win < 2)
 8237168:	e0bff00b 	ldhu	r2,-64(fp)
 823716c:	108000a8 	cmpgeui	r2,r2,2
 8237170:	1000021e 	bne	r2,zero,823717c <tcp_input+0x17fc>
                  win = 2;
 8237174:	00800084 	movi	r2,2
 8237178:	e0bff00d 	sth	r2,-64(fp)
               tp->snd_ssthresh = (u_short)(win * tp->t_maxseg);
 823717c:	e0bfe617 	ldw	r2,-104(fp)
 8237180:	10c00a0b 	ldhu	r3,40(r2)
 8237184:	e0bff00b 	ldhu	r2,-64(fp)
 8237188:	1885383a 	mul	r2,r3,r2
 823718c:	10ffffcc 	andi	r3,r2,65535
 8237190:	e0bfe617 	ldw	r2,-104(fp)
 8237194:	10c01c15 	stw	r3,112(r2)

               tp->t_timer[TCPT_REXMT] = 0;
 8237198:	e0bfe617 	ldw	r2,-104(fp)
 823719c:	10000315 	stw	zero,12(r2)
               tp->t_rttick = 0;
 82371a0:	e0bfe617 	ldw	r2,-104(fp)
 82371a4:	10001e15 	stw	zero,120(r2)
               tp->snd_nxt = ti->ti_ack;
 82371a8:	e0bff217 	ldw	r2,-56(fp)
 82371ac:	10c00717 	ldw	r3,28(r2)
 82371b0:	e0bfe617 	ldw	r2,-104(fp)
 82371b4:	10c00f15 	stw	r3,60(r2)
               tp->snd_cwnd = tp->t_maxseg;
 82371b8:	e0bfe617 	ldw	r2,-104(fp)
 82371bc:	10800a0b 	ldhu	r2,40(r2)
 82371c0:	10ffffcc 	andi	r3,r2,65535
 82371c4:	e0bfe617 	ldw	r2,-104(fp)
 82371c8:	10c01b15 	stw	r3,108(r2)
               (void) tcp_output(tp);
 82371cc:	e13fe617 	ldw	r4,-104(fp)
 82371d0:	82383000 	call	8238300 <tcp_output>

               if (SEQ_GT(onxt, tp->snd_nxt))
 82371d4:	e0bfe617 	ldw	r2,-104(fp)
 82371d8:	10800f17 	ldw	r2,60(r2)
 82371dc:	e0fff817 	ldw	r3,-32(fp)
 82371e0:	1885c83a 	sub	r2,r3,r2
 82371e4:	0080030e 	bge	zero,r2,82371f4 <tcp_input+0x1874>
                  tp->snd_nxt = onxt;
 82371e8:	e0bfe617 	ldw	r2,-104(fp)
 82371ec:	e0fff817 	ldw	r3,-32(fp)
 82371f0:	10c00f15 	stw	r3,60(r2)
               GOTO_DROP;
 82371f4:	00814544 	movi	r2,1301
 82371f8:	d0a0b215 	stw	r2,-32056(gp)
 82371fc:	00029206 	br	8237c48 <tcp_input+0x22c8>
            }
         } else
            tp->t_dupacks = 0;
 8237200:	e0bfe617 	ldw	r2,-104(fp)
 8237204:	10000915 	stw	zero,36(r2)
         break;
 8237208:	0000da06 	br	8237574 <tcp_input+0x1bf4>
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 823720c:	0001883a 	nop
                  tp->snd_nxt = onxt;
               GOTO_DROP;
            }
         } else
            tp->t_dupacks = 0;
         break;
 8237210:	0000d806 	br	8237574 <tcp_input+0x1bf4>
      }
      tp->t_dupacks = 0;
 8237214:	e0bfe617 	ldw	r2,-104(fp)
 8237218:	10000915 	stw	zero,36(r2)
      if (SEQ_GT(ti->ti_ack, tp->snd_max)) 
 823721c:	e0bff217 	ldw	r2,-56(fp)
 8237220:	10c00717 	ldw	r3,28(r2)
 8237224:	e0bfe617 	ldw	r2,-104(fp)
 8237228:	10801a17 	ldw	r2,104(r2)
 823722c:	1885c83a 	sub	r2,r3,r2
 8237230:	0080080e 	bge	zero,r2,8237254 <tcp_input+0x18d4>
      {
         tcpstat.tcps_rcvacktoomuch++;
 8237234:	008209b4 	movhi	r2,2086
 8237238:	10b98b04 	addi	r2,r2,-6612
 823723c:	10802a17 	ldw	r2,168(r2)
 8237240:	10c00044 	addi	r3,r2,1
 8237244:	008209b4 	movhi	r2,2086
 8237248:	10b98b04 	addi	r2,r2,-6612
 823724c:	10c02a15 	stw	r3,168(r2)
         goto dropafterack;
 8237250:	00022b06 	br	8237b00 <tcp_input+0x2180>
      }
      acked = (int)(ti->ti_ack - tp->snd_una);
 8237254:	e0bff217 	ldw	r2,-56(fp)
 8237258:	10c00717 	ldw	r3,28(r2)
 823725c:	e0bfe617 	ldw	r2,-104(fp)
 8237260:	10800e17 	ldw	r2,56(r2)
 8237264:	1885c83a 	sub	r2,r3,r2
 8237268:	e0bff615 	stw	r2,-40(fp)
      tcpstat.tcps_rcvackpack++;
 823726c:	008209b4 	movhi	r2,2086
 8237270:	10b98b04 	addi	r2,r2,-6612
 8237274:	10802b17 	ldw	r2,172(r2)
 8237278:	10c00044 	addi	r3,r2,1
 823727c:	008209b4 	movhi	r2,2086
 8237280:	10b98b04 	addi	r2,r2,-6612
 8237284:	10c02b15 	stw	r3,172(r2)
      tcpstat.tcps_rcvackbyte += acked;
 8237288:	008209b4 	movhi	r2,2086
 823728c:	10b98b04 	addi	r2,r2,-6612
 8237290:	10c02c17 	ldw	r3,176(r2)
 8237294:	e0bff617 	ldw	r2,-40(fp)
 8237298:	1887883a 	add	r3,r3,r2
 823729c:	008209b4 	movhi	r2,2086
 82372a0:	10b98b04 	addi	r2,r2,-6612
 82372a4:	10c02c15 	stw	r3,176(r2)
       * number was acked, update smoothed round trip time.
       * Since we now have an rtt measurement, cancel the
       * timer backoff (cf., Phil Karn's retransmit alg.).
       * Recompute the initial retransmit timer.
       */
      if((tp->t_rttick) && 
 82372a8:	e0bfe617 	ldw	r2,-104(fp)
 82372ac:	10801e17 	ldw	r2,120(r2)
 82372b0:	10000826 	beq	r2,zero,82372d4 <tcp_input+0x1954>
#ifdef TCP_TIMESTAMP
         ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
         (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
 82372b4:	e0bff217 	ldw	r2,-56(fp)
 82372b8:	10c00717 	ldw	r3,28(r2)
 82372bc:	e0bfe617 	ldw	r2,-104(fp)
 82372c0:	10801f17 	ldw	r2,124(r2)
 82372c4:	1885c83a 	sub	r2,r3,r2
       * number was acked, update smoothed round trip time.
       * Since we now have an rtt measurement, cancel the
       * timer backoff (cf., Phil Karn's retransmit alg.).
       * Recompute the initial retransmit timer.
       */
      if((tp->t_rttick) && 
 82372c8:	0080020e 	bge	zero,r2,82372d4 <tcp_input+0x1954>
#ifdef TCP_TIMESTAMP
         ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
         (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
         tcp_xmit_timer(tp);
 82372cc:	e13fe617 	ldw	r4,-104(fp)
 82372d0:	8237f640 	call	8237f64 <tcp_xmit_timer>
       * If all outstanding data is acked, stop retransmit
       * timer and remember to restart (more output or persist).
       * If there is more data to be acked, restart retransmit
       * timer, using current (possibly backed-off) value.
       */
      if (ti->ti_ack == tp->snd_max) 
 82372d4:	e0bff217 	ldw	r2,-56(fp)
 82372d8:	10c00717 	ldw	r3,28(r2)
 82372dc:	e0bfe617 	ldw	r2,-104(fp)
 82372e0:	10801a17 	ldw	r2,104(r2)
 82372e4:	1880051e 	bne	r3,r2,82372fc <tcp_input+0x197c>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 82372e8:	e0bfe617 	ldw	r2,-104(fp)
 82372ec:	10000315 	stw	zero,12(r2)
         needoutput = 1;
 82372f0:	00800044 	movi	r2,1
 82372f4:	e0bfeb15 	stw	r2,-84(fp)
 82372f8:	00000706 	br	8237318 <tcp_input+0x1998>
      } else if (tp->t_timer[TCPT_PERSIST] == 0)
 82372fc:	e0bfe617 	ldw	r2,-104(fp)
 8237300:	10800417 	ldw	r2,16(r2)
 8237304:	1000041e 	bne	r2,zero,8237318 <tcp_input+0x1998>
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 8237308:	e0bfe617 	ldw	r2,-104(fp)
 823730c:	10c00817 	ldw	r3,32(r2)
 8237310:	e0bfe617 	ldw	r2,-104(fp)
 8237314:	10c00315 	stw	r3,12(r2)
       * in flight, open exponentially (maxseg per packet).
       * Otherwise open linearly (maxseg per window,
       * or maxseg^2 / cwnd per packet).
       */
      {
         tcp_win  cw =  tp->snd_cwnd;
 8237318:	e0bfe617 	ldw	r2,-104(fp)
 823731c:	10801b17 	ldw	r2,108(r2)
 8237320:	e0bff915 	stw	r2,-28(fp)
         u_short  incr  =  tp->t_maxseg;
 8237324:	e0bfe617 	ldw	r2,-104(fp)
 8237328:	10800a0b 	ldhu	r2,40(r2)
 823732c:	e0bff08d 	sth	r2,-62(fp)

         if (cw > tp->snd_ssthresh)
 8237330:	e0bfe617 	ldw	r2,-104(fp)
 8237334:	10c01c17 	ldw	r3,112(r2)
 8237338:	e0bff917 	ldw	r2,-28(fp)
 823733c:	18800a2e 	bgeu	r3,r2,8237368 <tcp_input+0x19e8>
            incr = MAX( (incr * incr / cw), (ALIGN_TYPE << 2) );
 8237340:	e0fff08b 	ldhu	r3,-62(fp)
 8237344:	e0bff08b 	ldhu	r2,-62(fp)
 8237348:	1885383a 	mul	r2,r3,r2
 823734c:	e17ff917 	ldw	r5,-28(fp)
 8237350:	1009883a 	mov	r4,r2
 8237354:	8202c100 	call	8202c10 <__udivsi3>
 8237358:	10c00428 	cmpgeui	r3,r2,16
 823735c:	1800011e 	bne	r3,zero,8237364 <tcp_input+0x19e4>
 8237360:	00800404 	movi	r2,16
 8237364:	e0bff08d 	sth	r2,-62(fp)

         tp->snd_cwnd = MIN(cw + (u_short)incr, (IP_MAXPACKET));
 8237368:	e0fff08b 	ldhu	r3,-62(fp)
 823736c:	e0bff917 	ldw	r2,-28(fp)
 8237370:	1885883a 	add	r2,r3,r2
 8237374:	10d80070 	cmpltui	r3,r2,24577
 8237378:	1800011e 	bne	r3,zero,8237380 <tcp_input+0x1a00>
 823737c:	00980004 	movi	r2,24576
 8237380:	e0ffe617 	ldw	r3,-104(fp)
 8237384:	18801b15 	stw	r2,108(r3)
      }
      if (acked > (int)so->so_snd.sb_cc) 
 8237388:	e0bfe817 	ldw	r2,-96(fp)
 823738c:	10801217 	ldw	r2,72(r2)
 8237390:	1007883a 	mov	r3,r2
 8237394:	e0bff617 	ldw	r2,-40(fp)
 8237398:	1880120e 	bge	r3,r2,82373e4 <tcp_input+0x1a64>
      {
         tp->snd_wnd -= (u_short)so->so_snd.sb_cc;
 823739c:	e0bfe617 	ldw	r2,-104(fp)
 82373a0:	10c01417 	ldw	r3,80(r2)
 82373a4:	e0bfe817 	ldw	r2,-96(fp)
 82373a8:	10801217 	ldw	r2,72(r2)
 82373ac:	10bfffcc 	andi	r2,r2,65535
 82373b0:	1887c83a 	sub	r3,r3,r2
 82373b4:	e0bfe617 	ldw	r2,-104(fp)
 82373b8:	10c01415 	stw	r3,80(r2)
         sbdrop(&so->so_snd, (int)so->so_snd.sb_cc);
 82373bc:	e0bfe817 	ldw	r2,-96(fp)
 82373c0:	10c01204 	addi	r3,r2,72
 82373c4:	e0bfe817 	ldw	r2,-96(fp)
 82373c8:	10801217 	ldw	r2,72(r2)
 82373cc:	100b883a 	mov	r5,r2
 82373d0:	1809883a 	mov	r4,r3
 82373d4:	82349ac0 	call	82349ac <sbdrop>
         ourfinisacked = 1;
 82373d8:	00800044 	movi	r2,1
 82373dc:	e0bfea15 	stw	r2,-88(fp)
 82373e0:	00000d06 	br	8237418 <tcp_input+0x1a98>
      } 
      else 
      {
         sbdrop(&so->so_snd, acked);
 82373e4:	e0bfe817 	ldw	r2,-96(fp)
 82373e8:	10801204 	addi	r2,r2,72
 82373ec:	e17ff617 	ldw	r5,-40(fp)
 82373f0:	1009883a 	mov	r4,r2
 82373f4:	82349ac0 	call	82349ac <sbdrop>
         tp->snd_wnd -= (u_short)acked;
 82373f8:	e0bfe617 	ldw	r2,-104(fp)
 82373fc:	10c01417 	ldw	r3,80(r2)
 8237400:	e0bff617 	ldw	r2,-40(fp)
 8237404:	10bfffcc 	andi	r2,r2,65535
 8237408:	1887c83a 	sub	r3,r3,r2
 823740c:	e0bfe617 	ldw	r2,-104(fp)
 8237410:	10c01415 	stw	r3,80(r2)
         ourfinisacked = 0;
 8237414:	e03fea15 	stw	zero,-88(fp)
      }

      if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 8237418:	e0bfe817 	ldw	r2,-96(fp)
 823741c:	1080190b 	ldhu	r2,100(r2)
 8237420:	10bfffcc 	andi	r2,r2,65535
 8237424:	1080030c 	andi	r2,r2,12
 8237428:	10000526 	beq	r2,zero,8237440 <tcp_input+0x1ac0>
         sowwakeup(so);
 823742c:	e0bfe817 	ldw	r2,-96(fp)
 8237430:	10801204 	addi	r2,r2,72
 8237434:	100b883a 	mov	r5,r2
 8237438:	e13fe817 	ldw	r4,-96(fp)
 823743c:	82342440 	call	8234244 <sbwakeup>

      tp->snd_una = ti->ti_ack;
 8237440:	e0bff217 	ldw	r2,-56(fp)
 8237444:	10c00717 	ldw	r3,28(r2)
 8237448:	e0bfe617 	ldw	r2,-104(fp)
 823744c:	10c00e15 	stw	r3,56(r2)
      if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 8237450:	e0bfe617 	ldw	r2,-104(fp)
 8237454:	10c00f17 	ldw	r3,60(r2)
 8237458:	e0bfe617 	ldw	r2,-104(fp)
 823745c:	10800e17 	ldw	r2,56(r2)
 8237460:	1885c83a 	sub	r2,r3,r2
 8237464:	1000040e 	bge	r2,zero,8237478 <tcp_input+0x1af8>
         tp->snd_nxt = tp->snd_una;
 8237468:	e0bfe617 	ldw	r2,-104(fp)
 823746c:	10c00e17 	ldw	r3,56(r2)
 8237470:	e0bfe617 	ldw	r2,-104(fp)
 8237474:	10c00f15 	stw	r3,60(r2)


      switch (tp->t_state) 
 8237478:	e0bfe617 	ldw	r2,-104(fp)
 823747c:	10800217 	ldw	r2,8(r2)
 8237480:	10c001e0 	cmpeqi	r3,r2,7
 8237484:	18001a1e 	bne	r3,zero,82374f0 <tcp_input+0x1b70>
 8237488:	10c00208 	cmpgei	r3,r2,8
 823748c:	1800031e 	bne	r3,zero,823749c <tcp_input+0x1b1c>
 8237490:	108001a0 	cmpeqi	r2,r2,6
 8237494:	1000061e 	bne	r2,zero,82374b0 <tcp_input+0x1b30>
 8237498:	00003606 	br	8237574 <tcp_input+0x1bf4>
 823749c:	10c00220 	cmpeqi	r3,r2,8
 82374a0:	1800221e 	bne	r3,zero,823752c <tcp_input+0x1bac>
 82374a4:	108002a0 	cmpeqi	r2,r2,10
 82374a8:	1000271e 	bne	r2,zero,8237548 <tcp_input+0x1bc8>
 82374ac:	00003106 	br	8237574 <tcp_input+0x1bf4>
       * In FIN_WAIT_1 STATE in addition to the processing
       * for the ESTABLISHED state if our FIN is now acknowledged
       * then enter FIN_WAIT_2.
       */
      case TCPS_FIN_WAIT_1:
         if (ourfinisacked) 
 82374b0:	e0bfea17 	ldw	r2,-88(fp)
 82374b4:	10002a26 	beq	r2,zero,8237560 <tcp_input+0x1be0>
             * data, then closing user can proceed.
             * Starting the timer is contrary to the
             * specification, but if we don't get a FIN
             * we'll hang forever.
             */
            if (so->so_state & SS_CANTRCVMORE) 
 82374b8:	e0bfe817 	ldw	r2,-96(fp)
 82374bc:	1080088b 	ldhu	r2,34(r2)
 82374c0:	10bfffcc 	andi	r2,r2,65535
 82374c4:	1080080c 	andi	r2,r2,32
 82374c8:	10000526 	beq	r2,zero,82374e0 <tcp_input+0x1b60>
            {
               soisdisconnected(so);
 82374cc:	e13fe817 	ldw	r4,-96(fp)
 82374d0:	8233c740 	call	8233c74 <soisdisconnected>
               tp->t_timer[TCPT_2MSL] = tcp_maxidle;
 82374d4:	d0e0b417 	ldw	r3,-32048(gp)
 82374d8:	e0bfe617 	ldw	r2,-104(fp)
 82374dc:	10c00615 	stw	r3,24(r2)
            }
            tp->t_state = TCPS_FIN_WAIT_2;
 82374e0:	e0bfe617 	ldw	r2,-104(fp)
 82374e4:	00c00244 	movi	r3,9
 82374e8:	10c00215 	stw	r3,8(r2)
         }
         break;
 82374ec:	00001c06 	br	8237560 <tcp_input+0x1be0>
       * the ESTABLISHED state if the ACK acknowledges our FIN
       * then enter the TIME-WAIT state, otherwise ignore
       * the segment.
       */
      case TCPS_CLOSING:
         if (ourfinisacked) 
 82374f0:	e0bfea17 	ldw	r2,-88(fp)
 82374f4:	10001c26 	beq	r2,zero,8237568 <tcp_input+0x1be8>
         {
            tp->t_state = TCPS_TIME_WAIT;
 82374f8:	e0bfe617 	ldw	r2,-104(fp)
 82374fc:	00c00284 	movi	r3,10
 8237500:	10c00215 	stw	r3,8(r2)
            tcp_canceltimers(tp);
 8237504:	e13fe617 	ldw	r4,-104(fp)
 8237508:	823a0780 	call	823a078 <tcp_canceltimers>
            tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 823750c:	d0a03b17 	ldw	r2,-32532(gp)
 8237510:	1085883a 	add	r2,r2,r2
 8237514:	1007883a 	mov	r3,r2
 8237518:	e0bfe617 	ldw	r2,-104(fp)
 823751c:	10c00615 	stw	r3,24(r2)
            soisdisconnected(so);
 8237520:	e13fe817 	ldw	r4,-96(fp)
 8237524:	8233c740 	call	8233c74 <soisdisconnected>
         }
         break;
 8237528:	00000f06 	br	8237568 <tcp_input+0x1be8>
       * and/or to be acked, as well as for the ack of our FIN.
       * If our FIN is now acknowledged, delete the TCB,
       * enter the closed state and return.
       */
      case TCPS_LAST_ACK:
         if (ourfinisacked) 
 823752c:	e0bfea17 	ldw	r2,-88(fp)
 8237530:	10000f26 	beq	r2,zero,8237570 <tcp_input+0x1bf0>
         {
            SETTP(tp, tcp_close(tp));
 8237534:	e13fe617 	ldw	r4,-104(fp)
 8237538:	8239be00 	call	8239be0 <tcp_close>
            GOTO_DROP;
 823753c:	00816644 	movi	r2,1433
 8237540:	d0a0b215 	stw	r2,-32056(gp)
 8237544:	0001c006 	br	8237c48 <tcp_input+0x22c8>
       * In TIME_WAIT state the only thing that should arrive
       * is a retransmission of the remote FIN.  Acknowledge
       * it and restart the finack timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 8237548:	d0a03b17 	ldw	r2,-32532(gp)
 823754c:	1085883a 	add	r2,r2,r2
 8237550:	1007883a 	mov	r3,r2
 8237554:	e0bfe617 	ldw	r2,-104(fp)
 8237558:	10c00615 	stw	r3,24(r2)
         goto dropafterack;
 823755c:	00016806 	br	8237b00 <tcp_input+0x2180>
               soisdisconnected(so);
               tp->t_timer[TCPT_2MSL] = tcp_maxidle;
            }
            tp->t_state = TCPS_FIN_WAIT_2;
         }
         break;
 8237560:	0001883a 	nop
 8237564:	00000306 	br	8237574 <tcp_input+0x1bf4>
            tp->t_state = TCPS_TIME_WAIT;
            tcp_canceltimers(tp);
            tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
            soisdisconnected(so);
         }
         break;
 8237568:	0001883a 	nop
 823756c:	00000106 	br	8237574 <tcp_input+0x1bf4>
         if (ourfinisacked) 
         {
            SETTP(tp, tcp_close(tp));
            GOTO_DROP;
         }
         break;
 8237570:	0001883a 	nop
step6:
   /*
    * Update window information.
    * Don't look at window if no ACK: TAC's send garbage on first SYN.
    */
   if ((tiflags & TH_ACK) &&
 8237574:	e0bfe717 	ldw	r2,-100(fp)
 8237578:	1080040c 	andi	r2,r2,16
 823757c:	10004426 	beq	r2,zero,8237690 <tcp_input+0x1d10>
       /*
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
 8237580:	e0bfe617 	ldw	r2,-104(fp)
 8237584:	10c01117 	ldw	r3,68(r2)
 8237588:	e0bff217 	ldw	r2,-56(fp)
 823758c:	10800617 	ldw	r2,24(r2)
 8237590:	1885c83a 	sub	r2,r3,r2
step6:
   /*
    * Update window information.
    * Don't look at window if no ACK: TAC's send garbage on first SYN.
    */
   if ((tiflags & TH_ACK) &&
 8237594:	10001416 	blt	r2,zero,82375e8 <tcp_input+0x1c68>
       /*
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
 8237598:	e0bfe617 	ldw	r2,-104(fp)
 823759c:	10c01117 	ldw	r3,68(r2)
 82375a0:	e0bff217 	ldw	r2,-56(fp)
 82375a4:	10800617 	ldw	r2,24(r2)
 82375a8:	1880391e 	bne	r3,r2,8237690 <tcp_input+0x1d10>
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
 82375ac:	e0bfe617 	ldw	r2,-104(fp)
 82375b0:	10c01217 	ldw	r3,72(r2)
 82375b4:	e0bff217 	ldw	r2,-56(fp)
 82375b8:	10800717 	ldw	r2,28(r2)
 82375bc:	1885c83a 	sub	r2,r3,r2
       /*
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
 82375c0:	10000916 	blt	r2,zero,82375e8 <tcp_input+0x1c68>
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
 82375c4:	e0bfe617 	ldw	r2,-104(fp)
 82375c8:	10c01217 	ldw	r3,72(r2)
 82375cc:	e0bff217 	ldw	r2,-56(fp)
 82375d0:	10800717 	ldw	r2,28(r2)
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
 82375d4:	18802e1e 	bne	r3,r2,8237690 <tcp_input+0x1d10>
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
 82375d8:	e0bfe617 	ldw	r2,-104(fp)
 82375dc:	10c01417 	ldw	r3,80(r2)
 82375e0:	e0bff517 	ldw	r2,-44(fp)
 82375e4:	18802a2e 	bgeu	r3,r2,8237690 <tcp_input+0x1d10>
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
 82375e8:	e0bff217 	ldw	r2,-56(fp)
 82375ec:	1080028b 	ldhu	r2,10(r2)
 82375f0:	10bfffcc 	andi	r2,r2,65535
 82375f4:	1000101e 	bne	r2,zero,8237638 <tcp_input+0x1cb8>
          (tp->snd_wl2 == ti->ti_ack) &&
 82375f8:	e0bfe617 	ldw	r2,-104(fp)
 82375fc:	10c01217 	ldw	r3,72(r2)
 8237600:	e0bff217 	ldw	r2,-56(fp)
 8237604:	10800717 	ldw	r2,28(r2)
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
 8237608:	18800b1e 	bne	r3,r2,8237638 <tcp_input+0x1cb8>
          (tp->snd_wl2 == ti->ti_ack) &&
          (rx_win > tp->snd_wnd))
 823760c:	e0bfe617 	ldw	r2,-104(fp)
 8237610:	10c01417 	ldw	r3,80(r2)
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
          (tp->snd_wl2 == ti->ti_ack) &&
 8237614:	e0bff517 	ldw	r2,-44(fp)
 8237618:	1880072e 	bgeu	r3,r2,8237638 <tcp_input+0x1cb8>
          (rx_win > tp->snd_wnd))
      {
         tcpstat.tcps_rcvwinupd++;
 823761c:	008209b4 	movhi	r2,2086
 8237620:	10b98b04 	addi	r2,r2,-6612
 8237624:	10802d17 	ldw	r2,180(r2)
 8237628:	10c00044 	addi	r3,r2,1
 823762c:	008209b4 	movhi	r2,2086
 8237630:	10b98b04 	addi	r2,r2,-6612
 8237634:	10c02d15 	stw	r3,180(r2)
      }
      tp->snd_wnd = rx_win;
 8237638:	e0bfe617 	ldw	r2,-104(fp)
 823763c:	e0fff517 	ldw	r3,-44(fp)
 8237640:	10c01415 	stw	r3,80(r2)
      tp->snd_wl1 = ti->ti_seq;
 8237644:	e0bff217 	ldw	r2,-56(fp)
 8237648:	10c00617 	ldw	r3,24(r2)
 823764c:	e0bfe617 	ldw	r2,-104(fp)
 8237650:	10c01115 	stw	r3,68(r2)
      tp->snd_wl2 = ti->ti_ack;
 8237654:	e0bff217 	ldw	r2,-56(fp)
 8237658:	10c00717 	ldw	r3,28(r2)
 823765c:	e0bfe617 	ldw	r2,-104(fp)
 8237660:	10c01215 	stw	r3,72(r2)
      if (tp->snd_wnd > tp->max_sndwnd)
 8237664:	e0bfe617 	ldw	r2,-104(fp)
 8237668:	10801417 	ldw	r2,80(r2)
 823766c:	e0ffe617 	ldw	r3,-104(fp)
 8237670:	18c02317 	ldw	r3,140(r3)
 8237674:	1880042e 	bgeu	r3,r2,8237688 <tcp_input+0x1d08>
         tp->max_sndwnd = tp->snd_wnd;
 8237678:	e0bfe617 	ldw	r2,-104(fp)
 823767c:	10c01417 	ldw	r3,80(r2)
 8237680:	e0bfe617 	ldw	r2,-104(fp)
 8237684:	10c02315 	stw	r3,140(r2)
      needoutput = 1;
 8237688:	00800044 	movi	r2,1
 823768c:	e0bfeb15 	stw	r2,-84(fp)
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 8237690:	e0bfe717 	ldw	r2,-100(fp)
 8237694:	1080080c 	andi	r2,r2,32
 8237698:	10005626 	beq	r2,zero,82377f4 <tcp_input+0x1e74>
 823769c:	e0bff217 	ldw	r2,-56(fp)
 82376a0:	1080098b 	ldhu	r2,38(r2)
 82376a4:	10bfffcc 	andi	r2,r2,65535
 82376a8:	10005226 	beq	r2,zero,82377f4 <tcp_input+0x1e74>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 82376ac:	e0bfe617 	ldw	r2,-104(fp)
 82376b0:	10800217 	ldw	r2,8(r2)
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 82376b4:	10800288 	cmpgei	r2,r2,10
 82376b8:	10004e1e 	bne	r2,zero,82377f4 <tcp_input+0x1e74>
       * This is a kludge, but if we receive and accept
       * random urgent pointers, we'll crash in
       * soreceive.  It's hard to imagine someone
       * actually wanting to send this much urgent data.
       */
      if (ti->ti_urp + so->so_rcv.sb_cc > SB_MAX) 
 82376bc:	e0bff217 	ldw	r2,-56(fp)
 82376c0:	1080098b 	ldhu	r2,38(r2)
 82376c4:	10ffffcc 	andi	r3,r2,65535
 82376c8:	e0bfe817 	ldw	r2,-96(fp)
 82376cc:	10800a17 	ldw	r2,40(r2)
 82376d0:	1885883a 	add	r2,r3,r2
 82376d4:	10900070 	cmpltui	r2,r2,16385
 82376d8:	1000071e 	bne	r2,zero,82376f8 <tcp_input+0x1d78>
      {
         ti->ti_urp = 0;         /* XXX */
 82376dc:	e0bff217 	ldw	r2,-56(fp)
 82376e0:	1000098d 	sth	zero,38(r2)
         tiflags &= ~TH_URG;     /* XXX */
 82376e4:	e0ffe717 	ldw	r3,-100(fp)
 82376e8:	00bff7c4 	movi	r2,-33
 82376ec:	1884703a 	and	r2,r3,r2
 82376f0:	e0bfe715 	stw	r2,-100(fp)
         goto dodata;         /* XXX */
 82376f4:	00004b06 	br	8237824 <tcp_input+0x1ea4>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
 82376f8:	e0bff217 	ldw	r2,-56(fp)
 82376fc:	10c00617 	ldw	r3,24(r2)
 8237700:	e0bff217 	ldw	r2,-56(fp)
 8237704:	1080098b 	ldhu	r2,38(r2)
 8237708:	10bfffcc 	andi	r2,r2,65535
 823770c:	1887883a 	add	r3,r3,r2
 8237710:	e0bfe617 	ldw	r2,-104(fp)
 8237714:	10801717 	ldw	r2,92(r2)
 8237718:	1885c83a 	sub	r2,r3,r2
 823771c:	0080250e 	bge	zero,r2,82377b4 <tcp_input+0x1e34>
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
 8237720:	e0bff217 	ldw	r2,-56(fp)
 8237724:	10c00617 	ldw	r3,24(r2)
 8237728:	e0bff217 	ldw	r2,-56(fp)
 823772c:	1080098b 	ldhu	r2,38(r2)
 8237730:	10bfffcc 	andi	r2,r2,65535
 8237734:	1887883a 	add	r3,r3,r2
 8237738:	e0bfe617 	ldw	r2,-104(fp)
 823773c:	10c01715 	stw	r3,92(r2)
         so->so_oobmark = so->so_rcv.sb_cc +
 8237740:	e0bfe817 	ldw	r2,-96(fp)
 8237744:	10c00a17 	ldw	r3,40(r2)
         (tp->rcv_up - tp->rcv_nxt) - 1;
 8237748:	e0bfe617 	ldw	r2,-104(fp)
 823774c:	11001717 	ldw	r4,92(r2)
 8237750:	e0bfe617 	ldw	r2,-104(fp)
 8237754:	10801617 	ldw	r2,88(r2)
 8237758:	2085c83a 	sub	r2,r4,r2
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
         so->so_oobmark = so->so_rcv.sb_cc +
 823775c:	1885883a 	add	r2,r3,r2
         (tp->rcv_up - tp->rcv_nxt) - 1;
 8237760:	10ffffc4 	addi	r3,r2,-1
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
         so->so_oobmark = so->so_rcv.sb_cc +
 8237764:	e0bfe817 	ldw	r2,-96(fp)
 8237768:	10c01a15 	stw	r3,104(r2)
         (tp->rcv_up - tp->rcv_nxt) - 1;
         if (so->so_oobmark == 0)
 823776c:	e0bfe817 	ldw	r2,-96(fp)
 8237770:	10801a17 	ldw	r2,104(r2)
 8237774:	1000061e 	bne	r2,zero,8237790 <tcp_input+0x1e10>
            so->so_state |= SS_RCVATMARK;
 8237778:	e0bfe817 	ldw	r2,-96(fp)
 823777c:	1080088b 	ldhu	r2,34(r2)
 8237780:	10801014 	ori	r2,r2,64
 8237784:	1007883a 	mov	r3,r2
 8237788:	e0bfe817 	ldw	r2,-96(fp)
 823778c:	10c0088d 	sth	r3,34(r2)
         sohasoutofband(so);
 8237790:	e13fe817 	ldw	r4,-96(fp)
 8237794:	8233a1c0 	call	8233a1c <sohasoutofband>
         tp->t_oobflags &= ~(TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 8237798:	e0bfe617 	ldw	r2,-104(fp)
 823779c:	10c02403 	ldbu	r3,144(r2)
 82377a0:	00bfff04 	movi	r2,-4
 82377a4:	1884703a 	and	r2,r3,r2
 82377a8:	1007883a 	mov	r3,r2
 82377ac:	e0bfe617 	ldw	r2,-104(fp)
 82377b0:	10c02405 	stb	r3,144(r2)
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 82377b4:	e0bff217 	ldw	r2,-56(fp)
 82377b8:	1100098b 	ldhu	r4,38(r2)
 82377bc:	e0bff217 	ldw	r2,-56(fp)
 82377c0:	10c0028b 	ldhu	r3,10(r2)
 82377c4:	20bfffcc 	andi	r2,r4,65535
 82377c8:	18ffffcc 	andi	r3,r3,65535
 82377cc:	18801436 	bltu	r3,r2,8237820 <tcp_input+0x1ea0>
#ifdef SO_OOBINLINE
       && (so->so_options & SO_OOBINLINE) == 0
 82377d0:	e0bfe817 	ldw	r2,-96(fp)
 82377d4:	10800417 	ldw	r2,16(r2)
 82377d8:	1080400c 	andi	r2,r2,256
 82377dc:	1000101e 	bne	r2,zero,8237820 <tcp_input+0x1ea0>
#endif
       )
      {
         tcp_pulloutofband(so, ti, m);
 82377e0:	e1bffe17 	ldw	r6,-8(fp)
 82377e4:	e17ff217 	ldw	r5,-56(fp)
 82377e8:	e13fe817 	ldw	r4,-96(fp)
 82377ec:	8237e380 	call	8237e38 <tcp_pulloutofband>
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 82377f0:	00000b06 	br	8237820 <tcp_input+0x1ea0>
      /*
       * If no out of band data is expected,
       * pull receive urgent pointer along
       * with the receive window.
       */
   if (SEQ_GT(tp->rcv_nxt, tp->rcv_up))
 82377f4:	e0bfe617 	ldw	r2,-104(fp)
 82377f8:	10c01617 	ldw	r3,88(r2)
 82377fc:	e0bfe617 	ldw	r2,-104(fp)
 8237800:	10801717 	ldw	r2,92(r2)
 8237804:	1885c83a 	sub	r2,r3,r2
 8237808:	0080060e 	bge	zero,r2,8237824 <tcp_input+0x1ea4>
      tp->rcv_up = tp->rcv_nxt;
 823780c:	e0bfe617 	ldw	r2,-104(fp)
 8237810:	10c01617 	ldw	r3,88(r2)
 8237814:	e0bfe617 	ldw	r2,-104(fp)
 8237818:	10c01715 	stw	r3,92(r2)
 823781c:	00000106 	br	8237824 <tcp_input+0x1ea4>
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 8237820:	0001883a 	nop
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 8237824:	e0bff217 	ldw	r2,-56(fp)
 8237828:	1080028b 	ldhu	r2,10(r2)
 823782c:	10bfffcc 	andi	r2,r2,65535
 8237830:	1000031e 	bne	r2,zero,8237840 <tcp_input+0x1ec0>
 8237834:	e0bfe717 	ldw	r2,-100(fp)
 8237838:	1080004c 	andi	r2,r2,1
 823783c:	10005e26 	beq	r2,zero,82379b8 <tcp_input+0x2038>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 8237840:	e0bfe617 	ldw	r2,-104(fp)
 8237844:	10800217 	ldw	r2,8(r2)
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 8237848:	10800288 	cmpgei	r2,r2,10
 823784c:	10005a1e 	bne	r2,zero,82379b8 <tcp_input+0x2038>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 8237850:	e0bff217 	ldw	r2,-56(fp)
 8237854:	10c00617 	ldw	r3,24(r2)
 8237858:	e0bfe617 	ldw	r2,-104(fp)
 823785c:	10801617 	ldw	r2,88(r2)
 8237860:	1880371e 	bne	r3,r2,8237940 <tcp_input+0x1fc0>
         (tp->seg_next == (struct tcpiphdr *)(tp) ) &&
 8237864:	e0bfe617 	ldw	r2,-104(fp)
 8237868:	10c00017 	ldw	r3,0(r2)
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 823786c:	e0bfe617 	ldw	r2,-104(fp)
 8237870:	1880331e 	bne	r3,r2,8237940 <tcp_input+0x1fc0>
         (tp->seg_next == (struct tcpiphdr *)(tp) ) &&
         (tp->t_state == TCPS_ESTABLISHED))
 8237874:	e0bfe617 	ldw	r2,-104(fp)
 8237878:	10800217 	ldw	r2,8(r2)
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
         (tp->seg_next == (struct tcpiphdr *)(tp) ) &&
 823787c:	10800118 	cmpnei	r2,r2,4
 8237880:	10002f1e 	bne	r2,zero,8237940 <tcp_input+0x1fc0>
         else
         {
            tp->t_flags |= TF_ACKNOW;
         }
#else    /* not DO_DELAY_ACKS */
            tp->t_flags |= TF_ACKNOW;
 8237884:	e0bfe617 	ldw	r2,-104(fp)
 8237888:	10800b0b 	ldhu	r2,44(r2)
 823788c:	10800054 	ori	r2,r2,1
 8237890:	1007883a 	mov	r3,r2
 8237894:	e0bfe617 	ldw	r2,-104(fp)
 8237898:	10c00b0d 	sth	r3,44(r2)
#endif   /* DO_DELAY_ACKS */

         tp->rcv_nxt += ti->ti_len;
 823789c:	e0bfe617 	ldw	r2,-104(fp)
 82378a0:	10c01617 	ldw	r3,88(r2)
 82378a4:	e0bff217 	ldw	r2,-56(fp)
 82378a8:	1080028b 	ldhu	r2,10(r2)
 82378ac:	10bfffcc 	andi	r2,r2,65535
 82378b0:	1887883a 	add	r3,r3,r2
 82378b4:	e0bfe617 	ldw	r2,-104(fp)
 82378b8:	10c01615 	stw	r3,88(r2)
         tiflags = ti->ti_flags & TH_FIN;
 82378bc:	e0bff217 	ldw	r2,-56(fp)
 82378c0:	10800843 	ldbu	r2,33(r2)
 82378c4:	10803fcc 	andi	r2,r2,255
 82378c8:	1080004c 	andi	r2,r2,1
 82378cc:	e0bfe715 	stw	r2,-100(fp)
         tcpstat.tcps_rcvpack++;
 82378d0:	008209b4 	movhi	r2,2086
 82378d4:	10b98b04 	addi	r2,r2,-6612
 82378d8:	10801a17 	ldw	r2,104(r2)
 82378dc:	10c00044 	addi	r3,r2,1
 82378e0:	008209b4 	movhi	r2,2086
 82378e4:	10b98b04 	addi	r2,r2,-6612
 82378e8:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 82378ec:	008209b4 	movhi	r2,2086
 82378f0:	10b98b04 	addi	r2,r2,-6612
 82378f4:	10c01b17 	ldw	r3,108(r2)
 82378f8:	e0bff217 	ldw	r2,-56(fp)
 82378fc:	1080028b 	ldhu	r2,10(r2)
 8237900:	10bfffcc 	andi	r2,r2,65535
 8237904:	1887883a 	add	r3,r3,r2
 8237908:	008209b4 	movhi	r2,2086
 823790c:	10b98b04 	addi	r2,r2,-6612
 8237910:	10c01b15 	stw	r3,108(r2)
         sbappend(&so->so_rcv, (m));
 8237914:	e0bfe817 	ldw	r2,-96(fp)
 8237918:	10800a04 	addi	r2,r2,40
 823791c:	e17ffe17 	ldw	r5,-8(fp)
 8237920:	1009883a 	mov	r4,r2
 8237924:	82343f40 	call	82343f4 <sbappend>
         sorwakeup(so);
 8237928:	e0bfe817 	ldw	r2,-96(fp)
 823792c:	10800a04 	addi	r2,r2,40
 8237930:	100b883a 	mov	r5,r2
 8237934:	e13fe817 	ldw	r4,-96(fp)
 8237938:	82342440 	call	8234244 <sbwakeup>
 823793c:	00000b06 	br	823796c <tcp_input+0x1fec>
#endif /* TCP_SACK */
      }
      else     /* received out of sequence segment */
      {
         /* Drop it in the reassmbly queue */
         tiflags = tcp_reass(tp, ti, m);
 8237940:	e1bffe17 	ldw	r6,-8(fp)
 8237944:	e17ff217 	ldw	r5,-56(fp)
 8237948:	e13fe617 	ldw	r4,-104(fp)
 823794c:	82355700 	call	8235570 <tcp_reass>
 8237950:	e0bfe715 	stw	r2,-100(fp)
         tp->t_flags |= TF_ACKNOW;
 8237954:	e0bfe617 	ldw	r2,-104(fp)
 8237958:	10800b0b 	ldhu	r2,44(r2)
 823795c:	10800054 	ori	r2,r2,1
 8237960:	1007883a 	mov	r3,r2
 8237964:	e0bfe617 	ldw	r2,-104(fp)
 8237968:	10c00b0d 	sth	r3,44(r2)
      /*
       * Note the amount of data that peer has sent into
       * our window, in order to estimate the sender's
       * buffer size.
       */
      len = (int)(so->so_rcv.sb_hiwat - (tp->rcv_adv - tp->rcv_nxt));
 823796c:	e0bfe817 	ldw	r2,-96(fp)
 8237970:	10c00b17 	ldw	r3,44(r2)
 8237974:	e0bfe617 	ldw	r2,-104(fp)
 8237978:	11001617 	ldw	r4,88(r2)
 823797c:	e0bfe617 	ldw	r2,-104(fp)
 8237980:	10801917 	ldw	r2,100(r2)
 8237984:	2085c83a 	sub	r2,r4,r2
 8237988:	1885883a 	add	r2,r3,r2
 823798c:	e0bffc15 	stw	r2,-16(fp)
      if (len > (int)tp->max_rcvd)
 8237990:	e0bfe617 	ldw	r2,-104(fp)
 8237994:	10802217 	ldw	r2,136(r2)
 8237998:	1007883a 	mov	r3,r2
 823799c:	e0bffc17 	ldw	r2,-16(fp)
 82379a0:	18800b0e 	bge	r3,r2,82379d0 <tcp_input+0x2050>
         tp->max_rcvd = (u_short)len;
 82379a4:	e0bffc17 	ldw	r2,-16(fp)
 82379a8:	10ffffcc 	andi	r3,r2,65535
 82379ac:	e0bfe617 	ldw	r2,-104(fp)
 82379b0:	10c02215 	stw	r3,136(r2)
       * Note the amount of data that peer has sent into
       * our window, in order to estimate the sender's
       * buffer size.
       */
      len = (int)(so->so_rcv.sb_hiwat - (tp->rcv_adv - tp->rcv_nxt));
      if (len > (int)tp->max_rcvd)
 82379b4:	00000606 	br	82379d0 <tcp_input+0x2050>
      }
#endif   /* TCP_ZEROCOPY */
   } 
   else
   {
      m_freem(m);
 82379b8:	e13ffe17 	ldw	r4,-8(fp)
 82379bc:	822e6380 	call	822e638 <m_freem>
      tiflags &= ~TH_FIN;
 82379c0:	e0ffe717 	ldw	r3,-100(fp)
 82379c4:	00bfff84 	movi	r2,-2
 82379c8:	1884703a 	and	r2,r3,r2
 82379cc:	e0bfe715 	stw	r2,-100(fp)

   /*
    * If FIN is received ACK the FIN and let the user know
    * that the connection is closing.
    */
   if (tiflags & TH_FIN) 
 82379d0:	e0bfe717 	ldw	r2,-100(fp)
 82379d4:	1080004c 	andi	r2,r2,1
 82379d8:	10003f26 	beq	r2,zero,8237ad8 <tcp_input+0x2158>
   {
      if (TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 82379dc:	e0bfe617 	ldw	r2,-104(fp)
 82379e0:	10800217 	ldw	r2,8(r2)
 82379e4:	10800288 	cmpgei	r2,r2,10
 82379e8:	10000d1e 	bne	r2,zero,8237a20 <tcp_input+0x20a0>
      {
         socantrcvmore(so);
 82379ec:	e13fe817 	ldw	r4,-96(fp)
 82379f0:	82341440 	call	8234144 <socantrcvmore>
         tp->t_flags |= TF_ACKNOW;
 82379f4:	e0bfe617 	ldw	r2,-104(fp)
 82379f8:	10800b0b 	ldhu	r2,44(r2)
 82379fc:	10800054 	ori	r2,r2,1
 8237a00:	1007883a 	mov	r3,r2
 8237a04:	e0bfe617 	ldw	r2,-104(fp)
 8237a08:	10c00b0d 	sth	r3,44(r2)
         tp->rcv_nxt++;
 8237a0c:	e0bfe617 	ldw	r2,-104(fp)
 8237a10:	10801617 	ldw	r2,88(r2)
 8237a14:	10c00044 	addi	r3,r2,1
 8237a18:	e0bfe617 	ldw	r2,-104(fp)
 8237a1c:	10c01615 	stw	r3,88(r2)
      }
      switch (tp->t_state) 
 8237a20:	e0bfe617 	ldw	r2,-104(fp)
 8237a24:	10800217 	ldw	r2,8(r2)
 8237a28:	10bfff44 	addi	r2,r2,-3
 8237a2c:	10c00228 	cmpgeui	r3,r2,8
 8237a30:	1800291e 	bne	r3,zero,8237ad8 <tcp_input+0x2158>
 8237a34:	100690ba 	slli	r3,r2,2
 8237a38:	008208f4 	movhi	r2,2083
 8237a3c:	109e9304 	addi	r2,r2,31308
 8237a40:	1885883a 	add	r2,r3,r2
 8237a44:	10800017 	ldw	r2,0(r2)
 8237a48:	1000683a 	jmp	r2
 8237a4c:	08237a6c 	andhi	zero,at,36329
 8237a50:	08237a6c 	andhi	zero,at,36329
 8237a54:	08237ad8 	cmpnei	zero,at,-29205
 8237a58:	08237a7c 	xorhi	zero,at,36329
 8237a5c:	08237ad8 	cmpnei	zero,at,-29205
 8237a60:	08237ad8 	cmpnei	zero,at,-29205
 8237a64:	08237a8c 	andi	zero,at,36330
 8237a68:	08237ac0 	call	8237ac <OSCtxSw_SWITCH_PC+0x82376c>
       * In SYN_RECEIVED and ESTABLISHED STATES
       * enter the CLOSE_WAIT state.
       */
      case TCPS_SYN_RECEIVED:
      case TCPS_ESTABLISHED:
         tp->t_state = TCPS_CLOSE_WAIT;
 8237a6c:	e0bfe617 	ldw	r2,-104(fp)
 8237a70:	00c00144 	movi	r3,5
 8237a74:	10c00215 	stw	r3,8(r2)
         break;
 8237a78:	00001706 	br	8237ad8 <tcp_input+0x2158>
       /*
       * If still in FIN_WAIT_1 STATE FIN has not been acked so
       * enter the CLOSING state.
       */
      case TCPS_FIN_WAIT_1:
         tp->t_state = TCPS_CLOSING;
 8237a7c:	e0bfe617 	ldw	r2,-104(fp)
 8237a80:	00c001c4 	movi	r3,7
 8237a84:	10c00215 	stw	r3,8(r2)
         break;
 8237a88:	00001306 	br	8237ad8 <tcp_input+0x2158>
       * In FIN_WAIT_2 state enter the TIME_WAIT state,
       * starting the time-wait timer, turning off the other 
       * standard timers.
       */
      case TCPS_FIN_WAIT_2:
         tp->t_state = TCPS_TIME_WAIT;
 8237a8c:	e0bfe617 	ldw	r2,-104(fp)
 8237a90:	00c00284 	movi	r3,10
 8237a94:	10c00215 	stw	r3,8(r2)
         tcp_canceltimers(tp);
 8237a98:	e13fe617 	ldw	r4,-104(fp)
 8237a9c:	823a0780 	call	823a078 <tcp_canceltimers>
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 8237aa0:	d0a03b17 	ldw	r2,-32532(gp)
 8237aa4:	1085883a 	add	r2,r2,r2
 8237aa8:	1007883a 	mov	r3,r2
 8237aac:	e0bfe617 	ldw	r2,-104(fp)
 8237ab0:	10c00615 	stw	r3,24(r2)
         soisdisconnected(so);
 8237ab4:	e13fe817 	ldw	r4,-96(fp)
 8237ab8:	8233c740 	call	8233c74 <soisdisconnected>
         break;
 8237abc:	00000606 	br	8237ad8 <tcp_input+0x2158>

      /*
       * In TIME_WAIT state restart the 2 MSL time_wait timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 8237ac0:	d0a03b17 	ldw	r2,-32532(gp)
 8237ac4:	1085883a 	add	r2,r2,r2
 8237ac8:	1007883a 	mov	r3,r2
 8237acc:	e0bfe617 	ldw	r2,-104(fp)
 8237ad0:	10c00615 	stw	r3,24(r2)
         break;
 8237ad4:	0001883a 	nop
    ostate, tp, &tcp_saveti);
#endif
   /*
    * Return any desired output.
    */
   if (needoutput || (tp->t_flags & TF_ACKNOW))
 8237ad8:	e0bfeb17 	ldw	r2,-84(fp)
 8237adc:	1000051e 	bne	r2,zero,8237af4 <tcp_input+0x2174>
 8237ae0:	e0bfe617 	ldw	r2,-104(fp)
 8237ae4:	10800b0b 	ldhu	r2,44(r2)
 8237ae8:	10bfffcc 	andi	r2,r2,65535
 8237aec:	1080004c 	andi	r2,r2,1
 8237af0:	10006526 	beq	r2,zero,8237c88 <tcp_input+0x2308>
      (void) tcp_output(tp);
 8237af4:	e13fe617 	ldw	r4,-104(fp)
 8237af8:	82383000 	call	8238300 <tcp_output>
   return;
 8237afc:	00006206 	br	8237c88 <tcp_input+0x2308>
dropafterack:
   /*
    * Generate an ACK dropping incoming segment if it occupies
    * sequence space, where the ACK reflects our state.
    */
   if (tiflags & TH_RST)
 8237b00:	e0bfe717 	ldw	r2,-100(fp)
 8237b04:	1080010c 	andi	r2,r2,4
 8237b08:	10000326 	beq	r2,zero,8237b18 <tcp_input+0x2198>
      GOTO_DROP;
 8237b0c:	0081a904 	movi	r2,1700
 8237b10:	d0a0b215 	stw	r2,-32056(gp)
 8237b14:	00004c06 	br	8237c48 <tcp_input+0x22c8>
   m_freem (m);
 8237b18:	e13ffe17 	ldw	r4,-8(fp)
 8237b1c:	822e6380 	call	822e638 <m_freem>
   tp->t_flags |= TF_ACKNOW;
 8237b20:	e0bfe617 	ldw	r2,-104(fp)
 8237b24:	10800b0b 	ldhu	r2,44(r2)
 8237b28:	10800054 	ori	r2,r2,1
 8237b2c:	1007883a 	mov	r3,r2
 8237b30:	e0bfe617 	ldw	r2,-104(fp)
 8237b34:	10c00b0d 	sth	r3,44(r2)
   (void) tcp_output (tp);
 8237b38:	e13fe617 	ldw	r4,-104(fp)
 8237b3c:	82383000 	call	8238300 <tcp_output>
   return;
 8237b40:	00005606 	br	8237c9c <tcp_input+0x231c>

dropwithreset:
   TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 8237b44:	008209b4 	movhi	r2,2086
 8237b48:	10b95d04 	addi	r2,r2,-6796
 8237b4c:	10800d17 	ldw	r2,52(r2)
 8237b50:	10c00044 	addi	r3,r2,1
 8237b54:	008209b4 	movhi	r2,2086
 8237b58:	10b95d04 	addi	r2,r2,-6796
 8237b5c:	10c00d15 	stw	r3,52(r2)
   if (om) 
 8237b60:	e0bfe517 	ldw	r2,-108(fp)
 8237b64:	10000326 	beq	r2,zero,8237b74 <tcp_input+0x21f4>
   {
      (void) m_free(om);
 8237b68:	e13fe517 	ldw	r4,-108(fp)
 8237b6c:	822e5300 	call	822e530 <m_free>
      om = 0;
 8237b70:	e03fe515 	stw	zero,-108(fp)
   }

   /* Don't reset resets */
   if (tiflags & TH_RST)
 8237b74:	e0bfe717 	ldw	r2,-100(fp)
 8237b78:	1080010c 	andi	r2,r2,4
 8237b7c:	10000326 	beq	r2,zero,8237b8c <tcp_input+0x220c>
      GOTO_DROP;
 8237b80:	0081ad04 	movi	r2,1716
 8237b84:	d0a0b215 	stw	r2,-32056(gp)
 8237b88:	00002f06 	br	8237c48 <tcp_input+0x22c8>
    * Generate a RST, dropping incoming segment.
    * Make ACK acceptable to originator of segment.
    * Don't bother to respond if destination was broadcast.
    */
#ifdef IP_V4
   if (in_broadcast(ti->ti_dst.s_addr))
 8237b8c:	e0bff217 	ldw	r2,-56(fp)
 8237b90:	10800417 	ldw	r2,16(r2)
 8237b94:	1009883a 	mov	r4,r2
 8237b98:	822f5840 	call	822f584 <in_broadcast>
 8237b9c:	10000326 	beq	r2,zero,8237bac <tcp_input+0x222c>
      GOTO_DROP;
 8237ba0:	0081af44 	movi	r2,1725
 8237ba4:	d0a0b215 	stw	r2,-32056(gp)
 8237ba8:	00002706 	br	8237c48 <tcp_input+0x22c8>
      IP6CPY(&(m->pkt->ip6_hdr->ip_src), &ip6_src);
      IP6CPY(&(m->pkt->ip6_hdr->ip_dest), &ip6_dst);
   }
#endif   /* IP_V6 */

   if (tiflags & TH_ACK)
 8237bac:	e0bfe717 	ldw	r2,-100(fp)
 8237bb0:	1080040c 	andi	r2,r2,16
 8237bb4:	10000c26 	beq	r2,zero,8237be8 <tcp_input+0x2268>
      tcp_respond (tp, ti, (tcp_seq)0, ti->ti_ack, TH_RST, m);
 8237bb8:	e0bff217 	ldw	r2,-56(fp)
 8237bbc:	10c00717 	ldw	r3,28(r2)
 8237bc0:	e0bffe17 	ldw	r2,-8(fp)
 8237bc4:	d8800115 	stw	r2,4(sp)
 8237bc8:	00800104 	movi	r2,4
 8237bcc:	d8800015 	stw	r2,0(sp)
 8237bd0:	180f883a 	mov	r7,r3
 8237bd4:	000d883a 	mov	r6,zero
 8237bd8:	e17ff217 	ldw	r5,-56(fp)
 8237bdc:	e13fe617 	ldw	r4,-104(fp)
 8237be0:	82396280 	call	8239628 <tcp_respond>
 8237be4:	00001306 	br	8237c34 <tcp_input+0x22b4>
   else
   {
      if (tiflags & TH_SYN)
 8237be8:	e0bfe717 	ldw	r2,-100(fp)
 8237bec:	1080008c 	andi	r2,r2,2
 8237bf0:	10000526 	beq	r2,zero,8237c08 <tcp_input+0x2288>
         ti->ti_seq++;
 8237bf4:	e0bff217 	ldw	r2,-56(fp)
 8237bf8:	10800617 	ldw	r2,24(r2)
 8237bfc:	10c00044 	addi	r3,r2,1
 8237c00:	e0bff217 	ldw	r2,-56(fp)
 8237c04:	10c00615 	stw	r3,24(r2)
      tcp_respond(tp, ti, ti->ti_seq, (tcp_seq)0, TH_RST|TH_ACK, m);
 8237c08:	e0bff217 	ldw	r2,-56(fp)
 8237c0c:	10c00617 	ldw	r3,24(r2)
 8237c10:	e0bffe17 	ldw	r2,-8(fp)
 8237c14:	d8800115 	stw	r2,4(sp)
 8237c18:	00800504 	movi	r2,20
 8237c1c:	d8800015 	stw	r2,0(sp)
 8237c20:	000f883a 	mov	r7,zero
 8237c24:	180d883a 	mov	r6,r3
 8237c28:	e17ff217 	ldw	r5,-56(fp)
 8237c2c:	e13fe617 	ldw	r4,-104(fp)
 8237c30:	82396280 	call	8239628 <tcp_respond>
   }
   /* destroy temporarily created socket */
   if (dropsocket)
 8237c34:	e0bfec17 	ldw	r2,-80(fp)
 8237c38:	10001526 	beq	r2,zero,8237c90 <tcp_input+0x2310>
      (void) soabort(so);
 8237c3c:	e13fe817 	ldw	r4,-96(fp)
 8237c40:	82320d40 	call	82320d4 <soabort>
   return;
 8237c44:	00001206 	br	8237c90 <tcp_input+0x2310>

drop:
   if (om)
 8237c48:	e0bfe517 	ldw	r2,-108(fp)
 8237c4c:	10000226 	beq	r2,zero,8237c58 <tcp_input+0x22d8>
      (void) m_free(om);
 8237c50:	e13fe517 	ldw	r4,-108(fp)
 8237c54:	822e5300 	call	822e530 <m_free>
#ifdef DO_TCPTRACE
   if (tp && (tp->t_inpcb->inp_socket->so_options & SO_DEBUG))
      tcp_trace("drop: state %d, tcpcb: %x, saveti: %x",
    ostate, tp, &tcp_saveti);
#endif
   m_freem(m);
 8237c58:	e13ffe17 	ldw	r4,-8(fp)
 8237c5c:	822e6380 	call	822e638 <m_freem>
   /* destroy temporarily created socket */
   if (dropsocket)
 8237c60:	e0bfec17 	ldw	r2,-80(fp)
 8237c64:	10000c26 	beq	r2,zero,8237c98 <tcp_input+0x2318>
      (void) soabort(so);
 8237c68:	e13fe817 	ldw	r4,-96(fp)
 8237c6c:	82320d40 	call	82320d4 <soabort>
   return;
 8237c70:	0001883a 	nop
 8237c74:	00000806 	br	8237c98 <tcp_input+0x2318>
            /* If there is more data in the send buffer, and some is
             * still unsent, then call tcp_output() to try to send it
             */
            if (so->so_snd.sb_cc > (tp->snd_nxt - tp->snd_una))
               (void) tcp_output(tp);
            return;
 8237c78:	0001883a 	nop
 8237c7c:	00000706 	br	8237c9c <tcp_input+0x231c>
            tp->t_flags |= TF_ACKNOW;
            tp->t_flags &= ~TF_DELACK;
            tcp_output(tp);   /* send the ack now... */
         }

         return;
 8237c80:	0001883a 	nop
 8237c84:	00000506 	br	8237c9c <tcp_input+0x231c>
   /*
    * Return any desired output.
    */
   if (needoutput || (tp->t_flags & TF_ACKNOW))
      (void) tcp_output(tp);
   return;
 8237c88:	0001883a 	nop
 8237c8c:	00000306 	br	8237c9c <tcp_input+0x231c>
      tcp_respond(tp, ti, ti->ti_seq, (tcp_seq)0, TH_RST|TH_ACK, m);
   }
   /* destroy temporarily created socket */
   if (dropsocket)
      (void) soabort(so);
   return;
 8237c90:	0001883a 	nop
 8237c94:	00000106 	br	8237c9c <tcp_input+0x231c>
#endif
   m_freem(m);
   /* destroy temporarily created socket */
   if (dropsocket)
      (void) soabort(so);
   return;
 8237c98:	0001883a 	nop
}
 8237c9c:	e037883a 	mov	sp,fp
 8237ca0:	dfc00117 	ldw	ra,4(sp)
 8237ca4:	df000017 	ldw	fp,0(sp)
 8237ca8:	dec00204 	addi	sp,sp,8
 8237cac:	f800283a 	ret

08237cb0 <tcp_dooptions>:

void
tcp_dooptions(struct tcpcb * tp, 
   struct mbuf *  om,
   struct tcpiphdr * ti)
{
 8237cb0:	defff404 	addi	sp,sp,-48
 8237cb4:	dfc00b15 	stw	ra,44(sp)
 8237cb8:	df000a15 	stw	fp,40(sp)
 8237cbc:	dc000915 	stw	r16,36(sp)
 8237cc0:	df000a04 	addi	fp,sp,40
 8237cc4:	e13ffc15 	stw	r4,-16(fp)
 8237cc8:	e17ffd15 	stw	r5,-12(fp)
 8237ccc:	e1bffe15 	stw	r6,-8(fp)
   u_char * cp;   /* pointer into option buffer */
   int   opt;     /* current option code */
   int   optlen;  /* length of current option */
   int   cnt;     /* byte count left in header */
   struct socket * so = tp->t_inpcb->inp_socket;
 8237cd0:	e0bffc17 	ldw	r2,-16(fp)
 8237cd4:	10800d17 	ldw	r2,52(r2)
 8237cd8:	10800817 	ldw	r2,32(r2)
 8237cdc:	e0bff915 	stw	r2,-28(fp)
#ifdef TCP_TIMESTAMP
   int   gotstamp = FALSE;    /* TRUE if we got a timestamp */
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
 8237ce0:	e0bffd17 	ldw	r2,-12(fp)
 8237ce4:	10800317 	ldw	r2,12(r2)
 8237ce8:	e0bff615 	stw	r2,-40(fp)
   cnt = om->m_len;
 8237cec:	e0bffd17 	ldw	r2,-12(fp)
 8237cf0:	10800217 	ldw	r2,8(r2)
 8237cf4:	e0bff815 	stw	r2,-32(fp)
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 8237cf8:	00004006 	br	8237dfc <tcp_dooptions+0x14c>
   {
      opt = cp[0];
 8237cfc:	e0bff617 	ldw	r2,-40(fp)
 8237d00:	10800003 	ldbu	r2,0(r2)
 8237d04:	10803fcc 	andi	r2,r2,255
 8237d08:	e0bffa15 	stw	r2,-24(fp)
      if (opt == TCPOPT_EOL)
 8237d0c:	e0bffa17 	ldw	r2,-24(fp)
 8237d10:	10003d26 	beq	r2,zero,8237e08 <tcp_dooptions+0x158>
         break;
      if (opt == TCPOPT_NOP)
 8237d14:	e0bffa17 	ldw	r2,-24(fp)
 8237d18:	10800058 	cmpnei	r2,r2,1
 8237d1c:	1000031e 	bne	r2,zero,8237d2c <tcp_dooptions+0x7c>
         optlen = 1;
 8237d20:	00800044 	movi	r2,1
 8237d24:	e0bff715 	stw	r2,-36(fp)
 8237d28:	00000706 	br	8237d48 <tcp_dooptions+0x98>
      else 
      {
         optlen = cp[1];
 8237d2c:	e0bff617 	ldw	r2,-40(fp)
 8237d30:	10800044 	addi	r2,r2,1
 8237d34:	10800003 	ldbu	r2,0(r2)
 8237d38:	10803fcc 	andi	r2,r2,255
 8237d3c:	e0bff715 	stw	r2,-36(fp)
         if (optlen <= 0)
 8237d40:	e0bff717 	ldw	r2,-36(fp)
 8237d44:	0080320e 	bge	zero,r2,8237e10 <tcp_dooptions+0x160>
            break;
      }

      switch (opt) 
 8237d48:	e0bffa17 	ldw	r2,-24(fp)
 8237d4c:	108000a0 	cmpeqi	r2,r2,2
 8237d50:	1000011e 	bne	r2,zero,8237d58 <tcp_dooptions+0xa8>
         }
         break;
#endif   /* TCP_TIMESTAMP */

      default:
         break;
 8237d54:	00002106 	br	8237ddc <tcp_dooptions+0x12c>
      switch (opt) 
      {
      case TCPOPT_MAXSEG:
      {
         u_short mssval;
         if (optlen != 4)
 8237d58:	e0bff717 	ldw	r2,-36(fp)
 8237d5c:	10800120 	cmpeqi	r2,r2,4
 8237d60:	10001b26 	beq	r2,zero,8237dd0 <tcp_dooptions+0x120>
            continue;
         if (!(ti->ti_flags & TH_SYN))    /* MSS only on SYN */
 8237d64:	e0bffe17 	ldw	r2,-8(fp)
 8237d68:	10800843 	ldbu	r2,33(r2)
 8237d6c:	10803fcc 	andi	r2,r2,255
 8237d70:	1080008c 	andi	r2,r2,2
 8237d74:	10001826 	beq	r2,zero,8237dd8 <tcp_dooptions+0x128>
            continue;
         mssval = *(u_short *)(cp + 2);
 8237d78:	e0bff617 	ldw	r2,-40(fp)
 8237d7c:	1080008b 	ldhu	r2,2(r2)
 8237d80:	e0bffb0d 	sth	r2,-20(fp)
         mssval = ntohs(mssval);
 8237d84:	e0bffb0b 	ldhu	r2,-20(fp)
 8237d88:	1004d23a 	srli	r2,r2,8
 8237d8c:	1007883a 	mov	r3,r2
 8237d90:	e0bffb0b 	ldhu	r2,-20(fp)
 8237d94:	1004923a 	slli	r2,r2,8
 8237d98:	1884b03a 	or	r2,r3,r2
 8237d9c:	e0bffb0d 	sth	r2,-20(fp)
         tp->t_maxseg = (u_short)MIN(mssval, (u_short)tcp_mss(so));
 8237da0:	e43ffb0b 	ldhu	r16,-20(fp)
 8237da4:	e13ff917 	ldw	r4,-28(fp)
 8237da8:	82382080 	call	8238208 <tcp_mss>
 8237dac:	10bfffcc 	andi	r2,r2,65535
 8237db0:	1400030e 	bge	r2,r16,8237dc0 <tcp_dooptions+0x110>
 8237db4:	e13ff917 	ldw	r4,-28(fp)
 8237db8:	82382080 	call	8238208 <tcp_mss>
 8237dbc:	00000106 	br	8237dc4 <tcp_dooptions+0x114>
 8237dc0:	e0bffb0b 	ldhu	r2,-20(fp)
 8237dc4:	e0fffc17 	ldw	r3,-16(fp)
 8237dc8:	18800a0d 	sth	r2,40(r3)
         break;
 8237dcc:	00000306 	br	8237ddc <tcp_dooptions+0x12c>
      {
      case TCPOPT_MAXSEG:
      {
         u_short mssval;
         if (optlen != 4)
            continue;
 8237dd0:	0001883a 	nop
 8237dd4:	00000106 	br	8237ddc <tcp_dooptions+0x12c>
         if (!(ti->ti_flags & TH_SYN))    /* MSS only on SYN */
            continue;
 8237dd8:	0001883a 	nop
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
   cnt = om->m_len;
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 8237ddc:	e0fff817 	ldw	r3,-32(fp)
 8237de0:	e0bff717 	ldw	r2,-36(fp)
 8237de4:	1885c83a 	sub	r2,r3,r2
 8237de8:	e0bff815 	stw	r2,-32(fp)
 8237dec:	e0bff717 	ldw	r2,-36(fp)
 8237df0:	e0fff617 	ldw	r3,-40(fp)
 8237df4:	1885883a 	add	r2,r3,r2
 8237df8:	e0bff615 	stw	r2,-40(fp)
 8237dfc:	e0bff817 	ldw	r2,-32(fp)
 8237e00:	00bfbe16 	blt	zero,r2,8237cfc <tcp_dooptions+0x4c>
 8237e04:	00000306 	br	8237e14 <tcp_dooptions+0x164>
   {
      opt = cp[0];
      if (opt == TCPOPT_EOL)
         break;
 8237e08:	0001883a 	nop
 8237e0c:	00000106 	br	8237e14 <tcp_dooptions+0x164>
         optlen = 1;
      else 
      {
         optlen = cp[1];
         if (optlen <= 0)
            break;
 8237e10:	0001883a 	nop

      default:
         break;
      }
   }
   (void) m_free(om);
 8237e14:	e13ffd17 	ldw	r4,-12(fp)
 8237e18:	822e5300 	call	822e530 <m_free>
      if(!gotstamp)
         tp->t_flags &= ~TF_TIMESTAMP;
   }
#endif /* TCP_TIMESTAMP */

   return;
 8237e1c:	0001883a 	nop
}
 8237e20:	e6ffff04 	addi	sp,fp,-4
 8237e24:	dfc00217 	ldw	ra,8(sp)
 8237e28:	df000117 	ldw	fp,4(sp)
 8237e2c:	dc000017 	ldw	r16,0(sp)
 8237e30:	dec00304 	addi	sp,sp,12
 8237e34:	f800283a 	ret

08237e38 <tcp_pulloutofband>:

void
tcp_pulloutofband(struct socket * so, 
   struct tcpiphdr * ti,
   struct mbuf *  m)
{
 8237e38:	defff804 	addi	sp,sp,-32
 8237e3c:	dfc00715 	stw	ra,28(sp)
 8237e40:	df000615 	stw	fp,24(sp)
 8237e44:	df000604 	addi	fp,sp,24
 8237e48:	e13ffd15 	stw	r4,-12(fp)
 8237e4c:	e17ffe15 	stw	r5,-8(fp)
 8237e50:	e1bfff15 	stw	r6,-4(fp)
   int   cnt   =  ti->ti_urp  -  1;
 8237e54:	e0bffe17 	ldw	r2,-8(fp)
 8237e58:	1080098b 	ldhu	r2,38(r2)
 8237e5c:	10bfffcc 	andi	r2,r2,65535
 8237e60:	10bfffc4 	addi	r2,r2,-1
 8237e64:	e0bffa15 	stw	r2,-24(fp)

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 8237e68:	00003206 	br	8237f34 <tcp_pulloutofband+0xfc>
   {
      if (m->m_len > (unsigned)cnt) 
 8237e6c:	e0bfff17 	ldw	r2,-4(fp)
 8237e70:	10800217 	ldw	r2,8(r2)
 8237e74:	e0fffa17 	ldw	r3,-24(fp)
 8237e78:	1880242e 	bgeu	r3,r2,8237f0c <tcp_pulloutofband+0xd4>
      {
         char *   cp =  mtod(m,  char *) +  cnt;
 8237e7c:	e0bfff17 	ldw	r2,-4(fp)
 8237e80:	10c00317 	ldw	r3,12(r2)
 8237e84:	e0bffa17 	ldw	r2,-24(fp)
 8237e88:	1885883a 	add	r2,r3,r2
 8237e8c:	e0bffb15 	stw	r2,-20(fp)
         struct tcpcb * tp =  sototcpcb(so);
 8237e90:	e0bffd17 	ldw	r2,-12(fp)
 8237e94:	10800117 	ldw	r2,4(r2)
 8237e98:	10800917 	ldw	r2,36(r2)
 8237e9c:	e0bffc15 	stw	r2,-16(fp)

         tp->t_iobc = *cp;
 8237ea0:	e0bffb17 	ldw	r2,-20(fp)
 8237ea4:	10c00003 	ldbu	r3,0(r2)
 8237ea8:	e0bffc17 	ldw	r2,-16(fp)
 8237eac:	10c02445 	stb	r3,145(r2)
         tp->t_oobflags |= TCPOOB_HAVEDATA;
 8237eb0:	e0bffc17 	ldw	r2,-16(fp)
 8237eb4:	10802403 	ldbu	r2,144(r2)
 8237eb8:	10800054 	ori	r2,r2,1
 8237ebc:	1007883a 	mov	r3,r2
 8237ec0:	e0bffc17 	ldw	r2,-16(fp)
 8237ec4:	10c02405 	stb	r3,144(r2)
         MEMCPY(cp, cp+1, (unsigned)(m->m_len - cnt - 1));
 8237ec8:	e0bffb17 	ldw	r2,-20(fp)
 8237ecc:	11000044 	addi	r4,r2,1
 8237ed0:	e0bfff17 	ldw	r2,-4(fp)
 8237ed4:	10c00217 	ldw	r3,8(r2)
 8237ed8:	e0bffa17 	ldw	r2,-24(fp)
 8237edc:	1885c83a 	sub	r2,r3,r2
 8237ee0:	10bfffc4 	addi	r2,r2,-1
 8237ee4:	100d883a 	mov	r6,r2
 8237ee8:	200b883a 	mov	r5,r4
 8237eec:	e13ffb17 	ldw	r4,-20(fp)
 8237ef0:	8202f100 	call	8202f10 <memcpy>
         m->m_len--;
 8237ef4:	e0bfff17 	ldw	r2,-4(fp)
 8237ef8:	10800217 	ldw	r2,8(r2)
 8237efc:	10ffffc4 	addi	r3,r2,-1
 8237f00:	e0bfff17 	ldw	r2,-4(fp)
 8237f04:	10c00215 	stw	r3,8(r2)
         return;
 8237f08:	00001106 	br	8237f50 <tcp_pulloutofband+0x118>
      }
      cnt -= m->m_len;
 8237f0c:	e0fffa17 	ldw	r3,-24(fp)
 8237f10:	e0bfff17 	ldw	r2,-4(fp)
 8237f14:	10800217 	ldw	r2,8(r2)
 8237f18:	1885c83a 	sub	r2,r3,r2
 8237f1c:	e0bffa15 	stw	r2,-24(fp)
      m = m->m_next;
 8237f20:	e0bfff17 	ldw	r2,-4(fp)
 8237f24:	10800617 	ldw	r2,24(r2)
 8237f28:	e0bfff15 	stw	r2,-4(fp)
      if (m == 0)
 8237f2c:	e0bfff17 	ldw	r2,-4(fp)
 8237f30:	10000326 	beq	r2,zero,8237f40 <tcp_pulloutofband+0x108>
   struct mbuf *  m)
{
   int   cnt   =  ti->ti_urp  -  1;

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 8237f34:	e0bffa17 	ldw	r2,-24(fp)
 8237f38:	103fcc0e 	bge	r2,zero,8237e6c <tcp_pulloutofband+0x34>
 8237f3c:	00000106 	br	8237f44 <tcp_pulloutofband+0x10c>
         return;
      }
      cnt -= m->m_len;
      m = m->m_next;
      if (m == 0)
         break;
 8237f40:	0001883a 	nop
   }
   panic("tcp_pulloutofband");
 8237f44:	01020974 	movhi	r4,2085
 8237f48:	21039d04 	addi	r4,r4,3700
 8237f4c:	8228c480 	call	8228c48 <panic>
}
 8237f50:	e037883a 	mov	sp,fp
 8237f54:	dfc00117 	ldw	ra,4(sp)
 8237f58:	df000017 	ldw	fp,0(sp)
 8237f5c:	dec00204 	addi	sp,sp,8
 8237f60:	f800283a 	ret

08237f64 <tcp_xmit_timer>:
 * RETURNS: 
 */

void
tcp_xmit_timer(struct tcpcb * tp)
{
 8237f64:	defffb04 	addi	sp,sp,-20
 8237f68:	dfc00415 	stw	ra,16(sp)
 8237f6c:	df000315 	stw	fp,12(sp)
 8237f70:	df000304 	addi	fp,sp,12
 8237f74:	e13fff15 	stw	r4,-4(fp)
   int delta;
   int rtt;

#ifdef NPDEBUG
   if(tp->t_rttick == 0){ dtrap(); return; }
 8237f78:	e0bfff17 	ldw	r2,-4(fp)
 8237f7c:	10801e17 	ldw	r2,120(r2)
 8237f80:	1000021e 	bne	r2,zero,8237f8c <tcp_xmit_timer+0x28>
 8237f84:	822d5940 	call	822d594 <dtrap>
 8237f88:	00008806 	br	82381ac <tcp_xmit_timer+0x248>
#endif

   tcpstat.tcps_rttupdated++;
 8237f8c:	008209b4 	movhi	r2,2086
 8237f90:	10b98b04 	addi	r2,r2,-6612
 8237f94:	10800717 	ldw	r2,28(r2)
 8237f98:	10c00044 	addi	r3,r2,1
 8237f9c:	008209b4 	movhi	r2,2086
 8237fa0:	10b98b04 	addi	r2,r2,-6612
 8237fa4:	10c00715 	stw	r3,28(r2)

   /* get  this rtt. Convert from cticks to TCP slow ticks */
   rtt = (int)((cticks - tp->t_rttick) / (TPS/2));
 8237fa8:	d0e0a817 	ldw	r3,-32096(gp)
 8237fac:	e0bfff17 	ldw	r2,-4(fp)
 8237fb0:	10801e17 	ldw	r2,120(r2)
 8237fb4:	1887c83a 	sub	r3,r3,r2
 8237fb8:	00947b34 	movhi	r2,20972
 8237fbc:	10a147c4 	addi	r2,r2,-31457
 8237fc0:	1888383a 	mulxuu	r4,r3,r2
 8237fc4:	1885383a 	mul	r2,r3,r2
 8237fc8:	100b883a 	mov	r5,r2
 8237fcc:	200d883a 	mov	r6,r4
 8237fd0:	3004d13a 	srli	r2,r6,4
 8237fd4:	e0bffe15 	stw	r2,-8(fp)
   if(tp->t_srtt != 0)
 8237fd8:	e0bfff17 	ldw	r2,-4(fp)
 8237fdc:	10802017 	ldw	r2,128(r2)
 8237fe0:	10004626 	beq	r2,zero,82380fc <tcp_xmit_timer+0x198>
   {
      if(rtt == 0)      /* fast path for small round trip */
 8237fe4:	e0bffe17 	ldw	r2,-8(fp)
 8237fe8:	1000131e 	bne	r2,zero,8238038 <tcp_xmit_timer+0xd4>
      {
         /* if either the rtt or varience is over 1, reduce it. */
         if(tp->t_srtt > 1)
 8237fec:	e0bfff17 	ldw	r2,-4(fp)
 8237ff0:	10802017 	ldw	r2,128(r2)
 8237ff4:	10800090 	cmplti	r2,r2,2
 8237ff8:	1000051e 	bne	r2,zero,8238010 <tcp_xmit_timer+0xac>
            tp->t_srtt--;
 8237ffc:	e0bfff17 	ldw	r2,-4(fp)
 8238000:	10802017 	ldw	r2,128(r2)
 8238004:	10ffffc4 	addi	r3,r2,-1
 8238008:	e0bfff17 	ldw	r2,-4(fp)
 823800c:	10c02015 	stw	r3,128(r2)
         if(tp->t_rttvar > 1)
 8238010:	e0bfff17 	ldw	r2,-4(fp)
 8238014:	10802117 	ldw	r2,132(r2)
 8238018:	10800090 	cmplti	r2,r2,2
 823801c:	1000441e 	bne	r2,zero,8238130 <tcp_xmit_timer+0x1cc>
            tp->t_rttvar--;
 8238020:	e0bfff17 	ldw	r2,-4(fp)
 8238024:	10802117 	ldw	r2,132(r2)
 8238028:	10ffffc4 	addi	r3,r2,-1
 823802c:	e0bfff17 	ldw	r2,-4(fp)
 8238030:	10c02115 	stw	r3,132(r2)
 8238034:	00003e06 	br	8238130 <tcp_xmit_timer+0x1cc>
       * The following magic is equivalent
       * to the smoothing algorithm in rfc793
       * with an alpha of .875
       * (srtt = rtt/8 + srtt*7/8 in fixed point).
       */
      delta = ((rtt - 1) << 2) - (int)(tp->t_srtt >> 3);
 8238038:	e0bffe17 	ldw	r2,-8(fp)
 823803c:	10bfffc4 	addi	r2,r2,-1
 8238040:	1085883a 	add	r2,r2,r2
 8238044:	1085883a 	add	r2,r2,r2
 8238048:	1007883a 	mov	r3,r2
 823804c:	e0bfff17 	ldw	r2,-4(fp)
 8238050:	10802017 	ldw	r2,128(r2)
 8238054:	1005d0fa 	srai	r2,r2,3
 8238058:	1885c83a 	sub	r2,r3,r2
 823805c:	e0bffd15 	stw	r2,-12(fp)
      if ((tp->t_srtt += delta) <= 0)
 8238060:	e0bfff17 	ldw	r2,-4(fp)
 8238064:	10c02017 	ldw	r3,128(r2)
 8238068:	e0bffd17 	ldw	r2,-12(fp)
 823806c:	1887883a 	add	r3,r3,r2
 8238070:	e0bfff17 	ldw	r2,-4(fp)
 8238074:	10c02015 	stw	r3,128(r2)
 8238078:	e0bfff17 	ldw	r2,-4(fp)
 823807c:	10802017 	ldw	r2,128(r2)
 8238080:	00800316 	blt	zero,r2,8238090 <tcp_xmit_timer+0x12c>
         tp->t_srtt = 1;
 8238084:	e0bfff17 	ldw	r2,-4(fp)
 8238088:	00c00044 	movi	r3,1
 823808c:	10c02015 	stw	r3,128(r2)
       * (scaled by 4).  The following is equivalent
       * to rfc793 smoothing with an alpha of .75
       * (rttvar = rttvar*3/4 + |delta| / 4).
       * This replaces rfc793's wired-in beta.
       */
      if (delta < 0)
 8238090:	e0bffd17 	ldw	r2,-12(fp)
 8238094:	1000030e 	bge	r2,zero,82380a4 <tcp_xmit_timer+0x140>
         delta = -delta;
 8238098:	e0bffd17 	ldw	r2,-12(fp)
 823809c:	0085c83a 	sub	r2,zero,r2
 82380a0:	e0bffd15 	stw	r2,-12(fp)
      delta -= (short)(tp->t_rttvar >> 1);
 82380a4:	e0bfff17 	ldw	r2,-4(fp)
 82380a8:	10802117 	ldw	r2,132(r2)
 82380ac:	1005d07a 	srai	r2,r2,1
 82380b0:	10bfffcc 	andi	r2,r2,65535
 82380b4:	10a0001c 	xori	r2,r2,32768
 82380b8:	10a00004 	addi	r2,r2,-32768
 82380bc:	e0fffd17 	ldw	r3,-12(fp)
 82380c0:	1885c83a 	sub	r2,r3,r2
 82380c4:	e0bffd15 	stw	r2,-12(fp)
      if ((tp->t_rttvar += delta) <= 0)
 82380c8:	e0bfff17 	ldw	r2,-4(fp)
 82380cc:	10c02117 	ldw	r3,132(r2)
 82380d0:	e0bffd17 	ldw	r2,-12(fp)
 82380d4:	1887883a 	add	r3,r3,r2
 82380d8:	e0bfff17 	ldw	r2,-4(fp)
 82380dc:	10c02115 	stw	r3,132(r2)
 82380e0:	e0bfff17 	ldw	r2,-4(fp)
 82380e4:	10802117 	ldw	r2,132(r2)
 82380e8:	00801116 	blt	zero,r2,8238130 <tcp_xmit_timer+0x1cc>
         tp->t_rttvar = 1;
 82380ec:	e0bfff17 	ldw	r2,-4(fp)
 82380f0:	00c00044 	movi	r3,1
 82380f4:	10c02115 	stw	r3,132(r2)
 82380f8:	00000d06 	br	8238130 <tcp_xmit_timer+0x1cc>
       * No rtt measurement yet - use the
       * unsmoothed rtt.  Set the variance
       * to half the rtt (so our first
       * retransmit happens at 2*rtt)
       */
      if(rtt < 1)
 82380fc:	e0bffe17 	ldw	r2,-8(fp)
 8238100:	00800216 	blt	zero,r2,823810c <tcp_xmit_timer+0x1a8>
         rtt = 1;
 8238104:	00800044 	movi	r2,1
 8238108:	e0bffe15 	stw	r2,-8(fp)
      tp->t_srtt = rtt << 3;
 823810c:	e0bffe17 	ldw	r2,-8(fp)
 8238110:	100690fa 	slli	r3,r2,3
 8238114:	e0bfff17 	ldw	r2,-4(fp)
 8238118:	10c02015 	stw	r3,128(r2)
      tp->t_rttvar = rtt << 1;
 823811c:	e0bffe17 	ldw	r2,-8(fp)
 8238120:	1085883a 	add	r2,r2,r2
 8238124:	1007883a 	mov	r3,r2
 8238128:	e0bfff17 	ldw	r2,-4(fp)
 823812c:	10c02115 	stw	r3,132(r2)
   }
   tp->t_rttick = 0;       /* clear RT timer */
 8238130:	e0bfff17 	ldw	r2,-4(fp)
 8238134:	10001e15 	stw	zero,120(r2)
   tp->t_rxtshift = 0;
 8238138:	e0bfff17 	ldw	r2,-4(fp)
 823813c:	10000715 	stw	zero,28(r2)
   TCPT_RANGESET(tp->t_rxtcur, 
 8238140:	e0bfff17 	ldw	r2,-4(fp)
 8238144:	10802017 	ldw	r2,128(r2)
 8238148:	1007d0ba 	srai	r3,r2,2
 823814c:	e0bfff17 	ldw	r2,-4(fp)
 8238150:	10802117 	ldw	r2,132(r2)
 8238154:	1885883a 	add	r2,r3,r2
 8238158:	1005d07a 	srai	r2,r2,1
 823815c:	10ffffcc 	andi	r3,r2,65535
 8238160:	18e0001c 	xori	r3,r3,32768
 8238164:	18e00004 	addi	r3,r3,-32768
 8238168:	e0bfff17 	ldw	r2,-4(fp)
 823816c:	10c00815 	stw	r3,32(r2)
 8238170:	e0bfff17 	ldw	r2,-4(fp)
 8238174:	10800817 	ldw	r2,32(r2)
 8238178:	10800088 	cmpgei	r2,r2,2
 823817c:	1000041e 	bne	r2,zero,8238190 <tcp_xmit_timer+0x22c>
 8238180:	e0bfff17 	ldw	r2,-4(fp)
 8238184:	00c00084 	movi	r3,2
 8238188:	10c00815 	stw	r3,32(r2)
 823818c:	00000706 	br	82381ac <tcp_xmit_timer+0x248>
 8238190:	e0bfff17 	ldw	r2,-4(fp)
 8238194:	10800817 	ldw	r2,32(r2)
 8238198:	10802050 	cmplti	r2,r2,129
 823819c:	1000031e 	bne	r2,zero,82381ac <tcp_xmit_timer+0x248>
 82381a0:	e0bfff17 	ldw	r2,-4(fp)
 82381a4:	00c02004 	movi	r3,128
 82381a8:	10c00815 	stw	r3,32(r2)
    ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1,
    TCPTV_MIN, TCPTV_REXMTMAX);
}
 82381ac:	e037883a 	mov	sp,fp
 82381b0:	dfc00117 	ldw	ra,4(sp)
 82381b4:	df000017 	ldw	fp,0(sp)
 82381b8:	dec00204 	addi	sp,sp,8
 82381bc:	f800283a 	ret

082381c0 <ip4_tcpmss>:


#ifdef IP_V4
int
ip4_tcpmss(struct socket * so)
{
 82381c0:	defffd04 	addi	sp,sp,-12
 82381c4:	df000215 	stw	fp,8(sp)
 82381c8:	df000204 	addi	fp,sp,8
 82381cc:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = so->so_pcb->ifp;
 82381d0:	e0bfff17 	ldw	r2,-4(fp)
 82381d4:	10800117 	ldw	r2,4(r2)
 82381d8:	10800a17 	ldw	r2,40(r2)
 82381dc:	e0bffe15 	stw	r2,-8(fp)
   return(ifp->n_mtu - (40 + ifp->n_lnh));
 82381e0:	e0bffe17 	ldw	r2,-8(fp)
 82381e4:	10c00917 	ldw	r3,36(r2)
 82381e8:	e0bffe17 	ldw	r2,-8(fp)
 82381ec:	10800817 	ldw	r2,32(r2)
 82381f0:	10800a04 	addi	r2,r2,40
 82381f4:	1885c83a 	sub	r2,r3,r2
}
 82381f8:	e037883a 	mov	sp,fp
 82381fc:	df000017 	ldw	fp,0(sp)
 8238200:	dec00104 	addi	sp,sp,4
 8238204:	f800283a 	ret

08238208 <tcp_mss>:
 */


int
tcp_mss(struct socket * so)
{
 8238208:	defffa04 	addi	sp,sp,-24
 823820c:	dfc00515 	stw	ra,20(sp)
 8238210:	df000415 	stw	fp,16(sp)
 8238214:	df000404 	addi	fp,sp,16
 8238218:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp;
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
 823821c:	e0bfff17 	ldw	r2,-4(fp)
 8238220:	10000726 	beq	r2,zero,8238240 <tcp_mss+0x38>
       (so->so_pcb == NULL) ||
 8238224:	e0bfff17 	ldw	r2,-4(fp)
 8238228:	10800117 	ldw	r2,4(r2)
   struct tcpcb * tp;
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
 823822c:	10000426 	beq	r2,zero,8238240 <tcp_mss+0x38>
       (so->so_pcb == NULL) ||
       (so->so_pcb->ifp == NULL))
 8238230:	e0bfff17 	ldw	r2,-4(fp)
 8238234:	10800117 	ldw	r2,4(r2)
 8238238:	10800a17 	ldw	r2,40(r2)
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
       (so->so_pcb == NULL) ||
 823823c:	1000061e 	bne	r2,zero,8238258 <tcp_mss+0x50>
       (so->so_pcb->ifp == NULL))
   {
      if (so->so_domain == AF_INET)  /* IPv4 */
 8238240:	e0bfff17 	ldw	r2,-4(fp)
 8238244:	10800517 	ldw	r2,20(r2)
 8238248:	10800098 	cmpnei	r2,r2,2
 823824c:	1000021e 	bne	r2,zero,8238258 <tcp_mss+0x50>
         return TCP_MSS;            /* user defined */
 8238250:	00816d04 	movi	r2,1460
 8238254:	00002506 	br	82382ec <tcp_mss+0xe4>
#endif   /* IP_V6 */


#ifdef IP_V4   /* Begin messy domain defines */
#ifndef IP_V6  /* V4 only version */
   mss = ip4_tcpmss(so);
 8238258:	e13fff17 	ldw	r4,-4(fp)
 823825c:	82381c00 	call	82381c0 <ip4_tcpmss>
 8238260:	e0bffc15 	stw	r2,-16(fp)
#endif         /* end of dual mode */
#else          /* no IP_v4, assume V6 only */
      mss = ip6_tcpmss(so, ifp);
#endif         /* end messy domain defines */

   if (mss > TCP_MSS)    /* check upper limit from compile */
 8238264:	e0bffc17 	ldw	r2,-16(fp)
 8238268:	10816d50 	cmplti	r2,r2,1461
 823826c:	1000021e 	bne	r2,zero,8238278 <tcp_mss+0x70>
      mss = TCP_MSS;
 8238270:	00816d04 	movi	r2,1460
 8238274:	e0bffc15 	stw	r2,-16(fp)

   /* check upper limit which may be set by setsockopt() */
   inp = (struct inpcb *)so->so_pcb;         /* Map socket to IP cb */
 8238278:	e0bfff17 	ldw	r2,-4(fp)
 823827c:	10800117 	ldw	r2,4(r2)
 8238280:	e0bffd15 	stw	r2,-12(fp)
   tp = (struct tcpcb *)inp->inp_ppcb;       /* Map IP to TCP cb */
 8238284:	e0bffd17 	ldw	r2,-12(fp)
 8238288:	10800917 	ldw	r2,36(r2)
 823828c:	e0bffe15 	stw	r2,-8(fp)
   
   /* has user set max seg? */
   if (tp->t_flags & TF_MAXSEG)
 8238290:	e0bffe17 	ldw	r2,-8(fp)
 8238294:	10800b0b 	ldhu	r2,44(r2)
 8238298:	10bfffcc 	andi	r2,r2,65535
 823829c:	1081000c 	andi	r2,r2,1024
 82382a0:	10000426 	beq	r2,zero,82382b4 <tcp_mss+0xac>
      return tp->t_maxseg;    /* yup */
 82382a4:	e0bffe17 	ldw	r2,-8(fp)
 82382a8:	10800a0b 	ldhu	r2,40(r2)
 82382ac:	10bfffcc 	andi	r2,r2,65535
 82382b0:	00000e06 	br	82382ec <tcp_mss+0xe4>
      
   if (tp->t_maxseg && (mss > tp->t_maxseg))  /* check tcp's mss */
 82382b4:	e0bffe17 	ldw	r2,-8(fp)
 82382b8:	10800a0b 	ldhu	r2,40(r2)
 82382bc:	10bfffcc 	andi	r2,r2,65535
 82382c0:	10000926 	beq	r2,zero,82382e8 <tcp_mss+0xe0>
 82382c4:	e0bffe17 	ldw	r2,-8(fp)
 82382c8:	10800a0b 	ldhu	r2,40(r2)
 82382cc:	10ffffcc 	andi	r3,r2,65535
 82382d0:	e0bffc17 	ldw	r2,-16(fp)
 82382d4:	1880040e 	bge	r3,r2,82382e8 <tcp_mss+0xe0>
   {
      mss = tp->t_maxseg;        /* limit new MSS to set MSS */
 82382d8:	e0bffe17 	ldw	r2,-8(fp)
 82382dc:	10800a0b 	ldhu	r2,40(r2)
 82382e0:	10bfffcc 	andi	r2,r2,65535
 82382e4:	e0bffc15 	stw	r2,-16(fp)
   }

   return mss;
 82382e8:	e0bffc17 	ldw	r2,-16(fp)
}
 82382ec:	e037883a 	mov	sp,fp
 82382f0:	dfc00117 	ldw	ra,4(sp)
 82382f4:	df000017 	ldw	fp,0(sp)
 82382f8:	dec00204 	addi	sp,sp,8
 82382fc:	f800283a 	ret

08238300 <tcp_output>:
 * RETURNS: 0 if OK, else a sockets error code.
 */

int
tcp_output(struct tcpcb * tp)
{
 8238300:	deffe804 	addi	sp,sp,-96
 8238304:	dfc01715 	stw	ra,92(sp)
 8238308:	df001615 	stw	fp,88(sp)
 823830c:	df001604 	addi	fp,sp,88
 8238310:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 8238314:	e0bfff17 	ldw	r2,-4(fp)
 8238318:	10800d17 	ldw	r2,52(r2)
 823831c:	10800817 	ldw	r2,32(r2)
 8238320:	e0bff215 	stw	r2,-56(fp)
   int   len;
   long  win;
   int   off,  flags,   error;
   struct mbuf *  m;
   struct tcpiphdr * ti;
   unsigned optlen = 0;
 8238324:	e03fee15 	stw	zero,-72(fp)
    * Determine length of data that should be transmitted,
    * and flags that will be used.
    * If there is some data or critical controls (SYN, RST)
    * to send, then transmit; otherwise, investigate further.
    */
   idle = (tp->snd_max == tp->snd_una);
 8238328:	e0bfff17 	ldw	r2,-4(fp)
 823832c:	10c01a17 	ldw	r3,104(r2)
 8238330:	e0bfff17 	ldw	r2,-4(fp)
 8238334:	10800e17 	ldw	r2,56(r2)
 8238338:	1885003a 	cmpeq	r2,r3,r2
 823833c:	10803fcc 	andi	r2,r2,255
 8238340:	e0bff315 	stw	r2,-52(fp)

again:
   sendalot = 0;
 8238344:	e03fef15 	stw	zero,-68(fp)
   off = (int)(tp->snd_nxt - tp->snd_una);
 8238348:	e0bfff17 	ldw	r2,-4(fp)
 823834c:	10c00f17 	ldw	r3,60(r2)
 8238350:	e0bfff17 	ldw	r2,-4(fp)
 8238354:	10800e17 	ldw	r2,56(r2)
 8238358:	1885c83a 	sub	r2,r3,r2
 823835c:	e0bff415 	stw	r2,-48(fp)
   win = (long)tp->snd_wnd;   /* set basic send window */
 8238360:	e0bfff17 	ldw	r2,-4(fp)
 8238364:	10801417 	ldw	r2,80(r2)
 8238368:	e0bfeb15 	stw	r2,-84(fp)
   if (win > (long)tp->snd_cwnd) /* see if we need congestion control */
 823836c:	e0bfff17 	ldw	r2,-4(fp)
 8238370:	10801b17 	ldw	r2,108(r2)
 8238374:	1007883a 	mov	r3,r2
 8238378:	e0bfeb17 	ldw	r2,-84(fp)
 823837c:	1880060e 	bge	r3,r2,8238398 <tcp_output+0x98>
   {
      win = (int)(tp->snd_cwnd & ~(ALIGN_TYPE-1)); /* keep data aligned */
 8238380:	e0bfff17 	ldw	r2,-4(fp)
 8238384:	10801b17 	ldw	r2,108(r2)
 8238388:	1007883a 	mov	r3,r2
 823838c:	00bfff04 	movi	r2,-4
 8238390:	1884703a 	and	r2,r3,r2
 8238394:	e0bfeb15 	stw	r2,-84(fp)
    * If in persist timeout with window of 0, send 1 byte.
    * Otherwise, if window is small but nonzero
    * and timer expired, we will send what we can
    * and go to transmit state.
    */
   if (tp->t_force) 
 8238398:	e0bfff17 	ldw	r2,-4(fp)
 823839c:	10800a83 	ldbu	r2,42(r2)
 82383a0:	10803fcc 	andi	r2,r2,255
 82383a4:	1080201c 	xori	r2,r2,128
 82383a8:	10bfe004 	addi	r2,r2,-128
 82383ac:	10000926 	beq	r2,zero,82383d4 <tcp_output+0xd4>
   {
      if (win == 0)
 82383b0:	e0bfeb17 	ldw	r2,-84(fp)
 82383b4:	1000031e 	bne	r2,zero,82383c4 <tcp_output+0xc4>
         win = 1;
 82383b8:	00800044 	movi	r2,1
 82383bc:	e0bfeb15 	stw	r2,-84(fp)
 82383c0:	00000406 	br	82383d4 <tcp_output+0xd4>
      else 
      {
         tp->t_timer[TCPT_PERSIST] = 0;
 82383c4:	e0bfff17 	ldw	r2,-4(fp)
 82383c8:	10000415 	stw	zero,16(r2)
         tp->t_rxtshift = 0;
 82383cc:	e0bfff17 	ldw	r2,-4(fp)
 82383d0:	10000715 	stw	zero,28(r2)
   }
   else
#endif /* TCP_SACK */
   {
      /* set length of packets which are not sack resends */
      len = (int)MIN(so->so_snd.sb_cc, (unsigned)win) - off;
 82383d4:	e0bff217 	ldw	r2,-56(fp)
 82383d8:	10801217 	ldw	r2,72(r2)
 82383dc:	e0ffeb17 	ldw	r3,-84(fp)
 82383e0:	1880012e 	bgeu	r3,r2,82383e8 <tcp_output+0xe8>
 82383e4:	1805883a 	mov	r2,r3
 82383e8:	1007883a 	mov	r3,r2
 82383ec:	e0bff417 	ldw	r2,-48(fp)
 82383f0:	1885c83a 	sub	r2,r3,r2
 82383f4:	e0bfea15 	stw	r2,-88(fp)
   }

   flags = tcp_outflags[tp->t_state];
 82383f8:	e0bfff17 	ldw	r2,-4(fp)
 82383fc:	10c00217 	ldw	r3,8(r2)
 8238400:	00820974 	movhi	r2,2085
 8238404:	108ec304 	addi	r2,r2,15116
 8238408:	10c5883a 	add	r2,r2,r3
 823840c:	10800003 	ldbu	r2,0(r2)
 8238410:	10803fcc 	andi	r2,r2,255
 8238414:	e0bfec15 	stw	r2,-80(fp)
   }
#else
   /* If other options not defined this build then don't bother to call bld_options() except 
    * on SYN packets
    */
   if(flags & TH_SYN)
 8238418:	e0bfec17 	ldw	r2,-80(fp)
 823841c:	1080008c 	andi	r2,r2,2
 8238420:	10000926 	beq	r2,zero,8238448 <tcp_output+0x148>
   {
      optlen = bld_options(tp, &tcp_optionbuf[optlen], flags, so);
 8238424:	e0ffee17 	ldw	r3,-72(fp)
 8238428:	d0a0b304 	addi	r2,gp,-32052
 823842c:	1885883a 	add	r2,r3,r2
 8238430:	e1fff217 	ldw	r7,-56(fp)
 8238434:	e1bfec17 	ldw	r6,-80(fp)
 8238438:	100b883a 	mov	r5,r2
 823843c:	e13fff17 	ldw	r4,-4(fp)
 8238440:	82394040 	call	8239404 <bld_options>
 8238444:	e0bfee15 	stw	r2,-72(fp)
   }
#endif

   if (len < 0)
 8238448:	e0bfea17 	ldw	r2,-88(fp)
 823844c:	1000090e 	bge	r2,zero,8238474 <tcp_output+0x174>
       * cancel pending retransmit and pull snd_nxt
       * back to (closed) window.  We will enter persist
       * state below.  If the window didn't close completely,
       * just wait for an ACK.
       */
      len = 0;
 8238450:	e03fea15 	stw	zero,-88(fp)
      if (win == 0) 
 8238454:	e0bfeb17 	ldw	r2,-84(fp)
 8238458:	1000061e 	bne	r2,zero,8238474 <tcp_output+0x174>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 823845c:	e0bfff17 	ldw	r2,-4(fp)
 8238460:	10000315 	stw	zero,12(r2)
         tp->snd_nxt = tp->snd_una;
 8238464:	e0bfff17 	ldw	r2,-4(fp)
 8238468:	10c00e17 	ldw	r3,56(r2)
 823846c:	e0bfff17 	ldw	r2,-4(fp)
 8238470:	10c00f15 	stw	r3,60(r2)
      }
   }

   if (len > (int)tp->t_maxseg)
 8238474:	e0bfff17 	ldw	r2,-4(fp)
 8238478:	10800a0b 	ldhu	r2,40(r2)
 823847c:	10ffffcc 	andi	r3,r2,65535
 8238480:	e0bfea17 	ldw	r2,-88(fp)
 8238484:	1880060e 	bge	r3,r2,82384a0 <tcp_output+0x1a0>
   {
      len = tp->t_maxseg;
 8238488:	e0bfff17 	ldw	r2,-4(fp)
 823848c:	10800a0b 	ldhu	r2,40(r2)
 8238490:	10bfffcc 	andi	r2,r2,65535
 8238494:	e0bfea15 	stw	r2,-88(fp)
      sendalot = 1;
 8238498:	00800044 	movi	r2,1
 823849c:	e0bfef15 	stw	r2,-68(fp)
   /* We don't need a pmtu test for IPv6. V6 code limits t_maxseg to
    * the Path MTU, so the test above the v4 ifdef above covers us.
    */
#endif /* IP_V4 */

   if (SEQ_LT(tp->snd_nxt + len, tp->snd_una + so->so_snd.sb_cc))
 82384a0:	e0bfff17 	ldw	r2,-4(fp)
 82384a4:	10c00f17 	ldw	r3,60(r2)
 82384a8:	e0bfea17 	ldw	r2,-88(fp)
 82384ac:	1887883a 	add	r3,r3,r2
 82384b0:	e0bfff17 	ldw	r2,-4(fp)
 82384b4:	11000e17 	ldw	r4,56(r2)
 82384b8:	e0bff217 	ldw	r2,-56(fp)
 82384bc:	10801217 	ldw	r2,72(r2)
 82384c0:	2085883a 	add	r2,r4,r2
 82384c4:	1885c83a 	sub	r2,r3,r2
 82384c8:	1000040e 	bge	r2,zero,82384dc <tcp_output+0x1dc>
      flags &= ~TH_FIN;
 82384cc:	e0ffec17 	ldw	r3,-80(fp)
 82384d0:	00bfff84 	movi	r2,-2
 82384d4:	1884703a 	and	r2,r3,r2
 82384d8:	e0bfec15 	stw	r2,-80(fp)
   win = (long)(sbspace(&so->so_rcv));
 82384dc:	e0bff217 	ldw	r2,-56(fp)
 82384e0:	10800b17 	ldw	r2,44(r2)
 82384e4:	1007883a 	mov	r3,r2
 82384e8:	e0bff217 	ldw	r2,-56(fp)
 82384ec:	10800a17 	ldw	r2,40(r2)
 82384f0:	1885c83a 	sub	r2,r3,r2
 82384f4:	10000616 	blt	r2,zero,8238510 <tcp_output+0x210>
 82384f8:	e0bff217 	ldw	r2,-56(fp)
 82384fc:	10c00b17 	ldw	r3,44(r2)
 8238500:	e0bff217 	ldw	r2,-56(fp)
 8238504:	10800a17 	ldw	r2,40(r2)
 8238508:	1885c83a 	sub	r2,r3,r2
 823850c:	00000106 	br	8238514 <tcp_output+0x214>
 8238510:	0005883a 	mov	r2,zero
 8238514:	e0bfeb15 	stw	r2,-84(fp)
   /*
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
 8238518:	e0bfec17 	ldw	r2,-80(fp)
 823851c:	1080004c 	andi	r2,r2,1
 8238520:	10000d26 	beq	r2,zero,8238558 <tcp_output+0x258>
       (so->so_snd.sb_cc == 0) &&
 8238524:	e0bff217 	ldw	r2,-56(fp)
 8238528:	10801217 	ldw	r2,72(r2)
   /*
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
 823852c:	10000a1e 	bne	r2,zero,8238558 <tcp_output+0x258>
       (so->so_snd.sb_cc == 0) &&
       ((tp->t_flags & TF_SENTFIN) == 0 || tp->snd_nxt == tp->snd_una))
 8238530:	e0bfff17 	ldw	r2,-4(fp)
 8238534:	10800b0b 	ldhu	r2,44(r2)
 8238538:	10bfffcc 	andi	r2,r2,65535
 823853c:	1080040c 	andi	r2,r2,16
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
       (so->so_snd.sb_cc == 0) &&
 8238540:	10007926 	beq	r2,zero,8238728 <tcp_output+0x428>
       ((tp->t_flags & TF_SENTFIN) == 0 || tp->snd_nxt == tp->snd_una))
 8238544:	e0bfff17 	ldw	r2,-4(fp)
 8238548:	10c00f17 	ldw	r3,60(r2)
 823854c:	e0bfff17 	ldw	r2,-4(fp)
 8238550:	10800e17 	ldw	r2,56(r2)
 8238554:	18807426 	beq	r3,r2,8238728 <tcp_output+0x428>
      goto send;
   }
   /*
    * Send if we owe peer an ACK.
    */
   if (tp->t_flags & TF_ACKNOW)
 8238558:	e0bfff17 	ldw	r2,-4(fp)
 823855c:	10800b0b 	ldhu	r2,44(r2)
 8238560:	10bfffcc 	andi	r2,r2,65535
 8238564:	1080004c 	andi	r2,r2,1
 8238568:	10005c1e 	bne	r2,zero,82386dc <tcp_output+0x3dc>
      goto send;
   if (flags & (TH_SYN|TH_RST))
 823856c:	e0bfec17 	ldw	r2,-80(fp)
 8238570:	1080018c 	andi	r2,r2,6
 8238574:	10005b1e 	bne	r2,zero,82386e4 <tcp_output+0x3e4>
      goto send;
   if (SEQ_GT(tp->snd_up, tp->snd_una))
 8238578:	e0bfff17 	ldw	r2,-4(fp)
 823857c:	10c01017 	ldw	r3,64(r2)
 8238580:	e0bfff17 	ldw	r2,-4(fp)
 8238584:	10800e17 	ldw	r2,56(r2)
 8238588:	1885c83a 	sub	r2,r3,r2
 823858c:	00805716 	blt	zero,r2,82386ec <tcp_output+0x3ec>
    * If peer's buffer is tiny, then send
    * when window is at least half open.
    * If retransmitting (possibly after persist timer forced us
    * to send into a small window), then must resend.
    */
   if (len)
 8238590:	e0bfea17 	ldw	r2,-88(fp)
 8238594:	10002426 	beq	r2,zero,8238628 <tcp_output+0x328>
   {
      if (len == (int)tp->t_maxseg)
 8238598:	e0bfff17 	ldw	r2,-4(fp)
 823859c:	10800a0b 	ldhu	r2,40(r2)
 82385a0:	10ffffcc 	andi	r3,r2,65535
 82385a4:	e0bfea17 	ldw	r2,-88(fp)
 82385a8:	18805226 	beq	r3,r2,82386f4 <tcp_output+0x3f4>
         goto send;
      if ((idle || tp->t_flags & TF_NODELAY) &&
 82385ac:	e0bff317 	ldw	r2,-52(fp)
 82385b0:	1000051e 	bne	r2,zero,82385c8 <tcp_output+0x2c8>
 82385b4:	e0bfff17 	ldw	r2,-4(fp)
 82385b8:	10800b0b 	ldhu	r2,44(r2)
 82385bc:	10bfffcc 	andi	r2,r2,65535
 82385c0:	1080010c 	andi	r2,r2,4
 82385c4:	10000626 	beq	r2,zero,82385e0 <tcp_output+0x2e0>
          len + off >= (int)so->so_snd.sb_cc)
 82385c8:	e0ffea17 	ldw	r3,-88(fp)
 82385cc:	e0bff417 	ldw	r2,-48(fp)
 82385d0:	1885883a 	add	r2,r3,r2
 82385d4:	e0fff217 	ldw	r3,-56(fp)
 82385d8:	18c01217 	ldw	r3,72(r3)
    */
   if (len)
   {
      if (len == (int)tp->t_maxseg)
         goto send;
      if ((idle || tp->t_flags & TF_NODELAY) &&
 82385dc:	10c0470e 	bge	r2,r3,82386fc <tcp_output+0x3fc>
          len + off >= (int)so->so_snd.sb_cc)
      {
         goto send;
      }
      if (tp->t_force)
 82385e0:	e0bfff17 	ldw	r2,-4(fp)
 82385e4:	10800a83 	ldbu	r2,42(r2)
 82385e8:	10803fcc 	andi	r2,r2,255
 82385ec:	1080201c 	xori	r2,r2,128
 82385f0:	10bfe004 	addi	r2,r2,-128
 82385f4:	1000431e 	bne	r2,zero,8238704 <tcp_output+0x404>
         goto send;
      if (len >= (int)(tp->max_sndwnd / 2))
 82385f8:	e0bfff17 	ldw	r2,-4(fp)
 82385fc:	10802317 	ldw	r2,140(r2)
 8238600:	1004d07a 	srli	r2,r2,1
 8238604:	1007883a 	mov	r3,r2
 8238608:	e0bfea17 	ldw	r2,-88(fp)
 823860c:	10c03f0e 	bge	r2,r3,823870c <tcp_output+0x40c>
         goto send;
      if (SEQ_LT(tp->snd_nxt, tp->snd_max))
 8238610:	e0bfff17 	ldw	r2,-4(fp)
 8238614:	10c00f17 	ldw	r3,60(r2)
 8238618:	e0bfff17 	ldw	r2,-4(fp)
 823861c:	10801a17 	ldw	r2,104(r2)
 8238620:	1885c83a 	sub	r2,r3,r2
 8238624:	10003b16 	blt	r2,zero,8238714 <tcp_output+0x414>
    * known to peer (as advertised window less
    * next expected input).  If the difference is at least two
    * max size segments or at least 35% of the maximum possible
    * window, then want to send a window update to peer.
    */
   if (win > 0)
 8238628:	e0bfeb17 	ldw	r2,-84(fp)
 823862c:	00801c0e 	bge	zero,r2,82386a0 <tcp_output+0x3a0>
   {
      int   adv   =  (int)win -  (int)(tp->rcv_adv -  tp->rcv_nxt);
 8238630:	e0bfff17 	ldw	r2,-4(fp)
 8238634:	10c01617 	ldw	r3,88(r2)
 8238638:	e0bfff17 	ldw	r2,-4(fp)
 823863c:	10801917 	ldw	r2,100(r2)
 8238640:	1885c83a 	sub	r2,r3,r2
 8238644:	1007883a 	mov	r3,r2
 8238648:	e0bfeb17 	ldw	r2,-84(fp)
 823864c:	1885883a 	add	r2,r3,r2
 8238650:	e0bffd15 	stw	r2,-12(fp)

      if (so->so_rcv.sb_cc == 0 && adv >= (int)(tp->t_maxseg * 2))
 8238654:	e0bff217 	ldw	r2,-56(fp)
 8238658:	10800a17 	ldw	r2,40(r2)
 823865c:	1000071e 	bne	r2,zero,823867c <tcp_output+0x37c>
 8238660:	e0bfff17 	ldw	r2,-4(fp)
 8238664:	10800a0b 	ldhu	r2,40(r2)
 8238668:	10bfffcc 	andi	r2,r2,65535
 823866c:	1085883a 	add	r2,r2,r2
 8238670:	1007883a 	mov	r3,r2
 8238674:	e0bffd17 	ldw	r2,-12(fp)
 8238678:	10c0280e 	bge	r2,r3,823871c <tcp_output+0x41c>
         goto send;
      if (100 * (u_int)adv / so->so_rcv.sb_hiwat >= 35)
 823867c:	e0bffd17 	ldw	r2,-12(fp)
 8238680:	10c01924 	muli	r3,r2,100
 8238684:	e0bff217 	ldw	r2,-56(fp)
 8238688:	10800b17 	ldw	r2,44(r2)
 823868c:	100b883a 	mov	r5,r2
 8238690:	1809883a 	mov	r4,r3
 8238694:	8202c100 	call	8202c10 <__udivsi3>
 8238698:	108008f0 	cmpltui	r2,r2,35
 823869c:	10002126 	beq	r2,zero,8238724 <tcp_output+0x424>
    * retransmit or persist is pending, then go to persist state.
    * If nothing happens soon, send when timer expires:
    * if window is nonzero, transmit what we can,
    * otherwise force out a byte.
    */
   if (so->so_snd.sb_cc && tp->t_timer[TCPT_REXMT] == 0 &&
 82386a0:	e0bff217 	ldw	r2,-56(fp)
 82386a4:	10801217 	ldw	r2,72(r2)
 82386a8:	10000a26 	beq	r2,zero,82386d4 <tcp_output+0x3d4>
 82386ac:	e0bfff17 	ldw	r2,-4(fp)
 82386b0:	10800317 	ldw	r2,12(r2)
 82386b4:	1000071e 	bne	r2,zero,82386d4 <tcp_output+0x3d4>
       tp->t_timer[TCPT_PERSIST] == 0) 
 82386b8:	e0bfff17 	ldw	r2,-4(fp)
 82386bc:	10800417 	ldw	r2,16(r2)
    * retransmit or persist is pending, then go to persist state.
    * If nothing happens soon, send when timer expires:
    * if window is nonzero, transmit what we can,
    * otherwise force out a byte.
    */
   if (so->so_snd.sb_cc && tp->t_timer[TCPT_REXMT] == 0 &&
 82386c0:	1000041e 	bne	r2,zero,82386d4 <tcp_output+0x3d4>
       tp->t_timer[TCPT_PERSIST] == 0) 
   {
      tp->t_rxtshift = 0;
 82386c4:	e0bfff17 	ldw	r2,-4(fp)
 82386c8:	10000715 	stw	zero,28(r2)
      tcp_setpersist(tp);
 82386cc:	e13fff17 	ldw	r4,-4(fp)
 82386d0:	82393040 	call	8239304 <tcp_setpersist>
   }

   /*
    * No reason to send a segment, just return.
    */
   return (0);
 82386d4:	0005883a 	mov	r2,zero
 82386d8:	00030506 	br	82392f0 <tcp_output+0xff0>
   }
   /*
    * Send if we owe peer an ACK.
    */
   if (tp->t_flags & TF_ACKNOW)
      goto send;
 82386dc:	0001883a 	nop
 82386e0:	00001106 	br	8238728 <tcp_output+0x428>
   if (flags & (TH_SYN|TH_RST))
      goto send;
 82386e4:	0001883a 	nop
 82386e8:	00000f06 	br	8238728 <tcp_output+0x428>
   if (SEQ_GT(tp->snd_up, tp->snd_una))
      goto send;
 82386ec:	0001883a 	nop
 82386f0:	00000d06 	br	8238728 <tcp_output+0x428>
    * to send into a small window), then must resend.
    */
   if (len)
   {
      if (len == (int)tp->t_maxseg)
         goto send;
 82386f4:	0001883a 	nop
 82386f8:	00000b06 	br	8238728 <tcp_output+0x428>
      if ((idle || tp->t_flags & TF_NODELAY) &&
          len + off >= (int)so->so_snd.sb_cc)
      {
         goto send;
 82386fc:	0001883a 	nop
 8238700:	00000906 	br	8238728 <tcp_output+0x428>
      }
      if (tp->t_force)
         goto send;
 8238704:	0001883a 	nop
 8238708:	00000706 	br	8238728 <tcp_output+0x428>
      if (len >= (int)(tp->max_sndwnd / 2))
         goto send;
 823870c:	0001883a 	nop
 8238710:	00000506 	br	8238728 <tcp_output+0x428>
      if (SEQ_LT(tp->snd_nxt, tp->snd_max))
         goto send;
 8238714:	0001883a 	nop
 8238718:	00000306 	br	8238728 <tcp_output+0x428>
   if (win > 0)
   {
      int   adv   =  (int)win -  (int)(tp->rcv_adv -  tp->rcv_nxt);

      if (so->so_rcv.sb_cc == 0 && adv >= (int)(tp->t_maxseg * 2))
         goto send;
 823871c:	0001883a 	nop
 8238720:	00000106 	br	8238728 <tcp_output+0x428>
      if (100 * (u_int)adv / so->so_rcv.sb_hiwat >= 35)
         goto send;
 8238724:	0001883a 	nop
    * No reason to send a segment, just return.
    */
   return (0);

send:
   ENTER_CRIT_SECTION(tp);
 8238728:	822d76c0 	call	822d76c <irq_Mask>

   /* Limit send length to the current buffer so as to
    * avoid doing the "mbuf shuffle" in m_copy().
    */
   bufoff = off;
 823872c:	e0bff417 	ldw	r2,-48(fp)
 8238730:	e0bff115 	stw	r2,-60(fp)
   sendm = so->so_snd.sb_mb;
 8238734:	e0bff217 	ldw	r2,-56(fp)
 8238738:	10801817 	ldw	r2,96(r2)
 823873c:	e0bff015 	stw	r2,-64(fp)
   if (len)
 8238740:	e0bfea17 	ldw	r2,-88(fp)
 8238744:	10005526 	beq	r2,zero,823889c <tcp_output+0x59c>
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 8238748:	00000a06 	br	8238774 <tcp_output+0x474>
      {
         bufoff -= sendm->m_len;
 823874c:	e0fff117 	ldw	r3,-60(fp)
 8238750:	e0bff017 	ldw	r2,-64(fp)
 8238754:	10800217 	ldw	r2,8(r2)
 8238758:	1885c83a 	sub	r2,r3,r2
 823875c:	e0bff115 	stw	r2,-60(fp)
         if (bufoff < 0)   /* if off is in this buffer, break */
 8238760:	e0bff117 	ldw	r2,-60(fp)
 8238764:	10000616 	blt	r2,zero,8238780 <tcp_output+0x480>
            break;
         sendm = sendm->m_next;
 8238768:	e0bff017 	ldw	r2,-64(fp)
 823876c:	10800617 	ldw	r2,24(r2)
 8238770:	e0bff015 	stw	r2,-64(fp)
   bufoff = off;
   sendm = so->so_snd.sb_mb;
   if (len)
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 8238774:	e0bff017 	ldw	r2,-64(fp)
 8238778:	103ff41e 	bne	r2,zero,823874c <tcp_output+0x44c>
 823877c:	00000106 	br	8238784 <tcp_output+0x484>
      {
         bufoff -= sendm->m_len;
         if (bufoff < 0)   /* if off is in this buffer, break */
            break;
 8238780:	0001883a 	nop
         sendm = sendm->m_next;
      }
      if (!sendm) { dtrap();  /* shouldn't happen */ }
 8238784:	e0bff017 	ldw	r2,-64(fp)
 8238788:	1000011e 	bne	r2,zero,8238790 <tcp_output+0x490>
 823878c:	822d5940 	call	822d594 <dtrap>
      bufoff += sendm->m_len; /* index to next data to send in msend */
 8238790:	e0bff017 	ldw	r2,-64(fp)
 8238794:	10c00217 	ldw	r3,8(r2)
 8238798:	e0bff117 	ldw	r2,-60(fp)
 823879c:	1885883a 	add	r2,r3,r2
 82387a0:	e0bff115 	stw	r2,-60(fp)

      /* if socket has multiple unsent mbufs, set flag for send to loop */
      if ((sendm->m_next) && (len > (int)sendm->m_len))
 82387a4:	e0bff017 	ldw	r2,-64(fp)
 82387a8:	10800617 	ldw	r2,24(r2)
 82387ac:	10000b26 	beq	r2,zero,82387dc <tcp_output+0x4dc>
 82387b0:	e0bff017 	ldw	r2,-64(fp)
 82387b4:	10800217 	ldw	r2,8(r2)
 82387b8:	1007883a 	mov	r3,r2
 82387bc:	e0bfea17 	ldw	r2,-88(fp)
 82387c0:	1880060e 	bge	r3,r2,82387dc <tcp_output+0x4dc>
      {
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 82387c4:	e0ffec17 	ldw	r3,-80(fp)
 82387c8:	00bfff84 	movi	r2,-2
 82387cc:	1884703a 	and	r2,r3,r2
 82387d0:	e0bfec15 	stw	r2,-80(fp)
         sendalot = 1;     /* set to send more segments */
 82387d4:	00800044 	movi	r2,1
 82387d8:	e0bfef15 	stw	r2,-68(fp)
      }
      if((flags & TH_FIN) && (so->so_snd.sb_cc > (unsigned)len))
 82387dc:	e0bfec17 	ldw	r2,-80(fp)
 82387e0:	1080004c 	andi	r2,r2,1
 82387e4:	10000826 	beq	r2,zero,8238808 <tcp_output+0x508>
 82387e8:	e0bff217 	ldw	r2,-56(fp)
 82387ec:	10801217 	ldw	r2,72(r2)
 82387f0:	e0ffea17 	ldw	r3,-88(fp)
 82387f4:	1880042e 	bgeu	r3,r2,8238808 <tcp_output+0x508>
      {
         /* This can happen on slow links (PPP) which retry the last 
          * segment - the one with the FIN bit attached to data.
          */
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 82387f8:	e0ffec17 	ldw	r3,-80(fp)
 82387fc:	00bfff84 	movi	r2,-2
 8238800:	1884703a 	and	r2,r3,r2
 8238804:	e0bfec15 	stw	r2,-80(fp)
      }

      /* only send the rest of msend */
      len = min(len, (int)sendm->m_len);
 8238808:	e0bff017 	ldw	r2,-64(fp)
 823880c:	10800217 	ldw	r2,8(r2)
 8238810:	e0ffea17 	ldw	r3,-88(fp)
 8238814:	1880010e 	bge	r3,r2,823881c <tcp_output+0x51c>
 8238818:	1805883a 	mov	r2,r3
 823881c:	e0bfea15 	stw	r2,-88(fp)
       * Similarly, if sendm->m_data is not aligned with respect to 
       * sendm->m_base and ALIGN_TYPE, we will copy the data to 
       * ensure that it (and the then-prepended IP/TCP headers) will 
       * be aligned according to ALIGN_TYPE. 
       */
      if ((bufoff != 0) ||       /* data not front aligned in send mbuf? */
 8238820:	e0bff117 	ldw	r2,-60(fp)
 8238824:	1000081e 	bne	r2,zero,8238848 <tcp_output+0x548>
          (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) != 0))
 8238828:	e0bff017 	ldw	r2,-64(fp)
 823882c:	10800317 	ldw	r2,12(r2)
 8238830:	1007883a 	mov	r3,r2
 8238834:	e0bff017 	ldw	r2,-64(fp)
 8238838:	10800417 	ldw	r2,16(r2)
 823883c:	1885c83a 	sub	r2,r3,r2
 8238840:	108000cc 	andi	r2,r2,3
       * Similarly, if sendm->m_data is not aligned with respect to 
       * sendm->m_base and ALIGN_TYPE, we will copy the data to 
       * ensure that it (and the then-prepended IP/TCP headers) will 
       * be aligned according to ALIGN_TYPE. 
       */
      if ((bufoff != 0) ||       /* data not front aligned in send mbuf? */
 8238844:	10001526 	beq	r2,zero,823889c <tcp_output+0x59c>
          (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) != 0))
      {
         len = min(len, (int)(sendm->m_len - bufoff));   /* limit len again */
 8238848:	e0bff017 	ldw	r2,-64(fp)
 823884c:	10c00217 	ldw	r3,8(r2)
 8238850:	e0bff117 	ldw	r2,-60(fp)
 8238854:	1885c83a 	sub	r2,r3,r2
 8238858:	e0ffea17 	ldw	r3,-88(fp)
 823885c:	1880010e 	bge	r3,r2,8238864 <tcp_output+0x564>
 8238860:	1805883a 	mov	r2,r3
 8238864:	e0bfea15 	stw	r2,-88(fp)
          * of the m_data buffer then we can't use it in place, else we
          * might write the IP/TCP header over data that has not yet
          * been acked. In this case we must make sure our send
          * fits into a little buffer and send what we can.
          */
         if ((len > (int)(lilbufsiz - HDRSLEN)) && /* length is bigger the small buffer? */
 8238868:	d0a03717 	ldw	r2,-32548(gp)
 823886c:	10bff204 	addi	r2,r2,-56
 8238870:	1007883a 	mov	r3,r2
 8238874:	e0bfea17 	ldw	r2,-88(fp)
 8238878:	1880080e 	bge	r3,r2,823889c <tcp_output+0x59c>
             (bigfreeq.q_len < 2))      /* and we are low on big buffers */
 823887c:	008209b4 	movhi	r2,2086
 8238880:	10b8c204 	addi	r2,r2,-7416
 8238884:	10800217 	ldw	r2,8(r2)
          * of the m_data buffer then we can't use it in place, else we
          * might write the IP/TCP header over data that has not yet
          * been acked. In this case we must make sure our send
          * fits into a little buffer and send what we can.
          */
         if ((len > (int)(lilbufsiz - HDRSLEN)) && /* length is bigger the small buffer? */
 8238888:	10800088 	cmpgei	r2,r2,2
 823888c:	1000031e 	bne	r2,zero,823889c <tcp_output+0x59c>
             (bigfreeq.q_len < 2))      /* and we are low on big buffers */
         {
            len = lilbufsiz - HDRSLEN;
 8238890:	d0a03717 	ldw	r2,-32548(gp)
 8238894:	10bff204 	addi	r2,r2,-56
 8238898:	e0bfea15 	stw	r2,-88(fp)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 823889c:	e0bfea17 	ldw	r2,-88(fp)
 82388a0:	10003626 	beq	r2,zero,823897c <tcp_output+0x67c>
 82388a4:	e0bff117 	ldw	r2,-60(fp)
 82388a8:	1000341e 	bne	r2,zero,823897c <tcp_output+0x67c>
       (sendm->pkt->inuse == 1) &&
 82388ac:	e0bff017 	ldw	r2,-64(fp)
 82388b0:	10800117 	ldw	r2,4(r2)
 82388b4:	10800917 	ldw	r2,36(r2)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 82388b8:	10800058 	cmpnei	r2,r2,1
 82388bc:	10002f1e 	bne	r2,zero,823897c <tcp_output+0x67c>
       (sendm->pkt->inuse == 1) &&
       (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) == 0) && 
 82388c0:	e0bff017 	ldw	r2,-64(fp)
 82388c4:	10800317 	ldw	r2,12(r2)
 82388c8:	1007883a 	mov	r3,r2
 82388cc:	e0bff017 	ldw	r2,-64(fp)
 82388d0:	10800417 	ldw	r2,16(r2)
 82388d4:	1885c83a 	sub	r2,r3,r2
 82388d8:	108000cc 	andi	r2,r2,3

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
       (sendm->pkt->inuse == 1) &&
 82388dc:	1000271e 	bne	r2,zero,823897c <tcp_output+0x67c>
       (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) == 0) && 
 82388e0:	e0bfee17 	ldw	r2,-72(fp)
 82388e4:	1000251e 	bne	r2,zero,823897c <tcp_output+0x67c>
       (optlen == 0))
   {
      /* get an empty mbuf to "clone" the data */
      m = m_getnbuf(MT_TXDATA, 0);
 82388e8:	000b883a 	mov	r5,zero
 82388ec:	01000084 	movi	r4,2
 82388f0:	822e3a80 	call	822e3a8 <m_getnbuf>
 82388f4:	e0bfed15 	stw	r2,-76(fp)
      if (!m)
 82388f8:	e0bfed17 	ldw	r2,-76(fp)
 82388fc:	1000031e 	bne	r2,zero,823890c <tcp_output+0x60c>
      {
         EXIT_CRIT_SECTION(tp);
 8238900:	822d7cc0 	call	822d7cc <irq_Unmask>
         return (ENOBUFS);
 8238904:	00801a44 	movi	r2,105
 8238908:	00027906 	br	82392f0 <tcp_output+0xff0>
      }
      m->pkt = sendm->pkt; /* copy packet location in new mbuf */
 823890c:	e0bff017 	ldw	r2,-64(fp)
 8238910:	10c00117 	ldw	r3,4(r2)
 8238914:	e0bfed17 	ldw	r2,-76(fp)
 8238918:	10c00115 	stw	r3,4(r2)
      m->pkt->inuse++;     /* bump packet's use count */
 823891c:	e0bfed17 	ldw	r2,-76(fp)
 8238920:	10800117 	ldw	r2,4(r2)
 8238924:	10c00917 	ldw	r3,36(r2)
 8238928:	18c00044 	addi	r3,r3,1
 823892c:	10c00915 	stw	r3,36(r2)
      m->m_base = sendm->m_base; /* clone mbuf members */
 8238930:	e0bff017 	ldw	r2,-64(fp)
 8238934:	10c00417 	ldw	r3,16(r2)
 8238938:	e0bfed17 	ldw	r2,-76(fp)
 823893c:	10c00415 	stw	r3,16(r2)
      m->m_memsz = sendm->m_memsz;
 8238940:	e0bff017 	ldw	r2,-64(fp)
 8238944:	10c00517 	ldw	r3,20(r2)
 8238948:	e0bfed17 	ldw	r2,-76(fp)
 823894c:	10c00515 	stw	r3,20(r2)
      m->m_len = len + TCPIPHDRSZ;  /* adjust clone for header */
 8238950:	e0bfea17 	ldw	r2,-88(fp)
 8238954:	10800a04 	addi	r2,r2,40
 8238958:	1007883a 	mov	r3,r2
 823895c:	e0bfed17 	ldw	r2,-76(fp)
 8238960:	10c00215 	stw	r3,8(r2)
      m->m_data = sendm->m_data - TCPIPHDRSZ;
 8238964:	e0bff017 	ldw	r2,-64(fp)
 8238968:	10800317 	ldw	r2,12(r2)
 823896c:	10fff604 	addi	r3,r2,-40
 8238970:	e0bfed17 	ldw	r2,-76(fp)
 8238974:	10c00315 	stw	r3,12(r2)
 8238978:	00002706 	br	8238a18 <tcp_output+0x718>
   {
      /* Grab a header mbuf, attaching a copy of data to be 
       * transmitted, and initialize the header from 
       * the template for sends on this connection.
       */
      m = m_getwithdata (MT_HEADER, IFNETHDR_SIZE + TCPIPHDRSZ);
 823897c:	d0a08117 	ldw	r2,-32252(gp)
 8238980:	10800a04 	addi	r2,r2,40
 8238984:	100b883a 	mov	r5,r2
 8238988:	010000c4 	movi	r4,3
 823898c:	822e3a80 	call	822e3a8 <m_getnbuf>
 8238990:	e0bfed15 	stw	r2,-76(fp)
      if (m ==(struct mbuf *)NULL)
 8238994:	e0bfed17 	ldw	r2,-76(fp)
 8238998:	1000031e 	bne	r2,zero,82389a8 <tcp_output+0x6a8>
      {
         EXIT_CRIT_SECTION(tp);
 823899c:	822d7cc0 	call	822d7cc <irq_Unmask>
         return ENOBUFS;
 82389a0:	00801a44 	movi	r2,105
 82389a4:	00025206 	br	82392f0 <tcp_output+0xff0>
      }

      m->m_len = TCPIPHDRSZ;
 82389a8:	e0bfed17 	ldw	r2,-76(fp)
 82389ac:	00c00a04 	movi	r3,40
 82389b0:	10c00215 	stw	r3,8(r2)
      m->m_data += IFNETHDR_SIZE;/* Move this to sizeof tcpip hdr leave*/
 82389b4:	e0bfed17 	ldw	r2,-76(fp)
 82389b8:	10800317 	ldw	r2,12(r2)
 82389bc:	d0e08117 	ldw	r3,-32252(gp)
 82389c0:	10c7883a 	add	r3,r2,r3
 82389c4:	e0bfed17 	ldw	r2,-76(fp)
 82389c8:	10c00315 	stw	r3,12(r2)
      /* 14 bytes for ethernet header      */

      if (len) /* attach any data to send */
 82389cc:	e0bfea17 	ldw	r2,-88(fp)
 82389d0:	10001126 	beq	r2,zero,8238a18 <tcp_output+0x718>
      {
         m->m_next = m_copy(so->so_snd.sb_mb, off, (int) len);
 82389d4:	e0bff217 	ldw	r2,-56(fp)
 82389d8:	10801817 	ldw	r2,96(r2)
 82389dc:	e1bfea17 	ldw	r6,-88(fp)
 82389e0:	e17ff417 	ldw	r5,-48(fp)
 82389e4:	1009883a 	mov	r4,r2
 82389e8:	822e67c0 	call	822e67c <m_copy>
 82389ec:	1007883a 	mov	r3,r2
 82389f0:	e0bfed17 	ldw	r2,-76(fp)
 82389f4:	10c00615 	stw	r3,24(r2)
         if (m->m_next == 0)
 82389f8:	e0bfed17 	ldw	r2,-76(fp)
 82389fc:	10800617 	ldw	r2,24(r2)
 8238a00:	1000051e 	bne	r2,zero,8238a18 <tcp_output+0x718>
         {
            m_freem(m);
 8238a04:	e13fed17 	ldw	r4,-76(fp)
 8238a08:	822e6380 	call	822e638 <m_freem>
            EXIT_CRIT_SECTION(tp);
 8238a0c:	822d7cc0 	call	822d7cc <irq_Unmask>
            return ENOBUFS;
 8238a10:	00801a44 	movi	r2,105
 8238a14:	00023606 	br	82392f0 <tcp_output+0xff0>
         }
      }
   }
   EXIT_CRIT_SECTION(tp);
 8238a18:	822d7cc0 	call	822d7cc <irq_Unmask>

   if (len) 
 8238a1c:	e0bfea17 	ldw	r2,-88(fp)
 8238a20:	10003726 	beq	r2,zero,8238b00 <tcp_output+0x800>
   {
      if (tp->t_force && len == 1)
 8238a24:	e0bfff17 	ldw	r2,-4(fp)
 8238a28:	10800a83 	ldbu	r2,42(r2)
 8238a2c:	10803fcc 	andi	r2,r2,255
 8238a30:	1080201c 	xori	r2,r2,128
 8238a34:	10bfe004 	addi	r2,r2,-128
 8238a38:	10000b26 	beq	r2,zero,8238a68 <tcp_output+0x768>
 8238a3c:	e0bfea17 	ldw	r2,-88(fp)
 8238a40:	10800058 	cmpnei	r2,r2,1
 8238a44:	1000081e 	bne	r2,zero,8238a68 <tcp_output+0x768>
         tcpstat.tcps_sndprobe++;
 8238a48:	008209b4 	movhi	r2,2086
 8238a4c:	10b98b04 	addi	r2,r2,-6612
 8238a50:	10801517 	ldw	r2,84(r2)
 8238a54:	10c00044 	addi	r3,r2,1
 8238a58:	008209b4 	movhi	r2,2086
 8238a5c:	10b98b04 	addi	r2,r2,-6612
 8238a60:	10c01515 	stw	r3,84(r2)
 8238a64:	00005306 	br	8238bb4 <tcp_output+0x8b4>
      else if (SEQ_LT(tp->snd_nxt, tp->snd_max)) 
 8238a68:	e0bfff17 	ldw	r2,-4(fp)
 8238a6c:	10c00f17 	ldw	r3,60(r2)
 8238a70:	e0bfff17 	ldw	r2,-4(fp)
 8238a74:	10801a17 	ldw	r2,104(r2)
 8238a78:	1885c83a 	sub	r2,r3,r2
 8238a7c:	1000100e 	bge	r2,zero,8238ac0 <tcp_output+0x7c0>
      {
         tcpstat.tcps_sndrexmitpack++;
 8238a80:	008209b4 	movhi	r2,2086
 8238a84:	10b98b04 	addi	r2,r2,-6612
 8238a88:	10801217 	ldw	r2,72(r2)
 8238a8c:	10c00044 	addi	r3,r2,1
 8238a90:	008209b4 	movhi	r2,2086
 8238a94:	10b98b04 	addi	r2,r2,-6612
 8238a98:	10c01215 	stw	r3,72(r2)
         tcpstat.tcps_sndrexmitbyte += len;
 8238a9c:	008209b4 	movhi	r2,2086
 8238aa0:	10b98b04 	addi	r2,r2,-6612
 8238aa4:	10c01317 	ldw	r3,76(r2)
 8238aa8:	e0bfea17 	ldw	r2,-88(fp)
 8238aac:	1887883a 	add	r3,r3,r2
 8238ab0:	008209b4 	movhi	r2,2086
 8238ab4:	10b98b04 	addi	r2,r2,-6612
 8238ab8:	10c01315 	stw	r3,76(r2)
 8238abc:	00003d06 	br	8238bb4 <tcp_output+0x8b4>
         tcpstat.tcps_sackresend++;
#endif
      } 
      else 
      {
         tcpstat.tcps_sndpack++;
 8238ac0:	008209b4 	movhi	r2,2086
 8238ac4:	10b98b04 	addi	r2,r2,-6612
 8238ac8:	10801017 	ldw	r2,64(r2)
 8238acc:	10c00044 	addi	r3,r2,1
 8238ad0:	008209b4 	movhi	r2,2086
 8238ad4:	10b98b04 	addi	r2,r2,-6612
 8238ad8:	10c01015 	stw	r3,64(r2)
         tcpstat.tcps_sndbyte += len;
 8238adc:	008209b4 	movhi	r2,2086
 8238ae0:	10b98b04 	addi	r2,r2,-6612
 8238ae4:	10c01117 	ldw	r3,68(r2)
 8238ae8:	e0bfea17 	ldw	r2,-88(fp)
 8238aec:	1887883a 	add	r3,r3,r2
 8238af0:	008209b4 	movhi	r2,2086
 8238af4:	10b98b04 	addi	r2,r2,-6612
 8238af8:	10c01115 	stw	r3,68(r2)
 8238afc:	00002d06 	br	8238bb4 <tcp_output+0x8b4>
      }
   }
   else if (tp->t_flags & TF_ACKNOW)
 8238b00:	e0bfff17 	ldw	r2,-4(fp)
 8238b04:	10800b0b 	ldhu	r2,44(r2)
 8238b08:	10bfffcc 	andi	r2,r2,65535
 8238b0c:	1080004c 	andi	r2,r2,1
 8238b10:	10000826 	beq	r2,zero,8238b34 <tcp_output+0x834>
   {
      tcpstat.tcps_sndacks++;
 8238b14:	008209b4 	movhi	r2,2086
 8238b18:	10b98b04 	addi	r2,r2,-6612
 8238b1c:	10801417 	ldw	r2,80(r2)
 8238b20:	10c00044 	addi	r3,r2,1
 8238b24:	008209b4 	movhi	r2,2086
 8238b28:	10b98b04 	addi	r2,r2,-6612
 8238b2c:	10c01415 	stw	r3,80(r2)
 8238b30:	00002006 	br	8238bb4 <tcp_output+0x8b4>
   }
   else if (flags & (TH_SYN|TH_FIN|TH_RST))
 8238b34:	e0bfec17 	ldw	r2,-80(fp)
 8238b38:	108001cc 	andi	r2,r2,7
 8238b3c:	10000826 	beq	r2,zero,8238b60 <tcp_output+0x860>
      tcpstat.tcps_sndctrl++;
 8238b40:	008209b4 	movhi	r2,2086
 8238b44:	10b98b04 	addi	r2,r2,-6612
 8238b48:	10801817 	ldw	r2,96(r2)
 8238b4c:	10c00044 	addi	r3,r2,1
 8238b50:	008209b4 	movhi	r2,2086
 8238b54:	10b98b04 	addi	r2,r2,-6612
 8238b58:	10c01815 	stw	r3,96(r2)
 8238b5c:	00001506 	br	8238bb4 <tcp_output+0x8b4>
   else if (SEQ_GT(tp->snd_up, tp->snd_una))
 8238b60:	e0bfff17 	ldw	r2,-4(fp)
 8238b64:	10c01017 	ldw	r3,64(r2)
 8238b68:	e0bfff17 	ldw	r2,-4(fp)
 8238b6c:	10800e17 	ldw	r2,56(r2)
 8238b70:	1885c83a 	sub	r2,r3,r2
 8238b74:	0080080e 	bge	zero,r2,8238b98 <tcp_output+0x898>
      tcpstat.tcps_sndurg++;
 8238b78:	008209b4 	movhi	r2,2086
 8238b7c:	10b98b04 	addi	r2,r2,-6612
 8238b80:	10801617 	ldw	r2,88(r2)
 8238b84:	10c00044 	addi	r3,r2,1
 8238b88:	008209b4 	movhi	r2,2086
 8238b8c:	10b98b04 	addi	r2,r2,-6612
 8238b90:	10c01615 	stw	r3,88(r2)
 8238b94:	00000706 	br	8238bb4 <tcp_output+0x8b4>
   else
      tcpstat.tcps_sndwinup++;
 8238b98:	008209b4 	movhi	r2,2086
 8238b9c:	10b98b04 	addi	r2,r2,-6612
 8238ba0:	10801717 	ldw	r2,92(r2)
 8238ba4:	10c00044 	addi	r3,r2,1
 8238ba8:	008209b4 	movhi	r2,2086
 8238bac:	10b98b04 	addi	r2,r2,-6612
 8238bb0:	10c01715 	stw	r3,92(r2)

   ti = (struct tcpiphdr *)(m->m_data+sizeof(struct ip)-sizeof(struct ipovly));
 8238bb4:	e0bfed17 	ldw	r2,-76(fp)
 8238bb8:	10800317 	ldw	r2,12(r2)
 8238bbc:	e0bff515 	stw	r2,-44(fp)
   if ((char *)ti < m->pkt->nb_buff)
 8238bc0:	e0bfed17 	ldw	r2,-76(fp)
 8238bc4:	10800117 	ldw	r2,4(r2)
 8238bc8:	10800117 	ldw	r2,4(r2)
 8238bcc:	e0fff517 	ldw	r3,-44(fp)
 8238bd0:	1880032e 	bgeu	r3,r2,8238be0 <tcp_output+0x8e0>
   {
      panic("tcp_out- packet ptr underflow\n");
 8238bd4:	01020974 	movhi	r4,2085
 8238bd8:	2103a204 	addi	r4,r4,3720
 8238bdc:	8228c480 	call	8228c48 <panic>
   }
   tcp_mbuf = m;        /* flag TCP header mbuf */
 8238be0:	e0bfed17 	ldw	r2,-76(fp)
 8238be4:	e0bff615 	stw	r2,-40(fp)
      tcp_mbuf->m_data += sizeof(struct ipovly);
      tcp_mbuf->m_len -= sizeof(struct ipovly);
   }
#endif   /* end IP_V6 */

   if (tp->t_template == 0)
 8238be8:	e0bfff17 	ldw	r2,-4(fp)
 8238bec:	10800c17 	ldw	r2,48(r2)
 8238bf0:	1000031e 	bne	r2,zero,8238c00 <tcp_output+0x900>
      panic("tcp_output");
 8238bf4:	01020974 	movhi	r4,2085
 8238bf8:	2103aa04 	addi	r4,r4,3752
 8238bfc:	8228c480 	call	8228c48 <panic>

   MEMCPY((char*)ti, (char*)tp->t_template, sizeof(struct tcpiphdr));
 8238c00:	e0bfff17 	ldw	r2,-4(fp)
 8238c04:	10800c17 	ldw	r2,48(r2)
 8238c08:	01800a04 	movi	r6,40
 8238c0c:	100b883a 	mov	r5,r2
 8238c10:	e13ff517 	ldw	r4,-44(fp)
 8238c14:	8202f100 	call	8202f10 <memcpy>
   /*
    * Fill in fields, remembering maximum advertised
    * window for use in delaying messages about window sizes.
    * If resending a FIN, be sure not to use a new sequence number.
    */
   if (flags & TH_FIN && tp->t_flags & TF_SENTFIN && 
 8238c18:	e0bfec17 	ldw	r2,-80(fp)
 8238c1c:	1080004c 	andi	r2,r2,1
 8238c20:	10000f26 	beq	r2,zero,8238c60 <tcp_output+0x960>
 8238c24:	e0bfff17 	ldw	r2,-4(fp)
 8238c28:	10800b0b 	ldhu	r2,44(r2)
 8238c2c:	10bfffcc 	andi	r2,r2,65535
 8238c30:	1080040c 	andi	r2,r2,16
 8238c34:	10000a26 	beq	r2,zero,8238c60 <tcp_output+0x960>
       tp->snd_nxt == tp->snd_max)
 8238c38:	e0bfff17 	ldw	r2,-4(fp)
 8238c3c:	10c00f17 	ldw	r3,60(r2)
 8238c40:	e0bfff17 	ldw	r2,-4(fp)
 8238c44:	10801a17 	ldw	r2,104(r2)
   /*
    * Fill in fields, remembering maximum advertised
    * window for use in delaying messages about window sizes.
    * If resending a FIN, be sure not to use a new sequence number.
    */
   if (flags & TH_FIN && tp->t_flags & TF_SENTFIN && 
 8238c48:	1880051e 	bne	r3,r2,8238c60 <tcp_output+0x960>
       tp->snd_nxt == tp->snd_max)
   {
      tp->snd_nxt--;
 8238c4c:	e0bfff17 	ldw	r2,-4(fp)
 8238c50:	10800f17 	ldw	r2,60(r2)
 8238c54:	10ffffc4 	addi	r3,r2,-1
 8238c58:	e0bfff17 	ldw	r2,-4(fp)
 8238c5c:	10c00f15 	stw	r3,60(r2)
   }

   ti->ti_seq = htonl(tp->snd_nxt);
 8238c60:	e0bfff17 	ldw	r2,-4(fp)
 8238c64:	10800f17 	ldw	r2,60(r2)
 8238c68:	1006d63a 	srli	r3,r2,24
 8238c6c:	e0bfff17 	ldw	r2,-4(fp)
 8238c70:	10800f17 	ldw	r2,60(r2)
 8238c74:	1004d23a 	srli	r2,r2,8
 8238c78:	10bfc00c 	andi	r2,r2,65280
 8238c7c:	1886b03a 	or	r3,r3,r2
 8238c80:	e0bfff17 	ldw	r2,-4(fp)
 8238c84:	10800f17 	ldw	r2,60(r2)
 8238c88:	10bfc00c 	andi	r2,r2,65280
 8238c8c:	1004923a 	slli	r2,r2,8
 8238c90:	1886b03a 	or	r3,r3,r2
 8238c94:	e0bfff17 	ldw	r2,-4(fp)
 8238c98:	10800f17 	ldw	r2,60(r2)
 8238c9c:	1004963a 	slli	r2,r2,24
 8238ca0:	1886b03a 	or	r3,r3,r2
 8238ca4:	e0bff517 	ldw	r2,-44(fp)
 8238ca8:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(tp->rcv_nxt);
 8238cac:	e0bfff17 	ldw	r2,-4(fp)
 8238cb0:	10801617 	ldw	r2,88(r2)
 8238cb4:	1006d63a 	srli	r3,r2,24
 8238cb8:	e0bfff17 	ldw	r2,-4(fp)
 8238cbc:	10801617 	ldw	r2,88(r2)
 8238cc0:	1004d23a 	srli	r2,r2,8
 8238cc4:	10bfc00c 	andi	r2,r2,65280
 8238cc8:	1886b03a 	or	r3,r3,r2
 8238ccc:	e0bfff17 	ldw	r2,-4(fp)
 8238cd0:	10801617 	ldw	r2,88(r2)
 8238cd4:	10bfc00c 	andi	r2,r2,65280
 8238cd8:	1004923a 	slli	r2,r2,8
 8238cdc:	1886b03a 	or	r3,r3,r2
 8238ce0:	e0bfff17 	ldw	r2,-4(fp)
 8238ce4:	10801617 	ldw	r2,88(r2)
 8238ce8:	1004963a 	slli	r2,r2,24
 8238cec:	1886b03a 	or	r3,r3,r2
 8238cf0:	e0bff517 	ldw	r2,-44(fp)
 8238cf4:	10c00715 	stw	r3,28(r2)
    * a retransmission, and the original SYN caused PPP to start
    * bringing the interface up, and PPP has got a new IP address
    * via IPCP), update the template and the inpcb with the new 
    * address.
    */
   if (flags & TH_SYN)
 8238cf8:	e0bfec17 	ldw	r2,-80(fp)
 8238cfc:	1080008c 	andi	r2,r2,2
 8238d00:	10002426 	beq	r2,zero,8238d94 <tcp_output+0xa94>
   {
      struct inpcb * inp;
      inp = (struct inpcb *)so->so_pcb;
 8238d04:	e0bff217 	ldw	r2,-56(fp)
 8238d08:	10800117 	ldw	r2,4(r2)
 8238d0c:	e0bff715 	stw	r2,-36(fp)

      switch(so->so_domain)
 8238d10:	e0bff217 	ldw	r2,-56(fp)
 8238d14:	10800517 	ldw	r2,20(r2)
 8238d18:	108000a0 	cmpeqi	r2,r2,2
 8238d1c:	10001a26 	beq	r2,zero,8238d88 <tcp_output+0xa88>
         }
         }
#endif   /* INCLUDE_PPP */

         /* If this is a SYN (not a SYN/ACK) then set the pmtu */
         if((flags & TH_ACK) == 0)
 8238d20:	e0bfec17 	ldw	r2,-80(fp)
 8238d24:	1080040c 	andi	r2,r2,16
 8238d28:	1000191e 	bne	r2,zero,8238d90 <tcp_output+0xa90>
            inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
            {
               NET ifp;
               /* find iface for route. Pass "src" as nexthop return */
               ifp = iproute(ti->ti_dst.s_addr, &src);
 8238d2c:	e0bff517 	ldw	r2,-44(fp)
 8238d30:	10800417 	ldw	r2,16(r2)
 8238d34:	e0fffe04 	addi	r3,fp,-8
 8238d38:	180b883a 	mov	r5,r3
 8238d3c:	1009883a 	mov	r4,r2
 8238d40:	8240ce80 	call	8240ce8 <iproute>
 8238d44:	e0bff815 	stw	r2,-32(fp)
               if(ifp)
 8238d48:	e0bff817 	ldw	r2,-32(fp)
 8238d4c:	10000926 	beq	r2,zero,8238d74 <tcp_output+0xa74>
                  inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 8238d50:	e0bff817 	ldw	r2,-32(fp)
 8238d54:	10c00917 	ldw	r3,36(r2)
 8238d58:	e0bff817 	ldw	r2,-32(fp)
 8238d5c:	10800817 	ldw	r2,32(r2)
 8238d60:	10800a04 	addi	r2,r2,40
 8238d64:	1887c83a 	sub	r3,r3,r2
 8238d68:	e0bff717 	ldw	r2,-36(fp)
 8238d6c:	10c00615 	stw	r3,24(r2)
               else
                  inp->inp_pmtu = 580;  /* Ugh. */
            }
#endif   /* IP_PMTU */
         }
         break;
 8238d70:	00000706 	br	8238d90 <tcp_output+0xa90>
               /* find iface for route. Pass "src" as nexthop return */
               ifp = iproute(ti->ti_dst.s_addr, &src);
               if(ifp)
                  inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
               else
                  inp->inp_pmtu = 580;  /* Ugh. */
 8238d74:	e0bff717 	ldw	r2,-36(fp)
 8238d78:	00c09104 	movi	r3,580
 8238d7c:	10c00615 	stw	r3,24(r2)
            }
#endif   /* IP_PMTU */
         }
         break;
 8238d80:	0001883a 	nop
 8238d84:	00000206 	br	8238d90 <tcp_output+0xa90>
         }
         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();    /* bad domain setting */
 8238d88:	822d5940 	call	822d594 <dtrap>
 8238d8c:	00000106 	br	8238d94 <tcp_output+0xa94>
               else
                  inp->inp_pmtu = 580;  /* Ugh. */
            }
#endif   /* IP_PMTU */
         }
         break;
 8238d90:	0001883a 	nop
         dtrap();    /* bad domain setting */
      }
   }

   /* fill in options if any are set */
   if (optlen)
 8238d94:	e0bfee17 	ldw	r2,-72(fp)
 8238d98:	10002b26 	beq	r2,zero,8238e48 <tcp_output+0xb48>
   {
      struct mbuf * mopt;

      mopt = m_getwithdata(MT_TXDATA, MAXOPTLEN);
 8238d9c:	01404004 	movi	r5,256
 8238da0:	01000084 	movi	r4,2
 8238da4:	822e3a80 	call	822e3a8 <m_getnbuf>
 8238da8:	e0bff915 	stw	r2,-28(fp)
      if (mopt == NULL) 
 8238dac:	e0bff917 	ldw	r2,-28(fp)
 8238db0:	1000041e 	bne	r2,zero,8238dc4 <tcp_output+0xac4>
      {
         m_freem(m);
 8238db4:	e13fed17 	ldw	r4,-76(fp)
 8238db8:	822e6380 	call	822e638 <m_freem>
         return (ENOBUFS);
 8238dbc:	00801a44 	movi	r2,105
 8238dc0:	00014b06 	br	82392f0 <tcp_output+0xff0>
      }

      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
 8238dc4:	e0bff617 	ldw	r2,-40(fp)
 8238dc8:	10c00617 	ldw	r3,24(r2)
 8238dcc:	e0bff917 	ldw	r2,-28(fp)
 8238dd0:	10c00615 	stw	r3,24(r2)
      tcp_mbuf->m_next = mopt;
 8238dd4:	e0bff617 	ldw	r2,-40(fp)
 8238dd8:	e0fff917 	ldw	r3,-28(fp)
 8238ddc:	10c00615 	stw	r3,24(r2)

      /* extend options to aligned address */
      while(optlen & 0x03)
 8238de0:	00000606 	br	8238dfc <tcp_output+0xafc>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;
 8238de4:	e0bfee17 	ldw	r2,-72(fp)
 8238de8:	10c00044 	addi	r3,r2,1
 8238dec:	e0ffee15 	stw	r3,-72(fp)
 8238df0:	d0e0b304 	addi	r3,gp,-32052
 8238df4:	10c5883a 	add	r2,r2,r3
 8238df8:	10000005 	stb	zero,0(r2)
      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
      tcp_mbuf->m_next = mopt;

      /* extend options to aligned address */
      while(optlen & 0x03)
 8238dfc:	e0bfee17 	ldw	r2,-72(fp)
 8238e00:	108000cc 	andi	r2,r2,3
 8238e04:	103ff71e 	bne	r2,zero,8238de4 <tcp_output+0xae4>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;

      MEMCPY(mtod(mopt, char *), tcp_optionbuf, optlen);
 8238e08:	e0bff917 	ldw	r2,-28(fp)
 8238e0c:	10800317 	ldw	r2,12(r2)
 8238e10:	e1bfee17 	ldw	r6,-72(fp)
 8238e14:	d160b304 	addi	r5,gp,-32052
 8238e18:	1009883a 	mov	r4,r2
 8238e1c:	8202f100 	call	8202f10 <memcpy>
      mopt->m_len = optlen;
 8238e20:	e0bff917 	ldw	r2,-28(fp)
 8238e24:	e0ffee17 	ldw	r3,-72(fp)
 8238e28:	10c00215 	stw	r3,8(r2)
      /* use portable macro to set tcp data offset bits */
      SET_TH_OFF(ti->ti_t, ((sizeof (struct tcphdr) + optlen) >> 2));
 8238e2c:	e0bfee17 	ldw	r2,-72(fp)
 8238e30:	10800504 	addi	r2,r2,20
 8238e34:	1004d0ba 	srli	r2,r2,2
 8238e38:	1004913a 	slli	r2,r2,4
 8238e3c:	1007883a 	mov	r3,r2
 8238e40:	e0bff517 	ldw	r2,-44(fp)
 8238e44:	10c00805 	stb	r3,32(r2)
   }

   ti->ti_flags = (u_char)flags;
 8238e48:	e0bfec17 	ldw	r2,-80(fp)
 8238e4c:	1007883a 	mov	r3,r2
 8238e50:	e0bff517 	ldw	r2,-44(fp)
 8238e54:	10c00845 	stb	r3,33(r2)
   /*
    * Calculate receive window. Don't shrink window,
    * but avoid silly window syndrome.
    */
   if (win < (long)(so->so_rcv.sb_hiwat / 4) && win < (long)tp->t_maxseg)
 8238e58:	e0bff217 	ldw	r2,-56(fp)
 8238e5c:	10800b17 	ldw	r2,44(r2)
 8238e60:	1004d0ba 	srli	r2,r2,2
 8238e64:	1007883a 	mov	r3,r2
 8238e68:	e0bfeb17 	ldw	r2,-84(fp)
 8238e6c:	10c0060e 	bge	r2,r3,8238e88 <tcp_output+0xb88>
 8238e70:	e0bfff17 	ldw	r2,-4(fp)
 8238e74:	10800a0b 	ldhu	r2,40(r2)
 8238e78:	10bfffcc 	andi	r2,r2,65535
 8238e7c:	e0ffeb17 	ldw	r3,-84(fp)
 8238e80:	1880010e 	bge	r3,r2,8238e88 <tcp_output+0xb88>
      win = 0;
 8238e84:	e03feb15 	stw	zero,-84(fp)
   if (win < (long)(tp->rcv_adv - tp->rcv_nxt))
 8238e88:	e0bfff17 	ldw	r2,-4(fp)
 8238e8c:	10c01917 	ldw	r3,100(r2)
 8238e90:	e0bfff17 	ldw	r2,-4(fp)
 8238e94:	10801617 	ldw	r2,88(r2)
 8238e98:	1885c83a 	sub	r2,r3,r2
 8238e9c:	1007883a 	mov	r3,r2
 8238ea0:	e0bfeb17 	ldw	r2,-84(fp)
 8238ea4:	10c0060e 	bge	r2,r3,8238ec0 <tcp_output+0xbc0>
      win = (long)(tp->rcv_adv - tp->rcv_nxt);
 8238ea8:	e0bfff17 	ldw	r2,-4(fp)
 8238eac:	10c01917 	ldw	r3,100(r2)
 8238eb0:	e0bfff17 	ldw	r2,-4(fp)
 8238eb4:	10801617 	ldw	r2,88(r2)
 8238eb8:	1885c83a 	sub	r2,r3,r2
 8238ebc:	e0bfeb15 	stw	r2,-84(fp)

   /* do check for Iniche buffer limits -JB- */
   if (bigfreeq.q_len == 0)   /* If queue length is 0, set window to 0 */
 8238ec0:	008209b4 	movhi	r2,2086
 8238ec4:	10b8c204 	addi	r2,r2,-7416
 8238ec8:	10800217 	ldw	r2,8(r2)
 8238ecc:	1000021e 	bne	r2,zero,8238ed8 <tcp_output+0xbd8>
   {
      win = 0;
 8238ed0:	e03feb15 	stw	zero,-84(fp)
 8238ed4:	00001006 	br	8238f18 <tcp_output+0xc18>
   }
   else if(win > (((long)bigfreeq.q_len - 1) * (long)bigbufsiz))
 8238ed8:	008209b4 	movhi	r2,2086
 8238edc:	10b8c204 	addi	r2,r2,-7416
 8238ee0:	10800217 	ldw	r2,8(r2)
 8238ee4:	10bfffc4 	addi	r2,r2,-1
 8238ee8:	d0e03917 	ldw	r3,-32540(gp)
 8238eec:	10c7383a 	mul	r3,r2,r3
 8238ef0:	e0bfeb17 	ldw	r2,-84(fp)
 8238ef4:	1880080e 	bge	r3,r2,8238f18 <tcp_output+0xc18>
   {
      win = ((long)bigfreeq.q_len - 1) * bigbufsiz;
 8238ef8:	008209b4 	movhi	r2,2086
 8238efc:	10b8c204 	addi	r2,r2,-7416
 8238f00:	10800217 	ldw	r2,8(r2)
 8238f04:	10bfffc4 	addi	r2,r2,-1
 8238f08:	1007883a 	mov	r3,r2
 8238f0c:	d0a03917 	ldw	r2,-32540(gp)
 8238f10:	1885383a 	mul	r2,r3,r2
 8238f14:	e0bfeb15 	stw	r2,-84(fp)
      ti->ti_win = htons((u_short)(win >> tp->rcv_wind_scale)); /* apply scale */
   }
   else
#endif /* TCP_WIN_SCALE */
   {
      ti->ti_win = htons((u_short)win);
 8238f18:	e0bfeb17 	ldw	r2,-84(fp)
 8238f1c:	10bfffcc 	andi	r2,r2,65535
 8238f20:	1005d23a 	srai	r2,r2,8
 8238f24:	10803fcc 	andi	r2,r2,255
 8238f28:	1007883a 	mov	r3,r2
 8238f2c:	e0bfeb17 	ldw	r2,-84(fp)
 8238f30:	10bfffcc 	andi	r2,r2,65535
 8238f34:	1004923a 	slli	r2,r2,8
 8238f38:	1884b03a 	or	r2,r3,r2
 8238f3c:	1007883a 	mov	r3,r2
 8238f40:	e0bff517 	ldw	r2,-44(fp)
 8238f44:	10c0088d 	sth	r3,34(r2)
   }

   if (SEQ_GT(tp->snd_up, tp->snd_nxt)) 
 8238f48:	e0bfff17 	ldw	r2,-4(fp)
 8238f4c:	10c01017 	ldw	r3,64(r2)
 8238f50:	e0bfff17 	ldw	r2,-4(fp)
 8238f54:	10800f17 	ldw	r2,60(r2)
 8238f58:	1885c83a 	sub	r2,r3,r2
 8238f5c:	00801c0e 	bge	zero,r2,8238fd0 <tcp_output+0xcd0>
   {
      ti->ti_urp = htons((u_short)(tp->snd_up - tp->snd_nxt));
 8238f60:	e0bfff17 	ldw	r2,-4(fp)
 8238f64:	10801017 	ldw	r2,64(r2)
 8238f68:	1007883a 	mov	r3,r2
 8238f6c:	e0bfff17 	ldw	r2,-4(fp)
 8238f70:	10800f17 	ldw	r2,60(r2)
 8238f74:	1885c83a 	sub	r2,r3,r2
 8238f78:	10bfffcc 	andi	r2,r2,65535
 8238f7c:	1004d23a 	srli	r2,r2,8
 8238f80:	1007883a 	mov	r3,r2
 8238f84:	e0bfff17 	ldw	r2,-4(fp)
 8238f88:	10801017 	ldw	r2,64(r2)
 8238f8c:	1009883a 	mov	r4,r2
 8238f90:	e0bfff17 	ldw	r2,-4(fp)
 8238f94:	10800f17 	ldw	r2,60(r2)
 8238f98:	2085c83a 	sub	r2,r4,r2
 8238f9c:	10bfffcc 	andi	r2,r2,65535
 8238fa0:	1004923a 	slli	r2,r2,8
 8238fa4:	1884b03a 	or	r2,r3,r2
 8238fa8:	1007883a 	mov	r3,r2
 8238fac:	e0bff517 	ldw	r2,-44(fp)
 8238fb0:	10c0098d 	sth	r3,38(r2)
      ti->ti_flags |= TH_URG;
 8238fb4:	e0bff517 	ldw	r2,-44(fp)
 8238fb8:	10800843 	ldbu	r2,33(r2)
 8238fbc:	10800814 	ori	r2,r2,32
 8238fc0:	1007883a 	mov	r3,r2
 8238fc4:	e0bff517 	ldw	r2,-44(fp)
 8238fc8:	10c00845 	stb	r3,33(r2)
 8238fcc:	00000406 	br	8238fe0 <tcp_output+0xce0>
       * If no urgent pointer to send, then we pull
       * the urgent pointer to the left edge of the send window
       * so that it doesn't drift into the send window on sequence
       * number wraparound.
       */
      tp->snd_up = tp->snd_una;        /* drag it along */
 8238fd0:	e0bfff17 	ldw	r2,-4(fp)
 8238fd4:	10c00e17 	ldw	r3,56(r2)
 8238fd8:	e0bfff17 	ldw	r2,-4(fp)
 8238fdc:	10c01015 	stw	r3,64(r2)
   /*
    * If anything to send and we can send it all, set PUSH.
    * (This will keep happy those implementations which only
    * give data to the user when a buffer fills or a PUSH comes in.)
    */
   if (len && off+len == (int)so->so_snd.sb_cc)
 8238fe0:	e0bfea17 	ldw	r2,-88(fp)
 8238fe4:	10000c26 	beq	r2,zero,8239018 <tcp_output+0xd18>
 8238fe8:	e0fff417 	ldw	r3,-48(fp)
 8238fec:	e0bfea17 	ldw	r2,-88(fp)
 8238ff0:	1885883a 	add	r2,r3,r2
 8238ff4:	e0fff217 	ldw	r3,-56(fp)
 8238ff8:	18c01217 	ldw	r3,72(r3)
 8238ffc:	10c0061e 	bne	r2,r3,8239018 <tcp_output+0xd18>
      ti->ti_flags |= TH_PUSH;
 8239000:	e0bff517 	ldw	r2,-44(fp)
 8239004:	10800843 	ldbu	r2,33(r2)
 8239008:	10800214 	ori	r2,r2,8
 823900c:	1007883a 	mov	r3,r2
 8239010:	e0bff517 	ldw	r2,-44(fp)
 8239014:	10c00845 	stb	r3,33(r2)

   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
 8239018:	e0bfff17 	ldw	r2,-4(fp)
 823901c:	10800a83 	ldbu	r2,42(r2)
 8239020:	10803fcc 	andi	r2,r2,255
 8239024:	1080201c 	xori	r2,r2,128
 8239028:	10bfe004 	addi	r2,r2,-128
 823902c:	10000326 	beq	r2,zero,823903c <tcp_output+0xd3c>
 8239030:	e0bfff17 	ldw	r2,-4(fp)
 8239034:	10800417 	ldw	r2,16(r2)
 8239038:	10004d1e 	bne	r2,zero,8239170 <tcp_output+0xe70>
   {
      tcp_seq startseq = tp->snd_nxt;
 823903c:	e0bfff17 	ldw	r2,-4(fp)
 8239040:	10800f17 	ldw	r2,60(r2)
 8239044:	e0bffa15 	stw	r2,-24(fp)

      /*
       * Advance snd_nxt over sequence space of this segment.
       */
      if (flags & TH_SYN)
 8239048:	e0bfec17 	ldw	r2,-80(fp)
 823904c:	1080008c 	andi	r2,r2,2
 8239050:	10000526 	beq	r2,zero,8239068 <tcp_output+0xd68>
         tp->snd_nxt++;
 8239054:	e0bfff17 	ldw	r2,-4(fp)
 8239058:	10800f17 	ldw	r2,60(r2)
 823905c:	10c00044 	addi	r3,r2,1
 8239060:	e0bfff17 	ldw	r2,-4(fp)
 8239064:	10c00f15 	stw	r3,60(r2)

      if (flags & TH_FIN)
 8239068:	e0bfec17 	ldw	r2,-80(fp)
 823906c:	1080004c 	andi	r2,r2,1
 8239070:	10000b26 	beq	r2,zero,82390a0 <tcp_output+0xda0>
      {
         tp->snd_nxt++;
 8239074:	e0bfff17 	ldw	r2,-4(fp)
 8239078:	10800f17 	ldw	r2,60(r2)
 823907c:	10c00044 	addi	r3,r2,1
 8239080:	e0bfff17 	ldw	r2,-4(fp)
 8239084:	10c00f15 	stw	r3,60(r2)
         tp->t_flags |= TF_SENTFIN;
 8239088:	e0bfff17 	ldw	r2,-4(fp)
 823908c:	10800b0b 	ldhu	r2,44(r2)
 8239090:	10800414 	ori	r2,r2,16
 8239094:	1007883a 	mov	r3,r2
 8239098:	e0bfff17 	ldw	r2,-4(fp)
 823909c:	10c00b0d 	sth	r3,44(r2)
      }
      tp->snd_nxt += len;
 82390a0:	e0bfff17 	ldw	r2,-4(fp)
 82390a4:	10c00f17 	ldw	r3,60(r2)
 82390a8:	e0bfea17 	ldw	r2,-88(fp)
 82390ac:	1887883a 	add	r3,r3,r2
 82390b0:	e0bfff17 	ldw	r2,-4(fp)
 82390b4:	10c00f15 	stw	r3,60(r2)
      if (SEQ_GT(tp->snd_nxt, tp->snd_max)) 
 82390b8:	e0bfff17 	ldw	r2,-4(fp)
 82390bc:	10c00f17 	ldw	r3,60(r2)
 82390c0:	e0bfff17 	ldw	r2,-4(fp)
 82390c4:	10801a17 	ldw	r2,104(r2)
 82390c8:	1885c83a 	sub	r2,r3,r2
 82390cc:	0080140e 	bge	zero,r2,8239120 <tcp_output+0xe20>
      {
         tp->snd_max = tp->snd_nxt;
 82390d0:	e0bfff17 	ldw	r2,-4(fp)
 82390d4:	10c00f17 	ldw	r3,60(r2)
 82390d8:	e0bfff17 	ldw	r2,-4(fp)
 82390dc:	10c01a15 	stw	r3,104(r2)
         /*
          * Time this transmission if not a retransmission and
          * not currently timing anything.
          */
         if (tp->t_rttick == 0) 
 82390e0:	e0bfff17 	ldw	r2,-4(fp)
 82390e4:	10801e17 	ldw	r2,120(r2)
 82390e8:	10000d1e 	bne	r2,zero,8239120 <tcp_output+0xe20>
         {
            tp->t_rttick = cticks;
 82390ec:	d0e0a817 	ldw	r3,-32096(gp)
 82390f0:	e0bfff17 	ldw	r2,-4(fp)
 82390f4:	10c01e15 	stw	r3,120(r2)
            tp->t_rtseq = startseq;
 82390f8:	e0bfff17 	ldw	r2,-4(fp)
 82390fc:	e0fffa17 	ldw	r3,-24(fp)
 8239100:	10c01f15 	stw	r3,124(r2)
            tcpstat.tcps_segstimed++;
 8239104:	008209b4 	movhi	r2,2086
 8239108:	10b98b04 	addi	r2,r2,-6612
 823910c:	10800617 	ldw	r2,24(r2)
 8239110:	10c00044 	addi	r3,r2,1
 8239114:	008209b4 	movhi	r2,2086
 8239118:	10b98b04 	addi	r2,r2,-6612
 823911c:	10c00615 	stw	r3,24(r2)
       * Initial value for retransmit timer is smoothed
       * round-trip time + 2 * round-trip time variance.
       * Initialize shift counter which is used for backoff
       * of retransmit time.
       */
      if (tp->t_timer[TCPT_REXMT] == 0 &&
 8239120:	e0bfff17 	ldw	r2,-4(fp)
 8239124:	10800317 	ldw	r2,12(r2)
 8239128:	1000201e 	bne	r2,zero,82391ac <tcp_output+0xeac>
          tp->snd_nxt != tp->snd_una) 
 823912c:	e0bfff17 	ldw	r2,-4(fp)
 8239130:	10c00f17 	ldw	r3,60(r2)
 8239134:	e0bfff17 	ldw	r2,-4(fp)
 8239138:	10800e17 	ldw	r2,56(r2)
       * Initial value for retransmit timer is smoothed
       * round-trip time + 2 * round-trip time variance.
       * Initialize shift counter which is used for backoff
       * of retransmit time.
       */
      if (tp->t_timer[TCPT_REXMT] == 0 &&
 823913c:	18801b26 	beq	r3,r2,82391ac <tcp_output+0xeac>
          tp->snd_nxt != tp->snd_una) 
      {
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 8239140:	e0bfff17 	ldw	r2,-4(fp)
 8239144:	10c00817 	ldw	r3,32(r2)
 8239148:	e0bfff17 	ldw	r2,-4(fp)
 823914c:	10c00315 	stw	r3,12(r2)
         if (tp->t_timer[TCPT_PERSIST]) 
 8239150:	e0bfff17 	ldw	r2,-4(fp)
 8239154:	10800417 	ldw	r2,16(r2)
 8239158:	10001426 	beq	r2,zero,82391ac <tcp_output+0xeac>
         {
            tp->t_timer[TCPT_PERSIST] = 0;
 823915c:	e0bfff17 	ldw	r2,-4(fp)
 8239160:	10000415 	stw	zero,16(r2)
            tp->t_rxtshift = 0;
 8239164:	e0bfff17 	ldw	r2,-4(fp)
 8239168:	10000715 	stw	zero,28(r2)
   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
   {
 823916c:	00000f06 	br	82391ac <tcp_output+0xeac>
         }
      }
   }
   else
   {
      if (SEQ_GT(tp->snd_nxt + len, tp->snd_max))
 8239170:	e0bfff17 	ldw	r2,-4(fp)
 8239174:	10c00f17 	ldw	r3,60(r2)
 8239178:	e0bfea17 	ldw	r2,-88(fp)
 823917c:	1887883a 	add	r3,r3,r2
 8239180:	e0bfff17 	ldw	r2,-4(fp)
 8239184:	10801a17 	ldw	r2,104(r2)
 8239188:	1885c83a 	sub	r2,r3,r2
 823918c:	0080080e 	bge	zero,r2,82391b0 <tcp_output+0xeb0>
         tp->snd_max = tp->snd_nxt + len;
 8239190:	e0bfff17 	ldw	r2,-4(fp)
 8239194:	10c00f17 	ldw	r3,60(r2)
 8239198:	e0bfea17 	ldw	r2,-88(fp)
 823919c:	1887883a 	add	r3,r3,r2
 82391a0:	e0bfff17 	ldw	r2,-4(fp)
 82391a4:	10c01a15 	stw	r3,104(r2)
 82391a8:	00000106 	br	82391b0 <tcp_output+0xeb0>
   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
   {
 82391ac:	0001883a 	nop
   tcp_trace("tcp_output: sending, state %d, tcpcb: %x",
    tp->t_state, tp );
#endif

#ifdef MUTE_WARNS
   error = 0;
 82391b0:	e03ffb15 	stw	zero,-20(fp)
   if(so->so_domain != AF_INET6)
#endif   /* IP_V6 */
   {
      struct ip * pip;
   
      pip = mtod(m, struct ip *);
 82391b4:	e0bfed17 	ldw	r2,-76(fp)
 82391b8:	10800317 	ldw	r2,12(r2)
 82391bc:	e0bffc15 	stw	r2,-16(fp)
      /* Fill in IP length and send to IP level. */
      pip->ip_len = (u_short)(TCPIPHDRSZ + optlen + len);
 82391c0:	e0bfee17 	ldw	r2,-72(fp)
 82391c4:	1007883a 	mov	r3,r2
 82391c8:	e0bfea17 	ldw	r2,-88(fp)
 82391cc:	1885883a 	add	r2,r3,r2
 82391d0:	10800a04 	addi	r2,r2,40
 82391d4:	1007883a 	mov	r3,r2
 82391d8:	e0bffc17 	ldw	r2,-16(fp)
 82391dc:	10c0008d 	sth	r3,2(r2)
      error = ip_output(m, so->so_optsPack);
 82391e0:	e0bff217 	ldw	r2,-56(fp)
 82391e4:	10801f17 	ldw	r2,124(r2)
 82391e8:	100b883a 	mov	r5,r2
 82391ec:	e13fed17 	ldw	r4,-76(fp)
 82391f0:	822efd40 	call	822efd4 <ip_output>
 82391f4:	e0bffb15 	stw	r2,-20(fp)
                    (sizeof(struct ipv6) + sizeof(struct tcphdr) + optlen + len),
                    (struct   ip_socopts *)0);          
   }
#endif   /* IP_V6 */

   if (error)
 82391f8:	e0bffb17 	ldw	r2,-20(fp)
 82391fc:	10001326 	beq	r2,zero,823924c <tcp_output+0xf4c>
   {
      if (error == ENOBUFS)   /* ip_output needed a copy buffer it couldn't get */
 8239200:	e0bffb17 	ldw	r2,-20(fp)
 8239204:	10801a58 	cmpnei	r2,r2,105
 8239208:	10000e1e 	bne	r2,zero,8239244 <tcp_output+0xf44>
      {
         if (m->m_type == MT_FREE)  /* ip_output() probably freed first mbuf */
 823920c:	e0bfed17 	ldw	r2,-76(fp)
 8239210:	10800817 	ldw	r2,32(r2)
 8239214:	1000031e 	bne	r2,zero,8239224 <tcp_output+0xf24>
            m = m->m_next;
 8239218:	e0bfed17 	ldw	r2,-76(fp)
 823921c:	10800617 	ldw	r2,24(r2)
 8239220:	e0bfed15 	stw	r2,-76(fp)
         m_freem(m); /* free the mbuf chain */
 8239224:	e13fed17 	ldw	r4,-76(fp)
 8239228:	822e6380 	call	822e638 <m_freem>
         tcp_quench(tp->t_inpcb);
 823922c:	e0bfff17 	ldw	r2,-4(fp)
 8239230:	10800d17 	ldw	r2,52(r2)
 8239234:	1009883a 	mov	r4,r2
 8239238:	8239cd00 	call	8239cd0 <tcp_quench>
         return (error);
 823923c:	e0bffb17 	ldw	r2,-20(fp)
 8239240:	00002b06 	br	82392f0 <tcp_output+0xff0>
      }
      return (error);
 8239244:	e0bffb17 	ldw	r2,-20(fp)
 8239248:	00002906 	br	82392f0 <tcp_output+0xff0>

   /*
    * Data sent (as far as we can tell).
    */

   TCP_MIB_INC(tcpOutSegs);   /* keep MIB stats */
 823924c:	008209b4 	movhi	r2,2086
 8239250:	10b95d04 	addi	r2,r2,-6796
 8239254:	10800a17 	ldw	r2,40(r2)
 8239258:	10c00044 	addi	r3,r2,1
 823925c:	008209b4 	movhi	r2,2086
 8239260:	10b95d04 	addi	r2,r2,-6796
 8239264:	10c00a15 	stw	r3,40(r2)
   tcpstat.tcps_sndtotal++;
 8239268:	008209b4 	movhi	r2,2086
 823926c:	10b98b04 	addi	r2,r2,-6612
 8239270:	10800f17 	ldw	r2,60(r2)
 8239274:	10c00044 	addi	r3,r2,1
 8239278:	008209b4 	movhi	r2,2086
 823927c:	10b98b04 	addi	r2,r2,-6612
 8239280:	10c00f15 	stw	r3,60(r2)
   /*
    * If this advertises a larger window than any other segment,
    * then remember the size of the advertised window.
    * Any pending ACK has now been sent.
    */
   if (win > 0 && SEQ_GT(tp->rcv_nxt+win, tp->rcv_adv))
 8239284:	e0bfeb17 	ldw	r2,-84(fp)
 8239288:	00800e0e 	bge	zero,r2,82392c4 <tcp_output+0xfc4>
 823928c:	e0bfff17 	ldw	r2,-4(fp)
 8239290:	10c01617 	ldw	r3,88(r2)
 8239294:	e0bfeb17 	ldw	r2,-84(fp)
 8239298:	1887883a 	add	r3,r3,r2
 823929c:	e0bfff17 	ldw	r2,-4(fp)
 82392a0:	10801917 	ldw	r2,100(r2)
 82392a4:	1885c83a 	sub	r2,r3,r2
 82392a8:	0080060e 	bge	zero,r2,82392c4 <tcp_output+0xfc4>
      tp->rcv_adv = tp->rcv_nxt + (unsigned)win;
 82392ac:	e0bfff17 	ldw	r2,-4(fp)
 82392b0:	10c01617 	ldw	r3,88(r2)
 82392b4:	e0bfeb17 	ldw	r2,-84(fp)
 82392b8:	1887883a 	add	r3,r3,r2
 82392bc:	e0bfff17 	ldw	r2,-4(fp)
 82392c0:	10c01915 	stw	r3,100(r2)
   tp->t_flags &= ~(TF_ACKNOW|TF_SACKNOW|TF_DELACK);
 82392c4:	e0bfff17 	ldw	r2,-4(fp)
 82392c8:	10c00b0b 	ldhu	r3,44(r2)
 82392cc:	00bfef04 	movi	r2,-68
 82392d0:	1884703a 	and	r2,r3,r2
 82392d4:	1007883a 	mov	r3,r2
 82392d8:	e0bfff17 	ldw	r2,-4(fp)
 82392dc:	10c00b0d 	sth	r3,44(r2)
   if (sendalot)
 82392e0:	e0bfef17 	ldw	r2,-68(fp)
 82392e4:	10000126 	beq	r2,zero,82392ec <tcp_output+0xfec>
      goto again;
 82392e8:	003c1606 	br	8238344 <tcp_output+0x44>
   return (0);
 82392ec:	0005883a 	mov	r2,zero
}
 82392f0:	e037883a 	mov	sp,fp
 82392f4:	dfc00117 	ldw	ra,4(sp)
 82392f8:	df000017 	ldw	fp,0(sp)
 82392fc:	dec00204 	addi	sp,sp,8
 8239300:	f800283a 	ret

08239304 <tcp_setpersist>:
 * RETURNS: NA
 */

void
tcp_setpersist(struct tcpcb * tp)
{
 8239304:	defffc04 	addi	sp,sp,-16
 8239308:	dfc00315 	stw	ra,12(sp)
 823930c:	df000215 	stw	fp,8(sp)
 8239310:	df000204 	addi	fp,sp,8
 8239314:	e13fff15 	stw	r4,-4(fp)
   int   t;

   t = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 8239318:	e0bfff17 	ldw	r2,-4(fp)
 823931c:	10802017 	ldw	r2,128(r2)
 8239320:	1007d0ba 	srai	r3,r2,2
 8239324:	e0bfff17 	ldw	r2,-4(fp)
 8239328:	10802117 	ldw	r2,132(r2)
 823932c:	1885883a 	add	r2,r3,r2
 8239330:	1005d07a 	srai	r2,r2,1
 8239334:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_timer[TCPT_REXMT])
 8239338:	e0bfff17 	ldw	r2,-4(fp)
 823933c:	10800317 	ldw	r2,12(r2)
 8239340:	10000326 	beq	r2,zero,8239350 <tcp_setpersist+0x4c>
      panic("tcp_output REXMT");
 8239344:	01020974 	movhi	r4,2085
 8239348:	2103ad04 	addi	r4,r4,3764
 823934c:	8228c480 	call	8228c48 <panic>
   /*
    * Start/restart persistance timer.
    */
   TCPT_RANGESET(tp->t_timer[TCPT_PERSIST],
 8239350:	e0bffe17 	ldw	r2,-8(fp)
 8239354:	1009883a 	mov	r4,r2
 8239358:	e0bfff17 	ldw	r2,-4(fp)
 823935c:	10c00717 	ldw	r3,28(r2)
 8239360:	00820974 	movhi	r2,2085
 8239364:	108ec5c4 	addi	r2,r2,15127
 8239368:	10c5883a 	add	r2,r2,r3
 823936c:	10800003 	ldbu	r2,0(r2)
 8239370:	10803fcc 	andi	r2,r2,255
 8239374:	2085383a 	mul	r2,r4,r2
 8239378:	10ffffcc 	andi	r3,r2,65535
 823937c:	18e0001c 	xori	r3,r3,32768
 8239380:	18e00004 	addi	r3,r3,-32768
 8239384:	e0bfff17 	ldw	r2,-4(fp)
 8239388:	10c00415 	stw	r3,16(r2)
 823938c:	e0bfff17 	ldw	r2,-4(fp)
 8239390:	10800417 	ldw	r2,16(r2)
 8239394:	10800288 	cmpgei	r2,r2,10
 8239398:	1000041e 	bne	r2,zero,82393ac <tcp_setpersist+0xa8>
 823939c:	e0bfff17 	ldw	r2,-4(fp)
 82393a0:	00c00284 	movi	r3,10
 82393a4:	10c00415 	stw	r3,16(r2)
 82393a8:	00000706 	br	82393c8 <tcp_setpersist+0xc4>
 82393ac:	e0bfff17 	ldw	r2,-4(fp)
 82393b0:	10800417 	ldw	r2,16(r2)
 82393b4:	10801e50 	cmplti	r2,r2,121
 82393b8:	1000031e 	bne	r2,zero,82393c8 <tcp_setpersist+0xc4>
 82393bc:	e0bfff17 	ldw	r2,-4(fp)
 82393c0:	00c01e04 	movi	r3,120
 82393c4:	10c00415 	stw	r3,16(r2)
    t * tcp_backoff[tp->t_rxtshift],
    TCPTV_PERSMIN, TCPTV_PERSMAX);
   if (tp->t_rxtshift < TCP_MAXRXTSHIFT)
 82393c8:	e0bfff17 	ldw	r2,-4(fp)
 82393cc:	10800717 	ldw	r2,28(r2)
 82393d0:	10800308 	cmpgei	r2,r2,12
 82393d4:	1000051e 	bne	r2,zero,82393ec <tcp_setpersist+0xe8>
      tp->t_rxtshift++;
 82393d8:	e0bfff17 	ldw	r2,-4(fp)
 82393dc:	10800717 	ldw	r2,28(r2)
 82393e0:	10c00044 	addi	r3,r2,1
 82393e4:	e0bfff17 	ldw	r2,-4(fp)
 82393e8:	10c00715 	stw	r3,28(r2)

}
 82393ec:	0001883a 	nop
 82393f0:	e037883a 	mov	sp,fp
 82393f4:	dfc00117 	ldw	ra,4(sp)
 82393f8:	df000017 	ldw	fp,0(sp)
 82393fc:	dec00204 	addi	sp,sp,8
 8239400:	f800283a 	ret

08239404 <bld_options>:
 * RETURNS: length of option data added to buffer
 */

static int
bld_options(struct tcpcb * tp, u_char * cp, int flags, struct socket * so)
{
 8239404:	defff804 	addi	sp,sp,-32
 8239408:	dfc00715 	stw	ra,28(sp)
 823940c:	df000615 	stw	fp,24(sp)
 8239410:	df000604 	addi	fp,sp,24
 8239414:	e13ffc15 	stw	r4,-16(fp)
 8239418:	e17ffd15 	stw	r5,-12(fp)
 823941c:	e1bffe15 	stw	r6,-8(fp)
 8239420:	e1ffff15 	stw	r7,-4(fp)
   int      len;
   u_short  mss;

   if(tp->t_flags & TF_NOOPT)    /* no options allowed? */
 8239424:	e0bffc17 	ldw	r2,-16(fp)
 8239428:	10800b0b 	ldhu	r2,44(r2)
 823942c:	10bfffcc 	andi	r2,r2,65535
 8239430:	1080020c 	andi	r2,r2,8
 8239434:	10000226 	beq	r2,zero,8239440 <bld_options+0x3c>
      return 0;
 8239438:	0005883a 	mov	r2,zero
 823943c:	00001e06 	br	82394b8 <bld_options+0xb4>

   /* Alway put MSS option on SYN packets */
   if (flags & TH_SYN)
 8239440:	e0bffe17 	ldw	r2,-8(fp)
 8239444:	1080008c 	andi	r2,r2,2
 8239448:	10001926 	beq	r2,zero,82394b0 <bld_options+0xac>
   {
      mss   =  (u_short)tcp_mss(so);
 823944c:	e13fff17 	ldw	r4,-4(fp)
 8239450:	82382080 	call	8238208 <tcp_mss>
 8239454:	e0bffb0d 	sth	r2,-20(fp)

      /* always send MSS option on SYN, fill in MSS parm */
      *(cp + 0) = TCPOPT_MAXSEG;
 8239458:	e0bffd17 	ldw	r2,-12(fp)
 823945c:	00c00084 	movi	r3,2
 8239460:	10c00005 	stb	r3,0(r2)
      *(cp + 1) = MSSOPT_LEN;               /* length byte */
 8239464:	e0bffd17 	ldw	r2,-12(fp)
 8239468:	10800044 	addi	r2,r2,1
 823946c:	00c00104 	movi	r3,4
 8239470:	10c00005 	stb	r3,0(r2)
      *(cp + 2)  = (u_char) ((mss & 0xff00) >> 8);
 8239474:	e0bffd17 	ldw	r2,-12(fp)
 8239478:	10800084 	addi	r2,r2,2
 823947c:	e0fffb0b 	ldhu	r3,-20(fp)
 8239480:	1806d23a 	srli	r3,r3,8
 8239484:	10c00005 	stb	r3,0(r2)
      *(cp + 3)  = (u_char) (mss & 0xff);
 8239488:	e0bffd17 	ldw	r2,-12(fp)
 823948c:	108000c4 	addi	r2,r2,3
 8239490:	e0fffb0b 	ldhu	r3,-20(fp)
 8239494:	10c00005 	stb	r3,0(r2)
      len = 4;
 8239498:	00800104 	movi	r2,4
 823949c:	e0bffa15 	stw	r2,-24(fp)
      cp += 4;
 82394a0:	e0bffd17 	ldw	r2,-12(fp)
 82394a4:	10800104 	addi	r2,r2,4
 82394a8:	e0bffd15 	stw	r2,-12(fp)
 82394ac:	00000106 	br	82394b4 <bld_options+0xb0>
   }
   else
      len = 0;
 82394b0:	e03ffa15 	stw	zero,-24(fp)
      len += 10;
   }
#endif   /* TCP_TIMESTAMP */

   USE_ARG(so);
   return len;
 82394b4:	e0bffa17 	ldw	r2,-24(fp)
}
 82394b8:	e037883a 	mov	sp,fp
 82394bc:	dfc00117 	ldw	ra,4(sp)
 82394c0:	df000017 	ldw	fp,0(sp)
 82394c4:	dec00204 	addi	sp,sp,8
 82394c8:	f800283a 	ret

082394cc <tcp_init>:
 * RETURNS: 
 */

void
tcp_init()
{
 82394cc:	deffff04 	addi	sp,sp,-4
 82394d0:	df000015 	stw	fp,0(sp)
 82394d4:	d839883a 	mov	fp,sp
   tcp_iss = 1;      /* wrong */
 82394d8:	00800044 	movi	r2,1
 82394dc:	d0a0b515 	stw	r2,-32044(gp)
   tcb.inp_next = tcb.inp_prev = &tcb;
 82394e0:	008209b4 	movhi	r2,2086
 82394e4:	10b98004 	addi	r2,r2,-6656
 82394e8:	00c209b4 	movhi	r3,2086
 82394ec:	18f98004 	addi	r3,r3,-6656
 82394f0:	10c00115 	stw	r3,4(r2)
 82394f4:	008209b4 	movhi	r2,2086
 82394f8:	10b98004 	addi	r2,r2,-6656
 82394fc:	10c00117 	ldw	r3,4(r2)
 8239500:	008209b4 	movhi	r2,2086
 8239504:	10b98004 	addi	r2,r2,-6656
 8239508:	10c00015 	stw	r3,0(r2)
}
 823950c:	0001883a 	nop
 8239510:	e037883a 	mov	sp,fp
 8239514:	df000017 	ldw	fp,0(sp)
 8239518:	dec00104 	addi	sp,sp,4
 823951c:	f800283a 	ret

08239520 <tcp_template>:
 * RETURNS: 
 */

struct tcpiphdr * 
tcp_template(struct tcpcb * tp)
{
 8239520:	defffb04 	addi	sp,sp,-20
 8239524:	dfc00415 	stw	ra,16(sp)
 8239528:	df000315 	stw	fp,12(sp)
 823952c:	df000304 	addi	fp,sp,12
 8239530:	e13fff15 	stw	r4,-4(fp)
   struct inpcb * inp   =  tp->t_inpcb;
 8239534:	e0bfff17 	ldw	r2,-4(fp)
 8239538:	10800d17 	ldw	r2,52(r2)
 823953c:	e0bffe15 	stw	r2,-8(fp)
   struct tcpiphdr * n;

   if ((n = tp->t_template) == 0)
 8239540:	e0bfff17 	ldw	r2,-4(fp)
 8239544:	10800c17 	ldw	r2,48(r2)
 8239548:	e0bffd15 	stw	r2,-12(fp)
 823954c:	e0bffd17 	ldw	r2,-12(fp)
 8239550:	1000071e 	bne	r2,zero,8239570 <tcp_template+0x50>
   {
      n = (struct tcpiphdr *)TPH_ALLOC (sizeof (*n));
 8239554:	01000a04 	movi	r4,40
 8239558:	822e16c0 	call	822e16c <npalloc>
 823955c:	e0bffd15 	stw	r2,-12(fp)
      if (n == NULL)
 8239560:	e0bffd17 	ldw	r2,-12(fp)
 8239564:	1000021e 	bne	r2,zero,8239570 <tcp_template+0x50>
         return (0);
 8239568:	0005883a 	mov	r2,zero
 823956c:	00002906 	br	8239614 <tcp_template+0xf4>
   }
   n->ti_next = n->ti_prev = 0;
 8239570:	e0bffd17 	ldw	r2,-12(fp)
 8239574:	10000115 	stw	zero,4(r2)
 8239578:	e0bffd17 	ldw	r2,-12(fp)
 823957c:	10c00117 	ldw	r3,4(r2)
 8239580:	e0bffd17 	ldw	r2,-12(fp)
 8239584:	10c00015 	stw	r3,0(r2)
   n->ti_len = htons(sizeof (struct tcpiphdr) - sizeof (struct ip));
 8239588:	e0bffd17 	ldw	r2,-12(fp)
 823958c:	00c50004 	movi	r3,5120
 8239590:	10c0028d 	sth	r3,10(r2)
   n->ti_src = inp->inp_laddr;
 8239594:	e0bffd17 	ldw	r2,-12(fp)
 8239598:	e0fffe17 	ldw	r3,-8(fp)
 823959c:	18c00417 	ldw	r3,16(r3)
 82395a0:	10c00315 	stw	r3,12(r2)
   n->ti_dst = inp->inp_faddr;
 82395a4:	e0bffd17 	ldw	r2,-12(fp)
 82395a8:	e0fffe17 	ldw	r3,-8(fp)
 82395ac:	18c00317 	ldw	r3,12(r3)
 82395b0:	10c00415 	stw	r3,16(r2)
   n->ti_sport = inp->inp_lport;
 82395b4:	e0bffe17 	ldw	r2,-8(fp)
 82395b8:	10c0078b 	ldhu	r3,30(r2)
 82395bc:	e0bffd17 	ldw	r2,-12(fp)
 82395c0:	10c0050d 	sth	r3,20(r2)
   n->ti_dport = inp->inp_fport;
 82395c4:	e0bffe17 	ldw	r2,-8(fp)
 82395c8:	10c0070b 	ldhu	r3,28(r2)
 82395cc:	e0bffd17 	ldw	r2,-12(fp)
 82395d0:	10c0058d 	sth	r3,22(r2)
   n->ti_seq = 0;
 82395d4:	e0bffd17 	ldw	r2,-12(fp)
 82395d8:	10000615 	stw	zero,24(r2)
   n->ti_ack = 0;
 82395dc:	e0bffd17 	ldw	r2,-12(fp)
 82395e0:	10000715 	stw	zero,28(r2)
   n->ti_t.th_doff = (5 << 4);   /* NetPort */
 82395e4:	e0bffd17 	ldw	r2,-12(fp)
 82395e8:	00c01404 	movi	r3,80
 82395ec:	10c00805 	stb	r3,32(r2)
   n->ti_flags = 0;
 82395f0:	e0bffd17 	ldw	r2,-12(fp)
 82395f4:	10000845 	stb	zero,33(r2)
   n->ti_win = 0;
 82395f8:	e0bffd17 	ldw	r2,-12(fp)
 82395fc:	1000088d 	sth	zero,34(r2)
   n->ti_sum = 0;
 8239600:	e0bffd17 	ldw	r2,-12(fp)
 8239604:	1000090d 	sth	zero,36(r2)
   n->ti_urp = 0;
 8239608:	e0bffd17 	ldw	r2,-12(fp)
 823960c:	1000098d 	sth	zero,38(r2)
   return (n);
 8239610:	e0bffd17 	ldw	r2,-12(fp)
}
 8239614:	e037883a 	mov	sp,fp
 8239618:	dfc00117 	ldw	ra,4(sp)
 823961c:	df000017 	ldw	fp,0(sp)
 8239620:	dec00204 	addi	sp,sp,8
 8239624:	f800283a 	ret

08239628 <tcp_respond>:
   struct tcpiphdr * ti,
   tcp_seq  ack,
   tcp_seq  seq,
   int   flags,
   struct mbuf *  ti_mbuf)
{
 8239628:	defff204 	addi	sp,sp,-56
 823962c:	dfc00d15 	stw	ra,52(sp)
 8239630:	df000c15 	stw	fp,48(sp)
 8239634:	df000c04 	addi	fp,sp,48
 8239638:	e13ffc15 	stw	r4,-16(fp)
 823963c:	e17ffd15 	stw	r5,-12(fp)
 8239640:	e1bffe15 	stw	r6,-8(fp)
 8239644:	e1ffff15 	stw	r7,-4(fp)
   int      tlen;       /* tcp data len - 0 or 1 */
   int      domain;     /* AF_INET or AF_INET6 */
   int      win = 0;    /* window to use in sent packet */
 8239648:	e03ff615 	stw	zero,-40(fp)
   struct mbuf *  m;    /* mbuf to send */
   struct tcpiphdr * tmp_thdr;   /* scratch */

   if (tp)
 823964c:	e0bffc17 	ldw	r2,-16(fp)
 8239650:	10001726 	beq	r2,zero,82396b0 <tcp_respond+0x88>
      win = (int)sbspace(&tp->t_inpcb->inp_socket->so_rcv);
 8239654:	e0bffc17 	ldw	r2,-16(fp)
 8239658:	10800d17 	ldw	r2,52(r2)
 823965c:	10800817 	ldw	r2,32(r2)
 8239660:	10800b17 	ldw	r2,44(r2)
 8239664:	1007883a 	mov	r3,r2
 8239668:	e0bffc17 	ldw	r2,-16(fp)
 823966c:	10800d17 	ldw	r2,52(r2)
 8239670:	10800817 	ldw	r2,32(r2)
 8239674:	10800a17 	ldw	r2,40(r2)
 8239678:	1885c83a 	sub	r2,r3,r2
 823967c:	10000a16 	blt	r2,zero,82396a8 <tcp_respond+0x80>
 8239680:	e0bffc17 	ldw	r2,-16(fp)
 8239684:	10800d17 	ldw	r2,52(r2)
 8239688:	10800817 	ldw	r2,32(r2)
 823968c:	10c00b17 	ldw	r3,44(r2)
 8239690:	e0bffc17 	ldw	r2,-16(fp)
 8239694:	10800d17 	ldw	r2,52(r2)
 8239698:	10800817 	ldw	r2,32(r2)
 823969c:	10800a17 	ldw	r2,40(r2)
 82396a0:	1885c83a 	sub	r2,r3,r2
 82396a4:	00000106 	br	82396ac <tcp_respond+0x84>
 82396a8:	0005883a 	mov	r2,zero
 82396ac:	e0bff615 	stw	r2,-40(fp)

   /* Figure out of we can recycle the passed buffer or if we need a 
    * new one. Construct the easy parts of the the TCP and IP headers.
    */
   if (flags == 0)   /* sending keepalive from timer */
 82396b0:	e0800217 	ldw	r2,8(fp)
 82396b4:	1000261e 	bne	r2,zero,8239750 <tcp_respond+0x128>
   {
      /* no flags == need a new buffer */
      m = m_getwithdata (MT_HEADER, 64);
 82396b8:	01401004 	movi	r5,64
 82396bc:	010000c4 	movi	r4,3
 82396c0:	822e3a80 	call	822e3a8 <m_getnbuf>
 82396c4:	e0bff715 	stw	r2,-36(fp)
      if (m == NULL)
 82396c8:	e0bff717 	ldw	r2,-36(fp)
 82396cc:	1000d026 	beq	r2,zero,8239a10 <tcp_respond+0x3e8>
         return;
      tlen = 1;   /* Keepalives have one byte of data */
 82396d0:	00800044 	movi	r2,1
 82396d4:	e0bff415 	stw	r2,-48(fp)
      m->m_len = TCPIPHDRSZ + tlen;
 82396d8:	e0bff417 	ldw	r2,-48(fp)
 82396dc:	10800a04 	addi	r2,r2,40
 82396e0:	1007883a 	mov	r3,r2
 82396e4:	e0bff717 	ldw	r2,-36(fp)
 82396e8:	10c00215 	stw	r3,8(r2)
      /*
       * Copy template contents into the mbuf and set ti to point
       * to the header structure in the mbuf.
       */
      tmp_thdr = (struct tcpiphdr *)((char *)m->m_data+sizeof(struct ip)
 82396ec:	e0bff717 	ldw	r2,-36(fp)
 82396f0:	10800317 	ldw	r2,12(r2)
 82396f4:	e0bff815 	stw	r2,-32(fp)
         - sizeof(struct ipovly));
      if ((char *)tmp_thdr < m->pkt->nb_buff)
 82396f8:	e0bff717 	ldw	r2,-36(fp)
 82396fc:	10800117 	ldw	r2,4(r2)
 8239700:	10800117 	ldw	r2,4(r2)
 8239704:	e0fff817 	ldw	r3,-32(fp)
 8239708:	1880032e 	bgeu	r3,r2,8239718 <tcp_respond+0xf0>
      {
         panic("tcp_respond- packet ptr underflow\n");
 823970c:	01020974 	movhi	r4,2085
 8239710:	2103b204 	addi	r4,r4,3784
 8239714:	8228c480 	call	8228c48 <panic>
      }
      MEMCPY(tmp_thdr, ti, sizeof(struct tcpiphdr));
 8239718:	01800a04 	movi	r6,40
 823971c:	e17ffd17 	ldw	r5,-12(fp)
 8239720:	e13ff817 	ldw	r4,-32(fp)
 8239724:	8202f100 	call	8202f10 <memcpy>
      ti = tmp_thdr;
 8239728:	e0bff817 	ldw	r2,-32(fp)
 823972c:	e0bffd15 	stw	r2,-12(fp)
      flags = TH_ACK;
 8239730:	00800404 	movi	r2,16
 8239734:	e0800215 	stw	r2,8(fp)
      domain = tp->t_inpcb->inp_socket->so_domain;
 8239738:	e0bffc17 	ldw	r2,-16(fp)
 823973c:	10800d17 	ldw	r2,52(r2)
 8239740:	10800817 	ldw	r2,32(r2)
 8239744:	10800517 	ldw	r2,20(r2)
 8239748:	e0bff515 	stw	r2,-44(fp)
 823974c:	00003b06 	br	823983c <tcp_respond+0x214>
   }
   else  /* Flag was passed (e.g. reset); recycle passed mbuf */
   {
      m = ti_mbuf;   /*dtom(ti);*/
 8239750:	e0800317 	ldw	r2,12(fp)
 8239754:	e0bff715 	stw	r2,-36(fp)
      if(m->pkt->type == IPTP)   /* IPv4 packet */
 8239758:	e0bff717 	ldw	r2,-36(fp)
 823975c:	10800117 	ldw	r2,4(r2)
 8239760:	1080080b 	ldhu	r2,32(r2)
 8239764:	10bfffcc 	andi	r2,r2,65535
 8239768:	10800218 	cmpnei	r2,r2,8
 823976c:	1000031e 	bne	r2,zero,823977c <tcp_respond+0x154>
         domain = AF_INET;
 8239770:	00800084 	movi	r2,2
 8239774:	e0bff515 	stw	r2,-44(fp)
 8239778:	00000206 	br	8239784 <tcp_respond+0x15c>
      else
         domain = AF_INET6;
 823977c:	008000c4 	movi	r2,3
 8239780:	e0bff515 	stw	r2,-44(fp)

      m_freem(m->m_next);
 8239784:	e0bff717 	ldw	r2,-36(fp)
 8239788:	10800617 	ldw	r2,24(r2)
 823978c:	1009883a 	mov	r4,r2
 8239790:	822e6380 	call	822e638 <m_freem>
      m->m_next = 0;
 8239794:	e0bff717 	ldw	r2,-36(fp)
 8239798:	10000615 	stw	zero,24(r2)
      tlen = 0;         /* NO data */
 823979c:	e03ff415 	stw	zero,-48(fp)
      m->m_len = TCPIPHDRSZ;
 82397a0:	e0bff717 	ldw	r2,-36(fp)
 82397a4:	00c00a04 	movi	r3,40
 82397a8:	10c00215 	stw	r3,8(r2)
      xchg(ti->ti_dport, ti->ti_sport, u_short);
 82397ac:	e0bffd17 	ldw	r2,-12(fp)
 82397b0:	1080058b 	ldhu	r2,22(r2)
 82397b4:	e0bff90d 	sth	r2,-28(fp)
 82397b8:	e0bffd17 	ldw	r2,-12(fp)
 82397bc:	10c0050b 	ldhu	r3,20(r2)
 82397c0:	e0bffd17 	ldw	r2,-12(fp)
 82397c4:	10c0058d 	sth	r3,22(r2)
 82397c8:	e0bffd17 	ldw	r2,-12(fp)
 82397cc:	e0fff90b 	ldhu	r3,-28(fp)
 82397d0:	10c0050d 	sth	r3,20(r2)
      if(m->pkt->type == IPTP)
 82397d4:	e0bff717 	ldw	r2,-36(fp)
 82397d8:	10800117 	ldw	r2,4(r2)
 82397dc:	1080080b 	ldhu	r2,32(r2)
 82397e0:	10bfffcc 	andi	r2,r2,65535
 82397e4:	10800218 	cmpnei	r2,r2,8
 82397e8:	10000a1e 	bne	r2,zero,8239814 <tcp_respond+0x1ec>
         xchg(ti->ti_dst.s_addr, ti->ti_src.s_addr, u_long);
 82397ec:	e0bffd17 	ldw	r2,-12(fp)
 82397f0:	10800417 	ldw	r2,16(r2)
 82397f4:	e0bffa15 	stw	r2,-24(fp)
 82397f8:	e0bffd17 	ldw	r2,-12(fp)
 82397fc:	10c00317 	ldw	r3,12(r2)
 8239800:	e0bffd17 	ldw	r2,-12(fp)
 8239804:	10c00415 	stw	r3,16(r2)
 8239808:	e0bffd17 	ldw	r2,-12(fp)
 823980c:	e0fffa17 	ldw	r3,-24(fp)
 8239810:	10c00315 	stw	r3,12(r2)
      if (flags & TH_RST)  /* count resets in MIB */
 8239814:	e0800217 	ldw	r2,8(fp)
 8239818:	1080010c 	andi	r2,r2,4
 823981c:	10000726 	beq	r2,zero,823983c <tcp_respond+0x214>
         TCP_MIB_INC(tcpOutRsts);   /* keep MIB stats */
 8239820:	008209b4 	movhi	r2,2086
 8239824:	10b95d04 	addi	r2,r2,-6796
 8239828:	10800e17 	ldw	r2,56(r2)
 823982c:	10c00044 	addi	r3,r2,1
 8239830:	008209b4 	movhi	r2,2086
 8239834:	10b95d04 	addi	r2,r2,-6796
 8239838:	10c00e15 	stw	r3,56(r2)
   }

   /* finish constructing the TCP header */
   ti->ti_seq = htonl(seq);
 823983c:	e0bfff17 	ldw	r2,-4(fp)
 8239840:	1006d63a 	srli	r3,r2,24
 8239844:	e0bfff17 	ldw	r2,-4(fp)
 8239848:	1004d23a 	srli	r2,r2,8
 823984c:	10bfc00c 	andi	r2,r2,65280
 8239850:	1886b03a 	or	r3,r3,r2
 8239854:	e0bfff17 	ldw	r2,-4(fp)
 8239858:	10bfc00c 	andi	r2,r2,65280
 823985c:	1004923a 	slli	r2,r2,8
 8239860:	1886b03a 	or	r3,r3,r2
 8239864:	e0bfff17 	ldw	r2,-4(fp)
 8239868:	1004963a 	slli	r2,r2,24
 823986c:	1886b03a 	or	r3,r3,r2
 8239870:	e0bffd17 	ldw	r2,-12(fp)
 8239874:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(ack);
 8239878:	e0bffe17 	ldw	r2,-8(fp)
 823987c:	1006d63a 	srli	r3,r2,24
 8239880:	e0bffe17 	ldw	r2,-8(fp)
 8239884:	1004d23a 	srli	r2,r2,8
 8239888:	10bfc00c 	andi	r2,r2,65280
 823988c:	1886b03a 	or	r3,r3,r2
 8239890:	e0bffe17 	ldw	r2,-8(fp)
 8239894:	10bfc00c 	andi	r2,r2,65280
 8239898:	1004923a 	slli	r2,r2,8
 823989c:	1886b03a 	or	r3,r3,r2
 82398a0:	e0bffe17 	ldw	r2,-8(fp)
 82398a4:	1004963a 	slli	r2,r2,24
 82398a8:	1886b03a 	or	r3,r3,r2
 82398ac:	e0bffd17 	ldw	r2,-12(fp)
 82398b0:	10c00715 	stw	r3,28(r2)
   ti->ti_t.th_doff = 0x50;      /* NetPort: init data offset bits */
 82398b4:	e0bffd17 	ldw	r2,-12(fp)
 82398b8:	00c01404 	movi	r3,80
 82398bc:	10c00805 	stb	r3,32(r2)
   ti->ti_flags = (u_char)flags;
 82398c0:	e0800217 	ldw	r2,8(fp)
 82398c4:	1007883a 	mov	r3,r2
 82398c8:	e0bffd17 	ldw	r2,-12(fp)
 82398cc:	10c00845 	stb	r3,33(r2)
   ti->ti_win = htons((u_short)win);
 82398d0:	e0bff617 	ldw	r2,-40(fp)
 82398d4:	10bfffcc 	andi	r2,r2,65535
 82398d8:	1005d23a 	srai	r2,r2,8
 82398dc:	10803fcc 	andi	r2,r2,255
 82398e0:	1007883a 	mov	r3,r2
 82398e4:	e0bff617 	ldw	r2,-40(fp)
 82398e8:	10bfffcc 	andi	r2,r2,65535
 82398ec:	1004923a 	slli	r2,r2,8
 82398f0:	1884b03a 	or	r2,r3,r2
 82398f4:	1007883a 	mov	r3,r2
 82398f8:	e0bffd17 	ldw	r2,-12(fp)
 82398fc:	10c0088d 	sth	r3,34(r2)
   ti->ti_urp = 0;
 8239900:	e0bffd17 	ldw	r2,-12(fp)
 8239904:	1000098d 	sth	zero,38(r2)

   /* Finish constructing IP header and send, based on IP type in use */
   switch(domain)
 8239908:	e0bff517 	ldw	r2,-44(fp)
 823990c:	108000a0 	cmpeqi	r2,r2,2
 8239910:	10003b26 	beq	r2,zero,8239a00 <tcp_respond+0x3d8>
#ifdef IP_V4
      case AF_INET:
      {
         struct ip * pip;

         pip = (struct ip *)((char*)ti+sizeof(struct ipovly)-sizeof(struct ip));
 8239914:	e0bffd17 	ldw	r2,-12(fp)
 8239918:	e0bffb15 	stw	r2,-20(fp)

         pip->ip_len = (unshort)(TCPIPHDRSZ + tlen);
 823991c:	e0bff417 	ldw	r2,-48(fp)
 8239920:	10800a04 	addi	r2,r2,40
 8239924:	1007883a 	mov	r3,r2
 8239928:	e0bffb17 	ldw	r2,-20(fp)
 823992c:	10c0008d 	sth	r3,2(r2)
         /* If our system's max. MAC header size is geater than the size 
          * of the MAC header in the received packet then we need to 
          * adjust the IP header offset to allow for this. Since the packets 
          * are only headers they should always fit.
          */
         if(pip >= (struct ip *)(m->pkt->nb_buff + MaxLnh))
 8239930:	e0bff717 	ldw	r2,-36(fp)
 8239934:	10800117 	ldw	r2,4(r2)
 8239938:	10800117 	ldw	r2,4(r2)
 823993c:	d0e08117 	ldw	r3,-32252(gp)
 8239940:	10c5883a 	add	r2,r2,r3
 8239944:	e0fffb17 	ldw	r3,-20(fp)
 8239948:	18800436 	bltu	r3,r2,823995c <tcp_respond+0x334>
         {
            m->m_data = (char*)pip; /* headers will fit, just set pointer */
 823994c:	e0bff717 	ldw	r2,-36(fp)
 8239950:	e0fffb17 	ldw	r3,-20(fp)
 8239954:	10c00315 	stw	r3,12(r2)
 8239958:	00001106 	br	82399a0 <tcp_respond+0x378>
         }
         else     /* MAC may not fit, adjust pointer and move headers back */
         {
            m->m_data = m->pkt->nb_prot = m->pkt->nb_buff + MaxLnh;  /* new ptr */
 823995c:	e0bff717 	ldw	r2,-36(fp)
 8239960:	10800117 	ldw	r2,4(r2)
 8239964:	e0fff717 	ldw	r3,-36(fp)
 8239968:	18c00117 	ldw	r3,4(r3)
 823996c:	18c00117 	ldw	r3,4(r3)
 8239970:	d1208117 	ldw	r4,-32252(gp)
 8239974:	1907883a 	add	r3,r3,r4
 8239978:	10c00315 	stw	r3,12(r2)
 823997c:	10c00317 	ldw	r3,12(r2)
 8239980:	e0bff717 	ldw	r2,-36(fp)
 8239984:	10c00315 	stw	r3,12(r2)
            MEMMOVE(m->m_data, pip, TCPIPHDRSZ);  /* move back tcp/ip headers */
 8239988:	e0bff717 	ldw	r2,-36(fp)
 823998c:	10800317 	ldw	r2,12(r2)
 8239990:	01800a04 	movi	r6,40
 8239994:	e17ffb17 	ldw	r5,-20(fp)
 8239998:	1009883a 	mov	r4,r2
 823999c:	82030580 	call	8203058 <memmove>

         /*
          * In the case of a SYN DOS attack, many RST|ACK replies
          *   have no tp structure and need to be freed.
          */
         if (!tp)
 82399a0:	e0bffc17 	ldw	r2,-16(fp)
 82399a4:	1000031e 	bne	r2,zero,82399b4 <tcp_respond+0x38c>
              m_freem(m);
 82399a8:	e13ff717 	ldw	r4,-36(fp)
 82399ac:	822e6380 	call	822e638 <m_freem>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
		 }

         break;
 82399b0:	00001506 	br	8239a08 <tcp_respond+0x3e0>
          */
         if (!tp)
              m_freem(m);
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
 82399b4:	e0bffc17 	ldw	r2,-16(fp)
 82399b8:	10800d17 	ldw	r2,52(r2)
 82399bc:	10000c26 	beq	r2,zero,82399f0 <tcp_respond+0x3c8>
 82399c0:	e0bffc17 	ldw	r2,-16(fp)
 82399c4:	10800d17 	ldw	r2,52(r2)
 82399c8:	10800817 	ldw	r2,32(r2)
 82399cc:	10000826 	beq	r2,zero,82399f0 <tcp_respond+0x3c8>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
 82399d0:	e0bffc17 	ldw	r2,-16(fp)
 82399d4:	10800d17 	ldw	r2,52(r2)
 82399d8:	10800817 	ldw	r2,32(r2)
 82399dc:	10801f17 	ldw	r2,124(r2)
 82399e0:	100b883a 	mov	r5,r2
 82399e4:	e13ff717 	ldw	r4,-36(fp)
 82399e8:	822efd40 	call	822efd4 <ip_output>
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
		 }

         break;
 82399ec:	00000606 	br	8239a08 <tcp_respond+0x3e0>
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
 82399f0:	000b883a 	mov	r5,zero
 82399f4:	e13ff717 	ldw	r4,-36(fp)
 82399f8:	822efd40 	call	822efd4 <ip_output>
		 }

         break;
 82399fc:	00000206 	br	8239a08 <tcp_respond+0x3e0>

         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();
 8239a00:	822d5940 	call	822d594 <dtrap>
         break;
 8239a04:	0001883a 	nop
   }
   return;
 8239a08:	0001883a 	nop
 8239a0c:	00000106 	br	8239a14 <tcp_respond+0x3ec>
   if (flags == 0)   /* sending keepalive from timer */
   {
      /* no flags == need a new buffer */
      m = m_getwithdata (MT_HEADER, 64);
      if (m == NULL)
         return;
 8239a10:	0001883a 	nop
      default:
         dtrap();
         break;
   }
   return;
}
 8239a14:	e037883a 	mov	sp,fp
 8239a18:	dfc00117 	ldw	ra,4(sp)
 8239a1c:	df000017 	ldw	fp,0(sp)
 8239a20:	dec00204 	addi	sp,sp,8
 8239a24:	f800283a 	ret

08239a28 <tcp_newtcpcb>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_newtcpcb(struct inpcb * inp)
{
 8239a28:	defffb04 	addi	sp,sp,-20
 8239a2c:	dfc00415 	stw	ra,16(sp)
 8239a30:	df000315 	stw	fp,12(sp)
 8239a34:	df000304 	addi	fp,sp,12
 8239a38:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp;
   short t_time;

   tp = TCB_ALLOC(sizeof (*tp));
 8239a3c:	01002504 	movi	r4,148
 8239a40:	822e16c0 	call	822e16c <npalloc>
 8239a44:	e0bffd15 	stw	r2,-12(fp)
   if (tp == NULL)
 8239a48:	e0bffd17 	ldw	r2,-12(fp)
 8239a4c:	1000021e 	bne	r2,zero,8239a58 <tcp_newtcpcb+0x30>
      return (struct tcpcb *)NULL;
 8239a50:	0005883a 	mov	r2,zero
 8239a54:	00003206 	br	8239b20 <tcp_newtcpcb+0xf8>
   tp->seg_next = tp->seg_prev = (struct tcpiphdr *)tp;
 8239a58:	e0bffd17 	ldw	r2,-12(fp)
 8239a5c:	e0fffd17 	ldw	r3,-12(fp)
 8239a60:	10c00115 	stw	r3,4(r2)
 8239a64:	e0bffd17 	ldw	r2,-12(fp)
 8239a68:	10c00117 	ldw	r3,4(r2)
 8239a6c:	e0bffd17 	ldw	r2,-12(fp)
 8239a70:	10c00015 	stw	r3,0(r2)
   tp->t_maxseg = TCP_MSS;
 8239a74:	e0bffd17 	ldw	r2,-12(fp)
 8239a78:	00c16d04 	movi	r3,1460
 8239a7c:	10c00a0d 	sth	r3,40(r2)
   tp->t_flags = 0;        /* sends options! */
 8239a80:	e0bffd17 	ldw	r2,-12(fp)
 8239a84:	10000b0d 	sth	zero,44(r2)
   tp->t_inpcb = inp;
 8239a88:	e0bffd17 	ldw	r2,-12(fp)
 8239a8c:	e0ffff17 	ldw	r3,-4(fp)
 8239a90:	10c00d15 	stw	r3,52(r2)
   /*
    * Init srtt to TCPTV_SRTTBASE (0), so we can tell that we have no
    * rtt estimate.  Set rttvar so that srtt + 2 * rttvar gives
    * reasonable initial retransmit time.
    */
   tp->t_srtt = TCPTV_SRTTBASE;
 8239a94:	e0bffd17 	ldw	r2,-12(fp)
 8239a98:	10002015 	stw	zero,128(r2)
   tp->t_rttvar = TCPTV_SRTTDFLT << 2;
 8239a9c:	e0bffd17 	ldw	r2,-12(fp)
 8239aa0:	00c00604 	movi	r3,24
 8239aa4:	10c02115 	stw	r3,132(r2)

   t_time = ((TCPTV_SRTTBASE >> 2) + (TCPTV_SRTTDFLT << 2)) >> 1;
 8239aa8:	00800304 	movi	r2,12
 8239aac:	e0bffe0d 	sth	r2,-8(fp)
   TCPT_RANGESET(tp->t_rxtcur, t_time, TCPTV_MIN, TCPTV_REXMTMAX);
 8239ab0:	e0fffe0f 	ldh	r3,-8(fp)
 8239ab4:	e0bffd17 	ldw	r2,-12(fp)
 8239ab8:	10c00815 	stw	r3,32(r2)
 8239abc:	e0bffd17 	ldw	r2,-12(fp)
 8239ac0:	10800817 	ldw	r2,32(r2)
 8239ac4:	10800088 	cmpgei	r2,r2,2
 8239ac8:	1000041e 	bne	r2,zero,8239adc <tcp_newtcpcb+0xb4>
 8239acc:	e0bffd17 	ldw	r2,-12(fp)
 8239ad0:	00c00084 	movi	r3,2
 8239ad4:	10c00815 	stw	r3,32(r2)
 8239ad8:	00000706 	br	8239af8 <tcp_newtcpcb+0xd0>
 8239adc:	e0bffd17 	ldw	r2,-12(fp)
 8239ae0:	10800817 	ldw	r2,32(r2)
 8239ae4:	10802050 	cmplti	r2,r2,129
 8239ae8:	1000031e 	bne	r2,zero,8239af8 <tcp_newtcpcb+0xd0>
 8239aec:	e0bffd17 	ldw	r2,-12(fp)
 8239af0:	00c02004 	movi	r3,128
 8239af4:	10c00815 	stw	r3,32(r2)

   /* Set initial congestion window - RFC-2581, pg 4. */
   tp->snd_cwnd = 2 * TCP_MSS;
 8239af8:	e0bffd17 	ldw	r2,-12(fp)
 8239afc:	00c2da04 	movi	r3,2920
 8239b00:	10c01b15 	stw	r3,108(r2)

#ifdef DO_DELAY_ACKS
   tp->t_delacktime = 1;
#endif   /* DO_DELAY_ACKS */

   tp->snd_ssthresh = 65535;  /* Start with high slow-start threshold */
 8239b04:	e0bffd17 	ldw	r2,-12(fp)
 8239b08:	00ffffd4 	movui	r3,65535
 8239b0c:	10c01c15 	stw	r3,112(r2)

   inp->inp_ppcb = (char *)tp;
 8239b10:	e0bfff17 	ldw	r2,-4(fp)
 8239b14:	e0fffd17 	ldw	r3,-12(fp)
 8239b18:	10c00915 	stw	r3,36(r2)
   return (tp);
 8239b1c:	e0bffd17 	ldw	r2,-12(fp)
}
 8239b20:	e037883a 	mov	sp,fp
 8239b24:	dfc00117 	ldw	ra,4(sp)
 8239b28:	df000017 	ldw	fp,0(sp)
 8239b2c:	dec00204 	addi	sp,sp,8
 8239b30:	f800283a 	ret

08239b34 <tcp_drop>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_drop(struct tcpcb * tp, int err)
{
 8239b34:	defffb04 	addi	sp,sp,-20
 8239b38:	dfc00415 	stw	ra,16(sp)
 8239b3c:	df000315 	stw	fp,12(sp)
 8239b40:	df000304 	addi	fp,sp,12
 8239b44:	e13ffe15 	stw	r4,-8(fp)
 8239b48:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 8239b4c:	e0bffe17 	ldw	r2,-8(fp)
 8239b50:	10800d17 	ldw	r2,52(r2)
 8239b54:	10800817 	ldw	r2,32(r2)
 8239b58:	e0bffd15 	stw	r2,-12(fp)

   if (TCPS_HAVERCVDSYN(tp->t_state)) 
 8239b5c:	e0bffe17 	ldw	r2,-8(fp)
 8239b60:	10800217 	ldw	r2,8(r2)
 8239b64:	108000d0 	cmplti	r2,r2,3
 8239b68:	10000c1e 	bne	r2,zero,8239b9c <tcp_drop+0x68>
   {
      tp->t_state = TCPS_CLOSED;
 8239b6c:	e0bffe17 	ldw	r2,-8(fp)
 8239b70:	10000215 	stw	zero,8(r2)
      (void) tcp_output(tp);
 8239b74:	e13ffe17 	ldw	r4,-8(fp)
 8239b78:	82383000 	call	8238300 <tcp_output>
      tcpstat.tcps_drops++;
 8239b7c:	008209b4 	movhi	r2,2086
 8239b80:	10b98b04 	addi	r2,r2,-6612
 8239b84:	10800317 	ldw	r2,12(r2)
 8239b88:	10c00044 	addi	r3,r2,1
 8239b8c:	008209b4 	movhi	r2,2086
 8239b90:	10b98b04 	addi	r2,r2,-6612
 8239b94:	10c00315 	stw	r3,12(r2)
 8239b98:	00000706 	br	8239bb8 <tcp_drop+0x84>
   }
   else
      tcpstat.tcps_conndrops++;
 8239b9c:	008209b4 	movhi	r2,2086
 8239ba0:	10b98b04 	addi	r2,r2,-6612
 8239ba4:	10800417 	ldw	r2,16(r2)
 8239ba8:	10c00044 	addi	r3,r2,1
 8239bac:	008209b4 	movhi	r2,2086
 8239bb0:	10b98b04 	addi	r2,r2,-6612
 8239bb4:	10c00415 	stw	r3,16(r2)
   so->so_error = err;
 8239bb8:	e0bffd17 	ldw	r2,-12(fp)
 8239bbc:	e0ffff17 	ldw	r3,-4(fp)
 8239bc0:	10c00615 	stw	r3,24(r2)
#ifdef TCP_ZEROCOPY
   if (so->rx_upcall)
      so->rx_upcall(so, NULL, err);
#endif   /* TCP_ZEROCOPY */
   return (tcp_close(tp));
 8239bc4:	e13ffe17 	ldw	r4,-8(fp)
 8239bc8:	8239be00 	call	8239be0 <tcp_close>
}
 8239bcc:	e037883a 	mov	sp,fp
 8239bd0:	dfc00117 	ldw	ra,4(sp)
 8239bd4:	df000017 	ldw	fp,0(sp)
 8239bd8:	dec00204 	addi	sp,sp,8
 8239bdc:	f800283a 	ret

08239be0 <tcp_close>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_close(struct tcpcb * tp)
{
 8239be0:	defff904 	addi	sp,sp,-28
 8239be4:	dfc00615 	stw	ra,24(sp)
 8239be8:	df000515 	stw	fp,20(sp)
 8239bec:	df000504 	addi	fp,sp,20
 8239bf0:	e13fff15 	stw	r4,-4(fp)
   struct tcpiphdr * t;
   struct inpcb * inp   =  tp->t_inpcb;
 8239bf4:	e0bfff17 	ldw	r2,-4(fp)
 8239bf8:	10800d17 	ldw	r2,52(r2)
 8239bfc:	e0bffc15 	stw	r2,-16(fp)
   struct socket *   so =  inp->inp_socket;
 8239c00:	e0bffc17 	ldw	r2,-16(fp)
 8239c04:	10800817 	ldw	r2,32(r2)
 8239c08:	e0bffd15 	stw	r2,-12(fp)
   struct mbuf *  m;

   t = tp->seg_next;
 8239c0c:	e0bfff17 	ldw	r2,-4(fp)
 8239c10:	10800017 	ldw	r2,0(r2)
 8239c14:	e0bffb15 	stw	r2,-20(fp)
   while (t != (struct tcpiphdr *)tp) 
 8239c18:	00000e06 	br	8239c54 <tcp_close+0x74>
   {
      t = (struct tcpiphdr *)t->ti_next;
 8239c1c:	e0bffb17 	ldw	r2,-20(fp)
 8239c20:	10800017 	ldw	r2,0(r2)
 8239c24:	e0bffb15 	stw	r2,-20(fp)
      m = dtom(t->ti_prev);
 8239c28:	e0bffb17 	ldw	r2,-20(fp)
 8239c2c:	10800117 	ldw	r2,4(r2)
 8239c30:	1009883a 	mov	r4,r2
 8239c34:	822eb840 	call	822eb84 <dtom>
 8239c38:	e0bffe15 	stw	r2,-8(fp)
      remque(t->ti_prev);
 8239c3c:	e0bffb17 	ldw	r2,-20(fp)
 8239c40:	10800117 	ldw	r2,4(r2)
 8239c44:	1009883a 	mov	r4,r2
 8239c48:	822ec200 	call	822ec20 <remque>
      m_freem (m);
 8239c4c:	e13ffe17 	ldw	r4,-8(fp)
 8239c50:	822e6380 	call	822e638 <m_freem>
   struct inpcb * inp   =  tp->t_inpcb;
   struct socket *   so =  inp->inp_socket;
   struct mbuf *  m;

   t = tp->seg_next;
   while (t != (struct tcpiphdr *)tp) 
 8239c54:	e0fffb17 	ldw	r3,-20(fp)
 8239c58:	e0bfff17 	ldw	r2,-4(fp)
 8239c5c:	18bfef1e 	bne	r3,r2,8239c1c <tcp_close+0x3c>
      t = (struct tcpiphdr *)t->ti_next;
      m = dtom(t->ti_prev);
      remque(t->ti_prev);
      m_freem (m);
   }
   if (tp->t_template)
 8239c60:	e0bfff17 	ldw	r2,-4(fp)
 8239c64:	10800c17 	ldw	r2,48(r2)
 8239c68:	10000426 	beq	r2,zero,8239c7c <tcp_close+0x9c>
      TPH_FREE (tp->t_template);
 8239c6c:	e0bfff17 	ldw	r2,-4(fp)
 8239c70:	10800c17 	ldw	r2,48(r2)
 8239c74:	1009883a 	mov	r4,r2
 8239c78:	822e1a00 	call	822e1a0 <npfree>
   TCB_FREE (tp);
 8239c7c:	e13fff17 	ldw	r4,-4(fp)
 8239c80:	822e1a00 	call	822e1a0 <npfree>
   inp->inp_ppcb = 0;
 8239c84:	e0bffc17 	ldw	r2,-16(fp)
 8239c88:	10000915 	stw	zero,36(r2)
   soisdisconnected(so);
 8239c8c:	e13ffd17 	ldw	r4,-12(fp)
 8239c90:	8233c740 	call	8233c74 <soisdisconnected>
   in_pcbdetach(inp);
 8239c94:	e13ffc17 	ldw	r4,-16(fp)
 8239c98:	8247ec00 	call	8247ec0 <in_pcbdetach>
   tcpstat.tcps_closed++;
 8239c9c:	008209b4 	movhi	r2,2086
 8239ca0:	10b98b04 	addi	r2,r2,-6612
 8239ca4:	10800517 	ldw	r2,20(r2)
 8239ca8:	10c00044 	addi	r3,r2,1
 8239cac:	008209b4 	movhi	r2,2086
 8239cb0:	10b98b04 	addi	r2,r2,-6612
 8239cb4:	10c00515 	stw	r3,20(r2)
   return ((struct tcpcb *)0);
 8239cb8:	0005883a 	mov	r2,zero
}
 8239cbc:	e037883a 	mov	sp,fp
 8239cc0:	dfc00117 	ldw	ra,4(sp)
 8239cc4:	df000017 	ldw	fp,0(sp)
 8239cc8:	dec00204 	addi	sp,sp,8
 8239ccc:	f800283a 	ret

08239cd0 <tcp_quench>:
 * RETURNS: 
 */

void
tcp_quench(struct inpcb * inp)
{
 8239cd0:	defffd04 	addi	sp,sp,-12
 8239cd4:	df000215 	stw	fp,8(sp)
 8239cd8:	df000204 	addi	fp,sp,8
 8239cdc:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp =  intotcpcb(inp);
 8239ce0:	e0bfff17 	ldw	r2,-4(fp)
 8239ce4:	10800917 	ldw	r2,36(r2)
 8239ce8:	e0bffe15 	stw	r2,-8(fp)

   if (tp)
 8239cec:	e0bffe17 	ldw	r2,-8(fp)
 8239cf0:	10000526 	beq	r2,zero,8239d08 <tcp_quench+0x38>
      tp->snd_cwnd = tp->t_maxseg;
 8239cf4:	e0bffe17 	ldw	r2,-8(fp)
 8239cf8:	10800a0b 	ldhu	r2,40(r2)
 8239cfc:	10ffffcc 	andi	r3,r2,65535
 8239d00:	e0bffe17 	ldw	r2,-8(fp)
 8239d04:	10c01b15 	stw	r3,108(r2)
}
 8239d08:	0001883a 	nop
 8239d0c:	e037883a 	mov	sp,fp
 8239d10:	df000017 	ldw	fp,0(sp)
 8239d14:	dec00104 	addi	sp,sp,4
 8239d18:	f800283a 	ret

08239d1c <tcp_putseq>:

/* tcp_putseq()  */

u_char *
tcp_putseq(u_char * cp, tcp_seq seq)
{
 8239d1c:	defffc04 	addi	sp,sp,-16
 8239d20:	df000315 	stw	fp,12(sp)
 8239d24:	df000304 	addi	fp,sp,12
 8239d28:	e13ffe15 	stw	r4,-8(fp)
 8239d2c:	e17fff15 	stw	r5,-4(fp)
   int   i;

   cp += 3;                /* do low byte first */
 8239d30:	e0bffe17 	ldw	r2,-8(fp)
 8239d34:	108000c4 	addi	r2,r2,3
 8239d38:	e0bffe15 	stw	r2,-8(fp)
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 8239d3c:	e03ffd15 	stw	zero,-12(fp)
 8239d40:	00000b06 	br	8239d70 <tcp_putseq+0x54>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
 8239d44:	e0bffe17 	ldw	r2,-8(fp)
 8239d48:	10ffffc4 	addi	r3,r2,-1
 8239d4c:	e0fffe15 	stw	r3,-8(fp)
 8239d50:	e0ffff17 	ldw	r3,-4(fp)
 8239d54:	10c00005 	stb	r3,0(r2)
      seq >>= 8;
 8239d58:	e0bfff17 	ldw	r2,-4(fp)
 8239d5c:	1004d23a 	srli	r2,r2,8
 8239d60:	e0bfff15 	stw	r2,-4(fp)
tcp_putseq(u_char * cp, tcp_seq seq)
{
   int   i;

   cp += 3;                /* do low byte first */
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 8239d64:	e0bffd17 	ldw	r2,-12(fp)
 8239d68:	10800044 	addi	r2,r2,1
 8239d6c:	e0bffd15 	stw	r2,-12(fp)
 8239d70:	e0bffd17 	ldw	r2,-12(fp)
 8239d74:	10800110 	cmplti	r2,r2,4
 8239d78:	103ff21e 	bne	r2,zero,8239d44 <tcp_putseq+0x28>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
      seq >>= 8;
   }
   return (cp + 5);
 8239d7c:	e0bffe17 	ldw	r2,-8(fp)
 8239d80:	10800144 	addi	r2,r2,5
}
 8239d84:	e037883a 	mov	sp,fp
 8239d88:	df000017 	ldw	fp,0(sp)
 8239d8c:	dec00104 	addi	sp,sp,4
 8239d90:	f800283a 	ret

08239d94 <tcp_getseq>:
 * RETURNS: a long in local endian
 */

u_long
tcp_getseq(u_char * cp)
{
 8239d94:	defffc04 	addi	sp,sp,-16
 8239d98:	df000315 	stw	fp,12(sp)
 8239d9c:	df000304 	addi	fp,sp,12
 8239da0:	e13fff15 	stw	r4,-4(fp)
   int i;
   ulong seq = 0;
 8239da4:	e03ffe15 	stw	zero,-8(fp)

   for(i = 0; i < 4; i++)
 8239da8:	e03ffd15 	stw	zero,-12(fp)
 8239dac:	00000e06 	br	8239de8 <tcp_getseq+0x54>
   {
      seq <<= 8;
 8239db0:	e0bffe17 	ldw	r2,-8(fp)
 8239db4:	1004923a 	slli	r2,r2,8
 8239db8:	e0bffe15 	stw	r2,-8(fp)
      seq += (u_long)*(cp++);
 8239dbc:	e0bfff17 	ldw	r2,-4(fp)
 8239dc0:	10c00044 	addi	r3,r2,1
 8239dc4:	e0ffff15 	stw	r3,-4(fp)
 8239dc8:	10800003 	ldbu	r2,0(r2)
 8239dcc:	10803fcc 	andi	r2,r2,255
 8239dd0:	e0fffe17 	ldw	r3,-8(fp)
 8239dd4:	1885883a 	add	r2,r3,r2
 8239dd8:	e0bffe15 	stw	r2,-8(fp)
tcp_getseq(u_char * cp)
{
   int i;
   ulong seq = 0;

   for(i = 0; i < 4; i++)
 8239ddc:	e0bffd17 	ldw	r2,-12(fp)
 8239de0:	10800044 	addi	r2,r2,1
 8239de4:	e0bffd15 	stw	r2,-12(fp)
 8239de8:	e0bffd17 	ldw	r2,-12(fp)
 8239dec:	10800110 	cmplti	r2,r2,4
 8239df0:	103fef1e 	bne	r2,zero,8239db0 <tcp_getseq+0x1c>
   {
      seq <<= 8;
      seq += (u_long)*(cp++);
   }
   return seq;
 8239df4:	e0bffe17 	ldw	r2,-8(fp)
}
 8239df8:	e037883a 	mov	sp,fp
 8239dfc:	df000017 	ldw	fp,0(sp)
 8239e00:	dec00104 	addi	sp,sp,4
 8239e04:	f800283a 	ret

08239e08 <tcp_slowtimo>:
 * RETURNS: 
 */

void
tcp_slowtimo(void)
{
 8239e08:	defff704 	addi	sp,sp,-36
 8239e0c:	dfc00815 	stw	ra,32(sp)
 8239e10:	df000715 	stw	fp,28(sp)
 8239e14:	df000704 	addi	fp,sp,28
   struct tcpcb * tp;
   int   i;
   struct socket * so, * sonext;
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;
 8239e18:	d0a03f17 	ldw	r2,-32516(gp)
 8239e1c:	100490fa 	slli	r2,r2,3
 8239e20:	d0a0b415 	stw	r2,-32048(gp)

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 8239e24:	008209b4 	movhi	r2,2086
 8239e28:	10b95804 	addi	r2,r2,-6816
 8239e2c:	10800017 	ldw	r2,0(r2)
 8239e30:	e0bffa15 	stw	r2,-24(fp)
 8239e34:	00008006 	br	823a038 <tcp_slowtimo+0x230>
   {
      sonext = so->next;
 8239e38:	e0bffa17 	ldw	r2,-24(fp)
 8239e3c:	10800017 	ldw	r2,0(r2)
 8239e40:	e0bffb15 	stw	r2,-20(fp)

      /* for SOCK_STREAM (TCP) sockets, we must do slow-timeout 
       * processing and (optionally) processing of pending 
       * zero-copy socket upcalls.
       */
      if (so->so_type == SOCK_STREAM)
 8239e44:	e0bffa17 	ldw	r2,-24(fp)
 8239e48:	10800983 	ldbu	r2,38(r2)
 8239e4c:	10803fcc 	andi	r2,r2,255
 8239e50:	1080201c 	xori	r2,r2,128
 8239e54:	10bfe004 	addi	r2,r2,-128
 8239e58:	10800058 	cmpnei	r2,r2,1
 8239e5c:	1000461e 	bne	r2,zero,8239f78 <tcp_slowtimo+0x170>
      {
         ip = so->so_pcb;
 8239e60:	e0bffa17 	ldw	r2,-24(fp)
 8239e64:	10800117 	ldw	r2,4(r2)
 8239e68:	e0bffc15 	stw	r2,-16(fp)
         if (!ip)
 8239e6c:	e0bffc17 	ldw	r2,-16(fp)
 8239e70:	10006a26 	beq	r2,zero,823a01c <tcp_slowtimo+0x214>
            continue;
         ipnxt = ip->inp_next;
 8239e74:	e0bffc17 	ldw	r2,-16(fp)
 8239e78:	10800017 	ldw	r2,0(r2)
 8239e7c:	e0bffd15 	stw	r2,-12(fp)

         tp = intotcpcb(so->so_pcb);
 8239e80:	e0bffa17 	ldw	r2,-24(fp)
 8239e84:	10800117 	ldw	r2,4(r2)
 8239e88:	10800917 	ldw	r2,36(r2)
 8239e8c:	e0bffe15 	stw	r2,-8(fp)
         if (!tp)
 8239e90:	e0bffe17 	ldw	r2,-8(fp)
 8239e94:	10006326 	beq	r2,zero,823a024 <tcp_slowtimo+0x21c>
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 8239e98:	e03ff915 	stw	zero,-28(fp)
 8239e9c:	00002e06 	br	8239f58 <tcp_slowtimo+0x150>
         {
            if (tp->t_timer[i] && --tp->t_timer[i] == 0) 
 8239ea0:	e0fffe17 	ldw	r3,-8(fp)
 8239ea4:	e0bff917 	ldw	r2,-28(fp)
 8239ea8:	108000c4 	addi	r2,r2,3
 8239eac:	1085883a 	add	r2,r2,r2
 8239eb0:	1085883a 	add	r2,r2,r2
 8239eb4:	1885883a 	add	r2,r3,r2
 8239eb8:	10800017 	ldw	r2,0(r2)
 8239ebc:	10002326 	beq	r2,zero,8239f4c <tcp_slowtimo+0x144>
 8239ec0:	e0fffe17 	ldw	r3,-8(fp)
 8239ec4:	e0bff917 	ldw	r2,-28(fp)
 8239ec8:	108000c4 	addi	r2,r2,3
 8239ecc:	1085883a 	add	r2,r2,r2
 8239ed0:	1085883a 	add	r2,r2,r2
 8239ed4:	1885883a 	add	r2,r3,r2
 8239ed8:	10800017 	ldw	r2,0(r2)
 8239edc:	10ffffc4 	addi	r3,r2,-1
 8239ee0:	e13ffe17 	ldw	r4,-8(fp)
 8239ee4:	e0bff917 	ldw	r2,-28(fp)
 8239ee8:	108000c4 	addi	r2,r2,3
 8239eec:	1085883a 	add	r2,r2,r2
 8239ef0:	1085883a 	add	r2,r2,r2
 8239ef4:	2085883a 	add	r2,r4,r2
 8239ef8:	10c00015 	stw	r3,0(r2)
 8239efc:	e0fffe17 	ldw	r3,-8(fp)
 8239f00:	e0bff917 	ldw	r2,-28(fp)
 8239f04:	108000c4 	addi	r2,r2,3
 8239f08:	1085883a 	add	r2,r2,r2
 8239f0c:	1085883a 	add	r2,r2,r2
 8239f10:	1885883a 	add	r2,r3,r2
 8239f14:	10800017 	ldw	r2,0(r2)
 8239f18:	10000c1e 	bne	r2,zero,8239f4c <tcp_slowtimo+0x144>
            {
               /* call usrreq to do actual work */
               so->so_req = PRU_SLOWTIMO;
 8239f1c:	e0bffa17 	ldw	r2,-24(fp)
 8239f20:	00c004c4 	movi	r3,19
 8239f24:	10c00715 	stw	r3,28(r2)
               (void) tcp_usrreq(so, (struct mbuf *)0, 
 8239f28:	e0bff917 	ldw	r2,-28(fp)
 8239f2c:	100d883a 	mov	r6,r2
 8239f30:	000b883a 	mov	r5,zero
 8239f34:	e13ffa17 	ldw	r4,-24(fp)
 8239f38:	823a5580 	call	823a558 <tcp_usrreq>
                                 LONG2MBUF((long)i));

               /* If ip disappeared on us, handle it */
               if (ipnxt->inp_prev != ip)
 8239f3c:	e0bffd17 	ldw	r2,-12(fp)
 8239f40:	10c00117 	ldw	r3,4(r2)
 8239f44:	e0bffc17 	ldw	r2,-16(fp)
 8239f48:	1880381e 	bne	r3,r2,823a02c <tcp_slowtimo+0x224>

         tp = intotcpcb(so->so_pcb);
         if (!tp)
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 8239f4c:	e0bff917 	ldw	r2,-28(fp)
 8239f50:	10800044 	addi	r2,r2,1
 8239f54:	e0bff915 	stw	r2,-28(fp)
 8239f58:	e0bff917 	ldw	r2,-28(fp)
 8239f5c:	10800110 	cmplti	r2,r2,4
 8239f60:	103fcf1e 	bne	r2,zero,8239ea0 <tcp_slowtimo+0x98>
               }
            }
         }
#endif   /* TCP_ZEROCOPY */

         tp->t_idle++;
 8239f64:	e0bffe17 	ldw	r2,-8(fp)
 8239f68:	10801d17 	ldw	r2,116(r2)
 8239f6c:	10c00044 	addi	r3,r2,1
 8239f70:	e0bffe17 	ldw	r2,-8(fp)
 8239f74:	10c01d15 	stw	r3,116(r2)
      }

      /* wake up anyone sleeping in a select() involving this socket */
      sb = &so->so_rcv;
 8239f78:	e0bffa17 	ldw	r2,-24(fp)
 8239f7c:	10800a04 	addi	r2,r2,40
 8239f80:	e0bfff15 	stw	r2,-4(fp)
      if (sb->sb_flags & SB_SEL) 
 8239f84:	e0bfff17 	ldw	r2,-4(fp)
 8239f88:	1080070b 	ldhu	r2,28(r2)
 8239f8c:	10bfffcc 	andi	r2,r2,65535
 8239f90:	1080020c 	andi	r2,r2,8
 8239f94:	10000a26 	beq	r2,zero,8239fc0 <tcp_slowtimo+0x1b8>
      {
         select_wait = 0;
 8239f98:	d020b00d 	sth	zero,-32064(gp)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 8239f9c:	d120b004 	addi	r4,gp,-32064
 8239fa0:	82296a80 	call	82296a8 <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 8239fa4:	e0bfff17 	ldw	r2,-4(fp)
 8239fa8:	10c0070b 	ldhu	r3,28(r2)
 8239fac:	00bffdc4 	movi	r2,-9
 8239fb0:	1884703a 	and	r2,r3,r2
 8239fb4:	1007883a 	mov	r3,r2
 8239fb8:	e0bfff17 	ldw	r2,-4(fp)
 8239fbc:	10c0070d 	sth	r3,28(r2)
      }
      sb = &so->so_snd;
 8239fc0:	e0bffa17 	ldw	r2,-24(fp)
 8239fc4:	10801204 	addi	r2,r2,72
 8239fc8:	e0bfff15 	stw	r2,-4(fp)
      if (sb->sb_flags & SB_SEL) 
 8239fcc:	e0bfff17 	ldw	r2,-4(fp)
 8239fd0:	1080070b 	ldhu	r2,28(r2)
 8239fd4:	10bfffcc 	andi	r2,r2,65535
 8239fd8:	1080020c 	andi	r2,r2,8
 8239fdc:	10000a26 	beq	r2,zero,823a008 <tcp_slowtimo+0x200>
      {
         select_wait = 0;         
 8239fe0:	d020b00d 	sth	zero,-32064(gp)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 8239fe4:	d120b004 	addi	r4,gp,-32064
 8239fe8:	82296a80 	call	82296a8 <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 8239fec:	e0bfff17 	ldw	r2,-4(fp)
 8239ff0:	10c0070b 	ldhu	r3,28(r2)
 8239ff4:	00bffdc4 	movi	r2,-9
 8239ff8:	1884703a 	and	r2,r3,r2
 8239ffc:	1007883a 	mov	r3,r2
 823a000:	e0bfff17 	ldw	r2,-4(fp)
 823a004:	10c0070d 	sth	r3,28(r2)
      }

      /* wake any thread with a timer going for a connection state change */     
      tcp_wakeup((char*)&so->so_timeo);
 823a008:	e0bffa17 	ldw	r2,-24(fp)
 823a00c:	10800904 	addi	r2,r2,36
 823a010:	1009883a 	mov	r4,r2
 823a014:	82296a80 	call	82296a8 <tcp_wakeup>
 823a018:	00000506 	br	823a030 <tcp_slowtimo+0x228>
       */
      if (so->so_type == SOCK_STREAM)
      {
         ip = so->so_pcb;
         if (!ip)
            continue;
 823a01c:	0001883a 	nop
 823a020:	00000306 	br	823a030 <tcp_slowtimo+0x228>
         ipnxt = ip->inp_next;

         tp = intotcpcb(so->so_pcb);
         if (!tp)
            continue;
 823a024:	0001883a 	nop
 823a028:	00000106 	br	823a030 <tcp_slowtimo+0x228>
               (void) tcp_usrreq(so, (struct mbuf *)0, 
                                 LONG2MBUF((long)i));

               /* If ip disappeared on us, handle it */
               if (ipnxt->inp_prev != ip)
                  goto tpgone;
 823a02c:	0001883a 	nop
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 823a030:	e0bffb17 	ldw	r2,-20(fp)
 823a034:	e0bffa15 	stw	r2,-24(fp)
 823a038:	e0bffa17 	ldw	r2,-24(fp)
 823a03c:	103f7e1e 	bne	r2,zero,8239e38 <tcp_slowtimo+0x30>

tpgone:
      ;
   }

   tcp_iss += (unsigned)(TCP_ISSINCR/PR_SLOWHZ);      /* increment iss */
 823a040:	d0e0b517 	ldw	r3,-32044(gp)
 823a044:	00be9fd4 	movui	r2,64127
 823a048:	1885883a 	add	r2,r3,r2
 823a04c:	d0a0b515 	stw	r2,-32044(gp)

   if (tcp_iss & 0xff000000)
 823a050:	d0a0b517 	ldw	r2,-32044(gp)
 823a054:	10bfc02c 	andhi	r2,r2,65280
 823a058:	10000126 	beq	r2,zero,823a060 <tcp_slowtimo+0x258>
      tcp_iss = 0L;
 823a05c:	d020b515 	stw	zero,-32044(gp)
}
 823a060:	0001883a 	nop
 823a064:	e037883a 	mov	sp,fp
 823a068:	dfc00117 	ldw	ra,4(sp)
 823a06c:	df000017 	ldw	fp,0(sp)
 823a070:	dec00204 	addi	sp,sp,8
 823a074:	f800283a 	ret

0823a078 <tcp_canceltimers>:
 * RETURNS: 
 */

void
tcp_canceltimers(struct tcpcb * tp)
{
 823a078:	defffd04 	addi	sp,sp,-12
 823a07c:	df000215 	stw	fp,8(sp)
 823a080:	df000204 	addi	fp,sp,8
 823a084:	e13fff15 	stw	r4,-4(fp)
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 823a088:	e03ffe15 	stw	zero,-8(fp)
 823a08c:	00000a06 	br	823a0b8 <tcp_canceltimers+0x40>
      tp->t_timer[i] = 0;
 823a090:	e0ffff17 	ldw	r3,-4(fp)
 823a094:	e0bffe17 	ldw	r2,-8(fp)
 823a098:	108000c4 	addi	r2,r2,3
 823a09c:	1085883a 	add	r2,r2,r2
 823a0a0:	1085883a 	add	r2,r2,r2
 823a0a4:	1885883a 	add	r2,r3,r2
 823a0a8:	10000015 	stw	zero,0(r2)
void
tcp_canceltimers(struct tcpcb * tp)
{
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 823a0ac:	e0bffe17 	ldw	r2,-8(fp)
 823a0b0:	10800044 	addi	r2,r2,1
 823a0b4:	e0bffe15 	stw	r2,-8(fp)
 823a0b8:	e0bffe17 	ldw	r2,-8(fp)
 823a0bc:	10800110 	cmplti	r2,r2,4
 823a0c0:	103ff31e 	bne	r2,zero,823a090 <tcp_canceltimers+0x18>
      tp->t_timer[i] = 0;
}
 823a0c4:	0001883a 	nop
 823a0c8:	e037883a 	mov	sp,fp
 823a0cc:	df000017 	ldw	fp,0(sp)
 823a0d0:	dec00104 	addi	sp,sp,4
 823a0d4:	f800283a 	ret

0823a0d8 <tcp_timers>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_timers(struct tcpcb * tp, int timer)
{
 823a0d8:	defff804 	addi	sp,sp,-32
 823a0dc:	dfc00715 	stw	ra,28(sp)
 823a0e0:	df000615 	stw	fp,24(sp)
 823a0e4:	df000604 	addi	fp,sp,24
 823a0e8:	e13ffe15 	stw	r4,-8(fp)
 823a0ec:	e17fff15 	stw	r5,-4(fp)
   int   rexmt;

   switch (timer) 
 823a0f0:	e0bfff17 	ldw	r2,-4(fp)
 823a0f4:	10c00060 	cmpeqi	r3,r2,1
 823a0f8:	1800b21e 	bne	r3,zero,823a3c4 <tcp_timers+0x2ec>
 823a0fc:	10c00088 	cmpgei	r3,r2,2
 823a100:	1800021e 	bne	r3,zero,823a10c <tcp_timers+0x34>
 823a104:	10001826 	beq	r2,zero,823a168 <tcp_timers+0x90>
 823a108:	00010d06 	br	823a540 <tcp_timers+0x468>
 823a10c:	10c000a0 	cmpeqi	r3,r2,2
 823a110:	1800bd1e 	bne	r3,zero,823a408 <tcp_timers+0x330>
 823a114:	108000e0 	cmpeqi	r2,r2,3
 823a118:	10010926 	beq	r2,zero,823a540 <tcp_timers+0x468>
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 823a11c:	e0bffe17 	ldw	r2,-8(fp)
 823a120:	10800217 	ldw	r2,8(r2)
 823a124:	108002a0 	cmpeqi	r2,r2,10
 823a128:	10000b1e 	bne	r2,zero,823a158 <tcp_timers+0x80>
          tp->t_idle <= tcp_maxidle)
 823a12c:	e0bffe17 	ldw	r2,-8(fp)
 823a130:	10801d17 	ldw	r2,116(r2)
 823a134:	d0e0b417 	ldw	r3,-32048(gp)
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 823a138:	18800716 	blt	r3,r2,823a158 <tcp_timers+0x80>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
 823a13c:	d0a03f17 	ldw	r2,-32516(gp)
 823a140:	10ffffcc 	andi	r3,r2,65535
 823a144:	18e0001c 	xori	r3,r3,32768
 823a148:	18e00004 	addi	r3,r3,-32768
 823a14c:	e0bffe17 	ldw	r2,-8(fp)
 823a150:	10c00615 	stw	r3,24(r2)
      }
      else
         tp = tcp_close(tp);
      break;
 823a154:	0000fa06 	br	823a540 <tcp_timers+0x468>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
      }
      else
         tp = tcp_close(tp);
 823a158:	e13ffe17 	ldw	r4,-8(fp)
 823a15c:	8239be00 	call	8239be0 <tcp_close>
 823a160:	e0bffe15 	stw	r2,-8(fp)
      break;
 823a164:	0000f606 	br	823a540 <tcp_timers+0x468>
    * Retransmission timer went off.  Message has not
    * been acked within retransmit interval.  Back off
    * to a longer retransmit interval and retransmit one segment.
    */
   case TCPT_REXMT:
      TCP_MIB_INC(tcpRetransSegs);     /* keep MIB stats */
 823a168:	008209b4 	movhi	r2,2086
 823a16c:	10b95d04 	addi	r2,r2,-6796
 823a170:	10800b17 	ldw	r2,44(r2)
 823a174:	10c00044 	addi	r3,r2,1
 823a178:	008209b4 	movhi	r2,2086
 823a17c:	10b95d04 	addi	r2,r2,-6796
 823a180:	10c00b15 	stw	r3,44(r2)
      if (++tp->t_rxtshift > TCP_MAXRXTSHIFT) 
 823a184:	e0bffe17 	ldw	r2,-8(fp)
 823a188:	10800717 	ldw	r2,28(r2)
 823a18c:	10c00044 	addi	r3,r2,1
 823a190:	e0bffe17 	ldw	r2,-8(fp)
 823a194:	10c00715 	stw	r3,28(r2)
 823a198:	e0bffe17 	ldw	r2,-8(fp)
 823a19c:	10800717 	ldw	r2,28(r2)
 823a1a0:	10800350 	cmplti	r2,r2,13
 823a1a4:	10000f1e 	bne	r2,zero,823a1e4 <tcp_timers+0x10c>
      {
         tp->t_rxtshift = TCP_MAXRXTSHIFT;
 823a1a8:	e0bffe17 	ldw	r2,-8(fp)
 823a1ac:	00c00304 	movi	r3,12
 823a1b0:	10c00715 	stw	r3,28(r2)
         tcpstat.tcps_timeoutdrop++;
 823a1b4:	008209b4 	movhi	r2,2086
 823a1b8:	10b98b04 	addi	r2,r2,-6612
 823a1bc:	10800917 	ldw	r2,36(r2)
 823a1c0:	10c00044 	addi	r3,r2,1
 823a1c4:	008209b4 	movhi	r2,2086
 823a1c8:	10b98b04 	addi	r2,r2,-6612
 823a1cc:	10c00915 	stw	r3,36(r2)
         tp = tcp_drop(tp, ETIMEDOUT);
 823a1d0:	01401d04 	movi	r5,116
 823a1d4:	e13ffe17 	ldw	r4,-8(fp)
 823a1d8:	8239b340 	call	8239b34 <tcp_drop>
 823a1dc:	e0bffe15 	stw	r2,-8(fp)
         break;
 823a1e0:	0000d706 	br	823a540 <tcp_timers+0x468>
      }
      tcpstat.tcps_rexmttimeo++;
 823a1e4:	008209b4 	movhi	r2,2086
 823a1e8:	10b98b04 	addi	r2,r2,-6612
 823a1ec:	10800a17 	ldw	r2,40(r2)
 823a1f0:	10c00044 	addi	r3,r2,1
 823a1f4:	008209b4 	movhi	r2,2086
 823a1f8:	10b98b04 	addi	r2,r2,-6612
 823a1fc:	10c00a15 	stw	r3,40(r2)
      rexmt = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 823a200:	e0bffe17 	ldw	r2,-8(fp)
 823a204:	10802017 	ldw	r2,128(r2)
 823a208:	1007d0ba 	srai	r3,r2,2
 823a20c:	e0bffe17 	ldw	r2,-8(fp)
 823a210:	10802117 	ldw	r2,132(r2)
 823a214:	1885883a 	add	r2,r3,r2
 823a218:	1005d07a 	srai	r2,r2,1
 823a21c:	e0bffd15 	stw	r2,-12(fp)
      rexmt *= tcp_backoff[tp->t_rxtshift];
 823a220:	e0bffe17 	ldw	r2,-8(fp)
 823a224:	10c00717 	ldw	r3,28(r2)
 823a228:	00820974 	movhi	r2,2085
 823a22c:	108ec5c4 	addi	r2,r2,15127
 823a230:	10c5883a 	add	r2,r2,r3
 823a234:	10800003 	ldbu	r2,0(r2)
 823a238:	10803fcc 	andi	r2,r2,255
 823a23c:	e0fffd17 	ldw	r3,-12(fp)
 823a240:	1885383a 	mul	r2,r3,r2
 823a244:	e0bffd15 	stw	r2,-12(fp)
      TCPT_RANGESET(tp->t_rxtcur, rexmt, TCPTV_MIN, TCPTV_REXMTMAX);
 823a248:	e0bffd17 	ldw	r2,-12(fp)
 823a24c:	10ffffcc 	andi	r3,r2,65535
 823a250:	18e0001c 	xori	r3,r3,32768
 823a254:	18e00004 	addi	r3,r3,-32768
 823a258:	e0bffe17 	ldw	r2,-8(fp)
 823a25c:	10c00815 	stw	r3,32(r2)
 823a260:	e0bffe17 	ldw	r2,-8(fp)
 823a264:	10800817 	ldw	r2,32(r2)
 823a268:	10800088 	cmpgei	r2,r2,2
 823a26c:	1000041e 	bne	r2,zero,823a280 <tcp_timers+0x1a8>
 823a270:	e0bffe17 	ldw	r2,-8(fp)
 823a274:	00c00084 	movi	r3,2
 823a278:	10c00815 	stw	r3,32(r2)
 823a27c:	00000706 	br	823a29c <tcp_timers+0x1c4>
 823a280:	e0bffe17 	ldw	r2,-8(fp)
 823a284:	10800817 	ldw	r2,32(r2)
 823a288:	10802050 	cmplti	r2,r2,129
 823a28c:	1000031e 	bne	r2,zero,823a29c <tcp_timers+0x1c4>
 823a290:	e0bffe17 	ldw	r2,-8(fp)
 823a294:	00c02004 	movi	r3,128
 823a298:	10c00815 	stw	r3,32(r2)
      tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 823a29c:	e0bffe17 	ldw	r2,-8(fp)
 823a2a0:	10c00817 	ldw	r3,32(r2)
 823a2a4:	e0bffe17 	ldw	r2,-8(fp)
 823a2a8:	10c00315 	stw	r3,12(r2)
       * so we'll take the next rtt measurement as our srtt;
       * move the current srtt into rttvar to keep the current
       * retransmit times until then. Don't clobber with rtt
       * if we got it from a timestamp option.
       */
      if((tp->t_rxtshift > TCP_MAXRXTSHIFT / 4) &&
 823a2ac:	e0bffe17 	ldw	r2,-8(fp)
 823a2b0:	10800717 	ldw	r2,28(r2)
 823a2b4:	10800110 	cmplti	r2,r2,4
 823a2b8:	10000f1e 	bne	r2,zero,823a2f8 <tcp_timers+0x220>
         ((tp->t_flags & TF_TIMESTAMP) == 0))
 823a2bc:	e0bffe17 	ldw	r2,-8(fp)
 823a2c0:	10800b0b 	ldhu	r2,44(r2)
 823a2c4:	10bfffcc 	andi	r2,r2,65535
 823a2c8:	1080400c 	andi	r2,r2,256
       * so we'll take the next rtt measurement as our srtt;
       * move the current srtt into rttvar to keep the current
       * retransmit times until then. Don't clobber with rtt
       * if we got it from a timestamp option.
       */
      if((tp->t_rxtshift > TCP_MAXRXTSHIFT / 4) &&
 823a2cc:	10000a1e 	bne	r2,zero,823a2f8 <tcp_timers+0x220>
         ((tp->t_flags & TF_TIMESTAMP) == 0))
      {
         tp->t_rttvar += (tp->t_srtt >> 2);
 823a2d0:	e0bffe17 	ldw	r2,-8(fp)
 823a2d4:	10c02117 	ldw	r3,132(r2)
 823a2d8:	e0bffe17 	ldw	r2,-8(fp)
 823a2dc:	10802017 	ldw	r2,128(r2)
 823a2e0:	1005d0ba 	srai	r2,r2,2
 823a2e4:	1887883a 	add	r3,r3,r2
 823a2e8:	e0bffe17 	ldw	r2,-8(fp)
 823a2ec:	10c02115 	stw	r3,132(r2)
         tp->t_srtt = 0;
 823a2f0:	e0bffe17 	ldw	r2,-8(fp)
 823a2f4:	10002015 	stw	zero,128(r2)
      }
      tp->snd_nxt = tp->snd_una;
 823a2f8:	e0bffe17 	ldw	r2,-8(fp)
 823a2fc:	10c00e17 	ldw	r3,56(r2)
 823a300:	e0bffe17 	ldw	r2,-8(fp)
 823a304:	10c00f15 	stw	r3,60(r2)
      /*
       * If timing a segment in this window, stop the timer.
       */
      tp->t_rttick = 0;
 823a308:	e0bffe17 	ldw	r2,-8(fp)
 823a30c:	10001e15 	stw	zero,120(r2)
       * to go below this.)
       *
       * Vers 1.9 - Skip slow start if the SO_NOSLOWSTART socket option
       * is set.
       */
      if((tp->t_inpcb->inp_socket->so_options & SO_NOSLOWSTART) == 0)
 823a310:	e0bffe17 	ldw	r2,-8(fp)
 823a314:	10800d17 	ldw	r2,52(r2)
 823a318:	10800817 	ldw	r2,32(r2)
 823a31c:	10800417 	ldw	r2,16(r2)
 823a320:	1090000c 	andi	r2,r2,16384
 823a324:	1000241e 	bne	r2,zero,823a3b8 <tcp_timers+0x2e0>
      {
         u_int win = MIN(tp->snd_wnd, tp->snd_cwnd);
 823a328:	e0bffe17 	ldw	r2,-8(fp)
 823a32c:	11001417 	ldw	r4,80(r2)
 823a330:	e0bffe17 	ldw	r2,-8(fp)
 823a334:	10c01b17 	ldw	r3,108(r2)
 823a338:	2005883a 	mov	r2,r4
 823a33c:	1880012e 	bgeu	r3,r2,823a344 <tcp_timers+0x26c>
 823a340:	1805883a 	mov	r2,r3
 823a344:	e0bffc15 	stw	r2,-16(fp)
         win = win / 2 / tp->t_maxseg;
 823a348:	e0bffc17 	ldw	r2,-16(fp)
 823a34c:	1006d07a 	srli	r3,r2,1
 823a350:	e0bffe17 	ldw	r2,-8(fp)
 823a354:	10800a0b 	ldhu	r2,40(r2)
 823a358:	10bfffcc 	andi	r2,r2,65535
 823a35c:	100b883a 	mov	r5,r2
 823a360:	1809883a 	mov	r4,r3
 823a364:	8202c100 	call	8202c10 <__udivsi3>
 823a368:	e0bffc15 	stw	r2,-16(fp)
         if (win < 2)
 823a36c:	e0bffc17 	ldw	r2,-16(fp)
 823a370:	108000a8 	cmpgeui	r2,r2,2
 823a374:	1000021e 	bne	r2,zero,823a380 <tcp_timers+0x2a8>
            win = 2;
 823a378:	00800084 	movi	r2,2
 823a37c:	e0bffc15 	stw	r2,-16(fp)
         tp->snd_cwnd = tp->t_maxseg;
 823a380:	e0bffe17 	ldw	r2,-8(fp)
 823a384:	10800a0b 	ldhu	r2,40(r2)
 823a388:	10ffffcc 	andi	r3,r2,65535
 823a38c:	e0bffe17 	ldw	r2,-8(fp)
 823a390:	10c01b15 	stw	r3,108(r2)
         tp->snd_ssthresh = (u_short)win * tp->t_maxseg;
 823a394:	e0bffc17 	ldw	r2,-16(fp)
 823a398:	10ffffcc 	andi	r3,r2,65535
 823a39c:	e0bffe17 	ldw	r2,-8(fp)
 823a3a0:	10800a0b 	ldhu	r2,40(r2)
 823a3a4:	10bfffcc 	andi	r2,r2,65535
 823a3a8:	1885383a 	mul	r2,r3,r2
 823a3ac:	1007883a 	mov	r3,r2
 823a3b0:	e0bffe17 	ldw	r2,-8(fp)
 823a3b4:	10c01c15 	stw	r3,112(r2)
      }
      (void) tcp_output(tp);
 823a3b8:	e13ffe17 	ldw	r4,-8(fp)
 823a3bc:	82383000 	call	8238300 <tcp_output>
      break;
 823a3c0:	00005f06 	br	823a540 <tcp_timers+0x468>
   /*
    * Persistance timer into zero window.
    * Force a byte to be output, if possible.
    */
   case TCPT_PERSIST:
      tcpstat.tcps_persisttimeo++;
 823a3c4:	008209b4 	movhi	r2,2086
 823a3c8:	10b98b04 	addi	r2,r2,-6612
 823a3cc:	10800b17 	ldw	r2,44(r2)
 823a3d0:	10c00044 	addi	r3,r2,1
 823a3d4:	008209b4 	movhi	r2,2086
 823a3d8:	10b98b04 	addi	r2,r2,-6612
 823a3dc:	10c00b15 	stw	r3,44(r2)
      tcp_setpersist(tp);
 823a3e0:	e13ffe17 	ldw	r4,-8(fp)
 823a3e4:	82393040 	call	8239304 <tcp_setpersist>
      tp->t_force = 1;
 823a3e8:	e0bffe17 	ldw	r2,-8(fp)
 823a3ec:	00c00044 	movi	r3,1
 823a3f0:	10c00a85 	stb	r3,42(r2)
      (void) tcp_output(tp);
 823a3f4:	e13ffe17 	ldw	r4,-8(fp)
 823a3f8:	82383000 	call	8238300 <tcp_output>
      tp->t_force = 0;
 823a3fc:	e0bffe17 	ldw	r2,-8(fp)
 823a400:	10000a85 	stb	zero,42(r2)
      break;
 823a404:	00004e06 	br	823a540 <tcp_timers+0x468>
   /*
    * Keep-alive timer went off; send something
    * or drop connection if idle for too long.
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
 823a408:	008209b4 	movhi	r2,2086
 823a40c:	10b98b04 	addi	r2,r2,-6612
 823a410:	10800c17 	ldw	r2,48(r2)
 823a414:	10c00044 	addi	r3,r2,1
 823a418:	008209b4 	movhi	r2,2086
 823a41c:	10b98b04 	addi	r2,r2,-6612
 823a420:	10c00c15 	stw	r3,48(r2)
      if (tp->t_state < TCPS_ESTABLISHED)
 823a424:	e0bffe17 	ldw	r2,-8(fp)
 823a428:	10800217 	ldw	r2,8(r2)
 823a42c:	10800108 	cmpgei	r2,r2,4
 823a430:	10003426 	beq	r2,zero,823a504 <tcp_timers+0x42c>
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 823a434:	e0bffe17 	ldw	r2,-8(fp)
 823a438:	10800d17 	ldw	r2,52(r2)
 823a43c:	10800817 	ldw	r2,32(r2)
 823a440:	10800417 	ldw	r2,16(r2)
 823a444:	1080020c 	andi	r2,r2,8
 823a448:	10002726 	beq	r2,zero,823a4e8 <tcp_timers+0x410>
          tp->t_state <= TCPS_CLOSE_WAIT) 
 823a44c:	e0bffe17 	ldw	r2,-8(fp)
 823a450:	10800217 	ldw	r2,8(r2)
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
      if (tp->t_state < TCPS_ESTABLISHED)
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 823a454:	10800188 	cmpgei	r2,r2,6
 823a458:	1000231e 	bne	r2,zero,823a4e8 <tcp_timers+0x410>
          tp->t_state <= TCPS_CLOSE_WAIT) 
      {
         if (tp->t_idle >= tcp_keepidle + tcp_maxidle)
 823a45c:	e0bffe17 	ldw	r2,-8(fp)
 823a460:	10c01d17 	ldw	r3,116(r2)
 823a464:	d1203e17 	ldw	r4,-32520(gp)
 823a468:	d0a0b417 	ldw	r2,-32048(gp)
 823a46c:	2085883a 	add	r2,r4,r2
 823a470:	1880260e 	bge	r3,r2,823a50c <tcp_timers+0x434>
          * causes the transmitted zero-length segment
          * to lie outside the receive window;
          * by the protocol spec, this requires the
          * correspondent TCP to respond.
          */
         tcpstat.tcps_keepprobe++;
 823a474:	008209b4 	movhi	r2,2086
 823a478:	10b98b04 	addi	r2,r2,-6612
 823a47c:	10800d17 	ldw	r2,52(r2)
 823a480:	10c00044 	addi	r3,r2,1
 823a484:	008209b4 	movhi	r2,2086
 823a488:	10b98b04 	addi	r2,r2,-6612
 823a48c:	10c00d15 	stw	r3,52(r2)

         /*
          * The keepalive packet must have nonzero length
          * to get a 4.2 host to respond.
          */
         tcp_respond(tp, tp->t_template, tp->rcv_nxt - 1,
 823a490:	e0bffe17 	ldw	r2,-8(fp)
 823a494:	10c00c17 	ldw	r3,48(r2)
 823a498:	e0bffe17 	ldw	r2,-8(fp)
 823a49c:	10801617 	ldw	r2,88(r2)
 823a4a0:	113fffc4 	addi	r4,r2,-1
            tp->snd_una - 1, 0, (struct mbuf *)NULL);
 823a4a4:	e0bffe17 	ldw	r2,-8(fp)
 823a4a8:	10800e17 	ldw	r2,56(r2)

         /*
          * The keepalive packet must have nonzero length
          * to get a 4.2 host to respond.
          */
         tcp_respond(tp, tp->t_template, tp->rcv_nxt - 1,
 823a4ac:	10bfffc4 	addi	r2,r2,-1
 823a4b0:	d8000115 	stw	zero,4(sp)
 823a4b4:	d8000015 	stw	zero,0(sp)
 823a4b8:	100f883a 	mov	r7,r2
 823a4bc:	200d883a 	mov	r6,r4
 823a4c0:	180b883a 	mov	r5,r3
 823a4c4:	e13ffe17 	ldw	r4,-8(fp)
 823a4c8:	82396280 	call	8239628 <tcp_respond>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
 823a4cc:	d0a03f17 	ldw	r2,-32516(gp)
 823a4d0:	10ffffcc 	andi	r3,r2,65535
 823a4d4:	18e0001c 	xori	r3,r3,32768
 823a4d8:	18e00004 	addi	r3,r3,-32768
 823a4dc:	e0bffe17 	ldw	r2,-8(fp)
 823a4e0:	10c00515 	stw	r3,20(r2)
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
      break;
 823a4e4:	00001606 	br	823a540 <tcp_timers+0x468>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
 823a4e8:	d0a03e17 	ldw	r2,-32520(gp)
 823a4ec:	10ffffcc 	andi	r3,r2,65535
 823a4f0:	18e0001c 	xori	r3,r3,32768
 823a4f4:	18e00004 	addi	r3,r3,-32768
 823a4f8:	e0bffe17 	ldw	r2,-8(fp)
 823a4fc:	10c00515 	stw	r3,20(r2)
      break;
 823a500:	00000f06 	br	823a540 <tcp_timers+0x468>
    * or drop connection if idle for too long.
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
      if (tp->t_state < TCPS_ESTABLISHED)
         goto dropit;
 823a504:	0001883a 	nop
 823a508:	00000106 	br	823a510 <tcp_timers+0x438>
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
          tp->t_state <= TCPS_CLOSE_WAIT) 
      {
         if (tp->t_idle >= tcp_keepidle + tcp_maxidle)
            goto dropit;
 823a50c:	0001883a 	nop
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
      break;
      dropit:
      tcpstat.tcps_keepdrops++;
 823a510:	008209b4 	movhi	r2,2086
 823a514:	10b98b04 	addi	r2,r2,-6612
 823a518:	10800e17 	ldw	r2,56(r2)
 823a51c:	10c00044 	addi	r3,r2,1
 823a520:	008209b4 	movhi	r2,2086
 823a524:	10b98b04 	addi	r2,r2,-6612
 823a528:	10c00e15 	stw	r3,56(r2)
      tp = tcp_drop (tp, ETIMEDOUT);
 823a52c:	01401d04 	movi	r5,116
 823a530:	e13ffe17 	ldw	r4,-8(fp)
 823a534:	8239b340 	call	8239b34 <tcp_drop>
 823a538:	e0bffe15 	stw	r2,-8(fp)
      break;
 823a53c:	0001883a 	nop
   }
   return tp;
 823a540:	e0bffe17 	ldw	r2,-8(fp)
}
 823a544:	e037883a 	mov	sp,fp
 823a548:	dfc00117 	ldw	ra,4(sp)
 823a54c:	df000017 	ldw	fp,0(sp)
 823a550:	dec00204 	addi	sp,sp,8
 823a554:	f800283a 	ret

0823a558 <tcp_usrreq>:

int
tcp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 823a558:	defff604 	addi	sp,sp,-40
 823a55c:	dfc00915 	stw	ra,36(sp)
 823a560:	df000815 	stw	fp,32(sp)
 823a564:	df000804 	addi	fp,sp,32
 823a568:	e13ffd15 	stw	r4,-12(fp)
 823a56c:	e17ffe15 	stw	r5,-8(fp)
 823a570:	e1bfff15 	stw	r6,-4(fp)
   struct inpcb * inp;
   struct tcpcb * tp;
   int   error =  0;
 823a574:	e03ff915 	stw	zero,-28(fp)

#ifdef DO_TCPTRACE
   int   ostate;
#endif

   req = so->so_req;    /* get request from socket struct */
 823a578:	e0bffd17 	ldw	r2,-12(fp)
 823a57c:	10800717 	ldw	r2,28(r2)
 823a580:	e0bffa15 	stw	r2,-24(fp)
   inp = sotoinpcb(so);
 823a584:	e0bffd17 	ldw	r2,-12(fp)
 823a588:	10800117 	ldw	r2,4(r2)
 823a58c:	e0bffb15 	stw	r2,-20(fp)
   /*
    * When a TCP is attached to a socket, then there will be
    * a (struct inpcb) pointed at by the socket, and this
    * structure will point at a subsidary (struct tcpcb).
    */
   if (inp == 0 && req != PRU_ATTACH) 
 823a590:	e0bffb17 	ldw	r2,-20(fp)
 823a594:	1000041e 	bne	r2,zero,823a5a8 <tcp_usrreq+0x50>
 823a598:	e0bffa17 	ldw	r2,-24(fp)
 823a59c:	10000226 	beq	r2,zero,823a5a8 <tcp_usrreq+0x50>
   {
      return (EINVAL);
 823a5a0:	00800584 	movi	r2,22
 823a5a4:	00019c06 	br	823ac18 <tcp_usrreq+0x6c0>
   }

   if (inp)
 823a5a8:	e0bffb17 	ldw	r2,-20(fp)
 823a5ac:	10000426 	beq	r2,zero,823a5c0 <tcp_usrreq+0x68>
      tp = intotcpcb(inp);
 823a5b0:	e0bffb17 	ldw	r2,-20(fp)
 823a5b4:	10800917 	ldw	r2,36(r2)
 823a5b8:	e0bff815 	stw	r2,-32(fp)
 823a5bc:	00000706 	br	823a5dc <tcp_usrreq+0x84>
   else  /* inp and tp not set, make sure this is OK: */
   { 
      if (req == PRU_ATTACH)
 823a5c0:	e0bffa17 	ldw	r2,-24(fp)
 823a5c4:	1000021e 	bne	r2,zero,823a5d0 <tcp_usrreq+0x78>
         tp = NULL;  /* stifle compiler warnings about using unassigned tp*/
 823a5c8:	e03ff815 	stw	zero,-32(fp)
 823a5cc:	00000306 	br	823a5dc <tcp_usrreq+0x84>
      else
      {
         dtrap(); /* programming error? */
 823a5d0:	822d5940 	call	822d594 <dtrap>
         return EINVAL;
 823a5d4:	00800584 	movi	r2,22
 823a5d8:	00018f06 	br	823ac18 <tcp_usrreq+0x6c0>
      }
   }

   switch (req) 
 823a5dc:	e0bffa17 	ldw	r2,-24(fp)
 823a5e0:	10800528 	cmpgeui	r2,r2,20
 823a5e4:	1001761e 	bne	r2,zero,823abc0 <tcp_usrreq+0x668>
 823a5e8:	e0bffa17 	ldw	r2,-24(fp)
 823a5ec:	100690ba 	slli	r3,r2,2
 823a5f0:	00820934 	movhi	r2,2084
 823a5f4:	10a98104 	addi	r2,r2,-23036
 823a5f8:	1885883a 	add	r2,r3,r2
 823a5fc:	10800017 	ldw	r2,0(r2)
 823a600:	1000683a 	jmp	r2
 823a604:	0823a654 	ori	zero,at,36505
 823a608:	0823a6b4 	orhi	zero,at,36506
 823a60c:	0823a6dc 	xori	zero,at,36507
 823a610:	0823a714 	ori	zero,at,36508
 823a614:	0823a74c 	andi	zero,at,36509
 823a618:	0823a8a4 	muli	zero,at,-29022
 823a61c:	0823a898 	cmpnei	zero,at,-29022
 823a620:	0823a954 	ori	zero,at,36517
 823a624:	0823a980 	call	823a98 <OSCtxSw_SWITCH_PC+0x823a58>
 823a628:	0823a98c 	andi	zero,at,36518
 823a62c:	0823a9e8 	cmpgeui	zero,at,36519
 823a630:	0823abc0 	call	823abc <OSCtxSw_SWITCH_PC+0x823a7c>
 823a634:	0823a9f8 	rdprs	zero,at,-29017
 823a638:	0823aa04 	addi	zero,at,-29016
 823a63c:	0823aabc 	xorhi	zero,at,36522
 823a640:	0823ab8c 	andi	zero,at,36526
 823a644:	0823ab9c 	xori	zero,at,36526
 823a648:	0823a88c 	andi	zero,at,36514
 823a64c:	0823abc0 	call	823abc <OSCtxSw_SWITCH_PC+0x823a7c>
 823a650:	0823abac 	andhi	zero,at,36526
   /*
    * TCP attaches to socket via PRU_ATTACH, reserving space,
    * and an internet control block.
    */
   case PRU_ATTACH:
      if (inp) 
 823a654:	e0bffb17 	ldw	r2,-20(fp)
 823a658:	10000326 	beq	r2,zero,823a668 <tcp_usrreq+0x110>
      {
         error = EISCONN;
 823a65c:	00801fc4 	movi	r2,127
 823a660:	e0bff915 	stw	r2,-28(fp)
         break;
 823a664:	00016b06 	br	823ac14 <tcp_usrreq+0x6bc>
      }
      error = tcp_attach(so);
 823a668:	e13ffd17 	ldw	r4,-12(fp)
 823a66c:	823ac2c0 	call	823ac2c <tcp_attach>
 823a670:	e0bff915 	stw	r2,-28(fp)
      if (error)
 823a674:	e0bff917 	ldw	r2,-28(fp)
 823a678:	1001551e 	bne	r2,zero,823abd0 <tcp_usrreq+0x678>
         break;
      if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 823a67c:	e0bffd17 	ldw	r2,-12(fp)
 823a680:	10800417 	ldw	r2,16(r2)
 823a684:	1080200c 	andi	r2,r2,128
 823a688:	10015326 	beq	r2,zero,823abd8 <tcp_usrreq+0x680>
 823a68c:	e0bffd17 	ldw	r2,-12(fp)
 823a690:	1080080b 	ldhu	r2,32(r2)
 823a694:	10bfffcc 	andi	r2,r2,65535
 823a698:	10a0001c 	xori	r2,r2,32768
 823a69c:	10a00004 	addi	r2,r2,-32768
 823a6a0:	10014d1e 	bne	r2,zero,823abd8 <tcp_usrreq+0x680>
         so->so_linger = TCP_LINGERTIME;
 823a6a4:	e0bffd17 	ldw	r2,-12(fp)
 823a6a8:	00c01e04 	movi	r3,120
 823a6ac:	10c0080d 	sth	r3,32(r2)
#ifdef   DO_TCPTRACE
      SETTP(tp, sototcpcb(so));
#endif
      break;
 823a6b0:	00014906 	br	823abd8 <tcp_usrreq+0x680>
    * do this directly: have to initiate a PRU_DISCONNECT,
    * which may finish later; embryonic TCB's can just
    * be discarded here.
    */
   case PRU_DETACH:
      if (tp->t_state > TCPS_LISTEN)
 823a6b4:	e0bff817 	ldw	r2,-32(fp)
 823a6b8:	10800217 	ldw	r2,8(r2)
 823a6bc:	10800090 	cmplti	r2,r2,2
 823a6c0:	1000031e 	bne	r2,zero,823a6d0 <tcp_usrreq+0x178>
         SETTP(tp, tcp_disconnect(tp));
 823a6c4:	e13ff817 	ldw	r4,-32(fp)
 823a6c8:	823ad440 	call	823ad44 <tcp_disconnect>
      else
         SETTP(tp, tcp_close(tp));
      break;
 823a6cc:	00015106 	br	823ac14 <tcp_usrreq+0x6bc>
    */
   case PRU_DETACH:
      if (tp->t_state > TCPS_LISTEN)
         SETTP(tp, tcp_disconnect(tp));
      else
         SETTP(tp, tcp_close(tp));
 823a6d0:	e13ff817 	ldw	r4,-32(fp)
 823a6d4:	8239be00 	call	8239be0 <tcp_close>
      break;
 823a6d8:	00014e06 	br	823ac14 <tcp_usrreq+0x6bc>
      /* bind is quite different for IPv4 and v6, so we use two 
       * seperate pcbbind routines. so_domain was checked for 
       * validity way up in t_bind()
       */
#ifdef IP_V4
      if(inp->inp_socket->so_domain == AF_INET)
 823a6dc:	e0bffb17 	ldw	r2,-20(fp)
 823a6e0:	10800817 	ldw	r2,32(r2)
 823a6e4:	10800517 	ldw	r2,20(r2)
 823a6e8:	10800098 	cmpnei	r2,r2,2
 823a6ec:	1000051e 	bne	r2,zero,823a704 <tcp_usrreq+0x1ac>
      {
         error = in_pcbbind(inp, nam);
 823a6f0:	e17fff17 	ldw	r5,-4(fp)
 823a6f4:	e13ffb17 	ldw	r4,-20(fp)
 823a6f8:	8247f180 	call	8247f18 <in_pcbbind>
 823a6fc:	e0bff915 	stw	r2,-28(fp)
         break;
 823a700:	00014406 	br	823ac14 <tcp_usrreq+0x6bc>
      {
         error = ip6_pcbbind(inp, nam);
         break;
      }
#endif /* IP_V6 */
      dtrap();    /* not v4 or v6? */
 823a704:	822d5940 	call	822d594 <dtrap>
      error = EINVAL;
 823a708:	00800584 	movi	r2,22
 823a70c:	e0bff915 	stw	r2,-28(fp)
      break;
 823a710:	00014006 	br	823ac14 <tcp_usrreq+0x6bc>
   /*
    * Prepare to accept connections.
    */
   case PRU_LISTEN:
      if (inp->inp_lport == 0)
 823a714:	e0bffb17 	ldw	r2,-20(fp)
 823a718:	1080078b 	ldhu	r2,30(r2)
 823a71c:	10bfffcc 	andi	r2,r2,65535
 823a720:	1000041e 	bne	r2,zero,823a734 <tcp_usrreq+0x1dc>
         error = in_pcbbind(inp, (struct mbuf *)0);
 823a724:	000b883a 	mov	r5,zero
 823a728:	e13ffb17 	ldw	r4,-20(fp)
 823a72c:	8247f180 	call	8247f18 <in_pcbbind>
 823a730:	e0bff915 	stw	r2,-28(fp)
      if (error == 0)
 823a734:	e0bff917 	ldw	r2,-28(fp)
 823a738:	1001291e 	bne	r2,zero,823abe0 <tcp_usrreq+0x688>
         tp->t_state = TCPS_LISTEN;
 823a73c:	e0bff817 	ldw	r2,-32(fp)
 823a740:	00c00044 	movi	r3,1
 823a744:	10c00215 	stw	r3,8(r2)
      break;
 823a748:	00012506 	br	823abe0 <tcp_usrreq+0x688>
    * Enter SYN_SENT state, and mark socket as connecting.
    * Start keep-alive timer, and seed output sequence space.
    * Send initial segment on connection.
    */
   case PRU_CONNECT:
      if (inp->inp_lport == 0) 
 823a74c:	e0bffb17 	ldw	r2,-20(fp)
 823a750:	1080078b 	ldhu	r2,30(r2)
 823a754:	10bfffcc 	andi	r2,r2,65535
 823a758:	1000061e 	bne	r2,zero,823a774 <tcp_usrreq+0x21c>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbbind(inp, (struct mbuf *)0);
 823a75c:	000b883a 	mov	r5,zero
 823a760:	e13ffb17 	ldw	r4,-20(fp)
 823a764:	8247f180 	call	8247f18 <in_pcbbind>
 823a768:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbbind(inp, (struct mbuf *)0);
#endif   /* end v6 only */

         if (error)
 823a76c:	e0bff917 	ldw	r2,-28(fp)
 823a770:	10011d1e 	bne	r2,zero,823abe8 <tcp_usrreq+0x690>
            break;
      }

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbconnect(inp, nam);
 823a774:	e17fff17 	ldw	r5,-4(fp)
 823a778:	e13ffb17 	ldw	r4,-20(fp)
 823a77c:	82481280 	call	8248128 <in_pcbconnect>
 823a780:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbconnect(inp, nam);
#endif   /* end v6 only */

      if (error)
 823a784:	e0bff917 	ldw	r2,-28(fp)
 823a788:	1001191e 	bne	r2,zero,823abf0 <tcp_usrreq+0x698>
         break;
      tp->t_template = tcp_template(tp);
 823a78c:	e13ff817 	ldw	r4,-32(fp)
 823a790:	82395200 	call	8239520 <tcp_template>
 823a794:	1007883a 	mov	r3,r2
 823a798:	e0bff817 	ldw	r2,-32(fp)
 823a79c:	10c00c15 	stw	r3,48(r2)
      if (tp->t_template == 0) 
 823a7a0:	e0bff817 	ldw	r2,-32(fp)
 823a7a4:	10800c17 	ldw	r2,48(r2)
 823a7a8:	1000051e 	bne	r2,zero,823a7c0 <tcp_usrreq+0x268>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
         in_pcbdisconnect(inp);
 823a7ac:	e13ffb17 	ldw	r4,-20(fp)
 823a7b0:	82483080 	call	8248308 <in_pcbdisconnect>
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
         ip6_pcbdisconnect(inp);
#endif   /* end v6 only */

         error = ENOBUFS;
 823a7b4:	00801a44 	movi	r2,105
 823a7b8:	e0bff915 	stw	r2,-28(fp)
         break;
 823a7bc:	00011506 	br	823ac14 <tcp_usrreq+0x6bc>
      }

      soisconnecting(so);
 823a7c0:	e13ffd17 	ldw	r4,-12(fp)
 823a7c4:	8233a680 	call	8233a68 <soisconnecting>
      tcpstat.tcps_connattempt++;
 823a7c8:	008209b4 	movhi	r2,2086
 823a7cc:	10b98b04 	addi	r2,r2,-6612
 823a7d0:	10800017 	ldw	r2,0(r2)
 823a7d4:	10c00044 	addi	r3,r2,1
 823a7d8:	008209b4 	movhi	r2,2086
 823a7dc:	10b98b04 	addi	r2,r2,-6612
 823a7e0:	10c00015 	stw	r3,0(r2)
      tp->t_state = TCPS_SYN_SENT;
 823a7e4:	e0bff817 	ldw	r2,-32(fp)
 823a7e8:	00c00084 	movi	r3,2
 823a7ec:	10c00215 	stw	r3,8(r2)
      tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 823a7f0:	e0bff817 	ldw	r2,-32(fp)
 823a7f4:	00c02584 	movi	r3,150
 823a7f8:	10c00515 	stw	r3,20(r2)
      tp->iss = tcp_iss; 
 823a7fc:	d0e0b517 	ldw	r3,-32044(gp)
 823a800:	e0bff817 	ldw	r2,-32(fp)
 823a804:	10c01315 	stw	r3,76(r2)
      tcp_iss += (tcp_seq)(TCP_ISSINCR/2);
 823a808:	d0e0b517 	ldw	r3,-32044(gp)
 823a80c:	00be9fd4 	movui	r2,64127
 823a810:	1885883a 	add	r2,r3,r2
 823a814:	d0a0b515 	stw	r2,-32044(gp)
      tcp_sendseqinit(tp);
 823a818:	e0bff817 	ldw	r2,-32(fp)
 823a81c:	10c01317 	ldw	r3,76(r2)
 823a820:	e0bff817 	ldw	r2,-32(fp)
 823a824:	10c01015 	stw	r3,64(r2)
 823a828:	e0bff817 	ldw	r2,-32(fp)
 823a82c:	10c01017 	ldw	r3,64(r2)
 823a830:	e0bff817 	ldw	r2,-32(fp)
 823a834:	10c01a15 	stw	r3,104(r2)
 823a838:	e0bff817 	ldw	r2,-32(fp)
 823a83c:	10c01a17 	ldw	r3,104(r2)
 823a840:	e0bff817 	ldw	r2,-32(fp)
 823a844:	10c00f15 	stw	r3,60(r2)
 823a848:	e0bff817 	ldw	r2,-32(fp)
 823a84c:	10c00f17 	ldw	r3,60(r2)
 823a850:	e0bff817 	ldw	r2,-32(fp)
 823a854:	10c00e15 	stw	r3,56(r2)
      error = tcp_output(tp);
 823a858:	e13ff817 	ldw	r4,-32(fp)
 823a85c:	82383000 	call	8238300 <tcp_output>
 823a860:	e0bff915 	stw	r2,-28(fp)
      if (!error)
 823a864:	e0bff917 	ldw	r2,-28(fp)
 823a868:	1000e31e 	bne	r2,zero,823abf8 <tcp_usrreq+0x6a0>
         TCP_MIB_INC(tcpActiveOpens);     /* keep MIB stats */
 823a86c:	008209b4 	movhi	r2,2086
 823a870:	10b95d04 	addi	r2,r2,-6796
 823a874:	10800417 	ldw	r2,16(r2)
 823a878:	10c00044 	addi	r3,r2,1
 823a87c:	008209b4 	movhi	r2,2086
 823a880:	10b95d04 	addi	r2,r2,-6796
 823a884:	10c00415 	stw	r3,16(r2)
      break;
 823a888:	0000db06 	br	823abf8 <tcp_usrreq+0x6a0>

   /*
    * Create a TCP connection between two sockets.
    */
   case PRU_CONNECT2:
      error = EOPNOTSUPP;
 823a88c:	008017c4 	movi	r2,95
 823a890:	e0bff915 	stw	r2,-28(fp)
      break;
 823a894:	0000df06 	br	823ac14 <tcp_usrreq+0x6bc>
    * when peer sends FIN and acks ours.
    *
    * SHOULD IMPLEMENT LATER PRU_CONNECT VIA REALLOC TCPCB.
    */
   case PRU_DISCONNECT:
      SETTP(tp, tcp_disconnect(tp));
 823a898:	e13ff817 	ldw	r4,-32(fp)
 823a89c:	823ad440 	call	823ad44 <tcp_disconnect>
      break;
 823a8a0:	0000dc06 	br	823ac14 <tcp_usrreq+0x6bc>
    * done at higher levels; just return the address
    * of the peer, storing through addr.
    */
   case PRU_ACCEPT: 
   {
         struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 823a8a4:	e0bfff17 	ldw	r2,-4(fp)
 823a8a8:	10800317 	ldw	r2,12(r2)
 823a8ac:	e0bffc15 	stw	r2,-16(fp)
            IP6CPY(&sin6->sin6_addr, &inp->ip6_faddr);
         }
#endif

#ifdef IP_V4
         if (so->so_domain == AF_INET)
 823a8b0:	e0bffd17 	ldw	r2,-12(fp)
 823a8b4:	10800517 	ldw	r2,20(r2)
 823a8b8:	10800098 	cmpnei	r2,r2,2
 823a8bc:	10000e1e 	bne	r2,zero,823a8f8 <tcp_usrreq+0x3a0>
         {
            nam->m_len = sizeof (struct sockaddr_in);
 823a8c0:	e0bfff17 	ldw	r2,-4(fp)
 823a8c4:	00c00404 	movi	r3,16
 823a8c8:	10c00215 	stw	r3,8(r2)
            sin->sin_family = AF_INET;
 823a8cc:	e0bffc17 	ldw	r2,-16(fp)
 823a8d0:	00c00084 	movi	r3,2
 823a8d4:	10c0000d 	sth	r3,0(r2)
            sin->sin_port = inp->inp_fport;
 823a8d8:	e0bffb17 	ldw	r2,-20(fp)
 823a8dc:	10c0070b 	ldhu	r3,28(r2)
 823a8e0:	e0bffc17 	ldw	r2,-16(fp)
 823a8e4:	10c0008d 	sth	r3,2(r2)
            sin->sin_addr = inp->inp_faddr;
 823a8e8:	e0bffc17 	ldw	r2,-16(fp)
 823a8ec:	e0fffb17 	ldw	r3,-20(fp)
 823a8f0:	18c00317 	ldw	r3,12(r3)
 823a8f4:	10c00115 	stw	r3,4(r2)
         }
#endif
         if ( !(so->so_domain == AF_INET) &&
 823a8f8:	e0bffd17 	ldw	r2,-12(fp)
 823a8fc:	10800517 	ldw	r2,20(r2)
 823a900:	108000a0 	cmpeqi	r2,r2,2
 823a904:	10000b1e 	bne	r2,zero,823a934 <tcp_usrreq+0x3dc>
              !(so->so_domain == AF_INET6)
 823a908:	e0bffd17 	ldw	r2,-12(fp)
 823a90c:	10800517 	ldw	r2,20(r2)
            sin->sin_family = AF_INET;
            sin->sin_port = inp->inp_fport;
            sin->sin_addr = inp->inp_faddr;
         }
#endif
         if ( !(so->so_domain == AF_INET) &&
 823a910:	108000e0 	cmpeqi	r2,r2,3
 823a914:	1000071e 	bne	r2,zero,823a934 <tcp_usrreq+0x3dc>
              !(so->so_domain == AF_INET6)
             )
         {
            dprintf("*** PRU_ACCEPT bad domain = %d\n", so->so_domain);
 823a918:	e0bffd17 	ldw	r2,-12(fp)
 823a91c:	10800517 	ldw	r2,20(r2)
 823a920:	100b883a 	mov	r5,r2
 823a924:	01020974 	movhi	r4,2085
 823a928:	2103bb04 	addi	r4,r4,3820
 823a92c:	82033a00 	call	82033a0 <printf>
            dtrap();
 823a930:	822d5940 	call	822d594 <dtrap>
         } 
         TCP_MIB_INC(tcpPassiveOpens);    /* keep MIB stats */
 823a934:	008209b4 	movhi	r2,2086
 823a938:	10b95d04 	addi	r2,r2,-6796
 823a93c:	10800517 	ldw	r2,20(r2)
 823a940:	10c00044 	addi	r3,r2,1
 823a944:	008209b4 	movhi	r2,2086
 823a948:	10b95d04 	addi	r2,r2,-6796
 823a94c:	10c00515 	stw	r3,20(r2)
         break;
 823a950:	0000b006 	br	823ac14 <tcp_usrreq+0x6bc>

   /*
    * Mark the connection as being incapable of further output.
    */
   case PRU_SHUTDOWN:
      socantsendmore(so);
 823a954:	e13ffd17 	ldw	r4,-12(fp)
 823a958:	82340ec0 	call	82340ec <socantsendmore>
      tp = tcp_usrclosed(tp);
 823a95c:	e13ff817 	ldw	r4,-32(fp)
 823a960:	823ae100 	call	823ae10 <tcp_usrclosed>
 823a964:	e0bff815 	stw	r2,-32(fp)
      if (tp)
 823a968:	e0bff817 	ldw	r2,-32(fp)
 823a96c:	1000a426 	beq	r2,zero,823ac00 <tcp_usrreq+0x6a8>
         error = tcp_output(tp);
 823a970:	e13ff817 	ldw	r4,-32(fp)
 823a974:	82383000 	call	8238300 <tcp_output>
 823a978:	e0bff915 	stw	r2,-28(fp)
      break;
 823a97c:	0000a006 	br	823ac00 <tcp_usrreq+0x6a8>

   /*
    * After a receive, possibly send window update to peer.
    */
   case PRU_RCVD:
      (void) tcp_output(tp);
 823a980:	e13ff817 	ldw	r4,-32(fp)
 823a984:	82383000 	call	8238300 <tcp_output>
      break;
 823a988:	0000a206 	br	823ac14 <tcp_usrreq+0x6bc>
   /*
    * Do a send by putting data in output queue and updating urgent
    * marker if URG set.  Possibly send more data.
    */
   case PRU_SEND:
      if (so->so_pcb == NULL)
 823a98c:	e0bffd17 	ldw	r2,-12(fp)
 823a990:	10800117 	ldw	r2,4(r2)
 823a994:	1000031e 	bne	r2,zero,823a9a4 <tcp_usrreq+0x44c>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 823a998:	00800804 	movi	r2,32
 823a99c:	e0bff915 	stw	r2,-28(fp)
         break;
 823a9a0:	00009c06 	br	823ac14 <tcp_usrreq+0x6bc>
      }
      sbappend(&so->so_snd, m);
 823a9a4:	e0bffd17 	ldw	r2,-12(fp)
 823a9a8:	10801204 	addi	r2,r2,72
 823a9ac:	e17ffe17 	ldw	r5,-8(fp)
 823a9b0:	1009883a 	mov	r4,r2
 823a9b4:	82343f40 	call	82343f4 <sbappend>
      error = tcp_output(tp);
 823a9b8:	e13ff817 	ldw	r4,-32(fp)
 823a9bc:	82383000 	call	8238300 <tcp_output>
 823a9c0:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 823a9c4:	e0bff917 	ldw	r2,-28(fp)
 823a9c8:	10801a58 	cmpnei	r2,r2,105
 823a9cc:	10008e1e 	bne	r2,zero,823ac08 <tcp_usrreq+0x6b0>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 823a9d0:	e0bffd17 	ldw	r2,-12(fp)
 823a9d4:	10801204 	addi	r2,r2,72
 823a9d8:	e17ffe17 	ldw	r5,-8(fp)
 823a9dc:	1009883a 	mov	r4,r2
 823a9e0:	8234b640 	call	8234b64 <sbdropend>
      break;
 823a9e4:	00008806 	br	823ac08 <tcp_usrreq+0x6b0>

   /*
    * Abort the TCP.
    */
   case PRU_ABORT:
      SETTP(tp, tcp_drop(tp, ECONNABORTED));
 823a9e8:	01401c44 	movi	r5,113
 823a9ec:	e13ff817 	ldw	r4,-32(fp)
 823a9f0:	8239b340 	call	8239b34 <tcp_drop>
      break;
 823a9f4:	00008706 	br	823ac14 <tcp_usrreq+0x6bc>

   case PRU_SENSE:
      /*      ((struct stat *) m)->st_blksize = so->so_snd.sb_hiwat; */
      dtrap();    /* does this ever happen? */
 823a9f8:	822d5940 	call	822d594 <dtrap>
      return (0);
 823a9fc:	0005883a 	mov	r2,zero
 823aa00:	00008506 	br	823ac18 <tcp_usrreq+0x6c0>

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
 823aa04:	e0bffd17 	ldw	r2,-12(fp)
 823aa08:	10801a17 	ldw	r2,104(r2)
 823aa0c:	1000051e 	bne	r2,zero,823aa24 <tcp_usrreq+0x4cc>
          (so->so_state & SS_RCVATMARK) == 0) ||
 823aa10:	e0bffd17 	ldw	r2,-12(fp)
 823aa14:	1080088b 	ldhu	r2,34(r2)
 823aa18:	10bfffcc 	andi	r2,r2,65535
 823aa1c:	1080100c 	andi	r2,r2,64
      /*      ((struct stat *) m)->st_blksize = so->so_snd.sb_hiwat; */
      dtrap();    /* does this ever happen? */
      return (0);

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
 823aa20:	10000926 	beq	r2,zero,823aa48 <tcp_usrreq+0x4f0>
          (so->so_state & SS_RCVATMARK) == 0) ||
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
 823aa24:	e0bffd17 	ldw	r2,-12(fp)
 823aa28:	10800417 	ldw	r2,16(r2)
 823aa2c:	1080400c 	andi	r2,r2,256
      dtrap();    /* does this ever happen? */
      return (0);

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
          (so->so_state & SS_RCVATMARK) == 0) ||
 823aa30:	1000051e 	bne	r2,zero,823aa48 <tcp_usrreq+0x4f0>
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
#endif
       tp->t_oobflags & TCPOOB_HADDATA) 
 823aa34:	e0bff817 	ldw	r2,-32(fp)
 823aa38:	10802403 	ldbu	r2,144(r2)
 823aa3c:	10803fcc 	andi	r2,r2,255
 823aa40:	1080008c 	andi	r2,r2,2

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
          (so->so_state & SS_RCVATMARK) == 0) ||
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
 823aa44:	10000326 	beq	r2,zero,823aa54 <tcp_usrreq+0x4fc>
#endif
       tp->t_oobflags & TCPOOB_HADDATA) 
       {
         error = EINVAL;
 823aa48:	00800584 	movi	r2,22
 823aa4c:	e0bff915 	stw	r2,-28(fp)
         break;
 823aa50:	00007006 	br	823ac14 <tcp_usrreq+0x6bc>
      }
      if ((tp->t_oobflags & TCPOOB_HAVEDATA) == 0) 
 823aa54:	e0bff817 	ldw	r2,-32(fp)
 823aa58:	10802403 	ldbu	r2,144(r2)
 823aa5c:	10803fcc 	andi	r2,r2,255
 823aa60:	1080004c 	andi	r2,r2,1
 823aa64:	1000031e 	bne	r2,zero,823aa74 <tcp_usrreq+0x51c>
      {
         error = EWOULDBLOCK;
 823aa68:	008002c4 	movi	r2,11
 823aa6c:	e0bff915 	stw	r2,-28(fp)
         break;
 823aa70:	00006806 	br	823ac14 <tcp_usrreq+0x6bc>
      }
      m->m_len = 1;
 823aa74:	e0bffe17 	ldw	r2,-8(fp)
 823aa78:	00c00044 	movi	r3,1
 823aa7c:	10c00215 	stw	r3,8(r2)
      *mtod(m, char *) = tp->t_iobc;
 823aa80:	e0bffe17 	ldw	r2,-8(fp)
 823aa84:	10800317 	ldw	r2,12(r2)
 823aa88:	e0fff817 	ldw	r3,-32(fp)
 823aa8c:	18c02443 	ldbu	r3,145(r3)
 823aa90:	10c00005 	stb	r3,0(r2)
      if ((MBUF2LONG(nam) & MSG_PEEK) == 0)
 823aa94:	e0bfff17 	ldw	r2,-4(fp)
 823aa98:	1080008c 	andi	r2,r2,2
 823aa9c:	10005c1e 	bne	r2,zero,823ac10 <tcp_usrreq+0x6b8>
         tp->t_oobflags ^= (TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 823aaa0:	e0bff817 	ldw	r2,-32(fp)
 823aaa4:	10802403 	ldbu	r2,144(r2)
 823aaa8:	108000dc 	xori	r2,r2,3
 823aaac:	1007883a 	mov	r3,r2
 823aab0:	e0bff817 	ldw	r2,-32(fp)
 823aab4:	10c02405 	stb	r3,144(r2)
      break;
 823aab8:	00005506 	br	823ac10 <tcp_usrreq+0x6b8>

   case PRU_SENDOOB:
      if (so->so_pcb == NULL)
 823aabc:	e0bffd17 	ldw	r2,-12(fp)
 823aac0:	10800117 	ldw	r2,4(r2)
 823aac4:	1000031e 	bne	r2,zero,823aad4 <tcp_usrreq+0x57c>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 823aac8:	00800804 	movi	r2,32
 823aacc:	e0bff915 	stw	r2,-28(fp)
         break;
 823aad0:	00005006 	br	823ac14 <tcp_usrreq+0x6bc>
      }
      if (sbspace(&so->so_snd) == 0) 
 823aad4:	e0bffd17 	ldw	r2,-12(fp)
 823aad8:	10801317 	ldw	r2,76(r2)
 823aadc:	1007883a 	mov	r3,r2
 823aae0:	e0bffd17 	ldw	r2,-12(fp)
 823aae4:	10801217 	ldw	r2,72(r2)
 823aae8:	1885c83a 	sub	r2,r3,r2
 823aaec:	10000516 	blt	r2,zero,823ab04 <tcp_usrreq+0x5ac>
 823aaf0:	e0bffd17 	ldw	r2,-12(fp)
 823aaf4:	10c01317 	ldw	r3,76(r2)
 823aaf8:	e0bffd17 	ldw	r2,-12(fp)
 823aafc:	10801217 	ldw	r2,72(r2)
 823ab00:	1880051e 	bne	r3,r2,823ab18 <tcp_usrreq+0x5c0>
      {
         m_freem(m);
 823ab04:	e13ffe17 	ldw	r4,-8(fp)
 823ab08:	822e6380 	call	822e638 <m_freem>
         error = ENOBUFS;
 823ab0c:	00801a44 	movi	r2,105
 823ab10:	e0bff915 	stw	r2,-28(fp)
         break;
 823ab14:	00003f06 	br	823ac14 <tcp_usrreq+0x6bc>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section.
       * Otherwise, snd_up should be one lower.
       */
      sbappend(&so->so_snd, m);
 823ab18:	e0bffd17 	ldw	r2,-12(fp)
 823ab1c:	10801204 	addi	r2,r2,72
 823ab20:	e17ffe17 	ldw	r5,-8(fp)
 823ab24:	1009883a 	mov	r4,r2
 823ab28:	82343f40 	call	82343f4 <sbappend>
      tp->snd_up = tp->snd_una + so->so_snd.sb_cc;
 823ab2c:	e0bff817 	ldw	r2,-32(fp)
 823ab30:	10c00e17 	ldw	r3,56(r2)
 823ab34:	e0bffd17 	ldw	r2,-12(fp)
 823ab38:	10801217 	ldw	r2,72(r2)
 823ab3c:	1887883a 	add	r3,r3,r2
 823ab40:	e0bff817 	ldw	r2,-32(fp)
 823ab44:	10c01015 	stw	r3,64(r2)
      tp->t_force = 1;
 823ab48:	e0bff817 	ldw	r2,-32(fp)
 823ab4c:	00c00044 	movi	r3,1
 823ab50:	10c00a85 	stb	r3,42(r2)
      error = tcp_output(tp);
 823ab54:	e13ff817 	ldw	r4,-32(fp)
 823ab58:	82383000 	call	8238300 <tcp_output>
 823ab5c:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 823ab60:	e0bff917 	ldw	r2,-28(fp)
 823ab64:	10801a58 	cmpnei	r2,r2,105
 823ab68:	1000051e 	bne	r2,zero,823ab80 <tcp_usrreq+0x628>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 823ab6c:	e0bffd17 	ldw	r2,-12(fp)
 823ab70:	10801204 	addi	r2,r2,72
 823ab74:	e17ffe17 	ldw	r5,-8(fp)
 823ab78:	1009883a 	mov	r4,r2
 823ab7c:	8234b640 	call	8234b64 <sbdropend>
      tp->t_force = 0;
 823ab80:	e0bff817 	ldw	r2,-32(fp)
 823ab84:	10000a85 	stb	zero,42(r2)
      break;
 823ab88:	00002206 	br	823ac14 <tcp_usrreq+0x6bc>
   case PRU_SOCKADDR:

   /* sockaddr and peeraddr have to switch based on IP type */
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setsockaddr(inp, nam);
 823ab8c:	e17fff17 	ldw	r5,-4(fp)
 823ab90:	e13ffb17 	ldw	r4,-20(fp)
 823ab94:	82483640 	call	8248364 <in_setsockaddr>
         in_setsockaddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setsockaddr(inp, nam);
#endif
      break;         
 823ab98:	00001e06 	br	823ac14 <tcp_usrreq+0x6bc>

   case PRU_PEERADDR:
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setpeeraddr(inp, nam);
 823ab9c:	e17fff17 	ldw	r5,-4(fp)
 823aba0:	e13ffb17 	ldw	r4,-20(fp)
 823aba4:	82483e80 	call	82483e8 <in_setpeeraddr>
         in_setpeeraddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setpeeraddr(inp, nam);
#endif
      break;
 823aba8:	00001a06 	br	823ac14 <tcp_usrreq+0x6bc>

   case PRU_SLOWTIMO:
      SETTP(tp, tcp_timers(tp, (int)MBUF2LONG(nam)));
 823abac:	e0bfff17 	ldw	r2,-4(fp)
 823abb0:	100b883a 	mov	r5,r2
 823abb4:	e13ff817 	ldw	r4,-32(fp)
 823abb8:	823a0d80 	call	823a0d8 <tcp_timers>
#ifdef DO_TCPTRACE
      req |= (long)nam << 8;        /* for debug's sake */
#endif
      break;
 823abbc:	00001506 	br	823ac14 <tcp_usrreq+0x6bc>

      default:
      panic("tcp_usrreq");
 823abc0:	01020974 	movhi	r4,2085
 823abc4:	2103c304 	addi	r4,r4,3852
 823abc8:	8228c480 	call	8228c48 <panic>
 823abcc:	00001106 	br	823ac14 <tcp_usrreq+0x6bc>
         error = EISCONN;
         break;
      }
      error = tcp_attach(so);
      if (error)
         break;
 823abd0:	0001883a 	nop
 823abd4:	00000f06 	br	823ac14 <tcp_usrreq+0x6bc>
      if ((so->so_options & SO_LINGER) && so->so_linger == 0)
         so->so_linger = TCP_LINGERTIME;
#ifdef   DO_TCPTRACE
      SETTP(tp, sototcpcb(so));
#endif
      break;
 823abd8:	0001883a 	nop
 823abdc:	00000d06 	br	823ac14 <tcp_usrreq+0x6bc>
   case PRU_LISTEN:
      if (inp->inp_lport == 0)
         error = in_pcbbind(inp, (struct mbuf *)0);
      if (error == 0)
         tp->t_state = TCPS_LISTEN;
      break;
 823abe0:	0001883a 	nop
 823abe4:	00000b06 	br	823ac14 <tcp_usrreq+0x6bc>
#else    /* no v4, v6 only */
      error = ip6_pcbbind(inp, (struct mbuf *)0);
#endif   /* end v6 only */

         if (error)
            break;
 823abe8:	0001883a 	nop
 823abec:	00000906 	br	823ac14 <tcp_usrreq+0x6bc>
#else    /* no v4, v6 only */
      error = ip6_pcbconnect(inp, nam);
#endif   /* end v6 only */

      if (error)
         break;
 823abf0:	0001883a 	nop
 823abf4:	00000706 	br	823ac14 <tcp_usrreq+0x6bc>
      tcp_iss += (tcp_seq)(TCP_ISSINCR/2);
      tcp_sendseqinit(tp);
      error = tcp_output(tp);
      if (!error)
         TCP_MIB_INC(tcpActiveOpens);     /* keep MIB stats */
      break;
 823abf8:	0001883a 	nop
 823abfc:	00000506 	br	823ac14 <tcp_usrreq+0x6bc>
   case PRU_SHUTDOWN:
      socantsendmore(so);
      tp = tcp_usrclosed(tp);
      if (tp)
         error = tcp_output(tp);
      break;
 823ac00:	0001883a 	nop
 823ac04:	00000306 	br	823ac14 <tcp_usrreq+0x6bc>
      }
      sbappend(&so->so_snd, m);
      error = tcp_output(tp);
      if (error == ENOBUFS)
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
      break;
 823ac08:	0001883a 	nop
 823ac0c:	00000106 	br	823ac14 <tcp_usrreq+0x6bc>
      }
      m->m_len = 1;
      *mtod(m, char *) = tp->t_iobc;
      if ((MBUF2LONG(nam) & MSG_PEEK) == 0)
         tp->t_oobflags ^= (TCPOOB_HAVEDATA | TCPOOB_HADDATA);
      break;
 823ac10:	0001883a 	nop
#ifdef DO_TCPTRACE
   if (tp && (so->so_options & SO_DEBUG))
      tcp_trace("usrreq: state: %d, tcpcb: %x, req: %d",
    ostate, tp, req);
#endif
   return (error);
 823ac14:	e0bff917 	ldw	r2,-28(fp)
}
 823ac18:	e037883a 	mov	sp,fp
 823ac1c:	dfc00117 	ldw	ra,4(sp)
 823ac20:	df000017 	ldw	fp,0(sp)
 823ac24:	dec00204 	addi	sp,sp,8
 823ac28:	f800283a 	ret

0823ac2c <tcp_attach>:
 * RETURNS: 0 if OK, or nonzero error code.
 */

int
tcp_attach(struct socket * so)
{
 823ac2c:	defff904 	addi	sp,sp,-28
 823ac30:	dfc00615 	stw	ra,24(sp)
 823ac34:	df000515 	stw	fp,20(sp)
 823ac38:	df000504 	addi	fp,sp,20
 823ac3c:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp;
   struct inpcb * inp;
   int   error;

   if (so->so_snd.sb_hiwat == 0 || so->so_rcv.sb_hiwat == 0) 
 823ac40:	e0bfff17 	ldw	r2,-4(fp)
 823ac44:	10801317 	ldw	r2,76(r2)
 823ac48:	10000326 	beq	r2,zero,823ac58 <tcp_attach+0x2c>
 823ac4c:	e0bfff17 	ldw	r2,-4(fp)
 823ac50:	10800b17 	ldw	r2,44(r2)
 823ac54:	10000b1e 	bne	r2,zero,823ac84 <tcp_attach+0x58>
   {
      error = soreserve(so, tcp_sendspace, tcp_recvspace);
 823ac58:	d0a04017 	ldw	r2,-32512(gp)
 823ac5c:	d0e04117 	ldw	r3,-32508(gp)
 823ac60:	180d883a 	mov	r6,r3
 823ac64:	100b883a 	mov	r5,r2
 823ac68:	e13fff17 	ldw	r4,-4(fp)
 823ac6c:	82342d00 	call	82342d0 <soreserve>
 823ac70:	e0bffb15 	stw	r2,-20(fp)
      if (error)
 823ac74:	e0bffb17 	ldw	r2,-20(fp)
 823ac78:	10000226 	beq	r2,zero,823ac84 <tcp_attach+0x58>
         return (error);
 823ac7c:	e0bffb17 	ldw	r2,-20(fp)
 823ac80:	00002b06 	br	823ad30 <tcp_attach+0x104>
   }
   error = in_pcballoc(so, &tcb);
 823ac84:	014209b4 	movhi	r5,2086
 823ac88:	29798004 	addi	r5,r5,-6656
 823ac8c:	e13fff17 	ldw	r4,-4(fp)
 823ac90:	8247e380 	call	8247e38 <in_pcballoc>
 823ac94:	e0bffb15 	stw	r2,-20(fp)
   if (error)
 823ac98:	e0bffb17 	ldw	r2,-20(fp)
 823ac9c:	10000226 	beq	r2,zero,823aca8 <tcp_attach+0x7c>
      return (error);
 823aca0:	e0bffb17 	ldw	r2,-20(fp)
 823aca4:	00002206 	br	823ad30 <tcp_attach+0x104>
   inp = sotoinpcb(so);
 823aca8:	e0bfff17 	ldw	r2,-4(fp)
 823acac:	10800117 	ldw	r2,4(r2)
 823acb0:	e0bffc15 	stw	r2,-16(fp)
   tp = tcp_newtcpcb(inp);
 823acb4:	e13ffc17 	ldw	r4,-16(fp)
 823acb8:	8239a280 	call	8239a28 <tcp_newtcpcb>
 823acbc:	e0bffd15 	stw	r2,-12(fp)
   if (tp == 0) 
 823acc0:	e0bffd17 	ldw	r2,-12(fp)
 823acc4:	1000171e 	bne	r2,zero,823ad24 <tcp_attach+0xf8>
   {
      int   nofd  =  so->so_state   &  SS_NOFDREF; /* XXX */
 823acc8:	e0bfff17 	ldw	r2,-4(fp)
 823accc:	1080088b 	ldhu	r2,34(r2)
 823acd0:	10bfffcc 	andi	r2,r2,65535
 823acd4:	1080004c 	andi	r2,r2,1
 823acd8:	e0bffe15 	stw	r2,-8(fp)

      so->so_state &= ~SS_NOFDREF;     /* don't free the socket yet */
 823acdc:	e0bfff17 	ldw	r2,-4(fp)
 823ace0:	10c0088b 	ldhu	r3,34(r2)
 823ace4:	00bfff84 	movi	r2,-2
 823ace8:	1884703a 	and	r2,r3,r2
 823acec:	1007883a 	mov	r3,r2
 823acf0:	e0bfff17 	ldw	r2,-4(fp)
 823acf4:	10c0088d 	sth	r3,34(r2)
      in_pcbdetach(inp);
 823acf8:	e13ffc17 	ldw	r4,-16(fp)
 823acfc:	8247ec00 	call	8247ec0 <in_pcbdetach>
      so->so_state |= nofd;
 823ad00:	e0bfff17 	ldw	r2,-4(fp)
 823ad04:	1080088b 	ldhu	r2,34(r2)
 823ad08:	e0fffe17 	ldw	r3,-8(fp)
 823ad0c:	10c4b03a 	or	r2,r2,r3
 823ad10:	1007883a 	mov	r3,r2
 823ad14:	e0bfff17 	ldw	r2,-4(fp)
 823ad18:	10c0088d 	sth	r3,34(r2)
      return (ENOBUFS);
 823ad1c:	00801a44 	movi	r2,105
 823ad20:	00000306 	br	823ad30 <tcp_attach+0x104>
   }
   tp->t_state = TCPS_CLOSED;
 823ad24:	e0bffd17 	ldw	r2,-12(fp)
 823ad28:	10000215 	stw	zero,8(r2)
   return (0);
 823ad2c:	0005883a 	mov	r2,zero
}
 823ad30:	e037883a 	mov	sp,fp
 823ad34:	dfc00117 	ldw	ra,4(sp)
 823ad38:	df000017 	ldw	fp,0(sp)
 823ad3c:	dec00204 	addi	sp,sp,8
 823ad40:	f800283a 	ret

0823ad44 <tcp_disconnect>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_disconnect(struct tcpcb * tp)
{
 823ad44:	defffc04 	addi	sp,sp,-16
 823ad48:	dfc00315 	stw	ra,12(sp)
 823ad4c:	df000215 	stw	fp,8(sp)
 823ad50:	df000204 	addi	fp,sp,8
 823ad54:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 823ad58:	e0bfff17 	ldw	r2,-4(fp)
 823ad5c:	10800d17 	ldw	r2,52(r2)
 823ad60:	10800817 	ldw	r2,32(r2)
 823ad64:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_state < TCPS_ESTABLISHED)
 823ad68:	e0bfff17 	ldw	r2,-4(fp)
 823ad6c:	10800217 	ldw	r2,8(r2)
 823ad70:	10800108 	cmpgei	r2,r2,4
 823ad74:	1000041e 	bne	r2,zero,823ad88 <tcp_disconnect+0x44>
      tp = tcp_close(tp);
 823ad78:	e13fff17 	ldw	r4,-4(fp)
 823ad7c:	8239be00 	call	8239be0 <tcp_close>
 823ad80:	e0bfff15 	stw	r2,-4(fp)
 823ad84:	00001c06 	br	823adf8 <tcp_disconnect+0xb4>
   else if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 823ad88:	e0bffe17 	ldw	r2,-8(fp)
 823ad8c:	10800417 	ldw	r2,16(r2)
 823ad90:	1080200c 	andi	r2,r2,128
 823ad94:	10000b26 	beq	r2,zero,823adc4 <tcp_disconnect+0x80>
 823ad98:	e0bffe17 	ldw	r2,-8(fp)
 823ad9c:	1080080b 	ldhu	r2,32(r2)
 823ada0:	10bfffcc 	andi	r2,r2,65535
 823ada4:	10a0001c 	xori	r2,r2,32768
 823ada8:	10a00004 	addi	r2,r2,-32768
 823adac:	1000051e 	bne	r2,zero,823adc4 <tcp_disconnect+0x80>
      tp = tcp_drop(tp, 0);
 823adb0:	000b883a 	mov	r5,zero
 823adb4:	e13fff17 	ldw	r4,-4(fp)
 823adb8:	8239b340 	call	8239b34 <tcp_drop>
 823adbc:	e0bfff15 	stw	r2,-4(fp)
 823adc0:	00000d06 	br	823adf8 <tcp_disconnect+0xb4>
   else 
   {
      soisdisconnecting(so);
 823adc4:	e13ffe17 	ldw	r4,-8(fp)
 823adc8:	8233bdc0 	call	8233bdc <soisdisconnecting>
      sbflush(&so->so_rcv);
 823adcc:	e0bffe17 	ldw	r2,-8(fp)
 823add0:	10800a04 	addi	r2,r2,40
 823add4:	1009883a 	mov	r4,r2
 823add8:	82349280 	call	8234928 <sbflush>
      tp = tcp_usrclosed(tp);
 823addc:	e13fff17 	ldw	r4,-4(fp)
 823ade0:	823ae100 	call	823ae10 <tcp_usrclosed>
 823ade4:	e0bfff15 	stw	r2,-4(fp)
      if (tp)
 823ade8:	e0bfff17 	ldw	r2,-4(fp)
 823adec:	10000226 	beq	r2,zero,823adf8 <tcp_disconnect+0xb4>
         (void) tcp_output(tp);
 823adf0:	e13fff17 	ldw	r4,-4(fp)
 823adf4:	82383000 	call	8238300 <tcp_output>
   }
   return (tp);
 823adf8:	e0bfff17 	ldw	r2,-4(fp)
}
 823adfc:	e037883a 	mov	sp,fp
 823ae00:	dfc00117 	ldw	ra,4(sp)
 823ae04:	df000017 	ldw	fp,0(sp)
 823ae08:	dec00204 	addi	sp,sp,8
 823ae0c:	f800283a 	ret

0823ae10 <tcp_usrclosed>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_usrclosed(struct tcpcb * tp)
{
 823ae10:	defffd04 	addi	sp,sp,-12
 823ae14:	dfc00215 	stw	ra,8(sp)
 823ae18:	df000115 	stw	fp,4(sp)
 823ae1c:	df000104 	addi	fp,sp,4
 823ae20:	e13fff15 	stw	r4,-4(fp)

   switch (tp->t_state) 
 823ae24:	e0bfff17 	ldw	r2,-4(fp)
 823ae28:	10800217 	ldw	r2,8(r2)
 823ae2c:	10c001a8 	cmpgeui	r3,r2,6
 823ae30:	18001a1e 	bne	r3,zero,823ae9c <tcp_usrclosed+0x8c>
 823ae34:	100690ba 	slli	r3,r2,2
 823ae38:	00820934 	movhi	r2,2084
 823ae3c:	10ab9304 	addi	r2,r2,-20916
 823ae40:	1885883a 	add	r2,r3,r2
 823ae44:	10800017 	ldw	r2,0(r2)
 823ae48:	1000683a 	jmp	r2
 823ae4c:	0823ae64 	muli	zero,at,-28999
 823ae50:	0823ae64 	muli	zero,at,-28999
 823ae54:	0823ae64 	muli	zero,at,-28999
 823ae58:	0823ae7c 	xorhi	zero,at,36537
 823ae5c:	0823ae7c 	xorhi	zero,at,36537
 823ae60:	0823ae8c 	andi	zero,at,36538
   {
   case TCPS_CLOSED:
   case TCPS_LISTEN:
   case TCPS_SYN_SENT:
      tp->t_state = TCPS_CLOSED;
 823ae64:	e0bfff17 	ldw	r2,-4(fp)
 823ae68:	10000215 	stw	zero,8(r2)
      tp = tcp_close(tp);
 823ae6c:	e13fff17 	ldw	r4,-4(fp)
 823ae70:	8239be00 	call	8239be0 <tcp_close>
 823ae74:	e0bfff15 	stw	r2,-4(fp)
      break;
 823ae78:	00000806 	br	823ae9c <tcp_usrclosed+0x8c>

   case TCPS_SYN_RECEIVED:
   case TCPS_ESTABLISHED:
      tp->t_state = TCPS_FIN_WAIT_1;
 823ae7c:	e0bfff17 	ldw	r2,-4(fp)
 823ae80:	00c00184 	movi	r3,6
 823ae84:	10c00215 	stw	r3,8(r2)
      break;
 823ae88:	00000406 	br	823ae9c <tcp_usrclosed+0x8c>

   case TCPS_CLOSE_WAIT:
      tp->t_state = TCPS_LAST_ACK;
 823ae8c:	e0bfff17 	ldw	r2,-4(fp)
 823ae90:	00c00204 	movi	r3,8
 823ae94:	10c00215 	stw	r3,8(r2)
      break;
 823ae98:	0001883a 	nop
   }
   if (tp && tp->t_state >= TCPS_FIN_WAIT_2)
 823ae9c:	e0bfff17 	ldw	r2,-4(fp)
 823aea0:	10000926 	beq	r2,zero,823aec8 <tcp_usrclosed+0xb8>
 823aea4:	e0bfff17 	ldw	r2,-4(fp)
 823aea8:	10800217 	ldw	r2,8(r2)
 823aeac:	10800250 	cmplti	r2,r2,9
 823aeb0:	1000051e 	bne	r2,zero,823aec8 <tcp_usrclosed+0xb8>
      soisdisconnected(tp->t_inpcb->inp_socket);
 823aeb4:	e0bfff17 	ldw	r2,-4(fp)
 823aeb8:	10800d17 	ldw	r2,52(r2)
 823aebc:	10800817 	ldw	r2,32(r2)
 823aec0:	1009883a 	mov	r4,r2
 823aec4:	8233c740 	call	8233c74 <soisdisconnected>
   return (tp);
 823aec8:	e0bfff17 	ldw	r2,-4(fp)
}
 823aecc:	e037883a 	mov	sp,fp
 823aed0:	dfc00117 	ldw	ra,4(sp)
 823aed4:	df000017 	ldw	fp,0(sp)
 823aed8:	dec00204 	addi	sp,sp,8
 823aedc:	f800283a 	ret

0823aee0 <tcpinit>:
 * RETURNS: 0 if OK, else one of the ENP_ error codes
 */

int
tcpinit(void)
{
 823aee0:	defffd04 	addi	sp,sp,-12
 823aee4:	dfc00215 	stw	ra,8(sp)
 823aee8:	df000115 	stw	fp,4(sp)
 823aeec:	df000104 	addi	fp,sp,4
   tcp_sendspace = (TCP_MSS) * 2;
   tcp_recvspace = (TCP_MSS) * 2;
   TCPTV_MSL =    (4 * PR_SLOWHZ);     /* max seg lifetime default */
#endif

   e = nptcp_init();    /* call the NetPort init in nptcp.c */
 823aef0:	822ed0c0 	call	822ed0c <nptcp_init>
 823aef4:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 823aef8:	e0bfff17 	ldw	r2,-4(fp)
 823aefc:	10000226 	beq	r2,zero,823af08 <tcpinit+0x28>
      return e;
 823af00:	e0bfff17 	ldw	r2,-4(fp)
 823af04:	00000106 	br	823af0c <tcpinit+0x2c>

   return 0;   /* good return */
 823af08:	0005883a 	mov	r2,zero
}
 823af0c:	e037883a 	mov	sp,fp
 823af10:	dfc00117 	ldw	ra,4(sp)
 823af14:	df000017 	ldw	fp,0(sp)
 823af18:	dec00204 	addi	sp,sp,8
 823af1c:	f800283a 	ret

0823af20 <udp_lookup>:
 * RETURNS: 
 */

UDPCONN
udp_lookup(struct socket * so)
{
 823af20:	defffd04 	addi	sp,sp,-12
 823af24:	df000215 	stw	fp,8(sp)
 823af28:	df000204 	addi	fp,sp,8
 823af2c:	e13fff15 	stw	r4,-4(fp)
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 823af30:	d0a09c17 	ldw	r2,-32144(gp)
 823af34:	e0bffe15 	stw	r2,-8(fp)
 823af38:	00000906 	br	823af60 <udp_lookup+0x40>
      if (tmp->u_data == (void*)so)
 823af3c:	e0bffe17 	ldw	r2,-8(fp)
 823af40:	10c00617 	ldw	r3,24(r2)
 823af44:	e0bfff17 	ldw	r2,-4(fp)
 823af48:	1880021e 	bne	r3,r2,823af54 <udp_lookup+0x34>
      return (tmp);
 823af4c:	e0bffe17 	ldw	r2,-8(fp)
 823af50:	00000606 	br	823af6c <udp_lookup+0x4c>
UDPCONN
udp_lookup(struct socket * so)
{
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 823af54:	e0bffe17 	ldw	r2,-8(fp)
 823af58:	10800017 	ldw	r2,0(r2)
 823af5c:	e0bffe15 	stw	r2,-8(fp)
 823af60:	e0bffe17 	ldw	r2,-8(fp)
 823af64:	103ff51e 	bne	r2,zero,823af3c <udp_lookup+0x1c>
      if (tmp->u_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 823af68:	0005883a 	mov	r2,zero
}
 823af6c:	e037883a 	mov	sp,fp
 823af70:	df000017 	ldw	fp,0(sp)
 823af74:	dec00104 	addi	sp,sp,4
 823af78:	f800283a 	ret

0823af7c <udp_soinput>:
 * RETURNS: 
 */

int
udp_soinput(PACKET pkt, void * so_ptr)
{
 823af7c:	defff504 	addi	sp,sp,-44
 823af80:	dfc00a15 	stw	ra,40(sp)
 823af84:	df000915 	stw	fp,36(sp)
 823af88:	df000904 	addi	fp,sp,36
 823af8c:	e13ffe15 	stw	r4,-8(fp)
 823af90:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 823af94:	e0bfff17 	ldw	r2,-4(fp)
 823af98:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;
   struct udp *   udpp;

   LOCK_NET_RESOURCE(NET_RESID); 
 823af9c:	0009883a 	mov	r4,zero
 823afa0:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 823afa4:	e0bff717 	ldw	r2,-36(fp)
 823afa8:	10c00a17 	ldw	r3,40(r2)
 823afac:	e0bffe17 	ldw	r2,-8(fp)
 823afb0:	10800417 	ldw	r2,16(r2)
 823afb4:	1887883a 	add	r3,r3,r2
 823afb8:	e0bff717 	ldw	r2,-36(fp)
 823afbc:	10800b17 	ldw	r2,44(r2)
 823afc0:	18800436 	bltu	r3,r2,823afd4 <udp_soinput+0x58>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 823afc4:	0009883a 	mov	r4,zero
 823afc8:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 823afcc:	00801a44 	movi	r2,105
 823afd0:	00004d06 	br	823b108 <udp_soinput+0x18c>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 823afd4:	000b883a 	mov	r5,zero
 823afd8:	01000044 	movi	r4,1
 823afdc:	822e3a80 	call	822e3a8 <m_getnbuf>
 823afe0:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 823afe4:	e0bff817 	ldw	r2,-32(fp)
 823afe8:	1000041e 	bne	r2,zero,823affc <udp_soinput+0x80>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 823afec:	0009883a 	mov	r4,zero
 823aff0:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 823aff4:	00801a44 	movi	r2,105
 823aff8:	00004306 	br	823b108 <udp_soinput+0x18c>
   }

   /* set data mbuf to point to start of UDP data */
   m_in->pkt = pkt;
 823affc:	e0bff817 	ldw	r2,-32(fp)
 823b000:	e0fffe17 	ldw	r3,-8(fp)
 823b004:	10c00115 	stw	r3,4(r2)
   m_in->m_data = pkt->nb_prot;
 823b008:	e0bffe17 	ldw	r2,-8(fp)
 823b00c:	10c00317 	ldw	r3,12(r2)
 823b010:	e0bff817 	ldw	r2,-32(fp)
 823b014:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 823b018:	e0bffe17 	ldw	r2,-8(fp)
 823b01c:	10c00417 	ldw	r3,16(r2)
 823b020:	e0bff817 	ldw	r2,-32(fp)
 823b024:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;
 823b028:	e0bffe17 	ldw	r2,-8(fp)
 823b02c:	10c00117 	ldw	r3,4(r2)
 823b030:	e0bff817 	ldw	r2,-32(fp)
 823b034:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 823b038:	e0bffe17 	ldw	r2,-8(fp)
 823b03c:	10c00217 	ldw	r3,8(r2)
 823b040:	e0bff817 	ldw	r2,-32(fp)
 823b044:	10c00515 	stw	r3,20(r2)

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 823b048:	e0bffe17 	ldw	r2,-8(fp)
 823b04c:	10800717 	ldw	r2,28(r2)
 823b050:	e0bffb15 	stw	r2,-20(fp)
   udpp = (struct udp *)(pkt->nb_prot - sizeof(struct udp));
 823b054:	e0bffe17 	ldw	r2,-8(fp)
 823b058:	10800317 	ldw	r2,12(r2)
 823b05c:	10bffe04 	addi	r2,r2,-8
 823b060:	e0bff915 	stw	r2,-28(fp)
   sin.sin_port = htons(udpp->ud_srcp);
 823b064:	e0bff917 	ldw	r2,-28(fp)
 823b068:	1080000b 	ldhu	r2,0(r2)
 823b06c:	10bfffcc 	andi	r2,r2,65535
 823b070:	1004d23a 	srli	r2,r2,8
 823b074:	1007883a 	mov	r3,r2
 823b078:	e0bff917 	ldw	r2,-28(fp)
 823b07c:	1080000b 	ldhu	r2,0(r2)
 823b080:	10bfffcc 	andi	r2,r2,65535
 823b084:	1004923a 	slli	r2,r2,8
 823b088:	1884b03a 	or	r2,r3,r2
 823b08c:	e0bffa8d 	sth	r2,-22(fp)
   sin.sin_family = AF_INET;
 823b090:	00800084 	movi	r2,2
 823b094:	e0bffa0d 	sth	r2,-24(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 823b098:	e0bff717 	ldw	r2,-36(fp)
 823b09c:	10800a04 	addi	r2,r2,40
 823b0a0:	e0fffa04 	addi	r3,fp,-24
 823b0a4:	e1bff817 	ldw	r6,-32(fp)
 823b0a8:	180b883a 	mov	r5,r3
 823b0ac:	1009883a 	mov	r4,r2
 823b0b0:	823456c0 	call	823456c <sbappendaddr>
 823b0b4:	1000081e 	bne	r2,zero,823b0d8 <udp_soinput+0x15c>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       */
      m_in->pkt = NULL;
 823b0b8:	e0bff817 	ldw	r2,-32(fp)
 823b0bc:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 823b0c0:	e13ff817 	ldw	r4,-32(fp)
 823b0c4:	822e5300 	call	822e530 <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 823b0c8:	0009883a 	mov	r4,zero
 823b0cc:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 823b0d0:	00801a44 	movi	r2,105
 823b0d4:	00000c06 	br	823b108 <udp_soinput+0x18c>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 823b0d8:	e0bff717 	ldw	r2,-36(fp)
 823b0dc:	10800a04 	addi	r2,r2,40
 823b0e0:	1009883a 	mov	r4,r2
 823b0e4:	82296a80 	call	82296a8 <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 823b0e8:	e0bff717 	ldw	r2,-36(fp)
 823b0ec:	10800a04 	addi	r2,r2,40
 823b0f0:	100b883a 	mov	r5,r2
 823b0f4:	e13ff717 	ldw	r4,-36(fp)
 823b0f8:	82342440 	call	8234244 <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 823b0fc:	0009883a 	mov	r4,zero
 823b100:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   return 0;
 823b104:	0005883a 	mov	r2,zero
}
 823b108:	e037883a 	mov	sp,fp
 823b10c:	dfc00117 	ldw	ra,4(sp)
 823b110:	df000017 	ldw	fp,0(sp)
 823b114:	dec00204 	addi	sp,sp,8
 823b118:	f800283a 	ret

0823b11c <udp_usrreq>:

int
udp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 823b11c:	defff804 	addi	sp,sp,-32
 823b120:	dfc00715 	stw	ra,28(sp)
 823b124:	df000615 	stw	fp,24(sp)
 823b128:	df000604 	addi	fp,sp,24
 823b12c:	e13ffd15 	stw	r4,-12(fp)
 823b130:	e17ffe15 	stw	r5,-8(fp)
 823b134:	e1bfff15 	stw	r6,-4(fp)
   UDPCONN udpconn = (UDPCONN)NULL;
 823b138:	e03ffb15 	stw	zero,-20(fp)
   int   req;

   req = so->so_req;    /* get request from socket struct */
 823b13c:	e0bffd17 	ldw	r2,-12(fp)
 823b140:	10800717 	ldw	r2,28(r2)
 823b144:	e0bffc15 	stw	r2,-16(fp)

   switch (req) 
 823b148:	e0bffc17 	ldw	r2,-16(fp)
 823b14c:	10800468 	cmpgeui	r2,r2,17
 823b150:	10007b1e 	bne	r2,zero,823b340 <udp_usrreq+0x224>
 823b154:	e0bffc17 	ldw	r2,-16(fp)
 823b158:	100690ba 	slli	r3,r2,2
 823b15c:	00820934 	movhi	r2,2084
 823b160:	10ac5c04 	addi	r2,r2,-20112
 823b164:	1885883a 	add	r2,r3,r2
 823b168:	10800017 	ldw	r2,0(r2)
 823b16c:	1000683a 	jmp	r2
 823b170:	0823b1b4 	orhi	zero,at,36550
 823b174:	0823b238 	rdprs	zero,at,-28984
 823b178:	0823b274 	orhi	zero,at,36553
 823b17c:	0823b340 	call	823b34 <OSCtxSw_SWITCH_PC+0x823af4>
 823b180:	0823b274 	orhi	zero,at,36553
 823b184:	0823b340 	call	823b34 <OSCtxSw_SWITCH_PC+0x823af4>
 823b188:	0823b334 	orhi	zero,at,36556
 823b18c:	0823b340 	call	823b34 <OSCtxSw_SWITCH_PC+0x823af4>
 823b190:	0823b334 	orhi	zero,at,36556
 823b194:	0823b2b4 	orhi	zero,at,36554
 823b198:	0823b340 	call	823b34 <OSCtxSw_SWITCH_PC+0x823af4>
 823b19c:	0823b340 	call	823b34 <OSCtxSw_SWITCH_PC+0x823af4>
 823b1a0:	0823b340 	call	823b34 <OSCtxSw_SWITCH_PC+0x823af4>
 823b1a4:	0823b340 	call	823b34 <OSCtxSw_SWITCH_PC+0x823af4>
 823b1a8:	0823b340 	call	823b34 <OSCtxSw_SWITCH_PC+0x823af4>
 823b1ac:	0823b2f4 	orhi	zero,at,36555
 823b1b0:	0823b2f4 	orhi	zero,at,36555
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = udp_maxalloc();
 823b1b4:	82454a40 	call	82454a4 <udp_maxalloc>
 823b1b8:	1007883a 	mov	r3,r2
 823b1bc:	e0bffd17 	ldw	r2,-12(fp)
 823b1c0:	10c01315 	stw	r3,76(r2)
 823b1c4:	e0bffd17 	ldw	r2,-12(fp)
 823b1c8:	10c01317 	ldw	r3,76(r2)
 823b1cc:	e0bffd17 	ldw	r2,-12(fp)
 823b1d0:	10c00b15 	stw	r3,44(r2)

#ifdef IP_V4
      /* make a NetPort UDP connection */
      /* unlock the net resource; UDP will immediatly re-lock it */
      if (so->so_domain  == AF_INET){
 823b1d4:	e0bffd17 	ldw	r2,-12(fp)
 823b1d8:	10800517 	ldw	r2,20(r2)
 823b1dc:	10800098 	cmpnei	r2,r2,2
 823b1e0:	10000f1e 	bne	r2,zero,823b220 <udp_usrreq+0x104>
        UNLOCK_NET_RESOURCE(NET_RESID);
 823b1e4:	0009883a 	mov	r4,zero
 823b1e8:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
        udpconn = udp_open(0L, 0, udp_socket(), udp_soinput, so);
 823b1ec:	82453380 	call	8245338 <udp_socket>
 823b1f0:	10ffffcc 	andi	r3,r2,65535
 823b1f4:	e0bffd17 	ldw	r2,-12(fp)
 823b1f8:	d8800015 	stw	r2,0(sp)
 823b1fc:	01c20934 	movhi	r7,2084
 823b200:	39ebdf04 	addi	r7,r7,-20612
 823b204:	180d883a 	mov	r6,r3
 823b208:	000b883a 	mov	r5,zero
 823b20c:	0009883a 	mov	r4,zero
 823b210:	822d12c0 	call	822d12c <udp_open>
 823b214:	e0bffb15 	stw	r2,-20(fp)
        LOCK_NET_RESOURCE(NET_RESID);
 823b218:	0009883a 	mov	r4,zero
 823b21c:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
        UNLOCK_NET_RESOURCE(NET_RESID);
        udpconn = udp6_open(0L, 0, udp_socket(), udp6_soinput, so);
        LOCK_NET_RESOURCE(NET_RESID);
      }
#endif
      if (!udpconn)
 823b220:	e0bffb17 	ldw	r2,-20(fp)
 823b224:	1000021e 	bne	r2,zero,823b230 <udp_usrreq+0x114>
         return(EINVAL);
 823b228:	00800584 	movi	r2,22
 823b22c:	00004506 	br	823b344 <udp_usrreq+0x228>
      return 0;
 823b230:	0005883a 	mov	r2,zero
 823b234:	00004306 	br	823b344 <udp_usrreq+0x228>
   case PRU_DETACH:
      /* delete the NetPort UDP connection */
      udpconn = udp_lookup(so);
 823b238:	e13ffd17 	ldw	r4,-12(fp)
 823b23c:	823af200 	call	823af20 <udp_lookup>
 823b240:	e0bffb15 	stw	r2,-20(fp)
      if (!udpconn)
 823b244:	e0bffb17 	ldw	r2,-20(fp)
 823b248:	1000021e 	bne	r2,zero,823b254 <udp_usrreq+0x138>
         return(EINVAL);
 823b24c:	00800584 	movi	r2,22
 823b250:	00003c06 	br	823b344 <udp_usrreq+0x228>
      /* unlock the net resource; UDP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 823b254:	0009883a 	mov	r4,zero
 823b258:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      udp_close(udpconn);
 823b25c:	e13ffb17 	ldw	r4,-20(fp)
 823b260:	822d3280 	call	822d328 <udp_close>
      LOCK_NET_RESOURCE(NET_RESID);
 823b264:	0009883a 	mov	r4,zero
 823b268:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      return 0;
 823b26c:	0005883a 	mov	r2,zero
 823b270:	00003406 	br	823b344 <udp_usrreq+0x228>
   case PRU_CONNECT:
      /* Install foreign port for UDP, making a virtual connection */
      /* fall to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 823b274:	e0bfff17 	ldw	r2,-4(fp)
 823b278:	1000021e 	bne	r2,zero,823b284 <udp_usrreq+0x168>
         return(EINVAL);
 823b27c:	00800584 	movi	r2,22
 823b280:	00003006 	br	823b344 <udp_usrreq+0x228>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 823b284:	e0bffd17 	ldw	r2,-12(fp)
 823b288:	10800517 	ldw	r2,20(r2)
 823b28c:	10800098 	cmpnei	r2,r2,2
 823b290:	1000051e 	bne	r2,zero,823b2a8 <udp_usrreq+0x18c>
        return udp4_sockbind(so, nam, req );
 823b294:	e1bffc17 	ldw	r6,-16(fp)
 823b298:	e17fff17 	ldw	r5,-4(fp)
 823b29c:	e13ffd17 	ldw	r4,-12(fp)
 823b2a0:	823b3580 	call	823b358 <udp4_sockbind>
 823b2a4:	00002706 	br	823b344 <udp_usrreq+0x228>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockbind(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 823b2a8:	822d5940 	call	822d594 <dtrap>
      return EINVAL;
 823b2ac:	00800584 	movi	r2,22
 823b2b0:	00002406 	br	823b344 <udp_usrreq+0x228>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 823b2b4:	e0bffe17 	ldw	r2,-8(fp)
 823b2b8:	1000021e 	bne	r2,zero,823b2c4 <udp_usrreq+0x1a8>
         return(EINVAL);
 823b2bc:	00800584 	movi	r2,22
 823b2c0:	00002006 	br	823b344 <udp_usrreq+0x228>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 823b2c4:	e0bffd17 	ldw	r2,-12(fp)
 823b2c8:	10800517 	ldw	r2,20(r2)
 823b2cc:	10800098 	cmpnei	r2,r2,2
 823b2d0:	1000051e 	bne	r2,zero,823b2e8 <udp_usrreq+0x1cc>
        return udp4_socksend(so, m, nam );
 823b2d4:	e1bfff17 	ldw	r6,-4(fp)
 823b2d8:	e17ffe17 	ldw	r5,-8(fp)
 823b2dc:	e13ffd17 	ldw	r4,-12(fp)
 823b2e0:	823b62c0 	call	823b62c <udp4_socksend>
 823b2e4:	00001706 	br	823b344 <udp_usrreq+0x228>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_socksend(so, m, nam);
      }
#endif
      dtrap();   /* invalid address */
 823b2e8:	822d5940 	call	822d594 <dtrap>
      return EINVAL;
 823b2ec:	00800584 	movi	r2,22
 823b2f0:	00001406 	br	823b344 <udp_usrreq+0x228>

   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 823b2f4:	e0bfff17 	ldw	r2,-4(fp)
 823b2f8:	1000021e 	bne	r2,zero,823b304 <udp_usrreq+0x1e8>
         return(EINVAL);
 823b2fc:	00800584 	movi	r2,22
 823b300:	00001006 	br	823b344 <udp_usrreq+0x228>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 823b304:	e0bffd17 	ldw	r2,-12(fp)
 823b308:	10800517 	ldw	r2,20(r2)
 823b30c:	10800098 	cmpnei	r2,r2,2
 823b310:	1000051e 	bne	r2,zero,823b328 <udp_usrreq+0x20c>
        return udp4_sockaddr(so, nam, req );
 823b314:	e1bffc17 	ldw	r6,-16(fp)
 823b318:	e17fff17 	ldw	r5,-4(fp)
 823b31c:	e13ffd17 	ldw	r4,-12(fp)
 823b320:	823b9ac0 	call	823b9ac <udp4_sockaddr>
 823b324:	00000706 	br	823b344 <udp_usrreq+0x228>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockaddr(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 823b328:	822d5940 	call	822d594 <dtrap>
      return EINVAL;
 823b32c:	00800584 	movi	r2,22
 823b330:	00000406 	br	823b344 <udp_usrreq+0x228>

   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 823b334:	822d5940 	call	822d594 <dtrap>
      return 0;
 823b338:	0005883a 	mov	r2,zero
 823b33c:	00000106 	br	823b344 <udp_usrreq+0x228>
   case PRU_LISTEN:     /* don't support these for UDP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 823b340:	008017c4 	movi	r2,95
   }
}
 823b344:	e037883a 	mov	sp,fp
 823b348:	dfc00117 	ldw	ra,4(sp)
 823b34c:	df000017 	ldw	fp,0(sp)
 823b350:	dec00204 	addi	sp,sp,8
 823b354:	f800283a 	ret

0823b358 <udp4_sockbind>:

#ifdef IP_V4
int udp4_sockbind(struct socket *so, struct mbuf *nam, int req ) 
{
 823b358:	defff304 	addi	sp,sp,-52
 823b35c:	dfc00c15 	stw	ra,48(sp)
 823b360:	df000b15 	stw	fp,44(sp)
 823b364:	df000b04 	addi	fp,sp,44
 823b368:	e13ffd15 	stw	r4,-12(fp)
 823b36c:	e17ffe15 	stw	r5,-8(fp)
 823b370:	e1bfff15 	stw	r6,-4(fp)
  u_short  lport;   /* local port (local byte order) */
  ip_addr fhost; /* host to send to/recv from (network byte order) */
  ip_addr lhost; /* local IP address to bind to (network byte order) */
  NET ifp;

  sin = mtod(nam, struct sockaddr_in *);
 823b374:	e0bffe17 	ldw	r2,-8(fp)
 823b378:	10800317 	ldw	r2,12(r2)
 823b37c:	e0bffa15 	stw	r2,-24(fp)
  if (sin == NULL)
 823b380:	e0bffa17 	ldw	r2,-24(fp)
 823b384:	1000021e 	bne	r2,zero,823b390 <udp4_sockbind+0x38>
    return(EINVAL);
 823b388:	00800584 	movi	r2,22
 823b38c:	0000a206 	br	823b618 <udp4_sockbind+0x2c0>
  if (nam->m_len != sizeof (*sin))
 823b390:	e0bffe17 	ldw	r2,-8(fp)
 823b394:	10800217 	ldw	r2,8(r2)
 823b398:	10800420 	cmpeqi	r2,r2,16
 823b39c:	1000021e 	bne	r2,zero,823b3a8 <udp4_sockbind+0x50>
    return(EINVAL);
 823b3a0:	00800584 	movi	r2,22
 823b3a4:	00009c06 	br	823b618 <udp4_sockbind+0x2c0>
  udpconn = udp_lookup(so);
 823b3a8:	e13ffd17 	ldw	r4,-12(fp)
 823b3ac:	823af200 	call	823af20 <udp_lookup>
 823b3b0:	e0bffb15 	stw	r2,-20(fp)
  if (!udpconn)
 823b3b4:	e0bffb17 	ldw	r2,-20(fp)
 823b3b8:	1000021e 	bne	r2,zero,823b3c4 <udp4_sockbind+0x6c>
     return(EINVAL);
 823b3bc:	00800584 	movi	r2,22
 823b3c0:	00009506 	br	823b618 <udp4_sockbind+0x2c0>
  if (req == PRU_BIND)
 823b3c4:	e0bfff17 	ldw	r2,-4(fp)
 823b3c8:	10800098 	cmpnei	r2,r2,2
 823b3cc:	1000531e 	bne	r2,zero,823b51c <udp4_sockbind+0x1c4>
     * if the caller-supplied port is 0, try to get
     * the port from the UDP endpoint, or pick a new
     * unique port; else, use the caller-supplied
     * port
     */
    if (sin->sin_port == 0)
 823b3d0:	e0bffa17 	ldw	r2,-24(fp)
 823b3d4:	1080008b 	ldhu	r2,2(r2)
 823b3d8:	10bfffcc 	andi	r2,r2,65535
 823b3dc:	10000b1e 	bne	r2,zero,823b40c <udp4_sockbind+0xb4>
    {
      if (udpconn->u_lport != 0)
 823b3e0:	e0bffb17 	ldw	r2,-20(fp)
 823b3e4:	1080018b 	ldhu	r2,6(r2)
 823b3e8:	10bfffcc 	andi	r2,r2,65535
 823b3ec:	10000426 	beq	r2,zero,823b400 <udp4_sockbind+0xa8>
        lport = udpconn->u_lport;
 823b3f0:	e0bffb17 	ldw	r2,-20(fp)
 823b3f4:	1080018b 	ldhu	r2,6(r2)
 823b3f8:	e0bff60d 	sth	r2,-40(fp)
 823b3fc:	00000e06 	br	823b438 <udp4_sockbind+0xe0>
      else
        lport = udp_socket();
 823b400:	82453380 	call	8245338 <udp_socket>
 823b404:	e0bff60d 	sth	r2,-40(fp)
 823b408:	00000b06 	br	823b438 <udp4_sockbind+0xe0>
    }
    else
    {
      lport = ntohs(sin->sin_port);
 823b40c:	e0bffa17 	ldw	r2,-24(fp)
 823b410:	1080008b 	ldhu	r2,2(r2)
 823b414:	10bfffcc 	andi	r2,r2,65535
 823b418:	1004d23a 	srli	r2,r2,8
 823b41c:	1007883a 	mov	r3,r2
 823b420:	e0bffa17 	ldw	r2,-24(fp)
 823b424:	1080008b 	ldhu	r2,2(r2)
 823b428:	10bfffcc 	andi	r2,r2,65535
 823b42c:	1004923a 	slli	r2,r2,8
 823b430:	1884b03a 	or	r2,r3,r2
 823b434:	e0bff60d 	sth	r2,-40(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * don't bind to a specific address; else, 
     * make sure the caller-supplied address is
     * an interface IP address and if so, bind to that
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 823b438:	e0bffa17 	ldw	r2,-24(fp)
 823b43c:	10800117 	ldw	r2,4(r2)
 823b440:	1000021e 	bne	r2,zero,823b44c <udp4_sockbind+0xf4>
    {
      lhost = 0L;
 823b444:	e03ff815 	stw	zero,-32(fp)
 823b448:	00001706 	br	823b4a8 <udp4_sockbind+0x150>
    }
    else
    {
      lhost = sin->sin_addr.s_addr;
 823b44c:	e0bffa17 	ldw	r2,-24(fp)
 823b450:	10800117 	ldw	r2,4(r2)
 823b454:	e0bff815 	stw	r2,-32(fp)
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b458:	008209b4 	movhi	r2,2086
 823b45c:	10ba5c04 	addi	r2,r2,-5776
 823b460:	10800017 	ldw	r2,0(r2)
 823b464:	e0bff915 	stw	r2,-28(fp)
 823b468:	00000706 	br	823b488 <udp4_sockbind+0x130>
        if (ifp->n_ipaddr == lhost)
 823b46c:	e0bff917 	ldw	r2,-28(fp)
 823b470:	10c00a17 	ldw	r3,40(r2)
 823b474:	e0bff817 	ldw	r2,-32(fp)
 823b478:	18800626 	beq	r3,r2,823b494 <udp4_sockbind+0x13c>
    else
    {
      lhost = sin->sin_addr.s_addr;
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b47c:	e0bff917 	ldw	r2,-28(fp)
 823b480:	10800017 	ldw	r2,0(r2)
 823b484:	e0bff915 	stw	r2,-28(fp)
 823b488:	e0bff917 	ldw	r2,-28(fp)
 823b48c:	103ff71e 	bne	r2,zero,823b46c <udp4_sockbind+0x114>
 823b490:	00000106 	br	823b498 <udp4_sockbind+0x140>
        if (ifp->n_ipaddr == lhost)
          break;
 823b494:	0001883a 	nop
      if (ifp == NULL)
 823b498:	e0bff917 	ldw	r2,-28(fp)
 823b49c:	1000021e 	bne	r2,zero,823b4a8 <udp4_sockbind+0x150>
        return(EADDRNOTAVAIL);
 823b4a0:	00801f44 	movi	r2,125
 823b4a4:	00005c06 	br	823b618 <udp4_sockbind+0x2c0>
    }

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
 823b4a8:	e0bffd17 	ldw	r2,-12(fp)
 823b4ac:	10800417 	ldw	r2,16(r2)
 823b4b0:	1080010c 	andi	r2,r2,4
 823b4b4:	1000121e 	bne	r2,zero,823b500 <udp4_sockbind+0x1a8>
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 823b4b8:	d0a09c17 	ldw	r2,-32144(gp)
 823b4bc:	e0bff515 	stw	r2,-44(fp)
 823b4c0:	00000d06 	br	823b4f8 <udp4_sockbind+0x1a0>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
 823b4c4:	e0bff517 	ldw	r2,-44(fp)
 823b4c8:	1080018b 	ldhu	r2,6(r2)
 823b4cc:	10ffffcc 	andi	r3,r2,65535
 823b4d0:	e0bff60b 	ldhu	r2,-40(fp)
 823b4d4:	1880051e 	bne	r3,r2,823b4ec <udp4_sockbind+0x194>
 823b4d8:	e0fff517 	ldw	r3,-44(fp)
 823b4dc:	e0bffb17 	ldw	r2,-20(fp)
 823b4e0:	18800226 	beq	r3,r2,823b4ec <udp4_sockbind+0x194>
          return(EADDRINUSE);
 823b4e4:	00801c04 	movi	r2,112
 823b4e8:	00004b06 	br	823b618 <udp4_sockbind+0x2c0>

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 823b4ec:	e0bff517 	ldw	r2,-44(fp)
 823b4f0:	10800017 	ldw	r2,0(r2)
 823b4f4:	e0bff515 	stw	r2,-44(fp)
 823b4f8:	e0bff517 	ldw	r2,-44(fp)
 823b4fc:	103ff11e 	bne	r2,zero,823b4c4 <udp4_sockbind+0x16c>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
          return(EADDRINUSE);
    /* bind the UDP endpoint */
    udpconn->u_lport = lport;
 823b500:	e0bffb17 	ldw	r2,-20(fp)
 823b504:	e0fff60b 	ldhu	r3,-40(fp)
 823b508:	10c0018d 	sth	r3,6(r2)
    udpconn->u_lhost = lhost;
 823b50c:	e0bffb17 	ldw	r2,-20(fp)
 823b510:	e0fff817 	ldw	r3,-32(fp)
 823b514:	10c00315 	stw	r3,12(r2)
 823b518:	00003e06 	br	823b614 <udp4_sockbind+0x2bc>
  else /* PRU_CONNECT */
  {
    /* connect the socket to a remote IP address and
     * UDP port.
     */
    fport = ntohs(sin->sin_port);
 823b51c:	e0bffa17 	ldw	r2,-24(fp)
 823b520:	1080008b 	ldhu	r2,2(r2)
 823b524:	10bfffcc 	andi	r2,r2,65535
 823b528:	1004d23a 	srli	r2,r2,8
 823b52c:	1007883a 	mov	r3,r2
 823b530:	e0bffa17 	ldw	r2,-24(fp)
 823b534:	1080008b 	ldhu	r2,2(r2)
 823b538:	10bfffcc 	andi	r2,r2,65535
 823b53c:	1004923a 	slli	r2,r2,8
 823b540:	1884b03a 	or	r2,r3,r2
 823b544:	e0bffc0d 	sth	r2,-16(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * use the wildcard address; else, use the caller-
     * supplied address
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 823b548:	e0bffa17 	ldw	r2,-24(fp)
 823b54c:	10800117 	ldw	r2,4(r2)
 823b550:	1000021e 	bne	r2,zero,823b55c <udp4_sockbind+0x204>
      fhost = 0L;
 823b554:	e03ff715 	stw	zero,-36(fp)
 823b558:	00000306 	br	823b568 <udp4_sockbind+0x210>
    else
      fhost = sin->sin_addr.s_addr;
 823b55c:	e0bffa17 	ldw	r2,-24(fp)
 823b560:	10800117 	ldw	r2,4(r2)
 823b564:	e0bff715 	stw	r2,-36(fp)
    /* prepare to bind the socket to the appropriate 
     * local interface address for the to-be-connected 
     * peer
     */
    lhost = ip_mymach(fhost);
 823b568:	e13ff717 	ldw	r4,-36(fp)
 823b56c:	824099c0 	call	824099c <ip_mymach>
 823b570:	e0bff815 	stw	r2,-32(fp)
    if (lhost == 0)
 823b574:	e0bff817 	ldw	r2,-32(fp)
 823b578:	1000021e 	bne	r2,zero,823b584 <udp4_sockbind+0x22c>
      return(ENETUNREACH);
 823b57c:	00801c84 	movi	r2,114
 823b580:	00002506 	br	823b618 <udp4_sockbind+0x2c0>
    /* if the socket hasn't been bound to a local
     * port yet, do so now
     */
    lport = udpconn->u_lport;
 823b584:	e0bffb17 	ldw	r2,-20(fp)
 823b588:	1080018b 	ldhu	r2,6(r2)
 823b58c:	e0bff60d 	sth	r2,-40(fp)
    if (lport == 0)
 823b590:	e0bff60b 	ldhu	r2,-40(fp)
 823b594:	1000021e 	bne	r2,zero,823b5a0 <udp4_sockbind+0x248>
      lport = udp_socket();
 823b598:	82453380 	call	8245338 <udp_socket>
 823b59c:	e0bff60d 	sth	r2,-40(fp)
    /* bind and connect the UDP endpoint */
    udpconn->u_lhost = lhost;
 823b5a0:	e0bffb17 	ldw	r2,-20(fp)
 823b5a4:	e0fff817 	ldw	r3,-32(fp)
 823b5a8:	10c00315 	stw	r3,12(r2)
    udpconn->u_lport = lport;
 823b5ac:	e0bffb17 	ldw	r2,-20(fp)
 823b5b0:	e0fff60b 	ldhu	r3,-40(fp)
 823b5b4:	10c0018d 	sth	r3,6(r2)
    udpconn->u_fhost = fhost;
 823b5b8:	e0bffb17 	ldw	r2,-20(fp)
 823b5bc:	e0fff717 	ldw	r3,-36(fp)
 823b5c0:	10c00415 	stw	r3,16(r2)
    udpconn->u_fport = fport;
 823b5c4:	e0bffb17 	ldw	r2,-20(fp)
 823b5c8:	e0fffc0b 	ldhu	r3,-16(fp)
 823b5cc:	10c0020d 	sth	r3,8(r2)
    /* mark the socket as connected */
    so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 823b5d0:	e0bffd17 	ldw	r2,-12(fp)
 823b5d4:	10c0088b 	ldhu	r3,34(r2)
 823b5d8:	00bffcc4 	movi	r2,-13
 823b5dc:	1884703a 	and	r2,r3,r2
 823b5e0:	1007883a 	mov	r3,r2
 823b5e4:	e0bffd17 	ldw	r2,-12(fp)
 823b5e8:	10c0088d 	sth	r3,34(r2)
    so->so_state |= SS_ISCONNECTED;
 823b5ec:	e0bffd17 	ldw	r2,-12(fp)
 823b5f0:	1080088b 	ldhu	r2,34(r2)
 823b5f4:	10800094 	ori	r2,r2,2
 823b5f8:	1007883a 	mov	r3,r2
 823b5fc:	e0bffd17 	ldw	r2,-12(fp)
 823b600:	10c0088d 	sth	r3,34(r2)
    /* since socket was in listen state, packets may be queued */
    sbflush(&so->so_rcv);   /* dump these now */
 823b604:	e0bffd17 	ldw	r2,-12(fp)
 823b608:	10800a04 	addi	r2,r2,40
 823b60c:	1009883a 	mov	r4,r2
 823b610:	82349280 	call	8234928 <sbflush>
  }
  return 0;
 823b614:	0005883a 	mov	r2,zero
}
 823b618:	e037883a 	mov	sp,fp
 823b61c:	dfc00117 	ldw	ra,4(sp)
 823b620:	df000017 	ldw	fp,0(sp)
 823b624:	dec00204 	addi	sp,sp,8
 823b628:	f800283a 	ret

0823b62c <udp4_socksend>:

int udp4_socksend(struct socket *so, struct mbuf *m, 
		struct mbuf *nam ) 
{
 823b62c:	defff304 	addi	sp,sp,-52
 823b630:	dfc00c15 	stw	ra,48(sp)
 823b634:	df000b15 	stw	fp,44(sp)
 823b638:	dc000a15 	stw	r16,40(sp)
 823b63c:	df000b04 	addi	fp,sp,44
 823b640:	e13ffc15 	stw	r4,-16(fp)
 823b644:	e17ffd15 	stw	r5,-12(fp)
 823b648:	e1bffe15 	stw	r6,-8(fp)
  PACKET pkt;
#ifdef MULTI_HOMED
  NET ifp;
#endif

  udpconn = udp_lookup(so);
 823b64c:	e13ffc17 	ldw	r4,-16(fp)
 823b650:	823af200 	call	823af20 <udp_lookup>
 823b654:	e0bff815 	stw	r2,-32(fp)
  if (!udpconn)
 823b658:	e0bff817 	ldw	r2,-32(fp)
 823b65c:	1000041e 	bne	r2,zero,823b670 <udp4_socksend+0x44>
  {
    m_free(m);
 823b660:	e13ffd17 	ldw	r4,-12(fp)
 823b664:	822e5300 	call	822e530 <m_free>
    /* may be bogus socket, but more likely the connection may 
       have closed due to ICMP dest unreachable from other side. */
    return(ECONNREFUSED);
 823b668:	00801bc4 	movi	r2,111
 823b66c:	0000c906 	br	823b994 <udp4_socksend+0x368>
  }

  if (nam == NULL)  /* no sendto() info passed, must be send() */
 823b670:	e0bffe17 	ldw	r2,-8(fp)
 823b674:	10000e1e 	bne	r2,zero,823b6b0 <udp4_socksend+0x84>
  { 
    if (so->so_state & SS_ISCONNECTED)
 823b678:	e0bffc17 	ldw	r2,-16(fp)
 823b67c:	1080088b 	ldhu	r2,34(r2)
 823b680:	10bfffcc 	andi	r2,r2,65535
 823b684:	1080008c 	andi	r2,r2,2
 823b688:	10000726 	beq	r2,zero,823b6a8 <udp4_socksend+0x7c>
    {
      fport = udpconn->u_fport;
 823b68c:	e0bff817 	ldw	r2,-32(fp)
 823b690:	1080020b 	ldhu	r2,8(r2)
 823b694:	e0bff50d 	sth	r2,-44(fp)
      fhost = udpconn->u_fhost;
 823b698:	e0bff817 	ldw	r2,-32(fp)
 823b69c:	10800417 	ldw	r2,16(r2)
 823b6a0:	e0bff615 	stw	r2,-40(fp)
 823b6a4:	00002806 	br	823b748 <udp4_socksend+0x11c>
    }
    else
      return (EINVAL);
 823b6a8:	00800584 	movi	r2,22
 823b6ac:	0000b906 	br	823b994 <udp4_socksend+0x368>
  }
  else if(nam->m_len != sizeof (*sin))
 823b6b0:	e0bffe17 	ldw	r2,-8(fp)
 823b6b4:	10800217 	ldw	r2,8(r2)
 823b6b8:	10800420 	cmpeqi	r2,r2,16
 823b6bc:	1000031e 	bne	r2,zero,823b6cc <udp4_socksend+0xa0>
  {
    dtrap();
 823b6c0:	822d5940 	call	822d594 <dtrap>
    return (EINVAL);
 823b6c4:	00800584 	movi	r2,22
 823b6c8:	0000b206 	br	823b994 <udp4_socksend+0x368>
  }
  else
  {
    sin = mtod(nam, struct sockaddr_in *);
 823b6cc:	e0bffe17 	ldw	r2,-8(fp)
 823b6d0:	10800317 	ldw	r2,12(r2)
 823b6d4:	e0bff915 	stw	r2,-28(fp)
    fhost = sin->sin_addr.s_addr;
 823b6d8:	e0bff917 	ldw	r2,-28(fp)
 823b6dc:	10800117 	ldw	r2,4(r2)
 823b6e0:	e0bff615 	stw	r2,-40(fp)
    /* use caller's fport if specified, ours may be a wildcard */
    if (sin->sin_port)   /* caller gets to change fport on the fly */
 823b6e4:	e0bff917 	ldw	r2,-28(fp)
 823b6e8:	1080008b 	ldhu	r2,2(r2)
 823b6ec:	10bfffcc 	andi	r2,r2,65535
 823b6f0:	10000c26 	beq	r2,zero,823b724 <udp4_socksend+0xf8>
      fport = ntohs(sin->sin_port);
 823b6f4:	e0bff917 	ldw	r2,-28(fp)
 823b6f8:	1080008b 	ldhu	r2,2(r2)
 823b6fc:	10bfffcc 	andi	r2,r2,65535
 823b700:	1004d23a 	srli	r2,r2,8
 823b704:	1007883a 	mov	r3,r2
 823b708:	e0bff917 	ldw	r2,-28(fp)
 823b70c:	1080008b 	ldhu	r2,2(r2)
 823b710:	10bfffcc 	andi	r2,r2,65535
 823b714:	1004923a 	slli	r2,r2,8
 823b718:	1884b03a 	or	r2,r3,r2
 823b71c:	e0bff50d 	sth	r2,-44(fp)
 823b720:	00000906 	br	823b748 <udp4_socksend+0x11c>
    else  /* use port already set in UDP connection */
    {
      if (udpconn->u_fport == 0) /* don't send to port 0 */
 823b724:	e0bff817 	ldw	r2,-32(fp)
 823b728:	1080020b 	ldhu	r2,8(r2)
 823b72c:	10bfffcc 	andi	r2,r2,65535
 823b730:	1000021e 	bne	r2,zero,823b73c <udp4_socksend+0x110>
        return (EINVAL);
 823b734:	00800584 	movi	r2,22
 823b738:	00009606 	br	823b994 <udp4_socksend+0x368>
      fport = udpconn->u_fport;
 823b73c:	e0bff817 	ldw	r2,-32(fp)
 823b740:	1080020b 	ldhu	r2,8(r2)
 823b744:	e0bff50d 	sth	r2,-44(fp)

  /* since our pkt->nb_buff size is tied to max packet size, we 
   * assume our UDP datagrams are always in one mbuf and that the 
   * mbuf 
   */
  if (m->m_len > (unsigned)udp_maxalloc()) /* but check anyway:*/
 823b748:	e0bffd17 	ldw	r2,-12(fp)
 823b74c:	14000217 	ldw	r16,8(r2)
 823b750:	82454a40 	call	82454a4 <udp_maxalloc>
 823b754:	1400032e 	bgeu	r2,r16,823b764 <udp4_socksend+0x138>
  {
    dtrap(); /* should never happen */
 823b758:	822d5940 	call	822d594 <dtrap>
    return EMSGSIZE;  /* try to recover */
 823b75c:	00801e84 	movi	r2,122
 823b760:	00008c06 	br	823b994 <udp4_socksend+0x368>
  }
  pkt = udp_alloc(m->m_len, 0);    /* get a NetPort buffer for send */
 823b764:	e0bffd17 	ldw	r2,-12(fp)
 823b768:	10800217 	ldw	r2,8(r2)
 823b76c:	000b883a 	mov	r5,zero
 823b770:	1009883a 	mov	r4,r2
 823b774:	82453e80 	call	82453e8 <udp_alloc>
 823b778:	e0bffa15 	stw	r2,-24(fp)
  if (!pkt)
 823b77c:	e0bffa17 	ldw	r2,-24(fp)
 823b780:	1000041e 	bne	r2,zero,823b794 <udp4_socksend+0x168>
  {
    m_free(m);
 823b784:	e13ffd17 	ldw	r4,-12(fp)
 823b788:	822e5300 	call	822e530 <m_free>
    return ENOBUFS;   /* report buffer shortages */
 823b78c:	00801a44 	movi	r2,105
 823b790:	00008006 	br	823b994 <udp4_socksend+0x368>
  }
  MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 823b794:	e0bffa17 	ldw	r2,-24(fp)
 823b798:	10c00317 	ldw	r3,12(r2)
 823b79c:	e0bffd17 	ldw	r2,-12(fp)
 823b7a0:	11000317 	ldw	r4,12(r2)
 823b7a4:	e0bffd17 	ldw	r2,-12(fp)
 823b7a8:	10800217 	ldw	r2,8(r2)
 823b7ac:	100d883a 	mov	r6,r2
 823b7b0:	200b883a 	mov	r5,r4
 823b7b4:	1809883a 	mov	r4,r3
 823b7b8:	8202f100 	call	8202f10 <memcpy>
  pkt->nb_plen = m->m_len;
 823b7bc:	e0bffd17 	ldw	r2,-12(fp)
 823b7c0:	10c00217 	ldw	r3,8(r2)
 823b7c4:	e0bffa17 	ldw	r2,-24(fp)
 823b7c8:	10c00415 	stw	r3,16(r2)
  /* finished with mbuf, free it now */
  m_free(m);
 823b7cc:	e13ffd17 	ldw	r4,-12(fp)
 823b7d0:	822e5300 	call	822e530 <m_free>
  pkt->fhost = fhost;
 823b7d4:	e0bffa17 	ldw	r2,-24(fp)
 823b7d8:	e0fff617 	ldw	r3,-40(fp)
 823b7dc:	10c00715 	stw	r3,28(r2)
     * is up; if (after all that) we don't have an interface then we
     * fail with error EADDRNOTAVAIL; and finally, if we're built
     * for a single-homed configuration where there's only one
     * interface, we might as well use it, so we do.  
   */
  if (fhost == 0xffffffff)
 823b7e0:	e0bff617 	ldw	r2,-40(fp)
 823b7e4:	10bfffd8 	cmpnei	r2,r2,-1
 823b7e8:	10004a1e 	bne	r2,zero,823b914 <udp4_socksend+0x2e8>
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
 823b7ec:	e0bff817 	ldw	r2,-32(fp)
 823b7f0:	10800317 	ldw	r2,12(r2)
 823b7f4:	10001026 	beq	r2,zero,823b838 <udp4_socksend+0x20c>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b7f8:	008209b4 	movhi	r2,2086
 823b7fc:	10ba5c04 	addi	r2,r2,-5776
 823b800:	10800017 	ldw	r2,0(r2)
 823b804:	e0bff715 	stw	r2,-36(fp)
 823b808:	00000806 	br	823b82c <udp4_socksend+0x200>
        if (ifp->n_ipaddr == udpconn->u_lhost)
 823b80c:	e0bff717 	ldw	r2,-36(fp)
 823b810:	10c00a17 	ldw	r3,40(r2)
 823b814:	e0bff817 	ldw	r2,-32(fp)
 823b818:	10800317 	ldw	r2,12(r2)
 823b81c:	18801d26 	beq	r3,r2,823b894 <udp4_socksend+0x268>
  if (fhost == 0xffffffff)
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b820:	e0bff717 	ldw	r2,-36(fp)
 823b824:	10800017 	ldw	r2,0(r2)
 823b828:	e0bff715 	stw	r2,-36(fp)
 823b82c:	e0bff717 	ldw	r2,-36(fp)
 823b830:	103ff61e 	bne	r2,zero,823b80c <udp4_socksend+0x1e0>
 823b834:	00001a06 	br	823b8a0 <udp4_socksend+0x274>
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b838:	008209b4 	movhi	r2,2086
 823b83c:	10ba5c04 	addi	r2,r2,-5776
 823b840:	10800017 	ldw	r2,0(r2)
 823b844:	e0bff715 	stw	r2,-36(fp)
 823b848:	00000f06 	br	823b888 <udp4_socksend+0x25c>
        if ((ifp->n_flags & NF_BCAST) &&
 823b84c:	e0bff717 	ldw	r2,-36(fp)
 823b850:	10802a17 	ldw	r2,168(r2)
 823b854:	1080004c 	andi	r2,r2,1
 823b858:	10000826 	beq	r2,zero,823b87c <udp4_socksend+0x250>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 823b85c:	e0bff717 	ldw	r2,-36(fp)
 823b860:	10802717 	ldw	r2,156(r2)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if ((ifp->n_flags & NF_BCAST) &&
 823b864:	10000526 	beq	r2,zero,823b87c <udp4_socksend+0x250>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 823b868:	e0bff717 	ldw	r2,-36(fp)
 823b86c:	10802717 	ldw	r2,156(r2)
 823b870:	10800617 	ldw	r2,24(r2)
 823b874:	10800058 	cmpnei	r2,r2,1
 823b878:	10000826 	beq	r2,zero,823b89c <udp4_socksend+0x270>
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b87c:	e0bff717 	ldw	r2,-36(fp)
 823b880:	10800017 	ldw	r2,0(r2)
 823b884:	e0bff715 	stw	r2,-36(fp)
 823b888:	e0bff717 	ldw	r2,-36(fp)
 823b88c:	103fef1e 	bne	r2,zero,823b84c <udp4_socksend+0x220>
 823b890:	00000306 	br	823b8a0 <udp4_socksend+0x274>
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
 823b894:	0001883a 	nop
 823b898:	00000106 	br	823b8a0 <udp4_socksend+0x274>
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if ((ifp->n_flags & NF_BCAST) &&
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
 823b89c:	0001883a 	nop
    }
    if (ifp == NULL)
 823b8a0:	e0bff717 	ldw	r2,-36(fp)
 823b8a4:	1000181e 	bne	r2,zero,823b908 <udp4_socksend+0x2dc>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b8a8:	008209b4 	movhi	r2,2086
 823b8ac:	10ba5c04 	addi	r2,r2,-5776
 823b8b0:	10800017 	ldw	r2,0(r2)
 823b8b4:	e0bff715 	stw	r2,-36(fp)
 823b8b8:	00000b06 	br	823b8e8 <udp4_socksend+0x2bc>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 823b8bc:	e0bff717 	ldw	r2,-36(fp)
 823b8c0:	10802717 	ldw	r2,156(r2)
 823b8c4:	10000526 	beq	r2,zero,823b8dc <udp4_socksend+0x2b0>
 823b8c8:	e0bff717 	ldw	r2,-36(fp)
 823b8cc:	10802717 	ldw	r2,156(r2)
 823b8d0:	10800617 	ldw	r2,24(r2)
 823b8d4:	10800058 	cmpnei	r2,r2,1
 823b8d8:	10000626 	beq	r2,zero,823b8f4 <udp4_socksend+0x2c8>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
    }
    if (ifp == NULL)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b8dc:	e0bff717 	ldw	r2,-36(fp)
 823b8e0:	10800017 	ldw	r2,0(r2)
 823b8e4:	e0bff715 	stw	r2,-36(fp)
 823b8e8:	e0bff717 	ldw	r2,-36(fp)
 823b8ec:	103ff31e 	bne	r2,zero,823b8bc <udp4_socksend+0x290>
 823b8f0:	00000106 	br	823b8f8 <udp4_socksend+0x2cc>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
          break;
 823b8f4:	0001883a 	nop
      if (ifp == NULL)
 823b8f8:	e0bff717 	ldw	r2,-36(fp)
 823b8fc:	1000021e 	bne	r2,zero,823b908 <udp4_socksend+0x2dc>
        return(EADDRNOTAVAIL);
 823b900:	00801f44 	movi	r2,125
 823b904:	00002306 	br	823b994 <udp4_socksend+0x368>
    }
    pkt->net = ifp;
 823b908:	e0bffa17 	ldw	r2,-24(fp)
 823b90c:	e0fff717 	ldw	r3,-36(fp)
 823b910:	10c00615 	stw	r3,24(r2)
#ifdef IP_MULTICAST

  /* If the socket has an IP moptions structure for multicast options,
   * place a pointer to this structure in the PACKET structure.
   */
  if (so->inp_moptions)
 823b914:	e0bffc17 	ldw	r2,-16(fp)
 823b918:	10800317 	ldw	r2,12(r2)
 823b91c:	10000426 	beq	r2,zero,823b930 <udp4_socksend+0x304>
     pkt->imo = so->inp_moptions;
 823b920:	e0bffc17 	ldw	r2,-16(fp)
 823b924:	10c00317 	ldw	r3,12(r2)
 823b928:	e0bffa17 	ldw	r2,-24(fp)
 823b92c:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

   /* have we set options? */
   if (so->so_optsPack)
 823b930:	e0bffc17 	ldw	r2,-16(fp)
 823b934:	10801f17 	ldw	r2,124(r2)
 823b938:	10000426 	beq	r2,zero,823b94c <udp4_socksend+0x320>
	   pkt->soxopts = so->so_optsPack; /* yup - copy to pkt */
 823b93c:	e0bffc17 	ldw	r2,-16(fp)
 823b940:	10c01f17 	ldw	r3,124(r2)
 823b944:	e0bffa17 	ldw	r2,-24(fp)
 823b948:	10c00c15 	stw	r3,48(r2)

  /* unlock the net resource; UDP will immediately re-lock it */
  UNLOCK_NET_RESOURCE(NET_RESID);
 823b94c:	0009883a 	mov	r4,zero
 823b950:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
  e = udp_send(fport, udpconn->u_lport, pkt);
 823b954:	e0fff50b 	ldhu	r3,-44(fp)
 823b958:	e0bff817 	ldw	r2,-32(fp)
 823b95c:	1080018b 	ldhu	r2,6(r2)
 823b960:	10bfffcc 	andi	r2,r2,65535
 823b964:	e1bffa17 	ldw	r6,-24(fp)
 823b968:	100b883a 	mov	r5,r2
 823b96c:	1809883a 	mov	r4,r3
 823b970:	8244fac0 	call	8244fac <udp_send>
 823b974:	e0bffb15 	stw	r2,-20(fp)
  LOCK_NET_RESOURCE(NET_RESID);
 823b978:	0009883a 	mov	r4,zero
 823b97c:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
  if (e < 0) 
 823b980:	e0bffb17 	ldw	r2,-20(fp)
 823b984:	1000020e 	bge	r2,zero,823b990 <udp4_socksend+0x364>
     return(e);
 823b988:	e0bffb17 	ldw	r2,-20(fp)
 823b98c:	00000106 	br	823b994 <udp4_socksend+0x368>
  return 0;
 823b990:	0005883a 	mov	r2,zero
}
 823b994:	e6ffff04 	addi	sp,fp,-4
 823b998:	dfc00217 	ldw	ra,8(sp)
 823b99c:	df000117 	ldw	fp,4(sp)
 823b9a0:	dc000017 	ldw	r16,0(sp)
 823b9a4:	dec00304 	addi	sp,sp,12
 823b9a8:	f800283a 	ret

0823b9ac <udp4_sockaddr>:

int udp4_sockaddr(struct socket *so, struct mbuf *nam , int req)
{
 823b9ac:	defff904 	addi	sp,sp,-28
 823b9b0:	dfc00615 	stw	ra,24(sp)
 823b9b4:	df000515 	stw	fp,20(sp)
 823b9b8:	df000504 	addi	fp,sp,20
 823b9bc:	e13ffd15 	stw	r4,-12(fp)
 823b9c0:	e17ffe15 	stw	r5,-8(fp)
 823b9c4:	e1bfff15 	stw	r6,-4(fp)
  struct sockaddr_in * sin;
  UDPCONN udpconn;

  sin = mtod(nam, struct sockaddr_in *);
 823b9c8:	e0bffe17 	ldw	r2,-8(fp)
 823b9cc:	10800317 	ldw	r2,12(r2)
 823b9d0:	e0bffb15 	stw	r2,-20(fp)
  if (sin == NULL)
 823b9d4:	e0bffb17 	ldw	r2,-20(fp)
 823b9d8:	1000021e 	bne	r2,zero,823b9e4 <udp4_sockaddr+0x38>
     return(EINVAL);
 823b9dc:	00800584 	movi	r2,22
 823b9e0:	00003706 	br	823bac0 <udp4_sockaddr+0x114>
  udpconn = udp_lookup(so);
 823b9e4:	e13ffd17 	ldw	r4,-12(fp)
 823b9e8:	823af200 	call	823af20 <udp_lookup>
 823b9ec:	e0bffc15 	stw	r2,-16(fp)
  if (!udpconn)
 823b9f0:	e0bffc17 	ldw	r2,-16(fp)
 823b9f4:	1000021e 	bne	r2,zero,823ba00 <udp4_sockaddr+0x54>
     return(EINVAL);
 823b9f8:	00800584 	movi	r2,22
 823b9fc:	00003006 	br	823bac0 <udp4_sockaddr+0x114>
  nam->m_len = sizeof(*sin);
 823ba00:	e0bffe17 	ldw	r2,-8(fp)
 823ba04:	00c00404 	movi	r3,16
 823ba08:	10c00215 	stw	r3,8(r2)
  if (req == PRU_SOCKADDR)
 823ba0c:	e0bfff17 	ldw	r2,-4(fp)
 823ba10:	108003d8 	cmpnei	r2,r2,15
 823ba14:	1000151e 	bne	r2,zero,823ba6c <udp4_sockaddr+0xc0>
  {
     sin->sin_family = AF_INET;
 823ba18:	e0bffb17 	ldw	r2,-20(fp)
 823ba1c:	00c00084 	movi	r3,2
 823ba20:	10c0000d 	sth	r3,0(r2)
     sin->sin_port = htons(udpconn->u_lport);
 823ba24:	e0bffc17 	ldw	r2,-16(fp)
 823ba28:	1080018b 	ldhu	r2,6(r2)
 823ba2c:	10bfffcc 	andi	r2,r2,65535
 823ba30:	1004d23a 	srli	r2,r2,8
 823ba34:	1007883a 	mov	r3,r2
 823ba38:	e0bffc17 	ldw	r2,-16(fp)
 823ba3c:	1080018b 	ldhu	r2,6(r2)
 823ba40:	10bfffcc 	andi	r2,r2,65535
 823ba44:	1004923a 	slli	r2,r2,8
 823ba48:	1884b03a 	or	r2,r3,r2
 823ba4c:	1007883a 	mov	r3,r2
 823ba50:	e0bffb17 	ldw	r2,-20(fp)
 823ba54:	10c0008d 	sth	r3,2(r2)
     sin->sin_addr.s_addr = udpconn->u_lhost;
 823ba58:	e0bffc17 	ldw	r2,-16(fp)
 823ba5c:	10c00317 	ldw	r3,12(r2)
 823ba60:	e0bffb17 	ldw	r2,-20(fp)
 823ba64:	10c00115 	stw	r3,4(r2)
 823ba68:	00001406 	br	823babc <udp4_sockaddr+0x110>
  }
  else /* PRU_PEERADDR */
  {
    sin->sin_family = AF_INET;
 823ba6c:	e0bffb17 	ldw	r2,-20(fp)
 823ba70:	00c00084 	movi	r3,2
 823ba74:	10c0000d 	sth	r3,0(r2)
    sin->sin_port = htons(udpconn->u_fport);
 823ba78:	e0bffc17 	ldw	r2,-16(fp)
 823ba7c:	1080020b 	ldhu	r2,8(r2)
 823ba80:	10bfffcc 	andi	r2,r2,65535
 823ba84:	1004d23a 	srli	r2,r2,8
 823ba88:	1007883a 	mov	r3,r2
 823ba8c:	e0bffc17 	ldw	r2,-16(fp)
 823ba90:	1080020b 	ldhu	r2,8(r2)
 823ba94:	10bfffcc 	andi	r2,r2,65535
 823ba98:	1004923a 	slli	r2,r2,8
 823ba9c:	1884b03a 	or	r2,r3,r2
 823baa0:	1007883a 	mov	r3,r2
 823baa4:	e0bffb17 	ldw	r2,-20(fp)
 823baa8:	10c0008d 	sth	r3,2(r2)
    sin->sin_addr.s_addr = udpconn->u_fhost;
 823baac:	e0bffc17 	ldw	r2,-16(fp)
 823bab0:	10c00417 	ldw	r3,16(r2)
 823bab4:	e0bffb17 	ldw	r2,-20(fp)
 823bab8:	10c00115 	stw	r3,4(r2)
  }
  return 0;
 823babc:	0005883a 	mov	r2,zero
}
 823bac0:	e037883a 	mov	sp,fp
 823bac4:	dfc00117 	ldw	ra,4(sp)
 823bac8:	df000017 	ldw	fp,0(sp)
 823bacc:	dec00204 	addi	sp,sp,8
 823bad0:	f800283a 	ret

0823bad4 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 823bad4:	defff504 	addi	sp,sp,-44
 823bad8:	df000a15 	stw	fp,40(sp)
 823badc:	df000a04 	addi	fp,sp,40
 823bae0:	e13ffc15 	stw	r4,-16(fp)
 823bae4:	e17ffd15 	stw	r5,-12(fp)
 823bae8:	e1bffe15 	stw	r6,-8(fp)
 823baec:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 823baf0:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 823baf4:	d0a0b817 	ldw	r2,-32032(gp)
  
  if (alt_ticks_per_second ())
 823baf8:	10003c26 	beq	r2,zero,823bbec <alt_alarm_start+0x118>
  {
    if (alarm)
 823bafc:	e0bffc17 	ldw	r2,-16(fp)
 823bb00:	10003826 	beq	r2,zero,823bbe4 <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
 823bb04:	e0bffc17 	ldw	r2,-16(fp)
 823bb08:	e0fffe17 	ldw	r3,-8(fp)
 823bb0c:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 823bb10:	e0bffc17 	ldw	r2,-16(fp)
 823bb14:	e0ffff17 	ldw	r3,-4(fp)
 823bb18:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823bb1c:	0005303a 	rdctl	r2,status
 823bb20:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823bb24:	e0fff917 	ldw	r3,-28(fp)
 823bb28:	00bfff84 	movi	r2,-2
 823bb2c:	1884703a 	and	r2,r3,r2
 823bb30:	1001703a 	wrctl	status,r2
  
  return context;
 823bb34:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
 823bb38:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 823bb3c:	d0a0b917 	ldw	r2,-32028(gp)
      
      current_nticks = alt_nticks();
 823bb40:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 823bb44:	e0fffd17 	ldw	r3,-12(fp)
 823bb48:	e0bff617 	ldw	r2,-40(fp)
 823bb4c:	1885883a 	add	r2,r3,r2
 823bb50:	10c00044 	addi	r3,r2,1
 823bb54:	e0bffc17 	ldw	r2,-16(fp)
 823bb58:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 823bb5c:	e0bffc17 	ldw	r2,-16(fp)
 823bb60:	10c00217 	ldw	r3,8(r2)
 823bb64:	e0bff617 	ldw	r2,-40(fp)
 823bb68:	1880042e 	bgeu	r3,r2,823bb7c <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
 823bb6c:	e0bffc17 	ldw	r2,-16(fp)
 823bb70:	00c00044 	movi	r3,1
 823bb74:	10c00405 	stb	r3,16(r2)
 823bb78:	00000206 	br	823bb84 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
 823bb7c:	e0bffc17 	ldw	r2,-16(fp)
 823bb80:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 823bb84:	e0bffc17 	ldw	r2,-16(fp)
 823bb88:	d0e04904 	addi	r3,gp,-32476
 823bb8c:	e0fffa15 	stw	r3,-24(fp)
 823bb90:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 823bb94:	e0bffb17 	ldw	r2,-20(fp)
 823bb98:	e0fffa17 	ldw	r3,-24(fp)
 823bb9c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 823bba0:	e0bffa17 	ldw	r2,-24(fp)
 823bba4:	10c00017 	ldw	r3,0(r2)
 823bba8:	e0bffb17 	ldw	r2,-20(fp)
 823bbac:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 823bbb0:	e0bffa17 	ldw	r2,-24(fp)
 823bbb4:	10800017 	ldw	r2,0(r2)
 823bbb8:	e0fffb17 	ldw	r3,-20(fp)
 823bbbc:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 823bbc0:	e0bffa17 	ldw	r2,-24(fp)
 823bbc4:	e0fffb17 	ldw	r3,-20(fp)
 823bbc8:	10c00015 	stw	r3,0(r2)
 823bbcc:	e0bff817 	ldw	r2,-32(fp)
 823bbd0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823bbd4:	e0bff717 	ldw	r2,-36(fp)
 823bbd8:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 823bbdc:	0005883a 	mov	r2,zero
 823bbe0:	00000306 	br	823bbf0 <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
 823bbe4:	00bffa84 	movi	r2,-22
 823bbe8:	00000106 	br	823bbf0 <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
 823bbec:	00bfde84 	movi	r2,-134
  }
}
 823bbf0:	e037883a 	mov	sp,fp
 823bbf4:	df000017 	ldw	fp,0(sp)
 823bbf8:	dec00104 	addi	sp,sp,4
 823bbfc:	f800283a 	ret

0823bc00 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823bc00:	defffe04 	addi	sp,sp,-8
 823bc04:	dfc00115 	stw	ra,4(sp)
 823bc08:	df000015 	stw	fp,0(sp)
 823bc0c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823bc10:	d0a04717 	ldw	r2,-32484(gp)
 823bc14:	10000326 	beq	r2,zero,823bc24 <alt_get_errno+0x24>
 823bc18:	d0a04717 	ldw	r2,-32484(gp)
 823bc1c:	103ee83a 	callr	r2
 823bc20:	00000106 	br	823bc28 <alt_get_errno+0x28>
 823bc24:	d0a06304 	addi	r2,gp,-32372
}
 823bc28:	e037883a 	mov	sp,fp
 823bc2c:	dfc00117 	ldw	ra,4(sp)
 823bc30:	df000017 	ldw	fp,0(sp)
 823bc34:	dec00204 	addi	sp,sp,8
 823bc38:	f800283a 	ret

0823bc3c <alt_close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 823bc3c:	defffb04 	addi	sp,sp,-20
 823bc40:	dfc00415 	stw	ra,16(sp)
 823bc44:	df000315 	stw	fp,12(sp)
 823bc48:	df000304 	addi	fp,sp,12
 823bc4c:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 823bc50:	e0bfff17 	ldw	r2,-4(fp)
 823bc54:	10000616 	blt	r2,zero,823bc70 <alt_close+0x34>
 823bc58:	e0bfff17 	ldw	r2,-4(fp)
 823bc5c:	10c00324 	muli	r3,r2,12
 823bc60:	00820974 	movhi	r2,2085
 823bc64:	108ed304 	addi	r2,r2,15180
 823bc68:	1885883a 	add	r2,r3,r2
 823bc6c:	00000106 	br	823bc74 <alt_close+0x38>
 823bc70:	0005883a 	mov	r2,zero
 823bc74:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
 823bc78:	e0bffd17 	ldw	r2,-12(fp)
 823bc7c:	10001926 	beq	r2,zero,823bce4 <alt_close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 823bc80:	e0bffd17 	ldw	r2,-12(fp)
 823bc84:	10800017 	ldw	r2,0(r2)
 823bc88:	10800417 	ldw	r2,16(r2)
 823bc8c:	10000626 	beq	r2,zero,823bca8 <alt_close+0x6c>
 823bc90:	e0bffd17 	ldw	r2,-12(fp)
 823bc94:	10800017 	ldw	r2,0(r2)
 823bc98:	10800417 	ldw	r2,16(r2)
 823bc9c:	e13ffd17 	ldw	r4,-12(fp)
 823bca0:	103ee83a 	callr	r2
 823bca4:	00000106 	br	823bcac <alt_close+0x70>
 823bca8:	0005883a 	mov	r2,zero
 823bcac:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 823bcb0:	e13fff17 	ldw	r4,-4(fp)
 823bcb4:	823c74c0 	call	823c74c <alt_release_fd>
    if (rval < 0)
 823bcb8:	e0bffe17 	ldw	r2,-8(fp)
 823bcbc:	1000070e 	bge	r2,zero,823bcdc <alt_close+0xa0>
    {
      ALT_ERRNO = -rval;
 823bcc0:	823bc000 	call	823bc00 <alt_get_errno>
 823bcc4:	1007883a 	mov	r3,r2
 823bcc8:	e0bffe17 	ldw	r2,-8(fp)
 823bccc:	0085c83a 	sub	r2,zero,r2
 823bcd0:	18800015 	stw	r2,0(r3)
      return -1;
 823bcd4:	00bfffc4 	movi	r2,-1
 823bcd8:	00000706 	br	823bcf8 <alt_close+0xbc>
    }
    return 0;
 823bcdc:	0005883a 	mov	r2,zero
 823bce0:	00000506 	br	823bcf8 <alt_close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 823bce4:	823bc000 	call	823bc00 <alt_get_errno>
 823bce8:	1007883a 	mov	r3,r2
 823bcec:	00801444 	movi	r2,81
 823bcf0:	18800015 	stw	r2,0(r3)
    return -1;
 823bcf4:	00bfffc4 	movi	r2,-1
  }
}
 823bcf8:	e037883a 	mov	sp,fp
 823bcfc:	dfc00117 	ldw	ra,4(sp)
 823bd00:	df000017 	ldw	fp,0(sp)
 823bd04:	dec00204 	addi	sp,sp,8
 823bd08:	f800283a 	ret

0823bd0c <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
 823bd0c:	defffb04 	addi	sp,sp,-20
 823bd10:	df000415 	stw	fp,16(sp)
 823bd14:	df000404 	addi	fp,sp,16
 823bd18:	e13ffe15 	stw	r4,-8(fp)
 823bd1c:	e17fff15 	stw	r5,-4(fp)
  {
    len = NIOS2_DCACHE_SIZE;
  }
  #endif

  end = ((char*) start) + len; 
 823bd20:	e0fffe17 	ldw	r3,-8(fp)
 823bd24:	e0bfff17 	ldw	r2,-4(fp)
 823bd28:	1885883a 	add	r2,r3,r2
 823bd2c:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 823bd30:	e0bffe17 	ldw	r2,-8(fp)
 823bd34:	e0bffc15 	stw	r2,-16(fp)
 823bd38:	00000506 	br	823bd50 <alt_dcache_flush+0x44>
  { 
    ALT_FLUSH_DATA(i); 
 823bd3c:	e0bffc17 	ldw	r2,-16(fp)
 823bd40:	1000001b 	flushda	0(r2)
  }
  #endif

  end = ((char*) start) + len; 

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 823bd44:	e0bffc17 	ldw	r2,-16(fp)
 823bd48:	10800804 	addi	r2,r2,32
 823bd4c:	e0bffc15 	stw	r2,-16(fp)
 823bd50:	e0fffc17 	ldw	r3,-16(fp)
 823bd54:	e0bffd17 	ldw	r2,-12(fp)
 823bd58:	18bff836 	bltu	r3,r2,823bd3c <alt_dcache_flush+0x30>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_DCACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_DCACHE_LINE_SIZE - 1))
 823bd5c:	e0bffe17 	ldw	r2,-8(fp)
 823bd60:	108007cc 	andi	r2,r2,31
 823bd64:	10000226 	beq	r2,zero,823bd70 <alt_dcache_flush+0x64>
  {
    ALT_FLUSH_DATA(i);
 823bd68:	e0bffc17 	ldw	r2,-16(fp)
 823bd6c:	1000001b 	flushda	0(r2)
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 823bd70:	0001883a 	nop
 823bd74:	e037883a 	mov	sp,fp
 823bd78:	df000017 	ldw	fp,0(sp)
 823bd7c:	dec00104 	addi	sp,sp,4
 823bd80:	f800283a 	ret

0823bd84 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 823bd84:	defffc04 	addi	sp,sp,-16
 823bd88:	df000315 	stw	fp,12(sp)
 823bd8c:	df000304 	addi	fp,sp,12
 823bd90:	e13ffd15 	stw	r4,-12(fp)
 823bd94:	e17ffe15 	stw	r5,-8(fp)
 823bd98:	e1bfff15 	stw	r6,-4(fp)
  return len;
 823bd9c:	e0bfff17 	ldw	r2,-4(fp)
}
 823bda0:	e037883a 	mov	sp,fp
 823bda4:	df000017 	ldw	fp,0(sp)
 823bda8:	dec00104 	addi	sp,sp,4
 823bdac:	f800283a 	ret

0823bdb0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823bdb0:	defffe04 	addi	sp,sp,-8
 823bdb4:	dfc00115 	stw	ra,4(sp)
 823bdb8:	df000015 	stw	fp,0(sp)
 823bdbc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823bdc0:	d0a04717 	ldw	r2,-32484(gp)
 823bdc4:	10000326 	beq	r2,zero,823bdd4 <alt_get_errno+0x24>
 823bdc8:	d0a04717 	ldw	r2,-32484(gp)
 823bdcc:	103ee83a 	callr	r2
 823bdd0:	00000106 	br	823bdd8 <alt_get_errno+0x28>
 823bdd4:	d0a06304 	addi	r2,gp,-32372
}
 823bdd8:	e037883a 	mov	sp,fp
 823bddc:	dfc00117 	ldw	ra,4(sp)
 823bde0:	df000017 	ldw	fp,0(sp)
 823bde4:	dec00204 	addi	sp,sp,8
 823bde8:	f800283a 	ret

0823bdec <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 823bdec:	defffa04 	addi	sp,sp,-24
 823bdf0:	dfc00515 	stw	ra,20(sp)
 823bdf4:	df000415 	stw	fp,16(sp)
 823bdf8:	df000404 	addi	fp,sp,16
 823bdfc:	e13ffe15 	stw	r4,-8(fp)
 823be00:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 823be04:	e0bffe17 	ldw	r2,-8(fp)
 823be08:	10000326 	beq	r2,zero,823be18 <alt_dev_llist_insert+0x2c>
 823be0c:	e0bffe17 	ldw	r2,-8(fp)
 823be10:	10800217 	ldw	r2,8(r2)
 823be14:	1000061e 	bne	r2,zero,823be30 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 823be18:	823bdb00 	call	823bdb0 <alt_get_errno>
 823be1c:	1007883a 	mov	r3,r2
 823be20:	00800584 	movi	r2,22
 823be24:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 823be28:	00bffa84 	movi	r2,-22
 823be2c:	00001306 	br	823be7c <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 823be30:	e0bffe17 	ldw	r2,-8(fp)
 823be34:	e0ffff17 	ldw	r3,-4(fp)
 823be38:	e0fffc15 	stw	r3,-16(fp)
 823be3c:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 823be40:	e0bffd17 	ldw	r2,-12(fp)
 823be44:	e0fffc17 	ldw	r3,-16(fp)
 823be48:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 823be4c:	e0bffc17 	ldw	r2,-16(fp)
 823be50:	10c00017 	ldw	r3,0(r2)
 823be54:	e0bffd17 	ldw	r2,-12(fp)
 823be58:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 823be5c:	e0bffc17 	ldw	r2,-16(fp)
 823be60:	10800017 	ldw	r2,0(r2)
 823be64:	e0fffd17 	ldw	r3,-12(fp)
 823be68:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 823be6c:	e0bffc17 	ldw	r2,-16(fp)
 823be70:	e0fffd17 	ldw	r3,-12(fp)
 823be74:	10c00015 	stw	r3,0(r2)

  return 0;  
 823be78:	0005883a 	mov	r2,zero
}
 823be7c:	e037883a 	mov	sp,fp
 823be80:	dfc00117 	ldw	ra,4(sp)
 823be84:	df000017 	ldw	fp,0(sp)
 823be88:	dec00204 	addi	sp,sp,8
 823be8c:	f800283a 	ret

0823be90 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 823be90:	defffd04 	addi	sp,sp,-12
 823be94:	dfc00215 	stw	ra,8(sp)
 823be98:	df000115 	stw	fp,4(sp)
 823be9c:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 823bea0:	00820974 	movhi	r2,2085
 823bea4:	10afb404 	addi	r2,r2,-16688
 823bea8:	e0bfff15 	stw	r2,-4(fp)
 823beac:	00000606 	br	823bec8 <_do_ctors+0x38>
        (*ctor) (); 
 823beb0:	e0bfff17 	ldw	r2,-4(fp)
 823beb4:	10800017 	ldw	r2,0(r2)
 823beb8:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 823bebc:	e0bfff17 	ldw	r2,-4(fp)
 823bec0:	10bfff04 	addi	r2,r2,-4
 823bec4:	e0bfff15 	stw	r2,-4(fp)
 823bec8:	e0ffff17 	ldw	r3,-4(fp)
 823becc:	00820974 	movhi	r2,2085
 823bed0:	10afb504 	addi	r2,r2,-16684
 823bed4:	18bff62e 	bgeu	r3,r2,823beb0 <_do_ctors+0x20>
        (*ctor) (); 
}
 823bed8:	0001883a 	nop
 823bedc:	e037883a 	mov	sp,fp
 823bee0:	dfc00117 	ldw	ra,4(sp)
 823bee4:	df000017 	ldw	fp,0(sp)
 823bee8:	dec00204 	addi	sp,sp,8
 823beec:	f800283a 	ret

0823bef0 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 823bef0:	defffd04 	addi	sp,sp,-12
 823bef4:	dfc00215 	stw	ra,8(sp)
 823bef8:	df000115 	stw	fp,4(sp)
 823befc:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 823bf00:	00820974 	movhi	r2,2085
 823bf04:	10afb404 	addi	r2,r2,-16688
 823bf08:	e0bfff15 	stw	r2,-4(fp)
 823bf0c:	00000606 	br	823bf28 <_do_dtors+0x38>
        (*dtor) (); 
 823bf10:	e0bfff17 	ldw	r2,-4(fp)
 823bf14:	10800017 	ldw	r2,0(r2)
 823bf18:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 823bf1c:	e0bfff17 	ldw	r2,-4(fp)
 823bf20:	10bfff04 	addi	r2,r2,-4
 823bf24:	e0bfff15 	stw	r2,-4(fp)
 823bf28:	e0ffff17 	ldw	r3,-4(fp)
 823bf2c:	00820974 	movhi	r2,2085
 823bf30:	10afb504 	addi	r2,r2,-16684
 823bf34:	18bff62e 	bgeu	r3,r2,823bf10 <_do_dtors+0x20>
        (*dtor) (); 
}
 823bf38:	0001883a 	nop
 823bf3c:	e037883a 	mov	sp,fp
 823bf40:	dfc00117 	ldw	ra,4(sp)
 823bf44:	df000017 	ldw	fp,0(sp)
 823bf48:	dec00204 	addi	sp,sp,8
 823bf4c:	f800283a 	ret

0823bf50 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 823bf50:	defffa04 	addi	sp,sp,-24
 823bf54:	dfc00515 	stw	ra,20(sp)
 823bf58:	df000415 	stw	fp,16(sp)
 823bf5c:	df000404 	addi	fp,sp,16
 823bf60:	e13ffe15 	stw	r4,-8(fp)
 823bf64:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
 823bf68:	e0bfff17 	ldw	r2,-4(fp)
 823bf6c:	10800017 	ldw	r2,0(r2)
 823bf70:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 823bf74:	e13ffe17 	ldw	r4,-8(fp)
 823bf78:	8203f600 	call	8203f60 <strlen>
 823bf7c:	10800044 	addi	r2,r2,1
 823bf80:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 823bf84:	00000d06 	br	823bfbc <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 823bf88:	e0bffc17 	ldw	r2,-16(fp)
 823bf8c:	10800217 	ldw	r2,8(r2)
 823bf90:	e0fffd17 	ldw	r3,-12(fp)
 823bf94:	180d883a 	mov	r6,r3
 823bf98:	e17ffe17 	ldw	r5,-8(fp)
 823bf9c:	1009883a 	mov	r4,r2
 823bfa0:	820c5dc0 	call	820c5dc <memcmp>
 823bfa4:	1000021e 	bne	r2,zero,823bfb0 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 823bfa8:	e0bffc17 	ldw	r2,-16(fp)
 823bfac:	00000706 	br	823bfcc <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 823bfb0:	e0bffc17 	ldw	r2,-16(fp)
 823bfb4:	10800017 	ldw	r2,0(r2)
 823bfb8:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 823bfbc:	e0fffc17 	ldw	r3,-16(fp)
 823bfc0:	e0bfff17 	ldw	r2,-4(fp)
 823bfc4:	18bff01e 	bne	r3,r2,823bf88 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 823bfc8:	0005883a 	mov	r2,zero
}
 823bfcc:	e037883a 	mov	sp,fp
 823bfd0:	dfc00117 	ldw	ra,4(sp)
 823bfd4:	df000017 	ldw	fp,0(sp)
 823bfd8:	dec00204 	addi	sp,sp,8
 823bfdc:	f800283a 	ret

0823bfe0 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 823bfe0:	defff904 	addi	sp,sp,-28
 823bfe4:	dfc00615 	stw	ra,24(sp)
 823bfe8:	df000515 	stw	fp,20(sp)
 823bfec:	df000504 	addi	fp,sp,20
 823bff0:	e13ffc15 	stw	r4,-16(fp)
 823bff4:	e17ffd15 	stw	r5,-12(fp)
 823bff8:	e1bffe15 	stw	r6,-8(fp)
 823bffc:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 823c000:	e0800217 	ldw	r2,8(fp)
 823c004:	d8800015 	stw	r2,0(sp)
 823c008:	e1ffff17 	ldw	r7,-4(fp)
 823c00c:	e1bffe17 	ldw	r6,-8(fp)
 823c010:	e17ffd17 	ldw	r5,-12(fp)
 823c014:	e13ffc17 	ldw	r4,-16(fp)
 823c018:	823c1900 	call	823c190 <alt_iic_isr_register>
}  
 823c01c:	e037883a 	mov	sp,fp
 823c020:	dfc00117 	ldw	ra,4(sp)
 823c024:	df000017 	ldw	fp,0(sp)
 823c028:	dec00204 	addi	sp,sp,8
 823c02c:	f800283a 	ret

0823c030 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 823c030:	defff904 	addi	sp,sp,-28
 823c034:	df000615 	stw	fp,24(sp)
 823c038:	df000604 	addi	fp,sp,24
 823c03c:	e13ffe15 	stw	r4,-8(fp)
 823c040:	e17fff15 	stw	r5,-4(fp)
 823c044:	e0bfff17 	ldw	r2,-4(fp)
 823c048:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823c04c:	0005303a 	rdctl	r2,status
 823c050:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823c054:	e0fffb17 	ldw	r3,-20(fp)
 823c058:	00bfff84 	movi	r2,-2
 823c05c:	1884703a 	and	r2,r3,r2
 823c060:	1001703a 	wrctl	status,r2
  
  return context;
 823c064:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 823c068:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
 823c06c:	00c00044 	movi	r3,1
 823c070:	e0bffa17 	ldw	r2,-24(fp)
 823c074:	1884983a 	sll	r2,r3,r2
 823c078:	1007883a 	mov	r3,r2
 823c07c:	d0a0b717 	ldw	r2,-32036(gp)
 823c080:	1884b03a 	or	r2,r3,r2
 823c084:	d0a0b715 	stw	r2,-32036(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 823c088:	d0a0b717 	ldw	r2,-32036(gp)
 823c08c:	100170fa 	wrctl	ienable,r2
 823c090:	e0bffc17 	ldw	r2,-16(fp)
 823c094:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823c098:	e0bffd17 	ldw	r2,-12(fp)
 823c09c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 823c0a0:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
 823c0a4:	0001883a 	nop
}
 823c0a8:	e037883a 	mov	sp,fp
 823c0ac:	df000017 	ldw	fp,0(sp)
 823c0b0:	dec00104 	addi	sp,sp,4
 823c0b4:	f800283a 	ret

0823c0b8 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 823c0b8:	defff904 	addi	sp,sp,-28
 823c0bc:	df000615 	stw	fp,24(sp)
 823c0c0:	df000604 	addi	fp,sp,24
 823c0c4:	e13ffe15 	stw	r4,-8(fp)
 823c0c8:	e17fff15 	stw	r5,-4(fp)
 823c0cc:	e0bfff17 	ldw	r2,-4(fp)
 823c0d0:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823c0d4:	0005303a 	rdctl	r2,status
 823c0d8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823c0dc:	e0fffb17 	ldw	r3,-20(fp)
 823c0e0:	00bfff84 	movi	r2,-2
 823c0e4:	1884703a 	and	r2,r3,r2
 823c0e8:	1001703a 	wrctl	status,r2
  
  return context;
 823c0ec:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 823c0f0:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
 823c0f4:	00c00044 	movi	r3,1
 823c0f8:	e0bffa17 	ldw	r2,-24(fp)
 823c0fc:	1884983a 	sll	r2,r3,r2
 823c100:	0084303a 	nor	r2,zero,r2
 823c104:	1007883a 	mov	r3,r2
 823c108:	d0a0b717 	ldw	r2,-32036(gp)
 823c10c:	1884703a 	and	r2,r3,r2
 823c110:	d0a0b715 	stw	r2,-32036(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 823c114:	d0a0b717 	ldw	r2,-32036(gp)
 823c118:	100170fa 	wrctl	ienable,r2
 823c11c:	e0bffc17 	ldw	r2,-16(fp)
 823c120:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823c124:	e0bffd17 	ldw	r2,-12(fp)
 823c128:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 823c12c:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
 823c130:	0001883a 	nop
}
 823c134:	e037883a 	mov	sp,fp
 823c138:	df000017 	ldw	fp,0(sp)
 823c13c:	dec00104 	addi	sp,sp,4
 823c140:	f800283a 	ret

0823c144 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 823c144:	defffc04 	addi	sp,sp,-16
 823c148:	df000315 	stw	fp,12(sp)
 823c14c:	df000304 	addi	fp,sp,12
 823c150:	e13ffe15 	stw	r4,-8(fp)
 823c154:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 823c158:	000530fa 	rdctl	r2,ienable
 823c15c:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 823c160:	00c00044 	movi	r3,1
 823c164:	e0bfff17 	ldw	r2,-4(fp)
 823c168:	1884983a 	sll	r2,r3,r2
 823c16c:	1007883a 	mov	r3,r2
 823c170:	e0bffd17 	ldw	r2,-12(fp)
 823c174:	1884703a 	and	r2,r3,r2
 823c178:	1004c03a 	cmpne	r2,r2,zero
 823c17c:	10803fcc 	andi	r2,r2,255
}
 823c180:	e037883a 	mov	sp,fp
 823c184:	df000017 	ldw	fp,0(sp)
 823c188:	dec00104 	addi	sp,sp,4
 823c18c:	f800283a 	ret

0823c190 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 823c190:	defff504 	addi	sp,sp,-44
 823c194:	dfc00a15 	stw	ra,40(sp)
 823c198:	df000915 	stw	fp,36(sp)
 823c19c:	df000904 	addi	fp,sp,36
 823c1a0:	e13ffc15 	stw	r4,-16(fp)
 823c1a4:	e17ffd15 	stw	r5,-12(fp)
 823c1a8:	e1bffe15 	stw	r6,-8(fp)
 823c1ac:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
 823c1b0:	00bffa84 	movi	r2,-22
 823c1b4:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 823c1b8:	e0bffd17 	ldw	r2,-12(fp)
 823c1bc:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 823c1c0:	e0bff817 	ldw	r2,-32(fp)
 823c1c4:	10800808 	cmpgei	r2,r2,32
 823c1c8:	1000271e 	bne	r2,zero,823c268 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823c1cc:	0005303a 	rdctl	r2,status
 823c1d0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823c1d4:	e0fffb17 	ldw	r3,-20(fp)
 823c1d8:	00bfff84 	movi	r2,-2
 823c1dc:	1884703a 	and	r2,r3,r2
 823c1e0:	1001703a 	wrctl	status,r2
  
  return context;
 823c1e4:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 823c1e8:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
 823c1ec:	008209b4 	movhi	r2,2086
 823c1f0:	10b9c304 	addi	r2,r2,-6388
 823c1f4:	e0fff817 	ldw	r3,-32(fp)
 823c1f8:	180690fa 	slli	r3,r3,3
 823c1fc:	10c5883a 	add	r2,r2,r3
 823c200:	e0fffe17 	ldw	r3,-8(fp)
 823c204:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
 823c208:	008209b4 	movhi	r2,2086
 823c20c:	10b9c304 	addi	r2,r2,-6388
 823c210:	e0fff817 	ldw	r3,-32(fp)
 823c214:	180690fa 	slli	r3,r3,3
 823c218:	10c5883a 	add	r2,r2,r3
 823c21c:	10800104 	addi	r2,r2,4
 823c220:	e0ffff17 	ldw	r3,-4(fp)
 823c224:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 823c228:	e0bffe17 	ldw	r2,-8(fp)
 823c22c:	10000526 	beq	r2,zero,823c244 <alt_iic_isr_register+0xb4>
 823c230:	e0bff817 	ldw	r2,-32(fp)
 823c234:	100b883a 	mov	r5,r2
 823c238:	e13ffc17 	ldw	r4,-16(fp)
 823c23c:	823c0300 	call	823c030 <alt_ic_irq_enable>
 823c240:	00000406 	br	823c254 <alt_iic_isr_register+0xc4>
 823c244:	e0bff817 	ldw	r2,-32(fp)
 823c248:	100b883a 	mov	r5,r2
 823c24c:	e13ffc17 	ldw	r4,-16(fp)
 823c250:	823c0b80 	call	823c0b8 <alt_ic_irq_disable>
 823c254:	e0bff715 	stw	r2,-36(fp)
 823c258:	e0bffa17 	ldw	r2,-24(fp)
 823c25c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823c260:	e0bff917 	ldw	r2,-28(fp)
 823c264:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 823c268:	e0bff717 	ldw	r2,-36(fp)
}
 823c26c:	e037883a 	mov	sp,fp
 823c270:	dfc00117 	ldw	ra,4(sp)
 823c274:	df000017 	ldw	fp,0(sp)
 823c278:	dec00204 	addi	sp,sp,8
 823c27c:	f800283a 	ret

0823c280 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 823c280:	defff904 	addi	sp,sp,-28
 823c284:	dfc00615 	stw	ra,24(sp)
 823c288:	df000515 	stw	fp,20(sp)
 823c28c:	df000504 	addi	fp,sp,20
 823c290:	e13ffc15 	stw	r4,-16(fp)
 823c294:	e17ffd15 	stw	r5,-12(fp)
 823c298:	e1bffe15 	stw	r6,-8(fp)
 823c29c:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 823c2a0:	e1bfff17 	ldw	r6,-4(fp)
 823c2a4:	e17ffe17 	ldw	r5,-8(fp)
 823c2a8:	e13ffd17 	ldw	r4,-12(fp)
 823c2ac:	823c4c00 	call	823c4c0 <open>
 823c2b0:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 823c2b4:	e0bffb17 	ldw	r2,-20(fp)
 823c2b8:	10001c16 	blt	r2,zero,823c32c <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
 823c2bc:	00820974 	movhi	r2,2085
 823c2c0:	108ed304 	addi	r2,r2,15180
 823c2c4:	e0fffb17 	ldw	r3,-20(fp)
 823c2c8:	18c00324 	muli	r3,r3,12
 823c2cc:	10c5883a 	add	r2,r2,r3
 823c2d0:	10c00017 	ldw	r3,0(r2)
 823c2d4:	e0bffc17 	ldw	r2,-16(fp)
 823c2d8:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 823c2dc:	00820974 	movhi	r2,2085
 823c2e0:	108ed304 	addi	r2,r2,15180
 823c2e4:	e0fffb17 	ldw	r3,-20(fp)
 823c2e8:	18c00324 	muli	r3,r3,12
 823c2ec:	10c5883a 	add	r2,r2,r3
 823c2f0:	10800104 	addi	r2,r2,4
 823c2f4:	10c00017 	ldw	r3,0(r2)
 823c2f8:	e0bffc17 	ldw	r2,-16(fp)
 823c2fc:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 823c300:	00820974 	movhi	r2,2085
 823c304:	108ed304 	addi	r2,r2,15180
 823c308:	e0fffb17 	ldw	r3,-20(fp)
 823c30c:	18c00324 	muli	r3,r3,12
 823c310:	10c5883a 	add	r2,r2,r3
 823c314:	10800204 	addi	r2,r2,8
 823c318:	10c00017 	ldw	r3,0(r2)
 823c31c:	e0bffc17 	ldw	r2,-16(fp)
 823c320:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 823c324:	e13ffb17 	ldw	r4,-20(fp)
 823c328:	823c74c0 	call	823c74c <alt_release_fd>
  }
} 
 823c32c:	0001883a 	nop
 823c330:	e037883a 	mov	sp,fp
 823c334:	dfc00117 	ldw	ra,4(sp)
 823c338:	df000017 	ldw	fp,0(sp)
 823c33c:	dec00204 	addi	sp,sp,8
 823c340:	f800283a 	ret

0823c344 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 823c344:	defffb04 	addi	sp,sp,-20
 823c348:	dfc00415 	stw	ra,16(sp)
 823c34c:	df000315 	stw	fp,12(sp)
 823c350:	df000304 	addi	fp,sp,12
 823c354:	e13ffd15 	stw	r4,-12(fp)
 823c358:	e17ffe15 	stw	r5,-8(fp)
 823c35c:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 823c360:	01c07fc4 	movi	r7,511
 823c364:	01800044 	movi	r6,1
 823c368:	e17ffd17 	ldw	r5,-12(fp)
 823c36c:	01020974 	movhi	r4,2085
 823c370:	210ed604 	addi	r4,r4,15192
 823c374:	823c2800 	call	823c280 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 823c378:	01c07fc4 	movi	r7,511
 823c37c:	000d883a 	mov	r6,zero
 823c380:	e17ffe17 	ldw	r5,-8(fp)
 823c384:	01020974 	movhi	r4,2085
 823c388:	210ed304 	addi	r4,r4,15180
 823c38c:	823c2800 	call	823c280 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 823c390:	01c07fc4 	movi	r7,511
 823c394:	01800044 	movi	r6,1
 823c398:	e17fff17 	ldw	r5,-4(fp)
 823c39c:	01020974 	movhi	r4,2085
 823c3a0:	210ed904 	addi	r4,r4,15204
 823c3a4:	823c2800 	call	823c280 <alt_open_fd>
}  
 823c3a8:	0001883a 	nop
 823c3ac:	e037883a 	mov	sp,fp
 823c3b0:	dfc00117 	ldw	ra,4(sp)
 823c3b4:	df000017 	ldw	fp,0(sp)
 823c3b8:	dec00204 	addi	sp,sp,8
 823c3bc:	f800283a 	ret

0823c3c0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823c3c0:	defffe04 	addi	sp,sp,-8
 823c3c4:	dfc00115 	stw	ra,4(sp)
 823c3c8:	df000015 	stw	fp,0(sp)
 823c3cc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823c3d0:	d0a04717 	ldw	r2,-32484(gp)
 823c3d4:	10000326 	beq	r2,zero,823c3e4 <alt_get_errno+0x24>
 823c3d8:	d0a04717 	ldw	r2,-32484(gp)
 823c3dc:	103ee83a 	callr	r2
 823c3e0:	00000106 	br	823c3e8 <alt_get_errno+0x28>
 823c3e4:	d0a06304 	addi	r2,gp,-32372
}
 823c3e8:	e037883a 	mov	sp,fp
 823c3ec:	dfc00117 	ldw	ra,4(sp)
 823c3f0:	df000017 	ldw	fp,0(sp)
 823c3f4:	dec00204 	addi	sp,sp,8
 823c3f8:	f800283a 	ret

0823c3fc <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 823c3fc:	defffd04 	addi	sp,sp,-12
 823c400:	df000215 	stw	fp,8(sp)
 823c404:	df000204 	addi	fp,sp,8
 823c408:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 823c40c:	e0bfff17 	ldw	r2,-4(fp)
 823c410:	10800217 	ldw	r2,8(r2)
 823c414:	10d00034 	orhi	r3,r2,16384
 823c418:	e0bfff17 	ldw	r2,-4(fp)
 823c41c:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 823c420:	e03ffe15 	stw	zero,-8(fp)
 823c424:	00001d06 	br	823c49c <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 823c428:	00820974 	movhi	r2,2085
 823c42c:	108ed304 	addi	r2,r2,15180
 823c430:	e0fffe17 	ldw	r3,-8(fp)
 823c434:	18c00324 	muli	r3,r3,12
 823c438:	10c5883a 	add	r2,r2,r3
 823c43c:	10c00017 	ldw	r3,0(r2)
 823c440:	e0bfff17 	ldw	r2,-4(fp)
 823c444:	10800017 	ldw	r2,0(r2)
 823c448:	1880111e 	bne	r3,r2,823c490 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 823c44c:	00820974 	movhi	r2,2085
 823c450:	108ed304 	addi	r2,r2,15180
 823c454:	e0fffe17 	ldw	r3,-8(fp)
 823c458:	18c00324 	muli	r3,r3,12
 823c45c:	10c5883a 	add	r2,r2,r3
 823c460:	10800204 	addi	r2,r2,8
 823c464:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 823c468:	1000090e 	bge	r2,zero,823c490 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
 823c46c:	e0bffe17 	ldw	r2,-8(fp)
 823c470:	10c00324 	muli	r3,r2,12
 823c474:	00820974 	movhi	r2,2085
 823c478:	108ed304 	addi	r2,r2,15180
 823c47c:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 823c480:	e0bfff17 	ldw	r2,-4(fp)
 823c484:	18800226 	beq	r3,r2,823c490 <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 823c488:	00bffcc4 	movi	r2,-13
 823c48c:	00000806 	br	823c4b0 <alt_file_locked+0xb4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 823c490:	e0bffe17 	ldw	r2,-8(fp)
 823c494:	10800044 	addi	r2,r2,1
 823c498:	e0bffe15 	stw	r2,-8(fp)
 823c49c:	d0a04617 	ldw	r2,-32488(gp)
 823c4a0:	1007883a 	mov	r3,r2
 823c4a4:	e0bffe17 	ldw	r2,-8(fp)
 823c4a8:	18bfdf2e 	bgeu	r3,r2,823c428 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 823c4ac:	0005883a 	mov	r2,zero
}
 823c4b0:	e037883a 	mov	sp,fp
 823c4b4:	df000017 	ldw	fp,0(sp)
 823c4b8:	dec00104 	addi	sp,sp,4
 823c4bc:	f800283a 	ret

0823c4c0 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 823c4c0:	defff604 	addi	sp,sp,-40
 823c4c4:	dfc00915 	stw	ra,36(sp)
 823c4c8:	df000815 	stw	fp,32(sp)
 823c4cc:	df000804 	addi	fp,sp,32
 823c4d0:	e13ffd15 	stw	r4,-12(fp)
 823c4d4:	e17ffe15 	stw	r5,-8(fp)
 823c4d8:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 823c4dc:	00bfffc4 	movi	r2,-1
 823c4e0:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
 823c4e4:	00bffb44 	movi	r2,-19
 823c4e8:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
 823c4ec:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 823c4f0:	d1604404 	addi	r5,gp,-32496
 823c4f4:	e13ffd17 	ldw	r4,-12(fp)
 823c4f8:	823bf500 	call	823bf50 <alt_find_dev>
 823c4fc:	e0bff815 	stw	r2,-32(fp)
 823c500:	e0bff817 	ldw	r2,-32(fp)
 823c504:	1000051e 	bne	r2,zero,823c51c <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 823c508:	e13ffd17 	ldw	r4,-12(fp)
 823c50c:	824a27c0 	call	824a27c <alt_find_file>
 823c510:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
 823c514:	00800044 	movi	r2,1
 823c518:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 823c51c:	e0bff817 	ldw	r2,-32(fp)
 823c520:	10002926 	beq	r2,zero,823c5c8 <open+0x108>
  {
    if ((index = alt_get_fd (dev)) < 0)
 823c524:	e13ff817 	ldw	r4,-32(fp)
 823c528:	824a3840 	call	824a384 <alt_get_fd>
 823c52c:	e0bff915 	stw	r2,-28(fp)
 823c530:	e0bff917 	ldw	r2,-28(fp)
 823c534:	1000030e 	bge	r2,zero,823c544 <open+0x84>
    {
      status = index;
 823c538:	e0bff917 	ldw	r2,-28(fp)
 823c53c:	e0bffa15 	stw	r2,-24(fp)
 823c540:	00002306 	br	823c5d0 <open+0x110>
    }
    else
    {
      fd = &alt_fd_list[index];
 823c544:	e0bff917 	ldw	r2,-28(fp)
 823c548:	10c00324 	muli	r3,r2,12
 823c54c:	00820974 	movhi	r2,2085
 823c550:	108ed304 	addi	r2,r2,15180
 823c554:	1885883a 	add	r2,r3,r2
 823c558:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 823c55c:	e0fffe17 	ldw	r3,-8(fp)
 823c560:	00900034 	movhi	r2,16384
 823c564:	10bfffc4 	addi	r2,r2,-1
 823c568:	1886703a 	and	r3,r3,r2
 823c56c:	e0bffc17 	ldw	r2,-16(fp)
 823c570:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 823c574:	e0bffb17 	ldw	r2,-20(fp)
 823c578:	1000051e 	bne	r2,zero,823c590 <open+0xd0>
 823c57c:	e13ffc17 	ldw	r4,-16(fp)
 823c580:	823c3fc0 	call	823c3fc <alt_file_locked>
 823c584:	e0bffa15 	stw	r2,-24(fp)
 823c588:	e0bffa17 	ldw	r2,-24(fp)
 823c58c:	10001016 	blt	r2,zero,823c5d0 <open+0x110>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 823c590:	e0bff817 	ldw	r2,-32(fp)
 823c594:	10800317 	ldw	r2,12(r2)
 823c598:	10000826 	beq	r2,zero,823c5bc <open+0xfc>
 823c59c:	e0bff817 	ldw	r2,-32(fp)
 823c5a0:	10800317 	ldw	r2,12(r2)
 823c5a4:	e1ffff17 	ldw	r7,-4(fp)
 823c5a8:	e1bffe17 	ldw	r6,-8(fp)
 823c5ac:	e17ffd17 	ldw	r5,-12(fp)
 823c5b0:	e13ffc17 	ldw	r4,-16(fp)
 823c5b4:	103ee83a 	callr	r2
 823c5b8:	00000106 	br	823c5c0 <open+0x100>
 823c5bc:	0005883a 	mov	r2,zero
 823c5c0:	e0bffa15 	stw	r2,-24(fp)
 823c5c4:	00000206 	br	823c5d0 <open+0x110>
      }
    }
  }
  else
  {
    status = -ENODEV;
 823c5c8:	00bffb44 	movi	r2,-19
 823c5cc:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 823c5d0:	e0bffa17 	ldw	r2,-24(fp)
 823c5d4:	1000090e 	bge	r2,zero,823c5fc <open+0x13c>
  {
    alt_release_fd (index);  
 823c5d8:	e13ff917 	ldw	r4,-28(fp)
 823c5dc:	823c74c0 	call	823c74c <alt_release_fd>
    ALT_ERRNO = -status;
 823c5e0:	823c3c00 	call	823c3c0 <alt_get_errno>
 823c5e4:	1007883a 	mov	r3,r2
 823c5e8:	e0bffa17 	ldw	r2,-24(fp)
 823c5ec:	0085c83a 	sub	r2,zero,r2
 823c5f0:	18800015 	stw	r2,0(r3)
    return -1;
 823c5f4:	00bfffc4 	movi	r2,-1
 823c5f8:	00000106 	br	823c600 <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
 823c5fc:	e0bff917 	ldw	r2,-28(fp)
}
 823c600:	e037883a 	mov	sp,fp
 823c604:	dfc00117 	ldw	ra,4(sp)
 823c608:	df000017 	ldw	fp,0(sp)
 823c60c:	dec00204 	addi	sp,sp,8
 823c610:	f800283a 	ret

0823c614 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823c614:	defffe04 	addi	sp,sp,-8
 823c618:	dfc00115 	stw	ra,4(sp)
 823c61c:	df000015 	stw	fp,0(sp)
 823c620:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823c624:	d0a04717 	ldw	r2,-32484(gp)
 823c628:	10000326 	beq	r2,zero,823c638 <alt_get_errno+0x24>
 823c62c:	d0a04717 	ldw	r2,-32484(gp)
 823c630:	103ee83a 	callr	r2
 823c634:	00000106 	br	823c63c <alt_get_errno+0x28>
 823c638:	d0a06304 	addi	r2,gp,-32372
}
 823c63c:	e037883a 	mov	sp,fp
 823c640:	dfc00117 	ldw	ra,4(sp)
 823c644:	df000017 	ldw	fp,0(sp)
 823c648:	dec00204 	addi	sp,sp,8
 823c64c:	f800283a 	ret

0823c650 <alt_read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 823c650:	defff904 	addi	sp,sp,-28
 823c654:	dfc00615 	stw	ra,24(sp)
 823c658:	df000515 	stw	fp,20(sp)
 823c65c:	df000504 	addi	fp,sp,20
 823c660:	e13ffd15 	stw	r4,-12(fp)
 823c664:	e17ffe15 	stw	r5,-8(fp)
 823c668:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 823c66c:	e0bffd17 	ldw	r2,-12(fp)
 823c670:	10000616 	blt	r2,zero,823c68c <alt_read+0x3c>
 823c674:	e0bffd17 	ldw	r2,-12(fp)
 823c678:	10c00324 	muli	r3,r2,12
 823c67c:	00820974 	movhi	r2,2085
 823c680:	108ed304 	addi	r2,r2,15180
 823c684:	1885883a 	add	r2,r3,r2
 823c688:	00000106 	br	823c690 <alt_read+0x40>
 823c68c:	0005883a 	mov	r2,zero
 823c690:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 823c694:	e0bffb17 	ldw	r2,-20(fp)
 823c698:	10002226 	beq	r2,zero,823c724 <alt_read+0xd4>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 823c69c:	e0bffb17 	ldw	r2,-20(fp)
 823c6a0:	10800217 	ldw	r2,8(r2)
 823c6a4:	108000cc 	andi	r2,r2,3
 823c6a8:	10800060 	cmpeqi	r2,r2,1
 823c6ac:	1000181e 	bne	r2,zero,823c710 <alt_read+0xc0>
        (fd->dev->read))
 823c6b0:	e0bffb17 	ldw	r2,-20(fp)
 823c6b4:	10800017 	ldw	r2,0(r2)
 823c6b8:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 823c6bc:	10001426 	beq	r2,zero,823c710 <alt_read+0xc0>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 823c6c0:	e0bffb17 	ldw	r2,-20(fp)
 823c6c4:	10800017 	ldw	r2,0(r2)
 823c6c8:	10800517 	ldw	r2,20(r2)
 823c6cc:	e0ffff17 	ldw	r3,-4(fp)
 823c6d0:	180d883a 	mov	r6,r3
 823c6d4:	e17ffe17 	ldw	r5,-8(fp)
 823c6d8:	e13ffb17 	ldw	r4,-20(fp)
 823c6dc:	103ee83a 	callr	r2
 823c6e0:	e0bffc15 	stw	r2,-16(fp)
 823c6e4:	e0bffc17 	ldw	r2,-16(fp)
 823c6e8:	1000070e 	bge	r2,zero,823c708 <alt_read+0xb8>
        {
          ALT_ERRNO = -rval;
 823c6ec:	823c6140 	call	823c614 <alt_get_errno>
 823c6f0:	1007883a 	mov	r3,r2
 823c6f4:	e0bffc17 	ldw	r2,-16(fp)
 823c6f8:	0085c83a 	sub	r2,zero,r2
 823c6fc:	18800015 	stw	r2,0(r3)
          return -1;
 823c700:	00bfffc4 	movi	r2,-1
 823c704:	00000c06 	br	823c738 <alt_read+0xe8>
        }
        return rval;
 823c708:	e0bffc17 	ldw	r2,-16(fp)
 823c70c:	00000a06 	br	823c738 <alt_read+0xe8>
      }
      else
      {
        ALT_ERRNO = EACCES;
 823c710:	823c6140 	call	823c614 <alt_get_errno>
 823c714:	1007883a 	mov	r3,r2
 823c718:	00800344 	movi	r2,13
 823c71c:	18800015 	stw	r2,0(r3)
 823c720:	00000406 	br	823c734 <alt_read+0xe4>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 823c724:	823c6140 	call	823c614 <alt_get_errno>
 823c728:	1007883a 	mov	r3,r2
 823c72c:	00801444 	movi	r2,81
 823c730:	18800015 	stw	r2,0(r3)
  }
  return -1;
 823c734:	00bfffc4 	movi	r2,-1
}
 823c738:	e037883a 	mov	sp,fp
 823c73c:	dfc00117 	ldw	ra,4(sp)
 823c740:	df000017 	ldw	fp,0(sp)
 823c744:	dec00204 	addi	sp,sp,8
 823c748:	f800283a 	ret

0823c74c <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 823c74c:	defffe04 	addi	sp,sp,-8
 823c750:	df000115 	stw	fp,4(sp)
 823c754:	df000104 	addi	fp,sp,4
 823c758:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 823c75c:	e0bfff17 	ldw	r2,-4(fp)
 823c760:	108000d0 	cmplti	r2,r2,3
 823c764:	10000d1e 	bne	r2,zero,823c79c <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 823c768:	00820974 	movhi	r2,2085
 823c76c:	108ed304 	addi	r2,r2,15180
 823c770:	e0ffff17 	ldw	r3,-4(fp)
 823c774:	18c00324 	muli	r3,r3,12
 823c778:	10c5883a 	add	r2,r2,r3
 823c77c:	10800204 	addi	r2,r2,8
 823c780:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 823c784:	00820974 	movhi	r2,2085
 823c788:	108ed304 	addi	r2,r2,15180
 823c78c:	e0ffff17 	ldw	r3,-4(fp)
 823c790:	18c00324 	muli	r3,r3,12
 823c794:	10c5883a 	add	r2,r2,r3
 823c798:	10000015 	stw	zero,0(r2)
  }
}
 823c79c:	0001883a 	nop
 823c7a0:	e037883a 	mov	sp,fp
 823c7a4:	df000017 	ldw	fp,0(sp)
 823c7a8:	dec00104 	addi	sp,sp,4
 823c7ac:	f800283a 	ret

0823c7b0 <alt_remap_cached>:
 * Convert a pointer to a block of uncached memory, into a block of
 * cached memory.
 */

void* alt_remap_cached (volatile void* ptr, alt_u32 len)
{
 823c7b0:	defffd04 	addi	sp,sp,-12
 823c7b4:	df000215 	stw	fp,8(sp)
 823c7b8:	df000204 	addi	fp,sp,8
 823c7bc:	e13ffe15 	stw	r4,-8(fp)
 823c7c0:	e17fff15 	stw	r5,-4(fp)
  return (void*) (((alt_u32) ptr) & ~BYPASS_DCACHE_MASK);
 823c7c4:	e0fffe17 	ldw	r3,-8(fp)
 823c7c8:	00a00034 	movhi	r2,32768
 823c7cc:	10bfffc4 	addi	r2,r2,-1
 823c7d0:	1884703a 	and	r2,r3,r2
}
 823c7d4:	e037883a 	mov	sp,fp
 823c7d8:	df000017 	ldw	fp,0(sp)
 823c7dc:	dec00104 	addi	sp,sp,4
 823c7e0:	f800283a 	ret

0823c7e4 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 823c7e4:	defffa04 	addi	sp,sp,-24
 823c7e8:	df000515 	stw	fp,20(sp)
 823c7ec:	df000504 	addi	fp,sp,20
 823c7f0:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823c7f4:	0005303a 	rdctl	r2,status
 823c7f8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823c7fc:	e0fffc17 	ldw	r3,-16(fp)
 823c800:	00bfff84 	movi	r2,-2
 823c804:	1884703a 	and	r2,r3,r2
 823c808:	1001703a 	wrctl	status,r2
  
  return context;
 823c80c:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 823c810:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
 823c814:	e0bfff17 	ldw	r2,-4(fp)
 823c818:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 823c81c:	e0bffd17 	ldw	r2,-12(fp)
 823c820:	10800017 	ldw	r2,0(r2)
 823c824:	e0fffd17 	ldw	r3,-12(fp)
 823c828:	18c00117 	ldw	r3,4(r3)
 823c82c:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 823c830:	e0bffd17 	ldw	r2,-12(fp)
 823c834:	10800117 	ldw	r2,4(r2)
 823c838:	e0fffd17 	ldw	r3,-12(fp)
 823c83c:	18c00017 	ldw	r3,0(r3)
 823c840:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 823c844:	e0bffd17 	ldw	r2,-12(fp)
 823c848:	e0fffd17 	ldw	r3,-12(fp)
 823c84c:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 823c850:	e0bffd17 	ldw	r2,-12(fp)
 823c854:	e0fffd17 	ldw	r3,-12(fp)
 823c858:	10c00015 	stw	r3,0(r2)
 823c85c:	e0bffb17 	ldw	r2,-20(fp)
 823c860:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823c864:	e0bffe17 	ldw	r2,-8(fp)
 823c868:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 823c86c:	0001883a 	nop
 823c870:	e037883a 	mov	sp,fp
 823c874:	df000017 	ldw	fp,0(sp)
 823c878:	dec00104 	addi	sp,sp,4
 823c87c:	f800283a 	ret

0823c880 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 823c880:	defffb04 	addi	sp,sp,-20
 823c884:	dfc00415 	stw	ra,16(sp)
 823c888:	df000315 	stw	fp,12(sp)
 823c88c:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 823c890:	d0a04917 	ldw	r2,-32476(gp)
 823c894:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 823c898:	d0a0b917 	ldw	r2,-32028(gp)
 823c89c:	10800044 	addi	r2,r2,1
 823c8a0:	d0a0b915 	stw	r2,-32028(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 823c8a4:	00002e06 	br	823c960 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 823c8a8:	e0bffd17 	ldw	r2,-12(fp)
 823c8ac:	10800017 	ldw	r2,0(r2)
 823c8b0:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 823c8b4:	e0bffd17 	ldw	r2,-12(fp)
 823c8b8:	10800403 	ldbu	r2,16(r2)
 823c8bc:	10803fcc 	andi	r2,r2,255
 823c8c0:	10000426 	beq	r2,zero,823c8d4 <alt_tick+0x54>
 823c8c4:	d0a0b917 	ldw	r2,-32028(gp)
 823c8c8:	1000021e 	bne	r2,zero,823c8d4 <alt_tick+0x54>
    {
      alarm->rollover = 0;
 823c8cc:	e0bffd17 	ldw	r2,-12(fp)
 823c8d0:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 823c8d4:	e0bffd17 	ldw	r2,-12(fp)
 823c8d8:	10800217 	ldw	r2,8(r2)
 823c8dc:	d0e0b917 	ldw	r3,-32028(gp)
 823c8e0:	18801d36 	bltu	r3,r2,823c958 <alt_tick+0xd8>
 823c8e4:	e0bffd17 	ldw	r2,-12(fp)
 823c8e8:	10800403 	ldbu	r2,16(r2)
 823c8ec:	10803fcc 	andi	r2,r2,255
 823c8f0:	1000191e 	bne	r2,zero,823c958 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 823c8f4:	e0bffd17 	ldw	r2,-12(fp)
 823c8f8:	10800317 	ldw	r2,12(r2)
 823c8fc:	e0fffd17 	ldw	r3,-12(fp)
 823c900:	18c00517 	ldw	r3,20(r3)
 823c904:	1809883a 	mov	r4,r3
 823c908:	103ee83a 	callr	r2
 823c90c:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 823c910:	e0bfff17 	ldw	r2,-4(fp)
 823c914:	1000031e 	bne	r2,zero,823c924 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 823c918:	e13ffd17 	ldw	r4,-12(fp)
 823c91c:	823c7e40 	call	823c7e4 <alt_alarm_stop>
 823c920:	00000d06 	br	823c958 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 823c924:	e0bffd17 	ldw	r2,-12(fp)
 823c928:	10c00217 	ldw	r3,8(r2)
 823c92c:	e0bfff17 	ldw	r2,-4(fp)
 823c930:	1887883a 	add	r3,r3,r2
 823c934:	e0bffd17 	ldw	r2,-12(fp)
 823c938:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 823c93c:	e0bffd17 	ldw	r2,-12(fp)
 823c940:	10c00217 	ldw	r3,8(r2)
 823c944:	d0a0b917 	ldw	r2,-32028(gp)
 823c948:	1880032e 	bgeu	r3,r2,823c958 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 823c94c:	e0bffd17 	ldw	r2,-12(fp)
 823c950:	00c00044 	movi	r3,1
 823c954:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 823c958:	e0bffe17 	ldw	r2,-8(fp)
 823c95c:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 823c960:	e0fffd17 	ldw	r3,-12(fp)
 823c964:	d0a04904 	addi	r2,gp,-32476
 823c968:	18bfcf1e 	bne	r3,r2,823c8a8 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 823c96c:	82158780 	call	8215878 <OSTimeTick>
}
 823c970:	0001883a 	nop
 823c974:	e037883a 	mov	sp,fp
 823c978:	dfc00117 	ldw	ra,4(sp)
 823c97c:	df000017 	ldw	fp,0(sp)
 823c980:	dec00204 	addi	sp,sp,8
 823c984:	f800283a 	ret

0823c988 <alt_uncached_free>:
/*
 * Free a block of uncached memory.
 */

void alt_uncached_free (volatile void* ptr)
{
 823c988:	defffd04 	addi	sp,sp,-12
 823c98c:	dfc00215 	stw	ra,8(sp)
 823c990:	df000115 	stw	fp,4(sp)
 823c994:	df000104 	addi	fp,sp,4
 823c998:	e13fff15 	stw	r4,-4(fp)
  free ((void*) (((alt_u32) ptr) & ~BYPASS_DCACHE_MASK));
 823c99c:	e0ffff17 	ldw	r3,-4(fp)
 823c9a0:	00a00034 	movhi	r2,32768
 823c9a4:	10bfffc4 	addi	r2,r2,-1
 823c9a8:	1884703a 	and	r2,r3,r2
 823c9ac:	1009883a 	mov	r4,r2
 823c9b0:	824b6a40 	call	824b6a4 <free>
}
 823c9b4:	0001883a 	nop
 823c9b8:	e037883a 	mov	sp,fp
 823c9bc:	dfc00117 	ldw	ra,4(sp)
 823c9c0:	df000017 	ldw	fp,0(sp)
 823c9c4:	dec00204 	addi	sp,sp,8
 823c9c8:	f800283a 	ret

0823c9cc <alt_uncached_malloc>:
/*
 * Allocate a block of uncached memory.
 */

volatile void* alt_uncached_malloc (size_t size)
{
 823c9cc:	defffc04 	addi	sp,sp,-16
 823c9d0:	dfc00315 	stw	ra,12(sp)
 823c9d4:	df000215 	stw	fp,8(sp)
 823c9d8:	df000204 	addi	fp,sp,8
 823c9dc:	e13fff15 	stw	r4,-4(fp)
  void* ptr;

  ptr = malloc (size);
 823c9e0:	e13fff17 	ldw	r4,-4(fp)
 823c9e4:	824b6900 	call	824b690 <malloc>
 823c9e8:	e0bffe15 	stw	r2,-8(fp)

  alt_dcache_flush (ptr, size);
 823c9ec:	e17fff17 	ldw	r5,-4(fp)
 823c9f0:	e13ffe17 	ldw	r4,-8(fp)
 823c9f4:	823bd0c0 	call	823bd0c <alt_dcache_flush>

  return ptr ? (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK) : NULL;
 823c9f8:	e0bffe17 	ldw	r2,-8(fp)
 823c9fc:	10000326 	beq	r2,zero,823ca0c <alt_uncached_malloc+0x40>
 823ca00:	e0bffe17 	ldw	r2,-8(fp)
 823ca04:	10a00034 	orhi	r2,r2,32768
 823ca08:	00000106 	br	823ca10 <alt_uncached_malloc+0x44>
 823ca0c:	0005883a 	mov	r2,zero
}
 823ca10:	e037883a 	mov	sp,fp
 823ca14:	dfc00117 	ldw	ra,4(sp)
 823ca18:	df000017 	ldw	fp,0(sp)
 823ca1c:	dec00204 	addi	sp,sp,8
 823ca20:	f800283a 	ret

0823ca24 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 823ca24:	defffb04 	addi	sp,sp,-20
 823ca28:	dfc00415 	stw	ra,16(sp)
 823ca2c:	df000315 	stw	fp,12(sp)
 823ca30:	df000304 	addi	fp,sp,12
 823ca34:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
 823ca38:	d0a06b43 	ldbu	r2,-32339(gp)
 823ca3c:	10803fcc 	andi	r2,r2,255
 823ca40:	1000031e 	bne	r2,zero,823ca50 <usleep+0x2c>
  {
    return alt_busy_sleep (us);
 823ca44:	e13fff17 	ldw	r4,-4(fp)
 823ca48:	8249fc80 	call	8249fc8 <alt_busy_sleep>
 823ca4c:	00003e06 	br	823cb48 <usleep+0x124>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 823ca50:	d0a0b817 	ldw	r2,-32032(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
 823ca54:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
 823ca58:	e0ffff17 	ldw	r3,-4(fp)
 823ca5c:	0090c734 	movhi	r2,17180
 823ca60:	10b7a0c4 	addi	r2,r2,-8573
 823ca64:	1888383a 	mulxuu	r4,r3,r2
 823ca68:	1885383a 	mul	r2,r3,r2
 823ca6c:	1013883a 	mov	r9,r2
 823ca70:	2015883a 	mov	r10,r4
 823ca74:	5006d4ba 	srli	r3,r10,18
 823ca78:	e0bffe17 	ldw	r2,-8(fp)
 823ca7c:	1893383a 	mul	r9,r3,r2
 823ca80:	e0ffff17 	ldw	r3,-4(fp)
 823ca84:	0090c734 	movhi	r2,17180
 823ca88:	10b7a0c4 	addi	r2,r2,-8573
 823ca8c:	1888383a 	mulxuu	r4,r3,r2
 823ca90:	1885383a 	mul	r2,r3,r2
 823ca94:	100f883a 	mov	r7,r2
 823ca98:	2011883a 	mov	r8,r4
 823ca9c:	4004d4ba 	srli	r2,r8,18
 823caa0:	010003f4 	movhi	r4,15
 823caa4:	21109004 	addi	r4,r4,16960
 823caa8:	1105383a 	mul	r2,r2,r4
 823caac:	1885c83a 	sub	r2,r3,r2
 823cab0:	e0fffe17 	ldw	r3,-8(fp)
 823cab4:	10c7383a 	mul	r3,r2,r3
 823cab8:	0090c734 	movhi	r2,17180
 823cabc:	10b7a0c4 	addi	r2,r2,-8573
 823cac0:	1888383a 	mulxuu	r4,r3,r2
 823cac4:	1885383a 	mul	r2,r3,r2
 823cac8:	100b883a 	mov	r5,r2
 823cacc:	200d883a 	mov	r6,r4
 823cad0:	3004d4ba 	srli	r2,r6,18
 823cad4:	4885883a 	add	r2,r9,r2
 823cad8:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 823cadc:	00000706 	br	823cafc <usleep+0xd8>
  {
    OSTimeDly(0xffff);
 823cae0:	013fffd4 	movui	r4,65535
 823cae4:	821bed80 	call	821bed8 <OSTimeDly>
    ticks -= 0xffff;
 823cae8:	e0fffd17 	ldw	r3,-12(fp)
 823caec:	00bffff4 	movhi	r2,65535
 823caf0:	10800044 	addi	r2,r2,1
 823caf4:	1885883a 	add	r2,r3,r2
 823caf8:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 823cafc:	e0bffd17 	ldw	r2,-12(fp)
 823cb00:	00ffffd4 	movui	r3,65535
 823cb04:	18bff636 	bltu	r3,r2,823cae0 <usleep+0xbc>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
 823cb08:	e0bffd17 	ldw	r2,-12(fp)
 823cb0c:	10bfffcc 	andi	r2,r2,65535
 823cb10:	1009883a 	mov	r4,r2
 823cb14:	821bed80 	call	821bed8 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
 823cb18:	e17ffe17 	ldw	r5,-8(fp)
 823cb1c:	010003f4 	movhi	r4,15
 823cb20:	21109004 	addi	r4,r4,16960
 823cb24:	8202c100 	call	8202c10 <__udivsi3>
 823cb28:	1007883a 	mov	r3,r2
 823cb2c:	e0bfff17 	ldw	r2,-4(fp)
 823cb30:	180b883a 	mov	r5,r3
 823cb34:	1009883a 	mov	r4,r2
 823cb38:	8202c740 	call	8202c74 <__umodsi3>
 823cb3c:	1009883a 	mov	r4,r2
 823cb40:	8249fc80 	call	8249fc8 <alt_busy_sleep>

  return 0;  
 823cb44:	0005883a 	mov	r2,zero
}
 823cb48:	e037883a 	mov	sp,fp
 823cb4c:	dfc00117 	ldw	ra,4(sp)
 823cb50:	df000017 	ldw	fp,0(sp)
 823cb54:	dec00204 	addi	sp,sp,8
 823cb58:	f800283a 	ret

0823cb5c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823cb5c:	defffe04 	addi	sp,sp,-8
 823cb60:	dfc00115 	stw	ra,4(sp)
 823cb64:	df000015 	stw	fp,0(sp)
 823cb68:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823cb6c:	d0a04717 	ldw	r2,-32484(gp)
 823cb70:	10000326 	beq	r2,zero,823cb80 <alt_get_errno+0x24>
 823cb74:	d0a04717 	ldw	r2,-32484(gp)
 823cb78:	103ee83a 	callr	r2
 823cb7c:	00000106 	br	823cb84 <alt_get_errno+0x28>
 823cb80:	d0a06304 	addi	r2,gp,-32372
}
 823cb84:	e037883a 	mov	sp,fp
 823cb88:	dfc00117 	ldw	ra,4(sp)
 823cb8c:	df000017 	ldw	fp,0(sp)
 823cb90:	dec00204 	addi	sp,sp,8
 823cb94:	f800283a 	ret

0823cb98 <alt_write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 823cb98:	defff904 	addi	sp,sp,-28
 823cb9c:	dfc00615 	stw	ra,24(sp)
 823cba0:	df000515 	stw	fp,20(sp)
 823cba4:	df000504 	addi	fp,sp,20
 823cba8:	e13ffd15 	stw	r4,-12(fp)
 823cbac:	e17ffe15 	stw	r5,-8(fp)
 823cbb0:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 823cbb4:	e0bffd17 	ldw	r2,-12(fp)
 823cbb8:	10000616 	blt	r2,zero,823cbd4 <alt_write+0x3c>
 823cbbc:	e0bffd17 	ldw	r2,-12(fp)
 823cbc0:	10c00324 	muli	r3,r2,12
 823cbc4:	00820974 	movhi	r2,2085
 823cbc8:	108ed304 	addi	r2,r2,15180
 823cbcc:	1885883a 	add	r2,r3,r2
 823cbd0:	00000106 	br	823cbd8 <alt_write+0x40>
 823cbd4:	0005883a 	mov	r2,zero
 823cbd8:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 823cbdc:	e0bffb17 	ldw	r2,-20(fp)
 823cbe0:	10002126 	beq	r2,zero,823cc68 <alt_write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 823cbe4:	e0bffb17 	ldw	r2,-20(fp)
 823cbe8:	10800217 	ldw	r2,8(r2)
 823cbec:	108000cc 	andi	r2,r2,3
 823cbf0:	10001826 	beq	r2,zero,823cc54 <alt_write+0xbc>
 823cbf4:	e0bffb17 	ldw	r2,-20(fp)
 823cbf8:	10800017 	ldw	r2,0(r2)
 823cbfc:	10800617 	ldw	r2,24(r2)
 823cc00:	10001426 	beq	r2,zero,823cc54 <alt_write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 823cc04:	e0bffb17 	ldw	r2,-20(fp)
 823cc08:	10800017 	ldw	r2,0(r2)
 823cc0c:	10800617 	ldw	r2,24(r2)
 823cc10:	e0ffff17 	ldw	r3,-4(fp)
 823cc14:	180d883a 	mov	r6,r3
 823cc18:	e17ffe17 	ldw	r5,-8(fp)
 823cc1c:	e13ffb17 	ldw	r4,-20(fp)
 823cc20:	103ee83a 	callr	r2
 823cc24:	e0bffc15 	stw	r2,-16(fp)
 823cc28:	e0bffc17 	ldw	r2,-16(fp)
 823cc2c:	1000070e 	bge	r2,zero,823cc4c <alt_write+0xb4>
      {
        ALT_ERRNO = -rval;
 823cc30:	823cb5c0 	call	823cb5c <alt_get_errno>
 823cc34:	1007883a 	mov	r3,r2
 823cc38:	e0bffc17 	ldw	r2,-16(fp)
 823cc3c:	0085c83a 	sub	r2,zero,r2
 823cc40:	18800015 	stw	r2,0(r3)
        return -1;
 823cc44:	00bfffc4 	movi	r2,-1
 823cc48:	00000c06 	br	823cc7c <alt_write+0xe4>
      }
      return rval;
 823cc4c:	e0bffc17 	ldw	r2,-16(fp)
 823cc50:	00000a06 	br	823cc7c <alt_write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
 823cc54:	823cb5c0 	call	823cb5c <alt_get_errno>
 823cc58:	1007883a 	mov	r3,r2
 823cc5c:	00800344 	movi	r2,13
 823cc60:	18800015 	stw	r2,0(r3)
 823cc64:	00000406 	br	823cc78 <alt_write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 823cc68:	823cb5c0 	call	823cb5c <alt_get_errno>
 823cc6c:	1007883a 	mov	r3,r2
 823cc70:	00801444 	movi	r2,81
 823cc74:	18800015 	stw	r2,0(r3)
  }
  return -1;
 823cc78:	00bfffc4 	movi	r2,-1
}
 823cc7c:	e037883a 	mov	sp,fp
 823cc80:	dfc00117 	ldw	ra,4(sp)
 823cc84:	df000017 	ldw	fp,0(sp)
 823cc88:	dec00204 	addi	sp,sp,8
 823cc8c:	f800283a 	ret

0823cc90 <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
 823cc90:	deffff04 	addi	sp,sp,-4
 823cc94:	df000015 	stw	fp,0(sp)
 823cc98:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 823cc9c:	000170fa 	wrctl	ienable,zero
}
 823cca0:	0001883a 	nop
 823cca4:	e037883a 	mov	sp,fp
 823cca8:	df000017 	ldw	fp,0(sp)
 823ccac:	dec00104 	addi	sp,sp,4
 823ccb0:	f800283a 	ret

0823ccb4 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
 823ccb4:	defff504 	addi	sp,sp,-44
      bltu  sp, et, .Lstack_overflow

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
 823ccb8:	d0e00217 	ldw	r3,-32760(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
 823ccbc:	d1207a17 	ldw	r4,-32280(gp)

      stw ra,  0(sp)
 823ccc0:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
 823ccc4:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
 823ccc8:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
 823cccc:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
 823ccd0:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
 823ccd4:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
 823ccd8:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
 823ccdc:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
 823cce0:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
 823cce4:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
 823cce8:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
 823ccec:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 823ccf0:	823cf280 	call	823cf28 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
 823ccf4:	d1207517 	ldw	r4,-32300(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
 823ccf8:	d1606d07 	ldb	r5,-32332(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
 823ccfc:	d1207a15 	stw	r4,-32280(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
 823cd00:	d1606d45 	stb	r5,-32331(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
 823cd04:	26c00017 	ldw	sp,0(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
 823cd08:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
 823cd0c:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
 823cd10:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
 823cd14:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
 823cd18:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
 823cd1c:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
 823cd20:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
 823cd24:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
 823cd28:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
 823cd2c:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
 823cd30:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
 823cd34:	d0e00215 	stw	r3,-32760(gp)

      stw et, %gprel(alt_stack_limit_value)(gp)

#endif

      addi sp, sp, 44
 823cd38:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
 823cd3c:	f800283a 	ret

0823cd40 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
 823cd40:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
 823cd44:	047fff84 	movi	r17,-2
      and   r18, r18, r17
 823cd48:	9464703a 	and	r18,r18,r17
      wrctl status, r18
 823cd4c:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 823cd50:	823cf280 	call	823cf28 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
 823cd54:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
 823cd58:	d4a06b45 	stb	r18,-32339(gp)

      /*
       * start execution of the new task.
       */

      br 9b
 823cd5c:	003fe506 	br	823ccf4 <OSCtxSw+0x40>

0823cd60 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
 823cd60:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
 823cd64:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
 823cd68:	10800054 	ori	r2,r2,1
      wrctl status, r2
 823cd6c:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
 823cd70:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
 823cd74:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
 823cd78:	dec00204 	addi	sp,sp,8

      callr r2
 823cd7c:	103ee83a 	callr	r2

      nop
 823cd80:	0001883a 	nop

0823cd84 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
 823cd84:	defff704 	addi	sp,sp,-36
 823cd88:	dfc00815 	stw	ra,32(sp)
 823cd8c:	df000715 	stw	fp,28(sp)
 823cd90:	df000704 	addi	fp,sp,28
 823cd94:	e13ffc15 	stw	r4,-16(fp)
 823cd98:	e17ffd15 	stw	r5,-12(fp)
 823cd9c:	e1bffe15 	stw	r6,-8(fp)
 823cda0:	3805883a 	mov	r2,r7
 823cda4:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
 823cda8:	e0fffe17 	ldw	r3,-8(fp)
 823cdac:	00bfff04 	movi	r2,-4
 823cdb0:	1884703a 	and	r2,r3,r2
 823cdb4:	10bef704 	addi	r2,r2,-1060
 823cdb8:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
 823cdbc:	01810904 	movi	r6,1060
 823cdc0:	000b883a 	mov	r5,zero
 823cdc4:	e13ff917 	ldw	r4,-28(fp)
 823cdc8:	82031b40 	call	82031b4 <memset>
 823cdcc:	e0bff917 	ldw	r2,-28(fp)
 823cdd0:	10c0bb04 	addi	r3,r2,748
 823cdd4:	e0bff917 	ldw	r2,-28(fp)
 823cdd8:	10c00115 	stw	r3,4(r2)
 823cddc:	e0bff917 	ldw	r2,-28(fp)
 823cde0:	10c0d504 	addi	r3,r2,852
 823cde4:	e0bff917 	ldw	r2,-28(fp)
 823cde8:	10c00215 	stw	r3,8(r2)
 823cdec:	e0bff917 	ldw	r2,-28(fp)
 823cdf0:	10c0ef04 	addi	r3,r2,956
 823cdf4:	e0bff917 	ldw	r2,-28(fp)
 823cdf8:	10c00315 	stw	r3,12(r2)
 823cdfc:	e0fff917 	ldw	r3,-28(fp)
 823ce00:	00820974 	movhi	r2,2085
 823ce04:	1083c904 	addi	r2,r2,3876
 823ce08:	18800d15 	stw	r2,52(r3)
 823ce0c:	e0bff917 	ldw	r2,-28(fp)
 823ce10:	00c00044 	movi	r3,1
 823ce14:	10c02915 	stw	r3,164(r2)
 823ce18:	10002a15 	stw	zero,168(r2)
 823ce1c:	e0bff917 	ldw	r2,-28(fp)
 823ce20:	00ccc384 	movi	r3,13070
 823ce24:	10c02b0d 	sth	r3,172(r2)
 823ce28:	e0bff917 	ldw	r2,-28(fp)
 823ce2c:	00eaf344 	movi	r3,-21555
 823ce30:	10c02b8d 	sth	r3,174(r2)
 823ce34:	e0bff917 	ldw	r2,-28(fp)
 823ce38:	00c48d04 	movi	r3,4660
 823ce3c:	10c02c0d 	sth	r3,176(r2)
 823ce40:	e0bff917 	ldw	r2,-28(fp)
 823ce44:	00f99b44 	movi	r3,-6547
 823ce48:	10c02c8d 	sth	r3,178(r2)
 823ce4c:	e0bff917 	ldw	r2,-28(fp)
 823ce50:	00f7bb04 	movi	r3,-8468
 823ce54:	10c02d0d 	sth	r3,180(r2)
 823ce58:	e0bff917 	ldw	r2,-28(fp)
 823ce5c:	00c00144 	movi	r3,5
 823ce60:	10c02d8d 	sth	r3,182(r2)
 823ce64:	e0bff917 	ldw	r2,-28(fp)
 823ce68:	00c002c4 	movi	r3,11
 823ce6c:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
 823ce70:	e0bff917 	ldw	r2,-28(fp)
 823ce74:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
 823ce78:	e0bffa17 	ldw	r2,-24(fp)
 823ce7c:	10bff304 	addi	r2,r2,-52
 823ce80:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
 823ce84:	e0bffb17 	ldw	r2,-20(fp)
 823ce88:	10800c04 	addi	r2,r2,48
 823ce8c:	e0fffc17 	ldw	r3,-16(fp)
 823ce90:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
 823ce94:	e0bffb17 	ldw	r2,-20(fp)
 823ce98:	10800b04 	addi	r2,r2,44
 823ce9c:	e0fffd17 	ldw	r3,-12(fp)
 823cea0:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
 823cea4:	e0bffb17 	ldw	r2,-20(fp)
 823cea8:	10800a04 	addi	r2,r2,40
 823ceac:	e0fff917 	ldw	r3,-28(fp)
 823ceb0:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
 823ceb4:	00820934 	movhi	r2,2084
 823ceb8:	10b35804 	addi	r2,r2,-12960
 823cebc:	10c00104 	addi	r3,r2,4
 823cec0:	e0bffb17 	ldw	r2,-20(fp)
 823cec4:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
 823cec8:	e0bffb17 	ldw	r2,-20(fp)
}
 823cecc:	e037883a 	mov	sp,fp
 823ced0:	dfc00117 	ldw	ra,4(sp)
 823ced4:	df000017 	ldw	fp,0(sp)
 823ced8:	dec00204 	addi	sp,sp,8
 823cedc:	f800283a 	ret

0823cee0 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
 823cee0:	defffe04 	addi	sp,sp,-8
 823cee4:	df000115 	stw	fp,4(sp)
 823cee8:	df000104 	addi	fp,sp,4
 823ceec:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
 823cef0:	0001883a 	nop
 823cef4:	e037883a 	mov	sp,fp
 823cef8:	df000017 	ldw	fp,0(sp)
 823cefc:	dec00104 	addi	sp,sp,4
 823cf00:	f800283a 	ret

0823cf04 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
 823cf04:	defffe04 	addi	sp,sp,-8
 823cf08:	df000115 	stw	fp,4(sp)
 823cf0c:	df000104 	addi	fp,sp,4
 823cf10:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
 823cf14:	0001883a 	nop
 823cf18:	e037883a 	mov	sp,fp
 823cf1c:	df000017 	ldw	fp,0(sp)
 823cf20:	dec00104 	addi	sp,sp,4
 823cf24:	f800283a 	ret

0823cf28 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
 823cf28:	deffff04 	addi	sp,sp,-4
 823cf2c:	df000015 	stw	fp,0(sp)
 823cf30:	d839883a 	mov	fp,sp
}
 823cf34:	0001883a 	nop
 823cf38:	e037883a 	mov	sp,fp
 823cf3c:	df000017 	ldw	fp,0(sp)
 823cf40:	dec00104 	addi	sp,sp,4
 823cf44:	f800283a 	ret

0823cf48 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
 823cf48:	deffff04 	addi	sp,sp,-4
 823cf4c:	df000015 	stw	fp,0(sp)
 823cf50:	d839883a 	mov	fp,sp
}
 823cf54:	0001883a 	nop
 823cf58:	e037883a 	mov	sp,fp
 823cf5c:	df000017 	ldw	fp,0(sp)
 823cf60:	dec00104 	addi	sp,sp,4
 823cf64:	f800283a 	ret

0823cf68 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
 823cf68:	defffe04 	addi	sp,sp,-8
 823cf6c:	dfc00115 	stw	ra,4(sp)
 823cf70:	df000015 	stw	fp,0(sp)
 823cf74:	d839883a 	mov	fp,sp
    }
#endif  
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
 823cf78:	822d7100 	call	822d710 <cticks_hook>
#endif
}
 823cf7c:	0001883a 	nop
 823cf80:	e037883a 	mov	sp,fp
 823cf84:	dfc00117 	ldw	ra,4(sp)
 823cf88:	df000017 	ldw	fp,0(sp)
 823cf8c:	dec00204 	addi	sp,sp,8
 823cf90:	f800283a 	ret

0823cf94 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
 823cf94:	deffff04 	addi	sp,sp,-4
 823cf98:	df000015 	stw	fp,0(sp)
 823cf9c:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
#endif
}
 823cfa0:	0001883a 	nop
 823cfa4:	e037883a 	mov	sp,fp
 823cfa8:	df000017 	ldw	fp,0(sp)
 823cfac:	dec00104 	addi	sp,sp,4
 823cfb0:	f800283a 	ret

0823cfb4 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
 823cfb4:	deffff04 	addi	sp,sp,-4
 823cfb8:	df000015 	stw	fp,0(sp)
 823cfbc:	d839883a 	mov	fp,sp
}
 823cfc0:	0001883a 	nop
 823cfc4:	e037883a 	mov	sp,fp
 823cfc8:	df000017 	ldw	fp,0(sp)
 823cfcc:	dec00104 	addi	sp,sp,4
 823cfd0:	f800283a 	ret

0823cfd4 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
 823cfd4:	deffff04 	addi	sp,sp,-4
 823cfd8:	df000015 	stw	fp,0(sp)
 823cfdc:	d839883a 	mov	fp,sp
}
 823cfe0:	0001883a 	nop
 823cfe4:	e037883a 	mov	sp,fp
 823cfe8:	df000017 	ldw	fp,0(sp)
 823cfec:	dec00104 	addi	sp,sp,4
 823cff0:	f800283a 	ret

0823cff4 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
 823cff4:	defffe04 	addi	sp,sp,-8
 823cff8:	df000115 	stw	fp,4(sp)
 823cffc:	df000104 	addi	fp,sp,4
 823d000:	e13fff15 	stw	r4,-4(fp)
}
 823d004:	0001883a 	nop
 823d008:	e037883a 	mov	sp,fp
 823d00c:	df000017 	ldw	fp,0(sp)
 823d010:	dec00104 	addi	sp,sp,4
 823d014:	f800283a 	ret

0823d018 <netmain_init>:
 * RETURNS: 
 */

void 
netmain_init(void)
{
 823d018:	defffb04 	addi	sp,sp,-20
 823d01c:	dfc00415 	stw	ra,16(sp)
 823d020:	df000315 	stw	fp,12(sp)
 823d024:	dc000215 	stw	r16,8(sp)
 823d028:	df000304 	addi	fp,sp,12
   int   e = 0;
 823d02c:	e03ffd15 	stw	zero,-12(fp)
   char *   msg;
#ifdef IP_V6
   ip6_addr host;
#endif

   printf("%s\n", name);
 823d030:	d0a04b17 	ldw	r2,-32468(gp)
 823d034:	1009883a 	mov	r4,r2
 823d038:	82036240 	call	8203624 <puts>
   printf("Copyright 1996-2008 by InterNiche Technologies. All rights reserved. \n");
 823d03c:	01020974 	movhi	r4,2085
 823d040:	2103d504 	addi	r4,r4,3924
 823d044:	82036240 	call	8203624 <puts>
#ifdef IN_MENUS
   install_version("allports3.1");
#endif
#ifndef SUPERLOOP
   /* call this to do pre-task setup including intialization of port_prep */
   msg = pre_task_setup();
 823d048:	822dedc0 	call	822dedc <pre_task_setup>
 823d04c:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 823d050:	e0bffe17 	ldw	r2,-8(fp)
 823d054:	10000226 	beq	r2,zero,823d060 <netmain_init+0x48>
      panic(msg);
 823d058:	e13ffe17 	ldw	r4,-8(fp)
 823d05c:	8228c480 	call	8228c48 <panic>
      printf("global_log_create() failed\n");
   }
   glog_with_type(LOG_TYPE_INFO, "INICHE LOG initialized", 1);
#endif

   msg = ip_startup();
 823d060:	82268840 	call	8226884 <ip_startup>
 823d064:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 823d068:	e0bffe17 	ldw	r2,-8(fp)
 823d06c:	10000726 	beq	r2,zero,823d08c <netmain_init+0x74>
   {
      printf("inet startup error: %s\n", msg);
 823d070:	e17ffe17 	ldw	r5,-8(fp)
 823d074:	01020974 	movhi	r4,2085
 823d078:	2103e704 	addi	r4,r4,3996
 823d07c:	82033a00 	call	82033a0 <printf>
      panic("IP");
 823d080:	01020974 	movhi	r4,2085
 823d084:	2103ed04 	addi	r4,r4,4020
 823d088:	8228c480 	call	8228c48 <panic>
   }

#if defined(MEMDEV_SIZE) && defined(VFS_FILES)
   init_memdev(); /* init the mem and null test devices */
 823d08c:	82471640 	call	8247164 <init_memdev>
#endif

#ifdef IP_MULTICAST
#ifdef INCLUDE_TCP
   /* call the IP multicast test program */
   u_mctest_init();
 823d090:	82467040 	call	8246704 <u_mctest_init>

   /* clear debugging flags. Port can optionally turn them
    * back on in post_task_setup();
    * NDEBUG = UPCTRACE | IPTRACE | TPTRACE ;  
    */
   NDEBUG = 0;    
 823d094:	d0208315 	stw	zero,-32244(gp)

   /* print IP address of the first interface - for user's benefit */
   printf("IP address of %s : %s\n" , ((NET)(netlist.q_head))->name,
 823d098:	008209b4 	movhi	r2,2086
 823d09c:	10ba5c04 	addi	r2,r2,-5776
 823d0a0:	10800017 	ldw	r2,0(r2)
 823d0a4:	14000104 	addi	r16,r2,4
      print_ipad(((NET)(netlist.q_head))->n_ipaddr));
 823d0a8:	008209b4 	movhi	r2,2086
 823d0ac:	10ba5c04 	addi	r2,r2,-5776
 823d0b0:	10800017 	ldw	r2,0(r2)
    * NDEBUG = UPCTRACE | IPTRACE | TPTRACE ;  
    */
   NDEBUG = 0;    

   /* print IP address of the first interface - for user's benefit */
   printf("IP address of %s : %s\n" , ((NET)(netlist.q_head))->name,
 823d0b4:	10800a17 	ldw	r2,40(r2)
 823d0b8:	1009883a 	mov	r4,r2
 823d0bc:	82289f40 	call	82289f4 <print_ipad>
 823d0c0:	100d883a 	mov	r6,r2
 823d0c4:	800b883a 	mov	r5,r16
 823d0c8:	01020974 	movhi	r4,2085
 823d0cc:	2103ee04 	addi	r4,r4,4024
 823d0d0:	82033a00 	call	82033a0 <printf>
      print_ipad(((NET)(netlist.q_head))->n_ipaddr));
 
#ifndef SUPERLOOP
   /* call this per-target routine after basic tasks & net are up */
   msg = post_task_setup();
 823d0d4:	822df280 	call	822df28 <post_task_setup>
 823d0d8:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 823d0dc:	e0bffe17 	ldw	r2,-8(fp)
 823d0e0:	10000226 	beq	r2,zero,823d0ec <netmain_init+0xd4>
      panic(msg);
 823d0e4:	e13ffe17 	ldw	r4,-8(fp)
 823d0e8:	8228c480 	call	8228c48 <panic>
#ifdef USE_AUTOIP
   Upnp_init();      /* start Auto IP before DHCP client */
#endif   /* USE_AUTOIP */

#ifdef DHCP_CLIENT
   dhc_setup();   /* kick off any DHCP clients */
 823d0ec:	8246dec0 	call	8246dec <dhc_setup>
      panic("prep_modules");
   }
#endif
   USE_ARG(e);    /* Avoid compiler warnings */

} /* end of netmain_init() */
 823d0f0:	0001883a 	nop
 823d0f4:	e6ffff04 	addi	sp,fp,-4
 823d0f8:	dfc00217 	ldw	ra,8(sp)
 823d0fc:	df000117 	ldw	fp,4(sp)
 823d100:	dc000017 	ldw	r16,0(sp)
 823d104:	dec00304 	addi	sp,sp,12
 823d108:	f800283a 	ret

0823d10c <icmp_port_du>:
 * RETURNS: 
 */

void
icmp_port_du(PACKET p, struct destun * pdp)
{
 823d10c:	defffb04 	addi	sp,sp,-20
 823d110:	dfc00415 	stw	ra,16(sp)
 823d114:	df000315 	stw	fp,12(sp)
 823d118:	dc000215 	stw	r16,8(sp)
 823d11c:	df000304 	addi	fp,sp,12
 823d120:	e13ffd15 	stw	r4,-12(fp)
 823d124:	e17ffe15 	stw	r5,-8(fp)
   dprintf("got ICMP %s UNREACHABLE from %s\n", 
      icmpdu_types[(int)(pdp->dtype)], print_ipad(p->fhost) );
 823d128:	e0bffe17 	ldw	r2,-8(fp)
 823d12c:	10800003 	ldbu	r2,0(r2)
 823d130:	10c03fcc 	andi	r3,r2,255
 823d134:	18c0201c 	xori	r3,r3,128
 823d138:	18ffe004 	addi	r3,r3,-128
 */

void
icmp_port_du(PACKET p, struct destun * pdp)
{
   dprintf("got ICMP %s UNREACHABLE from %s\n", 
 823d13c:	00820974 	movhi	r2,2085
 823d140:	108f3304 	addi	r2,r2,15564
 823d144:	18c7883a 	add	r3,r3,r3
 823d148:	18c7883a 	add	r3,r3,r3
 823d14c:	10c5883a 	add	r2,r2,r3
 823d150:	14000017 	ldw	r16,0(r2)
 823d154:	e0bffd17 	ldw	r2,-12(fp)
 823d158:	10800717 	ldw	r2,28(r2)
 823d15c:	1009883a 	mov	r4,r2
 823d160:	82289f40 	call	82289f4 <print_ipad>
 823d164:	100d883a 	mov	r6,r2
 823d168:	800b883a 	mov	r5,r16
 823d16c:	01020974 	movhi	r4,2085
 823d170:	2103fe04 	addi	r4,r4,4088
 823d174:	82033a00 	call	82033a0 <printf>
      icmpdu_types[(int)(pdp->dtype)], print_ipad(p->fhost) );
   dprintf(prompt);
 823d178:	d0a04c17 	ldw	r2,-32464(gp)
 823d17c:	1009883a 	mov	r4,r2
 823d180:	82033a00 	call	82033a0 <printf>
}
 823d184:	0001883a 	nop
 823d188:	e6ffff04 	addi	sp,fp,-4
 823d18c:	dfc00217 	ldw	ra,8(sp)
 823d190:	df000117 	ldw	fp,4(sp)
 823d194:	dc000017 	ldw	r16,0(sp)
 823d198:	dec00304 	addi	sp,sp,12
 823d19c:	f800283a 	ret

0823d1a0 <station_state>:
 * RETURNS: 
 */

int
station_state(void * pio)
{
 823d1a0:	defff904 	addi	sp,sp,-28
 823d1a4:	dfc00615 	stw	ra,24(sp)
 823d1a8:	df000515 	stw	fp,20(sp)
 823d1ac:	dc000415 	stw	r16,16(sp)
 823d1b0:	df000504 	addi	fp,sp,20
 823d1b4:	e13ffe15 	stw	r4,-8(fp)
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 823d1b8:	e03ffc15 	stw	zero,-16(fp)
 823d1bc:	008209b4 	movhi	r2,2086
 823d1c0:	10ba5c04 	addi	r2,r2,-5776
 823d1c4:	10800017 	ldw	r2,0(r2)
 823d1c8:	e0bffd15 	stw	r2,-12(fp)
 823d1cc:	00002506 	br	823d264 <station_state+0xc4>
   {
      ns_printf(pio, "iface %d-%s IP addr:%s  ", 
       i, ifp->name, print_ipad(ifp->n_ipaddr) );
 823d1d0:	e0bffd17 	ldw	r2,-12(fp)
 823d1d4:	14000104 	addi	r16,r2,4
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
   {
      ns_printf(pio, "iface %d-%s IP addr:%s  ", 
 823d1d8:	e0bffd17 	ldw	r2,-12(fp)
 823d1dc:	10800a17 	ldw	r2,40(r2)
 823d1e0:	1009883a 	mov	r4,r2
 823d1e4:	82289f40 	call	82289f4 <print_ipad>
 823d1e8:	d8800015 	stw	r2,0(sp)
 823d1ec:	800f883a 	mov	r7,r16
 823d1f0:	e1bffc17 	ldw	r6,-16(fp)
 823d1f4:	01420974 	movhi	r5,2085
 823d1f8:	29440704 	addi	r5,r5,4124
 823d1fc:	e13ffe17 	ldw	r4,-8(fp)
 823d200:	8228e600 	call	8228e60 <ns_printf>
       i, ifp->name, print_ipad(ifp->n_ipaddr) );
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
 823d204:	e0bffd17 	ldw	r2,-12(fp)
 823d208:	10800c17 	ldw	r2,48(r2)
 823d20c:	1009883a 	mov	r4,r2
 823d210:	82289f40 	call	82289f4 <print_ipad>
 823d214:	100d883a 	mov	r6,r2
 823d218:	01420974 	movhi	r5,2085
 823d21c:	29440e04 	addi	r5,r5,4152
 823d220:	e13ffe17 	ldw	r4,-8(fp)
 823d224:	8228e600 	call	8228e60 <ns_printf>
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
 823d228:	e0bffd17 	ldw	r2,-12(fp)
 823d22c:	10800d17 	ldw	r2,52(r2)
 823d230:	1009883a 	mov	r4,r2
 823d234:	82289f40 	call	82289f4 <print_ipad>
 823d238:	100d883a 	mov	r6,r2
 823d23c:	01420974 	movhi	r5,2085
 823d240:	29441104 	addi	r5,r5,4164
 823d244:	e13ffe17 	ldw	r4,-8(fp)
 823d248:	8228e600 	call	8228e60 <ns_printf>
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 823d24c:	e0bffd17 	ldw	r2,-12(fp)
 823d250:	10800017 	ldw	r2,0(r2)
 823d254:	e0bffd15 	stw	r2,-12(fp)
 823d258:	e0bffc17 	ldw	r2,-16(fp)
 823d25c:	10800044 	addi	r2,r2,1
 823d260:	e0bffc15 	stw	r2,-16(fp)
 823d264:	e0bffd17 	ldw	r2,-12(fp)
 823d268:	103fd91e 	bne	r2,zero,823d1d0 <station_state+0x30>
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
   }
#endif   /* NO_INET_STACK */

   ns_printf(pio, "current tick count %lu\n", cticks);
 823d26c:	d0a0a817 	ldw	r2,-32096(gp)
 823d270:	100d883a 	mov	r6,r2
 823d274:	01420974 	movhi	r5,2085
 823d278:	29441404 	addi	r5,r5,4176
 823d27c:	e13ffe17 	ldw	r4,-8(fp)
 823d280:	8228e600 	call	8228e60 <ns_printf>

   ns_printf(pio, "common delay parameter:  %lu ticks (%lu ms).\n", pingdelay, (pingdelay * TIMEFOR1TICK));
 823d284:	d0e04d17 	ldw	r3,-32460(gp)
 823d288:	d0a04d17 	ldw	r2,-32460(gp)
 823d28c:	108002a4 	muli	r2,r2,10
 823d290:	100f883a 	mov	r7,r2
 823d294:	180d883a 	mov	r6,r3
 823d298:	01420974 	movhi	r5,2085
 823d29c:	29441a04 	addi	r5,r5,4200
 823d2a0:	e13ffe17 	ldw	r4,-8(fp)
 823d2a4:	8228e600 	call	8228e60 <ns_printf>
   ns_printf(pio, "common host parameter: %s\n", print_ipad(activehost));
 823d2a8:	d0a0ba17 	ldw	r2,-32024(gp)
 823d2ac:	1009883a 	mov	r4,r2
 823d2b0:	82289f40 	call	82289f4 <print_ipad>
 823d2b4:	100d883a 	mov	r6,r2
 823d2b8:	01420974 	movhi	r5,2085
 823d2bc:	29442604 	addi	r5,r5,4248
 823d2c0:	e13ffe17 	ldw	r4,-8(fp)
 823d2c4:	8228e600 	call	8228e60 <ns_printf>
   ns_printf(pio, "common length parameter: %d\n", deflength);
 823d2c8:	d0a04e17 	ldw	r2,-32456(gp)
 823d2cc:	100d883a 	mov	r6,r2
 823d2d0:	01420974 	movhi	r5,2085
 823d2d4:	29442d04 	addi	r5,r5,4276
 823d2d8:	e13ffe17 	ldw	r4,-8(fp)
 823d2dc:	8228e600 	call	8228e60 <ns_printf>
#ifdef USE_PPP
   ns_printf(pio, "current dial-in user name is %s\n", pppcfg.username);
   ns_printf(pio, "current dial-in password is %s\n", pppcfg.password);
#endif   /* USE_PPP */

   task_stats(pio);
 823d2e0:	e13ffe17 	ldw	r4,-8(fp)
 823d2e4:	823d8440 	call	823d844 <task_stats>

   return 0;
 823d2e8:	0005883a 	mov	r2,zero
}
 823d2ec:	e6ffff04 	addi	sp,fp,-4
 823d2f0:	dfc00217 	ldw	ra,8(sp)
 823d2f4:	df000117 	ldw	fp,4(sp)
 823d2f8:	dc000017 	ldw	r16,0(sp)
 823d2fc:	dec00304 	addi	sp,sp,12
 823d300:	f800283a 	ret

0823d304 <sysuptime>:
 * RETURNS: 
 */

unsigned long
sysuptime()
{
 823d304:	deffff04 	addi	sp,sp,-4
 823d308:	df000015 	stw	fp,0(sp)
 823d30c:	d839883a 	mov	fp,sp
   return ((cticks/TPS)*100);    /* 100ths of a sec since boot time */
 823d310:	d160a817 	ldw	r5,-32096(gp)
 823d314:	00947b34 	movhi	r2,20972
 823d318:	10a147c4 	addi	r2,r2,-31457
 823d31c:	288c383a 	mulxuu	r6,r5,r2
 823d320:	2885383a 	mul	r2,r5,r2
 823d324:	1007883a 	mov	r3,r2
 823d328:	3009883a 	mov	r4,r6
 823d32c:	2004d17a 	srli	r2,r4,5
 823d330:	10801924 	muli	r2,r2,100
}
 823d334:	e037883a 	mov	sp,fp
 823d338:	df000017 	ldw	fp,0(sp)
 823d33c:	dec00104 	addi	sp,sp,4
 823d340:	f800283a 	ret

0823d344 <packet_check>:

static int inside_pktdemux = 0; 

void
packet_check(void)
{
 823d344:	defffe04 	addi	sp,sp,-8
 823d348:	dfc00115 	stw	ra,4(sp)
 823d34c:	df000015 	stw	fp,0(sp)
 823d350:	d839883a 	mov	fp,sp
   if(inside_pktdemux != 0)   /* check re-entrancy flag */
 823d354:	d0a0bb17 	ldw	r2,-32020(gp)
 823d358:	1000081e 	bne	r2,zero,823d37c <packet_check+0x38>
      return;           /* do not re-enter pktdemux(), packet will wait... */
   inside_pktdemux++;   /* set re-entrany flag */
 823d35c:	d0a0bb17 	ldw	r2,-32020(gp)
 823d360:	10800044 	addi	r2,r2,1
 823d364:	d0a0bb15 	stw	r2,-32020(gp)
   pktdemux();          /* process low level packet input */
 823d368:	82262c40 	call	82262c4 <pktdemux>
   inside_pktdemux--;   /* clear re-entrany flag */
 823d36c:	d0a0bb17 	ldw	r2,-32020(gp)
 823d370:	10bfffc4 	addi	r2,r2,-1
 823d374:	d0a0bb15 	stw	r2,-32020(gp)
 823d378:	00000106 	br	823d380 <packet_check+0x3c>

void
packet_check(void)
{
   if(inside_pktdemux != 0)   /* check re-entrancy flag */
      return;           /* do not re-enter pktdemux(), packet will wait... */
 823d37c:	0001883a 	nop
   inside_pktdemux++;   /* set re-entrany flag */
   pktdemux();          /* process low level packet input */
   inside_pktdemux--;   /* clear re-entrany flag */
}
 823d380:	e037883a 	mov	sp,fp
 823d384:	dfc00117 	ldw	ra,4(sp)
 823d388:	df000017 	ldw	fp,0(sp)
 823d38c:	dec00204 	addi	sp,sp,8
 823d390:	f800283a 	ret

0823d394 <mcastlist>:
 * RETURNS: 
 */

int
mcastlist(struct in_multi * multi_ptr)
{
 823d394:	defffe04 	addi	sp,sp,-8
 823d398:	df000115 	stw	fp,4(sp)
 823d39c:	df000104 	addi	fp,sp,4
 823d3a0:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(multi_ptr);

   return 0;
 823d3a4:	0005883a 	mov	r2,zero
}
 823d3a8:	e037883a 	mov	sp,fp
 823d3ac:	df000017 	ldw	fp,0(sp)
 823d3b0:	dec00104 	addi	sp,sp,4
 823d3b4:	f800283a 	ret

0823d3b8 <prep_modules>:
#ifdef USE_MODEM
extern   int   prep_modem(void);
#endif   /* USE_MODEM */

int prep_modules(void)
{
 823d3b8:	defffd04 	addi	sp,sp,-12
 823d3bc:	dfc00215 	stw	ra,8(sp)
 823d3c0:	df000115 	stw	fp,4(sp)
 823d3c4:	df000104 	addi	fp,sp,4
#ifdef IP_V6
   ip6_addr host;
   int i;
#endif

int e = 0;
 823d3c8:	e03fff15 	stw	zero,-4(fp)
      panic("prep_modules");
   }
#endif   /* SMTP_ALERTS */

#ifdef VFS_FILES
   e = prep_vfs();
 823d3cc:	8249fa40 	call	8249fa4 <prep_vfs>
 823d3d0:	e0bfff15 	stw	r2,-4(fp)
   if (e != 0)
 823d3d4:	e0bfff17 	ldw	r2,-4(fp)
 823d3d8:	10000626 	beq	r2,zero,823d3f4 <prep_modules+0x3c>
   {
      dprintf("VFS Module prep failed\n");
 823d3dc:	01020974 	movhi	r4,2085
 823d3e0:	21043504 	addi	r4,r4,4308
 823d3e4:	82036240 	call	8203624 <puts>
      panic("prep_modules");
 823d3e8:	01020974 	movhi	r4,2085
 823d3ec:	21043b04 	addi	r4,r4,4332
 823d3f0:	8228c480 	call	8228c48 <panic>
   {
      dprintf("sslapp_init() failed\n");
      panic("prep_modules");
   }
#endif
   return 0;
 823d3f4:	0005883a 	mov	r2,zero
}
 823d3f8:	e037883a 	mov	sp,fp
 823d3fc:	dfc00117 	ldw	ra,4(sp)
 823d400:	df000017 	ldw	fp,0(sp)
 823d404:	dec00204 	addi	sp,sp,8
 823d408:	f800283a 	ret

0823d40c <inet_timer>:
 * RETURNS: 
 */

void
inet_timer(void)
{
 823d40c:	defffe04 	addi	sp,sp,-8
 823d410:	dfc00115 	stw	ra,4(sp)
 823d414:	df000015 	stw	fp,0(sp)
 823d418:	d839883a 	mov	fp,sp
#ifdef IP_FRAGMENTS
   /* run thru' the IP reassembly queue (once every second) */
   if (ire_cticks < cticks)
 823d41c:	d0e0c917 	ldw	r3,-31964(gp)
 823d420:	d0a0a817 	ldw	r2,-32096(gp)
 823d424:	1880012e 	bgeu	r3,r2,823d42c <inet_timer+0x20>
      ip_reasm_process_timer_tick ();
 823d428:	82424cc0 	call	82424cc <ip_reasm_process_timer_tick>
#endif

#ifdef INCLUDE_TCP
   tcp_tick();          /* run TCP timers */
 823d42c:	822f9f80 	call	822f9f8 <tcp_tick>
#endif

#ifdef INICHE_TIMERS    /* interval timers? */
   check_interval_timers();
 823d430:	823d4980 	call	823d498 <check_interval_timers>
#endif

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Call igmp timeout routine */
   if (igmp_cticks < cticks)  /* Call igmp timeout routine 5 times per sec */
 823d434:	d0e08717 	ldw	r3,-32228(gp)
 823d438:	d0a0a817 	ldw	r2,-32096(gp)
 823d43c:	1880012e 	bgeu	r3,r2,823d444 <inet_timer+0x38>
      igmp_fasttimo();
 823d440:	8226e700 	call	8226e70 <igmp_fasttimo>
#endif



   /* Some timer routines only need calling once a second: */
   if ((nextppp < cticks) ||  /* next call to PPP is due */
 823d444:	d0e0bc17 	ldw	r3,-32016(gp)
 823d448:	d0a0a817 	ldw	r2,-32096(gp)
 823d44c:	18800436 	bltu	r3,r2,823d460 <inet_timer+0x54>
       (nextppp > (cticks+(10*TPS))) )  /* for when cticks wraps */
 823d450:	d0a0a817 	ldw	r2,-32096(gp)
 823d454:	10c0fa04 	addi	r3,r2,1000
 823d458:	d0a0bc17 	ldw	r2,-32016(gp)
#endif



   /* Some timer routines only need calling once a second: */
   if ((nextppp < cticks) ||  /* next call to PPP is due */
 823d45c:	1880082e 	bgeu	r3,r2,823d480 <inet_timer+0x74>
       (nextppp > (cticks+(10*TPS))) )  /* for when cticks wraps */
   {
      nextppp = cticks + TPS;
 823d460:	d0a0a817 	ldw	r2,-32096(gp)
 823d464:	10801904 	addi	r2,r2,100
 823d468:	d0a0bc15 	stw	r2,-32016(gp)

      if (port_1s_callout != NULL)
 823d46c:	d0a0bd17 	ldw	r2,-32012(gp)
 823d470:	10000226 	beq	r2,zero,823d47c <inet_timer+0x70>
         (*port_1s_callout)();
 823d474:	d0a0bd17 	ldw	r2,-32012(gp)
 823d478:	103ee83a 	callr	r2

#ifdef USE_PPP
      ppp_timeisup();
#endif
#ifdef DHCP_CLIENT
      dhc_second();
 823d47c:	822bd100 	call	822bd10 <dhc_second>
#endif
#ifdef IPSEC
      IPSecTimer();
#endif
   }
}
 823d480:	0001883a 	nop
 823d484:	e037883a 	mov	sp,fp
 823d488:	dfc00117 	ldw	ra,4(sp)
 823d48c:	df000017 	ldw	fp,0(sp)
 823d490:	dec00204 	addi	sp,sp,8
 823d494:	f800283a 	ret

0823d498 <check_interval_timers>:

static int numtimers = 0;     /* number of active timers */

static void
check_interval_timers(void)
{
 823d498:	defffc04 	addi	sp,sp,-16
 823d49c:	dfc00315 	stw	ra,12(sp)
 823d4a0:	df000215 	stw	fp,8(sp)
 823d4a4:	df000204 	addi	fp,sp,8
   int   i;
   int   found = 0;  /* number of valid timers found */
 823d4a8:	e03fff15 	stw	zero,-4(fp)

   /* if no timers, just return */
   if (numtimers > 0)
 823d4ac:	d0a0be17 	ldw	r2,-32008(gp)
 823d4b0:	0080560e 	bge	zero,r2,823d60c <check_interval_timers+0x174>
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 823d4b4:	e03ffe15 	stw	zero,-8(fp)
 823d4b8:	00004f06 	br	823d5f8 <check_interval_timers+0x160>
      {
         if (intimers[i].callback)   /* is this timer active? */
 823d4bc:	008209b4 	movhi	r2,2086
 823d4c0:	10ba0304 	addi	r2,r2,-6132
 823d4c4:	e0fffe17 	ldw	r3,-8(fp)
 823d4c8:	18c00524 	muli	r3,r3,20
 823d4cc:	10c5883a 	add	r2,r2,r3
 823d4d0:	10800017 	ldw	r2,0(r2)
 823d4d4:	10004526 	beq	r2,zero,823d5ec <check_interval_timers+0x154>
	 {
            if ((intimers[i].tmo < cticks) && (!intimers[i].inuse))  /* timer ready fire? */
 823d4d8:	008209b4 	movhi	r2,2086
 823d4dc:	10ba0304 	addi	r2,r2,-6132
 823d4e0:	e0fffe17 	ldw	r3,-8(fp)
 823d4e4:	18c00524 	muli	r3,r3,20
 823d4e8:	10c5883a 	add	r2,r2,r3
 823d4ec:	10800304 	addi	r2,r2,12
 823d4f0:	10c00017 	ldw	r3,0(r2)
 823d4f4:	d0a0a817 	ldw	r2,-32096(gp)
 823d4f8:	1880362e 	bgeu	r3,r2,823d5d4 <check_interval_timers+0x13c>
 823d4fc:	008209b4 	movhi	r2,2086
 823d500:	10ba0304 	addi	r2,r2,-6132
 823d504:	e0fffe17 	ldw	r3,-8(fp)
 823d508:	18c00524 	muli	r3,r3,20
 823d50c:	10c5883a 	add	r2,r2,r3
 823d510:	10800404 	addi	r2,r2,16
 823d514:	10800017 	ldw	r2,0(r2)
 823d518:	10002e1e 	bne	r2,zero,823d5d4 <check_interval_timers+0x13c>
            {
               intimers[i].tmo = intimers[i].interval + cticks;   /* set next tmo */
 823d51c:	008209b4 	movhi	r2,2086
 823d520:	10ba0304 	addi	r2,r2,-6132
 823d524:	e0fffe17 	ldw	r3,-8(fp)
 823d528:	18c00524 	muli	r3,r3,20
 823d52c:	10c5883a 	add	r2,r2,r3
 823d530:	10800204 	addi	r2,r2,8
 823d534:	10c00017 	ldw	r3,0(r2)
 823d538:	d0a0a817 	ldw	r2,-32096(gp)
 823d53c:	1887883a 	add	r3,r3,r2
 823d540:	008209b4 	movhi	r2,2086
 823d544:	10ba0304 	addi	r2,r2,-6132
 823d548:	e13ffe17 	ldw	r4,-8(fp)
 823d54c:	21000524 	muli	r4,r4,20
 823d550:	1105883a 	add	r2,r2,r4
 823d554:	10800304 	addi	r2,r2,12
 823d558:	10c00015 	stw	r3,0(r2)
               intimers[i].inuse = TRUE;
 823d55c:	008209b4 	movhi	r2,2086
 823d560:	10ba0304 	addi	r2,r2,-6132
 823d564:	e0fffe17 	ldw	r3,-8(fp)
 823d568:	18c00524 	muli	r3,r3,20
 823d56c:	10c5883a 	add	r2,r2,r3
 823d570:	10800404 	addi	r2,r2,16
 823d574:	00c00044 	movi	r3,1
 823d578:	10c00015 	stw	r3,0(r2)
               intimers[i].callback(intimers[i].parm);      /* call user routine */
 823d57c:	008209b4 	movhi	r2,2086
 823d580:	10ba0304 	addi	r2,r2,-6132
 823d584:	e0fffe17 	ldw	r3,-8(fp)
 823d588:	18c00524 	muli	r3,r3,20
 823d58c:	10c5883a 	add	r2,r2,r3
 823d590:	10c00017 	ldw	r3,0(r2)
 823d594:	008209b4 	movhi	r2,2086
 823d598:	10ba0304 	addi	r2,r2,-6132
 823d59c:	e13ffe17 	ldw	r4,-8(fp)
 823d5a0:	21000524 	muli	r4,r4,20
 823d5a4:	1105883a 	add	r2,r2,r4
 823d5a8:	10800104 	addi	r2,r2,4
 823d5ac:	10800017 	ldw	r2,0(r2)
 823d5b0:	1009883a 	mov	r4,r2
 823d5b4:	183ee83a 	callr	r3
               intimers[i].inuse = FALSE;
 823d5b8:	008209b4 	movhi	r2,2086
 823d5bc:	10ba0304 	addi	r2,r2,-6132
 823d5c0:	e0fffe17 	ldw	r3,-8(fp)
 823d5c4:	18c00524 	muli	r3,r3,20
 823d5c8:	10c5883a 	add	r2,r2,r3
 823d5cc:	10800404 	addi	r2,r2,16
 823d5d0:	10000015 	stw	zero,0(r2)
            }
            /* If we've examined all the active timers, we're done */
            if (++found >= numtimers)
 823d5d4:	e0bfff17 	ldw	r2,-4(fp)
 823d5d8:	10800044 	addi	r2,r2,1
 823d5dc:	e0bfff15 	stw	r2,-4(fp)
 823d5e0:	d0a0be17 	ldw	r2,-32008(gp)
 823d5e4:	e0ffff17 	ldw	r3,-4(fp)
 823d5e8:	1880070e 	bge	r3,r2,823d608 <check_interval_timers+0x170>

   /* if no timers, just return */
   if (numtimers > 0)
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 823d5ec:	e0bffe17 	ldw	r2,-8(fp)
 823d5f0:	10800044 	addi	r2,r2,1
 823d5f4:	e0bffe15 	stw	r2,-8(fp)
 823d5f8:	e0bffe17 	ldw	r2,-8(fp)
 823d5fc:	10800150 	cmplti	r2,r2,5
 823d600:	103fae1e 	bne	r2,zero,823d4bc <check_interval_timers+0x24>
            if (++found >= numtimers)
               break;
         }
      }
   }
}
 823d604:	00000106 	br	823d60c <check_interval_timers+0x174>
               intimers[i].callback(intimers[i].parm);      /* call user routine */
               intimers[i].inuse = FALSE;
            }
            /* If we've examined all the active timers, we're done */
            if (++found >= numtimers)
               break;
 823d608:	0001883a 	nop
         }
      }
   }
}
 823d60c:	0001883a 	nop
 823d610:	e037883a 	mov	sp,fp
 823d614:	dfc00117 	ldw	ra,4(sp)
 823d618:	df000017 	ldw	fp,0(sp)
 823d61c:	dec00204 	addi	sp,sp,8
 823d620:	f800283a 	ret

0823d624 <in_timerset>:
 * RETURNS: timer ID if OK, else if table is full.
 */

long
in_timerset(void (*callback)(long), long msecs, long parm)
{
 823d624:	defffa04 	addi	sp,sp,-24
 823d628:	dfc00515 	stw	ra,20(sp)
 823d62c:	df000415 	stw	fp,16(sp)
 823d630:	df000404 	addi	fp,sp,16
 823d634:	e13ffd15 	stw	r4,-12(fp)
 823d638:	e17ffe15 	stw	r5,-8(fp)
 823d63c:	e1bfff15 	stw	r6,-4(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 823d640:	e03ffc15 	stw	zero,-16(fp)
 823d644:	00004606 	br	823d760 <in_timerset+0x13c>
   {
      if(intimers[i].callback == NULL)
 823d648:	008209b4 	movhi	r2,2086
 823d64c:	10ba0304 	addi	r2,r2,-6132
 823d650:	e0fffc17 	ldw	r3,-16(fp)
 823d654:	18c00524 	muli	r3,r3,20
 823d658:	10c5883a 	add	r2,r2,r3
 823d65c:	10800017 	ldw	r2,0(r2)
 823d660:	10003c1e 	bne	r2,zero,823d754 <in_timerset+0x130>
      {
         /* found empty table entry, set up new timer */
         intimers[i].callback = callback;
 823d664:	008209b4 	movhi	r2,2086
 823d668:	10ba0304 	addi	r2,r2,-6132
 823d66c:	e0fffc17 	ldw	r3,-16(fp)
 823d670:	18c00524 	muli	r3,r3,20
 823d674:	10c5883a 	add	r2,r2,r3
 823d678:	e0fffd17 	ldw	r3,-12(fp)
 823d67c:	10c00015 	stw	r3,0(r2)
         intimers[i].parm = parm;
 823d680:	008209b4 	movhi	r2,2086
 823d684:	10ba0304 	addi	r2,r2,-6132
 823d688:	e0fffc17 	ldw	r3,-16(fp)
 823d68c:	18c00524 	muli	r3,r3,20
 823d690:	10c5883a 	add	r2,r2,r3
 823d694:	10800104 	addi	r2,r2,4
 823d698:	e0ffff17 	ldw	r3,-4(fp)
 823d69c:	10c00015 	stw	r3,0(r2)
         /* set interval, in TPS (cticks) units */
         intimers[i].interval = (msecs * TPS)/1000;
 823d6a0:	e0bffe17 	ldw	r2,-8(fp)
 823d6a4:	10801924 	muli	r2,r2,100
 823d6a8:	0140fa04 	movi	r5,1000
 823d6ac:	1009883a 	mov	r4,r2
 823d6b0:	8202b180 	call	8202b18 <__divsi3>
 823d6b4:	1009883a 	mov	r4,r2
 823d6b8:	008209b4 	movhi	r2,2086
 823d6bc:	10ba0304 	addi	r2,r2,-6132
 823d6c0:	e0fffc17 	ldw	r3,-16(fp)
 823d6c4:	18c00524 	muli	r3,r3,20
 823d6c8:	10c5883a 	add	r2,r2,r3
 823d6cc:	10800204 	addi	r2,r2,8
 823d6d0:	11000015 	stw	r4,0(r2)
         intimers[i].tmo = intimers[i].interval + cticks;   /* first tmo */
 823d6d4:	008209b4 	movhi	r2,2086
 823d6d8:	10ba0304 	addi	r2,r2,-6132
 823d6dc:	e0fffc17 	ldw	r3,-16(fp)
 823d6e0:	18c00524 	muli	r3,r3,20
 823d6e4:	10c5883a 	add	r2,r2,r3
 823d6e8:	10800204 	addi	r2,r2,8
 823d6ec:	10c00017 	ldw	r3,0(r2)
 823d6f0:	d0a0a817 	ldw	r2,-32096(gp)
 823d6f4:	1887883a 	add	r3,r3,r2
 823d6f8:	008209b4 	movhi	r2,2086
 823d6fc:	10ba0304 	addi	r2,r2,-6132
 823d700:	e13ffc17 	ldw	r4,-16(fp)
 823d704:	21000524 	muli	r4,r4,20
 823d708:	1105883a 	add	r2,r2,r4
 823d70c:	10800304 	addi	r2,r2,12
 823d710:	10c00015 	stw	r3,0(r2)
		 intimers[i].inuse = FALSE;
 823d714:	008209b4 	movhi	r2,2086
 823d718:	10ba0304 	addi	r2,r2,-6132
 823d71c:	e0fffc17 	ldw	r3,-16(fp)
 823d720:	18c00524 	muli	r3,r3,20
 823d724:	10c5883a 	add	r2,r2,r3
 823d728:	10800404 	addi	r2,r2,16
 823d72c:	10000015 	stw	zero,0(r2)
         numtimers++;
 823d730:	d0a0be17 	ldw	r2,-32008(gp)
 823d734:	10800044 	addi	r2,r2,1
 823d738:	d0a0be15 	stw	r2,-32008(gp)
         return (long)&intimers[i];
 823d73c:	e0bffc17 	ldw	r2,-16(fp)
 823d740:	10c00524 	muli	r3,r2,20
 823d744:	008209b4 	movhi	r2,2086
 823d748:	10ba0304 	addi	r2,r2,-6132
 823d74c:	1885883a 	add	r2,r3,r2
 823d750:	00000706 	br	823d770 <in_timerset+0x14c>
long
in_timerset(void (*callback)(long), long msecs, long parm)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 823d754:	e0bffc17 	ldw	r2,-16(fp)
 823d758:	10800044 	addi	r2,r2,1
 823d75c:	e0bffc15 	stw	r2,-16(fp)
 823d760:	e0bffc17 	ldw	r2,-16(fp)
 823d764:	10800150 	cmplti	r2,r2,5
 823d768:	103fb71e 	bne	r2,zero,823d648 <in_timerset+0x24>
		 intimers[i].inuse = FALSE;
         numtimers++;
         return (long)&intimers[i];
      }
   }
   return 0;
 823d76c:	0005883a 	mov	r2,zero
}
 823d770:	e037883a 	mov	sp,fp
 823d774:	dfc00117 	ldw	ra,4(sp)
 823d778:	df000017 	ldw	fp,0(sp)
 823d77c:	dec00204 	addi	sp,sp,8
 823d780:	f800283a 	ret

0823d784 <in_timerkill>:
 */


int
in_timerkill(long timer)
{
 823d784:	defffc04 	addi	sp,sp,-16
 823d788:	dfc00315 	stw	ra,12(sp)
 823d78c:	df000215 	stw	fp,8(sp)
 823d790:	df000204 	addi	fp,sp,8
 823d794:	e13fff15 	stw	r4,-4(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 823d798:	e03ffe15 	stw	zero,-8(fp)
 823d79c:	00001606 	br	823d7f8 <in_timerkill+0x74>
   {
      if(timer == (long)&intimers[i])
 823d7a0:	e0bffe17 	ldw	r2,-8(fp)
 823d7a4:	10c00524 	muli	r3,r2,20
 823d7a8:	008209b4 	movhi	r2,2086
 823d7ac:	10ba0304 	addi	r2,r2,-6132
 823d7b0:	1885883a 	add	r2,r3,r2
 823d7b4:	1007883a 	mov	r3,r2
 823d7b8:	e0bfff17 	ldw	r2,-4(fp)
 823d7bc:	18800b1e 	bne	r3,r2,823d7ec <in_timerkill+0x68>
      {
         intimers[i].callback = NULL;
 823d7c0:	008209b4 	movhi	r2,2086
 823d7c4:	10ba0304 	addi	r2,r2,-6132
 823d7c8:	e0fffe17 	ldw	r3,-8(fp)
 823d7cc:	18c00524 	muli	r3,r3,20
 823d7d0:	10c5883a 	add	r2,r2,r3
 823d7d4:	10000015 	stw	zero,0(r2)
         numtimers--;
 823d7d8:	d0a0be17 	ldw	r2,-32008(gp)
 823d7dc:	10bfffc4 	addi	r2,r2,-1
 823d7e0:	d0a0be15 	stw	r2,-32008(gp)
         return 0;      /* OK return */
 823d7e4:	0005883a 	mov	r2,zero
 823d7e8:	00000806 	br	823d80c <in_timerkill+0x88>
int
in_timerkill(long timer)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 823d7ec:	e0bffe17 	ldw	r2,-8(fp)
 823d7f0:	10800044 	addi	r2,r2,1
 823d7f4:	e0bffe15 	stw	r2,-8(fp)
 823d7f8:	e0bffe17 	ldw	r2,-8(fp)
 823d7fc:	10800150 	cmplti	r2,r2,5
 823d800:	103fe71e 	bne	r2,zero,823d7a0 <in_timerkill+0x1c>
         intimers[i].callback = NULL;
         numtimers--;
         return 0;      /* OK return */
      }
   }
   dtrap();    /* timer to kill not found */
 823d804:	822d5940 	call	822d594 <dtrap>
   return ENP_PARAM;
 823d808:	00bffd84 	movi	r2,-10
}
 823d80c:	e037883a 	mov	sp,fp
 823d810:	dfc00117 	ldw	ra,4(sp)
 823d814:	df000017 	ldw	fp,0(sp)
 823d818:	dec00204 	addi	sp,sp,8
 823d81c:	f800283a 	ret

0823d820 <create_apptasks>:
#endif
/* per-application thread definitions */

int
create_apptasks(void)
{
 823d820:	defffe04 	addi	sp,sp,-8
 823d824:	df000115 	stw	fp,4(sp)
 823d828:	df000104 	addi	fp,sp,4
int e = 0;
 823d82c:	e03fff15 	stw	zero,-4(fp)
#endif
/* 
 * Altera Niche Stack Nios port modification:
 * return error code, if any 
 */
   return e;
 823d830:	e0bfff17 	ldw	r2,-4(fp)
}
 823d834:	e037883a 	mov	sp,fp
 823d838:	df000017 	ldw	fp,0(sp)
 823d83c:	dec00104 	addi	sp,sp,4
 823d840:	f800283a 	ret

0823d844 <task_stats>:
 */


void
task_stats(void * pio)
{
 823d844:	defffd04 	addi	sp,sp,-12
 823d848:	dfc00215 	stw	ra,8(sp)
 823d84c:	df000115 	stw	fp,4(sp)
 823d850:	df000104 	addi	fp,sp,4
 823d854:	e13fff15 	stw	r4,-4(fp)
   ns_printf(pio, "Task wakeups:");
 823d858:	01420974 	movhi	r5,2085
 823d85c:	29443f04 	addi	r5,r5,4348
 823d860:	e13fff17 	ldw	r4,-4(fp)
 823d864:	8228e600 	call	8228e60 <ns_printf>

#ifndef NO_INET_STACK
   ns_printf(pio, "netmain: %lu\n", netmain_wakes);
 823d868:	d0a08a17 	ldw	r2,-32216(gp)
 823d86c:	100d883a 	mov	r6,r2
 823d870:	01420974 	movhi	r5,2085
 823d874:	29444304 	addi	r5,r5,4364
 823d878:	e13fff17 	ldw	r4,-4(fp)
 823d87c:	8228e600 	call	8228e60 <ns_printf>
#endif
#ifndef NO_INET_TICK
   ns_printf(pio, "nettick: %lu\n", nettick_wakes);
 823d880:	d0a08b17 	ldw	r2,-32212(gp)
 823d884:	100d883a 	mov	r6,r2
 823d888:	01420974 	movhi	r5,2085
 823d88c:	29444704 	addi	r5,r5,4380
 823d890:	e13fff17 	ldw	r4,-4(fp)
 823d894:	8228e600 	call	8228e60 <ns_printf>
   ns_printf(pio, "browtask: %lu  ", browtask_wakes);
#endif
#ifdef INCLUDE_SSLAPP
   ns_printf(pio, "INCLUDE_SSLAPP: %lu  ", sslapp_wakes);
#endif
   ns_printf(pio, "\n");
 823d898:	01420974 	movhi	r5,2085
 823d89c:	29444b04 	addi	r5,r5,4396
 823d8a0:	e13fff17 	ldw	r4,-4(fp)
 823d8a4:	8228e600 	call	8228e60 <ns_printf>
}
 823d8a8:	0001883a 	nop
 823d8ac:	e037883a 	mov	sp,fp
 823d8b0:	dfc00117 	ldw	ra,4(sp)
 823d8b4:	df000017 	ldw	fp,0(sp)
 823d8b8:	dec00204 	addi	sp,sp,8
 823d8bc:	f800283a 	ret

0823d8c0 <fcntl>:
 * (for files and device drivers) or calls the InterNiche bsd_ioctl for 
 * sockets.
 */
 
int fcntl (int file, int cmd, ...)
{
 823d8c0:	defff804 	addi	sp,sp,-32
 823d8c4:	dfc00515 	stw	ra,20(sp)
 823d8c8:	df000415 	stw	fp,16(sp)
 823d8cc:	df000404 	addi	fp,sp,16
 823d8d0:	e13ffe15 	stw	r4,-8(fp)
 823d8d4:	e17fff15 	stw	r5,-4(fp)
 823d8d8:	e1800215 	stw	r6,8(fp)
 823d8dc:	e1c00315 	stw	r7,12(fp)
  long     flags;
  va_list  argp;

  if (file < ALT_MAX_FD)
 823d8e0:	e0bffe17 	ldw	r2,-8(fp)
 823d8e4:	10800808 	cmpgei	r2,r2,32
 823d8e8:	10000c1e 	bne	r2,zero,823d91c <fcntl+0x5c>
  {
    va_start(argp, cmd);
 823d8ec:	e0800204 	addi	r2,fp,8
 823d8f0:	e0bffd15 	stw	r2,-12(fp)
    flags = va_arg(argp, long);
 823d8f4:	e0bffd17 	ldw	r2,-12(fp)
 823d8f8:	10c00104 	addi	r3,r2,4
 823d8fc:	e0fffd15 	stw	r3,-12(fp)
 823d900:	10800017 	ldw	r2,0(r2)
 823d904:	e0bffc15 	stw	r2,-16(fp)
    va_end(argp);
    return alt_fcntl(file, cmd, flags);
 823d908:	e1bffc17 	ldw	r6,-16(fp)
 823d90c:	e17fff17 	ldw	r5,-4(fp)
 823d910:	e13ffe17 	ldw	r4,-8(fp)
 823d914:	824a15c0 	call	824a15c <alt_fcntl>
 823d918:	00000c06 	br	823d94c <fcntl+0x8c>
  }
  else
  {
    va_start(argp, cmd);
 823d91c:	e0800204 	addi	r2,fp,8
 823d920:	e0bffd15 	stw	r2,-12(fp)
    flags = va_arg(argp, long);
 823d924:	e0bffd17 	ldw	r2,-12(fp)
 823d928:	10c00104 	addi	r3,r2,4
 823d92c:	e0fffd15 	stw	r3,-12(fp)
 823d930:	10800017 	ldw	r2,0(r2)
 823d934:	e0bffc15 	stw	r2,-16(fp)
    va_end(argp);
    return bsd_ioctl(file, cmd, flags);
 823d938:	e0bfff17 	ldw	r2,-4(fp)
 823d93c:	e1bffc17 	ldw	r6,-16(fp)
 823d940:	100b883a 	mov	r5,r2
 823d944:	e13ffe17 	ldw	r4,-8(fp)
 823d948:	822823c0 	call	822823c <bsd_ioctl>
  }
}
 823d94c:	e037883a 	mov	sp,fp
 823d950:	dfc00117 	ldw	ra,4(sp)
 823d954:	df000017 	ldw	fp,0(sp)
 823d958:	dec00404 	addi	sp,sp,16
 823d95c:	f800283a 	ret

0823d960 <etainit>:
 * RETURNS: int               0 if OK, else nonzero
 */

int
etainit(void)
{
 823d960:	defffe04 	addi	sp,sp,-8
 823d964:	dfc00115 	stw	ra,4(sp)
 823d968:	df000015 	stw	fp,0(sp)
 823d96c:	d839883a 	mov	fp,sp
   /* register ARP type with the Net Driver */
   if (reg_type(ET_ARP) != 0)
 823d970:	01018204 	movi	r4,1544
 823d974:	823ee8c0 	call	823ee8c <reg_type>
 823d978:	10000526 	beq	r2,zero,823d990 <etainit+0x30>
   {
#ifdef NPDEBUG
      dprintf("ARP: unable to register type with MAC Driver\n");
 823d97c:	01020974 	movhi	r4,2085
 823d980:	21044c04 	addi	r4,r4,4400
 823d984:	82036240 	call	8203624 <puts>
#endif
      return (1);
 823d988:	00800044 	movi	r2,1
 823d98c:	00000106 	br	823d994 <etainit+0x34>
   }
   return (0);
 823d990:	0005883a 	mov	r2,zero
}
 823d994:	e037883a 	mov	sp,fp
 823d998:	dfc00117 	ldw	ra,4(sp)
 823d99c:	df000017 	ldw	fp,0(sp)
 823d9a0:	dec00204 	addi	sp,sp,8
 823d9a4:	f800283a 	ret

0823d9a8 <et_send>:
 * and MIB info in the packet header. 
 */

int
et_send(PACKET pkt, struct arptabent *tp)
{
 823d9a8:	defff904 	addi	sp,sp,-28
 823d9ac:	dfc00615 	stw	ra,24(sp)
 823d9b0:	df000515 	stw	fp,20(sp)
 823d9b4:	df000504 	addi	fp,sp,20
 823d9b8:	e13ffe15 	stw	r4,-8(fp)
 823d9bc:	e17fff15 	stw	r5,-4(fp)
   char *ethhdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 823d9c0:	e0bffe17 	ldw	r2,-8(fp)
 823d9c4:	10800617 	ldw	r2,24(r2)
 823d9c8:	10802717 	ldw	r2,156(r2)
 823d9cc:	e0bffc15 	stw	r2,-16(fp)
   int err;

   tp->lasttime = cticks;
 823d9d0:	d0e0a817 	ldw	r3,-32096(gp)
 823d9d4:	e0bfff17 	ldw	r2,-4(fp)
 823d9d8:	10c00615 	stw	r3,24(r2)
   pkt->nb_prot -= ETHHDR_SIZE;  /* prepare for prepending ethernet header */
 823d9dc:	e0bffe17 	ldw	r2,-8(fp)
 823d9e0:	10800317 	ldw	r2,12(r2)
 823d9e4:	10fffc04 	addi	r3,r2,-16
 823d9e8:	e0bffe17 	ldw	r2,-8(fp)
 823d9ec:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen += ETHHDR_SIZE;
 823d9f0:	e0bffe17 	ldw	r2,-8(fp)
 823d9f4:	10800417 	ldw	r2,16(r2)
 823d9f8:	10c00404 	addi	r3,r2,16
 823d9fc:	e0bffe17 	ldw	r2,-8(fp)
 823da00:	10c00415 	stw	r3,16(r2)
   ethhdr = pkt->nb_prot + ETHHDR_BIAS;
 823da04:	e0bffe17 	ldw	r2,-8(fp)
 823da08:	10800317 	ldw	r2,12(r2)
 823da0c:	10800084 	addi	r2,r2,2
 823da10:	e0bffd15 	stw	r2,-12(fp)
      MEMMOVE(snap, snapdata, 6);
      snap->type = ARPIP;
   }
#endif   /* IEEE_802_3 */

   if (ethhdr < pkt->nb_buff)   /* sanity check pointer */
 823da14:	e0bffe17 	ldw	r2,-8(fp)
 823da18:	10800117 	ldw	r2,4(r2)
 823da1c:	e0fffd17 	ldw	r3,-12(fp)
 823da20:	1880032e 	bgeu	r3,r2,823da30 <et_send+0x88>
      panic("et_send: prepend");
 823da24:	01020974 	movhi	r4,2085
 823da28:	21045804 	addi	r4,r4,4448
 823da2c:	8228c480 	call	8228c48 <panic>

   MEMMOVE(ethhdr + ET_DSTOFF, tp->t_phy_addr, 6);  /* set pkt's MAC dst addr */
 823da30:	e0bfff17 	ldw	r2,-4(fp)
 823da34:	10800104 	addi	r2,r2,4
 823da38:	01800184 	movi	r6,6
 823da3c:	100b883a 	mov	r5,r2
 823da40:	e13ffd17 	ldw	r4,-12(fp)
 823da44:	82030580 	call	8203058 <memmove>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);  /* MAC src */
 823da48:	e0bffd17 	ldw	r2,-12(fp)
 823da4c:	10c00184 	addi	r3,r2,6
 823da50:	e0bffc17 	ldw	r2,-16(fp)
 823da54:	10800517 	ldw	r2,20(r2)
 823da58:	01800184 	movi	r6,6
 823da5c:	100b883a 	mov	r5,r2
 823da60:	1809883a 	mov	r4,r3
 823da64:	82030580 	call	8203058 <memmove>

   /* nice clean ethernet II header */
   if ((tp->flags & (ET_ETH2|ET_SNAP)) != ET_SNAP)
 823da68:	e0bfff17 	ldw	r2,-4(fp)
 823da6c:	1080070b 	ldhu	r2,28(r2)
 823da70:	10bfffcc 	andi	r2,r2,65535
 823da74:	108000cc 	andi	r2,r2,3
 823da78:	108000a0 	cmpeqi	r2,r2,2
 823da7c:	1000041e 	bne	r2,zero,823da90 <et_send+0xe8>
      ET_TYPE_SET(ethhdr, ntohs(ARPIP));
 823da80:	e0bffd17 	ldw	r2,-12(fp)
 823da84:	10800304 	addi	r2,r2,12
 823da88:	00c00204 	movi	r3,8
 823da8c:	10c00005 	stb	r3,0(r2)
 823da90:	e0bffd17 	ldw	r2,-12(fp)
 823da94:	10800344 	addi	r2,r2,13
 823da98:	10000005 	stb	zero,0(r2)
      ET_TYPE_SET(ethhdr, len8023);
   }
#endif   /* IEEE_802_3 */

   /* if a packet oriented send exists, use it: */
   if (pkt->net->pkt_send)
 823da9c:	e0bffe17 	ldw	r2,-8(fp)
 823daa0:	10800617 	ldw	r2,24(r2)
 823daa4:	10800417 	ldw	r2,16(r2)
 823daa8:	10000726 	beq	r2,zero,823dac8 <et_send+0x120>
      err = pkt->net->pkt_send(pkt);   /* send packet to media */
 823daac:	e0bffe17 	ldw	r2,-8(fp)
 823dab0:	10800617 	ldw	r2,24(r2)
 823dab4:	10800417 	ldw	r2,16(r2)
 823dab8:	e13ffe17 	ldw	r4,-8(fp)
 823dabc:	103ee83a 	callr	r2
 823dac0:	e0bffb15 	stw	r2,-20(fp)
 823dac4:	00001206 	br	823db10 <et_send+0x168>
   else  /* else use older raw_send routine */
   {
      /* sent to media */
      err = pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 823dac8:	e0bffe17 	ldw	r2,-8(fp)
 823dacc:	10800617 	ldw	r2,24(r2)
 823dad0:	10800317 	ldw	r2,12(r2)
 823dad4:	e0fffe17 	ldw	r3,-8(fp)
 823dad8:	19000617 	ldw	r4,24(r3)
 823dadc:	e0fffe17 	ldw	r3,-8(fp)
 823dae0:	19400317 	ldw	r5,12(r3)
 823dae4:	e0fffe17 	ldw	r3,-8(fp)
 823dae8:	18c00417 	ldw	r3,16(r3)
 823daec:	180d883a 	mov	r6,r3
 823daf0:	103ee83a 	callr	r2
 823daf4:	e0bffb15 	stw	r2,-20(fp)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823daf8:	01000084 	movi	r4,2
 823dafc:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 823db00:	e13ffe17 	ldw	r4,-8(fp)
 823db04:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823db08:	01000084 	movi	r4,2
 823db0c:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   }

   return (err);
 823db10:	e0bffb17 	ldw	r2,-20(fp)
}
 823db14:	e037883a 	mov	sp,fp
 823db18:	dfc00117 	ldw	ra,4(sp)
 823db1c:	df000017 	ldw	fp,0(sp)
 823db20:	dec00204 	addi	sp,sp,8
 823db24:	f800283a 	ret

0823db28 <arp_free_pending>:
 * and mark the entry "unused".
 */

void
arp_free_pending(struct arptabent *entry)
{
 823db28:	defffb04 	addi	sp,sp,-20
 823db2c:	dfc00415 	stw	ra,16(sp)
 823db30:	df000315 	stw	fp,12(sp)
 823db34:	df000304 	addi	fp,sp,12
 823db38:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt;
   PACKET nextpkt;

   /* entry->pending has the linked list of all pending packets */
   tmppkt = entry->pending;
 823db3c:	e0bfff17 	ldw	r2,-4(fp)
 823db40:	10800417 	ldw	r2,16(r2)
 823db44:	e0bffd15 	stw	r2,-12(fp)
   entry->pending = (PACKET)NULL;
 823db48:	e0bfff17 	ldw	r2,-4(fp)
 823db4c:	10000415 	stw	zero,16(r2)

   LOCK_NET_RESOURCE(FREEQ_RESID);
 823db50:	01000084 	movi	r4,2
 823db54:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>

   /* free all pending packets */
   while (tmppkt)
 823db58:	00000906 	br	823db80 <arp_free_pending+0x58>
   {
      nextpkt = tmppkt->next;        /* save the next packet in list */
 823db5c:	e0bffd17 	ldw	r2,-12(fp)
 823db60:	10800017 	ldw	r2,0(r2)
 823db64:	e0bffe15 	stw	r2,-8(fp)
      tmppkt->next = (PACKET)NULL;
 823db68:	e0bffd17 	ldw	r2,-12(fp)
 823db6c:	10000015 	stw	zero,0(r2)
      pk_free(tmppkt);               /* free current packet */
 823db70:	e13ffd17 	ldw	r4,-12(fp)
 823db74:	822cd3c0 	call	822cd3c <pk_free>
      tmppkt = nextpkt;              /* process the next packet */
 823db78:	e0bffe17 	ldw	r2,-8(fp)
 823db7c:	e0bffd15 	stw	r2,-12(fp)
   entry->pending = (PACKET)NULL;

   LOCK_NET_RESOURCE(FREEQ_RESID);

   /* free all pending packets */
   while (tmppkt)
 823db80:	e0bffd17 	ldw	r2,-12(fp)
 823db84:	103ff51e 	bne	r2,zero,823db5c <arp_free_pending+0x34>
      tmppkt->next = (PACKET)NULL;
      pk_free(tmppkt);               /* free current packet */
      tmppkt = nextpkt;              /* process the next packet */
   }

   entry->t_pro_addr = 0;     /* mark the entry "unused" */
 823db88:	e0bfff17 	ldw	r2,-4(fp)
 823db8c:	10000015 	stw	zero,0(r2)

   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823db90:	01000084 	movi	r4,2
 823db94:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
}
 823db98:	0001883a 	nop
 823db9c:	e037883a 	mov	sp,fp
 823dba0:	dfc00117 	ldw	ra,4(sp)
 823dba4:	df000017 	ldw	fp,0(sp)
 823dba8:	dec00204 	addi	sp,sp,8
 823dbac:	f800283a 	ret

0823dbb0 <arp_send_pending>:
 * Clear the list (entry->pending) after sending the packets.
 */

void
arp_send_pending(struct arptabent *entry)
{
 823dbb0:	defffc04 	addi	sp,sp,-16
 823dbb4:	dfc00315 	stw	ra,12(sp)
 823dbb8:	df000215 	stw	fp,8(sp)
 823dbbc:	df000204 	addi	fp,sp,8
 823dbc0:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt = entry->pending;
 823dbc4:	e0bfff17 	ldw	r2,-4(fp)
 823dbc8:	10800417 	ldw	r2,16(r2)
 823dbcc:	e0bffe15 	stw	r2,-8(fp)

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 823dbd0:	00000906 	br	823dbf8 <arp_send_pending+0x48>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
 823dbd4:	e0bffe17 	ldw	r2,-8(fp)
 823dbd8:	10c00017 	ldw	r3,0(r2)
 823dbdc:	e0bfff17 	ldw	r2,-4(fp)
 823dbe0:	10c00415 	stw	r3,16(r2)
      tmppkt->next = (PACKET)NULL;
 823dbe4:	e0bffe17 	ldw	r2,-8(fp)
 823dbe8:	10000015 	stw	zero,0(r2)
      et_send(tmppkt, entry);          /* try send again */
 823dbec:	e17fff17 	ldw	r5,-4(fp)
 823dbf0:	e13ffe17 	ldw	r4,-8(fp)
 823dbf4:	823d9a80 	call	823d9a8 <et_send>
   PACKET tmppkt = entry->pending;

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 823dbf8:	e0bfff17 	ldw	r2,-4(fp)
 823dbfc:	10800417 	ldw	r2,16(r2)
 823dc00:	e0bffe15 	stw	r2,-8(fp)
 823dc04:	e0bffe17 	ldw	r2,-8(fp)
 823dc08:	103ff21e 	bne	r2,zero,823dbd4 <arp_send_pending+0x24>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
      tmppkt->next = (PACKET)NULL;
      et_send(tmppkt, entry);          /* try send again */
   }
}
 823dc0c:	0001883a 	nop
 823dc10:	e037883a 	mov	sp,fp
 823dc14:	dfc00117 	ldw	ra,4(sp)
 823dc18:	df000017 	ldw	fp,0(sp)
 823dc1c:	dec00204 	addi	sp,sp,8
 823dc20:	f800283a 	ret

0823dc24 <send_arp>:
 * timeout will eventually free packet. 
 */

int
send_arp(PACKET pkt, ip_addr dest_ip)
{
 823dc24:	defff404 	addi	sp,sp,-48
 823dc28:	dfc00b15 	stw	ra,44(sp)
 823dc2c:	df000a15 	stw	fp,40(sp)
 823dc30:	df000a04 	addi	fp,sp,40
 823dc34:	e13ffe15 	stw	r4,-8(fp)
 823dc38:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *   oldest;
   char * ethhdr;
   NET net = pkt->net;
 823dc3c:	e0bffe17 	ldw	r2,-8(fp)
 823dc40:	10800617 	ldw	r2,24(r2)
 823dc44:	e0bff615 	stw	r2,-40(fp)
   struct arp_hdr *  arphdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 823dc48:	e0bffe17 	ldw	r2,-8(fp)
 823dc4c:	10800617 	ldw	r2,24(r2)
 823dc50:	10802717 	ldw	r2,156(r2)
 823dc54:	e0bff715 	stw	r2,-36(fp)
   } dest_ip_ptr;
#endif /* ETHMCAST */


   /* If we are broadcasting or multicasting ... */
   if ((dest_ip == 0xFFFFFFFF) ||  
 823dc58:	e0bfff17 	ldw	r2,-4(fp)
 823dc5c:	10bfffe0 	cmpeqi	r2,r2,-1
 823dc60:	1000191e 	bne	r2,zero,823dcc8 <send_arp+0xa4>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask)))
 823dc64:	e0bff617 	ldw	r2,-40(fp)
 823dc68:	10800c17 	ldw	r2,48(r2)
 823dc6c:	0086303a 	nor	r3,zero,r2
 823dc70:	e0bfff17 	ldw	r2,-4(fp)
 823dc74:	1886703a 	and	r3,r3,r2
 823dc78:	e0bff617 	ldw	r2,-40(fp)
 823dc7c:	10800c17 	ldw	r2,48(r2)
 823dc80:	0084303a 	nor	r2,zero,r2
   } dest_ip_ptr;
#endif /* ETHMCAST */


   /* If we are broadcasting or multicasting ... */
   if ((dest_ip == 0xFFFFFFFF) ||  
 823dc84:	18801026 	beq	r3,r2,823dcc8 <send_arp+0xa4>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask)))
       || (IN_MULTICAST(ntohl(dest_ip)) ))
 823dc88:	e0bfff17 	ldw	r2,-4(fp)
 823dc8c:	1006d63a 	srli	r3,r2,24
 823dc90:	e0bfff17 	ldw	r2,-4(fp)
 823dc94:	1004d23a 	srli	r2,r2,8
 823dc98:	10bfc00c 	andi	r2,r2,65280
 823dc9c:	1886b03a 	or	r3,r3,r2
 823dca0:	e0bfff17 	ldw	r2,-4(fp)
 823dca4:	10bfc00c 	andi	r2,r2,65280
 823dca8:	1004923a 	slli	r2,r2,8
 823dcac:	1886b03a 	or	r3,r3,r2
 823dcb0:	e0bfff17 	ldw	r2,-4(fp)
 823dcb4:	1004963a 	slli	r2,r2,24
 823dcb8:	1884b03a 	or	r2,r3,r2
 823dcbc:	10fc002c 	andhi	r3,r2,61440
 823dcc0:	00b80034 	movhi	r2,57344
 823dcc4:	1880391e 	bne	r3,r2,823ddac <send_arp+0x188>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask))))

#endif /* IP_MULTICAST */
   {
      /* get unused or oldest entry in table */
      oldest = make_arp_entry(dest_ip, pkt->net);
 823dcc8:	e0bffe17 	ldw	r2,-8(fp)
 823dccc:	10800617 	ldw	r2,24(r2)
 823dcd0:	100b883a 	mov	r5,r2
 823dcd4:	e13fff17 	ldw	r4,-4(fp)
 823dcd8:	823e1e40 	call	823e1e4 <make_arp_entry>
 823dcdc:	e0bff915 	stw	r2,-28(fp)

      /* set MAC destination to ethernet broadcast (all FFs) */
      MEMSET(oldest->t_phy_addr, 0xFF, 6);
 823dce0:	e0bff917 	ldw	r2,-28(fp)
 823dce4:	10800104 	addi	r2,r2,4
 823dce8:	01800184 	movi	r6,6
 823dcec:	01403fc4 	movi	r5,255
 823dcf0:	1009883a 	mov	r4,r2
 823dcf4:	82031b40 	call	82031b4 <memset>
#ifdef IP_MULTICAST
      /* If n_mcastlist routine is defined in the net structure,
         map IP mcast to Ether multicast  */

#ifdef ETHMCAST
      if ((pkt->net->n_mcastlist) && (IN_MULTICAST(ntohl(dest_ip))))
 823dcf8:	e0bffe17 	ldw	r2,-8(fp)
 823dcfc:	10800617 	ldw	r2,24(r2)
 823dd00:	10802b17 	ldw	r2,172(r2)
 823dd04:	10002526 	beq	r2,zero,823dd9c <send_arp+0x178>
 823dd08:	e0bfff17 	ldw	r2,-4(fp)
 823dd0c:	1006d63a 	srli	r3,r2,24
 823dd10:	e0bfff17 	ldw	r2,-4(fp)
 823dd14:	1004d23a 	srli	r2,r2,8
 823dd18:	10bfc00c 	andi	r2,r2,65280
 823dd1c:	1886b03a 	or	r3,r3,r2
 823dd20:	e0bfff17 	ldw	r2,-4(fp)
 823dd24:	10bfc00c 	andi	r2,r2,65280
 823dd28:	1004923a 	slli	r2,r2,8
 823dd2c:	1886b03a 	or	r3,r3,r2
 823dd30:	e0bfff17 	ldw	r2,-4(fp)
 823dd34:	1004963a 	slli	r2,r2,24
 823dd38:	1884b03a 	or	r2,r3,r2
 823dd3c:	10fc002c 	andhi	r3,r2,61440
 823dd40:	00b80034 	movhi	r2,57344
 823dd44:	1880151e 	bne	r3,r2,823dd9c <send_arp+0x178>
      {
         /* If IP mcast to be mapped to Ethernet multicast */
         dest_ip_ptr.l = dest_ip;
 823dd48:	e0bfff17 	ldw	r2,-4(fp)
 823dd4c:	e0bffd15 	stw	r2,-12(fp)
         oldest->t_phy_addr[0] = 0x01;
 823dd50:	e0bff917 	ldw	r2,-28(fp)
 823dd54:	00c00044 	movi	r3,1
 823dd58:	10c00105 	stb	r3,4(r2)
         oldest->t_phy_addr[1] = 0x00;
 823dd5c:	e0bff917 	ldw	r2,-28(fp)
 823dd60:	10000145 	stb	zero,5(r2)
         oldest->t_phy_addr[2] = 0x5e;
 823dd64:	e0bff917 	ldw	r2,-28(fp)
 823dd68:	00c01784 	movi	r3,94
 823dd6c:	10c00185 	stb	r3,6(r2)
         oldest->t_phy_addr[3] = (u_char )(dest_ip_ptr.c[1] & 0x7f);
 823dd70:	e0bffd43 	ldbu	r2,-11(fp)
 823dd74:	10801fcc 	andi	r2,r2,127
 823dd78:	1007883a 	mov	r3,r2
 823dd7c:	e0bff917 	ldw	r2,-28(fp)
 823dd80:	10c001c5 	stb	r3,7(r2)
         oldest->t_phy_addr[4] = (u_char )dest_ip_ptr.c[2];
 823dd84:	e0fffd83 	ldbu	r3,-10(fp)
 823dd88:	e0bff917 	ldw	r2,-28(fp)
 823dd8c:	10c00205 	stb	r3,8(r2)
         oldest->t_phy_addr[5] = (u_char )dest_ip_ptr.c[3];
 823dd90:	e0fffdc3 	ldbu	r3,-9(fp)
 823dd94:	e0bff917 	ldw	r2,-28(fp)
 823dd98:	10c00245 	stb	r3,9(r2)
      }
#endif /* ETHMCAST */
#endif /* IP_MULTICAST */
      return (et_send(pkt, oldest));
 823dd9c:	e17ff917 	ldw	r5,-28(fp)
 823dda0:	e13ffe17 	ldw	r4,-8(fp)
 823dda4:	823d9a80 	call	823d9a8 <et_send>
 823dda8:	0000ae06 	br	823e064 <send_arp+0x440>

   /* If packet is addressed to this Ethernet interface, and
    * it's not a loopback address, then don't send it on the wire. 
    * Instead, free the packet and return ENP_NO_ROUTE  
    */
   if ((pkt->fhost == pkt->net->n_ipaddr) &&
 823ddac:	e0bffe17 	ldw	r2,-8(fp)
 823ddb0:	10c00717 	ldw	r3,28(r2)
 823ddb4:	e0bffe17 	ldw	r2,-8(fp)
 823ddb8:	10800617 	ldw	r2,24(r2)
 823ddbc:	10800a17 	ldw	r2,40(r2)
 823ddc0:	18800d1e 	bne	r3,r2,823ddf8 <send_arp+0x1d4>
      ((pkt->fhost & htonl(0xFF000000)) != htonl(0x7F000000)))
 823ddc4:	e0bffe17 	ldw	r2,-8(fp)
 823ddc8:	10800717 	ldw	r2,28(r2)
 823ddcc:	10803fcc 	andi	r2,r2,255

   /* If packet is addressed to this Ethernet interface, and
    * it's not a loopback address, then don't send it on the wire. 
    * Instead, free the packet and return ENP_NO_ROUTE  
    */
   if ((pkt->fhost == pkt->net->n_ipaddr) &&
 823ddd0:	10801fe0 	cmpeqi	r2,r2,127
 823ddd4:	1000081e 	bne	r2,zero,823ddf8 <send_arp+0x1d4>
      ((pkt->fhost & htonl(0xFF000000)) != htonl(0x7F000000)))
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823ddd8:	01000084 	movi	r4,2
 823dddc:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 823dde0:	e13ffe17 	ldw	r4,-8(fp)
 823dde4:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823dde8:	01000084 	movi	r4,2
 823ddec:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return ENP_NO_ROUTE;
 823ddf0:	00bff7c4 	movi	r2,-33
 823ddf4:	00009b06 	br	823e064 <send_arp+0x440>
   }

   /* not broadcasting, so get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 823ddf8:	01000084 	movi	r4,2
 823ddfc:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 823de00:	01000c04 	movi	r4,48
 823de04:	822c9ec0 	call	822c9ec <pk_alloc>
 823de08:	e0bff815 	stw	r2,-32(fp)
   if (!arppkt)
 823de0c:	e0bff817 	ldw	r2,-32(fp)
 823de10:	1000061e 	bne	r2,zero,823de2c <send_arp+0x208>
   {
      pk_free(pkt);
 823de14:	e13ffe17 	ldw	r4,-8(fp)
 823de18:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823de1c:	01000084 	movi	r4,2
 823de20:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 823de24:	00bffa84 	movi	r2,-22
 823de28:	00008e06 	br	823e064 <send_arp+0x440>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823de2c:	01000084 	movi	r4,2
 823de30:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 823de34:	e0bff817 	ldw	r2,-32(fp)
 823de38:	10c00117 	ldw	r3,4(r2)
 823de3c:	e0bff817 	ldw	r2,-32(fp)
 823de40:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 823de44:	e0bff817 	ldw	r2,-32(fp)
 823de48:	00c00c04 	movi	r3,48
 823de4c:	10c00415 	stw	r3,16(r2)
   arppkt->net = pkt->net;
 823de50:	e0bffe17 	ldw	r2,-8(fp)
 823de54:	10c00617 	ldw	r3,24(r2)
 823de58:	e0bff817 	ldw	r2,-32(fp)
 823de5c:	10c00615 	stw	r3,24(r2)

   /* get unused or oldest entry in table */
   oldest = make_arp_entry(dest_ip, pkt->net);
 823de60:	e0bffe17 	ldw	r2,-8(fp)
 823de64:	10800617 	ldw	r2,24(r2)
 823de68:	100b883a 	mov	r5,r2
 823de6c:	e13fff17 	ldw	r4,-4(fp)
 823de70:	823e1e40 	call	823e1e4 <make_arp_entry>
 823de74:	e0bff915 	stw	r2,-28(fp)

   oldest->pending = pkt;           /* packet is "pended", not pk_free()d */
 823de78:	e0bff917 	ldw	r2,-28(fp)
 823de7c:	e0fffe17 	ldw	r3,-8(fp)
 823de80:	10c00415 	stw	r3,16(r2)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 823de84:	e0bff817 	ldw	r2,-32(fp)
 823de88:	10800117 	ldw	r2,4(r2)
 823de8c:	10800084 	addi	r2,r2,2
 823de90:	e0bffa15 	stw	r2,-24(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 823de94:	e0bff817 	ldw	r2,-32(fp)
 823de98:	10800117 	ldw	r2,4(r2)
 823de9c:	10800404 	addi	r2,r2,16
 823dea0:	e0bffb15 	stw	r2,-20(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 823dea4:	e0bffb17 	ldw	r2,-20(fp)
 823dea8:	00c04004 	movi	r3,256
 823deac:	10c0000d 	sth	r3,0(r2)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 823deb0:	e0bffb17 	ldw	r2,-20(fp)
 823deb4:	00c00204 	movi	r3,8
 823deb8:	10c0008d 	sth	r3,2(r2)
   arphdr->ar_hln = 6;
 823debc:	e0bffb17 	ldw	r2,-20(fp)
 823dec0:	00c00184 	movi	r3,6
 823dec4:	10c00105 	stb	r3,4(r2)
   arphdr->ar_pln = 4;
 823dec8:	e0bffb17 	ldw	r2,-20(fp)
 823decc:	00c00104 	movi	r3,4
 823ded0:	10c00145 	stb	r3,5(r2)
   arphdr->ar_op = ARREQ;
 823ded4:	e0bffb17 	ldw	r2,-20(fp)
 823ded8:	00c04004 	movi	r3,256
 823dedc:	10c0018d 	sth	r3,6(r2)
   arphdr->ar_tpa = dest_ip;        /* target's IP address */
 823dee0:	e0bffb17 	ldw	r2,-20(fp)
 823dee4:	e0ffff17 	ldw	r3,-4(fp)
 823dee8:	10c00715 	stw	r3,28(r2)
   arphdr->ar_spa = pkt->net->n_ipaddr;   /* my IP address */
 823deec:	e0bffe17 	ldw	r2,-8(fp)
 823def0:	10800617 	ldw	r2,24(r2)
 823def4:	10c00a17 	ldw	r3,40(r2)
 823def8:	e0bffb17 	ldw	r2,-20(fp)
 823defc:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 823df00:	e0bffb17 	ldw	r2,-20(fp)
 823df04:	10c00204 	addi	r3,r2,8
 823df08:	e0bff717 	ldw	r2,-36(fp)
 823df0c:	10800517 	ldw	r2,20(r2)
 823df10:	01800184 	movi	r6,6
 823df14:	100b883a 	mov	r5,r2
 823df18:	1809883a 	mov	r4,r3
 823df1c:	82030580 	call	8203058 <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 823df20:	01800184 	movi	r6,6
 823df24:	01403fc4 	movi	r5,255
 823df28:	e13ffa17 	ldw	r4,-24(fp)
 823df2c:	82031b40 	call	82031b4 <memset>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 823df30:	e0bffa17 	ldw	r2,-24(fp)
 823df34:	10c00184 	addi	r3,r2,6
 823df38:	e0bff717 	ldw	r2,-36(fp)
 823df3c:	10800517 	ldw	r2,20(r2)
 823df40:	01800184 	movi	r6,6
 823df44:	100b883a 	mov	r5,r2
 823df48:	1809883a 	mov	r4,r3
 823df4c:	82030580 	call	8203058 <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 823df50:	e0bffa17 	ldw	r2,-24(fp)
 823df54:	10800304 	addi	r2,r2,12
 823df58:	00c00204 	movi	r3,8
 823df5c:	10c00005 	stb	r3,0(r2)
 823df60:	e0bffa17 	ldw	r2,-24(fp)
 823df64:	10800344 	addi	r2,r2,13
 823df68:	00c00184 	movi	r3,6
 823df6c:	10c00005 	stb	r3,0(r2)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 823df70:	e0bffb17 	ldw	r2,-20(fp)
 823df74:	e0bffc15 	stw	r2,-16(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 823df78:	e0bffc17 	ldw	r2,-16(fp)
 823df7c:	10c00204 	addi	r3,r2,8
 823df80:	e0bffb17 	ldw	r2,-20(fp)
 823df84:	10800204 	addi	r2,r2,8
 823df88:	01800184 	movi	r6,6
 823df8c:	100b883a 	mov	r5,r2
 823df90:	1809883a 	mov	r4,r3
 823df94:	82030580 	call	8203058 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 823df98:	e0bffc17 	ldw	r2,-16(fp)
 823df9c:	10c00384 	addi	r3,r2,14
 823dfa0:	e0bffb17 	ldw	r2,-20(fp)
 823dfa4:	10800404 	addi	r2,r2,16
 823dfa8:	01800104 	movi	r6,4
 823dfac:	100b883a 	mov	r5,r2
 823dfb0:	1809883a 	mov	r4,r3
 823dfb4:	82030580 	call	8203058 <memmove>
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 823dfb8:	e0bffc17 	ldw	r2,-16(fp)
 823dfbc:	10c00484 	addi	r3,r2,18
 823dfc0:	e0bffb17 	ldw	r2,-20(fp)
 823dfc4:	10800504 	addi	r2,r2,20
 823dfc8:	01800184 	movi	r6,6
 823dfcc:	100b883a 	mov	r5,r2
 823dfd0:	1809883a 	mov	r4,r3
 823dfd4:	82030580 	call	8203058 <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 823dfd8:	e0bffc17 	ldw	r2,-16(fp)
 823dfdc:	10c00604 	addi	r3,r2,24
 823dfe0:	e0bffb17 	ldw	r2,-20(fp)
 823dfe4:	10800704 	addi	r2,r2,28
 823dfe8:	01800104 	movi	r6,4
 823dfec:	100b883a 	mov	r5,r2
 823dff0:	1809883a 	mov	r4,r3
 823dff4:	82030580 	call	8203058 <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 823dff8:	e0bff617 	ldw	r2,-40(fp)
 823dffc:	10800417 	ldw	r2,16(r2)
 823e000:	10000526 	beq	r2,zero,823e018 <send_arp+0x3f4>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 823e004:	e0bff617 	ldw	r2,-40(fp)
 823e008:	10800417 	ldw	r2,16(r2)
 823e00c:	e13ff817 	ldw	r4,-32(fp)
 823e010:	103ee83a 	callr	r2
 823e014:	00000f06 	br	823e054 <send_arp+0x430>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 823e018:	e0bff617 	ldw	r2,-40(fp)
 823e01c:	10800317 	ldw	r2,12(r2)
 823e020:	e0fff817 	ldw	r3,-32(fp)
 823e024:	19000617 	ldw	r4,24(r3)
 823e028:	e0fff817 	ldw	r3,-32(fp)
 823e02c:	18c00117 	ldw	r3,4(r3)
 823e030:	01800c04 	movi	r6,48
 823e034:	180b883a 	mov	r5,r3
 823e038:	103ee83a 	callr	r2
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823e03c:	01000084 	movi	r4,2
 823e040:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 823e044:	e13ff817 	ldw	r4,-32(fp)
 823e048:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e04c:	01000084 	movi	r4,2
 823e050:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 823e054:	d0a0c317 	ldw	r2,-31988(gp)
 823e058:	10800044 	addi	r2,r2,1
 823e05c:	d0a0c315 	stw	r2,-31988(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 823e060:	00800044 	movi	r2,1
}
 823e064:	e037883a 	mov	sp,fp
 823e068:	dfc00117 	ldw	ra,4(sp)
 823e06c:	df000017 	ldw	fp,0(sp)
 823e070:	dec00204 	addi	sp,sp,8
 823e074:	f800283a 	ret

0823e078 <find_oldest_arp>:
 * Old entries are removed from the table.
 */

struct arptabent * 
find_oldest_arp(ip_addr dest_ip)
{
 823e078:	defff804 	addi	sp,sp,-32
 823e07c:	dfc00715 	stw	ra,28(sp)
 823e080:	df000615 	stw	fp,24(sp)
 823e084:	df000604 	addi	fp,sp,24
 823e088:	e13fff15 	stw	r4,-4(fp)
   struct arptabent *tp;
   struct arptabent *exact  = (struct arptabent *)NULL;
 823e08c:	e03ffb15 	stw	zero,-20(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
 823e090:	e03ffc15 	stw	zero,-16(fp)
   struct arptabent *empty  = (struct arptabent *)NULL;
 823e094:	e03ffd15 	stw	zero,-12(fp)
   unsigned long lticks = cticks;
 823e098:	d0a0a817 	ldw	r2,-32096(gp)
 823e09c:	e0bffe15 	stw	r2,-8(fp)

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823e0a0:	008209b4 	movhi	r2,2086
 823e0a4:	10ba1c04 	addi	r2,r2,-6032
 823e0a8:	e0bffa15 	stw	r2,-24(fp)
 823e0ac:	00003b06 	br	823e19c <find_oldest_arp+0x124>
   {
      /* age out old, pending entries */
      if (tp->pending)
 823e0b0:	e0bffa17 	ldw	r2,-24(fp)
 823e0b4:	10800417 	ldw	r2,16(r2)
 823e0b8:	10000b26 	beq	r2,zero,823e0e8 <find_oldest_arp+0x70>
      {
         /* purge if pending for more than one second */
         if ((lticks - tp->createtime) > TPS)
 823e0bc:	e0bffa17 	ldw	r2,-24(fp)
 823e0c0:	10800517 	ldw	r2,20(r2)
 823e0c4:	e0fffe17 	ldw	r3,-8(fp)
 823e0c8:	1885c83a 	sub	r2,r3,r2
 823e0cc:	10801970 	cmpltui	r2,r2,101
 823e0d0:	1000171e 	bne	r2,zero,823e130 <find_oldest_arp+0xb8>
         {
            arp_free_pending(tp);   /* free pending packets */
 823e0d4:	e13ffa17 	ldw	r4,-24(fp)
 823e0d8:	823db280 	call	823db28 <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 823e0dc:	e0bffa17 	ldw	r2,-24(fp)
 823e0e0:	10000015 	stw	zero,0(r2)
 823e0e4:	00001206 	br	823e130 <find_oldest_arp+0xb8>
         }
      }
      else if ((tp->t_pro_addr != 0) &&
 823e0e8:	e0bffa17 	ldw	r2,-24(fp)
 823e0ec:	10800017 	ldw	r2,0(r2)
 823e0f0:	10000f26 	beq	r2,zero,823e130 <find_oldest_arp+0xb8>
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
 823e0f4:	e0bffa17 	ldw	r2,-24(fp)
 823e0f8:	10800517 	ldw	r2,20(r2)
 823e0fc:	e0fffe17 	ldw	r3,-8(fp)
 823e100:	1885c83a 	sub	r2,r3,r2
 823e104:	1007883a 	mov	r3,r2
 823e108:	d0a04f17 	ldw	r2,-32452(gp)
         {
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
      }
      else if ((tp->t_pro_addr != 0) &&
 823e10c:	18800816 	blt	r3,r2,823e130 <find_oldest_arp+0xb8>
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
               ((int)(lticks - tp->lasttime)   >= TPS))
 823e110:	e0bffa17 	ldw	r2,-24(fp)
 823e114:	10800617 	ldw	r2,24(r2)
 823e118:	e0fffe17 	ldw	r3,-8(fp)
 823e11c:	1885c83a 	sub	r2,r3,r2
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
      }
      else if ((tp->t_pro_addr != 0) &&
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
 823e120:	10801910 	cmplti	r2,r2,100
 823e124:	1000021e 	bne	r2,zero,823e130 <find_oldest_arp+0xb8>
               ((int)(lticks - tp->lasttime)   >= TPS))
      {
         /* entry has "expired" and has not been reference in 1 sec. */
         tp->t_pro_addr = 0;     /* mark entry as "unused" */
 823e128:	e0bffa17 	ldw	r2,-24(fp)
 823e12c:	10000015 	stw	zero,0(r2)
      }

      if (tp->t_pro_addr == dest_ip)   /* ip addr already has entry */
 823e130:	e0bffa17 	ldw	r2,-24(fp)
 823e134:	10c00017 	ldw	r3,0(r2)
 823e138:	e0bfff17 	ldw	r2,-4(fp)
 823e13c:	1880031e 	bne	r3,r2,823e14c <find_oldest_arp+0xd4>
      {
         exact = tp;
 823e140:	e0bffa17 	ldw	r2,-24(fp)
 823e144:	e0bffb15 	stw	r2,-20(fp)
 823e148:	00001106 	br	823e190 <find_oldest_arp+0x118>
      }
      else if (tp->t_pro_addr != 0)
 823e14c:	e0bffa17 	ldw	r2,-24(fp)
 823e150:	10800017 	ldw	r2,0(r2)
 823e154:	10000a26 	beq	r2,zero,823e180 <find_oldest_arp+0x108>
      {
         if (!oldest || (tp->lasttime < oldest->lasttime))
 823e158:	e0bffc17 	ldw	r2,-16(fp)
 823e15c:	10000526 	beq	r2,zero,823e174 <find_oldest_arp+0xfc>
 823e160:	e0bffa17 	ldw	r2,-24(fp)
 823e164:	10c00617 	ldw	r3,24(r2)
 823e168:	e0bffc17 	ldw	r2,-16(fp)
 823e16c:	10800617 	ldw	r2,24(r2)
 823e170:	1880072e 	bgeu	r3,r2,823e190 <find_oldest_arp+0x118>
            oldest = tp;
 823e174:	e0bffa17 	ldw	r2,-24(fp)
 823e178:	e0bffc15 	stw	r2,-16(fp)
 823e17c:	00000406 	br	823e190 <find_oldest_arp+0x118>
      }
      else if (!empty)
 823e180:	e0bffd17 	ldw	r2,-12(fp)
 823e184:	1000021e 	bne	r2,zero,823e190 <find_oldest_arp+0x118>
         empty = tp;          /* grab first empty slot */
 823e188:	e0bffa17 	ldw	r2,-24(fp)
 823e18c:	e0bffd15 	stw	r2,-12(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
   struct arptabent *empty  = (struct arptabent *)NULL;
   unsigned long lticks = cticks;

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823e190:	e0bffa17 	ldw	r2,-24(fp)
 823e194:	10800804 	addi	r2,r2,32
 823e198:	e0bffa15 	stw	r2,-24(fp)
 823e19c:	e0fffa17 	ldw	r3,-24(fp)
 823e1a0:	008209b4 	movhi	r2,2086
 823e1a4:	10ba5c04 	addi	r2,r2,-5776
 823e1a8:	18bfc136 	bltu	r3,r2,823e0b0 <find_oldest_arp+0x38>
      }
      else if (!empty)
         empty = tp;          /* grab first empty slot */
   }

   return ((exact) ? exact : ((empty) ? empty : oldest));
 823e1ac:	e0bffb17 	ldw	r2,-20(fp)
 823e1b0:	1000061e 	bne	r2,zero,823e1cc <find_oldest_arp+0x154>
 823e1b4:	e0bffd17 	ldw	r2,-12(fp)
 823e1b8:	10000226 	beq	r2,zero,823e1c4 <find_oldest_arp+0x14c>
 823e1bc:	e0bffd17 	ldw	r2,-12(fp)
 823e1c0:	00000306 	br	823e1d0 <find_oldest_arp+0x158>
 823e1c4:	e0bffc17 	ldw	r2,-16(fp)
 823e1c8:	00000106 	br	823e1d0 <find_oldest_arp+0x158>
 823e1cc:	e0bffb17 	ldw	r2,-20(fp)
}
 823e1d0:	e037883a 	mov	sp,fp
 823e1d4:	dfc00117 	ldw	ra,4(sp)
 823e1d8:	df000017 	ldw	fp,0(sp)
 823e1dc:	dec00204 	addi	sp,sp,8
 823e1e0:	f800283a 	ret

0823e1e4 <make_arp_entry>:
 * active.
 */

struct arptabent *   
make_arp_entry(ip_addr dest_ip, NET net)
{
 823e1e4:	defffa04 	addi	sp,sp,-24
 823e1e8:	dfc00515 	stw	ra,20(sp)
 823e1ec:	df000415 	stw	fp,16(sp)
 823e1f0:	df000404 	addi	fp,sp,16
 823e1f4:	e13ffe15 	stw	r4,-8(fp)
 823e1f8:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *oldest;
   unsigned long lticks = cticks;
 823e1fc:	d0a0a817 	ldw	r2,-32096(gp)
 823e200:	e0bffc15 	stw	r2,-16(fp)

   /* find usable (or existing) ARP table entry */
   oldest = find_oldest_arp(dest_ip);
 823e204:	e13ffe17 	ldw	r4,-8(fp)
 823e208:	823e0780 	call	823e078 <find_oldest_arp>
 823e20c:	e0bffd15 	stw	r2,-12(fp)

   /* If recycling entry, don't leak packets which may be stuck here */
   if (oldest->pending && (oldest->t_pro_addr != dest_ip))
 823e210:	e0bffd17 	ldw	r2,-12(fp)
 823e214:	10800417 	ldw	r2,16(r2)
 823e218:	10000626 	beq	r2,zero,823e234 <make_arp_entry+0x50>
 823e21c:	e0bffd17 	ldw	r2,-12(fp)
 823e220:	10c00017 	ldw	r3,0(r2)
 823e224:	e0bffe17 	ldw	r2,-8(fp)
 823e228:	18800226 	beq	r3,r2,823e234 <make_arp_entry+0x50>
   {
      arp_free_pending(oldest);
 823e22c:	e13ffd17 	ldw	r4,-12(fp)
 823e230:	823db280 	call	823db28 <arp_free_pending>
   }

   /* partially fill in arp entry */
   oldest->t_pro_addr = dest_ip;
 823e234:	e0bffd17 	ldw	r2,-12(fp)
 823e238:	e0fffe17 	ldw	r3,-8(fp)
 823e23c:	10c00015 	stw	r3,0(r2)
   oldest->net = net;
 823e240:	e0bffd17 	ldw	r2,-12(fp)
 823e244:	e0ffff17 	ldw	r3,-4(fp)
 823e248:	10c00315 	stw	r3,12(r2)
   oldest->flags = 0;
 823e24c:	e0bffd17 	ldw	r2,-12(fp)
 823e250:	1000070d 	sth	zero,28(r2)
   MEMSET(oldest->t_phy_addr, '\0', 6);   /* clear mac address */
 823e254:	e0bffd17 	ldw	r2,-12(fp)
 823e258:	10800104 	addi	r2,r2,4
 823e25c:	01800184 	movi	r6,6
 823e260:	000b883a 	mov	r5,zero
 823e264:	1009883a 	mov	r4,r2
 823e268:	82031b40 	call	82031b4 <memset>
   oldest->createtime = oldest->lasttime = lticks;
 823e26c:	e0bffd17 	ldw	r2,-12(fp)
 823e270:	e0fffc17 	ldw	r3,-16(fp)
 823e274:	10c00615 	stw	r3,24(r2)
 823e278:	e0bffd17 	ldw	r2,-12(fp)
 823e27c:	10c00617 	ldw	r3,24(r2)
 823e280:	e0bffd17 	ldw	r2,-12(fp)
 823e284:	10c00515 	stw	r3,20(r2)

   /* start a ARP timer if there isn't one already */
   /* update the timeout value if there is a timer */
   /* time is specified in milliseconds */
   if (arp_timer == 0)
 823e288:	d0a0bf17 	ldw	r2,-32004(gp)
 823e28c:	1000071e 	bne	r2,zero,823e2ac <make_arp_entry+0xc8>
   {
      arp_timer = in_timerset(&cb_arpent_tmo, ARPENT_TMO * 1000, 0);
 823e290:	000d883a 	mov	r6,zero
 823e294:	0149c404 	movi	r5,10000
 823e298:	01020934 	movhi	r4,2084
 823e29c:	213a6104 	addi	r4,r4,-5756
 823e2a0:	823d6240 	call	823d624 <in_timerset>
 823e2a4:	d0a0bf15 	stw	r2,-32004(gp)
 823e2a8:	00000706 	br	823e2c8 <make_arp_entry+0xe4>
   }
   else
   {
      ((struct intimer *)arp_timer)->tmo =
 823e2ac:	d0a0bf17 	ldw	r2,-32004(gp)
 823e2b0:	1009883a 	mov	r4,r2
              ((struct intimer *)arp_timer)->interval + lticks;
 823e2b4:	d0a0bf17 	ldw	r2,-32004(gp)
 823e2b8:	10c00217 	ldw	r3,8(r2)
 823e2bc:	e0bffc17 	ldw	r2,-16(fp)
 823e2c0:	1885883a 	add	r2,r3,r2
   {
      arp_timer = in_timerset(&cb_arpent_tmo, ARPENT_TMO * 1000, 0);
   }
   else
   {
      ((struct intimer *)arp_timer)->tmo =
 823e2c4:	20800315 	stw	r2,12(r4)
              ((struct intimer *)arp_timer)->interval + lticks;
   }

   return oldest;
 823e2c8:	e0bffd17 	ldw	r2,-12(fp)
}
 823e2cc:	e037883a 	mov	sp,fp
 823e2d0:	dfc00117 	ldw	ra,4(sp)
 823e2d4:	df000017 	ldw	fp,0(sp)
 823e2d8:	dec00204 	addi	sp,sp,8
 823e2dc:	f800283a 	ret

0823e2e0 <arpReply>:
 * must be freed (or reused) herein. 
 */

void
arpReply(PACKET pkt)
{
 823e2e0:	defff704 	addi	sp,sp,-36
 823e2e4:	dfc00815 	stw	ra,32(sp)
 823e2e8:	df000715 	stw	fp,28(sp)
 823e2ec:	df000704 	addi	fp,sp,28
 823e2f0:	e13fff15 	stw	r4,-4(fp)
   struct arp_hdr *in;
   struct arp_hdr *out;
   char *ethout;
   char *ethin;

   LOCK_NET_RESOURCE(FREEQ_RESID);
 823e2f4:	01000084 	movi	r4,2
 823e2f8:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   outpkt = pk_alloc(arpsize);
 823e2fc:	01000c04 	movi	r4,48
 823e300:	822c9ec0 	call	822c9ec <pk_alloc>
 823e304:	e0bff915 	stw	r2,-28(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e308:	01000084 	movi	r4,2
 823e30c:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>

   if (!outpkt)
 823e310:	e0bff917 	ldw	r2,-28(fp)
 823e314:	1000021e 	bne	r2,zero,823e320 <arpReply+0x40>
   {
      dtrap();
 823e318:	822d5940 	call	822d594 <dtrap>
      return;
 823e31c:	00009b06 	br	823e58c <arpReply+0x2ac>
   }

   outpkt->net = pkt->net;    /* send back out the iface it came from */
 823e320:	e0bfff17 	ldw	r2,-4(fp)
 823e324:	10c00617 	ldw	r3,24(r2)
 823e328:	e0bff917 	ldw	r2,-28(fp)
 823e32c:	10c00615 	stw	r3,24(r2)

   ethin = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 823e330:	e0bfff17 	ldw	r2,-4(fp)
 823e334:	10800317 	ldw	r2,12(r2)
 823e338:	10bffc84 	addi	r2,r2,-14
 823e33c:	e0bffa15 	stw	r2,-24(fp)
   ethout = outpkt->nb_buff + ETHHDR_BIAS;
 823e340:	e0bff917 	ldw	r2,-28(fp)
 823e344:	10800117 	ldw	r2,4(r2)
 823e348:	10800084 	addi	r2,r2,2
 823e34c:	e0bffb15 	stw	r2,-20(fp)
      snap->type = ET_ARP;
   }
   else
#endif   /* IEEE_802_3 */
   {
      ET_TYPE_SET(ethout, ntohs(ET_ARP));   /* 0x0806 - ARP type on ethernet */
 823e350:	e0bffb17 	ldw	r2,-20(fp)
 823e354:	10800304 	addi	r2,r2,12
 823e358:	00c00204 	movi	r3,8
 823e35c:	10c00005 	stb	r3,0(r2)
 823e360:	e0bffb17 	ldw	r2,-20(fp)
 823e364:	10800344 	addi	r2,r2,13
 823e368:	00c00184 	movi	r3,6
 823e36c:	10c00005 	stb	r3,0(r2)
      in = (struct arp_hdr *)(pkt->nb_prot);
 823e370:	e0bfff17 	ldw	r2,-4(fp)
 823e374:	10800317 	ldw	r2,12(r2)
 823e378:	e0bffc15 	stw	r2,-16(fp)
      out = (struct arp_hdr *)(outpkt->nb_buff + ETHHDR_SIZE);
 823e37c:	e0bff917 	ldw	r2,-28(fp)
 823e380:	10800117 	ldw	r2,4(r2)
 823e384:	10800404 	addi	r2,r2,16
 823e388:	e0bffd15 	stw	r2,-12(fp)
      outpkt->nb_plen = arpsize;
 823e38c:	e0bff917 	ldw	r2,-28(fp)
 823e390:	00c00c04 	movi	r3,48
 823e394:	10c00415 	stw	r3,16(r2)

   /* prepare outgoing arp packet */
#ifdef IEEE_802_3
   out->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   out->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 823e398:	e0bffd17 	ldw	r2,-12(fp)
 823e39c:	00c04004 	movi	r3,256
 823e3a0:	10c0000d 	sth	r3,0(r2)
#endif /* IEEE_802_3 */

   out->ar_pro = ARPIP;
 823e3a4:	e0bffd17 	ldw	r2,-12(fp)
 823e3a8:	00c00204 	movi	r3,8
 823e3ac:	10c0008d 	sth	r3,2(r2)
   out->ar_hln = 6;
 823e3b0:	e0bffd17 	ldw	r2,-12(fp)
 823e3b4:	00c00184 	movi	r3,6
 823e3b8:	10c00105 	stb	r3,4(r2)
   out->ar_pln = 4;
 823e3bc:	e0bffd17 	ldw	r2,-12(fp)
 823e3c0:	00c00104 	movi	r3,4
 823e3c4:	10c00145 	stb	r3,5(r2)
   out->ar_op = ARREP;
 823e3c8:	e0bffd17 	ldw	r2,-12(fp)
 823e3cc:	00c08004 	movi	r3,512
 823e3d0:	10c0018d 	sth	r3,6(r2)
   out->ar_tpa = in->ar_spa;     /* swap IP addresses */
 823e3d4:	e0bffc17 	ldw	r2,-16(fp)
 823e3d8:	10c00417 	ldw	r3,16(r2)
 823e3dc:	e0bffd17 	ldw	r2,-12(fp)
 823e3e0:	10c00715 	stw	r3,28(r2)
   out->ar_spa = in->ar_tpa;
 823e3e4:	e0bffc17 	ldw	r2,-16(fp)
 823e3e8:	10c00717 	ldw	r3,28(r2)
 823e3ec:	e0bffd17 	ldw	r2,-12(fp)
 823e3f0:	10c00415 	stw	r3,16(r2)
   MEMMOVE(out->ar_tha, in->ar_sha, 6);    /* move his MAC address */
 823e3f4:	e0bffd17 	ldw	r2,-12(fp)
 823e3f8:	10c00504 	addi	r3,r2,20
 823e3fc:	e0bffc17 	ldw	r2,-16(fp)
 823e400:	10800204 	addi	r2,r2,8
 823e404:	01800184 	movi	r6,6
 823e408:	100b883a 	mov	r5,r2
 823e40c:	1809883a 	mov	r4,r3
 823e410:	82030580 	call	8203058 <memmove>
   MEMMOVE(out->ar_sha, outpkt->net->n_mib->ifPhysAddress, 6);  /* fill in our mac address */
 823e414:	e0bffd17 	ldw	r2,-12(fp)
 823e418:	10c00204 	addi	r3,r2,8
 823e41c:	e0bff917 	ldw	r2,-28(fp)
 823e420:	10800617 	ldw	r2,24(r2)
 823e424:	10802717 	ldw	r2,156(r2)
 823e428:	10800517 	ldw	r2,20(r2)
 823e42c:	01800184 	movi	r6,6
 823e430:	100b883a 	mov	r5,r2
 823e434:	1809883a 	mov	r4,r3
 823e438:	82030580 	call	8203058 <memmove>

   /* prepend ethernet unicast header to arp reply */
   MEMMOVE(ethout + ET_DSTOFF, ethin + ET_SRCOFF, 6);
 823e43c:	e0bffa17 	ldw	r2,-24(fp)
 823e440:	10800184 	addi	r2,r2,6
 823e444:	01800184 	movi	r6,6
 823e448:	100b883a 	mov	r5,r2
 823e44c:	e13ffb17 	ldw	r4,-20(fp)
 823e450:	82030580 	call	8203058 <memmove>
   MEMMOVE(ethout + ET_SRCOFF, outpkt->net->n_mib->ifPhysAddress, 6);
 823e454:	e0bffb17 	ldw	r2,-20(fp)
 823e458:	10c00184 	addi	r3,r2,6
 823e45c:	e0bff917 	ldw	r2,-28(fp)
 823e460:	10800617 	ldw	r2,24(r2)
 823e464:	10802717 	ldw	r2,156(r2)
 823e468:	10800517 	ldw	r2,20(r2)
 823e46c:	01800184 	movi	r6,6
 823e470:	100b883a 	mov	r5,r2
 823e474:	1809883a 	mov	r4,r3
 823e478:	82030580 	call	8203058 <memmove>

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)out;
 823e47c:	e0bffd17 	ldw	r2,-12(fp)
 823e480:	e0bffe15 	stw	r2,-8(fp)
      MEMMOVE(&arwp->data[AR_SHA], out->ar_sha, 6);
 823e484:	e0bffe17 	ldw	r2,-8(fp)
 823e488:	10c00204 	addi	r3,r2,8
 823e48c:	e0bffd17 	ldw	r2,-12(fp)
 823e490:	10800204 	addi	r2,r2,8
 823e494:	01800184 	movi	r6,6
 823e498:	100b883a 	mov	r5,r2
 823e49c:	1809883a 	mov	r4,r3
 823e4a0:	82030580 	call	8203058 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &out->ar_spa, 4);
 823e4a4:	e0bffe17 	ldw	r2,-8(fp)
 823e4a8:	10c00384 	addi	r3,r2,14
 823e4ac:	e0bffd17 	ldw	r2,-12(fp)
 823e4b0:	10800404 	addi	r2,r2,16
 823e4b4:	01800104 	movi	r6,4
 823e4b8:	100b883a 	mov	r5,r2
 823e4bc:	1809883a 	mov	r4,r3
 823e4c0:	82030580 	call	8203058 <memmove>
      MEMMOVE(&arwp->data[AR_THA], out->ar_tha, 6);
 823e4c4:	e0bffe17 	ldw	r2,-8(fp)
 823e4c8:	10c00484 	addi	r3,r2,18
 823e4cc:	e0bffd17 	ldw	r2,-12(fp)
 823e4d0:	10800504 	addi	r2,r2,20
 823e4d4:	01800184 	movi	r6,6
 823e4d8:	100b883a 	mov	r5,r2
 823e4dc:	1809883a 	mov	r4,r3
 823e4e0:	82030580 	call	8203058 <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &out->ar_tpa, 4);
 823e4e4:	e0bffe17 	ldw	r2,-8(fp)
 823e4e8:	10c00604 	addi	r3,r2,24
 823e4ec:	e0bffd17 	ldw	r2,-12(fp)
 823e4f0:	10800704 	addi	r2,r2,28
 823e4f4:	01800104 	movi	r6,4
 823e4f8:	100b883a 	mov	r5,r2
 823e4fc:	1809883a 	mov	r4,r3
 823e500:	82030580 	call	8203058 <memmove>
   }
#endif   /* NO_CC_PACKING */

   /* if a packet oriented send exists, use it: */
   if (outpkt->net->pkt_send)
 823e504:	e0bff917 	ldw	r2,-28(fp)
 823e508:	10800617 	ldw	r2,24(r2)
 823e50c:	10800417 	ldw	r2,16(r2)
 823e510:	10000a26 	beq	r2,zero,823e53c <arpReply+0x25c>
   {
      outpkt->nb_prot = outpkt->nb_buff;
 823e514:	e0bff917 	ldw	r2,-28(fp)
 823e518:	10c00117 	ldw	r3,4(r2)
 823e51c:	e0bff917 	ldw	r2,-28(fp)
 823e520:	10c00315 	stw	r3,12(r2)
      outpkt->net->pkt_send(outpkt);
 823e524:	e0bff917 	ldw	r2,-28(fp)
 823e528:	10800617 	ldw	r2,24(r2)
 823e52c:	10800417 	ldw	r2,16(r2)
 823e530:	e13ff917 	ldw	r4,-28(fp)
 823e534:	103ee83a 	callr	r2
 823e538:	00001106 	br	823e580 <arpReply+0x2a0>
   }
   else
   {
      outpkt->net->raw_send(pkt->net, outpkt->nb_buff, outpkt->nb_plen);
 823e53c:	e0bff917 	ldw	r2,-28(fp)
 823e540:	10800617 	ldw	r2,24(r2)
 823e544:	10800317 	ldw	r2,12(r2)
 823e548:	e0ffff17 	ldw	r3,-4(fp)
 823e54c:	19000617 	ldw	r4,24(r3)
 823e550:	e0fff917 	ldw	r3,-28(fp)
 823e554:	19400117 	ldw	r5,4(r3)
 823e558:	e0fff917 	ldw	r3,-28(fp)
 823e55c:	18c00417 	ldw	r3,16(r3)
 823e560:	180d883a 	mov	r6,r3
 823e564:	103ee83a 	callr	r2
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823e568:	01000084 	movi	r4,2
 823e56c:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free(outpkt);
 823e570:	e13ff917 	ldw	r4,-28(fp)
 823e574:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e578:	01000084 	movi	r4,2
 823e57c:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   }
   /* input 'pkt' will be freed by caller */
   arpRepsOut++;
 823e580:	d0a0c517 	ldw	r2,-31980(gp)
 823e584:	10800044 	addi	r2,r2,1
 823e588:	d0a0c515 	stw	r2,-31980(gp)
}
 823e58c:	e037883a 	mov	sp,fp
 823e590:	dfc00117 	ldw	ra,4(sp)
 823e594:	df000017 	ldw	fp,0(sp)
 823e598:	dec00204 	addi	sp,sp,8
 823e59c:	f800283a 	ret

0823e5a0 <arprcv>:
 *                            else a negative error code. 
 */

int
arprcv(PACKET pkt)
{
 823e5a0:	defff904 	addi	sp,sp,-28
 823e5a4:	dfc00615 	stw	ra,24(sp)
 823e5a8:	df000515 	stw	fp,20(sp)
 823e5ac:	df000504 	addi	fp,sp,20
 823e5b0:	e13fff15 	stw	r4,-4(fp)
   char *eth;
#ifdef IEEE_802_3
   int      ieee = FALSE;     /* TRUE if received packet is 802.3 */
#endif

   eth = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 823e5b4:	e0bfff17 	ldw	r2,-4(fp)
 823e5b8:	10800317 	ldw	r2,12(r2)
 823e5bc:	10bffc84 	addi	r2,r2,-14
 823e5c0:	e0bffc15 	stw	r2,-16(fp)
   arphdr = (struct arp_hdr *)(pkt->nb_prot);
 823e5c4:	e0bfff17 	ldw	r2,-4(fp)
 823e5c8:	10800317 	ldw	r2,12(r2)
 823e5cc:	e0bffd15 	stw	r2,-12(fp)
#endif   /* IEEE_802_3_ONLY */
#endif   /* IEEE_802_3 */

#ifdef NO_CC_PACKING    /* force ARP fields to local CPU valid boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 823e5d0:	e0bffd17 	ldw	r2,-12(fp)
 823e5d4:	e0bffe15 	stw	r2,-8(fp)
      MEMMOVE(&arphdr->ar_tpa, &arwp->data[AR_TPA], 4);
 823e5d8:	e0bffd17 	ldw	r2,-12(fp)
 823e5dc:	10c00704 	addi	r3,r2,28
 823e5e0:	e0bffe17 	ldw	r2,-8(fp)
 823e5e4:	10800604 	addi	r2,r2,24
 823e5e8:	01800104 	movi	r6,4
 823e5ec:	100b883a 	mov	r5,r2
 823e5f0:	1809883a 	mov	r4,r3
 823e5f4:	82030580 	call	8203058 <memmove>
      MEMMOVE(arphdr->ar_tha, &arwp->data[AR_THA], 6);
 823e5f8:	e0bffd17 	ldw	r2,-12(fp)
 823e5fc:	10c00504 	addi	r3,r2,20
 823e600:	e0bffe17 	ldw	r2,-8(fp)
 823e604:	10800484 	addi	r2,r2,18
 823e608:	01800184 	movi	r6,6
 823e60c:	100b883a 	mov	r5,r2
 823e610:	1809883a 	mov	r4,r3
 823e614:	82030580 	call	8203058 <memmove>
      MEMMOVE(&arphdr->ar_spa, &arwp->data[AR_SPA], 4);
 823e618:	e0bffd17 	ldw	r2,-12(fp)
 823e61c:	10c00404 	addi	r3,r2,16
 823e620:	e0bffe17 	ldw	r2,-8(fp)
 823e624:	10800384 	addi	r2,r2,14
 823e628:	01800104 	movi	r6,4
 823e62c:	100b883a 	mov	r5,r2
 823e630:	1809883a 	mov	r4,r3
 823e634:	82030580 	call	8203058 <memmove>
      MEMMOVE(arphdr->ar_sha, &arwp->data[AR_SHA], 6);
 823e638:	e0bffd17 	ldw	r2,-12(fp)
 823e63c:	10c00204 	addi	r3,r2,8
 823e640:	e0bffe17 	ldw	r2,-8(fp)
 823e644:	10800204 	addi	r2,r2,8
 823e648:	01800184 	movi	r6,6
 823e64c:	100b883a 	mov	r5,r2
 823e650:	1809883a 	mov	r4,r3
 823e654:	82030580 	call	8203058 <memmove>
#endif
   USE_ARG(eth);

   /* check ARP's target IP against our net's: */
#ifdef IP_MULTICAST
   if ((arphdr->ar_tpa != pkt->net->n_ipaddr) &&   /* if it's not for me.... */
 823e658:	e0bffd17 	ldw	r2,-12(fp)
 823e65c:	10c00717 	ldw	r3,28(r2)
 823e660:	e0bfff17 	ldw	r2,-4(fp)
 823e664:	10800617 	ldw	r2,24(r2)
 823e668:	10800a17 	ldw	r2,40(r2)
 823e66c:	18801c26 	beq	r3,r2,823e6e0 <arprcv+0x140>
     (!IN_MULTICAST(ntohl(arphdr->ar_tpa))))
 823e670:	e0bffd17 	ldw	r2,-12(fp)
 823e674:	10800717 	ldw	r2,28(r2)
 823e678:	1006d63a 	srli	r3,r2,24
 823e67c:	e0bffd17 	ldw	r2,-12(fp)
 823e680:	10800717 	ldw	r2,28(r2)
 823e684:	1004d23a 	srli	r2,r2,8
 823e688:	10bfc00c 	andi	r2,r2,65280
 823e68c:	1886b03a 	or	r3,r3,r2
 823e690:	e0bffd17 	ldw	r2,-12(fp)
 823e694:	10800717 	ldw	r2,28(r2)
 823e698:	10bfc00c 	andi	r2,r2,65280
 823e69c:	1004923a 	slli	r2,r2,8
 823e6a0:	1886b03a 	or	r3,r3,r2
 823e6a4:	e0bffd17 	ldw	r2,-12(fp)
 823e6a8:	10800717 	ldw	r2,28(r2)
 823e6ac:	1004963a 	slli	r2,r2,24
 823e6b0:	1884b03a 	or	r2,r3,r2
 823e6b4:	10fc002c 	andhi	r3,r2,61440
#endif
   USE_ARG(eth);

   /* check ARP's target IP against our net's: */
#ifdef IP_MULTICAST
   if ((arphdr->ar_tpa != pkt->net->n_ipaddr) &&   /* if it's not for me.... */
 823e6b8:	00b80034 	movhi	r2,57344
 823e6bc:	18800826 	beq	r3,r2,823e6e0 <arprcv+0x140>
     (!IN_MULTICAST(ntohl(arphdr->ar_tpa))))
#else
   if (arphdr->ar_tpa != pkt->net->n_ipaddr)
#endif /* IP_MULTICAST */
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823e6c0:	01000084 	movi	r4,2
 823e6c4:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free(pkt);     /* not for us, dump & ret (proxy here later?) */
 823e6c8:	e13fff17 	ldw	r4,-4(fp)
 823e6cc:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e6d0:	01000084 	movi	r4,2
 823e6d4:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return (ENP_NOT_MINE);
 823e6d8:	00800084 	movi	r2,2
 823e6dc:	00004406 	br	823e7f0 <arprcv+0x250>
   }

   if (arphdr->ar_op == ARREQ)   /* is it an arp request? */
 823e6e0:	e0bffd17 	ldw	r2,-12(fp)
 823e6e4:	1080018b 	ldhu	r2,6(r2)
 823e6e8:	10bfffcc 	andi	r2,r2,65535
 823e6ec:	10804018 	cmpnei	r2,r2,256
 823e6f0:	10000d1e 	bne	r2,zero,823e728 <arprcv+0x188>
   {
      arpReqsIn++;   /* count these */
 823e6f4:	d0a0c217 	ldw	r2,-31992(gp)
 823e6f8:	10800044 	addi	r2,r2,1
 823e6fc:	d0a0c215 	stw	r2,-31992(gp)
      arpReply(pkt); /* send arp reply */
 823e700:	e13fff17 	ldw	r4,-4(fp)
 823e704:	823e2e00 	call	823e2e0 <arpReply>
      /* make partial ARP table entry */
      make_arp_entry(arphdr->ar_spa, pkt->net);
 823e708:	e0bffd17 	ldw	r2,-12(fp)
 823e70c:	10c00417 	ldw	r3,16(r2)
 823e710:	e0bfff17 	ldw	r2,-4(fp)
 823e714:	10800617 	ldw	r2,24(r2)
 823e718:	100b883a 	mov	r5,r2
 823e71c:	1809883a 	mov	r4,r3
 823e720:	823e1e40 	call	823e1e4 <make_arp_entry>
 823e724:	00000306 	br	823e734 <arprcv+0x194>
      /* fall thru to arp reply logic to finish our table entry */
   }
   else     /* ARP reply, count and fall thru to logic to update table */
   {
      arpRepsIn++;
 823e728:	d0a0c417 	ldw	r2,-31984(gp)
 823e72c:	10800044 	addi	r2,r2,1
 823e730:	d0a0c415 	stw	r2,-31984(gp)
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823e734:	008209b4 	movhi	r2,2086
 823e738:	10ba1c04 	addi	r2,r2,-6032
 823e73c:	e0bffb15 	stw	r2,-20(fp)
 823e740:	00002006 	br	823e7c4 <arprcv+0x224>
   {
      if (tp->t_pro_addr == arphdr->ar_spa)     /* we found IP address, update entry */
 823e744:	e0bffb17 	ldw	r2,-20(fp)
 823e748:	10c00017 	ldw	r3,0(r2)
 823e74c:	e0bffd17 	ldw	r2,-12(fp)
 823e750:	10800417 	ldw	r2,16(r2)
 823e754:	1880181e 	bne	r3,r2,823e7b8 <arprcv+0x218>
            tp->flags |= ET_SNAP;
         else
            tp->flags |= ET_ETH2;      /* else it's ethernet II */
#endif   /* IEEE_802_3 */

         MEMMOVE(tp->t_phy_addr, arphdr->ar_sha, 6);   /* update MAC adddress */
 823e758:	e0bffb17 	ldw	r2,-20(fp)
 823e75c:	10c00104 	addi	r3,r2,4
 823e760:	e0bffd17 	ldw	r2,-12(fp)
 823e764:	10800204 	addi	r2,r2,8
 823e768:	01800184 	movi	r6,6
 823e76c:	100b883a 	mov	r5,r2
 823e770:	1809883a 	mov	r4,r3
 823e774:	82030580 	call	8203058 <memmove>
         tp->lasttime = cticks;
 823e778:	d0e0a817 	ldw	r3,-32096(gp)
 823e77c:	e0bffb17 	ldw	r2,-20(fp)
 823e780:	10c00615 	stw	r3,24(r2)
         if (tp->pending)     /* packet waiting for this IP entry? */
 823e784:	e0bffb17 	ldw	r2,-20(fp)
 823e788:	10800417 	ldw	r2,16(r2)
 823e78c:	10000226 	beq	r2,zero,823e798 <arprcv+0x1f8>
         {
            arp_send_pending(tp);
 823e790:	e13ffb17 	ldw	r4,-20(fp)
 823e794:	823dbb00 	call	823dbb0 <arp_send_pending>
         }
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823e798:	01000084 	movi	r4,2
 823e79c:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 823e7a0:	e13fff17 	ldw	r4,-4(fp)
 823e7a4:	822cd3c0 	call	822cd3c <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e7a8:	01000084 	movi	r4,2
 823e7ac:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>

         return (0);
 823e7b0:	0005883a 	mov	r2,zero
 823e7b4:	00000e06 	br	823e7f0 <arprcv+0x250>
      arpRepsIn++;
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823e7b8:	e0bffb17 	ldw	r2,-20(fp)
 823e7bc:	10800804 	addi	r2,r2,32
 823e7c0:	e0bffb15 	stw	r2,-20(fp)
 823e7c4:	e0fffb17 	ldw	r3,-20(fp)
 823e7c8:	008209b4 	movhi	r2,2086
 823e7cc:	10ba5c04 	addi	r2,r2,-5776
 823e7d0:	18bfdc36 	bltu	r3,r2,823e744 <arprcv+0x1a4>

#ifdef IEEE_802_3_ONLY
drop:
#endif /* IEEE_802_3_ONLY */
   /* fall to here if packet is not in table */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 823e7d4:	01000084 	movi	r4,2
 823e7d8:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   pk_free(pkt);
 823e7dc:	e13fff17 	ldw	r4,-4(fp)
 823e7e0:	822cd3c0 	call	822cd3c <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e7e4:	01000084 	movi	r4,2
 823e7e8:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>

   return ENP_NOT_MINE;
 823e7ec:	00800084 	movi	r2,2
}
 823e7f0:	e037883a 	mov	sp,fp
 823e7f4:	dfc00117 	ldw	ra,4(sp)
 823e7f8:	df000017 	ldw	fp,0(sp)
 823e7fc:	dec00204 	addi	sp,sp,8
 823e800:	f800283a 	ret

0823e804 <send_via_arp>:
 * change the PC's IP address. 
 */

int
send_via_arp(PACKET pkt, ip_addr dest_ip)
{
 823e804:	defff804 	addi	sp,sp,-32
 823e808:	dfc00715 	stw	ra,28(sp)
 823e80c:	df000615 	stw	fp,24(sp)
 823e810:	df000604 	addi	fp,sp,24
 823e814:	e13ffe15 	stw	r4,-8(fp)
 823e818:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *tp;
   unsigned long lticks = cticks;
 823e81c:	d0a0a817 	ldw	r2,-32096(gp)
 823e820:	e0bffd15 	stw	r2,-12(fp)
   int err;

   /* don't allow zero dest */
   if (dest_ip == 0)
 823e824:	e0bfff17 	ldw	r2,-4(fp)
 823e828:	1000081e 	bne	r2,zero,823e84c <send_via_arp+0x48>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823e82c:	01000084 	movi	r4,2
 823e830:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 823e834:	e13ffe17 	ldw	r4,-8(fp)
 823e838:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e83c:	01000084 	movi	r4,2
 823e840:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return SEND_DROPPED; 
 823e844:	00bffa84 	movi	r2,-22
 823e848:	00004906 	br	823e970 <send_via_arp+0x16c>
   }

   /* Force refresh of cache once a second */
   if ((lticks - cachetime) > TPS)
 823e84c:	d0a0c117 	ldw	r2,-31996(gp)
 823e850:	e0fffd17 	ldw	r3,-12(fp)
 823e854:	1885c83a 	sub	r2,r3,r2
 823e858:	10801970 	cmpltui	r2,r2,101
 823e85c:	1000011e 	bne	r2,zero,823e864 <send_via_arp+0x60>
      arpcache = (struct arptabent *)NULL;
 823e860:	d020c015 	stw	zero,-32000(gp)

   /* look at the last ARP entry used. Good chance it's ours: */
   if (arpcache && (arpcache->t_pro_addr == dest_ip))
 823e864:	d0a0c017 	ldw	r2,-32000(gp)
 823e868:	10000726 	beq	r2,zero,823e888 <send_via_arp+0x84>
 823e86c:	d0a0c017 	ldw	r2,-32000(gp)
 823e870:	10c00017 	ldw	r3,0(r2)
 823e874:	e0bfff17 	ldw	r2,-4(fp)
 823e878:	1880031e 	bne	r3,r2,823e888 <send_via_arp+0x84>
      tp = arpcache;
 823e87c:	d0a0c017 	ldw	r2,-32000(gp)
 823e880:	e0bffa15 	stw	r2,-24(fp)
 823e884:	00000306 	br	823e894 <send_via_arp+0x90>
   else
   {
      /* scan arp table for an existing entry */
      tp = find_oldest_arp(dest_ip);
 823e888:	e13fff17 	ldw	r4,-4(fp)
 823e88c:	823e0780 	call	823e078 <find_oldest_arp>
 823e890:	e0bffa15 	stw	r2,-24(fp)
   }

   if (tp->t_pro_addr == dest_ip)   /* we found our entry */
 823e894:	e0bffa17 	ldw	r2,-24(fp)
 823e898:	10c00017 	ldw	r3,0(r2)
 823e89c:	e0bfff17 	ldw	r2,-4(fp)
 823e8a0:	18802e1e 	bne	r3,r2,823e95c <send_via_arp+0x158>
   {
      if (tp->pending)  /* arp already pending for this IP? */
 823e8a4:	e0bffa17 	ldw	r2,-24(fp)
 823e8a8:	10800417 	ldw	r2,16(r2)
 823e8ac:	10002226 	beq	r2,zero,823e938 <send_via_arp+0x134>
      {
         if (lilfreeq.q_len < 2)
 823e8b0:	008209b4 	movhi	r2,2086
 823e8b4:	10b87d04 	addi	r2,r2,-7692
 823e8b8:	10800217 	ldw	r2,8(r2)
 823e8bc:	10800088 	cmpgei	r2,r2,2
 823e8c0:	1000091e 	bne	r2,zero,823e8e8 <send_via_arp+0xe4>
         {
            /* system is depleted of resources - free the
             * pkt instead of queueing it - so that we are in a
             * position to receive an arp reply 
             */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 823e8c4:	01000084 	movi	r4,2
 823e8c8:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
            pk_free(pkt);  /* sorry, we have to dump this one.. */
 823e8cc:	e13ffe17 	ldw	r4,-8(fp)
 823e8d0:	822cd3c0 	call	822cd3c <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e8d4:	01000084 	movi	r4,2
 823e8d8:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
            err = SEND_DROPPED;    /* pkts already waiting for this IP entry */
 823e8dc:	00bffa84 	movi	r2,-22
 823e8e0:	e0bffb15 	stw	r2,-20(fp)
 823e8e4:	00002106 	br	823e96c <send_via_arp+0x168>
         }
         else
         {
            PACKET tmppkt=tp->pending;
 823e8e8:	e0bffa17 	ldw	r2,-24(fp)
 823e8ec:	10800417 	ldw	r2,16(r2)
 823e8f0:	e0bffc15 	stw	r2,-16(fp)

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 823e8f4:	00000306 	br	823e904 <send_via_arp+0x100>
               tmppkt = tmppkt->next;
 823e8f8:	e0bffc17 	ldw	r2,-16(fp)
 823e8fc:	10800017 	ldw	r2,0(r2)
 823e900:	e0bffc15 	stw	r2,-16(fp)
         else
         {
            PACKET tmppkt=tp->pending;

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 823e904:	e0bffc17 	ldw	r2,-16(fp)
 823e908:	10800017 	ldw	r2,0(r2)
 823e90c:	103ffa1e 	bne	r2,zero,823e8f8 <send_via_arp+0xf4>
               tmppkt = tmppkt->next;
            tmppkt->next = pkt;      /* add new pkt to end of list */
 823e910:	e0bffc17 	ldw	r2,-16(fp)
 823e914:	e0fffe17 	ldw	r3,-8(fp)
 823e918:	10c00015 	stw	r3,0(r2)
            if (pkt->next)
 823e91c:	e0bffe17 	ldw	r2,-8(fp)
 823e920:	10800017 	ldw	r2,0(r2)
 823e924:	10000126 	beq	r2,zero,823e92c <send_via_arp+0x128>
            {
               dtrap();              /* chain of pkts to be sent ??? */
 823e928:	822d5940 	call	822d594 <dtrap>
            }
            err = ENP_SEND_PENDING; /* packet queued pending ARP reply */
 823e92c:	00800044 	movi	r2,1
 823e930:	e0bffb15 	stw	r2,-20(fp)
 823e934:	00000d06 	br	823e96c <send_via_arp+0x168>
         }
      }
      else  /* just send it */
      {
         arpcache = tp;       /* cache this entry */
 823e938:	e0bffa17 	ldw	r2,-24(fp)
 823e93c:	d0a0c015 	stw	r2,-32000(gp)
         cachetime = lticks;  /* mark time we cached */
 823e940:	e0bffd17 	ldw	r2,-12(fp)
 823e944:	d0a0c115 	stw	r2,-31996(gp)
         err = et_send(pkt, tp);
 823e948:	e17ffa17 	ldw	r5,-24(fp)
 823e94c:	e13ffe17 	ldw	r4,-8(fp)
 823e950:	823d9a80 	call	823d9a8 <et_send>
 823e954:	e0bffb15 	stw	r2,-20(fp)
 823e958:	00000406 	br	823e96c <send_via_arp+0x168>
      }
   }
   else
      /* start the ARP process for this IP address */
      err = send_arp(pkt, dest_ip);
 823e95c:	e17fff17 	ldw	r5,-4(fp)
 823e960:	e13ffe17 	ldw	r4,-8(fp)
 823e964:	823dc240 	call	823dc24 <send_arp>
 823e968:	e0bffb15 	stw	r2,-20(fp)

   return (err);
 823e96c:	e0bffb17 	ldw	r2,-20(fp)
}
 823e970:	e037883a 	mov	sp,fp
 823e974:	dfc00117 	ldw	ra,4(sp)
 823e978:	df000017 	ldw	fp,0(sp)
 823e97c:	dec00204 	addi	sp,sp,8
 823e980:	f800283a 	ret

0823e984 <cb_arpent_tmo>:
 *
 * If there are no more unresolved entries, cancel the timer.
 */
void
cb_arpent_tmo(long arg)
{
 823e984:	defffa04 	addi	sp,sp,-24
 823e988:	dfc00515 	stw	ra,20(sp)
 823e98c:	df000415 	stw	fp,16(sp)
 823e990:	df000404 	addi	fp,sp,16
 823e994:	e13fff15 	stw	r4,-4(fp)
   struct arptabent *tp;
   int arp_count = 0;
 823e998:	e03ffd15 	stw	zero,-12(fp)
   unsigned long lticks = cticks;
 823e99c:	d0a0a817 	ldw	r2,-32096(gp)
 823e9a0:	e0bffe15 	stw	r2,-8(fp)

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823e9a4:	008209b4 	movhi	r2,2086
 823e9a8:	10ba1c04 	addi	r2,r2,-6032
 823e9ac:	e0bffc15 	stw	r2,-16(fp)
 823e9b0:	00002706 	br	823ea50 <cb_arpent_tmo+0xcc>
   {
      if (tp->t_pro_addr != 0)
 823e9b4:	e0bffc17 	ldw	r2,-16(fp)
 823e9b8:	10800017 	ldw	r2,0(r2)
 823e9bc:	10002126 	beq	r2,zero,823ea44 <cb_arpent_tmo+0xc0>
      {
         /* age out old, pending entries */
         if (tp->pending && ((lticks - tp->createtime) > TPS))
 823e9c0:	e0bffc17 	ldw	r2,-16(fp)
 823e9c4:	10800417 	ldw	r2,16(r2)
 823e9c8:	10000b26 	beq	r2,zero,823e9f8 <cb_arpent_tmo+0x74>
 823e9cc:	e0bffc17 	ldw	r2,-16(fp)
 823e9d0:	10800517 	ldw	r2,20(r2)
 823e9d4:	e0fffe17 	ldw	r3,-8(fp)
 823e9d8:	1885c83a 	sub	r2,r3,r2
 823e9dc:	10801970 	cmpltui	r2,r2,101
 823e9e0:	1000051e 	bne	r2,zero,823e9f8 <cb_arpent_tmo+0x74>
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
 823e9e4:	e13ffc17 	ldw	r4,-16(fp)
 823e9e8:	823db280 	call	823db28 <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 823e9ec:	e0bffc17 	ldw	r2,-16(fp)
 823e9f0:	10000015 	stw	zero,0(r2)
 823e9f4:	00001306 	br	823ea44 <cb_arpent_tmo+0xc0>
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 823e9f8:	e0bffc17 	ldw	r2,-16(fp)
 823e9fc:	10800517 	ldw	r2,20(r2)
 823ea00:	e0fffe17 	ldw	r3,-8(fp)
 823ea04:	1885c83a 	sub	r2,r3,r2
 823ea08:	1007883a 	mov	r3,r2
 823ea0c:	d0a04f17 	ldw	r2,-32452(gp)
 823ea10:	18800916 	blt	r3,r2,823ea38 <cb_arpent_tmo+0xb4>
                  ((int)(lticks - tp->lasttime)   >= TPS))
 823ea14:	e0bffc17 	ldw	r2,-16(fp)
 823ea18:	10800617 	ldw	r2,24(r2)
 823ea1c:	e0fffe17 	ldw	r3,-8(fp)
 823ea20:	1885c83a 	sub	r2,r3,r2
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 823ea24:	10801910 	cmplti	r2,r2,100
 823ea28:	1000031e 	bne	r2,zero,823ea38 <cb_arpent_tmo+0xb4>
                  ((int)(lticks - tp->lasttime)   >= TPS))
         {
            /* entry has "expired" and has not been reference in 1 sec. */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 823ea2c:	e0bffc17 	ldw	r2,-16(fp)
 823ea30:	10000015 	stw	zero,0(r2)
 823ea34:	00000306 	br	823ea44 <cb_arpent_tmo+0xc0>
         }
         else
            arp_count++;
 823ea38:	e0bffd17 	ldw	r2,-12(fp)
 823ea3c:	10800044 	addi	r2,r2,1
 823ea40:	e0bffd15 	stw	r2,-12(fp)
{
   struct arptabent *tp;
   int arp_count = 0;
   unsigned long lticks = cticks;

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823ea44:	e0bffc17 	ldw	r2,-16(fp)
 823ea48:	10800804 	addi	r2,r2,32
 823ea4c:	e0bffc15 	stw	r2,-16(fp)
 823ea50:	e0fffc17 	ldw	r3,-16(fp)
 823ea54:	008209b4 	movhi	r2,2086
 823ea58:	10ba5c04 	addi	r2,r2,-5776
 823ea5c:	18bfd536 	bltu	r3,r2,823e9b4 <cb_arpent_tmo+0x30>
            arp_count++;
      }
   }

   /* if there are no more "pending" entries, kill the timer */
   if (arp_count == 0)
 823ea60:	e0bffd17 	ldw	r2,-12(fp)
 823ea64:	1000041e 	bne	r2,zero,823ea78 <cb_arpent_tmo+0xf4>
   {
      in_timerkill(arp_timer);
 823ea68:	d0a0bf17 	ldw	r2,-32004(gp)
 823ea6c:	1009883a 	mov	r4,r2
 823ea70:	823d7840 	call	823d784 <in_timerkill>
      arp_timer = 0;
 823ea74:	d020bf15 	stw	zero,-32004(gp)
   }
      
   USE_ARG(arg);
}
 823ea78:	0001883a 	nop
 823ea7c:	e037883a 	mov	sp,fp
 823ea80:	dfc00117 	ldw	ra,4(sp)
 823ea84:	df000017 	ldw	fp,0(sp)
 823ea88:	dec00204 	addi	sp,sp,8
 823ea8c:	f800283a 	ret

0823ea90 <grat_arp>:
 * RETURNS: Returns 0 if OK, or the usual ENP_ errors 
 */

int
grat_arp(NET net, int flag)
{
 823ea90:	defff704 	addi	sp,sp,-36
 823ea94:	dfc00815 	stw	ra,32(sp)
 823ea98:	df000715 	stw	fp,28(sp)
 823ea9c:	df000704 	addi	fp,sp,28
 823eaa0:	e13ffe15 	stw	r4,-8(fp)
 823eaa4:	e17fff15 	stw	r5,-4(fp)
   char * ethhdr;
   struct arp_hdr *  arphdr;
   IFMIB etif = net->n_mib;    /* mib info for this ethernet interface */
 823eaa8:	e0bffe17 	ldw	r2,-8(fp)
 823eaac:	10802717 	ldw	r2,156(r2)
 823eab0:	e0bff915 	stw	r2,-28(fp)
   PACKET arppkt;

   /* get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 823eab4:	01000084 	movi	r4,2
 823eab8:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 823eabc:	01000c04 	movi	r4,48
 823eac0:	822c9ec0 	call	822c9ec <pk_alloc>
 823eac4:	e0bffa15 	stw	r2,-24(fp)
   if (!arppkt)
 823eac8:	e0bffa17 	ldw	r2,-24(fp)
 823eacc:	1000041e 	bne	r2,zero,823eae0 <grat_arp+0x50>
   {
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823ead0:	01000084 	movi	r4,2
 823ead4:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 823ead8:	00bffa84 	movi	r2,-22
 823eadc:	00009506 	br	823ed34 <grat_arp+0x2a4>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823eae0:	01000084 	movi	r4,2
 823eae4:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 823eae8:	e0bffa17 	ldw	r2,-24(fp)
 823eaec:	10c00117 	ldw	r3,4(r2)
 823eaf0:	e0bffa17 	ldw	r2,-24(fp)
 823eaf4:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 823eaf8:	e0bffa17 	ldw	r2,-24(fp)
 823eafc:	00c00c04 	movi	r3,48
 823eb00:	10c00415 	stw	r3,16(r2)
   arppkt->net = net;
 823eb04:	e0bffa17 	ldw	r2,-24(fp)
 823eb08:	e0fffe17 	ldw	r3,-8(fp)
 823eb0c:	10c00615 	stw	r3,24(r2)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 823eb10:	e0bffa17 	ldw	r2,-24(fp)
 823eb14:	10800117 	ldw	r2,4(r2)
 823eb18:	10800084 	addi	r2,r2,2
 823eb1c:	e0bffb15 	stw	r2,-20(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 823eb20:	e0bffa17 	ldw	r2,-24(fp)
 823eb24:	10800117 	ldw	r2,4(r2)
 823eb28:	10800404 	addi	r2,r2,16
 823eb2c:	e0bffc15 	stw	r2,-16(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 823eb30:	e0bffc17 	ldw	r2,-16(fp)
 823eb34:	00c04004 	movi	r3,256
 823eb38:	10c0000d 	sth	r3,0(r2)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 823eb3c:	e0bffc17 	ldw	r2,-16(fp)
 823eb40:	00c00204 	movi	r3,8
 823eb44:	10c0008d 	sth	r3,2(r2)
   arphdr->ar_hln = 6;
 823eb48:	e0bffc17 	ldw	r2,-16(fp)
 823eb4c:	00c00184 	movi	r3,6
 823eb50:	10c00105 	stb	r3,4(r2)
   arphdr->ar_pln = 4;
 823eb54:	e0bffc17 	ldw	r2,-16(fp)
 823eb58:	00c00104 	movi	r3,4
 823eb5c:	10c00145 	stb	r3,5(r2)
   
   /* ARP req? */
   if (flag == 0)
 823eb60:	e0bfff17 	ldw	r2,-4(fp)
 823eb64:	1000041e 	bne	r2,zero,823eb78 <grat_arp+0xe8>
      /* yup */
      arphdr->ar_op = ARREQ;
 823eb68:	e0bffc17 	ldw	r2,-16(fp)
 823eb6c:	00c04004 	movi	r3,256
 823eb70:	10c0018d 	sth	r3,6(r2)
 823eb74:	00000306 	br	823eb84 <grat_arp+0xf4>
   else
     /* nope */
      arphdr->ar_op = ARREP;
 823eb78:	e0bffc17 	ldw	r2,-16(fp)
 823eb7c:	00c08004 	movi	r3,512
 823eb80:	10c0018d 	sth	r3,6(r2)
      
   arphdr->ar_tpa = net->n_ipaddr;        /* target's IP address */
 823eb84:	e0bffe17 	ldw	r2,-8(fp)
 823eb88:	10c00a17 	ldw	r3,40(r2)
 823eb8c:	e0bffc17 	ldw	r2,-16(fp)
 823eb90:	10c00715 	stw	r3,28(r2)
   arphdr->ar_spa = net->n_ipaddr;   /* my IP address */
 823eb94:	e0bffe17 	ldw	r2,-8(fp)
 823eb98:	10c00a17 	ldw	r3,40(r2)
 823eb9c:	e0bffc17 	ldw	r2,-16(fp)
 823eba0:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 823eba4:	e0bffc17 	ldw	r2,-16(fp)
 823eba8:	10c00204 	addi	r3,r2,8
 823ebac:	e0bff917 	ldw	r2,-28(fp)
 823ebb0:	10800517 	ldw	r2,20(r2)
 823ebb4:	01800184 	movi	r6,6
 823ebb8:	100b883a 	mov	r5,r2
 823ebbc:	1809883a 	mov	r4,r3
 823ebc0:	82030580 	call	8203058 <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 823ebc4:	01800184 	movi	r6,6
 823ebc8:	01403fc4 	movi	r5,255
 823ebcc:	e13ffb17 	ldw	r4,-20(fp)
 823ebd0:	82031b40 	call	82031b4 <memset>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 823ebd4:	e0bffb17 	ldw	r2,-20(fp)
 823ebd8:	10c00184 	addi	r3,r2,6
 823ebdc:	e0bff917 	ldw	r2,-28(fp)
 823ebe0:	10800517 	ldw	r2,20(r2)
 823ebe4:	01800184 	movi	r6,6
 823ebe8:	100b883a 	mov	r5,r2
 823ebec:	1809883a 	mov	r4,r3
 823ebf0:	82030580 	call	8203058 <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 823ebf4:	e0bffb17 	ldw	r2,-20(fp)
 823ebf8:	10800304 	addi	r2,r2,12
 823ebfc:	00c00204 	movi	r3,8
 823ec00:	10c00005 	stb	r3,0(r2)
 823ec04:	e0bffb17 	ldw	r2,-20(fp)
 823ec08:	10800344 	addi	r2,r2,13
 823ec0c:	00c00184 	movi	r3,6
 823ec10:	10c00005 	stb	r3,0(r2)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 823ec14:	e0bffc17 	ldw	r2,-16(fp)
 823ec18:	e0bffd15 	stw	r2,-12(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 823ec1c:	e0bffd17 	ldw	r2,-12(fp)
 823ec20:	10c00204 	addi	r3,r2,8
 823ec24:	e0bffc17 	ldw	r2,-16(fp)
 823ec28:	10800204 	addi	r2,r2,8
 823ec2c:	01800184 	movi	r6,6
 823ec30:	100b883a 	mov	r5,r2
 823ec34:	1809883a 	mov	r4,r3
 823ec38:	82030580 	call	8203058 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 823ec3c:	e0bffd17 	ldw	r2,-12(fp)
 823ec40:	10c00384 	addi	r3,r2,14
 823ec44:	e0bffc17 	ldw	r2,-16(fp)
 823ec48:	10800404 	addi	r2,r2,16
 823ec4c:	01800104 	movi	r6,4
 823ec50:	100b883a 	mov	r5,r2
 823ec54:	1809883a 	mov	r4,r3
 823ec58:	82030580 	call	8203058 <memmove>

   /* ARP req? */
   if (flag == 0)
 823ec5c:	e0bfff17 	ldw	r2,-4(fp)
 823ec60:	1000091e 	bne	r2,zero,823ec88 <grat_arp+0x1f8>
      /* yup */      
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 823ec64:	e0bffd17 	ldw	r2,-12(fp)
 823ec68:	10c00484 	addi	r3,r2,18
 823ec6c:	e0bffc17 	ldw	r2,-16(fp)
 823ec70:	10800504 	addi	r2,r2,20
 823ec74:	01800184 	movi	r6,6
 823ec78:	100b883a 	mov	r5,r2
 823ec7c:	1809883a 	mov	r4,r3
 823ec80:	82030580 	call	8203058 <memmove>
 823ec84:	00000806 	br	823eca8 <grat_arp+0x218>
   else
      /* nope */
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_sha, 6);
 823ec88:	e0bffd17 	ldw	r2,-12(fp)
 823ec8c:	10c00484 	addi	r3,r2,18
 823ec90:	e0bffc17 	ldw	r2,-16(fp)
 823ec94:	10800204 	addi	r2,r2,8
 823ec98:	01800184 	movi	r6,6
 823ec9c:	100b883a 	mov	r5,r2
 823eca0:	1809883a 	mov	r4,r3
 823eca4:	82030580 	call	8203058 <memmove>
      
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 823eca8:	e0bffd17 	ldw	r2,-12(fp)
 823ecac:	10c00604 	addi	r3,r2,24
 823ecb0:	e0bffc17 	ldw	r2,-16(fp)
 823ecb4:	10800704 	addi	r2,r2,28
 823ecb8:	01800104 	movi	r6,4
 823ecbc:	100b883a 	mov	r5,r2
 823ecc0:	1809883a 	mov	r4,r3
 823ecc4:	82030580 	call	8203058 <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 823ecc8:	e0bffe17 	ldw	r2,-8(fp)
 823eccc:	10800417 	ldw	r2,16(r2)
 823ecd0:	10000526 	beq	r2,zero,823ece8 <grat_arp+0x258>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 823ecd4:	e0bffe17 	ldw	r2,-8(fp)
 823ecd8:	10800417 	ldw	r2,16(r2)
 823ecdc:	e13ffa17 	ldw	r4,-24(fp)
 823ece0:	103ee83a 	callr	r2
 823ece4:	00000f06 	br	823ed24 <grat_arp+0x294>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 823ece8:	e0bffe17 	ldw	r2,-8(fp)
 823ecec:	10800317 	ldw	r2,12(r2)
 823ecf0:	e0fffa17 	ldw	r3,-24(fp)
 823ecf4:	19000617 	ldw	r4,24(r3)
 823ecf8:	e0fffa17 	ldw	r3,-24(fp)
 823ecfc:	18c00117 	ldw	r3,4(r3)
 823ed00:	01800c04 	movi	r6,48
 823ed04:	180b883a 	mov	r5,r3
 823ed08:	103ee83a 	callr	r2
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823ed0c:	01000084 	movi	r4,2
 823ed10:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 823ed14:	e13ffa17 	ldw	r4,-24(fp)
 823ed18:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823ed1c:	01000084 	movi	r4,2
 823ed20:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 823ed24:	d0a0c317 	ldw	r2,-31988(gp)
 823ed28:	10800044 	addi	r2,r2,1
 823ed2c:	d0a0c315 	stw	r2,-31988(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 823ed30:	00800044 	movi	r2,1
}
 823ed34:	e037883a 	mov	sp,fp
 823ed38:	dfc00117 	ldw	ra,4(sp)
 823ed3c:	df000017 	ldw	fp,0(sp)
 823ed40:	dec00204 	addi	sp,sp,8
 823ed44:	f800283a 	ret

0823ed48 <if_getbynum>:
 * RETURNS: Returns NET pointer, or NULL if out of range
 */

NET
if_getbynum(int ifnum)
{
 823ed48:	defffc04 	addi	sp,sp,-16
 823ed4c:	dfc00315 	stw	ra,12(sp)
 823ed50:	df000215 	stw	fp,8(sp)
 823ed54:	df000204 	addi	fp,sp,8
 823ed58:	e13fff15 	stw	r4,-4(fp)
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823ed5c:	008209b4 	movhi	r2,2086
 823ed60:	10ba5c04 	addi	r2,r2,-5776
 823ed64:	10800017 	ldw	r2,0(r2)
 823ed68:	e0bffe15 	stw	r2,-8(fp)
 823ed6c:	00000906 	br	823ed94 <if_getbynum+0x4c>
   {
      if(ifnum-- == 0)
 823ed70:	e0bfff17 	ldw	r2,-4(fp)
 823ed74:	10ffffc4 	addi	r3,r2,-1
 823ed78:	e0ffff15 	stw	r3,-4(fp)
 823ed7c:	1000021e 	bne	r2,zero,823ed88 <if_getbynum+0x40>
         return ifp;
 823ed80:	e0bffe17 	ldw	r2,-8(fp)
 823ed84:	00000706 	br	823eda4 <if_getbynum+0x5c>

NET
if_getbynum(int ifnum)
{
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823ed88:	e0bffe17 	ldw	r2,-8(fp)
 823ed8c:	10800017 	ldw	r2,0(r2)
 823ed90:	e0bffe15 	stw	r2,-8(fp)
 823ed94:	e0bffe17 	ldw	r2,-8(fp)
 823ed98:	103ff51e 	bne	r2,zero,823ed70 <if_getbynum+0x28>
   {
      if(ifnum-- == 0)
         return ifp;
   }
   dtrap();
 823ed9c:	822d5940 	call	822d594 <dtrap>
   return NULL;   /* list is not long enough */
 823eda0:	0005883a 	mov	r2,zero
}
 823eda4:	e037883a 	mov	sp,fp
 823eda8:	dfc00117 	ldw	ra,4(sp)
 823edac:	df000017 	ldw	fp,0(sp)
 823edb0:	dec00204 	addi	sp,sp,8
 823edb4:	f800283a 	ret

0823edb8 <isbcast>:
 * RETURNS:  Returns TRUE if broadcast, else false. 
 */

int
isbcast(NET ifc, unsigned char * addr)
{
 823edb8:	defffd04 	addi	sp,sp,-12
 823edbc:	df000215 	stw	fp,8(sp)
 823edc0:	df000204 	addi	fp,sp,8
 823edc4:	e13ffe15 	stw	r4,-8(fp)
 823edc8:	e17fff15 	stw	r5,-4(fp)
#if (ALIGN_TYPE > 2)
   /* On systems with 32bit alignment requirements we have to make
    * sure our tests are aligned. Specifically, this results in "data
    * abort" errors on the Samsung/ARM port. 
    */
   if((u_long)addr & (ALIGN_TYPE - 1))
 823edcc:	e0bfff17 	ldw	r2,-4(fp)
 823edd0:	108000cc 	andi	r2,r2,3
 823edd4:	10000e26 	beq	r2,zero,823ee10 <isbcast+0x58>
   {
      /* check first two bytes */
      if ((u_short)*(u_short*)(addr) != 0xFFFF)
 823edd8:	e0bfff17 	ldw	r2,-4(fp)
 823eddc:	1080000b 	ldhu	r2,0(r2)
 823ede0:	10ffffcc 	andi	r3,r2,65535
 823ede4:	00bfffd4 	movui	r2,65535
 823ede8:	18800226 	beq	r3,r2,823edf4 <isbcast+0x3c>
         return(FALSE);
 823edec:	0005883a 	mov	r2,zero
 823edf0:	00002206 	br	823ee7c <isbcast+0xc4>
      if ((u_long)(*(u_long*)(addr + 2)) != 0xFFFFFFFF)
 823edf4:	e0bfff17 	ldw	r2,-4(fp)
 823edf8:	10800084 	addi	r2,r2,2
 823edfc:	10800017 	ldw	r2,0(r2)
 823ee00:	10bfffe0 	cmpeqi	r2,r2,-1
 823ee04:	1000101e 	bne	r2,zero,823ee48 <isbcast+0x90>
         return FALSE;
 823ee08:	0005883a 	mov	r2,zero
 823ee0c:	00001b06 	br	823ee7c <isbcast+0xc4>
#endif /* ALIGN_TYPE > 4 */
   {
      /* check first four bytes for all ones. Since this is the fastest
       * test, do it first
       */
      if ((u_long)(*(u_long*)addr) != 0xFFFFFFFF)
 823ee10:	e0bfff17 	ldw	r2,-4(fp)
 823ee14:	10800017 	ldw	r2,0(r2)
 823ee18:	10bfffe0 	cmpeqi	r2,r2,-1
 823ee1c:	1000021e 	bne	r2,zero,823ee28 <isbcast+0x70>
         return FALSE;
 823ee20:	0005883a 	mov	r2,zero
 823ee24:	00001506 	br	823ee7c <isbcast+0xc4>

      /* check last two bytes */
      if ((u_short)*(u_short*)(addr+4) != 0xFFFF)
 823ee28:	e0bfff17 	ldw	r2,-4(fp)
 823ee2c:	10800104 	addi	r2,r2,4
 823ee30:	1080000b 	ldhu	r2,0(r2)
 823ee34:	10ffffcc 	andi	r3,r2,65535
 823ee38:	00bfffd4 	movui	r2,65535
 823ee3c:	18800226 	beq	r3,r2,823ee48 <isbcast+0x90>
         return(FALSE);
 823ee40:	0005883a 	mov	r2,zero
 823ee44:	00000d06 	br	823ee7c <isbcast+0xc4>
   }
   
   /* now reject any line type packets which don't support broadcast */
   if ((ifc->n_mib->ifType == PPP) ||
 823ee48:	e0bffe17 	ldw	r2,-8(fp)
 823ee4c:	10802717 	ldw	r2,156(r2)
 823ee50:	10800217 	ldw	r2,8(r2)
 823ee54:	108005e0 	cmpeqi	r2,r2,23
 823ee58:	1000051e 	bne	r2,zero,823ee70 <isbcast+0xb8>
       (ifc->n_mib->ifType == SLIP))
 823ee5c:	e0bffe17 	ldw	r2,-8(fp)
 823ee60:	10802717 	ldw	r2,156(r2)
 823ee64:	10800217 	ldw	r2,8(r2)
      if ((u_short)*(u_short*)(addr+4) != 0xFFFF)
         return(FALSE);
   }
   
   /* now reject any line type packets which don't support broadcast */
   if ((ifc->n_mib->ifType == PPP) ||
 823ee68:	10800718 	cmpnei	r2,r2,28
 823ee6c:	1000021e 	bne	r2,zero,823ee78 <isbcast+0xc0>
       (ifc->n_mib->ifType == SLIP))
   {
      return FALSE;
 823ee70:	0005883a 	mov	r2,zero
 823ee74:	00000106 	br	823ee7c <isbcast+0xc4>
   }

   /* passed all tests, must be broadcast */
   return(TRUE);
 823ee78:	00800044 	movi	r2,1
}
 823ee7c:	e037883a 	mov	sp,fp
 823ee80:	df000017 	ldw	fp,0(sp)
 823ee84:	dec00104 	addi	sp,sp,4
 823ee88:	f800283a 	ret

0823ee8c <reg_type>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
reg_type(unshort type)
{
 823ee8c:	defffb04 	addi	sp,sp,-20
 823ee90:	dfc00415 	stw	ra,16(sp)
 823ee94:	df000315 	stw	fp,12(sp)
 823ee98:	df000304 	addi	fp,sp,12
 823ee9c:	2005883a 	mov	r2,r4
 823eea0:	e0bfff0d 	sth	r2,-4(fp)
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823eea4:	008209b4 	movhi	r2,2086
 823eea8:	10ba5c04 	addi	r2,r2,-5776
 823eeac:	10800017 	ldw	r2,0(r2)
 823eeb0:	e0bffd15 	stw	r2,-12(fp)
 823eeb4:	00001106 	br	823eefc <reg_type+0x70>
   {
      if (ifp->n_reg_type)    /* make sure call exists */
 823eeb8:	e0bffd17 	ldw	r2,-12(fp)
 823eebc:	10800617 	ldw	r2,24(r2)
 823eec0:	10000b26 	beq	r2,zero,823eef0 <reg_type+0x64>
      {
         e = (ifp->n_reg_type)(type, ifp);
 823eec4:	e0bffd17 	ldw	r2,-12(fp)
 823eec8:	10800617 	ldw	r2,24(r2)
 823eecc:	e0ffff0b 	ldhu	r3,-4(fp)
 823eed0:	e17ffd17 	ldw	r5,-12(fp)
 823eed4:	1809883a 	mov	r4,r3
 823eed8:	103ee83a 	callr	r2
 823eedc:	e0bffe15 	stw	r2,-8(fp)
         if (e)
 823eee0:	e0bffe17 	ldw	r2,-8(fp)
 823eee4:	10000226 	beq	r2,zero,823eef0 <reg_type+0x64>
            return e;   /* bails out if error */
 823eee8:	e0bffe17 	ldw	r2,-8(fp)
 823eeec:	00000606 	br	823ef08 <reg_type+0x7c>
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823eef0:	e0bffd17 	ldw	r2,-12(fp)
 823eef4:	10800017 	ldw	r2,0(r2)
 823eef8:	e0bffd15 	stw	r2,-12(fp)
 823eefc:	e0bffd17 	ldw	r2,-12(fp)
 823ef00:	103fed1e 	bne	r2,zero,823eeb8 <reg_type+0x2c>
         e = (ifp->n_reg_type)(type, ifp);
         if (e)
            return e;   /* bails out if error */
      }
   }
   return 0;   /* OK code */
 823ef04:	0005883a 	mov	r2,zero
}
 823ef08:	e037883a 	mov	sp,fp
 823ef0c:	dfc00117 	ldw	ra,4(sp)
 823ef10:	df000017 	ldw	fp,0(sp)
 823ef14:	dec00204 	addi	sp,sp,8
 823ef18:	f800283a 	ret

0823ef1c <if_killsocks>:
 */

      /* kill this NETs sockets */
void
if_killsocks(NET ifp)
{
 823ef1c:	defffa04 	addi	sp,sp,-24
 823ef20:	dfc00515 	stw	ra,20(sp)
 823ef24:	df000415 	stw	fp,16(sp)
 823ef28:	df000404 	addi	fp,sp,16
 823ef2c:	e13fff15 	stw	r4,-4(fp)
   struct socket * so;
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
 823ef30:	008209b4 	movhi	r2,2086
 823ef34:	10b95804 	addi	r2,r2,-6816
 823ef38:	10800017 	ldw	r2,0(r2)
 823ef3c:	e0bffc15 	stw	r2,-16(fp)
   while(so)
 823ef40:	00001306 	br	823ef90 <if_killsocks+0x74>
   {
      if(so->so_pcb)
 823ef44:	e0bffc17 	ldw	r2,-16(fp)
 823ef48:	10800117 	ldw	r2,4(r2)
 823ef4c:	10000526 	beq	r2,zero,823ef64 <if_killsocks+0x48>
         so_ifp = so->so_pcb->ifp;
 823ef50:	e0bffc17 	ldw	r2,-16(fp)
 823ef54:	10800117 	ldw	r2,4(r2)
 823ef58:	10800a17 	ldw	r2,40(r2)
 823ef5c:	e0bffd15 	stw	r2,-12(fp)
 823ef60:	00000106 	br	823ef68 <if_killsocks+0x4c>
      else
         so_ifp = NULL;
 823ef64:	e03ffd15 	stw	zero,-12(fp)
      next = (struct socket *)so->next;
 823ef68:	e0bffc17 	ldw	r2,-16(fp)
 823ef6c:	10800017 	ldw	r2,0(r2)
 823ef70:	e0bffe15 	stw	r2,-8(fp)
      if (so_ifp == ifp)
 823ef74:	e0fffd17 	ldw	r3,-12(fp)
 823ef78:	e0bfff17 	ldw	r2,-4(fp)
 823ef7c:	1880021e 	bne	r3,r2,823ef88 <if_killsocks+0x6c>
      {
         /* this is a direct heavy-handed close. A reset is sent
          * and all data is lost. The user should really have closed
          * all the sockets gracfully first.... 
          */
         soabort(so);
 823ef80:	e13ffc17 	ldw	r4,-16(fp)
 823ef84:	82320d40 	call	82320d4 <soabort>
      }
      so = next;
 823ef88:	e0bffe17 	ldw	r2,-8(fp)
 823ef8c:	e0bffc15 	stw	r2,-16(fp)
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
   while(so)
 823ef90:	e0bffc17 	ldw	r2,-16(fp)
 823ef94:	103feb1e 	bne	r2,zero,823ef44 <if_killsocks+0x28>
          */
         soabort(so);
      }
      so = next;
   }
}
 823ef98:	0001883a 	nop
 823ef9c:	e037883a 	mov	sp,fp
 823efa0:	dfc00117 	ldw	ra,4(sp)
 823efa4:	df000017 	ldw	fp,0(sp)
 823efa8:	dec00204 	addi	sp,sp,8
 823efac:	f800283a 	ret

0823efb0 <ip_init>:
 * OK, else returns a non-zero error code. 
 */

int
ip_init(void)
{
 823efb0:	defffe04 	addi	sp,sp,-8
 823efb4:	dfc00115 	stw	ra,4(sp)
 823efb8:	df000015 	stw	fp,0(sp)
 823efbc:	d839883a 	mov	fp,sp

   /* register IP type with link layer drivers */
   if (reg_type(IP_TYPE) != 0)
 823efc0:	01000204 	movi	r4,8
 823efc4:	823ee8c0 	call	823ee8c <reg_type>
 823efc8:	10000526 	beq	r2,zero,823efe0 <ip_init+0x30>
   {   
#ifdef NPDEBUG
      dprintf("IP_INIT: unable to register type with MAC driver\n");
 823efcc:	01020974 	movhi	r4,2085
 823efd0:	21045d04 	addi	r4,r4,4468
 823efd4:	82036240 	call	8203624 <puts>
#endif
      return(1);
 823efd8:	00800044 	movi	r2,1
 823efdc:	00002906 	br	823f084 <ip_init+0xd4>
   }

   /* initialize the IP mib */
   MEMSET(&ip_mib, 0, sizeof(ip_mib));
 823efe0:	01801404 	movi	r6,80
 823efe4:	000b883a 	mov	r5,zero
 823efe8:	010209b4 	movhi	r4,2086
 823efec:	213a6104 	addi	r4,r4,-5756
 823eff0:	82031b40 	call	82031b4 <memset>
   ip_mib.ipForwarding = 2;   /* default to host, not gateway (router) */
 823eff4:	008209b4 	movhi	r2,2086
 823eff8:	10ba6104 	addi	r2,r2,-5756
 823effc:	00c00084 	movi	r3,2
 823f000:	10c00015 	stw	r3,0(r2)
   ip_mib.ipDefaultTTL = IP_TTL;
 823f004:	008209b4 	movhi	r2,2086
 823f008:	10ba6104 	addi	r2,r2,-5756
 823f00c:	00c01004 	movi	r3,64
 823f010:	10c00115 	stw	r3,4(r2)

#ifdef IP_ROUTING
   /* alloc space for the route table */
   rt_mib = (struct RtMib*)RT_ALLOC(ipRoutes * sizeof(struct RtMib));
 823f014:	d0a05117 	ldw	r2,-32444(gp)
 823f018:	10800f24 	muli	r2,r2,60
 823f01c:	1009883a 	mov	r4,r2
 823f020:	822e16c0 	call	822e16c <npalloc>
 823f024:	d0a0c615 	stw	r2,-31976(gp)
   if (!rt_mib)
 823f028:	d0a0c617 	ldw	r2,-31976(gp)
 823f02c:	1000051e 	bne	r2,zero,823f044 <ip_init+0x94>
   {
#ifdef NPDEBUG
      dprintf("IP_INIT ERROR: can't alloc route table\n");
 823f030:	01020974 	movhi	r4,2085
 823f034:	21046a04 	addi	r4,r4,4520
 823f038:	82036240 	call	8203624 <puts>
#endif   /* NPDEBUG */
      return(ENP_NOMEM);
 823f03c:	00bffb04 	movi	r2,-20
 823f040:	00001006 	br	823f084 <ip_init+0xd4>
   }

  MEMSET(rt_mib,0, ipRoutes * sizeof(struct RtMib)) ;
 823f044:	d0e0c617 	ldw	r3,-31976(gp)
 823f048:	d0a05117 	ldw	r2,-32444(gp)
 823f04c:	10800f24 	muli	r2,r2,60
 823f050:	100d883a 	mov	r6,r2
 823f054:	000b883a 	mov	r5,zero
 823f058:	1809883a 	mov	r4,r3
 823f05c:	82031b40 	call	82031b4 <memset>
  ip_mib.ipForwarding = 1;   /* override default, be gateway (router) */
 823f060:	008209b4 	movhi	r2,2086
 823f064:	10ba6104 	addi	r2,r2,-5756
 823f068:	00c00044 	movi	r3,1
 823f06c:	10c00015 	stw	r3,0(r2)
#endif   /* IP_ROUTING */

   /* set IP reassembly timeout */
   ip_mib.ipReasmTimeout = IRE_TMO;
 823f070:	008209b4 	movhi	r2,2086
 823f074:	10ba6104 	addi	r2,r2,-5756
 823f078:	00c01e04 	movi	r3,120
 823f07c:	10c00c15 	stw	r3,48(r2)
      return(1);
   }
#endif   /* IPSEC */

   /* everything opened OK return 0 */
   return(SUCCESS);
 823f080:	0005883a 	mov	r2,zero
}
 823f084:	e037883a 	mov	sp,fp
 823f088:	dfc00117 	ldw	ra,4(sp)
 823f08c:	df000017 	ldw	fp,0(sp)
 823f090:	dec00204 	addi	sp,sp,8
 823f094:	f800283a 	ret

0823f098 <ip_bldhead>:
 * RETURNS: void
 */

void
ip_bldhead(PACKET p, unsigned pid, u_char prot, unshort fragword)
{
 823f098:	defff804 	addi	sp,sp,-32
 823f09c:	dfc00715 	stw	ra,28(sp)
 823f0a0:	df000615 	stw	fp,24(sp)
 823f0a4:	df000604 	addi	fp,sp,24
 823f0a8:	e13ffc15 	stw	r4,-16(fp)
 823f0ac:	e17ffd15 	stw	r5,-12(fp)
 823f0b0:	3007883a 	mov	r3,r6
 823f0b4:	3805883a 	mov	r2,r7
 823f0b8:	e0fffe05 	stb	r3,-8(fp)
 823f0bc:	e0bfff0d 	sth	r2,-4(fp)
   struct ip * pip;
   struct ip_socopts *sopts;

   /* prepend IP header to packet data */
   p->nb_prot -= sizeof(struct ip);       /* this assumes no send options! */
 823f0c0:	e0bffc17 	ldw	r2,-16(fp)
 823f0c4:	10800317 	ldw	r2,12(r2)
 823f0c8:	10fffb04 	addi	r3,r2,-20
 823f0cc:	e0bffc17 	ldw	r2,-16(fp)
 823f0d0:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 823f0d4:	e0bffc17 	ldw	r2,-16(fp)
 823f0d8:	10800417 	ldw	r2,16(r2)
 823f0dc:	10c00504 	addi	r3,r2,20
 823f0e0:	e0bffc17 	ldw	r2,-16(fp)
 823f0e4:	10c00415 	stw	r3,16(r2)

   pip = (struct ip*)p->nb_prot;
 823f0e8:	e0bffc17 	ldw	r2,-16(fp)
 823f0ec:	10800317 	ldw	r2,12(r2)
 823f0f0:	e0bffa15 	stw	r2,-24(fp)

   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 823f0f4:	e0bffa17 	ldw	r2,-24(fp)
 823f0f8:	00c01144 	movi	r3,69
 823f0fc:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = fragword; /* fragment flags and offset */
 823f100:	e0bffa17 	ldw	r2,-24(fp)
 823f104:	e0ffff0b 	ldhu	r3,-4(fp)
 823f108:	10c0018d 	sth	r3,6(r2)
   pip->ip_id = htons((unshort)pid);   /* IP datagram ID */
 823f10c:	e0bffd17 	ldw	r2,-12(fp)
 823f110:	10bfffcc 	andi	r2,r2,65535
 823f114:	1005d23a 	srai	r2,r2,8
 823f118:	10803fcc 	andi	r2,r2,255
 823f11c:	1007883a 	mov	r3,r2
 823f120:	e0bffd17 	ldw	r2,-12(fp)
 823f124:	10bfffcc 	andi	r2,r2,65535
 823f128:	1004923a 	slli	r2,r2,8
 823f12c:	1884b03a 	or	r2,r3,r2
 823f130:	1007883a 	mov	r3,r2
 823f134:	e0bffa17 	ldw	r2,-24(fp)
 823f138:	10c0010d 	sth	r3,4(r2)
   pip->ip_len = htons((unshort)p->nb_plen);
 823f13c:	e0bffc17 	ldw	r2,-16(fp)
 823f140:	10800417 	ldw	r2,16(r2)
 823f144:	10bfffcc 	andi	r2,r2,65535
 823f148:	1005d23a 	srai	r2,r2,8
 823f14c:	10803fcc 	andi	r2,r2,255
 823f150:	1007883a 	mov	r3,r2
 823f154:	e0bffc17 	ldw	r2,-16(fp)
 823f158:	10800417 	ldw	r2,16(r2)
 823f15c:	10bfffcc 	andi	r2,r2,65535
 823f160:	1004923a 	slli	r2,r2,8
 823f164:	1884b03a 	or	r2,r3,r2
 823f168:	1007883a 	mov	r3,r2
 823f16c:	e0bffa17 	ldw	r2,-24(fp)
 823f170:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;          /* install protocol ID (TCP, UDP, etc) */
 823f174:	e0bffa17 	ldw	r2,-24(fp)
 823f178:	e0fffe03 	ldbu	r3,-8(fp)
 823f17c:	10c00245 	stb	r3,9(r2)

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 823f180:	e0bffc17 	ldw	r2,-16(fp)
 823f184:	10800c17 	ldw	r2,48(r2)
 823f188:	e0bffb15 	stw	r2,-20(fp)
 823f18c:	e0bffb17 	ldw	r2,-20(fp)
 823f190:	10001126 	beq	r2,zero,823f1d8 <ip_bldhead+0x140>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 823f194:	e0bffb17 	ldw	r2,-20(fp)
 823f198:	10800043 	ldbu	r2,1(r2)
 823f19c:	10803fcc 	andi	r2,r2,255
 823f1a0:	10000526 	beq	r2,zero,823f1b8 <ip_bldhead+0x120>
         pip->ip_time = sopts->ip_ttl;
 823f1a4:	e0bffb17 	ldw	r2,-20(fp)
 823f1a8:	10c00043 	ldbu	r3,1(r2)
 823f1ac:	e0bffa17 	ldw	r2,-24(fp)
 823f1b0:	10c00205 	stb	r3,8(r2)
 823f1b4:	00000306 	br	823f1c4 <ip_bldhead+0x12c>
	  else
         pip->ip_time = (u_char)IP_TTL;     /* default number of hops, really */
 823f1b8:	e0bffa17 	ldw	r2,-24(fp)
 823f1bc:	00c01004 	movi	r3,64
 823f1c0:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = sopts->ip_tos;
 823f1c4:	e0bffb17 	ldw	r2,-20(fp)
 823f1c8:	10c00003 	ldbu	r3,0(r2)
 823f1cc:	e0bffa17 	ldw	r2,-24(fp)
 823f1d0:	10c00045 	stb	r3,1(r2)
 823f1d4:	00000506 	br	823f1ec <ip_bldhead+0x154>
   }
   else
   {
	  /* nope */
      pip->ip_time = (u_char)IP_TTL;       /* default number of hops, really */
 823f1d8:	e0bffa17 	ldw	r2,-24(fp)
 823f1dc:	00c01004 	movi	r3,64
 823f1e0:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 823f1e4:	e0bffa17 	ldw	r2,-24(fp)
 823f1e8:	10000045 	stb	zero,1(r2)
   }
   
   pip->ip_chksum = IPXSUM;      /* clear checksum field for summing */
 823f1ec:	e0bffa17 	ldw	r2,-24(fp)
 823f1f0:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 823f1f4:	01400284 	movi	r5,10
 823f1f8:	e13ffa17 	ldw	r4,-24(fp)
 823f1fc:	82287b40 	call	82287b4 <cksum>
 823f200:	0084303a 	nor	r2,zero,r2
 823f204:	1007883a 	mov	r3,r2
 823f208:	e0bffa17 	ldw	r2,-24(fp)
 823f20c:	10c0028d 	sth	r3,10(r2)
}
 823f210:	0001883a 	nop
 823f214:	e037883a 	mov	sp,fp
 823f218:	dfc00117 	ldw	ra,4(sp)
 823f21c:	df000017 	ldw	fp,0(sp)
 823f220:	dec00204 	addi	sp,sp,8
 823f224:	f800283a 	ret

0823f228 <ip_write_internal>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_write_internal(PACKET p)
{
 823f228:	defff004 	addi	sp,sp,-64
 823f22c:	dfc00f15 	stw	ra,60(sp)
 823f230:	df000e15 	stw	fp,56(sp)
 823f234:	df000e04 	addi	fp,sp,56
 823f238:	e13fff15 	stw	r4,-4(fp)
   PACKET newpkt;
   unsigned maxbuflen;

#ifdef IP_MULTICAST
   /* If destination address is multicast, process multicast options */
   if (IN_MULTICAST(ntohl(p->fhost)))
 823f23c:	e0bfff17 	ldw	r2,-4(fp)
 823f240:	10800717 	ldw	r2,28(r2)
 823f244:	1006d63a 	srli	r3,r2,24
 823f248:	e0bfff17 	ldw	r2,-4(fp)
 823f24c:	10800717 	ldw	r2,28(r2)
 823f250:	1004d23a 	srli	r2,r2,8
 823f254:	10bfc00c 	andi	r2,r2,65280
 823f258:	1886b03a 	or	r3,r3,r2
 823f25c:	e0bfff17 	ldw	r2,-4(fp)
 823f260:	10800717 	ldw	r2,28(r2)
 823f264:	10bfc00c 	andi	r2,r2,65280
 823f268:	1004923a 	slli	r2,r2,8
 823f26c:	1886b03a 	or	r3,r3,r2
 823f270:	e0bfff17 	ldw	r2,-4(fp)
 823f274:	10800717 	ldw	r2,28(r2)
 823f278:	1004963a 	slli	r2,r2,24
 823f27c:	1884b03a 	or	r2,r3,r2
 823f280:	10fc002c 	andhi	r3,r2,61440
 823f284:	00b80034 	movhi	r2,57344
 823f288:	1880a81e 	bne	r3,r2,823f52c <ip_write_internal+0x304>
   {
      if (p->imo != NULL)
 823f28c:	e0bfff17 	ldw	r2,-4(fp)
 823f290:	10800b17 	ldw	r2,44(r2)
 823f294:	10001426 	beq	r2,zero,823f2e8 <ip_write_internal+0xc0>
         if (p->imo->imo_multicast_netp)
 823f298:	e0bfff17 	ldw	r2,-4(fp)
 823f29c:	10800b17 	ldw	r2,44(r2)
 823f2a0:	10800017 	ldw	r2,0(r2)
 823f2a4:	10000626 	beq	r2,zero,823f2c0 <ip_write_internal+0x98>
            p->net = p->imo->imo_multicast_netp;
 823f2a8:	e0bfff17 	ldw	r2,-4(fp)
 823f2ac:	10800b17 	ldw	r2,44(r2)
 823f2b0:	10c00017 	ldw	r3,0(r2)
 823f2b4:	e0bfff17 	ldw	r2,-4(fp)
 823f2b8:	10c00615 	stw	r3,24(r2)
 823f2bc:	00002506 	br	823f354 <ip_write_internal+0x12c>
         else
            p->net = iproute(p->fhost, &firsthop);
 823f2c0:	e0bfff17 	ldw	r2,-4(fp)
 823f2c4:	10800717 	ldw	r2,28(r2)
 823f2c8:	e0fffe04 	addi	r3,fp,-8
 823f2cc:	180b883a 	mov	r5,r3
 823f2d0:	1009883a 	mov	r4,r2
 823f2d4:	8240ce80 	call	8240ce8 <iproute>
 823f2d8:	1007883a 	mov	r3,r2
 823f2dc:	e0bfff17 	ldw	r2,-4(fp)
 823f2e0:	10c00615 	stw	r3,24(r2)
 823f2e4:	00001b06 	br	823f354 <ip_write_internal+0x12c>
      else
      {
         for (i = 0; i < ifNumber; i++)
 823f2e8:	e03ff515 	stw	zero,-44(fp)
 823f2ec:	00001606 	br	823f348 <ip_write_internal+0x120>
            if (nets[i]->n_mcastlist)
 823f2f0:	008209b4 	movhi	r2,2086
 823f2f4:	10b81b04 	addi	r2,r2,-8084
 823f2f8:	e0fff517 	ldw	r3,-44(fp)
 823f2fc:	18c7883a 	add	r3,r3,r3
 823f300:	18c7883a 	add	r3,r3,r3
 823f304:	10c5883a 	add	r2,r2,r3
 823f308:	10800017 	ldw	r2,0(r2)
 823f30c:	10802b17 	ldw	r2,172(r2)
 823f310:	10000a26 	beq	r2,zero,823f33c <ip_write_internal+0x114>
            {
               p->net = nets[i];
 823f314:	008209b4 	movhi	r2,2086
 823f318:	10b81b04 	addi	r2,r2,-8084
 823f31c:	e0fff517 	ldw	r3,-44(fp)
 823f320:	18c7883a 	add	r3,r3,r3
 823f324:	18c7883a 	add	r3,r3,r3
 823f328:	10c5883a 	add	r2,r2,r3
 823f32c:	10c00017 	ldw	r3,0(r2)
 823f330:	e0bfff17 	ldw	r2,-4(fp)
 823f334:	10c00615 	stw	r3,24(r2)
               break;
 823f338:	00000606 	br	823f354 <ip_write_internal+0x12c>
            p->net = p->imo->imo_multicast_netp;
         else
            p->net = iproute(p->fhost, &firsthop);
      else
      {
         for (i = 0; i < ifNumber; i++)
 823f33c:	e0bff517 	ldw	r2,-44(fp)
 823f340:	10800044 	addi	r2,r2,1
 823f344:	e0bff515 	stw	r2,-44(fp)
 823f348:	d0a08417 	ldw	r2,-32240(gp)
 823f34c:	e0fff517 	ldw	r3,-44(fp)
 823f350:	18bfe736 	bltu	r3,r2,823f2f0 <ip_write_internal+0xc8>
               break;
            }
      }

      /* Confirm that the outgoing interface supports multicast. */
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
 823f354:	e0bfff17 	ldw	r2,-4(fp)
 823f358:	10800617 	ldw	r2,24(r2)
 823f35c:	10000426 	beq	r2,zero,823f370 <ip_write_internal+0x148>
 823f360:	e0bfff17 	ldw	r2,-4(fp)
 823f364:	10800617 	ldw	r2,24(r2)
 823f368:	10802b17 	ldw	r2,172(r2)
 823f36c:	10002c1e 	bne	r2,zero,823f420 <ip_write_internal+0x1f8>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 823f370:	d0a08317 	ldw	r2,-32244(gp)
 823f374:	1080840c 	andi	r2,r2,528
 823f378:	10001a26 	beq	r2,zero,823f3e4 <ip_write_internal+0x1bc>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f37c:	e0bfff17 	ldw	r2,-4(fp)
 823f380:	11400417 	ldw	r5,16(r2)
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f384:	e0bfff17 	ldw	r2,-4(fp)
 823f388:	10800717 	ldw	r2,28(r2)
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f38c:	11803fcc 	andi	r6,r2,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f390:	e0bfff17 	ldw	r2,-4(fp)
 823f394:	10800717 	ldw	r2,28(r2)
 823f398:	1004d23a 	srli	r2,r2,8
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f39c:	10803fcc 	andi	r2,r2,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f3a0:	e0ffff17 	ldw	r3,-4(fp)
 823f3a4:	18c00717 	ldw	r3,28(r3)
 823f3a8:	1806d43a 	srli	r3,r3,16
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f3ac:	18c03fcc 	andi	r3,r3,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f3b0:	e13fff17 	ldw	r4,-4(fp)
 823f3b4:	21000717 	ldw	r4,28(r4)
 823f3b8:	2008d63a 	srli	r4,r4,24
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f3bc:	d9000215 	stw	r4,8(sp)
 823f3c0:	d8c00115 	stw	r3,4(sp)
 823f3c4:	d8800015 	stw	r2,0(sp)
 823f3c8:	300f883a 	mov	r7,r6
 823f3cc:	280d883a 	mov	r6,r5
 823f3d0:	e17fff17 	ldw	r5,-4(fp)
 823f3d4:	01020974 	movhi	r4,2085
 823f3d8:	21047404 	addi	r4,r4,4560
 823f3dc:	82033a00 	call	82033a0 <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 823f3e0:	822d5940 	call	822d594 <dtrap>
         }
#endif
         ip_mib.ipOutNoRoutes++;
 823f3e4:	008209b4 	movhi	r2,2086
 823f3e8:	10ba6104 	addi	r2,r2,-5756
 823f3ec:	10800b17 	ldw	r2,44(r2)
 823f3f0:	10c00044 	addi	r3,r2,1
 823f3f4:	008209b4 	movhi	r2,2086
 823f3f8:	10ba6104 	addi	r2,r2,-5756
 823f3fc:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f400:	01000084 	movi	r4,2
 823f404:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
         pk_free(p);
 823f408:	e13fff17 	ldw	r4,-4(fp)
 823f40c:	822cd3c0 	call	822cd3c <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f410:	01000084 	movi	r4,2
 823f414:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 823f418:	00bff7c4 	movi	r2,-33
 823f41c:	00014606 	br	823f938 <ip_write_internal+0x710>
       * If we belong to the destination multicast group
       * on the outgoing interface, and the caller did not
       * forbid loopback, put a copy of the packet on the
       * received queue.
       */
      inm = lookup_mcast(p->fhost, p->net);
 823f420:	e0bfff17 	ldw	r2,-4(fp)
 823f424:	10c00717 	ldw	r3,28(r2)
 823f428:	e0bfff17 	ldw	r2,-4(fp)
 823f42c:	10800617 	ldw	r2,24(r2)
 823f430:	100b883a 	mov	r5,r2
 823f434:	1809883a 	mov	r4,r3
 823f438:	8243ba80 	call	8243ba8 <lookup_mcast>
 823f43c:	e0bff715 	stw	r2,-36(fp)
      if ((inm != NULL) &&
 823f440:	e0bff717 	ldw	r2,-36(fp)
 823f444:	10001b26 	beq	r2,zero,823f4b4 <ip_write_internal+0x28c>
          ((p->imo == NULL) || p->imo->imo_multicast_loop)) 
 823f448:	e0bfff17 	ldw	r2,-4(fp)
 823f44c:	10800b17 	ldw	r2,44(r2)
       * on the outgoing interface, and the caller did not
       * forbid loopback, put a copy of the packet on the
       * received queue.
       */
      inm = lookup_mcast(p->fhost, p->net);
      if ((inm != NULL) &&
 823f450:	10000526 	beq	r2,zero,823f468 <ip_write_internal+0x240>
          ((p->imo == NULL) || p->imo->imo_multicast_loop)) 
 823f454:	e0bfff17 	ldw	r2,-4(fp)
 823f458:	10800b17 	ldw	r2,44(r2)
 823f45c:	10800143 	ldbu	r2,5(r2)
 823f460:	10803fcc 	andi	r2,r2,255
 823f464:	10001326 	beq	r2,zero,823f4b4 <ip_write_internal+0x28c>
      {
         p->type = IPTP;
 823f468:	e0bfff17 	ldw	r2,-4(fp)
 823f46c:	00c00204 	movi	r3,8
 823f470:	10c0080d 	sth	r3,32(r2)
         pkt2 = ip_copypkt(p);
 823f474:	e13fff17 	ldw	r4,-4(fp)
 823f478:	8240ec00 	call	8240ec0 <ip_copypkt>
 823f47c:	e0bff815 	stw	r2,-32(fp)
         if (pkt2)
 823f480:	e0bff817 	ldw	r2,-32(fp)
 823f484:	10000b26 	beq	r2,zero,823f4b4 <ip_write_internal+0x28c>
         {
            LOCK_NET_RESOURCE(RXQ_RESID);
 823f488:	01000044 	movi	r4,1
 823f48c:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
            putq(&rcvdq, (q_elt)pkt2);
 823f490:	e17ff817 	ldw	r5,-32(fp)
 823f494:	010209b4 	movhi	r4,2086
 823f498:	21375604 	addi	r4,r4,-8872
 823f49c:	822cf7c0 	call	822cf7c <putq>
            UNLOCK_NET_RESOURCE(RXQ_RESID);
 823f4a0:	01000044 	movi	r4,1
 823f4a4:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
            SignalPktDemux();
 823f4a8:	d0a0ab17 	ldw	r2,-32084(gp)
 823f4ac:	1009883a 	mov	r4,r2
 823f4b0:	821a44c0 	call	821a44c <OSSemPost>
       * Also, multicasts addressed to the loopback interface
       * are not sent -- a copy will already have been looped
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
 823f4b4:	e0bfff17 	ldw	r2,-4(fp)
 823f4b8:	10800317 	ldw	r2,12(r2)
 823f4bc:	e0bff915 	stw	r2,-28(fp)
      if ((pip->ip_time == 0) || 
 823f4c0:	e0bff917 	ldw	r2,-28(fp)
 823f4c4:	10800203 	ldbu	r2,8(r2)
 823f4c8:	10803fcc 	andi	r2,r2,255
 823f4cc:	10000b26 	beq	r2,zero,823f4fc <ip_write_internal+0x2d4>
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
 823f4d0:	e0bfff17 	ldw	r2,-4(fp)
 823f4d4:	10800717 	ldw	r2,28(r2)
 823f4d8:	10803fcc 	andi	r2,r2,255
       * are not sent -- a copy will already have been looped
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
      if ((pip->ip_time == 0) || 
 823f4dc:	10801fe0 	cmpeqi	r2,r2,127
 823f4e0:	1000061e 	bne	r2,zero,823f4fc <ip_write_internal+0x2d4>
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
          (p->fhost == p->net->n_ipaddr))
 823f4e4:	e0bfff17 	ldw	r2,-4(fp)
 823f4e8:	10c00717 	ldw	r3,28(r2)
 823f4ec:	e0bfff17 	ldw	r2,-4(fp)
 823f4f0:	10800617 	ldw	r2,24(r2)
 823f4f4:	10800a17 	ldw	r2,40(r2)
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
      if ((pip->ip_time == 0) || 
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
 823f4f8:	1880081e 	bne	r3,r2,823f51c <ip_write_internal+0x2f4>
          (p->fhost == p->net->n_ipaddr))
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f4fc:	01000084 	movi	r4,2
 823f500:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
         pk_free(p);
 823f504:	e13fff17 	ldw	r4,-4(fp)
 823f508:	822cd3c0 	call	822cd3c <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f50c:	01000084 	movi	r4,2
 823f510:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return(SUCCESS);
 823f514:	0005883a 	mov	r2,zero
 823f518:	00010706 	br	823f938 <ip_write_internal+0x710>
      }

      firsthop = p->fhost;
 823f51c:	e0bfff17 	ldw	r2,-4(fp)
 823f520:	10800717 	ldw	r2,28(r2)
 823f524:	e0bffe15 	stw	r2,-8(fp)

      goto sendit;
 823f528:	00004006 	br	823f62c <ip_write_internal+0x404>
   }

#endif /* IP_MULTICAST */

   /* if this is a broadcast packet, use the caller-selected network */
   if (p->fhost == 0xFFFFFFFF)
 823f52c:	e0bfff17 	ldw	r2,-4(fp)
 823f530:	10800717 	ldw	r2,28(r2)
 823f534:	10bfffd8 	cmpnei	r2,r2,-1
 823f538:	1000041e 	bne	r2,zero,823f54c <ip_write_internal+0x324>
   {
      firsthop = p->fhost;
 823f53c:	e0bfff17 	ldw	r2,-4(fp)
 823f540:	10800717 	ldw	r2,28(r2)
 823f544:	e0bffe15 	stw	r2,-8(fp)
 823f548:	00003806 	br	823f62c <ip_write_internal+0x404>
   }
   else
   {
      p->net = iproute(p->fhost, &firsthop);
 823f54c:	e0bfff17 	ldw	r2,-4(fp)
 823f550:	10800717 	ldw	r2,28(r2)
 823f554:	e0fffe04 	addi	r3,fp,-8
 823f558:	180b883a 	mov	r5,r3
 823f55c:	1009883a 	mov	r4,r2
 823f560:	8240ce80 	call	8240ce8 <iproute>
 823f564:	1007883a 	mov	r3,r2
 823f568:	e0bfff17 	ldw	r2,-4(fp)
 823f56c:	10c00615 	stw	r3,24(r2)
      if (p->net == NULL)
 823f570:	e0bfff17 	ldw	r2,-4(fp)
 823f574:	10800617 	ldw	r2,24(r2)
 823f578:	10002c1e 	bne	r2,zero,823f62c <ip_write_internal+0x404>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 823f57c:	d0a08317 	ldw	r2,-32244(gp)
 823f580:	1080840c 	andi	r2,r2,528
 823f584:	10001a26 	beq	r2,zero,823f5f0 <ip_write_internal+0x3c8>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f588:	e0bfff17 	ldw	r2,-4(fp)
 823f58c:	11400417 	ldw	r5,16(r2)
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f590:	e0bfff17 	ldw	r2,-4(fp)
 823f594:	10800717 	ldw	r2,28(r2)
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f598:	11803fcc 	andi	r6,r2,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f59c:	e0bfff17 	ldw	r2,-4(fp)
 823f5a0:	10800717 	ldw	r2,28(r2)
 823f5a4:	1004d23a 	srli	r2,r2,8
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f5a8:	10803fcc 	andi	r2,r2,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f5ac:	e0ffff17 	ldw	r3,-4(fp)
 823f5b0:	18c00717 	ldw	r3,28(r3)
 823f5b4:	1806d43a 	srli	r3,r3,16
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f5b8:	18c03fcc 	andi	r3,r3,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f5bc:	e13fff17 	ldw	r4,-4(fp)
 823f5c0:	21000717 	ldw	r4,28(r4)
 823f5c4:	2008d63a 	srli	r4,r4,24
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f5c8:	d9000215 	stw	r4,8(sp)
 823f5cc:	d8c00115 	stw	r3,4(sp)
 823f5d0:	d8800015 	stw	r2,0(sp)
 823f5d4:	300f883a 	mov	r7,r6
 823f5d8:	280d883a 	mov	r6,r5
 823f5dc:	e17fff17 	ldw	r5,-4(fp)
 823f5e0:	01020974 	movhi	r4,2085
 823f5e4:	21047404 	addi	r4,r4,4560
 823f5e8:	82033a00 	call	82033a0 <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 823f5ec:	822d5940 	call	822d594 <dtrap>
         }
#endif   /* NPDEBUG */
         ip_mib.ipOutNoRoutes++;
 823f5f0:	008209b4 	movhi	r2,2086
 823f5f4:	10ba6104 	addi	r2,r2,-5756
 823f5f8:	10800b17 	ldw	r2,44(r2)
 823f5fc:	10c00044 	addi	r3,r2,1
 823f600:	008209b4 	movhi	r2,2086
 823f604:	10ba6104 	addi	r2,r2,-5756
 823f608:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f60c:	01000084 	movi	r4,2
 823f610:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
         pk_free(p);
 823f614:	e13fff17 	ldw	r4,-4(fp)
 823f618:	822cd3c0 	call	822cd3c <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f61c:	01000084 	movi	r4,2
 823f620:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 823f624:	00bff7c4 	movi	r2,-33
 823f628:	0000c306 	br	823f938 <ip_write_internal+0x710>
#ifdef   IP_MULTICAST
sendit:  /* label used for multicast packets to skip routing logic */
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
 823f62c:	d0a08317 	ldw	r2,-32244(gp)
 823f630:	1080800c 	andi	r2,r2,512
 823f634:	10002926 	beq	r2,zero,823f6dc <ip_write_internal+0x4b4>
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f638:	e0bfff17 	ldw	r2,-4(fp)
 823f63c:	11000417 	ldw	r4,16(r2)
       p->nb_plen, PUSH_IPADDR(p->fhost));
 823f640:	e0bfff17 	ldw	r2,-4(fp)
 823f644:	10800717 	ldw	r2,28(r2)
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f648:	11403fcc 	andi	r5,r2,255
       p->nb_plen, PUSH_IPADDR(p->fhost));
 823f64c:	e0bfff17 	ldw	r2,-4(fp)
 823f650:	10800717 	ldw	r2,28(r2)
 823f654:	1004d23a 	srli	r2,r2,8
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f658:	11803fcc 	andi	r6,r2,255
       p->nb_plen, PUSH_IPADDR(p->fhost));
 823f65c:	e0bfff17 	ldw	r2,-4(fp)
 823f660:	10800717 	ldw	r2,28(r2)
 823f664:	1004d43a 	srli	r2,r2,16
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f668:	10803fcc 	andi	r2,r2,255
       p->nb_plen, PUSH_IPADDR(p->fhost));
 823f66c:	e0ffff17 	ldw	r3,-4(fp)
 823f670:	18c00717 	ldw	r3,28(r3)
 823f674:	1806d63a 	srli	r3,r3,24
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f678:	d8c00115 	stw	r3,4(sp)
 823f67c:	d8800015 	stw	r2,0(sp)
 823f680:	300f883a 	mov	r7,r6
 823f684:	280d883a 	mov	r6,r5
 823f688:	200b883a 	mov	r5,r4
 823f68c:	01020974 	movhi	r4,2085
 823f690:	21048404 	addi	r4,r4,4624
 823f694:	82033a00 	call	82033a0 <printf>
       p->nb_plen, PUSH_IPADDR(p->fhost));
      dprintf(" route %u.%u.%u.%u\n", PUSH_IPADDR(firsthop));
 823f698:	e0bffe17 	ldw	r2,-8(fp)
 823f69c:	10c03fcc 	andi	r3,r2,255
 823f6a0:	e0bffe17 	ldw	r2,-8(fp)
 823f6a4:	1004d23a 	srli	r2,r2,8
 823f6a8:	11003fcc 	andi	r4,r2,255
 823f6ac:	e0bffe17 	ldw	r2,-8(fp)
 823f6b0:	1004d43a 	srli	r2,r2,16
 823f6b4:	11403fcc 	andi	r5,r2,255
 823f6b8:	e0bffe17 	ldw	r2,-8(fp)
 823f6bc:	1004d63a 	srli	r2,r2,24
 823f6c0:	d8800015 	stw	r2,0(sp)
 823f6c4:	280f883a 	mov	r7,r5
 823f6c8:	200d883a 	mov	r6,r4
 823f6cc:	180b883a 	mov	r5,r3
 823f6d0:	01020974 	movhi	r4,2085
 823f6d4:	21048d04 	addi	r4,r4,4660
 823f6d8:	82033a00 	call	82033a0 <printf>
#endif   /* IPSEC */

   /* If the packet is being sent to the same interface it will be sent
    * from, short-cut things and just put it on the received queue.
    */
   if ((p->net->n_ipaddr == p->fhost) &&
 823f6dc:	e0bfff17 	ldw	r2,-4(fp)
 823f6e0:	10800617 	ldw	r2,24(r2)
 823f6e4:	10c00a17 	ldw	r3,40(r2)
 823f6e8:	e0bfff17 	ldw	r2,-4(fp)
 823f6ec:	10800717 	ldw	r2,28(r2)
 823f6f0:	1880271e 	bne	r3,r2,823f790 <ip_write_internal+0x568>
       ((p->fhost & htonl(0xff000000)) != htonl(0x7f000000)))
 823f6f4:	e0bfff17 	ldw	r2,-4(fp)
 823f6f8:	10800717 	ldw	r2,28(r2)
 823f6fc:	10803fcc 	andi	r2,r2,255
#endif   /* IPSEC */

   /* If the packet is being sent to the same interface it will be sent
    * from, short-cut things and just put it on the received queue.
    */
   if ((p->net->n_ipaddr == p->fhost) &&
 823f700:	10801fe0 	cmpeqi	r2,r2,127
 823f704:	1000221e 	bne	r2,zero,823f790 <ip_write_internal+0x568>
       ((p->fhost & htonl(0xff000000)) != htonl(0x7f000000)))
   {
      if (!(p->net->n_flags & NF_NBPROT))
 823f708:	e0bfff17 	ldw	r2,-4(fp)
 823f70c:	10800617 	ldw	r2,24(r2)
 823f710:	10802a17 	ldw	r2,168(r2)
 823f714:	1080020c 	andi	r2,r2,8
 823f718:	1000091e 	bne	r2,zero,823f740 <ip_write_internal+0x518>
          * IP or ARP protocol header) and nb_type to the protocol
          * type, and set the NF_NBPROT flag in its interfaces'
          * n_flags fields.
          */
#ifdef NPDEBUG
         dtrap();
 823f71c:	822d5940 	call	822d594 <dtrap>
#endif
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f720:	01000084 	movi	r4,2
 823f724:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
         pk_free(p);
 823f728:	e13fff17 	ldw	r4,-4(fp)
 823f72c:	822cd3c0 	call	822cd3c <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f730:	01000084 	movi	r4,2
 823f734:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_LOGIC;
 823f738:	00bffd44 	movi	r2,-11
 823f73c:	00007e06 	br	823f938 <ip_write_internal+0x710>
      }
      p->type = IPTP;
 823f740:	e0bfff17 	ldw	r2,-4(fp)
 823f744:	00c00204 	movi	r3,8
 823f748:	10c0080d 	sth	r3,32(r2)
      UNLOCK_NET_RESOURCE(NET_RESID);
 823f74c:	0009883a 	mov	r4,zero
 823f750:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(RXQ_RESID);
 823f754:	01000044 	movi	r4,1
 823f758:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      putq(&rcvdq, (q_elt)p);
 823f75c:	e17fff17 	ldw	r5,-4(fp)
 823f760:	010209b4 	movhi	r4,2086
 823f764:	21375604 	addi	r4,r4,-8872
 823f768:	822cf7c0 	call	822cf7c <putq>
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 823f76c:	01000044 	movi	r4,1
 823f770:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(NET_RESID);
 823f774:	0009883a 	mov	r4,zero
 823f778:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);

      SignalPktDemux();
 823f77c:	d0a0ab17 	ldw	r2,-32084(gp)
 823f780:	1009883a 	mov	r4,r2
 823f784:	821a44c0 	call	821a44c <OSSemPost>

      return SUCCESS;
 823f788:	0005883a 	mov	r2,zero
 823f78c:	00006a06 	br	823f938 <ip_write_internal+0x710>
   }

   /* determine if the buffer that needs to be transmitted is interrupt-safe */
   intrsafe_buf = ((p->flags & PKF_INTRUNSAFE) ? 0 : 1);
 823f790:	e0bfff17 	ldw	r2,-4(fp)
 823f794:	10800a17 	ldw	r2,40(r2)
 823f798:	1080040c 	andi	r2,r2,16
 823f79c:	1005003a 	cmpeq	r2,r2,zero
 823f7a0:	e0bffa05 	stb	r2,-24(fp)
   /* obtain the length of the largest interrupt-safe buffer that can be 
    * allocated via pk_alloc () */
   maxbuflen = pk_get_max_intrsafe_buf_len ();
 823f7a4:	822cde80 	call	822cde8 <pk_get_max_intrsafe_buf_len>
 823f7a8:	e0bffb15 	stw	r2,-20(fp)
    * the original buffer is interrupt-safe, we just need to consider the
    * MTU of the egress interface.  If the original buffer is interrupt-
    * unsafe, we compute the MIN of the largest interrupt-safe buffer that
    * we can use and the MTU of the egress interface (since we must satisfy
    * both constraints) */
   if (!intrsafe_buf)
 823f7ac:	e0bffa03 	ldbu	r2,-24(fp)
 823f7b0:	1000081e 	bne	r2,zero,823f7d4 <ip_write_internal+0x5ac>
       limit = MIN(maxbuflen,p->net->n_mtu);
 823f7b4:	e0bfff17 	ldw	r2,-4(fp)
 823f7b8:	10800617 	ldw	r2,24(r2)
 823f7bc:	10800917 	ldw	r2,36(r2)
 823f7c0:	e0fffb17 	ldw	r3,-20(fp)
 823f7c4:	1880012e 	bgeu	r3,r2,823f7cc <ip_write_internal+0x5a4>
 823f7c8:	1805883a 	mov	r2,r3
 823f7cc:	e0bff615 	stw	r2,-40(fp)
 823f7d0:	00000406 	br	823f7e4 <ip_write_internal+0x5bc>
   else
       limit = p->net->n_mtu;
 823f7d4:	e0bfff17 	ldw	r2,-4(fp)
 823f7d8:	10800617 	ldw	r2,24(r2)
 823f7dc:	10800917 	ldw	r2,36(r2)
 823f7e0:	e0bff615 	stw	r2,-40(fp)

   if ((p->nb_plen + p->net->n_lnh) > limit)
 823f7e4:	e0bfff17 	ldw	r2,-4(fp)
 823f7e8:	10800417 	ldw	r2,16(r2)
 823f7ec:	e0ffff17 	ldw	r3,-4(fp)
 823f7f0:	18c00617 	ldw	r3,24(r3)
 823f7f4:	18c00817 	ldw	r3,32(r3)
 823f7f8:	10c5883a 	add	r2,r2,r3
 823f7fc:	e0fff617 	ldw	r3,-40(fp)
 823f800:	1880072e 	bgeu	r3,r2,823f820 <ip_write_internal+0x5f8>
   {
#ifdef IP_FRAGMENTS
      int err;
      err = ip_fragment(p, firsthop);
 823f804:	e0bffe17 	ldw	r2,-8(fp)
 823f808:	100b883a 	mov	r5,r2
 823f80c:	e13fff17 	ldw	r4,-4(fp)
 823f810:	82403d80 	call	82403d8 <ip_fragment>
 823f814:	e0bffc15 	stw	r2,-16(fp)
      IN_PROFILER(PF_IP, PF_EXIT);
      return(err);
 823f818:	e0bffc17 	ldw	r2,-16(fp)
 823f81c:	00004606 	br	823f938 <ip_write_internal+0x710>
   }
   else
   {
      /* fragmentation is not required; check to see if we need to copy out of
       * an interrupt-unsafe buffer */ 
      if (!intrsafe_buf)
 823f820:	e0bffa03 	ldbu	r2,-24(fp)
 823f824:	1000401e 	bne	r2,zero,823f928 <ip_write_internal+0x700>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f828:	01000084 	movi	r4,2
 823f82c:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
         newpkt = pk_alloc(p->nb_plen + p->net->n_lnh);
 823f830:	e0bfff17 	ldw	r2,-4(fp)
 823f834:	10800417 	ldw	r2,16(r2)
 823f838:	e0ffff17 	ldw	r3,-4(fp)
 823f83c:	18c00617 	ldw	r3,24(r3)
 823f840:	18c00817 	ldw	r3,32(r3)
 823f844:	10c5883a 	add	r2,r2,r3
 823f848:	1009883a 	mov	r4,r2
 823f84c:	822c9ec0 	call	822c9ec <pk_alloc>
 823f850:	e0bffd15 	stw	r2,-12(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f854:	01000084 	movi	r4,2
 823f858:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         if (newpkt == 0)
 823f85c:	e0bffd17 	ldw	r2,-12(fp)
 823f860:	1000081e 	bne	r2,zero,823f884 <ip_write_internal+0x65c>
         {
            /* can't allocate interrupt-safe buffer, so free the packet that 
             * we are working with */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 823f864:	01000084 	movi	r4,2
 823f868:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
            pk_free(p);
 823f86c:	e13fff17 	ldw	r4,-4(fp)
 823f870:	822cd3c0 	call	822cd3c <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f874:	01000084 	movi	r4,2
 823f878:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NOBUFFER;
 823f87c:	00bffac4 	movi	r2,-21
 823f880:	00002d06 	br	823f938 <ip_write_internal+0x710>
         }
         else
         {
            /* copy from interrupt-unsafe buffer into interrupt-safe buffer */
            newpkt->nb_prot = newpkt->nb_buff + p->net->n_lnh;
 823f884:	e0bffd17 	ldw	r2,-12(fp)
 823f888:	10800117 	ldw	r2,4(r2)
 823f88c:	e0ffff17 	ldw	r3,-4(fp)
 823f890:	18c00617 	ldw	r3,24(r3)
 823f894:	18c00817 	ldw	r3,32(r3)
 823f898:	10c7883a 	add	r3,r2,r3
 823f89c:	e0bffd17 	ldw	r2,-12(fp)
 823f8a0:	10c00315 	stw	r3,12(r2)
            MEMCPY(newpkt->nb_prot, p->nb_prot, p->nb_plen);
 823f8a4:	e0bffd17 	ldw	r2,-12(fp)
 823f8a8:	10c00317 	ldw	r3,12(r2)
 823f8ac:	e0bfff17 	ldw	r2,-4(fp)
 823f8b0:	11000317 	ldw	r4,12(r2)
 823f8b4:	e0bfff17 	ldw	r2,-4(fp)
 823f8b8:	10800417 	ldw	r2,16(r2)
 823f8bc:	100d883a 	mov	r6,r2
 823f8c0:	200b883a 	mov	r5,r4
 823f8c4:	1809883a 	mov	r4,r3
 823f8c8:	8202f100 	call	8202f10 <memcpy>
            /* setup various fields in the newly allocated PACKET structure */
            newpkt->nb_plen = p->nb_plen;
 823f8cc:	e0bfff17 	ldw	r2,-4(fp)
 823f8d0:	10c00417 	ldw	r3,16(r2)
 823f8d4:	e0bffd17 	ldw	r2,-12(fp)
 823f8d8:	10c00415 	stw	r3,16(r2)
            newpkt->net = p->net;
 823f8dc:	e0bfff17 	ldw	r2,-4(fp)
 823f8e0:	10c00617 	ldw	r3,24(r2)
 823f8e4:	e0bffd17 	ldw	r2,-12(fp)
 823f8e8:	10c00615 	stw	r3,24(r2)
            newpkt->fhost = p->fhost;
 823f8ec:	e0bfff17 	ldw	r2,-4(fp)
 823f8f0:	10c00717 	ldw	r3,28(r2)
 823f8f4:	e0bffd17 	ldw	r2,-12(fp)
 823f8f8:	10c00715 	stw	r3,28(r2)
            /* free the original packet since it is no longer needed */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 823f8fc:	01000084 	movi	r4,2
 823f900:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
            pk_free(p);
 823f904:	e13fff17 	ldw	r4,-4(fp)
 823f908:	822cd3c0 	call	822cd3c <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f90c:	01000084 	movi	r4,2
 823f910:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            /* send packet to MAC layer. This will try to resolve MAC layer addressing 
             * and send packet. ip2mac() can return SUCCESS, PENDING, or error codes. 
             */
            return(ip2mac(newpkt, firsthop));
 823f914:	e0bffe17 	ldw	r2,-8(fp)
 823f918:	100b883a 	mov	r5,r2
 823f91c:	e13ffd17 	ldw	r4,-12(fp)
 823f920:	82266f80 	call	82266f8 <ip2mac>
 823f924:	00000406 	br	823f938 <ip_write_internal+0x710>
      else
      {
         /* since the packet is in an interrupt-safe buffer, it can be passed to 
          * ip2mac () without any additional work. */
         IN_PROFILER(PF_IP, PF_EXIT);
         return(ip2mac(p, firsthop));
 823f928:	e0bffe17 	ldw	r2,-8(fp)
 823f92c:	100b883a 	mov	r5,r2
 823f930:	e13fff17 	ldw	r4,-4(fp)
 823f934:	82266f80 	call	82266f8 <ip2mac>
      }
   }
}
 823f938:	e037883a 	mov	sp,fp
 823f93c:	dfc00117 	ldw	ra,4(sp)
 823f940:	df000017 	ldw	fp,0(sp)
 823f944:	dec00204 	addi	sp,sp,8
 823f948:	f800283a 	ret

0823f94c <ip_write>:

int
ip_write(
   u_char   prot,
   PACKET   p)
{
 823f94c:	defff904 	addi	sp,sp,-28
 823f950:	dfc00615 	stw	ra,24(sp)
 823f954:	df000515 	stw	fp,20(sp)
 823f958:	df000504 	addi	fp,sp,20
 823f95c:	2005883a 	mov	r2,r4
 823f960:	e17fff15 	stw	r5,-4(fp)
 823f964:	e0bffe05 	stb	r2,-8(fp)
   u_char ttl;
   struct ip_socopts *sopts;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 823f968:	008209b4 	movhi	r2,2086
 823f96c:	10ba6104 	addi	r2,r2,-5756
 823f970:	10800917 	ldw	r2,36(r2)
 823f974:	10c00044 	addi	r3,r2,1
 823f978:	008209b4 	movhi	r2,2086
 823f97c:	10ba6104 	addi	r2,r2,-5756
 823f980:	10c00915 	stw	r3,36(r2)

   /* make room for IP header, and form a pointer to it (pip) */
   p->nb_prot -= sizeof(struct ip);
 823f984:	e0bfff17 	ldw	r2,-4(fp)
 823f988:	10800317 	ldw	r2,12(r2)
 823f98c:	10fffb04 	addi	r3,r2,-20
 823f990:	e0bfff17 	ldw	r2,-4(fp)
 823f994:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 823f998:	e0bfff17 	ldw	r2,-4(fp)
 823f99c:	10800417 	ldw	r2,16(r2)
 823f9a0:	10c00504 	addi	r3,r2,20
 823f9a4:	e0bfff17 	ldw	r2,-4(fp)
 823f9a8:	10c00415 	stw	r3,16(r2)
   pip = (struct ip*)(p->nb_prot);
 823f9ac:	e0bfff17 	ldw	r2,-4(fp)
 823f9b0:	10800317 	ldw	r2,12(r2)
 823f9b4:	e0bffc15 	stw	r2,-16(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 823f9b8:	e0bffc17 	ldw	r2,-16(fp)
 823f9bc:	00c01144 	movi	r3,69
 823f9c0:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = 0;        /* clear fragmentation info field */
 823f9c4:	e0bffc17 	ldw	r2,-16(fp)
 823f9c8:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 823f9cc:	d0a05017 	ldw	r2,-32448(gp)
 823f9d0:	10bfffcc 	andi	r2,r2,65535
 823f9d4:	1005d23a 	srai	r2,r2,8
 823f9d8:	10803fcc 	andi	r2,r2,255
 823f9dc:	1007883a 	mov	r3,r2
 823f9e0:	d0a05017 	ldw	r2,-32448(gp)
 823f9e4:	10bfffcc 	andi	r2,r2,65535
 823f9e8:	1004923a 	slli	r2,r2,8
 823f9ec:	1884b03a 	or	r2,r3,r2
 823f9f0:	1007883a 	mov	r3,r2
 823f9f4:	e0bffc17 	ldw	r2,-16(fp)
 823f9f8:	10c0010d 	sth	r3,4(r2)
   uid++;
 823f9fc:	d0a05017 	ldw	r2,-32448(gp)
 823fa00:	10800044 	addi	r2,r2,1
 823fa04:	d0a05015 	stw	r2,-32448(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 823fa08:	e0bfff17 	ldw	r2,-4(fp)
 823fa0c:	10800417 	ldw	r2,16(r2)
 823fa10:	10bfffcc 	andi	r2,r2,65535
 823fa14:	1005d23a 	srai	r2,r2,8
 823fa18:	10803fcc 	andi	r2,r2,255
 823fa1c:	1007883a 	mov	r3,r2
 823fa20:	e0bfff17 	ldw	r2,-4(fp)
 823fa24:	10800417 	ldw	r2,16(r2)
 823fa28:	10bfffcc 	andi	r2,r2,65535
 823fa2c:	1004923a 	slli	r2,r2,8
 823fa30:	1884b03a 	or	r2,r3,r2
 823fa34:	1007883a 	mov	r3,r2
 823fa38:	e0bffc17 	ldw	r2,-16(fp)
 823fa3c:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 823fa40:	e0bffc17 	ldw	r2,-16(fp)
 823fa44:	e0fffe03 	ldbu	r3,-8(fp)
 823fa48:	10c00245 	stb	r3,9(r2)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 823fa4c:	e0bffc17 	ldw	r2,-16(fp)
 823fa50:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 823fa54:	00801004 	movi	r2,64
 823fa58:	e0bffb05 	stb	r2,-20(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 823fa5c:	e0bfff17 	ldw	r2,-4(fp)
 823fa60:	10800717 	ldw	r2,28(r2)
 823fa64:	1006d63a 	srli	r3,r2,24
 823fa68:	e0bfff17 	ldw	r2,-4(fp)
 823fa6c:	10800717 	ldw	r2,28(r2)
 823fa70:	1004d23a 	srli	r2,r2,8
 823fa74:	10bfc00c 	andi	r2,r2,65280
 823fa78:	1886b03a 	or	r3,r3,r2
 823fa7c:	e0bfff17 	ldw	r2,-4(fp)
 823fa80:	10800717 	ldw	r2,28(r2)
 823fa84:	10bfc00c 	andi	r2,r2,65280
 823fa88:	1004923a 	slli	r2,r2,8
 823fa8c:	1886b03a 	or	r3,r3,r2
 823fa90:	e0bfff17 	ldw	r2,-4(fp)
 823fa94:	10800717 	ldw	r2,28(r2)
 823fa98:	1004963a 	slli	r2,r2,24
 823fa9c:	1884b03a 	or	r2,r3,r2
 823faa0:	10fc002c 	andhi	r3,r2,61440
 823faa4:	00b80034 	movhi	r2,57344
 823faa8:	1880071e 	bne	r3,r2,823fac8 <ip_write+0x17c>
 823faac:	e0bfff17 	ldw	r2,-4(fp)
 823fab0:	10800b17 	ldw	r2,44(r2)
 823fab4:	10000426 	beq	r2,zero,823fac8 <ip_write+0x17c>
      ttl = p->imo->imo_multicast_ttl;
 823fab8:	e0bfff17 	ldw	r2,-4(fp)
 823fabc:	10800b17 	ldw	r2,44(r2)
 823fac0:	10800103 	ldbu	r2,4(r2)
 823fac4:	e0bffb05 	stb	r2,-20(fp)
#endif /* IP_MULTICAST */

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 823fac8:	e0bfff17 	ldw	r2,-4(fp)
 823facc:	10800c17 	ldw	r2,48(r2)
 823fad0:	e0bffd15 	stw	r2,-12(fp)
 823fad4:	e0bffd17 	ldw	r2,-12(fp)
 823fad8:	10001126 	beq	r2,zero,823fb20 <ip_write+0x1d4>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 823fadc:	e0bffd17 	ldw	r2,-12(fp)
 823fae0:	10800043 	ldbu	r2,1(r2)
 823fae4:	10803fcc 	andi	r2,r2,255
 823fae8:	10000526 	beq	r2,zero,823fb00 <ip_write+0x1b4>
         pip->ip_time = sopts->ip_ttl;
 823faec:	e0bffd17 	ldw	r2,-12(fp)
 823faf0:	10c00043 	ldbu	r3,1(r2)
 823faf4:	e0bffc17 	ldw	r2,-16(fp)
 823faf8:	10c00205 	stb	r3,8(r2)
 823fafc:	00000306 	br	823fb0c <ip_write+0x1c0>
	  else
         pip->ip_time = ttl;
 823fb00:	e0bffc17 	ldw	r2,-16(fp)
 823fb04:	e0fffb03 	ldbu	r3,-20(fp)
 823fb08:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = sopts->ip_tos;
 823fb0c:	e0bffd17 	ldw	r2,-12(fp)
 823fb10:	10c00003 	ldbu	r3,0(r2)
 823fb14:	e0bffc17 	ldw	r2,-16(fp)
 823fb18:	10c00045 	stb	r3,1(r2)
 823fb1c:	00000506 	br	823fb34 <ip_write+0x1e8>
   }
   else
   {
	  /* nope */
      pip->ip_time = ttl;
 823fb20:	e0bffc17 	ldw	r2,-16(fp)
 823fb24:	e0fffb03 	ldbu	r3,-20(fp)
 823fb28:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 823fb2c:	e0bffc17 	ldw	r2,-16(fp)
 823fb30:	10000045 	stb	zero,1(r2)
   }
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum(pip, 10);
 823fb34:	01400284 	movi	r5,10
 823fb38:	e13ffc17 	ldw	r4,-16(fp)
 823fb3c:	82287b40 	call	82287b4 <cksum>
 823fb40:	0084303a 	nor	r2,zero,r2
 823fb44:	1007883a 	mov	r3,r2
 823fb48:	e0bffc17 	ldw	r2,-16(fp)
 823fb4c:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 823fb50:	e13fff17 	ldw	r4,-4(fp)
 823fb54:	823f2280 	call	823f228 <ip_write_internal>
}
 823fb58:	e037883a 	mov	sp,fp
 823fb5c:	dfc00117 	ldw	ra,4(sp)
 823fb60:	df000017 	ldw	fp,0(sp)
 823fb64:	dec00204 	addi	sp,sp,8
 823fb68:	f800283a 	ret

0823fb6c <ip_write2>:
 * OUTPUT: This function returns the return code from 
 *         ip_write_internal ().
 */

int ip_write2 (u_char prot, PACKET p, u_char * optp)
{
 823fb6c:	defff604 	addi	sp,sp,-40
 823fb70:	dfc00915 	stw	ra,36(sp)
 823fb74:	df000815 	stw	fp,32(sp)
 823fb78:	df000804 	addi	fp,sp,32
 823fb7c:	2005883a 	mov	r2,r4
 823fb80:	e17ffe15 	stw	r5,-8(fp)
 823fb84:	e1bfff15 	stw	r6,-4(fp)
 823fb88:	e0bffd05 	stb	r2,-12(fp)
   struct ip * pip;
   u_char ttl;
   struct ip_socopts * sopts;
   u_char iphlen = sizeof (struct ip);
 823fb8c:	00800504 	movi	r2,20
 823fb90:	e0bff845 	stb	r2,-31(fp)
   u_char iphlen_pad;
   u_char i;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 823fb94:	008209b4 	movhi	r2,2086
 823fb98:	10ba6104 	addi	r2,r2,-5756
 823fb9c:	10800917 	ldw	r2,36(r2)
 823fba0:	10c00044 	addi	r3,r2,1
 823fba4:	008209b4 	movhi	r2,2086
 823fba8:	10ba6104 	addi	r2,r2,-5756
 823fbac:	10c00915 	stw	r3,36(r2)

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 823fbb0:	e0bfff17 	ldw	r2,-4(fp)
 823fbb4:	e0bff915 	stw	r2,-28(fp)
 823fbb8:	00000d06 	br	823fbf0 <ip_write2+0x84>
   {
      /* account for options, if any (caller has already created
       * adequate space for the requested option) */
      switch (*tmpp)
 823fbbc:	e0bff917 	ldw	r2,-28(fp)
 823fbc0:	10800003 	ldbu	r2,0(r2)
 823fbc4:	10803fcc 	andi	r2,r2,255
 823fbc8:	10800520 	cmpeqi	r2,r2,20
 823fbcc:	1000011e 	bne	r2,zero,823fbd4 <ip_write2+0x68>
      {
         case IP_RTR_ALERT_OPT:
            iphlen += IP_RTR_ALERT_OPT_SIZE;
            break;
         default:
            break;
 823fbd0:	00000406 	br	823fbe4 <ip_write2+0x78>
      /* account for options, if any (caller has already created
       * adequate space for the requested option) */
      switch (*tmpp)
      {
         case IP_RTR_ALERT_OPT:
            iphlen += IP_RTR_ALERT_OPT_SIZE;
 823fbd4:	e0bff843 	ldbu	r2,-31(fp)
 823fbd8:	10800104 	addi	r2,r2,4
 823fbdc:	e0bff845 	stb	r2,-31(fp)
            break;
 823fbe0:	0001883a 	nop
   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 823fbe4:	e0bff917 	ldw	r2,-28(fp)
 823fbe8:	10800044 	addi	r2,r2,1
 823fbec:	e0bff915 	stw	r2,-28(fp)
 823fbf0:	e0bff917 	ldw	r2,-28(fp)
 823fbf4:	10800003 	ldbu	r2,0(r2)
 823fbf8:	10803fcc 	andi	r2,r2,255
 823fbfc:	103fef1e 	bne	r2,zero,823fbbc <ip_write2+0x50>
   }

   /* compute the amount of padding required, if any (to ensure
    * that the IP header (including options) ends on a dword
    * (four byte) boundary */
   if (iphlen & 0x3)
 823fc00:	e0bff843 	ldbu	r2,-31(fp)
 823fc04:	108000cc 	andi	r2,r2,3
 823fc08:	10000726 	beq	r2,zero,823fc28 <ip_write2+0xbc>
      iphlen_pad = 4 - (iphlen & 0x3);
 823fc0c:	e0bff843 	ldbu	r2,-31(fp)
 823fc10:	108000cc 	andi	r2,r2,3
 823fc14:	1007883a 	mov	r3,r2
 823fc18:	00800104 	movi	r2,4
 823fc1c:	10c5c83a 	sub	r2,r2,r3
 823fc20:	e0bffa05 	stb	r2,-24(fp)
 823fc24:	00000106 	br	823fc2c <ip_write2+0xc0>
   else iphlen_pad = 0; /* no header padding required */
 823fc28:	e03ffa05 	stb	zero,-24(fp)
   /* the packet passed to ip_write2 () has its nb_prot set to
    * point to start of the protocol's (e.g., IGMP) data, and 
    * nb_plen set to the length of that data.  locate start of 
    * the IP header (account for IP options), and form a pointer 
    * to it (pip) */
   p->nb_prot -= (iphlen + iphlen_pad);
 823fc2c:	e0bffe17 	ldw	r2,-8(fp)
 823fc30:	10c00317 	ldw	r3,12(r2)
 823fc34:	e13ff843 	ldbu	r4,-31(fp)
 823fc38:	e0bffa03 	ldbu	r2,-24(fp)
 823fc3c:	2085883a 	add	r2,r4,r2
 823fc40:	0085c83a 	sub	r2,zero,r2
 823fc44:	1887883a 	add	r3,r3,r2
 823fc48:	e0bffe17 	ldw	r2,-8(fp)
 823fc4c:	10c00315 	stw	r3,12(r2)
   /* add padding length to the total length of the IP datagram */
   p->nb_plen += (iphlen + iphlen_pad);
 823fc50:	e0bffe17 	ldw	r2,-8(fp)
 823fc54:	10800417 	ldw	r2,16(r2)
 823fc58:	e13ff843 	ldbu	r4,-31(fp)
 823fc5c:	e0fffa03 	ldbu	r3,-24(fp)
 823fc60:	20c7883a 	add	r3,r4,r3
 823fc64:	10c7883a 	add	r3,r2,r3
 823fc68:	e0bffe17 	ldw	r2,-8(fp)
 823fc6c:	10c00415 	stw	r3,16(r2)
   pip = (struct ip *) (p->nb_prot);
 823fc70:	e0bffe17 	ldw	r2,-8(fp)
 823fc74:	10800317 	ldw	r2,12(r2)
 823fc78:	e0bffb15 	stw	r2,-20(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = ((IP_VER << 4) | ((iphlen + iphlen_pad) >> 2));
 823fc7c:	e0fff843 	ldbu	r3,-31(fp)
 823fc80:	e0bffa03 	ldbu	r2,-24(fp)
 823fc84:	1885883a 	add	r2,r3,r2
 823fc88:	1005d0ba 	srai	r2,r2,2
 823fc8c:	10801014 	ori	r2,r2,64
 823fc90:	1007883a 	mov	r3,r2
 823fc94:	e0bffb17 	ldw	r2,-20(fp)
 823fc98:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = 0; /* clear fragmentation info field */
 823fc9c:	e0bffb17 	ldw	r2,-20(fp)
 823fca0:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 823fca4:	d0a05017 	ldw	r2,-32448(gp)
 823fca8:	10bfffcc 	andi	r2,r2,65535
 823fcac:	1005d23a 	srai	r2,r2,8
 823fcb0:	10803fcc 	andi	r2,r2,255
 823fcb4:	1007883a 	mov	r3,r2
 823fcb8:	d0a05017 	ldw	r2,-32448(gp)
 823fcbc:	10bfffcc 	andi	r2,r2,65535
 823fcc0:	1004923a 	slli	r2,r2,8
 823fcc4:	1884b03a 	or	r2,r3,r2
 823fcc8:	1007883a 	mov	r3,r2
 823fccc:	e0bffb17 	ldw	r2,-20(fp)
 823fcd0:	10c0010d 	sth	r3,4(r2)
   uid++;
 823fcd4:	d0a05017 	ldw	r2,-32448(gp)
 823fcd8:	10800044 	addi	r2,r2,1
 823fcdc:	d0a05015 	stw	r2,-32448(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 823fce0:	e0bffe17 	ldw	r2,-8(fp)
 823fce4:	10800417 	ldw	r2,16(r2)
 823fce8:	10bfffcc 	andi	r2,r2,65535
 823fcec:	1005d23a 	srai	r2,r2,8
 823fcf0:	10803fcc 	andi	r2,r2,255
 823fcf4:	1007883a 	mov	r3,r2
 823fcf8:	e0bffe17 	ldw	r2,-8(fp)
 823fcfc:	10800417 	ldw	r2,16(r2)
 823fd00:	10bfffcc 	andi	r2,r2,65535
 823fd04:	1004923a 	slli	r2,r2,8
 823fd08:	1884b03a 	or	r2,r3,r2
 823fd0c:	1007883a 	mov	r3,r2
 823fd10:	e0bffb17 	ldw	r2,-20(fp)
 823fd14:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 823fd18:	e0bffb17 	ldw	r2,-20(fp)
 823fd1c:	e0fffd03 	ldbu	r3,-12(fp)
 823fd20:	10c00245 	stb	r3,9(r2)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 823fd24:	e0bffb17 	ldw	r2,-20(fp)
 823fd28:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 823fd2c:	00801004 	movi	r2,64
 823fd30:	e0bff805 	stb	r2,-32(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 823fd34:	e0bffe17 	ldw	r2,-8(fp)
 823fd38:	10800717 	ldw	r2,28(r2)
 823fd3c:	1006d63a 	srli	r3,r2,24
 823fd40:	e0bffe17 	ldw	r2,-8(fp)
 823fd44:	10800717 	ldw	r2,28(r2)
 823fd48:	1004d23a 	srli	r2,r2,8
 823fd4c:	10bfc00c 	andi	r2,r2,65280
 823fd50:	1886b03a 	or	r3,r3,r2
 823fd54:	e0bffe17 	ldw	r2,-8(fp)
 823fd58:	10800717 	ldw	r2,28(r2)
 823fd5c:	10bfc00c 	andi	r2,r2,65280
 823fd60:	1004923a 	slli	r2,r2,8
 823fd64:	1886b03a 	or	r3,r3,r2
 823fd68:	e0bffe17 	ldw	r2,-8(fp)
 823fd6c:	10800717 	ldw	r2,28(r2)
 823fd70:	1004963a 	slli	r2,r2,24
 823fd74:	1884b03a 	or	r2,r3,r2
 823fd78:	10fc002c 	andhi	r3,r2,61440
 823fd7c:	00b80034 	movhi	r2,57344
 823fd80:	1880071e 	bne	r3,r2,823fda0 <ip_write2+0x234>
 823fd84:	e0bffe17 	ldw	r2,-8(fp)
 823fd88:	10800b17 	ldw	r2,44(r2)
 823fd8c:	10000426 	beq	r2,zero,823fda0 <ip_write2+0x234>
      ttl = p->imo->imo_multicast_ttl;
 823fd90:	e0bffe17 	ldw	r2,-8(fp)
 823fd94:	10800b17 	ldw	r2,44(r2)
 823fd98:	10800103 	ldbu	r2,4(r2)
 823fd9c:	e0bff805 	stb	r2,-32(fp)
#endif /* IP_MULTICAST */

   /* have TOS or TTL been set (via socket options)? */
   if ((sopts = p->soxopts))
 823fda0:	e0bffe17 	ldw	r2,-8(fp)
 823fda4:	10800c17 	ldw	r2,48(r2)
 823fda8:	e0bffc15 	stw	r2,-16(fp)
 823fdac:	e0bffc17 	ldw	r2,-16(fp)
 823fdb0:	10001126 	beq	r2,zero,823fdf8 <ip_write2+0x28c>
   {
      if (sopts->ip_ttl)
 823fdb4:	e0bffc17 	ldw	r2,-16(fp)
 823fdb8:	10800043 	ldbu	r2,1(r2)
 823fdbc:	10803fcc 	andi	r2,r2,255
 823fdc0:	10000526 	beq	r2,zero,823fdd8 <ip_write2+0x26c>
         pip->ip_time = sopts->ip_ttl;
 823fdc4:	e0bffc17 	ldw	r2,-16(fp)
 823fdc8:	10c00043 	ldbu	r3,1(r2)
 823fdcc:	e0bffb17 	ldw	r2,-20(fp)
 823fdd0:	10c00205 	stb	r3,8(r2)
 823fdd4:	00000306 	br	823fde4 <ip_write2+0x278>
      else
         pip->ip_time = ttl;
 823fdd8:	e0bffb17 	ldw	r2,-20(fp)
 823fddc:	e0fff803 	ldbu	r3,-32(fp)
 823fde0:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = sopts->ip_tos;
 823fde4:	e0bffc17 	ldw	r2,-16(fp)
 823fde8:	10c00003 	ldbu	r3,0(r2)
 823fdec:	e0bffb17 	ldw	r2,-20(fp)
 823fdf0:	10c00045 	stb	r3,1(r2)
 823fdf4:	00000506 	br	823fe0c <ip_write2+0x2a0>
   }
   else
   {
      pip->ip_time = ttl;
 823fdf8:	e0bffb17 	ldw	r2,-20(fp)
 823fdfc:	e0fff803 	ldbu	r3,-32(fp)
 823fe00:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 823fe04:	e0bffb17 	ldw	r2,-20(fp)
 823fe08:	10000045 	stb	zero,1(r2)
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 823fe0c:	e0bffe17 	ldw	r2,-8(fp)
 823fe10:	10800317 	ldw	r2,12(r2)
 823fe14:	10800504 	addi	r2,r2,20
 823fe18:	e0bff915 	stw	r2,-28(fp)
 823fe1c:	00001006 	br	823fe60 <ip_write2+0x2f4>
   {
      /* caller has already provided adequate space for the requested options */
      switch (*optp)
 823fe20:	e0bfff17 	ldw	r2,-4(fp)
 823fe24:	10800003 	ldbu	r2,0(r2)
 823fe28:	10803fcc 	andi	r2,r2,255
 823fe2c:	10800520 	cmpeqi	r2,r2,20
 823fe30:	1000011e 	bne	r2,zero,823fe38 <ip_write2+0x2cc>
            *((u_long *) tmpp) = htonl (IP_RTR_ALERT_OPT_DATA);
            /* this option is 4 bytes long */
            tmpp += IP_RTR_ALERT_OPT_SIZE;
            break;
         default:
            break;
 823fe34:	00000706 	br	823fe54 <ip_write2+0x2e8>
   {
      /* caller has already provided adequate space for the requested options */
      switch (*optp)
      {
         case IP_RTR_ALERT_OPT:
            *((u_long *) tmpp) = htonl (IP_RTR_ALERT_OPT_DATA);
 823fe38:	e0bff917 	ldw	r2,-28(fp)
 823fe3c:	00c12504 	movi	r3,1172
 823fe40:	10c00015 	stw	r3,0(r2)
            /* this option is 4 bytes long */
            tmpp += IP_RTR_ALERT_OPT_SIZE;
 823fe44:	e0bff917 	ldw	r2,-28(fp)
 823fe48:	10800104 	addi	r2,r2,4
 823fe4c:	e0bff915 	stw	r2,-28(fp)
            break;
 823fe50:	0001883a 	nop
      pip->ip_time = ttl;
      pip->ip_tos = IP_TOS_DEFVAL;
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 823fe54:	e0bfff17 	ldw	r2,-4(fp)
 823fe58:	10800044 	addi	r2,r2,1
 823fe5c:	e0bfff15 	stw	r2,-4(fp)
 823fe60:	e0bfff17 	ldw	r2,-4(fp)
 823fe64:	10800003 	ldbu	r2,0(r2)
 823fe68:	10803fcc 	andi	r2,r2,255
 823fe6c:	103fec1e 	bne	r2,zero,823fe20 <ip_write2+0x2b4>
            break;
      }
   }

   /* add one (or more) one-byte long End of Option options (if required) */
   for (i = 0; i < iphlen_pad; ++i) *(tmpp + i) = 0;
 823fe70:	e03ffa45 	stb	zero,-23(fp)
 823fe74:	00000706 	br	823fe94 <ip_write2+0x328>
 823fe78:	e0bffa43 	ldbu	r2,-23(fp)
 823fe7c:	e0fff917 	ldw	r3,-28(fp)
 823fe80:	1885883a 	add	r2,r3,r2
 823fe84:	10000005 	stb	zero,0(r2)
 823fe88:	e0bffa43 	ldbu	r2,-23(fp)
 823fe8c:	10800044 	addi	r2,r2,1
 823fe90:	e0bffa45 	stb	r2,-23(fp)
 823fe94:	e0fffa43 	ldbu	r3,-23(fp)
 823fe98:	e0bffa03 	ldbu	r2,-24(fp)
 823fe9c:	18bff636 	bltu	r3,r2,823fe78 <ip_write2+0x30c>
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum (pip, ((iphlen + iphlen_pad)/2));
 823fea0:	e0fff843 	ldbu	r3,-31(fp)
 823fea4:	e0bffa03 	ldbu	r2,-24(fp)
 823fea8:	1885883a 	add	r2,r3,r2
 823feac:	1006d7fa 	srli	r3,r2,31
 823feb0:	1885883a 	add	r2,r3,r2
 823feb4:	1005d07a 	srai	r2,r2,1
 823feb8:	100b883a 	mov	r5,r2
 823febc:	e13ffb17 	ldw	r4,-20(fp)
 823fec0:	82287b40 	call	82287b4 <cksum>
 823fec4:	0084303a 	nor	r2,zero,r2
 823fec8:	1007883a 	mov	r3,r2
 823fecc:	e0bffb17 	ldw	r2,-20(fp)
 823fed0:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal (p));
 823fed4:	e13ffe17 	ldw	r4,-8(fp)
 823fed8:	823f2280 	call	823f228 <ip_write_internal>
}
 823fedc:	e037883a 	mov	sp,fp
 823fee0:	dfc00117 	ldw	ra,4(sp)
 823fee4:	df000017 	ldw	fp,0(sp)
 823fee8:	dec00204 	addi	sp,sp,8
 823feec:	f800283a 	ret

0823fef0 <ip_raw_write>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_raw_write(PACKET p)
{
 823fef0:	defffc04 	addi	sp,sp,-16
 823fef4:	dfc00315 	stw	ra,12(sp)
 823fef8:	df000215 	stw	fp,8(sp)
 823fefc:	df000204 	addi	fp,sp,8
 823ff00:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 823ff04:	008209b4 	movhi	r2,2086
 823ff08:	10ba6104 	addi	r2,r2,-5756
 823ff0c:	10800917 	ldw	r2,36(r2)
 823ff10:	10c00044 	addi	r3,r2,1
 823ff14:	008209b4 	movhi	r2,2086
 823ff18:	10ba6104 	addi	r2,r2,-5756
 823ff1c:	10c00915 	stw	r3,36(r2)

   /* form a pointer to IP header (pip) */
   pip = (struct ip*)(p->nb_prot);
 823ff20:	e0bfff17 	ldw	r2,-4(fp)
 823ff24:	10800317 	ldw	r2,12(r2)
 823ff28:	e0bffe15 	stw	r2,-8(fp)
   
   /* if there's no IP id, give it one */
   if (pip->ip_id == 0)
 823ff2c:	e0bffe17 	ldw	r2,-8(fp)
 823ff30:	1080010b 	ldhu	r2,4(r2)
 823ff34:	10bfffcc 	andi	r2,r2,65535
 823ff38:	10000f1e 	bne	r2,zero,823ff78 <ip_raw_write+0x88>
   {
      pip->ip_id = htons((unshort)uid);
 823ff3c:	d0a05017 	ldw	r2,-32448(gp)
 823ff40:	10bfffcc 	andi	r2,r2,65535
 823ff44:	1005d23a 	srai	r2,r2,8
 823ff48:	10803fcc 	andi	r2,r2,255
 823ff4c:	1007883a 	mov	r3,r2
 823ff50:	d0a05017 	ldw	r2,-32448(gp)
 823ff54:	10bfffcc 	andi	r2,r2,65535
 823ff58:	1004923a 	slli	r2,r2,8
 823ff5c:	1884b03a 	or	r2,r3,r2
 823ff60:	1007883a 	mov	r3,r2
 823ff64:	e0bffe17 	ldw	r2,-8(fp)
 823ff68:	10c0010d 	sth	r3,4(r2)
      uid++;
 823ff6c:	d0a05017 	ldw	r2,-32448(gp)
 823ff70:	10800044 	addi	r2,r2,1
 823ff74:	d0a05015 	stw	r2,-32448(gp)
   }

   /* checksum the IP header */
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 823ff78:	e0bffe17 	ldw	r2,-8(fp)
 823ff7c:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 823ff80:	01400284 	movi	r5,10
 823ff84:	e13ffe17 	ldw	r4,-8(fp)
 823ff88:	82287b40 	call	82287b4 <cksum>
 823ff8c:	0084303a 	nor	r2,zero,r2
 823ff90:	1007883a 	mov	r3,r2
 823ff94:	e0bffe17 	ldw	r2,-8(fp)
 823ff98:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 823ff9c:	e13fff17 	ldw	r4,-4(fp)
 823ffa0:	823f2280 	call	823f228 <ip_write_internal>
}
 823ffa4:	e037883a 	mov	sp,fp
 823ffa8:	dfc00117 	ldw	ra,4(sp)
 823ffac:	df000017 	ldw	fp,0(sp)
 823ffb0:	dec00204 	addi	sp,sp,8
 823ffb4:	f800283a 	ret

0823ffb8 <ip_fragment_lc>:
 *              invocation of ip2mac () for the last generated fragment
 */

int
ip_fragment_lc(PACKET p, ip_addr firsthop)
{
 823ffb8:	defff104 	addi	sp,sp,-60
 823ffbc:	dfc00e15 	stw	ra,56(sp)
 823ffc0:	df000d15 	stw	fp,52(sp)
 823ffc4:	df000d04 	addi	fp,sp,52
 823ffc8:	e13ffe15 	stw	r4,-8(fp)
 823ffcc:	e17fff15 	stw	r5,-4(fp)
   int      e;
   struct ip * pip;
   int      iphlen;     /* IP header length */
   unshort  tmp_fraginfo   ;

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 823ffd0:	008209b4 	movhi	r2,2086
 823ffd4:	10ba6104 	addi	r2,r2,-5756
 823ffd8:	10801017 	ldw	r2,64(r2)
 823ffdc:	10c00044 	addi	r3,r2,1
 823ffe0:	008209b4 	movhi	r2,2086
 823ffe4:	10ba6104 	addi	r2,r2,-5756
 823ffe8:	10c01015 	stw	r3,64(r2)
   pip = (struct ip *)(p->nb_prot);          /* get ptr to IP header */
 823ffec:	e0bffe17 	ldw	r2,-8(fp)
 823fff0:	10800317 	ldw	r2,12(r2)
 823fff4:	e0bff815 	stw	r2,-32(fp)
   iphlen = (pip->ip_ver_ihl & 0xf) << 2;    /* and its length */
 823fff8:	e0bff817 	ldw	r2,-32(fp)
 823fffc:	10800003 	ldbu	r2,0(r2)
 8240000:	10803fcc 	andi	r2,r2,255
 8240004:	108003cc 	andi	r2,r2,15
 8240008:	1085883a 	add	r2,r2,r2
 824000c:	1085883a 	add	r2,r2,r2
 8240010:	e0bff915 	stw	r2,-28(fp)
   left = (int)p->nb_plen - iphlen; /* bytes left to send in datagram */
 8240014:	e0bffe17 	ldw	r2,-8(fp)
 8240018:	10800417 	ldw	r2,16(r2)
 824001c:	1007883a 	mov	r3,r2
 8240020:	e0bff917 	ldw	r2,-28(fp)
 8240024:	1885c83a 	sub	r2,r3,r2
 8240028:	e0bff515 	stw	r2,-44(fp)
    * of fragments to get a fragment length that will result
    * in similarly-sized segments (remembering to round this
    * length up to a multiple of 8 because that's how the IP 
    * Fragment Offset field is scaled).
    */
   maxipsize = p->net->n_mtu - (iphlen + p->net->n_lnh + 8);   /* 8 == for rounding up */
 824002c:	e0bffe17 	ldw	r2,-8(fp)
 8240030:	10800617 	ldw	r2,24(r2)
 8240034:	10c00917 	ldw	r3,36(r2)
 8240038:	e0bffe17 	ldw	r2,-8(fp)
 824003c:	10800617 	ldw	r2,24(r2)
 8240040:	11000817 	ldw	r4,32(r2)
 8240044:	e0bff917 	ldw	r2,-28(fp)
 8240048:	2085883a 	add	r2,r4,r2
 824004c:	10800204 	addi	r2,r2,8
 8240050:	1885c83a 	sub	r2,r3,r2
 8240054:	e0bffa15 	stw	r2,-24(fp)
   if (maxipsize < 64)  /* to small to use */
 8240058:	e0bffa17 	ldw	r2,-24(fp)
 824005c:	10801028 	cmpgeui	r2,r2,64
 8240060:	1000031e 	bne	r2,zero,8240070 <ip_fragment_lc+0xb8>
   {
      dtrap();    /* probably bad programming */
 8240064:	822d5940 	call	822d594 <dtrap>
      return ENP_LOGIC;
 8240068:	00bffd44 	movi	r2,-11
 824006c:	0000d506 	br	82403c4 <ip_fragment_lc+0x40c>
   }
   numfrags = (p->nb_plen/maxipsize) + 1;    /* number of fragments */
 8240070:	e0bffe17 	ldw	r2,-8(fp)
 8240074:	10800417 	ldw	r2,16(r2)
 8240078:	e17ffa17 	ldw	r5,-24(fp)
 824007c:	1009883a 	mov	r4,r2
 8240080:	8202c100 	call	8202c10 <__udivsi3>
 8240084:	10800044 	addi	r2,r2,1
 8240088:	e0bffb15 	stw	r2,-20(fp)
   fragsize = (((p->nb_plen + (numfrags - 1)) / numfrags) + 7) & ~7; 
 824008c:	e0bffe17 	ldw	r2,-8(fp)
 8240090:	10c00417 	ldw	r3,16(r2)
 8240094:	e0bffb17 	ldw	r2,-20(fp)
 8240098:	1885883a 	add	r2,r3,r2
 824009c:	10bfffc4 	addi	r2,r2,-1
 82400a0:	e17ffb17 	ldw	r5,-20(fp)
 82400a4:	1009883a 	mov	r4,r2
 82400a8:	8202c100 	call	8202c10 <__udivsi3>
 82400ac:	10c001c4 	addi	r3,r2,7
 82400b0:	00bffe04 	movi	r2,-8
 82400b4:	1884703a 	and	r2,r3,r2
 82400b8:	e0bffc15 	stw	r2,-16(fp)
   foffset = 0;
 82400bc:	e03ff315 	stw	zero,-52(fp)

   /* Now update from any previous info */
   tmp_fraginfo = ntohs(pip->ip_flgs_foff);     /* get current frag info*/
 82400c0:	e0bff817 	ldw	r2,-32(fp)
 82400c4:	1080018b 	ldhu	r2,6(r2)
 82400c8:	10bfffcc 	andi	r2,r2,65535
 82400cc:	1004d23a 	srli	r2,r2,8
 82400d0:	1007883a 	mov	r3,r2
 82400d4:	e0bff817 	ldw	r2,-32(fp)
 82400d8:	1080018b 	ldhu	r2,6(r2)
 82400dc:	10bfffcc 	andi	r2,r2,65535
 82400e0:	1004923a 	slli	r2,r2,8
 82400e4:	1884b03a 	or	r2,r3,r2
 82400e8:	e0bffd0d 	sth	r2,-12(fp)
   if ( tmp_fraginfo & (~IP_FLG_MASK) )
 82400ec:	e0fffd0b 	ldhu	r3,-12(fp)
 82400f0:	00bffff4 	movhi	r2,65535
 82400f4:	1087ffc4 	addi	r2,r2,8191
 82400f8:	1884703a 	and	r2,r3,r2
 82400fc:	10000826 	beq	r2,zero,8240120 <ip_fragment_lc+0x168>
   {
      /* When fragmenting an already fragmented packet, we need to
         add the initial offset */
      foffset = (tmp_fraginfo & (~IP_FLG_MASK))  ;
 8240100:	e0fffd0b 	ldhu	r3,-12(fp)
 8240104:	00bffff4 	movhi	r2,65535
 8240108:	1087ffc4 	addi	r2,r2,8191
 824010c:	1884703a 	and	r2,r3,r2
 8240110:	e0bff315 	stw	r2,-52(fp)
      foffset <<= 3;    /* Multiply by 8 to get "offset in num of bytes" */
 8240114:	e0bff317 	ldw	r2,-52(fp)
 8240118:	100490fa 	slli	r2,r2,3
 824011c:	e0bff315 	stw	r2,-52(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
 8240120:	e0bffe17 	ldw	r2,-8(fp)
 8240124:	e0bff615 	stw	r2,-40(fp)
   e = 0;
 8240128:	e03ff715 	stw	zero,-36(fp)
   while (left > 1)  /* more data left to send? */
 824012c:	0000a106 	br	82403b4 <ip_fragment_lc+0x3fc>
   {
      p = pkt2;  /* move next fragment up */
 8240130:	e0bff617 	ldw	r2,-40(fp)
 8240134:	e0bffe15 	stw	r2,-8(fp)
      pip = (struct ip *)(p->nb_prot);
 8240138:	e0bffe17 	ldw	r2,-8(fp)
 824013c:	10800317 	ldw	r2,12(r2)
 8240140:	e0bff815 	stw	r2,-32(fp)
      p->nb_plen = min((int)fragsize, left) + iphlen; /* set size of fragment */
 8240144:	e0bffc17 	ldw	r2,-16(fp)
 8240148:	e0fff517 	ldw	r3,-44(fp)
 824014c:	1880010e 	bge	r3,r2,8240154 <ip_fragment_lc+0x19c>
 8240150:	1805883a 	mov	r2,r3
 8240154:	e0fff917 	ldw	r3,-28(fp)
 8240158:	10c5883a 	add	r2,r2,r3
 824015c:	1007883a 	mov	r3,r2
 8240160:	e0bffe17 	ldw	r2,-8(fp)
 8240164:	10c00415 	stw	r3,16(r2)
      left -= fragsize; /* decrement count of bytes left to send */
 8240168:	e0fff517 	ldw	r3,-44(fp)
 824016c:	e0bffc17 	ldw	r2,-16(fp)
 8240170:	1885c83a 	sub	r2,r3,r2
 8240174:	e0bff515 	stw	r2,-44(fp)

      /* set the IP datagram length */
      pip->ip_len = htons((unshort)p->nb_plen);
 8240178:	e0bffe17 	ldw	r2,-8(fp)
 824017c:	10800417 	ldw	r2,16(r2)
 8240180:	10bfffcc 	andi	r2,r2,65535
 8240184:	1005d23a 	srai	r2,r2,8
 8240188:	10803fcc 	andi	r2,r2,255
 824018c:	1007883a 	mov	r3,r2
 8240190:	e0bffe17 	ldw	r2,-8(fp)
 8240194:	10800417 	ldw	r2,16(r2)
 8240198:	10bfffcc 	andi	r2,r2,65535
 824019c:	1004923a 	slli	r2,r2,8
 82401a0:	1884b03a 	or	r2,r3,r2
 82401a4:	1007883a 	mov	r3,r2
 82401a8:	e0bff817 	ldw	r2,-32(fp)
 82401ac:	10c0008d 	sth	r3,2(r2)

      /* build 16bit IP header field value for fragment flags & offset */
      fraginfo = (unshort)(foffset >> 3);    /* offset, in 8 byte chunks */
 82401b0:	e0bff317 	ldw	r2,-52(fp)
 82401b4:	1004d0fa 	srli	r2,r2,3
 82401b8:	e0bff40d 	sth	r2,-48(fp)
      fraginfo |= ((left>1)?IP_FLG_MF:0);    /* OR in MoreFrags flag */
 82401bc:	e0bff517 	ldw	r2,-44(fp)
 82401c0:	10800090 	cmplti	r2,r2,2
 82401c4:	1000021e 	bne	r2,zero,82401d0 <ip_fragment_lc+0x218>
 82401c8:	00880004 	movi	r2,8192
 82401cc:	00000106 	br	82401d4 <ip_fragment_lc+0x21c>
 82401d0:	0005883a 	mov	r2,zero
 82401d4:	e0fff40b 	ldhu	r3,-48(fp)
 82401d8:	10c4b03a 	or	r2,r2,r3
 82401dc:	e0bff40d 	sth	r2,-48(fp)

      if ( tmp_fraginfo & IP_FLG_MF )             
 82401e0:	e0bffd0b 	ldhu	r2,-12(fp)
 82401e4:	1088000c 	andi	r2,r2,8192
 82401e8:	10000326 	beq	r2,zero,82401f8 <ip_fragment_lc+0x240>
      {
         /* As flag is set in main packet, it should be set in all
          * fragmented packets also 
          */
         fraginfo |= IP_FLG_MF;
 82401ec:	e0bff40b 	ldhu	r2,-48(fp)
 82401f0:	10880014 	ori	r2,r2,8192
 82401f4:	e0bff40d 	sth	r2,-48(fp)
      }

      pip->ip_flgs_foff = htons(fraginfo);   /* do htons macro on separate line */
 82401f8:	e0bff40b 	ldhu	r2,-48(fp)
 82401fc:	1004d23a 	srli	r2,r2,8
 8240200:	1007883a 	mov	r3,r2
 8240204:	e0bff40b 	ldhu	r2,-48(fp)
 8240208:	1004923a 	slli	r2,r2,8
 824020c:	1884b03a 	or	r2,r3,r2
 8240210:	1007883a 	mov	r3,r2
 8240214:	e0bff817 	ldw	r2,-32(fp)
 8240218:	10c0018d 	sth	r3,6(r2)
      /* set up & save next fragment (pkt2) since ip2mac() will delete p */
      if (left > 1)
 824021c:	e0bff517 	ldw	r2,-44(fp)
 8240220:	10800090 	cmplti	r2,r2,2
 8240224:	10003e1e 	bne	r2,zero,8240320 <ip_fragment_lc+0x368>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 8240228:	01000084 	movi	r4,2
 824022c:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
         pkt2 = pk_alloc(left + iphlen + MaxLnh);
 8240230:	e0fff517 	ldw	r3,-44(fp)
 8240234:	e0bff917 	ldw	r2,-28(fp)
 8240238:	1887883a 	add	r3,r3,r2
 824023c:	d0a08117 	ldw	r2,-32252(gp)
 8240240:	1885883a 	add	r2,r3,r2
 8240244:	1009883a 	mov	r4,r2
 8240248:	822c9ec0 	call	822c9ec <pk_alloc>
 824024c:	e0bff615 	stw	r2,-40(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8240250:	01000084 	movi	r4,2
 8240254:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         if (!pkt2)
 8240258:	e0bff617 	ldw	r2,-40(fp)
 824025c:	1000101e 	bne	r2,zero,82402a0 <ip_fragment_lc+0x2e8>
         {
            dtrap();
 8240260:	822d5940 	call	822d594 <dtrap>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 8240264:	01000084 	movi	r4,2
 8240268:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
            pk_free(p);
 824026c:	e13ffe17 	ldw	r4,-8(fp)
 8240270:	822cd3c0 	call	822cd3c <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8240274:	01000084 	movi	r4,2
 8240278:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 824027c:	008209b4 	movhi	r2,2086
 8240280:	10ba6104 	addi	r2,r2,-5756
 8240284:	10801117 	ldw	r2,68(r2)
 8240288:	10c00044 	addi	r3,r2,1
 824028c:	008209b4 	movhi	r2,2086
 8240290:	10ba6104 	addi	r2,r2,-5756
 8240294:	10c01115 	stw	r3,68(r2)
            return ENP_RESOURCE;
 8240298:	00bffa84 	movi	r2,-22
 824029c:	00004906 	br	82403c4 <ip_fragment_lc+0x40c>
         }

         pkt2->net = p->net;       /* copy critical parms to new packet */
 82402a0:	e0bffe17 	ldw	r2,-8(fp)
 82402a4:	10c00617 	ldw	r3,24(r2)
 82402a8:	e0bff617 	ldw	r2,-40(fp)
 82402ac:	10c00615 	stw	r3,24(r2)
         pkt2->fhost = p->fhost;
 82402b0:	e0bffe17 	ldw	r2,-8(fp)
 82402b4:	10c00717 	ldw	r3,28(r2)
 82402b8:	e0bff617 	ldw	r2,-40(fp)
 82402bc:	10c00715 	stw	r3,28(r2)
         /* Duplicate the IPHeader */
         MEMCPY(pkt2->nb_prot, p->nb_prot, iphlen);
 82402c0:	e0bff617 	ldw	r2,-40(fp)
 82402c4:	10c00317 	ldw	r3,12(r2)
 82402c8:	e0bffe17 	ldw	r2,-8(fp)
 82402cc:	10800317 	ldw	r2,12(r2)
 82402d0:	e13ff917 	ldw	r4,-28(fp)
 82402d4:	200d883a 	mov	r6,r4
 82402d8:	100b883a 	mov	r5,r2
 82402dc:	1809883a 	mov	r4,r3
 82402e0:	8202f100 	call	8202f10 <memcpy>
         /* copy data for NEXT fragment from p to pkt2 */
         MEMCPY(pkt2->nb_prot + iphlen, p->nb_prot + iphlen + fragsize, left);
 82402e4:	e0bff617 	ldw	r2,-40(fp)
 82402e8:	10c00317 	ldw	r3,12(r2)
 82402ec:	e0bff917 	ldw	r2,-28(fp)
 82402f0:	188f883a 	add	r7,r3,r2
 82402f4:	e0bffe17 	ldw	r2,-8(fp)
 82402f8:	10c00317 	ldw	r3,12(r2)
 82402fc:	e13ff917 	ldw	r4,-28(fp)
 8240300:	e0bffc17 	ldw	r2,-16(fp)
 8240304:	2085883a 	add	r2,r4,r2
 8240308:	1885883a 	add	r2,r3,r2
 824030c:	e0fff517 	ldw	r3,-44(fp)
 8240310:	180d883a 	mov	r6,r3
 8240314:	100b883a 	mov	r5,r2
 8240318:	3809883a 	mov	r4,r7
 824031c:	8202f100 	call	8202f10 <memcpy>
      }

      /* we've changed the IP header, so recalculate the checksum */
      pip->ip_chksum = IPXSUM;
 8240320:	e0bff817 	ldw	r2,-32(fp)
 8240324:	1000028d 	sth	zero,10(r2)
      pip->ip_chksum = ~cksum(pip, 10);
 8240328:	01400284 	movi	r5,10
 824032c:	e13ff817 	ldw	r4,-32(fp)
 8240330:	82287b40 	call	82287b4 <cksum>
 8240334:	0084303a 	nor	r2,zero,r2
 8240338:	1007883a 	mov	r3,r2
 824033c:	e0bff817 	ldw	r2,-32(fp)
 8240340:	10c0028d 	sth	r3,10(r2)

      /* ip_dump(p); */

      e = ip2mac(p, firsthop);   /* send fragment in p */
 8240344:	e17fff17 	ldw	r5,-4(fp)
 8240348:	e13ffe17 	ldw	r4,-8(fp)
 824034c:	82266f80 	call	82266f8 <ip2mac>
 8240350:	e0bff715 	stw	r2,-36(fp)
      ip_mib.ipFragCreates++;
 8240354:	008209b4 	movhi	r2,2086
 8240358:	10ba6104 	addi	r2,r2,-5756
 824035c:	10801217 	ldw	r2,72(r2)
 8240360:	10c00044 	addi	r3,r2,1
 8240364:	008209b4 	movhi	r2,2086
 8240368:	10ba6104 	addi	r2,r2,-5756
 824036c:	10c01215 	stw	r3,72(r2)
      if (e < 0)
 8240370:	e0bff717 	ldw	r2,-36(fp)
 8240374:	10000b0e 	bge	r2,zero,82403a4 <ip_fragment_lc+0x3ec>
      {
         if (left > 1) 
 8240378:	e0bff517 	ldw	r2,-44(fp)
 824037c:	10800090 	cmplti	r2,r2,2
 8240380:	1000061e 	bne	r2,zero,824039c <ip_fragment_lc+0x3e4>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 8240384:	01000084 	movi	r4,2
 8240388:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
            pk_free(pkt2);
 824038c:	e13ff617 	ldw	r4,-40(fp)
 8240390:	822cd3c0 	call	822cd3c <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8240394:	01000084 	movi	r4,2
 8240398:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         }
         return e;
 824039c:	e0bff717 	ldw	r2,-36(fp)
 82403a0:	00000806 	br	82403c4 <ip_fragment_lc+0x40c>
      }
      foffset += fragsize;    /* offset for next fragment */
 82403a4:	e0fff317 	ldw	r3,-52(fp)
 82403a8:	e0bffc17 	ldw	r2,-16(fp)
 82403ac:	1885883a 	add	r2,r3,r2
 82403b0:	e0bff315 	stw	r2,-52(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
   e = 0;
   while (left > 1)  /* more data left to send? */
 82403b4:	e0bff517 	ldw	r2,-44(fp)
 82403b8:	10800088 	cmpgei	r2,r2,2
 82403bc:	103f5c1e 	bne	r2,zero,8240130 <ip_fragment_lc+0x178>
         }
         return e;
      }
      foffset += fragsize;    /* offset for next fragment */
   }
   return e;
 82403c0:	e0bff717 	ldw	r2,-36(fp)
}
 82403c4:	e037883a 	mov	sp,fp
 82403c8:	dfc00117 	ldw	ra,4(sp)
 82403cc:	df000017 	ldw	fp,0(sp)
 82403d0:	dec00204 	addi	sp,sp,8
 82403d4:	f800283a 	ret

082403d8 <ip_fragment>:
 *              generated fragment, if less than zero
 *          (5) 0, if everything went okay
 */

int ip_fragment(PACKET p, ip_addr firsthop)
{
 82403d8:	defff004 	addi	sp,sp,-64
 82403dc:	dfc00f15 	stw	ra,60(sp)
 82403e0:	df000e15 	stw	fp,56(sp)
 82403e4:	df000e04 	addi	fp,sp,56
 82403e8:	e13ffe15 	stw	r4,-8(fp)
 82403ec:	e17fff15 	stw	r5,-4(fp)
   u_short parent_mf;
   PACKET newpkt;
   struct ip * newpip;
   int e;

   pip = ip_head(p);
 82403f0:	e0bffe17 	ldw	r2,-8(fp)
 82403f4:	10800317 	ldw	r2,12(r2)
 82403f8:	e0bff515 	stw	r2,-44(fp)
   if ((ntohs(pip->ip_flgs_foff)) & IP_FLG_DF)
 82403fc:	e0bff517 	ldw	r2,-44(fp)
 8240400:	1080018b 	ldhu	r2,6(r2)
 8240404:	10bfffcc 	andi	r2,r2,65535
 8240408:	1004d23a 	srli	r2,r2,8
 824040c:	10bfffcc 	andi	r2,r2,65535
 8240410:	10c03fcc 	andi	r3,r2,255
 8240414:	e0bff517 	ldw	r2,-44(fp)
 8240418:	1080018b 	ldhu	r2,6(r2)
 824041c:	10bfffcc 	andi	r2,r2,65535
 8240420:	1004923a 	slli	r2,r2,8
 8240424:	10bfffcc 	andi	r2,r2,65535
 8240428:	1884b03a 	or	r2,r3,r2
 824042c:	1090000c 	andi	r2,r2,16384
 8240430:	10001c26 	beq	r2,zero,82404a4 <ip_fragment+0xcc>
   {
      /* can't fragment a packet with the DF bit set */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 8240434:	01000084 	movi	r4,2
 8240438:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free(p);
 824043c:	e13ffe17 	ldw	r4,-8(fp)
 8240440:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8240444:	01000084 	movi	r4,2
 8240448:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      ip_mib.ipFragFails++;
 824044c:	008209b4 	movhi	r2,2086
 8240450:	10ba6104 	addi	r2,r2,-5756
 8240454:	10801117 	ldw	r2,68(r2)
 8240458:	10c00044 	addi	r3,r2,1
 824045c:	008209b4 	movhi	r2,2086
 8240460:	10ba6104 	addi	r2,r2,-5756
 8240464:	10c01115 	stw	r3,68(r2)
#ifdef FULL_ICMP
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 8240468:	e0bff517 	ldw	r2,-44(fp)
 824046c:	10c00317 	ldw	r3,12(r2)
 8240470:	e0bffe17 	ldw	r2,-8(fp)
 8240474:	10800617 	ldw	r2,24(r2)
 8240478:	11000a17 	ldw	r4,40(r2)
 824047c:	e0bffe17 	ldw	r2,-8(fp)
 8240480:	10800617 	ldw	r2,24(r2)
 8240484:	d8800015 	stw	r2,0(sp)
 8240488:	01c00104 	movi	r7,4
 824048c:	e1bff517 	ldw	r6,-44(fp)
 8240490:	200b883a 	mov	r5,r4
 8240494:	1809883a 	mov	r4,r3
 8240498:	824afc40 	call	824afc4 <icmp_destun>
#endif   /* FULL_ICMP */
      return 0;
 824049c:	0005883a 	mov	r2,zero
 82404a0:	00013906 	br	8240988 <ip_fragment+0x5b0>
   }

   maxbuflen = pk_get_max_intrsafe_buf_len ();
 82404a4:	822cde80 	call	822cde8 <pk_get_max_intrsafe_buf_len>
 82404a8:	e0bff615 	stw	r2,-40(fp)

   /* the maximum amount of data that will be sent to ip2mac ().  Please note that
    * our definition of MTU is different from the traditional definition of that
    * parameter (which excludes the data link layer header). */
   maxl3_len = (unsigned short int) (MIN(maxbuflen, ((unsigned) p->net->n_mtu)));
 82404ac:	e0bffe17 	ldw	r2,-8(fp)
 82404b0:	10800617 	ldw	r2,24(r2)
 82404b4:	10800917 	ldw	r2,36(r2)
 82404b8:	1007883a 	mov	r3,r2
 82404bc:	e0bff617 	ldw	r2,-40(fp)
 82404c0:	10c0022e 	bgeu	r2,r3,82404cc <ip_fragment+0xf4>
 82404c4:	e0bff617 	ldw	r2,-40(fp)
 82404c8:	00000306 	br	82404d8 <ip_fragment+0x100>
 82404cc:	e0bffe17 	ldw	r2,-8(fp)
 82404d0:	10800617 	ldw	r2,24(r2)
 82404d4:	10800917 	ldw	r2,36(r2)
 82404d8:	e0bff70d 	sth	r2,-36(fp)

   /* get the length of the IP header of the original, unfragmented datagram */
   iphlen = ip_hlen(pip);
 82404dc:	e0bff517 	ldw	r2,-44(fp)
 82404e0:	10800003 	ldbu	r2,0(r2)
 82404e4:	108003cc 	andi	r2,r2,15
 82404e8:	1085883a 	add	r2,r2,r2
 82404ec:	1085883a 	add	r2,r2,r2
 82404f0:	e0bff785 	stb	r2,-34(fp)

   /* obtain the useable payload length in an IP datagram (after accounting for the 
    * length of the IP and data link layer headers) */
   l2hdr_len = (u_char) p->net->n_lnh;
 82404f4:	e0bffe17 	ldw	r2,-8(fp)
 82404f8:	10800617 	ldw	r2,24(r2)
 82404fc:	10800817 	ldw	r2,32(r2)
 8240500:	e0bff7c5 	stb	r2,-33(fp)
   useable_payload_len = maxl3_len - iphlen - l2hdr_len;
 8240504:	e0bff783 	ldbu	r2,-34(fp)
 8240508:	e0fff70b 	ldhu	r3,-36(fp)
 824050c:	1885c83a 	sub	r2,r3,r2
 8240510:	1007883a 	mov	r3,r2
 8240514:	e0bff7c3 	ldbu	r2,-33(fp)
 8240518:	1885c83a 	sub	r2,r3,r2
 824051c:	e0bff80d 	sth	r2,-32(fp)

   /* IP fragments must always have a length that is a multiple of 8 bytes, so we
    * need to round 'payload_len' down to the nearest multiple of 8 bytes. */
   useable_payload_len &= (~((unsigned short int) 0x07));
 8240520:	e0fff80b 	ldhu	r3,-32(fp)
 8240524:	00bffe04 	movi	r2,-8
 8240528:	1884703a 	and	r2,r3,r2
 824052c:	e0bff80d 	sth	r2,-32(fp)

   /* compute the number of packets that we need to send.  First compute the total
    * payload length of the "original" datagram (which could itself be a fragment). 
    */
   total_payload_len = (ntohs(pip->ip_len)) - iphlen;
 8240530:	e0bff517 	ldw	r2,-44(fp)
 8240534:	1080008b 	ldhu	r2,2(r2)
 8240538:	10bfffcc 	andi	r2,r2,65535
 824053c:	1004d23a 	srli	r2,r2,8
 8240540:	1007883a 	mov	r3,r2
 8240544:	e0bff517 	ldw	r2,-44(fp)
 8240548:	1080008b 	ldhu	r2,2(r2)
 824054c:	10bfffcc 	andi	r2,r2,65535
 8240550:	1004923a 	slli	r2,r2,8
 8240554:	1884b03a 	or	r2,r3,r2
 8240558:	1007883a 	mov	r3,r2
 824055c:	e0bff783 	ldbu	r2,-34(fp)
 8240560:	1885c83a 	sub	r2,r3,r2
 8240564:	e0bff88d 	sth	r2,-30(fp)
   num_frags = (total_payload_len / useable_payload_len);
 8240568:	e0bff88b 	ldhu	r2,-30(fp)
 824056c:	e0fff80b 	ldhu	r3,-32(fp)
 8240570:	180b883a 	mov	r5,r3
 8240574:	1009883a 	mov	r4,r2
 8240578:	8202c100 	call	8202c10 <__udivsi3>
 824057c:	e0bff30d 	sth	r2,-52(fp)
   if ((last_payload_len = (total_payload_len % useable_payload_len)) != 0)
 8240580:	e0bff88b 	ldhu	r2,-30(fp)
 8240584:	e0fff80b 	ldhu	r3,-32(fp)
 8240588:	180b883a 	mov	r5,r3
 824058c:	1009883a 	mov	r4,r2
 8240590:	8202c740 	call	8202c74 <__umodsi3>
 8240594:	e0bff90d 	sth	r2,-28(fp)
 8240598:	e0bff90b 	ldhu	r2,-28(fp)
 824059c:	10000326 	beq	r2,zero,82405ac <ip_fragment+0x1d4>
   {
      /* we will have one additional (also last) fragment that is smaller than the 
       * other fragments */
      ++num_frags;
 82405a0:	e0bff30b 	ldhu	r2,-52(fp)
 82405a4:	10800044 	addi	r2,r2,1
 82405a8:	e0bff30d 	sth	r2,-52(fp)
    * the one passed to this function) is interrupt-safe, then we use 
    * ip_fragment_lc () for creating the child fragments.  This decreases the 
    * amount of copying that needs to be done in those cases (as compared to this 
    * function); however, for larger packets, ip_fragment () becomes more efficient 
    * (than ip_fragment_lc ()). */
   if ((num_frags <= FRAG_SCHEME_SWITCH_THRESHOLD) && (!(p->flags & PKF_INTRUNSAFE)))
 82405ac:	e0bff30b 	ldhu	r2,-52(fp)
 82405b0:	10800128 	cmpgeui	r2,r2,4
 82405b4:	1000081e 	bne	r2,zero,82405d8 <ip_fragment+0x200>
 82405b8:	e0bffe17 	ldw	r2,-8(fp)
 82405bc:	10800a17 	ldw	r2,40(r2)
 82405c0:	1080040c 	andi	r2,r2,16
 82405c4:	1000041e 	bne	r2,zero,82405d8 <ip_fragment+0x200>
   {
      return (ip_fragment_lc (p, firsthop));
 82405c8:	e17fff17 	ldw	r5,-4(fp)
 82405cc:	e13ffe17 	ldw	r4,-8(fp)
 82405d0:	823ffb80 	call	823ffb8 <ip_fragment_lc>
 82405d4:	0000ec06 	br	8240988 <ip_fragment+0x5b0>
   }

   parent_frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 82405d8:	e0bff517 	ldw	r2,-44(fp)
 82405dc:	1080018b 	ldhu	r2,6(r2)
 82405e0:	10bfffcc 	andi	r2,r2,65535
 82405e4:	1004d23a 	srli	r2,r2,8
 82405e8:	10bfffcc 	andi	r2,r2,65535
 82405ec:	10c03fcc 	andi	r3,r2,255
 82405f0:	e0bff517 	ldw	r2,-44(fp)
 82405f4:	1080018b 	ldhu	r2,6(r2)
 82405f8:	10bfffcc 	andi	r2,r2,65535
 82405fc:	1004923a 	slli	r2,r2,8
 8240600:	10bfffcc 	andi	r2,r2,65535
 8240604:	1884b03a 	or	r2,r3,r2
 8240608:	100490fa 	slli	r2,r2,3
 824060c:	e0bff98d 	sth	r2,-26(fp)
   parent_mf = ((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF);
 8240610:	e0bff517 	ldw	r2,-44(fp)
 8240614:	1080018b 	ldhu	r2,6(r2)
 8240618:	10bfffcc 	andi	r2,r2,65535
 824061c:	1004d23a 	srli	r2,r2,8
 8240620:	1007883a 	mov	r3,r2
 8240624:	e0bff517 	ldw	r2,-44(fp)
 8240628:	1080018b 	ldhu	r2,6(r2)
 824062c:	10bfffcc 	andi	r2,r2,65535
 8240630:	1004923a 	slli	r2,r2,8
 8240634:	1884b03a 	or	r2,r3,r2
 8240638:	1088000c 	andi	r2,r2,8192
 824063c:	e0bffa0d 	sth	r2,-24(fp)
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 8240640:	e03ff38d 	sth	zero,-50(fp)
 8240644:	0000bf06 	br	8240944 <ip_fragment+0x56c>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 8240648:	01000084 	movi	r4,2
 824064c:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      newpkt = pk_alloc (useable_payload_len + iphlen + l2hdr_len); 
 8240650:	e0fff80b 	ldhu	r3,-32(fp)
 8240654:	e0bff783 	ldbu	r2,-34(fp)
 8240658:	1887883a 	add	r3,r3,r2
 824065c:	e0bff7c3 	ldbu	r2,-33(fp)
 8240660:	1885883a 	add	r2,r3,r2
 8240664:	1009883a 	mov	r4,r2
 8240668:	822c9ec0 	call	822c9ec <pk_alloc>
 824066c:	e0bffb15 	stw	r2,-20(fp)
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8240670:	01000084 	movi	r4,2
 8240674:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>

      if (newpkt == 0)
 8240678:	e0bffb17 	ldw	r2,-20(fp)
 824067c:	10000f1e 	bne	r2,zero,82406bc <ip_fragment+0x2e4>
      {
         /* free the packet that we are working with */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 8240680:	01000084 	movi	r4,2
 8240684:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
         pk_free(p);
 8240688:	e13ffe17 	ldw	r4,-8(fp)
 824068c:	822cd3c0 	call	822cd3c <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8240690:	01000084 	movi	r4,2
 8240694:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         ip_mib.ipFragFails++;
 8240698:	008209b4 	movhi	r2,2086
 824069c:	10ba6104 	addi	r2,r2,-5756
 82406a0:	10801117 	ldw	r2,68(r2)
 82406a4:	10c00044 	addi	r3,r2,1
 82406a8:	008209b4 	movhi	r2,2086
 82406ac:	10ba6104 	addi	r2,r2,-5756
 82406b0:	10c01115 	stw	r3,68(r2)
         return ENP_NOBUFFER;
 82406b4:	00bffac4 	movi	r2,-21
 82406b8:	0000b306 	br	8240988 <ip_fragment+0x5b0>
      }
      else
      {
         /* copy the IP header from the original datagram into the fragment */
         MEMCPY((newpkt->nb_buff + l2hdr_len), p->nb_prot, iphlen);
 82406bc:	e0bffb17 	ldw	r2,-20(fp)
 82406c0:	10c00117 	ldw	r3,4(r2)
 82406c4:	e0bff7c3 	ldbu	r2,-33(fp)
 82406c8:	1887883a 	add	r3,r3,r2
 82406cc:	e0bffe17 	ldw	r2,-8(fp)
 82406d0:	10800317 	ldw	r2,12(r2)
 82406d4:	e13ff783 	ldbu	r4,-34(fp)
 82406d8:	200d883a 	mov	r6,r4
 82406dc:	100b883a 	mov	r5,r2
 82406e0:	1809883a 	mov	r4,r3
 82406e4:	8202f100 	call	8202f10 <memcpy>

         /* compute the amount of payload that needs to be copied into each 
          * child fragment */
         if (i < (num_frags - 1))
 82406e8:	e0fff38b 	ldhu	r3,-50(fp)
 82406ec:	e0bff30b 	ldhu	r2,-52(fp)
 82406f0:	10bfffc4 	addi	r2,r2,-1
 82406f4:	1880030e 	bge	r3,r2,8240704 <ip_fragment+0x32c>
         {
            amt_to_copy = useable_payload_len;
 82406f8:	e0bff80b 	ldhu	r2,-32(fp)
 82406fc:	e0bff40d 	sth	r2,-48(fp)
 8240700:	00000606 	br	824071c <ip_fragment+0x344>
         }
         else
         {
            amt_to_copy = ((last_payload_len == 0) ? useable_payload_len : last_payload_len);
 8240704:	e0bff90b 	ldhu	r2,-28(fp)
 8240708:	1000021e 	bne	r2,zero,8240714 <ip_fragment+0x33c>
 824070c:	e0bff80b 	ldhu	r2,-32(fp)
 8240710:	00000106 	br	8240718 <ip_fragment+0x340>
 8240714:	e0bff90b 	ldhu	r2,-28(fp)
 8240718:	e0bff40d 	sth	r2,-48(fp)
         }
         MEMCPY((newpkt->nb_buff + l2hdr_len + iphlen), p->nb_prot + iphlen + (useable_payload_len * i), amt_to_copy);
 824071c:	e0bffb17 	ldw	r2,-20(fp)
 8240720:	10c00117 	ldw	r3,4(r2)
 8240724:	e13ff7c3 	ldbu	r4,-33(fp)
 8240728:	e0bff783 	ldbu	r2,-34(fp)
 824072c:	2085883a 	add	r2,r4,r2
 8240730:	188f883a 	add	r7,r3,r2
 8240734:	e0bffe17 	ldw	r2,-8(fp)
 8240738:	10c00317 	ldw	r3,12(r2)
 824073c:	e0bff783 	ldbu	r2,-34(fp)
 8240740:	e17ff80b 	ldhu	r5,-32(fp)
 8240744:	e13ff38b 	ldhu	r4,-50(fp)
 8240748:	2909383a 	mul	r4,r5,r4
 824074c:	1105883a 	add	r2,r2,r4
 8240750:	1885883a 	add	r2,r3,r2
 8240754:	e0fff40b 	ldhu	r3,-48(fp)
 8240758:	180d883a 	mov	r6,r3
 824075c:	100b883a 	mov	r5,r2
 8240760:	3809883a 	mov	r4,r7
 8240764:	8202f100 	call	8202f10 <memcpy>

         /* set up the various netbuf fields for the fragment */
         newpkt->nb_prot = newpkt->nb_buff + l2hdr_len;
 8240768:	e0bffb17 	ldw	r2,-20(fp)
 824076c:	10c00117 	ldw	r3,4(r2)
 8240770:	e0bff7c3 	ldbu	r2,-33(fp)
 8240774:	1887883a 	add	r3,r3,r2
 8240778:	e0bffb17 	ldw	r2,-20(fp)
 824077c:	10c00315 	stw	r3,12(r2)
         newpkt->nb_plen = iphlen + amt_to_copy;
 8240780:	e0fff783 	ldbu	r3,-34(fp)
 8240784:	e0bff40b 	ldhu	r2,-48(fp)
 8240788:	1885883a 	add	r2,r3,r2
 824078c:	1007883a 	mov	r3,r2
 8240790:	e0bffb17 	ldw	r2,-20(fp)
 8240794:	10c00415 	stw	r3,16(r2)
         newpkt->net = p->net;
 8240798:	e0bffe17 	ldw	r2,-8(fp)
 824079c:	10c00617 	ldw	r3,24(r2)
 82407a0:	e0bffb17 	ldw	r2,-20(fp)
 82407a4:	10c00615 	stw	r3,24(r2)
         newpkt->fhost = p->fhost;
 82407a8:	e0bffe17 	ldw	r2,-8(fp)
 82407ac:	10c00717 	ldw	r3,28(r2)
 82407b0:	e0bffb17 	ldw	r2,-20(fp)
 82407b4:	10c00715 	stw	r3,28(r2)
         /* type and nb_tstamp fields are not used in the egress direction, but we set 'type' anyway */
         newpkt->type = htons(IPTP);
 82407b8:	e0bffb17 	ldw	r2,-20(fp)
 82407bc:	00c20004 	movi	r3,2048
 82407c0:	10c0080d 	sth	r3,32(r2)

         /* now set the Total Length, Fragment Offset, and More Fragments fields */
         newpip = ip_head(newpkt);
 82407c4:	e0bffb17 	ldw	r2,-20(fp)
 82407c8:	10800317 	ldw	r2,12(r2)
 82407cc:	e0bffc15 	stw	r2,-16(fp)
         newpip->ip_len = htons(newpkt->nb_plen);
 82407d0:	e0bffb17 	ldw	r2,-20(fp)
 82407d4:	10800417 	ldw	r2,16(r2)
 82407d8:	1004d23a 	srli	r2,r2,8
 82407dc:	10803fcc 	andi	r2,r2,255
 82407e0:	1007883a 	mov	r3,r2
 82407e4:	e0bffb17 	ldw	r2,-20(fp)
 82407e8:	10800417 	ldw	r2,16(r2)
 82407ec:	1004923a 	slli	r2,r2,8
 82407f0:	1884b03a 	or	r2,r3,r2
 82407f4:	1007883a 	mov	r3,r2
 82407f8:	e0bffc17 	ldw	r2,-16(fp)
 82407fc:	10c0008d 	sth	r3,2(r2)
         /* the following statement will reset DF and MF bits */
         newpip->ip_flgs_foff = htons((parent_frag_offset + (useable_payload_len * i)) >> 3);
 8240800:	e0fff98b 	ldhu	r3,-26(fp)
 8240804:	e13ff80b 	ldhu	r4,-32(fp)
 8240808:	e0bff38b 	ldhu	r2,-50(fp)
 824080c:	2085383a 	mul	r2,r4,r2
 8240810:	1885883a 	add	r2,r3,r2
 8240814:	1005d2fa 	srai	r2,r2,11
 8240818:	10803fcc 	andi	r2,r2,255
 824081c:	100b883a 	mov	r5,r2
 8240820:	e0fff98b 	ldhu	r3,-26(fp)
 8240824:	e13ff80b 	ldhu	r4,-32(fp)
 8240828:	e0bff38b 	ldhu	r2,-50(fp)
 824082c:	2085383a 	mul	r2,r4,r2
 8240830:	1885883a 	add	r2,r3,r2
 8240834:	1005d0fa 	srai	r2,r2,3
 8240838:	1004923a 	slli	r2,r2,8
 824083c:	2884b03a 	or	r2,r5,r2
 8240840:	1007883a 	mov	r3,r2
 8240844:	e0bffc17 	ldw	r2,-16(fp)
 8240848:	10c0018d 	sth	r3,6(r2)
          *     child fragments but the last will have the MF bit set)
          * (2) Parent fragment offset = x, MF = 1: first or middle fragment (FF or MF)
          *     (all child fragments will have the MF bit set)
          * (3) Parent fragment offset > 0, MF = 0: last fragment (LF) (all child fragments
          *     except the last will have the MF bit set) */
         if (i < (num_frags - 1))
 824084c:	e0fff38b 	ldhu	r3,-50(fp)
 8240850:	e0bff30b 	ldhu	r2,-52(fp)
 8240854:	10bfffc4 	addi	r2,r2,-1
 8240858:	1880070e 	bge	r3,r2,8240878 <ip_fragment+0x4a0>
         {
            newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 824085c:	e0bffc17 	ldw	r2,-16(fp)
 8240860:	1080018b 	ldhu	r2,6(r2)
 8240864:	10800814 	ori	r2,r2,32
 8240868:	1007883a 	mov	r3,r2
 824086c:	e0bffc17 	ldw	r2,-16(fp)
 8240870:	10c0018d 	sth	r3,6(r2)
 8240874:	00000806 	br	8240898 <ip_fragment+0x4c0>
         }
         else
         {
            if (parent_mf)
 8240878:	e0bffa0b 	ldhu	r2,-24(fp)
 824087c:	10000626 	beq	r2,zero,8240898 <ip_fragment+0x4c0>
            {
               newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 8240880:	e0bffc17 	ldw	r2,-16(fp)
 8240884:	1080018b 	ldhu	r2,6(r2)
 8240888:	10800814 	ori	r2,r2,32
 824088c:	1007883a 	mov	r3,r2
 8240890:	e0bffc17 	ldw	r2,-16(fp)
 8240894:	10c0018d 	sth	r3,6(r2)
            }
         }

         /* finally, update the checksum */
         newpip->ip_chksum = IPXSUM;
 8240898:	e0bffc17 	ldw	r2,-16(fp)
 824089c:	1000028d 	sth	zero,10(r2)
         newpip->ip_chksum = ~cksum(newpip, (iphlen/2));
 82408a0:	e0bff783 	ldbu	r2,-34(fp)
 82408a4:	1004d07a 	srli	r2,r2,1
 82408a8:	10803fcc 	andi	r2,r2,255
 82408ac:	100b883a 	mov	r5,r2
 82408b0:	e13ffc17 	ldw	r4,-16(fp)
 82408b4:	82287b40 	call	82287b4 <cksum>
 82408b8:	0084303a 	nor	r2,zero,r2
 82408bc:	1007883a 	mov	r3,r2
 82408c0:	e0bffc17 	ldw	r2,-16(fp)
 82408c4:	10c0028d 	sth	r3,10(r2)

         ip_mib.ipFragCreates++;
 82408c8:	008209b4 	movhi	r2,2086
 82408cc:	10ba6104 	addi	r2,r2,-5756
 82408d0:	10801217 	ldw	r2,72(r2)
 82408d4:	10c00044 	addi	r3,r2,1
 82408d8:	008209b4 	movhi	r2,2086
 82408dc:	10ba6104 	addi	r2,r2,-5756
 82408e0:	10c01215 	stw	r3,72(r2)

         /* we're done; hand the packet off to ip2mac () */
         e = ip2mac (newpkt, firsthop);
 82408e4:	e17fff17 	ldw	r5,-4(fp)
 82408e8:	e13ffb17 	ldw	r4,-20(fp)
 82408ec:	82266f80 	call	82266f8 <ip2mac>
 82408f0:	e0bffd15 	stw	r2,-12(fp)
         if (e < 0)
 82408f4:	e0bffd17 	ldw	r2,-12(fp)
 82408f8:	10000f0e 	bge	r2,zero,8240938 <ip_fragment+0x560>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 82408fc:	01000084 	movi	r4,2
 8240900:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
            pk_free(p);
 8240904:	e13ffe17 	ldw	r4,-8(fp)
 8240908:	822cd3c0 	call	822cd3c <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824090c:	01000084 	movi	r4,2
 8240910:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 8240914:	008209b4 	movhi	r2,2086
 8240918:	10ba6104 	addi	r2,r2,-5756
 824091c:	10801117 	ldw	r2,68(r2)
 8240920:	10c00044 	addi	r3,r2,1
 8240924:	008209b4 	movhi	r2,2086
 8240928:	10ba6104 	addi	r2,r2,-5756
 824092c:	10c01115 	stw	r3,68(r2)
            return e;
 8240930:	e0bffd17 	ldw	r2,-12(fp)
 8240934:	00001406 	br	8240988 <ip_fragment+0x5b0>
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 8240938:	e0bff38b 	ldhu	r2,-50(fp)
 824093c:	10800044 	addi	r2,r2,1
 8240940:	e0bff38d 	sth	r2,-50(fp)
 8240944:	e0fff38b 	ldhu	r3,-50(fp)
 8240948:	e0bff30b 	ldhu	r2,-52(fp)
 824094c:	18bf3e36 	bltu	r3,r2,8240648 <ip_fragment+0x270>

   } /* end FOR (all child fragments) */

   /* free the parent buffer since all of the data from it have been copied 
    * out into the child fragments */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8240950:	01000084 	movi	r4,2
 8240954:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   pk_free(p);
 8240958:	e13ffe17 	ldw	r4,-8(fp)
 824095c:	822cd3c0 	call	822cd3c <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8240960:	01000084 	movi	r4,2
 8240964:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 8240968:	008209b4 	movhi	r2,2086
 824096c:	10ba6104 	addi	r2,r2,-5756
 8240970:	10801017 	ldw	r2,64(r2)
 8240974:	10c00044 	addi	r3,r2,1
 8240978:	008209b4 	movhi	r2,2086
 824097c:	10ba6104 	addi	r2,r2,-5756
 8240980:	10c01015 	stw	r3,64(r2)

   return 0;
 8240984:	0005883a 	mov	r2,zero
}
 8240988:	e037883a 	mov	sp,fp
 824098c:	dfc00117 	ldw	ra,4(sp)
 8240990:	df000017 	ldw	fp,0(sp)
 8240994:	dec00204 	addi	sp,sp,8
 8240998:	f800283a 	ret

0824099c <ip_mymach>:
 * certain foreign host. 
 */

ip_addr
ip_mymach(ip_addr host)
{
 824099c:	defffa04 	addi	sp,sp,-24
 82409a0:	dfc00515 	stw	ra,20(sp)
 82409a4:	df000415 	stw	fp,16(sp)
 82409a8:	df000404 	addi	fp,sp,16
 82409ac:	e13fff15 	stw	r4,-4(fp)

#ifndef MULTI_HOMED /* single static interface */
   USE_ARG(host);
   return(nets[0]->n_ipaddr);   /* always use address from only net */
#else   /* MULTI_HOMED */
   tnet = iproute(host, &temp);
 82409b0:	e0bffe04 	addi	r2,fp,-8
 82409b4:	100b883a 	mov	r5,r2
 82409b8:	e13fff17 	ldw	r4,-4(fp)
 82409bc:	8240ce80 	call	8240ce8 <iproute>
 82409c0:	e0bffd15 	stw	r2,-12(fp)
   if (tnet == 0)
 82409c4:	e0bffd17 	ldw	r2,-12(fp)
 82409c8:	1000161e 	bne	r2,zero,8240a24 <ip_mymach+0x88>
   {
#ifdef   NPDEBUG
      if (NDEBUG & (PROTERR|INFOMSG))
 82409cc:	d0a08317 	ldw	r2,-32244(gp)
 82409d0:	1080050c 	andi	r2,r2,20
 82409d4:	10001126 	beq	r2,zero,8240a1c <ip_mymach+0x80>
         dprintf("IP: Couldn't route to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 82409d8:	e0bfff17 	ldw	r2,-4(fp)
 82409dc:	10c03fcc 	andi	r3,r2,255
 82409e0:	e0bfff17 	ldw	r2,-4(fp)
 82409e4:	1004d23a 	srli	r2,r2,8
 82409e8:	11003fcc 	andi	r4,r2,255
 82409ec:	e0bfff17 	ldw	r2,-4(fp)
 82409f0:	1004d43a 	srli	r2,r2,16
 82409f4:	11403fcc 	andi	r5,r2,255
 82409f8:	e0bfff17 	ldw	r2,-4(fp)
 82409fc:	1004d63a 	srli	r2,r2,24
 8240a00:	d8800015 	stw	r2,0(sp)
 8240a04:	280f883a 	mov	r7,r5
 8240a08:	200d883a 	mov	r6,r4
 8240a0c:	180b883a 	mov	r5,r3
 8240a10:	01020974 	movhi	r4,2085
 8240a14:	21049204 	addi	r4,r4,4680
 8240a18:	82033a00 	call	82033a0 <printf>
#endif   /* NPDEBUG */
      return 0L;
 8240a1c:	0005883a 	mov	r2,zero
 8240a20:	00000206 	br	8240a2c <ip_mymach+0x90>
   }
   return tnet->n_ipaddr;
 8240a24:	e0bffd17 	ldw	r2,-12(fp)
 8240a28:	10800a17 	ldw	r2,40(r2)
#endif /* MULTI_HOMED */
}
 8240a2c:	e037883a 	mov	sp,fp
 8240a30:	dfc00117 	ldw	ra,4(sp)
 8240a34:	df000017 	ldw	fp,0(sp)
 8240a38:	dec00204 	addi	sp,sp,8
 8240a3c:	f800283a 	ret

08240a40 <ip_dump>:
 * RETURNS: void
 */

void
ip_dump(PACKET p)
{
 8240a40:	defff704 	addi	sp,sp,-36
 8240a44:	dfc00815 	stw	ra,32(sp)
 8240a48:	df000715 	stw	fp,28(sp)
 8240a4c:	df000704 	addi	fp,sp,28
 8240a50:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;
   unsigned char * cp;
   unsigned short xsum, osum;

   pip = ip_head(p);
 8240a54:	e0bfff17 	ldw	r2,-4(fp)
 8240a58:	10800317 	ldw	r2,12(r2)
 8240a5c:	e0bffc15 	stw	r2,-16(fp)
   osum = pip->ip_chksum;
 8240a60:	e0bffc17 	ldw	r2,-16(fp)
 8240a64:	1080028b 	ldhu	r2,10(r2)
 8240a68:	e0bffd0d 	sth	r2,-12(fp)
   pip->ip_chksum = 0;
 8240a6c:	e0bffc17 	ldw	r2,-16(fp)
 8240a70:	1000028d 	sth	zero,10(r2)
   xsum = ~cksum(pip, ip_hlen(pip) >> 1);
 8240a74:	e0bffc17 	ldw	r2,-16(fp)
 8240a78:	10800003 	ldbu	r2,0(r2)
 8240a7c:	10803fcc 	andi	r2,r2,255
 8240a80:	108003cc 	andi	r2,r2,15
 8240a84:	1085883a 	add	r2,r2,r2
 8240a88:	1085883a 	add	r2,r2,r2
 8240a8c:	1005d07a 	srai	r2,r2,1
 8240a90:	100b883a 	mov	r5,r2
 8240a94:	e13ffc17 	ldw	r4,-16(fp)
 8240a98:	82287b40 	call	82287b4 <cksum>
 8240a9c:	0084303a 	nor	r2,zero,r2
 8240aa0:	e0bffd8d 	sth	r2,-10(fp)

   if (osum != xsum)          /* trap here if checksum is wrong */
 8240aa4:	e0fffd0b 	ldhu	r3,-12(fp)
 8240aa8:	e0bffd8b 	ldhu	r2,-10(fp)
 8240aac:	18800126 	beq	r3,r2,8240ab4 <ip_dump+0x74>
   {
      dtrap();
 8240ab0:	822d5940 	call	822d594 <dtrap>
   /* dtrap() is fatal in the default Windows implementation, so
    * we comment it out */
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
 8240ab4:	01420974 	movhi	r5,2085
 8240ab8:	29449b04 	addi	r5,r5,4716
 8240abc:	0009883a 	mov	r4,zero
 8240ac0:	8228e600 	call	8228e60 <ns_printf>
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
 8240ac4:	e0bffc17 	ldw	r2,-16(fp)
 8240ac8:	e0bffe15 	stw	r2,-8(fp)
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 8240acc:	e0bffe17 	ldw	r2,-8(fp)
 8240ad0:	10800003 	ldbu	r2,0(r2)
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 8240ad4:	11403fcc 	andi	r5,r2,255
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 8240ad8:	e0bffe17 	ldw	r2,-8(fp)
 8240adc:	10800044 	addi	r2,r2,1
 8240ae0:	10800003 	ldbu	r2,0(r2)
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 8240ae4:	11803fcc 	andi	r6,r2,255
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 8240ae8:	e0bffc17 	ldw	r2,-16(fp)
 8240aec:	1080008b 	ldhu	r2,2(r2)
 8240af0:	10bfffcc 	andi	r2,r2,65535
 8240af4:	1004d23a 	srli	r2,r2,8
 8240af8:	10bfffcc 	andi	r2,r2,65535
 8240afc:	10c03fcc 	andi	r3,r2,255
 8240b00:	e0bffc17 	ldw	r2,-16(fp)
 8240b04:	1080008b 	ldhu	r2,2(r2)
 8240b08:	10bfffcc 	andi	r2,r2,65535
 8240b0c:	1004923a 	slli	r2,r2,8
 8240b10:	10bfffcc 	andi	r2,r2,65535
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 8240b14:	1884b03a 	or	r2,r3,r2
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 8240b18:	e0fffc17 	ldw	r3,-16(fp)
 8240b1c:	18c0010b 	ldhu	r3,4(r3)
 8240b20:	18ffffcc 	andi	r3,r3,65535
 8240b24:	1806d23a 	srli	r3,r3,8
 8240b28:	18ffffcc 	andi	r3,r3,65535
 8240b2c:	19003fcc 	andi	r4,r3,255
 8240b30:	e0fffc17 	ldw	r3,-16(fp)
 8240b34:	18c0010b 	ldhu	r3,4(r3)
 8240b38:	18ffffcc 	andi	r3,r3,65535
 8240b3c:	1806923a 	slli	r3,r3,8
 8240b40:	18ffffcc 	andi	r3,r3,65535
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 8240b44:	20c6b03a 	or	r3,r4,r3
 8240b48:	d8c00115 	stw	r3,4(sp)
 8240b4c:	d8800015 	stw	r2,0(sp)
 8240b50:	300f883a 	mov	r7,r6
 8240b54:	280d883a 	mov	r6,r5
 8240b58:	01420974 	movhi	r5,2085
 8240b5c:	2944a004 	addi	r5,r5,4736
 8240b60:	0009883a 	mov	r4,zero
 8240b64:	8228e600 	call	8228e60 <ns_printf>
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
 8240b68:	e0bffe17 	ldw	r2,-8(fp)
 8240b6c:	10800184 	addi	r2,r2,6
 8240b70:	1080000b 	ldhu	r2,0(r2)
 8240b74:	10bfffcc 	andi	r2,r2,65535
 8240b78:	1004d23a 	srli	r2,r2,8
 8240b7c:	10bfffcc 	andi	r2,r2,65535
 8240b80:	10c03fcc 	andi	r3,r2,255
 8240b84:	e0bffe17 	ldw	r2,-8(fp)
 8240b88:	10800184 	addi	r2,r2,6
 8240b8c:	1080000b 	ldhu	r2,0(r2)
 8240b90:	10bfffcc 	andi	r2,r2,65535
 8240b94:	1004923a 	slli	r2,r2,8
 8240b98:	10bfffcc 	andi	r2,r2,65535

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 8240b9c:	188cb03a 	or	r6,r3,r2
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
 8240ba0:	e0bffc17 	ldw	r2,-16(fp)
 8240ba4:	10800203 	ldbu	r2,8(r2)

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 8240ba8:	11c03fcc 	andi	r7,r2,255
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
 8240bac:	e0bffc17 	ldw	r2,-16(fp)
 8240bb0:	10800243 	ldbu	r2,9(r2)

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 8240bb4:	10c03fcc 	andi	r3,r2,255
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
    htons(osum), (osum==xsum)?"ok":"bad");
 8240bb8:	e0bffd0b 	ldhu	r2,-12(fp)
 8240bbc:	1004d23a 	srli	r2,r2,8
 8240bc0:	10bfffcc 	andi	r2,r2,65535
 8240bc4:	11003fcc 	andi	r4,r2,255
 8240bc8:	e0bffd0b 	ldhu	r2,-12(fp)
 8240bcc:	1004923a 	slli	r2,r2,8
 8240bd0:	10bfffcc 	andi	r2,r2,65535

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 8240bd4:	2088b03a 	or	r4,r4,r2
 8240bd8:	e17ffd0b 	ldhu	r5,-12(fp)
 8240bdc:	e0bffd8b 	ldhu	r2,-10(fp)
 8240be0:	2880031e 	bne	r5,r2,8240bf0 <ip_dump+0x1b0>
 8240be4:	00820974 	movhi	r2,2085
 8240be8:	1084ac04 	addi	r2,r2,4784
 8240bec:	00000206 	br	8240bf8 <ip_dump+0x1b8>
 8240bf0:	00820974 	movhi	r2,2085
 8240bf4:	1084ad04 	addi	r2,r2,4788
 8240bf8:	d8800215 	stw	r2,8(sp)
 8240bfc:	d9000115 	stw	r4,4(sp)
 8240c00:	d8c00015 	stw	r3,0(sp)
 8240c04:	01420974 	movhi	r5,2085
 8240c08:	2944ae04 	addi	r5,r5,4792
 8240c0c:	0009883a 	mov	r4,zero
 8240c10:	8228e600 	call	8228e60 <ns_printf>
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
    htons(osum), (osum==xsum)?"ok":"bad");
   ns_printf(NULL ,"src: %u.%u.%u.%u  ", PUSH_IPADDR(pip->ip_src));
 8240c14:	e0bffc17 	ldw	r2,-16(fp)
 8240c18:	10800317 	ldw	r2,12(r2)
 8240c1c:	11003fcc 	andi	r4,r2,255
 8240c20:	e0bffc17 	ldw	r2,-16(fp)
 8240c24:	10800317 	ldw	r2,12(r2)
 8240c28:	1004d23a 	srli	r2,r2,8
 8240c2c:	11403fcc 	andi	r5,r2,255
 8240c30:	e0bffc17 	ldw	r2,-16(fp)
 8240c34:	10800317 	ldw	r2,12(r2)
 8240c38:	1004d43a 	srli	r2,r2,16
 8240c3c:	10803fcc 	andi	r2,r2,255
 8240c40:	e0fffc17 	ldw	r3,-16(fp)
 8240c44:	18c00317 	ldw	r3,12(r3)
 8240c48:	1806d63a 	srli	r3,r3,24
 8240c4c:	d8c00115 	stw	r3,4(sp)
 8240c50:	d8800015 	stw	r2,0(sp)
 8240c54:	280f883a 	mov	r7,r5
 8240c58:	200d883a 	mov	r6,r4
 8240c5c:	01420974 	movhi	r5,2085
 8240c60:	2944be04 	addi	r5,r5,4856
 8240c64:	0009883a 	mov	r4,zero
 8240c68:	8228e600 	call	8228e60 <ns_printf>
   ns_printf(NULL ,"dest: %u.%u.%u.%u\n", PUSH_IPADDR(pip->ip_dest));
 8240c6c:	e0bffc17 	ldw	r2,-16(fp)
 8240c70:	10800417 	ldw	r2,16(r2)
 8240c74:	11003fcc 	andi	r4,r2,255
 8240c78:	e0bffc17 	ldw	r2,-16(fp)
 8240c7c:	10800417 	ldw	r2,16(r2)
 8240c80:	1004d23a 	srli	r2,r2,8
 8240c84:	11403fcc 	andi	r5,r2,255
 8240c88:	e0bffc17 	ldw	r2,-16(fp)
 8240c8c:	10800417 	ldw	r2,16(r2)
 8240c90:	1004d43a 	srli	r2,r2,16
 8240c94:	10803fcc 	andi	r2,r2,255
 8240c98:	e0fffc17 	ldw	r3,-16(fp)
 8240c9c:	18c00417 	ldw	r3,16(r3)
 8240ca0:	1806d63a 	srli	r3,r3,24
 8240ca4:	d8c00115 	stw	r3,4(sp)
 8240ca8:	d8800015 	stw	r2,0(sp)
 8240cac:	280f883a 	mov	r7,r5
 8240cb0:	200d883a 	mov	r6,r4
 8240cb4:	01420974 	movhi	r5,2085
 8240cb8:	2944c304 	addi	r5,r5,4876
 8240cbc:	0009883a 	mov	r4,zero
 8240cc0:	8228e600 	call	8228e60 <ns_printf>

   pip->ip_chksum = osum;     /* fix what we clobbered */
 8240cc4:	e0bffc17 	ldw	r2,-16(fp)
 8240cc8:	e0fffd0b 	ldhu	r3,-12(fp)
 8240ccc:	10c0028d 	sth	r3,10(r2)
}
 8240cd0:	0001883a 	nop
 8240cd4:	e037883a 	mov	sp,fp
 8240cd8:	dfc00117 	ldw	ra,4(sp)
 8240cdc:	df000017 	ldw	fp,0(sp)
 8240ce0:	dec00204 	addi	sp,sp,8
 8240ce4:	f800283a 	ret

08240ce8 <iproute>:
 * RETURNS: Returns NULL when unable to route, else returns a NET pointer.
 */

NET
iproute(ip_addr host, ip_addr * hop1)
{
 8240ce8:	defff804 	addi	sp,sp,-32
 8240cec:	dfc00715 	stw	ra,28(sp)
 8240cf0:	df000615 	stw	fp,24(sp)
 8240cf4:	df000604 	addi	fp,sp,24
 8240cf8:	e13ffe15 	stw	r4,-8(fp)
 8240cfc:	e17fff15 	stw	r5,-4(fp)
   NET      ifp;
#ifdef IP_ROUTING
   RTMIB    rtp;
#endif   /* IP_ROUTING */

   if (host == 0L)      /* Sanity check parameter. */
 8240d00:	e0bffe17 	ldw	r2,-8(fp)
 8240d04:	1000021e 	bne	r2,zero,8240d10 <iproute+0x28>
      return NULL;
 8240d08:	0005883a 	mov	r2,zero
 8240d0c:	00006706 	br	8240eac <iproute+0x1c4>
    * stack has been initialized (tk_yield() gets called out of the 
    * dialer code as part of PPP initialization), one symptom of 
    * which is the routing table not being present yet. if this 
    * happens, quit. 
    */
   if (rt_mib == NULL)
 8240d10:	d0a0c617 	ldw	r2,-31976(gp)
 8240d14:	1000021e 	bne	r2,zero,8240d20 <iproute+0x38>
      return NULL;
 8240d18:	0005883a 	mov	r2,zero
 8240d1c:	00006306 	br	8240eac <iproute+0x1c4>
#endif   /* BTREE_ROUTING */

   /* see if the host matches the cached route */
   if (cachedRoute)     /* don't test this if route is null  */
 8240d20:	d0a0d017 	ldw	r2,-31936(gp)
 8240d24:	10000e26 	beq	r2,zero,8240d60 <iproute+0x78>
   {
      if (cachedRoute->ipRouteDest == host)    /* exact match */
 8240d28:	d0a0d017 	ldw	r2,-31936(gp)
 8240d2c:	10c00017 	ldw	r3,0(r2)
 8240d30:	e0bffe17 	ldw	r2,-8(fp)
 8240d34:	18800a1e 	bne	r3,r2,8240d60 <iproute+0x78>
      {
         *hop1 = cachedRoute->ipRouteNextHop;   /* fill in nexthop IP addr */
 8240d38:	d0a0d017 	ldw	r2,-31936(gp)
 8240d3c:	10c00617 	ldw	r3,24(r2)
 8240d40:	e0bfff17 	ldw	r2,-4(fp)
 8240d44:	10c00015 	stw	r3,0(r2)
         cachedRoute->ipRouteAge = cticks;      /* timestamp route entry */
 8240d48:	d0a0d017 	ldw	r2,-31936(gp)
 8240d4c:	d0e0a817 	ldw	r3,-32096(gp)
 8240d50:	10c00915 	stw	r3,36(r2)
         return(cachedRoute->ifp); /* net to send on */
 8240d54:	d0a0d017 	ldw	r2,-31936(gp)
 8240d58:	10800e17 	ldw	r2,56(r2)
 8240d5c:	00005306 	br	8240eac <iproute+0x1c4>
      }
   }

   rtp = rt_lookup(host);
 8240d60:	e13ffe17 	ldw	r4,-8(fp)
 8240d64:	82441dc0 	call	82441dc <rt_lookup>
 8240d68:	e0bffd15 	stw	r2,-12(fp)
   if(rtp)
 8240d6c:	e0bffd17 	ldw	r2,-12(fp)
 8240d70:	10000926 	beq	r2,zero,8240d98 <iproute+0xb0>
   {
      cachedRoute = rtp;
 8240d74:	e0bffd17 	ldw	r2,-12(fp)
 8240d78:	d0a0d015 	stw	r2,-31936(gp)
      *hop1 = rtp->ipRouteNextHop;  /* fill in IP dest (next hop) */
 8240d7c:	e0bffd17 	ldw	r2,-12(fp)
 8240d80:	10c00617 	ldw	r3,24(r2)
 8240d84:	e0bfff17 	ldw	r2,-4(fp)
 8240d88:	10c00015 	stw	r3,0(r2)
      return(rtp->ifp);             /* return pointer to net */
 8240d8c:	e0bffd17 	ldw	r2,-12(fp)
 8240d90:	10800e17 	ldw	r2,56(r2)
 8240d94:	00004506 	br	8240eac <iproute+0x1c4>
    * the initial state for the for loop that iterates through the
    * list), but only build the iterator for multi-homed systems
    * because single-homed systems are often memory-limited systems as
    * well.  
    */
   ifp = (NET)(netlist.q_head);
 8240d98:	008209b4 	movhi	r2,2086
 8240d9c:	10ba5c04 	addi	r2,r2,-5776
 8240da0:	10800017 	ldw	r2,0(r2)
 8240da4:	e0bffc15 	stw	r2,-16(fp)
   i = 0;
 8240da8:	e03ffb15 	stw	zero,-20(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 8240dac:	00002406 	br	8240e40 <iproute+0x158>
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
 8240db0:	e0bffc17 	ldw	r2,-16(fp)
 8240db4:	10800c17 	ldw	r2,48(r2)
 8240db8:	10001b26 	beq	r2,zero,8240e28 <iproute+0x140>
         (ifp->n_ipaddr != 0) && 
 8240dbc:	e0bffc17 	ldw	r2,-16(fp)
 8240dc0:	10800a17 	ldw	r2,40(r2)
   i = 0;
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
 8240dc4:	10001826 	beq	r2,zero,8240e28 <iproute+0x140>
         (ifp->n_ipaddr != 0) && 
         ((ifp->n_ipaddr & ifp->snmask) == (host & ifp->snmask)))
 8240dc8:	e0bffc17 	ldw	r2,-16(fp)
 8240dcc:	10c00a17 	ldw	r3,40(r2)
 8240dd0:	e0bffe17 	ldw	r2,-8(fp)
 8240dd4:	1886f03a 	xor	r3,r3,r2
 8240dd8:	e0bffc17 	ldw	r2,-16(fp)
 8240ddc:	10800c17 	ldw	r2,48(r2)
 8240de0:	1884703a 	and	r2,r3,r2
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
         (ifp->n_ipaddr != 0) && 
 8240de4:	1000101e 	bne	r2,zero,8240e28 <iproute+0x140>
         ((ifp->n_ipaddr & ifp->snmask) == (host & ifp->snmask)))
      {
#ifdef IP_ROUTING
         /* make a cached Route entry for next time */
         cachedRoute = add_route(host, 0xFFFFFFFF, host, i, IPRP_OTHER);
 8240de8:	00800044 	movi	r2,1
 8240dec:	d8800015 	stw	r2,0(sp)
 8240df0:	e1fffb17 	ldw	r7,-20(fp)
 8240df4:	e1bffe17 	ldw	r6,-8(fp)
 8240df8:	017fffc4 	movi	r5,-1
 8240dfc:	e13ffe17 	ldw	r4,-8(fp)
 8240e00:	82443300 	call	8244330 <add_route>
 8240e04:	d0a0d015 	stw	r2,-31936(gp)
#ifdef NPDEBUG
         if (cachedRoute == NULL)
 8240e08:	d0a0d017 	ldw	r2,-31936(gp)
 8240e0c:	1000011e 	bne	r2,zero,8240e14 <iproute+0x12c>
            dtrap();
 8240e10:	822d5940 	call	822d594 <dtrap>
#endif   /* NPDEBUG */
#endif   /* IP_ROUTING */
         *hop1 = host;
 8240e14:	e0bfff17 	ldw	r2,-4(fp)
 8240e18:	e0fffe17 	ldw	r3,-8(fp)
 8240e1c:	10c00015 	stw	r3,0(r2)
         return ifp;
 8240e20:	e0bffc17 	ldw	r2,-16(fp)
 8240e24:	00002106 	br	8240eac <iproute+0x1c4>
    * well.  
    */
   ifp = (NET)(netlist.q_head);
   i = 0;
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 8240e28:	e0bffc17 	ldw	r2,-16(fp)
 8240e2c:	10800017 	ldw	r2,0(r2)
 8240e30:	e0bffc15 	stw	r2,-16(fp)
 8240e34:	e0bffb17 	ldw	r2,-20(fp)
 8240e38:	10800044 	addi	r2,r2,1
 8240e3c:	e0bffb15 	stw	r2,-20(fp)
 8240e40:	e0bffc17 	ldw	r2,-16(fp)
 8240e44:	103fda1e 	bne	r2,zero,8240db0 <iproute+0xc8>
#endif   /* IP_LOOPBACK */

   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
 8240e48:	008209b4 	movhi	r2,2086
 8240e4c:	10ba5c04 	addi	r2,r2,-5776
 8240e50:	10800017 	ldw	r2,0(r2)
 8240e54:	e0bffc15 	stw	r2,-16(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 8240e58:	00000c06 	br	8240e8c <iproute+0x1a4>
#endif   /* MULTI_HOMED */
   {
      /* Check if this net has a gateway */
      if(ifp->n_defgw)
 8240e5c:	e0bffc17 	ldw	r2,-16(fp)
 8240e60:	10800d17 	ldw	r2,52(r2)
 8240e64:	10000626 	beq	r2,zero,8240e80 <iproute+0x198>
      {
         *hop1 = ifp->n_defgw;
 8240e68:	e0bffc17 	ldw	r2,-16(fp)
 8240e6c:	10c00d17 	ldw	r3,52(r2)
 8240e70:	e0bfff17 	ldw	r2,-4(fp)
 8240e74:	10c00015 	stw	r3,0(r2)
         return ifp;
 8240e78:	e0bffc17 	ldw	r2,-16(fp)
 8240e7c:	00000b06 	br	8240eac <iproute+0x1c4>
   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 8240e80:	e0bffc17 	ldw	r2,-16(fp)
 8240e84:	10800017 	ldw	r2,0(r2)
 8240e88:	e0bffc15 	stw	r2,-16(fp)
 8240e8c:	e0bffc17 	ldw	r2,-16(fp)
 8240e90:	103ff21e 	bne	r2,zero,8240e5c <iproute+0x174>
   /* if no gateway is set, then change the first hop address to the 
    * host we're trying to route to. this is just a kluge to make 
    * this work with arp routing. otherwise, we would try to return 
    * some sort of error indication. 
    */
   *hop1 = host;
 8240e94:	e0bfff17 	ldw	r2,-4(fp)
 8240e98:	e0fffe17 	ldw	r3,-8(fp)
 8240e9c:	10c00015 	stw	r3,0(r2)
   return((NET)(netlist.q_head));
 8240ea0:	008209b4 	movhi	r2,2086
 8240ea4:	10ba5c04 	addi	r2,r2,-5776
 8240ea8:	10800017 	ldw	r2,0(r2)
#endif   /* STRICT_SUBNETTING */
}
 8240eac:	e037883a 	mov	sp,fp
 8240eb0:	dfc00117 	ldw	ra,4(sp)
 8240eb4:	df000017 	ldw	fp,0(sp)
 8240eb8:	dec00204 	addi	sp,sp,8
 8240ebc:	f800283a 	ret

08240ec0 <ip_copypkt>:
 * RETURNS: a pointer to the new copy of the packet,
 *          or NULL if no packet buffer could be allocated
 */
PACKET
ip_copypkt(PACKET p)
{
 8240ec0:	defffb04 	addi	sp,sp,-20
 8240ec4:	dfc00415 	stw	ra,16(sp)
 8240ec8:	df000315 	stw	fp,12(sp)
 8240ecc:	df000304 	addi	fp,sp,12
 8240ed0:	e13fff15 	stw	r4,-4(fp)
   int len;

   /* figure out how much we need to copy from the packet, 
    * and allocate a new buffer to hold it 
    */
   len = p->nb_plen + (p->nb_prot - p->nb_buff);
 8240ed4:	e0bfff17 	ldw	r2,-4(fp)
 8240ed8:	10800417 	ldw	r2,16(r2)
 8240edc:	e0ffff17 	ldw	r3,-4(fp)
 8240ee0:	18c00317 	ldw	r3,12(r3)
 8240ee4:	1809883a 	mov	r4,r3
 8240ee8:	e0ffff17 	ldw	r3,-4(fp)
 8240eec:	18c00117 	ldw	r3,4(r3)
 8240ef0:	20c7c83a 	sub	r3,r4,r3
 8240ef4:	10c5883a 	add	r2,r2,r3
 8240ef8:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8240efc:	01000084 	movi	r4,2
 8240f00:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   np = pk_alloc(len);
 8240f04:	e0bffd17 	ldw	r2,-12(fp)
 8240f08:	1009883a 	mov	r4,r2
 8240f0c:	822c9ec0 	call	822c9ec <pk_alloc>
 8240f10:	e0bffe15 	stw	r2,-8(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8240f14:	01000084 	movi	r4,2
 8240f18:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   if (np == NULL)
 8240f1c:	e0bffe17 	ldw	r2,-8(fp)
 8240f20:	1000061e 	bne	r2,zero,8240f3c <ip_copypkt+0x7c>
   {
#ifdef NPDEBUG
      dprintf("ip_copypkt(): unable to obtain packet (len %d)\n", len);
 8240f24:	e17ffd17 	ldw	r5,-12(fp)
 8240f28:	01020974 	movhi	r4,2085
 8240f2c:	2104c804 	addi	r4,r4,4896
 8240f30:	82033a00 	call	82033a0 <printf>
#endif
      return NULL;
 8240f34:	0005883a 	mov	r2,zero
 8240f38:	00002906 	br	8240fe0 <ip_copypkt+0x120>
   }

   /* copy packet data into new buffer */
   MEMCPY(np->nb_buff, p->nb_buff, len);
 8240f3c:	e0bffe17 	ldw	r2,-8(fp)
 8240f40:	10c00117 	ldw	r3,4(r2)
 8240f44:	e0bfff17 	ldw	r2,-4(fp)
 8240f48:	10800117 	ldw	r2,4(r2)
 8240f4c:	e13ffd17 	ldw	r4,-12(fp)
 8240f50:	200d883a 	mov	r6,r4
 8240f54:	100b883a 	mov	r5,r2
 8240f58:	1809883a 	mov	r4,r3
 8240f5c:	8202f100 	call	8202f10 <memcpy>

   /* copy relevant packet fields */
   np->nb_prot = np->nb_buff + (p->nb_prot - p->nb_buff);
 8240f60:	e0bffe17 	ldw	r2,-8(fp)
 8240f64:	10800117 	ldw	r2,4(r2)
 8240f68:	e0ffff17 	ldw	r3,-4(fp)
 8240f6c:	18c00317 	ldw	r3,12(r3)
 8240f70:	1809883a 	mov	r4,r3
 8240f74:	e0ffff17 	ldw	r3,-4(fp)
 8240f78:	18c00117 	ldw	r3,4(r3)
 8240f7c:	20c7c83a 	sub	r3,r4,r3
 8240f80:	10c7883a 	add	r3,r2,r3
 8240f84:	e0bffe17 	ldw	r2,-8(fp)
 8240f88:	10c00315 	stw	r3,12(r2)
   np->nb_plen = p->nb_plen;
 8240f8c:	e0bfff17 	ldw	r2,-4(fp)
 8240f90:	10c00417 	ldw	r3,16(r2)
 8240f94:	e0bffe17 	ldw	r2,-8(fp)
 8240f98:	10c00415 	stw	r3,16(r2)
   np->net = p->net;
 8240f9c:	e0bfff17 	ldw	r2,-4(fp)
 8240fa0:	10c00617 	ldw	r3,24(r2)
 8240fa4:	e0bffe17 	ldw	r2,-8(fp)
 8240fa8:	10c00615 	stw	r3,24(r2)
   np->fhost = p->fhost;
 8240fac:	e0bfff17 	ldw	r2,-4(fp)
 8240fb0:	10c00717 	ldw	r3,28(r2)
 8240fb4:	e0bffe17 	ldw	r2,-8(fp)
 8240fb8:	10c00715 	stw	r3,28(r2)
   np->type = p->type;
 8240fbc:	e0bfff17 	ldw	r2,-4(fp)
 8240fc0:	10c0080b 	ldhu	r3,32(r2)
 8240fc4:	e0bffe17 	ldw	r2,-8(fp)
 8240fc8:	10c0080d 	sth	r3,32(r2)
   np->nb_tstamp = p->nb_tstamp;
 8240fcc:	e0bfff17 	ldw	r2,-4(fp)
 8240fd0:	10c00517 	ldw	r3,20(r2)
 8240fd4:	e0bffe17 	ldw	r2,-8(fp)
 8240fd8:	10c00515 	stw	r3,20(r2)

   /* return pointer to the copy */
   return np;
 8240fdc:	e0bffe17 	ldw	r2,-8(fp)
}
 8240fe0:	e037883a 	mov	sp,fp
 8240fe4:	dfc00117 	ldw	ra,4(sp)
 8240fe8:	df000017 	ldw	fp,0(sp)
 8240fec:	dec00204 	addi	sp,sp,8
 8240ff0:	f800283a 	ret

08240ff4 <ip_reasm_match_frag_with_ire>:
packet being processed.  If no such entry is found, this function returns 
NULL.
*/

IREP ip_reasm_match_frag_with_ire (struct ip * pip)
{
 8240ff4:	defffa04 	addi	sp,sp,-24
 8240ff8:	df000515 	stw	fp,20(sp)
 8240ffc:	df000504 	addi	fp,sp,20
 8241000:	e13fff15 	stw	r4,-4(fp)
   ip_addr dest;
   u_char prot;
   u_short id;
   IREP tmpp;
 
   src = pip->ip_src;
 8241004:	e0bfff17 	ldw	r2,-4(fp)
 8241008:	10800317 	ldw	r2,12(r2)
 824100c:	e0bffc15 	stw	r2,-16(fp)
   dest = pip->ip_dest;
 8241010:	e0bfff17 	ldw	r2,-4(fp)
 8241014:	10800417 	ldw	r2,16(r2)
 8241018:	e0bffd15 	stw	r2,-12(fp)
   prot = pip->ip_prot;
 824101c:	e0bfff17 	ldw	r2,-4(fp)
 8241020:	10800243 	ldbu	r2,9(r2)
 8241024:	e0bffe05 	stb	r2,-8(fp)
   id = pip->ip_id;
 8241028:	e0bfff17 	ldw	r2,-4(fp)
 824102c:	1080010b 	ldhu	r2,4(r2)
 8241030:	e0bffe8d 	sth	r2,-6(fp)

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8241034:	d0a0c817 	ldw	r2,-31968(gp)
 8241038:	e0bffb15 	stw	r2,-20(fp)
 824103c:	00001706 	br	824109c <ip_reasm_match_frag_with_ire+0xa8>
      {
      if ((tmpp->src == src) && (tmpp->dest == dest) && 
 8241040:	e0bffb17 	ldw	r2,-20(fp)
 8241044:	10c00117 	ldw	r3,4(r2)
 8241048:	e0bffc17 	ldw	r2,-16(fp)
 824104c:	1880101e 	bne	r3,r2,8241090 <ip_reasm_match_frag_with_ire+0x9c>
 8241050:	e0bffb17 	ldw	r2,-20(fp)
 8241054:	10c00217 	ldw	r3,8(r2)
 8241058:	e0bffd17 	ldw	r2,-12(fp)
 824105c:	18800c1e 	bne	r3,r2,8241090 <ip_reasm_match_frag_with_ire+0x9c>
          (tmpp->prot == prot) && (tmpp->id == id))
 8241060:	e0bffb17 	ldw	r2,-20(fp)
 8241064:	10800383 	ldbu	r2,14(r2)

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
      {
      if ((tmpp->src == src) && (tmpp->dest == dest) && 
 8241068:	10c03fcc 	andi	r3,r2,255
 824106c:	e0bffe03 	ldbu	r2,-8(fp)
 8241070:	1880071e 	bne	r3,r2,8241090 <ip_reasm_match_frag_with_ire+0x9c>
          (tmpp->prot == prot) && (tmpp->id == id))
 8241074:	e0bffb17 	ldw	r2,-20(fp)
 8241078:	1080030b 	ldhu	r2,12(r2)
 824107c:	10ffffcc 	andi	r3,r2,65535
 8241080:	e0bffe8b 	ldhu	r2,-6(fp)
 8241084:	1880021e 	bne	r3,r2,8241090 <ip_reasm_match_frag_with_ire+0x9c>
         {
         return tmpp; /* we've found a match */
 8241088:	e0bffb17 	ldw	r2,-20(fp)
 824108c:	00000606 	br	82410a8 <ip_reasm_match_frag_with_ire+0xb4>
   prot = pip->ip_prot;
   id = pip->ip_id;

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8241090:	e0bffb17 	ldw	r2,-20(fp)
 8241094:	10800017 	ldw	r2,0(r2)
 8241098:	e0bffb15 	stw	r2,-20(fp)
 824109c:	e0bffb17 	ldw	r2,-20(fp)
 82410a0:	103fe71e 	bne	r2,zero,8241040 <ip_reasm_match_frag_with_ire+0x4c>
         return tmpp; /* we've found a match */
         }
      }

   /* no match found */
   return NULL;
 82410a4:	0005883a 	mov	r2,zero
}
 82410a8:	e037883a 	mov	sp,fp
 82410ac:	df000017 	ldw	fp,0(sp)
 82410b0:	dec00104 	addi	sp,sp,4
 82410b4:	f800283a 	ret

082410b8 <ip_reasm_determine_type_of_frag>:
OUTPUT: One of the various IP_FRAGTYPE values (IP_CP, IP_FF, IP_MF, 
or IP_LF)
*/

IP_FRAGTYPE ip_reasm_determine_type_of_frag (struct ip * pip)
{
 82410b8:	defffc04 	addi	sp,sp,-16
 82410bc:	df000315 	stw	fp,12(sp)
 82410c0:	df000304 	addi	fp,sp,12
 82410c4:	e13fff15 	stw	r4,-4(fp)
  u_short mf;
  u_short foff;
  IP_FRAGTYPE rc;

  mf = (((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF) >> 13);
 82410c8:	e0bfff17 	ldw	r2,-4(fp)
 82410cc:	1080018b 	ldhu	r2,6(r2)
 82410d0:	10bfffcc 	andi	r2,r2,65535
 82410d4:	1004d23a 	srli	r2,r2,8
 82410d8:	10bfffcc 	andi	r2,r2,65535
 82410dc:	10c03fcc 	andi	r3,r2,255
 82410e0:	e0bfff17 	ldw	r2,-4(fp)
 82410e4:	1080018b 	ldhu	r2,6(r2)
 82410e8:	10bfffcc 	andi	r2,r2,65535
 82410ec:	1004923a 	slli	r2,r2,8
 82410f0:	10bfffcc 	andi	r2,r2,65535
 82410f4:	1884b03a 	or	r2,r3,r2
 82410f8:	1088000c 	andi	r2,r2,8192
 82410fc:	1005d37a 	srai	r2,r2,13
 8241100:	e0bffe0d 	sth	r2,-8(fp)
  foff = ((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF);
 8241104:	e0bfff17 	ldw	r2,-4(fp)
 8241108:	1080018b 	ldhu	r2,6(r2)
 824110c:	10bfffcc 	andi	r2,r2,65535
 8241110:	1004d23a 	srli	r2,r2,8
 8241114:	1007883a 	mov	r3,r2
 8241118:	e0bfff17 	ldw	r2,-4(fp)
 824111c:	1080018b 	ldhu	r2,6(r2)
 8241120:	10bfffcc 	andi	r2,r2,65535
 8241124:	1004923a 	slli	r2,r2,8
 8241128:	1884b03a 	or	r2,r3,r2
 824112c:	1087ffcc 	andi	r2,r2,8191
 8241130:	e0bffe8d 	sth	r2,-6(fp)

  if (mf == 0)
 8241134:	e0bffe0b 	ldhu	r2,-8(fp)
 8241138:	1000071e 	bne	r2,zero,8241158 <ip_reasm_determine_type_of_frag+0xa0>
     {
     if (foff == 0) {rc = IP_CP;}
 824113c:	e0bffe8b 	ldhu	r2,-6(fp)
 8241140:	1000021e 	bne	r2,zero,824114c <ip_reasm_determine_type_of_frag+0x94>
 8241144:	e03ffd15 	stw	zero,-12(fp)
 8241148:	00000a06 	br	8241174 <ip_reasm_determine_type_of_frag+0xbc>
     else {rc = IP_LF;}
 824114c:	00800144 	movi	r2,5
 8241150:	e0bffd15 	stw	r2,-12(fp)
 8241154:	00000706 	br	8241174 <ip_reasm_determine_type_of_frag+0xbc>
     }
  else
     {
     if (foff == 0) {rc = IP_FF;}
 8241158:	e0bffe8b 	ldhu	r2,-6(fp)
 824115c:	1000031e 	bne	r2,zero,824116c <ip_reasm_determine_type_of_frag+0xb4>
 8241160:	00800044 	movi	r2,1
 8241164:	e0bffd15 	stw	r2,-12(fp)
 8241168:	00000206 	br	8241174 <ip_reasm_determine_type_of_frag+0xbc>
     else {rc = IP_MF;}
 824116c:	008000c4 	movi	r2,3
 8241170:	e0bffd15 	stw	r2,-12(fp)
     }

  return rc;
 8241174:	e0bffd17 	ldw	r2,-12(fp)
}
 8241178:	e037883a 	mov	sp,fp
 824117c:	df000017 	ldw	fp,0(sp)
 8241180:	dec00104 	addi	sp,sp,4
 8241184:	f800283a 	ret

08241188 <ip_reasm_check_mem_useage>:
OUTPUT: ENP_RESOURCE, if the increment request can't be allowed; 
otherwise it returns IPREASM_OK.
*/

int ip_reasm_check_mem_useage (u_short increment)
{
 8241188:	defffe04 	addi	sp,sp,-8
 824118c:	df000115 	stw	fp,4(sp)
 8241190:	df000104 	addi	fp,sp,4
 8241194:	2005883a 	mov	r2,r4
 8241198:	e0bfff0d 	sth	r2,-4(fp)
   /* sanity check */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 824119c:	d0a0c717 	ldw	r2,-31972(gp)
 82411a0:	00c001b4 	movhi	r3,6
 82411a4:	1880072e 	bgeu	r3,r2,82411c4 <ip_reasm_check_mem_useage+0x3c>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 82411a8:	008209b4 	movhi	r2,2086
 82411ac:	10ba7504 	addi	r2,r2,-5676
 82411b0:	10800217 	ldw	r2,8(r2)
 82411b4:	10c00044 	addi	r3,r2,1
 82411b8:	008209b4 	movhi	r2,2086
 82411bc:	10ba7504 	addi	r2,r2,-5676
 82411c0:	10c00215 	stw	r3,8(r2)
   }

   /* check to see if we are already at limit OR if we may become over limit 
    * after accepting this new fragment */
   if ((ipr_curr_mem == IP_REASM_MAX_MEM) ||
 82411c4:	d0e0c717 	ldw	r3,-31972(gp)
 82411c8:	008001b4 	movhi	r2,6
 82411cc:	18800526 	beq	r3,r2,82411e4 <ip_reasm_check_mem_useage+0x5c>
       (ipr_curr_mem + increment > IP_REASM_MAX_MEM))
 82411d0:	e0ffff0b 	ldhu	r3,-4(fp)
 82411d4:	d0a0c717 	ldw	r2,-31972(gp)
 82411d8:	1885883a 	add	r2,r3,r2
      ++ire_stats.bad_max_mem;
   }

   /* check to see if we are already at limit OR if we may become over limit 
    * after accepting this new fragment */
   if ((ipr_curr_mem == IP_REASM_MAX_MEM) ||
 82411dc:	00c001b4 	movhi	r3,6
 82411e0:	1880092e 	bgeu	r3,r2,8241208 <ip_reasm_check_mem_useage+0x80>
       (ipr_curr_mem + increment > IP_REASM_MAX_MEM))
   {
      /* return an error indication */
      ++ire_stats.mem_check_fail;
 82411e4:	008209b4 	movhi	r2,2086
 82411e8:	10ba7504 	addi	r2,r2,-5676
 82411ec:	10800317 	ldw	r2,12(r2)
 82411f0:	10c00044 	addi	r3,r2,1
 82411f4:	008209b4 	movhi	r2,2086
 82411f8:	10ba7504 	addi	r2,r2,-5676
 82411fc:	10c00315 	stw	r3,12(r2)
      return ENP_RESOURCE;
 8241200:	00bffa84 	movi	r2,-22
 8241204:	00000106 	br	824120c <ip_reasm_check_mem_useage+0x84>
   }

   /* memory limits will not be exceeded with this increment */
   return IPREASM_OK;
 8241208:	0005883a 	mov	r2,zero
}
 824120c:	e037883a 	mov	sp,fp
 8241210:	df000017 	ldw	fp,0(sp)
 8241214:	dec00104 	addi	sp,sp,4
 8241218:	f800283a 	ret

0824121c <ip_reasm_incr_mem_useage>:
system exceeding the maximum limit or if the system has already exceeded 
the prespecified limit for memory useage; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_incr_mem_useage (u_short increment)
{
 824121c:	defffe04 	addi	sp,sp,-8
 8241220:	df000115 	stw	fp,4(sp)
 8241224:	df000104 	addi	fp,sp,4
 8241228:	2005883a 	mov	r2,r4
 824122c:	e0bfff0d 	sth	r2,-4(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 8241230:	d0a0c717 	ldw	r2,-31972(gp)
 8241234:	00c001b4 	movhi	r3,6
 8241238:	1880092e 	bgeu	r3,r2,8241260 <ip_reasm_incr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 824123c:	008209b4 	movhi	r2,2086
 8241240:	10ba7504 	addi	r2,r2,-5676
 8241244:	10800217 	ldw	r2,8(r2)
 8241248:	10c00044 	addi	r3,r2,1
 824124c:	008209b4 	movhi	r2,2086
 8241250:	10ba7504 	addi	r2,r2,-5676
 8241254:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 8241258:	00bffa84 	movi	r2,-22
 824125c:	00001306 	br	82412ac <ip_reasm_incr_mem_useage+0x90>
   }
   if (ipr_curr_mem + increment > IP_REASM_MAX_MEM)
 8241260:	e0ffff0b 	ldhu	r3,-4(fp)
 8241264:	d0a0c717 	ldw	r2,-31972(gp)
 8241268:	1885883a 	add	r2,r3,r2
 824126c:	00c001b4 	movhi	r3,6
 8241270:	1880092e 	bgeu	r3,r2,8241298 <ip_reasm_incr_mem_useage+0x7c>
   {
      /* this should never happen since caller should have 
       * checked prior to asking for the increment */
      ++ire_stats.mem_incr_fail;
 8241274:	008209b4 	movhi	r2,2086
 8241278:	10ba7504 	addi	r2,r2,-5676
 824127c:	10800417 	ldw	r2,16(r2)
 8241280:	10c00044 	addi	r3,r2,1
 8241284:	008209b4 	movhi	r2,2086
 8241288:	10ba7504 	addi	r2,r2,-5676
 824128c:	10c00415 	stw	r3,16(r2)
      return ENP_RESOURCE;
 8241290:	00bffa84 	movi	r2,-22
 8241294:	00000506 	br	82412ac <ip_reasm_incr_mem_useage+0x90>
   }

   ipr_curr_mem += increment;
 8241298:	e0ffff0b 	ldhu	r3,-4(fp)
 824129c:	d0a0c717 	ldw	r2,-31972(gp)
 82412a0:	1885883a 	add	r2,r3,r2
 82412a4:	d0a0c715 	stw	r2,-31972(gp)

   /* successfully incremented memory useage counter */
   return IPREASM_OK;
 82412a8:	0005883a 	mov	r2,zero
}
 82412ac:	e037883a 	mov	sp,fp
 82412b0:	df000017 	ldw	fp,0(sp)
 82412b4:	dec00104 	addi	sp,sp,4
 82412b8:	f800283a 	ret

082412bc <ip_reasm_decr_mem_useage>:
exceeded the prespecified limit for memory useage; otherwise, it returns 
IPREASM_OK.
*/

int ip_reasm_decr_mem_useage (u_short decrement)
{
 82412bc:	defffe04 	addi	sp,sp,-8
 82412c0:	df000115 	stw	fp,4(sp)
 82412c4:	df000104 	addi	fp,sp,4
 82412c8:	2005883a 	mov	r2,r4
 82412cc:	e0bfff0d 	sth	r2,-4(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 82412d0:	d0a0c717 	ldw	r2,-31972(gp)
 82412d4:	00c001b4 	movhi	r3,6
 82412d8:	1880092e 	bgeu	r3,r2,8241300 <ip_reasm_decr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 82412dc:	008209b4 	movhi	r2,2086
 82412e0:	10ba7504 	addi	r2,r2,-5676
 82412e4:	10800217 	ldw	r2,8(r2)
 82412e8:	10c00044 	addi	r3,r2,1
 82412ec:	008209b4 	movhi	r2,2086
 82412f0:	10ba7504 	addi	r2,r2,-5676
 82412f4:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 82412f8:	00bffa84 	movi	r2,-22
 82412fc:	00001106 	br	8241344 <ip_reasm_decr_mem_useage+0x88>
   }
   if (ipr_curr_mem < decrement)
 8241300:	e0bfff0b 	ldhu	r2,-4(fp)
 8241304:	d0e0c717 	ldw	r3,-31972(gp)
 8241308:	1880092e 	bgeu	r3,r2,8241330 <ip_reasm_decr_mem_useage+0x74>
   {
      /* this should never happen since the current memory useage
       * counter must always be greater than or at least equal to
       * the allocation that is being "returned" */
      ++ire_stats.mem_decr_fail;
 824130c:	008209b4 	movhi	r2,2086
 8241310:	10ba7504 	addi	r2,r2,-5676
 8241314:	10800517 	ldw	r2,20(r2)
 8241318:	10c00044 	addi	r3,r2,1
 824131c:	008209b4 	movhi	r2,2086
 8241320:	10ba7504 	addi	r2,r2,-5676
 8241324:	10c00515 	stw	r3,20(r2)
      return ENP_RESOURCE;
 8241328:	00bffa84 	movi	r2,-22
 824132c:	00000506 	br	8241344 <ip_reasm_decr_mem_useage+0x88>
   }

   ipr_curr_mem -= decrement;
 8241330:	d0e0c717 	ldw	r3,-31972(gp)
 8241334:	e0bfff0b 	ldhu	r2,-4(fp)
 8241338:	1885c83a 	sub	r2,r3,r2
 824133c:	d0a0c715 	stw	r2,-31972(gp)

   /* successfully decremented memory useage counter */
   return IPREASM_OK;
 8241340:	0005883a 	mov	r2,zero
}
 8241344:	e037883a 	mov	sp,fp
 8241348:	df000017 	ldw	fp,0(sp)
 824134c:	dec00104 	addi	sp,sp,4
 8241350:	f800283a 	ret

08241354 <ip_reasm_process_first_fragment>:
OUTPUT: ENP_RESOURCE if the memory check (in ip_reasm_check_mem_useage ()) 
or the allocation for an IRE fails; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_process_first_fragment (PACKET p)
{
 8241354:	defff704 	addi	sp,sp,-36
 8241358:	dfc00815 	stw	ra,32(sp)
 824135c:	df000715 	stw	fp,28(sp)
 8241360:	df000704 	addi	fp,sp,28
 8241364:	e13fff15 	stw	r4,-4(fp)
   u_short total_len;
   int rc;

   /* this is a fragment from a hitherto unknown fragment stream; 
    * check for resource limits before accepting it */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (IRE)))) != IPREASM_OK)
 8241368:	e0bfff17 	ldw	r2,-4(fp)
 824136c:	10800217 	ldw	r2,8(r2)
 8241370:	10802204 	addi	r2,r2,136
 8241374:	10bfffcc 	andi	r2,r2,65535
 8241378:	1009883a 	mov	r4,r2
 824137c:	82411880 	call	8241188 <ip_reasm_check_mem_useage>
 8241380:	e0bff915 	stw	r2,-28(fp)
 8241384:	e0bff917 	ldw	r2,-28(fp)
 8241388:	10000f26 	beq	r2,zero,82413c8 <ip_reasm_process_first_fragment+0x74>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 824138c:	01000084 	movi	r4,2
 8241390:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free (p);
 8241394:	e13fff17 	ldw	r4,-4(fp)
 8241398:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 824139c:	01000084 	movi	r4,2
 82413a0:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 82413a4:	008209b4 	movhi	r2,2086
 82413a8:	10ba6104 	addi	r2,r2,-5756
 82413ac:	10800f17 	ldw	r2,60(r2)
 82413b0:	10c00044 	addi	r3,r2,1
 82413b4:	008209b4 	movhi	r2,2086
 82413b8:	10ba6104 	addi	r2,r2,-5756
 82413bc:	10c00f15 	stw	r3,60(r2)
      return rc;
 82413c0:	e0bff917 	ldw	r2,-28(fp)
 82413c4:	00008c06 	br	82415f8 <ip_reasm_process_first_fragment+0x2a4>
   }

   /* we are ok wrt memory limits; since this is the first fragment, we need 
    * to create an IRE entry */
   irep = (IREP) IPR_ALLOC(sizeof(IRE));
 82413c8:	01002204 	movi	r4,136
 82413cc:	822e16c0 	call	822e16c <npalloc>
 82413d0:	e0bffa15 	stw	r2,-24(fp)
   if (irep == 0) 
 82413d4:	e0bffa17 	ldw	r2,-24(fp)
 82413d8:	10000f1e 	bne	r2,zero,8241418 <ip_reasm_process_first_fragment+0xc4>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 82413dc:	01000084 	movi	r4,2
 82413e0:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free (p);
 82413e4:	e13fff17 	ldw	r4,-4(fp)
 82413e8:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 82413ec:	01000084 	movi	r4,2
 82413f0:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 82413f4:	008209b4 	movhi	r2,2086
 82413f8:	10ba6104 	addi	r2,r2,-5756
 82413fc:	10800f17 	ldw	r2,60(r2)
 8241400:	10c00044 	addi	r3,r2,1
 8241404:	008209b4 	movhi	r2,2086
 8241408:	10ba6104 	addi	r2,r2,-5756
 824140c:	10c00f15 	stw	r3,60(r2)
      return ENP_RESOURCE;
 8241410:	00bffa84 	movi	r2,-22
 8241414:	00007806 	br	82415f8 <ip_reasm_process_first_fragment+0x2a4>
   }

   pip = ip_head(p);
 8241418:	e0bfff17 	ldw	r2,-4(fp)
 824141c:	10800317 	ldw	r2,12(r2)
 8241420:	e0bffb15 	stw	r2,-20(fp)
   iphlen = ip_hlen(pip);
 8241424:	e0bffb17 	ldw	r2,-20(fp)
 8241428:	10800003 	ldbu	r2,0(r2)
 824142c:	108003cc 	andi	r2,r2,15
 8241430:	1085883a 	add	r2,r2,r2
 8241434:	1085883a 	add	r2,r2,r2
 8241438:	e0bffc05 	stb	r2,-16(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 824143c:	e13ffb17 	ldw	r4,-20(fp)
 8241440:	82410b80 	call	82410b8 <ip_reasm_determine_type_of_frag>
 8241444:	e0bffd15 	stw	r2,-12(fp)
   frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 8241448:	e0bffb17 	ldw	r2,-20(fp)
 824144c:	1080018b 	ldhu	r2,6(r2)
 8241450:	10bfffcc 	andi	r2,r2,65535
 8241454:	1004d23a 	srli	r2,r2,8
 8241458:	10bfffcc 	andi	r2,r2,65535
 824145c:	10c03fcc 	andi	r3,r2,255
 8241460:	e0bffb17 	ldw	r2,-20(fp)
 8241464:	1080018b 	ldhu	r2,6(r2)
 8241468:	10bfffcc 	andi	r2,r2,65535
 824146c:	1004923a 	slli	r2,r2,8
 8241470:	10bfffcc 	andi	r2,r2,65535
 8241474:	1884b03a 	or	r2,r3,r2
 8241478:	100490fa 	slli	r2,r2,3
 824147c:	e0bffe0d 	sth	r2,-8(fp)
   total_len = ntohs(pip->ip_len);
 8241480:	e0bffb17 	ldw	r2,-20(fp)
 8241484:	1080008b 	ldhu	r2,2(r2)
 8241488:	10bfffcc 	andi	r2,r2,65535
 824148c:	1004d23a 	srli	r2,r2,8
 8241490:	1007883a 	mov	r3,r2
 8241494:	e0bffb17 	ldw	r2,-20(fp)
 8241498:	1080008b 	ldhu	r2,2(r2)
 824149c:	10bfffcc 	andi	r2,r2,65535
 82414a0:	1004923a 	slli	r2,r2,8
 82414a4:	1884b03a 	or	r2,r3,r2
 82414a8:	e0bffe8d 	sth	r2,-6(fp)

   /* now setup various fields in the IRE entry (multi-byte fields stored in network 
    * byte order) */
   irep->src = pip->ip_src;
 82414ac:	e0bffb17 	ldw	r2,-20(fp)
 82414b0:	10c00317 	ldw	r3,12(r2)
 82414b4:	e0bffa17 	ldw	r2,-24(fp)
 82414b8:	10c00115 	stw	r3,4(r2)
   irep->dest = pip->ip_dest;
 82414bc:	e0bffb17 	ldw	r2,-20(fp)
 82414c0:	10c00417 	ldw	r3,16(r2)
 82414c4:	e0bffa17 	ldw	r2,-24(fp)
 82414c8:	10c00215 	stw	r3,8(r2)
   irep->prot = pip->ip_prot;
 82414cc:	e0bffb17 	ldw	r2,-20(fp)
 82414d0:	10c00243 	ldbu	r3,9(r2)
 82414d4:	e0bffa17 	ldw	r2,-24(fp)
 82414d8:	10c00385 	stb	r3,14(r2)
   irep->id = pip->ip_id;
 82414dc:	e0bffb17 	ldw	r2,-20(fp)
 82414e0:	10c0010b 	ldhu	r3,4(r2)
 82414e4:	e0bffa17 	ldw	r2,-24(fp)
 82414e8:	10c0030d 	sth	r3,12(r2)
   if (ftype == IP_LF)
 82414ec:	e0bffd17 	ldw	r2,-12(fp)
 82414f0:	10800158 	cmpnei	r2,r2,5
 82414f4:	10000a1e 	bne	r2,zero,8241520 <ip_reasm_process_first_fragment+0x1cc>
      {
      irep->length = frag_offset + (total_len - iphlen);
 82414f8:	e0bffc03 	ldbu	r2,-16(fp)
 82414fc:	e0fffe8b 	ldhu	r3,-6(fp)
 8241500:	1885c83a 	sub	r2,r3,r2
 8241504:	1007883a 	mov	r3,r2
 8241508:	e0bffe0b 	ldhu	r2,-8(fp)
 824150c:	1885883a 	add	r2,r3,r2
 8241510:	1007883a 	mov	r3,r2
 8241514:	e0bffa17 	ldw	r2,-24(fp)
 8241518:	10c0040d 	sth	r3,16(r2)
 824151c:	00000a06 	br	8241548 <ip_reasm_process_first_fragment+0x1f4>
      }
   else if (ftype == IP_FF)
 8241520:	e0bffd17 	ldw	r2,-12(fp)
 8241524:	10800058 	cmpnei	r2,r2,1
 8241528:	1000071e 	bne	r2,zero,8241548 <ip_reasm_process_first_fragment+0x1f4>
       * out, and results in the transmission of an ICMP Time Exceeded message (with the
       * code set to "fragment reassembly time exceeded").  Please note that the 'l2_hdr' 
       * as set below may not be the start address for the L2 header (but it is adequate 
       * for our use).  If the FF is never received, these fields stay at their initial
       * value of 0. */
      irep->l2_hdr = p->nb_buff;
 824152c:	e0bfff17 	ldw	r2,-4(fp)
 8241530:	10c00117 	ldw	r3,4(r2)
 8241534:	e0bffa17 	ldw	r2,-24(fp)
 8241538:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 824153c:	e0bffa17 	ldw	r2,-24(fp)
 8241540:	e0fffb17 	ldw	r3,-20(fp)
 8241544:	10c02015 	stw	r3,128(r2)
      }

   /* note that the 'rcvd' and 'length' counters only keep track of the data part of 
    * the IP datagram */
   irep->rcvd = total_len - iphlen;
 8241548:	e0bffc03 	ldbu	r2,-16(fp)
 824154c:	e0fffe8b 	ldhu	r3,-6(fp)
 8241550:	1885c83a 	sub	r2,r3,r2
 8241554:	1007883a 	mov	r3,r2
 8241558:	e0bffa17 	ldw	r2,-24(fp)
 824155c:	10c0048d 	sth	r3,18(r2)
   irep->age = 0;
 8241560:	e0bffa17 	ldw	r2,-24(fp)
 8241564:	10000515 	stw	zero,20(r2)

   /* all RFQs are compact when created */
   irep->flags |= IPR_RFQ_COMPACT;
 8241568:	e0bffa17 	ldw	r2,-24(fp)
 824156c:	10802103 	ldbu	r2,132(r2)
 8241570:	10800054 	ori	r2,r2,1
 8241574:	1007883a 	mov	r3,r2
 8241578:	e0bffa17 	ldw	r2,-24(fp)
 824157c:	10c02105 	stb	r3,132(r2)

   /* store PACKET pointer in the first location of the first RFQ */
   irep->rfq.bufp[0] = p;
 8241580:	e0bffa17 	ldw	r2,-24(fp)
 8241584:	e0ffff17 	ldw	r3,-4(fp)
 8241588:	10c00715 	stw	r3,28(r2)
   irep->rfq.frag_offset[0] = frag_offset;
 824158c:	e0bffa17 	ldw	r2,-24(fp)
 8241590:	e0fffe0b 	ldhu	r3,-8(fp)
 8241594:	10c0170d 	sth	r3,92(r2)
   /* the next pointer in the RFQ is already 0 */

   p->nb_prot += iphlen;
 8241598:	e0bfff17 	ldw	r2,-4(fp)
 824159c:	10c00317 	ldw	r3,12(r2)
 82415a0:	e0bffc03 	ldbu	r2,-16(fp)
 82415a4:	1887883a 	add	r3,r3,r2
 82415a8:	e0bfff17 	ldw	r2,-4(fp)
 82415ac:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 82415b0:	e0bfff17 	ldw	r2,-4(fp)
 82415b4:	10c00417 	ldw	r3,16(r2)
 82415b8:	e0bffc03 	ldbu	r2,-16(fp)
 82415bc:	1887c83a 	sub	r3,r3,r2
 82415c0:	e0bfff17 	ldw	r2,-4(fp)
 82415c4:	10c00415 	stw	r3,16(r2)

   /* insert at start of global IRE list */
   irep->next = h_ireq;
 82415c8:	d0e0c817 	ldw	r3,-31968(gp)
 82415cc:	e0bffa17 	ldw	r2,-24(fp)
 82415d0:	10c00015 	stw	r3,0(r2)
   h_ireq = irep;
 82415d4:	e0bffa17 	ldw	r2,-24(fp)
 82415d8:	d0a0c815 	stw	r2,-31968(gp)

   /* increment the memory useage */
   ip_reasm_incr_mem_useage (p->nb_blen + (sizeof (IRE)));
 82415dc:	e0bfff17 	ldw	r2,-4(fp)
 82415e0:	10800217 	ldw	r2,8(r2)
 82415e4:	10802204 	addi	r2,r2,136
 82415e8:	10bfffcc 	andi	r2,r2,65535
 82415ec:	1009883a 	mov	r4,r2
 82415f0:	824121c0 	call	824121c <ip_reasm_incr_mem_useage>

   return IPREASM_OK;
 82415f4:	0005883a 	mov	r2,zero
}
 82415f8:	e037883a 	mov	sp,fp
 82415fc:	dfc00117 	ldw	ra,4(sp)
 8241600:	df000017 	ldw	fp,0(sp)
 8241604:	dec00204 	addi	sp,sp,8
 8241608:	f800283a 	ret

0824160c <ip_reassm>:
merely passes their return code back to its caller.  Otherwise, it returns
IPREASM_OK indicating that the fragment was successfully processed.
*/

int ip_reassm (PACKET p)
{
 824160c:	defff904 	addi	sp,sp,-28
 8241610:	dfc00615 	stw	ra,24(sp)
 8241614:	df000515 	stw	fp,20(sp)
 8241618:	df000504 	addi	fp,sp,20
 824161c:	e13fff15 	stw	r4,-4(fp)
   IREP irep;
   struct ip * pip;
   int rc1, rc2;

   pip = ip_head(p);
 8241620:	e0bfff17 	ldw	r2,-4(fp)
 8241624:	10800317 	ldw	r2,12(r2)
 8241628:	e0bffb15 	stw	r2,-20(fp)

   /* we have just received a fragment, so let's start processing it.  First
    * check for a matching IRE entry. */
   irep = ip_reasm_match_frag_with_ire (pip);
 824162c:	e13ffb17 	ldw	r4,-20(fp)
 8241630:	8240ff40 	call	8240ff4 <ip_reasm_match_frag_with_ire>
 8241634:	e0bffc15 	stw	r2,-16(fp)

   if (!irep)
 8241638:	e0bffc17 	ldw	r2,-16(fp)
 824163c:	1000071e 	bne	r2,zero,824165c <ip_reassm+0x50>
   {
      /* this is the first packet for a "new" fragment stream */
      if ((rc1 = ip_reasm_process_first_fragment (p)) != IPREASM_OK)
 8241640:	e13fff17 	ldw	r4,-4(fp)
 8241644:	82413540 	call	8241354 <ip_reasm_process_first_fragment>
 8241648:	e0bffd15 	stw	r2,-12(fp)
 824164c:	e0bffd17 	ldw	r2,-12(fp)
 8241650:	10000a26 	beq	r2,zero,824167c <ip_reassm+0x70>
      {
         /* ip_reasm_process_first_fragment () will free the packet */
         return rc1;
 8241654:	e0bffd17 	ldw	r2,-12(fp)
 8241658:	00000906 	br	8241680 <ip_reassm+0x74>
      }
   }
   else
   {
      /* a matching IRE already exists for this fragment */
      if ((rc2 = ip_reasm_process_subsequent_fragments (p, irep)) != IPREASM_OK)
 824165c:	e17ffc17 	ldw	r5,-16(fp)
 8241660:	e13fff17 	ldw	r4,-4(fp)
 8241664:	8241bf80 	call	8241bf8 <ip_reasm_process_subsequent_fragments>
 8241668:	e0bffe15 	stw	r2,-8(fp)
 824166c:	e0bffe17 	ldw	r2,-8(fp)
 8241670:	10000226 	beq	r2,zero,824167c <ip_reassm+0x70>
      {
         /* ip_reasm_process_subsequent_fragments () has already deleted the IRE entry */
         return rc2;
 8241674:	e0bffe17 	ldw	r2,-8(fp)
 8241678:	00000106 	br	8241680 <ip_reassm+0x74>
      }
   }

   return IPREASM_OK;
 824167c:	0005883a 	mov	r2,zero
}
 8241680:	e037883a 	mov	sp,fp
 8241684:	dfc00117 	ldw	ra,4(sp)
 8241688:	df000017 	ldw	fp,0(sp)
 824168c:	dec00204 	addi	sp,sp,8
 8241690:	f800283a 	ret

08241694 <ip_reasm_compute_overlap>:
            (i.e., contains "unique" data).
*/

IPREASM_RC ip_reasm_compute_overlap (PACKET p, IREP irep, u_short * indexp, 
 RFQP * last_rfqpp, u_short * frag_offsetp, u_char * hole_createdp)
{
 8241694:	defff204 	addi	sp,sp,-56
 8241698:	dfc00d15 	stw	ra,52(sp)
 824169c:	df000c15 	stw	fp,48(sp)
 82416a0:	df000c04 	addi	fp,sp,48
 82416a4:	e13ffc15 	stw	r4,-16(fp)
 82416a8:	e17ffd15 	stw	r5,-12(fp)
 82416ac:	e1bffe15 	stw	r6,-8(fp)
 82416b0:	e1ffff15 	stw	r7,-4(fp)
   u_short currend;
   u_short drop_len;
   u_char iphlen;
   u_short i;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 82416b4:	e13ffd17 	ldw	r4,-12(fp)
 82416b8:	82421280 	call	8242128 <ip_reasm_find_ire>
 82416bc:	10803fcc 	andi	r2,r2,255
 82416c0:	10800060 	cmpeqi	r2,r2,1
 82416c4:	10000f1e 	bne	r2,zero,8241704 <ip_reasm_compute_overlap+0x70>
      {
      ++ire_stats.bad_irep;
 82416c8:	008209b4 	movhi	r2,2086
 82416cc:	10ba7504 	addi	r2,r2,-5676
 82416d0:	10800017 	ldw	r2,0(r2)
 82416d4:	10c00044 	addi	r3,r2,1
 82416d8:	008209b4 	movhi	r2,2086
 82416dc:	10ba7504 	addi	r2,r2,-5676
 82416e0:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 82416e4:	01000084 	movi	r4,2
 82416e8:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free (p);
 82416ec:	e13ffc17 	ldw	r4,-16(fp)
 82416f0:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 82416f4:	01000084 	movi	r4,2
 82416f8:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return IPREASM_DROP_FRAG_BAD_PARAM;
 82416fc:	00800044 	movi	r2,1
 8241700:	00013806 	br	8241be4 <ip_reasm_compute_overlap+0x550>
      }

   jrip = ip_head(p);
 8241704:	e0bffc17 	ldw	r2,-16(fp)
 8241708:	10800317 	ldw	r2,12(r2)
 824170c:	e0bff715 	stw	r2,-36(fp)
   iphlen = ip_hlen (jrip);
 8241710:	e0bff717 	ldw	r2,-36(fp)
 8241714:	10800003 	ldbu	r2,0(r2)
 8241718:	108003cc 	andi	r2,r2,15
 824171c:	1085883a 	add	r2,r2,r2
 8241720:	1085883a 	add	r2,r2,r2
 8241724:	e0bff805 	stb	r2,-32(fp)
   jrstart = (((ntohs(jrip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 8241728:	e0bff717 	ldw	r2,-36(fp)
 824172c:	1080018b 	ldhu	r2,6(r2)
 8241730:	10bfffcc 	andi	r2,r2,65535
 8241734:	1004d23a 	srli	r2,r2,8
 8241738:	10bfffcc 	andi	r2,r2,65535
 824173c:	10c03fcc 	andi	r3,r2,255
 8241740:	e0bff717 	ldw	r2,-36(fp)
 8241744:	1080018b 	ldhu	r2,6(r2)
 8241748:	10bfffcc 	andi	r2,r2,65535
 824174c:	1004923a 	slli	r2,r2,8
 8241750:	10bfffcc 	andi	r2,r2,65535
 8241754:	1884b03a 	or	r2,r3,r2
 8241758:	100490fa 	slli	r2,r2,3
 824175c:	e0bff50d 	sth	r2,-44(fp)
   jrend =   jrstart + ((ntohs(jrip->ip_len)) - iphlen) - 1;
 8241760:	e0bff717 	ldw	r2,-36(fp)
 8241764:	1080008b 	ldhu	r2,2(r2)
 8241768:	10bfffcc 	andi	r2,r2,65535
 824176c:	1004d23a 	srli	r2,r2,8
 8241770:	1007883a 	mov	r3,r2
 8241774:	e0bff717 	ldw	r2,-36(fp)
 8241778:	1080008b 	ldhu	r2,2(r2)
 824177c:	10bfffcc 	andi	r2,r2,65535
 8241780:	1004923a 	slli	r2,r2,8
 8241784:	1884b03a 	or	r2,r3,r2
 8241788:	1007883a 	mov	r3,r2
 824178c:	e0bff803 	ldbu	r2,-32(fp)
 8241790:	1885c83a 	sub	r2,r3,r2
 8241794:	1007883a 	mov	r3,r2
 8241798:	e0bff50b 	ldhu	r2,-44(fp)
 824179c:	1885883a 	add	r2,r3,r2
 82417a0:	10bfffc4 	addi	r2,r2,-1
 82417a4:	e0bff58d 	sth	r2,-42(fp)
   /* skip past the IP header of the just received fragment as we get ready 
    * to compare for overlap between the just received fragment and the 
    * fragments that are currently queued in the IRE entry for this fragment 
    * chain */
   p->nb_prot += iphlen;
 82417a8:	e0bffc17 	ldw	r2,-16(fp)
 82417ac:	10c00317 	ldw	r3,12(r2)
 82417b0:	e0bff803 	ldbu	r2,-32(fp)
 82417b4:	1887883a 	add	r3,r3,r2
 82417b8:	e0bffc17 	ldw	r2,-16(fp)
 82417bc:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 82417c0:	e0bffc17 	ldw	r2,-16(fp)
 82417c4:	10c00417 	ldw	r3,16(r2)
 82417c8:	e0bff803 	ldbu	r2,-32(fp)
 82417cc:	1887c83a 	sub	r3,r3,r2
 82417d0:	e0bffc17 	ldw	r2,-16(fp)
 82417d4:	10c00415 	stw	r3,16(r2)

   *frag_offsetp = jrstart;
 82417d8:	e0800217 	ldw	r2,8(fp)
 82417dc:	e0fff50b 	ldhu	r3,-44(fp)
 82417e0:	10c0000d 	sth	r3,0(r2)
   *indexp = INVALID_FRAG_INDEX;
 82417e4:	e0bffe17 	ldw	r2,-8(fp)
 82417e8:	00c00404 	movi	r3,16
 82417ec:	10c0000d 	sth	r3,0(r2)
   *last_rfqpp = 0;
 82417f0:	e0bfff17 	ldw	r2,-4(fp)
 82417f4:	10000015 	stw	zero,0(r2)
   *hole_createdp = IPREASM_FALSE;
 82417f8:	e0800317 	ldw	r2,12(fp)
 82417fc:	10000005 	stb	zero,0(r2)

   rfqp = &(irep->rfq);
 8241800:	e0bffd17 	ldw	r2,-12(fp)
 8241804:	10800604 	addi	r2,r2,24
 8241808:	e0bff415 	stw	r2,-48(fp)

   while (rfqp)
 824180c:	0000ef06 	br	8241bcc <ip_reasm_compute_overlap+0x538>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8241810:	e03ff60d 	sth	zero,-40(fp)
 8241814:	0000dd06 	br	8241b8c <ip_reasm_compute_overlap+0x4f8>
         {
         if ((currpkt = rfqp->bufp[i]) != 0)
 8241818:	e0bff60b 	ldhu	r2,-40(fp)
 824181c:	e0fff417 	ldw	r3,-48(fp)
 8241820:	10800044 	addi	r2,r2,1
 8241824:	1085883a 	add	r2,r2,r2
 8241828:	1085883a 	add	r2,r2,r2
 824182c:	1885883a 	add	r2,r3,r2
 8241830:	10800017 	ldw	r2,0(r2)
 8241834:	e0bff915 	stw	r2,-28(fp)
 8241838:	e0bff917 	ldw	r2,-28(fp)
 824183c:	1000c026 	beq	r2,zero,8241b40 <ip_reasm_compute_overlap+0x4ac>
            {
            currstart = rfqp->frag_offset[i];
 8241840:	e0bff60b 	ldhu	r2,-40(fp)
 8241844:	e0fff417 	ldw	r3,-48(fp)
 8241848:	10800884 	addi	r2,r2,34
 824184c:	1085883a 	add	r2,r2,r2
 8241850:	1885883a 	add	r2,r3,r2
 8241854:	1080000b 	ldhu	r2,0(r2)
 8241858:	e0bffa0d 	sth	r2,-24(fp)
            currend = currstart + currpkt->nb_plen - 1;
 824185c:	e0bff917 	ldw	r2,-28(fp)
 8241860:	10800417 	ldw	r2,16(r2)
 8241864:	1007883a 	mov	r3,r2
 8241868:	e0bffa0b 	ldhu	r2,-24(fp)
 824186c:	1885883a 	add	r2,r3,r2
 8241870:	10bfffc4 	addi	r2,r2,-1
 8241874:	e0bffa8d 	sth	r2,-22(fp)

            if (currstart < jrstart)
 8241878:	e0fffa0b 	ldhu	r3,-24(fp)
 824187c:	e0bff50b 	ldhu	r2,-44(fp)
 8241880:	18802b2e 	bgeu	r3,r2,8241930 <ip_reasm_compute_overlap+0x29c>
               {
               if (currend < jrend) /* cases A1 and A2 */
 8241884:	e0fffa8b 	ldhu	r3,-22(fp)
 8241888:	e0bff58b 	ldhu	r2,-42(fp)
 824188c:	1880202e 	bgeu	r3,r2,8241910 <ip_reasm_compute_overlap+0x27c>
                  {
                  if (currend < jrstart) /* A1 */
 8241890:	e0fffa8b 	ldhu	r3,-22(fp)
 8241894:	e0bff50b 	ldhu	r2,-44(fp)
 8241898:	1880b936 	bltu	r3,r2,8241b80 <ip_reasm_compute_overlap+0x4ec>
                     {
                     /* the just received fragment partially overlaps current 
                      * fragment on the latter's right; increment start 
                      * pointer and decrement length of just received fragment.
                      * Move on to the next fragment in the RFQ. */
                     drop_len = (currend - jrstart) + 1;
 824189c:	e0fffa8b 	ldhu	r3,-22(fp)
 82418a0:	e0bff50b 	ldhu	r2,-44(fp)
 82418a4:	1885c83a 	sub	r2,r3,r2
 82418a8:	10800044 	addi	r2,r2,1
 82418ac:	e0bffb0d 	sth	r2,-20(fp)
                     p->nb_prot += drop_len;
 82418b0:	e0bffc17 	ldw	r2,-16(fp)
 82418b4:	10c00317 	ldw	r3,12(r2)
 82418b8:	e0bffb0b 	ldhu	r2,-20(fp)
 82418bc:	1887883a 	add	r3,r3,r2
 82418c0:	e0bffc17 	ldw	r2,-16(fp)
 82418c4:	10c00315 	stw	r3,12(r2)
                     p->nb_plen -= drop_len;
 82418c8:	e0bffc17 	ldw	r2,-16(fp)
 82418cc:	10c00417 	ldw	r3,16(r2)
 82418d0:	e0bffb0b 	ldhu	r2,-20(fp)
 82418d4:	1887c83a 	sub	r3,r3,r2
 82418d8:	e0bffc17 	ldw	r2,-16(fp)
 82418dc:	10c00415 	stw	r3,16(r2)
                     jrstart += drop_len;
 82418e0:	e0fff50b 	ldhu	r3,-44(fp)
 82418e4:	e0bffb0b 	ldhu	r2,-20(fp)
 82418e8:	1885883a 	add	r2,r3,r2
 82418ec:	e0bff50d 	sth	r2,-44(fp)
                     jrend = jrstart + p->nb_plen - 1;
 82418f0:	e0bffc17 	ldw	r2,-16(fp)
 82418f4:	10800417 	ldw	r2,16(r2)
 82418f8:	1007883a 	mov	r3,r2
 82418fc:	e0bff50b 	ldhu	r2,-44(fp)
 8241900:	1885883a 	add	r2,r3,r2
 8241904:	10bfffc4 	addi	r2,r2,-1
 8241908:	e0bff58d 	sth	r2,-42(fp)
 824190c:	00009c06 	br	8241b80 <ip_reasm_compute_overlap+0x4ec>
               else
                  {
                  /* currend is greater than or equal to jrend (cases E1 and E2).
                   * The current fragment is a superset of the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 8241910:	01000084 	movi	r4,2
 8241914:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
                  pk_free (p);
 8241918:	e13ffc17 	ldw	r4,-16(fp)
 824191c:	822cd3c0 	call	822cd3c <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241920:	01000084 	movi	r4,2
 8241924:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 8241928:	0005883a 	mov	r2,zero
 824192c:	0000ad06 	br	8241be4 <ip_reasm_compute_overlap+0x550>
                  }
               }
            else if (currstart > jrstart)
 8241930:	e0bffa0b 	ldhu	r2,-24(fp)
 8241934:	e0fff50b 	ldhu	r3,-44(fp)
 8241938:	18804e2e 	bgeu	r3,r2,8241a74 <ip_reasm_compute_overlap+0x3e0>
               {
               if (currend > jrend) /* cases B1 and B2 */
 824193c:	e0bffa8b 	ldhu	r2,-22(fp)
 8241940:	e0fff58b 	ldhu	r3,-42(fp)
 8241944:	1880112e 	bgeu	r3,r2,824198c <ip_reasm_compute_overlap+0x2f8>
                  {
                  if (currstart > jrend) /* B1 */
 8241948:	e0bffa0b 	ldhu	r2,-24(fp)
 824194c:	e0fff58b 	ldhu	r3,-42(fp)
 8241950:	18808b36 	bltu	r3,r2,8241b80 <ip_reasm_compute_overlap+0x4ec>
                     {
                     /* just received fragment partially overlaps current 
                      * fragment on the latter's left; decrement length of 
                      * just received fragment.  Move on to the next fragment 
                      * in the RFQ. */
                     p->nb_plen = currstart - jrstart;
 8241954:	e0fffa0b 	ldhu	r3,-24(fp)
 8241958:	e0bff50b 	ldhu	r2,-44(fp)
 824195c:	1885c83a 	sub	r2,r3,r2
 8241960:	1007883a 	mov	r3,r2
 8241964:	e0bffc17 	ldw	r2,-16(fp)
 8241968:	10c00415 	stw	r3,16(r2)
                     /* start offset remains unchanged, but jrend must be updated */
                     jrend = jrstart + p->nb_plen - 1;
 824196c:	e0bffc17 	ldw	r2,-16(fp)
 8241970:	10800417 	ldw	r2,16(r2)
 8241974:	1007883a 	mov	r3,r2
 8241978:	e0bff50b 	ldhu	r2,-44(fp)
 824197c:	1885883a 	add	r2,r3,r2
 8241980:	10bfffc4 	addi	r2,r2,-1
 8241984:	e0bff58d 	sth	r2,-42(fp)
 8241988:	00007d06 	br	8241b80 <ip_reasm_compute_overlap+0x4ec>
                     }
                  }
               else if (currend == jrend) /* F1 */
 824198c:	e0fffa8b 	ldhu	r3,-22(fp)
 8241990:	e0bff58b 	ldhu	r2,-42(fp)
 8241994:	18800e1e 	bne	r3,r2,82419d0 <ip_reasm_compute_overlap+0x33c>
                  {
                  /* current fragment is a subset of the just received fragment.  
                   * Decrement the length of the just received fragment.  Move
                   * on to the next fragment in the RFQ. */
                  p->nb_plen = currstart - jrstart;
 8241998:	e0fffa0b 	ldhu	r3,-24(fp)
 824199c:	e0bff50b 	ldhu	r2,-44(fp)
 82419a0:	1885c83a 	sub	r2,r3,r2
 82419a4:	1007883a 	mov	r3,r2
 82419a8:	e0bffc17 	ldw	r2,-16(fp)
 82419ac:	10c00415 	stw	r3,16(r2)
                  jrend = jrstart + p->nb_plen - 1;
 82419b0:	e0bffc17 	ldw	r2,-16(fp)
 82419b4:	10800417 	ldw	r2,16(r2)
 82419b8:	1007883a 	mov	r3,r2
 82419bc:	e0bff50b 	ldhu	r2,-44(fp)
 82419c0:	1885883a 	add	r2,r3,r2
 82419c4:	10bfffc4 	addi	r2,r2,-1
 82419c8:	e0bff58d 	sth	r2,-42(fp)
 82419cc:	00006c06 	br	8241b80 <ip_reasm_compute_overlap+0x4ec>
                  {
                  /* currend is less than jrend (case F2).  current fragment is 
                   * a subset of the just received fragment.  Drop current
                   * fragment.  Move on to the next fragment in the RFQ.  Decrement
                   * the amount of memory currently in use. */
                  ip_reasm_decr_mem_useage (currpkt->nb_blen);
 82419d0:	e0bff917 	ldw	r2,-28(fp)
 82419d4:	10800217 	ldw	r2,8(r2)
 82419d8:	10bfffcc 	andi	r2,r2,65535
 82419dc:	1009883a 	mov	r4,r2
 82419e0:	82412bc0 	call	82412bc <ip_reasm_decr_mem_useage>
                  irep->rcvd -= currpkt->nb_plen;
 82419e4:	e0bffd17 	ldw	r2,-12(fp)
 82419e8:	1080048b 	ldhu	r2,18(r2)
 82419ec:	e0fff917 	ldw	r3,-28(fp)
 82419f0:	18c00417 	ldw	r3,16(r3)
 82419f4:	10c5c83a 	sub	r2,r2,r3
 82419f8:	1007883a 	mov	r3,r2
 82419fc:	e0bffd17 	ldw	r2,-12(fp)
 8241a00:	10c0048d 	sth	r3,18(r2)
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 8241a04:	01000084 	movi	r4,2
 8241a08:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
                  pk_free (currpkt);
 8241a0c:	e13ff917 	ldw	r4,-28(fp)
 8241a10:	822cd3c0 	call	822cd3c <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241a14:	01000084 	movi	r4,2
 8241a18:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
                  rfqp->bufp[i] = 0; /* mark slot as unused */
 8241a1c:	e0bff60b 	ldhu	r2,-40(fp)
 8241a20:	e0fff417 	ldw	r3,-48(fp)
 8241a24:	10800044 	addi	r2,r2,1
 8241a28:	1085883a 	add	r2,r2,r2
 8241a2c:	1085883a 	add	r2,r2,r2
 8241a30:	1885883a 	add	r2,r3,r2
 8241a34:	10000015 	stw	zero,0(r2)
                  /* save the location of the empty slot */
                  if ((*indexp) == INVALID_FRAG_INDEX) 
 8241a38:	e0bffe17 	ldw	r2,-8(fp)
 8241a3c:	1080000b 	ldhu	r2,0(r2)
 8241a40:	10bfffcc 	andi	r2,r2,65535
 8241a44:	10800418 	cmpnei	r2,r2,16
 8241a48:	1000061e 	bne	r2,zero,8241a64 <ip_reasm_compute_overlap+0x3d0>
                     {
                     *indexp = i;
 8241a4c:	e0bffe17 	ldw	r2,-8(fp)
 8241a50:	e0fff60b 	ldhu	r3,-40(fp)
 8241a54:	10c0000d 	sth	r3,0(r2)
                     *last_rfqpp = rfqp;
 8241a58:	e0bfff17 	ldw	r2,-4(fp)
 8241a5c:	e0fff417 	ldw	r3,-48(fp)
 8241a60:	10c00015 	stw	r3,0(r2)
                     }
                  /* we've just created a hole; the array may no longer be "compact" */
                  *hole_createdp = IPREASM_TRUE;
 8241a64:	e0800317 	ldw	r2,12(fp)
 8241a68:	00c00044 	movi	r3,1
 8241a6c:	10c00005 	stb	r3,0(r2)
 8241a70:	00004306 	br	8241b80 <ip_reasm_compute_overlap+0x4ec>
                  }
               }
            else
               {
               /* currstart and jrstart are equal */
               if (currend == jrend) /* case C */
 8241a74:	e0fffa8b 	ldhu	r3,-22(fp)
 8241a78:	e0bff58b 	ldhu	r2,-42(fp)
 8241a7c:	1880081e 	bne	r3,r2,8241aa0 <ip_reasm_compute_overlap+0x40c>
                  {
                  /* the current fragment is identical to the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 8241a80:	01000084 	movi	r4,2
 8241a84:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
                  pk_free (p);
 8241a88:	e13ffc17 	ldw	r4,-16(fp)
 8241a8c:	822cd3c0 	call	822cd3c <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241a90:	01000084 	movi	r4,2
 8241a94:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 8241a98:	0005883a 	mov	r2,zero
 8241a9c:	00005106 	br	8241be4 <ip_reasm_compute_overlap+0x550>
                  }
               else if (currend > jrend) /* case D1 */
 8241aa0:	e0bffa8b 	ldhu	r2,-22(fp)
 8241aa4:	e0fff58b 	ldhu	r3,-42(fp)
 8241aa8:	1880082e 	bgeu	r3,r2,8241acc <ip_reasm_compute_overlap+0x438>
                  {
                  /* current fragment is a superset of just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 8241aac:	01000084 	movi	r4,2
 8241ab0:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
                  pk_free (p);
 8241ab4:	e13ffc17 	ldw	r4,-16(fp)
 8241ab8:	822cd3c0 	call	822cd3c <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241abc:	01000084 	movi	r4,2
 8241ac0:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 8241ac4:	0005883a 	mov	r2,zero
 8241ac8:	00004606 	br	8241be4 <ip_reasm_compute_overlap+0x550>
                  /* currend is less than jrend (case D2).  current fragment 
                   * is a subset of the just received fragment.  Increment 
                   * the start pointer and decrement the length of the just
                   * received fragment.  Move on to the next fragment in 
                   * the RFQ. */
                  drop_len = (currend - jrstart) + 1;
 8241acc:	e0fffa8b 	ldhu	r3,-22(fp)
 8241ad0:	e0bff50b 	ldhu	r2,-44(fp)
 8241ad4:	1885c83a 	sub	r2,r3,r2
 8241ad8:	10800044 	addi	r2,r2,1
 8241adc:	e0bffb0d 	sth	r2,-20(fp)
                  p->nb_prot += drop_len;
 8241ae0:	e0bffc17 	ldw	r2,-16(fp)
 8241ae4:	10c00317 	ldw	r3,12(r2)
 8241ae8:	e0bffb0b 	ldhu	r2,-20(fp)
 8241aec:	1887883a 	add	r3,r3,r2
 8241af0:	e0bffc17 	ldw	r2,-16(fp)
 8241af4:	10c00315 	stw	r3,12(r2)
                  p->nb_plen -= drop_len;
 8241af8:	e0bffc17 	ldw	r2,-16(fp)
 8241afc:	10c00417 	ldw	r3,16(r2)
 8241b00:	e0bffb0b 	ldhu	r2,-20(fp)
 8241b04:	1887c83a 	sub	r3,r3,r2
 8241b08:	e0bffc17 	ldw	r2,-16(fp)
 8241b0c:	10c00415 	stw	r3,16(r2)
                  jrstart += drop_len;
 8241b10:	e0fff50b 	ldhu	r3,-44(fp)
 8241b14:	e0bffb0b 	ldhu	r2,-20(fp)
 8241b18:	1885883a 	add	r2,r3,r2
 8241b1c:	e0bff50d 	sth	r2,-44(fp)
                  jrend = jrstart + p->nb_plen - 1;
 8241b20:	e0bffc17 	ldw	r2,-16(fp)
 8241b24:	10800417 	ldw	r2,16(r2)
 8241b28:	1007883a 	mov	r3,r2
 8241b2c:	e0bff50b 	ldhu	r2,-44(fp)
 8241b30:	1885883a 	add	r2,r3,r2
 8241b34:	10bfffc4 	addi	r2,r2,-1
 8241b38:	e0bff58d 	sth	r2,-42(fp)
 8241b3c:	00001006 	br	8241b80 <ip_reasm_compute_overlap+0x4ec>
                  }
               }
            } /* end if (PACKET buffer exists at this slot) */
         else
            {
            if ((*indexp) == INVALID_FRAG_INDEX)
 8241b40:	e0bffe17 	ldw	r2,-8(fp)
 8241b44:	1080000b 	ldhu	r2,0(r2)
 8241b48:	10bfffcc 	andi	r2,r2,65535
 8241b4c:	10800418 	cmpnei	r2,r2,16
 8241b50:	1000061e 	bne	r2,zero,8241b6c <ip_reasm_compute_overlap+0x4d8>
               {
               *indexp = i;
 8241b54:	e0bffe17 	ldw	r2,-8(fp)
 8241b58:	e0fff60b 	ldhu	r3,-40(fp)
 8241b5c:	10c0000d 	sth	r3,0(r2)
               *last_rfqpp = rfqp;               
 8241b60:	e0bfff17 	ldw	r2,-4(fp)
 8241b64:	e0fff417 	ldw	r3,-48(fp)
 8241b68:	10c00015 	stw	r3,0(r2)
               }
            if (irep->flags & IPR_RFQ_COMPACT)
 8241b6c:	e0bffd17 	ldw	r2,-12(fp)
 8241b70:	10802103 	ldbu	r2,132(r2)
 8241b74:	10803fcc 	andi	r2,r2,255
 8241b78:	1080004c 	andi	r2,r2,1
 8241b7c:	1000071e 	bne	r2,zero,8241b9c <ip_reasm_compute_overlap+0x508>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8241b80:	e0bff60b 	ldhu	r2,-40(fp)
 8241b84:	10800044 	addi	r2,r2,1
 8241b88:	e0bff60d 	sth	r2,-40(fp)
 8241b8c:	e0bff60b 	ldhu	r2,-40(fp)
 8241b90:	10800430 	cmpltui	r2,r2,16
 8241b94:	103f201e 	bne	r2,zero,8241818 <ip_reasm_compute_overlap+0x184>
 8241b98:	00000106 	br	8241ba0 <ip_reasm_compute_overlap+0x50c>
               *indexp = i;
               *last_rfqpp = rfqp;               
               }
            if (irep->flags & IPR_RFQ_COMPACT)
               {
               break;
 8241b9c:	0001883a 	nop
               }
            }
         } /* end FOR (0...(IPR_MAX_FRAGS - 1)) */

      /* skip saving RFQ pointer if we've already found an empty slot */
      if ((*indexp) == INVALID_FRAG_INDEX) 
 8241ba0:	e0bffe17 	ldw	r2,-8(fp)
 8241ba4:	1080000b 	ldhu	r2,0(r2)
 8241ba8:	10bfffcc 	andi	r2,r2,65535
 8241bac:	10800418 	cmpnei	r2,r2,16
 8241bb0:	1000031e 	bne	r2,zero,8241bc0 <ip_reasm_compute_overlap+0x52c>
         {
         *last_rfqpp = rfqp;
 8241bb4:	e0bfff17 	ldw	r2,-4(fp)
 8241bb8:	e0fff417 	ldw	r3,-48(fp)
 8241bbc:	10c00015 	stw	r3,0(r2)
         }
      rfqp = rfqp->next;
 8241bc0:	e0bff417 	ldw	r2,-48(fp)
 8241bc4:	10800017 	ldw	r2,0(r2)
 8241bc8:	e0bff415 	stw	r2,-48(fp)
   *last_rfqpp = 0;
   *hole_createdp = IPREASM_FALSE;

   rfqp = &(irep->rfq);

   while (rfqp)
 8241bcc:	e0bff417 	ldw	r2,-48(fp)
 8241bd0:	103f0f1e 	bne	r2,zero,8241810 <ip_reasm_compute_overlap+0x17c>
      } /* end while (rfqp) */

   /* if no empty slots were found, (*last_rfqpp) will contain a pointer 
    * to the last RFQ that we were working with */

   *frag_offsetp = jrstart; /* stored in host byte order */
 8241bd4:	e0800217 	ldw	r2,8(fp)
 8241bd8:	e0fff50b 	ldhu	r3,-44(fp)
 8241bdc:	10c0000d 	sth	r3,0(r2)

   return IPREASM_ACCEPT_FRAG;
 8241be0:	00800084 	movi	r2,2
}
 8241be4:	e037883a 	mov	sp,fp
 8241be8:	dfc00117 	ldw	ra,4(sp)
 8241bec:	df000017 	ldw	fp,0(sp)
 8241bf0:	dec00204 	addi	sp,sp,8
 8241bf4:	f800283a 	ret

08241bf8 <ip_reasm_process_subsequent_fragments>:
            queued fragments (and hence has been dropped), or if the fragment
            has been processed successfully.
*/

int ip_reasm_process_subsequent_fragments (PACKET p, IREP irep)
{
 8241bf8:	defff104 	addi	sp,sp,-60
 8241bfc:	dfc00e15 	stw	ra,56(sp)
 8241c00:	df000d15 	stw	fp,52(sp)
 8241c04:	df000d04 	addi	fp,sp,52
 8241c08:	e13ffe15 	stw	r4,-8(fp)
 8241c0c:	e17fff15 	stw	r5,-4(fp)
   PACKET reassy_pkt;
   struct ip * pip;
   RFQP new_rfqp = 0;
 8241c10:	e03ff515 	stw	zero,-44(fp)
   u_short index;
   RFQP rfqp;
   u_short frag_offset;
   u_char hole_created;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 8241c14:	e13fff17 	ldw	r4,-4(fp)
 8241c18:	82421280 	call	8242128 <ip_reasm_find_ire>
 8241c1c:	10803fcc 	andi	r2,r2,255
 8241c20:	10800060 	cmpeqi	r2,r2,1
 8241c24:	1000161e 	bne	r2,zero,8241c80 <ip_reasm_process_subsequent_fragments+0x88>
      {
      ++ire_stats.bad_irep;
 8241c28:	008209b4 	movhi	r2,2086
 8241c2c:	10ba7504 	addi	r2,r2,-5676
 8241c30:	10800017 	ldw	r2,0(r2)
 8241c34:	10c00044 	addi	r3,r2,1
 8241c38:	008209b4 	movhi	r2,2086
 8241c3c:	10ba7504 	addi	r2,r2,-5676
 8241c40:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 8241c44:	01000084 	movi	r4,2
 8241c48:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free (p);
 8241c4c:	e13ffe17 	ldw	r4,-8(fp)
 8241c50:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241c54:	01000084 	movi	r4,2
 8241c58:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 8241c5c:	008209b4 	movhi	r2,2086
 8241c60:	10ba6104 	addi	r2,r2,-5756
 8241c64:	10800f17 	ldw	r2,60(r2)
 8241c68:	10c00044 	addi	r3,r2,1
 8241c6c:	008209b4 	movhi	r2,2086
 8241c70:	10ba6104 	addi	r2,r2,-5756
 8241c74:	10c00f15 	stw	r3,60(r2)
      return ENP_PARAM;
 8241c78:	00bffd84 	movi	r2,-10
 8241c7c:	00012506 	br	8242114 <ip_reasm_process_subsequent_fragments+0x51c>
      }

   pip = ip_head(p);
 8241c80:	e0bffe17 	ldw	r2,-8(fp)
 8241c84:	10800317 	ldw	r2,12(r2)
 8241c88:	e0bff615 	stw	r2,-40(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 8241c8c:	e13ff617 	ldw	r4,-40(fp)
 8241c90:	82410b80 	call	82410b8 <ip_reasm_determine_type_of_frag>
 8241c94:	e0bff715 	stw	r2,-36(fp)
   /* this fragment is a destined for an already queued fragment stream.
    * we update the 'length' field for LFs here because ip_reasm_compute_overlap ()
    * modifies the received fragment's nb_prot pointer (thereby making its IP header 
    * inaccessible) */
   if (ftype == IP_LF)
 8241c98:	e0bff717 	ldw	r2,-36(fp)
 8241c9c:	10800158 	cmpnei	r2,r2,5
 8241ca0:	1000251e 	bne	r2,zero,8241d38 <ip_reasm_process_subsequent_fragments+0x140>
      {
      irep->length = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3) + ((ntohs(pip->ip_len)) - ip_hlen(pip));
 8241ca4:	e0bff617 	ldw	r2,-40(fp)
 8241ca8:	1080018b 	ldhu	r2,6(r2)
 8241cac:	10bfffcc 	andi	r2,r2,65535
 8241cb0:	1004d23a 	srli	r2,r2,8
 8241cb4:	10bfffcc 	andi	r2,r2,65535
 8241cb8:	10c03fcc 	andi	r3,r2,255
 8241cbc:	e0bff617 	ldw	r2,-40(fp)
 8241cc0:	1080018b 	ldhu	r2,6(r2)
 8241cc4:	10bfffcc 	andi	r2,r2,65535
 8241cc8:	1004923a 	slli	r2,r2,8
 8241ccc:	10bfffcc 	andi	r2,r2,65535
 8241cd0:	1884b03a 	or	r2,r3,r2
 8241cd4:	100490fa 	slli	r2,r2,3
 8241cd8:	1007883a 	mov	r3,r2
 8241cdc:	e0bff617 	ldw	r2,-40(fp)
 8241ce0:	1080008b 	ldhu	r2,2(r2)
 8241ce4:	10bfffcc 	andi	r2,r2,65535
 8241ce8:	1004d23a 	srli	r2,r2,8
 8241cec:	1009883a 	mov	r4,r2
 8241cf0:	e0bff617 	ldw	r2,-40(fp)
 8241cf4:	1080008b 	ldhu	r2,2(r2)
 8241cf8:	10bfffcc 	andi	r2,r2,65535
 8241cfc:	1004923a 	slli	r2,r2,8
 8241d00:	2084b03a 	or	r2,r4,r2
 8241d04:	1009883a 	mov	r4,r2
 8241d08:	e0bff617 	ldw	r2,-40(fp)
 8241d0c:	10800003 	ldbu	r2,0(r2)
 8241d10:	10803fcc 	andi	r2,r2,255
 8241d14:	108003cc 	andi	r2,r2,15
 8241d18:	1085883a 	add	r2,r2,r2
 8241d1c:	1085883a 	add	r2,r2,r2
 8241d20:	2085c83a 	sub	r2,r4,r2
 8241d24:	1885883a 	add	r2,r3,r2
 8241d28:	1007883a 	mov	r3,r2
 8241d2c:	e0bfff17 	ldw	r2,-4(fp)
 8241d30:	10c0040d 	sth	r3,16(r2)
 8241d34:	00000a06 	br	8241d60 <ip_reasm_process_subsequent_fragments+0x168>
      }
   else if (ftype == IP_FF)
 8241d38:	e0bff717 	ldw	r2,-36(fp)
 8241d3c:	10800058 	cmpnei	r2,r2,1
 8241d40:	1000071e 	bne	r2,zero,8241d60 <ip_reasm_process_subsequent_fragments+0x168>
      {
      irep->l2_hdr = p->nb_buff;
 8241d44:	e0bffe17 	ldw	r2,-8(fp)
 8241d48:	10c00117 	ldw	r3,4(r2)
 8241d4c:	e0bfff17 	ldw	r2,-4(fp)
 8241d50:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 8241d54:	e0bfff17 	ldw	r2,-4(fp)
 8241d58:	e0fff617 	ldw	r3,-40(fp)
 8241d5c:	10c02015 	stw	r3,128(r2)
      }

   /* Check for overlap, and determine the increase in memory resource 
    * requirements from the newly arrived fragment */
   if ((rc2 = ip_reasm_compute_overlap (p, irep, &index, &rfqp, &frag_offset, &hole_created)) != IPREASM_ACCEPT_FRAG)
 8241d60:	e13ffc04 	addi	r4,fp,-16
 8241d64:	e0fffb04 	addi	r3,fp,-20
 8241d68:	e0bffd84 	addi	r2,fp,-10
 8241d6c:	d8800115 	stw	r2,4(sp)
 8241d70:	e0bffd04 	addi	r2,fp,-12
 8241d74:	d8800015 	stw	r2,0(sp)
 8241d78:	200f883a 	mov	r7,r4
 8241d7c:	180d883a 	mov	r6,r3
 8241d80:	e17fff17 	ldw	r5,-4(fp)
 8241d84:	e13ffe17 	ldw	r4,-8(fp)
 8241d88:	82416940 	call	8241694 <ip_reasm_compute_overlap>
 8241d8c:	e0bff815 	stw	r2,-32(fp)
 8241d90:	e0bff817 	ldw	r2,-32(fp)
 8241d94:	108000a0 	cmpeqi	r2,r2,2
 8241d98:	1000091e 	bne	r2,zero,8241dc0 <ip_reasm_process_subsequent_fragments+0x1c8>
      {
      switch (rc2)
 8241d9c:	e0bff817 	ldw	r2,-32(fp)
 8241da0:	10c00060 	cmpeqi	r3,r2,1
 8241da4:	1800031e 	bne	r3,zero,8241db4 <ip_reasm_process_subsequent_fragments+0x1bc>
 8241da8:	00800436 	bltu	zero,r2,8241dbc <ip_reasm_process_subsequent_fragments+0x1c4>
         {
         case IPREASM_DROP_FRAG_DUPLICATE:
            /* this isn't really an error, since it indicates that the received 
             * fragment's information is a duplicate of what is present in the 
             * already queued fragments */
            return IPREASM_OK;
 8241dac:	0005883a 	mov	r2,zero
 8241db0:	0000d806 	br	8242114 <ip_reasm_process_subsequent_fragments+0x51c>
         case IPREASM_DROP_FRAG_BAD_PARAM:
            /* this is a real error */
            return ENP_PARAM;
 8241db4:	00bffd84 	movi	r2,-10
 8241db8:	0000d606 	br	8242114 <ip_reasm_process_subsequent_fragments+0x51c>
          * Altera Niche Stack Nios port modification:
          * Handle IPREASM_ACCEPT_FRAG case (will never
          * get here per if() above) to remove build warning.
          */
         case IPREASM_ACCEPT_FRAG:
            while(0);
 8241dbc:	0001883a 	nop
      }

   /* this is a fragment from an existing fragment stream; 
    * check for resource limits before accepting it.  For now
    * assume that an extra RFQ is not required. */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen)) != IPREASM_OK)
 8241dc0:	e0bffe17 	ldw	r2,-8(fp)
 8241dc4:	10800217 	ldw	r2,8(r2)
 8241dc8:	10bfffcc 	andi	r2,r2,65535
 8241dcc:	1009883a 	mov	r4,r2
 8241dd0:	82411880 	call	8241188 <ip_reasm_check_mem_useage>
 8241dd4:	e0bff915 	stw	r2,-28(fp)
 8241dd8:	e0bff917 	ldw	r2,-28(fp)
 8241ddc:	10001126 	beq	r2,zero,8241e24 <ip_reasm_process_subsequent_fragments+0x22c>
      {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 8241de0:	01000084 	movi	r4,2
 8241de4:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free (p);
 8241de8:	e13ffe17 	ldw	r4,-8(fp)
 8241dec:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241df0:	01000084 	movi	r4,2
 8241df4:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      ip_reasm_delete_ire (irep);
 8241df8:	e13fff17 	ldw	r4,-4(fp)
 8241dfc:	82425a40 	call	82425a4 <ip_reasm_delete_ire>
      ++ip_mib.ipReasmFails;
 8241e00:	008209b4 	movhi	r2,2086
 8241e04:	10ba6104 	addi	r2,r2,-5756
 8241e08:	10800f17 	ldw	r2,60(r2)
 8241e0c:	10c00044 	addi	r3,r2,1
 8241e10:	008209b4 	movhi	r2,2086
 8241e14:	10ba6104 	addi	r2,r2,-5756
 8241e18:	10c00f15 	stw	r3,60(r2)
      return rc;
 8241e1c:	e0bff917 	ldw	r2,-28(fp)
 8241e20:	0000bc06 	br	8242114 <ip_reasm_process_subsequent_fragments+0x51c>

   /* the two combinations of index and rfqp are as follows:
    * (1) index = INVALID_FRAG_INDEX, rfqp = non-zero: no empty slot found in RFQ(s),
    *     and rfqp points to the last RFQ that was processed
    * (2) index != INVALID_FRAG_INDEX, rfqp = non-zero: empty slot found in RFQ(s) */
   if (index != INVALID_FRAG_INDEX)
 8241e24:	e0bffb0b 	ldhu	r2,-20(fp)
 8241e28:	10bfffcc 	andi	r2,r2,65535
 8241e2c:	10800420 	cmpeqi	r2,r2,16
 8241e30:	1000121e 	bne	r2,zero,8241e7c <ip_reasm_process_subsequent_fragments+0x284>
      {
      /* we have an empty slot in the PACKET array into which we can place 
       * the just received fragment */
      rfqp->bufp[index] = p;
 8241e34:	e0fffc17 	ldw	r3,-16(fp)
 8241e38:	e0bffb0b 	ldhu	r2,-20(fp)
 8241e3c:	10bfffcc 	andi	r2,r2,65535
 8241e40:	10800044 	addi	r2,r2,1
 8241e44:	1085883a 	add	r2,r2,r2
 8241e48:	1085883a 	add	r2,r2,r2
 8241e4c:	1885883a 	add	r2,r3,r2
 8241e50:	e0fffe17 	ldw	r3,-8(fp)
 8241e54:	10c00015 	stw	r3,0(r2)
      rfqp->frag_offset[index] = frag_offset;
 8241e58:	e13ffc17 	ldw	r4,-16(fp)
 8241e5c:	e0bffb0b 	ldhu	r2,-20(fp)
 8241e60:	10bfffcc 	andi	r2,r2,65535
 8241e64:	e0fffd0b 	ldhu	r3,-12(fp)
 8241e68:	10800884 	addi	r2,r2,34
 8241e6c:	1085883a 	add	r2,r2,r2
 8241e70:	2085883a 	add	r2,r4,r2
 8241e74:	10c0000d 	sth	r3,0(r2)
 8241e78:	00003906 	br	8241f60 <ip_reasm_process_subsequent_fragments+0x368>
      }
   else
      {
      /* since we need to allocate an extra RFQ, check for memory useage again... */
      if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (RFQ)))) != IPREASM_OK)
 8241e7c:	e0bffe17 	ldw	r2,-8(fp)
 8241e80:	10800217 	ldw	r2,8(r2)
 8241e84:	10801904 	addi	r2,r2,100
 8241e88:	10bfffcc 	andi	r2,r2,65535
 8241e8c:	1009883a 	mov	r4,r2
 8241e90:	82411880 	call	8241188 <ip_reasm_check_mem_useage>
 8241e94:	e0bff915 	stw	r2,-28(fp)
 8241e98:	e0bff917 	ldw	r2,-28(fp)
 8241e9c:	10001126 	beq	r2,zero,8241ee4 <ip_reasm_process_subsequent_fragments+0x2ec>
         {
         LOCK_NET_RESOURCE (FREEQ_RESID);
 8241ea0:	01000084 	movi	r4,2
 8241ea4:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
         pk_free (p);
 8241ea8:	e13ffe17 	ldw	r4,-8(fp)
 8241eac:	822cd3c0 	call	822cd3c <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241eb0:	01000084 	movi	r4,2
 8241eb4:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 8241eb8:	e13fff17 	ldw	r4,-4(fp)
 8241ebc:	82425a40 	call	82425a4 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 8241ec0:	008209b4 	movhi	r2,2086
 8241ec4:	10ba6104 	addi	r2,r2,-5756
 8241ec8:	10800f17 	ldw	r2,60(r2)
 8241ecc:	10c00044 	addi	r3,r2,1
 8241ed0:	008209b4 	movhi	r2,2086
 8241ed4:	10ba6104 	addi	r2,r2,-5756
 8241ed8:	10c00f15 	stw	r3,60(r2)
         return rc;
 8241edc:	e0bff917 	ldw	r2,-28(fp)
 8241ee0:	00008c06 	br	8242114 <ip_reasm_process_subsequent_fragments+0x51c>
         }

      /* no slots are available in the one (or more) existing RFQs; we 
       * need to create a new RFQ to store the just received fragment */
      new_rfqp = (RFQP) IPR_ALLOC (sizeof(RFQ));
 8241ee4:	01001904 	movi	r4,100
 8241ee8:	822e16c0 	call	822e16c <npalloc>
 8241eec:	e0bff515 	stw	r2,-44(fp)
      if (new_rfqp == 0)
 8241ef0:	e0bff517 	ldw	r2,-44(fp)
 8241ef4:	1000111e 	bne	r2,zero,8241f3c <ip_reasm_process_subsequent_fragments+0x344>
         {
         /* can't store the existing fragment, so we'll drop it */
         LOCK_NET_RESOURCE (FREEQ_RESID);
 8241ef8:	01000084 	movi	r4,2
 8241efc:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
         pk_free (p);
 8241f00:	e13ffe17 	ldw	r4,-8(fp)
 8241f04:	822cd3c0 	call	822cd3c <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241f08:	01000084 	movi	r4,2
 8241f0c:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 8241f10:	e13fff17 	ldw	r4,-4(fp)
 8241f14:	82425a40 	call	82425a4 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 8241f18:	008209b4 	movhi	r2,2086
 8241f1c:	10ba6104 	addi	r2,r2,-5756
 8241f20:	10800f17 	ldw	r2,60(r2)
 8241f24:	10c00044 	addi	r3,r2,1
 8241f28:	008209b4 	movhi	r2,2086
 8241f2c:	10ba6104 	addi	r2,r2,-5756
 8241f30:	10c00f15 	stw	r3,60(r2)
         return ENP_RESOURCE;
 8241f34:	00bffa84 	movi	r2,-22
 8241f38:	00007606 	br	8242114 <ip_reasm_process_subsequent_fragments+0x51c>
         }
      else
         {
         new_rfqp->bufp[0] = p;
 8241f3c:	e0bff517 	ldw	r2,-44(fp)
 8241f40:	e0fffe17 	ldw	r3,-8(fp)
 8241f44:	10c00115 	stw	r3,4(r2)
         new_rfqp->frag_offset[0] = frag_offset;
 8241f48:	e0fffd0b 	ldhu	r3,-12(fp)
 8241f4c:	e0bff517 	ldw	r2,-44(fp)
 8241f50:	10c0110d 	sth	r3,68(r2)
         rfqp->next = new_rfqp;
 8241f54:	e0bffc17 	ldw	r2,-16(fp)
 8241f58:	e0fff517 	ldw	r3,-44(fp)
 8241f5c:	10c00015 	stw	r3,0(r2)
         }
      }
      
      /* check to see if the RFQ is still compact, but only if hole(s) were created 
       * in ip_reasm_compute_overlap () */
      if (hole_created)
 8241f60:	e0bffd83 	ldbu	r2,-10(fp)
 8241f64:	10803fcc 	andi	r2,r2,255
 8241f68:	10001426 	beq	r2,zero,8241fbc <ip_reasm_process_subsequent_fragments+0x3c4>
         {
         if ((rc = ip_reasm_mark_compact_rfq (irep)) != IPREASM_OK)
 8241f6c:	e13fff17 	ldw	r4,-4(fp)
 8241f70:	82427580 	call	8242758 <ip_reasm_mark_compact_rfq>
 8241f74:	e0bff915 	stw	r2,-28(fp)
 8241f78:	e0bff917 	ldw	r2,-28(fp)
 8241f7c:	10000f26 	beq	r2,zero,8241fbc <ip_reasm_process_subsequent_fragments+0x3c4>
            {
            /* an error return is due to a bad IRE pointer, which ip_reasm_mark_compact_rfq () logs */
            LOCK_NET_RESOURCE (FREEQ_RESID);
 8241f80:	01000084 	movi	r4,2
 8241f84:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
            pk_free (p);
 8241f88:	e13ffe17 	ldw	r4,-8(fp)
 8241f8c:	822cd3c0 	call	822cd3c <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241f90:	01000084 	movi	r4,2
 8241f94:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
            ++ip_mib.ipReasmFails;
 8241f98:	008209b4 	movhi	r2,2086
 8241f9c:	10ba6104 	addi	r2,r2,-5756
 8241fa0:	10800f17 	ldw	r2,60(r2)
 8241fa4:	10c00044 	addi	r3,r2,1
 8241fa8:	008209b4 	movhi	r2,2086
 8241fac:	10ba6104 	addi	r2,r2,-5756
 8241fb0:	10c00f15 	stw	r3,60(r2)
            return rc;
 8241fb4:	e0bff917 	ldw	r2,-28(fp)
 8241fb8:	00005606 	br	8242114 <ip_reasm_process_subsequent_fragments+0x51c>

   /* compute the total number of bytes queued in this IRE.  Note 
    * that the RHS has been updated to reflect the amount of "unique"
    * data in the just received fragment (the IP header has been dropped,
    * and perhaps additional duplicate data too (if present)) */
   irep->rcvd += (u_short) (p->nb_plen);
 8241fbc:	e0bfff17 	ldw	r2,-4(fp)
 8241fc0:	1080048b 	ldhu	r2,18(r2)
 8241fc4:	e0fffe17 	ldw	r3,-8(fp)
 8241fc8:	18c00417 	ldw	r3,16(r3)
 8241fcc:	10c5883a 	add	r2,r2,r3
 8241fd0:	1007883a 	mov	r3,r2
 8241fd4:	e0bfff17 	ldw	r2,-4(fp)
 8241fd8:	10c0048d 	sth	r3,18(r2)
   ip_reasm_incr_mem_useage (p->nb_blen + ((new_rfqp == 0) ? 0 : (sizeof(RFQ))));
 8241fdc:	e0bffe17 	ldw	r2,-8(fp)
 8241fe0:	10800217 	ldw	r2,8(r2)
 8241fe4:	1007883a 	mov	r3,r2
 8241fe8:	e0bff517 	ldw	r2,-44(fp)
 8241fec:	1000021e 	bne	r2,zero,8241ff8 <ip_reasm_process_subsequent_fragments+0x400>
 8241ff0:	0005883a 	mov	r2,zero
 8241ff4:	00000106 	br	8241ffc <ip_reasm_process_subsequent_fragments+0x404>
 8241ff8:	00801904 	movi	r2,100
 8241ffc:	1885883a 	add	r2,r3,r2
 8242000:	10bfffcc 	andi	r2,r2,65535
 8242004:	1009883a 	mov	r4,r2
 8242008:	824121c0 	call	824121c <ip_reasm_incr_mem_useage>

   if (irep->length != 0)
 824200c:	e0bfff17 	ldw	r2,-4(fp)
 8242010:	1080040b 	ldhu	r2,16(r2)
 8242014:	10bfffcc 	andi	r2,r2,65535
 8242018:	10003d26 	beq	r2,zero,8242110 <ip_reasm_process_subsequent_fragments+0x518>
      {
      /* we know the total length of the original unfragmented datagram; 
       * let's check to see if we have all of the bytes... */
      if (irep->rcvd == irep->length)
 824201c:	e0bfff17 	ldw	r2,-4(fp)
 8242020:	10c0048b 	ldhu	r3,18(r2)
 8242024:	e0bfff17 	ldw	r2,-4(fp)
 8242028:	1080040b 	ldhu	r2,16(r2)
 824202c:	18ffffcc 	andi	r3,r3,65535
 8242030:	10bfffcc 	andi	r2,r2,65535
 8242034:	1880361e 	bne	r3,r2,8242110 <ip_reasm_process_subsequent_fragments+0x518>
          * Ensure that we allocate space for the data link header, IP header, 
          * and the payload of the original, unfragmented datagram.  We pick 
          * the data link layer and IP headers from the First Fragment (FF), 
          * but we need to adjust some of the fields in the IP header after 
          * reassembly is complete. */
         pip = (struct ip *) irep->l3_hdr;
 8242038:	e0bfff17 	ldw	r2,-4(fp)
 824203c:	10802017 	ldw	r2,128(r2)
 8242040:	e0bff615 	stw	r2,-40(fp)
         LOCK_NET_RESOURCE (FREEQ_RESID);
 8242044:	01000084 	movi	r4,2
 8242048:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
         reassy_pkt = pk_alloc (irep->length + (irep->l3_hdr - irep->l2_hdr) + ip_hlen (pip));
 824204c:	e0bfff17 	ldw	r2,-4(fp)
 8242050:	1080040b 	ldhu	r2,16(r2)
 8242054:	10ffffcc 	andi	r3,r2,65535
 8242058:	e0bfff17 	ldw	r2,-4(fp)
 824205c:	10802017 	ldw	r2,128(r2)
 8242060:	1009883a 	mov	r4,r2
 8242064:	e0bfff17 	ldw	r2,-4(fp)
 8242068:	10801f17 	ldw	r2,124(r2)
 824206c:	2085c83a 	sub	r2,r4,r2
 8242070:	1887883a 	add	r3,r3,r2
 8242074:	e0bff617 	ldw	r2,-40(fp)
 8242078:	10800003 	ldbu	r2,0(r2)
 824207c:	10803fcc 	andi	r2,r2,255
 8242080:	108003cc 	andi	r2,r2,15
 8242084:	1085883a 	add	r2,r2,r2
 8242088:	1085883a 	add	r2,r2,r2
 824208c:	1885883a 	add	r2,r3,r2
 8242090:	1009883a 	mov	r4,r2
 8242094:	822c9ec0 	call	822c9ec <pk_alloc>
 8242098:	e0bffa15 	stw	r2,-24(fp)
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 824209c:	01000084 	movi	r4,2
 82420a0:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         if (reassy_pkt == 0)
 82420a4:	e0bffa17 	ldw	r2,-24(fp)
 82420a8:	10000b1e 	bne	r2,zero,82420d8 <ip_reasm_process_subsequent_fragments+0x4e0>
            {
            /* the following call will delete all queued fragments, including
             * the currently received one */
            ip_reasm_delete_ire (irep);
 82420ac:	e13fff17 	ldw	r4,-4(fp)
 82420b0:	82425a40 	call	82425a4 <ip_reasm_delete_ire>
            ++ip_mib.ipReasmFails;
 82420b4:	008209b4 	movhi	r2,2086
 82420b8:	10ba6104 	addi	r2,r2,-5756
 82420bc:	10800f17 	ldw	r2,60(r2)
 82420c0:	10c00044 	addi	r3,r2,1
 82420c4:	008209b4 	movhi	r2,2086
 82420c8:	10ba6104 	addi	r2,r2,-5756
 82420cc:	10c00f15 	stw	r3,60(r2)
            return ENP_NOBUFFER;
 82420d0:	00bffac4 	movi	r2,-21
 82420d4:	00000f06 	br	8242114 <ip_reasm_process_subsequent_fragments+0x51c>
            }
         else
            {
            ip_reasm_copy_queued_fragments_into_reassy_buffer (reassy_pkt, irep);
 82420d8:	e17fff17 	ldw	r5,-4(fp)
 82420dc:	e13ffa17 	ldw	r4,-24(fp)
 82420e0:	82421800 	call	8242180 <ip_reasm_copy_queued_fragments_into_reassy_buffer>
            /* free the IRE structure (and its constituent elements) */
            ip_reasm_delete_ire (irep);
 82420e4:	e13fff17 	ldw	r4,-4(fp)
 82420e8:	82425a40 	call	82425a4 <ip_reasm_delete_ire>
            /* at this point, 'irep' is no longer a valid pointer, and so should 
             * not be referenced.  We're done, and we now pass the packet for 
             * demux'ing to the appropriate entity (e.g., UDP, TCP, etc.).  Note
             * that ip_demux () expects 'nb_prot' to point to the beginning of 
             * the IP header. */
            ++ip_mib.ipReasmOKs;
 82420ec:	008209b4 	movhi	r2,2086
 82420f0:	10ba6104 	addi	r2,r2,-5756
 82420f4:	10800e17 	ldw	r2,56(r2)
 82420f8:	10c00044 	addi	r3,r2,1
 82420fc:	008209b4 	movhi	r2,2086
 8242100:	10ba6104 	addi	r2,r2,-5756
 8242104:	10c00e15 	stw	r3,56(r2)
            ip_demux (reassy_pkt);
 8242108:	e13ffa17 	ldw	r4,-24(fp)
 824210c:	824357c0 	call	824357c <ip_demux>
      {
      /* we haven't received the LF (so we don't know the total amount of data in 
       * the original, unfragmented datagram), and therefore reassembly can't complete yet */
      }

   return IPREASM_OK;
 8242110:	0005883a 	mov	r2,zero
}
 8242114:	e037883a 	mov	sp,fp
 8242118:	dfc00117 	ldw	ra,4(sp)
 824211c:	df000017 	ldw	fp,0(sp)
 8242120:	dec00204 	addi	sp,sp,8
 8242124:	f800283a 	ret

08242128 <ip_reasm_find_ire>:
OUTPUT: This function returns a IPREASM_TRUE if the IRE exists in the master 
IRE list; otherwise, it returns a IPREASM_FALSE.
*/

u_char ip_reasm_find_ire (IREP irep)
{
 8242128:	defffd04 	addi	sp,sp,-12
 824212c:	df000215 	stw	fp,8(sp)
 8242130:	df000204 	addi	fp,sp,8
 8242134:	e13fff15 	stw	r4,-4(fp)
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8242138:	d0a0c817 	ldw	r2,-31968(gp)
 824213c:	e0bffe15 	stw	r2,-8(fp)
 8242140:	00000806 	br	8242164 <ip_reasm_find_ire+0x3c>
      {
      if (tmpp == irep) 
 8242144:	e0fffe17 	ldw	r3,-8(fp)
 8242148:	e0bfff17 	ldw	r2,-4(fp)
 824214c:	1880021e 	bne	r3,r2,8242158 <ip_reasm_find_ire+0x30>
         {
         return IPREASM_TRUE;
 8242150:	00800044 	movi	r2,1
 8242154:	00000606 	br	8242170 <ip_reasm_find_ire+0x48>
u_char ip_reasm_find_ire (IREP irep)
{
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8242158:	e0bffe17 	ldw	r2,-8(fp)
 824215c:	10800017 	ldw	r2,0(r2)
 8242160:	e0bffe15 	stw	r2,-8(fp)
 8242164:	e0bffe17 	ldw	r2,-8(fp)
 8242168:	103ff61e 	bne	r2,zero,8242144 <ip_reasm_find_ire+0x1c>
         {
         return IPREASM_TRUE;
         }
      }

   return IPREASM_FALSE;
 824216c:	0005883a 	mov	r2,zero
}
 8242170:	e037883a 	mov	sp,fp
 8242174:	df000017 	ldw	fp,0(sp)
 8242178:	dec00104 	addi	sp,sp,4
 824217c:	f800283a 	ret

08242180 <ip_reasm_copy_queued_fragments_into_reassy_buffer>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_copy_queued_fragments_into_reassy_buffer (PACKET reassy_pkt, IREP irep)
{
 8242180:	defff504 	addi	sp,sp,-44
 8242184:	dfc00a15 	stw	ra,40(sp)
 8242188:	df000915 	stw	fp,36(sp)
 824218c:	df000904 	addi	fp,sp,36
 8242190:	e13ffe15 	stw	r4,-8(fp)
 8242194:	e17fff15 	stw	r5,-4(fp)
   RFQP rfqp;
   u_short i;
   PACKET p;
   u_char iphlen;
   char * writep;
   PACKET sav_pkt = 0;
 8242198:	e03ff915 	stw	zero,-28(fp)

   pip = (struct ip *) irep->l3_hdr;
 824219c:	e0bfff17 	ldw	r2,-4(fp)
 82421a0:	10802017 	ldw	r2,128(r2)
 82421a4:	e0bffa15 	stw	r2,-24(fp)
   iphlen = ip_hlen (pip);
 82421a8:	e0bffa17 	ldw	r2,-24(fp)
 82421ac:	10800003 	ldbu	r2,0(r2)
 82421b0:	108003cc 	andi	r2,r2,15
 82421b4:	1085883a 	add	r2,r2,r2
 82421b8:	1085883a 	add	r2,r2,r2
 82421bc:	e0bffb05 	stb	r2,-20(fp)

   /* copy the data link and IP layer headers into place.  These headers are 
    * from the First Fragment (FF). */
   offset = (u_char) ((irep->l3_hdr - irep->l2_hdr) + iphlen);
 82421c0:	e0bfff17 	ldw	r2,-4(fp)
 82421c4:	10802017 	ldw	r2,128(r2)
 82421c8:	1007883a 	mov	r3,r2
 82421cc:	e0bfff17 	ldw	r2,-4(fp)
 82421d0:	10801f17 	ldw	r2,124(r2)
 82421d4:	1885c83a 	sub	r2,r3,r2
 82421d8:	1007883a 	mov	r3,r2
 82421dc:	e0bffb03 	ldbu	r2,-20(fp)
 82421e0:	1885883a 	add	r2,r3,r2
 82421e4:	e0bffb45 	stb	r2,-19(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);
 82421e8:	e0bffe17 	ldw	r2,-8(fp)
 82421ec:	10c00117 	ldw	r3,4(r2)
 82421f0:	e0bfff17 	ldw	r2,-4(fp)
 82421f4:	10801f17 	ldw	r2,124(r2)
 82421f8:	e13ffb43 	ldbu	r4,-19(fp)
 82421fc:	200d883a 	mov	r6,r4
 8242200:	100b883a 	mov	r5,r2
 8242204:	1809883a 	mov	r4,r3
 8242208:	8202f100 	call	8202f10 <memcpy>

   rfqp = &(irep->rfq);
 824220c:	e0bfff17 	ldw	r2,-4(fp)
 8242210:	10800604 	addi	r2,r2,24
 8242214:	e0bff715 	stw	r2,-36(fp)
   writep = reassy_pkt->nb_buff + offset;
 8242218:	e0bffe17 	ldw	r2,-8(fp)
 824221c:	10c00117 	ldw	r3,4(r2)
 8242220:	e0bffb43 	ldbu	r2,-19(fp)
 8242224:	1885883a 	add	r2,r3,r2
 8242228:	e0bffc15 	stw	r2,-16(fp)

   while (rfqp)
 824222c:	00004506 	br	8242344 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1c4>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8242230:	e03ff80d 	sth	zero,-32(fp)
 8242234:	00003b06 	br	8242324 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1a4>
         {
         if ((p = rfqp->bufp [i]) != 0)
 8242238:	e0bff80b 	ldhu	r2,-32(fp)
 824223c:	e0fff717 	ldw	r3,-36(fp)
 8242240:	10800044 	addi	r2,r2,1
 8242244:	1085883a 	add	r2,r2,r2
 8242248:	1085883a 	add	r2,r2,r2
 824224c:	1885883a 	add	r2,r3,r2
 8242250:	10800017 	ldw	r2,0(r2)
 8242254:	e0bffd15 	stw	r2,-12(fp)
 8242258:	e0bffd17 	ldw	r2,-12(fp)
 824225c:	10002926 	beq	r2,zero,8242304 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x184>
            {
            /* note that rfqp->frag_offset[i] is the true value of the offset field, 
             * and does not require any scaling (like the Fragment Offset field in 
             * the IP header) */
            MEMCPY((writep + rfqp->frag_offset[i]), p->nb_prot, p->nb_plen);
 8242260:	e0bff80b 	ldhu	r2,-32(fp)
 8242264:	e0fff717 	ldw	r3,-36(fp)
 8242268:	10800884 	addi	r2,r2,34
 824226c:	1085883a 	add	r2,r2,r2
 8242270:	1885883a 	add	r2,r3,r2
 8242274:	1080000b 	ldhu	r2,0(r2)
 8242278:	10bfffcc 	andi	r2,r2,65535
 824227c:	e0fffc17 	ldw	r3,-16(fp)
 8242280:	1887883a 	add	r3,r3,r2
 8242284:	e0bffd17 	ldw	r2,-12(fp)
 8242288:	11000317 	ldw	r4,12(r2)
 824228c:	e0bffd17 	ldw	r2,-12(fp)
 8242290:	10800417 	ldw	r2,16(r2)
 8242294:	100d883a 	mov	r6,r2
 8242298:	200b883a 	mov	r5,r4
 824229c:	1809883a 	mov	r4,r3
 82422a0:	8202f100 	call	8202f10 <memcpy>
            /* free fragment after we've copied data out from it (unless we need to
             * save it so that we can copy some fields from it later (after exiting 
             * from the loop)) */
            if (!sav_pkt) sav_pkt = p;
 82422a4:	e0bff917 	ldw	r2,-28(fp)
 82422a8:	1000031e 	bne	r2,zero,82422b8 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x138>
 82422ac:	e0bffd17 	ldw	r2,-12(fp)
 82422b0:	e0bff915 	stw	r2,-28(fp)
 82422b4:	00000b06 	br	82422e4 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x164>
            else
               {
               ip_reasm_decr_mem_useage (p->nb_blen);
 82422b8:	e0bffd17 	ldw	r2,-12(fp)
 82422bc:	10800217 	ldw	r2,8(r2)
 82422c0:	10bfffcc 	andi	r2,r2,65535
 82422c4:	1009883a 	mov	r4,r2
 82422c8:	82412bc0 	call	82412bc <ip_reasm_decr_mem_useage>
               LOCK_NET_RESOURCE (FREEQ_RESID);
 82422cc:	01000084 	movi	r4,2
 82422d0:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
               pk_free (p);
 82422d4:	e13ffd17 	ldw	r4,-12(fp)
 82422d8:	822cd3c0 	call	822cd3c <pk_free>
               UNLOCK_NET_RESOURCE (FREEQ_RESID);
 82422dc:	01000084 	movi	r4,2
 82422e0:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
               }
            /* since we're done with the packet, mark slot as unused */
            rfqp->bufp [i] = 0;
 82422e4:	e0bff80b 	ldhu	r2,-32(fp)
 82422e8:	e0fff717 	ldw	r3,-36(fp)
 82422ec:	10800044 	addi	r2,r2,1
 82422f0:	1085883a 	add	r2,r2,r2
 82422f4:	1085883a 	add	r2,r2,r2
 82422f8:	1885883a 	add	r2,r3,r2
 82422fc:	10000015 	stw	zero,0(r2)
 8242300:	00000506 	br	8242318 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x198>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 8242304:	e0bfff17 	ldw	r2,-4(fp)
 8242308:	10802103 	ldbu	r2,132(r2)
 824230c:	10803fcc 	andi	r2,r2,255
 8242310:	1080004c 	andi	r2,r2,1
 8242314:	1000071e 	bne	r2,zero,8242334 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1b4>
   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8242318:	e0bff80b 	ldhu	r2,-32(fp)
 824231c:	10800044 	addi	r2,r2,1
 8242320:	e0bff80d 	sth	r2,-32(fp)
 8242324:	e0bff80b 	ldhu	r2,-32(fp)
 8242328:	10800430 	cmpltui	r2,r2,16
 824232c:	103fc21e 	bne	r2,zero,8242238 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xb8>
 8242330:	00000106 	br	8242338 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1b8>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
               {
               break;
 8242334:	0001883a 	nop
               }
            }
          }

      rfqp = rfqp->next;
 8242338:	e0bff717 	ldw	r2,-36(fp)
 824233c:	10800017 	ldw	r2,0(r2)
 8242340:	e0bff715 	stw	r2,-36(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);

   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
 8242344:	e0bff717 	ldw	r2,-36(fp)
 8242348:	103fb91e 	bne	r2,zero,8242230 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xb0>
      }

   /* update various fields in the reassembled packet.  Some fields will be 
    * picked from one of the constituent fragments (sav_pkt) which hasn't
    * been deleted yet. */
   reassy_pkt->nb_prot = reassy_pkt->nb_buff + (irep->l3_hdr - irep->l2_hdr);
 824234c:	e0bffe17 	ldw	r2,-8(fp)
 8242350:	10800117 	ldw	r2,4(r2)
 8242354:	e0ffff17 	ldw	r3,-4(fp)
 8242358:	18c02017 	ldw	r3,128(r3)
 824235c:	1809883a 	mov	r4,r3
 8242360:	e0ffff17 	ldw	r3,-4(fp)
 8242364:	18c01f17 	ldw	r3,124(r3)
 8242368:	20c7c83a 	sub	r3,r4,r3
 824236c:	10c7883a 	add	r3,r2,r3
 8242370:	e0bffe17 	ldw	r2,-8(fp)
 8242374:	10c00315 	stw	r3,12(r2)
   reassy_pkt->nb_plen = irep->length + iphlen;
 8242378:	e0bfff17 	ldw	r2,-4(fp)
 824237c:	1080040b 	ldhu	r2,16(r2)
 8242380:	10ffffcc 	andi	r3,r2,65535
 8242384:	e0bffb03 	ldbu	r2,-20(fp)
 8242388:	1885883a 	add	r2,r3,r2
 824238c:	1007883a 	mov	r3,r2
 8242390:	e0bffe17 	ldw	r2,-8(fp)
 8242394:	10c00415 	stw	r3,16(r2)
   reassy_pkt->nb_tstamp = cticks;
 8242398:	d0a0a817 	ldw	r2,-32096(gp)
 824239c:	1007883a 	mov	r3,r2
 82423a0:	e0bffe17 	ldw	r2,-8(fp)
 82423a4:	10c00515 	stw	r3,20(r2)
   reassy_pkt->flags |= ((sav_pkt->flags) & (PKF_BCAST | PKF_MCAST));
 82423a8:	e0bffe17 	ldw	r2,-8(fp)
 82423ac:	10c00a17 	ldw	r3,40(r2)
 82423b0:	e0bff917 	ldw	r2,-28(fp)
 82423b4:	10800a17 	ldw	r2,40(r2)
 82423b8:	108000cc 	andi	r2,r2,3
 82423bc:	1886b03a 	or	r3,r3,r2
 82423c0:	e0bffe17 	ldw	r2,-8(fp)
 82423c4:	10c00a15 	stw	r3,40(r2)
   reassy_pkt->net = sav_pkt->net;
 82423c8:	e0bff917 	ldw	r2,-28(fp)
 82423cc:	10c00617 	ldw	r3,24(r2)
 82423d0:	e0bffe17 	ldw	r2,-8(fp)
 82423d4:	10c00615 	stw	r3,24(r2)
   reassy_pkt->type = sav_pkt->type;
 82423d8:	e0bff917 	ldw	r2,-28(fp)
 82423dc:	10c0080b 	ldhu	r3,32(r2)
 82423e0:	e0bffe17 	ldw	r2,-8(fp)
 82423e4:	10c0080d 	sth	r3,32(r2)
   /* fhost is set by ip_demux () before handing off to the packet to its 
    * intended destination (protocol) */

   /* free the saved packet too, since we don't need it anymore */
   ip_reasm_decr_mem_useage (sav_pkt->nb_blen);
 82423e8:	e0bff917 	ldw	r2,-28(fp)
 82423ec:	10800217 	ldw	r2,8(r2)
 82423f0:	10bfffcc 	andi	r2,r2,65535
 82423f4:	1009883a 	mov	r4,r2
 82423f8:	82412bc0 	call	82412bc <ip_reasm_decr_mem_useage>
   LOCK_NET_RESOURCE (FREEQ_RESID);
 82423fc:	01000084 	movi	r4,2
 8242400:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   pk_free (sav_pkt);
 8242404:	e13ff917 	ldw	r4,-28(fp)
 8242408:	822cd3c0 	call	822cd3c <pk_free>
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 824240c:	01000084 	movi	r4,2
 8242410:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>

   /* after the reassembly is complete, we update the following fields in
    * the IP header: Total Length, Flags/Fragment Offset, header checksum */
   pip = ip_head(reassy_pkt);
 8242414:	e0bffe17 	ldw	r2,-8(fp)
 8242418:	10800317 	ldw	r2,12(r2)
 824241c:	e0bffa15 	stw	r2,-24(fp)
   pip->ip_len = htons(reassy_pkt->nb_plen);
 8242420:	e0bffe17 	ldw	r2,-8(fp)
 8242424:	10800417 	ldw	r2,16(r2)
 8242428:	1004d23a 	srli	r2,r2,8
 824242c:	10803fcc 	andi	r2,r2,255
 8242430:	1007883a 	mov	r3,r2
 8242434:	e0bffe17 	ldw	r2,-8(fp)
 8242438:	10800417 	ldw	r2,16(r2)
 824243c:	1004923a 	slli	r2,r2,8
 8242440:	1884b03a 	or	r2,r3,r2
 8242444:	1007883a 	mov	r3,r2
 8242448:	e0bffa17 	ldw	r2,-24(fp)
 824244c:	10c0008d 	sth	r3,2(r2)
   /* turn off More Fragments (MF) bit; the DF bit stays unchanged */
   pip->ip_flgs_foff &= htons(~((u_short) IP_FLG_MF));
 8242450:	e0bffa17 	ldw	r2,-24(fp)
 8242454:	10c0018b 	ldhu	r3,6(r2)
 8242458:	00bff7c4 	movi	r2,-33
 824245c:	1884703a 	and	r2,r3,r2
 8242460:	1007883a 	mov	r3,r2
 8242464:	e0bffa17 	ldw	r2,-24(fp)
 8242468:	10c0018d 	sth	r3,6(r2)
   /* clear the Fragment Offset bits */
   pip->ip_flgs_foff &= htons(~((u_short) IP_EXTRACT_FOFF)); 
 824246c:	e0bffa17 	ldw	r2,-24(fp)
 8242470:	1080018b 	ldhu	r2,6(r2)
 8242474:	1080380c 	andi	r2,r2,224
 8242478:	1007883a 	mov	r3,r2
 824247c:	e0bffa17 	ldw	r2,-24(fp)
 8242480:	10c0018d 	sth	r3,6(r2)
   /* the following isn't really required, and can be removed */
   pip->ip_chksum = IPXSUM;
 8242484:	e0bffa17 	ldw	r2,-24(fp)
 8242488:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum (pip, (iphlen/2));
 824248c:	e0bffb03 	ldbu	r2,-20(fp)
 8242490:	1004d07a 	srli	r2,r2,1
 8242494:	10803fcc 	andi	r2,r2,255
 8242498:	100b883a 	mov	r5,r2
 824249c:	e13ffa17 	ldw	r4,-24(fp)
 82424a0:	82287b40 	call	82287b4 <cksum>
 82424a4:	0084303a 	nor	r2,zero,r2
 82424a8:	1007883a 	mov	r3,r2
 82424ac:	e0bffa17 	ldw	r2,-24(fp)
 82424b0:	10c0028d 	sth	r3,10(r2)

   return IPREASM_OK;
 82424b4:	0005883a 	mov	r2,zero
}
 82424b8:	e037883a 	mov	sp,fp
 82424bc:	dfc00117 	ldw	ra,4(sp)
 82424c0:	df000017 	ldw	fp,0(sp)
 82424c4:	dec00204 	addi	sp,sp,8
 82424c8:	f800283a 	ret

082424cc <ip_reasm_process_timer_tick>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_process_timer_tick (void)
{
 82424cc:	defffc04 	addi	sp,sp,-16
 82424d0:	dfc00315 	stw	ra,12(sp)
 82424d4:	df000215 	stw	fp,8(sp)
 82424d8:	df000204 	addi	fp,sp,8
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 82424dc:	0009883a 	mov	r4,zero
 82424e0:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 82424e4:	d0a0c817 	ldw	r2,-31968(gp)
 82424e8:	e0bffe15 	stw	r2,-8(fp)
 82424ec:	00002006 	br	8242570 <ip_reasm_process_timer_tick+0xa4>
      {
      /* save the next pointer for the IRE that may be deleted */
      nxt_tmpp = tmpp->next;
 82424f0:	e0bffe17 	ldw	r2,-8(fp)
 82424f4:	10800017 	ldw	r2,0(r2)
 82424f8:	e0bfff15 	stw	r2,-4(fp)
      ++tmpp->age;
 82424fc:	e0bffe17 	ldw	r2,-8(fp)
 8242500:	10800517 	ldw	r2,20(r2)
 8242504:	10c00044 	addi	r3,r2,1
 8242508:	e0bffe17 	ldw	r2,-8(fp)
 824250c:	10c00515 	stw	r3,20(r2)
      /* check to see if this entry has reached its max age (expired)? */
      if (tmpp->age == IRE_TMO)
 8242510:	e0bffe17 	ldw	r2,-8(fp)
 8242514:	10800517 	ldw	r2,20(r2)
 8242518:	10801e18 	cmpnei	r2,r2,120
 824251c:	1000121e 	bne	r2,zero,8242568 <ip_reasm_process_timer_tick+0x9c>
         {
         /* it has...and therefore must be deleted. */
         ++ire_stats.ire_timed_out;
 8242520:	008209b4 	movhi	r2,2086
 8242524:	10ba7504 	addi	r2,r2,-5676
 8242528:	10800117 	ldw	r2,4(r2)
 824252c:	10c00044 	addi	r3,r2,1
 8242530:	008209b4 	movhi	r2,2086
 8242534:	10ba7504 	addi	r2,r2,-5676
 8242538:	10c00115 	stw	r3,4(r2)
#ifdef FULL_ICMP
         /* send ICMP Time Exceeded message with code 1 ("fragment reassembly time exceeded") */
         ip_reasm_send_icmp_timex (tmpp);
 824253c:	e13ffe17 	ldw	r4,-8(fp)
 8242540:	8242be00 	call	8242be0 <ip_reasm_send_icmp_timex>
#endif
         ip_reasm_delete_ire (tmpp);
 8242544:	e13ffe17 	ldw	r4,-8(fp)
 8242548:	82425a40 	call	82425a4 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 824254c:	008209b4 	movhi	r2,2086
 8242550:	10ba6104 	addi	r2,r2,-5756
 8242554:	10800f17 	ldw	r2,60(r2)
 8242558:	10c00044 	addi	r3,r2,1
 824255c:	008209b4 	movhi	r2,2086
 8242560:	10ba6104 	addi	r2,r2,-5756
 8242564:	10c00f15 	stw	r3,60(r2)
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 8242568:	e0bfff17 	ldw	r2,-4(fp)
 824256c:	e0bffe15 	stw	r2,-8(fp)
 8242570:	e0bffe17 	ldw	r2,-8(fp)
 8242574:	103fde1e 	bne	r2,zero,82424f0 <ip_reasm_process_timer_tick+0x24>
         ++ip_mib.ipReasmFails;
         }
      }

   /* set the time for the next invocation of this routine (one second later) */
   ire_cticks = cticks + TPS;
 8242578:	d0a0a817 	ldw	r2,-32096(gp)
 824257c:	10801904 	addi	r2,r2,100
 8242580:	d0a0c915 	stw	r2,-31964(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 8242584:	0009883a 	mov	r4,zero
 8242588:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>

   return IPREASM_OK;
 824258c:	0005883a 	mov	r2,zero
}
 8242590:	e037883a 	mov	sp,fp
 8242594:	dfc00117 	ldw	ra,4(sp)
 8242598:	df000017 	ldw	fp,0(sp)
 824259c:	dec00204 	addi	sp,sp,8
 82425a0:	f800283a 	ret

082425a4 <ip_reasm_delete_ire>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in the 
master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_delete_ire (IREP irep)
{
 82425a4:	defff604 	addi	sp,sp,-40
 82425a8:	dfc00915 	stw	ra,36(sp)
 82425ac:	df000815 	stw	fp,32(sp)
 82425b0:	df000804 	addi	fp,sp,32
 82425b4:	e13fff15 	stw	r4,-4(fp)
   RFQP rfqp, first_rfqp, prev_rfqp;
   u_short i;
   PACKET p;
   IREP tmpp;
   IREP prev_tmpp = 0;
 82425b8:	e03ffb15 	stw	zero,-20(fp)

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 82425bc:	d0a0c817 	ldw	r2,-31968(gp)
 82425c0:	e0bffa15 	stw	r2,-24(fp)
 82425c4:	00001406 	br	8242618 <ip_reasm_delete_ire+0x74>
      {
      if (tmpp == irep) 
 82425c8:	e0fffa17 	ldw	r3,-24(fp)
 82425cc:	e0bfff17 	ldw	r2,-4(fp)
 82425d0:	18800c1e 	bne	r3,r2,8242604 <ip_reasm_delete_ire+0x60>
         {
         /* update the head pointer to the list */
         if (tmpp == h_ireq) h_ireq = irep->next;
 82425d4:	d0a0c817 	ldw	r2,-31968(gp)
 82425d8:	e0fffa17 	ldw	r3,-24(fp)
 82425dc:	1880041e 	bne	r3,r2,82425f0 <ip_reasm_delete_ire+0x4c>
 82425e0:	e0bfff17 	ldw	r2,-4(fp)
 82425e4:	10800017 	ldw	r2,0(r2)
 82425e8:	d0a0c815 	stw	r2,-31968(gp)
         else prev_tmpp->next = irep->next;
         break;
 82425ec:	00000c06 	br	8242620 <ip_reasm_delete_ire+0x7c>
      {
      if (tmpp == irep) 
         {
         /* update the head pointer to the list */
         if (tmpp == h_ireq) h_ireq = irep->next;
         else prev_tmpp->next = irep->next;
 82425f0:	e0bfff17 	ldw	r2,-4(fp)
 82425f4:	10c00017 	ldw	r3,0(r2)
 82425f8:	e0bffb17 	ldw	r2,-20(fp)
 82425fc:	10c00015 	stw	r3,0(r2)
         break;
 8242600:	00000706 	br	8242620 <ip_reasm_delete_ire+0x7c>
         }
      prev_tmpp = tmpp;
 8242604:	e0bffa17 	ldw	r2,-24(fp)
 8242608:	e0bffb15 	stw	r2,-20(fp)
   IREP tmpp;
   IREP prev_tmpp = 0;

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 824260c:	e0bffa17 	ldw	r2,-24(fp)
 8242610:	10800017 	ldw	r2,0(r2)
 8242614:	e0bffa15 	stw	r2,-24(fp)
 8242618:	e0bffa17 	ldw	r2,-24(fp)
 824261c:	103fea1e 	bne	r2,zero,82425c8 <ip_reasm_delete_ire+0x24>
      prev_tmpp = tmpp;
      }

   /* if the IRE entry does not exist in the master table, return an error 
    * to the caller */
   if (!tmpp)
 8242620:	e0bffa17 	ldw	r2,-24(fp)
 8242624:	1000091e 	bne	r2,zero,824264c <ip_reasm_delete_ire+0xa8>
      {
      ++ire_stats.bad_irep;
 8242628:	008209b4 	movhi	r2,2086
 824262c:	10ba7504 	addi	r2,r2,-5676
 8242630:	10800017 	ldw	r2,0(r2)
 8242634:	10c00044 	addi	r3,r2,1
 8242638:	008209b4 	movhi	r2,2086
 824263c:	10ba7504 	addi	r2,r2,-5676
 8242640:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 8242644:	00bffd84 	movi	r2,-10
 8242648:	00003e06 	br	8242744 <ip_reasm_delete_ire+0x1a0>
      }

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);
 824264c:	e0bfff17 	ldw	r2,-4(fp)
 8242650:	10800604 	addi	r2,r2,24
 8242654:	e0bffc15 	stw	r2,-16(fp)
 8242658:	e0bffc17 	ldw	r2,-16(fp)
 824265c:	e0bff815 	stw	r2,-32(fp)

   while (rfqp)
 8242660:	00003106 	br	8242728 <ip_reasm_delete_ire+0x184>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8242664:	e03ff90d 	sth	zero,-28(fp)
 8242668:	00001e06 	br	82426e4 <ip_reasm_delete_ire+0x140>
         {
         if ((p = rfqp->bufp [i]) != 0)
 824266c:	e0bff90b 	ldhu	r2,-28(fp)
 8242670:	e0fff817 	ldw	r3,-32(fp)
 8242674:	10800044 	addi	r2,r2,1
 8242678:	1085883a 	add	r2,r2,r2
 824267c:	1085883a 	add	r2,r2,r2
 8242680:	1885883a 	add	r2,r3,r2
 8242684:	10800017 	ldw	r2,0(r2)
 8242688:	e0bffd15 	stw	r2,-12(fp)
 824268c:	e0bffd17 	ldw	r2,-12(fp)
 8242690:	10000c26 	beq	r2,zero,82426c4 <ip_reasm_delete_ire+0x120>
            {
            ip_reasm_decr_mem_useage (p->nb_blen);
 8242694:	e0bffd17 	ldw	r2,-12(fp)
 8242698:	10800217 	ldw	r2,8(r2)
 824269c:	10bfffcc 	andi	r2,r2,65535
 82426a0:	1009883a 	mov	r4,r2
 82426a4:	82412bc0 	call	82412bc <ip_reasm_decr_mem_useage>
            LOCK_NET_RESOURCE (FREEQ_RESID);
 82426a8:	01000084 	movi	r4,2
 82426ac:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
            pk_free (p);
 82426b0:	e13ffd17 	ldw	r4,-12(fp)
 82426b4:	822cd3c0 	call	822cd3c <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);               
 82426b8:	01000084 	movi	r4,2
 82426bc:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
 82426c0:	00000506 	br	82426d8 <ip_reasm_delete_ire+0x134>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 82426c4:	e0bfff17 	ldw	r2,-4(fp)
 82426c8:	10802103 	ldbu	r2,132(r2)
 82426cc:	10803fcc 	andi	r2,r2,255
 82426d0:	1080004c 	andi	r2,r2,1
 82426d4:	1000071e 	bne	r2,zero,82426f4 <ip_reasm_delete_ire+0x150>
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 82426d8:	e0bff90b 	ldhu	r2,-28(fp)
 82426dc:	10800044 	addi	r2,r2,1
 82426e0:	e0bff90d 	sth	r2,-28(fp)
 82426e4:	e0bff90b 	ldhu	r2,-28(fp)
 82426e8:	10800430 	cmpltui	r2,r2,16
 82426ec:	103fdf1e 	bne	r2,zero,824266c <ip_reasm_delete_ire+0xc8>
 82426f0:	00000106 	br	82426f8 <ip_reasm_delete_ire+0x154>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
               {
               break;
 82426f4:	0001883a 	nop
               }
            }
          }

       prev_rfqp = rfqp;
 82426f8:	e0bff817 	ldw	r2,-32(fp)
 82426fc:	e0bffe15 	stw	r2,-8(fp)
       rfqp = rfqp->next;
 8242700:	e0bff817 	ldw	r2,-32(fp)
 8242704:	10800017 	ldw	r2,0(r2)
 8242708:	e0bff815 	stw	r2,-32(fp)
       /* the first RFQ is statically allocated, and cannot be freed */
       if (prev_rfqp != first_rfqp)
 824270c:	e0fffe17 	ldw	r3,-8(fp)
 8242710:	e0bffc17 	ldw	r2,-16(fp)
 8242714:	18800426 	beq	r3,r2,8242728 <ip_reasm_delete_ire+0x184>
          {
          ip_reasm_decr_mem_useage (sizeof(RFQ));
 8242718:	01001904 	movi	r4,100
 824271c:	82412bc0 	call	82412bc <ip_reasm_decr_mem_useage>
          IPR_FREE (prev_rfqp);
 8242720:	e13ffe17 	ldw	r4,-8(fp)
 8242724:	822e1a00 	call	822e1a0 <npfree>

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
 8242728:	e0bff817 	ldw	r2,-32(fp)
 824272c:	103fcd1e 	bne	r2,zero,8242664 <ip_reasm_delete_ire+0xc0>
          IPR_FREE (prev_rfqp);
          }
      }

   /* now free the parent entity */
   ip_reasm_decr_mem_useage (sizeof(IRE));
 8242730:	01002204 	movi	r4,136
 8242734:	82412bc0 	call	82412bc <ip_reasm_decr_mem_useage>
   IPR_FREE (irep);
 8242738:	e13fff17 	ldw	r4,-4(fp)
 824273c:	822e1a00 	call	822e1a0 <npfree>

   return IPREASM_OK;
 8242740:	0005883a 	mov	r2,zero
}
 8242744:	e037883a 	mov	sp,fp
 8242748:	dfc00117 	ldw	ra,4(sp)
 824274c:	df000017 	ldw	fp,0(sp)
 8242750:	dec00204 	addi	sp,sp,8
 8242754:	f800283a 	ret

08242758 <ip_reasm_mark_compact_rfq>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in 
the master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_mark_compact_rfq (IREP irep)
{
 8242758:	defffb04 	addi	sp,sp,-20
 824275c:	dfc00415 	stw	ra,16(sp)
 8242760:	df000315 	stw	fp,12(sp)
 8242764:	df000304 	addi	fp,sp,12
 8242768:	e13fff15 	stw	r4,-4(fp)
   RFQP rfqp;
   u_short i;
   u_char empty_slot_discovered = IPREASM_FALSE;
 824276c:	e03ffe85 	stb	zero,-6(fp)
   u_char compact = IPREASM_TRUE;
 8242770:	00800044 	movi	r2,1
 8242774:	e0bffec5 	stb	r2,-5(fp)

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 8242778:	e13fff17 	ldw	r4,-4(fp)
 824277c:	82421280 	call	8242128 <ip_reasm_find_ire>
 8242780:	10803fcc 	andi	r2,r2,255
 8242784:	10800060 	cmpeqi	r2,r2,1
 8242788:	1000091e 	bne	r2,zero,82427b0 <ip_reasm_mark_compact_rfq+0x58>
   {
      ++ire_stats.bad_irep;
 824278c:	008209b4 	movhi	r2,2086
 8242790:	10ba7504 	addi	r2,r2,-5676
 8242794:	10800017 	ldw	r2,0(r2)
 8242798:	10c00044 	addi	r3,r2,1
 824279c:	008209b4 	movhi	r2,2086
 82427a0:	10ba7504 	addi	r2,r2,-5676
 82427a4:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 82427a8:	00bffd84 	movi	r2,-10
 82427ac:	00003106 	br	8242874 <ip_reasm_mark_compact_rfq+0x11c>
   }

   rfqp = &(irep->rfq);
 82427b0:	e0bfff17 	ldw	r2,-4(fp)
 82427b4:	10800604 	addi	r2,r2,24
 82427b8:	e0bffd15 	stw	r2,-12(fp)

   while (rfqp)
 82427bc:	00001a06 	br	8242828 <ip_reasm_mark_compact_rfq+0xd0>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 82427c0:	e03ffe0d 	sth	zero,-8(fp)
 82427c4:	00001206 	br	8242810 <ip_reasm_mark_compact_rfq+0xb8>
         {
         if (rfqp->bufp [i] == 0)
 82427c8:	e0bffe0b 	ldhu	r2,-8(fp)
 82427cc:	e0fffd17 	ldw	r3,-12(fp)
 82427d0:	10800044 	addi	r2,r2,1
 82427d4:	1085883a 	add	r2,r2,r2
 82427d8:	1085883a 	add	r2,r2,r2
 82427dc:	1885883a 	add	r2,r3,r2
 82427e0:	10800017 	ldw	r2,0(r2)
 82427e4:	1000031e 	bne	r2,zero,82427f4 <ip_reasm_mark_compact_rfq+0x9c>
            {            
            empty_slot_discovered = IPREASM_TRUE;
 82427e8:	00800044 	movi	r2,1
 82427ec:	e0bffe85 	stb	r2,-6(fp)
 82427f0:	00000406 	br	8242804 <ip_reasm_mark_compact_rfq+0xac>
            }
         else
            {
            if (empty_slot_discovered) 
 82427f4:	e0bffe83 	ldbu	r2,-6(fp)
 82427f8:	10000226 	beq	r2,zero,8242804 <ip_reasm_mark_compact_rfq+0xac>
               {
               compact = IPREASM_FALSE;
 82427fc:	e03ffec5 	stb	zero,-5(fp)
               break;
 8242800:	00000606 	br	824281c <ip_reasm_mark_compact_rfq+0xc4>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8242804:	e0bffe0b 	ldhu	r2,-8(fp)
 8242808:	10800044 	addi	r2,r2,1
 824280c:	e0bffe0d 	sth	r2,-8(fp)
 8242810:	e0bffe0b 	ldhu	r2,-8(fp)
 8242814:	10800430 	cmpltui	r2,r2,16
 8242818:	103feb1e 	bne	r2,zero,82427c8 <ip_reasm_mark_compact_rfq+0x70>
               compact = IPREASM_FALSE;
               break;
               }
            }
          }
       rfqp = rfqp->next;
 824281c:	e0bffd17 	ldw	r2,-12(fp)
 8242820:	10800017 	ldw	r2,0(r2)
 8242824:	e0bffd15 	stw	r2,-12(fp)
      return ENP_PARAM;
   }

   rfqp = &(irep->rfq);

   while (rfqp)
 8242828:	e0bffd17 	ldw	r2,-12(fp)
 824282c:	103fe41e 	bne	r2,zero,82427c0 <ip_reasm_mark_compact_rfq+0x68>
            }
          }
       rfqp = rfqp->next;
      }

   if (compact) 
 8242830:	e0bffec3 	ldbu	r2,-5(fp)
 8242834:	10000726 	beq	r2,zero,8242854 <ip_reasm_mark_compact_rfq+0xfc>
      {
      irep->flags |= IPR_RFQ_COMPACT;
 8242838:	e0bfff17 	ldw	r2,-4(fp)
 824283c:	10802103 	ldbu	r2,132(r2)
 8242840:	10800054 	ori	r2,r2,1
 8242844:	1007883a 	mov	r3,r2
 8242848:	e0bfff17 	ldw	r2,-4(fp)
 824284c:	10c02105 	stb	r3,132(r2)
 8242850:	00000706 	br	8242870 <ip_reasm_mark_compact_rfq+0x118>
      }
   else 
      {
      irep->flags &= ~IPR_RFQ_COMPACT;
 8242854:	e0bfff17 	ldw	r2,-4(fp)
 8242858:	10c02103 	ldbu	r3,132(r2)
 824285c:	00bfff84 	movi	r2,-2
 8242860:	1884703a 	and	r2,r3,r2
 8242864:	1007883a 	mov	r3,r2
 8242868:	e0bfff17 	ldw	r2,-4(fp)
 824286c:	10c02105 	stb	r3,132(r2)
      }

   return IPREASM_OK;
 8242870:	0005883a 	mov	r2,zero
}
 8242874:	e037883a 	mov	sp,fp
 8242878:	dfc00117 	ldw	ra,4(sp)
 824287c:	df000017 	ldw	fp,0(sp)
 8242880:	dec00204 	addi	sp,sp,8
 8242884:	f800283a 	ret

08242888 <ipr_stats>:

OUTPUT: This function always returns IPREASM_OK.
*/

int ipr_stats(void * pio)
{
 8242888:	deffeb04 	addi	sp,sp,-84
 824288c:	dfc01415 	stw	ra,80(sp)
 8242890:	df001315 	stw	fp,76(sp)
 8242894:	dc401215 	stw	r17,72(sp)
 8242898:	dc001115 	stw	r16,68(sp)
 824289c:	df001304 	addi	fp,sp,76
 82428a0:	e13ffd15 	stw	r4,-12(fp)
   unsigned long ticks_elapsed = cticks;
 82428a4:	d0a0a817 	ldw	r2,-32096(gp)
 82428a8:	e0bffb15 	stw	r2,-20(fp)
   u_short size_ire = sizeof(IRE);
 82428ac:	00802204 	movi	r2,136
 82428b0:	e0bffc0d 	sth	r2,-16(fp)
   u_short size_rfq = sizeof(RFQ);
 82428b4:	00801904 	movi	r2,100
 82428b8:	e0bffc8d 	sth	r2,-14(fp)
   IREP tmpp;
   u_short count = 0;
 82428bc:	e03ff80d 	sth	zero,-32(fp)
   RFQP rfqp;
   u_short frag_count = 0;
 82428c0:	e03ffa0d 	sth	zero,-24(fp)
   u_short i;

   ns_printf(pio,"IP reassembly statistics:\n");
 82428c4:	01420974 	movhi	r5,2085
 82428c8:	2944d404 	addi	r5,r5,4944
 82428cc:	e13ffd17 	ldw	r4,-12(fp)
 82428d0:	8228e600 	call	8228e60 <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
 82428d4:	d160c717 	ldw	r5,-31972(gp)
 82428d8:	e0fffb17 	ldw	r3,-20(fp)
 82428dc:	00947b34 	movhi	r2,20972
 82428e0:	10a147c4 	addi	r2,r2,-31457
 82428e4:	1888383a 	mulxuu	r4,r3,r2
 82428e8:	1885383a 	mul	r2,r3,r2
 82428ec:	1021883a 	mov	r16,r2
 82428f0:	2023883a 	mov	r17,r4
 82428f4:	8804d17a 	srli	r2,r17,5
 82428f8:	e0fffc0b 	ldhu	r3,-16(fp)
 82428fc:	e13ffc8b 	ldhu	r4,-14(fp)
 8242900:	d9000215 	stw	r4,8(sp)
 8242904:	d8c00115 	stw	r3,4(sp)
 8242908:	d8800015 	stw	r2,0(sp)
 824290c:	e1fffb17 	ldw	r7,-20(fp)
 8242910:	280d883a 	mov	r6,r5
 8242914:	01420974 	movhi	r5,2085
 8242918:	2944db04 	addi	r5,r5,4972
 824291c:	e13ffd17 	ldw	r4,-12(fp)
 8242920:	8228e600 	call	8228e60 <ns_printf>
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
 8242924:	008209b4 	movhi	r2,2086
 8242928:	10ba7504 	addi	r2,r2,-5676
 824292c:	11800117 	ldw	r6,4(r2)
 8242930:	008209b4 	movhi	r2,2086
 8242934:	10ba7504 	addi	r2,r2,-5676
 8242938:	11c00017 	ldw	r7,0(r2)
 824293c:	008209b4 	movhi	r2,2086
 8242940:	10ba7504 	addi	r2,r2,-5676
 8242944:	10c00217 	ldw	r3,8(r2)
 8242948:	008209b4 	movhi	r2,2086
 824294c:	10ba7504 	addi	r2,r2,-5676
 8242950:	11000317 	ldw	r4,12(r2)
 8242954:	008209b4 	movhi	r2,2086
 8242958:	10ba7504 	addi	r2,r2,-5676
 824295c:	11400417 	ldw	r5,16(r2)
 8242960:	008209b4 	movhi	r2,2086
 8242964:	10ba7504 	addi	r2,r2,-5676
 8242968:	10800517 	ldw	r2,20(r2)
 824296c:	d8800315 	stw	r2,12(sp)
 8242970:	d9400215 	stw	r5,8(sp)
 8242974:	d9000115 	stw	r4,4(sp)
 8242978:	d8c00015 	stw	r3,0(sp)
 824297c:	01420974 	movhi	r5,2085
 8242980:	2944eb04 	addi	r5,r5,5036
 8242984:	e13ffd17 	ldw	r4,-12(fp)
 8242988:	8228e600 	call	8228e60 <ns_printf>
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
 824298c:	d0a0c817 	ldw	r2,-31968(gp)
 8242990:	100d883a 	mov	r6,r2
 8242994:	01420974 	movhi	r5,2085
 8242998:	29450004 	addi	r5,r5,5120
 824299c:	e13ffd17 	ldw	r4,-12(fp)
 82429a0:	8228e600 	call	8228e60 <ns_printf>
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 82429a4:	d0a0c817 	ldw	r2,-31968(gp)
 82429a8:	e0bff715 	stw	r2,-36(fp)
 82429ac:	00007c06 	br	8242ba0 <ipr_stats+0x318>
      {
      ++count;
 82429b0:	e0bff80b 	ldhu	r2,-32(fp)
 82429b4:	10800044 	addi	r2,r2,1
 82429b8:	e0bff80d 	sth	r2,-32(fp)
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
 82429bc:	e0bff717 	ldw	r2,-36(fp)
 82429c0:	10800604 	addi	r2,r2,24
 82429c4:	e0bff915 	stw	r2,-28(fp)
      while (rfqp)
 82429c8:	00001e06 	br	8242a44 <ipr_stats+0x1bc>
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 82429cc:	e03ffa8d 	sth	zero,-22(fp)
 82429d0:	00001406 	br	8242a24 <ipr_stats+0x19c>
            {
            if (rfqp->bufp [i] != 0)
 82429d4:	e0bffa8b 	ldhu	r2,-22(fp)
 82429d8:	e0fff917 	ldw	r3,-28(fp)
 82429dc:	10800044 	addi	r2,r2,1
 82429e0:	1085883a 	add	r2,r2,r2
 82429e4:	1085883a 	add	r2,r2,r2
 82429e8:	1885883a 	add	r2,r3,r2
 82429ec:	10800017 	ldw	r2,0(r2)
 82429f0:	10000426 	beq	r2,zero,8242a04 <ipr_stats+0x17c>
               {
               ++frag_count;            
 82429f4:	e0bffa0b 	ldhu	r2,-24(fp)
 82429f8:	10800044 	addi	r2,r2,1
 82429fc:	e0bffa0d 	sth	r2,-24(fp)
 8242a00:	00000506 	br	8242a18 <ipr_stats+0x190>
               }
            else
               {
               if (tmpp->flags & IPR_RFQ_COMPACT)
 8242a04:	e0bff717 	ldw	r2,-36(fp)
 8242a08:	10802103 	ldbu	r2,132(r2)
 8242a0c:	10803fcc 	andi	r2,r2,255
 8242a10:	1080004c 	andi	r2,r2,1
 8242a14:	1000071e 	bne	r2,zero,8242a34 <ipr_stats+0x1ac>
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8242a18:	e0bffa8b 	ldhu	r2,-22(fp)
 8242a1c:	10800044 	addi	r2,r2,1
 8242a20:	e0bffa8d 	sth	r2,-22(fp)
 8242a24:	e0bffa8b 	ldhu	r2,-22(fp)
 8242a28:	10800430 	cmpltui	r2,r2,16
 8242a2c:	103fe91e 	bne	r2,zero,82429d4 <ipr_stats+0x14c>
 8242a30:	00000106 	br	8242a38 <ipr_stats+0x1b0>
               }
            else
               {
               if (tmpp->flags & IPR_RFQ_COMPACT)
                  {
                  break;
 8242a34:	0001883a 	nop
                  }
               }
            }
         rfqp = rfqp->next;
 8242a38:	e0bff917 	ldw	r2,-28(fp)
 8242a3c:	10800017 	ldw	r2,0(r2)
 8242a40:	e0bff915 	stw	r2,-28(fp)
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
      {
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
 8242a44:	e0bff917 	ldw	r2,-28(fp)
 8242a48:	103fe01e 	bne	r2,zero,82429cc <ipr_stats+0x144>
                  }
               }
            }
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
 8242a4c:	e33ffa0b 	ldhu	r12,-24(fp)
 8242a50:	e0bff717 	ldw	r2,-36(fp)
 8242a54:	10800117 	ldw	r2,4(r2)
 8242a58:	1006d63a 	srli	r3,r2,24
 8242a5c:	e0bff717 	ldw	r2,-36(fp)
 8242a60:	10800117 	ldw	r2,4(r2)
 8242a64:	1004d23a 	srli	r2,r2,8
 8242a68:	10bfc00c 	andi	r2,r2,65280
 8242a6c:	1886b03a 	or	r3,r3,r2
 8242a70:	e0bff717 	ldw	r2,-36(fp)
 8242a74:	10800117 	ldw	r2,4(r2)
 8242a78:	10bfc00c 	andi	r2,r2,65280
 8242a7c:	1004923a 	slli	r2,r2,8
 8242a80:	1886b03a 	or	r3,r3,r2
 8242a84:	e0bff717 	ldw	r2,-36(fp)
 8242a88:	10800117 	ldw	r2,4(r2)
 8242a8c:	1004963a 	slli	r2,r2,24
 8242a90:	1884b03a 	or	r2,r3,r2
 8242a94:	e0fff717 	ldw	r3,-36(fp)
 8242a98:	18c00217 	ldw	r3,8(r3)
 8242a9c:	1808d63a 	srli	r4,r3,24
 8242aa0:	e0fff717 	ldw	r3,-36(fp)
 8242aa4:	18c00217 	ldw	r3,8(r3)
 8242aa8:	1806d23a 	srli	r3,r3,8
 8242aac:	18ffc00c 	andi	r3,r3,65280
 8242ab0:	20c8b03a 	or	r4,r4,r3
 8242ab4:	e0fff717 	ldw	r3,-36(fp)
 8242ab8:	18c00217 	ldw	r3,8(r3)
 8242abc:	18ffc00c 	andi	r3,r3,65280
 8242ac0:	1806923a 	slli	r3,r3,8
 8242ac4:	20c8b03a 	or	r4,r4,r3
 8242ac8:	e0fff717 	ldw	r3,-36(fp)
 8242acc:	18c00217 	ldw	r3,8(r3)
 8242ad0:	1806963a 	slli	r3,r3,24
 8242ad4:	20c6b03a 	or	r3,r4,r3
 8242ad8:	e13ff717 	ldw	r4,-36(fp)
 8242adc:	21000383 	ldbu	r4,14(r4)
 8242ae0:	21003fcc 	andi	r4,r4,255
 8242ae4:	e17ff717 	ldw	r5,-36(fp)
 8242ae8:	2940030b 	ldhu	r5,12(r5)
 8242aec:	297fffcc 	andi	r5,r5,65535
 8242af0:	280ad23a 	srli	r5,r5,8
 8242af4:	297fffcc 	andi	r5,r5,65535
 8242af8:	29803fcc 	andi	r6,r5,255
 8242afc:	e17ff717 	ldw	r5,-36(fp)
 8242b00:	2940030b 	ldhu	r5,12(r5)
 8242b04:	297fffcc 	andi	r5,r5,65535
 8242b08:	280a923a 	slli	r5,r5,8
 8242b0c:	297fffcc 	andi	r5,r5,65535
 8242b10:	314ab03a 	or	r5,r6,r5
 8242b14:	e1bff717 	ldw	r6,-36(fp)
 8242b18:	3180040b 	ldhu	r6,16(r6)
 8242b1c:	31bfffcc 	andi	r6,r6,65535
 8242b20:	e1fff717 	ldw	r7,-36(fp)
 8242b24:	39c0048b 	ldhu	r7,18(r7)
 8242b28:	39ffffcc 	andi	r7,r7,65535
 8242b2c:	e23ff717 	ldw	r8,-36(fp)
 8242b30:	42000517 	ldw	r8,20(r8)
 8242b34:	e27ff717 	ldw	r9,-36(fp)
 8242b38:	4a401f17 	ldw	r9,124(r9)
 8242b3c:	e2bff717 	ldw	r10,-36(fp)
 8242b40:	52802017 	ldw	r10,128(r10)
 8242b44:	e2fff717 	ldw	r11,-36(fp)
 8242b48:	5ac02103 	ldbu	r11,132(r11)
 8242b4c:	5ac03fcc 	andi	r11,r11,255
 8242b50:	5ac0004c 	andi	r11,r11,1
 8242b54:	dac00915 	stw	r11,36(sp)
 8242b58:	da800815 	stw	r10,32(sp)
 8242b5c:	da400715 	stw	r9,28(sp)
 8242b60:	da000615 	stw	r8,24(sp)
 8242b64:	d9c00515 	stw	r7,20(sp)
 8242b68:	d9800415 	stw	r6,16(sp)
 8242b6c:	d9400315 	stw	r5,12(sp)
 8242b70:	d9000215 	stw	r4,8(sp)
 8242b74:	d8c00115 	stw	r3,4(sp)
 8242b78:	d8800015 	stw	r2,0(sp)
 8242b7c:	600f883a 	mov	r7,r12
 8242b80:	e1bff717 	ldw	r6,-36(fp)
 8242b84:	01420974 	movhi	r5,2085
 8242b88:	29450604 	addi	r5,r5,5144
 8242b8c:	e13ffd17 	ldw	r4,-12(fp)
 8242b90:	8228e600 	call	8228e60 <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8242b94:	e0bff717 	ldw	r2,-36(fp)
 8242b98:	10800017 	ldw	r2,0(r2)
 8242b9c:	e0bff715 	stw	r2,-36(fp)
 8242ba0:	e0bff717 	ldw	r2,-36(fp)
 8242ba4:	103f821e 	bne	r2,zero,82429b0 <ipr_stats+0x128>
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
      } /* end FOR (IRE linked list) */

   ns_printf(pio,"Found a total of %u IRE entries\n",count);
 8242ba8:	e0bff80b 	ldhu	r2,-32(fp)
 8242bac:	100d883a 	mov	r6,r2
 8242bb0:	01420974 	movhi	r5,2085
 8242bb4:	29452104 	addi	r5,r5,5252
 8242bb8:	e13ffd17 	ldw	r4,-12(fp)
 8242bbc:	8228e600 	call	8228e60 <ns_printf>

   return IPREASM_OK;
 8242bc0:	0005883a 	mov	r2,zero
}
 8242bc4:	e6fffe04 	addi	sp,fp,-8
 8242bc8:	dfc00317 	ldw	ra,12(sp)
 8242bcc:	df000217 	ldw	fp,8(sp)
 8242bd0:	dc400117 	ldw	r17,4(sp)
 8242bd4:	dc000017 	ldw	r16,0(sp)
 8242bd8:	dec00404 	addi	sp,sp,16
 8242bdc:	f800283a 	ret

08242be0 <ip_reasm_send_icmp_timex>:
OUTPUT: This function always returns IPREASM_OK.
*/

#ifdef FULL_ICMP
u_long ip_reasm_send_icmp_timex (IREP irep)
{
 8242be0:	defffc04 	addi	sp,sp,-16
 8242be4:	dfc00315 	stw	ra,12(sp)
 8242be8:	df000215 	stw	fp,8(sp)
 8242bec:	df000204 	addi	fp,sp,8
 8242bf0:	e13fff15 	stw	r4,-4(fp)

   /* we can only send an ICMP Time Exceeded message with code 1 ("fragment reassembly 
    * time exceeded") if we have received the First Fragment (FF) of the original, 
    * unfragmented datagram.  This is indicated by a non-zero value for the l2_hdr and
    * l3_hdr fields in the IRE data structure. */
   if (irep->l2_hdr)
 8242bf4:	e0bfff17 	ldw	r2,-4(fp)
 8242bf8:	10801f17 	ldw	r2,124(r2)
 8242bfc:	10000626 	beq	r2,zero,8242c18 <ip_reasm_send_icmp_timex+0x38>
      {
      pip = (struct ip *) irep->l3_hdr;
 8242c00:	e0bfff17 	ldw	r2,-4(fp)
 8242c04:	10802017 	ldw	r2,128(r2)
 8242c08:	e0bffe15 	stw	r2,-8(fp)
      icmp_timex (pip, TIMEX_REASSY_FAILED);
 8242c0c:	01400044 	movi	r5,1
 8242c10:	e13ffe17 	ldw	r4,-8(fp)
 8242c14:	824b2c40 	call	824b2c4 <icmp_timex>
      }

   return IPREASM_OK;
 8242c18:	0005883a 	mov	r2,zero
}
 8242c1c:	e037883a 	mov	sp,fp
 8242c20:	dfc00117 	ldw	ra,4(sp)
 8242c24:	df000017 	ldw	fp,0(sp)
 8242c28:	dec00204 	addi	sp,sp,8
 8242c2c:	f800283a 	ret

08242c30 <ip_rcv>:
 * RETURNS: 
 */

int
ip_rcv(PACKET p)
{
 8242c30:	defff404 	addi	sp,sp,-48
 8242c34:	dfc00b15 	stw	ra,44(sp)
 8242c38:	df000a15 	stw	fp,40(sp)
 8242c3c:	dc000915 	stw	r16,36(sp)
 8242c40:	df000a04 	addi	fp,sp,40
 8242c44:	e13ffe15 	stw	r4,-8(fp)
   unsigned hdrlen;  /* length of IP header including options */
   unsigned len;     /* total length including IP header */
   unsigned short int num_pkts;
   PACKET * pktp;
   unsigned char i;
   int rcvrc = -1;
 8242c48:	00bfffc4 	movi	r2,-1
 8242c4c:	e0bff715 	stw	r2,-36(fp)
   unsigned char rc_ret;
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8242c50:	d0a08317 	ldw	r2,-32244(gp)
 8242c54:	1081000c 	andi	r2,r2,1024
 8242c58:	10000e26 	beq	r2,zero,8242c94 <ip_rcv+0x64>
 8242c5c:	d0a08317 	ldw	r2,-32244(gp)
 8242c60:	1080800c 	andi	r2,r2,512
 8242c64:	10000b26 	beq	r2,zero,8242c94 <ip_rcv+0x64>
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
         p->nb_plen, net_num(p->net));
 8242c68:	e0bffe17 	ldw	r2,-8(fp)
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
 8242c6c:	14000417 	ldw	r16,16(r2)
         p->nb_plen, net_num(p->net));
 8242c70:	e0bffe17 	ldw	r2,-8(fp)
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
 8242c74:	10800617 	ldw	r2,24(r2)
 8242c78:	1009883a 	mov	r4,r2
 8242c7c:	8226c680 	call	8226c68 <if_netnumber>
 8242c80:	100d883a 	mov	r6,r2
 8242c84:	800b883a 	mov	r5,r16
 8242c88:	01020974 	movhi	r4,2085
 8242c8c:	21052a04 	addi	r4,r4,5288
 8242c90:	82033a00 	call	82033a0 <printf>
         p->nb_plen, net_num(p->net));
#endif

   IN_PROFILER(PF_IP, PF_ENTRY);

   ip_mib.ipInReceives++;
 8242c94:	008209b4 	movhi	r2,2086
 8242c98:	10ba6104 	addi	r2,r2,-5756
 8242c9c:	10800217 	ldw	r2,8(r2)
 8242ca0:	10c00044 	addi	r3,r2,1
 8242ca4:	008209b4 	movhi	r2,2086
 8242ca8:	10ba6104 	addi	r2,r2,-5756
 8242cac:	10c00215 	stw	r3,8(r2)
   pip = ip_head(p);
 8242cb0:	e0bffe17 	ldw	r2,-8(fp)
 8242cb4:	10800317 	ldw	r2,12(r2)
 8242cb8:	e0bff815 	stw	r2,-32(fp)

   /* test received MAC len against IP header len */
   if (p->nb_plen < (unsigned)htons(pip->ip_len))
 8242cbc:	e0bffe17 	ldw	r2,-8(fp)
 8242cc0:	10800417 	ldw	r2,16(r2)
 8242cc4:	e0fff817 	ldw	r3,-32(fp)
 8242cc8:	18c0008b 	ldhu	r3,2(r3)
 8242ccc:	18ffffcc 	andi	r3,r3,65535
 8242cd0:	1806d23a 	srli	r3,r3,8
 8242cd4:	18ffffcc 	andi	r3,r3,65535
 8242cd8:	19003fcc 	andi	r4,r3,255
 8242cdc:	e0fff817 	ldw	r3,-32(fp)
 8242ce0:	18c0008b 	ldhu	r3,2(r3)
 8242ce4:	18ffffcc 	andi	r3,r3,65535
 8242ce8:	1806923a 	slli	r3,r3,8
 8242cec:	18ffffcc 	andi	r3,r3,65535
 8242cf0:	20c6b03a 	or	r3,r4,r3
 8242cf4:	10c01f2e 	bgeu	r2,r3,8242d74 <ip_rcv+0x144>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8242cf8:	d0a08317 	ldw	r2,-32244(gp)
 8242cfc:	1081000c 	andi	r2,r2,1024
 8242d00:	10000c26 	beq	r2,zero,8242d34 <ip_rcv+0x104>
 8242d04:	d0a08317 	ldw	r2,-32244(gp)
 8242d08:	1080800c 	andi	r2,r2,512
 8242d0c:	10000926 	beq	r2,zero,8242d34 <ip_rcv+0x104>
      {
         dprintf("ip_rcv: bad pkt len\n");
 8242d10:	01020974 	movhi	r4,2085
 8242d14:	21053304 	addi	r4,r4,5324
 8242d18:	82036240 	call	8203624 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 8242d1c:	d0a08317 	ldw	r2,-32244(gp)
 8242d20:	1080008c 	andi	r2,r2,2
 8242d24:	10000326 	beq	r2,zero,8242d34 <ip_rcv+0x104>
 8242d28:	e0bffe17 	ldw	r2,-8(fp)
 8242d2c:	1009883a 	mov	r4,r2
 8242d30:	8240a400 	call	8240a40 <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 8242d34:	008209b4 	movhi	r2,2086
 8242d38:	10ba6104 	addi	r2,r2,-5756
 8242d3c:	10800317 	ldw	r2,12(r2)
 8242d40:	10c00044 	addi	r3,r2,1
 8242d44:	008209b4 	movhi	r2,2086
 8242d48:	10ba6104 	addi	r2,r2,-5756
 8242d4c:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 8242d50:	01000084 	movi	r4,2
 8242d54:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free(p);
 8242d58:	e0bffe17 	ldw	r2,-8(fp)
 8242d5c:	1009883a 	mov	r4,r2
 8242d60:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8242d64:	01000084 	movi	r4,2
 8242d68:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 8242d6c:	00bff804 	movi	r2,-32
 8242d70:	00008906 	br	8242f98 <ip_rcv+0x368>
   }

   /* use length from IP header; MAC value may be padded */
   len = htons(pip->ip_len);
 8242d74:	e0bff817 	ldw	r2,-32(fp)
 8242d78:	1080008b 	ldhu	r2,2(r2)
 8242d7c:	10bfffcc 	andi	r2,r2,65535
 8242d80:	1004d23a 	srli	r2,r2,8
 8242d84:	10bfffcc 	andi	r2,r2,65535
 8242d88:	10c03fcc 	andi	r3,r2,255
 8242d8c:	e0bff817 	ldw	r2,-32(fp)
 8242d90:	1080008b 	ldhu	r2,2(r2)
 8242d94:	10bfffcc 	andi	r2,r2,65535
 8242d98:	1004923a 	slli	r2,r2,8
 8242d9c:	10bfffcc 	andi	r2,r2,65535
 8242da0:	1884b03a 	or	r2,r3,r2
 8242da4:	e0bff915 	stw	r2,-28(fp)
   p->nb_plen = len;       /* fix pkt len */
 8242da8:	e0bffe17 	ldw	r2,-8(fp)
 8242dac:	e0fff917 	ldw	r3,-28(fp)
 8242db0:	10c00415 	stw	r3,16(r2)

   if ( ((pip->ip_ver_ihl & 0xf0) >> 4) != IP_VER)
 8242db4:	e0bff817 	ldw	r2,-32(fp)
 8242db8:	10800003 	ldbu	r2,0(r2)
 8242dbc:	10803fcc 	andi	r2,r2,255
 8242dc0:	1004d13a 	srli	r2,r2,4
 8242dc4:	10803fcc 	andi	r2,r2,255
 8242dc8:	10800120 	cmpeqi	r2,r2,4
 8242dcc:	10001f1e 	bne	r2,zero,8242e4c <ip_rcv+0x21c>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8242dd0:	d0a08317 	ldw	r2,-32244(gp)
 8242dd4:	1081000c 	andi	r2,r2,1024
 8242dd8:	10000c26 	beq	r2,zero,8242e0c <ip_rcv+0x1dc>
 8242ddc:	d0a08317 	ldw	r2,-32244(gp)
 8242de0:	1080800c 	andi	r2,r2,512
 8242de4:	10000926 	beq	r2,zero,8242e0c <ip_rcv+0x1dc>
      {
         dprintf("ip_rcv: bad version number\n");
 8242de8:	01020974 	movhi	r4,2085
 8242dec:	21053804 	addi	r4,r4,5344
 8242df0:	82036240 	call	8203624 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 8242df4:	d0a08317 	ldw	r2,-32244(gp)
 8242df8:	1080008c 	andi	r2,r2,2
 8242dfc:	10000326 	beq	r2,zero,8242e0c <ip_rcv+0x1dc>
 8242e00:	e0bffe17 	ldw	r2,-8(fp)
 8242e04:	1009883a 	mov	r4,r2
 8242e08:	8240a400 	call	8240a40 <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 8242e0c:	008209b4 	movhi	r2,2086
 8242e10:	10ba6104 	addi	r2,r2,-5756
 8242e14:	10800317 	ldw	r2,12(r2)
 8242e18:	10c00044 	addi	r3,r2,1
 8242e1c:	008209b4 	movhi	r2,2086
 8242e20:	10ba6104 	addi	r2,r2,-5756
 8242e24:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 8242e28:	01000084 	movi	r4,2
 8242e2c:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free(p);
 8242e30:	e0bffe17 	ldw	r2,-8(fp)
 8242e34:	1009883a 	mov	r4,r2
 8242e38:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8242e3c:	01000084 	movi	r4,2
 8242e40:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 8242e44:	00bff804 	movi	r2,-32
 8242e48:	00005306 	br	8242f98 <ip_rcv+0x368>
   }

   csum = pip->ip_chksum;
 8242e4c:	e0bff817 	ldw	r2,-32(fp)
 8242e50:	1080028b 	ldhu	r2,10(r2)
 8242e54:	e0bffa0d 	sth	r2,-24(fp)
   pip->ip_chksum = 0;
 8242e58:	e0bff817 	ldw	r2,-32(fp)
 8242e5c:	1000028d 	sth	zero,10(r2)
   hdrlen = ip_hlen(pip);
 8242e60:	e0bff817 	ldw	r2,-32(fp)
 8242e64:	10800003 	ldbu	r2,0(r2)
 8242e68:	10803fcc 	andi	r2,r2,255
 8242e6c:	108003cc 	andi	r2,r2,15
 8242e70:	1085883a 	add	r2,r2,r2
 8242e74:	1085883a 	add	r2,r2,r2
 8242e78:	e0bffb15 	stw	r2,-20(fp)
   tempsum = ~cksum(pip, hdrlen >> 1);
 8242e7c:	e0bffb17 	ldw	r2,-20(fp)
 8242e80:	1004d07a 	srli	r2,r2,1
 8242e84:	100b883a 	mov	r5,r2
 8242e88:	e13ff817 	ldw	r4,-32(fp)
 8242e8c:	82287b40 	call	82287b4 <cksum>
 8242e90:	0084303a 	nor	r2,zero,r2
 8242e94:	e0bffc0d 	sth	r2,-16(fp)

   if (csum != tempsum)
 8242e98:	e0fffa0b 	ldhu	r3,-24(fp)
 8242e9c:	e0bffc0b 	ldhu	r2,-16(fp)
 8242ea0:	18802226 	beq	r3,r2,8242f2c <ip_rcv+0x2fc>
   {
      pip->ip_chksum = csum;
 8242ea4:	e0bff817 	ldw	r2,-32(fp)
 8242ea8:	e0fffa0b 	ldhu	r3,-24(fp)
 8242eac:	10c0028d 	sth	r3,10(r2)
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8242eb0:	d0a08317 	ldw	r2,-32244(gp)
 8242eb4:	1081000c 	andi	r2,r2,1024
 8242eb8:	10000c26 	beq	r2,zero,8242eec <ip_rcv+0x2bc>
 8242ebc:	d0a08317 	ldw	r2,-32244(gp)
 8242ec0:	1080800c 	andi	r2,r2,512
 8242ec4:	10000926 	beq	r2,zero,8242eec <ip_rcv+0x2bc>
      {
         dprintf("ip_rcv: bad xsum\n");
 8242ec8:	01020974 	movhi	r4,2085
 8242ecc:	21053f04 	addi	r4,r4,5372
 8242ed0:	82036240 	call	8203624 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 8242ed4:	d0a08317 	ldw	r2,-32244(gp)
 8242ed8:	1080008c 	andi	r2,r2,2
 8242edc:	10000326 	beq	r2,zero,8242eec <ip_rcv+0x2bc>
 8242ee0:	e0bffe17 	ldw	r2,-8(fp)
 8242ee4:	1009883a 	mov	r4,r2
 8242ee8:	8240a400 	call	8240a40 <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 8242eec:	008209b4 	movhi	r2,2086
 8242ef0:	10ba6104 	addi	r2,r2,-5756
 8242ef4:	10800317 	ldw	r2,12(r2)
 8242ef8:	10c00044 	addi	r3,r2,1
 8242efc:	008209b4 	movhi	r2,2086
 8242f00:	10ba6104 	addi	r2,r2,-5756
 8242f04:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 8242f08:	01000084 	movi	r4,2
 8242f0c:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free(p);
 8242f10:	e0bffe17 	ldw	r2,-8(fp)
 8242f14:	1009883a 	mov	r4,r2
 8242f18:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8242f1c:	01000084 	movi	r4,2
 8242f20:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 8242f24:	00bff804 	movi	r2,-32
 8242f28:	00001b06 	br	8242f98 <ip_rcv+0x368>
   }

   pip->ip_chksum = csum;
 8242f2c:	e0bff817 	ldw	r2,-32(fp)
 8242f30:	e0fffa0b 	ldhu	r3,-24(fp)
 8242f34:	10c0028d 	sth	r3,10(r2)
#endif

    /* start off by assuming that we will only process the "current" packet;
     * these values may get overwritten by the NAT module if it returns
     * more than one packet back to this function (ip_rcv ()) */
    num_pkts = 1;
 8242f38:	00800044 	movi	r2,1
 8242f3c:	e0bffc8d 	sth	r2,-14(fp)
    pktp = &p;
 8242f40:	e0bffe04 	addi	r2,fp,-8
 8242f44:	e0bffd15 	stw	r2,-12(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 8242f48:	e03ff605 	stb	zero,-40(fp)
 8242f4c:	00000d06 	br	8242f84 <ip_rcv+0x354>
   {
      rcvrc = ip_rcv_phase2 (*(pktp + i));
 8242f50:	e0bff603 	ldbu	r2,-40(fp)
 8242f54:	1085883a 	add	r2,r2,r2
 8242f58:	1085883a 	add	r2,r2,r2
 8242f5c:	1007883a 	mov	r3,r2
 8242f60:	e0bffd17 	ldw	r2,-12(fp)
 8242f64:	10c5883a 	add	r2,r2,r3
 8242f68:	10800017 	ldw	r2,0(r2)
 8242f6c:	1009883a 	mov	r4,r2
 8242f70:	8242fb00 	call	8242fb0 <ip_rcv_phase2>
 8242f74:	e0bff715 	stw	r2,-36(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 8242f78:	e0bff603 	ldbu	r2,-40(fp)
 8242f7c:	10800044 	addi	r2,r2,1
 8242f80:	e0bff605 	stb	r2,-40(fp)
 8242f84:	e0bff603 	ldbu	r2,-40(fp)
 8242f88:	10ffffcc 	andi	r3,r2,65535
 8242f8c:	e0bffc8b 	ldhu	r2,-14(fp)
 8242f90:	18bfef36 	bltu	r3,r2,8242f50 <ip_rcv+0x320>
   if (pktp != &p) nat_free (pktp);
#endif /* NATRT */

   /* when multiple packets are processed in the loop above, the return code
    * contains the return code for the last packet */
   return rcvrc;
 8242f94:	e0bff717 	ldw	r2,-36(fp)
}
 8242f98:	e6ffff04 	addi	sp,fp,-4
 8242f9c:	dfc00217 	ldw	ra,8(sp)
 8242fa0:	df000117 	ldw	fp,4(sp)
 8242fa4:	dc000017 	ldw	r16,0(sp)
 8242fa8:	dec00304 	addi	sp,sp,12
 8242fac:	f800283a 	ret

08242fb0 <ip_rcv_phase2>:


int ip_rcv_phase2 (PACKET p)
{
 8242fb0:	defff504 	addi	sp,sp,-44
 8242fb4:	dfc00a15 	stw	ra,40(sp)
 8242fb8:	df000915 	stw	fp,36(sp)
 8242fbc:	df000904 	addi	fp,sp,36
 8242fc0:	e13fff15 	stw	r4,-4(fp)

   struct ip * pip;     /* the internet header */
   NET nt;
   unsigned short tempsum;

   pip = ip_head(p);
 8242fc4:	e0bfff17 	ldw	r2,-4(fp)
 8242fc8:	10800317 	ldw	r2,12(r2)
 8242fcc:	e0bff815 	stw	r2,-32(fp)
   nt = p->net;      /* which interface it came in on */
 8242fd0:	e0bfff17 	ldw	r2,-4(fp)
 8242fd4:	10800617 	ldw	r2,24(r2)
 8242fd8:	e0bff915 	stw	r2,-28(fp)

#ifdef IP_MULTICAST

   if (IN_MULTICAST(ntohl(pip->ip_dest))) 
 8242fdc:	e0bff817 	ldw	r2,-32(fp)
 8242fe0:	10800417 	ldw	r2,16(r2)
 8242fe4:	1006d63a 	srli	r3,r2,24
 8242fe8:	e0bff817 	ldw	r2,-32(fp)
 8242fec:	10800417 	ldw	r2,16(r2)
 8242ff0:	1004d23a 	srli	r2,r2,8
 8242ff4:	10bfc00c 	andi	r2,r2,65280
 8242ff8:	1886b03a 	or	r3,r3,r2
 8242ffc:	e0bff817 	ldw	r2,-32(fp)
 8243000:	10800417 	ldw	r2,16(r2)
 8243004:	10bfc00c 	andi	r2,r2,65280
 8243008:	1004923a 	slli	r2,r2,8
 824300c:	1886b03a 	or	r3,r3,r2
 8243010:	e0bff817 	ldw	r2,-32(fp)
 8243014:	10800417 	ldw	r2,16(r2)
 8243018:	1004963a 	slli	r2,r2,24
 824301c:	1884b03a 	or	r2,r3,r2
 8243020:	10fc002c 	andhi	r3,r2,61440
 8243024:	00b80034 	movhi	r2,57344
 8243028:	1880171e 	bne	r3,r2,8243088 <ip_rcv_phase2+0xd8>
      struct in_multi * inm;
      /*
       * See if we belong to the destination multicast group on the
       * arrival interface.
       */
      inm = lookup_mcast(pip->ip_dest, nt);
 824302c:	e0bff817 	ldw	r2,-32(fp)
 8243030:	10800417 	ldw	r2,16(r2)
 8243034:	e17ff917 	ldw	r5,-28(fp)
 8243038:	1009883a 	mov	r4,r2
 824303c:	8243ba80 	call	8243ba8 <lookup_mcast>
 8243040:	e0bffa15 	stw	r2,-24(fp)
      if (inm == NULL) 
 8243044:	e0bffa17 	ldw	r2,-24(fp)
 8243048:	1001081e 	bne	r2,zero,824346c <ip_rcv_phase2+0x4bc>
      {
         ip_mib.ipOutNoRoutes++;
 824304c:	008209b4 	movhi	r2,2086
 8243050:	10ba6104 	addi	r2,r2,-5756
 8243054:	10800b17 	ldw	r2,44(r2)
 8243058:	10c00044 	addi	r3,r2,1
 824305c:	008209b4 	movhi	r2,2086
 8243060:	10ba6104 	addi	r2,r2,-5756
 8243064:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 8243068:	01000084 	movi	r4,2
 824306c:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
         pk_free(p);
 8243070:	e13fff17 	ldw	r4,-4(fp)
 8243074:	822cd3c0 	call	822cd3c <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8243078:	01000084 	movi	r4,2
 824307c:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NOT_MINE);
 8243080:	00800084 	movi	r2,2
 8243084:	00013806 	br	8243568 <ip_rcv_phase2+0x5b8>
      else
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
 8243088:	e0bff817 	ldw	r2,-32(fp)
 824308c:	10c00417 	ldw	r3,16(r2)
 8243090:	e0bff917 	ldw	r2,-28(fp)
 8243094:	10800a17 	ldw	r2,40(r2)
 8243098:	1880f726 	beq	r3,r2,8243478 <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 824309c:	e0bff817 	ldw	r2,-32(fp)
 82430a0:	10800417 	ldw	r2,16(r2)
      else
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
 82430a4:	10bfffe0 	cmpeqi	r2,r2,-1
 82430a8:	1000f31e 	bne	r2,zero,8243478 <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
 82430ac:	e0bff817 	ldw	r2,-32(fp)
 82430b0:	10c00417 	ldw	r3,16(r2)
 82430b4:	e0bff917 	ldw	r2,-28(fp)
 82430b8:	10800e17 	ldw	r2,56(r2)
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 82430bc:	1880ee26 	beq	r3,r2,8243478 <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
 82430c0:	e0bff817 	ldw	r2,-32(fp)
 82430c4:	10c00417 	ldw	r3,16(r2)
 82430c8:	e0bff917 	ldw	r2,-28(fp)
 82430cc:	10800f17 	ldw	r2,60(r2)
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
 82430d0:	1880e926 	beq	r3,r2,8243478 <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
 82430d4:	e0bff817 	ldw	r2,-32(fp)
 82430d8:	10c00417 	ldw	r3,16(r2)
 82430dc:	e0bff917 	ldw	r2,-28(fp)
 82430e0:	10801017 	ldw	r2,64(r2)
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
 82430e4:	1880e426 	beq	r3,r2,8243478 <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
 82430e8:	e0bff917 	ldw	r2,-28(fp)
 82430ec:	10c00a17 	ldw	r3,40(r2)
 82430f0:	e0bff917 	ldw	r2,-28(fp)
 82430f4:	10800c17 	ldw	r2,48(r2)
 82430f8:	0084303a 	nor	r2,zero,r2
 82430fc:	1884703a 	and	r2,r3,r2

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
 8243100:	1000dd26 	beq	r2,zero,8243478 <ip_rcv_phase2+0x4c8>
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8243104:	d0a08317 	ldw	r2,-32244(gp)
 8243108:	1081000c 	andi	r2,r2,1024
 824310c:	10001826 	beq	r2,zero,8243170 <ip_rcv_phase2+0x1c0>
 8243110:	d0a08317 	ldw	r2,-32244(gp)
 8243114:	1080800c 	andi	r2,r2,512
 8243118:	10001526 	beq	r2,zero,8243170 <ip_rcv_phase2+0x1c0>
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
       PUSH_IPADDR(pip->ip_dest));
 824311c:	e0bff817 	ldw	r2,-32(fp)
 8243120:	10800417 	ldw	r2,16(r2)
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 8243124:	10c03fcc 	andi	r3,r2,255
       PUSH_IPADDR(pip->ip_dest));
 8243128:	e0bff817 	ldw	r2,-32(fp)
 824312c:	10800417 	ldw	r2,16(r2)
 8243130:	1004d23a 	srli	r2,r2,8
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 8243134:	11003fcc 	andi	r4,r2,255
       PUSH_IPADDR(pip->ip_dest));
 8243138:	e0bff817 	ldw	r2,-32(fp)
 824313c:	10800417 	ldw	r2,16(r2)
 8243140:	1004d43a 	srli	r2,r2,16
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 8243144:	11403fcc 	andi	r5,r2,255
       PUSH_IPADDR(pip->ip_dest));
 8243148:	e0bff817 	ldw	r2,-32(fp)
 824314c:	10800417 	ldw	r2,16(r2)
 8243150:	1004d63a 	srli	r2,r2,24
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 8243154:	d8800015 	stw	r2,0(sp)
 8243158:	280f883a 	mov	r7,r5
 824315c:	200d883a 	mov	r6,r4
 8243160:	180b883a 	mov	r5,r3
 8243164:	01020974 	movhi	r4,2085
 8243168:	21054404 	addi	r4,r4,5392
 824316c:	82033a00 	call	82033a0 <printf>

#ifdef IP_ROUTING    /* if multi-homed router, try to route */
      /* Do routing only if ipForwarding is enabled in the IP MIB. This
       * is the switch for routing whether SNMP is used or not.
       */
      if (ip_mib.ipForwarding == 2)
 8243170:	008209b4 	movhi	r2,2086
 8243174:	10ba6104 	addi	r2,r2,-5756
 8243178:	10800017 	ldw	r2,0(r2)
 824317c:	10800098 	cmpnei	r2,r2,2
 8243180:	10000f1e 	bne	r2,zero,82431c0 <ip_rcv_phase2+0x210>
      {
         ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 8243184:	008209b4 	movhi	r2,2086
 8243188:	10ba6104 	addi	r2,r2,-5756
 824318c:	10800a17 	ldw	r2,40(r2)
 8243190:	10c00044 	addi	r3,r2,1
 8243194:	008209b4 	movhi	r2,2086
 8243198:	10ba6104 	addi	r2,r2,-5756
 824319c:	10c00a15 	stw	r3,40(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 82431a0:	01000084 	movi	r4,2
 82431a4:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
         pk_free(p);
 82431a8:	e13fff17 	ldw	r4,-4(fp)
 82431ac:	822cd3c0 	call	822cd3c <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82431b0:	01000084 	movi	r4,2
 82431b4:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_NO_ROUTE;
 82431b8:	00bff7c4 	movi	r2,-33
 82431bc:	0000ea06 	br	8243568 <ip_rcv_phase2+0x5b8>
         NET outnet;
#ifdef IP_FRAGMENTS
         int err;
#endif

         ip_mib.ipForwDatagrams++;  /* Count MIB-2 route attempts here */
 82431c0:	008209b4 	movhi	r2,2086
 82431c4:	10ba6104 	addi	r2,r2,-5756
 82431c8:	10800517 	ldw	r2,20(r2)
 82431cc:	10c00044 	addi	r3,r2,1
 82431d0:	008209b4 	movhi	r2,2086
 82431d4:	10ba6104 	addi	r2,r2,-5756
 82431d8:	10c00515 	stw	r3,20(r2)
         if (pip->ip_time <= 1)     /* Time to Live (hopcount) expired? */
 82431dc:	e0bff817 	ldw	r2,-32(fp)
 82431e0:	10800203 	ldbu	r2,8(r2)
 82431e4:	10803fcc 	andi	r2,r2,255
 82431e8:	108000a8 	cmpgeui	r2,r2,2
 82431ec:	10001c1e 	bne	r2,zero,8243260 <ip_rcv_phase2+0x2b0>
         {
            ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 82431f0:	008209b4 	movhi	r2,2086
 82431f4:	10ba6104 	addi	r2,r2,-5756
 82431f8:	10800a17 	ldw	r2,40(r2)
 82431fc:	10c00044 	addi	r3,r2,1
 8243200:	008209b4 	movhi	r2,2086
 8243204:	10ba6104 	addi	r2,r2,-5756
 8243208:	10c00a15 	stw	r3,40(r2)
#ifdef FULL_ICMP
            icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, (TIMEX <<8), p->net);
 824320c:	e0bff817 	ldw	r2,-32(fp)
 8243210:	10c00317 	ldw	r3,12(r2)
 8243214:	e0bfff17 	ldw	r2,-4(fp)
 8243218:	10800617 	ldw	r2,24(r2)
 824321c:	11000a17 	ldw	r4,40(r2)
 8243220:	e0bfff17 	ldw	r2,-4(fp)
 8243224:	10800617 	ldw	r2,24(r2)
 8243228:	d8800015 	stw	r2,0(sp)
 824322c:	01c2c004 	movi	r7,2816
 8243230:	e1bff817 	ldw	r6,-32(fp)
 8243234:	200b883a 	mov	r5,r4
 8243238:	1809883a 	mov	r4,r3
 824323c:	824afc40 	call	824afc4 <icmp_destun>
#endif   /* FULL_ICMP */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 8243240:	01000084 	movi	r4,2
 8243244:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
            pk_free(p);
 8243248:	e13fff17 	ldw	r4,-4(fp)
 824324c:	822cd3c0 	call	822cd3c <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8243250:	01000084 	movi	r4,2
 8243254:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 8243258:	00bff7c4 	movi	r2,-33
 824325c:	0000c206 	br	8243568 <ip_rcv_phase2+0x5b8>
         }

         p->fhost = pip->ip_dest;   /* set packet's target IP in net endian */
 8243260:	e0bff817 	ldw	r2,-32(fp)
 8243264:	10c00417 	ldw	r3,16(r2)
 8243268:	e0bfff17 	ldw	r2,-4(fp)
 824326c:	10c00715 	stw	r3,28(r2)
         if ((outnet = iproute(p->fhost, &firsthop)) == NULL)  /* find route */
 8243270:	e0bfff17 	ldw	r2,-4(fp)
 8243274:	10800717 	ldw	r2,28(r2)
 8243278:	e0fffe04 	addi	r3,fp,-8
 824327c:	180b883a 	mov	r5,r3
 8243280:	1009883a 	mov	r4,r2
 8243284:	8240ce80 	call	8240ce8 <iproute>
 8243288:	e0bffb15 	stw	r2,-20(fp)
 824328c:	e0bffb17 	ldw	r2,-20(fp)
 8243290:	10000f1e 	bne	r2,zero,82432d0 <ip_rcv_phase2+0x320>
         {
            ip_mib.ipOutNoRoutes++; /* count unroutable pkts */
 8243294:	008209b4 	movhi	r2,2086
 8243298:	10ba6104 	addi	r2,r2,-5756
 824329c:	10800b17 	ldw	r2,44(r2)
 82432a0:	10c00044 	addi	r3,r2,1
 82432a4:	008209b4 	movhi	r2,2086
 82432a8:	10ba6104 	addi	r2,r2,-5756
 82432ac:	10c00b15 	stw	r3,44(r2)
            LOCK_NET_RESOURCE(FREEQ_RESID);
 82432b0:	01000084 	movi	r4,2
 82432b4:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
            pk_free(p);
 82432b8:	e13fff17 	ldw	r4,-4(fp)
 82432bc:	822cd3c0 	call	822cd3c <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82432c0:	01000084 	movi	r4,2
 82432c4:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 82432c8:	00bff7c4 	movi	r2,-33
 82432cc:	0000a606 	br	8243568 <ip_rcv_phase2+0x5b8>
         /* Check to see if the packet was is addressed to one of our IP
          * addresses other than the interface it was received on. If so,
          * routing should have returned that interface and we can trap this
          * situation by checking the interfaces IP address.
          */
         if(pip->ip_dest == outnet->n_ipaddr)
 82432d0:	e0bff817 	ldw	r2,-32(fp)
 82432d4:	10c00417 	ldw	r3,16(r2)
 82432d8:	e0bffb17 	ldw	r2,-20(fp)
 82432dc:	10800a17 	ldw	r2,40(r2)
 82432e0:	18806426 	beq	r3,r2,8243474 <ip_rcv_phase2+0x4c4>
            goto ours;

         /* Make sure the packet is not a subnet broadcast for either the
          * source or destination network.
          */
         if((pip->ip_dest == outnet->n_netbr) ||
 82432e4:	e0bff817 	ldw	r2,-32(fp)
 82432e8:	10c00417 	ldw	r3,16(r2)
 82432ec:	e0bffb17 	ldw	r2,-20(fp)
 82432f0:	10800e17 	ldw	r2,56(r2)
 82432f4:	18806026 	beq	r3,r2,8243478 <ip_rcv_phase2+0x4c8>
            (pip->ip_dest == p->net->n_netbr))
 82432f8:	e0bff817 	ldw	r2,-32(fp)
 82432fc:	10c00417 	ldw	r3,16(r2)
 8243300:	e0bfff17 	ldw	r2,-4(fp)
 8243304:	10800617 	ldw	r2,24(r2)
 8243308:	10800e17 	ldw	r2,56(r2)
            goto ours;

         /* Make sure the packet is not a subnet broadcast for either the
          * source or destination network.
          */
         if((pip->ip_dest == outnet->n_netbr) ||
 824330c:	18805a26 	beq	r3,r2,8243478 <ip_rcv_phase2+0x4c8>
         {
            goto ours;            
         }

         /* Routed OK, prepare to send */
         p->net = outnet;           /* set iface to send on */
 8243310:	e0bfff17 	ldw	r2,-4(fp)
 8243314:	e0fffb17 	ldw	r3,-20(fp)
 8243318:	10c00615 	stw	r3,24(r2)
            }
         }
#endif   /* IPSEC */

         /* see if packet is too big for media of dest net */
         if ((p->nb_plen + p->net->n_lnh) > (unsigned)outnet->n_mtu)
 824331c:	e0bfff17 	ldw	r2,-4(fp)
 8243320:	10800417 	ldw	r2,16(r2)
 8243324:	e0ffff17 	ldw	r3,-4(fp)
 8243328:	18c00617 	ldw	r3,24(r3)
 824332c:	18c00817 	ldw	r3,32(r3)
 8243330:	10c5883a 	add	r2,r2,r3
 8243334:	e0fffb17 	ldw	r3,-20(fp)
 8243338:	18c00917 	ldw	r3,36(r3)
 824333c:	1880372e 	bgeu	r3,r2,824341c <ip_rcv_phase2+0x46c>
         {
#ifdef IP_FRAGMENTS
            /* see if we're not supposed to fragment it */
            if (ntohs(pip->ip_flgs_foff) & IP_FLG_DF)
 8243340:	e0bff817 	ldw	r2,-32(fp)
 8243344:	1080018b 	ldhu	r2,6(r2)
 8243348:	10bfffcc 	andi	r2,r2,65535
 824334c:	1004d23a 	srli	r2,r2,8
 8243350:	10bfffcc 	andi	r2,r2,65535
 8243354:	10c03fcc 	andi	r3,r2,255
 8243358:	e0bff817 	ldw	r2,-32(fp)
 824335c:	1080018b 	ldhu	r2,6(r2)
 8243360:	10bfffcc 	andi	r2,r2,65535
 8243364:	1004923a 	slli	r2,r2,8
 8243368:	10bfffcc 	andi	r2,r2,65535
 824336c:	1884b03a 	or	r2,r3,r2
 8243370:	1090000c 	andi	r2,r2,16384
 8243374:	10001c26 	beq	r2,zero,82433e8 <ip_rcv_phase2+0x438>
            {
#ifdef FULL_ICMP
               icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 8243378:	e0bff817 	ldw	r2,-32(fp)
 824337c:	10c00317 	ldw	r3,12(r2)
 8243380:	e0bfff17 	ldw	r2,-4(fp)
 8243384:	10800617 	ldw	r2,24(r2)
 8243388:	11000a17 	ldw	r4,40(r2)
 824338c:	e0bfff17 	ldw	r2,-4(fp)
 8243390:	10800617 	ldw	r2,24(r2)
 8243394:	d8800015 	stw	r2,0(sp)
 8243398:	01c00104 	movi	r7,4
 824339c:	e1bff817 	ldw	r6,-32(fp)
 82433a0:	200b883a 	mov	r5,r4
 82433a4:	1809883a 	mov	r4,r3
 82433a8:	824afc40 	call	824afc4 <icmp_destun>
#endif   /* FULL_ICMP */
               ip_mib.ipFragFails++;
 82433ac:	008209b4 	movhi	r2,2086
 82433b0:	10ba6104 	addi	r2,r2,-5756
 82433b4:	10801117 	ldw	r2,68(r2)
 82433b8:	10c00044 	addi	r3,r2,1
 82433bc:	008209b4 	movhi	r2,2086
 82433c0:	10ba6104 	addi	r2,r2,-5756
 82433c4:	10c01115 	stw	r3,68(r2)
               LOCK_NET_RESOURCE(FREEQ_RESID);
 82433c8:	01000084 	movi	r4,2
 82433cc:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
               pk_free(p);
 82433d0:	e13fff17 	ldw	r4,-4(fp)
 82433d4:	822cd3c0 	call	822cd3c <pk_free>
               UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82433d8:	01000084 	movi	r4,2
 82433dc:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
               IN_PROFILER(PF_IP, PF_EXIT);
               return ENP_LOGIC;
 82433e0:	00bffd44 	movi	r2,-11
 82433e4:	00006006 	br	8243568 <ip_rcv_phase2+0x5b8>
            }

            /* fall to here if we're going to fragment it. */
            pip->ip_time--;            /* datagram's hop count */
 82433e8:	e0bff817 	ldw	r2,-32(fp)
 82433ec:	10800203 	ldbu	r2,8(r2)
 82433f0:	10bfffc4 	addi	r2,r2,-1
 82433f4:	1007883a 	mov	r3,r2
 82433f8:	e0bff817 	ldw	r2,-32(fp)
 82433fc:	10c00205 	stb	r3,8(r2)
            err = ip_fragment(p, firsthop);
 8243400:	e0bffe17 	ldw	r2,-8(fp)
 8243404:	100b883a 	mov	r5,r2
 8243408:	e13fff17 	ldw	r4,-4(fp)
 824340c:	82403d80 	call	82403d8 <ip_fragment>
 8243410:	e0bffc15 	stw	r2,-16(fp)
            IN_PROFILER(PF_IP, PF_EXIT);
            return(err);
 8243414:	e0bffc17 	ldw	r2,-16(fp)
 8243418:	00005306 	br	8243568 <ip_rcv_phase2+0x5b8>
            pk_free(p);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
            return ENP_LOGIC;
#endif   /* IP_FRAGMENTS */
         }
         pip->ip_time--;            /* datagram's hop count */
 824341c:	e0bff817 	ldw	r2,-32(fp)
 8243420:	10800203 	ldbu	r2,8(r2)
 8243424:	10bfffc4 	addi	r2,r2,-1
 8243428:	1007883a 	mov	r3,r2
 824342c:	e0bff817 	ldw	r2,-32(fp)
 8243430:	10c00205 	stb	r3,8(r2)
         pip->ip_chksum = IPXSUM;   /* clear checksum field for summing */
 8243434:	e0bff817 	ldw	r2,-32(fp)
 8243438:	1000028d 	sth	zero,10(r2)
         pip->ip_chksum = ~cksum(pip, 10);   /* new xsum */
 824343c:	01400284 	movi	r5,10
 8243440:	e13ff817 	ldw	r4,-32(fp)
 8243444:	82287b40 	call	82287b4 <cksum>
 8243448:	0084303a 	nor	r2,zero,r2
 824344c:	1007883a 	mov	r3,r2
 8243450:	e0bff817 	ldw	r2,-32(fp)
 8243454:	10c0028d 	sth	r3,10(r2)
         IN_PROFILER(PF_IP, PF_EXIT);
#ifdef RF_SIMULATION
         if(rfsim_routing)
            return(rfsim_send(p, firsthop));
#endif   /* RF_SIMULATION */
         return(ip2mac(p, firsthop));
 8243458:	e0bffe17 	ldw	r2,-8(fp)
 824345c:	100b883a 	mov	r5,r2
 8243460:	e13fff17 	ldw	r4,-4(fp)
 8243464:	82266f80 	call	82266f8 <ip2mac>
 8243468:	00003f06 	br	8243568 <ip_rcv_phase2+0x5b8>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NOT_MINE);
      }
      else
         goto ours;
 824346c:	0001883a 	nop
 8243470:	00000106 	br	8243478 <ip_rcv_phase2+0x4c8>
          * addresses other than the interface it was received on. If so,
          * routing should have returned that interface and we can trap this
          * situation by checking the interfaces IP address.
          */
         if(pip->ip_dest == outnet->n_ipaddr)
            goto ours;
 8243474:	0001883a 	nop
#if defined (IP_MULTICAST) || defined (IP_ROUTING)
ours:
#endif

   /* Test for fragment: */
   tempsum = htons(pip->ip_flgs_foff); /* borrow cksum variable */
 8243478:	e0bff817 	ldw	r2,-32(fp)
 824347c:	1080018b 	ldhu	r2,6(r2)
 8243480:	10bfffcc 	andi	r2,r2,65535
 8243484:	1004d23a 	srli	r2,r2,8
 8243488:	1007883a 	mov	r3,r2
 824348c:	e0bff817 	ldw	r2,-32(fp)
 8243490:	1080018b 	ldhu	r2,6(r2)
 8243494:	10bfffcc 	andi	r2,r2,65535
 8243498:	1004923a 	slli	r2,r2,8
 824349c:	1884b03a 	or	r2,r3,r2
 82434a0:	e0bffd0d 	sth	r2,-12(fp)
   if ((tempsum & IP_FLG_MF) ||  /* IP flag for "More Fragments" set? */
 82434a4:	e0bffd0b 	ldhu	r2,-12(fp)
 82434a8:	1088000c 	andi	r2,r2,8192
 82434ac:	1000051e 	bne	r2,zero,82434c4 <ip_rcv_phase2+0x514>
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
 82434b0:	e0fffd0b 	ldhu	r3,-12(fp)
 82434b4:	00bffff4 	movhi	r2,65535
 82434b8:	1087ffc4 	addi	r2,r2,8191
 82434bc:	1884703a 	and	r2,r3,r2
ours:
#endif

   /* Test for fragment: */
   tempsum = htons(pip->ip_flgs_foff); /* borrow cksum variable */
   if ((tempsum & IP_FLG_MF) ||  /* IP flag for "More Fragments" set? */
 82434c0:	10002726 	beq	r2,zero,8243560 <ip_rcv_phase2+0x5b0>
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 82434c4:	d0a08317 	ldw	r2,-32244(gp)
 82434c8:	1081000c 	andi	r2,r2,1024
 82434cc:	10001a26 	beq	r2,zero,8243538 <ip_rcv_phase2+0x588>
 82434d0:	d0a08317 	ldw	r2,-32244(gp)
 82434d4:	1080800c 	andi	r2,r2,512
 82434d8:	10001726 	beq	r2,zero,8243538 <ip_rcv_phase2+0x588>
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
          PUSH_IPADDR(pip->ip_src));
 82434dc:	e0bff817 	ldw	r2,-32(fp)
 82434e0:	10800317 	ldw	r2,12(r2)
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 82434e4:	10c03fcc 	andi	r3,r2,255
          PUSH_IPADDR(pip->ip_src));
 82434e8:	e0bff817 	ldw	r2,-32(fp)
 82434ec:	10800317 	ldw	r2,12(r2)
 82434f0:	1004d23a 	srli	r2,r2,8
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 82434f4:	11003fcc 	andi	r4,r2,255
          PUSH_IPADDR(pip->ip_src));
 82434f8:	e0bff817 	ldw	r2,-32(fp)
 82434fc:	10800317 	ldw	r2,12(r2)
 8243500:	1004d43a 	srli	r2,r2,16
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 8243504:	11403fcc 	andi	r5,r2,255
          PUSH_IPADDR(pip->ip_src));
 8243508:	e0bff817 	ldw	r2,-32(fp)
 824350c:	10800317 	ldw	r2,12(r2)
 8243510:	1004d63a 	srli	r2,r2,24
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 8243514:	d8800015 	stw	r2,0(sp)
 8243518:	280f883a 	mov	r7,r5
 824351c:	200d883a 	mov	r6,r4
 8243520:	180b883a 	mov	r5,r3
 8243524:	01020974 	movhi	r4,2085
 8243528:	21055004 	addi	r4,r4,5440
 824352c:	82033a00 	call	82033a0 <printf>
          PUSH_IPADDR(pip->ip_src));
         ip_dump(p);
 8243530:	e13fff17 	ldw	r4,-4(fp)
 8243534:	8240a400 	call	8240a40 <ip_dump>
      }
#endif
      ip_mib.ipReasmReqds++;     /* got a reassemble request; ie a frag */
 8243538:	008209b4 	movhi	r2,2086
 824353c:	10ba6104 	addi	r2,r2,-5756
 8243540:	10800d17 	ldw	r2,52(r2)
 8243544:	10c00044 	addi	r3,r2,1
 8243548:	008209b4 	movhi	r2,2086
 824354c:	10ba6104 	addi	r2,r2,-5756
 8243550:	10c00d15 	stw	r3,52(r2)
#ifdef IP_FRAGMENTS
      return(ip_reassm(p));
 8243554:	e13fff17 	ldw	r4,-4(fp)
 8243558:	824160c0 	call	824160c <ip_reassm>
 824355c:	00000206 	br	8243568 <ip_rcv_phase2+0x5b8>
   {
      return ENP_LOGIC;
   }
#endif /* IPSEC */

   return(ip_demux(p));    /* demux to correct to upper layer */
 8243560:	e13fff17 	ldw	r4,-4(fp)
 8243564:	824357c0 	call	824357c <ip_demux>
}
 8243568:	e037883a 	mov	sp,fp
 824356c:	dfc00117 	ldw	ra,4(sp)
 8243570:	df000017 	ldw	fp,0(sp)
 8243574:	dec00204 	addi	sp,sp,8
 8243578:	f800283a 	ret

0824357c <ip_demux>:
 * RETURNS: Same return values as ip_rcv(). 
 */

int
ip_demux(PACKET p)
{
 824357c:	defff904 	addi	sp,sp,-28
 8243580:	dfc00615 	stw	ra,24(sp)
 8243584:	df000515 	stw	fp,20(sp)
 8243588:	df000504 	addi	fp,sp,20
 824358c:	e13fff15 	stw	r4,-4(fp)
   int   err;

   /* The packet is verified; the header is correct. Now we have
    * to demultiplex it among our internet connections.
    */
   pip = (struct ip *)(p->nb_prot);
 8243590:	e0bfff17 	ldw	r2,-4(fp)
 8243594:	10800317 	ldw	r2,12(r2)
 8243598:	e0bffe15 	stw	r2,-8(fp)

#ifdef NPDEBUG
   /* make sure the caller set p->nb_prot */
   if(pip->ip_ver_ihl != 0x45)
 824359c:	e0bffe17 	ldw	r2,-8(fp)
 82435a0:	10800003 	ldbu	r2,0(r2)
 82435a4:	10803fcc 	andi	r2,r2,255
 82435a8:	10801160 	cmpeqi	r2,r2,69
 82435ac:	1000131e 	bne	r2,zero,82435fc <ip_demux+0x80>
   {
      if((pip->ip_ver_ihl < 0x45) ||
 82435b0:	e0bffe17 	ldw	r2,-8(fp)
 82435b4:	10800003 	ldbu	r2,0(r2)
 82435b8:	10803fcc 	andi	r2,r2,255
 82435bc:	10801170 	cmpltui	r2,r2,69
 82435c0:	1000051e 	bne	r2,zero,82435d8 <ip_demux+0x5c>
         (pip->ip_ver_ihl > 0x47))
 82435c4:	e0bffe17 	ldw	r2,-8(fp)
 82435c8:	10800003 	ldbu	r2,0(r2)

#ifdef NPDEBUG
   /* make sure the caller set p->nb_prot */
   if(pip->ip_ver_ihl != 0x45)
   {
      if((pip->ip_ver_ihl < 0x45) ||
 82435cc:	10803fcc 	andi	r2,r2,255
 82435d0:	10801230 	cmpltui	r2,r2,72
 82435d4:	1000091e 	bne	r2,zero,82435fc <ip_demux+0x80>
         (pip->ip_ver_ihl > 0x47))
      {
         dprintf("ip_demux: bad IP type 0x%x\n", pip->ip_ver_ihl);
 82435d8:	e0bffe17 	ldw	r2,-8(fp)
 82435dc:	10800003 	ldbu	r2,0(r2)
 82435e0:	10803fcc 	andi	r2,r2,255
 82435e4:	100b883a 	mov	r5,r2
 82435e8:	01020974 	movhi	r4,2085
 82435ec:	21055904 	addi	r4,r4,5476
 82435f0:	82033a00 	call	82033a0 <printf>
         return ENP_LOGIC;
 82435f4:	00bffd44 	movi	r2,-11
 82435f8:	0000d006 	br	824393c <ip_demux+0x3c0>

   /* for profiling purposes count the upper layers (UDP, ICMP) in the IP
    * profile bucket. TCP will insert it's own nested profile calls 
    */
   IN_PROFILER(PF_IP, PF_ENTRY);
   p->fhost = pip->ip_src;
 82435fc:	e0bffe17 	ldw	r2,-8(fp)
 8243600:	10c00317 	ldw	r3,12(r2)
 8243604:	e0bfff17 	ldw	r2,-4(fp)
 8243608:	10c00715 	stw	r3,28(r2)

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 824360c:	d0a08317 	ldw	r2,-32244(gp)
 8243610:	1081000c 	andi	r2,r2,1024
 8243614:	10002126 	beq	r2,zero,824369c <ip_demux+0x120>
 8243618:	d0a08317 	ldw	r2,-32244(gp)
 824361c:	1080800c 	andi	r2,r2,512
 8243620:	10001e26 	beq	r2,zero,824369c <ip_demux+0x120>
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 8243624:	e0bffe17 	ldw	r2,-8(fp)
 8243628:	10800243 	ldbu	r2,9(r2)
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 824362c:	11003fcc 	andi	r4,r2,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 8243630:	e0bffe17 	ldw	r2,-8(fp)
 8243634:	10800317 	ldw	r2,12(r2)
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 8243638:	11403fcc 	andi	r5,r2,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 824363c:	e0bffe17 	ldw	r2,-8(fp)
 8243640:	10800317 	ldw	r2,12(r2)
 8243644:	1004d23a 	srli	r2,r2,8
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 8243648:	11803fcc 	andi	r6,r2,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 824364c:	e0bffe17 	ldw	r2,-8(fp)
 8243650:	10800317 	ldw	r2,12(r2)
 8243654:	1004d43a 	srli	r2,r2,16
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 8243658:	10803fcc 	andi	r2,r2,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 824365c:	e0fffe17 	ldw	r3,-8(fp)
 8243660:	18c00317 	ldw	r3,12(r3)
 8243664:	1806d63a 	srli	r3,r3,24
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 8243668:	d8c00115 	stw	r3,4(sp)
 824366c:	d8800015 	stw	r2,0(sp)
 8243670:	300f883a 	mov	r7,r6
 8243674:	280d883a 	mov	r6,r5
 8243678:	200b883a 	mov	r5,r4
 824367c:	01020974 	movhi	r4,2085
 8243680:	21056004 	addi	r4,r4,5504
 8243684:	82033a00 	call	82033a0 <printf>
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
      if (NDEBUG & DUMP) ip_dump(p);
 8243688:	d0a08317 	ldw	r2,-32244(gp)
 824368c:	1080008c 	andi	r2,r2,2
 8243690:	10000226 	beq	r2,zero,824369c <ip_demux+0x120>
 8243694:	e13fff17 	ldw	r4,-4(fp)
 8243698:	8240a400 	call	8240a40 <ip_dump>
   }
#endif

   switch (pip->ip_prot)
 824369c:	e0bffe17 	ldw	r2,-8(fp)
 82436a0:	10800243 	ldbu	r2,9(r2)
 82436a4:	10803fcc 	andi	r2,r2,255
 82436a8:	10c000a0 	cmpeqi	r3,r2,2
 82436ac:	18001f1e 	bne	r3,zero,824372c <ip_demux+0x1b0>
 82436b0:	10c000c8 	cmpgei	r3,r2,3
 82436b4:	1800031e 	bne	r3,zero,82436c4 <ip_demux+0x148>
 82436b8:	10800060 	cmpeqi	r2,r2,1
 82436bc:	1000101e 	bne	r2,zero,8243700 <ip_demux+0x184>
 82436c0:	00003006 	br	8243784 <ip_demux+0x208>
 82436c4:	10c001a0 	cmpeqi	r3,r2,6
 82436c8:	1800231e 	bne	r3,zero,8243758 <ip_demux+0x1dc>
 82436cc:	10800460 	cmpeqi	r2,r2,17
 82436d0:	10002c26 	beq	r2,zero,8243784 <ip_demux+0x208>
   {
   case UDP_PROT:
      ip_mib.ipInDelivers++;
 82436d4:	008209b4 	movhi	r2,2086
 82436d8:	10ba6104 	addi	r2,r2,-5756
 82436dc:	10800817 	ldw	r2,32(r2)
 82436e0:	10c00044 	addi	r3,r2,1
 82436e4:	008209b4 	movhi	r2,2086
 82436e8:	10ba6104 	addi	r2,r2,-5756
 82436ec:	10c00815 	stw	r3,32(r2)
      err = udpdemux(p);
 82436f0:	e13fff17 	ldw	r4,-4(fp)
 82436f4:	82448040 	call	8244804 <udpdemux>
 82436f8:	e0bffd15 	stw	r2,-12(fp)
      break;
 82436fc:	00002c06 	br	82437b0 <ip_demux+0x234>
   case ICMP_PROT:
      ip_mib.ipInDelivers++;
 8243700:	008209b4 	movhi	r2,2086
 8243704:	10ba6104 	addi	r2,r2,-5756
 8243708:	10800817 	ldw	r2,32(r2)
 824370c:	10c00044 	addi	r3,r2,1
 8243710:	008209b4 	movhi	r2,2086
 8243714:	10ba6104 	addi	r2,r2,-5756
 8243718:	10c00815 	stw	r3,32(r2)
      err = icmprcv(p);
 824371c:	e13fff17 	ldw	r4,-4(fp)
 8243720:	824a4600 	call	824a460 <icmprcv>
 8243724:	e0bffd15 	stw	r2,-12(fp)
      break;
 8243728:	00002106 	br	82437b0 <ip_demux+0x234>
#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   case IGMP_PROT:
      ip_mib.ipInDelivers++;
 824372c:	008209b4 	movhi	r2,2086
 8243730:	10ba6104 	addi	r2,r2,-5756
 8243734:	10800817 	ldw	r2,32(r2)
 8243738:	10c00044 	addi	r3,r2,1
 824373c:	008209b4 	movhi	r2,2086
 8243740:	10ba6104 	addi	r2,r2,-5756
 8243744:	10c00815 	stw	r3,32(r2)
      err = igmp_input(p);
 8243748:	e13fff17 	ldw	r4,-4(fp)
 824374c:	8226d900 	call	8226d90 <igmp_input>
 8243750:	e0bffd15 	stw	r2,-12(fp)
      break;
 8243754:	00001606 	br	82437b0 <ip_demux+0x234>
#endif   /* IP_MULTICAST and (IGMPv1 or IGMPv2) */
#ifdef INCLUDE_TCP
   case TCP_PROT:
      ip_mib.ipInDelivers++;
 8243758:	008209b4 	movhi	r2,2086
 824375c:	10ba6104 	addi	r2,r2,-5756
 8243760:	10800817 	ldw	r2,32(r2)
 8243764:	10c00044 	addi	r3,r2,1
 8243768:	008209b4 	movhi	r2,2086
 824376c:	10ba6104 	addi	r2,r2,-5756
 8243770:	10c00815 	stw	r3,32(r2)
      err = tcp_rcv(p);
 8243774:	e13fff17 	ldw	r4,-4(fp)
 8243778:	822ee040 	call	822ee04 <tcp_rcv>
 824377c:	e0bffd15 	stw	r2,-12(fp)
      break;
 8243780:	00000b06 	br	82437b0 <ip_demux+0x234>
      err = v6t_rcv(p);
      break;
#endif /* IPV6_TUNNEL */
   default: /* unknown upper protocol */
#ifdef IP_RAW
      ip_mib.ipInDelivers++;
 8243784:	008209b4 	movhi	r2,2086
 8243788:	10ba6104 	addi	r2,r2,-5756
 824378c:	10800817 	ldw	r2,32(r2)
 8243790:	10c00044 	addi	r3,r2,1
 8243794:	008209b4 	movhi	r2,2086
 8243798:	10ba6104 	addi	r2,r2,-5756
 824379c:	10c00815 	stw	r3,32(r2)
      err = ip_raw_input(p);
 82437a0:	e13fff17 	ldw	r4,-4(fp)
 82437a4:	8243e740 	call	8243e74 <ip_raw_input>
 82437a8:	e0bffd15 	stw	r2,-12(fp)
      break;
 82437ac:	0001883a 	nop
#endif /* IP_RAW */
   }

   IN_PROFILER(PF_IP, PF_EXIT);

   if(err != ENP_PARAM)
 82437b0:	e0bffd17 	ldw	r2,-12(fp)
 82437b4:	10bffda0 	cmpeqi	r2,r2,-10
 82437b8:	1000021e 	bne	r2,zero,82437c4 <ip_demux+0x248>
   {
      return err;
 82437bc:	e0bffd17 	ldw	r2,-12(fp)
 82437c0:	00005e06 	br	824393c <ip_demux+0x3c0>

#ifdef FULL_ICMP
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 82437c4:	e0bffe17 	ldw	r2,-8(fp)
 82437c8:	10800417 	ldw	r2,16(r2)
 82437cc:	10bfffe0 	cmpeqi	r2,r2,-1
 82437d0:	10004c1e 	bne	r2,zero,8243904 <ip_demux+0x388>
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
 82437d4:	e0bffe17 	ldw	r2,-8(fp)
 82437d8:	10800417 	ldw	r2,16(r2)
 82437dc:	1006d63a 	srli	r3,r2,24
 82437e0:	e0bffe17 	ldw	r2,-8(fp)
 82437e4:	10800417 	ldw	r2,16(r2)
 82437e8:	1004d23a 	srli	r2,r2,8
 82437ec:	10bfc00c 	andi	r2,r2,65280
 82437f0:	1886b03a 	or	r3,r3,r2
 82437f4:	e0bffe17 	ldw	r2,-8(fp)
 82437f8:	10800417 	ldw	r2,16(r2)
 82437fc:	10bfc00c 	andi	r2,r2,65280
 8243800:	1004923a 	slli	r2,r2,8
 8243804:	1886b03a 	or	r3,r3,r2
 8243808:	e0bffe17 	ldw	r2,-8(fp)
 824380c:	10800417 	ldw	r2,16(r2)
 8243810:	1004963a 	slli	r2,r2,24
 8243814:	1884b03a 	or	r2,r3,r2
 8243818:	10fc002c 	andhi	r3,r2,61440

#ifdef FULL_ICMP
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 824381c:	00b80034 	movhi	r2,57344
 8243820:	18803826 	beq	r3,r2,8243904 <ip_demux+0x388>
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
 8243824:	e0bffe17 	ldw	r2,-8(fp)
 8243828:	10c00417 	ldw	r3,16(r2)
 824382c:	e0bfff17 	ldw	r2,-4(fp)
 8243830:	10800617 	ldw	r2,24(r2)
 8243834:	10800e17 	ldw	r2,56(r2)
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
 8243838:	18803226 	beq	r3,r2,8243904 <ip_demux+0x388>
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
 824383c:	e0bffe17 	ldw	r2,-8(fp)
 8243840:	10c00417 	ldw	r3,16(r2)
 8243844:	e0bfff17 	ldw	r2,-4(fp)
 8243848:	10800617 	ldw	r2,24(r2)
 824384c:	10800f17 	ldw	r2,60(r2)
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
 8243850:	18802c26 	beq	r3,r2,8243904 <ip_demux+0x388>
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
 8243854:	e0bffe17 	ldw	r2,-8(fp)
 8243858:	10c00417 	ldw	r3,16(r2)
 824385c:	e0bfff17 	ldw	r2,-4(fp)
 8243860:	10800617 	ldw	r2,24(r2)
 8243864:	10801017 	ldw	r2,64(r2)
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
 8243868:	18802626 	beq	r3,r2,8243904 <ip_demux+0x388>
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
       (p->net->n_ipaddr ^ p->net->n_subnetbr))  /* Know our own host address? */
 824386c:	e0bfff17 	ldw	r2,-4(fp)
 8243870:	10800617 	ldw	r2,24(r2)
 8243874:	10c00a17 	ldw	r3,40(r2)
 8243878:	e0bfff17 	ldw	r2,-4(fp)
 824387c:	10800617 	ldw	r2,24(r2)
 8243880:	10801017 	ldw	r2,64(r2)
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
 8243884:	18801f26 	beq	r3,r2,8243904 <ip_demux+0x388>
       (p->net->n_ipaddr ^ p->net->n_subnetbr))  /* Know our own host address? */
   {

#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8243888:	d0a08317 	ldw	r2,-32244(gp)
 824388c:	1081000c 	andi	r2,r2,1024
 8243890:	10000f26 	beq	r2,zero,82438d0 <ip_demux+0x354>
 8243894:	d0a08317 	ldw	r2,-32244(gp)
 8243898:	1080800c 	andi	r2,r2,512
 824389c:	10000c26 	beq	r2,zero,82438d0 <ip_demux+0x354>
      {
         dprintf("ip_demux: unhandled prot %u\n", pip->ip_prot);
 82438a0:	e0bffe17 	ldw	r2,-8(fp)
 82438a4:	10800243 	ldbu	r2,9(r2)
 82438a8:	10803fcc 	andi	r2,r2,255
 82438ac:	100b883a 	mov	r5,r2
 82438b0:	01020974 	movhi	r4,2085
 82438b4:	21056a04 	addi	r4,r4,5544
 82438b8:	82033a00 	call	82033a0 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 82438bc:	d0a08317 	ldw	r2,-32244(gp)
 82438c0:	1080008c 	andi	r2,r2,2
 82438c4:	10000226 	beq	r2,zero,82438d0 <ip_demux+0x354>
 82438c8:	e13fff17 	ldw	r4,-4(fp)
 82438cc:	8240a400 	call	8240a40 <ip_dump>
      }
#endif   /* NPDEBUG */
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTPROT, p->net);
 82438d0:	e0bffe17 	ldw	r2,-8(fp)
 82438d4:	10c00317 	ldw	r3,12(r2)
 82438d8:	e0bfff17 	ldw	r2,-4(fp)
 82438dc:	10800617 	ldw	r2,24(r2)
 82438e0:	11000a17 	ldw	r4,40(r2)
 82438e4:	e0bfff17 	ldw	r2,-4(fp)
 82438e8:	10800617 	ldw	r2,24(r2)
 82438ec:	d8800015 	stw	r2,0(sp)
 82438f0:	01c00084 	movi	r7,2
 82438f4:	e1bffe17 	ldw	r6,-8(fp)
 82438f8:	200b883a 	mov	r5,r4
 82438fc:	1809883a 	mov	r4,r3
 8243900:	824afc40 	call	824afc4 <icmp_destun>
   }
#endif   /* FULL_ICMP */

   ip_mib.ipUnknownProtos++;
 8243904:	008209b4 	movhi	r2,2086
 8243908:	10ba6104 	addi	r2,r2,-5756
 824390c:	10800617 	ldw	r2,24(r2)
 8243910:	10c00044 	addi	r3,r2,1
 8243914:	008209b4 	movhi	r2,2086
 8243918:	10ba6104 	addi	r2,r2,-5756
 824391c:	10c00615 	stw	r3,24(r2)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8243920:	01000084 	movi	r4,2
 8243924:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   pk_free(p);
 8243928:	e13fff17 	ldw	r4,-4(fp)
 824392c:	822cd3c0 	call	822cd3c <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8243930:	01000084 	movi	r4,2
 8243934:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   return ENP_NOT_MINE;
 8243938:	00800084 	movi	r2,2
}
 824393c:	e037883a 	mov	sp,fp
 8243940:	dfc00117 	ldw	ra,4(sp)
 8243944:	df000017 	ldw	fp,0(sp)
 8243948:	dec00204 	addi	sp,sp,8
 824394c:	f800283a 	ret

08243950 <in_addmulti>:
 * RETURNS: 
 */

struct in_multi * 
in_addmulti(ip_addr *ap, struct net *netp, int addrtype)
{
 8243950:	defff904 	addi	sp,sp,-28
 8243954:	dfc00615 	stw	ra,24(sp)
 8243958:	df000515 	stw	fp,20(sp)
 824395c:	df000504 	addi	fp,sp,20
 8243960:	e13ffd15 	stw	r4,-12(fp)
 8243964:	e17ffe15 	stw	r5,-8(fp)
 8243968:	e1bfff15 	stw	r6,-4(fp)
   struct in_multi *inm = (struct in_multi *)NULL;
 824396c:	e03ffb15 	stw	zero,-20(fp)
   int error;

   /* check for good addr. */
   if ((ap == (ip_addr *)NULL) || (*ap == 0))
 8243970:	e0bffd17 	ldw	r2,-12(fp)
 8243974:	10000326 	beq	r2,zero,8243984 <in_addmulti+0x34>
 8243978:	e0bffd17 	ldw	r2,-12(fp)
 824397c:	10800017 	ldw	r2,0(r2)
 8243980:	1000021e 	bne	r2,zero,824398c <in_addmulti+0x3c>
      return ((struct in_multi *)NULL);  
 8243984:	0005883a 	mov	r2,zero
 8243988:	00003f06 	br	8243a88 <in_addmulti+0x138>

   ENTER_CRIT_SECTION(netp);
 824398c:	822d76c0 	call	822d76c <irq_Mask>
#ifdef IP_V6
   if(addrtype == 6)
      inm = v6_lookup_mcast((ip6_addr*)ap, netp);
#endif
#ifdef IP_V4
   if(addrtype != 6)
 8243990:	e0bfff17 	ldw	r2,-4(fp)
 8243994:	108001a0 	cmpeqi	r2,r2,6
 8243998:	1000061e 	bne	r2,zero,82439b4 <in_addmulti+0x64>
      inm = lookup_mcast(*ap, netp);
 824399c:	e0bffd17 	ldw	r2,-12(fp)
 82439a0:	10800017 	ldw	r2,0(r2)
 82439a4:	e17ffe17 	ldw	r5,-8(fp)
 82439a8:	1009883a 	mov	r4,r2
 82439ac:	8243ba80 	call	8243ba8 <lookup_mcast>
 82439b0:	e0bffb15 	stw	r2,-20(fp)
#endif

   if (inm != (struct in_multi *)NULL) 
 82439b4:	e0bffb17 	ldw	r2,-20(fp)
 82439b8:	10000626 	beq	r2,zero,82439d4 <in_addmulti+0x84>
   {
      /* Found it; just increment the reference count. */
      ++inm->inm_refcount;
 82439bc:	e0bffb17 	ldw	r2,-20(fp)
 82439c0:	10800217 	ldw	r2,8(r2)
 82439c4:	10c00044 	addi	r3,r2,1
 82439c8:	e0bffb17 	ldw	r2,-20(fp)
 82439cc:	10c00215 	stw	r3,8(r2)
 82439d0:	00002b06 	br	8243a80 <in_addmulti+0x130>
   {
      /*
       * New address; allocate a new multicast record
       * and link it into the interface's multicast list.
       */
      inm = (struct in_multi *)INM_ALLOC(sizeof(*inm));
 82439d4:	01000604 	movi	r4,24
 82439d8:	822e16c0 	call	822e16c <npalloc>
 82439dc:	e0bffb15 	stw	r2,-20(fp)

      if (inm == (struct in_multi *)NULL) 
 82439e0:	e0bffb17 	ldw	r2,-20(fp)
 82439e4:	1000031e 	bne	r2,zero,82439f4 <in_addmulti+0xa4>
      {
         EXIT_CRIT_SECTION(netp);
 82439e8:	822d7cc0 	call	822d7cc <irq_Unmask>
         return ((struct in_multi *)NULL);
 82439ec:	0005883a 	mov	r2,zero
 82439f0:	00002506 	br	8243a88 <in_addmulti+0x138>
#ifdef IP_V6
      if(addrtype == 6)
         IP6CPY(&inm->ip6addr, (struct in6_addr *)ap);
#endif
#ifdef IP_V4
      if(addrtype != 6)
 82439f4:	e0bfff17 	ldw	r2,-4(fp)
 82439f8:	108001a0 	cmpeqi	r2,r2,6
 82439fc:	1000041e 	bne	r2,zero,8243a10 <in_addmulti+0xc0>
         inm->inm_addr = *ap;
 8243a00:	e0bffd17 	ldw	r2,-12(fp)
 8243a04:	10c00017 	ldw	r3,0(r2)
 8243a08:	e0bffb17 	ldw	r2,-20(fp)
 8243a0c:	10c00015 	stw	r3,0(r2)
#endif
      inm->inm_netp = netp;
 8243a10:	e0bffb17 	ldw	r2,-20(fp)
 8243a14:	e0fffe17 	ldw	r3,-8(fp)
 8243a18:	10c00115 	stw	r3,4(r2)
      inm->inm_refcount = 1;
 8243a1c:	e0bffb17 	ldw	r2,-20(fp)
 8243a20:	00c00044 	movi	r3,1
 8243a24:	10c00215 	stw	r3,8(r2)
      inm->inm_next = netp->mc_list;
 8243a28:	e0bffe17 	ldw	r2,-8(fp)
 8243a2c:	10c02c17 	ldw	r3,176(r2)
 8243a30:	e0bffb17 	ldw	r2,-20(fp)
 8243a34:	10c00515 	stw	r3,20(r2)
      netp->mc_list = inm;
 8243a38:	e0bffe17 	ldw	r2,-8(fp)
 8243a3c:	e0fffb17 	ldw	r3,-20(fp)
 8243a40:	10c02c15 	stw	r3,176(r2)
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the new address.
       */
      if(netp->n_mcastlist)
 8243a44:	e0bffe17 	ldw	r2,-8(fp)
 8243a48:	10802b17 	ldw	r2,172(r2)
 8243a4c:	10000626 	beq	r2,zero,8243a68 <in_addmulti+0x118>
         error = netp->n_mcastlist(inm);
 8243a50:	e0bffe17 	ldw	r2,-8(fp)
 8243a54:	10802b17 	ldw	r2,172(r2)
 8243a58:	e13ffb17 	ldw	r4,-20(fp)
 8243a5c:	103ee83a 	callr	r2
 8243a60:	e0bffc15 	stw	r2,-16(fp)
 8243a64:	00000106 	br	8243a6c <in_addmulti+0x11c>
      else
         error = 0;
 8243a68:	e03ffc15 	stw	zero,-16(fp)
#if defined (IGMP_V1) || defined (IGMP_V2)
      /*
       * Let IGMP know that we have joined a new IP multicast group.
       */
      if (inm->inm_addr) igmp_joingroup(inm);
 8243a6c:	e0bffb17 	ldw	r2,-20(fp)
 8243a70:	10800017 	ldw	r2,0(r2)
 8243a74:	10000226 	beq	r2,zero,8243a80 <in_addmulti+0x130>
 8243a78:	e13ffb17 	ldw	r4,-20(fp)
 8243a7c:	82272800 	call	8227280 <igmp_joingroup>
#endif      
   }

   EXIT_CRIT_SECTION(netp);
 8243a80:	822d7cc0 	call	822d7cc <irq_Unmask>
   USE_ARG(error);

   return (inm);
 8243a84:	e0bffb17 	ldw	r2,-20(fp)
}
 8243a88:	e037883a 	mov	sp,fp
 8243a8c:	dfc00117 	ldw	ra,4(sp)
 8243a90:	df000017 	ldw	fp,0(sp)
 8243a94:	dec00204 	addi	sp,sp,8
 8243a98:	f800283a 	ret

08243a9c <in_delmulti>:
 * RETURNS: 
 */

void
in_delmulti(struct in_multi * inm)
{
 8243a9c:	defffa04 	addi	sp,sp,-24
 8243aa0:	dfc00515 	stw	ra,20(sp)
 8243aa4:	df000415 	stw	fp,16(sp)
 8243aa8:	df000404 	addi	fp,sp,16
 8243aac:	e13fff15 	stw	r4,-4(fp)
   struct in_multi * p;
   NET         netp = inm->inm_netp;
 8243ab0:	e0bfff17 	ldw	r2,-4(fp)
 8243ab4:	10800117 	ldw	r2,4(r2)
 8243ab8:	e0bffe15 	stw	r2,-8(fp)
   int error;

   ENTER_CRIT_SECTION(inm);
 8243abc:	822d76c0 	call	822d76c <irq_Mask>
   if (--inm->inm_refcount == 0) 
 8243ac0:	e0bfff17 	ldw	r2,-4(fp)
 8243ac4:	10800217 	ldw	r2,8(r2)
 8243ac8:	10ffffc4 	addi	r3,r2,-1
 8243acc:	e0bfff17 	ldw	r2,-4(fp)
 8243ad0:	10c00215 	stw	r3,8(r2)
 8243ad4:	e0bfff17 	ldw	r2,-4(fp)
 8243ad8:	10800217 	ldw	r2,8(r2)
 8243adc:	10002b1e 	bne	r2,zero,8243b8c <in_delmulti+0xf0>
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 8243ae0:	e0bffe17 	ldw	r2,-8(fp)
 8243ae4:	10802c17 	ldw	r2,176(r2)
 8243ae8:	e0bffc15 	stw	r2,-16(fp)
 8243aec:	00001406 	br	8243b40 <in_delmulti+0xa4>
      {
         if(p == inm)   /* inm is first in mc_list */
 8243af0:	e0fffc17 	ldw	r3,-16(fp)
 8243af4:	e0bfff17 	ldw	r2,-4(fp)
 8243af8:	1880051e 	bne	r3,r2,8243b10 <in_delmulti+0x74>
         {
            netp->mc_list = p->inm_next;  /* unlink */
 8243afc:	e0bffc17 	ldw	r2,-16(fp)
 8243b00:	10c00517 	ldw	r3,20(r2)
 8243b04:	e0bffe17 	ldw	r2,-8(fp)
 8243b08:	10c02c15 	stw	r3,176(r2)
            break;
 8243b0c:	00000e06 	br	8243b48 <in_delmulti+0xac>
         }
         else if(p->inm_next == inm)   /* inm is next */
 8243b10:	e0bffc17 	ldw	r2,-16(fp)
 8243b14:	10c00517 	ldw	r3,20(r2)
 8243b18:	e0bfff17 	ldw	r2,-4(fp)
 8243b1c:	1880051e 	bne	r3,r2,8243b34 <in_delmulti+0x98>
         {
            p->inm_next = inm->inm_next;  /* unlink */
 8243b20:	e0bfff17 	ldw	r2,-4(fp)
 8243b24:	10c00517 	ldw	r3,20(r2)
 8243b28:	e0bffc17 	ldw	r2,-16(fp)
 8243b2c:	10c00515 	stw	r3,20(r2)
            break;
 8243b30:	00000506 	br	8243b48 <in_delmulti+0xac>

   ENTER_CRIT_SECTION(inm);
   if (--inm->inm_refcount == 0) 
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 8243b34:	e0bffc17 	ldw	r2,-16(fp)
 8243b38:	10800517 	ldw	r2,20(r2)
 8243b3c:	e0bffc15 	stw	r2,-16(fp)
 8243b40:	e0bffc17 	ldw	r2,-16(fp)
 8243b44:	103fea1e 	bne	r2,zero,8243af0 <in_delmulti+0x54>
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the deleted address.
       */
      if(netp->n_mcastlist)
 8243b48:	e0bffe17 	ldw	r2,-8(fp)
 8243b4c:	10802b17 	ldw	r2,172(r2)
 8243b50:	10000626 	beq	r2,zero,8243b6c <in_delmulti+0xd0>
         error = netp->n_mcastlist(inm);
 8243b54:	e0bffe17 	ldw	r2,-8(fp)
 8243b58:	10802b17 	ldw	r2,172(r2)
 8243b5c:	e13fff17 	ldw	r4,-4(fp)
 8243b60:	103ee83a 	callr	r2
 8243b64:	e0bffd15 	stw	r2,-12(fp)
 8243b68:	00000106 	br	8243b70 <in_delmulti+0xd4>
      else
         error = 0;
 8243b6c:	e03ffd15 	stw	zero,-12(fp)
#if defined (IGMP_V2)
      /*
       * No remaining claims to this record; let IGMP know that
       * we are leaving the multicast group.
       */
      if (inm->inm_addr) igmp_leavegroup(inm);
 8243b70:	e0bfff17 	ldw	r2,-4(fp)
 8243b74:	10800017 	ldw	r2,0(r2)
 8243b78:	10000226 	beq	r2,zero,8243b84 <in_delmulti+0xe8>
 8243b7c:	e13fff17 	ldw	r4,-4(fp)
 8243b80:	82274d40 	call	82274d4 <igmp_leavegroup>
#endif      

      IM_FREE(inm);
 8243b84:	e13fff17 	ldw	r4,-4(fp)
 8243b88:	822e1a00 	call	822e1a0 <npfree>
   }

   EXIT_CRIT_SECTION(inm);
 8243b8c:	822d7cc0 	call	822d7cc <irq_Unmask>
   USE_ARG(error);
}
 8243b90:	0001883a 	nop
 8243b94:	e037883a 	mov	sp,fp
 8243b98:	dfc00117 	ldw	ra,4(sp)
 8243b9c:	df000017 	ldw	fp,0(sp)
 8243ba0:	dec00204 	addi	sp,sp,8
 8243ba4:	f800283a 	ret

08243ba8 <lookup_mcast>:
 * RETURNS: pointer to mcast addr structure, or NULL if not found.
 */

struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
 8243ba8:	defffc04 	addi	sp,sp,-16
 8243bac:	df000315 	stw	fp,12(sp)
 8243bb0:	df000304 	addi	fp,sp,12
 8243bb4:	e13ffe15 	stw	r4,-8(fp)
 8243bb8:	e17fff15 	stw	r5,-4(fp)
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 8243bbc:	e0bfff17 	ldw	r2,-4(fp)
 8243bc0:	10802c17 	ldw	r2,176(r2)
 8243bc4:	e0bffd15 	stw	r2,-12(fp)
 8243bc8:	00000906 	br	8243bf0 <lookup_mcast+0x48>
   {
      if(imp->inm_addr == addr)
 8243bcc:	e0bffd17 	ldw	r2,-12(fp)
 8243bd0:	10c00017 	ldw	r3,0(r2)
 8243bd4:	e0bffe17 	ldw	r2,-8(fp)
 8243bd8:	1880021e 	bne	r3,r2,8243be4 <lookup_mcast+0x3c>
         return imp;
 8243bdc:	e0bffd17 	ldw	r2,-12(fp)
 8243be0:	00000606 	br	8243bfc <lookup_mcast+0x54>
struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 8243be4:	e0bffd17 	ldw	r2,-12(fp)
 8243be8:	10800517 	ldw	r2,20(r2)
 8243bec:	e0bffd15 	stw	r2,-12(fp)
 8243bf0:	e0bffd17 	ldw	r2,-12(fp)
 8243bf4:	103ff51e 	bne	r2,zero,8243bcc <lookup_mcast+0x24>
   {
      if(imp->inm_addr == addr)
         return imp;
   }
   return NULL;   /* addr not found in mcast list */
 8243bf8:	0005883a 	mov	r2,zero
}
 8243bfc:	e037883a 	mov	sp,fp
 8243c00:	df000017 	ldw	fp,0(sp)
 8243c04:	dec00104 	addi	sp,sp,4
 8243c08:	f800283a 	ret

08243c0c <prep_ifaces>:
 * passed value. 
 */

int
prep_ifaces(int ifaces_found)
{
 8243c0c:	defffd04 	addi	sp,sp,-12
 8243c10:	dfc00215 	stw	ra,8(sp)
 8243c14:	df000115 	stw	fp,4(sp)
 8243c18:	df000104 	addi	fp,sp,4
 8243c1c:	e13fff15 	stw	r4,-4(fp)
   if (port_prep)
 8243c20:	d0a0ca17 	ldw	r2,-31960(gp)
 8243c24:	10000426 	beq	r2,zero,8243c38 <prep_ifaces+0x2c>
      ifaces_found = port_prep(ifaces_found);
 8243c28:	d0a0ca17 	ldw	r2,-31960(gp)
 8243c2c:	e13fff17 	ldw	r4,-4(fp)
 8243c30:	103ee83a 	callr	r2
 8243c34:	e0bfff15 	stw	r2,-4(fp)

#ifdef MAC_LOOPBACK
   ifaces_found = prep_lb(ifaces_found);
#endif   /* MAC_LOOPBACK */

   ifNumber = ifaces_found;   /* set global interface counter */
 8243c38:	e0bfff17 	ldw	r2,-4(fp)
 8243c3c:	d0a08415 	stw	r2,-32240(gp)

   initmsg("prepped %u interface%s, initializing...\n", 
 8243c40:	e0bfff17 	ldw	r2,-4(fp)
 8243c44:	10800058 	cmpnei	r2,r2,1
 8243c48:	1000031e 	bne	r2,zero,8243c58 <prep_ifaces+0x4c>
 8243c4c:	00820974 	movhi	r2,2085
 8243c50:	10857204 	addi	r2,r2,5576
 8243c54:	00000206 	br	8243c60 <prep_ifaces+0x54>
 8243c58:	00820974 	movhi	r2,2085
 8243c5c:	10857304 	addi	r2,r2,5580
 8243c60:	100d883a 	mov	r6,r2
 8243c64:	e17fff17 	ldw	r5,-4(fp)
 8243c68:	01020974 	movhi	r4,2085
 8243c6c:	21057404 	addi	r4,r4,5584
 8243c70:	82033a00 	call	82033a0 <printf>
      ifaces_found, ifaces_found==1?"":"s");

   return ifaces_found;
 8243c74:	e0bfff17 	ldw	r2,-4(fp)
}
 8243c78:	e037883a 	mov	sp,fp
 8243c7c:	dfc00117 	ldw	ra,4(sp)
 8243c80:	df000017 	ldw	fp,0(sp)
 8243c84:	dec00204 	addi	sp,sp,8
 8243c88:	f800283a 	ret

08243c8c <netexit>:
 * RETURNS: SHould not return
 */

void
netexit(int err)      /* exit error level */
{
 8243c8c:	defffd04 	addi	sp,sp,-12
 8243c90:	dfc00215 	stw	ra,8(sp)
 8243c94:	df000115 	stw	fp,4(sp)
 8243c98:	df000104 	addi	fp,sp,4
 8243c9c:	e13fff15 	stw	r4,-4(fp)
   net_system_exit = TRUE; /* set flag for shutting down */
 8243ca0:	00800044 	movi	r2,1
 8243ca4:	d0a0cb15 	stw	r2,-31956(gp)
   ip_exit();  /* do the exit_hook()ed stuff */
 8243ca8:	8226b980 	call	8226b98 <ip_exit>

   PORT_EXIT_FUNC(err);    /* should not return! */
 8243cac:	e13fff17 	ldw	r4,-4(fp)
 8243cb0:	824b6580 	call	824b658 <exit>

08243cb4 <evtmap_setup>:
 * INPUT: None.
 * OUTPUT: None
 */
 
void evtmap_setup (void)
{
 8243cb4:	deffff04 	addi	sp,sp,-4
 8243cb8:	df000015 	stw	fp,0(sp)
 8243cbc:	d839883a 	mov	fp,sp
#ifdef SOCK_MAP_EVENTS
   so_evtmap = TRUE;
   so_evtmap_create = evtmap_create;
   so_evtmap_delete = evtmap_delete;
#else
   so_evtmap = FALSE;
 8243cc0:	d020ce05 	stb	zero,-31944(gp)
   so_evtmap_create = 0;
 8243cc4:	d020cc15 	stw	zero,-31952(gp)
   so_evtmap_delete = 0;
 8243cc8:	d020cd15 	stw	zero,-31948(gp)
#endif   /* SOCK_MAP_EVENTS */ 

}
 8243ccc:	0001883a 	nop
 8243cd0:	e037883a 	mov	sp,fp
 8243cd4:	df000017 	ldw	fp,0(sp)
 8243cd8:	dec00104 	addi	sp,sp,4
 8243cdc:	f800283a 	ret

08243ce0 <ip_raw_open>:
ip_raw_open(u_char prot,
            ip_addr laddr,
            ip_addr faddr,
            int (*handler)(PACKET, void *),
            void * data)
{
 8243ce0:	defff904 	addi	sp,sp,-28
 8243ce4:	dfc00615 	stw	ra,24(sp)
 8243ce8:	df000515 	stw	fp,20(sp)
 8243cec:	df000504 	addi	fp,sp,20
 8243cf0:	2005883a 	mov	r2,r4
 8243cf4:	e17ffd15 	stw	r5,-12(fp)
 8243cf8:	e1bffe15 	stw	r6,-8(fp)
 8243cfc:	e1ffff15 	stw	r7,-4(fp)
 8243d00:	e0bffc05 	stb	r2,-16(fp)
   struct ipraw_ep * ep;

   LOCK_NET_RESOURCE(NET_RESID);
 8243d04:	0009883a 	mov	r4,zero
 8243d08:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>

   /* allocate a structure for the endpoint */
   ep = (struct ipraw_ep *)IEP_ALLOC(sizeof(struct ipraw_ep));
 8243d0c:	01000604 	movi	r4,24
 8243d10:	822e16c0 	call	822e16c <npalloc>
 8243d14:	e0bffb15 	stw	r2,-20(fp)
   if (ep == NULL)
 8243d18:	e0bffb17 	ldw	r2,-20(fp)
 8243d1c:	10000a1e 	bne	r2,zero,8243d48 <ip_raw_open+0x68>
   {
#ifdef NPDEBUG
      if (NDEBUG & INFOMSG)
 8243d20:	d0a08317 	ldw	r2,-32244(gp)
 8243d24:	1080010c 	andi	r2,r2,4
 8243d28:	10000326 	beq	r2,zero,8243d38 <ip_raw_open+0x58>
         dprintf("IP: Couldn't allocate ep storage.\n");
 8243d2c:	01020974 	movhi	r4,2085
 8243d30:	21057f04 	addi	r4,r4,5628
 8243d34:	82036240 	call	8203624 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 8243d38:	0009883a 	mov	r4,zero
 8243d3c:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return ep;
 8243d40:	e0bffb17 	ldw	r2,-20(fp)
 8243d44:	00001706 	br	8243da4 <ip_raw_open+0xc4>
   }

   /* fill it in with the caller's requested binding */
   ep->ipr_laddr = laddr;
 8243d48:	e0bffb17 	ldw	r2,-20(fp)
 8243d4c:	e0fffd17 	ldw	r3,-12(fp)
 8243d50:	10c00115 	stw	r3,4(r2)
   ep->ipr_faddr = faddr;
 8243d54:	e0bffb17 	ldw	r2,-20(fp)
 8243d58:	e0fffe17 	ldw	r3,-8(fp)
 8243d5c:	10c00215 	stw	r3,8(r2)
   ep->ipr_prot = prot;
 8243d60:	e0bffb17 	ldw	r2,-20(fp)
 8243d64:	e0fffc03 	ldbu	r3,-16(fp)
 8243d68:	10c00505 	stb	r3,20(r2)
   ep->ipr_rcv = handler;
 8243d6c:	e0bffb17 	ldw	r2,-20(fp)
 8243d70:	e0ffff17 	ldw	r3,-4(fp)
 8243d74:	10c00315 	stw	r3,12(r2)
   ep->ipr_data = data;
 8243d78:	e0bffb17 	ldw	r2,-20(fp)
 8243d7c:	e0c00217 	ldw	r3,8(fp)
 8243d80:	10c00415 	stw	r3,16(r2)

   /* link it into the list 
    * (at the head, because that's simple and fast) 
    */
   ep->ipr_next = ipraw_eps;
 8243d84:	d0e0cf17 	ldw	r3,-31940(gp)
 8243d88:	e0bffb17 	ldw	r2,-20(fp)
 8243d8c:	10c00015 	stw	r3,0(r2)
   ipraw_eps = ep;
 8243d90:	e0bffb17 	ldw	r2,-20(fp)
 8243d94:	d0a0cf15 	stw	r2,-31940(gp)

   /* and return the pointer to the endpoint */
   UNLOCK_NET_RESOURCE(NET_RESID);
 8243d98:	0009883a 	mov	r4,zero
 8243d9c:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   return ep;
 8243da0:	e0bffb17 	ldw	r2,-20(fp)
}
 8243da4:	e037883a 	mov	sp,fp
 8243da8:	dfc00117 	ldw	ra,4(sp)
 8243dac:	df000017 	ldw	fp,0(sp)
 8243db0:	dec00204 	addi	sp,sp,8
 8243db4:	f800283a 	ret

08243db8 <ip_raw_close>:
 *                               that is to be closed
 * RETURNS: void
 */
void
ip_raw_close(struct ipraw_ep * ep)
{
 8243db8:	defffb04 	addi	sp,sp,-20
 8243dbc:	dfc00415 	stw	ra,16(sp)
 8243dc0:	df000315 	stw	fp,12(sp)
 8243dc4:	df000304 	addi	fp,sp,12
 8243dc8:	e13fff15 	stw	r4,-4(fp)
   struct ipraw_ep * prev_ep;
   struct ipraw_ep * curr_ep;

   LOCK_NET_RESOURCE(NET_RESID);
 8243dcc:	0009883a 	mov	r4,zero
 8243dd0:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
 8243dd4:	e03ffd15 	stw	zero,-12(fp)
 8243dd8:	d0a0cf17 	ldw	r2,-31940(gp)
 8243ddc:	e0bffe15 	stw	r2,-8(fp)
 8243de0:	00000806 	br	8243e04 <ip_raw_close+0x4c>
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
   {
      if (curr_ep == ep)
 8243de4:	e0fffe17 	ldw	r3,-8(fp)
 8243de8:	e0bfff17 	ldw	r2,-4(fp)
 8243dec:	18800826 	beq	r3,r2,8243e10 <ip_raw_close+0x58>
         break;
      prev_ep = curr_ep;
 8243df0:	e0bffe17 	ldw	r2,-8(fp)
 8243df4:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
 8243df8:	e0bffe17 	ldw	r2,-8(fp)
 8243dfc:	10800017 	ldw	r2,0(r2)
 8243e00:	e0bffe15 	stw	r2,-8(fp)
   struct ipraw_ep * curr_ep;

   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
 8243e04:	e0bffe17 	ldw	r2,-8(fp)
 8243e08:	103ff61e 	bne	r2,zero,8243de4 <ip_raw_close+0x2c>
 8243e0c:	00000106 	br	8243e14 <ip_raw_close+0x5c>
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
   {
      if (curr_ep == ep)
         break;
 8243e10:	0001883a 	nop
      prev_ep = curr_ep;
   }

   /* if we didn't find it, we can't close it, so just return */
   if (curr_ep == NULL)
 8243e14:	e0bffe17 	ldw	r2,-8(fp)
 8243e18:	1000041e 	bne	r2,zero,8243e2c <ip_raw_close+0x74>
   {
#ifdef NPDEBUG
      /* caller passed pointer to endpoint not in list 
       * -- not fatal, but may be programming error
       */
      dtrap();
 8243e1c:	822d5940 	call	822d594 <dtrap>
#endif /* NPDEBUG */
      UNLOCK_NET_RESOURCE(NET_RESID);
 8243e20:	0009883a 	mov	r4,zero
 8243e24:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return;
 8243e28:	00000d06 	br	8243e60 <ip_raw_close+0xa8>
   }

   /* unlink it from the list */
   if (prev_ep)
 8243e2c:	e0bffd17 	ldw	r2,-12(fp)
 8243e30:	10000426 	beq	r2,zero,8243e44 <ip_raw_close+0x8c>
      prev_ep = curr_ep->ipr_next;
 8243e34:	e0bffe17 	ldw	r2,-8(fp)
 8243e38:	10800017 	ldw	r2,0(r2)
 8243e3c:	e0bffd15 	stw	r2,-12(fp)
 8243e40:	00000306 	br	8243e50 <ip_raw_close+0x98>
   else
      ipraw_eps = curr_ep->ipr_next;
 8243e44:	e0bffe17 	ldw	r2,-8(fp)
 8243e48:	10800017 	ldw	r2,0(r2)
 8243e4c:	d0a0cf15 	stw	r2,-31940(gp)

   /* free its storage */
   IEP_FREE(curr_ep);
 8243e50:	e13ffe17 	ldw	r4,-8(fp)
 8243e54:	822e1a00 	call	822e1a0 <npfree>

   /* and return */
   UNLOCK_NET_RESOURCE(NET_RESID);
 8243e58:	0009883a 	mov	r4,zero
 8243e5c:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
}
 8243e60:	e037883a 	mov	sp,fp
 8243e64:	dfc00117 	ldw	ra,4(sp)
 8243e68:	df000017 	ldw	fp,0(sp)
 8243e6c:	dec00204 	addi	sp,sp,8
 8243e70:	f800283a 	ret

08243e74 <ip_raw_input>:
 *          freed); else an error code indicating that the
 *          received packet was not accepted/processed
 */
int
ip_raw_input(PACKET p)
{
 8243e74:	defff604 	addi	sp,sp,-40
 8243e78:	dfc00915 	stw	ra,36(sp)
 8243e7c:	df000815 	stw	fp,32(sp)
 8243e80:	df000804 	addi	fp,sp,32
 8243e84:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;              /* the internet header */
   struct ipraw_ep * ep;
   struct ipraw_ep * next_ep;
   struct ipraw_ep * matched_ep = NULL;
 8243e88:	e03ff915 	stw	zero,-28(fp)
   int err;
   int delivered;

   /* start out expecting to not deliver the packet */
   delivered = 0;
 8243e8c:	e03ffb15 	stw	zero,-20(fp)

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);
 8243e90:	e0bfff17 	ldw	r2,-4(fp)
 8243e94:	10800317 	ldw	r2,12(r2)
 8243e98:	e0bffc15 	stw	r2,-16(fp)

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 8243e9c:	d0a0cf17 	ldw	r2,-31940(gp)
 8243ea0:	e0bff815 	stw	r2,-32(fp)
 8243ea4:	00004c06 	br	8243fd8 <ip_raw_input+0x164>
   {
      /* keep track of next endpoint -- defense against upcall
       * function closing its own endpoint
       */
      next_ep = ep->ipr_next;
 8243ea8:	e0bff817 	ldw	r2,-32(fp)
 8243eac:	10800017 	ldw	r2,0(r2)
 8243eb0:	e0bffd15 	stw	r2,-12(fp)

      /* if this packet doesn't match the endpoint's filters (IP
       * protocol ID, locally-bound address, connected-peer address)
       * then skip ahead to next endpoint
       */
      if (ep->ipr_prot && ep->ipr_prot != pip->ip_prot)
 8243eb4:	e0bff817 	ldw	r2,-32(fp)
 8243eb8:	10800503 	ldbu	r2,20(r2)
 8243ebc:	10803fcc 	andi	r2,r2,255
 8243ec0:	10000726 	beq	r2,zero,8243ee0 <ip_raw_input+0x6c>
 8243ec4:	e0bff817 	ldw	r2,-32(fp)
 8243ec8:	10c00503 	ldbu	r3,20(r2)
 8243ecc:	e0bffc17 	ldw	r2,-16(fp)
 8243ed0:	10800243 	ldbu	r2,9(r2)
 8243ed4:	18c03fcc 	andi	r3,r3,255
 8243ed8:	10803fcc 	andi	r2,r2,255
 8243edc:	1880371e 	bne	r3,r2,8243fbc <ip_raw_input+0x148>
         continue;
      if (ep->ipr_laddr && ep->ipr_laddr != pip->ip_dest)
 8243ee0:	e0bff817 	ldw	r2,-32(fp)
 8243ee4:	10800117 	ldw	r2,4(r2)
 8243ee8:	10000526 	beq	r2,zero,8243f00 <ip_raw_input+0x8c>
 8243eec:	e0bff817 	ldw	r2,-32(fp)
 8243ef0:	10c00117 	ldw	r3,4(r2)
 8243ef4:	e0bffc17 	ldw	r2,-16(fp)
 8243ef8:	10800417 	ldw	r2,16(r2)
 8243efc:	1880311e 	bne	r3,r2,8243fc4 <ip_raw_input+0x150>
         continue;
      if (ep->ipr_faddr && ep->ipr_faddr != pip->ip_src)
 8243f00:	e0bff817 	ldw	r2,-32(fp)
 8243f04:	10800217 	ldw	r2,8(r2)
 8243f08:	10000526 	beq	r2,zero,8243f20 <ip_raw_input+0xac>
 8243f0c:	e0bff817 	ldw	r2,-32(fp)
 8243f10:	10c00217 	ldw	r3,8(r2)
 8243f14:	e0bffc17 	ldw	r2,-16(fp)
 8243f18:	10800317 	ldw	r2,12(r2)
 8243f1c:	18802b1e 	bne	r3,r2,8243fcc <ip_raw_input+0x158>
         continue;

      /* if the endpoint has a receive upcall function, 
       * keep track of the endpoint
       */
      if (ep->ipr_rcv != NULL)
 8243f20:	e0bff817 	ldw	r2,-32(fp)
 8243f24:	10800317 	ldw	r2,12(r2)
 8243f28:	10002926 	beq	r2,zero,8243fd0 <ip_raw_input+0x15c>
          * copy the packet into a new buffer,
          * and pass the new copy to the previously matched 
          * endpoint's upcall function 
          * before we forget the previous endpoint
          */
         if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 8243f2c:	e0bff917 	ldw	r2,-28(fp)
 8243f30:	10001f26 	beq	r2,zero,8243fb0 <ip_raw_input+0x13c>
 8243f34:	e0bff917 	ldw	r2,-28(fp)
 8243f38:	10800317 	ldw	r2,12(r2)
 8243f3c:	10001c26 	beq	r2,zero,8243fb0 <ip_raw_input+0x13c>
         {
            PACKET p2;

            p2 = ip_copypkt(p);
 8243f40:	e13fff17 	ldw	r4,-4(fp)
 8243f44:	8240ec00 	call	8240ec0 <ip_copypkt>
 8243f48:	e0bffe15 	stw	r2,-8(fp)
            if (p2)
 8243f4c:	e0bffe17 	ldw	r2,-8(fp)
 8243f50:	10001726 	beq	r2,zero,8243fb0 <ip_raw_input+0x13c>
            {
               UNLOCK_NET_RESOURCE(NET_RESID);
 8243f54:	0009883a 	mov	r4,zero
 8243f58:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
               err = ((*matched_ep->ipr_rcv)(p2, matched_ep->ipr_data));
 8243f5c:	e0bff917 	ldw	r2,-28(fp)
 8243f60:	10800317 	ldw	r2,12(r2)
 8243f64:	e0fff917 	ldw	r3,-28(fp)
 8243f68:	18c00417 	ldw	r3,16(r3)
 8243f6c:	180b883a 	mov	r5,r3
 8243f70:	e13ffe17 	ldw	r4,-8(fp)
 8243f74:	103ee83a 	callr	r2
 8243f78:	e0bffa15 	stw	r2,-24(fp)
               LOCK_NET_RESOURCE(NET_RESID);
 8243f7c:	0009883a 	mov	r4,zero
 8243f80:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
               if (err)
 8243f84:	e0bffa17 	ldw	r2,-24(fp)
 8243f88:	10000726 	beq	r2,zero,8243fa8 <ip_raw_input+0x134>
               {
                  LOCK_NET_RESOURCE(FREEQ_RESID);
 8243f8c:	01000084 	movi	r4,2
 8243f90:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
                  pk_free(p2);
 8243f94:	e13ffe17 	ldw	r4,-8(fp)
 8243f98:	822cd3c0 	call	822cd3c <pk_free>
                  UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8243f9c:	01000084 	movi	r4,2
 8243fa0:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
 8243fa4:	00000206 	br	8243fb0 <ip_raw_input+0x13c>
               }
               else
                  delivered = 1;
 8243fa8:	00800044 	movi	r2,1
 8243fac:	e0bffb15 	stw	r2,-20(fp)
            }
         }
         matched_ep = ep;
 8243fb0:	e0bff817 	ldw	r2,-32(fp)
 8243fb4:	e0bff915 	stw	r2,-28(fp)
 8243fb8:	00000506 	br	8243fd0 <ip_raw_input+0x15c>
      /* if this packet doesn't match the endpoint's filters (IP
       * protocol ID, locally-bound address, connected-peer address)
       * then skip ahead to next endpoint
       */
      if (ep->ipr_prot && ep->ipr_prot != pip->ip_prot)
         continue;
 8243fbc:	0001883a 	nop
 8243fc0:	00000306 	br	8243fd0 <ip_raw_input+0x15c>
      if (ep->ipr_laddr && ep->ipr_laddr != pip->ip_dest)
         continue;
 8243fc4:	0001883a 	nop
 8243fc8:	00000106 	br	8243fd0 <ip_raw_input+0x15c>
      if (ep->ipr_faddr && ep->ipr_faddr != pip->ip_src)
         continue;
 8243fcc:	0001883a 	nop

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 8243fd0:	e0bffd17 	ldw	r2,-12(fp)
 8243fd4:	e0bff815 	stw	r2,-32(fp)
 8243fd8:	e0bff817 	ldw	r2,-32(fp)
 8243fdc:	103fb21e 	bne	r2,zero,8243ea8 <ip_raw_input+0x34>
   /* if we matched an endpoint, 
    * pass the packet to its upcall function
    * otherwise, return ENP_PARAM to indicate that the
    * packet was not processed and freed
    */
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 8243fe0:	e0bff917 	ldw	r2,-28(fp)
 8243fe4:	10001426 	beq	r2,zero,8244038 <ip_raw_input+0x1c4>
 8243fe8:	e0bff917 	ldw	r2,-28(fp)
 8243fec:	10800317 	ldw	r2,12(r2)
 8243ff0:	10001126 	beq	r2,zero,8244038 <ip_raw_input+0x1c4>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 8243ff4:	0009883a 	mov	r4,zero
 8243ff8:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      err = ((*matched_ep->ipr_rcv)(p, matched_ep->ipr_data));
 8243ffc:	e0bff917 	ldw	r2,-28(fp)
 8244000:	10800317 	ldw	r2,12(r2)
 8244004:	e0fff917 	ldw	r3,-28(fp)
 8244008:	18c00417 	ldw	r3,16(r3)
 824400c:	180b883a 	mov	r5,r3
 8244010:	e13fff17 	ldw	r4,-4(fp)
 8244014:	103ee83a 	callr	r2
 8244018:	e0bffa15 	stw	r2,-24(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 824401c:	0009883a 	mov	r4,zero
 8244020:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      if (err == 0)
 8244024:	e0bffa17 	ldw	r2,-24(fp)
 8244028:	10000c1e 	bne	r2,zero,824405c <ip_raw_input+0x1e8>
         delivered = 1;
 824402c:	00800044 	movi	r2,1
 8244030:	e0bffb15 	stw	r2,-20(fp)
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
      err = ((*matched_ep->ipr_rcv)(p, matched_ep->ipr_data));
      LOCK_NET_RESOURCE(NET_RESID);
      if (err == 0)
 8244034:	00000906 	br	824405c <ip_raw_input+0x1e8>
         delivered = 1;
   }
   else
   {
      err = ENP_PARAM;
 8244038:	00bffd84 	movi	r2,-10
 824403c:	e0bffa15 	stw	r2,-24(fp)
      ip_mib.ipUnknownProtos++;
 8244040:	008209b4 	movhi	r2,2086
 8244044:	10ba6104 	addi	r2,r2,-5756
 8244048:	10800617 	ldw	r2,24(r2)
 824404c:	10c00044 	addi	r3,r2,1
 8244050:	008209b4 	movhi	r2,2086
 8244054:	10ba6104 	addi	r2,r2,-5756
 8244058:	10c00615 	stw	r3,24(r2)
   }

   if (!delivered)
 824405c:	e0bffb17 	ldw	r2,-20(fp)
 8244060:	1000071e 	bne	r2,zero,8244080 <ip_raw_input+0x20c>
      ip_mib.ipInDelivers--;
 8244064:	008209b4 	movhi	r2,2086
 8244068:	10ba6104 	addi	r2,r2,-5756
 824406c:	10800817 	ldw	r2,32(r2)
 8244070:	10ffffc4 	addi	r3,r2,-1
 8244074:	008209b4 	movhi	r2,2086
 8244078:	10ba6104 	addi	r2,r2,-5756
 824407c:	10c00815 	stw	r3,32(r2)

   return err;
 8244080:	e0bffa17 	ldw	r2,-24(fp)
}
 8244084:	e037883a 	mov	sp,fp
 8244088:	dfc00117 	ldw	ra,4(sp)
 824408c:	df000017 	ldw	fp,0(sp)
 8244090:	dec00204 	addi	sp,sp,8
 8244094:	f800283a 	ret

08244098 <ip_raw_alloc>:
 *          inclhdr is zero.
 */

PACKET
ip_raw_alloc(int reqlen, int hdrincl)
{
 8244098:	defffa04 	addi	sp,sp,-24
 824409c:	dfc00515 	stw	ra,20(sp)
 82440a0:	df000415 	stw	fp,16(sp)
 82440a4:	df000404 	addi	fp,sp,16
 82440a8:	e13ffe15 	stw	r4,-8(fp)
 82440ac:	e17fff15 	stw	r5,-4(fp)
   int len;
   PACKET p;

   len = (reqlen + 1) & ~1;
 82440b0:	e0bffe17 	ldw	r2,-8(fp)
 82440b4:	10c00044 	addi	r3,r2,1
 82440b8:	00bfff84 	movi	r2,-2
 82440bc:	1884703a 	and	r2,r3,r2
 82440c0:	e0bffc15 	stw	r2,-16(fp)
   if (!hdrincl)
 82440c4:	e0bfff17 	ldw	r2,-4(fp)
 82440c8:	1000031e 	bne	r2,zero,82440d8 <ip_raw_alloc+0x40>
      len += IPHSIZ;
 82440cc:	e0bffc17 	ldw	r2,-16(fp)
 82440d0:	10800504 	addi	r2,r2,20
 82440d4:	e0bffc15 	stw	r2,-16(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 82440d8:	01000084 	movi	r4,2
 82440dc:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   p = pk_alloc(len + MaxLnh);
 82440e0:	d0e08117 	ldw	r3,-32252(gp)
 82440e4:	e0bffc17 	ldw	r2,-16(fp)
 82440e8:	1885883a 	add	r2,r3,r2
 82440ec:	1009883a 	mov	r4,r2
 82440f0:	822c9ec0 	call	822c9ec <pk_alloc>
 82440f4:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82440f8:	01000084 	movi	r4,2
 82440fc:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   if (p)
 8244100:	e0bffd17 	ldw	r2,-12(fp)
 8244104:	10000c26 	beq	r2,zero,8244138 <ip_raw_alloc+0xa0>
   {
      if (!hdrincl)
 8244108:	e0bfff17 	ldw	r2,-4(fp)
 824410c:	10000a1e 	bne	r2,zero,8244138 <ip_raw_alloc+0xa0>
      {
         p->nb_prot += IPHSIZ;
 8244110:	e0bffd17 	ldw	r2,-12(fp)
 8244114:	10800317 	ldw	r2,12(r2)
 8244118:	10c00504 	addi	r3,r2,20
 824411c:	e0bffd17 	ldw	r2,-12(fp)
 8244120:	10c00315 	stw	r3,12(r2)
         p->nb_plen -= IPHSIZ;
 8244124:	e0bffd17 	ldw	r2,-12(fp)
 8244128:	10800417 	ldw	r2,16(r2)
 824412c:	10fffb04 	addi	r3,r2,-20
 8244130:	e0bffd17 	ldw	r2,-12(fp)
 8244134:	10c00415 	stw	r3,16(r2)
      }
   }
   return p;
 8244138:	e0bffd17 	ldw	r2,-12(fp)
}
 824413c:	e037883a 	mov	sp,fp
 8244140:	dfc00117 	ldw	ra,4(sp)
 8244144:	df000017 	ldw	fp,0(sp)
 8244148:	dec00204 	addi	sp,sp,8
 824414c:	f800283a 	ret

08244150 <ip_raw_free>:
 * RETURNS: void
 */

void
ip_raw_free(PACKET p)
{
 8244150:	defffd04 	addi	sp,sp,-12
 8244154:	dfc00215 	stw	ra,8(sp)
 8244158:	df000115 	stw	fp,4(sp)
 824415c:	df000104 	addi	fp,sp,4
 8244160:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8244164:	01000084 	movi	r4,2
 8244168:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   pk_free(p);
 824416c:	e13fff17 	ldw	r4,-4(fp)
 8244170:	822cd3c0 	call	822cd3c <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8244174:	01000084 	movi	r4,2
 8244178:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
}
 824417c:	0001883a 	nop
 8244180:	e037883a 	mov	sp,fp
 8244184:	dfc00117 	ldw	ra,4(sp)
 8244188:	df000017 	ldw	fp,0(sp)
 824418c:	dec00204 	addi	sp,sp,8
 8244190:	f800283a 	ret

08244194 <ip_raw_maxalloc>:
 *          for 
 */

int
ip_raw_maxalloc(int hdrincl)
{
 8244194:	defffd04 	addi	sp,sp,-12
 8244198:	df000215 	stw	fp,8(sp)
 824419c:	df000204 	addi	fp,sp,8
 82441a0:	e13fff15 	stw	r4,-4(fp)
   int len;

   len = bigbufsiz - MaxLnh;
 82441a4:	d0a03917 	ldw	r2,-32540(gp)
 82441a8:	d0e08117 	ldw	r3,-32252(gp)
 82441ac:	10c5c83a 	sub	r2,r2,r3
 82441b0:	e0bffe15 	stw	r2,-8(fp)
   if (!hdrincl)
 82441b4:	e0bfff17 	ldw	r2,-4(fp)
 82441b8:	1000031e 	bne	r2,zero,82441c8 <ip_raw_maxalloc+0x34>
      len -= IPHSIZ;
 82441bc:	e0bffe17 	ldw	r2,-8(fp)
 82441c0:	10bffb04 	addi	r2,r2,-20
 82441c4:	e0bffe15 	stw	r2,-8(fp)
   return len;
 82441c8:	e0bffe17 	ldw	r2,-8(fp)
}
 82441cc:	e037883a 	mov	sp,fp
 82441d0:	df000017 	ldw	fp,0(sp)
 82441d4:	dec00104 	addi	sp,sp,4
 82441d8:	f800283a 	ret

082441dc <rt_lookup>:
 * entry was found.
 */

RTMIB
rt_lookup(ip_addr host)
{
 82441dc:	defff804 	addi	sp,sp,-32
 82441e0:	df000715 	stw	fp,28(sp)
 82441e4:	df000704 	addi	fp,sp,28
 82441e8:	e13fff15 	stw	r4,-4(fp)
   RTMIB    rtp;
   RTMIB    netmatch;
   unsigned char max_bits_matched = 0;
 82441ec:	e03ffb05 	stb	zero,-20(fp)
   unsigned char curr_bits_matched;
   ip_addr  entry_mask;
   unsigned long int bitcount_mask;
   unsigned long int extracted_bit;

   netmatch = NULL;
 82441f0:	e03ffa15 	stw	zero,-24(fp)

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 82441f4:	d0a0c617 	ldw	r2,-31976(gp)
 82441f8:	e0bff915 	stw	r2,-28(fp)
 82441fc:	00003a06 	br	82442e8 <rt_lookup+0x10c>
   {
      if (rtp->ipRouteNextHop == 0L)   /* skip over empty entries */
 8244200:	e0bff917 	ldw	r2,-28(fp)
 8244204:	10800617 	ldw	r2,24(r2)
 8244208:	10003326 	beq	r2,zero,82442d8 <rt_lookup+0xfc>
#ifdef RIP_SUPPORT
      /* skip RIP private entries */
      if (rtp->ipRouteFlags & RIP_PRIVATE)
         continue;
#endif
      entry_mask = rtp->ipRouteMask;
 824420c:	e0bff917 	ldw	r2,-28(fp)
 8244210:	10800a17 	ldw	r2,40(r2)
 8244214:	e0bffd15 	stw	r2,-12(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
 8244218:	e0bff917 	ldw	r2,-28(fp)
 824421c:	10c00017 	ldw	r3,0(r2)
 8244220:	e0bfff17 	ldw	r2,-4(fp)
 8244224:	1886f03a 	xor	r3,r3,r2
 8244228:	e0bffd17 	ldw	r2,-12(fp)
 824422c:	1884703a 	and	r2,r3,r2
 8244230:	10002a1e 	bne	r2,zero,82442dc <rt_lookup+0x100>
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 8244234:	e03ffb45 	stb	zero,-19(fp)
 8244238:	00a00034 	movhi	r2,32768
 824423c:	e0bffc15 	stw	r2,-16(fp)
 8244240:	00001806 	br	82442a4 <rt_lookup+0xc8>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
 8244244:	e0bffd17 	ldw	r2,-12(fp)
 8244248:	1006d63a 	srli	r3,r2,24
 824424c:	e0bffd17 	ldw	r2,-12(fp)
 8244250:	1004d23a 	srli	r2,r2,8
 8244254:	10bfc00c 	andi	r2,r2,65280
 8244258:	1886b03a 	or	r3,r3,r2
 824425c:	e0bffd17 	ldw	r2,-12(fp)
 8244260:	10bfc00c 	andi	r2,r2,65280
 8244264:	1004923a 	slli	r2,r2,8
 8244268:	1886b03a 	or	r3,r3,r2
 824426c:	e0bffd17 	ldw	r2,-12(fp)
 8244270:	1004963a 	slli	r2,r2,24
 8244274:	1886b03a 	or	r3,r3,r2
 8244278:	e0bffc17 	ldw	r2,-16(fp)
 824427c:	1884703a 	and	r2,r3,r2
 8244280:	e0bffe15 	stw	r2,-8(fp)
            if (extracted_bit) ++curr_bits_matched;
 8244284:	e0bffe17 	ldw	r2,-8(fp)
 8244288:	10000326 	beq	r2,zero,8244298 <rt_lookup+0xbc>
 824428c:	e0bffb43 	ldbu	r2,-19(fp)
 8244290:	10800044 	addi	r2,r2,1
 8244294:	e0bffb45 	stb	r2,-19(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 8244298:	e0bffc17 	ldw	r2,-16(fp)
 824429c:	1004d07a 	srli	r2,r2,1
 82442a0:	e0bffc15 	stw	r2,-16(fp)
 82442a4:	e0bffc17 	ldw	r2,-16(fp)
 82442a8:	103fe61e 	bne	r2,zero,8244244 <rt_lookup+0x68>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
            if (extracted_bit) ++curr_bits_matched;
         }
         if (curr_bits_matched > max_bits_matched)
 82442ac:	e0bffb43 	ldbu	r2,-19(fp)
 82442b0:	e0fffb03 	ldbu	r3,-20(fp)
 82442b4:	1880092e 	bgeu	r3,r2,82442dc <rt_lookup+0x100>
         {
            /* save a pointer to the best match */
            max_bits_matched = curr_bits_matched;
 82442b8:	e0bffb43 	ldbu	r2,-19(fp)
 82442bc:	e0bffb05 	stb	r2,-20(fp)
            netmatch = rtp;
 82442c0:	e0bff917 	ldw	r2,-28(fp)
 82442c4:	e0bffa15 	stw	r2,-24(fp)
            /* if all 32 bits match, stop searching the route table */
            if (max_bits_matched == 32)
 82442c8:	e0bffb03 	ldbu	r2,-20(fp)
 82442cc:	10800818 	cmpnei	r2,r2,32
 82442d0:	10000c26 	beq	r2,zero,8244304 <rt_lookup+0x128>
 82442d4:	00000106 	br	82442dc <rt_lookup+0x100>

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
   {
      if (rtp->ipRouteNextHop == 0L)   /* skip over empty entries */
         continue;
 82442d8:	0001883a 	nop
   unsigned long int extracted_bit;

   netmatch = NULL;

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 82442dc:	e0bff917 	ldw	r2,-28(fp)
 82442e0:	10800f04 	addi	r2,r2,60
 82442e4:	e0bff915 	stw	r2,-28(fp)
 82442e8:	d0e0c617 	ldw	r3,-31976(gp)
 82442ec:	d0a05117 	ldw	r2,-32444(gp)
 82442f0:	10800f24 	muli	r2,r2,60
 82442f4:	1885883a 	add	r2,r3,r2
 82442f8:	e0fff917 	ldw	r3,-28(fp)
 82442fc:	18bfc036 	bltu	r3,r2,8244200 <rt_lookup+0x24>
 8244300:	00000106 	br	8244308 <rt_lookup+0x12c>
            /* save a pointer to the best match */
            max_bits_matched = curr_bits_matched;
            netmatch = rtp;
            /* if all 32 bits match, stop searching the route table */
            if (max_bits_matched == 32)
               break;
 8244304:	0001883a 	nop
         }
      }
   }

   if (netmatch)
 8244308:	e0bffa17 	ldw	r2,-24(fp)
 824430c:	10000326 	beq	r2,zero,824431c <rt_lookup+0x140>
      netmatch->ipRouteAge = cticks;   /* timestamp entry we used */
 8244310:	d0e0a817 	ldw	r3,-32096(gp)
 8244314:	e0bffa17 	ldw	r2,-24(fp)
 8244318:	10c00915 	stw	r3,36(r2)

   return netmatch;
 824431c:	e0bffa17 	ldw	r2,-24(fp)
}
 8244320:	e037883a 	mov	sp,fp
 8244324:	df000017 	ldw	fp,0(sp)
 8244328:	dec00104 	addi	sp,sp,4
 824432c:	f800283a 	ret

08244330 <add_route>:
   ip_addr  dest,       /* ultimate destination */
   ip_addr  mask,       /* net mask, 0xFFFFFFFF if dest is host address */
   ip_addr  nexthop,    /* where to forward to */
   int      iface,      /* interface (net) for nexthop */
   int      prot)       /* how we know it: icmp, table, etc */
{
 8244330:	defff704 	addi	sp,sp,-36
 8244334:	dfc00815 	stw	ra,32(sp)
 8244338:	df000715 	stw	fp,28(sp)
 824433c:	df000704 	addi	fp,sp,28
 8244340:	e13ffc15 	stw	r4,-16(fp)
 8244344:	e17ffd15 	stw	r5,-12(fp)
 8244348:	e1bffe15 	stw	r6,-8(fp)
 824434c:	e1ffff15 	stw	r7,-4(fp)
   RTMIB rtp;           /* scratch route table entrry pointer */
   RTMIB newrt;         /* best entry for new route */
   struct net * ifp;    /* interface (net) for nexthop */

   newrt = NULL;     /* may be replaced with empty or more expendable entry */
 8244350:	e03ffa15 	stw	zero,-24(fp)
					 
   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   ifp = if_getbynum(iface);
 8244354:	e13fff17 	ldw	r4,-4(fp)
 8244358:	823ed480 	call	823ed48 <if_getbynum>
 824435c:	e0bffb15 	stw	r2,-20(fp)
   if(!ifp)
 8244360:	e0bffb17 	ldw	r2,-20(fp)
 8244364:	1000021e 	bne	r2,zero,8244370 <add_route+0x40>
      return NULL;
 8244368:	0005883a 	mov	r2,zero
 824436c:	0000db06 	br	82446dc <add_route+0x3ac>

   if (rt_mib == NULL)
 8244370:	d0a0c617 	ldw	r2,-31976(gp)
 8244374:	1000021e 	bne	r2,zero,8244380 <add_route+0x50>
      return NULL;
 8244378:	0005883a 	mov	r2,zero
 824437c:	0000d706 	br	82446dc <add_route+0x3ac>

   /* Don't add null masks or IP addresses - they give false positives on
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
 8244380:	e0bffc17 	ldw	r2,-16(fp)
 8244384:	10000226 	beq	r2,zero,8244390 <add_route+0x60>
 8244388:	e0bffd17 	ldw	r2,-12(fp)
 824438c:	1000221e 	bne	r2,zero,8244418 <add_route+0xe8>
   {
      dtrap();    /* bad configuration? */
 8244390:	822d5940 	call	822d594 <dtrap>
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
	      htonl(dest), htonl(mask) );
 8244394:	e0bffc17 	ldw	r2,-16(fp)
 8244398:	1006d63a 	srli	r3,r2,24
 824439c:	e0bffc17 	ldw	r2,-16(fp)
 82443a0:	1004d23a 	srli	r2,r2,8
 82443a4:	10bfc00c 	andi	r2,r2,65280
 82443a8:	1886b03a 	or	r3,r3,r2
 82443ac:	e0bffc17 	ldw	r2,-16(fp)
 82443b0:	10bfc00c 	andi	r2,r2,65280
 82443b4:	1004923a 	slli	r2,r2,8
 82443b8:	1886b03a 	or	r3,r3,r2
 82443bc:	e0bffc17 	ldw	r2,-16(fp)
 82443c0:	1004963a 	slli	r2,r2,24
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
   {
      dtrap();    /* bad configuration? */
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
 82443c4:	1888b03a 	or	r4,r3,r2
	      htonl(dest), htonl(mask) );
 82443c8:	e0bffd17 	ldw	r2,-12(fp)
 82443cc:	1006d63a 	srli	r3,r2,24
 82443d0:	e0bffd17 	ldw	r2,-12(fp)
 82443d4:	1004d23a 	srli	r2,r2,8
 82443d8:	10bfc00c 	andi	r2,r2,65280
 82443dc:	1886b03a 	or	r3,r3,r2
 82443e0:	e0bffd17 	ldw	r2,-12(fp)
 82443e4:	10bfc00c 	andi	r2,r2,65280
 82443e8:	1004923a 	slli	r2,r2,8
 82443ec:	1886b03a 	or	r3,r3,r2
 82443f0:	e0bffd17 	ldw	r2,-12(fp)
 82443f4:	1004963a 	slli	r2,r2,24
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
   {
      dtrap();    /* bad configuration? */
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
 82443f8:	1884b03a 	or	r2,r3,r2
 82443fc:	100d883a 	mov	r6,r2
 8244400:	200b883a 	mov	r5,r4
 8244404:	01020974 	movhi	r4,2085
 8244408:	21058804 	addi	r4,r4,5664
 824440c:	82033a00 	call	82033a0 <printf>
	      htonl(dest), htonl(mask) );
      return NULL;
 8244410:	0005883a 	mov	r2,zero
 8244414:	0000b106 	br	82446dc <add_route+0x3ac>
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 8244418:	d0a0c617 	ldw	r2,-31976(gp)
 824441c:	e0bff915 	stw	r2,-28(fp)
 8244420:	00006a06 	br	82445cc <add_route+0x29c>
   {
      if (rtp->ipRouteDest == dest) /* found existing entry for target */
 8244424:	e0bff917 	ldw	r2,-28(fp)
 8244428:	10c00017 	ldw	r3,0(r2)
 824442c:	e0bffc17 	ldw	r2,-16(fp)
 8244430:	1880151e 	bne	r3,r2,8244488 <add_route+0x158>
      {
         rtp->ipRouteNextHop = nexthop;      /* fix entry */
 8244434:	e0bff917 	ldw	r2,-28(fp)
 8244438:	e0fffe17 	ldw	r3,-8(fp)
 824443c:	10c00615 	stw	r3,24(r2)
         rtp->ipRouteAge = cticks;           /* timestamp it */
 8244440:	d0e0a817 	ldw	r3,-32096(gp)
 8244444:	e0bff917 	ldw	r2,-28(fp)
 8244448:	10c00915 	stw	r3,36(r2)
         /* set the rfc1213 1-based SNMP-ish interface index */
         rtp->ipRouteIfIndex = (long)(iface) + 1;
 824444c:	e0bfff17 	ldw	r2,-4(fp)
 8244450:	10c00044 	addi	r3,r2,1
 8244454:	e0bff917 	ldw	r2,-28(fp)
 8244458:	10c00115 	stw	r3,4(r2)
         rtp->ipRouteProto = prot;           /* icmp, or whatever */
 824445c:	e0bff917 	ldw	r2,-28(fp)
 8244460:	e0c00217 	ldw	r3,8(fp)
 8244464:	10c00815 	stw	r3,32(r2)
         rtp->ipRouteMask = mask;
 8244468:	e0bff917 	ldw	r2,-28(fp)
 824446c:	e0fffd17 	ldw	r3,-12(fp)
 8244470:	10c00a15 	stw	r3,40(r2)
         rtp->ifp = ifp;
 8244474:	e0bff917 	ldw	r2,-28(fp)
 8244478:	e0fffb17 	ldw	r3,-20(fp)
 824447c:	10c00e15 	stw	r3,56(r2)
         return(rtp);   /* just update and exit */
 8244480:	e0bff917 	ldw	r2,-28(fp)
 8244484:	00009506 	br	82446dc <add_route+0x3ac>
      }
      /* if we didn't find empty slot yet, look for good slot to recycle */
      if (!newrt || (newrt->ipRouteProto != 0))
 8244488:	e0bffa17 	ldw	r2,-24(fp)
 824448c:	10000326 	beq	r2,zero,824449c <add_route+0x16c>
 8244490:	e0bffa17 	ldw	r2,-24(fp)
 8244494:	10800817 	ldw	r2,32(r2)
 8244498:	10004926 	beq	r2,zero,82445c0 <add_route+0x290>
      {
         if (!rtp->ipRouteNextHop)  /* found empty slot for use */
 824449c:	e0bff917 	ldw	r2,-28(fp)
 82444a0:	10800617 	ldw	r2,24(r2)
 82444a4:	1000051e 	bne	r2,zero,82444bc <add_route+0x18c>
         {
            newrt = rtp;   /* record empty route for use */
 82444a8:	e0bff917 	ldw	r2,-28(fp)
 82444ac:	e0bffa15 	stw	r2,-24(fp)
            newrt->ipRouteProto = 0;
 82444b0:	e0bffa17 	ldw	r2,-24(fp)
 82444b4:	10000815 	stw	zero,32(r2)
            continue;
 82444b8:	00004106 	br	82445c0 <add_route+0x290>
         }
         /* else see if the new route has higher priority than this slot: */
         if (rtp_priority[prot] >= rtp_priority[rtp->ipRouteProto])
 82444bc:	00820974 	movhi	r2,2085
 82444c0:	108f3904 	addi	r2,r2,15588
 82444c4:	e0c00217 	ldw	r3,8(fp)
 82444c8:	10c5883a 	add	r2,r2,r3
 82444cc:	11000003 	ldbu	r4,0(r2)
 82444d0:	e0bff917 	ldw	r2,-28(fp)
 82444d4:	10c00817 	ldw	r3,32(r2)
 82444d8:	00820974 	movhi	r2,2085
 82444dc:	108f3904 	addi	r2,r2,15588
 82444e0:	10c5883a 	add	r2,r2,r3
 82444e4:	10800003 	ldbu	r2,0(r2)
 82444e8:	20c03fcc 	andi	r3,r4,255
 82444ec:	10803fcc 	andi	r2,r2,255
 82444f0:	18803336 	bltu	r3,r2,82445c0 <add_route+0x290>
         {
            if (!newrt)
 82444f4:	e0bffa17 	ldw	r2,-24(fp)
 82444f8:	1000031e 	bne	r2,zero,8244508 <add_route+0x1d8>
            {
               newrt = rtp;
 82444fc:	e0bff917 	ldw	r2,-28(fp)
 8244500:	e0bffa15 	stw	r2,-24(fp)
               continue;
 8244504:	00002e06 	br	82445c0 <add_route+0x290>
            }

            /* see if rtp is less important then newrtp */
            if (rtp_priority[rtp->ipRouteProto] < 
 8244508:	e0bff917 	ldw	r2,-28(fp)
 824450c:	10c00817 	ldw	r3,32(r2)
 8244510:	00820974 	movhi	r2,2085
 8244514:	108f3904 	addi	r2,r2,15588
 8244518:	10c5883a 	add	r2,r2,r3
 824451c:	11000003 	ldbu	r4,0(r2)
                rtp_priority[newrt->ipRouteProto])
 8244520:	e0bffa17 	ldw	r2,-24(fp)
 8244524:	10c00817 	ldw	r3,32(r2)
 8244528:	00820974 	movhi	r2,2085
 824452c:	108f3904 	addi	r2,r2,15588
 8244530:	10c5883a 	add	r2,r2,r3
 8244534:	10800003 	ldbu	r2,0(r2)
               newrt = rtp;
               continue;
            }

            /* see if rtp is less important then newrtp */
            if (rtp_priority[rtp->ipRouteProto] < 
 8244538:	20c03fcc 	andi	r3,r4,255
 824453c:	10803fcc 	andi	r2,r2,255
 8244540:	1880032e 	bgeu	r3,r2,8244550 <add_route+0x220>
                rtp_priority[newrt->ipRouteProto])
            {
               newrt = rtp;   /* save lower priority entry for recycle */
 8244544:	e0bff917 	ldw	r2,-28(fp)
 8244548:	e0bffa15 	stw	r2,-24(fp)
 824454c:	00001c06 	br	82445c0 <add_route+0x290>
            }
            else if(rtp_priority[rtp->ipRouteProto] == 
 8244550:	e0bff917 	ldw	r2,-28(fp)
 8244554:	10c00817 	ldw	r3,32(r2)
 8244558:	00820974 	movhi	r2,2085
 824455c:	108f3904 	addi	r2,r2,15588
 8244560:	10c5883a 	add	r2,r2,r3
 8244564:	11000003 	ldbu	r4,0(r2)
                rtp_priority[newrt->ipRouteProto])
 8244568:	e0bffa17 	ldw	r2,-24(fp)
 824456c:	10c00817 	ldw	r3,32(r2)
 8244570:	00820974 	movhi	r2,2085
 8244574:	108f3904 	addi	r2,r2,15588
 8244578:	10c5883a 	add	r2,r2,r3
 824457c:	10800003 	ldbu	r2,0(r2)
            if (rtp_priority[rtp->ipRouteProto] < 
                rtp_priority[newrt->ipRouteProto])
            {
               newrt = rtp;   /* save lower priority entry for recycle */
            }
            else if(rtp_priority[rtp->ipRouteProto] == 
 8244580:	20c03fcc 	andi	r3,r4,255
 8244584:	10803fcc 	andi	r2,r2,255
 8244588:	18800d1e 	bne	r3,r2,82445c0 <add_route+0x290>
                rtp_priority[newrt->ipRouteProto])
            {
               /* if equal priority, keep the older entry for deletion */
               if (c_older(rtp->ipRouteAge, newrt->ipRouteAge) == rtp->ipRouteAge)
 824458c:	e0bff917 	ldw	r2,-28(fp)
 8244590:	10c00917 	ldw	r3,36(r2)
 8244594:	e0bffa17 	ldw	r2,-24(fp)
 8244598:	10800917 	ldw	r2,36(r2)
 824459c:	100b883a 	mov	r5,r2
 82445a0:	1809883a 	mov	r4,r3
 82445a4:	82266680 	call	8226668 <c_older>
 82445a8:	1007883a 	mov	r3,r2
 82445ac:	e0bff917 	ldw	r2,-28(fp)
 82445b0:	10800917 	ldw	r2,36(r2)
 82445b4:	1880021e 	bne	r3,r2,82445c0 <add_route+0x290>
                  newrt = rtp;   /* got an older one */
 82445b8:	e0bff917 	ldw	r2,-28(fp)
 82445bc:	e0bffa15 	stw	r2,-24(fp)
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 82445c0:	e0bff917 	ldw	r2,-28(fp)
 82445c4:	10800f04 	addi	r2,r2,60
 82445c8:	e0bff915 	stw	r2,-28(fp)
 82445cc:	d0e0c617 	ldw	r3,-31976(gp)
 82445d0:	d0a05117 	ldw	r2,-32444(gp)
 82445d4:	10800f24 	muli	r2,r2,60
 82445d8:	1885883a 	add	r2,r3,r2
 82445dc:	e0fff917 	ldw	r3,-28(fp)
 82445e0:	18bf9036 	bltu	r3,r2,8244424 <add_route+0xf4>
         }
      }
   }

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
 82445e4:	e0bffa17 	ldw	r2,-24(fp)
 82445e8:	10002926 	beq	r2,zero,8244690 <add_route+0x360>
      rtp = newrt;   /* create new entry in lowest priority slot */
 82445ec:	e0bffa17 	ldw	r2,-24(fp)
 82445f0:	e0bff915 	stw	r2,-28(fp)
   else  /* all slots have higher priority, new entry looses */
      return NULL;

   /* set default value in new route entry, caller can modiy further. */
   rtp->ifp = ifp;
 82445f4:	e0bff917 	ldw	r2,-28(fp)
 82445f8:	e0fffb17 	ldw	r3,-20(fp)
 82445fc:	10c00e15 	stw	r3,56(r2)
   rtp->ipRouteDest = dest;
 8244600:	e0bff917 	ldw	r2,-28(fp)
 8244604:	e0fffc17 	ldw	r3,-16(fp)
 8244608:	10c00015 	stw	r3,0(r2)
   rtp->ipRouteIfIndex = (long)(if_netnumber(ifp)) + 1; /* set interface number */
 824460c:	e13ffb17 	ldw	r4,-20(fp)
 8244610:	8226c680 	call	8226c68 <if_netnumber>
 8244614:	10c00044 	addi	r3,r2,1
 8244618:	e0bff917 	ldw	r2,-28(fp)
 824461c:	10c00115 	stw	r3,4(r2)
   rtp->ipRouteMetric1 = ip_mib.ipDefaultTTL;
 8244620:	008209b4 	movhi	r2,2086
 8244624:	10ba6104 	addi	r2,r2,-5756
 8244628:	10800117 	ldw	r2,4(r2)
 824462c:	1007883a 	mov	r3,r2
 8244630:	e0bff917 	ldw	r2,-28(fp)
 8244634:	10c00215 	stw	r3,8(r2)
   rtp->ipRouteMetric2 = -1;
 8244638:	e0bff917 	ldw	r2,-28(fp)
 824463c:	00ffffc4 	movi	r3,-1
 8244640:	10c00315 	stw	r3,12(r2)
   rtp->ipRouteMetric3 = -1;
 8244644:	e0bff917 	ldw	r2,-28(fp)
 8244648:	00ffffc4 	movi	r3,-1
 824464c:	10c00415 	stw	r3,16(r2)
   rtp->ipRouteMetric4 = -1;
 8244650:	e0bff917 	ldw	r2,-28(fp)
 8244654:	00ffffc4 	movi	r3,-1
 8244658:	10c00515 	stw	r3,20(r2)
   rtp->ipRouteNextHop = nexthop;
 824465c:	e0bff917 	ldw	r2,-28(fp)
 8244660:	e0fffe17 	ldw	r3,-8(fp)
 8244664:	10c00615 	stw	r3,24(r2)
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */
 8244668:	e0bff917 	ldw	r2,-28(fp)
 824466c:	e0c00217 	ldw	r3,8(fp)
 8244670:	10c00815 	stw	r3,32(r2)

   if ((dest & mask) == (nexthop & mask))
 8244674:	e0fffc17 	ldw	r3,-16(fp)
 8244678:	e0bffe17 	ldw	r2,-8(fp)
 824467c:	1886f03a 	xor	r3,r3,r2
 8244680:	e0bffd17 	ldw	r2,-12(fp)
 8244684:	1884703a 	and	r2,r3,r2
 8244688:	1000071e 	bne	r2,zero,82446a8 <add_route+0x378>
 824468c:	00000206 	br	8244698 <add_route+0x368>

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
      rtp = newrt;   /* create new entry in lowest priority slot */
   else  /* all slots have higher priority, new entry looses */
      return NULL;
 8244690:	0005883a 	mov	r2,zero
 8244694:	00001106 	br	82446dc <add_route+0x3ac>
   rtp->ipRouteMetric4 = -1;
   rtp->ipRouteNextHop = nexthop;
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */

   if ((dest & mask) == (nexthop & mask))
      rtp->ipRouteType = IPRT_DIRECT;
 8244698:	e0bff917 	ldw	r2,-28(fp)
 824469c:	00c000c4 	movi	r3,3
 82446a0:	10c00715 	stw	r3,28(r2)
 82446a4:	00000306 	br	82446b4 <add_route+0x384>
   else
      rtp->ipRouteType = IPRT_INDIRECT;
 82446a8:	e0bff917 	ldw	r2,-28(fp)
 82446ac:	00c00104 	movi	r3,4
 82446b0:	10c00715 	stw	r3,28(r2)

   rtp->ipRouteAge = cticks;        /* timestamp it */
 82446b4:	d0e0a817 	ldw	r3,-32096(gp)
 82446b8:	e0bff917 	ldw	r2,-28(fp)
 82446bc:	10c00915 	stw	r3,36(r2)
   rtp->ipRouteMask = mask;
 82446c0:	e0bff917 	ldw	r2,-28(fp)
 82446c4:	e0fffd17 	ldw	r3,-12(fp)
 82446c8:	10c00a15 	stw	r3,40(r2)
   rtp->ipRouteMetric5 = -1;
 82446cc:	e0bff917 	ldw	r2,-28(fp)
 82446d0:	00ffffc4 	movi	r3,-1
 82446d4:	10c00b15 	stw	r3,44(r2)
   return(rtp);
 82446d8:	e0bff917 	ldw	r2,-28(fp)
}
 82446dc:	e037883a 	mov	sp,fp
 82446e0:	dfc00117 	ldw	ra,4(sp)
 82446e4:	df000017 	ldw	fp,0(sp)
 82446e8:	dec00204 	addi	sp,sp,8
 82446ec:	f800283a 	ret

082446f0 <del_route>:
 * RETURNS: Returns number of route table entries deleted. 
 */

int
del_route(ip_addr dest, ip_addr mask, int iface)
{
 82446f0:	defff804 	addi	sp,sp,-32
 82446f4:	dfc00715 	stw	ra,28(sp)
 82446f8:	df000615 	stw	fp,24(sp)
 82446fc:	df000604 	addi	fp,sp,24
 8244700:	e13ffd15 	stw	r4,-12(fp)
 8244704:	e17ffe15 	stw	r5,-8(fp)
 8244708:	e1bfff15 	stw	r6,-4(fp)
   RTMIB rtp;
   int   retval   =  0;
 824470c:	e03ffb15 	stw	zero,-20(fp)

   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   if(iface == -1)
 8244710:	e0bfff17 	ldw	r2,-4(fp)
 8244714:	10bfffd8 	cmpnei	r2,r2,-1
 8244718:	1000021e 	bne	r2,zero,8244724 <del_route+0x34>
      ifp = NULL;    /* wildcard */
 824471c:	e03ffc15 	stw	zero,-16(fp)
 8244720:	00000306 	br	8244730 <del_route+0x40>
   else
      ifp = if_getbynum(iface);
 8244724:	e13fff17 	ldw	r4,-4(fp)
 8244728:	823ed480 	call	823ed48 <if_getbynum>
 824472c:	e0bffc15 	stw	r2,-16(fp)

   if (rt_mib == NULL)     /* Make sure we're up */
 8244730:	d0a0c617 	ldw	r2,-31976(gp)
 8244734:	1000021e 	bne	r2,zero,8244740 <del_route+0x50>
      return 0;
 8244738:	0005883a 	mov	r2,zero
 824473c:	00002c06 	br	82447f0 <del_route+0x100>

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 8244740:	d0a0c617 	ldw	r2,-31976(gp)
 8244744:	e0bffa15 	stw	r2,-24(fp)
 8244748:	00002206 	br	82447d4 <del_route+0xe4>
   {
      if (!rtp->ipRouteNextHop)  /* empty slot */
 824474c:	e0bffa17 	ldw	r2,-24(fp)
 8244750:	10800617 	ldw	r2,24(r2)
 8244754:	10001926 	beq	r2,zero,82447bc <del_route+0xcc>
         continue;
      if(ifp != NULL && ifp != rtp->ifp)
 8244758:	e0bffc17 	ldw	r2,-16(fp)
 824475c:	10000426 	beq	r2,zero,8244770 <del_route+0x80>
 8244760:	e0bffa17 	ldw	r2,-24(fp)
 8244764:	10c00e17 	ldw	r3,56(r2)
 8244768:	e0bffc17 	ldw	r2,-16(fp)
 824476c:	1880151e 	bne	r3,r2,82447c4 <del_route+0xd4>
         continue;   /* interface didn't match */
      if ((rtp->ipRouteDest & mask) == (dest & mask))
 8244770:	e0bffa17 	ldw	r2,-24(fp)
 8244774:	10c00017 	ldw	r3,0(r2)
 8244778:	e0bffd17 	ldw	r2,-12(fp)
 824477c:	1886f03a 	xor	r3,r3,r2
 8244780:	e0bffe17 	ldw	r2,-8(fp)
 8244784:	1884703a 	and	r2,r3,r2
 8244788:	1000071e 	bne	r2,zero,82447a8 <del_route+0xb8>
      {
         MEMSET(rtp, 0, sizeof(*rtp)); /* clear entry */
 824478c:	01800f04 	movi	r6,60
 8244790:	000b883a 	mov	r5,zero
 8244794:	e13ffa17 	ldw	r4,-24(fp)
 8244798:	82031b40 	call	82031b4 <memset>
         retval++;
 824479c:	e0bffb17 	ldw	r2,-20(fp)
 82447a0:	10800044 	addi	r2,r2,1
 82447a4:	e0bffb15 	stw	r2,-20(fp)
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
 82447a8:	d0e0d017 	ldw	r3,-31936(gp)
 82447ac:	e0bffa17 	ldw	r2,-24(fp)
 82447b0:	1880051e 	bne	r3,r2,82447c8 <del_route+0xd8>
         cachedRoute = NULL;
 82447b4:	d020d015 	stw	zero,-31936(gp)
 82447b8:	00000306 	br	82447c8 <del_route+0xd8>
      return 0;

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
   {
      if (!rtp->ipRouteNextHop)  /* empty slot */
         continue;
 82447bc:	0001883a 	nop
 82447c0:	00000106 	br	82447c8 <del_route+0xd8>
      if(ifp != NULL && ifp != rtp->ifp)
         continue;   /* interface didn't match */
 82447c4:	0001883a 	nop
      ifp = if_getbynum(iface);

   if (rt_mib == NULL)     /* Make sure we're up */
      return 0;

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 82447c8:	e0bffa17 	ldw	r2,-24(fp)
 82447cc:	10800f04 	addi	r2,r2,60
 82447d0:	e0bffa15 	stw	r2,-24(fp)
 82447d4:	d0e0c617 	ldw	r3,-31976(gp)
 82447d8:	d0a05117 	ldw	r2,-32444(gp)
 82447dc:	10800f24 	muli	r2,r2,60
 82447e0:	1885883a 	add	r2,r3,r2
 82447e4:	e0fffa17 	ldw	r3,-24(fp)
 82447e8:	18bfd836 	bltu	r3,r2,824474c <del_route+0x5c>
         retval++;
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
         cachedRoute = NULL;
   }
   return retval;
 82447ec:	e0bffb17 	ldw	r2,-20(fp)
}
 82447f0:	e037883a 	mov	sp,fp
 82447f4:	dfc00117 	ldw	ra,4(sp)
 82447f8:	df000017 	ldw	fp,0(sp)
 82447fc:	dec00204 	addi	sp,sp,8
 8244800:	f800283a 	ret

08244804 <udpdemux>:
 * RETURNS: 0 if OK or ENP error code
 */

int
udpdemux(PACKET p)
{
 8244804:	deffec04 	addi	sp,sp,-80
 8244808:	dfc01315 	stw	ra,76(sp)
 824480c:	df001215 	stw	fp,72(sp)
 8244810:	df001204 	addi	fp,sp,72
 8244814:	e13fff15 	stw	r4,-4(fp)
   unsigned short osum, xsum; /* scratch checksum holders */
   unsigned plen; /* packet length */
   int   e;    /* general error holder */

   /* First let's verify that it's a valid UDP packet. */
   pip = ip_head(p);       /* we'll need IP header info */
 8244818:	e0bfff17 	ldw	r2,-4(fp)
 824481c:	10800317 	ldw	r2,12(r2)
 8244820:	e0bff615 	stw	r2,-40(fp)
   pup = (struct udp*)ip_data(pip);   /*  also need UDP header */
 8244824:	e0bff617 	ldw	r2,-40(fp)
 8244828:	10800003 	ldbu	r2,0(r2)
 824482c:	10803fcc 	andi	r2,r2,255
 8244830:	108003cc 	andi	r2,r2,15
 8244834:	1085883a 	add	r2,r2,r2
 8244838:	1085883a 	add	r2,r2,r2
 824483c:	1007883a 	mov	r3,r2
 8244840:	e0bff617 	ldw	r2,-40(fp)
 8244844:	10c5883a 	add	r2,r2,r3
 8244848:	e0bff715 	stw	r2,-36(fp)
   plen = htons(pup->ud_len);
 824484c:	e0bff717 	ldw	r2,-36(fp)
 8244850:	1080010b 	ldhu	r2,4(r2)
 8244854:	10bfffcc 	andi	r2,r2,65535
 8244858:	1004d23a 	srli	r2,r2,8
 824485c:	10bfffcc 	andi	r2,r2,65535
 8244860:	10c03fcc 	andi	r3,r2,255
 8244864:	e0bff717 	ldw	r2,-36(fp)
 8244868:	1080010b 	ldhu	r2,4(r2)
 824486c:	10bfffcc 	andi	r2,r2,65535
 8244870:	1004923a 	slli	r2,r2,8
 8244874:	10bfffcc 	andi	r2,r2,65535
 8244878:	1884b03a 	or	r2,r3,r2
 824487c:	e0bff815 	stw	r2,-32(fp)

   if (plen > p->nb_plen)
 8244880:	e0bfff17 	ldw	r2,-4(fp)
 8244884:	10c00417 	ldw	r3,16(r2)
 8244888:	e0bff817 	ldw	r2,-32(fp)
 824488c:	1880252e 	bgeu	r3,r2,8244924 <udpdemux+0x120>
#ifdef   NPDEBUG
/* 
 * Altera Niche Stack Nios port modification:
 * cast arg to unsigned long to remove build warning
 */
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 8244890:	d0a08317 	ldw	r2,-32244(gp)
 8244894:	1081000c 	andi	r2,r2,1024
 8244898:	10001726 	beq	r2,zero,82448f8 <udpdemux+0xf4>
 824489c:	d0a08317 	ldw	r2,-32244(gp)
 82448a0:	1080400c 	andi	r2,r2,256
 82448a4:	10001426 	beq	r2,zero,82448f8 <udpdemux+0xf4>
         dprintf("UDP: bad len pkt: rcvd: %u, hdr: %u.\n",
 82448a8:	e0bfff17 	ldw	r2,-4(fp)
 82448ac:	11000417 	ldw	r4,16(r2)
                 p->nb_plen, (unsigned int)(htons(pup->ud_len) + UDPLEN));
 82448b0:	e0bff717 	ldw	r2,-36(fp)
 82448b4:	1080010b 	ldhu	r2,4(r2)
 82448b8:	10bfffcc 	andi	r2,r2,65535
 82448bc:	1004d23a 	srli	r2,r2,8
 82448c0:	10bfffcc 	andi	r2,r2,65535
 82448c4:	10c03fcc 	andi	r3,r2,255
 82448c8:	e0bff717 	ldw	r2,-36(fp)
 82448cc:	1080010b 	ldhu	r2,4(r2)
 82448d0:	10bfffcc 	andi	r2,r2,65535
 82448d4:	1004923a 	slli	r2,r2,8
 82448d8:	10bfffcc 	andi	r2,r2,65535
 82448dc:	1884b03a 	or	r2,r3,r2
/* 
 * Altera Niche Stack Nios port modification:
 * cast arg to unsigned long to remove build warning
 */
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         dprintf("UDP: bad len pkt: rcvd: %u, hdr: %u.\n",
 82448e0:	10800204 	addi	r2,r2,8
 82448e4:	100d883a 	mov	r6,r2
 82448e8:	200b883a 	mov	r5,r4
 82448ec:	01020974 	movhi	r4,2085
 82448f0:	21059604 	addi	r4,r4,5720
 82448f4:	82033a00 	call	82033a0 <printf>
                 p->nb_plen, (unsigned int)(htons(pup->ud_len) + UDPLEN));
#endif
      udp_mib.udpInErrors++;
 82448f8:	008209b4 	movhi	r2,2086
 82448fc:	10ba7b04 	addi	r2,r2,-5652
 8244900:	10800217 	ldw	r2,8(r2)
 8244904:	10c00044 	addi	r3,r2,1
 8244908:	008209b4 	movhi	r2,2086
 824490c:	10ba7b04 	addi	r2,r2,-5652
 8244910:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 8244914:	e13fff17 	ldw	r4,-4(fp)
 8244918:	82454c80 	call	82454c8 <udp_free>
      return ENP_BAD_HEADER;
 824491c:	00bff804 	movi	r2,-32
 8244920:	00019d06 	br	8244f98 <udpdemux+0x794>
   }

   osum = pup->ud_cksum;
 8244924:	e0bff717 	ldw	r2,-36(fp)
 8244928:	1080018b 	ldhu	r2,6(r2)
 824492c:	e0bff90d 	sth	r2,-28(fp)
   /* did other guy use checksumming? */
   if (osum)
 8244930:	e0bff90b 	ldhu	r2,-28(fp)
 8244934:	10005826 	beq	r2,zero,8244a98 <udpdemux+0x294>
   {
      if (plen & 1) ((char *)pup)[plen] = 0;
 8244938:	e0bff817 	ldw	r2,-32(fp)
 824493c:	1080004c 	andi	r2,r2,1
 8244940:	10000426 	beq	r2,zero,8244954 <udpdemux+0x150>
 8244944:	e0fff717 	ldw	r3,-36(fp)
 8244948:	e0bff817 	ldw	r2,-32(fp)
 824494c:	1885883a 	add	r2,r3,r2
 8244950:	10000005 	stb	zero,0(r2)
         php.ph_src = p->fhost;
 8244954:	e0bfff17 	ldw	r2,-4(fp)
 8244958:	10800717 	ldw	r2,28(r2)
 824495c:	e0bffc15 	stw	r2,-16(fp)
      php.ph_dest = pip->ip_dest;
 8244960:	e0bff617 	ldw	r2,-40(fp)
 8244964:	10800417 	ldw	r2,16(r2)
 8244968:	e0bffd15 	stw	r2,-12(fp)
      php.ph_zero = 0;
 824496c:	e03ffe05 	stb	zero,-8(fp)
      php.ph_prot = UDP_PROT;
 8244970:	00800444 	movi	r2,17
 8244974:	e0bffe45 	stb	r2,-7(fp)
      php.ph_len  = pup->ud_len;
 8244978:	e0bff717 	ldw	r2,-36(fp)
 824497c:	1080010b 	ldhu	r2,4(r2)
 8244980:	e0bffe8d 	sth	r2,-6(fp)

      pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 8244984:	e0bffc04 	addi	r2,fp,-16
 8244988:	01400184 	movi	r5,6
 824498c:	1009883a 	mov	r4,r2
 8244990:	82287b40 	call	82287b4 <cksum>
 8244994:	1007883a 	mov	r3,r2
 8244998:	e0bff717 	ldw	r2,-36(fp)
 824499c:	10c0018d 	sth	r3,6(r2)
      xsum = ~cksum(pup, (plen+1)>>1);
 82449a0:	e0bff817 	ldw	r2,-32(fp)
 82449a4:	10800044 	addi	r2,r2,1
 82449a8:	1004d07a 	srli	r2,r2,1
 82449ac:	100b883a 	mov	r5,r2
 82449b0:	e13ff717 	ldw	r4,-36(fp)
 82449b4:	82287b40 	call	82287b4 <cksum>
 82449b8:	0084303a 	nor	r2,zero,r2
 82449bc:	e0bff30d 	sth	r2,-52(fp)
      if (!xsum)
 82449c0:	e0bff30b 	ldhu	r2,-52(fp)
 82449c4:	1000021e 	bne	r2,zero,82449d0 <udpdemux+0x1cc>
         xsum = 0xffff;
 82449c8:	00bfffc4 	movi	r2,-1
 82449cc:	e0bff30d 	sth	r2,-52(fp)
      pup->ud_cksum = osum;
 82449d0:	e0bff717 	ldw	r2,-36(fp)
 82449d4:	e0fff90b 	ldhu	r3,-28(fp)
 82449d8:	10c0018d 	sth	r3,6(r2)
      if (xsum != osum)
 82449dc:	e0fff30b 	ldhu	r3,-52(fp)
 82449e0:	e0bff90b 	ldhu	r2,-28(fp)
 82449e4:	18802c26 	beq	r3,r2,8244a98 <udpdemux+0x294>
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 82449e8:	d0a08317 	ldw	r2,-32244(gp)
 82449ec:	1081000c 	andi	r2,r2,1024
 82449f0:	10001e26 	beq	r2,zero,8244a6c <udpdemux+0x268>
 82449f4:	d0a08317 	ldw	r2,-32244(gp)
 82449f8:	1080400c 	andi	r2,r2,256
 82449fc:	10001b26 	beq	r2,zero,8244a6c <udpdemux+0x268>
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 8244a00:	e17ff90b 	ldhu	r5,-28(fp)
 8244a04:	e1bff30b 	ldhu	r6,-52(fp)
                    osum, xsum, PUSH_IPADDR(p->fhost));
 8244a08:	e0bfff17 	ldw	r2,-4(fp)
 8244a0c:	10800717 	ldw	r2,28(r2)
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 8244a10:	11c03fcc 	andi	r7,r2,255
                    osum, xsum, PUSH_IPADDR(p->fhost));
 8244a14:	e0bfff17 	ldw	r2,-4(fp)
 8244a18:	10800717 	ldw	r2,28(r2)
 8244a1c:	1004d23a 	srli	r2,r2,8
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 8244a20:	10803fcc 	andi	r2,r2,255
                    osum, xsum, PUSH_IPADDR(p->fhost));
 8244a24:	e0ffff17 	ldw	r3,-4(fp)
 8244a28:	18c00717 	ldw	r3,28(r3)
 8244a2c:	1806d43a 	srli	r3,r3,16
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 8244a30:	18c03fcc 	andi	r3,r3,255
                    osum, xsum, PUSH_IPADDR(p->fhost));
 8244a34:	e13fff17 	ldw	r4,-4(fp)
 8244a38:	21000717 	ldw	r4,28(r4)
 8244a3c:	2008d63a 	srli	r4,r4,24
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 8244a40:	d9000215 	stw	r4,8(sp)
 8244a44:	d8c00115 	stw	r3,4(sp)
 8244a48:	d8800015 	stw	r2,0(sp)
 8244a4c:	01020974 	movhi	r4,2085
 8244a50:	2105a004 	addi	r4,r4,5760
 8244a54:	82033a00 	call	82033a0 <printf>
                    osum, xsum, PUSH_IPADDR(p->fhost));
            if (NDEBUG & DUMP)
 8244a58:	d0a08317 	ldw	r2,-32244(gp)
 8244a5c:	1080008c 	andi	r2,r2,2
 8244a60:	10000226 	beq	r2,zero,8244a6c <udpdemux+0x268>
               ip_dump(p);
 8244a64:	e13fff17 	ldw	r4,-4(fp)
 8244a68:	8240a400 	call	8240a40 <ip_dump>
         }
#endif
         udp_mib.udpInErrors++;
 8244a6c:	008209b4 	movhi	r2,2086
 8244a70:	10ba7b04 	addi	r2,r2,-5652
 8244a74:	10800217 	ldw	r2,8(r2)
 8244a78:	10c00044 	addi	r3,r2,1
 8244a7c:	008209b4 	movhi	r2,2086
 8244a80:	10ba7b04 	addi	r2,r2,-5652
 8244a84:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 8244a88:	e13fff17 	ldw	r4,-4(fp)
 8244a8c:	82454c80 	call	82454c8 <udp_free>
         return ENP_BAD_HEADER;
 8244a90:	00bff804 	movi	r2,-32
 8244a94:	00014006 	br	8244f98 <udpdemux+0x794>
      }
   }

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 8244a98:	e13ff717 	ldw	r4,-36(fp)
 8244a9c:	82452440 	call	8245244 <udpswap>
#endif

   /* Prior to upcall, adjust nb_prot for size of IP and UDP headers */
   e = (sizeof(struct udp) + ip_hlen(pip));
 8244aa0:	e0bff617 	ldw	r2,-40(fp)
 8244aa4:	10800003 	ldbu	r2,0(r2)
 8244aa8:	10803fcc 	andi	r2,r2,255
 8244aac:	108003cc 	andi	r2,r2,15
 8244ab0:	1085883a 	add	r2,r2,r2
 8244ab4:	1085883a 	add	r2,r2,r2
 8244ab8:	10800204 	addi	r2,r2,8
 8244abc:	e0bff415 	stw	r2,-48(fp)
   p->nb_plen -= e;
 8244ac0:	e0bfff17 	ldw	r2,-4(fp)
 8244ac4:	10c00417 	ldw	r3,16(r2)
 8244ac8:	e0bff417 	ldw	r2,-48(fp)
 8244acc:	1887c83a 	sub	r3,r3,r2
 8244ad0:	e0bfff17 	ldw	r2,-4(fp)
 8244ad4:	10c00415 	stw	r3,16(r2)
   p->nb_prot += e;
 8244ad8:	e0bfff17 	ldw	r2,-4(fp)
 8244adc:	10c00317 	ldw	r3,12(r2)
 8244ae0:	e0bff417 	ldw	r2,-48(fp)
 8244ae4:	1887883a 	add	r3,r3,r2
 8244ae8:	e0bfff17 	ldw	r2,-4(fp)
 8244aec:	10c00315 	stw	r3,12(r2)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 8244af0:	d0a08317 	ldw	r2,-32244(gp)
 8244af4:	1081000c 	andi	r2,r2,1024
 8244af8:	10001f26 	beq	r2,zero,8244b78 <udpdemux+0x374>
 8244afc:	d0a08317 	ldw	r2,-32244(gp)
 8244b00:	1080400c 	andi	r2,r2,256
 8244b04:	10001c26 	beq	r2,zero,8244b78 <udpdemux+0x374>
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 8244b08:	e0bfff17 	ldw	r2,-4(fp)
 8244b0c:	10800717 	ldw	r2,28(r2)
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 8244b10:	11803fcc 	andi	r6,r2,255
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 8244b14:	e0bfff17 	ldw	r2,-4(fp)
 8244b18:	10800717 	ldw	r2,28(r2)
 8244b1c:	1004d23a 	srli	r2,r2,8
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 8244b20:	11c03fcc 	andi	r7,r2,255
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 8244b24:	e0bfff17 	ldw	r2,-4(fp)
 8244b28:	10800717 	ldw	r2,28(r2)
 8244b2c:	1004d43a 	srli	r2,r2,16
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 8244b30:	10803fcc 	andi	r2,r2,255
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 8244b34:	e0ffff17 	ldw	r3,-4(fp)
 8244b38:	18c00717 	ldw	r3,28(r3)
 8244b3c:	1806d63a 	srli	r3,r3,24
 8244b40:	e13ff717 	ldw	r4,-36(fp)
 8244b44:	2100000b 	ldhu	r4,0(r4)
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 8244b48:	213fffcc 	andi	r4,r4,65535
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 8244b4c:	e17ff717 	ldw	r5,-36(fp)
 8244b50:	2940008b 	ldhu	r5,2(r5)
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 8244b54:	297fffcc 	andi	r5,r5,65535
 8244b58:	d9400315 	stw	r5,12(sp)
 8244b5c:	d9000215 	stw	r4,8(sp)
 8244b60:	d8c00115 	stw	r3,4(sp)
 8244b64:	d8800015 	stw	r2,0(sp)
 8244b68:	e17ff817 	ldw	r5,-32(fp)
 8244b6c:	01020974 	movhi	r4,2085
 8244b70:	2105ae04 	addi	r4,r4,5816
 8244b74:	82033a00 	call	82033a0 <printf>
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 8244b78:	d0a09c17 	ldw	r2,-32144(gp)
 8244b7c:	e0bff215 	stw	r2,-56(fp)
 8244b80:	0000ae06 	br	8244e3c <udpdemux+0x638>
         continue;
#endif

      /* enforce all three aspects of tuple matching. Old code
      assumed lport was unique, which is not always so. */
      if (con->u_lport && (con->u_lport != pup->ud_dstp))
 8244b84:	e0bff217 	ldw	r2,-56(fp)
 8244b88:	1080018b 	ldhu	r2,6(r2)
 8244b8c:	10bfffcc 	andi	r2,r2,65535
 8244b90:	10000726 	beq	r2,zero,8244bb0 <udpdemux+0x3ac>
 8244b94:	e0bff217 	ldw	r2,-56(fp)
 8244b98:	10c0018b 	ldhu	r3,6(r2)
 8244b9c:	e0bff717 	ldw	r2,-36(fp)
 8244ba0:	1080008b 	ldhu	r2,2(r2)
 8244ba4:	18ffffcc 	andi	r3,r3,65535
 8244ba8:	10bfffcc 	andi	r2,r2,65535
 8244bac:	1880991e 	bne	r3,r2,8244e14 <udpdemux+0x610>
         continue;
      if (con->u_fport && (con->u_fport != pup->ud_srcp))
 8244bb0:	e0bff217 	ldw	r2,-56(fp)
 8244bb4:	1080020b 	ldhu	r2,8(r2)
 8244bb8:	10bfffcc 	andi	r2,r2,65535
 8244bbc:	10000726 	beq	r2,zero,8244bdc <udpdemux+0x3d8>
 8244bc0:	e0bff217 	ldw	r2,-56(fp)
 8244bc4:	10c0020b 	ldhu	r3,8(r2)
 8244bc8:	e0bff717 	ldw	r2,-36(fp)
 8244bcc:	1080000b 	ldhu	r2,0(r2)
 8244bd0:	18ffffcc 	andi	r3,r3,65535
 8244bd4:	10bfffcc 	andi	r2,r2,65535
 8244bd8:	1880901e 	bne	r3,r2,8244e1c <udpdemux+0x618>
         continue;
      if (con->u_fhost && (con->u_fhost != p->fhost))
 8244bdc:	e0bff217 	ldw	r2,-56(fp)
 8244be0:	10800417 	ldw	r2,16(r2)
 8244be4:	10000526 	beq	r2,zero,8244bfc <udpdemux+0x3f8>
 8244be8:	e0bff217 	ldw	r2,-56(fp)
 8244bec:	10c00417 	ldw	r3,16(r2)
 8244bf0:	e0bfff17 	ldw	r2,-4(fp)
 8244bf4:	10800717 	ldw	r2,28(r2)
 8244bf8:	18808a1e 	bne	r3,r2,8244e24 <udpdemux+0x620>
#ifdef IP_MULTICAST
      /* In the case of multicast, check if there is multicast membership
       * attached to this socket and if so, is the incoming packet
       * addressed to the multicast address
       */
      if (IN_MULTICAST(ntohl(pip->ip_dest)))
 8244bfc:	e0bff617 	ldw	r2,-40(fp)
 8244c00:	10800417 	ldw	r2,16(r2)
 8244c04:	1006d63a 	srli	r3,r2,24
 8244c08:	e0bff617 	ldw	r2,-40(fp)
 8244c0c:	10800417 	ldw	r2,16(r2)
 8244c10:	1004d23a 	srli	r2,r2,8
 8244c14:	10bfc00c 	andi	r2,r2,65280
 8244c18:	1886b03a 	or	r3,r3,r2
 8244c1c:	e0bff617 	ldw	r2,-40(fp)
 8244c20:	10800417 	ldw	r2,16(r2)
 8244c24:	10bfc00c 	andi	r2,r2,65280
 8244c28:	1004923a 	slli	r2,r2,8
 8244c2c:	1886b03a 	or	r3,r3,r2
 8244c30:	e0bff617 	ldw	r2,-40(fp)
 8244c34:	10800417 	ldw	r2,16(r2)
 8244c38:	1004963a 	slli	r2,r2,24
 8244c3c:	1884b03a 	or	r2,r3,r2
 8244c40:	10fc002c 	andhi	r3,r2,61440
 8244c44:	00b80034 	movhi	r2,57344
 8244c48:	1880301e 	bne	r3,r2,8244d0c <udpdemux+0x508>
      {
         struct socket *soptr = (struct socket *)con->u_data;
 8244c4c:	e0bff217 	ldw	r2,-56(fp)
 8244c50:	10800617 	ldw	r2,24(r2)
 8244c54:	e0bffa15 	stw	r2,-24(fp)

         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
 8244c58:	e0bff217 	ldw	r2,-56(fp)
 8244c5c:	10c00517 	ldw	r3,20(r2)
 8244c60:	00820934 	movhi	r2,2084
 8244c64:	10abdf04 	addi	r2,r2,-20612
 8244c68:	1880281e 	bne	r3,r2,8244d0c <udpdemux+0x508>
 8244c6c:	e0bffa17 	ldw	r2,-24(fp)
 8244c70:	10800317 	ldw	r2,12(r2)
 8244c74:	10002526 	beq	r2,zero,8244d0c <udpdemux+0x508>
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;
 8244c78:	e0bffa17 	ldw	r2,-24(fp)
 8244c7c:	10800317 	ldw	r2,12(r2)
 8244c80:	e0bffb15 	stw	r2,-20(fp)

            for (i = 0; i < imo->imo_num_memberships; ++i)
 8244c84:	e03ff50d 	sth	zero,-44(fp)
 8244c88:	00001906 	br	8244cf0 <udpdemux+0x4ec>
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
 8244c8c:	e0bff50b 	ldhu	r2,-44(fp)
 8244c90:	e0fffb17 	ldw	r3,-20(fp)
 8244c94:	10800084 	addi	r2,r2,2
 8244c98:	1085883a 	add	r2,r2,r2
 8244c9c:	1085883a 	add	r2,r2,r2
 8244ca0:	1885883a 	add	r2,r3,r2
 8244ca4:	10800017 	ldw	r2,0(r2)
 8244ca8:	10c00117 	ldw	r3,4(r2)
 8244cac:	e0bfff17 	ldw	r2,-4(fp)
 8244cb0:	10800617 	ldw	r2,24(r2)
 8244cb4:	18800b1e 	bne	r3,r2,8244ce4 <udpdemux+0x4e0>
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
 8244cb8:	e0bff50b 	ldhu	r2,-44(fp)
 8244cbc:	e0fffb17 	ldw	r3,-20(fp)
 8244cc0:	10800084 	addi	r2,r2,2
 8244cc4:	1085883a 	add	r2,r2,r2
 8244cc8:	1085883a 	add	r2,r2,r2
 8244ccc:	1885883a 	add	r2,r3,r2
 8244cd0:	10800017 	ldw	r2,0(r2)
 8244cd4:	10c00017 	ldw	r3,0(r2)
 8244cd8:	e0bff617 	ldw	r2,-40(fp)
 8244cdc:	10800417 	ldw	r2,16(r2)
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;

            for (i = 0; i < imo->imo_num_memberships; ++i)
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
 8244ce0:	18800926 	beq	r3,r2,8244d08 <udpdemux+0x504>
         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;

            for (i = 0; i < imo->imo_num_memberships; ++i)
 8244ce4:	e0bff50b 	ldhu	r2,-44(fp)
 8244ce8:	10800044 	addi	r2,r2,1
 8244cec:	e0bff50d 	sth	r2,-44(fp)
 8244cf0:	e0bffb17 	ldw	r2,-20(fp)
 8244cf4:	1080018b 	ldhu	r2,6(r2)
 8244cf8:	10bfffcc 	andi	r2,r2,65535
 8244cfc:	e0fff50b 	ldhu	r3,-44(fp)
 8244d00:	18bfe236 	bltu	r3,r2,8244c8c <udpdemux+0x488>
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
               {
                  goto found;
               }
            }
            continue;
 8244d04:	00004a06 	br	8244e30 <udpdemux+0x62c>
            for (i = 0; i < imo->imo_num_memberships; ++i)
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
               {
                  goto found;
 8244d08:	0001883a 	nop
#endif /* INCLUDE_TCP */

      /* if this endpoint has been bound to a local interface address,
       * make sure the packet was received on that interface address
       */
      if (!IN_MULTICAST(ntohl(pip->ip_dest)))
 8244d0c:	e0bff617 	ldw	r2,-40(fp)
 8244d10:	10800417 	ldw	r2,16(r2)
 8244d14:	1006d63a 	srli	r3,r2,24
 8244d18:	e0bff617 	ldw	r2,-40(fp)
 8244d1c:	10800417 	ldw	r2,16(r2)
 8244d20:	1004d23a 	srli	r2,r2,8
 8244d24:	10bfc00c 	andi	r2,r2,65280
 8244d28:	1886b03a 	or	r3,r3,r2
 8244d2c:	e0bff617 	ldw	r2,-40(fp)
 8244d30:	10800417 	ldw	r2,16(r2)
 8244d34:	10bfc00c 	andi	r2,r2,65280
 8244d38:	1004923a 	slli	r2,r2,8
 8244d3c:	1886b03a 	or	r3,r3,r2
 8244d40:	e0bff617 	ldw	r2,-40(fp)
 8244d44:	10800417 	ldw	r2,16(r2)
 8244d48:	1004963a 	slli	r2,r2,24
 8244d4c:	1884b03a 	or	r2,r3,r2
 8244d50:	10fc002c 	andhi	r3,r2,61440
 8244d54:	00b80034 	movhi	r2,57344
 8244d58:	18800826 	beq	r3,r2,8244d7c <udpdemux+0x578>
      {
         if ((con->u_lhost != 0) && (con->u_lhost != pip->ip_dest)) 
 8244d5c:	e0bff217 	ldw	r2,-56(fp)
 8244d60:	10800317 	ldw	r2,12(r2)
 8244d64:	10000526 	beq	r2,zero,8244d7c <udpdemux+0x578>
 8244d68:	e0bff217 	ldw	r2,-56(fp)
 8244d6c:	10c00317 	ldw	r3,12(r2)
 8244d70:	e0bff617 	ldw	r2,-40(fp)
 8244d74:	10800417 	ldw	r2,16(r2)
 8244d78:	18802c1e 	bne	r3,r2,8244e2c <udpdemux+0x628>
            continue;
      }

      /* fall to here if we found it */
      udp_mib.udpInDatagrams++;
 8244d7c:	008209b4 	movhi	r2,2086
 8244d80:	10ba7b04 	addi	r2,r2,-5652
 8244d84:	10800017 	ldw	r2,0(r2)
 8244d88:	10c00044 	addi	r3,r2,1
 8244d8c:	008209b4 	movhi	r2,2086
 8244d90:	10ba7b04 	addi	r2,r2,-5652
 8244d94:	10c00015 	stw	r3,0(r2)
      if (con->u_rcv)         /* if upcall address is set... */
 8244d98:	e0bff217 	ldw	r2,-56(fp)
 8244d9c:	10800517 	ldw	r2,20(r2)
 8244da0:	10000d26 	beq	r2,zero,8244dd8 <udpdemux+0x5d4>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 8244da4:	0009883a 	mov	r4,zero
 8244da8:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         e = ((*con->u_rcv)(p, con->u_data));   /* upcall it */
 8244dac:	e0bff217 	ldw	r2,-56(fp)
 8244db0:	10800517 	ldw	r2,20(r2)
 8244db4:	e0fff217 	ldw	r3,-56(fp)
 8244db8:	18c00617 	ldw	r3,24(r3)
 8244dbc:	180b883a 	mov	r5,r3
 8244dc0:	e13fff17 	ldw	r4,-4(fp)
 8244dc4:	103ee83a 	callr	r2
 8244dc8:	e0bff415 	stw	r2,-48(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 8244dcc:	0009883a 	mov	r4,zero
 8244dd0:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
 8244dd4:	00000206 	br	8244de0 <udpdemux+0x5dc>
      }
      else
         e = ENP_LOGIC;
 8244dd8:	00bffd44 	movi	r2,-11
 8244ddc:	e0bff415 	stw	r2,-48(fp)

      /* if error occurred in upcall or there was no upcall hander
         its up to this routine to free the packet buffer */
      if (e)
 8244de0:	e0bff417 	ldw	r2,-48(fp)
 8244de4:	10000926 	beq	r2,zero,8244e0c <udpdemux+0x608>
      {
         udp_mib.udpInErrors++;
 8244de8:	008209b4 	movhi	r2,2086
 8244dec:	10ba7b04 	addi	r2,r2,-5652
 8244df0:	10800217 	ldw	r2,8(r2)
 8244df4:	10c00044 	addi	r3,r2,1
 8244df8:	008209b4 	movhi	r2,2086
 8244dfc:	10ba7b04 	addi	r2,r2,-5652
 8244e00:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 8244e04:	e13fff17 	ldw	r4,-4(fp)
 8244e08:	82454c80 	call	82454c8 <udp_free>
      }

      return(e);
 8244e0c:	e0bff417 	ldw	r2,-48(fp)
 8244e10:	00006106 	br	8244f98 <udpdemux+0x794>
#endif

      /* enforce all three aspects of tuple matching. Old code
      assumed lport was unique, which is not always so. */
      if (con->u_lport && (con->u_lport != pup->ud_dstp))
         continue;
 8244e14:	0001883a 	nop
 8244e18:	00000506 	br	8244e30 <udpdemux+0x62c>
      if (con->u_fport && (con->u_fport != pup->ud_srcp))
         continue;
 8244e1c:	0001883a 	nop
 8244e20:	00000306 	br	8244e30 <udpdemux+0x62c>
      if (con->u_fhost && (con->u_fhost != p->fhost))
         continue;
 8244e24:	0001883a 	nop
 8244e28:	00000106 	br	8244e30 <udpdemux+0x62c>
       * make sure the packet was received on that interface address
       */
      if (!IN_MULTICAST(ntohl(pip->ip_dest)))
      {
         if ((con->u_lhost != 0) && (con->u_lhost != pip->ip_dest)) 
            continue;
 8244e2c:	0001883a 	nop
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 8244e30:	e0bff217 	ldw	r2,-56(fp)
 8244e34:	10800017 	ldw	r2,0(r2)
 8244e38:	e0bff215 	stw	r2,-56(fp)
 8244e3c:	e0bff217 	ldw	r2,-56(fp)
 8244e40:	103f501e 	bne	r2,zero,8244b84 <udpdemux+0x380>

   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
 8244e44:	e0bff617 	ldw	r2,-40(fp)
 8244e48:	10800417 	ldw	r2,16(r2)
 8244e4c:	10bfffe0 	cmpeqi	r2,r2,-1
 8244e50:	1000121e 	bne	r2,zero,8244e9c <udpdemux+0x698>
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
 8244e54:	e0bff617 	ldw	r2,-40(fp)
 8244e58:	10c00417 	ldw	r3,16(r2)
 8244e5c:	e0bfff17 	ldw	r2,-4(fp)
 8244e60:	10800617 	ldw	r2,24(r2)
 8244e64:	10800e17 	ldw	r2,56(r2)

   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
 8244e68:	18800c26 	beq	r3,r2,8244e9c <udpdemux+0x698>
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
 8244e6c:	e0bff617 	ldw	r2,-40(fp)
 8244e70:	10c00417 	ldw	r3,16(r2)
 8244e74:	e0bfff17 	ldw	r2,-4(fp)
 8244e78:	10800617 	ldw	r2,24(r2)
 8244e7c:	10800f17 	ldw	r2,60(r2)
   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
 8244e80:	18800626 	beq	r3,r2,8244e9c <udpdemux+0x698>
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
       (pip->ip_dest == p->net->n_subnetbr))  /* Our subnet broadcast */
 8244e84:	e0bff617 	ldw	r2,-40(fp)
 8244e88:	10c00417 	ldw	r3,16(r2)
 8244e8c:	e0bfff17 	ldw	r2,-4(fp)
 8244e90:	10800617 	ldw	r2,24(r2)
 8244e94:	10801017 	ldw	r2,64(r2)
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
 8244e98:	1880141e 	bne	r3,r2,8244eec <udpdemux+0x6e8>
       (pip->ip_dest == p->net->n_subnetbr))  /* Our subnet broadcast */
   {
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 8244e9c:	d0a08317 	ldw	r2,-32244(gp)
 8244ea0:	1081000c 	andi	r2,r2,1024
 8244ea4:	10000626 	beq	r2,zero,8244ec0 <udpdemux+0x6bc>
 8244ea8:	d0a08317 	ldw	r2,-32244(gp)
 8244eac:	1080400c 	andi	r2,r2,256
 8244eb0:	10000326 	beq	r2,zero,8244ec0 <udpdemux+0x6bc>
         dprintf("UDP: ignoring ip broadcast\n");
 8244eb4:	01020974 	movhi	r4,2085
 8244eb8:	2105b804 	addi	r4,r4,5856
 8244ebc:	82036240 	call	8203624 <puts>
#endif
      udp_mib.udpInErrors++;
 8244ec0:	008209b4 	movhi	r2,2086
 8244ec4:	10ba7b04 	addi	r2,r2,-5652
 8244ec8:	10800217 	ldw	r2,8(r2)
 8244ecc:	10c00044 	addi	r3,r2,1
 8244ed0:	008209b4 	movhi	r2,2086
 8244ed4:	10ba7b04 	addi	r2,r2,-5652
 8244ed8:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 8244edc:	e13fff17 	ldw	r4,-4(fp)
 8244ee0:	82454c80 	call	82454c8 <udp_free>
      return ENP_NOT_MINE;
 8244ee4:	00800084 	movi	r2,2
 8244ee8:	00002b06 	br	8244f98 <udpdemux+0x794>
   }

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 8244eec:	d0a08317 	ldw	r2,-32244(gp)
 8244ef0:	1081000c 	andi	r2,r2,1024
 8244ef4:	10000f26 	beq	r2,zero,8244f34 <udpdemux+0x730>
 8244ef8:	d0a08317 	ldw	r2,-32244(gp)
 8244efc:	1080400c 	andi	r2,r2,256
 8244f00:	10000c26 	beq	r2,zero,8244f34 <udpdemux+0x730>
   {
      dprintf("UDP: unexpected port %04x\n", pup->ud_dstp);
 8244f04:	e0bff717 	ldw	r2,-36(fp)
 8244f08:	1080008b 	ldhu	r2,2(r2)
 8244f0c:	10bfffcc 	andi	r2,r2,65535
 8244f10:	100b883a 	mov	r5,r2
 8244f14:	01020974 	movhi	r4,2085
 8244f18:	2105bf04 	addi	r4,r4,5884
 8244f1c:	82033a00 	call	82033a0 <printf>
      if (NDEBUG & DUMP) 
 8244f20:	d0a08317 	ldw	r2,-32244(gp)
 8244f24:	1080008c 	andi	r2,r2,2
 8244f28:	10000226 	beq	r2,zero,8244f34 <udpdemux+0x730>
         ip_dump(p);
 8244f2c:	e13fff17 	ldw	r4,-4(fp)
 8244f30:	8240a400 	call	8240a40 <ip_dump>
#ifdef FULL_ICMP
   /* send destination unreachable.  Swap back all the swapped information */
   /* so that the destun packet format is correct */

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 8244f34:	e13ff717 	ldw	r4,-36(fp)
 8244f38:	82452440 	call	8245244 <udpswap>
#endif   /* BYTE_ORDER */
   
   icmp_destun(p->fhost, p->net->n_ipaddr, pip, DSTPORT, p->net);
 8244f3c:	e0bfff17 	ldw	r2,-4(fp)
 8244f40:	10c00717 	ldw	r3,28(r2)
 8244f44:	e0bfff17 	ldw	r2,-4(fp)
 8244f48:	10800617 	ldw	r2,24(r2)
 8244f4c:	11000a17 	ldw	r4,40(r2)
 8244f50:	e0bfff17 	ldw	r2,-4(fp)
 8244f54:	10800617 	ldw	r2,24(r2)
 8244f58:	d8800015 	stw	r2,0(sp)
 8244f5c:	01c000c4 	movi	r7,3
 8244f60:	e1bff617 	ldw	r6,-40(fp)
 8244f64:	200b883a 	mov	r5,r4
 8244f68:	1809883a 	mov	r4,r3
 8244f6c:	824afc40 	call	824afc4 <icmp_destun>
#endif   /* FULL_ICMP */

   udp_mib.udpNoPorts++;
 8244f70:	008209b4 	movhi	r2,2086
 8244f74:	10ba7b04 	addi	r2,r2,-5652
 8244f78:	10800117 	ldw	r2,4(r2)
 8244f7c:	10c00044 	addi	r3,r2,1
 8244f80:	008209b4 	movhi	r2,2086
 8244f84:	10ba7b04 	addi	r2,r2,-5652
 8244f88:	10c00115 	stw	r3,4(r2)
   udp_free(p);
 8244f8c:	e13fff17 	ldw	r4,-4(fp)
 8244f90:	82454c80 	call	82454c8 <udp_free>
   return ENP_NOT_MINE;
 8244f94:	00800084 	movi	r2,2
}
 8244f98:	e037883a 	mov	sp,fp
 8244f9c:	dfc00117 	ldw	ra,4(sp)
 8244fa0:	df000017 	ldw	fp,0(sp)
 8244fa4:	dec00204 	addi	sp,sp,8
 8244fa8:	f800283a 	ret

08244fac <udp_send>:
 * detected. 
 */

int
udp_send(unshort fport, unshort lport, PACKET p)
{
 8244fac:	deffef04 	addi	sp,sp,-68
 8244fb0:	dfc01015 	stw	ra,64(sp)
 8244fb4:	df000f15 	stw	fp,60(sp)
 8244fb8:	df000f04 	addi	fp,sp,60
 8244fbc:	2007883a 	mov	r3,r4
 8244fc0:	2805883a 	mov	r2,r5
 8244fc4:	e1bfff15 	stw	r6,-4(fp)
 8244fc8:	e0fffd0d 	sth	r3,-12(fp)
 8244fcc:	e0bffe0d 	sth	r2,-8(fp)
   int         udplen;
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
 8244fd0:	d0a08317 	ldw	r2,-32244(gp)
 8244fd4:	1080410c 	andi	r2,r2,260
 8244fd8:	10001a26 	beq	r2,zero,8245044 <udp_send+0x98>
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 8244fdc:	e0bfff17 	ldw	r2,-4(fp)
 8244fe0:	12000417 	ldw	r8,16(r2)
 8244fe4:	e1bffe0b 	ldhu	r6,-8(fp)
    PUSH_IPADDR(p->fhost), fport);
 8244fe8:	e0bfff17 	ldw	r2,-4(fp)
 8244fec:	10800717 	ldw	r2,28(r2)
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 8244ff0:	11c03fcc 	andi	r7,r2,255
    PUSH_IPADDR(p->fhost), fport);
 8244ff4:	e0bfff17 	ldw	r2,-4(fp)
 8244ff8:	10800717 	ldw	r2,28(r2)
 8244ffc:	1004d23a 	srli	r2,r2,8
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 8245000:	10803fcc 	andi	r2,r2,255
    PUSH_IPADDR(p->fhost), fport);
 8245004:	e0ffff17 	ldw	r3,-4(fp)
 8245008:	18c00717 	ldw	r3,28(r3)
 824500c:	1806d43a 	srli	r3,r3,16
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 8245010:	18c03fcc 	andi	r3,r3,255
    PUSH_IPADDR(p->fhost), fport);
 8245014:	e13fff17 	ldw	r4,-4(fp)
 8245018:	21000717 	ldw	r4,28(r4)
 824501c:	2008d63a 	srli	r4,r4,24
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 8245020:	e17ffd0b 	ldhu	r5,-12(fp)
 8245024:	d9400315 	stw	r5,12(sp)
 8245028:	d9000215 	stw	r4,8(sp)
 824502c:	d8c00115 	stw	r3,4(sp)
 8245030:	d8800015 	stw	r2,0(sp)
 8245034:	400b883a 	mov	r5,r8
 8245038:	01020974 	movhi	r4,2085
 824503c:	2105c604 	addi	r4,r4,5912
 8245040:	82033a00 	call	82033a0 <printf>
    PUSH_IPADDR(p->fhost), fport);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 8245044:	0009883a 	mov	r4,zero
 8245048:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   /* prepend UDP header to upper layer's data */
   p->nb_prot -= sizeof(struct udp);
 824504c:	e0bfff17 	ldw	r2,-4(fp)
 8245050:	10800317 	ldw	r2,12(r2)
 8245054:	10fffe04 	addi	r3,r2,-8
 8245058:	e0bfff17 	ldw	r2,-4(fp)
 824505c:	10c00315 	stw	r3,12(r2)
   pup = (struct udp*)p->nb_prot;
 8245060:	e0bfff17 	ldw	r2,-4(fp)
 8245064:	10800317 	ldw	r2,12(r2)
 8245068:	e0bff615 	stw	r2,-40(fp)
   udplen = p->nb_plen + sizeof(struct udp);
 824506c:	e0bfff17 	ldw	r2,-4(fp)
 8245070:	10800417 	ldw	r2,16(r2)
 8245074:	10800204 	addi	r2,r2,8
 8245078:	e0bff715 	stw	r2,-36(fp)
   p->nb_plen = udplen;
 824507c:	e0fff717 	ldw	r3,-36(fp)
 8245080:	e0bfff17 	ldw	r2,-4(fp)
 8245084:	10c00415 	stw	r3,16(r2)
   if (udplen & 1) ((char *)pup)[udplen] = 0;
 8245088:	e0bff717 	ldw	r2,-36(fp)
 824508c:	1080004c 	andi	r2,r2,1
 8245090:	10000426 	beq	r2,zero,82450a4 <udp_send+0xf8>
 8245094:	e0bff717 	ldw	r2,-36(fp)
 8245098:	e0fff617 	ldw	r3,-40(fp)
 824509c:	1885883a 	add	r2,r3,r2
 82450a0:	10000005 	stb	zero,0(r2)

      pup->ud_len = (unshort)udplen;   /* fill in the UDP header */
 82450a4:	e0bff717 	ldw	r2,-36(fp)
 82450a8:	1007883a 	mov	r3,r2
 82450ac:	e0bff617 	ldw	r2,-40(fp)
 82450b0:	10c0010d 	sth	r3,4(r2)
   pup->ud_srcp = lport;
 82450b4:	e0bff617 	ldw	r2,-40(fp)
 82450b8:	e0fffe0b 	ldhu	r3,-8(fp)
 82450bc:	10c0000d 	sth	r3,0(r2)
   pup->ud_dstp = fport;
 82450c0:	e0bff617 	ldw	r2,-40(fp)
 82450c4:	e0fffd0b 	ldhu	r3,-12(fp)
 82450c8:	10c0008d 	sth	r3,2(r2)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 82450cc:	e13ff617 	ldw	r4,-40(fp)
 82450d0:	82452440 	call	8245244 <udpswap>
#endif   /* BYTE_ORDER */
   
#ifdef MULTI_HOMED
   /* getting the source IP address for a broadcast is a bit tricky: */
   if (p->fhost == 0xffffffff)
 82450d4:	e0bfff17 	ldw	r2,-4(fp)
 82450d8:	10800717 	ldw	r2,28(r2)
 82450dc:	10bfffd8 	cmpnei	r2,r2,-1
 82450e0:	10000f1e 	bne	r2,zero,8245120 <udp_send+0x174>
   {
      if (!p->net)
 82450e4:	e0bfff17 	ldw	r2,-4(fp)
 82450e8:	10800617 	ldw	r2,24(r2)
 82450ec:	1000071e 	bne	r2,zero,824510c <udp_send+0x160>
      {
         dtrap();    /* programmer forgot to select iface */
 82450f0:	822d5940 	call	822d594 <dtrap>
         /* it would appear that the callers of udp_send() expect it
            to do cleanup on failure, so free the packet buffer here */
         udp_free(p);
 82450f4:	e13fff17 	ldw	r4,-4(fp)
 82450f8:	82454c80 	call	82454c8 <udp_free>
         UNLOCK_NET_RESOURCE(NET_RESID);
 82450fc:	0009883a 	mov	r4,zero
 8245100:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
         return ENP_NO_IFACE;
 8245104:	00bff784 	movi	r2,-34
 8245108:	00004906 	br	8245230 <udp_send+0x284>
      }
      src_ip = p->net->n_ipaddr;
 824510c:	e0bfff17 	ldw	r2,-4(fp)
 8245110:	10800617 	ldw	r2,24(r2)
 8245114:	10800a17 	ldw	r2,40(r2)
 8245118:	e0bff515 	stw	r2,-44(fp)
 824511c:	00000506 	br	8245134 <udp_send+0x188>
   /* set the IP addresses in the IP header. The pseudo header used for
    * checksumming overlays the addresses on the IP header area in the
    * buffer, so setting them there (which we need to do for cksum
    * anyway) sets up for IP too.
    */
   src_ip = ip_mymach(p->fhost);
 8245120:	e0bfff17 	ldw	r2,-4(fp)
 8245124:	10800717 	ldw	r2,28(r2)
 8245128:	1009883a 	mov	r4,r2
 824512c:	824099c0 	call	824099c <ip_mymach>
 8245130:	e0bff515 	stw	r2,-44(fp)
   php.ph_src = src_ip;
 8245134:	e0bff517 	ldw	r2,-44(fp)
 8245138:	e0bffa15 	stw	r2,-24(fp)
   php.ph_dest = p->fhost;
 824513c:	e0bfff17 	ldw	r2,-4(fp)
 8245140:	10800717 	ldw	r2,28(r2)
 8245144:	e0bffb15 	stw	r2,-20(fp)
#ifdef NO_UDP_CKSUM
   /* If no UDP checksum support, just zero the checksum field */
   pup->ud_cksum = 0;
#else
   /* finish filling in the pseudo header required for checksumming */
   php.ph_zero = 0;
 8245148:	e03ffc05 	stb	zero,-16(fp)
   php.ph_prot = UDP_PROT;
 824514c:	00800444 	movi	r2,17
 8245150:	e0bffc45 	stb	r2,-15(fp)
   php.ph_len = pup->ud_len;
 8245154:	e0bff617 	ldw	r2,-40(fp)
 8245158:	1080010b 	ldhu	r2,4(r2)
 824515c:	e0bffc8d 	sth	r2,-14(fp)
   pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 8245160:	e0bffa04 	addi	r2,fp,-24
 8245164:	01400184 	movi	r5,6
 8245168:	1009883a 	mov	r4,r2
 824516c:	82287b40 	call	82287b4 <cksum>
 8245170:	1007883a 	mov	r3,r2
 8245174:	e0bff617 	ldw	r2,-40(fp)
 8245178:	10c0018d 	sth	r3,6(r2)
   pup->ud_cksum = ~cksum(pup, (udplen+1)>>1);
 824517c:	e0bff717 	ldw	r2,-36(fp)
 8245180:	10800044 	addi	r2,r2,1
 8245184:	1005d07a 	srai	r2,r2,1
 8245188:	100b883a 	mov	r5,r2
 824518c:	e13ff617 	ldw	r4,-40(fp)
 8245190:	82287b40 	call	82287b4 <cksum>
 8245194:	0084303a 	nor	r2,zero,r2
 8245198:	1007883a 	mov	r3,r2
 824519c:	e0bff617 	ldw	r2,-40(fp)
 82451a0:	10c0018d 	sth	r3,6(r2)
   if (pup->ud_cksum == 0)
 82451a4:	e0bff617 	ldw	r2,-40(fp)
 82451a8:	1080018b 	ldhu	r2,6(r2)
 82451ac:	10bfffcc 	andi	r2,r2,65535
 82451b0:	1000031e 	bne	r2,zero,82451c0 <udp_send+0x214>
      pup->ud_cksum = 0xffff;
 82451b4:	e0bff617 	ldw	r2,-40(fp)
 82451b8:	00ffffc4 	movi	r3,-1
 82451bc:	10c0018d 	sth	r3,6(r2)
#endif

   /* need to fill in IP addresses at this layer too */
   pip = (struct ip *)(p->nb_prot - sizeof(struct ip));
 82451c0:	e0bfff17 	ldw	r2,-4(fp)
 82451c4:	10800317 	ldw	r2,12(r2)
 82451c8:	10bffb04 	addi	r2,r2,-20
 82451cc:	e0bff815 	stw	r2,-32(fp)
   pip->ip_src = src_ip;
 82451d0:	e0bff817 	ldw	r2,-32(fp)
 82451d4:	e0fff517 	ldw	r3,-44(fp)
 82451d8:	10c00315 	stw	r3,12(r2)
   pip->ip_dest = p->fhost;
 82451dc:	e0bfff17 	ldw	r2,-4(fp)
 82451e0:	10c00717 	ldw	r3,28(r2)
 82451e4:	e0bff817 	ldw	r2,-32(fp)
 82451e8:	10c00415 	stw	r3,16(r2)

   udp_mib.udpOutDatagrams++;
 82451ec:	008209b4 	movhi	r2,2086
 82451f0:	10ba7b04 	addi	r2,r2,-5652
 82451f4:	10800317 	ldw	r2,12(r2)
 82451f8:	10c00044 	addi	r3,r2,1
 82451fc:	008209b4 	movhi	r2,2086
 8245200:	10ba7b04 	addi	r2,r2,-5652
 8245204:	10c00315 	stw	r3,12(r2)

   p->nb_plen = udplen;       /* nb_prot was adjusted above */
 8245208:	e0fff717 	ldw	r3,-36(fp)
 824520c:	e0bfff17 	ldw	r2,-4(fp)
 8245210:	10c00415 	stw	r3,16(r2)
   e = ip_write(UDP_PROT, p);
 8245214:	e17fff17 	ldw	r5,-4(fp)
 8245218:	01000444 	movi	r4,17
 824521c:	823f94c0 	call	823f94c <ip_write>
 8245220:	e0bff915 	stw	r2,-28(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 8245224:	0009883a 	mov	r4,zero
 8245228:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   return e;
 824522c:	e0bff917 	ldw	r2,-28(fp)
}
 8245230:	e037883a 	mov	sp,fp
 8245234:	dfc00117 	ldw	ra,4(sp)
 8245238:	df000017 	ldw	fp,0(sp)
 824523c:	dec00204 	addi	sp,sp,8
 8245240:	f800283a 	ret

08245244 <udpswap>:
 */

#if (BYTE_ORDER == LITTLE_ENDIAN)
void
udpswap(struct udp *pup)
{
 8245244:	defffe04 	addi	sp,sp,-8
 8245248:	df000115 	stw	fp,4(sp)
 824524c:	df000104 	addi	fp,sp,4
 8245250:	e13fff15 	stw	r4,-4(fp)

   pup->ud_srcp = htons(pup->ud_srcp);
 8245254:	e0bfff17 	ldw	r2,-4(fp)
 8245258:	1080000b 	ldhu	r2,0(r2)
 824525c:	10bfffcc 	andi	r2,r2,65535
 8245260:	1004d23a 	srli	r2,r2,8
 8245264:	1007883a 	mov	r3,r2
 8245268:	e0bfff17 	ldw	r2,-4(fp)
 824526c:	1080000b 	ldhu	r2,0(r2)
 8245270:	10bfffcc 	andi	r2,r2,65535
 8245274:	1004923a 	slli	r2,r2,8
 8245278:	1884b03a 	or	r2,r3,r2
 824527c:	1007883a 	mov	r3,r2
 8245280:	e0bfff17 	ldw	r2,-4(fp)
 8245284:	10c0000d 	sth	r3,0(r2)
   pup->ud_dstp = htons(pup->ud_dstp);
 8245288:	e0bfff17 	ldw	r2,-4(fp)
 824528c:	1080008b 	ldhu	r2,2(r2)
 8245290:	10bfffcc 	andi	r2,r2,65535
 8245294:	1004d23a 	srli	r2,r2,8
 8245298:	1007883a 	mov	r3,r2
 824529c:	e0bfff17 	ldw	r2,-4(fp)
 82452a0:	1080008b 	ldhu	r2,2(r2)
 82452a4:	10bfffcc 	andi	r2,r2,65535
 82452a8:	1004923a 	slli	r2,r2,8
 82452ac:	1884b03a 	or	r2,r3,r2
 82452b0:	1007883a 	mov	r3,r2
 82452b4:	e0bfff17 	ldw	r2,-4(fp)
 82452b8:	10c0008d 	sth	r3,2(r2)
   pup->ud_len = htons(pup->ud_len);
 82452bc:	e0bfff17 	ldw	r2,-4(fp)
 82452c0:	1080010b 	ldhu	r2,4(r2)
 82452c4:	10bfffcc 	andi	r2,r2,65535
 82452c8:	1004d23a 	srli	r2,r2,8
 82452cc:	1007883a 	mov	r3,r2
 82452d0:	e0bfff17 	ldw	r2,-4(fp)
 82452d4:	1080010b 	ldhu	r2,4(r2)
 82452d8:	10bfffcc 	andi	r2,r2,65535
 82452dc:	1004923a 	slli	r2,r2,8
 82452e0:	1884b03a 	or	r2,r3,r2
 82452e4:	1007883a 	mov	r3,r2
 82452e8:	e0bfff17 	ldw	r2,-4(fp)
 82452ec:	10c0010d 	sth	r3,4(r2)
   pup->ud_cksum = htons(pup->ud_cksum);
 82452f0:	e0bfff17 	ldw	r2,-4(fp)
 82452f4:	1080018b 	ldhu	r2,6(r2)
 82452f8:	10bfffcc 	andi	r2,r2,65535
 82452fc:	1004d23a 	srli	r2,r2,8
 8245300:	1007883a 	mov	r3,r2
 8245304:	e0bfff17 	ldw	r2,-4(fp)
 8245308:	1080018b 	ldhu	r2,6(r2)
 824530c:	10bfffcc 	andi	r2,r2,65535
 8245310:	1004923a 	slli	r2,r2,8
 8245314:	1884b03a 	or	r2,r3,r2
 8245318:	1007883a 	mov	r3,r2
 824531c:	e0bfff17 	ldw	r2,-4(fp)
 8245320:	10c0018d 	sth	r3,6(r2)
}
 8245324:	0001883a 	nop
 8245328:	e037883a 	mov	sp,fp
 824532c:	df000017 	ldw	fp,0(sp)
 8245330:	dec00104 	addi	sp,sp,4
 8245334:	f800283a 	ret

08245338 <udp_socket>:
#define  MINSOCKET   1200
static unshort usocket = 0;   /* next socket to grab */

unshort
udp_socket(void)
{
 8245338:	defffe04 	addi	sp,sp,-8
 824533c:	df000115 	stw	fp,4(sp)
 8245340:	df000104 	addi	fp,sp,4
   UDPCONN tmp;

   if (usocket < MINSOCKET)
 8245344:	d0a0d10b 	ldhu	r2,-31932(gp)
 8245348:	10bfffcc 	andi	r2,r2,65535
 824534c:	10812c28 	cmpgeui	r2,r2,1200
 8245350:	10000a1e 	bne	r2,zero,824537c <udp_socket+0x44>
   {
      /* logic for for init and after wraps */
      usocket = (unshort)(cticks & 0x7fff);
 8245354:	d0a0a817 	ldw	r2,-32096(gp)
 8245358:	109fffcc 	andi	r2,r2,32767
 824535c:	d0a0d10d 	sth	r2,-31932(gp)
      if (usocket < MINSOCKET)
 8245360:	d0a0d10b 	ldhu	r2,-31932(gp)
 8245364:	10bfffcc 	andi	r2,r2,65535
 8245368:	10812c28 	cmpgeui	r2,r2,1200
 824536c:	1000031e 	bne	r2,zero,824537c <udp_socket+0x44>
         usocket += MINSOCKET;
 8245370:	d0a0d10b 	ldhu	r2,-31932(gp)
 8245374:	10812c04 	addi	r2,r2,1200
 8245378:	d0a0d10d 	sth	r2,-31932(gp)
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 824537c:	d0a09c17 	ldw	r2,-32144(gp)
 8245380:	e0bfff15 	stw	r2,-4(fp)
 8245384:	00000f06 	br	82453c4 <udp_socket+0x8c>
   {
      if (tmp->u_lport == usocket)
 8245388:	e0bfff17 	ldw	r2,-4(fp)
 824538c:	10c0018b 	ldhu	r3,6(r2)
 8245390:	d0a0d10b 	ldhu	r2,-31932(gp)
 8245394:	18ffffcc 	andi	r3,r3,65535
 8245398:	10bfffcc 	andi	r2,r2,65535
 824539c:	1880061e 	bne	r3,r2,82453b8 <udp_socket+0x80>
      {
         usocket++;     /* bump socket number */
 82453a0:	d0a0d10b 	ldhu	r2,-31932(gp)
 82453a4:	10800044 	addi	r2,r2,1
 82453a8:	d0a0d10d 	sth	r2,-31932(gp)
         tmp = firstudp;   /* restart scan */
 82453ac:	d0a09c17 	ldw	r2,-32144(gp)
 82453b0:	e0bfff15 	stw	r2,-4(fp)
         continue;
 82453b4:	0001883a 	nop
      usocket = (unshort)(cticks & 0x7fff);
      if (usocket < MINSOCKET)
         usocket += MINSOCKET;
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 82453b8:	e0bfff17 	ldw	r2,-4(fp)
 82453bc:	10800017 	ldw	r2,0(r2)
 82453c0:	e0bfff15 	stw	r2,-4(fp)
 82453c4:	e0bfff17 	ldw	r2,-4(fp)
 82453c8:	103fef1e 	bne	r2,zero,8245388 <udp_socket+0x50>
         usocket++;     /* bump socket number */
         tmp = firstudp;   /* restart scan */
         continue;
      }
   }
   return usocket++;
 82453cc:	d0a0d10b 	ldhu	r2,-31932(gp)
 82453d0:	10c00044 	addi	r3,r2,1
 82453d4:	d0e0d10d 	sth	r3,-31932(gp)
}
 82453d8:	e037883a 	mov	sp,fp
 82453dc:	df000017 	ldw	fp,0(sp)
 82453e0:	dec00104 	addi	sp,sp,4
 82453e4:	f800283a 	ret

082453e8 <udp_alloc>:
 * RETURNS:  Returns buffer, or NULL in no buffer was available. 
 */

PACKET
udp_alloc(int datalen, int optlen)
{
 82453e8:	defffa04 	addi	sp,sp,-24
 82453ec:	dfc00515 	stw	ra,20(sp)
 82453f0:	df000415 	stw	fp,16(sp)
 82453f4:	df000404 	addi	fp,sp,16
 82453f8:	e13ffe15 	stw	r4,-8(fp)
 82453fc:	e17fff15 	stw	r5,-4(fp)
   int   len;
   PACKET p;

   len = (datalen + sizeof(struct udp) + 1) & ~1;
 8245400:	e0bffe17 	ldw	r2,-8(fp)
 8245404:	10800244 	addi	r2,r2,9
 8245408:	1007883a 	mov	r3,r2
 824540c:	00bfff84 	movi	r2,-2
 8245410:	1884703a 	and	r2,r3,r2
 8245414:	e0bffc15 	stw	r2,-16(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8245418:	01000084 	movi	r4,2
 824541c:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   p = pk_alloc(len + UDPHDRSLEN + optlen);
 8245420:	e0bffc17 	ldw	r2,-16(fp)
 8245424:	10c00904 	addi	r3,r2,36
 8245428:	e0bfff17 	ldw	r2,-4(fp)
 824542c:	1885883a 	add	r2,r3,r2
 8245430:	1009883a 	mov	r4,r2
 8245434:	822c9ec0 	call	822c9ec <pk_alloc>
 8245438:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824543c:	01000084 	movi	r4,2
 8245440:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>

   if (p != (PACKET)NULL)
 8245444:	e0bffd17 	ldw	r2,-12(fp)
 8245448:	10001026 	beq	r2,zero,824548c <udp_alloc+0xa4>
   {
      /* set prot pointers past end of UDP header  */
      len = sizeof(struct ip) + (optlen >> 2) + sizeof(struct udp);
 824544c:	e0bfff17 	ldw	r2,-4(fp)
 8245450:	1005d0ba 	srai	r2,r2,2
 8245454:	10800704 	addi	r2,r2,28
 8245458:	e0bffc15 	stw	r2,-16(fp)
      p->nb_prot += len;
 824545c:	e0bffd17 	ldw	r2,-12(fp)
 8245460:	10c00317 	ldw	r3,12(r2)
 8245464:	e0bffc17 	ldw	r2,-16(fp)
 8245468:	1887883a 	add	r3,r3,r2
 824546c:	e0bffd17 	ldw	r2,-12(fp)
 8245470:	10c00315 	stw	r3,12(r2)
      p->nb_plen -= len;
 8245474:	e0bffd17 	ldw	r2,-12(fp)
 8245478:	10c00417 	ldw	r3,16(r2)
 824547c:	e0bffc17 	ldw	r2,-16(fp)
 8245480:	1887c83a 	sub	r3,r3,r2
 8245484:	e0bffd17 	ldw	r2,-12(fp)
 8245488:	10c00415 	stw	r3,16(r2)
   }

   return (p);
 824548c:	e0bffd17 	ldw	r2,-12(fp)
}
 8245490:	e037883a 	mov	sp,fp
 8245494:	dfc00117 	ldw	ra,4(sp)
 8245498:	df000017 	ldw	fp,0(sp)
 824549c:	dec00204 	addi	sp,sp,8
 82454a0:	f800283a 	ret

082454a4 <udp_maxalloc>:
 *          returned value, the allocation will fail
 */

int
udp_maxalloc(void)
{
 82454a4:	deffff04 	addi	sp,sp,-4
 82454a8:	df000015 	stw	fp,0(sp)
 82454ac:	d839883a 	mov	fp,sp
    * created is ((2^16 - 1) - (size of IP and UDP headers)) */
   return (0xFFFF - (sizeof (struct ip) + sizeof (struct udp)));
#else
   /* if heap buffers are not available, the largest size of a UDP datagram
    * is constrained by what will fit inside a big buffer */
   return (bigbufsiz - UDPHDRSLEN);
 82454b0:	d0a03917 	ldw	r2,-32540(gp)
 82454b4:	10bff704 	addi	r2,r2,-36
#endif
}
 82454b8:	e037883a 	mov	sp,fp
 82454bc:	df000017 	ldw	fp,0(sp)
 82454c0:	dec00104 	addi	sp,sp,4
 82454c4:	f800283a 	ret

082454c8 <udp_free>:
 * RETURNS: void
 */

void
udp_free(PACKET p)
{
 82454c8:	defffd04 	addi	sp,sp,-12
 82454cc:	dfc00215 	stw	ra,8(sp)
 82454d0:	df000115 	stw	fp,4(sp)
 82454d4:	df000104 	addi	fp,sp,4
 82454d8:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 82454dc:	01000084 	movi	r4,2
 82454e0:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   pk_free(p);
 82454e4:	e13fff17 	ldw	r4,-4(fp)
 82454e8:	822cd3c0 	call	822cd3c <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82454ec:	01000084 	movi	r4,2
 82454f0:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
}
 82454f4:	0001883a 	nop
 82454f8:	e037883a 	mov	sp,fp
 82454fc:	dfc00117 	ldw	ra,4(sp)
 8245500:	df000017 	ldw	fp,0(sp)
 8245504:	dec00204 	addi	sp,sp,8
 8245508:	f800283a 	ret

0824550c <igmpv1_input>:
 * OUTPUT: This function returns IGMP_ERR if it is passed an "unknown"
 * packet type.  Otherwise, it returns IGMP_OK.
 */

int igmpv1_input(PACKET p)
{
 824550c:	defff804 	addi	sp,sp,-32
 8245510:	dfc00715 	stw	ra,28(sp)
 8245514:	df000615 	stw	fp,24(sp)
 8245518:	df000604 	addi	fp,sp,24
 824551c:	e13fff15 	stw	r4,-4(fp)
   struct igmp *  igmp;
   struct ip *    pip;
   struct in_multi * inm;
   NET netp  = p->net;
 8245520:	e0bfff17 	ldw	r2,-4(fp)
 8245524:	10800617 	ldw	r2,24(r2)
 8245528:	e0bffc15 	stw	r2,-16(fp)
   int rc;
         
   pip = ip_head (p);
 824552c:	e0bfff17 	ldw	r2,-4(fp)
 8245530:	10800317 	ldw	r2,12(r2)
 8245534:	e0bffd15 	stw	r2,-12(fp)
   igmp = (struct igmp *) (ip_data (pip));
 8245538:	e0bffd17 	ldw	r2,-12(fp)
 824553c:	10800003 	ldbu	r2,0(r2)
 8245540:	10803fcc 	andi	r2,r2,255
 8245544:	108003cc 	andi	r2,r2,15
 8245548:	1085883a 	add	r2,r2,r2
 824554c:	1085883a 	add	r2,r2,r2
 8245550:	1007883a 	mov	r3,r2
 8245554:	e0bffd17 	ldw	r2,-12(fp)
 8245558:	10c5883a 	add	r2,r2,r3
 824555c:	e0bffe15 	stw	r2,-8(fp)

   switch (igmp->igmp_type) 
 8245560:	e0bffe17 	ldw	r2,-8(fp)
 8245564:	10800003 	ldbu	r2,0(r2)
 8245568:	10803fcc 	andi	r2,r2,255
 824556c:	10c00460 	cmpeqi	r3,r2,17
 8245570:	1800031e 	bne	r3,zero,8245580 <igmpv1_input+0x74>
 8245574:	108004a0 	cmpeqi	r2,r2,18
 8245578:	1000571e 	bne	r2,zero,82456d8 <igmpv1_input+0x1cc>
 824557c:	00007606 	br	8245758 <igmpv1_input+0x24c>
   {
   case IGMP_HOST_MEMBERSHIP_QUERY:
      ++igmpstats.igmpv1mode_v1_queries_rcvd;
 8245580:	008209b4 	movhi	r2,2086
 8245584:	10b81f04 	addi	r2,r2,-8068
 8245588:	10800117 	ldw	r2,4(r2)
 824558c:	10c00044 	addi	r3,r2,1
 8245590:	008209b4 	movhi	r2,2086
 8245594:	10b81f04 	addi	r2,r2,-8068
 8245598:	10c00115 	stw	r3,4(r2)
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 824559c:	e0bffc17 	ldw	r2,-16(fp)
 82455a0:	10802c17 	ldw	r2,176(r2)
 82455a4:	e0bffa15 	stw	r2,-24(fp)
 82455a8:	00004706 	br	82456c8 <igmpv1_input+0x1bc>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (inm->inm_addr == 0)
 82455ac:	e0bffa17 	ldw	r2,-24(fp)
 82455b0:	10800017 	ldw	r2,0(r2)
 82455b4:	10004026 	beq	r2,zero,82456b8 <igmpv1_input+0x1ac>
            continue;
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 82455b8:	e0bffa17 	ldw	r2,-24(fp)
 82455bc:	10c00017 	ldw	r3,0(r2)
 82455c0:	d0a08817 	ldw	r2,-32224(gp)
 82455c4:	18803d26 	beq	r3,r2,82456bc <igmpv1_input+0x1b0>
         {
            if (inm->inm_timer == 0)
 82455c8:	e0bffa17 	ldw	r2,-24(fp)
 82455cc:	10800317 	ldw	r2,12(r2)
 82455d0:	10003a1e 	bne	r2,zero,82456bc <igmpv1_input+0x1b0>
            {
               inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 82455d4:	008209b4 	movhi	r2,2086
 82455d8:	10ba6104 	addi	r2,r2,-5756
 82455dc:	10c00217 	ldw	r3,8(r2)
 82455e0:	008209b4 	movhi	r2,2086
 82455e4:	10b81b04 	addi	r2,r2,-8084
 82455e8:	10800017 	ldw	r2,0(r2)
 82455ec:	10800a17 	ldw	r2,40(r2)
 82455f0:	1008d63a 	srli	r4,r2,24
 82455f4:	008209b4 	movhi	r2,2086
 82455f8:	10b81b04 	addi	r2,r2,-8084
 82455fc:	10800017 	ldw	r2,0(r2)
 8245600:	10800a17 	ldw	r2,40(r2)
 8245604:	1004d23a 	srli	r2,r2,8
 8245608:	10bfc00c 	andi	r2,r2,65280
 824560c:	2088b03a 	or	r4,r4,r2
 8245610:	008209b4 	movhi	r2,2086
 8245614:	10b81b04 	addi	r2,r2,-8084
 8245618:	10800017 	ldw	r2,0(r2)
 824561c:	10800a17 	ldw	r2,40(r2)
 8245620:	10bfc00c 	andi	r2,r2,65280
 8245624:	1004923a 	slli	r2,r2,8
 8245628:	2088b03a 	or	r4,r4,r2
 824562c:	008209b4 	movhi	r2,2086
 8245630:	10b81b04 	addi	r2,r2,-8084
 8245634:	10800017 	ldw	r2,0(r2)
 8245638:	10800a17 	ldw	r2,40(r2)
 824563c:	1004963a 	slli	r2,r2,24
 8245640:	2084b03a 	or	r2,r4,r2
 8245644:	1887883a 	add	r3,r3,r2
 8245648:	e0bffa17 	ldw	r2,-24(fp)
 824564c:	10800017 	ldw	r2,0(r2)
 8245650:	1008d63a 	srli	r4,r2,24
 8245654:	e0bffa17 	ldw	r2,-24(fp)
 8245658:	10800017 	ldw	r2,0(r2)
 824565c:	1004d23a 	srli	r2,r2,8
 8245660:	10bfc00c 	andi	r2,r2,65280
 8245664:	2088b03a 	or	r4,r4,r2
 8245668:	e0bffa17 	ldw	r2,-24(fp)
 824566c:	10800017 	ldw	r2,0(r2)
 8245670:	10bfc00c 	andi	r2,r2,65280
 8245674:	1004923a 	slli	r2,r2,8
 8245678:	2088b03a 	or	r4,r4,r2
 824567c:	e0bffa17 	ldw	r2,-24(fp)
 8245680:	10800017 	ldw	r2,0(r2)
 8245684:	1004963a 	slli	r2,r2,24
 8245688:	2084b03a 	or	r2,r4,r2
 824568c:	1885883a 	add	r2,r3,r2
 8245690:	01400c84 	movi	r5,50
 8245694:	1009883a 	mov	r4,r2
 8245698:	8202c740 	call	8202c74 <__umodsi3>
 824569c:	10c00044 	addi	r3,r2,1
 82456a0:	e0bffa17 	ldw	r2,-24(fp)
 82456a4:	10c00315 	stw	r3,12(r2)
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
 82456a8:	d0a08617 	ldw	r2,-32232(gp)
 82456ac:	10800044 	addi	r2,r2,1
 82456b0:	d0a08615 	stw	r2,-32232(gp)
 82456b4:	00000106 	br	82456bc <igmpv1_input+0x1b0>
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (inm->inm_addr == 0)
            continue;
 82456b8:	0001883a 	nop
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 82456bc:	e0bffa17 	ldw	r2,-24(fp)
 82456c0:	10800517 	ldw	r2,20(r2)
 82456c4:	e0bffa15 	stw	r2,-24(fp)
 82456c8:	e0bffa17 	ldw	r2,-24(fp)
 82456cc:	103fb71e 	bne	r2,zero,82455ac <igmpv1_input+0xa0>
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
            }   
         }
      }
      rc = IGMP_OK;
 82456d0:	e03ffb15 	stw	zero,-20(fp)
      break;
 82456d4:	00002a06 	br	8245780 <igmpv1_input+0x274>

   case IGMP_HOST_MEMBERSHIP_REPORT:
      ++igmpstats.igmpv1mode_v1_reports_rcvd;
 82456d8:	008209b4 	movhi	r2,2086
 82456dc:	10b81f04 	addi	r2,r2,-8068
 82456e0:	10800217 	ldw	r2,8(r2)
 82456e4:	10c00044 	addi	r3,r2,1
 82456e8:	008209b4 	movhi	r2,2086
 82456ec:	10b81f04 	addi	r2,r2,-8068
 82456f0:	10c00215 	stw	r3,8(r2)
      /*
       * If we belong to the group being reported and have a 
       * running timer for that group, stop our timer for that 
       * group.
       */
      inm = lookup_mcast(igmp->igmp_group, netp);
 82456f4:	e0bffe17 	ldw	r2,-8(fp)
 82456f8:	10800117 	ldw	r2,4(r2)
 82456fc:	e17ffc17 	ldw	r5,-16(fp)
 8245700:	1009883a 	mov	r4,r2
 8245704:	8243ba80 	call	8243ba8 <lookup_mcast>
 8245708:	e0bffa15 	stw	r2,-24(fp)
      if (inm != NULL) 
 824570c:	e0bffa17 	ldw	r2,-24(fp)
 8245710:	10000f26 	beq	r2,zero,8245750 <igmpv1_input+0x244>
      {
         if (inm->inm_timer > 0)
 8245714:	e0bffa17 	ldw	r2,-24(fp)
 8245718:	10800317 	ldw	r2,12(r2)
 824571c:	10000c26 	beq	r2,zero,8245750 <igmpv1_input+0x244>
         {
            inm->inm_timer = 0;
 8245720:	e0bffa17 	ldw	r2,-24(fp)
 8245724:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 8245728:	d0a08617 	ldw	r2,-32232(gp)
 824572c:	10bfffc4 	addi	r2,r2,-1
 8245730:	d0a08615 	stw	r2,-32232(gp)
            ++igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer;
 8245734:	008209b4 	movhi	r2,2086
 8245738:	10b81f04 	addi	r2,r2,-8068
 824573c:	10800317 	ldw	r2,12(r2)
 8245740:	10c00044 	addi	r3,r2,1
 8245744:	008209b4 	movhi	r2,2086
 8245748:	10b81f04 	addi	r2,r2,-8068
 824574c:	10c00315 	stw	r3,12(r2)
         }
      }
      rc = IGMP_OK;
 8245750:	e03ffb15 	stw	zero,-20(fp)
      break;
 8245754:	00000a06 	br	8245780 <igmpv1_input+0x274>
      
   default:
      ++igmpstats.igmpv1mode_unknown_pkttype;
 8245758:	008209b4 	movhi	r2,2086
 824575c:	10b81f04 	addi	r2,r2,-8068
 8245760:	10801017 	ldw	r2,64(r2)
 8245764:	10c00044 	addi	r3,r2,1
 8245768:	008209b4 	movhi	r2,2086
 824576c:	10b81f04 	addi	r2,r2,-8068
 8245770:	10c01015 	stw	r3,64(r2)
      rc = IGMP_ERR;
 8245774:	00bfffc4 	movi	r2,-1
 8245778:	e0bffb15 	stw	r2,-20(fp)
      break;   
 824577c:	0001883a 	nop
   }

   /* we're done with the received packet; return packet buffer back 
    * to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8245780:	01000084 	movi	r4,2
 8245784:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   pk_free(p);
 8245788:	e13fff17 	ldw	r4,-4(fp)
 824578c:	822cd3c0 	call	822cd3c <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8245790:	01000084 	movi	r4,2
 8245794:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      
   return rc;
 8245798:	e0bffb17 	ldw	r2,-20(fp)
}
 824579c:	e037883a 	mov	sp,fp
 82457a0:	dfc00117 	ldw	ra,4(sp)
 82457a4:	df000017 	ldw	fp,0(sp)
 82457a8:	dec00204 	addi	sp,sp,8
 82457ac:	f800283a 	ret

082457b0 <igmpv2_input>:
 * from igmpv2_process_report (), IGMP_OK (for a received Leave Group
 * message only), or IGMP_ERR (for a message of an "unknown" type).
 */

int igmpv2_input (PACKET p)
{
 82457b0:	defff904 	addi	sp,sp,-28
 82457b4:	dfc00615 	stw	ra,24(sp)
 82457b8:	df000515 	stw	fp,20(sp)
 82457bc:	df000504 	addi	fp,sp,20
 82457c0:	e13fff15 	stw	r4,-4(fp)
   struct igmp * igmp;
   struct ip * pip;
   u_char type;
   int rc;

   pip = ip_head (p);    
 82457c4:	e0bfff17 	ldw	r2,-4(fp)
 82457c8:	10800317 	ldw	r2,12(r2)
 82457cc:	e0bffc15 	stw	r2,-16(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 82457d0:	e0bffc17 	ldw	r2,-16(fp)
 82457d4:	10800003 	ldbu	r2,0(r2)
 82457d8:	10803fcc 	andi	r2,r2,255
 82457dc:	108003cc 	andi	r2,r2,15
 82457e0:	1085883a 	add	r2,r2,r2
 82457e4:	1085883a 	add	r2,r2,r2
 82457e8:	1007883a 	mov	r3,r2
 82457ec:	e0bffc17 	ldw	r2,-16(fp)
 82457f0:	10c5883a 	add	r2,r2,r3
 82457f4:	e0bffd15 	stw	r2,-12(fp)
   /* extract the IGMP packet type from received packet */
   type = igmp->igmp_type;
 82457f8:	e0bffd17 	ldw	r2,-12(fp)
 82457fc:	10800003 	ldbu	r2,0(r2)
 8245800:	e0bffe05 	stb	r2,-8(fp)

   switch (type) 
 8245804:	e0bffe03 	ldbu	r2,-8(fp)
 8245808:	10c004a0 	cmpeqi	r3,r2,18
 824580c:	18000e1e 	bne	r3,zero,8245848 <igmpv2_input+0x98>
 8245810:	10c004c8 	cmpgei	r3,r2,19
 8245814:	1800031e 	bne	r3,zero,8245824 <igmpv2_input+0x74>
 8245818:	10800460 	cmpeqi	r2,r2,17
 824581c:	1000061e 	bne	r2,zero,8245838 <igmpv2_input+0x88>
 8245820:	00001606 	br	824587c <igmpv2_input+0xcc>
 8245824:	10c005a0 	cmpeqi	r3,r2,22
 8245828:	1800071e 	bne	r3,zero,8245848 <igmpv2_input+0x98>
 824582c:	108005e0 	cmpeqi	r2,r2,23
 8245830:	1000091e 	bne	r2,zero,8245858 <igmpv2_input+0xa8>
 8245834:	00001106 	br	824587c <igmpv2_input+0xcc>
   {
      case IGMP_HOST_MEMBERSHIP_QUERY:
         rc = igmpv2_process_query (p);
 8245838:	e13fff17 	ldw	r4,-4(fp)
 824583c:	8245a080 	call	8245a08 <igmpv2_process_query>
 8245840:	e0bffb15 	stw	r2,-20(fp)
         break;
 8245844:	00001706 	br	82458a4 <igmpv2_input+0xf4>

      case IGMP_HOST_MEMBERSHIP_REPORT:
      case IGMPv2_MEMBERSHIP_REPORT:
         rc = igmpv2_process_report (p);
 8245848:	e13fff17 	ldw	r4,-4(fp)
 824584c:	82458d40 	call	82458d4 <igmpv2_process_report>
 8245850:	e0bffb15 	stw	r2,-20(fp)
         break;
 8245854:	00001306 	br	82458a4 <igmpv2_input+0xf4>
          * expect to receive such messages.  However, according to
          * RFC 2236, some implementations of an older version of the 
          * IGMPv2 specification send leave messages to the group 
          * being left.  If we do receive such a message, we will 
          * drop it. */       
         ++igmpstats.igmpv2mode_v2_leave_msgs_rcvd;
 8245858:	008209b4 	movhi	r2,2086
 824585c:	10b81f04 	addi	r2,r2,-8068
 8245860:	10800917 	ldw	r2,36(r2)
 8245864:	10c00044 	addi	r3,r2,1
 8245868:	008209b4 	movhi	r2,2086
 824586c:	10b81f04 	addi	r2,r2,-8068
 8245870:	10c00915 	stw	r3,36(r2)
         rc = IGMP_OK;
 8245874:	e03ffb15 	stw	zero,-20(fp)
         break;               
 8245878:	00000a06 	br	82458a4 <igmpv2_input+0xf4>

      default:     
         ++igmpstats.igmpv2mode_unknown_pkttype;
 824587c:	008209b4 	movhi	r2,2086
 8245880:	10b81f04 	addi	r2,r2,-8068
 8245884:	10801517 	ldw	r2,84(r2)
 8245888:	10c00044 	addi	r3,r2,1
 824588c:	008209b4 	movhi	r2,2086
 8245890:	10b81f04 	addi	r2,r2,-8068
 8245894:	10c01515 	stw	r3,84(r2)
         rc = IGMP_ERR;         
 8245898:	00bfffc4 	movi	r2,-1
 824589c:	e0bffb15 	stw	r2,-20(fp)
         break;
 82458a0:	0001883a 	nop
   } /* end SWITCH */

   /* we're done processing the received packet; return packet buffer 
    * back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 82458a4:	01000084 	movi	r4,2
 82458a8:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   pk_free(p);
 82458ac:	e13fff17 	ldw	r4,-4(fp)
 82458b0:	822cd3c0 	call	822cd3c <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82458b4:	01000084 	movi	r4,2
 82458b8:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
   
   return rc;
 82458bc:	e0bffb17 	ldw	r2,-20(fp)
}
 82458c0:	e037883a 	mov	sp,fp
 82458c4:	dfc00117 	ldw	ra,4(sp)
 82458c8:	df000017 	ldw	fp,0(sp)
 82458cc:	dec00204 	addi	sp,sp,8
 82458d0:	f800283a 	ret

082458d4 <igmpv2_process_report>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_report (PACKET p)
{
 82458d4:	defff904 	addi	sp,sp,-28
 82458d8:	dfc00615 	stw	ra,24(sp)
 82458dc:	df000515 	stw	fp,20(sp)
 82458e0:	df000504 	addi	fp,sp,20
 82458e4:	e13fff15 	stw	r4,-4(fp)
   struct igmp * igmp;
   struct ip * pip;
   NET netp;
   struct in_multi * inm;

   netp = p->net;
 82458e8:	e0bfff17 	ldw	r2,-4(fp)
 82458ec:	10800617 	ldw	r2,24(r2)
 82458f0:	e0bffb15 	stw	r2,-20(fp)
   pip = ip_head (p);
 82458f4:	e0bfff17 	ldw	r2,-4(fp)
 82458f8:	10800317 	ldw	r2,12(r2)
 82458fc:	e0bffc15 	stw	r2,-16(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 8245900:	e0bffc17 	ldw	r2,-16(fp)
 8245904:	10800003 	ldbu	r2,0(r2)
 8245908:	10803fcc 	andi	r2,r2,255
 824590c:	108003cc 	andi	r2,r2,15
 8245910:	1085883a 	add	r2,r2,r2
 8245914:	1085883a 	add	r2,r2,r2
 8245918:	1007883a 	mov	r3,r2
 824591c:	e0bffc17 	ldw	r2,-16(fp)
 8245920:	10c5883a 	add	r2,r2,r3
 8245924:	e0bffd15 	stw	r2,-12(fp)
    * processing IGMPv2 packets (it has "downgraded" itself because
    * there are IGMPv1 routers on that network); however, we do not
    * know that, and hence we don't cancel our timer (for the 
    * subsequent transmission of a IGMPv1 report).
    */
   inm = lookup_mcast(igmp->igmp_group, netp);
 8245928:	e0bffd17 	ldw	r2,-12(fp)
 824592c:	10800117 	ldw	r2,4(r2)
 8245930:	e17ffb17 	ldw	r5,-20(fp)
 8245934:	1009883a 	mov	r4,r2
 8245938:	8243ba80 	call	8243ba8 <lookup_mcast>
 824593c:	e0bffe15 	stw	r2,-8(fp)
   if (inm != NULL) 
 8245940:	e0bffe17 	ldw	r2,-8(fp)
 8245944:	10002326 	beq	r2,zero,82459d4 <igmpv2_process_report+0x100>
   {
      if (inm->inm_timer != 0)
 8245948:	e0bffe17 	ldw	r2,-8(fp)
 824594c:	10800317 	ldw	r2,12(r2)
 8245950:	10001826 	beq	r2,zero,82459b4 <igmpv2_process_report+0xe0>
      {
         /* we have a timer running */
         if (!(netp->igmpv1_rtr_present && 
 8245954:	e0bffb17 	ldw	r2,-20(fp)
 8245958:	10802d03 	ldbu	r2,180(r2)
 824595c:	10803fcc 	andi	r2,r2,255
 8245960:	10000526 	beq	r2,zero,8245978 <igmpv2_process_report+0xa4>
             igmp->igmp_type == IGMPv2_MEMBERSHIP_REPORT))
 8245964:	e0bffd17 	ldw	r2,-12(fp)
 8245968:	10800003 	ldbu	r2,0(r2)
   if (inm != NULL) 
   {
      if (inm->inm_timer != 0)
      {
         /* we have a timer running */
         if (!(netp->igmpv1_rtr_present && 
 824596c:	10803fcc 	andi	r2,r2,255
 8245970:	108005a0 	cmpeqi	r2,r2,22
 8245974:	10001e1e 	bne	r2,zero,82459f0 <igmpv2_process_report+0x11c>
             igmp->igmp_type == IGMPv2_MEMBERSHIP_REPORT))
         {
            /* cancel timer */
            inm->inm_timer = 0;
 8245978:	e0bffe17 	ldw	r2,-8(fp)
 824597c:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 8245980:	d0a08617 	ldw	r2,-32232(gp)
 8245984:	10bfffc4 	addi	r2,r2,-1
 8245988:	d0a08615 	stw	r2,-32232(gp)
            /* indicate that we are not the last host to send a 
             * report for this group */
            inm->last2send_report = IGMP_FALSE;
 824598c:	e0bffe17 	ldw	r2,-8(fp)
 8245990:	10000405 	stb	zero,16(r2)
            ++igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer;
 8245994:	008209b4 	movhi	r2,2086
 8245998:	10b81f04 	addi	r2,r2,-8068
 824599c:	10800717 	ldw	r2,28(r2)
 82459a0:	10c00044 	addi	r3,r2,1
 82459a4:	008209b4 	movhi	r2,2086
 82459a8:	10b81f04 	addi	r2,r2,-8068
 82459ac:	10c00715 	stw	r3,28(r2)
 82459b0:	00000f06 	br	82459f0 <igmpv2_process_report+0x11c>
      else
      {
         /* we don't have a timer running; perhaps the source
          * host has just joined the group, and has sent an
          * unsolicited report */
         ++igmpstats.igmpv2mode_v12_reports_rcvd_no_timer;   
 82459b4:	008209b4 	movhi	r2,2086
 82459b8:	10b81f04 	addi	r2,r2,-8068
 82459bc:	10800817 	ldw	r2,32(r2)
 82459c0:	10c00044 	addi	r3,r2,1
 82459c4:	008209b4 	movhi	r2,2086
 82459c8:	10b81f04 	addi	r2,r2,-8068
 82459cc:	10c00815 	stw	r3,32(r2)
 82459d0:	00000706 	br	82459f0 <igmpv2_process_report+0x11c>
       * on that interface.  Even if imperfect filtering at the 
       * device level causes reports for unregistered groups to 
       * be passed up to the IP module, ip_rcv_phase2 () is 
       * responsible for dropping them, and so we should never
       * receive such packets. */
      ++igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd;
 82459d4:	008209b4 	movhi	r2,2086
 82459d8:	10b81f04 	addi	r2,r2,-8068
 82459dc:	10801317 	ldw	r2,76(r2)
 82459e0:	10c00044 	addi	r3,r2,1
 82459e4:	008209b4 	movhi	r2,2086
 82459e8:	10b81f04 	addi	r2,r2,-8068
 82459ec:	10c01315 	stw	r3,76(r2)
   }
   
   return IGMP_OK;   
 82459f0:	0005883a 	mov	r2,zero
}
 82459f4:	e037883a 	mov	sp,fp
 82459f8:	dfc00117 	ldw	ra,4(sp)
 82459fc:	df000017 	ldw	fp,0(sp)
 8245a00:	dec00204 	addi	sp,sp,8
 8245a04:	f800283a 	ret

08245a08 <igmpv2_process_query>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_query (PACKET p)
{
 8245a08:	defff804 	addi	sp,sp,-32
 8245a0c:	dfc00715 	stw	ra,28(sp)
 8245a10:	df000615 	stw	fp,24(sp)
 8245a14:	df000604 	addi	fp,sp,24
 8245a18:	e13fff15 	stw	r4,-4(fp)
   NET netp;
   u_short max_resp_time;
   u_char process_all;
   struct in_multi * inm;

   netp = p->net;
 8245a1c:	e0bfff17 	ldw	r2,-4(fp)
 8245a20:	10800617 	ldw	r2,24(r2)
 8245a24:	e0bffc15 	stw	r2,-16(fp)
   pip = ip_head (p);
 8245a28:	e0bfff17 	ldw	r2,-4(fp)
 8245a2c:	10800317 	ldw	r2,12(r2)
 8245a30:	e0bffd15 	stw	r2,-12(fp)
   igmp = (struct igmp *) (ip_data (pip));
 8245a34:	e0bffd17 	ldw	r2,-12(fp)
 8245a38:	10800003 	ldbu	r2,0(r2)
 8245a3c:	10803fcc 	andi	r2,r2,255
 8245a40:	108003cc 	andi	r2,r2,15
 8245a44:	1085883a 	add	r2,r2,r2
 8245a48:	1085883a 	add	r2,r2,r2
 8245a4c:	1007883a 	mov	r3,r2
 8245a50:	e0bffd17 	ldw	r2,-12(fp)
 8245a54:	10c5883a 	add	r2,r2,r3
 8245a58:	e0bffe15 	stw	r2,-8(fp)

   if (igmp->igmp_code == 0)
 8245a5c:	e0bffe17 	ldw	r2,-8(fp)
 8245a60:	10800043 	ldbu	r2,1(r2)
 8245a64:	10803fcc 	andi	r2,r2,255
 8245a68:	1000121e 	bne	r2,zero,8245ab4 <igmpv2_process_query+0xac>
   {
      /* this is a IGMPv1 Host Membership Query */
      netp->igmpv1_rtr_present = IGMP_TRUE;
 8245a6c:	e0bffc17 	ldw	r2,-16(fp)
 8245a70:	00c00044 	movi	r3,1
 8245a74:	10c02d05 	stb	r3,180(r2)
      netp->igmpv1_query_rcvd_time = cticks;      
 8245a78:	d0e0a817 	ldw	r3,-32096(gp)
 8245a7c:	e0bffc17 	ldw	r2,-16(fp)
 8245a80:	10c02e15 	stw	r3,184(r2)
      ++igmpstats.igmpv2mode_v1_queries_rcvd;
 8245a84:	008209b4 	movhi	r2,2086
 8245a88:	10b81f04 	addi	r2,r2,-8068
 8245a8c:	10800417 	ldw	r2,16(r2)
 8245a90:	10c00044 	addi	r3,r2,1
 8245a94:	008209b4 	movhi	r2,2086
 8245a98:	10b81f04 	addi	r2,r2,-8068
 8245a9c:	10c00415 	stw	r3,16(r2)
      /* set maximum time to respond to the equivalent of 10 
       * seconds worth of "ticks" (the timeout routine is
       * intended to be invoked PR_FASTHZ (5) times a second,
       * so each tick is equal to 200 ms) */
      max_resp_time = IGMP_MAX_HOST_REPORT_DELAY * PR_FASTHZ;
 8245aa0:	00800c84 	movi	r2,50
 8245aa4:	e0bffa0d 	sth	r2,-24(fp)
      process_all = IGMP_TRUE;
 8245aa8:	00800044 	movi	r2,1
 8245aac:	e0bffa85 	stb	r2,-22(fp)
 8245ab0:	00001d06 	br	8245b28 <igmpv2_process_query+0x120>
   }
   else
   {
      /* this is either a IGMPv2 General Query or 
       * a IGMPv2 Group-Specific Query */
      if (igmp->igmp_group == 0)
 8245ab4:	e0bffe17 	ldw	r2,-8(fp)
 8245ab8:	10800117 	ldw	r2,4(r2)
 8245abc:	10000a1e 	bne	r2,zero,8245ae8 <igmpv2_process_query+0xe0>
      {
         /* this is a IGMPv2 General Query */
         ++igmpstats.igmpv2mode_v2_general_queries_rcvd;
 8245ac0:	008209b4 	movhi	r2,2086
 8245ac4:	10b81f04 	addi	r2,r2,-8068
 8245ac8:	10800517 	ldw	r2,20(r2)
 8245acc:	10c00044 	addi	r3,r2,1
 8245ad0:	008209b4 	movhi	r2,2086
 8245ad4:	10b81f04 	addi	r2,r2,-8068
 8245ad8:	10c00515 	stw	r3,20(r2)
         process_all = IGMP_TRUE;
 8245adc:	00800044 	movi	r2,1
 8245ae0:	e0bffa85 	stb	r2,-22(fp)
 8245ae4:	00000806 	br	8245b08 <igmpv2_process_query+0x100>
      }
      else
      {
         /* this is a IGMPv2 Group-Specific Query */       
         ++igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd;
 8245ae8:	008209b4 	movhi	r2,2086
 8245aec:	10b81f04 	addi	r2,r2,-8068
 8245af0:	10800617 	ldw	r2,24(r2)
 8245af4:	10c00044 	addi	r3,r2,1
 8245af8:	008209b4 	movhi	r2,2086
 8245afc:	10b81f04 	addi	r2,r2,-8068
 8245b00:	10c00615 	stw	r3,24(r2)
         process_all = IGMP_FALSE;
 8245b04:	e03ffa85 	stb	zero,-22(fp)
       * IGMPv2 General Query or a IGMPv2 Group-Specific Query,
       * set maximum time to respond to value extracted 
       * from received message. The value in the message
       * is in tenths of a second.  max_resp_time is in
       * units of ticks (where one tick is 200 ms) */
      max_resp_time = (igmp->igmp_code * PR_FASTHZ) / 10;
 8245b08:	e0bffe17 	ldw	r2,-8(fp)
 8245b0c:	10800043 	ldbu	r2,1(r2)
 8245b10:	10803fcc 	andi	r2,r2,255
 8245b14:	10800164 	muli	r2,r2,5
 8245b18:	01400284 	movi	r5,10
 8245b1c:	1009883a 	mov	r4,r2
 8245b20:	8202b180 	call	8202b18 <__divsi3>
 8245b24:	e0bffa0d 	sth	r2,-24(fp)
   
   /* process all entries in a link's multicast address linked
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
 8245b28:	e0bffa83 	ldbu	r2,-22(fp)
 8245b2c:	10001726 	beq	r2,zero,8245b8c <igmpv2_process_query+0x184>
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 8245b30:	e0bffc17 	ldw	r2,-16(fp)
 8245b34:	10802c17 	ldw	r2,176(r2)
 8245b38:	e0bffb15 	stw	r2,-20(fp)
 8245b3c:	00001006 	br	8245b80 <igmpv2_process_query+0x178>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (!(inm->inm_addr)) continue;
 8245b40:	e0bffb17 	ldw	r2,-20(fp)
 8245b44:	10800017 	ldw	r2,0(r2)
 8245b48:	10000926 	beq	r2,zero,8245b70 <igmpv2_process_query+0x168>
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 8245b4c:	e0bffb17 	ldw	r2,-20(fp)
 8245b50:	10c00017 	ldw	r3,0(r2)
 8245b54:	d0a08817 	ldw	r2,-32224(gp)
 8245b58:	18800626 	beq	r3,r2,8245b74 <igmpv2_process_query+0x16c>
            igmpv2_chk_set_timer (inm, max_resp_time);
 8245b5c:	e0bffa0b 	ldhu	r2,-24(fp)
 8245b60:	100b883a 	mov	r5,r2
 8245b64:	e13ffb17 	ldw	r4,-20(fp)
 8245b68:	8245bf40 	call	8245bf4 <igmpv2_chk_set_timer>
 8245b6c:	00000106 	br	8245b74 <igmpv2_process_query+0x16c>
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (!(inm->inm_addr)) continue;
 8245b70:	0001883a 	nop
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 8245b74:	e0bffb17 	ldw	r2,-20(fp)
 8245b78:	10800517 	ldw	r2,20(r2)
 8245b7c:	e0bffb15 	stw	r2,-20(fp)
 8245b80:	e0bffb17 	ldw	r2,-20(fp)
 8245b84:	103fee1e 	bne	r2,zero,8245b40 <igmpv2_process_query+0x138>
 8245b88:	00001406 	br	8245bdc <igmpv2_process_query+0x1d4>
   {
      /* process one (for IGMPv2 Group-Specific Query) entry (the 
       * one that corresponds to the address listed in the received 
       * query) - it should be present in the link's multicast
       * address list */
      inm = lookup_mcast(igmp->igmp_group, netp);
 8245b8c:	e0bffe17 	ldw	r2,-8(fp)
 8245b90:	10800117 	ldw	r2,4(r2)
 8245b94:	e17ffc17 	ldw	r5,-16(fp)
 8245b98:	1009883a 	mov	r4,r2
 8245b9c:	8243ba80 	call	8243ba8 <lookup_mcast>
 8245ba0:	e0bffb15 	stw	r2,-20(fp)
      if (inm != NULL)
 8245ba4:	e0bffb17 	ldw	r2,-20(fp)
 8245ba8:	10000526 	beq	r2,zero,8245bc0 <igmpv2_process_query+0x1b8>
         igmpv2_chk_set_timer (inm, max_resp_time);
 8245bac:	e0bffa0b 	ldhu	r2,-24(fp)
 8245bb0:	100b883a 	mov	r5,r2
 8245bb4:	e13ffb17 	ldw	r4,-20(fp)
 8245bb8:	8245bf40 	call	8245bf4 <igmpv2_chk_set_timer>
 8245bbc:	00000706 	br	8245bdc <igmpv2_process_query+0x1d4>
      else ++igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd;
 8245bc0:	008209b4 	movhi	r2,2086
 8245bc4:	10b81f04 	addi	r2,r2,-8068
 8245bc8:	10801217 	ldw	r2,72(r2)
 8245bcc:	10c00044 	addi	r3,r2,1
 8245bd0:	008209b4 	movhi	r2,2086
 8245bd4:	10b81f04 	addi	r2,r2,-8068
 8245bd8:	10c01215 	stw	r3,72(r2)
   } /* end ELSE (process ALL) */
   
   /* return success; caller will the received packet back to the 
    * free pool */
   return IGMP_OK;
 8245bdc:	0005883a 	mov	r2,zero
}
 8245be0:	e037883a 	mov	sp,fp
 8245be4:	dfc00117 	ldw	ra,4(sp)
 8245be8:	df000017 	ldw	fp,0(sp)
 8245bec:	dec00204 	addi	sp,sp,8
 8245bf0:	f800283a 	ret

08245bf4 <igmpv2_chk_set_timer>:
 *
 * OUTPUT: None.
 */

void igmpv2_chk_set_timer (struct in_multi * inm, u_short max_resp_time)
{  
 8245bf4:	defffc04 	addi	sp,sp,-16
 8245bf8:	dfc00315 	stw	ra,12(sp)
 8245bfc:	df000215 	stw	fp,8(sp)
 8245c00:	df000204 	addi	fp,sp,8
 8245c04:	e13ffe15 	stw	r4,-8(fp)
 8245c08:	2805883a 	mov	r2,r5
 8245c0c:	e0bfff0d 	sth	r2,-4(fp)

    * Otherwise, the current timer for this group is scheduled 
    * to expire within the duration indicated in the Query 
    * message, so we let it continue. 
    */
   if ((inm->inm_timer > max_resp_time) ||
 8245c10:	e0bffe17 	ldw	r2,-8(fp)
 8245c14:	10800317 	ldw	r2,12(r2)
 8245c18:	e0ffff0b 	ldhu	r3,-4(fp)
 8245c1c:	18800336 	bltu	r3,r2,8245c2c <igmpv2_chk_set_timer+0x38>
       (inm->inm_timer == 0))
 8245c20:	e0bffe17 	ldw	r2,-8(fp)
 8245c24:	10800317 	ldw	r2,12(r2)

    * Otherwise, the current timer for this group is scheduled 
    * to expire within the duration indicated in the Query 
    * message, so we let it continue. 
    */
   if ((inm->inm_timer > max_resp_time) ||
 8245c28:	10003d1e 	bne	r2,zero,8245d20 <igmpv2_chk_set_timer+0x12c>
       (inm->inm_timer == 0))
   {
      if (inm->inm_timer == 0) ++igmp_timers_are_running;
 8245c2c:	e0bffe17 	ldw	r2,-8(fp)
 8245c30:	10800317 	ldw	r2,12(r2)
 8245c34:	1000031e 	bne	r2,zero,8245c44 <igmpv2_chk_set_timer+0x50>
 8245c38:	d0a08617 	ldw	r2,-32232(gp)
 8245c3c:	10800044 	addi	r2,r2,1
 8245c40:	d0a08615 	stw	r2,-32232(gp)
      inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY (max_resp_time, inm->inm_addr);                     
 8245c44:	008209b4 	movhi	r2,2086
 8245c48:	10ba6104 	addi	r2,r2,-5756
 8245c4c:	10c00217 	ldw	r3,8(r2)
 8245c50:	008209b4 	movhi	r2,2086
 8245c54:	10b81b04 	addi	r2,r2,-8084
 8245c58:	10800017 	ldw	r2,0(r2)
 8245c5c:	10800a17 	ldw	r2,40(r2)
 8245c60:	1008d63a 	srli	r4,r2,24
 8245c64:	008209b4 	movhi	r2,2086
 8245c68:	10b81b04 	addi	r2,r2,-8084
 8245c6c:	10800017 	ldw	r2,0(r2)
 8245c70:	10800a17 	ldw	r2,40(r2)
 8245c74:	1004d23a 	srli	r2,r2,8
 8245c78:	10bfc00c 	andi	r2,r2,65280
 8245c7c:	2088b03a 	or	r4,r4,r2
 8245c80:	008209b4 	movhi	r2,2086
 8245c84:	10b81b04 	addi	r2,r2,-8084
 8245c88:	10800017 	ldw	r2,0(r2)
 8245c8c:	10800a17 	ldw	r2,40(r2)
 8245c90:	10bfc00c 	andi	r2,r2,65280
 8245c94:	1004923a 	slli	r2,r2,8
 8245c98:	2088b03a 	or	r4,r4,r2
 8245c9c:	008209b4 	movhi	r2,2086
 8245ca0:	10b81b04 	addi	r2,r2,-8084
 8245ca4:	10800017 	ldw	r2,0(r2)
 8245ca8:	10800a17 	ldw	r2,40(r2)
 8245cac:	1004963a 	slli	r2,r2,24
 8245cb0:	2084b03a 	or	r2,r4,r2
 8245cb4:	1887883a 	add	r3,r3,r2
 8245cb8:	e0bffe17 	ldw	r2,-8(fp)
 8245cbc:	10800017 	ldw	r2,0(r2)
 8245cc0:	1008d63a 	srli	r4,r2,24
 8245cc4:	e0bffe17 	ldw	r2,-8(fp)
 8245cc8:	10800017 	ldw	r2,0(r2)
 8245ccc:	1004d23a 	srli	r2,r2,8
 8245cd0:	10bfc00c 	andi	r2,r2,65280
 8245cd4:	2088b03a 	or	r4,r4,r2
 8245cd8:	e0bffe17 	ldw	r2,-8(fp)
 8245cdc:	10800017 	ldw	r2,0(r2)
 8245ce0:	10bfc00c 	andi	r2,r2,65280
 8245ce4:	1004923a 	slli	r2,r2,8
 8245ce8:	2088b03a 	or	r4,r4,r2
 8245cec:	e0bffe17 	ldw	r2,-8(fp)
 8245cf0:	10800017 	ldw	r2,0(r2)
 8245cf4:	1004963a 	slli	r2,r2,24
 8245cf8:	2084b03a 	or	r2,r4,r2
 8245cfc:	1885883a 	add	r2,r3,r2
 8245d00:	e0ffff0b 	ldhu	r3,-4(fp)
 8245d04:	180b883a 	mov	r5,r3
 8245d08:	1009883a 	mov	r4,r2
 8245d0c:	8202c740 	call	8202c74 <__umodsi3>
 8245d10:	10c00044 	addi	r3,r2,1
 8245d14:	e0bffe17 	ldw	r2,-8(fp)
 8245d18:	10c00315 	stw	r3,12(r2)
   }

   return;
 8245d1c:	0001883a 	nop
 8245d20:	0001883a 	nop
}
 8245d24:	e037883a 	mov	sp,fp
 8245d28:	dfc00117 	ldw	ra,4(sp)
 8245d2c:	df000017 	ldw	fp,0(sp)
 8245d30:	dec00204 	addi	sp,sp,8
 8245d34:	f800283a 	ret

08245d38 <igmpv2_chk4_rtr_alert_opt>:
 *         the IP Router Alert option in the received
 *         packet, and IGMP_FALSE otherwise.
 */

u_char igmpv2_chk4_rtr_alert_opt (struct ip * pip)
{
 8245d38:	defffb04 	addi	sp,sp,-20
 8245d3c:	df000415 	stw	fp,16(sp)
 8245d40:	df000404 	addi	fp,sp,16
 8245d44:	e13fff15 	stw	r4,-4(fp)
   u_long * rtr_alert_optp;
   u_char total_optlen;
   u_char optlen;
   u_char optval;

   total_optlen = ip_hlen (pip) - sizeof (struct ip);
 8245d48:	e0bfff17 	ldw	r2,-4(fp)
 8245d4c:	10800003 	ldbu	r2,0(r2)
 8245d50:	108003cc 	andi	r2,r2,15
 8245d54:	1085883a 	add	r2,r2,r2
 8245d58:	1085883a 	add	r2,r2,r2
 8245d5c:	10bffb04 	addi	r2,r2,-20
 8245d60:	e0bffd05 	stb	r2,-12(fp)

   if (total_optlen > 0)
 8245d64:	e0bffd03 	ldbu	r2,-12(fp)
 8245d68:	10003e26 	beq	r2,zero,8245e64 <igmpv2_chk4_rtr_alert_opt+0x12c>
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
 8245d6c:	e0bfff17 	ldw	r2,-4(fp)
 8245d70:	10800504 	addi	r2,r2,20
 8245d74:	e0bffc15 	stw	r2,-16(fp)
  
      while (total_optlen > 0)
 8245d78:	00003806 	br	8245e5c <igmpv2_chk4_rtr_alert_opt+0x124>
      {
         /* only the lowermost 5 bits are significant */    
         optval = (*optp) & IPOPT_TYPE_MASK;
 8245d7c:	e0bffc17 	ldw	r2,-16(fp)
 8245d80:	10800003 	ldbu	r2,0(r2)
 8245d84:	108007cc 	andi	r2,r2,31
 8245d88:	e0bffd85 	stb	r2,-10(fp)
         switch (optval)
 8245d8c:	e0bffd83 	ldbu	r2,-10(fp)
 8245d90:	10c00060 	cmpeqi	r3,r2,1
 8245d94:	1800071e 	bne	r3,zero,8245db4 <igmpv2_chk4_rtr_alert_opt+0x7c>
 8245d98:	10c00520 	cmpeqi	r3,r2,20
 8245d9c:	1800081e 	bne	r3,zero,8245dc0 <igmpv2_chk4_rtr_alert_opt+0x88>
 8245da0:	1000201e 	bne	r2,zero,8245e24 <igmpv2_chk4_rtr_alert_opt+0xec>
         {
            case EOL_OPT:
               /* we've encountered the End of Option List option, 
                * and so setting optlen isn't necessary */
               optlen = 1;
 8245da4:	00800044 	movi	r2,1
 8245da8:	e0bffd45 	stb	r2,-11(fp)
               /* we're done - we couldn't locate the IP Router Alert 
                * option in this IP header */
               return IGMP_FALSE;
 8245dac:	0005883a 	mov	r2,zero
 8245db0:	00002d06 	br	8245e68 <igmpv2_chk4_rtr_alert_opt+0x130>
         
            case NOOP_OPT:
               /* skip past the one byte of the No Operation option */
               optlen = 1;
 8245db4:	00800044 	movi	r2,1
 8245db8:	e0bffd45 	stb	r2,-11(fp)
               break;
 8245dbc:	00001f06 	br	8245e3c <igmpv2_chk4_rtr_alert_opt+0x104>
         
            case IP_RTR_ALERT_OPT:
               rtr_alert_optp = (u_long *) optp; 
 8245dc0:	e0bffc17 	ldw	r2,-16(fp)
 8245dc4:	e0bffe15 	stw	r2,-8(fp)
               if ((ntohl (*rtr_alert_optp)) == IP_RTR_ALERT_OPT_DATA)
 8245dc8:	e0bffe17 	ldw	r2,-8(fp)
 8245dcc:	10800017 	ldw	r2,0(r2)
 8245dd0:	1006d63a 	srli	r3,r2,24
 8245dd4:	e0bffe17 	ldw	r2,-8(fp)
 8245dd8:	10800017 	ldw	r2,0(r2)
 8245ddc:	1004d23a 	srli	r2,r2,8
 8245de0:	10bfc00c 	andi	r2,r2,65280
 8245de4:	1886b03a 	or	r3,r3,r2
 8245de8:	e0bffe17 	ldw	r2,-8(fp)
 8245dec:	10800017 	ldw	r2,0(r2)
 8245df0:	10bfc00c 	andi	r2,r2,65280
 8245df4:	1004923a 	slli	r2,r2,8
 8245df8:	1886b03a 	or	r3,r3,r2
 8245dfc:	e0bffe17 	ldw	r2,-8(fp)
 8245e00:	10800017 	ldw	r2,0(r2)
 8245e04:	1004963a 	slli	r2,r2,24
 8245e08:	1886b03a 	or	r3,r3,r2
 8245e0c:	00a50134 	movhi	r2,37892
 8245e10:	1880021e 	bne	r3,r2,8245e1c <igmpv2_chk4_rtr_alert_opt+0xe4>
                  /* found the option, return success */
                  return IGMP_TRUE;
 8245e14:	00800044 	movi	r2,1
 8245e18:	00001306 	br	8245e68 <igmpv2_chk4_rtr_alert_opt+0x130>
               else return IGMP_FALSE;
 8245e1c:	0005883a 	mov	r2,zero
 8245e20:	00001106 	br	8245e68 <igmpv2_chk4_rtr_alert_opt+0x130>
          
            default:
               /* extract the length of the current option, and compute
                * the total length of this option */
               optlen = (*(optp + 1)) + 2;
 8245e24:	e0bffc17 	ldw	r2,-16(fp)
 8245e28:	10800044 	addi	r2,r2,1
 8245e2c:	10800003 	ldbu	r2,0(r2)
 8245e30:	10800084 	addi	r2,r2,2
 8245e34:	e0bffd45 	stb	r2,-11(fp)
               break;
 8245e38:	0001883a 	nop
         }
         
         /* skip past the bytes associated with the current option to 
          * point to the next option. */
         optp += optlen;
 8245e3c:	e0bffd43 	ldbu	r2,-11(fp)
 8245e40:	e0fffc17 	ldw	r3,-16(fp)
 8245e44:	1885883a 	add	r2,r3,r2
 8245e48:	e0bffc15 	stw	r2,-16(fp)
         total_optlen -= optlen;
 8245e4c:	e0fffd03 	ldbu	r3,-12(fp)
 8245e50:	e0bffd43 	ldbu	r2,-11(fp)
 8245e54:	1885c83a 	sub	r2,r3,r2
 8245e58:	e0bffd05 	stb	r2,-12(fp)
   if (total_optlen > 0)
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
  
      while (total_optlen > 0)
 8245e5c:	e0bffd03 	ldbu	r2,-12(fp)
 8245e60:	103fc61e 	bne	r2,zero,8245d7c <igmpv2_chk4_rtr_alert_opt+0x44>
         total_optlen -= optlen;
      } /* end WHILE */
   }

   /* didn't find IP Alert option in IP header of rcvd packet */
   return IGMP_FALSE;
 8245e64:	0005883a 	mov	r2,zero
}
 8245e68:	e037883a 	mov	sp,fp
 8245e6c:	df000017 	ldw	fp,0(sp)
 8245e70:	dec00104 	addi	sp,sp,4
 8245e74:	f800283a 	ret

08245e78 <IPADDR_TO_NETP>:
 * RETURNS: 
 */

void
IPADDR_TO_NETP(ip_addr addr, NET* netp)
{
 8245e78:	defffc04 	addi	sp,sp,-16
 8245e7c:	df000315 	stw	fp,12(sp)
 8245e80:	df000304 	addi	fp,sp,12
 8245e84:	e13ffe15 	stw	r4,-8(fp)
 8245e88:	e17fff15 	stw	r5,-4(fp)
   u_short  idx   =  0;
 8245e8c:	e03ffd0d 	sth	zero,-12(fp)
   *netp = nets[idx];
 8245e90:	e0fffd0b 	ldhu	r3,-12(fp)
 8245e94:	008209b4 	movhi	r2,2086
 8245e98:	10b81b04 	addi	r2,r2,-8084
 8245e9c:	18c7883a 	add	r3,r3,r3
 8245ea0:	18c7883a 	add	r3,r3,r3
 8245ea4:	10c5883a 	add	r2,r2,r3
 8245ea8:	10c00017 	ldw	r3,0(r2)
 8245eac:	e0bfff17 	ldw	r2,-4(fp)
 8245eb0:	10c00015 	stw	r3,0(r2)
/*
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
 8245eb4:	e0bffe17 	ldw	r2,-8(fp)
 8245eb8:	10002e1e 	bne	r2,zero,8245f74 <IPADDR_TO_NETP+0xfc>
   {
      for (idx = 0; idx < ifNumber; idx++)
 8245ebc:	e03ffd0d 	sth	zero,-12(fp)
 8245ec0:	00001606 	br	8245f1c <IPADDR_TO_NETP+0xa4>
      {
         if (nets[idx]->n_mcastlist)
 8245ec4:	e0fffd0b 	ldhu	r3,-12(fp)
 8245ec8:	008209b4 	movhi	r2,2086
 8245ecc:	10b81b04 	addi	r2,r2,-8084
 8245ed0:	18c7883a 	add	r3,r3,r3
 8245ed4:	18c7883a 	add	r3,r3,r3
 8245ed8:	10c5883a 	add	r2,r2,r3
 8245edc:	10800017 	ldw	r2,0(r2)
 8245ee0:	10802b17 	ldw	r2,172(r2)
 8245ee4:	10000a26 	beq	r2,zero,8245f10 <IPADDR_TO_NETP+0x98>
         {
            *netp = nets[idx];
 8245ee8:	e0fffd0b 	ldhu	r3,-12(fp)
 8245eec:	008209b4 	movhi	r2,2086
 8245ef0:	10b81b04 	addi	r2,r2,-8084
 8245ef4:	18c7883a 	add	r3,r3,r3
 8245ef8:	18c7883a 	add	r3,r3,r3
 8245efc:	10c5883a 	add	r2,r2,r3
 8245f00:	10c00017 	ldw	r3,0(r2)
 8245f04:	e0bfff17 	ldw	r2,-4(fp)
 8245f08:	10c00015 	stw	r3,0(r2)
            break;
 8245f0c:	00002206 	br	8245f98 <IPADDR_TO_NETP+0x120>
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
   {
      for (idx = 0; idx < ifNumber; idx++)
 8245f10:	e0bffd0b 	ldhu	r2,-12(fp)
 8245f14:	10800044 	addi	r2,r2,1
 8245f18:	e0bffd0d 	sth	r2,-12(fp)
 8245f1c:	e0fffd0b 	ldhu	r3,-12(fp)
 8245f20:	d0a08417 	ldw	r2,-32240(gp)
 8245f24:	18bfe736 	bltu	r3,r2,8245ec4 <IPADDR_TO_NETP+0x4c>
         }
         else
            *netp = nets[idx];
      }
   }
}
 8245f28:	00001b06 	br	8245f98 <IPADDR_TO_NETP+0x120>
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
      {
         idx++;
 8245f2c:	e0bffd0b 	ldhu	r2,-12(fp)
 8245f30:	10800044 	addi	r2,r2,1
 8245f34:	e0bffd0d 	sth	r2,-12(fp)
         if (idx >= ifNumber)
 8245f38:	e0fffd0b 	ldhu	r3,-12(fp)
 8245f3c:	d0a08417 	ldw	r2,-32240(gp)
 8245f40:	18800336 	bltu	r3,r2,8245f50 <IPADDR_TO_NETP+0xd8>
         {
            *netp = NULL;
 8245f44:	e0bfff17 	ldw	r2,-4(fp)
 8245f48:	10000015 	stw	zero,0(r2)
            break;
 8245f4c:	00001206 	br	8245f98 <IPADDR_TO_NETP+0x120>
         }
         else
            *netp = nets[idx];
 8245f50:	e0fffd0b 	ldhu	r3,-12(fp)
 8245f54:	008209b4 	movhi	r2,2086
 8245f58:	10b81b04 	addi	r2,r2,-8084
 8245f5c:	18c7883a 	add	r3,r3,r3
 8245f60:	18c7883a 	add	r3,r3,r3
 8245f64:	10c5883a 	add	r2,r2,r3
 8245f68:	10c00017 	ldw	r3,0(r2)
 8245f6c:	e0bfff17 	ldw	r2,-4(fp)
 8245f70:	10c00015 	stw	r3,0(r2)
         }
      }
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
 8245f74:	e0bfff17 	ldw	r2,-4(fp)
 8245f78:	10800017 	ldw	r2,0(r2)
 8245f7c:	10000626 	beq	r2,zero,8245f98 <IPADDR_TO_NETP+0x120>
 8245f80:	e0bfff17 	ldw	r2,-4(fp)
 8245f84:	10800017 	ldw	r2,0(r2)
 8245f88:	10c00a17 	ldw	r3,40(r2)
 8245f8c:	e0bffe17 	ldw	r2,-8(fp)
 8245f90:	18bfe61e 	bne	r3,r2,8245f2c <IPADDR_TO_NETP+0xb4>
         }
         else
            *netp = nets[idx];
      }
   }
}
 8245f94:	00000006 	br	8245f98 <IPADDR_TO_NETP+0x120>
 8245f98:	0001883a 	nop
 8245f9c:	e037883a 	mov	sp,fp
 8245fa0:	df000017 	ldw	fp,0(sp)
 8245fa4:	dec00104 	addi	sp,sp,4
 8245fa8:	f800283a 	ret

08245fac <ip_setmoptions>:
 * RETURNS: 
 */

int
ip_setmoptions(int optname, struct socket * so, void * val)
{
 8245fac:	defff304 	addi	sp,sp,-52
 8245fb0:	dfc00c15 	stw	ra,48(sp)
 8245fb4:	df000b15 	stw	fp,44(sp)
 8245fb8:	dc000a15 	stw	r16,40(sp)
 8245fbc:	df000b04 	addi	fp,sp,44
 8245fc0:	e13ffc15 	stw	r4,-16(fp)
 8245fc4:	e17ffd15 	stw	r5,-12(fp)
 8245fc8:	e1bffe15 	stw	r6,-8(fp)
   int   error =  0;
 8245fcc:	e03ff515 	stw	zero,-44(fp)
   u_short  i;
   struct ip_mreq *  mreq;
   struct net *   netp  =  NULL;
 8245fd0:	e03ffb15 	stw	zero,-20(fp)
   struct ip_moptions * imo   =  so->inp_moptions;
 8245fd4:	e0bffd17 	ldw	r2,-12(fp)
 8245fd8:	10800317 	ldw	r2,12(r2)
 8245fdc:	e0bff715 	stw	r2,-36(fp)
   struct ip_moptions **imop  =  &so->inp_moptions;
 8245fe0:	e0bffd17 	ldw	r2,-12(fp)
 8245fe4:	10800304 	addi	r2,r2,12
 8245fe8:	e0bff815 	stw	r2,-32(fp)
   ip_addr addr;


   if (imo == NULL) 
 8245fec:	e0bff717 	ldw	r2,-36(fp)
 8245ff0:	1000141e 	bne	r2,zero,8246044 <ip_setmoptions+0x98>
   {
   /*
    * No multicast option buffer attached to the pcb;
    * allocate one and initialize to default values.
    */
      imo = (struct ip_moptions*)IM_ALLOC(sizeof(*imo));
 8245ff4:	01001604 	movi	r4,88
 8245ff8:	822e16c0 	call	822e16c <npalloc>
 8245ffc:	e0bff715 	stw	r2,-36(fp)

      if (imo == NULL)
 8246000:	e0bff717 	ldw	r2,-36(fp)
 8246004:	1000021e 	bne	r2,zero,8246010 <ip_setmoptions+0x64>
         return (ENOBUFS);
 8246008:	00801a44 	movi	r2,105
 824600c:	00015306 	br	824655c <ip_setmoptions+0x5b0>
      *imop = imo;
 8246010:	e0bff817 	ldw	r2,-32(fp)
 8246014:	e0fff717 	ldw	r3,-36(fp)
 8246018:	10c00015 	stw	r3,0(r2)
      imo->imo_multicast_netp = NULL;
 824601c:	e0bff717 	ldw	r2,-36(fp)
 8246020:	10000015 	stw	zero,0(r2)
      imo->imo_multicast_ttl = IP_DEFAULT_MULTICAST_TTL;
 8246024:	e0bff717 	ldw	r2,-36(fp)
 8246028:	00c00044 	movi	r3,1
 824602c:	10c00105 	stb	r3,4(r2)
      imo->imo_multicast_loop = IP_DEFAULT_MULTICAST_LOOP;
 8246030:	e0bff717 	ldw	r2,-36(fp)
 8246034:	00c00044 	movi	r3,1
 8246038:	10c00145 	stb	r3,5(r2)
      imo->imo_num_memberships = 0;
 824603c:	e0bff717 	ldw	r2,-36(fp)
 8246040:	1000018d 	sth	zero,6(r2)
   }

   switch (optname) 
 8246044:	e0bffc17 	ldw	r2,-16(fp)
 8246048:	10bffdc4 	addi	r2,r2,-9
 824604c:	10c00168 	cmpgeui	r3,r2,5
 8246050:	1801261e 	bne	r3,zero,82464ec <ip_setmoptions+0x540>
 8246054:	100690ba 	slli	r3,r2,2
 8246058:	00820934 	movhi	r2,2084
 824605c:	10981b04 	addi	r2,r2,24684
 8246060:	1885883a 	add	r2,r3,r2
 8246064:	10800017 	ldw	r2,0(r2)
 8246068:	1000683a 	jmp	r2
 824606c:	08246080 	call	824608 <OSCtxSw_SWITCH_PC+0x8245c8>
 8246070:	082460e8 	cmpgeui	zero,at,37251
 8246074:	082460fc 	xorhi	zero,at,37251
 8246078:	08246130 	cmpltui	zero,at,37252
 824607c:	08246304 	addi	zero,at,-28276

   case IP_MULTICAST_IF:
      /*
       * Select the interface for outgoing multicast packets.
       */
      addr = *(ip_addr *)val;
 8246080:	e0bffe17 	ldw	r2,-8(fp)
 8246084:	10800017 	ldw	r2,0(r2)
 8246088:	e0bff915 	stw	r2,-28(fp)
         /*
          * AADDR is used to remove a previous selection.
          * When no interface is selected, a default one is
          * chosen every time a multicast packet is sent.
          */
      if (addr == AADDR) 
 824608c:	e0bff917 	ldw	r2,-28(fp)
 8246090:	1000031e 	bne	r2,zero,82460a0 <ip_setmoptions+0xf4>
      {
         imo->imo_multicast_netp = NULL;
 8246094:	e0bff717 	ldw	r2,-36(fp)
 8246098:	10000015 	stw	zero,0(r2)
         break;
 824609c:	00011706 	br	82464fc <ip_setmoptions+0x550>
         /*
          * The selected interface is identified by its local
          * IP address.  Find the interface and confirm that
          * it supports multicasting.
          */
      IPADDR_TO_NETP(addr, &netp);
 82460a0:	e0bffb04 	addi	r2,fp,-20
 82460a4:	100b883a 	mov	r5,r2
 82460a8:	e13ff917 	ldw	r4,-28(fp)
 82460ac:	8245e780 	call	8245e78 <IPADDR_TO_NETP>
      if ((netp == NULL) || (netp->n_mcastlist) == NULL) 
 82460b0:	e0bffb17 	ldw	r2,-20(fp)
 82460b4:	10000326 	beq	r2,zero,82460c4 <ip_setmoptions+0x118>
 82460b8:	e0bffb17 	ldw	r2,-20(fp)
 82460bc:	10802b17 	ldw	r2,172(r2)
 82460c0:	1000031e 	bne	r2,zero,82460d0 <ip_setmoptions+0x124>
      {
         error = EADDRNOTAVAIL;
 82460c4:	00801f44 	movi	r2,125
 82460c8:	e0bff515 	stw	r2,-44(fp)
         break;
 82460cc:	00010b06 	br	82464fc <ip_setmoptions+0x550>
      }
      if (addr != AADDR) 
 82460d0:	e0bff917 	ldw	r2,-28(fp)
 82460d4:	10010826 	beq	r2,zero,82464f8 <ip_setmoptions+0x54c>
         imo->imo_multicast_netp = netp;
 82460d8:	e0fffb17 	ldw	r3,-20(fp)
 82460dc:	e0bff717 	ldw	r2,-36(fp)
 82460e0:	10c00015 	stw	r3,0(r2)
      break;
 82460e4:	00010406 	br	82464f8 <ip_setmoptions+0x54c>

   case IP_MULTICAST_TTL:
      /*
       * Set the IP time-to-live for outgoing multicast packets.
       */
      imo->imo_multicast_ttl = *(u_char *)val;
 82460e8:	e0bffe17 	ldw	r2,-8(fp)
 82460ec:	10c00003 	ldbu	r3,0(r2)
 82460f0:	e0bff717 	ldw	r2,-36(fp)
 82460f4:	10c00105 	stb	r3,4(r2)
      break;
 82460f8:	00010006 	br	82464fc <ip_setmoptions+0x550>
   case IP_MULTICAST_LOOP:
      /*
       * Set the loopback flag for outgoing multicast packets.
       * Must be zero or one.
       */
      if (*(u_char *)val > 1) 
 82460fc:	e0bffe17 	ldw	r2,-8(fp)
 8246100:	10800003 	ldbu	r2,0(r2)
 8246104:	10803fcc 	andi	r2,r2,255
 8246108:	108000b0 	cmpltui	r2,r2,2
 824610c:	1000031e 	bne	r2,zero,824611c <ip_setmoptions+0x170>
      {
         error = EINVAL;
 8246110:	00800584 	movi	r2,22
 8246114:	e0bff515 	stw	r2,-44(fp)
         break;
 8246118:	0000f806 	br	82464fc <ip_setmoptions+0x550>
      }
      imo->imo_multicast_loop = *(u_char *)(val);
 824611c:	e0bffe17 	ldw	r2,-8(fp)
 8246120:	10c00003 	ldbu	r3,0(r2)
 8246124:	e0bff717 	ldw	r2,-36(fp)
 8246128:	10c00145 	stb	r3,5(r2)
      break;
 824612c:	0000f306 	br	82464fc <ip_setmoptions+0x550>
   case IP_ADD_MEMBERSHIP:
      /*
       * Add a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 8246130:	e0bffe17 	ldw	r2,-8(fp)
 8246134:	e0bffa15 	stw	r2,-24(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 8246138:	e0bffa17 	ldw	r2,-24(fp)
 824613c:	10800017 	ldw	r2,0(r2)
 8246140:	1006d63a 	srli	r3,r2,24
 8246144:	e0bffa17 	ldw	r2,-24(fp)
 8246148:	10800017 	ldw	r2,0(r2)
 824614c:	1004d23a 	srli	r2,r2,8
 8246150:	10bfc00c 	andi	r2,r2,65280
 8246154:	1886b03a 	or	r3,r3,r2
 8246158:	e0bffa17 	ldw	r2,-24(fp)
 824615c:	10800017 	ldw	r2,0(r2)
 8246160:	10bfc00c 	andi	r2,r2,65280
 8246164:	1004923a 	slli	r2,r2,8
 8246168:	1886b03a 	or	r3,r3,r2
 824616c:	e0bffa17 	ldw	r2,-24(fp)
 8246170:	10800017 	ldw	r2,0(r2)
 8246174:	1004963a 	slli	r2,r2,24
 8246178:	1884b03a 	or	r2,r3,r2
 824617c:	10fc002c 	andhi	r3,r2,61440
 8246180:	00b80034 	movhi	r2,57344
 8246184:	18800326 	beq	r3,r2,8246194 <ip_setmoptions+0x1e8>
      {
         error = EINVAL;
 8246188:	00800584 	movi	r2,22
 824618c:	e0bff515 	stw	r2,-44(fp)
         break;
 8246190:	0000da06 	br	82464fc <ip_setmoptions+0x550>
       * If no interface address was provided, use the interface of
       * the route to the given multicast address.
       * For the Iniche stack implementation, look for a default
       * interface that supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 8246194:	e0bffa17 	ldw	r2,-24(fp)
 8246198:	10800117 	ldw	r2,4(r2)
 824619c:	e0fffb04 	addi	r3,fp,-20
 82461a0:	180b883a 	mov	r5,r3
 82461a4:	1009883a 	mov	r4,r2
 82461a8:	8245e780 	call	8245e78 <IPADDR_TO_NETP>
      /*
       * See if we found an interface, and confirm that it
       * supports multicast.
       */
      if (netp == NULL || (netp->n_mcastlist) == NULL) 
 82461ac:	e0bffb17 	ldw	r2,-20(fp)
 82461b0:	10000326 	beq	r2,zero,82461c0 <ip_setmoptions+0x214>
 82461b4:	e0bffb17 	ldw	r2,-20(fp)
 82461b8:	10802b17 	ldw	r2,172(r2)
 82461bc:	1000031e 	bne	r2,zero,82461cc <ip_setmoptions+0x220>
      {
         error = EADDRNOTAVAIL;
 82461c0:	00801f44 	movi	r2,125
 82461c4:	e0bff515 	stw	r2,-44(fp)
         break;
 82461c8:	0000cc06 	br	82464fc <ip_setmoptions+0x550>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 82461cc:	e03ff60d 	sth	zero,-40(fp)
 82461d0:	00001806 	br	8246234 <ip_setmoptions+0x288>
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
 82461d4:	e0bff60b 	ldhu	r2,-40(fp)
 82461d8:	e0fff717 	ldw	r3,-36(fp)
 82461dc:	10800084 	addi	r2,r2,2
 82461e0:	1085883a 	add	r2,r2,r2
 82461e4:	1085883a 	add	r2,r2,r2
 82461e8:	1885883a 	add	r2,r3,r2
 82461ec:	10800017 	ldw	r2,0(r2)
 82461f0:	10c00117 	ldw	r3,4(r2)
 82461f4:	e0bffb17 	ldw	r2,-20(fp)
 82461f8:	18800b1e 	bne	r3,r2,8246228 <ip_setmoptions+0x27c>
             imo->imo_membership[i]->inm_addr
 82461fc:	e0bff60b 	ldhu	r2,-40(fp)
 8246200:	e0fff717 	ldw	r3,-36(fp)
 8246204:	10800084 	addi	r2,r2,2
 8246208:	1085883a 	add	r2,r2,r2
 824620c:	1085883a 	add	r2,r2,r2
 8246210:	1885883a 	add	r2,r3,r2
 8246214:	10800017 	ldw	r2,0(r2)
 8246218:	10c00017 	ldw	r3,0(r2)
             == mreq->imr_multiaddr)
 824621c:	e0bffa17 	ldw	r2,-24(fp)
 8246220:	10800017 	ldw	r2,0(r2)
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
 8246224:	18800926 	beq	r3,r2,824624c <ip_setmoptions+0x2a0>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 8246228:	e0bff60b 	ldhu	r2,-40(fp)
 824622c:	10800044 	addi	r2,r2,1
 8246230:	e0bff60d 	sth	r2,-40(fp)
 8246234:	e0bff717 	ldw	r2,-36(fp)
 8246238:	1080018b 	ldhu	r2,6(r2)
 824623c:	10bfffcc 	andi	r2,r2,65535
 8246240:	e0fff60b 	ldhu	r3,-40(fp)
 8246244:	18bfe336 	bltu	r3,r2,82461d4 <ip_setmoptions+0x228>
 8246248:	00000106 	br	8246250 <ip_setmoptions+0x2a4>
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
             imo->imo_membership[i]->inm_addr
             == mreq->imr_multiaddr)
         {
            break;
 824624c:	0001883a 	nop
         }
      }
      if (i < imo->imo_num_memberships) 
 8246250:	e0bff717 	ldw	r2,-36(fp)
 8246254:	1080018b 	ldhu	r2,6(r2)
 8246258:	10bfffcc 	andi	r2,r2,65535
 824625c:	e0fff60b 	ldhu	r3,-40(fp)
 8246260:	1880032e 	bgeu	r3,r2,8246270 <ip_setmoptions+0x2c4>
      {
         error = EADDRINUSE;
 8246264:	00801c04 	movi	r2,112
 8246268:	e0bff515 	stw	r2,-44(fp)
         break;
 824626c:	0000a306 	br	82464fc <ip_setmoptions+0x550>
      }
      if (i == IP_MAX_MEMBERSHIPS) 
 8246270:	e0bff60b 	ldhu	r2,-40(fp)
 8246274:	10800518 	cmpnei	r2,r2,20
 8246278:	1000031e 	bne	r2,zero,8246288 <ip_setmoptions+0x2dc>
      {
         error = ETOOMANYREFS;
 824627c:	00802044 	movi	r2,129
 8246280:	e0bff515 	stw	r2,-44(fp)
         break;
 8246284:	00009d06 	br	82464fc <ip_setmoptions+0x550>
      }
      /*
       * Everything looks good; add a new record to the multicast
       * address list for the given interface.
       */
      if ((imo->imo_membership[i] =
 8246288:	e43ff60b 	ldhu	r16,-40(fp)
          in_addmulti(&mreq->imr_multiaddr, netp, 4)) == NULL) 
 824628c:	e0bffa17 	ldw	r2,-24(fp)
 8246290:	e0fffb17 	ldw	r3,-20(fp)
 8246294:	01800104 	movi	r6,4
 8246298:	180b883a 	mov	r5,r3
 824629c:	1009883a 	mov	r4,r2
 82462a0:	82439500 	call	8243950 <in_addmulti>
 82462a4:	1009883a 	mov	r4,r2
      }
      /*
       * Everything looks good; add a new record to the multicast
       * address list for the given interface.
       */
      if ((imo->imo_membership[i] =
 82462a8:	e0fff717 	ldw	r3,-36(fp)
 82462ac:	80800084 	addi	r2,r16,2
 82462b0:	1085883a 	add	r2,r2,r2
 82462b4:	1085883a 	add	r2,r2,r2
 82462b8:	1885883a 	add	r2,r3,r2
 82462bc:	11000015 	stw	r4,0(r2)
 82462c0:	e0fff717 	ldw	r3,-36(fp)
 82462c4:	80800084 	addi	r2,r16,2
 82462c8:	1085883a 	add	r2,r2,r2
 82462cc:	1085883a 	add	r2,r2,r2
 82462d0:	1885883a 	add	r2,r3,r2
 82462d4:	10800017 	ldw	r2,0(r2)
 82462d8:	1000031e 	bne	r2,zero,82462e8 <ip_setmoptions+0x33c>
          in_addmulti(&mreq->imr_multiaddr, netp, 4)) == NULL) 
      {
         error = ENOBUFS;
 82462dc:	00801a44 	movi	r2,105
 82462e0:	e0bff515 	stw	r2,-44(fp)
         break;
 82462e4:	00008506 	br	82464fc <ip_setmoptions+0x550>
      }
      ++imo->imo_num_memberships;
 82462e8:	e0bff717 	ldw	r2,-36(fp)
 82462ec:	1080018b 	ldhu	r2,6(r2)
 82462f0:	10800044 	addi	r2,r2,1
 82462f4:	1007883a 	mov	r3,r2
 82462f8:	e0bff717 	ldw	r2,-36(fp)
 82462fc:	10c0018d 	sth	r3,6(r2)
      break;
 8246300:	00007e06 	br	82464fc <ip_setmoptions+0x550>
   case IP_DROP_MEMBERSHIP:
      /*
       * Drop a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 8246304:	e0bffe17 	ldw	r2,-8(fp)
 8246308:	e0bffa15 	stw	r2,-24(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 824630c:	e0bffa17 	ldw	r2,-24(fp)
 8246310:	10800017 	ldw	r2,0(r2)
 8246314:	1006d63a 	srli	r3,r2,24
 8246318:	e0bffa17 	ldw	r2,-24(fp)
 824631c:	10800017 	ldw	r2,0(r2)
 8246320:	1004d23a 	srli	r2,r2,8
 8246324:	10bfc00c 	andi	r2,r2,65280
 8246328:	1886b03a 	or	r3,r3,r2
 824632c:	e0bffa17 	ldw	r2,-24(fp)
 8246330:	10800017 	ldw	r2,0(r2)
 8246334:	10bfc00c 	andi	r2,r2,65280
 8246338:	1004923a 	slli	r2,r2,8
 824633c:	1886b03a 	or	r3,r3,r2
 8246340:	e0bffa17 	ldw	r2,-24(fp)
 8246344:	10800017 	ldw	r2,0(r2)
 8246348:	1004963a 	slli	r2,r2,24
 824634c:	1884b03a 	or	r2,r3,r2
 8246350:	10fc002c 	andhi	r3,r2,61440
 8246354:	00b80034 	movhi	r2,57344
 8246358:	18800326 	beq	r3,r2,8246368 <ip_setmoptions+0x3bc>
      {
         error = EINVAL;
 824635c:	00800584 	movi	r2,22
 8246360:	e0bff515 	stw	r2,-44(fp)
         break;
 8246364:	00006506 	br	82464fc <ip_setmoptions+0x550>
       * If an interface address was specified, get a pointer
       * to its ifnet structure. If an interface address was not
       * specified, get a pointer to the first interface that
       * supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 8246368:	e0bffa17 	ldw	r2,-24(fp)
 824636c:	10800117 	ldw	r2,4(r2)
 8246370:	e0fffb04 	addi	r3,fp,-20
 8246374:	180b883a 	mov	r5,r3
 8246378:	1009883a 	mov	r4,r2
 824637c:	8245e780 	call	8245e78 <IPADDR_TO_NETP>
      if (netp == NULL) 
 8246380:	e0bffb17 	ldw	r2,-20(fp)
 8246384:	1000031e 	bne	r2,zero,8246394 <ip_setmoptions+0x3e8>
      {
         error = EADDRNOTAVAIL;
 8246388:	00801f44 	movi	r2,125
 824638c:	e0bff515 	stw	r2,-44(fp)
         break;
 8246390:	00005a06 	br	82464fc <ip_setmoptions+0x550>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 8246394:	e03ff60d 	sth	zero,-40(fp)
 8246398:	00001a06 	br	8246404 <ip_setmoptions+0x458>
      {
         if ((netp == NULL ||
 824639c:	e0bffb17 	ldw	r2,-20(fp)
 82463a0:	10000a26 	beq	r2,zero,82463cc <ip_setmoptions+0x420>
             imo->imo_membership[i]->inm_netp == netp) &&
 82463a4:	e0bff60b 	ldhu	r2,-40(fp)
 82463a8:	e0fff717 	ldw	r3,-36(fp)
 82463ac:	10800084 	addi	r2,r2,2
 82463b0:	1085883a 	add	r2,r2,r2
 82463b4:	1085883a 	add	r2,r2,r2
 82463b8:	1885883a 	add	r2,r3,r2
 82463bc:	10800017 	ldw	r2,0(r2)
 82463c0:	10c00117 	ldw	r3,4(r2)
 82463c4:	e0bffb17 	ldw	r2,-20(fp)
      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
      {
         if ((netp == NULL ||
 82463c8:	18800b1e 	bne	r3,r2,82463f8 <ip_setmoptions+0x44c>
             imo->imo_membership[i]->inm_netp == netp) &&
             imo->imo_membership[i]->inm_addr ==
 82463cc:	e0bff60b 	ldhu	r2,-40(fp)
 82463d0:	e0fff717 	ldw	r3,-36(fp)
 82463d4:	10800084 	addi	r2,r2,2
 82463d8:	1085883a 	add	r2,r2,r2
 82463dc:	1085883a 	add	r2,r2,r2
 82463e0:	1885883a 	add	r2,r3,r2
 82463e4:	10800017 	ldw	r2,0(r2)
 82463e8:	10c00017 	ldw	r3,0(r2)
             mreq->imr_multiaddr)
 82463ec:	e0bffa17 	ldw	r2,-24(fp)
 82463f0:	10800017 	ldw	r2,0(r2)
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
      {
         if ((netp == NULL ||
             imo->imo_membership[i]->inm_netp == netp) &&
 82463f4:	18800926 	beq	r3,r2,824641c <ip_setmoptions+0x470>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 82463f8:	e0bff60b 	ldhu	r2,-40(fp)
 82463fc:	10800044 	addi	r2,r2,1
 8246400:	e0bff60d 	sth	r2,-40(fp)
 8246404:	e0bff717 	ldw	r2,-36(fp)
 8246408:	1080018b 	ldhu	r2,6(r2)
 824640c:	10bfffcc 	andi	r2,r2,65535
 8246410:	e0fff60b 	ldhu	r3,-40(fp)
 8246414:	18bfe136 	bltu	r3,r2,824639c <ip_setmoptions+0x3f0>
 8246418:	00000106 	br	8246420 <ip_setmoptions+0x474>
         if ((netp == NULL ||
             imo->imo_membership[i]->inm_netp == netp) &&
             imo->imo_membership[i]->inm_addr ==
             mreq->imr_multiaddr)
         {
            break;
 824641c:	0001883a 	nop
         }
      }
      if (i == imo->imo_num_memberships) 
 8246420:	e0bff717 	ldw	r2,-36(fp)
 8246424:	1080018b 	ldhu	r2,6(r2)
 8246428:	10ffffcc 	andi	r3,r2,65535
 824642c:	e0bff60b 	ldhu	r2,-40(fp)
 8246430:	1880031e 	bne	r3,r2,8246440 <ip_setmoptions+0x494>
      {
         error = EADDRNOTAVAIL;
 8246434:	00801f44 	movi	r2,125
 8246438:	e0bff515 	stw	r2,-44(fp)
         break;
 824643c:	00002f06 	br	82464fc <ip_setmoptions+0x550>
      }
      /*
       * Give up the multicast address record to which the
       * membership points.
       */
      in_delmulti(imo->imo_membership[i]);
 8246440:	e0bff60b 	ldhu	r2,-40(fp)
 8246444:	e0fff717 	ldw	r3,-36(fp)
 8246448:	10800084 	addi	r2,r2,2
 824644c:	1085883a 	add	r2,r2,r2
 8246450:	1085883a 	add	r2,r2,r2
 8246454:	1885883a 	add	r2,r3,r2
 8246458:	10800017 	ldw	r2,0(r2)
 824645c:	1009883a 	mov	r4,r2
 8246460:	8243a9c0 	call	8243a9c <in_delmulti>
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 8246464:	e0bff60b 	ldhu	r2,-40(fp)
 8246468:	10800044 	addi	r2,r2,1
 824646c:	e0bff60d 	sth	r2,-40(fp)
 8246470:	00001206 	br	82464bc <ip_setmoptions+0x510>
         imo->imo_membership[i-1] = imo->imo_membership[i];
 8246474:	e0bff60b 	ldhu	r2,-40(fp)
 8246478:	117fffc4 	addi	r5,r2,-1
 824647c:	e0bff60b 	ldhu	r2,-40(fp)
 8246480:	e0fff717 	ldw	r3,-36(fp)
 8246484:	10800084 	addi	r2,r2,2
 8246488:	1085883a 	add	r2,r2,r2
 824648c:	1085883a 	add	r2,r2,r2
 8246490:	1885883a 	add	r2,r3,r2
 8246494:	10c00017 	ldw	r3,0(r2)
 8246498:	e13ff717 	ldw	r4,-36(fp)
 824649c:	28800084 	addi	r2,r5,2
 82464a0:	1085883a 	add	r2,r2,r2
 82464a4:	1085883a 	add	r2,r2,r2
 82464a8:	2085883a 	add	r2,r4,r2
 82464ac:	10c00015 	stw	r3,0(r2)
       */
      in_delmulti(imo->imo_membership[i]);
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 82464b0:	e0bff60b 	ldhu	r2,-40(fp)
 82464b4:	10800044 	addi	r2,r2,1
 82464b8:	e0bff60d 	sth	r2,-40(fp)
 82464bc:	e0bff717 	ldw	r2,-36(fp)
 82464c0:	1080018b 	ldhu	r2,6(r2)
 82464c4:	10bfffcc 	andi	r2,r2,65535
 82464c8:	e0fff60b 	ldhu	r3,-40(fp)
 82464cc:	18bfe936 	bltu	r3,r2,8246474 <ip_setmoptions+0x4c8>
         imo->imo_membership[i-1] = imo->imo_membership[i];
      --imo->imo_num_memberships;
 82464d0:	e0bff717 	ldw	r2,-36(fp)
 82464d4:	1080018b 	ldhu	r2,6(r2)
 82464d8:	10bfffc4 	addi	r2,r2,-1
 82464dc:	1007883a 	mov	r3,r2
 82464e0:	e0bff717 	ldw	r2,-36(fp)
 82464e4:	10c0018d 	sth	r3,6(r2)
      break;
 82464e8:	00000406 	br	82464fc <ip_setmoptions+0x550>

      default:
      error = EOPNOTSUPP;
 82464ec:	008017c4 	movi	r2,95
 82464f0:	e0bff515 	stw	r2,-44(fp)
      break;
 82464f4:	00000106 	br	82464fc <ip_setmoptions+0x550>
         error = EADDRNOTAVAIL;
         break;
      }
      if (addr != AADDR) 
         imo->imo_multicast_netp = netp;
      break;
 82464f8:	0001883a 	nop
   }

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
 82464fc:	e0bff717 	ldw	r2,-36(fp)
 8246500:	10800017 	ldw	r2,0(r2)
 8246504:	1000141e 	bne	r2,zero,8246558 <ip_setmoptions+0x5ac>
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
 8246508:	e0bff717 	ldw	r2,-36(fp)
 824650c:	10800103 	ldbu	r2,4(r2)
   }

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
 8246510:	10803fcc 	andi	r2,r2,255
 8246514:	10800058 	cmpnei	r2,r2,1
 8246518:	10000f1e 	bne	r2,zero,8246558 <ip_setmoptions+0x5ac>
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
 824651c:	e0bff717 	ldw	r2,-36(fp)
 8246520:	10800143 	ldbu	r2,5(r2)

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
 8246524:	10803fcc 	andi	r2,r2,255
 8246528:	10800058 	cmpnei	r2,r2,1
 824652c:	10000a1e 	bne	r2,zero,8246558 <ip_setmoptions+0x5ac>
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
       imo->imo_num_memberships == 0) 
 8246530:	e0bff717 	ldw	r2,-36(fp)
 8246534:	1080018b 	ldhu	r2,6(r2)
      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
 8246538:	10bfffcc 	andi	r2,r2,65535
 824653c:	1000061e 	bne	r2,zero,8246558 <ip_setmoptions+0x5ac>
       imo->imo_num_memberships == 0) 
   {
      IM_FREE(*imop);
 8246540:	e0bff817 	ldw	r2,-32(fp)
 8246544:	10800017 	ldw	r2,0(r2)
 8246548:	1009883a 	mov	r4,r2
 824654c:	822e1a00 	call	822e1a0 <npfree>
      *imop = NULL;
 8246550:	e0bff817 	ldw	r2,-32(fp)
 8246554:	10000015 	stw	zero,0(r2)
   }
   return (error);
 8246558:	e0bff517 	ldw	r2,-44(fp)
}
 824655c:	e6ffff04 	addi	sp,fp,-4
 8246560:	dfc00217 	ldw	ra,8(sp)
 8246564:	df000117 	ldw	fp,4(sp)
 8246568:	dc000017 	ldw	r16,0(sp)
 824656c:	dec00304 	addi	sp,sp,12
 8246570:	f800283a 	ret

08246574 <ip_getmoptions>:
 * RETURNS: 
 */

int
ip_getmoptions(int optname, struct socket * so, void * val)
{
 8246574:	defff804 	addi	sp,sp,-32
 8246578:	df000715 	stw	fp,28(sp)
 824657c:	df000704 	addi	fp,sp,28
 8246580:	e13ffd15 	stw	r4,-12(fp)
 8246584:	e17ffe15 	stw	r5,-8(fp)
 8246588:	e1bfff15 	stw	r6,-4(fp)
   u_char * ttl;
   u_char * loop;
   ip_addr *addr;
   struct ip_moptions*  imo   =  so->inp_moptions;
 824658c:	e0bffe17 	ldw	r2,-8(fp)
 8246590:	10800317 	ldw	r2,12(r2)
 8246594:	e0bff915 	stw	r2,-28(fp)
   /* The following code will be commented out for Iniche stack.
    * Don't allocate a buffer here.
    *
    *        *mp = m_get(M_WAIT, MT_SOOPTS);
    */
   switch (optname) 
 8246598:	e0bffd17 	ldw	r2,-12(fp)
 824659c:	10c002a0 	cmpeqi	r3,r2,10
 82465a0:	1800151e 	bne	r3,zero,82465f8 <ip_getmoptions+0x84>
 82465a4:	10c002e0 	cmpeqi	r3,r2,11
 82465a8:	1800211e 	bne	r3,zero,8246630 <ip_getmoptions+0xbc>
 82465ac:	10800260 	cmpeqi	r2,r2,9
 82465b0:	10002d26 	beq	r2,zero,8246668 <ip_getmoptions+0xf4>
   {

   case IP_MULTICAST_IF:
      addr = (ip_addr *)(val);
 82465b4:	e0bfff17 	ldw	r2,-4(fp)
 82465b8:	e0bffa15 	stw	r2,-24(fp)
      if (imo == NULL || imo->imo_multicast_netp == NULL)
 82465bc:	e0bff917 	ldw	r2,-28(fp)
 82465c0:	10000326 	beq	r2,zero,82465d0 <ip_getmoptions+0x5c>
 82465c4:	e0bff917 	ldw	r2,-28(fp)
 82465c8:	10800017 	ldw	r2,0(r2)
 82465cc:	1000031e 	bne	r2,zero,82465dc <ip_getmoptions+0x68>
         *addr = AADDR;
 82465d0:	e0bffa17 	ldw	r2,-24(fp)
 82465d4:	10000015 	stw	zero,0(r2)
 82465d8:	00000506 	br	82465f0 <ip_getmoptions+0x7c>
      else
         *addr = imo->imo_multicast_netp->n_ipaddr;
 82465dc:	e0bff917 	ldw	r2,-28(fp)
 82465e0:	10800017 	ldw	r2,0(r2)
 82465e4:	10c00a17 	ldw	r3,40(r2)
 82465e8:	e0bffa17 	ldw	r2,-24(fp)
 82465ec:	10c00015 	stw	r3,0(r2)
      return (0);
 82465f0:	0005883a 	mov	r2,zero
 82465f4:	00001d06 	br	824666c <ip_getmoptions+0xf8>

   case IP_MULTICAST_TTL:
      ttl = (u_char *)val;
 82465f8:	e0bfff17 	ldw	r2,-4(fp)
 82465fc:	e0bffb15 	stw	r2,-20(fp)
      if (imo == NULL)
 8246600:	e0bff917 	ldw	r2,-28(fp)
 8246604:	1000041e 	bne	r2,zero,8246618 <ip_getmoptions+0xa4>
         *ttl = IP_DEFAULT_MULTICAST_TTL;
 8246608:	e0bffb17 	ldw	r2,-20(fp)
 824660c:	00c00044 	movi	r3,1
 8246610:	10c00005 	stb	r3,0(r2)
 8246614:	00000406 	br	8246628 <ip_getmoptions+0xb4>
      else
         *ttl = imo->imo_multicast_ttl;
 8246618:	e0bff917 	ldw	r2,-28(fp)
 824661c:	10c00103 	ldbu	r3,4(r2)
 8246620:	e0bffb17 	ldw	r2,-20(fp)
 8246624:	10c00005 	stb	r3,0(r2)
      return (0);
 8246628:	0005883a 	mov	r2,zero
 824662c:	00000f06 	br	824666c <ip_getmoptions+0xf8>

   case IP_MULTICAST_LOOP:
      loop = (u_char *)val;
 8246630:	e0bfff17 	ldw	r2,-4(fp)
 8246634:	e0bffc15 	stw	r2,-16(fp)
      if (imo == NULL)
 8246638:	e0bff917 	ldw	r2,-28(fp)
 824663c:	1000041e 	bne	r2,zero,8246650 <ip_getmoptions+0xdc>
         *loop = IP_DEFAULT_MULTICAST_LOOP;
 8246640:	e0bffc17 	ldw	r2,-16(fp)
 8246644:	00c00044 	movi	r3,1
 8246648:	10c00005 	stb	r3,0(r2)
 824664c:	00000406 	br	8246660 <ip_getmoptions+0xec>
      else
         *loop = imo->imo_multicast_loop;
 8246650:	e0bff917 	ldw	r2,-28(fp)
 8246654:	10c00143 	ldbu	r3,5(r2)
 8246658:	e0bffc17 	ldw	r2,-16(fp)
 824665c:	10c00005 	stb	r3,0(r2)
      return (0);
 8246660:	0005883a 	mov	r2,zero
 8246664:	00000106 	br	824666c <ip_getmoptions+0xf8>

      default:
      return (EOPNOTSUPP);
 8246668:	008017c4 	movi	r2,95
   }
}
 824666c:	e037883a 	mov	sp,fp
 8246670:	df000017 	ldw	fp,0(sp)
 8246674:	dec00104 	addi	sp,sp,4
 8246678:	f800283a 	ret

0824667c <ip_freemoptions>:
 * RETURNS: 
 */

void
ip_freemoptions(struct ip_moptions * imo)
{
 824667c:	defffc04 	addi	sp,sp,-16
 8246680:	dfc00315 	stw	ra,12(sp)
 8246684:	df000215 	stw	fp,8(sp)
 8246688:	df000204 	addi	fp,sp,8
 824668c:	e13fff15 	stw	r4,-4(fp)
   u_short  i;

   if (imo != NULL) 
 8246690:	e0bfff17 	ldw	r2,-4(fp)
 8246694:	10001526 	beq	r2,zero,82466ec <ip_freemoptions+0x70>
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 8246698:	e03ffe0d 	sth	zero,-8(fp)
 824669c:	00000c06 	br	82466d0 <ip_freemoptions+0x54>
         in_delmulti(imo->imo_membership[i]);
 82466a0:	e0bffe0b 	ldhu	r2,-8(fp)
 82466a4:	e0ffff17 	ldw	r3,-4(fp)
 82466a8:	10800084 	addi	r2,r2,2
 82466ac:	1085883a 	add	r2,r2,r2
 82466b0:	1085883a 	add	r2,r2,r2
 82466b4:	1885883a 	add	r2,r3,r2
 82466b8:	10800017 	ldw	r2,0(r2)
 82466bc:	1009883a 	mov	r4,r2
 82466c0:	8243a9c0 	call	8243a9c <in_delmulti>
{
   u_short  i;

   if (imo != NULL) 
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 82466c4:	e0bffe0b 	ldhu	r2,-8(fp)
 82466c8:	10800044 	addi	r2,r2,1
 82466cc:	e0bffe0d 	sth	r2,-8(fp)
 82466d0:	e0bfff17 	ldw	r2,-4(fp)
 82466d4:	1080018b 	ldhu	r2,6(r2)
 82466d8:	10bfffcc 	andi	r2,r2,65535
 82466dc:	e0fffe0b 	ldhu	r3,-8(fp)
 82466e0:	18bfef36 	bltu	r3,r2,82466a0 <ip_freemoptions+0x24>
         in_delmulti(imo->imo_membership[i]);
      npfree(imo);
 82466e4:	e13fff17 	ldw	r4,-4(fp)
 82466e8:	822e1a00 	call	822e1a0 <npfree>
   }
}
 82466ec:	0001883a 	nop
 82466f0:	e037883a 	mov	sp,fp
 82466f4:	dfc00117 	ldw	ra,4(sp)
 82466f8:	df000017 	ldw	fp,0(sp)
 82466fc:	dec00204 	addi	sp,sp,8
 8246700:	f800283a 	ret

08246704 <u_mctest_init>:
 *
 * RETURNS: 
 */

void u_mctest_init()
{
 8246704:	defffe04 	addi	sp,sp,-8
 8246708:	dfc00115 	stw	ra,4(sp)
 824670c:	df000015 	stw	fp,0(sp)
 8246710:	d839883a 	mov	fp,sp
   printf("mctest init called\n");
 8246714:	01020974 	movhi	r4,2085
 8246718:	2105d004 	addi	r4,r4,5952
 824671c:	82036240 	call	8203624 <puts>
// altera changes end (cadler@altera.com)
   install_menu(u_mctest_menu);
// altera changes begin (cadler@altera.com)
#endif //IN_MENUS
// altera changes end (cadler@altera.com)
}
 8246720:	0001883a 	nop
 8246724:	e037883a 	mov	sp,fp
 8246728:	dfc00117 	ldw	ra,4(sp)
 824672c:	df000017 	ldw	fp,0(sp)
 8246730:	dec00204 	addi	sp,sp,8
 8246734:	f800283a 	ret

08246738 <u_mctest_run>:
 *
 * RETURNS: 
 */

int u_mctest_run(void * pio)
{
 8246738:	defede04 	addi	sp,sp,-1160
 824673c:	dfc12115 	stw	ra,1156(sp)
 8246740:	df012015 	stw	fp,1152(sp)
 8246744:	df012004 	addi	fp,sp,1152
 8246748:	e13fff15 	stw	r4,-4(fp)
    struct sockaddr_in   stLocal, stTo, stFrom;
    char  achIn[BUFSIZE];
    char  achOut[] = "Message number:              ";
 824674c:	009cdcf4 	movhi	r2,29555
 8246750:	10995344 	addi	r2,r2,25933
 8246754:	e0bff215 	stw	r2,-56(fp)
 8246758:	00881974 	movhi	r2,8293
 824675c:	1099d844 	addi	r2,r2,26465
 8246760:	e0bff315 	stw	r2,-52(fp)
 8246764:	00989b74 	movhi	r2,25197
 8246768:	109d5b84 	addi	r2,r2,30062
 824676c:	e0bff415 	stw	r2,-48(fp)
 8246770:	00880eb4 	movhi	r2,8250
 8246774:	109c9944 	addi	r2,r2,29285
 8246778:	e0bff515 	stw	r2,-44(fp)
 824677c:	00880834 	movhi	r2,8224
 8246780:	10880804 	addi	r2,r2,8224
 8246784:	e0bff615 	stw	r2,-40(fp)
 8246788:	00880834 	movhi	r2,8224
 824678c:	10880804 	addi	r2,r2,8224
 8246790:	e0bff715 	stw	r2,-36(fp)
 8246794:	00880834 	movhi	r2,8224
 8246798:	10880804 	addi	r2,r2,8224
 824679c:	e0bff815 	stw	r2,-32(fp)
 82467a0:	00800804 	movi	r2,32
 82467a4:	e0bff90d 	sth	r2,-28(fp)
    struct ip_mreq stMreq;
    u_char cTmp;
    unsigned long endtime;

   /* get a datagram socket */
   s = t_socket(AF_INET,SOCK_DGRAM, 0);
 82467a8:	000d883a 	mov	r6,zero
 82467ac:	01400084 	movi	r5,2
 82467b0:	01000084 	movi	r4,2
 82467b4:	82304300 	call	8230430 <t_socket>
 82467b8:	e0bee315 	stw	r2,-1140(fp)

   if (s == INVALID_SOCKET) 
 82467bc:	e0bee317 	ldw	r2,-1140(fp)
 82467c0:	10bfffd8 	cmpnei	r2,r2,-1
 82467c4:	1000091e 	bne	r2,zero,82467ec <u_mctest_run+0xb4>
   {
      ns_printf (pio,"t_socket() failed, Err: %d\n", t_errno(s));
 82467c8:	e13ee317 	ldw	r4,-1140(fp)
 82467cc:	823199c0 	call	823199c <t_errno>
 82467d0:	100d883a 	mov	r6,r2
 82467d4:	01420974 	movhi	r5,2085
 82467d8:	2945d504 	addi	r5,r5,5972
 82467dc:	e13fff17 	ldw	r4,-4(fp)
 82467e0:	8228e600 	call	8228e60 <ns_printf>
      exit(1);
 82467e4:	01000044 	movi	r4,1
 82467e8:	824b6580 	call	824b658 <exit>
   }

   /* avoid EADDRINUSE error on bind() */ 
   iTmp = 1;
 82467ec:	00800044 	movi	r2,1
 82467f0:	e0bffa15 	stw	r2,-24(fp)
   iRet = t_setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *)&iTmp, sizeof(iTmp));
 82467f4:	e0fffa04 	addi	r3,fp,-24
 82467f8:	00800104 	movi	r2,4
 82467fc:	d8800015 	stw	r2,0(sp)
 8246800:	180f883a 	mov	r7,r3
 8246804:	01800104 	movi	r6,4
 8246808:	017fffc4 	movi	r5,-1
 824680c:	e13ee317 	ldw	r4,-1140(fp)
 8246810:	8230e100 	call	8230e10 <t_setsockopt>
 8246814:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 8246818:	e0bee417 	ldw	r2,-1136(fp)
 824681c:	10bfffd8 	cmpnei	r2,r2,-1
 8246820:	1000071e 	bne	r2,zero,8246840 <u_mctest_run+0x108>
   {
      ns_printf (pio,"t_setsockopt() SO_REUSEADDR failed, Err: %d\n",
 8246824:	e13ee317 	ldw	r4,-1140(fp)
 8246828:	823199c0 	call	823199c <t_errno>
 824682c:	100d883a 	mov	r6,r2
 8246830:	01420974 	movhi	r5,2085
 8246834:	2945dc04 	addi	r5,r5,6000
 8246838:	e13fff17 	ldw	r4,-4(fp)
 824683c:	8228e600 	call	8228e60 <ns_printf>
       t_errno(s));
   }

   /* name the socket */
   stLocal.sin_family =   AF_INET;
 8246840:	00800084 	movi	r2,2
 8246844:	e0bee60d 	sth	r2,-1128(fp)
   stLocal.sin_addr.s_addr = htonl(INADDR_ANY);
 8246848:	e03ee715 	stw	zero,-1124(fp)
   stLocal.sin_port =   htons(TEST_PORT);
 824684c:	00a00344 	movi	r2,-32755
 8246850:	e0bee68d 	sth	r2,-1126(fp)
   iRet = t_bind(s, (struct sockaddr*) &stLocal, sizeof(struct sockaddr_in));
 8246854:	e0bee604 	addi	r2,fp,-1128
 8246858:	01800404 	movi	r6,16
 824685c:	100b883a 	mov	r5,r2
 8246860:	e13ee317 	ldw	r4,-1140(fp)
 8246864:	82304b00 	call	82304b0 <t_bind>
 8246868:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 824686c:	e0bee417 	ldw	r2,-1136(fp)
 8246870:	10bfffd8 	cmpnei	r2,r2,-1
 8246874:	1000061e 	bne	r2,zero,8246890 <u_mctest_run+0x158>
   {
      printf ("t_bind() failed, Err: %d\n",
 8246878:	e13ee317 	ldw	r4,-1140(fp)
 824687c:	823199c0 	call	823199c <t_errno>
 8246880:	100b883a 	mov	r5,r2
 8246884:	01020974 	movhi	r4,2085
 8246888:	2105e804 	addi	r4,r4,6048
 824688c:	82033a00 	call	82033a0 <printf>
       t_errno(s));
   }

   /* join the multicast group. TEST_ADDR */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR);
 8246890:	01820974 	movhi	r6,2085
 8246894:	3185ef04 	addi	r6,r6,6076
 8246898:	01420974 	movhi	r5,2085
 824689c:	2945f204 	addi	r5,r5,6088
 82468a0:	e13fff17 	ldw	r4,-4(fp)
 82468a4:	8228e600 	call	8228e60 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 82468a8:	01020974 	movhi	r4,2085
 82468ac:	2105ef04 	addi	r4,r4,6076
 82468b0:	82478140 	call	8247814 <inet_addr>
 82468b4:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 82468b8:	008209b4 	movhi	r2,2086
 82468bc:	10b75b04 	addi	r2,r2,-8852
 82468c0:	10800a17 	ldw	r2,40(r2)
 82468c4:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP,
 82468c8:	e0fffb04 	addi	r3,fp,-20
 82468cc:	00800204 	movi	r2,8
 82468d0:	d8800015 	stw	r2,0(sp)
 82468d4:	180f883a 	mov	r7,r3
 82468d8:	01800304 	movi	r6,12
 82468dc:	000b883a 	mov	r5,zero
 82468e0:	e13ee317 	ldw	r4,-1140(fp)
 82468e4:	8230e100 	call	8230e10 <t_setsockopt>
 82468e8:	e0bee415 	stw	r2,-1136(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 82468ec:	e0bee417 	ldw	r2,-1136(fp)
 82468f0:	10bfffd8 	cmpnei	r2,r2,-1
 82468f4:	1000071e 	bne	r2,zero,8246914 <u_mctest_run+0x1dc>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 82468f8:	e13ee317 	ldw	r4,-1140(fp)
 82468fc:	823199c0 	call	823199c <t_errno>
 8246900:	100d883a 	mov	r6,r2
 8246904:	01420974 	movhi	r5,2085
 8246908:	2945fa04 	addi	r5,r5,6120
 824690c:	e13fff17 	ldw	r4,-4(fp)
 8246910:	8228e600 	call	8228e60 <ns_printf>
                     t_errno(s));
   } 
   tk_yield();
 8246914:	822980c0 	call	822980c <tk_yield>

   /* join the multicast group. TEST_ADDR1 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR1);
 8246918:	01820974 	movhi	r6,2085
 824691c:	31860704 	addi	r6,r6,6172
 8246920:	01420974 	movhi	r5,2085
 8246924:	2945f204 	addi	r5,r5,6088
 8246928:	e13fff17 	ldw	r4,-4(fp)
 824692c:	8228e600 	call	8228e60 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR1);
 8246930:	01020974 	movhi	r4,2085
 8246934:	21060704 	addi	r4,r4,6172
 8246938:	82478140 	call	8247814 <inet_addr>
 824693c:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 8246940:	008209b4 	movhi	r2,2086
 8246944:	10b75b04 	addi	r2,r2,-8852
 8246948:	10800a17 	ldw	r2,40(r2)
 824694c:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 8246950:	e0fffb04 	addi	r3,fp,-20
 8246954:	00800204 	movi	r2,8
 8246958:	d8800015 	stw	r2,0(sp)
 824695c:	180f883a 	mov	r7,r3
 8246960:	01800304 	movi	r6,12
 8246964:	000b883a 	mov	r5,zero
 8246968:	e13ee317 	ldw	r4,-1140(fp)
 824696c:	8230e100 	call	8230e10 <t_setsockopt>
 8246970:	e0bee415 	stw	r2,-1136(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 8246974:	e0bee417 	ldw	r2,-1136(fp)
 8246978:	10bfffd8 	cmpnei	r2,r2,-1
 824697c:	1000071e 	bne	r2,zero,824699c <u_mctest_run+0x264>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 8246980:	e13ee317 	ldw	r4,-1140(fp)
 8246984:	823199c0 	call	823199c <t_errno>
 8246988:	100d883a 	mov	r6,r2
 824698c:	01420974 	movhi	r5,2085
 8246990:	2945fa04 	addi	r5,r5,6120
 8246994:	e13fff17 	ldw	r4,-4(fp)
 8246998:	8228e600 	call	8228e60 <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 824699c:	822980c0 	call	822980c <tk_yield>

   /* join the multicast group. TEST_ADDR2 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR2);
 82469a0:	01820974 	movhi	r6,2085
 82469a4:	31860a04 	addi	r6,r6,6184
 82469a8:	01420974 	movhi	r5,2085
 82469ac:	2945f204 	addi	r5,r5,6088
 82469b0:	e13fff17 	ldw	r4,-4(fp)
 82469b4:	8228e600 	call	8228e60 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR2);
 82469b8:	01020974 	movhi	r4,2085
 82469bc:	21060a04 	addi	r4,r4,6184
 82469c0:	82478140 	call	8247814 <inet_addr>
 82469c4:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 82469c8:	008209b4 	movhi	r2,2086
 82469cc:	10b75b04 	addi	r2,r2,-8852
 82469d0:	10800a17 	ldw	r2,40(r2)
 82469d4:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 82469d8:	e0fffb04 	addi	r3,fp,-20
 82469dc:	00800204 	movi	r2,8
 82469e0:	d8800015 	stw	r2,0(sp)
 82469e4:	180f883a 	mov	r7,r3
 82469e8:	01800304 	movi	r6,12
 82469ec:	000b883a 	mov	r5,zero
 82469f0:	e13ee317 	ldw	r4,-1140(fp)
 82469f4:	8230e100 	call	8230e10 <t_setsockopt>
 82469f8:	e0bee415 	stw	r2,-1136(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 82469fc:	e0bee417 	ldw	r2,-1136(fp)
 8246a00:	10bfffd8 	cmpnei	r2,r2,-1
 8246a04:	1000071e 	bne	r2,zero,8246a24 <u_mctest_run+0x2ec>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 8246a08:	e13ee317 	ldw	r4,-1140(fp)
 8246a0c:	823199c0 	call	823199c <t_errno>
 8246a10:	100d883a 	mov	r6,r2
 8246a14:	01420974 	movhi	r5,2085
 8246a18:	2945fa04 	addi	r5,r5,6120
 8246a1c:	e13fff17 	ldw	r4,-4(fp)
 8246a20:	8228e600 	call	8228e60 <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 8246a24:	822980c0 	call	822980c <tk_yield>

   /* set TTL to traverse up to multiple routers */
   cTmp = TTL_VALUE;
 8246a28:	00800084 	movi	r2,2
 8246a2c:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, (char *)&cTmp, sizeof(cTmp));
 8246a30:	e0fffd04 	addi	r3,fp,-12
 8246a34:	00800044 	movi	r2,1
 8246a38:	d8800015 	stw	r2,0(sp)
 8246a3c:	180f883a 	mov	r7,r3
 8246a40:	01800284 	movi	r6,10
 8246a44:	000b883a 	mov	r5,zero
 8246a48:	e13ee317 	ldw	r4,-1140(fp)
 8246a4c:	8230e100 	call	8230e10 <t_setsockopt>
 8246a50:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 8246a54:	e0bee417 	ldw	r2,-1136(fp)
 8246a58:	10bfffd8 	cmpnei	r2,r2,-1
 8246a5c:	1000071e 	bne	r2,zero,8246a7c <u_mctest_run+0x344>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_TTL failed, Err: %d\n",
 8246a60:	e13ee317 	ldw	r4,-1140(fp)
 8246a64:	823199c0 	call	823199c <t_errno>
 8246a68:	100d883a 	mov	r6,r2
 8246a6c:	01420974 	movhi	r5,2085
 8246a70:	29460d04 	addi	r5,r5,6196
 8246a74:	e13fff17 	ldw	r4,-4(fp)
 8246a78:	8228e600 	call	8228e60 <ns_printf>
                     t_errno(s));
   }

   /* enable loopback */
   cTmp = 1;
 8246a7c:	00800044 	movi	r2,1
 8246a80:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP, (char *)&cTmp, sizeof(cTmp));
 8246a84:	e0fffd04 	addi	r3,fp,-12
 8246a88:	00800044 	movi	r2,1
 8246a8c:	d8800015 	stw	r2,0(sp)
 8246a90:	180f883a 	mov	r7,r3
 8246a94:	018002c4 	movi	r6,11
 8246a98:	000b883a 	mov	r5,zero
 8246a9c:	e13ee317 	ldw	r4,-1140(fp)
 8246aa0:	8230e100 	call	8230e10 <t_setsockopt>
 8246aa4:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 8246aa8:	e0bee417 	ldw	r2,-1136(fp)
 8246aac:	10bfffd8 	cmpnei	r2,r2,-1
 8246ab0:	1000071e 	bne	r2,zero,8246ad0 <u_mctest_run+0x398>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_LOOP failed, Err: %d\n",
 8246ab4:	e13ee317 	ldw	r4,-1140(fp)
 8246ab8:	823199c0 	call	823199c <t_errno>
 8246abc:	100d883a 	mov	r6,r2
 8246ac0:	01420974 	movhi	r5,2085
 8246ac4:	29461a04 	addi	r5,r5,6248
 8246ac8:	e13fff17 	ldw	r4,-4(fp)
 8246acc:	8228e600 	call	8228e60 <ns_printf>
                     t_errno(s));
   }

   /* assign our destination address */
   stTo.sin_family =      AF_INET;
 8246ad0:	00800084 	movi	r2,2
 8246ad4:	e0beea0d 	sth	r2,-1112(fp)
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
 8246ad8:	01020974 	movhi	r4,2085
 8246adc:	21060704 	addi	r4,r4,6172
 8246ae0:	82478140 	call	8247814 <inet_addr>
 8246ae4:	e0beeb15 	stw	r2,-1108(fp)
   stTo.sin_port =        htons(TEST_PORT);
 8246ae8:	00a00344 	movi	r2,-32755
 8246aec:	e0beea8d 	sth	r2,-1110(fp)
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
 8246af0:	01820974 	movhi	r6,2085
 8246af4:	31860704 	addi	r6,r6,6172
 8246af8:	01420974 	movhi	r5,2085
 8246afc:	29462704 	addi	r5,r5,6300
 8246b00:	e13fff17 	ldw	r4,-4(fp)
 8246b04:	8228e600 	call	8228e60 <ns_printf>
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 8246b08:	e03ee215 	stw	zero,-1144(fp)
 8246b0c:	00008606 	br	8246d28 <u_mctest_run+0x5f0>
   {
      static int iCounter = 1;

      /* send to the multicast address */
      sprintf(&achOut[16], "%d", iCounter++);
 8246b10:	d0a05217 	ldw	r2,-32440(gp)
 8246b14:	10c00044 	addi	r3,r2,1
 8246b18:	d0e05215 	stw	r3,-32440(gp)
 8246b1c:	e0fff204 	addi	r3,fp,-56
 8246b20:	18c00404 	addi	r3,r3,16
 8246b24:	100d883a 	mov	r6,r2
 8246b28:	01420974 	movhi	r5,2085
 8246b2c:	29463604 	addi	r5,r5,6360
 8246b30:	1809883a 	mov	r4,r3
 8246b34:	82037180 	call	8203718 <sprintf>
      iRet = t_sendto(s, achOut, sizeof(achOut), 0, (struct sockaddr*)&stTo,
 8246b38:	e0fff204 	addi	r3,fp,-56
 8246b3c:	00800404 	movi	r2,16
 8246b40:	d8800115 	stw	r2,4(sp)
 8246b44:	e0beea04 	addi	r2,fp,-1112
 8246b48:	d8800015 	stw	r2,0(sp)
 8246b4c:	000f883a 	mov	r7,zero
 8246b50:	01800784 	movi	r6,30
 8246b54:	180b883a 	mov	r5,r3
 8246b58:	e13ee317 	ldw	r4,-1140(fp)
 8246b5c:	823137c0 	call	823137c <t_sendto>
 8246b60:	e0bee415 	stw	r2,-1136(fp)
                      sizeof(struct sockaddr_in));
      if (iRet < 0) 
 8246b64:	e0bee417 	ldw	r2,-1136(fp)
 8246b68:	1000080e 	bge	r2,zero,8246b8c <u_mctest_run+0x454>
      {
         /*      perror("sendto() failed\n"); */
         ns_printf (pio,"t_sendto() failed, Error: %d\n", t_errno(s));
 8246b6c:	e13ee317 	ldw	r4,-1140(fp)
 8246b70:	823199c0 	call	823199c <t_errno>
 8246b74:	100d883a 	mov	r6,r2
 8246b78:	01420974 	movhi	r5,2085
 8246b7c:	29463704 	addi	r5,r5,6364
 8246b80:	e13fff17 	ldw	r4,-4(fp)
 8246b84:	8228e600 	call	8228e60 <ns_printf>
         /*     exit(1); */
         goto exitloop;
 8246b88:	00006a06 	br	8246d34 <u_mctest_run+0x5fc>
      }

      /* make the socket non-blocking */
      iTmp = 1;
 8246b8c:	00800044 	movi	r2,1
 8246b90:	e0bffa15 	stw	r2,-24(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&iTmp, sizeof(iTmp));
 8246b94:	e0fffa04 	addi	r3,fp,-24
 8246b98:	00800104 	movi	r2,4
 8246b9c:	d8800015 	stw	r2,0(sp)
 8246ba0:	180f883a 	mov	r7,r3
 8246ba4:	01840584 	movi	r6,4118
 8246ba8:	017fffc4 	movi	r5,-1
 8246bac:	e13ee317 	ldw	r4,-1140(fp)
 8246bb0:	8230e100 	call	8230e10 <t_setsockopt>
 8246bb4:	e0bee415 	stw	r2,-1136(fp)
      if (iRet == SOCKET_ERROR) 
 8246bb8:	e0bee417 	ldw	r2,-1136(fp)
 8246bbc:	10bfffd8 	cmpnei	r2,r2,-1
 8246bc0:	1000071e 	bne	r2,zero,8246be0 <u_mctest_run+0x4a8>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (1) failed, Err: %d\n",
 8246bc4:	e13ee317 	ldw	r4,-1140(fp)
 8246bc8:	823199c0 	call	823199c <t_errno>
 8246bcc:	100d883a 	mov	r6,r2
 8246bd0:	01420974 	movhi	r5,2085
 8246bd4:	29463f04 	addi	r5,r5,6396
 8246bd8:	e13fff17 	ldw	r4,-4(fp)
 8246bdc:	8228e600 	call	8228e60 <ns_printf>
                        t_errno(s));
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);
 8246be0:	d0a0a817 	ldw	r2,-32096(gp)
 8246be4:	10807d04 	addi	r2,r2,500
 8246be8:	e0bee515 	stw	r2,-1132(fp)

      while (cticks < endtime)
 8246bec:	00003406 	br	8246cc0 <u_mctest_run+0x588>
      {
         int sa_size = sizeof(struct sockaddr_in);
 8246bf0:	00800404 	movi	r2,16
 8246bf4:	e0bffe15 	stw	r2,-8(fp)
         tk_yield();
 8246bf8:	822980c0 	call	822980c <tk_yield>

         iRet = t_recvfrom(s, achIn, BUFSIZE, 0, (struct sockaddr*)&stFrom, &sa_size);
 8246bfc:	e0fef204 	addi	r3,fp,-1080
 8246c00:	e0bffe04 	addi	r2,fp,-8
 8246c04:	d8800115 	stw	r2,4(sp)
 8246c08:	e0beee04 	addi	r2,fp,-1096
 8246c0c:	d8800015 	stw	r2,0(sp)
 8246c10:	000f883a 	mov	r7,zero
 8246c14:	01810004 	movi	r6,1024
 8246c18:	180b883a 	mov	r5,r3
 8246c1c:	e13ee317 	ldw	r4,-1140(fp)
 8246c20:	823123c0 	call	823123c <t_recvfrom>
 8246c24:	e0bee415 	stw	r2,-1136(fp)
         if (iRet < 0) 
 8246c28:	e0bee417 	ldw	r2,-1136(fp)
 8246c2c:	10000c0e 	bge	r2,zero,8246c60 <u_mctest_run+0x528>
         {
            if (t_errno(s) != EWOULDBLOCK)
 8246c30:	e13ee317 	ldw	r4,-1140(fp)
 8246c34:	823199c0 	call	823199c <t_errno>
 8246c38:	108002e0 	cmpeqi	r2,r2,11
 8246c3c:	1000081e 	bne	r2,zero,8246c60 <u_mctest_run+0x528>
            {
               /*      perror("recvfrom() failed\n"); */
               ns_printf (pio,"t_recvfrom() failed, Error: %d\n", t_errno(s));
 8246c40:	e13ee317 	ldw	r4,-1140(fp)
 8246c44:	823199c0 	call	823199c <t_errno>
 8246c48:	100d883a 	mov	r6,r2
 8246c4c:	01420974 	movhi	r5,2085
 8246c50:	29464b04 	addi	r5,r5,6444
 8246c54:	e13fff17 	ldw	r4,-4(fp)
 8246c58:	8228e600 	call	8228e60 <ns_printf>
 8246c5c:	00003506 	br	8246d34 <u_mctest_run+0x5fc>
               /*     exit(1); */
               goto exitloop;
            }
         }
         if (iRet > 0)
 8246c60:	e0bee417 	ldw	r2,-1136(fp)
 8246c64:	0080160e 	bge	zero,r2,8246cc0 <u_mctest_run+0x588>
         {
            ns_printf(pio,"From host:%s port:%d, %s\n",
 8246c68:	e0beef17 	ldw	r2,-1092(fp)
 8246c6c:	1009883a 	mov	r4,r2
 8246c70:	82289f40 	call	82289f4 <print_ipad>
 8246c74:	1009883a 	mov	r4,r2
             print_ipad(stFrom.sin_addr.s_addr),
             ntohs(stFrom.sin_port), achIn);
 8246c78:	e0beee8b 	ldhu	r2,-1094(fp)
 8246c7c:	10bfffcc 	andi	r2,r2,65535
 8246c80:	1004d23a 	srli	r2,r2,8
 8246c84:	10bfffcc 	andi	r2,r2,65535
 8246c88:	10c03fcc 	andi	r3,r2,255
 8246c8c:	e0beee8b 	ldhu	r2,-1094(fp)
 8246c90:	10bfffcc 	andi	r2,r2,65535
 8246c94:	1004923a 	slli	r2,r2,8
 8246c98:	10bfffcc 	andi	r2,r2,65535
               goto exitloop;
            }
         }
         if (iRet > 0)
         {
            ns_printf(pio,"From host:%s port:%d, %s\n",
 8246c9c:	1886b03a 	or	r3,r3,r2
 8246ca0:	e0bef204 	addi	r2,fp,-1080
 8246ca4:	d8800015 	stw	r2,0(sp)
 8246ca8:	180f883a 	mov	r7,r3
 8246cac:	200d883a 	mov	r6,r4
 8246cb0:	01420974 	movhi	r5,2085
 8246cb4:	29465304 	addi	r5,r5,6476
 8246cb8:	e13fff17 	ldw	r4,-4(fp)
 8246cbc:	8228e600 	call	8228e60 <ns_printf>
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);

      while (cticks < endtime)
 8246cc0:	d0e0a817 	ldw	r3,-32096(gp)
 8246cc4:	e0bee517 	ldw	r2,-1132(fp)
 8246cc8:	18bfc936 	bltu	r3,r2,8246bf0 <u_mctest_run+0x4b8>
             ntohs(stFrom.sin_port), achIn);
         }
      }   /* end while (cticks...) */

      /* make the socket blocking */
      cTmp = 0;
 8246ccc:	e03ffd05 	stb	zero,-12(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&cTmp, sizeof(cTmp));
 8246cd0:	e0fffd04 	addi	r3,fp,-12
 8246cd4:	00800044 	movi	r2,1
 8246cd8:	d8800015 	stw	r2,0(sp)
 8246cdc:	180f883a 	mov	r7,r3
 8246ce0:	01840584 	movi	r6,4118
 8246ce4:	017fffc4 	movi	r5,-1
 8246ce8:	e13ee317 	ldw	r4,-1140(fp)
 8246cec:	8230e100 	call	8230e10 <t_setsockopt>
 8246cf0:	e0bee415 	stw	r2,-1136(fp)
      if (iRet == SOCKET_ERROR) 
 8246cf4:	e0bee417 	ldw	r2,-1136(fp)
 8246cf8:	10bfffd8 	cmpnei	r2,r2,-1
 8246cfc:	1000071e 	bne	r2,zero,8246d1c <u_mctest_run+0x5e4>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (0) failed, Err: %d\n",
 8246d00:	e13ee317 	ldw	r4,-1140(fp)
 8246d04:	823199c0 	call	823199c <t_errno>
 8246d08:	100d883a 	mov	r6,r2
 8246d0c:	01420974 	movhi	r5,2085
 8246d10:	29465a04 	addi	r5,r5,6504
 8246d14:	e13fff17 	ldw	r4,-4(fp)
 8246d18:	8228e600 	call	8228e60 <ns_printf>
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
   stTo.sin_port =        htons(TEST_PORT);
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 8246d1c:	e0bee217 	ldw	r2,-1144(fp)
 8246d20:	10800044 	addi	r2,r2,1
 8246d24:	e0bee215 	stw	r2,-1144(fp)
 8246d28:	e0bee217 	ldw	r2,-1144(fp)
 8246d2c:	108000d0 	cmplti	r2,r2,3
 8246d30:	103f771e 	bne	r2,zero,8246b10 <u_mctest_run+0x3d8>
      }
   }   /* end for(;;) */

exitloop:
   /* delete the multicast group. */
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 8246d34:	01020974 	movhi	r4,2085
 8246d38:	2105ef04 	addi	r4,r4,6076
 8246d3c:	82478140 	call	8247814 <inet_addr>
 8246d40:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 8246d44:	008209b4 	movhi	r2,2086
 8246d48:	10b75b04 	addi	r2,r2,-8852
 8246d4c:	10800a17 	ldw	r2,40(r2)
 8246d50:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_DROP_MEMBERSHIP, (char *)&stMreq, sizeof(stMreq));
 8246d54:	e0fffb04 	addi	r3,fp,-20
 8246d58:	00800204 	movi	r2,8
 8246d5c:	d8800015 	stw	r2,0(sp)
 8246d60:	180f883a 	mov	r7,r3
 8246d64:	01800344 	movi	r6,13
 8246d68:	000b883a 	mov	r5,zero
 8246d6c:	e13ee317 	ldw	r4,-1140(fp)
 8246d70:	8230e100 	call	8230e10 <t_setsockopt>
 8246d74:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 8246d78:	e0bee417 	ldw	r2,-1136(fp)
 8246d7c:	10bfffd8 	cmpnei	r2,r2,-1
 8246d80:	1000071e 	bne	r2,zero,8246da0 <u_mctest_run+0x668>
   {
      ns_printf (pio,"t_setsockopt() IP_DROP_MEMBERSHIP failed, Err: %d\n",
 8246d84:	e13ee317 	ldw	r4,-1140(fp)
 8246d88:	823199c0 	call	823199c <t_errno>
 8246d8c:	100d883a 	mov	r6,r2
 8246d90:	01420974 	movhi	r5,2085
 8246d94:	29466604 	addi	r5,r5,6552
 8246d98:	e13fff17 	ldw	r4,-4(fp)
 8246d9c:	8228e600 	call	8228e60 <ns_printf>
   {
      ns_printf (pio,"t_shutdown failed.  Err: %d\n", t_errno(s));
   }
#endif

   iRet = t_socketclose(s);
 8246da0:	e13ee317 	ldw	r4,-1140(fp)
 8246da4:	823184c0 	call	823184c <t_socketclose>
 8246da8:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 8246dac:	e0bee417 	ldw	r2,-1136(fp)
 8246db0:	10bfffd8 	cmpnei	r2,r2,-1
 8246db4:	1000071e 	bne	r2,zero,8246dd4 <u_mctest_run+0x69c>
   {
      ns_printf (pio,"t_socketclose() failed.  Err: %d\n", t_errno(s));
 8246db8:	e13ee317 	ldw	r4,-1140(fp)
 8246dbc:	823199c0 	call	823199c <t_errno>
 8246dc0:	100d883a 	mov	r6,r2
 8246dc4:	01420974 	movhi	r5,2085
 8246dc8:	29467304 	addi	r5,r5,6604
 8246dcc:	e13fff17 	ldw	r4,-4(fp)
 8246dd0:	8228e600 	call	8228e60 <ns_printf>
   }

   return(0);
 8246dd4:	0005883a 	mov	r2,zero
}  /* end main() */  
 8246dd8:	e037883a 	mov	sp,fp
 8246ddc:	dfc00117 	ldw	ra,4(sp)
 8246de0:	df000017 	ldw	fp,0(sp)
 8246de4:	dec00204 	addi	sp,sp,8
 8246de8:	f800283a 	ret

08246dec <dhc_setup>:
 * RETURNS: void
 */

void
dhc_setup(void)
{  
 8246dec:	defff604 	addi	sp,sp,-40
 8246df0:	dfc00915 	stw	ra,36(sp)
 8246df4:	df000815 	stw	fp,32(sp)
 8246df8:	df000804 	addi	fp,sp,32
   int      iface;
   ulong    dhcp_started;
   ip_addr  dhcp_saveaddr[STATIC_NETS];
   int      e;
   int      dhcnets = 0;   /* number of nets doing DHCP */
 8246dfc:	e03ff915 	stw	zero,-28(fp)

   e = dhc_init();
 8246e00:	8229acc0 	call	8229acc <dhc_init>
 8246e04:	e0bffa15 	stw	r2,-24(fp)

   if (e)
 8246e08:	e0bffa17 	ldw	r2,-24(fp)
 8246e0c:	10000526 	beq	r2,zero,8246e24 <dhc_setup+0x38>
   {
      printf("Error starting DHCP client code.\n");
 8246e10:	01020974 	movhi	r4,2085
 8246e14:	21067c04 	addi	r4,r4,6640
 8246e18:	82036240 	call	8203624 <puts>
      netexit(1);
 8246e1c:	01000044 	movi	r4,1
 8246e20:	8243c8c0 	call	8243c8c <netexit>
   }

   dhcp_started = cticks;  /* init timeout */
 8246e24:	d0a0a817 	ldw	r2,-32096(gp)
 8246e28:	e0bffb15 	stw	r2,-20(fp)

   for (iface = 0; iface < STATIC_NETS; iface++)
 8246e2c:	e03ff815 	stw	zero,-32(fp)
 8246e30:	00005006 	br	8246f74 <dhc_setup+0x188>
   {
      if (!nets[iface])
 8246e34:	008209b4 	movhi	r2,2086
 8246e38:	10b81b04 	addi	r2,r2,-8084
 8246e3c:	e0fff817 	ldw	r3,-32(fp)
 8246e40:	18c7883a 	add	r3,r3,r3
 8246e44:	18c7883a 	add	r3,r3,r3
 8246e48:	10c5883a 	add	r2,r2,r3
 8246e4c:	10800017 	ldw	r2,0(r2)
 8246e50:	10004226 	beq	r2,zero,8246f5c <dhc_setup+0x170>
#ifdef INCLUDE_NVPARMS
      if (inet_nvparms.ifs[iface].client_dhcp)
         nets[iface]->n_flags |= NF_DHCPC ; /* use DHCP Client on this iface */
#endif   /* INCLUDE_NVPARMS */

      if (!(nets[iface]->n_flags & NF_DHCPC))
 8246e54:	008209b4 	movhi	r2,2086
 8246e58:	10b81b04 	addi	r2,r2,-8084
 8246e5c:	e0fff817 	ldw	r3,-32(fp)
 8246e60:	18c7883a 	add	r3,r3,r3
 8246e64:	18c7883a 	add	r3,r3,r3
 8246e68:	10c5883a 	add	r2,r2,r3
 8246e6c:	10800017 	ldw	r2,0(r2)
 8246e70:	10802a17 	ldw	r2,168(r2)
 8246e74:	1080400c 	andi	r2,r2,256
 8246e78:	10003a26 	beq	r2,zero,8246f64 <dhc_setup+0x178>
         continue;

      /* If callback is not already in use (by AutoIP) grab it for
       * our printf routine.
       */
      if(dhc_states[iface].callback == NULL)
 8246e7c:	008209b4 	movhi	r2,2086
 8246e80:	10b84104 	addi	r2,r2,-7932
 8246e84:	e0fff817 	ldw	r3,-32(fp)
 8246e88:	18c00f24 	muli	r3,r3,60
 8246e8c:	10c5883a 	add	r2,r2,r3
 8246e90:	10800e04 	addi	r2,r2,56
 8246e94:	10800017 	ldw	r2,0(r2)
 8246e98:	1000041e 	bne	r2,zero,8246eac <dhc_setup+0xc0>
      {
         dhc_set_callback(iface, dhc_main_ipset);
 8246e9c:	01420934 	movhi	r5,2084
 8246ea0:	295c1404 	addi	r5,r5,28752
 8246ea4:	e13ff817 	ldw	r4,-32(fp)
 8246ea8:	8229b7c0 	call	8229b7c <dhc_set_callback>
      }

      /* start DHCP on the iface - first save the default address */
      dhcp_saveaddr[iface] = nets[iface]->n_ipaddr;
 8246eac:	008209b4 	movhi	r2,2086
 8246eb0:	10b81b04 	addi	r2,r2,-8084
 8246eb4:	e0fff817 	ldw	r3,-32(fp)
 8246eb8:	18c7883a 	add	r3,r3,r3
 8246ebc:	18c7883a 	add	r3,r3,r3
 8246ec0:	10c5883a 	add	r2,r2,r3
 8246ec4:	10800017 	ldw	r2,0(r2)
 8246ec8:	10c00a17 	ldw	r3,40(r2)
 8246ecc:	e0bff817 	ldw	r2,-32(fp)
 8246ed0:	1085883a 	add	r2,r2,r2
 8246ed4:	1085883a 	add	r2,r2,r2
 8246ed8:	e13ff804 	addi	r4,fp,-32
 8246edc:	2085883a 	add	r2,r4,r2
 8246ee0:	10800404 	addi	r2,r2,16
 8246ee4:	10c00015 	stw	r3,0(r2)

      if (dhcp_saveaddr[iface] == 0L)  /* see if there is a default */
 8246ee8:	e0bff817 	ldw	r2,-32(fp)
 8246eec:	1085883a 	add	r2,r2,r2
 8246ef0:	1085883a 	add	r2,r2,r2
 8246ef4:	e0fff804 	addi	r3,fp,-32
 8246ef8:	1885883a 	add	r2,r3,r2
 8246efc:	10800404 	addi	r2,r2,16
 8246f00:	10800017 	ldw	r2,0(r2)
 8246f04:	1000041e 	bne	r2,zero,8246f18 <dhc_setup+0x12c>
         dhc_state_init(iface, TRUE);  /* Put DHCPClient in INIT state */
 8246f08:	01400044 	movi	r5,1
 8246f0c:	e13ff817 	ldw	r4,-32(fp)
 8246f10:	822c4980 	call	822c498 <dhc_state_init>
 8246f14:	00000306 	br	8246f24 <dhc_setup+0x138>
      else
         dhc_state_init(iface, FALSE); /* Put DHCPClient in INIT-REBOOT state */
 8246f18:	000b883a 	mov	r5,zero
 8246f1c:	e13ff817 	ldw	r4,-32(fp)
 8246f20:	822c4980 	call	822c498 <dhc_state_init>

      e=dhc_second();                  /* To send the DISCOVER/REQUEST pkt */
 8246f24:	822bd100 	call	822bd10 <dhc_second>
 8246f28:	e0bffa15 	stw	r2,-24(fp)
      if (e)
 8246f2c:	e0bffa17 	ldw	r2,-24(fp)
 8246f30:	10000626 	beq	r2,zero,8246f4c <dhc_setup+0x160>
      {
         printf("Error sending DHCP packet on iface %d.\n", iface);
 8246f34:	e17ff817 	ldw	r5,-32(fp)
 8246f38:	01020974 	movhi	r4,2085
 8246f3c:	21068504 	addi	r4,r4,6676
 8246f40:	82033a00 	call	82033a0 <printf>
         netexit(1);
 8246f44:	01000044 	movi	r4,1
 8246f48:	8243c8c0 	call	8243c8c <netexit>
      /* If we are not using Auto IP then we want to block below waiting
       * for DHCP completion. If we are using Auto IP then we want to
       * return and let the Auto IP code handle the DHCP completion.
       * "dhcnets" is a flag which allows this.
       */
      dhcnets++;
 8246f4c:	e0bff917 	ldw	r2,-28(fp)
 8246f50:	10800044 	addi	r2,r2,1
 8246f54:	e0bff915 	stw	r2,-28(fp)
 8246f58:	00000306 	br	8246f68 <dhc_setup+0x17c>
   dhcp_started = cticks;  /* init timeout */

   for (iface = 0; iface < STATIC_NETS; iface++)
   {
      if (!nets[iface])
         continue; /* no valid iface for this network */
 8246f5c:	0001883a 	nop
 8246f60:	00000106 	br	8246f68 <dhc_setup+0x17c>
      if (inet_nvparms.ifs[iface].client_dhcp)
         nets[iface]->n_flags |= NF_DHCPC ; /* use DHCP Client on this iface */
#endif   /* INCLUDE_NVPARMS */

      if (!(nets[iface]->n_flags & NF_DHCPC))
         continue;
 8246f64:	0001883a 	nop
      netexit(1);
   }

   dhcp_started = cticks;  /* init timeout */

   for (iface = 0; iface < STATIC_NETS; iface++)
 8246f68:	e0bff817 	ldw	r2,-32(fp)
 8246f6c:	10800044 	addi	r2,r2,1
 8246f70:	e0bff815 	stw	r2,-32(fp)
 8246f74:	e0bff817 	ldw	r2,-32(fp)
 8246f78:	10800110 	cmplti	r2,r2,4
 8246f7c:	103fad1e 	bne	r2,zero,8246e34 <dhc_setup+0x48>
       */
      dhcnets++;
#endif
   }

   if(dhcnets == 0)  /* no nets doing DHCP? */
 8246f80:	e0bff917 	ldw	r2,-28(fp)
 8246f84:	10002c26 	beq	r2,zero,8247038 <dhc_setup+0x24c>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 8246f88:	00000206 	br	8246f94 <dhc_setup+0x1a8>
   {
      /* let other tasks spin. This is required, since some systems
       * increment cticks in tasks, or use a polling task to receive
       * packets. Without this activity this loop will never exit.
       */
      tk_yield();
 8246f8c:	822980c0 	call	822980c <tk_yield>
      pktdemux();
 8246f90:	82262c40 	call	82262c4 <pktdemux>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 8246f94:	d0e0a817 	ldw	r3,-32096(gp)
 8246f98:	e0bffb17 	ldw	r2,-20(fp)
 8246f9c:	1885c83a 	sub	r2,r3,r2
 8246fa0:	108cb228 	cmpgeui	r2,r2,13000
 8246fa4:	1000021e 	bne	r2,zero,8246fb0 <dhc_setup+0x1c4>
      (dhc_alldone() == FALSE))
 8246fa8:	822c4f00 	call	822c4f0 <dhc_alldone>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 8246fac:	103ff726 	beq	r2,zero,8246f8c <dhc_setup+0x1a0>
#ifdef SUPERLOOP
      dhc_second ();
#endif
   }

   if (dhc_alldone() == FALSE)   /* dhcp timed out? */
 8246fb0:	822c4f00 	call	822c4f0 <dhc_alldone>
 8246fb4:	1000211e 	bne	r2,zero,824703c <dhc_setup+0x250>
   {
      dprintf("DHCP timed out, going back to default IP address(es)\n");
 8246fb8:	01020974 	movhi	r4,2085
 8246fbc:	21068f04 	addi	r4,r4,6716
 8246fc0:	82036240 	call	8203624 <puts>
      /* go back to defaults */
      for (iface = 0; iface < STATIC_NETS; iface++)
 8246fc4:	e03ff815 	stw	zero,-32(fp)
 8246fc8:	00001706 	br	8247028 <dhc_setup+0x23c>
      {
         if (dhc_ifacedone(iface) == FALSE)
 8246fcc:	e13ff817 	ldw	r4,-32(fp)
 8246fd0:	822c5780 	call	822c578 <dhc_ifacedone>
 8246fd4:	1000111e 	bne	r2,zero,824701c <dhc_setup+0x230>
         {
            dhc_halt(iface);
 8246fd8:	e13ff817 	ldw	r4,-32(fp)
 8246fdc:	822c2600 	call	822c260 <dhc_halt>
            nets[iface]->n_ipaddr = dhcp_saveaddr[iface];
 8246fe0:	008209b4 	movhi	r2,2086
 8246fe4:	10b81b04 	addi	r2,r2,-8084
 8246fe8:	e0fff817 	ldw	r3,-32(fp)
 8246fec:	18c7883a 	add	r3,r3,r3
 8246ff0:	18c7883a 	add	r3,r3,r3
 8246ff4:	10c5883a 	add	r2,r2,r3
 8246ff8:	10c00017 	ldw	r3,0(r2)
 8246ffc:	e0bff817 	ldw	r2,-32(fp)
 8247000:	1085883a 	add	r2,r2,r2
 8247004:	1085883a 	add	r2,r2,r2
 8247008:	e13ff804 	addi	r4,fp,-32
 824700c:	2085883a 	add	r2,r4,r2
 8247010:	10800404 	addi	r2,r2,16
 8247014:	10800017 	ldw	r2,0(r2)
 8247018:	18800a15 	stw	r2,40(r3)

   if (dhc_alldone() == FALSE)   /* dhcp timed out? */
   {
      dprintf("DHCP timed out, going back to default IP address(es)\n");
      /* go back to defaults */
      for (iface = 0; iface < STATIC_NETS; iface++)
 824701c:	e0bff817 	ldw	r2,-32(fp)
 8247020:	10800044 	addi	r2,r2,1
 8247024:	e0bff815 	stw	r2,-32(fp)
 8247028:	e0bff817 	ldw	r2,-32(fp)
 824702c:	10800110 	cmplti	r2,r2,4
 8247030:	103fe61e 	bne	r2,zero,8246fcc <dhc_setup+0x1e0>
 8247034:	00000106 	br	824703c <dhc_setup+0x250>
      dhcnets++;
#endif
   }

   if(dhcnets == 0)  /* no nets doing DHCP? */
      return;
 8247038:	0001883a 	nop
            dhc_halt(iface);
            nets[iface]->n_ipaddr = dhcp_saveaddr[iface];
         }
      }
   }
}
 824703c:	e037883a 	mov	sp,fp
 8247040:	dfc00117 	ldw	ra,4(sp)
 8247044:	df000017 	ldw	fp,0(sp)
 8247048:	dec00204 	addi	sp,sp,8
 824704c:	f800283a 	ret

08247050 <dhc_main_ipset>:
 * RETURNS: 
 */

int
dhc_main_ipset(int iface, int state)
{
 8247050:	defffc04 	addi	sp,sp,-16
 8247054:	dfc00315 	stw	ra,12(sp)
 8247058:	df000215 	stw	fp,8(sp)
 824705c:	df000204 	addi	fp,sp,8
 8247060:	e13ffe15 	stw	r4,-8(fp)
 8247064:	e17fff15 	stw	r5,-4(fp)
   if ( state == DHCS_BOUND )
 8247068:	e0bfff17 	ldw	r2,-4(fp)
 824706c:	10800198 	cmpnei	r2,r2,6
 8247070:	1000361e 	bne	r2,zero,824714c <dhc_main_ipset+0xfc>
   {
      /* print IP address acquired through DHCP Client - for user's benefit */
      printf("Acquired IP address via DHCP client for interface: %s\n",
              nets[iface]->name);
 8247074:	008209b4 	movhi	r2,2086
 8247078:	10b81b04 	addi	r2,r2,-8084
 824707c:	e0fffe17 	ldw	r3,-8(fp)
 8247080:	18c7883a 	add	r3,r3,r3
 8247084:	18c7883a 	add	r3,r3,r3
 8247088:	10c5883a 	add	r2,r2,r3
 824708c:	10800017 	ldw	r2,0(r2)
 8247090:	10800104 	addi	r2,r2,4
dhc_main_ipset(int iface, int state)
{
   if ( state == DHCS_BOUND )
   {
      /* print IP address acquired through DHCP Client - for user's benefit */
      printf("Acquired IP address via DHCP client for interface: %s\n",
 8247094:	100b883a 	mov	r5,r2
 8247098:	01020974 	movhi	r4,2085
 824709c:	21069d04 	addi	r4,r4,6772
 82470a0:	82033a00 	call	82033a0 <printf>
              nets[iface]->name);

      printf("IP address : %s\n", print_ipad(nets[iface]->n_ipaddr));
 82470a4:	008209b4 	movhi	r2,2086
 82470a8:	10b81b04 	addi	r2,r2,-8084
 82470ac:	e0fffe17 	ldw	r3,-8(fp)
 82470b0:	18c7883a 	add	r3,r3,r3
 82470b4:	18c7883a 	add	r3,r3,r3
 82470b8:	10c5883a 	add	r2,r2,r3
 82470bc:	10800017 	ldw	r2,0(r2)
 82470c0:	10800a17 	ldw	r2,40(r2)
 82470c4:	1009883a 	mov	r4,r2
 82470c8:	82289f40 	call	82289f4 <print_ipad>
 82470cc:	100b883a 	mov	r5,r2
 82470d0:	01020974 	movhi	r4,2085
 82470d4:	2106ab04 	addi	r4,r4,6828
 82470d8:	82033a00 	call	82033a0 <printf>
      printf("Subnet Mask: %s\n", print_ipad(nets[iface]->snmask));
 82470dc:	008209b4 	movhi	r2,2086
 82470e0:	10b81b04 	addi	r2,r2,-8084
 82470e4:	e0fffe17 	ldw	r3,-8(fp)
 82470e8:	18c7883a 	add	r3,r3,r3
 82470ec:	18c7883a 	add	r3,r3,r3
 82470f0:	10c5883a 	add	r2,r2,r3
 82470f4:	10800017 	ldw	r2,0(r2)
 82470f8:	10800c17 	ldw	r2,48(r2)
 82470fc:	1009883a 	mov	r4,r2
 8247100:	82289f40 	call	82289f4 <print_ipad>
 8247104:	100b883a 	mov	r5,r2
 8247108:	01020974 	movhi	r4,2085
 824710c:	2106b004 	addi	r4,r4,6848
 8247110:	82033a00 	call	82033a0 <printf>
      printf("Gateway    : %s\n", print_ipad(nets[iface]->n_defgw));
 8247114:	008209b4 	movhi	r2,2086
 8247118:	10b81b04 	addi	r2,r2,-8084
 824711c:	e0fffe17 	ldw	r3,-8(fp)
 8247120:	18c7883a 	add	r3,r3,r3
 8247124:	18c7883a 	add	r3,r3,r3
 8247128:	10c5883a 	add	r2,r2,r3
 824712c:	10800017 	ldw	r2,0(r2)
 8247130:	10800d17 	ldw	r2,52(r2)
 8247134:	1009883a 	mov	r4,r2
 8247138:	82289f40 	call	82289f4 <print_ipad>
 824713c:	100b883a 	mov	r5,r2
 8247140:	01020974 	movhi	r4,2085
 8247144:	2106b504 	addi	r4,r4,6868
 8247148:	82033a00 	call	82033a0 <printf>
   }
   return 0;
 824714c:	0005883a 	mov	r2,zero
}
 8247150:	e037883a 	mov	sp,fp
 8247154:	dfc00117 	ldw	ra,4(sp)
 8247158:	df000017 	ldw	fp,0(sp)
 824715c:	dec00204 	addi	sp,sp,8
 8247160:	f800283a 	ret

08247164 <init_memdev>:
 * RETURNS: 
 */

int
init_memdev(void)
{
 8247164:	deffff04 	addi	sp,sp,-4
 8247168:	df000015 	stw	fp,0(sp)
 824716c:	d839883a 	mov	fp,sp
   /* add our IO pointer to master list */
   mdio.next = vfsystems;
 8247170:	d0e0d417 	ldw	r3,-31920(gp)
 8247174:	00820974 	movhi	r2,2085
 8247178:	108f3c04 	addi	r2,r2,15600
 824717c:	10c00015 	stw	r3,0(r2)
   vfsystems = &mdio;
 8247180:	00820974 	movhi	r2,2085
 8247184:	108f3c04 	addi	r2,r2,15600
 8247188:	d0a0d415 	stw	r2,-31920(gp)

   /* add the memory device files to vfs list */
   mdlist[0].next = vfsfiles;
 824718c:	d0e0d617 	ldw	r3,-31912(gp)
 8247190:	00820974 	movhi	r2,2085
 8247194:	108f4504 	addi	r2,r2,15636
 8247198:	10c00015 	stw	r3,0(r2)
   vfsfiles = &mdlist[3];
 824719c:	00820974 	movhi	r2,2085
 82471a0:	108f6604 	addi	r2,r2,15768
 82471a4:	d0a0d615 	stw	r2,-31912(gp)

   return 0;
 82471a8:	0005883a 	mov	r2,zero
}
 82471ac:	e037883a 	mov	sp,fp
 82471b0:	df000017 	ldw	fp,0(sp)
 82471b4:	dec00104 	addi	sp,sp,4
 82471b8:	f800283a 	ret

082471bc <md_fopen>:
 * RETURNS: 
 */

VFILE* 
md_fopen(char * name, char * mode)
{
 82471bc:	defffd04 	addi	sp,sp,-12
 82471c0:	df000215 	stw	fp,8(sp)
 82471c4:	df000204 	addi	fp,sp,8
 82471c8:	e13ffe15 	stw	r4,-8(fp)
 82471cc:	e17fff15 	stw	r5,-4(fp)
   USE_ARG(mode);
   USE_ARG(name);
   return NULL;
 82471d0:	0005883a 	mov	r2,zero
}
 82471d4:	e037883a 	mov	sp,fp
 82471d8:	df000017 	ldw	fp,0(sp)
 82471dc:	dec00104 	addi	sp,sp,4
 82471e0:	f800283a 	ret

082471e4 <md_fclose>:
 * RETURNS: 
 */

void   
md_fclose(VFILE * vfd)
{
 82471e4:	defffe04 	addi	sp,sp,-8
 82471e8:	df000115 	stw	fp,4(sp)
 82471ec:	df000104 	addi	fp,sp,4
 82471f0:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);
}
 82471f4:	0001883a 	nop
 82471f8:	e037883a 	mov	sp,fp
 82471fc:	df000017 	ldw	fp,0(sp)
 8247200:	dec00104 	addi	sp,sp,4
 8247204:	f800283a 	ret

08247208 <md_fread>:
 * RETURNS: 
 */

int    
md_fread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 8247208:	defff704 	addi	sp,sp,-36
 824720c:	dfc00815 	stw	ra,32(sp)
 8247210:	df000715 	stw	fp,28(sp)
 8247214:	df000704 	addi	fp,sp,28
 8247218:	e13ffc15 	stw	r4,-16(fp)
 824721c:	e17ffd15 	stw	r5,-12(fp)
 8247220:	e1bffe15 	stw	r6,-8(fp)
 8247224:	e1ffff15 	stw	r7,-4(fp)
   u_long   bcount;     /* number of bytes put in caller's buffer */
   u_long   location;   /* current offset into file */
   unsigned long file_size = MEMDEV_SIZE;
 8247228:	00800834 	movhi	r2,32
 824722c:	e0bffa15 	stw	r2,-24(fp)
   if(vfd && vfd->file)
 8247230:	e0bfff17 	ldw	r2,-4(fp)
 8247234:	10000726 	beq	r2,zero,8247254 <md_fread+0x4c>
 8247238:	e0bfff17 	ldw	r2,-4(fp)
 824723c:	10800117 	ldw	r2,4(r2)
 8247240:	10000426 	beq	r2,zero,8247254 <md_fread+0x4c>
   {
      file_size = vfd->file->real_size; 
 8247244:	e0bfff17 	ldw	r2,-4(fp)
 8247248:	10800117 	ldw	r2,4(r2)
 824724c:	10800717 	ldw	r2,28(r2)
 8247250:	e0bffa15 	stw	r2,-24(fp)
#ifdef SEG16_16   /* 16-bit x86 must include segment. */
   if(vfd->cmploc == (u_char*)0xFFFFFFFF)   /* at EOF */
      return 0;
   location = (u_long)(((char huge *)vfd->cmploc) - ((char huge *)vfd->file->data));
#else
   location = (u_long)(vfd->cmploc - vfd->file->data);
 8247254:	e0bfff17 	ldw	r2,-4(fp)
 8247258:	10800217 	ldw	r2,8(r2)
 824725c:	1007883a 	mov	r3,r2
 8247260:	e0bfff17 	ldw	r2,-4(fp)
 8247264:	10800117 	ldw	r2,4(r2)
 8247268:	10800617 	ldw	r2,24(r2)
 824726c:	1885c83a 	sub	r2,r3,r2
 8247270:	e0bffb15 	stw	r2,-20(fp)
#endif   /* SEG16_16 */

   bcount = (items * (u_long)size);     /* number of bytes to transfer */
 8247274:	e0fffe17 	ldw	r3,-8(fp)
 8247278:	e0bffd17 	ldw	r2,-12(fp)
 824727c:	1885383a 	mul	r2,r3,r2
 8247280:	e0bff915 	stw	r2,-28(fp)

   /* if near end of memory, trim read count accordingly */
   if ((location + bcount) > file_size)
 8247284:	e0fffb17 	ldw	r3,-20(fp)
 8247288:	e0bff917 	ldw	r2,-28(fp)
 824728c:	1885883a 	add	r2,r3,r2
 8247290:	e0fffa17 	ldw	r3,-24(fp)
 8247294:	1880042e 	bgeu	r3,r2,82472a8 <md_fread+0xa0>
      bcount = ((u_long)file_size - location);
 8247298:	e0fffa17 	ldw	r3,-24(fp)
 824729c:	e0bffb17 	ldw	r2,-20(fp)
 82472a0:	1885c83a 	sub	r2,r3,r2
 82472a4:	e0bff915 	stw	r2,-28(fp)

   /* trap bogus size items and end-of-x86 memory conditions */
   if((location >= file_size) ||
 82472a8:	e0fffb17 	ldw	r3,-20(fp)
 82472ac:	e0bffa17 	ldw	r2,-24(fp)
 82472b0:	1880052e 	bgeu	r3,r2,82472c8 <md_fread+0xc0>
      (bcount  & 0xFFFF0000) ||
 82472b4:	e0bff917 	ldw	r2,-28(fp)
 82472b8:	10bfffec 	andhi	r2,r2,65535
   /* if near end of memory, trim read count accordingly */
   if ((location + bcount) > file_size)
      bcount = ((u_long)file_size - location);

   /* trap bogus size items and end-of-x86 memory conditions */
   if((location >= file_size) ||
 82472bc:	1000021e 	bne	r2,zero,82472c8 <md_fread+0xc0>
      (bcount  & 0xFFFF0000) ||
 82472c0:	e0bff917 	ldw	r2,-28(fp)
 82472c4:	1000021e 	bne	r2,zero,82472d0 <md_fread+0xc8>
      (bcount == 0))
   {
      return 0;
 82472c8:	0005883a 	mov	r2,zero
 82472cc:	00002006 	br	8247350 <md_fread+0x148>
   /* Use VF_NODATA if memory devices have a size, but no
      data. This can be used to measure file read speed
      without introducing an undefined data copy. */
   /* VF_NODATA is defined in ../h/vfsfiles.h */
   
   if (!(vfd->file->flags & VF_NODATA))
 82472d0:	e0bfff17 	ldw	r2,-4(fp)
 82472d4:	10800117 	ldw	r2,4(r2)
 82472d8:	1080058b 	ldhu	r2,22(r2)
 82472dc:	10bfffcc 	andi	r2,r2,65535
 82472e0:	10a0001c 	xori	r2,r2,32768
 82472e4:	10a00004 	addi	r2,r2,-32768
 82472e8:	10001016 	blt	r2,zero,824732c <md_fread+0x124>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 82472ec:	e0bfff17 	ldw	r2,-4(fp)
 82472f0:	10800117 	ldw	r2,4(r2)
 82472f4:	10800103 	ldbu	r2,4(r2)
 82472f8:	10803fcc 	andi	r2,r2,255
 82472fc:	1080201c 	xori	r2,r2,128
 8247300:	10bfe004 	addi	r2,r2,-128
 8247304:	10801b58 	cmpnei	r2,r2,109
 8247308:	1000081e 	bne	r2,zero,824732c <md_fread+0x124>
         MEMCPY(buf, vfd->cmploc + MEMDEV_BASE, (unsigned)bcount);
 824730c:	e0bfff17 	ldw	r2,-4(fp)
 8247310:	10c00217 	ldw	r3,8(r2)
 8247314:	00800834 	movhi	r2,32
 8247318:	1885883a 	add	r2,r3,r2
 824731c:	e1bff917 	ldw	r6,-28(fp)
 8247320:	100b883a 	mov	r5,r2
 8247324:	e13ffc17 	ldw	r4,-16(fp)
 8247328:	8202f100 	call	8202f10 <memcpy>
         vfd->cmploc = (u_char *)cp;
      else     /* read wrapped memory, set pointer to EOF value */
         vfd->cmploc = (u_char*)(0xFFFFFFFF);  /* EOF */
   }
#else
   vfd->cmploc += bcount;  /* adjust location */
 824732c:	e0bfff17 	ldw	r2,-4(fp)
 8247330:	10c00217 	ldw	r3,8(r2)
 8247334:	e0bff917 	ldw	r2,-28(fp)
 8247338:	1887883a 	add	r3,r3,r2
 824733c:	e0bfff17 	ldw	r2,-4(fp)
 8247340:	10c00215 	stw	r3,8(r2)
#endif
   
   return ((int)bcount/size);
 8247344:	e17ffd17 	ldw	r5,-12(fp)
 8247348:	e13ff917 	ldw	r4,-28(fp)
 824734c:	8202c100 	call	8202c10 <__udivsi3>
}
 8247350:	e037883a 	mov	sp,fp
 8247354:	dfc00117 	ldw	ra,4(sp)
 8247358:	df000017 	ldw	fp,0(sp)
 824735c:	dec00204 	addi	sp,sp,8
 8247360:	f800283a 	ret

08247364 <md_fwrite>:
 * RETURNS: 
 */

int    
md_fwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 8247364:	defffb04 	addi	sp,sp,-20
 8247368:	df000415 	stw	fp,16(sp)
 824736c:	df000404 	addi	fp,sp,16
 8247370:	e13ffc15 	stw	r4,-16(fp)
 8247374:	e17ffd15 	stw	r5,-12(fp)
 8247378:	e1bffe15 	stw	r6,-8(fp)
 824737c:	e1ffff15 	stw	r7,-4(fp)
   if (vfd->file->name[0] == 'm')   /* memory device */
 8247380:	e0bfff17 	ldw	r2,-4(fp)
 8247384:	10800117 	ldw	r2,4(r2)
 8247388:	10800103 	ldbu	r2,4(r2)
 824738c:	10803fcc 	andi	r2,r2,255
 8247390:	1080201c 	xori	r2,r2,128
 8247394:	10bfe004 	addi	r2,r2,-128
 8247398:	10801b58 	cmpnei	r2,r2,109
 824739c:	1000021e 	bne	r2,zero,82473a8 <md_fwrite+0x44>
      return 0;   /* not writable device */
 82473a0:	0005883a 	mov	r2,zero
 82473a4:	00000906 	br	82473cc <md_fwrite+0x68>

   vfd->cmploc += (items * size);   /* adjust location */
 82473a8:	e0bfff17 	ldw	r2,-4(fp)
 82473ac:	10c00217 	ldw	r3,8(r2)
 82473b0:	e13ffe17 	ldw	r4,-8(fp)
 82473b4:	e0bffd17 	ldw	r2,-12(fp)
 82473b8:	2085383a 	mul	r2,r4,r2
 82473bc:	1887883a 	add	r3,r3,r2
 82473c0:	e0bfff17 	ldw	r2,-4(fp)
 82473c4:	10c00215 	stw	r3,8(r2)

   USE_ARG(buf);     /* supress compiler warnings */

   return (items);
 82473c8:	e0bffe17 	ldw	r2,-8(fp)
}
 82473cc:	e037883a 	mov	sp,fp
 82473d0:	df000017 	ldw	fp,0(sp)
 82473d4:	dec00104 	addi	sp,sp,4
 82473d8:	f800283a 	ret

082473dc <md_fseek>:
 * RETURNS: 
 */

int
md_fseek(VFILE * vfd, long offset, int mode)
{
 82473dc:	defffc04 	addi	sp,sp,-16
 82473e0:	df000315 	stw	fp,12(sp)
 82473e4:	df000304 	addi	fp,sp,12
 82473e8:	e13ffd15 	stw	r4,-12(fp)
 82473ec:	e17ffe15 	stw	r5,-8(fp)
 82473f0:	e1bfff15 	stw	r6,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   USE_ARG(offset);
   USE_ARG(mode);
   return 0;
 82473f4:	0005883a 	mov	r2,zero
}
 82473f8:	e037883a 	mov	sp,fp
 82473fc:	df000017 	ldw	fp,0(sp)
 8247400:	dec00104 	addi	sp,sp,4
 8247404:	f800283a 	ret

08247408 <md_ftell>:
 * RETURNS: 
 */

long   
md_ftell(VFILE * vfd)
{
 8247408:	defffe04 	addi	sp,sp,-8
 824740c:	df000115 	stw	fp,4(sp)
 8247410:	df000104 	addi	fp,sp,4
 8247414:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   return MEMDEV_SIZE;
 8247418:	00800834 	movhi	r2,32
}
 824741c:	e037883a 	mov	sp,fp
 8247420:	df000017 	ldw	fp,0(sp)
 8247424:	dec00104 	addi	sp,sp,4
 8247428:	f800283a 	ret

0824742c <md_fgetc>:
 * RETURNS: 
 */

int    
md_fgetc(VFILE * vfd)
{
 824742c:	defffc04 	addi	sp,sp,-16
 8247430:	df000315 	stw	fp,12(sp)
 8247434:	df000304 	addi	fp,sp,12
 8247438:	e13fff15 	stw	r4,-4(fp)
   unsigned location;   /* current offset infile */
   int   retval   =  0;
 824743c:	e03ffd15 	stw	zero,-12(fp)

   location = vfd->cmploc - vfd->file->data;
 8247440:	e0bfff17 	ldw	r2,-4(fp)
 8247444:	10800217 	ldw	r2,8(r2)
 8247448:	1007883a 	mov	r3,r2
 824744c:	e0bfff17 	ldw	r2,-4(fp)
 8247450:	10800117 	ldw	r2,4(r2)
 8247454:	10800617 	ldw	r2,24(r2)
 8247458:	1885c83a 	sub	r2,r3,r2
 824745c:	e0bffe15 	stw	r2,-8(fp)
   if (location >= vfd->file->real_size)     /* at end of file? */
 8247460:	e0bfff17 	ldw	r2,-4(fp)
 8247464:	10800117 	ldw	r2,4(r2)
 8247468:	10800717 	ldw	r2,28(r2)
 824746c:	e0fffe17 	ldw	r3,-8(fp)
 8247470:	18800236 	bltu	r3,r2,824747c <md_fgetc+0x50>
      return EOF;
 8247474:	00bfffc4 	movi	r2,-1
 8247478:	00001a06 	br	82474e4 <md_fgetc+0xb8>

   if (!(vfd->file->flags & VF_NODATA))
 824747c:	e0bfff17 	ldw	r2,-4(fp)
 8247480:	10800117 	ldw	r2,4(r2)
 8247484:	1080058b 	ldhu	r2,22(r2)
 8247488:	10bfffcc 	andi	r2,r2,65535
 824748c:	10a0001c 	xori	r2,r2,32768
 8247490:	10a00004 	addi	r2,r2,-32768
 8247494:	10000d16 	blt	r2,zero,82474cc <md_fgetc+0xa0>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 8247498:	e0bfff17 	ldw	r2,-4(fp)
 824749c:	10800117 	ldw	r2,4(r2)
 82474a0:	10800103 	ldbu	r2,4(r2)
 82474a4:	10803fcc 	andi	r2,r2,255
 82474a8:	1080201c 	xori	r2,r2,128
 82474ac:	10bfe004 	addi	r2,r2,-128
 82474b0:	10801b58 	cmpnei	r2,r2,109
 82474b4:	1000051e 	bne	r2,zero,82474cc <md_fgetc+0xa0>
         retval = (int)(*vfd->cmploc) & 0xFF ;
 82474b8:	e0bfff17 	ldw	r2,-4(fp)
 82474bc:	10800217 	ldw	r2,8(r2)
 82474c0:	10800003 	ldbu	r2,0(r2)
 82474c4:	10803fcc 	andi	r2,r2,255
 82474c8:	e0bffd15 	stw	r2,-12(fp)
   }

   /* else for null device or files without data, 
      use whatever is in retval */

   vfd->cmploc++;    /* adjust location */
 82474cc:	e0bfff17 	ldw	r2,-4(fp)
 82474d0:	10800217 	ldw	r2,8(r2)
 82474d4:	10c00044 	addi	r3,r2,1
 82474d8:	e0bfff17 	ldw	r2,-4(fp)
 82474dc:	10c00215 	stw	r3,8(r2)
   return retval;
 82474e0:	e0bffd17 	ldw	r2,-12(fp)
}
 82474e4:	e037883a 	mov	sp,fp
 82474e8:	df000017 	ldw	fp,0(sp)
 82474ec:	dec00104 	addi	sp,sp,4
 82474f0:	f800283a 	ret

082474f4 <md_unlink>:
 * RETURNS: 
 */

int    
md_unlink(char * filename)
{
 82474f4:	defffe04 	addi	sp,sp,-8
 82474f8:	df000115 	stw	fp,4(sp)
 82474fc:	df000104 	addi	fp,sp,4
 8247500:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(filename);     /* supress compiler warnings */
   return 0;
 8247504:	0005883a 	mov	r2,zero
}
 8247508:	e037883a 	mov	sp,fp
 824750c:	df000017 	ldw	fp,0(sp)
 8247510:	dec00104 	addi	sp,sp,4
 8247514:	f800283a 	ret

08247518 <parse_ipad>:

char *   
parse_ipad(ip_addr * ipout,   /* pointer to IP address to set */
   unsigned *  sbits,      /* default subnet bit number */
   char *   stringin)      /* buffer with ascii to parse */
{
 8247518:	defff604 	addi	sp,sp,-40
 824751c:	dfc00915 	stw	ra,36(sp)
 8247520:	df000815 	stw	fp,32(sp)
 8247524:	df000804 	addi	fp,sp,32
 8247528:	e13ffd15 	stw	r4,-12(fp)
 824752c:	e17ffe15 	stw	r5,-8(fp)
 8247530:	e1bfff15 	stw	r6,-4(fp)
   char *   cp;
   int   dots  =  0; /* periods imbedded in input string */
 8247534:	e03ff915 	stw	zero,-28(fp)
   union   
   {
      u_char   c[4];
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";
 8247538:	00820974 	movhi	r2,2085
 824753c:	1086ba04 	addi	r2,r2,6888
 8247540:	e0bffa15 	stw	r2,-24(fp)

   cp = stringin;
 8247544:	e0bfff17 	ldw	r2,-4(fp)
 8247548:	e0bff815 	stw	r2,-32(fp)
   while (*cp)
 824754c:	00002506 	br	82475e4 <parse_ipad+0xcc>
   {
      if (*cp > '9' || *cp < '.' || *cp == '/')
 8247550:	e0bff817 	ldw	r2,-32(fp)
 8247554:	10800003 	ldbu	r2,0(r2)
 8247558:	10803fcc 	andi	r2,r2,255
 824755c:	1080201c 	xori	r2,r2,128
 8247560:	10bfe004 	addi	r2,r2,-128
 8247564:	10800e88 	cmpgei	r2,r2,58
 8247568:	10000e1e 	bne	r2,zero,82475a4 <parse_ipad+0x8c>
 824756c:	e0bff817 	ldw	r2,-32(fp)
 8247570:	10800003 	ldbu	r2,0(r2)
 8247574:	10803fcc 	andi	r2,r2,255
 8247578:	1080201c 	xori	r2,r2,128
 824757c:	10bfe004 	addi	r2,r2,-128
 8247580:	10800b90 	cmplti	r2,r2,46
 8247584:	1000071e 	bne	r2,zero,82475a4 <parse_ipad+0x8c>
 8247588:	e0bff817 	ldw	r2,-32(fp)
 824758c:	10800003 	ldbu	r2,0(r2)
 8247590:	10803fcc 	andi	r2,r2,255
 8247594:	1080201c 	xori	r2,r2,128
 8247598:	10bfe004 	addi	r2,r2,-128
 824759c:	10800bd8 	cmpnei	r2,r2,47
 82475a0:	1000031e 	bne	r2,zero,82475b0 <parse_ipad+0x98>
         return("all chars must be digits (0-9) or dots (.)");
 82475a4:	00820974 	movhi	r2,2085
 82475a8:	1086c304 	addi	r2,r2,6924
 82475ac:	00009406 	br	8247800 <parse_ipad+0x2e8>
      if (*cp == '.')dots++;
 82475b0:	e0bff817 	ldw	r2,-32(fp)
 82475b4:	10800003 	ldbu	r2,0(r2)
 82475b8:	10803fcc 	andi	r2,r2,255
 82475bc:	1080201c 	xori	r2,r2,128
 82475c0:	10bfe004 	addi	r2,r2,-128
 82475c4:	10800b98 	cmpnei	r2,r2,46
 82475c8:	1000031e 	bne	r2,zero,82475d8 <parse_ipad+0xc0>
 82475cc:	e0bff917 	ldw	r2,-28(fp)
 82475d0:	10800044 	addi	r2,r2,1
 82475d4:	e0bff915 	stw	r2,-28(fp)
         cp++;
 82475d8:	e0bff817 	ldw	r2,-32(fp)
 82475dc:	10800044 	addi	r2,r2,1
 82475e0:	e0bff815 	stw	r2,-32(fp)
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";

   cp = stringin;
   while (*cp)
 82475e4:	e0bff817 	ldw	r2,-32(fp)
 82475e8:	10800003 	ldbu	r2,0(r2)
 82475ec:	10803fcc 	andi	r2,r2,255
 82475f0:	1080201c 	xori	r2,r2,128
 82475f4:	10bfe004 	addi	r2,r2,-128
 82475f8:	103fd51e 	bne	r2,zero,8247550 <parse_ipad+0x38>
         return("all chars must be digits (0-9) or dots (.)");
      if (*cp == '.')dots++;
         cp++;
   }

   if ( dots < 1 || dots > 3 )
 82475fc:	e0bff917 	ldw	r2,-28(fp)
 8247600:	0080030e 	bge	zero,r2,8247610 <parse_ipad+0xf8>
 8247604:	e0bff917 	ldw	r2,-28(fp)
 8247608:	10800110 	cmplti	r2,r2,4
 824760c:	1000031e 	bne	r2,zero,824761c <parse_ipad+0x104>
      return("string must contain 1 - 3 dots (.)");
 8247610:	00820974 	movhi	r2,2085
 8247614:	1086ce04 	addi	r2,r2,6968
 8247618:	00007906 	br	8247800 <parse_ipad+0x2e8>

   cp = stringin;
 824761c:	e0bfff17 	ldw	r2,-4(fp)
 8247620:	e0bff815 	stw	r2,-32(fp)
   if ((number = atoi(cp)) > 255)   /* set net number */
 8247624:	e13ff817 	ldw	r4,-32(fp)
 8247628:	824b6400 	call	824b640 <atoi>
 824762c:	e0bffb15 	stw	r2,-20(fp)
 8247630:	e0bffb17 	ldw	r2,-20(fp)
 8247634:	10804010 	cmplti	r2,r2,256
 8247638:	1000021e 	bne	r2,zero,8247644 <parse_ipad+0x12c>
      return(toobig);
 824763c:	e0bffa17 	ldw	r2,-24(fp)
 8247640:	00006f06 	br	8247800 <parse_ipad+0x2e8>

   retval.c[0] = (u_char)number;
 8247644:	e0bffb17 	ldw	r2,-20(fp)
 8247648:	e0bffc05 	stb	r2,-16(fp)

   while (*cp != '.')cp++; /* find dot (end of number) */
 824764c:	00000306 	br	824765c <parse_ipad+0x144>
 8247650:	e0bff817 	ldw	r2,-32(fp)
 8247654:	10800044 	addi	r2,r2,1
 8247658:	e0bff815 	stw	r2,-32(fp)
 824765c:	e0bff817 	ldw	r2,-32(fp)
 8247660:	10800003 	ldbu	r2,0(r2)
 8247664:	10803fcc 	andi	r2,r2,255
 8247668:	1080201c 	xori	r2,r2,128
 824766c:	10bfe004 	addi	r2,r2,-128
 8247670:	10800b98 	cmpnei	r2,r2,46
 8247674:	103ff61e 	bne	r2,zero,8247650 <parse_ipad+0x138>
      cp++;             /* point past dot */
 8247678:	e0bff817 	ldw	r2,-32(fp)
 824767c:	10800044 	addi	r2,r2,1
 8247680:	e0bff815 	stw	r2,-32(fp)

   if (dots == 1 || dots == 2) retval.c[1] = 0;
 8247684:	e0bff917 	ldw	r2,-28(fp)
 8247688:	10800060 	cmpeqi	r2,r2,1
 824768c:	1000031e 	bne	r2,zero,824769c <parse_ipad+0x184>
 8247690:	e0bff917 	ldw	r2,-28(fp)
 8247694:	10800098 	cmpnei	r2,r2,2
 8247698:	1000021e 	bne	r2,zero,82476a4 <parse_ipad+0x18c>
 824769c:	e03ffc45 	stb	zero,-15(fp)
 82476a0:	00001806 	br	8247704 <parse_ipad+0x1ec>
      else
   {
      number = atoi(cp);
 82476a4:	e13ff817 	ldw	r4,-32(fp)
 82476a8:	824b6400 	call	824b640 <atoi>
 82476ac:	e0bffb15 	stw	r2,-20(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 82476b0:	00000306 	br	82476c0 <parse_ipad+0x1a8>
 82476b4:	e0bff817 	ldw	r2,-32(fp)
 82476b8:	10800044 	addi	r2,r2,1
 82476bc:	e0bff815 	stw	r2,-32(fp)
 82476c0:	e0bff817 	ldw	r2,-32(fp)
 82476c4:	10800003 	ldbu	r2,0(r2)
 82476c8:	10803fcc 	andi	r2,r2,255
 82476cc:	1080201c 	xori	r2,r2,128
 82476d0:	10bfe004 	addi	r2,r2,-128
 82476d4:	10800b98 	cmpnei	r2,r2,46
 82476d8:	103ff61e 	bne	r2,zero,82476b4 <parse_ipad+0x19c>
         cp++;             /* point past dot */
 82476dc:	e0bff817 	ldw	r2,-32(fp)
 82476e0:	10800044 	addi	r2,r2,1
 82476e4:	e0bff815 	stw	r2,-32(fp)
      if (number > 255) return(toobig);
 82476e8:	e0bffb17 	ldw	r2,-20(fp)
 82476ec:	10804010 	cmplti	r2,r2,256
 82476f0:	1000021e 	bne	r2,zero,82476fc <parse_ipad+0x1e4>
 82476f4:	e0bffa17 	ldw	r2,-24(fp)
 82476f8:	00004106 	br	8247800 <parse_ipad+0x2e8>
         retval.c[1] = (u_char)number;
 82476fc:	e0bffb17 	ldw	r2,-20(fp)
 8247700:	e0bffc45 	stb	r2,-15(fp)
   }

   if (dots == 1) retval.c[2] = 0;
 8247704:	e0bff917 	ldw	r2,-28(fp)
 8247708:	10800058 	cmpnei	r2,r2,1
 824770c:	1000021e 	bne	r2,zero,8247718 <parse_ipad+0x200>
 8247710:	e03ffc85 	stb	zero,-14(fp)
 8247714:	00001806 	br	8247778 <parse_ipad+0x260>
      else
   {
      number = atoi(cp);
 8247718:	e13ff817 	ldw	r4,-32(fp)
 824771c:	824b6400 	call	824b640 <atoi>
 8247720:	e0bffb15 	stw	r2,-20(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 8247724:	00000306 	br	8247734 <parse_ipad+0x21c>
 8247728:	e0bff817 	ldw	r2,-32(fp)
 824772c:	10800044 	addi	r2,r2,1
 8247730:	e0bff815 	stw	r2,-32(fp)
 8247734:	e0bff817 	ldw	r2,-32(fp)
 8247738:	10800003 	ldbu	r2,0(r2)
 824773c:	10803fcc 	andi	r2,r2,255
 8247740:	1080201c 	xori	r2,r2,128
 8247744:	10bfe004 	addi	r2,r2,-128
 8247748:	10800b98 	cmpnei	r2,r2,46
 824774c:	103ff61e 	bne	r2,zero,8247728 <parse_ipad+0x210>
         cp++;             /* point past dot */
 8247750:	e0bff817 	ldw	r2,-32(fp)
 8247754:	10800044 	addi	r2,r2,1
 8247758:	e0bff815 	stw	r2,-32(fp)
      if (number > 255) return(toobig);
 824775c:	e0bffb17 	ldw	r2,-20(fp)
 8247760:	10804010 	cmplti	r2,r2,256
 8247764:	1000021e 	bne	r2,zero,8247770 <parse_ipad+0x258>
 8247768:	e0bffa17 	ldw	r2,-24(fp)
 824776c:	00002406 	br	8247800 <parse_ipad+0x2e8>
         retval.c[2] = (u_char)number;
 8247770:	e0bffb17 	ldw	r2,-20(fp)
 8247774:	e0bffc85 	stb	r2,-14(fp)
   }

   if ((number = atoi(cp)) > 255)
 8247778:	e13ff817 	ldw	r4,-32(fp)
 824777c:	824b6400 	call	824b640 <atoi>
 8247780:	e0bffb15 	stw	r2,-20(fp)
 8247784:	e0bffb17 	ldw	r2,-20(fp)
 8247788:	10804010 	cmplti	r2,r2,256
 824778c:	1000021e 	bne	r2,zero,8247798 <parse_ipad+0x280>
      return(toobig);
 8247790:	e0bffa17 	ldw	r2,-24(fp)
 8247794:	00001a06 	br	8247800 <parse_ipad+0x2e8>
   retval.c[3] = (u_char)number;
 8247798:	e0bffb17 	ldw	r2,-20(fp)
 824779c:	e0bffcc5 	stb	r2,-13(fp)

   if (retval.c[0] < 128) *sbits = 8;
 82477a0:	e0bffc03 	ldbu	r2,-16(fp)
 82477a4:	10803fcc 	andi	r2,r2,255
 82477a8:	1080201c 	xori	r2,r2,128
 82477ac:	10bfe004 	addi	r2,r2,-128
 82477b0:	10000416 	blt	r2,zero,82477c4 <parse_ipad+0x2ac>
 82477b4:	e0bffe17 	ldw	r2,-8(fp)
 82477b8:	00c00204 	movi	r3,8
 82477bc:	10c00015 	stw	r3,0(r2)
 82477c0:	00000b06 	br	82477f0 <parse_ipad+0x2d8>
      else if(retval.c[0] < 192) *sbits = 16;
 82477c4:	e0bffc03 	ldbu	r2,-16(fp)
 82477c8:	10803fcc 	andi	r2,r2,255
 82477cc:	10803028 	cmpgeui	r2,r2,192
 82477d0:	1000041e 	bne	r2,zero,82477e4 <parse_ipad+0x2cc>
 82477d4:	e0bffe17 	ldw	r2,-8(fp)
 82477d8:	00c00404 	movi	r3,16
 82477dc:	10c00015 	stw	r3,0(r2)
 82477e0:	00000306 	br	82477f0 <parse_ipad+0x2d8>
      else *sbits = 24;
 82477e4:	e0bffe17 	ldw	r2,-8(fp)
 82477e8:	00c00604 	movi	r3,24
 82477ec:	10c00015 	stw	r3,0(r2)

      *ipout = retval.l;      /* everything went OK, return number */
 82477f0:	e0fffc17 	ldw	r3,-16(fp)
 82477f4:	e0bffd17 	ldw	r2,-12(fp)
 82477f8:	10c00015 	stw	r3,0(r2)
   return(NULL);        /* return OK code (no error string) */
 82477fc:	0005883a 	mov	r2,zero
}
 8247800:	e037883a 	mov	sp,fp
 8247804:	dfc00117 	ldw	ra,4(sp)
 8247808:	df000017 	ldw	fp,0(sp)
 824780c:	dec00204 	addi	sp,sp,8
 8247810:	f800283a 	ret

08247814 <inet_addr>:
 * RETURNS: u_long ipaddr
 */

u_long 
inet_addr(char FAR * str)
{
 8247814:	defffb04 	addi	sp,sp,-20
 8247818:	dfc00415 	stw	ra,16(sp)
 824781c:	df000315 	stw	fp,12(sp)
 8247820:	df000304 	addi	fp,sp,12
 8247824:	e13fff15 	stw	r4,-4(fp)
    * we need to make the conversion. Usually this function will be 
    * used for debugging, so I think we can bear the STRCPY overhead.
    */
   static char nearBuf[30];

   strcpy((char FAR *)nearBuf,str);
 8247828:	e17fff17 	ldw	r5,-4(fp)
 824782c:	01020974 	movhi	r4,2085
 8247830:	21120f04 	addi	r4,r4,18492
 8247834:	824b6b80 	call	824b6b8 <strcpy>
   if ( parse_ipad(&ipaddr,&bits,nearBuf) == NULL )
 8247838:	e0bffe04 	addi	r2,fp,-8
 824783c:	01820974 	movhi	r6,2085
 8247840:	31920f04 	addi	r6,r6,18492
 8247844:	100b883a 	mov	r5,r2
 8247848:	e13ffd04 	addi	r4,fp,-12
 824784c:	82475180 	call	8247518 <parse_ipad>
 8247850:	1000021e 	bne	r2,zero,824785c <inet_addr+0x48>
   {
      return ipaddr ;
 8247854:	e0bffd17 	ldw	r2,-12(fp)
 8247858:	00000106 	br	8247860 <inet_addr+0x4c>
   }
   else
   {
      return (u_long)NULL ;
 824785c:	0005883a 	mov	r2,zero
   }
}
 8247860:	e037883a 	mov	sp,fp
 8247864:	dfc00117 	ldw	ra,4(sp)
 8247868:	df000017 	ldw	fp,0(sp)
 824786c:	dec00204 	addi	sp,sp,8
 8247870:	f800283a 	ret

08247874 <hextoa>:
 * RETURNS: character 0-9 or A-F
 */

char
hextoa(int val)
{
 8247874:	defffe04 	addi	sp,sp,-8
 8247878:	df000115 	stw	fp,4(sp)
 824787c:	df000104 	addi	fp,sp,4
 8247880:	e13fff15 	stw	r4,-4(fp)
   val &= 0x0f;
 8247884:	e0bfff17 	ldw	r2,-4(fp)
 8247888:	108003cc 	andi	r2,r2,15
 824788c:	e0bfff15 	stw	r2,-4(fp)
   if(val < 10)
 8247890:	e0bfff17 	ldw	r2,-4(fp)
 8247894:	10800288 	cmpgei	r2,r2,10
 8247898:	1000031e 	bne	r2,zero,82478a8 <hextoa+0x34>
      return (char)(val + '0');
 824789c:	e0bfff17 	ldw	r2,-4(fp)
 82478a0:	10800c04 	addi	r2,r2,48
 82478a4:	00000206 	br	82478b0 <hextoa+0x3c>
   else
      return (char)(val + 55);   /* converts 10-15 -> "A-F" */
 82478a8:	e0bfff17 	ldw	r2,-4(fp)
 82478ac:	10800dc4 	addi	r2,r2,55
}
 82478b0:	e037883a 	mov	sp,fp
 82478b4:	df000017 	ldw	fp,0(sp)
 82478b8:	dec00104 	addi	sp,sp,4
 82478bc:	f800283a 	ret

082478c0 <inet_pton>:

char * pton_error = "";

int
inet_pton(int af, const char * src, void * dst)
{
 82478c0:	defff804 	addi	sp,sp,-32
 82478c4:	dfc00715 	stw	ra,28(sp)
 82478c8:	df000615 	stw	fp,24(sp)
 82478cc:	df000604 	addi	fp,sp,24
 82478d0:	e13ffd15 	stw	r4,-12(fp)
 82478d4:	e17ffe15 	stw	r5,-8(fp)
 82478d8:	e1bfff15 	stw	r6,-4(fp)
   int            words;   /* count of words written to dest */
#endif

#if defined(IP_V4) || defined(MINI_IP)
   /* RFC 2133 wants us to support both types of address */
   if(af == AF_INET)    /* wants a v4 address */
 82478dc:	e0bffd17 	ldw	r2,-12(fp)
 82478e0:	10800098 	cmpnei	r2,r2,2
 82478e4:	1000151e 	bne	r2,zero,824793c <inet_pton+0x7c>
   {
      u_long ip4addr;
      unsigned sbits;
      char * err;
      
      err = parse_ipad(&ip4addr, &sbits, (char *) src);
 82478e8:	e0fffc04 	addi	r3,fp,-16
 82478ec:	e0bffb04 	addi	r2,fp,-20
 82478f0:	e1bffe17 	ldw	r6,-8(fp)
 82478f4:	180b883a 	mov	r5,r3
 82478f8:	1009883a 	mov	r4,r2
 82478fc:	82475180 	call	8247518 <parse_ipad>
 8247900:	e0bffa15 	stw	r2,-24(fp)
      if(err == NULL)
 8247904:	e0bffa17 	ldw	r2,-24(fp)
 8247908:	1000071e 	bne	r2,zero,8247928 <inet_pton+0x68>
      {
         /* copy the parsed address into caller's buffer, and 
          * return success
          */
         MEMCPY(dst, &ip4addr, sizeof (u_long));
 824790c:	e0bffb04 	addi	r2,fp,-20
 8247910:	01800104 	movi	r6,4
 8247914:	100b883a 	mov	r5,r2
 8247918:	e13fff17 	ldw	r4,-4(fp)
 824791c:	8202f100 	call	8202f10 <memcpy>
         return 0;
 8247920:	0005883a 	mov	r2,zero
 8247924:	00000606 	br	8247940 <inet_pton+0x80>
      }
      else
      {
         /* return failure */
         pton_error = "IPv4 address parse failure";
 8247928:	00820974 	movhi	r2,2085
 824792c:	1086d804 	addi	r2,r2,7008
 8247930:	d0a05415 	stw	r2,-32432(gp)
         return 1;
 8247934:	00800044 	movi	r2,1
 8247938:	00000106 	br	8247940 <inet_pton+0x80>
      pton_error = "too short - missing colon?";
      return 1;
   }
   
#endif /* IP_V6 */   
   return 0;
 824793c:	0005883a 	mov	r2,zero
}
 8247940:	e037883a 	mov	sp,fp
 8247944:	dfc00117 	ldw	ra,4(sp)
 8247948:	df000017 	ldw	fp,0(sp)
 824794c:	dec00204 	addi	sp,sp,8
 8247950:	f800283a 	ret

08247954 <inet_ntop>:
 * address output (40 bytes).
 */

const char *
inet_ntop(int af, const void *addr, char *str, size_t size)
{
 8247954:	defff804 	addi	sp,sp,-32
 8247958:	dfc00715 	stw	ra,28(sp)
 824795c:	df000615 	stw	fp,24(sp)
 8247960:	df000604 	addi	fp,sp,24
 8247964:	e13ffc15 	stw	r4,-16(fp)
 8247968:	e17ffd15 	stw	r5,-12(fp)
 824796c:	e1bffe15 	stw	r6,-8(fp)
 8247970:	e1ffff15 	stw	r7,-4(fp)
   char *cp;

#if defined(IP_V4) || defined(MINI_IP)
   if (af == AF_INET)
 8247974:	e0bffc17 	ldw	r2,-16(fp)
 8247978:	10800098 	cmpnei	r2,r2,2
 824797c:	1000101e 	bne	r2,zero,82479c0 <inet_ntop+0x6c>
   {
      u_long   ip4addr;

      ip4addr = *(u_long*)addr;
 8247980:	e0bffd17 	ldw	r2,-12(fp)
 8247984:	10800017 	ldw	r2,0(r2)
 8247988:	e0bffa15 	stw	r2,-24(fp)
      cp = print_ipad(ip4addr);
 824798c:	e13ffa17 	ldw	r4,-24(fp)
 8247990:	82289f40 	call	82289f4 <print_ipad>
 8247994:	e0bffb15 	stw	r2,-20(fp)
      if (strlen(cp) < size)
 8247998:	e13ffb17 	ldw	r4,-20(fp)
 824799c:	8203f600 	call	8203f60 <strlen>
 82479a0:	1007883a 	mov	r3,r2
 82479a4:	e0bfff17 	ldw	r2,-4(fp)
 82479a8:	1880052e 	bgeu	r3,r2,82479c0 <inet_ntop+0x6c>
      {
         strcpy(str, cp);
 82479ac:	e17ffb17 	ldw	r5,-20(fp)
 82479b0:	e13ffe17 	ldw	r4,-8(fp)
 82479b4:	824b6b80 	call	824b6b8 <strcpy>
         return (str);
 82479b8:	e0bffe17 	ldw	r2,-8(fp)
 82479bc:	00000106 	br	82479c4 <inet_ntop+0x70>
         return (str);
      }
   }
#endif

   return ((const char *)NULL);
 82479c0:	0005883a 	mov	r2,zero
}
 82479c4:	e037883a 	mov	sp,fp
 82479c8:	dfc00117 	ldw	ra,4(sp)
 82479cc:	df000017 	ldw	fp,0(sp)
 82479d0:	dec00204 	addi	sp,sp,8
 82479d4:	f800283a 	ret

082479d8 <print46_addr>:
 *
 * RETURNS: Pointer to string with the address in readable format.
 */

char * print46_addr(struct sockaddr *ipaddr)
{
 82479d8:	defffc04 	addi	sp,sp,-16
 82479dc:	dfc00315 	stw	ra,12(sp)
 82479e0:	df000215 	stw	fp,8(sp)
 82479e4:	df000204 	addi	fp,sp,8
 82479e8:	e13fff15 	stw	r4,-4(fp)
   if (ipaddr->sa_family == AF_INET)
 82479ec:	e0bfff17 	ldw	r2,-4(fp)
 82479f0:	1080000b 	ldhu	r2,0(r2)
 82479f4:	10bfffcc 	andi	r2,r2,65535
 82479f8:	10800098 	cmpnei	r2,r2,2
 82479fc:	1000071e 	bne	r2,zero,8247a1c <print46_addr+0x44>
   {
      struct sockaddr_in * addr = (struct sockaddr_in *)ipaddr;
 8247a00:	e0bfff17 	ldw	r2,-4(fp)
 8247a04:	e0bffe15 	stw	r2,-8(fp)
      return print_ipad(addr->sin_addr.s_addr);
 8247a08:	e0bffe17 	ldw	r2,-8(fp)
 8247a0c:	10800117 	ldw	r2,4(r2)
 8247a10:	1009883a 	mov	r4,r2
 8247a14:	82289f40 	call	82289f4 <print_ipad>
 8247a18:	00000106 	br	8247a20 <print46_addr+0x48>
      static char namebuf[46];  /* max len of IPv6 addr */
      return (char *)inet_ntop(AF_INET6,&addr->sin6_addr, namebuf, sizeof(namebuf));
   }
#endif

   return NULL;
 8247a1c:	0005883a 	mov	r2,zero
}
 8247a20:	e037883a 	mov	sp,fp
 8247a24:	dfc00117 	ldw	ra,4(sp)
 8247a28:	df000017 	ldw	fp,0(sp)
 8247a2c:	dec00204 	addi	sp,sp,8
 8247a30:	f800283a 	ret

08247a34 <inet46_addr>:
 *
 */

int 
inet46_addr(char * str, struct sockaddr *address)
{
 8247a34:	defffb04 	addi	sp,sp,-20
 8247a38:	dfc00415 	stw	ra,16(sp)
 8247a3c:	df000315 	stw	fp,12(sp)
 8247a40:	df000304 	addi	fp,sp,12
 8247a44:	e13ffe15 	stw	r4,-8(fp)
 8247a48:	e17fff15 	stw	r5,-4(fp)
   /* Read the IPv4/IPv6 address */
   address->sa_family = AF_INET; /* assume IPv4 address by default */
 8247a4c:	e0bfff17 	ldw	r2,-4(fp)
 8247a50:	00c00084 	movi	r3,2
 8247a54:	10c0000d 	sth	r3,0(r2)

   if ((str[1] == '.') || (str[2] == '.') || (str[3] == '.'))
 8247a58:	e0bffe17 	ldw	r2,-8(fp)
 8247a5c:	10800044 	addi	r2,r2,1
 8247a60:	10800003 	ldbu	r2,0(r2)
 8247a64:	10803fcc 	andi	r2,r2,255
 8247a68:	1080201c 	xori	r2,r2,128
 8247a6c:	10bfe004 	addi	r2,r2,-128
 8247a70:	10800ba0 	cmpeqi	r2,r2,46
 8247a74:	1000101e 	bne	r2,zero,8247ab8 <inet46_addr+0x84>
 8247a78:	e0bffe17 	ldw	r2,-8(fp)
 8247a7c:	10800084 	addi	r2,r2,2
 8247a80:	10800003 	ldbu	r2,0(r2)
 8247a84:	10803fcc 	andi	r2,r2,255
 8247a88:	1080201c 	xori	r2,r2,128
 8247a8c:	10bfe004 	addi	r2,r2,-128
 8247a90:	10800ba0 	cmpeqi	r2,r2,46
 8247a94:	1000081e 	bne	r2,zero,8247ab8 <inet46_addr+0x84>
 8247a98:	e0bffe17 	ldw	r2,-8(fp)
 8247a9c:	108000c4 	addi	r2,r2,3
 8247aa0:	10800003 	ldbu	r2,0(r2)
 8247aa4:	10803fcc 	andi	r2,r2,255
 8247aa8:	1080201c 	xori	r2,r2,128
 8247aac:	10bfe004 	addi	r2,r2,-128
 8247ab0:	10800b98 	cmpnei	r2,r2,46
 8247ab4:	10000a1e 	bne	r2,zero,8247ae0 <inet46_addr+0xac>
   {
      struct sockaddr_in *addr = (struct sockaddr_in *)address;
 8247ab8:	e0bfff17 	ldw	r2,-4(fp)
 8247abc:	e0bffd15 	stw	r2,-12(fp)
      addr->sin_addr.s_addr = inet_addr(str);
 8247ac0:	e13ffe17 	ldw	r4,-8(fp)
 8247ac4:	82478140 	call	8247814 <inet_addr>
 8247ac8:	1007883a 	mov	r3,r2
 8247acc:	e0bffd17 	ldw	r2,-12(fp)
 8247ad0:	10c00115 	stw	r3,4(r2)
      addr->sin_family = AF_INET;
 8247ad4:	e0bffd17 	ldw	r2,-12(fp)
 8247ad8:	00c00084 	movi	r3,2
 8247adc:	10c0000d 	sth	r3,0(r2)
      inet_pton(AF_INET6, str, &addr->sin6_addr);
      addr->sin6_family = AF_INET6;
   }
#endif

   return 0;
 8247ae0:	0005883a 	mov	r2,zero
}
 8247ae4:	e037883a 	mov	sp,fp
 8247ae8:	dfc00117 	ldw	ra,4(sp)
 8247aec:	df000017 	ldw	fp,0(sp)
 8247af0:	dec00204 	addi	sp,sp,8
 8247af4:	f800283a 	ret

08247af8 <inet_setport>:
 *
 * RETURNS: -
 */

void inet_setport(struct sockaddr *addr,int port) 
{
 8247af8:	defffc04 	addi	sp,sp,-16
 8247afc:	df000315 	stw	fp,12(sp)
 8247b00:	df000304 	addi	fp,sp,12
 8247b04:	e13ffe15 	stw	r4,-8(fp)
 8247b08:	e17fff15 	stw	r5,-4(fp)
   if (addr->sa_family == AF_INET)
 8247b0c:	e0bffe17 	ldw	r2,-8(fp)
 8247b10:	1080000b 	ldhu	r2,0(r2)
 8247b14:	10bfffcc 	andi	r2,r2,65535
 8247b18:	10800098 	cmpnei	r2,r2,2
 8247b1c:	10000c1e 	bne	r2,zero,8247b50 <inet_setport+0x58>
   {
      struct sockaddr_in *si = (struct sockaddr_in *)addr;
 8247b20:	e0bffe17 	ldw	r2,-8(fp)
 8247b24:	e0bffd15 	stw	r2,-12(fp)
      si->sin_port = htons(port);  
 8247b28:	e0bfff17 	ldw	r2,-4(fp)
 8247b2c:	1005d23a 	srai	r2,r2,8
 8247b30:	10803fcc 	andi	r2,r2,255
 8247b34:	1007883a 	mov	r3,r2
 8247b38:	e0bfff17 	ldw	r2,-4(fp)
 8247b3c:	1004923a 	slli	r2,r2,8
 8247b40:	1884b03a 	or	r2,r3,r2
 8247b44:	1007883a 	mov	r3,r2
 8247b48:	e0bffd17 	ldw	r2,-12(fp)
 8247b4c:	10c0008d 	sth	r3,2(r2)
      struct sockaddr_in6 *si = (struct sockaddr_in6 *)addr;
      si->sin6_port = htons(port);
   }
#endif

}
 8247b50:	0001883a 	nop
 8247b54:	e037883a 	mov	sp,fp
 8247b58:	df000017 	ldw	fp,0(sp)
 8247b5c:	dec00104 	addi	sp,sp,4
 8247b60:	f800283a 	ret

08247b64 <convert_ip>:
 *Returns:
 *
 */

unsigned long convert_ip(const char *p)
{
 8247b64:	defff904 	addi	sp,sp,-28
 8247b68:	df000615 	stw	fp,24(sp)
 8247b6c:	df000604 	addi	fp,sp,24
 8247b70:	e13fff15 	stw	r4,-4(fp)
   const char *cp = p;
 8247b74:	e0bfff17 	ldw	r2,-4(fp)
 8247b78:	e0bffa15 	stw	r2,-24(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
 8247b7c:	e0bffe04 	addi	r2,fp,-8
 8247b80:	e0bffd15 	stw	r2,-12(fp)
   int n = 0;
 8247b84:	e03ffb15 	stw	zero,-20(fp)
   unsigned short v = 0;
 8247b88:	e03ffc0d 	sth	zero,-16(fp)
   dw = 0;
 8247b8c:	e03ffe15 	stw	zero,-8(fp)
   while(*cp)
 8247b90:	00003106 	br	8247c58 <convert_ip+0xf4>
   {
      if( *cp == '.')
 8247b94:	e0bffa17 	ldw	r2,-24(fp)
 8247b98:	10800003 	ldbu	r2,0(r2)
 8247b9c:	10803fcc 	andi	r2,r2,255
 8247ba0:	1080201c 	xori	r2,r2,128
 8247ba4:	10bfe004 	addi	r2,r2,-128
 8247ba8:	10800b98 	cmpnei	r2,r2,46
 8247bac:	10000e1e 	bne	r2,zero,8247be8 <convert_ip+0x84>
      {
         lpb[n] = (unsigned char) v;
 8247bb0:	e0bffb17 	ldw	r2,-20(fp)
 8247bb4:	e0fffd17 	ldw	r3,-12(fp)
 8247bb8:	1885883a 	add	r2,r3,r2
 8247bbc:	e0fffc0b 	ldhu	r3,-16(fp)
 8247bc0:	10c00005 	stb	r3,0(r2)
         v = 0;
 8247bc4:	e03ffc0d 	sth	zero,-16(fp)
         n++;
 8247bc8:	e0bffb17 	ldw	r2,-20(fp)
 8247bcc:	10800044 	addi	r2,r2,1
 8247bd0:	e0bffb15 	stw	r2,-20(fp)
         if(n > 3)
 8247bd4:	e0bffb17 	ldw	r2,-20(fp)
 8247bd8:	10800110 	cmplti	r2,r2,4
 8247bdc:	10001b1e 	bne	r2,zero,8247c4c <convert_ip+0xe8>
         {
            return dw;
 8247be0:	e0bffe17 	ldw	r2,-8(fp)
 8247be4:	00002806 	br	8247c88 <convert_ip+0x124>
         }
      }
      else if(((*cp >= '0') && (*cp <= '9')))
 8247be8:	e0bffa17 	ldw	r2,-24(fp)
 8247bec:	10800003 	ldbu	r2,0(r2)
 8247bf0:	10803fcc 	andi	r2,r2,255
 8247bf4:	1080201c 	xori	r2,r2,128
 8247bf8:	10bfe004 	addi	r2,r2,-128
 8247bfc:	10800c10 	cmplti	r2,r2,48
 8247c00:	1000121e 	bne	r2,zero,8247c4c <convert_ip+0xe8>
 8247c04:	e0bffa17 	ldw	r2,-24(fp)
 8247c08:	10800003 	ldbu	r2,0(r2)
 8247c0c:	10803fcc 	andi	r2,r2,255
 8247c10:	1080201c 	xori	r2,r2,128
 8247c14:	10bfe004 	addi	r2,r2,-128
 8247c18:	10800e88 	cmpgei	r2,r2,58
 8247c1c:	10000b1e 	bne	r2,zero,8247c4c <convert_ip+0xe8>
      {
         v = (v * 10) + (*cp - '0');
 8247c20:	e0bffc0b 	ldhu	r2,-16(fp)
 8247c24:	108002a4 	muli	r2,r2,10
 8247c28:	1007883a 	mov	r3,r2
 8247c2c:	e0bffa17 	ldw	r2,-24(fp)
 8247c30:	10800003 	ldbu	r2,0(r2)
 8247c34:	10803fcc 	andi	r2,r2,255
 8247c38:	1080201c 	xori	r2,r2,128
 8247c3c:	10bfe004 	addi	r2,r2,-128
 8247c40:	1885883a 	add	r2,r3,r2
 8247c44:	10bff404 	addi	r2,r2,-48
 8247c48:	e0bffc0d 	sth	r2,-16(fp)
      }
      cp++;
 8247c4c:	e0bffa17 	ldw	r2,-24(fp)
 8247c50:	10800044 	addi	r2,r2,1
 8247c54:	e0bffa15 	stw	r2,-24(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
   int n = 0;
   unsigned short v = 0;
   dw = 0;
   while(*cp)
 8247c58:	e0bffa17 	ldw	r2,-24(fp)
 8247c5c:	10800003 	ldbu	r2,0(r2)
 8247c60:	10803fcc 	andi	r2,r2,255
 8247c64:	1080201c 	xori	r2,r2,128
 8247c68:	10bfe004 	addi	r2,r2,-128
 8247c6c:	103fc91e 	bne	r2,zero,8247b94 <convert_ip+0x30>
      {
         v = (v * 10) + (*cp - '0');
      }
      cp++;
   }
   lpb[n] = (unsigned char) v;
 8247c70:	e0bffb17 	ldw	r2,-20(fp)
 8247c74:	e0fffd17 	ldw	r3,-12(fp)
 8247c78:	1885883a 	add	r2,r3,r2
 8247c7c:	e0fffc0b 	ldhu	r3,-16(fp)
 8247c80:	10c00005 	stb	r3,0(r2)
   return dw;
 8247c84:	e0bffe17 	ldw	r2,-8(fp)
}  /* convert_ip() */
 8247c88:	e037883a 	mov	sp,fp
 8247c8c:	df000017 	ldw	fp,0(sp)
 8247c90:	dec00104 	addi	sp,sp,4
 8247c94:	f800283a 	ret

08247c98 <tcp_cksum>:
 * RETURNS: 
 */

unshort
tcp_cksum(struct ip * pip)
{
 8247c98:	defff704 	addi	sp,sp,-36
 8247c9c:	dfc00815 	stw	ra,32(sp)
 8247ca0:	df000715 	stw	fp,28(sp)
 8247ca4:	df000704 	addi	fp,sp,28
 8247ca8:	e13fff15 	stw	r4,-4(fp)
   unshort  oldsum;
   unshort  newsum;
   struct tcphdr * tp;

#ifdef MUTE_WARNS    /* stifle compiler warnings */
   tcpdata = (char *)NULL;
 8247cac:	e03ffa15 	stw	zero,-24(fp)
#endif   /* MUTE_WARNS */

   IN_PROFILER(PF_TSUM, PF_ENTRY);

   oddchar = 0;
 8247cb0:	e03ffb05 	stb	zero,-20(fp)

   iphlen = (unshort)ip_hlen(pip);
 8247cb4:	e0bfff17 	ldw	r2,-4(fp)
 8247cb8:	10800003 	ldbu	r2,0(r2)
 8247cbc:	10803fcc 	andi	r2,r2,255
 8247cc0:	108003cc 	andi	r2,r2,15
 8247cc4:	1085883a 	add	r2,r2,r2
 8247cc8:	1085883a 	add	r2,r2,r2
 8247ccc:	e0bffc0d 	sth	r2,-16(fp)
   tcplen = htons(pip->ip_len) - iphlen;
 8247cd0:	e0bfff17 	ldw	r2,-4(fp)
 8247cd4:	1080008b 	ldhu	r2,2(r2)
 8247cd8:	10bfffcc 	andi	r2,r2,65535
 8247cdc:	1004d23a 	srli	r2,r2,8
 8247ce0:	1007883a 	mov	r3,r2
 8247ce4:	e0bfff17 	ldw	r2,-4(fp)
 8247ce8:	1080008b 	ldhu	r2,2(r2)
 8247cec:	10bfffcc 	andi	r2,r2,65535
 8247cf0:	1004923a 	slli	r2,r2,8
 8247cf4:	1884b03a 	or	r2,r3,r2
 8247cf8:	1007883a 	mov	r3,r2
 8247cfc:	e0bffc0b 	ldhu	r2,-16(fp)
 8247d00:	1885c83a 	sub	r2,r3,r2
 8247d04:	e0bff90d 	sth	r2,-28(fp)

   tp = (struct tcphdr*)ip_data(pip);     /* get TCP header */
 8247d08:	e0bfff17 	ldw	r2,-4(fp)
 8247d0c:	10800003 	ldbu	r2,0(r2)
 8247d10:	10803fcc 	andi	r2,r2,255
 8247d14:	108003cc 	andi	r2,r2,15
 8247d18:	1085883a 	add	r2,r2,r2
 8247d1c:	1085883a 	add	r2,r2,r2
 8247d20:	1007883a 	mov	r3,r2
 8247d24:	e0bfff17 	ldw	r2,-4(fp)
 8247d28:	10c5883a 	add	r2,r2,r3
 8247d2c:	e0bffd15 	stw	r2,-12(fp)
   oldsum = tp->th_sum;       /* Save passed checksum */
 8247d30:	e0bffd17 	ldw	r2,-12(fp)
 8247d34:	1080040b 	ldhu	r2,16(r2)
 8247d38:	e0bffe0d 	sth	r2,-8(fp)
    * cannot overflow a 16 bit field) and put them in the cksum field. 
    * We include the IP addresses by passing them to the lower level 
    * fast sum routine. This results in their values being factored into 
    * the sum and the cksum field contributes zero.
    */
   tp->th_sum = htons(tcplen + 6);
 8247d3c:	e0bff90b 	ldhu	r2,-28(fp)
 8247d40:	10800184 	addi	r2,r2,6
 8247d44:	1005d23a 	srai	r2,r2,8
 8247d48:	10803fcc 	andi	r2,r2,255
 8247d4c:	1007883a 	mov	r3,r2
 8247d50:	e0bff90b 	ldhu	r2,-28(fp)
 8247d54:	10800184 	addi	r2,r2,6
 8247d58:	1004923a 	slli	r2,r2,8
 8247d5c:	1884b03a 	or	r2,r3,r2
 8247d60:	1007883a 	mov	r3,r2
 8247d64:	e0bffd17 	ldw	r2,-12(fp)
 8247d68:	10c0040d 	sth	r3,16(r2)

   /* zero pad odd sized packets for checksumming */
   if (tcplen & 1)   
 8247d6c:	e0bff90b 	ldhu	r2,-28(fp)
 8247d70:	1080004c 	andi	r2,r2,1
 8247d74:	10000e26 	beq	r2,zero,8247db0 <tcp_cksum+0x118>
   {
      tcpdata = ((char*)pip) + iphlen + tcplen;    /* end of packet */
 8247d78:	e0fffc0b 	ldhu	r3,-16(fp)
 8247d7c:	e0bff90b 	ldhu	r2,-28(fp)
 8247d80:	1885883a 	add	r2,r3,r2
 8247d84:	e0ffff17 	ldw	r3,-4(fp)
 8247d88:	1885883a 	add	r2,r3,r2
 8247d8c:	e0bffa15 	stw	r2,-24(fp)
      oddchar = *tcpdata;
 8247d90:	e0bffa17 	ldw	r2,-24(fp)
 8247d94:	10800003 	ldbu	r2,0(r2)
 8247d98:	e0bffb05 	stb	r2,-20(fp)
      *tcpdata = '\0';        /* zero out pad byte */
 8247d9c:	e0bffa17 	ldw	r2,-24(fp)
 8247da0:	10000005 	stb	zero,0(r2)
      tcplen++;               /* bump length to pass to cksum() */
 8247da4:	e0bff90b 	ldhu	r2,-28(fp)
 8247da8:	10800044 	addi	r2,r2,1
 8247dac:	e0bff90d 	sth	r2,-28(fp)

   /* Pass a pointer to the beginning of the IP address area into the IP header
    * the the low level sum routine. Add the size of these two IP addresses to
    * the length, and convert the length to 16 bit words.
    */
   newsum = ~cksum(((char*)tp) - 8, (tcplen + 8) >> 1);
 8247db0:	e0bffd17 	ldw	r2,-12(fp)
 8247db4:	10fffe04 	addi	r3,r2,-8
 8247db8:	e0bff90b 	ldhu	r2,-28(fp)
 8247dbc:	10800204 	addi	r2,r2,8
 8247dc0:	1005d07a 	srai	r2,r2,1
 8247dc4:	100b883a 	mov	r5,r2
 8247dc8:	1809883a 	mov	r4,r3
 8247dcc:	82287b40 	call	82287b4 <cksum>
 8247dd0:	0084303a 	nor	r2,zero,r2
 8247dd4:	e0bffb8d 	sth	r2,-18(fp)

   /* If the old checksum is 0xffff, but the actual checksum is 0x0000,
    * declare that to be a match.
    */
   if ((newsum != oldsum) && (oldsum == 0xffff) && (newsum == 0x0000))
 8247dd8:	e0fffb8b 	ldhu	r3,-18(fp)
 8247ddc:	e0bffe0b 	ldhu	r2,-8(fp)
 8247de0:	18800726 	beq	r3,r2,8247e00 <tcp_cksum+0x168>
 8247de4:	e0fffe0b 	ldhu	r3,-8(fp)
 8247de8:	00bfffd4 	movui	r2,65535
 8247dec:	1880041e 	bne	r3,r2,8247e00 <tcp_cksum+0x168>
 8247df0:	e0bffb8b 	ldhu	r2,-18(fp)
 8247df4:	1000021e 	bne	r2,zero,8247e00 <tcp_cksum+0x168>
      newsum = 0xffff;
 8247df8:	00bfffc4 	movi	r2,-1
 8247dfc:	e0bffb8d 	sth	r2,-18(fp)

   /* restore what we clobbered */
   tp->th_sum = oldsum;       /* put back passed checksum */
 8247e00:	e0bffd17 	ldw	r2,-12(fp)
 8247e04:	e0fffe0b 	ldhu	r3,-8(fp)
 8247e08:	10c0040d 	sth	r3,16(r2)
   if (oddchar)
 8247e0c:	e0bffb07 	ldb	r2,-20(fp)
 8247e10:	10000326 	beq	r2,zero,8247e20 <tcp_cksum+0x188>
      *tcpdata = oddchar;     /* restore odd byte if we zeroed it */
 8247e14:	e0bffa17 	ldw	r2,-24(fp)
 8247e18:	e0fffb03 	ldbu	r3,-20(fp)
 8247e1c:	10c00005 	stb	r3,0(r2)

   IN_PROFILER(PF_TSUM, PF_EXIT);

   return newsum;
 8247e20:	e0bffb8b 	ldhu	r2,-18(fp)
}
 8247e24:	e037883a 	mov	sp,fp
 8247e28:	dfc00117 	ldw	ra,4(sp)
 8247e2c:	df000017 	ldw	fp,0(sp)
 8247e30:	dec00204 	addi	sp,sp,8
 8247e34:	f800283a 	ret

08247e38 <in_pcballoc>:
 */

int
in_pcballoc(struct socket * so, 
   struct inpcb * head)
{
 8247e38:	defffb04 	addi	sp,sp,-20
 8247e3c:	dfc00415 	stw	ra,16(sp)
 8247e40:	df000315 	stw	fp,12(sp)
 8247e44:	df000304 	addi	fp,sp,12
 8247e48:	e13ffe15 	stw	r4,-8(fp)
 8247e4c:	e17fff15 	stw	r5,-4(fp)
   struct inpcb * inp;

   inp = INP_ALLOC (sizeof (*inp));
 8247e50:	01000b04 	movi	r4,44
 8247e54:	822e16c0 	call	822e16c <npalloc>
 8247e58:	e0bffd15 	stw	r2,-12(fp)
   if (inp == 0)
 8247e5c:	e0bffd17 	ldw	r2,-12(fp)
 8247e60:	1000021e 	bne	r2,zero,8247e6c <in_pcballoc+0x34>
      return ENOMEM;
 8247e64:	00800304 	movi	r2,12
 8247e68:	00001006 	br	8247eac <in_pcballoc+0x74>
   inp->inp_head = head;
 8247e6c:	e0bffd17 	ldw	r2,-12(fp)
 8247e70:	e0ffff17 	ldw	r3,-4(fp)
 8247e74:	10c00215 	stw	r3,8(r2)
   inp->inp_socket = so;
 8247e78:	e0bffd17 	ldw	r2,-12(fp)
 8247e7c:	e0fffe17 	ldw	r3,-8(fp)
 8247e80:	10c00815 	stw	r3,32(r2)

   /* Set Path MTU to a very small default. It should get expanded 
    * later by v4 or v6 specific SYN code. We don't want it zero 
    * in case it doesn't get expanded promptly.
    */
   inp->inp_pmtu = 512;
 8247e84:	e0bffd17 	ldw	r2,-12(fp)
 8247e88:	00c08004 	movi	r3,512
 8247e8c:	10c00615 	stw	r3,24(r2)
   insque(inp, head);
 8247e90:	e17fff17 	ldw	r5,-4(fp)
 8247e94:	e13ffd17 	ldw	r4,-12(fp)
 8247e98:	822ec900 	call	822ec90 <insque>
   so->so_pcb = inp;
 8247e9c:	e0bffe17 	ldw	r2,-8(fp)
 8247ea0:	e0fffd17 	ldw	r3,-12(fp)
 8247ea4:	10c00115 	stw	r3,4(r2)
   return 0;
 8247ea8:	0005883a 	mov	r2,zero
}
 8247eac:	e037883a 	mov	sp,fp
 8247eb0:	dfc00117 	ldw	ra,4(sp)
 8247eb4:	df000017 	ldw	fp,0(sp)
 8247eb8:	dec00204 	addi	sp,sp,8
 8247ebc:	f800283a 	ret

08247ec0 <in_pcbdetach>:
 * RETURNS: 
 */

void
in_pcbdetach(struct inpcb * inp)
{
 8247ec0:	defffc04 	addi	sp,sp,-16
 8247ec4:	dfc00315 	stw	ra,12(sp)
 8247ec8:	df000215 	stw	fp,8(sp)
 8247ecc:	df000204 	addi	fp,sp,8
 8247ed0:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  inp->inp_socket;
 8247ed4:	e0bfff17 	ldw	r2,-4(fp)
 8247ed8:	10800817 	ldw	r2,32(r2)
 8247edc:	e0bffe15 	stw	r2,-8(fp)

   so->so_pcb = 0;
 8247ee0:	e0bffe17 	ldw	r2,-8(fp)
 8247ee4:	10000115 	stw	zero,4(r2)
   sofree(so);
 8247ee8:	e13ffe17 	ldw	r4,-8(fp)
 8247eec:	8231d080 	call	8231d08 <sofree>
   remque(inp);
 8247ef0:	e13fff17 	ldw	r4,-4(fp)
 8247ef4:	822ec200 	call	822ec20 <remque>
   INP_FREE (inp);
 8247ef8:	e13fff17 	ldw	r4,-4(fp)
 8247efc:	822e1a00 	call	822e1a0 <npfree>
}
 8247f00:	0001883a 	nop
 8247f04:	e037883a 	mov	sp,fp
 8247f08:	dfc00117 	ldw	ra,4(sp)
 8247f0c:	df000017 	ldw	fp,0(sp)
 8247f10:	dec00204 	addi	sp,sp,8
 8247f14:	f800283a 	ret

08247f18 <in_pcbbind>:

int
in_pcbbind(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 8247f18:	defff504 	addi	sp,sp,-44
 8247f1c:	dfc00a15 	stw	ra,40(sp)
 8247f20:	df000915 	stw	fp,36(sp)
 8247f24:	df000904 	addi	fp,sp,36
 8247f28:	e13ffe15 	stw	r4,-8(fp)
 8247f2c:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so =  inp->inp_socket;
 8247f30:	e0bffe17 	ldw	r2,-8(fp)
 8247f34:	10800817 	ldw	r2,32(r2)
 8247f38:	e0bffb15 	stw	r2,-20(fp)
   struct inpcb * head  =  inp->inp_head;
 8247f3c:	e0bffe17 	ldw	r2,-8(fp)
 8247f40:	10800217 	ldw	r2,8(r2)
 8247f44:	e0bffc15 	stw	r2,-16(fp)
   struct sockaddr_in * sin;
   u_short  lport =  0;
 8247f48:	e03ff90d 	sth	zero,-28(fp)


   if (inp->inp_lport || inp->inp_laddr.s_addr != INADDR_ANY)
 8247f4c:	e0bffe17 	ldw	r2,-8(fp)
 8247f50:	1080078b 	ldhu	r2,30(r2)
 8247f54:	10bfffcc 	andi	r2,r2,65535
 8247f58:	1000031e 	bne	r2,zero,8247f68 <in_pcbbind+0x50>
 8247f5c:	e0bffe17 	ldw	r2,-8(fp)
 8247f60:	10800417 	ldw	r2,16(r2)
 8247f64:	10000226 	beq	r2,zero,8247f70 <in_pcbbind+0x58>
      return (EINVAL);
 8247f68:	00800584 	movi	r2,22
 8247f6c:	00006906 	br	8248114 <in_pcbbind+0x1fc>
   if (nam == 0)
 8247f70:	e0bfff17 	ldw	r2,-4(fp)
 8247f74:	10003926 	beq	r2,zero,824805c <in_pcbbind+0x144>
      goto noname;
   sin = mtod(nam, struct sockaddr_in *);
 8247f78:	e0bfff17 	ldw	r2,-4(fp)
 8247f7c:	10800317 	ldw	r2,12(r2)
 8247f80:	e0bffd15 	stw	r2,-12(fp)
   /*
    * removed test here for "if (nam->m_len != sizeof (*sin))"
    * since it really complicatges supporting dual IPv4/v6, and 
    * the 2.0 stack now checks this in t_bind(). -JB-
    */
   if (sin->sin_addr.s_addr != INADDR_ANY) 
 8247f84:	e0bffd17 	ldw	r2,-12(fp)
 8247f88:	10800117 	ldw	r2,4(r2)
 8247f8c:	10000a26 	beq	r2,zero,8247fb8 <in_pcbbind+0xa0>
   {
      if (ip_mymach(sin->sin_addr.s_addr) != sin->sin_addr.s_addr)
 8247f90:	e0bffd17 	ldw	r2,-12(fp)
 8247f94:	10800117 	ldw	r2,4(r2)
 8247f98:	1009883a 	mov	r4,r2
 8247f9c:	824099c0 	call	824099c <ip_mymach>
 8247fa0:	1007883a 	mov	r3,r2
 8247fa4:	e0bffd17 	ldw	r2,-12(fp)
 8247fa8:	10800117 	ldw	r2,4(r2)
 8247fac:	18800226 	beq	r3,r2,8247fb8 <in_pcbbind+0xa0>
      return (EADDRNOTAVAIL);
 8247fb0:	00801f44 	movi	r2,125
 8247fb4:	00005706 	br	8248114 <in_pcbbind+0x1fc>
   }
   lport = sin->sin_port;
 8247fb8:	e0bffd17 	ldw	r2,-12(fp)
 8247fbc:	1080008b 	ldhu	r2,2(r2)
 8247fc0:	e0bff90d 	sth	r2,-28(fp)
   if (lport) 
 8247fc4:	e0bff90b 	ldhu	r2,-28(fp)
 8247fc8:	10001f26 	beq	r2,zero,8248048 <in_pcbbind+0x130>
   {
      int   wild  =  0;
 8247fcc:	e03ffa15 	stw	zero,-24(fp)

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
 8247fd0:	e0bffb17 	ldw	r2,-20(fp)
 8247fd4:	10800417 	ldw	r2,16(r2)
 8247fd8:	1080010c 	andi	r2,r2,4
 8247fdc:	10000c1e 	bne	r2,zero,8248010 <in_pcbbind+0xf8>
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
 8247fe0:	e0bffb17 	ldw	r2,-20(fp)
 8247fe4:	10800217 	ldw	r2,8(r2)
 8247fe8:	1080010b 	ldhu	r2,4(r2)
 8247fec:	10bfffcc 	andi	r2,r2,65535
 8247ff0:	1080010c 	andi	r2,r2,4
   if (lport) 
   {
      int   wild  =  0;

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
 8247ff4:	10000426 	beq	r2,zero,8248008 <in_pcbbind+0xf0>
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
          (so->so_options & SO_ACCEPTCONN) == 0))
 8247ff8:	e0bffb17 	ldw	r2,-20(fp)
 8247ffc:	10800417 	ldw	r2,16(r2)
 8248000:	1080008c 	andi	r2,r2,2
   {
      int   wild  =  0;

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
 8248004:	1000021e 	bne	r2,zero,8248010 <in_pcbbind+0xf8>
          (so->so_options & SO_ACCEPTCONN) == 0))
      {
         wild = INPLOOKUP_WILDCARD;
 8248008:	00800044 	movi	r2,1
 824800c:	e0bffa15 	stw	r2,-24(fp)
      }
      if (in_pcblookup(head,
 8248010:	e0bffd17 	ldw	r2,-12(fp)
 8248014:	11000117 	ldw	r4,4(r2)
 8248018:	e0bff90b 	ldhu	r2,-28(fp)
 824801c:	e0fffa17 	ldw	r3,-24(fp)
 8248020:	d8c00115 	stw	r3,4(sp)
 8248024:	d8800015 	stw	r2,0(sp)
 8248028:	200f883a 	mov	r7,r4
 824802c:	000d883a 	mov	r6,zero
 8248030:	000b883a 	mov	r5,zero
 8248034:	e13ffc17 	ldw	r4,-16(fp)
 8248038:	824846c0 	call	824846c <in_pcblookup>
 824803c:	10000226 	beq	r2,zero,8248048 <in_pcbbind+0x130>
          0L, 0, sin->sin_addr.s_addr, lport, wild))
      {
         return (EADDRINUSE);
 8248040:	00801c04 	movi	r2,112
 8248044:	00003306 	br	8248114 <in_pcbbind+0x1fc>
      }
   }
   inp->inp_laddr = sin->sin_addr;
 8248048:	e0bffe17 	ldw	r2,-8(fp)
 824804c:	e0fffd17 	ldw	r3,-12(fp)
 8248050:	18c00117 	ldw	r3,4(r3)
 8248054:	10c00415 	stw	r3,16(r2)
 8248058:	00000106 	br	8248060 <in_pcbbind+0x148>


   if (inp->inp_lport || inp->inp_laddr.s_addr != INADDR_ANY)
      return (EINVAL);
   if (nam == 0)
      goto noname;
 824805c:	0001883a 	nop
         return (EADDRINUSE);
      }
   }
   inp->inp_laddr = sin->sin_addr;
noname:
   if (lport == 0)
 8248060:	e0bff90b 	ldhu	r2,-28(fp)
 8248064:	1000271e 	bne	r2,zero,8248104 <in_pcbbind+0x1ec>
   {
      do 
      {
         if (head->inp_lport++ < IPPORT_RESERVED ||
 8248068:	e0bffc17 	ldw	r2,-16(fp)
 824806c:	1080078b 	ldhu	r2,30(r2)
 8248070:	10c00044 	addi	r3,r2,1
 8248074:	1809883a 	mov	r4,r3
 8248078:	e0fffc17 	ldw	r3,-16(fp)
 824807c:	1900078d 	sth	r4,30(r3)
 8248080:	10bfffcc 	andi	r2,r2,65535
 8248084:	10810030 	cmpltui	r2,r2,1024
 8248088:	1000051e 	bne	r2,zero,82480a0 <in_pcbbind+0x188>
             head->inp_lport > IPPORT_USERRESERVED)
 824808c:	e0bffc17 	ldw	r2,-16(fp)
 8248090:	1080078b 	ldhu	r2,30(r2)
noname:
   if (lport == 0)
   {
      do 
      {
         if (head->inp_lport++ < IPPORT_RESERVED ||
 8248094:	10bfffcc 	andi	r2,r2,65535
 8248098:	1084e270 	cmpltui	r2,r2,5001
 824809c:	1000031e 	bne	r2,zero,82480ac <in_pcbbind+0x194>
             head->inp_lport > IPPORT_USERRESERVED)
         {
            head->inp_lport = IPPORT_RESERVED;
 82480a0:	e0bffc17 	ldw	r2,-16(fp)
 82480a4:	00c10004 	movi	r3,1024
 82480a8:	10c0078d 	sth	r3,30(r2)
         }
         lport = htons(head->inp_lport);
 82480ac:	e0bffc17 	ldw	r2,-16(fp)
 82480b0:	1080078b 	ldhu	r2,30(r2)
 82480b4:	10bfffcc 	andi	r2,r2,65535
 82480b8:	1004d23a 	srli	r2,r2,8
 82480bc:	1007883a 	mov	r3,r2
 82480c0:	e0bffc17 	ldw	r2,-16(fp)
 82480c4:	1080078b 	ldhu	r2,30(r2)
 82480c8:	10bfffcc 	andi	r2,r2,65535
 82480cc:	1004923a 	slli	r2,r2,8
 82480d0:	1884b03a 	or	r2,r3,r2
 82480d4:	e0bff90d 	sth	r2,-28(fp)
      } while(in_pcblookup(head, 0L, 0, inp->inp_laddr.s_addr, lport, 0));
 82480d8:	e0bffe17 	ldw	r2,-8(fp)
 82480dc:	10c00417 	ldw	r3,16(r2)
 82480e0:	e0bff90b 	ldhu	r2,-28(fp)
 82480e4:	d8000115 	stw	zero,4(sp)
 82480e8:	d8800015 	stw	r2,0(sp)
 82480ec:	180f883a 	mov	r7,r3
 82480f0:	000d883a 	mov	r6,zero
 82480f4:	000b883a 	mov	r5,zero
 82480f8:	e13ffc17 	ldw	r4,-16(fp)
 82480fc:	824846c0 	call	824846c <in_pcblookup>
 8248100:	103fd91e 	bne	r2,zero,8248068 <in_pcbbind+0x150>
   }
   inp->inp_lport = lport;
 8248104:	e0bffe17 	ldw	r2,-8(fp)
 8248108:	e0fff90b 	ldhu	r3,-28(fp)
 824810c:	10c0078d 	sth	r3,30(r2)
   return (0);
 8248110:	0005883a 	mov	r2,zero
}
 8248114:	e037883a 	mov	sp,fp
 8248118:	dfc00117 	ldw	ra,4(sp)
 824811c:	df000017 	ldw	fp,0(sp)
 8248120:	dec00204 	addi	sp,sp,8
 8248124:	f800283a 	ret

08248128 <in_pcbconnect>:
 */

int
in_pcbconnect(struct inpcb * inp, 
   struct mbuf *  nam)
{
 8248128:	defff604 	addi	sp,sp,-40
 824812c:	dfc00915 	stw	ra,36(sp)
 8248130:	df000815 	stw	fp,32(sp)
 8248134:	df000804 	addi	fp,sp,32
 8248138:	e13ffe15 	stw	r4,-8(fp)
 824813c:	e17fff15 	stw	r5,-4(fp)
   unsigned long ifaddr;
   struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 8248140:	e0bfff17 	ldw	r2,-4(fp)
 8248144:	10800317 	ldw	r2,12(r2)
 8248148:	e0bffb15 	stw	r2,-20(fp)

   if (nam->m_len < sizeof (*sin))
 824814c:	e0bfff17 	ldw	r2,-4(fp)
 8248150:	10800217 	ldw	r2,8(r2)
 8248154:	10800428 	cmpgeui	r2,r2,16
 8248158:	1000021e 	bne	r2,zero,8248164 <in_pcbconnect+0x3c>
      return (EINVAL);
 824815c:	00800584 	movi	r2,22
 8248160:	00006406 	br	82482f4 <in_pcbconnect+0x1cc>
   if (sin->sin_family != AF_INET)
 8248164:	e0bffb17 	ldw	r2,-20(fp)
 8248168:	1080000b 	ldhu	r2,0(r2)
 824816c:	10bfffcc 	andi	r2,r2,65535
 8248170:	10a0001c 	xori	r2,r2,32768
 8248174:	10a00004 	addi	r2,r2,-32768
 8248178:	108000a0 	cmpeqi	r2,r2,2
 824817c:	1000021e 	bne	r2,zero,8248188 <in_pcbconnect+0x60>
      return (EAFNOSUPPORT);
 8248180:	00801a84 	movi	r2,106
 8248184:	00005b06 	br	82482f4 <in_pcbconnect+0x1cc>
   if (sin->sin_port == 0)
 8248188:	e0bffb17 	ldw	r2,-20(fp)
 824818c:	1080008b 	ldhu	r2,2(r2)
 8248190:	10bfffcc 	andi	r2,r2,65535
 8248194:	1000021e 	bne	r2,zero,82481a0 <in_pcbconnect+0x78>
      return (EADDRNOTAVAIL);
 8248198:	00801f44 	movi	r2,125
 824819c:	00005506 	br	82482f4 <in_pcbconnect+0x1cc>
    * use the primary local address.
    * If the supplied address is INADDR_BROADCAST,
    * and the primary interface supports broadcast,
    * choose the broadcast address for that interface.
    */
   if (sin->sin_addr.s_addr == INADDR_ANY)
 82481a0:	e0bffb17 	ldw	r2,-20(fp)
 82481a4:	10800117 	ldw	r2,4(r2)
 82481a8:	10000d1e 	bne	r2,zero,82481e0 <in_pcbconnect+0xb8>
   {
      if (inp && inp->ifp)
 82481ac:	e0bffe17 	ldw	r2,-8(fp)
 82481b0:	10000926 	beq	r2,zero,82481d8 <in_pcbconnect+0xb0>
 82481b4:	e0bffe17 	ldw	r2,-8(fp)
 82481b8:	10800a17 	ldw	r2,40(r2)
 82481bc:	10000626 	beq	r2,zero,82481d8 <in_pcbconnect+0xb0>
         sin->sin_addr.s_addr = inp->ifp->n_ipaddr;
 82481c0:	e0bffe17 	ldw	r2,-8(fp)
 82481c4:	10800a17 	ldw	r2,40(r2)
 82481c8:	10c00a17 	ldw	r3,40(r2)
 82481cc:	e0bffb17 	ldw	r2,-20(fp)
 82481d0:	10c00115 	stw	r3,4(r2)
 82481d4:	00000806 	br	82481f8 <in_pcbconnect+0xd0>
      else
         return (EADDRNOTAVAIL);
 82481d8:	00801f44 	movi	r2,125
 82481dc:	00004506 	br	82482f4 <in_pcbconnect+0x1cc>
   }
   else if (sin->sin_addr.s_addr == INADDR_BROADCAST)
 82481e0:	e0bffb17 	ldw	r2,-20(fp)
 82481e4:	10800117 	ldw	r2,4(r2)
 82481e8:	10bfffd8 	cmpnei	r2,r2,-1
 82481ec:	1000021e 	bne	r2,zero,82481f8 <in_pcbconnect+0xd0>
      return (EADDRNOTAVAIL);
 82481f0:	00801f44 	movi	r2,125
 82481f4:	00003f06 	br	82482f4 <in_pcbconnect+0x1cc>


   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 82481f8:	e0bffe17 	ldw	r2,-8(fp)
 82481fc:	10800417 	ldw	r2,16(r2)
 8248200:	10000f1e 	bne	r2,zero,8248240 <in_pcbconnect+0x118>
   {
#ifdef MULTI_HOMED
      ip_addr hop1;     /* dummy for pass to iproute() */
      NET npnet;     /* the netport iface we can send on */
      /* call netport stack's IP routing */
      npnet = iproute(sin->sin_addr.s_addr, &hop1);
 8248204:	e0bffb17 	ldw	r2,-20(fp)
 8248208:	10800117 	ldw	r2,4(r2)
 824820c:	e0fffd04 	addi	r3,fp,-12
 8248210:	180b883a 	mov	r5,r3
 8248214:	1009883a 	mov	r4,r2
 8248218:	8240ce80 	call	8240ce8 <iproute>
 824821c:	e0bffc15 	stw	r2,-16(fp)
      if (!npnet)
 8248220:	e0bffc17 	ldw	r2,-16(fp)
 8248224:	1000021e 	bne	r2,zero,8248230 <in_pcbconnect+0x108>
         return EADDRNOTAVAIL;
 8248228:	00801f44 	movi	r2,125
 824822c:	00003106 	br	82482f4 <in_pcbconnect+0x1cc>
      ifaddr = npnet->n_ipaddr;  /* local address for this host */
 8248230:	e0bffc17 	ldw	r2,-16(fp)
 8248234:	10800a17 	ldw	r2,40(r2)
 8248238:	e0bffa15 	stw	r2,-24(fp)
 824823c:	00000306 	br	824824c <in_pcbconnect+0x124>
#else    /* not netport MULTI_HOMED, use 0th (only) iface */
      ifaddr = nets[0]->n_ipaddr;
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */
 8248240:	e0bffe17 	ldw	r2,-8(fp)
 8248244:	10800417 	ldw	r2,16(r2)
 8248248:	e0bffa15 	stw	r2,-24(fp)

   if (in_pcblookup(inp->inp_head,
 824824c:	e0bffe17 	ldw	r2,-8(fp)
 8248250:	10c00217 	ldw	r3,8(r2)
 8248254:	e0bffb17 	ldw	r2,-20(fp)
 8248258:	11000117 	ldw	r4,4(r2)
       sin->sin_addr.s_addr,
       sin->sin_port,
 824825c:	e0bffb17 	ldw	r2,-20(fp)
 8248260:	1080008b 	ldhu	r2,2(r2)
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */

   if (in_pcblookup(inp->inp_head,
 8248264:	117fffcc 	andi	r5,r2,65535
       sin->sin_addr.s_addr,
       sin->sin_port,
       ifaddr,
       inp->inp_lport,
 8248268:	e0bffe17 	ldw	r2,-8(fp)
 824826c:	1080078b 	ldhu	r2,30(r2)
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */

   if (in_pcblookup(inp->inp_head,
 8248270:	10bfffcc 	andi	r2,r2,65535
 8248274:	d8000115 	stw	zero,4(sp)
 8248278:	d8800015 	stw	r2,0(sp)
 824827c:	e1fffa17 	ldw	r7,-24(fp)
 8248280:	280d883a 	mov	r6,r5
 8248284:	200b883a 	mov	r5,r4
 8248288:	1809883a 	mov	r4,r3
 824828c:	824846c0 	call	824846c <in_pcblookup>
 8248290:	10000226 	beq	r2,zero,824829c <in_pcbconnect+0x174>
       sin->sin_port,
       ifaddr,
       inp->inp_lport,
       0))
   {
      return (EADDRINUSE);
 8248294:	00801c04 	movi	r2,112
 8248298:	00001606 	br	82482f4 <in_pcbconnect+0x1cc>
   }
   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 824829c:	e0bffe17 	ldw	r2,-8(fp)
 82482a0:	10800417 	ldw	r2,16(r2)
 82482a4:	10000a1e 	bne	r2,zero,82482d0 <in_pcbconnect+0x1a8>
   {
      if (inp->inp_lport == 0)
 82482a8:	e0bffe17 	ldw	r2,-8(fp)
 82482ac:	1080078b 	ldhu	r2,30(r2)
 82482b0:	10bfffcc 	andi	r2,r2,65535
 82482b4:	1000031e 	bne	r2,zero,82482c4 <in_pcbconnect+0x19c>
         (void)in_pcbbind(inp, (struct mbuf *)0);
 82482b8:	000b883a 	mov	r5,zero
 82482bc:	e13ffe17 	ldw	r4,-8(fp)
 82482c0:	8247f180 	call	8247f18 <in_pcbbind>
      inp->inp_laddr.s_addr = ifaddr;
 82482c4:	e0bffe17 	ldw	r2,-8(fp)
 82482c8:	e0fffa17 	ldw	r3,-24(fp)
 82482cc:	10c00415 	stw	r3,16(r2)
   }
   inp->inp_faddr = sin->sin_addr;
 82482d0:	e0bffe17 	ldw	r2,-8(fp)
 82482d4:	e0fffb17 	ldw	r3,-20(fp)
 82482d8:	18c00117 	ldw	r3,4(r3)
 82482dc:	10c00315 	stw	r3,12(r2)
   inp->inp_fport = sin->sin_port;
 82482e0:	e0bffb17 	ldw	r2,-20(fp)
 82482e4:	10c0008b 	ldhu	r3,2(r2)
 82482e8:	e0bffe17 	ldw	r2,-8(fp)
 82482ec:	10c0070d 	sth	r3,28(r2)
   return 0;
 82482f0:	0005883a 	mov	r2,zero
}
 82482f4:	e037883a 	mov	sp,fp
 82482f8:	dfc00117 	ldw	ra,4(sp)
 82482fc:	df000017 	ldw	fp,0(sp)
 8248300:	dec00204 	addi	sp,sp,8
 8248304:	f800283a 	ret

08248308 <in_pcbdisconnect>:
 * RETURNS: 
 */

void
in_pcbdisconnect(struct inpcb * inp)
{
 8248308:	defffd04 	addi	sp,sp,-12
 824830c:	dfc00215 	stw	ra,8(sp)
 8248310:	df000115 	stw	fp,4(sp)
 8248314:	df000104 	addi	fp,sp,4
 8248318:	e13fff15 	stw	r4,-4(fp)

   inp->inp_faddr.s_addr = INADDR_ANY;
 824831c:	e0bfff17 	ldw	r2,-4(fp)
 8248320:	10000315 	stw	zero,12(r2)
   inp->inp_fport = 0;
 8248324:	e0bfff17 	ldw	r2,-4(fp)
 8248328:	1000070d 	sth	zero,28(r2)
   if (inp->inp_socket->so_state & SS_NOFDREF)
 824832c:	e0bfff17 	ldw	r2,-4(fp)
 8248330:	10800817 	ldw	r2,32(r2)
 8248334:	1080088b 	ldhu	r2,34(r2)
 8248338:	10bfffcc 	andi	r2,r2,65535
 824833c:	1080004c 	andi	r2,r2,1
 8248340:	10000226 	beq	r2,zero,824834c <in_pcbdisconnect+0x44>
      in_pcbdetach (inp);
 8248344:	e13fff17 	ldw	r4,-4(fp)
 8248348:	8247ec00 	call	8247ec0 <in_pcbdetach>
}
 824834c:	0001883a 	nop
 8248350:	e037883a 	mov	sp,fp
 8248354:	dfc00117 	ldw	ra,4(sp)
 8248358:	df000017 	ldw	fp,0(sp)
 824835c:	dec00204 	addi	sp,sp,8
 8248360:	f800283a 	ret

08248364 <in_setsockaddr>:
 */

void
in_setsockaddr(struct inpcb * inp, 
   struct mbuf *  nam)
{
 8248364:	defffb04 	addi	sp,sp,-20
 8248368:	dfc00415 	stw	ra,16(sp)
 824836c:	df000315 	stw	fp,12(sp)
 8248370:	df000304 	addi	fp,sp,12
 8248374:	e13ffe15 	stw	r4,-8(fp)
 8248378:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 824837c:	e0bfff17 	ldw	r2,-4(fp)
 8248380:	00c00404 	movi	r3,16
 8248384:	10c00215 	stw	r3,8(r2)
   sin = mtod(nam, struct sockaddr_in *);
 8248388:	e0bfff17 	ldw	r2,-4(fp)
 824838c:	10800317 	ldw	r2,12(r2)
 8248390:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 8248394:	01800404 	movi	r6,16
 8248398:	000b883a 	mov	r5,zero
 824839c:	e13ffd17 	ldw	r4,-12(fp)
 82483a0:	82031b40 	call	82031b4 <memset>
   sin->sin_family = AF_INET;
 82483a4:	e0bffd17 	ldw	r2,-12(fp)
 82483a8:	00c00084 	movi	r3,2
 82483ac:	10c0000d 	sth	r3,0(r2)
   sin->sin_port = inp->inp_lport;
 82483b0:	e0bffe17 	ldw	r2,-8(fp)
 82483b4:	10c0078b 	ldhu	r3,30(r2)
 82483b8:	e0bffd17 	ldw	r2,-12(fp)
 82483bc:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_laddr;
 82483c0:	e0bffd17 	ldw	r2,-12(fp)
 82483c4:	e0fffe17 	ldw	r3,-8(fp)
 82483c8:	18c00417 	ldw	r3,16(r3)
 82483cc:	10c00115 	stw	r3,4(r2)
}
 82483d0:	0001883a 	nop
 82483d4:	e037883a 	mov	sp,fp
 82483d8:	dfc00117 	ldw	ra,4(sp)
 82483dc:	df000017 	ldw	fp,0(sp)
 82483e0:	dec00204 	addi	sp,sp,8
 82483e4:	f800283a 	ret

082483e8 <in_setpeeraddr>:

void
in_setpeeraddr(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 82483e8:	defffb04 	addi	sp,sp,-20
 82483ec:	dfc00415 	stw	ra,16(sp)
 82483f0:	df000315 	stw	fp,12(sp)
 82483f4:	df000304 	addi	fp,sp,12
 82483f8:	e13ffe15 	stw	r4,-8(fp)
 82483fc:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 8248400:	e0bfff17 	ldw	r2,-4(fp)
 8248404:	00c00404 	movi	r3,16
 8248408:	10c00215 	stw	r3,8(r2)
   sin = mtod(nam, struct sockaddr_in *);
 824840c:	e0bfff17 	ldw	r2,-4(fp)
 8248410:	10800317 	ldw	r2,12(r2)
 8248414:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 8248418:	01800404 	movi	r6,16
 824841c:	000b883a 	mov	r5,zero
 8248420:	e13ffd17 	ldw	r4,-12(fp)
 8248424:	82031b40 	call	82031b4 <memset>
   sin->sin_family = AF_INET;
 8248428:	e0bffd17 	ldw	r2,-12(fp)
 824842c:	00c00084 	movi	r3,2
 8248430:	10c0000d 	sth	r3,0(r2)
   sin->sin_port = inp->inp_fport;
 8248434:	e0bffe17 	ldw	r2,-8(fp)
 8248438:	10c0070b 	ldhu	r3,28(r2)
 824843c:	e0bffd17 	ldw	r2,-12(fp)
 8248440:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_faddr;
 8248444:	e0bffd17 	ldw	r2,-12(fp)
 8248448:	e0fffe17 	ldw	r3,-8(fp)
 824844c:	18c00317 	ldw	r3,12(r3)
 8248450:	10c00115 	stw	r3,4(r2)
}
 8248454:	0001883a 	nop
 8248458:	e037883a 	mov	sp,fp
 824845c:	dfc00117 	ldw	ra,4(sp)
 8248460:	df000017 	ldw	fp,0(sp)
 8248464:	dec00204 	addi	sp,sp,8
 8248468:	f800283a 	ret

0824846c <in_pcblookup>:
   u_long   faddr, 
   unshort  xfport,
   u_long   laddr,
   unshort  xlport,
   int   flags)
{
 824846c:	defff504 	addi	sp,sp,-44
 8248470:	df000a15 	stw	fp,40(sp)
 8248474:	df000a04 	addi	fp,sp,40
 8248478:	e13ffb15 	stw	r4,-20(fp)
 824847c:	e17ffc15 	stw	r5,-16(fp)
 8248480:	3007883a 	mov	r3,r6
 8248484:	e1fffe15 	stw	r7,-8(fp)
 8248488:	e0800117 	ldw	r2,4(fp)
 824848c:	e0fffd0d 	sth	r3,-12(fp)
 8248490:	e0bfff0d 	sth	r2,-4(fp)
   struct inpcb * inp, *   match =  0;
 8248494:	e03ff715 	stw	zero,-36(fp)
   unshort  fport =  xfport; 
 8248498:	e0bffd0b 	ldhu	r2,-12(fp)
 824849c:	e0bffa0d 	sth	r2,-24(fp)
   unshort  lport =  xlport;
 82484a0:	e0bfff0b 	ldhu	r2,-4(fp)
 82484a4:	e0bffa8d 	sth	r2,-22(fp)
   int   matchwild   =  3;
 82484a8:	008000c4 	movi	r2,3
 82484ac:	e0bff815 	stw	r2,-32(fp)
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 82484b0:	e0bffb17 	ldw	r2,-20(fp)
 82484b4:	10800017 	ldw	r2,0(r2)
 82484b8:	e0bff615 	stw	r2,-40(fp)
 82484bc:	00004f06 	br	82485fc <in_pcblookup+0x190>
   {
      if (inp->inp_lport != lport)
 82484c0:	e0bff617 	ldw	r2,-40(fp)
 82484c4:	1080078b 	ldhu	r2,30(r2)
 82484c8:	10ffffcc 	andi	r3,r2,65535
 82484cc:	e0bffa8b 	ldhu	r2,-22(fp)
 82484d0:	1880401e 	bne	r3,r2,82485d4 <in_pcblookup+0x168>
         continue;

      /* Skip non IPv4 sockets */
      if(inp->inp_socket->so_domain != AF_INET)
 82484d4:	e0bff617 	ldw	r2,-40(fp)
 82484d8:	10800817 	ldw	r2,32(r2)
 82484dc:	10800517 	ldw	r2,20(r2)
 82484e0:	108000a0 	cmpeqi	r2,r2,2
 82484e4:	10003d26 	beq	r2,zero,82485dc <in_pcblookup+0x170>
         continue;

      wildcard = 0;
 82484e8:	e03ff915 	stw	zero,-28(fp)
      if (inp->inp_laddr.s_addr != INADDR_ANY) 
 82484ec:	e0bff617 	ldw	r2,-40(fp)
 82484f0:	10800417 	ldw	r2,16(r2)
 82484f4:	10000b26 	beq	r2,zero,8248524 <in_pcblookup+0xb8>
      {
         if (laddr == INADDR_ANY)
 82484f8:	e0bffe17 	ldw	r2,-8(fp)
 82484fc:	1000041e 	bne	r2,zero,8248510 <in_pcblookup+0xa4>
            wildcard++;
 8248500:	e0bff917 	ldw	r2,-28(fp)
 8248504:	10800044 	addi	r2,r2,1
 8248508:	e0bff915 	stw	r2,-28(fp)
 824850c:	00000a06 	br	8248538 <in_pcblookup+0xcc>
         else if (inp->inp_laddr.s_addr != laddr)
 8248510:	e0bff617 	ldw	r2,-40(fp)
 8248514:	10c00417 	ldw	r3,16(r2)
 8248518:	e0bffe17 	ldw	r2,-8(fp)
 824851c:	18800626 	beq	r3,r2,8248538 <in_pcblookup+0xcc>
            continue;
 8248520:	00003306 	br	82485f0 <in_pcblookup+0x184>
      }
      else 
      {
         if (laddr != INADDR_ANY)
 8248524:	e0bffe17 	ldw	r2,-8(fp)
 8248528:	10000326 	beq	r2,zero,8248538 <in_pcblookup+0xcc>
            wildcard++;
 824852c:	e0bff917 	ldw	r2,-28(fp)
 8248530:	10800044 	addi	r2,r2,1
 8248534:	e0bff915 	stw	r2,-28(fp)
      }
      if (inp->inp_faddr.s_addr != INADDR_ANY) 
 8248538:	e0bff617 	ldw	r2,-40(fp)
 824853c:	10800317 	ldw	r2,12(r2)
 8248540:	10001026 	beq	r2,zero,8248584 <in_pcblookup+0x118>
      {
         if (faddr == INADDR_ANY)
 8248544:	e0bffc17 	ldw	r2,-16(fp)
 8248548:	1000041e 	bne	r2,zero,824855c <in_pcblookup+0xf0>
            wildcard++;
 824854c:	e0bff917 	ldw	r2,-28(fp)
 8248550:	10800044 	addi	r2,r2,1
 8248554:	e0bff915 	stw	r2,-28(fp)
 8248558:	00000f06 	br	8248598 <in_pcblookup+0x12c>
         else if (inp->inp_faddr.s_addr != faddr ||
 824855c:	e0bff617 	ldw	r2,-40(fp)
 8248560:	10c00317 	ldw	r3,12(r2)
 8248564:	e0bffc17 	ldw	r2,-16(fp)
 8248568:	18801e1e 	bne	r3,r2,82485e4 <in_pcblookup+0x178>
             inp->inp_fport != fport)
 824856c:	e0bff617 	ldw	r2,-40(fp)
 8248570:	1080070b 	ldhu	r2,28(r2)
      }
      if (inp->inp_faddr.s_addr != INADDR_ANY) 
      {
         if (faddr == INADDR_ANY)
            wildcard++;
         else if (inp->inp_faddr.s_addr != faddr ||
 8248574:	10ffffcc 	andi	r3,r2,65535
 8248578:	e0bffa0b 	ldhu	r2,-24(fp)
 824857c:	18800626 	beq	r3,r2,8248598 <in_pcblookup+0x12c>
             inp->inp_fport != fport)
         {
            continue;
 8248580:	00001806 	br	82485e4 <in_pcblookup+0x178>
         }
      } else 
      {
         if (faddr != INADDR_ANY)
 8248584:	e0bffc17 	ldw	r2,-16(fp)
 8248588:	10000326 	beq	r2,zero,8248598 <in_pcblookup+0x12c>
            wildcard++;
 824858c:	e0bff917 	ldw	r2,-28(fp)
 8248590:	10800044 	addi	r2,r2,1
 8248594:	e0bff915 	stw	r2,-28(fp)
      }
      if (wildcard && (flags & INPLOOKUP_WILDCARD) == 0)
 8248598:	e0bff917 	ldw	r2,-28(fp)
 824859c:	10000326 	beq	r2,zero,82485ac <in_pcblookup+0x140>
 82485a0:	e0800217 	ldw	r2,8(fp)
 82485a4:	1080004c 	andi	r2,r2,1
 82485a8:	10001026 	beq	r2,zero,82485ec <in_pcblookup+0x180>
         continue;
      if (wildcard < matchwild) 
 82485ac:	e0fff917 	ldw	r3,-28(fp)
 82485b0:	e0bff817 	ldw	r2,-32(fp)
 82485b4:	18800e0e 	bge	r3,r2,82485f0 <in_pcblookup+0x184>
      {
         match = inp;
 82485b8:	e0bff617 	ldw	r2,-40(fp)
 82485bc:	e0bff715 	stw	r2,-36(fp)
         matchwild = wildcard;
 82485c0:	e0bff917 	ldw	r2,-28(fp)
 82485c4:	e0bff815 	stw	r2,-32(fp)
         if (matchwild == 0)
 82485c8:	e0bff817 	ldw	r2,-32(fp)
 82485cc:	10000f26 	beq	r2,zero,824860c <in_pcblookup+0x1a0>
 82485d0:	00000706 	br	82485f0 <in_pcblookup+0x184>
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
   {
      if (inp->inp_lport != lport)
         continue;
 82485d4:	0001883a 	nop
 82485d8:	00000506 	br	82485f0 <in_pcblookup+0x184>

      /* Skip non IPv4 sockets */
      if(inp->inp_socket->so_domain != AF_INET)
         continue;
 82485dc:	0001883a 	nop
 82485e0:	00000306 	br	82485f0 <in_pcblookup+0x184>
         if (faddr == INADDR_ANY)
            wildcard++;
         else if (inp->inp_faddr.s_addr != faddr ||
             inp->inp_fport != fport)
         {
            continue;
 82485e4:	0001883a 	nop
 82485e8:	00000106 	br	82485f0 <in_pcblookup+0x184>
      {
         if (faddr != INADDR_ANY)
            wildcard++;
      }
      if (wildcard && (flags & INPLOOKUP_WILDCARD) == 0)
         continue;
 82485ec:	0001883a 	nop
   unshort  fport =  xfport; 
   unshort  lport =  xlport;
   int   matchwild   =  3;
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 82485f0:	e0bff617 	ldw	r2,-40(fp)
 82485f4:	10800017 	ldw	r2,0(r2)
 82485f8:	e0bff615 	stw	r2,-40(fp)
 82485fc:	e0fff617 	ldw	r3,-40(fp)
 8248600:	e0bffb17 	ldw	r2,-20(fp)
 8248604:	18bfae1e 	bne	r3,r2,82484c0 <in_pcblookup+0x54>
 8248608:	00000106 	br	8248610 <in_pcblookup+0x1a4>
      if (wildcard < matchwild) 
      {
         match = inp;
         matchwild = wildcard;
         if (matchwild == 0)
            break;
 824860c:	0001883a 	nop
      }
   }
   if (match == NULL)
 8248610:	e0bff717 	ldw	r2,-36(fp)
 8248614:	1000021e 	bne	r2,zero,8248620 <in_pcblookup+0x1b4>
      return match;
 8248618:	e0bff717 	ldw	r2,-36(fp)
 824861c:	00002406 	br	82486b0 <in_pcblookup+0x244>

   if (head->inp_next == match)  /* got cache hit? */
 8248620:	e0bffb17 	ldw	r2,-20(fp)
 8248624:	10c00017 	ldw	r3,0(r2)
 8248628:	e0bff717 	ldw	r2,-36(fp)
 824862c:	1880041e 	bne	r3,r2,8248640 <in_pcblookup+0x1d4>
   {
      inpcb_cachehits++;
 8248630:	d0a0d217 	ldw	r2,-31928(gp)
 8248634:	10800044 	addi	r2,r2,1
 8248638:	d0a0d215 	stw	r2,-31928(gp)
 824863c:	00001b06 	br	82486ac <in_pcblookup+0x240>
   }
   else
   {
      inpcb_cachemiss++;
 8248640:	d0a0d317 	ldw	r2,-31924(gp)
 8248644:	10800044 	addi	r2,r2,1
 8248648:	d0a0d315 	stw	r2,-31924(gp)
      /* "cache" the match to be first checked next time. */
      match->inp_next->inp_prev = match->inp_prev; /*unlink match */
 824864c:	e0bff717 	ldw	r2,-36(fp)
 8248650:	10800017 	ldw	r2,0(r2)
 8248654:	e0fff717 	ldw	r3,-36(fp)
 8248658:	18c00117 	ldw	r3,4(r3)
 824865c:	10c00115 	stw	r3,4(r2)
      match->inp_prev->inp_next = match->inp_next;
 8248660:	e0bff717 	ldw	r2,-36(fp)
 8248664:	10800117 	ldw	r2,4(r2)
 8248668:	e0fff717 	ldw	r3,-36(fp)
 824866c:	18c00017 	ldw	r3,0(r3)
 8248670:	10c00015 	stw	r3,0(r2)

      /* relink match as head->inp_next */
      match->inp_next = head->inp_next;
 8248674:	e0bffb17 	ldw	r2,-20(fp)
 8248678:	10c00017 	ldw	r3,0(r2)
 824867c:	e0bff717 	ldw	r2,-36(fp)
 8248680:	10c00015 	stw	r3,0(r2)
      head->inp_next = match;
 8248684:	e0bffb17 	ldw	r2,-20(fp)
 8248688:	e0fff717 	ldw	r3,-36(fp)
 824868c:	10c00015 	stw	r3,0(r2)
      match->inp_prev = head;
 8248690:	e0bff717 	ldw	r2,-36(fp)
 8248694:	e0fffb17 	ldw	r3,-20(fp)
 8248698:	10c00115 	stw	r3,4(r2)
      match->inp_next->inp_prev = match;
 824869c:	e0bff717 	ldw	r2,-36(fp)
 82486a0:	10800017 	ldw	r2,0(r2)
 82486a4:	e0fff717 	ldw	r3,-36(fp)
 82486a8:	10c00115 	stw	r3,4(r2)
   }
   return (match);
 82486ac:	e0bff717 	ldw	r2,-36(fp)
}
 82486b0:	e037883a 	mov	sp,fp
 82486b4:	df000017 	ldw	fp,0(sp)
 82486b8:	dec00104 	addi	sp,sp,4
 82486bc:	f800283a 	ret

082486c0 <set_vfopen_error>:
 *
 * RETURNS: 
 */

void set_vfopen_error(int error)
{
 82486c0:	defffe04 	addi	sp,sp,-8
 82486c4:	df000115 	stw	fp,4(sp)
 82486c8:	df000104 	addi	fp,sp,4
 82486cc:	e13fff15 	stw	r4,-4(fp)
   vfopen_error = error;
 82486d0:	e0bfff17 	ldw	r2,-4(fp)
 82486d4:	d0a0d715 	stw	r2,-31908(gp)
}
 82486d8:	0001883a 	nop
 82486dc:	e037883a 	mov	sp,fp
 82486e0:	df000017 	ldw	fp,0(sp)
 82486e4:	dec00104 	addi	sp,sp,4
 82486e8:	f800283a 	ret

082486ec <get_vfopen_error>:
 *
 * RETURNS: 
 */

int get_vfopen_error()
{
 82486ec:	deffff04 	addi	sp,sp,-4
 82486f0:	df000015 	stw	fp,0(sp)
 82486f4:	d839883a 	mov	fp,sp
   return vfopen_error;
 82486f8:	d0a0d717 	ldw	r2,-31908(gp)
}
 82486fc:	e037883a 	mov	sp,fp
 8248700:	df000017 	ldw	fp,0(sp)
 8248704:	dec00104 	addi	sp,sp,4
 8248708:	f800283a 	ret

0824870c <vf_alloc_and_link_vop>:
 *
 * RETURNS: 
 */

VFILE * vf_alloc_and_link_vop()
{
 824870c:	defffd04 	addi	sp,sp,-12
 8248710:	dfc00215 	stw	ra,8(sp)
 8248714:	df000115 	stw	fp,4(sp)
 8248718:	df000104 	addi	fp,sp,4
   struct vfs_open * vop;

   /* enforce maximum number of simultaneously open files */
   if (vfs_open_files >= VFS_MAX_OPEN_FILES)
 824871c:	d0a0d917 	ldw	r2,-31900(gp)
 8248720:	10803ff0 	cmpltui	r2,r2,255
 8248724:	1000021e 	bne	r2,zero,8248730 <vf_alloc_and_link_vop+0x24>
   {
#ifdef VFS_VERBOSE
      dprintf("vfs_open_files too big (%ld) in vf_alloc_and_link_vop()\n",
       vfs_open_files);
#endif   /* VFS_VERBOSE */
      return NULL;
 8248728:	0005883a 	mov	r2,zero
 824872c:	00000e06 	br	8248768 <vf_alloc_and_link_vop+0x5c>
   }

   /* allocate a structure to represent the open file */
   vop = VFS_VFS_OPEN_ALLOC();
 8248730:	01000504 	movi	r4,20
 8248734:	822e16c0 	call	822e16c <npalloc>
 8248738:	e0bfff15 	stw	r2,-4(fp)

   /* if the allocation succeeded */
   if (vop)
 824873c:	e0bfff17 	ldw	r2,-4(fp)
 8248740:	10000826 	beq	r2,zero,8248764 <vf_alloc_and_link_vop+0x58>
   {
      /* add to the beginning of the list of open files */
      vop->next = vfiles;
 8248744:	d0e0d517 	ldw	r3,-31916(gp)
 8248748:	e0bfff17 	ldw	r2,-4(fp)
 824874c:	10c00015 	stw	r3,0(r2)
      vfiles = vop;
 8248750:	e0bfff17 	ldw	r2,-4(fp)
 8248754:	d0a0d515 	stw	r2,-31916(gp)
      /* increment the count of open files */
      vfs_open_files++;
 8248758:	d0a0d917 	ldw	r2,-31900(gp)
 824875c:	10800044 	addi	r2,r2,1
 8248760:	d0a0d915 	stw	r2,-31900(gp)
#ifdef VFS_VERBOSE
   else
      dprintf("VFS_VFS_OPEN_ALLOC() failed in vf_alloc_and_link_vop()\n");
#endif   /* VFS_VERBOSE */

   return vop;
 8248764:	e0bfff17 	ldw	r2,-4(fp)
}
 8248768:	e037883a 	mov	sp,fp
 824876c:	dfc00117 	ldw	ra,4(sp)
 8248770:	df000017 	ldw	fp,0(sp)
 8248774:	dec00204 	addi	sp,sp,8
 8248778:	f800283a 	ret

0824877c <vf_alloc_buffer>:
 *
 * RETURNS: 
 */

unsigned char * vf_alloc_buffer(unsigned long size)
{
 824877c:	defff904 	addi	sp,sp,-28
 8248780:	dfc00615 	stw	ra,24(sp)
 8248784:	df000515 	stw	fp,20(sp)
 8248788:	df000504 	addi	fp,sp,20
 824878c:	e13fff15 	stw	r4,-4(fp)
   unsigned int long_size,int_size;
#endif   /* MUTE_WARNS */

   /* make sure the requested allocation does not exceed the total
      memory space reserved for file buffers */
   if ((vfs_total_rw_space + size) > VFS_MAX_TOTAL_RW_SPACE)
 8248790:	d0e0da17 	ldw	r3,-31896(gp)
 8248794:	e0bfff17 	ldw	r2,-4(fp)
 8248798:	1885883a 	add	r2,r3,r2
 824879c:	00ffffd4 	movui	r3,65535
 82487a0:	1880022e 	bgeu	r3,r2,82487ac <vf_alloc_buffer+0x30>
      return NULL;
 82487a4:	0005883a 	mov	r2,zero
 82487a8:	00002106 	br	8248830 <vf_alloc_buffer+0xb4>
    * any bigger than what will fit in an unsigned int 
    */
#ifdef MUTE_WARNS
   /* the idiotic hoops you got to jump through to suppress compiler
      warnings */
   long_size   =  sizeof(unsigned   long);
 82487ac:	00800104 	movi	r2,4
 82487b0:	e0bffb15 	stw	r2,-20(fp)
   int_size = sizeof(unsigned int);
 82487b4:	00800104 	movi	r2,4
 82487b8:	e0bffc15 	stw	r2,-16(fp)
   if (long_size > int_size)
 82487bc:	e0bffb17 	ldw	r2,-20(fp)
 82487c0:	e0fffc17 	ldw	r3,-16(fp)
 82487c4:	1880102e 	bgeu	r3,r2,8248808 <vf_alloc_buffer+0x8c>
       * most systems where this "if" expression will evaluate to 
       * true (2 byte ints, 4 byte longs). if any of those upper bits 
       * are on in your requested size, you otta luck.
       */
#ifdef MUTE_WARNS
      switch (int_size)
 82487c8:	e0bffc17 	ldw	r2,-16(fp)
 82487cc:	108000a0 	cmpeqi	r2,r2,2
 82487d0:	10000826 	beq	r2,zero,82487f4 <vf_alloc_buffer+0x78>
#else
      switch (sizeof(unsigned int))
#endif   /* MUTE_WARNS */
      {
      case 2 :
         mem_mask = 0xffff0000;
 82487d4:	00bffff4 	movhi	r2,65535
 82487d8:	e0bffd15 	stw	r2,-12(fp)
         break;
 82487dc:	0001883a 	nop
         default :
            dtrap();    /* you have a weird compiler */
         return NULL;
      }

      if (size & mem_mask)
 82487e0:	e0ffff17 	ldw	r3,-4(fp)
 82487e4:	e0bffd17 	ldw	r2,-12(fp)
 82487e8:	1884703a 	and	r2,r3,r2
 82487ec:	10000626 	beq	r2,zero,8248808 <vf_alloc_buffer+0x8c>
 82487f0:	00000306 	br	8248800 <vf_alloc_buffer+0x84>
      {
      case 2 :
         mem_mask = 0xffff0000;
         break;
         default :
            dtrap();    /* you have a weird compiler */
 82487f4:	822d5940 	call	822d594 <dtrap>
         return NULL;
 82487f8:	0005883a 	mov	r2,zero
 82487fc:	00000c06 	br	8248830 <vf_alloc_buffer+0xb4>
      }

      if (size & mem_mask)
         return NULL;
 8248800:	0005883a 	mov	r2,zero
 8248804:	00000a06 	br	8248830 <vf_alloc_buffer+0xb4>
   }

   /* try to allocate a buffer of the requested size */
   buffer = (unsigned char *) npalloc((unsigned int) size);
 8248808:	e13fff17 	ldw	r4,-4(fp)
 824880c:	822e16c0 	call	822e16c <npalloc>
 8248810:	e0bffe15 	stw	r2,-8(fp)

   /* if the allocation succeeded */
   if (buffer)
 8248814:	e0bffe17 	ldw	r2,-8(fp)
 8248818:	10000426 	beq	r2,zero,824882c <vf_alloc_buffer+0xb0>
   {
      /* add size to the count of total buffer space allocated */
      vfs_total_rw_space += size;
 824881c:	d0e0da17 	ldw	r3,-31896(gp)
 8248820:	e0bfff17 	ldw	r2,-4(fp)
 8248824:	1885883a 	add	r2,r3,r2
 8248828:	d0a0da15 	stw	r2,-31896(gp)
   }

   return buffer;
 824882c:	e0bffe17 	ldw	r2,-8(fp)
}
 8248830:	e037883a 	mov	sp,fp
 8248834:	dfc00117 	ldw	ra,4(sp)
 8248838:	df000017 	ldw	fp,0(sp)
 824883c:	dec00204 	addi	sp,sp,8
 8248840:	f800283a 	ret

08248844 <vf_free_buffer>:
 *
 * RETURNS: 
 */

void vf_free_buffer(unsigned char * buffer, unsigned long size)
{
 8248844:	defffc04 	addi	sp,sp,-16
 8248848:	dfc00315 	stw	ra,12(sp)
 824884c:	df000215 	stw	fp,8(sp)
 8248850:	df000204 	addi	fp,sp,8
 8248854:	e13ffe15 	stw	r4,-8(fp)
 8248858:	e17fff15 	stw	r5,-4(fp)
   /* free the buffer */
   if (buffer)
 824885c:	e0bffe17 	ldw	r2,-8(fp)
 8248860:	10000226 	beq	r2,zero,824886c <vf_free_buffer+0x28>
      npfree(buffer);
 8248864:	e13ffe17 	ldw	r4,-8(fp)
 8248868:	822e1a00 	call	822e1a0 <npfree>

   /* and subtract its size from the total buffer space count */
   vfs_total_rw_space -= size;
 824886c:	d0e0da17 	ldw	r3,-31896(gp)
 8248870:	e0bfff17 	ldw	r2,-4(fp)
 8248874:	1885c83a 	sub	r2,r3,r2
 8248878:	d0a0da15 	stw	r2,-31896(gp)
}
 824887c:	0001883a 	nop
 8248880:	e037883a 	mov	sp,fp
 8248884:	dfc00117 	ldw	ra,4(sp)
 8248888:	df000017 	ldw	fp,0(sp)
 824888c:	dec00204 	addi	sp,sp,8
 8248890:	f800283a 	ret

08248894 <vfopen_locked>:
 * RETURNS: 
 */

VFILE *
vfopen_locked(char * name, char * mode)
{
 8248894:	defff904 	addi	sp,sp,-28
 8248898:	dfc00615 	stw	ra,24(sp)
 824889c:	df000515 	stw	fp,20(sp)
 82488a0:	df000504 	addi	fp,sp,20
 82488a4:	e13ffe15 	stw	r4,-8(fp)
 82488a8:	e17fff15 	stw	r5,-4(fp)
   struct vfs_file * vfp;
   struct vfs_open * vop;

   /* clear any previous vfopen() error */
   set_vfopen_error(0);
 82488ac:	0009883a 	mov	r4,zero
 82488b0:	82486c00 	call	82486c0 <set_vfopen_error>

   /* the old code used to do special handling of '?' in files for 
    * the benefit of the web server. the web server should be doing 
    * this now. this is here to make sure that its doing it 
    */
   if (strchr(name,'?'))
 82488b4:	01400fc4 	movi	r5,63
 82488b8:	e13ffe17 	ldw	r4,-8(fp)
 82488bc:	82037840 	call	8203784 <strchr>
 82488c0:	10000326 	beq	r2,zero,82488d0 <vfopen_locked+0x3c>
   {
      dtrap();
 82488c4:	822d5940 	call	822d594 <dtrap>
      return NULL;
 82488c8:	0005883a 	mov	r2,zero
 82488cc:	0000ba06 	br	8248bb8 <vfopen_locked+0x324>
   }

   /* determine if the file exists */
   /* if the directory exists, vfp will point to its directory entry
      structure else vfp will be NULL */
   vfp = vfslookup_locked(name);
 82488d0:	e13ffe17 	ldw	r4,-8(fp)
 82488d4:	8249b180 	call	8249b18 <vfslookup_locked>
 82488d8:	e0bffc15 	stw	r2,-16(fp)

   /* if the file exists */
   if (vfp)
 82488dc:	e0bffc17 	ldw	r2,-16(fp)
 82488e0:	10004a26 	beq	r2,zero,8248a0c <vfopen_locked+0x178>

#ifdef HT_RWVFS

      /* if mode begins with 'w' we will truncate to end of file */
      /* make sure the file is writable before proceeding */
      if ((*mode == 'w') && !(vfp->flags & VF_WRITE))
 82488e4:	e0bfff17 	ldw	r2,-4(fp)
 82488e8:	10800003 	ldbu	r2,0(r2)
 82488ec:	10803fcc 	andi	r2,r2,255
 82488f0:	1080201c 	xori	r2,r2,128
 82488f4:	10bfe004 	addi	r2,r2,-128
 82488f8:	10801dd8 	cmpnei	r2,r2,119
 82488fc:	1000091e 	bne	r2,zero,8248924 <vfopen_locked+0x90>
 8248900:	e0bffc17 	ldw	r2,-16(fp)
 8248904:	1080058b 	ldhu	r2,22(r2)
 8248908:	10bfffcc 	andi	r2,r2,65535
 824890c:	1080080c 	andi	r2,r2,32
 8248910:	1000041e 	bne	r2,zero,8248924 <vfopen_locked+0x90>
      {
         set_vfopen_error(ENP_FILEIO);
 8248914:	013ff984 	movi	r4,-26
 8248918:	82486c00 	call	82486c0 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("mode w with no VF_WRITE\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 824891c:	0005883a 	mov	r2,zero
 8248920:	0000a506 	br	8248bb8 <vfopen_locked+0x324>
      }

#endif   /* HT_RWVFS */

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 8248924:	824870c0 	call	824870c <vf_alloc_and_link_vop>
 8248928:	e0bffd15 	stw	r2,-12(fp)

      /* check for failure */
      if (!vop)
 824892c:	e0bffd17 	ldw	r2,-12(fp)
 8248930:	1000041e 	bne	r2,zero,8248944 <vfopen_locked+0xb0>
      {
         set_vfopen_error(ENP_NOMEM);
 8248934:	013ffb04 	movi	r4,-20
 8248938:	82486c00 	call	82486c0 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 1\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 824893c:	0005883a 	mov	r2,zero
 8248940:	00009d06 	br	8248bb8 <vfopen_locked+0x324>
      }

      /* link to the file's directory entry structure */
      vop->file = vfp;
 8248944:	e0bffd17 	ldw	r2,-12(fp)
 8248948:	e0fffc17 	ldw	r3,-16(fp)
 824894c:	10c00115 	stw	r3,4(r2)

      /* by default start at the beginning of the file */
      /* note that vfp->data could be NULL at this point since empty
         files might have no data buffer allocated to them */
      vop->cmploc = vfp->data;   /* start at beginning of file */
 8248950:	e0bffc17 	ldw	r2,-16(fp)
 8248954:	10c00617 	ldw	r3,24(r2)
 8248958:	e0bffd17 	ldw	r2,-12(fp)
 824895c:	10c00215 	stw	r3,8(r2)

#ifdef HT_RWVFS

      /* if mode begins with 'a', seek to end of file */
      if (*mode == 'a')
 8248960:	e0bfff17 	ldw	r2,-4(fp)
 8248964:	10800003 	ldbu	r2,0(r2)
 8248968:	10803fcc 	andi	r2,r2,255
 824896c:	1080201c 	xori	r2,r2,128
 8248970:	10bfe004 	addi	r2,r2,-128
 8248974:	10801858 	cmpnei	r2,r2,97
 8248978:	10000a1e 	bne	r2,zero,82489a4 <vfopen_locked+0x110>
      {
         if (vfp->data)
 824897c:	e0bffc17 	ldw	r2,-16(fp)
 8248980:	10800617 	ldw	r2,24(r2)
 8248984:	10000726 	beq	r2,zero,82489a4 <vfopen_locked+0x110>
         {
            vop->cmploc = vfp->data + vfp->comp_size;
 8248988:	e0bffc17 	ldw	r2,-16(fp)
 824898c:	10c00617 	ldw	r3,24(r2)
 8248990:	e0bffc17 	ldw	r2,-16(fp)
 8248994:	10800817 	ldw	r2,32(r2)
 8248998:	1887883a 	add	r3,r3,r2
 824899c:	e0bffd17 	ldw	r2,-12(fp)
 82489a0:	10c00215 	stw	r3,8(r2)
         }
      }

      /* if mode begins with 'w', truncate to end of file */
      if (*mode == 'w')
 82489a4:	e0bfff17 	ldw	r2,-4(fp)
 82489a8:	10800003 	ldbu	r2,0(r2)
 82489ac:	10803fcc 	andi	r2,r2,255
 82489b0:	1080201c 	xori	r2,r2,128
 82489b4:	10bfe004 	addi	r2,r2,-128
 82489b8:	10801dd8 	cmpnei	r2,r2,119
 82489bc:	1000111e 	bne	r2,zero,8248a04 <vfopen_locked+0x170>
      {
         /* set the size of the file before compression to 0 */
         vfp->real_size = 0;
 82489c0:	e0bffc17 	ldw	r2,-16(fp)
 82489c4:	10000715 	stw	zero,28(r2)
         /* set the size of the compressed data to 0 */
         vfp->comp_size = 0;
 82489c8:	e0bffc17 	ldw	r2,-16(fp)
 82489cc:	10000815 	stw	zero,32(r2)
         /* note we leave the pointer to the file buffer and its length
            alone since first writes will go to it */
         /* flag that the file has been modified */
         vfp->flags |= VF_STALE;
 82489d0:	e0bffc17 	ldw	r2,-16(fp)
 82489d4:	1080058b 	ldhu	r2,22(r2)
 82489d8:	10808014 	ori	r2,r2,512
 82489dc:	1007883a 	mov	r3,r2
 82489e0:	e0bffc17 	ldw	r2,-16(fp)
 82489e4:	10c0058d 	sth	r3,22(r2)

         /* turn off the compression flag */
         vfp->flags &= ~VF_HTMLCOMPRESSED;
 82489e8:	e0bffc17 	ldw	r2,-16(fp)
 82489ec:	10c0058b 	ldhu	r3,22(r2)
 82489f0:	00bfff84 	movi	r2,-2
 82489f4:	1884703a 	and	r2,r3,r2
 82489f8:	1007883a 	mov	r3,r2
 82489fc:	e0bffc17 	ldw	r2,-16(fp)
 8248a00:	10c0058d 	sth	r3,22(r2)
      }

#endif   /* HT_RWVFS */

      return vop;
 8248a04:	e0bffd17 	ldw	r2,-12(fp)
 8248a08:	00006b06 	br	8248bb8 <vfopen_locked+0x324>

#ifdef HT_EXTDEV

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 8248a0c:	e0bfff17 	ldw	r2,-4(fp)
 8248a10:	10800003 	ldbu	r2,0(r2)
 8248a14:	10803fcc 	andi	r2,r2,255
 8248a18:	1080201c 	xori	r2,r2,128
 8248a1c:	10bfe004 	addi	r2,r2,-128
 8248a20:	10801ca0 	cmpeqi	r2,r2,114
 8248a24:	1000121e 	bne	r2,zero,8248a70 <vfopen_locked+0x1dc>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 8248a28:	d0a0d417 	ldw	r2,-31920(gp)
 8248a2c:	e0bffb15 	stw	r2,-20(fp)
 8248a30:	00000d06 	br	8248a68 <vfopen_locked+0x1d4>
      {
         if ((vop = vfs->r_fopen(name, mode)) != NULL)
 8248a34:	e0bffb17 	ldw	r2,-20(fp)
 8248a38:	10800117 	ldw	r2,4(r2)
 8248a3c:	e17fff17 	ldw	r5,-4(fp)
 8248a40:	e13ffe17 	ldw	r4,-8(fp)
 8248a44:	103ee83a 	callr	r2
 8248a48:	e0bffd15 	stw	r2,-12(fp)
 8248a4c:	e0bffd17 	ldw	r2,-12(fp)
 8248a50:	10000226 	beq	r2,zero,8248a5c <vfopen_locked+0x1c8>
         {
            return vop;
 8248a54:	e0bffd17 	ldw	r2,-12(fp)
 8248a58:	00005706 	br	8248bb8 <vfopen_locked+0x324>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 8248a5c:	e0bffb17 	ldw	r2,-20(fp)
 8248a60:	10800017 	ldw	r2,0(r2)
 8248a64:	e0bffb15 	stw	r2,-20(fp)
 8248a68:	e0bffb17 	ldw	r2,-20(fp)
 8248a6c:	103ff11e 	bne	r2,zero,8248a34 <vfopen_locked+0x1a0>

#ifdef HT_RWVFS

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 8248a70:	e0bfff17 	ldw	r2,-4(fp)
 8248a74:	10800003 	ldbu	r2,0(r2)
 8248a78:	10803fcc 	andi	r2,r2,255
 8248a7c:	1080201c 	xori	r2,r2,128
 8248a80:	10bfe004 	addi	r2,r2,-128
 8248a84:	10801ca0 	cmpeqi	r2,r2,114
 8248a88:	1000481e 	bne	r2,zero,8248bac <vfopen_locked+0x318>
   {
      /* enforce maximum number of files */
      if (vfs_total_dyna_files >= VFS_MAX_DYNA_FILES)
 8248a8c:	d0a0db17 	ldw	r2,-31892(gp)
 8248a90:	10803ff0 	cmpltui	r2,r2,255
 8248a94:	1000041e 	bne	r2,zero,8248aa8 <vfopen_locked+0x214>
      {
         set_vfopen_error(ENP_NOMEM);
 8248a98:	013ffb04 	movi	r4,-20
 8248a9c:	82486c00 	call	82486c0 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_total_dyna_files too big in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 8248aa0:	0005883a 	mov	r2,zero
 8248aa4:	00004406 	br	8248bb8 <vfopen_locked+0x324>
      }

      /* make sure the file name is not too long for the VFS */
      if (strlen(name) > FILENAMEMAX)
 8248aa8:	e13ffe17 	ldw	r4,-8(fp)
 8248aac:	8203f600 	call	8203f60 <strlen>
 8248ab0:	10800470 	cmpltui	r2,r2,17
 8248ab4:	1000041e 	bne	r2,zero,8248ac8 <vfopen_locked+0x234>
      {
         set_vfopen_error(ENP_PARAM);
 8248ab8:	013ffd84 	movi	r4,-10
 8248abc:	82486c00 	call	82486c0 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("file name too long in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 8248ac0:	0005883a 	mov	r2,zero
 8248ac4:	00003c06 	br	8248bb8 <vfopen_locked+0x324>
      }

      /* allocate a vfs_file structure to hold the new file entry in */
      vfp = VFS_VFS_FILE_ALLOC();
 8248ac8:	01000b04 	movi	r4,44
 8248acc:	822e16c0 	call	822e16c <npalloc>
 8248ad0:	e0bffc15 	stw	r2,-16(fp)

      /* check for memory allocation failure */
      if (!vfp)
 8248ad4:	e0bffc17 	ldw	r2,-16(fp)
 8248ad8:	1000041e 	bne	r2,zero,8248aec <vfopen_locked+0x258>
      {
         set_vfopen_error(ENP_NOMEM);
 8248adc:	013ffb04 	movi	r4,-20
 8248ae0:	82486c00 	call	82486c0 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("VFS_VFS_FILE_ALLOC() failed in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 8248ae4:	0005883a 	mov	r2,zero
 8248ae8:	00003306 	br	8248bb8 <vfopen_locked+0x324>
      }

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 8248aec:	824870c0 	call	824870c <vf_alloc_and_link_vop>
 8248af0:	e0bffd15 	stw	r2,-12(fp)

      /* check for memory allocation failure */
      if (!vop)
 8248af4:	e0bffd17 	ldw	r2,-12(fp)
 8248af8:	1000061e 	bne	r2,zero,8248b14 <vfopen_locked+0x280>
      {
         VFS_VFS_FILE_FREE(vfp); /* free the allocated vfs_file entry */
 8248afc:	e13ffc17 	ldw	r4,-16(fp)
 8248b00:	822e1a00 	call	822e1a0 <npfree>
         set_vfopen_error(ENP_NOMEM);
 8248b04:	013ffb04 	movi	r4,-20
 8248b08:	82486c00 	call	82486c0 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 2\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 8248b0c:	0005883a 	mov	r2,zero
 8248b10:	00002906 	br	8248bb8 <vfopen_locked+0x324>
      }

      /* add the vfs_file structure to the head of the list */

      vfp->next = vfsfiles;
 8248b14:	d0e0d617 	ldw	r3,-31912(gp)
 8248b18:	e0bffc17 	ldw	r2,-16(fp)
 8248b1c:	10c00015 	stw	r3,0(r2)
      vfsfiles = vfp;
 8248b20:	e0bffc17 	ldw	r2,-16(fp)
 8248b24:	d0a0d615 	stw	r2,-31912(gp)

      /* increment count of total files */
      vfs_total_dyna_files++;
 8248b28:	d0a0db17 	ldw	r2,-31892(gp)
 8248b2c:	10800044 	addi	r2,r2,1
 8248b30:	d0a0db15 	stw	r2,-31892(gp)

      /* remove leading directory separator before storing name */
      if (*name == '/' || *name == '\\')
 8248b34:	e0bffe17 	ldw	r2,-8(fp)
 8248b38:	10800003 	ldbu	r2,0(r2)
 8248b3c:	10803fcc 	andi	r2,r2,255
 8248b40:	1080201c 	xori	r2,r2,128
 8248b44:	10bfe004 	addi	r2,r2,-128
 8248b48:	10800be0 	cmpeqi	r2,r2,47
 8248b4c:	1000071e 	bne	r2,zero,8248b6c <vfopen_locked+0x2d8>
 8248b50:	e0bffe17 	ldw	r2,-8(fp)
 8248b54:	10800003 	ldbu	r2,0(r2)
 8248b58:	10803fcc 	andi	r2,r2,255
 8248b5c:	1080201c 	xori	r2,r2,128
 8248b60:	10bfe004 	addi	r2,r2,-128
 8248b64:	10801718 	cmpnei	r2,r2,92
 8248b68:	1000031e 	bne	r2,zero,8248b78 <vfopen_locked+0x2e4>
         name++;
 8248b6c:	e0bffe17 	ldw	r2,-8(fp)
 8248b70:	10800044 	addi	r2,r2,1
 8248b74:	e0bffe15 	stw	r2,-8(fp)

      /* store the converted name in the directory entry structure */
      strcpy(vfp->name,name);
 8248b78:	e0bffc17 	ldw	r2,-16(fp)
 8248b7c:	10800104 	addi	r2,r2,4
 8248b80:	e17ffe17 	ldw	r5,-8(fp)
 8248b84:	1009883a 	mov	r4,r2
 8248b88:	824b6b80 	call	824b6b8 <strcpy>

      /* set the flags */
      vfp->flags = VF_DYNAMICINFO   /* the directory entry was allocated */
 8248b8c:	e0bffc17 	ldw	r2,-16(fp)
 8248b90:	00c0d804 	movi	r3,864
 8248b94:	10c0058d 	sth	r3,22(r2)
       * note that this means the data pointer contains a null 
       * because we don't allocate any buffer to hold the data 
       * in until the first write 
       */
      /* link to the file's directory entry structure */
      vop->file = vfp;
 8248b98:	e0bffd17 	ldw	r2,-12(fp)
 8248b9c:	e0fffc17 	ldw	r3,-16(fp)
 8248ba0:	10c00115 	stw	r3,4(r2)
      /* the cmploc and tag fields of the vop retain their NULLs from 
       * npalloc(). cmploc contains NULL because there is no data 
       * buffer to point to yet. tag contains NULL because no 
       * decompression operation has started yet
       */
      return vop;
 8248ba4:	e0bffd17 	ldw	r2,-12(fp)
 8248ba8:	00000306 	br	8248bb8 <vfopen_locked+0x324>
   /* pass the open to the local file system */
   return (VFILE *) fopen(name,mode);

#else

   set_vfopen_error(ENP_NOFILE);
 8248bac:	013ff9c4 	movi	r4,-25
 8248bb0:	82486c00 	call	82486c0 <set_vfopen_error>
#ifdef VFS_VERBOSE
   dprintf("fell thru to end of vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
   return NULL;
 8248bb4:	0005883a 	mov	r2,zero

#endif   /* HT_LOCALFS */
}
 8248bb8:	e037883a 	mov	sp,fp
 8248bbc:	dfc00117 	ldw	ra,4(sp)
 8248bc0:	df000017 	ldw	fp,0(sp)
 8248bc4:	dec00204 	addi	sp,sp,8
 8248bc8:	f800283a 	ret

08248bcc <vfopen>:
 * RETURNS: 
 */

VFILE *
vfopen(char * name, char * mode)
{
 8248bcc:	defffb04 	addi	sp,sp,-20
 8248bd0:	dfc00415 	stw	ra,16(sp)
 8248bd4:	df000315 	stw	fp,12(sp)
 8248bd8:	df000304 	addi	fp,sp,12
 8248bdc:	e13ffe15 	stw	r4,-8(fp)
 8248be0:	e17fff15 	stw	r5,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfopen() passed >%s<,%s\n",name,mode);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 8248be4:	01000144 	movi	r4,5
 8248be8:	822dba80 	call	822dba8 <wait_app_sem>

   vfd = vfopen_locked(name,mode);
 8248bec:	e17fff17 	ldw	r5,-4(fp)
 8248bf0:	e13ffe17 	ldw	r4,-8(fp)
 8248bf4:	82488940 	call	8248894 <vfopen_locked>
 8248bf8:	e0bffd15 	stw	r2,-12(fp)

   vfs_unlock();
 8248bfc:	01000144 	movi	r4,5
 8248c00:	822dc640 	call	822dc64 <post_app_sem>

   return vfd;
 8248c04:	e0bffd17 	ldw	r2,-12(fp)
}
 8248c08:	e037883a 	mov	sp,fp
 8248c0c:	dfc00117 	ldw	ra,4(sp)
 8248c10:	df000017 	ldw	fp,0(sp)
 8248c14:	dec00204 	addi	sp,sp,8
 8248c18:	f800283a 	ret

08248c1c <vfclose_locked>:
 * RETURNS: 
 */

void 
vfclose_locked(VFILE * vfd)
{
 8248c1c:	defff804 	addi	sp,sp,-32
 8248c20:	dfc00715 	stw	ra,28(sp)
 8248c24:	df000615 	stw	fp,24(sp)
 8248c28:	df000604 	addi	fp,sp,24
 8248c2c:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;
   VFILE * vlast;

   vlast = NULL;
 8248c30:	e03ffb15 	stw	zero,-20(fp)

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
 8248c34:	d0a0d517 	ldw	r2,-31916(gp)
 8248c38:	e0bffa15 	stw	r2,-24(fp)
   while (vtmp)
 8248c3c:	00000806 	br	8248c60 <vfclose_locked+0x44>
   {
      /* if this is the one we are looking for, exist search loop */
      if (vfd == vtmp)
 8248c40:	e0ffff17 	ldw	r3,-4(fp)
 8248c44:	e0bffa17 	ldw	r2,-24(fp)
 8248c48:	18800826 	beq	r3,r2,8248c6c <vfclose_locked+0x50>
         break;

      /* bump the next and previous pointers along to try the next one */
      vlast = vtmp;
 8248c4c:	e0bffa17 	ldw	r2,-24(fp)
 8248c50:	e0bffb15 	stw	r2,-20(fp)
      vtmp = vtmp->next;
 8248c54:	e0bffa17 	ldw	r2,-24(fp)
 8248c58:	10800017 	ldw	r2,0(r2)
 8248c5c:	e0bffa15 	stw	r2,-24(fp)
   vlast = NULL;

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
   while (vtmp)
 8248c60:	e0bffa17 	ldw	r2,-24(fp)
 8248c64:	103ff61e 	bne	r2,zero,8248c40 <vfclose_locked+0x24>
 8248c68:	00000106 	br	8248c70 <vfclose_locked+0x54>
   {
      /* if this is the one we are looking for, exist search loop */
      if (vfd == vtmp)
         break;
 8248c6c:	0001883a 	nop
      vlast = vtmp;
      vtmp = vtmp->next;
   }

   /* if the passed in handle was not in the list we maintain */
   if (vfd != vtmp)
 8248c70:	e0ffff17 	ldw	r3,-4(fp)
 8248c74:	e0bffa17 	ldw	r2,-24(fp)
 8248c78:	1880511e 	bne	r3,r2,8248dc0 <vfclose_locked+0x1a4>

   /* this not really a forever loop. it exists so we can break easily
      and deal with all the ifdefs */
   while (1)
   {
      struct vfs_file * vfp   =  vfd->file;
 8248c7c:	e0bfff17 	ldw	r2,-4(fp)
 8248c80:	10800117 	ldw	r2,4(r2)
 8248c84:	e0bffc15 	stw	r2,-16(fp)
      /* vfd->file will be null if somebody unlinked the file after
       * this handle was created to point to it. if the file itself 
       * is gone there is nothing left to do, so break to list 
       * deletion code at bottom of loop
       */
      if (vfp == NULL)
 8248c88:	e0bffc17 	ldw	r2,-16(fp)
 8248c8c:	10003826 	beq	r2,zero,8248d70 <vfclose_locked+0x154>
         break;
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 8248c90:	e0bffc17 	ldw	r2,-16(fp)
 8248c94:	10800a17 	ldw	r2,40(r2)
 8248c98:	10000826 	beq	r2,zero,8248cbc <vfclose_locked+0xa0>
      {
         /* call that file system's fclose() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)(vfp->method);
 8248c9c:	e0bffc17 	ldw	r2,-16(fp)
 8248ca0:	10800a17 	ldw	r2,40(r2)
 8248ca4:	e0bffd15 	stw	r2,-12(fp)

         vfs->r_fclose(vfd);
 8248ca8:	e0bffd17 	ldw	r2,-12(fp)
 8248cac:	10800217 	ldw	r2,8(r2)
 8248cb0:	e13fff17 	ldw	r4,-4(fp)
 8248cb4:	103ee83a 	callr	r2
         break;   /* break to list deletion code after end of phoney loop */
 8248cb8:	00003006 	br	8248d7c <vfclose_locked+0x160>

      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
 8248cbc:	e0bffc17 	ldw	r2,-16(fp)
 8248cc0:	1080058b 	ldhu	r2,22(r2)
 8248cc4:	10bfffcc 	andi	r2,r2,65535
 8248cc8:	1080200c 	andi	r2,r2,128
 8248ccc:	10002a26 	beq	r2,zero,8248d78 <vfclose_locked+0x15c>
          ((vfp->buf_size - vfp->comp_size) > VFS_CLOSE_FRAG_FLOOR) &&
 8248cd0:	e0bffc17 	ldw	r2,-16(fp)
 8248cd4:	10c00917 	ldw	r3,36(r2)
 8248cd8:	e0bffc17 	ldw	r2,-16(fp)
 8248cdc:	10800817 	ldw	r2,32(r2)
 8248ce0:	1885c83a 	sub	r2,r3,r2

      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
 8248ce4:	10804030 	cmpltui	r2,r2,256
 8248ce8:	1000231e 	bne	r2,zero,8248d78 <vfclose_locked+0x15c>
          ((vfp->buf_size - vfp->comp_size) > VFS_CLOSE_FRAG_FLOOR) &&
          vfp->data) /* this last test is a sanity check */
 8248cec:	e0bffc17 	ldw	r2,-16(fp)
 8248cf0:	10800617 	ldw	r2,24(r2)
      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
          ((vfp->buf_size - vfp->comp_size) > VFS_CLOSE_FRAG_FLOOR) &&
 8248cf4:	10002026 	beq	r2,zero,8248d78 <vfclose_locked+0x15c>
          vfp->data) /* this last test is a sanity check */
      {
         /* try to reclaim the unused data */

         /* allocate a new buffer just big enough for the data */
         new_buffer = vf_alloc_buffer(vfp->comp_size);
 8248cf8:	e0bffc17 	ldw	r2,-16(fp)
 8248cfc:	10800817 	ldw	r2,32(r2)
 8248d00:	1009883a 	mov	r4,r2
 8248d04:	824877c0 	call	824877c <vf_alloc_buffer>
 8248d08:	e0bffe15 	stw	r2,-8(fp)

         /* if the allocation worked */
         if (new_buffer)
 8248d0c:	e0bffe17 	ldw	r2,-8(fp)
 8248d10:	10001926 	beq	r2,zero,8248d78 <vfclose_locked+0x15c>
         {
            /* copy the old buffer to the new one */
            MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 8248d14:	e0bffc17 	ldw	r2,-16(fp)
 8248d18:	10c00617 	ldw	r3,24(r2)
 8248d1c:	e0bffc17 	ldw	r2,-16(fp)
 8248d20:	10800817 	ldw	r2,32(r2)
 8248d24:	100d883a 	mov	r6,r2
 8248d28:	180b883a 	mov	r5,r3
 8248d2c:	e13ffe17 	ldw	r4,-8(fp)
 8248d30:	8202f100 	call	8202f10 <memcpy>
            /* free the old buffer */
            vf_free_buffer(vfp->data,vfp->buf_size);
 8248d34:	e0bffc17 	ldw	r2,-16(fp)
 8248d38:	10c00617 	ldw	r3,24(r2)
 8248d3c:	e0bffc17 	ldw	r2,-16(fp)
 8248d40:	10800917 	ldw	r2,36(r2)
 8248d44:	100b883a 	mov	r5,r2
 8248d48:	1809883a 	mov	r4,r3
 8248d4c:	82488440 	call	8248844 <vf_free_buffer>
            /* update the buffer pointer and size to reflect the
               just big enough buffer */
            vfp->data = new_buffer;
 8248d50:	e0bffc17 	ldw	r2,-16(fp)
 8248d54:	e0fffe17 	ldw	r3,-8(fp)
 8248d58:	10c00615 	stw	r3,24(r2)
            vfp->buf_size = vfp->comp_size;
 8248d5c:	e0bffc17 	ldw	r2,-16(fp)
 8248d60:	10c00817 	ldw	r3,32(r2)
 8248d64:	e0bffc17 	ldw	r2,-16(fp)
 8248d68:	10c00915 	stw	r3,36(r2)
#endif   /* VFS_AUTO_SYNC */

#endif   /* HT_RWVFS */

      /* break to list deletion code below */
      break;
 8248d6c:	00000206 	br	8248d78 <vfclose_locked+0x15c>
       * this handle was created to point to it. if the file itself 
       * is gone there is nothing left to do, so break to list 
       * deletion code at bottom of loop
       */
      if (vfp == NULL)
         break;
 8248d70:	0001883a 	nop
 8248d74:	00000106 	br	8248d7c <vfclose_locked+0x160>
#endif   /* VFS_AUTO_SYNC */

#endif   /* HT_RWVFS */

      /* break to list deletion code below */
      break;
 8248d78:	0001883a 	nop

   }

   if (vlast)  /* unlink from list of open files */
 8248d7c:	e0bffb17 	ldw	r2,-20(fp)
 8248d80:	10000526 	beq	r2,zero,8248d98 <vfclose_locked+0x17c>
      vlast->next = vtmp->next;
 8248d84:	e0bffa17 	ldw	r2,-24(fp)
 8248d88:	10c00017 	ldw	r3,0(r2)
 8248d8c:	e0bffb17 	ldw	r2,-20(fp)
 8248d90:	10c00015 	stw	r3,0(r2)
 8248d94:	00000306 	br	8248da4 <vfclose_locked+0x188>
   else
      vfiles = vtmp->next;
 8248d98:	e0bffa17 	ldw	r2,-24(fp)
 8248d9c:	10800017 	ldw	r2,0(r2)
 8248da0:	d0a0d515 	stw	r2,-31916(gp)

   /* free structure addressed by open handle */
   VFS_VFS_OPEN_FREE(vtmp);
 8248da4:	e13ffa17 	ldw	r4,-24(fp)
 8248da8:	822e1a00 	call	822e1a0 <npfree>
   /* decrement the number of open files */
   vfs_open_files--;
 8248dac:	d0a0d917 	ldw	r2,-31900(gp)
 8248db0:	10bfffc4 	addi	r2,r2,-1
 8248db4:	d0a0d915 	stw	r2,-31900(gp)
   return;
 8248db8:	0001883a 	nop
 8248dbc:	00000106 	br	8248dc4 <vfclose_locked+0x1a8>

#ifdef HT_LOCALFS
      /* default to call on local system */
      fclose((FILE*)vfd);
#endif   /* HT_LOCALFS */
      return;
 8248dc0:	0001883a 	nop
   /* free structure addressed by open handle */
   VFS_VFS_OPEN_FREE(vtmp);
   /* decrement the number of open files */
   vfs_open_files--;
   return;
}
 8248dc4:	e037883a 	mov	sp,fp
 8248dc8:	dfc00117 	ldw	ra,4(sp)
 8248dcc:	df000017 	ldw	fp,0(sp)
 8248dd0:	dec00204 	addi	sp,sp,8
 8248dd4:	f800283a 	ret

08248dd8 <vfclose>:
 *
 * RETURNS: 
 */

void vfclose(VFILE * vfd)
{
 8248dd8:	defffd04 	addi	sp,sp,-12
 8248ddc:	dfc00215 	stw	ra,8(sp)
 8248de0:	df000115 	stw	fp,4(sp)
 8248de4:	df000104 	addi	fp,sp,4
 8248de8:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 8248dec:	01000144 	movi	r4,5
 8248df0:	822dba80 	call	822dba8 <wait_app_sem>

   vfclose_locked(vfd);
 8248df4:	e13fff17 	ldw	r4,-4(fp)
 8248df8:	8248c1c0 	call	8248c1c <vfclose_locked>

   vfs_unlock();
 8248dfc:	01000144 	movi	r4,5
 8248e00:	822dc640 	call	822dc64 <post_app_sem>
}
 8248e04:	0001883a 	nop
 8248e08:	e037883a 	mov	sp,fp
 8248e0c:	dfc00117 	ldw	ra,4(sp)
 8248e10:	df000017 	ldw	fp,0(sp)
 8248e14:	dec00204 	addi	sp,sp,8
 8248e18:	f800283a 	ret

08248e1c <vfflush>:
 *
 * RETURNS: 
 */

int vfflush(VFILE * vfd)
{
 8248e1c:	defffd04 	addi	sp,sp,-12
 8248e20:	dfc00215 	stw	ra,8(sp)
 8248e24:	df000115 	stw	fp,4(sp)
 8248e28:	df000104 	addi	fp,sp,4
 8248e2c:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 8248e30:	01000144 	movi	r4,5
 8248e34:	822dba80 	call	822dba8 <wait_app_sem>

   printf("vfflush(): This function needs to be implemented\n");
 8248e38:	01020974 	movhi	r4,2085
 8248e3c:	2106df04 	addi	r4,r4,7036
 8248e40:	82036240 	call	8203624 <puts>

   vfs_unlock();
 8248e44:	01000144 	movi	r4,5
 8248e48:	822dc640 	call	822dc64 <post_app_sem>
   return(0);
 8248e4c:	0005883a 	mov	r2,zero
}
 8248e50:	e037883a 	mov	sp,fp
 8248e54:	dfc00117 	ldw	ra,4(sp)
 8248e58:	df000017 	ldw	fp,0(sp)
 8248e5c:	dec00204 	addi	sp,sp,8
 8248e60:	f800283a 	ret

08248e64 <vfgets>:

char * vfgets(char * s, int lim, VFILE * fp) 
{
 8248e64:	defff904 	addi	sp,sp,-28
 8248e68:	dfc00615 	stw	ra,24(sp)
 8248e6c:	df000515 	stw	fp,20(sp)
 8248e70:	df000504 	addi	fp,sp,20
 8248e74:	e13ffd15 	stw	r4,-12(fp)
 8248e78:	e17ffe15 	stw	r5,-8(fp)
 8248e7c:	e1bfff15 	stw	r6,-4(fp)
   int   c   = EOF;
 8248e80:	00bfffc4 	movi	r2,-1
 8248e84:	e0bffb15 	stw	r2,-20(fp)
   char* ret = s;
 8248e88:	e0bffd17 	ldw	r2,-12(fp)
 8248e8c:	e0bffc15 	stw	r2,-16(fp)

   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 8248e90:	00000b06 	br	8248ec0 <vfgets+0x5c>
      if (( *ret ++ = c) == '\n')
 8248e94:	e0bffc17 	ldw	r2,-16(fp)
 8248e98:	10c00044 	addi	r3,r2,1
 8248e9c:	e0fffc15 	stw	r3,-16(fp)
 8248ea0:	e0fffb17 	ldw	r3,-20(fp)
 8248ea4:	10c00005 	stb	r3,0(r2)
 8248ea8:	10800003 	ldbu	r2,0(r2)
 8248eac:	10803fcc 	andi	r2,r2,255
 8248eb0:	1080201c 	xori	r2,r2,128
 8248eb4:	10bfe004 	addi	r2,r2,-128
 8248eb8:	10800298 	cmpnei	r2,r2,10
 8248ebc:	10000c26 	beq	r2,zero,8248ef0 <vfgets+0x8c>
char * vfgets(char * s, int lim, VFILE * fp) 
{
   int   c   = EOF;
   char* ret = s;

   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 8248ec0:	e0bffe17 	ldw	r2,-8(fp)
 8248ec4:	10bfffc4 	addi	r2,r2,-1
 8248ec8:	e0bffe15 	stw	r2,-8(fp)
 8248ecc:	e0bffe17 	ldw	r2,-8(fp)
 8248ed0:	0080080e 	bge	zero,r2,8248ef4 <vfgets+0x90>
 8248ed4:	e13fff17 	ldw	r4,-4(fp)
 8248ed8:	8249ad00 	call	8249ad0 <vgetc>
 8248edc:	e0bffb15 	stw	r2,-20(fp)
 8248ee0:	e0bffb17 	ldw	r2,-20(fp)
 8248ee4:	10bfffd8 	cmpnei	r2,r2,-1
 8248ee8:	103fea1e 	bne	r2,zero,8248e94 <vfgets+0x30>
 8248eec:	00000106 	br	8248ef4 <vfgets+0x90>
      if (( *ret ++ = c) == '\n')
         break;
 8248ef0:	0001883a 	nop
   *ret = '\0';
 8248ef4:	e0bffc17 	ldw	r2,-16(fp)
 8248ef8:	10000005 	stb	zero,0(r2)
   return ( c == EOF && ret == s) ? NULL : s;
 8248efc:	e0bffb17 	ldw	r2,-20(fp)
 8248f00:	10bfffd8 	cmpnei	r2,r2,-1
 8248f04:	1000031e 	bne	r2,zero,8248f14 <vfgets+0xb0>
 8248f08:	e0fffc17 	ldw	r3,-16(fp)
 8248f0c:	e0bffd17 	ldw	r2,-12(fp)
 8248f10:	18800226 	beq	r3,r2,8248f1c <vfgets+0xb8>
 8248f14:	e0bffd17 	ldw	r2,-12(fp)
 8248f18:	00000106 	br	8248f20 <vfgets+0xbc>
 8248f1c:	0005883a 	mov	r2,zero
}
 8248f20:	e037883a 	mov	sp,fp
 8248f24:	dfc00117 	ldw	ra,4(sp)
 8248f28:	df000017 	ldw	fp,0(sp)
 8248f2c:	dec00204 	addi	sp,sp,8
 8248f30:	f800283a 	ret

08248f34 <vfeof>:
 *
 * RETURNS: 1 if the file pointer is at EOF, otherwise 0
 */
 
int vfeof(VFILE * vfd)
{
 8248f34:	defffc04 	addi	sp,sp,-16
 8248f38:	dfc00315 	stw	ra,12(sp)
 8248f3c:	df000215 	stw	fp,8(sp)
 8248f40:	df000204 	addi	fp,sp,8
 8248f44:	e13fff15 	stw	r4,-4(fp)
   int c = 0;
 8248f48:	e03ffe15 	stw	zero,-8(fp)

#ifdef HT_LOCALFS
   return(feof((FILE*)vfd));
#endif
   if ((c = vgetc(vfd)) == EOF )
 8248f4c:	e13fff17 	ldw	r4,-4(fp)
 8248f50:	8249ad00 	call	8249ad0 <vgetc>
 8248f54:	e0bffe15 	stw	r2,-8(fp)
 8248f58:	e0bffe17 	ldw	r2,-8(fp)
 8248f5c:	10bfffd8 	cmpnei	r2,r2,-1
 8248f60:	1000021e 	bne	r2,zero,8248f6c <vfeof+0x38>
   {
      return 1;
 8248f64:	00800044 	movi	r2,1
 8248f68:	00000106 	br	8248f70 <vfeof+0x3c>
   }   
   return 0;
 8248f6c:	0005883a 	mov	r2,zero
}
 8248f70:	e037883a 	mov	sp,fp
 8248f74:	dfc00117 	ldw	ra,4(sp)
 8248f78:	df000017 	ldw	fp,0(sp)
 8248f7c:	dec00204 	addi	sp,sp,8
 8248f80:	f800283a 	ret

08248f84 <vunlink_flag_open_files>:
 *
 * RETURNS: 
 */

void vunlink_flag_open_files(struct vfs_file * vfp)
{
 8248f84:	defffd04 	addi	sp,sp,-12
 8248f88:	df000215 	stw	fp,8(sp)
 8248f8c:	df000204 	addi	fp,sp,8
 8248f90:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 8248f94:	d0a0d517 	ldw	r2,-31916(gp)
 8248f98:	e0bffe15 	stw	r2,-8(fp)
 8248f9c:	00000906 	br	8248fc4 <vunlink_flag_open_files+0x40>
   {
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
 8248fa0:	e0bffe17 	ldw	r2,-8(fp)
 8248fa4:	10c00117 	ldw	r3,4(r2)
 8248fa8:	e0bfff17 	ldw	r2,-4(fp)
 8248fac:	1880021e 	bne	r3,r2,8248fb8 <vunlink_flag_open_files+0x34>
         vtmp->file = NULL;
 8248fb0:	e0bffe17 	ldw	r2,-8(fp)
 8248fb4:	10000115 	stw	zero,4(r2)
void vunlink_flag_open_files(struct vfs_file * vfp)
{
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 8248fb8:	e0bffe17 	ldw	r2,-8(fp)
 8248fbc:	10800017 	ldw	r2,0(r2)
 8248fc0:	e0bffe15 	stw	r2,-8(fp)
 8248fc4:	e0bffe17 	ldw	r2,-8(fp)
 8248fc8:	103ff51e 	bne	r2,zero,8248fa0 <vunlink_flag_open_files+0x1c>
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
         vtmp->file = NULL;
   }
}
 8248fcc:	0001883a 	nop
 8248fd0:	e037883a 	mov	sp,fp
 8248fd4:	df000017 	ldw	fp,0(sp)
 8248fd8:	dec00104 	addi	sp,sp,4
 8248fdc:	f800283a 	ret

08248fe0 <vunlink>:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
int
vunlink(const char * const_name)
{
 8248fe0:	defff604 	addi	sp,sp,-40
 8248fe4:	dfc00915 	stw	ra,36(sp)
 8248fe8:	df000815 	stw	fp,32(sp)
 8248fec:	df000804 	addi	fp,sp,32
 8248ff0:	e13fff15 	stw	r4,-4(fp)
   struct vfs_file * vfp;
   int   rc =  0;
 8248ff4:	e03ff815 	stw	zero,-32(fp)
/*
 * Altera Niche Stack Nios port modification:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
   char * name = malloc(strlen(const_name)+1);
 8248ff8:	e13fff17 	ldw	r4,-4(fp)
 8248ffc:	8203f600 	call	8203f60 <strlen>
 8249000:	10800044 	addi	r2,r2,1
 8249004:	1009883a 	mov	r4,r2
 8249008:	824b6900 	call	824b690 <malloc>
 824900c:	e0bffb15 	stw	r2,-20(fp)
   strcpy(name, const_name);
 8249010:	e17fff17 	ldw	r5,-4(fp)
 8249014:	e13ffb17 	ldw	r4,-20(fp)
 8249018:	824b6b80 	call	824b6b8 <strcpy>
   if (vfs_log_file_name)
      dprintf("vunlink() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 824901c:	01000144 	movi	r4,5
 8249020:	822dba80 	call	822dba8 <wait_app_sem>

   /* see if the converted name is one of the one's in our list */
   /* if it isn't */
   if ((vfp = vfslookup_locked(name)) == NULL)
 8249024:	e13ffb17 	ldw	r4,-20(fp)
 8249028:	8249b180 	call	8249b18 <vfslookup_locked>
 824902c:	e0bffc15 	stw	r2,-16(fp)
 8249030:	e0bffc17 	ldw	r2,-16(fp)
 8249034:	1000061e 	bne	r2,zero,8249050 <vunlink+0x70>
   {
      vfs_unlock();
 8249038:	01000144 	movi	r4,5
 824903c:	822dc640 	call	822dc64 <post_app_sem>
#ifdef HT_LOCALFS
      /* default to call on local system */
      return remove(name);
#else
      /* no local file system, so return error condition */
      free(name);
 8249040:	e13ffb17 	ldw	r4,-20(fp)
 8249044:	824b6a40 	call	824b6a4 <free>
      return -1;
 8249048:	00bfffc4 	movi	r2,-1
 824904c:	00005f06 	br	82491cc <vunlink+0x1ec>
#ifdef   HT_RWVFS
   /* save the next link pointer since in one path through the code, 
    * the vfs_file structure gets freed before its unlinked from the 
    * list
    */
   vfnext = vfp->next;
 8249050:	e0bffc17 	ldw	r2,-16(fp)
 8249054:	10800017 	ldw	r2,0(r2)
 8249058:	e0bffd15 	stw	r2,-12(fp)

   /* search list of files to determine predecessor in list */
   vflast = NULL;
 824905c:	e03ffa15 	stw	zero,-24(fp)
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 8249060:	d0a0d617 	ldw	r2,-31912(gp)
 8249064:	e0bff915 	stw	r2,-28(fp)
 8249068:	00000806 	br	824908c <vunlink+0xac>
   {
      if (vtmp == vfp)
 824906c:	e0fff917 	ldw	r3,-28(fp)
 8249070:	e0bffc17 	ldw	r2,-16(fp)
 8249074:	18800826 	beq	r3,r2,8249098 <vunlink+0xb8>
         break;
      vflast = vtmp;
 8249078:	e0bff917 	ldw	r2,-28(fp)
 824907c:	e0bffa15 	stw	r2,-24(fp)
    */
   vfnext = vfp->next;

   /* search list of files to determine predecessor in list */
   vflast = NULL;
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 8249080:	e0bff917 	ldw	r2,-28(fp)
 8249084:	10800017 	ldw	r2,0(r2)
 8249088:	e0bff915 	stw	r2,-28(fp)
 824908c:	e0bff917 	ldw	r2,-28(fp)
 8249090:	103ff61e 	bne	r2,zero,824906c <vunlink+0x8c>
 8249094:	00000106 	br	824909c <vunlink+0xbc>
   {
      if (vtmp == vfp)
         break;
 8249098:	0001883a 	nop
      vflast = vtmp;
   }

   /* this shouldn't happen since vfslookup_locked() already searched
      the list, but just in case */
   if (vtmp == NULL)
 824909c:	e0bff917 	ldw	r2,-28(fp)
 82490a0:	1000071e 	bne	r2,zero,82490c0 <vunlink+0xe0>
   {
      dtrap();
 82490a4:	822d5940 	call	822d594 <dtrap>
      vfs_unlock();
 82490a8:	01000144 	movi	r4,5
 82490ac:	822dc640 	call	822dc64 <post_app_sem>
      free(name);
 82490b0:	e13ffb17 	ldw	r4,-20(fp)
 82490b4:	824b6a40 	call	824b6a4 <free>
      return -1;
 82490b8:	00bfffc4 	movi	r2,-1
 82490bc:	00004306 	br	82491cc <vunlink+0x1ec>
   while (1)
   {

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 82490c0:	e0bffc17 	ldw	r2,-16(fp)
 82490c4:	10800a17 	ldw	r2,40(r2)
 82490c8:	10000926 	beq	r2,zero,82490f0 <vunlink+0x110>
      {
         /* call that file system's unlink() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfp->method);
 82490cc:	e0bffc17 	ldw	r2,-16(fp)
 82490d0:	10800a17 	ldw	r2,40(r2)
 82490d4:	e0bffe15 	stw	r2,-8(fp)

         rc = vfs->r_unlink(name);
 82490d8:	e0bffe17 	ldw	r2,-8(fp)
 82490dc:	10800817 	ldw	r2,32(r2)
 82490e0:	e13ffb17 	ldw	r4,-20(fp)
 82490e4:	103ee83a 	callr	r2
 82490e8:	e0bff815 	stw	r2,-32(fp)
         break;   /* break to list deletion code after end of phoney loop */
 82490ec:	00002606 	br	8249188 <vunlink+0x1a8>
      }
#endif   /* HT_EXTDEV */

      /* if the file is not write enabled, return error condition */
      if (!(vfp->flags & VF_WRITE))
 82490f0:	e0bffc17 	ldw	r2,-16(fp)
 82490f4:	1080058b 	ldhu	r2,22(r2)
 82490f8:	10bfffcc 	andi	r2,r2,65535
 82490fc:	1080080c 	andi	r2,r2,32
 8249100:	1000061e 	bne	r2,zero,824911c <vunlink+0x13c>
      {
         vfs_unlock();
 8249104:	01000144 	movi	r4,5
 8249108:	822dc640 	call	822dc64 <post_app_sem>
         free(name);
 824910c:	e13ffb17 	ldw	r4,-20(fp)
 8249110:	824b6a40 	call	824b6a4 <free>
         return -1;
 8249114:	00bfffc4 	movi	r2,-1
 8249118:	00002c06 	br	82491cc <vunlink+0x1ec>
      }

      /* if the data buffer containing the file's data was dynamically
         allocated and is not null */
      if ((vfp->flags & VF_DYNAMICDATA) && (vfp->data))
 824911c:	e0bffc17 	ldw	r2,-16(fp)
 8249120:	1080058b 	ldhu	r2,22(r2)
 8249124:	10bfffcc 	andi	r2,r2,65535
 8249128:	1080200c 	andi	r2,r2,128
 824912c:	10000a26 	beq	r2,zero,8249158 <vunlink+0x178>
 8249130:	e0bffc17 	ldw	r2,-16(fp)
 8249134:	10800617 	ldw	r2,24(r2)
 8249138:	10000726 	beq	r2,zero,8249158 <vunlink+0x178>
      {
         /* free the buffer */
         vf_free_buffer(vfp->data,vfp->buf_size);
 824913c:	e0bffc17 	ldw	r2,-16(fp)
 8249140:	10c00617 	ldw	r3,24(r2)
 8249144:	e0bffc17 	ldw	r2,-16(fp)
 8249148:	10800917 	ldw	r2,36(r2)
 824914c:	100b883a 	mov	r5,r2
 8249150:	1809883a 	mov	r4,r3
 8249154:	82488440 	call	8248844 <vf_free_buffer>
      }

      /* if the vfs_file structure itself was allocated dynamically */
      if (vfp->flags & VF_DYNAMICINFO)
 8249158:	e0bffc17 	ldw	r2,-16(fp)
 824915c:	1080058b 	ldhu	r2,22(r2)
 8249160:	10bfffcc 	andi	r2,r2,65535
 8249164:	1080100c 	andi	r2,r2,64
 8249168:	10000526 	beq	r2,zero,8249180 <vunlink+0x1a0>
      {
         /* decrement count of total files */
         vfs_total_dyna_files--;
 824916c:	d0a0db17 	ldw	r2,-31892(gp)
 8249170:	10bfffc4 	addi	r2,r2,-1
 8249174:	d0a0db15 	stw	r2,-31892(gp)

         /* free the vfs_file structure */
         VFS_VFS_FILE_FREE(vfp);
 8249178:	e13ffc17 	ldw	r4,-16(fp)
 824917c:	822e1a00 	call	822e1a0 <npfree>
         the vfs_file has been deleted from the list */
#ifdef VFS_AUTO_SYNC
      do_sync = 1;
#endif
      /* we were successful at our unlink */
      rc = 0;
 8249180:	e03ff815 	stw	zero,-32(fp)

      break;
 8249184:	0001883a 	nop
   }

   /* delete the vfs_file structure from the list headed by vfsfiles */
   if (vflast)
 8249188:	e0bffa17 	ldw	r2,-24(fp)
 824918c:	10000426 	beq	r2,zero,82491a0 <vunlink+0x1c0>
      vflast->next = vfnext;
 8249190:	e0bffa17 	ldw	r2,-24(fp)
 8249194:	e0fffd17 	ldw	r3,-12(fp)
 8249198:	10c00015 	stw	r3,0(r2)
 824919c:	00000206 	br	82491a8 <vunlink+0x1c8>
   else
      vfsfiles = vfnext;
 82491a0:	e0bffd17 	ldw	r2,-12(fp)
 82491a4:	d0a0d615 	stw	r2,-31912(gp)

   /* fix up references to deleted file in list of currently open VFILEs */
   vunlink_flag_open_files(vfp);
 82491a8:	e13ffc17 	ldw	r4,-16(fp)
 82491ac:	8248f840 	call	8248f84 <vunlink_flag_open_files>

   /* flag that the directory is stale so vfs_sync() knows it has to do
      something */
   vfs_dir_stale = TRUE;
 82491b0:	00800044 	movi	r2,1
 82491b4:	d0a0d815 	stw	r2,-31904(gp)

   /* unlinks not allowed on read-only VFS */
   rc = -1;

#endif   /* HT_RWVFS */
   vfs_unlock();
 82491b8:	01000144 	movi	r4,5
 82491bc:	822dc640 	call	822dc64 <post_app_sem>
   free(name);
 82491c0:	e13ffb17 	ldw	r4,-20(fp)
 82491c4:	824b6a40 	call	824b6a4 <free>
   return rc;
 82491c8:	e0bff817 	ldw	r2,-32(fp)
}
 82491cc:	e037883a 	mov	sp,fp
 82491d0:	dfc00117 	ldw	ra,4(sp)
 82491d4:	df000017 	ldw	fp,0(sp)
 82491d8:	dec00204 	addi	sp,sp,8
 82491dc:	f800283a 	ret

082491e0 <vfread>:
 * RETURNS: 
 */

int 
vfread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 82491e0:	defff604 	addi	sp,sp,-40
 82491e4:	dfc00915 	stw	ra,36(sp)
 82491e8:	df000815 	stw	fp,32(sp)
 82491ec:	df000804 	addi	fp,sp,32
 82491f0:	e13ffc15 	stw	r4,-16(fp)
 82491f4:	e17ffd15 	stw	r5,-12(fp)
 82491f8:	e1bffe15 	stw	r6,-8(fp)
 82491fc:	e1ffff15 	stw	r7,-4(fp)
   unsigned bcount;  /* number of bytes put in caller's buffer */

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 8249200:	01000144 	movi	r4,5
 8249204:	822dba80 	call	822dba8 <wait_app_sem>

   /* if the file is in our list of open files */
   if (isvfile_locked(vfd))
 8249208:	e13fff17 	ldw	r4,-4(fp)
 824920c:	8249e500 	call	8249e50 <isvfile_locked>
 8249210:	10004e26 	beq	r2,zero,824934c <vfread+0x16c>
   {

#ifdef HT_RWVFS
      /* the caller is trying to read a handle to a file that's been
         deleted, so he gets 0 data back */
      if (vfd->file == NULL)
 8249214:	e0bfff17 	ldw	r2,-4(fp)
 8249218:	10800117 	ldw	r2,4(r2)
 824921c:	1000041e 	bne	r2,zero,8249230 <vfread+0x50>
      {
         vfs_unlock();
 8249220:	01000144 	movi	r4,5
 8249224:	822dc640 	call	822dc64 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 8249228:	0005883a 	mov	r2,zero
 824922c:	00004a06 	br	8249358 <vfread+0x178>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfd->file->method)
 8249230:	e0bfff17 	ldw	r2,-4(fp)
 8249234:	10800117 	ldw	r2,4(r2)
 8249238:	10800a17 	ldw	r2,40(r2)
 824923c:	10001026 	beq	r2,zero,8249280 <vfread+0xa0>
      {
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 8249240:	e0bfff17 	ldw	r2,-4(fp)
 8249244:	10800117 	ldw	r2,4(r2)
 8249248:	10800a17 	ldw	r2,40(r2)
 824924c:	e0bff915 	stw	r2,-28(fp)
         int   rc;

         /* call that system's fread() */
         rc = vfs->r_fread(buf,size,items,vfd);
 8249250:	e0bff917 	ldw	r2,-28(fp)
 8249254:	10800317 	ldw	r2,12(r2)
 8249258:	e1ffff17 	ldw	r7,-4(fp)
 824925c:	e1bffe17 	ldw	r6,-8(fp)
 8249260:	e17ffd17 	ldw	r5,-12(fp)
 8249264:	e13ffc17 	ldw	r4,-16(fp)
 8249268:	103ee83a 	callr	r2
 824926c:	e0bffa15 	stw	r2,-24(fp)
         vfs_unlock();
 8249270:	01000144 	movi	r4,5
 8249274:	822dc640 	call	822dc64 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return rc;
 8249278:	e0bffa17 	ldw	r2,-24(fp)
 824927c:	00003606 	br	8249358 <vfread+0x178>
#ifdef HT_RWVFS
      /* the data pointer can be NULL if somebody tries to read from 
       * a freshly created file, in which case there is no data in 
       * the file, so return 0
       */
      if (!(vfd->file->data))
 8249280:	e0bfff17 	ldw	r2,-4(fp)
 8249284:	10800117 	ldw	r2,4(r2)
 8249288:	10800617 	ldw	r2,24(r2)
 824928c:	1000041e 	bne	r2,zero,82492a0 <vfread+0xc0>
      {
         vfs_unlock();
 8249290:	01000144 	movi	r4,5
 8249294:	822dc640 	call	822dc64 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 8249298:	0005883a 	mov	r2,zero
 824929c:	00002e06 	br	8249358 <vfread+0x178>
      }
#endif   /* HT_RWVFS */

      bcount = items * size;  /* number of bytes to transfer */
 82492a0:	e0fffe17 	ldw	r3,-8(fp)
 82492a4:	e0bffd17 	ldw	r2,-12(fp)
 82492a8:	1885383a 	mul	r2,r3,r2
 82492ac:	e0bff815 	stw	r2,-32(fp)
         return(items); /* filled user buffer, return # items copied */
      }
      else  /* else fall to faster non-compression code */
#endif   /* HTML_COMPRESSION */
      {  /* get here to do simple uncompressed data read */
         unsigned location = vfd->cmploc - vfd->file->data;
 82492b0:	e0bfff17 	ldw	r2,-4(fp)
 82492b4:	10800217 	ldw	r2,8(r2)
 82492b8:	1007883a 	mov	r3,r2
 82492bc:	e0bfff17 	ldw	r2,-4(fp)
 82492c0:	10800117 	ldw	r2,4(r2)
 82492c4:	10800617 	ldw	r2,24(r2)
 82492c8:	1885c83a 	sub	r2,r3,r2
 82492cc:	e0bffb15 	stw	r2,-20(fp)

         if (((unsigned long)location + bcount) > vfd->file->comp_size)
 82492d0:	e0fffb17 	ldw	r3,-20(fp)
 82492d4:	e0bff817 	ldw	r2,-32(fp)
 82492d8:	1885883a 	add	r2,r3,r2
 82492dc:	e0ffff17 	ldw	r3,-4(fp)
 82492e0:	18c00117 	ldw	r3,4(r3)
 82492e4:	18c00817 	ldw	r3,32(r3)
 82492e8:	1880062e 	bgeu	r3,r2,8249304 <vfread+0x124>
            bcount = (unsigned)(vfd->file->comp_size - location);
 82492ec:	e0bfff17 	ldw	r2,-4(fp)
 82492f0:	10800117 	ldw	r2,4(r2)
 82492f4:	10c00817 	ldw	r3,32(r2)
 82492f8:	e0bffb17 	ldw	r2,-20(fp)
 82492fc:	1885c83a 	sub	r2,r3,r2
 8249300:	e0bff815 	stw	r2,-32(fp)
         MEMCPY(buf, vfd->cmploc, bcount);
 8249304:	e0bfff17 	ldw	r2,-4(fp)
 8249308:	10800217 	ldw	r2,8(r2)
 824930c:	e1bff817 	ldw	r6,-32(fp)
 8249310:	100b883a 	mov	r5,r2
 8249314:	e13ffc17 	ldw	r4,-16(fp)
 8249318:	8202f100 	call	8202f10 <memcpy>
         vfd->cmploc += bcount;
 824931c:	e0bfff17 	ldw	r2,-4(fp)
 8249320:	10c00217 	ldw	r3,8(r2)
 8249324:	e0bff817 	ldw	r2,-32(fp)
 8249328:	1887883a 	add	r3,r3,r2
 824932c:	e0bfff17 	ldw	r2,-4(fp)
 8249330:	10c00215 	stw	r3,8(r2)
      }
      vfs_unlock();
 8249334:	01000144 	movi	r4,5
 8249338:	822dc640 	call	822dc64 <post_app_sem>
      IN_PROFILER(PF_FS, PF_EXIT);
      return (bcount/size);
 824933c:	e17ffd17 	ldw	r5,-12(fp)
 8249340:	e13ff817 	ldw	r4,-32(fp)
 8249344:	8202c100 	call	8202c10 <__udivsi3>
 8249348:	00000306 	br	8249358 <vfread+0x178>
   }

   vfs_unlock();
 824934c:	01000144 	movi	r4,5
 8249350:	822dc640 	call	822dc64 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fread(buf, size, items, (FILE*)vfd));
#else
   return 0;
 8249354:	0005883a 	mov	r2,zero
#endif   /* HT_LOCALFS */
}
 8249358:	e037883a 	mov	sp,fp
 824935c:	dfc00117 	ldw	ra,4(sp)
 8249360:	df000017 	ldw	fp,0(sp)
 8249364:	dec00204 	addi	sp,sp,8
 8249368:	f800283a 	ret

0824936c <vfwrite_locked>:
 * RETURNS: 
 */

int 
vfwrite_locked(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 824936c:	defff204 	addi	sp,sp,-56
 8249370:	dfc00d15 	stw	ra,52(sp)
 8249374:	df000c15 	stw	fp,48(sp)
 8249378:	df000c04 	addi	fp,sp,48
 824937c:	e13ffc15 	stw	r4,-16(fp)
 8249380:	e17ffd15 	stw	r5,-12(fp)
 8249384:	e1bffe15 	stw	r6,-8(fp)
 8249388:	e1ffff15 	stw	r7,-4(fp)
   unsigned long current_offset;
   struct vfs_file * vfp;
#endif   /* HT_RWVFS */

   /* if the file is not in our list of files */
   if (!isvfile_locked(vfd))
 824938c:	e13fff17 	ldw	r4,-4(fp)
 8249390:	8249e500 	call	8249e50 <isvfile_locked>
 8249394:	1000021e 	bne	r2,zero,82493a0 <vfwrite_locked+0x34>
   {
#ifdef HT_LOCALFS
      /* default to call on local system */
      return(fwrite(buf, size, items, (FILE*)vfd));
#else
      return EBADF;
 8249398:	00800244 	movi	r2,9
 824939c:	0000da06 	br	8249708 <vfwrite_locked+0x39c>
   }
   /* this file is in our list of files */

#ifdef HT_EXTDEV
   /* if the file was created by an external file system */
   if (vfd->file->method)
 82493a0:	e0bfff17 	ldw	r2,-4(fp)
 82493a4:	10800117 	ldw	r2,4(r2)
 82493a8:	10800a17 	ldw	r2,40(r2)
 82493ac:	10000e26 	beq	r2,zero,82493e8 <vfwrite_locked+0x7c>
   {
      struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 82493b0:	e0bfff17 	ldw	r2,-4(fp)
 82493b4:	10800117 	ldw	r2,4(r2)
 82493b8:	10800a17 	ldw	r2,40(r2)
 82493bc:	e0bff415 	stw	r2,-48(fp)
      int   rc;

      /* call that system's fwrite() */
      rc = vfs->r_fwrite(buf,size,items,vfd);
 82493c0:	e0bff417 	ldw	r2,-48(fp)
 82493c4:	10800417 	ldw	r2,16(r2)
 82493c8:	e1ffff17 	ldw	r7,-4(fp)
 82493cc:	e1bffe17 	ldw	r6,-8(fp)
 82493d0:	e17ffd17 	ldw	r5,-12(fp)
 82493d4:	e13ffc17 	ldw	r4,-16(fp)
 82493d8:	103ee83a 	callr	r2
 82493dc:	e0bff515 	stw	r2,-44(fp)
      return rc;
 82493e0:	e0bff517 	ldw	r2,-44(fp)
 82493e4:	0000c806 	br	8249708 <vfwrite_locked+0x39c>

#else    /* HT_RWVFS */

   /* the caller is trying to write to a file that's been deleted,
      so he writes 0 data */
   if (vfd->file == NULL)
 82493e8:	e0bfff17 	ldw	r2,-4(fp)
 82493ec:	10800117 	ldw	r2,4(r2)
 82493f0:	1000021e 	bne	r2,zero,82493fc <vfwrite_locked+0x90>
   {
      return 0;
 82493f4:	0005883a 	mov	r2,zero
 82493f8:	0000c306 	br	8249708 <vfwrite_locked+0x39c>
   }

   vfp = vfd->file;
 82493fc:	e0bfff17 	ldw	r2,-4(fp)
 8249400:	10800117 	ldw	r2,4(r2)
 8249404:	e0bff615 	stw	r2,-40(fp)

   /* if the file is not writable, return error condition */
   if (!(vfp->flags & VF_WRITE))
 8249408:	e0bff617 	ldw	r2,-40(fp)
 824940c:	1080058b 	ldhu	r2,22(r2)
 8249410:	10bfffcc 	andi	r2,r2,65535
 8249414:	1080080c 	andi	r2,r2,32
 8249418:	1000051e 	bne	r2,zero,8249430 <vfwrite_locked+0xc4>
   {
      vfd->error = ENP_FILEIO;
 824941c:	e0bfff17 	ldw	r2,-4(fp)
 8249420:	00fff984 	movi	r3,-26
 8249424:	10c00415 	stw	r3,16(r2)
      return 0;
 8249428:	0005883a 	mov	r2,zero
 824942c:	0000b606 	br	8249708 <vfwrite_locked+0x39c>
   }

   /* compute number of bytes to write */
   bcount = size * items;
 8249430:	e0fffd17 	ldw	r3,-12(fp)
 8249434:	e0bffe17 	ldw	r2,-8(fp)
 8249438:	1885383a 	mul	r2,r3,r2
 824943c:	e0bff715 	stw	r2,-36(fp)

   /* get rid of this degenerate case up front */
   if (bcount == 0)
 8249440:	e0bff717 	ldw	r2,-36(fp)
 8249444:	1000021e 	bne	r2,zero,8249450 <vfwrite_locked+0xe4>
   {
      return 0;
 8249448:	0005883a 	mov	r2,zero
 824944c:	0000ae06 	br	8249708 <vfwrite_locked+0x39c>
   }

   /* if the file currently has no data buffer */
   if (vfp->data == NULL)
 8249450:	e0bff617 	ldw	r2,-40(fp)
 8249454:	10800617 	ldw	r2,24(r2)
 8249458:	10003d1e 	bne	r2,zero,8249550 <vfwrite_locked+0x1e4>
   {
      /* compute the size of the buffer to be created */
      /* we round up the size of the data to be written so we dont have
         the overhead of a memory allocation on every write */
      unsigned long buf_size = VFS_ROUND_UP((unsigned long)bcount);
 824945c:	e0bff717 	ldw	r2,-36(fp)
 8249460:	10bfffc4 	addi	r2,r2,-1
 8249464:	1004d37a 	srli	r2,r2,13
 8249468:	10800044 	addi	r2,r2,1
 824946c:	1004937a 	slli	r2,r2,13
 8249470:	e0bff815 	stw	r2,-32(fp)

      /* allocate a buffer of that size */
      vfp->data = vf_alloc_buffer(buf_size);
 8249474:	e13ff817 	ldw	r4,-32(fp)
 8249478:	824877c0 	call	824877c <vf_alloc_buffer>
 824947c:	1007883a 	mov	r3,r2
 8249480:	e0bff617 	ldw	r2,-40(fp)
 8249484:	10c00615 	stw	r3,24(r2)

      /* if the allocation failed */
      if (!(vfp->data))
 8249488:	e0bff617 	ldw	r2,-40(fp)
 824948c:	10800617 	ldw	r2,24(r2)
 8249490:	1000051e 	bne	r2,zero,82494a8 <vfwrite_locked+0x13c>
      {
         vfd->error = ENP_NOMEM;
 8249494:	e0bfff17 	ldw	r2,-4(fp)
 8249498:	00fffb04 	movi	r3,-20
 824949c:	10c00415 	stw	r3,16(r2)
         return 0;
 82494a0:	0005883a 	mov	r2,zero
 82494a4:	00009806 	br	8249708 <vfwrite_locked+0x39c>
      }

      /* store the size of the allocated buffer */
      vfp->buf_size = buf_size;
 82494a8:	e0bff617 	ldw	r2,-40(fp)
 82494ac:	e0fff817 	ldw	r3,-32(fp)
 82494b0:	10c00915 	stw	r3,36(r2)

      /* store the number of bytes written in the real and compressed
         file sizes */
      vfp->real_size = bcount;
 82494b4:	e0bff617 	ldw	r2,-40(fp)
 82494b8:	e0fff717 	ldw	r3,-36(fp)
 82494bc:	10c00715 	stw	r3,28(r2)
      vfp->comp_size = bcount;
 82494c0:	e0bff617 	ldw	r2,-40(fp)
 82494c4:	e0fff717 	ldw	r3,-36(fp)
 82494c8:	10c00815 	stw	r3,32(r2)

      /* set the file pointer to the first byte following the last
         byte written */
      vfd->cmploc = vfp->data + bcount;
 82494cc:	e0bff617 	ldw	r2,-40(fp)
 82494d0:	10c00617 	ldw	r3,24(r2)
 82494d4:	e0bff717 	ldw	r2,-36(fp)
 82494d8:	1887883a 	add	r3,r3,r2
 82494dc:	e0bfff17 	ldw	r2,-4(fp)
 82494e0:	10c00215 	stw	r3,8(r2)

      /* turn off the compression flag */
      vfp->flags &= ~VF_HTMLCOMPRESSED;
 82494e4:	e0bff617 	ldw	r2,-40(fp)
 82494e8:	10c0058b 	ldhu	r3,22(r2)
 82494ec:	00bfff84 	movi	r2,-2
 82494f0:	1884703a 	and	r2,r3,r2
 82494f4:	1007883a 	mov	r3,r2
 82494f8:	e0bff617 	ldw	r2,-40(fp)
 82494fc:	10c0058d 	sth	r3,22(r2)

      /* the data in the file is stale */
      vfp->flags |= VF_STALE;
 8249500:	e0bff617 	ldw	r2,-40(fp)
 8249504:	1080058b 	ldhu	r2,22(r2)
 8249508:	10808014 	ori	r2,r2,512
 824950c:	1007883a 	mov	r3,r2
 8249510:	e0bff617 	ldw	r2,-40(fp)
 8249514:	10c0058d 	sth	r3,22(r2)

      /* the buffer data was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 8249518:	e0bff617 	ldw	r2,-40(fp)
 824951c:	1080058b 	ldhu	r2,22(r2)
 8249520:	10802014 	ori	r2,r2,128
 8249524:	1007883a 	mov	r3,r2
 8249528:	e0bff617 	ldw	r2,-40(fp)
 824952c:	10c0058d 	sth	r3,22(r2)

      /* copy the data to be written to the file buffer */
      MEMCPY(vfp->data,buf,bcount);
 8249530:	e0bff617 	ldw	r2,-40(fp)
 8249534:	10800617 	ldw	r2,24(r2)
 8249538:	e1bff717 	ldw	r6,-36(fp)
 824953c:	e17ffc17 	ldw	r5,-16(fp)
 8249540:	1009883a 	mov	r4,r2
 8249544:	8202f100 	call	8202f10 <memcpy>

      /* return the number of "items" written */
      return items;
 8249548:	e0bffe17 	ldw	r2,-8(fp)
 824954c:	00006e06 	br	8249708 <vfwrite_locked+0x39c>
   }

   /* compute the current offset into the file */
   current_offset = vfd->cmploc - vfp->data;
 8249550:	e0bfff17 	ldw	r2,-4(fp)
 8249554:	10800217 	ldw	r2,8(r2)
 8249558:	1007883a 	mov	r3,r2
 824955c:	e0bff617 	ldw	r2,-40(fp)
 8249560:	10800617 	ldw	r2,24(r2)
 8249564:	1885c83a 	sub	r2,r3,r2
 8249568:	e0bff915 	stw	r2,-28(fp)

   /* if the data to be written wont fit into the file buffer */
   if ((current_offset + bcount) > vfp->buf_size)
 824956c:	e0fff917 	ldw	r3,-28(fp)
 8249570:	e0bff717 	ldw	r2,-36(fp)
 8249574:	1885883a 	add	r2,r3,r2
 8249578:	e0fff617 	ldw	r3,-40(fp)
 824957c:	18c00917 	ldw	r3,36(r3)
 8249580:	1880382e 	bgeu	r3,r2,8249664 <vfwrite_locked+0x2f8>
   {
      /* compute the size of a new buffer to hold the data */
      unsigned long new_buf_size = VFS_ROUND_UP(current_offset + bcount);
 8249584:	e0fff917 	ldw	r3,-28(fp)
 8249588:	e0bff717 	ldw	r2,-36(fp)
 824958c:	1885883a 	add	r2,r3,r2
 8249590:	10bfffc4 	addi	r2,r2,-1
 8249594:	1004d37a 	srli	r2,r2,13
 8249598:	10800044 	addi	r2,r2,1
 824959c:	1004937a 	slli	r2,r2,13
 82495a0:	e0bffa15 	stw	r2,-24(fp)
      unsigned char *new_buffer;

      /* allocate a new buffer */
      new_buffer = vf_alloc_buffer(new_buf_size);
 82495a4:	e13ffa17 	ldw	r4,-24(fp)
 82495a8:	824877c0 	call	824877c <vf_alloc_buffer>
 82495ac:	e0bffb15 	stw	r2,-20(fp)

      /* check for allocation failure */
      if (!new_buffer)
 82495b0:	e0bffb17 	ldw	r2,-20(fp)
 82495b4:	1000051e 	bne	r2,zero,82495cc <vfwrite_locked+0x260>
      {
         vfd->error = ENP_NOMEM;
 82495b8:	e0bfff17 	ldw	r2,-4(fp)
 82495bc:	00fffb04 	movi	r3,-20
 82495c0:	10c00415 	stw	r3,16(r2)
         return 0;
 82495c4:	0005883a 	mov	r2,zero
 82495c8:	00004f06 	br	8249708 <vfwrite_locked+0x39c>
      }

      /* copy the old buffer contents to the new buffer */
      MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 82495cc:	e0bff617 	ldw	r2,-40(fp)
 82495d0:	10c00617 	ldw	r3,24(r2)
 82495d4:	e0bff617 	ldw	r2,-40(fp)
 82495d8:	10800817 	ldw	r2,32(r2)
 82495dc:	100d883a 	mov	r6,r2
 82495e0:	180b883a 	mov	r5,r3
 82495e4:	e13ffb17 	ldw	r4,-20(fp)
 82495e8:	8202f100 	call	8202f10 <memcpy>

      /* if the old buffer had been dynamically allocated */
      if (vfp->flags & VF_DYNAMICDATA)
 82495ec:	e0bff617 	ldw	r2,-40(fp)
 82495f0:	1080058b 	ldhu	r2,22(r2)
 82495f4:	10bfffcc 	andi	r2,r2,65535
 82495f8:	1080200c 	andi	r2,r2,128
 82495fc:	10000726 	beq	r2,zero,824961c <vfwrite_locked+0x2b0>
      {
         /* free it */
         vf_free_buffer(vfp->data,vfp->buf_size);
 8249600:	e0bff617 	ldw	r2,-40(fp)
 8249604:	10c00617 	ldw	r3,24(r2)
 8249608:	e0bff617 	ldw	r2,-40(fp)
 824960c:	10800917 	ldw	r2,36(r2)
 8249610:	100b883a 	mov	r5,r2
 8249614:	1809883a 	mov	r4,r3
 8249618:	82488440 	call	8248844 <vf_free_buffer>
      }

      /* store the new buffer in the file structure */
      vfp->data = new_buffer;
 824961c:	e0bff617 	ldw	r2,-40(fp)
 8249620:	e0fffb17 	ldw	r3,-20(fp)
 8249624:	10c00615 	stw	r3,24(r2)

      /* store the new buffer size in the file structure */
      vfp->buf_size = new_buf_size;
 8249628:	e0bff617 	ldw	r2,-40(fp)
 824962c:	e0fffa17 	ldw	r3,-24(fp)
 8249630:	10c00915 	stw	r3,36(r2)

      /* the new buffer was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 8249634:	e0bff617 	ldw	r2,-40(fp)
 8249638:	1080058b 	ldhu	r2,22(r2)
 824963c:	10802014 	ori	r2,r2,128
 8249640:	1007883a 	mov	r3,r2
 8249644:	e0bff617 	ldw	r2,-40(fp)
 8249648:	10c0058d 	sth	r3,22(r2)
       * buffer note that this means the VFS does not support 
       * simultaneous opens of the same file, since for that to work, 
       * all the other cmploc's that point to this file would 
       * have to be updated also 
       */
      vfd->cmploc = vfp->data + current_offset;
 824964c:	e0bff617 	ldw	r2,-40(fp)
 8249650:	10c00617 	ldw	r3,24(r2)
 8249654:	e0bff917 	ldw	r2,-28(fp)
 8249658:	1887883a 	add	r3,r3,r2
 824965c:	e0bfff17 	ldw	r2,-4(fp)
 8249660:	10c00215 	stw	r3,8(r2)
   }

   /* copy the data to the current file pointer */
   MEMCPY(vfd->cmploc,buf,bcount);
 8249664:	e0bfff17 	ldw	r2,-4(fp)
 8249668:	10800217 	ldw	r2,8(r2)
 824966c:	e1bff717 	ldw	r6,-36(fp)
 8249670:	e17ffc17 	ldw	r5,-16(fp)
 8249674:	1009883a 	mov	r4,r2
 8249678:	8202f100 	call	8202f10 <memcpy>

   /* update the current file pointer */
   vfd->cmploc += bcount;
 824967c:	e0bfff17 	ldw	r2,-4(fp)
 8249680:	10c00217 	ldw	r3,8(r2)
 8249684:	e0bff717 	ldw	r2,-36(fp)
 8249688:	1887883a 	add	r3,r3,r2
 824968c:	e0bfff17 	ldw	r2,-4(fp)
 8249690:	10c00215 	stw	r3,8(r2)

   /* if the resulting current offset is greater than the file size */
   if (current_offset + bcount > vfp->comp_size)
 8249694:	e0fff917 	ldw	r3,-28(fp)
 8249698:	e0bff717 	ldw	r2,-36(fp)
 824969c:	1885883a 	add	r2,r3,r2
 82496a0:	e0fff617 	ldw	r3,-40(fp)
 82496a4:	18c00817 	ldw	r3,32(r3)
 82496a8:	1880052e 	bgeu	r3,r2,82496c0 <vfwrite_locked+0x354>
   {
      /* update the "compressed" file size */
      vfp->comp_size = current_offset + bcount;
 82496ac:	e0fff917 	ldw	r3,-28(fp)
 82496b0:	e0bff717 	ldw	r2,-36(fp)
 82496b4:	1887883a 	add	r3,r3,r2
 82496b8:	e0bff617 	ldw	r2,-40(fp)
 82496bc:	10c00815 	stw	r3,32(r2)
   }

   /* since we turn off the compression bit below, the "real" size and
      the compressed size must be the same */
   vfp->real_size = vfp->comp_size;
 82496c0:	e0bff617 	ldw	r2,-40(fp)
 82496c4:	10c00817 	ldw	r3,32(r2)
 82496c8:	e0bff617 	ldw	r2,-40(fp)
 82496cc:	10c00715 	stw	r3,28(r2)

   /* turn off the compression flag */
   vfp->flags &= ~VF_HTMLCOMPRESSED;
 82496d0:	e0bff617 	ldw	r2,-40(fp)
 82496d4:	10c0058b 	ldhu	r3,22(r2)
 82496d8:	00bfff84 	movi	r2,-2
 82496dc:	1884703a 	and	r2,r3,r2
 82496e0:	1007883a 	mov	r3,r2
 82496e4:	e0bff617 	ldw	r2,-40(fp)
 82496e8:	10c0058d 	sth	r3,22(r2)

   /* the data in the file is stale */
   vfp->flags |= VF_STALE;
 82496ec:	e0bff617 	ldw	r2,-40(fp)
 82496f0:	1080058b 	ldhu	r2,22(r2)
 82496f4:	10808014 	ori	r2,r2,512
 82496f8:	1007883a 	mov	r3,r2
 82496fc:	e0bff617 	ldw	r2,-40(fp)
 8249700:	10c0058d 	sth	r3,22(r2)

   /* return the number of "items" written */
   return items;
 8249704:	e0bffe17 	ldw	r2,-8(fp)

#endif   /* HT_RWVFS */
}
 8249708:	e037883a 	mov	sp,fp
 824970c:	dfc00117 	ldw	ra,4(sp)
 8249710:	df000017 	ldw	fp,0(sp)
 8249714:	dec00204 	addi	sp,sp,8
 8249718:	f800283a 	ret

0824971c <vfwrite>:
 * RETURNS: 
 */

int
vfwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 824971c:	defff904 	addi	sp,sp,-28
 8249720:	dfc00615 	stw	ra,24(sp)
 8249724:	df000515 	stw	fp,20(sp)
 8249728:	df000504 	addi	fp,sp,20
 824972c:	e13ffc15 	stw	r4,-16(fp)
 8249730:	e17ffd15 	stw	r5,-12(fp)
 8249734:	e1bffe15 	stw	r6,-8(fp)
 8249738:	e1ffff15 	stw	r7,-4(fp)
   int   rc;

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 824973c:	01000144 	movi	r4,5
 8249740:	822dba80 	call	822dba8 <wait_app_sem>

   /* do the write */
   rc = vfwrite_locked(buf, size, items, vfd);
 8249744:	e1ffff17 	ldw	r7,-4(fp)
 8249748:	e1bffe17 	ldw	r6,-8(fp)
 824974c:	e17ffd17 	ldw	r5,-12(fp)
 8249750:	e13ffc17 	ldw	r4,-16(fp)
 8249754:	824936c0 	call	824936c <vfwrite_locked>
 8249758:	e0bffb15 	stw	r2,-20(fp)

   /* unlock the VFS */
   vfs_unlock();
 824975c:	01000144 	movi	r4,5
 8249760:	822dc640 	call	822dc64 <post_app_sem>

   IN_PROFILER(PF_FS, PF_EXIT);

   return rc;
 8249764:	e0bffb17 	ldw	r2,-20(fp)
}
 8249768:	e037883a 	mov	sp,fp
 824976c:	dfc00117 	ldw	ra,4(sp)
 8249770:	df000017 	ldw	fp,0(sp)
 8249774:	dec00204 	addi	sp,sp,8
 8249778:	f800283a 	ret

0824977c <vfseek>:
 * RETURNS: 
 */

int 
vfseek(VFILE * vfd, long offset, int mode)
{
 824977c:	defff904 	addi	sp,sp,-28
 8249780:	dfc00615 	stw	ra,24(sp)
 8249784:	df000515 	stw	fp,20(sp)
 8249788:	df000504 	addi	fp,sp,20
 824978c:	e13ffd15 	stw	r4,-12(fp)
 8249790:	e17ffe15 	stw	r5,-8(fp)
 8249794:	e1bfff15 	stw	r6,-4(fp)
   /* lock the VFS */
   vfs_lock();
 8249798:	01000144 	movi	r4,5
 824979c:	822dba80 	call	822dba8 <wait_app_sem>

   if (isvfile_locked(vfd))
 82497a0:	e13ffd17 	ldw	r4,-12(fp)
 82497a4:	8249e500 	call	8249e50 <isvfile_locked>
 82497a8:	10003f26 	beq	r2,zero,82498a8 <vfseek+0x12c>
   {
#ifdef HT_RWVFS
      /* the caller is trying to seek a file that's been deleted,
         so return an error indication */
      if (vfd->file == NULL)
 82497ac:	e0bffd17 	ldw	r2,-12(fp)
 82497b0:	10800117 	ldw	r2,4(r2)
 82497b4:	1000041e 	bne	r2,zero,82497c8 <vfseek+0x4c>
      {
         vfs_unlock();
 82497b8:	01000144 	movi	r4,5
 82497bc:	822dc640 	call	822dc64 <post_app_sem>
         return -1;
 82497c0:	00bfffc4 	movi	r2,-1
 82497c4:	00003b06 	br	82498b4 <vfseek+0x138>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 82497c8:	e0bffd17 	ldw	r2,-12(fp)
 82497cc:	10800117 	ldw	r2,4(r2)
 82497d0:	10800a17 	ldw	r2,40(r2)
 82497d4:	10000f26 	beq	r2,zero,8249814 <vfseek+0x98>
      {
         struct vfroutines *vfp = (struct vfroutines*)(vfd->file->method);
 82497d8:	e0bffd17 	ldw	r2,-12(fp)
 82497dc:	10800117 	ldw	r2,4(r2)
 82497e0:	10800a17 	ldw	r2,40(r2)
 82497e4:	e0bffb15 	stw	r2,-20(fp)
         int   rc;

         rc = vfp->r_fseek(vfd, offset, mode);
 82497e8:	e0bffb17 	ldw	r2,-20(fp)
 82497ec:	10800517 	ldw	r2,20(r2)
 82497f0:	e1bfff17 	ldw	r6,-4(fp)
 82497f4:	e17ffe17 	ldw	r5,-8(fp)
 82497f8:	e13ffd17 	ldw	r4,-12(fp)
 82497fc:	103ee83a 	callr	r2
 8249800:	e0bffc15 	stw	r2,-16(fp)
         vfs_unlock();
 8249804:	01000144 	movi	r4,5
 8249808:	822dc640 	call	822dc64 <post_app_sem>
         return rc;
 824980c:	e0bffc17 	ldw	r2,-16(fp)
 8249810:	00002806 	br	82498b4 <vfseek+0x138>
      }
#endif   /* HT_EXTDEV */
      /* this vfseek() currently only supports seek to exact
         end or begining of file */
      switch (mode)
 8249814:	e0bfff17 	ldw	r2,-4(fp)
 8249818:	10c00060 	cmpeqi	r3,r2,1
 824981c:	18000b1e 	bne	r3,zero,824984c <vfseek+0xd0>
 8249820:	10c000a0 	cmpeqi	r3,r2,2
 8249824:	1800101e 	bne	r3,zero,8249868 <vfseek+0xec>
 8249828:	10001b1e 	bne	r2,zero,8249898 <vfseek+0x11c>
      {
      case SEEK_SET:
         vfd->cmploc = vfd->file->data + offset;
 824982c:	e0bffd17 	ldw	r2,-12(fp)
 8249830:	10800117 	ldw	r2,4(r2)
 8249834:	10c00617 	ldw	r3,24(r2)
 8249838:	e0bffe17 	ldw	r2,-8(fp)
 824983c:	1887883a 	add	r3,r3,r2
 8249840:	e0bffd17 	ldw	r2,-12(fp)
 8249844:	10c00215 	stw	r3,8(r2)
         break;
 8249848:	00001306 	br	8249898 <vfseek+0x11c>
      case SEEK_CUR:
         /* If the file is compressed, then the following
          * adjustment is inaccurate. Currently we don't have
          * any scenario where this happens. - handle later */
         vfd->cmploc += offset; 
 824984c:	e0bffd17 	ldw	r2,-12(fp)
 8249850:	10c00217 	ldw	r3,8(r2)
 8249854:	e0bffe17 	ldw	r2,-8(fp)
 8249858:	1887883a 	add	r3,r3,r2
 824985c:	e0bffd17 	ldw	r2,-12(fp)
 8249860:	10c00215 	stw	r3,8(r2)
         break;
 8249864:	00000c06 	br	8249898 <vfseek+0x11c>
      case SEEK_END:
         vfd->cmploc = vfd->file->data + vfd->file->comp_size + offset;
 8249868:	e0bffd17 	ldw	r2,-12(fp)
 824986c:	10800117 	ldw	r2,4(r2)
 8249870:	10c00617 	ldw	r3,24(r2)
 8249874:	e0bffd17 	ldw	r2,-12(fp)
 8249878:	10800117 	ldw	r2,4(r2)
 824987c:	11000817 	ldw	r4,32(r2)
 8249880:	e0bffe17 	ldw	r2,-8(fp)
 8249884:	2085883a 	add	r2,r4,r2
 8249888:	1887883a 	add	r3,r3,r2
 824988c:	e0bffd17 	ldw	r2,-12(fp)
 8249890:	10c00215 	stw	r3,8(r2)
         break;
 8249894:	0001883a 	nop
      }
      vfs_unlock();
 8249898:	01000144 	movi	r4,5
 824989c:	822dc640 	call	822dc64 <post_app_sem>
      return(0);
 82498a0:	0005883a 	mov	r2,zero
 82498a4:	00000306 	br	82498b4 <vfseek+0x138>
   }

   vfs_unlock();
 82498a8:	01000144 	movi	r4,5
 82498ac:	822dc640 	call	822dc64 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fseek((FILE*)vfd, offset, mode));
#else
   return -1;
 82498b0:	00bfffc4 	movi	r2,-1
#endif   /* HT_LOCALFS */
}
 82498b4:	e037883a 	mov	sp,fp
 82498b8:	dfc00117 	ldw	ra,4(sp)
 82498bc:	df000017 	ldw	fp,0(sp)
 82498c0:	dec00204 	addi	sp,sp,8
 82498c4:	f800283a 	ret

082498c8 <vftell>:
 * RETURNS: 
 */

long
vftell(VFILE * vfd)
{
 82498c8:	defffb04 	addi	sp,sp,-20
 82498cc:	dfc00415 	stw	ra,16(sp)
 82498d0:	df000315 	stw	fp,12(sp)
 82498d4:	df000304 	addi	fp,sp,12
 82498d8:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 82498dc:	01000144 	movi	r4,5
 82498e0:	822dba80 	call	822dba8 <wait_app_sem>

   if (isvfile_locked(vfd))
 82498e4:	e13fff17 	ldw	r4,-4(fp)
 82498e8:	8249e500 	call	8249e50 <isvfile_locked>
 82498ec:	10003226 	beq	r2,zero,82499b8 <vftell+0xf0>
   {
#ifdef HT_RWVFS
      /* the caller is trying to ftell a deleted file,
         so return an error condition */
      if (vfd->file == NULL)
 82498f0:	e0bfff17 	ldw	r2,-4(fp)
 82498f4:	10800117 	ldw	r2,4(r2)
 82498f8:	1000041e 	bne	r2,zero,824990c <vftell+0x44>
      {
         vfs_unlock();
 82498fc:	01000144 	movi	r4,5
 8249900:	822dc640 	call	822dc64 <post_app_sem>
         return -1;
 8249904:	00bfffc4 	movi	r2,-1
 8249908:	00002e06 	br	82499c4 <vftell+0xfc>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 824990c:	e0bfff17 	ldw	r2,-4(fp)
 8249910:	10800117 	ldw	r2,4(r2)
 8249914:	10800a17 	ldw	r2,40(r2)
 8249918:	10000d26 	beq	r2,zero,8249950 <vftell+0x88>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 824991c:	e0bfff17 	ldw	r2,-4(fp)
 8249920:	10800117 	ldw	r2,4(r2)
 8249924:	10800a17 	ldw	r2,40(r2)
 8249928:	e0bffd15 	stw	r2,-12(fp)
         long  rc;

         rc = vfp->r_ftell(vfd);
 824992c:	e0bffd17 	ldw	r2,-12(fp)
 8249930:	10800617 	ldw	r2,24(r2)
 8249934:	e13fff17 	ldw	r4,-4(fp)
 8249938:	103ee83a 	callr	r2
 824993c:	e0bffe15 	stw	r2,-8(fp)
         vfs_unlock();
 8249940:	01000144 	movi	r4,5
 8249944:	822dc640 	call	822dc64 <post_app_sem>
         return rc;
 8249948:	e0bffe17 	ldw	r2,-8(fp)
 824994c:	00001d06 	br	82499c4 <vftell+0xfc>
      }
#endif   /* HT_EXTDEV */
      /* if file has been fseeked to end, return uncompressed size.
         else return current location in compression stream */
      if (vfd->cmploc == vfd->file->data + vfd->file->comp_size)
 8249950:	e0bfff17 	ldw	r2,-4(fp)
 8249954:	10c00217 	ldw	r3,8(r2)
 8249958:	e0bfff17 	ldw	r2,-4(fp)
 824995c:	10800117 	ldw	r2,4(r2)
 8249960:	11000617 	ldw	r4,24(r2)
 8249964:	e0bfff17 	ldw	r2,-4(fp)
 8249968:	10800117 	ldw	r2,4(r2)
 824996c:	10800817 	ldw	r2,32(r2)
 8249970:	2085883a 	add	r2,r4,r2
 8249974:	1880061e 	bne	r3,r2,8249990 <vftell+0xc8>
      {
         vfs_unlock();
 8249978:	01000144 	movi	r4,5
 824997c:	822dc640 	call	822dc64 <post_app_sem>

         return vfd->file->comp_size;
 8249980:	e0bfff17 	ldw	r2,-4(fp)
 8249984:	10800117 	ldw	r2,4(r2)
 8249988:	10800817 	ldw	r2,32(r2)
 824998c:	00000d06 	br	82499c4 <vftell+0xfc>
      }
      else
      {
         vfs_unlock();
 8249990:	01000144 	movi	r4,5
 8249994:	822dc640 	call	822dc64 <post_app_sem>

         return (vfd->cmploc - vfd->file->data);
 8249998:	e0bfff17 	ldw	r2,-4(fp)
 824999c:	10800217 	ldw	r2,8(r2)
 82499a0:	1007883a 	mov	r3,r2
 82499a4:	e0bfff17 	ldw	r2,-4(fp)
 82499a8:	10800117 	ldw	r2,4(r2)
 82499ac:	10800617 	ldw	r2,24(r2)
 82499b0:	1885c83a 	sub	r2,r3,r2
 82499b4:	00000306 	br	82499c4 <vftell+0xfc>
      }
   }

   vfs_unlock();
 82499b8:	01000144 	movi	r4,5
 82499bc:	822dc640 	call	822dc64 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(ftell((FILE*)vfd));
#else
   return EBADF;
 82499c0:	00800244 	movi	r2,9
#endif   /* HT_LOCALFS */
}
 82499c4:	e037883a 	mov	sp,fp
 82499c8:	dfc00117 	ldw	ra,4(sp)
 82499cc:	df000017 	ldw	fp,0(sp)
 82499d0:	dec00204 	addi	sp,sp,8
 82499d4:	f800283a 	ret

082499d8 <vgetc_locked>:
 * RETURNS: 
 */

int
vgetc_locked(VFILE * vfd)
{
 82499d8:	defffb04 	addi	sp,sp,-20
 82499dc:	dfc00415 	stw	ra,16(sp)
 82499e0:	df000315 	stw	fp,12(sp)
 82499e4:	df000304 	addi	fp,sp,12
 82499e8:	e13fff15 	stw	r4,-4(fp)
   int   chr;

   if (isvfile_locked(vfd))
 82499ec:	e13fff17 	ldw	r4,-4(fp)
 82499f0:	8249e500 	call	8249e50 <isvfile_locked>
 82499f4:	10002f26 	beq	r2,zero,8249ab4 <vgetc_locked+0xdc>
   {
#ifdef HT_RWVFS
      /* the caller is trying to read a file that's been deleted,
         so return an error condition */
      if (vfd->file == NULL)
 82499f8:	e0bfff17 	ldw	r2,-4(fp)
 82499fc:	10800117 	ldw	r2,4(r2)
 8249a00:	1000021e 	bne	r2,zero,8249a0c <vgetc_locked+0x34>
      {
         return EOF;
 8249a04:	00bfffc4 	movi	r2,-1
 8249a08:	00002c06 	br	8249abc <vgetc_locked+0xe4>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 8249a0c:	e0bfff17 	ldw	r2,-4(fp)
 8249a10:	10800117 	ldw	r2,4(r2)
 8249a14:	10800a17 	ldw	r2,40(r2)
 8249a18:	10000926 	beq	r2,zero,8249a40 <vgetc_locked+0x68>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 8249a1c:	e0bfff17 	ldw	r2,-4(fp)
 8249a20:	10800117 	ldw	r2,4(r2)
 8249a24:	10800a17 	ldw	r2,40(r2)
 8249a28:	e0bffe15 	stw	r2,-8(fp)
         return (vfp->r_fgetc(vfd));
 8249a2c:	e0bffe17 	ldw	r2,-8(fp)
 8249a30:	10800717 	ldw	r2,28(r2)
 8249a34:	e13fff17 	ldw	r4,-4(fp)
 8249a38:	103ee83a 	callr	r2
 8249a3c:	00001f06 	br	8249abc <vgetc_locked+0xe4>
#endif   /* HT_EXTDEV */

#ifdef HT_RWVFS
      /* a freshly created file might not have a data buffer associated
         with it yet */
      if (vfd->file->data == NULL)
 8249a40:	e0bfff17 	ldw	r2,-4(fp)
 8249a44:	10800117 	ldw	r2,4(r2)
 8249a48:	10800617 	ldw	r2,24(r2)
 8249a4c:	1000021e 	bne	r2,zero,8249a58 <vgetc_locked+0x80>
         return EOF;
 8249a50:	00bfffc4 	movi	r2,-1
 8249a54:	00001906 	br	8249abc <vgetc_locked+0xe4>
      }
      else  /* HTML compression flag not set */
      {
#endif   /* HTML_COMPRESSION */
         /* Check to see if read has advanced to end of file */
         if (vfd->cmploc >= (vfd->file->data + vfd->file->comp_size))
 8249a58:	e0bfff17 	ldw	r2,-4(fp)
 8249a5c:	10c00217 	ldw	r3,8(r2)
 8249a60:	e0bfff17 	ldw	r2,-4(fp)
 8249a64:	10800117 	ldw	r2,4(r2)
 8249a68:	11000617 	ldw	r4,24(r2)
 8249a6c:	e0bfff17 	ldw	r2,-4(fp)
 8249a70:	10800117 	ldw	r2,4(r2)
 8249a74:	10800817 	ldw	r2,32(r2)
 8249a78:	2085883a 	add	r2,r4,r2
 8249a7c:	18800336 	bltu	r3,r2,8249a8c <vgetc_locked+0xb4>
            chr = EOF;
 8249a80:	00bfffc4 	movi	r2,-1
 8249a84:	e0bffd15 	stw	r2,-12(fp)
 8249a88:	00000806 	br	8249aac <vgetc_locked+0xd4>
         else  /* else just get next char to return */
            chr = *(vfd->cmploc++);
 8249a8c:	e0bfff17 	ldw	r2,-4(fp)
 8249a90:	10800217 	ldw	r2,8(r2)
 8249a94:	11000044 	addi	r4,r2,1
 8249a98:	e0ffff17 	ldw	r3,-4(fp)
 8249a9c:	19000215 	stw	r4,8(r3)
 8249aa0:	10800003 	ldbu	r2,0(r2)
 8249aa4:	10803fcc 	andi	r2,r2,255
 8249aa8:	e0bffd15 	stw	r2,-12(fp)
#ifdef HTML_COMPRESSION
      }  /* need to close brace form if...else; */
#endif   /* HTML_COMPRESSION */

      return chr;
 8249aac:	e0bffd17 	ldw	r2,-12(fp)
 8249ab0:	00000206 	br	8249abc <vgetc_locked+0xe4>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(getc((FILE*)vfd));
#else
   dtrap(); /* can this happen? */
 8249ab4:	822d5940 	call	822d594 <dtrap>
   return EOF;
 8249ab8:	00bfffc4 	movi	r2,-1
#endif   /* HT_LOCALFS */
}
 8249abc:	e037883a 	mov	sp,fp
 8249ac0:	dfc00117 	ldw	ra,4(sp)
 8249ac4:	df000017 	ldw	fp,0(sp)
 8249ac8:	dec00204 	addi	sp,sp,8
 8249acc:	f800283a 	ret

08249ad0 <vgetc>:
 * RETURNS: 
 */

int
vgetc(VFILE * vfd)
{
 8249ad0:	defffc04 	addi	sp,sp,-16
 8249ad4:	dfc00315 	stw	ra,12(sp)
 8249ad8:	df000215 	stw	fp,8(sp)
 8249adc:	df000204 	addi	fp,sp,8
 8249ae0:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 8249ae4:	01000144 	movi	r4,5
 8249ae8:	822dba80 	call	822dba8 <wait_app_sem>

   /* get the character */
   rc = vgetc_locked(vfd);
 8249aec:	e13fff17 	ldw	r4,-4(fp)
 8249af0:	82499d80 	call	82499d8 <vgetc_locked>
 8249af4:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 8249af8:	01000144 	movi	r4,5
 8249afc:	822dc640 	call	822dc64 <post_app_sem>
   return rc;
 8249b00:	e0bffe17 	ldw	r2,-8(fp)
}
 8249b04:	e037883a 	mov	sp,fp
 8249b08:	dfc00117 	ldw	ra,4(sp)
 8249b0c:	df000017 	ldw	fp,0(sp)
 8249b10:	dec00204 	addi	sp,sp,8
 8249b14:	f800283a 	ret

08249b18 <vfslookup_locked>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup_locked(char * name)
{
 8249b18:	defffb04 	addi	sp,sp,-20
 8249b1c:	dfc00415 	stw	ra,16(sp)
 8249b20:	df000315 	stw	fp,12(sp)
 8249b24:	df000304 	addi	fp,sp,12
 8249b28:	e13fff15 	stw	r4,-4(fp)

#ifdef VFS_STRIPPATH
   char *   cp;

   /* If root path is prepended to name, skip past it */
   if (*name == '/' || *name == '\\')
 8249b2c:	e0bfff17 	ldw	r2,-4(fp)
 8249b30:	10800003 	ldbu	r2,0(r2)
 8249b34:	10803fcc 	andi	r2,r2,255
 8249b38:	1080201c 	xori	r2,r2,128
 8249b3c:	10bfe004 	addi	r2,r2,-128
 8249b40:	10800be0 	cmpeqi	r2,r2,47
 8249b44:	1000071e 	bne	r2,zero,8249b64 <vfslookup_locked+0x4c>
 8249b48:	e0bfff17 	ldw	r2,-4(fp)
 8249b4c:	10800003 	ldbu	r2,0(r2)
 8249b50:	10803fcc 	andi	r2,r2,255
 8249b54:	1080201c 	xori	r2,r2,128
 8249b58:	10bfe004 	addi	r2,r2,-128
 8249b5c:	10801718 	cmpnei	r2,r2,92
 8249b60:	1000191e 	bne	r2,zero,8249bc8 <vfslookup_locked+0xb0>
   {
      cp = strippath(name);
 8249b64:	e13fff17 	ldw	r4,-4(fp)
 8249b68:	8249c840 	call	8249c84 <strippath>
 8249b6c:	e0bffe15 	stw	r2,-8(fp)

      if (!cp) /* strippath coundn't match our path */
 8249b70:	e0bffe17 	ldw	r2,-8(fp)
 8249b74:	1000121e 	bne	r2,zero,8249bc0 <vfslookup_locked+0xa8>
      {
         /* Files like "/hub47.gif" need to be taken care of */
         if (*name == '/' || *name == '\\')
 8249b78:	e0bfff17 	ldw	r2,-4(fp)
 8249b7c:	10800003 	ldbu	r2,0(r2)
 8249b80:	10803fcc 	andi	r2,r2,255
 8249b84:	1080201c 	xori	r2,r2,128
 8249b88:	10bfe004 	addi	r2,r2,-128
 8249b8c:	10800be0 	cmpeqi	r2,r2,47
 8249b90:	1000071e 	bne	r2,zero,8249bb0 <vfslookup_locked+0x98>
 8249b94:	e0bfff17 	ldw	r2,-4(fp)
 8249b98:	10800003 	ldbu	r2,0(r2)
 8249b9c:	10803fcc 	andi	r2,r2,255
 8249ba0:	1080201c 	xori	r2,r2,128
 8249ba4:	10bfe004 	addi	r2,r2,-128
 8249ba8:	10801718 	cmpnei	r2,r2,92
 8249bac:	1000061e 	bne	r2,zero,8249bc8 <vfslookup_locked+0xb0>
            name++;
 8249bb0:	e0bfff17 	ldw	r2,-4(fp)
 8249bb4:	10800044 	addi	r2,r2,1
 8249bb8:	e0bfff15 	stw	r2,-4(fp)
 8249bbc:	00000206 	br	8249bc8 <vfslookup_locked+0xb0>
      }
      else
         name = cp ;
 8249bc0:	e0bffe17 	ldw	r2,-8(fp)
 8249bc4:	e0bfff15 	stw	r2,-4(fp)
   }
#endif   /* VFS_STRIPPATH */

   /* see if there is a question mark in the file name */
   if (strchr(name,'?'))
 8249bc8:	01400fc4 	movi	r5,63
 8249bcc:	e13fff17 	ldw	r4,-4(fp)
 8249bd0:	82037840 	call	8203784 <strchr>
 8249bd4:	10000326 	beq	r2,zero,8249be4 <vfslookup_locked+0xcc>
   {
      dtrap(); /* is this still allowed? */
 8249bd8:	822d5940 	call	822d594 <dtrap>
      return NULL;
 8249bdc:	0005883a 	mov	r2,zero
 8249be0:	00001106 	br	8249c28 <vfslookup_locked+0x110>
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 8249be4:	d0a0d617 	ldw	r2,-31912(gp)
 8249be8:	e0bffd15 	stw	r2,-12(fp)
 8249bec:	00000b06 	br	8249c1c <vfslookup_locked+0x104>
   {
      if (strcmp(name, vp->name) == 0)
 8249bf0:	e0bffd17 	ldw	r2,-12(fp)
 8249bf4:	10800104 	addi	r2,r2,4
 8249bf8:	100b883a 	mov	r5,r2
 8249bfc:	e13fff17 	ldw	r4,-4(fp)
 8249c00:	820dfac0 	call	820dfac <strcmp>
 8249c04:	1000021e 	bne	r2,zero,8249c10 <vfslookup_locked+0xf8>
         return vp;
 8249c08:	e0bffd17 	ldw	r2,-12(fp)
 8249c0c:	00000606 	br	8249c28 <vfslookup_locked+0x110>
   {
      dtrap(); /* is this still allowed? */
      return NULL;
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 8249c10:	e0bffd17 	ldw	r2,-12(fp)
 8249c14:	10800017 	ldw	r2,0(r2)
 8249c18:	e0bffd15 	stw	r2,-12(fp)
 8249c1c:	e0bffd17 	ldw	r2,-12(fp)
 8249c20:	103ff31e 	bne	r2,zero,8249bf0 <vfslookup_locked+0xd8>
   {
      if (strcmp(name, vp->name) == 0)
         return vp;
   }

   return NULL;   /* fall to here if not found in for loop */
 8249c24:	0005883a 	mov	r2,zero
}
 8249c28:	e037883a 	mov	sp,fp
 8249c2c:	dfc00117 	ldw	ra,4(sp)
 8249c30:	df000017 	ldw	fp,0(sp)
 8249c34:	dec00204 	addi	sp,sp,8
 8249c38:	f800283a 	ret

08249c3c <vfslookup>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup(char * name) 
{
 8249c3c:	defffc04 	addi	sp,sp,-16
 8249c40:	dfc00315 	stw	ra,12(sp)
 8249c44:	df000215 	stw	fp,8(sp)
 8249c48:	df000204 	addi	fp,sp,8
 8249c4c:	e13fff15 	stw	r4,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfslookup() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 8249c50:	01000144 	movi	r4,5
 8249c54:	822dba80 	call	822dba8 <wait_app_sem>

   /* do the lookup */
   vp = vfslookup_locked(name);
 8249c58:	e13fff17 	ldw	r4,-4(fp)
 8249c5c:	8249b180 	call	8249b18 <vfslookup_locked>
 8249c60:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 8249c64:	01000144 	movi	r4,5
 8249c68:	822dc640 	call	822dc64 <post_app_sem>
   return vp;
 8249c6c:	e0bffe17 	ldw	r2,-8(fp)
}
 8249c70:	e037883a 	mov	sp,fp
 8249c74:	dfc00117 	ldw	ra,4(sp)
 8249c78:	df000017 	ldw	fp,0(sp)
 8249c7c:	dec00204 	addi	sp,sp,8
 8249c80:	f800283a 	ret

08249c84 <strippath>:
 * have the http_root_path prepended; or on any error. 
 */

char * 
strippath(char * name)
{
 8249c84:	defff904 	addi	sp,sp,-28
 8249c88:	dfc00615 	stw	ra,24(sp)
 8249c8c:	df000515 	stw	fp,20(sp)
 8249c90:	df000504 	addi	fp,sp,20
 8249c94:	e13fff15 	stw	r4,-4(fp)
   char *   path; /* pointer into system path */
   char *   ptmp; /* another pointer into path */
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
 8249c98:	e13fff17 	ldw	r4,-4(fp)
 8249c9c:	8228de40 	call	8228de4 <uslash>
 8249ca0:	e0bffc15 	stw	r2,-16(fp)
   path = http_root_path; /* The servers root path, at least one UNIX slash */
 8249ca4:	d0a05517 	ldw	r2,-32428(gp)
 8249ca8:	e0bffb15 	stw	r2,-20(fp)
   while (*path && *ntmp)
 8249cac:	00003a06 	br	8249d98 <strippath+0x114>
   {
      while (*path == '/') path++;   /* strip leading slash */
 8249cb0:	e0bffb17 	ldw	r2,-20(fp)
 8249cb4:	10800044 	addi	r2,r2,1
 8249cb8:	e0bffb15 	stw	r2,-20(fp)
 8249cbc:	e0bffb17 	ldw	r2,-20(fp)
 8249cc0:	10800003 	ldbu	r2,0(r2)
 8249cc4:	10803fcc 	andi	r2,r2,255
 8249cc8:	1080201c 	xori	r2,r2,128
 8249ccc:	10bfe004 	addi	r2,r2,-128
 8249cd0:	10800be0 	cmpeqi	r2,r2,47
 8249cd4:	103ff61e 	bne	r2,zero,8249cb0 <strippath+0x2c>
         if (*path == 0)
 8249cd8:	e0bffb17 	ldw	r2,-20(fp)
 8249cdc:	10800003 	ldbu	r2,0(r2)
 8249ce0:	10803fcc 	andi	r2,r2,255
 8249ce4:	1080201c 	xori	r2,r2,128
 8249ce8:	10bfe004 	addi	r2,r2,-128
 8249cec:	10003726 	beq	r2,zero,8249dcc <strippath+0x148>
         break;
      /* find number of chars in this directory layer's name */
      ptmp = strchr(path, '/');   /* location of next slash in path */
 8249cf0:	01400bc4 	movi	r5,47
 8249cf4:	e13ffb17 	ldw	r4,-20(fp)
 8249cf8:	82037840 	call	8203784 <strchr>
 8249cfc:	e0bffe15 	stw	r2,-8(fp)
      if (ptmp)
 8249d00:	e0bffe17 	ldw	r2,-8(fp)
 8249d04:	10000526 	beq	r2,zero,8249d1c <strippath+0x98>
         dirlen = ptmp - path;
 8249d08:	e0fffe17 	ldw	r3,-8(fp)
 8249d0c:	e0bffb17 	ldw	r2,-20(fp)
 8249d10:	1885c83a 	sub	r2,r3,r2
 8249d14:	e0bffd15 	stw	r2,-12(fp)
 8249d18:	00000706 	br	8249d38 <strippath+0xb4>
      else
         dirlen = strlen(path);
 8249d1c:	e13ffb17 	ldw	r4,-20(fp)
 8249d20:	8203f600 	call	8203f60 <strlen>
 8249d24:	e0bffd15 	stw	r2,-12(fp)

      while (*ntmp == '/') ntmp++;   /* strip leading slash */
 8249d28:	00000306 	br	8249d38 <strippath+0xb4>
 8249d2c:	e0bffc17 	ldw	r2,-16(fp)
 8249d30:	10800044 	addi	r2,r2,1
 8249d34:	e0bffc15 	stw	r2,-16(fp)
 8249d38:	e0bffc17 	ldw	r2,-16(fp)
 8249d3c:	10800003 	ldbu	r2,0(r2)
 8249d40:	10803fcc 	andi	r2,r2,255
 8249d44:	1080201c 	xori	r2,r2,128
 8249d48:	10bfe004 	addi	r2,r2,-128
 8249d4c:	10800be0 	cmpeqi	r2,r2,47
 8249d50:	103ff61e 	bne	r2,zero,8249d2c <strippath+0xa8>
         if (strncmp(ntmp, path, dirlen) == 0)
 8249d54:	e0bffd17 	ldw	r2,-12(fp)
 8249d58:	100d883a 	mov	r6,r2
 8249d5c:	e17ffb17 	ldw	r5,-20(fp)
 8249d60:	e13ffc17 	ldw	r4,-16(fp)
 8249d64:	824b7480 	call	824b748 <strncmp>
 8249d68:	1000091e 	bne	r2,zero,8249d90 <strippath+0x10c>
      {
         path += dirlen;
 8249d6c:	e0bffd17 	ldw	r2,-12(fp)
 8249d70:	e0fffb17 	ldw	r3,-20(fp)
 8249d74:	1885883a 	add	r2,r3,r2
 8249d78:	e0bffb15 	stw	r2,-20(fp)
         ntmp += dirlen;
 8249d7c:	e0bffd17 	ldw	r2,-12(fp)
 8249d80:	e0fffc17 	ldw	r3,-16(fp)
 8249d84:	1885883a 	add	r2,r3,r2
 8249d88:	e0bffc15 	stw	r2,-16(fp)
 8249d8c:	00000206 	br	8249d98 <strippath+0x114>
      }
      else
         return NULL;   /* didn't match */
 8249d90:	0005883a 	mov	r2,zero
 8249d94:	00002906 	br	8249e3c <strippath+0x1b8>
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
   path = http_root_path; /* The servers root path, at least one UNIX slash */
   while (*path && *ntmp)
 8249d98:	e0bffb17 	ldw	r2,-20(fp)
 8249d9c:	10800003 	ldbu	r2,0(r2)
 8249da0:	10803fcc 	andi	r2,r2,255
 8249da4:	1080201c 	xori	r2,r2,128
 8249da8:	10bfe004 	addi	r2,r2,-128
 8249dac:	10000826 	beq	r2,zero,8249dd0 <strippath+0x14c>
 8249db0:	e0bffc17 	ldw	r2,-16(fp)
 8249db4:	10800003 	ldbu	r2,0(r2)
 8249db8:	10803fcc 	andi	r2,r2,255
 8249dbc:	1080201c 	xori	r2,r2,128
 8249dc0:	10bfe004 	addi	r2,r2,-128
 8249dc4:	103fbd1e 	bne	r2,zero,8249cbc <strippath+0x38>
 8249dc8:	00000106 	br	8249dd0 <strippath+0x14c>
   {
      while (*path == '/') path++;   /* strip leading slash */
         if (*path == 0)
         break;
 8249dcc:	0001883a 	nop
         ntmp += dirlen;
      }
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
 8249dd0:	e0bffb17 	ldw	r2,-20(fp)
 8249dd4:	10800003 	ldbu	r2,0(r2)
 8249dd8:	10803fcc 	andi	r2,r2,255
 8249ddc:	1080201c 	xori	r2,r2,128
 8249de0:	10bfe004 	addi	r2,r2,-128
 8249de4:	1000141e 	bne	r2,zero,8249e38 <strippath+0x1b4>
   {
      while (*ntmp == '\\' || *ntmp == '/')
 8249de8:	00000306 	br	8249df8 <strippath+0x174>
         ntmp++;
 8249dec:	e0bffc17 	ldw	r2,-16(fp)
 8249df0:	10800044 	addi	r2,r2,1
 8249df4:	e0bffc15 	stw	r2,-16(fp)
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
   {
      while (*ntmp == '\\' || *ntmp == '/')
 8249df8:	e0bffc17 	ldw	r2,-16(fp)
 8249dfc:	10800003 	ldbu	r2,0(r2)
 8249e00:	10803fcc 	andi	r2,r2,255
 8249e04:	1080201c 	xori	r2,r2,128
 8249e08:	10bfe004 	addi	r2,r2,-128
 8249e0c:	10801720 	cmpeqi	r2,r2,92
 8249e10:	103ff61e 	bne	r2,zero,8249dec <strippath+0x168>
 8249e14:	e0bffc17 	ldw	r2,-16(fp)
 8249e18:	10800003 	ldbu	r2,0(r2)
 8249e1c:	10803fcc 	andi	r2,r2,255
 8249e20:	1080201c 	xori	r2,r2,128
 8249e24:	10bfe004 	addi	r2,r2,-128
 8249e28:	10800be0 	cmpeqi	r2,r2,47
 8249e2c:	103fef1e 	bne	r2,zero,8249dec <strippath+0x168>
         ntmp++;
      return ntmp;
 8249e30:	e0bffc17 	ldw	r2,-16(fp)
 8249e34:	00000106 	br	8249e3c <strippath+0x1b8>
   }
   else
      return NULL;
 8249e38:	0005883a 	mov	r2,zero
}
 8249e3c:	e037883a 	mov	sp,fp
 8249e40:	dfc00117 	ldw	ra,4(sp)
 8249e44:	df000017 	ldw	fp,0(sp)
 8249e48:	dec00204 	addi	sp,sp,8
 8249e4c:	f800283a 	ret

08249e50 <isvfile_locked>:
 * RETURNS: 
 */

int
isvfile_locked(VFILE * vfp)
{
 8249e50:	defffd04 	addi	sp,sp,-12
 8249e54:	df000215 	stw	fp,8(sp)
 8249e58:	df000204 	addi	fp,sp,8
 8249e5c:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 8249e60:	d0a0d517 	ldw	r2,-31916(gp)
 8249e64:	e0bffe15 	stw	r2,-8(fp)
 8249e68:	00000806 	br	8249e8c <isvfile_locked+0x3c>
      if (vtmp == vfp)
 8249e6c:	e0fffe17 	ldw	r3,-8(fp)
 8249e70:	e0bfff17 	ldw	r2,-4(fp)
 8249e74:	1880021e 	bne	r3,r2,8249e80 <isvfile_locked+0x30>
      return TRUE;
 8249e78:	00800044 	movi	r2,1
 8249e7c:	00000606 	br	8249e98 <isvfile_locked+0x48>
int
isvfile_locked(VFILE * vfp)
{
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 8249e80:	e0bffe17 	ldw	r2,-8(fp)
 8249e84:	10800017 	ldw	r2,0(r2)
 8249e88:	e0bffe15 	stw	r2,-8(fp)
 8249e8c:	e0bffe17 	ldw	r2,-8(fp)
 8249e90:	103ff61e 	bne	r2,zero,8249e6c <isvfile_locked+0x1c>
      if (vtmp == vfp)
      return TRUE;

   return FALSE;  /* passed pointer not found in list */
 8249e94:	0005883a 	mov	r2,zero
}
 8249e98:	e037883a 	mov	sp,fp
 8249e9c:	df000017 	ldw	fp,0(sp)
 8249ea0:	dec00104 	addi	sp,sp,4
 8249ea4:	f800283a 	ret

08249ea8 <isvfile>:
 * RETURNS: 
 */

int
isvfile(VFILE * vfp)
{
 8249ea8:	defffc04 	addi	sp,sp,-16
 8249eac:	dfc00315 	stw	ra,12(sp)
 8249eb0:	df000215 	stw	fp,8(sp)
 8249eb4:	df000204 	addi	fp,sp,8
 8249eb8:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 8249ebc:	01000144 	movi	r4,5
 8249ec0:	822dba80 	call	822dba8 <wait_app_sem>

   /* do the lookup */
   rc = isvfile_locked(vfp);
 8249ec4:	e13fff17 	ldw	r4,-4(fp)
 8249ec8:	8249e500 	call	8249e50 <isvfile_locked>
 8249ecc:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 8249ed0:	01000144 	movi	r4,5
 8249ed4:	822dc640 	call	822dc64 <post_app_sem>
   return rc;
 8249ed8:	e0bffe17 	ldw	r2,-8(fp)
}
 8249edc:	e037883a 	mov	sp,fp
 8249ee0:	dfc00117 	ldw	ra,4(sp)
 8249ee4:	df000017 	ldw	fp,0(sp)
 8249ee8:	dec00204 	addi	sp,sp,8
 8249eec:	f800283a 	ret

08249ef0 <vferror>:
 * RETURNS: 
 */

int
vferror(VFILE * vfd)
{
 8249ef0:	defffd04 	addi	sp,sp,-12
 8249ef4:	dfc00215 	stw	ra,8(sp)
 8249ef8:	df000115 	stw	fp,4(sp)
 8249efc:	df000104 	addi	fp,sp,4
 8249f00:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 8249f04:	01000144 	movi	r4,5
 8249f08:	822dba80 	call	822dba8 <wait_app_sem>

   if (isvfile_locked(vfd))
 8249f0c:	e13fff17 	ldw	r4,-4(fp)
 8249f10:	8249e500 	call	8249e50 <isvfile_locked>
 8249f14:	10000526 	beq	r2,zero,8249f2c <vferror+0x3c>
   {
      vfs_unlock();
 8249f18:	01000144 	movi	r4,5
 8249f1c:	822dc640 	call	822dc64 <post_app_sem>

      return vfd->error;
 8249f20:	e0bfff17 	ldw	r2,-4(fp)
 8249f24:	10800417 	ldw	r2,16(r2)
 8249f28:	00000306 	br	8249f38 <vferror+0x48>
   }

   vfs_unlock();
 8249f2c:	01000144 	movi	r4,5
 8249f30:	822dc640 	call	822dc64 <post_app_sem>

#ifdef HT_LOCALFS
   return(ferror((FILE*)vfd));
#else /* not a VFILE, and no local FS */
   return -1;  /* should this be an error? */
 8249f34:	00bfffc4 	movi	r2,-1
#endif   /* HT_LOCALFS */
}
 8249f38:	e037883a 	mov	sp,fp
 8249f3c:	dfc00117 	ldw	ra,4(sp)
 8249f40:	df000017 	ldw	fp,0(sp)
 8249f44:	dec00204 	addi	sp,sp,8
 8249f48:	f800283a 	ret

08249f4c <vclearerr>:
 *
 * RETURNS: 
 */

void vclearerr(VFILE * vfd)
{
 8249f4c:	defffd04 	addi	sp,sp,-12
 8249f50:	dfc00215 	stw	ra,8(sp)
 8249f54:	df000115 	stw	fp,4(sp)
 8249f58:	df000104 	addi	fp,sp,4
 8249f5c:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 8249f60:	01000144 	movi	r4,5
 8249f64:	822dba80 	call	822dba8 <wait_app_sem>

   if (isvfile_locked(vfd))
 8249f68:	e13fff17 	ldw	r4,-4(fp)
 8249f6c:	8249e500 	call	8249e50 <isvfile_locked>
 8249f70:	10000526 	beq	r2,zero,8249f88 <vclearerr+0x3c>
   {
      vfs_unlock();
 8249f74:	01000144 	movi	r4,5
 8249f78:	822dc640 	call	822dc64 <post_app_sem>

      vfd->error = 0;
 8249f7c:	e0bfff17 	ldw	r2,-4(fp)
 8249f80:	10000415 	stw	zero,16(r2)
      return;
 8249f84:	00000206 	br	8249f90 <vclearerr+0x44>
   }

   vfs_unlock();
 8249f88:	01000144 	movi	r4,5
 8249f8c:	822dc640 	call	822dc64 <post_app_sem>

#ifdef HT_LOCALFS
   clearerr((FILE *) vfd);
#endif   /* HT_LOCALFS */
}
 8249f90:	e037883a 	mov	sp,fp
 8249f94:	dfc00117 	ldw	ra,4(sp)
 8249f98:	df000017 	ldw	fp,0(sp)
 8249f9c:	dec00204 	addi	sp,sp,8
 8249fa0:	f800283a 	ret

08249fa4 <prep_vfs>:
 * PARAMS: NONE
 *
 * RETURNS: Error Code or 0 for OK
 */
int prep_vfs(void)
{
 8249fa4:	defffe04 	addi	sp,sp,-8
 8249fa8:	df000115 	stw	fp,4(sp)
 8249fac:	df000104 	addi	fp,sp,4
int e = 0;
 8249fb0:	e03fff15 	stw	zero,-4(fp)
   {
      dprintf("unable to install VFS NVPARMS, reconfigure nv_formats[]\n");
      dtrap();
   }
#endif   /* INCLUDE_NVPARMS */
   return e;
 8249fb4:	e0bfff17 	ldw	r2,-4(fp)
}
 8249fb8:	e037883a 	mov	sp,fp
 8249fbc:	df000017 	ldw	fp,0(sp)
 8249fc0:	dec00104 	addi	sp,sp,4
 8249fc4:	f800283a 	ret

08249fc8 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 8249fc8:	defffa04 	addi	sp,sp,-24
 8249fcc:	dfc00515 	stw	ra,20(sp)
 8249fd0:	df000415 	stw	fp,16(sp)
 8249fd4:	df000404 	addi	fp,sp,16
 8249fd8:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
 8249fdc:	008000c4 	movi	r2,3
 8249fe0:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
 8249fe4:	e0fffd17 	ldw	r3,-12(fp)
 8249fe8:	008003f4 	movhi	r2,15
 8249fec:	10909004 	addi	r2,r2,16960
 8249ff0:	1885383a 	mul	r2,r3,r2
 8249ff4:	100b883a 	mov	r5,r2
 8249ff8:	0100bef4 	movhi	r4,763
 8249ffc:	213c2004 	addi	r4,r4,-3968
 824a000:	8202c100 	call	8202c10 <__udivsi3>
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
 824a004:	100b883a 	mov	r5,r2
 824a008:	01200034 	movhi	r4,32768
 824a00c:	213fffc4 	addi	r4,r4,-1
 824a010:	8202c100 	call	8202c10 <__udivsi3>
 824a014:	100b883a 	mov	r5,r2
 824a018:	e13fff17 	ldw	r4,-4(fp)
 824a01c:	8202c100 	call	8202c10 <__udivsi3>
 824a020:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 824a024:	e0bffe17 	ldw	r2,-8(fp)
 824a028:	10002a26 	beq	r2,zero,824a0d4 <alt_busy_sleep+0x10c>
  {
    for(i=0;i<big_loops;i++)
 824a02c:	e03ffc15 	stw	zero,-16(fp)
 824a030:	00001706 	br	824a090 <alt_busy_sleep+0xc8>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 824a034:	00a00034 	movhi	r2,32768
 824a038:	10bfffc4 	addi	r2,r2,-1
 824a03c:	10bfffc4 	addi	r2,r2,-1
 824a040:	103ffe1e 	bne	r2,zero,824a03c <alt_busy_sleep+0x74>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
 824a044:	e0fffd17 	ldw	r3,-12(fp)
 824a048:	008003f4 	movhi	r2,15
 824a04c:	10909004 	addi	r2,r2,16960
 824a050:	1885383a 	mul	r2,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 824a054:	100b883a 	mov	r5,r2
 824a058:	0100bef4 	movhi	r4,763
 824a05c:	213c2004 	addi	r4,r4,-3968
 824a060:	8202c100 	call	8202c10 <__udivsi3>
 824a064:	100b883a 	mov	r5,r2
 824a068:	01200034 	movhi	r4,32768
 824a06c:	213fffc4 	addi	r4,r4,-1
 824a070:	8202c100 	call	8202c10 <__udivsi3>
 824a074:	1007883a 	mov	r3,r2
 824a078:	e0bfff17 	ldw	r2,-4(fp)
 824a07c:	10c5c83a 	sub	r2,r2,r3
 824a080:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 824a084:	e0bffc17 	ldw	r2,-16(fp)
 824a088:	10800044 	addi	r2,r2,1
 824a08c:	e0bffc15 	stw	r2,-16(fp)
 824a090:	e0fffc17 	ldw	r3,-16(fp)
 824a094:	e0bffe17 	ldw	r2,-8(fp)
 824a098:	18bfe616 	blt	r3,r2,824a034 <alt_busy_sleep+0x6c>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 824a09c:	e0fffd17 	ldw	r3,-12(fp)
 824a0a0:	008003f4 	movhi	r2,15
 824a0a4:	10909004 	addi	r2,r2,16960
 824a0a8:	1885383a 	mul	r2,r3,r2
 824a0ac:	100b883a 	mov	r5,r2
 824a0b0:	0100bef4 	movhi	r4,763
 824a0b4:	213c2004 	addi	r4,r4,-3968
 824a0b8:	8202c100 	call	8202c10 <__udivsi3>
 824a0bc:	1007883a 	mov	r3,r2
 824a0c0:	e0bfff17 	ldw	r2,-4(fp)
 824a0c4:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 824a0c8:	10bfffc4 	addi	r2,r2,-1
 824a0cc:	103ffe1e 	bne	r2,zero,824a0c8 <alt_busy_sleep+0x100>
 824a0d0:	00000d06 	br	824a108 <alt_busy_sleep+0x140>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 824a0d4:	e0fffd17 	ldw	r3,-12(fp)
 824a0d8:	008003f4 	movhi	r2,15
 824a0dc:	10909004 	addi	r2,r2,16960
 824a0e0:	1885383a 	mul	r2,r3,r2
 824a0e4:	100b883a 	mov	r5,r2
 824a0e8:	0100bef4 	movhi	r4,763
 824a0ec:	213c2004 	addi	r4,r4,-3968
 824a0f0:	8202c100 	call	8202c10 <__udivsi3>
 824a0f4:	1007883a 	mov	r3,r2
 824a0f8:	e0bfff17 	ldw	r2,-4(fp)
 824a0fc:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 824a100:	10bfffc4 	addi	r2,r2,-1
 824a104:	00bffe16 	blt	zero,r2,824a100 <alt_busy_sleep+0x138>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 824a108:	0005883a 	mov	r2,zero
}
 824a10c:	e037883a 	mov	sp,fp
 824a110:	dfc00117 	ldw	ra,4(sp)
 824a114:	df000017 	ldw	fp,0(sp)
 824a118:	dec00204 	addi	sp,sp,8
 824a11c:	f800283a 	ret

0824a120 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 824a120:	defffe04 	addi	sp,sp,-8
 824a124:	dfc00115 	stw	ra,4(sp)
 824a128:	df000015 	stw	fp,0(sp)
 824a12c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 824a130:	d0a04717 	ldw	r2,-32484(gp)
 824a134:	10000326 	beq	r2,zero,824a144 <alt_get_errno+0x24>
 824a138:	d0a04717 	ldw	r2,-32484(gp)
 824a13c:	103ee83a 	callr	r2
 824a140:	00000106 	br	824a148 <alt_get_errno+0x28>
 824a144:	d0a06304 	addi	r2,gp,-32372
}
 824a148:	e037883a 	mov	sp,fp
 824a14c:	dfc00117 	ldw	ra,4(sp)
 824a150:	df000017 	ldw	fp,0(sp)
 824a154:	dec00204 	addi	sp,sp,8
 824a158:	f800283a 	ret

0824a15c <alt_fcntl>:
 *
 * ALT_FCNTL is mapped onto the fcntl() system call in alt_syscall.h
 */
 
int ALT_FCNTL (int file, int cmd, ...)
{ 
 824a15c:	defff704 	addi	sp,sp,-36
 824a160:	dfc00615 	stw	ra,24(sp)
 824a164:	df000515 	stw	fp,20(sp)
 824a168:	df000504 	addi	fp,sp,20
 824a16c:	e13ffe15 	stw	r4,-8(fp)
 824a170:	e17fff15 	stw	r5,-4(fp)
 824a174:	e1800215 	stw	r6,8(fp)
 824a178:	e1c00315 	stw	r7,12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 824a17c:	e0bffe17 	ldw	r2,-8(fp)
 824a180:	10000616 	blt	r2,zero,824a19c <alt_fcntl+0x40>
 824a184:	e0bffe17 	ldw	r2,-8(fp)
 824a188:	10c00324 	muli	r3,r2,12
 824a18c:	00820974 	movhi	r2,2085
 824a190:	108ed304 	addi	r2,r2,15180
 824a194:	1885883a 	add	r2,r3,r2
 824a198:	00000106 	br	824a1a0 <alt_fcntl+0x44>
 824a19c:	0005883a 	mov	r2,zero
 824a1a0:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 824a1a4:	e0bffb17 	ldw	r2,-20(fp)
 824a1a8:	10002a26 	beq	r2,zero,824a254 <alt_fcntl+0xf8>
  {
    switch (cmd)
 824a1ac:	e0bfff17 	ldw	r2,-4(fp)
 824a1b0:	10c000e0 	cmpeqi	r3,r2,3
 824a1b4:	1800031e 	bne	r3,zero,824a1c4 <alt_fcntl+0x68>
 824a1b8:	10800120 	cmpeqi	r2,r2,4
 824a1bc:	1000071e 	bne	r2,zero,824a1dc <alt_fcntl+0x80>
 824a1c0:	00001e06 	br	824a23c <alt_fcntl+0xe0>
    {
    case F_GETFL:
      return fd->fd_flags & ~((alt_u32) ALT_FD_FLAGS_MASK);
 824a1c4:	e0bffb17 	ldw	r2,-20(fp)
 824a1c8:	10c00217 	ldw	r3,8(r2)
 824a1cc:	00900034 	movhi	r2,16384
 824a1d0:	10bfffc4 	addi	r2,r2,-1
 824a1d4:	1884703a 	and	r2,r3,r2
 824a1d8:	00002306 	br	824a268 <alt_fcntl+0x10c>
    case F_SETFL:
      va_start(argp, cmd);
 824a1dc:	e0800204 	addi	r2,fp,8
 824a1e0:	e0bffd15 	stw	r2,-12(fp)
      flags = va_arg(argp, long);
 824a1e4:	e0bffd17 	ldw	r2,-12(fp)
 824a1e8:	10c00104 	addi	r3,r2,4
 824a1ec:	e0fffd15 	stw	r3,-12(fp)
 824a1f0:	10800017 	ldw	r2,0(r2)
 824a1f4:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags &= ~ALT_FCNTL_FLAGS_MASK;
 824a1f8:	e0bffb17 	ldw	r2,-20(fp)
 824a1fc:	10c00217 	ldw	r3,8(r2)
 824a200:	00affdc4 	movi	r2,-16393
 824a204:	1886703a 	and	r3,r3,r2
 824a208:	e0bffb17 	ldw	r2,-20(fp)
 824a20c:	10c00215 	stw	r3,8(r2)
      fd->fd_flags |= (flags & ALT_FCNTL_FLAGS_MASK);
 824a210:	e0bffb17 	ldw	r2,-20(fp)
 824a214:	10800217 	ldw	r2,8(r2)
 824a218:	1007883a 	mov	r3,r2
 824a21c:	e0bffc17 	ldw	r2,-16(fp)
 824a220:	1090020c 	andi	r2,r2,16392
 824a224:	1884b03a 	or	r2,r3,r2
 824a228:	1007883a 	mov	r3,r2
 824a22c:	e0bffb17 	ldw	r2,-20(fp)
 824a230:	10c00215 	stw	r3,8(r2)
      va_end(argp);
      return 0;
 824a234:	0005883a 	mov	r2,zero
 824a238:	00000b06 	br	824a268 <alt_fcntl+0x10c>
    default:
      ALT_ERRNO = EINVAL;
 824a23c:	824a1200 	call	824a120 <alt_get_errno>
 824a240:	1007883a 	mov	r3,r2
 824a244:	00800584 	movi	r2,22
 824a248:	18800015 	stw	r2,0(r3)
      return -1;
 824a24c:	00bfffc4 	movi	r2,-1
 824a250:	00000506 	br	824a268 <alt_fcntl+0x10c>
    }
  }

  ALT_ERRNO = EBADFD;
 824a254:	824a1200 	call	824a120 <alt_get_errno>
 824a258:	1007883a 	mov	r3,r2
 824a25c:	00801444 	movi	r2,81
 824a260:	18800015 	stw	r2,0(r3)
  return -1;
 824a264:	00bfffc4 	movi	r2,-1
}
 824a268:	e037883a 	mov	sp,fp
 824a26c:	dfc00117 	ldw	ra,4(sp)
 824a270:	df000017 	ldw	fp,0(sp)
 824a274:	dec00404 	addi	sp,sp,16
 824a278:	f800283a 	ret

0824a27c <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 824a27c:	defffb04 	addi	sp,sp,-20
 824a280:	dfc00415 	stw	ra,16(sp)
 824a284:	df000315 	stw	fp,12(sp)
 824a288:	df000304 	addi	fp,sp,12
 824a28c:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 824a290:	d0a04217 	ldw	r2,-32504(gp)
 824a294:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 824a298:	00003106 	br	824a360 <alt_find_file+0xe4>
  {
    len = strlen(next->name);
 824a29c:	e0bffd17 	ldw	r2,-12(fp)
 824a2a0:	10800217 	ldw	r2,8(r2)
 824a2a4:	1009883a 	mov	r4,r2
 824a2a8:	8203f600 	call	8203f60 <strlen>
 824a2ac:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 824a2b0:	e0bffd17 	ldw	r2,-12(fp)
 824a2b4:	10c00217 	ldw	r3,8(r2)
 824a2b8:	e0bffe17 	ldw	r2,-8(fp)
 824a2bc:	10bfffc4 	addi	r2,r2,-1
 824a2c0:	1885883a 	add	r2,r3,r2
 824a2c4:	10800003 	ldbu	r2,0(r2)
 824a2c8:	10803fcc 	andi	r2,r2,255
 824a2cc:	1080201c 	xori	r2,r2,128
 824a2d0:	10bfe004 	addi	r2,r2,-128
 824a2d4:	10800bd8 	cmpnei	r2,r2,47
 824a2d8:	1000031e 	bne	r2,zero,824a2e8 <alt_find_file+0x6c>
    {
      len -= 1;
 824a2dc:	e0bffe17 	ldw	r2,-8(fp)
 824a2e0:	10bfffc4 	addi	r2,r2,-1
 824a2e4:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 824a2e8:	e0bffe17 	ldw	r2,-8(fp)
 824a2ec:	e0ffff17 	ldw	r3,-4(fp)
 824a2f0:	1885883a 	add	r2,r3,r2
 824a2f4:	10800003 	ldbu	r2,0(r2)
 824a2f8:	10803fcc 	andi	r2,r2,255
 824a2fc:	1080201c 	xori	r2,r2,128
 824a300:	10bfe004 	addi	r2,r2,-128
 824a304:	10800be0 	cmpeqi	r2,r2,47
 824a308:	1000081e 	bne	r2,zero,824a32c <alt_find_file+0xb0>
 824a30c:	e0bffe17 	ldw	r2,-8(fp)
 824a310:	e0ffff17 	ldw	r3,-4(fp)
 824a314:	1885883a 	add	r2,r3,r2
 824a318:	10800003 	ldbu	r2,0(r2)
 824a31c:	10803fcc 	andi	r2,r2,255
 824a320:	1080201c 	xori	r2,r2,128
 824a324:	10bfe004 	addi	r2,r2,-128
 824a328:	10000a1e 	bne	r2,zero,824a354 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
 824a32c:	e0bffd17 	ldw	r2,-12(fp)
 824a330:	10800217 	ldw	r2,8(r2)
 824a334:	e0fffe17 	ldw	r3,-8(fp)
 824a338:	180d883a 	mov	r6,r3
 824a33c:	e17fff17 	ldw	r5,-4(fp)
 824a340:	1009883a 	mov	r4,r2
 824a344:	820c5dc0 	call	820c5dc <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 824a348:	1000021e 	bne	r2,zero,824a354 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 824a34c:	e0bffd17 	ldw	r2,-12(fp)
 824a350:	00000706 	br	824a370 <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
 824a354:	e0bffd17 	ldw	r2,-12(fp)
 824a358:	10800017 	ldw	r2,0(r2)
 824a35c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 824a360:	e0fffd17 	ldw	r3,-12(fp)
 824a364:	d0a04204 	addi	r2,gp,-32504
 824a368:	18bfcc1e 	bne	r3,r2,824a29c <alt_find_file+0x20>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 824a36c:	0005883a 	mov	r2,zero
}
 824a370:	e037883a 	mov	sp,fp
 824a374:	dfc00117 	ldw	ra,4(sp)
 824a378:	df000017 	ldw	fp,0(sp)
 824a37c:	dec00204 	addi	sp,sp,8
 824a380:	f800283a 	ret

0824a384 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 824a384:	defff904 	addi	sp,sp,-28
 824a388:	dfc00615 	stw	ra,24(sp)
 824a38c:	df000515 	stw	fp,20(sp)
 824a390:	df000504 	addi	fp,sp,20
 824a394:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
 824a398:	00bffa04 	movi	r2,-24
 824a39c:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
 824a3a0:	d0a0b617 	ldw	r2,-32040(gp)
 824a3a4:	e0bffd15 	stw	r2,-12(fp)
 824a3a8:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 824a3ac:	e0bffe0b 	ldhu	r2,-8(fp)
 824a3b0:	e0fffe84 	addi	r3,fp,-6
 824a3b4:	180d883a 	mov	r6,r3
 824a3b8:	100b883a 	mov	r5,r2
 824a3bc:	e13ffd17 	ldw	r4,-12(fp)
 824a3c0:	821a0d40 	call	821a0d4 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 824a3c4:	e03ffb15 	stw	zero,-20(fp)
 824a3c8:	00001906 	br	824a430 <alt_get_fd+0xac>
  {
    if (!alt_fd_list[i].dev)
 824a3cc:	00820974 	movhi	r2,2085
 824a3d0:	108ed304 	addi	r2,r2,15180
 824a3d4:	e0fffb17 	ldw	r3,-20(fp)
 824a3d8:	18c00324 	muli	r3,r3,12
 824a3dc:	10c5883a 	add	r2,r2,r3
 824a3e0:	10800017 	ldw	r2,0(r2)
 824a3e4:	10000f1e 	bne	r2,zero,824a424 <alt_get_fd+0xa0>
    {
      alt_fd_list[i].dev = dev;
 824a3e8:	00820974 	movhi	r2,2085
 824a3ec:	108ed304 	addi	r2,r2,15180
 824a3f0:	e0fffb17 	ldw	r3,-20(fp)
 824a3f4:	18c00324 	muli	r3,r3,12
 824a3f8:	10c5883a 	add	r2,r2,r3
 824a3fc:	e0ffff17 	ldw	r3,-4(fp)
 824a400:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
 824a404:	d0e04617 	ldw	r3,-32488(gp)
 824a408:	e0bffb17 	ldw	r2,-20(fp)
 824a40c:	1880020e 	bge	r3,r2,824a418 <alt_get_fd+0x94>
      {
        alt_max_fd = i;
 824a410:	e0bffb17 	ldw	r2,-20(fp)
 824a414:	d0a04615 	stw	r2,-32488(gp)
      }
      rc = i;
 824a418:	e0bffb17 	ldw	r2,-20(fp)
 824a41c:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
 824a420:	00000606 	br	824a43c <alt_get_fd+0xb8>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 824a424:	e0bffb17 	ldw	r2,-20(fp)
 824a428:	10800044 	addi	r2,r2,1
 824a42c:	e0bffb15 	stw	r2,-20(fp)
 824a430:	e0bffb17 	ldw	r2,-20(fp)
 824a434:	10800810 	cmplti	r2,r2,32
 824a438:	103fe41e 	bne	r2,zero,824a3cc <alt_get_fd+0x48>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
 824a43c:	d0a0b617 	ldw	r2,-32040(gp)
 824a440:	1009883a 	mov	r4,r2
 824a444:	821a44c0 	call	821a44c <OSSemPost>

  return rc;
 824a448:	e0bffc17 	ldw	r2,-16(fp)
}
 824a44c:	e037883a 	mov	sp,fp
 824a450:	dfc00117 	ldw	ra,4(sp)
 824a454:	df000017 	ldw	fp,0(sp)
 824a458:	dec00204 	addi	sp,sp,8
 824a45c:	f800283a 	ret

0824a460 <icmprcv>:
};
#endif /* USER_PING_TSTAMP */

int
icmprcv(PACKET p)      /* the incoming packet */
{
 824a460:	deffef04 	addi	sp,sp,-68
 824a464:	dfc01015 	stw	ra,64(sp)
 824a468:	df000f15 	stw	fp,60(sp)
 824a46c:	dc400e15 	stw	r17,56(sp)
 824a470:	dc000d15 	stw	r16,52(sp)
 824a474:	df000f04 	addi	fp,sp,60
 824a478:	e13ffd15 	stw	r4,-12(fp)
   unsigned short xsum;
#ifdef FULL_ICMP
   struct redirect * rd;
   struct destun *   pdp;
#endif   /* FULL_ICMP */
   char sav_ch = 0;
 824a47c:	e03ff305 	stb	zero,-52(fp)
   int i;

   icmp_mib.icmpInMsgs++;                 /* received one more icmp */
 824a480:	008209b4 	movhi	r2,2086
 824a484:	10ba7f04 	addi	r2,r2,-5636
 824a488:	10800017 	ldw	r2,0(r2)
 824a48c:	10c00044 	addi	r3,r2,1
 824a490:	008209b4 	movhi	r2,2086
 824a494:	10ba7f04 	addi	r2,r2,-5636
 824a498:	10c00015 	stw	r3,0(r2)

   pip = ip_head(p);                      /* find IP header */
 824a49c:	e0bffd17 	ldw	r2,-12(fp)
 824a4a0:	10800317 	ldw	r2,12(r2)
 824a4a4:	e0bff415 	stw	r2,-48(fp)
   len = p->nb_plen - (ip_hlen(pip));     /* strip IP header length */
 824a4a8:	e0bffd17 	ldw	r2,-12(fp)
 824a4ac:	10c00417 	ldw	r3,16(r2)
 824a4b0:	e0bff417 	ldw	r2,-48(fp)
 824a4b4:	10800003 	ldbu	r2,0(r2)
 824a4b8:	10803fcc 	andi	r2,r2,255
 824a4bc:	108003cc 	andi	r2,r2,15
 824a4c0:	1085883a 	add	r2,r2,r2
 824a4c4:	1085883a 	add	r2,r2,r2
 824a4c8:	1885c83a 	sub	r2,r3,r2
 824a4cc:	e0bff515 	stw	r2,-44(fp)
   host = p->fhost;                       /* filled in by IP layer */
 824a4d0:	e0bffd17 	ldw	r2,-12(fp)
 824a4d4:	10800717 	ldw	r2,28(r2)
 824a4d8:	e0bff615 	stw	r2,-40(fp)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 824a4dc:	d0a08317 	ldw	r2,-32244(gp)
 824a4e0:	1081000c 	andi	r2,r2,1024
 824a4e4:	10001526 	beq	r2,zero,824a53c <icmprcv+0xdc>
 824a4e8:	d0a08317 	ldw	r2,-32244(gp)
 824a4ec:	1080800c 	andi	r2,r2,512
 824a4f0:	10001226 	beq	r2,zero,824a53c <icmprcv+0xdc>
      dprintf("ICMP: p[%u] from %u.%u.%u.%u\n", len, PUSH_IPADDR(host));
 824a4f4:	e0bff617 	ldw	r2,-40(fp)
 824a4f8:	11003fcc 	andi	r4,r2,255
 824a4fc:	e0bff617 	ldw	r2,-40(fp)
 824a500:	1004d23a 	srli	r2,r2,8
 824a504:	11403fcc 	andi	r5,r2,255
 824a508:	e0bff617 	ldw	r2,-40(fp)
 824a50c:	1004d43a 	srli	r2,r2,16
 824a510:	10803fcc 	andi	r2,r2,255
 824a514:	e0fff617 	ldw	r3,-40(fp)
 824a518:	1806d63a 	srli	r3,r3,24
 824a51c:	d8c00115 	stw	r3,4(sp)
 824a520:	d8800015 	stw	r2,0(sp)
 824a524:	280f883a 	mov	r7,r5
 824a528:	200d883a 	mov	r6,r4
 824a52c:	e17ff517 	ldw	r5,-44(fp)
 824a530:	01020974 	movhi	r4,2085
 824a534:	2106ec04 	addi	r4,r4,7088
 824a538:	82033a00 	call	82033a0 <printf>
#endif

   e = (struct ping *)ip_data(pip);       /* finally, extract ICMP header */
 824a53c:	e0bff417 	ldw	r2,-48(fp)
 824a540:	10800003 	ldbu	r2,0(r2)
 824a544:	10803fcc 	andi	r2,r2,255
 824a548:	108003cc 	andi	r2,r2,15
 824a54c:	1085883a 	add	r2,r2,r2
 824a550:	1085883a 	add	r2,r2,r2
 824a554:	1007883a 	mov	r3,r2
 824a558:	e0bff417 	ldw	r2,-48(fp)
 824a55c:	10c5883a 	add	r2,r2,r3
 824a560:	e0bff715 	stw	r2,-36(fp)

   osum = e->pchksum;
 824a564:	e0bff717 	ldw	r2,-36(fp)
 824a568:	1080008b 	ldhu	r2,2(r2)
 824a56c:	e0bff80d 	sth	r2,-32(fp)
   e->pchksum = 0;
 824a570:	e0bff717 	ldw	r2,-36(fp)
 824a574:	1000008d 	sth	zero,2(r2)

   if (len&1)
 824a578:	e0bff517 	ldw	r2,-44(fp)
 824a57c:	1080004c 	andi	r2,r2,1
 824a580:	10000926 	beq	r2,zero,824a5a8 <icmprcv+0x148>
   {
      sav_ch = *(((char *) e) + len);
 824a584:	e0fff717 	ldw	r3,-36(fp)
 824a588:	e0bff517 	ldw	r2,-44(fp)
 824a58c:	1885883a 	add	r2,r3,r2
 824a590:	10800003 	ldbu	r2,0(r2)
 824a594:	e0bff305 	stb	r2,-52(fp)
      ((char *)e)[len] = 0;
 824a598:	e0fff717 	ldw	r3,-36(fp)
 824a59c:	e0bff517 	ldw	r2,-44(fp)
 824a5a0:	1885883a 	add	r2,r3,r2
 824a5a4:	10000005 	stb	zero,0(r2)
   }

   xsum = ~cksum(e, (len+1)>>1);
 824a5a8:	e0bff517 	ldw	r2,-44(fp)
 824a5ac:	10800044 	addi	r2,r2,1
 824a5b0:	1004d07a 	srli	r2,r2,1
 824a5b4:	100b883a 	mov	r5,r2
 824a5b8:	e13ff717 	ldw	r4,-36(fp)
 824a5bc:	82287b40 	call	82287b4 <cksum>
 824a5c0:	0084303a 	nor	r2,zero,r2
 824a5c4:	e0bff88d 	sth	r2,-30(fp)
   if (len&1) *(((char *) e) + len) = sav_ch;
 824a5c8:	e0bff517 	ldw	r2,-44(fp)
 824a5cc:	1080004c 	andi	r2,r2,1
 824a5d0:	10000526 	beq	r2,zero,824a5e8 <icmprcv+0x188>
 824a5d4:	e0fff717 	ldw	r3,-36(fp)
 824a5d8:	e0bff517 	ldw	r2,-44(fp)
 824a5dc:	1885883a 	add	r2,r3,r2
 824a5e0:	e0fff303 	ldbu	r3,-52(fp)
 824a5e4:	10c00005 	stb	r3,0(r2)
   if (xsum != osum)
 824a5e8:	e0fff88b 	ldhu	r3,-30(fp)
 824a5ec:	e0bff80b 	ldhu	r2,-32(fp)
 824a5f0:	18802426 	beq	r3,r2,824a684 <icmprcv+0x224>
   {
      e->pchksum = osum;
 824a5f4:	e0bff717 	ldw	r2,-36(fp)
 824a5f8:	e0fff80b 	ldhu	r3,-32(fp)
 824a5fc:	10c0008d 	sth	r3,2(r2)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 824a600:	d0a08317 	ldw	r2,-32244(gp)
 824a604:	1081000c 	andi	r2,r2,1024
 824a608:	10000f26 	beq	r2,zero,824a648 <icmprcv+0x1e8>
 824a60c:	d0a08317 	ldw	r2,-32244(gp)
 824a610:	1080800c 	andi	r2,r2,512
 824a614:	10000c26 	beq	r2,zero,824a648 <icmprcv+0x1e8>
      {
         dprintf("ICMP: Bad xsum %04x should have been %04x\n",
 824a618:	e0bff80b 	ldhu	r2,-32(fp)
 824a61c:	e0fff88b 	ldhu	r3,-30(fp)
 824a620:	180d883a 	mov	r6,r3
 824a624:	100b883a 	mov	r5,r2
 824a628:	01020974 	movhi	r4,2085
 824a62c:	2106f404 	addi	r4,r4,7120
 824a630:	82033a00 	call	82033a0 <printf>
          osum, xsum);
         if (NDEBUG & DUMP) ip_dump(p);
 824a634:	d0a08317 	ldw	r2,-32244(gp)
 824a638:	1080008c 	andi	r2,r2,2
 824a63c:	10000226 	beq	r2,zero,824a648 <icmprcv+0x1e8>
 824a640:	e13ffd17 	ldw	r4,-12(fp)
 824a644:	8240a400 	call	8240a40 <ip_dump>
      }
#endif
      icmp_mib.icmpInErrors++;
 824a648:	008209b4 	movhi	r2,2086
 824a64c:	10ba7f04 	addi	r2,r2,-5636
 824a650:	10800117 	ldw	r2,4(r2)
 824a654:	10c00044 	addi	r3,r2,1
 824a658:	008209b4 	movhi	r2,2086
 824a65c:	10ba7f04 	addi	r2,r2,-5636
 824a660:	10c00115 	stw	r3,4(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824a664:	01000084 	movi	r4,2
 824a668:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free(p);
 824a66c:	e13ffd17 	ldw	r4,-12(fp)
 824a670:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824a674:	01000084 	movi	r4,2
 824a678:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 824a67c:	00bff804 	movi	r2,-32
 824a680:	00024906 	br	824afa8 <icmprcv+0xb48>
   }

   e->pchksum = osum;
 824a684:	e0bff717 	ldw	r2,-36(fp)
 824a688:	e0fff80b 	ldhu	r3,-32(fp)
 824a68c:	10c0008d 	sth	r3,2(r2)

   switch (e->ptype) 
 824a690:	e0bff717 	ldw	r2,-36(fp)
 824a694:	10800003 	ldbu	r2,0(r2)
 824a698:	10803fcc 	andi	r2,r2,255
 824a69c:	1080201c 	xori	r2,r2,128
 824a6a0:	10bfe004 	addi	r2,r2,-128
 824a6a4:	10c00428 	cmpgeui	r3,r2,16
 824a6a8:	1802251e 	bne	r3,zero,824af40 <icmprcv+0xae0>
 824a6ac:	100690ba 	slli	r3,r2,2
 824a6b0:	00820974 	movhi	r2,2085
 824a6b4:	10a9b104 	addi	r2,r2,-22844
 824a6b8:	1885883a 	add	r2,r3,r2
 824a6bc:	10800017 	ldw	r2,0(r2)
 824a6c0:	1000683a 	jmp	r2
 824a6c4:	0824a978 	rdprs	zero,at,-27995
 824a6c8:	0824af40 	call	824af4 <OSCtxSw_SWITCH_PC+0x824ab4>
 824a6cc:	0824af40 	call	824af4 <OSCtxSw_SWITCH_PC+0x824ab4>
 824a6d0:	0824a9a0 	cmpeqi	zero,at,-27994
 824a6d4:	0824aa9c 	xori	zero,at,37546
 824a6d8:	0824ab38 	rdprs	zero,at,-27988
 824a6dc:	0824af40 	call	824af4 <OSCtxSw_SWITCH_PC+0x824ab4>
 824a6e0:	0824af40 	call	824af4 <OSCtxSw_SWITCH_PC+0x824ab4>
 824a6e4:	0824a704 	addi	zero,at,-28004
 824a6e8:	0824af40 	call	824af4 <OSCtxSw_SWITCH_PC+0x824ab4>
 824a6ec:	0824af40 	call	824af4 <OSCtxSw_SWITCH_PC+0x824ab4>
 824a6f0:	0824ac6c 	andhi	zero,at,37553
 824a6f4:	0824ad74 	orhi	zero,at,37557
 824a6f8:	0824add8 	cmpnei	zero,at,-27977
 824a6fc:	0824af40 	call	824af4 <OSCtxSw_SWITCH_PC+0x824ab4>
 824a700:	0824af0c 	andi	zero,at,37564
   {
   case ECHOREQ:  /* got ping request, send reply */
      icmp_mib.icmpInEchos++;
 824a704:	008209b4 	movhi	r2,2086
 824a708:	10ba7f04 	addi	r2,r2,-5636
 824a70c:	10800717 	ldw	r2,28(r2)
 824a710:	10c00044 	addi	r3,r2,1
 824a714:	008209b4 	movhi	r2,2086
 824a718:	10ba7f04 	addi	r2,r2,-5636
 824a71c:	10c00715 	stw	r3,28(r2)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 824a720:	d0a08317 	ldw	r2,-32244(gp)
 824a724:	1081000c 	andi	r2,r2,1024
 824a728:	10001426 	beq	r2,zero,824a77c <icmprcv+0x31c>
 824a72c:	d0a08317 	ldw	r2,-32244(gp)
 824a730:	1080800c 	andi	r2,r2,512
 824a734:	10001126 	beq	r2,zero,824a77c <icmprcv+0x31c>
         dprintf("ICMP: echo reply to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 824a738:	e0bff617 	ldw	r2,-40(fp)
 824a73c:	10c03fcc 	andi	r3,r2,255
 824a740:	e0bff617 	ldw	r2,-40(fp)
 824a744:	1004d23a 	srli	r2,r2,8
 824a748:	11003fcc 	andi	r4,r2,255
 824a74c:	e0bff617 	ldw	r2,-40(fp)
 824a750:	1004d43a 	srli	r2,r2,16
 824a754:	11403fcc 	andi	r5,r2,255
 824a758:	e0bff617 	ldw	r2,-40(fp)
 824a75c:	1004d63a 	srli	r2,r2,24
 824a760:	d8800015 	stw	r2,0(sp)
 824a764:	280f883a 	mov	r7,r5
 824a768:	200d883a 	mov	r6,r4
 824a76c:	180b883a 	mov	r5,r3
 824a770:	01020974 	movhi	r4,2085
 824a774:	2106ff04 	addi	r4,r4,7164
 824a778:	82033a00 	call	82033a0 <printf>
#endif
      e->ptype = ECHOREP;
 824a77c:	e0bff717 	ldw	r2,-36(fp)
 824a780:	10000005 	stb	zero,0(r2)
      e->pchksum = 0;
 824a784:	e0bff717 	ldw	r2,-36(fp)
 824a788:	1000008d 	sth	zero,2(r2)
      if (len&1)  /* pad odd length packets for checksum routine */
 824a78c:	e0bff517 	ldw	r2,-44(fp)
 824a790:	1080004c 	andi	r2,r2,1
 824a794:	10000926 	beq	r2,zero,824a7bc <icmprcv+0x35c>
      {
         sav_ch = *(((char *) e) + len);
 824a798:	e0fff717 	ldw	r3,-36(fp)
 824a79c:	e0bff517 	ldw	r2,-44(fp)
 824a7a0:	1885883a 	add	r2,r3,r2
 824a7a4:	10800003 	ldbu	r2,0(r2)
 824a7a8:	e0bff305 	stb	r2,-52(fp)
         ((char *)e)[len] = 0;
 824a7ac:	e0fff717 	ldw	r3,-36(fp)
 824a7b0:	e0bff517 	ldw	r2,-44(fp)
 824a7b4:	1885883a 	add	r2,r3,r2
 824a7b8:	10000005 	stb	zero,0(r2)
      }

      e->pchksum = ~cksum(e, (len+1)>>1);
 824a7bc:	e0bff517 	ldw	r2,-44(fp)
 824a7c0:	10800044 	addi	r2,r2,1
 824a7c4:	1004d07a 	srli	r2,r2,1
 824a7c8:	100b883a 	mov	r5,r2
 824a7cc:	e13ff717 	ldw	r4,-36(fp)
 824a7d0:	82287b40 	call	82287b4 <cksum>
 824a7d4:	0084303a 	nor	r2,zero,r2
 824a7d8:	1007883a 	mov	r3,r2
 824a7dc:	e0bff717 	ldw	r2,-36(fp)
 824a7e0:	10c0008d 	sth	r3,2(r2)
      if (len&1) *(((char *) e) + len) = sav_ch;
 824a7e4:	e0bff517 	ldw	r2,-44(fp)
 824a7e8:	1080004c 	andi	r2,r2,1
 824a7ec:	10000526 	beq	r2,zero,824a804 <icmprcv+0x3a4>
 824a7f0:	e0fff717 	ldw	r3,-36(fp)
 824a7f4:	e0bff517 	ldw	r2,-44(fp)
 824a7f8:	1885883a 	add	r2,r3,r2
 824a7fc:	e0fff303 	ldbu	r3,-52(fp)
 824a800:	10c00005 	stb	r3,0(r2)
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 824a804:	e0bff417 	ldw	r2,-48(fp)
 824a808:	10800417 	ldw	r2,16(r2)
 824a80c:	10bfffe0 	cmpeqi	r2,r2,-1
 824a810:	10001f1e 	bne	r2,zero,824a890 <icmprcv+0x430>
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
 824a814:	e0bff417 	ldw	r2,-48(fp)
 824a818:	10800417 	ldw	r2,16(r2)
 824a81c:	1006d63a 	srli	r3,r2,24
 824a820:	e0bff417 	ldw	r2,-48(fp)
 824a824:	10800417 	ldw	r2,16(r2)
 824a828:	1004d23a 	srli	r2,r2,8
 824a82c:	10bfc00c 	andi	r2,r2,65280
 824a830:	1886b03a 	or	r3,r3,r2
 824a834:	e0bff417 	ldw	r2,-48(fp)
 824a838:	10800417 	ldw	r2,16(r2)
 824a83c:	10bfc00c 	andi	r2,r2,65280
 824a840:	1004923a 	slli	r2,r2,8
 824a844:	1886b03a 	or	r3,r3,r2
 824a848:	e0bff417 	ldw	r2,-48(fp)
 824a84c:	10800417 	ldw	r2,16(r2)
 824a850:	1004963a 	slli	r2,r2,24
 824a854:	1884b03a 	or	r2,r3,r2
 824a858:	10fc002c 	andhi	r3,r2,61440
      if (len&1) *(((char *) e) + len) = sav_ch;
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 824a85c:	00b80034 	movhi	r2,57344
 824a860:	18800b26 	beq	r3,r2,824a890 <icmprcv+0x430>
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
 824a864:	e0bff417 	ldw	r2,-48(fp)
 824a868:	10c00417 	ldw	r3,16(r2)
 824a86c:	e0bffd17 	ldw	r2,-12(fp)
 824a870:	10800617 	ldw	r2,24(r2)
 824a874:	11000a17 	ldw	r4,40(r2)
 824a878:	e0bffd17 	ldw	r2,-12(fp)
 824a87c:	10800617 	ldw	r2,24(r2)
 824a880:	10800c17 	ldw	r2,48(r2)
 824a884:	0084303a 	nor	r2,zero,r2
 824a888:	2084b03a 	or	r2,r4,r2
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
 824a88c:	1880061e 	bne	r3,r2,824a8a8 <icmprcv+0x448>
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
      {
         pip->ip_src = p->net->n_ipaddr;
 824a890:	e0bffd17 	ldw	r2,-12(fp)
 824a894:	10800617 	ldw	r2,24(r2)
 824a898:	10c00a17 	ldw	r3,40(r2)
 824a89c:	e0bff417 	ldw	r2,-48(fp)
 824a8a0:	10c00315 	stw	r3,12(r2)
 824a8a4:	00000406 	br	824a8b8 <icmprcv+0x458>
      }
      else pip->ip_src = pip->ip_dest;
 824a8a8:	e0bff417 	ldw	r2,-48(fp)
 824a8ac:	10c00417 	ldw	r3,16(r2)
 824a8b0:	e0bff417 	ldw	r2,-48(fp)
 824a8b4:	10c00315 	stw	r3,12(r2)

      pip->ip_dest = host;
 824a8b8:	e0bff417 	ldw	r2,-48(fp)
 824a8bc:	e0fff617 	ldw	r3,-40(fp)
 824a8c0:	10c00415 	stw	r3,16(r2)
      icmp_mib.icmpOutEchoReps++;
 824a8c4:	008209b4 	movhi	r2,2086
 824a8c8:	10ba7f04 	addi	r2,r2,-5636
 824a8cc:	10801517 	ldw	r2,84(r2)
 824a8d0:	10c00044 	addi	r3,r2,1
 824a8d4:	008209b4 	movhi	r2,2086
 824a8d8:	10ba7f04 	addi	r2,r2,-5636
 824a8dc:	10c01515 	stw	r3,84(r2)
      icmp_mib.icmpOutMsgs++;
 824a8e0:	008209b4 	movhi	r2,2086
 824a8e4:	10ba7f04 	addi	r2,r2,-5636
 824a8e8:	10800d17 	ldw	r2,52(r2)
 824a8ec:	10c00044 	addi	r3,r2,1
 824a8f0:	008209b4 	movhi	r2,2086
 824a8f4:	10ba7f04 	addi	r2,r2,-5636
 824a8f8:	10c00d15 	stw	r3,52(r2)
      p->fhost = host;
 824a8fc:	e0bffd17 	ldw	r2,-12(fp)
 824a900:	e0fff617 	ldw	r3,-40(fp)
 824a904:	10c00715 	stw	r3,28(r2)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 824a908:	e0bffd17 	ldw	r2,-12(fp)
 824a90c:	10c00317 	ldw	r3,12(r2)
 824a910:	e0bff417 	ldw	r2,-48(fp)
 824a914:	10800003 	ldbu	r2,0(r2)
 824a918:	10803fcc 	andi	r2,r2,255
 824a91c:	108003cc 	andi	r2,r2,15
 824a920:	1085883a 	add	r2,r2,r2
 824a924:	1085883a 	add	r2,r2,r2
 824a928:	1887883a 	add	r3,r3,r2
 824a92c:	e0bffd17 	ldw	r2,-12(fp)
 824a930:	10c00315 	stw	r3,12(r2)
      p->nb_plen = len;
 824a934:	e0bffd17 	ldw	r2,-12(fp)
 824a938:	e0fff517 	ldw	r3,-44(fp)
 824a93c:	10c00415 	stw	r3,16(r2)

      i = ip_write(ICMP_PROT, p);
 824a940:	e17ffd17 	ldw	r5,-12(fp)
 824a944:	01000044 	movi	r4,1
 824a948:	823f94c0 	call	823f94c <ip_write>
 824a94c:	e0bff915 	stw	r2,-28(fp)
      if (i < 0)
 824a950:	e0bff917 	ldw	r2,-28(fp)
 824a954:	1000060e 	bge	r2,zero,824a970 <icmprcv+0x510>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (UPCTRACE))
 824a958:	d0a08317 	ldw	r2,-32244(gp)
 824a95c:	1081000c 	andi	r2,r2,1024
 824a960:	10000326 	beq	r2,zero,824a970 <icmprcv+0x510>
            dprintf("icmp: reply failed\n");
 824a964:	01020974 	movhi	r4,2085
 824a968:	21070804 	addi	r4,r4,7200
 824a96c:	82036240 	call	8203624 <puts>
#endif
      }
      /* reused p will be freed by net->xxx_send() */
      return 0;
 824a970:	0005883a 	mov	r2,zero
 824a974:	00018c06 	br	824afa8 <icmprcv+0xb48>
   case ECHOREP:
      icmp_mib.icmpInEchoReps++;
 824a978:	008209b4 	movhi	r2,2086
 824a97c:	10ba7f04 	addi	r2,r2,-5636
 824a980:	10800817 	ldw	r2,32(r2)
 824a984:	10c00044 	addi	r3,r2,1
 824a988:	008209b4 	movhi	r2,2086
 824a98c:	10ba7f04 	addi	r2,r2,-5636
 824a990:	10c00815 	stw	r3,32(r2)
      
/* 
 * Altera Niche Stack Nios port modification
 */
#if defined(ALT_INICHE) && !defined(PING_APP) && defined(IP_RAW)
      return(ip_raw_input(p));
 824a994:	e13ffd17 	ldw	r4,-12(fp)
 824a998:	8243e740 	call	8243e74 <ip_raw_input>
 824a99c:	00018206 	br	824afa8 <icmprcv+0xb48>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
      return(0);
#endif   /* PING_APP */
#ifdef FULL_ICMP
   case DESTIN:
      icmp_mib.icmpInDestUnreachs++;
 824a9a0:	008209b4 	movhi	r2,2086
 824a9a4:	10ba7f04 	addi	r2,r2,-5636
 824a9a8:	10800217 	ldw	r2,8(r2)
 824a9ac:	10c00044 	addi	r3,r2,1
 824a9b0:	008209b4 	movhi	r2,2086
 824a9b4:	10ba7f04 	addi	r2,r2,-5636
 824a9b8:	10c00215 	stw	r3,8(r2)
      pdp = (struct destun *)e;
 824a9bc:	e0bff717 	ldw	r2,-36(fp)
 824a9c0:	e0bffa15 	stw	r2,-24(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824a9c4:	d0a08317 	ldw	r2,-32244(gp)
 824a9c8:	1081000c 	andi	r2,r2,1024
 824a9cc:	10002f26 	beq	r2,zero,824aa8c <icmprcv+0x62c>
      {
         dprintf("ICMP: got dest unreachable type ");
 824a9d0:	01020974 	movhi	r4,2085
 824a9d4:	21070d04 	addi	r4,r4,7220
 824a9d8:	82033a00 	call	82033a0 <printf>
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824a9dc:	e0bffa17 	ldw	r2,-24(fp)
 824a9e0:	10800043 	ldbu	r2,1(r2)
 824a9e4:	11003fcc 	andi	r4,r2,255
 824a9e8:	2100201c 	xori	r4,r4,128
 824a9ec:	213fe004 	addi	r4,r4,-128
          PUSH_IPADDR(pdp->dip.ip_dest));
 824a9f0:	e0bffa17 	ldw	r2,-24(fp)
 824a9f4:	10800617 	ldw	r2,24(r2)
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824a9f8:	11403fcc 	andi	r5,r2,255
          PUSH_IPADDR(pdp->dip.ip_dest));
 824a9fc:	e0bffa17 	ldw	r2,-24(fp)
 824aa00:	10800617 	ldw	r2,24(r2)
 824aa04:	1004d23a 	srli	r2,r2,8
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824aa08:	11803fcc 	andi	r6,r2,255
          PUSH_IPADDR(pdp->dip.ip_dest));
 824aa0c:	e0bffa17 	ldw	r2,-24(fp)
 824aa10:	10800617 	ldw	r2,24(r2)
 824aa14:	1004d43a 	srli	r2,r2,16
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824aa18:	10803fcc 	andi	r2,r2,255
          PUSH_IPADDR(pdp->dip.ip_dest));
 824aa1c:	e0fffa17 	ldw	r3,-24(fp)
 824aa20:	18c00617 	ldw	r3,24(r3)
 824aa24:	1806d63a 	srli	r3,r3,24
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824aa28:	d8c00115 	stw	r3,4(sp)
 824aa2c:	d8800015 	stw	r2,0(sp)
 824aa30:	300f883a 	mov	r7,r6
 824aa34:	280d883a 	mov	r6,r5
 824aa38:	200b883a 	mov	r5,r4
 824aa3c:	01020974 	movhi	r4,2085
 824aa40:	21071604 	addi	r4,r4,7256
 824aa44:	82033a00 	call	82033a0 <printf>
          PUSH_IPADDR(pdp->dip.ip_dest));
         dprintf("from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 824aa48:	e0bff617 	ldw	r2,-40(fp)
 824aa4c:	10c03fcc 	andi	r3,r2,255
 824aa50:	e0bff617 	ldw	r2,-40(fp)
 824aa54:	1004d23a 	srli	r2,r2,8
 824aa58:	11003fcc 	andi	r4,r2,255
 824aa5c:	e0bff617 	ldw	r2,-40(fp)
 824aa60:	1004d43a 	srli	r2,r2,16
 824aa64:	11403fcc 	andi	r5,r2,255
 824aa68:	e0bff617 	ldw	r2,-40(fp)
 824aa6c:	1004d63a 	srli	r2,r2,24
 824aa70:	d8800015 	stw	r2,0(sp)
 824aa74:	280f883a 	mov	r7,r5
 824aa78:	200d883a 	mov	r6,r4
 824aa7c:	180b883a 	mov	r5,r3
 824aa80:	01020974 	movhi	r4,2085
 824aa84:	21071b04 	addi	r4,r4,7276
 824aa88:	82033a00 	call	82033a0 <printf>
      }
#endif   /* NPDEBUG */
      icmp_du(p, pdp);
 824aa8c:	e17ffa17 	ldw	r5,-24(fp)
 824aa90:	e13ffd17 	ldw	r4,-12(fp)
 824aa94:	824b5d80 	call	824b5d8 <icmp_du>
      break;
 824aa98:	00014206 	br	824afa4 <icmprcv+0xb44>
   case SOURCEQ:
      icmp_mib.icmpInSrcQuenchs++;
 824aa9c:	008209b4 	movhi	r2,2086
 824aaa0:	10ba7f04 	addi	r2,r2,-5636
 824aaa4:	10800517 	ldw	r2,20(r2)
 824aaa8:	10c00044 	addi	r3,r2,1
 824aaac:	008209b4 	movhi	r2,2086
 824aab0:	10ba7f04 	addi	r2,r2,-5636
 824aab4:	10c00515 	stw	r3,20(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824aab8:	d0a08317 	ldw	r2,-32244(gp)
 824aabc:	1081000c 	andi	r2,r2,1024
 824aac0:	10001626 	beq	r2,zero,824ab1c <icmprcv+0x6bc>
      {
         dprintf("ICMP: source quench from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 824aac4:	e0bff617 	ldw	r2,-40(fp)
 824aac8:	10c03fcc 	andi	r3,r2,255
 824aacc:	e0bff617 	ldw	r2,-40(fp)
 824aad0:	1004d23a 	srli	r2,r2,8
 824aad4:	11003fcc 	andi	r4,r2,255
 824aad8:	e0bff617 	ldw	r2,-40(fp)
 824aadc:	1004d43a 	srli	r2,r2,16
 824aae0:	11403fcc 	andi	r5,r2,255
 824aae4:	e0bff617 	ldw	r2,-40(fp)
 824aae8:	1004d63a 	srli	r2,r2,24
 824aaec:	d8800015 	stw	r2,0(sp)
 824aaf0:	280f883a 	mov	r7,r5
 824aaf4:	200d883a 	mov	r6,r4
 824aaf8:	180b883a 	mov	r5,r3
 824aafc:	01020974 	movhi	r4,2085
 824ab00:	21072004 	addi	r4,r4,7296
 824ab04:	82033a00 	call	82033a0 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 824ab08:	d0a08317 	ldw	r2,-32244(gp)
 824ab0c:	1080008c 	andi	r2,r2,2
 824ab10:	10000226 	beq	r2,zero,824ab1c <icmprcv+0x6bc>
 824ab14:	e13ffd17 	ldw	r4,-12(fp)
 824ab18:	8240a400 	call	8240a40 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824ab1c:	01000084 	movi	r4,2
 824ab20:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free(p);
 824ab24:	e13ffd17 	ldw	r4,-12(fp)
 824ab28:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824ab2c:	01000084 	movi	r4,2
 824ab30:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      break;
 824ab34:	00011b06 	br	824afa4 <icmprcv+0xb44>
   case REDIR:          /* got an icmp redirect */
      icmp_mib.icmpInRedirects++;
 824ab38:	008209b4 	movhi	r2,2086
 824ab3c:	10ba7f04 	addi	r2,r2,-5636
 824ab40:	10800617 	ldw	r2,24(r2)
 824ab44:	10c00044 	addi	r3,r2,1
 824ab48:	008209b4 	movhi	r2,2086
 824ab4c:	10ba7f04 	addi	r2,r2,-5636
 824ab50:	10c00615 	stw	r3,24(r2)
      rd = (struct redirect *)e;
 824ab54:	e0bff717 	ldw	r2,-36(fp)
 824ab58:	e0bffb15 	stw	r2,-20(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824ab5c:	d0a08317 	ldw	r2,-32244(gp)
 824ab60:	1081000c 	andi	r2,r2,1024
 824ab64:	10002a26 	beq	r2,zero,824ac10 <icmprcv+0x7b0>
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
          PUSH_IPADDR(rd->rdip.ip_dest));
 824ab68:	e0bffb17 	ldw	r2,-20(fp)
 824ab6c:	10800617 	ldw	r2,24(r2)
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 824ab70:	10c03fcc 	andi	r3,r2,255
          PUSH_IPADDR(rd->rdip.ip_dest));
 824ab74:	e0bffb17 	ldw	r2,-20(fp)
 824ab78:	10800617 	ldw	r2,24(r2)
 824ab7c:	1004d23a 	srli	r2,r2,8
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 824ab80:	11003fcc 	andi	r4,r2,255
          PUSH_IPADDR(rd->rdip.ip_dest));
 824ab84:	e0bffb17 	ldw	r2,-20(fp)
 824ab88:	10800617 	ldw	r2,24(r2)
 824ab8c:	1004d43a 	srli	r2,r2,16
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 824ab90:	11403fcc 	andi	r5,r2,255
          PUSH_IPADDR(rd->rdip.ip_dest));
 824ab94:	e0bffb17 	ldw	r2,-20(fp)
 824ab98:	10800617 	ldw	r2,24(r2)
 824ab9c:	1004d63a 	srli	r2,r2,24
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 824aba0:	d8800015 	stw	r2,0(sp)
 824aba4:	280f883a 	mov	r7,r5
 824aba8:	200d883a 	mov	r6,r4
 824abac:	180b883a 	mov	r5,r3
 824abb0:	01020974 	movhi	r4,2085
 824abb4:	21072a04 	addi	r4,r4,7336
 824abb8:	82033a00 	call	82033a0 <printf>
          PUSH_IPADDR(rd->rdip.ip_dest));
         dprintf("to %u.%u.%u.%u\n", PUSH_IPADDR(rd->rdgw));
 824abbc:	e0bffb17 	ldw	r2,-20(fp)
 824abc0:	10800117 	ldw	r2,4(r2)
 824abc4:	10c03fcc 	andi	r3,r2,255
 824abc8:	e0bffb17 	ldw	r2,-20(fp)
 824abcc:	10800117 	ldw	r2,4(r2)
 824abd0:	1004d23a 	srli	r2,r2,8
 824abd4:	11003fcc 	andi	r4,r2,255
 824abd8:	e0bffb17 	ldw	r2,-20(fp)
 824abdc:	10800117 	ldw	r2,4(r2)
 824abe0:	1004d43a 	srli	r2,r2,16
 824abe4:	11403fcc 	andi	r5,r2,255
 824abe8:	e0bffb17 	ldw	r2,-20(fp)
 824abec:	10800117 	ldw	r2,4(r2)
 824abf0:	1004d63a 	srli	r2,r2,24
 824abf4:	d8800015 	stw	r2,0(sp)
 824abf8:	280f883a 	mov	r7,r5
 824abfc:	200d883a 	mov	r6,r4
 824ac00:	180b883a 	mov	r5,r3
 824ac04:	01020974 	movhi	r4,2085
 824ac08:	21073404 	addi	r4,r4,7376
 824ac0c:	82033a00 	call	82033a0 <printf>
      }
#endif   /* NPDEBUG */
#ifdef IP_ROUTING
      /* try to add/update route table */
      add_route(rd->rdip.ip_dest, 0xFFFFFFFF, rd->rdgw, 
 824ac10:	e0bffb17 	ldw	r2,-20(fp)
 824ac14:	14000617 	ldw	r16,24(r2)
 824ac18:	e0bffb17 	ldw	r2,-20(fp)
 824ac1c:	14400117 	ldw	r17,4(r2)
 824ac20:	e0bffd17 	ldw	r2,-12(fp)
 824ac24:	10800617 	ldw	r2,24(r2)
 824ac28:	1009883a 	mov	r4,r2
 824ac2c:	8226c680 	call	8226c68 <if_netnumber>
 824ac30:	1007883a 	mov	r3,r2
 824ac34:	00800104 	movi	r2,4
 824ac38:	d8800015 	stw	r2,0(sp)
 824ac3c:	180f883a 	mov	r7,r3
 824ac40:	880d883a 	mov	r6,r17
 824ac44:	017fffc4 	movi	r5,-1
 824ac48:	8009883a 	mov	r4,r16
 824ac4c:	82443300 	call	8244330 <add_route>
       net_num(p->net), IPRP_ICMP);
#endif   /* IP_ROUTING */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824ac50:	01000084 	movi	r4,2
 824ac54:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free(p);
 824ac58:	e13ffd17 	ldw	r4,-12(fp)
 824ac5c:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824ac60:	01000084 	movi	r4,2
 824ac64:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      break;
 824ac68:	0000ce06 	br	824afa4 <icmprcv+0xb44>
   case TIMEX:
      icmp_mib.icmpInTimeExcds++;
 824ac6c:	008209b4 	movhi	r2,2086
 824ac70:	10ba7f04 	addi	r2,r2,-5636
 824ac74:	10800317 	ldw	r2,12(r2)
 824ac78:	10c00044 	addi	r3,r2,1
 824ac7c:	008209b4 	movhi	r2,2086
 824ac80:	10ba7f04 	addi	r2,r2,-5636
 824ac84:	10c00315 	stw	r3,12(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824ac88:	d0a08317 	ldw	r2,-32244(gp)
 824ac8c:	1081000c 	andi	r2,r2,1024
 824ac90:	10003126 	beq	r2,zero,824ad58 <icmprcv+0x8f8>
      {
         struct timex * pt =  (struct  timex *)e;
 824ac94:	e0bff717 	ldw	r2,-36(fp)
 824ac98:	e0bffc15 	stw	r2,-16(fp)

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
          PUSH_IPADDR(p->fhost));
 824ac9c:	e0bffd17 	ldw	r2,-12(fp)
 824aca0:	10800717 	ldw	r2,28(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 824aca4:	10c03fcc 	andi	r3,r2,255
          PUSH_IPADDR(p->fhost));
 824aca8:	e0bffd17 	ldw	r2,-12(fp)
 824acac:	10800717 	ldw	r2,28(r2)
 824acb0:	1004d23a 	srli	r2,r2,8
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 824acb4:	11003fcc 	andi	r4,r2,255
          PUSH_IPADDR(p->fhost));
 824acb8:	e0bffd17 	ldw	r2,-12(fp)
 824acbc:	10800717 	ldw	r2,28(r2)
 824acc0:	1004d43a 	srli	r2,r2,16
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 824acc4:	11403fcc 	andi	r5,r2,255
          PUSH_IPADDR(p->fhost));
 824acc8:	e0bffd17 	ldw	r2,-12(fp)
 824accc:	10800717 	ldw	r2,28(r2)
 824acd0:	1004d63a 	srli	r2,r2,24
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 824acd4:	d8800015 	stw	r2,0(sp)
 824acd8:	280f883a 	mov	r7,r5
 824acdc:	200d883a 	mov	r6,r4
 824ace0:	180b883a 	mov	r5,r3
 824ace4:	01020974 	movhi	r4,2085
 824ace8:	21073804 	addi	r4,r4,7392
 824acec:	82033a00 	call	82033a0 <printf>
          PUSH_IPADDR(p->fhost));
         dprintf(" about %u.%u.%u.%u\n", PUSH_IPADDR(pt->tip.ip_dest));
 824acf0:	e0bffc17 	ldw	r2,-16(fp)
 824acf4:	10800617 	ldw	r2,24(r2)
 824acf8:	10c03fcc 	andi	r3,r2,255
 824acfc:	e0bffc17 	ldw	r2,-16(fp)
 824ad00:	10800617 	ldw	r2,24(r2)
 824ad04:	1004d23a 	srli	r2,r2,8
 824ad08:	11003fcc 	andi	r4,r2,255
 824ad0c:	e0bffc17 	ldw	r2,-16(fp)
 824ad10:	10800617 	ldw	r2,24(r2)
 824ad14:	1004d43a 	srli	r2,r2,16
 824ad18:	11403fcc 	andi	r5,r2,255
 824ad1c:	e0bffc17 	ldw	r2,-16(fp)
 824ad20:	10800617 	ldw	r2,24(r2)
 824ad24:	1004d63a 	srli	r2,r2,24
 824ad28:	d8800015 	stw	r2,0(sp)
 824ad2c:	280f883a 	mov	r7,r5
 824ad30:	200d883a 	mov	r6,r4
 824ad34:	180b883a 	mov	r5,r3
 824ad38:	01020974 	movhi	r4,2085
 824ad3c:	21074104 	addi	r4,r4,7428
 824ad40:	82033a00 	call	82033a0 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 824ad44:	d0a08317 	ldw	r2,-32244(gp)
 824ad48:	1080008c 	andi	r2,r2,2
 824ad4c:	10000226 	beq	r2,zero,824ad58 <icmprcv+0x8f8>
 824ad50:	e13ffd17 	ldw	r4,-12(fp)
 824ad54:	8240a400 	call	8240a40 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824ad58:	01000084 	movi	r4,2
 824ad5c:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free(p);
 824ad60:	e13ffd17 	ldw	r4,-12(fp)
 824ad64:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824ad68:	01000084 	movi	r4,2
 824ad6c:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      break;
 824ad70:	00008c06 	br	824afa4 <icmprcv+0xb44>
   case PARAM:
      icmp_mib.icmpInParmProbs++;
 824ad74:	008209b4 	movhi	r2,2086
 824ad78:	10ba7f04 	addi	r2,r2,-5636
 824ad7c:	10800417 	ldw	r2,16(r2)
 824ad80:	10c00044 	addi	r3,r2,1
 824ad84:	008209b4 	movhi	r2,2086
 824ad88:	10ba7f04 	addi	r2,r2,-5636
 824ad8c:	10c00415 	stw	r3,16(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824ad90:	d0a08317 	ldw	r2,-32244(gp)
 824ad94:	1081000c 	andi	r2,r2,1024
 824ad98:	10000326 	beq	r2,zero,824ada8 <icmprcv+0x948>
         dprintf("ICMP: got param problem message\n");
 824ad9c:	01020974 	movhi	r4,2085
 824ada0:	21074604 	addi	r4,r4,7448
 824ada4:	82036240 	call	8203624 <puts>
      if (NDEBUG & DUMP)
 824ada8:	d0a08317 	ldw	r2,-32244(gp)
 824adac:	1080008c 	andi	r2,r2,2
 824adb0:	10000226 	beq	r2,zero,824adbc <icmprcv+0x95c>
      {
         ip_dump(p);
 824adb4:	e13ffd17 	ldw	r4,-12(fp)
 824adb8:	8240a400 	call	8240a40 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824adbc:	01000084 	movi	r4,2
 824adc0:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free(p);
 824adc4:	e13ffd17 	ldw	r4,-12(fp)
 824adc8:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824adcc:	01000084 	movi	r4,2
 824add0:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      break;
 824add4:	00007306 	br	824afa4 <icmprcv+0xb44>
   case TIMEREQ:
      icmp_mib.icmpInTimestamps++;
 824add8:	008209b4 	movhi	r2,2086
 824addc:	10ba7f04 	addi	r2,r2,-5636
 824ade0:	10800917 	ldw	r2,36(r2)
 824ade4:	10c00044 	addi	r3,r2,1
 824ade8:	008209b4 	movhi	r2,2086
 824adec:	10ba7f04 	addi	r2,r2,-5636
 824adf0:	10c00915 	stw	r3,36(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824adf4:	d0a08317 	ldw	r2,-32244(gp)
 824adf8:	1081000c 	andi	r2,r2,1024
 824adfc:	10000326 	beq	r2,zero,824ae0c <icmprcv+0x9ac>
         dprintf("ICMP: got timestamp request\n");
 824ae00:	01020974 	movhi	r4,2085
 824ae04:	21074e04 	addi	r4,r4,7480
 824ae08:	82036240 	call	8203624 <puts>
#endif   /* NPDEBUG */
      e->ptype = TIMEREP;
 824ae0c:	e0bff717 	ldw	r2,-36(fp)
 824ae10:	00c00384 	movi	r3,14
 824ae14:	10c00005 	stb	r3,0(r2)
      e->pchksum = 0;
 824ae18:	e0bff717 	ldw	r2,-36(fp)
 824ae1c:	1000008d 	sth	zero,2(r2)
		   */
		  sstmp->dtstamp[1] = sstmp->dtstamp[2] = user_UTCtime();
	  }
#endif /* USER_PING_TSTAMP */

      e->pchksum = ~cksum(e, sizeof(struct tstamp)>>1);
 824ae20:	01400284 	movi	r5,10
 824ae24:	e13ff717 	ldw	r4,-36(fp)
 824ae28:	82287b40 	call	82287b4 <cksum>
 824ae2c:	0084303a 	nor	r2,zero,r2
 824ae30:	1007883a 	mov	r3,r2
 824ae34:	e0bff717 	ldw	r2,-36(fp)
 824ae38:	10c0008d 	sth	r3,2(r2)
      pip->ip_src = pip->ip_dest;
 824ae3c:	e0bff417 	ldw	r2,-48(fp)
 824ae40:	10c00417 	ldw	r3,16(r2)
 824ae44:	e0bff417 	ldw	r2,-48(fp)
 824ae48:	10c00315 	stw	r3,12(r2)
      pip->ip_dest = host;
 824ae4c:	e0bff417 	ldw	r2,-48(fp)
 824ae50:	e0fff617 	ldw	r3,-40(fp)
 824ae54:	10c00415 	stw	r3,16(r2)
      icmp_mib.icmpOutMsgs++;
 824ae58:	008209b4 	movhi	r2,2086
 824ae5c:	10ba7f04 	addi	r2,r2,-5636
 824ae60:	10800d17 	ldw	r2,52(r2)
 824ae64:	10c00044 	addi	r3,r2,1
 824ae68:	008209b4 	movhi	r2,2086
 824ae6c:	10ba7f04 	addi	r2,r2,-5636
 824ae70:	10c00d15 	stw	r3,52(r2)
      icmp_mib.icmpOutTimestampReps++;
 824ae74:	008209b4 	movhi	r2,2086
 824ae78:	10ba7f04 	addi	r2,r2,-5636
 824ae7c:	10801717 	ldw	r2,92(r2)
 824ae80:	10c00044 	addi	r3,r2,1
 824ae84:	008209b4 	movhi	r2,2086
 824ae88:	10ba7f04 	addi	r2,r2,-5636
 824ae8c:	10c01715 	stw	r3,92(r2)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 824ae90:	e0bffd17 	ldw	r2,-12(fp)
 824ae94:	10c00317 	ldw	r3,12(r2)
 824ae98:	e0bff417 	ldw	r2,-48(fp)
 824ae9c:	10800003 	ldbu	r2,0(r2)
 824aea0:	10803fcc 	andi	r2,r2,255
 824aea4:	108003cc 	andi	r2,r2,15
 824aea8:	1085883a 	add	r2,r2,r2
 824aeac:	1085883a 	add	r2,r2,r2
 824aeb0:	1887883a 	add	r3,r3,r2
 824aeb4:	e0bffd17 	ldw	r2,-12(fp)
 824aeb8:	10c00315 	stw	r3,12(r2)
      p->nb_plen = sizeof(struct tstamp);
 824aebc:	e0bffd17 	ldw	r2,-12(fp)
 824aec0:	00c00504 	movi	r3,20
 824aec4:	10c00415 	stw	r3,16(r2)
      p->fhost = host;
 824aec8:	e0bffd17 	ldw	r2,-12(fp)
 824aecc:	e0fff617 	ldw	r3,-40(fp)
 824aed0:	10c00715 	stw	r3,28(r2)
      i = ip_write(ICMP_PROT, p);
 824aed4:	e17ffd17 	ldw	r5,-12(fp)
 824aed8:	01000044 	movi	r4,1
 824aedc:	823f94c0 	call	823f94c <ip_write>
 824aee0:	e0bff915 	stw	r2,-28(fp)
      if (i < 0)
 824aee4:	e0bff917 	ldw	r2,-28(fp)
 824aee8:	1000060e 	bge	r2,zero,824af04 <icmprcv+0xaa4>
      {
#ifdef   NPDEBUG
         if (NDEBUG & UPCTRACE)
 824aeec:	d0a08317 	ldw	r2,-32244(gp)
 824aef0:	1081000c 	andi	r2,r2,1024
 824aef4:	10000326 	beq	r2,zero,824af04 <icmprcv+0xaa4>
            dprintf("icmp: can't send timestamp reply\n");
 824aef8:	01020974 	movhi	r4,2085
 824aefc:	21075504 	addi	r4,r4,7508
 824af00:	82036240 	call	8203624 <puts>
#endif   /* NPDEBUG */
      }
      /* re-used packet was pk_free()d by net->send() */
      return (0);
 824af04:	0005883a 	mov	r2,zero
 824af08:	00002706 	br	824afa8 <icmprcv+0xb48>
   case INFO:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824af0c:	d0a08317 	ldw	r2,-32244(gp)
 824af10:	1081000c 	andi	r2,r2,1024
 824af14:	10000326 	beq	r2,zero,824af24 <icmprcv+0xac4>
         dprintf("icmp: got info request\n");
 824af18:	01020974 	movhi	r4,2085
 824af1c:	21075e04 	addi	r4,r4,7544
 824af20:	82036240 	call	8203624 <puts>
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824af24:	01000084 	movi	r4,2
 824af28:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free(p);
 824af2c:	e13ffd17 	ldw	r4,-12(fp)
 824af30:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824af34:	01000084 	movi	r4,2
 824af38:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      break;
 824af3c:	00001906 	br	824afa4 <icmprcv+0xb44>
#endif   /* FULL_ICMP */
   default:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824af40:	d0a08317 	ldw	r2,-32244(gp)
 824af44:	1081000c 	andi	r2,r2,1024
 824af48:	10000e26 	beq	r2,zero,824af84 <icmprcv+0xb24>
      {
         dprintf("icmp: unhandled type %u\n", e->ptype);
 824af4c:	e0bff717 	ldw	r2,-36(fp)
 824af50:	10800003 	ldbu	r2,0(r2)
 824af54:	10803fcc 	andi	r2,r2,255
 824af58:	1080201c 	xori	r2,r2,128
 824af5c:	10bfe004 	addi	r2,r2,-128
 824af60:	100b883a 	mov	r5,r2
 824af64:	01020974 	movhi	r4,2085
 824af68:	21076404 	addi	r4,r4,7568
 824af6c:	82033a00 	call	82033a0 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 824af70:	d0a08317 	ldw	r2,-32244(gp)
 824af74:	1080008c 	andi	r2,r2,2
 824af78:	10000226 	beq	r2,zero,824af84 <icmprcv+0xb24>
 824af7c:	e13ffd17 	ldw	r4,-12(fp)
 824af80:	8240a400 	call	8240a40 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824af84:	01000084 	movi	r4,2
 824af88:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
      pk_free(p);
 824af8c:	e13ffd17 	ldw	r4,-12(fp)
 824af90:	822cd3c0 	call	822cd3c <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824af94:	01000084 	movi	r4,2
 824af98:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>
      return ENP_NOT_MINE;
 824af9c:	00800084 	movi	r2,2
 824afa0:	00000106 	br	824afa8 <icmprcv+0xb48>
   }
#ifdef FULL_ICMP
   return ENP_NOT_MINE;
 824afa4:	00800084 	movi	r2,2
#endif   /* FULL_ICMP */
}
 824afa8:	e6fffe04 	addi	sp,fp,-8
 824afac:	dfc00317 	ldw	ra,12(sp)
 824afb0:	df000217 	ldw	fp,8(sp)
 824afb4:	dc400117 	ldw	r17,4(sp)
 824afb8:	dc000017 	ldw	r16,0(sp)
 824afbc:	dec00404 	addi	sp,sp,16
 824afc0:	f800283a 	ret

0824afc4 <icmp_destun>:
icmp_destun(ip_addr host,  /* host to complain to */
   ip_addr src_addr, /* source address for outgoing ICMP/IP packet header */
   struct ip * ip,   /* IP header of offending packet */
   unsigned typecode,    /* type & code of DU to send (PROT, PORT, HOST) */
   NET   net)        /* interface that this packet came in on */
{
 824afc4:	defff404 	addi	sp,sp,-48
 824afc8:	dfc00b15 	stw	ra,44(sp)
 824afcc:	df000a15 	stw	fp,40(sp)
 824afd0:	df000a04 	addi	fp,sp,40
 824afd4:	e13ffc15 	stw	r4,-16(fp)
 824afd8:	e17ffd15 	stw	r5,-12(fp)
 824afdc:	e1bffe15 	stw	r6,-8(fp)
 824afe0:	e1ffff15 	stw	r7,-4(fp)
   struct destun *   d;
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 824afe4:	d0a08317 	ldw	r2,-32244(gp)
 824afe8:	1080040c 	andi	r2,r2,16
 824afec:	10001a26 	beq	r2,zero,824b058 <icmp_destun+0x94>
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 824aff0:	e0bfff17 	ldw	r2,-4(fp)
 824aff4:	10c03fcc 	andi	r3,r2,255
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 824aff8:	00820974 	movhi	r2,2085
 824affc:	108f9104 	addi	r2,r2,15940
 824b000:	18c7883a 	add	r3,r3,r3
 824b004:	18c7883a 	add	r3,r3,r3
 824b008:	10c5883a 	add	r2,r2,r3
 824b00c:	11000017 	ldw	r4,0(r2)
 824b010:	e0bffc17 	ldw	r2,-16(fp)
 824b014:	11403fcc 	andi	r5,r2,255
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 824b018:	e0bffc17 	ldw	r2,-16(fp)
 824b01c:	1004d23a 	srli	r2,r2,8
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 824b020:	11803fcc 	andi	r6,r2,255
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 824b024:	e0bffc17 	ldw	r2,-16(fp)
 824b028:	1004d43a 	srli	r2,r2,16
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 824b02c:	10803fcc 	andi	r2,r2,255
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 824b030:	e0fffc17 	ldw	r3,-16(fp)
 824b034:	1806d63a 	srli	r3,r3,24
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 824b038:	d8c00115 	stw	r3,4(sp)
 824b03c:	d8800015 	stw	r2,0(sp)
 824b040:	300f883a 	mov	r7,r6
 824b044:	280d883a 	mov	r6,r5
 824b048:	200b883a 	mov	r5,r4
 824b04c:	01020974 	movhi	r4,2085
 824b050:	21077e04 	addi	r4,r4,7672
 824b054:	82033a00 	call	82033a0 <printf>
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(FREEQ_RESID);
 824b058:	01000084 	movi	r4,2
 824b05c:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
   p = pk_alloc(512 + IPHSIZ);   /* get packet to send icmp dest unreachable */
 824b060:	01008504 	movi	r4,532
 824b064:	822c9ec0 	call	822c9ec <pk_alloc>
 824b068:	e0bff815 	stw	r2,-32(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824b06c:	01000084 	movi	r4,2
 824b070:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 824b074:	e0bff817 	ldw	r2,-32(fp)
 824b078:	10000e1e 	bne	r2,zero,824b0b4 <icmp_destun+0xf0>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 824b07c:	d0a08317 	ldw	r2,-32244(gp)
 824b080:	1080800c 	andi	r2,r2,512
 824b084:	10000326 	beq	r2,zero,824b094 <icmp_destun+0xd0>
         dprintf("icmp: can't alloc pkt\n");
 824b088:	01020974 	movhi	r4,2085
 824b08c:	21078b04 	addi	r4,r4,7724
 824b090:	82036240 	call	8203624 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 824b094:	008209b4 	movhi	r2,2086
 824b098:	10ba7f04 	addi	r2,r2,-5636
 824b09c:	10800e17 	ldw	r2,56(r2)
 824b0a0:	10c00044 	addi	r3,r2,1
 824b0a4:	008209b4 	movhi	r2,2086
 824b0a8:	10ba7f04 	addi	r2,r2,-5636
 824b0ac:	10c00e15 	stw	r3,56(r2)
      return;
 824b0b0:	00007f06 	br	824b2b0 <icmp_destun+0x2ec>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 824b0b4:	e0bff817 	ldw	r2,-32(fp)
 824b0b8:	10800317 	ldw	r2,12(r2)
 824b0bc:	e0bff915 	stw	r2,-28(fp)
   pip->ip_src = src_addr;
 824b0c0:	e0bff917 	ldw	r2,-28(fp)
 824b0c4:	e0fffd17 	ldw	r3,-12(fp)
 824b0c8:	10c00315 	stw	r3,12(r2)
   pip->ip_dest = host;
 824b0cc:	e0bff917 	ldw	r2,-28(fp)
 824b0d0:	e0fffc17 	ldw	r3,-16(fp)
 824b0d4:	10c00415 	stw	r3,16(r2)

   /* allow space for icmp header */
   p->nb_prot += sizeof(struct ip);
 824b0d8:	e0bff817 	ldw	r2,-32(fp)
 824b0dc:	10800317 	ldw	r2,12(r2)
 824b0e0:	10c00504 	addi	r3,r2,20
 824b0e4:	e0bff817 	ldw	r2,-32(fp)
 824b0e8:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= sizeof(struct ip);
 824b0ec:	e0bff817 	ldw	r2,-32(fp)
 824b0f0:	10800417 	ldw	r2,16(r2)
 824b0f4:	10fffb04 	addi	r3,r2,-20
 824b0f8:	e0bff817 	ldw	r2,-32(fp)
 824b0fc:	10c00415 	stw	r3,16(r2)
   p->net = net;     /* Put in the interface that this packet came in on */
 824b100:	e0bff817 	ldw	r2,-32(fp)
 824b104:	e0c00217 	ldw	r3,8(fp)
 824b108:	10c00615 	stw	r3,24(r2)

   d = (struct destun *)p->nb_prot;
 824b10c:	e0bff817 	ldw	r2,-32(fp)
 824b110:	10800317 	ldw	r2,12(r2)
 824b114:	e0bffa15 	stw	r2,-24(fp)

   if (typecode & 0xFF00)               /* if the type was sent */
 824b118:	e0bfff17 	ldw	r2,-4(fp)
 824b11c:	10bfc00c 	andi	r2,r2,65280
 824b120:	10000626 	beq	r2,zero,824b13c <icmp_destun+0x178>
      d->dtype = (char)(typecode >>8);  /* then use it */
 824b124:	e0bfff17 	ldw	r2,-4(fp)
 824b128:	1004d23a 	srli	r2,r2,8
 824b12c:	1007883a 	mov	r3,r2
 824b130:	e0bffa17 	ldw	r2,-24(fp)
 824b134:	10c00005 	stb	r3,0(r2)
 824b138:	00000306 	br	824b148 <icmp_destun+0x184>
   else                                 /* else use default */
      d->dtype = DESTIN;
 824b13c:	e0bffa17 	ldw	r2,-24(fp)
 824b140:	00c000c4 	movi	r3,3
 824b144:	10c00005 	stb	r3,0(r2)
   d->dcode = (char)(typecode & 0xFF);
 824b148:	e0bfff17 	ldw	r2,-4(fp)
 824b14c:	1007883a 	mov	r3,r2
 824b150:	e0bffa17 	ldw	r2,-24(fp)
 824b154:	10c00045 	stb	r3,1(r2)
   d->dno1 = d->dno2 = 0;
 824b158:	e0bffa17 	ldw	r2,-24(fp)
 824b15c:	1000018d 	sth	zero,6(r2)
 824b160:	e0bffa17 	ldw	r2,-24(fp)
 824b164:	10c0018b 	ldhu	r3,6(r2)
 824b168:	e0bffa17 	ldw	r2,-24(fp)
 824b16c:	10c0010d 	sth	r3,4(r2)
#ifndef ICMP_SUPPRESS_PMTU
   if ((typecode & 0xFF) == DSTFRAG)
 824b170:	e0bfff17 	ldw	r2,-4(fp)
 824b174:	10803fcc 	andi	r2,r2,255
 824b178:	10800118 	cmpnei	r2,r2,4
 824b17c:	1000121e 	bne	r2,zero,824b1c8 <icmp_destun+0x204>
      d->dno2 = htons(net->n_mtu - net->n_lnh);
 824b180:	e0800217 	ldw	r2,8(fp)
 824b184:	10c00917 	ldw	r3,36(r2)
 824b188:	e0800217 	ldw	r2,8(fp)
 824b18c:	10800817 	ldw	r2,32(r2)
 824b190:	1885c83a 	sub	r2,r3,r2
 824b194:	1005d23a 	srai	r2,r2,8
 824b198:	10803fcc 	andi	r2,r2,255
 824b19c:	1009883a 	mov	r4,r2
 824b1a0:	e0800217 	ldw	r2,8(fp)
 824b1a4:	10c00917 	ldw	r3,36(r2)
 824b1a8:	e0800217 	ldw	r2,8(fp)
 824b1ac:	10800817 	ldw	r2,32(r2)
 824b1b0:	1885c83a 	sub	r2,r3,r2
 824b1b4:	1004923a 	slli	r2,r2,8
 824b1b8:	2084b03a 	or	r2,r4,r2
 824b1bc:	1007883a 	mov	r3,r2
 824b1c0:	e0bffa17 	ldw	r2,-24(fp)
 824b1c4:	10c0018d 	sth	r3,6(r2)
#endif    /* ICMP_SUPPRESS_PMTU */
   MEMCPY(&d->dip, ip, (sizeof(struct ip) + ICMPDUDATA));
 824b1c8:	e0bffa17 	ldw	r2,-24(fp)
 824b1cc:	10800204 	addi	r2,r2,8
 824b1d0:	01800704 	movi	r6,28
 824b1d4:	e17ffe17 	ldw	r5,-8(fp)
 824b1d8:	1009883a 	mov	r4,r2
 824b1dc:	8202f100 	call	8202f10 <memcpy>

   d->dchksum = 0;
 824b1e0:	e0bffa17 	ldw	r2,-24(fp)
 824b1e4:	1000008d 	sth	zero,2(r2)
   d->dchksum = ~cksum(d, sizeof(struct destun)>>1);
 824b1e8:	01400484 	movi	r5,18
 824b1ec:	e13ffa17 	ldw	r4,-24(fp)
 824b1f0:	82287b40 	call	82287b4 <cksum>
 824b1f4:	0084303a 	nor	r2,zero,r2
 824b1f8:	1007883a 	mov	r3,r2
 824b1fc:	e0bffa17 	ldw	r2,-24(fp)
 824b200:	10c0008d 	sth	r3,2(r2)

   p->nb_plen =  sizeof(struct destun);
 824b204:	e0bff817 	ldw	r2,-32(fp)
 824b208:	00c00904 	movi	r3,36
 824b20c:	10c00415 	stw	r3,16(r2)
   p->fhost = host;
 824b210:	e0bff817 	ldw	r2,-32(fp)
 824b214:	e0fffc17 	ldw	r3,-16(fp)
 824b218:	10c00715 	stw	r3,28(r2)
   i = ip_write(ICMP_PROT, p);
 824b21c:	e17ff817 	ldw	r5,-32(fp)
 824b220:	01000044 	movi	r4,1
 824b224:	823f94c0 	call	823f94c <ip_write>
 824b228:	e0bffb15 	stw	r2,-20(fp)
   if (i < 0)
 824b22c:	e0bffb17 	ldw	r2,-20(fp)
 824b230:	10000e0e 	bge	r2,zero,824b26c <icmp_destun+0x2a8>
   {
      icmp_mib.icmpOutErrors++;
 824b234:	008209b4 	movhi	r2,2086
 824b238:	10ba7f04 	addi	r2,r2,-5636
 824b23c:	10800e17 	ldw	r2,56(r2)
 824b240:	10c00044 	addi	r3,r2,1
 824b244:	008209b4 	movhi	r2,2086
 824b248:	10ba7f04 	addi	r2,r2,-5636
 824b24c:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 824b250:	d0a08317 	ldw	r2,-32244(gp)
 824b254:	1080860c 	andi	r2,r2,536
 824b258:	10001426 	beq	r2,zero,824b2ac <icmp_destun+0x2e8>
         dprintf("ICMP: Can't send dest unreachable\n");
 824b25c:	01020974 	movhi	r4,2085
 824b260:	21079104 	addi	r4,r4,7748
 824b264:	82036240 	call	8203624 <puts>
#endif   /* NPDEBUG  */
      return;
 824b268:	00001006 	br	824b2ac <icmp_destun+0x2e8>
   }
   icmp_mib.icmpOutMsgs++;
 824b26c:	008209b4 	movhi	r2,2086
 824b270:	10ba7f04 	addi	r2,r2,-5636
 824b274:	10800d17 	ldw	r2,52(r2)
 824b278:	10c00044 	addi	r3,r2,1
 824b27c:	008209b4 	movhi	r2,2086
 824b280:	10ba7f04 	addi	r2,r2,-5636
 824b284:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutDestUnreachs++;
 824b288:	008209b4 	movhi	r2,2086
 824b28c:	10ba7f04 	addi	r2,r2,-5636
 824b290:	10800f17 	ldw	r2,60(r2)
 824b294:	10c00044 	addi	r3,r2,1
 824b298:	008209b4 	movhi	r2,2086
 824b29c:	10ba7f04 	addi	r2,r2,-5636
 824b2a0:	10c00f15 	stw	r3,60(r2)
   return;
 824b2a4:	0001883a 	nop
 824b2a8:	00000106 	br	824b2b0 <icmp_destun+0x2ec>
      icmp_mib.icmpOutErrors++;
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
         dprintf("ICMP: Can't send dest unreachable\n");
#endif   /* NPDEBUG  */
      return;
 824b2ac:	0001883a 	nop
   }
   icmp_mib.icmpOutMsgs++;
   icmp_mib.icmpOutDestUnreachs++;
   return;
}
 824b2b0:	e037883a 	mov	sp,fp
 824b2b4:	dfc00117 	ldw	ra,4(sp)
 824b2b8:	df000017 	ldw	fp,0(sp)
 824b2bc:	dec00204 	addi	sp,sp,8
 824b2c0:	f800283a 	ret

0824b2c4 <icmp_timex>:
 *
 * RETURNS: void
 */

void icmp_timex (struct ip * ip, char code) 
{
 824b2c4:	defff504 	addi	sp,sp,-44
 824b2c8:	dfc00a15 	stw	ra,40(sp)
 824b2cc:	df000915 	stw	fp,36(sp)
 824b2d0:	df000904 	addi	fp,sp,36
 824b2d4:	e13ffe15 	stw	r4,-8(fp)
 824b2d8:	2805883a 	mov	r2,r5
 824b2dc:	e0bfff05 	stb	r2,-4(fp)
   struct ip * pip;
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 824b2e0:	d0a08317 	ldw	r2,-32244(gp)
 824b2e4:	1080040c 	andi	r2,r2,16
 824b2e8:	10003026 	beq	r2,zero,824b3ac <icmp_timex+0xe8>
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824b2ec:	e17fff07 	ldb	r5,-4(fp)
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 824b2f0:	e0bffe17 	ldw	r2,-8(fp)
 824b2f4:	10800317 	ldw	r2,12(r2)
 824b2f8:	1004d23a 	srli	r2,r2,8
 824b2fc:	10c03fcc 	andi	r3,r2,255
 824b300:	e0bffe17 	ldw	r2,-8(fp)
 824b304:	10800317 	ldw	r2,12(r2)
 824b308:	1004923a 	slli	r2,r2,8
 824b30c:	10bfffcc 	andi	r2,r2,65535
 824b310:	1884b03a 	or	r2,r3,r2
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824b314:	11803fcc 	andi	r6,r2,255
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 824b318:	e0bffe17 	ldw	r2,-8(fp)
 824b31c:	10800317 	ldw	r2,12(r2)
 824b320:	1004d23a 	srli	r2,r2,8
 824b324:	10c03fcc 	andi	r3,r2,255
 824b328:	e0bffe17 	ldw	r2,-8(fp)
 824b32c:	10800317 	ldw	r2,12(r2)
 824b330:	1004923a 	slli	r2,r2,8
 824b334:	10bfffcc 	andi	r2,r2,65535
 824b338:	1884b03a 	or	r2,r3,r2
 824b33c:	1004d23a 	srli	r2,r2,8
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824b340:	11c03fcc 	andi	r7,r2,255
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 824b344:	e0bffe17 	ldw	r2,-8(fp)
 824b348:	10800317 	ldw	r2,12(r2)
 824b34c:	1004d23a 	srli	r2,r2,8
 824b350:	10c03fcc 	andi	r3,r2,255
 824b354:	e0bffe17 	ldw	r2,-8(fp)
 824b358:	10800317 	ldw	r2,12(r2)
 824b35c:	1004923a 	slli	r2,r2,8
 824b360:	10bfffcc 	andi	r2,r2,65535
 824b364:	1884b03a 	or	r2,r3,r2
 824b368:	1004d43a 	srli	r2,r2,16
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824b36c:	10803fcc 	andi	r2,r2,255
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 824b370:	e0fffe17 	ldw	r3,-8(fp)
 824b374:	18c00317 	ldw	r3,12(r3)
 824b378:	1806d23a 	srli	r3,r3,8
 824b37c:	19003fcc 	andi	r4,r3,255
 824b380:	e0fffe17 	ldw	r3,-8(fp)
 824b384:	18c00317 	ldw	r3,12(r3)
 824b388:	1806923a 	slli	r3,r3,8
 824b38c:	18ffffcc 	andi	r3,r3,65535
 824b390:	20c6b03a 	or	r3,r4,r3
 824b394:	1806d63a 	srli	r3,r3,24
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824b398:	d8c00115 	stw	r3,4(sp)
 824b39c:	d8800015 	stw	r2,0(sp)
 824b3a0:	01020974 	movhi	r4,2085
 824b3a4:	21079a04 	addi	r4,r4,7784
 824b3a8:	82033a00 	call	82033a0 <printf>
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
#endif   /* NPDEBUG */

   icmp_pkt_len = ICMPTIMEX_HDR_LEN + ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN;
 824b3ac:	e0bffe17 	ldw	r2,-8(fp)
 824b3b0:	10800003 	ldbu	r2,0(r2)
 824b3b4:	108003cc 	andi	r2,r2,15
 824b3b8:	1085883a 	add	r2,r2,r2
 824b3bc:	1085883a 	add	r2,r2,r2
 824b3c0:	10800404 	addi	r2,r2,16
 824b3c4:	e0bff905 	stb	r2,-28(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 824b3c8:	01000084 	movi	r4,2
 824b3cc:	822d8100 	call	822d810 <LOCK_NET_RESOURCE>
    * length of the "outer" IP header, length of the ICMP header (ICMPTIMEX_HDR_LEN,
    * 8 bytes), length of the "inner" IP header, and length of "user" data 
    * (ICMPTIMEX_PAYLOAD_DATA_LEN, 8 bytes) (just past the "inner" IP header).  The 
    * latter two items are from the packet that the ICMP Time Exceeded message is 
    * being sent in response to. */
   p = pk_alloc(MaxLnh + IPHSIZ + icmp_pkt_len);
 824b3d0:	e0bff903 	ldbu	r2,-28(fp)
 824b3d4:	d0e08117 	ldw	r3,-32252(gp)
 824b3d8:	10c5883a 	add	r2,r2,r3
 824b3dc:	10800504 	addi	r2,r2,20
 824b3e0:	1009883a 	mov	r4,r2
 824b3e4:	822c9ec0 	call	822c9ec <pk_alloc>
 824b3e8:	e0bffa15 	stw	r2,-24(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824b3ec:	01000084 	movi	r4,2
 824b3f0:	822d8d40 	call	822d8d4 <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 824b3f4:	e0bffa17 	ldw	r2,-24(fp)
 824b3f8:	10000e1e 	bne	r2,zero,824b434 <icmp_timex+0x170>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 824b3fc:	d0a08317 	ldw	r2,-32244(gp)
 824b400:	1080800c 	andi	r2,r2,512
 824b404:	10000326 	beq	r2,zero,824b414 <icmp_timex+0x150>
         dprintf("icmp: can't alloc pkt\n");
 824b408:	01020974 	movhi	r4,2085
 824b40c:	21078b04 	addi	r4,r4,7724
 824b410:	82036240 	call	8203624 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 824b414:	008209b4 	movhi	r2,2086
 824b418:	10ba7f04 	addi	r2,r2,-5636
 824b41c:	10800e17 	ldw	r2,56(r2)
 824b420:	10c00044 	addi	r3,r2,1
 824b424:	008209b4 	movhi	r2,2086
 824b428:	10ba7f04 	addi	r2,r2,-5636
 824b42c:	10c00e15 	stw	r3,56(r2)
      return;
 824b430:	00006406 	br	824b5c4 <icmp_timex+0x300>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 824b434:	e0bffa17 	ldw	r2,-24(fp)
 824b438:	10800317 	ldw	r2,12(r2)
 824b43c:	e0bffb15 	stw	r2,-20(fp)
   /* source IP address of packet is our address (i.e., destination IP address 
    * in the datagram whose reassembly timed out) */
   pip->ip_src = ip->ip_dest;
 824b440:	e0bffe17 	ldw	r2,-8(fp)
 824b444:	10c00417 	ldw	r3,16(r2)
 824b448:	e0bffb17 	ldw	r2,-20(fp)
 824b44c:	10c00315 	stw	r3,12(r2)
   /* the destination address is the same as the source IP address of the 
    * datagram whose reassembly timed out */
   pip->ip_dest = ip->ip_src;
 824b450:	e0bffe17 	ldw	r2,-8(fp)
 824b454:	10c00317 	ldw	r3,12(r2)
 824b458:	e0bffb17 	ldw	r2,-20(fp)
 824b45c:	10c00415 	stw	r3,16(r2)

   /* move past space for IP header to get to start of ICMP header */
   p->nb_prot += sizeof(struct ip);
 824b460:	e0bffa17 	ldw	r2,-24(fp)
 824b464:	10800317 	ldw	r2,12(r2)
 824b468:	10c00504 	addi	r3,r2,20
 824b46c:	e0bffa17 	ldw	r2,-24(fp)
 824b470:	10c00315 	stw	r3,12(r2)

   tx = (struct timex *) p->nb_prot;
 824b474:	e0bffa17 	ldw	r2,-24(fp)
 824b478:	10800317 	ldw	r2,12(r2)
 824b47c:	e0bffc15 	stw	r2,-16(fp)

   tx->ttype = TIMEX;
 824b480:	e0bffc17 	ldw	r2,-16(fp)
 824b484:	00c002c4 	movi	r3,11
 824b488:	10c00005 	stb	r3,0(r2)
   tx->tcode = code;
 824b48c:	e0bffc17 	ldw	r2,-16(fp)
 824b490:	e0ffff03 	ldbu	r3,-4(fp)
 824b494:	10c00045 	stb	r3,1(r2)
   tx->tno1 = tx->tno2 = 0;
 824b498:	e0bffc17 	ldw	r2,-16(fp)
 824b49c:	1000018d 	sth	zero,6(r2)
 824b4a0:	e0bffc17 	ldw	r2,-16(fp)
 824b4a4:	10c0018b 	ldhu	r3,6(r2)
 824b4a8:	e0bffc17 	ldw	r2,-16(fp)
 824b4ac:	10c0010d 	sth	r3,4(r2)
   MEMCPY(&tx->tip, ip, (ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN));
 824b4b0:	e0bffc17 	ldw	r2,-16(fp)
 824b4b4:	10c00204 	addi	r3,r2,8
 824b4b8:	e0bffe17 	ldw	r2,-8(fp)
 824b4bc:	10800003 	ldbu	r2,0(r2)
 824b4c0:	10803fcc 	andi	r2,r2,255
 824b4c4:	108003cc 	andi	r2,r2,15
 824b4c8:	1085883a 	add	r2,r2,r2
 824b4cc:	1085883a 	add	r2,r2,r2
 824b4d0:	10800204 	addi	r2,r2,8
 824b4d4:	100d883a 	mov	r6,r2
 824b4d8:	e17ffe17 	ldw	r5,-8(fp)
 824b4dc:	1809883a 	mov	r4,r3
 824b4e0:	8202f100 	call	8202f10 <memcpy>

   tx->tchksum = 0;
 824b4e4:	e0bffc17 	ldw	r2,-16(fp)
 824b4e8:	1000008d 	sth	zero,2(r2)
   tx->tchksum = ~cksum(tx, (icmp_pkt_len>>1));
 824b4ec:	e0bff903 	ldbu	r2,-28(fp)
 824b4f0:	1004d07a 	srli	r2,r2,1
 824b4f4:	10803fcc 	andi	r2,r2,255
 824b4f8:	100b883a 	mov	r5,r2
 824b4fc:	e13ffc17 	ldw	r4,-16(fp)
 824b500:	82287b40 	call	82287b4 <cksum>
 824b504:	0084303a 	nor	r2,zero,r2
 824b508:	1007883a 	mov	r3,r2
 824b50c:	e0bffc17 	ldw	r2,-16(fp)
 824b510:	10c0008d 	sth	r3,2(r2)

   p->nb_plen = icmp_pkt_len;
 824b514:	e0fff903 	ldbu	r3,-28(fp)
 824b518:	e0bffa17 	ldw	r2,-24(fp)
 824b51c:	10c00415 	stw	r3,16(r2)
   /* p->fhost is expected to be in network byte order */
   p->fhost = pip->ip_dest;
 824b520:	e0bffb17 	ldw	r2,-20(fp)
 824b524:	10c00417 	ldw	r3,16(r2)
 824b528:	e0bffa17 	ldw	r2,-24(fp)
 824b52c:	10c00715 	stw	r3,28(r2)
   i = ip_write(ICMP_PROT, p);
 824b530:	e17ffa17 	ldw	r5,-24(fp)
 824b534:	01000044 	movi	r4,1
 824b538:	823f94c0 	call	823f94c <ip_write>
 824b53c:	e0bffd15 	stw	r2,-12(fp)
   if (i < 0)
 824b540:	e0bffd17 	ldw	r2,-12(fp)
 824b544:	10000e0e 	bge	r2,zero,824b580 <icmp_timex+0x2bc>
   {
      icmp_mib.icmpOutErrors++;
 824b548:	008209b4 	movhi	r2,2086
 824b54c:	10ba7f04 	addi	r2,r2,-5636
 824b550:	10800e17 	ldw	r2,56(r2)
 824b554:	10c00044 	addi	r3,r2,1
 824b558:	008209b4 	movhi	r2,2086
 824b55c:	10ba7f04 	addi	r2,r2,-5636
 824b560:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 824b564:	d0a08317 	ldw	r2,-32244(gp)
 824b568:	1080860c 	andi	r2,r2,536
 824b56c:	10001426 	beq	r2,zero,824b5c0 <icmp_timex+0x2fc>
         dprintf("ICMP: Can't send Time Exceeded\n");
 824b570:	01020974 	movhi	r4,2085
 824b574:	2107aa04 	addi	r4,r4,7848
 824b578:	82036240 	call	8203624 <puts>
#endif   /* NPDEBUG  */
      return;
 824b57c:	00001006 	br	824b5c0 <icmp_timex+0x2fc>
   }
   icmp_mib.icmpOutMsgs++;
 824b580:	008209b4 	movhi	r2,2086
 824b584:	10ba7f04 	addi	r2,r2,-5636
 824b588:	10800d17 	ldw	r2,52(r2)
 824b58c:	10c00044 	addi	r3,r2,1
 824b590:	008209b4 	movhi	r2,2086
 824b594:	10ba7f04 	addi	r2,r2,-5636
 824b598:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutTimeExcds++;
 824b59c:	008209b4 	movhi	r2,2086
 824b5a0:	10ba7f04 	addi	r2,r2,-5636
 824b5a4:	10801017 	ldw	r2,64(r2)
 824b5a8:	10c00044 	addi	r3,r2,1
 824b5ac:	008209b4 	movhi	r2,2086
 824b5b0:	10ba7f04 	addi	r2,r2,-5636
 824b5b4:	10c01015 	stw	r3,64(r2)
   return;
 824b5b8:	0001883a 	nop
 824b5bc:	00000106 	br	824b5c4 <icmp_timex+0x300>
      icmp_mib.icmpOutErrors++;
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
         dprintf("ICMP: Can't send Time Exceeded\n");
#endif   /* NPDEBUG  */
      return;
 824b5c0:	0001883a 	nop
   }
   icmp_mib.icmpOutMsgs++;
   icmp_mib.icmpOutTimeExcds++;
   return;
}
 824b5c4:	e037883a 	mov	sp,fp
 824b5c8:	dfc00117 	ldw	ra,4(sp)
 824b5cc:	df000017 	ldw	fp,0(sp)
 824b5d0:	dec00204 	addi	sp,sp,8
 824b5d4:	f800283a 	ret

0824b5d8 <icmp_du>:
 * RETURNS: void
 */

void  
icmp_du(PACKET p, struct destun * pdp)
{
 824b5d8:	defffc04 	addi	sp,sp,-16
 824b5dc:	dfc00315 	stw	ra,12(sp)
 824b5e0:	df000215 	stw	fp,8(sp)
 824b5e4:	df000204 	addi	fp,sp,8
 824b5e8:	e13ffe15 	stw	r4,-8(fp)
 824b5ec:	e17fff15 	stw	r5,-4(fp)
   /* see if user app wants notification first */
   if (icmpdu_hook)
 824b5f0:	d0a0dc17 	ldw	r2,-31888(gp)
 824b5f4:	10000426 	beq	r2,zero,824b608 <icmp_du+0x30>
      icmpdu_hook(p, pdp);
 824b5f8:	d0a0dc17 	ldw	r2,-31888(gp)
 824b5fc:	e17fff17 	ldw	r5,-4(fp)
 824b600:	e13ffe17 	ldw	r4,-8(fp)
 824b604:	103ee83a 	callr	r2

#ifdef INCLUDE_TCP
   /* Tell the sockets layer so it can correct the problem. */
   so_icmpdu(p, pdp);   /* this call should free packet p */
 824b608:	e17fff17 	ldw	r5,-4(fp)
 824b60c:	e13ffe17 	ldw	r4,-8(fp)
 824b610:	822f6b00 	call	822f6b0 <so_icmpdu>
done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(p); /* else just free packet */
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif   /* INCLUDE_TCP */
}
 824b614:	0001883a 	nop
 824b618:	e037883a 	mov	sp,fp
 824b61c:	dfc00117 	ldw	ra,4(sp)
 824b620:	df000017 	ldw	fp,0(sp)
 824b624:	dec00204 	addi	sp,sp,8
 824b628:	f800283a 	ret

0824b62c <atexit>:
 824b62c:	200b883a 	mov	r5,r4
 824b630:	000f883a 	mov	r7,zero
 824b634:	000d883a 	mov	r6,zero
 824b638:	0009883a 	mov	r4,zero
 824b63c:	824bbf01 	jmpi	824bbf0 <__register_exitproc>

0824b640 <atoi>:
 824b640:	01800284 	movi	r6,10
 824b644:	000b883a 	mov	r5,zero
 824b648:	824bb3c1 	jmpi	824bb3c <strtol>

0824b64c <_atoi_r>:
 824b64c:	01c00284 	movi	r7,10
 824b650:	000d883a 	mov	r6,zero
 824b654:	824b9041 	jmpi	824b904 <_strtol_r>

0824b658 <exit>:
 824b658:	defffe04 	addi	sp,sp,-8
 824b65c:	000b883a 	mov	r5,zero
 824b660:	dc000015 	stw	r16,0(sp)
 824b664:	dfc00115 	stw	ra,4(sp)
 824b668:	2021883a 	mov	r16,r4
 824b66c:	824bd080 	call	824bd08 <__call_exitprocs>
 824b670:	00820974 	movhi	r2,2085
 824b674:	108f9804 	addi	r2,r2,15968
 824b678:	11000017 	ldw	r4,0(r2)
 824b67c:	20800f17 	ldw	r2,60(r4)
 824b680:	10000126 	beq	r2,zero,824b688 <exit+0x30>
 824b684:	103ee83a 	callr	r2
 824b688:	8009883a 	mov	r4,r16
 824b68c:	824bea00 	call	824bea0 <_exit>

0824b690 <malloc>:
 824b690:	00820974 	movhi	r2,2085
 824b694:	108f9904 	addi	r2,r2,15972
 824b698:	200b883a 	mov	r5,r4
 824b69c:	11000017 	ldw	r4,0(r2)
 824b6a0:	820bcec1 	jmpi	820bcec <_malloc_r>

0824b6a4 <free>:
 824b6a4:	00820974 	movhi	r2,2085
 824b6a8:	108f9904 	addi	r2,r2,15972
 824b6ac:	200b883a 	mov	r5,r4
 824b6b0:	11000017 	ldw	r4,0(r2)
 824b6b4:	820b1001 	jmpi	820b100 <_free_r>

0824b6b8 <strcpy>:
 824b6b8:	2906b03a 	or	r3,r5,r4
 824b6bc:	18c000cc 	andi	r3,r3,3
 824b6c0:	2005883a 	mov	r2,r4
 824b6c4:	1800161e 	bne	r3,zero,824b720 <strcpy+0x68>
 824b6c8:	29c00017 	ldw	r7,0(r5)
 824b6cc:	02ffbff4 	movhi	r11,65279
 824b6d0:	5affbfc4 	addi	r11,r11,-257
 824b6d4:	02a02074 	movhi	r10,32897
 824b6d8:	01c6303a 	nor	r3,zero,r7
 824b6dc:	3ac9883a 	add	r4,r7,r11
 824b6e0:	52a02004 	addi	r10,r10,-32640
 824b6e4:	20c6703a 	and	r3,r4,r3
 824b6e8:	1a86703a 	and	r3,r3,r10
 824b6ec:	18000c1e 	bne	r3,zero,824b720 <strcpy+0x68>
 824b6f0:	1011883a 	mov	r8,r2
 824b6f4:	41c00015 	stw	r7,0(r8)
 824b6f8:	29400104 	addi	r5,r5,4
 824b6fc:	29c00017 	ldw	r7,0(r5)
 824b700:	41800104 	addi	r6,r8,4
 824b704:	3011883a 	mov	r8,r6
 824b708:	3ad3883a 	add	r9,r7,r11
 824b70c:	01c6303a 	nor	r3,zero,r7
 824b710:	48c6703a 	and	r3,r9,r3
 824b714:	1a86703a 	and	r3,r3,r10
 824b718:	183ff626 	beq	r3,zero,824b6f4 <strcpy+0x3c>
 824b71c:	00000106 	br	824b724 <strcpy+0x6c>
 824b720:	100d883a 	mov	r6,r2
 824b724:	28c00003 	ldbu	r3,0(r5)
 824b728:	31800044 	addi	r6,r6,1
 824b72c:	29400044 	addi	r5,r5,1
 824b730:	30ffffc5 	stb	r3,-1(r6)
 824b734:	18c03fcc 	andi	r3,r3,255
 824b738:	18c0201c 	xori	r3,r3,128
 824b73c:	18ffe004 	addi	r3,r3,-128
 824b740:	183ff81e 	bne	r3,zero,824b724 <strcpy+0x6c>
 824b744:	f800283a 	ret

0824b748 <strncmp>:
 824b748:	30003126 	beq	r6,zero,824b810 <strncmp+0xc8>
 824b74c:	2144b03a 	or	r2,r4,r5
 824b750:	108000cc 	andi	r2,r2,3
 824b754:	10001e1e 	bne	r2,zero,824b7d0 <strncmp+0x88>
 824b758:	024000c4 	movi	r9,3
 824b75c:	49801c2e 	bgeu	r9,r6,824b7d0 <strncmp+0x88>
 824b760:	20800017 	ldw	r2,0(r4)
 824b764:	28c00017 	ldw	r3,0(r5)
 824b768:	10c0191e 	bne	r2,r3,824b7d0 <strncmp+0x88>
 824b76c:	31bfff04 	addi	r6,r6,-4
 824b770:	30002726 	beq	r6,zero,824b810 <strncmp+0xc8>
 824b774:	02ffbff4 	movhi	r11,65279
 824b778:	5affbfc4 	addi	r11,r11,-257
 824b77c:	0086303a 	nor	r3,zero,r2
 824b780:	02a02074 	movhi	r10,32897
 824b784:	12c5883a 	add	r2,r2,r11
 824b788:	52a02004 	addi	r10,r10,-32640
 824b78c:	10c4703a 	and	r2,r2,r3
 824b790:	1284703a 	and	r2,r2,r10
 824b794:	10000b26 	beq	r2,zero,824b7c4 <strncmp+0x7c>
 824b798:	00001d06 	br	824b810 <strncmp+0xc8>
 824b79c:	20c00017 	ldw	r3,0(r4)
 824b7a0:	29c00017 	ldw	r7,0(r5)
 824b7a4:	1ad1883a 	add	r8,r3,r11
 824b7a8:	00c4303a 	nor	r2,zero,r3
 824b7ac:	4084703a 	and	r2,r8,r2
 824b7b0:	1284703a 	and	r2,r2,r10
 824b7b4:	19c0061e 	bne	r3,r7,824b7d0 <strncmp+0x88>
 824b7b8:	31bfff04 	addi	r6,r6,-4
 824b7bc:	30001426 	beq	r6,zero,824b810 <strncmp+0xc8>
 824b7c0:	1000131e 	bne	r2,zero,824b810 <strncmp+0xc8>
 824b7c4:	21000104 	addi	r4,r4,4
 824b7c8:	29400104 	addi	r5,r5,4
 824b7cc:	49bff336 	bltu	r9,r6,824b79c <strncmp+0x54>
 824b7d0:	28800007 	ldb	r2,0(r5)
 824b7d4:	20c00007 	ldb	r3,0(r4)
 824b7d8:	31bfffc4 	addi	r6,r6,-1
 824b7dc:	10c0081e 	bne	r2,r3,824b800 <strncmp+0xb8>
 824b7e0:	30000b26 	beq	r6,zero,824b810 <strncmp+0xc8>
 824b7e4:	10000a26 	beq	r2,zero,824b810 <strncmp+0xc8>
 824b7e8:	21000044 	addi	r4,r4,1
 824b7ec:	29400044 	addi	r5,r5,1
 824b7f0:	20800007 	ldb	r2,0(r4)
 824b7f4:	28c00007 	ldb	r3,0(r5)
 824b7f8:	31bfffc4 	addi	r6,r6,-1
 824b7fc:	10fff826 	beq	r2,r3,824b7e0 <strncmp+0x98>
 824b800:	20800003 	ldbu	r2,0(r4)
 824b804:	28c00003 	ldbu	r3,0(r5)
 824b808:	10c5c83a 	sub	r2,r2,r3
 824b80c:	f800283a 	ret
 824b810:	0005883a 	mov	r2,zero
 824b814:	f800283a 	ret

0824b818 <strncpy>:
 824b818:	2906b03a 	or	r3,r5,r4
 824b81c:	18c000cc 	andi	r3,r3,3
 824b820:	2005883a 	mov	r2,r4
 824b824:	18002c1e 	bne	r3,zero,824b8d8 <strncpy+0xc0>
 824b828:	010000c4 	movi	r4,3
 824b82c:	21802a2e 	bgeu	r4,r6,824b8d8 <strncpy+0xc0>
 824b830:	033fbff4 	movhi	r12,65279
 824b834:	02e02074 	movhi	r11,32897
 824b838:	633fbfc4 	addi	r12,r12,-257
 824b83c:	5ae02004 	addi	r11,r11,-32640
 824b840:	100f883a 	mov	r7,r2
 824b844:	2a000017 	ldw	r8,0(r5)
 824b848:	3815883a 	mov	r10,r7
 824b84c:	4313883a 	add	r9,r8,r12
 824b850:	0206303a 	nor	r3,zero,r8
 824b854:	48c6703a 	and	r3,r9,r3
 824b858:	1ac6703a 	and	r3,r3,r11
 824b85c:	1800261e 	bne	r3,zero,824b8f8 <strncpy+0xe0>
 824b860:	39c00104 	addi	r7,r7,4
 824b864:	52000015 	stw	r8,0(r10)
 824b868:	31bfff04 	addi	r6,r6,-4
 824b86c:	3811883a 	mov	r8,r7
 824b870:	29400104 	addi	r5,r5,4
 824b874:	21bff336 	bltu	r4,r6,824b844 <strncpy+0x2c>
 824b878:	30001e26 	beq	r6,zero,824b8f4 <strncpy+0xdc>
 824b87c:	29c00003 	ldbu	r7,0(r5)
 824b880:	31bfffc4 	addi	r6,r6,-1
 824b884:	40c00044 	addi	r3,r8,1
 824b888:	41c00005 	stb	r7,0(r8)
 824b88c:	39c03fcc 	andi	r7,r7,255
 824b890:	39c0201c 	xori	r7,r7,128
 824b894:	39ffe004 	addi	r7,r7,-128
 824b898:	29400044 	addi	r5,r5,1
 824b89c:	38001026 	beq	r7,zero,824b8e0 <strncpy+0xc8>
 824b8a0:	1811883a 	mov	r8,r3
 824b8a4:	00000906 	br	824b8cc <strncpy+0xb4>
 824b8a8:	29c00003 	ldbu	r7,0(r5)
 824b8ac:	31bfffc4 	addi	r6,r6,-1
 824b8b0:	29400044 	addi	r5,r5,1
 824b8b4:	41c00005 	stb	r7,0(r8)
 824b8b8:	39c03fcc 	andi	r7,r7,255
 824b8bc:	39c0201c 	xori	r7,r7,128
 824b8c0:	39ffe004 	addi	r7,r7,-128
 824b8c4:	1811883a 	mov	r8,r3
 824b8c8:	38000526 	beq	r7,zero,824b8e0 <strncpy+0xc8>
 824b8cc:	18c00044 	addi	r3,r3,1
 824b8d0:	303ff51e 	bne	r6,zero,824b8a8 <strncpy+0x90>
 824b8d4:	f800283a 	ret
 824b8d8:	1011883a 	mov	r8,r2
 824b8dc:	003fe606 	br	824b878 <strncpy+0x60>
 824b8e0:	30000726 	beq	r6,zero,824b900 <strncpy+0xe8>
 824b8e4:	198d883a 	add	r6,r3,r6
 824b8e8:	18000005 	stb	zero,0(r3)
 824b8ec:	18c00044 	addi	r3,r3,1
 824b8f0:	19bffd1e 	bne	r3,r6,824b8e8 <strncpy+0xd0>
 824b8f4:	f800283a 	ret
 824b8f8:	3811883a 	mov	r8,r7
 824b8fc:	003fdf06 	br	824b87c <strncpy+0x64>
 824b900:	f800283a 	ret

0824b904 <_strtol_r>:
 824b904:	00820974 	movhi	r2,2085
 824b908:	defff404 	addi	sp,sp,-48
 824b90c:	108f9704 	addi	r2,r2,15964
 824b910:	dd400715 	stw	r21,28(sp)
 824b914:	15400017 	ldw	r21,0(r2)
 824b918:	dd800815 	stw	r22,32(sp)
 824b91c:	dd000615 	stw	r20,24(sp)
 824b920:	dcc00515 	stw	r19,20(sp)
 824b924:	d9000015 	stw	r4,0(sp)
 824b928:	dfc00b15 	stw	ra,44(sp)
 824b92c:	df000a15 	stw	fp,40(sp)
 824b930:	ddc00915 	stw	r23,36(sp)
 824b934:	dc800415 	stw	r18,16(sp)
 824b938:	dc400315 	stw	r17,12(sp)
 824b93c:	dc000215 	stw	r16,8(sp)
 824b940:	2829883a 	mov	r20,r5
 824b944:	3027883a 	mov	r19,r6
 824b948:	382d883a 	mov	r22,r7
 824b94c:	2809883a 	mov	r4,r5
 824b950:	24000003 	ldbu	r16,0(r4)
 824b954:	24400044 	addi	r17,r4,1
 824b958:	2007883a 	mov	r3,r4
 824b95c:	ac05883a 	add	r2,r21,r16
 824b960:	10800043 	ldbu	r2,1(r2)
 824b964:	8809883a 	mov	r4,r17
 824b968:	1080020c 	andi	r2,r2,8
 824b96c:	103ff81e 	bne	r2,zero,824b950 <_strtol_r+0x4c>
 824b970:	00800b44 	movi	r2,45
 824b974:	80805826 	beq	r16,r2,824bad8 <_strtol_r+0x1d4>
 824b978:	00800ac4 	movi	r2,43
 824b97c:	80805a26 	beq	r16,r2,824bae8 <_strtol_r+0x1e4>
 824b980:	0039883a 	mov	fp,zero
 824b984:	b0004426 	beq	r22,zero,824ba98 <_strtol_r+0x194>
 824b988:	00800404 	movi	r2,16
 824b98c:	b0806026 	beq	r22,r2,824bb10 <_strtol_r+0x20c>
 824b990:	b02f883a 	mov	r23,r22
 824b994:	00a00034 	movhi	r2,32768
 824b998:	e025003a 	cmpeq	r18,fp,zero
 824b99c:	14a5c83a 	sub	r18,r2,r18
 824b9a0:	b80b883a 	mov	r5,r23
 824b9a4:	9009883a 	mov	r4,r18
 824b9a8:	8202c740 	call	8202c74 <__umodsi3>
 824b9ac:	b80b883a 	mov	r5,r23
 824b9b0:	9009883a 	mov	r4,r18
 824b9b4:	d8800115 	stw	r2,4(sp)
 824b9b8:	8202c100 	call	8202c10 <__udivsi3>
 824b9bc:	ac07883a 	add	r3,r21,r16
 824b9c0:	18c00043 	ldbu	r3,1(r3)
 824b9c4:	880b883a 	mov	r5,r17
 824b9c8:	000d883a 	mov	r6,zero
 824b9cc:	1a00010c 	andi	r8,r3,4
 824b9d0:	0009883a 	mov	r4,zero
 824b9d4:	02800044 	movi	r10,1
 824b9d8:	027fffc4 	movi	r9,-1
 824b9dc:	d9c00117 	ldw	r7,4(sp)
 824b9e0:	40000e26 	beq	r8,zero,824ba1c <_strtol_r+0x118>
 824b9e4:	843ff404 	addi	r16,r16,-48
 824b9e8:	8580120e 	bge	r16,r22,824ba34 <_strtol_r+0x130>
 824b9ec:	32400526 	beq	r6,r9,824ba04 <_strtol_r+0x100>
 824b9f0:	11002536 	bltu	r2,r4,824ba88 <_strtol_r+0x184>
 824b9f4:	20802326 	beq	r4,r2,824ba84 <_strtol_r+0x180>
 824b9f8:	25c9383a 	mul	r4,r4,r23
 824b9fc:	01800044 	movi	r6,1
 824ba00:	8109883a 	add	r4,r16,r4
 824ba04:	2c000003 	ldbu	r16,0(r5)
 824ba08:	29400044 	addi	r5,r5,1
 824ba0c:	ac07883a 	add	r3,r21,r16
 824ba10:	18c00043 	ldbu	r3,1(r3)
 824ba14:	1a00010c 	andi	r8,r3,4
 824ba18:	403ff21e 	bne	r8,zero,824b9e4 <_strtol_r+0xe0>
 824ba1c:	18c000cc 	andi	r3,r3,3
 824ba20:	18000426 	beq	r3,zero,824ba34 <_strtol_r+0x130>
 824ba24:	1a801a26 	beq	r3,r10,824ba90 <_strtol_r+0x18c>
 824ba28:	00c015c4 	movi	r3,87
 824ba2c:	80e1c83a 	sub	r16,r16,r3
 824ba30:	85bfee16 	blt	r16,r22,824b9ec <_strtol_r+0xe8>
 824ba34:	00bfffc4 	movi	r2,-1
 824ba38:	30801e26 	beq	r6,r2,824bab4 <_strtol_r+0x1b0>
 824ba3c:	e0001b1e 	bne	fp,zero,824baac <_strtol_r+0x1a8>
 824ba40:	2005883a 	mov	r2,r4
 824ba44:	98000326 	beq	r19,zero,824ba54 <_strtol_r+0x150>
 824ba48:	3000211e 	bne	r6,zero,824bad0 <_strtol_r+0x1cc>
 824ba4c:	a00b883a 	mov	r5,r20
 824ba50:	99400015 	stw	r5,0(r19)
 824ba54:	dfc00b17 	ldw	ra,44(sp)
 824ba58:	df000a17 	ldw	fp,40(sp)
 824ba5c:	ddc00917 	ldw	r23,36(sp)
 824ba60:	dd800817 	ldw	r22,32(sp)
 824ba64:	dd400717 	ldw	r21,28(sp)
 824ba68:	dd000617 	ldw	r20,24(sp)
 824ba6c:	dcc00517 	ldw	r19,20(sp)
 824ba70:	dc800417 	ldw	r18,16(sp)
 824ba74:	dc400317 	ldw	r17,12(sp)
 824ba78:	dc000217 	ldw	r16,8(sp)
 824ba7c:	dec00c04 	addi	sp,sp,48
 824ba80:	f800283a 	ret
 824ba84:	3c3fdc0e 	bge	r7,r16,824b9f8 <_strtol_r+0xf4>
 824ba88:	01bfffc4 	movi	r6,-1
 824ba8c:	003fdd06 	br	824ba04 <_strtol_r+0x100>
 824ba90:	00c00dc4 	movi	r3,55
 824ba94:	003fe506 	br	824ba2c <_strtol_r+0x128>
 824ba98:	00800c04 	movi	r2,48
 824ba9c:	80801626 	beq	r16,r2,824baf8 <_strtol_r+0x1f4>
 824baa0:	05800284 	movi	r22,10
 824baa4:	b02f883a 	mov	r23,r22
 824baa8:	003fba06 	br	824b994 <_strtol_r+0x90>
 824baac:	0109c83a 	sub	r4,zero,r4
 824bab0:	003fe306 	br	824ba40 <_strtol_r+0x13c>
 824bab4:	d9000017 	ldw	r4,0(sp)
 824bab8:	00c00884 	movi	r3,34
 824babc:	e005003a 	cmpeq	r2,fp,zero
 824bac0:	20c00015 	stw	r3,0(r4)
 824bac4:	00e00034 	movhi	r3,32768
 824bac8:	1885c83a 	sub	r2,r3,r2
 824bacc:	983fe126 	beq	r19,zero,824ba54 <_strtol_r+0x150>
 824bad0:	297fffc4 	addi	r5,r5,-1
 824bad4:	003fde06 	br	824ba50 <_strtol_r+0x14c>
 824bad8:	1c400084 	addi	r17,r3,2
 824badc:	1c000043 	ldbu	r16,1(r3)
 824bae0:	07000044 	movi	fp,1
 824bae4:	003fa706 	br	824b984 <_strtol_r+0x80>
 824bae8:	1c400084 	addi	r17,r3,2
 824baec:	1c000043 	ldbu	r16,1(r3)
 824baf0:	0039883a 	mov	fp,zero
 824baf4:	003fa306 	br	824b984 <_strtol_r+0x80>
 824baf8:	88800003 	ldbu	r2,0(r17)
 824bafc:	00c01604 	movi	r3,88
 824bb00:	108037cc 	andi	r2,r2,223
 824bb04:	10c00826 	beq	r2,r3,824bb28 <_strtol_r+0x224>
 824bb08:	05800204 	movi	r22,8
 824bb0c:	003fa006 	br	824b990 <_strtol_r+0x8c>
 824bb10:	00800c04 	movi	r2,48
 824bb14:	80bf9e1e 	bne	r16,r2,824b990 <_strtol_r+0x8c>
 824bb18:	88800003 	ldbu	r2,0(r17)
 824bb1c:	00c01604 	movi	r3,88
 824bb20:	108037cc 	andi	r2,r2,223
 824bb24:	10ff9a1e 	bne	r2,r3,824b990 <_strtol_r+0x8c>
 824bb28:	05c00404 	movi	r23,16
 824bb2c:	8c000043 	ldbu	r16,1(r17)
 824bb30:	b82d883a 	mov	r22,r23
 824bb34:	8c400084 	addi	r17,r17,2
 824bb38:	003f9606 	br	824b994 <_strtol_r+0x90>

0824bb3c <strtol>:
 824bb3c:	00820974 	movhi	r2,2085
 824bb40:	108f9904 	addi	r2,r2,15972
 824bb44:	300f883a 	mov	r7,r6
 824bb48:	280d883a 	mov	r6,r5
 824bb4c:	200b883a 	mov	r5,r4
 824bb50:	11000017 	ldw	r4,0(r2)
 824bb54:	824b9041 	jmpi	824b904 <_strtol_r>

0824bb58 <vprintf>:
 824bb58:	00820974 	movhi	r2,2085
 824bb5c:	108f9904 	addi	r2,r2,15972
 824bb60:	200d883a 	mov	r6,r4
 824bb64:	11000017 	ldw	r4,0(r2)
 824bb68:	280f883a 	mov	r7,r5
 824bb6c:	21400217 	ldw	r5,8(r4)
 824bb70:	824be881 	jmpi	824be88 <_vfprintf_r>

0824bb74 <_vprintf_r>:
 824bb74:	300f883a 	mov	r7,r6
 824bb78:	280d883a 	mov	r6,r5
 824bb7c:	21400217 	ldw	r5,8(r4)
 824bb80:	824be881 	jmpi	824be88 <_vfprintf_r>

0824bb84 <_vsprintf_r>:
 824bb84:	00a00034 	movhi	r2,32768
 824bb88:	deffe504 	addi	sp,sp,-108
 824bb8c:	10bfffc4 	addi	r2,r2,-1
 824bb90:	2807883a 	mov	r3,r5
 824bb94:	02008204 	movi	r8,520
 824bb98:	d8800215 	stw	r2,8(sp)
 824bb9c:	d8800515 	stw	r2,20(sp)
 824bba0:	d80b883a 	mov	r5,sp
 824bba4:	00bfffc4 	movi	r2,-1
 824bba8:	d8c00015 	stw	r3,0(sp)
 824bbac:	d8c00415 	stw	r3,16(sp)
 824bbb0:	dfc01a15 	stw	ra,104(sp)
 824bbb4:	da00030d 	sth	r8,12(sp)
 824bbb8:	d880038d 	sth	r2,14(sp)
 824bbbc:	820485c0 	call	820485c <___svfprintf_internal_r>
 824bbc0:	d8c00017 	ldw	r3,0(sp)
 824bbc4:	18000005 	stb	zero,0(r3)
 824bbc8:	dfc01a17 	ldw	ra,104(sp)
 824bbcc:	dec01b04 	addi	sp,sp,108
 824bbd0:	f800283a 	ret

0824bbd4 <vsprintf>:
 824bbd4:	00820974 	movhi	r2,2085
 824bbd8:	108f9904 	addi	r2,r2,15972
 824bbdc:	300f883a 	mov	r7,r6
 824bbe0:	280d883a 	mov	r6,r5
 824bbe4:	200b883a 	mov	r5,r4
 824bbe8:	11000017 	ldw	r4,0(r2)
 824bbec:	824bb841 	jmpi	824bb84 <_vsprintf_r>

0824bbf0 <__register_exitproc>:
 824bbf0:	defffa04 	addi	sp,sp,-24
 824bbf4:	dc000315 	stw	r16,12(sp)
 824bbf8:	04020974 	movhi	r16,2085
 824bbfc:	840f9804 	addi	r16,r16,15968
 824bc00:	80c00017 	ldw	r3,0(r16)
 824bc04:	dc400415 	stw	r17,16(sp)
 824bc08:	dfc00515 	stw	ra,20(sp)
 824bc0c:	18805217 	ldw	r2,328(r3)
 824bc10:	2023883a 	mov	r17,r4
 824bc14:	10003726 	beq	r2,zero,824bcf4 <__register_exitproc+0x104>
 824bc18:	10c00117 	ldw	r3,4(r2)
 824bc1c:	010007c4 	movi	r4,31
 824bc20:	20c00e16 	blt	r4,r3,824bc5c <__register_exitproc+0x6c>
 824bc24:	1a000044 	addi	r8,r3,1
 824bc28:	8800221e 	bne	r17,zero,824bcb4 <__register_exitproc+0xc4>
 824bc2c:	18c00084 	addi	r3,r3,2
 824bc30:	18c7883a 	add	r3,r3,r3
 824bc34:	18c7883a 	add	r3,r3,r3
 824bc38:	12000115 	stw	r8,4(r2)
 824bc3c:	10c7883a 	add	r3,r2,r3
 824bc40:	19400015 	stw	r5,0(r3)
 824bc44:	0005883a 	mov	r2,zero
 824bc48:	dfc00517 	ldw	ra,20(sp)
 824bc4c:	dc400417 	ldw	r17,16(sp)
 824bc50:	dc000317 	ldw	r16,12(sp)
 824bc54:	dec00604 	addi	sp,sp,24
 824bc58:	f800283a 	ret
 824bc5c:	00820974 	movhi	r2,2085
 824bc60:	10ada404 	addi	r2,r2,-18800
 824bc64:	10002626 	beq	r2,zero,824bd00 <__register_exitproc+0x110>
 824bc68:	01006404 	movi	r4,400
 824bc6c:	d9400015 	stw	r5,0(sp)
 824bc70:	d9800115 	stw	r6,4(sp)
 824bc74:	d9c00215 	stw	r7,8(sp)
 824bc78:	824b6900 	call	824b690 <malloc>
 824bc7c:	d9400017 	ldw	r5,0(sp)
 824bc80:	d9800117 	ldw	r6,4(sp)
 824bc84:	d9c00217 	ldw	r7,8(sp)
 824bc88:	10001d26 	beq	r2,zero,824bd00 <__register_exitproc+0x110>
 824bc8c:	81000017 	ldw	r4,0(r16)
 824bc90:	10000115 	stw	zero,4(r2)
 824bc94:	02000044 	movi	r8,1
 824bc98:	22405217 	ldw	r9,328(r4)
 824bc9c:	0007883a 	mov	r3,zero
 824bca0:	12400015 	stw	r9,0(r2)
 824bca4:	20805215 	stw	r2,328(r4)
 824bca8:	10006215 	stw	zero,392(r2)
 824bcac:	10006315 	stw	zero,396(r2)
 824bcb0:	883fde26 	beq	r17,zero,824bc2c <__register_exitproc+0x3c>
 824bcb4:	18c9883a 	add	r4,r3,r3
 824bcb8:	2109883a 	add	r4,r4,r4
 824bcbc:	1109883a 	add	r4,r2,r4
 824bcc0:	21802215 	stw	r6,136(r4)
 824bcc4:	01800044 	movi	r6,1
 824bcc8:	12406217 	ldw	r9,392(r2)
 824bccc:	30cc983a 	sll	r6,r6,r3
 824bcd0:	4992b03a 	or	r9,r9,r6
 824bcd4:	12406215 	stw	r9,392(r2)
 824bcd8:	21c04215 	stw	r7,264(r4)
 824bcdc:	01000084 	movi	r4,2
 824bce0:	893fd21e 	bne	r17,r4,824bc2c <__register_exitproc+0x3c>
 824bce4:	11006317 	ldw	r4,396(r2)
 824bce8:	218cb03a 	or	r6,r4,r6
 824bcec:	11806315 	stw	r6,396(r2)
 824bcf0:	003fce06 	br	824bc2c <__register_exitproc+0x3c>
 824bcf4:	18805304 	addi	r2,r3,332
 824bcf8:	18805215 	stw	r2,328(r3)
 824bcfc:	003fc606 	br	824bc18 <__register_exitproc+0x28>
 824bd00:	00bfffc4 	movi	r2,-1
 824bd04:	003fd006 	br	824bc48 <__register_exitproc+0x58>

0824bd08 <__call_exitprocs>:
 824bd08:	defff504 	addi	sp,sp,-44
 824bd0c:	df000915 	stw	fp,36(sp)
 824bd10:	dd400615 	stw	r21,24(sp)
 824bd14:	dc800315 	stw	r18,12(sp)
 824bd18:	dfc00a15 	stw	ra,40(sp)
 824bd1c:	ddc00815 	stw	r23,32(sp)
 824bd20:	dd800715 	stw	r22,28(sp)
 824bd24:	dd000515 	stw	r20,20(sp)
 824bd28:	dcc00415 	stw	r19,16(sp)
 824bd2c:	dc400215 	stw	r17,8(sp)
 824bd30:	dc000115 	stw	r16,4(sp)
 824bd34:	d9000015 	stw	r4,0(sp)
 824bd38:	2839883a 	mov	fp,r5
 824bd3c:	04800044 	movi	r18,1
 824bd40:	057fffc4 	movi	r21,-1
 824bd44:	00820974 	movhi	r2,2085
 824bd48:	108f9804 	addi	r2,r2,15968
 824bd4c:	12000017 	ldw	r8,0(r2)
 824bd50:	45005217 	ldw	r20,328(r8)
 824bd54:	44c05204 	addi	r19,r8,328
 824bd58:	a0001c26 	beq	r20,zero,824bdcc <__call_exitprocs+0xc4>
 824bd5c:	a0800117 	ldw	r2,4(r20)
 824bd60:	15ffffc4 	addi	r23,r2,-1
 824bd64:	b8000d16 	blt	r23,zero,824bd9c <__call_exitprocs+0x94>
 824bd68:	14000044 	addi	r16,r2,1
 824bd6c:	8421883a 	add	r16,r16,r16
 824bd70:	8421883a 	add	r16,r16,r16
 824bd74:	84402004 	addi	r17,r16,128
 824bd78:	a463883a 	add	r17,r20,r17
 824bd7c:	a421883a 	add	r16,r20,r16
 824bd80:	e0001e26 	beq	fp,zero,824bdfc <__call_exitprocs+0xf4>
 824bd84:	80804017 	ldw	r2,256(r16)
 824bd88:	e0801c26 	beq	fp,r2,824bdfc <__call_exitprocs+0xf4>
 824bd8c:	bdffffc4 	addi	r23,r23,-1
 824bd90:	843fff04 	addi	r16,r16,-4
 824bd94:	8c7fff04 	addi	r17,r17,-4
 824bd98:	bd7ff91e 	bne	r23,r21,824bd80 <__call_exitprocs+0x78>
 824bd9c:	00820974 	movhi	r2,2085
 824bda0:	10ada904 	addi	r2,r2,-18780
 824bda4:	10000926 	beq	r2,zero,824bdcc <__call_exitprocs+0xc4>
 824bda8:	a0800117 	ldw	r2,4(r20)
 824bdac:	1000301e 	bne	r2,zero,824be70 <__call_exitprocs+0x168>
 824bdb0:	a0800017 	ldw	r2,0(r20)
 824bdb4:	10003226 	beq	r2,zero,824be80 <__call_exitprocs+0x178>
 824bdb8:	a009883a 	mov	r4,r20
 824bdbc:	98800015 	stw	r2,0(r19)
 824bdc0:	824b6a40 	call	824b6a4 <free>
 824bdc4:	9d000017 	ldw	r20,0(r19)
 824bdc8:	a03fe41e 	bne	r20,zero,824bd5c <__call_exitprocs+0x54>
 824bdcc:	dfc00a17 	ldw	ra,40(sp)
 824bdd0:	df000917 	ldw	fp,36(sp)
 824bdd4:	ddc00817 	ldw	r23,32(sp)
 824bdd8:	dd800717 	ldw	r22,28(sp)
 824bddc:	dd400617 	ldw	r21,24(sp)
 824bde0:	dd000517 	ldw	r20,20(sp)
 824bde4:	dcc00417 	ldw	r19,16(sp)
 824bde8:	dc800317 	ldw	r18,12(sp)
 824bdec:	dc400217 	ldw	r17,8(sp)
 824bdf0:	dc000117 	ldw	r16,4(sp)
 824bdf4:	dec00b04 	addi	sp,sp,44
 824bdf8:	f800283a 	ret
 824bdfc:	a0800117 	ldw	r2,4(r20)
 824be00:	80c00017 	ldw	r3,0(r16)
 824be04:	10bfffc4 	addi	r2,r2,-1
 824be08:	15c01426 	beq	r2,r23,824be5c <__call_exitprocs+0x154>
 824be0c:	80000015 	stw	zero,0(r16)
 824be10:	183fde26 	beq	r3,zero,824bd8c <__call_exitprocs+0x84>
 824be14:	95c8983a 	sll	r4,r18,r23
 824be18:	a0806217 	ldw	r2,392(r20)
 824be1c:	a5800117 	ldw	r22,4(r20)
 824be20:	2084703a 	and	r2,r4,r2
 824be24:	10000b26 	beq	r2,zero,824be54 <__call_exitprocs+0x14c>
 824be28:	a0806317 	ldw	r2,396(r20)
 824be2c:	2088703a 	and	r4,r4,r2
 824be30:	20000c1e 	bne	r4,zero,824be64 <__call_exitprocs+0x15c>
 824be34:	89400017 	ldw	r5,0(r17)
 824be38:	d9000017 	ldw	r4,0(sp)
 824be3c:	183ee83a 	callr	r3
 824be40:	a0800117 	ldw	r2,4(r20)
 824be44:	15bfbf1e 	bne	r2,r22,824bd44 <__call_exitprocs+0x3c>
 824be48:	98800017 	ldw	r2,0(r19)
 824be4c:	153fcf26 	beq	r2,r20,824bd8c <__call_exitprocs+0x84>
 824be50:	003fbc06 	br	824bd44 <__call_exitprocs+0x3c>
 824be54:	183ee83a 	callr	r3
 824be58:	003ff906 	br	824be40 <__call_exitprocs+0x138>
 824be5c:	a5c00115 	stw	r23,4(r20)
 824be60:	003feb06 	br	824be10 <__call_exitprocs+0x108>
 824be64:	89000017 	ldw	r4,0(r17)
 824be68:	183ee83a 	callr	r3
 824be6c:	003ff406 	br	824be40 <__call_exitprocs+0x138>
 824be70:	a0800017 	ldw	r2,0(r20)
 824be74:	a027883a 	mov	r19,r20
 824be78:	1029883a 	mov	r20,r2
 824be7c:	003fb606 	br	824bd58 <__call_exitprocs+0x50>
 824be80:	0005883a 	mov	r2,zero
 824be84:	003ffb06 	br	824be74 <__call_exitprocs+0x16c>

0824be88 <_vfprintf_r>:
 824be88:	deffff04 	addi	sp,sp,-4
 824be8c:	dfc00015 	stw	ra,0(sp)
 824be90:	8206a3c0 	call	8206a3c <___vfprintf_internal_r>
 824be94:	dfc00017 	ldw	ra,0(sp)
 824be98:	dec00104 	addi	sp,sp,4
 824be9c:	f800283a 	ret

0824bea0 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 824bea0:	defffd04 	addi	sp,sp,-12
 824bea4:	df000215 	stw	fp,8(sp)
 824bea8:	df000204 	addi	fp,sp,8
 824beac:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 824beb0:	d0206b45 	stb	zero,-32339(gp)
 824beb4:	e0bfff17 	ldw	r2,-4(fp)
 824beb8:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 824bebc:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 824bec0:	10000226 	beq	r2,zero,824becc <_exit+0x2c>
    ALT_SIM_FAIL();
 824bec4:	002af070 	cmpltui	zero,zero,43969
 824bec8:	00000106 	br	824bed0 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
 824becc:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 824bed0:	003fff06 	br	824bed0 <_exit+0x30>
